!-*-BLISS-*-
!<BLF/NOERROR>
!<BLF/WIDTH:116>
!<BLF/REMARK:8>
!<BLF/NOPLIT>
!<BLF/MACRO>
!<BLF/LOWERCASE_KEY>
!<BLF/UPPERCASE_USER>
module SOR$SORT_ROUTIN (language (bliss32) ,
		list (assembly) ,
		unames,
		addressing_mode (external = general) ,
		ident = 'V03-001'
		) =
begin
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! Facility:
!
!	SORT
!
! Abstract:
!
!	This module contains the main sorting routines.
!
!
! Environment:
!
!	Starlet Operating System, User mode utility
!
!
! Author:
!
!	Ellen R Simich,		Creation Date:		1-Sep-77
!
!
! MODIFIED BY :
!
!
!	V03.01		PDG0301		PDG		4-Mar-1982
!		Some changes to avoid comparing uninitialized records.
!		Also, check for at least 2 nodes in the tree.
!	V02.06		PDG0006		Peter D Gilbert	8-Feb-1982
!		Clean up usage of SHR$ errors.
!	V02.05		JDN0005		Joe Neumeister	21-Sep-1981
!		Change SOR$GV_FLAGS from a bitvector [16] to a 
!    		    bitvector [32] to allow new switches, (/STATISTICS);
!		Define a new global constant SOR$GK_LOG_STATS and
!		    set it equal to 16, (thus referencing the first
!		    bit of the second word of SOR$GV_FLAGS).
!	V02.04		VLB0004		Vick Bennison	11-Sep-1981
!		Initialize SOR$GL_TOT_ALQ in SOR$INIT_SORT
!	V02.03		VLB0003		Vick Bennison	08-Sep-1981
!		Modify test for NO_MERGE at END_OF_FILE
!	V02.02		JDN0002		Joe Neumeister	19-Jun-1981
!		Change addressing mode to (external = general) for module.
!	V02.01		JDN0001		Joe Neumeister	12-Feb-1981
!		Remove locking of working set if subroutine, calculate
!		    tree node size in CALC_MIN_STORAGE (SCRIO.b32).
!		Declare ERROR symbols as external literals to allow
!		    new error messages to be outputted.
!--

!
! TABLE OF CONTENTS:
!

macro
    MAP_REGS =
	START_ADR = 11 %,
    ARGS =
	0, 0, 8, 0 %,
    PTR_TO_LOSER =
	0, 0, 32, 0 %,						! Prefix to each tree node
    INT_EXT_PTR =
	1, 0, 32, 0 %,
    INT_INT_PTR =
	2, 0, 32, 0 %,
    LOSER_RUN_NUM =
	3, 0, 32, 0 %,
    RECORD_SIZE =
	4, 0, 32, 0 %,
    KEY_TYPE =
	0, 0, 8, 0 %,
    SEG_SIZE =
	1, 0, 8, 0 %,
    SEG_POS =
	2, 0, 8, 0 %,
    SEG_ORDER =
	3, 0, 8, 0 %;

linkage
    CALLR = call : global (MAP_REGS),
    JSBR = jsb : global (MAP_REGS),
    JSBR2 = jsb (register = 9, register = 10),
    JSBR1 = jsb (register = 8) : global (MAP_REGS),
    JSBL = jsb;

forward routine
    OUTPUT_RECORD : JSBR1,					! Output record from sort
    SOR$SORT_MERGE,						! Initial dispersion algorithm
    LIST_INSERTION : JSBL novalue,				! Merge list insertion by key
    MERGE0 : CALLR,						! Merging algorithm
    INIT_TREE : JSBL novalue;					! Initialize sort tree

!
! INCLUDE FILES:
!

library 'SYS$LIBRARY:STARLET.L32';


!
! MACROS:
!
!
! EQUATED SYMBOLS:
!

global literal
    SOR$GK_FILE_IO = 0,						! User passed filename not records
    SOR$GK_SORT1 = 1,						! Sort in progress bits
    SOR$GK_SORT2 = 2,
    SOR$GK_SORT3 = 3,
    SOR$GK_SORT4 = 4,
    SOR$GK_SORT5 = 5,
    SOR$GK_SORT6 = 6,
    SOR$GK_NO_MERGE = 7,					! Indicate no merge passes needed
    SOR$GK_UTILITY = 8,						! Indicates utility running
    SOR$GK_FINAL = 9,						! Final merge pass
    SOR$GK_MERGE2 = 10,						! Lit by INIT_MERGE
    SOR$GK_USER_CMP = 11,					! User supplied comparison routine.
    SOR$GK_STABLE = 12,						! Stable sort.
    SOR$GK_EBCDIC = 13,						! EBCDIC collating sequence for char keys.
    SOR$GK_CHK_SEQ = 14,					! Check input file sequence on merge.
    SOR$GK_LOAD_FIL = 15,					! /LOAD_FILL
    SOR$GK_RECORD = 1,						! Sort types
    SOR$GK_TAG = 2,
    SOR$GK_INDEX = 3,
    SOR$GK_ADDRESS = 4,

! User option flags.
    SOR$V_STABLE = 0,						! User flag for stable sort.
    SOR$V_EBCDIC = 1,						! User flag for EBCDIC collating sequence.
    SOR$V_SEQ_CHECK = 2,					! Check sequence on merge input.
    SOR$M_STABLE = 1,						! Stable sort (mask)
    SOR$M_EBCDIC = 2,						! EBCDIC collating sequence (mask)
    SOR$M_SEQ_CHECK = 4,					! Check sequence on merge.
    SOR$GK_LOG_STATS = 16;					! Print SORT/MERGE statistics.  --JDN


literal
    ERROR = 0,
    REC_NUM_SIZE = 4,						! Size of record number for STABLE sort.
    MAX_CHAR = 255,						! Max number of characters per key.
    SUCCESS = 1,
    SORT_ERROR = 28;
MACRO
    DEFSHR_[MSG,SEV] =
	%NAME('SOR$_',MSG) =
		%NAME('SHR$_',MSG) +
		%NAME('STS$K_',SEV) + SORT_ERROR ^ 16 %;
LITERAL
    DEFSHR_(
	OPENOUT,  SEVERE);

psect
    global = SOR$SORTDATA ( addressing_mode (general)),
    own = SOR$SORTDATA ( addressing_mode (general));

!
! OWN STORAGE:
!

global
    SOR$GL_SAVE_SIZ,						! Size of LAST_KEY buffer.
    SOR$GL_SAVE_ADR,						! Address of LAST_KEY buffer.
    SOR$GL_REC_SIZE,						! Size of tree node
    SOR$GL_IN_ALQ,						! File size
    SOR$GW_IN_LRL : word,					! Longest record length
    SOR$GL_NUM_NODS,						! Number of nodes in the sort tree.
    SOR$GW_FIX_SIZE : word initial (%x'FFFF'),			! Sized of fixed area for VFC records
    SOR$GV_FLAGS : bitvector [32],				! Sort flags, (longword --JDN).
    SOR$GL_KEY_COMP,						! User key comparison address.
    SOR$GB_NO_SCR : byte,					! TRUE if scratch files have not been created yet.
    SOR$GB_SOR_TYP : byte initial (1);				! Sort to perform

own
    NUMBER_OF_NODES,
    NUMBER_OF_RUNS,						! Sort algorithm variables
    TREE1,
    END_LIST,
    CURRENT_RUN,
    LAST_KEY,
    SAVE_SIZE,
    CURRENT_OUT_BUF,
    WINNER_RUN_NUM,
    PTR_TO_NODE,
    PTR_TO_WINNER,
    EOS,							! End of string value.
    NUM_RECS,
    END_OF_FILE : byte;


compiletime
    PERFORMANCE = 0;						! Performance measurement.


external routine
    %if PERFORMANCE %then
    PME_INIT,							! Performance measurement exit.
    %fi

    LIB$ESTABLISH : addressing_mode (general),
    LIB$SIG_TO_RET : addressing_mode (general),
    LIB$SCOPY_R_DX : addressing_mode (general),		! Copy to any class string.
    LIB$GET_VM : addressing_mode (general),
    SOR$$COND_HAND,						! Handle exception conditions
    SOR$$ERROR : novalue weak,
    SOR$$SORT_GET : weak,
    SOR$$INIT_KEYS : weak,					! Set up key buffer
    SOR$$CREATE_SCR,						! Create scratch file
    SOR$$GET_SPACE,						! Get WS and VM
    SOR$$PUT_RECORD : JSBL weak,				! Put a record to a file
    SOR$$LOCK_PAGES,						! Lock pages in working set.
    SOR$$UNLOCK_GRP,						! Unlock a group of pages.
    SOR$$INIT_GROUP,						! Initialize page locking.
    SOR$$CREATE_OUT : weak,					! Create the output file.
    SOR$$MAP_RUN : JSBL,					! Map work file to memory
    SOR$$RET_MERGE : weak,					! Return record from merge utility.
    SOR$$MERGE_PASS : CALLR,					! Initialize work area for merge
    SOR$$OUT_RAB : weak,					! Initialize RAB for output
    SOR$$GEN_KEY : novalue,					! Generate a key routine.
    SOR$$BUILD_KEY,						! Extract key from record
    SOR$$CMPG,						! Grand floating compare.
    SOR$$CMPH,							! Huge floating compare.
    SOR$$MAP_VM : JSBR;						! Map memory to work file

external
    SOR$GW_MAX_LRL : word,					! Largest LRL in all input files.
    SOR$GW_MAX_MRS : word,					! Largest MRS in all input files.
    SOR$GL_TOT_ALQ,						! Total input allocation.
    SOR$GB_WRK_FIL : byte,
    SOR$GB_MERGE : byte,
    SOR$GL_BUF_END,
    SOR$AL_STATS : vector [16] weak,				! Statistics buffer
    SOR$GL_IN_BUF,						! Input buffer area
    SOR$AL_BUF_ADR : ref blockvector [10, 21, byte],
    SOR$GL_OUT_BUF,
    SOR$GB_INP_SIZ: byte weak,
    SOR$GL_TREE,
    SOR$GB_CUR_FILE : byte weak,				! Current input file.
    SOR$GB_NUM_FILE : byte weak,				! Number of input files.
    SOR$GL_DDB_PTR : weak,					! Pointer to input file DDB
    SOR$GV_DDB_TABL : vector [],				! Table of DDBs for each input file.
    SOR$GL_TREE_SIZ,
    SOR$GB_KEY_SIZE : byte,
    SOR$GL_REC_CNT,						! Count of records read. (STABLE sort)
    SOR$GB_REC_NUM : byte,					! Position of record number in key.
    SOR$GB_NUM_KEYS : byte,
    SOR$GB_NUM_SEGS : byte,					! Number of key segments (combined keys)
    SOR$AB_KEY_TYPE : vector [,byte],				! Key types.
    SOR$AB_KEY_SIZE : vector [,byte],				! Key sizes
    SOR$AB_KEY_POS  : vector [,byte],				! Key positions.
    SOR$AB_KEY_ORDR : vector [,byte];				! Key orders.

external literal
    SOR$GK_LEN_SIZE : unsigned (4),				! Length of record size field.
    SOR$GK_NODE_HED : unsigned (5),				! Length of tree node header.
    SOR$GK_CHAR_KEY : unsigned (1),                             ! Character
    SOR$GK_BIN_KEY : unsigned (2),                              ! Binary
    SOR$GK_ZONE_KEY : unsigned (2),                             ! Zoned decimal
    SOR$GK_PACK_KEY : unsigned (3),                             ! Packed decimal
    SOR$GK_USB_KEY : unsigned (3),                              ! Unsigned Binary
    SOR$GK_DLO_KEY : unsigned (3),                              ! Decimal leading overpunch sign
    SOR$GK_DLS_KEY : unsigned (3),                              ! Decimal leading separate sign
    SOR$GK_DTO_KEY : unsigned (4),                              ! Decimal trailing overpunch sign
    SOR$GK_DTS_KEY : unsigned (4),                              ! Decimal tailing separate sign
    SOR$GK_FLT_KEY : unsigned (4),                              ! Floating point
    SOR$GK_FLTD_KEY : unsigned (4),                             ! Double precision floating point
    SOR$GK_FLTG_KEY : unsigned (4),                             ! G_floating floating point
    SOR$GK_FLTH_KEY : unsigned (4),                             ! H_floating floating point
    SOR$_MISS_KEY,				! Declare ERROR symbols
    SOR$_WORK_DEV,				!  as external literals
    SOR$_NO_WRK,
    SOR$_VM_FAIL,
    SOR$_WS_FAIL,
    SOR$_SORT_ON,
    SOR$_BAD_KEY,
    SOR$_NUM_KEY,
    SOR$_BAD_LEN,
    SOR$_ONE_IN,
    SOR$_IND_OVR,
    SOR$_INCONSIS,
    SOR$_VAR_FIX,
    SOR$_BAD_TYPE,
    SOR$_LRL_MISS,
    SOR$_BAD_SPEC,
    SOR$_BAD_LRL,
    SOR$_BAD_FILE,
    SOR$_BAD_ADR,
    SOR$_MAP,
    SOR$_EXTEND,
    SOR$_KEY_LEN,
    SOR$_CLEAN_UP,
    SOR$_BAD_MERGE,
    SOR$_BAD_ROUTIN,
    SOR$_INP_FILES,
    SOR$_BAD_ORDER;


macro
    RECORD_LEN (A) = block [(A), 0, 0, 8 * SOR$GK_LEN_SIZE, 0; ,byte] %;	! Access record length.

macro
    KEY_START = SOR$GK_LEN_SIZE + SOR$GK_NODE_HED%;


psect
    code = SOR$SORTINIT;


%title 'SOR$INIT_SORT'

global routine SOR$INIT_SORT (KEY_PTR_ADR, LRL_ADR, FILE_SIZE_ADR, NUM_WRK_FIL_ADR, SORT_TYPE_ADR, TKS, COMPARE, FLAGS) :
    =

!++
! Functional Description:
!
!	This routine initializes the sort work area and the scratch
!	files.
!
!
! Formal Parameters:
!
!	The sort to perform, the key buffer address, or the total key size and
!	the address of a user written key comparison routine, optionally the
!	number of work files, the longest record length and the file size to
!	allocate for the work files if records are being passed, 0 otherwise.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!	An error code on error.
!
!
! Completion Codes:
!
!	1 for sucess.
!
!
! Side Effects:
!
!	The work files are created, the working set is extended and the
!	virtual memory is extended.
!
!
!--

    begin

    builtin
	ap;

    map
	FLAGS : ref bitvector [32],
	ap : ref block [, byte];

    literal
	USER_CALL = 4,
	SORT_ON = 124,
	DEFAULT_FILE = 1000;					! Default file size

    bind
	NUM_WRK_FIL = .NUM_WRK_FIL_ADR : vector [, byte],
	SORT_TYPE = .SORT_TYPE_ADR : vector [, byte],
	LRL = .LRL_ADR : vector [, word],
	FILE_SIZE = .FILE_SIZE_ADR : vector,
	KEY_PTR = .KEY_PTR_ADR : vector;

    local
	ERROR_CODE;						! Error return

!
! Sort is not reentrant therefore if a sort is in progress return error.
!

    if (.SOR$GV_FLAGS and SORT_ON) neq 0 then return SOR$_SORT_ON;

    EOS = (1 ^ (SOR$GK_LEN_SIZE * 8)) - 1;			! Calculate end of run flag.  All ones in length field.

    SOR$GV_FLAGS [SOR$GK_SORT2] = 1;				! Set sort 2nd call on


!------------------------change-----------------------------------
!initialize SOR$GL_TOT_ALQ so that callable SORT works properly
!on multiple calls    -VLB
!-----------------------------------------------------------------
    SOR$GL_TOT_ALQ = 0;		!total allocation for all input files

    !
    ! Check all parameters passed by the call for validity.
    !

    if not .SOR$GV_FLAGS [SOR$GK_UTILITY]			! If subroutine package
    then
	begin
	LIB$ESTABLISH (LIB$SIG_TO_RET);

	if .ap [ARGS]  geq 8 then
	    if .FLAGS neq 0 then
		begin
		    if .FLAGS [SOR$V_STABLE] then SOR$GV_FLAGS [SOR$GK_STABLE] = 1;
		    if .FLAGS [SOR$V_EBCDIC] then SOR$GV_FLAGS [SOR$GK_EBCDIC] = 1;
		    end;


	if .SOR$GV_FLAGS [SOR$GK_FILE_IO]			! If file name passed
	then
	    begin


	    if .ap [ARGS] gtru 4
	    then

		if SORT_TYPE [0] neq 0
		then

		    if .SORT_TYPE [0] gtru SOR$GK_ADDRESS then return SOR$_BAD_TYPE;	! 1-4 valid types

	    if .ap [ARGS] gtru 1
	    then

		if LRL [0] neq 0
		then

		    if .LRL [0] leq 0 then return SOR$_BAD_LRL else SOR$GW_IN_LRL = .LRL [0];

	    end
	else 							! If records passed must have LRL
	    begin

	    if .ap [ARGS] gtru 4
	    then

		if SORT_TYPE [0] neq 0 then return SOR$_BAD_TYPE;	! No sort type except record

	    if .ap [ARGS] lssu 2 or LRL [0] leq 0 then return SOR$_LRL_MISS;	! Must specify LRL

	    if .LRL [0] leq 0 then return SOR$_BAD_LRL else SOR$GW_IN_LRL = .LRL [0];

	    end;

	end;

    if .ap [ARGS] gtru 0
    then

	if .SOR$GV_FLAGS [SOR$GK_UTILITY] or
	  (KEY_PTR [0] neq 0 and .KEY_PTR [0] neq 0)
	then
	    begin
	    !
	    ! The user must pass either the key buffer info or a user key
	    ! comparison routine address and a total key size.  If the user does
	    ! not wish to prefix the key to the record the total key size may be
	    ! set to 0. Copy key information into buffer or set up compare routine
	    ! to fall through to user call.
	    !
	    ERROR_CODE = SOR$$INIT_KEYS (KEY_PTR [0]);

	    if not .ERROR_CODE then return .ERROR_CODE;

	    end
	else

	    if .ap [ARGS] lssu 7
	    then
		return SOR$_MISS_KEY
	    else
		begin

		if .TKS neq 0 then SOR$GB_KEY_SIZE = ..TKS;

		!
		! If stable sort, then we must account for the
		! record number.  This takes up 4 bytes in the
		! key position of the record.
		!

		if .SOR$GV_FLAGS [SOR$GK_STABLE] then

		    begin
			if .SOR$GB_KEY_SIZE + REC_NUM_SIZE gtr MAX_CHAR then return SOR$_KEY_LEN;
			SOR$GB_KEY_SIZE = .SOR$GB_KEY_SIZE + REC_NUM_SIZE;  	! Add record number to key.
			SOR$GB_REC_NUM = 0;					! Starts at the beginning of the key.
			end;

		SOR$GV_FLAGS [SOR$GK_USER_CMP] = 1;	! Flag that user has passed key compare routine.
		SOR$GL_KEY_COMP = .COMPARE;
		SOR$GB_NUM_KEYS = 1;
		SOR$GB_NUM_SEGS = 1;		! Number of key segments.
		SOR$AB_KEY_TYPE [0] = USER_CALL;
		SOR$AB_KEY_ORDR [0] = 0;	! Force ascending order.
		SOR$$GEN_KEY ();		! Generate a key compare routine.
		end;


    if .ap [ARGS] gtru 3
    then

	if NUM_WRK_FIL [0] neq 0  then SOR$GB_WRK_FIL = .NUM_WRK_FIL [0];

    if .SOR$GB_WRK_FIL eql 0 then SOR$GV_FLAGS [SOR$GK_NO_MERGE] = 1;

    if .ap [ARGS] gtru 4
    then

	if SORT_TYPE [0] neq 0 then SOR$GB_SOR_TYP = .SORT_TYPE [0];



    !
    ! If FILE_IO, then create the output file and set up input file
    ! pointers.
    !

    if .SOR$GV_FLAGS [SOR$GK_FILE_IO] then

	begin

	    !
	    ! Check for errors if not record sort.
	    !
	    if .SOR$GB_SOR_TYP neq SOR$GK_RECORD then

		begin
!		    if .SOR$GV_FLAGS [SOR$GK_USER_CMP] then return SOR$_BAD_KEY;
		    if .SOR$GB_NUM_FILE gtr 1 then return SOR$_INP_FILES;
		    end;

	    SOR$$INIT_GROUP ();				! Initialize group page locking.

	    SOR$GW_IN_LRL = maxu (.SOR$GW_IN_LRL, .SOR$GW_MAX_LRL);		! Use maximum lrl of input files.
	    if .SOR$GL_IN_ALQ eql 0 then SOR$GL_IN_ALQ = .SOR$GL_TOT_ALQ;  ! Use total input file allocation.
	    SOR$GL_DDB_PTR = .SOR$GV_DDB_TABL [0];	! Use parameters from 1st file
							! as defaults for output file.
	    SOR$GB_CUR_FILE = -1;			! Havn't connected the 1st file yet.
	    ERROR_CODE = SOR$$CREATE_OUT ();		! Create the output file.
	    if not .ERROR_CODE then return .ERROR_CODE;	! Return if error.
	    end;

    if .SOR$GL_IN_ALQ eql 0
    then

	if .ap [ARGS] gtru 2
	then

	    if FILE_SIZE [0] neq 0
	    then

		if .FILE_SIZE [0] leq 0 then return SOR$_BAD_FILE else SOR$GL_IN_ALQ = .FILE_SIZE [0]

	    else
		SOR$GL_IN_ALQ = DEFAULT_FILE;

    !
    ! Go get virtual memory and expand working set.
    !
    ERROR_CODE = SOR$$GET_SPACE (.SOR$GW_IN_LRL);

    if not .ERROR_CODE then return .ERROR_CODE;


    SOR$GB_NO_SCR = 1;			! No scratch files have been created yet.

    !
    ! Initialize the sort tree.
    !
    INIT_TREE ();
    if .SOR$GL_NUM_NODS lssu 2
    then
	begin
	if .SOR$GV_FLAGS [SOR$GK_UTILITY] then SOR$$ERROR (SOR$_VM_FAIL, .SOR$GL_REC_SIZE);
	return SOR$_VM_FAIL;
	end;

    !
    ! Set up the area to save the record or keys.  If the user is comparing
    ! the keys, get enough memory to save the complete record.  If the user
    ! doesn't have a compare routine, get enough memory to save only the keys.
    !
    SAVE_SIZE = (if not .SOR$GV_FLAGS [SOR$GK_USER_CMP] then .SOR$GB_KEY_SIZE + SOR$GK_LEN_SIZE else .SOR$GL_REC_SIZE);

    if not LIB$GET_VM (SAVE_SIZE, LAST_KEY)
    then
	begin

	if .SOR$GV_FLAGS [SOR$GK_UTILITY] then SOR$$ERROR (SOR$_VM_FAIL, .SOR$GL_REC_SIZE);

	return SOR$_VM_FAIL;
	end;
    SOR$GL_SAVE_SIZ = .SAVE_SIZE;			! Save address and size
    SOR$GL_SAVE_ADR = .LAST_KEY;			! For SOR$END_SORT.

    return SUCCESS;
    end;

psect
    code = SOR$SORTINIT;


%title 'INIT_TREE'
routine INIT_TREE : JSBL novalue =

!++
! Functional Description:
!
!	This routine sets up the initial tree pointers.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	The size and address of the sort tree, the sort type, the
!	total key size and the length of the longest record.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    literal
	BLK_BYTES = 512,					! Bytes per block.
	RFA_SIZE = 6;						! RMS RFA size

    local
	EST_NUM_RECORDS,					! Estimated number of records.
	INT_INT,						! Temps for computation
	INT_EXT;						!  of pointers

    map
	PTR_TO_NODE : ref block [5];

    END_OF_FILE = 0;
    NUM_RECS = 0;
    NUMBER_OF_RUNS = 0;						! Initialize variables
    CURRENT_RUN = 0;
    WINNER_RUN_NUM = 0;
    PTR_TO_NODE = .SOR$GL_TREE;					! Initialize to begining
    PTR_TO_WINNER = .SOR$GL_TREE;				!  of tree space
!
! The number of nodes the tree will hold is equal to the key size plus
! the constant header of 16 bytes plus the longest record length for a
! record sort or the RFA size (6) for the other sorts.
!
! The internal pointer is equal to the node divided by two.
!
! The external pointer is equal to the node plus the total number of
! nodes divided by two.
!

!
!
!	Calculate the number of nodes for the sort tree.  Estimate
!	the number of records in the input file based on the file
!	allocation and the record size.  Then make sure the tree
!	does not contain too many more nodes then the estimated file
!	size so that we do not waste too much time fooling with an
!	empty tree.
!
    NUMBER_OF_NODES = (.SOR$GL_TREE_SIZ/.SOR$GL_REC_SIZE);

    if .SOR$GL_IN_ALQ gtr 0 then
	EST_NUM_RECORDS = max ((.SOR$GL_IN_ALQ*BLK_BYTES*2/.SOR$GW_IN_LRL), 100)
    else
	EST_NUM_RECORDS = .NUMBER_OF_NODES;

    NUMBER_OF_NODES = minu (.EST_NUM_RECORDS, .NUMBER_OF_NODES) and -2;
    SOR$GL_NUM_NODS = .NUMBER_OF_NODES;		! Save for statistics.
    INT_INT = .SOR$GL_TREE - .SOR$GL_REC_SIZE;
    INT_EXT = .INT_INT + (.SOR$GL_REC_SIZE*(.NUMBER_OF_NODES/2));
    !
    ! Now loop through each node setting up the pointers to the loser,
    ! internal and external nodes as well as the loser run number.
    !

    decr OFFSET from .NUMBER_OF_NODES to 1 do
	begin
	PTR_TO_NODE [PTR_TO_LOSER] = .PTR_TO_NODE;		! Loser is self

	if .OFFSET mod 2 eql 0					! If even node
	then
	    begin
	    INT_INT = .INT_INT + .SOR$GL_REC_SIZE;
	    INT_EXT = .INT_EXT + .SOR$GL_REC_SIZE;
	    end;

	PTR_TO_NODE [INT_INT_PTR] = .INT_INT;
	PTR_TO_NODE [INT_EXT_PTR] = .INT_EXT;
	PTR_TO_NODE [LOSER_RUN_NUM] = 0;			! Run number 0
	PTR_TO_NODE = .PTR_TO_NODE + .SOR$GL_REC_SIZE;
	end;

    TREE1 = .SOR$GL_TREE + .SOR$GL_REC_SIZE;
    CURRENT_OUT_BUF = .SOR$GL_OUT_BUF;				! Initialize starting
    SOR$GL_REC_SIZE = .SOR$GL_REC_SIZE - SOR$GK_NODE_HED;	! Output address
    end;

psect
    code = SOR$SORTALG;


%title 'SOR$RELEASE_REC'

global routine SOR$RELEASE_REC (DESC_ADR) : =

!++
! Functional Description:
!
!	This routine is called by a user to pass a record to the sort.
!
!
! Formal Parameters:
!
!	The record descriptor address.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	1 for success, or an error code.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    builtin
	ap;

    map
	ap : ref block [, byte];

    macro
	LEN =
	    0, 0, 16, 0 %,
	ADR =
	    4, 0, 32, 0 %;

    map
	DESC_ADR : ref block [, byte];

    literal
	SORT_ON = 99,
	SORT_OFF = 4;

!
! Just pass the record to the sort.
!

    if (.SOR$GV_FLAGS and SORT_ON) neq 0 or (.SOR$GV_FLAGS and SORT_OFF) neq SORT_OFF then return SOR$_SORT_ON;

    SOR$GV_FLAGS [SOR$GK_SORT3] = 1;				! Set sort 3rd call on
    LIB$ESTABLISH (LIB$SIG_TO_RET);

    if .ap [ARGS] lssu 1 or .DESC_ADR eql 0 then return SOR$_BAD_ADR;

    if .DESC_ADR [LEN] leq 0 or .DESC_ADR [LEN] gtr (.SOR$GW_IN_LRL + .SOR$GB_KEY_SIZE) then return SOR$_BAD_LRL;

    return SOR$SORT_MERGE (.DESC_ADR);
    end;

psect
    code = SOR$SORTALG;


%title 'SOR$SORT_MERGE'

global routine SOR$SORT_MERGE (DESC_ADR) : =

!++
! Functional Description:
!
!	This routine is the initial dispersion pass for the sorting algorithm.
!	The dispersion of records into sorted runs is done by replacement
!	selection.
!
!
! Formal Parameters:
!
!	The descriptor for the next input record.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	The records are sorted into several runs and placed in the work files
!	on disk for merging.
!
!
! Routine Value:
!
!	If record I/O and there is no merge phase the address of the output
!	record descriptor.
!
!
! Completion Codes:
!
!       1 for success, or an error code.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    builtin
	sp,
	ap;

    map
	ap : ref block [, byte];

    global register
	MAP_REGS;

    literal
	SORT_ON = 64,
	SORT_OFF = 12,
	SORT_FOF = 6,
	RUNS = 11,
	NEW_RUN = 1;

    local
	TEMP;


    map
	PTR_TO_NODE : ref block [5],
	PTR_TO_WINNER : ref block [5];

    %if PERFORMANCE %then
	PME_INIT();						! Start performance measurement
    %fi
    !
    ! Get records placing them in the correct position in the tree and
    ! outputting the "winner" each time a new record is input.
    !
    START_ADR = .CURRENT_OUT_BUF;				! Restore from user

    if (.SOR$GV_FLAGS and SORT_ON) neq 0 or (.SOR$GV_FLAGS and SORT_OFF) neq SORT_OFF
    then
	SOR$GV_FLAGS [SOR$GK_SORT3] = 1;				! For null input file

    if (.SOR$GV_FLAGS and SORT_ON) neq 0 or ((.SOR$GV_FLAGS and SORT_OFF) neq SORT_OFF and (.SOR$GV_FLAGS and
	SORT_FOF) neq SORT_FOF)
    then
	return SOR$_SORT_ON;

    SOR$GV_FLAGS [SOR$GK_SORT4] = 1;				! Set sort 4th call on
    LIB$ESTABLISH (SOR$$COND_HAND);

    if .SOR$GV_FLAGS [SOR$GK_FILE_IO] then

	if .SOR$GV_FLAGS [SOR$GK_UTILITY] then			! If utility, lock VM into WS

		begin
		    SOR$$LOCK_PAGES (SOR$SORT_MERGE, SOR$SORT_MERGE+485, 1);	! Lock SOR$SORT_MERGE
		    SOR$$LOCK_PAGES (SOR$$BUILD_KEY, SOR$$BUILD_KEY+715, 1);	! Lock SOR$$BUILD_KEY
		    SOR$$LOCK_PAGES (SOR$$SORT_GET, SOR$$SORT_GET+200, 1);	! Lock input routine.
		    SOR$$LOCK_PAGES (.LAST_KEY, .LAST_KEY+.SAVE_SIZE-1, 1);	! Lock temporary key.
		    SOR$$LOCK_PAGES (.SP, .SP+1536, 2);				! Lock the stack.
		    SOR$$LOCK_PAGES (SOR$$MAP_VM, SOR$$MAP_VM+1024, 2);		! Lock routines around MAP_VM
		    SOR$$LOCK_PAGES (OUTPUT_RECORD, OUTPUT_RECORD+94, 2);	! Lock OUTPUT_RECORD
		    SOR$$LOCK_PAGES (.SOR$GL_KEY_COMP, .SOR$GL_KEY_COMP+512, 2);! Lock the key comparison routine.
		    SOR$$LOCK_PAGES (SOR$GB_INP_SIZ, SOR$GB_INP_SIZ+1024, 2)	! Lock the data area
		    end;


    while 1 do
	begin
	!
	! If starting a new run map the output buffer for the run into the
	! correct work file.
	!

	if .WINNER_RUN_NUM neq 0
	then
	    begin

	    if .CURRENT_RUN neq .WINNER_RUN_NUM
	    then
		begin

		if .CURRENT_RUN neq 0
		then
		    begin
		    RECORD_LEN (.START_ADR) = .EOS;		! Indicate end of run
		    START_ADR = .START_ADR + SOR$GK_LEN_SIZE;
		    end;

		if .WINNER_RUN_NUM lss 0
		then

		    if not .SOR$GV_FLAGS [SOR$GK_NO_MERGE]
		    then
			begin

			if .SOR$GV_FLAGS [SOR$GK_UTILITY] then SOR$AL_STATS [RUNS] = .NUMBER_OF_RUNS;

			if .SOR$GV_FLAGS [SOR$GK_FILE_IO] then

				if .SOR$GV_FLAGS [SOR$GK_UTILITY] then			! If utility, lock VM into WS

				    begin
					SOR$$UNLOCK_GRP (1);		! Unlock group 1 pages.
					SOR$$LOCK_PAGES (MERGE0, MERGE0+476, 2);	! Lock MERGE0
					SOR$$LOCK_PAGES (LIST_INSERTION, LIST_INSERTION+147, 2);
					end;

			return MERGE0 ();			! Done with dispersion
			end
		    else
			return SUCCESS				! Now do intermediate merges
		else

		    begin
		    if .SOR$GB_NO_SCR and not .SOR$GV_FLAGS [SOR$GK_NO_MERGE] then	! If first time here, we must create the scratch files.
			begin
			    SOR$GB_NO_SCR = 0;			! Don't come here again.
			    TEMP = SOR$$CREATE_SCR ();		! Create the scratch files.
			    if not .TEMP then return .TEMP;	! Return if error.
			    START_ADR = .SOR$GL_OUT_BUF;	! Set output address
			    CURRENT_OUT_BUF = .START_ADR;	! And current output buffer.
			    end;

		    WINNER_RUN_NUM = .CURRENT_RUN + 1;
		    CURRENT_RUN = .WINNER_RUN_NUM;
		    TEMP = SOR$$MAP_VM (NEW_RUN);

		    if not .TEMP then return .TEMP;

		    end;

		end;

	    !
	    ! If this is not the first time through output the "winner". Check
	    ! to make sure that part of the output area is mapped and if not map it.
	    !

	    if .SOR$GV_FLAGS [SOR$GK_NO_MERGE]
	    then

		if not .SOR$GV_FLAGS [SOR$GK_FILE_IO]
		then
		    begin
		    WINNER_RUN_NUM = 0;
		    return .PTR_TO_WINNER + SOR$GK_NODE_HED;
		    end;

	    TEMP = OUTPUT_RECORD (.PTR_TO_WINNER + SOR$GK_NODE_HED);

	    if not .TEMP then return .TEMP;

	    end;

	!
	! If user is passing records and one exists or doing file I/O build the
	! key and place it in the tree. Otherwise go get a record from the user.
	!

	if not .END_OF_FILE
	then
	    begin
	    ch$move (.SAVE_SIZE, ch$ptr (.PTR_TO_WINNER + SOR$GK_NODE_HED), ch$ptr (.LAST_KEY));

	    while 1 do
		begin

		if .ap [ARGS] gtru 0
		then
		    TEMP = SOR$$BUILD_KEY (.DESC_ADR, .PTR_TO_WINNER)
		else
		    TEMP = SOR$$BUILD_KEY (0, .PTR_TO_WINNER);

		if .TEMP eql RMS$_EOF
		then
		    begin
		    END_OF_FILE = 1;

!-------------change-----------------------------------
!old line was:	    if .NUMBER_OF_NODES geq .NUM_RECS
!     -VLB
!------------------------------------------------------
		    if .NUMBER_OF_NODES gtr .NUM_RECS
		    then
			begin
			SOR$GV_FLAGS [SOR$GK_NO_MERGE] = 1;
			SOR$GV_FLAGS [SOR$GK_FINAL] = 1;

			if not .SOR$GV_FLAGS [SOR$GK_FILE_IO] then return SUCCESS;

			end;

		    WINNER_RUN_NUM = -1;
		    exitloop;
		    end
		else

		    if .TEMP
		    then
			exitloop
		    else

			if not .SOR$GV_FLAGS [SOR$GK_FILE_IO]
			    or .TEMP gtr (SORT_ERROR*65536)
			then
			    begin
			    WINNER_RUN_NUM = 0;
			    CURRENT_OUT_BUF = .START_ADR;
			    return .TEMP;
			    end;

		end;

	    end
	else
	    WINNER_RUN_NUM = -1;

	!
	! If a new record was input compare it against the other records
	! in the tree until its proper place is found.
	!

	if not .END_OF_FILE
	then
	    begin
	    NUM_RECS = .NUM_RECS + 1;

	    if .NUMBER_OF_NODES leq .NUM_RECS
	    then

		if .SOR$GV_FLAGS [SOR$GK_NO_MERGE] then return SOR$_NO_WRK;

	    if
		begin
		if .WINNER_RUN_NUM eql 0 then 1
		else JSBR2(.SOR$GL_KEY_COMP,
			.PTR_TO_WINNER+KEY_START,
			.LAST_KEY+SOR$GK_LEN_SIZE) lss 0
		end
	    then
		begin
		WINNER_RUN_NUM = .WINNER_RUN_NUM + 1;

		if .WINNER_RUN_NUM gtr .NUMBER_OF_RUNS then NUMBER_OF_RUNS = .WINNER_RUN_NUM;

		end;

	    end;

	!
	! Set node pointer to the external node of the "winner". Loop through
	! the tree until the next "winner" is located or a new run must be
	! started.
	!
	PTR_TO_NODE = .PTR_TO_WINNER [INT_EXT_PTR];

	while 1 do
	    begin

	    if
		begin
		if .PTR_TO_NODE[LOSER_RUN_NUM] lssu .WINNER_RUN_NUM then 1 else
		if .PTR_TO_NODE[LOSER_RUN_NUM] nequ .WINNER_RUN_NUM then 0 else
		if .PTR_TO_NODE[LOSER_RUN_NUM] leq 0 then 0 else
		if JSBR2(.SOR$GL_KEY_COMP,
			.PTR_TO_WINNER+KEY_START,
			.PTR_TO_NODE[PTR_TO_LOSER]+KEY_START) gtr 0 then 1
		else 0
		end
	    then
		begin
		TEMP = .PTR_TO_NODE [PTR_TO_LOSER];
		PTR_TO_NODE [PTR_TO_LOSER] = .PTR_TO_WINNER;
		PTR_TO_WINNER = .TEMP;
		TEMP = .PTR_TO_NODE [LOSER_RUN_NUM];
		PTR_TO_NODE [LOSER_RUN_NUM] = .WINNER_RUN_NUM;
		WINNER_RUN_NUM = .TEMP;
		end;

	    if .PTR_TO_NODE neq .TREE1 then PTR_TO_NODE = .PTR_TO_NODE [INT_INT_PTR] else exitloop;

	    end;						! Find winner loop

	if not .SOR$GV_FLAGS [SOR$GK_FILE_IO] and not .END_OF_FILE
	then
	    begin
	    CURRENT_OUT_BUF = .START_ADR;			! Save buffer address
	    return SUCCESS;					! Go get next record
	    end;

	end;							! Input/output to tree loop

    return SUCCESS;
    end;

psect
    code = SOR$SORTMERGE;


%title 'MERGE0'
routine MERGE0 : CALLR =

!++
! Functional Description:
!
!	This routine does the merging of the strings created during the
!	dispersion phase. It uses an m-way list merging algorithm.
!
!
! Formal Parameters:
!
!
! Implicit Inputs:
!
!	The number of runs created during dispersion.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	1 for success, or an error code.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    builtin
	remque;

    macro
	VBN_LEFT =
	    16, 0, 32, 0 %,
	CUR_BUF =
	    8, 0, 32, 0 %,
	END_BUF =
	    4, 0, 32, 0 %,
	PTR_TO_NEXT =
	    0, 0, 32, 0 %,
	PTR_TO_PREV =
	    1, 0, 32, 0 %,
	PTR_TO_REC =
	    2, 0, 32, 0 %,
	BUFFER_NUM =
	    3, 0, 32, 0 %;

    label
	OUTPUTRUN;

    own
	FIRST_TIME : byte;

    literal
	LIST_SIZE = 160,
	INDEX_SIZE = 220,
	NUM_PASSES = 15,
	MERGE_ORDER = 13,
	END_RUN = 3,
	NEW_PASS = 1;

    local
	TEMP;

    external register
	MAP_REGS;

    bind
	MERGE_LIST = .SOR$GL_TREE + INDEX_SIZE : blockvector [10, 4],
	FREE_NODE = LAST_KEY;

    map
	PTR_TO_NODE : ref block,
	FREE_NODE : ref block;

    bind
	NUM_OF_MERGED = WINNER_RUN_NUM,
	MERGE_LISTHEAD = TREE1 : vector [2],
	CURRENT_RECORD = PTR_TO_WINNER,
	CURRENT_BUFFER = CURRENT_RUN,
	RUNS_LEFT = NUMBER_OF_NODES;

!
! Initialize the number of runs left to the number created by
! dispersion. Then initialize the work space and determine the order
! of the merge.
!

    if not .SOR$GV_FLAGS [SOR$GK_FINAL] then RUNS_LEFT = .NUMBER_OF_RUNS;

    while 1 do 							! New merge pass
OUTPUTRUN :
	begin

	if not .SOR$GV_FLAGS [SOR$GK_FINAL]
	then
	    begin
	    NUM_OF_MERGED = 0;
	    MERGE_LISTHEAD [0] = MERGE_LISTHEAD;
	    MERGE_LISTHEAD [1] = MERGE_LISTHEAD;
	    SOR$$MAP_VM (END_RUN);				! Update last run in index
	    TEMP = SOR$$MERGE_PASS (.RUNS_LEFT, NEW_PASS);

	    if not .TEMP then return .TEMP;

	    if .SOR$GV_FLAGS [SOR$GK_UTILITY]
	    then
		begin
		SOR$AL_STATS [NUM_PASSES] = .SOR$AL_STATS [NUM_PASSES] + 1;

		if .RUNS_LEFT eql .NUMBER_OF_RUNS then SOR$AL_STATS [MERGE_ORDER] = .SOR$GB_MERGE;

		end;

	    end;

	!
	! Now start the merging. Initialize the list pointers and fill the list
	! from each of the buffers.
	!

	while 1 do 						! Need to fill buffers
	    begin

	    if not .SOR$GV_FLAGS [SOR$GK_FINAL] or .SOR$GV_FLAGS [SOR$GK_FILE_IO]
	    then
		begin
		NUM_OF_MERGED = .NUM_OF_MERGED + 1;
		FIRST_TIME = 1;
		RUNS_LEFT = .RUNS_LEFT - .SOR$GB_MERGE;
		CURRENT_BUFFER = 0;

		while 1 do 					! List insertion
		    begin
		    PTR_TO_NODE = .MERGE_LISTHEAD [0];
		    FREE_NODE = MERGE_LIST [.CURRENT_BUFFER, PTR_TO_NEXT];
		    LIST_INSERTION (.CURRENT_BUFFER);
		    CURRENT_BUFFER = .CURRENT_BUFFER + 1;

		    if .CURRENT_BUFFER geq .SOR$GB_MERGE then exitloop;

		    end;					! Fill up list

		end;

	    !
	    ! If ready for final merge pass and record io return to the user.
	    ! Otherwise, continue with the final merge.
	    !

	    if .RUNS_LEFT eql 0 and .NUM_OF_MERGED eql 1 and not .SOR$GV_FLAGS [SOR$GK_FINAL]
	    then
		begin
		SOR$GV_FLAGS [SOR$GK_FINAL] = 1;

		if not .SOR$GV_FLAGS [SOR$GK_FILE_IO]
		then
		    return SUCCESS
		else

		    if not SOR$$OUT_RAB ()			! Init output RAB
		    then
			return SOR$_OPENOUT;

		end;

	    !
	    ! Output the records in order replacing a record in the list with one
	    ! from its buffer.
	    !

	    while 1 do
		begin

		if not .FIRST_TIME
		then
		    begin
		    remque (.FREE_NODE, FREE_NODE);
		    CURRENT_BUFFER = .FREE_NODE [BUFFER_NUM];

		    if .SOR$AL_BUF_ADR [.CURRENT_BUFFER, CUR_BUF] + .SOR$GL_REC_SIZE - 1 gtra .SOR$AL_BUF_ADR [
			    .CURRENT_BUFFER, END_BUF]
		    then

			if .SOR$AL_BUF_ADR [.CURRENT_BUFFER, VBN_LEFT] neq 0
			then
			    begin
			    TEMP = SOR$$MAP_RUN (.CURRENT_BUFFER);

			    if not .TEMP then return .TEMP;

			    end;

		    CURRENT_RECORD = .SOR$AL_BUF_ADR [.CURRENT_BUFFER, CUR_BUF];

		    if .RECORD_LEN (.CURRENT_RECORD) nequ .EOS
		    then
			begin
			PTR_TO_NODE = .MERGE_LISTHEAD [0];
			LIST_INSERTION (.SOR$GB_MERGE - 1);
			end;

		    end
		else
		    FIRST_TIME = 0;

		FREE_NODE = .MERGE_LISTHEAD [0];

		if .FREE_NODE eql MERGE_LISTHEAD
		then
		    begin

		    if not .SOR$GV_FLAGS [SOR$GK_FINAL]
		    then
			begin
			RECORD_LEN (.START_ADR) = .EOS;		! Put end of run
			START_ADR = .START_ADR + SOR$GK_LEN_SIZE;
			end;

		    !
		    ! If there are no runs left and only one merged string then done.
		    ! If there are no runs left and several merged strings then start a
		    ! new pass.  If there are runs left continue with this pass after
		    ! mapping the rest of the runs into the buffers.
		    !

		    if .RUNS_LEFT leq 0
		    then

			if .NUM_OF_MERGED eql 1
			then
			    return SUCCESS
			else
			    begin
			    RUNS_LEFT = .NUM_OF_MERGED;
			    leave OUTPUTRUN;
			    end;

		    if .RUNS_LEFT lss .SOR$GB_MERGE then SOR$GB_MERGE = .RUNS_LEFT;

		    TEMP = SOR$$MERGE_PASS (.RUNS_LEFT, 0);

		    if not .TEMP then return .TEMP;

		    MERGE_LISTHEAD [0] = MERGE_LISTHEAD;
		    MERGE_LISTHEAD [1] = MERGE_LISTHEAD;
		    exitloop;					! Done with this set of runs
		    end
		else
		    begin

		    if .SOR$GV_FLAGS [SOR$GK_FINAL]
		    then

			if not .SOR$GV_FLAGS [SOR$GK_FILE_IO] then return .FREE_NODE [PTR_TO_REC];

		    !
		    ! Output the record at the head of the list. then get the next record
		    ! from that buffer and insert it into the list.
		    !
		    TEMP = OUTPUT_RECORD (.FREE_NODE [PTR_TO_REC]);

		    if not .TEMP then return .TEMP;

		    end;					! Output record

		end;						! Output run go start another

	    end;						! Merge pass

	end;							! Merging

    return SUCCESS;
    end;

psect
    code = SOR$SORTMERGE;


%title 'LIST_INSERTION'
routine LIST_INSERTION (NUM_NODES) : JSBL novalue =

!++
! Functional Description:
!
!	This routine does the list insertion by keys of the input records for
!	the merge phase.
!
!
! Formal Parameters:
!
!	The number of nodes in the list.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    builtin
	insque;

    macro
	CUR_BUF =
	    8, 0, 32, 0 %,
	PTR_TO_NEXT =
	    0, 0, 32, 0 %,
	PTR_TO_PREV =
	    1, 0, 32, 0 %,
	PTR_TO_REC =
	    2, 0, 32, 0 %,
	BUFFER_NUM =
	    3, 0, 32, 0 %;

    bind
	FREE_NODE = LAST_KEY,
	MERGE_LISTHEAD = TREE1 : vector [2],
	CURRENT_RECORD = PTR_TO_WINNER,
	CURRENT_BUFFER = CURRENT_RUN;

    map
	PTR_TO_NODE : ref block,
	FREE_NODE : ref block;

    !
    ! Set up the free node to point to the next record in the current buffer.
    !
    CURRENT_RECORD = .SOR$AL_BUF_ADR [.CURRENT_BUFFER, CUR_BUF];
    SOR$AL_BUF_ADR [.CURRENT_BUFFER, CUR_BUF] = .RECORD_LEN (.CURRENT_RECORD) + .SOR$AL_BUF_ADR [.CURRENT_BUFFER, CUR_BUF];
    FREE_NODE [BUFFER_NUM] = .CURRENT_BUFFER;
    FREE_NODE [PTR_TO_REC] = .CURRENT_RECORD;
    !
    ! Loop through the list inserting the new record in proper order by
    ! key.
    !

    incr index from 0 to .NUM_NODES do

	if PTR_TO_NODE [PTR_TO_NEXT] neq MERGE_LISTHEAD
	then

	    if JSBR2 (.SOR$GL_KEY_COMP, .FREE_NODE [PTR_TO_REC] + SOR$GK_LEN_SIZE, .PTR_TO_NODE [PTR_TO_REC] + SOR$GK_LEN_SIZE) eql 1
	    then
		PTR_TO_NODE = .PTR_TO_NODE [PTR_TO_NEXT]
	    else
		0

	else
	    exitloop;

    insque (.FREE_NODE, .PTR_TO_NODE [PTR_TO_PREV]);
    end;

psect
    code = SOR$SORTMERGE;


%title 'SOR$RETURN_REC'

global routine SOR$RETURN_REC (OUTPUT_DESC, SIZE) : =

!++
! Functional Description:
!
!	This routine returns a sorted record to the user.
!
!
! Formal Parameters:
!
!	The address the output area for the record.
!	The address of the word area for the record length.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	An error code or success or end of file.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    builtin
	ap;

    map
	SIZE : ref vector [, word],
	ap : ref block [, byte];

    global register
	MAP_REGS;

    macro
	LEN =
	    0, 0, 16, 0 %,
	ADR =
	    4, 0, 32, 0 %;

    local
	TEMP,
	ADDRESS;

    literal
	SORT_ON = 66,
	SORT_OFF = 28;

    bind
	DESC = .OUTPUT_DESC : block [, byte];

    !
    !
    ! Test if this is a MERGE utility and if so, call SOR$$RET_MERGE
    !

    if .SOR$GV_FLAGS [SOR$GK_MERGE2] then return SOR$$RET_MERGE (.OUTPUT_DESC, .SIZE);

    !
    ! Call the final merge routine to get a sorted record and move it into
    ! the users area. If the area is too small return the record truncated
    ! to the area size.
    !

    if (.SOR$GV_FLAGS and SORT_ON) neq 0 or (.SOR$GV_FLAGS and SORT_OFF) neq SORT_OFF then return SOR$_SORT_ON;

    if .ap [ARGS] lssu 2 then return SOR$_BAD_ADR;

    SOR$GV_FLAGS [SOR$GK_SORT5] = 1;				! Set sort 5th call on
    LIB$ESTABLISH (LIB$SIG_TO_RET);

    if .SOR$GV_FLAGS [SOR$GK_NO_MERGE] then ADDRESS = SOR$SORT_MERGE () else ADDRESS = MERGE0 ();

    selectone .ADDRESS of
	set

	[SOR$_MAP, SOR$_EXTEND, SOR$_VM_FAIL] :
	    return .ADDRESS;

	[SUCCESS] :
	    return SS$_ENDOFFILE;

	[otherwise] :
	    0;
	tes;

    SIZE [0] = min (.RECORD_LEN (.ADDRESS) - (.SOR$GB_KEY_SIZE + SOR$GK_LEN_SIZE), .DESC [LEN]);

    TEMP = LIB$SCOPY_R_DX (SIZE [0], .ADDRESS + SOR$GK_LEN_SIZE + .SOR$GB_KEY_SIZE, DESC);
    if not .TEMP then return .TEMP;
    return SUCCESS;
    end;

psect
    code = SOR$SORTCOM;


psect
    code = SOR$SORTCOM;


%title 'OUTPUT_RECORD'
routine OUTPUT_RECORD (PTR) : JSBR1 =

!++
! Functional Description:
!
!	This routine outputs a record to either the output file or the mapped
!	file.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	The address of the record to be output in r8.
!
!
! Implicit Outputs:
!
!	The updated buffer address in r11.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    external register
	MAP_REGS;

    literal
	SAME_PASS = 0;

    !
    ! If this is the final merge pass or no merge pass is needed then
    ! output the record to the output file.  Otherwise output it to the
    ! mapped file.  If we need to map an additional portion of the virtual
    ! memory then do it.
    !

    if .SOR$GV_FLAGS [SOR$GK_FINAL] or .SOR$GV_FLAGS [SOR$GK_NO_MERGE]
    then
	return SOR$$PUT_RECORD (.RECORD_LEN (.PTR) - (SOR$GK_LEN_SIZE + .SOR$GB_KEY_SIZE), .PTR + SOR$GK_LEN_SIZE + .SOR$GB_KEY_SIZE)
    else
	begin
	ch$move (.RECORD_LEN (.PTR), ch$ptr (.PTR), ch$ptr (.START_ADR));
	START_ADR = .START_ADR + .RECORD_LEN (.PTR);

	if .SOR$GL_REC_SIZE + .START_ADR gtra .SOR$GL_BUF_END + 1 then return SOR$$MAP_VM (SAME_PASS);

	end;

    return SUCCESS;
    end;
end

eludom
