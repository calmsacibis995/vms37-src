!-*-BLISS-*-
!<BLF/NOERROR>
!<BLF/WIDTH:116>
!<BLF/REMARK:8>
!<BLF/NOPLIT>
!<BLF/MACRO>
!<BLF/LOWERCASE_KEY>
!<BLF/UPPERCASE_USER>
module SOR$RMS_IO (						! Sort RMS Routines
		addressing_mode (external = general) ,
		language (bliss32) ,
		list (assembly) ,
		unames,
		list (assembly) ,
		unames,
		ident = 'V03-000'
		) =
begin
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! Facility:
!
!	SORT
!
! Abstract:
!
!	This module contains all of the routines that do RMS file I/O.
!
!
! Environment:
!
!	Starlet Operating System, User mode utility
!
!
! Author:
!
!	Ellen R Simich,		Creation Date:		1-Sep-77
!
! Modified By :
!
!	V02.08		PDG0008		PDG		17-Feb-1982
!		Fix problem with re-opening of the input files for tag sort.
!		This entails the following changes:
!		Set the SQO bit only if we don't reaccess the file by RFA.
!		Close the input file at EOF only if not a tag sort.
!		In SOR$$PUT_RECORD do not reopen the file; just set RFA access.
!		Note that there is also a substantial performance improvement
!		for tag sorts of extremely short input files.
!	V02.07		PDG0007		PDG		8-Feb-1982
!		Get the best approximation to the resultant file name string.
!		Clean up usage of SHR$ errors.
!	V02.06		PDG0006		PDG		30-Dec-1981
!		Fix check for BUFSIZE parameter present in SOR$$RAB_INIT.
!	V02.05		PDG0005		Peter D Gilbert	11-Dec-1981
!		Fix returned address/status problem with
!		    SOR$$GET_RECORD, SOR$$SORT_GET and SOR$$RAB_INIT.
!		Make RMS_ERROR check SOR$GK_UTILITY (code savings).
!	V02.04		JDN0004		Joe Neumeister	21-Oct-1981
!		Change SOR$GV_FLAGS from a bitvector [16] to a 
!    		    bitvector [32] to allow new switches, (/STATISTICS).
!	V02.03		VLB0003		Vick Bennison	28-Sep-1981
!		Fix "overlay" problems during callable sort on indexed files
!	V02.02		JDN0002		Joe Neumeister	19-Jun-1981
!		Change addressing mode to (external = general) for module.
!	V02.01		JDN0001		Joe Neumeister	12-Feb-1981
!		Max. record size calculations were changed by C. Krapf
!		to avoid geting "BAD RECORD" errors.
!			Declare ERROR symbols as external literals to 
!	    	allow new error messages to be outputted.
!
!
!--

!
!TABLE OF CONTENTS:
!

linkage
    JSBL = jsb;

forward routine
    SOR$$CLOSE_FILE,						! Close Files
    SOR$$CREATE_OUT,						! Output File Create
    MOVE_FILE_NAME : novalue,					! Move name and strip blanks.
    RMS_ERROR : JSBL,						! Common Error Routine
    CALC_LRL,							! Routine to calculate largest record length.
    SOR$$RAB_INIT,						! Connect a RAB.
    SOR$$GET_RECORD : JSBL,						! Input a record.
    SOR$$NEW_INPUT,						! Get FAB/RAB for next data file.
    OPEN_FILE : JSBL;						! Common Open a File

!
! INCLUDE FILES:
!

library 'SYS$LIBRARY:STARLET.L32';


!
! MACROS:
!

psect
    global = SOR$RMSSTOR ( addressing_mode (general)),
    own = SOR$SPECDATA ( addressing_mode (general)),
    plit = SOR$RMSOPEN ( execute);

!
! EQUATED SYMBOLS:
!

literal
    ERROR = 0,
    SUCCESS = 1,
    RP06_TRK = 16,						! Maximum MBC count
    MBF_COUNT = 2,						! Maximum MBF count
    MBC_COUNT = 7,						! Minimum MBC count
    BLK_BYTES = 512,						! Number of bytes in a block
    SORT_ERROR = 28,
    WARN = 0,
    FATAL = 4;							! Sort facility code

MACRO
    DEFSHR_[MSG,SEV] =
	%NAME('SOR$_',MSG) =
		%NAME('SHR$_',MSG) +
		%NAME('STS$K_',SEV) + SORT_ERROR ^ 16 %;
LITERAL
    DEFSHR_(
	OPENOUT,  SEVERE,
	OPENIN,   SEVERE,
	READERR,  SEVERE,
	WRITEERR, SEVERE,
	CLOSEIN,  WARNING,
	CLOSEOUT, WARNING);
!
! OWN STORAGE:
!

own
    RECORD_BUFFER : vector [ch$allocation (132)];

global literal
    SOR$GK_MAX_FILE = 10,			! Maximum number of input files.
    SOR$GK_DDB_SIZE = FAB$C_BLN + RAB$C_BLN + NAM$C_BLN + XAB$C_KEYLEN + XAB$C_FHCLEN;	! Total DDB length in bytes.

global
!
! Filename strings and output file options.
!
    SOR$GT_INP_NAME : vector [ch$allocation (NAM$C_MAXRSS)],
    SOR$GT_OUT_NAME : vector [ch$allocation (NAM$C_MAXRSS)],
    SOR$GB_INP_SIZ : byte,
    SOR$GB_OUT_SIZ : byte,
    SOR$GB_OUT_ORG : signed byte initial (-1),			! Organization
    SOR$GB_OUT_FSZ : signed byte initial (-1),
    ! VFC size
    SOR$GW_MAX_LRL : word,					! Max LRL in all input files.
    SOR$GW_MAX_MRS : word,					! Maximum MRS field of all input files.
    SOR$GL_TOT_ALQ,						! Total allocation for all input files.
    SOR$GL_OUT_FOP : initial (0),				! Options
    SOR$GL_OUT_ALQ : initial (0),				! Allocation quantity
    SOR$GW_OUT_BLS : signed word initial (-1),			! Block size
    SOR$GW_OUT_MRS : signed word initial (-1),			! Maximum record size
    SOR$GB_OUT_RFM : signed byte initial (-1),			! Record format
    SOR$GL_DDB_PTR,						! Pointer to input file DDB.
    SOR$GV_DDB_TABL : vector [SOR$GK_MAX_FILE],			! Table of DDB addresses.
    SOR$GB_NUM_FILE : byte initial (0),				! Number of input files.
    SOR$GB_CUR_FILE : signed byte initial (-1),			! Current file number
    SOR$GB_OUT_BKS : signed byte initial (-1);			! File bucket size

psect
    own = SOR$RMSSTOR ( addressing_mode (general));


map
    SOR$GL_DDB_PTR : ref block [,byte];				! Points to input file FAB, RAB, NAM, XAB.




own
    OUT_FAB : $FAB_DECL,					! Output FAB
    OUT_RAB : $RAB_DECL,					! Output RAB
    OUT_NAM : $NAM_DECL,					! Output name block
    KEY_BUF : initial (1),					! Relative RRN
    FIRST_TIME : byte initial (1);				! Flag for tag sort PUT

!
! EXTERNAL REFERENCES:
!

external routine
    LIB$ESTABLISH : addressing_mode (general),
    LIB$SIG_TO_RET : addressing_mode (general),
    LIB$GET_VM : addressing_mode (general),
    SOR$$ERROR : novalue weak;

external literal
    SOR$GK_FINAL : unsigned (4),
    SOR$GK_LOAD_FIL : unsigned (4),				! /LOAD_FILL
    SOR$GK_CHAR_KEY : unsigned (2),				! Key types
    SOR$GK_BIN_KEY : unsigned (2),
    SOR$GK_PACK_KEY : unsigned (3),
    SOR$GK_UTILITY : unsigned (4),				! Utility flag
    SOR$GK_INDEX : unsigned (3),				! Sort types
    SOR$GK_RECORD : unsigned (2),
    SOR$GK_TAG : unsigned (2),
    SOR$GK_ADDRESS : unsigned (3),
    SOR$GK_SORT1 : unsigned (3),				! Sort sequence bit
    SOR$GK_FILE_IO : unsigned (3),				! Bit for file I/O versus records
    SOR$_MISS_KEY,				! Declare ERROR symbols
    SOR$_WORK_DEV,				!  as external literals
    SOR$_NO_WRK,
    SOR$_VM_FAIL,
    SOR$_WS_FAIL,
    SOR$_SORT_ON,
    SOR$_BAD_KEY,
    SOR$_NUM_KEY,
    SOR$_BAD_LEN,
    SOR$_ONE_IN,
    SOR$_IND_OVR,
    SOR$_INCONSIS,
    SOR$_VAR_FIX,
    SOR$_BAD_TYPE,
    SOR$_LRL_MISS,
    SOR$_BAD_SPEC,
    SOR$_BAD_LRL,
    SOR$_BAD_FILE,
    SOR$_BAD_ADR,
    SOR$_MAP,
    SOR$_EXTEND,
    SOR$_KEY_LEN,
    SOR$_CLEAN_UP,
    SOR$_BAD_MERGE,
    SOR$_BAD_ROUTIN,
    SOR$_INP_FILES,
    SOR$_BAD_ORDER;


external
    SOR$GT_SPECNAME : vector [ch$allocation (NAM$C_MAXRSS)] weak,
    SOR$GB_SPECSIZE : byte weak,				! Spec filename size
    SOR$GW_IN_LRL : word,					! Longest record length
    SOR$GL_REC_SIZE,						! Tree entry size
    SOR$GL_IN_ALQ,						! File size
    SOR$GL_IN_BUF,						! Address of input buffer
    SOR$GL_BUF_SIZE,						! Size for RMS internal buffers
    SOR$GB_KEY_SIZE : byte,					! Total key size in bytes
    SOR$AW_KEY_BUF : blockvector [, 3, word],			! Key buffer
    SOR$GB_NUM_KEYS : byte,					! Number of keys
    SOR$GB_SOR_TYP : byte,					! Type of sort to perform
    SOR$GW_FIX_SIZE : word,					! Size of fixed area for vfc records.
    SOR$AL_STATS : vector [16] weak,				! Statistics buffer
    SOR$GV_FLAGS : bitvector [32];				! Flags for sorting options
								!    Change to longword.  ---JDN


psect
    code = SOR$RMSOPEN;


%title 'SOR$$OPEN_INPUT'

global routine SOR$$OPEN_INPUT =

!++
! Functional Description:
!
!       This routine sets up the FAB for the input file and calls the
!       common open routine.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
! Completion Codes:
!
!	Status code.
!       An error code on error.
!       1 for success.
!
!
! Side Effects:
!
!       The input file name is parsed and the file opened.
!
!--

    begin

    literal
	DEFAULT_SIZE = 4,					! Default type size
	KEY_BUCKET = 15,					! Overhead in index bucket
	TOTAL_KEY = 3;						! Overhead in total key size

    REQUIRE 'SRC$:MAPDDB.REQ';

    bind
	DEFAULT_TYPE = uplit byte(%ascii'.DAT');

    local
	FILE_ALQ;						! File allocation.


!
! Initialize the FAB.
!
    $FAB_INIT (FAB = COM_FAB, NAM = COM_NAM, FNA = ch$ptr (SOR$GT_INP_NAME), FNS = .SOR$GB_INP_SIZ,
	DNA = ch$ptr (DEFAULT_TYPE), DNS = DEFAULT_SIZE, XAB = FHC_XAB, RAT = CR);

    ! Set the SQO bit only if we don't reaccess the file by RFA.
    !
    if .SOR$GB_SOR_TYP NEQ SOR$GK_TAG THEN COM_FAB[FAB$L_FOP] = FAB$M_SQO;

    $XABFHC_INIT (XAB = FHC_XAB, NXT = KEY_XAB);	! Init the FHC XAB and link into XAB chain.

    ch$fill (0, XAB$C_KEYLEN, ch$ptr (KEY_XAB));	! Init the KEY XAB.

    KEY_XAB [XAB$B_REF] = 0;
    KEY_XAB [XAB$B_COD] = XAB$C_KEY;
    KEY_XAB [XAB$B_BLN] = XAB$C_KEYLEN;
    KEY_XAB [XAB$B_SIZ0] = 1;
    KEY_XAB [XAB$B_TKS] = 1;
    KEY_XAB [XAB$B_NSG] = 1;
!
! Initialize the Name Block and do the open.
!
    $NAM_INIT (NAM = COM_NAM, ESS = NAM$C_MAXRSS, ESA = ch$ptr (SOR$GT_INP_NAME), RSS = NAM$C_MAXRSS,
	RSA = ch$ptr (SOR$GT_INP_NAME));

    if not OPEN_FILE () then return SOR$_OPENIN;

    if .COM_FAB [FAB$B_RFM] eql FAB$C_UDF			! Undefined not valid
    then
	return RMS_ERROR (SOR$_INCONSIS, COM_NAM, 0);


    if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC then

	begin
	    if .SOR$GW_FIX_SIZE eql %X'FFFF' then
		SOR$GW_FIX_SIZE = .COM_FAB [FAB$B_FSZ];		! Copy fixed size.
	    if .SOR$GW_FIX_SIZE neq .COM_FAB [FAB$B_FSZ] then
		    return RMS_ERROR (SOR$_INCONSIS, COM_NAM, 0);
	    end;


    SOR$GV_FLAGS [SOR$GK_FILE_IO] = 1;				! Turn on file I/O bit
    SOR$GV_FLAGS [SOR$GK_SORT1] = 1;				! Turn on phase 1 done bit
    !
    ! If the file is on disk, take the allocation quantity from the FAB.  If
    ! the file is indexed organization then the allocation quantity is 3/4 the
    ! total allocation.  Otherwise use the user specified value or the default.
    ! Then create the output file now so we dont sort and then get an error.
    !

    if .block [COM_FAB [FAB$L_DEV], DEV$V_RND;, byte]
	then
	    FILE_ALQ = .COM_FAB [FAB$L_ALQ]	! Get file allocation.
	else
	    begin
		FILE_ALQ = 0;			! Unknown allocation.
		if .SOR$GB_SOR_TYP neq SOR$GK_RECORD then return SOR$_BAD_TYPE;  ! If not disk, then must be record sort.
		end;

    SOR$GL_TOT_ALQ = .SOR$GL_TOT_ALQ + .FILE_ALQ; ! Add to total input allocation.


    ! Now calculate the largest lrl for all the input files.
    !

    FILE_ALQ = CALC_LRL();			! Calculate the lrl for this file.

    if .FILE_ALQ gtr .SOR$GW_MAX_LRL then
	SOR$GW_MAX_LRL = .FILE_ALQ;

    !
    ! Find the largest MRS field of all the input files.
    !
    
    if .COM_FAB [FAB$W_MRS] gtr .SOR$GW_MAX_MRS then
	SOR$GW_MAX_MRS = .COM_FAB [FAB$W_MRS];


    SUCCESS
    end;

psect
    code = SOR$RMSCOM;


%title 'SOR$$RAB_INIT'

global routine SOR$$RAB_INIT (LRL,BUFSIZE) : weak =

!++
! Functional Description:
!
!	This routine sets up the RAB for the input file and connects.
!
!
! Formal Parameters:
!
!	The longest record length.
!
!	The address of where to store the total needed buffer size (optional).
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
! Completion Codes:
!
!	Status code.
!
! Side Effects:
!
!	None.
!
!--

    begin

    require 'SRC$:MAPDDB.REQ';


    literal
	LRL_STAT = 1,
	IN_MBC = 3,
	IN_MBF = 7,
	BKS_OVER = 24;						! Bucket overhead for indexed file

    builtin
	ACTUALCOUNT;

    !
    ! Initialize the RAB.
    !
    $RAB_INIT (RAB = COM_RAB, FAB = COM_FAB, RAC = SEQ, KRF = 0, ROP = RAH);
    !
    ! Compute the amount of buffer space that can be use for multi buffering
    ! and multi block reads based on file organiation and device
    ! characteristics.
    !

    if .LRL neq 0						! If user specified LRL
    then 							! then use it
	COM_RAB [RAB$W_USZ] = .LRL
    else 							! else use the LRL in the header.

	COM_RAB [RAB$W_USZ] = CALC_LRL();			! Calculate the lrl from the header.


    if .COM_RAB [RAB$W_USZ] leq 0 then				! Check for bad LRL
	    return RMS_ERROR (SOR$_BAD_LRL, COM_NAM, 0);


    !
    ! If organization is sequential and the device is disk use MBC and MBF if
    ! there are more than 8 blocks available.  Otherwise use an MBF of 2.
    !

    if .COM_FAB [FAB$B_ORG] neq FAB$C_SEQ or .block [COM_FAB [FAB$L_DEV], DEV$V_SQD;, byte] or not .block [COM_FAB
	    [FAB$L_DEV], DEV$V_RND;, byte]
    then
	COM_RAB [RAB$B_MBF] = MBF_COUNT
    else

	begin
	COM_RAB [RAB$B_MBC] = RP06_TRK;
	COM_RAB [RAB$B_MBF] = MBF_COUNT;
	end;

    !
    ! Finally connect to the FAB and return the actual buffer size so any
    ! excess can be added to the sort tree.
    !

    if not $RMS_CONNECT (RAB = COM_RAB)
    then
	return RMS_ERROR (SOR$_OPENIN, COM_NAM, COM_RAB);


    if .SOR$GV_FLAGS [SOR$GK_UTILITY]
    then
	begin
	SOR$AL_STATS [LRL_STAT] = .SOR$GW_IN_LRL;
	SOR$AL_STATS [IN_MBC] = .COM_RAB [RAB$B_MBC];
	SOR$AL_STATS [IN_MBF] = .COM_RAB [RAB$B_MBF];
	end;

    if ACTUALCOUNT() gequ 2 then	! Buffer size requested?
    if .BUFSIZE neq 0 then
	begin
	.BUFSIZE = (.COM_FAB[FAB$B_BKS] + .COM_RAB[RAB$B_MBC])
		    * BLK_BYTES * .COM_RAB[RAB$B_MBF];

	if .block [COM_FAB [FAB$L_DEV], DEV$V_SQD;, byte]
	then
	    .BUFSIZE = ..BUFSIZE + .COM_FAB[FAB$W_BLS] * .COM_RAB[RAB$B_MBF];
	end;

    return SUCCESS;
    end;

%title 'CALC_LRL'

routine CALC_LRL =


!++
!
!
! Functional Description:
!
!	Routine to calculate the longest record length of a file
!	based on the information in the FAB and XABs. 
!
!
!
!
! Global Inputs:
!
!	COM_FAB, and FHC_XAB.
!
!
!
! Routine Value:
!
!	The largest record length for this file.  If it can't
!	be determined from the FAB and XAB, returns zero.
!
!
!
!--


    begin



	require 'SRC$:MAPDDB.REQ';		! Map access to COM_FAB and FHC_XAB.

	literal
	    BKS_OVER = 24;			! Bucket overhead for indexed file.

	local
	    LRL;				! Best guess at longest record length.



	if .FHC_XAB [XAB$W_LRL] neq 0
	then
	    LRL = .FHC_XAB [XAB$W_LRL]
	else

	    if .COM_FAB [FAB$W_MRS] neq 0
	    then
		LRL = .COM_FAB [FAB$W_MRS]
	    else

		if .COM_FAB [FAB$B_BKS] neq 0
		then
		    LRL = ((.COM_FAB [FAB$B_BKS]*BLK_BYTES) - BKS_OVER)
		else
		    LRL = 0;

	if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC then LRL = .LRL + .COM_FAB [FAB$B_FSZ];

	!
	! If this is a disk, and this is an empty file, set the
	! LRL to 1 so we don't get errors.
	!
	if .LRL eql 0 and .block [COM_FAB [FAB$L_DEV], DEV$V_RND;, byte]
	    and not .block [COM_FAB [FAB$L_DEV], DEV$V_SQD;, byte]
	    and .COM_FAB [FAB$L_ALQ] eql 0

		then LRL = 1;

	.LRL					! Return calculated value.
	end;


psect
    code = SOR$SPEC,
    plit = SOR$SPEC ( execute);


%title 'SOR$$OPEN_SPEC'

global routine SOR$$OPEN_SPEC : =

!++
! Functional Description:
!
!	This routine sets up the fab and the rab for the specification
!	file and calls the common open routine.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	1 for success, 0 for error.
!
!
! Side Effects:
!
!	The specification file is opened and the RAB connected.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';



    bind
	PROMPT = plit byte(%ascii'Please enter specification file records.');

    literal
	MAX_REC = 132;						! Maximum spec record size

    !
    ! Initialize the FAB.
    !
    $FAB_INIT (FAB = COM_FAB, NAM = COM_NAM, FNA = ch$ptr (SOR$GT_SPECNAME), FNS = .SOR$GB_SPECSIZE, RAT = CR);
    COM_FAB [FAB$B_FAC] = FAB$M_GET or FAB$M_PUT;
    !
    ! Initialize the Name Block and do the open.
    !
    $NAM_INIT (NAM = COM_NAM, ESS = NAM$C_MAXRSS, ESA = ch$ptr (SOR$GT_SPECNAME), RSS = NAM$C_MAXRSS,
	RSA = ch$ptr (SOR$GT_SPECNAME));

    if not OPEN_FILE () then return SOR$_OPENIN;

    !
    ! Initialize the RAB and connect.
    !
    $RAB_INIT (RAB = COM_RAB, FAB = COM_FAB, RAC = SEQ, ROP = LOC, RBF = ch$ptr (PROMPT), RSZ = 40,
	UBF = ch$ptr (RECORD_BUFFER), USZ = MAX_REC);

    if not $RMS_CONNECT (RAB = COM_RAB)
    then
	return RMS_ERROR (SOR$_OPENIN, COM_NAM, COM_RAB)
    else
	if .block [COM_FAB [FAB$L_DEV], DEV$V_TRM;, byte] then $RMS_PUT (RAB = COM_RAB);

    return SUCCESS;
    end;

psect
    code = SOR$RMSOPEN;


%title 'CREATE_OUTPUT'
global routine SOR$$CREATE_OUT : =

!++
! Functional Description:
!
!	This routine sets up the fab for the output file and creates it.
!	The FAB for the first input file serves as a prototype for the
!	default file parameters for the output file.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None. (OH COME ON!)
!
! Routine Value:
!
!	An error code on error.
!
!
! Completion Codes:
!
!	1 for sucess.
!
!
! Side Effects:
!
!	The output file name is parsed and the file created.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';



    literal
	FIXED_DEFAULT = 2,					! Default fixed size for VFC
	RFA_SIZE = 6;						! RFA size


    local
	OUTPUT_FIXED,
	INPUT_FIXED,
	STATUS;

    !
    ! Initialize the FAB and the Name Block, then setting up the fields
    ! dependent on the sort type.
    !
    $FAB_INIT (FAB = OUT_FAB, FAC = PUT, FNA = ch$ptr (SOR$GT_OUT_NAME), FNS = .SOR$GB_OUT_SIZ,
	ALQ = .SOR$GL_OUT_ALQ, XAB = KEY_XAB, NAM = OUT_NAM);
    OUT_FAB [FAB$L_FOP] = .SOR$GL_OUT_FOP or FAB$M_OFP or FAB$M_DFW;


    !
    ! Set the maximum record number field only if there is exactly
    ! one input file.  Otherwise, don't do MRN checking.
    !
    if .SOR$GB_NUM_FILE eql 1 then
	OUT_FAB [FAB$L_MRN] = .COM_FAB [FAB$L_MRN]
    else
	OUT_FAB [FAB$L_MRN] = 0;

    KEY_XAB [XAB$B_COD] = XAB$C_KEY;
    KEY_XAB [XAB$B_BLN] = XAB$C_KEYLEN;
    KEY_XAB [XAB$B_REF] = 0;
    KEY_XAB [XAB$B_SIZ0] = 1;
    KEY_XAB [XAB$B_TKS] = 1;
    KEY_XAB [XAB$B_NSG] = 1;
    !
    ! Initialize the Name Block.
    !
    $NAM_INIT (NAM = OUT_NAM, ESS = NAM$C_MAXRSS, ESA = ch$ptr (SOR$GT_OUT_NAME), RLF = COM_NAM,
	RSS = NAM$C_MAXRSS, RSA = ch$ptr (SOR$GT_OUT_NAME));
    !
    ! If address or index sort default organization to sequential and record
    ! format to fixed. Allow RMS to default block and bucket size.
    !
    ! If index or address sort

    if .SOR$GB_SOR_TYP gtr SOR$GK_TAG
    then
	begin
	! If address sort

	if .SOR$GB_SOR_TYP eql SOR$GK_ADDRESS
	then
	    OUT_FAB [FAB$W_MRS] = RFA_SIZE
	else
	    OUT_FAB [FAB$W_MRS] = (.SOR$GB_KEY_SIZE + RFA_SIZE);

	OUT_FAB [FAB$B_ORG] = FAB$C_SEQ;
	OUT_FAB [FAB$B_RFM] = FAB$C_FIX;
	OUT_FAB [FAB$B_RAT] = FAB$M_CR;
	end
	!
	! If tag or record use user specified fields, otherwise default to
	! the input file organization, record format, bucket size and
	! maximum record size.
	!
    else
	begin

	if .SOR$GB_OUT_ORG geq 0
	then
	    OUT_FAB [FAB$B_ORG] = .SOR$GB_OUT_ORG
	else
	    OUT_FAB [FAB$B_ORG] = .COM_FAB [FAB$B_ORG];

	! If indexed

	if .OUT_FAB [FAB$B_ORG] eql FAB$C_IDX
	then
!-----------change----------------------------------------------
! old code was:
!
!	! must have said overlay
!
!	    if not .OUT_FAB [FAB$V_CIF] then return SOR$_IND_OVR;
!
! Change so that error is not returned in callable sort and CIF
! option is set correctly.      -VLB
!---------------------------------------------------------------

	    BEGIN
	    IF .SOR$GV_FLAGS [SOR$GK_UTILITY]
	    THEN
		IF NOT .OUT_FAB [FAB$V_CIF] THEN RETURN SOR$_IND_OVR;

	    !if in callable sort then set CIF option
	    OUT_FAB [FAB$L_FOP] = .OUT_FAB [FAB$L_FOP] OR FAB$M_CIF;
	    END;



	if .SOR$GB_OUT_RFM geq 0
	then
	    OUT_FAB [FAB$B_RFM] = .SOR$GB_OUT_RFM
	else
	    OUT_FAB [FAB$B_RFM] = .COM_FAB [FAB$B_RFM];

	if .SOR$GW_OUT_BLS geq 0 then OUT_FAB [FAB$W_BLS] = .SOR$GW_OUT_BLS;

	if .SOR$GW_OUT_MRS geq 0
	then
	    OUT_FAB [FAB$W_MRS] = .SOR$GW_OUT_MRS
	else

	    if .SOR$GW_MAX_MRS neq 0 then OUT_FAB [FAB$W_MRS] = .SOR$GW_MAX_MRS;  ! Use max MRS of all input files.


	!
	! If relative or fixed format, and MRS is zero, then use
	! the maximum input file LRL for the output MRS.
	!

	if .OUT_FAB [FAB$W_MRS] eql 0 and (.OUT_FAB [FAB$B_ORG] eql FAB$C_REL
		or .OUT_FAB [FAB$B_RFM] eql FAB$C_FIX) then
			OUT_FAB [FAB$W_MRS] = .SOR$GW_MAX_LRL;

	if .SOR$GB_OUT_BKS geq 0
	then
	    OUT_FAB [FAB$B_BKS] = .SOR$GB_OUT_BKS
	else
	    OUT_FAB [FAB$B_BKS] = .COM_FAB [FAB$B_BKS];

	if .SOR$GB_OUT_FSZ geq 0
	then
	    OUT_FAB [FAB$B_FSZ] = .SOR$GB_OUT_FSZ
	else
	    OUT_FAB [FAB$B_FSZ] = .COM_FAB [FAB$B_FSZ];

	OUT_FAB [FAB$B_RAT] = .COM_FAB [FAB$B_RAT];


	!
	! If the output file is vfc, and we are changing the
	! size of the fixed portion, then MRS must be adjusted
	! accordingly.
	!

	if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC then
	    begin
		INPUT_FIXED = .COM_FAB [FAB$B_FSZ];
		if .INPUT_FIXED eql 0 then INPUT_FIXED = FIXED_DEFAULT;
		end
	else
	    INPUT_FIXED = 0;

	if .SOR$GW_OUT_MRS lss 0 then		! If user did not specify MRS
	    if .OUT_FAB [FAB$B_RFM] eql FAB$C_VFC then
		begin
		    OUTPUT_FIXED = .OUT_FAB [FAB$B_FSZ];
		    if .OUTPUT_FIXED eql 0 then OUTPUT_FIXED = FIXED_DEFAULT;
		    if .OUT_FAB [FAB$W_MRS] neq 0 then	! Adjust MRS unless unlimitted.
			OUT_FAB [FAB$W_MRS] = .OUT_FAB [FAB$W_MRS] + .OUTPUT_FIXED - .INPUT_FIXED;
		    end;

	end;

    !
    ! Finally create the file.
    !
    STATUS = $RMS_CREATE (FAB = OUT_FAB);

    ! Get the best file name string available into NAM$B_RSL/NAM$L_RSA
    !
    IF .OUT_NAM[NAM$B_RSL] NEQ 0
    THEN
	0
    ELSE IF .OUT_NAM[NAM$B_ESL] NEQ 0
    THEN
	OUT_NAM[NAM$B_RSL] = .OUT_NAM[NAM$B_ESL]
    ELSE
	BEGIN
	CH$MOVE(.OUT_FAB[FAB$B_FNS], .OUT_FAB[FAB$L_FNA],
	    .OUT_NAM[NAM$L_RSA]);
	OUT_NAM[NAM$B_RSL] = .OUT_FAB[FAB$B_FNS];
	END;

    if not .STATUS
    then
	return RMS_ERROR (SOR$_OPENOUT, OUT_NAM, OUT_FAB);

    !
    ! Check all parameters for validity based on the sort type.
    !

    if .SOR$GB_SOR_TYP lss SOR$GK_INDEX
    then
	begin
	!
	! If input RFM is variable and output RFM is fixed then error.
	!

	if (.COM_FAB [FAB$B_RFM] eql FAB$C_VAR or .COM_FAB [FAB$B_RFM] eql FAB$C_VFC) and .OUT_FAB [FAB$B_RFM] eql
	    FAB$C_FIX
	then
	    return SOR$_VAR_FIX;

	!
	! If the file already existed check that any user specified attributes
	! agree with the files existing attributes.
	!

	if .OUT_FAB [FAB$L_STS] neq RMS$_CREATED
	then
	    begin

	    if .SOR$GB_OUT_ORG geq 0
	    then

		if .OUT_FAB [FAB$B_ORG] neq .SOR$GB_OUT_ORG
		then
		    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    if .SOR$GB_OUT_RFM geq 0
	    then

		if .OUT_FAB [FAB$B_RFM] neq .SOR$GB_OUT_RFM
		then
		    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    if .SOR$GW_OUT_BLS geq 0
	    then

		if .OUT_FAB [FAB$W_BLS] neq .SOR$GW_OUT_BLS
		then
		    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    if .SOR$GW_OUT_MRS geq 0
	    then

		if .OUT_FAB [FAB$W_MRS] neq .SOR$GW_OUT_MRS
		then
		    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    if .SOR$GB_OUT_BKS geq 0
	    then

		if .OUT_FAB [FAB$B_BKS] neq .SOR$GB_OUT_BKS
		then
		    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    if .SOR$GB_OUT_FSZ geq 0
	    then

		if .OUT_FAB [FAB$B_FSZ] neq .SOR$GB_OUT_FSZ
		then
		    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    if .OUT_FAB [FAB$B_RFM] eql FAB$C_UDF
	    then				    ! Udefined not valid
		return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	    end
	else

	    if .OUT_FAB [FAB$B_ORG] eql FAB$C_IDX
	    then
		return RMS_ERROR (SOR$_IND_OVR, OUT_NAM, 0);

	end
    else
	begin

	if .OUT_FAB [FAB$B_ORG] neq FAB$C_SEQ
	then
	    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	if .OUT_FAB [FAB$B_RFM] neq FAB$C_FIX
	then
	    return RMS_ERROR (SOR$_INCONSIS, OUT_NAM, 0);

	end;

    !
    ! Copy fields needed by sort algorithms into parameter area.
    !
    SOR$GB_OUT_RFM = .OUT_FAB [FAB$B_RFM];
    SOR$GB_OUT_FSZ = .OUT_FAB [FAB$B_FSZ];
    return SUCCESS;
    end;

psect
    code = SOR$RMSCOM;


%title 'SOR$$OUT_RAB'

global routine SOR$$OUT_RAB : novalue weak =

!++
! Functional Description:
!
!	This routine sets up the rab for the output file and connects.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	Error code on error or success.
!
!
! Side Effects:
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';



    macro
	KEY_TYPE =
	    0, 0, 8, 0 %,
	KEY_ORDER =
	    0, 8, 8, 0 %,
	KEY_POS =
	    1, 0, 16, 0 %,
	KEY_SIZE =
	    2, 0, 16, 0 %;

    literal
	MAX_MBF = 10,
	OUT_MBC = 5,
	OUT_MBF = 9,
	BKS_OVER = 24;						! Index bucket overhead

    label
	TESTKEY;

    !
    ! Initialize the RAB based on sort type and file organization.
    !
    $RAB_INIT (RAB = OUT_RAB, KRF = 0, RAC = SEQ, ROP = WBH, FAB = OUT_FAB);

    if .OUT_FAB [FAB$W_MRS] neq 0
    then

	if .SOR$GL_BUF_SIZE*BLK_BYTES/.OUT_FAB [FAB$W_MRS] lssu MAX_MBF
	then
	    OUT_RAB [RAB$B_MBF] = .SOR$GL_BUF_SIZE*BLK_BYTES/.OUT_FAB [FAB$W_MRS]
	else
	    OUT_RAB [RAB$B_MBF] = MAX_MBF;

    selectone .OUT_FAB [FAB$B_ORG] of
	set

	[FAB$C_SEQ] :
	    begin

	    if .SOR$GB_SOR_TYP gtr SOR$GK_TAG then OUT_RAB [RAB$W_RSZ] = .OUT_FAB [FAB$W_MRS];

	    !
	    ! Compute the amount of buffer space that can be use for multi
	    ! buffering and multi block reads based on the device
	    ! characteristics.
	    !
	    ! If organization is sequential and the device is disk
	    ! use MBC and MBF if there are more than 8 blocks available.
	    ! Otherwise use MBF as large as possible for all other types.
	    !

	    if not .block [OUT_FAB [FAB$L_DEV], DEV$V_SQD;, byte] and .block [OUT_FAB [FAB$L_DEV], DEV$V_DIR;,
		    byte]
	    then

		begin
		    OUT_RAB [RAB$B_MBC] = RP06_TRK;
		    OUT_RAB [RAB$B_MBF] = MBF_COUNT;
		    end


	    else

		if .OUT_FAB [FAB$W_MRS] eql 0
		then

		    if .SOR$GW_IN_LRL neq 0 and
			 .SOR$GL_BUF_SIZE*BLK_BYTES/.SOR$GW_IN_LRL lssu MAX_MBF
		    then
			OUT_RAB [RAB$B_MBF] = .SOR$GL_BUF_SIZE*BLK_BYTES/.SOR$GW_IN_LRL
		    else
			OUT_RAB [RAB$B_MBF] = MAX_MBF;

	    end;

	[FAB$C_REL] :
	    0;

	[FAB$C_IDX] :
	    begin
	    OUT_RAB [RAB$B_KSZ] = .SOR$GB_KEY_SIZE;

	    if .OUT_FAB [FAB$W_MRS] eql 0
	    then

		if .SOR$GL_BUF_SIZE*BLK_BYTES/(.OUT_FAB [FAB$B_BKS]*BLK_BYTES - BKS_OVER) lssu MAX_MBF
		then
		    OUT_RAB [RAB$B_MBF] = .SOR$GL_BUF_SIZE*BLK_BYTES/(.OUT_FAB [FAB$B_BKS]*BLK_BYTES - BKS_OVER)
		else
		    OUT_RAB [RAB$B_MBF] = MAX_MBF;

	    !
	    ! If the primary key of the file is the same as the sort key
	    ! then do sequential and mass insert; otherwise do keyed insert.
	    !
TESTKEY :
	    begin
	    OUT_RAB [RAB$B_RAC] = RAB$C_KEY;

	    case .KEY_XAB [XAB$B_DTP] from XAB$C_STG to XAB$C_PAC of
		set

		[XAB$C_STG] :
		    begin

		    if .KEY_XAB [XAB$B_TKS] lss .SOR$GB_KEY_SIZE then leave TESTKEY;

		    if .KEY_XAB [XAB$B_NSG] lss .SOR$GB_NUM_KEYS then leave TESTKEY;

		    incr SEG from 0 to .SOR$GB_NUM_KEYS - 1 do
			begin

			if .SOR$AW_KEY_BUF [.SEG, KEY_TYPE] neq SOR$GK_CHAR_KEY then leave TESTKEY;

			if .(KEY_XAB [XAB$B_SIZ0] + .SEG)<0, 8> neq .SOR$AW_KEY_BUF [.SEG, KEY_SIZE]
			then
			    leave TESTKEY;

			if .(KEY_XAB [XAB$W_POS0] + (.SEG*2))<0, 16> neq .SOR$AW_KEY_BUF [.SEG, KEY_POS] - 1
			then
			    leave TESTKEY;

			if .SOR$AW_KEY_BUF [.SEG, KEY_ORDER] then leave TESTKEY;

			end;

		    end;

		[XAB$C_IN2] :
		    begin

		    if .SOR$AW_KEY_BUF [0, KEY_TYPE] neq SOR$GK_BIN_KEY then leave TESTKEY;

		    if .KEY_XAB [XAB$B_SIZ0] neq .SOR$AW_KEY_BUF [0, KEY_SIZE] then leave TESTKEY;

		    if .KEY_XAB [XAB$W_POS0] neq .SOR$AW_KEY_BUF [0, KEY_POS] - 1 then leave TESTKEY;

		    if .SOR$AW_KEY_BUF [0, KEY_ORDER] then leave TESTKEY;

		    end;

		[XAB$C_IN4] :
		    begin

		    if .SOR$AW_KEY_BUF [0, KEY_TYPE] neq SOR$GK_BIN_KEY then leave TESTKEY;

		    if .KEY_XAB [XAB$B_SIZ0] neq .SOR$AW_KEY_BUF [0, KEY_SIZE] then leave TESTKEY;

		    if .KEY_XAB [XAB$W_POS0] neq .SOR$AW_KEY_BUF [0, KEY_POS] - 1 then leave TESTKEY;

		    if .SOR$AW_KEY_BUF [0, KEY_ORDER] then leave TESTKEY;

		    end;

		[XAB$C_PAC] :
		    begin

		    if .SOR$AW_KEY_BUF [0, KEY_TYPE] neq SOR$GK_PACK_KEY then leave TESTKEY;

		    if .KEY_XAB [XAB$B_SIZ0] neq (.SOR$AW_KEY_BUF [0, KEY_SIZE]/2) + 1 then leave TESTKEY;

		    if .KEY_XAB [XAB$W_POS0] neq .SOR$AW_KEY_BUF [0, KEY_POS] - 1 then leave TESTKEY;

		    if .SOR$AW_KEY_BUF [0, KEY_ORDER] then leave TESTKEY;

		    end;

		[inrange] :
		    leave TESTKEY;
		tes;

	    OUT_RAB [RAB$B_RAC] = RAB$C_SEQ;
	    OUT_RAB [RAB$L_ROP] = RAB$M_WBH and RAB$M_MAS;
	    end;


	    !
	    ! If /LOAD_FILL set load bit of ROP.
	    !
	    if .SOR$GV_FLAGS [SOR$GK_LOAD_FIL] then
		OUT_RAB [RAB$V_LOA] = 1;

	    end;

	[otherwise] :
	    0;							! No other file orgs than these.
	tes;

    !
    ! Finally connect to the FAB.
    !

    if not $RMS_CONNECT (RAB = OUT_RAB)
    then
	return RMS_ERROR (SOR$_OPENOUT, OUT_NAM, OUT_RAB);

    if .SOR$GV_FLAGS [SOR$GK_UTILITY]
    then
	begin
	SOR$AL_STATS [OUT_MBC] = .OUT_RAB [RAB$B_MBC];
	SOR$AL_STATS [OUT_MBF] = .OUT_RAB [RAB$B_MBF];
	end;

    return SUCCESS;
    end;

psect
    code = SOR$RMSCOM;


%title 'OPEN_FILE'
routine OPEN_FILE : JSBL =

!++
! Functional Description:
!
!	This routine calls the rms file name parser and opens the file.
!
!
! Formal Parameters:
!
!	None.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	1 for success, 0 for error.
!
!
! Side Effects:
!
!	If an error occurs a message is sent to the user.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';

    local
	STATUS;

    STATUS = $RMS_OPEN (FAB = COM_FAB);

    ! Get the best file name string available into NAM$B_RSL/NAM$L_RSA
    !
    IF .COM_NAM[NAM$B_RSL] NEQ 0
    THEN
	0
    ELSE IF .COM_NAM[NAM$B_ESL] NEQ 0
    THEN
	COM_NAM[NAM$B_RSL] = .COM_NAM[NAM$B_ESL]
    ELSE
	BEGIN
	CH$MOVE(.COM_FAB[FAB$B_FNS], .COM_FAB[FAB$L_FNA],
	    .COM_NAM[NAM$L_RSA]);
	COM_NAM[NAM$B_RSL] = .COM_FAB[FAB$B_FNS];
	END;

    if not .STATUS
    then
	return RMS_ERROR (SOR$_OPENIN, COM_NAM, COM_FAB);

    return SUCCESS;
    end;

psect
    code = SOR$SORTCOM;


%title 'SOR$$SORT_GET'

global routine SOR$$SORT_GET (DESC) =

!++
!
!
! Functional Description:
!
!	Routine to get a record for the sort process.  If the current
!	file reaches end of file, the next file is opened and started
!	up.
!
! Formal Parameters:
!
!	DESC -	Address where the descriptor is to be stored.
!		This must be three longwords in length.
!
! Global Inputs:
!
!	SOR$GB_NUM_FILE, SOR$GV_DDB_TABL.
!
!
! Global Outputs:
!
!	SOR$GB_DDB_PTR
!
!
!
! Routine Value:
!
!	Status code.
!	RMS$_EOF if all the imput files have reached end of file.
!
!
!
!--


    begin

    map
	DESC:	REF VECTOR[3];

    while 1 do

	begin
	local
	    TEMP;

	TEMP = 0;

	! Attempt to get a record
	!
	if .SOR$GB_CUR_FILE geq 0 then
	    begin
	    TEMP = SOR$$GET_RECORD (.DESC);
	    if .TEMP neq RMS$_EOF then return .TEMP;
	    end;


	! If no current file, or previous read reached end-of-file,
	! try another file.
	!
!	if .SOR$GB_CUR_FILE lss 0 or .TEMP eql RMS$_EOF then

	    begin
	    SOR$GB_CUR_FILE = .SOR$GB_CUR_FILE + 1;
	    if .SOR$GB_CUR_FILE eql .SOR$GB_NUM_FILE then return RMS$_EOF;
	    SOR$GL_DDB_PTR = .SOR$GV_DDB_TABL [.SOR$GB_CUR_FILE];  ! Set up the new ddb.
	    TEMP = SOR$$RAB_INIT (.SOR$GW_IN_LRL, DESC[0]);
	    if not .TEMP then return .TEMP;
	    end
!
!	else
!	    return .TEMP;
!
	end;

    return RMS$_EOF;	! Will never get here
    end;

%title 'SOR$$GET_RECORD'

global routine SOR$$GET_RECORD (DESC): JSBL weak =

!++
! Functional Description:
!
!	This routine calls the rms get record routine to read a record
!	from a file.
!
!
! Formal Parameters:
!
!	DESC -	The address of the record descriptor.
!		This must be a vector of three longwords.
!
!
! Implicit Inputs:
!
!	The FAB and RAB already initialized for the appropriate file.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!	Status code.
!	Success, RMS$_EOF, or an RMS error.
!
! Side Effects:
!
!	If an error occurs a message is sent to the user.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';

    map
	DESC: ref vector[3];			! Record descriptor and RFA.

    literal
	RECORDS_IN = 0;

    !
    ! Get records until either a record is read or end of file is reached.
    ! Print a warning message for every read error that occurs.
    !

    while 1 do
	begin

	if .COM_RAB [RAB$L_UBF] eql 0
	then

	    if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC
	    then
		begin
		COM_RAB [RAB$L_RHB] = .SOR$GL_IN_BUF;
		COM_RAB [RAB$L_UBF] = .SOR$GL_IN_BUF + .COM_FAB [FAB$B_FSZ];
		end
	    else
		COM_RAB [RAB$L_UBF] = .SOR$GL_IN_BUF;

	if .SOR$GV_FLAGS [SOR$GK_UTILITY] and not .SOR$GV_FLAGS [SOR$GK_FINAL] and .COM_RAB [RAB$L_UBF] neq
	    RECORD_BUFFER
	then
	    SOR$AL_STATS [RECORDS_IN] = .SOR$AL_STATS [RECORDS_IN] + 1;

	selectone $RMS_GET (RAB = COM_RAB) of
	    set

	    [RMS$_EOF] :
		begin

		if .SOR$GV_FLAGS [SOR$GK_UTILITY] and .COM_RAB [RAB$L_UBF] neq RECORD_BUFFER
		then
		    SOR$AL_STATS [RECORDS_IN] = .SOR$AL_STATS [RECORDS_IN] - 1;

		! Close the file, since we reached the end of file.
		! If this is a tag sort, do not close the file yet.
		!
		if .SOR$GB_SOR_TYP neq SOR$GK_TAG
		then
		    SOR$$CLOSE_FILE (0);
		return RMS$_EOF;
		end;

	    [RMS$_RTB] :	! Record too big
		begin

		if .SOR$GV_FLAGS [SOR$GK_UTILITY]
		then 
		    return RMS_ERROR (SOR$_BAD_LRL, COM_NAM, COM_RAB)
		else
		    0;		! Okay if user-callable interface

		if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC
		then
		    DESC [0] = .COM_RAB [RAB$W_RSZ] + .COM_FAB [FAB$B_FSZ]
		else
		    DESC [0] = .COM_RAB [RAB$W_RSZ];

		DESC [1] = .COM_RAB [RAB$L_RBF];
		DESC [2] = COM_RAB [RAB$L_RFA0];
		return SUCCESS;
		end;

	    [RMS$_SUC] :

		if .COM_RAB [RAB$W_RSZ] neq 0
		then
		    begin

		    if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC
		    then
			DESC [0] = .COM_RAB [RAB$W_RSZ] + .COM_FAB [FAB$B_FSZ]
		    else
			DESC [0] = .COM_RAB [RAB$W_RSZ];

		    DESC [1] = .COM_RAB [RAB$L_RBF];
		    DESC [2] = COM_RAB [RAB$L_RFA0];

		    if .COM_RAB [RAB$L_UBF] neq RECORD_BUFFER
		    and .SOR$GW_IN_LRL gtru .DESC [0]
		    then
			ch$fill (%x'0', (.SOR$GW_IN_LRL - .DESC [0]),
			    ch$ptr (.SOR$GL_IN_BUF + .DESC [0]));

		    return SUCCESS;
		    end;

	    [otherwise] :
		return RMS_ERROR (SOR$_READERR, COM_NAM, COM_RAB);

	    tes;

	end;

    return 0;	! Will never get here
    end;

psect
    code = SOR$SORTCOM;


%title 'SOR$$PUT_RECORD'

global routine SOR$$PUT_RECORD (LEN, ADR) : JSBL weak =

!++
! Functional Description:
!
!	This routine calls the rms put record routine to write a record
!	to a file.
!
!
! Formal Parameters:
!
!	The length and address of the record.
!
!
! Implicit Inputs:
!
!	The FAB and RAB already initialized for the appropriate file.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	1 for success or an error code.
!
!
! Side Effects:
!
!	If an error occurs a message is sent to the user.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';



    bind
	RFA1 = .SOR$GL_IN_BUF + 4 : word;

    literal
	RFA_SIZE = 6,
	RECORDS_OUT = 4;

    !
    ! Put the record into the output file. If this is a tag sort then reopen
    ! the input file and read the record by RFA. Print a warning message if a
    ! write error occurs.
    !

    if .SOR$GB_SOR_TYP eql SOR$GK_TAG
    then
	begin

	if .FIRST_TIME
	then
	    begin
%(
	    ! Since we did not close the file, we do not need to reopen it.
	    ! However, set the RAC field to RFA for the last pass of tag sorts.
	    !
	    COM_FAB [FAB$L_FOP] = FAB$M_NAM;
	    COM_FAB [FAB$B_DNS] = 0;
	    COM_FAB [FAB$B_FNS] = 0;
	    COM_NAM [NAM$B_ESS] = 0;
	    COM_NAM [NAM$B_RSS] = 0;

	    if not OPEN_FILE () then return SOR$_OPENIN;

	    SOR$$RAB_INIT (.SOR$GW_IN_LRL);
)%
	    COM_RAB [RAB$B_RAC] = RAB$C_RFA;
	    FIRST_TIME = 0;
	    end;

	COM_RAB [RAB$L_RFA0] = ..ADR;				! Set up RFA.
	COM_RAB [RAB$W_RFA4] = .(.ADR + 4);

	if not
	    begin
	    local
		DESC: vector[3];
	    SOR$$GET_RECORD (DESC)
	    end
	then
	    return SOR$_READERR;

	OUT_RAB [RAB$L_RBF] = .COM_RAB [RAB$L_RBF];

	if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC then OUT_RAB [RAB$L_RHB] = .COM_RAB [RAB$L_RHB];

	OUT_RAB [RAB$W_RSZ] = .COM_RAB [RAB$W_RSZ];
	end
    else

	if .SOR$GB_SOR_TYP gtr SOR$GK_RECORD
	then
	    OUT_RAB [RAB$L_RBF] = .ADR
	    !
	    ! If this is a record sort, then if the input format is VFC
	    ! copy the fixed portion field if output is VFC.  Adjust the
	    ! buffer address and record size to exclude the fixed portion
	    ! from the actual record.  Otherwise just copy the record as
	    ! is.
	    !
	else

	    if .COM_FAB [FAB$B_RFM] eql FAB$C_VFC
	    then
		begin
		OUT_RAB [RAB$L_RHB] = .ADR;
		OUT_RAB [RAB$W_RSZ] = .LEN - .COM_FAB [FAB$B_FSZ];
		OUT_RAB [RAB$L_RBF] = .ADR + .COM_FAB [FAB$B_FSZ];
		end
	    else
		begin
		OUT_RAB [RAB$L_RBF] = .ADR;
		OUT_RAB [RAB$W_RSZ] = .LEN;
		end;

    if .OUT_RAB [RAB$B_RAC] eql RAB$C_KEY
    then
	OUT_RAB [RAB$L_KBF] = .ADR - .SOR$GB_KEY_SIZE
    else
	OUT_RAB [RAB$L_KBF] = KEY_BUF;

    if not $RMS_PUT (RAB = OUT_RAB)
    then
	return RMS_ERROR (SOR$_WRITEERR, OUT_NAM, OUT_RAB)
    else
	if .SOR$GV_FLAGS [SOR$GK_UTILITY]
	then
	    SOR$AL_STATS [RECORDS_OUT] = .SOR$AL_STATS [RECORDS_OUT] + 1;

    KEY_BUF = .KEY_BUF + 1;
    return SUCCESS;
    end;

psect
    code = SOR$CONTROL;


%title 'SOR$$CLOSE_FILE'

global routine SOR$$CLOSE_FILE (OUTPUT_FLAG) : =

!++
! Functional Description:
!
!	This routine disconnects and closes a file.
!
!
! Formal Parameters:
!
!	A flag indicating whether to close the output file, as
!	well as the input file or delete it.
!
!
! Implicit Inputs:
!
!	The RAB and FAB initialized for the appropriate file.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!	Status code.
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	If an error occurs a message is sent to the user.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';



    literal
	CLOSE_IN = 0,
	CLOSE_OUT = 1,
	DELETE_OUT = 2;

    !
    ! Based on the output flag either close the output file and the input file,
    ! close the input file or close the input file and delete the output file.
    ! Return any errors.
    !

    if not .OUTPUT_FLAG or .SOR$GB_SOR_TYP eql SOR$GK_TAG
    then
	begin
	$RMS_DISCONNECT (RAB = COM_RAB);

	if .COM_FAB [FAB$W_IFI] nequ 0 then	! Close file if not already closed
	if not $RMS_CLOSE (FAB = COM_FAB)
	then
	    return RMS_ERROR (SOR$_CLOSEIN, COM_NAM, COM_FAB);

	FIRST_TIME = 1;
	end;

    if .OUTPUT_FLAG gtr CLOSE_IN
    then
	begin

	if .OUTPUT_FLAG
	then
	    $RMS_DISCONNECT (RAB = OUT_RAB)
	else

	    if .OUT_FAB [FAB$B_ORG] neq FAB$C_IDX then OUT_FAB [FAB$L_FOP] = FAB$M_DLT;

	if not $RMS_CLOSE (FAB = OUT_FAB)
	then
	    return RMS_ERROR (SOR$_CLOSEOUT, OUT_NAM, OUT_FAB);

	!
	! Reset all output options to initial values in case called again.
	!
	KEY_BUF = 1;
	SOR$GB_OUT_ORG = -1;
	SOR$GB_OUT_FSZ = -1;
	SOR$GB_OUT_RFM = -1;
	SOR$GB_OUT_BKS = -1;
	SOR$GW_OUT_MRS = -1;
	SOR$GW_OUT_BLS = -1;
	SOR$GL_OUT_FOP = 0;
	SOR$GL_OUT_ALQ = 0;
	end;

    return SUCCESS;
    end;

psect
    code = SOR$ABORT;


%title 'RMS_ERROR'
routine RMS_ERROR (ERROR_CODE, NAM, FAB_RAB) : JSBL =

!++
! Functional Description:
!
!	If this is the Sort/Merge utility,
!	    Call the common error routine to report RMS errors.
!
!	If this is the callable interface,
!	    Return the error status.
!
! Formal Parameters:
!
!	The error code, the name block address and the address of the FAB
!	or RAB.
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!	If not the utility, then the same error status as was passed
!	(sharable messages are converted to use Sort's facility code).
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	A message is sent to the user.
!
!--

    begin

    map
	NAM : ref block [, byte],
	FAB_RAB : ref block [, byte];

    if .SOR$GV_FLAGS [SOR$GK_UTILITY]
    then
	begin
	!
	! Simply call the common error routine.
	!
	if .FAB_RAB eql 0
	then
	    SOR$$ERROR (.ERROR_CODE, .NAM [NAM$B_RSL], .NAM [NAM$L_RSA])
	else
	    SOR$$ERROR (.ERROR_CODE, .NAM [NAM$B_RSL], .NAM [NAM$L_RSA], .FAB_RAB [FAB$L_STS], .FAB_RAB [FAB$L_STV]);
	end;

    return .ERROR_CODE;
    end;

psect
    code = SOR$RMSOPEN;


%title 'SOR$PASS_FILES'

global routine SOR$PASS_FILES (INPUT_DESC_ADR, OUTPUT_DESC_ADR, OUT_ORG_ADR, OUT_RFM_ADR, OUT_BKS_ADR,
	OUT_BLS_ADR, OUT_LRL_ADR, OUT_ALQ_ADR, OUT_FOP_ADR) : =

!++
! Functional Description:
!
!	This routine copies the specified filenames into the appropriate
!	area and calls the open input routine.
!
!
! Formal Parameters:
!
!	The descriptor for the output file name, the output file
!	organization, record format, bucket size, block size, max record
!	size, allocation quantity, file options and the descriptor for
!	the input filename.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!	An error code on error.
!
!
! Completion Codes:
!
!	1 for success.
!
!
! Side Effects:
!
!	The input file is opened.
!
!--

    begin
    require 'SRC$:MAPDDB.REQ';



    builtin
	ap;

    local
	OUTPUT_DESC,
	TEMP;


    macro
	LEN =
	    0, 0, 16, 0 %,
	ARGS =
	    0, 0, 8, 0 %,
	ADR =
	    4, 0, 32, 0 %;

    map
	OUTPUT_DESC : ref block [,byte],	! Output filename descriptor.
	ap : ref block [, byte];

    literal
	SORT_ON = %x'474';			! Combine SORT2-SORT6, MERGE2


    bind
	OUT_ORG = .OUT_ORG_ADR : vector [, byte],
	OUT_RFM = .OUT_RFM_ADR : vector [, byte],
	OUT_BKS = .OUT_BKS_ADR : vector [, byte],
	OUT_BLS = .OUT_BLS_ADR : vector [, word],
	OUT_LRL = .OUT_LRL_ADR : vector [, word],
	OUT_ALQ = .OUT_ALQ_ADR : vector,
	OUT_FOP = .OUT_FOP_ADR : vector,
	INPUT_DESC = .INPUT_DESC_ADR : block [, byte];

    !
    ! Move the filenames into the common area.
    !

    if (.SOR$GV_FLAGS and SORT_ON) neq 0 then return SOR$_SORT_ON;

    if .SOR$GB_NUM_FILE gtr 0 then		! If 2nd or gtr input file

	begin
	    if .ap [ARGS] gtru 1 then return SOR$_SORT_ON; ! Can't be more than 1 arg.
	    TEMP = 1;					   ! Also, can't be less.
	    end
	else
	    TEMP = 2;					! If 1st call, must be at least 2 args.



    if .ap [ARGS] lssu .TEMP then return SOR$_BAD_ADR;

    if not .SOR$GV_FLAGS [SOR$GK_UTILITY] then LIB$ESTABLISH (LIB$SIG_TO_RET);

    TEMP = SOR$$NEW_INPUT ();			! Set up DDB for next input file.
    if not .TEMP then return .TEMP;		! Bomb if can't get memory.



    if .INPUT_DESC [LEN] gtru NAM$C_MAXRSS  then return SS$_RESULTOVF;

    ! Move the filenames, stripping trailing blanks and tabs.
    MOVE_FILE_NAME (.INPUT_DESC [ADR], .INPUT_DESC [LEN], SOR$GT_INP_NAME, TEMP);
    SOR$GB_INP_SIZ = .TEMP;			! Adjusted name size


    if .ap [ARGS] eql 1 then return SOR$$OPEN_INPUT ();

    OUTPUT_DESC = .OUTPUT_DESC_ADR;		! Point to the output descriptor.
    MOVE_FILE_NAME (.OUTPUT_DESC [ADR], .OUTPUT_DESC [LEN], SOR$GT_OUT_NAME, TEMP);
    SOR$GB_OUT_SIZ = .TEMP;

    !
    ! Move output file options into parameter area.
    !

    if .ap [ARGS] gtru 2
    then

	if OUT_ORG [0] neq 0 then SOR$GB_OUT_ORG = .OUT_ORG [0];

    if .ap [ARGS] gtru 3
    then

	if OUT_RFM [0] neq 0 then SOR$GB_OUT_RFM = .OUT_RFM [0];

    if .ap [ARGS] gtru 4
    then

	if OUT_BKS [0] neq 0 then SOR$GB_OUT_BKS = .OUT_BKS [0];

    if .ap [ARGS] gtru 8
    then

	if OUT_FOP [0] neq 0 then SOR$GL_OUT_FOP = .OUT_FOP [0];

    if .ap [ARGS] gtru 7
    then

	if OUT_ALQ [0] neq 0 then SOR$GL_OUT_ALQ = .OUT_ALQ [0];

    if .ap [ARGS] gtru 6
    then

	if OUT_LRL [0] neq 0 then SOR$GW_OUT_MRS = .OUT_LRL [0];

    if .ap [ARGS] gtru 5
    then

	if OUT_BLS [0] neq 0 then SOR$GW_OUT_BLS = .OUT_BLS [0];

    return SOR$$OPEN_INPUT ();
    end;

%title 'SOR$$NEW_INPUT'

global routine SOR$$NEW_INPUT =


!++
!
!
!
! Functional Description:
!
!	Routine to get a DDB containing the FAB and RAB for a new
!	input file.  The address of the new DDB is placed in
!	SOR$GL_DDB_PTR and in SOR$GV_DDB_TABL.  SOR$GB_NUM_FILE
!	is updated to contain the number of input files.
!
!
!
!
! Global Inputs:
!
!
!	SOR$GL_NUM_FILE.
!
!
!
! Global Outputs:
!
!	SOR$GL_NUM_FILE, SOR$GV_DDB_TABL, SOR$GL_DDB_PTR.
!
!
! Routine Value:
!
!	SUCCESS or an error code.
!
!
!--


    begin


	local
	    FILE,
	    TEMP;



	FILE = .SOR$GB_NUM_FILE;	! Use current file number as index.

	if .FILE gequ SOR$GK_MAX_FILE then return SOR$_INP_FILES;  ! Error if too many files.

	SOR$GB_NUM_FILE = .FILE + 1;	! Update number of files.

	TEMP = LIB$GET_VM (%ref (SOR$GK_DDB_SIZE), SOR$GL_DDB_PTR);  ! Get memory for the FAB/RAB.
	if not .TEMP then return SOR$_VM_FAIL;

	SOR$GV_DDB_TABL [.FILE] = .SOR$GL_DDB_PTR;	! Save address in table for SOR$END_SORT.

	SUCCESS
	end;

%title 'MOVE_FILE_NAME'

routine MOVE_FILE_NAME (NAME, LENGTH, NAME_BUFFER, NEW_LENGTH): novalue =


!++
!
! 
! Functional Description:
!
!	This routine copies a file name to a name buffer, stripping
!	trailing blanks and nulls and returning the adjusted length.
!	(RMS doesn't like file names with trailing blanks.)
!
!
!
! Formal Parameters:
!
!	NAME (ref)		a byte vector containing the file name.
!
!	LENGTH (val)		the number of characters in NAME.
!
!	NAME_BUFFER (ref)	a buffer to put the resultant file name.
!
!	NEW_LENGTH (ref)	the length of the name after the trailing
!				blanks and nulls have been removed.
!
!
!
!
!
!--



    begin

	map
	    NAME: ref vector [,byte],
	    NAME_BUFFER: ref vector [,byte];


	local
	    COUNT;



	COUNT = .LENGTH - 1;		! Start scanning at the last character.

	while .NAME [.COUNT] eql ' ' or .NAME [.COUNT] eql 0 do

	    begin
		COUNT = .COUNT - 1;
		if .COUNT lss 0 then exitloop;
		end;

	.NEW_LENGTH = .COUNT + 1;	! Save adjusted character count.

	ch$move (..NEW_LENGTH, ch$ptr(NAME [0]), ch$ptr(NAME_BUFFER [0])); ! Move the name.

	end;

end

eludom
