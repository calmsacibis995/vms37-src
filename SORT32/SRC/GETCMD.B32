!-*-BLISS-*-
!<BLF/WIDTH:116>
!<BLF/REMARK:8>
!<BLF/NOPLIT>
!<BLF/MACRO>
!<BLF/LOWERCASE_KEY>
!<BLF/UPPERCASE_USER>
module SOR$GET_CMD (language (bliss32) ,
		list (assembly) ,
		unames,
		ident = 'V03-000'
		) =
begin

psect
    code = SOR$CLI,
    own = SOR$CLIDATA,
    plit = SOR$CLI ( execute);

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! Facility:
!
!	SORT
!
!
! Abstract:
!
!	This module contains the routines which talk to DCL and
!	process the command line.
!
!
! Environment:
!
!	Starlet Operating System, User mode utility
!
!
! Author:
!
!	Ellen R Simich,		Creation Date:		1-Sep-77
!	Robert A Surtees,	Modification Date:	1-Sep-79
!
!
! Modified by:
!
!	V02.03		PDG0003		Peter D Gilbert	8-Feb-1982
!		Clean up usage of SHR$ errors.
!	V02.02		JDN0002		Joe Neumeister	21-Sep-1981
!		Change SOR$GV_FLAGS and PARSER_FLAGS from a 
!    		    bitvector [16] to a bitvector [32] to allow 
!		    new switches, (/STATISTICS).
!		Add a new qualifier (/STATISTICS), which if used, will 
!		    cause SORT statistics to be outputed.
!	V02.01		JDN0001		Joe Neumeister	12-Mar-1981
!		Declare ERROR symbols as external literals to allow
!		    new error messages to be outputted.
!
!--

!
! TABLE OF CONTENTS:
!

forward routine
    NUMERIC_PARSE : novalue,					! Parse a number
    GET_SPEC_FILE : novalue,					! Parse specification file name
    GET_COLL_SEQ : novalue,					! Get argument of /COLLATING_SEQUE=
    SET_SORT_TYPE : novalue,					! Set type of sort requested
    SET_OUTPUT_FMT : novalue,					! Set output file record format
    SET_INPUT_FMT : novalue,					! Set input record format
    SET_OVERLAY : novalue,					! Set output file overlay
    SET_OUT_CONTIG : novalue,					! Set output file contiguous
    PARSE_KEY : novalue,					! Parse and store key definitions
    KEYWORD_MATCH,						! Compare keyword strings
    CLI_ERROR : novalue;					! Parsing error

!
! INCLUDE FILES:
!

library 'SYS$LIBRARY:CLIMAC.L32';				! DCL bliss macros

library 'SYS$LIBRARY:STARLET.L32';				! DCL symbols


!
! MACROS:
!

macro
    KEY_TYPE =
	0, 0, 8, 0 %,						! Fields for key buffer blocks
    KEY_ORDER =
	0, 8, 8, 0 %,
    KEY_POS =
	1, 0, 16, 0 %,
    KEY_SIZE =
	2, 0, 16, 0 %,
    CALL_CLI =
	(.CLI_RECALL) %,					! Call back to CLI
    QUALIFIER_ERROR =
	PARSER_FLAGS [CLI_QUAL_ERROR] %;			! Error parsing qualifier value

!
! EQUATED SYMBOLS:
!

external literal
    SOR$GK_MAX_FILE : unsigned (4),				! Maximum number of input files.
    SOR$GK_STABLE : unsigned (4),				! Bit flag for stable sort.
    SOR$GK_LOAD_FIL : unsigned (4),				! LOAD_FILL flag
    SOR$GK_EBCDIC : unsigned (4),				! EBCDIC collating sequence.
    SOR$GK_LOG_STATS : unsigned (5),				! Print SORT statistics flag bit --JDN
    SOR$GK_RECORD : unsigned (1),				! Sort types
    SOR$GK_TAG : unsigned (2),
    SOR$GK_INDEX : unsigned (3),
    SOR$GK_ADDRESS : unsigned (3),
    SOR$_MISS_KEY,				! Declare ERROR symbols
    SOR$_WORK_DEV,				!  as external literals
    SOR$_NO_WRK,
    SOR$_VM_FAIL,
    SOR$_WS_FAIL,
    SOR$_SORT_ON,
    SOR$_BAD_KEY,
    SOR$_NUM_KEY,
    SOR$_BAD_LEN,
    SOR$_ONE_IN,
    SOR$_IND_OVR,
    SOR$_INCONSIS,
    SOR$_VAR_FIX,
    SOR$_BAD_TYPE,
    SOR$_LRL_MISS,
    SOR$_BAD_SPEC,
    SOR$_BAD_LRL,
    SOR$_BAD_FILE,
    SOR$_BAD_ADR,
    SOR$_MAP,
    SOR$_EXTEND,
    SOR$_KEY_LEN,
    SOR$_CLEAN_UP,
    SOR$_BAD_MERGE,
    SOR$_BAD_ROUTIN,
    SOR$_INP_FILES,
    SOR$_BAD_ORDER;


literal
    ERROR = 0,
    SUCCESS = 1,
    SEQ_ORG = 2,						! Bit definitions for parser flag
    REL_ORG = 3,
    INDEX_ORG = 4,
    RECORD_LENGTH = 5,
    BUCKET_SIZE = 6,
    ALLOC_SIZE = 7,
    WORK_FILES = 8,
    CLI_QUAL_ERROR = 9,
    STABLE_SORT = 10,					! If /STABLE
    LOAD_FILL_FLAG = 12;				! If /LOAD_FILL

literal
    FLT_SIZE = 4,						! Sizes for floating point keys
    FLTD_SIZE = 8,
    FLTG_SIZE = 8,
    FLTH_SIZE = 16;
LITERAL
    SORT_ERROR = 28;				! Facility code for VAX-11 Sort
MACRO
    DEFSHR_[MSG,SEV] =
	%NAME('SOR$_',MSG) =
		%NAME('SHR$_',MSG) +
		%NAME('STS$K_',SEV) + SORT_ERROR ^ 16 %;
LITERAL
    DEFSHR_(
	BADBYTE,  SEVERE,
	BADWORD,  SEVERE,
	BADFIELD, SEVERE);

!
! OWN STORAGE:
!
$CLIQUALCODES (SORT, 						! All qualifiers to sort command line
    PROCESS, 							! Sort types
    KEY, 							! Sort key specification
    WORK_FILES, 						! Scratch file spec
    SPECIFICATION, 						! Specification file name
    SEQUENTIAL, 						! Output file organization
    relative, INDEXED_SEQUENT, FORMAT, 				! File record format
    BUCKET_SIZE, ALLOCATION, 					! Output file size to preallocate
    overlay, 							! Overlay existing file
    CONTIGUOUS,							! Output file contiguous
    STABLE,							! Stable sort
    LOAD_FILL,							! /LOAD_FILL
    COLLATING_SEQUE,						! Collating sequence
    STATISTICS							! print SORT statistics   --JDN
);								! End of qualifiers

own
    !
    ! Initialize parse request descriptor block
    !
    INIT_PRS_DESC : $CLIREQDESC (RQTYPE = INITPRS, 		! Initialiazation
                                 ERRACT = CLI_ERROR,            ! Error routine
                                 RQFLGS = ABSADR),              ! Use absolute addressing
    !
    ! Sort command qualifiers request descriptor blocks.
    !
    COMMAND_QUAL : $CLIQUALDESC (QDCODE = PROCESS, 		! PROCESS qualifier
                                 TRUACT = SET_SORT_TYPE),       ! Action routine if found

    WORK_QUAL : $CLIQUALDESC (QDCODE = WORK_FILES, 		! WORK_FILES qualifier
                              SETLST = WORK_FILES,              ! Set WORK_FILES to true
                              TRUACT = NUMERIC_PARSE),          ! Action routine if found

    SPEC_QUAL : $CLIQUALDESC (QDCODE = SPECIFICATION, 		! SPECIFICATION qualifier
                              TRUACT = GET_SPEC_FILE),          ! Action routine if found

    KEY_QUAL : $CLIQUALDESC (QDCODE = KEY, 			! KEY qualifier
                             TRUACT = PARSE_KEY),               ! Action routine if found

    COLL_QUAL : $CLIQUALDESC (QDCODE = COLLATING_SEQUE,		! COLLATING_SEQUENCE qualifier.
    			      TRUACT = GET_COLL_SEQ),		! Action routine.

    STABLE_QUAL : $CLIQUALDESC (QDCODE = STABLE,		! STABLE qualifier
			        SETLST = STABLE_SORT),		! Set flag if found

    STATS_QUAL : $CLIQUALDESC (QDCODE = STATISTICS,		! Print SORT statistics qualifier  --JDN
			        SETLST = SOR$GK_LOG_STATS),	! Set flag if found  --JDN



    CMD_QUAL_END : $CLIQUALEND,

    !
    ! Request command qualifiers block
    !
    COMMAND_DESC : $CLIREQDESC (RQTYPE = GETQUAL, 		! Get command qualifiers
                                RQFLGS = ABSADR,                ! Use absolute addressing
                                QUALST = COMMAND_QUAL,
                                ERRACT = CLI_ERROR),
    !
    ! Output file qualifiers descriptor blocks.
    !
    ! (Can only have one file organization.)
    !
    OUT_FILE_QUAL : $CLIQUALDESC (QDCODE = SEQUENTIAL, 		! SEQUENTIAL qualifier
                                  TSTLST = (REL_ORG,            ! Error if REL_ORG is set
                                            INDEX_ORG),         ! Error if INDEX_ORG is set
                                  SETLST = SEQ_ORG),            ! Set SEQ_ORG to true

    RELATIVE_QUAL : $CLIQUALDESC (QDCODE = relative, 		! RELATIVE qualifier
                                  TSTLST = (SEQ_ORG,            ! Error if SEQ_ORG is set
                                            INDEX_ORG),         ! Error if INDEX_ORG is set
                                  SETLST = REL_ORG),            ! Set REL_ORG to true

    INDEXED_QUAL : $CLIQUALDESC (QDCODE = INDEXED, 		! INDEXED qualifier
                                 TSTLST = (SEQ_ORG,             ! Error if SEQ_ORG is set
                                           REL_ORG),            ! Error if REL_ORG is set
                                 SETLST = INDEX_ORG),           ! Set INDEX_ORG to true


    LOAD_FILL_QUAL : $CLIQUALDESC (QDCODE = LOAD_FILL,		! /LOAD_FILL
				   SETLST = LOAD_FILL_FLAG),	! Set flag


    FORMAT_QUAL : $CLIQUALDESC (QDCODE = FORMAT, 		! FORMAT qualifier
                                TRUACT = SET_OUTPUT_FMT),       ! Action routine if found

    OVERLAY_QUAL : $CLIQUALDESC (QDCODE = OVERLAY, 		! OVERLAY qualifier
                                 TRUACT = SET_OVERLAY),         ! Action routine if found

    BUCK_SIZE_QUAL : $CLIQUALDESC (QDCODE = BUCKET_SIZE, 	! BUCKET_SIZE qualifier
                                   TRUACT = NUMERIC_PARSE,      ! Action routine if found
                                   SETLST = BUCKET_SIZE),       ! Set BUCKET_SIZE to true

    ALLOC_QUAL : $CLIQUALDESC (QDCODE = ALLOCATION, 		! ALLOCATION qualifier
                               TRUACT = NUMERIC_PARSE,          ! Action routine if found
                               SETLST = ALLOC_SIZE),            ! Set ALLOC_SIZE to true

    CONTIG_QUAL : $CLIQUALDESC (QDCODE = CONTIGUOUS, 		! CONTIGUOUS qualifier
                                TRUACT = SET_OUT_CONTIG),       ! Action routine if found
    END_OUT_QUAL : $CLIQUALEND,

    !
    ! Request output file and qualifiers block (input2 temp until CLI fixed)
    !
    OUT_FILE_DESC : $CLIREQDESC (RQTYPE = INPUT2, 		! Output parameter
                                 RQFLGS = ABSADR,               ! Use absolute addressing
                                 QUALST = OUT_FILE_QUAL,        ! Associated qualifier descriptor
                                 ABSACT = (CLI_ERROR),          ! Error if not present
                                 ERRACT = CLI_ERROR),           ! Error routine

    !
    ! Input file qualifiers request blocks.
    !
    FORM_QUAL : $CLIQUALDESC (QDCODE = FORMAT, 			! FORMAT qualifier
                              TRUACT = SET_INPUT_FMT),          ! Action routine if found
    END_IN_QUAL : $CLIQUALEND,

    !
    ! Request input file and qualifiers blocks
    !
    INPUT_FILE_DESC : $CLIREQDESC (RQTYPE = INPUT1, 		! Input parameter
                                   RQFLGS = ABSADR,             ! Use absolute addressing
                                   QUALST = FORM_QUAL,          ! Pointer to associated qualifier
                                   ABSACT = (CLI_ERROR),        ! Error if absent
                                   ERRACT = CLI_ERROR),         ! Error routine

    NEXT_FILE_DESC : $CLIREQDESC (RQTYPE = INPUT1, 		! Input parameter
                                   RQFLGS = ABSADR,             ! Use absolute addressing
				   BITNUM = SUCCESS,		! Set bit if present
				   QUALST = FORM_QUAL,		! Pointer to qualifier
                                   ERRACT = CLI_ERROR),         ! Error routine

    END_INPUT_DESC : $CLIREQDESC (RQTYPE = ENDPRM1, 		! Complete parsing
				  RQFLGS = ABSADR,		! Absolute addressing.
                                  ERRACT = CLI_ERROR),          ! Error routine

    !
    ! Qualifier number value descriptor block
    !
    NUMBER_DESC : $CLIREQDESC (RQTYPE = NUMERVAL, 		! Get numeric value
                               RQFLGS = ABSADR,                 ! Use absolute addressing
                               ERRACT = CLI_ERROR),             ! Error routine

    !
    ! Qualifier string value descriptor block
    !
    STRING_DESC : $CLIREQDESC (RQTYPE = ASCIIVAL, 		! Get ascii string value
                               RQFLGS = ABSADR,                 ! Use absolute addressing
                               ERRACT = CLI_ERROR),             ! Error routine

    CLI_RECALL,
    CLI_WORK_AREA : vector [CLI$C_WORKAREA, byte],

    !
    ! Sort parser flags
    !
    PARSER_FLAGS : bitvector [32];				! Change from [16] to [32] to    --JDN
								!    add space for new qualifiers. --JDN

!
! EXTERNAL REFERENCES:
!

external routine
    SOR$PASS_FILES,						! Pass file names.
    SOR$$ERROR : novalue weak;

external literal 						! Key types
    SOR$GK_CHAR_KEY : unsigned (1),                             ! Character
    SOR$GK_BIN_KEY : unsigned (2),                              ! Binary
    SOR$GK_ZONE_KEY : unsigned (2),                             ! Zoned decimal
    SOR$GK_PACK_KEY : unsigned (3),                             ! Packed decimal
    SOR$GK_USB_KEY : unsigned (3),                              ! Unsigned Binary
    SOR$GK_DLO_KEY : unsigned (3),                              ! Decimal leading overpunch sign
    SOR$GK_DLS_KEY : unsigned (3),                              ! Decimal leading separate sign
    SOR$GK_DTO_KEY : unsigned (4),                              ! Decimal trailing overpunch sign
    SOR$GK_DTS_KEY : unsigned (4),                              ! Decimal tailing separate sign
    SOR$GK_FLT_KEY : unsigned (4),                              ! Floating point
    SOR$GK_FLTD_KEY : unsigned (4),                             ! Double precision floating point
    SOR$GK_FLTG_KEY : unsigned (4),                             ! G_floating floating point
    SOR$GK_FLTH_KEY : unsigned (4),                             ! H_floating floating point

    SOR$GK_NUM_KEYS : unsigned (4);				! Number of keys allowed

external
    SOR$GB_OUT_ORG : byte,					! Output file organization
    SOR$GL_OUT_FOP,						! Output file options
    SOR$GB_OUT_FSZ : byte,					! Output file VFC size
    SOR$GW_OUT_MRS : word,					! Output file maximum record size
    SOR$GL_OUT_ALQ,						! Output file allocation quantity
    SOR$GW_OUT_BLS : word,					! Output file block size
    SOR$GB_OUT_RFM : byte,					! Output file record format
    SOR$GB_OUT_BKS : byte,					! Output file bucket size
    SOR$GT_OUT_NAME : vector [ch$allocation (NAM$C_MAXRSS)],	! Output file name
    SOR$GB_OUT_SIZ : byte,					! Output file name size
    SOR$GT_INP_NAME : vector [ch$allocation (NAM$C_MAXRSS)],	! Input file name
    SOR$GB_INP_SIZ : byte,					! Input file name size
    SOR$GT_SPECNAME : vector [ch$allocation (NAM$C_MAXRSS)],	! Specification file name
    SOR$GB_SPECSIZE : byte,					! Specification file name size
    SOR$GB_WRK_FIL : byte,					! Number of work files
    SOR$GB_NUM_KEYS : byte,					! Number of keys defined
    SOR$AW_KEY_BUF : blockvector [, 3, word],			! Key definition buffer
    SOR$GW_IN_LRL : word,					! Input longest record length
    SOR$GL_IN_ALQ,						! File size
    SOR$GV_FLAGS : bitvector [32],				! Sort flags
    SOR$GB_SOR_TYP : byte;					! Type of sort to perform


%title 'SOR$PARSE_CMD'

global routine SOR$PARSE_CMD (CALL_BACK) : =

!++
! Functional Description:
!
!	This routine request the sort command line from DCL and calls DCL to
!	parse it.
!
!
! Formal Parameters:
!
!	The address of the cli service routines.
!
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	The sort prameters as specified by the user are set up, the key
!	definitions are placed in the key buffer and the filenames are passed
!	to the routine which calls rms to open them.
!
!
! Routine Value:
!
!	True if parse completed with no errors, false if an error occured.
!
!
! Completion Codes:
!
!	None.
!
! Side Effects:
!
!	None.
!
!--

    begin
!

	local
	    INDEX,
	    TEMP;


! Initialize work area and parse parameters for DCL.
!
    KEY_QUAL [CLI$V_ALLOCCUR] = 1;				! Ask for all key definitions
    CLI_RECALL = .CALL_BACK;					! Set up call back address

    if not CALL_CLI						! Call CLI initialization
	(INIT_PRS_DESC, CLI_WORK_AREA, PARSER_FLAGS)
    then
	return ERROR;						! Error return

    if not CALL_CLI						! Get command qualifiers
	(COMMAND_DESC, CLI_WORK_AREA, PARSER_FLAGS) or .QUALIFIER_ERROR
    then
	return ERROR;						! Error return

    if not CALL_CLI						! Get output file spec and its qualifiers
	(OUT_FILE_DESC, CLI_WORK_AREA, PARSER_FLAGS) or .QUALIFIER_ERROR
    then
	return ERROR;						! Error return

    if not CALL_CLI						! Get input file spec
	(INPUT_FILE_DESC, CLI_WORK_AREA, PARSER_FLAGS)
    then
	return ERROR;						! Error return

!
! Copy all output options specified to output file parameter
! area.
!

    if .PARSER_FLAGS [BUCKET_SIZE]
    then

	if .BUCK_SIZE_QUAL [CLI$L_RQVALU] gtru 255
	then
	    SOR$$ERROR (SOR$_BADBYTE, .BUCK_SIZE_QUAL [CLI$L_RQVALU],
		0)
	else
	    SOR$GB_OUT_BKS = .BUCK_SIZE_QUAL [CLI$L_RQVALU];

    if .PARSER_FLAGS [ALLOC_SIZE] then SOR$GL_OUT_ALQ = .ALLOC_QUAL [CLI$L_RQVALU];

    if .PARSER_FLAGS [WORK_FILES]
    then

	if .WORK_QUAL [CLI$L_RQVALU] gtru 255
	then
	    SOR$$ERROR (SOR$_BADBYTE, .WORK_QUAL [CLI$L_RQVALU], 0)
	else
	    SOR$GB_WRK_FIL = .WORK_QUAL [CLI$L_RQVALU];

    if .PARSER_FLAGS [SEQ_ORG]
    then
	SOR$GB_OUT_ORG = FAB$C_SEQ
    else

	if .PARSER_FLAGS [REL_ORG]
	then
	    SOR$GB_OUT_ORG = FAB$C_REL
	else

	    if .PARSER_FLAGS [INDEX_ORG] then SOR$GB_OUT_ORG = FAB$C_IDX;


!
! Copy Options
!


    if .PARSER_FLAGS [STABLE_SORT] then SOR$GV_FLAGS [SOR$GK_STABLE] = 1;

    if .PARSER_FLAGS [LOAD_FILL_FLAG] then SOR$GV_FLAGS [SOR$GK_LOAD_FIL] = 1;

    if .PARSER_FLAGS [SOR$GK_LOG_STATS] then SOR$GV_FLAGS [SOR$GK_LOG_STATS] = 1;	! set STATISTICS flag  --JDN


!
!
! Copy the filenames.
!
    TEMP = SOR$PASS_FILES (INPUT_FILE_DESC [CLI$W_RQSIZE], OUT_FILE_DESC [CLI$W_RQSIZE]);
    if not .TEMP then return .TEMP;


!
! Now get the rest of the input files.
!

    INDEX = 2;

    do				! Until 10 parameters or null parameter

	begin

	if not CALL_CLI						! Terminate the parse
	    (END_INPUT_DESC, CLI_WORK_AREA, PARSER_FLAGS)

	    then return ERROR;

	    if  .END_INPUT_DESC [CLI$V_MOREINP] then
	        begin
		    if not CALL_CLI 
		    (NEXT_FILE_DESC, CLI_WORK_AREA, PARSER_FLAGS)
		    then
		    return ERROR;

	            if .PARSER_FLAGS [SUCCESS] then

		    begin
			TEMP = SOR$PASS_FILES (NEXT_FILE_DESC [CLI$W_RQSIZE]);
			if not .TEMP then return .TEMP;
			end;

	        end;

	    INDEX = .INDEX + 1;

	    end


    until not .END_INPUT_DESC [CLI$V_MOREINP] or .INDEX gtru SOR$GK_MAX_FILE;

    if .INDEX gtru SOR$GK_MAX_FILE then
	    if not CALL_CLI						! Terminate the parse
		(END_INPUT_DESC, CLI_WORK_AREA, PARSER_FLAGS) or .END_INPUT_DESC [CLI$V_MOREINP]
	! Too many inputs
    then
	begin
	CLI_ERROR (END_INPUT_DESC, SOR$_INP_FILES);
	return SOR$_INP_FILES;
	end
    else
	return SUCCESS;						! Successful return

    SUCCESS
    end;


%title 'NUMERIC_PARSE'
routine NUMERIC_PARSE (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine calls the CLI to parse a decimal ASCII number into a
!	binary value.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!
! Completion Codes:
!
!	If an error occurs qualifier_error is set to one.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    map
	QUAL_DESC : ref block [, byte];				! Give block attribute to formal

    if CALL_CLI							! Call CLI to parse value
	(NUMBER_DESC, CLI_WORK_AREA, .QUAL_DESC)
    then

	if .QUAL_DESC eql ALLOC_QUAL or .QUAL_DESC eql WORK_QUAL or .QUAL_DESC eql BUCK_SIZE_QUAL
	then
	    QUAL_DESC [CLI$L_RQVALU] = .NUMBER_DESC [CLI$L_RQVALU]
	else
	    0

    else
	QUALIFIER_ERROR = 1;					! Store value in descriptor block

    end;

%title 'GET_SPEC_FILE'
routine GET_SPEC_FILE (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine calls the CLI to parse a file name and stores it in the
!	sort parameter area.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
! Implicit Outputs:
!
!	None.
!
! Routine Value:
!
!
! Completion Codes:
!
!	If an error occurs qualifier_error is set to one.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    literal
	DEFAULT_SIZE = 9;					! Default file name size

    map
	QUAL_DESC : ref block [, byte];				! Give block attribute to formal

    if .SPEC_QUAL [CLI$W_QDVALSIZ] neq 0			! Name given?
    then

	if CALL_CLI						! Call CLI to parse filename
	    (STRING_DESC, CLI_WORK_AREA, .QUAL_DESC)
	then
	    begin
	    ch$move (.STRING_DESC [CLI$W_RQSIZE], ch$ptr (.STRING_DESC [CLI$A_RQADDR]), ch$ptr (SOR$GT_SPECNAME));
	    SOR$GB_SPECSIZE = .STRING_DESC [CLI$W_RQSIZE];	! Move name and size
	    end							! into parameter area
	else
	    QUALIFIER_ERROR = 1

    else
	SOR$GB_SPECSIZE = DEFAULT_SIZE;

    end;

%title 'SET_OUTPUT_FMT'
routine SET_OUTPUT_FMT (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine sets the output file record format in the output file
!	parameter area.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    map
	QUAL_DESC : ref block [, byte];				! Give block attribute to formal

    bind
	KEYWORD_TABLE = plit (plit byte(%asciz'FIXED'),
                              plit byte(%asciz'VARIABLE'),    ! 
                              plit byte(%asciz'CONTROLLED'),  ! 
                              plit byte(%asciz'SIZE'),        ! 
                              plit byte(%asciz'BLOCK_SIZE')) : vector;	!

    local
	NUMBER_ADR;

    map
	NUMBER_ADR : ref vector [, word];

    label
	CASEBLOCK;

    literal
	FIX = 0,
	VAR = 1,
	CON = 2,
	SIZ = 3,
	BLK = 4;

!
! Determine which format was specified and set the appropriate
! attributes in the output file area.
!

    do								! Continue until no more keywords in list

	if CALL_CLI (STRING_DESC, CLI_WORK_AREA, .QUAL_DESC)
	then
CASEBLOCK :
	    begin

	    case KEYWORD_MATCH (KEYWORD_TABLE, .STRING_DESC [CLI$W_RQSIZE], ch$ptr (.STRING_DESC [CLI$A_RQADDR]))
	    from FIX to BLK of
		set

		[FIX] :
		    begin
		    SOR$GB_OUT_RFM = FAB$C_FIX;

		    if .STRING_DESC [CLI$V_KEYVALU]		! If colon seen
		    then 					! get optional LRL number
			NUMBER_ADR = SOR$GW_OUT_MRS
		    else
			begin
			NUMBER_DESC [CLI$V_MOREVALS] = .STRING_DESC [CLI$V_MOREVALS];
			leave CASEBLOCK;
			end;

		    end;

		[VAR] :
		    begin
		    SOR$GB_OUT_RFM = FAB$C_VAR;

		    if .STRING_DESC [CLI$V_KEYVALU]		! If colon seen
		    then 					! get optional LRL number
			NUMBER_ADR = SOR$GW_OUT_MRS
		    else
			begin					! otherwise set up bit for loop
			NUMBER_DESC [CLI$V_MOREVALS] = .STRING_DESC [CLI$V_MOREVALS];
			leave CASEBLOCK;
			end;

		    end;

		[CON] :
		    begin
		    SOR$GB_OUT_RFM = FAB$C_VFC;

		    if .STRING_DESC [CLI$V_KEYVALU]		! If colon seen
		    then 					! get optional LRL number
			NUMBER_ADR = SOR$GW_OUT_MRS
		    else
			begin					! otherwise set up bit for loop
			NUMBER_DESC [CLI$V_MOREVALS] = .STRING_DESC [CLI$V_MOREVALS];
			leave CASEBLOCK;
			end;

		    end;

		[SIZ] :
		    begin
		    NUMERIC_PARSE (.QUAL_DESC);

		    if not .QUALIFIER_ERROR
		    then

			if .NUMBER_DESC [CLI$L_RQVALU] gtru 255
			then
			    SOR$$ERROR (SOR$_BADBYTE,
				.NUMBER_DESC [CLI$L_RQVALU], 0)
			else
			    SOR$GB_OUT_FSZ = .NUMBER_DESC [CLI$L_RQVALU];

		    leave CASEBLOCK;
		    end;

		[BLK] :
		    NUMBER_ADR = SOR$GW_OUT_BLS;

		[outrange] :
		    SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0);
		tes;

	    NUMERIC_PARSE (.QUAL_DESC);

	    if not .QUALIFIER_ERROR
	    then

		if .NUMBER_DESC [CLI$L_RQVALU] gtru 65536
		then
		    SOR$$ERROR (SOR$_BADWORD,
			.NUMBER_DESC [CLI$L_RQVALU], 0)
		else
		    NUMBER_ADR [0] = .NUMBER_DESC [CLI$L_RQVALU];

	    end
	else
	    SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0)

    while .NUMBER_DESC [CLI$V_MOREVALS];

    end;

%title 'SET_SORT_TYPE'
routine SET_SORT_TYPE (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine sets the sort type to perform in the sort parameter area.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    bind
	KEYWORD_TABLE = plit (plit byte(%asciz'RECORD'),
                              plit byte(%asciz'TAG'), ! 
                              plit byte(%asciz'ADDRESS'),     ! 
                              plit byte(%asciz'INDEX')) : vector;	!

    literal
	REC = 0,
	TAG = 1,
	ADR = 2,
	IND = 3;

!
! Determine which type was specified and set the appropriate attribute
! in the sort parameter area.
!

    if CALL_CLI (STRING_DESC, CLI_WORK_AREA, .QUAL_DESC)
    then

	case KEYWORD_MATCH (KEYWORD_TABLE, .STRING_DESC [CLI$W_RQSIZE], ch$ptr (.STRING_DESC [CLI$A_RQADDR])) from
	    REC to IND of
	    set

	    [REC] :
		SOR$GB_SOR_TYP = SOR$GK_RECORD;

	    [TAG] :
		SOR$GB_SOR_TYP = SOR$GK_TAG;

	    [ADR] :
		SOR$GB_SOR_TYP = SOR$GK_ADDRESS;

	    [IND] :
		SOR$GB_SOR_TYP = SOR$GK_INDEX;

	    [outrange] :
		SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0);
	    tes

    else
	QUALIFIER_ERROR = 1;

    end;

%title 'SET_OVERLAY'
routine SET_OVERLAY (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine sets the overlay attribute for the output file.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin
    SOR$GL_OUT_FOP = .SOR$GL_OUT_FOP or FAB$M_CIF;		! Set overlay option
    end;

%title 'SET_OUT_CONTIG'
routine SET_OUT_CONTIG (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine sets the contiguous attribute for the output file.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin
    SOR$GL_OUT_FOP = .SOR$GL_OUT_FOP or FAB$M_CTG;		! Set output file options
    end;

%title 'SET_INPUT_FMT'
routine SET_INPUT_FMT (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine sets the input file record format in the input file
!	parameter area.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    map
	QUAL_DESC : ref block [, byte];				! Give block attribute to formal

    bind
	KEYWORD_TABLE = plit (plit byte(%asciz'FILE_SIZE'),
                              plit byte(%asciz'RECORD_SIZE')) : vector;	!

    literal
	REC = 1,
	FILE = 0;

!
! Get values and store them away.
!

    do								! Continue until no more keywords in list

	if CALL_CLI (STRING_DESC, CLI_WORK_AREA, .QUAL_DESC)
	then

	    case KEYWORD_MATCH (KEYWORD_TABLE, .STRING_DESC [CLI$W_RQSIZE], ch$ptr (.STRING_DESC [CLI$A_RQADDR]))
	    from FILE to REC of
		set

		[REC] :
		    begin
		    NUMERIC_PARSE (.QUAL_DESC);

		    if not .QUALIFIER_ERROR
		    then

			if .NUMBER_DESC [CLI$L_RQVALU] gtru 65536
			then
			    SOR$$ERROR (SOR$_BADWORD,
				.NUMBER_DESC [CLI$L_RQVALU], 0)
			else
			    SOR$GW_IN_LRL = .NUMBER_DESC [CLI$L_RQVALU];

		    end;

		[FILE] :
		    begin
		    NUMERIC_PARSE (.QUAL_DESC);

		    if not .QUALIFIER_ERROR then SOR$GL_IN_ALQ = .NUMBER_DESC [CLI$L_RQVALU];

		    end;

		[outrange] :
		    SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0);
		tes

	else
	    SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0)

    while .NUMBER_DESC [CLI$V_MOREVALS];

    end;

%title 'PARSE_KEY'
routine PARSE_KEY (QUAL_DESC) : novalue =

!++
! Functional Description:
!
!	This routine parses the key definition and stores it in the key
!	buffer.
!
!
! Formal Parameters:
!
!	The address of the qualifier descriptor block.
!
!
! Implicit Inputs:
!
!	The key buffer in SOR$AW_KEY_BUF.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    own
	KEY_NUM : byte initial (0);

    !
    ! Table of keywords
    !

    bind
	KEYWORD_TABLE = plit (plit byte (%asciz'ASCENDING'),	!
			      plit byte (%asciz'BINARY'),       !
                              plit byte (%asciz'CHARACTER'),    ! 
                              plit byte (%asciz'DECIMAL'),      ! 
                              plit byte (%asciz'DESCENDING'),   ! 
                              plit byte (%asciz'UNSIGNED'),     ! 
                              plit byte (%asciz'F_FLOATING'),   ! 
                              plit byte (%asciz'D_FLOATING'),   !
                              plit byte (%asciz'G_FLOATING'),   !
                              plit byte (%asciz'H_FLOATING'),   !
                              plit byte (%asciz'LEADING_SIGN'), ! 
                              plit byte (%asciz'NUMBER'),       ! 
                              plit byte (%asciz'OVERPUNCHED_SIGN'),     ! 
                              plit byte (%asciz'POSITION'),     ! 
                              plit byte (%asciz'PACKED_DECIMAL'),       ! 
                              plit byte (%asciz'SIZE'),         !
                              plit byte (%asciz'SEPARATE_SIGN'),!
                              plit byte (%asciz'TRAILING_SIGN'),! 
                              plit byte (%asciz'ZONED')) : vector;	!

    local
	CURRENT_KEY;

    map
	CURRENT_KEY : ref block [, word],
	QUAL_DESC : ref block [, byte];

    literal
	TABLE_SIZE = 18,					! Total number of table entries
	ASCENDING = 0,						! Table index for keyword
	BINARY    = 1,
	CHARACTER = 2,
	DECIMAL   = 3,
	DESCENDING= 4,
        UNS_BINARY= 5,
        FLOATING  = 6,
        DOUBLE    = 7,
        G_FLOATING= 8,
        H_FLOATING= 9,
        LEADING   = 10,
	NUMBER    = 11,
	OVERPUNCH = 12,
	POSITION  = 13,
	PACKED    = 14,
	SIZE      = 15,
	SEPARATE  = 16,
	TRAILING  = 17,
	ZONED     = 18,
	SEP_BIT   = 0,						! Bits for key_flags
	LEAD_BIT  = 1,
	UNSIGNED_BIT = 2;

    stacklocal 							! Temporary storage for key
	TYPE        : byte,
	DESC_SWITCH : byte,
	POS         : word,
	SIZ         : word,
	KEY_FLAGS   : bitvector [8];				! Key parser flags

    KEY_NUM       = .KEY_NUM + 1;                               ! Set up defaults
    TYPE          = SOR$GK_CHAR_KEY;
    DESC_SWITCH   = 0;
    POS           = 0;
    SIZ           = 0;
    KEY_FLAGS     = 0;

    do								! Continue until no more keywords in list

	if CALL_CLI						! Get keyword
	    (STRING_DESC, CLI_WORK_AREA, .QUAL_DESC)
	then

	    case KEYWORD_MATCH (KEYWORD_TABLE, .STRING_DESC [CLI$W_RQSIZE], ch$ptr (.STRING_DESC [CLI$A_RQADDR]))
	    from 0 to TABLE_SIZE of
		set

		[BINARY] :

		    if .KEY_FLAGS [UNSIGNED_BIT] then

			TYPE = SOR$GK_USB_KEY			! Set key type to unsigned binary.

		    else

			TYPE = SOR$GK_BIN_KEY;			! Set key type to binary

		[DECIMAL] :

		    if .KEY_FLAGS [SEP_BIT]			! Set key type to decimal
		    then

			if .KEY_FLAGS [LEAD_BIT] then TYPE = SOR$GK_DLS_KEY else TYPE = SOR$GK_DTS_KEY

		    else

			if .KEY_FLAGS [LEAD_BIT] then TYPE = SOR$GK_DLO_KEY else TYPE = SOR$GK_DTO_KEY;

		[DESCENDING] :
		    DESC_SWITCH = 1;				! Set key order

                [UNS_BINARY]:
                    begin
			if .TYPE eql SOR$GK_BIN_KEY then	! If BINARY then
			    TYPE = SOR$GK_USB_KEY;		! Then make it unsigned.

			KEY_FLAGS [UNSIGNED_BIT] = 1;		! Set unsigned binary flag.
                    end;

                [FLOATING]:
                    begin
                        TYPE  = SOR$GK_FLT_KEY;                 ! Set key type to floating
                        SIZ   = FLT_SIZE;                       ! Size is 4 bytes
                    end;

                [DOUBLE]:
                    begin
                        TYPE = SOR$GK_FLTD_KEY;                 ! Set key type to double
                        SIZ   = FLTD_SIZE;                      ! Size is 8 bytes
                    end;

                [G_FLOATING]:
                    begin
                        TYPE = SOR$GK_FLTG_KEY;                 ! Set key type to g_floating
                        SIZ   = FLTG_SIZE;                      ! Size is 8 bytes
                    end;

                [H_FLOATING]:
                    begin
                        TYPE = SOR$GK_FLTH_KEY;                 ! Set key type to h_floating
                        SIZ   = FLTH_SIZE;                      ! Size is 16 bytes
                    end;

		[LEADING] :
		    begin					! Set decimal sign position

		    if .KEY_FLAGS [SEP_BIT] then TYPE = SOR$GK_DLS_KEY else TYPE = SOR$GK_DLO_KEY;

		    KEY_FLAGS [LEAD_BIT] = 1;
		    end;

		[NUMBER] :
		    begin					! Set key number
		    NUMERIC_PARSE (.QUAL_DESC);

		    if not .QUALIFIER_ERROR
		    then

			if .NUMBER_DESC [CLI$L_RQVALU] gtru 10
			then
			    CLI_ERROR (.QUAL_DESC, SOR$_NUM_KEY)
			else
			    KEY_NUM = .NUMBER_DESC [CLI$L_RQVALU];

		    STRING_DESC [CLI$V_MOREVALS] = .NUMBER_DESC [CLI$V_MOREVALS];
		    end;

		[OVERPUNCH] :
		    begin					! Set decimal sign position

		    if .KEY_FLAGS [LEAD_BIT] then TYPE = SOR$GK_DLO_KEY else TYPE = SOR$GK_DTO_KEY;

		    KEY_FLAGS [SEP_BIT] = 0;
		    end;

		[PACKED] :
		    TYPE = SOR$GK_PACK_KEY;			! Set key type to packed

		[POSITION] :
		    begin					! Set starting position of key
		    NUMERIC_PARSE (.QUAL_DESC);

		    if not .QUALIFIER_ERROR
		    then

			if .NUMBER_DESC [CLI$L_RQVALU] gtru 65536
			then
			    CLI_ERROR (.QUAL_DESC, SOR$_BAD_KEY)
			else
			    POS = .NUMBER_DESC [CLI$L_RQVALU];

		    STRING_DESC [CLI$V_MOREVALS] = .NUMBER_DESC [CLI$V_MOREVALS];
		    end;

		[SEPARATE] :
		    begin					! Set decimal sign position

		    if .KEY_FLAGS [LEAD_BIT] then TYPE = SOR$GK_DLS_KEY else TYPE = SOR$GK_DTS_KEY;

		    KEY_FLAGS [SEP_BIT] = 1;
		    end;

		[SIZE] :
		    begin					! Set size of key field
		    NUMERIC_PARSE (.QUAL_DESC);

		    if not .QUALIFIER_ERROR
		    then

			if .NUMBER_DESC [CLI$L_RQVALU] gtru 65536
			then
			    CLI_ERROR (.QUAL_DESC, SOR$_BAD_KEY)
			else
			    SIZ = .NUMBER_DESC [CLI$L_RQVALU];

		    STRING_DESC [CLI$V_MOREVALS] = .NUMBER_DESC [CLI$V_MOREVALS];
		    end;

		[TRAILING] :
		    begin					! Set decimal sign position

		    if .KEY_FLAGS [SEP_BIT] then TYPE = SOR$GK_DTS_KEY else TYPE = SOR$GK_DTO_KEY;

		    KEY_FLAGS [LEAD_BIT] = 0;
		    end;

		[ZONED] :
		    TYPE = SOR$GK_ZONE_KEY;			! Set key type to zoned

		[CHARACTER, ASCENDING] :
		    0;						! Default already set

		[inrange, outrange] :
		    SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0);
		tes

	else
	    SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE], .STRING_DESC [CLI$A_RQADDR], 0)

    while .STRING_DESC [CLI$V_MOREVALS];

    if .POS eql 0 or .SIZ eql 0					! Size and position mandatory
    then
	CLI_ERROR (.QUAL_DESC, SOR$_BAD_KEY);

    if .KEY_NUM gtr SOR$GK_NUM_KEYS				! Key number less than 10
    then
	CLI_ERROR (.QUAL_DESC, SOR$_NUM_KEY);

    if .QUALIFIER_ERROR gtr 0 then return ERROR;

!
! Copy key definition with defaults to block in key buffer.
!
    CURRENT_KEY = SOR$AW_KEY_BUF [.KEY_NUM - 1, KEY_TYPE];
    CURRENT_KEY [KEY_TYPE] = .TYPE;
    CURRENT_KEY [KEY_ORDER] = .DESC_SWITCH;
    CURRENT_KEY [KEY_POS] = .POS;
    CURRENT_KEY [KEY_SIZE] = .SIZ;
    SOR$GB_NUM_KEYS = .SOR$GB_NUM_KEYS + 1;
    end;

%title 'GET_COLL_SEQ'

routine GET_COLL_SEQ (QUAL_DESC): novalue = 

!++
!
!
! Functional Description:
!
!	Routine to call CLI to get the argument of the /COLLATING_SEQUE
!	qualifier.  The two valid arguments are ASCII and EBCDIC.  If no
!	argument is given, ASCII is assumed.
!
!
!
! Formal Parameters:
!
!	QUAL_DESC	address of the qualifier descriptor block.
!
!
!
! Implicit Outputs:
!
!	SOR$GV_FLAGS [SOR$GK_EBCDIC] is turned on if EBCDIC was specified.
!
!
!
!--


    begin


	literal
	    ASCII = 0,
	    EBCDIC= 1;


	map
	    QUAL_DESC : ref block [,byte];

	bind
	    KEYWORD_TABLE = plit (plit byte (%asciz 'ASCII'),
				  plit byte (%asciz 'EBCDIC')) : vector;



	if CALL_CLI (STRING_DESC, CLI_WORK_AREA, .QUAL_DESC) then

	    case KEYWORD_MATCH (KEYWORD_TABLE, .STRING_DESC [CLI$W_RQSIZE],
				ch$ptr (.STRING_DESC [CLI$A_RQADDR]))
		 from ASCII to EBCDIC of

		set

		    [ASCII]:
			;

		    [EBCDIC]:
			SOR$GV_FLAGS [SOR$GK_EBCDIC] = 1;	! Set flag for SORT.

		    [outrange]:
			SOR$$ERROR (SOR$_BADFIELD, .STRING_DESC [CLI$W_RQSIZE],
				    .STRING_DESC [CLI$A_RQADDR],0);

		    tes;

	end;

%title 'KEYWORD_MATCH'
routine KEYWORD_MATCH (TABLE, TEXT_SIZE, TEXT_PTR) : =

!++
! Functional Description:
!
!	This routine matches a typed in keyword with a table entry.
!
!
! Formal Parameters:
!
!	The table address, the size of the typed in keyword and a pointer to
!	the typed in keyword.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!	The index into the table of the keywrd if success.
!
!
! Completion Codes:
!
!	-1 if error.
!
!
! Side Effects:
!
!	None.
!
!--

    begin

    map
	TABLE : ref vector;

    local
	TABLE_INDEX;						! Routine return value

!
! Search through table looking for a single match. If more than one
! match is found return an error.
!
    TABLE_INDEX = -1;						! Initialize return to error

    incr index from 0 to .TABLE [-1] - 1 do

	if ch$eql (.TEXT_SIZE, .TEXT_PTR, .TEXT_SIZE, ch$ptr (.TABLE [.index]))
	then

	    if .TABLE_INDEX geq 0 then return -1 else TABLE_INDEX = .index;	! Set up return value

    return .TABLE_INDEX;
    end;

psect
    code = SOR$ABORT;


%title 'CLI_ERROR'
routine CLI_ERROR (QUAL_DESC, ERRCODE) : novalue =

!++
! Functional Description:
!
!	This routine calls the error routine with the appropraite parameters.
!
!
! Formal Parameters:
!
!	The qualifier descriptor block and an error code.
!
!
! Implicit Inputs:
!
!	None.
!
!
! Implicit Outputs:
!
!	None.
!
!
! Routine Value:
!
!
! Completion Codes:
!
!	None.
!
!
! Side Effects:
!
!	The utility exits.
!
!
!--

    begin

    map
	QUAL_DESC : ref block [, byte];

    SOR$$ERROR (.ERRCODE, .QUAL_DESC [CLI$W_RQSIZE], .QUAL_DESC [CLI$A_RQADDR]);
    end;
end

eludom
