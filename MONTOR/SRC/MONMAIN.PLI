MONMAIN: Procedure	Returns(Fixed Binary(31))
			Options(Ident('V03-004'), Main);

/*
/****************************************************************************
/*									    *
/*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
/*  ALL RIGHTS RESERVED.						    *
/* 									    *
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
/*  TRANSFERRED.							    *
/* 									    *
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
/*  CORPORATION.							    *
/* 									    *
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
/* 									    *
/*									    *
/****************************************************************************
/*/

/*
/*++
/* FACILITY:  VAX/VMS MONITOR Utility 
/*
/* ABSTRACT:  MAIN Routine, including command interface.
/*
/*
/* ENVIRONMENT:
/*
/*		Unprivileged user mode,
/*		except for certain collection routines which
/*		run in EXEC or KERNEL mode to access system
/*		data bases.
/*
/* AUTHOR:  Thomas L. Cafarella, April, 1981
/*

/*
/* MODIFIED BY:
/*
/*	V03-004	TLC1012		Thomas L. Cafarella	30-Mar-1982	13:00
/*		Display user's comment string on screen line 5.
/*
/*	V03-004	TLC1011		Thomas L. Cafarella	29-Mar-1982	20:00
/*		Move system service names for SSERROR msg to static storage.
/*
/*	V03-003	TLC1009		Thomas L. Cafarella	29-Mar-1982	01:00
/*		Get current time when other times are converted.
/*
/*	V03-003	TLC1007		Thomas L. Cafarella	28-Mar-1982	19:00
/*		Add checks for maximum sizes of qualifier values.
/*
/*	V03-002	TLC1003		Thomas L. Cafarella	23-Mar-1982	13:00
/*		Fix up module headers.
/*
/*	V03-001	TLC1001		Thomas L. Cafarella	16-Mar-1982	13:00
/*		Add CTRL-W screen refresh support.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;				/* Monitor utility structure definitions */
%INCLUDE	$CHFDEF;			/* Condition handler facility definitions */
%INCLUDE	$STSDEF;			/* Status code definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		   SYSTEM SERVICE MACRO DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$GETTIM;			/* $GETTIM system service */
%INCLUDE	SYS$PUTMSG;			/* $PUTMSG system service */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CLI$PRESENT	ENTRY(ANY) RETURNS(BIT(1)),
CLI$GET_VALUE	ENTRY(ANY, ANY)
		RETURNS(BIT(1)),
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),
							/* Routine to log synchronous errors */
SET_CLASS_DEF	ENTRY,					/* Routine to set default values for all classes */
EXECUTE_REQUEST	ENTRY RETURNS(FIXED BINARY(31)),	/* Procedure to execute a single request */
DISPLAY_CLEANUP	ENTRY RETURNS(FIXED BINARY(31)),	/* Procedure clean up DISPLAY processing */
SS$_NORMAL	FIXED BINARY(31) GLOBALREF VALUE,	/* System normal return status */
VTWIDTH		FIXED BINARY(31) GLOBALREF VALUE,	/* Video terminal width */
VTHEIGHT	FIXED BINARY(31) GLOBALREF VALUE,	/* Video terminal height */
VTDATALINES	FIXED BINARY(31) GLOBALREF VALUE,	/* Video terminal actual data lines */
NORMAL		FIXED BINARY(31) GLOBALDEF,		/* MONITOR normal return status */
MAX_CLASS_NO	FIXED BINARY(31) GLOBALREF VALUE,	/* Maximum defined class number */
PUTMSGVEC	FIXED BINARY(31) GLOBALREF,		/* $PUTMSG message argument vector */
MODES_CLSNO	FIXED BINARY(31) GLOBALREF VALUE;	/* MODES class number */

Declare
1 CLASSTABLE  GLOBALREF,				/* Table of class names & numbers */
  2 VECTOR_CT	FIXED BINARY(31),			/* Count of longwords following in table */
  2 CL_DESCR (0:127),
    3 CL_PTR	POINTER,				/* Pointer to class cstring */
    3 CL_NO	FIXED BINARY(31);			/* Class number */

Declare
1 CDBHEAD GLOBALREF,					/* Table of CDB's */
  2 CDBLOCK (0:127) CHAR(CDB$K_SIZE);

Declare
MNR$_SQUALERR	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_PDQUALERR	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_QUALINV	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVBTIMSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVETIMSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVINTSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVVIEWSP	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_INVCLSNM	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_ERRINPFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_ERRRECFIL	FIXED BINARY(31) GLOBALREF VALUE,	/* Error message code */
MNR$_UNEXPERR	FIXED BINARY(31) GLOBALREF VALUE;	/* Error message code */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		      GLOBAL STORAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
DISP_DEF_PTR		POINTER GLOBALDEF,			/* Pointer to DISPLAY default file-spec descr */
DISPLAYING		BIT(1) ALIGNED GLOBALDEF INIT('0'B);	/* YES => terminal display output is active */

Declare
  1 READEF_STR GLOBALDEF,					/* Counted string for $READEF */	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$READEF'),		/* String */

  1 CLREF_STR GLOBALDEF,					/* Counted string for $CLREF */	
	   2 L		FIXED BINARY(7) INIT(6),		/* Length */
	   2 S		CHAR(7) INIT('$CLREF'),			/* String */

  1 SCHDWK_STR GLOBALDEF,					/* Counted string for $SCHDWK */	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$SCHDWK'),		/* String */

  1 SETIMR_STR GLOBALDEF,					/* Counted string for $SETIMR */	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$SETIMR'),		/* String */

  1 DCLAST_STR GLOBALDEF,					/* Counted string for $DCLAST*/	
	   2 L		FIXED BINARY(7) INIT(7),		/* Length */
	   2 S		CHAR(7) INIT('$DCLAST');		/* String */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  yes		bit(1)	init('1'B) globaldef value,
  no		bit(1)	init('0'B) globaldef value,
  on		bit(1)	init('1'B) globaldef value,
  off		bit(1)	init('0'B) globaldef value,
  display	bit(1)	init('1'B) globaldef value,
  record	bit(1)	init('0'B) globaldef value,
  command	bit(1)	init('1'B) globaldef value,
  utility	bit(1)	init('0'B) globaldef value,
  buff_a	bit(1)	init('0'B) globaldef value,		/* Value for CDB$V_SWAPBUF */
  buff_b	bit(1)	init('1'B) globaldef value,		/* Value for CDB$V_SWAPBUF */

  All_stat	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Cur_stat	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Ave_stat	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Min_stat	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Max_stat	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */

  Topc_proc	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Topd_proc	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Topb_proc	FIXED BINARY(31) GLOBALREF VALUE,		/* Value for CDB$B_ST */
  Topf_proc	FIXED BINARY(31) GLOBALREF VALUE;		/* Value for CDB$B_ST */

%REPLACE 	NOT_SUCCESSFUL		BY '0'B;	/* Failing severity code */
%REPLACE	CLASS_TOK_SIZE 		BY 20;		/* Size of token for class-name */
%REPLACE	FILE_TOK_SIZE 		BY 128;		/* Size of token for file spec */
%REPLACE	SECONDS_TOK_SIZE	BY 7;		/* Size of token for seconds */
%REPLACE	TIME_TOK_SIZE		BY 40;		/* Size of token for time specs */
%REPLACE	OR_OP			BY '0111'B;	/* OR Boolean operation */
%REPLACE	STATS			BY 5;		/* No of statistic qualifiers */
%REPLACE	PROCDISPS		BY 4;		/* No of PROCESSES display qualifiers */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
call			fixed binary(31),		/* Holds function value (return status) of called routines */ 
status			bit(1)	based(addr(call));	/* Low-order status bit for called routines */

Declare
temp			fixed binary(31);		/* scratch "register" */

Declare
cdbptr			pointer globaldef,		/* Pointer to CDB (Class Descriptor Block) */
c			pointer defined(cdbptr),	/* Short-hand synonym for cdbptr */
mrbptr			pointer globaldef,		/* Pointer to MRB (Monitor Request Block) */
m			pointer defined(mrbptr),	/* Short-hand synonym for mrbptr */
mcaptr			pointer globaldef,		/* Pointer to MCA (Monitor Communication Area) */
mc			pointer defined(mcaptr),	/* Short-hand synonym for mcaptr */
sptr			pointer globaldef;		/* Pointer to SYI (System Information Area) */

Declare
1 STAT_TABLE,						/* Table of statistic qualifier descr ptrs & values */
  2 STAT_DESC	(STATS) POINTER,			/* Pointer to statistic str descr */
  2 STAT_VAL	(STATS) FIXED BINARY(7)			/* Statistic code value */
		INIT(ALL_STAT,CUR_STAT,AVE_STAT,MIN_STAT,MAX_STAT);

Declare
1 PROCD_TABLE,						/* Table of PROCESSES display qualifier descr ptrs & values */
  2 PROCD_DESC	(PROCDISPS) POINTER,			/* Pointer to qualifier str descr */
  2 PROCD_VAL	(PROCDISPS) FIXED BINARY(7)		/* PROCESSES display type value */
		INIT(TOPC_PROC,TOPD_PROC,TOPB_PROC,TOPF_PROC);



/* String descriptors for qualifier values */

DECLARE

01 BEG_VAL,							/* Beginning time string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(TIME_TOK_SIZE+1),				/* String */

01 END_VAL,							/* Ending string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(TIME_TOK_SIZE+1),				/* String */

01 INT_VAL,							/* Interval string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(SECONDS_TOK_SIZE+1),			/* String */

01 VIEW_VAL,							/* Viewing_time string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(SECONDS_TOK_SIZE+1),			/* String */

01 INP_VAL,							/* Input file string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(FILE_TOK_SIZE),				/* String */

01 DISP_VAL,							/* Display file string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(FILE_TOK_SIZE),				/* String */

01 REC_VAL,							/* Record file string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(FILE_TOK_SIZE),				/* String */

01 SUMM_VAL,							/* Summary file string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(FILE_TOK_SIZE),				/* String */

01 COMM_VAL		GLOBALREF,				/* Comment string descriptor */
    02 L		FIXED BINARY(15),
    02 T		FIXED BINARY(7),
    02 C		FIXED BINARY(7),
    02 A		POINTER;


/* String descriptors for command qualifiers */

DECLARE

01 BEG_QUAL,							/* BEGINNING qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(9) INIT('BEGINNING'),			/* String */

01 END_QUAL,							/* ENDING qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(6) INIT('ENDING'),				/* String */

01 INT_QUAL,							/* INTERVAL qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(8) INIT('INTERVAL'),			/* String */

01 VIEW_QUAL,							/* VIEWING_TIME qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(12) INIT('VIEWING_TIME'),			/* String */

01 INP_QUAL,							/* INPUT qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(5) INIT('INPUT'),				/* String */

01 DISP_QUAL,							/* DISPLAY qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('DISPLAY'),			/* String */

01 REC_QUAL,							/* RECORD qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(6) INIT('RECORD'),				/* String */

01 SUMM_QUAL,							/* SUMMARY qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('SUMMARY'),			/* String */

01 COMM_QUAL,							/* COMMENT qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('COMMENT');			/* String */

/*

String descriptor for CLASS_NAME parameter

*/
DECLARE

01 CLASS_PARM,							/* CLASS_NAME parameter string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(10) INIT('CLASS_NAME');			/* String */

/*
/* String descriptors for Class-name qualifiers
/*/

Declare

01 ALL_QUAL,							/* ALL qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(3) INIT('ALL'),				/* String */

01 CUR_QUAL,							/* CUR qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('CURRENT'),			/* String */

01 AVE_QUAL,							/* AVE qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('AVERAGE'),			/* String */

01 MIN_QUAL,							/* MIN qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('MINIMUM'),			/* String */

01 MAX_QUAL,							/* MAX qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('MAXIMUM'),			/* String */

01 TOPC_QUAL,							/* TOPCPU qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(6) INIT('TOPCPU'),				/* String */

01 TOPD_QUAL,							/* TOPDIO qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(6) INIT('TOPDIO'),				/* String */

01 TOPB_QUAL,							/* TOPBIO qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(6) INIT('TOPBIO'),				/* String */

01 TOPF_QUAL,							/* TOPFAULT qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(8) INIT('TOPFAULT'),			/* String */

01 CPU_QUAL,							/* CPU qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(3) INIT('CPU'),				/* String */

01 PCENT_QUAL,							/* PERCENT qualifier string descriptor */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(7) INIT('PERCENT');			/* String */


/* Default file-spec values for qualifiers */

Declare

01 REC_DEF,							/* RECORD qualifier default value */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(11) INIT('MONITOR.DAT'),			/* String */

01 DISP_DEF,							/* DISPLAY qualifier default value */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(11) INIT('SYS$OUTPUT:'),			/* String */

01 SUMM_DEF,							/* SUMMARY qualifier default value */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(11) INIT('MONITOR.SUM');			/* String */


DECLARE

01 MRB_DEF, 						/* Default Monitor Request Block */

    02 beg	bit(64) aligned		init('0'B),	/* Beginning time of request in system time units */
    02 end	bit(64) aligned		init('0'B),	/* Ending time of request in system time units */
    02 int	fixed binary(31)	init(0),	/* Interval value in seconds */
    02 vie	fixed binary(31)	init(0),	/* Viewing time for a screen in seconds */
    02 inp	pointer			init(null()),	/* Address of input file descr (0 if input not requested) */
    02 dis	pointer			init(null()),	/* Address of display file descr (0 if display not requested) */
    02 rec	pointer			init(null()),	/* Address of record file descr (0 if record not requested) */
    02 sum	pointer			init(null()),	/* Address of summary file descr (0 if summary not requested) */
    02 com	pointer			init(addr(comm_val)), /* Address of comment string descriptor */
    02 clc	fixed binary(15),			/* Count of classes requested (needs no init) */
    02 clb	bit(128) aligned	init('0'B),	/* Bit string of requested classes */
    02 fla,						/* Flags for MRB */
	03 dis	bit(1)			init(NO),	/* Display can be YES or NO */
	03 rec	bit(1)			init(NO),	/* Record can be YES or NO */
	03 sum	bit(1)			init(NO),	/* Summary can be YES or NO */
	03 pbk	bit(1)			init(NO),	/* Playback can be YES or NO */
	03 ide	bit(1)			init(NO),	/* Indefinite end can be YES or NO */
	03 dtf	bit(1)			init(NO),	/* Display_to_file can be YES or NO */
	03 fil	bit(10)			init('0'B);	/* Fill out rest of word */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	MONMAIN
/*
/*	This routine is the main Monitor routine, entered from DCL.
/*	It calls the CLE (Command Language Editor) to parse the
/*	MONITOR command line, and creates a Monitor Request Block (MRB)
/*	describing the request. The EXECUTE_REQUEST routine is then
/*	called to execute the request.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	The MONITOR command line.
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status.
/*
/*--
/*/

ON FINISH;						/* On finish, do nothing */
ON ANYCONDITION						/* On any condition signaled, */
    BEGIN;
    DECLARE SIG_CODE	FIXED BIN(31),			/* Signal message code */
	    MON_CODE	FIXED BIN(31),			/* Monitor message code */
	    ON_FILE	CHAR(100) VARYING,		/* Holds possible file name string */
	    SIGNALED_ERR ENTRY (ANY VALUE, ANY VALUE, ANY VALUE, ANY); /* Rtn to set up PUTMSGVEC */

    CHF$ARGPTR = ONARGSLIST();				/* Get signal array pointer */
    SIG_CODE = CHF$SIG_NAME;				/* Get code for signaled condition */
    ON_FILE = ONFILE();					/* Get PL/I file constant if I/O cond */
    IF ON_FILE = 'INPUT_FILE'				/* If input file error, */
        THEN MON_CODE = MNR$_ERRINPFIL;			/* Set Monitor status code accordingly */
	ELSE IF ON_FILE = 'RECORD_FILE'			/* See if it's the recording file */
	         THEN MON_CODE = MNR$_ERRRECFIL;	/* Yes, save code */
		 ELSE MON_CODE = MNR$_UNEXPERR;		/* No, it's an unexpected error */
    CALL SIGNALED_ERR(MON_CODE,SIG_CODE,DIM(CHF$SIG_ARG,1),CHF$SIG_ARG); /* Log the error */
    CALL = MON_CODE;					/* Set up code for exit processing */
    GO TO MON_EXIT;					/* ... and go exit */
    END;

CALL =  MONITOR_INIT();					/* Do image-wide initialization */
IF STATUS						/* Continue if status OK */
    THEN IF MC->MCA$V_ENTRY = COMMAND			/* If entered via DCL command, */
	     THEN  CALL = SET_UP_OPTIONS();		/* ... then options can be set up immediately */
	     ELSE  CALL = READ_LOOP_TO_SET_UP_OPTIONS(); /* Otherwise, need to prompt user */

MON_EXIT:						/* Common exit point */

IF STATUS = NOT_SUCCESSFUL				/* If bad status, */
    THEN DO;
	 IF DISPLAYING = YES				/* If display output is active, */
	     THEN CALL = DISPLAY_CLEANUP();		/*   then perform cleanup */
	 STS$VALUE = SYS$PUTMSG(PUTMSGVEC,,);		/* Print error msg */
	 END;
STS$VALUE = CALL;					/* Get MONITOR completion status */
STS$INHIB_MSG = ON;					/* Inhibit DCL print */
RETURN(STS$VALUE);					/* Return to DCL */

MONITOR_INIT: Procedure Returns(fixed binary(31));

/*
/* 	This routine performs general set-up, including
/* 	determination of command or interactive entry.
/*/

Declare
  CALC_LEN	ENTRY;				/* Routine to calculate class block (record) length */

/*
/* 	Initialize string descriptors for
/* 	command qualifiers and parameters.
/*/

BEG_VAL.L = LENGTH(BEG_VAL.S);			/* Init length longword of descr */
BEG_VAL.A = ADDR(BEG_VAL.S);			/* Init address longword of descr */

END_VAL.L = LENGTH(END_VAL.S);			/* Init length longword of descr */
END_VAL.A = ADDR(END_VAL.S);			/* Init address longword of descr */

INT_VAL.L = LENGTH(INT_VAL.S);			/* Init length longword of descr */
INT_VAL.A = ADDR(INT_VAL.S);			/* Init address longword of descr */

VIEW_VAL.L = LENGTH(VIEW_VAL.S);		/* Init length longword of descr */
VIEW_VAL.A = ADDR(VIEW_VAL.S);			/* Init address longword of descr */

INP_VAL.L = LENGTH(INP_VAL.S);			/* Init length longword of descr */
INP_VAL.A = ADDR(INP_VAL.S);			/* Init address longword of descr */

DISP_VAL.L = LENGTH(DISP_VAL.S);		/* Init length longword of descr */
DISP_VAL.A = ADDR(DISP_VAL.S);			/* Init address longword of descr */

REC_VAL.L = LENGTH(REC_VAL.S);			/* Init length longword of descr */
REC_VAL.A = ADDR(REC_VAL.S);			/* Init address longword of descr */

SUMM_VAL.L = LENGTH(SUMM_VAL.S);		/* Init length longword of descr */
SUMM_VAL.A = ADDR(SUMM_VAL.S);			/* Init address longword of descr */

BEG_QUAL.L = LENGTH(BEG_QUAL.S);		/* Init length longword of descr */
BEG_QUAL.A = ADDR(BEG_QUAL.S);			/* Init address longword of descr */

END_QUAL.L = LENGTH(END_QUAL.S);		/* Init length longword of descr */
END_QUAL.A = ADDR(END_QUAL.S);			/* Init address longword of descr */

INT_QUAL.L = LENGTH(INT_QUAL.S);		/* Init length longword of descr */
INT_QUAL.A = ADDR(INT_QUAL.S);			/* Init address longword of descr */

VIEW_QUAL.L = LENGTH(VIEW_QUAL.S);		/* Init length longword of descr */
VIEW_QUAL.A = ADDR(VIEW_QUAL.S);		/* Init address longword of descr */

INP_QUAL.L = LENGTH(INP_QUAL.S);		/* Init length longword of descr */
INP_QUAL.A = ADDR(INP_QUAL.S);			/* Init address longword of descr */

DISP_QUAL.L = LENGTH(DISP_QUAL.S);		/* Init length longword of descr */
DISP_QUAL.A = ADDR(DISP_QUAL.S);		/* Init address longword of descr */

REC_QUAL.L = LENGTH(REC_QUAL.S);		/* Init length longword of descr */
REC_QUAL.A = ADDR(REC_QUAL.S);			/* Init address longword of descr */

SUMM_QUAL.L = LENGTH(SUMM_QUAL.S);		/* Init length longword of descr */
SUMM_QUAL.A = ADDR(SUMM_QUAL.S);		/* Init address longword of descr */

COMM_QUAL.L = LENGTH(COMM_QUAL.S);		/* Init length longword of descr */
COMM_QUAL.A = ADDR(COMM_QUAL.S);		/* Init address longword of descr */

CLASS_PARM.L = LENGTH(CLASS_PARM.S);		/* Init length longword of descr */
CLASS_PARM.A = ADDR(CLASS_PARM.S);		/* Init address longword of descr */

ALL_QUAL.L = LENGTH(ALL_QUAL.S);		/* Init length longword of descr */
ALL_QUAL.A = ADDR(ALL_QUAL.S);			/* Init address longword of descr */

CUR_QUAL.L = LENGTH(CUR_QUAL.S);		/* Init length longword of descr */
CUR_QUAL.A = ADDR(CUR_QUAL.S);			/* Init address longword of descr */

AVE_QUAL.L = LENGTH(AVE_QUAL.S);		/* Init length longword of descr */
AVE_QUAL.A = ADDR(AVE_QUAL.S);			/* Init address longword of descr */

MIN_QUAL.L = LENGTH(MIN_QUAL.S);		/* Init length longword of descr */
MIN_QUAL.A = ADDR(MIN_QUAL.S);			/* Init address longword of descr */

MAX_QUAL.L = LENGTH(MAX_QUAL.S);		/* Init length longword of descr */
MAX_QUAL.A = ADDR(MAX_QUAL.S);			/* Init address longword of descr */

TOPC_QUAL.L = LENGTH(TOPC_QUAL.S);		/* Init length longword of descr */
TOPC_QUAL.A = ADDR(TOPC_QUAL.S);		/* Init address longword of descr */

TOPD_QUAL.L = LENGTH(TOPD_QUAL.S);		/* Init length longword of descr */
TOPD_QUAL.A = ADDR(TOPD_QUAL.S);		/* Init address longword of descr */

TOPB_QUAL.L = LENGTH(TOPB_QUAL.S);		/* Init length longword of descr */
TOPB_QUAL.A = ADDR(TOPB_QUAL.S);		/* Init address longword of descr */

TOPF_QUAL.L = LENGTH(TOPF_QUAL.S);		/* Init length longword of descr */
TOPF_QUAL.A = ADDR(TOPF_QUAL.S);		/* Init address longword of descr */

CPU_QUAL.L = LENGTH(CPU_QUAL.S);		/* Init length longword of descr */
CPU_QUAL.A = ADDR(CPU_QUAL.S);			/* Init address longword of descr */

PCENT_QUAL.L = LENGTH(PCENT_QUAL.S);		/* Init length longword of descr */
PCENT_QUAL.A = ADDR(PCENT_QUAL.S);		/* Init address longword of descr */

REC_DEF.L = LENGTH(REC_DEF.S);			/* Init length longword of descr */
REC_DEF.A = ADDR(REC_DEF.S);			/* Init address longword of descr */

DISP_DEF.L = LENGTH(DISP_DEF.S);		/* Init length longword of descr */
DISP_DEF.A = ADDR(DISP_DEF.S);			/* Init address longword of descr */

SUMM_DEF.L = LENGTH(SUMM_DEF.S);		/* Init length longword of descr */
SUMM_DEF.A = ADDR(SUMM_DEF.S);			/* Init address longword of descr */

/*
/* 	Initialize STAT_TABLE descriptor pointers.
/*/

STAT_DESC(1) = ADDR(ALL_QUAL);			/* Init pointer to ALL descr */
STAT_DESC(2) = ADDR(CUR_QUAL);			/* Init pointer to CUR descr */
STAT_DESC(3) = ADDR(AVE_QUAL);			/* Init pointer to AVE descr */
STAT_DESC(4) = ADDR(MIN_QUAL);			/* Init pointer to MIN descr */
STAT_DESC(5) = ADDR(MAX_QUAL);			/* Init pointer to MAX descr */

/*
/* 	Initialize PROCD_TABLE descriptor pointers.
/*/

PROCD_DESC(1) = ADDR(TOPC_QUAL);			/* Init pointer to TOPC descr */
PROCD_DESC(2) = ADDR(TOPD_QUAL);			/* Init pointer to TOPD descr */
PROCD_DESC(3) = ADDR(TOPB_QUAL);			/* Init pointer to TOPB descr */
PROCD_DESC(4) = ADDR(TOPF_QUAL);			/* Init pointer to TOPF descr */

ALLOCATE MCA SET(MCAPTR);			/* Obtain Monitor Communication Area */
ALLOCATE SYS_INFO SET(SPTR);			/* Obtain System Information Area */
NORMAL = SS$_NORMAL;				/* use system's normal status */
DISP_DEF_PTR = ADDR(DISP_DEF);			/* Save ptr to DISP_DEF for use in EXECUTE_REQUEST rtn */
MC->MCA$V_ENTRY = COMMAND;			/* **TEMP** -- force command entry */

/*
/*	Call routine to calculate CDB$W_BLKLEN for all STD classes.
/*/

CALL CALC_LEN();				/* Calculate block length for all classes */

RETURN(NORMAL);
END MONITOR_INIT;

SET_UP_OPTIONS: Procedure Returns(fixed binary(31));
/*

Command issued from DCL; call CLE to set up qualifiers and classes

*/

ALLOCATE MRB SET(MRBPTR);						/* Get a Monitor Request Block */
MRBPTR->MRB = MRB_DEF;							/* ... and fill it with default values */
CALL SET_CLASS_DEF();							/* Set default values for each class */

CALL = GET_QUALIFIERS();						/* Get DCL command qualifiers from CLE */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  			/* ... and check status */
CALL = GET_CLASSES();							/* Get requested classes from CLE */
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  			/* ... and check status */
CALL = EXECUTE_REQUEST();						/* Request is valid ... do it */
RETURN(CALL);								/* Return to caller */
END SET_UP_OPTIONS;

read_loop_to_set_up_options: Procedure Returns(fixed binary(31));
/*

Loop which reads terminal and performs action routines for various
utility commands. Keep looping and when a request is issued, execute
the execute_request procedure as commented below. Terminate the loop
when the user issues exit command.

*/

Declare
CURR_MRBPTR	POINTER,						/* Pointer to CURRENT (last known valid) MRB */
CM		POINTER DEFINED(CURR_MRBPTR);				/* Short-hand synonym for CURR_MRBPTR */

ALLOCATE MRB SET(CURR_MRBPTR);						/* Get CURRENT MRB */
CURR_MRBPTR->MRB = MRB_DEF;						/* Initialize it to default values */

/*
/*	Also need to loop through all CDB's loading PCENT_DEF value to PERCENT,
/*	CPU_DEF value to CPU, and STAT_DEF value to STAT. This, along with
/*	MRB_DEF line above could be combined in a routine, executed here, and
/*	when INITIALIZE issued, and at DCL entry; just need to parameterize
/*	MRB pointer to make it work at both interfaces.
/*/

ALLOCATE MRB SET(MRBPTR);						/* Get ACTIVE MRB */

/*
/*	Put read loop in here.
/*/

/*
/*	SET Command
/*/

	MRBPTR->MRB = CURR_MRBPTR->MRB;					/* Copy CURRENT MRB to ACTIVE */
	CALL = GET_QUALIFIERS();					/* Get qualifier values into ACTIVE MRB */
	IF STATUS							/* If no errors ... */
	    THEN DO;
		 CALL = GET_CLASSES();					/* Get classes into ACTIVE MRB */
		 IF STATUS 						/* If no errors ... */
		    THEN CURR_MRBPTR->MRB = MRBPTR->MRB;		/* ... then copy ACTIVE to CURRENT */
		 END;

/*
/*	MONITOR Command
/*/

	MRBPTR->MRB = CURR_MRBPTR->MRB;					/* Copy CURRENT MRB to ACTIVE */
	 CALL = EXECUTE_REQUEST();					/* ... and execute the request */

/*
/*	INITIALIZE Command
/*/

	CURR_MRBPTR->MRB = MRB_DEF;					/* Copy DEFAULT MRB to CURRENT MRB */

/*
/*	SHOW Command
/*	Show values from CURRENT MRB. Use the CM synonym to refer to individual items in MRB.
/*/


RETURN(NORMAL);								/* User has exited */

END READ_LOOP_TO_SET_UP_OPTIONS;

GET_QUALIFIERS: Procedure Returns(fixed binary(31));

/*
/*	Communicate with CLE to get qualifier values.
/*/

Declare
LIB$CVT_TIME	EXTERNAL ENTRY(ANY, BIT(64) ALIGNED)
		RETURNS(BIT(1)),
STR$UPCASE	EXTERNAL ENTRY(ANY,ANY) RETURNS(BIT(1));

CALL = SYS$GETTIM(MC->MCA$Q_CURR_TIME);					/* Get current time from system */

IF CLI$GET_VALUE(BEG_QUAL,BEG_VAL)					/* Get "BEGINNING" string and check status */
    THEN DO;
	 BEG_VAL.L = INDEX(BEG_VAL.S,' ') - 1;				/* Eliminate trailing blanks */
	 IF BEG_VAL.L <= 0						/* Check for valid size for time spec */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVBTIMSP);				/* Log possible error */
		  RETURN(MNR$_INVBTIMSP);				/* ... and return with status */
		  END;
	 IF ^ STR$UPCASE(BEG_VAL,BEG_VAL)				/* Upcase and check status */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVBTIMSP);				/* Log possible error */
		  RETURN(MNR$_INVBTIMSP);				/* ... and return with status */
		  END;
	 IF ^ LIB$CVT_TIME(BEG_VAL,M->MRB$Q_BEGINNING) 			/* Cvt to system time */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVBTIMSP);				/* Log possible error */
		  RETURN(MNR$_INVBTIMSP);				/* ... and return with status */
		  END;
	 END;

IF CLI$GET_VALUE(END_QUAL,END_VAL)					/* Get "ENDING" string and check status */
    THEN DO;
	 END_VAL.L = INDEX(END_VAL.S,' ') - 1;				/* Eliminate trailing blanks */
	 IF END_VAL.L <= 0						/* Check for valid size for time spec */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVETIMSP);				/* Log possible error */
		  RETURN(MNR$_INVETIMSP);				/* ... and return with status */
		  END;
	 IF ^ STR$UPCASE(END_VAL,END_VAL)				/* Upcase and check status */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVETIMSP);				/* Log possible error */
		  RETURN(MNR$_INVETIMSP);				/* ... and return with status */
		  END;
	 IF ^ LIB$CVT_TIME(END_VAL,M->MRB$Q_ENDING) 			/* Cvt to system time */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVETIMSP);				/* Log possible error */
		  RETURN(MNR$_INVETIMSP);				/* ... and return with status */
		  END;
	 END;

IF CLI$GET_VALUE(INT_QUAL,INT_VAL)					/* Get "INTERVAL" string and check status */
    THEN DO;
             INT_VAL.L = INDEX(INT_VAL.S,' ') - 1;			/* Eliminate trailing blanks */
             IF INT_VAL.L <= 0						/* Check for valid size for "seconds" */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVINTSP);				/* Log possible error */
		  RETURN(MNR$_INVINTSP);				/* ... and return with status */
		  END;
	     M->MRB$L_INTERVAL = BIN(SUBSTR(INT_VAL.S,1,INT_VAL.L),31);	/* Convert seconds to binary */
	     IF M->MRB$L_INTERVAL <= 0					/* Check for valid value */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVINTSP);				/* Log possible error */
		  RETURN(MNR$_INVINTSP);				/* ... and return with status */
		  END;
	 END;

IF CLI$GET_VALUE(VIEW_QUAL,VIEW_VAL)					/* Get "VIEWING_TIME" string and check status */
    THEN DO;
             VIEW_VAL.L = INDEX(VIEW_VAL.S,' ') - 1;			/* Eliminate trailing blanks */
             IF VIEW_VAL.L <= 0						/* Check for valid size for "seconds" */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVVIEWSP);				/* Log possible error */
		  RETURN(MNR$_INVVIEWSP);				/* ... and return with status */
		  END;
	     M->MRB$L_VIEWING_TIME = BIN(SUBSTR(VIEW_VAL.S,1,VIEW_VAL.L),31); /* Convert seconds to binary */
	     IF M->MRB$L_VIEWING_TIME <= 0				/* Check for valid value */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVVIEWSP);				/* Log possible error */
		  RETURN(MNR$_INVVIEWSP);				/* ... and return with status */
		  END;
	 END;

IF CLI$PRESENT(INP_QUAL)						/* INPUT qualifier present ? */
    THEN IF CLI$GET_VALUE(INP_QUAL,INP_VAL)				/* Qualifier value specified ? */
             THEN M->MRB$A_INPUT = ADDR(INP_VAL);			/* Yes -- store it away */
             ELSE M->MRB$A_INPUT = ADDR(REC_DEF);			/* No -- store a default value (same as RECORD)*/

IF CLI$PRESENT(DISP_QUAL)						/* DISPLAY qualifier present ? */
    THEN IF CLI$GET_VALUE(DISP_QUAL,DISP_VAL)				/* Qualifier value specified ? */
             THEN DO;
		  DISP_VAL.L = INDEX(DISP_VAL.S,' ') - 1;		/* Yes -- eliminate trailing blanks */
		  IF DISP_VAL.L < 0 THEN DISP_VAL.L = FILE_TOK_SIZE;	/* If too long, replace with max token size */
		  M->MRB$A_DISPLAY = ADDR(DISP_VAL);			/* Store away value descr address */
		  M->MRB$V_DISP_TO_FILE = YES;				/* Indicate filespec specified */
		  END;
             ELSE M->MRB$A_DISPLAY = ADDR(DISP_DEF);			/* No -- store a default value */

IF CLI$PRESENT(REC_QUAL)						/* RECORD qualifier present ? */
    THEN IF CLI$GET_VALUE(REC_QUAL,REC_VAL)				/* Qualifier value specified ? */
             THEN M->MRB$A_RECORD = ADDR(REC_VAL);			/* Yes -- store it away */
             ELSE M->MRB$A_RECORD = ADDR(REC_DEF);			/* No -- store a default value */

IF CLI$PRESENT(SUMM_QUAL)						/* SUMMARY qualifier present ? */
    THEN IF CLI$GET_VALUE(SUMM_QUAL,SUMM_VAL)				/* Qualifier value specified ? */
             THEN M->MRB$A_SUMMARY = ADDR(SUMM_VAL);			/* Yes -- store it away */
             ELSE M->MRB$A_SUMMARY = ADDR(SUMM_DEF);			/* No -- store a default value */

STATUS = CLI$GET_VALUE(COMM_QUAL,COMM_VAL);				/* Get COMMENT qualifier value */

RETURN(NORMAL);								/* Return with status */

END GET_QUALIFIERS;

GET_CLASSES: Procedure Returns(fixed binary(31));

/*
/*	Communicate with CLE to get class_name keywords; then use keywords as
/*	input to LOOKUP_KEY and get back class numbers. Ultimate output is
/*	MRB$O_CLASSBITS, a bit string for which each bit number corresponds
/*	to class number. If a lookup error is found, bad status is returned
/*	to the issuer.
/*/

declare
lib$lookup_key		external entry(any, any, fixed binary(31))
			returns(bit(1));

declare
request_class_mask	bit(max_class_no+1),		/* requested classes have bits on */
request_class_vec	(0:max_class_no) bit(1) defined(request_class_mask),
							/* alias for request_class_mask, but bit-addressable */
temp_mask		bit(128) aligned;		/* temporary holding area for request_class_mask */

DECLARE
01 CLASS_STR,						/* Class name string descr used for CLE comm'n */
    02 L		FIXED BINARY(31),
    02 A		POINTER,
    02 S		CHAR(CLASS_TOK_SIZE+1);				/* String */

CLASS_STR.L = LENGTH(CLASS_STR.S);			/* Init length longword of descr */
CLASS_STR.A = ADDR(CLASS_STR.S);			/* Init address longword of descr */

REQUEST_CLASS_MASK = '0'B;				/* Turn off all class bits initially */
DO WHILE(CLI$GET_VALUE(CLASS_PARM,CLASS_STR));		/* Loop once for each requested class */
    CLASS_STR.L = INDEX(CLASS_STR.S,' ') - 1;		/* Now strip off trailing blanks */
    IF CLASS_STR.L < 0 THEN CLASS_STR.L = CLASS_TOK_SIZE; /* If too long, replace with max token size */

    IF ^ LIB$LOOKUP_KEY(CLASS_STR,CLASSTABLE,TEMP) 	/* Get class number into temp */
	THEN DO;
	     CALL MON_ERR(MNR$_INVCLSNM,,CLASS_STR); 	/* Log error if bad class name */
	     RETURN(MNR$_INVCLSNM);			/* ... and return with status */
	     END;
    CLASS_STR.L = CLASS_TOK_SIZE + 1;			/* Restore string len for next loop */
    REQUEST_CLASS_VEC(TEMP) = ON;			/* Turn on bit for this class */
    CALL = GET_CLASS_QUALS(TEMP);			/* Process class qualifiers for this class */
    IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);  	/* ... and check status */
END;
TEMP_MASK = REQUEST_CLASS_MASK;				/* Get result into temp */
M->MRB$O_CLASSBITS = BOOL(M->MRB$O_CLASSBITS,
			  TEMP_MASK,OR_OP);		/* ... and OR it into MRB */
RETURN(NORMAL);						/* Return to caller */

END GET_CLASSES;

GET_CLASS_QUALS: Procedure (CLSNO) Returns (fixed binary(31));

Declare
I		FIXED BINARY(15),				/* Loop control */
QUAL_FOUND	BIT(1) ALIGNED INIT(NO),			/* NO => haven't seen a qualifier yet */
CLSNO		FIXED BINARY(31),				/* Class number */
QD		CHAR(8) BASED,					/* Dummy qualifier string descr */
CLSTR		CHAR(1) BASED;					/* Dummy first char of class cstring */

CDBPTR = ADDR(CDBLOCK(CLSNO));					/* Get CDB addressability */

/*
/*	Check for the presence of each of the statistics qualifiers
/*	(ALL, CUR, AVE, MIN, MAX). If specified for the non-standard
/*	class (PROCESSES), or if more than one specified, log error
/*	and return.
/*/

DO I = 1 TO STATS;						/* Loop for each stat qual for this class */

IF CLI$PRESENT(STAT_DESC(I)->QD)				/* If this stat qual is present, */
    THEN IF C->CDB$V_STD = NO					/* Check if non-standard class */
	     THEN DO;						/* Non-STD -- stat quals not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,STAT_DESC(I)->QD,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);						     /* ... and return with status */
		  END;
	     ELSE IF QUAL_FOUND = NO				/* STD class -- If we haven't seen a qual yet, */
		      THEN DO;
			   QUAL_FOUND = YES;				/* Indicate we found one this time */
			   C->CDB$B_ST = STAT_VAL(I);			/* ... and move in the requested stat code */
			   END;
		      ELSE DO;					/* We've seen a stat qual for this class already */
			   CALL MON_ERR(MNR$_SQUALERR,,CL_PTR(CLSNO)->CLSTR); /* Log an error */
			   RETURN(MNR$_SQUALERR);			      /* Return with status */
			   END;
END;

/*
/*	Check for the presence of each of the PROCESSES display qualifiers
/*	(TOPCPU, TOPFAULT, TOPDIO, TOPBIO). If specified for a standard
/*	class, or if more than one specified, log error and return.
/*/

QUAL_FOUND = NO;						/* Indicate no PROCESSES qualifiers found yet */

DO I = 1 TO PROCDISPS;						/* Loop for each PROCESSES qualifier */

IF CLI$PRESENT(PROCD_DESC(I)->QD)				/* If this proc qual is present, */
    THEN IF C->CDB$V_STD = YES					/* Check if standard class */
	     THEN DO;						/* STD class -- proc quals not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,PROCD_DESC(I)->QD,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);						     /* ... and return with status */
		  END;
	     ELSE IF QUAL_FOUND = NO				/* Non-STD class -- If we haven't seen a qual yet, */
		      THEN DO;
			   QUAL_FOUND = YES;				/* Indicate we found one this time */
			   C->CDB$B_ST = PROCD_VAL(I);			/* ... and move in the requested display type */
			   END;
		      ELSE DO;					/* We've seen a proc qual for this class already */
			   CALL MON_ERR(MNR$_PDQUALERR,,CL_PTR(CLSNO)->CLSTR); /* Log an error */
			   RETURN(MNR$_PDQUALERR);			      /* Return with status */
			   END;
END;

/*
/*	The following Begin-End group sets the CDB$V_PERCENT and CDB$V_CPU bits to
/*	the proper states, depending on the specifications of the /[NO]PERCENT and
/*	/[NO]CPU qualifiers.
/*/

BEGIN;
Declare
CLI$PRESENT	EXTERNAL ENTRY(ANY) RETURNS(FIXED BINARY(31)),	/* CLE routine */
CLI$_NEGATED	FIXED BINARY(31)    GLOBALREF VALUE;		/* CLI$PRESENT return status code for "explicitly negated" */

/*
/*	Check for presence of /[NO]PERCENT qualifier
/*/

CALL = CLI$PRESENT(PCENT_QUAL);					/* Get "present" indicators for /PERCENT */
IF STATUS							/* If present, */
    THEN IF C->CDB$V_UNIFORM					/* If uniform (/PERCENT allowed for unif only) */
	     THEN C->CDB$V_PERCENT = YES;			/* ... then indicate percent stats */
	     ELSE DO;
		  CALL MON_ERR(MNR$_QUALINV,,PCENT_QUAL,CL_PTR(CLSNO)->CLSTR); /* ... otherwise, log an error */
		  RETURN(MNR$_QUALINV);					       /* ... and return with status */
		  END;
    ELSE IF CALL = CLI$_NEGATED THEN C->CDB$V_PERCENT = NO;	/* IF /PERCENT explicitly negated, turn it off */

/*
/*	Now check for presence of /[NO]CPU qualifier
/*/

CALL = CLI$PRESENT(CPU_QUAL);					/* Get "present" indicators for /CPU */
IF STATUS							/* If present, */
    THEN IF CLSNO = MODES_CLSNO					/* If MODES class, */
	     THEN C->CDB$V_CPU = YES;				/* ... indicate CPU-specific display */
	     ELSE DO;						/* Otherwise, /CPU is not allowed */
		  CALL MON_ERR(MNR$_QUALINV,,CPU_QUAL,CL_PTR(CLSNO)->CLSTR); /* Log an error */
		  RETURN(MNR$_QUALINV);					     /* ... and return with status */
		  END;
    ELSE IF CALL = CLI$_NEGATED THEN C->CDB$V_CPU = NO;		/* IF /CPU explicitly negated, turn it off */

END;								/* Terminate Begin-End group */

RETURN(NORMAL);
END GET_CLASS_QUALS;

END MONMAIN;
