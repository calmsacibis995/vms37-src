EXECUTE_REQUEST: Procedure	Returns(Fixed Binary(31))
				Options(Ident('V03-005'));

/*
/****************************************************************************
/*									    *
/*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
/*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
/*  ALL RIGHTS RESERVED.						    *
/* 									    *
/*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
/*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
/*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
/*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
/*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
/*  TRANSFERRED.							    *
/* 									    *
/*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
/*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
/*  CORPORATION.							    *
/* 									    *
/*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
/*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
/* 									    *
/*									    *
/****************************************************************************
/*/

/*
/*++
/* FACILITY:  MONITOR Utility 
/*
/* ABSTRACT:  EXECUTE_REQUEST Routine.
/*		
/*		 Called from MONMAIN routine to execute a single
/*		   MONITOR request.
/*
/*
/* ENVIRONMENT:
/*
/*		Unprivileged user mode,
/*		except for certain collection routines which
/*		run in EXEC or KERNEL mode to access system
/*		data bases.
/*
/* AUTHOR:  Thomas L. Cafarella, April, 1981
/*

/*
/* MODIFIED BY:
/*
/*	V03-005	TLC1016		Thomas L. Cafarella	02-Apr-1982	16:00
/*		Replace references to EXE$GQ_SYSTIME with $GETTIM calls.
/*
/*	V03-005	TLC1014		Thomas L. Cafarella	01-Apr-1982	13:00
/*		Correct attached processor time reporting for MODES class.
/*
/*	V03-005	TLC1013		Thomas L. Cafarella	31-Mar-1982	09:00
/*		Do not clear TOP box until it fills with data.
/*
/*	V03-005	TLC1012		Thomas L. Cafarella	30-Mar-1982	13:00
/*		Display user's comment string on screen line 5.
/*
/*	V03-005	TLC1011		Thomas L. Cafarella	29-Mar-1982	20:00
/*		Move system service names for SSERROR msg to static storage.
/*
/*	V03-004	TLC1009		Thomas L. Cafarella	29-Mar-1982	01:00
/*		Get current time when other times are converted.
/*
/*	V03-004	TLC1008		Thomas L. Cafarella	28-Mar-1982	21:00
/*		Fix to display first and last PROCESSES records on playback.
/*
/*	V03-004	TLC1006		Thomas L. Cafarella	28-Mar-1982	13:00
/*		Add checks to skip data display on CTRL-C during template.
/*
/*	V03-003	TLC1003		Thomas L. Cafarella	23-Mar-1982	13:00
/*		Fix up module headers.
/*
/*	V03-002	TLC1002		Thomas L. Cafarella	20-Mar-1982	13:00
/*		Change PROCESSES display from scroll-style to page-style to
/*			make it terminal-independent.
/*
/*		Move collection event flag to REQUEST.PLI for consolidation.
/*
/*	V03-001	TLC1001		Thomas L. Cafarella	16-Mar-1982	13:00
/*		Add CTRL-W screen refresh support.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				INCLUDE  FILES				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;				/* Monitor utility structure definitions */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		   SYSTEM SERVICE MACRO DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$DCLAST;			/* $DCLAST system service */
%INCLUDE	SYS$SETAST;			/* $SETAST system service */
%INCLUDE	SYS$CLREF;			/* $CLREF system service */
%INCLUDE	SYS$SETEF;			/* $SETEF system service */
%INCLUDE	SYS$READEF;			/* $READEF system service */
%INCLUDE	SYS$SETIMR;			/* $SETIMR system service */
%INCLUDE	SYS$CANTIM;			/* $CANTIM system service */
%INCLUDE	SYS$ASCTIM;			/* $ASCTIM system service */
%INCLUDE	SYS$WFLOR;			/* $WFLOR system service */
%INCLUDE	SYS$SCHDWK;			/* $SCHDWK system service */
%INCLUDE	SYS$HIBER;			/* $HIBER system service */
%INCLUDE	SYS$PUTMSG;			/* $PUTMSG system service */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MAX_CLASS_NO	FIXED BINARY(31) GLOBALREF VALUE,	/* Maximum defined class number */
CLASSTABLE	FIXED BINARY(31) GLOBALREF VALUE,	/* Addr of table of class names & numbers*/
ON		BIT(1)		 GLOBALREF VALUE,	/* For general use */
OFF		BIT(1)		 GLOBALREF VALUE,	/* For general use */
YES		BIT(1)		 GLOBALREF VALUE,	/* For general use */
NO		BIT(1)		 GLOBALREF VALUE,	/* For general use */
VTWIDTH		FIXED BINARY(31) GLOBALREF VALUE,	/* Width of video terminal */
VTHEIGHT	FIXED BINARY(31) GLOBALREF VALUE,	/* Height of video terminal */
MAX_REC_SIZE	FIXED BINARY(31) GLOBALREF VALUE,	/* Max record size for PLAYBACK & RECORD files */
PROCS_CLSNO	FIXED BINARY(31) GLOBALREF VALUE,	/* PROCESSES class number */
REG_PROC	FIXED BINARY(31) GLOBALREF VALUE;	/* Regular PROCESSES display code */

Declare
CDBPTR			POINTER GLOBALREF,		/* Pointer to CDB (Class Descriptor Block) */
C			POINTER DEFINED(CDBPTR),	/* Synonym for CDBPTR */
MRBPTR			POINTER GLOBALREF,		/* Pointer to MRB (Monitor Request Block) */
M			POINTER DEFINED(MRBPTR),	/* Synonym for MRBPTR */
MCAPTR			POINTER GLOBALREF,		/* Pointer to MCA (Monitor Communication Area) */
MC			POINTER DEFINED(MCAPTR),	/* Synonym for MCAPTR */
SPTR			POINTER GLOBALREF;		/* Pointer to SYI (System Information Area) */

Declare
DISPLAYING		BIT(1) ALIGNED GLOBALREF,	/* YES=> display output is active */
DISP_DEF_PTR		POINTER GLOBALREF;		/* Pointer to DISPLAY default file-spec descr */

Declare
EXE$GL_MP		POINTER GLOBALREF,		/* Pointer to multiprocessing data structures */
SGN$GW_MAXPRCCT		FIXED BINARY(15) GLOBALREF;	/* MAXPROCESSCNT SYSGEN parameter value */

Declare
SETIMR_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $SETIMR cstring */
DCLAST_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $DCLAST cstring */
SCHDWK_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $SCHDWK cstring */
READEF_STR		FIXED BINARY(7)  GLOBALREF,	/* Count byte for $READEF cstring */
CLREF_STR		FIXED BINARY(7)  GLOBALREF;	/* Count byte for $CLREF cstring */



/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     EXTERNAL ROUTINE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
LIB$SIGNAL	ENTRY (ANY VALUE) OPTIONS(VARIABLE),		/* RTL routine to issue error msgs */
MON_ERR		ENTRY (ANY VALUE, ANY, ANY) OPTIONS(VARIABLE),	/* MONITOR MACRO-32 routine to log synchronous errors */
READ_INPUT	ENTRY (FIXED BINARY(7)),			/* MONITOR routine to read an input (playback) file record */
ESTAB_CTRLC	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to set up CTRL-C handler */
ESTAB_CTRLW	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to set up CTRL-W handler */
DISPLAY_INIT	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to do display init */
SUMMARY_INIT	ENTRY RETURNS(FIXED BINARY(31)),		/* MONITOR MACRO-32 routine to do summary init */
COLLECTION_EVENT ENTRY,						/* MONITOR routine to perform collection */
QUAD_LT_QUAD	ENTRY (BIT(64) ALIGNED, BIT(64) ALIGNED) 	/* MONITOR MACRO-32 unsigned quadword compare routine */
		RETURNS(BIT(1)),
QUAD_EQ_0	ENTRY (BIT(64) ALIGNED) RETURNS(BIT(1)), 	/* MONITOR MACRO-32 quadword compare to 0 routine */
CVT_TO_DELTA	ENTRY (FIXED BINARY(31), BIT(64) ALIGNED),	/* MONITOR MACRO-32 rtn to convert to delta time */ 
MPCHECK		ENTRY RETURNS(BIT(1)),				/* MONITOR MACRO-32 rtn to check for MP capability */
COMPUTE_BOOTTIME ENTRY RETURNS(FIXED BINARY(31));		/* MONITOR MACRO-32 rtn to compute system time at boot */

Declare
DISPLAY_PUT	ENTRY(ANY, FIXED BINARY(31), ANY, ANY)		/* MACRO-32 rtn to put a display string */
		OPTIONS(VARIABLE)
		RETURNS(FIXED BINARY(31)),
FILL_DISP_BUFF	ENTRY (POINTER, BIT(64) ALIGNED)		/* MACRO-32 Fill display buffer routine */
		RETURNS (FIXED BINARY(31)),
DISPLAY_PROCS	ENTRY (POINTER, BIT(64) ALIGNED)		/* MACRO-32 rtn to display processes */
		RETURNS (FIXED BINARY(31)),
DISPLAY_TOP	ENTRY (POINTER)					/* MACRO-32 rtn to display top processes */
		RETURNS (FIXED BINARY(31));

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!			     MESSAGE DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
MNR$_SSERROR	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_DISPERR	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_BEGNLEND	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_HIB	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_CLASNP	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOCLASS	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_CLASDISAB	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_BEGRAN	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_PREMEOF	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_INVINPFIL	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_UNSTLEV	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_NOOUTPUT	FIXED BINARY(31) GLOBALREF VALUE,
MNR$_UNEXPERR	FIXED BINARY(31) GLOBALREF VALUE;

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		       GLOBAL STORAGE  DEFINITIONS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
ST_LEVEL_CUR	CHAR(8) INIT('MONSL001') GLOBALDEF,		/* Current MONITOR recording file structure level */
HEADER_TYPE	FIXED BINARY(15) GLOBALDEF INIT(128),		/* Type code for MONITOR recording file header */
DISP_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(16),	/* Display event flag */
DISP_EV_FLAG_M	BIT(32) ALIGNED GLOBALDEF VALUE INIT('00000000000000001'B), /* Display event flag mask */
REFR_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(17),	/* Refresh event flag */
REFR_EV_FLAG_M	BIT(32) ALIGNED GLOBALDEF VALUE INIT('000000000000000001'B), /* Refresh event flag mask */
COLL_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(18),	/* Collection event flag */
PROC_EV_FLAG	FIXED BINARY(31) GLOBALDEF VALUE INIT(19),	/* PROCESSES display event flag */
COLLENDED	BIT(1) ALIGNED	 GLOBALDEF,			/* YES => collection has ended */
CTRLC_HIT	BIT(1) ALIGNED	 GLOBALDEF,			/* YES => CTRL-C has been hit */
SKIP_TO_CLASS	FIXED BINARY(7) GLOBALDEF VALUE INIT(1),	/* Skip to class record indicator for READ_INPUT rtn */
CCDPTR		POINTER		 GLOBALDEF;			/* Pointer to CCD (Current Class Descriptor) Array */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	  COMPILE-TIME CONSTANTS			      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%REPLACE	SYI_TYPE_CODE		BY 129;			/* Type code for MONITOR recording file sys info record */
%REPLACE	NOT_SUCCESSFUL		BY '0'B;		/* Failing status bit */
%REPLACE 	INTERVAL_DEFAULT 	BY 3;			/* Default collection interval value */
%REPLACE 	VIEWING_DEFAULT 	BY 3;			/* Default viewing time value */
%REPLACE	ENABLE_AST		BY 1;			/* Enable AST indicator */
%REPLACE	DISABLE_AST		BY 0;			/* Disable AST indicator */
%REPLACE	AND_OP			BY '0001'B;		/* AND Boolean operation */
%REPLACE	XOR_OP			BY '0110'B;		/* XOR Boolean operation */
%REPLACE	NEXT_REC		BY 0;			/* Read next record indicator for READ_INPUT rtn */
%REPLACE	FLUSH_PERIOD		BY 300;			/* Number of seconds between recording file FLUSH's */

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	!		     	       OWN STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
CALL		FIXED BINARY(31),				/* Holds function value (return status) of called routines */ 
STATUS		BIT(1)	BASED(ADDR(CALL));			/* Low-order status bit for called routines */

Declare
NORMAL		FIXED BINARY(31) GLOBALREF, 			/* MONITOR normal return status */
TEMP		FIXED BINARY(31),				/* Scratch "register" */
COLLSTAT	FIXED BINARY(31) GLOBALDEF,			/* COLLECTION_EVENT status code */
TEMP_PTR	POINTER;					/* Scratch pointer */

Declare
INTERVAL_DEL	BIT(64) ALIGNED GLOBALDEF,			/* Delta time value for Interval */
VIEWING_DEL	BIT(64) ALIGNED;				/* Delta time value for Viewing time */

Declare
CURR_DCLASS	FIXED BINARY(15),				/* Consec no (not class no) of current display class */
REPT_TOP	BIT(1) ALIGNED,					/* YES => Repeat a TOP display */
MULT_TEMP	FIXED BINARY(31) GLOBALDEF;			/* Temp area for MCA$L_INT_MULT, used in COLLECTION_EVENT */

Declare
INPUT_FILE	FILE RECORD INPUT,				/* Monitor Input (Playback) File */
H		POINTER,					/* Pointer to input file header */
RECORD_FILE	FILE RECORD,	 				/* Monitor Record File */
RECCT		FIXED BINARY(31) GLOBALDEF;			/* Count of records written to record file */

Declare
SYI_TYPE	FIXED BINARY(15) INIT(SYI_TYPE_CODE),		/* Type for MONITOR recording file sys info record */
TEMP_TYPE	BIT(8) ALIGNED;					/* Temporary area for record type byte */

Declare
INPUT_CPTR	POINTER GLOBALDEF,				/* Ptr to input buffer count word */
INPUT_DATA	CHAR(MAX_REC_SIZE) VARYING BASED(INPUT_CPTR),	/* Playback file input buffer */
1 DPUT_FLAGS,							/* DISPLAY_PUT routine flags */
  2 FAOL_REQUESTED BIT(8) ALIGNED,				/* YES => Xlate buffer with FAOL first */
  2 OUTP_REQUESTED BIT(8) ALIGNED, 				/* YES => Really output buffer */
PUT_LEN		FIXED BINARY(31),				/* Length of buffer for DISPLAY_PUT to put */

INP_COMM_STR	CHAR(MNR_HDR$K_COMLEN),				/* User comment string from input file */
INP_COMM_LEN	FIXED BINARY(15);				/* Actual length of comment string */


Declare
FLUSH_IND	BIT(1) ALIGNED		GLOBALDEF,		/* Flush indicator; YES=> perform FLUSH */
FLUSH_COLLS	FIXED BINARY(15)	GLOBALDEF,		/* Number of collection events between FLUSH's */
FLUSH_CTR	FIXED BINARY(15)	GLOBALDEF;		/* Down counter for FLUSH_COLLS */

Declare

01 CURR_CLASS_DESCR (MAX_CLASS_NO+1),				/* Current Class Descriptor */
								/* This array of structures includes a CCD (Current */
								/* Class Descriptor) for each possible class. */
    02 CURR_CDBPTR	POINTER,				/* CDBPTR for current class */
    02 CURR_CLASS_NO	FIXED BINARY(7);			/* Class number for current class */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	EXECUTE_REQUEST
/*
/*	This routine is called by MONMAIN to execute a MONITOR request.
/*	The request is defined by the Monitor Request Block (MRB), which
/*	is created by MONMAIN after parsing a command string.
/*
/* INPUTS:
/*
/*	None
/*
/* IMPLICIT INPUTS:
/*
/*	Monitor Request Block (MRB), pointed to by MRBPTR.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	Monitor request has been performed.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

IF M->MRB$A_INPUT ^= NULL()				/* If this is a PLAYBACK request, */
    THEN  ON ENDFILE(INPUT_FILE) MC->MCA$V_EOF = YES; 	/* then set up EOF condition */
CALL = REQUEST_INIT();					/* Initialization for this request */	
IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);		/* Short-circuit request if failure */
IF M->MRB$V_DISPLAY 					/* If this is a DISPLAY request, */
    THEN DO;
	 CALL = DISPLAY_INIT();				/* ... then perform init for it */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_DISPERR,CALL);	/* Yes -- log the error */
		  RETURN(MNR$_DISPERR);			/* ... and return with status */
		  END;
	 ON FINISH CALL = DISPLAY_CLEANUP();		/* On finish, do display cleanup */
	 END;
IF M->MRB$V_RECORD					/* If this is a RECORD request, */
    THEN CALL = RECORD_INIT();				/* ... then do init for it */
IF ^ M->MRB$V_PLAYBACK & MC->MCA$V_FUTURE		/* If live future request, */
    THEN DO;
	 CALL = SYS$SCHDWK(,,M->MRB$Q_BEGINNING,);	/* ... sched a wakeup at requested begin */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,SCHDWK_STR); /* Yes -- log the error */
		  RETURN(MNR$_SSERROR);			/* ... and return with status */
		  END;
	 BEGIN;
	 DECLARE 1 HIBMSG,				/* Declare hibernate msg vec dynamically */
	 	  2 HCOUNT FIXED BIN(31) INIT(1),
		  2 HMSG   FIXED BIN(31) INIT(MNR$_HIB);
	 CALL = SYS$PUTMSG(HIBMSG,,);			/* Let user know we're sleeping */
	 END;
	 CALL = SYS$HIBER();				/* ... ZZZZZZZZZZ */
	 END;

/*
/*	Execute first collection event. If live, collection events will
/*	continue at AST level.
/*/

IF COLLENDED = NO & 					/* If end of collection not indicated AND, */
   ^ (MC->MCA$B_FIRSTC = PROCS_CLSNO & M->MRB$V_PLAYBACK) /* ... not playback of PROCESSES */
    THEN DO;
	 CALL = SYS$DCLAST(COLLECTION_EVENT,,);		/* ... then execute first collection event */
	 IF STATUS = NOT_SUCCESSFUL			/* $DCLAST failure? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,DCLAST_STR); /* Yes -- log the error */
		  RETURN(MNR$_SSERROR);			/* ... and return with status */
		  END;
	 END;

/*
/*	Establish CTRL-C handler for terminating the MONITOR request.
/*/

IF COLLENDED = NO  THEN CALL = ESTAB_CTRLC();		/* If still collecting, establish CTRL-C handler */
							/* If error, do not terminate; simply ignore CTRL-C's */

/*
/*	Establish CTRL-W handler for refreshing the terminal display.
/*/

IF COLLENDED = NO & M->MRB$V_DISPLAY			/* If still collecting, and display requested */
    THEN CALL = ESTAB_CTRLW();				/* ... establish CTRL-W handler */
							/* If error, do not terminate; simply ignore CTRL-W's */

/*
/*	Main monitoring loop. For playback, alternate collection and display events.
/*	For live, simply issue display events in a loop while collection events loop
/*	at AST level.
/*/

DO WHILE (COLLENDED = NO);				/* Loop while collection has not ended */
IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN DO;
	 CALL = SYS$DCLAST(COLLECTION_EVENT,,);		/* ... then execute a collection event */
	 IF STATUS = NOT_SUCCESSFUL			/* $DCLAST failure? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,DCLAST_STR); /* Yes -- log the error */
		  RETURN(MNR$_SSERROR);			/* ... and return with status */
		  END;
	 IF MC->MCA$V_MULTFND & M->MRB$V_DISPLAY	/* If multiple found and display requested, */
			      & COLLSTAT = NORMAL	/* ... and collection_event finished OK, */
	     THEN DO;
		  CALL = DISPLAY_EVENT();		/* Execute a display event */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Return if bad status */

		  IF COLLENDED = NO & M->MRB$V_DISP_TO_FILE = NO /* If still collecting, and displaying to SYS$OUTPUT, */
		      THEN CALL = SYS$WFLOR(0,DISP_EV_FLAG_M | REFR_EV_FLAG_M);
							/* ... then wait for viewing time or refresh request */

		  END;
	 END;

    ELSE DO;						/* This is a LIVE request */
	 IF M->MRB$V_DISPLAY				/* If display requested */
	     THEN DO;
		  CALL = DISPLAY_EVENT();		/* ... then execute a display request */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Return if bad status */
		  END;

	 IF COLLENDED = NO				/* Wait -- If no display, will wait whole request, */
	     THEN CALL = SYS$WFLOR(0,DISP_EV_FLAG_M | REFR_EV_FLAG_M);

	 END;						/* ... while collection continues at AST level */
END;

/*
/*	Perform cleanup now that collection is complete
/*/

IF M->MRB$V_RECORD					/* If this is a RECORD request */
    THEN CALL = RECORD_CLEANUP();			/* ... then do record cleanup */
IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN CALL = INPUT_CLEANUP();			/* ... then do cleanup for it */
IF M->MRB$V_DISPLAY					/* If this is a DISPLAY request */
    THEN CALL = DISPLAY_CLEANUP();			/* ... then do display cleanup */

/*
/*	Perform SUMMARY processing if requested.
/*/

IF M->MRB$V_SUMMARY & COLLSTAT = NORMAL			/* If this is a SUMMARY request, */
    THEN DO;						/* ... and collection status is normal, */
	 CALL = SYS$SETAST(DISABLE_AST);		/* Disable CTRL-C's until summary done */
	 CALL = SUMMARY_INIT();				/* Perform summary init */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  TEMP = SYS$SETAST(ENABLE_AST);	/* Yes -- re-enable CTRL-C's */
		  CALL MON_ERR(MNR$_DISPERR,CALL);	/* Log the error */
		  RETURN(MNR$_DISPERR);			/* ... and return with status */
		  END;
	 CALL = SUMMARY_EVENT();			/* Perform summarization */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  TEMP = SYS$SETAST(ENABLE_AST);	/* Yes -- re-enable CTRL-C's */
		  RETURN(CALL);				/* ... and return with status */
		  END;
	 CALL = SUMMARY_CLEANUP();			/* Perform cleanup */
	 CALL = SYS$SETAST(ENABLE_AST);			/* Re-enable CTRL-C's */
	 END;

RETURN(COLLSTAT);					/* Return to caller with collection_event status */

REQUEST_INIT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	REQUEST_INIT
/*
/*	Performs initialization for the Monitor request.
/*	Fills in defaults for the MRB (Monitor Request Block).
/*	Also inits the MCA (Monitor Communication Area), opens
/*	the input (playback) file if necessary, and fills in the
/*	SYI (System Information Area).
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/* SIDE EFFECTS:
/*
/*	/INPUT file (INPUT_FILE) is positioned to the first class record.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  F		POINTER;				/* Pointer to class record in input file */

COLLENDED = NO;						/* Indicate collection has not ended */
CTRLC_HIT = NO;						/* Indicate CTRL-C not hit */
INP_COMM_LEN = 0;					/* Length of input comment string */
MC->MCA$L_COLLCNT = 0;					/* Initialize collection count */
MC->MCA$L_DISPCNT = 0;					/* ... and display count */
MC->MCA$Q_LASTCOLL = '0'B;				/* Init latest collection time */
MC->MCA$V_FUTURE = NO;					/* Assume not a future request */
MC->MCA$V_EOF = NO;					/* Assume EOF not yet found on /INPUT file */
MC->MCA$V_ERA_SCRL = NO;				/* Assume no need to erase scrolling region */
MC->MCA$V_VIDEO = NO;					/* Assume display terminal is not video */
MC->MCA$V_GRAPHICS = NO;				/* ... and not VT-55 graphics */
MC->MCA$V_TOP_DISP = NO;				/* Indicate no TOP displays issued yet */
MC->MCA$V_REFRESH = NO;					/* Indicate screen refresh request not received */
MC->MCA$V_FILLER = '0'B;				/* Clear all unused flags */
FLUSH_IND = NO;						/* Indicate recording file flush not required */
CURR_DCLASS = 0;					/* Init current display class */
REPT_TOP = NO;						/* Indicate do not repeat TOP display */
DISPLAYING = NO;					/* Indicate display output not yet begun */
CCDPTR = ADDR(CURR_CLASS_DESCR);			/* Set up ptr for COLLECTION_EVENT to use */
COLLSTAT = NORMAL;					/* Start off COLLECTION_EVENT with normal status */
CALL = SYS$CLREF(REFR_EV_FLAG);				/* Clear refresh event flag */

/*
/*	Set MRB flags for options that were requested
/*/

IF M->MRB$A_INPUT   ^= NULL() THEN M->MRB$V_PLAYBACK = YES; /* If INPUT specified, indicate so */
IF M->MRB$A_DISPLAY ^= NULL() THEN M->MRB$V_DISPLAY = YES;  /* If DISPLAY specified, indicate so */
IF M->MRB$A_RECORD  ^= NULL() THEN M->MRB$V_RECORD = YES;   /* If RECORD specified, indicate so */
IF M->MRB$A_SUMMARY ^= NULL() THEN M->MRB$V_SUMMARY = YES;  /* If SUMMARY specified, indicate so */

IF ^ M->MRB$V_DISPLAY & ^ M->MRB$V_RECORD & ^ M->MRB$V_SUMMARY /* If none of the outputs requested, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOOUTPUT);			/* Log the error */
	 RETURN(MNR$_NOOUTPUT);				/* ... and return with status */
	 END;

/*
/*	Set or clear display event flag
/*/

IF M->MRB$V_DISPLAY					/* If display requested, */
    THEN CALL = SYS$SETEF(DISP_EV_FLAG);		/* ... then set display event flag to force 1st display event */
    ELSE CALL = SYS$CLREF(DISP_EV_FLAG);		/* ... otherwise clear it */

/*
/*	If PLAYBACK, perform input file initialization, so MONITOR file header information can be accessed.
/*/

IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN DO;
         CALL = INPUT_INIT();			 	/* ... perform input file initializaton */
         IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);
         END;

IF M->MRB$V_PLAYBACK					/* If this is a PLAYBACK request, */
    THEN DO;
	 INP_COMM_STR = H->MNR_HDR$T_COMMENT;		/* Save user's comment string from header record */
	 INP_COMM_LEN = H->MNR_HDR$W_COMLEN;		/* ... and its length */
	 END;

/*
/*	The next several groups of code update the MRB with default and
/*	specified values, and, for PLAYBACK, values from the input file.
/*/

/*
/*	Verify requested classes and set up Current Class Descriptor array
/*/

BEGIN;
Declare
  FILE_CLASSES	BIT(128),					/* Classes from input file */
  REQ_CLASSES	BIT(128),					/* Classes requested by user */
  NP_CLASSES	BIT(MAX_CLASS_NO+1),				/* Classes requested but not in input file */
  DO_CLASSES	BIT(128),					/* Classes to actually monitor */
  DO_CLASSES_VEC (0:127) BIT(1) DEFINED(DO_CLASSES),		/* Bit-addressable alias */
  CDBHEAD	FIXED BINARY(31) GLOBALREF VALUE,		/* Address of first CDB */
  I		FIXED BINARY(15),				/* Index for do-loop */
  CLASS_NO	FIXED BINARY(7),				/* Class number */
  TEMP_CDBPTR	POINTER,					/* Ptr to Class Descriptor Block (CDB) */
  CDBPTR_COMP	FIXED BINARY(31) BASED(ADDR(TEMP_CDBPTR));	/* Computable CDBPTR */

IF M->MRB$V_PLAYBACK						/* Playback request */
    THEN DO;
	 FILE_CLASSES = H->MNR_HDR$O_CLASSBITS;			/* Get file classes */
	 REQ_CLASSES = M->MRB$O_CLASSBITS;			/* Get requested classes */
	 DO_CLASSES = BOOL(FILE_CLASSES,REQ_CLASSES,AND_OP); 	/* Compute classes to actually do */
	 NP_CLASSES = BOOL(DO_CLASSES,REQ_CLASSES,XOR_OP); 	/* Compute classes not present */
	 IF M->MRB$V_DISPLAY = NO & NP_CLASSES ^= '0'B		/* If at least one class not present & not displaying, */
	  & DO_CLASSES ^= '0'B					/* ... and have at least one to do */
	     THEN BEGIN;					/* ... then print a warning */
		  DECLARE 1 NPMSG,				/* Declare not present msg vec dynamically */
		 	   2 NPCOUNT FIXED BIN(31) INIT(1),
			   2 NPMSG   FIXED BIN(31) INIT(MNR$_CLASNP);
		  CALL = SYS$PUTMSG(NPMSG,,);			/* Warn user that classes missing */
		  END;
	 END;
    ELSE							/* Live request */
	 DO_CLASSES = M->MRB$O_CLASSBITS;			/* Do requested classes */
IF DO_CLASSES = '0'B						/* If no classes to be done, */
    THEN DO;
	 CALL MON_ERR(MNR$_NOCLASS);				/* Log error */
	 RETURN(MNR$_NOCLASS);					/* ... and return */
	 END;

/*
/*	Given DO_CLASSES, execute do loop using INDEX builtin
/*	to fill in the CCD (Current Class Descriptor) array.
/*	When do loop is finished, MRB$O_CLASSBITS, MRB$W_CLASSCT
/*				  MCA$B_FIRSTC and MCA$B_LASTC
/*				  will all be established.
/*/

M->MRB$O_CLASSBITS = DO_CLASSES;				/* Remember classes to do */
CLASS_NO = 0;							/* Initialize class number */
DO I = 1 TO MAX_CLASS_NO + 1  WHILE(CLASS_NO >= 0);		/* Loop once for each possible class */
  CLASS_NO = INDEX(DO_CLASSES,ON) - 1;				/* Find next requested class number */
  IF CLASS_NO >= 0						/* Only continue if a class was found */
    THEN DO;
         DO_CLASSES_VEC(CLASS_NO) = OFF;			/* Eliminate it from future consideration */
         CURR_CLASS_NO(I) = CLASS_NO;				/* Store class_no in CCD table */
         IF I = 1 THEN MC->MCA$B_FIRSTC = CLASS_NO;		/* Mark first class requested */
         MC->MCA$B_LASTC = CLASS_NO;				/* Mark last class requested */
         M->MRB$W_CLASSCT = I;					/* Keep track of class count */
         CDBPTR_COMP = CDBHEAD + (CDB$K_SIZE * CURR_CLASS_NO(I));
								/* Compute current cdbptr ... */
         CURR_CDBPTR(I) = TEMP_CDBPTR;				/* ... and store it in CCD table */
	 IF TEMP_CDBPTR->CDB$V_DISABLE = YES			/* If this class is disabled, */
	     THEN DO;
		  CALL MON_ERR(MNR$_CLASDISAB);			/* Log the error */
		  RETURN(MNR$_CLASDISAB);			/* ... and return */
		  END;
         END;
END;

END;								/* End of BEGIN-END group */

/*
/*	Establish defaults for INTERVAL and VIEWING_TIME options.
/*
/*	If Playback, divide file value for INTERVAL into requested value, and round
/*	requested value up to the next whole multiple of the file value. Store the
/*	multiple value in MCA$L_INT_MULT. It will be used to trigger recording and
/*	display events.
/*/

IF M->MRB$V_PLAYBACK						/* Playback request */
    THEN DO;
	 IF M->MRB$L_VIEWING_TIME = 0				/* If VIEWING_TIME never specified, */
	     THEN M->MRB$L_VIEWING_TIME = VIEWING_DEFAULT;	/* ... then take default */
	 IF M->MRB$L_INTERVAL = 0				/* If INTERVAL never specified, */
	     THEN DO;
		  M->MRB$L_INTERVAL = H->MNR_HDR$L_INTERVAL;	/* ... then use file value */
		  MC->MCA$L_INT_MULT = 1;			/* ... and multiple of 1 */
		  END;
	     ELSE DO;						/* INTERVAL explicitly specified */
		  MC->MCA$L_INT_MULT = DIVIDE(M->MRB$L_INTERVAL,H->MNR_HDR$L_INTERVAL,31);
								/* Divide spec'd val by file val */
		  IF (M->MRB$L_INTERVAL - (H->MNR_HDR$L_INTERVAL * MC->MCA$L_INT_MULT)) ^= 0
		      THEN DO;
			   MC->MCA$L_INT_MULT = MC->MCA$L_INT_MULT + 1; /* Round up if necessary */
			   M->MRB$L_INTERVAL = MC->MCA$L_INT_MULT * H->MNR_HDR$L_INTERVAL; /* Round interval too */
			   END;
		  END;
	 END;

    ELSE DO;							/* Live request */
	 IF M->MRB$L_INTERVAL = 0				/* If INTERVAL never specified... */
	     THEN M->MRB$L_INTERVAL = INTERVAL_DEFAULT;		/* Take the default value */
	 IF M->MRB$L_VIEWING_TIME = 0				/* If VIEWING_TIME never specified... */
	     THEN M->MRB$L_VIEWING_TIME = M->MRB$L_INTERVAL;	/* Default to interval value */

	 IF M->MRB$L_INTERVAL <= FLUSH_PERIOD			/* Requested interval not larger than flush period? */
	     THEN FLUSH_COLLS = DIVIDE(FLUSH_PERIOD,M->MRB$L_INTERVAL,31); /* Yes -- compute collections until flush */
	     ELSE FLUSH_COLLS = 1;				/* No -- flush on every collection */
	 FLUSH_CTR = FLUSH_COLLS;				/* Set up down counter */

	 END;
 
CALL CVT_TO_DELTA(M->MRB$L_INTERVAL,INTERVAL_DEL);		/* Convert INTERVAL to delta time */
CALL CVT_TO_DELTA(M->MRB$L_VIEWING_TIME,VIEWING_DEL);		/* Convert VIEWING_TIME to delta time */

/*
/*	Establish defaults for BEGINNING and ENDING options
/*/

IF M->MRB$V_PLAYBACK
    THEN MC->MCA$Q_CURR_TIME = H->MNR_HDR$Q_BEGINNING;		/* If Playback, get current time from file */
								/* If Live, MCA$Q_CURR_TIME already contains */
								/* ... current time from system */

/*
/*	If user requested a past time for the BEGINNING option,
/*	or defaulted, then replace his value with MCA$Q_CURR_TIME.
/*	Otherwise, indicate a future request.
/*/

MC->MCA$V_FUTURE = QUAD_LT_QUAD(MC->MCA$Q_CURR_TIME,M->MRB$Q_BEGINNING); /* MCA$V_FUTURE gets YES or NO */
IF MC->MCA$V_FUTURE = NO
    THEN M->MRB$Q_BEGINNING = MC->MCA$Q_CURR_TIME;			/* If NO, give user current time */

/*
/*	For PLAYBACK, verify ENDING option. If file value is
/*	non-zero, replace requested value with file value if
/*	requested value is 0 (never specified), or requested
/*	value is larger (later) than file value.
/*/

IF M->MRB$V_PLAYBACK
    THEN IF ^ QUAD_EQ_0(H->MNR_HDR$Q_ENDING)
	     THEN IF QUAD_EQ_0(M->MRB$Q_ENDING)
		      THEN M->MRB$Q_ENDING = H->MNR_HDR$Q_ENDING;
		      ELSE IF QUAD_LT_QUAD(H->MNR_HDR$Q_ENDING,M->MRB$Q_ENDING)
			       THEN M->MRB$Q_ENDING = H->MNR_HDR$Q_ENDING;

/*
/*	Set indefinite end bit if ENDING option never specified.
/*
/*	Also, perform sanity check of BEGINNING and ENDING times.
/*	If BEGINNING not less than ENDING, exit with error.
/*/

IF QUAD_EQ_0(M->MRB$Q_ENDING)						/* If ENDING never specified, */	
    THEN M->MRB$V_INDEFEND = YES;					/* ... call it indefinite */
    ELSE IF QUAD_LT_QUAD(M->MRB$Q_BEGINNING,M->MRB$Q_ENDING) = NO	/* If BEGINNING not less than ENDING, */
	 THEN DO;
	      CALL MON_ERR(MNR$_BEGNLEND);				/* Log the error */
	      RETURN(MNR$_BEGNLEND);					/* ... and return with status */
	      END;

/*
/*	Get information about the monitored system.
/*/

IF M->MRB$V_PLAYBACK					/* PLAYBACK request */
    THEN DO;
	 CALL READ_INPUT(NEXT_REC);			/* Read system information record */
	 IF MC->MCA$V_EOF				/* If end-of-file, */
	     THEN DO;
		  CALL MON_ERR(MNR$_PREMEOF);		/* Can't find sys info record; log the error */
		  RETURN (MNR$_PREMEOF);		/* ... and return to caller */
		  END;

	 TEMP_PTR = MC->MCA$A_INPUT_PTR;		/* Establish ptr to sys info record */
	 TEMP_TYPE = UNSPEC(SYI_TYPE);			/* Get sys info type into a byte for compare */
	 IF TEMP_PTR->MNR_SYI$B_TYPE ^= TEMP_TYPE	/* If this record is not the sys info rec, */
	     THEN DO;
		  CALL MON_ERR(MNR$_INVINPFIL);		/* Log an error */
		  RETURN(MNR$_INVINPFIL);		/* ... and return to caller */
		  END;

	 SPTR->SYS_INFO = TEMP_PTR->SYS_INFO;		/* Move entire sys info record to System Information Area */

	 END;

    ELSE DO;						/* LIVE request */
							/* Fill the System Information Area from the running system */
	 SPTR->MNR_SYI$B_TYPE = UNSPEC(SYI_TYPE);	/* Get SYI type code */
	 SPTR->MNR_SYI$V_FILLER = '0'B;			/* Clear all unused flags */
	 IF MPCHECK()					/* Multiprocessing capability? */
	     THEN SPTR->MNR_SYI$B_MPCPUS = 2;		/* Yes -- 2 cpu's */
	     ELSE SPTR->MNR_SYI$B_MPCPUS = 1;		/* No -- just 1 cpu */
	 SPTR->MNR_SYI$W_MAXPRCCT = SGN$GW_MAXPRCCT;	/* Get MAXPROCESSCNT SYSGEN parameter */
	 CALL = COMPUTE_BOOTTIME();			/* Get system time at boot into MNR_SYI$Q_BOOTTIME */
	 IF STATUS = NOT_SUCCESSFUL			/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_UNEXPERR,CALL);	/* Yes -- log the error */
		  RETURN(MNR$_DISPERR);			/* ... and return with status */
		  END;

	 END;

/*
/*	If PLAYBACK, read first class record from input file
/*	to "prime the pump."
/*/

IF M->MRB$V_PLAYBACK
    THEN DO;
	 CALL READ_INPUT(SKIP_TO_CLASS);		/* Set up first class record for COLLECTION_EVENT rtn */
	 IF MC->MCA$V_EOF				/* If end-of-file, */
	     THEN DO;
		  CALL MON_ERR(MNR$_PREMEOF);		/* Log the error */
	          RETURN (MNR$_PREMEOF);		/* ... and return to caller */
	          END;

/*
/*	If a future playback request, read input file, skipping
/*	past class records until file is positioned to requested
/*	begin point. Examine file time value only for the first
/*	class record within an interval, to ensure that the request
/*	will begin at an interval boundary. If end-of-file is hit
/*	during this operation, terminate the request with an error. 
/*/

	IF MC->MCA$V_FUTURE
	    THEN DO;
		 F = MC->MCA$A_INPUT_PTR;
		 DO WHILE (^ MC->MCA$V_EOF & QUAD_LT_QUAD(F->MNR_CLS$Q_STAMP,M->MRB$Q_BEGINNING));

		 READ FILE(INPUT_FILE) INTO(INPUT_DATA); /* Read rec following first class record */

		 DO WHILE (^ MC->MCA$V_EOF & F->MNR_CLS$B_TYPE ^= MC->MCA$B_FIRSTC);

		 READ FILE(INPUT_FILE) INTO(INPUT_DATA); /* Read until first class found again */

		 END;
		 END;
		 IF MC->MCA$V_EOF			/* EOF => bad beginning time */
		     THEN DO;
			  CALL MON_ERR(MNR$_BEGRAN);	/* Log the error */
			  RETURN(MNR$_BEGRAN);		/* ... and return with status */
			  END;
		 END;

	 MC->MCA$L_INPUT_LEN = LENGTH(INPUT_DATA);	/* Establish length of input */
	 END;

RETURN(NORMAL);						/* Return to caller */
END REQUEST_INIT;

INPUT_INIT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	INPUT_INIT
/*
/*	Called by REQUEST_INIT to open the input (playback) file
/*	performing various sanity checks on it.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/* SIDE EFFECTS:
/*
/*	/INPUT file (INPUT_FILE) is positioned to the file header record.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare

  TEMP_PTR	POINTER,
  01 TEMP BASED(TEMP_PTR),
    02 L	FIXED BINARY(31),
    02 A	POINTER,
  TEMP_STR	CHAR(TEMP.L) BASED(TEMP.A);

Declare
  TEMP_INPUT_PTR FIXED BINARY(31) BASED(ADDR(MC->MCA$A_INPUT_PTR)); /* Alias for MCA$A_INPUT_PTR for computation */ 

INPUT_CPTR = NULL();					/* Indicate no input buffer yet */
TEMP_PTR = M->MRB$A_INPUT;				/* Set up ptr to input file name string */
OPEN FILE(INPUT_FILE) TITLE(TEMP_STR);			/* Open the input recording file for playback */
ALLOCATE INPUT_DATA;					/* Allocate space for input buffer (for life of request) */
MC->MCA$A_INPUT_PTR = INPUT_CPTR;			/* Get ptr to first byte of input buffer */
TEMP_INPUT_PTR = TEMP_INPUT_PTR + 2;			/* Advance ptr beyond length word */
CALL READ_INPUT(NEXT_REC);				/* Read first (file header) record */
IF MC->MCA$V_EOF					/* If end-of-file, */
    THEN DO;
	 CALL MON_ERR(MNR$_PREMEOF);			/* Can't find file header; log the error */
         RETURN (MNR$_PREMEOF);				/* ... and return to caller */
         END;

H = MC->MCA$A_INPUT_PTR;				/* Establish ptr to file header */
TEMP_TYPE = UNSPEC(HEADER_TYPE);			/* Get header type into a byte for compare */
IF H->MNR_HDR$B_TYPE ^= TEMP_TYPE |			/* If first record is not a file header or ... */
   SUBSTR(H->MNR_HDR$T_LEVEL,1,3) ^= SUBSTR(ST_LEVEL_CUR,1,3) /* ... MONITOR ID is not OK, */
    THEN DO;
	 CALL MON_ERR(MNR$_INVINPFIL);			/* Log an error */
	 RETURN(MNR$_INVINPFIL);			/* ... and return to caller */
	 END;

IF SUBSTR(H->MNR_HDR$T_LEVEL,6,3) ^= SUBSTR(ST_LEVEL_CUR,6,3) /* If structure level is not OK, */
    THEN DO;
	 CALL MON_ERR(MNR$_UNSTLEV);			/* Log an error */
	 RETURN(MNR$_UNSTLEV);				/* ... and return to caller */
	 END;

RETURN(NORMAL);
END INPUT_INIT;

RECORD_INIT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	RECORD_INIT
/*
/*	Called by EXECUTE_REQUEST to open the output (recording) file.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  TEMP_PTR	POINTER,
  01 TEMP BASED(TEMP_PTR),
    02 L	FIXED BINARY(31),
    02 A	POINTER,
  TEMP_STR	CHAR(TEMP.L) BASED(TEMP.A);

RECCT = 0;						/* Init count of records written */
TEMP_PTR = M->MRB$A_RECORD;				/* Set up ptr to output file name string */
OPEN FILE(RECORD_FILE) OUTPUT TITLE(TEMP_STR)		/* Open the output recording file */
     ENVIRONMENT(MAXIMUM_RECORD_SIZE(MAX_REC_SIZE));

RETURN(NORMAL);
END RECORD_INIT;

DISPLAY_EVENT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	DISPLAY_EVENT
/*
/*	Called by EXECUTE_REQUEST to perform a single display event.
/*	One display event consists of creating and writing a screen
/*	image, including template if necessary, for a single class.
/*	The current class to be displayed is indicated within the
/*	DISPLAY_EVENT routine by the CURR_DCLASS variable. CURR_DCLASS
/*	is updated on each entry to DISPLAY_EVENT to indicate the
/*	next class in the list of requested classes. This causes the
/*	displays to cycle. DISPLAY_EVENT is entered once per viewing
/*	interval, or whenever a CTRL-W (screen refresh) is received.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
EV_FLAGS	BIT(32) ALIGNED,				/* Cluster 0 event flags */
SS$_WASCLR	FIXED BINARY(31) GLOBALREF VALUE;		/* "Event flag clear" return status */

Declare
DCDB		POINTER STATIC,					/* CDB for current display class */
COLL_TIME	BIT(64) ALIGNED STATIC,				/* Time stamp from most recent collection */
TEMP		FIXED BINARY(15);				/* Temporary scratch "register" */

Declare
1 TIME_PARMS	STATIC,						/* FAOL parms for date and time lines */
  2 DATE_LEN	FIXED BINARY(31) INIT(11),			/* Length of date string */
  2 DATE_PTR	POINTER,					/* Pointer to date string */
  2 TIME_LEN	FIXED BINARY(31) INIT(8),			/* Length of time string */
  2 TIME_PTR	POINTER,					/* Pointer to time string */

DATE_OUT	CHAR(11) STATIC,				/* Date output string from ASCTIM */	
TIME_OUT	CHAR(8) STATIC,					/* Time output string from ASCTIM */	

1 TIME_STR	GLOBALREF,					/* Date/time FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
DATA_STR	CHAR(1)	BASED(DCDB->CDB$A_FAOCTR),		/* First char of FAO ctr str for display data */
FAOSTK		FIXED BINARY(31) GLOBALREF;			/* First longword of FAOL parm list */

CALL = SYS$READEF(DISP_EV_FLAG,EV_FLAGS);			/* Examine state of display event flag */
IF STATUS = NOT_SUCCESSFUL					/* Failed? */
    THEN DO;
	 CALL MON_ERR(MNR$_SSERROR,CALL,READEF_STR);		/* Yes -- log the error */
	 RETURN(MNR$_SSERROR);					/* ... and return with status */
	 END;

IF CALL = SS$_WASCLR						/* If display event flag was clear, */
    THEN DO;							/* (Assume this is a refresh event) */
	 CALL = SYS$CLREF(REFR_EV_FLAG);			/* Clear refresh event flag */
	 MC->MCA$V_REFRESH = YES;				/* ... and indicate this is a refresh display event */
	 IF STATUS = NOT_SUCCESSFUL				/* SYS$CLREF service call failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,CLREF_STR);	/* Yes -- log the error */
		  RETURN(MNR$_SSERROR);				/* ... and return with status */
		  END;
	 END;

IF CURR_DCLASS = 0 & (DISPLAYING = NO | MC->MCA$V_REFRESH = YES) /* If class data not yet displayed, AND */
								/* ... first time thru or refresh requested */
    THEN DO;
	 CALL = DISP_TEMPLATE(CURR_CDBPTR(1),MC->MCA$V_VIDEO);	/* ... display a template for the first class, */
							   	/* ... forcing output to screen if video terminal */
	 DISPLAYING = YES;					/* Indicate that display output has begun */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);		/* Check call */
	 END;

IF CURR_DCLASS = M->MRB$W_CLASSCT				/* If did final class on previous entry, */
    THEN TEMP = 1;						/* ... then start over at first one */
    ELSE TEMP = CURR_DCLASS + 1;				/* ... otherwise, advance to next class */
IF MC->MCA$L_COLLCNT >= 2 | CURR_CLASS_NO(TEMP) = PROCS_CLSNO	/* If at least 2 collections have passed OR ... */
								/* ... this is the PROCESSES class, */
    THEN DO;
	 IF ^ REPT_TOP THEN CURR_DCLASS = TEMP;			/* Advance display class unless TOP repeat */
	 DCDB = CURR_CDBPTR(CURR_DCLASS);			/* Get CDB for current display class */

	 IF MC->MCA$L_DISPCNT ^= 0 & (MC->MCA$V_REFRESH = YES | M->MRB$W_CLASSCT ^= 1) & ^ REPT_TOP
								/* If template not printed above, AND ... */
								/* ... refresh requested OR more than 1 class, */
								/* ... AND not the special TOP repeat */
	     THEN DO;
		  CALL = DISP_TEMPLATE(DCDB,NO);		/* Display template */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL); /* Check call */
		  END;

	 REPT_TOP = NO;						/* Eliminate future TOP repeat */
	 IF MC->MCA$L_DISPCNT = 0 & CURR_CLASS_NO(CURR_DCLASS) = PROCS_CLSNO & DCDB->CDB$B_ST ^= REG_PROC
	     THEN REPT_TOP = YES;				/* If 1st TOP display, allow a 2nd consec TOP */

	 IF CTRLC_HIT = NO | M->MRB$V_DISP_TO_FILE THEN		/* If CTRL-C not hit OR displaying to a file, */
	 DO;							/* ... then prepare to display actual data */
	 CALL = SYS$SETAST(DISABLE_AST);			/* Disable collection events while filling display buffer */
	 CALL = FILL_DISP_BUFF(DCDB,COLL_TIME);			/* Fill display buffer for this class */
	 CALL = SYS$SETAST(ENABLE_AST);				/* Re-enable collection events */

/*
/*	Call DISPLAY_PUT to first display the date and time of the most recent collection,
/*	then to display the actual data itself.
/*/

	 CALL = SYS$ASCTIM(,DATE_OUT,COLL_TIME,0);		/* Get ASCII date */
	 CALL = SYS$ASCTIM(,TIME_OUT,COLL_TIME,1);		/* Get ASCII time */	 
	 DATE_PTR = ADDR(DATE_OUT);				/* Address of date string into FAOL list */
	 TIME_PTR = ADDR(TIME_OUT);				/* Address of time string into FAOL list */
	 PUT_LEN = TIME_STR.L;					/* Length of time control string */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,TIME_STR.S,TIME_PARMS);
								/* Send date and time to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

/*
/*	Put actual display data
/*/

	 IF DCDB->CDB$V_STD					/* Is this a standard class? */
	     THEN DO;						/* Standard Class */
		  FAOL_REQUESTED = YES;				/* Run it through FAOL */
		  OUTP_REQUESTED = YES;				/* Output it now */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,DCDB->CDB$L_FAOCTR,DATA_STR,FAOSTK);
								/* Send display data to SCRPKG */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */
		  END;
	     ELSE						/* Non-standard Class (PROCESSES) */
		  IF DCDB->CDB$B_ST = REG_PROC
		      THEN DO;					/* Regular PROCESSES display */
			   CALL = DISPLAY_PROCS(DCDB,COLL_TIME);         /* Send process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
		      ELSE DO;					/* TOP PROCESSES display */
			   CALL = DISPLAY_TOP(DCDB);		/* Send top process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
	 MC->MCA$L_DISPCNT = MC->MCA$L_DISPCNT + 1;		/* Count this display event */
	 END;
	 END;

IF MC->MCA$V_REFRESH THEN CALL = SYS$CANTIM(DISP_EV_FLAG,);	/* If a refresh event, cancel "regular" display timer */

IF COLLENDED = NO & ^ (M->MRB$V_PLAYBACK & M->MRB$V_DISP_TO_FILE)
								/* If collection still going, ... */
								/* ... AND not playing back to a file, */
    THEN DO;
	 CALL = SYS$SETIMR(DISP_EV_FLAG,VIEWING_DEL,,DISP_EV_FLAG); /* Set flag when ready to display again */
	 IF STATUS = NOT_SUCCESSFUL				/* Failed? */
	     THEN DO;
		  CALL MON_ERR(MNR$_SSERROR,CALL,SETIMR_STR);	/* Yes -- log the error */
		  RETURN(MNR$_SSERROR);				/* ... and return with status */
		  END;
	 END;

MC->MCA$V_REFRESH = NO;						/* Indicate not a refresh display event for next time */

RETURN(NORMAL);

END DISPLAY_EVENT;

SUMMARY_EVENT: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	SUMMARY_EVENT
/*
/*	Called by EXECUTE_REQUEST once per request to create a
/*	summary file containing a screen image for each of the
/*	requested classes.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
SUMMARY_TOP	ENTRY (POINTER)					/* MACRO-32 rtn to set up for TOP PROCESSES summary */
		RETURNS (FIXED BINARY(31));
Declare
DCDB		POINTER STATIC,					/* CDB for current display class */
COLL_TIME	BIT(64) ALIGNED STATIC;				/* Time stamp from most recent collection */

Declare
1 SUMM_PARMS	STATIC,						/* FAOL parms for summary beg and end date/times */
  2 BEG_LEN	FIXED BINARY(31) INIT(20),			/* Length of beginning date/time string */
  2 BEG_PTR	POINTER,					/* Pointer to beginning date/time string */
  2 END_LEN	FIXED BINARY(31) INIT(20),			/* Length of ending date/time string */
  2 END_PTR	POINTER,					/* Pointer to ending date/time string */

BEG_OUT	CHAR(23) STATIC,					/* Beg date/time output string from ASCTIM */	
END_OUT	CHAR(23) STATIC,					/* End date/time output string from ASCTIM */	

1 SUMMLINE_STR	GLOBALREF,					/* Summary date/time FAO control string */
  2 L		FIXED BINARY(7),				/* Length */
  2 S		CHAR(1);					/* First character of string */

Declare
DATA_STR	CHAR(1)	BASED(DCDB->CDB$A_FAOCTR),		/* First char of FAO ctr str for display data */
FAOSTK		FIXED BINARY(31) GLOBALREF;			/* First longword of FAOL parm list */

DO CURR_DCLASS = 1 TO M->MRB$W_CLASSCT				/* Loop once for each requested class */
   WHILE (MC->MCA$L_COLLCNT >= 2);				/* ... but only if at least 2 collections */

	 DCDB = CURR_CDBPTR(CURR_DCLASS);			/* Get CDB for current display class */
	 CALL = DISP_TEMPLATE(DCDB,NO);				/* Send template to SCRPKG, but don't output yet */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN (CALL);		/* Check call */
	 IF CURR_CLASS_NO(CURR_DCLASS) = PROCS_CLSNO		/* If PROCESSES Class, */
	  & DCDB->CDB$B_ST ^= REG_PROC				/* ... and TOP screen requested, */
	     THEN CALL = SUMMARY_TOP(DCDB);			/* ... then do TOP setup */
	 CALL = FILL_DISP_BUFF(DCDB,COLL_TIME);			/* Fill display buffer for this class */

/*
/*	Call DISPLAY_PUT to first display the summary time range,
/*	then to display the actual data itself.
/*/

	 CALL = SYS$ASCTIM(,BEG_OUT,M->MRB$Q_BEGINNING,0);	/* Get ASCII beginning time */
	 CALL = SYS$ASCTIM(,END_OUT,COLL_TIME,0);		/* Get ASCII ending time */	 
	 BEG_PTR = ADDR(BEG_OUT);				/* Address of beg string into FAOL list */
	 END_PTR = ADDR(END_OUT);				/* Address of end string into FAOL list */
	 PUT_LEN = SUMMLINE_STR.L;					/* Length of summary control string */
	 FAOL_REQUESTED = YES;					/* Run it through FAOL */
	 OUTP_REQUESTED = NO;					/* ... but don't output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,SUMMLINE_STR.S,SUMM_PARMS);
								/* Send summary line to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

/*
/*	Put actual display data
/*/

	 IF DCDB->CDB$V_STD					/* Is this a standard class? */
	     THEN DO;						/* Standard Class */
		  FAOL_REQUESTED = YES;				/* Run it through FAOL */
		  OUTP_REQUESTED = YES;				/* Output it now */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,DCDB->CDB$L_FAOCTR,DATA_STR,FAOSTK);
								/* Send display data to SCRPKG */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */
		  END;
	     ELSE						/* Non-standard Class (PROCESSES) */
		  IF DCDB->CDB$B_ST = REG_PROC
		      THEN DO;					/* Regular PROCESSES display */
			   CALL = DISPLAY_PROCS(DCDB,COLL_TIME);         /* Send process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;
		      ELSE DO;					/* TOP PROCESSES display */
			   CALL = DISPLAY_TOP(DCDB);		/* Send top process display lines to SCRPKG */
			   IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL); /* Check status */
			   END;

END;								/* End of DO loop */

RETURN(NORMAL);							/* Return */

END SUMMARY_EVENT;

DISP_TEMPLATE: Procedure (DCDB, OUTPUT_IND)
			 Returns(Fixed Binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	DISP_TEMPLATE
/*
/*	Called by DISPLAY_EVENT and SUMMARY_EVENT to form and write
/*	a template for the indicated class. The template consists of
/*	everything on the screen except actual data. This includes
/*	the first 7 lines of the screen, the footing line and the
/*	line item identifiers. If a bar graph has been requested,
/*	the graph box is also included.
/*
/* INPUTS:
/*
/*	DCDB	    -- Pointer to the CDB (Class Descriptor Block) 
/*			of the class to be displayed.
/*
/*	OUTPUT_IND  -- Output indicator bit. If set, DISP_TEMPLATE
/*			sends terminal display commands to the SCRPKG
/*			and requests it to output to the screen. If
/*			OUTPUT_IND is not set, DISP_TEMPLATE sends
/*			terminal display commands to the SCRPKG, but
/*			does not request immediate screen output.
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
TEMPLATE	ENTRY(POINTER VALUE)		/* BLISS rtn to output template */
		RETURNS(FIXED BINARY(31));

Declare
DCDB		POINTER,			/* Pointer to current display class CDB */
OUTPUT_IND	BIT(1),				/* YES => output the template */
ALL_STAT	FIXED BINARY(31) GLOBALREF VALUE, /* Value for CDB$B_ST indicating all statistics */
I		FIXED BINARY(15);		/* Index for DO loop */

Declare
1 ANNCE_STR	GLOBALREF,			/* Announcement FAO control string */
  2 L		FIXED BINARY(7),		/* Length */
  2 S		CHAR(1);			/* First character of string */

Declare
1 STATUS_STR	GLOBALREF,			/* Status FAO control string */
  2 L		FIXED BINARY(7),		/* Length */
  2 S		CHAR(1),			/* First character of string */
STATUS_PARMS	CHAR(12) GLOBALREF;		/* 3 longword FAOL parms for status display */

Declare
1 TITLE_PARMS	STATIC,				/* FAOL parms for title display line */
  2 BLANKS	FIXED BINARY(31),		/* Number of preceding blanks */
  2 TITLE_PTR	POINTER,			/* Pointer to title cstring */
  2 PCENT_WID	FIXED BINARY(31),		/* Width of percent string (0 or 4) */
TITLE_LEN	FIXED BINARY(7) BASED(TITLE_PTR), /* Length of title string */
1 TITLE_STR	GLOBALREF,			/* Title FAO control string */
  2 L		FIXED BINARY(7),		/* Length */
  2 S		CHAR(1);			/* First character of string */

Declare
1 COMM_PARMS	STATIC,				/* FAOL parms for comment display line */
  2 BLANKS	FIXED BINARY(31),		/* Number of preceding blanks */
  2 COMM_LEN	FIXED BINARY(31),		/* Length of comment */
  2 COMM_ADDR	POINTER,			/* Address of comment string */
1 COMM_STR	GLOBALREF,			/* Comment FAO control string */
  2 L		FIXED BINARY(7),		/* Length */
  2 S		CHAR(1);			/* First character of string */

Declare
1 TABHEAD_STR	GLOBALREF,			/* Tabular heading control string */
  2 L		FIXED BINARY(7),		/* Length */
  2 S		CHAR(1),			/* First character of string */
TABHEAD_PARM	POINTER STATIC,			/* FAOL parm indicating % or blank */
PCENT_STR	CHAR(2) GLOBALREF,		/* Percent symbol cstring */
BLANK_STR	CHAR(2) GLOBALREF;		/* Blank character cstring */

Declare
1 PROCHEAD_STR	GLOBALREF,			/* PROCESSES heading control string */
  2 L		FIXED BINARY(7),		/* Length */
  2 S		CHAR(1);			/* First character of string */

MC->MCA$V_ERA_SCRL = NO;			/* Indicate no need to erase scrolling ... */
						/* ... region for PROCESSES */

/*
/*	Send announcement string to SCRPKG via DISPLAY_PUT routine
/*	This string is independent of screen style.
/*/

PUT_LEN = ANNCE_STR.L;				/* Get length of this put */
FAOL_REQUESTED = NO;				/* No need to go thru $FAOL */
OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,ANNCE_STR.S,);
						/* Send announcement string to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	Send status (footing) string to SCRPKG via DISPLAY_PUT
/*	routine. This string is independent of screen style.
/*/

PUT_LEN = STATUS_STR.L;				/* Get length of this put */
FAOL_REQUESTED = YES;				/* Request a run thru $FAOL */
OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,STATUS_STR.S,STATUS_PARMS);
						/* Send status string to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	Send title string to SCRPKG via DISPLAY_PUT routine.
/*	This string is independent of screen style.
/*/

TITLE_PTR = DCDB->CDB$A_TITLE;			/* Establish title pointer */
TITLE_PARMS.BLANKS = DIVIDE((VTWIDTH - TITLE_LEN),2,31) - 1; /* Compute preceding blanks */
IF DCDB->CDB$V_PERCENT = YES			/* Percent display ? */
    THEN PCENT_WID = 4;				/* Yes -- put out % string */
    ELSE PCENT_WID = 0;				/* No -- don't put % string */
PUT_LEN = TITLE_STR.L;				/* Get length of this put */
FAOL_REQUESTED = YES;				/* Request a run thru $FAOL */
OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,TITLE_STR.S,TITLE_PARMS);
						/* Send title line to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	Send user's comment string to SCRPKG via DISPLAY_PUT routine.
/*	This string is independent of screen style.
/*/

IF INP_COMM_LEN ^= 0				/* If an input comment exists, */
    THEN DO;
	 COMM_LEN = INP_COMM_LEN;			/* Move length to parm list */
	 COMM_ADDR = ADDR(INP_COMM_STR);		/* Move address to parm list */
	 COMM_PARMS.BLANKS = DIVIDE((VTWIDTH - COMM_LEN),2,31) - 1; /* Compute preceding blanks */
	 PUT_LEN = COMM_STR.L;				/* Get length of this put */
	 FAOL_REQUESTED = YES;				/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;				/* Not ready to actually output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,COMM_STR.S,COMM_PARMS);
							/* Send comment line to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */
	 END;

/*
/*	For standard classes, call TEMPLATE to put item
/*	names and build FAO string for actual data for
/*	tabular or bar-style screen.
/*/

IF DCDB->CDB$V_STD					/* If standard class, */
    THEN DO;
	 CALL = TEMPLATE(DCDB);				/* Put item names and build FAO string */
	 IF STATUS = NOT_SUCCESSFUL			/* Check status */
	     THEN DO;
		  CALL MON_ERR(MNR$_DISPERR,CALL);	/* Log the error */
		  RETURN(MNR$_DISPERR);			/* ... and return with status */
		  END;
	 END;

/*
/*	Send heading string (and box, if bar graph)
/*	to SCRPKG via DISPLAY_PUT routine.
/*/

/*
/*	Put PROCESSES Heading
/*/

IF ^ DCDB->CDB$V_STD & DCDB->CDB$B_ST = REG_PROC		/* Put out regular PROCESSES heading */
    THEN DO;
	 PUT_LEN = PROCHEAD_STR.L;				/* Length of put */
	 FAOL_REQUESTED = NO;					/* No $FAOL required */
	 OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,PROCHEAD_STR.S,); /* Hand heading over to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
	 END;

/*
/*	Put Tabular Heading
/*/

    ELSE IF DCDB->CDB$V_STD & DCDB->CDB$B_ST = ALL_STAT			/* All statistics requested for STD class? */
	     THEN DO;							/* Tabular display */
		  IF DCDB->CDB$V_PERCENT
		      THEN TABHEAD_PARM = ADDR(PCENT_STR);		/* Include % symbol in heading */
		      ELSE TABHEAD_PARM = ADDR(BLANK_STR);		/* Exlude % symbol from heading */
		  PUT_LEN = TABHEAD_STR.L;				/* Length of put */
		  FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
		  OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,TABHEAD_STR.S,TABHEAD_PARM);
									/* Hand heading over to SCRPKG */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
		  END;

/*
/*	Put Bar Graph Heading
/*/

   ELSE BEGIN;							/* Bar graph display */
	 Declare
	 K_STR		CHAR(2) GLOBALREF,			/* K symbol for heading line */
	 NULL_STR	FIXED BINARY(15) INIT(0),		/* Dummy null symbol for heading line */
	 CURGR_VAL	FIXED BINARY(31),			/* Current graph value (for heading) */
	 MAXGR_VAL	FIXED BINARY(31),			/* Max (right-edge) graph value for heading */
	 GR_INCR	FIXED BINARY(31),			/* Increment value for heading */
	 RANGE		FIXED BINARY(31),			/* Range for heading values */
	 CHAR_ADDR	POINTER;				/* Addr of symbol char for heading */

	 Declare
	 1 BARHEAD_STR	GLOBALREF,				/* Bar graph heading control string */
	   2 L		FIXED BINARY(7),			/* Length */
	   2 S		CHAR(1),				/* First character of string */
	 1 BARHEAD_PARMS,					/* FAOL parms for graph heading line */
	   2 BP1	FIXED BINARY(31),			/* Graph heading value */
	   2 BP2	POINTER,				/* Graph heading symbol string ptr */
	   2 BP3	FIXED BINARY(31),			/* Graph heading value */
	   2 BP4	POINTER,				/* Graph heading symbol string ptr */
	   2 BP5	FIXED BINARY(31),			/* Graph heading value */
	   2 BP6	POINTER,				/* Graph heading symbol string ptr */
	   2 BP7	FIXED BINARY(31),			/* Graph heading value */
	   2 BP8	POINTER,				/* Graph heading symbol string ptr */
	   2 BP9	FIXED BINARY(31),			/* 1=> advance heading one byte to right */
	   2 BP10	FIXED BINARY(31),			/* Graph heading value */
	   2 BP11	POINTER;				/* Graph heading symbol string ptr */

	 Declare
	 1 STATHEAD_STR	GLOBALREF,				/* Bar graph statistic heading control string */
	   2 L		FIXED BINARY(7),			/* Length */
	   2 S		CHAR(1),				/* First character of string */
	 1 STATHEAD_PARMS,					/* FAOL parms for statistic heading */
	   2 L		FIXED BINARY(31) INIT(3),		/* Statistic heading string length */
	   2 A		POINTER,				/* Pointer to heading string */
	 STAT_HEAD (4)	CHAR(3) GLOBALREF;			/* Table of 3-char heading strings */

	 CALL = PUT_BOX();					/* Put larger bar graph box to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */

/*
/*	Put heading line on top of the box.
/*/

	 IF DCDB->CDB$V_PERCENT
	     THEN DO;						/* Heading values are percents */
		  CHAR_ADDR = ADDR(PCENT_STR);			/* Use % symbol for heading */
		  CURGR_VAL = 0;				/* First value is 0 */
		  RANGE = 100;					/* Range is 100 */
		  END;
	     ELSE IF DCDB->CDB$V_KUNITS
		      THEN DO;					/* Values in units of 1000 */
			   CHAR_ADDR = ADDR(K_STR);		/* Use K symbol for heading */
			   CURGR_VAL = DIVIDE(DCDB->CDB$L_MIN,1000,31); /* Compute first value */
			   RANGE = DIVIDE(DCDB->CDB$L_RANGE,1000,31);   /* ... and range */
			   END;
		      ELSE DO;					/* Heading values are as is */
			   CHAR_ADDR = ADDR(NULL_STR);		/* Use no (null) symbol for heading */
			   CURGR_VAL = DCDB->CDB$L_MIN;		/* Compute first value */
			   RANGE = DCDB->CDB$L_RANGE;		/* ... and range */
			   END;
	 GR_INCR = DIVIDE(RANGE,4,31);				/* Compute increment between values */
	 MAXGR_VAL = CURGR_VAL + RANGE;				/* ... and max (right-most) value */
	 BP1 = CURGR_VAL;					/* Fill in FAOL parms to put heading */
	 BP2 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 BP3 = CURGR_VAL;					/* ........ */
	 BP4 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 BP5 = CURGR_VAL;					/* ........ */
	 BP6 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 BP7 = CURGR_VAL;					/* ........ */
	 BP8 = CHAR_ADDR;					/* ........ */
	 CURGR_VAL = CURGR_VAL + GR_INCR;			/* Compute next value */
	 IF DCDB->CDB$V_PERCENT | DCDB->CDB$V_KUNITS		/* If units symbol is printable, */
	     THEN BP9 = 0;					/* ... then do not advance one space */
	     ELSE BP9 = 1;					/* ... else advance a space, so last value */
								/* ... is on right edge of box */
	 BP10 = MAXGR_VAL;					/* Next parm is the last value */
	 BP11 = CHAR_ADDR;					/* ... addr of units symbol */

/*
/*	Setup to call DISPLAY_PUT for the heading line
/*/
	 PUT_LEN = BARHEAD_STR.L;				/* Length of put */
	 FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
	 OUTP_REQUESTED = NO;					/* Not ready to output it yet */
	 CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,BARHEAD_STR.S,BARHEAD_PARMS);
								/* Hand heading over to SCRPKG */
	 IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
/*
/*	Now put the smaller box with the statistic heading for Standard classes
/*/
	 IF DCDB->CDB$V_STD					/* If standard class, */
	     THEN DO;
		  STATHEAD_PARMS.A = ADDR(STAT_HEAD(DCDB->CDB$B_ST));	/* Get addr of correct string */
		  PUT_LEN = STATHEAD_STR.L;				/* Length of put */
		  FAOL_REQUESTED = YES;					/* Request a run thru $FAOL */
		  OUTP_REQUESTED = OUTPUT_IND;				/* Output it if caller requested */
		  CALL = DISPLAY_PUT(DPUT_FLAGS,PUT_LEN,STATHEAD_STR.S,STATHEAD_PARMS);
									/* Hand statistic heading over to SCRPKG */
		  IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);		/* Check status */
		  END;

	 END;							/* End of begin-end group */

RETURN(NORMAL);							/* Return to caller */

PUT_BOX: Procedure Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	PUT_BOX
/*
/*	Called by DISP_TEMPLATE to put the bar graph box to the SCRPKG.
/*	Actual display output is not performed.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
FIRST_DATA_LINE		FIXED BINARY(31) GLOBALREF VALUE,	/* Line number of first data line on screen */
LAST_DATA_LINE		FIXED BINARY(31) GLOBALREF VALUE,	/* Line number of last data line on screen */
VTDATALINES		FIXED BINARY(31) GLOBALREF VALUE,	/* Total data lines on screen */
CURSOR_STR		CHAR(2) GLOBALREF,			/* Cursor control escape sequence */ 
HORIZ_STR		CHAR(42) GLOBALREF,			/* Horizontal portion of bar graph box */ 
CURROW			FIXED BINARY(15),			/* Current row counter */
CURCOL			FIXED BINARY(15);			/* Current column counter */

Declare
1 VERT_LINE (5*VTDATALINES),					/* Escape string to make vertical lines for box */
  2 CURSOR		CHAR(2),				/* Cursor control esc sequence */
  2 ROW			FIXED BINARY(7),			/* Row byte */
  2 COL			FIXED BINARY(7),			/* Column byte */
  2 VERT_CHAR		CHAR(1);				/* Vertical bar character */

Declare
1 HORIZ_LINE (2),						/* Escape string to make horiz'l lines for box */
  2 CURSOR		CHAR(2),				/* Cursor control esc sequence */
  2 ROW			FIXED BINARY(7),			/* Row byte */
  2 COL			FIXED BINARY(7),			/* Column byte */
  2 TOP_BOT		CHAR(42);				/* Horiz line appearing at top & bot of box */

/*
/*	Create and send to the SCRPKG the horizontal (top
/*	and bottom) lines of the bar graph box.
/*/

HORIZ_LINE.CURSOR(1) = CURSOR_STR;		/* Move in cursor control sequence */
HORIZ_LINE.ROW(1) = FIRST_DATA_LINE - 1;	/* Move in row number of top line of box */
HORIZ_LINE.COL(1) = 38;				/* Move in column number */
TOP_BOT(1) = HORIZ_STR;				/* Move in the top line */
HORIZ_LINE.CURSOR(2) = CURSOR_STR;		/* Move in cursor control sequence */
HORIZ_LINE.ROW(2) = LAST_DATA_LINE+1;		/* Move in row number of bot line of box */
HORIZ_LINE.COL(2) = 38;				/* Move in column number */
TOP_BOT(2) = HORIZ_STR;				/* Move in the bottom line */
FAOL_REQUESTED = NO;				/* FAOL not involved */
OUTP_REQUESTED = NO;				/* ... don't output it yet */
CALL = DISPLAY_PUT(DPUT_FLAGS,46*2,HORIZ_LINE,); /* Put horizontal lines to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

/*
/*	Now create and send to the SCRPKG the vertical
/*	lines of the bar graph box.
/*/

I = 0;						/* Initialize loop control */
DO CURROW = FIRST_DATA_LINE TO LAST_DATA_LINE;	/* Loop once for each data line in graph */
DO CURCOL = 38 TO 78 BY 10;			/* Loop once for each vert char in a line */
IF CURCOL = 78 THEN CURCOL = CURCOL + 1;	/* Push right-most bar over 1 */
I = I + 1;					/* Update index into VERT_LINE vector */
VERT_LINE.CURSOR(I) = CURSOR_STR;		/* Move in cursor control sequence */
VERT_LINE.ROW(I) = CURROW;			/* Move in row number */
VERT_LINE.COL(I) = CURCOL;			/* Move in column number */
VERT_CHAR(I) = '|';				/* Move in the vertical bar char */
END;
END;
CALL = DISPLAY_PUT(DPUT_FLAGS,5*5*VTDATALINES,VERT_LINE,); /* Put vertical lines to SCRPKG */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check status */

RETURN(NORMAL);					/* Return to caller */
END PUT_BOX;

END DISP_TEMPLATE;

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CLEANUP Routines. INPUT_CLEANUP, RECORD_CLEANUP,
/*			  SUMMARY_CLEANUP and DISPLAY_CLEANUP
/*
/*	Called by EXECUTE_REQUEST to close files, reset terminal
/*	characteristics, and release associated resources.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

INPUT_CLEANUP: Procedure Returns(fixed binary(31));

CLOSE FILE(INPUT_FILE);					/* Close the input file */
IF INPUT_CPTR ^= NULL()					/* If input buffer had been acquired */
    THEN FREE INPUT_CPTR->INPUT_DATA;			/* ... then free it */
RETURN(NORMAL);						/* Return */
END INPUT_CLEANUP;


RECORD_CLEANUP: Procedure Returns(fixed binary(31));

Declare
  H		POINTER;				/* Pointer to file header record */

Declare
  TEMP_PTR	POINTER,
  01 TEMP BASED(TEMP_PTR),
    02 L	FIXED BINARY(31),
    02 A	POINTER,
  TEMP_STR	CHAR(TEMP.L) BASED(TEMP.A);

CLOSE FILE(RECORD_FILE);				/* Close the record file */
TEMP_PTR = M->MRB$A_RECORD;				/* Set up ptr to output file name string */
OPEN FILE(RECORD_FILE) UPDATE TITLE(TEMP_STR);		/* Re-open it to re-write header */
READ FILE(RECORD_FILE) SET(H);				/* Read header record */
H->MNR_HDR$Q_ENDING = M->MRB$Q_ENDING;			/* Update the ending time */
H->MNR_HDR$L_RECCT = RECCT;				/* ... and the record count */
REWRITE FILE(RECORD_FILE);				/* Re-write the header record */
CLOSE FILE(RECORD_FILE);				/* ... and close it up again */

RETURN(NORMAL);						/* Return */
END RECORD_CLEANUP;

SUMMARY_CLEANUP: Procedure Returns(fixed binary(31));

Declare
LIB$SET_BUFFER	ENTRY (ANY VALUE),			/* Rtn to set and clear buffer mode for the SCRPKG */
SCR$SET_CURSOR	ENTRY (ANY VALUE, ANY VALUE),		/* SCRPKG rtn to set the cursor position */
SCR$UP_SCROLL	ENTRY,					/* SCRPKG rtn to scroll up one line */
SCR$STOP_OUTPUT	ENTRY;					/* Rtn to stop SCRPKG output stream */

Declare
1 BOT_CURS	GLOBALREF,				/* Place cursor on bottom of screen */
  2 L		FIXED BINARY(7),			/* Length */
  2 S		CHAR(1),				/* First character of string */

SFSPEC		CHAR(8) BASED;				/* Dummy summary file spec descriptor */

CALL LIB$SET_BUFFER(0);					/* Indicate "clear buffer mode" to SCRPKG */
							/* ... and output what's left in the buffer */
CALL SCR$SET_CURSOR(24,1);				/* Place cursor on bottom line, */
CALL SCR$UP_SCROLL();					/* ... and scroll up one line */
CALL SCR$STOP_OUTPUT();					/* Stop output stream and close summary file */
RETURN(NORMAL);						/* Return */
END SUMMARY_CLEANUP;

END EXECUTE_REQUEST;

DISPLAY_CLEANUP: Procedure Returns(fixed binary(31));

Declare
YES		BIT(1)		 GLOBALREF VALUE,	/* For general use */
NO		BIT(1)		 GLOBALREF VALUE,	/* For general use */
DISPLAYING	BIT(1) ALIGNED	GLOBALREF,		/* YES=> display output is active */
NORMAL		FIXED BINARY(31) GLOBALREF; 		/* MONITOR normal return status */

Declare
LIB$SET_BUFFER	ENTRY (ANY VALUE),			/* Rtn to set and clear buffer mode for the SCRPKG */
PUT_TO_SCREEN	ENTRY (ANY VALUE, ANY),			/* Rtn to put an arbitrary buffer to the SCRPKG */
SCR$SET_CURSOR	ENTRY (ANY VALUE, ANY VALUE),		/* SCRPKG rtn to set the cursor position */
SCR$UP_SCROLL	ENTRY,					/* SCRPKG rtn to scroll up one line */
SCR$STOP_OUTPUT	ENTRY;					/* Rtn to stop SCRPKG output stream */

Declare
1 FIN_SEQ	GLOBALREF,				/* Finish escape sequence for display terminal */
  2 L		FIXED BINARY(7),			/* Length */
  2 S		CHAR(1),				/* First character of string */

1 BOT_CURS	GLOBALREF,				/* Place cursor on bottom of screen */
  2 L		FIXED BINARY(7),			/* Length */
  2 S		CHAR(1),				/* First character of string */

DFSPEC		CHAR(8) BASED;				/* Dummy display file spec descriptor */

CALL LIB$SET_BUFFER(0);					/* Indicate "clear buffer mode" to SCRPKG */
							/* ... and output what's left in the buffer */
CALL PUT_TO_SCREEN(FIN_SEQ.L,FIN_SEQ.S);		/* Call SCRPKG for finish sequence, */
IF DISPLAYING = YES					/* If actual output has begun, */
    THEN DO;
	 CALL SCR$SET_CURSOR(24,1);			/* ... then place cursor on bottom line, */
	 CALL SCR$UP_SCROLL();				/* ... scroll up one line, */
	 DISPLAYING = NO;				/* ... and indicate display output has stopped */
	 END;
CALL SCR$STOP_OUTPUT();					/* Stop output stream if present */
RETURN(NORMAL);						/* Return */
END DISPLAY_CLEANUP;

COLLECTION_END: Procedure Returns(fixed binary(31));	/* Indicate collection ended */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	COLLECTION_END
/*
/*	Called by CTRLC, COLLECTION_EVENT or CLASS_COLLECT whenever it is
/*	determined that data collection has reached an end. This can occur
/*	when the user strikes CTRL-C, an input (playback) file has reached
/*	end-of-file, or a requested ending time has occurred.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	COLLENDED bit is set.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/* SIDE EFFECTS:
/*
/*	All timers are canceled, a $WAKE is issued, and the display and
/*	PROCESSES event flags are set.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$WAKE;				/* $WAKE system service */
%INCLUDE	SYS$CANTIM;				/* $CANTIM system service */
%INCLUDE	SYS$SETEF;				/* $SETEF system service */
%INCLUDE	MONDEF;					/* Monitor utility structure definitions */

Declare
  YES		BIT(1)		 GLOBALREF VALUE,	/* For general use */
  DISP_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* Display event flag */
  PROC_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* PROCESSES display event flag */
  COLLENDED	BIT(1)		 GLOBALREF,		/* YES => collection has ended */
  MRBPTR	POINTER		 GLOBALREF,		/* Pointer to MRB (Monitor Request Block) */
  MCAPTR	POINTER		 GLOBALREF,		/* Pointer to MCA (Monitor Communication Area) */
  NORMAL	FIXED BINARY(31) GLOBALREF, 		/* MONITOR normal status value */
  CALL		FIXED BINARY(31);			/* Holds function value (return status) of called routines */ 

CALL = SYS$WAKE(,);					/* Wake up if hibernating */
CALL = SYS$CANTIM(,);					/* Cancel outstanding timer requests */
CALL = SYS$SETEF(DISP_EV_FLAG);				/* Force final display */
CALL = SYS$SETEF(PROC_EV_FLAG);				/* Force final PROCESSES display */
COLLENDED = YES;					/* Indicate collection ended */
MRBPTR->MRB$Q_ENDING = MCAPTR->MCA$Q_LASTCOLL;		/* Establish last collection time as ending */
RETURN(NORMAL);						/* Return to caller */

END COLLECTION_END;

CTRLC: Procedure Returns(fixed binary(31));		/* CTRL-C handler */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CTRLC
/*
/*	AST Routine entered whenever the user strikes CTRL-C.
/*	The COLLECTION_END routine is called to begin termination
/*	of the Monitor request. Also, the CTRLC_HIT bit is set.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  COLLECTION_END ENTRY,					/* Routine to indicate end of collection */
  YES		BIT(1)		 GLOBALREF VALUE,	/* Bit value of 1 */
  CTRLC_HIT	BIT(1) ALIGNED   GLOBALREF,		/* YES => CTRL-C has been hit */
  NORMAL	FIXED BINARY(31) GLOBALREF; 		/* MONITOR normal status value */

CTRLC_HIT = YES;					/* Indicate CTRL-C has been hit */
CALL COLLECTION_END();					/* Indicate end of collection */
RETURN(NORMAL);						/* Return to caller */

END CTRLC;

CTRLW: Procedure Returns(fixed binary(31));		/* CTRL-W (display screen refresh) handler */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	CTRLW
/*
/*	AST routine, entered whenever the user strikes CTRL-W.
/*	Sets the Refresh Event Flag to indicate a new display
/*	event (including template) is desired.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	SYS$SETEF;				/* $SETEF system service */

Declare
  REFR_EV_FLAG	FIXED BINARY(31) GLOBALREF VALUE,	/* Refresh event flag */
  NORMAL	FIXED BINARY(31) GLOBALREF, 		/* MONITOR normal status value */
  CALL		FIXED BINARY(31);			/* Holds function value (return status) of called routines */ 

CALL = SYS$SETEF(REFR_EV_FLAG);				/* Cause refresh display event to occur */
RETURN(NORMAL);						/* Return to caller */

END CTRLW;

WRITE_HEADER: Procedure Returns(fixed binary(31));		/* Write recording file header record */
								/* ... and system information record */

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	WRITE_HEADER
/*
/*	Called by the CLASS_COLLECT routine to write the first 2
/*	records of the recording file (File Header Record and
/*	System Information Record). Called once per Monitor
/*	request before any class records are written.
/*
/* INPUTS:
/*
/*	None
/*
/* OUTPUTS:
/*
/*	None
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL, or failing MONITOR status code.
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
  WRITE_RECORD	ENTRY (ANY) RETURNS(FIXED BINARY(31));		/* Routine to write a rec to the recording file */

Declare
  CALL		FIXED BINARY(31),				/* Holds function value (return status) of called routines */ 
  STATUS	BIT(1)	BASED(ADDR(CALL)),			/* Low-order status bit for called routines */
  NORMAL	FIXED BINARY(31) GLOBALREF, 			/* MONITOR normal status value */
  SPTR		POINTER GLOBALREF,				/* Pointer to SYI (System Information Area) */
  MRBPTR	POINTER GLOBALREF,				/* Pointer to MRB (Monitor Request Block) */
  M		POINTER DEFINED(MRBPTR),			/* Synonym for MRBPTR */
  H		POINTER,					/* Pointer to record file header */
  HEADER_TYPE	FIXED BINARY(15) GLOBALREF,			/* Type for MONITOR recording file header */
  ST_LEVEL_CUR	CHAR(8) GLOBALREF,				/* Current MONITOR recording file structure level */
  1 COMM_D BASED(M->MRB$A_COMMENT),				/* Descriptor for user's comment string */
    2 L		FIXED BINARY(15),				/* Length */
    2 TC	CHAR(2),					/* Type and class */
    2 A		POINTER,					/* Address */
  COMMENT	CHAR(COMM_D.L) BASED(COMM_D.A),			/* User-specified comment string */
  1 REC_DESCR,							/* Record descriptor */
    2 L		FIXED BINARY(31),				/* Length */
    2 A		POINTER;					/* Address */

ALLOCATE FILE_HDR SET (H);			/* Allocate file header space */

H->MNR_HDR$B_TYPE = UNSPEC(HEADER_TYPE);	/* Load header type code */
H->MNR_HDR$V_FILLER = '0'B;			/* Clear all unused flags */
H->MNR_HDR$Q_BEGINNING = M->MRB$Q_BEGINNING;	/* Load beginning time */
H->MNR_HDR$Q_ENDING = '0'B;			/* Indicate no ending time yet */
H->MNR_HDR$L_INTERVAL = M->MRB$L_INTERVAL;	/* Load interval value */
H->MNR_HDR$O_CLASSBITS = M->MRB$O_CLASSBITS;	/* Load class bit string */
H->MNR_HDR$L_RECCT = 0;				/* Indicate no records yet */
H->MNR_HDR$T_LEVEL = ST_LEVEL_CUR;		/* Load current recording file structure level */
H->MNR_HDR$T_COMMENT = COMMENT;			/* Load user's comment string */
H->MNR_HDR$W_COMLEN = COMM_D.L;			/* ... and its actual length */
IF H->MNR_HDR$W_COMLEN > MNR_HDR$K_COMLEN	/* Minimize actual length with ... */
    THEN H->MNR_HDR$W_COMLEN = MNR_HDR$K_COMLEN; /* ... max comment length */

/*
/*	Write file header record
/*/

REC_DESCR.L = MNR_HDR$K_SIZE;			/* Load up length */
REC_DESCR.A = H;				/* ... and address of record for write */
CALL = WRITE_RECORD(REC_DESCR);			/* Write the file header record */
FREE H->FILE_HDR;				/* Free file header space */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check WRITE_RECORD call */

/*
/*	Write system information record
/*/

REC_DESCR.L = MNR_SYI$K_SIZE;			/* Load up length */
REC_DESCR.A = SPTR;				/* ... and address of record for write */
CALL = WRITE_RECORD(REC_DESCR);			/* Write the file header record */
IF STATUS = NOT_SUCCESSFUL THEN RETURN(CALL);	/* Check WRITE_RECORD call */

RETURN(NORMAL);					/* Return to caller */
END WRITE_HEADER;

WRITE_RECORD: Procedure (RECORD_DESC)
			Returns(fixed binary(31));

/*
/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	WRITE_RECORD
/*
/*	Called by the WRITE_HEADER and CLASS_COLLECT routines to
/*	write a single record to the recording file. If a flush
/*	has been indicated, it is performed.
/*
/* INPUTS:
/*
/*	Address of a string descriptor describing the record to be written.
/*
/* IMPLICIT INPUTS:
/*
/*	FLUSH_IND -- Flush indicator. If set, perform an RMS flush operation
/*		     to "checkpoint" the recording file.
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	RECCT incremented by 1.
/*
/* ROUTINE VALUE:
/*
/*	SS$_NORMAL
/*
/*--
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

Declare
  NORMAL		FIXED BINARY(31) GLOBALREF,		/* MONITOR normal status value */
  NO			BIT(1)		 GLOBALREF VALUE,	/* Bit value of 0 */
  RECCT			FIXED BINARY(31) GLOBALREF,		/* Count of records written to record file */
  FLUSH_IND		BIT(1) ALIGNED   GLOBALREF;		/* Flush indicator; YES => perform FLUSH */

Declare
  1 RECORD_DESC,						/* Record descriptor */
    2 RECORD_LEN	FIXED BINARY(31),			/* Record length */
    2 RECORD_PTR	POINTER,				/* Record pointer */
  RECORD_DATA		CHAR(RECORD_LEN) BASED(RECORD_PTR); 	/* Record data */

Declare
  RECORD_FILE		FILE RECORD;				/* Monitor Record File */

IF FLUSH_IND							/* If flush indicated for this write, */
    THEN DO;
	 CALL FLUSH(RECORD_FILE);				/* Flush record file to checkpoint collected data */
	 FLUSH_IND = NO;					/* Indicate flush not required */
	 END;

WRITE FILE(RECORD_FILE) FROM(RECORD_DATA);			/* Write a record */
RECCT = RECCT + 1;						/* Count it */

RETURN(NORMAL);							/* Return */
END WRITE_RECORD;

READ_INPUT: Procedure (SKIP_IND);				/* Routine to read a record from the /INPUT file */

/*++
/*
/* FUNCTIONAL DESCRIPTION:
/*
/*	READ_INPUT
/*
/*	This routine reads the /INPUT (playback) file until a
/*	record of the desired type is found, or until end-of-file
/*	is reached. The following categories of record types exist:
/*
/*		Types   0 - 127:	Class record
/*		Types 128 - 191:	DIGITAL control record
/*		Types 192 - 255:	Customer control record
/*
/*	A class record is always desired. A customer control record
/*	is never desired. A DIGITAL control record can be desired
/*	or not, depending on the input parameter SKIP_IND.
/*
/* INPUTS:
/*
/*	SKIP_IND -- a binary byte value indicating whether or not
/*			to skip past DIGITAL control records. If
/*			SKIP_IND is 0, DIGITAL control records
/*			are desired, and will not be skipped.
/*			Otherwise, they are skipped. 
/*
/* IMPLICIT INPUTS:
/*
/*	MCAPTR -- Pointer to Monitor Communication Area
/*	INPUT_CPTR -- Pointer to /INPUT file buffer
/*
/* OUTPUTS:
/*
/*	None
/*
/* IMPLICIT OUTPUTS:
/*
/*	MCA$L_INPUT_LEN is updated to indicate the length of the record
/*	currently in the input buffer.
/*
/*	MCA$V_EOF is set if end-of-file is reached.
/*
/* ROUTINE VALUE:
/*
/*	None
/*
/* SIDE EFFECTS:
/*
/*	/INPUT file (INPUT_FILE) is advanced to the desired record.
/*
/*/

/*
/*	!-----------------------------------------------------------------------------+
/*	!									      !
/*	! 				 LOCAL STORAGE				      !
/*	!									      !
/*	!-----------------------------------------------------------------------------+
/*/

%INCLUDE	MONDEF;						/* Monitor utility structure definitions */

Declare
  ON		BIT(1)		 GLOBALREF VALUE,		/* For general use */
  OFF		BIT(1)		 GLOBALREF VALUE,		/* For general use */
  YES		BIT(1)		 GLOBALREF VALUE,		/* For general use */
  NO		BIT(1)		 GLOBALREF VALUE,		/* For general use */
  MAX_REC_SIZE	FIXED BINARY(31) GLOBALREF VALUE,		/* Max record size for PLAYBACK & RECORD files */
  MCAPTR	POINTER GLOBALREF,				/* Pointer to MCA (Monitor Communication Area) */
  MC		POINTER DEFINED(MCAPTR),			/* Synonym for MCAPTR */
  INPUT_CPTR	POINTER GLOBALREF,				/* Ptr to input buffer count word */
  INPUT_DATA	CHAR(MAX_REC_SIZE) VARYING BASED(INPUT_CPTR);	/* Playback file input buffer */

Declare
  SKIP_IND		FIXED BINARY(7),			/* Skip indicator; non-zero => skip DIGITAL control recs */
  DESIRED_TYPE		BIT(1) ALIGNED,				/* YES => desired record type found */
  1 RECORD_TYPE		BASED(MC->MCA$A_INPUT_PTR), 		/* Record type field of input record */
    2 FILLER		BIT(6),
    2 BIT6		BIT(1),
    2 BIT7		BIT(1);

Declare
  INPUT_FILE		FILE RECORD INPUT;			/* Monitor Input (Playback) File */

DESIRED_TYPE = NO;						/* Don't have desired type yet */
DO WHILE (^ MC->MCA$V_EOF & ^ DESIRED_TYPE);			/* Stop reading when hit EOF or desired rec found */
READ FILE(INPUT_FILE) INTO(INPUT_DATA);				/* Read a record from the input file */
IF BIT7 = OFF							/* If high-order bit of record type off, */
    THEN DESIRED_TYPE = YES;					/*   then we found a desired type (class record) */
    ELSE IF SKIP_IND = 0 & BIT6 = OFF				/* If caller wants a DIGITAL control rec, */
	 THEN DESIRED_TYPE = YES;				/*   and it is present, let him have it */
END;

MC->MCA$L_INPUT_LEN = LENGTH(INPUT_DATA);			/* Establish length of input */

RETURN;								/* Return */
END READ_INPUT;
