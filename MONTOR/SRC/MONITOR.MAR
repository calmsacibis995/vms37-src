	.TITLE	MONITOR	- VAX/VMS Performance Monitor Utility
	.IDENT	'V03-005'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:  VAX/VMS MONITOR Utility
;
; ABSTRACT:
;
;	This module is a collection of routines which are called by
;	the MONMAIN, REQUEST, and COLLEVT PL/I routines to do
;	various tasks, including data collection, terminal I/O
;	(through the use of the Screen Package) and maintenance
;	of statistics for screen displays.
;
; ENVIRONMENT:
;
;	Unprivileged user mode,
;	except for certain collection routines which
;	run in EXEC or KERNEL mode to access system
;	data bases.
;
; AUTHOR: Thomas L. Cafarella, April, 1981
;
; MODIFIED BY:
;
;	V03-005	TLC1018		Thomas L. Cafarella	12-Apr-1982	16:00
;		Collect all data at KERNEL mode instead of EXEC.
;
;	V03-004	TLC1016		Thomas L. Cafarella	02-Apr-1982	16:00
;		Replace references to EXE$GQ_SYSTIME with $GETTIM calls.
;
;	V03-004	TLC1015		Thomas L. Cafarella	01-Apr-1982	16:00
;		Change .PSECT options in order to group image sections.
;
;	V03-004	TLC1014		Thomas L. Cafarella	01-Apr-1982	13:00
;		Correct attached processor time reporting for MODES class.
;
;	V03-004	TLC1012		Thomas L. Cafarella	30-Mar-1982	13:00
;		Display user's comment string on screen line 5.
;
;	V03-003	TLC1008		Thomas L. Cafarella	28-Mar-1981	21:00
;		Fix to display first and last PROCESSES records on playback.
;
;	V03-002	TLC1002		Thomas L. Cafarella	20-Mar-1981	13:00
;		Change PROCESSES display from scroll-style to page-style to
;			make it terminal-independent.
;
;		Widen working set field of PROCESSES display.
;
;		Reset DEC_CRT advanced video options at exit.
;
;	V03-001	TLC1001		Thomas L. Cafarella	16-Mar-1981	13:00
;		Add CTRL-W screen refresh support.
;
;--

	.SBTTL	DECLARATIONS
	.PSECT	DSPDATA,QUAD,NOEXE
;
; INCLUDE FILES:
;

	$DCDEF				; define device class codes
	$DIBDEF				; define device information block
	$IDBDEF				; define item descriptor block offsets
	$IODEF				; insert I/O function codes
	$IPLDEF				; define interrupt levels
	$RPBDEF				; define Restart Parameter Block
	$JPIDEF				; define GETJPI items
	$PCBDEF				; process control block
	$PHDDEF				; process header definitions
	$PRDEF				; define processor registers
	$PSLDEF				; define PSL fields
	$SCRDEF				; SCRPKG definitions
	$SSDEF				; define status codes
	$STSDEF				; define status fields
	$TTDEF				; define terinal functions
	$CDBDEF				; Define Class Descriptor Block
	$MRBDEF				; Define Monitor Request Block
	$MBPDEF				; Define Monitor Buffer Pointers
	$MCADEF				; Define Monitor Communication Area
	$MONDEF				; Monitor Recording File Definitions
	$DSCDEF				; Descriptor Definitions

;
; MACROS:
;

;
; Local Macro Definitions
;

;
; ALLOC Macro - Dynamically allocate space on the stack.
;

	.MACRO	ALLOC	LENGTH,RSLDESC,RSLBUF
	SUBL	#<LENGTH+3>&<^C3>,SP
	.IF	NB,RSLBUF
	MOVL	SP,RSLBUF
	.ENDC
	PUSHL	SP
	PUSHL	#LENGTH
	MOVL	SP,RSLDESC
	.ENDM	ALLOC


;
; EQUATED SYMBOLS:
;


COLL_BUFS = 2				; Number of collection  buffers
REG_BUFS = 4				; Number of "regular stats" buffers
PC_BUFS = 4				; Number of "percent stats" buffers

CR = 13					; carriage return
ESC = 27				; escape character
LF = 10					; line feed
SI = 15					; shift in (selects G0 char set on VT100)
BP_SECS = 2				; seconds between PROCESSES screens
MAXBARS == 40				; number of bar chars in horiz. graph
DEF_BAR = ^A/*/				; default bar character (for hardcopy)
VID_BAR = ^A/a/				; video terminal bar character
MAX55HEIGHT = 200			; max height of vertical bars (VT55)
STARTPOS = 50				; stavt of bargraph position
START_XPOS = 34+4			; starting x position for VT55 bar
VTHEIGHT == 24				; number of rows on screen
VTWIDTH == 80				; number of columns on screen
FIRST_DATA_LINE == 8			; line no of 1st data line for bar and tab
LAST_DATA_LINE == 22			; line no of last data line for bar and tab
VTDATALINES == LAST_DATA_LINE - FIRST_DATA_LINE + 1
					; number of lines of actual data on screen
VT55CWIDTH == 74			; number of chars. on x axis
VT55HEIGHT = 236			; screen height in points
VT55WIDTH = 512				; screen width in points
SCROLL_BEG = 8				; first data line of PROCESSES screen
SCROLL_END = 22				; last data line of PROCESSES screen
PROCS_AREA = SCROLL_END - SCROLL_BEG + 1 ; size of PROCESSES display area
PROC_LINE = 80				; width of a PROCESSES display line
PUTS_REGSET = 0				; value for reg graphics set to PUT_SCREEN
PUTS_ALTSET = 0				; value for alt graphics set to PUT_SCREEN
SCRDSC_SIZE = 900			; screen package buffer size
FAOSTK_SIZE = 650			; size of FAOL parameter stack for data displays */
OUTDSC_SIZE = 900			; size of FAO output buffer for displays */
FAOCTR_SIZE == 800			; size in bytes of FAO control string
PUTMSGSIZE = 20				; size in longwords of $PUTMSG message arg vector
MAX_REC_SIZE == 32000			; maximum record size for PLAYBACK and RECORD files
SYS_FAC_NO = 0				; system facility code

;
; SYS$OUTPUT Device types for Monitor
; Loaded into SYSOUT_TYPE
;
DEC_CRT   = 0				; includes VT100-compatible devices
VT5X      = 1				; VT5x series (VT52 and VT55)
HARDCOPY  = 2				; hardcopy terminal and disk file
OTHER_VID = 3				; other video types

;
; OWN STORAGE:
;

BARSIZE::	.LONG	25		; width of bar graph in points (VT55)
BARCHAR::	.BLKB	1		; bar graph character
BPU:		.BLKF	1		; no of bar chars per unit of output value
GMIN:		.BLKL	1		; min value which bar graph can represent
CURGRAPH::	.LONG	0		; currently enabled VT55 graph
CURXPOS:	.LONG	0		; current position for GRAPH6
CPUTIME:	.BLKQ	1		; space for saved process cpu time
PROCS_PER_REC:	.LONG	0		; number of processes which can fit into a ...
					; ... single PLAYBACK or RECORD file class record
TOP_PROCS:	.BLKB	1		; number of top processes to display
TOP_TIME:	.BLKQ	1		; collection time of most recent TOP
					; ... display (in system time units)
TOP_TICKS:	.BLKL	1		; number of clock ticks (10ms units)
					; ... covered by most recent TOP display

DISPLAY_TYPE:	.LONG	0		; display format indicator

NEWXPOS:	.LONG	0		; next point to plot for GRAPH6
NULLTIME:	.LONG	0		; previous CPU time of null process
PTS_STAT:	.BLKL	1		; save area for SCRPKG return stati

CTRLW_MASK:	.LONG	0		; mask required by QIO for out-of-band char
		.LONG	^X00800000	; bit 23 representing CTRL-W

BET_PROCS:	.LONG	-10*1000*1000*BP_SECS ; delta time between PROCESSES
		.LONG	-1		; ... screens for single display event

SYSCMD_DESC:	.ASCID	\SYS$COMMAND\	; User command terminal

VTTYPE::	.LONG	52		; note VT52 terminal
VT55XINCR::	.LONG	0		; incr to next bar of graph

PREV_PD:	.BLKL	1		; no. of processes displayed in previous interval

COMM_VAL::				; dynamic string descriptor for 
					; ... /COMMENT qualifier
		.WORD	MNR_HDR$K_COMLEN ; max comment length
		.BYTE	DSC$K_DTYPE_T	; string descriptor type
		.BYTE	DSC$K_CLASS_D	; dynamic class
		.LONG	0		; CLI$GET_VALUE will fill in address

;
; FAO-related buffers required for /DISPLAY
;

FAOSTK::	.BLKB	FAOSTK_SIZE	; DISPLAY buffer containing data for input to FAO

OUTDSC:					; FAO output buffer descriptor for data displays
		.LONG	OUTDSC_SIZE
		.LONG	10$
10$:		.BLKB	OUTDSC_SIZE

SCRDSC:					; Screen Package buffer descriptor
		.LONG	SCRDSC_SIZE
		.LONG	10$
10$:		.BLKB	SCRDSC_SIZE

;
; Control and name strings for screen output.
;
; These strings contain embedded escape sequences. Before the strings
; are sent to the Screen Package for output, the escape sequences are
; interpreted (in the PUT_TO_SCREEN routine) and translated to general-
; case screen package calls. The sequences embedded below are generally
; equivalent to VT52 escape sequences, with the following exceptions:
;
;	1) Cursor addresses for both row and column are in the
;	   form acceptable to the Screen Package -- i.e., the top
;	   row is 1 and the left-hand column is 1.
;
;	2) ESC B means BOLD all text until an UNDO sequence.
;
;	3) ESC L means UNDERLINE all text until an UNDO sequence.
;
;	4) ESC R means REVERSE VIDEO all text until an UNDO sequence.
;
;	5) ESC U means UNDO all DEC_CRT advanced video attributes selected
;				(i.e., BOLD, UNDERLINE, REVERSE, BLINK)
;

CLRVT55::
	.BYTE	10$-5$
5$:
	.BYTE	ESC,^A/1/		; enter graphics mode
	.BYTE	^A/A/,^X20		; turn off graphs
	.BYTE	^A/I/,^X30		; turn off lines, cursors, etc.
	.BYTE	ESC,^A/2/		; back to alphanumeric mode
10$:

NAMESTR::
	.BYTE	10$-5$
5$:	.BYTE	CR
	.ASCII	'!#*'
	.BYTE	LF
	.ASCII	'!AC'
10$:

;
; Finish sequence -- set regular character set,
; reset DEC_CRT (VT100) AVO characteristics, and 
; carriage return.
;

FIN_SEQ::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/G/	; Set regular character set
	.BYTE	ESC,^A/B/,ESC,^A/L/,ESC,^A/R/
				; Set AVO char'cs so UNDO works
	.BYTE	CR		; Need to send a character to set attribs
	.BYTE	ESC,^A/U/	; Undo DEC_CRT AVO characteristics
	.BYTE	CR
10$:

;
; Sequence to place the cursor on the bottom line and clear it.
;

BOT_CURS::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,24,1		; Position to bottom line on screen
	.BYTE	ESC,^A/K/		; Clear to end of line
10$:

;
; Announcement string, including home and clear screen, set regular
; char set, and identification (top line of the screen).
;

ANNCE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/G/,ESC,^A/H/,ESC,^A/J/,ESC,^A/Y/,1,29
	.ASCII	\VAX/VMS Monitor Utility\
10$:

;
; Status string. This is bottom line (footing) of the screen.
; It contains indications for "PLAYBACK", "SUMMARIZING",
; and "RECORDING".
;

STATUS_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,24,1
	.ASCII	\!AC\
	.BYTE	ESC,^A/Y/,24,34
	.ASCII	\!AC\
	.BYTE	ESC,^A/Y/,24,70
	.ASCII	\!AC\
10$:

;
; Title string, including cursor positioning and title (with
; optional percent sign), centered and reversed.
;

TITLE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,2,1		; Position cursor
	.ASCII	\!#* \			; Preceding blanks
	.BYTE	ESC,^A/R/		; Reverse-video
	.ASCII	\ !AC !#<(%) !>\	; Title text
	.BYTE	ESC,^A/U/		; Undo reverse-video
10$:

;
; User's comment string, including cursor positioning
; and comment string, centered and reversed.
;

COMM_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,5,1		; Position cursor
	.ASCII	\!#* \			; Preceding blanks
	.BYTE	ESC,^A/R/		; Reverse-video
	.ASCII	\ !AF \			; Title text
	.BYTE	ESC,^A/U/		; Undo reverse-video
10$:

;
; Date/time string, including cursor positioning.
;

TIME_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,3,35
	.ASCII	\!AD\
	.BYTE	ESC,^A/Y/,4,37
	.ASCII	\!AD\
10$:

;
; Summary line string, including cursor
; positioning and from/to times.
;

SUMMLINE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,3,37
	.ASCII	\SUMMARY      From: !AD\
	.BYTE	ESC,^A/Y/,4,50
	.ASCII	\To:   !AD\
10$:

PLAY_STR:				; String for footing line
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/R/		; Reverse video
	.ASCII	\ PLAYBACK \
	.BYTE	ESC,^A/U/		; Undo the reverse
10$:

SUMM_STR:				; String for footing line
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/R/		; Reverse video
	.ASCII	\ SUMMARIZING \
	.BYTE	ESC,^A/U/		; Undo the reverse
10$:

REC_STR:				; String for footing line
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/R/		; Reverse video
	.ASCII	\ RECORDING \
	.BYTE	ESC,^A/U/		; Undo the reverse
10$:

BLANK_STR::	.ASCIC	\ \		; Blank string for footing and heading lines
STATUS_PARMS::				; Status parms -- next 3 longwords
FOOTP:		.BLKL	1		; Address of "playback" or blank string
FOOTS:		.BLKL	1		; Address of "summary" or blank string
FOOTR:		.BLKL	1		; Address of "record" or blank string

;
; PROCESSES screen heading string.
;

PROCHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,1,1		; Position cursor
	.ASCII	\Process Count:\
	.BYTE	ESC,^A/Y/,1,60		; Position cursor
	.ASCII	\Uptime:\
	.BYTE	ESC,^A/Y/,6,1		; Position cursor
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\   PID      UIC    STATE PRI   NAME          SIZE\
	.ASCII	\      DIOCNT  FAULTS  CPU TIME \
	.BYTE	ESC,^A/U/		; Undo underlining
10$:

;
; Tabular screen heading string.
;

TABHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,6,40
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\CUR\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!AC       \
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\AVE\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!-!AC       \
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\MIN\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!-!AC       \
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\MAX\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!-!AC\
10$:

;
; Bar graph screen heading string.
;

BARHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,6,38
	.ASCII	\!10<!UL!AC!>!10<!UL!AC!>!10<!UL!AC!>!6<!UL!AC!>!#< !>!5UL!AC\
10$:

;
; Bar graph statistic heading string (in smaller box).
;

STATHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,2,13
	.ASCII	\+-----+\
	.BYTE	ESC,^A/Y/,3,13
	.ASCII	\| \
	.ASCII	\!AD\
	.ASCII	\ |\
	.BYTE	ESC,^A/Y/,4,13
	.ASCII	\+-----+\
10$:

;
; Other bar graph strings
;

CURSOR_STR::	.BYTE	ESC,^A\Y\	; Position cursor escape sequence

HORIZ_STR::	.ASCII	\+ - - - - + - - - - + - - - - + - - - - -+\
					; Top and bottom line of bar graph box
PCENT_STR::	.ASCIC	\%\		; Percent symbol string for heading line
K_STR::		.ASCIC	\K\		; K symbol string for heading on bar graph box
STAT_HEAD::	.ASCII	\CUR\		; Table of statistic headings for bar graph
		.ASCII	\AVE\
		.ASCII	\MIN\
		.ASCII	\MAX\

SYSOUT_TYPE:	.BLKB	1		; SYS$OUTPUT device type
					; MONITOR SYSOUT types are:
					; DEC_CRT, VT5X, OTHER_VID, HARDCOPY
					; (Type codes defined above)

PROC_SETUP_STR:	.LONG	20$-10$		; Descriptor for PROCESSES screen setup ...
		.LONG	10$		; ... string (incl. cursor positioning)
10$:
		.BYTE	ESC,^A/Y/,1,16	; Cursor position to process count field
		.ASCII	\!5<!UL!>\           
		.BYTE	ESC,^A/Y/,1,68	; Cursor position to uptime field
		.ASCII	\!AS\
20$:

PROC_RES_STR:	.LONG	20$-10$		; Descriptor for PROCESSES FAO control ...
		.LONG	10$		; ... string (resident process)
10$:		.ASCII	\!XL [!3OW,!3OW] !5AC !2UL !4(+)!15AF !9<!UL/!UL!> !7UL !7UL !2(+)!%T\
20$:

PROC_NRES_STR:	.LONG	20$-10$		; Descriptor for PROCESSES FAO control ...
		.LONG	10$		; ... string (non-resident process)
10$:		.ASCII	\!XL [!3OW,!3OW] !5AC !2UL !4(+)!15AF !9<!UL/!UL!>!5(+)       SWAPPED OUT!9* \
20$:

;
; Top PROCESSES FAO control string for one process display line
;

TOPSTR:
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,0,2		; position to left margin
	.ASCII	\[!3OW,!3OW]  !4(+)!15AF  !7<!#UL!>  \
	.BYTE	ESC,^A/F/		; select alternate char set
	.ASCII	\!#**\			; repeating bar character
	.BYTE	ESC,^A/G/,ESC,^A/K/	; select reg set and erase to EOL
10$:
TOPLNNO = TOPSTR+3			; label for line number
TOPBAR  = TOPSTR+46			; label for bar character

;
; Top PROCESSES FAO control string to erase a line
;

ERLINE_STR:
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,0,1		; position to left margin
	.BYTE	ESC,^A/K/		; erase to end of line
10$:
ERLNNO = ERLINE_STR+3			; label for line number

VT100_REGSET:	.LONG	20$-10$		; descriptor for VT100 ...
		.LONG	10$		; ... "regular" char set esc seq
10$:		.BYTE	ESC,^A/(/,^A/B/,SI
20$:
VT100_ALTSET:	.LONG	20$-10$		; descriptor for VT100 ...
		.LONG	10$		; ... "alternate" graphics set esc seq
10$:		.BYTE	ESC,^A/(/,^A/0/
20$:
VT100_CURSET:	.BLKL	1		; addr of esc seq descr for curr char set
REG_SET:	.LONG	20$-10$		; VT52 esc seq to estab regular char set
		.LONG	10$
10$:		.BYTE	ESC,^A/G/
20$:

PUTSCRARG:				; arg list for PUT_SCREEN call
	.LONG	4			; argument count
	.LONG	TXT_DESC		; addr of buffer to display
	.LONG	0,0			; no cursor pos specification
ATTRIBMSK: .LONG 0			; start off with no special attributes

TXT_DESC:				; hold area for descriptor to be PUT'd
TXT_LENGTH:	.BLKL	1		; length
TXT_START:	.BLKL	1		; address

ESC_SEQ_TABLE:	.ASCII	\LBFGHJKRUY\	; table of valid escape modifiers
ES_TAB_LEN = .-ESC_SEQ_TABLE		; length of table

PUTMSGVEC::	.BLKL	PUTMSGSIZE	; Message argument vector for $PUTMSG

	.SBTTL	CALC_LEN - Calculate class record lengths
	.PSECT	$$MONCODE,NOWRT,EXE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to calculate the length of a block
;	(CDB$W_BLKLEN) for each STANDARD class. Non-standard
;	classes have this value entered at compile-time. Block
;	length (for standard classes) is defined as the sum of
;	the sizes of all data items which comprise the class.
;
; CALLING SEQUENCE:
;
;	CALLS #0,CALC_LEN
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	PERFTABLE    - table of IDB'sdescribing each data item,
;			 indexed by item number ( * entry size).
;
;	CDBHEAD      - table of CDB's, one for each class.
;
;	MAX_CLASS_NO - maximum class number (class numbers are zero-origin)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDB$W_BLKLEN (block length) field established for each CDB.
;
;	PROCS_PER_REC field established for the PROCESSES class.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	CALC_LEN,	^M<R2,R3,R4,R6>

	MOVAL	CDBHEAD,R6		; Get address of first CDB
	MOVL	#MAX_CLASS_NO+1,R3	; Get number of CDB's
10$:
	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),20$ ; Cont if a standard class
	MOVL	#<MAX_REC_SIZE-MNR_CLS$K_HSIZE-MNR_PRO$K_PSIZE>,R2
					; Get max data size
	DIVW3	CDB$W_BLKLEN(R6),R2,W^PROCS_PER_REC
					; Compute processes per record for ...
					; ... PROCESSES non-STD class
	BRB	80$			; Go do next CDB
20$:
	MOVL	CDB$L_COUNT(R6),R0	; Get no of items to sum for this CDB
	MOVL	CDB$A_ITMSTR(R6),R1	; Address of item-number string
	CLRL	R2			; Clear block size reg
30$:
	MOVZBL	(R1)+,R4		; Get next item number
	MULL	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	CASE	IDB$W_ISIZE(R4),<40$,50$,60$>,W ; Select on proper size

40$:	INCL	R2			; Add 1 for byte
	BRB	70$
50$:	ADDL	#2,R2			; Add 2 for word
	BRB	70$
60$:	ADDL	#4,R2			; Add 4 for longword
70$:	SOBGTR	R0,30$			; Loop for each item in this class

	MOVW	R2,CDB$W_BLKLEN(R6)	; Store away count for this class
80$:	ADDL	#CDB$K_SIZE,R6		; Point to CDB for next class
	SOBGTR	R3,10$			; Loop for each CDB

	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

	.SBTTL	SET_CLASS_DEF - Set Class Defaults
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to set default values for
;	CDB$B_ST (Requested statistic) and CDB$V_PERCENT
;	(bit indicating that a percent transformation has
;	been requested) for each class(CDB).
;
; CALLING SEQUENCE:
;
;	CALLS #0,SET_CLASS_DEF
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	CDBHEAD      - table of CDB's, one for each class.
;
;	MAX_CLASS_NO - maximum class number (class numbers are zero-origin)
;
;	CDB$ST_DEF field for each CDB.
;
;	CDB$V_PERCENT bit for each CDB.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDB$B_ST (Statistic code) and CDB$V_PERCENT (percent transformation)
;	fields set to default values for all classes.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	SET_CLASS_DEF,	^M<R3,R6>

	MOVAL	CDBHEAD,R6		; Get address of first CDB
	MOVL	#MAX_CLASS_NO+1,R3	; Get number of CDB's
10$:
	MOVB	CDB$B_ST_DEF(R6),CDB$B_ST(R6) ; Load default stat to current

;
; Move CDB$V_PCENT_DEF bit setting to the CDB$V_PERCENT bit
;

	BBS	#CDB$V_PCENT_DEF,CDB$L_FLAGS(R6),30$ ; Br if percent is default
	BBCC	#CDB$V_PERCENT,CDB$L_FLAGS(R6),20$ ; Clear percent bit
20$:	BRB	40$			; ... and continue
30$:
	BBSS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),40$ ; Set percent bit
40$:

;
; Move CDB$V_CPU_DEF bit setting to the CDB$V_CPU bit
;

	BBS	#CDB$V_CPU_DEF,CDB$L_FLAGS(R6),60$ ; Br if cpu is default
	BBCC	#CDB$V_CPU,CDB$L_FLAGS(R6),50$ ; Clear cpu bit
50$:	BRB	70$			; ... and continue
60$:
	BBSS	#CDB$V_CPU,CDB$L_FLAGS(R6),70$ ; Set cpu bit
70$:
	ADDL	#CDB$K_SIZE,R6		; Point to CDB for next class
	SOBGTR	R3,10$			; Loop for each CDB

	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

	.SBTTL	FETCH - Collect Data into Buffer 

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to collect the data for the next interval.
;	It scans a table describing which items to collect, and moves
;	each item to the proper slot in the collection buffer supplied
;	by the caller.
;
; CALLING SEQUENCE:
;
;	Entered via CALL from $CMKRNL system service.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block)
;
;	 8(AP) - address of 1st byte of variable portion of collection buffer
;
; IMPLICIT INPUTS:
;
;	EXE$GQ_SYSTIME - current time in system time (quadword) units
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CURRENT collection buffer is filled with raw data.
;
; ROUTINE VALUE:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	FETCH,	^M<R3,R4,R5,R6>

	MOVL	4(AP),R6		; Load CDB pointer
	MOVL	8(AP),R5		; Load addr of 1st byte of actual data
	MOVQ	G^EXE$GQ_SYSTIME,<MNR_CLS$Q_STAMP-MNR_CLS$K_HSIZE>(R5)
					; Get current time into coll buffer
;
; If this class has a pre-collection routine, call it.
;
	TSTL	CDB$A_PRECOLL(R6)	; Is there a pre-collection rtn?
	BEQL	10$			; No -- continue
	PUSHL	R5			; Yes -- stack coll buffer addr
	CALLS	#1,@CDB$A_PRECOLL(R6)	; Call it
	BLBC	R0,70$			; If fetch is not required, get out
10$:
	MOVL	CDB$L_COUNT(R6),R0	; Get number of items to fetch
	MOVL	CDB$A_ITMSTR(R6),R1	; Address of item-number string
	CLRL	R3			; Clear loop counter
20$:
	MOVZBL	(R1)+,R4		; Get next item number
	MULL	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	CASE	IDB$W_ISIZE(R4),<30$,40$,50$>,W ; Select on proper size

30$:	MOVB	@IDB$A_ADDR(R4),(R5)+	; Collect a byte
	BRB	60$
40$:	MOVW	@IDB$A_ADDR(R4),(R5)+	; Collect a word
	BRB	60$
50$:	MOVL	@IDB$A_ADDR(R4),(R5)+	; Collect a longword
60$:	AOBLSS	R0,R3,20$		; Loop until done

;
; If this class has a post-collection routine, call it.
;
	TSTL	CDB$A_POSTCOLL(R6)	; Is there a post-collection rtn?
	BEQL	70$			; No -- go return
	PUSHL	8(AP)			; Yes -- stack coll buffer addr
	CALLS	#1,@CDB$A_POSTCOLL(R6)	; Call it

70$:	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

	.SBTTL	CLASS_COLLECT - Collect & Transform Data

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called once per interval per class to collect
;	and record raw data and to do statistical transformations of
;	that data. The transformations include calculations of minimum
;	value, maximum value, total since request began, percent, etc.
;	On the first call to this routine per request, up to ten buffers
;	are obtained. These consist of two flip-flopped collection
;	buffers for raw data, and up to 8 statistics buffers. On subsequent
;	calls, the buffers are updated.
;
; CALLING SEQUENCE:
;
;	CALLS #1, CLASS_COLLECT
;
; INPUTS:
;
;	 4(AP) - address of byte containing class number
;
; IMPLICIT INPUTS:
;
;	CDBPTR - pointer to CDB (Class Descriptor Block)
;	MRBPTR - pointer to MRB (Monitor Request Block)
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;	SPTR -   pointer to SYI (System Information Area)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with raw data for this class
;	for this interval.
;
;	All required statistics buffers filled with transformed
;	data for this class for this interval.
;
;	COLLENDED bit set to YES if this collection 
;	has passed the requested ending time.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R6  = CDB pointer
;	R7  = MRB pointer
;	R8  = CURRENT collection buffer pointer
;	R9  = PREVIOUS collection buffer pointer
;	R10 = Buffer block pointer
;	R11 = MCA pointer
;
;	Others are volatile.
;
;--


.ENTRY	CLASS_COLLECT,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	CDBPTR,R6		; Load CDB pointer
	MOVL	MRBPTR,R7		; Load MRB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	BBC	#CDB$V_CPU_EXP,CDB$L_FLAGS(R6),5$
					; Br if not special MODES case
;
; If CDB$V_CPU_EXP is set, this is a special case of the MODES
; class. It occurs when the monitored system is a multiprocessor
; system, but the user has requested a combined display (or
; summary) of the processor modes. The number of items for the
; MODES class is temporarily expanded to 14 during collection;
; it is reset to 7 before exiting the CLASS_COLLECT routine.
;

	MOVL	SPTR,R0			; Get ptr to SYI
	MOVZBL	MNR_SYI$B_MPCPUS(R0),R0	; Get number of CPUs
	MULL2	R0,CDB$L_COUNT(R6)	; Compute temporary item count
	MULW2	R0,CDB$W_BLKLEN(R6)	; Compute temporary block length
5$:
	TSTL	MCA$L_COLLCNT(R11)	; First collection ?
	BNEQ	10$			; No -- keep going
	BSBW	GET_BUFFERS		; Get collection & stat buffers
	BLBS	R0,10$			; Continue if OK
	BRW	CC_ERROR		; Else exit with error
10$:
	MOVL	CDB$A_BUFFERS(R6),R10	; Load address of buffer block
;
; For standard classes:
;
; Load CURRENT buffer pointer (R8) and PREVIOUS buffer pointer (R9); at
; the same time, flip-flop the state of the CDB$V_SWAPBUF bit, so BUFFERA
; and BUFFERB will be swapped on next CLASS_COLLECT call for this class.
; When CDB$V_SWAPBUF is OFF, BUFFERA is CURRENT; otherwise, BUFFERB is
; CURRENT.
;
; For non-standard class (PROCESSES):
;
; CURRENT buffer pointer (R8) always points to BUFFERA. The CDB$V_SWAPBUF
; bit is always clear.
;
	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),15$ ; Branch if STD class
	CMPL	MCA$L_COLLCNT(R11),#1	; Second collection coming up?
	BNEQ	20$			; No -- continue
	CMPB	CDB$B_ST(R6),#REG_PROC	; Regular PROCESSES display?
	BEQL	20$			; Yes -- continue
	BITW	#<MRB$M_DISPLAY+MRB$M_SUMMARY>,MRB$W_FLAGS(R7) ; Displaying or summarizing?
	BEQL	20$			; No -- continue
;
; Swap MBP$A_BUFFA and MBP$A_BUFF1ST pointers in order to retain data
; from the first collection buffer for use later during summary processing.
;

	MOVL	MBP$A_BUFFA(R10),R1	; Save current coll buff ptr
	MOVL	MBP$A_BUFF1ST(R10),MBP$A_BUFFA(R10) ; Point current to first
	MOVL	R1,MBP$A_BUFF1ST(R10)	; ... and first to current
	BRB	20$			; Go make BufferA CURRENT
;
; Standard classes
;

15$:
	BBSC	#CDB$V_SWAPBUF,CDB$L_FLAGS(R6),20$ ; Clear bit if set & branch
	INSV	#1,#CDB$V_SWAPBUF,#1,CDB$L_FLAGS(R6) ; Bit was clear -- set it
	MOVL	MBP$A_BUFFERB(R10),R8	; Make BufferB CURRENT
	MOVL	MBP$A_BUFFERA(R10),R9	; ... and BufferA PREVIOUS
	BRB	30$			; ... and continue
20$:
	MOVL	MBP$A_BUFFERA(R10),R8	; Make BufferA CURRENT
	MOVL	MBP$A_BUFFERB(R10),R9	; ... and BufferB PREVIOUS

;
; Collect data for this class into the CURRENT collection buffer.
;

30$:
	BSBW	COLLECTION		; Get data for this class
	BLBS	R0,40$			; Continue if OK
	BRW	CC_ERROR		; Else exit with error
;
; If a record request, perform recording.
;

40$:
	BBC	#MRB$V_RECORD,MRB$W_FLAGS(R7),70$ ; Continue if not recording
	BBC	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),50$ ; If live, go record
	BBC	#MCA$V_MULTFND,MCA$W_FLAGS(R11),70$ ; Skip rec if mult not found
50$:
	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),60$ ; If STD class, go write a record
	MOVZWL	CDB$W_BLKLEN(R6),-(SP)	; Non-STD class -- push data block size
	PUSHL	R8			; ... and collection buffer ptr
	CALLS	#2,WRITE_PROC_RECORDS	; Write the required num of PROCESSES recs
	BLBS	R0,70$			; Continue if status OK
	BRW	CC_ERROR		; Else exit with error
60$:
	CLRQ	-(SP)			; Get descr on stack for CALL
	MOVW	CDB$W_BLKLEN(R6),(SP)	; Move in length of buffer
	ADDW2	#MNR_CLS$K_HSIZE,(SP)	; Add in class header size
	MOVL	R8,4(SP)		; Load address of buffer
	PUSHL	SP			; Stack descriptor address
	CALLS	#1,WRITE_RECORD		; ... and record the buffer
70$:
	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),110$ ; If non-STD class, skip all transforms
	BBC	#CDB$V_CPU_EXP,CDB$L_FLAGS(R6),75$
					; Br if not special MODES case
	BSBW	COMBINE_MODES		; Combine modes for all cpu's
75$:
	TSTL	MCA$L_COLLCNT(R11)	; First collection?
	BEQL	110$			; Yes -- skip all transforms	
;
; Do Data Transformations
;
;

	BSBW	FILL_STATS_BUFF		; Fill STATS from the 2 coll buffers

;
; Update SUM buffer from STATS buffer
;
	MOVL	MBP$A_STATS(R10),R0	; Load STATS buffer pointer
	MOVL	MBP$A_SUM(R10),R1	; Load SUM buffer pointer
	MOVL	CDB$L_COUNT(R6),R2	; Load count of items in STATS
80$:
	ADDL2	(R0)+,(R1)+		; Add this item to SUM buff
	SOBGTR	R2,80$			; Loop for each item in STATS buff

	BBC	#CDB$V_PERCENT,CDB$L_FLAGS(R6),100$ ; If percent not requested, skip percent calcs

	BSBW	FILL_PCSTATS_BUFF	; Fill PCSTATS from STATS

;
; Update PCSUM buffer from PCSTATS buffer
;
	MOVL	MBP$A_PCSTATS(R10),R0	; Load PCSTATS buffer pointer
	MOVL	MBP$A_PCSUM(R10),R1	; Load PCSUM buffer pointer
	MOVL	CDB$L_COUNT(R6),R2	; Load count of items in PCSTATS
90$:
	ADDL2	(R0)+,(R1)+		; Add this item to PCSUM buff
	SOBGTR	R2,90$			; Loop for each item in PCSTATS buff
;
; Update PCMIN and PCMAX buffers from PCSTATS buffer
;
	BSBW	UPD_PC_MIN_MAX		; Update PCMIN and PCMAX

;
; Convert counts to rates in STATS buffer and update MIN and MAX
;
100$:
	BSBW	COMPUTE_STATS		; Convert counts to rates in STATS
					; ... and update MIN and MAX
;
;
;
;
; Call COLLECTION_END if end of collection has been reached. The end
; of collection is tested by comparing the system time (quadword)
; values of the current time and the requested end time.
;
;

110$:
	CMPB	@4(AP),MCA$B_LASTC(R11) 		; Last class?
	BNEQU	CC_NORMAL				; No -- just exit
	MOVQ	MNR_CLS$Q_STAMP(R8),MCA$Q_LASTCOLL(R11)	; Yes -- remember latest coll time
	BBS	#MRB$V_INDEFEND,MRB$W_FLAGS(R7),CC_NORMAL ; Skip end check if indef end
	CMPL	MNR_CLS$Q_STAMP+4(R8),MRB$Q_ENDING+4(R7) ; Has curr time passed
							; ... requested end (hi-order) ?
	BLSSU	CC_NORMAL				; No -- simply return
	BGTRU	120$					; Yes -- indicate so and return
	CMPL	MNR_CLS$Q_STAMP(R8),MRB$Q_ENDING(R7) 	; Check low order longword
	BLSSU	CC_NORMAL				; Not at end yet -- return
120$:
	CALLS	#0,COLLECTION_END			; Indicate collection has ended
							; COLLECTION_END sets COLLENDED bit

CC_NORMAL:
	MOVL	NORMAL,R0				; Indicate normal status
CC_ERROR:
	RET						; Return

	.SBTTL	COMBINE_MODES - Combine Modes for all CPUs

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by CLASS_COLLECT to combine the mode
;	tick counters for all CPU's on the system. The monitored
;	system is a multiprocessing system, but the user requested
;	that the display and/or summary show combined values for
;	the processor modes (/NOCPU).
;
; CALLING SEQUENCE:
;
;	BSBW	COMBINE_MODES
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	R6 = Pointer to MODES CDB
;	R8 = Pointer to CURRENT collection buffer
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDB$L_COUNT adjusted down to the number of modes (7).
;	CDB$W_BLKLEN adjusted down to the size of a uniprocessor data block.
;	
;	The first 7 longwords in the data portion of the collection buffer
;	will contain combined mode counter values for all CPU's on the system.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0, R1, R2 destroyed.
;
;--


COMBINE_MODES:

	MOVL	SPTR,R0			; Get pointer to SYI
	MOVZBL	MNR_SYI$B_MPCPUS(R0),R0	; Get number of CPUs
	DIVW2	R0,CDB$W_BLKLEN(R6)	; Shrink block len to uniprocessor case
	DIVL2	R0,CDB$L_COUNT(R6)	; Shrink count too
	MOVL	CDB$L_COUNT(R6),R0	; Get number of modes
	ADDL3	#MNR_CLS$K_HSIZE,R8,R1	; Compute start addr of 1st set of counters
	MOVAL	(R1)[R0],R2		; Compute start addr of 2nd set of counters
10$:
	ADDL2	(R2)+,(R1)+		; Combine 2nd set with 1st set
	SOBGTR	R0,10$			; ... for all counters

	RSB				; Return

	.SBTTL	QUAD_LT_QUAD - Compare Two Quadwords

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by PL/I routines to compare two unsigned
;	quadword values (such as system time values). The routine answers
;	the question: Is the first value less than the second value?
;	The value YES or NO is placed in R0 upon exit.
;
; CALLING SEQUENCE:
;
;	CALLS #2,QUAD_LT_QUAD
;
; INPUTS:
;
;	4(AP) - address of first quadword value
;
;	8(AP) - address of second quadword value
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	Routine value below.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	R0 = YES if first quadword value is less than the second quadword value.
;	R0 = NO  otherwise
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	QUAD_LT_QUAD,	^M<>

	MOVQ	4(AP),R0		; Pointers in R0 and R1
	CMPL	4(R0),4(R1)		; First < Second (hi-order) ?
	BLSSU	20$			; Yes -- answer is YES
	BGTRU	10$			; No -- answer is NO
	CMPL	(R0),(R1)		; Check low order longword
	BLSSU	20$			; Go answer YES
10$:
	MOVL	#NO,R0			; First not less than second
	BRB	QLQ_RET			; Go return
20$:
	MOVL	#YES,R0			; First less than second
QLQ_RET:
	RET				; Return with value in R0

	.SBTTL	QUAD_EQ_0 - Compare Quadword = 0

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by PL/I routines to compare an unsigned
;	quadword values (such as a system time value) with the quadword
;	value 0. The routine answers the question: Is the quadword value
;	equal to 0?
;
;	The value YES or NO is placed in R0 upon exit.
;
; CALLING SEQUENCE:
;
;	CALLS #1,QUAD_EQ_0
;
; INPUTS:
;
;	4(AP) - address of quadword value
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	Routine value below.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	R0 = YES if quadword value is equal to 0.
;	R0 = NO  otherwise
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	QUAD_EQ_0,	^M<>

	MOVQ	@4(AP),R0		; Quadword value in R0, R1
	TSTL	R0			; Right half = 0?
	BNEQU	10$			; No -- answer NO
	TSTL	R1			; Yes -- left half = 0?
	BNEQU	10$			; No -- answer NO
	MOVL	#YES,R0			; Answer YES
	BRB	QEZ_RET			; Go exit
10$:
	MOVL	#NO,R0			; Answer NO
QEZ_RET:
	RET				; Return with value in R0

	.SBTTL	MPCHECK - Check system for MP capability

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by the EXECUTE_REQUEST PL/I routine
;	to determine whether or not the running system has MP
;	(multiprocessing) capability.
;
;	The value YES or NO is placed in R0 upon exit.
;
; CALLING SEQUENCE:
;
;	CALLS #0,QUAD_EQ_0
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	EXE$GB_CPUTYPE -- CPU type. Assume type 1 = 780.
;
;	EXE$GL_RPB -- Address of Restart Parameter Block.
;
; OUTPUTS:
;
;	Routine value below.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	R0 = YES if the system has MP capability
;	R0 = NO  otherwise
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	MPCHECK,	^M<>

	CMPB	G^EXE$GB_CPUTYPE,#1	; 780 processor?
	BNEQ	10$			; No -- go answer NO
	MOVL	G^EXE$GL_RPB,R0		; Get Restart Parameter Block ptr
	BBC	#RPB$V_MPM,RPB$L_BOOTR5(R0),10$ ; Br if no multi-port mem
	MOVL	#YES,R0			; Answer YES
	BRB	20$			; Go exit
10$:
	MOVL	#NO,R0			; Answer NO
20$:
	RET				; Return with value in R0

	.SBTTL	GET_BUFFERS - Obtain Collection & Stat Buffers

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Standard classes:
;
;	This routine obtains a number of collection and statistical buffers
;	using the LIB$GET_VM facility. The number of buffers obtained is
;	determined by the 3 symbols COLL_BUFS, REG_BUFS and PC_BUFS.
;	The buffers are contiguous, forming a block which includes at
;	its beginning, a set of longword pointers to the buffers which
;	follow immediately thereafter. The buffer block always includes
;	COLL_BUFS collection buffers and REG_BUFS regular stats buffers.
;	If percent data is being maintained, PC_BUFS percent stats buffers
;	are also included.
;
;	Non-standard class (PROCESSES):
;
;	For the regular PROCESSES display, only one collection
;	buffer, and the display buffer will be obtained.
;
;	For the TOP PROCESSES displays, one collection buffer
;	and the 5 arrays (DATA, DIFF, ORDER, PID, ADDR) will
;	be obtained. Space for the FAO control string will also
;	be obtained, but will not be part of the buffer block.
;
; CALLING SEQUENCE:
;
;	BSBW GET_BUFFERS
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	COLL_BUFS global symbol -- number of collection buffers to obtain
;	REG_BUFS  global symbol -- number of regular stats buffers to obtain
;	PC_BUFS   global symbol -- number of percent stats buffers to obtain
;	SPTR -- pointer to SYI (System Information Area)
;
;	R6 -- pointer to CDB
;	R7 -- pointer to MRB
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDB$A_BUFFERS and CDB$L_BUFFERS fields of CDB will contain pointer
;	to buffer block and its length, respectively.
;
;	SUM buffer (and PCSUM buffer, if percent requested) are cleared to 0.
;
;	For TOP PROCESSES class, the DATA array will be cleared to 0.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or error status from LIB$GET_VM, if any.
;
; SIDE EFFECTS:
;
;	Registers R1,R2,R3,R4,R5,R8,R9,R10 destroyed.
;
;--

GET_BUFFERS:

;
; Get buffers for non-standard class (PROCESSES)
;

	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),5$	; Continue if a non-standard class
	BRW	90$				; Otherwise, go process standard
5$:
	CLRL	R9				; Clear collection buffer byte counter
	MOVL	SPTR,R2				; Get pointer to SYI
	MOVZWL	MNR_SYI$W_MAXPRCCT(R2),R2	; Get max process count
	MULW3	CDB$W_BLKLEN(R6),R2,R9		; Compute bytes for data blocks
	ADDL2	#<MNR_PRO$K_PSIZE+MNR_CLS$K_HSIZE>,R9 ; Add prefix and class header ...
						; ... to get collection buffer size
	CLRL	R4				; Clear FAO stack (display buffer) byte counter
	BITW	#<MRB$M_DISPLAY+MRB$M_SUMMARY>,MRB$W_FLAGS(R7) ; Displaying or summarizing?
	BEQL	10$				; No -- just need collection buffer
	CMPB	#REG_PROC,CDB$B_ST(R6)		; Regular PROCESSES display ?
	BNEQ	30$				; No -- go get TOP arrays

;
; Regular PROCESSES display -- get display buffer (FAO stack)
;

	MULW3	#MNR_PRO$K_FSIZE,R2,R4		; Calc FAO stack (display buffer) size
10$:
	ADDL2	R9,R4				; Add both buffer sizes together
	ADDL3	#8,R4,CDB$L_BUFFERS(R6)		; ... add enough for 2 pointers
	BSBW	80$				; Obtain the virtual memory
	BLBS	R0,20$				; Continue if obtained OK
	BRW	GB_RSB				; Else, go exit with error
20$:
	MOVL	CDB$A_BUFFERS(R6),R5		; Now prepare to load 2 pointers
	MOVAL	8(R5),(R5)			; Point first ptr to collection buffer	
	ADDL3	(R5),R9,4(R5)			; Point 2nd ptr to display buffer
	BRW	GB_NRSB				; ... and take normal return

;
; TOP PROCESSES display -- get 5 arrays consisting of "MAX PROCESS COUNT"
; longwords each.
;

30$:
	MULL3	#4,R2,R8			; Compute size of one array
	MULL3	#5,R8,R4			; Need 5 arrays
	ADDL2	R9,R4				; Add in size of 2 coll buffs to
	ADDL2	R9,R4				; ... get total bytes required
	ADDL3	#<4*7>,R4,CDB$L_BUFFERS(R6)	; ... add enough for 7 pointers
	BSBB	80$				; Obtain the virtual memory
	BLBS	R0,40$				; Continue if obtained OK
	BRW	GB_RSB				; Else, go exit with error
40$:
	MOVL	CDB$A_BUFFERS(R6),R5		; Now prepare to load the 7 pointers
	MOVAL	<4*7>(R5),(R5)+			; Point 1st ptr to 1st coll buffer	
	ADDL3	R9,-4(R5),(R5)+			; Point 2nd ptr to 2nd coll buffer
	ADDL2	-4(R5),R9			; Compute addr of first of 5 arrays
	MOVL	#5,R1				; Loop counter
50$:
	MOVL	R9,(R5)+			; Store array pointer and advance R5
	ADDL2	R8,R9				; Compute addr of next array
	SOBGTR	R1,50$				; Loop storing 5 pointers

	BSBW	CLEAR_DATA			; Clear DATA array

;
; Obtain an FAO control string for PROCESSES/TOP. This buffer
; will not be part of the buffer block, but, instead, will be
; described by the CDB$A_FAOCTR and CDB$L_FAOCTR fields of the
; CDB. The FAO control string for STANDARD classes is obtained
; in the TEMPLATE (BLISS-32) routine.
;

	MOVL	#FAOCTR_SIZE,CDB$L_FAOCTR(R6)	; Store size of FAO control string
	PUSHAL	CDB$A_FAOCTR(R6)		; Push addr of longword to hold
						; ... FAO control string pointer
	PUSHAL	CDB$L_FAOCTR(R6)		; Now push addr of # of bytes needed
	CALLS	#2,G^LIB$GET_VM			; Allocate space
	BLBC	R0,75$				; Branch if failed
	BRW	GB_NRSB				; Else take normal return
75$:
	BRW	GB_RSB				; Take common error exit

;
; Obtain virtual memory for required buffers.
;

;
; Push 2 addresses required by LIB$GET_VM and issue request
;

80$:
	PUSHAL	CDB$A_BUFFERS(R6)		; Push addr of longword to hold
						; ... buffer block pointer
	PUSHAL	CDB$L_BUFFERS(R6)		; Now push addr of # of bytes needed
	CALLS	#2,G^LIB$GET_VM			; Allocate buffers
	RSB					; Return

;
; Get buffers for standard class
;

;
; Compute number of bytes to allocate for the buffer block for this class.
;

90$:
	MOVL	#<COLL_BUFS+REG_BUFS>,R4	; Number of buffers to obtain
	BBC	#CDB$V_PERCENT,CDB$L_FLAGS(R6),100$ ; If percent not requested, skip PC_BUFS
	ADDL2	#PC_BUFS,R4			; Include PC_BUFS in count of buffers
100$:
	ADDL3	CDB$L_COUNT(R6),#1,R9		; Compute number of data items per buffer
						; ... + 1 for buffer pointer	
	MULL2	#4,R9				; ... times 4 since items are longwords
	MULL2	R4,R9				; ... times # of buffers
	ADDL3	#COLL_BUFS*MNR_CLS$K_HSIZE,R9,CDB$L_BUFFERS(R6)	; Collection buffers need headers
	BSBB	80$				; Obtain the virtual memory
	BLBC	R0,GB_RSB			; Exit with error if failed

;
; Store values for the buffer pointers at the beginning of the buffer block
; just allocated.
;
; Register Usage:
;
;	R2  = size of most recent buffer
;	R3  = address of most recent buffer
;	R4  = number of buffers; later used as loop control
;	R5  = pointer into block of pointers 
;	R6  = CDB pointer
;	R10  = buffer block pointer
;
	MOVL	CDB$A_BUFFERS(R6),R5	; Store address of 1st pointer
	MOVL	R5,R10			; Remember buffer block addr for later MOVC5
	MULL2	#4,R4			; Compute address of ...
	ADDL3	R4,R5,R3		; ... 1st buffer
	MOVL	R3,(R5)+		; Move it into 1st pointer
	MULL3	#4,CDB$L_COUNT(R6),R2	; Calculate size of next buffer
	ADDL2	#MNR_CLS$K_HSIZE,R2	; Add in the header size
	MOVZBL	#COLL_BUFS,R4		; Loop COLL_BUFS times
110$:
	ADDL2	R2,R3			; Calculate address of next buffer
	MOVL	R3,(R5)+		; ... and store it into next pointer
	SOBGTR	R4,110$			; ....

	SUBL2	#MNR_CLS$K_HSIZE,R2	; Next group don't have headers
	MOVL	R2,R8			; Save size of a buffer for later MOVC5
	MOVZBL	#REG_BUFS-1,R4		; Loop REG_BUFS-1 times
120$:
	ADDL2	R2,R3			; Calculate address of next buffer
	MOVL	R3,(R5)+		; ... and store it into next pointer
	SOBGTR	R4,120$			; ....
	BBC	#CDB$V_PERCENT,CDB$L_FLAGS(R6),140$ ; If percent not requested, skip pc buffs
	MOVZBL	#PC_BUFS,R4		; Loop PC_BUFS times
130$:
	ADDL2	R2,R3			; Calculate address of next buffer
	MOVL	R3,(R5)+		; ... and store it into next pointer
	SOBGTR	R4,130$			; ....
	MOVC5	#0,.,#0,R8,@MBP$A_PCSUM(R10) ; Zero out PCSUM buffer
140$:
	MOVC5	#0,.,#0,R8,@MBP$A_SUM(R10) ; Zero out SUM buffer
GB_NRSB:				; Normal return point
	MOVL	NORMAL,R0		; Indicate successful status
GB_RSB:					; Error return point
	RSB				; Return

CLEAR_DATA:

;
; Initialize the DATA array to zero.
;
; Input Registers:
;
;	R2 = max process count
;	R6 = address of PROCESSES CDB
;
; Registers R0-R5 and R8,R9 are destroyed.
;
; The only output of this subroutine is that the
; DATA array is cleared to zeroes.
;

	MULL3	#4,R2,R8			; Calculate size of DATA array
	MOVL	CDB$A_BUFFERS(R6),R9		; Get buffer block pointer
	MOVL	MBP$A_DATA(R9),R9		; Get DATA array pointer
10$:
	CMPL	#32000,R8			; Is a large MOVC5 required?
	BGEQ	20$				; No -- go do a smaller one
	MOVC5	#0,.,#0,#32000,(R9)		; Yes -- clear 32000 bytes
	SUBL2	#32000,R8			; Calc bytes left to clear
	ADDL2	#32000,R9			; ... and starting byte addr
	BRB	10$				; Go check size of next move
20$:
	MOVC5	#0,.,#0,R8,(R9)			; Clear remainder of DATA array

	RSB					; Return

	.SBTTL	WRITE_PROC_RECORDS - Write PROCESSES class records

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to write out a group of class
;	records containing the data in a PROCESSES collection
;	buffer.
;
; CALLING SEQUENCE:
;
;	CALLS #2,WRITE_PROCS_RECORDS
;
; INPUTS:
;
;	4(AP) - address of collection buffer
;
;	8(AP) - longword size of a data block (for a single process)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	As many class records as are required are written to the 
;	recording file for this PROCESSES collection buffer.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or error status, if any
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	WRITE_PROC_RECORDS,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	4(AP),R7		; Get pointer to collection buffer
	MOVL	<MNR_CLS$K_HSIZE+MNR_PRO$L_PCTINT>(R7),R8
					; Get num of processes in coll buffer
	CMPL	W^PROCS_PER_REC,R8	; Need more than 1 class record?
	BLSS	10$			; Yes -- go break it up
	ALLOC	8,R1,R2			; No -- alloc a descriptor on stack
	MULL3	R8,8(AP),(R2)		; Calculate size of data area
	ADDL2	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,(R2)
					; Add in class hdr and PROCESSES prefix
	MOVL	R7,4(R2)		; Load addr of coll buff into descr
	PUSHL	R2			; Push descriptor address
	CALLS	#1,WRITE_RECORD		; ... and write the record
	BRW	WPR_RET			; Go return with status of WRITE_RECORD

;
; Break up collection buffer into a group of records and write
; each into the recording file. All except the last will have the 
; MNR_CLS$V_CONT flag set indicating that data for this interval
; continues in the next record.
;
;
; Register Usage:
;
;	R6 =  # of full records to write
;	R7 =  collection buffer index pointer
;	R8 =  # of processes in the collection buffer;
;		also, # of processes in the final record
;	R9 =  pointer to write buffer data area
;	R10 = size of data portion of write buffer
;	R11 = pointer to write buffer descriptor
;

10$:
	DIVL3	W^PROCS_PER_REC,R8,R6	; Get number of full records to write
	MULL3	W^PROCS_PER_REC,R6,R1	; Calculate # of procs in ...
	SUBL2	R1,R8			; ... final record
	MULL3	W^PROCS_PER_REC,8(AP),R10 ; Get size of data portion of write buff
	ADDL3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R10,R1
					; Compute write buffer size
	ALLOC	8,R0,R11		; Get a write buffer descr on stack
	MOVL	R1,(R11)		; Move in write buff size
	PUSHAL	4(R11)			; Push addr of write buffer ptr
	PUSHAL	(R11)			; Push addr of write buffer size
	CALLS	#2,G^LIB$GET_VM		; Get the write buffer
	BLBS	R0,20$			; Continue if status OK
	BRW	WPR_RET			; Return with status if failed
20$:
	MOVL	4(R11),R9		; Get ptr to write buffer
	MOVC3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,(R7),(R9)
					; Move class hdr & prefix to write buff
	ADDL2	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R7 ; Update coll buff ptr
	BBSS	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R9),30$ ; Set "continued" bit
30$:	ADDL2	#MNR_CLS$K_HSIZE,R9	; Point to PROCESSES prefix
	MOVL	W^PROCS_PER_REC,MNR_PRO$L_PCTREC(R9) ; Load # of procs this rec
	ADDL2	#MNR_PRO$K_PSIZE,R9	; Point to data portion of write buffer

;
; Loop until all processes which fit into full records
; have been handled. On each time through the loop, move
; PROCS_PER_REC processes from the collection buffer to
; the write buffer and write it out. The class header
; portion and the PROCESSES prefix portion of the write
; buffer will be identical for all these records.
;

40$:
	MOVC3	R10,(R7),(R9)		; Move group of procs from coll to write
	ADDL2	R10,R7			; Update coll buff ptr
	PUSHL	R11			; Stack ptr to write buffer descr
	CALLS	#1,WRITE_RECORD		; Write this record
	BLBC	R0,WPR_RET		; Go exit with status if failed
	SOBGTR	R6,40$			; Loop back to do next group
;
; Build and write a final record for the "leftover"
; processes which didn't fit into one of the full records.
;

	MOVL	4(R11),R1		; Get pointer to write buff class hdr
	BBCC	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R1),50$ ; Clear "continued" bit
50$:	ADDL2	#MNR_CLS$K_HSIZE,R1	; Point to PROCESSES prefix
	MOVL	R8,MNR_PRO$L_PCTREC(R1)	; Load # of procs in this record
	MULL3	8(AP),R8,R10		; Compute size of data portion
	TSTL	R10			; Any "leftover" data to write?
	BEQL	60$			; No -- skip around the MOVC3
	MOVC3	R10,(R7),(R9)		; Move leftovers from coll to write buff
60$:
	ALLOC	8,R0,R1			; Allocate a descr for the write
	MOVL	4(R11),4(R1)		; Get write buff ptr from previous descr
	ADDL3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R10,(R1)
					; Move write buff length into descr
	PUSHL	R1			; Stack descr ptr for write
	CALLS	#1,WRITE_RECORD		; Write the last record
	BLBC	R0,WPR_RET		; Leave with status if failed
;
; Free the virtual memory occupied by the write buffer
;

	PUSHAL	4(R11)			; Stack addr of write buffer ptr
	PUSHAL	(R11)			; Stack addr of write buffer len
	CALLS	#2,G^LIB$FREE_VM	; Free the write buffer memory
	BLBC	R0,WPR_RET		; Leave with status if failed
	MOVL	NORMAL,R0		; Indicate normal status
WPR_RET:
	RET				; Return with status

	.SBTTL	CVT_TO_DELTA - Convert Seconds to Delta

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to convert a positive seconds quantity
;	supplied in a longword to a quadword delta time quantity.
;
; CALLING SEQUENCE:
;
;	CALLS #2,CVT_TO_DELTA
;
; INPUTS:
;
;	4(AP) - address of longword containing positive seconds quantity
;
;	8(AP) - address of quadword in which to store converted delta time.
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	Quadword addressed by 8(AP) is loaded with converted delta time.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	CVT_TO_DELTA,	^M<>

	EMUL	#-10*1000*1000,@4(AP),#0,@8(AP) ; That's all, folks
	RET

	.SBTTL	COMPUTE_BOOTTIME - Compute System Time of Boot

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to compute the quadword time value
;	representing the absolute time at which the monitored
;	(running) system was booted. This is done by converting
;	the EXE$GL_ABSTIM value (absolute number of seconds since
;	boot) to a negative quadword system time value and adding
;	it to the current time (obtained via $GETTIM).
;
; CALLING SEQUENCE:
;
;	CALLS #0,COMPUTE_BOOTTIME
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	EXE$GL_ABSTIM - longword containing positive number of seconds
;			since boot.
;
;	SPTR - pointer to SYI (System Information Area).
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	MNR_SYI$Q_BOOTTIME loaded with boot time in system time units.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or failing system service status
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	COMPUTE_BOOTTIME,	^M<R2>

	ALLOC	8,R0,R2			; Get quadword on stack
	$GETTIM_S TIMADR=(R2)		; Put current time into it
	BLBC	R0,10$			; Exit if error
	EMUL	#-10*1000*1000,EXE$GL_ABSTIM,#0,R0
					; Get delta quadword system time units
					; ... since boot
	ADDL2	(R2),R0			; Add low-order current time
	ADWC	4(R2),R1		; ... and high-order current time
	MOVL	SPTR,R2			; Get pointer to SYI
	MOVQ	R0,MNR_SYI$Q_BOOTTIME(R2) ; Move in boot time
	MOVL	NORMAL,R0		; Indicate success
10$:
	RET				; Return

	.SBTTL	COLLECTION - Collect into CURRENT Buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to collect data for the current
;	class into the buffer pointed to by the CURRENT register
;	(R8). The data is obtained either from the running system
;	(live collection) or from an input recording file (playback).
;
; CALLING SEQUENCE:
;
;	BSBW	COLLECTION
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	4(AP) - address of byte containing class number
;
;	Registers:
;
;		R6  = CDB pointer
;		R7  = MRB pointer
;		R8  = CURRENT collection buffer pointer
;		R11 = MCA pointer
;
;		If non-STD class, R8 has to have been set up before
;		entry to this routine.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CURRENT buffer filled with data for this class.
;
;	On first collection event, MRB$Q_BEGINNING is loaded with
;	  the system time of the first collection.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or error status, if any
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;
;--

COLLECTION:

	BBC	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),20$ ; If not collecting from
					; ... a file, go do live collection

	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),10$ ; Branch if standard class
;
; PLAYBACK -- Non-standard Class (PROCESSES)
;
	BSBB	COLL_NONSTD		; Fill coll buff from playback file
	BLBC	R0,COLL_RSB		; Premature EOF error possible here
	BRB	COLL_COMM		; Go join common collection code

;
; PLAYBACK -- Standard Class
;
; Pick up (with MOVC5) the collection buffer previously placed in a 
; fixed location by the PL/I read routine.
;

10$:
	PUSHR	#^M<R9,R10>		; Save regs 9 and 10
	MOVL	MCA$A_INPUT_PTR(R11),R9	; Get base of read buffer
	ADDW3	#MNR_CLS$K_HSIZE,CDB$W_BLKLEN(R6),R10 ; Compute size of buffer
	MOVC5	MCA$L_INPUT_LEN(R11),(R9),#0,R10,(R8) ; Move to CURRENT buffer
	POPR	#^M<R9,R10>		; Restore regs 9 and 10
	BRB	COLL_COMM		; Go join common collection code

;
; LIVE COLLECTION
;
; Create argument list (on stack) for $CMKRNL call to FETCH.
;

20$:
	ADDL3	#MNR_CLS$K_HSIZE,R8,-(SP) ; Stack addr of beg of variable
					; ... portion of collection buffer
	PUSHL	R6			; Stack CDB address
	PUSHL	#2			; Top off list with arg count
	MOVL	SP,R4			; Remember arg list addr for $CMKRNL
;
; Fill collection buffer header
;
	MOVB	@4(AP),MNR_CLS$B_TYPE(R8) ; Collect class number into buffer
	CLRW	MNR_CLS$W_FLAGS(R8)	; Zero out flags ...
	CLRW	MNR_CLS$W_RESERVED(R8)	; ... and reserved word
	$CMKRNL_S  FETCH,(R4)		; Call FETCH to fill in rest of buffer

	ADDL	#12,SP			; Restore stack
	BLBC	R0,COLL_RSB		; NOPRIV error possible here

COLL_COMM:				; Common code for playback or live collection
	MOVL	NORMAL,R0		; Indicate successful status
	TSTL	MCA$L_COLLCNT(R11)	; First collection?
	BNEQ	COLL_RSB		; No -- just return
	CMPB	@4(AP),MCA$B_FIRSTC(R11) ; First class?
	BNEQU	COLL_RSB		; No -- just return
	MOVQ	MNR_CLS$Q_STAMP(R8),MRB$Q_BEGINNING(R7)
					; Yes -- save start time of collection
	BBC	#MRB$V_RECORD,MRB$W_FLAGS(R7),COLL_RSB ; Exit if not recording
	CALLS	#0,WRITE_HEADER		; Write recording file header

COLL_RSB:
	RSB				; Return

;
; Since the PROCESSES class can have class data which spans several 
; records, loop reading all PROCESSES records for this interval,
; concatenating the data portions of the records into the collection
; buffer.
;

COLL_NONSTD:

	PUSHR	#^M<R7,R8,R9,R10>	; Save registers
	MOVL	MCA$A_INPUT_PTR(R11),R9	; Get base of read buffer
	MOVC3	MCA$L_INPUT_LEN(R11),(R9),(R8) ; 1st class rec to CURRENT buffer
	BBC	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R9),30$ ; Done if only 1 class rec
	ADDL2	MCA$L_INPUT_LEN(R11),R8	; Point to end of coll buffer
	ADDL3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R9,R10
					; Point to PROCESSES data in read buff
	CLRL	R7			; Ensure high-order word is clear ...
					; ... for later use
;
; Read the next PROCESSES class record for this interval
;

10$:
	MOVL	#SKIP_TO_CLASS,-(SP)	; Indicate next class rec is desired
	PUSHL	SP			; Stack indicator for call
	CALLS	#1,READ_INPUT		; Read next class record
	ADDL2	#4,SP			; Pop stack
	BBC	#MCA$V_EOF,MCA$W_FLAGS(R11),20$ ; Continue if not end-of-file
	MOVL	#MNR$_PREMEOF,R0	; Else indicate error ...
	BRB	40$			; ... and go return
20$:
	ADDL3	#MNR_CLS$K_HSIZE,R9,R0	; Point to PROCESSES prefix in read buff
	MULW3	MNR_PRO$L_PCTREC(R0),CDB$W_BLKLEN(R6),R7
					; Calc size of next move
	MOVC3	R7,(R10),(R8)		; Next class rec to CURRENT buffer
	ADDL2	R7,R8			; Point to end of coll buffer
	BBS	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R9),10$ ; If cont, go read next
30$:
	MOVL	NORMAL,R0		; Indicate normal status
40$:
	POPR	#^M<R7,R8,R9,R10>	; Restore registers
	RSB				; Return


	.SBTTL	FILL_STATS_BUFF  -  Fill the STATS Buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to fill in the STATS buffer,
;	given the current and previous buffers. For COUNT-type
;	data items, each STATS item is computed as CURRENT minus
;	PREVIOUS; for LEVEL-type data items, each STATS item is
;	merely copied from CURRENT. This process may be viewed as
;	"levelizing" the counts.
;
; CALLING SEQUENCE:
;
;	BSBW FILL_STATS_BUFF
;
; INPUTS:
;
;	R6 =	address of CDB (Class Descriptor Block)
;
;	R8 =	address of CURRENT buffer
;
;	R9 =	address of PREVIOUS buffer
;
;	R10 =	address of buffer block
;
; IMPLICIT INPUTS:
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	STATS buffer is filled.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;
;--


FILL_STATS_BUFF:

	PUSHR	#^M<R11>		; Save reg 11
	MOVL	CDB$L_COUNT(R6),R0	; Get number of items to fetch
	MOVL	CDB$A_ITMSTR(R6),R1	; Address of item-number string
	ADDL3	#MNR_CLS$K_HSIZE,R9,R2	; Calc start of items for PREVIOUS
	ADDL3	#MNR_CLS$K_HSIZE,R8,R3	; Calc start of items for CURRENT
	MOVL	MBP$A_STATS(R10),R4	; Get pointer to STATS
	CLRL	R11			; Clear loop counter
10$:
	MOVZBL	(R1)+,R5		; Get next item number
	MULL	#IDB$K_ILENGTH,R5	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R5],R5	; Address of IDB for this item
	CASE	IDB$W_ISIZE(R5),<20$,30$,40$>,W ; Select on proper size

20$:
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BNEQ	25$			; No -- assume level type
	SUBB3	(R2)+,(R3)+,(R4)	; Compute byte diff into STATS buff
	MOVZBL	(R4),(R4)+		; Zero-extend to longword
	BRB	50$
25$:
	MOVZBL	(R3)+,(R4)+		; Move CURRENT byte level to STATS
	TSTB	(R2)+			; Auto-increment PREVIOUS buffer
	BRB	50$
30$:
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BNEQ	35$			; No -- assume level type
	SUBW3	(R2)+,(R3)+,(R4)	; Compute word diff into STATS buff
	MOVZWL	(R4),(R4)+		; Zero-extend to longword
	BRB	50$
35$:
	MOVZWL	(R3)+,(R4)+		; Move CURRENT word level to STATS
	TSTW	(R2)+			; Auto-increment PREVIOUS buffer
	BRB	50$
40$:
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BNEQ	45$			; No -- assume level type
	SUBL3	(R2)+,(R3)+,(R4)+	; Compute long diff into STATS buff
	BRB	50$
45$:
	MOVL	(R3)+,(R4)+		; Move CURRENT longword level to STATS
	TSTL	(R2)+			; Auto-increment PREVIOUS buffer
50$:
	AOBLSS	R0,R11,10$		; Loop until done
	POPR	#^M<R11>		; Restore reg 11
	RSB				; ... and return

	.SBTTL	FILL_PCSTATS_BUFF - Fill PCSTATS Buffer from STATS Buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Fill the PCSTATS buffer with integer values representing
;	tenths of percent for each item in the STATS buffer.
;
; INPUTS:
;
;	R6  - CDB pointer
;	R10 - Buffer block pointer
;
; IMPLICIT INPUTS:
;
;	STATS buffer containing levels to be "percentized."
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	PCSTATS buffer filled with integer values representing
;	tenths of percent.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0, R1, R3, R4 destroyed.
;--

FILL_PCSTATS_BUFF:

	MOVL	MBP$A_PCSTATS(R10),R3	; Load PCSTATS buffer pointer
	MOVL	MBP$A_STATS(R10),R4	; Load STATS buffer pointer
	MOVL	CDB$L_COUNT(R6),R0	; Get number of items
	CLRL	R1			; Clear accumulator
10$:
	ADDL2	(R4)+,R1		; Add next item
	SOBGTR	R0,10$			; Continue until STATS summed
	MOVL	MBP$A_STATS(R10),R4	; Re-load STATS buffer pointer
	MOVL	CDB$L_COUNT(R6),R0	; ... and number of items
	TSTL	R1			; Zero sum?
	BNEQ	30$			; No -- go calc percentages
20$:
	MOVL	(R4)+,(R3)+		; Yes -- simply move zeroes
	SOBGTR	R0,20$			; ... into PCSTATS buffer
	BRB	40$			; ... and go exit
30$:
	MULL3	#1000,(R4)+,(R3)	; Multiply value by 1000 ... and
	DIVL2	R1,(R3)+		; Divide by sum, leaving tenths of %
	SOBGTR	R0,30$			; Continue for all items
40$:
	RSB				; Return

	.SBTTL	COMPUTE_STATS - Statistical Computations on STATS

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Replace each count item in the STATS buffer with a computed
;	(floating-point) rate per second. Also, replace each item in
;	the MIN and MAX buffers with the corresponding item from the
;	STATS buffer if it establishes a new minimum or maximum value.
;	On the first entry to this routine (2nd collection), the MIN
;	and MAX buffers are initialized by simply copying the STATS
;	buffer into them.
;
; INPUTS:
;
;	R6  - CDB pointer
;	R7  - MRB pointer
;	R8  - CURRENT buffer pointer
;	R9  - PREVIOUS buffer pointer
;	R10 - Buffer block pointer
;	R11 - MCA pointer
;
; IMPLICIT INPUTS:
;
;	STATS buffer
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Each count item in STATS buffer converted to floating rate/second.
;
;	Items in MIN and MAX buffers updated if new min and max
;	values were achieved in the interval just completed.
;
;	MCA$L_INTTICKS loaded with integer representing number of
;	clock ticks (10-millisecond units) accumulated over the
;	interval just completed.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;--

COMPUTE_STATS:

	PUSHR	#^M<R8,R9>		; Save regs
	BBC	#CDB$V_CTPRES,CDB$L_FLAGS(R6),10$ ; Skip ticks calc if no counts
;
; Calculate MCA$L_INTTICKS (clock ticks during interval just finished)
;
	MOVQ	MNR_CLS$Q_STAMP(R8),R2	; Current system time to temp regs
	SUBL2	MNR_CLS$Q_STAMP(R9),R2	; Calc low-order in sys units
	SBWC	MNR_CLS$Q_STAMP+4(R9),R3 ; Calc high-order in sys units
	EDIV	#100000,R2,MCA$L_INTTICKS(R11),R2 ; Calc interval ticks (10ms units)
					     	 ; ... for use below
;
; Load registers for upcoming buffer manipulations
;

10$:
	MOVL	MBP$A_STATS(R10),R2	; Load addr of first STATS item
	MOVL	MBP$A_MIN(R10),R8	; Load addr of first MIN item
	MOVL	MBP$A_MAX(R10),R9	; Load addr of first MAX item
	MOVL	CDB$A_ITMSTR(R6),R0	; Load addr of item-number string
	MOVL	CDB$L_COUNT(R6),R3	; Load number of items in STATS
	CLRL	R1			; Clear loop counter
20$:
	BBC	#CDB$V_CTPRES,CDB$L_FLAGS(R6),30$ ; Skip type check if no counts
	MOVZBL	(R0)+,R5		; Get next item number
	MULL	#IDB$K_ILENGTH,R5	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R5],R5	; Address of IDB for this item
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BEQLU	50$			; Yes -- go compute rate
;
; Update MIN and MAX buffers for this item (level).
;

30$:
	CMPL	(R2)[R1],(R8)[R1]	; Check minimum
	BGEQ	40$			; Branch if not less
	MOVL	(R2)[R1],(R8)[R1]	; Else insert new minimum
40$:
	CMPL	(R2)[R1],(R9)[R1]	; Check maximum
	BLEQ	70$			; Branch if not more
	MOVL	(R2)[R1],(R9)[R1]	; Else insert new maximum
	BRB	70$			; ... and go loop
;
; Compute rate/second for this count item, replacing count in
; STATS buffer.
;

50$:
	CVTLF	(R2)[R1],R4		; Get floating value over interval
	CVTLF	MCA$L_INTTICKS(R11),R5	; Get floating ticks over interval
	DIVF2	#100,R5			; Get floating seconds over interval
	DIVF3	R5,R4,(R2)[R1]		; Floating rate/second into STATS
;
; Update MIN and MAX buffers for this item (count).
;

	CMPF	(R2)[R1],(R8)[R1]	; Check minimum
	BGEQ	60$			; Branch if not less
	MOVF	(R2)[R1],(R8)[R1]	; Else insert new minimum
60$:
	CMPF	(R2)[R1],(R9)[R1]	; Check maximum
	BLEQ	70$			; Branch if not more
	MOVF	(R2)[R1],(R9)[R1]	; Else insert new maximum
70$:
	AOBLSS	R3,R1,20$		; Loop for each item in STATS

;
; Initialize MIN and MAX buffers if first time through this routine
;

	CMPL	MCA$L_COLLCNT(R11),#1	; 2nd collection?
	BNEQ	80$			; No -- continue
	MULL	#4,R3			; Yes -- compute len of STATS buffer
	PUSHR	#^M<R2,R3>		; Save regs
	MOVC3	R3,(R2),(R8)		; Initialize MIN buffer
	POPR	#^M<R2,R3>		; Restore regs
	MOVC3	R3,(R2),(R9)		; Initialize MAX buffer
80$:
	POPR	#^M<R8,R9>		; Restore regs
	RSB				; Return

	.SBTTL	UPD_PC_MIN_MAX - Update Percent Min/Max Buffers

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Replace each item in the PCMIN and PCMAX buffers with the
;	corresponding item from the PCSTATS buffer if it establishes
;	a new minimum or maximum value. On the first entry to this
;	routine (2nd collection), the PCMIN and PCMAX buffers are
;	initialized by simply copying the PCSTATS buffer into them.
;
; CALLING SEQUENCE:
;
;	BSBW UPD_PC_MIN_MAX
;
; INPUTS:
;
;	R6  - CDB pointer
;	R10 - Buffer block pointer
;	R11 - MCA pointer
;
; IMPLICIT INPUTS:
;
;	PCSTATS buffer containing percent values derived from
;	most recently collected levels.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Items in PCMIN and PCMAX buffers updated accordingly.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;--


UPD_PC_MIN_MAX:

	MOVL	MBP$A_PCSTATS(R10),R3	; Load PCSTATS ptr
	MOVL	MBP$A_PCMIN(R10),R4	; Load PCMIN ptr
	MOVL	MBP$A_PCMAX(R10),R5	; Load PCMAX ptr
	MOVL	CDB$L_COUNT(R6),R0	; Get item count
	CLRL	R2			; Clear loop counter

;
; Initialize PCMIN and PCMAX buffers if first time through this routine
;

	CMPL	MCA$L_COLLCNT(R11),#1	; 2nd collection?
	BNEQ	10$			; No -- continue
	MULL	#4,R0			; Yes -- compute len of PCSTATS buffer
	PUSHR	#^M<R0,R3,R5>		; Save regs
	MOVC3	R0,(R3),(R4)		; Initialize PCMIN buffer
	POPR	#^M<R0,R3,R5>		; Restore regs
	MOVC3	R0,(R3),(R5)		; Initialize PCMAX buffer
	BRB	40$			; Go return
;
; Replace minimum and maximum (if necessary) for each item
;

10$:
	CMPL	(R3)[R2],(R4)[R2]	; Check minimum
	BGEQ	20$			; Branch if not less
	MOVL	(R3)[R2],(R4)[R2]	; Else insert new minimum
20$:
	CMPL	(R3)[R2],(R5)[R2]	; Check maximum
	BLEQ	30$			; Branch if not more
	MOVL	(R3)[R2],(R5)[R2]	; Else insert new maximum
30$:
	AOBLSS	R0,R2,10$		; Loop for each item in PCSTATS
40$:
	RSB				; Return

	.SBTTL	DISPLAY_INIT - Init for Display Output

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs initialization for DISPLAY output.
;
; CALLING SEQUENCE:
;
;	CALLS #0, DISPLAY_INIT
;
; INPUTS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;
; OUTPUTS:
;
;	BARCHAR loaded with appropriate bar character.
;
;	SYSOUT_TYPE loaded with display output device class.
;
;		The four classes are:
;
;			DEC_CRT
;			VT5X
;			OTHER_VID
;			HARDCOPY (including disk file)
;
;	MCA$V_VIDEO set if display device is a video terminal.
;
;	MCA$V_GRAPHICS set if display device is a VT55.
;
;	ATTRIBMSK (DEC_CRT video attribute mask) cleared.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL or failing status from SCRPKG routine.
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R7   = MRB pointer
;	R11  = MCA pointer
;
;--


.ENTRY	DISPLAY_INIT,	^M<R2,R3,R7,R11>

	CLRL	W^ATTRIBMSK		; Turn off DEC_CRT attributes
	MOVL	MRBPTR,R7		; Load MRB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	BSBW	COMMON_INIT		; Do initialization common with SUMMARY

;
; Establish SCRPKG output stream
;

	TSTL	MRB$A_DISPLAY(R7)	; Is there a display file-spec?
	BEQL	10$			; No -- continue
	PUSHL	MRB$A_DISPLAY(R7)	; Yes -- stack it for SET_OUTPUT
	PUSHL	#1			; ... along with a stream identifier
	CALLS	#2,G^SCR$SET_OUTPUT	; Establish output stream
	BLBS	R0,10$			; Continue if status OK
	BRW	110$			; Go exit if SCR$SET_OUTPUT failed

;
; Establish bar character, sysout device type.
;
; Set MCA$V_VIDEO bit if a video terminal.
;
; Set MVA$V_GRAPHICS if a VT55 terminal.
;

10$:
	MOVB	#DEF_BAR,W^BARCHAR	; Start out with default bar char
	MOVB	#OTHER_VID,W^SYSOUT_TYPE ; ... and assume "other video" sysout type
	ALLOC	9,R1,R2			; Allocate 9 bytes for screen info
	PUSHL	R2			; Stack addr of screen info buffer
	CALLS	#1,G^SCR$SCREEN_INFO	; Get screen info (dev type)
	BLBS	R0,20$			; Continue if status OK
	BRW	110$			; Go exit if SCR$SCREEN_INFO failed
20$:
	MOVB	SCR$B_DEVTYPE(R2),R3	; Save SYS$OUTPUT device type
	BBC	#SCR$V_SCREEN,SCR$L_FLAGS(R2),30$ ; If not video, keep going
	BBSS	#MCA$V_VIDEO,MCA$W_FLAGS(R11),40$ ; Otherwise, indicate video
	BRB	40$			; ... and continue
30$:
	MOVB	#HARDCOPY,W^SYSOUT_TYPE	; Set hardcopy type
	BRB	100$			; ... and go take def bar char
40$:
	CMPB	#DT$_VT55,R3		; Is it a VT55 ?
	BNEQU	60$			; No -- go check for other types
	BBSS	#MCA$V_GRAPHICS,MCA$W_FLAGS(R11),50$
					; Yes -- indicate VT55-style graphics
50$:
	MOVB	#VT5X,W^SYSOUT_TYPE	; Indicate VT5x series
	BRB	90$			; Go set special bar char
60$:	BBC	#SCR$V_DECCRT,SCR$L_FLAGS(R2),70$ ; If not DEC CRT, keep going
	MOVB	#DEC_CRT,W^SYSOUT_TYPE	; Set DEC CRT
	BRB	90$			; ... and go set special bar char
70$:	CMPB	#DT$_VT100,R3		; Is it a VT100 ?
	BNEQU	80$			; No -- more checking
	MOVB	#DEC_CRT,W^SYSOUT_TYPE	; Yes -- set DEC CRT
	BRB	90$			; ... and go set special bar char
80$:
	CMPB	#DT$_VT52,R3		; Is it a VT52 ?
	BNEQU	100$			; No -- take def bar char and type
	MOVB	#VT5X,W^SYSOUT_TYPE	; Yes -- indicate VT5x series
90$:	MOVB	#VID_BAR,W^BARCHAR	; Indicate special bar char

100$:
	MOVB	W^BARCHAR,W^TOPBAR	; Move bar char into TOP display line

;
; Kick off buffering mode for the Screen Package
;

	PUSHAQ	SCRDSC			; Push this routine's buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode
110$:
	RET				; Return with R0 = status

	.SBTTL	SUMMARY_INIT - Init for Summary Output

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs initialization for SUMMARY output.
;
; CALLING SEQUENCE:
;
;	CALLS #0, SUMMARY_INIT
;
; INPUTS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
; OUTPUTS:
;
;	BARCHAR loaded with appropriate bar character.
;
;	SYSOUT_TYPE loaded with display output device type.
;
;	ATTRIBMSK (DEC_CRT video attribute mask) cleared.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL or failing status from SCRPKG routine.
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R7   = MRB pointer
;
;--


.ENTRY	SUMMARY_INIT,	^M<R7>

	CLRL	W^ATTRIBMSK		; Turn off DEC_CRT attributes
	MOVL	MRBPTR,R7		; Load MRB pointer
	BBS	#MRB$V_DISPLAY,MRB$W_FLAGS(R7),10$ ; Skip init if already done
	BSBW	COMMON_INIT		; Do initialization common with DISPLAY

;
; Establish SCRPKG output stream
;

10$:
	PUSHL	MRB$A_SUMMARY(R7)	; Stack SUMMARY filespec for SET_OUTPUT
	PUSHL	#1			; ... along with a stream identifier
	CALLS	#2,G^SCR$SET_OUTPUT	; Establish output stream
	BLBS	R0,20$			; Continue if status OK
	BRW	40$			; Go exit if SCR$SET_OUTPUT failed

;
; Establish bar character, sysout device type.
;

20$:
	MOVB	#DEF_BAR,W^BARCHAR	; Use default bar character
	MOVB	#DEF_BAR,W^TOPBAR	; ... also for TOP display line
	MOVB	#HARDCOPY,SYSOUT_TYPE	; Treat SYS$OUTPUT dev type as hardcopy
	BBSS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R7),30$
					; Indicate output to file
30$:

;
; Kick off buffering mode for the Screen Package
;

	PUSHAQ	SCRDSC			; Push this routine's buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode
40$:
	RET				; Return with R0 = status

COMMON_INIT:

;
; Do initialization for DISPLAY and SUMMARY options.
;

	MOVL	#SS$_NORMAL,W^PTS_STAT	; Start off request with clean status

;
; Set up footing display line with appropriate words
;

	MOVAL	W^BLANK_STR,W^FOOTP	; Indicate blank string for PLAYBACK
	BBC	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),10$ ; Continue if no PLAYBACK
	MOVAL	W^PLAY_STR,W^FOOTP	; Indicate PLAYBACK string in footing
10$:
	MOVAL	W^BLANK_STR,W^FOOTS	; Indicate blank string for SUMMARY
	BBC	#MRB$V_SUMMARY,MRB$W_FLAGS(R7),20$ ; Continue if no SUMMARY
	MOVAL	W^SUMM_STR,W^FOOTS	; Indicate SUMMARY string in footing
20$:
	MOVAL	W^BLANK_STR,W^FOOTR	; Indicate blank string for RECORD
	BBC	#MRB$V_RECORD,MRB$W_FLAGS(R7),30$ ; Continue if no RECORD
	MOVAL	W^REC_STR,W^FOOTR	; Indicate RECORD string in footing
30$:
	RSB				; Return

	.SBTTL	FILL_DISP_BUFF - Fill Display Buffer 

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to fill the display buffer with values
;	to be presented to FAOL for display of the screen for the current
;	class. The address of the CDB for the current class is passed
;	as the first parameter to this routine. The second parameter is
;	the address of a quadword into which this routine will store the
;	time stamp from the most recent collection buffer.
;
; CALLING SEQUENCE:
;
;	CALLS #2,FILL_DISP_BUFF
;
; INPUTS:
;
;	 4(AP) - address of a pointer to the CDB (Class Descriptor Block)
;		 for the class to display.
;
;	 8(AP) - address of quadword in which to store the time
;		 stamp from the most recent collection buffer.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
;
;	FAOSTK - buffer into which to store values for later FAOL call.
;
; OUTPUTS:
;
;	Quadword pointed to by 8(AP) is filled with time stamp from
;	most recent collection buffer.
;
; IMPLICIT OUTPUTS:
;
;	Display buffer (FAOSTK) buffer is filled.
;
;	For the non-standard class (PROCESSES),
;	MCA$L_PROC_DISP is filled with the count
;	of processes to display.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R5 = pointer to current longword in FAOSTK
;	R6 = address of CDB for class to display
;	R7 = scratch
;	R10 = address of buffer block
;	R11 = MCAPTR
;
;	Other registers: see below
;
;--


.ENTRY	FILL_DISP_BUFF,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	MOVL	CDB$A_BUFFERS(R6),R10	; Load address of buffer block

;
; Return time stamp from most recent collection buffer to caller.
;

	MOVL	MBP$A_BUFFERA(R10),R9	; Assume BufferA is current
	BBC	#CDB$V_SWAPBUF,CDB$L_FLAGS(R6),10$ ; Br if so
	MOVL	MBP$A_BUFFERB(R10),R9	; BufferB is current
10$:
	MOVQ	MNR_CLS$Q_STAMP(R9),@8(AP) ; Give current time stamp to caller

	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),20$ ; Branch if non-standard class
	BRW	FDB_STD			; Go process standard class

20$:					; Non-standard class (PROCESSES)
	CMPB	CDB$B_ST(R6),#REG_PROC	; Regular PROCESSES display?
	BEQL	FDB_REGPROC		; Yes -- go fill display buffer for it
					; No -- TOP PROCESSES display

;
; Calculate the two quantites BPU and GMIN for use later in computing
; the size of the bar graph:
;
;	BPU  - floating longword, no of bar chars per unit of output value
;	GMIN - integer longword, min value which graph can represent for this class
;

	BBS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),30$ ; Check for percent requested
	CVTLF	CDB$L_RANGE(R6),R7	; No percent -- get floating range for graph
	MOVL	CDB$L_MIN(R6),GMIN	; Get minimum value for graph
	BRB	40$			; Join common code
30$:
	CVTLF	#100,R7			; 100 is range of percent graph
	CLRL	GMIN			; 0 is min value of percent graph
40$:
	CVTBF	#MAXBARS,R8		; Get max bar chars per line
	DIVF3	R7,R8,BPU		; Calculate bar chars per unit of output

	PUSHL	R6			; Stack PROCESSES CDB pointer
	CALLS	#1,FILL_TOP		; Fill display buffer for TOP display
	BRW	FDB_RET			; ... and go return

;
; Fill display buffer for non-standard class (PROCESSES)
; (regular display).
;
; Register usage:
;
;	R2 = process index
;	R3 = process count
;	R5 = pointer to current longword in FAOSTK
;	R6 = address of CDB for class to display
;	R7 = scratch
;	R9 = CURRENT collection buffer
;	R10 = address of buffer block
;	R11 = MCAPTR
;

FDB_REGPROC:

	ADDL2	#MNR_CLS$K_HSIZE,R9	; Point to PROCESSES prefix
	MOVL	MNR_PRO$L_PCTINT(R9),R3	; Get process count
	MOVL	R3,MCA$L_PROC_DISP(R11)	; ... and save it for the display rtn
	ADDL2	#MNR_PRO$K_PSIZE,R9	; Point to first data block
	MOVL	#1,R2			; Init loop counter
	MOVL	MBP$A_BUFFERB(R10),R5	; Init FAO stack (display buffer) pointer

;
; Move individual items for this process from current data block
; in collection buffer to longwords in FAO stack.

10$:
	MOVL	MNR_PRO$L_PID(R9),(R5)+	; PID to FAO stack
	MOVZWL	MNR_PRO$L_UIC+2(R9),(R5)+ ; Group to FAO stack
	MOVZWL	MNR_PRO$L_UIC(R9),(R5)+	; Member to FAO stack
	MOVZWL	MNR_PRO$W_STATE(R9),R7	; Get state number
	MOVL	STATELIST[R7],(R5)+	; State cstring ptr to FAO stack
	MOVZBL	MNR_PRO$B_PRI(R9),R7	; Get priority (31's complement)
	SUBL3	R7,#31,(R5)+		; Complement it and move to FAO stack
	MOVQ	MNR_PRO$O_LNAME(R9),(R5)+ ; Process name cstring to FAO stack
	MOVQ	MNR_PRO$O_LNAME+8(R9),(R5)+ ; .....
	MOVZBL	-16(R5),(R5)+		; Length of process name to FAO stack
	SUBL3	#19,R5,(R5)+		; Address of process name to FAO stack
	MOVZWL	MNR_PRO$W_GPGCNT(R9),(R5)+ ; Global page count to FAO stack
	ADDW3	MNR_PRO$W_GPGCNT(R9),MNR_PRO$W_PPGCNT(R9),R7
					; Get sum of global & process page cnts
	MOVZWL	R7,(R5)+		; ... and move to FAO stack
	BBS	#PCB$V_RES,MNR_PRO$L_STS(R9),20$ ; Br if process was resident
	ADDL2	#16,R5			; Process non-res; skip next 4 longwords
	CLRL	(R5)+			; Clear CPUTIM ptr to indicate non-res
	BRB	30$			; ... and continue
20$:					; Resident process
	MOVL	MNR_PRO$L_DIOCNT(R9),(R5)+   ; DIO count to FAO stack
	MOVL	MNR_PRO$L_PAGEFLTS(R9),(R5)+ ; Page fault count to FAO stack
	EMUL	#100000,MNR_PRO$L_CPUTIM(R9),#0,(R5)+
					; Xlate ticks to quad time val & move to FAO stack
	SUBL3	#8,R5,(R5)+		; ... and move ptr to it into FAO stack
30$:
	ADDL2	#MNR_PRO$K_DSIZE,R9	; Point to next (process) data block in coll buffer
	ACBL	R3,#1,R2,10$		; Loop to move next process to FAO stack
	BRW	FDB_RET			; All processes done ... go return

;
; Fill display buffer (FAOSTK) for standard classes.
;
; Register usage:
;
;	R0 = address of current item number
;	R1 = number of data items in this class
;	R2 = data item index
;	R3 = address of statistics buffer from buffer block
;	R4 = address of IDB for current data item
;	R5 = pointer to current longword in FAOSTK
;	R6 = address of CDB for class to display
;	R7 = scratch
;	R8 = statistic code (ALL =0, CUR=1, AVE=2, MIN=3, MAX=4)
;	R9 = scratch
;	R10 = address of buffer block
;	R11 = MCAPTR
;

FDB_STD:

	MOVAL	FAOSTK,R5		; Load addr of display buffer
	MOVZBL	CDB$B_ST(R6),R8		; Load requested statistic

;
; If single statistic (not ALL) requested, calculate and store two quantities
; for later use:
;
;	BPU  - floating longword, no of bar chars per unit of output value
;	GMIN - integer longword, min value which graph can represent for this class
;

	CMPL	R8,#ALL_STAT		; ALL requested?
	BEQL	30$			; Yes -- continue	
	BBS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),10$ ; No -- check for percent requested
	CVTLF	CDB$L_RANGE(R6),R0	; No percent -- get floating range for graph
	MOVL	CDB$L_MIN(R6),GMIN	; Get minimum value for graph
	BRB	20$			; Join common code
10$:
	CVTLF	#100,R0			; 100 is range of percent graph
	CLRL	GMIN			; 0 is min value of percent graph
20$:
	CVTBF	#MAXBARS,R1		; Get max bar chars per line
	DIVF3	R0,R1,BPU		; Calculate bar chars per unit of output
	CMPL	R8,#AVE_STAT		; Was AVERAGE stat requested?
	BNEQ	40$			; No -- skip following calculation

;
; If AVERAGE or ALL statistic requested, calculate floating elapsed
; seconds from start of monitor request to time of most recent collection
; event. Store it on the stack for later use.
;

30$:
	MOVL	MRBPTR,R7		; Get temp pointer to MRB
	MOVL	MNR_CLS$Q_STAMP+4(R9),R1 ; Get high order bits of time
	SUBL3	MRB$Q_BEGINNING(R7),MNR_CLS$Q_STAMP(R9),R0 ; Compute elapsed time since start
	SBWC	MRB$Q_BEGINNING+4(R7),R1 ; Get high order difference
	EDIV	#10000,R0,R0,R1		; Turn time into milliseconds
	CVTLF	R0,R0			; Floating milliseconds
	DIVF3	#1000,R0,-(SP)		; Save floating seconds on stack for later use
					; Note -- will reference it as 4(SP) in subr.

;
; Loop once for each item in this class. Pick up transformed value for
; desired statistic from appropriate buffer within collection buffer
; block. Do computation on transformed value if required, and place
; whole and fractional portions of result into display buffer (FAOSTK).
;

40$:
	SUBL3	#1,CDB$L_COUNT(R6),R1	; Get number of items to examine (loop limit)
	MOVL	CDB$A_ITMSTR(R6),R0	; Address of item-number string
	CLRL	R2			; Clear item index register
FDB_BEG:
	MOVZBL	(R0)+,R4		; Get next item number
	MULL2	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	CASE	R8,<F_ALL,F_CUR,F_AVE,F_MIN,F_MAX>,L ; Select on requested statistic

F_ALL:
F_CUR:
	BBS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_STATS(R10),R3	; Load addr of STATS buffer
	BSBW	INTORFL			; Process an integer or floating value
	BRB	20$			; ... and continue
10$:
	MOVL	MBP$A_PCSTATS(R10),R3	; Load addr of PCSTATS buffer
	MOVL	(R3)[R2],R9		; Load tenths of % value
	BSB	PCTEN			; Process a tenths of % value
20$:
	TSTL	R8			; Was ALL statistic requested?
	BNEQ	COMMON			; No -- join common code
					; Yes -- continue to AVE
F_AVE:
	BBS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_SUM(R10),R3	; Load addr of SUM buffer
	BSB	INTAVE			; Process an integer average value
	BRB	20$			; ... and continue
10$:
	MOVL	MBP$A_PCSUM(R10),R3	; Load addr of PCSUM buffer
	SUBL3	#1,MCA$L_COLLCNT(R11),R7 ; Get no of colls, don't count 1st
	DIVL3	R7,(R3)[R2],R9		; Get average tenths % value
	BSB	PCTEN			; ... and process it
20$:
	TSTL	R8			; Was ALL statistic requested?
	BNEQ	COMMON			; No -- join common code
					; Yes -- continue to MIN
F_MIN:
	BBS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_MIN(R10),R3	; Load addr of MIN buffer
	BSBW	INTORFL			; Process an integer or floating value
	BRB	20$			; ... and continue
10$:
	MOVL	MBP$A_PCMIN(R10),R3	; Load addr of PCMIN buffer
	MOVL	(R3)[R2],R9		; Load tenths of % value
	BSB	PCTEN			; Process a tenths of % value
20$:
	TSTL	R8			; Was ALL statistic requested?
	BNEQ	COMMON			; No -- join common code
					; Yes -- continue to MAX
F_MAX:
	BBS	#CDB$V_PERCENT,CDB$L_FLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_MAX(R10),R3	; Load addr of MAX buffer
	BSB	INTORFL			; Process an integer or floating value
	BRB	COMMON			; ... and continue
10$:
	MOVL	MBP$A_PCMAX(R10),R3	; Load addr of PCMAX buffer
	MOVL	(R3)[R2],R9		; Load tenths of % value
	BSB	PCTEN			; Process a tenths of % value

COMMON:					; Common return point from CASE

	ACBL	R1,#1,R2,FDB_BEG	; Loop once for each item

FDB_RET:
	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

;
; PCTEN - Transform an integer tenths of percent value to a whole integer
;		percent value and an optional integer tenths "remainder"
;		value. Place result(s) in display buffer (FAOSTK).
;
;		R2 = data item index
;		R3 = address of source statistics buffer
;		R5 = address of current longword in display buffer
;		R7 = scratch
;		R8 = code for requested statistic
;		R9 = tenths of % value (input)
;

PCTEN:
	DIVL3	#10,R9,(R5)+		; Compute whole percent value
	TSTL	R8			; Requested ALL statistics?
	BEQL	10$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	20$			; ... and get out
10$:
	MULL3	#10,-4(R5),R7		; Need fraction for tabular display
	SUBL3	R7,R9,(R5)+		; Into display buffer
20$:
	RSB

;
; INTAVE - Transform an integer sum of level values or counts into an
;		average size/collection or rate/second. Place whole
;		and optional fractional parts into display buffer (FAOSTK).
;
;		R2 = data item index
;		R3 = address of source statistics buffer
;		R4 = address of IDB for current item
;		R5 = address of current longword in display buffer
;		R7 = scratch
;		R8 = code for requested statistic
;		R9 = scratch
;	       4(SP) = floating seconds from start of monitor request to
;			most recent collection event.
;

INTAVE:
	CVTLF	(R3)[R2],R7		; Get floating sum
	CMPW	IDB$W_TYPE(R4),#COUNT_TYPE ; This item a count?
	BNEQ	10$			; No -- assume level type
	DIVF	4(SP),R7		; Yes -- get floating avg rate/second
	BRB	20$			; ... and continue
10$:
	SUBL3	#1,MCA$L_COLLCNT(R11),R9 ; Get no of colls, don't count 1st
	CVTLF	R9,R9			; Get floating no of collections
	DIVF	R9,R7			; Compute floating avg size/collection
20$:
	CVTFL	R7,(R5)+		; Stack whole part for fao
	TSTL	R8			; Requested ALL statistics?
	BEQL	30$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	40$			; ... and get out
30$:
	CVTLF	-4(R5),R9		; Get back truncated part
	SUBF	R9,R7			; Compute fraction to two ...
	MULF	#100,R7			; ... digits for tabular display
	CVTFL	R7,(R5)+		; Stack fraction for fao
40$:
	RSB


;
; INTORFL - Place whole and optional fractional parts of integer value
;		(level) or floating rate/second value (count) into
;		display buffer (FAOSTK). 
;
;		R2 = data item index
;		R3 = address of source statistics buffer
;		R4 = address of IDB for current item
;		R5 = address of current longword in display buffer
;		R7 = scratch
;		R8 = code for requested statistic
;		R9 = scratch
;

INTORFL:
	CMPW	IDB$W_TYPE(R4),#COUNT_TYPE ; Is this item a count?
	BEQL	20$			; Br if yes
	MOVL	(R3)[R2],(R5)+		; Move level value to disp buffer
	TSTL	R8			; ALL statistics requested?
	BEQL	10$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	40$			; ... and get out
10$:
	CLRL	(R5)+			; Stack fractional part
	BRB	40$			; ... and exit
20$:
	CVTFL	(R3)[R2],(R5)+		; Stack whole part of rate (for count)
	TSTL	R8			; ALL statistics requested?
	BEQL	30$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	40$			; ... and get out
30$:
	CVTLF	-4(R5),R7		; Get back rounded part
	SUBF3	R7,(R3)[R2],R9		; Compute fraction
	MULF	#100,R9			; ... to two digits
	CVTFL	R9,(R5)+		; Stack fractional part
40$:
	RSB				; Return to caller

;
; CALC_BAR - Replace integer longword value in display buffer with three
;		longwords representing the width of a field to display
;		the value (0 or 7), the value, and the number of bar
;		characters needed to represent the value in a bar graph.
;
;	Register Inputs:
;
;		R5 = address of current longword in display buffer;
;		     will be updated to next available longword on output
;		R7 = scratch
;		R9 = scratch
;
;	Implicit Inputs:
;
;		GMIN - Integer longword, min value for graph
;		BPU  - Floating longword, bar chars per unit of value
;


;
; This subroutine creates 3 longwords in the FAOSTK array for the current
; data item. The current item is represented by a longword integer value
; which will be displayed to the left of the bar in the bar graph for
; the current class. The current item has already been placed in the
; display buffer by the calling routine; R5 has already been advanced to
; the next available longword. This subroutine must replace the value
; longword in the display buffer (FAOSTK) with 3 longwords, leaving R5
; pointing to the next available longword. The three longwords are:
; width of value field (0 or 7), value, and number of bar characters
; needed to represent the value. The number of bargraph characters is
; computed in floating point and then truncated.                       
;                                                                               

CALC_BAR:

	CLRL	R7			; Assume value field width will be 0          
	MOVL	-4(R5),(R5)		; Move value ahead in display buffer
	BEQL	10$			; If value zero, go move 0 field width 
	MOVZBL	#7,R7			; Value is non-zero; field width is 7
10$:                                                                            
	MOVL	R7,-4(R5)		; Move value field width into display buffer
;
; Now calculate number of bars to output
;
	CLRL	R7			; Assume no bars will be output
	SUBL3	GMIN,(R5)+,R9		; Calc units of value to output and ...
					; ... advance R5 to "no of bars" longword
	BLEQ	20$			; Output no bars if leq zero
	CVTLF	R9,R9			; Convert units to floating
	MULF2	BPU,R9			; Bars/unit * units => bars to output
	CVTFL	R9,R7			; Integer number to output
	CMPL	#MAXBARS,R7		; Check for upperbound
	BGEQ	20$			; Continue if within range
	MOVL	#MAXBARS,R7		; Else make it within range
20$:
	MOVL	R7,(R5)+		; Move number of bars to display buffer ...
					; ... and advance R5 to next longword
	RSB				; Return to caller

	.SBTTL	FILL_TOP - Fill Display Buffer for TOP PROCESSES

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Calculates the TOP 8 PROCESSES since the last display
;	event, and fills the display buffer (FAOSTK) with data
;	for later display.
;
; INPUTS:
;
;	 4(AP) - CDB (Class Descriptor Block) pointer
;		 for the PROCESSES class.
;
; IMPLICIT INPUTS:
;
;	FAOSTK - FAO parameter list for a TOP screen
;	MCAPTR - Pointer to MCA (Monitor Communication Area)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire display buffer (FAOSTK) filled with data for
;	eventual display.
;
;	TOP_PROCS byte filled with number of TOP processes
;	(with non-zero values) to display.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	none
;
; REGISTER USAGE:
;
;	R2  = Addr of DATA array
;	R3  = Addr of DIFF array
;	R4  = Addr of ORDER array
;	R5  = Addr of PID array
;	R6  = Addr of ADDR array
;	R7  = Pointer to collection buffer data block
;	R8  = Process index (PIX) for current data block
;	R9  = Current process index (from 0 to MNR_SYI$W_MAXPRCCT)
;	R10 = Number of data blocks (processes) in coll buff
;	R11 = Pointer to monitored data item in coll buff data block;
;	      Also, Max process count (from MNR_SYI$W_MAXPRCCT)
;--

.ENTRY	FILL_TOP, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	4(AP),R1		; Load CDB pointer
	MOVZBL	CDB$B_ST(R1),R11	; Get PROCESSES display type code
	CASE	R11,<REG,TOPC,TOPD,TOPB,TOPF>,W ; Go set offset based on type
	BRB	TOPC			; If out of range, do a TOPCPU

REG:					; Regular PROCESSES display (should not get)
TOPC:					; TOPCPU display
	MOVL	#MNR_PRO$L_CPUTIM,R11	; Get offset into PROCESSES data block
	BRB	FT_CASE			; Join common code
TOPD:					; TOPDIO display
	MOVL	#MNR_PRO$L_DIOCNT,R11	; Get offset into PROCESSES data block
	BRB	FT_CASE			; Join common code
TOPB:					; TOPBIO display
	MOVL	#MNR_PRO$L_BIOCNT,R11	; Get offset into PROCESSES data block
	BRB	FT_CASE			; Join common code
TOPF:					; TOPFAULT display
	MOVL	#MNR_PRO$L_PAGEFLTS,R11	; Get offset into PROCESSES data block

FT_CASE:				; Common CASE return

	MOVL	CDB$A_BUFFERS(R1),R1	; Load buffer block ptr
	MOVL	MBP$A_BUFFERA(R1),R7	; Load collection buffer ptr

;
; If not first TOP display event, calculate TOP_TICKS (the
; number of clock ticks (10ms units) since previous entry
; to FILL_TOP.
;

	MOVL	MCAPTR,R2		; Get MCA pointer
	BBC	#MCA$V_TOP_DISP,MCA$W_FLAGS(R2),5$
					; Skip TOP_TICKS calc if 1st time thru
	MOVQ	MNR_CLS$Q_STAMP(R7),R2	; Current system time to temp regs
	SUBL2	W^TOP_TIME,R2		; Calc low-order in sys units
	SBWC	W^TOP_TIME+4,R3		; Calc high-order in sys units
	EDIV	#100000,R2,W^TOP_TICKS,R2 ; Calc interval ticks (10ms units)
					  ; ... for use in MOVE_TOP8 rtn below
5$:
	MOVQ	MNR_CLS$Q_STAMP(R7),W^TOP_TIME ; Save curr time for next disp event

;
; Set up array pointers in preparation for calculations of difference
; values for each process for the monitored item over the last interval.
;

	MOVL	MBP$A_DATA(R1),R2	; Load DATA array ptr
	MOVL	MBP$A_DIFF(R1),R3	; Load DIFF array ptr
	MOVL	MBP$A_ORDER(R1),R4	; Load ORDER array ptr
	MOVL	MBP$A_PID(R1),R5	; Load PID array ptr
	MOVL	MBP$A_ADDR(R1),R6	; Load ADDR array ptr

	ADDL2	#MNR_CLS$K_HSIZE,R7	; Point to PROCESSES class prefix
	MOVL	MNR_PRO$L_PCTINT(R7),R10 ; Get no. of procs in this coll buffer
	ADDL2	#MNR_PRO$K_PSIZE,R7	; Point to first data block
	ADDL2	R7,R11			; ... and to first monitored data item

	MOVL	#-1,R9			; Init process index

10$:
	MOVZWL	MNR_PRO$L_PID(R7),R8	; Get process index from next process
					; ... in collection buffer
20$:
	INCL	R9			; Get next process index
	CMPL	R9,R8			; Any process slots not in coll buff?
	BGEQ	30$			; No -- go process this one
	CLRL	(R3)[R9]		; Yes -- clear DIFF array for this index
	BRB	20$			; Loop back to check next index
30$:
	CMPL	(R5)[R8],MNR_PRO$L_PID(R7) ; Same process as last time?
	BNEQU	40$			; No -- go zero out DIFF
	TSTL	(R11)			; Zero data item => swapped out
	BEQL	40$			; Swapped out -- go zero out DIFF
	TSTL	(R2)[R8]		; Swapped out last time?
	BEQL	40$			; Yes -- go zero out DIFF
	SUBL3	(R2)[R8],(R11),(R3)[R8]	; Calculate DIFF
	MOVL	R7,(R6)[R8]		; Store proc data block ptr in ADDR array
	BRB	50$			; ... and continue
40$:
	CLRL	(R3)[R8]		; Clear DIFF, indicating not a TOP candidate
	MOVL	MNR_PRO$L_PID(R7),(R5)[R8] ; Store PID
50$:
	MOVL	(R11),(R2)[R8]		; Store data item into DATA array
	ADDL2	#MNR_PRO$K_DSIZE,R7	; Point to next process in coll buffer
	ADDL2	#MNR_PRO$K_DSIZE,R11	; ... and to next data item
	SOBGTR	R10,10$			; Loop once for each proc in coll buffer

;
; A DIFF entry has been made for every index up through
; the last process in the collection buffer.
; The following loop clears the DIFF entry for each
; index between the last one already done and the
; last one in the DIFF array.
;

	INCL	R8			; Get next process index
	MOVL	SPTR,R11		; Get ptr to System Info Area
	MOVZWL	MNR_SYI$W_MAXPRCCT(R11),R11 ; Get max process count
	CMPL	R8,R11			; Any more process slots?
	BGEQ	70$			; No -- skip clear loop
60$:
	CLRL	(R3)[R8]		; Clear DIFF, indicating not a TOP candidate

	AOBLSS	R11,R8,60$		; Continue to end of DIFF array
70$:

	MOVL	MCAPTR,R1		; Get pointer to MCA
	BBCS	#MCA$V_TOP_DISP,MCA$W_FLAGS(R1),80$
					; If first top display event, don't
					; ... sort or move (and set bit for future)
	PUSHR	#^M<R11>		; Save max process count

	BSBB	SORT_PROCS		; Sort the top 8 processes

	POPR	#^M<R11>		; Restore max process count

	BSBB	MOVE_TOP8		; Insert data for TOP 8 into FAOSTK

	BRB	90$			; Go return
80$:
	CLRB	W^TOP_PROCS		; No procs to display on 1st time
90$:
	MOVL	NORMAL,R0		; Indicate normal status
	RET				; Return

;
; SORT_PROCS
;
; Set up the ORDER array to contain the processes indices.
;
; R11 contains max process count.
;
; This subroutine destroys registers R0,R1,R7,R8,R9,R10,R11.
;

SORT_PROCS:

	CLRL	R1			; Zero first process index
10$:	MOVL	R1,(R4)[R1]		; Load index into corresponding ORDER elem
	AOBLSS	R11,R1,10$		; Do all elements of ORDER array

;
; Go through the DIFF array and re-position elements in the
; ORDER array using a bubble sort. When the following two-level
; loop is complete, the highest-numbered 8 elements of the ORDER
; array will contain the process index numbers of the TOP 8
; consumers of the monitored resource.
;

	DECL	R11			; Get highest process index (PIX)
	SUBL3	#7,R11,R10		; Get 8th from the highest PIX
20$:
	MOVL	#1,R9			; Init loop index of inner loop
30$:
	SUBL3	#1,R9,R1		; R1 is always one less than R9
	MOVL	(R4)[R9],R7		; Get PIX from current ORDER element
	MOVL	(R4)[R1],R8		; Get PIX from previous ORDER element
	CMPL	(R3)[R7],(R3)[R8]	; Compare curr DIFF val with previous
	BGEQ	40$			; Curr is not less -- no switching
	MOVL	R8,(R4)[R9]		; Curr is less -- switch PIX in current
	MOVL	R7,(R4)[R1]		; ... ORDER elt with that in prev ORDER elt
40$:
	AOBLEQ	R11,R9,30$		; Loop through all elements of ORDER
					; ... array except the ones on the high
					; ... end which already have TOP values

	ACBL	R10,#-1,R11,20$		; Loop 8 times to "bubble down" PIX's
					; ... for the 8 largest consumers

	RSB				; Return


;
; MOVE_TOP8
;
; Move data for the top 8 (or fewer) processes
; into FAOSTK for later display.
;
; R11 contains max process count.
;
; This subroutine destroys registers R0,R1,R5,R7,R8,R9,R10,R11.
;

MOVE_TOP8:

	MOVAL	W^FAOSTK,R5		; Get pointer to display buffer
	MOVL	#1,R1			; Init count of procs that have
					; ... DIFF value > 0
10$:					; Beginning of TOP 8 loop
	DECL	R11			; Point to next lower ORDER element
	MOVL	(R4)[R11],R8		; Get PIX from ORDER array
	MOVL	(R3)[R8],R10		; Get DIFF value for this TOP process
	BEQL	20$			; Get out of loop if zero
	MOVL	(R6)[R8],R8		; Get ptr to process data block
					; ... from ADDR array
;
; NOTE -- at this point, R8 points to process data block
; ... and R10 has DIFF value.
;

;
; Move individual items for this process from current data block
; in collection buffer to longwords in FAO stack.
;

	MOVZWL	MNR_PRO$L_UIC+2(R8),(R5)+ ; Group to FAO stack
	MOVZWL	MNR_PRO$L_UIC(R8),(R5)+	; Member to FAO stack
	MOVQ	MNR_PRO$O_LNAME(R8),(R5)+ ; Process name cstring to FAO stack
	MOVQ	MNR_PRO$O_LNAME+8(R8),(R5)+ ; .....
	MOVZBL	-16(R5),(R5)+		; Length of process name to FAO stack
	SUBL3	#19,R5,(R5)+		; Address of process name to FAO stack

;
; Transform the DIFF value (in R10) from a delta to a
; rate/second. Then place it into the FAOSTK and ship
; it off to the CALC_BAR subroutine to insert the
; bar character count into FAOSTK.
; 

	CVTLF	R10,R10			; Get floating value over interval
	CVTLF	W^TOP_TICKS,R0		; Get floating ticks over interval
	DIVF2	#100,R0			; Get floating seconds over interval
	DIVF2	R0,R10			; Get floating rate per second
	CVTFL	R10,(R5)+		; Move longword rate/sec to FAO stack
	BSBW	CALC_BAR		; Calculate and stack bar chars required
					; CALC_BAR destroys regs R7 and R9, and
					; ... updates R5 to point to the next
					; ... available longword in the FAO stack

	AOBLEQ	#8,R1,10$		; Get info from TOP 8 processes
20$:
	SUBB3	#1,R1,W^TOP_PROCS	; Adjust count of processes for
					; ... DISPLAY_TOP routine

	RSB				; Return


	.SBTTL	SUMMARY_TOP - Set up Summary for TOP

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to do setup for Summary processing of
;	the PROCESSES class with the TOP display format. It is not
;	called when summarizing with the regular PROCESSES display format.
;	The basic job of this routine is to call FILL_DISP_BUFF with
;	the first collection buffer of the MONITOR request. This is
;	accomplished by loading the pointer to the current collection
;	buffer with the first collection buffer pointer, and then doing
;	a normal FILL_DISP_BUFF call. The current collection buffer
;	pointer is then restored to its original value before returning
;	to caller.
;
; CALLING SEQUENCE:
;
;	CALLS #1,SUMMARY_TOP
;
; INPUTS:
;
;	 4(AP) - address of a pointer to the CDB (Class Descriptor Block)
;		 for the PROCESSES class.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	SPTR - pointer to SYI (System Information Area)
;
; OUTPUTS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The 5 TOP arrays (DATA, DIFF, ORDER, PID, ADDR)
;	are filled with information from the first collection
;	buffer.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	SUMMARY_TOP,	^M<R2,R3,R4,R5,R6,R8,R9>

	MOVL	MCAPTR,R1		; Load MCA pointer
	BBCC	#MCA$V_TOP_DISP,MCA$W_FLAGS(R1),10$
					; Indicate no TOP displays done yet
10$:
	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBC	#MRB$V_DISPLAY,MRB$W_FLAGS(R1),20$ ; No need to clear DATA array
					; ... if not already used for displaying
	MOVL	SPTR,R2			; Load SYI pointer
	MOVZWL	MNR_SYI$W_MAXPRCCT(R2),R2 ; Get max process count
	BSBW	CLEAR_DATA		; Clear DATA array in preparation for
					; ... call to FILL_DISP_BUFF
					; (CLEAR_DATA subrtn destroys R0-R5 and
					; ... R8,R9)

;
; Load current collection buffer pointer (MBP$A_BUFFA) with
; first collection buffer pointer (MBP$A_BUFF1ST); then
; call FILL_DISP_BUFF to get the 5 TOP arrays loaded with
; data from the first collection buffer. Finally, restore
; original value of MBP$A_BUFFA for caller's use.
;

20$:
	MOVL	CDB$A_BUFFERS(R6),R2	; Load address of buffer block
	MOVL	MBP$A_BUFFA(R2),R8	; Save current buffer pointer
	MOVL	MBP$A_BUFF1ST(R2),MBP$A_BUFFA(R2) ; Move first to current

	ALLOC	4,R0,R1			; Allocate 12 (4+descr) stack bytes
					; ... for FILL_DISP_BUFF call
	MOVL	R6,(R1)			; CDB pointer into allocated space
	PUSHL	R0			; Push pointer to time quadword
	PUSHL	R1			; Push address of CDB pointer
	CALLS	#2,FILL_DISP_BUFF	; Fill 5 TOP arrays

	MOVL	R8,MBP$A_BUFFA(R2)	; Restore current collection buffer ptr

	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

	.SBTTL	DISPLAY_PROCS - Put PROCESSES Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Issues calls to various SCRPKG routines to display screen
;	output for the PROCESSES class (regular display).
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block) pointer
;		 for the PROCESSES class.
;
;	 8(AP) - address of quadword containing the system time
;		 value of the latest collection buffer.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;	MRBPTR - pointer to MRB (Monitor Request Block)
;	SPTR   - pointer to SYI (System Information Area)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire display buffer (FAOSTK) displayed to SYS$OUTPUT for
;	this display event.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_PROCS, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	MOVL	CDB$A_BUFFERS(R6),R10	; Load address of buffer block
	MOVL	MBP$A_BUFFERB(R10),R5	; Get pointer to FAO stack
	MOVL	MCA$L_PROC_DISP(R11),R7	; Get number of procs to display
	BNEQ	10$			; Continue if we have some
	BRW	110$			; Get out quickly if none to display

;
; Compute number of lines to erase (difference in the number of
; processes from previous display to this one).
;
; Clear the display area if necessary.
;

10$:
	CLRL	R9			; Assume no lines to erase
	BBC	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),30$
					; If bit clear, no need to erase
	CMPL	W^PREV_PD,#PROCS_AREA	; Previous display a single screen?
	BLEQ	20$			; Yes -- skip the erase
	ALLOC	6,R1,R3			; Get 6 bytes for call to BLINK
	BSBW	BLINK			; Erase entire display area
	BLBS	R0,30$			; Continue if status OK
	BRW	DPROCS_RET		; Return with status if failed
					; (already logged)
20$:
	CMPL	R7,#PROCS_AREA		; Current display a single screen?
	BGTR	30$			; No -- continue
	SUBL3	R7,W^PREV_PD,R9		; Yes -- calc lines to erase
30$:

;
; Compute and format ASCII uptime for setup display line.
;

	ALLOC	8,R1,R2			; Allocate 8 stack bytes for time calcs
	MOVL	SPTR,R4			; Get SYI pointer
	MOVQ	MNR_SYI$Q_BOOTTIME(R4),(R2) ; Boot time into calc area
	MOVQ	@8(AP),R0		; Get collection time
	SUBL2	R0,(R2)			; Subtract coll time from boot time
	SBWC	R1,4(R2)		; ....
	ALLOC	13,R4,R1		; Get ASCTIM output buffer
	$ASCTIM_S TIMBUF=(R4), TIMADR=(R2), CVTFLG=#0 ; Get ascii uptime
	BLBS	R0,40$			; Continue if status OK
	BRW	DPROCS_ERR		; Log error & ret with status if failed

;
; Put out process count and uptime.
;

40$:
	MOVL	R7,(R2)			; Re-use R2 as ptr to $FAOL parm list
	MOVL	R4,4(R2)		; Insert uptime descr ptr into parm list
	ALLOC	2,R1,R3			; Alloc 2 bytes for DISPLAY_PUT flags
	MOVW	#1,(R3)			; Set bit to force DISPLAY_PUT thru $FAOL
	PUSHL	R2			; Push ptr to $FAOL parameter list
	PUSHL	PROC_SETUP_STR+4	; Push address of setup string
	PUSHAL	PROC_SETUP_STR		; Push length of setup string
	PUSHL	R3			; Push DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out screen setup string
	BLBS	R0,50$			; Continue if status OK
	BRW	DPROCS_RET		; Return with status if failed (already logged)

;
; Loop putting out a line for each process
;

50$:
	ALLOC	8,R1,R2			; Allocate a descriptor
	MOVL	#PROC_LINE,(R2)		; Move const len of FAO output buff
	MOVL	OUTDSC+4,4(R2)		; Load ptr to FAO output buffer
	MOVL	R7,R8			; Load no. of procs for this interval
60$:
	CMPL	R8,#PROCS_AREA		; Will processes fit in display area?
	BLEQ	80$			; Yes -- go put them there

	BLBC	CTRLC_HIT,70$		; No -- go fill screen if collecting
					; Collection has ended
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),70$
					; Go fill screen if output to file
	BRB	130$			; Quit displaying
70$:
	MOVL	#PROCS_AREA,R4		; Do a screenful
	BSBW	FILL_SCREEN		; .....
	BLBC	R0,DPROCS_ERR		; Exit if error

	BSBW	PRINT_SCREEN		; Force SCRPKG to display screen
	BLBC	R0,DPROCS_ERR		; Exit if error

	BSBW	HOLD_SCREEN		; Wait between screenfuls
	BLBC	R0,DPROCS_ERR		; Exit if error

	ALLOC	6,R1,R3			; Get 6 bytes for call to BLINK
	BSBW	BLINK			; Erase entire display area
	BLBC	R0,DPROCS_RET		; Return with status if failed
					; (already logged)
	SUBL2	#PROCS_AREA,R8		; Calculate remaining processes
	BRB	60$			; ... and go get them displayed

80$:
	BLBC	CTRLC_HIT,90$		; Go fill screen unless CTRL-C hit
					; Collection has ended
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),90$
					; Go fill screen if output to file
	BRB	130$			; Quit displaying
90$:
	MOVL	R8,R4			; Load no. of procs for final screenful
	BSBB	FILL_SCREEN		; ... and put them out
	BLBC	R0,DPROCS_ERR		; Exit if error

;
; At this point, all process lines have been sent to the SCRPKG.
;
; If necessary, erase individual screen lines left over from
; previous display event.
;

	MOVL	R9,R3			; Retrieve number of lines to erase
	BLEQ	110$			; Continue if none to erase
	ADDL3	#SCROLL_BEG,R8,R4	; Compute 1st line to be erased
100$:
	PUSHL	#1			; Always erase from column 1
	PUSHL	R4			; ... at current row
	CALLS	#2,G^SCR$ERASE_LINE	; Erase current line
	BLBC	R0,DPROCS_ERR		; Quit if error
	INCL	R4			; Get next line number
	SOBGTR	R3,100$			; Go erase next line

;
; Save number of processes (this interval) for use in next interval.
;

110$:
	MOVL	R7,W^PREV_PD		; Remember number of procs for next interval
	BBSS	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),120$
					; Indicate erase display area next int
120$:
	BSBB	PRINT_SCREEN		; Force SCRPKG to display the screen
	BLBC	R0,DPROCS_ERR		; Exit if error
130$:
	MOVL	#SS$_NORMAL,R0		; Successful status

DPROCS_RET:
	RET				; Return with status set	

DPROCS_ERR:
	PUSHL	R0			; Bad status on stack
	PUSHAL	(SP)			; Stack pointer to bad status
	PUSHL	#MNR$_DISPERR		; Stack MONITOR failing status code
	CALLS	#2,MON_ERR		; Log the error
	MOVL	#MNR$_DISPERR,R0	; Get status to caller
	RET				; Return with status


;
; PRINT_SCREEN subroutine.
;
; Forces SCRPKG to actually output entire screen.
;

PRINT_SCREEN:

	CALLS	#0,G^LIB$PUT_BUFFER	; Output SCRPKG buffer and stop buffering
	BLBC	R0,10$			; Exit if error
	PUSHAQ	SCRDSC			; Push MONITOR buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode again
10$:
	RSB				; Return with R0 set


;
; The FILL_SCREEN subroutine fills the display area with
; the number of processes indicated in R4.
;
; REGISTER INPUTS:
;
;	R2 -- Pointer to an 8-byte stack area consisting of an FAO
;		output descriptor.
;		This register not modified by FILL_SCREEN.
;
;	R4 -- Number of processes to display (less than or equal
;		to display area size).
;		This register is destroyed by FILL_SCREEN.
;
;	R5 -- Pointer to current process in display buffer (FAO Stack).
;		On exit, R5 is updated to point to the first process
;		to be displayed on the next screen.
;
; SCRATCH REGISTERS:
;
;	R1
;
;	R3 --  Pointer to FAO control string
;
;	R10 -- Number of display lines to advance after PUT_LINE.
;
; RETURN REGISTER:
;
;	R0 -- On exit, contains status of most recent SCRPKG call.
;

FILL_SCREEN:

	PUSHL	#1			; Set cursor to
	PUSHL	#SCROLL_BEG		; ... first PROCESSES
	CALLS	#2,G^SCR$SET_CURSOR	; ... display line
	BLBC	R0,40$			; Exit if error

	MOVL	#1,R10			; Load number of lines to advance
10$:
	CMPL	#1,R4			; Only one process left to display?
	BNEQ	20$			; No -- continue
	CLRL	R10			; Yes -- indicate no advance

;
; Choose an FAO control string based on process residency
;

20$:
	MOVAL	PROC_RES_STR,R3		; Assume this process is resident
	TSTL	MNR_PRO$K_FSIZE-4(R5)	; Is last longword for this process zero?
	BNEQ	30$			; No -- process is resident
	MOVAL	PROC_NRES_STR,R3	; Yes -- process is non-resident
;
; Issue FAOL
;

30$:
	$FAOL_S CTRSTR=(R3), OUTBUF=OUTDSC, PRMLST=(R5)
	BLBC	R0,40$			; Exit if error

;
; Send process output line to SCRPKG
;

	PUSHL	R10			; Push number of lines to advance
	PUSHL	R2			; Push addr of FAO output descriptor
	CALLS	#2,G^SCR$PUT_LINE	; Give one process line to SCRPKG
	BLBC	R0,40$			; Exit if error

	ADDL2	#MNR_PRO$K_FSIZE,R5	; Point to next process in FAO stack
	SOBGTR	R4,10$			; Loop back to do next process
40$:
	RSB				; Return

;
; BLINK Subroutine.
;
; Erases entire process display area.
; Also calls DISPLAY_PUT to replace the status
;	(footing) line if necessary.
;
; R3 = Address of 6-byte stack area for call to DISPLAY_PUT:
;
;	1) longword to hold length of status string;
;	2) pair of bytes used for request flags.
;
; Upon exit, R0 contains status from DISPLAY_PUT call.
;
; Register R1 is destroyed by this subroutine.
;

BLINK:
	PUSHL	#1			; Column 1
	PUSHL	#SCROLL_BEG		; First line of process display area
	CALLS	#2,G^SCR$ERASE_PAGE	; Erase to end of screen

;
; Now replace the footing line that was erased if necessary
;

	MOVL	#SS$_NORMAL,R0		; Assume normal status
	MOVL	MRBPTR,R1		; Get MRB pointer
	BITW	#<MRB$M_PLAYBACK+MRB$M_SUMMARY+MRB$M_RECORD>,MRB$W_FLAGS(R1)
					; Any status fields need refreshing?
	BEQL	10$			; No -- go exit
	PUSHAL	W^STATUS_PARMS		; Push addr of $FAOL parameter list
	PUSHAB	W^STATUS_STR+1		; Push address of status string
	MOVZBL	W^STATUS_STR,(R3)	; Load status string length
	PUSHL	R3			; Push its address
	MOVW	#1,4(R3)		; Set bit to force DISPLAY_PUT thru $FAOL
	PUSHAL	4(R3)			; Push ptr to DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out status string on bottom line
10$:
	RSB				; Return with status in R0

;
; HOLD_SCREEN Subroutine.
;
;	Waits after a full screen has been displayed
;	in order to let the user see it before the
;	next screenful arrives.
;
; Upon exit, R0 contains status from $SETIMR or $WAITFR.
;
; Register R1 is destroyed by this subroutine.
;

HOLD_SCREEN:

	MOVL	#SS$_NORMAL,R0		; Assume normal status
	BLBS	CTRLC_HIT,10$		; If CTRL-C hit, don't hold 
	MOVL	MRBPTR,R1		; Get MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),10$
					; Don't hold if output to file
	$SETIMR_S EFN=#PROC_EV_FLAG, DAYTIM=W^BET_PROCS
					; Set time between screens
	BLBC	R0,10$			; Exit if error

	$WAITFR_S EFN=#PROC_EV_FLAG	; Wait between screenfuls
10$:
	RSB				; Return with status

	.SBTTL	DISPLAY_TOP - Put PROCESSES/TOP Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Constructs FAO control string for a PROCESSES/TOP screen
;	and calls DISPLAY_PUT to send the screen to the SCRPKG.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block) pointer
;		 for the PROCESSES class.
;
; IMPLICIT INPUTS:
;
;	FAOSTK - FAO parameter list for a TOP screen
;
;	TOP_PROCS - byte containing count (up to 8) of
;		    TOP processes to display.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire display buffer (FAOSTK) displayed to SYS$OUTPUT for
;	this display event.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_TOP, ^M<R2,R3,R4,R5,R6,R9,R10,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	CDB$A_FAOCTR(R6),R11	; Load addr of FAO control string

;
; Loop which concatenates as many FAO control string segments
; as needed to build the portion of the control string for
; processes to be displayed. The portion for null lines is
; built later.
;

	MOVB	#FIRST_DATA_LINE,W^TOPLNNO ; Load first TOP display line no
	MOVZBL	W^TOPSTR,R9		; Load length of FAO ctr str for 1 line
	MOVZBL	W^TOP_PROCS,R10		; Load number of TOP procs to display
	BEQL	20$			; Branch if none
10$:
	MOVC3	R9,W^TOPSTR+1,(R11)	; Move ctr str segment to ctr string
	ADDL2	R9,R11			; Point to next available byte in ctr str
	ADDB2	#2,W^TOPLNNO		; Update cursor control to next disp line
	SOBGTR	R10,10$			; Move one segment for each process

;
; Now loop moving in control string segments for each
; null line to be displayed.
;

20$:
	SUBB3	W^TOP_PROCS,CDB$L_COUNT(R6),R10 ; Calc number of null lines
	BEQL	40$			; Branch if none
	MOVB	W^TOPLNNO,W^ERLNNO	; Line number of first null line
	MOVZBL	W^ERLINE_STR,R9		; Length of "erase line" control string
30$:
	MOVC3	R9,W^ERLINE_STR+1,(R11)	; Move ctr str segment to ctr string
	ADDL2	R9,R11			; Update control string pointer
	ADDB2	#2,W^ERLNNO		; Update cursor control to next disp line
	SOBGTR	R10,30$			; Move one segment for each null line

;
; Call DISPLAY_PUT to put the screen image to SYS$OUTPUT.
;

40$:
	ALLOC	6,R1,R9			; Alloc 2 bytes for DISPLAY_PUT flags
					; ... and a longword for ctr str size
	MOVB	#1,(R9)			; Set bit to force DISPLAY_PUT thru $FAOL
	MOVB	#1,1(R9)		; Force DISPLAY_PUT to output it now
	SUBL3	CDB$A_FAOCTR(R6),R11,2(R9) ; Calc size of FAO control string

	PUSHAL	W^FAOSTK		; Push ptr to $FAOL parameter list
	PUSHL	CDB$A_FAOCTR(R6)	; Push address of control string
	PUSHAL	2(R9)			; Push length of control string
	PUSHL	R9			; Push DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out screen setup string
	BLBC	R0,DTOP_RET		; Return with status if failed (already logged)

	MOVL	#SS$_NORMAL,R0		; Indicate success

DTOP_RET:
	RET				; Return with status set	

	.SBTTL	DISPLAY_PUT - Put Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Puts DISPLAY output to SYS$OUTPUT (or any file) using
;	the Screen Package. Depending on the setting of an input
;	flag, DISPLAY_PUT will either send the supplied buffer
;	directly on to the screen package, or run it through $FAOL
;	before sending it. A second input flag indicates whether or 
;	not to actually output the data sent to the screen package.
;
; INPUTS:
;
;	 4(AP) - address of 2 contiguous bytes, each containing a flag:
;
;		Byte 0:	If low bit set, use supplied buffer as input
;			to $FAOL, and send the resultant buffer
;			to the screen package. Otherwise, send
;			the buffer directly on to the screen 
;			package.
;
;		Byte 1:	If low bit set, issue screen package calls to
;			actually output the data. Otherwise,
;			no such calls are made and the screen
;			package merely buffers all received data.
;
;	 8(AP) - address of longword containing length of buffer to put.
;
;       12(AP) - address of buffer to put.
;
;	16(AP) - optional address of $FAOL parameter list.
;
; IMPLICIT INPUTS:
;
;	OUTDSC - quadword string descriptor for $FAOL output buffer.
;	SCRDSC - quadword string descriptor for buffer required by SCRPKG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Translated buffer sent to Screen Package.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_PUT,^M<R2>

	BBS	#0,@4(AP),10$		; Go do $FAOL call if requested
	PUSHL	12(AP)			; Otherwise, simply put buffer
	PUSHL	@8(AP)			; ....
	CALLS	#2,PUT_TO_SCREEN	; ....
	BRB	20$			; Join common code
10$:
	ALLOC	10,R1,R2		; Allocate a descriptor & a word
	MOVL	@8(AP),(R2)		; Move in length of buffer
	MOVL	12(AP),4(R2)		; ... and address of buffer
	$FAOL_S CTRSTR=(R2), OUTLEN=8(R2), OUTBUF=OUTDSC, PRMLST=@16(AP)
	BLBC	R0,DP_ERR		; Exit if error
	PUSHL	OUTDSC+4		; Push output buffer address
	MOVZWL	8(R2),-(SP)		; ... and its length
	CALLS	#2,PUT_TO_SCREEN	; Put buffer to screen	
20$:
	BLBC	R0,DP_ERR		; Exit if error
	MOVL	@4(AP),-(SP)		; Get parameter bytes on stack
	BBC	#0,1(SP),30$		; Go exit if no output requested
	CALLS	#0,G^LIB$PUT_BUFFER	; Output SCRPKG buffer and stop buffering
	BLBC	R0,DP_ERR		; Exit if error
	PUSHAQ	SCRDSC			; Push MONITOR buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode again
	BLBC	R0,DP_ERR		; Exit if error
30$:
	MOVL	#SS$_NORMAL,R0		; No failing status hit
	RET				; Return with success	
DP_ERR:
	PUSHL	R0			; Bad status on stack
	PUSHAL	(SP)			; Stack pointer to bad status
	PUSHL	#MNR$_DISPERR		; Stack MONITOR failing status code
	CALLS	#2,MON_ERR		; Log the error
	MOVL	#MNR$_DISPERR,R0	; Get status to caller
	RET				; Return with status

	.SBTTL	PUT_TO_SCREEN - Translate escape seqs and issue PUT_SCREEN

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Translate a buffer with imbedded escape sequences to Screen
;	Package (SCRPKG) calls. The escape sequences present on
;	input are defined above in the messages declaration section.
;	They are generally VT52-style sequences, with a few minor
;	changes. These are converted to general-case SCRPKG calls
;	to accommodate any terminal. Within the buffer, strings of
;	text between escape sequences are sent to SCRPKG with a
;	SCR$PUT_SCREEN call.
;
; INPUTS:
;
;	4(AP) - length of buffer to translate (longword).
;	8(AP) - address of buffer to translate.
;
; IMPLICIT INPUTS:
;
;	SYSOUT_TYPE - SYS$OUTPUT terminal type (byte).
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 = Worst status received from SCRPKG.
;
; SIDE EFFECTS:
;
;	The entire buffer has been sent to the SCRPKG.
;
;--

.ENTRY	PUT_TO_SCREEN,^M<R2,R3>

	MOVQ	4(AP),R2		; get len & addr of buffer to translate
SCANBUF:
	MOVQ	R2,TXT_DESC		; save descriptor of remaining buffer
	LOCC	#ESC,R2,(R3)		; scan for escape character
	MOVQ	R0,R2			; use R2-R3 instead of R0-R1
	SUBW	R2,TXT_LENGTH		; compute length of text
	BEQL	10$			; br if no text between esc sequences
	CALLG	PUTSCRARG,G^SCR$PUT_SCREEN ; put text string into SCRPKG buffer
	BLBS	R0,10$			; continue if status OK
	MOVL	R0,PTS_STAT		; else, remember it for later
	.page
10$:
	SUBW	#2,R2			; update length of remaining buffer
	BGEQ	20$			; keep going if more chars in buffer
	BRW	PTS_RET			; all done if slid off end
20$:
	ADDL	#2,R3			; update ptr to remaining buffer
	LOCC	-1(R3),#ES_TAB_LEN,W^ESC_SEQ_TABLE ; get offset into tab for CASE
	BNEQ	30$			; go do CASE for known esc sequences
	BSBW	PUT_ESC_SEQ		; unknown esc seq ... just put out as text
	BRW	CHEKRET			; join common code
30$:
	CASE	R0,<CHEKBUF,PTS_ESCY,PTS_ESCU,PTS_ESCR,PTS_ESCK, -
		    PTS_ESCJ,PTS_ESCH,PTS_ESCG,PTS_ESCF,PTS_ESCB,PTS_ESCL>,W
	BRB	PTS_ESCH		; if out of range, do a cursor home

PTS_ESCB:				; set "bold" attribute
	BBSS	#SCR$V_BOLD,W^ATTRIBMSK,10$ ; turn on appropriate bit in attrib mask
10$:
	BRW	CHEKBUF			; join common code

PTS_ESCL:				; set "underline" attribute
	CMPB	#DEC_CRT,W^SYSOUT_TYPE	; is SYS$OUTPUT device VT100-compat ?
	BNEQU	10$			; no -- don't request underlining
	BBSS	#SCR$V_UNDERLINE,W^ATTRIBMSK,10$ ; turn on appropriate bit in attrib mask
10$:
	BRW	CHEKBUF			; join common code

PTS_ESCR:				; set "reverse video" attribute
	BBSS	#SCR$V_REVERSE,W^ATTRIBMSK,10$ ; turn on appropriate bit in attrib mask
10$:
	BRW	CHEKBUF			; join common code

PTS_ESCU:				; clear all VT100 attribute settings
	CLRL	W^ATTRIBMSK		; do it......
	BRW	CHEKBUF			; join common code

PTS_ESCY:				; position cursor
	SUBW	#2,R2			; update buffer length
	BGEQ	10$			; continue if more buffer left
	BRW	PTS_RET			; err if no coordinates -- just quit
10$:
	MOVZBL	1(R3),-(SP)		; stack column number
	MOVZBL	(R3),-(SP)		; stack row number
	ADDL	#2,R3			; update ptr to remaining buffer
	CALLS	#2,G^SCR$SET_CURSOR	; set the cursor position
	BRB	CHEKRET			; join common code

PTS_ESCK:				; erase to end of line
	CALLS	#0,G^LIB$ERASE_LINE	; do exactly that
	BRB	CHEKRET			; join common code

PTS_ESCJ:				; erase to end of page (screen)
	CALLS	#0,G^LIB$ERASE_PAGE	; do it
	BRB	CHEKRET			; join common code

PTS_ESCH:				; cursor to home
	PUSHL	#1			; stack column number
	PUSHL	#1			; stack row number
	CALLS	#2,G^SCR$SET_CURSOR	; position cursor to home
	BRB	CHEKRET			; join common code

PTS_ESCF:				; select "alternate" graphics set
	MOVAQ	VT100_ALTSET,VT100_CURSET ; make the alternate set current
	BRB	SELECT_SET		; ... and go output esc seq to select it

PTS_ESCG:				; select "regular" graphics set
	MOVAQ	VT100_REGSET,VT100_CURSET ; make the regular set current

SELECT_SET:
	CMPB	#DEC_CRT,W^SYSOUT_TYPE	; is SYS$OUTPUT device VT100-compat ?
	BNEQU	10$			; no --try another type
	PUSHL	VT100_CURSET		; yes -- push addr of esc seq
	CALLS	#1,G^SCR$PUT_SCREEN	; ... and write it
	BRB	CHEKRET			; join common return from CASE
10$:
	CMPB	#VT5X,SYSOUT_TYPE	; is it VT5x series ?
	BNEQU	CHEKBUF			; no -- no need to change char set

	BSBW	PUT_ESC_SEQ		; write out the esc seq just scanned

CHEKRET:
	BLBS	R0,CHEKBUF		; continue if status OK
	MOVL	R0,PTS_STAT		; else, remember it for later

CHEKBUF:				; common return point for CASE
	TSTW	R2			; whole buffer examined yet ?
	BEQL	PTS_RET			; yes -- get out
	BRW	SCANBUF			; no -- go look at more

PTS_RET:
	MOVL	PTS_STAT,R0		; return status value
	RET


PUT_ESC_SEQ:				; subroutine to put an imbedded esc
					; ... sequence directly to the screen

	MOVW	#2,TXT_LENGTH		; load length of esc sequence
	MOVAB	-2(R3),TXT_START	; load starting address
	PUSHAQ	TXT_DESC		; push descriptor addrress
	CALLS	#1,G^SCR$PUT_SCREEN	; ... and put out "as is"
	RSB

	.SBTTL	ESTAB_CTRLC - Establish CTRL-C Handler

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to set up a CTRL-C handler for the
;	SYS$COMMAND terminal device. A channel is assigned to
;	SYS$COMMAND and its device class is checked for TERMINAL.
;	If not terminal class, the handler is not established.
;
;	Then a $QIOW is issued to the terminal driver to establish
;	the CTRL-C handler. If any system service call fails,
;	the failing status is returned; otherwise, NORMAL status
;	is returned.
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	CTRLC - address of CTRL-C handling routine.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CTRL-C handler established for "CTRLC" routine.
;
; ROUTINE VALUE:
;
;	NORMAL, or failing system service status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	ESTAB_CTRLC,	^M<R2,R3,R4>

	ALLOC	2,R1,R2			; Allocate word on stack for chan number
	$ASSIGN_S DEVNAM=W^SYSCMD_DESC, CHAN=(R2) ; Assign channel to SYS$COMMAND
	BLBC	R0,EC_ERR		; Branch if error

	ALLOC	DIB$K_LENGTH,R3,R4	; Allocate DIB buffer on stack
	$GETCHN_S CHAN=(R2), PRIBUF=(R3) ; Get info on SYS$COMMAND device
	BLBC	R0,EC_ERR		; Branch if error

	CMPB	#DC$_TERM,DIB$B_DEVCLASS(R4) ; Is SYS$COMMAND device a terminal?
	BNEQU	EC_NOR			; No -- go return with normal status

	$QIOW_S	CHAN=(R2), -		; Yes -- set up CTRL-C handler
		FUNC=#<IO$_SETMODE!IO$M_CTRLCAST>, -
		P1=G^CTRLC

	BLBC	R0,EC_ERR		; Branch if error

EC_NOR:
	MOVL	NORMAL,R0		; Normal status
EC_ERR:
	RET				; Return with status

	.SBTTL	ESTAB_CTRLW - Establish CTRL-W Handler

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to set up a CTRL-W handler for
;	refreshing the display terminal screen. A channel is
;	assigned to the display device and its device class is
;	checked for TERMINAL. If not terminal class, the handler
;	is not established.
;
;	Then a $QIOW is issued to the terminal driver to establish
;	the CTRL-W handler. If any system service call fails,
;	the failing status is returned; otherwise, NORMAL status
;	is returned.
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	CTRLW - address of CTRL-W handling routine.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CTRL-W handler established for "CTRLW" routine.
;
; ROUTINE VALUE:
;
;	NORMAL, or failing system service status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	ESTAB_CTRLW,	^M<R2,R3,R4>

	ALLOC	2,R1,R2			; Allocate word on stack for chan number
	MOVL	MRBPTR,R3		; Get pointer to MRB
	$ASSIGN_S DEVNAM=@MRB$A_DISPLAY(R3), - ; Assign channel to display device
		  CHAN=(R2)
	BLBC	R0,EW_ERR		; Branch if error

	ALLOC	DIB$K_LENGTH,R3,R4	; Allocate DIB buffer on stack
	$GETCHN_S CHAN=(R2), PRIBUF=(R3) ; Get info on display device
	BLBC	R0,EW_ERR		; Branch if error

	CMPB	#DC$_TERM,DIB$B_DEVCLASS(R4) ; Is display device a terminal?
	BNEQU	EW_NOR			; No -- go return with normal status

	$QIOW_S	CHAN=(R2), -		; Yes -- set up CTRL-W handler
		FUNC=#<IO$_SETMODE!IO$M_OUTBAND>, -
		P1=G^CTRLW, -
		P2=#CTRLW_MASK

	BLBC	R0,EW_ERR		; Branch if error

EW_NOR:
	MOVL	NORMAL,R0		; Normal status
EW_ERR:
	RET				; Return with status

	.SBTTL	MON_ERR - Log MONITOR Error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to log an error whenever a MONITOR
;	synchronous error is discovered. Asynchronous (signaled)
;	errors are logged via the SIGNALED_ERR routine.
;	Logging consists of filling in the PUTMSGVEC array.
;	This array is the message argument vector for $PUTMSG which
;	will be called after all routines leading up to this
;	one have returned.
;
; INPUTS:
;
;	 4(AP) - MONITOR message code (required parameter)
;
;	 8(AP) - address of a secondary message code (0 if none).
;		 (optional parameter)
;
;       12(AP) - 1st FAO argument for MONITOR message (optional
;		 parameter). Up to 16 additional FAO arguments
;		 may be included in this parameter list, immediately
;		 following this parameter.
;
; IMPLICIT INPUTS:
;
;	PUTMSGVEC - 20-longword array, to contain the message argument
;		     vector for $PUTMSG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	PUTMSGVEC contains message argument vector for later $PUTMSG call.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	MON_ERR,	^M<R2,R3>

	MOVAL	PUTMSGVEC+4,R1		; Get pointer to where MONITOR code goes
	MOVL	4(AP),(R1)+		; Move it in and point to next item in list
	MOVZWL	(AP),R2			; Get number of input args
	CMPL	#1,R2			; Just one arg?
	BLSS	10$			; No -- continue
	MOVL	#1,PUTMSGVEC		; Yes -- tack on argument vector size
	BRB	ME_RET			; ... and go return
10$:
	SUBL2	#2,R2			; Compute # of input FAO args
	BGTR	20$			; Continue if found some
	CLRL	(R1)+			; Indicate none in PUTMSGVEC
	CLRL	R2			; Remember for later
	BRB	50$			; ... and go check secondary code
20$:
	CMPL	#PUTMSGSIZE-4,R2	; # FAO args greater than max?
	BGEQ	30$			; No, OK as is
	MOVL	#PUTMSGSIZE-4,R2	; Yes, replace with max
30$:
	MOVL	R2,(R1)+		; Move # FAO args into list
	CLRL	R3			; Clear an index register
40$:
	MOVL	12(AP)[R3],(R1)+	; Move an FAO arg into list
	AOBLSS	R2,R3,40$		; Loop to move all FAO args

50$:
	ADDL3	#2,R2,PUTMSGVEC		; Compute # message args and store
	TSTL	8(AP)			; Secondary message code?
	BEQL	ME_RET			; No -- all done
	MOVL	@8(AP),(R1)		; Yes -- move in after FAO args
	INCL	PUTMSGVEC		; ... and count it
ME_RET:
	RET				; Return to caller	

	.SBTTL	SIGNALED_ERR - Log Signaled Error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to log an error whenever a MONITOR
;	asynchronous (signaled) error is discovered. Synchronous
;	errors (detected by MONITOR) are logged via the MON_ERR
;	routine. Logging consists of filling in the PUTMSGVEC array.
;	This array is the message argument vector for $PUTMSG which
;	will be called after all routines leading up to this
;	one have returned.
;
; INPUTS:
;
;	 4(AP) - MONITOR message code (required parameter)
;
;	 8(AP) - secondary message code (required parameter)
;
;       12(AP) - number of additional (FAO) arguments for secondary
;		 message.
;
;	16(AP) - address of first additional argument. Others
;		 follow contiguously.
;
; IMPLICIT INPUTS:
;
;	PUTMSGVEC - 20-longword array, to contain the message argument
;		     vector for $PUTMSG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	PUTMSGVEC contains message argument vector for later $PUTMSG call.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	SIGNALED_ERR,	^M<R2,R3>

	MOVAL	PUTMSGVEC+4,R1		; Get pointer to where MONITOR code goes
	MOVL	4(AP),(R1)+		; Move it in and point to next item in list
	CLRL	(R1)+			; Zero MONITOR FAO args
	MOVL	8(AP),(R1)+		; Move in secondary code
	MOVL	#3,PUTMSGVEC		; Size of PUTMSGVEC so far
	CLRL	R2			; Start out with no PC/PSL args for 2ndary
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,8(AP),#SYS_FAC_NO ; System fac code?
	BNEQ	10$			; No -- go add in additional args
	ADDL2	#2,R2			; Yes -- count the PC/PSL args (h'ware xcptn)
10$:
	ADDL2	12(AP),R2		; Add in caller's additional args for 2ndary
	BEQL	40$			; Go exit if none
	MOVL	16(AP),R3		; Set up pointer to first add'l arg
	CMPL	#PUTMSGSIZE-4,R2	; # FAO args greater than max?
	BGEQ	20$			; No, OK as is
	MOVL	#PUTMSGSIZE-4,R2	; Yes, replace with max
20$:
	ADDL2	R2,PUTMSGVEC		; Add the add'l args into PUTMSGVEC size
30$:
	MOVL	(R3)+,(R1)+		; Move from signal array to PUTMSGVEC
	SOBGTR	R2,30$			; Loop once for each add'l arg
40$:
	RET				; ... and return
.END
