%TITLE	'Action Routines for Verbs'
MODULE NCPVRBACT(IDENT = 'V03-000',
		ADDRESSING_MODE(EXTERNAL=GENERAL),
		ADDRESSING_MODE(NONEXTERNAL=GENERAL)) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Network Control Program (NCP)
!
! ABSTRACT:
!
!	This module contains action routines, other routines and supporting
!	data for performing NCP functions at the conclusion of the parsing
!	of a command.  Routines here save the parameters into temporary
!	storage and build the messages to be sent to NML to perform the
!	actual functions.
!
! ENVIRONMENT:	VAX/VMS Operating System
!
! AUTHOR:	Darrell Duffy	, CREATION DATE: 22-October-1979
!
! MODIFIED BY:
!
!	V007	TMH0007		Tim Halvorsen	11-Jan-1982
!		Map circuit requests to a V2.0 NML into the
!		appropriate line request.
!
!	V006	TMH0006		Tim Halvorsen	 2-Dec-1981
!		Change text of message displayed in TMH0005.
!		Add check so that message is not displayed for
!		error responses.
!
!	V005	TMH0005		Tim Halvorsen	11-Nov-1981
!		Add ESCI parameter type handling.
!		Output "No information in database" message if all
!		responses from a show request are null.
!
!	V004	TMH0004		Tim Halvorsen	02-Sep-1981
!		Remove Phase II compatibility code.
!
!	V003	TMH0003		Tim Halvorsen	10-Jul-1981
!		Add action routine ACT$COPY_VALUE
!		Add parameter types:
!			SAD - Subaddress range
!			OBJ - Object ID
!		Do not copy string in MOV_STR if the byte count is negative
!		(meaning ACTIVE or KNOWN of that parameter).
!
!	V002	TMH0002		Tim Halvorsen	22-Jun-1981
!		Treat negative entity type codes in SDB as system-specific.
!		Add ENT parameter type, entity type and ID.
!
!	V001	TMH0001		Tim Halvorsen	13-Jun-1981
!		Make all external references longword relative.
!--

%SBTTL	'Definitions'

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	ACT$SAVPRM,			! Action routine to save a parameter
	NCP$MOV_QSTR	: NOVALUE,	! Move quoted string
	NCP$MOV_STR	: NOVALUE,	! Move unquoted string
	ACT$CLRLONG,			! Action routine to clear a longword
	ACT$COPY_VALUE,			! Action routine to copy a longword
	ACT$VRB_EXIT	: NOVALUE,	! Action routine for EXIT command
	ACT$VRB_UTILITY,		! Action routine for most commands
	ACT$VRB_SHOLIS,			! Show/List action routine
	NCP$HNDL_SHOLIS,		! Show/list handler
	ACT$VRB_LOOP,			! Action routine for LOOP command
	V2_REQUESTS,			! V2.0 NML request compatibility
	NCP$BLD_PROLOG	: NOVALUE,	! Build prolog of message
	NCP$BLD_ENTITY	: NOVALUE,	! Build entity code
	NCP$BLD_PRMS	: NOVALUE;	! Build parameters into message

!
! INCLUDE FILES:
!

	LIBRARY 'SYS$LIBRARY:STARLET.L32';
	LIBRARY 'LIB$:NCPLIBRY.L32';
	LIBRARY 'LIB$:NMALIBRY.L32';

!
! EQUATED SYMBOLS:
!

LITERAL
	NCP$C_MSGSIZ = 1000	! Message buffer size
	;

!
! OWN STORAGE:
!

GLOBAL
	NCP$GL_ENTITY:	SIGNED,		! Entity type code.  If negative, then
					! system-specific entity (NMA$C_SENT_)
	NCP$GT_MSGBFR:	VECTOR [NCP$C_MSGSIZ, BYTE];	! Message buffer itself


!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
	NCP$_ACCLIN,			! Access control with loop line
	NCP$_INVEVE,			! Invalid event range was specified
	NCP$_REPEAT,			! Parameter value has been repeated
	NCP$_NOPARM,			! Status for no parameters saved
	NCP$_INVRSP,			! Invalid management response
	NCP$_V2COMP;			! V2.0 NML parameter conversion error


EXTERNAL
	PDB$G_VRB_ALL,			! Parameter block for ALL code
	PDB$G_LOO_ACC,			! Access control for loop command
	PDB$G_LOO_PSW,
	PDB$G_LOO_USR,
	NCP$GL_FNC_CODE : BBLOCK [4],	! Function code byte
	NCP$GL_OPTION : BBLOCK [4],	! Option code byte
	NCP$GL_EXELCB: REF BBLOCK;	! Pointer to executor link control blk

EXTERNAL ROUTINE
	NCP$SIG_CMDERR,			! Signal a command error
	NCP$OPENLINK: NOVALUE,		! Open a link to the listener
					! (and get its version #)
	NCP$SENDMSG : NOVALUE,		! Write a message to the listner
	NCP$READRSP,			! Read a response from the listner
	NCP$OPENSHO : NOVALUE,		! Open show/list output file
	NCP$SHOHEAD : NOVALUE,		! Write the heading
	NCP$SHOLIS  : NOVALUE,		! Write the parameters from one msg
	NCP$WRITESHO : NOVALUE,		! Write a line to output file
	NCP$CLOSESHO : NOVALUE;		! Close the output file

%SBTTL	'ACT$SAVPRM	Save a Parameter'
GLOBAL ROUTINE ACT$SAVPRM (OPT, STRCNT, STRPTR, TKNCNT, TKNPTR,
		CHR, NUM, PBLK) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Action routine to store a parameter away for later use.
!	The parameter PBLK is the address of a control block which controls
!	the type of parameter saved and the address.  If the parameter
!	already has been saved in this parse, this routine complains by
!	signalling an error and returns failure.
!
! FORMAL PARAMETERS:
!
!	Parse state table
!
!	TKNCNT, TKNPTR	Descriptor of the token which may be used if the
!			type specifies a token
!
!	PBLK		Address of the parameter control block
!			BYTE (PBK$K_code)	code for type of parameter
!			LONG (ADR)		Address of the parameter data
!			LONG (PRM)		Value of the parameter for
!						the code specified
!
!		The parameter data has the following form
!			BYTE (STS)		0 for not yet saved here
!						1 for data saved here
!			...			Data of the parameter itself
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Success or an error signalled and failure
!
! SIDE EFFECTS:
!
!	NONE
!
!--


    BEGIN

    MAP
	PBLK : REF BBLOCK [PBK$C_SIZE]	! Parameter control block
	;

    LOCAL
	CPTR,				! Character pointer
	PTR				! Pointer to data segment
	;		!

    OWN
	EVELST				! Last event code seen
	;

    GLOBAL
	ACT$GL_NODADR_Q,		! Flag for Node address saved
	ACT$GL_SAD_BEGIN,		! Subaddress beginning
	ACT$GL_SAD_END;			! Subaddress end


    PTR = .PBLK [PBK$L_PDB_ADR];	! Address of param data block

    IF .BBLOCK [.PTR, PDB$B_STS_FLG]	! Is there already one here?
    THEN
	BEGIN
	IF NOT				! Exclude error check for some codes
	    (SELECTONEU .PBLK [PBK$B_TYPECODE]
	    OF
		SET
		[PBK$K_ESET TO PBK$K_ESEX, PBK$K_ESCI]: 1;
		[PBK$K_PRVL]: 1;
		[OTHERWISE]: 0;
		TES)
	THEN
	    BEGIN
	    NCP$SIG_CMDERR(NCP$_REPEAT,	! Yes, signal an error
		    .TKNCNT, .TKNPTR,
		    .STRCNT, .STRPTR);
	    RETURN FAILURE;		! Return a syntax error
	    END;
	END;

    BBLOCK [.PTR, PDB$B_STS_FLG] = 1;	! Set the status for we have one
    PTR = BBLOCK [.PTR, PDB$T_DATA];	! Advance the address to data

!
!	Dispatch on the type code
!

    CASE .PBLK [PBK$B_TYPECODE]
		FROM PBK$K_LOW
    		TO PBK$K_HIGH
    		OF
    SET

    [PBK$K_LITB] :			! Literal byte
    	CH$WCHAR (.PBLK [PBK$L_PARAM],
    		CH$PTR (.PTR)
    		)
	;

    [PBK$K_NUMB] :			! Number as a byte
    	CH$WCHAR (.NUM, CH$PTR (.PTR) )
	;


    [PBK$K_NUMW] :			! Number as a word
    	(.PTR) <0,16,0> = .NUM <0,16,0>
	;

    [PBK$K_NUML] :			! Number as a long word
    	.PTR = .NUM
	;

    [PBK$K_LITL] :			! Literal longword
	.PTR = .PBLK [PBK$L_PARAM]
	;

    [PBK$K_TKN] :			! Token as a string
	NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR)
	;

    [PBK$K_TKNQ] :			! Token as a quoted string
	NCP$MOV_QSTR (.TKNCNT, .TKNPTR, .PTR)
	;

    [PBK$K_STRQ] :			! A described string as a quoted str
	NCP$MOV_QSTR
	    (
	    .VECTOR [.PBLK [PBK$L_PARAM], 0],
	    .VECTOR [.PBLK [PBK$L_PARAM], 1],
	    .PTR
	    )
	;

    [PBK$K_NADR] :			! Node address
	BEGIN
	IF .ACT$GL_NODADR_Q		! Did we save a node address??
	THEN
	    BEGIN
	    ACT$GL_NODADR_Q = 0;	! Zero the flag
	    (.PTR) <0,8,0> = 0;		! Indicate the address
	    (.PTR) <8,16,0> = .NUM <0,16,0>	! The address
	    END
	ELSE				! Move a string with no quotes
	    NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR)
	END
	;

    [PBK$K_OBJ]:			! Object ID
	IF .ACT$GL_NODADR_Q		! Did we save a object number?
	THEN
	    BEGIN
	    ACT$GL_NODADR_Q = 0;	! Zero the flag
	    (.PTR) <0,8,0> = 0;		! Indicate an object number, not name
	    (.PTR) <8,8,0> = .NUM <0,8,0>; ! Object number
	    END
	ELSE				! Move a string with no quotes
	    NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR);

    [PBK$K_ENT]:			! Entity type and ID
	BEGIN
	(.PTR) <0,8> = NMA$C_ENT_NOD;	! &&& Only nodes handled for now &&&
	IF .ACT$GL_NODADR_Q		! Did we save a node address??
	THEN
	    BEGIN
	    ACT$GL_NODADR_Q = 0;	! Zero the flag
	    (.PTR+1) <0,8> = 0;		! Indicate a node address
	    (.PTR+2) <0,16> = .NUM <0,16>; ! The node address
	    END
	ELSE				! Move a string with no quotes
	    NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR+1);
	END;


    [PBK$K_HXPS] :			! Hex password
	BEGIN
	(.PTR) <0,8,0> = 
	    (.TKNCNT+1 )/ 2;		! Save the byte count
					! Zap last byte for high zero if odd
					! Number of bytes in string
	(.PTR + 1 + ( (.TKNCNT + 1) / 2) )<0, 8, 0> = 0;
	CPTR = CH$PTR (.TKNPTR);	! Make a pointer to the string

!
!	Step backward from last nibble used to beginning
!	of string
!

	DECRU BPOS FROM 8 + ( (.TKNCNT-1) * 4) ! Last nibble
		   TO 8			! First nibble
		   BY 4			! A nibble wide
	DO
	    BEGIN
	    LOCAL CHAR;
	    CHAR = CH$RCHAR_A (CPTR);	! Obtain the character
	    IF (.CHAR GEQU 'A' ) 	! Adjust the range of hex
	    	AND (.CHAR LEQU 'F')
	    THEN CHAR = .CHAR + 9;	! Make lower nibble valid
	    (.PTR) <.BPOS, 4, 0> = .CHAR ! Insert the nibble in the string
	    END
	END
	;


!
!	Event building types
!

    [PBK$K_ESET] :			! Setup to collect an event
	BEGIN
	(.PTR) <16, 8, 0> = 8;		! The type mask counter
	(.PTR+11) <0, 8, 0> = -1;	! The source entity code (none)
	BBLOCK [.PTR-1, PDB$B_STS_FLG] = 0; ! Inhibit repeated store checking
	END;

    [PBK$K_ECLS] :			! The event class code
	BEGIN
	(.PTR) <0, 16, 0> = .NUM;
	END;

    [PBK$K_EMSK] :			! A simple type
	BEGIN
	EVELST = .NUM;			! Save the event type for a range
	(.PTR+3) <.NUM, 1, 0> = 1;	! Set the bit
	END;

    [PBK$K_ERNG] :			! Set a range of event type bits
	BEGIN
	IF .EVELST GTRU .NUM		! Check the range for increasing
	THEN
	    NCP$SIG_CMDERR(NCP$_INVEVE,	! Yes, signal an error
		.TKNCNT, .TKNPTR,
		.STRCNT, .STRPTR);

	INCRA IDX FROM .EVELST TO .NUM	! Scan the bits
	DO
	    (.PTR+3) <.IDX, 1, 0> = 1;	! And set them

	EVELST = .NUM;			! Set for the next range
	END;


    [PBK$K_EWLD] :			! Event wild card
	0;				! Sets the parameter as active
					! Code is stored by mask operation
					! we don't do anything here

    [PBK$K_ESNO] :			! Event source node
	BEGIN
	EXTERNAL
	    ACT$GL_NODADR_Q;

	IF  CH$RCHAR (.PTR+11) NEQ 255	! If a parameter saved here
	THEN
	    NCP$SIG_CMDERR(NCP$_REPEAT,	! Yes, signal an error
		    .TKNCNT, .TKNPTR,
		    .STRCNT, .STRPTR);

	IF .ACT$GL_NODADR_Q		! Node address saved?
	THEN
	    BEGIN			! Its a node address
	    (.PTR+12) <0, 8, 0> = 0;	! Indicate a node address
	    (.PTR+12) <8, 16, 0> =	! Save the node address
		.NUM <0, 16, 0>;
	    ACT$GL_NODADR_Q = 0;	! Clear the address flag
	    END
	ELSE				! If its a node name, save it
	    NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR+12);
	CH$WCHAR (0, .PTR+11);		! Indicate its a node
	END;

    [PBK$K_ESLI] :			! Save a source line id
	BEGIN
	IF  CH$RCHAR (.PTR+11) NEQ 255	! If a parameter saved here
	THEN
	    NCP$SIG_CMDERR(NCP$_REPEAT,	! Yes, signal an error
		    .TKNCNT, .TKNPTR,
		    .STRCNT, .STRPTR);
	NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR+12);
	CH$WCHAR (1, .PTR+11);		! Indicate its a line id
	END;

    [PBK$K_ESCI] :			! Save a source circuit id
	BEGIN
	IF  CH$RCHAR (.PTR+11) NEQ 255	! If a parameter saved here
	THEN
	    NCP$SIG_CMDERR(NCP$_REPEAT,	! Yes, signal an error
		    .TKNCNT, .TKNPTR,
		    .STRCNT, .STRPTR);
	NCP$MOV_STR (.TKNCNT, .TKNPTR, .PTR+12);
	CH$WCHAR (3, .PTR+11)		! Indicate its a circuit id
	END;

    [PBK$K_ESEX] :			! Save the executor as source
	BEGIN
	IF  CH$RCHAR (.PTR+11) NEQ 255	! If a parameter saved here
	THEN
	    NCP$SIG_CMDERR(NCP$_REPEAT,	! Yes, signal an error
		    .TKNCNT, .TKNPTR,
		    .STRCNT, .STRPTR);
	CH$FILL (0, 4, .PTR+11);	! Indicate node source type and
					! store zero node address
	END;


!
!	Privilege list types
!

    [PBK$K_PRVC] :			! Clear the privilege mask
	BEGIN
	CH$FILL (0, LEN_PRV_MSK+1, .PTR+1);
	(.PTR) <0, 8, 0> = 8		! The count for the image field
	END
	;

    [PBK$K_PRVL] :			! Set a bit in the mask
	BEGIN
	EXTERNAL ROUTINE
	    PRV$SETPRIV			! Set privilege bit in mask
	    ;
	IF  NOT
	    PRV$SETPRIV			! Set privilege bit according
		(			! to the token string
		TKNCNT,			! Address of the token descriptor
		.PTR+1			! Address of the mask (quadword)
		)
	THEN
	    RETURN FAILURE		! Report syntax error
	END
	;


!
!	Subaddress range
!

    [PBK$K_SAD]:
	BEGIN
	(.PTR) <0,16,0> = .ACT$GL_SAD_BEGIN;
	(.PTR) <2,16,0> = .ACT$GL_SAD_END;
	END;

    [OUTRANGE, PBK$K_END, PBK$K_TRIPL] : ! For any error in coding block
	RETURN FAILURE;			! Report a syntax error

    TES;

    RETURN SUCCESS

    END;

%SBTTL	'NCP$MOV_QSTR	Move Quoted String'
ROUTINE NCP$MOV_QSTR (STRCNT, STRPTR, DST) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Copy a quoted string to DST.  Quotes are removed if present
!	and trailing spaces are removed if no quotes are found.
!	String is converted into a counted string format
!
! FORMAL PARAMETERS:
!
!	STRCNT, STRPTR		String descriptor for source string
!	DST			Address of the area to hold counted string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	CPTR1,				! Temporary string pointers
	CPTR2,
	CPEND,
	CHAR				! A character as we see it
	;		!

    CPTR1 = CH$PTR (.STRPTR);		! Point to beginning of source

    IF CH$RCHAR (.CPTR1) EQL '"'	! Is it quoted??
    THEN				! Yes
	BEGIN
	CPTR1 = CH$PLUS (.CPTR1, 1);	! Skip initial quote
	CPTR2 = CH$PTR (.DST + 1);	! Storing pointer
	CPEND = CH$PTR (.STRPTR +	! Pointer to end
		.STRCNT);

	WHILE .CPTR1 LSSA .CPEND	! There is more string to process
	DO
	    BEGIN
	    CHAR = CH$RCHAR_A (CPTR1);	! Obtain a character
	    IF .CHAR EQLU '"'		! Double quotes are stripped out
	    THEN
		BEGIN
		CHAR = CH$RCHAR (.CPTR1);
		IF .CHAR NEQU '"'
		THEN  EXITLOOP		! Single quote ends the string
		ELSE  CPTR1 = .CPTR1 + 1 ! Advance over quote
		END
	    ;
	    CH$WCHAR_A (.CHAR, CPTR2)	! Write a character we save
	    END
	;

	CPTR1 = CH$PTR (.DST + 1);	! Build a pointer to new string

	(.DST) <0, 8, 0> = .CPTR2 - .CPTR1; ! Store the count for the string

	END

    ELSE				! Deal with a string without quotes
	NCP$MOV_STR (.STRCNT, .STRPTR, .DST)
    ;

    RETURN

    END;

%SBTTL	'NCP$MOV_STR	Move an Unquoted String'
ROUTINE NCP$MOV_STR (STRCNT, STRPTR, DST) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Copy a token string to DST.  Trailing spaces are removed.
!	String is stored in counted string format.
!
! FORMAL PARAMETERS:
!
!	STRCNT, STRPTR		String descriptor for source string
!	DST			Address of target counted string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	CPTR				! Character pointer
	;		!

    CPTR = .STRPTR + .STRCNT - 1;	! Last character
    DECRA IDX				! Strip off trailing spaces
	    FROM .CPTR
	    TO .STRPTR
    DO
	IF  CH$RCHAR (.IDX) NEQU ' '	! Strip trailing spaces and
	    AND
	    CH$RCHAR (.IDX) NEQU 9	! tabs too
	THEN				! Exit with pointer to end
	    EXITLOOP CPTR = .IDX
    ;

    CH$WCHAR				! Store the count
	(
	CH$DIFF (.CPTR, .STRPTR) + 1,	! Size of string
	CH$PTR (.DST)			! Here is the count
	);

    CH$MOVE				! Move the string to the target
	(
	CH$DIFF (.CPTR, .STRPTR) + 1,	! How many
    	CH$PTR (.STRPTR),		! Source
    	CH$PTR (.DST + 1)		! Beyond the count
	);

    RETURN

    END;

%SBTTL	'ACT$CLRLONG	Clear a Longword Flag'
GLOBAL ROUTINE ACT$CLRLONG (OPT, STRCNT, STRPTR, TKNCNT, TKNPTR,
    				CHR, NUM, PRM) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Clear a longword flag or mask
!
! FORMAL PARAMETERS:
!
!	Parse state table
!	PRM		Address of the longword to clear
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    .PRM = 0;			! Clear the longword

    RETURN SUCCESS

    END;

%SBTTL	'ACT$COPY_VALUE	Copy a longword value'
GLOBAL ROUTINE ACT$COPY_VALUE (OPT, STRCNT, STRPTR, TKNCNT, TKNPTR,
    				CHR, NUM, PRM) =
!++
!
!	Copy a longword value to another location.
!
! Inputs:
!
!	Parse state table
!	NUM		Source longword
!	PRM		Address of the destination longword
!
! Outputs:
!
!	None
!--

BEGIN

.PRM = .NUM;			! Copy the longword

RETURN SUCCESS;

END;

%SBTTL	'ACT$VRB_EXIT  Action Routine to Exit NCP'
GLOBAL ROUTINE ACT$VRB_EXIT :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This action routine leaves NCP and returns control to VMS
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

!
!	No cleanup is done here.  It is assumed that the system
!	knows how to cleanup the logical links and open channels
!	we have.  Cleanup will be instituted if necessary.
!

    $EXIT ( CODE = SS$_NORMAL)		! Use the system service

    END;

%SBTTL	'ACT$VRB_UTILITY Action Routine for Most Verbs'
GLOBAL ROUTINE ACT$VRB_UTILITY (OPT, STRCNT, STRPTR, TKNCNT, TKNPTR,
 				CHR, NUM, PRM: REF BBLOCK) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Action routine to perform parameter processing for almost all
!	functions.  The NICE messages are built and sent
!	to the network object.
!
! FORMAL PARAMETERS:
!
!	Parse state table
!	PRM		Address of the SDB table to control this routine
!			The SDB has the following structure
!				BYTE (TYP)	Code for type of entity.  If
!						negative, system-specific entityt
!				LONG (ADR)	Address of entity PDB
!				LONG (ADR)	Address of PCL list
!
! SIDE EFFECTS:
!
!	NICE message built and sent, response processed
!
!--

    BEGIN

    LOCAL
	STATUS,				! Returned status
	LEN,				! Returned buffer length
	BFR,				! Returned buffer address
	MSGPTR;				! Used to build message

!
! If we are dealing with a V2.0 NML, then reformat any circuit requests
! into the appropriate line request.
!

    IF NOT .NCP$GL_EXELCB [LCB$B_STS]	! If link is not open yet,
    THEN
	NCP$OPENLINK(.NCP$GL_EXELCB);	! Open the link; signal any errors

    IF NOT V2_REQUESTS(.PRM)		! Handle V2.0 conversion (if any)
    THEN
	RETURN SUCCESS;			! If error, exit from action routine

!
! Build the message prologue fields
!

    NCP$BLD_PROLOG(.PRM, MSGPTR);	! Build the prolog for the message

!
! Build the parameter entries in the message
!

    NCP$BLD_PRMS (.PRM [SDB$L_PCL_ADR], MSGPTR, TRUE); ! Enable parameter check

    NCP$SENDMSG				! Send the message to NML and check
	(				! Response for error
	.NCP$GL_EXELCB,			! Link control block
	.MSGPTR - NCP$GT_MSGBFR,	! Length of message
	NCP$GT_MSGBFR			! Message start
	);

    STATUS = NCP$READRSP		! Read the response from NML
	(
	.NCP$GL_EXELCB,			! LCB
	LEN,				! Return the length here
	BFR,				! Return buffer address here
	FALSE				! Not show or list
	);

    IF .STATUS EQL NMA$C_STS_MOR	! Beginning of multiple responses?
    THEN
	BEGIN
	DO
	    BEGIN
	    IF .LEN NEQ 0		! Length must be zero
	    THEN
		SIGNAL (NCP$_INVRSP)	! Or call out nasty
	    ;
	    STATUS = NCP$READRSP	! Read the response from NML
		(
		.NCP$GL_EXELCB,		! LCB
		LEN,			! Return the length here
		BFR,			! Return buffer address here
		FALSE			! Not show or list
		)
	    END
	UNTIL .STATUS EQL NMA$C_STS_DON	! Read multiple until done
	END
    ELSE
	BEGIN
	IF .LEN NEQ 0			! Call out unclean if data here
	THEN
	    SIGNAL (NCP$_INVRSP)	! Call out the nasty
	END
    ;
    RETURN SUCCESS			! Never a syntax error reported here

    END;

%SBTTL	'ACT$VRB_SHOLIS  Action Routine for Display Verbs'
GLOBAL ROUTINE ACT$VRB_SHOLIS (OPT, STRCNT, STRPTR, TKNCNT, TKNPTR,
 				CHR, NUM, PRM) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Action routine to perform parameter processing for show and list
!	functions.  The NICE messages are built and sent
!	to the network object.  The responses are read and parsed
!	and written to the desired output file.
!
! FORMAL PARAMETERS:
!
!	Parse state table
!	PRM		Address of the SDB table to control this routine
!			The SDB has the following structure
!				BYTE (TYP)	Code for type of entity.  If
!						negative, system-specific entity
!				LONG (ADR)	Address of entity PDB
!				LONG (ADR)	Address of PCL list
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	SUCCESS
!
! SIDE EFFECTS:
!
!	NICE message built and sent, response processed
!
!--

    BEGIN

    MAP
	PRM : REF BBLOCK [SDB$C_SIZE]	! SET DEFINE Block
	;

    LOCAL
	STATUS,				! Returned status
	LEN,				! Returned buffer length
	BFR,				! Returned buffer address
	INFO_RETURNED,			! True if non-null reply returned
	MSGPTR;				! Used to build message

!
!	Enable a condition handler to close the output file for show/list
!	We know that the file is not opened immediately and that a
!	signal may occur before the file is opened.  This will cause the
!	Close to be attempted before the file is opened.  The close
!	operation does not signal however so this is not a problem now.
!

    ENABLE NCP$HNDL_SHOLIS;		! Enable handler to close file

!
! If we are dealing with a V2.0 NML, then reformat SHOW CIRCUIT
! into SHOW LINE.
!

    IF NOT .NCP$GL_EXELCB [LCB$B_STS]	! If link is not open yet,
    THEN
	NCP$OPENLINK(.NCP$GL_EXELCB);	! Open the link; signal any errors

    IF NOT V2_REQUESTS(.PRM)		! Handle V2.0 conversion (if any)
    THEN
	RETURN SUCCESS;			! If error, exit from action routine

!
! Build message prologue
!

    NCP$OPENSHO ();			! Open output file for show or list

    NCP$BLD_PROLOG(.PRM, MSGPTR);	! Build the prolog for the message

!
! Build the parameter entries in the message
!

    NCP$BLD_PRMS (.PRM [SDB$L_PCL_ADR], MSGPTR, FALSE);	! Disable parameter check

    NCP$SENDMSG				! Send the message to NML and check
	(				! Response for error
	.NCP$GL_EXELCB,			! Link control block
	.MSGPTR - NCP$GT_MSGBFR,	! Length of message
	NCP$GT_MSGBFR			! Message start
	);

    NCP$SHOHEAD ();			! Write the heading for the data

    STATUS = NCP$READRSP		! Read the response from NML
	(
	.NCP$GL_EXELCB,			! LCB
	LEN,				! Return the length here
	BFR,				! Return buffer address here
	TRUE				! This is a show or list
	);

    INFO_RETURNED = FALSE;		! Assume no information returned

    IF .STATUS EQL NMA$C_STS_MOR	! Multiple responses
    THEN
	BEGIN
	DO
	    BEGIN			! Read them all
	    IF .LEN NEQ 0		! Process them if data is here
	    THEN
		BEGIN
		NCP$SHOLIS(.LEN, .BFR);	! Pass the buffer length and address
		INFO_RETURNED = TRUE;	! Indicate we got information back
		END;
	    STATUS = NCP$READRSP	! Read the response from NML
		(
		.NCP$GL_EXELCB,		! LCB
		LEN,			! Return the length here
		BFR,			! Return buffer address here
		TRUE			! This is a show or list
		);
	    IF .STATUS NEQ NMA$C_STS_SUC	! If not successful,
		AND .STATUS NEQ NMA$C_STS_DON
	    THEN
		INFO_RETURNED = TRUE;	! Then mark information (an error)
					! WAS returned.
	    END
	UNTIL .STATUS EQL NMA$C_STS_DON	! Until done is in
	END

    ELSE
	BEGIN				! Not multiple responses
	IF .LEN NEQ 0			! Report data if any
	THEN
	    BEGIN
	    NCP$SHOLIS (.LEN, .BFR);	! Display information
	    INFO_RETURNED = TRUE;	! Indicate we got information back
	    END;
	IF .STATUS NEQ NMA$C_STS_SUC	! If not successful,
	THEN
	    INFO_RETURNED = TRUE;	! Then mark information (an error)
					! WAS returned.
	END;

    IF NOT .INFO_RETURNED		! If no information was returned,
    THEN
	BEGIN
	NCP$WRITESHO(ASCID('No information in database'));
	NCP$WRITESHO(ASCID(' '));
	END;

    NCP$CLOSESHO ();			! Close the output file

    RETURN SUCCESS;			! Never a syntax error reported here

    END;

%SBTTL	'NCP$HNDL_SHOLIS  Handler to Close Output'
ROUTINE NCP$HNDL_SHOLIS (SIG, MECH, ENBL) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is a condition handler for the show/list output routines.
!	It closes the output file, if it sees the unwind signal
!	otherwise it just resignals the condition.
!
! FORMAL PARAMETERS:
!
!	SIG		Address of signal array
!	MECH		Address of mechanism array
!	ENBL		Address of mechanism array (none)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,		! Map the arguments to vectors
	MECH : REF VECTOR,
	ENBL : REF VECTOR
	;

    IF .SIG [1] EQL SS$_UNWIND		! Check for the unwind condition
    THEN
	BEGIN
	NCP$CLOSESHO ();		! Close the show/list output file
	RETURN SUCCESS			! Return value is irrelavent
	END
    ELSE
	RETURN SS$_RESIGNAL		! Resignal the condition

    END;

%SBTTL	'ACT$VRB_LOOP  Action Routine for LOOP Command'
GLOBAL ROUTINE ACT$VRB_LOOP (OPT, STRCNT, STRPTR, TKNCNT, TKNPTR,
    				CHR, NUM, PSDB) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform the loop command.  Build the message and send it.
!	The loop command message is similar to other message formats
!	but to handle access control properly we need a special action
!	routine.
!
! FORMAL PARAMETERS:
!
!	Parse state table
!	PSDB		Address of the SDB for the loop entity
!
! IMPLICIT INPUTS:
!
!	NCP$GL_FNC_CODE
!	NCP$GL_OPTION
!	PDB$G_LOO_ACC
!	PDB$G_LOO_PSW
!	PDB$G_LOO_USR
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Success or error signalled
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	PSDB : REF BBLOCK [SDB$C_SIZE]	! Pointer to the sdb
	;

    LOCAL
	STATUS,				! Return status
	LEN,				! Length of return
	BFR,				! Address of return
	MSGPTR				! Pointer into message
	;

    IF .NCP$GL_OPTION [NMA$V_OPT_ENT]	! If entity is not node
	NEQ NMA$C_ENT_NOD
	AND
	.NCP$GL_OPTION [NMA$V_OPT_ACC]	! there can be no access control
    THEN
	SIGNAL_STOP (NCP$_ACCLIN);

!
! If we are dealing with a V2.0 NML, then reformat any circuit requests
! into the appropriate line request.
!

    IF NOT .NCP$GL_EXELCB [LCB$B_STS]	! If link is not open yet,
    THEN
	NCP$OPENLINK(.NCP$GL_EXELCB);	! Open the link; signal any errors

    IF NOT V2_REQUESTS(.PSDB)		! Handle V2.0 conversion (if any)
    THEN
	RETURN SUCCESS;			! If error, exit from action routine

!
! Build the message prologue fields
!

    NCP$BLD_PROLOG (.PSDB, MSGPTR);	! Build the prolog for the message

    IF .NCP$GL_OPTION [NMA$V_OPT_ACC]	! If there is access control
    THEN				! store the three strings
	BEGIN
	MSGPTR =
	    CH$MOVE
		(
		CH$RCHAR (PDB$G_LOO_USR + 1) + 1,
		PDB$G_LOO_USR + 1,
		.MSGPTR
		);
	MSGPTR =
	    CH$MOVE
		(
		CH$RCHAR (PDB$G_LOO_PSW + 1) + 1,
		PDB$G_LOO_PSW + 1,
		.MSGPTR
		);
	MSGPTR =
	    CH$MOVE
		(
		CH$RCHAR (PDB$G_LOO_ACC + 1) + 1,
		PDB$G_LOO_ACC + 1,
		.MSGPTR
		);
	END
    ;

    NCP$BLD_PRMS			! Add parameters to end of message
	(
	.PSDB [SDB$L_PCL_ADR],		! Address of parameter list
	MSGPTR,				! Message pointer
	FALSE				! No parameter check
	);

    NCP$SENDMSG 			! And send the message and check the
	(				! Response for error
	.NCP$GL_EXELCB,			! Link control block
	.MSGPTR - NCP$GT_MSGBFR,	! Length of message
	NCP$GT_MSGBFR			! Message start
	);

    STATUS = NCP$READRSP		! Read the response from NML
	(
	.NCP$GL_EXELCB,			! LCB
	LEN,				! Return the length here
	BFR,				! Return buffer address here
	FALSE				! Not show or list
	);

!
!	Messages not looped is reported with errors.  The returned data
!	is ignored here.
!

    RETURN SUCCESS

    END;

%SBTTL	'V2_REQUESTS   Handle compatibility with V2.0 NML'
ROUTINE V2_REQUESTS (SDB: REF BBLOCK) =

!---
!
!	This routine handles the case where we are sending a request
!	to a V2.0 NML, which only knows about lines, instead of lines
!	and circuits.  We must reformat any circuit request into the
!	appropriate line request.
!
! Inputs:
!
!	sdb = Address of the SDB structure
!
! Outputs:
!
!	Routine = True if valid converted message, False if error in message
!---

BEGIN

LOCAL
    PCL: REF BBLOCKVECTOR [, PCL$C_SIZE];	! Parameter control list

BIND
    V2_LIST = UPLIT WORD(		! List of circuit -> line parameters
		NMA$C_PCCI_STA, NMA$C_PCLI_STA,
		NMA$C_PCCI_SER, NMA$C_PCLI_SER,
		NMA$C_PCCI_LCT, NMA$C_PCLI_LCT,
		NMA$C_PCCI_BLO, NMA$C_PCLI_BLO,
		NMA$C_PCCI_COS, NMA$C_PCLI_COS,
		NMA$C_PCCI_TRI, NMA$C_PCLI_TRI,
		-1, -1): VECTOR [,WORD,SIGNED];

IF CH$NEQ(3, NCP$GL_EXELCB [LCB$B_NMLVERS],	! If not NML V2.0,
	3, UPLIT BYTE(2,0,0), 0)
THEN
    RETURN TRUE;			! then leave the message stand as is

IF .SDB [SDB$B_ENT_TYP] LSS 0		! If not a circuit request,
    OR .NCP$GL_OPTION [NMA$V_OPT_ENT] NEQ NMA$C_ENT_CIR
THEN
    RETURN TRUE;			! Then leave the message stand as is

NCP$GL_OPTION [NMA$V_OPT_ENT] = NMA$C_ENT_LIN;	! Change to line request

!
! Here, we can't assume that the numbering scheme between V3.0 NICE circuit
! parameters and V2.0 NICE line parameters match exactly, so we must
! convert the circuit parameter code to the corresponding line parameter
! code in V2.0 NICE.  If the circuit parameter doesn't appear in this table,
! then reject it, as the remote NML wouldn't understand it anyway.
!

PCL = .SDB [SDB$L_PCL_ADR];		! Get address of PCL array

IF .NCP$GL_FNC_CODE EQL NMA$C_FNC_CHA	! If its a SET or DEFINE,
THEN
    INCRU I FROM 0			! Scan all the parameters
    DO
	BEGIN
	IF .PCL [.I, PCL$B_PRM_TYP] EQL PBK$K_END ! If end of parameter list,
	THEN
	    EXITLOOP;			! Then we are all done

	IF .BBLOCK [.PCL [.I, PCL$L_PDB_ADR], PDB$B_STS_FLG] ! If parameter specified,
	THEN
	    INCRU J FROM 0 BY 2		! For each entry in conversion list,
	    DO
		BEGIN
		IF .V2_LIST [.J] EQL -1	! If end of table,
		THEN
		    BEGIN
		    SIGNAL(NCP$_V2COMP); ! Signal conversion error
		    RETURN FALSE;
		    END;
	        IF .V2_LIST [.J] EQL .PCL [.I, PCL$W_PRM_ID] ! Match found?
	        THEN
		    BEGIN
		    IF .PCL [.I, PCL$W_PRM_ID] NEQ .V2_LIST [.J+1] ! If not the same,
		    THEN		! (assume the codes are the same
			BEGIN		! because the PCL list is read-only)
			SIGNAL(NCP$_V2COMP); ! Signal conversion error
			RETURN FALSE;
			END;
		    EXITLOOP;		! Then pronounce it OK
		    END;
		END;
	END;

RETURN TRUE;

END;

%SBTTL	'NCP$BLD_PROLOG  Build Prolog for a Message'
ROUTINE NCP$BLD_PROLOG (PSDB, MSGPTR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Build the prolog for most NICE command messages.
!	The components are: Possible system specific code,
!	function code, option byte and entity.
!
! FORMAL PARAMETERS:
!
!	PSDB		Address of the SDB describing the command
!	MSGPTR		Address of the pointer to build the message
!
! IMPLICIT INPUTS:
!
!	NCP$GL_FNC_CODE		Function code byte
!	NCP$GL_OPTION		Option byte
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	PSDB : REF BBLOCK [SDB$C_SIZE]
	;

    .MSGPTR = CH$PTR (NCP$GT_MSGBFR);	! Set the pointer to the buffer

    NCP$GL_ENTITY = .PSDB [SDB$B_ENT_TYP];  ! Copy entity type code.  If
					! negative, indicates system-specific

    IF .PSDB [SDB$B_ENT_TYP] LSS 0	! Is this a system specific entity?
    THEN
	BEGIN				! Build the system specific header
	CH$COPY
	    (
	    2,
	    UPLIT (BYTE (NMA$C_FNC_SYS,	! System specific
	    		NMA$C_SYS_VMS	! VMS system
	    		)
	    	),
	    0, 2, ..MSGPTR
	    );

	.MSGPTR = CH$PLUS (..MSGPTR, 2)	! Update message pointer
	END
    ;

!
!   Write the function code and option byte to the message
!

    CH$WCHAR_A (.NCP$GL_FNC_CODE, .MSGPTR);
    CH$WCHAR_A (.NCP$GL_OPTION, .MSGPTR);

    NCP$BLD_ENTITY (.PSDB, .MSGPTR);	! Build the entity next

    RETURN

    END;

%SBTTL	'NCP$BLD_ENTITY  Build Entity into Message'
ROUTINE NCP$BLD_ENTITY (PSDB, MSGPTR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Build an entity description into a NICE message.
!	An entity is a format type byte followed by a byte string.
!	If the format type is negative only it is copied.
!	If the format type is zero, the following two bytes are copied.
!	If the format type is positive, that number of bytes is copied.
!	If the entity type is logging, only the format type byte is copied
!	if it is positive since only that byte is used.
!
! FORMAL PARAMETERS:
!
!	PSDB		Address of an SDB
!	MSGPTR		Address of a character pointer to build message
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	PSDB : REF BBLOCK [SDB$C_SIZE]
	;

    LOCAL
	ENTFMT,
	SPTR					! Pointer to source
	;		!

    SPTR = CH$PTR (.PSDB [SDB$L_ENT_ADR], 1);	! Make it a pointer to PDB
    ENTFMT = CH$RCHAR_A (SPTR);			! Read the entity

    CH$WCHAR_A (.ENTFMT, .MSGPTR);		! Copy the entity format

    IF .PSDB [SDB$B_ENT_TYP]			! If the entity is logging
    	EQL
    	NMA$C_ENT_LOG
    THEN					! Then only save the code byte
	RETURN
    ;

    IF .ENTFMT <0,8,1> EQL 0			! If the entity is a node adr
    THEN
	BEGIN
	CH$MOVE (2, .SPTR, ..MSGPTR);		! Move the two bytes of node
	.MSGPTR = CH$PLUS (..MSGPTR, 2)		! Adr and update the pointer
	END

    ELSE
	IF .ENTFMT <0,8,1> GTR 0		! If its a string
	THEN
	    BEGIN
	    CH$MOVE (.ENTFMT, .SPTR, ..MSGPTR);	! Copy the string
	    .MSGPTR = CH$PLUS (..MSGPTR, .ENTFMT) ! Update the pointer
	    END
    ;

    RETURN

    END;

%SBTTL	'NCP$BLD_PRMS	Build Parameters into Message'
ROUTINE NCP$BLD_PRMS (PLIST, MSGPTR, CHKFLG) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Build a list of parameters into a NICE message.
!	The parameters are described by a list which gives the format
!	of the parameter, its two byte code and the address of the
!	parameter data block containing the parameter data.
!
! FORMAL PARAMETERS:
!
!	PLIST		Address of the parameter descriptor list
!	MSGPTR		Address of the pointer to the next byte of the
!			NICE message being built.
!	CHKFLG		True for enable check to require at least one
!			parameter or ALL
!			False for disable check and allow no parameters
!
! IMPLICIT INPUTS:
!
!	PDB$G_VRB_ALL	The all parameter
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Novalue, error signaled if no parameters saved
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	PLIST :				! Pointer to a parameter control list
		REF BBLOCKVECTOR [1, PCL$C_SIZE]
	;

    LOCAL
	PCTR,				! Counter of parameters used
	PTR				! Local address pointer
	;		!




    PCTR = 0;				! No parameters used yet

    INCRU IDX FROM 0			! Scan the list
    DO
	BEGIN
	IF .PLIST [.IDX, PCL$B_PRM_TYP]	! Look for end of list
		EQL
	   PBK$K_END
	THEN EXITLOOP			! We found it so quit
	;

	IF .(.PLIST [.IDX, PCL$L_PDB_ADR]) ! If the parameter is present
	THEN
	    BEGIN

!
! 	Move the parameter id and update the message pointer
!

	    (..MSGPTR) <0, 16, 0> =		! Save it as a word
		.PLIST [.IDX, PCL$W_PRM_ID];
	    .MSGPTR = ..MSGPTR + 2;		! Update the pointer

!
! 	Build an address to the data of the parameter
!

	    PTR = .PLIST [.IDX, PCL$L_PDB_ADR] + 1;


!
! 	Dispatch for each type of parameter
!

	    CASE .PLIST [.IDX, PCL$B_PRM_TYP]
	    		FROM PBK$K_LOW
	    		TO PBK$K_HIGH
	    		OF
	    SET

	    [PBK$K_NUMB] :			! Number byte
	    	CH$WCHAR_A (..PTR, .MSGPTR)
		;

	    [PBK$K_LITB] :			! Literal byte
		;				! Do nothing for CLEAR/PURGE
						! We want only the ID

	    [PBK$K_NUMW] :			! Number word
		BEGIN
		(..MSGPTR) <0, 16, 0> = ..PTR;
		.MSGPTR = ..MSGPTR + 2
		END
		;

	    [PBK$K_NUML, PBK$K_LITL, PBK$K_SAD] : ! Number long word
		BEGIN
		..MSGPTR = ..PTR;
		.MSGPTR = ..MSGPTR + 4
		END
		;


!
! 	Any type of counted string
!

	    [PBK$K_TKN, PBK$K_TKNQ, PBK$K_STRQ, PBK$K_HXPS,
		PBK$K_PRVL, PBK$K_PRVC] :
		IF CH$RCHAR(.PTR) GTRU 127	! If plural form (ACTIVE, KNOWN),
		THEN				! then copy plural form byte
		    CH$WCHAR_A (CH$RCHAR_A (PTR), .MSGPTR)
		ELSE				! else copy ascic string
		    BEGIN
		    CH$MOVE(CH$RCHAR(.PTR)+1, .PTR, ..MSGPTR);
		    .MSGPTR = ..MSGPTR + CH$RCHAR(.PTR) + 1;
		    END;


!
! 	Node address or name
!

	    [PBK$K_NADR] :
		BEGIN
		IF CH$RCHAR (.PTR) EQL 0	! If its an address
		THEN				! Copy the address
		    BEGIN
		    CH$MOVE (3, .PTR, ..MSGPTR);
		    .MSGPTR = CH$PLUS (..MSGPTR, 3)
		    END
		ELSE				! Copy the name otherwise
		    BEGIN
		    IF CH$RCHAR (.PTR) GTRU 127 ! Is it a plural form?
		    THEN			! Copy the plural byte code
			CH$WCHAR_A (CH$RCHAR_A (PTR), .MSGPTR)
		    ELSE			! Copy the string
			BEGIN
			CH$MOVE
			    (.(.PTR) <0,8,0> + 1,
			    .PTR, ..MSGPTR)
			;
			.MSGPTR =
			    CH$PLUS
				(..MSGPTR,
				.(.PTR) <0,8,0> + 1)
			END
		    END
		END
		;


!
! 	Object number or name
!

	    [PBK$K_OBJ]:
		IF CH$RCHAR (.PTR) EQL 0	! If its an address
		THEN				! Copy the number (byte)
		    BEGIN
		    CH$MOVE (2, .PTR, ..MSGPTR);
		    .MSGPTR = CH$PLUS (..MSGPTR, 2);
		    END
		ELSE				! Copy the name otherwise
		    BEGIN
		    CH$MOVE(CH$RCHAR(.PTR)+1, .PTR, ..MSGPTR);
		    .MSGPTR = ..MSGPTR + CH$RCHAR(.PTR) + 1;
		    END;


!
! 	Entity type and ID
!
!	Byte of entity type code, followed by:
!		If node:	word(address) OR ascic(name)
!		Any other:	ascic(name)
!

	    [PBK$K_ENT]:
		BEGIN
		CH$WCHAR_A (CH$RCHAR_A (PTR), .MSGPTR);	! Copy entity type code
		IF CH$RCHAR(.PTR-1) EQL NMA$C_ENT_NOD	! If node entity
		    OR CH$RCHAR (.PTR) EQL 0	! and if its a node address
		THEN				! Copy the address
		    BEGIN
		    CH$MOVE (3, .PTR, ..MSGPTR);
		    .MSGPTR = ..MSGPTR + 3;
		    END
		ELSE				! Copy the name otherwise
		    BEGIN
		    IF CH$RCHAR (.PTR) GTRU 127 ! Is it a plural form?
		    THEN			! Copy the plural byte code
			CH$WCHAR_A (CH$RCHAR_A (PTR), .MSGPTR)
		    ELSE			! Copy the string
			BEGIN
			CH$MOVE(CH$RCHAR(.PTR)+1, .PTR, ..MSGPTR);
			.MSGPTR = ..MSGPTR + CH$RCHAR(.PTR) + 1;
			END;
		    END;
		END;


!
!	Event type codes
!

!
!	Event Parameter Format in PDB
!
!	offset	size		data
!
!	0	word		event class
!				bits 14,15 = 3 for wild event class and events
!				bits 14,15 = 2 for wild events
!	2	byte		size of next field
!	3	8 bytes		event type mask
!	11	byte		source type (-1 none, 0 node, 1 line, 3 circuit)
!	12	byte		source code
!	13	bytes		source entity
!

!
!	Event Parameter Format in Message
!
!	size	data
!
!	byte	Source type
!	byte	Source code
!	bytes	Source entity
!	word	Event class
!	byte	Size of event mask
!	bytes	Event mask, not present if wild class or events
!


!
! 	Build Event Code Into a Message
!

	    [PBK$K_ESET TO PBK$K_ESEX, PBK$K_ESCI] :
		BEGIN
					! Write the source type
		CH$WCHAR_A (.(.PTR + 11), .MSGPTR);
		IF .(.PTR + 11) <0, 8, 1>! Look at the source type
		    NEQ
		    -1 			! If its present
		THEN
		    BEGIN		! If the source type is node
		    IF  (CH$RCHAR (.PTR + 11)
			EQL
			0)
			AND		! If the node is an address
			(CH$RCHAR (.PTR + 12)
			EQL
			0)
		    THEN
			BEGIN
			CH$MOVE		! Move the address
			    (3, .PTR + 12, ..MSGPTR)
			;
			.MSGPTR =	! Update the message pointer too
			    CH$PLUS
				(..MSGPTR, 3)
			END
		    ELSE
			BEGIN		! If the source is a token
			CH$MOVE		! Move the token and its count
			    (.(.PTR + 12) <0, 8, 0> + 1,
			    .PTR + 12, ..MSGPTR)
			;
			.MSGPTR =	! And update the message pointer
			    CH$PLUS
				(..MSGPTR, .(.PTR+12) <0, 8, 0> + 1)
			END
		    END
		;
!
! 	Write the Event class and Mask to the message last
!


		IF .(.PTR) <14, 2, 0> NEQ 0	! Look at the wild bits
		THEN
		    BEGIN			! Something is wild,
		    (..MSGPTR) <0, 16, 0> = ..PTR; ! copy class only
		    .MSGPTR = ..MSGPTR + 2
		    END
		ELSE
		    BEGIN			! Nothing wild, take all
		    CH$MOVE (11, .PTR, ..MSGPTR);
		    .MSGPTR = CH$PLUS (..MSGPTR, 11)
		    END
		END
		;


	    [OUTRANGE, PBK$K_END, PBK$K_TRIPL] : ! For anything strange
		EXITLOOP;

	    TES
	    ;
	    PCTR = .PCTR + 1;			! Count one more parameter
	    END

	END;

    IF ( (.PCTR EQL 0) AND .CHKFLG)		! If there are no parameters
	AND					! and the check is enabled
	(NOT .PDB$G_VRB_ALL)			! and ALL was not specified
    THEN SIGNAL_STOP (NCP$_NOPARM)		! Signal an error
    ;

    RETURN

    END;

END				!End of module
ELUDOM
