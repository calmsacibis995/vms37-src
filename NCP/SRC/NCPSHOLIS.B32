%TITLE	'Process Returns from SHOW and LIST'
MODULE NCPSHOLIS (IDENT = 'V03-010',
		ADDRESSING_MODE(EXTERNAL=GENERAL),
		ADDRESSING_MODE(NONEXTERNAL=GENERAL)) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Network Control Program (NCP)
!
! ABSTRACT:
!
!	This module contains routines to process and print returns from
!	show and list commands.
!
! ENVIRONMENT:	VAX/VMS Operating System
!
! AUTHOR:	Darrell Duffy	, CREATION DATE:  13-November-1979
!
! MODIFIED BY:
!
!	V010	TMH0010		Tim Halvorsen	04-Mar-1982
!		Fix display headers to use "circuit" rather than "line".
!
!	V009	TMH0009		Tim Halvorsen	19-Feb-1982
!		Fix SHOW STATUS LINKS display to show "state" column.
!
!	V008	TMH0008		Tim Halvorsen	11-Jan-1982
!		Add V2.0 NICE mapping to process SHOW returns from
!		older systems.
!
!	V007	TMH0007		Tim Halvorsen	 2-Dec-1981
!		Add check to verify that the NICE response to a SHOW
!		request returned the parameters in ascending order,
!		as an additional level of NML validation.  We will
!		continue to output all the parameters, regardless of
!		order, but issue a warning message about the NICE
!		protocol violation to catch problems in NML.
!		Reformat LINKS display to include "remote ID".
!
!	V006	TMH0006		Tim Halvorsen	25-Nov-1981
!		Display source type (Line, Circuit, Node, etc)
!		in the source column, so display distinguishes
!		between source lines and circuits.  Display
!		"(all sources)" for global event masks.
!
!	V005	TMH0005		Tim Halvorsen	11-Nov-1981
!		Show circuit type in source column for show logging.
!		Output "No information available" message if no parameters
!		are returned in a show response message.
!
!	V004	TMH0004		Tim Halvorsen	28-Aug-1981
!		Add compatibility for 2.0 NML show link messages.
!
!	V003	TMH0003		Tim Halvorsen	25-Aug-1981
!		Display links as a single line per link
!		rather than multi-column format.
!
!	V002	TMH0002		Tim Halvorsen	07-Jul-1981
!		Complete code to display circuits
!
!	V001	TMH0001		Tim Halvorsen	22-Jun-1981
!		Add Circuit entity.  Re-do display code to detect
!		system-specific entities vs. NICE entities.
!--

%SBTTL	'Definitions'

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	NCP$SHOHEAD	: NOVALUE,	! Print heading for show/list
	NCP$SHOCOLHEAD	: NOVALUE,	! Setup heading for column output
	NCP$SHOLIS	: NOVALUE,	! Print all params for a return
	NCP$SHOCOLFMT	: ,		! Produce column output
	NCP$SHOENTITY	: NOVALUE,	! Convert entity in return
	V2_SHOW_COMPAT,			! V2.0 NML SHOW response compatibility
	NCP$FORMATPARM 	: NOVALUE,	! Format a parameter or counter
	NCP$PARSEPARM 	: NOVALUE,	! Parse a parameter into text
	NCP$PARSECOUNTER : NOVALUE,	! Parse a counter into text
	NCP$PARSEVENTS 	: NOVALUE,	! Parse an event mask into text
	NCP$PTBSEARCH,			! Search a parameter table
	NCP$FAOSET 	: NOVALUE,	! Setup fao pointers
	NCP$ADDSTR 	: NOVALUE,	! Add one string to another
	NCP$ADDFAO 	: NOVALUE,	! Add an entry to the fao list
	NCP$FAOWRITE 	: NOVALUE,	! Convert and write fao string
	NCP$FAOL	: NOVALUE,	! Convert fao parameters
	NCP$PRIVBITS 	: NOVALUE	! Convert privilege mask to text
	;		!

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:STARLET';
LIBRARY 'LIB$:NMALIBRY';
LIBRARY 'LIB$:NCPLIBRY';


!
! EQUATED SYMBOLS:
!

LITERAL
	FAOLSTSIZ	= 100,		! Size of the fao arg list
	CTRBUFSIZ	= 500,		! Size of control string buffer
	OUTBUFSIZ	= 500		! Size of fao output buffer
	;



!
!	Headers for column output
!

BIND

    NCP$Q_COLNODSUMHDR =

	ASCID
	(

'    Node           State      Active  Delay   Circuit',
%char(13), %char(10),
'                              Links',
%char(13), %char(10), ' '

	),

    NCP$Q_COLNODSTAHDR =

	ASCID
	(

'    Node           State      Active  Delay    Type      Cost   Hops   Circuit',
%char(13), %char(10),
'                              Links',
%char(13), %char(10), ' '

	),

    NCP$Q_COLCIRSTAHDR =

	ASCID
	(

'   Circuit          State                   Loopback     Adjacent     Block',
%char(13), %char(10),
'                                              Name         Node       Size',
%char(13), %char(10), ' '

	),

    NCP$Q_COLCIRSUMHDR =

	ASCID
	(

'   Circuit          State                   Loopback     Adjacent',
%char(13), %char(10),
'                                              Name         Node',
%char(13), %char(10), ' '

	),

    NCP$Q_COLLINSTAHDR =

	ASCID
	(

'   Line             State',
%char(13), %char(10), ' '

	),

    NCP$Q_COLLINSUMHDR =

	ASCID
	(

'   Line             State',
%char(13), %char(10), ' '

	),

    NCP$Q_COLLNKHDR =			! Header for links

	ASCID
	(

'   Link       Node           PID     Process     Remote link  Remote user',
%char(13), %char(10), ' '

	),

    NCP$Q_COLLNKSTAHDR =		! Header for link status

	ASCID
	(

'   Link       Node           PID     Process     Remote link  State',
%char(13), %char(10), ' '

	),

    NCP$Q_COLOBJHDR =			! Header for Objects

	ASCID
	(

'   Object   Number  File/PID         User Id          Password',
%char(13), %char(10), ' ',
%char(13), %char(10)

	),

    NCP$Q_COLLOGSTAHDR =		! Header for logging status

	ASCID
	(

'    Sink Node     Source               Events         State',
%char(13), %char(10), ' ',
%char(13), %char(10)

	),

    NCP$Q_COLLOGSUMHDR =		! Header for logging summary

	ASCID
	(

'    Sink Node     Source               Events         State Name',
%char(13), %char(10), ' ',
%char(13), %char(10)

	)

    ;


!
!	Parameter tables for column output
!

!
!	Tables have the following format
!	Word (parameter id code),
!	Byte (offset into line, size of field in line),
!	...
!	Word (-1)
!

BIND

    NCP$T_COLNODSUMTBL =		! Node summary

	UPLIT
	(
	WORD (NMA$C_PCNO_STA), BYTE (17, 11),
	WORD (NMA$C_PCNO_ACL), BYTE (29, 5),
	WORD (NMA$C_PCNO_DEL), BYTE (37, 5),
	WORD (NMA$C_PCNO_DLI), BYTE (46, 16),
	WORD (NMA$C_PCNO_NLI), BYTE (46, 16),
	WORD (-1)
	)
	,

    NCP$T_COLNODSTATBL =		! Node status

	UPLIT
	(
	WORD (NMA$C_PCNO_STA), BYTE (17, 11),
	WORD (NMA$C_PCNO_ACL), BYTE (29, 5),
	WORD (NMA$C_PCNO_DEL), BYTE (37, 5),
	WORD (NMA$C_PCNO_DTY), BYTE (45, 10),
	WORD (NMA$C_PCNO_DCO), BYTE (56, 5),
	WORD (NMA$C_PCNO_DHO), BYTE (63, 5),
	WORD (NMA$C_PCNO_DLI), BYTE (71, 16),
	WORD (NMA$C_PCNO_NLI), BYTE (71, 16),
	WORD (-1)
	)
	,

    NCP$T_COLCIRSTATBL =		! Circuit status

	UPLIT
	(
	WORD (NMA$C_PCCI_STA), BYTE (20, 7),
	WORD (NMA$C_PCCI_SUB), BYTE (29, 15),
	WORD (NMA$C_PCCI_LOO), BYTE (45, 6),
	WORD (NMA$C_PCCI_ADJ), BYTE (53, 14),
	WORD (NMA$C_PCCI_BLO), BYTE (69, 5),
	WORD (-1)
	),

    NCP$T_COLLINSTATBL =		! Line status

	UPLIT
	(
	WORD (NMA$C_PCLI_STA), BYTE (20, 7),
	WORD (NMA$C_PCLI_SUB), BYTE (29, 15),
	WORD (NMA$C_PCLI_LOO), BYTE (45, 6),
	WORD (NMA$C_PCLI_ADJ), BYTE (53, 14),
	WORD (NMA$C_PCLI_BLO), BYTE (69, 5),
	WORD (-1)
	),

    NCP$T_COLLNKTBL =			! Link display

	UPLIT
	(
	WORD (NMA$C_PCLK_NID), BYTE (9,14),	! Node ID
	WORD (NMA$C_PCLK_PID), BYTE (27,8),	! PID of local process
	WORD (NMA$C_PCLK_PRC), BYTE (37,16),	! Local process name
	WORD (NMA$C_PCLK_RLN), BYTE (55,5),	! Remote link number
	WORD (NMA$C_PCLK_RID), BYTE (62,16),	! Remote ID (username or PID)
	WORD (-1)
	),

    NCP$T_COLLNKSTATBL =		! Link status display

	UPLIT
	(
	WORD (NMA$C_PCLK_NID), BYTE (9,14),	! Node ID
	WORD (NMA$C_PCLK_PID), BYTE (27,8),	! PID of local process
	WORD (NMA$C_PCLK_PRC), BYTE (37,16),	! Local process name
	WORD (NMA$C_PCLK_RLN), BYTE (55,5),	! Remote link number
	WORD (NMA$C_PCLK_STA), BYTE (62,10),	! State
	WORD (-1)
	),

    NCP$T_COLOBJTBL =			! Object display

	UPLIT
	(
	WORD (NMA$C_PCOB_NUM), BYTE (13,5),	! Object number
	WORD (NMA$C_PCOB_FID), BYTE (20,16),	! File id
	WORD (NMA$C_PCOB_PID), BYTE (20,16),	! Process id
	WORD (NMA$C_PCOB_USR), BYTE (37,16),	! User id
	WORD (NMA$C_PCOB_PSW), BYTE (54,16),	! Password
	WORD (-1)
	),

    NCP$T_COLLOGTBL =			! Logging display

	UPLIT
	(

	WORD (NMA$C_PCLO_STA), BYTE (55,4),	! Logging state
	WORD (NMA$C_PCLO_LNA), BYTE (60,32),	! Logging name
	WORD (NMA$C_PCLO_EVE), BYTE (18,36),	! Events
	WORD (NMA$C_PCLO_SIN), BYTE (3,14),	! Sink node
	WORD (-1)
	)
	;


!
! OWN STORAGE:
!

OWN
	FAOPTR,				! Pointer to fao list
	FAOLST : VECTOR [FAOLSTSIZ],	! List of args for FAO
	CTRBUF : VECTOR [CTRBUFSIZ, BYTE], ! Control string for fao
	OUTDSC : VECTOR [2],		! Descriptor of output buffer
	OUTBUF : VECTOR [OUTBUFSIZ,BYTE], ! Fao output buffer
	PREV_PARAM_CODE,		! Previous NICE parameter code to check
					! if params are in ascending order
	NCP$A_COLHEAD,			! Address of descriptor for header
	NCP$B_COLHEAD	: BYTE,		! True for head printed
	NCP$B_LOGTYPE	: BYTE,		! Type code for logging
	NCP$A_COLTBL;			! Table for column output

GLOBAL
	NCP$GQ_CTRDSC : VECTOR [3]	! Descriptor of control string
	;

BIND
	CTRDSC = NCP$GQ_CTRDSC : VECTOR [3] ! Local alias
	;

!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
	NCP$_BADMSG,			! Invalid management message
	NCP$_LOGIC,			! NCP logic error
	NCP$_PARMORDER;			! SHOW response not in ascending order

EXTERNAL
	NCP$GA_TBL_EVESOUR,		! Event source table
	NCP$GL_OPTION : BBLOCK,		! Option byte
	NCP$GL_ENTITY : SIGNED,		! Entity type code.  If negative,
					! system-specific entity (NMA$C_SENT_)
	PDB$G_VRB_ENT : BBLOCK;		! Plural entity type code
					! (Known, Active, etc.)

EXTERNAL
	NCP$GA_PRM_NOD,			! Parameter tables
	NCP$GA_PRM_CIR,
	NCP$GA_PRM_LIN,
	NCP$GA_PRM_LOG,
	NCP$GA_PRM_OBJ,
	NCP$GA_PRM_LNK,
	NCP$GA_PRM_COUNTER;		! Counter table

EXTERNAL ROUTINE
	NCP$TABLESEARCH,		! Search for table entry
	NCP$WRITESHO : NOVALUE		! Write a message to show/list output
	;

%SBTTL	'NCP$SHOHEAD  Display Heading for SHOW and LIST'
GLOBAL ROUTINE NCP$SHOHEAD :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Create and display the standard heading for show and list data.
!	The parts come from the option byte and the entity which were
!	used to build the message originally.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NCP$GL_OPTION		Option byte
!	NCP$GL_ENTITY		Entity type code (negative if system-specific)
!	PDB$G_VRB_ENT		Plural entity code (known, active, etc.)
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    NCP$FAOSET ();			! Set the fao pointers

    ADDSTR (' !/ !/');			! Setup some formatting

    SELECTONE .(PDB$G_VRB_ENT [PDB$T_DATA]) <0, 8, 1>
    OF					! Plural entity formats
	SET
	[NMA$C_ENT_ACT] : ADDSTR ('Active ');
	[NMA$C_ENT_LOO] : ADDSTR ('Loop ');
	[NMA$C_ENT_KNO] : ADDSTR ('Known ');
	TES;

    SELECTONE .NCP$GL_ENTITY		! The type of entity
    OF
	SET
	[NMA$C_ENT_NOD] : ADDSTR ('Node');
	[NMA$C_ENT_LIN] : ADDSTR ('Line');
	[NMA$C_ENT_LOG] : ADDSTR ('Logging');
	[NMA$C_ENT_CIR] : ADDSTR ('Circuit');
	[NMA$C_ENT_MOD] : ADDSTR ('Module');
	[-NMA$C_SENT_OBJ] : ADDSTR ('Object');
	[-NMA$C_SENT_LNK] : ADDSTR ('Link');
	TES;

    IF .NCP$GL_OPTION [NMA$V_OPT_INF] NEQ NMA$C_OPINF_COU
    THEN
	BEGIN
	IF .NCP$GL_OPTION [NMA$V_OPT_PER] ! Indicate this is SHOW or LIST
	THEN
	    ADDSTR (' Permanent')	! List
	ELSE
	    ADDSTR (' Volatile')	! Show
	END;

    SELECTONE .NCP$GL_OPTION [NMA$V_OPT_INF]	! Information type
    OF
	SET
	[NMA$C_OPINF_SUM] : ADDSTR (' Summary');
	[NMA$C_OPINF_STA] : ADDSTR (' Status');
	[NMA$C_OPINF_CHA] : ADDSTR (' Characteristics');
	[NMA$C_OPINF_COU] : ADDSTR (' Counters');
	[NMA$C_OPINF_EVE] : ADDSTR (' Events');
	TES;

    ADDSTR (' as of !20%D!/ ');		! And the exact date and time
    ADDFAO (0);				! Quadword code for system datetime
    ADDFAO (0);

    NCP$FAOWRITE ();			! Convert and write it to file

    NCP$SHOCOLHEAD ();			! Set up for column header output

    RETURN

    END;

%SBTTL	'NCP$SHOCOLHEAD  Setup Header for Column Output'
ROUTINE NCP$SHOCOLHEAD :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Set the addresses of the column header text string and parameter
!	decoding table if column output should be used for this return.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NCP$GL_OPTION		Option byte
!	NCP$GL_ENTITY		Entity type code (negative if system-specific)
!
! IMPLICIT OUTPUTS:
!
!	NCP$A_COLHEAD
!	NCP$A_COLTBL
!	NCP$B_COLHEAD
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	INFO;				! Type of info requested

    NCP$A_COLHEAD = 0;			! Assume not a column display
    NCP$A_COLTBL = 0;

    INFO = .NCP$GL_OPTION [NMA$V_OPT_INF];	! Get type of information

    SELECTONE .NCP$GL_ENTITY		! Dispatch on entity type
    OF
	SET
	[NMA$C_ENT_NOD]:
	    IF NOT .NCP$GL_OPTION [NMA$V_OPT_PER]	! Volatile only:
	    THEN
		IF .INFO EQL NMA$C_OPINF_SUM		! Node summary
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLNODSUMHDR;
		    NCP$A_COLTBL = NCP$T_COLNODSUMTBL;
		    END
		ELSE IF .INFO EQL NMA$C_OPINF_STA	! Node status
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLNODSTAHDR;
		    NCP$A_COLTBL = NCP$T_COLNODSTATBL;
		    END;

	[NMA$C_ENT_CIR]:
	    IF NOT .NCP$GL_OPTION [NMA$V_OPT_PER]	! Volatile only:
	    THEN
		IF .INFO EQL NMA$C_OPINF_STA		! Circuit status
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLCIRSTAHDR;
		    NCP$A_COLTBL = NCP$T_COLCIRSTATBL;
		    END
		ELSE IF .INFO EQL NMA$C_OPINF_SUM	! Circuit summary
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLCIRSUMHDR;
		    NCP$A_COLTBL = NCP$T_COLCIRSTATBL;
		    END;

	[NMA$C_ENT_LIN]:
	    IF NOT .NCP$GL_OPTION [NMA$V_OPT_PER]	! Volatile only:
	    THEN
		IF .INFO EQL NMA$C_OPINF_STA		! Line status
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLLINSTAHDR;
		    NCP$A_COLTBL = NCP$T_COLLINSTATBL;
		    END
		ELSE IF .INFO EQL NMA$C_OPINF_SUM	! Line summary
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLLINSUMHDR;
		    NCP$A_COLTBL = NCP$T_COLLINSTATBL
		    END;

	[-NMA$C_SENT_LNK]:
	    IF NOT .NCP$GL_OPTION [NMA$V_OPT_PER]	! Volatile only:
	    THEN
		IF .INFO EQL NMA$C_OPINF_SUM		! Link summary
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLLNKHDR;
		    NCP$A_COLTBL = NCP$T_COLLNKTBL;
		    END
 		ELSE IF .INFO EQL NMA$C_OPINF_STA	! Link status
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLLNKSTAHDR;
		    NCP$A_COLTBL = NCP$T_COLLNKSTATBL;
		    END;

	[-NMA$C_SENT_OBJ]:
	    IF NOT .NCP$GL_OPTION [NMA$V_OPT_PER]	! Volatile only:
	    THEN
		IF .INFO EQL NMA$C_OPINF_STA		! Object status
		    OR .INFO EQL NMA$C_OPINF_SUM	! Object summary
		THEN
		    BEGIN
		    NCP$A_COLHEAD = NCP$Q_COLOBJHDR;
		    NCP$A_COLTBL = NCP$T_COLOBJTBL
		    END;

	[NMA$C_ENT_LOG]:
	    IF .INFO EQL NMA$C_OPINF_STA		! Logging status
	    THEN
		BEGIN
		NCP$A_COLHEAD = NCP$Q_COLLOGSTAHDR;
		NCP$A_COLTBL = NCP$T_COLLOGTBL
		END
	    ELSE IF .INFO EQL NMA$C_OPINF_SUM		! Logging summary
	    THEN
		BEGIN
		NCP$A_COLHEAD = NCP$Q_COLLOGSUMHDR;
		NCP$A_COLTBL = NCP$T_COLLOGTBL
		END;
	TES;

    NCP$B_COLHEAD = FALSE;			! Head not printed yet
    NCP$B_LOGTYPE = -1				! Invalid logging type

    END;

%SBTTL	'NCP$SHOLIS  Format a Single Return Message'
GLOBAL ROUTINE NCP$SHOLIS (LEN, BFR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine formats a single return message and produces
!	the title and the list of parameters or counters.
!
! FORMAL PARAMETERS:
!
!	LEN		Value of the length of the data
!	BFR		Address of the data
!
! IMPLICIT INPUTS:
!
!	NCP$GL_ENTITY	Entity code
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS,				! Return of shocolfmt
	PTR:	REF BBLOCK,		! General pointer
	PEND,				! Pointer to end of message
	CTR				! General counter
	;		!

    PTR = .BFR;				! Pointer to buffer
    PEND = .BFR + .LEN;			! End of data pointer
    PREV_PARAM_CODE = 0;		! Initialize previous parameter code
					! (used for ascending order checking)

!
!	If this is a link response message from a 2.0 NML,
!	then re-format it into 2.2 link response messages
!	recursively call ourself to format each of the links.
!	A 2.0 message consists of a node name followed by a
!	series of link/pid coded multiples.  A 2.2 message
!	describes only a single link and its attributes.  So,
!	we must reformat the 2.0 message into many 2.2 "messages".
!

    IF .ncp$gl_entity EQL -nma$c_sent_lnk  ! If its a link message
        AND CH$RCHAR(.ptr) NEQ 0	! If not a format byte of zero
    THEN
	BEGIN				! then assume its a node name
	LOCAL
	    new_buffer: BBLOCKVECTOR [32,1]; ! Allocate space for new message

	CH$FILL(0, 32, new_buffer);	! Preset entire buffer to zero
	! new_buffer [0,0,0,8,0] = 0;	! Format byte of zero
					! Leave space for word link address
	new_buffer [3,0,0,16,0] = nma$c_pclk_pid; ! Parameter code for PID
	new_buffer [5,nma$v_pty_nty] = 2; ! Hex image
	new_buffer [5,nma$v_pty_nle] = 4; ! longword
					! Leave space for longword PID
	new_buffer [10,0,0,16,0] = nma$c_pclk_nid; ! Parameter code for NID
	new_buffer [12,nma$v_pty_cod] = true;	! Coded
	new_buffer [12,nma$v_pty_mul] = true;	! Multiple
	new_buffer [12,nma$v_pty_cle] = 2;	! of 2 fields
	new_buffer [13,nma$v_pty_nle] = 2;	! Field 1 is a decimal word
	new_buffer [14,0,0,16,0] = .(.ptr) <0,16>; ! Copy node address
	new_buffer [16,nma$v_pty_asc] = true;	! Field 2 is an ASCIC string
	new_buffer [17,0,0,8,0] = CH$RCHAR(.ptr+2); ! Copy node name
	CH$MOVE(CH$RCHAR(.ptr+2), .ptr+3, new_buffer+18);

	ptr = .ptr + 3 + CH$RCHAR(.ptr+2); ! Point to first 2.0 parameter

	WHILE .ptr LEQA .pend		! For each 2.0 LAD parameter
	DO
	    BEGIN
	    IF .(.ptr) <0,16> NEQ nma$c_pclk_lad ! If not an LAD parameter,
	    THEN
		EXITLOOP;		! then get out of loop
	    new_buffer [1,0,0,16,0] = .(.ptr+4) <0,16>; ! Copy link address
	    new_buffer [6,0,0,32,0] = .(.ptr+7);	! Copy longword PID
	    ncp$sholis(18+CH$RCHAR(new_buffer+17), new_buffer); ! Display it
	    ptr = .ptr + 11;		! Skip to next LAD parameter
	    END;
	RETURN;				! Return - all done
	END;

    IF NOT 
	(STATUS = NCP$SHOCOLFMT (.LEN, .BFR, PTR) )! Try for column output
    THEN
	BEGIN
	NCP$FAOSET ();			! Set fao pointers
	NCP$SHOENTITY (PTR);		! Convert entity
	ADDSTR ('!/ ');			! Blank line
	NCP$FAOWRITE ();		! Write that much of it
	IF .PTR EQL .PEND		! If nothing else returned except
	THEN				! then entity id,
	    NCP$WRITESHO(ASCID('No information available'));
	END;

!
!	If we produced column output, we may have quit early if
!	there was a parameter we did not like to see.  We will print the
!	remainder of the parameters here in standard form.
!

    WHILE .PTR LSSA .PEND		! Scan til the end
    DO
	BEGIN				! Setup the output buffer descriptor
	OUTDSC [0] = OUTBUFSIZ;
	OUTDSC [1] = OUTBUF;

	! Check to see if the parameters returned in the NICE response
	! appear in ascending order by parameter code number.  This is
	! a DNA NICE restriction, and this is done solely to verify the
	! correctness of NML.

	IF NOT .PTR [NMA$V_CNT_COU]	! If its a parameter,
	    AND .PTR [NMA$V_PTY_TYP] LSS .PREV_PARAM_CODE ! If not in ascending order,
	THEN
	    SIGNAL(NCP$_PARMORDER);		! then signal informational msg

	PREV_PARAM_CODE = .PTR [NMA$V_PTY_TYP]; ! Save most recently parsed param code

	IF NOT V2_SHOW_COMPAT(.PTR)	! Map V2 to V3 parameters; if ignored,
	THEN
	    OUTDSC [0] = 0;		! Do not pass any result buffer

	NCP$FORMATPARM(			! Format one parameter
		.NCP$GL_ENTITY,		! Entity code
		.PTR,			! Point to start
		TRUE,			! We want a name
		TRUE,			! We want data
		OUTDSC,			! Output buffer descriptor
		OUTDSC [0],		! Return length here
		PTR);			! Return pointer here

	IF .OUTDSC [0] GTRU 0		! If non-null line,
	THEN
	    NCP$WRITESHO (OUTDSC);	! Write the line out
	END;

    IF NOT .STATUS			! If we did not use column output
    THEN
	BEGIN
	NCP$FAOSET ();			! Some blank lines at the end
	ADDSTR ('!/ !/');
	NCP$FAOWRITE ()
	END
    ;

    RETURN

    END;

%SBTTL	'NCP$SHOCOLFMT  Produce Column Output'
ROUTINE NCP$SHOCOLFMT (LEN, BFR, RTNPTR) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Format a message for column output.  We are given the buffer and
!	a table to use to format the parameters.  Write the header if
!	not written already, and change the parameter list into a line
!	of output for the table.
!	Parameters may appear in any order in the table and they may appear
!	more than once in the message and the table.  Any multiple entries
!	are used in order and additional lines are produced if no table entry
!	remains for the additional parameters.  These features are especially
!	useful for producing the link display.
!
! FORMAL PARAMETERS:
!
!	LEN		Value of the length of the buffer in bytes
!	BFR		Address of the buffer
!	RTNPTR		Return pointer here
!
! IMPLICIT INPUTS:
!
!	NCP$GL_ENTITY
!	NCP$A_COLHEAD
!	NCP$A_COLTBL
!	NCP$B_COLHEAD
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Success if written as column output
!	Failure otherwise
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	LINSIZ = 90		! Length of a line can be over 80
	;

    LOCAL
	ID,			! Parameter id temp
	IDFND,			! Bool for id found
	CTR,			! Byte counter
	PTR:	REF BBLOCK,	! Pointer into the buffer
	PEND,			! End of text
	LINDSC : VECTOR [2],	! Line descriptor
	LINBUF : VECTOR [LINSIZ, BYTE], ! Line buffer
	TBL : REF BBLOCKVECTOR [1, 4]	! Table pointer
	;		!

    LABEL
	BLDLINE			! Block to escape from
	;

    MACRO			! Table entry fields

	PRMID =  0, 0, 16, 0 %,	! Parameter id
	FLDOFF = 2, 0, 8, 0 %,	! Field offset in line
	FLDSIZ = 3, 0, 8, 0 %	! Field size in line
	;


!
!	Should we be here?
!

    IF .NCP$A_COLTBL EQL 0		! Column output wanted
	OR
	(
	.NCP$GL_ENTITY EQL NMA$C_ENT_NOD ! Check for leading executor case
	AND
	CH$RCHAR (.BFR + 2) GTR 127	! Executor bit set?
	)
    THEN
	BEGIN
	.RTNPTR = .BFR;			! Return false on no column output or
	RETURN FALSE			! Executor display is first in a node
	END				! display
    ;

    PTR = .BFR;				! Set pointer
    PEND = .BFR + .LEN;			! Set end pointer

    TBL = .NCP$A_COLTBL;		! Set table address
    CH$FILL (' ', LINSIZ, LINBUF);	! Blank the line buffer

    NCP$FAOSET ();			! Set to convert entity

    SELECTONE .NCP$GL_ENTITY OF		! Deal with the entity code
    SET

    [NMA$C_ENT_NOD] :			! Node address and name
	BEGIN
	ADDSTR ('!3UW');
	ADDFAO (.(.PTR) <0, 16, 0> );
	PTR = .PTR + 2;
	CTR = CH$RCHAR (.PTR) AND %X'7F'; ! Executor bit
	IF .CTR NEQ 0			! Is there a name present
	THEN
	    BEGIN
	    ADDSTR (' (!AC)');
	    ADDFAO (.PTR)
	    END
	;
	PTR = .PTR + .CTR + 1		! Over the node entity
	END;

    [NMA$C_ENT_CIR, NMA$C_ENT_LIN, -NMA$C_SENT_OBJ] :	! Circuit, Line or object entity
	BEGIN
	ADDSTR ('!AC');			! Counted string
	ADDFAO (.PTR);
	PTR = .PTR + CH$RCHAR_A (PTR)
	END;

    [-NMA$C_SENT_LNK]:			! Links
	BEGIN
	PTR = .PTR + 1;			! Skip by format byte (0 if link #)
	ADDSTR('!UW');			! Word link number
	ADDFAO(..PTR);
	PTR = .PTR + 2;
	END;

    [OTHERWISE] :			! For all rest including logging
	BEGIN
	LOCAL				! Save logging type for a moment
	    LOGTYP : BYTE
	    ;
	LOGTYP = CH$RCHAR (.PTR);	! Save the logging type
	ADDSTR ('!/ ');			! Blank line
	NCP$SHOENTITY (PTR);		! Print entity string
	ADDSTR ('!/ ');			! Blank line
	IF  .NCP$GL_ENTITY EQL NMA$C_ENT_LOG	! If logging
	    AND
	    .NCP$B_LOGTYPE EQL .LOGTYP	! and the type matches
	THEN
	    BEGIN
	    NCP$FAOSET ()		! Ignore the entity
	    END
	ELSE
	    BEGIN			! Otherwise print the entity
	    NCP$FAOWRITE ();		! Write it to the file
	    NCP$FAOSET ();		! And set up for next one
	    NCP$B_LOGTYPE = .LOGTYP;	! Save the log type
	    NCP$B_COLHEAD = FALSE	! Column head printed again
	    END
	END;

    TES;


    IF NOT .NCP$B_COLHEAD 		! Write header if not already
    THEN
	BEGIN
	NCP$WRITESHO (.NCP$A_COLHEAD);	! Write header
	NCP$B_COLHEAD = TRUE		! None left to write
	END
    ;

    OUTDSC [0] = OUTBUFSIZ;		! Setup output buffer
    OUTDSC [1] = OUTBUF;
    NCP$FAOL (OUTDSC);			! Convert to text and move it in

    CH$MOVE (.OUTDSC [0], .OUTDSC [1], LINBUF + 2);

    LINDSC [0] = LINSIZ;		! Describe the line for writesho
    LINDSC [1] = LINBUF;

    BLDLINE:				! Block to build the line
    BEGIN

    IDFND = FALSE;			! We have not found any parms as yet

    WHILE .PTR LSSA .PEND		! While there is data
    DO
	BEGIN
	ID = .(.PTR) <0, 16, 0>;	! Parameter id
	INCR IDX FROM 0			! Scan the table for the parm
	DO
	    BEGIN
	    IF .TBL [.IDX, PRMID] EQL 65535 ! If not found in table,
	    THEN
		BEGIN
		IF .IDFND		! If current line non-blank,
		THEN			! use multiple lines
		    BEGIN
		    NCP$WRITESHO (LINDSC);	! Write line so far
		    NCP$FAOSET ();		! Setup next one
		    CH$FILL (' ', LINSIZ, LINBUF); ! Blank the line buffer
		    IDX = 0;			! Reset to restart search
		    IDFND = FALSE		! Mark line empty again
		    END
		ELSE
		    LEAVE BLDLINE		! Not found, done here
		END
	    ;
	    IF .TBL [.IDX, PRMID] EQL .ID ! Do the id's match?
	    THEN
		BEGIN
		IF CH$EQL		! If field in line blank, use it
		    (
		    .TBL [.IDX, FLDSIZ],	  ! Size of source1
		    .TBL [.IDX, FLDOFF] + LINBUF, ! Address of source1
		    0, LINBUF,			  ! Dummy source2
		    ' '				  ! fill
		    )
		THEN
		    BEGIN
		    ID = .IDX;		! Leave with the correct index
		    EXITLOOP
		    END
		ELSE
		    IDFND = TRUE	! Just mark line non-empty and go on
		END
	    END
	;

	OUTDSC [0] = .TBL [.ID, FLDSIZ];	! Set an output descriptor
	OUTDSC [1] = .TBL [.ID, FLDOFF] + LINBUF;

	! Check to see if the parameters returned in the NICE response
	! appear in ascending order by parameter code number.  This is
	! a DNA NICE restriction, and this is done solely to verify the
	! correctness of NML.

	IF NOT .PTR [NMA$V_CNT_COU]	! If its a parameter,
	    AND .PTR [NMA$V_PTY_TYP] LSS .PREV_PARAM_CODE ! If not in ascending order,
	THEN
	    SIGNAL(NCP$_PARMORDER);		! then signal informational msg

	PREV_PARAM_CODE = .PTR [NMA$V_PTY_TYP]; ! Save most recently parsed param code

	IF NOT V2_SHOW_COMPAT(.PTR)	! Map V2 to V3 parameters; if ignored,
	THEN
	    OUTDSC [0] = 0;		! Do not pass any result buffer

	NCP$FORMATPARM(			! Format one parameter
		.NCP$GL_ENTITY,		! Entity type
		.PTR,			! Source pointer
		FALSE,			! No name for param
		TRUE,			! Data for param
		OUTDSC,			! Descriptor
		OUTDSC [0],		! Return length here
		PTR);			! Return pointer here
	END;
    END; ! Of labeled BLDLINE block

    NCP$WRITESHO (LINDSC);		! Write the line so far to output
    .RTNPTR = .PTR;			! Return pointer for remainder

    RETURN SUCCESS			! We wrote a line to output

    END;

%SBTTL	'NCP$SHOENTITY  Convert Entity in Return'
GLOBAL ROUTINE NCP$SHOENTITY (PTRADR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert an entity code in a return to fao control string and
!	parameters.
!
! FORMAL PARAMETERS:
!
!	PTRADR		Address of pointer to entity encoding in buffer
!			Return pointer past entity here
!
! IMPLICIT INPUTS:
!
!	NCP$GL_ENTITY	Entity code
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADR,				! Address of node
	CTR,				! Local counter
	PTR				! Local pointer
	;		!

    PTR = ..PTRADR;			! Setup pointer

    SELECTONE .NCP$GL_ENTITY OF		! Format the header for the block
    SET

    [NMA$C_ENT_NOD] :			! Report address and name for a node
	(
	ADR = .(.PTR) <0, 16, 0>;	! Address is two bytes
	ADDFAO (.ADR);			! Save on fao list
	PTR = .PTR + 2;
	IF .BBLOCK [.PTR, NMA$V_ENT_EXE]	! This the executor?
	THEN
	    ADDSTR     ('Executor node = !UW')	! Executor node
	ELSE
	    BEGIN
	    IF .ADR EQL 0			! Is this a loop node?
	    THEN
		ADDSTR ('Loop node =     !UW')	! Loop node
	    ELSE
		ADDSTR ('Remote node =   !UW')	! Other node
	    END
	;
	CTR = CH$RCHAR (.PTR) AND %X'7F'; ! Get count and drop exec node bit
	CH$WCHAR (.CTR, .PTR);		! Put the real count back
	IF .CTR NEQ 0			! Is there a name
	THEN
	    BEGIN			! Report the name
	    ADDSTR (' (!AC)');
	    ADDFAO (.PTR);
	    END
	;
	PTR = .PTR + .CTR + 1		! Advance the pointer
	);

    [NMA$C_ENT_LIN] :			! The line is a counted string
	(
	ADDSTR ('Line = !AC');
	ADDFAO (.PTR);
	PTR = .PTR + .(.PTR) <0,8,0> + 1
	);

    [-NMA$C_SENT_LNK]:			! Link address
	BEGIN
	PTR = .PTR + 1;			! Skip by format byte (0=link #)
	ADDSTR('Link = !UW');
	ADDFAO(..PTR);
	PTR = .PTR + 2;
	END;

    [NMA$C_ENT_LOG] :			! Logging is a byte of sink type
	(
	ADDSTR ('Logging sink type = ');
	SELECTONE .(.PTR) <0, 8, 0> OF	! Obtain the proper code
	SET

	[NMA$C_SNK_CON] : ADDSTR ('console');
	[NMA$C_SNK_FIL] : ADDSTR ('file');
	[NMA$C_SNK_MON] : ADDSTR ('monitor');

	TES
	;
	PTR = .PTR + 1
	);

    [-NMA$C_SENT_OBJ] :			! Object is a counted string
	(
	ADDSTR ('Object = !AC');
	ADDFAO (.PTR);
	PTR = .PTR + .(.PTR) <0, 8, 0> + 1
	);

    [NMA$C_ENT_CIR]:			! Circuit name is a counted string
	BEGIN
	ADDSTR ('Circuit = !AC');
	ADDFAO (.PTR);
	PTR = .PTR + CH$RCHAR(.PTR) + 1;
	END;

    TES;

    .PTRADR = .PTR;			! Return pointer beyond entity

    RETURN

    END;

%SBTTL	'V2_SHOW_COMPAT  Convert V2.0 NICE SHOW response'
ROUTINE V2_SHOW_COMPAT (PARM: REF BBLOCK) =

!---
!
!	This routine is called before each parameter is formatted
!	to convert the parameter into the appropriate V3.0 NICE
!	parameter, if we are currently connected to a V2.0 NML.
!
! Inputs:
!
!	parm = Address of parameter (starting with parameter ID word)
!
! Outputs:
!
!	Routine = True if mapped into V3 parameter; False if does not
!			apply to V3 and should be ignored.
!---

BEGIN

EXTERNAL
    NCP$GL_EXELCB: REF BBLOCK;		! Address of current LCB

IF CH$NEQ(3, NCP$GL_EXELCB [LCB$B_NMLVERS],	! If not NML V2.0,
	3, UPLIT BYTE(2,0,0), 0)
THEN
    RETURN TRUE;			! then leave the message stand as is

IF .NCP$GL_OPTION [NMA$V_OPT_ENT] NEQ NMA$C_ENT_LIN	! If not SHOW LINE response,
THEN
    RETURN TRUE;			! then leave it stand as is

IF .PARM [NMA$V_CNT_COU]		! If its a counter,
THEN
    RETURN TRUE;			! then format it as is

SELECTONEU .NCP$GL_ENTITY		! Based on original entity requested,
OF
    SET
    [NMA$C_ENT_CIR]:			! Map V2 lines -> V3 circuits
	BEGIN
	BIND LINE_TO_CIRCUIT = UPLIT WORD(
		NMA$C_PCLI_STA, NMA$C_PCCI_STA,
		NMA$C_PCLI_SER, NMA$C_PCCI_SER,
		NMA$C_PCLI_LCT, NMA$C_PCCI_LCT,
		NMA$C_PCLI_LOO, NMA$C_PCCI_LOO,
		NMA$C_PCLI_ADJ, NMA$C_PCCI_ADJ,
		NMA$C_PCLI_BLO, NMA$C_PCCI_BLO,
		NMA$C_PCLI_COS, NMA$C_PCCI_COS,
		NMA$C_PCLI_LTY, NMA$C_PCCI_TYP,
		NMA$C_PCLI_TRI, NMA$C_PCCI_TRI,
		-1, -1): VECTOR [,WORD,SIGNED];

	INCRU I FROM 0 BY 2		! For each entry in conversion table,
	DO
	    BEGIN
	    IF .LINE_TO_CIRCUIT [.I] EQL -1	! If not found in table,
	    THEN
		RETURN FALSE;		! Then ignore it

	    IF .PARM [NMA$V_PTY_TYP]	! If found in table,
		EQL .LINE_TO_CIRCUIT [.I]
	    THEN
		BEGIN
		PARM [NMA$V_PTY_TYP] = .LINE_TO_CIRCUIT [.I+1]; ! Convert ID
		RETURN TRUE;		! Format the converted parameter
		END;
	    END;
	END;

    [NMA$C_ENT_LIN]:			! Map V2 lines -> V3 lines
	BEGIN
	BIND LINE_TO_LINE = UPLIT WORD(
		NMA$C_PCLI_STA, NMA$C_PCLI_STA,
		NMA$C_PCLI_SER, NMA$C_PCLI_SER,
		NMA$C_PCLI_LCT, NMA$C_PCLI_LCT,
		NMA$C_PCLI_CON, NMA$C_PCLI_CON,
		NMA$C_PCLI_DUP, NMA$C_PCLI_DUP,
		NMA$C_PCLI_LTY, NMA$C_PCLI_PRO,
		NMA$C_PCLI_STI, NMA$C_PCLI_STI,
		NMA$C_PCLI_NTI, NMA$C_PCLI_RTT,
		2700, NMA$C_PCLI_BFN,
		-1, -1): VECTOR [,WORD,SIGNED];

	INCRU I FROM 0 BY 2		! For each entry in conversion table,
	DO
	    BEGIN
	    IF .LINE_TO_LINE [.I] EQL -1	! If not found in table,
	    THEN
		RETURN FALSE;		! Then ignore it

	    IF .PARM [NMA$V_PTY_TYP]	! If found in table,
		EQL .LINE_TO_LINE [.I]
	    THEN
		BEGIN
		PARM [NMA$V_PTY_TYP] = .LINE_TO_LINE [.I+1]; ! Convert ID
		RETURN TRUE;		! Format the converted parameter
		END;
	    END;
	END;
    TES;

END;

%SBTTL	'NCP$FORMATPARM  Return Text Format for Parameter'
GLOBAL ROUTINE NCP$FORMATPARM (ENTY, PDID, NAMQ, DATAQ, BDSC, RLEN, RPTR)
		:NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses a parameter in binary format and returns
!	the text of a description of the parameter in a buffer.
!
!	The parameters are the entity type of the parameter, and a pointer
!	to its binary representation.  Flags are passed indicating whether
!	to include the parameter name and the parameter value.
!
!	The returns are the length of the text data returned in the buffer,
!	and a pointer beyond the parameter as it was parsed.
!	
!
! FORMAL PARAMETERS:
!
!	ENTY		Entity number corresponding to the parameter
!			If negative, then system-specific entity
!	PDID		Address of the parameter ID word
!	NAMQ		True for include name in text output
!	DATAQ		True for include value in text output
!			Also pass over data and return pointer beyond it
!	BDSC		Address of buffer descriptor for text
!	RLEN		Address for returned length of text
!	RPTR		Address for returned address beyond parameter
!
! COMPLETION CODES:
!
!	Error is signaled by a called routine if it is not safe to
!	continue parsing parameters.
!--


    BEGIN

    LOCAL
	STATUS,				! General status value
	TBL,				! Address of table to search
	TYP,				! Type code from table lookup
	LST,				! Keyword list from table lookup
	TXT,				! Parameter name from table lookup
	ID : BBLOCK [LONG],		! Parameter id code
	DTY,				! Data type code
	PTR				! Pointer to parameter data
	;		!

    NCP$FAOSET ();			! Setup fao parameters

    PTR = .PDID;			! Set pointer to parameter
    ID = .(.PTR) <0, 16, 0>;		! The parameter id
    PTR = .PTR + 2;			! And advance over it

!
!	There is no real choice about getting the name or data for
!	counters.  We never print counters in a list with headers so its
!	not necessary.  You always get the name and the data for a counter.
!

    IF .ID [NMA$V_CNT_COU]		! If its a counter
    THEN
	NCP$PARSECOUNTER (.ID, PTR)	! This routine does it all
    ELSE
	BEGIN

!
!	For parameters, we select a table of data and then act based
!	on the data type code
!

	TBL =				! Select the parameter table
	    BEGIN			! Based on the entity passed
	    SELECTONE .ENTY OF		! Entity code
	    SET

	    [NMA$C_ENT_NOD] : NCP$GA_PRM_NOD ;
	    [NMA$C_ENT_CIR] : NCP$GA_PRM_CIR ;
	    [NMA$C_ENT_LIN] : NCP$GA_PRM_LIN ;
	    [NMA$C_ENT_LOG] : NCP$GA_PRM_LOG ;
	    [-NMA$C_SENT_OBJ] : NCP$GA_PRM_OBJ ;
	    [-NMA$C_SENT_LNK] : NCP$GA_PRM_LNK ;
	    [OTHERWISE] :
		SIGNAL_STOP (NCP$_BADMSG, 1,
			ASCIC ('invalid component code') )
		;

	    TES
	    END
	;


!
!	Search for the parameter to get its type and
!	a list of keywords if any and the text of its name
!

	STATUS =
	    NCP$PTBSEARCH
		(
		.TBL,
		.ID [NMA$V_PTY_TYP],
		TYP,
		LST,
		TXT
		)
	;
	IF NOT .STATUS			! Not known?
	THEN
	    TYP = PBK$K_END		! Set for 'we don't know'
	;

	IF .DATAQ AND .NAMQ		! If data wanted too, use a fixed
	THEN				! length field for the name
	    ADDSTR ('!24<')
	;

	IF .NAMQ			! If the user wants the name
	THEN				! Of the parameter
	    BEGIN
	    IF NOT .STATUS		! We don't know its name, so
	    THEN			! Concoct a name based on its id
		BEGIN
		ADDSTR ('Parameter #!UW');
		ADDFAO (.ID [NMA$V_PTY_TYP])
		END
	    ELSE
		BEGIN			! Use the params given name
		ADDSTR ('!AC');
		ADDFAO (.TXT)
		END
	    END
	;

	IF .DATAQ AND .NAMQ		! If the name and the data
	THEN
	    ADDSTR ('!> = ')		! Set the data off in some way
					! and close the fixed size field
	;

	IF .DATAQ			! If the user wants the data too
	THEN
	    BEGIN
	    DTY = .(.PTR) <0, 8, 0>;	! Obtain the data type code
	    PTR = .PTR + 1;		! And skip over it

!
!	As you might guess, this routine does all the real work of parsing
!	a parameter. It builds the text of the data and the fao list.
!	This routine signals if it cannot interpret the param in any way.
!

	    NCP$PARSEPARM (.DTY, PTR, .TYP, .LST)

	    END
	END
    ;

!
!	Now Make the text to return to the caller
!

    $FAOL			! The magic text maker
	(
	CTRSTR = CTRDSC,	! control string
	OUTLEN = .RLEN,		! Return the length here
	OUTBUF = .BDSC,		! Put the text here
	PRMLST = FAOLST		! Use this arg list
	);

    .RPTR = .PTR;		! Return the pointer past data

    RETURN

    END;

%SBTTL	'NCP$PARSECOUNTER  Parse a Counter'
ROUTINE NCP$PARSECOUNTER (ID, CPTR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses a counter and produces the necessary fao
!	control string and list entries to format the counter into text.
!
! FORMAL PARAMETERS:
!
!	ID		Value of the ID code for the counter
!	CPTR		Pointer to the counter data block,
!			returned as a pointer beyond the block
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Data inconsistancies are signalled as errors
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	ID : BBLOCK [4]			! Id has fields in it
	;

    LOCAL
	PTR,				! Pointer to counter data
	COUID,				! Id of the counter
	COUVAL,				! Value of the counter
	BITMAP,				! Things that got counted
	COUTYP,				! Data type of counter (ignored)
	COULST,				! List of counted strings
	COUTXT
	;		!

    
    PTR = ..CPTR;			! Set the local pointer to the data

    COUID = .ID [NMA$V_CNT_TYP];	! Counter id
    IF .ID [NMA$V_CNT_MAP]		! Look at the bit map bit
    THEN
	BEGIN				! We have a bitmap
	BITMAP = .(.PTR) <0, 16, 0>;	! Eat it up
	PTR = .PTR + 2			! And skip it
	END
    ELSE
	BITMAP = 0			! No bits in map
    ;

    SELECTONEU .ID [NMA$V_CNT_WID] OF	! Obtain the counter value by width
    SET

    [0] :				! NML blew it, with a reserved code
	(
	SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('reserved counter width') )
	);

    [1] :				! Its a byte
	(
	COUVAL = .(.PTR) <0, 8, 0>;
	IF .COUVAL <0, 8, 1> EQL -1	! Retain -1 to mean overflow
	THEN
	    BEGIN
	    COUVAL = -1;
	    ADDSTR ('!14<        >254!>')
	    END
	;
	PTR = .PTR + 1
	);

    [2] :				! Its a word
	(
	COUVAL = .(.PTR) <0, 16, 0>;
	IF .COUVAL <0, 16, 1> EQL -1
	THEN
	    BEGIN
	    COUVAL = -1;
	    ADDSTR ('!14<      >65534!>')
	    END
	;
	PTR = .PTR + 2
	);

    [3] :				! Its a longword counter
	(
	COUVAL = .(.PTR) <0, 32, 0>;
	IF .COUVAL EQL -1
	THEN
	    BEGIN
	    ADDSTR ('!14< >4294967294!>')
	    END
	;
	PTR = .PTR + 4
	);

    TES
    ;

    IF .COUVAL EQL -1			! Is it really overflow?
    THEN
	0				! Already taken care of
    ELSE
	BEGIN
	ADDSTR ('!14<!12UL!>');		! The counter value here
	ADDFAO (.COUVAL)
	END
    ;

    IF
	NCP$PTBSEARCH			! Look up the counter name, etc.
	    (
	    NCP$GA_PRM_COUNTER,
	    .COUID,
	    COUTYP,			! Type code
	    COULST,			! List of bitmap items
	    COUTXT			! Text of name of counter
	    )
    THEN
	BEGIN
	ADDSTR ('!AC');			! We found it return the name
	ADDFAO (.COUTXT)
	END
    ELSE
	BEGIN
	ADDSTR ('Counter #!UW');	! Generic name for we don't know
	ADDFAO (.COUID);
	COULST = 0			! We have no list either
	END
    ;

    IF .BITMAP NEQ 0			! Items in the bitmap
    THEN
	BEGIN
	ADDSTR (', including:');	! A title for them
	INCRU NBIT FROM 0 TO 15		! Scan all the bits
	DO
	    BEGIN
	    IF .BITMAP <.NBIT, 1, 0>	! If its here
	    THEN
		BEGIN
		IF .COULST EQL 0	! Is there a list of bits?
		THEN
		    BEGIN		! No use some standard title
		    ADDSTR ('!/!16* Qualifier #!UB');
		    ADDFAO (.NBIT)	! And report the bit number
		    END
		ELSE
		    BEGIN		! Report the qualifier string
		    ADDSTR ('!/!16* !AC');
		    ADDFAO (.COULST);
		    COULST =		! Advance to the next qualifier string
		    .(.COULST) <0, 8, 0> + .COULST + 1;
		    IF .(.COULST) <0, 8, 0> EQL 0
		    THEN		! No string left, report rest as bits
			COULST = 0
		    END
		END
	    END
	END
    ;

    .CPTR = .PTR;			! Return the pointer beyond data

    RETURN

    END;

%SBTTL	'NCP$PARSEPARM  Parse a Parameter'
ROUTINE NCP$PARSEPARM (DTY, PTR, TYP, LST) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses a parameter given its data type code and
!	puts text in the control string and entries in the fao list
!	to make the text for the data portion of the parameter.
!
!	Parameters are decoded in one of two ways.  By the format implicit
!	in their ID code.  This type is passed as TYP and comes from a PTB.
!	The other way is by explicit coding in the DTY code.  Even if we
!	do not know the format in the implicit case, we know the length of the
!	data so we can report the data in hexadecimal and skip the
!	data.  If the format is not consistant in some way, we signal and
!	error with a detail of the reason for the inconsistancy.
!
!	This routine is fully recursive because multiple fields contain
!	several data type codes followed by parameter data.  Runaway
!	recursion is prevented, because we reject multiple fields inside
!	of multiple fields.
!
! FORMAL PARAMETERS:
!
!	DTY		Value of the data type field
!	PTR		Address of the pointer to the data
!	TYP		Value of the type code from the PTB
!	LST		Address of the keyword list for keyword parameters
!
! IMPLICIT INPUTS:
!
!	NCP$A_COLTBL	To decide about width of integers
!	NCP$B_COLHEAD
!
! IMPLICIT OUTPUTS:
!
!	FAOLST		List of fao entries
!	CTRBUF		Control string buffer
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--


    BEGIN

    MAP
	DTY : BBLOCK [LONG]	! Data type
	;

    LOCAL
	PSTRT,			! Address of start of parameter data
	MULCTR,			! Multiple field counter
	LEN,			! Length of data
	NDTY : BBLOCK [LONG],	! New data type code, for recursion
	TXT,			! Address of text of name
	SOURTYP,		! Source type code for events
	ECLS			! Event class code
	;


!
!	If the parameter is not coded, the format of the data is
!	explicit in the data type code.
!

    IF NOT .DTY [NMA$V_PTY_COD]
    THEN
	BEGIN
	IF .DTY [NMA$V_PTY_ASC]		! Is the coding ascii image?
	THEN
	    BEGIN
	    IF .TYP EQL PBK$K_NADR	! Surround node names in ()
	    THEN ADDSTR (' (')
	    ;
	    ADDSTR ('!AC');		! Formatting is easy
	    ADDFAO (..PTR);		! And skip the data
	    CH$WCHAR			! Rewrite count minus the exec bit
		(
		CH$RCHAR (..PTR) AND %X'7F',
		..PTR
		);
	    .PTR = ..PTR + 1 + .(..PTR) <0, 8, 0>;
	    IF .TYP EQL PBK$K_NADR	! Surround node names
	    THEN ADDSTR (')')
	    ;
	    RETURN			! We are done very quickly
	    END
	ELSE
	    BEGIN			! Not ascii
	    LEN = .DTY [NMA$V_PTY_NLE];	! Obtain the length of binary data
	    IF .LEN EQL 0		! Any length?
	    THEN
		BEGIN			! Its an image field
		LEN = .(..PTR) <0, 8, 0>;
		.PTR = ..PTR + 1
		END
	    ;
	    IF .LEN LEQ 4		! If the length is less than longword
	    THEN
		BEGIN			! Obtain the numeric format code
		SELECTONE .DTY [NMA$V_PTY_NTY] OF
		SET

		[0] :			! Unsigned decimal
		    BEGIN
		    IF  .NCP$B_COLHEAD ! Header printed and
			AND
			.NCP$A_COLTBL NEQ 0 ! We are writting column output
		    THEN
			ADDSTR ('!5U')	! Column format, right justify
		    ELSE
			ADDSTR ('!U')
		    END;
		[1] : ADDSTR ('!S');	! Signed decimal
		[2] : ADDSTR ('!X');	! Hex
		[3] : ADDSTR ('!O');	! Octal

		TES
		END
	    ;

	    SELECTONE .LEN OF		! Do the appropriate thing for length
	    SET

	    [0] :			! If length is zero, NML screwed up
		(
		SIGNAL_STOP (NCP$_BADMSG, 1,
			ASCIC ('length of parameter is zero') )
		);

	    [1] :			! One is a byte? right?
		(
		ADDSTR ('B');
		ADDFAO (...PTR)
		);

	    [2] :			! Two for a word, buckle my shoe
		(
		ADDSTR ('W');
		ADDFAO (...PTR)
		);

	    [3] :			! Three for a long, wait a minute
		(
		ADDSTR ('L');
		ADDFAO (.(..PTR) <0, 24, 0>)	! Sure, just use 24 bits
		);

	    [4] :			! Four for a long, shut the door
		(			! We lost the rhyming somewhere
		ADDSTR ('L');
		ADDFAO (...PTR)
		);

	    [5 TO 32] :			! For reasonable length binary images
		BEGIN
		INCRU IDX FROM 1 TO .LEN
		DO
		    BEGIN
		    ADDSTR ('!XB');	! They are always in hex and reversed
		    ADDFAO (.(..PTR + .LEN - .IDX) <0, 8, 0>)
		    END
		END
		;

	    [OTHERWISE] :		! Now lets be reasonable,
		(			! Binary data longer than 32 is dumb
		SIGNAL_STOP (NCP$_BADMSG, 1, 
			ASCIC ('numeric parameter too long') )
		);

	    TES
	    ;

	    .PTR = ..PTR + .LEN;	! Skip the parameter data
	    RETURN			! We are done
	    END

	END
    ;


!
!	We have finished with explicitly formatted data both
!	ascii image and binary fields
!
!	Now we are going to decode implicitly formatted fields.
!	The format of the data is known in the PTB for the parameter
!	and is passed here by the TYP value.
!	These types of data may be multiplepleplepleply (sic) coded so
!	we may call ourselves to decode the subfields
!

    IF .DTY [NMA$V_PTY_MUL]		! Is the field multiply coded
    THEN
	BEGIN
	MULCTR = .DTY [NMA$V_PTY_CLE];	! Grab the count of fields
	IF .MULCTR GTR NMA$C_PTY_MAX	! Is it ridiculous?
	THEN				! Signal a parameter error
	    SIGNAL_STOP (NCP$_BADMSG, 1,
		ASCIC ('too many multiply coded fields') )
	;

!
!	Now we are going to handle some special formatting for multiply
!	coded fields.  There are three fields to worry about.
!	version triples, node names -addresses and logging events.
!	These parameters are passed as coded multiple fields so we
!	must add some special formatting around them.
!

	SELECTONE .TYP OF		! Select action by expected type
	SET

	[PBK$K_TRIPL] :			! Triples are easy, just a V
	    BEGIN			! and . between the numbers
	    ADDSTR ('V');
	    INCR IDX FROM 1 TO .MULCTR	! For each of the subfields
	    DO
		BEGIN
		IF .IDX NEQ 1		! Separate after the first
		THEN
		    ADDSTR ('.')
		;
		NCP$PARSEPARM		! Parse each following subfield
		    (
		    CH$RCHAR_A (.PTR),	! Pickup data type
		    .PTR,
		    PBK$K_END,		! We do not know the data
		    0
		    )
		END
	    ;
	    MULCTR = 0			! No more fields to process
	    END;


!
!	For node addresses names we need to surround the names in ()
!

	[PBK$K_NADR] :
	    BEGIN
	    INCRU IDX FROM 1 TO .MULCTR		! Allow lots of fields
	    DO					! We expect only an address
		BEGIN				! and a name
		NCP$PARSEPARM
		    (
		    CH$RCHAR_A (.PTR),
		    .PTR,
		    PBK$K_NADR,			! just say its a node and
		    0				! all is fixed for us
		    )				! by the above ascii image
		END				! output routine
	    ;
	    MULCTR = 0				! No more fields to process
	    END;


!
!	Events are very difficult however.  We must format the source
!	type and follow it by the event class (possibly wild) and then the
!	event mask.
!


	[PBK$K_ESET TO PBK$K_ESNO, PBK$K_ESCI] :
	    BEGIN
	    NDTY = CH$RCHAR (..PTR);		! The first data type
	    IF	.NDTY [NMA$V_PTY_COD]		! If its coded and not mult
		AND NOT
		.NDTY [NMA$V_PTY_MUL]		! Then its the source type
	    THEN
		BEGIN
		SOURTYP = CH$RCHAR (..PTR + 1);	! Save the source type for
						! Later formatting
		IF .NCP$A_COLTBL NEQ 0		! Formatting for columns?
		THEN
		    BEGIN
		    ADDSTR ('!19<');		! Source in a field
		    .PTR = ..PTR + 2		! Skip the data type byte
		    END				! and the code byte too
		ELSE
		    NCP$PARSEPARM		! Write source type
			(			! parse the parameter to 
			CH$RCHAR_A (.PTR),	! Look up the keyword for the
			.PTR,			! source type.
			PBK$K_LITB,
			NCP$GA_TBL_EVESOUR	! Event source keyword table
			)
	    	;
		MULCTR = .MULCTR - 1;		! One less subfield
		IF .SOURTYP NEQ %X'FF'		! If its not a null source
		    AND
		    .MULCTR GTR 0		! And there are more left
		THEN
		    BEGIN
		    SELECTONEU .SOURTYP		! Based on source type,
		    OF
			SET
			[NMA$C_ENT_LIN]: ADDSTR('Line ');
			[NMA$C_ENT_CIR]: ADDSTR('Circuit ');
			[NMA$C_ENT_NOD]: ADDSTR('Node ');
			TES;
		    NCP$PARSEPARM		! Parse the string or number
			(
			CH$RCHAR_A (.PTR),
			.PTR,
			PBK$K_END,		! Assume we do not know its
			0			! format
			);
		    MULCTR = .MULCTR - 1	! One less subfield
		    END
		ELSE
		    ADDSTR('(All sources)');

		NDTY = CH$RCHAR (..PTR);	! Next data type code
		IF .SOURTYP EQL 0		! Source is a node
		    AND
		    .MULCTR GTR 0		! Fields are left
		    AND
		    .NDTY [NMA$V_PTY_ASC]	! Its ascii
		    AND NOT
		    .NDTY [NMA$V_PTY_COD]	! And not coded
		THEN
		    BEGIN
		    NCP$PARSEPARM		! Parse as a node name
			(
			CH$RCHAR_A (.PTR),
			.PTR,
			PBK$K_NADR,
			0
			)
		    ;
		    MULCTR = .MULCTR - 1	! One less parameter
		    END
		;
		IF .NCP$A_COLTBL NEQ 0		! If column output
		THEN
		    ADDSTR ('!> ')		! Close off the source column
		END
	    ;
	    IF .MULCTR GTR 0			! If there are still more
	    THEN				! Subfields
		BEGIN
		NDTY = CH$RCHAR (..PTR);	! Look at the data type
		IF .NDTY EQL 2			! Two byte unsigned decimal?
		THEN				! Its the class code
		    BEGIN
		    .PTR = ..PTR + 1;		! Advance to value
		    ECLS = (.(..PTR) <0, 9, 0>); ! Get the class (9 bits)
		    .PTR = ..PTR + 2;		! Advance over it
		    MULCTR = .MULCTR - 1;	! Reduce the number of fields
		    SELECTONEU .(..PTR-2)<14, 2, 0> OF! Look at the wild codes
		    SET

		    [0] :			! Single event class, and mask
			(
			ADDFAO (.ECLS);
			ADDSTR (' !UW.');	! for the class
			NDTY = CH$RCHAR (..PTR); ! Get the data type
			IF .NDTY EQL %X'20'	! Hex image?
			    AND
			    .MULCTR GTR 0	! And there is one
			THEN
			    BEGIN
			    .PTR = ..PTR + 1;	! Advance to hex image
			    NCP$PARSEVENTS (.PTR);! Decode the mask
						! With a little help from our
						! friends
			    MULCTR = .MULCTR - 1 ! One less subfield
			    END
			);

		    [1] :			! This is a reserved type code
			(
			SIGNAL_STOP (NCP$_BADMSG, 1,
			ASCIC ('reserved event class code') )
			);

		    [2] :			! wild Mask
			(
			ADDFAO (.ECLS);
			ADDSTR (' !UW.*')
			);

		    [3] :			! Wild class and events
			(
			ADDSTR (' *.*')
			);
		    TES
		    END
		END
	    END;
	TES
	;


!
!	Take care of all the subfields that are left after we perform
!	the special actions.
!	If the special formats are wrong this will print the remainder
!	without leaving us in the middle of a multiple coded field.
!

	INCR IDX FROM 1 TO .MULCTR	! For each of the subfields
	DO
	    BEGIN
	    IF .IDX NEQ 1		! Separate after the first
	    THEN
		ADDSTR (', ')
	    ;
	    NDTY = .(..PTR) <0, 8, 0>;	! The new data type
	    IF  .NDTY [NMA$V_PTY_MUL]	! If its multiply coded,
		AND
		.NDTY [NMA$V_PTY_COD]
	    THEN			! Blow away, for multiple recursion
		SIGNAL_STOP (NCP$_BADMSG, 1,
			ASCIC ('recursive multiple fields') )
	    ;
	    .PTR = ..PTR + 1;		! Skip beyond the data type
	    NCP$PARSEPARM (.NDTY, .PTR, PBK$K_END, 0);
	    END
	;
	RETURN
	END
    ;


!
!	Its not a multiply coded field, so decode the data based on
!	the type code passed by the TYP parameter.
!

!
!	Dispatch on the data type to handle each separately
!

    LEN = .DTY [NMA$V_PTY_CLE];		! The length of the parameter data
    PSTRT = ..PTR;			! Save the start of the parameter data

    SELECTONE .TYP OF			! Dispatch on the type code
    SET

    [PBK$K_LITB] :			! This means we want to search a table
	(				! For a keyword based on a byte code
	IF .LST EQL 0			! If the list address is zero,
	THEN				! Thats our fault
	    SIGNAL_STOP (NCP$_LOGIC, 1, ASCIC ('invalid keyword list') )
	;
	IF
	    NCP$TABLESEARCH		! General routine for searching tables
		(
		.(..PTR) <0, 8, 0>,	! Byte code
		.LST,			! Table address is word offset
		TXT			! Put address of text here
		)
	THEN
	    BEGIN
	    ADDFAO (.TXT);		! Write the text we know
	    ADDSTR ('!AC')
	    END
	ELSE
	    BEGIN
	    ADDFAO (...PTR);		! Write in standard form
	    ADDSTR ('type #!UB')
	    END
	;
	.PTR = ..PTR + 1		! Advance over code
	);


!
!   Privilege mask
!

    [PBK$K_PRVC, PBK$K_PRVL] :
	BEGIN
	LOCAL
	    PRVMSK : VECTOR [8, BYTE],		! Full 8 byte mask
	    CTR					! Temp counter
	    ;

	CTR = .LEN;				! Obtain bytes in mask
	IF .CTR GTR 8				! If the mask is too long
	THEN					! Signal an error
	    SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('invalid privilege mask') )
	;
	CH$FILL (0, 8, PRVMSK);			! Clear the full mask size
	INCR IDX FROM 0 TO MINU (8, .CTR)	! Copy the message mask
	DO
	    PRVMSK [.IDX] = .(..PTR + .IDX) <0, 8, 0>
	;

	.PTR = ..PTR + .CTR;			! Step pointer beyond mask

	NCP$PRIVBITS (PRVMSK, CTR);		! Make bits into text entries
						! Return how many strings

	INCRU IDX FROM 1 TO .CTR		! Add the control string
	DO					! Entries to print them out
	    BEGIN
	    IF  ( (.IDX MOD 6) EQL 1)		! Every 6 get a new line
		AND
		(.IDX NEQ 1)			! Except the first
	    THEN
		ADDSTR ('!/!27* ')		! A new line and indent
	    ;
	    ADDSTR ('!AC ')			! A string pointer
	    END
	END
	;

    [OTHERWISE] :
	(
	ADDSTR ('%X''');		! Say the data is hex
	INCRU IDX FROM 0 TO .LEN - 1
	DO
	    BEGIN			! Write the data reversed
	    ADDSTR ('!XB');
	    ADDFAO (.(..PTR+.IDX) <0, 8, 0>)
	    END
	;
	ADDSTR ('''');
	.PTR = ..PTR + .LEN		! Assume the length is correct
	);

    TES
    ;

    IF (.PSTRT + .LEN) NEQU ..PTR	! Check the coded length and
    THEN				! Our decoding
	SIGNAL_STOP (NCP$_BADMSG, 1,	! They did not match
		ASCIC ('invalid length in parameter') )
    ;

    RETURN
    END;

%SBTTL	'NCP$PARSEVENTS  Parse Event Parameter'
ROUTINE NCP$PARSEVENTS (PTR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses the bit mask for event types and creates the fao list
!	entries and appents entries to the fao control string to do the
!	proper conversions.  This routine properly formats both single bits
!	and ranges.
!
! FORMAL PARAMETERS:
!
!	PTR		Address of a pointer to the event mask
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	ADDSTR		Macro called to add strings to fao control string
!	ADDFAO		Macro called to add items to fao list
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	FFS, FFC			! Find bit operations
					! Remember that these are true if
					! No bit is found
	;

    LOCAL
	BITS,				! How many bits
	BASE,				! Base address of bits
	LOBIT,				! Low bit number
	HIBIT,				! High bit number
	SIZE				! Size if field to search
	;		!

    BITS = ( .(..PTR) <0, 8, 0> ) * 8;	! Number of bits
    BASE = ..PTR + 1;
    .PTR = ..PTR + .(..PTR) <0, 8, 0> + 1; ! Point beyond the bits

    IF .BITS EQL 0			! Any bits
    THEN
	RETURN				! No bits, then nothing
    ;

    SIZE = 32;				! Size of field to search
    LOBIT = 0;				! Lowest bit to look for (POS)

    WHILE TRUE				! Forever look for bits
    DO
	BEGIN				! Any bits set?
	WHILE .LOBIT LSS .BITS		! While there are bits to look for
	    AND
	    FFS (LOBIT, SIZE, .BASE, LOBIT) ! Find first set until it is
	DO
	;

	IF .LOBIT GEQ .BITS		! First in our mask?
	THEN
	    RETURN			! Nope
	;

	FFC (LOBIT, SIZE, .BASE, HIBIT); ! If no bit is found, lobit + size
					! is returned as high bit


	IF .HIBIT GEQ .BITS		! Clamp the top of the range too
	THEN
	    HIBIT = .BITS
	;
	HIBIT = .HIBIT - 1;		! Adjust hibit
	IF .LOBIT EQL .HIBIT		! A range of bits found
	THEN
	    BEGIN			! Not a range
	    ADDFAO (.LOBIT);		! Stuff one bit
	    ADDSTR ('!UB ')
	    END
	ELSE
	    BEGIN			! Stuff a range of bits
	    ADDFAO (.LOBIT);
	    ADDFAO (.HIBIT);
	    ADDSTR ('!UB-!UB ')
	    END
	;
	LOBIT = .HIBIT + 1		! Continue searching from here
	END

    END;

%SBTTL	'NCP$PTBSEARCH  Search a PTB for an Entry'
ROUTINE NCP$PTBSEARCH (TBL, ID, TYP, LST, TXT) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Search a Parameter Table Block for an entry specified by
!	ID.  Return the parameter type code, address of a list entry, and
!	address of the text for the parameter name.
!
! FORMAL PARAMETERS:
!
!	TBL		Address of the PTB to search
!	ID		Value of the id to find
!	TYP		Address to return the type code
!	LST		Address to return the address of the associated list
!	TXT		Address to return the address of the name
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Success or failure
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN


    FIELD 				! Fields for Parameter Text Blocks
	PTBFLDS =
	SET
	PTB$W_ID	= [0, 0, 16, 0],	! Id is the NMA code
	PTB$B_TYP	= [2, 0, 8, 0],		! Type is the PBK type code
	PTB$W_LST	= [3, 0, 16, 1],	! Word offset to a text block
	PTB$W_TXT	= [5, 0, 16, 1]		! Word offset to a c string
	TES
	;

    LITERAL
	PTB$C_SIZE	= 7			! Size of the block
	;

    LOCAL
						! Pointer to the table
	PLIST : REF BBLOCKVECTOR [1, PTB$C_SIZE] FIELD (PTBFLDS)
	;		!

    PLIST = .TBL;				! Set the table start

    INCRU IDX FROM 0				! Look at the table from
    DO						! The beginning
	BEGIN
	IF .PLIST [.IDX, PTB$W_ID] EQL 65535	! All done
	THEN
	    RETURN FAILURE			! We didn't find it here
	;

!
!	If id's match, return the type, list, and text
!

	IF .PLIST [.IDX, PTB$W_ID] EQL .ID <0, 16, 0>
	THEN
	    BEGIN
	    .TYP = .PLIST [.IDX, PTB$B_TYP];	! Return the type code
	    IF .PLIST [.IDX, PTB$W_LST] EQL 0	! If there is no list
	    THEN
		.LST = 0			! Then return no list
	    ELSE				! Else, return real list addr
		.LST = .PLIST [.IDX, PTB$W_LST] + PLIST [.IDX, PTB$W_LST]
	    ;
	    .TXT = .PLIST [.IDX, PTB$W_TXT] + PLIST [.IDX, PTB$W_TXT];
	    RETURN SUCCESS
	    END
	END

    END;

%SBTTL	'NCP$FAOSET  Setup parameters for fao list'
GLOBAL ROUTINE NCP$FAOSET :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Setup control string buffer descriptor and fao list pointer.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    FAOPTR = 0;				! Initialize pointer to fao list
    CTRDSC [0] = 0;			! Control string descriptor
    CTRDSC [1] = CTRBUF;		! for FAO call later, set for ADDSTR
    CTRDSC [2] = CTRBUFSIZ;		! Set for size check
    RETURN

    END;

%SBTTL	'NCP$ADDSTR  Add a String to a Descriptor'
GLOBAL ROUTINE NCP$ADDSTR (CSTR, DSC) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds a counted string to the string described by
!	a descriptor.  A length check is made against the maximum length
!	of the string which is in the third longword of the descriptor.
!
! FORMAL PARAMETERS:
!
!	CSTR		Address of a counted string, ASCIC ('txt')
!	DSC		Address of a string descriptor and following longword
!   			max length
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE, error signaled if string does not fit
!
! SIDE EFFECTS:
!
!	NONE
!
!--


    BEGIN

    MAP
	DSC : REF VECTOR		! Descriptor of string
	;

    IF (.(.CSTR) <0, 8, 0> + .DSC [0])	! Will string fit?
    	GTR
    	.DSC [2]
    THEN
	SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('too many parameters') )
    ;

    CH$MOVE				! Copy the string
	(
	.(.CSTR) <0, 8, 0>,
	.CSTR + 1,
	.DSC [1] + .DSC [0]
	);

    DSC [0] = .DSC [0] + .(.CSTR) <0, 8, 0>; ! Update descriptor

    RETURN

    END;

%SBTTL	'NCP$ADDFAO  Add an Entry to the FAO List'
GLOBAL ROUTINE NCP$ADDFAO (ITEM) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Add a longword entry to the fao list we are building.
!	If the list overflows, signal an error for too many parameters.
!
! FORMAL PARAMETERS:
!
!	ITEM		Value of the list entry
!
! IMPLICIT INPUTS:
!
!	FAOPTR		Index into the FAOLST
!
! IMPLICIT OUTPUTS:
!
!	FAOPTR		Incremented
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    IF .FAOPTR GEQ FAOLSTSIZ		! Check the size of the list
    THEN
	SIGNAL_STOP (NCP$_BADMSG, 1,	! Too large, bump us off
		 ASCIC ('too many parameters') )
    ;

    FAOLST [.FAOPTR] = .ITEM;		! Add the item to the list
    FAOPTR = .FAOPTR + 1;		! Bump the index into the list
    RETURN

    END;

%SBTTL	'NCP$FAOWRITE  Convert and Write Fao Parameters'
GLOBAL ROUTINE NCP$FAOWRITE :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls $FAOL to convert the parameters in the
!	Fao control string and fao list and then calls the write
!	routine to write the string to the output device for
!	show and list.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CTRDSC
!	FAOLST
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    OUTDSC [0] = OUTBUFSIZ;		! Set the output buffer descriptor
    OUTDSC [1] = OUTBUF;

    NCP$FAOL (OUTDSC);			! Convert the fao lists

    NCP$WRITESHO (OUTDSC);		! Write the output

    RETURN

    END;

%SBTTL	'NCP$FAOL  Convert fao list'
GLOBAL ROUTINE NCP$FAOL (OUTDSC) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert the fao list we have been building.  Return the string in
!	a string whose descriptor is passed.
!
! FORMAL PARAMETERS:
!
!	OUTDSC		Address of descriptor of buffer for text.
!			Descriptor is modified to contain the new length.
!
! IMPLICIT INPUTS:
!
!	CTRDSC		Descriptor of control string
!	FAOLST		Fao parameter list
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	OUTDSC : REF VECTOR [2]		! Local description of descriptor
	;		!

    $FAOL
	(
	CTRSTR = CTRDSC,		! Module wide control string
	OUTLEN = OUTDSC [0],		! Descriptor parameter
	OUTBUF = .OUTDSC,
	PRMLST = FAOLST			! Module wide parameter list
	);

    RETURN

    END;

%SBTTL	'NCP$PRIVBITS  Convert Privilege Mask to Text Entries'
ROUTINE NCP$PRIVBITS (MASK, RLEN) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert a privilege mask to a of bit names entries in the fao list.
!	Store the list in the fao list and return its length.
!
! FORMAL PARAMETERS:
!
!	MASK		Address of privilege mask
!	RLEN		Address to return length of the fao list
!
! IMPLICIT INPUTS:
!
!	PRV$AB_NAMES		Table of bit names and values
!				Format :	BYTE minimum name size
!						BYTE bit value
!						ASCIC bit name
!						...
!						BYTE 0
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--


    BEGIN

    LOCAL
	NBIT,				! Number of the current bit
	PTR,				! Pointer to bit
	CTR				! Counter for list
	;		!

    EXTERNAL
	PRV$AB_NAMES;			! Magic table of privilege names

    CTR = 0;				! No entries yet
    PTR = PRV$AB_NAMES;			! Scan the table, bit by bit

    WHILE .(.PTR) <0, 8, 0> NEQ 0	! While the table is not done
    DO
	BEGIN
	PTR = .PTR + 1;			! Skip the minimum string size
	NBIT = .(.PTR) <0, 8, 0>;	! Bit number
	PTR = .PTR + 1;			! -> ascic name of bit
	IF .(.MASK) <.NBIT, 1, 0>	! Look at the bit in the mask
	THEN
	    BEGIN			! If so, add the name
	    ADDFAO (.PTR);		! Add the entry to the fao list
	    CTR = .CTR + 1		! Count the entry
	    END
	;

	PTR = .PTR + .(.PTR) <0, 8, 0> + 1 ! Skip the string
	END
    ;

    .RLEN = .CTR;			! Return the length of the data
    RETURN

    END;

END				!End of module
ELUDOM
