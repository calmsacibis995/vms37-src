%TITLE	'Phase II Functions'
MODULE NCPPHASE2 (IDENT = 'V03-000',
		ADDRESSING_MODE(EXTERNAL=GENERAL),
		ADDRESSING_MODE(NONEXTERNAL=GENERAL)) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Network Control Program (NCP)
!
! ABSTRACT:
!
!	This module contains the routines which perform functions with
!	DECnet-VAX phase II NICE.
!
! ENVIRONMENT:	VAX/VMS Operating System
!
! AUTHOR:	Darrell Duffy	, CREATION DATE:  21-March-1980
!
! MODIFIED BY:
!
!	V003	TMH0003		Tim Halvorsen	11-Aug-1981
!		Use new format of NMLRSP message
!
!	V002	TMH0002		Tim Halvorsen	28-Jul-1981
!		Add general addressing.
!
!	V001	TMH0001		Tim Halvorsen	02-Jul-1981
!		Use new name for system-specific entity, link.
!--

%SBTTL	'Definitions'

!
! TABLE OF CONTENTS:
!

!FORWARD ROUTINE
!	;		!

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB.L32';
LIBRARY 'OBJ$:NMALIBRY.L32';
LIBRARY 'OBJ$:NCPLIBRY.L32';

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
    					! Error status codes for 
    NCP$_BADMSG,			! Invalid message
    NCP$_NMLRSP,			! Management response
    NCP$_NETIO,				! Net IO error
    NCP$_PH2INV				! Invalid for phase II executor
    ;

EXTERNAL
    NCP$GL_EXELCB	: 		! Pointer to link control block
    	REF BBLOCK [LCB$C_SIZE],
    NCP$GL_FNC_CODE	: BBLOCK [4],	! Function code from parse
    NCP$GL_OPTION	: BBLOCK [4],	! Option byte from parse
    PDB$G_VRB_ENT	: BBLOCK [1],	! Verb entity from parse
    PDB$G_LOO_CNT	: BBLOCK [1],	! Loop count
    PDB$G_LOO_WTH	: BBLOCK [1],	! Loop data type
    PDB$G_LOO_LEN	: BBLOCK [1],	! Loop data length
    NCP$GQ_CTRDSC,			! Fao control string dsc
    NCP$GT_RSPBFR	: VECTOR [1, BYTE], ! Response buffer
    NCP$GT_MSGBFR	: VECTOR [1, BYTE] ! Message buffer
    ;

EXTERNAL
    NCP$GA_TBL_PH2STS,			! Return status text
    NCP$GA_TBL_PH2LINES,		! Line type names
    NCP$GA_TBL_PH2LINCOU,		! Line counters
    NCP$GA_TBL_PH2EXECOU;		! Local counters


EXTERNAL ROUTINE
	NCP$FAOSET,			! Set fao conversion buffers
	NCP$FAOWRITE,			! Convert and write buffers
	NCP$ADDSTR,			! Add string to fao control string
	NCP$ADDFAO,			! Add argument to fao list
	NCP$SENDMSG,			! Transmit message to NML
	NCP$SIGNETERR,			! Signal network error
	NCP$TABLESEARCH,		! Search a table
	FOR$CNV_IN_I;

%SBTTL	'NCP$PH2Q  Is Executor a Phase II Node?'
ROUTINE NCP$PH2Q =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return true if the current executor node is phase II, false otherwise.
!	The phase of the node was determined at connect time with NML.  The
!	optional data for phase II NICE is null.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NCP$GL_EXELCB		Link control block
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Success or failure
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    IF .NCP$GL_EXELCB [LCB$B_PH2]	! Look at the phase II flag in
    THEN				! link control block
	RETURN SUCCESS
    ELSE
	RETURN FAILURE

    END;

%SBTTL	'NCP$PH2INVALID  Signal Invalid Function for Phase II'
ROUTINE NCP$PH2INVALID :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Signal error for invalid function for phase II NICE object.
!	Error indicates invalid verb or option of any kind.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    SIGNAL_STOP (NCP$_PH2INV)		! Signal for unwind

    END;

%SBTTL	'NCP$PH2COPYLINE  Build a Line ID into Message'
ROUTINE NCP$PH2COPYLINE (MPTR) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Check the verb entity as a line and if its valid, build it
!	into a message.  The line type must be DMC since that is
!	the only line type supported by Phase II DECnet VAX.
!
! FORMAL PARAMETERS:
!
!	MPTR		Address to build line id into message
!
! IMPLICIT INPUTS:
!
!	PDB$G_VRB_ENT
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Pointer beyond line id in message
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into output message
	CTR,				! Counter of chars in line id
	DSC : VECTOR [2],		! General descriptor
	CTRLR,				! Control as binary
	PDATA				! Pointer to line id
	;		!

    PTR = .MPTR;			! Set output pointer
    PDATA = PDB$G_VRB_ENT [PDB$T_DATA];	! Set input pointer
    CTR = CH$RCHAR_A (PDATA);		! And counter
    IF .CTR EQL 255			! Known??
    THEN
	CH$WCHAR_A (0, PTR)		! Use known code

    ELSE
	BEGIN				! Check for DMC line type
	IF
	    .CTR GTR 4			! Enough chars for line id
	    AND
	    CH$EQL (4, .PDATA, 4, UPLIT BYTE ('DMC-'), 0) ! Must be dmc
	THEN
	    BEGIN			! Build line description for output
	    PTR = CH$MOVE (5, UPLIT BYTE (1, 12, 0, 0, 0), .PTR);
	    DSC [0] = .CTR - 4;		! Prepare to convert controller
	    DSC [1] = .PDATA + 4;
	    FOR$CNV_IN_I (DSC, CTRLR);	! Convert controller string to binary
	    CH$WCHAR (.CTRLR, .PTR - 3)	! Stuff into the string
	    END
	ELSE
	    NCP$PH2INVALID ()		! Not DMC, too bad
	END
    ;

    RETURN .PTR				! Return pointer beyond message

    END;

%SBTTL	'NCP$PH2BLDMSG  Build Message for NICE'
ROUTINE NCP$PH2BLDMSG (FNC, OPTLIN, OPTLOC, OPTRTN, KWNRTN) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Build a message to send to NICE.  The message consists of a
!	function code, and an option byte.  The line or local option byte
!	is selected based on the data from the parse and the appropriate
!	option is also returned to the caller.  Also an indication of
!	KNOWN entity is returned to the caller.  The pointer beyond the
!	message is returned as the value of the function.
!
! FORMAL PARAMETERS:
!
!	FNC			Value of function code
!	OPTLIN			Value of option for lines
!	OPTLOC			Value of option for local node
!	OPTRTN			Address to return option used
!	KWNRTN			Address to return true-false for KNOWN
!
! IMPLICIT INPUTS:
!
!	PDB$G_VRB_ENT
!	NCP$GL_OPTION
!
! IMPLICIT OUTPUTS:
!
!	NCP$GT_MSGBFR
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Pointer beyond message thus far built
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into message
	ENT,				! Value of entity for output
	LINECODE			! Code for line
	;		!

    PTR = NCP$GT_MSGBFR;		! Point to message buffer
    CH$WCHAR_A (.FNC, PTR);		! Write function code there
    .KWNRTN = FALSE;			! Initialize known return

    ENT = .NCP$GL_OPTION [NMA$V_OPT_ENT]; ! Entity code for function

    SELECTONE .ENT OF			! Select line or local
    SET

    [NMA$C_ENT_NOD] :			! Local is a node
	BEGIN
	.OPTRTN = .OPTLOC;		! Say its local
	CH$WCHAR_A (.OPTLOC, PTR);
	IF .PDB$G_VRB_ENT [1, 0, 24, 0] NEQ 0 ! Must be executor (adr = 0)
	THEN
	    NCP$PH2INVALID ()		! Not executor node
	END;

    [NMA$C_ENT_LIN] :			! Line
	BEGIN
	.OPTRTN = .OPTLIN;		! Store option for line
	CH$WCHAR_A (.OPTLIN, PTR);
	LINECODE = .PDB$G_VRB_ENT [1, 0, 8, 1]; ! Get code byte
	SELECTONE TRUE OF		! Tricky way to select
	SET
	[.LINECODE GTR 0] :		! Line id string present
	    PTR = NCP$PH2COPYLINE (.PTR);
	[.LINECODE EQL -1] :		! Known lines
	    BEGIN
	    .KWNRTN = TRUE;
	    CH$WCHAR_A (0, PTR)
	    END;
	[OTHERWISE] :			! Loop lines etc are invalid
	    NCP$PH2INVALID ();
	TES
	END;

    [OTHERWISE] :			! Other entities are invalid
	NCP$PH2INVALID ();

    TES;

    RETURN .PTR				! Pointer beyond prefix in buffer

    END;

%SBTTL	'NCP$PH2READRSP  Read Response from NICE'
ROUTINE NCP$PH2READRSP (LEN, BFR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read response from NICE and check for an error return.
!	Return the length and address of the data beyond the status
!	byte.  Errors are signaled.
!
! FORMAL PARAMETERS:
!
!	LEN		Address to return length of message
!	BFR		Address to return address of buffer
!
! IMPLICIT INPUTS:
!
!	NCP$GL_EXELCB
!	NCP$GT_RSPBFR
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN


    LITERAL
	ENTSIZ = 32,			! Size of entity text buffer
	RSPSIZ = 32			! Size of response text buffer
	;

    BIND
	NULSTR = ASCIC ('')		! Blank string
	;

    LOCAL
	PTR,				! Pointer into message
	STATUS,				! Status value
	IOSB	: BBLOCK [8],		! IO status block
	OUTLEN,				! Output length from fao
	RSP,				! Response text string
	COMMA,				! Detail delimiter (not used)
	DTL,				! Detail string (not used)
	ERR,				! Error string (not used)
	ENT,				! Entity string (not used)
	CODE,				! Code value
	CTR				! Size of return string
	;		!

    OWN
	ENTBUF : VECTOR [ENTSIZ, BYTE],	! Buffer for loop response text
	RSPBUF : VECTOR [RSPSIZ, BYTE]	! Buffer for response text
	;

    STATUS = $QIOW			! Read a message
	(
	CHAN = .NCP$GL_EXELCB [LCB$W_CHAN], ! Channel to executor
	FUNC = IO$_READVBLK,		! Read a block
	IOSB = IOSB,			! IO status block
	P1 = NCP$GT_RSPBFR,		! Response buffer
	P2 = NCP$C_RSPSIZ		! Size of buffer
	);

    NCP$SIGNETERR (NCP$_NETIO, .STATUS, IOSB); ! Signal the error

    .LEN = 0;				! Set return data
    .BFR = NCP$GT_RSPBFR;

    CTR = .IOSB [0, 16, 16, 0];		! Obtain the size
    PTR = NCP$GT_RSPBFR;		! Point to the data
    RSP = ASCIC ('Unrecognised');	! Initialize strings
    COMMA = NULSTR;
    DTL = NULSTR;
    ERR = NULSTR;
    ENT = NULSTR;

    IF .CTR EQL 0			! If no data, croak
    THEN
	SIGNAL_STOP
	    (
	    NCP$_NMLRSP,		! Standard nml response message
	    5,				! with four strings
	    .RSP, .COMMA, .DTL, .ENT, .ERR
	    )
    ;

    CODE = .(.PTR) <0, 8, 1>;		! Obtain sign extended code

    IF NOT NCP$TABLESEARCH		! Look for the response in table
	(
	CH$RCHAR (CODE),
	NCP$GA_TBL_PH2STS,
	RSP
	)
    THEN
	BEGIN				! If none, make one
	$FAO
	    (
	    ASCID ('Management return #!SB'),
	    OUTLEN,
	    UPLIT (RSPSIZ - 1, RSPBUF + 1),
	    .CODE
	    );
	RSPBUF [0] = .OUTLEN;
	RSP = RSPBUF
	END
    ;

    IF .CODE LSS 0			! If its an error code
    THEN
	BEGIN
	IF .NCP$GL_FNC_CODE		! Check function code for loop test
	    EQL
	    NMA$C_FNC_TES 		! If looping, convert the
	    AND				! unlooped message count if
	    .CTR GEQ 3			! There is one
	THEN
	    BEGIN
	    $FAO			! Convert the count to text
		(
		ASCID ('Messages not looped = !UW'),
		OUTLEN,
		UPLIT (ENTSIZ - 1, ENTBUF + 1),
		.(.PTR + 1) <0, 16>
		);
	    ENTBUF [0] = .OUTLEN;	! Make a counted string
	    ENT = ENTBUF		! Report the message here
	    END
	;
	SIGNAL_STOP			! Signal the error
	    (
	    NCP$_NMLRSP,
	    5,
	    .RSP, .COMMA, .DTL, .ENT, .ERR
	    )
	END
    ;

    .LEN = .CTR - 1;			! Otherwise return buffer data
    .BFR = ..BFR + 1;

    RETURN

    END;

%SBTTL	'NCP$OUTLINE  Convert Line for Output'
ROUTINE NCP$OUTLINE (MSGPTR) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse a line id in a message and prepare it for output.
!	Return the pointer beyond the line id as the value of this
!	routine.
!
! FORMAL PARAMETERS:
!
!	MSGPTR		Address of line id in a message
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into message
	LINETYPE,			! Line type code
	CTL,				! Controller number
	LINE,				! Line number
	STA,				! Station number
	LINNAM				! Name of the line as text
	;


    PTR = .MSGPTR;			! Set pointer into message
    LINETYPE = CH$RCHAR_A (PTR);	! Pickup line type
    ADDSTR ('!24<');			! Setup string to justify line
    SELECTONE .LINETYPE OF		! Dispatch on the line type
    SET

    [1] :				! Look for the line in the table
	BEGIN
	IF NCP$TABLESEARCH
	    (
	    CH$RCHAR_A (PTR),		! Device type
	    NCP$GA_TBL_PH2LINES,
	    LINNAM			! Return name here
	    )
	THEN
	    ADDFAO (.LINNAM)		! Use the name we have
	ELSE
	    SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('Invalid line type' ) )
	;
	CTL = CH$RCHAR_A (PTR);		! Controller number
	LINE = CH$RCHAR_A (PTR);	! Line number
	STA = CH$RCHAR_A (PTR);		! Station number
	ADDFAO (.CTL);			! Control is always printed
	ADDSTR ('!AC-!UB');		! Setup control string entry
	IF .LINE NEQ 0			! Check for line number and station
	    OR
	    .STA NEQ 0
	THEN
	    BEGIN
	    IF .STA EQL 0		! If only line
	    THEN
		BEGIN
		ADDSTR ('-!UB');	! Line only format
		ADDFAO (.LINE)
		END
	    ELSE
		BEGIN
		ADDSTR ('-!UB.!UB');	! Line and station format
		ADDFAO (.LINE);
		ADDFAO (.STA)
		END
	    END
	END;

    [2] :				! Convenience name format of line
	BEGIN
	ADDSTR ('!AC');			! Just a counted string
	ADDFAO (.PTR);
	PTR = .PTR + CH$RCHAR_A (PTR)
	END;

    [OTHERWISE] :			! Message screwup
	SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('Unknown line type') )
	;

    TES;

    ADDSTR ('!>');			! Capoff the line field

    RETURN .PTR				! Return pointer beyond the line

    END;

%SBTTL	'NCP$CNVSTATE  Convert a State Value for Output'
ROUTINE NCP$CNVSTATE (STATE, PTR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert a byte state value to a counted string.  Return the
!	counted string in the address pointer.
!
! FORMAL PARAMETERS:
!
!	STATE		Value of the state byte
!	PTR		Address of return for counted string address
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ST
	;		!

    ST = .STATE;
    .PTR =
	(
	SELECTONE .ST OF
	SET

	[NDB$C_ON] : 		ASCIC ('On');
	[NDB$C_OFF] : 		ASCIC ('Off');
	[NDB$C_SHUT] : 		ASCIC ('Shut');
	[NDB$C_LOOP] : 		ASCIC ('Loopback');
	[NDB$C_MAINT] : 	ASCIC ('Service');
	[NDB$C_CTL_LOOP] : 	ASCIC ('Device Loopback');
	[OTHERWISE] : 		ASCIC ('Invalid state');

	TES
	)

    END;

%SBTTL	'NCP$EXTTOBIN  Extended Bytes to Binary'
ROUTINE NCP$EXTTOBIN (INPTR, RTNVAL) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert an extended binary byte string to a binary longword.
!	Return the binary value in the RTNVAL address and the pointer
!	beyond the field as the routine value.
!
! FORMAL PARAMETERS:
!
!	INPTR		Address of the extended byte field
!	RTNVAL		Address to return binary value
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Address beyond extended byte field
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into message
	VALUE,				! Build value here
	TMP : BYTE			! Temp byte to look at
	;		!


    VALUE = 0;				! Set value to return
    PTR = .INPTR;			! Set pointer

    INCR IDX FROM 0 TO 21 BY 7		! Scan in the output value
    DO
	BEGIN
	TMP = VALUE <.IDX, 7> = CH$RCHAR_A (PTR); ! Obtain a byte and store it
	IF NOT .TMP <7, 1>		! Look at it for extension
	THEN EXITLOOP			! Not extended
	END
    ;

    .RTNVAL = .VALUE;			! Return the value
    RETURN .PTR				! Return the pointer

    END;

%SBTTL	'NCP$PH2CHKSDB  Check for Valid State'
ROUTINE NCP$PH2CHKSDB (SDB) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Scan the SDB for all parameters for this command.  They must be
!	all missing except state.  The value of the state byte is
!	returned.
!
! FORMAL PARAMETERS:
!
!	SDB		Address of the sdb which describes all parameters
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	State byte
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	SDB	: REF BBLOCK [SDB$C_SIZE]
	;

    LOCAL
	PCL	: REF BBLOCKVECTOR [1, PCL$C_SIZE],
	PDB	: REF BBLOCK [PDB$C_SIZE],
	STATE
	;		!

    PCL = .SDB [SDB$L_PCL_ADR];			! Address of parameter list
    STATE = 100;				! Invalid state for sure

    INCR IDX FROM 0				! Scan the pcl list
    DO
	BEGIN
	IF .PCL [.IDX, PCL$B_PRM_TYP] EQL PBK$K_END	! Til end
	THEN EXITLOOP
	;
	PDB = .PCL [.IDX, PCL$L_PDB_ADR];	! Data block
	IF .PCL [.IDX, PCL$W_PRM_ID] EQL 0	! State?
	THEN
	    BEGIN
	    IF NOT .PDB [PDB$B_STS_FLG]		! Must be present
	    THEN NCP$PH2INVALID ()
	    ;
	    STATE = .PDB [PDB$T_DATA]		! Return state
	    END
	ELSE
	    BEGIN
	    IF .PDB [PDB$B_STS_FLG]		! All others may not be
	    THEN NCP$PH2INVALID ()		! present
	    END
	END
    ;

    RETURN .STATE				! Return state code

    END;

%SBTTL	'NCP$PH2SETSTA  Set State to NICE'
ROUTINE NCP$PH2SETSTA (SDB) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform set state line and set state local functions.
!	Only the state parameter is valid, so we require all other parameters
!	to be absent.  We scan the sdb to look at all the parameters.
!
! FORMAL PARAMETERS:
!
!	SDB		Address of SDB for this command
!
! IMPLICIT INPUTS:
!
!	NCP$GL_OPTION
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	SDB	: REF BBLOCK [SDB$C_SIZE]	! Data block
	;

    LOCAL
	ENT,					! Entity of concern
	PTR,					! Pointer to message
	STATE,					! State value
	LEN,					! Return length of response
	BFR					! Return buffer address
	;		!

    PTR = NCP$GT_MSGBFR;			! Set pointer and
    CH$WCHAR_A (NMA$C_FN2_SET, PTR);		! Function code

    ENT = .NCP$GL_OPTION [NMA$V_OPT_ENT];	! Obtain entity code

    SELECTONE .ENT OF
    SET

    [NMA$C_ENT_NOD] :				! Node is for local
	BEGIN
	STATE = NCP$PH2CHKSDB (.SDB);		! Check for other than state
	IF .PDB$G_VRB_ENT [1, 0, 24, 0] NEQ 0	! Must be executor
	THEN NCP$PH2INVALID ()			! Not address zero
	;
	IF .STATE GTR NMA$C_STATE_SHU		! Look for invalid state
	THEN NCP$PH2INVALID ()
	;
	CH$WCHAR_A (NMA$C_OP2_CHNST, PTR);	! Set option byte
	CH$WCHAR_A (.STATE, PTR)		! State byte
	END;

    [NMA$C_ENT_LIN] :				! Line
	BEGIN
	STATE = NCP$PH2CHKSDB (.SDB);		! Check for only state value
	CH$WCHAR_A (NMA$C_OP2_CHLST, PTR);	! Write option byte
	PTR = NCP$PH2COPYLINE (.PTR);		! Copy line id
	IF .STATE GTR NMA$C_STATE_OFF		! Check for valid state
	THEN NCP$PH2INVALID ()
	;
	CH$WCHAR_A (.STATE, PTR)		! Write state
	END;

    [OTHERWISE] :
	NCP$PH2INVALID ();			! May not set other things

    TES;

    NCP$SENDMSG					! Send the message
	(
	.NCP$GL_EXELCB,				! Link control block
	.PTR - NCP$GT_MSGBFR,			! Size
	NCP$GT_MSGBFR				! Message
	);

    NCP$PH2READRSP (LEN, BFR);			! Read response and
    						! print any error
    RETURN

    END;

%SBTTL	'NCP$PH2STAHDR   Print Header for Status'
ROUTINE NCP$PH2STAHDR (OPTION, KWN) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write header for show status.  Header is based on values of option
!	and known flag.
!
! FORMAL PARAMETERS:
!
!	OPTION		Value of option sent to NICE
!	KWN		True if known
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	OPT			! Option used in message
	;

    OPT = .OPTION;		! Option
    IF .KWN			! If known adjust code for dispatch
    THEN
	OPT = .OPT -1
    ;

    NCP$FAOSET ();			! Setup output conversion

    SELECTONE .OPT OF			! Dispatch on code
    SET

    [NMA$C_OP2_RENST] :			! Local status
	BEGIN
	ADDSTR ('!/Executor Status as of !20%D!/')
	END;

    [NMA$C_OP2_RELST - 1] :		! Known line status
	BEGIN
	ADDSTR
	    (%STRING
		(
		'!/Known Line Status as of !20%D!/',
		'!/!_Line id!_!_!_State!_!_!_Remote!/ '
		)
	    )
	END;

    [NMA$C_OP2_RELST] :			! Single line status
	BEGIN
	ADDSTR
	    (%STRING
		(
		'!/Line Status as of !20%D!/',
		'!/!_Line id!_!_!_State!_!_!_Remote!/ '
		)
	    )
	END;

    TES;

    ADDFAO (0);				! So we obtain system date
    ADDFAO (0);
    NCP$FAOWRITE ()			! Convert and write to output

    END;

%SBTTL	'NCP$PH2LOCSTA  Executor Status'
ROUTINE NCP$PH2LOCSTA (BFR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert executor status message
!
! FORMAL PARAMETERS:
!
!	BFR		Address of status message
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	ADR,				! Address of node
	NODE,				! Name of node
	OPSYS,				! Operating system version
	ROUTEVER : VECTOR [3, BYTE],	! Routing version
	COMMVER  : VECTOR [3, BYTE],	! Communication version
	STATE,				! State of local
	HOST,				! Host of local
	PTR				! Pointer into message
	;


    MACRO
	CTRSTR = 			! Fao control string
	%STRING
	    (
	    '!/Node = !UL (!AC)',
	    '!/System                = !AC',
	    '!/Routing version       = V!UB.!UB.!UB',
	    '!/Communication version = V!UB.!UB.!UB',
	    '!/State                 = !AC',
	    '!/Default Host          = !AC'
	    )
	%;


    PTR = .BFR;				! Set pointer to parse message
    NODE = .PTR;			! Node name
    PTR = .PTR + CH$RCHAR_A (PTR);	! Skip counted string
    PTR = NCP$EXTTOBIN (.PTR, ADR);	! Obtain address
    NCP$CNVSTATE ( CH$RCHAR_A (PTR), STATE); ! Convert state byte
    PTR = .PTR + 2;			! Skip logging info (not used)
    HOST = .PTR;			! Host node name
    PTR = .PTR + CH$RCHAR_A (PTR);	! Skip counted string
    CH$MOVE (3, .PTR, ROUTEVER);	! Routing version
    PTR = .PTR + 3;
    CH$MOVE (3, .PTR, COMMVER);		! Comm version
    PTR = .PTR + 3;
    OPSYS = .PTR;			! Operating system text

    ADDSTR (CTRSTR);			! Load control strings
    ADDFAO (.ADR);			! Arguments in correct order
    ADDFAO (.NODE);
    ADDFAO (.OPSYS);
    ADDFAO (.ROUTEVER [0]);
    ADDFAO (.ROUTEVER [1]);
    ADDFAO (.ROUTEVER [2]);
    ADDFAO (.COMMVER [0]);
    ADDFAO (.COMMVER [1]);
    ADDFAO (.COMMVER [2]);
    ADDFAO (.STATE);
    ADDFAO (.HOST)

    END;

%SBTTL	'NCP$PH2LINSTA  Line Status'
ROUTINE NCP$PH2LINSTA (BFR) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert and write line status buffer
!
! FORMAL PARAMETERS:
!
!	Pointer to buffer
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATE,				! State of line
	PTR				! Pointer into message
	;		!

    ADDSTR ('!_');			! Set up some indent
    PTR = NCP$OUTLINE (.BFR);		! Convert line to text
    NCP$CNVSTATE (CH$RCHAR_A (PTR), STATE); ! Convert state of line
    ADDSTR ('!24AC!AC');		! Counted string for state and remote
    ADDFAO (.STATE);			! State of line
    ADDFAO (.PTR + 2)			! Pointer to node name, skip 2 zeros

    END;

%SBTTL	'NCP$PH2WRISTA  Dispatch to Write Status'
ROUTINE NCP$PH2WRISTA (OPT) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read response message from NICE and dispatch to write output.
!
! FORMAL PARAMETERS:
!
!	OPT		Value of option
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	LEN,				! Return length of response
	BFR				! Return buffer address
	;		!

    NCP$PH2READRSP (LEN, BFR);		! Read response

    NCP$FAOSET ();			! Set conversion buffers

    SELECTONE .OPT OF			! Dispatch on options
    SET

    [NMA$C_OP2_RENST] :			! Executor status
	NCP$PH2LOCSTA (.BFR);

    [NMA$C_OP2_RELST] :			! Line status
	NCP$PH2LINSTA (.BFR);

    TES;

    NCP$FAOWRITE ()			! Convert and write messages

    END;

%SBTTL	'NCP$PH2SHOSTA  Display Status'
ROUTINE NCP$PH2SHOSTA :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Display status of the executor or lines.  A simple message is
!	sent to NICE to request the function and the return messages
!	are formatted and written to the output file for show.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into message
	OPT,				! Returned option used
	KWN,				! Returned true for KNOWN
	LEN,				! Length of return message
	BFR,				! Pointer to return message
	MSGS				! Number of messages in reply
	;		!

    PTR = NCP$PH2BLDMSG			! Build command message
	(
	NMA$C_FN2_REA,			! Function byte
	NMA$C_OP2_RELST,		! Option for lines
	NMA$C_OP2_RENST,		! Option for local
	OPT, KWN			! Return option and known
	);

    NCP$SENDMSG				! Send message to NICE
	(
	.NCP$GL_EXELCB,
	.PTR - NCP$GT_MSGBFR,
	NCP$GT_MSGBFR
	);

    NCP$PH2READRSP (LEN, BFR);		! Read number of messages

    IF .LEN NEQ 2			! Must be two bytes
    THEN
	SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('Invalid number of messages') )
    ;

    MSGS = .(.BFR) <0, 16>;		! Obtain number

    NCP$PH2STAHDR (.OPT, .KWN);		! Write header for messages

    DECR DCX FROM .MSGS TO 1		! Read each and write it out
    DO
	NCP$PH2WRISTA (.OPT)
    ;

    RETURN

    END;

%SBTTL	'NCP$PH2COUNTS  Convert Counts in a Message'
ROUTINE NCP$PH2COUNTS (PSTR, PEND, TBL) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert and write the counts in a message.
!
! FORMAL PARAMETERS:
!
!	PSTR		Address of start of counters in message
!	PEND		End of message
!	TBL		Address of table to use for conversions
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into message
	COUNTER,			! Value of the counter
	COUTYPE,			! Type code of counter
	COUNAM				! Address of counted counter name
	;		!

    PTR = .PSTR;			! Initialize pointer
    WHILE .PEND GTRU .PTR		! Scan the whole message
    DO
	BEGIN
	PTR = NCP$EXTTOBIN (.PTR, COUTYPE); ! Obtain the counter type code
	COUNTER = .(.PTR) <0, 16>;	! The counter value
	PTR = .PTR + 2;			! Skip the counter
	NCP$FAOSET ();			! Setup output conversion
	IF .COUNTER <15,1>		! Check for overflow
	THEN
	    ADDSTR ('    Overflow')	! Sure enough, overflow it is.
	ELSE
	    BEGIN
	    ADDSTR ('!12UL');		! Write the counter value
	    ADDFAO (.COUNTER)
	    END
	;
	ADDSTR ('  ');			! Some white space
	IF NCP$TABLESEARCH (.COUTYPE, .TBL, COUNAM) ! Look for the counter
	THEN				! type code in the table
	    BEGIN
	    ADDSTR ('!AC');		! Write the name
	    ADDFAO (.COUNAM)
	    END
	ELSE
	    BEGIN			! For unknown types, write the number
	    ADDSTR ('Counter type #!UW');
	    ADDFAO (.COUTYPE)
	    END
	;
	NCP$FAOWRITE ()			! Perform output conversion
	END
    
    END;

%SBTTL	'NCP$PH2COUHDR  Header for Show Counts'
ROUTINE NCP$PH2COUHDR (OPTION, KNOWN) :NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write header for show counts.
!
! FORMAL PARAMETERS:
!
!	OPTION			Value of option byte used
!	KNOWN			True for known option used
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	OPT				! Option value
	;


    OPT = .OPTION;			! Obtain the option value
    IF .KNOWN				! Adjust for unique based on known
    THEN				! Flag
	OPT = .OPT - 1
    ;

    NCP$FAOSET ();			! Setup output conversion

    ADDSTR ('!/');			! Leave a little space

    SELECTONE .OPT OF			! Dispatch on option value
    SET					! for lead word

    [NMA$C_OP2_RELCT] : ADDSTR ('Line');

    [NMA$C_OP2_RELCT - 1] : ADDSTR ('Known Lines');

    [NMA$C_OP2_RENCT] : ADDSTR ('Executor');

    TES;

    ADDSTR (' Counts as of !20%D!/ ');	! Fill in the date
    ADDFAO (0);				! Use system date and time
    ADDFAO (0);
    NCP$FAOWRITE ()			! Output conversion

    END;

%SBTTL	'NCP$PH2WRICOU  Write Counts'
ROUTINE NCP$PH2WRICOU (OPTION) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read a NICE counters message and convert and write counts
!	based on the option.
!
! FORMAL PARAMETERS:
!
!	OPTION		Value of option byte sent to NICE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	TABLE,				! Address of counter text table
	PTR,				! Pointer into message
	PEND,				! Pointer to end of message
	LEN				! Length of message
	;		!

    TABLE =				! Select conversion table to use
	(
	SELECTONE .OPTION OF
	SET
	[NMA$C_OP2_RENCT] : NCP$GA_TBL_PH2EXECOU; ! Local node
	[NMA$C_OP2_RELCT] : NCP$GA_TBL_PH2LINCOU; ! Lines
	[OTHERWISE]       : NCP$GA_TBL_PH2LINCOU; ! Lines, prevent failure
	TES
	);

    NCP$PH2READRSP (LEN, PTR);		! Read response

    PEND = .PTR + .LEN;			! Point to end of message
    NCP$FAOSET ();			! Setup output conversion

    SELECTONE .OPTION OF		! Write header for a the executor
    SET
    [NMA$C_OP2_RENCT] :			! Header for local node
	BEGIN
	ADDSTR ('!/Node = !AC!/ ');
	ADDFAO (.PTR);
	PTR = .PTR + CH$RCHAR_A (PTR)	! Skip over a counted string
	END;
    [NMA$C_OP2_RELCT] :			! Line counters
	BEGIN
	ADDSTR ('!/Line = ');		! Line name
	PTR = NCP$OUTLINE (.PTR);	! Convert line name to text
	ADDSTR ('!/ ')
	END;
    TES;

    NCP$FAOWRITE ();			! Convert and write to output

    NCP$PH2COUNTS (.PTR, .PEND, .TABLE)	! Process counts in message

    END;

%SBTTL	'NCP$PH2SHOCOU  Display Counts'
ROUTINE NCP$PH2SHOCOU :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Display counts from local or lines.  Build command message and 
!	send to NICE.  Receive return number of messages and dispatch
!	for conversion of remainder of output.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer to build message
	OPT,				! Option used
	KWN,				! True for known
	LEN,				! Return length of response
	BFR,				! Address of response
	MSGS				! Number of message following
	;		!


    PTR = NCP$PH2BLDMSG			! Build message to send
	(
	NMA$C_FN2_REA,			! Function code is a read
	NMA$C_OP2_RELCT,		! Option for lines
	NMA$C_OP2_RENCT,		! Option for local
	OPT, KWN			! Return option and known used
	);

    NCP$SENDMSG				! Send the message
	(
	.NCP$GL_EXELCB,			! Link control block
	.PTR - NCP$GT_MSGBFR,		! Length of message
	NCP$GT_MSGBFR			! Buffer address
	);

    NCP$PH2READRSP (LEN, BFR);		! Read response

    IF .LEN NEQ 2			! Valid count
    THEN
	SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('Invalid number of messages') )
    ;

    MSGS = .(.BFR) <0, 16>;		! Grab the number of messages

    NCP$PH2COUHDR (.OPT, .KWN);		! Write the header

    DECRU DCX FROM .MSGS TO 1		! Count it down
    DO
	NCP$PH2WRICOU (.OPT)		! Write each message

    END;

%SBTTL	'NCP$PH2LOOP  Perform Loop Function with Phase 2'
GLOBAL ROUTINE NCP$PH2LOOP =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Build and send phase 2 loop message to NICE.  Loop target must be
!	a node specified by name or the executor.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	PDB$G_VRB_ENT
!	PDB$G_LOO_CNT
!	PDB$G_LOO_WTH
!	PDB$G_LOO_LEN
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	False if not phase 2, True otherwise
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	TXTSIZ = 32			! Size of error message text
	;

    LOCAL
	PTR,				! Pointer into output message
	COLON,				! Position of colon in ncb
	DQUOT,				! Position of double quote in ncb
	SIZ,				! Size of ncb string
	NCB,				! Point to ncb string
	NCBEND,				! End of ncb string
	TXTDSC : VECTOR [2],		! Descriptor for error text
	OUTLEN,				! Result length of error text
	CNT,				! Returned message count
	LEN,				! Returned data count
	BFR				! Returned data address
	;		!

    BIND
	NULSTR = ASCIC ('')		! Just a little null string
	;

    OWN
	TXTBFR : VECTOR [TXTSIZ, BYTE]	! Error text buffer
	;

    IF NOT NCP$PH2Q ()			! If not phase II
    THEN
	RETURN FALSE			! Just return false
    ;

    PTR = NCP$GT_MSGBFR;		! Set pointer to build message
    CH$WCHAR_A (NMA$C_FN2_TES, PTR);	! Test function
    CH$WCHAR_A (0, PTR);		! Node option

    IF .NCP$GL_OPTION [NMA$V_OPT_ENT] NEQ NMA$C_ENT_NOD ! Must be a node
    THEN					! you know
	NCP$PH2INVALID ()			! Or bump him off
    ;

    IF .PDB$G_VRB_ENT [1, 0, 24, 0] EQL 0	! Check for executor node
    THEN
	BEGIN					! Find the executor node name
	NCB = .NCP$GL_EXELCB [LCB$L_NCBPTR];	! Look for node name in
	SIZ = .NCP$GL_EXELCB [LCB$L_NCBCNT];	! the link control block
	COLON = CH$FIND_CH (.SIZ, .NCB, ':');	! Look for end of nodename
	DQUOT = CH$FIND_CH (.SIZ, .NCB, '"');	! or access control
	IF (NCBEND = MIN (.COLON, .DQUOT) )	! Select address of end
	    EQL 0				! Pick shortest string
	THEN
	    NCP$PH2INVALID ()			! One was not there, bug
	;
	SIZ = .NCBEND - .NCB;			! Size of node name string
	CH$WCHAR_A (.SIZ, PTR);			! Build as counted string
	PTR = CH$MOVE (.SIZ, .NCB, .PTR)	! Now copy the string
	END
    ELSE
	BEGIN
	IF .PDB$G_VRB_ENT [1, 0, 8, 0] EQL 0	! Not executor, must be by
	THEN					! name not number
	    NCP$PH2INVALID ()			! Too bad, passed by number
	;
	PTR = CH$MOVE				! Copy the name to output
	    (					! and the count too
	    CH$RCHAR (PDB$G_VRB_ENT + 1) + 1,
	    PDB$G_VRB_ENT [PDB$T_DATA],
	    .PTR
	    );
	END
    ;

    IF .PDB$G_LOO_CNT [PDB$B_STS_FLG]		! Build the loop parameters
    THEN					! with the appropriate default
	PTR = CH$MOVE (2, PDB$G_LOO_CNT [PDB$T_DATA], .PTR)
    ELSE
	PTR = CH$MOVE (2, UPLIT (NMA$C_LOOP_DCNT), .PTR)
    ;

    IF .PDB$G_LOO_WTH [PDB$B_STS_FLG]
    THEN
	CH$WCHAR_A (.PDB$G_LOO_WTH [PDB$T_DATA], PTR)
    ELSE
	CH$WCHAR_A (NMA$C_LOOP_MIX, PTR)
    ;

    IF .PDB$G_LOO_LEN [PDB$B_STS_FLG]
    THEN
	PTR = CH$MOVE (2, PDB$G_LOO_LEN [PDB$T_DATA], .PTR)
    ELSE
	PTR = CH$MOVE (2, UPLIT (NMA$C_LOOP_DSIZ), .PTR)
    ;

    NCP$SENDMSG					! Send the message to NICE
	(
	.NCP$GL_EXELCB,
	.PTR - NCP$GT_MSGBFR,
	NCP$GT_MSGBFR
	);

    NCP$PH2READRSP (LEN, BFR);			! Expect one response

    IF .LEN NEQ 2				! With messages not looped
    THEN
	SIGNAL_STOP (NCP$_BADMSG, 1, ASCIC ('Invalid loop return') )
    ;

    CNT = .(.BFR) <0, 16>;			! Obtain messages not looped

    IF .CNT NEQ 0
    THEN
	BEGIN
	TXTDSC [0] = TXTSIZ - 1;		! Build descriptor of data
	TXTDSC [1] = TXTBFR + 1;
	$FAO					! Convert it to text
	    (
	    ASCID ('Messages not looped = !UW'),
	    OUTLEN,
	    TXTDSC,
	    .CNT
	    );
	TXTBFR [0] = .OUTLEN;			! Fix as a counted string
	SIGNAL					! And signal the error
	    (
	    NCP$_NMLRSP,
	    5,
	    TXTBFR, NULSTR, NULSTR, NULSTR, NULSTR
	    )
	END
    ;

    RETURN SUCCESS				! We are phase II

    END;

%SBTTL	'NCP$PH2SHOLNK  Display Links Phase 2'
ROUTINE NCP$PH2SHOLNK :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Display links from a phase 2 node.  Command message is built and
!	sent.  Reply messages are parsed and written to the output file.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into messages
	LEN,				! Returned length of response
	BFR,				! Returned address of response
	LINKS				! Links in response messages
	;

    MACRO
	LINKHEAD = '!/Known Links for Executor as of !20%D!/ '%,
	NOLINKS = 'No links'%
	;

    PTR = NCP$GT_MSGBFR;		! Set pointer to build message
    CH$WCHAR_A (NMA$C_FN2_REA, PTR);	! Function code is read
    CH$WCHAR_A (7, PTR);		! Option for links

    NCP$SENDMSG				! Send the message
	(
	.NCP$GL_EXELCB,			! Link control block
	.PTR - NCP$GT_MSGBFR,		! Length of message
	NCP$GT_MSGBFR			! Buffer
	);

    NCP$PH2READRSP (LEN, BFR);		! Read first response

    NCP$FAOSET ();			! Set to write header

    ADDSTR (LINKHEAD);			! Header
    ADDFAO (0);				! For the datetime
    ADDFAO (0);

    NCP$FAOWRITE ();			! Write that much

    DECRU DCX FROM .(.BFR) <0, 16> TO 1	! Count the messages down
    DO
	BEGIN
	NCP$PH2READRSP (LEN, BFR);	! Read a message
	PTR = .BFR;			! Look at it carefully
	NCP$FAOSET ();			! Start with the required node
	ADDSTR ('!/Node = !AC!/ ');
	ADDFAO (.PTR);
	PTR = .PTR + CH$RCHAR_A (PTR);	! Skip the counted string
	NCP$FAOWRITE ();		! Write that much

	IF CH$RCHAR_A (PTR) NEQ 1	! Check the code
	THEN
	    SIGNAL_STOP (NCP$_BADMSG, 1,
	    		ASCIC ('Invalid phase II link code') )
	;
	LINKS = .(.PTR) <0, 16>;	! Get number of links
	PTR = .PTR + 2;			! Skip that
	NCP$FAOSET ();			! Set to write links
	IF .LINKS NEQ 0			! If there are any
	THEN
	    BEGIN
	    INCRU DCX FROM 1 TO .LINKS	! Count it down
	    DO
		BEGIN
		ADDSTR ('!_!5UW/!XL');	! The link format (link, pid)
		ADDFAO (.(.PTR) <0, 16>); ! Get link number
		PTR = .PTR + 2;		! Skip that
		ADDFAO (..PTR);		! Get the pid
		PTR = .PTR + 4;		! Skip that too
		IF (.DCX MOD 4) EQL 0	! Every now and then, write it out
		THEN			! for a blank line
		    BEGIN
		    NCP$FAOWRITE ();
		    NCP$FAOSET ()	! and reset the buffers
		    END
		END
	    END
	ELSE
	    ADDSTR (NOLINKS)		! No links for that node
	;

	NCP$FAOWRITE ()			! Clean up and write it out
	END
    ;

    NCP$FAOSET ();			! Two blank lines at the end
    ADDSTR ('!/ !/ ');
    NCP$FAOWRITE ()

    END;

%SBTTL	'NCP$PH2ZERO  Perform Zero with NICE'
ROUTINE NCP$PH2ZERO :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform Zero function with Phase II NICE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR,				! Pointer into buffer
	OPT,				! Return option used
	KWN,				! Return known
	LEN,				! Return length
	BFR				! Return buffer address
	;		!


    PTR = NCP$PH2BLDMSG			! Build the message
	(
	NMA$C_FN2_ZER,			! Function code
	NMA$C_OP2_ZELCT,		! Line option
	NMA$C_OP2_ZENCT,		! Local option
	OPT,				! Return option
	KWN				! Return known
	);

    NCP$SENDMSG				! Send the message
	(
	.NCP$GL_EXELCB,			! Link control block
	.PTR - NCP$GT_MSGBFR,		! Size
	NCP$GT_MSGBFR			! Message
	);

    NCP$PH2READRSP (LEN, BFR);		! Read response and print any error

    RETURN

    END;

%SBTTL	'NCP$PH2UTILITY  Perform Utility Phase II Functions'
GLOBAL ROUTINE NCP$PH2UTILITY (SDB) =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is an interface routine with the normal verb action routines.
!	It validates the phase II ness of our executor and if not it
!	returns false.  If our executor is phase II, then we dispatch to
!	the correct function routine after some initial validation and
!	then return true to indicate that the function has been performed.
!
! FORMAL PARAMETERS:
!
!	SDB		Address of SDB for Set state functions
!
! IMPLICIT INPUTS:
!
!	NCP$GL_FNC_CODE
!	NCP$GL_OPTION
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Success if function performed,  Failure if not Phase II.
!	As always, errors are signalled.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    IF NOT NCP$PH2Q ()			! If our executor is not phase II
    THEN
	RETURN FALSE			! We do not do windows
    ;

    SELECTONE .NCP$GL_FNC_CODE OF	! We only do a few functions here
    SET

    [NMA$C_FNC_CHA] :			! Change parameter value
	BEGIN
	IF .NCP$GL_OPTION [NMA$V_OPT_CLE] ! But not to clear it
	    OR
	    .NCP$GL_OPTION [NMA$V_OPT_PER] ! and not to permanent database
	THEN
	    NCP$PH2INVALID ()		! So barf on those
	;
	NCP$PH2SETSTA (.SDB)		! Set state line or executor
	END;

    [NMA$C_FNC_ZER] :			! We zero lines or executor too
	NCP$PH2ZERO ();

    [OTHERWISE] :			! But nothing else here
	NCP$PH2INVALID ();

    TES;

    RETURN SUCCESS			! We must have done it successfully

    END;

%SBTTL	'NCP$PH2SHOLIS  Perform Show Functions'
GLOBAL ROUTINE NCP$PH2SHOLIS =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return false if our executor is not phase 2.  If it is, perform
!	some validity checks and dispatch to the correct routine to
!	show links, show status or executor or lines or show counts of
!	the executor or lines.  Return true if we performed a function.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NCP$GL_OPTION
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	False if not phase II, True if so, errors signalled.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	INF,				! Hold information type
	ENT				! Hold entity type
	;		!

    IF NOT NCP$PH2Q ()			! If not phase II
    THEN
	RETURN FALSE			! Return not phase II
    ;

    IF .NCP$GL_OPTION [NMA$V_OPT_PER]	! Must not be permanent (LIST)
    THEN
	NCP$PH2INVALID ()
    ;

    INF = .NCP$GL_OPTION [NMA$V_OPT_INF];	! Obtain information type
    ENT = .NCP$GL_OPTION [NMA$V_OPT_ENT];	! Obtain entity type

    SELECTONE .ENT OF			! Check entity
    SET

    [NMA$C_SENT_LNK] :			! If link, show no matter what else
	BEGIN
	NCP$PH2SHOLNK ();
	RETURN SUCCESS
	END;

    [NMA$C_ENT_NOD] : 0;		! Node entity is ok
    
    [NMA$C_ENT_LIN] : 0;		! So are lines

    [OTHERWISE] :			! All else is invalid
	NCP$PH2INVALID ();

    TES;

    SELECTONE .INF OF			! Check information code
    SET

    [NMA$C_OPINF_SUM] :			! Take summary as status
	NCP$PH2SHOSTA ();

    [NMA$C_OPINF_STA] :			! Accept status too
	NCP$PH2SHOSTA ();

    [NMA$C_OPINF_COU] :			! If counts, then show them
	NCP$PH2SHOCOU ();

    [OTHERWISE] :			! Every thing else is invalid
	NCP$PH2INVALID ();

    TES;

    RETURN SUCCESS			! We must have succeeded

    END;

END				!End of module
ELUDOM
