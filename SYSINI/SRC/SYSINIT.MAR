	.TITLE	SYSINIT	- SYSTEM INITIALIZATION PROCESS
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	SYSTEM INITIALIZATION
;
; ABSTRACT:	PERFORMS OPERATIONS NECESSARY TO GET
;		THE SYSTEM TO A POINT THAT IT CAN
;		SUPPORT ITSELF.
;
; ENVIRONMENT:	OPERATES WITHIN THE LIMITED CAPABILITIES
;		THE BOOT STRAPPED OPERATING SYSTEM.
;
; AUTHOR:  W.H.BROWN, CREATION DATE:  6-JAN-77
;
; MODIFIED BY:
;
;	V03-002	LJK0165		Lawrence J. Kenah	20-Apr-1982
;		Correct test for SWPFILCNT parameter set to zero.
;
;	V03-001	PHL0040		Peter H. Lipman		16-Mar-1982
;		Allow dump to be in page file.  If it is, then
;		conditionally preserve the dump by marking the
;		pages "in use" in the page file bit map.  SDA
;		will release them when the dump is analyzed.
;
;		Use new "rich" system quota list for STARTUP.
;
;	V02-035	KTA0078		Kerbey T. Altmann	11-Feb-1982
;		Add support for SYSGEN parameter TPWAIT - the amount
;		of time to wait for input of system time before
;		deciding that there is no operator and booting anyway.
;
;	V02-034	LJK0126		Lawrence J. Kenah	9-Feb-1982
;		Treat files with from 1 to 7 blocks as having zero blocks.
;		Demand that swap file size be at least as big as the
;		SWPALLOCINC SYSGEN parameter.
;
;	V02-033	LJK0113		Lawrence J. Kenah	8-Jan-1982
;		Increase size of OPA0 output buffer to 132 bytes.
;		Remove obsolete error messages.
;
;	V02-032	LJK0106		Lawrence J. Kenah	17-Dec-1981
;		If initialization of page or swap file fails because of
;		insufficient memory, see if FIL$OPENCACHE can be
;		deallocated before reporting failure.
;
;	V02-031	PHL0024		Peter H. Lipman		17-Nov-1981
;		If TOPSYS is not null make a shared ACP known file
;		entry with the correct full directory path name.
;
;	V02-030	PHL0023		Peter H. Lipman		1-Nov-1981
;		Change SYS$SYSDISK to SYS$SYSDEVICE.
;		Change interface to INS$CREDEL
;
;	V02-029	KDM40417	Kathleen D. Morse	04-Sep-1981
;		Count number of busy messages as well as valid messages
;		when scanning the error log buffers in the dump file.
;
;	V02-028	PHL0014		Peter H. Lipman		29-Aug-1981
;		Eliminate the leading "_" on the logical names for
;		SYS$SYSTEM, SYS$SHARE, and SYS$MESSAGE.  Using
;		SYS$SYSDISK instead of its translation didn't work.
;
;	V02-027	PHL0014		Peter H. Lipman		28-Aug-1981
;		Use SYS$SYSDISK instead of its translation for the
;		device in the logical names for SYS$SYSTEM, SYS$SHARE,
;		and SYS$MESSAGE.
;
;	V02-026	LJK0048		Lawrence J. Kenah	20-Aug-1981
;		Move initialization of page file control block
;		vector from SYSINIT to INIT.
;
;	V02-025	LJK0044		Lawrence J. Kenah	11-Aug-1981
;		Cause page file and swap file initialization to use same
;		closed procedure used by SYSGEN. Also make other modifications
;		to allow variable number of page or swap files.
;
;	V02-024	HRJ0025		Herb Jacobs		31-Jul-1981
;		Handle initialize of updated page file control block.
;
;	V02-023	KDM0057		Kathleen D. Morse	15-Jul-1981
;		Add SID to error log buffer message format and make
;		header information be negative values off front of message.
;
;	V02-022	HRJ0023		Herb Jacobs		06-Jul-1981
;		Change over of swap file to look as page file, and
;		removal of SFT control block.
;
;	V02-021	PHL0010		Peter H. Lipman		28-May-1981
;		If debugging SYSINIT with DELTA, the startup process
;		gets the null device for its output and error files.
;
;		If SYSPAGING = 0, don't map RMS, rather, read it in to
;		DZRO pages using the same SPT slots that would have been
;		used to map it.  If mapping RMS, the pages are now UR.
;
;		Virtual I/O for SYSDUMP and RMS is done through a new
;		routine QIO_RWVB in SYSINIT proper.
;
;		Use new $BOODEF macro to define Boot Control Block offsets
;
;		SYSDUMP.DMP is no longer required to be contiguous.
;		Remove the code that sets up the LBN, size, and checksum.
;
;	V02-020	LJK0025		Lawrence J. Kenah	18-May-1981
;		Use correct register when initializing swap file table entry.
;
;	V02-019	PHL0009		Peter H. Lipman		06-May-1981
;		SYSDUMP.DMP is now looked up by SYSBOOT.
;
;		Use virtual I/O code in BOOTCB to read and write
;		the DUMP file.
;
;		Allocate non-paged pool through a common allocator.
;		If the allocation fails due to lack of pool, release the
;		FILEREAD cache and try again.  Zero the block allocated.
;
;	V02-018	PHL0008		Peter H. Lipman		21-Apr-1981
;		Move the creation of JOBCTL, OPCOM, and ERRFMT out
;		of this code to the STARTUP command file.
;
;		Find the real directory name of the SYS$TOPSYS directory.
;
;		Create system wide logical name SYS$TOPSYS for the
;		top level system directory.
;
;	V02-017	PHL0007		Peter H. Lipman		28-Mar-1981
;		Implement the TOPSYS top level directory in which the
;		system directories are found.  Deallocate the new
;		FIL$OPENFILE cache when done using FILEREAD.  Open
;		SYSMSG.EXE via RMS rather than via FIL$OPENFILE.
;
;	V02-016	PHL0006		Peter H. Lipman		04-Mar-1981
;		The following files are no longer required to be contiguous
;			[SYSEXE]PAGEFILE.SYS
;			[SYSEXE]SWAPFILE.SYS
;			[SYSEXE]RMS.EXE
;			[SYSMSG]SYSMSG.EXE
;
;	V02-015	PHL0002		Peter H. Lipman		27-Jan-1981
;		Initialize page file control block with one less
;		"reservable" page than allocatable page.  This
;		combines with a fix in [SYS.SRC]PAGEFILE.MAR to
;		keep the modified page writer working even when
;		the pagefile has run dead out of space.
;
;	V02-014	GWF0006		Gary Fowler		11-Dec-1980
;		Changed reference to SGN$GW_MAXGPGCT to SGN$GL_MAXGPGCT
;
;	V02-013	GRR0001		Greg Robert		13-Oct-1980
;		Replaced references to SFT$B_SLTCNT with SFT$W_SLTCNT
;
;	V02-012	RIH32713	Richard I. Hustvedt 	15-Sep-1980
;		Provide for greater than 128 swap slots in the initial
;		swapping file.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:	NONE
	.nocross

;
; MACROS:
;
;
; PROGRAM SECTION DEFINITION MACROS
;	ARGUMENTS ARE:
;		1) SECTION NAME (KEY WORD IS NAME)
;		2) ALIGNMENT    (KEY WORD IS ALIGN)
;
;	IN ALL CASE, ARGUMENTS ARE OPTIONAL
;
; MACRO TO GENERATE A PROGRAM SECTION FOR EXECUTABLE CODE
;
	.MACRO	PURE_SECT NAME=SIP_PURE,ALIGN=BYTE
 
	.PSECT	NAME	EXE,RD,NOWRT,ALIGN
 
	.ENDM	PURE_SECT
;
; MACRO TO GENERATE IMPURE DATA SEGMENT
;
	.MACRO	IMPURE_DATA  NAME=SIP_RWDATA,ALIGN=LONG
 
	.PSECT	NAME	NOEXE,WRT,RD,ALIGN
 
	.ENDM	IMPURE_DATA
;
; MACRO TO GENERATE A STRING WITH DESCRIPTOR
;
;	STRING_DESC <STRING> 
;
; WHERE:
;	<STRING> IS THE STRING TO BE USED
;
	.MACRO	STRING_DESC ST,?L1,?L2
 
	.LONG	L2-L1
	.LONG	L1
L1:	.ASCII	\ST\
L2:
 
	.ENDM

;
; MACRO TO GENERATE A LIST OF SELFRELATIVE WORD POINTERS
;
	.MACRO	OFFSET	LIST
	.IRP	$$$,<LIST>
	.WORD	<$$$-.-2>
	.ENDR
	.ENDM	OFFSET
;
; EQUATED SYMBOLS:
;
	$ATRDEF				; FILE ATTRIBUTE DEFINITIONS
	$BOODEF				; BOOT CONTROL BLOCK DEFINITIONS
	$CCBDEF				; CHANNEL CONTROL BLOCK DEFINITIONS
	$DEVDEF				; DEVICE BIT DEFINITIONS
	$DMPDEF				; SYSTEM DUMP FILE HEADER DEFINITONS
	$DYNDEF				; STRUCTURE TYPE DEFINITIONS
	$EMBDEF CR			; ERROR LOG MESSAGE BUFFER FORMAT
	$ERLDEF				; ERROR LOG BUFFER DEFINITIONS
	$FIDDEF				; FILE ID OFFSET DEFINITIONS
	$IHDDEF				; IMAGE FILE HEADER DEFINITIONS
	$IHPDEF				; IMAGE HEADER PATCH DEFINITIONS
	$IHSDEF				; IMAGE HEADER SYMBOLIC DEBUGGING DEFS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$KFIDEF				; KNOWN FILE ENTRY DEFINITIONS
	$KFPDEF				; KNOWN FILE POINTER BLOCK DEFINITIONS
	$LOGDEF				; DEFINE LOG OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFLDEF				; PAGE FILE OFFSET DEFINITONS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRTDEF				; PAGE PROTECTION DEFINITIONS
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$PTRDEF				; POINTER CONTROL BLOCK OFFSETS
	$RPBDEF				; DEFINE RPB OFFSETS
	$SECDEF				; DEFINE PROCESS SECTION
	$TQEDEF				; DEFINE TIMER QUEUE ENTRY OFFSETS
	$UCBDEF				; UNIT CONTROL BLOCK DEFINITIONS
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$WCBDEF				; WINDOW CONTROL BLOCK DEFINITIONS

	SIP_C_DUMPVER = 2		; DUMP FILE HEADER VERSION
	SIP_C_MINPAGFIL = 2500-2048	; MINIMUM PAGE FILE REQUIRED
;
; OFFSETS INTO FILE ATTRIBUTES ARRAY
;
	$OFFSET	0,POSITIVE,<-
	<STATBLK,0>,-			; 8 BYTE STATISTICS BLOCK CONSISTING OF
	FILELBN,-			; STARTING LBN OR 0 IF NOT CONTIG
	FILESIZE,-			; SIZE OF FILE IN 512 BYTE BLOCKS
	IMAGEVBN,-			; FIRST VBN IF IMAGE FORMAT
	IMAGESIZE,-			; SIZE IF IMAGE FORMAT
	RTRVLEN,-			; BYTE COUNT OF RETRIEVAL POINTERS
	<RTRVPTRS,0>-			; FIRST RETRIEVAL POINTER
	>
;
; OFFSETS INTO CRELOG SCRATCH STORAGE
;
	$OFFSET 0,POSITIVE,<-
	CRELOG_BUFSIZ,-			; SIZE OF STRING TO TRANSLATE TO
	CRELOG_BUFADR,-			; ADDRESS OF STRING TO TRANSLATE TO
	<CRELOG_LOGNAM,8>,-		; DESCRIPTOR OF LOGICAL NAME STRING
	<CRELOG_BUF,32>-		; STRING TO TRANSLATE TO
	>

	.WEAK	XDT$START		; IF DEBUGGING, THEN DEFINED

	.cross

;
; OWN STORAGE:
;
	PURE_SECT
 
SIP_Q_TTNAME:
	STRING_DESC	<OPA0>		; DEVICE NAME FOR TERMINAL
 
SIP_Q_DSKNAME:
	STRING_DESC	<SYS$SYSDEVICE>	; DEVICE NAME FOR SYSTEM DISK

;
; LOGICAL NAMES TO CREATE, FORMAT:
;	DIRECTORY NAME STRING TO TRANSLATE TO (NO BRACKETS)
;	LOGICAL NAME TO CREATE
;
	.ENABL	LSB
SIP_A_CRELOG:
	.LONG	10$,SIP_T_SYSTEM	; SYS$SYSTEM
	.LONG	20$,SIP_T_SHARE		; SYS$SHARE
	.LONG	30$,SIP_T_MESSAGE	; SYS$MESSAGE
	.LONG	0			; END OF TABLE
SIP_T_SYSTEM:
	.ASCIC	/SYS$SYSTEM/
10$:	.ASCIC	/SYSEXE/		; DIRECTORY FOR SYS$SYSTEM
SIP_T_SHARE:
	.ASCIC	/SYS$SHARE/
20$:	.ASCIC	/SYSLIB/		; DIRECTORY FOR SYS$SHARE
SIP_T_MESSAGE:
	.ASCIC	/SYS$MESSAGE/
30$:	.ASCIC	/SYSMSG/		; DIRECTORY FOR SYS$MESSAGE
	.DSABL	LSB

SIP_Q_FIBDESC:
	.LONG	SIP_C_FIB_SIZE,SIP_A_FIB ; DESCRIPTOR FOR FILE IDENT BLOCK
SIP_A_ATRLIST:
	.WORD	ATR$S_ASCNAME,ATR$C_ASCNAME ; ASCII NAME ATTRIBUTE
	.LONG	SIP_A_ERLBUFFER		; SET ADR TO STORE NAME HERE
	.LONG	0			; END OF ATTRIBUTE LIST
SIP_Q_TOPSYS:
	STRING_DESC	<SYS$TOPSYS>	; TOP LEVEL SYSTEM DIRECTORY NAME
 
SIP_Q_STARTUP:				; STARTUP PROCESS NAME
	STRING_DESC	<STARTUP>	;


SIP_Q_SPOUTPUT:				; STARTUP PROCESS OUTPUT
	STRING_DESC	<OPA0:>		; CONSOLE
SIP_Q_SPOUTXDT:				; STARTUP PROCESS OUTPUT (DELTA)
	STRING_DESC	<NLA0:>		; NULL DEVICE

SIP_Q_SPIMAGE:				; STARTUP PROCESS IMAGE
	STRING_DESC	<SYS$SYSTEM:LOGINOUT.EXE>	; NORMAL LOGINOUT IMAGE
SIP_Q_SYSUAF:				; SYSUAF NAME STRING
	STRING_DESC	<SYSUAF>	;

SIP_Q_SYSUAFALT:			; SYSUAF ALTERNATE NAME
	STRING_DESC	<SYSUAFALT>	;

 
SIP_Q_PRVMSK:
	.LONG	-1,-1			; INITIAL PRIVILEGES
 
FAOERR:	STRING_DESC  <%SYSINIT-E- !AC, status = !XL>
CRELOGERR:
	.ASCIC	\failed to create system logical names\
PAGFILERR:
	.ASCIC	\lookup failure on paging file\
MSGFILERR:
	.ASCIC	\message file not found, or insufficient SPT to map it\
 
ACPINIERR:
	.ASCIC	\F11ACP initialization error\
 
MOUERR:	.ASCIC	\error mounting system device\
 
INIPAGFIL:				; ERROR INITIALIZING THE PAGE OR SWAP FILE
	.ASCIC	\page file or swap file control block initialization error\
 
RMSMAPERR:				; ERROR ON RMS FILE MAP
	.ASCIC	\RMS.EXE not found, or insufficient SPT to map it\

 
INIWCBERR:				; ERROR INITING A WINDOW CONTROL BLOCK
	.ASCIC	\error initing a WCB\
 
TIMERR:	.ASCIC	\invalid date/time\	;
 
INIKNOWNFIL:
	.ASCIC	\known file list initialization error\

TIMEPROMPT:
	.BYTE	NPROMPT
	.ASCII	<13><10>/PLEASE ENTER DATE AND TIME (DD-MMM-YYYY  HH:MM)  /
NPROMPT=.-TIMEPROMPT-1
 
PAGFILNAM:
	.ASCIC	\PAGEFILE.SYS\
SWPFILNAM:
	.ASCIC	\SWAPFILE.SYS\
RMSFILNAM:
	.ASCIC	\RMS.EXE\
MSGFILNAM:
	.ASCII	\SYS$MESSAGE:SYSMSG.EXE\
	MSGFILNAMSZ=.-MSGFILNAM
 
;
; ***** PAGE FILE MUST BE FIRST
;
SIP_A_NAMES:
	.LONG	PAGFILNAM		; FILENAME AND ERROR POINTER
	.LONG	SWPFILNAM		;
	.LONG	RMSFILNAM		;
	.LONG	0			; END OF LIST
 
	IMPURE_DATA SIP_RWDATA_PAGE,PAGE
;
;	BUFFER TO READ SYSTEM DUMP FILE FOR ERROR LOG INFORMATION
;
SIP_A_ERLBUFFER:			; 
	.BLKB	<3*512>			; 3 PAGES
SIP_A_INDEXFHDR	= SIP_A_ERLBUFFER	; INDEX FILE HEADER BUF (FIL$OPENFILE)
SIP_A_FILEHDR	= SIP_A_ERLBUFFER+512	; FILE HEADER BUFFER (FIL$OPENFILE)

	IMPURE_DATA
 
MSGFILFAB:	$FAB	FAC=GET,-	; FILE ACCESS IS GET (READ)
		FOP=<UFO>,-		; USER FILE OPEN
		FNA=MSGFILNAM,-		; ADDRESS OF FILE NAME STRING
		FNS=MSGFILNAMSZ,-		; 
		RFM=FIX,-		; FIXED RECORD FORMAT
		MRS=512,-		; MAXIMUM RECORD SIZE OF ONE PAGE
		RTV=255,-		; LET ACP COMPUTE LARGEST RETRIEVAL WINDOW
		XAB=MSGFILXAB		; EXTENDED ATTRIBUTE BLOCK
MSGFILXAB:	$XABFHC			; EXTENDED ATTRIBUTE BLOCK FOR FILE HEADER
SIP_A_FIB:				; FILE IDENTIFICATION BLOCK
	.LONG	0			; ACCESS CONTROL INFORMATION
	.WORD	0,0,0			; RETURNED FILE ID
	.WORD	FID$C_MFD,FID$C_MFD,0	; DIRECTORY ID OF MFD
	SIP_C_FIB_SIZE=.-SIP_A_FIB
SIP_L_TTCHAN:
	.BLKL	1			; CHANNEL FOR TERMINAL HERE
 
SIP_Q_RETADR:				; RETURN ADDRESS RANGE FROM EXPREG
	.BLKQ	1
SIP_Q_TMPDESC:				; TEMPORY STRING DESCRIPTOR
	.BLKQ	1
SIP_Q_STATBLK:
	.BLKQ	1			; STATISTICS BLOCK RETURNED BY FIL$OPENFILE
SIP_Q_RTRVBUF:				; DESCRIPTOR FOR RTRV PTR BUFFER
	.BLKQ	1
SIP_L_RTRVLEN:				; RETURNED RTRV PTR BUFFER LENGTH
	.BLKL	1
SIP_A_OPENARG:				; ARGUMENT LIST TO FIL$OPENFILE
	.LONG	7			; 7 ARGUMENTS TO FIL$OPENFILE
	.LONG	SIP_L_DSKCHAN		; ADDRESS TO RETURN DISK CHANNEL
	.LONG	SIP_Q_TMPDESC		; ADDRESS OF FILE NAME DESCRIPTOR
	.LONG	SIP_A_INDEXFHDR		; BUFFER ADDRESS FOR INDEX FILE HEADER
	.LONG	SIP_A_FILEHDR		; BUFFER ADDRESS FOR FILE HEADER
	.LONG	SIP_Q_STATBLK		; ADDRESS TO RETURN STATISTICS BLOCK
					;    STARTING LBN IF CONTIG, 0 IF NOT
					;    FILE SIZE IN BLOCKS
	.LONG	SIP_L_RTRVLEN		; ADR TO RETURN RTRV PTR BUF LENGTH
	.LONG	SIP_Q_RTRVBUF		; ADR OF RTRV PTR BUF DESCRIPTOR
 
SIP_L_ERRSEQ:
	.LONG	0			; SAVED ERROR SEQUENCE NUMBER
					; FROM DUMP FILE HEADER
SIP_A_FILATT:				; LIST OF FILE ATTRIBUTE AREAS
SIP_L_PAGATT:				; PAGE FILE
	.BLKL	1
SIP_L_SWPATT:				; SWAP FILE
	.BLKL	1
SIP_L_RMSATT:				; RMS
	.BLKL	1

SIP_Q_CURNTIM:				; CURRENT TIME QUAD WORD
	.BLKQ	1			;
SIP_Q_INTIME:				; INPUT TIME VALUE
	.BLKQ	1			;

SIP_A_KFIARG:				; ARGUMENT LIST FOR MAKING A KNOWN
	.LONG	7			; FILE ENTRY FOR THE SYSTEM DEVICE FCP
SIP_L_DSKCHAN:
	.BLKL	1			; CHANNEL FOR DISK HERE
	.LONG	SIP_L_KFICMDBIT		; ADDRESS OF KNOWN FILE CMD BITS
	.LONG	SIP_L_KFIFLAGS		; ADDRESS OF FLAGS WORD FOR KFI ENTRY
	.LONG	SIP_Q_PRVMSK		; ADDRESS OF PRIVILEGE MASK
	.LONG	SIP_A_ERLBUFFER		; ADDRESS OF COUNTED ASCII DIRECTORY STRING
	.LONG	SIP_T_KFIFILNAM		; ADDRESS OF COUNTED ASCII FILE NAME
	.LONG	SIP_T_KFITYPNAM		; ADDRESS OF COUNTED ASCII TYPE NAME

SIP_L_KFICMDBIT:			; KNOWN FILE ENTRY COMMAND BITS
	.LONG	0			; DEFAULT TO CREATE KFI
SIP_L_KFIFLAGS:				;
	.LONG	KFI$M_KP_OPEN ! KFI$M_KP_SHARED ! KFI$M_PROCPRIV
SIP_T_KFIDIRNAM:			; COUNTED DIRECTORY STRING 
	.ASCIC	/SYSEXE/		; NO BRACKETS, CANONICAL FORM
SIP_T_KFIFILNAM:			; COUNTED FILE NAME FOR ACP
	.ASCIC	/F11AACP/		; STRUCTURE LEVEL FIXED BY SYSIMGACT
					; "F11A" FOR LEVEL 1, "F11B" FOR LEVEL 2
SIP_T_KFITYPNAM:			; COUNTED TYPE NAME STRING
	.ASCIC	/EXE/

SIP_Q_LINBUF:
	.WORD	0,SIP_C_LINBUFSIZ	; DESCRIPTOR FOR LINE BUFFER
	.LONG	SIP_T_LINBUF
 
SIP_T_LINBUF:
	.BLKB	132
 
SIP_C_LINBUFSIZ=.-SIP_T_LINBUF
 
CREPRCERR:				; CREATE PROCESS ERROR
	.BYTE	CREERREND-.-1		; LENGTH OF STRING
	.ASCII	\create process error on \
CREPRCNAM:				;
	.BLKB	15			;
CREERREND:
SIP_Q_SPINPUT:				; STARTUP PROCESS INPUT
	.LONG	0			; COUNT FOR STRING
	.LONG	EXE$GT_STARTUP+1	; ADDRESS 

	.SBTTL	SYSTEM INITIALIZATION PROCESS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS PROCESS IS INITIATED BY THE OPERATING SYSTEM AFTER
;	IT HAS BEEN BOOT STRAPPED AND PROCESSOR INITIALIZTION
;	HAS BEEN COMPLETED. THE FOLLOWING FUNCTIONS ARE
;	PERFORMED:
;
;		1) SYSTEM LOGICAL NAMES ARE CREATED
;		2) PAGEFILE, SWAPFILE, AND RMS ARE
;		   INITIALIZED.
;		3) THE SYSTEM DISK IS MOUNTED (ACP STARTED UP)
;		4) THE SYSTEM MESSAGE FILE IS OPENED AND MAPPED
;		5) STARTUP PROCESS IS INITIATED, WHICH NOW STARTS UP
;		   JOBCTL, OPCOM, AND ERRFMT.
;
;
; CALLING SEQUENCE:
;
;	NONE-ENTERED DIRECTLY FROM THE IMAGE ACTIVATOR
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LOGICAL NAME "SYS$SYSDEVICE" IS ASSIGNED TO THE SYSTEM DISK
;	FIL$GQ_CACHE CONTAINS A DESCRIPTOR FOR THE FIL$OPENFILE CACHE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	FILE ADDRESS ARE STORED, THE SPECIFIED PROCESSES ARE CREATED
;
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	PURE_SECT

SIP_START:
	.WORD	0			; ENTRY MASK
	CALLS	#0,W^LOCKDOWN		; LOCK PAGES THAT MUST BE LOCKED
;
; CREATE SYSTEM WIDE LOGICAL NAMES
;
	MOVAL	W^SIP_A_ERLBUFFER,R8	; ADDRESS OF SCRATCH STORAGE
	MOVAL	W^SIP_A_CRELOG,R6	; ADDRESS OF ARRAY OF LOGICALS
	MOVAL	CRELOG_BUF(R8),CRELOG_BUFADR(R8) ; FORM DESCRIPTOR FOR
	MOVL	#32,CRELOG_BUFSIZ(R8)	; TRANSLATE BUFFER
	$TRNLOG_S -			; GET TRANSLATION OF THE SYSTEM DISK
		LOGNAM=W^SIP_Q_DSKNAME -
		RSLLEN=CRELOG_BUFSIZ(R8) - ; OVERWRITE MAX LENGTH OF BUF
		RSLBUF=CRELOG_BUFSIZ(R8) ; DESCRIPTOR OF BUFFER
	BLBC	R0,CRELOG_FATAL		; BRANCH IF ERROR
	ADDL3	CRELOG_BUFSIZ(R8),CRELOG_BUFADR(R8),R3 ; ADR OF 1ST BYTE BEYOND
					; DEVICE NAME TRANSLATION
	CMPB	#^A/_/,@CRELOG_BUFADR(R8) ; IF EQUVALENCE NAME BEGINS WITH "_"
	BNEQ	5$			;
	INCL	CRELOG_BUFADR(R8)	; REMOVE IT
5$:	MOVB	#^A/[/,(R3)+		; BEGIN DIRECTORY STRING
	MOVAL	FIL$GT_TOPSYS,R1	; TOP LEVEL SYSTEM DIRECTORY IF ANY
	MOVZBL	(R1)+,R0		; GET SIZE OF STRING
	BEQL	10$			; BRANCH IF NO TOP LEVEL DIRECTORY
	MOVC3	R0,(R1),(R3)		; MOVE THE TOP LEVEL DIRECTORY NAME
	MOVB	#^A/./,(R3)+		; AND THE SEPARATOR
10$:	MOVL	R3,R7			; SAVE THE ADR TO STORE DIR NAME
	MOVL	(R6)+,R1		; ADR OF ASCIC DIRECTORY NAME
	BEQL	CRELOG_DONE		; BRANCH IF DONE
	MOVZBL	(R1)+,R0		; R0 = SIZE, R1 = ADDRESS
	MOVC3	R0,(R1),(R3)		; MOVE THE NAME INTO BUFFER
	MOVB	#^A/]/,(R3)+		; CLOSE BRACKET
	SUBL3	CRELOG_BUFADR(R8),R3,CRELOG_BUFSIZ(R8) ; SIZE OF EQUIV NAME STRING
	MOVL	(R6)+,R1		; ADR OF ASCIC LOGICAL NAME
	MOVZBL	(R1)+,R0		; R0 = SIZE, R1 = ADDRESS
	MOVQ	R0,CRELOG_LOGNAM(R8)	; DESCRIPTOR FOR LOGICAL NAME
	$CRELOG_S -			; CREATE THE LOGICAL NAME
		TBLFLG=#LOG$C_SYSTEM -	; USE THE SYSTEM TABLE
		LOGNAM=CRELOG_LOGNAM(R8) - ; DESCRIPTOR FOR LOGICAL NAME
		EQLNAM=CRELOG_BUFSIZ(R8) ; DESCRIPTOR FOR EQUIVALENCE NAME
	MOVL	R7,R3			; RECOVER ADR TO STORE DIR NAME
	BLBS	R0,10$			; BRANCH IF SUCCESSFUL
;
; FAILED TO CREATE THE SYSTEM LOGICAL NAMES
;
CRELOG_FATAL:
	MOVAL	W^CRELOGERR,R1		; ERROR MESSAGE TEXT
	BSBW	SIP_FATAL		; REPORT ERROR AND QUIT

CRELOG_DONE:				; SUCCESSFULLY CREATED LOGICAL NAMES
	$CMKRNL_S W^SIP_SETTIME		; SET THE SYSTEM TIME
	BBC	#EXE$V_SYSUAFALT,EXE$GL_FLAGS,10$ ; BR IF NORMAL NAME FOR SYSUAF
	$CRELOG_S	#LOG$C_SYSTEM,SIP_Q_SYSUAF,SIP_Q_SYSUAFALT	;
					; EQUATE SYSUAF TO ALTERNATE NAME
;
; THE FILE SYSTEM AND RMS ARE NOT YET AVAILABLE, USE THE BOOTSTRAP
; FIL$OPENFILE CODE TO "OPEN" THE FILES THAT MUST BE PRESENT BEFORE
; THE FILE SYSTEM CAN BE INITIALIZED.
;
10$:	CLRQ	R6			; R6 = SIZE OF ATTRIBUTE REGION
					; R7 = ADDRESS OF ATTRIBUTE REGION
	MOVAL	W^SIP_A_FILATT,R8	; ARRAY OF FILE ATTRIBUTE POINTERS
	MOVAL	W^SIP_A_NAMES,R9	; ARRAY OF FILE NAME POINTERS
	BBC	S^#EXE$V_PAGFILDMP,EXE$GL_FLAGS,30$ ; BRANCH IF DUMP
					; IS NOT IN PAGE FILE
	CMPL	(R8)+,(R9)+		; SYSBOOT "OPENED" PAGEFILE.SYS
					; DON'T BOTHER DOING IT AGAIN
30$:	MOVL	(R9)+,R1		; ADR OF ASCIC FILE NAME STRING
	BNEQ	32$			; PROCESS IT
	BRW	50$			; BRANCH IF THIS IS THE END
32$:	MOVZBL	(R1)+,R0		; SIZE IN R0, ADR IN R1
	MOVQ	R0,W^SIP_Q_TMPDESC	; STORE FILE NAME DESCRIPTOR
	CMPL	R6,#RTRVPTRS+8		; ENOUGH ROOM IN RTRV BUFFER
					; FOR FILE ATTRIBUTES AND AT LEAST
					; ONE RETRIEVAL POINTER?
	BGEQ	36$			; BRANCH IF YES
;
; NEED TO ALLOCATE (MORE) SPACE FOR FILE ATTRIBUTES
;
34$:	ADDL3	#1,W^SIP_Q_RETADR+4,R2	; FIRST ADDRESS OF NEXT PAGE TO
					; BE EXPANDED INTO.  1 IF NO
					; RTRV PTR BUFFER ALLOCATED YET.
	$EXPREG_S -
		REGION=#0 -		; GET THE NEXT PAGE IN P0 SPACE
		PAGCNT=#1 -		; 1 PAGE
		RETADR=W^SIP_Q_RETADR	; RETURN ADDRESS RANGE
	MOVAL	512(R6),R6		; FILE ATTRIBUTES BUFFER IS NOW 
					; 1 PAGE BIGGER (ASSUMING IT WAS
					; ALLOCATED ADJACENT TO THE CURRENT BUF)
	
	CMPL	W^SIP_Q_RETADR,R2	; DID WE ALLOCATE THE ADJACENT PAGE?
	BEQL	36$			; BRANCH IF YES
	MOVL	W^SIP_Q_RETADR,R7	; SET NEW STARTING ADDRESS
	MOVZWL	#512,R6			; AND SIZE FOR FILE ATTRIBUTES BUFFER
36$:	SUBL3	#RTRVPTRS,R6,W^SIP_Q_RTRVBUF ; SET UP SIZE AND ADDRESS
	ADDL3	#RTRVPTRS,R7,W^SIP_Q_RTRVBUF+4 ; OF RTRV PTR BUFFER
	$DASSGN_S W^SIP_L_DSKCHAN	; FIL$OPENFILE ASSIGN CHANNEL EACH CALL
					; LEAVE IT ASSIGNED AFTER LAST CALL
	CALLG	W^SIP_A_OPENARG,FIL$OPENFILE ; GET RETRIEVAL POINTERS
					; FOR SPECIFIED FILE
	BLBS	R0,40$			; BRANCH IF SUCCESSFUL
	MNEGL	#1,FILELBN(R7)		; SET IMPOSSIBLE STARTING LBN
	CLRL	FILESIZE(R7)		; SET SIZE=0
	CLRL	RTRVLEN(R7)		; NO RETRIEVAL POINTERS
	MOVL	#RTRVPTRS,R0		; NO. OF BYTE USED FOR ATTRIBUTES
	BRB	44$
;
; SUCCESS RETURN FROM FIL$OPENFILE
;
40$:	MOVQ	W^SIP_Q_STATBLK,STATBLK(R7) ; STORE STATISTICS BLOCK
	MOVL	W^SIP_L_RTRVLEN,RTRVLEN(R7) ; AND RTRV PTR BYTE COUNT
	ADDL3	#RTRVPTRS,RTRVLEN(R7),R0 ; FORM BYTE COUNT USED IF ALL
					; THE RETRIEVAL POINTERS FIT IN
					; THE SPECIFIED BUFFER SPACE.
	CMPL	R0,R6			; WAS THERE ENOUGH SPACE?
	BGTR	34$			; BRANCH IF NOT, GET MORE SPACE
					; AND TRY THE FIL$OPENFILE AGAIN
;
; R0 = THE NUMBER OF BYTE USED FOR THE FILE ATTRIBUTES FOR THIS FILE
;
44$:	MOVL	#1,IMAGEVBN(R7)		; INIT IMAGE ATTRIBUTES
	MOVL	FILESIZE(R7),IMAGESIZE(R7) ; AS IF NOT AN IMAGE FILE
	MOVL	R7,(R8)+		; STORE THE POINTER TO THE
					; ATTRIBUTES FOR THIS FILE
	ADDL	R0,R7			; UPDATE BUFFER ADDRESS
	SUBL	R0,R6			; AND SIZE
	BRW	30$			; GO PROCESS THE NEXT FILE

50$:	MOVL	W^SIP_L_RMSATT,R7	; RMS FILE ATTRIBUTES
	MOVZWL	W^SIP_L_DSKCHAN,R0	; CHANNEL TO READ FROM
	MOVL	RTRVPTRS+4(R7),R1	; LBN OF FIRST BLOCK OF FILE
	MOVL	#IO$_READLBLK,R3	; FUNCTION CODE
	MOVL	IMAGESIZE(R7),R2	; ACTUAL LAST VBN IN FILE
	BSBW	SIP_IMAGE_ATT		; GET IMAGE ATTRIBUTES
	BLBC	R0,52$			; BRANCH IF ERROR
	ADDL3	#1,R1,IMAGEVBN(R7)	; SAVE STARTING VBN OF IMAGE
	SUBL3	R1,R2,IMAGESIZE(R7)	; SAVE BLOCKS OF IMAGE TO MAP
52$:
	$CMKRNL_S	W^SIP_KERNELRTN	; EXECUTE THIS AT KERNEL ACCESS MODE
	BBC	S^#EXE$V_SHRF11ACP,EXE$GL_FLAGS,60$ ; BRANCH IF NOT SHARING FCP
	MOVAL	W^SIP_A_ERLBUFFER+1,R8	; ADDRESS TO PUT KFI DIR STRING
	MOVL	R8,R3			; WORKING REGISTER FOR DESTINATION
	MOVAL	FIL$GT_TOPSYS,R1	; ADDRESS OF ASCIC TOPSYS STRING
	MOVZBL	(R1)+,R0		; SIZE IN R0, ADR IN R1
	BEQL	56$			; BRANCH IF NO TOPSYS DIRECTORY
	MOVC3	R0,(R1),(R3)		; FORM "SYSX."
	MOVB	#^A/./,(R3)+
56$:	MOVAL	W^SIP_T_KFIDIRNAM,R1	; ADDRESS OF ASCIC DIR NAME FOR ACP
	MOVZBL	(R1)+,R0		; R0 = SIZE, R1 = ADR
	MOVC3	R0,(R1),(R3)		; MOVE IT TO THE DESTINATION BUFFER
	SUBL	R8,R3			; SIZE OF STRING
	MOVB	R3,-(R8)		; FORM ASCIC DIR STRING (NO BRACKETS)
	$CMKRNL_S W^MAKE_FCP_KFI,W^SIP_A_KFIARG ; MAKE KNOWN FILE ENTRY FOR FCP
	BLBS	R0,60$			; BRANCH IF SUCCESSFUL
	MOVAB	W^INIKNOWNFIL,R1	; ADDRESS OF ERROR MESSAGE
	BSBW	SIP_SYSMSG		; ISSUE THE MESSAGE
60$:	MOVZWL	W^SIP_L_DSKCHAN,-(SP)	; GET CHANNEL ASSIGNED TO SYSTEM DISK
	CALLS	#1,MOUNT_SYSTEM		; AND MOUNT IT
	BLBS	R0,65$			; BR IF MOUNT WENT OK
	MOVAB	W^MOUERR,R1		; SET ERROR MESSAGE
	BSBW	SIP_SYSMSG		; OUTPUT SYSTEM MESSAGE
65$:
;
; NOW INTERLOCK WITH THE FCP BY ISSUING A QI/O TO IT.
;
	$QIOW_S -
		CHAN=W^SIP_L_DSKCHAN,-
		EFN=#1,-
		FUNC=#IO$_ACPCONTROL
	BBS	S^#EXE$V_INIT,EXE$GL_FLAGS,70$ ; BRANCH IF FCP IS RUNNING
	MOVAB	W^ACPINIERR,R1		; SET ERROR TEXT
	BSBW	SIP_FATAL		; PRINT ERROR AND EXIT
;
; DEALLOCATE THE FIL$OPENFILE CACHE, WE NOW HAVE THE FILE SYSTEM UP
;
70$:	$CMKRNL_S W^SIP_CACHE_DALC	; DONE WITH FIL$OPENFILE CACHE
;
; IF THERE IS A TOP LEVEL SYSTEM DIRECTORY, ASK THE FILES ACP FOR ITS
; REAL NAME SO THAT THIS NAME WILL APPEAR IN THE SYSTEM WIDE LOGICAL
; NAMES RATHER THAN "SYSX".
;
SIP_GET_TOPSYS:
	MOVAB	FIL$GT_TOPSYS,R1	; TOP LEVEL SYSTEM DIRECTORY STRING
	MOVZBL	(R1)+,R6		; SIZE OF STRING IF PRESENT
	BEQL	20$			; BRANCH IF NO TOP LEVEL DIR
	MOVAB	W^SIP_A_ERLBUFFER,R8	; FORM ADDRESSES FOR 2
	MOVAB	ATR$S_ASCNAME(R8),R7	; FILE NAME SCRATCH BUFFERS
	MOVC3	R6,(R1),(R7)		; FORM NAME OF DIRECTORY TO LOOK UP
	MOVL	#^A/.DIR/,(R3)+		; TACK ON THE FILE TYPE
	MOVW	#^A/;1/,(R3)+		; AND VERSION NUMBER
	PUSHAB	(R7)			; FORM DESCRIPTOR FOR DIR NAME
	PUSHAB	6(R6)			; SIZE OF NAME + 6 CHARS
	MOVL	SP,R0			; ADDRESS OF NAME DESCRIPTOR
	$QIOW_S -
		CHAN=W^SIP_L_DSKCHAN -	; CHANNEL
		FUNC=#IO$_ACCESS -	; FUNCTION CODE = ACCESS
		EFN=#1 -		; EVENT FLAG TO WAIT FOR
		IOSB=W^SIP_Q_STATBLK -	; I/O STATUS BLOCK
		P1=W^SIP_Q_FIBDESC -	; FILE ID BLOCK DESCRIPTOR
		P2=R0 -			; FILE NAME DESCRIPTOR TO LOOK UP
		P5=#SIP_A_ATRLIST	; ATTRIBUTE LIST ADDRESS
	ADDL	#8,SP			; CLEAN OFF NAME DESCRIPTOR
	BLBC	R0,10$			; BRANCH IF I/O DID NOT GET QUEUED
	BLBC	W^SIP_Q_STATBLK,10$	; BRANCH IF I/O FAILED
	LOCC	#^A/./,#ATR$S_ASCNAME,(R8) ; FIND THE END OF THE DIR NAME
	BEQL	10$			; BRANCH IF NO NAME RETURNED
	SUBL3	R8,R1,R6		; GET SIZE OF NAME
	MOVL	R8,R7			; AND ADDRESS
10$:	MOVQ	R6,W^SIP_Q_TMPDESC	; SET TEMPORARY DESCRIPTOR
	$CRELOG_S -
		TBLFLG=#LOG$C_SYSTEM -	; CREATE SYSTEM LOGICAL NAME
		LOGNAM=W^SIP_Q_TOPSYS -	; FOR SYS$TOPSYS
		EQLNAM=W^SIP_Q_TMPDESC
20$:
;
; NOW OPEN AND MAP THE SYSTEM WIDE MESSAGE FILE (SYS$MESSAGE:SYSMSG.EXE)
;
	$OPEN	FAB=W^MSGFILFAB		; OPEN THE FILE
	BLBC	R0,74$			; BRANCH IF ERROR
	MOVZWL	W^MSGFILFAB+FAB$L_STV,R0 ; CHANNEL TO READ FROM
	MOVL	#1,R1			; READ VIRTUAL BLOCK 1
	MOVL	#IO$_READVBLK,R3	; FUNCTION CODE
	MOVL	MSGFILXAB+XAB$L_EBK,R2	; END OF FILE BLOCK NUMBER
	TSTW	MSGFILXAB+XAB$W_FFB	; UNLESS FIRST FREE BYTE = 0
	BNEQ	72$
	DECL	R2			; IN WHICH CASE IT IS ONE TOO BIG
72$:	BSBW	SIP_IMAGE_ATT		; GET IMAGE ATTRIBUTES
	BLBC	R0,74$			; BRANCH IF ERROR
	SUBL	R1,R2			; NUMBER OF BLOCKS TO ACTUALLY MAP
	BLEQ	74$			; BRANCH IF NOTHING TO MAP
;
; MAP THE MESSAGE FILE AS A SYSTEM SECTION
;
	PUSHL	#PRT$C_UR		; PROTECTION FOR PAGES
	PUSHAL	EXE$GL_SYSMSG		; LOCATION TO STORE SYSTEM 
					; ADDRESS AT WHICH SYSMSG IS MAPPED
	PUSHL	R2			; PAGE COUNT TO MAP
	ADDL3	#1,R1,-(SP)		; STARTING VBN TO MAP
	MOVZWL	MSGFILFAB+FAB$L_STV,-(SP) ; CHANNEL ON WHICH SYSMSG IS OPEN
	PUSHL	#5			; NO. OF ARGUMENTS IN THE ARG LIST
	MOVL	SP,R0			; ADDRESS OF ARGUMENT LIST
	$CMKRNL_S W^BOO$CRMPSC,(R0)	; MAP THE SECTION
	ADDL	#<6*4>,SP		; CLEAN OFF ARGUMENT LIST
	BLBS	R0,90$			; BRANCH IF SUCCESSFUL
74$:	MOVAB	W^MSGFILERR,R1		; "FAILED TO OPEN OR MAP SYSMSG.EXE"
	BSBW	SIP_SYSMSG		; ISSUE A WARNING DIAGNOSTICE
90$:					;
	MOVZBL	EXE$GT_STARTUP,W^SIP_Q_SPINPUT	; SET CORRECT COUNT IN DESCR
	MOVAB	W^SIP_Q_SPOUTPUT,R0	; STARTUP PROCESS OUTPUT
	CMPL	#XDT$START,#0		; DEBUGGING WITH DELTA?
	BEQL	95$			; BRANCH IF NOT
	MOVAB	W^SIP_Q_SPOUTXDT,R0	; USE DIFFERENT OUTPUT FOR DELTA
95$:	$CREPRC_S	INPUT=W^SIP_Q_SPINPUT,-	; INPUT FROM STARTUP FILE
			OUTPUT=(R0),-	; OUTPUT TO CONSOLE TERMINAL
			ERROR=(R0),-	; ERRORS ALSO
			BASPRI=#4,-	; BASE PRIORITY
			IMAGE=W^SIP_Q_SPIMAGE,-	; RUN LOGIN IMAGE
			UIC=#^X80020,-		; RUN IN UIC [10,40]
			STSFLG=#<1@6>,-		; FLAG FOR AUTO LOGIN
			PRVADR=W^SIP_Q_PRVMSK,-	; ALL PRIVILEGES
			QUOTA=PQL$AB_SYSPQL,-	; QUOTA LIST
			PRCNAM=W^SIP_Q_STARTUP	; NAME IS STARTUP
	BLBS	R0,100$			; BR IF SUCCESS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAQ	W^SIP_Q_STARTUP,R0	; GET PROCESS NAME DESCRIPTOR
	MOVC5	(R0),@4(R0),#0,#15,W^CREPRCNAM ; COPY NAME INTO MESSAGE
	MOVAB	W^CREPRCERR,R1		; SET ADDR OF MESSAGE
	MOVL	(SP),R0			; SET FAILURE STATUS VALUE
	BSBW	SIP_SYSMSG		; PRINT THE MESSAGE
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	$GETMSG_S R0,SIP_Q_TMPDESC,SIP_Q_LINBUF ; GET STATUS MESSAGE
	MOVZWL	SIP_Q_TMPDESC,R0	; GET SIZE OF MESSAGE
	MOVAB	SIP_T_LINBUF,R1		; GET ADDR OF MESSAGE
	BSBW	SIP_TYPOUT		; TYPE IT ON CONSOLE
100$:
	RET				; THATS ALL FOR NOW

	.SBTTL	SIP_IMAGE_ATT - Read header, get image attributes
;++
; FUNCTIONAL DESCRIPTION:
;
;	READ THE IMAGE HEADER OF AN IMAGE AND RETURN THE COUNT OF
;	IMAGE HEADER BLOCKS AND THE HIGHEST VBN THAT IS PART OF THE
;	IMAGE, I.E. EXCLUDING SYMBOL TABLE AND PATCH STUFF.
;
; INPUT PARAMETERS:
;
;	R0 = CHANNEL TO READ FROM
;	R1 = DISK ADDRESS TO READ (LBN OR VBN)
;	R2 = LAST VBN IN FILE
;	R3 = FUNCTION CODE (READ LOGICAL OR READ VIRTUAL)
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R1 = HEADER BLOCK COUNT
;	R2 = LAST VIRTUAL BLOCK NUMBER IN IMAGE
;	     EXCLUDING DEBUG SYMBOL TABLE AND PATCH AUDIT TRAIL TEXT.
;	R3 = IMAGE HEADER ADDRESS
;
;--

SIP_IMAGE_ATT:
	$QIOW_S	-			; READ THE IMAGE HEADER
		EFN  = #1 -		; EVENT FLAG
		CHAN = R0 -		; CHANNEL TO READ ON
		FUNC = R3 -		; READ VIRTUAL OR LOGICAL
		IOSB = W^SIP_Q_STATBLK - ; I/O STATUS BLOCK ADDRESS
		P1   = W^SIP_A_ERLBUFFER - ; BUFFER TO READ INTO
		P2   = #512 -		; NUMBER OF BYTES TO READ
		P3   = R1		; DISK BLOCK TO READ
	BLBC	R0,100$			; BRANCH IF ERROR
	MOVZWL	W^SIP_Q_STATBLK,R0	; GET I/O STATUS
	BLBC	R0,100$			; BRANCH IF ERROR
	MOVAL	W^SIP_A_ERLBUFFER,R3	; HEADER BUFFER ADDRESS
	BSBW	BOO$IMAGE_ATT		; GET IMAGE ATTRIBUTES
	MOVL	S^#SS$_NORMAL,R0
100$:	RSB
	.PAGE
	.SBTTL	BOO$IMAGE_ATT - Get image attributes from image header
;++
; Functional Description:
;
;	BOO$IMAGE_ATT returns to the caller some attributes of the image
;
; Calling Sequence:
;
;	BSBW	BOO$IMAGE_ATT
;
; Inputs:
;
;	R2 = Size of file in blocks
;	R3 = Address of image header block (first one only)
;
; Outputs:
;
;	R1 = Number of image header blocks at the front of the image
;	R2 = Size of image in blocks excluding the blocks at the end
;	     containing local symbols, global symbols, or patch text
;
;--

BOO$IMAGE_ATT::
	MOVZWL	IHD$W_SYMDBGOFF(R3),R0	; ANY SYMBOL TABLE INFORMATION?
	BEQL	20$			; BRANCH IF NOT
	MOVAB	IHS$L_DSTVBN(R0)[R3],R1	; ADR OF 1ST VBN IN DEBUG SYMBOL TABLE
	BSBB	40$			; PROCESS IT
	MOVAB	IHS$L_GSTVBN(R0)[R3],R1	; ADR OF 1ST VBN IN GLOBAL SYMBOL TABLE
	BSBB	40$			; PROCESS IT
20$:	MOVZWL	IHD$W_PATCHOFF(R3),R0	; ANY PATCH CONTROL INFORMATION?
	BEQL	30$			; BRANCH IF NOT
	MOVAB	IHP$L_PATCOMTXT(R0)[R3],R1 ; ADR OF 1ST VBN OF PATCH COMMAND TEXT
	BSBB	40$			; PROCESS IT
30$:	MOVZBL	IHD$B_HDRBLKCNT(R3),R1	; GET IMAGE HEADER BLOCK COUNT
	RSB
;
; SEE IF VBN IS NON ZERO AND THEN IF IT IS SMALLER THAN THE CURRENT SMALLEST
;
40$:	SUBL3	#1,(R1),R1		; FETCH VBN - 1
	BLSS	50$			; BRANCH IF NO VBN IS PRESENT
	CMPL	R2,R1			; IS IT SMALLER THAN THE CURRENT ONE
	BLEQ	50$			; BRANCH IF NOT
	MOVL	R1,R2			; YES, USE IT
50$:	RSB
	.PAGE
	.SBTTL	SYSTEM INITIALIZATION KERNEL LEVEL
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PERFORM SYSTEM INITIALIZATION
;	FUNCTIONS WHICH REQUIRE KERNEL LEVEL ACCESS.
;	THE FOLLOWING ARE PERFORMED:
;
;		1) SET UP THE KNOWN FILE DATA BASE
;		2) INIT THE PAGING FILE
;		3) INIT THE SWAP FILE
;		4) MAP RMS INTO SYSTEM SPACE
;		6) RECOVER UNLOGGED ERROR LOG ENTRIES FROM CRASH DUMP
;		   AND MAKE SURE THEY ARE PROPERLY LOGGED.
;
; CALLING SEQUENCE:
;
;	ENTER VIA THE CHANGE MODE TO SYSTEM SERVICE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LOCATION "SIP_A_FILATT" CONTAINS A LIST OF ADDRESSES OF
;	FILE ATTRIBUTES BUFFERS FOR:
;		1) PAGE FILE
;		2) SWAP FILE
;		3) RMS
;
;	THE FORMAT OF THE ATTRIBUTES BUFFERS IS:
;		.LONG	STARTING LBN IF CONTIGUOUS, 0 IF NOT, -1 IF NO SUCH FILE
;		.LONG	SIZE OF FILE IN 512 BYTE BLOCKS
;		.LONG	FIRST VBN IF IMAGE FORMAT
;		.LONG	SIZE IF IMAGE FORMAT
;		.LONG	BYTE COUNT OF RETRIEVAL POINTERS THAT FOLLOW
;		.LONG	BLOCK COUNT FOR RTRV PTR 1
;		.LONG	LBN FOR RTRV PTR 1
;		...
;		...
;		...
;		.LONG	BLOCK COUNT FOR RTRV PTR N
;		.LONG	LBN FOR RTRV PTR N
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 IS RETURNED TRUE OF FALSE DEPENDING ON
;	INITIALIZATION SUCESS OR FAILURE
;
; SIDE EFFECTS:
;
SIP_KERNELRTN:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; ENTRY MASK
	MOVL	@#MMG$GL_GPTE,R3	; GET BASE ADDRESS OF GPTE
	ASHL	#2,@#SGN$GL_MAXGPGCT,4(R3); SET THE GLOBAL PAGE TABLE ENTRY 
					; MAX CNT
	MOVL	EXE$GL_SYSUCB,R0	; PICK UP ADDRESS OF SYSTEM UCB
	BICL	#<DEV$M_FOR!DEV$M_MNT>,-; CLEAR FOREIGN AND MOUNTED FORM INIT IN
		UCB$L_DEVCHAR(R0)	; SYSTEM DISK UCB CHARACTERISTICS WORD
	MOVL	SCH$GL_CURPCB,R1	; GET CURRENT PROCESS PCB ADDRESS
	MOVL	PCB$L_PID(R1),UCB$L_PID(R0) ; ALLOCATE SYSTEM DEVICE
;
; INIT KNOWN FILE POINTER BLOCK
;
SIP_INIKNOWNFIL:
	MOVZBL	G^SGN$GB_KFILSTCT,R1	; DESIRED NUMBER OF KNOWN FILE LISTS
	MULL	#4,R1			; NUMBER OF BYTE REQUIRED
	ADDL	#KFP$L_QUE0,R1		; PLUS OVERHEAD BYTES
	PUSHL	R1			; SAVE REQUESTED SIZE
	BSBW	SIP_ALONONPAGED		; ALLOCATE THE POINTER BLOCK
	BLBS	R0,20$			; BRANCH IF SUCCESSFUL
	MOVAB	W^INIKNOWNFIL,R1	; ADDRESS OF ERROR MESSAGE
	BSBW	SIP_FATAL		; ISSUE FATAL ERROR
20$:	MOVL	(SP)+,KFP$W_SIZE(R2)	; SIZE IS THE REQUESTED SIZE
	MOVW	#<DYN$C_KFI@8 + DYN$C_PTR>,KFP$B_TYPE(R2) ; SET STRUCTURE TYPES
	MOVAB	KFP$L_QUE0(R2),G^EXE$GL_KNOWNFIL ; SET ADDRESS OF VECTOR
					; OF KNOWN FILE LISTS

	.PAGE	
	.SUBTITLE	SIP_INITPAGFIL		Initialize PAGEFILE.SYS
;
;  Now initialize PAGEFILE.SYS if it exists
;

;
; The following register conventions are used in INITPAGFIL
;
;	R5 = Address of the first block of the dump header
;	R6 = Address of the Boot Control Block
;	R7 = Number of blocks of page file to permanently reserve for
;	     a dump file header.  0 if dump file is not in the page file
;	     4 if the dump file is in the page file.
;	R8 = Number of blocks of page file to initially mark "in use"
;	     because the dump is in the page file and is supposed to
;	     be analyzed before the pages are released to the page file.
;	R9 = Contents of SIP_L_PAGATT, 0 if page file contains the dump.
;	     The page file attributes block address if not.
;
SIP_INITPAGFIL:
;
; Since the dump file may be at the front of the page file,
; we will read the 3 header blocks of the dump file and
; process some information now.  Later the "restore error log"
; code will not have to read or update the dump.  It will only
; have to process and save the error log entries if any.
;
	CLRQ	R7			; Init for separate dump and page files
	MOVL	W^SIP_L_PAGATT,R9	; Page file attribute block address
	BNEQ	5$			; Branch if separate page and dump files
	MOVL	#4,R7			; Dump is in page file
					; never page to first 4 blocks
5$:	MOVL	EXE$GL_BOOTCB,R6	; Address of Boot Control Block
	MOVAB	W^SIP_A_ERLBUFFER,R5	; Buffer to read into
	PUSHL	W^SIP_L_DSKCHAN		; Channel to read disk
	PUSHL	#IO$_READLBLK		; Read function
	ROTL	#9,#3,-(SP)		; Assume reading 3 pages
	CMPL	BOO$L_DMP_SIZE(R6),#3	; Is dump file at least that big?
	BGEQ	10$			; Branch if yes
	CLRL	(SP)			; No blocks to be read
10$:	PUSHAB	(R5)			;
	PUSHL	BOO$L_DMP_MAP(R6)	; Virtual to logical map for dump file
	PUSHL	BOO$L_DMP_VBN(R6)	; Starting VBN of dump file
	PUSHL	#6			; 6 arguments to RWVB
;
; At this point there is an argument list at the top of the stack 
; for the call to QIO_RWVB.  This argument list is kept until
; exiting this "paragraph" when a write of the first block of the
; dump header may be needed.
;
	CLRL	W^SIP_L_ERRSEQ		; Zero saved sequence number
	TSTL	16(SP)			; Any blocks to read?
	BEQL	60$			; Branch if not
	CALLG	(SP),W^QIO_RWVB		; Issue QIO Read Virtual Block
	CLRL	16(SP)			; Init for no write of page
	BLBC	R0,60$			; Skip if error reading file
	CMPW	DMP$W_DUMPVER(R5),#SIP_C_DUMPVER ; Must be known dump version
	BNEQ	60$			; Branch if earlier system or garbage
	MCOML	DMP$L_SYSVER(R5),R0	; Get complement of system version
	CMPL	R0,DMP$L_CHECK(R5)	; Does check match?
	BNEQ	60$			; Branch if earlier system or garbage
;
; The dump file header looks OK, indicate that we can save error log
; entries if any are present.
;
	MOVL	DMP$L_ERRSEQ(R5),W^SIP_L_ERRSEQ ; Save sequence number
	BEQL	20$			; Branch if already zero on disk
	CLRL	DMP$L_ERRSEQ(R5)	; Save these ERL entries only once
	ROTL	#9,#1,16(SP)		; Indicate that block is to be written
;
; See if the dump is in the page file and if it should be preserved
;
20$:	TSTL	R9			; Separate dump and page files?
	BNEQ	65$			; Branch if yes
	BBC	S^#EXE$V_SAVEDUMP,EXE$GL_FLAGS,50$ ; Branch if not
					; supposed to preserve the dump
	BBS	#DMP$V_OLDDUMP,DMP$W_FLAGS(R5),50$ ; Don't preserve dump
					; if already analyzed once.
	BICL3	#7,DMP$L_CRASHERL+EMB$K_LENGTH+EMB$L_CR_CODE(R5),R0
					; Fetch crash code, zero severity
	CMPL	R0,#BUG$_OPERATOR	; "Operator Requested Shutdown?"
	BEQL	50$			; Branch if yes, don't preserve
;
; Loop through the memory descriptors and calculate the number of pages
; of dump to preserve.
;
	ASSUME	DMP$C_NMEMDSC EQ RPB$C_NMEMDSC
	MOVZBL	#DMP$C_NMEMDSC,R1	; Max # of memory descriptors
	MOVAB	DMP$L_MEMDSC(R5),R2	; Get adr of memory descriptors
30$:	EXTZV	#DMP$V_PAGCNT,#DMP$S_PAGCNT,(R2),R0 ; Get page cnt for this mem
	BEQL	40$			; BR if no more memory descriptors used
	ADDL2	R0,R8			; Accumulate total # of pages
	ASSUME	DMP$C_MEMDSCSIZ EQ RPB$C_MEMDSCSIZ
	ADDL2	#DMP$C_MEMDSCSIZ,R2	; Get next memory descriptor
	SOBGTR	R1,30$			; Loop once for each memory descriptor
40$:	TSTL	R8			; Any dump blocks to preserve?
	BGTR	60$			; Branch if yes
50$:	ROTL	#9,#1,16(SP)		; Note that we must write the block
	BBSS	#DMP$V_EMPTY,DMP$W_FLAGS(R5),60$ ; Mark dump empty for SDA
					; so it will not try to analyze
					; a (partially) overwritten dump
60$:	TSTL	R9			; Address of page file attributes buffer
	BNEQ	65$			; Branch if SYSINIT looked up page file
;
; Dump file is in page file.  SYSBOOT "opened" PAGEFILE.SYS and called
; it the dump file.  So the retrieval information and the file size
; are in the boot control block fields for the dump file.
;
	MOVL	BOO$L_DMP_MAP(R6),R2	; Address of page file mapping data
	MOVL	BOO$L_DMP_SIZE(R6),R4	; Size of page file
	BRB	70$			;
65$:	MOVAL	RTRVLEN(R9),R2		; Address of page file mapping data
	MOVL	FILESIZE(R9),R4		; Size of page file
70$:	BICL3	#7,R4,R0		; A zero length file is also useless
	SUBL	R8,R0			; Enough room left in page file
	CMPL	R0,#SIP_C_MINPAGFIL	; after reserving the dump portion
	BGEQ	80$			; Branch if yes
	TSTL	R8			; No, then don't preserve the dump
	BEQL	100$			; Branch if too small anyway
	CLRL	R8			; No dump data preserved
	BRB	50$
80$:	BSBW	SIP_INIWCB		; Allocate and init a window control block
;
; Set up argument list to BOO$INITPAGFIL on the stack. Ignore returned
; page file index. Default MAXVBN parameter. Use WCB address returned
; by SIP_INIWCB.
;
90$:	MOVQ	R7,-(SP)		; Count of blocks to mark "in use"
					; Starting VBN - 1 for page file
	CLRQ	-(SP)			; Default these two parameters
	PUSHL	R2			; Store WCB address
	PUSHL	R4			;  ... and file size
	CALLS	#6,G^BOO$INITPAGFIL	; Allocate and initialize a PFL
	BLBS	R0,120$			; Go on to next step if successful
	BSBB	CHECK_CACHE		; Can FIL$OPENFILE cache be deallocated?
	BLBS	R0,90$			; If so, try again
	MOVAB	W^INIPAGFIL,R1		; Otherwise, report an error message
	BSBW	SIP_FATAL		;  and abort the startup sequence
;
; Page file does not exist, or is too small to be useful
;
100$:	MOVAB	PAGFILERR,R1		; Display paging file error message
	BSBW	SIP_SYSMSG		; 
;
; All exits from the init page file logic must flow through here in
; order to conditionally write the first dump header block back
; and unconditionally clean the argument list off the stack.
;
120$:	MOVL	R8,EXE$GL_SAVEDUMP	; Note count of blocks reserved
	TSTL	16(SP)			; Write the dump file header?
	BEQL	140$			; Branch if not
	MOVL	#IO$_WRITELBLK,20(SP)	; Change read to write
	CALLG	(SP),W^QIO_RWVB		; Write the block
140$:	ADDL	#7*4,SP			; Clean argument list off stack
	BRB	SIP_INITSWPFIL

	.PAGE	
	.SUBTITLE	CHECK_CACHE

;+
; This routine checks whether there is a FIL$OPENFILE cache to be deallocated.
; The reason why this routine is necessary here is that the BOO$INITxxxFIL
; procedures cannot use the local nonpaged pool allocation routine. Those
; procedures are shared with SYSGEN and cannot know about such specialized
; items as this cache in nonpaged pool.
;
; If the cache is still allocated, it is deallocated and a success status
; is returned.
;
; Input Parameter:
;
;	R0 low bit clear
;
; Status Code:
;
;	R0 low bit set    => FILEREAD cache successfully deallocated
;
;	R0 low bit clear  => FILEREAD cache was already  deallocated
;			     (previous error stands)
;-

CHECK_CACHE:
	TSTL	G^FIL$GQ_CACHE		; Cache still allocated?
	BEQL	10$			; Branch if not -- original error stands
	CALLS	#0,SIP_CACHE_DALC	; Otherwise, deallocate the cache
10$:	RSB				;  and return to caller


	.PAGE	
	.SUBTITLE	SIP_INITSWPFIL		Initialize SWAPFILE.SYS
;
;  Now initialize SWAPFILE.SYS if it exists
;

SIP_INITSWPFIL:
	TSTW	G^SGN$GW_SWPFILES	; If requested number of swap files is
	BEQL	SIP_INITRMS		;  zero, then skip this entire section
	MOVL	W^SIP_L_SWPATT,R4	; Address of swap file attributes buffer
	BICL3	#7,FILESIZE(R4),R0	; If file is empty or does not exist
	BEQL	SIP_INITRMS		;  then skip to the next step
	MOVZWL	G^SWP$GW_SWPINC,-(SP)	; Get value of SWPALLOCINC parameter
	CMPL	R0,(SP)+		; File size must be at least as large
	BLSSU	SIP_INITRMS		; ... so skip to next step if too small
	MOVAB	RTRVLEN(R4),R2		; Address of mapping data
	BSBW	SIP_INIWCB		; Allocate and init a window control block
;
; Set up argument list to BOO$INITSWPFIL on the stack. Ignore returned
; page file index. Default MAXVBN parameter. Use WCB address returned
; by SIP_INIWCB.
;
10$:	CLRQ	-(SP)			; Default last two parameters
	PUSHL	R2			; Store WCB address
	PUSHL	FILESIZE(R4)		;  ... and file size
	CALLS	#4,G^BOO$INITSWPFIL	; Allocate and initialize a PFL
	BLBS	R0,SIP_INITRMS		; Go on to next step if successful
	BSBB	CHECK_CACHE		; Can FIL$OPENFILE cache be deallocated?
	BLBS	R0,10$			; If so, try again
	MOVAB	W^INIPAGFIL,R1		; Otherwise, report an error message
	BSBW	SIP_FATAL		;  and abort the startup sequence

	.PAGE
	.SBTTL	SIP_INITRMS - Install RMS Image
;
;	INSTALL RMS IMAGE AS A PAGEABLE SYSTEM SECTION
;

SIP_INITRMS:
	MOVL	W^SIP_L_RMSATT,R4	; ADDRESS OF RMS FILE ATTRIBUTES BUF
	MOVL	IMAGESIZE(R4),R6	; ANY PAGES TO MAP?
	BLEQ	10$			; BRANCH IF NOT, ERROR
	BBC	S^#EXE$V_SYSPAGING,EXE$GL_FLAGS,30$ ; BRANCH IF NOT
					; PAGING SYSTEM SPACE
	MOVAB	RTRVLEN(R4),R2		; ADDRESS OF MAPPING DATA
	BSBW	SIP_INIWCB		; MAKE A WINDOW CONTROL BLOCK
	PUSHL	S^#PRT$C_UR		; PROTECTION FOR RMS PAGES
	PUSHAL	MMG$GL_RMSBASE		; ADDRESS TO STORE BASE OF SECTION
	PUSHL	R6			; NUMBER OF PAGES TO MAP
	PUSHL	IMAGEVBN(R4)		; STARTING VBN TO MAP
	PUSHL	R2			; WINDOW CONTROL BLOCK ADDRESS
	CALLS	#5,W^BOO$CRMPSC		; CREATE AND MAP SYSTEM SECTION
	BLBS	R0,60$			; BRANCH IF SUCCESSFUL
10$:	MOVAB	W^RMSMAPERR,R1		; FAILED TO MAP RMS
	BSBW	SIP_FATAL		; ISSUE FATAL DIAGNOSTIC
;
; IF SYSPAGING = 0 (NOT PAGING THE PAGED PORTION OF THE SYSTEM CODE),
; THEN CREATE SOME (WRITABLE) ADDRESS SPACE FOR RMS AND READ IT IN.
; RMS WILL STILL PAGE IN THE SYSTEM WORKING SET WHICH MEANS THAT THE
; SYSTEM WORKING SET MUST BE LARGE IF THE PAGES ARE TO STAY IN MEMORY.
;
30$:	ADDL3	R6,BOO$GL_SPTFREL,R1	; ALLOCATE SPT FOR RMS PAGES
	CMPL	R1,BOO$GL_SPTFREH	; ENOUGH LEFT?
	BGTR	10$			; BRANCH IF NOT
	MOVL	R1,BOO$GL_SPTFREL	; RECORD THE ALLOCATION
	SUBL	R6,R1			; FIRST SPT INDEX
	ASHL	#9,R1,R2		; FORM SYSTEM VA OF RMS
	BBSS	#VA$V_SYSTEM,R2,35$	; OR IN THE SYSTEM BIT
35$:
;
; SET UP THE ARGUMENT LIST FOR THE READ VIRTUAL CALL
;
	PUSHL	W^SIP_L_DSKCHAN		; CHANNEL FOR THE I/O REQUEST
	PUSHL	#IO$_READLBLK		; FUNCTION CODE
	ASHL	#9,R6,-(SP)		; BYTE COUNT TO READ (MAY BE > 65KB)
	PUSHL	R2			; VA TO READ INTO
	PUSHAL	RTRVLEN(R4)		; VIRTUAL TO LOGICAL MAP
	PUSHL	IMAGEVBN(R4)		; STARTING VBN IN IMAGE
;
; NOW FILL IN THE SPT WITH DEMAND ZERO ENTRIES
;
	MOVAL	@MMG$GL_SPTBASE[R1],R1	; ADDRESS OF FIRST SPT ENTRY
40$:	ASHL	#PTE$V_PROT,S^#PRT$C_URKW,(R1)+ ; STORE THE NEXT PTE
	SOBGTR	R6,40$			; LOOP THROUGH ALL PAGES
	CALLS	#6,W^QIO_RWVB		; READ RMS
	BLBC	R0,10$			; BRANCH IF ERROR
	MOVL	R2,MMG$GL_RMSBASE	; SET RMS BASE ADDRESS
60$:	MOVL	MMG$GL_RMSBASE,CTL$GL_RMSBASE ; SET RMS BASE FOR THIS PROCESS
	MOVL	EXE$GL_SYSUCB,R1	; GET SYSTEM DEVICE UCB ADDRESS
	CLRL	UCB$L_PID(R1)		; DEALLOCATE SYSTEM DEVICE
	.PAGE
	.SBTTL	RESTORE ERROR LOG BUFFERS
;
;	THE FOLLOWING LOOKS AT THE FIRST 3 PAGES OF THE DUMP FILE.  IF THERE
;	IS INFORMATION IN THE FILE, IT THEN LOOKS FOR ERROR LOG ENTRIES THAT
;	REMAINED IN THE BUFFERS AT THE TIME OF THE CRASH.  THESE ARE REMOVED
;	AND PLACED IN THE CURRENT ERROR LOG BUFFERS.  THE ERROR LOG ENTRY
;	FOR THE BUG_CHECK WILL BE CONTAINED IN THE ERROR LOG BUFFER PAGES
;	IN THE DUMP (PAGES 2 AND 3), IF THE DUMP WAS FOR A SYSTEM PRIOR TO
;	RELEASE 2.0.  RELEASE 2.0 AND SUBSEQUENT RELEASES PLACE BUG_CHECK
;	ERROR LOG IN THE FIRST PAGE OF THE DUMP FILE.  THIS WAS DONE BECAUSE
;	THE ERROR LOG BUFFERS COULD BE FULL AND THE BUG_CHECK INFORMATION LOST.
;
RESTORERL:				; RESTORE ERROR LOG INFORMATION
	MOVAB	W^SIP_A_ERLBUFFER,R4	; BUFFER TO READ INTO
	TSTL	W^SIP_L_ERRSEQ		; TEST SAVED SEQUENCE NUMBER
	BNEQ	10$			; BRANCH IF ERROR LOG ENTRIES TO SAVE
	BRW	NOERL			; NO ERROR LOG ENTRIES
10$:	MOVL	#2,R5			; SET NUMBER OF ERROR LOG BUFFERS
20$:	MOVAB	512(R4),R4		; POINT TO NEXT BUFFER
	MOVZBL	ERL$B_MSGCNT(R4),R11	; GET COUNT OF COMPLETED MSGS IN BUFFER
	BEQL	80$			; NO, TRY NEXT BUFFER
	MOVZBL	ERL$B_BUSY(R4),R7	; GET COUNT OF INCOMPLETE MSGS IN BUFFER
	ADDL	R7,R11			; GET TOTAL # OF MESSAGES TO SCAN
	MOVZWL	#<512-ERL$C_LENGTH>,R7	; SET BYTES IN BUFFER
	SUBL3	ERL$L_NEXT(R4),ERL$L_END(R4),R6 ; EMPTY BUFFER SIZE
	CMPL	R6,R7			; CHECK FOR REASONABLE POINTERS
	BGTRU	80$			; NO, TRY NEXT BUFFER
	SUBL	R6,R7			; COMPUTE ALLOCATED SPACE IN BUFFER
	MOVZBL	#ERL$C_LENGTH,R10	; SET INITIAL OFFSET IN ERL BUFFER
30$:	MOVAB	(R4)[R10],R8		; COMPUTE MESSAGE BASE ADDRESS
	ADDL	#EMB$K_LENGTH,R8	; POINT PAST MESSAGE HEADER
	MOVZWL	EMB$W_SIZE(R8),R9	; GET MESSAGE SIZE
	BEQL	80$			; NULL - ERROR
	SUBL	R9,R7			; CHECK FOR FIT IN ALLOCATED BUFFER
	BLSS	80$			; NO SKIP REST OF BUFFER
	TSTB	EMB$B_VALID(R8)		; IS THIS A VALID MESSAGE?
	BEQL	40$			; BRANCH IF NOT
	CMPB	EMB$B_BUFIND(R8),#1	; FURTHER CHECK MESSAGE VALIDITY
	BGTRU	80$			; BR IF NOT TO SKIP BUFFER
	SUBL	#EMB$K_LENGTH,R9	; SIZE OF BUFFER TO ALLOCATE
	MOVL	R9,R1			; SIZE OF BUFFER TO ALLOCATE
	JSB	ERL$ALLOCEMB		; ALLOCATE BUFFER FOR MESSAGE
	BLBC	R0,40$			; SKIP IF NO SPACE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	R9,(R8),(R2)		; COPY MESSAGE ENTIRELY
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	JSB	ERL$RELEASEMB		; MARK MESSAGE COMPLETE
	ADDL	#EMB$K_LENGTH,R9	; SIZE OF MESSAGE BUFFER W/HEADER
40$:	ADDL	R9,R10			; POINT TO NEXT MESSAGE
50$:	SOBGTR	R11,30$			; GET NEXT MESSAGE IF ANY
80$:	SOBGTR	R5,20$			; NEXT BUFFER
	MOVAB	W^SIP_A_ERLBUFFER,R4	; GET ADDRESS OF FIRST PAGE FROM DUMP
	MOVAB	DMP$L_CRASHERL+EMB$K_LENGTH(R4),R4 ; GET ADR OF CRASH ERL ENTRY
	MOVZWL	EMB$W_SIZE(R4),R9	; GET SIZE OF ERL ENTRY
	SUBL	#EMB$K_LENGTH,R9	; SET SIZE OF BUFFER TO ALLOCATE
	MOVL	R9,R1			; REMEMBER SIZE
	JSB	ERL$ALLOCEMB		; ALLOCATE SPACE IN ERROR LOG BUFFER
	BLBC	R0,90$			; BR ON ERROR, NO SPACE AVAILABLE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	R9,(R4),(R2)		; COPY ERL ENTRY INTO ERROR LOG BUFFER
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	JSB	ERL$RELEASEMB		; MARK MESSAGE COMPLETE
90$:	MOVL	W^SIP_L_ERRSEQ,ERL$GL_SEQUENCE	; RESTORE CURRENT SEQUENCE MESSAGE
NOERL:					; 
	JSB	ERL$COLDSTART		; LOG STARTUP
;
; INITIALIZATION KERNEL ROUTINE COMPLETE
;
	MOVZWL	#1,R0			; GIVE SUCCESS
	RET
	.PAGE
	.SBTTL	QIO_RWVB - Read or Write Virtual Block
;++
; Functional Description:
;	This routine maps the specified virtual blocks to logical blocks
;	and reads or writes the desired number of bytes to or from the
;	specified location in memory.
;
; Calling sequence:
;	CALLG	arglist,QIO_RWVB
;
; Inputs:
;	QIO_RWVB_VBN(AP)    = Virtual Block Number
;	QIO_RWVB_MAP(AP)    = Mapping info for virtual to logical mapping:
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;	QIO_RWVB_BUF(AP)    = Buffer Address to read into
;	QIO_RWVB_BYTCNT(AP) = Byte count to read (up to 31 bits)
;	QIO_RWVB_FUNC(AP)   = #IO$_READLBLK or #IO$_WRITELBLK
;	QIO_RWVB_CHAN(AP)   = Channel assigned to disk
;
; Outputs:
;	R0 = Status
;	R1 altered
;	All other registers preserved
;
;--

	$OFFSET	4,POSITIVE,<-
	QIO_RWVB_VBN,-
	QIO_RWVB_MAP,-
	QIO_RWVB_BUF,-
	QIO_RWVB_BYTCNT,-
	QIO_RWVB_FUNC,-
	QIO_RWVB_CHAN -
	>

QIO_RWVB:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	ASSUME	QIO_RWVB_MAP EQ QIO_RWVB_VBN+4
	MOVQ	QIO_RWVB_VBN(AP),R3	; R3 = VBN, R4 = Map
	MOVL	QIO_RWVB_BUF(AP),R6	; R6 = Buffer address

	ASSUME	QIO_RWVB_FUNC EQ QIO_RWVB_BYTCNT+4
	MOVQ	QIO_RWVB_BYTCNT(AP),R9	; R9 = byte count, R10 = function
	MOVL	QIO_RWVB_CHAN(AP),R11	; R11 = RPB adr or channel
	ASHL	#-3,(R4)+,R5		; R5 = # of rtrv ptr quad words
					; R4 = adr of 1st rtrv ptr
10$:	MOVQ	(R4)+,R0		; R0 = # of LBN's in this rtrv ptr
					; R1 = Starting LBN in this rtrv ptr
	SUBL	R0,R3			; Is desired VBN covered 
					; by this retrieval pointer?
	BLSS	20$			; Branch if yes
	SOBGTR	R5,10$			; No, get the next rtrv ptr
	BRB	60$			; Desired VBN beyond EOF
20$:	MOVAB	-(R3)[R0],R3		; R3 = R3 + R0 - 1
					; Number of blocks from the
					; beginning of this rtrv ptr
	ADDL	R3,R1			; Adjust starting LBN
	SUBL	R3,R0			; and LBN count
	BRB	40$
30$:	MOVQ	(R4)+,R0		; Get the next rtrv ptr
;
; R0 = number of blocks that can be read in this portion
; R1 = starting LBN to read from
;
40$:	PUSHL	R9			; Save desired byte count
	ASHL	#9,R0,R0		; # of bytes that can be read
	CMPL	R9,R0			; If fewer are needed
	BLEQ	50$			; Then read the smaller number
	MOVL	R0,R9			; Otherwise read all we can
50$:	SUBL	R9,(SP)			; Note how much is left to be read
	MOVL	R1,R8			; Starting LBN of read request
	BSBB	QIO_RWLB		; Read or write the file
	MOVL	(SP)+,R9		; Recover byte left to be read
	BLEQ	90$			; Branch if all done
	BLBC	R0,90$			; Branch if read error
	SOBGTR	R5,30$			; Get the next retrieval pointer
60$:	MOVZWL	#SS$_ENDOFFILE,R0	; Indicate EOF error
90$:	RET
	.PAGE
	.SBTTL	QIO_RWLB - Read or Write Logical Block
;++
; Functional Description:
;	This routine reads/writes the specified logical block numbers
;	from/to the boot disk.
;
; Calling Sequence:
;	BSBW	QIO_RWLB
;
; Inputs:
;	R6  = Buffer address (updated)
;	R8  = Logical block number (updated)
;	R9  = Byte count to transfer (up to 31 bits)
;	R10 = #IO$_READLBLK or #IO$_WRITELBLK
;	R11 = Channel assigned to disk
; Outputs:
;	R0 = Status
;	R1,R6-R9 altered
;	All other registers preserved
;--
	IOSIZE=127
QIO_RWLB:
	SUBL	#8,SP			; Reserve an IOSB
10$:	MOVZWL	#IOSIZE*512,R7		; Assume maximum transfer
	CMPL	R7,R9			; Minimize with file size
	BLEQ	20$			; Smaller than remaining file size
	MOVL	R9,R7			; Set to remaining file size
20$:	MOVL	SP,R0			; Address of IOSB
	$QIOW_S -
		EFN = #0 -		; Event flag
		CHAN = R11 -		; Channel
		FUNC = R10 -		; Read or write logical block
		IOSB = (R0) -		; I/O Status block address
		P1 = (R6) -		; Buffer address
		P2 = R7 -		; Byte count to transfer
		P3 = R8 		; Logical block number
	BLBC	R0,50$			; Branch if error
	MOVZWL	(SP),R0			; Get completion status
	BLBS	R0,90$			; Branch if completed successfully
	BEQL	70$			; Branch if I/O is still in progress
;
; Error from QI/O
;
50$:	CMPW	R0,#SS$_INSFWSL		; Insufficient working set?
	BNEQ	100$			; Branch if not, report error
	ASHL	#-1,R7,R7		; Try again with half the byte count
	BICL	#^X1FF,R7		; Use an integral number of pages
	BNEQ	20$			; Branch if something left to transfer
	BRB	100$			; Couldn't even transfer 1 page
;
; The following magic with event flag 0 and the IOSB is to take care
; of the case that the event flag was set for some reason other than 
; the completion of this particular I/O request.  In that case, the
; only real completion information is the IOSB itself.  The sequence
; must be to clear the event flag, check the IOSB, and then wait again
; for the event flag.
;
60$:	$WAITFR_S #0			; Wait for event flag
70$:	$CLREF_S #0			; Clear the event flag
	MOVZWL	(SP),R0			; Fetch I/O status
	BEQL	60$			; Branch if I/O not completed
	BLBC	R0,100$			; Branch if error
;
; I/O completed successfully, see if there is any more to do
;
90$:	ASHL	#-9,R7,R1		; Block count
	ADDL	R1,R8			; Starting LBN for next piece
	ADDL	R7,R6			; Starting Buf Adr for next piece
	SUBL	R7,R9			; Count bytes tranferred
	BGTR	10$			; Branch if another transfer to do
100$:	ADDL	#8,SP			; Clean off IOSB
	RSB				; and return
	.PAGE
	.SBTTL	BOO$CRMPSC - CREATE AND MAP A SYSTEM SECTION

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CREATES AND MAPS A SECTION IN SYSTEM SPACE
;
; CALLING SEQUENCE:
;
;	CALLG	(AP),BOO$CRMPSC
;
; INPUTS:
;
;	CHAN(AP)	=		CHANNEL ON WHICH FILE IS OPEN
;					WCB ADDRESS IF NEGATIVE
;	VBN(AP)		=		STARTING VBN TO MAP
;	PAGCNT(AP)	=		NUMBER OF PAGES TO MAP
;	SYSADR(AP)	=		ADDRESS TO RETURN STARTING SYSTEM VA
;	PROT(AP)	=		PROTECTION TO BE USED FOR PAGES
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
;--

	$OFFSET	4,POSITIVE,<-
	CHAN,-
	VBN,-
	PAGCNT,-
	SYSADR,-
	PROT-
	>
BOO$CRMPSC:
	.WORD	^M<R2,R3,R4,R5,R6>
	MOVL	CHAN(AP),R0
	MOVL	R0,R6
	BLSS	30$			; BRANCH IF WCB INSTEAD OF CHANNEL
	JSB	IOC$VERIFYCHAN
	BLBC	R0,10$			; BRANCH IF ERROR
	MOVL	CCB$L_WIND(R1),R6	; GET WINDOW CONTROL BLOCK ADDRESS
	BNEQ	20$			; BRANCH IF A FILE IS ACCESSED
	MOVZWL	#SS$_IVCHNLSEC,R0	; INVALID CHANNEL FOR A SECTION
10$:	RET
20$:	BBSS	#WCB$V_SHRWCB,WCB$B_ACCESS(R6),30$ ; SET SHARE BIT, BR IF SET

	.IF	EQ <WCB$L_PID+2-WCB$W_REFCNT> ; REFCNT EQ PID+2
	ROTL	#16,#1,WCB$L_PID(R6)	; MAKE PID INVALID, SET REFCNT = 1
	.IFF
	MOVW	#1,WCB$W_REFCNT(R6)	; SET REFCNT = 1
	.ENDC
30$:	MOVAL	@MMG$GL_SYSPHD,R5	; ADDRESS OF SYSTEM HEADER
	MOVL	PAGCNT(AP),R1		; PAGE COUNT TO BE MAPPED
	MOVZWL	#SS$_VASFULL,R0		; IF OUT OF SPT, "VIRT ADR SPACE FULL"
	ADDL3	R1,BOO$GL_SPTFREL,R4	; COMPUTE NEXT FREE SPT SLOT
	CMPL	R4,BOO$GL_SPTFREH	; ENOUGH ROOM FOR THIS SECTION
	BGTR	100$			; BRANCH IF NOT ENOUGH ROOM
	JSB	MMG$ALCSTX		; ALLOCATE SECTION TABLE ENTRY
	BLBC	R0,100$			; BRANCH IF NONE AVAILABLE
	MOVL	R4,BOO$GL_SPTFREL	; UPDATE SPT SLOTS ALLOCATED
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R3 ; BASE ADDRESS OF SECTION TABLE
	MOVAL	(R3)[R1],R3		; ADDRESS OF SECTION TABLE ENTRY
	CLRL	SEC$L_CCB(R3)		; NO CHANNEL CONTROL BLOCK ADDRESS
	MOVL	R6,SEC$L_WINDOW(R3)	; SET WINDOW ADDRESS
	MOVL	VBN(AP),SEC$L_VBN(R3)	; STARTING VBN OF SECTION
	MOVL	PAGCNT(AP),R0		; SECTION SIZE
	SUBL	R0,R4			; BASE VIRTUAL PAGE NUMBER
	MOVL	R4,SEC$L_VPXPFC(R3)	; STARTING VIRTUAL PAGE NUMBER IN SPT
	CLRW	SEC$W_FLAGS(R3)		; ZERO SECTION FLAGS
	MOVL	R0,SEC$L_PAGCNT(R3)	; SIZE OF SECTION IN PAGES
	MOVL	R0,SEC$L_REFCNT(R3)	; NUMBER OF OUTSTANDING REFERENCES
	CLRL	SEC$W_SECXFL(R3)	; NO SECTION INDICES
	INSV	#<PTE$M_TYP1 ! PTE$M_TYP0>@-16,-
		#16,#16,R1		; FORM SECTION TYPE PTE
	INSV	PROT(AP),#PTE$V_PROT,#PTE$S_PROT,R1 ; SET DESIRED PROTECTION
	MOVAL	@MMG$GL_SPTBASE[R4],R2	; ADDRESS OF FIRST SPT ENTRY TO FILL IN
70$:	MOVL	R1,(R2)+		; STORE EACH PAGE TABLE ENTRY
	SOBGTR	R0,70$			; AND REPEAT FOR EACH PAGE
	ASHL	#9,R4,R4		; FORM STARTING (SYSTEM) VA
	BBSS	#VA$V_SYSTEM,R4,80$	; SET THE SYSTEM BIT
80$:	MOVL	R4,@SYSADR(AP)		; RETURN SECTION BASE ADDRESS
	BBC	#WCB$V_SHRWCB,WCB$B_ACCESS(R6),90$ ; BRANCH IF NOT SHARED WCB
	INCW	WCB$W_REFCNT(R6)	; COUNT ANOTHER POINTER TO SHARED WCB
90$:	MOVL	S^#SS$_NORMAL,R0	; SET SUCCESS STATUS
100$:	RET				; AND RETURN
	.PAGE
	.SBTTL	SIP_INIWCB - ALLOCATE AND INIT A WINDOW CONTROL BLOCK
;
; INPUTS:
;
;	R2 = ADDRESS OF MAPPING DATA
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;
; OUTPUTS:
;
;	R2 = WINDOW CONTROL BLOCK ADDRESS
;	R0,R1,R3 ALTERED
;	R4,R5 PRESERVED
;	RETURNS IN LINE ONLY IF SUCCESSFUL
;	FATAL ERROR IF FAIL TO ALLOCATE A WINDOW
;
SIP_INIWCB:
	MOVL	(R2)+,R1		;SIZE OF RETRIEVAL POINTER
	MOVL	EXE$GL_SYSUCB,R3	;SYSTEM UCB ADDRESS
	JSB	MMG$INIWCB		;ALLOCATE AND INIT THE WINDOW
	BLBC	R0,10$			;BRANCH IF FAILED
	RSB

10$:	MOVAB	W^INIWCBERR,R1		; ERROR INITING WINDOW CONTROL BLOCK
	BSBW	SIP_FATAL		;
	.PAGE
	.SBTTL	SIP MAKE KNOWN FILE ENTRY FOR FCP

MAKE_FCP_KFI:
	.WORD	0
	CALLG	(AP),W^INS$CREDEL	; CREATE THE KNOWN FILE ENTRY
	BLBC	R0,10$			; BRANCH IF ERROR
	MOVL	@EXE$GL_KNOWNFIL,R1	; GET ADDRESS OF FIRST KNOWN FILE LIST
	MOVL	@(R1),KFI$GL_F11AACP	; STORE KNOWN FILE ENTRY ADDRESS
					; FOR THE FCP, WHERE THE IMAGE
					; ACIVATOR WILL FIND IT.
10$:	RET
	.PAGE
	.SBTTL	ALLOCATE NON-PAGED DYNAMIC MEMORY
;++
; Functional Description:
;	This routine allocates and zeroes the specified number of
;	bytes of non-paged dynamic memory.  If the allocation fails
;	it deallocates the FIL$OPENFILE cache if has not already been
;	deallocated and tries again.
;
; Calling Sequence:
;	BSBW	SIP_ALONONPAGED
;
; Inputs:
;	R1 = Desired number of bytes to allocate
;
; Outputs:
;	R0 = Status
;	R1 = No. of bytes allocated if successful
;	R2 = Address of block allocated if successful
;	     Block is zeroed
;	All other registers preserved
;--

SIP_ALONONPAGED:
	PUSHR	#^M<R1,R3,R4,R5>	; REMEMBER SIZE FOR RETRY
					; SAVE OTHERS FROM MOVC5
10$:	JSB	G^EXE$ALONONPAGED	; ALLOCATE NON-PAGED MEMORY
	BLBS	R0,30$			; BRANCH IF SUCCESSFUL
	TSTL	G^FIL$GQ_CACHE		; CACHE STILL ALLOCATED?
	BEQL	40$			; BRANCH IF NOT, ALLOC ERROR
	CALLS	#0,B^SIP_CACHE_DALC	; DEALLOCATE FIL$OPENFILE CACHE
	MOVL	(SP),R1			; RECOVER SIZE TO ALLOCATE
	BRB	10$			; AND TRY AGAIN
30$:	PUSHR	#^M<R0,R1,R2>		; SAVE RETURN INFO FROM MOVC5
	MOVC5	#0,(R2),#0,R1,(R2)	; ZERO THE ALLOCATED BLOCK
	POPR	#^M<R0,R1,R2>		; RECOVER STATUS, SIZE, ADR
40$:	ADDL	#4,SP			; CLEAN OFF SAVED SIZE TO ALLOCATE
	POPR	#^M<R3,R4,R5>		; RESTORE OTHER REGISTERS
	RSB

	.SBTTL	DEALLOCATE FIL$OPENFILE CACHE
;
; KERNEL MODE ROUTINE TO DEALLOCATE THE FIL$OPENFILE CACHE
;
SIP_CACHE_DALC:
	.WORD	^M<R2,R3>
	MOVQ	G^FIL$GQ_CACHE,R1	; R1 = SIZE, R2 = ADR OF CACHE
	BEQL	10$			; BRANCH IF NOT PRESENT
	CLRQ	G^FIL$GQ_CACHE		; DISABLE THE CACHE
	MOVL	R2,R0
	MOVL	G^EXE$GL_NONPAGED+4,R3	; ADDRESS OF FREE NON-PAGED POOL
	JSB	G^EXE$DEALLOCATE	; DEALLOCATE FIL$OPENFILE CACHE
10$:	MOVL	S^#SS$_NORMAL,R0	; INDICATE SUCCESSFUL COMPLETION
	RET
	.PAGE
	.SBTTL	SIP ERROR/MESSAGE OUTPUT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE IS CALL TO DISPLAY AN ERROR FOR THE
;	SYSTEM INITIALIZATION PROCESS.
;
; CALLING SEQUENCE:
;
;	BSB	SIP_FATAL		; DISPLAY ERROR AND EXIT
;	BSB	SIP_SYSMSG		; TO DISPLAY A SYSTEM ERROR AND RETURN
;	BSB	SIP_R0MSG		; TO DISPLAY AN ERROR WITH VALUE IN R0
	BSB	SIP_TYPOUT		; TYPE OUT A MESSAGE
;
; INPUT PARAMETERS:
;
; FOR SIP_FATAL AND SIP_SYSMSG:
;
;	R0 IS ERROR CODE
;	R1 IS ADDRESS OF COUNTED MESSAGE STRING
;
; CALL AT SIP_TYPOUT WITH:
;
;	R0 = BYTE COUNT
;	R1 = ADDRESS OF STRING
;
; OUTPUT PARAMETERS:
;
;	THE MESSAGE IS DISPLAYED AND AN IMAGE EXIT IS EFFECTED IF
;	ENTERED AT SIP_FATAL.
;--
;
SIP_FATAL:
	PUSHL	R0			; SAVE ERROR
	BSB	SIP_SYSMSG		; OUTPUT MESSAGE
	CALLS	#1,@#SYS$EXIT		; TAKE EXIT WITH STATUS
 
;
; ROUTINE TO PRINT MESSAGE WITH SYSTEM ERROR CODE
;
 
SIP_SYSMSG:
	PUSHR	#<^M<R0,R2>>		; SAVE ARGUMENT AND A REGISTER
	PUSHL	R1			; PUSH ADDRESS OF THE TEXT STRING
	MOVAL	W^SIP_Q_LINBUF+2,R2	; GET THE BUFFER DESCRIPTOR
	MOVW	(R2),-(R2)		; SET BUFFER LENGTH
	PUSHAQ	(R2)			; ADDRESS OF BUFFER DESCRIPTOR
	PUSHAW	(R2)			; PLACE TO RETURN LENGTH
	PUSHAB	W^FAOERR		; FORMAT STRING
	CALLS	#5,@#SYS$FAO		; FORMAT THE MESSAGE
	MOVZWL	(R2),R0			; GET LENGTH
	MOVL	4(R2),R1		; BUFFER ADDRESS
	POPR	#^M<R2>			; RESTORE CALLER R2
					; FALL INTO TYPE OUT
 
SIP_TYPOUT:				;
	PUSHR	#^M<R0,R1>		; SAVE BUFFER AND COUNT
	$ASSIGN_S  W^SIP_Q_TTNAME,W^SIP_L_TTCHAN ; ASSIGN A CHANNEL TO TERMINAL
	BLBC	R0,30$			; BR IF ERROR ASSIGNING CHANNEL
	POPR	#^M<R0,R1>		; RESTORE COUNT AND BUFFER
	$QIOW_S	#0,W^SIP_L_TTCHAN,-	; EVENT FLAG 0, TERMINAL CHANNEL
		#IO$_WRITEVBLK,-	; WRITE OPERATION
		,,,-			; NO I/O STATUS,AST ADDRESS OR PARAMETER
		(R1),R0,-		; BUFFER ADDRESS IN R1,R0 CONTAINS COUNT
		#0,#32			; NULL PARAMETER PLUS CARRAIGE CONTROL
	BLBC	R0,30$			; BR IF ERROR WRITING TERMINAL
	$DASSGN_S W^SIP_L_TTCHAN	; REMOVE TERMINAL ASSIGNMENT
	BLBC	R0,30$			; BR ON DEASSIGN ERROR
	RSB				; RETURN TO CALLER
30$:	$CMKRNL_S B^100$		; GET TO KERNEL MODE
;
; FATAL ERROR ROUTINE
;
100$:	.WORD	0			; ERROR ATTEMPTING OUTPUT TO TERMINAL
	BUG_CHECK  SYSTRMERR,FATAL	; REPORT FATAL ERROR
	.PAGE
	.SBTTL	SIP_SETTIME  -  SET SYSTEM TIME TO CORRECT VALUE AT STARTUP
;++
; FUNCTIONAL DESCRIPTION:
;	SIP_SETTIME SOLICITS THE CORRECT TIME FROM THE OPERATOR IF NECESSARY,
;	CONVERTS THE ASCII RESPONSE TO BINARY FORMAT AND CALLS THE
;	SYS$SETIME SYSTEM SERVICE TO SET THE NEW SYSTEM TIME.
;
;	ANY CHANGES BY SYSBOOT TO THE SYSTEM PARAMETERS ARE ALSO SAVED
;	BY THE SYS$SETIME SERVICE SINCE IT WRITES THE TIME-OF-DAY CLOCK
;	BASE VALUE BACK TO THE SYSTEM IMAGE AND THE PARAMETERS ARE
;	LOCATED IN THE SAME PAGE(S).
;
;	IF THE TIME WOULD NORMALLY BE SOLICITED FROM AN OPERATOR, BECAUSE
;	THE HARDWARE TIME OF YEAR CLOCK IS ZERO, THEN THE SYSGEN PARAMETER
;	"TPWAIT" IS CHECKED.  IF IT IS ZERO, THEN IT IS ASSUMED THAT NO
;	OPERATOR IS PRESENT AND THE SYSTEM IS BOOTED USING THE LAST TIME
;	RECORDED IN THE SYSTEM IMAGE.  IF THE PARAMETER IS NON ZERO THEN
;	THAT TIME IS USED AS THE MAXIMUM TIME TO WAIT BEFOR ASSUMING THAT
;	THERE IS NO OPERATOR AND BOOTING ANY WAY.  IF THE PARAMETER IS
;	NEGATIVE, THE SYSTEM WILL WAIT FOREVER.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	TIME-OF-DAY PROCESSOR CLOCK.
;
; IMPLICIT OUTPUTS:
;	EXE$GQ_SYSTIME - SET TO CURRENT TIME IN 100 NANOSECOND UNITS SINCE
;			 17-NOV-1858  00:00:00.
;
;	SYSTEM PARAMETER PAGE(S) WRITTEN BACK TO SYS$SYSTEM:SYS.EXE.
;
;--

SIP_SETTIME:				; SET CORRECT TIME
	.ENABLE LSB
	.WORD	^M<R2,R3,R4,R8,R9,R10>	; ENTRY MASK
	BBS	S^#EXE$V_SETTIME,EXE$GL_FLAGS,READTIME	; BR IF MUST SOLICIT TIME
	MFPR	#PR$_TODR,R10		; GET TIME OF DAY CLOCK VALUE
	SUBL3	EXE$GL_TODR,R10,R9	; GET TOD DELTA TIME (10 MS UNITS)
	BLEQU	READTIME		; LESS, MUST SOLICIT TIME
5$:	$SETIME_S			; USE TIME-OF-DAY CLOCK TO SET
					; SYSTEM TIME
	RET				;

READTIME:				; SOLICIT TIME 
	CLRL	R9			; CLEAR A FLAG
	CVTWL	G^SGN$GW_TPWAIT,R8	; PICK UP TIMEOUT WAIT INTERVAL
	BGTR	8$			; POSITIVE, WAIT THAT PERIOD ONCE
	BLSS	7$			; NEGATIVE IS WAIT FOREVER
6$:	MTPR	G^EXE$GL_TODR,#PR$_TODR	; ZERO, SET TIME-OF-DAY CLOCK TO
	BRB	5$			;   KNOWN VALUE AND FINISH UP

7$:	MOVL	#20,R8			; STARTING WAIT
	INCL	R9			; NEGATIVE - WAIT FOREVER
8$:	$GETTIM_S	W^SIP_Q_CURNTIM	; GET CURRENT TIME FOR VALIDITY CHECK
	$ASSIGN_S	W^SIP_Q_TTNAME,W^SIP_L_TTCHAN	; AND ASSIGN TO INPUT DEVICE
	BLBS	R0,10$			; CONTINUE IF SUCCESSFUL
	BRW	99$			; FATAL SET TIME ERROR
10$:	MOVAB	W^TIMEPROMPT,R2		; GET ADDRESS OF PROMPT STRING
	MOVZBL	(R2)+,R3		; AND LENGTH
	$QIOW_S	#0,W^SIP_L_TTCHAN,-	; PROMPT AND READ TIME
	#<IO$_READPROMPT!IO$M_PURGE!IO$M_TIMED!IO$M_CVTLOW>,-
	W^SIP_Q_TMPDESC,,,-		; I/O STATUS BLOCK , NO AST OR PARAM
	W^SIP_T_LINBUF,#SIP_C_LINBUFSIZ,-	; BUFFER ADDRESS AND SIZE
	R8,#0,-				; TIME OUT
	R2,R3				; PROMPT ADDRESS AND SIZE
	BLBC	R0,99$			; FATAL SET TIME ERROR
	MOVQ	W^SIP_Q_TMPDESC,R4	; GET COMPLETION STATUS
	BLBS	R4,20$			; CONTINUE IF SUCCESSFUL READ
	BLBC	R9,6$			; FAILED ON ONE-TIME READ, RETURN
	MOVAB	1(R8)[R8],R8		; (2 * TIMEOUT) + 1
	MOVZWL	R8,R8			; BOUND TIMEOUT
	BRB	10$			; TRY AGAIN FOR TIME
20$:					; SOMETHING WAS INPUT
	MOVZWL	W^SIP_Q_TMPDESC+2,W^SIP_Q_TMPDESC	; FORM DESCRIPTOR FOR BUFFER
	MOVAB	W^SIP_T_LINBUF,W^SIP_Q_TMPDESC+4	; SET DESCRIPTOR ADDRESS
	$BINTIM_S	W^SIP_Q_TMPDESC,W^SIP_Q_INTIME	; CONVERT TO BINARY TIME
	BLBC	R0,89$			; INVALID TIME
	CMPL	W^SIP_Q_INTIME+4,W^SIP_Q_CURNTIM+4	; CHECK FOR VALID
	BLSS	89$			; NOT VALID, TOO EARLY
	BGTR	30$			; LOOKS GOOD
	CMPL	W^SIP_Q_INTIME,W^SIP_Q_CURNTIM	; CHECK LOW ORDER BITS
	BLSSU	89$			; NOT VALID
30$:					; VALID TIME INPUT, CONVERTED
	BRB	100$			; RELEASE CHANNEL AND EXIT

89$:					; INVALID TIME VALUE INPUT
	MOVAB	W^TIMERR,R2		; ADDRESS OF ERROR MESSAGE 
	MOVZBL	(R2)+,R3		; GET STRING LENGTH
	$QIOW_S	#0,W^SIP_L_TTCHAN,-	; GIVE ERROR MESSAGE
		#IO$_WRITEVBLK,-	;
		,,,-			; NO I/O STATUS,AST OR AST PARAM
		(R2),R3	,-		; BUFFER ADDRESS, LENGTH
		#0,#32			; SET CARRIAGE CONTROL TO CR/LF
	BRW	10$			; AND TRY AGAIN
99$:					; BAD ERROR
100$:					; EXIT
	$DASSGN_S	W^SIP_L_TTCHAN	; DE-ASSIGN TERMINAL CHANNEL
	$SETIME_S W^SIP_Q_INTIME	; SET NEW SYSTEM TIME
	RET				;
	.DISABLE LSB

	.END	SIP_START
