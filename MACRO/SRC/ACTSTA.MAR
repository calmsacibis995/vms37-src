	.TITLE	MAC$ACTSTA MACHINE STATEMENTS
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 25-AUG-78
;
; MODIFIED BY:
;
;	V02.18	BLS0063		Benn Schreiber	30-Jul-1981
;		Remove 65K store repeated check since linker
;		allows more
;
;	V02.17	PCG0004		Peter George	28-Jul-1981
;		Call DATARG from QUDSTR and OCTSTR.
;
;	V02.16	PCG0002		Peter George	05-May-1981
;		Set RELPSECT flag for all global symbol assignments
;		and for all global labels.
;
;	V02.15	CNH0042		Chris Hume	28-Oct-1980
;		De-optimize boundary valued backward references if indexing
;		requested.  Allow the architecturally legal immediate mode in
;		address and vield contexts and also the practically useless
;		indexed immediate mode.
;		(ACTREF.MAR 02.15, DEFINE.MAR 02.17, SYMTAB.MAR 02.18)
;
;	V01.14	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.13	RN0020		R. Newland	26-Oct-1979
;		Change error message for .BLKx expression not absolute
;
;	V01.12	RN0019		R. Newland	25-Oct-1979
;		Improve error pointer positioning
;
;	V01.11	RN0014		R. Newland	14-Oct-1979
;		Support for G_floating, H_floating and Octaword data types.
;		.BLKG, .BLKH, .BLKO and .OCTA directives.
;
;	V01.10	RN0005		R. Newland	12-Aug-1979
;		Remove .ALIGN LONG statements
;
;	V01.15	RN0029		R. Newland	12-Feb-1980
;		Correct listing of branch operand when on continued line.
;
;	V01.13	RN0021		R. Newland	28-Oct-1979
;		Correct listing of .ENTRY register mask value.
;		SPR 11-26384
;
;	V01.09	0003		B. Schreiber	10-JAN-1979
;		Catch syntax error if pound sign forgotten before
;		ASCII immediate (^A) in operands.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_INTCODDEF			;DEFINE INT. FILE COMMANDS
	$MAC_ADRMODDEF			;DEFINE ADDRESSING MODES
	$MAC_OPRDEF			;DEFINE OPERAND DESCRIPTOR BITS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG

DAT_NUL_CMD:
	.BYTE	INT$_STIB,-
		INT$_STIW,-
		INT$_STIL,-
		INT$_STIL,-
		INT$_STIB,-
		INT$_STIW,-
		INT$_STIL

DAT_RPT_CMD:
	.BYTE	INT$_STRB,-
		INT$_STRW,-
		INT$_STRL,-
		0,-
		INT$_STRSB,-
		INT$_STRSW,-
		0

DAT_STO_CMD:
	.BYTE	INT$_STOB,-
		INT$_STOW,-
		INT$_STOL,-
		INT$_STOL,-
		INT$_STSB,-
		INT$_STSW,-
		INT$_STOL

DAT_TRUNC_CHK:				;ROUTINES TO CHECK FOR TRUNCATION
	.ADDRESS MAC$CK_BYT_TRU1,-	;BYTE
		MAC$CK_WRD_TRU1,-	;WORD
		0,-			;LONGWORD
		0,-			;QUADWORD
		MAC$CK_SBY_TRU1,-	;SIGNED BYTE
		MAC$CK_SWD_TRU1,-	;SIGNED WORD
		0			;OCTAWORD

DAT_SHIFT_FACT:				;SHIFT # OF ELEMENTS OF ALLOCATION
					;BY THIS MUCH TO GET ALLOCATION
	.BYTE	0,1,2,3,0,1,4		;BYTE,WORD,LONG,QUAD,SIGNED_BYTE,
					;SIGNED_WORD,OCTAWORD

;++
; THIS IS THE HEART OF THE MARS ASSEMBLER.  THESE ROUTINES HANDLE
; MACHINE INSTRUCTIONS WHICH APPEAR AS SPECIAL BLOCKS IN THE
; SYMBOL TABLE.  THE 'SYM$B_SEG' BYTE IS THE NUMBER OF OPERANDS
; THE INSTRUCTION NEEDS.  STARTING AT BYTE 'SYM$K_BLKSIZ' IS A
; STRING OF BYTES DESCRIBING THE OPERANDS.  THE LOW 4 BITS DEFINE
; THE SIZE OF THE OPERAND, THE NEXT 3 BITS ARE AN INDEX INTO THE
; ILLEGAL MODE TABLE, AND THE LAST BIT IS SET IF IT IS A FLOATING
; OPERAND.
;
;--

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

STAT1::					;STATEMENT = MACHINE_STAT

	TSTL	W^MAC$GL_MOPNUM		;WERE THERE ENOUGH OPERANDS?
	BLEQ	10$			;IF LEQ YES
	$MAC_ERR NOTENUFOPR		; No--set message code
	BSBW	MAC$ERRORPT		;SEND ERROR MSG TO INT. FILE
10$:	RSB

	.SBTTL	OPCODE GENERATION

;++
; FUNCTIONAL DESCRIPTION:
;
;	MINST1 IS INVOKED WHEN AN OPCODE IS ENCOUNTERED.  IT SETS
;	UP TO PROCESS THE OPERANDS THAT FOLLOW THE OPCODE.
;
; INPUTS:
;
;	MAC$GL_VALUE		SYMBOL BLOCK ADDRESS OF OPCODE
;
; OUTPUTS:
;
;	MAC$GL_MOPNUM		NUMBER OF OPERANDS FOR THIS OPCODE
;	MAC$GL_MOPPTR		POINTER TO OPERAND WORD DESCRIPTORS
;
;--

MINST1::				;MACHINE_INST = DOPCODE

	MOVL	W^MAC$GL_VALUE,R6	;GET SYMBOL BLOCK ADDRESS
	BSBW	MAC$CREF_OPCODE		;CREF THE OPCODE IF NEEDED
	$INTOUT_WD INT$_OP,SYM$L_VAL(R6) ;OUTPUT OPCODE TO PASS 2
	$INC_PC				;UPDATE PC FOR OPCODE
	TSTB	SYM$L_VAL+1(R6)		;TWO-BYTE OPCODE?
	BEQL	10$			;IF EQL NO
	$INC_PC				;YES--UPDATE PC FOR 2-BYTE OPCODE
10$:	MOVZBL	SYM$B_SEG(R6),-		;SET UP OPERAND COUNTER
			W^MAC$GL_MOPNUM
	MOVAB	SYM$K_BLKSIZ(R6),-	;POINT TO OPERAND MODE WORD DESCRIPTORS
			W^MAC$GL_MOPPTR	;

;
; EXIT FROM MACHINE INSTRUCTION OR OPERAND--SET FOR NEXT OPERAND
;

MACH_OP_EXIT:
					; Clear Index Mode de-optimize flag,
	bicw2	#FLG$M_UPAFLG!FLG$M_OPTVFLIDX,4(r11) ; and DUpA flag.
	BBCC	#FLG$V_CHKLPND,(R11),5$	;CHKL PENDING?
	$INTOUT_X INT$_CHKL		;YES--SEND IT NOW
5$:	EXTZV	#OPD$V_SIZE,#OPD$S_SIZE,- ;GET SIZE OF OPERAND
		@W^MAC$GL_MOPPTR,R0	;...
	MOVL	R0,W^MAC$GL_OPSIZE	;AND STORE FOR LATER USE
10$:	CLRL	W^MAC$GB_MODE		;CLEAR MODE,IMODE,REG, AND IREG
	MOVL	W^MAC$GL_PSECT,-	;START WITH CURRENT PSECT
			W^MAC$GL_PRMSEG	;
	CMPL	R9,W^MAC$GL_INTWRNPT	;NEAR THE END OF THE INT. BUFFER?
	BLEQU	20$			;IF LEQU NO
	BSBW	MAC$OUTFRAME		;YES--SET UP FOR NEW BUFFER
20$:	MOVL	R9,W^MAC$GL_EXPPTR	;SAVE PTR TO EXPRESSION START
	MOVL	R9,W^MAC$GL_EXPEND	;AND EXPRESSION END
	BISL2	#FLG$M_COMPEXPR!FLG$M_EXPOPT!FLG$M_EVALEXPR,-
			(R11)		;ASSUME COMPILE TIME EXPRESSION,
					; ALLOW EXPRESSION OPTIMIZATION
					; AND EVALUATE ON PASS 2
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE EXPRESSION
	MOVL	W^MAC$GL_PC,W^MAC$GL_SAVE_PC ;SAVE PC FOR ERROR RECOVERY
	CLRL	W^MAC$GL_HIGH_32	;CLEAR HI 32 BITS IN CASE QUAD OPERAND
	RSB

	.SBTTL	OPERAND GENERATION

;++
; FUNCTIONAL DESCRIPTION:
;
;	OPRAND IS INVOKED WHEN A REFERENCE (OPERAND) HAS BEEN SCANNED.
;	IF THERE ARE TOO MANY OPERANDS A MESSAGE IS ISSUED TO PASS 2.
;	THE MODE OF THE REFERENCE IS CHECKED TO SEE IF IT IS LEGAL FOR
;	THIS OPERAND.  THE REFERENCE IS THEN EMITTED TO PASS 2.
;
; INPUTS:
;
;	MAC$GL_MOPPTR		POINTER TO OPERAND WORD DESCRIPTOR
;	MAC$GB_MODE		MODE OF OPERAND
;
; OUTPUTS:
;
;	THE INTERMEDIATE CODE FOR THIS OPERAND IS EMITTED TO THE
;	INTERMEDIATE FILE.
;
;--

OPRAND::				;OPERANDS = REF
					;OPERANDS = OPERANDS DCOMMA REF

	TSTL	W^MAC$GL_MOPNUM		;SHOULD WE REALLY BE HERE?
	BGTR	10$			;IF GTR THEN CONTINUE
	$MAC_ERR TOOMNYOPND		; Else set error message code
	BSBW	MAC$ERRORPX		;SEND ERROR TO PASS 2
	MOVL	W^MAC$GL_SAVE_PC,W^MAC$GL_PC ;RESET PC TO NOT COUNT OPERAND
	BRB	MACH_OP_EXIT		;FINISH UP THIS OPERAND
10$:	MOVZWL	@W^MAC$GL_MOPPTR,R6	;GET OPERAND DESC. WORD THIS OPRAND
	EXTZV	#OPD$V_MODE,#OPD$S_MODE,- ;GET THE OPERAND MODE
		R6,R5			;INTO R5
	MOVZBL	W^MAC$GB_MODE,R4	;GET OPERAND MODE WE SCANNED
	MOVZWL	L^MAC$AW_ILLMODTB[R5],R0 ;GET TABLE ENTRY FOR ACCESS MODE
	BBC	R4,R0,20$		;BRANCH IF LEGAL MODE
	$MAC_ERR ILLMODE		; No--get message code
	CMPB	R4,#ADM$_REGISTER	; Is addressing mode register?
	BNEQ	14$			; No if NEQ
	BSBW	MAC$ERRORPX		;SEND ERROR TO PASS 2
	BRB	16$
14$:
	BSBW	MAC$ERRORPT		; Send error to pass-2
16$:
	CLRL	R6			;USE ZERO DESCRIPTOR
20$:	ADDL2	#2,W^MAC$GL_MOPPTR	;ADVANCE TO NEXT DESCRIPTOR
	DECL	W^MAC$GL_MOPNUM		;DECREMENT OPERAND COUNT
	BNEQ	30$			;IF NEQ THEN NOT LAST OPERAND
	CMPW	W^MAC$GL_ERRPTX,-	;LAST OPERAND--FIRST ON LINE?
			#MAC$AB_LINEBF	;
	BEQL	30$			;IF EQL YES
	BBCS	#OPF$V_LASTOPR,-	;NO--MARK LAST OPERAND
			W^MAC$GL_OPSIZE,30$
30$:	BBS	#FLG$V_COMPEXPR,(R11),40$ ;BRANCH IF OPTIMIZABLE
	BBCC	#FLG$V_EXPOPT,(R11),50$	;ELSE FLAG UNABLE TO OPTIMIZE
40$:	BBC	#FLG$V_EXPOPT,(R11),50$	;BRANCH IF UNABLE TO OPTIMIZE
	BSBW	MAC$OPTIMIZEXPR		;OPTIMIZE EXPRESSION
	BBCS	#OPF$V_OPTEXP,-		;MARK OPTIMIZED
			W^MAC$GL_OPSIZE,50$
50$:	CMPW	R6,#OPD$M_BB		;BRANCH DESTINATION?
	BEQL	60$			;IF EQL YES
	CMPW	R6,#OPD$M_BW		;BRANCH DESTINATION?
	BEQL	55$			;IF EQL YES
	BRW	120$			;ELSE NOT A BRANCH DESTINATION
55$:	$INC_PC				;YES--UPDATE PC FOR BRANCH WORD
60$:	CMPB	W^MAC$GB_VAL3,#REG$_PC	;REGISTER MUST BE 'PC'
	BEQL	70$			;IF EQL OK
	$MAC_ERR ILLBRDEST		; Illegal branch destination
	BSBW	MAC$ERRORPX		;SEND ERROR TO PASS 2
	BRW	150$			;FINISH
70$:	CMPB	W^MAC$GB_MODE,#ADM$_BYTE_DISP ;CORRECT BRANCH SIZE
	BNEQ	80$
	$DEC_PC				;
	BRB	100$			;JOIN COMMON CODE
80$:	CMPB	W^MAC$GB_MODE,#ADM$_WORD_DISP
	BNEQ	90$
	$DEC_PC	#2
	BRB	100$
90$:	$DEC_PC	#4
100$:	CLRB	-(SP)			;ASSUME NOT OPTIMIZED
	MOVL	W^MAC$GL_EXPOPVL1,R3	;GET (MAYBE) OPTIMIZED VALUE
	BBS	#FLG$V_EXPOPT,(R11),110$ ;BRANCH IF WE OPTIMIZED
	CLRL	R3			;ASSUME GLOBAL
	MOVL	W^MAC$GL_EXPPTR,R2	;GET EXPRESSION POINTER
	SUBL3	R2,W^MAC$GL_EXPEND,R0	;COMPUTE SIZE OF EXPRESSION
104$:
	BEQL	110$			;IF EQL NO EXPRESSION
	CMPL	R0,#6			;6 BYTES?
	BEQL	106$			; Yes if EQL
	CMPB	1(R2),#INT$_NEWL	; Is it a new-line?
	BNEQ	110$			; No if NEQ
	MOVZBL	(R2),R1			; Get frame length
	ADDL2	R1,R2			; Point to next frame
	SUBL2	R1,R0			; and reduce size of expression
	BRB	104$
106$:
	CMPB	1(R2),#INT$_STKS	;YES--STACK SYMBOL REFERENCE?
	BNEQ	110$			;IF NEQ NO
	MOVL	2(R2),R3		;YES--GET ID ADDRESS
	MOVB	W^MAC$GL_PSECT,(SP)	;MUST BE IN SAME PSECT
	CLRL	2(R2)			;FLAG SPECIAL RESOLUTION
110$:	MOVZBL	#9,R0			;WE WILL OUTPUT 9 BYTES
	BSBW	MAC$INTOUT_N		;MAKE ROOM FOR THEM
	MOVB	#INT$_BDST,(R9)+	;STORE INT. CODE
	MOVW	W^MAC$GL_OPSIZE,(R9)+	;STORE FLAGS
	MOVL	R3,(R9)+		;STORE 0 OR SYMBOL ID ADDRESS
	MOVB	(SP)+,(R9)+		;STORE 0 OR PSECT NUMBER
	BRB	150$
;
; NOT BRANCH DESTINATION
;
120$:	BBC	#FLG$V_UPAFLG,(R11),125$ ;BRANCH IF DUPA WAS NOT SEEN
	CMPB	W^MAC$GB_REG,#REG$_PC	;YES--IS REGISTER PC?
	BNEQ	125$			;IF NEQ NO
	CMPB	R4,#ADM$_BYTE_DISP	;YES--IS MODE LEGAL?
	BLSS	125$			;IF LSS YES
	$MAC_ERR OPRNDSYNX		;NO--TELL OF OPERAND SYNTAX ERROR
	BSBW	MAC$ERRORPT		;...
125$:	BBC	#FLG$V_EXPOPT,(R11),130$ ;BRANCH IF CANNOT OPTIMIZE
	MOVZBL	#12,R0			;SET TO STORE 12 BYTES
	BSBW	MAC$INTOUT_N		;SET UP FOR IT
	MOVB	#INT$_REF,(R9)+		;STORE INT. CODE
	MOVL	W^MAC$GL_VALUE,(R9)+	;STORE REGISTERS/MODES
	MOVW	W^MAC$GL_OPSIZE,(R9)+	;STORE FLAGS
	MOVL	W^MAC$GL_EXPOPVL1,(R9)+	;STORE OPTIMIZED VALUE
	BRB	140$
130$:	MOVZBL	#8,R0			;SET TO STORE 8 BYTES
	BSBW	MAC$INTOUT_N		;SET UP FOR IT
	MOVB	#INT$_REF,(R9)+		;STORE INT. CODE
	MOVL	W^MAC$GL_VALUE,(R9)+	;STORE MODES/REGISTERS
	MOVW	W^MAC$GL_OPSIZE,(R9)+	;STORE FLAGS
140$:
	CMPB	W^MAC$GL_VALUE,#ADM$_IMMEDIATE ; Is address mode immediate?
	BNEQ	150$			; No if NEQ
	CMPB	W^MAC$GL_OPSIZE,#8	; Is operand a QUAD or OCTA value?
	BLSS	150$			; No if LSS
	$INTOUT_LW INT$_STIL,<W^MAC$GL_HIGH_32> ; Output bits 32-63
	CMPB	W^MAC$GL_OPSIZE,#16	; Is operand an OCTA value?
	BNEQ	150$			; No if NEQ
	$INTOUT_LW INT$_STIL,<W^MAC$GQ_HIGH_64+0> ; Output bits 64-95
	$INTOUT_LW INT$_STIL,<W^MAC$GQ_HIGH_64+4> ; and then bits 96-127
150$:	MOVB	#RDX$V_DECIMAL,W^MAC$GB_RDXNDX ;RESET RADIX
	BRW	MACH_OP_EXIT

	.SBTTL	ASSIGNMENT STATMENTS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES ARE INOVKED WHEN AN ASSIGNMENT STATMENT
;	IS DETECTED.  IF ENTRY AT ASSHD3, IT IS FLAGGED AS AN
;	ASSIGNMENT TO 'PC'.  IF ENTRY AT ASSHD2, THE SYMBOL
;	IS FLAGGED AS GLOBAL.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-8[R7]	(ASSHD2) SYMBOL BLOCK OF ID
;	MAC$AL_VALSTACK-4[R7]	(ASSHD1) SYMBOL BLOCK OF ID
;
; OUTPUTS:
;
;	MAC$GL_ASNPTR		POINTER TO SYMBOL BLOCK OF ID
;	MAC$GL_OPSIZE		4
;
;--


ASSHD3::				;ASSIGN_HEAD = DPC
	CVTBL	#-1,R0			;MARK PC AUGMENTATION
	BRB	ASSIGN_HEAD

ASSHD2::				;ASSIGN_HEAD = ID DEQ DEQ
	MOVL	W^MAC$AL_VALSTACK-8[R7],R0 ;POINT TO ID SYMBOL BLOCK
	BISW2	#SYM$M_GLOBL,SYM$W_FLAG(R0) ;MARK SYMBOL AS GLOBAL
	BISW2	#SYM$M_RELPSECT,SYM$W_FLAG(R0)	;ALWAYS OUTPUT GLOBAL SYMBOL
	BRB	ASSIGN_HEAD

ASSHD1::				;ASSIGN_HEAD = ID DEQ
	MOVL	W^MAC$AL_VALSTACK-4[R7],R0 ;POINT TO ID SYMBOL BLOCK
ASSIGN_HEAD:
	MOVL	R0,W^MAC$GL_ASNPTR	;SAVE POINTER TO ID
	CLRL	W^MAC$GL_PRMSEG		;ALLOW EXPRESSION IN ANY SEGMENT
	BBCC	#FLG$V_EVALEXPR,(R11),10$ ;DON'T EVALUATE EXPRESSION
10$:	BISL2	#FLG$M_COMPEXPR!FLG$M_OPRND,- ;ASSUME COMPILE TIME EXPR
			(R11)		;AND FLAG IN OPERAND FIELD
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE EXPRESSION
	MOVZBL	#4,W^MAC$GL_OPSIZE	;SET OPERAND MAX SIZE TO 4 BYTES
;
; IF CREFFING, SAVE LINE/PAGE SO THEY ARE CORRECT
;
	BBC	#FLG$V_CRF,(R11),30$	;BRANCH IF NOT CREFFING
	MOVL	W^MAC$GL_SRCPAG,-	;YES--SAVE SOURCE PAGE
		W^MAC$GL_SAV_PAG
	MOVL	W^MAC$GL_LINBAS,-	;SAVE LINE BASE
		W^MAC$GL_SAV_BAS
	MOVL	W^MAC$GL_LINENUM,R0	;GET THE LINE NUMBER
	BBC	#FLG$V_SEQFIL,(R11),20$	;BRANCH IF NOT SEQUENCED
	MOVL	W^MAC$GL_RECHDBUF,R0	;YES--GET SEQUENCE NUMBER
20$:	MOVL	R0,W^MAC$GL_SAV_LIN	;AND SAVE LINE NUMBER
30$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	ASSGN1 IS INVOKED TO FINISH PROCESSING AN ASSIGNMENT STATEMENT.
;	THE EXPRESSION HAS BEEN EVALUATED, AND IS ON THE VALUE STACK.
;	IF THE ASSIGNMENT IS TO THE PC, CODE IS EMITTED TO THE INTERMEDIATE
;	FILE TO AUGMENT THE PC.  IF THE ASSIGNMENT IS NOT TO PC, A
;	CHECK IS MADE FOR A MULTIPLE LABEL DEFINITION, AND THEN THE
;	FLAGS IN THE SYMBOL BLOCK ARE UPDATED.  CODE IS EMITTED TO
;	THE INTERMEDIATE FILE TO UPDATE THE SYMBOL BLOCK IN PASS 2.
;
; INPUTS:
;
;	MAC$GL_ASNPTR		(-1) IF PC AUGMENTATION, ELSE POINTER
;				TO SYMBOL BLOCK OF ID.
;	MAC$AL_VALSTACK-4[R7]	EXPRESSION VALUE
;
; OUTPUTS:
;
;
;--

ASSGN1::				;ASSIGNMENT = ASSIGN_HEAD EXPR DEOL
	MOVL	W^MAC$GL_ASNPTR,R6	;GET POINTER TO ID SYMBOL BLOCK
	BBS	#FLG$V_COMPEXPR,(R11),10$ ;MUST BE COMPILE TIME EXPRESSION
	$MAC_ERR ASGNMNTSYN		; No--send message to pass 2
	BSBW	MAC$ERRORPT
10$:	ADDL3	#1,R6,R0		;IS THIS PC ASSIGNMENT (R6=-1?)?
	BNEQ	20$			;IF NEQ NO
	BSBW	MAC$SET_PC		;YES--RECORD HI MARK OF PC
	MOVL	W^MAC$AL_VALSTACK-4[R7],R6 ;GET NEW VALUE
	SUBL3	W^MAC$GL_PC,R6,R5	;COMPUTE AUGMENTATION
	$INTOUT_LW INT$_AUGPC,R5	;SEND TO PASS 2
	MOVL	R6,W^MAC$GL_PC		;SET NEW PC
	BSBW	MAC$SET_PC		;CHECK NEW PC
	BRW	80$			;
;
; EXPRESSION DOES NOT INVOLVE PC
;
20$:	BBC	#SYM$V_EXTRN,SYM$W_FLAG(R6),30$ ;EXTERNAL?
	$MAC_ERR SYMDCLEXTR		; Yes-error
	BSBW	MAC$ERRORPT		;ISSUE ERROR TO PASS 2
30$:	BSBW	MAC$MUL_DEF_CHK		;SEE IF MULTIPLY DEFINED
	MOVB	W^MAC$GL_PRMSEG,SYM$B_SEG(R6) ;DEFINE IN EXPRESSION PSECT
	BICW2	#SYM$M_ABS,SYM$W_FLAG(R6) ;ASSUME NOT ABSOLUTE
	TSTL	W^MAC$GL_ABSFLAG	;IS EXPRESSION ABSOLUTE?
	BNEQ	50$			;IF NEQ NO
	CLRB	SYM$B_SEG(R6)		;YES--MAKE ABSOLUTE PSECT
	BBCS	#SYM$V_ABS,SYM$W_FLAG(R6),50$ ;SET ABSOLUTE FLAG
50$:	BBS	#SYM$V_LOCAL,SYM$W_FLAG(R6),60$ ;IS SYMBOL LOCAL?
	BLBC	W^ENB$G_DEBUG+SYM$L_VAL,60$	;NO--BRANCH IF NO ENABLE DEBUG
	BISW2	#SYM$M_DEBUG,SYM$W_FLAG(R6) ;LET DEBUGGER KNOW ABOUT SYMBOL
60$:	MOVL	W^MAC$AL_VALSTACK-4[R7],- ;PUT IN SYMBOL VALUE
			SYM$L_VAL(R6)
	BISW2	#SYM$M_DEF!SYM$M_ASN,-	;MARK AS DEFINED BY ASSIGNMENT
			SYM$W_FLAG(R6)
	MOVZBL	#CRF$K_DEF,R5		;SET DEFINITION FLAG
	PUSHL	W^MAC$GL_LINBAS		;GET READY TO SET RIGHT LINE/PAGE
	PUSHL	W^MAC$GL_LINENUM	;BY SAVING CURRENT VALUES
	PUSHL	W^MAC$GL_SRCPAG		;...
	PUSHL	W^MAC$GL_RECHDBUF
	MOVL	W^MAC$GL_SAV_BAS,-	;NOW SET VALUES WE WANT
		W^MAC$GL_LINBAS
	MOVL	W^MAC$GL_SAV_LIN,R0
	MOVL	R0,W^MAC$GL_LINENUM
	MOVL	R0,W^MAC$GL_RECHDBUF	;(IN CASE SEQUENCED FILE)
	MOVL	W^MAC$GL_SAV_PAG,-
		W^MAC$GL_SRCPAG
	BSBW	MAC$CREF_SYM		;OUTPUT TO CREF IF CREFFING
	POPL	W^MAC$GL_RECHDBUF	;RESTORE OLD LINES/PAGES
	POPL	W^MAC$GL_SRCPAG		;
	POPL	W^MAC$GL_LINENUM	;
	POPL	W^MAC$GL_LINBAS		;
	BSBB	MAC$INTOUT_ASN		;OUTPUT ASN TO INTERMED. FILE
80$:	BBCS	#FLG$V_EVALEXPR,(R11),90$ ;ALLOW EXPRESSION EVALUATION
90$:	$INTOUT_LW INT$_PRIL,<W^MAC$AL_VALSTACK-4[R7]> ;PRINT EXPRESSION
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS AN ASSIGN COMMAND AND DATA TO THE
;	INTERMEDIATE FILE.
;
; INPUTS:
;
;	R6	POINTS TO SYMBOL BLOCK
;
;--

MAC$INTOUT_ASN::
	MOVZBL	#12,R0			;SIZE OF AN ASN COMMAND AND DATA
	BSBW	MAC$INTOUT_N		;MAKE ROOM FOR IT
	MOVB	#INT$_ASN,(R9)+		;STORE THE COMMAND
	MOVL	R6,(R9)+		;STORE SYMBOL BLOCK ADDRESS
	MOVB	SYM$B_SEG(R6),(R9)+	;STORE SYMBOL SEGMENT
	MOVL	SYM$L_VAL(R6),(R9)+	;STORE SYMBOL VALUE
	CLRL	R0			;ASSUME ABSOLUTE
	BBS	#SYM$V_ABS,SYM$W_FLAG(R6),10$ ;BRANCH IF ABSOLUTE
	INCL	R0			;NO--MAKE RELOCATABLE
10$:	MOVB	R0,(R9)+		;STORE ABS/REL FLAG
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS FOR A MULTIPLY DEFINED LABEL.  IF THE
;	LABEL IS MULTIPLY DEFINED, AN ERROR MESSAGE IS ISSUED TO
;	PASS 2.
;
; INPUTS:
;
;	R6	SYMBOL BLOCK ADDRESS
;
;--

MAC$MUL_DEF_CHK::
	BBC	#SYM$V_DEF,SYM$W_FLAG(R6),10$ ;BRANCH IF NOT DEFINED
	BBS	#SYM$V_ASN,SYM$W_FLAG(R6),10$ ;BRANCH IF BY ASSIGNMENT
	$MAC_ERR MULDEFLBL		; This is multiply defined
	BRW	MAC$ERRORPT		;ISSUE ERROR TO PASS 2
10$:	BLBC	W^ENB$G_SUPPRESS+SYM$L_VAL,20$ ;BRANCH IF NOT ENABLE SUPPRESSION
	BISW2	#SYM$M_SUPR,SYM$W_FLAG(R6) ;YES--SET SUPPRESS BIT THIS SYMBOL
20$:	RSB

	.SBTTL	BLOCK DATA STORAGE DIRECTIVES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES (BLKBYT, BLKWRD, BLKLNG, BLKQUD AND BLKOCT) ARE
;	CALLED WHEN A BLOCK DATA DIRECTIVE IS SCANNED.  THE
;	SHIFT COUNT FOR THE PARTICULAR DATA TYPE IS SET INTO 
;	MAC$GL_VALUE AND FLAGS ARE SET TO SCAN THE EXPRESSION
;	INDICATED THE NUMBER OF UNITS OF STORAGE TO ALLOCATE.
;
; OUTPUTS:
;
;	MAC$GL_VALUE	SHIFT COUNT TO SHIFT NUMBER OF UNITS INTO BYTES
;	MAC$GL_FLAGS	FLG$M_COMPEXPR IS SET (LOOK FOR COMPILE TIME EXPRESSION
;			FLG$M_EVALEXPR IS CLEARED (DON'T EVALUATE ON PASS 2)
;
;--

	.ENABL	LSB

BLKBYT::				;BLOCK_TYPE = KBLKB
	BSBB	10$			;GO TO COMMON ROUTINE
	.BYTE	0			;SHIFT ALLOCATION 0

BLKWRD::				;BLOCK_TYPE = KBLKW
	BSBB	10$			;GO TO COMMON ROUTINE
	.BYTE	1			;SHIFT ALLOCATION ONCE

BLKLNG::				;BLOCK_TYPE = KBLKL
					;	OR    KLBKA
					;	OR    KBLKF
	BSBB	10$			;GO TO COMMON ROUTINE
	.BYTE	2			;SHIFT ALLOCATION TWICE

BLKQUD::				;BLOCK_TYPE = KBLKQ
					;	OR    KBLKD
					;	OR	KBLKG
	BSBB	10$			;GO TO COMMON ROUTINE
	.BYTE	3			;SHIFT ALLOCATION THREE TIMES

BLKOCT::				;BLOCK TYPE = KBLKO
					;	OR    KBLKH
	BSBB	10$			;GOTO COMMON ROUTINE
	.BYTE	4			;SHIFT ALLOCATION FOUR TIMES

10$:	MOVZBL	@(SP)+,W^MAC$GL_VALUE	;SET SHIFT COUNT AS VALUE
	BISL2	#FLG$M_COMPEXPR,(R11)	;LOOK FOR COMPILE TIME EXPRESSION
	BBCC	#FLG$V_EVALEXPR,(R11),.+1 ;DON'T OUTPUT EXPRESSION TO PASS 2
	CLRL	W^MAC$GL_ABSFLAG	;LOOK FOR ABSOLUTE EXPRESSION
	RSB

	.DSABL	LSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE TWO ROUTINES (BSTAT1 AND BSTAT2) FINISH PROCESSING OF
;	BLOCK DATA DIRECTIVES.
;
;--

	.ENABL	LSB

BSTAT1::				;BLOCK_STAT = BLOCK_TYPE
	MOVZBL	#1,R6			;DEFAULT ALLOCATION IS 1 UNIT
	MOVL	W^MAC$AL_VALSTACK[R7],R5;GET THE SHIFT COUNT
	BRB	10$

BSTAT2::				;BLOCK_STAT = BLOCK_TYPE EXPR
	MOVL	W^MAC$AL_VALSTACK[R7],R6;GET NUMBER OF UNITS OF ALLOCATION
	MOVL	W^MAC$AL_VALSTACK-4[R7],R5 ;GET THE SHIFT COUNT
10$:	BSBW	MAC$SET_PC		;RECORD HIGH PC
	TSTL	W^MAC$GL_ABSFLAG	;EXPRESSION MUST BE ABSOLUTE
	BEQL	20$			;IF EQL IT IS
	$MAC_ERR BLKEXPNABS		; Set message code
	BSBW	MAC$ERRORPT		;ISSUE MESSAGE TO PASS 2
	CLRQ	R5			;ALLOCATE NO SPACE
20$:	ASHL	R5,R6,R6		;CONVERT ALLOCATION TO BYTES
	$INTOUT_LW INT$_AUGPC,R6	;AUGMENT PC BY THAT MANY BYTES
	$INC_PC	R6			;INCREMENT PC FOR PASS 1 ALSO
	$INTOUT_LW INT$_PRIL,<W^MAC$GL_PC> ;LIST NEW PC
	BBCS	#FLG$V_EVALEXPR,(R11),30$ ;ALLOW EXPRESSION EVALUATION ON PASS 2 AGAIN
30$:	RSB

	.DSABL	LSB

	.SBTTL	LABEL DEFINITIONS

	.ENABL	LSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES DEFINE LABELS.  IF ENTRY IS AT LBL2 THE LABEL
;	IS DEFINED GLOBALLY. IF ENTRY IS AT LBL1 THE LABEL IS DEFINED
;	AS A LOCAL LABEL.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-8[R7]	(LBL2) SYMBOL BLOCK ADDRESS OF ID
;	MAC$AL_VALSTACK-4[R7]	(LBL1) SYMBOL BLOCK ADDRESS OF ID
;
; OUTPUTS:
;
;	MAC$GL_LSB		INCREMENTED IF NOT LOCAL LABEL
;				AND 'ENABL LSB'
;
;--

	.ENABL	LSB

LBL2::					;LABEL = ID DCOLON DCOLON
	MOVL	W^MAC$AL_VALSTACK-8[R7],R6 ;POINT TO ID SYMBOL BLOCK
	BISW2	#SYM$M_GLOBL,SYM$W_FLAG(R6) ;MARK AS GLOBAL SYMBOL
	BISW2	#SYM$M_RELPSECT,SYM$W_FLAG(R6)	;ALWAYS OUTPUT GLOBAL SYMBOL
	BRB	10$

LBL1::					;LABEL = ID DCOLON
	MOVL	W^MAC$AL_VALSTACK-4[R7],R6 ;POINT TO ID SYMBOL BLOCK
10$:
LBL_X:					;ENTRY FOR .ENTRY
	BBS	#SYM$V_LOCAL,SYM$W_FLAG(R6),30$ ;BRANCH IF LOCAL SYMBOL
	BLBS	W^ENB$G_LOCALSYMB+SYM$L_VAL,20$ ;BRANCH IF ENABLE LSB
	BSBW	MAC$SET_NEW_LSB		;NO--MAKE A NEW LSB
20$:	BLBC	W^ENB$G_DEBUG+SYM$L_VAL,30$ ;BRANCH IF NO ENABLE DEBUG
	BBCS	#SYM$V_DEBUG,SYM$W_FLAG(R6),30$ ;NO--TELL DEBUGGER ABOUT SYMBOL
30$:	BBC	#SYM$V_DEF,SYM$W_FLAG(R6),40$ ;SYMBOL ALREADY DEFINED?
	$MAC_ERR MULDEFLBL		; Yes--send message
	BSBW	MAC$ERRORPT		;
40$:	BBC	#SYM$V_EXTRN,SYM$W_FLAG(R6),50$ ;IS SYMBOL EXTERNAL?
	$MAC_ERR SYMDCLEXTR		; Yes--send message
	BSBW	MAC$ERRORPT
50$:	MOVL	W^MAC$GL_PC,SYM$L_VAL(R6) ;SET SYMBOL VALUE
	MOVB	W^MAC$GL_PSECT,SYM$B_SEG(R6) ;SET PSECT NUMBER OF SYMBOL
	BISW2	#SYM$M_DEF,SYM$W_FLAG(R6) ;MARK AS DEFINED
	MOVL	W^MAC$GL_PSECTPTR,R5	;POINT TO CURRENT PSECT
	BBS	#PSC$V_REL,PSC$W_OPTIONS(R5),60$ ;BRANCH IF RELOCATABLE
	BISW2	#SYM$M_ABS,SYM$W_FLAG(R6) ;NO--FLAG SYMBOL AS ABSOLUTE
60$:	BISW2	#SYM$M_REF,PSC$W_FLAG(R5) ;MARK PSECT AS REFERENCED
	$INTOUT_LW INT$_LGLAB,R6	;OUTPUT COMMAND TO PASS 2
	MOVZBL	#CRF$K_DEF,R5		;SET DEFINITION
	BRW	MAC$CREF_SYM		;CREF SYMBOL IF CROSS REFERENCING

	.DSABL	LSB

	.SBTTL	DATA GENERATION DIRECTIVES

;++
; FUNCTIONAL DESCRIPTION:
;
;	BYTE/WORD/LONG/QUAD/SGNBYT/SGNWRD/OCTA ARE CALLED WHEN THE CORRESPONDING
;	DATA GENERATION DIRECTIVE IS SCANNED.  FLAGS ARE SET FOR THE
;	ROUTINES DALST2, DALST1, AND DATNUL TO PROCESS THE FOLLOWING
;	DATA ITEMS.
;
;--

BYTE::					;DATA_TYPE = KBYTE
	PUSHL	#0			;STACK INDEX
	BSBB	DAT_COM			;GO TO COMMON ROUTINE
	.BYTE	1			;1 BYTE PER ITEM

WORD::					;DATA_TYPE = KWORD
	PUSHL	#1			;STACK INDEX
	BSBB	DAT_COM			;GO TO COMMON ROUTINE
	.BYTE	2			;TWO BYTES PER ITEM

LONG::					;DATA_TYPE = KLONG
	PUSHL	#2			;STACK INDEX
	BSBB	DAT_COM			;GO TO COMMON ROUTINE
	.BYTE	4			;FOUR BYTES PER ITEM

QUAD::					;DATA_TYPE = KQUAD
	PUSHL	#3			;STACK INDEX
	BSBB	DAT_COM			;GO TO COMMON ROUTINE
	.BYTE	8			;EIGHT BYTES PER ITEM

SGNBYT::				;DATA_TYPE = KSGNB
	PUSHL	#4			;STACK INDEX
	BSBB	DAT_COM			;GO TO COMMON ROUTINE
	.BYTE	1			;ONE BYTE PER ITEM

SGNWRD::				;DATA_TYPE = KSGNW
	PUSHL	#5			;STACK INDEX
	BSBB	DAT_COM			;GO TO COMMON ROUTINE
	.BYTE	2			;TWO BYTES PER ITEM

OCTA::					;DATA_TYPE = KOCTA
	PUSHL	#6			;STACK INDEX
	BSBB	DAT_COM			;GOTO COMMON ROUTINE
	.BYTE	16			;SIXTEEN BYTES PER ITEM

DAT_COM:
	MOVZBL	@(SP)+,W^MAC$GL_OPSIZE	;STORE OPERAND SIZE
	POPL	W^MAC$GL_DIRFLG		;STORE INDEX
	BBCS	#FLG$V_EVALEXPR,(R11),.+1 ;ALLOW EXPRESSION EVALUATION
;
; CONTINUE ON INTO DATA_EXIT
;

;++
; FUNCTIONAL DESCRIPTION:
;
;	'ADDRES' IS CALLED WHEN A .ADDRESS DIRECTIVE IS SCANNED.
;	ALL THAT IS DONE IS TO SET FLAGS AND ENSURE THAT THERE
;	IS ROOM IN THE INTERMEDIATE BUFFER TO CONTAIN THE EXPRESSION.
;
;--

ADDRES::				;ADDR_TYPE = KADDRESS
DATA_EXIT:
	CMPL	R9,W^MAC$GL_INTWRNPT	;NEAR THE END OF THE BUFFER?
	BLEQU	10$			;IF LEQ NO
	BSBW	MAC$OUTFRAME		;YES--WRITE BUFFER OUT
10$:	MOVL	R9,W^MAC$GL_EXPPTR	;SAVE START OF EXPRESSION
	MOVL	R9,W^MAC$GL_EXPEND	;AND END OF EXPRESSION
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE EXPR
	CLRL	W^MAC$GL_PRMSEG		;ABSOLUTE SEGMENT
	BBCC	#FLG$V_DATRPT,(R11),.+1	;NO REPEAT YET
	BISL2	#FLG$M_EXPOPT!FLG$M_COMPEXPR,(R11) ;ALLOW EXPRESSION OPT.
					;   AND ASSUME COMPILE TIME EXPR
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	'STOADR' IS CALLED FOR EACH ITEM FOUND IN A .ADDRESS DIRECTIVE.
;	CODE IS PUT IN THE INTERMEDIATE BUFFER TO STACK THE VALUE,
;	AND STORE POSITION INDPENDENT DATA.  FLAGS ARE THEN INITIALIZED
;	FOR THE NEXT ITEM.
;
;--

STOADR::				;ADDR_LIST = EXPR ! ADDR_LIST DCOMMA EXPR
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BNEQ	10$			;IF NEQ NO
	BSBW	MAC$OPTIMIZEXPR		;YES--WIPE IT OUT
	$INTOUT_LW INT$_STKL,<W^MAC$AL_VALSTACK[R7]> ;AND STACK THE VALUE
10$:	$INTOUT_X INT$_SPID		;STORE PIC DATA
	$INC_PC	#4			;COUNT FOUR BYTES
	BRW	DATA_EXIT		;INIT FOR NEXT ADDRESS

;++
; FUNCTIONAL DESCRIPTION:
;
;	'DATARG' IS CALLED FOR EACH ITEM IN A BYTE/WORD/LONG/QUAD
;	DIRECTIVE.  FLAGS ARE INITIALIZED FOR THE NEXT ITEM.
;
;--

DATARG::				;DATA_LIST = EXPR
					;DATA_LIST = DATA_LIST DCOMMA EXPR
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BEQL	10$			;IF EQL YES
	BBCC	#FLG$V_EXPOPT,(R11),10$	;NO--NO OPTIMIZATION
10$:
;
; THE FOLLOWING ALLOWS EVALUATION OF REPEAT COUNT
;
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE
	CLRL	W^MAC$GL_PRMSEG		;ABS PSECT
	BBCC	#FLG$V_DATRPT,(R11),.+1	;NO REPEAT COUNT YET
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	'DATNUL' IS CALLED WHEN A NULL DATA ITEM IS FOUND IN A
;	BYTE/WORD/LONG/QUAD/OCTA DIRECTIVE.  A ZERO VALUE IS EMITTED
;	TO PASS 2 AND FLAGS  ARE INITIALIZED FOR THE NEXT ITEM.
;
;--

DATNUL::				;DATA_STAT = DATA_TYPE <NULL>
	MOVL	W^MAC$GL_DIRFLG,R5	;GET INDEX FOR DATA TYPE
	MOVZBL	L^DAT_NUL_CMD(R5),R0	;GET COMMAND
	PUSHL	#0			;STACK A 0
	BSBW	MAC$INTOUT_1_LW		;SEND TO INT. BUFFER
	MOVZBL	L^DAT_SHIFT_FACT(R5),R3	; Get shift factor
	CMPB	R3,#3			; Was this .QUAD or .OCTA?
	BLSS	10$			; No if LSS
	$INTOUT_LW INT$_STIL,<#0>	; Set bits 32-63 as zero
	CMPB	R3,#4			; Was this .OCTA?
	BNEQ	10$			; No if NEQ
	$INTOUT_LW INT$_STIL,<#0>	; Set bits 64-95 and
	$INTOUT_LW INT$_STIL,<#0>	; bits 96-127 as zero
10$:	$INC_PC	W^MAC$GL_OPSIZE		;COUNT THE BYTES
	BRW	DATA_EXIT		;INIT FOR NEXT ITEM

;++
; FUNCTIONAL DESCRIPTION:
;
;	'DALST2' AND 'DALST1' ARE CALLED TO PROCESS THE ITEMS IN
;	A DATA-LIST FOR BYTE/WORD/LONG/QUAD/OCTA DIRECTIVES.  'DALST2'
;	IS CALLED IF THIS IS A REPEAT ITEM, AND 'DALST1' IS CALLED
;	IF IT IS NOT.
;
;--

DALST2::				;DATA_ARGS = DATA_LIST DSQOPN EXPR DSQCLS
	BBCS	#FLG$V_DATRPT,(R11),-	;THIS IS REPEATED DATA
		DALST1
QUDSTR::				;DATA_STAT = QUAD_HEAD PRIMITIVE
OCTSTR::				;DATA_STAT = OCTA_HEAD PRIMITIVE
	BSBW	DATARG			;INIT DATA FLAGS
DALST1::				;DATA_ARGS = DATA_LIST
	MOVL	W^MAC$GL_DIRFLG,R5	;GET DATA TYPE INDEX
	BBC	#FLG$V_DATRPT,(R11),30$	;BRANCH IF NOT REPEAT
;
; THIS IS REPEATED DATA TYPE
;
	TSTL	W^MAC$GL_ABSFLAG	;IS REPEAT COUNT ABSOLUTE?
	BNEQ	10$			;IF NEQ NO--ERROR
	MOVL	W^MAC$AL_VALSTACK-4[R7],R0 ;YES--GET REPEAT COUNT
	BRB	20$			;AND SKIP AHEAD
10$:	$MAC_ERR RPTCNTNABS		; No--get error code
	BSBW	MAC$ERRORPT		;ISSUE MESSAGE TO PASS 2
	CLRL	W^MAC$AL_VALSTACK-4[R7]	;DO NO REPEATING
20$:	MOVZBL	L^DAT_RPT_CMD(R5),R0	;GET COMMAND
	BSBW	MAC$INTOUT_X		;ISSUE TO PASS 2
	MOVL	W^MAC$AL_VALSTACK-4[R7],R0 ;GET THE REPEAT COUNT
	BRB	60$			;FINISH UP
;
; NOT A REPEAT
;
30$:	BBC	#FLG$V_EXPOPT,(R11),40$	;BRANCH IF NOT OPTIMIZABLE
	BSBW	MAC$OPTIMIZEXPR		;YES--WIPE OUT EXPRESSION
	PUSHL	W^MAC$AL_VALSTACK[R7]	;STACK THE VALUE
	MOVL	L^DAT_TRUNC_CHK[R5],R0	;GET TRUNCATION ROUTINE CHECK ADDRESS
	BEQL	33$			;IF EQL NO NEED TO CHECK
	JSB	(R0)			;CHECK FOR TRUNCATION AND REPORT ERROR
33$:	MOVL	W^MAC$GL_DIRFLG,R5	;RETRIEVE DATA TYPE INDEX AGAIN
	MOVZBL	L^DAT_NUL_CMD(R5),R0	;GET THE COMMAND
35$:	BSBW	MAC$INTOUT_1_LW		;SEND TO INT. FILE
	BRB	50$			;CONTINUE
;
; NOT OPTIMIZED, NOT REPEATED
;
40$:	MOVZBL	L^DAT_STO_CMD(R5),R0	;GET COMMAND
	BSBW	MAC$INTOUT_X		;SEND TO INT. FILE
50$:	MOVZBL	#1,R0			;USE REPEAT COUNT OF 1
;
; FINISH UP
;
60$:	MOVZBL	L^DAT_SHIFT_FACT(R5),R3	; Get shift factor
	ASHL	R3,R0,R0		; Figure total allocation
	$INC_PC	R0			;COUNT IN PASS 1
	CMPB	R3,#3			; Was this .QUAD or .OCTA
	BLSS	70$			; No if LSS
	$INTOUT_LW INT$_STIL,<W^MAC$GL_VAL3> ; Send bits 32-63 to intermediate file
	CMPB	R3,#4			; Was this .OCTA?
	BNEQ	65$			; No if NEQ
	$INTOUT_LW INT$_STIL,<W^MAC$GQ_VAL2+0> ; Send bits 64-95 and then
	$INTOUT_LW INT$_STIL,<W^MAC$GQ_VAL2+4> ; bits 96-127 to intermediate file
65$:
	RSB
70$:	BRW	DATA_EXIT		;INIT FOR NEXT ELEMENT

	.SBTTL	ENTRY POINT DEFINITION DIRECTIVES

;++
; FUNCTIONAL DESCRIPTION:
;
;	VECTR0 IS CALLED WHEN A .VECTOR DIRECTIVE WITH NO EPT MASK
;	IS SCANNED.
;
;--

VECTR0::				;DIRECTIVE = KVECTOR ID
	$INTOUT_LW INT$_STKEPT,<W^MAC$AL_VALSTACK[R7]> ;STACK ENTRY POINT MASK
	$INTOUT_X INT$_STOW		; Store word
	BRB	ENTRY_VEC_XIT		;TAKE COMMON EXIT

;++
; FUNCTIONAL DESCRIPTION:
;
;	VECTR2 AND VECTR1 ARE CALLED WHEN .VECTOR DIRECTIVES ARE
;	SCANNED WITH AN EPT MASK.  CODE IS EMITTED TO STACK THE
;	EPT AND OR IT WITH THE EXPRESSION ON THE STACK.
;
;--

VECTR2::				;DIRECTIVE = KVECTOR ID EXPR
	MOVL	W^MAC$AL_VALSTACK-4[R7],R2 ;POINT TO SYMBOL
	BRB	VEC_COM			;

VECTR1::				;DIRECTIVE = KVECTOR ID DCOMMA EXPR
	MOVL	W^MAC$AL_VALSTACK-8[R7],R2 ;POINT TO SYMBOL
VEC_COM:
	$INTOUT_LW INT$_STKEPT,R2	;STACK EPT
	$INTOUT_X INT$_OR		;OR WITH EXPR ON STACK
	$INTOUT_X INT$_STOW		; Store word
	BRB	ENTRY_VECTOR		;

;++
; FUNCTIONAL DESCRIPTION:
;
;	ENTRY1 AND ENTRY2 ARE CALLED TO PROCESS .ENTRY DIRECTIVES.  THE
;	ONLY DIFFERENCE BETWEEN THEM IS THAT ENTRY1 IS CALLED IF THERE
;	WAS A COMMA BETWEEN THE ID AND THE EXPRESSIION AND ENTRY2 IS
;	CALLED IF THERE WAS NO COMMA.
;
;--

ENTRY1::				;DIRECTIVE = KENTRY ID DCOMMA EXPR
	MOVL	W^MAC$AL_VALSTACK-8[R7],R6 ;POINT TO SYMBOL BLOCK
	BRB	ENTRY_COM

ENTRY2::				;DIRECTIVE = KENTRY ID EXPR
	MOVL	W^MAC$AL_VALSTACK-4[R7],R6 ;POINT TO SYMBOL BLOCK
ENTRY_COM:
	BISW2	#SYM$M_EPT!SYM$M_GLOBL,- ;MARK AS GLOBAL EPT
			SYM$W_FLAG(R6)	;...
	BSBW	LBL_X			;DEFINE LABEL
	$INTOUT_LW INT$_EPT,<R6,W^MAC$AL_VALSTACK[R7]> ;PROCESS EPT ON PASS 2
ENTRY_VECTOR:
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPR?
	BNEQ	10$			;IF NEQ NO
	BITL	#^X3003,W^MAC$AL_VALSTACK[R7] ;YES--ANY ILLEGAL BITS SET?
	BEQL	20$			;IF EQL NO
	$MAC_ERR ILLMASKBIT		; Yes--get message code
	BRB	15$			;
10$:	$MAC_ERR EMSKNOTABS		; Entry mask not absolute
15$:	BSBW	MAC$ERRORPT		;REPORT TO PASS 2
20$:
ENTRY_VEC_XIT:
	$INC_PC	#2			;COUNT TWO BYTES
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS THE .TRANSFER DIRECTIVE.
;	CODE IS EMITTED TO PASS 2 TO SEND A REDEFINITION COMMAND
;	TO THE LINKER.
;
;--

XFER::					;DIRECTIVE = KXFER ID
	$INTOUT_LW INT$_REDEF,<W^MAC$AL_VALSTACK[R7]> ;TELL PASS 2
	RSB

	.END
