	.TITLE	MAC$P2DRVR PASS 2 DRIVER MODULE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V02.08	PCG0002		Peter George	16-Apr-1981
;		Filter out abs psect code.
;
;	V01.07	RN0005		R. Newland	13-Aug-1979
;		Variable symbol storage and remove .ALIGN LONG statements
;
;	V01.07	RN0022		R. Newland	31-Oct-1979
;		Translate SYS$LP_LINES to set lines/page
;
;	V01.06	RN0002		R. Newland	01-Feb-1979
;		Changes for Source Update Merge
; 01	- 
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$RABDEF				;DEFINE RAB OFFSETS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAG OFFSETS

;
; LOCAL DATA
;

	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG

P2$DISPATCH::
	$MAC_INTCODDEF	DISPATCHTABLE
P2$K_MAXCOD=$COUNT			;MAXIMUM PASS 2 CODE + 1

	.SBTTL	MAC$P2DRVR  PASS 2 DRIVER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS THE MODULE HEADER TO THE OBJECT FILE,
;	INITIALIZES TO READ THE INTERMEDIATE 'FILE', AND THEN
;	PROCESSES THE INTERMEDIATE FILE.
;
;--

	.PSECT	MAC$RO_CODE_P2,NOWRT,GBL,LONG

MAC$PASS2_DRIVR::
	MOVAB	W^MAC$AB_OBJBUF,R10	;R10 POINTS TO OBJECT BUFFER DURING PASS 2
	CLRL	W^MAC$GL_PC		;PC STARTS AT 0
	CLRL	R7			;INITIALIZE STACK POINTER
	BSBW	MAC$WRT_LST_INI		;INITIALIZE LISTING BUFFER
	BBSC	#FLG$V_FIRSTLN,(R11),10$ ; Branch if immediate error
	BSBW	MAC$GETLIN		;START WITH FIRST LINE OF FILE
	BSBW	MAC$FORM_LINENO		; Form line number and audit trail
10$:
	MOVAB	W^PSECT$MAIN,W^MAC$GL_PSECTPTR ;START IN BLANK PSECT
;
; OUTPUT MODULE HEADER INFORMATION
;
	BSBW	MAC$OBJHDROUT		;OUTPUT MODULE HEADER INFO
;
; RESET THE INITIAL SETTINGS FOR THE ENABLE/DISABLE AND LIST/NLIST
; OPTIONS
;
	MOVAB	L^LST$G_DIRLIST,R5	;POINT TO THE LIST
2$:	CVTBL	SYM$B_TOKEN(R5),SYM$L_VAL(R5) ;RESET TO THE INITIAL SETTING
	MOVL	(R5),R5			;LINK TO NEXT
	BNEQ	2$			;LOOP FOR ALL
	MOVAB	L^ENB$G_OPTIONS,R5	;POINT TO ENABLE OPTIONS LIST
3$:	CVTBL	SYM$B_TOKEN(R5),SYM$L_VAL(R5) ;RESET
	MOVL	(R5),R5
	BNEQ	3$			;LOOP FOR ALL
;
; SET UP TO READ INTERMEDIATE 'FILE' FROM VIRTUAL MEMORY
;
	MOVL	W^MAC$GL_INTQUE,R9	;POINT TO BEGINNING OF FIRST BLOCK
	MOVAB	12(R9),R8		;R8 POINTS TO FIRST COMMAND
	CLRL	R7			;INIT VALUE STACK POINTER
	MOVL	SP,W^MAC$GL_SAVE_SP	;SAVE STACK POINTER
	ADDL3	8(R9),R8,-(SP)		;FIGURE END OF BLOCK ONTO STACK
;
; AT THIS POINT:
;
;	R10	POINTER INTO OBJECT BUFFER
;	R9	POINTER TO CURRENT INTERMEDIATE 'FILE' BLOCK
;	R8	POINTER INTO INTERMEDIATE FILE (INCH-ALONG)
;	R7	VALUE STACK POINTER
;
PASS_2_LOOP:
	CMPL	R8,(SP)			;ARE WE AT THE END OF A BUFFER?
	BLSSU	10$			;IF LSSU NO
	MOVL	(R9),R9			;YES--CHAIN TO NEXT BUFFER
	BEQL	MAC$EARLY_END		;IF EQL THEN EARLY ENDING
	MOVAB	12(R9),R8		;POINT TO FIRST ACTION
	ADDL3	8(R9),R8,(SP)		;FIGURE END OF NEW BUFFER
10$:	MOVZBL	(R8)+,R6		;GET LENGTH OF FRAME
	SUBL2	#2,R6			;COUNT LENGTH AND COMMAND BYTES
	MOVZBL	(R8)+,R0		;GET COMMAND
	BLEQ	20$			;IF LE THEN SURELY ILLEGAL
	CMPB	R0,#P2$K_MAXCOD		;ENSURE LEGAL
	BLSS	30$			;IF LSS THEN LEGAL
20$:	CLRL	R0			;0 GOES TO ILLEGAL COMMAND ROUTINE
;
; CALL PASS 2 ACTION ROUTINE WITH:
;
;	R10	POINTER INTO OBJECT BUFFER
;	R9	RESERVED
;	R8	POINTER TO INTERMEDIATE FILE 
;	R7	VALUE STACK POINTER
;	R6	LENGTH OF COMMAND IN BYTES
;	R5	POINTER TO TOP OF VALUE STACK (MAC$AL_VALSTACK[R7])
;
;	REGISTERS R8, R6, R5, AND R4-R0 MAY BE DESTROYED
;
30$:	CMPB	R6,#<-1-2>		;SPECIAL MACRO LINE (-1 FLAG -2 BYTES)?
	BNEQ	40$			;IF NEQ NO
	MOVZWL	(R8),R6			;YES--GET LENGTH OF TEXT
	ADDL2	#2,R6			;COUNT THE LENGTH WORD
40$:	ADDL3	R6,R8,-(SP)		;FIGURE START OF NEXT COMMAND
	MOVAL	W^MAC$AL_VALSTACK[R7],R5 ;POINT TO TOP OF VALUE STACK
	PUSHL	L^P2$DISPATCH[R0]	;GET ACTION ROUTINE ADDRESS
	JSB	@(SP)+			;DISPATCH TO ACTION ROUTINE
	MOVL	(SP)+,R8		;SET POINTER TO NEXT COMMAND
	BRB	PASS_2_LOOP
;
; WHEN THE .END DIRECTIVE IS ENCOUNTERED, CONTROL WILL TRANSFER
; TO HERE.
;
MAC$PASS_2_END::
	MOVL	W^MAC$GL_SAVE_SP,SP	;RESET THE STACK POINTER
	RSB

;
; WE REACHED THE END OF THE INTERMEDIATE FILE BEFORE WE SHOULD HAVE??!!!
;
MAC$EARLY_END::
	CALLS	#0,W^MAC$ERR_INTERN	;REPORT INTERNAL ERROR
	BRW	P2$END			;AND GO FINISH PASS 2

;
; ILLEGAL COMMAND ENCOUNTERED IN INTERMEDIATE BUFFER
;
P2$ILG::
	CALLS	#0,W^MAC$ERR_INTERN	;REPORT INTERNAL ERROR
	BRW	P2$END			;GO FINISH PASS 2
;
; STORE PIC CODE COMMAND NOT IMPLEMENTED (THIS SHOULD NEVAH HAPPEN SUH!)
;
P2$SPIC::				;(DO WE REALLY NEED THIS?)
	CALLS	#0,W^MAC$ERR_INTERN	;REPORT INTERNAL ERROR
	BRW	P2$END			;GO FINISH PASS 2


;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE EMITS A SYMBOL OR PSECT NAME TO THE OBJECT FILE.
;
; INPUTS:
;
;	R6	SYMBOL BLOCK ADDRESS
;
; OUTPUTS:
;
;	SYMBOL NAME AND SIZE OUTPUT TO OBJECT FILE
;
;--

MAC$SYMNAMOUT::
	BBS	#FLG$V_DBGOUT,(R11),5$	; If debugger record
	MOVL	MAC$GL_PSECTPTR,R0	; or zero psect
	BEQL	5$			; Then output record
	BBC	#PSC$V_REL, -		; Else if abs psect, then
		PSC$W_OPTIONS(R0),20$	; filter record out
5$:	MOVZBL	SYM$B_NAME(R6),R3	; Get offset to symbol count/name
	SUBL3	R3,R6,R3		; and form its address
	MOVB	(R3)+,R4		; Get count and advance pointer to name
	$OBJ_OUTBYT R4			;EMIT SIZE OF NAME
10$:	MOVB	(R3)+,(R10)+		;STORE ONE CHARACTER OF NAME
	SOBGTR	R4,10$			;LOOP FOR WHOLE NAME
20$:	RSB

	.SBTTL	OBJECT FILE OUTPUT ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	OUTPUTS THE BYTE IN R0 TO THE STORE IMMEDIATE COMMAND
;	ALREADY IN PROGRESS.  IF THE FLAG 'FLG$M_STOIMF' IS
;	FALSE THEN A NEW STORE IMMEDIATE COMMAND IS STARTED WITH
;	THIS BYTE.  THE FIRST BYTE OF A STORE IMMEDIATE COMMAND
;	IS THE TWO'S COMPLEMENT BYTE COUNT OF THE STRING UP TO
;	-128. (^O200).
;
; INPUTS:
;
;	R0	BYTE TO STORE
;
;--

MAC$STOIM::
	BBS	#FLG$V_DBGOUT,(R11),5$	; If debugger record
	MOVL	MAC$GL_PSECTPTR,R1	; or zero psect
	BEQL	5$			; Then output record
	BBC	#PSC$V_REL, -		; Else if abs psect, then
		PSC$W_OPTIONS(R1),30$	; filter record out
5$:	CMPW	R10,#MAC$AB_OBJWRN	;PAST WARNING LIMIT?
	BLEQU	10$			;IF LEQ NO
	BSBB	MAC$WRTOBJ		;YES--OUTPUT BUFFER
10$:	BBSC	#FLG$V_STOIMF,(R11),20$	;BRANCH IF STORE IMMEIDATE IN PROGRESS
	MOVL	R10,W^MAC$GL_STOIMPTR	;NO--START ONE.
	CLRB	(R10)+			;LEAVE ROOM FOR COUNT BYTE AND INIT IT
20$:	MOVB	R0,(R10)+		;STORE DATA BYTE
	DECB	@W^MAC$GL_STOIMPTR	;COUNT THE BYTE
	CMPB	@W^MAC$GL_STOIMPTR,#^O200 ;DONE 128 YET?
	BLEQU	30$			;IF LEQU YES
	BBSS	#FLG$V_STOIMF,(R11),30$	;NO--FLAG STORE IMMEDIATE IN PROGRESS
30$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	IF THE BUFFER POINTER IS PAST THE WARNING LIMIT, THE OBJECT
;	BUFFER IS WRITTEN OUT.  THE BYTE IN R0 IS THEN STORED IN THE
;	OBJECT FILE BUFFER.
;
; INPUTS:
;
;	R0	BYTE TO STORE
;
;--

MAC$CHKBYT::
	CMPW	R10,#MAC$AB_OBJWRN	;PAST THE WARNING LIMIT?
	BLEQU	10$			;IF LEQU NO
	BSBB	MAC$WRTOBJ		;YES--OUTPUT RECORD
10$:	BRB	MAC$OUTOBJ		;OUTPUT THE BYTE
					;AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	OUTPUT THE BYTE IN R0 TO THE OBJECT FILE
;
; INPUTS:
;
;	R0	BYTE TO OUTPUT
;
;--

	.ENABLE LSB

MAC$OUTOBJ::
	BBS	#FLG$V_DBGOUT,(R11),5$	; If debugger record
	MOVL	MAC$GL_PSECTPTR,R1	; or zero psect
	BEQL	5$			; Then output record
	BBC	#PSC$V_REL, -		; Else if abs psect, then
		PSC$W_OPTIONS(R1),20$	; filter record out
5$:	CMPB	W^MAC$GL_RECTYP,W^MAC$AB_OBJBUF ;SAME RECORD TYPE?
	BEQL	10$			;IF EQL YES
	BSBB	MAC$WRTOBJ		;NO--WRITE OUT LAST RECORD
10$:
MAC$OUTOBJ_0::
	MOVB	R0,(R10)+		;STORE BYTE IN BUFFER
	BBCC	#FLG$V_STOIMF,(R11),20$	;NO LONGER STORING IMMEDIATE
20$:	RSB

	.DISABLE LSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	WRITE OUT OBJECT CODE BUFFER TO OBJECT CODE FILE
;
; INPUTS:
;
;	R10	POINTS TO WHERE WE ARE IN BUFFER
;
; ***NO REGISTERS USED***
;
;--

MAC$WRTOBJ::
	CMPW	#MAC$AB_OBJBUF+1,R10	;IS BUFFER EMPTY?
	BGEQU	10$			;IF GEQ YES
	BBC	#FLG$V_OBJXST,(R11),10$	;BRANCH IF NO OBJECT FILE
	PUSHL	R0			;NO--SAVE R0
	SUBL3	#MAC$AB_OBJBUF,R10,R0	;FIGURE LENGTH OF RECORD
	MOVW	R0,L^MAC$OBJECT_RAB+RAB$W_RSZ ;SET RECORD LENGTH IN RAB
	$PUT	RAB=L^MAC$OBJECT_RAB,-	;SEND RECORD TO OUTPUT FILE
		ERR=W^MAC$ERR_PUT	; ERROR ROUTINE
	BLBS	R0,5$			;BRANCH IF SUCCESSFUL
	BSBW	MAC$CLS_DEL_OBJ		;CLOSE AND DELETE OBJECT FILE
5$:	INCL	W^MAC$GL_OBJ_RCNT	;COUNT OBJECT RECORD WRITTEN
	POPL	R0			;RESTORE R0
10$:	MOVAB	W^MAC$AB_OBJBUF,R10	;RESET POINTER INTO BUFFER
	MOVB	W^MAC$GL_RECTYP,(R10)+	;STORE RECORD TYPE IN BUFFER
	BBCC	#FLG$V_STOIMF,(R11),20$	;STOP ANY STORE IMMEDIATE IN PROGRESS
20$:	RSB

	.SBTTL	LISTING FILE ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	POP THE TOP LONGWORD OFF THE VALUE STACK AND LIST THE NUMBER
;	OF BYTES IN R0.  UPDATE R5 TO POINT TO THE TOP OF THE VALUE
;	STACK AGAIN.
;
; INPUTS:
;
;	R0	NUMBER OF BYTES TO OUTPUT (1 <= R0 <= 4)
;	R5	POINTS TO TOP OF VALUE STACK
;	R7	VALUE STACK POINTER
;
; OUTPUTS:
;
;	R5	POINTS TO NEW TOP OF STACK
;	R7	UPDATED
;	MAC$GL_PC INCREMENTED BY 1
;
;--

MAC$LIST_BYT_0::
	MOVAL	W^MAC$AL_VALSTACK[R7],R5 ;POINT R5 TO TOP OF STACK
MAC$LIST_BYTES::
	PUSHL	R0			;COPY BYTE COUNT
	PUSHL	R0			;COPY ONCE MORE FOR GOOD LUCK
	MOVAB	W^MAC$GL_VALUE,R3	;POINT TO RESULT AREA
	MOVL	(R5),(R3)		;COPY VALUE FROM TOP OF STACK
	DECL	R7			;'POP' THE STACK
	TSTL	-(R5)			;KEEP R5 POINTING TO TOP OF STACK
10$:	MOVZBL	(R3)+,R0		;GET NEXT BYTE
	BSBB	MAC$LST_HEX_BYT		;OUTPUT ONE BYTE
	SOBGTR	(SP),10$		;LOOP FOR ALL BYTES
	TSTL	(SP)+			;CLEAN STACK
	$INC_PC	(SP)+			;INC. PC AND CLEAN STACK
	DECL	W^MAC$GL_LIST_PTR	;BACK UP LISTING POINTER
	MOVB	#^A/ /,@W^MAC$GL_LIST_PTR ;STORE A SPACE
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS ONE BYTE TO THE LISTING FILE IN
;	HEX (TWO HEX DIGITS)
;
;--

MAC$LST_HEX_BYT::
	MOVZBL	R0,R0			;ENSURE REST OF WORD ZERO
	PUSHL	R0			;SAVE THE BYTE
	CMPW	W^MAC$GL_LIST_PTR,#MAC$AB_LST_OP2+1 ; Time to dump buffer?
	BGTRU	10$			; No if GTRU
	BBS	#FLG$V_UPDFIL,(R11),5$	; If updated file it is time now
	CMPW	W^MAC$GL_LIST_PTR,#MAC$AB_LST_END+1 ;TIME TO DUMP THE BUFFER?
	BGTRU	10$			;IF GTRU NO
5$:
	BSBW	MAC$WRTLST
	MOVL	(SP),R0			;REFRESH THE BYTE
10$:	BSBB	20$			;OUTPUT LOW 4 BITS
	ASHL	#-4,(SP)+,R0		;POSITION TO GET HI 4 BITS
20$:	DECL	W^MAC$GL_LIST_PTR	;
	BICB2	#^C<^XF>,R0		;ISOLATE 4 BITS
	MOVB	L^HEX_TAB(R0),@W^MAC$GL_LIST_PTR ;CONVERT AND OUTPUT
	RSB

HEX_TAB:.ASCII	/0123456789ABCDEF/	;CONVERSION FROM BINARY TO HEX

	.SBTTL	MAC$WRT_BLNKLIN	WRITE A BLANK LINE TO LISTING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WRITES A BLANK LINE TO THE LISTING FILE
;
;--

MAC$WRT_3_BLNK::
	PUSHL	#3			;SET TO WRITE 3 BLANK LINES
	BRB	WRT_BL

MAC$WRT_2_BLNK::
	PUSHL	#2			;SET TO WRITE 2 BLANK LINES
WRT_BL:	BSBB	MAC$WRT_BLNKLIN		;WRITE A BLANK LINE
	SOBGTR	(SP),WRT_BL		;LOOP FOR ALL
	TSTL	(SP)+			;CLEAN STACK
	RSB				;EXIT

MAC$WRT_BLNKLIN::
	MOVL	#-MAC$K_LIST_SIZE,W^MAC$GL_LINELN ;SET FOR NULL LINE
	BRB	MAC$WRTLST		;WRITE LINE AND RETURN

	.SBTTL	MAC$WRTLST	WRITE LINE TO LISTING FILE

;++
; FUNCTIONAL DESCRIPTION:
;
;	WRITES THE CURRENT LISTING LINE AND INITIALIZES FOR THE
;	NEXT LINE.
;
;--

MAC$WRTLST::
	MOVL	W^MAC$GL_LIST_IT,R2	;GET CURRENT LISTING FLAG
	BBC	#FLG$V_MACLTB,(R11),20$	;BRANCH IF NOT EXPANDING A MACRO
	BLBS	L^LST$G_MACROXPAN+SYM$L_VAL,20$ ;EXPANDING--BRANCH IF LISTING
						;MACRO EXPANSIONS
	CLRL	R2			;CLEAR LISTING FLAG
	BLBC	L^LST$G_MACROBIN+SYM$L_VAL,20$  ;BRANCH IF NOT LISTING
						;MACRO BINARY
	BBSC	#FLG$V_MEBLST,(R11),10$	;SPECIAL LIST FLAG ON?
	CMPL	W^MAC$GL_PC,W^MAC$GL_SAVE_PC ;SAME PC AS LAST TIME?
	BEQL	20$			;IF EQL YES
10$:	MOVL	SP,R2			;NO--SET LISTING FLAG
20$:	MOVL	W^MAC$GL_LINELN,R0	;GET LENGTH OF CURRENT LINE
	CMPB	#FF,L^MAC$AB_LINEBF-1(R0) ;LAST CHARACTER A FORMFEED?
	BNEQ	30$			;IF NEQ NO
	DECL	W^MAC$GL_LINELN		;YES--DON'T COUNT IT
	BEQL	40$			;IF EQL ZERO LENGTH LINE
30$:	TSTL	W^MAC$GL_LIST_LVL	;CHECK THE LISTING LEVEL
	BLSS	40$			;IF LSS DON'T LIST
	BGTR	50$			;IF GTR LIST EVERYTHING
	CMPL	R2,#1			;DON'T LIST '.LIST/.NLIST' AT LEVEL 0
	BNEQ	60$			;IF NEQ NOT .LIST/.NLIST
40$:	CLRL	R2			;CLEAR LISTING FLAG
	BRB	60$
50$:	MOVL	SP,R2			;SET LISTING FLAG
60$:	TSTL	R2			;LISTING FLAG CLEAR?
	BEQL	90$			;IF EQL YES--DO NO OUTPUT
	BBC	#FLG$V_LSTXST,(R11),MAC$WRT_LST_INI ;BRANCH IF NO LISTING FILE
	PUSHL	R0			;SAVE INDEX INTO LINEBF
	TSTL	W^MAC$GL_LINE_CNT	;AT THE END OF A PAGE
	BLEQ	70$			;IF LEQ YES--GO DO ONE
	BBC	#FLG$V_NEWPND,(R11),80$	;BRANCH IF NEW PAGE NOT PENDING
70$:	BSBW	MAC$LST_PAG_HDR		;YES--OUTPUT PAGE HEADER
80$:	MOVL	W^MAC$GL_LINELN,R0	;FIGURE SIZE OF LINE
	ADDW2	#MAC$K_LIST_SIZE,R0	;FIGURE TOTAL LENGTH OF LINE
	MOVAB	L^MAC$LIST_RAB,R1	;POINT TO LISTING RAB
	MOVW	R0,RAB$W_RSZ(R1)	;STORE RECORD SIZE
	BBC	#FLG$V_LSTXST,(R11),87$	;BRANCH IF ERROR IN HEADER OUTPUT
	MOVAB	W^MAC$AB_LST_END,RAB$L_RBF(R1) ;STORE BUFFER ADDRESS
	$PUT	RAB=(R1),-		;WRITE THE LINE TO THE LISTING
		ERR=W^MAC$ERR_PUT
	BLBS	R0,85$			;BRANCH IF GOOD PUT
	BSBW	MAC$CLOSE_LIST		;CLOSE THE LISTING FILE ON ERROR
85$:	DECL	W^MAC$GL_LINE_CNT	;DECREMENT LINES LEFT ON PAGE
87$:	POPL	R0			;GET INDEX INTO LINEBF
90$:	CMPB	#FF,L^MAC$AB_LINEBF-1(R0) ;FORM FEED?
	BNEQ	100$			;IF NEQ NO
	BBCS	#FLG$V_NEWPND,(R11),100$ ;YES--FLAG NEW PAGE NEEDED
100$:	BBCC	#FLG$V_MEBLST,(R11),110$ ;CLEAR SPECIAL LIST FLAG IF
					 ;IT GOT SET AND WE WERE NOT
					 ;IN A MACRO
110$:

MAC$WRT_LST_INI::
	PUSHR	#^M<R3,R4,R5>		;SAVE REGISTERS
	CLRL	W^MAC$GL_LINELN		;ZERO LENGTH OF LINE IN BUFFER
	MOVC5	#0,(R11),#^A/ /,-	;FILL LISTING BUFFER WITH SPACES
			#MAC$K_LIST_SIZE,-
			W^MAC$AB_LST_END
	MOVAB	W^MAC$AB_SEQ_NUM,W^MAC$GL_LIST_PTR ;INIT LISTING POINTER
	PUSHL	W^MAC$GL_VALUE		;SAVE WHAT MIGHT BE HERE
	$VPUSH	W^MAC$GL_PC		;STACK THE PC
	MOVZBL	#2,R0			;SET TO LIST TWO BYTES
	BSBW	MAC$LIST_BYT_0		;LIST THEM
	$DEC_PC	#2			;DON'T INCREMENT PC FOR IT THOUGH
	POPL	W^MAC$GL_VALUE		;RESTORE VALUE
	MOVL	W^MAC$GL_PC,W^MAC$GL_SAVE_PC ;SAVE PC
	CVTBL	#-1,W^MAC$GL_LIST_IT	;ASSUME LINE IS LISTED
	DECL	W^MAC$GL_LIST_PTR	;BACK UP POINTER
	MOVB	#^A/ /,@W^MAC$GL_LIST_PTR ;STORE A SPACE THERE
	POPR	#^M<R3,R4,R5>		;RESTORE REGISTERS
	RSB

	.SBTTL	MAC$LST_PAG_HDR	WRITE NEW PAGE AND HEADER TO LISTING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS A PAGE MARK AND A NEW PAGE HEADER TO
;	THE LISTING FILE.
;
;--

MAC$LST_PAG_HDR::
	BBCC	#FLG$V_NEWPND,(R11),10$	;CLEAR NEW PAGE PENDING FLAG
10$:	MOVL	W^MAC$GL_LN_PAGE,W^MAC$GL_LINE_CNT ; Reset lines/page
	BBS	#FLG$V_LSTXST,(R11),20$	;BRANCH IF LISTING FILE
	BRW	50$			;NO LISTING FILE--GO AWAY
20$:	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE REGISTERS
;***;	$ASCTIM_S TIMBUF=MAC$AL_ATIM_DSC ;GET NEW TIME FOR PAGE HEADER
	PUSHL	W^MAC$GL_LIST_PTR	;SAVE CURRENT LISTING POINTER
	MOVAB	W^MAC$AB_HD_END,W^MAC$GL_LIST_PTR ;POINT TO WHERE PAGE # GOES
	INCL	W^MAC$GL_LPTPAG		;BUMP PAGE COUNTER
	MOVL	W^MAC$GL_LPTPAG,R0	;GET LISTING PAGE NUMBER
	BSBW	MAC$DEC_OUT_R2L		;OUTPUT TO BUFFER
	MOVAB	W^MAC$AB_SBT_END-1,W^MAC$GL_LIST_PTR ;POINT TO WHERE SOURCE PAGE # GOES
	MOVB	#^A/)/,W^MAC$AB_SBT_END-1 ;STORE TERMINAL PAREN
	MOVL	W^MAC$GL_SRCPAG,R0	;GET SOURCE PAGE NUMBER
	BSBW	MAC$DEC_OUT_R2L		;OUTPUT SOURCE PAGE NUMBER
	SUBL3	#1,W^MAC$GL_LIST_PTR,R0	;GET NEXT AVAIL SPOT
	MOVB	#^A/(/,(R0)		;STORE OPEN PAREN
	MOVAB	L^MAC$LIST_RAB,R5	;POINT TO LISTING RAB
	MOVW	#MAC$K_HD_SIZE+1,RAB$W_RSZ(R5) ;STORE RECORD SIZE (INCLUDE FORMFEED)
	MOVAB	W^MAC$AB_HD_NEWPG,RAB$L_RBF(R5) ;AND RECORD ADDRESS
	BSBB	60$			;WRITE FIRST LINE OF NEW PAGE
	MOVW	#MAC$K_SBT_SIZ,RAB$W_RSZ(R5) ;LENGTH OF SUBTITLE LINE
	MOVAB	W^MAC$AB_SBT_IDNT,RAB$L_RBF(R5) ;AND ADDRESS
	BSBB	60$			;WRITE SUBTITLE LINE
	CLRW	RAB$W_RSZ(R5)		;WRITE BLANK LINE
	BSBB	60$			;...
30$:	POPL	W^MAC$GL_LIST_PTR	;RESTORE LISTING POINTER
40$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS
50$:	RSB
;
; WRITE LINE TO LISTING -- R5 POINTS TO RAB
;
60$:	BBC	#FLG$V_LSTXST,(R11),70$	;BRANCH IF LISTING DISABLED
	$PUT	RAB=(R5),ERR=W^MAC$ERR_PUT ;WRITE LINE TO LISTING
	BLBS	R0,70$			;BRANCH IF GOOD PUT
	BSBW	MAC$CLOSE_LIST		;ELSE CLOSE THE LISTING FILE
70$:	RSB

	.SBTTL	MAC$DEC_OUT_R2L OUTPUT DECIMAL NUMBER TO LISTING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS A 5 DIGIT OR LESS DECIMAL NUMBER
;	TO THE LISTING FILE (IN REVERSE)
;
; INPUTS:
;
;	R0	NUMBER TO OUTPUT
;
;--

MAC$DEC_OUT_R2L::
	PUSHR	#^M<R3,R4,R5>		;SAVE REGISTERS
	CMPL	R0,#99999		;CHECK FOR NUMBER TOO LARGE
	BLEQU	10$			;IF LEQ NUMBER IS OK
	MOVL	#99999,R0		;ELSE USE THE MAXIMUM
10$:	MOVZWL	R0,R4			;SET UP FOR THE EDIV
	CLRL	R5			;CLEAR HIGH LONGWORD
20$:	EDIV	#10,R4,R4,R0		;DO A DIVISION BY 10
	ADDB2	#^A/0/,R0		;CONVERT DIGIT TO ASCII
	BSBB	MAC$LST_CHAR		;OUTPUT DIGIT TO LISTING BUFFER
	TSTL	R4			;ARE WE DONE?
	BNEQ	20$			;IF NEQ NO
	POPR	#^M<R3,R4,R5>		;YES--RESTORE REGISTERS
	RSB				;EXIT

	.SBTTL	MAC$DEC_OUT_L2X	OUTPUT DECIMAL NUMBER LEFT TO RIGHT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS A DECIMAL NUMBER LEFT-TO-RIGHT.
;
; INPUTS:
;
;	R0	NUMBER TO CONVERT
;	R1	OUTPUT POINTER
; OUTPUTS:
;
;	R0	UPDATED OUTPUT POINTER
;
;--

MAC$DEC_OUT_L2X::
	PUSHR	#^M<R3,R4,R5,R6>	;SAVE REGISTERS
	MOVL	R1,R6			;SET OUTPUT POINTER
	MOVL	R0,R4			;AND NUMBER TO PRINT
	CLRL	R5			;CLEAR HI WORD
	BSBB	DEC_OUT			;CONVERT AND OUTPUT THE NUMBER
	MOVL	R6,R0			;SET UPDATED POINTER
	POPR	#^M<R3,R4,R5,R6>	;RESTORE REGISTERS
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS A 5 DIGIT DECIMAL NUMBER IN R0 TO
;	THE LISTING FILE LEFT-TO-RIGHT.
;
;--

MAC$DEC_OUT_L2R::
	PUSHR	#^M<R3,R4,R5,R6>	;SAVE REGISTERS
	MOVL	R0,R4			;COPY THE NUMBER
	CLRL	R5			;CLEAR HIGH WORD
	MOVL	W^MAC$GL_LIST_PTR,R6	;GET THE LISTING POINTER
	BSBB	DEC_OUT			;DO THE DIVISION
	MOVL	R6,W^MAC$GL_LIST_PTR	;UPDATE LISTING POINTER
	POPR	#^M<R3,R4,R5,R6>	;RESTORE REGISTERS
	RSB

DEC_OUT:
	EDIV	#10,R4,R4,R0		;DIVIDE EM UP
	ADDB3	#^A/0/,R0,-(SP)		;CONVERT REMAINDER TO ASCII AND STACK IT
	TSTL	R4			;ARE WE DONE?
	BEQL	20$			;IF EQL YES
	BSBB	DEC_OUT			;NO--RECURSE
20$:	MOVB	(SP)+,(R6)+		;GET DIGIT BACK AND STORE IT
	RSB				;RECURSE OR RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	WRITE THE CHARACTER IN R0 INTO THE LISTING BUFFER FROM
;	RIGHT TO LEFT.  THE POINTER INTO THE LISTING BUFFER IS
;	DECREMENTED FIRST.
;
;--

MAC$LST_CHAR::
	DECL	W^MAC$GL_LIST_PTR	;BACK UP THE POINTER
	MOVB	R0,@W^MAC$GL_LIST_PTR	;PUT CHARACTER INTO LINE BUFFER
	RSB

	.SBTTL	TERMINAL OUTPUT ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PRINTS THE LINE CONTAINED IN MAC$AB_LINEBF
;	AND MAC$AB_LST_END.  THE LENGTH OF THE LINE IS CALCULATED
;	AND THE LINE IS OUTPUT.
;
;--

MAC$TERM_BLANK::
	CLRL	R0			;ZERO FOR BLANK LINE
	MOVL	SP,R1			;SHOULDN'T MATTER WHERE IT IS
	BRB	MAC$PUT_TERM		;GO OUTPUT AND RETURN
MAC$WRITE_TERM::
	ADDW3	W^MAC$GL_LINELN,#MAC$K_LIST_SIZE,R0 ;COMPUTE SIZE OF LINE
	MOVAB	L^MAC$AB_LST_END,R1	;GET ADDRESS OF BUFFER

MAC$PUT_TERM::
	PUSHL	R2			;SAVE R2
	MOVAB	L^MAC$TERM_RAB,R2	;GET ADDRESS OF TERMINAL RAB
	MOVW	R0,RAB$W_RSZ(R2)	;SET THE RECORD SIZE IN THE RAB
	MOVL	R1,RAB$L_RBF(R2)	;SET THE RECORD ADDRESS
	$PUT	RAB=(R2),-		;WRITE THE LINE TO THE TERMINAL
		ERR=W^MAC$ERR_PUT
	POPL	R2			;RESTORE R2
	RSB

	.END
