	.TITLE	MAC$ACTREF OPERAND REFERENCES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V02.18	MTR0001		Mike Rhodes	28-Oct-1981
;		Fix immediate mode H-Float short literal optimization/
;		generation code.  Also fixed broken BRBs to BRWs.
;
;	V02.17	PCG0011		Peter George	12-Oct-1981
;		The previous fix only handles explicit short literals.
;		Now extend that code to cover implicit short literals.
;
;	V02.16	PCG0010		Peter George	08-Sep-1981
;		Correct generation of short floating point literals.
;
;	V02.15	CNH0042		Chris Hume	 1-Dec-1980
;		De-optimize boundary valued backward references if indexing
;		requested.  Allow the architecturally legal immediate mode in
;		address and vield contexts and also the practically useless
;		indexed immediate mode.
;		(ACTSTA.MAR 02.15, DEFINE.MAR 02.17, SYMTAB.MAR 02.18)
;
;	V01.14	RN0030		R. Newland	17-Mar-1980
;		In explicit PC relative addressing test for displacement
;		expression being absolute.  SPR 11-29354
;
;	V01.13	RN0029		R. Newland	 9-Mar-1980
;		In relative and relative deferred references always
;		optimize if displacement is known, and use default
;		displacement if not known. SPR 11-29062
;
;	V01.12	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.11	RN0019		R. Newland	25-Oct-1979
;		Improve error pointer positioning
;
;	V01.10	RN0017		R. Newland	20-Oct-1979
;		Support for G_floating, H_floating and Octaword data types.
;		Check all bits of operand for optimisation test.
;
;	V01.08	RN0014		R. Newland	14-Oct-1979
;		Support for .REF16 directive
;
;	V01.07	RN0005		R. Newland	12-Aug-1979
;		Remove .ALIGN LONG statements
;
;	V01.09	RN0017		R. Newland	20-Oct-1979
;		Fix problem with optimising a quadword literal when
;		bits 0-31 were all zero.
;
;	V01.08	RN0016		R. Newland	19-Oct-1979
;		Don't output error messages when .NTYPE operand
;		argument is the PC.  SPR 11-26392
;
;	V01.06	007		B. SCHREIBER	22-JAN-79
;		Fix problem with negative displacement from PC.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_ADRMODDEF			;DEFINE ADDRESSING MODES
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_INTCODDEF			;DEFINE INT. FILE CODES
	$MAC_OPRDEF			; Define operand descriptor bits
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;


	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG

PC_DISPL_DISP:				;JUMP TABLE USED WHEN
					;.DEFAULT HAS BEEN SPECIFIED
					;FOR PC-DISPLACMENT REFS
	.LONG	0			;0--NOT USED
	.LONG	DISPL3			;1--BYTE DISPLACEMENT
	.LONG	DISPL5			;2--WORD DISPLACEMENT
	.LONG	DISPL4			;3--LONGWORD DISPLACEMENT

;++
; OPERANDS OF MACHINE INSTRUCTIONS ARE SPECIFIED BY REFERENCES.  BEFORE
; THESE ROUTINES ARE CALLED, THE FOLLOWING FLAGS MUST BE SET:
;
;	MAC$GL_OPSIZE	SIZE OF OPERAND IN BYTES (DEPENDS ON INSTRUCTION)
;
;	MAC$GL_REFSIZ	USER SUPPLIED REF WIDTH (IE MOVL ^S#1,R0)
;			THIS VALUE MUST BE SET TO THE DEFAULT SIZE
;			IF THE USER SPECIFIED NO WIDTH.
;
;
; THESE ROUTINES GENERATE INTERMEDIATE CODE SPECIFYING THE MODE(S)
; AND REGISTER(S) USED BY THE REFERENCE.
;
; THE RESULTS ARE RETURNED AS FOLLOWS:
;
;	MAC$GB_VAL1	MAC$GB_MODE	MODE OF OPERAND
;	MAC$GB_VAL2	MAC$GB_IMODE	('E' MODE IF INDEX MODE)
;	MAC$GB_VAL3	MAC$GB_REG	(REGISTER USED BY OPERAND)
;	MAC$GB_VAL4	MAC$GB_IREG	('E' REGISTER IF INDEX MODE)
;
; THE VALUE OF 'MAC$GL_PC' IS UPDATED BY THE SIZE OF THE REFERENCE
; AND THE ASSOCIATED VALUES, IF ANY.
;
;--

	.SBTTL	REFERENCE DIRECTIVE ROUTINES (.REFn)

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED AFTER A REFERENCE DIRECTIVE HAS
;	BEEN PROCESSED.  THE ROUTINES RFHD1/2/4/8/16 SET UP THE
;	INFORMATION, THE REFERENCE IS THEN PARSED, AND DIRREF
;	IS THEN CALLED TO FINISH THE PRODUCTION.  THE REFERENCE
;	IS EMITTED TO THE INTERMEDIATE FILE.
;
;--

DIRREF::				;DIRECTIVE = REF_HEAD REF
	$INTOUT_LW INT$_REF,<W^MAC$GL_VALUE,W^MAC$GL_OPSIZE> ;OUTPUT REFERENCE
	CMPB	W^MAC$GL_OPSIZE,#8	;QUADWORD REFERENCE?
	BNEQ	10$			;IF NEQ NO
	CMPB	W^MAC$GB_VAL1,#ADM$_IMMEDIATE ;YES--IMMEDIATE?
	BNEQ	10$			;IF NEQ NO
	$INTOUT_LW INT$_STIL,<W^MAC$GL_VAL3> ;YES--STORE UPPER 32 BITS
10$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES (RFHD1/2/4/8) ARE INVOKED WHEN A REFERENCE
;	DIRECTIVE IS ENCOUNTERED.  RFHDX SET THE SIZE OF THE OPERAND
;	AND INITIALIZE STORAGE FOR PARSING THE EXPRESSION TO FOLLOW.
;
;--

RFHD1::					;REF_HEAD = KREF1
	BSBB	RFHD			;GO TO COMMON ROUTINE
	.BYTE	1			;OPERAND SIZE IS ONE BYTE

RFHD2::					;REF_HEAD = KREF2
	BSBB	RFHD			;GO TO COMMON ROUTINE
	.BYTE	2			;SIZE OF OPERAND IS 2 BYTES

RFHD4::					;REF_HEAD = KREF4
	BSBB	RFHD			;GO TO COMMON ROUTINE
	.BYTE	4			;SIZE OF OPERAND IS 4 BYTES

RFHD8::					;REF_HEAD = KREF8
	BSBB	RFHD			;GO TO COMMON ROUTINE
	.BYTE	8			;SIZE OF OPERAND IS 8 BYTES

RFHD16::				;REF_HEAD = KREF16
	BSBB	RFHD			;GOTO COMMON ROUTINE
	.BYTE	16			;SIZE OF OPERAND IS 16 BYTES

RFHD:
	MOVZBL	@(SP)+,W^MAC$GL_OPSIZE	;SET OPERAND SIZE
	MOVAB	W^MAC$GK_ZERO,W^MAC$GL_MOPPTR ;ALL MODES ARE LEGAL
	CLRL	W^MAC$GB_MODE		;CLEAR MODE,IMODE,REG,IREG
	BISL2	#FLG$M_EVALEXPR!FLG$M_COMPEXPR,- ;EVALUATE EXPRESSION
			(R11)			 ;AND ASSUME COMPILE TIME EXPR
	RSB				;RETURN TO CALLER'S CALLER

	.SBTTL	OPERAND REFERENCE ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	REF1 AND REF3 ARE INVOKED WHEN A BASIC REFERENCE OR
;	AN INDEX REFERENCE IS PROCESSED TO COPY THE MODE AND
;	REGISTER VALUES INTO MAC$GB_VAL1-MAC$GB_VAL4.
;
;--

REF1::					;REF = BASIC_REF
REF3::					;REF = INDEX_REF
REF_EXIT:				;GENERAL REF EXIT
	MOVL	W^MAC$GB_MODE,W^MAC$GB_VAL1 ;ENCODE MODES AND REGISTERS
					    ;INTO GB_VAL1-GB_VAL4
AUTOI::					;BASIC_REF = AUTO_INC
DISP::					;BASIC_REF = DISPLACEMENT
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	REF2 IS INVOKED WHEN A BASIC REGISTER REFERENCE IS ENCOUNTERED.
;	THE MODE (REGISTER MODE) IS ENCODED INTO MAC$GB_MODE, AND THE
;	REGISTER NUMBER IS SET IN MAC$GB_REG.  THE FINAL RESULTS ARE
;	THEN ENCODED INTO MAC$GB_VAL1-MAC$GB_VAL4.
;
; INPUTS:
;
;	MAC$GB_VAL1	REGISTER NUMBER
;
; OUTPUTS:
;
;	MAC$GB_MODE	SET TO 'ADM$_REGISTER'
;	MAC$GB_REG	REGISTER NUMBER
;	MAC$GB_VAL1-VAL4 ENCODED MODES AND REGISTERS
;
;--

REF2::					;REF = RRREG
	MOVB	#ADM$_REGISTER,W^MAC$GB_MODE ;MODE IS REGISTER MODE
	MOVB	W^MAC$GB_VAL1,W^MAC$GB_REG ;GET REGISTER VALUE
	BSBB	ILL_REG_CHK		;CHECK FOR ILLEGAL PC USAGE
	BRB	REF_EXIT		;FINISH UP

	.SBTTL	DEFERRED REGISTER MODE OPERAND

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN A DEFERRED REGISTER MODE OPERAND
;	IS ENCOUNTERED.  THE MODE IS SET TO INDIRECT REGISTER, AND
;	THE REGISTER NUMBER IS STORED.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-4[R7]	REGISTER NUMBER
;
; OUTPUTS:
;
;	MAC$GB_MODE		'ADM$_RRIND'--INDIRECT REGISTER MODE
;	MAC$GB_REG		REGISTER NUMBER
;
;--

RDEFER::				;BASIC_REF = DOPN RRREG DCLS
	MOVB	#ADM$_RRIND,W^MAC$GB_MODE ;SET MODE AS INDIRECT REG
	CVTLB	W^MAC$AL_VALSTACK-4[R7],- ;STORE REGISTER NUMBER
			W^MAC$GB_REG
	BRB	ILL_REG_CHK		;CHECK ILLEGAL PC AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN THE PRODUCTION 'DAT AUTO_INC'
;	IS FOUND IN THE TEXT.  IF LITERAL MODE IS USED IT IS FORCED
;	TO IMMEDIATE LONGWORD.  THE MODE IS SET AS ABSOLUTE.
;
;--

AUTOII::				;BASIC_REF = DAT AUTO_INC
	BSBW	SPESHL_MODE_CHK		;FORCE LONGWORD TO IMMEDIATE
	BSBW	SPESHL_MODE_CHK		;FORCE LONGWORD CONTEXT
	INCB	W^MAC$GB_MODE		;MAKE INDIRECT MODE
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN AN AUTO-DECREMENT ADDRESSING MODE
;	IS ENCOUNTERED.  THE MODE AND REGISTER ARE SET UP, AND A CHECK
;	IS MADE FOR ILLEGAL USE OF 'PC'.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-4[R7]	REGISTER NUMBER
;
; OUTPUTS:
;
;	MAC$GB_MODE		'ADM$_REGAUTODEC'
;	MAC$GB_REG		REGISTER NUMBER
;
;--

AUTODC::				;BASIC_REF = DMINUS DOPN RRREG DCLS
	MOVB	#ADM$_REGAUTODEC,W^MAC$GB_MODE ;SET MODE
	CVTLB	W^MAC$AL_VALSTACK-4[R7],- ;PICK UP REGISTER NUMBER
			W^MAC$GB_REG
	BRB	ILL_REG_CHK		;CHECK ILLEGAL REGISTER AND RETURN

	.SBTTL	INDIRECT DISPLACEMENT REFERENCES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES INDIRECT DISPLACEMENT REFERENCES.
;	ABSOLUTE AND PIC MODES ARE CHANGED TO LONGWORD DISPLACEMENT,
;	LONGWORD DISPLACEMENTS ARE FORCE TO IMMEDIATE LONGWORD
;	CONTEXT. THE MODE IS THEN SET TO DEFERRED DISPLACEMENT MODE.
;
; INPUTS:
;
;	MAC$GB_MODE		MODE OF DISPLACEMENT
;
; OUTPUTS:
;
;	MAC$GB_MODE		DEFERRED DISPLACEMENT MODE
;	MAC$GL_PC		UPDATED IF NECESSARY
;
;--

DISPI::					;BASIC_REF = DAT DISPLACEMENT
	MOVAB	W^MAC$GB_MODE,R0	;GET ADDRESS OF MODE
	CMPB	(R0),#ADM$_ABSOLUTE	;ABSOLUTE MODE?
	BNEQ	20$			;IF NEQ NO
10$:	MOVB	#ADM$_LONG_DISP,(R0)	;YES--FORCE LONGWORD DISPLACEMENT
	BRB	30$
20$:	CMPB	(R0),#ADM$_PIC		;PIC CODE?
	BEQL	10$			;IF EQL YES
	CMPB	(R0),#ADM$_RRIND	;IF (R) THEN DE-OPTIMIZE
	BNEQ	30$			;NOT (R)
	$INC_PC				;ONE MORE BYTE
	MOVB	#ADM$_BYTE_DISP,(R0)	;USE BYTE DISPLACEMENT
30$:	BSBW	SPESHL_MODE_CHK		;CHECK MODES FOR DEFERRAL
	INCB	W^MAC$GB_MODE		;MAKE DEFERRED DISPLACEMENT
	RSB

	.SBTTL	CHECK FOR ILLEGAL USE OF PC

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS FOR ILLEGAL USE OF PC.  IF THE REGISTER
;	IS PC, AN ERROR MESSAGE IS SENT TO PASS 2.  THE LOCATION COUNTER
;	IS BUMPED BY 1.
;
; INPUTS:
;
;	MAC$GB_REG		REGISTER IN QUESTION
;	MAC$GB_MODE		CURRENT MODE
;
; OUTPUTS:
;
;	MAC$GL_PC		INCREMENTED BY 1
;
;--

ILL_REG_CHK:
	CMPB	W^MAC$GB_REG,#REG$_PC	;'PC' IS ILLEGAL REGISTER HERE
	BNEQ	10$			;IF NEQ THEN LEGAL REGISTER
	BBSC	#FLG$V_NTYPEPC,(R11),10$ ; If .NTYPE directive no error
	$MAC_ERR ILLREGHERE		; Load message code
	CMPB	W^MAC$GB_MODE,#ADM$_REGISTER ; Is addressing mode register?
	BNEQ	5$			; No if NEQ
	BSBW	MAC$ERRORPX		; Send error to pass-2
	BRB	10$
5$:
	BSBW	MAC$ERRORPT		;SEND ERROR TO PASS2
10$:	$INC_PC				;ADD ONE TO LOCATION COUNTER
	RSB

	.SBTTL	DISPLACEMENT REFERENCES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES DISPLACEMENTS OFF OF A SPECIFIC
;	REGISTER.  IF THE REGISTER IS 'PC', THE OPERAND IS 
;	TREATED AS 'EXPR'.  IF THE VALUE OF THE EXPRESSION IS 0
;	AND WE CAN OPTIMIZE EXPRESSION, THE CODE FOR THE EXPRESSION
;	IS DELETED FROM THE INTERMEDIATE BUFFER.  THE DISPLACEMENT
;	IS SET TO BYTE, WORD, OR LONGWORD WITH WORD DISPLACEMENT
;	THE DEFAULT.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-12[R7]		EXPRESSION VALUE TO CONSIDER
;	MAC$AL-VALSTACK-4[R7]		REGISTER BEING DISPLACED
;
; OUTPUTS:
;
;	MAC$GB_MODE			SET WITH CORRECT MODE
;	MAC$GL_PC			UPDATED BY SIZE OF OPERAND
;
;--

DISPL1::				;DISPLACEMENT = EXPR DOPN RRREG DCLS
	MOVL	W^MAC$AL_VALSTACK-12[R7],R1 ;GET EXPRESSION TO OPTIMIZE
	MOVL	R1,R6			;COPY VALUE IN CASE REGISTER IS PC
	MOVL	W^MAC$AL_VALSTACK-4[R7],R2	;GET REGISTER BEING DISPLACED
	MOVB	R2,W^MAC$GB_REG		;STORE FOR WORLD TO SEE
	CMPB	R2,#REG$_PC		;IS REGISTER 'PC'?
	BNEQ	5$			; No if NEQ
	TSTL	W^MAC$GL_ABSFLAG	; Is expression absolute?
	BEQL	5$			; Yes if EQL
	BRW	DISPPC
5$:
	MOVL	R1,W^MAC$GL_EXPOPVL1	;LOAD EXPR VALUE
	MOVB	#ADM$_WORD_DISP,W^MAC$GB_MODE ;SET DEFAULT DISPLACEMENT
	MOVZBL	#3,R6			;DEFAULT IS 3 BYTES LONG
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BEQL	10$			;IF EQL YES
	BICL2	#FLG$M_COMPEXPR,(R11)	;NO--NOT COMPILE TIME EXPRESSION
	BITL	#^XFFFF0000,R1		;REQUIRE LONGWORD?
	BEQL	50$			;IF EQL NO--LINKER MAY COMPLAIN THO
	BRB	40$			;YES--SET LONGWORD AND EXIT
10$:	TSTL	R1			;VALUE 0?
	BNEQ	20$			;IF NEQ NO
	BBC	#FLG$V_EXPOPT,(R11),20$	;BRANCH IF CANNOT OPTIMIZE EXPR
	BSBW	MAC$OPTIMIZEXPR		;WE CAN--WIPE OUT EXPRESSION
	MOVL	R9,W^MAC$GL_EXPEND	;SET NEW END OF EXPR POINTER
	BRW	W^RDEFER		;USE REGISTER DEFERRED MODE
20$:	bgeq	30$			; If negative
	mcoml	r1,r1			; then make it positive magnitude.
30$:	cmpl	r1,#^x7fff		; Byte or Word Displacement?
	bgtru	40$			; If GTRU no.
	cmpl	r1,#^x7f		; Yes:  Byte Displacement?
	bgtru	50$			; If GTRU no:  Word Disp. and PC OK.
	movb	#ADM$_BYTE_DISP,w^MAC$GB_MODE ; Yes:  Set Byte Displacement.
	MOVZBL	#2,R6			;2 BYTE OPERAND
	BRB	50$
40$:	MOVB	#ADM$_LONG_DISP,W^MAC$GB_MODE ;SET LONGWORD DISPLACEMENT
	MOVZBL	#5,R6			;5 BYTES FOR OPERAND
50$:	$INC_PC	R6			;UPDATE LOCATION COUNTER
	CMPB	W^MAC$GB_REG,#REG$_PC	; Is reference from PC?
	BNEQ	60$			; No if NEQ
	ADDL2	W^MAC$GL_PC,W^MAC$GL_EXPOPVL1 ; Send expression value to pass-2
					; with PC added in, it will be subtracted
					; by pass-2.
60$:
	RSB

	.SBTTL	DISPLACEMENT OFF 'PC'

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN A DISPLACEMENT OF THE FORM
;	'EXPR' IS ENCOUNTERED.  THE CORRECT SIZE OF THE DISPLACEMENT
;	IS DETERMINED AND THE MODE IS SET AND THE PC IS UPDATED.
;
; INPUTS:
;
;	MAC$AL_VALSTACK[R7]	VALUE OF EXPRESSION
;
; OUTPUTS:
;
;	MAC$GB_MODE		SET TO CORRECT MODE
;	MAC$GL_EXPOPVL1		SET TO VALUE OF EXPRESSION
;	MAC$GL_PC		UPDATED BY SIZE OF OPERAND
;
;--

DISPL2::				;DISPLACEMENT = EXPR
	BLBC	W^ENB$G_ABSADDR+SYM$L_VAL,10$ ;BRANCH IF NOT ENABLE AMA
	BSBW	AINC2			;YES--TREAT AS IMMEDIATE
	BRW	AUTOII			;THEN MAKE ABSOLUTE AND EXIT
10$:	MOVL	W^MAC$AL_VALSTACK[R7],R6 ;GET VALUE
	MOVB	#REG$_PC,W^MAC$GB_REG	;SET PC AS REGISTER
DISPPC:	MOVL	R6,W^MAC$GL_EXPOPVL1	;COPY VALUE
	CLRL	R1			; Initialise absolute flag
	TSTL	W^MAC$GL_ABSFLAG	; Absolute expression?
	BNEQ	1$			; No if NEQ
	INCL	R1			; Set flag for later
	BRB	5$
1$:
	BBS	#FLG$V_COMPEXPR,(R11),5$ ; Branch if compile time expression
2$:
	MOVL	W^MAC$GL_DFPC_DSP,R0	;GET THE DISPLACEMENT FROM .DEFAULT
	BNEQ	3$			; Branch if has been specified
	MOVL	#3,R0			; Use 'longword' displacment as default
3$:
	ADDL2	#4,R7			;FAKE UP STACK FRAME
	MOVL	#REG$_PC,W^MAC$AL_VALSTACK-4[R7] ;SET REGISTER
	MOVL	R6,W^MAC$AL_VALSTACK-12[R7] ;AND VALUE
	MOVL	W^PC_DISPL_DISP[R0],R0	;GET THE ROUTINE ADDRESS
	JSB	(R0)			;GO TO  DISPL3/4/5
	SUBL2	#4,R7			;ADJUST STACK
	RSB				;DONE
5$:	MOVB	#ADM$_LONG_DISP,W^MAC$GB_MODE ;SET DEFAULT MODE
	MOVZBL	#1,R4			;INC/DEC VALUE FOR PC
	$INC_PC	#2			;OPERAND IS AT LEAST 2 BYTES
	BLBS	R1,50$			; Branch if expression was not absolute
;
; EXPRESSION CAN BE OPTIMIZED
;
	SUBL2	W^MAC$GL_PC,R6		;GET DISPLACEMENT
	bgeq	10$			; Branch if positive displacement
	mnegl	r4,r4			; Need to add one if not Byte
	mcoml	r6,r6			; Get positive magnitude -1
10$:	cmpl	r6,#^x7f		; Byte Displacement?
	bgtru	20$			; If greater in magnitude:  No.
	bnequ	15$			; Flag at boundary in case of indexing.
	tstl	r4			; If forward ref. indexing is no prob.
	bgeq	15$
	bbss	#FLG$V_OPTVFLIDX,(r11),15$
15$:	movb	#ADM$_BYTE_DISP,w^MAC$GB_MODE ; Yes:  Set Byte Displacement,
	brb	60$			; PC is correct now.
20$:	subl2	r4,r6			; Include extra byte in displacement.
	cmpl	r6,#^x7fff		; Word Displacement?
	bgtru	30$			; If greater in magnitude:  No.
	bnequ	25$			; Flag at boundary in case of indexing.
	tstl	r4			; If forward ref. indexing is no prob.
	bgeq	25$
	bbss	#FLG$V_OPTVFLIDX,(r11),25$
25$:	movb	#ADM$_WORD_DISP,w^MAC$GB_MODE ; Yes:  Set Word Displacement,
	movzbl	#1,r4			; Update PC by one.
	brb	40$
30$:	movzbl	#3,r4			; Longword:  update PC by 3.
40$:	$INC_PC	R4			;UPDATE LOCATION COUNTER
	BRB	60$
;
; Not compile time expression (not Absolute)
;
50$:	BICL2	#FLG$M_COMPEXPR,(R11)	;FLAG NOT COMPILE TIME EXPRESSION
	$INC_PC #3			;UPDATE PC FOR DEFAULT LONGWORD
60$:	RSB

	.SBTTL	EXPLICIT DISPLACEMENTS AND PIC REFERENCES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES (DISPL3/4/5) ARE INVOKED WHEN AN EXPLICIT
;	DISPLACEMENT REFERENCE IS ENCOUNTERED.  THE CORRECT MODE
;	IS SET, THE REGISTER IS SET, AND THE PC IS UPDATED BY
;	THE SIZE OF THE OPERAND.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-4[R7]	REGISTER VALUE
;	MAC$AL_VALSTACK-12[R7]	EXPRESSION VALUE
;
; OUTPUTS:
;
;	MAC$GB_MODE		SET TO CORRECT MODE
;	MAC$GB_REG		SET TO REGISTER
;	MAC$GL_PC		UPDATED BY SIZE OF OPERAND
;
;--

	.ENABL	LSB

DISPL3::				;DISPLACEMENT = DBUP EXPR DOPN RRREG DCLS
	MOVZBL	#ADM$_BYTE_DISP,R0	;SET BYTE DISPLACEMENT
	MOVZBL	#2,R1			;LENGTH OF OPERAND
	BRB	10$

DISPL4::				;DISPLACEMENT = DLUP EXPR DOPN RRREG DCLS
	MOVZBL	#ADM$_LONG_DISP,R0	;SET LONGWORD DISPLACEMENT
	MOVZBL	#5,R1			;LENGTH OF OPERAND
	BRB	10$

DISPL5::				;DISPLACEMENT = DWUP EXPR DOPN RRREG DCLS
	MOVZBL	#ADM$_WORD_DISP,R0	;SET WORD DISPLACEMENT
	MOVZBL	#3,R1			;LENGTH OF OPERAND
10$:	CVTLB	W^MAC$AL_VALSTACK-4[R7],- ;GET THE REGISTER VALUE
			W^MAC$GB_REG
	MOVL	W^MAC$AL_VALSTACK-12[R7],- ;COPY EXPRESSION VALUE
			W^MAC$GL_EXPOPVL1
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BEQL	20$			;IF EQL YES
	BICL2	#FLG$M_COMPEXPR,(R11)	;ELSE NOT COMPILE TIME EXPRESSION
DISPLX_EXIT:
20$:	MOVB	R0,W^MAC$GB_MODE	;SET MODE OF OPERAND
	$INC_PC	R1			;UPDATE PC BY SIZE OF OPERAND
	RSB

	.DSABL	LSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES (DISPL6/7/8 AND GENLDS) ARE INVOKED WHEN
;	A SPECIFIC SIZE DISPLACEMENT REFERENCE OR A SPECIFIC PIC
;	REFERENCE IS ENCOUNTERED.  THE REGISTER IS SET TO 'PC',
;	AND THE PC IS UPDATED BY THE SIZE OF THE OPERAND.
;
; INPUTS:
;
;	MAC$AL_VALSTACK[R7]	EXPRESSION VALUE
;
; OUTPUTS:
;
;	MAC$GB_MODE		SET TO MODE
;	MAC$GB_REG		SET TO 'PC' (15.)
;	MAC$GL_PC		UPDATED BY SIZE OF OPERAND
;	MAC$GL_EXPOPVL1		SET TO VALUE OF EXPRESSION
;
;--

	.ENABL	LSB

DISPL6::				;DISPLACEMENT = DBUP EXPR
	MOVZBL	#ADM$_BYTE_DISP,R0	;SET BYTE DISPLACEMENT
	MOVZBL	#2,R1			;SET SIZE OF OPERAND
	BRB	10$

DISPL7::				;DISPLACEMENT = DLUP EXPR
	MOVZBL	#ADM$_LONG_DISP,R0	;SET LONGWORD DISPLACEMENT
	MOVZBL	#5,R1			;SIZE IS 5 BYTES
	BRB	10$

DISPL8::				;DISPLACEMENT = DWUP EXPR
	MOVZBL	#ADM$_WORD_DISP,R0	;SET WORD DISPLACEMENT
	MOVZBL	#3,R1			;SIZE IS 3 BYTES
	BRB	10$			;

GENLDS::				;DISPLACEMENT = DGUP EXPR
	MOVZBL	#ADM$_PIC,R0		;SET PIC MODE
	MOVZBL	#5,R1			;LENGTH IS 5 BYTES
10$:	MOVB	#REG$_PC,W^MAC$GB_REG	;SET REGISTER TO PC
	MOVL	W^MAC$AL_VALSTACK[R7],-	;COPY EXPRESSION
			W^MAC$GL_EXPOPVL1
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BNEQ	DISPLX_EXIT		;IF NEQ NO--GO FINISH UP
	BICL2	#FLG$M_COMPEXPR,(R11)	;YES--ABS REQUIRES LINKER ACTION
	BRB	DISPLX_EXIT		;GO EXIT

	.DSABL	LSB

	.SBTTL	LITERAL MODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN A LITERAL REFERENCE IS SCANNED.
;	IF THE OPERAND IS A FLOATING POINT OPERAND, IT IS CONVERTED
;	TO A SHORT FLOATING LITERAL.
;
; INPUTS:
;
;	MAC$AL_VALSTACK[R7]	VALUE OF EXPRESSION
;
;--

LITERL::				;REF = DSUP DPOUND EXPR
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE?
	BEQL	10$			;IF EQL YES
	BBCC	#FLG$V_EXPOPT,(R11),10$	;NO--DO NOT ALLOW OPTIMIZATION
10$:	MOVB	#ADM$_LITERAL,W^MAC$GB_MODE ;SET LITERAL MODE
	$INC_PC				;COUNT 1 BYTE
	MOVL	W^MAC$AL_VALSTACK[R7],-	;COPY THE VALUE
			W^MAC$GL_EXPOPVL1
	CMPB	W^MAC$GB_RDXNDX,-	;READING FLT. PT.?
		#RDX$V_FLOAT 
	BLSSU	40$			;IF LESS THEN NO
	MOVL	W^MAC$GL_EXPOPVL1,R0	;MOVE FLOATING PT. NUMBER INTO R0
	CMPB	W^MAC$GB_RDXNDX,-	;H FLOAT?
		#RDX$V_HFLOAT
	BNEQ	20$			;NO, THEN SKIP TO OTHER FLT. PT. CODE
	EXTZV	#29,#3,R0,R1		;GET FRACTION
	EXTZV	#0,#3,R0,R2		;GET EXPONENT
	INSV	R2,#3,#3,R1		;COMBINE THEM
	MOVZBL	R1,W^MAC$GL_EXPOPVL1	;STORE RESULT
	BRB	40$			;DONE
20$:	CMPB	W^MAC$GB_RDXNDX,-	;G FLOAT?
		#RDX$V_GFLOAT
	BNEQ	30$			;NO, SKIP TO F AND D FLOAT COMMON CODE
	EXTZV	#1,#6,R0,-		;YES, STORE RESULT
		W^MAC$GL_EXPOPVL1
	BRB	40$
30$:	EXTZV	#4,#6,R0,-		;F OR D FLOAT, STORE RESULT
		W^MAC$GL_EXPOPVL1
40$:	BRW	REF_EXIT		;EXIT FROM REFERENCE

	.SBTTL	AUTO-INCREMENT MODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN AN AUTO-INCREMENT REFERENCE IS
;	SCANNED.  THE MODE AND REGISTER ARE SET, AND A CHECK IS MADE
;	FOR AN ILLEGAL REGISTER REFERENCE.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-8[R7]	RESGISTER NUMBER
;
; OUTPUTS:
;
;	MAC$GB_MODE		'ADM$_REGAUTOINC'
;	MAC$GB_REG		SET TO REGISTER
;
;--

AINC1::					;AUTO_INC = DOPN RRREG DCLS DPLUS

	MOVB	#ADM$_REGAUTOINC,W^MAC$GB_MODE ;SET MODE
	CVTLB	W^MAC$AL_VALSTACK-8[R7],- ;GET REGISTER NUMBER
			W^MAC$GB_REG
	BRW	ILL_REG_CHK		;CHK REG ERROR AND RETURN

	.SBTTL	IMMEDIATE MODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN AN IMMEDATE REFERENCE IS SCANNED.
;	(ALSO FOR AUTO-INCRMENT OF PC [#EXPR]).
;
;--

AINC3::					;BASIC_REF = DIUP DPOUND EXPR
	MOVZBL	#1,W^MAC$GL_ABSFLAG	;DO NOT ALLOW OPTIMIZATION

	.SBTTL	AUTO-INCREMENT PC

AINC2::					;AUTO_INC = DPOUND DEXPR
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BEQL	10$			;IF EQL YES
	BBCC	#FLG$V_EXPOPT,(R11),10$	;NO--DO NOT ALLOW OPTIMIZATION
10$:	MOVAB	W^MAC$GL_EXPOPVL1,R6	;POINT TO RESULT
	MOVL	W^MAC$AL_VALSTACK[R7],(R6) ;SET RESULT
	TSTL	W^MAC$GL_ABSFLAG	;ABSOULTE EXPRESSION?
	BNEQ	17$			;IF NEQ NO
	CMPB	W^MAC$GL_OPSIZE,#16	; Is operand octaword?
	BNEQ	12$			; No if NEQ
	TSTL	W^MAC$GQ_HIGH_64+4	; Are bits 96-127 all zero?
	BNEQ	17$			; No if NEQ
	TSTL	W^MAC$GQ_HIGH_64+0	; Are bits 64-95 all zero?
	BNEQ	17$			; No if NEQ
	BRB	14$
12$:
	CMPB	W^MAC$GL_OPSIZE,#8	; Is operand quadword?
	BNEQ	16$			; No if NEQ?
14$:
	TSTL	W^MAC$GL_HIGH_32	; Are bits 32-63 all zero?
	BNEQ	17$			; No if NEQ
16$:
	CMPB	W^MAC$GB_RDXNDX,-	;H FLOAT?
		#RDX$V_HFLOAT
	BEQL	18$			;YES, THEN LEAVE UPPER WORD FOR LATER
	TSTW	2(R6)			;NO, UPPER 16 BITS 0?
	BEQL	18$			;IF EQL THEN YES
17$:	BRW	40$
					; Yes:  Get Operand bits, isolate Mode.
18$:	movl	w^MAC$GL_MOPPTR,r0
	beql	26$			; If null pointer assume integer.
	extv	#OPD$V_MODE,#OPD$S_MODE,(r0),r1
	cmpw	#OPD$M_ADDR,r1		; Can't allow short lit. if Addr. ref.,
	beql	40$
	cmpw	#OPD$M_VIELD,r1		; ditto for Vield references.
	beql	40$
	tstw	(r0)			; Floating Operand?
	bgeq	26$			; No if positive.
;
; ABSOLUTE FLOATING OPERAND--MAKE SHORT FLOATING IF WE CAN
;
	ADDW3	#^XC000,(R6),R0		;CLEAR HIGH ORDER BIT IN EXPONENT
	CMPB	W^MAC$GB_RDXNDX,-	;H FLOAT?
		#RDX$V_HFLOAT
	BNEQ	20$			;NO, THEN SKIP TO OTHER FLT. PT. CODE
	INSV	2(R6), #16, #16, R0	;YES, MOVE FRACTION TO LOW WORD OF R0
	BITL	#^X1FFFFFF8,R0		;ARE NECESSARY BITS ZERO?
	BNEQ	40$			;IF NEQ NO
	EXTZV	#29,#3,R0,R1		;GET FRACTION
	EXTZV	#0,#3,R0,R2		;GET EXPONENT
	INSV	R2,#3,#3,R1		;COMBINE THEM
	MOVZBL	R1,(R6)			;STORE RESULT
	BRB	30$			;DONE

20$:	CMPB	W^MAC$GB_RDXNDX,-	;G FLOAT?
		#RDX$V_GFLOAT
	BNEQ	23$			;NO, SKIP TO F AND D FLOAT COMMON CODE
	BITW	#^XFF81,R0		;ARE NECESSARY BITS ZERO?
	BNEQ	40$			;IF NEQ NO
	EXTZV	#1,#6,R0,(R6)		;YES, STORE RESULT
	BRB	30$

23$:	BITW	#^XFC0F,R0		;ARE NECESSARY BITS ZERO?
	BNEQ	40$			;IF NEQ NO
	EXTZV	#4,#6,R0,(R6)		;F OR D FLOAT, STORE RESULT
	BRB	30$
;
; ABSOLUTE NON-FLOATING--MAKE SHORT LITERAL IF WE CAN
;
26$:	BITW	#^C<^X3F>,(R6)		;INTEGER LESS THAN 64?
	BNEQ	40$			;IF NEQ NO
30$:	MOVB	#ADM$_LITERAL,W^MAC$GB_MODE ;SET LITERAL MODE
	$INC_PC				;COUNT THE BYTE
	BRB	50$
;
; MUST USE IMMEDIATE MODE
;
40$:	MOVB	#ADM$_IMMEDIATE,W^MAC$GB_MODE ;SET THE MODE
	MOVB	#REG$_PC,W^MAC$GB_REG	;REGISTER IS PC
	MOVZBL	W^MAC$GL_OPSIZE,R0	;GET THE OPERAND SIZE
	INCL	R0			;PLUS ONE BYTE
	$INC_PC	R0			;UPDATE LOCATION COUNTER
50$:	RSB

	.SBTTL	DEFERRED INDIRECT REGISTER REFERENCE

;++
; FUNCTIONAL DESCRIPTION:
;
;	ROUTINE IS INVOKED WHEN A DEFERRED INDIRECT REGISTER REFERENCE
;	IS SCANNED.  THE MODE AND REGISTER ARE SET, AND THE PC IS
;	INCREMENTED BY TWO BYTES.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-4[R7]	REGISTER
;
; OUTPUTS:
;
;	MAC$GB_MODE		'ADM$_DFBYTEDISP'
;	MAC$GB_REG		SET TO REGISTER
;	MAC$GL_PC		INCREMENTED BY 2
;
;--

AUTOI3::				;BASIC_REF = DAT DOPN RRREG DCLS
	CLRL	W^MAC$GL_EXPOPVL1	;VALUE IS 0
	MOVB	#ADM$_DFBYTEDISP,W^MAC$GB_MODE ;SET THE MODE
	CVTLB	W^MAC$AL_VALSTACK-4[R7],- ;GET THE REGISTER
			W^MAC$GB_REG
	$INC_PC	#2			;EAT TWO BYTES
	RSB

	.SBTTL	INDEXED REFERENCES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS INVOKED WHEN AN INDEX REFERENCE IS FOUND. CHECKS
;	ARE MADE FOR ILLEGAL INDEX MODES, AND MESSAGES ISSUED TO PASS 2
;	IF ILLEGAL INDEX MODES ARE FOUND.  THE MODES AND REGISTERS OF
;	THE BASIC REFERENCE AND THE INDEX REFERENCE ARE SET UP AND THE
;	PC IS INCREMENTED TO COUNT THE INDEX REGISTER REFERENCE.
;
; INPUTS:
;
;	MAC$AL_VALSTACK-4[R7]		INDEX REGISTER NUMBER
;	MAC$GB_MODE			MODE OF BASIC REFERENCE
;	MAC$GB_REG			REGISTER OF BASIC REFERENCE
;
; OUTPUTS:
;
;	MAC$GB_MODE			'ADM$_INDEX'
;	MAC$GB_REG			INDEX REGISTER NUMBER
;	MAC$GB_IMODE			MODE OF BASIC REFERENCE
;	MAC$GB_REG			REGISTER OF BASIC REFERENCE
;	MAC$GL_PC			INCREMENTED BY 1 FOR INDEX REF.
;
;--

INDEX::					;INDEX_REF = BASIC_REF DSQOPN RRREG DSQCLS
	MOVB	W^MAC$GB_MODE,R0	;GET BASIC_REF MODE
	CMPB	R0,#ADM$_LITERAL	;SURELY LITERAL MODE IS ILLEGAL
	BNEQ	20$			;NO ERROR MESSAGE TODAY
10$:	$MAC_ERR MAYNOTINDX		; Set message code
	BSBW	MAC$ERRORPT		;REPORT ERROR TO PASS 2
20$:	MOVL	W^MAC$AL_VALSTACK-4[R7],R6 ;GET INDEX REGISTER NUMBER
	CMPB	R6,#REG$_PC		;PC IS AN ILLEGAL REGISTER
	BEQL	30$			;IF EQL ILLEGAL INDEX REG
	CMPB	R6,W^MAC$GB_REG		;SAME AS BASIC_REF REGISTER?
	BNEQ	40$			;IF NEQ NO
	CMPB	R0,#ADM$_REGAUTODEC	;YES--IS MODE -(RX)[RX]
	BEQL	30$			;IF EQL ILLEGAL
	CMPB	R0,#ADM$_REGAUTOINC	;IS MODE (RX)+[RX]
	BEQL	30$			;IF EQL YES
	CMPB	R0,#ADM$_DFRAUTOINC	;IS MODE @(RX)+[RX]
	BNEQ	40$			;IF NEQ NO
30$:	$MAC_ERR ILLINDXREG		; Yes--set message code
	BSBW	MAC$ERRORPT		;ISSUE MESSAGE TO PASS 2
40$:	bbc	#FLG$V_OPTVFLIDX,(r11),60$ ; Occasionally, the presence of
	addb2	#2,r0			; indexing forces de-optimization.
	cmpb	r0,#ADM$_LONG_DISP	; If we de-optimize to Longword Disp.
	bnequ	50$			; the increase is two bytes, otherwise
	$inc_pc				; the increase is only one byte.
50$:	$inc_pc
60$:	MOVB	r0,W^MAC$GB_IMODE	;MOVE REGISTERS AND MODES
	MOVB	#ADM$_INDEX,W^MAC$GB_MODE ;SET INDEX MODE
	MOVB	W^MAC$GB_REG,W^MAC$GB_IREG ;...
	MOVB	R6,W^MAC$GB_REG		;STORE INDEX REGISTER VALUE
	$INC_PC				;ALLOW ROOM FOR INDEX REG
	RSB

	.SBTTL	SPESHL_MODE_CHK

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS FOR SPECIAL MODES THAT MUST BE HANDLED
;	SPECIALLY SINCE THEY ARE USED AS ADDRESSES IN INDEX MODE.
;	LITERAL MODE REFERENCES ARE CHANGED TO IMMEDIATE MODE
;	REFERENCES AND THE PC IS UPDATED BY THE SIZE OF THE OPERAND.
;	IMMEDIATE MODE REFERENCES ARE FORCED TO LONGWORD SIZE.
;
; INPUTS:
;
;	MAC$GB_MODE		MODE OF OPERAND
;
; OUTPUTS:
;
;	MAC$GB_MODE		NEW MODE OF OPERAND
;	MAC$GB_REG		SET TO PC IF ORIGINAL REF WAS LITERAL
;	MAC$GL_PC		UPDATED.
;
;--

SPESHL_MODE_CHK:
	MOVB	W^MAC$GB_MODE,R0	;GET THE MODE SPECIFIER
	BNEQ	10$			;BRANCH IF NOT LITERAL (0)
	MOVB	#ADM$_IMMEDIATE,W^MAC$GB_MODE ;YES--SET MODE TO IMEDIATE
	MOVB	#REG$_PC,W^MAC$GB_REG	;USE (PC)+ 
	MOVZBL	W^MAC$GL_OPSIZE,R0	;GET OPERAND SIZE
	$INC_PC	R0			;UPDATE PC
	BRB	20$			;EXIT ROUTINE
10$:	DECB	R0			;IS MODE IMMEDIATE (1)?
	BNEQ	20$			;IF NEQ NO
	MOVZBL	W^MAC$GL_OPSIZE,R0	;YES--GET OPERAND SIZE
	$DEC_PC	R0			;SUBTRACT DEFAULT SIZE
	$INC_PC	#4			;FORCE TO LONGWORD
	MOVB	#4,W^MAC$GL_OPSIZE	;...
20$:	RSB

	.END
