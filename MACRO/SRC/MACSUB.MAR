	.TITLE	MAC$MACSUB SUBROUTINES FOR VAX-11/780 ASSEMBLER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 21-AUG-78
;
; MODIFIED BY:
;
;	V02-019		BLS0057		Benn Schreiber		13-Jun-1981
;		Correct reference to SUM$INIT_EDIT to be General addressing mode
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$RABDEF				;DEFINE RAB OFFSETS
	$FABDEF				;DEFINE FAB OFFSETS
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_MLFDEF			; Define MLF offsets
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MACMSGDEF			; Define message codes
	$MAC_MNBDEF			; Define MXB offsets

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_CODE_P15,NOWRT,GBL,LONG

	.SBTTL	MAC$FAOUT FORMAT ASCII STRINGS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE THREE ROUTINES ARE USED TO FORMAT ASCII STRINGS
;	USING $FAOL.  THERE ARE THREE ENTRY POINTS:
;
;	MAC$FAOUTS	THE ARGUMENT LIST IS PUSHED ONTO THE STACK
;			BEFORE CALLING.  THE CALLER MUST CLEAR THE
;			STACK ON RETURN
;
;	MAC$WRT_FAOUTS	SAME AS MAC$FAOUTS EXCEPT THAT MAC$WRTLST
;			IS CALLED TO WRITE THE LINE BEFORE RETURNING.
;
;	MAC$FAOUT	THE ARGUMENT LIST IS POINTED TO BY R1
;
; INPUTS:
;
;	R0		FAO CONTROL STRING
;
; OUTPUTS:
;
;	MAC$GL_LINELN	ADJUSTED AND READY TO CALL MAC$WRTLST
;
;--

MAC$WRT_FAOUTS::
	MOVAB	4(SP),R1		;POINT TO THE ARGUMENT LIST
	BSBB	MAC$FAOUT		;FORMAT THE STRING
	BRW	MAC$WRTLST		;WRITE LINE TO LISTING AND RETURN

MAC$FAOUTS::
	MOVAB	4(SP),R1		;POINT TO THE ARGUMENT LIST
MAC$FAOUT::
	$FAOL_S	CTRSTR=(R0),-		;FORMAT THE STRING
		OUTBUF=L^MAC$G_LSTBUFDES,-
		OUTLEN=L^MAC$GL_LINELN,-
		PRMLST=(R1)
	SUBL2	#MAC$K_LIST_SIZE,W^MAC$GL_LINELN
	RSB

	.SBTTL	MAC$SET_PC RECORD HIGH WATER PC

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO STORE THE PC IN PSC$L_MAXLGTH
;	FOR THE CURRENT PSECT IF IT IS HIGHER THAN THE STORED
;	PC THERE.  IT SHOULD BE CALLED ANY TIME THE PC IS ADJUSTED
;	BACKWARDS, OR BEFORE CHANGING PSECTS.
;
;--

MAC$SET_PC::				;
	MOVL	W^MAC$GL_PSECTPTR,R0	;POINT TO CURRENT PSECT
	CMPL	W^MAC$GL_PC,PSC$L_MAXLGTH(R0) ;CURRENT PC HIGHER THAN STORED?
	BLSSU	10$			;IF LSSU NO
	MOVL	W^MAC$GL_PC,PSC$L_MAXLGTH(R0) ;YES--SET NEW PC
10$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UPDATES MAC$GL_LSB TO THE NEXT AVAILABLE LSB.
;
;--

MAC$SET_NEW_LSB::
	MOVAB	W^MAC$GL_LSB,R0		;POINT TO THE WORD
	CMPL	(R0),4(R0)		;CAN WE JUST INCREMENT LSB?
	BLSSU	10$			;IF LSSU NO--MUST USE HIGHEST LSB PLUS 1
	MOVL	(R0),4(R0)		;YES--STORE HIGHEST LSB SO FAR
	INCL	(R0)			;INCREMENT TO NEXT LSB
	RSB				;DONE
10$:	ADDL3	#1,4(R0),(R0)		;USE HIGHEST LSB + 1
	RSB

	.SBTTL	MAC$HASH_SYM	FORM HASH VALUE FOR SYMBOL IN MAC$AB_TMPSYM

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ACCUMULATES THE HASH VALUE FOR A SYMBOL.
;
; INPUTS:
;
;	MAC$AB_TMPSYM	THE SYMBOL NAME (LENGTH, NAME)
;
; OUTPUTS:
;
;	MAC$GL_HSHVAL	ACCUMULATED HASH VALUE
;
;--

MAC$HASH_SYM::
	PUSHR	#^M<R0,R1,R2,R3>	;SAVE REGISTERS
	MOVAB	W^MAC$AB_TMPSYM,R0	;POINT TO THE SYMBOL NAME BLOCK
	MOVZBL	(R0)+,R1		;GET THE # OF CHARS IN NAME
	MOVL	R1,R2			;SET LOOP COUNT
10$:	MOVZBL	(R0)+,R3		;GET NEXT CHARACTER
	ADDL2	R3,R1			;IMPROVE HASH VALUE
	SOBGTR	R2,10$			;LOOP FOR ALL CHARACTERS
	BICL3	#^C<HASHSZ>,R1,-	;TRIM TO HASH TABLE SIZE
		W^MAC$GL_HSHVAL		;AND STORE HASH VALUE
	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS
	RSB

	.SBTTL	TRUNCATION CHECK ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS THE VALUE ON THE TOP OF THE VALUE STACK
;	FOR UNSIGNED BYTE TRUNCATION.
;
; INPUTS:
;
;	R5 	POINTS TO VALUE TO CHECK
;--

MAC$CK_BYT_TRU1::
	MOVAL	4(SP),R5		;POINT R5 TO THE WORD
	BSBB	MAC$CK_BYT_TRUN		;CHECK FOR TRUNCATION
	BLBS	R0,10$			;BRANCH IF NO ERROR
	CLRW	2(R5)			;YES--TRIM TO A BYTE
	CLRB	1(R5)			;...
10$:	RSB				;DONE
MAC$CK_BYT_TRUN::
	TSTW	2(R5)			;POSITIVE VALUE?
	BNEQ	10$			;IF NEQ NO
	TSTW	1(R5)			;YES--UPPER 3 BYTES MUST BE 0
	BNEQ	MAC$TRUNC_ERR		;IF NEQ TRUNCATION ERROR
	TSTB	3(R5)			;...
	BNEQ	MAC$TRUNC_ERR
	BRB	20$			;ALL IS WELL
10$:	CMPW	2(R5),#-1		;UPPER WORD MUST BE ALL ONES
	BNEQ	MAC$TRUNC_ERR		;IF NEQ THEN TRUNCATION ERROR
	CMPB	1(R5),#-1		;SECOND BYTE MUST BE ALL ONES
	BNEQ	MAC$TRUNC_ERR		;IF NEQ TRUNCATION ERROR
20$:	MOVL	#1,R0			;RETURN SUCCESS
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS THE VALUE ON THE TOP OF THE VALUE STACK
;	FOR WORD TRUNCATION.
;
;--

MAC$CK_WRD_TRU1::
	MOVAL	4(SP),R5		;POINT TO WORD IN QUESTION
	BSBB	MAC$CK_WRD_TRUN		;GO CHECK FOR TRUNCATION
	BLBS	R0,10$			;BRANCH IF ALL OK
	CLRW	2(R5)			;NO--CLEAR TRUNCATION ERROR
10$:	RSB				;ALL DONE
MAC$CK_WRD_TRUN::
	TSTW	2(R5)			;UPPER WORD 0?
	BEQL	10$			;IF EQL YES--OK
	CMPW	2(R5),#-1		;NO--IS IT ALL ONES?
	BNEQ	MAC$TRUNC_ERR		;IF NEQ NO--TRUNCATION ERROR
10$:	MOVL	#1,R0			;RETURN SUCCESS
	RSB

;
; REPORT TRUNCATION ERROR
;

MAC$TRUNC_ERR:
	BBC	#FLG$V_P2,(R11),10$	;BRANCH IF PASS 1
	$MAC_P2_ERR DATATRUNC		; Report error
	RSB
10$:	$MAC_ERR DATATRUNC		; Get message code
	BSBW	MAC$ERRORPT		;ISSUE ERROR TO PASS 2 AND RETURN
	CLRL	R0			;RETURN ERROR
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	CHECK FOR SIGNED BYTE TRUNCATION
;
;--

MAC$CK_SBY_TRU1::
	MOVAL	4(SP),R5		;POINT TO WORD IN QUESTION
	BSBB	MAC$CK_SBY_TRUN		;CHECK FOR TRUNCATION
	BLBS	R0,20$			;BRANCH IF ALL IS WELL
	CLRL	R0			;ASSUME POS BYTE
	TSTB	(R5)			;POS OR NEG. BYTE?
	BGEQ	10$			;IF GEQ POS
	DECL	R0			;NEGATIVE--MAKE -1
10$:	MOVW	R0,2(R5)		;STORE -1
	MOVB	R0,1(R5)		;...
20$:	RSB				;DONE
MAC$CK_SBY_TRUN::
	CLRL	R1			;ASSUME POSITIVE
	TSTB	(R5)			;CHECK SIGN OF BYTE
	BGEQ	10$			;BR IF GEQ
	DECL	R1			;MAKE 0 INTO -1
10$:	CMPW	R1,2(R5)		;DOES HIGH WORD HAVE RIGHT SIGN?
	BNEQ	MAC$TRUNC_ERR		;IF NEQ NO--ERROR
	CMPB	R1,1(R5)		;YES--HOW ABOUT SECOND BYTE?
	BNEQ	MAC$TRUNC_ERR		;IF NEQ NO
	MOVL	#1,R0			;RETURN SUCCESS
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	CHECK FOR SIGNED WORD TRUNCATION
;
;--

MAC$CK_SWD_TRU1::
	MOVAL	4(SP),R5		;POINT TO WORD IN QUESTION
	BSBB	MAC$CK_SWD_TRUN		;CHECK FOR TRUNCATION
	BLBS	R0,20$			;BRANCH IF ALL IS WELL
	CLRL	R0			;ASSUME POS. BYTE
	TSTW	(R5)			;POSITIVE?
	BGEQ	10$			;IF GEQ YES
	DECL	R0			;NO--MAKE -1
10$:	MOVW	R0,2(R5)		;FIX THE ERROR
20$:	RSB
MAC$CK_SWD_TRUN::
	CLRL	R1			;ASSUME POSITIVE
	TSTW	(R5)			;CHECK SIGN OF WORD
	BGEQ	10$			;BR IF GEQ
	DECL	R1			;MAKE 0 INTO -1
10$:	CMPW	R1,2(R5)		;SIGN OF UPPER WORD CORRECT?
	BNEQ	MAC$TRUNC_ERR		;IF NEQ NO--ERROR
	MOVL	#1,R0			;RETURN SUCCESS
	RSB

	.SBTTL	MAC$SRC_KEYS	SEARCH KEYWORD LIST WITH ABBREVIATIONS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SEARCHES A LINKED LIST FOR A KEYWORD, WITH
;	ABBREVIATIONS TAKEN INTO ACCOUNT.
;
; INPUTS:
;
;	R5	POINTER TO FIRST ELEMENT OF LINKED SYMBOL LIST
;
; OUTPUTS:
;
;	R0	0	NOT FOUND OR MULTIPLE PARTIAL MATCHES
;		1	FOUND
;	R1	0	NOT FOUND OR MULTIPLE PARTIAL MATCHES
;		<>0	ADDRESS OF SYMBOL BLOCK.
;
;--

MAC$SRC_KEYS::
	PUSHR	#^M<R4,R5,R6,R7,R8,R9> ;SAVE REGISTERS
	MOVL	R5,R6			;POINT TO LINKED LIST
	MOVAB	W^MAC$AB_TMPSYM,R7	;POINT TO SYMBOL IN QUESTION
	MOVZBL	(R7)+,R8		;GET LENGTH OF SYMBOL
	CLRL	R9			;CLEAR PARTIAL MATCH INDICATOR
;
; CHAIN THROUGH LIST LOOKING FOR SYMBOL
;
10$:	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to symbol count/name
	SUBL3	R0,R6,R0		; and form its address
	MOVZBL	(R0)+,R1		; Get count byte and advance pointer
	MATCHC	R8,(R7),R1,(R0)		; Find the substring in here?
	BEQL	60$			;IF EQL YES
20$:	MOVL	SYM$L_LINK(R6),R6	; No--link to next
	BNEQ	10$			;IF NEQ GO CHECK IT OUT
30$:	CLRQ	R0			;ASSUME NOT FOUND
	TSTL	R9			;WAS THERE A PARTIAL MATCH?
	BEQL	50$			;IF EQL NO--RETURN NOT FOUND
	INCL	R0			;YES--RETURN 1 FOR FOUND
	MOVL	R9,R1			;RETURN ADDRESS IN R1
	BRB	50$			;GO RETURN
40$:	MOVL	#1,R0			;RETURN SUCCESS
	MOVL	R6,R1			;...
50$:	POPR	#^M<R4,R5,R6,R7,R8,R9>	;RESTORE REGISTERS
	RSB
;
; HERE IF FOUND
;
60$:
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to symbol count/name
	SUBL3	R0,R6,R0		; and form its address
	CMPB	(R7),1(R0)		; Did it match on first character?
	BNEQ	20$			;IF NEQ NO--NOT A MATCH
	TSTL	R2			;WAS IT A PERFECT MATCH?
	BEQL	40$			;IF EQL YES--GO RETURN
	TSTL	R9			;NO--WAS THERE ALREADY A PARTIAL MATCH?
	BNEQ	30$			;IF NEQ YES--CONFLICT MEANS NOT FOUND
	MOVL	R6,R9			;NO--SAVE ADDRESS OF THIS PARTIAL MATCH
	BRB	20$			;CONTINUE LOOKING

	.SBTTL	CONVERT LOWER CASE TO UPPER CASE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS THE (POSSIBLE) LOWER CASE LETTER
;	IN R10 TO UPPER CASE.
;
;--

MAC$CVT_LOWER::
	CMPB	R10,#^A/A/+^X20		;CAN CHARACTER BE LOWER CASE?
	BLSSU	10$			;IF LSSU NO
	CMPB	R10,#^A/Z/+^X20		;STILL CHECKING FOR LOWER CASE
	BGTRU	10$			;IF GTRU NOT LOWER CASE
	BICB2	#^X20,R10		;YES--CONVERT TO UPPER CASE
10$:	RSB

	.SBTTL	MAC$OPEN_INPUT OPEN INPUT FILE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OPEN THE INPUT FILE
;
; INPUTS:
;
;	R0	ADDRESS OF FDB
;
; OUTPUTS:
;
;	FILE IS OPENED.  CREATION TIME PLACED IN SUBTITLE BUFFER.
;
;--

MAC$OPEN_INPUT::
	PUSHR	#^M<R1,R2,R3,R4,R5>	;SAVE REGISTERS
	MOVL	R0,W^MAC$GL_CURINFDB	;SET AS CURRENT FDB
	MOVAB	8(R0),W^MAC$INPUT_RAB+RAB$L_FAB ;POINT RAB TO FAB
	MOVB	#2,FAB$B_FSZ+8(R0)	;SET FIXED AREA SIZE OF 2
	PUSHAB	FAB$B_RFM+8(R0)		;STACK RECORD FORMAT ADDRESS
	$OPEN	FAB=8(R0),-		;OPEN THE FILE
		ERR=W^MAC$ERR_OPN_INP
	BLBS	R0,5$			; Branch if OK
	BRW	100$
5$:
	BBCC	#FLG$V_SEQFIL,(R11),10$	;ASSUME NOT SEQUENCED FILE
10$:	CMPB	@(SP)+,#FAB$C_VFC	;IS IT SEQUENCED?
	BNEQ	20$			;IF NEQ NO
	BBCS	#FLG$V_SEQFIL,(R11),20$	;YES--SET FLAG FOR PASS 2
20$:	MOVAB	W^MAC$INPUT_RAB,R0	;POINT TO INPUT RAB
	MOVAB	W^MAC$GL_RECHDBUF,RAB$L_RHB(R0) ;SET RECORD HEADER BUFFER ADDRESS
	$CONNECT RAB=(R0),-		;CONNECT RECORD STREAM
		ERR=W^MAC$ERR_CONNECT
	BLBC	R0,100$			;BRANCH IF ERROR
	$ASCTIM_S TIMBUF=L^MAC$AL_FTIM_DSC,- ;CONVERT FILE CREATION DATE/TIME
		  TIMADR=L^MAC$INPUT_XAB+XAB$Q_CDT ;
;
; COPY FILENAME AND CREATION DATE TIME TO VM FOR PASS 2 (IF PASS 1)
;
;
; COPY FILENAME INTO SUBTITLE BUFFER
;
	MOVL	MAC$GL_CURINFDB,R0	;POINT TO FDB AGAIN
	MOVZBL	FAB$B_FNS+8(R0),R1	;GET LENGTH OF FILENAME STRING
	MOVC5	R1,FAB$C_BLN+NAM$C_BLN+12(R0),- ;COPY FILENAME INTO
			#^A/ /,#39.,-	;THE SUBTITLE LISTING BUFFER
		W^MAC$AB_SBT_FILE	;...
	MOVL	MAC$GL_CURINFDB,R0	; Point to FDB again
	BBCC	#FLG$V_UPDFIL,(R11),30$	; Assume file is not being updated
30$:
	PUSHAB	W^MAC$INPUT_RAB		; Push parameters: RAB address
	PUSHL	FAB$C_BLN+NAM$C_BLN+8(R0) ; Update files list address

	BEQL	40$			; If EQL zero their are no update files
	BBSS	#FLG$V_UPDFIL,(R11),40$	; Flag this file as being updated
40$:
	PUSHAB	W^MAC$GT_SCB		; SUM control block
	CALLS	#3,G^SUM$INIT_EDIT	; Initialise update files
	BLBC	R0,100$			; Error if LBC
	POPR	#^M<R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	MOVL	#1,R0			;SET SUCCESS
	RSB

100$:	BRW	MAC$LAST_CHANCE		;GO TO LAST CHANCE HANDLER

	.SBTTL	MAC$RESCANCH RESCAN CURRENT CHARACTER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE BACKS UP THE LINE POINTER AND RESETS THE NEXT
;	CHARACTER SO AS TO RESCAN THE CURRENT CHARACTER.
;
;--

MAC$RESCANCH::
	MOVAB	W^MAC$GL_LINEPT,R0	;GET POINTER TO MAC$GL_LINEPT
	CMPW	(R0),#MAC$AB_LINEBF	;AT BEGINNING OF LINE?
	BEQL	10$			;IF EQL YES
	DECL	(R0)			;NO--BACK IT UP
10$:	RSB

	.SBTTL	MAC$OPTIMIZEXPR DELETE EXPRESSION

;++
; FUNCTIONAL DESCRIPTION:
;
;	MAC$OPTIMIZEXPR IS CALLED TO REMOVE THE CODE TO EVALUATE AN
;	EXPRESSION FROM THE INTERMEDIATE BUFFER.  THE EXPRESSION IS
;	POINTED TO BY 'MAC$GL_EXPPTR' AND 'MAC$GL_EXPEND'.  ANY MACRO
;	TEXT WITHIN THIS RANGE IS COPIED DOWN.  THE REST OF THE
;	INTERMEDIATE CODE IS DELETED. ALL POINTERS AND COUNTERS
;	ARE UPDATED (EXCEPT MAC$GL_EXPPTR AND MAC$GL_EXPEND).
;
;--

MAC$OPTIMIZEXPR::
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;PRESERVE REGISTERS
	MOVL	W^MAC$GL_EXPPTR,R8	;POINT TO EXPRESSION START
	MOVL	W^MAC$GL_EXPEND,R7	;AND END OF EXPRESSION
	CMPL	R7,R8			;IS THERE AN EXPRESSION?
	BEQL	50$			;IF EQL NO
	MOVL	R8,R6			;COPY START OF EXPRESSION POINTER
10$:	CMPB	(R6),#^XFF		;MACRO LINE?
	BEQL	20$			;IF EQL YES
	MOVZBL	(R6),R0			;NO--EXPRESSION COMMAND--GET LENGTH
	ADDL2	R0,R6			;SKIP THE EXPRESSION
	ADDL2	R0,W^MAC$GL_INTCNT	;INCREASE REMAINING BYTES IN BUFFER
	BRB	30$			;
;
; MACRO LINE--COPY DOWN
;
20$:	MOVW	2(R6),R0		;GET MACRO LINE LENGTH
	ADDL2	#4,R0			;COUNT OVERHEAD BYTES
	MOVC3	R0,(R6),(R8)		;MOVE MACRO LINE
	MOVL	R3,R8			;UPDATE POINTER
	MOVL	R1,R6			;POINT PAST MACRO TEXT
30$:	CMPL	R6,R7			;END OF EXPRESSION?
	BLSSU	10$			;IF LSS NO
	MOVL	R8,R3			;COPY END OF EXPR. POINTER
	SUBL3	R7,R9,R0		;COMPUTE LENGTH OF CODE TO MOVE
	BLEQ	40$			;IF LEQ NOTHING
	MOVC3	R0,(R6),(R8)		;MOVE CODE
40$:	MOVL	R3,R9			;UPDATE FRAME POINTER
50$:	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

	.SBTTL	MAC$SKP_OPR	SKIP TO NEXT OPERAND OR EOL

;++
; FUNCTIONAL DESCRIPTION:
;
;	MAC$SKP_OPR WILL SCAN TO A COMMA OR END-OF-LINE.  THIS IS
;	DONE WHEN AN ERROR IS DETECTED, SO AS TO PREVENT MULTIPLE
;	ERROR MESSAGES PER OPERAND.  IF AN END-OF-LINE IS ENCOUNTERED
;	THE OPERAND FLAG IS CLEARED AND THE BEGINNING OF LINE FLAG IS
;	SET.
;
;--

MAC$SKP_OPR::
	BBC	#FLG$V_OPRND,(R11),40$	;BRANCH IF NOT IN OPERAND FIELD
10$:	CMPB	R10,#CR			;YES--IS CHARACTER CR?
	BEQL	20$			;IF EQL YES
	CMPB	R10,#^A/,/		;NO--IS IT A COMMA?
	BEQL	40$			;IF EQL YES
	BSBW	MAC$GETCHR		;NO--GET NEXT CHARACTER
	BRB	10$			;LOOK FOR NEW LINE OR COMMA
20$:	BBCC	#FLG$V_OPRND,(R11),30$	;CLEAR OPERAND FLAG FOR NEW LINE
30$:	BBSS	#FLG$V_BOL,(R11),40$	;FLAG AT BEGINNING OF LINE
40$:	RSB

MAC$SKIPSP::
10$:	CMPB	R10,#^A/ /		;IS IT A SPACE?
	BGTRU	30$			;IF GTR NO--NOT SPACE-LIKE EITHER
	BEQL	20$			;IF EQL YES--READ NEXT CHARACTER
	TSTL	MAC$AL_CHRTAB[R10]	;CHECK ENTRY IN TABLE
	BNEQ	30$			;IF NEQ NOT SPACE-LIKE CHARACTER
20$:	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	BRB	10$			;CHECK IT OUT
30$:	RSB				;RETURN


	.SBTTL	MAC$CLOSE_FILES CLOSE ALL FILES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CLOSES ALL POSSIBLY OPEN FILES
;
;--

MAC$CLOSE_FILES::
	$DISCONNECT RAB=W^MAC$INPUT_RAB	;DISCONNECT INPUT RECORD STREAM
	MOVL	W^MAC$GL_CURINFDB,R0	;GET PTR TO CURRENT FDB
	$CLOSE	FAB=8(R0)		;CLOSE INPUT FILE
	BBCC	#FLG$V_OBJXST,(R11),10$	;BRANCH IF NO OBJECT FILE
	$DISCONNECT RAB=W^MAC$OBJECT_RAB;DISCONNECT OBJECT FILE STREAM
	$CLOSE	FAB=W^MAC$OBJECT_FAB	;CLOSE OBJECT FILE
10$:	BSBB	MAC$CLOSE_LIST		;CLOSE LISTING FILE
	BRW	MAC$CLOSE_LIB		;CLOSE LIBRARIES
MAC$CLOSE_LIST::
	BBCC	#FLG$V_LSTXST,(R11),20$	;BRANCH IF NO LISTING FILE
	$DISCONNECT RAB=W^MAC$LIST_RAB	;DISCONNECT LISTING FILE STREAM
	$CLOSE	FAB=W^MAC$LIST_FAB	;CLOSE LISTING FILE
20$:	RSB				;RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CLOSES ALL OPEN FILES, AND DELETES THE OBJECT
;	AND LISTING FILE.  THIS SHOULD BE CALLED ONLY ON ABORTS.
;
;--

MAC$CLS_DEL_OBJ::
	BBCC	#FLG$V_OBJXST,(R11),10$	;BRANCH IF NO OBJECT FILE
	MOVAB	W^MAC$OBJECT_RAB,R0	;GET POINTER TO OBJECT RAB
	MOVL	RAB$L_FAB(R0),R1	;GET POINTER TO FAB
	BBCS	#FAB$V_DLT,FAB$L_FOP(R1),.+1 ;SET DELETE BIT IN FAB
	PUSHL	R1			;SAVE FAB ADDRESS
	$DISCONNECT RAB=(R0)		;DISCONNECT RECORD ACCESS
	POPL	R0			;GET FAB ADDRESS BACK
	$CLOSE	FAB=(R0)		;CLOSE AND DELETE THE FILE
10$:	RSB

	.SBTTL	MAC$CLOSE_LIB	CLOSE MACRO LIBRARIES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CLOSES ALL MACRO LIBRARY FILES.  THE FILES SHOULD
;	BE DISCONNECTED FROM RECORD ACCESS.
;
;--

MAC$CLOSE_LIB::
	MOVL	W^MAC$GL_MLB_QUE,R2	;POINT TO THE FIRST MLB FDB
	BEQL	20$			;IF EQL NO LIBRARIES TO CLOSE
10$:
	PUSHAB	MLF$L_CTINDEX(R2)	; Address of control table index
	CALLS	#1,G^LBR$CLOSE		; Close library file
	MOVL	MLF$L_QLINK(R2),R2	; Link to possible next library
	CMPL	R2,#MAC$GL_MLB_QUE	;ALL DONE?
	BNEQ	10$			;IF NEQ NO
20$:	RSB				;DONE

	.SBTTL	ALLOCATE/DEALLOCATE VIRTUAL MEMORY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ALLOCATE 1 PAGE OF VIRTUAL MEMORY.
;	AN ATTEMPT IS MADE TO GET MEMORY FROM THE RETURNED PAGES LIST.
;	IF THAT FAILS, LIB$GET_VM IS CALLED TO ALLOCATE A NEW PAGE.
;
;--

MAC$ALL_1_PAGE::
	REMQUE	@W^MAC$GL_FREE_LST,R0	;TRY TO GET A PAGE FROM THE
					;RETURNED PAGES LIST
	BVC	10$			;IF V-CLEAR WE GOT ONE
	CALLG	L^MAC$G_1_PAGE,G^LIB$GET_VM ;NONE THERE--ALLOCATE A NEW PAGE
	BLBC	R0,NO_MEM		;BRANCH IF ALLOCATION FAILURE
	MOVL	W^MAC$GL_BASEADDR,R0	;PICK UP THE BLOCK ADDRESS
10$:	RSB				;RETURN WITH BLOCK ADDRESS IN R0

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO DEALLOCATE 1 PAGE OF VIRTUAL MEMORY.
;	THE DEALLOCATED PAGES ARE PLACED ON A LINKED LIST POINTED TO
;	BY MAC$GL_FREE_LST.
;
;--

MAC$DEA_1_PAGE::
	INSQUE	(R0),W^MAC$GL_FREE_LST	;INSERT THE PAGE INTO THE FREE LIST
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES TWO CONTIGUOUS PAGES OF MEMORY.
;	THE ADDRESS IS RETURNED IN R0.
;
;--

MAC$ALL_2_PAGES::
	CALLG	L^MAC$G_2_PAGES,G^LIB$GET_VM ;TRY TO GET THE PAGES
	BLBC	R0,NO_MEM		;BRANCH IF ALLOCATION ERROR
	MOVL	W^MAC$GL_BASEADDR,R0	;GOT IT--GET THE ADDRESS
	RSB
NO_MEM:	BRW	MAC$ERR_NOMEM		;REPORT NO MEMORY ERROR
					;(NO RETURN)

;++
; Functional description:
;
;	This routine deallocates a block of virtual memory.  If the block
;	is 1 page it is returned to the free list; if it is >1 page the
;	block is returned to the system.
;	This routine is used to deallocate MXB blocks.
;
; Inputs:
;	R0 = Address of block to deallocate
;		Offset MXB$L_PAGES contains the size of the block in pages
;
;--

MAC$DEAL_BLOCK::
	CMPL	MXB$L_PAGES(R0),#1	; Is this block 1 page?
	BEQL	MAC$DEA_1_PAGE		; Yes if EQL
	PUSHL	R0			; Put address on stack
	MOVL	SP,R1			; and save stack address
	ASHL	#9,MXB$L_PAGES(R0),-(SP) ; Put block size (in bytes) on stack
	MOVL	SP,R0			; and save stack address
	PUSHL	R1			; Form argument block
	PUSHL	R0			; on stack
	CALLS	#2,G^LIB$FREE_VM	; Return virtual memory
	ADDL	#<2*4>,SP		; Clean up stack
	RSB


;++
; Functional description:
;
;	This routine allocates a block of virtual memory.  The block
;	size is rounded up to 1 page.
;
; Inputs:
;	R1 = Number of bytes required
;
; Outputs:
;	R0 = Address of memory block
;	R1 = Number of pages allocated
;
;--

MAC$ALL_BLOCK::
	ADDL2	#511,R1			; Round number of bytes to multiple
	BICL2	#511,R1			; of 512 bytes.
	ASHL	#-9,R1,-(SP)		; Also convert to number of pages
	CMPL	(SP),#1			; Is 1 page required?
	BNEQ	10$			; No if NEQ
	BSBB	MAC$ALL_1_PAGE		; Get 1 page
	BRB	20$
10$:
	PUSHL	R1			; Stack bytes required
	MOVL	SP,R0			; and save its address
	PUSHAL	W^MAC$GL_BASEADDR	; Push address to return block address
	PUSHL	R0			; and address of bytes required
	CALLS	#2,G^LIB$GET_VM		; Get memory
	BLBC	R0,NO_MEM		; Branch if error
	MOVL	W^MAC$GL_BASEADDR,R0	; Get base address of allocated block
	ADDL	#<1*4>,SP		; Clean stack
20$:
	POPL	R1			; Get pages allocated
	RSB
;
;
	.END
