	.TITLE	MAC$ACTPRI PRIMARIES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V03.00	MTR0001		Mike Rhodes	15-Mar-1982
;		Modify routine NUMASC to use FLG$V_DLIMSTR flag
;		to allow passing hyphens and semicolons.
;		Fixes SPR #11-42904.
;
;	V02.12	PCG0008		Peter George	28-Aug-1981
;		Fix test for floating negation in PRMUN.
;
;	V02.11	PCG0002		Peter George	05-May-1981
;		Set SYM$M_RELPSECT flag in IDLIST and PRMSYM.
;
;	V01.10	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error message from system
;		message file.
;
;	V01.09	RN0014		R. Newland	17-Oct-1979
;		Support for G_floating, H_floating, and Octaword data types.
;
;	V01.07	RN0005		R. Newland	12-Aug-1979
;		Remove .ALIGN LONG statements
;
;	V01.11	RN0027		R. Newland	14-Jan-1980
;		Fix problems with negative floating point literals.
;		SPR 11-27884.
;
;	V01.08	RN0007		R. Newland	28-Aug-1979
;		Fix problem with quadword ^A literals less
;		than 8 characters.  SPR 11-25674.
;
;	V01.05	0003		B. Schreiber	10-JAN-1979
;		Catch syntax error if pound sign forgotten before
;		ASCII immediate (^A) in operands.
;	V01.06	0006		B. Schreiber	16-JAN-1979
;		Fix problem with data generation if repeated data
;		and uparrow-A data (i.e. .BYTE ^A/ /[10])
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

$MAC_SYMBLKDEF				;DEFINE SYMBOL BLOCK OFFSETS
$MAC_CTLFLGDEF				;DEFINE CONTROL FLAGS
$MAC_INTCODDEF				;DEFINE INT. FILE COMMANDS
$MAC_GENVALDEF				;DEFINE OTHER GOOD SYMBOLS
$MACMSGDEF				; Define message codes

;
; EQUATED SYMBOLS:
;

	SIGN_BIT	=	^X80000000	;SIGN BIT

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG

;++
;	THIS DISPATCH TABLE IS USED DURING PASS 1 TO JSB TO
;	MATH ACTION ROUTINES.
;--

P1$ARITH_DISP::
	.LONG	0			;(0)--SHOULD NOT HAPPEN
	.LONG	P1$ARITH_ADD		;INT$_ADD
	.LONG	P1$ARITH_AND		;INT$_AND
	.LONG	P1$ARITH_ASH		;INT$_ASH
	.LONG	P1$ARITH_DIV		;INT$_DIV
	.LONG	P1$ARITH_MUL		;INT$_MUL
	.LONG	P1$ARITH_NEG		;INT$_NEG
	.LONG	P1$ARITH_NOT		;INT$_NOT
	.LONG	P1$ARITH_OR		;INT$_OR
	.LONG	P1$ARITH_SAME		;INT$_SAME
	.LONG	P1$ARITH_SUB		;INT$_SUB
	.LONG	P1$ARITH_XOR		;INT$_XOR

	.PSECT	MAC$ACTPRI_DATA,NOEXE,LONG

SYM_FLAG:.WORD	0			;USED FOR GLOBAL/DEBUG/WEAK/EXTERN
ENTRY_MASK:
	.WORD	0			;USED FOR .ENTRY/.VECTOR

	.SBTTL	PRMUN	PRIMARY UNARY OPERATORS

;++
; FUNCTIONAL DESCRIPTION:
;
;	PRMUN IS CALLED WHEN A UNARY OPERATOR PRODUCTION IS
;	ENCOUNTERED.  IT CHECKS FOR UNARY FLOATING NEGATION
;	AND CHANGES IT TO AN XOR OF THE SIGN BIT.  IF THE
;	EXPRESSION IS TO BE EVALUATED IN PASS 2 THE INTERMEDIATE
;	CODE IS EMITTED.  THE EXPRESSION IS THEN EVALUATED
;	AND THE RESULT IS RETURNED IN MAC$GL_VALUE.
;
; INPUTS:
;
;	MAC$AL_VALSTACK[R7]	VALUE OF EXPRESSION
;	MAC$AL_VALSTACK-4[R7]	OPERATION
;
; OUTPUTS:
;
;	MAC$GL_VALUE		COMPUTED VALUE
;
;--

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

	.ENABL	LSB

PRMUN::					;PRIMITIVE = OPUNARY PRIMITIVE
	MOVAL	W^MAC$AL_VALSTACK[R7],R6;POINT TO TOP OF VALUE STACK
	$VPUSH	(R6)			;PUSH VALUE ONTO STACK
	TSTL	-(R6)			;BACK UP TO ROUTINE VALUE
;
; IF OPERATION IS FLOATING NEGATION, CHANGE TO XOR OF SIGN BIT
;
	CMPB	(R6),#INT$_NEG		;ARE WE DOING A NEGATE?
	BNEQ	20$			;IF NEQ NO
	CMPB	W^MAC$GB_RDXNDX,-	;YES--AND IS IT A FLOATING NEGATE?
			#RDX$V_FLOAT	;...
	BLSSU	20$			;IF LESS NO
	BBC	#FLG$V_EVALEXPR,(R11),10$ ;YES--ARE WE EVALUATING ON PASS 2
	$INTOUT_LW INT$_STKL,<#^X8000>	; Yes--stack floating point sign bit
10$:	MOVZBL	#INT$_XOR,(R6)		;CHANGE COMMAND TO XOR
	$VPUSH	#^X8000			; Stack sign bit
20$:	MOVL	(R6),R0			;GET ACTION
	MOVL	R0,R6			;REMEMBER IT FOR LATER
	BBC	#FLG$V_EVALEXPR,(R11),30$ ;BRANCH IF NOT EVAL ON PASS 2
	MOVZBL	#2,R1			;SET BYTE COUNT
	BSBW	MAC$INTOUT_X		;EMIT TO INT. FILE
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPR POINTER
30$:	MOVL	W^P1$ARITH_DISP[R6],R6	;GET ADDRESS OF ROUTINE
	JSB	(R6)			;CALL IT
	$VPOP	W^MAC$GL_VALUE		;RETRIEVE VALUE
	RSB

	.DSABL	LSB

	.SBTTL	PRMSYM	PRIMARY SYMBOLS

;++
; FUNCTIONAL DESCRIPTION
;
;	PRMSYM IS INVOKED WHEN AN ID IS FOUND IN THE PRODUCTION.
;	BASED ON THE SYMBOL ATTRIBUTES (LOCAL, GLOBAL, EXTERNAL,
;	DEFINED, ABSOLUTE) IT WILL SET CONTROL FLAGS FOR LATER
;	PROCESSING OF THE ID.
;
; INPUTS:
;
;	MAC$GL_VALUE		POINTER TO ID SYMBOL BLOCK
;
; OUTPUTS:
;
;--

PRMSYM::				;PRIMARY = ID

	MOVL	W^MAC$GL_VALUE,R6	;GET POINTER TO SYMBOL BLOCK
	BBS	#FLG$V_NOREF,(R11),5$	;BRANCH IF WE SHOULD NOT REF SYMBOL
	BISW2	#SYM$M_REF,SYM$W_FLAG(R6) ;FLAG SYMBOL AS REFERENCED
	MOVL	MAC$GL_PSECTPTR,R0	;GET POINTER TO PSECT DATA
	BBC	#PSC$V_REL, -		;IF ABS PSECT
		PSC$W_OPTIONS(R0),5$	;THEN SKIP
	BISW2	#SYM$M_RELPSECT,SYM$W_FLAG(R6)	;SET REL PSECT FLAG
5$:	BICW2	#SYM$M_SUPR,SYM$W_FLAG(R6) ;AND CLEAR SUPPRESS BIT
	BBS	#SYM$V_DEF,SYM$W_FLAG(R6),10$
					;IF SYMBOL NOT YET DEFINED
	BICL2	#FLG$M_COMPEXPR,(R11)	;THEN EXPR VALUE NOT YET KNOWN
10$:	BITW	#SYM$M_GLOBL!SYM$M_EXTRN,- ;SYMBOL GLOBAL OR EXTERNAL?
			SYM$W_FLAG(R6)
	BEQL	20$			;IF EQL NO
	BITW	#SYM$M_DEF!SYM$M_LOCAL,-;YES--DEFINED OR LOCAL?
			SYM$W_FLAG(R6)	;
	BNEQ	20$			;IF NEQ NO
					;
					;SYMBOL IS EXTERNAL OR GLOBAL
					; SYMBOL NOT YET DEFINED
	BBC	#FLG$V_EVALEXPR,(R11),50$ ;EVALUATE ON PASS 2?
	$INTOUT_LW INT$_STKG,R6		;YES--STACK GLOBAL
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPRESSION
	BRB	50$
;
; LOCAL OR DEFINE SYMBOL
;
20$:	CMPB	SYM$B_SEG(R6),W^MAC$GL_PRMSEG ;DIFFERENT PSECTS?
	BEQL	30$			;IF EQL NO
	BBS	#SYM$V_ABS,SYM$W_FLAG(R6),30$ ;YES--UNLESS SYMBOL ABSOLUTE
					      ;(BRANCH IF ABSOLUTE)
	TSTL	W^MAC$GL_PRMSEG		;REALLY DIFFERENT PSECTS?
	BEQL	30$			;IF EQL NO
	BICL2	#FLG$M_COMPEXPR,(R11)	;YES--VALUE NOT YET KNOWN
30$:	BBC	#FLG$V_EVALEXPR,(R11),40$ ;EVALUATE ON PASS 2?
	$INTOUT_LW INT$_STKS,R6		;YES--STACK SYMBOL
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPRESSION
40$:	MOVL	SYM$L_VAL(R6),W^MAC$GL_VALUE ;VALUE IS VALUE OF SYMBOL
50$:	BBC	#SYM$V_ABS,SYM$W_FLAG(R6),60$ ;IS SYMBOL ABSOLUTE?
	BBS	#FLG$V_COMPEXPR,(R11),70$ ;YES--DO WE KNOW EXPR VALUE?
60$:	INCL	W^MAC$GL_ABSFLAG	;NO--NOT ABSOLUTE EXPRESSION
	TSTL	W^MAC$GL_PRMSEG		;DOES EXPR HAVE A SEG YET?
	BNEQ	70$			;IF NEQ YES
	MOVZBL	SYM$B_SEG(R6),W^MAC$GL_PRMSEG ;NO--USE SYMBOL SEGMENT
70$:	MOVZBL	#CRF$K_REF,R5		;SET REFERENCE
	BRW	MAC$CREF_SYM		;CREF SYMBOL IF CREFFING AND RETURN

	.SBTTL	NUMERIC PRIMARIES

;++
; FUNCTIONAL DESCRIPTION:
;
;	NUMFLT IS CALLED WHEN '^F' IS SEEN. A FLOATING POINT NUMBER
;	IS SCANNED.
;
;--

NUMFLT::				;SPECIAL_OPERATOR = DUPF
	BSBW	MAC$SKIPSP		;SKIP SPACES
	BSBW	MAC$GETFLOAT		;ACCUMULATE FLOATING POINT NUMBER
	BRB	PRMINT			;TREAT AS INTEGER

;++
; FUNCTIONAL DESCRIPTION:
;
;	PRMINT IS CALLED WHEN AN INTEGER (OR INTEGER-LIKE) TOKEN
;	IS FOUND.  IF THE EXPRESSION IS BEING EVALUATED IN PASS 2
;	THE VALUE IS EMITTED TO THE INTERMEDIATE FILE.
;
;--

PRMINT::				;PRIMARY = DINTEGER
	BBC	#FLG$V_EVALEXPR,(R11),10$ ;EVALUATE ON PASS 2?
	$INTOUT_LW INT$_STKL,<W^MAC$GL_VALUE> ;YES--STACK VALUE
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPRESSION
10$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	PRMBRK IS CALLED WHEN AN EXPRESSION IN ANGLE BRACKETS IS
;	SCANNED.  THE VALUE IS PICKED OFF OF THE STACK AND PLACED
;	IN MAC$GL_VALUE.
;
;--

PRMBRK::				;PRIMARY = DANGOPN EXPR DANGCLS
	MOVL	W^MAC$AL_VALSTACK-4[R7],- ;VALUE IS ON STACK
			W^MAC$GL_VALUE	;
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	PRMRDX IS CALLED WHEN A RADIX CONTROL PRIMARY HAS BEEN
;	SCANNED.  THE RADIX IS RESET TO THE PREVIOUS RADIX.
;
;--

PRMRDX::				;PRIMARY = RADIX_CONTROL PRIMARY
	CVTLB	W^MAC$AL_VALSTACK-4[R7],- ;RESET TO PREVIOUS
			W^MAC$GB_RDXNDX	  ;RADIX
	RSB

	.SBTTL	PROGRAM COUNTER PRIMARY

;++
; FUNCTIONAL DESCRIPTION:
;
;	PRMPC IS CALLED WHEN A PC REFERENCE (".") IS SCANNED.
;	IF THE EXPRESSION IS BEING EVALUATED ON PASS 2 THE
;	CODE IS EMITTED TO STACK THE PC VALUE.  IF THE EXPRESSION
;	CONTAINS CROSS-PSECT REFERENCES THEN THE EXPRESSION IS
;	NOT A COMPILE-TIME EXPRESSION AND THE FLAG (FLG$M_COMPEXPR)
;	IS CLEARED IN THE FLAGS WORD.
;
;--

PRMPC::					;PRIMARY = DPC
	BBC	#FLG$V_EVALEXPR,(R11),10$ ;BR IF NOT EVALUATE ON PASS 2
	$INTOUT_X INT$_STKPC		;YES--STACK PC
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPRESSION
10$:	MOVL	W^MAC$GL_PC,W^MAC$GL_VALUE ;RETURN VALUE IS PC
	MOVL	W^MAC$GL_PSECTPTR,R0	;GET POINTER TO CURRENT PSECT
	BBC	#PSC$V_REL,PSC$W_OPTIONS(R0),30$
					;BRANCH IF ABS PSECT
	INCL	W^MAC$GL_ABSFLAG	;RELOCATABLE--FLAG NOT ABS EXPR
	TSTL	W^MAC$GL_PRMSEG		;EXPR HAVE A PSECT YET?
	BNEQ	20$			;IF NEQ YES
	MOVL	W^MAC$GL_PSECT,-	;NO--USE CURRENT PSECT
			W^MAC$GL_PRMSEG
	BRB	30$
20$:	CMPL	W^MAC$GL_PRMSEG,-	;YES--CROSS PSECT REFERENCES?
			W^MAC$GL_PSECT
	BEQL	30$			;IF EQL NO
	BICL2	#FLG$M_COMPEXPR,(R11)	;YES--FLAG NOT COMPILE EXPRESSION
30$:	RSB

	.SBTTL	ENTRY POINT MASK ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	RGLST1 AND REGLST ARE CALLED TO ACCUMULATE AN ENTRY-POINT
;	MASK.  RGLST1 IS CALLED FOR THE FIRST ITEM TO INITIALIZE THE
;	ENTRY MASK TO ZERO, AND REGLST IS CALLED FOR EACH SUCCESSIVE
;	ITEM IN THE MASK.  THE APPROPRIATE BIT IN ENTRY_MASK IS
;	SET FOR LATER PROCESSING BY THE 'MASK' ROUTINE.
;
;--

RGLST1::				;REGLIS = MASK_ITEM
	CLRW	W^ENTRY_MASK		;START WITH 0
REGLST::				;REGLIS = REGLIS MASK_ITEM
	MOVL	W^MAC$AL_VALSTACK[R7],R0;GET THE MASK BIT NUMBER
	BBCS	R0,W^ENTRY_MASK,10$	;SET THE BIT IN THE MASK
10$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	MASK IS CALLED WHEN AN ENTRY-POINT MASK HAS BEEN ACCUMULATED
;	IN ENTRY_MASK.  IF WE ARE EVALUATEING EXPRESSIONS THE VALUE
;	WILL BE STACKED IN PASS 2.
;
;--

	.ENABL	LSB

MASK::					;REGISTER_MASK = DUPM DANGOPN REGLIS DANGCLS
	MOVZWL	W^ENTRY_MASK,R0		;PICK UP MASK WORD
	BRB	10$			;FINISH IN COMMON CODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	MASKX IS CALLED WHEN '^MRn' IS SCANNED.  A MASK IS CREATED
;	AND THE VALUE IS SENT TO PASS 2 IF EXPRESSIONS ARE BEING
;	EVALUATED.
;
;--

MASKX::					;REGISTER_MASK = DUPM MASK_ITEM
	MOVL	W^MAC$AL_VALSTACK[R7],R1;GET MASK BIT NUMBER
	CLRL	R0			;START WITH A CLEAN SLATE
	BBCS	R1,R0,10$		;SET THE MASK BIT AND JOIN COMMON CODE
	BRB	10$			;BETTER SAFE THAN SORRY

;++
; FUNCTIONAL DESCRIPTION:
;
;	MASKNL IS CALLED WHEN A NULL ENTRY-MASK IS SCANNED.  IF
;	EXPRESSSIONS ARE BEING EVALUATED, A ZERO  IS STACKED IN
;	PASS 2.
;
;--

MASKNL::				;REGISTER_MASK = DUPM DANGOPN DANGCLS
	CLRL	R0			;RESULT IS 0
10$:	MOVL	R0,W^MAC$GL_VALUE	;STORE RESULT
	BBC	#FLG$V_EVALEXPR,(R11),20$ ;BRANCH IF NO EXPRESSION EVALUATION
	$INTOUT_LW INT$_STKL,<W^MAC$GL_VALUE> ;YES--SEND VALUE TO PASS 2
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPRESSION
20$:	RSB

	.DSABL	LSB

	.SBTTL	EXPRESSIONS

;++
;	VAX-11 MACRO RECOGNIZES DIFFERENT TYPES OF EXPRESSIONS. THESE
;	ROUTINES PROCESS COMPILE-TIME EXPRESSIONS.  THE RESULT OF SUCH
;	AN EXPRESSION IS A LONGWORD WHICH WILL BE KNOWN BY PASS2
;	(OR AT LINK TIME IF THE EXPRESSION INVOLVES GLOBALS OR
;	EXTERNALS).  THE MOST COMMON USAGE OF THIS TYPE OF EXPRESSIONS
;	IS IN OPERANDS.   ANOTHER TYPE OF EXPRESSION IS FOUND IN THE
;	ASSIGNMENT STATMENT WHERE AN EXPRESSION GENERATES CODE TO
;	EVALUATE THE EXPRESSION AT RUN TIME.
;
;	THE 'PRIMITIVE' ROUTINES SET FLAGS DESCRIBING THE EXPRESSION.
;	THESE FLAGS MUST BE INITIALIZED BY THE EXPRESSION CALLER IF
;	THEY ARE TO BE USED.
;
;	FLG$M_COMPEXPR	FALSE IF EXPRESSION VALUE NOT YET KNOWN
;	FLG$M_EVALEXPR	TRUE CAUSES EVALUATION TO OCCUR ON PASS 2
;	FLG$M_ABSEXPR	TRUE INDICATES THAT EXPRESSION IS ABSOLUTE
;
;--

EXPBIN::				;EXPR = EXPR OPBINARY PRIMARY
	MOVL	R7,R5			;COPY STACK POINTER
	$VPUSH	W^MAC$AL_VALSTACK-8[R5]	;PUSH LEFT OPERAND ONTO STACK
	$VPUSH	W^MAC$AL_VALSTACK[R5]	;PUSH RIGHT OPERAND
	MOVL	W^MAC$AL_VALSTACK-4[R5],R6 ;GET COMMAND FROM STACK
	BBC	#FLG$V_EVALEXPR,(R11),10$ ;EVALUEATE ON PASS 2?
	MOVL	R6,R0			;YES--GET COMMAND
	BSBW	MAC$INTOUT_X		;OUTPUT CMD TO INT FILE
	MOVL	R9,W^MAC$GL_EXPEND	;SAVE END OF EXPRESSSION PTR
10$:	TSTL	R6			;WAS ROUTINE SUPPLIED?
	BEQL	40$			;IF EQL NO
	CMPB	R6,#INT$_SUB		;SUBTRACTION?
	BNEQ	20$			;IF NEQ NO
	CMPL	W^MAC$GL_ABSFLAG,#1	;YES--SEVERAL RELATIVE REFS?
	BLEQ	20$			;IF LEQ NO
	BBC	#FLG$V_COMPEXPR,(R11),20$ ;YES--REALLY COMPILE TIME EXPR?
	SUBL2	#2,W^MAC$GL_ABSFLAG	;YES--MAKE RESULT ABSOLUTE
20$:	CLRL	W^MAC$GL_VAL3		;CLEAR EXPRESSION OVERFLOWW IND.
	PUSHL	R6			;SAVE ROUTINE IDENT.
	MOVL	W^P1$ARITH_DISP[R6],R6	;GET ROUTINE ADDRESS
	JSB	(R6)			;CALL ROUTINE
	POPL	R6			;RESTORE ROUTINE IDENT
	MOVL	W^MAC$GL_VAL3,R1	;EXPRESSION OVERFLOW?
	BEQL	50$			;IF EQL NO
	TSTL	W^MAC$GL_ABSFLAG	;YES--ABSOLUTE EXPRESSION?
	BNEQ	50$			;IF NEQ NO
	MOVL	#MAC$_EXPOVR32,R2	; No--assume expression overflow
	CMPB	R6,#INT$_DIV		;UNLESS IT WAS DIVISION
	BNEQ	30$			;IF NEQ NO
	TSTL	R1			;THEN CHECK FOR DIVIDE BY 0
	BGEQ	30$			;IF GEQ THEN NOT DIVIDE BY 0
	MOVL	#MAC$_DIVBYZERO,R2	; It was divide by zero
30$:	$INTOUT_LW INT$_WRN,<R2,W^MAC$GL_ERRPT> ;EMIT ERROR TO PASS 2
	BRB	50$
;
; NO ROUTINE SUPPLIED
;
40$:	$VPUSH	#0			;RESULT IS 0
50$:	$VPOP	W^MAC$GL_VALUE		;POP RESULT INTO MAC$GL_VALUE
	CMPL	W^MAC$GL_ABSFLAG,#1	;SEVERAL RELATIVE REFERENCES?
	BLEQ	60$			;IF LEQ NO
	MOVZBL	#1,W^MAC$GL_ABSFLAG	;YES--CALL IT ONE
60$:	RSB

	.SBTTL	UP-ARROW-A ASCII TEXT PRIMARY

;++
; FUNCTIONAL DESCRIPTION:
;
;	NUMASC IS INVOKED WHEN THE PRODUCTION 'UP-ARROW-A' IS
;	FOUND IN THE INPUT.  IT SCANS THE NEXT CHARACTER AS A
;	DELIMITER, THEN READS TEXT, STORING UP TO THE MAXIMUM
;	NUMBER OF CHARACTERS IN 'MAC$GL_VALUE', LOOKING FOR
;	THE MATCHING DELIMITER.  IF THE MAXIMUM NUMBER OF BYTES
;	FOR THIS OPERAND IS EXCEEDED OR IF END-OF-LINE IS FOUND
;	BEFORE THE MATCHING DELIMITER, A MESSAGE IS OUTPUT
;	TO PASS 2.
;
;--

NUMASC::				;SPECIAL OPERATOR = DUPA
	BBCS	#FLG$V_UPAFLG,(R11),.+1	;FLAG DUPA WAS SEEN
	BSBW	MAC$SKIPSP		;SKIP SPACES AND TABS
	MOVAB	W^MAC$GQ_VALUEQ,R6	;POINT TO RESULT AREA
	CLRQ	(R6)			;CLEAR OUT 8 BYTES
	CLRQ	8(R6)			; and then the next 8 bytes
	MOVL	R10,R5			;COPY DELIMITER
	CMPB	R5,#CR			;IS DELIMITER CR?
	BEQL	20$			;IF EQL YES--ERROR
	MOVZBL	W^MAC$GL_OPSIZE,R4	;GET MAX SIZE OF OPERAND
	BBCS	#FLG$V_DLIMSTR,(R11),.+1 ; PASS ALL CHARACTERS (EVEN -;)
10$:	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	CMPB	R10,R5			;DELIMITER?
	BEQL	30$			;IF EQL YES
	CMPB	R10,#CR			;NO--END OF LINE?
	BEQL	20$			;IF EQL YES--ERROR
	DECL	R4			;NO--ROOM TO STORE BYTE?
	BLSS	10$			;DON'T STORE IF TOO MANY CHARS
	MOVB	R10,(R6)+		;STORE CHARACTER
	BRB	10$			;LOOP FOR MORE
;
; FOUND EOL BEFORE DELIMITER
;
20$:	$MAC_ERR UNTERMARG		; Get message code
	BSBW	MAC$ERRORPT		;ISSUE MESSAGE TO PASS 2
	BBSC	#FLG$V_DLIMSTR,(R11),40$ ;CLEAR ALLCHR AND GO FINISH UP
	BRB	40$			;FINISH
;
; FOUND OTHER DELIMITER
;
30$:	BBSC	#FLG$V_DLIMSTR,(R11),.+1 ;DO NOT PASS ALL CHARACTERS
	BSBW	MAC$GETCHR		;SKIP OVER DELIMITER
40$:	TSTL	R4			;TOO MANY CHARACTERS?
	BGEQ	50$			;IF GEQ NO
	$INTOUT_LW INT$_WRN,<#MAC$_DATATRUNC,W^MAC$GL_ERRPT> ; Yes--report error
50$:
	CMPB	W^MAC$GL_OPSIZE,#8	; Was this a QUAD or OCTA operand?
	BLSS	70$			; No if LSS
	MOVL	W^MAC$GL_VAL3, -	; Yes: save bits 32 to 63
		W^MAC$GL_HIGH_32
	CMPB	W^MAC$GL_OPSIZE,#16	; Was this an OCTA operand?
	BNEQ	70$			; No if NEQ
	MOVQ	W^MAC$GQ_VAL2, -	; Yes: save bits 64 to 127
		W^MAC$GQ_HIGH_64
70$:	BRW	PRMINT			;TREAT AS INTEGER DATA

	.SBTTL	RADIX CONTROL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE FOUR ROUTINES ARE INVOKED WHEN A RADIX CONTROL
;	PRIMARY IS ENCOUNTERED.  THESE ROUTINES SAVE THE
;	OLD RADIX IN MAC$GL_VALUE (FOR LATER RESTORATION) AND
;	SET THE NEW RADIX IN MAC$GB_RDXNDX.
;
;--

RDXBIN::				;RADIX_CONTROL = DUPB
	BSBB	SET_RADIX		;GO SET THE INDEX FOR BINARY
	.BYTE	RDX$V_BINARY

RDXDEC::				;RADIX_CONTROL = DUPD
	BSBB	SET_RADIX		;SET DECIMAL RADIX
	.BYTE	RDX$V_DECIMAL

RDXOCT::				;RADIX_CONTROL = DUPO
	BSBB	SET_RADIX		;SET OCTAL RADIX
	.BYTE	RDX$V_OCTAL

RDXHEX::				;RADIX_CONTROL = DUPX
	BSBB	SET_RADIX		;SET HEX RADIX
	.BYTE	RDX$V_HEX

SET_RADIX:

	MOVZBL	W^MAC$GB_RDXNDX,-	;SAVE CURRENT INDEX
			W^MAC$GL_VALUE
	MOVB	@(SP)+,W^MAC$GB_RDXNDX	;SET NEW RADIX AND CLEAN STACK
	RSB				;RETURN TO CALLER'S CALLER


	.SBTTL	OPERATORS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE OPERATOR ROUTINES ARE CALLED WHEN A BINARY OPERATOR
;	IS ENCOUNTERED IN THE TEXT.  THESE ROUTINES MERELY SET
;	THE OPERATOR NUMBER INTO MAC$GL_VALUE FOR LATER PROCESSING
;	BY THE EXPRESSION EVALUATION ROUTINE (EXPBIN).
;
;--



	.MACRO	OP	OPR
	BSBB	SET_UP_OPERATOR
	.BYTE	INT$_'OPR
	.ENDM


OPPLUS::				;OPBINARY = DDPLUS
	OP	ADD
OPMINU::				;OPBINARY = DDMINUS
	OP	SUB
OPMUL::					;OPBINARY = DDTIMES
	OP	MUL
OPDIV::					;OPBINARY = DDDIV
	OP	DIV
OPAND::					;OPBINARY = DDAND
	OP	AND
OPOR::					;OPBINARY = DDOR
	OP	OR
OPXOR::					;OPBINARY = DDXOR
	OP	XOR
OPASH::					;OPBINARY = DDASH
	OP	ASH
OPCOM::					;OPBINARY = DDUPC
	OP	NOT
OPNEG::					;OPBINARY = DDMINUS
	OP	NEG
OPSAME::				;OPBINARY = DDPLUS
	OP	SAME

SET_UP_OPERATOR:
	MOVZBL	@(SP)+,W^MAC$GL_VALUE	;GET THE OPERATOR NUMBER
	RSB				;RETURN TO CALLER'S CALLER

	.SBTTL	SYMBOL ATTRIBUTE DIRECTIVES -GLOBL/DEBUG/WEAK/EXTRN

;++
; FUNCTIONAL DESCRIPTION:
;
;	GLOBAL/DEBUG/WEAK/EXTRN ARE CALLED WHEN THE CORRESPONDING
;	DIRECTIVE IS SCANNED.  FLAGS ARE SET IN SYM_FLAG FOR THE
;	ROUTINE 'IDLIST'.  'IDLIST' IS CALLED FOR EACH SYMBOL IN
;	THE LIST AND IT SETS THE BITS IN SYM_FLAG IN THE SYMBOL
;	BLOCK FOR THAT SYMBOL.
;
;--

GLOBAL::				;ID_LIST_HEAD = KGLOBL
	BSBB	SET_SYM_FLAG		;SET FLAG TO REMEMBER
	.WORD	SYM$M_GLOBL

DEBUG::					;ID_LIST_HEAD = KDEBUG
	BSBB	SET_SYM_FLAG		;SET FLAGS TO REMEMBER
	.WORD	SYM$M_DEBUG!SYM$M_REF

WEAK::					;ID_LIST_HEAD = KWEAK
	BSBB	SET_SYM_FLAG		;SET FLAGS TO REMEMBER
	.WORD	SYM$M_WEAK!SYM$M_GLOBL

EXTRN::					;ID_LIST_HEAD = KEXTRN
	BSBB	SET_SYM_FLAG		;SET THE FLAG
	.WORD	SYM$M_EXTRN


SET_SYM_FLAG:
	MOVW	@(SP)+,W^SYM_FLAG	;REMEMBER THE FLAG BIT
	RSB				;RETURN TO CALLER'S CALLER

;++
; FUNCTIONAL DESCRIPTION:
;
;	AFTER A GLOBAL/DEBUG/WEAK/EXTRN DIRECTIVE HAS BEEN SCANNED,
;	'IDLIST' IS CALLED FOR EACH SYMBOL IN THE LIST OF SYMBOLS
;	ACCOMPANYING THE DIRECTIVE.  THE FLAGS CONTAINED IN SYM_FLAG
;	ARE SET FOR THE SYMBOL.  IF THE DIRECTIVE IS .EXTRN AND
;	THE SYMBOL IS ALREADY DEFINED, AN ERROR MESSAGE IS ISSUED
;	TO PASS 2.
;
;--

IDLIST::				;ID_LIST = ID
	MOVL	W^MAC$AL_VALSTACK[R7],R6;GET POINTER TO SYMBOL BLOCK
	BBC	#SYM$V_EXTRN,W^SYM_FLAG,10$ ;BRANCH IF NOT .EXTRN
	BBC	#SYM$V_DEF,SYM$W_FLAG(R6),10$ ;BRANCH IF SYMBOL NOT DEFINED
	$MAC_ERR SYMDEFINMO		; Yes--get error message
	BSBW	MAC$ERRORPT		;SYMBOL DECLARED EXTERNAL BUT ALREADY DEFINED
10$:	BISW	W^SYM_FLAG,SYM$W_FLAG(R6) ;SET BIT(S) IN SYMBOL FLAGS
	BBC	#SYM$V_DEBUG,SYM$W_FLAG(R6),20$ ;BRANCH IF NOT .DEBUG
	BBSC	#SYM$V_SUPR,SYM$W_FLAG(R6),.+1 ;.DEBUG--CLEAR SUPR BIT
20$:	MOVZBL	#CRF$K_REF,R5		;SET REFERENCE
	MOVL	MAC$GL_PSECTPTR,R0	;GET POINTER TO PSECT DATA
	BBC	#PSC$V_REL, -		;IF ABS PSECT
		PSC$W_OPTIONS(R0),30$	;THEN SKIP
	BISW2	#SYM$M_RELPSECT,SYM$W_FLAG(R6)	;SET REL PSECT FLAG
30$:	BRW	MAC$CREF_SYM		;CREF SYMBOL IF CREFFING AND RETURN

	.END
