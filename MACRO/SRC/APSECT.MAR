	.TITLE	MAC$APSECT	PROCESS PSECT RELATED DIRECTIVES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V01.10	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.09	RN0013		R. Newland	27-Sep-1979
;		Use new symbols for PSECT option processing
;
;	V01.08	RN0005		R. Newland	12-Aug-1979
;		Variable symbol names and remove .ALIGN LONG statements
;
;	V01.07	008		B. Schreiber		23-JAN-1979
;		Clear PSECT Block before using it.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_INTCODDEF			;DEFINE INT. BUFFER CODES
	$MAC_SYMBLKDEF			;DEFINE SYMBOL/PSECT BLOCK OFFSETS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

	.SBTTL	PSECT	PROCESS .PSECT STATEMENT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE FULLY PROCESSES THE .PSECT STATEMENT.  THE
;	OPTIONS ARE PARSED AND A PSECT BLOCK IS ALLOCATED AND
;	FILLED IN.
;
;--

PSECT::					;DIRECTIVE = KPSECT
	BLBS	W^ENB$G_LOCALSYMB+SYM$L_VAL,10$ ;BRANCH IF ENABLE LSB
	BSBW	MAC$SET_NEW_LSB		;NO--MAKE A NEW LSB NOW
10$:	BSBW	MAC$SET_PC		;RECORD HIGH PC
	BSBW	MAC$SYMSCNUP		;GET THE PSECT NAME
	BLBC	R0,50$			;BRANCH IF NO PSECT NAME
	MOVAB	W^MAC$GL_PSC_LIST,R6	;YES--POINT TO PSECT LIST
	MOVL	R6,R2			;COPY IN CASE NOTHING IN LIST
	MOVL	SYM$L_LINK(R6),R5	; Get next PSECT entry
	BEQL	20$			;BRANCH IF NO PSECTS YET
	BSBW	MAC$SRC_LIST		;SEE IF PSECT ALREADY DECLARED
	MOVL	R1,R6			;COPY RESULT IF FOUND
	BLBS	R0,60$			;BRANCH IF FOUND
20$:	PUSHL	R2			;STACK ADDRESS OF PREVIOUS
	MOVL	W^MAC$GL_PSC_BLKP,R0	;GET POINTER TO PSECT 2K BLOCK
	BNEQ	40$			;IF NEQ GO USE IT
30$:	BSBW	MAC$ALL_2_PAGES		;ALLOCATE TWO PAGES
	MOVL	R0,W^MAC$GL_PSC_BLKP	;SAVE ADDRESS FOR LATER
	MOVZWL	#<1024-8>,(R0)		; Set # bytes in first longword
	MOVAB	8(R0),4(R0)		;SET 2ND LONGWORD AS POINTER TO FREE
40$:	MOVZBL	W^MAC$AB_TMPSYM,R1	; Get size of name
	INCL	R1			; Include count byte
	SUBL2	R1,(R0)			; Subtract from bytes available
	SUBL2	#PSC$K_BLKSIZ,(R0)+	; and subtract fixed part size
	BLSS	30$			;IF LSS NO--GO ALLOCATE ANOTHER
	MOVL	(R0),R6			;GET POINTER TO PSECT BLOCK
	ADDL2	R1,(R0)			; Set pointer to end of allocated
	ADDL2	#PSC$K_BLKSIZ,(R0)	; block
	MOVB	R1,-(SP)		; Save total length
	MOVC3	R1,W^MAC$AB_TMPSYM,(R6)	; Copy symbol count/name
	MOVL	R3,R6			; Save pointer to block
	MOVC5	#0,(SP),#0,#PSC$K_BLKSIZ,(R3) ; Clear rest of block
	MOVB	(SP)+,SYM$B_NAME(R6)	; Store offset to name
	POPL	R2			;GET POINTER TO PREVIOUS PSECT BLOCK
	MOVL	SYM$L_LINK(R2), -	; Link in new PSECT block
		SYM$L_LINK(R6)
	MOVL	R6,SYM$L_LINK(R2)	; ...
	BRB	60$
50$:	MOVAB	W^PSECT$BLANK,R6	;USE THE BLANK PSECT
60$:	BISW2	#SYM$M_REF,PSC$W_FLAG(R6) ;FLAG PSECT AS REFERENCED
	BSBW	MAC$PSC_OPT_SCN		;SCAN PSECT OPTIONS
	$INTOUT_LW INT$_PSECT,R6	;SWITCH TO NEW PSECT IN PASS 2
	MOVL	PSC$L_MAXLGTH(R6),W^MAC$GL_PC ;SET NEW PC
	MOVZBL	PSC$B_SEG(R6),W^MAC$GL_PSECT ;AND NEW PSECT
	MOVL	R6,W^MAC$GL_PSECTPTR
	RSB

	.SBTTL	SCAN PSECT OPTIONS

MAC$PSC_OPT_SCN:
	PUSHL	R7			;SAVE R7
	BBC	#SYM$V_DEF,SYM$W_FLAG(R6),10$ ;BRANCH IF PSECT NOT DEFINED
	MOVZWL	PSC$W_OPTIONS(R6),R7	;DEFINED---GET DEFINED OPTIONS
	MOVL	R7,-(SP)		;COPY TO -(SP) FOR POSITIVE OPTIONS
	MCOML	R7,-(SP)		;COPY COMPLEMENTED OPTIONS TO -(SP)
	BRB	20$
10$:	MOVZWL	#PSC$M_DEFAULT,R7	;NEW PSECT--SET DEFAULT OPTIONS
	CLRL	-(SP)			;CLEAR POS. AND NEG. OPTIONS
	CLRL	-(SP)			;...
20$:

OPTION_SCAN:
	CMPB	R10,#CR			;END OF LINE?
	BNEQ	10$			;IF NEQ NO
5$:	BRW	130$			;YES--EXIT
10$:	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;SCAN TO A COMMA?
	BNEQ	20$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
	BSBW	MAC$SKIPSP		;SKIP SPACES AGAIN
	BRB	OPTION_SCAN		;CK FOR EOL AGAIN
20$:	CMPB	R10,#CR			;GET TO EOL?
	BEQL	5$			;IF EQL YES--ALL DONE
25$:	BBC	#CHR$V_NUM_BER,-	;BRANCH IF NOT NUMERIC
		W^MAC$AB_CMSK_TAB(R10),60$
	BBC	#PSC$V_ALIGNFLG,(SP),30$ ;YES--WAS ALIGNMENT SEEN?
	BSBW	OPTION_CONFLICT		;YES--REPORT CONFLICT
	BSBW	MAC$SKP_OPR		;SKIP TO COMMA OR EOL
	BRB	OPTION_SCAN		;AND SCAN NEXT OPTION
30$:	BSBW	MAC$DNUMBER		;ACCUMULATE NUMERIC ALIGNMENT
	MOVL	W^MAC$GL_VALUE,R5	;GET ALIGNMENT SCANNED
	CMPL	R5,#9			;LEGAL ALIGNMENT?
	BLEQU	40$			;IF LEQU YES
	MOVZBL	#9,R5			;NO--USE PAGE ALIGNMENT
	$MAC_ERR INVALIGN		; Get error message code
	BSBW	MAC$ERRORLN		;REPORT ERROR TO PASS 2
40$:	ASHL	#PSC$V_ALIGNMENT,R5,R5	; Position alignment
	BBCS	#PSC$V_ALIGNFLG,R5,50$	;SET ALIGNMENT FLAG
50$:	BISL2	R5,R7			;SET IN OPTIONS
	BISL2	R5,(SP)			;SET IN COMPL. OPTIONS FOR CHECK
	BRB	OPTION_SCAN		;CONTINUE SCANNING
;
; NOT A NUMBER
;
60$:	BSBW	MAC$SYMSCNUP		;SCAN THE OPTION NAME
	BLBS	R0,70$			;BRANCH IF OPTION SCANNED
	$MAC_ERR DIRSYNX		; No--get message code
	BSBW	MAC$ERRORLN		;REPORT ERROR TO PASS 2
	BSBW	MAC$SKP_OPR		;SKIP TO COMMA OR EOL
	BRB	OPTION_SCAN		;SCAN NEXT OPTION
;
; LOOK UP THE OPTION
;
70$:	MOVAB	W^PSC$G_OPTIONS,R5	;POINT TO THE OPTIONS
	BSBW	MAC$SRC_LIST		;LOOK IT UP
	BLBS	R0,80$			;BRANCH IF FOUND
	$MAC_ERR NOTPSECOPT		; No--get error code
	BSBW	MAC$ERRORLN		;ISSUE ERROR TO PASS 2
	BRW	OPTION_SCAN		;SCAN NEXT OPTION
80$:	CVTWL	SYM$L_VAL(R1),R5	;GET BITS FOR OPTION
	BGTR	100$			;IF GTR NOT COMPLEMENT OF OPTION
	MCOML	R5,R5			;COMPLEMENTED--GET UNCOMPLEMENTED
	BITL	R5,4(SP)		;POSITIVE SET?
	BEQL	90$			;IF EQL NO
	BSBW	OPTION_CONFLICT		;YES--ISSUE MESSAGE
	BRB	120$			;CONTINUE SCAN
90$:	BICL2	R5,R7			;CLEAR OPTION
	BISL2	R5,(SP)			;SET IN NEGATIVE MASK
	BRB	120$			;CONTINUE SCANNING
;
; POSITIVE SENSE OPTION
;
100$:	BITL	R5,(SP)			;WAS COMPLEMENT SET?
	BEQL	110$			;IF EQL NO
	BSBW	OPTION_CONFLICT		;YES--REPORT ERROR
	BRB	120$			;CONTINUE SCANNING
110$:	BISL2	R5,R7			;SET IN OPTIONS WORD
	BISL2	R5,4(SP)		;AND IN POSITIVE MASK
	BBC	#PSC$V_ALIGNFLG,R5,120$	;IS THIS AN ALIGNMENT OPTION?
	BISL2	R5,(SP)			;YES--SET IN NEG. MASK
120$:	BRW	OPTION_SCAN		;CONTINUE SCANNING OPTIONS
;
; DONE SCANNING OPTIONS
;
130$:	BBS	#SYM$V_DEF,PSC$W_FLAG(R6),150$ ;BRANCH IF NOT NEW PSECT
	BISW2	#SYM$M_DEF!SYM$M_REF,PSC$W_FLAG(R6) ;NEW--MARK DEFINED
						    ;AND REFERENCED
	MOVW	R7,PSC$W_OPTIONS(R6)	;SET THE OPTIONS
	$INTOUT_LW INT$_NEWP,R6		;DEFINE NEW PSECT IN PASS 2
	INCL	W^MAC$GL_PSC_MAX	;COUNT ANOTHER PSECT
	CMPW	W^MAC$GL_PSC_MAX,#256	;DO WE HAVE TOO MANY PSECTS?
	BLEQU	140$			;IF LEQU NO
	$MAC_ERR TOOMNYPSEC		; Yes--get code
	BSBW	MAC$ERRORLN		;SEND TO PASS 2
140$:	MOVB	W^MAC$GL_PSC_MAX,PSC$B_SEG(R6) ;SET THE PSECT NUMBER
	CLRL	PSC$L_MAXLGTH(R6)	;CLEAR MAX LENGTH
	CLRL	PSC$L_CURLOC(R6)	;START AT 0
150$:	ADDL2	#2*4,SP			;CLEAR TWO WORDS FROM STACK
	POPL	R7			;RESTORE R7
	RSB

OPTION_CONFLICT:
	$MAC_ERR PSECOPCNFL		; Get message code
	BRW	W^MAC$ERRORLN		;ISSUE MESSAGE AND RETURN

	.SBTTL	PROCESS .SAVE DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	CSAVE IS CALLED TO PROCESS THE .SAVE DIRECTIVE.  THE
;	NUMBER OF THE CURRENT PSECT IS SAVED IN THE PSECT
;	SAVE BUFFER.  THE PC FOR THE CURRENT PSECT IS SAVED
;	IN PSC$L_CURLOC OF THE CURRENT PSECT'S PSECT SYMBOL BLOCK.
;
;--

CSAVE::					;DIRECTIVE = KSAVE
	MOVZBL	W^MAC$GL_PSC_SBP,R6	;GET BUFFER INDEX
	CMPB	R6,#31			;OVERFLOW?
	BLEQU	10$			;IF LEQU NO
	$MAC_ERR PSECBUFOVF		; Yes--get message code
	MOVL	#CR,R10			;FORCE END OF LINE
	BRW	MAC$ERRORLN		;ISSUE AND RETURN
10$:	MOVB	W^MAC$GL_PSECT,L^MAC$AB_PSC_SBF(R6) ;SAVE PSECT NUMBER
	INCL	W^MAC$GL_PSC_SBP	;BUMP THE INDEX
	MOVL	W^MAC$GL_PSECTPTR,R2	;GET POINTER TO PSECT BLOCK
	MOVL	W^MAC$GL_PC,PSC$L_CURLOC(R2) ;SAVE CURRENT PC
	$INTOUT_LW INT$_SAVE,R2		;ISSUE SAVE TO PASS 2
	BSBW	MAC$SYMSCNUP		;SEE IF THERE IS AN ARGUMENT
	BLBS	R0,30$			;BRANCH IF THERE WAS
	CMPB	R10,#CR			;NO--BUT DID WE GET TO EOL?
	BEQL	40$			;IF EQL YES
20$:	$MAC_ERR DIRSYNX		; No--call it directive syntax
	BRW	MAC$ERRORLN		;REPORT THE ERROR
30$:	MOVAB	W^MAC$G_LSBNAM,R5	;POINT TO LSB NAMES
	BSBW	MAC$SRC_LIST		;SEE IF IT IS LEGAL FOR LSB
	BLBC	R0,20$			;BRANCH IF ILL ARG
	MOVL	W^MAC$GL_LSB,L^MAC$AL_PSC_SLB[R6] ;YES--SAVE LSB
	BRB	50$			;AND EXIT
40$:	CLRL	L^MAC$AL_PSC_SLB[R6]	;ENSURE NO LSB SAVED
50$:	RSB

	.SBTTL	PROCESS .RESTORE DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	CRESTO IS CALLED TO PROCESS THE .RESTORE PSECT DIRECTIVE.
;	CODE IS EMITTED TO PASS 2 TO SWITCH PSECTS.
;
;--

CRESTO::				;DIRECTIVE = KRESTORE
	BSBW	MAC$SET_PC		;RECORD HIGH PC
	MOVL	W^MAC$GL_PSC_SBP,R6	;GET SAVE BUFFER INDEX
	BGTR	10$			;IF GTR OK
	$MAC_ERR PSECBUFUND		; No--get error code
	BSBW	MAC$ERRORPT		;REPORT TO PASS 2
	RSB				;RETURN
10$:	DECL	R6			;BACK UP THE INDEX
	MOVL	R6,W^MAC$GL_PSC_SBP	;SAVE INDEX
	MOVZBL	L^MAC$AB_PSC_SBF(R6),R0 ;GET THE PSECT INDEX
	CMPB	R0,#1			;BLANK PSECT?
	BNEQ	20$			;IF NEQ NO
	MOVAB	W^PSECT$BLANK,R5	;YES--SET FOR IT
	BRB	50$			;
20$:	MOVL	W^MAC$GL_PSC_LIST,R5	;POINT TO PSECT LIST
	BEQL	MAC$PSC_RES_ERR		;IF EQL NOTHING THERE
30$:	CMPB	R0,PSC$B_SEG(R5)	;IS THIS THE RIGHT PSECT?
	BEQL	50$			;IF EQL YES
	MOVL	(R5),R5			;NO--LINK TO NEXT
	BNEQ	30$			;IF NEQ KEEP LOOKING
	BRB	MAC$PSC_RES_ERR		;PSECT RESTORE ERROR
50$:	$INTOUT_LW INT$_REST,R5		;ISSUE RESTORE TO PASS 2
60$:	MOVL	R5,W^MAC$GL_PSECTPTR	;SET NEW PSECT POINTER
	MOVZBL	PSC$B_SEG(R5),W^MAC$GL_PSECT ;AND NEW PSECT NUMBER
	MOVL	PSC$L_CURLOC(R5),W^MAC$GL_PC ;SET NEW PC
	MOVL	L^MAC$AL_PSC_SLB[R6],R0	;GET THE SAVED LSB NUMBER
	BEQL	70$			;IF EQL NO SAVED PSECT NUMBER
	MOVL	R0,W^MAC$GL_LSB		;SET NEW LSB
70$:	RSB

MAC$PSC_RES_ERR::
	CALLS	#0,W^MAC$ERR_INTERN	;REPORT INTERNAL DIFFICULTIES
	BRW	MAC$LAST_CHANCE		;STAY TUNED FOR QUICK EXIT

	.SBTTL	ALIGNMENT DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS DIRECTIVE CAUSES THE PC TO BE ALIGNED TO THE SPECIFIED
;	BOUNDARY, WITH THE OPTION OF THE SKIPPED BYTES BEING FILLED
;	WITH A FILL EXPRESSION.
;
;--

ALIGN::					;ALSIGN_HEAD = KALIGN
	BBCC	#FLG$V_EVALEXPR,(R11),.+1 ;DON'T OUTPUT EXPRESSION
	BBCS	#FLG$V_EXPOPT,(R11),.+1	;ASSUME NICE EXPRESSION
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE
	BSBW	MAC$SKIPSP		;SKIP SPACES
	BBC	#CHR$V_NUM_BER,-	;BRANCH IF NOT NUMERIC
		W^MAC$AB_CMSK_TAB(R10),30$
	BSBW	MAC$DNUMBER		;YES--GET IT
	MOVW	W^MAC$GL_VALUE,R0	;GET THE RESULT
	ASHL	R0,#1,R1		;GET 2**(VALUE)
	BRB	70$			;FINISH UP
;
; SYMBOLIC ALIGNMENT
;
30$:	BSBW	MAC$SYMSCNUP		;SCAN THE SYMBOL
	BLBC	R0,50$			;BRANCH IF NO SYMBOL SCANNED
	MOVAB	W^PSC$G_OPTIONS,R5	;POINT TO PSECT OPTIONS
	BSBW	MAC$SRC_LIST		;LOOK IT UP
	BLBC	R0,50$			;BRANCH IF NOT FOUND
	MOVL	SYM$L_VAL(R1),R0	;GET THE BITS FOR SYMBOL
	BITW	#PSC$M_ALLOPTNS,R0	; Is this an alignment?
	BEQL	60$			;IF EQL YES
;
; INVALID ALIGNMENT
;
50$:	$MAC_ERR INVALIGN		; Get message code
	BSBW	MAC$ERRORLN		;ISSUE TO PASS 2
	CLRQ	R0			;DO NO ALIGNING
	BRB	70$			;...
;
; FINISH SYMBOL ALIGNMENT
;
60$:	EXTZV	#PSC$V_ALIGNMENT,-	;GET EXPONENT VALUE FOR KEYWORD
		#PSC$S_ALIGNMENT,R0,R0
	ASHL	R0,#1,R1		;CALCULATE ALIGNMENT FACTOR
70$:	MOVL	W^MAC$GL_PSECTPTR,R2	;POINT TO CURRENT PSECT
	EXTZV	#PSC$V_ALIGNMENT,-	;GET PSECT ALIGNMENT
		#PSC$S_ALIGNMENT,-
		PSC$W_OPTIONS(R2),R3
	ASHL	R3,#1,R4		;CALCULATE PSECT ALIGNMENT
	CMPL	R1,R4			;ALIGNMENT TOO BIG
	BLEQU	80$			;IF LEQU NO
	$MAC_ERR ALIGNXCEED		; Yes--set code
	BSBW	MAC$ERRORLN		;ISSUE TO PASS 2
	MOVL	R4,R1			;USE PSECT ALIGNMENT
80$:	MOVL	R1,W^MAC$GL_EXPOPVL1	;STORE VALUE FOR ALIGN1/ALIGN2
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	ALIGN1/ALIGN2 ARE CALLED TO FINISH PROCESSING THE .ALIGN
;	DIRECTIVE.  IF NECESSARY, THE PC IS ADJUSTED AND, IF THIS
;	IS ALIGN2, THEN THE FILL IS EMITTED TO PASS 2 ALSO.
;
;--

ALIGN1::				;DIRECTIVE = ALIGN_HEAD
	BBCC	#FLG$V_DATRPT,(R11),ALIGN_COM ;FLAG NO FILL EXPRESSION
	BRB	ALIGN_COM		;(YOU NEVER CAN TELL...)

ALIGN2::				;DIRECTIVE = ALIGN_HEAD EXPR
					;DIRECTIVE = ALIGN_HEAD DCOMMA EXPR
	BBCS	#FLG$V_DATRPT,(R11),ALIGN_COM ;FLAG FILL EXPRESSION PRESENT
ALIGN_COM:
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BEQL	10$			;IF EQL YES
	$MAC_ERR INVALIGN		; No--get error code
	BSBW	MAC$ERRORPT		;ISSUE ERROR TO PASS 2
10$:	MOVL	W^MAC$GL_EXPOPVL1,R2	;GET THE ALIGNMENT FACTOR
	BEQL	40$			;IF EQL NONE
	MOVL	R2,R3			;COPY IT
	DECL	R2			;
	MCOML	R2,R2			;AND COMPLEMENT
	MOVL	W^MAC$GL_PC,R1		;GET CURRENT PC
	BICL2	R2,R1			;
	BEQL	40$			;IF EQL NO ADJUSTMENT NEEDED
	SUBL2	R1,R3			;
	PUSHL	R3			;
	BBSC	#FLG$V_DATRPT,(R11),20$	;IS THERE A FILL?
	$INTOUT_LW INT$_AUGPC,R3	;NO--AUGMENT PC
	BRB	30$			;AND EXIT
;
; THERE IS A FILL
;
20$:	$INTOUT_LW INT$_STKL,<W^MAC$AL_VALSTACK[R7]> ;STACK THE FILL EXPR
	$INTOUT_LW INT$_STKL,R3		;STACK THE FILL COUNT
	$INTOUT_X INT$_STRB		;STORE REPEATED BYTE
30$:	POPL	R3			;GET THE PC AUGMENTATION
	$INC_PC	R3			;ADJUST PC IN PASS 1 ALSO
40$:	RSB

	.END
