	.TITLE	MAC$SCANER SCANNING ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 29-AUG-78
;
; MODIFIED BY:
;
;	V02.16	PCG0008		Peter George		26-Aug-1981
;		Fix handling of floating point literals.
;
;	V02.15	CNH0040		Chris Hume		15-Oct-1980
;		.ENDC ignored after local label in conditional suppressed
;		code.  (ACTIF.MAR 02.06)
;
;	V02.14	HJ0001		Herb Jacobs	14-Aug-1980
;		Performance improvement to symbol table search
;
;	V01.13	RN0023		R. Newland		 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.12	RN0014		R. Newland		12-Oct-1979
;		Support for G_floating, H_floating and Octaword data types
;
;	V01.12	RN0015		R. Newland		11-Oct-1979
;		Fix problem with top 32 bits of quadword number.
;		SPR 11-26479
;
;	V01.11	RN0008		R. Newland		29-Aug-1979
;		31 character symbols
;
;	V01.10	RN0005		R. Newland		14-Aug-1979
;		Variable symbol storage and remove .ALIGN LONG
;		and .DEBUG statements
;
;	V01.09	008		B. Schreiber		22-JAN-1979
;		Better bookkeeping of pages allocated so they can
;		be deallocated on multiple assemblies.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_GENVALDEF			;USEFUL SYMBOLS
	$MAC_SYMBLKDEF			;SYMBOL BLOCK DEFINITIONS
	$MAC_GRAMMARDEF			;TERMINAL GRAMMAR SYMBOLS
	$MAC_INTCODDEF			;INTERMEDIATE CODE DEFINTIONS
	$MAC_CTLFLGDEF			;CONTROL FLAG DEFINITIONS
	$MAC_CRFLAGDEF			;DEFINE CREF CONTROL FLAGS
	$MAC_OPRDEF			;DEFINE OPERAND DESCRIPTOR BITS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG


TWO_CHR_REG_NAM:			;TABLE OF NAMES FOR TWO CHAR REGISTERS
	.ASCII	/R0R1R2R3R4R5R6R7R8R9SPPCAPFPIVDV/
TWO_CHR_REG_SIZ=.-TWO_CHR_REG_NAM	;SIZE OF TABLE
TWO_CHR_REG_VAL:			;VALUES ASSOCIATED WITH ABOVE REGS
	.BYTE	0,1,2,3,4,5,6,7,8,9,14,15,12,13,14,15

	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG
MAC$AL_RGNM_TAB::			;POINTER TO REGISTER NAME SYMBOL
					;BLOCKS (USED FOR CREF)
	.IRP	FOO,<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP,SP,PC>
	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG
	.LONG	REG_SYMB_'FOO
	.PSECT	MAC$RW_DATA,WRT,NOEXE,LONG
	$MAC_INSERT_SYM 'FOO,,,REG_SYMB_'FOO
	$MAC_INSERT_SYM 'FOO
	.ENDM

	.SBTTL	MAC$SYMBOL SCAN NEXT SYMBOL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ACCUMULATES A SYMBOL NAME IN 'MAC$AB_TMPSYM'.
;	THE SYMBOL IS THEN LOOKED UP IN THE APPROPRIATE SYMBOL
;	TABLES (BASED ON THE POSITION IN THE LINE).  THE TOKEN TYPE
;	IS RETURNED IN R8 AND THE POINTER TO THE SYMBOL BLOCK
;	IS RETURNED IN 'MAC$GL_VALUE'.
;
;--

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

MAC$SYMBOL::
	BSBW	MAC$SYMSCNUP		;ACCUMULATE SYMBOL NAME
	BBC	#FLG$V_BOL,(R11),100$	;BR IF NOT AT BEGINNING OF LINE
	BSBW	MAC$SKIPSP		;SKIP OVER SPACES
	CMPB	R10,#^A/:/		;DID WE FIND A LABEL?
	BNEQ	10$			;IF NEQ NO
	BSBB	MAC$CHKREG		;YES--RETURN TOKEN TYPE IN R8
	BRB	200$			;GO RETURN
;
; NO LONGER AT BEGINNING OF LINE--SEE IF ASSIGNMENT
;
10$:	BICL2	#FLG$M_BOL,(R11)	;DO NOT ALLOW ANY MORE LABELS
	CMPB	R10,#^A/=/		;ASSIGNMENT STATEMENT?
	BNEQ	100$			;IF NEQ NO
	BSBB	MAC$CHKREG		;YES--RETURN TOKEN TYPE IN R8
	CMPB	R8,#ID			;WAS IT AN ID?
	BNEQ	200$			;IF NEQ GO EXIT
	BBCS	#FLG$V_OPRND,(R11),200$	;YES--NOW IN OPERAND FIELD
	BRB	200$
;
; IN OPERAND FIELD?
;
100$:	BBC	#FLG$V_OPRND,(R11),110$	;BR IF NOT IN OPERAND FIELD
	BSBB	MAC$CHKREG		;RETURN TOKEN TYPE IN R8
	BRB	200$			;
110$:	MOVAB	W^MAC$AL_UMCHSHTB,R3	; Look in user macro table
	BSBW	MAC$SRCSYMTAB		;...
	BLBC	R0,120$			;IF LBC THEN NOT FOUND
	MOVZBL	#MACTXT,R8		;FOUND--RETURN TOKEN FOR MACRO
	BRB	200$
;
; NOT A MACRO--LOOK THROUGH PERMANENT SYMBOL TABLE
;
120$:	MOVL	W^MAC$GL_OPCLSTPT,R5	;GET POINTER TO USER-DEFINED OPCODES
	BEQL	122$			;IF EQL NONE DEFINED
	BSBW	MAC$SRC_LIST		;SEE IF USER-DEFINED OPCODE
	BLBS	R0,124$			;IF LBS YES--GO PROCESS IT
122$:	MOVAB	MAC$AL_PRMHSHTB,R3	;NO--LOOK IN PERMANENT SYMBOL TABLE
	BSBW	MAC$SRCSYMTAB		;...
	BLBC	R0,130$			;IF LBC THEN NOT FOUND
124$:	MOVZBL	SYM$B_TOKEN(R1),R8	;PICK UP TOKEN FOR SYMBOL
	CMPB	R8,#DOPCODE		;WAS THIS AN OPCODE?
	BEQL	125$			;IF EQL YES
	BSBW	MAC$CREF_DIR		;NO--DIRECTIVE--CREF IT IF CREFFING
					;    DIRECTIVES.
125$:	BBCS	#FLG$V_OPRND,(R11),200$	;NOW IN OPERAND FIELD
	BRB	200$
;
; NOT FOUND--TRY AN IMPLICIT .MCALL
;
130$:	BSBW	MAC$IMPLMCALL		;TRY AN IMPLICIT MCALL
;**;	BRB	200$			;RETURN WITH TOKEN
;
; SET POINTER TO SYMBOL BLOCK IN MAC$GL_VALUE
;
200$:	MOVL	R1,W^MAC$GL_VALUE	;RETURN POINTER TO SYMBOL BLOCK
220$:	RSB

	.SBTTL	MAC$CHKREG IS SCANNED SYMBOL A REGISTER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS TO SEE IF THE SYMBOL SCANNED BY MAC$GETSYM
;	IS A REGISTER NAME, AND IF NOT, SEARCHES FOR IT IN THE USER'S
;	SYMBOL TABLE.  IF THE SYMBOL IS NOT IN THE USER'S SYMBOL TABLE
;	IT IS INSERTED.  IN ANY CASE, THE TOKEN VALUE RETURNED IN R8
;	IS EITHER 'ID' OR 'RRREG'. IF 'RRREG', THE REGISTER VALUE
;	WILL BE RETURNED IN R1. IF 'ID', THE SYMBOL BLOCK ADDRESS
;	WILL BE RETURNED IN R1.
;--

MAC$CHKREG:
	BSBW	MAC$REGIS		;SEE IF SYMBOL IS A REGISTER NAME
	TSTL	R8			;IS IT A REGISTER?
	BNEQ	10$			;IF NEQ YES
	BSBW	MAC$INSUSRSYMTB		;NO--INSERT SYMBOL IN USER SYMBOL TABLE
	MOVZBL	#ID,R8			;RESULT ALWAYS ID
10$:	RSB

	.SBTTL	MAC$SYMNUM LETTERS A-F CAN START SYMBOL OR NUMBER

MAC$SYMNUM::
	CMPB	W^MAC$GB_RDXNDX,-	;ARE WE GOING TO GET HEX NUMBER?
			#RDX$V_HEX	; ...
	BEQL	MAC$NUMBER		;IF EQL YES
	CMPB	R10,#^A/B/		;CAN SYMBOL BE 'B^'?
	BEQL	MAC$XSYMBL		;YES--SEE IF 'B^'
	CMPB	R10,#^A/b/		;OR LOWER CASE 'b^'?
	BEQL	MAC$XSYMBL		;YES--SEE IF 'b^'
	BRW	MAC$SYMBOL		;NO--GO SCAN SYMBOL

	.SBTTL	MAC$XSYMBL NEXT CHARACTER CAN BE AN UPARROW

;++
;	CHECK IF NEXT CHARACTER IS AN UPARROW.  IF IT IS THEN THIS IS
;	A WIDTH INDICATOR.
;
;--

MAC$XSYMBL::
	CMPB	@W^MAC$GL_LINEPT,#^A/^/	;NEXT CHAR AN UPARROW?
	BEQL	20$			;IF EQL YES--CONTINUE
10$:	BRW	MAC$SYMBOL		;NO--GO SCAN A SYMBOL
20$:	LOCC	R10,#LEN$K_XUPTAB,-	;LOOKUP CHARACTER IN XUPTAB
			W^MAC$AB_XUPTAB	; to see if it can preceded '^'
	BEQL	10$			;IF EQL NOT IN TABLE--SCAN SYMBOL
	SUBL3	#MAC$AB_XUPTAB,R1,R2	;GET INDEX INTO TABLE FOR CHARACTER
	MOVZBL	MAC$AB_XUPTOKEN[R2],R8 ;RETREIVE TOKEN VALUE
	BSBB	30$			;SCAN OVER THE CHARACTER
30$:	BRW	MAC$GETCHR		;SCAN OVER UPARROW AND RETURN
					;  WITH TOKEN VALUE

	.SBTTL	MAC$NUMBER ACCUMULATE NUMBER

MAC$NUMBER::
	MOVZBL	W^MAC$GB_RDXNDX,R0	;GET INDEX FOR NUMBER GETTER
	MOVL	W^NUM_TAB[R0],R0	;GET ADDRESS OF ROUTINE TO READ NUMBER
	JMP	(R0)			;AND GO GET THE NUMBER

NUM_TAB:.LONG	MAC$BINNUM		;(0) BINARY
	.LONG	MAC$OCTNUM		;(1) OCTAL
	.LONG	MAC$DNUMBER		;(2) DECIMAL
	.LONG	MAC$HEXNUM		;(3) HEX
	.LONG	MAC$GETFLOAT		;(4) F FLOATING
	.LONG 	MAC$GETDOUBLE		;(5) D FLOATING
	.LONG	MAC$GETGFLOAT		;(6) G FLOATING
	.LONG	MAC$GETHFLOAT		;(7) H FLOATING

	.SBTTL	MAC$SYMSCN SCAN FOR SYMBOL NAME

;++
;	THIS ROUTINE IS CALLED BY SEVERAL DIRECTIVES TO SCAN
;	A NAME FROM THE INPUT LINE.  LEADING SPACES AND TABS
;	ARE IGNORED.  IF NOT FOUND, R0 IS SET TO 0.
;
;--

	.ENABL	LSB
MAC$SYMSCNUP::
	BSBB	MAC$SYMSCN		;SCAN SYMBOL NAME
	BLBS	R0,5$			;IF LBS CVT TO UPPER CASE
	BRB	30$			;ELSE JUST RETURN

MAC$SYMSCNUP1::
	BSBB	MAC$SYMSCN		;SCAN THE SYMBOL NAME
	PUSHL	R5			;SAVE R5 OVER MOVC
	MOVC3	#SYM$K_MAXLEN+1,W^MAC$AB_TMPSYM,- ;COPY NAME TO TEMP BUFFER
		W^MAC$AB_TMPSY1		;...
	POPL	R5			;RESTORE R5
5$:	BSBB	MAC$CVT_SYM_UP		;CONVERT TO UPPER CASE
	BRB	20$			;AND RETURN

MAC$SYMSCN::
	BSBW	MAC$SKIPSP		;SKIP LEADING SPACES
	BBS	#CHR$V_SYM_CHR,-	;BRANCH IF CHAR CAN START A SYMBOL
		W^MAC$AB_CMSK_TAB(R10),10$
	CLRL	R0			;NO--RETURN NO SYMBOL SCANNED
	RSB
10$:	BSBB	MAC$GETSYM		;YES--SCAN THE SYMBOL
20$:	MOVZBL	#1,R0			;RETURN SYMBOL SCANNED
30$:	RSB
	.DSABL	LSB

	.SBTTL	MAC$LCLSKIP SCAN FOR LOCAL LABEL

;++
;  This routine skips over a string which looks like a local label.
;  A false status return indicates that a syntax error was detected.
;--
.ENABL	LSB

MAC$LCLSKIP::
	bsbw	MAC$SKIPSP		;Skip leading spaces
	bbc	#CHR$V_NUM_BER,-	;Local labels start with a decimal no.
		w^MAC$AB_CMSK_TAB(r10),20$
10$:	bsbw	MAC$GETCHR		;Move to next character
	bbs	#CHR$V_NUM_BER,-	;Continue to consume decimal digits.
		w^MAC$AB_CMSK_TAB(r10),10$
	cmpb	r10,#^a/$/		;Ensure trailing Dollar Sign.
	bneq	20$
	bsbw	MAC$GETCHR		;Consume it.
	movzbl	#1,r0			;The syntax was correct.
	rsb
20$:	clrl	r0			;Local Label was not found.
	rsb

.DSABL	LSB

	.SBTTL	CONVERT SYMBOL TO UPPER CASE FOR TABLE SEARCH

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS THE SYMBOL IN MAC$AB_TMPSYM
;	TO ALL UPPER CASE CHARACTERS AND COMPUTES A NEW HASH VALUE
;	FOR THE SYMBOL.
;
;--

MAC$CVT_SYM_UP::
	MOVAB	W^MAC$AB_TMPSYM,R1	;POINT TO THE SYMBOL
	MOVZBL	(R1)+,R2		;GET SYMBOL CHARACTER COUNT
	MOVL	R2,R0			;INITIALIZE HASH VALUE TO COUNT
10$:	MOVZBL	(R1)+,R3		;GET NEXT CHARACTER OF NAME
	CMPB	R3,#^A/A/+^X20		;CAN CHARACTER BE LOWER CASE?
	BLSSU	20$			;IF LSSU NO
	CMPB	R3,#^A/Z/+^X20		;STILL CHECKING FOR LOWER CASE
	BGTRU	20$			;IF GTRU NOT LOWER CASE
	BICB2	#^X20,R3		;YES--CONVERT TO UPPER CASE
	MOVB	R3,-1(R1)		;STORE IMPROVED CHARACTER
20$:	ADDL2	R3,R0			;IMPROVE HASH VALUE
	SOBGTR	R2,10$			;LOOP FOR WHOLE NAME
	BICL3	#^C<HASHSZ>,R0,W^MAC$GL_HSHVAL ;TRIM TO HASH TABLE SIZE
	RSB

	.SBTTL	MAC$GETSYM ACCUMULATE SYMBOL NAME
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE READS THE INPUT STREAM AND ACCUMULATES A SYMBOL
;	NAME AND ITS HASH VALUE.
;
; CALLING SEQUENCE:
;
;	JSB	MAC$GETSYM
;
; INPUT PARAMETERS:
;
;	R10	FIRST CHARACTER OF SYMBOL NAME
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	MAC$AB_TMPSYM	CONTAINS:	.BYTE SYMLEN,.ASCII/SYMBOLNAME/
;	MAC$GL_HSHVAL	THE HASH VALUE FOR THE ACCUMULATED SYMBOL
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



MAC$GETSYM::
	PUSHR	#^M<R4,R5,R6>		;SAVE REGISTERS
	MOVAB	W^MAC$AB_TMPSYM,R6	;POINT TO TEMP SYMBOL STORAGE
	MOVC5	#0,(SP),#0,-		;CLEAR THE TEMPORARY SYMBOL NAME
		#SYM$K_MAXLEN+1,(R6)	;...
	MOVAB	1(R6),R5		;POINT TO FIRST CHAR OF NAME
					; (FIRST BYTE HOLDS SYMBOL LENGTH)
	PUSHL	#SYM$K_MAXLEN-1		;SET MAX LENGTH (1ST CHAR COUNTED)
	MOVB	R10,(R5)+		;STORE FIRST CHAR OF NAME
	MOVZBL	R10,R4			;GET FIRST CHAR AND INIT HASH VALUE
;
; LOOP, COLLECTING SYMBOL NAME AND HASH VALUE
;
10$:	BSBW	MAC$GETCHR		;GET NEXT CHARACTER OF NAME
	BBC	#CHR$V_SYM_CH1,-	;BRANCH IF NOT LEGAL FOR SYMBOL
		W^MAC$AB_CMSK_TAB(R10),30$
20$:	DECL	(SP)			;COUNT THE CHARACTER
	BLSS	10$			;IF LSS NAME IS TOO LONG--DO NOT
					; STORE
	MOVB	R10,(R5)+		;STORE BYTE IN TEMP SYM BLOCK
	ADDL2	R10,R4			;ACCUM NEW HASH VALUE
	BRB	10$			;LOOP FOR END OF SYMBOL
;
; NAME IS ACCUMULATED
;
30$:	MOVL	(SP)+,R3		;GET <15-LENGTH>
	BGEQ	40$			;IF GEQ LEGAL SYMBOL LENGTH
	CLRL	R3			;TOO LONG--MAKE IT MAX LENGTH
	TSTL	W^MAC$GL_MCLVL		;ARE WE IN A MACRO DEFINITION?
	BGTR	40$			;IF GTR YES--SKIP ERROR MSG
	$INTOUT_LW INT$_WRN,-		;ISSUE WARNING IN PASS 2
	<#MAC$_ILLSYMLEN,W^MAC$GL_LINEPT> ; Symbol name exceeds max length
40$:	SUBL3	R3,#SYM$K_MAXLEN,R3	;COMPUTE # CHARACTERS IN SYMBOL
	MOVB	R3,(R6)			;STORE # OF CHARS IN MAC$AB_TMPSYM
	ADDL2	R3,R4			;HASH VALUE IS SUM OF CHARACTERS
					;PLUS THE NUMBER OF CHARACTERS
	BICL3	#^C<HASHSZ>,R4,-	;TRIM TO HASH TABLE SIZE
		W^MAC$GL_HSHVAL 	;AND STORE IN HASH VALUE 
	POPR	#^M<R4,R5,R6>
	RSB

	.SBTTL	MAC$XUPARROW CHECK CHARACTER AFTER "^"

;++
;	THIS ROUTINE RETURNS IN R8 THE TOKEN CORRESPONDING TO THE
;	CHARACTER FOLLOWING THE UPARROW.  IF THE CHARACTER IS NOT
;	IN THE TABLE THIS ROUTINE BRANCHES TO MAC$CHRERR TO REPORT
;	THE ILLEGAL CHARACTER.
;
;	NOTE THAT THIS ROUTINE IS JMP'ED TO BY MAC$TOKEN.
;--

MAC$XUPARROW::
	BSBW	MAC$GETCHR		;GET THE NEXT CHARACTER
	LOCC	R10,#LEN$K_UPXTAB,-	;LOOK UP CHARACTER IN UPXTAB
			W^MAC$AB_UPXTAB	; to see if legal character
	BEQL	10$			;IF EQL THEN ILLEGAL CHARACTER
	SUBL3	#MAC$AB_UPXTAB,R1,R2	;GET INDEX INTO TABLE FOR CHARACTER
	MOVZBL	MAC$AB_UPXTOKEN[R2],R8 ;RETRIEVE TOKEN VALUE
	BRW	MAC$GETCHR		;GET THE FIRST REAL CHARACTER
					;AND RETURN
;
; CHARACTER IS ILLEGAL
;
10$:	BRW	MAC$CHRERR		;REPORT ILLEGAL CHARACTER

	.SBTTL	MAC$XPOUND A POUND SIGN WAS DETECTED

;++
;	THIS ROUTINE LOADS MAC$GB_RDXNDX BASED ON THE OPCODE TYPE
;	FOUND IN MAC$GL_MOPPTR.
;--

MAC$XPOUND::
	MOVL	W^MAC$GL_MOPPTR,R0	;GET PTR TO OPERAND DESCR. BYTE
	BEQL	10$			;IF EQL NOT FLOATING POINT
	TSTW	(R0)			;FLOATING OPERAND?
	BGEQ	10$			;IF GEQ NO
	BBC	#OPD$V_H_FLOAT,(R0),2$	;IF NOT H FLOAT THEN SKIP
	MOVB	#RDX$V_HFLOAT,-		;YES--USE H FLOAT READER
			W^MAC$GB_RDXNDX
	BRB	20$	
2$:	BBC	#OPD$V_G_FLOAT,(R0),4$	;IF NOT G FLOAT THEN SKIP
	MOVB	#RDX$V_GFLOAT,-		;YES--USE G FLOAT READER
			W^MAC$GB_RDXNDX
	BRB	20$	
4$:	BBC	#OPD$V_D_FLOAT,(R0),6$	;IF NOT D FLOAT THEN SKIP
	MOVB	#RDX$V_DOUBLE,-		;YES--USE D FLOAT READER
			W^MAC$GB_RDXNDX
	BRB	20$	
6$:	MOVB	#RDX$V_FLOAT,-		;USE F FLOAT READER
			W^MAC$GB_RDXNDX
	BRB	20$
10$:	MOVB	#RDX$V_DECIMAL,-	;ELSE USE DECIMAL
			W^MAC$GB_RDXNDX
20$:	MOVZBL	#DPOUND,R8		;RETURN TOKEN OF POUND SIGN
	BRW	MAC$GETCHR		;READ NEXT CHARACTER AND RETURN

	.SBTTL	INSERT/SEARCH USER SYMBOL TABLE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO LOOKUP A SYMBOL IN THE USER SYMBOL
;	TABLE, AND IF THE ENTRY IS AT MAC$INSUSRSYMTB, THEN TO INSERT
;	THE SYMBOL IF IT IS NOT FOUND.
;
; CALLING SEQUENCE:
;
;	JSB	MAC$INSUSRSYMTB
; OR	JSB	MAC$SRCUSRSYMTB
;
; INPUT PARAMETERS:
;
;	MAC$AB_TMPSYM	CONTAINS:	.BYTE SYMLEN,.ASCII/SYMBOLNAME/
;	MAC$GL_HSHVAL	THE HASH VALUE FOR THE ACCUMULATED SYMBOL
;	R3		HASH TABLE ADDRESS IF ENTRY AT MAC$SRCSYMTAB
;	R5		POINTER TO LINKED LIST IF ENTRY AT MAC$SRC_LIST
;	R6		POINTER TO WHERE R5 POINTS IF ENTRY AT MAC$SRC_LIST
;				AND YOU NEED THE PREV. POINTER RETURNED
;
; OUTPUT PARAMETERS:
;
;	R0	0	NOT FOUND
;		1	FOUND
;	R1	SYMBOL BLOCK ADDRESS IF FOUND
;		0	IF NOT FOUND
;	R2	POINTER TO PREVIOUS SYMBOL BLOCK
;
;--

	.ENABL	LSB
MAC$SRC_LIST::				;ENTRY TO SEARCH LINKED LIST
	BICL2	#FLG$M_ORDLST!FLG$M_INSERT,- ;NOT ORDERED LIST
			(R11)		     ;AND DO NOT INSERT
	PUSHR	#^M<R4,R5,R6,R7,R8>	;SAVE REGISTERS
	BRB	30$			;JUMP INTO COMMON CODE
MAC$SRCSYMTAB::				;ENTRY TO SEARCH ARBITRARY TABLE
	BICL2	#FLG$M_ORDLST!FLG$M_INSERT,- ;OPCODE TABLE IS NOT ORDERED
			(R11)		;AND DO NOT ALLOW INSERTION
	BRB	20$

MAC$INSUSRSYMTB::			;ENTRY TO INSERT IN USER SYMBOL TABLE
	BBCS	#FLG$V_INSERT,(R11),10$	;SET INSERT FLAG
	BRB	10$			;JOIN COMMON CODE

MAC$SRCUSRSYMTB::			;ENTRY TO SEARCH USER SYMBOL TABLE
	BBCC	#FLG$V_INSERT,(R11),10$	;DO NOT INSERT IF NOT FOUND
10$:	MOVAB	W^MAC$AL_USYHSHTB,R3	;PICK UP SYMBOL HASH TABLE ADDRESS
	BBCS	#FLG$V_ORDLST,(R11),20$	;USER SYMBOL TABLE IS ORDERED
20$:	PUSHR	#^M<R4,R5,R6,R7,R8>	;SAVE REGISTERS
	MOVL	W^MAC$GL_HSHVAL,R4	;GET HASH VALUE FOR SYMBOL
	MOVAL	(R3)[R4],R6 		;GET ADDRESS OF PREVIOUS SYMBOL
	MOVL	(R6),R5			;POINT TO FIRST SYMBOL
	BEQL	70$			;IF EQL NOTHING IN BUCKET
30$:	MOVAB	W^MAC$AB_TMPSYM,R7	;POINT TO TEMP SYMBOL NAME
	MOVZBL	(R7)+,R8		;GET # CHARS IN NEW SYMBOL NAME
;
; CHAIN THROUGH THE BUCKET LOOKING FOR THE SYMBOL.  GET OUT IF WE FIND
; IT OR IF WE FIND A SYMBOL LARGER THAN THIS ONE, SINCE THE BUCKETS
; ARE LINKED FROM SMALLEST TO LARGEST.
;
40$:	MOVZBL	SYM$B_NAME(R5),R0	; Get offset to symbol count/name
	SUBL3	R0,R5,R0		; and form its address
	MOVZBL	(R0)+,R1		; Get symbol size and advance pointer
	CMPC5	R8,(R7),#0,R1,(R0)	; Match the symbols
	BEQL	75$			; Branch if symbol found
50$:	BLSSU	65$			;IF SYMBOL LSSU THE ONE IN THE TABLE
					; THEN GET OUT.
60$:	MOVL	R5,R6			;BRING UP THE BACK POINTER
	MOVL	SYM$L_LINK(R5),R5	; Link to next symbol block
	BNEQ	40$			;IF NEQ GO GET IT
	BRB	70$			; Symbol not found

65$:	BBC	#FLG$V_ORDLST,(R11),60$	;BR IF NOT ORDERED LIST
;
; THE SYMBOL IN QUESTION IS NOT IN THE BUCKET
;
70$:	BBSC	#FLG$V_INSERT,(R11),80$	;SYMBOL NOT THERE--SHOULD WE INSERT?
	BRW	160$			;NO--GO RETURN NOT FOUND
75$:	BRW	120$			;FOUND IT--GO FINISH UP
80$:	MOVL	W^MAC$GL_SYMPGPTR,R7	;YES--GET POINTER TO CURRENT PAGES
	BNEQ	100$			;IF NEQ GO USE THEM
;
; ALLOCATE PAGES FOR THIS BUCKET
;
90$:	PUSHL	#<512*STB$K_PG_MISS>	;STACK SIZE OF BLOCK WE NEED
	MOVL	SP,R2			;SAVE ADDRESS
	PUSHAB	W^MAC$GL_BASEADDR	;STACK RESULT LOCATION
	PUSHL	R2			;STACK ADDRESS OF SIZE
	CALLS	#2,G^LIB$GET_VM		;ALLOCATE BLOCK
	TSTL	(SP)+			;KEEP STACK CLEAN
	BLBC	R0,150$			;IF LBC ALLOCATION FAILURE
	MOVL	W^MAC$GL_SYMPGPTR,R0	;GET LAST PAGES ALLOCATED
	BEQL	92$			;IF EQL THIS IS FIRST ALLOCATE
	INSQUE	(R0),W^MAC$GL_SYM_PAGL	;LINK INTO SYMBOL PAGE LIST
92$:	INCL	W^MAC$GL_SYMPGREQ	;COUNT ANOTHER SYMBOL PAGES GET
	MOVL	W^MAC$GL_BASEADDR,R0	;GET ADDRESS OF BLOCK ALLOCATED
	MOVL	R0,R7			;COPY ADDRESS FOR LATER
	MOVL	R0,W^MAC$GL_SYMPGPTR	;STORE POINTER TO CURRENT PAGES
	MOVZWL	#<<512*STB$K_PG_MISS>-8>,(R0)+ ; Set count of bytes in block
					; IN THESE PAGES.
	MOVAB	4(R0),(R0)+		;STORE POINTER TO FIRST SYMBOL BLOCK
;
; SYMBOL PAGE IS POINTED TO BY R7
;
100$:
	MOVAB	W^MAC$AB_TMPSYM,R0	; Get address of new symbol count/name
	MOVZBL	(R0),R1			; Get symbol count and advance pointer
	CMPB	R1,#SYM$K_TWOCOL	; Will 2 column symbol table be required?
	BLSS	110$			; No if LSS
	BBSS	#FLG$V_SYM2COL,(R11),110$ ; Set bit for 2 column symbol table
110$:
	INCL	R1			; Include count byte in length
	SUBL2	R1,(R7)			; Subtract length and
	SUBL2	#SYM$K_BLKSIZ,(R7)+	; and fixed part from bytes in block
	BLSS	90$			; If LSS no space left so get new block
	MOVL	(R7),R8			; Get new block address
	ADDL2	R1,(R7)			; Add size of this block to figure
	ADDL2	#SYM$K_BLKSIZ,(R7)	; address of next
	MOVB	R1,-(SP)		; Save total length
	MOVC3	R1,(R0),(R8)		; Copy symbol count/name into block
	MOVL	R3,R8			; Set proper block address
	MOVL	(R6),(R3)+		; Link new symbol block
	MOVL	R8,(R6)			; into bucket
	MOVB	(SP)+,(R3)+		; Store name offset
	MOVL	W^MAC$GL_VALUE,(R3)+	; Put symbol value in
	CLRW	(R3)+			; Clear symbol's flags
	CLRB	(R3)+			; Token value
	MOVB	W^MAC$GL_PSECT,(R3)+	; Segment number
;
	MOVL	R8,R1			; Point to symbol block
	BRB	140$			;EXIT ROUTINE
;
; SYMBOL WAS FOUND IN THE TABLE
;
120$:	MOVL	R5,R1			;POINT TO SYMBOL BLOCK
140$:	MOVZBL	#1,R0			;RETURN SUCCESS
	MOVL	R6,R2			;POINT TO PREVIOUS SYMBOL
	BRB	170$			;EXIT ROUTINE
;
; PAGE ALLOCATION FAILURE
;
150$:	BRW	MAC$ERR_NOMEM		;NO MEMORY--GO REPORT ERROR
;
; SYMBOL NOT FOUND AND NOT INSERTING
;
160$:	CLRQ	R0			;RETURN 0 ON FAILURE
	MOVL	R6,R2			;RETURN POINTER TO PREVIOUS
170$:	POPR	#^M<R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

	.DSABL	LSB

	.SBTTL	MAC$REGIS SEE IF THE SCANNED SYMBOL IS A REGISTER


;++
;	THIS ROUTINE CHECKS THE SYMBOL NAME TO SEE IF IT IS A REGISTER.
;	R8 WILL BE 0 IF IT IS NOT, AND NON-ZERO IF IT IS.  R1 WILL
;	CONTAIN THE VALUE.
;--

MAC$REGIS:
	MOVAB	W^MAC$AB_TMPSYM,R5	;POINT TO SYMBOL LENGTH+NAME
	CASEB	(R5)+,#1,#2		;SEE IF 1-3 CHARACTER NAME
10$:	.WORD	30$-10$			;ONE-CHARACTER NAME
	.WORD	40$-10$			;TWO-CHARACTER NAME
	.WORD	70$-10$			;THREE-CHARACTER NAME
;
; DEFINITELY NOT A REGISTER--RETURN 0
;
20$:	CLRL	R8			;RETURN 0 FOR NOT A REGISTER
	RSB
;
; ONE CHARACTER NAME--IS IT "."?
;
30$:	CMPB	(R5),#^A/./		;IS SYMBOL CURRENT PC (.)?
	BNEQ	20$			;IF NEQ NO
	MOVZBL	#DPC,R8			;YES--RETURN TOKEN FOR PC
	RSB
;
; TWO CHARACTER NAME CAN BE R0-R9, SP, PC, AP, FP, IV, OR DV
;
40$:	MATCHC	#2,(R5),#TWO_CHR_REG_SIZ,- ;SEE IF A REGISTER
			W^TWO_CHR_REG_NAM
	BNEQ	20$			;IF NEQ NOT IN TABLE
	BLBS	R2,20$			;IF LBS THEN NAME IS LAST CHAR
					; OF ONE REG AND FIRST OF ANOTHER
					; (EX. PP, VD, CA)
	DIVL2	#2,R2			;FIGURE BYTE INDEX
	SUBL3	R2,#15,R0		;FIGURE INDEX INTO TWO_CHR_REG_VAL TABLE
	MOVZBL	L^TWO_CHR_REG_VAL(R0),R1;PICK UP THE REGISTER VALUE
50$:	MOVZBL	#RRREG,R8		;RETURN TOKEN OF REGISTER
	CMPB	1(R5),#^A/V/		;UNLESS 'IV' OR 'DV'
	BNEQ	REG_CREF		;IF NEQ NOT 'IV' OR 'DV'--SEE IF CREF
	MOVZBL	#DMASK,R8		;'IV' OR 'DV'--TOKEN IS DMASK
60$:	RSB
;
; THREE CHARACTER SYMBOL NAME CAN BE R10-R12
;
70$:	CMPW	(R5)+,#^A/R1/		;IS IT A REGISTER?
	BNEQ	20$			;IF NEQ NO
	SUBB3	#^A/0/,(R5),R1		;YES--GET VALUE IN R1
	BLSS	20$			;IF LSS THEN NOT REGISTER
	CMPB	R1,#2			;IN RANGE?
	BGTR	20$			;IF GTR NO
	ADDB2	#10.,R1			;YES--ADJUST REGISTER VALUE
	MOVZBL	#RRREG,R8		;RETURN TOKEN IS REGISTERS
	MOVZBL	R1,R1			;EXTEND REG. NUMBER TO LONGWORD
;**;	BRB	REG_CREF		;SEE ABOUT CREF AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CROSS-REFERENCES REGISTERS IF REGISTER CROSS-REF
;	IS ENABLED.
;
; INPUTS:
;
;	R1	REGISTER NUMBER
;
;--

REG_CREF:
	BBC	#CRF$V_REGISTERS,W^MAC$GL_CRF_FLG,30$ ;BRANCH IF NOT CREFFING REGS
	BBS	#FLG$V_XCRF,(R11),30$		;BRANCH IF .NOCROSS ON
	PUSHL	R1			;CREFFING--SAVE R1
	MOVL	L^MAC$AL_RGNM_TAB[R1],R5 ;POINT R5 TO REGISTER SYMBOL BLOCK
	INCL	SYM$L_VAL(R5)		;COUNT REGISTER REFERENCES
	BBSS	#SYM$V_CRFO,SYM$W_FLAG(R5),10$ ;BRANCH IF INSERT DONE
	CLRL	-(SP)			;NO--CLEAR FLAGS
	PUSHAB	SYM$L_VAL(R5)		;POINT TO VALUE WORD
	MOVZBL	SYM$B_NAME(R5),R0	; Get offset to symbol name/count
	SUBL3	R0,R5,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFRGCTB	;STACK CONTROL TABLE ADDRESS
	CALLS	#4,G^CRF$INSRTKEY	;INSERT REGISTER KEY
10$:	PUSHL	#CRF$K_REF		;THIS IS A REFERENCE
	PUSHL	#0			;ASSUME READ REFERENCE
	MOVL	W^MAC$GL_MOPPTR,R0	;GET OPERAND MODE BYTE POINTER
	BEQL	20$			;IF EQL NOT IN INSTRUCTION
	BITW	#OPD$M_MODIFY!OPD$M_WRITE,(R0) ;MODIFY OR WRITE REF?
	BEQL	20$			;IF EQL NO
	MOVL	#1,(SP)			;YES--SET WRITE REFERENCE
20$:	PUSHAB	W^MAC$AB_LPBUF		;REFERENCER NAME ADDRESS
	MOVZBL	SYM$B_NAME(R5),R0	; Get offset to symbol name/count
	SUBL3	R0,R5,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFRGCTB	;CREF CONTROL TABLE ADDRESS
	BSBW	MAC$CVT_LIN_PAG		;CONVERT LINE/PAGE INTO LPBUF
	CALLS	#5,G^CRF$INSRTREF	;INSERT REGISTER REFERENCE
	INCL	W^MAC$GL_CRF_RCNT	;COUNT REGISTER REFERENCE
	POPL	R1			;RESTORE REGISTER NUMBER
30$:	RSB

	.SBTTL	MAC$DNUMBER ACCUMULATE DECIMAL NUMBER

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine accumulates a decimal octaword value in
;	MAC$GO_VALUEO
;--

MAC$DNUMBER::
	PUSHL	R6			;SAVE R6
	CLRQ	R2			; Clear R2, R3, R4, R5
	CLRQ	R4			; to accumalate octaword number
	MOVAB	-^A/0/(R10),R2		; Convert first digit to binary
;
; LOOP, COLLECTING THE VALUE
;
10$:
	PUSHL	R2			; Save R2
	BSBW	MAC$GETCHR		; Get next character
	POPL	R2			; Restore R2
	MOVAB	-^A/0/(R10),R1		; Convert digit to binary
	BLSS	20$			;IF LSS THEN WE ARE DONE
	CMPB	R1,#9			; Check if really a digit?
	BGTR	20$			;IF GTR NO
;
; Multiply accumulated value by 10 and add in new digit
;
	PUSHR	#^M<R7,R8,R9>		; Get some more work registers
;
; Multiply 1st longword by 10 and add in new digit
;
	EMUL	#10,R2,R1,R0		; Put 10*1st longword into R0,R1
	BBC	#31,R2,12$		; If sign bit set compensate for
	ADDL	#10,R1			; unsigned bias of 2**32
12$:
	MOVQ	R0,R6			; Accumulate result in R6,R7,R8,R9
	CLRQ	R8
;
; Multiply 2nd longword by 10
;
	EMUL	#10,R3,#0,R0		; Put 10*2nd longword into R0,R1
	BBC	#31,R3,14$		; If sign bit set compensate for
	ADDL	#10,R1			; unsigned bias of 2**32
14$:
	ADDL2	R0,R7			; Add value into 2nd and 3rd longwords
	ADWC	R1,R8			; of octaword result
;
; Multiply 3rd logword by 10
;
	EMUL	#10,R4,#0,R0		; Put 10*3rd longword into R0,R1
	BBC	#31,R4,16$		; If sign bit set compensate for
	ADDL	#10,R1			; unsigned bias of 2**32
16$:
	ADDL2	R0,R8			; Add value into 3rd and 4th longwords
	ADWC	R1,R9			; of octaword result
;
; Multiply 4th lonword by 10
;
	MULL3	#10,R5,R0		; Put 10*4th longword into R0
	ADDL2	R0,R9			; Add value into 4th longword of result
;
	MOVQ	R6,R2			; Position result for next loop
	MOVQ	R8,R4
	POPR	#^M<R7,R8,R9>		; Restore registers
	BRB	10$			;LOOP FOR ALL DIGITS
;
; NUMBER IS ACCUMULATED
;
20$:
	MOVQ	R2,W^MAC$GO_VALUEO	; Store value in VALUEO
	MOVQ	R4,W^MAC$GO_VALUEO+8
	MOVL	R3,W^MAC$GL_HIGH_32	; Set high 32 bits in case .QUAD
	MOVQ	R4,W^MAC$GQ_HIGH_64	; Set high 64 bits in case .OCTA
	POPL	R6			;RESTORE R6
	MOVZBL	#DINTEGER,R8		;TOKEN IS INTEGER
	CMPB	R10,#^A/$/		;DID WE JUST CONVERT LOCAL LABEL?
	BNEQ	30$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SCAN PAST IT
	BRB	MAC$GOTLOCLAB		;AND GO PROCESS THE LOCAL LABEL
30$:	CMPB	R10,#^A/./		;TRAILING PERIOD IN VALUE?
	BNEQ	40$			;IF NEQ NO
	BRW	MAC$GETCHR		;YES--SCAN PAST IT
40$:	RSB

	.SBTTL	MAC$GOTLOCLAB PROCESS LOCAL LABEL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A LOCAL LABEL IS ENCOUNTERED.
;
; INPUTS:
;
;	MAC$GQ_VALUEQ	DECIMAL VALUE OF THE LOCAL LABEL
;--

MAC$GOTLOCLAB:
	MOVC5	#0,(SP),#0,#SYM$K_MAXLEN+1,-  ;ZERO TMP SYMBOL BLOCK
			W^MAC$AB_TMPSYM	; ...
	MOVAB	W^MAC$AB_TMPSYM,R1	;POINT TO TMP SYMBOL BLOCK
	MOVB	#6,(R1)+		;NAME IS 6 CHARS LONG
	MOVL	W^MAC$GL_LSB,R2		;GET LSB NUMBER SYMBOL IS IN
	MOVL	R2,(R1)+		;STORE AS FIRST 4 CHARS OF NAME
	MOVW	W^MAC$GQ_VALUEQ,(R1)+	;5TH AND 6TH CHARS ARE VALUE
	ADDW2	-(R1),R2		;ACCUMULATE HASH VALUE FOR SYMBOL
	BICL3	#^C<HASHSZ>,R2,W^MAC$GL_HSHVAL 	;TRIM TO HASH SIZE
	BSBW	MAC$INSUSRSYMTB		;INSERT IN USER SYMBOL TABLE
	BISW2	#SYM$M_LOCAL,SYM$W_FLAG(R1) ;FLAG AS LOCAL LABEL
	MOVL	R1,W^MAC$GL_VALUE	;VALUE IS ADDRESS OF SYMBOL BLOCK
	CMPB	R10,#^A/=/		;ASSIGNMENT OF LOCAL SYMBOL?
	BNEQ	20$			;IF NEQ NO
	BBSS	#FLG$V_OPRND,(R11),20$	;YES--FLAG IN OPERAND FIELD
20$:	MOVZBL	#ID,R8			;TOKEN TYPE IS ID
	RSB

	.SBTTL	ACCUMULATE BINARY/OCTAL/HEX NUMBERS

MAC$BINNUM::
	MOVZBL	#1,R5			;SET LOG(2) OF RADIX
	MOVZBL	#^A/1/,R4		;SET UPPER CHARACTER BOUND
	BRB	MAC$PNUMBER		;GO ACCUM NUMBER

MAC$OCTNUM::
	MOVZBL	#3,R5			;SET LOG(2) OF RADIX
	MOVZBL	#^A/7/,R4		;SET UPPER CHARACTER BOUND
	BRB	MAC$PNUMBER

MAC$HEXNUM::
	MOVZBL	#4,R5			;SET LOG(2) OF RADIX
	MOVZBL	#^A/F/,R4		;SET UPPER CHARACTER BOUND
	BRB	MAC$PNUMBER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ACCUMULATES A NUMBER OF AN EVEN RADIX.
;
; INPUTS:
;
;	R5	LOG(2) OF RADIX
;	R4	UPPER CHARACTER BOUND
;
; OUTPUTS:
;
;	MAC$GO_VALUEO	ACCUMULATED VALUE
;	R8		TOKEN VALUE
;
;--

MAC$PNUMBER::
	PUSHL	R10			;SAVE THE CURRENT CHARACTER,
	PUSHL	W^MAC$GL_LINEPT		; AND LINE POINTER (IN CASE WE
					; ACTUALLY SCAN A LOCAL SYMBOL)
	MOVAB	W^MAC$GO_VALUEO,R1	; Point to value octaword
	CLRQ	(R1)			; Clear result octaword
	CLRQ	8(R1)
;
; LOOP AND COLLECT THE VALUE
;
10$:	MOVL	R10,R0			;GET NEXT CHARACTER
	CMPB	R0,#^A/0/		;IS IT A DIGIT?
	BLSS	40$			;IF LSS NO
	CMPB	R0,#^A/A/+^X20		;IS CHARACTER LOWER-CASE ALPHA?
	BLSSU	15$			;IF LSSU NO
	CMPB	R0,#^A/Z/+^X20		;MAYBE...
	BGTRU	15$			;IF GTRU NOT LOWER-CASE ALPHA
	BICB2	#^X20,R0		;YES--MAKE UPPER CASE ALPHA
15$:	CMPB	R0,R4			;WITHIN RANGE FOR RADIX?
	BGTR	40$			;IF GTR NO
	CMPB	R0,#^A/9/		;ABOVE THE DIGITS?
	BLEQ	20$			;IF LEQ NO
	CMPB	R0,#^A/A/		;YES--IS IT ABOVE LETTER 'A'?
	BLSS	40$			;IF LSS NO--NUMBER IS DONE
	MOVAB	-7(R0),R0		;YES--HEX ALPHA CHARACTER--7 IS
					; DIFF BETWEEN 9 AND A
20$:	MOVAB	-^A/0/(R0),R0		;CONVERT DIGIT TO BINARY
	MOVL	R5,R3			;SET UP LOOP COUNT
30$:
	MOVL	R1,R2			; Reset work pointer
	ADDL2	(R2),(R2)+		; Multiply by two,
	ADWC	(R2),(R2)+		; add high part and carry
	ADWC	(R2),(R2)+		; ...
	ADWC	(R2),(R2)		; ...
	SOBGTR	R3,30$			; Loop for radix
	MOVL	R1,R2			; Reset work pointer
	ADDL2	R0,(R2)+		; Add in new digit
	ADWC	#0,(R2)+		; add carry
	ADWC	#0,(R2)+		; ...
	ADWC	#0,(R2)			; ...
	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	BRB	10$			;CONTINUE
;
; NUMBER IS ACCUMULATED
;
40$:	CMPB	R10,#^A/$/		;DID WE JUST SCAN A LOCAL LABEL?
	BEQL	50$			;IF EQL YES--GO FIX UP
	MOVZBL	#DINTEGER,R8		;NO--RETURN INTEGER TOKEN
	MOVL	W^MAC$GL_VAL3,W^MAC$GL_HIGH_32 ;SAVE HIGH 32 BITS
	MOVQ	W^MAC$GQ_VAL2,W^MAC$GQ_HIGH_64 ; Save high 64 bits
	ADDL2	#2*4,SP			;CLEAN STACK
	RSB
;
; IT APPEARS THAT WE ACTUALLY SCANNED A LOCAL SYMBOL.  THIS CAN HAPPEN
; WHEN SOMETHING LIKE "^O<12+47$+12>" OCCURS.
;
50$:	POPL	W^MAC$GL_LINEPT		;RESTORE LINE POINTER
	POPL	R10			;RESTORE CHARACTER
	BRW	MAC$DNUMBER		;GO RESCAN AS DECIMAL NUMBER

	.END
