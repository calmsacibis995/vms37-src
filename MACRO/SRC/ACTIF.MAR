	.TITLE	MAC$ACTIF	CONDITIONAL STATEMENT PROCESSOR
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V02.06	CNH0040		Chris Hume		15-Oct-1980
;		.ENDC ignored after local label in conditional suppressed
;		code.  (SCANER.MAR 02.14)
;
;	V01.05	RN0023		R. Newland		 2-Nov-1979
;		New message codes to get error message from system
;		message file.
;
;	V01.05	RN0018		R. Newland		20-Oct-1979
;		Get arguments of .IF_IDENTICAL/.IF_DIFFERENT upper cased
;		before making comparison.
;
;	V01.04	RN0011		R. Newland		26-Sep-1979
;		New librarian support - remove truncation error
;
;	V01.03	RN0010		R. Newland		 5-Sep-1979
;		Multipage IF arguments
;
;	V01.02	RN0005		R. Newland		14-Aug-1979
;		Variable symbol storage and remove .ALIGN LONG statements
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_INTCODDEF			;DEFINE INT. CODES
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_MNBDEF			; Define MXB offsets
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG

;++
;	THESE ARE THE .IF CONDITION NAMES.  THE VALUE IS THE NAME OF
;	THE ROUTINE TO CALL.  IF THE ADDRESS HAS BIT 31 SET, THEN
;	THE ROUTINE MUST EVALUATE ITS OWN CONDITION, RATHER THAN
;	LETTING THE PARSER DO IT.
;
;--

	IF_SPECIAL	=	^X80000000	;HIGH BIT IF SPECIAL
	INSYMP	=	0

	$MAC_INSERT_SYX	EQ,	IF_EQUAL		;EQUAL TO ZERO
	$MAC_INSERT_SYX	EQUAL,	IF_EQUAL		;EQUAL TO ZERO
	$MAC_INSERT_SYX	NE,	IF_NOT_EQUAL		;NOT EQUAL TO ZERO
	$MAC_INSERT_SYX	NOT_EQUAL,IF_NOT_EQUAL		;NOT EQUAL TO ZERO
	$MAC_INSERT_SYX	GT,	IF_GREATER		;GREATER THAN ZERO
	$MAC_INSERT_SYX	GREATER,IF_GREATER		;GREATER THAN ZERO
	$MAC_INSERT_SYX	LE,	IF_LESS_EQUAL		;LESS THAN OR EQUAL ZERO
	$MAC_INSERT_SYX	LESS_EQUAL,IF_LESS_EQUAL	;LESS THAN OR EQUAL ZERO
	$MAC_INSERT_SYX	GE,	IF_GTR_EQUAL		;GREATER THAN OR EQUAL ZERO
	$MAC_INSERT_SYX	GREATER_EQUAL,IF_GTR_EQUAL	;GREATER THAN OR EQUAL ZERO
	$MAC_INSERT_SYX	LT,	IF_LESS_THAN		;LESS THAN ZERO
	$MAC_INSERT_SYX	LESS_THAN,IF_LESS_THAN		;LESS THAN ZERO
	$MAC_INSERT_SYX	DF,	IF_DEFINED!IF_SPECIAL	;DEFINED
	$MAC_INSERT_SYX	DEFINED,IF_DEFINED!IF_SPECIAL	;DEFINED
	$MAC_INSERT_SYX	NDF,	IF_NOT_DEFINED!IF_SPECIAL;NOT DEFINED
	$MAC_INSERT_SYX	NOT_DEFINED,IF_NOT_DEFINED!IF_SPECIAL ;NOT DEFINED
	$MAC_INSERT_SYX	B,	IF_BLANK!IF_SPECIAL	;BLANK
	$MAC_INSERT_SYX	BLANK,	IF_BLANK!IF_SPECIAL	;BLANK
	$MAC_INSERT_SYX	NB,	IF_NOT_BLANK!IF_SPECIAL	;NOT BLANK
	$MAC_INSERT_SYX	NOT_BLANK,IF_NOT_BLANK!IF_SPECIAL ;NOT BLANK
	$MAC_INSERT_SYX	IDN,	IF_IDENTICAL!IF_SPECIAL	;IDENTICAL
	$MAC_INSERT_SYX	IDENTICAL,IF_IDENTICAL!IF_SPECIAL ;IDENTICAL
	$MAC_INSERT_SYX	DIF,	IF_DIFFERENT!IF_SPECIAL	;DIFFERENT
	$MAC_INSERT_SYX	DIFFERENT,IF_DIFFERENT!IF_SPECIAL,-; DIFFERENT
			IF_COND_NAMES

;++
;	SPECIAL KEYWORDS WHICH ARE SCANNED WHILE PROCESSING THE
;	FALSE PART OF A CONDITIONAL ASSEMBLY.  THE VALUE IS A
;	POINTER TO A ROUTINE TO CALL WHEN THE KEYWORD IS DETECTED.
;
;--

	INSYMP	=	0			;START NEW LIST

	$MAC_INSERT_SYX	.END,	IF_ERROR		;ERROR IF THIS SEEN
	$MAC_INSERT_SYX	.IF,	IF_IN_AN_IF		;.IF WITHIN AN IF
	$MAC_INSERT_SYX	.IFF,	IFF			;.IFF
	$MAC_INSERT_SYX	.IFT,	IFT			;.IFT
	$MAC_INSERT_SYX	.IFTF,	IFTF			;.IFTF
	$MAC_INSERT_SYX .IF_FALSE, IFF			;.IF_FALSE
	$MAC_INSERT_SYX .IF_TRUE,  IFT			;.IF_TRUE
	$MAC_INSERT_SYX .IF_TRUE_FALSE, IFTF		;.IF_TRUE_FALSE
	$MAC_INSERT_SYX	.ENDC,	ENDC,	IF_SPL_KEYWORDS

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

	.SBTTL	IFHD1 CONDITIONAL ASSEMBLY PROCESSOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	'IFHD1' IS CALLED WHEN A '.IF' CONDITIONAL ASSEMBLY IS
;	DETECTED.   IT SCANS THE CONDITION ITSELF, AND IT MOST
;	CASES (B,NB,DIF,IDN,DF,NDF ARE THE EXCEPTIONS) IT ALLOWS
;	THE PARSER TO EVALUATE THE ASSOCIATED EXPRESSION.
;
;--

IFHD1::					;IF_HEAD = KIF
	MOVAB	W^IS_TRUE,W^MAC$GL_IF_CNDPT ;PRESET IN CASE OF ERROR
	BSBW	MAC$SYMSCNUP		;SCAN THE CONDITION CODE
	BLBC	R0,10$			;BRANCH IF NO CONDITION FOUND
	MOVAB	W^IF_COND_NAMES,R5	; Point to condition names
	BSBW	MAC$SRC_LIST		;LOOK UP THE ONE WE SCANNED
	BLBS	R0,20$			;BRANCH IF FOUND
10$:	$MAC_ERR ILLIFCOND		; Illegal IF condition
	BRW	MAC$ERRORLN		;ISSUE MESSAGE AND RETURN
20$:	MOVL	SYM$L_VAL(R1),R6	;GET THE ROUTINE ADDRESS
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;NEXT CHAR A COMMA?
	BNEQ	30$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
30$:	BBCC	#31,R6,40$		;BRANCH IF NO SPECIAL SCAN
	JSB	(R6)			;YES--DO SPECIAL SCAN
	BBS	#FLG$V_IIF,(R11),50$	;IS THIS A .IIF?
	MOVL	W^MAC$GL_LINEPT,W^MAC$GL_ERRPT ;NO--SAVE LINE POSITION
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#CR			;WE SHOULD BE AT END OF LINE
	BEQL	50$			;IF EQL ALL IS WELL
	$MAC_ERR IFDIRSYNX		; No--IF directive syntax error
	BSBW	MAC$ERRORLN		;ISSUE MESSAGE TO PASS 2
	MOVZBL	#CR,R10			;FORCE NEW LINE
	BRB	50$			;CONTINUE
;
; NO SPECIAL SCANNING
;
40$:	MOVL	R6,W^MAC$GL_IF_CNDPT	;SET CONDITION TEST POINTER
50$:	BICL2	#FLG$M_IFSTAT!FLG$M_EVALEXPR,(R11) ;NOT IN AN IF AND DO
						   ;NOT OUTPUT EXPRESSIONS
	BISL2	#FLG$M_COMPEXPR,(R11)	;ASSUME COMPILE TIME EXPRESSION
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	IFSYNT IS CALLED IF THERE IS A SYNTAX ERROR IN A CONDITIONAL
;	ASSEMBLY STATEMENT.  THE ERROR IS REPORTED, AND THE CONDITION
;	IS THEN PROCESSED.
;
;--

IFSYNT::				;IF_STATE = IF_HEAD ERR02
	$MAC_ERR IFDIRSYNX		; Get the message code
	BSBW	MAC$ERRORLN		;ISSUE MESSAGE TO PASS 2
	BRB	IF			;PROCESS THE CONDITIONAL ASSEMBLY

	.SBTTL	IF DIRECTIVE ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS IS THE HEART OF THE CONDITIONAL ASSEMBLY PROCESSOR.  THIS
;	ROUTINE CHECKS THE RESULT OF THE IF EXPRESSION AND FALLS INTO
;	THE 'SCAN_FALSE_CODE'  ROUTINE WHICH SCANS THE CODE LOOKING
;	FOR A CHANCE TO RESUME ASSEMBLING.
;
;--

IF::					;IF_STATE = IF_HEAD EXPR DEOL
	MOVL	W^MAC$AL_VALSTACK-4[R7],R6 ;GET THE EXPRESSION
	$INTOUT_LW INT$_PRIL,R6		;PRINT THE EXPRESSION VALUE
	BBS	#FLG$V_COMPEXPR,(R11),10$ ;BRANCH IF COMPILE TIME EXPRESSION
	$MAC_ERR IFEXPRNABS		; No--get the message code
	BSBW	MAC$ERRORPT		;ISSUE ERROR MESSAGE
10$:	MOVL	R6,R0			;COPY THE VALUE FOR CONDITION CHECKER

IFSPL::					;IF_STATE = IF_HEAD DEOL
	JSB	@W^MAC$GL_IF_CNDPT	;CALL THE CONDITION CHECKER
	BSBW	IF_LIST_CND_CHK		;CHECK  IF LISTING CONDITIONALS
	CLRL	W^MAC$GL_IF_COUNT	;CLEAR COUNT OF CONDITIONALS WITHIN FALSE CONDITIONALS
	BLBS	W^MAC$GL_IF_VALUE,10$	;BRANCH IF RESULT IS FALSE
	RSB				;TRUE--RETURN TO ASSEMBLE CODE
10$:

;
; SCAN THROUGH THE  FALSE CODE, LOOKING FOR A CHANCE TO START ASSEMBLING
; (THE MATCHING .ENDC)
;

SCAN_FALSE_CODE:
	BSBW	IF_LIST_CND_CHK		;SEE ABOUT LISTING CONDITIONALS
10$:	BSBW	MAC$SYMSCNUP		;Check for (non-local) label
	BLBS	R0,20$
	BSBW	MAC$LCLSKIP		;Try for local label
	BLBC	R0,40$
	BSBW	MAC$SKIPSP
	CMPB	R10,#^A/:/		;Ensure presence of Colon
	BEQL	25$
	BRB	40$
20$:	BSBW	MAC$SKIPSP		;Skip any spaces
	CMPB	R10,#^A/:/		;Presence of Colon indicates label
	BNEQ	30$
25$:	BSBW	MAC$GETCHR		;Found a label -- go back for more
	BRB	10$
30$:	MOVAB	W^IF_SPL_KEYWORDS,R5	;We have a symbol -- look it up
	BSBW	MAC$SRC_LIST		;...
	BLBC	R0,40$			;BRANCH IF NOT FOUND
	PUSHL	SYM$L_VAL(R1)		;FOUND--STACK ROUTINE ADDRESS
	BSBW	MAC$CREF_DIR		;CROSS-REF IT IF CREFFING DIRECTIVES
					;(R1 POINTS TO SYMBOL BLOCK)
	$INTOUT_X INT$_CHKL		;PRINT SOURCE LINES NOT ASSEMBLED
;
; BRANCH TO THE ROUTINE FOR THE SPECIAL SYMBOL.  THE ROUTINE WILL EITHER
; BRANCH BACK TO SCAN_FALSE_CODE TO CONTINUE LOOKING FOR TRUTHE, OR
; IT WILL RETURN IF IT IS TIME TO ASSEMBLE CODE AGAIN.
;
	RSB				;GO TO THE SPECIAL ROUTINE
40$:	PUSHL	W^MAC$GL_INPUTP		;STACK INPUT BLOCK POINTER
	MOVZBL	#CR,R10			;FORCE NEW LINE
	BSBW	MAC$GETCHR		;READ IT
	CMPL	W^MAC$GL_INPUTP,(SP)+	;WAS THERE A CONTEXT CHANGE?
	BEQL	SCAN_FALSE_CODE		;IF EQL NO--KEEP SCANNING
	RSB				;YES--RETURN

	.SBTTL	"IF" CONDITION ROUTINES--EQ,NE,GT,LE,GE,LT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES TEST THE EXPRESSION CONTAINED IN R0 FOR THE
;	CONDITION DESIRED. THE LOW BIT OF 'MAC$GL_IF_VALUE' WILL
;	BE CLEARED IF IT TESTS TRUE, AND SET IF IT TESTS FALSE.
;
;--

IF_EQUAL:
	TSTL	R0			;CHECK CONDITION
	BEQL	IS_TRUE			;IF EQL IS TRUE
	BRB	IS_FALSE		;ELSE IS FALSE

IF_NOT_EQUAL:
	TSTL	R0			;CHECK CONDITION
	BNEQ	IS_TRUE			;IF NEQ IS TRUE
	BRB	IS_FALSE		;ELSE IS FALSE

IF_GREATER:
	TSTL	R0			;CHECK CONDITION
	BGTR	IS_TRUE			;IF GTR IS TRUE
	BRB	IS_FALSE

IF_LESS_EQUAL:
	TSTL	R0			;CHECK CONDITION
	BLEQ	IS_TRUE			;IF LEQ IS TRUE
	BRB	IS_FALSE		;ELSE IS FALSE

IF_LESS_THAN:
	TSTL	R0			;CHECK CONDITION
	BLSS	IS_TRUE			;IF LSS IS TRUE
	BRB	IS_FALSE		;ELSE IS FALSE

IF_GTR_EQUAL:
	TSTL	R0			;CHECK CONDITION
	BLSS	IS_FALSE		;IF LSS THEN FALSE
;**;	BRB	IS_TRUE			;ELSE IS TRUE

IS_TRUE:
	CLRL	R0			;SET FOR TRUTH
	BRB	TRUE_FALSE

IS_FALSE:
	MOVZBL	#1,R0			;SET FOR FALSE
TRUE_FALSE:
	ROTL	#1,W^MAC$GL_IF_VALUE,R1	;MAKE ROOM FOR NEW RESULT
	BISL3	R0,R1,W^MAC$GL_IF_VALUE	;OR IN NEW CONDITION AND STORE IT
	INCL	W^MAC$GL_IF_LEVEL	;COUNT NEW NESTING LEVEL
	CMPL	W^MAC$GL_IF_LEVEL,#32	;NESTING EXCEEDED?
	BLEQ	10$			;IF LEQ NO
	$MAC_ERR IFLEVLXCED		; Yes--get message code
	BRW	MAC$ERRORLN		;ISSUE MESSAGE TO PASS 2 AND RETURN
10$:	RSB

	.SBTTL	'IF' CONDITION ROUTINES--IF_DEFINED

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS THE POINTER MAC$GL_IF_CNDPT TO POINT
;	TO IS_TRUE OR IS_FALSE, DEPENDING ON WHETHER THE SYMBOL
;	IS DEFINED OR NOT.
;
;--

IF_DEFINED:
	PUSHAB	W^IS_TRUE		;IF DEFINED
	PUSHAB	W^IS_FALSE		;IF NOT DEFINED
	BRB	IF_DF

IF_NOT_DEFINED:
	PUSHAB	W^IS_FALSE		;IF DEFINED
	PUSHAB	W^IS_TRUE		;IF NOT DEFINED
IF_DF:	BSBW	MAC$SYMSCNUP		;SCAN A SYMBOL	
	BLBS	R0,10$			;BRANCH IF WE SCANNED ONE
	$MAC_ERR ILLIFCOND		; No--get message code
	CMPL	(SP)+,(SP)+		;CLEAR ROUTINE ADDRESSES
	BRW	MAC$ERRORLN		;ISSUE TO PASS 2 AND RETURN
10$:	BSBW	MAC$SRCUSRSYMTB		;SEARCH SYMBOL TABLE FOR IT
	BLBC	R0,20$			;BRANCH IF NOT FOUND
	BBS	#SYM$V_DEF,SYM$W_FLAG(R1),30$ ;BRANCH IF SYMBOL IS DEFINED
20$:	POPL	W^MAC$GL_IF_CNDPT	;NOT DEFINED--GET RESULT
	TSTL	(SP)+			;CLEAR OTHER RESULT
	RSB
30$:	TSTL	(SP)+			;CLEAR NOT DEFINED RESULT
	POPL	W^MAC$GL_IF_CNDPT	;GET DEFINED RESULT
	RSB

	.SBTTL	'IF' CONDITION ROUTINES--IF_BLANK

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS THE POINTER MAC$GL_IF_CNDPT TO POINT
;	TO IS_TRUE OR IS_FALSE, DEPENDING ON WHETHER OR NOT THE
;	ARGUMENT IS BLANK OR NOT.
;
;--

IF_BLANK:
	PUSHAB	W^IS_TRUE		;IF BLANK
	PUSHAB	W^IS_FALSE		;IF NOT BLANK
	BRB	IF_B			;JOIN COMMON CODE

IF_NOT_BLANK:
	PUSHAB	W^IS_FALSE		;IF BLANK
	PUSHAB	W^IS_TRUE		;IF NOT BLANK
IF_B:	BBCS	#FLG$V_IFSTAT,(R11),.+1	;FLAG WE ARE IN AN IF
	BSBW	MAC$MAC_ARG_SCN		;SCAN THE ARGUMENT
	BBCC	#FLG$V_IFSTAT,(R11),.+1	;NOT IN AN IF ANY MORE
	TSTL	R0			;WAS THE ARGUMENT BLANK?
	BNEQ	10$			;IF NEQ NO
	TSTL	(SP)+			;YES--CLEAR FALSE CONDITION
	POPL	W^MAC$GL_IF_CNDPT	;SET TRUE CONDITION
	RSB
10$:	POPL	W^MAC$GL_IF_CNDPT	;SET FALSE CONDITION
	TSTL	(SP)+			;CLEAR TRUE CONDITION
	RSB

	.SBTTL	DIRECTIVE ROUTINES--IF_IDENTICAL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DETERMINES WHETHER TWO STRINGS ARE IDENTICAL
;	OR NOT, AND SETS THE APPROPRIATE ROUTINE ADDRESS INTO
;	MAC$GL_IF_CNDPT.
;
;--

IF_IDENTICAL:
	PUSHL	R12			;SAVE R12
	PUSHAB	W^IS_TRUE		;TRUE RESULT
	PUSHAB	W^IS_FALSE		;FALSE RESULT
	BRB	IF_IDN			;GO PROCESS IT

IF_DIFFERENT:
	PUSHL	R12			;SAVE R12
	PUSHAB	W^IS_FALSE		;TRUE RESULT
	PUSHAB	W^IS_TRUE		;FALSE RESULT
IF_IDN:	CLRL	R12			;ASSUME NULL FIRST ARGUMENT
	BBSS	#FLG$V_UPMARG,(R11),.+1	; Get arguments upper cased
	BSBW	MAC$MAC_ARG_SCN		;SCAN THE FIRST ARGUMENT
	PUSHL	R0			;STACK THE LENGTH OF THE ARG
	BEQL	20$			;BRANCH IF NULL ARG
	ADDL3	#MXB$K_BLKSIZ,R0,R1	; Include header size
	BSBW	MAC$ALL_BLOCK		; Allocate memory block
	MOVL	R1,MXB$L_PAGES(R0)	; Save block size in block
	ADDL3	#MXB$K_BLKSIZ,R0,R6	; Set pointer to free bytes
	MOVL	R6,R12			; Save pointer
	MOVC3	(SP),W^MAC$AB_TMPBUF,(R6) ;COPY ARG TO VIRT. MEMORY
20$:	BBCS	#FLG$V_IFSTAT,(R11),.+1	;FLAG WITHIN AN IF
	BSBW	MAC$MAC_ARG_SCN		;SCAN SECOND ARGUMENT
	BBCC	#FLG$V_IFSTAT,(R11),.+1	;NO LONGER WITHIN AN IF
	BBCC	#FLG$V_UPMARG,(R11),.+1	; Return normal argument processing
	POPL	R6			;GET LENGTH OF FIRST STRING
50$:	CMPL	R0,R6			;STRINGS THE SAME LENGTH?
	BNEQ	70$			;IF NEQ NO
	TSTL	R0			;YES--ARE THEY BOTH NULL?
	BEQL	60$			;IF EQL YES--THEY ARE THE SAME
	CMPC5	R6,(R12),#0,R0,W^MAC$AB_TMPBUF ;NO--STRINGS IDENTICAL?
	BNEQ	70$			;IF NEQ NO
60$:	TSTL	(SP)+			;CLEAR FALSE RESULT
	POPL	W^MAC$GL_IF_CNDPT	;SET TRUE RESULT
	BRB	80$			;FINISH UP
70$:	POPL	W^MAC$GL_IF_CNDPT	;STORE FALSE RESULT
	TSTL	(SP)+			;POP FALSE RESULT
80$:	MOVL	R12,R0			;GET ADDRESS OF PAGE FOR ARG 1
	BEQL	90$			;IF EQL NO PAGE ALLOCATED
	SUBL2	#MXB$K_BLKSIZ,R0	; Point to base of block
	BSBW	MAC$DEAL_BLOCK		; and deallocate
90$:	POPL	R12			;RESTORE R12
	RSB				;DONE

	.SBTTL	DIRECTIVE ROUTINES--IFF,IFT,IFTF, ENDC

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CAN BE CALLED FROM TWO PLACES: 1) THE SCAN_FALSE_CODE
;	ROUTINE, WHEN IT DETECTS A .IFF WHILE SCANNING FALSE CODE, OR
;	2) FROM THE PARSER.  IT CHECKS THE IF STATUS, AND IF WE ARE
;	SCANNING FALSE CODE, IT BRANCHES TO SCAN_FALSE_CODE TO CONTINUE
;	SCANNING FALSE CODE.  IF IT TESTS TRUE, WE RETURN TO THE PARSER
;	TO ASSEMBLE CODE.
;
;--

IFF::					;DIRECTIVE = KIFF
	BSBB	CHECK_IF_STATUS		;CHECK 'IF' STATUS
	BLBS	W^MAC$GL_IF_VALUE,IF_LIST_CND_CHK ;BRANCH IF NOT IN FALSE CODE
GO_SCAN_FALSE:
	BRW	SCAN_FALSE_CODE		;ELSE CONTINUE SCANNING FALSE CODE

IFT::					;DIRECTIVE = KIFT
	BSBB	CHECK_IF_STATUS		;CHECK 'IF' STATUS
	BLBS	W^MAC$GL_IF_VALUE,GO_SCAN_FALSE ;BRANCH IF WITHIN FALSE
	BRB	IF_LIST_CND_CHK		;ELSE RETURN TO ASSEMBLE CODE

IFTF::					;DIRECTIVE = KIFTF
	BSBB	CHECK_IF_STATUS		;CHECK 'IF' STATUS
	BRB	IF_LIST_CND_CHK		;CHECK LISTING AND RETURN

ENDC::					;DIRECTIVE = KENDC
	SUBL3	#1,W^MAC$GL_IF_LEVEL,R6	;DECREMENT IF LEVEL AND CHECK
	BGEQ	10$			;IF GEQ WITHIN AN IF
	$MAC_ERR NOTINANIF		; No--get message code
	BRW	MAC$ERRORLN		;ISSUE MESSAGE TO PASS 2 AND RETURN
10$:	SUBL3	#1,W^MAC$GL_IF_COUNT,R5	;SEE IF IN NESTED FALSE CONDITIONAL
	BLSS	20$			;IF LSS NO
	MOVL	R5,W^MAC$GL_IF_COUNT	;YES--UPDATE NESTING COUNT
	BRB	GO_SCAN_FALSE		;AND CONTINUE SCANNING FALSE CODE
20$:	MOVL	R6,W^MAC$GL_IF_LEVEL	;UPDATE IF LEVEL
	BICL3	#1,W^MAC$GL_IF_VALUE,R0	;PREPARE TO BRING TRUTH INTO HIGH BIT
	ROTL	#-1,R0,W^MAC$GL_IF_VALUE ;DO IT NOW
;**;	BRB	IF_LIST_CND_CHK		;CHECK LISTING STATUS AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	IF NOT LISTING CONDITIONALS, CODE IS EMITTED TO PASS 2 TO
;	CLEAR THE LISTING FLAG, MAC$GL_LIST_IT.
;
;--

IF_LIST_CND_CHK:
	BLBS	W^LST$G_CONDITION+SYM$L_VAL,CK_EXIT ;BRANCH IF LISTING
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;NO--
CK_EXIT:RSB


;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS TO ENSURE WE ARE IN AN IF STATEMENT.
;	IF WE ARE NOT, IT ISSUES AN ERROR MESSAGE TO PASS 2
;	AND RETURNS.  IF WE ARE, THEN IF WE ARE SKIPPING CODE, THE
;	STACK IS POPPED AND WE BRANCH TO SCAN_FALSE_CODE TO CONTINUE
;	SKIPPING CODE.
;
;--

CHECK_IF_STATUS:
	TSTL	W^MAC$GL_IF_LEVEL	;ARE WE IN AN IF?
	BGTR	10$			;IF GTR YES
	$MAC_ERR NOTINANIF		; No--get message code
	BRW	MAC$ERRORLN		;ISSUE MESSAGE AND RETURN
10$:	TSTL	W^MAC$GL_IF_COUNT	;INSIDE NESTED FALSE CONDITIONAL?
	BLEQ	20$			;IF LEQ NO
	TSTL	(SP)+			;YES--CLEAR RETURN
	BRW	SCAN_FALSE_CODE		;AND CONTINUE SCANNING FALSE CODE
20$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED IF A .END STATMENT IS ENCOUNTERED
;	WHILE SCANNING THE FALSE CONDITIONAL CODE.
;
;--

IF_ERROR:
	CLRL	W^MAC$GL_IF_VALUE	;EVERYTHING IS TRUE
	$MAC_ERR UNTERMCOND		; Get message code
	BRW	MAC$ERRORLN		;ISSUE MESSAGE AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED IF A .IF STATEMENT IS ENCOUNTERED
;	WHILE SCANNING THE FALSE CONDITION CODE.
;
;--

IF_IN_AN_IF:
	INCL	W^MAC$GL_IF_COUNT	;BUMP FALSE CONDITIONAL NESTING COUNT
	BRW	SCAN_FALSE_CODE		;CONTINUE SCANNING FALSE CODE

	.SBTTL	.IIF DIRECTIVE ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	IIF IS CALLED WHEN A .IIF DIRECTIVE IS DETECTED.  THE IIF_HEAD
;	IS SCANNED.  THE PARSER WILL THEN CALL IIF1 TO FINISH PROCESSING
;	THE .IIF DIRECTIVE.
;
;--

IIF::					;IIF_HEAD = KIIF
	BBCS	#FLG$V_IIF,(R11),.+1	;FLAG THIS IS .IIF
	BSBW	IFHD1			;SCAN THE CONDITION
	BBCC	#FLG$V_IIF,(R11),.+1	;CLEAR .IIF FLAG
	BRW	IF_LIST_CND_CHK		;CHECK LISTING AND RETURN

IIF1::					;IIF_STAT = IIF_HEAD EXPR DCOMMA
	BBS	#FLG$V_COMPEXPR,(R11),10$ ;BRANCH IF COMPILE TIME EXPRESSION
	$MAC_ERR IFEXPRNABS		; No--get message code
	BSBW	MAC$ERRORLN		;ISSUE TO PASS 2
10$:	MOVL	W^MAC$AL_VALSTACK-4[R7],R0 ;GET THE VALUE
	JSB	@W^MAC$GL_IF_CNDPT	;CALL THE ROUTINE TO EVALUATE CONDITION
	MOVL	W^MAC$GL_IF_VALUE,R0	;GET THE 'IF' VALUE
	BICL3	#1,R0,R1		;SET TO BRING TRUTH INTO HI BIT
	ROTL	#-1,R1,W^MAC$GL_IF_VALUE ;DO IT AND STORE
	DECL	W^MAC$GL_IF_LEVEL	;DROP DOWN AN IF LEVEL
	BLBS	R0,IIF_FALSE		;BRANCH IF FALSE
	BRB	IIF_TRUE		;GO TO TRUE EXIT

IIF2::					;IIF_STAT = IIF_HEAD DCOMMA
	CMPL	W^MAC$GL_IF_CNDPT,#IS_FALSE ; WAS CONDITION FALSE?
	BNEQ	IIF_TRUE		;BRANCH IF NOT
IIF_FALSE:
	MOVZBL	#CR,R10			;FORCE NEW LINE
IIF_TRUE:
	BBCS	#FLG$V_BOL,(R11),.+1	;SET BOL FLAG
	BBCC	#FLG$V_OPRND,(R11),.+1	;NOT IN OPERAND FIELD
	RSB

	.END
