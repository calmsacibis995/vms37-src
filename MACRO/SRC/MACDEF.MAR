	.TITLE	MAC$MACDEF	MACRO DEFINITION PROCESSOR
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V03.00	MTR0009		Mike Rhodes	15-Mar-1982
;		Modify routine MACRO:: to de-optimize the handling of
;		null macros.  Fixes SPR #11-42119.
;
;	V01.10	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.09	RN0010		R. Newland	 5-Sep-1979
;		Multipage MXB blocks
;
;	V01.08	RN0008		R. Newland	31-Aug-1979
;		31 character symbols (macro names)
;
;	V01.07	RN0005		R. Newland	13-Aug-1979
;		Variable symbol name storage
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_INTCODDEF			;DEFINE INT. FILE CODES
	$MAC_INPBLKDEF			;DEFINE INPUT BLOCK OFFSETS
	$MAC_MNBDEF			;DEFINE MNB/MAB OFFSETS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_CRFLAGDEF			;DEFINE CREF CONTROL FLAGS
	$MACMSGDEF			; Define message codes
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS

;
; EQUATED SYMBOLS:
;

	.PSECT	MAC$RO_CODE_MAC,NOWRT,GBL,LONG

	.SBTTL	MACRO	DEFINE A MACRO

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A '.MACRO' DIRECTIVE IS SCANNED.
;	THE MACRO FORMAL ARGS ARE SCANNED, AND THE MACRO BODY IS
;	SCANNED AND PLACED IN CORE.  THE MACRO DEFINITION IS ENTERED
;	IN THE USER MACRO HASH TABLE.
;
;--

MACRO::					;DIRECTIVE = KMACRO
	BLBS	W^LST$G_MACRODEF+SYM$L_VAL,10$ ;BRANCH IF LISTING MACRO DEFINITIONS
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;NO--DO NOT LIST
10$:	BSBW	MAC$SYMSCNUP		;SCAN MACRO NAME
	BLBS	R0,20$			;BRANCH IF NAME FOUND
	$MAC_ERR ILLMACNAM		; No--get message code
	MOVL	#CR,R10			;FORCE NEW LINE
	BRW	MAC$ERRORLN		;ISSUE ERROR AND RETURN
20$:	MOVAB	W^MAC$AL_UMCHSHTB,R3	;POINT TO USER MACRO HASH TABLE
	BSBW	MAC$SRCSYMTAB		;LOOK UP THE MACRO NAME
	BLBC	R0,30$			;BRANCH IF NOT FOUND
	PUSHL	R2			;FOUND--SAVE PTR TO PREVIOUS
	BSBW	FREE_UP_MACRO		;DELETE OLD DEFINITION
	POPL	R2			;RESTORE PTR TO PREVIOUS
30$:	BSBW	MACRO_DEFINE		;DEFINE THE MACRO
	MOVZBL	#CRF$K_DEF,R5		;THIS IS MACRO DEFINITION
	BSBW	MAC$CREF_MACRO		;CREF IT IF CREFFING
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;STOP ON A COMMA?
	BNEQ	40$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
;
; SCAN FORMAL ARGUMENTS
;
40$:	BSBW	MACRO_ARG_SCAN		;SCAN FORMAL ARGUMENTS AND SET UP
					;MAB'S FOR THEM
	MOVL	W^MAC$GL_ARGPTR,MNB$L_TXTP(R6) ;STORE POINTER TO TEXT
	MOVZBL	#CR,R10			;FORCE READING OF NEW LINE
	BSBW	MAC$GETCHR		;READ FIRST CHARACTER OF BODY
	PUSHL	MNB$L_ARGP(R6)		;STACK THE ARGUMENT POINTER
	SUBL3	W^MAC$GL_BLKPTR,-	;FIGURE SPACE LEFT IN BLOCK
		W^MAC$GL_ARGPTR,R0	;(THIS GIVES SPACE USED)
	SUBL3	R0,#512,-(SP)		;FIGURE SPACE LEFT AND STACK IT
	PUSHL	W^MAC$GL_ARGPTR		;STACK POINTER TO FREE SPACE IN BLOCK
	CALLS	#3,W^MAC$BODY_SCAN	;SCAN THE MACRO BODY AND READ
					;IT INTO CORE
;
; MACRO IS SCANNED.  SEE IF THERE WAS A SYMBOL NAME FOLLOWING THE
; .ENDM DIRECTIVE.
;
50$:	INCL	W^MAC$GL_MCDEF		;COUNT ANOTHER MACRO DEFINITION
	BSBW	MAC$SYMSCNUP		;IS THERE A SYMBOL?
	BLBC	R0,60$			;IF LBC NO
	MOVL	W^MAC$GL_MACPTR,R0	;YES--GET PTR TO MNB OF MACRO
	MOVZBL	MNB$B_NAME(R0),R1	; Get offset to symbol count/name
	SUBL2	R1,R0			; and form its address
	MOVZBL	(R0)+,R1		;GET SIZE OF NAME
	MOVAB	W^MAC$AB_TMPSYM,R2	;POINT TO SCANNED NAME
	MOVZBL	(R2)+,R3		;GET ITS SIZE
	CMPC5	R1,(R0),#0,R3,(R2)	;RIGHT .ENDM FOR THIS MACRO?
	BEQL	60$			;IF EQL YES
	$INTOUT_X INT$_CHKL		;NO--ALIGN SOURCE AND LISTING
	$MAC_ERR ENDWRNGMAC		; Get message code
	BRW	MAC$ERRORPT		;ISSUE AND RETURN
60$:	RSB

	.SBTTL	DELETE		.MDELETE DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS THE .MDELETE DIRECTIVE.  THE
;	ARGUMENT TO THE DIRECTIVE IS A LIST OF MACRO NAMES.   IF ANY
;	OF THE MACROS NAMED ARE DEFINED, THEY ARE UNDEFINED.  THE LITERAL
;	PRINTED WITH THE LISTING IS THE NUMBER OF MACROS DELETED.
;
;--

DELETE::				;DIRECTIVE = KMDELETE
	CLRL	-(SP)			;INITIALIZE COUNT OF MACROS DELETED
10$:	BSBW	MAC$SYMSCNUP		;SCAN A MACRO NAME
	BLBS	R0,20$			;BRANCH IF WE FOUND ONE
	$MAC_ERR DIRSYNX		; No-directive syntax error
	BSBW	MAC$ERRORPT		;REPORT ERROR
	MOVL	#CR,R10			;FORCE NEW LINE
	BRB	50$			;FINISH PROCESSING
20$:	MOVAB	W^MAC$AL_UMCHSHTB,R3	;LOOK UP IN MACRO HASH TABLE
	BSBW	MAC$SRCSYMTAB		;...
	BLBC	R0,30$			;BRANCH IF NOT FOUND (EASY OUT)
	BSBB	FREE_UP_MACRO		;FOUND--DELETE DEFINITION
	INCL	(SP)			;COUNT MACRO AS DELETED
30$:	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;STOP ON A COMMA?
	BNEQ	40$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP OVER IT
	BSBW	MAC$SKIPSP		;SKIP SPACES AGAIN
40$:	CMPB	R10,#CR			;AT EOL?
	BNEQ	10$			;IF NEQ NO--KEEP SCANNING
50$:	POPL	R3			;YES--GET COUNT OF MACROS DELETED
	$INTOUT_LW INT$_PRIL,R3		;PRINT # MACROS DELETED
	RSB

	.SBTTL	FREE_UP_MACRO	DELETE OLD MACRO DEFINITION

;++
; FUNCTIONAL DESCRIPTION:
;
;--

FREE_UP_MACRO:
	PUSHL	R6			;SAVE R6
	MOVL	MNB$L_LINK(R1),MNB$L_LINK(R2) ; Unlink MNB from the list
	MOVL	R1,R6			;SAVE POINTER
	MOVL	W^MAC$GL_INPUTP,R3	;POINT TO CURRENT INPUT BLOCK
10$:	CMPL	R1,INP$L_RPTCNT(R3)	;REDEFINING THIS MACRO?
	BNEQ	20$			;IF NEQ NO
	BBCS	#31,INP$L_RPTCNT(R3),30$ ;YES--FLAG TO DELETE THE OLD DEF.
	BRB	30$			;(SAFTEY FIRST!)
20$:	MOVL	(R3),R3			;LINK TO NEXT INPUT BLOCK
	CMPL	R3,#MAC$GL_PRMINBL	;LOOKING AT PRIMARY INPUT BLOCK?
	BNEQ	10$			;IF NEQ NO
	BSBB	MAC$DEL_MAC_DEF		;DELETE THE MACRO DEFINITION
30$:	POPL	R6			;RESTORE R6
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DELETES THE MACRO DEFINITION POINTED TO BY R6.
;	THE MNB IS NOT DEALLOCATED IF CREFFING MACROS.
;
;--

MAC$DEL_MAC_DEF::
	DECL	W^MAC$GL_MCDEF		;UN-COUNT THE MACRO DEFINITION
	CLRL	MNB$L_TXTP(R6)		;CLEAR TEXT POINTER
	BBS	#CRF$V_MACROS,W^MAC$GL_CRF_FLG,5$ ;BRANCH IF CREFFING MACROS
	MOVZBL	MNB$B_NAME(R6),R0	; Get offset to symbol count/name
	SUBL3	R0,R6,R0		; and get start address of page
	MOVL	MNB$L_PAGP(R6),R6	;POINT TO THE PAGE LIST
	BSBW	MAC$DEA_1_PAGE		; Deallocate MNB which is always 1 page
	DECL	W^MAC$GL_MCPGRQ		; One less page for macro definitions
	BRB	20$			;GO FREE SOME PAGES
5$:	MOVL	MNB$L_PAGP(R6),R0	;POINT TO POSSIBLE PAGE TO FREE
	CLRL	MNB$L_PAGP(R6)		;AND PAGE POINTER
	MOVL	R0,R6			;ANY PAGES TO FREE?
	BEQL	30$			;IF EQL NO--ALL DONE
10$:	MOVL	R6,R0			;GET SET TO FREE CURRENT PAGE
	MOVL	MXB$L_LINK(R6),R6	; Point R6 to possible next block
	SUBL2	MXB$L_PAGES(R0), -	; Subtract size of block from pages
		W^MAC$GL_MCPGRQ		; used for macro definitions
	BSBW	MAC$DEAL_BLOCK		; Deallocate block of memory
20$:
	TSTL	R6			;ANY MORE PAGES?
	BNEQ	10$			;IF NEQ YES--GO DO THEM
30$:	RSB

	.SBTTL	MACRO_DEFINE CREATE MNB AND SET IT UP

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES A PAGE FOR A MACRO NAME BLOCK AND
;	MACRO ARG BLOCKS.  THE MNB IS INITIALIZED AND THE POINTER
;	IS RETURNED IN MAC$GL_MACPTR.
;
;--

MACRO_DEFINE:
	PUSHL	R2			;SAVE PTR TO PREVIOUS
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE A PAGE FOR THE MNB
	INCL	W^MAC$GL_MCPGRQ		;COUNT PAGE FOR MACRO DEFINITION
	MOVL	R0,W^MAC$GL_BLKPTR	; Set pointer to start of block
	MOVZBL	W^MAC$AB_TMPSYM,R1	; Get symbol count
	CMPB	R1,#SYM$K_TWOCOL	; Wide listing format required?
	BLSS	10$			; No if LSS
	BBSS	#FLG$V_MAC2COL,(R11),10$ ; Set flag for wide macro name listing
10$:
	INCL	R1			; Include the count byte
	MOVC3	R1,W^MAC$AB_TMPSYM,(R0)	; Copy symbol count/name into MNB
	MOVL	R3,R6			; Save address of MNB
	MOVL	R6,W^MAC$GL_MACPTR	; and return address in MACPTR
	POPL	R0			;RESTORE PTR TO PREVIOUS
	MOVL	MNB$L_LINK(R0),(R3)+	; Link in new MNB
	MOVL	R6,MNB$L_LINK(R0)	; ...
	ADDB3	#1,W^MAC$AB_TMPSYM,(R3)+; Insert name offset
	CLRL	(R3)+			;CLEAR TXTP
	CLRW	(R3)+			;CLEAR FLAGS
	CLRL	(R3)+			;CLEAR PAGP
	MOVL	#1,(R3)+		;INITIALIZE PAGC (PAGE COUNT)
	CLRL	(R3)+			;CLEAR CRSYMF
	CLRB	(R3)+			;CLEAR ARG COUNT
	CLRL	(R3)+			;CLEAR ARG POINTER
	MOVL	R3,W^MAC$GL_ARGPTR	;STORE POINTER FOR MAB ALLOCATION
	RSB

	.SBTTL	MACRO_ARG_SCAN SCAN FORMAL MACRO ARGUMENTS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SCANS THE FORMAL MACRO ARGUMENTS AND STORES
;	THEM IN MACRO ARGUMENT BLOCKS (MAB'S) THAT ARE LINKED TO
;	THE MACRO NAME BLOCK.
;
;--

MACRO_ARG_SCAN:
	PUSHR	#^M<R7,R8,R12>		;SAVE REGISTERS
	MOVL	W^MAC$GL_ARGPTR,R8	;POINT TO FREE SPACE IN BLOCK
	MOVZBL	MNB$B_NAME(R6),R0	; Get bytes used to store symbol name
	SUBL3	R6,R8,R7		; Figure bytes used for fixed-sized MNB
	ADDL2	R0,R7			; Add fixed and variable parts
	SUBL3	R7,#512,R7		;REALLY GET SPACE LEFT NOW
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#CR			;SKIP TO END OF LINE?
	BNEQ	10$			;IF NEQ NO
	BRW	ARG_SCAN_EXIT		;YES--NO FORMAL ARGS HERE
10$:

ARG_SCAN_LOOP:
	BSBW	MAC$SKIPSP		;SKIP LEADING SPACES
	CMPB	R10,#^A/?/		;CREATED SYMBOL?
	BNEQ	30$			;IF NEQ NO
	CMPB	MNB$B_ARGCT(R6),#31	;ONLY FIRST 32 SYMBOLS CAN BE CREATED
	BGTRU	30$			;IF GTR THEN LOSE
	MOVZBL	MNB$B_ARGCT(R6),R0	;GET ARGUMENT NUMBER - 1
	BBCS	R0,MNB$L_CRSYMF(R6),20$	;SET CREATED SYMBOL FLAG FOR THIS ARG
20$:	BSBW	MAC$GETCHR		;SKIP THE QUESTION MARK
	BSBW	MAC$SKIPSP		;SKIP LEADING SPACES
30$:	BBS	#CHR$V_SYM_CHR,-	;BRANCH IF LEGAL CHAR FOR ARG
		W^MAC$AB_CMSK_TAB(R10),80$
	$MAC_ERR ILLMACARGN		; No--get error code
	BSBW	MAC$ERRORLN		;ISSUE ERROR TO PASS 2
;
; LOOP LOOKING FOR END OF ARGUMENT OR END OF LINE
;
40$:	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	CMPB	R10,#^A/,/		;START OF NEXT ARG?
	BEQL	50$			;IF EQL YES
	CMPB	R10,#TAB		;TAB?
	BEQL	60$			;IF EQL YES
	CMPB	R10,#^A/ /		;SPACE?
	BEQL	60$			;IF EQL YES
	CMPB	R10,#CR			;NO--END OF LINE?
	BEQL	70$			;IF EQL YES
	BRB	40$			;NO--KEEP SKIPPING
;
; FOUND A COMMA
;
50$:	BSBW	MAC$GETCHR		;SKIP THE COMMA
60$:	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#CR			;DID WE SKIP TO END OF LINE?
	BNEQ	ARG_SCAN_LOOP		;IF NEQ NO--CONTINUE SCANNING ARGS
70$:	BRW	150$			;QUIT ON EOL
;
; CHARACTER CAN LEGALLY START A MACRO ARGUMENT
;
80$:	BSBW	MAC$SYMSCNUP		;GET SYMBOL NAME
	PUSHL	R6			;SAVE PTR TO MNB
	MOVAB	MNB$L_ARGP(R6),R6	;POINT TO ARGUMENT LIST
	MOVL	R6,R5			;MAKE A COPY
	BSBW	MAC$SRC_LIST		;LOOK IT UP
	POPL	R6			;RESTORE MNB POINTER
	PUSHL	R0			;SAVE THE SEARCH RESULT
	MOVL	R1,W^MAC$GL_ARGPTR	;SAVE POINTER TO MAB IN CASE FOUND
	MOVAL	MAB$W_DVLEN(R1),R3	;ASSUME WE FOUND IT
	BLBS	R0,100$			;BRANCH IF FOUND
	MOVL	R8,R3			;NO--GET PTR TO FREE MAB SPOT ON PAGE
	MOVZBL	W^MAC$AB_TMPSYM,R0	; Get symbol name length
	INCL	R0			; Include count byte
	SUBL2	R0,R7			; Subtract from space in block
	SUBL2	#MAB$K_BLKSIZ,R7	;IS THERE ROOM IN BLOCK FOR MAB?
	BGTR	90$			;IF GTR YES
	BSBW	MAC$ALL_1_PAGE		;NO--GET ANOTHER PAGE
	INCL	W^MAC$GL_MCPGRQ		;COUNT PAGE FOR MACRO DEFINITION
	MOVL	R0,R8			;PAGE ADDRESS TO R8
	MOVL	R0,W^MAC$GL_BLKPTR	;SET NEW PAGE START
	ASSUME	MXB$L_LINK EQ 0
	ASSUME	MXB$L_PAGES EQ MXB$L_LINK+4
	MOVL	MNB$L_PAGP(R6),(R8)+	;LINK NEW PAGE INTO PAGE LIST
	MOVL	R0,MNB$L_PAGP(R6)	;...
	MOVL	#1,(R8)+		; Size of block is 1 page
	INCL	MNB$L_PAGC(R6)		;COUNT ANOTHER PAGE FOR DEF.
	MOVZWL	#<512-MXB$K_BLKSIZ-MAB$K_BLKSIZ>,R7 ; Set block count
	MOVL	R8,R3			;SET POINTER IN R3 ALSO
90$:
	PUSHL	R2			; Save previous pointer
	MOVZBL	W^MAC$AB_TMPSYM,R0	; Get symbol name length
	INCL	R0			; Include count byte
	MOVC3	R0,W^MAC$AB_TMPSYM,(R3)	; Copy symbol count/name to MAB
	MOVL	R3,W^MAC$GL_ARGPTR	; Set new argument pointer
	POPL	R2			; Restore previous pointer
	MOVL	MAB$L_LINK(R2),(R3)+	; Copy previous link to new MAB
	MOVL	W^MAC$GL_ARGPTR,MAB$L_LINK(R2) ; Point previous link to new MAB
	ADDB3	#1,W^MAC$AB_TMPSYM,(R3)+; Store name offset
	INCB	MNB$B_ARGCT(R6)		;COUNT THE ARGUMENT
	MOVB	MNB$B_ARGCT(R6),(R3)+	;STORE ARGUMENT NUMBER
100$:	MOVL	R3,R12			;SAVE KEYWORD LINK POINTER
	CLRW	(R3)+			;CLEAR DEFAULT VALUE LENGTH
	CLRL	(R3)+			;CLEAR DEFAULT VALUE PTR
	TSTL	(SP)+			;DID WE FIND THE MAB OR MAKE NEW ONE?
	BNEQ	110$			;IF NEQ WE FOUND IT--DON'T UPDATE PTR
	MOVL	R3,R8			;STORE POINTER TO NEXT MAB
110$:	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/=/		;KEYWORD ARG?
	BNEQ	130$			;IF NEQ NO
;
; SCAN DEFAULT ARGUMENT
;
	BSBW	MAC$GETCHR		;GET FIRST CHARACTER OF ARGUMENT
	BSBW	MAC$MAC_ARG_SCN		;SCAN DEFAULT ARG
	TSTL	R0			;WAS IT NULL?
	BEQL	130$			;IF EQL YES
	MOVW	R0,(R12)+		;STORE DEFAULT VALUE LENGTH
	SUBL2	R0,R7			;IS THERE ROOM FOR DEFAULT STRING?
	BGTR	120$			;IF GTR YES
	PUSHL	R0			;NO--SAVE SIZE OF DEFAULT ARG
	ADDL3	#MXB$K_BLKSIZ,R0,R1	; Compute total size of block required
	BSBW	MAC$ALL_BLOCK		; Allocate block of memory
	ADDL2	R1,W^MAC$GL_MCPGRQ	; Add pages allocated to macro definitions
	MOVL	R0,R8			;PAGE ADDRESS TO R8
	MOVL	R0,W^MAC$GL_BLKPTR	;SET PAGE START ADDRESS IN BLKPTR
	MOVL	MNB$L_PAGP(R6),(R8)+	;LINK NEW PAGE INTO PAGE LIST
	MOVL	R0,MNB$L_PAGP(R6)	;...
	MOVL	R1,(R8)+		; Insert block size in block
	ADDL2	R1,MNB$L_PAGC(R6)	; Add pages to total used to define macro
	ASHL	#9,R1,R7		; Compute block size in bytes
	SUBL2	#MXB$K_BLKSIZ,R7	; and subtract MXB header size
	POPL	R0			;SAVE SIZE OF DEFAULT ARG
	SUBL2	R0,R7			; Subtract size of argument
120$:	MOVL	R8,(R12)+		;STORE DEFAULT VALUE POINTER
	MOVC3	R0,W^MAC$AB_TMPBUF,(R8)	;COPY INTO BLOCK
	MOVL	R3,R8			;UPDATE ARG POINTER
130$:	CMPB	R10,#^A/,/		;STOP ON A COMMA?
	BNEQ	140$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--GET NEXT CHARACTER
140$:	CMPB	R10,#CR			;END OF LINE?
	BEQL	150$			;IF EQL NO
	BRW	ARG_SCAN_LOOP		;NO--CONTINUE SCANNING ARGS
150$:	MOVL	R8,W^MAC$GL_ARGPTR	;STORE UPDATED ARG POINTER

ARG_SCAN_EXIT:
	POPR	#^M<R7,R8,R12>		;RESTORE REGISTERS
	RSB

	.END
