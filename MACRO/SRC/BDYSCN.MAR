	.TITLE	MAC$BDYSCN	SCAN MACRO BODY
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V01.14	RN0029		R. Newland	 9-Feb-1980
;		Copy macro comments correctly into virtual memory.
;		SPR 11-28597
;
;	V01.13	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.12	RN0010		R. Newland	 5-Sep-1979
;		Multipage MXB blocks
;
;	V01.14	RN0028		R. Newland	18-Jan-1980
;		Do not process lexical functions for macros defined
;		within another macro.  SPR 11-28098
;
;	V01.14	RN0025		R. Newland	15-Dec-1979
;		Copy symbols correctly from macro body.
;		SPR 11-27450
;
;	V01.11	RN0005		R. Newland	13-Aug-1979
;		Remove .ALIGN LONG and .DEBUG statements
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_INTCODDEF			;DEFINE INTER. BUFFER CODES
	$MAC_MTXDEF			;DEFINE SPECIAL MACRO TEXT OPERATOR BYTES
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_MNBDEF			;DEFINE MNB OFFSETS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; LOCAL DATA
;
	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG

	INSYMP	=	0

	$MAC_INSERT_SYM	EXTRACT,LEXICAL_EXTRACT,MTX$_LXEXT ;%EXTRACT
	$MAC_INSERT_SYM	LENGTH,LEXICAL_LENGTH,MTX$_LXLEN   ;%LENGTH
	$MAC_INSERT_SYM	LOCATE,LEXICAL_LOCATE,MTX$_LXLOC,- ;%LOCATE
			MAC$LEX_OP_LIST

	.PSECT	MAC$RO_CODE_MAC,NOWRT,GBL,LONG

	.SBTTL	MAC$BODY_SCAN	SCAN MACRO BODY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SCAN A MACRO, REPEAT OR INDEFINITE
;	REPEAT BODY AND READ IT INTO VIRTUAL MEMORY.
;
; CALLING SEQUENCE:
;
;	CALLX	X,MAC$BODY_SCAN
;
; INPUTS:
;
;	4(AP)		POINTER TO WHERE TO START STORING TEXT
;	8(AP)		NO. OF BYTES LEFT IN BLOCK POINTED TO BY 4(AP)
;	12(AP)		POINTER TO MACRO ARGUMENT LIST OR 0 IF NO ARGS
;
; OUTPUTS:
;
;	R0		0 IF NULL MACRO BODY, ELSE NON-ZERO
;
;	THE MACRO TEXT WILL BE STORED AT THE APPOINTED LOCATION.  ANY
;	ADDITIONAL PAGES REQUIRED WILL BE GOTTEN AND THE PAGES WILL BE
;	LINKED INTO THE MACRO NAME BLOCK PAGE LIST (MNB$L_PAGP).  UNLESS
;	FLG$M_RPTIRP IS SET THE ADDITIONAL PAGES WILL BE COUNTED IN THE
;	NUMBER OF PAGES USED TO DEFINE MACROS.
;
;--

MAC$BODY_SCAN::
	.WORD	^M<R6,R7,R8>		;REGISTER SAVE MASK
	CLRL	-(SP)			;ASSUME NULL MACRO BODY
	MOVL	#1,W^MAC$GL_MCLVL	;START AT MACRO LEVEL 1
	MOVL	4(AP),R8		;POINT TO THE BLOCK
	SUBL3	#6,8(AP),R7		;GET CHARACTER COUNT AND LEAVE
					;ROOM FOR LINK FLAG WORD AND LINK
	BGTR	20$			;BRANCH IF THERE IS ROOM
	CVTBW	#MTX$_TXTLNK,(R8)+	;NO--START WITH A LINK
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE A PAGE
	BSBW	MAC$VSTO_GET_0		;SETUP LINK
20$:

;
; COME HERE AT THE BEGINNING OF EACH NEW LINE.  THE ADDRESS OF THE COUNT
; WORD FOR THIS LINE IS STACKED SO WE CAN STORE THE LINE COUNT THERE AT
; THE END OF THE LINE.  FIRST WE MUST CHECK TO SEE IF THERE IS ROOM TO
; STORE THE COUNT WORD.  IF NOT, GET A NEW PAGE AND SET THE SPECIAL
; COUNT WORD LINK FLAG.
;

BODY_SCAN_LOOP:
	BBCC	#FLG$V_SPECOP,(R11),.+1	;CLEAR SPECIAL OPERATOR FLAG
	PUSHL	R8			;SAVE PTR TO BEGINNING OF LINE
	SUBL3	#8,R7,R0		;SEE IF ROOM FOR COUNT, TXTLNK, AND LINK
	BGTR	10$			;IF GTR YES
	CVTBW	#MTX$_TXTLNK,(R8)+	;NO--START WITH A LINK
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE A PAGE
	BSBW	MAC$VSTO_GET_0		;SETUP LINK
	MOVL	R8,(SP)			;UPDATE BEGINNING OF LINE PTR
10$:	CLRW	(R8)+			;CLEAR BYTE COUNT (FILLED IN LATER)
	CLRL	R6			;INIT COUNT OF CHARS STORED
	SUBL2	#2,R7			;DECREMENT BYTES REMAINING
	MOVZBL	W^MAC$AB_LINEBF,R10	;COPY 1ST CHAR IN CASE ";"
	BICL2	#FLG$M_ALLCHR!FLG$M_CONT!FLG$M_SPLALL,(R11) ;DO NOT PASS ALL CHARS
					       ;AND NO CONT. LINES
	BLBS	W^LST$G_MACRODEF+SYM$L_VAL,20$ ;BRANCH IF LISTING MACRO DEFS
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;NO--SEND TO PASS 2
20$:	BBCS	#FLG$V_ENDMCH,(R11),30$	;ALLOW DIRECTIVE CHECKING
;
; HERE FOR EACH NEW CHARACTER IN THE LINE
;
30$:	CMPB	R10,#^A/%/		;POSSIBLY A LEXICAL OPERATOR?
	BNEQ	35$			;IF NEQ NO
	CMPL	W^MAC$GL_MCLVL,#1	; In outer macro (the macro being defined)?
	BNEQ	35$			; No if NEQ, do not process lexical fns
	BSBW	SCAN_PERCENT		;YES--CHECK IT OUT
	BRB	30$			;CONTINUE SCANNING WITH NEXT
					;CHARACTER AFTER THE OPERATOR
35$:	CMPB	R10,#CR			;END OF LINE?
	BEQL	40$			;IF EQL YES--DO END OF LINE PROCESSING
	BBC	#CHR$V_SYM_CHR,-	;BRANCH IF CHAR CANNOT
		W^MAC$AB_CMSK_TAB(R10),42$ ;START A SYMBOL
	PUSHL	W^MAC$GL_LINEPT		; Save line pointer
	BISL2	#FLG$M_ALLCHR,(R11)	; Pass all characters
	BSBW	MAC$SYMSCNUP1		; Scan a symbol
	BICL2	#FLG$M_ALLCHR,(R11)	; Clear ALLCHR flag
	POPL	R4			; Reset stack and get line pointer
	CMPB	R10,#^A/:/		;IS IT A LABEL?
	BEQL	50$			;IF EQL YES--DON'T CHECK IT
	BBCC	#FLG$V_ENDMCH,(R11),60$	;NO--CHECKING DIRECTIVES?
					;(AND DISABLE CHECKING)
	CMPB	W^MAC$AB_TMPSYM+1,#^A/./;YES--CAN SYMBOL BE A DIRECTIVE?
	BNEQ	60$			;IF NEQ NO
	MOVAB	MAC$G_SPLMC_DIR,R5	;POINT TO LIST
	BSBW	MAC$SRC_LIST		;SEE IF SPECIAL MACRO DIRECTIVE
	BLBC	R0,60$			;BRANCH IF NOT FOUND
	JSB	@SYM$L_VAL(R1)		;YES--PROCESS THE DIRECTIVE
	TSTL	W^MAC$GL_MCLVL		;STILL IN A MACRO?
	BGTR	90$			;IF GTR YES
40$:	BRW	BODY_SCAN_END		;NO--EXIT
42$:	BRB	100$			;BRANCH AID
50$:	BBCS	#FLG$V_ENDMCH,(R11),60$	;JUST SCANNED A LABEL, ALLOW
					;CHECKING OF DIRECTIVES
60$:
;
; SEE IF A MACRO ARGUMENT
;
	MOVL	12(AP),R5		;POINT TO MACRO ARG NAMES
	BEQL	95$			; If EQL no macro argument names
65$:	BSBW	MAC$SRC_LIST		;SEE IF A MACRO ARG
	BLBC	R0,95$			; Branch if not
	CMPB	-1(R8),#^A/'/		;YES--CONCATENATION PRECEDING
					;MACRO ARG?
	BNEQ	70$			;IF NEQ NO
	DECL	R8			;YES--BACKUP POINTER
	INCL	R7			;ADJUST COUNTER
	DECL	R6			;DECREMENT COUNT OF CHARS STORED
70$:	MOVL	#2,R0			;SET TO STORE TWO BYTES
	PUSHL	R1			;SAVE MAB ADDRESS
	BSBW	MAC$VSTO_SET		;...
	MOVB	#MTX$_ARGMRK,(R8)+	;MARK MACRO ARG
	BBSS	#FLG$V_SPECOP,(R11),.+1	;FLAG SPECIAL OPERATOR ON LINE
	POPL	R1			;RESTORE MAB ADDRESS
	MOVB	MAB$B_ARGNO(R1),(R8)+	;STORE ARGUMENT NUMBER
	CMPB	R10,#^A/'/		;POST-CONCATENATION?
	BNEQ	80$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--EAT THE QUOTE
80$:	BRW	30$			;PROCESS NEXT CHARACTER
;
; COPY DIRECTIVE TO OUTPUT
;
90$:	MOVAB	W^MAC$AB_TMPSY1,R2	;POINT TO DIRECTIVE NAME
	MOVZBL	(R2)+,R3		;GET LENGTH OF NAME
	BRB	98$
;
; Copy non-argument string to output
;
95$:
	SUBL3	#1,R4,R2		; Get address of string
	SUBL3	R4,W^MAC$GL_LINEPT,R3	; and compute its size
98$:
	BSBW	MAC$VSTO_STR		;COPY TO VIRTUAL BUFFER
	BRB	80$			;PROCESS NEXT CHARACTER
;
; CHARACTER NOT SYMBOL CONSTITUENT
;
100$:	BSBW	MAC$VSTO_CHAR		;STORE THE CHARACTER
	BISL2	#FLG$M_ALLCHR,(R11)	;PASS ALL CHARS (SEMICOLONS)
	BSBW	MAC$GETCHR		;GET NEXT CHAR
	BBSC	#FLG$V_ALLCHR,(R11),80$	;CLEAR ALLCHR FLAG AND CONTINUE
					;SCANNING.

BODY_SCAN_END:
	BBCC	#FLG$V_SPLALL,(R11),.+1	;CLEAR SPECIAL ALL CHARS FLAG
	POPL	R1			;GET ADDRESS TO STORE LINE LENGTH AT
	BBCC	#FLG$V_SPECOP,(R11),10$	;BRANCH IF NO SPECIAL OPERATORS ON LINE
	BISW2	#^X8000,R6		;THERE WERE--FLAG IN LINE LENGTH
10$:	MOVW	R6,(R1)			;STORE LINE LENGTH
	BEQL	20$			;BRANCH IF NULL LINE
	INCL	(SP)			;FLAG NOT NULL MACRO NOW
20$:	TSTL	W^MAC$GL_MCLVL		;STILL IN MACRO?
	BLEQ	30$			;IF LEQ NO
	MOVZBL	#CR,R10			;YES--FORCE READING NEW LINE
	BSBW	MAC$GETCHR		;READ NEW CHAR/LINE
	BRW	BODY_SCAN_LOOP		;CONTINUE SCANNING MACRO BODY
30$:	MOVL	#2,R0			;SET TO STORE 2 BYTES
	BSBW	MAC$VSTO_SET		;...
	MOVW	#-1,(R8)+		;MARK END WITH LINE LENGTH OF -1
	MOVL	R8,W^MAC$GL_ARGPTR	;STORE UPDATED ARG POINTER
	POPL	R0			;GET THE NULLNESS FLAG
	RET				;EXIT FROM BODY SCAN

;
; THIS ROUTINE IS CALLED WHEN A PERCENT SIGN IS ENCOUNTERED WHILE LOADING
; MACRO TEXT INTO CORE.  IT COMPLETELY PROCESSES THE LEXICAL OPERATOR
; INTO SPECIAL MTX$_ BYTES AND RETURNS WITH THE CHARACTER FOLLOWING
; THE LEXICAL OPERATOR.
;

SCAN_PERCENT:
	PUSHL	W^MAC$GL_LINEPT		;SAVE CURRENT LINE POINTER
	BISL2	#FLG$M_ALLCHR,(R11)	;PASS ALL CHARACTERS BACK
	BSBW	MAC$GETCHR		;GET THE NEXT CHARACTER
	BICL2	#FLG$M_ALLCHR,(R11)	;CLEAR ALL CHARACTER FLAG
	BBC	#CHR$V_SYM_CHR,-	;BRANCH IF CHARACTER IS NOT A SYMBOL
		W^MAC$AB_CMSK_TAB(R10),10$ ;CONSTITUENT
;
; MAYBE WE HAVE A LEXICAL OPERATOR.  SCAN THE SYMBOL
;
	BSBW	MAC$SYMSCNUP1		;ACCUMULATE THE SYMBOL NAME
	CMPB	R10,#^A/(/		;SHOULD STOP ON LEFT PAREN
	BNEQ	10$			;IF NEQ NOT A LEXICAL OPERATOR
	MOVAB	W^MAC$LEX_OP_LIST,R5	;LOAD UP OPERATOR NAME TABLE ADDRESS
	BSBW	MAC$SRC_LIST		;SEE IF A LEXICAL OPERATOR
	BLBC	R0,10$			;IF LBC NO--FIX UP AND RETURN
	POPL	R0			;CLEAR SAVED LINE POINTER FROM STACK
	PUSHL	SYM$L_VAL(R1)		;YES--STACK PROCESSOR ADDRESS
	MOVZBL	SYM$W_FLAG(R1),R10	;GET THE MTX IDENTIFIER BYTE
	BBSS	#FLG$V_SPECOP,(R11),20$	;FLAG SPECIAL OPERATOR ON LINE AND
	BRB	20$			;GO STORE THE MTX BYTE, GET THE
					;NEXT CHARACTER, AND DISPATCH
					;TO PROCESSOR
10$:	POPL	W^MAC$GL_LINEPT		;RESTORE OLD LINE POINTER
	MOVL	#^A/%/,R10		;RESTORE THE PERCENT SIGN
20$:	BSBW	MAC$VSTO_CHAR		;SEND IT TO THE OUTPUT
	BISL2	#FLG$M_ALLCHR,(R11)	;PASS ALL CHARACTERS
	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	BICL2	#FLG$M_ALLCHR,(R11)	;CLEAR ALLCHR FLAG
	RSB				;RETURN

	.SBTTL	PROCESS %EXTRACT LEXICAL OPERATOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE %EXTRACT LEXICAL OPERATOR.  THE
;	ARGUMENTS TO THE OPERATOR ARE %EXTRACT(POS,LEN,STRING).
;
;--

LEXICAL_EXTRACT:
	BSBB	10$			;GET THE POSITION AND SKIP COMMA
	BSBB	10$			;GET LENGTH AND SKIP THE COMMA
	BSBW	GET_LEX_STRING		;GET THE STRING TO EXTRACT FROM
	BLBC	R0,LEXICAL_ARG_ERR	;BRANCH IF ERROR
	BRB	LEXICAL_END_CK		;FINISH UP
;
; GET A NUMBER AND SKIP THE COMMA AFTER IT--NO RETURN IF ERROR
;
10$:	BSBW	GET_LEX_NUM		;GET THE NUMBER
	BLBC	R0,20$			;BRANCH IF ERROR
	BSBW	LEX_SKIP_COMMA		;SKIP THE COMMA
	BLBC	R0,20$			;BRANCH IF ERROR
	RSB
20$:	TSTL	(SP)+			;CLEAR CALL FROM STACK
	BRB	LEXICAL_ARG_ERR		;PROCESS THE ERROR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE %LOCATE LEXICAL FUNCTION.  THE
;	ARGUMENTS TO LOCATE ARE %LOCATE(SUBSTRING,STRING,STARTPOS),
;	WITH THE STARTPOS ARGUMENT BEING OPTIONAL.
;
;--

LEXICAL_LOCATE:
	BSBW	GET_LEX_STRING		;GET THE SUBSTRING TO LOCATE
	BLBC	R0,LEXICAL_ARG_ERR	;BRANCH IF ERROR
	BSBW	LEX_SKIP_COMMA		;SKIP THE COMMA
	BLBC	R0,LEXICAL_ARG_ERR	;BRANCH IF ERROR
	BSBW	GET_LEX_STRING		;GET THE STRING TO LOCATE IN
	BLBC	R0,LEXICAL_ARG_ERR	;BRANCH IF ERROR
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/)/		;GET TO CLOSE PAREN?
	BEQL	20$			;IF EQL YES--NO STARTPOS ARGUMENT
	CMPB	R10,#^A/,/		;NO--STOP ON A COMMA?
	BNEQ	10$			;IF NEQ NO--ERROR
	BSBW	MAC$GETCHR		;YES--GET NEXT CHARACTER
	BSBW	GET_LEX_NUM		;GET STARTPOS ARGUMENT
	BLBS	R0,30$			;IF LBS OK
10$:	BRB	LEXICAL_ARG_ERR		;GO TO ERROR ROUTINE
20$:	MOVB	#MTX$_NOMORE,R10	;NO STARTPOS--FLAG IT
	BSBW	MAC$VSTO_CHAR		;STORE IT AWAY
	MOVB	#^A/)/,R10		;RESET THE PAREN
30$:	BRB	LEXICAL_END_CK		;FINISH UP

	.SBTTL	PROCESS %LENGTH LEXICAL OPERATOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE %LENGTH LEXICAL OPERATOR.  THE
;	ARGUMENT TO THE OPERATOR IS EITHER A STRING OR A DUMMY
;	ARGUMENT NAME.
;
;--

LEXICAL_LENGTH:
	BSBW	GET_LEX_STRING		;READ STRING
	BLBC	R0,10$			;BRANCH IF THERE WAS AN ERROR
	BRB	LEXICAL_END_CK		;FINISH LEXICAL OPERATOR PROCESSING
10$:
LEXICAL_ARG_ERR:
	$INTOUT_X INT$_CHKL		;ALIGN SOURCE AND LISTING
	$MAC_ERR BADLEXARG		; Get the message code
	BSBW	MAC$ERRORLN		;ISSUE TO PASS 2
	PUSHL	R10			;SAVE R10
	CLRL	R10			;SEND A ZERO TO CANCEL
	BSBW	MAC$VSTO_CHAR		;STORE IT
	POPL	R10			;RESTORE R10
	BRB	FIND_LEX_END		;SCAN TO END OF LEXICAL OPERATOR NOW

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHECKS THAT THE LEXICAL OPERATOR WAS TERMINATED
;	PROPERLY AND ISSUES AN ERROR TO PASS 2 IF IT WAS NOT.
;
;--

LEXICAL_END_CK:
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/)/		;DID WE END PROPERLY?
	BEQL	FIND_LEX_END		;IF EQL YES
	$INTOUT_X INT$_CHKL		;NO--ALIGN SOURCE AND LISTING
	$MAC_ERR BADLEXFORM		; Get message code
	BSBW	MAC$ERRORLN		;ISSUE ERROR TO PASS 2

FIND_LEX_END:
	CMPB	R10,#CR			;END OF LINE?
	BEQL	LEXICAL_EXIT		;IF EQL YES
	CMPB	R10,#^A/)/		;NO--END OF OPERATOR?
	BEQL	20$			;IF EQL YES
	BSBW	MAC$GETCHR		;NO--GET NEXT CHARACTER
	BRB	FIND_LEX_END		;KEEP LOOKING
20$:	BSBW	MAC$GETCHR		;GET CHARACTER AFTER RIGHT PAREN
LEXICAL_EXIT:
	RSB

	.SBTTL	SCAN LEXICAL OPERATOR ARGUMENT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SCAN ONE LEXICAL OPERATOR ARGUMENT.
;	THE POSSIBLE ARGUMENTS ARE:
;
;	STRING ARGUMENTS:

;		<STRING_ENCLOSED_IN_ANGLE_BRACKETS>
;		^@STRING_ENCLOSED_WITHIN_DELIMITERS_(@_IN_THIS_CASE)@
;		DUMMY_ARG_NAME
;
;	NUMERIC ARGUMENTS:
;
;		DECIMAL_NUMBER
;		ABSOLUTE_SYMBOL_NAME
;
; INPUTS:
;
;	12(AP)		0 OR POINTER TO MACRO ARG NAMES (MAB'S)
;
; OUTPUTS:
;
;	R0		0	ERROR ENCOUNTERED
;			1	OK
;--


	.ENABL	LSB
GET_LEX_NUM:				;READ A NUMBER
	BSBW	MAC$SKIPSP		;SKIP ANY SPACES
	BBS	#CHR$V_NUM_BER,-	;BRANCH IF IT IS A NUMBER
		W^MAC$AB_CMSK_TAB(R10),30$ ;...
	BSBW	MAC$SYMSCNUP		;NO--TRY TO SCAN ABS_SYM_NAME
	BLBS	R0,10$			;IF LBS GOT SYMBOL NAME
;
; NUMBER EXPECTED, DID NOT FIND EITHER A DECIMAL_NUMBER OR AN
; ABSOLUTE_SYMBOL_NAME.
;
	CLRL	R0			;RETURN FAILURE
	RSB
10$:	BSBW	MAC$INSUSRSYMTB		;FOUND SYMBOL NAME--LOOK UP OR ENTER
					;IN USER SYMBOL TABLE
	PUSHL	R1			;SAVE SYMBOL BLOCK ADDRESS
	MOVL	#5,R0			;SET TO STORE 5 BYTES
	BSBW	MAC$VSTO_SET		;PREPARE TO STORE THEM
	MOVB	#MTX$_SYMADR,(R8)+	;FIRST BYTE IS MACRO OPERATOR
					;FLAGGING SYMBOL BLOCK ADDRESS
	POPL	(R8)+			;STORE THE SYMBOL BLOCK ADDRESS
	BRB	300$			;RETURN WITH SUCCESS
;
; EXPECTING DECIMAL_NUMBER, AND FOUND A DIGIT--READ THE NUMBER IN
;
30$:	PUSHL	R8			;SAVE R8, WHICH DNUMBER WIPES
	BSBW	MAC$DNUMBER		;READ THE NUMBER
	POPL	R8			;RESTORE R8
	MOVL	#5,R0			;SET TO STORE 5 BYTES
	BSBW	MAC$VSTO_SET		;PREPARE TO STORE THEM
	MOVB	#MTX$_LITVAL,(R8)+	;FLAG LITERAL VALUE FOLLOWS
	MOVL	W^MAC$GL_VALUE,(R8)+	;STORE THE VALUE
	BRB	300$			;RETURN WITH SUCCESS
;
; STRING IS EXPECTED
;
GET_LEX_STRING:
	BSBW	MAC$SKIPSP		;SKIP SPACES
	BBS	#CHR$V_SYM_CHR,-	;BRANCH IF FORMAL ARG NAME
		W^MAC$AB_CMSK_TAB(R10),200$ ;
;
; MUST BE EITHER A STRING IN ANGLE BRACKETS OR AN UPARROW-DELIMITER
; TYPE STRING.
;
	CMPB	R10,#^A/^/		;IS IT THE UPARROW?
	BEQL	120$			;IF EQL YES
	CMPB	R10,#^A/</		;NO--ANGLE BRACKET?
	BEQL	120$			;IF EQL YES
	CLRL	R0			;RETURN ERROR
	RSB
120$:	BBCS	#FLG$V_LEXOP,(R11),.+1	;FLAG LEXICAL OPERATOR CALL
	BSBW	MAC$MAC_ARG_SCN		;SCAN THE MACRO ARGUMENT
	BBCC	#FLG$V_LEXOP,(R11),.+1	;CLEAR LEXICAL OPERATOR FLAG
	PUSHL	R0			;SAVE LENGTH OF ARGUMENT SCANNED
	ADDL2	#3,R0			;FIGURE LENGTH NEEDED
					;(MTX$_LITSTR AND LENGTH WORD)
	BSBW	MAC$VSTO_SET		;SET TO STORE THE STRING
	MOVB	#MTX$_LITSTR,(R8)+	;SET INDICATOR BYTE
	POPL	R0			;GET THE STRING COUNT BACK
	MOVW	R0,(R8)+		;STORE THE COUNT WORD
	MOVC3	R0,W^MAC$AB_TMPBUF,(R8)	;COPY THE ARGUMENT OUT
	MOVL	R3,R8			;UPDATE THE POINTER
	BRB	300$			;RETURN WITH SUCCESS
;
; IT APPEARS WE WILL BE SCANNING A DUMMY ARGUMENT NAME
;
200$:	BSBW	MAC$SYMSCNUP		;SCAN THE DUMMY ARG NAME
	MOVL	12(AP),R5		;POINT TO MACRO ARG BLOCK LIST
	BEQL	310$			;IF EQL NO ARGS--OOPS
	BSBW	MAC$SRC_LIST		;LOOK UP THE DUMMY ARG
	BLBC	R0,310$			;BRANCH IF NOT FOUND
	PUSHL	R1			;SAVE MAB ADDRESS
	MOVB	#2,R0			;SET TO STORE 2 BYTES
	BSBW	MAC$VSTO_SET		;SET UP FOR THEM
	MOVB	#MTX$_ARGMRK,(R8)+	;STORE ARG MARKER BYTE
	POPL	R1			;RESTORE MAB ADDRESS
	MOVB	MAB$B_ARGNO(R1),(R8)+	;STORE ARG NUMBER
;
; COME HERE TO SET SUCCESS AND RETURN
;
300$:	MOVL	#1,R0			;FLAG GOOD ARGUMENT
	RSB				;ALL DONE
310$:	CLRL	R0			;FLAG AN ERROR
	RSB
	.DSABL	LSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SKIPS SPACES, EXPECTS A COMMA THEN, AND RETURNS
;	WITH THE CHARACTER FOLLOWING THE COMMA.
;
;--

LEX_SKIP_COMMA:
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;DID WE GET TO A COMMA?
	BEQL	10$			;IF EQL YES
	CLRL	R0			;NO--FLAG AN ERROR
	RSB
10$:	BSBW	MAC$GETCHR		;READ CHARACTER AFTER COMMA
	MOVL	#1,R0			;FLAG SUCCESS
	RSB

	.SBTTL	SPECIAL DIRECTIVES SCANNED DURING BODY_SCAN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A .REPT, .IRP, .IRPC, OR
;	.MACRO IS SCANNED WHILE READING THE MACRO BODY INTO
;	CORE.  THE MACRO DEFINITION LEVEL IS INCREMENTED SO
;	THAT BODY_SCAN KNOWS WHEN THE PROPER .ENDM HAS BEEN
;	FOUND.
;
;--

MAC$MAC_IN_MAC::
	INCL	W^MAC$GL_MCLVL		;BUMP THE MACRO DEFINITION LEVEL
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A .END, .ENDM, OR .ENDR IS
;	SCANNED IN BODY_SCAN.  THE MACRO DEFINITION LEVEL IS
;	DECREMENTED, AND IF MACRO DEFINITIONS ARE NOT BEING
;	LISTED, THE LIST_IT FLAG IS CLEARED.
;
;--

MAC$MAC_DEF_END::
	DECL	W^MAC$GL_MCLVL		;DECREMENT MACRO DEF. LEVEL
	BGTR	10$			;IF GTR STILL IN A MACRO
	BSBW	MAC$CREF_DIR		;CREF DIRECTIVE IF CREFFING
					;(R1 STILL POINTS TO SYMBOL BLOCK)
	BLBS	W^LST$G_MACRODEF+SYM$L_VAL,10$ ;BRANCH IF LISTING MACRO
						;DEFS
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;NO--OUTPUT FLAG
10$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN CERTAIN DIRECTIVES (.ERROR, .WARN,
;	.PRINT, .ASCIX) ARE SCANNED.  THESE DIRECTIVES ARE SPECIAL IN
;	THAT THEY MAY HAVE SEMI-COLONS AS PART OF THEIR SYNTAX.  THEREFORE
;	THE SPECIAL ALL CHARACTERS FLAG (SPLALL) IS SET SO THAT THESE
;	SEMI-COLONS ARE NOT TAKEN AS COMMENTS.
;
;--

MAC$SET_ALL_CHR::
	BBCS	#FLG$V_SPLALL,(R11),.+1	;SET SPECIAL ALL CHARACTERS FLAG
	RSB				;THAT'S ALL

	.SBTTL	STORE CHARACTER INTO VIRTUAL MEMORY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE STORES THE CHARACTER IN R10 INTO VIRTUAL MEMORY.
;
; INPUTS:
;
;	R8	PTR INTO VIRTUAL MEMORY
;	R7	COUNT OF BYTES LEFT IN THIS BLOCK OF VIRT. MEMORY
;	R6	COUNT OF CHARACTERS STORED 
;
; OUTPUTS:
;
;	R8	UPDATED
;	R7	UPDATED
;	R6	UPDATED
;
;	CHARACTER IN R10 STORED INTO STRING
;
;--

MAC$VSTO_CHAR::
	SUBL3	#7,R7,R0		;SEE IF ROOM FOR 2 CHARACTERS AND LINK
	BGTR	10$			;IF GT YES
	BSBB	MAC$VSTO_GET		;NO--GET A NEW PAGE
10$:	MOVB	R10,(R8)+		;STORE CHAR IN VM
	INCL	R6			;COUNT CHARACTERS STORED
	DECL	R7			;DEC. COUNT OF REMAINING SPACE
	RSB				;DONE

	.SBTTL	STORE STRING INTO VIRTUAL MEMORY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE STORES A STRING INTO VIRTUAL MEMORY.
;
; INPUTS:
;
;	R2	ADDRESS OF THE STRING
;	R3	LENGTH OF THE STRING
;	R6	CHARS STORED IN VM
;	R7	CHARS LEFT IN VM
;	R8	POINTER INTO VM
;
; OUTPUTS:
;
;	R6,R7,R8 ARE UPDATED
;	STRING IS STORED
;
;--

MAC$VSTO_STR::
	SUBL3	R3,R7,R0		;SEE IF ROOM FOR STRING
	BGTR	10$			;IF GTR YES
	BSBB	MAC$VSTO_GET		;NO--GET A PAGE
10$:	SUBL2	R3,R7			;DECREASE COUNT LEFT
	ADDL2	R3,R6			;INCREASE COUNT STORED
	MOVC3	R3,(R2),(R8)		;COPY INTO BUFFER
	MOVL	R3,R8			;UPDATE THE VM POINTER
	RSB				;DONE

	.SBTTL	SETUP TO STORE INTO VIRTUAL MEMORY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PREPARES TO STORE 'N' BYTES IN VM.
;
; INPUTS:
;
;	R0	NUMBER OF BYTES TO STORE
;	R6	COUNT OF BYTES STORED
;	R7	COUNT OF BYTES LEFT
;	R8	POINTER INTO VM
;
; OUTPUTS:
;
;	R6,R7	UPDATED SO ALL CALLER NEEDS TO DO IS STORE BYTES (R8)
;
;--

MAC$VSTO_SET::
	PUSHL	R0			;SAVE THE COUNT
	SUBL3	R0,R7,R0		;SEE IF ROOM
	BGTR	10$			;IF GTR YES
	BSBB	MAC$VSTO_GET		;NO--GET A PAGE
10$:	SUBL2	(SP),R7			;ADJUST THE COUNT LEFT
	ADDL2	(SP)+,R6		;ADJUST COUNT STORED
	RSB				;BACK TO CALLER

	.SBTTL	ALLOCATE VIRTUAL BUFFER PAGE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES A PAGE OF VIRTUAL MEMORY AND LINKS THE
;	TEXT STREAM ON THE CURRENT PAGE TO THE NEW PAGE.  THE POINTER
;	(R8) AND COUNTER (R7) ARE UPDATED.
;
; INPUTS:
;
;	R8	POINTER TO CURRENT PAGE (WHERE WE ARE STORING)
;	R7	COUNT  OF BYTES LEFT ON PAGE 
;	MAC$GL_MACPTR	POINTER TO MNB FOR MACRO BEING DEFINED
;
; OUTPUTS:
;
;	R8	POINTS TO FIRST BYTE ON NEW PAGE
;	R7	Number of usable bytes in page (512 bytes/page -
;		MXB$K_BLKSIZ for header and 6 bytes for link byte flag)
;
;--

MAC$VSTO_GET::
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE A PAGE (ADDR IN R0 ON RETURN)
	MOVB	#MTX$_TXTLNK,(R8)+	;STORE TEXT LINK FLAG BYTE
	BBSS	#FLG$V_SPECOP,(R11),.+1	;FLAG SPECIAL OPERATOR ON LINE
MAC$VSTO_GET_0:				;ENTRY TO SET LINKS ONLY
	MOVL	R0,(R8)+		;STORE TEXT LINK LINK POINTER
	MOVL	R0,R8			;POINT R8 TO THE NEW PAGE
	MOVZWL	#<512-MXB$K_BLKSIZ-6>,R7 ; Set byte count
	MOVL	W^MAC$GL_MACPTR,R1	;GET POINTER TO MNB FOR MACRO
	ASSUME MXB$L_LINK  EQ 0
	ASSUME MXB$L_PAGES EQ MXB$L_LINK+4
	MOVL	MNB$L_PAGP(R1),(R8)+	;LINK NEW PAGE INTO PAGE LIST
	MOVL	R0,MNB$L_PAGP(R1)	;...
	MOVL	#1,(R8)+		; Block size is 1 page
	INCL	MNB$L_PAGC(R1)		;AND COUNT IT
	BBS	#FLG$V_RPTIRP,(R11),10$	;BRANCH IF RPTIRP (NOT MACRO)
	INCL	W^MAC$GL_MCPGRQ		;COUNT ANOTHER PAGE FOR MACRO DEFINITION
10$:	RSB				;RETURN TO CALLER

	.END
