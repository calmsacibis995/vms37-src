	.TITLE	MAC$ACTOPC	DEFINE USER OPCODES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 9-OCT-1978
;
; MODIFIED BY:
;
;	V01.05	CNH0049		Chris Hume	12-Feb-1981
;		Added BB and BW to operand descriptor list for .OPDEF
;		directive.
;
;	V01.04	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.03	RN0005		R. Newland	11-Aug-1979
;		Variable symbol name storage
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_GENVALDEF			;GENERAL VALUES
	$MAC_GRAMMARDEF			;GRAMMAR DEFINITIONS
	$MAC_SYMBLKDEF			;SYMBOL BLOCK OFFSETS
	$MAC_OPRDEF			;DEFINE OPERAND DESCRIPTORS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_DATA,NOWRT,GBL,NOEXE,LONG

;
; LIST OF LEGAL OPERAND DESCRIPTORS.  THE VALUE IS THE OPERAND DESCRIPTOR
; WORD VALUE.
;
	INSYMP	=	0

$MAC_INSERT_SYX	BB,OPD$M_BB
$MAC_INSERT_SYX	BW,OPD$M_BW
$MAC_INSERT_SYX	AB,OPD$M_ADDR+B
$MAC_INSERT_SYX	AW,OPD$M_ADDR+W
$MAC_INSERT_SYX	AL,OPD$M_ADDR+L
$MAC_INSERT_SYX	AF,OPD$M_ADDR+F
$MAC_INSERT_SYX	AD,OPD$M_ADDR+D
$MAC_INSERT_SYX	AQ,OPD$M_ADDR+Q
$MAC_INSERT_SYX	AG,OPD$M_ADDR+G
$MAC_INSERT_SYX	AO,OPD$M_ADDR+O
$MAC_INSERT_SYX	AH,OPD$M_ADDR+H
$MAC_INSERT_SYX	RB,OPD$M_READ+B
$MAC_INSERT_SYX	RW,OPD$M_READ+W
$MAC_INSERT_SYX	RL,OPD$M_READ+L
$MAC_INSERT_SYX	RF,OPD$M_READ+F
$MAC_INSERT_SYX	RD,OPD$M_READ+D
$MAC_INSERT_SYX	RQ,OPD$M_READ+Q
$MAC_INSERT_SYX	RG,OPD$M_READ+G
$MAC_INSERT_SYX	RO,OPD$M_READ+O
$MAC_INSERT_SYX	RH,OPD$M_READ+H
$MAC_INSERT_SYX	MB,OPD$M_MODIFY+B
$MAC_INSERT_SYX	MW,OPD$M_MODIFY+W
$MAC_INSERT_SYX	ML,OPD$M_MODIFY+L
$MAC_INSERT_SYX	MF,OPD$M_MODIFY+F
$MAC_INSERT_SYX	MD,OPD$M_MODIFY+D
$MAC_INSERT_SYX	MQ,OPD$M_MODIFY+Q
$MAC_INSERT_SYX	MG,OPD$M_MODIFY+G
$MAC_INSERT_SYX	MO,OPD$M_MODIFY+O
$MAC_INSERT_SYX	MH,OPD$M_MODIFY+H
$MAC_INSERT_SYX	WB,OPD$M_WRITE+B
$MAC_INSERT_SYX	WW,OPD$M_WRITE+W
$MAC_INSERT_SYX	WL,OPD$M_WRITE+L
$MAC_INSERT_SYX	WF,OPD$M_WRITE+F
$MAC_INSERT_SYX	WD,OPD$M_WRITE+D
$MAC_INSERT_SYX	WQ,OPD$M_WRITE+Q
$MAC_INSERT_SYX	WG,OPD$M_WRITE+G
$MAC_INSERT_SYX	WO,OPD$M_WRITE+O
$MAC_INSERT_SYX	WH,OPD$M_WRITE+H
$MAC_INSERT_SYX	VB,OPD$M_VIELD+B
$MAC_INSERT_SYX	VW,OPD$M_VIELD+W
$MAC_INSERT_SYX	VL,OPD$M_VIELD+L
$MAC_INSERT_SYX	VF,OPD$M_VIELD+F
$MAC_INSERT_SYX	VD,OPD$M_VIELD+D
$MAC_INSERT_SYX	VQ,OPD$M_VIELD+Q
$MAC_INSERT_SYX	VG,OPD$M_VIELD+G
$MAC_INSERT_SYX	VO,OPD$M_VIELD+O
$MAC_INSERT_SYX	VH,OPD$M_VIELD+H,MAC$G_ARGDSCTAB

	.SBTTL	DFNOPC	ENTRY POINT TO DEFINE AN OPCODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE .OPCODE DIRECTIVE IS PARSED.
;	THIS ROUTINE COMPLETELY PROCESSES THE DIRECTIVE, AND DEFINES
;	THE OPCODE FOR LATER REFERENCE.
;
;--

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

DFNOPC::				;DIRECTIVE = KOPDEF ID EXPR DCOMMA
	PUSHR	#^M<R7,R8,R12>		;SAVE SOME REGISTERS
	MOVL	W^MAC$AL_VALSTACK-8[R7],R6 ;GET SYMBOL BLOCK ADDRESS
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to name
	SUBL3	R0,R6,R1		; Compute address of name
	MOVC5	R0,(R1),#0,#SYM$K_MAXLEN+1, - ; Copy symbol count/name to TMPSYM
		W^MAC$AB_TMPSYM
	BSBW	MAC$HASH_SYM		;COMPUTE HASH VALUE FOR SYMBOL
	BSBW	MAC$SRCUSRSYMTB		;LOOK UP SYMBOL TO GET PREDECESSOR
	BLBS	R0,10$			;WE ALWAYS SHOULD BRANCH HERE
	CALLS	#0,W^MAC$ERR_INTERN	;OR WE HAVE A REAL PROBLEM
	BRW	MAC$ABORT_PASS1		;
10$:	MOVL	SYM$L_LINK(R6),SYM$L_LINK(R2) ;UNLINK THIS SYMBOL BLOCK
	MOVAB	W^MAC$AB_TMPBUF,R7	;POINT TO TEMPORARY BUFFER
	CLRL	R8			;CLEAR COUNT OF OPERAND DESCRIPTORS
;
; COLLECT OPERAND DESCRIPTORS IN MAC$AB_TMPBUF WITH A COUNT IN R8
;
GET_ARG_DESC:
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#CR			;ARE WE DONE?
	BEQL	40$			;IF EQL YES
	CMPB	R10,#^A/,/		;COMMA?
	BNEQ	5$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
5$:	BSBW	MAC$SYMSCNUP		;SCAN A SYMBOL
	BLBS	R0,10$			;BRANCH IF GOT ONE
	$MAC_ERR ILLARGDESC		; Else illegal argument descriptor
	BSBW	MAC$ERRORLN		;REPORT THE ERROR
	MOVL	#CR,R10			;NO SENSE IN LOOPING ON ERRORS
	BRB	40$			;GO FINISH UP
10$:	MOVAB	W^MAC$G_ARGDSCTAB,R5	;POINT TO LIST OF LEGAL DESCRIPTORS
	BSBW	MAC$SRC_LIST		;SEE IF A LEGAL DESCRIPTOR
	BLBS	R0,20$			;IF LBS YES
	$MAC_ERR ILLARGDESC		; No--get message code
	BSBW	MAC$ERRORLN		;ISSUE ERROR TO PASS 2
	CLRW	(R7)+			;USE DESCRIPTOR OF 0
	BRB	30$			;CONTINUE
20$:	MOVW	SYM$L_VAL(R1),(R7)+	;COPY ARG DESCRIPTOR VALUE
30$:	INCL	R8			;COUNT ARG DESCRIPTOR
	BRB	GET_ARG_DESC		;LOOP TILL DONE
;
; ARG DESCRIPTORS HAVE BEEN ACCUMULATED. DEFINE THE OPCODE NOW
;
40$:	MOVL	W^MAC$GL_OPCPGPTR,R7	;GET POINTER TO CURRENT PAGES
	BNEQ	60$			;BRANCH IF ALLOCATED
50$:	BSBW	MAC$ALL_2_PAGES		;NO--ALLOCATE 2 PAGES
	MOVL	R0,R7			;R7 POINTS TO THE PAGES
	MOVL	R0,W^MAC$GL_OPCPGPTR	;SAVE POINTER TO CURRENT PAGES
	MOVZWL	#<<512*2>-8>,(R0)+	;SET BYTE COUNT IN FIRST WORD
	MOVAB	4(R0),(R0)+		;SET POINTER TO FIRST FREE
60$:	MULL3	#2,R8,R0		;CALCULATE # BYTES FOR DESCRIPTORS
	MOVZBL	SYM$B_NAME(R6),R1	; Get size of symbol count/name
	SUBL2	R1,(R7)			; and subtract from space available
	SUBL2	R0,(R7)			;ROOM ON THESE PAGES?
	BLSS	50$			;IF LSS NO--ALLOCATE NEW PAGES
	MOVL	4(R7),R12		;YES--GET POINTER TO FREE SPOT
	SUBL3	R1,R6,R0		; Get address of symbol count/name
	MOVC3	R1,(R0),(R12)		; and copy into block
	MOVL	W^MAC$GL_OPCLSTPT,(R3)	; Link into front of list
	MOVAL	(R3)+,W^MAC$GL_OPCLSTPT
	MOVB	SYM$B_NAME(R6),(R3)+	; Fill in symbol offset
	PUSHAL	(R3)+			;REMEMBER WHERE VALUE GOES
					;(AND BUMP POINTER)
	CLRW	(R3)+			;CLEAR FLAGS
	MOVB	#DOPCODE,(R3)+		;TOKEN VALUE IS OPCODE
	MOVB	R8,(R3)+		;SEGMENT IS OPERAND COUNT
	MULL3	#2,R8,R0		;FIGURE OPERAND BYTE COUNT
	MOVC3	R0,W^MAC$AB_TMPBUF,(R3)	;AND COPY DESCRIPTORS
	MOVL	R3,4(R7)		;SET POINTER TO NEW FIRST FREE
	POPL	R0			;RETRIEVE VALUE ADDRESS
	POPR	#^M<R7,R8,R12>		;RESTORE REGISTERS
	MOVL	W^MAC$AL_VALSTACK-4[R7],(R0) ;SET OPCODE VALUE
	TSTW	2(R0)			;SEE IF VALUE OK
	BEQL	80$			;IF EQL YES
	$MAC_ERR ILLOPDEFVL		; No--report the error now
	BSBW	MAC$ERRORLN		;...
80$:	RSB

	.END
