	.TITLE	MAC$COMPUT	ARITHMEITIC ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V01.02	RN0005		R. Newland	27-Aug-1979
;		Remove .ALIGN LONG statements and unecessary
;		branch statements.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_TIRCMDDEF			;DEFINE TIR COMMANDS


;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;


	.SBTTL	COMPUTATIONAL ROUTINES

	.PSECT	MAC$RO_CODE_P15,NOWRT,GBL,LONG

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES PERFORM ARITHMETIC OPERATIONS ON THE VALUES
;	STORED ON MAC$AL_VALSTACK.  THE PASS 2 VERSIONS EMIT CODE
;	TO THE OBJECT FILE, WHILE THE PASS 1 VERSIONS DO NOT.  THE
;	RESULT IS RETURNED ON THE TOP OF THE STACK.
;
;--

P2$ADD::
	$OBJ_CHKBYT #TIR$C_OPR_ADD	;GENERATE OBJECT COMMAND

P1$ARITH_ADD::
	BSBW	LD_XQ_AND_STORE		;LOAD R0 AND R1
	ADDL2	R0,R1			;FORM SUM

	.IF DF CHECK_OVERFLOW

	BVC	P1$ARITH_SAME		;BRANCH IF NO OVERFLOW
	BRW	SET_OVERFLOW		;OVERFLOW--GO FLAG IT

	.IFF	;DEFINED CHECK_OVERFLOW

	RSB

	.IFTF	;DEFINED CHECK_OVERFLOW


P2$SAME::
	$OBJ_CHKBYT #TIR$C_OPR_NOP	;GENERATE COMMAND

P1$ARITH_SAME::
	RSB

P2$AND::
	$OBJ_CHKBYT #TIR$C_OPR_AND	;GENERATE COMMAND

P1$ARITH_AND::
	BSBW	LD_XQ_AND_STORE		;LOAD R0 AND R1
	MCOML	R0,R0			;GET COMPLEMENT
	BICL2	R0,R1			;DO THE AND
	RSB

P2$ASH::
	$OBJ_CHKBYT #TIR$C_OPR_ASH	;GENERATE COMMAND

P1$ARITH_ASH::
	BSBW	LD_XQ_AND_STORE
	TSTL	R0			;NEG SHIFT COUNT?
	BGTR	10$			;IF GTR NO
	BEQL	30$			;IF EQL DO NOT TOUCH SHIFT COUNT
	BISL2	#^XFFFFFFE0,R0		;YES--MAKE IT NEG MODULO 32
	BRB	20$
10$:	BICL2	#^XFFFFFFE0,R0		;MAKE MODULO 32
20$:	ASHL	R0,R1,R1		;DO THE SHIFT
30$:	RSB				;RETURN TO STORE RESULT

P2$NEG::
	$OBJ_CHKBYT #TIR$C_OPR_NEG	;GENERATE COMMAND

P1$ARITH_NEG::
	BSBW	LD_XEQ_STORE_0		;GET THE OPERAND
	MNEGL	R1,R1			;NEGATE
	RSB				;RETURN TO STORE

P2$NOT::
	$OBJ_CHKBYT #TIR$C_OPR_COM	;GENERATE COMMAND

P1$ARITH_NOT::
	BSBB	LD_XEQ_STORE_0		;GET THE OPERAND
	MCOML	R1,R1			;COMPLEMENT IT
	RSB				;RETURN TO STORE RESULT

P2$OR::
	$OBJ_CHKBYT #TIR$C_OPR_IOR	;GENERATE COMMAND

P1$ARITH_OR::
	BSBB	LD_XQ_AND_STORE		;LOAD OPERANDS
	BISL2	R0,R1			;FORM RESULT
	RSB

P2$SUB::
	$OBJ_CHKBYT #TIR$C_OPR_SUB	;GENERATE COMMAND

P1$ARITH_SUB::
	BSBB	LD_XQ_AND_STORE
	SUBL2	R0,R1			;FORM RESULT

	.IFT	;DEFINED CHECK_OVERFLOW

GO_SET_OVF:
	BVS	SET_OVERFLOW		;BRANCH IF OVERFLOW

	.IFTF	;DEFINED CHECK_OVERFLOW

	RSB

P2$XOR::
	$OBJ_CHKBYT #TIR$C_OPR_EOR	;GENERATE COMMAND

P1$ARITH_XOR::
	BSBB	LD_XQ_AND_STORE
	XORL2	R0,R1			;FORM RESULT
	RSB

P2$MUL::
	$OBJ_CHKBYT #TIR$C_OPR_MUL	;GENERATE COMMAND

P1$ARITH_MUL::
	BSBB	LD_XQ_AND_STORE
	MULL2	R0,R1			;FORM RESULT

	.IFT	;DEFINED CHECK_OVERFLOW

	BVS	SET_OVERFLOW		;BRANCH IF OVERFLOW

	.IFTF	;DEFINED CHECK_OVERFLOW

	RSB

P2$DIV::
	$OBJ_CHKBYT #TIR$C_OPR_DIV	;GENERATE COMMAND

P1$ARITH_DIV::
	BSBB	LD_XQ_AND_STORE
	TSTL	R0			;SEE IF DIVIDING BY ZERO
	BNEQ	10$			;IF NEQ NO--GO DIVIDE
	CVTBL	#-1,W^MAC$GL_VAL3	;YES--FLAG DIVIDE BY ZERO
	RSB
10$:	DIVL3	R0,R1,R1		;PERFORM OPERATION

	.IFT	;DEFINED CHECK_OVERFLOW

	BVS	SET_OVERFLOW		;BRANCH IF OVERFLOW
	RSB				;NO OVERFLOW
SET_OVERFLOW:
	INCL	W^MAC$GL_VAL3		;INDICATE OVERFLOW

	.ENDC	;DEFINED CHECK_OVERFLOW

	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	LD_XQ_AND_STORE IS CALLED TO POP THE FIRST OPERAND INTO
;	R0, AND THE SECOND OPERAND INTO R1.  THE CALLER IS THEN
;	CALLED TO PERFORM THE OPERATION, RETURNING THE RESULT IN
;	R1.  THIS RESULT IS PUSHED ON THE VALUE STACK.
;
;	LD_XEQ_STORE_0 POPS ONE OPERAND FROM THE STACK INTO R1
;	AND THEN CALLS THE CALLER BACK TO PERFORM A UNARY OPERATION
;	SUCH AS NEGATION OR COMPLEMENTATION.
;
;--

LD_XQ_AND_STORE:
	$VPOP	R0			;GET THE FIRST OPERAND

LD_XEQ_STORE_0:
	$VPOP	R1			;GET THE SECOND (OR ONLY) OPERAND
	JSB	@(SP)+			;CALL CO-ROUTINE TO XEQ FUNCTION
	$VPUSH	R1			;STACK RESULT
	RSB

	.END
