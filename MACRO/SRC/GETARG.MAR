	.TITLE	MAC$GETARG	GET MACRO FORMAL ARGUMENTS
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 30-AUG-78
;
; MODIFIED BY:
;
;	V02.06	CNH0047		Chris Hume	22-Dec-1980
;		Count null argument after trailing comma for .NARG directive.
;		(ARGSCN 02.08, DEFINE.MAR 02.18)
;
;	V01.05	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.04	RN0010		R. Newland	5-Sep-1979
;		Multi-page MXB blocks
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_CTLFLGDEF				;DEFINE CONTROL FLAGS
	$MAC_INTCODDEF				;DEFINE INTERMEDIATE CODES
	$MAC_GENVALDEF				;DEFINE GENERAL VALUES
	$MAC_SYMBLKDEF				;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_MNBDEF				;DEFINE MNB, MAB
	$MAC_INPBLKDEF				;DEFINE INPUT BLOCK OFFSETS
	$MACMSGDEF			; Define message codes

	.PSECT	MAC$RO_CODE_MAC,NOWRT,GBL,LONG

	.SBTTL	MAC$GET_ARGS	SCAN REAL MACRO ARGUMENTS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SCANS THE REAL MACRO ARGUMENTS ON A MACRO
;	INVOCATION.  AN INPUT BLOCK IS CREATED TO READ THE MACRO
;	TEXT WITH THE REAL ARGUMENTS ATTACHED TO THIS BLOCK.
;
;--

MAC$GET_ARGS::
	PUSHR	#^M<R7,R8,R12>		;SAVE REGISTERS
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE PAGE FOR INPUT BLOCK
	MOVL	R0,R8			;POINT R8 TO INPUT BLOCK
	MOVL	R8,W^MAC$GL_BLKPTR	;SAVE INPUT BLOCK ADDRESS
	MOVL	W^MAC$GL_INPUTP,(R8)+	;SET LINK 
	MOVL	MNB$L_TXTP(R6),(R8)+	;SET POINTER TO FIRST LINE OF MACRO TEXT
	MOVAB	W^MAC$GET_MAC_LIN,(R8)+	;SET ROUTINE ADDRESS TO GET NEXT LINE
	MOVAB	W^MAC$GL_IF_LEVEL,R0	;POINT TO IF LEVEL/VALUE LONGWORDS
	MOVL	(R0),(R8)+		;SAVE OLD IF LEVEL
	CLRL	(R0)+			;SET NEW IF LEVEL
	MOVL	(R0),(R8)+		;SAVE OLD IF VALUES
	CLRL	(R0)			;CLEAR NEW IF VALUES
	MOVL	R6,(R8)+		;STORE POINTER TO MACRO MNB IN
					;THE RPTCNT WORD
	CLRL	(R8)+			;CLEAR PAGE POINTER
	MOVZBL	MNB$B_ARGCT(R6),R0	;GET ARGUMENT COUNT
	MOVL	R0,W^MAC$GL_MC_ARGCT	;SET MACRO ARGUMENT COUNT
	MOVB	R0,(R8)+		;STORE ARG COUNT IN INPUT BLOCK
	BNEQ	10$			;IF NEQ GO PROCESS ARGS
	BRW	GET_ARG_EXIT		;ELSE WE ARE ALL DONE

;
; ZERO ARGUMENT POINTERS, THEN SCAN ARGS AND FILL IN POINTERS
;
10$:	MOVL	R8,W^MAC$GL_ARGPTR	;SAVE POINTER TO ARG POINTERS
20$:	CLRL	(R8)+			;ZERO ARG POINTER
	SOBGTR	R0,20$			;ZERO THEM ALL
	BSBW	MAC$SKIPSP		;SKIP LEADING SPACES
	SUBL3	W^MAC$GL_BLKPTR,R8,R7	;FIGURE SPACE LEFT ON PAGE
	SUBL3	R7,#512,R7		;NOW WE HAVE IT
	BBCC	#FLG$V_MOREARG,(R11),.+1; Clear trailing comma flag.
	BBCC	#FLG$V_ENDMCH,(R11),30$	;CLEAR DONE FLAG
;
; HERE FOR EACH NEW ARGUMENT
;
30$:	CMPB	R10,#CR			;END OF LINE?
	BNEQ	40$			;IF NEQ NO
	BBSS	#FLG$V_ENDMCH,(R11),40$	;YES--HAVE WE BEEN HERE BEFORE?
					;(AND SET FLAG)
	MOVZBL	MNB$B_ARGCT(R6),R0	;GET # OF ARGS IN  MACRO
	SUBL2	W^MAC$GL_MC_ARGCT,R0	;COUNT OF ARGS
	MOVL	W^MAC$GL_BLKPTR,R1	;POINT TO INPUT BLOCK
	BBC	#FLG$V_MOREARG,(R11),35$; Was one more argument expected?
	INCL	R0			; Bump count for .NARG if so.
35$:	MOVB	R0,INP$B_ARGCT(R1)	;SET COUNT INTO BLOCK
40$:	BSBW	MAC$MAC_ARG_SCN		;SCAN MACRO ARGUMENT
	TSTL	R0			;NULL ARG?
	BEQL	90$			;IF EQL YES
	SUBL2	#2,R7			;COUNT THE COUNT WORD ALSO
	SUBL2	R0,R7			;NO--IS THERE ROOM TO STORE IT?
	BGTR	50$			;IF GTR YES
	PUSHL	R0			;NO--SAVE SIZE OF ARG
	ADDL3	#<MXB$K_BLKSIZ+2>,R0,R1	; Compute total size of block required
	BSBW	ALL_INP_PAGE		;ALLOCATE A PAGE
	SUBL2	#2,R7			; Sub size of count word from new count
	POPL	R0			;GET SIZE OF MACRO ARG BACK
	SUBL2	R0,R7			;UDPATE FREE SPACE
50$:	MOVL	W^MAC$GL_KEYPTR,R1	;GET POINTER TO POSSIBLE KEYWORD MAB
	BEQL	60$			;IF EQL NOT KEYWORD ARGUMENT
	BSBW	SET_ARG_PKW		;SET ARG POINTER FOR KEYWORD
	BRB	70$			;GO COPY ARG TO VM
60$:	BSBW	SET_ARG_PTR		;SET ARG PTR FOR THIS ARG
70$:	MOVW	R0,(R8)+		;STORE LINE LENGTH
	MOVC3	R0,W^MAC$AB_TMPBUF,(R8)	;COPY ARG INTO VM
	MOVL	R3,R8			;UPDATE POINTER
80$:	TSTL	W^MAC$GL_KEYPTR		;DON'T COUNT KEYWORD ARGS
	BNEQ	30$			;IF NEQ KEYWORD ARG
	SOBGTR	W^MAC$GL_MC_ARGCT,30$	;LOOP FOR ALL ARGS
	BSBW	MAC$SKIPSP		;SKIP ANY SPACES LEFT
	BBS	#FLG$V_MOREARG,(R11),85$; Complain if trailing comma.
	CMPB	R10,#CR			;DONE--DID WE GET TO EOL?
	BEQL	FILL_DEF_ARGS		;YES--GO FILL DEFAULT ARGS
85$:	$INTOUT_LW INT$_WRN,<#MAC$_TOOMNYARGS,W^MAC$GL_LINEPT> ; No--warn in pass 2
	BRB	FILL_DEF_ARGS		;GO FILL DEFAULT ARGS
					; (STAT4 FORCES EOL TO READ MACRO
					;  SO WE DON'T NEED TO FIND IT HERE)

;
; THE ARGUMENT WAS NULL. IF THIS IS A CREATED SYMBOL, CREATE THE
; SYMBOL NOW.
;
90$:	MOVZBL	MNB$B_ARGCT(R6),R0	;GET TOTAL # ARGS
	SUBL2	W^MAC$GL_MC_ARGCT,R0	;FIGURE ARGUMENT # -1
	CMPL	R0,#31			;ONLY FIRST 32 SYMBOLS ARE CREATED
	BGTR	80$			;IF GTR THEN JUST SKIP IT
	BBC	R0,MNB$L_CRSYMF(R6),80$	;BRANCH IF NOT CREATED SYMBOL
	SUBL3	#8,R7,R0		;IT IS--IS THERE ROOM FOR 5 DIGITS,
					;DOLLAR SIGN, AND CHAR COUNT?
	BGTR	100$			;IF GTR YES
	MOVL	#8,R1			; 8 bytes required
	BSBW	ALL_INP_PAGE		;NO--ALLOCATE A PAGE
100$:	MOVL	W^MAC$GL_CRSYM,R0	;GET NEXT CREATED SYMBOL NUMBER
	INCL	W^MAC$GL_CRSYM		;INC TO NEXT CREATED SYMBOL
	PUSHL	R8			;REMEMBER WHERE COUNT WORD IS
	CLRW	(R8)+			;RESERVE SPACE FOR COUNT WORD
	MOVL	R8,R1			;R1 HAS OUTPUT POINTER
	BSBW	MAC$DEC_OUT_L2X		;OUTPUT NUMBER IN DECIMAL
	MOVB	#^A/$/,(R0)+		;FINISH SYMBOL WITH '$'
	SUBL3	R8,R0,R1		;FIGURE LENGTH OF NUMBER
	POPL	R8			;RESTORE PTR TO COUNT WORD
	MOVW	R1,(R8)			;STORE CHARACTER COUNT
	BSBW	SET_ARG_PTR		;STORE ARG POINTER IN INPUT BLOCK
	MOVL	R0,R8			;UPDATE POINTER
	SUBL2	R1,R7			;UPDATE COUNTER
	SUBL2	#2,R7			;COUNT THE COUNT WORD ALSO
	BRB	80$			;CONTINUE

;
; NOW TRY TO FILL IN NULL ARGS WITH KEYWORD DEFAULT VALUES
;

FILL_DEF_ARGS:
	MOVZBL	#1,W^MAC$GL_MC_ARGCT	;FIRST ARGUMENT	
	MOVL	W^MAC$GL_ARGPTR,R12	;GET POINTER TO ARG POINTERS
	MOVZBL	MNB$B_ARGCT(R6),-(SP)	;STACK # OF ARGS
	BEQL	60$			;IF EQL NOTHING TO DO
	TSTL	MNB$L_ARGP(R6)		;ARE THERE ANY ARGS?
	BEQL	60$			;IF EQL NOTHING TO DEFAULT WITH
10$:	TSTL	(R12)+			;THIS ARG NULL?
	BNEQ	50$			;IF NEQ NO
	MOVL	MNB$L_ARGP(R6),R5	;YES--POINT TO ARGS
	MOVL	W^MAC$GL_MC_ARGCT,R0	;GET CURRENT ARG NUMBER
20$:	CMPB	R0,MAB$B_ARGNO(R5)	;IS THIS THE RIGHT ARG?
	BEQL	30$			;IF EQL YES
	MOVL	(R5),R5			;NO--LINK TO NEXT MAB
	BNEQ	20$			;IF NEQ KEEP LOOKING
	BRB	50$			;???--NOT THERE???--JUST SKIP IT
;
; FOUND KEYWORD MAB. IF THERE IS A DEFAULT VALUE, COPY IT INTO THE
; INPUT BLOCK
;
30$:	MOVZWL	MAB$W_DVLEN(R5),R4	;GET LENGTH OF DEFAULT STRING
	BEQL	50$			;IF EQL THERE IS NONE
	SUBL2	#2,R7			;LEAVE ROOM FOR COUNT WORD
	SUBL2	R4,R7			;SEE IF ROOM IN BLOCK
	BGTR	40$			;IF GTR YES
	ADDL3	#<MXB$K_BLKSIZ+2>,R4,R1	; Compute total size of block required
	BSBW	ALL_INP_PAGE		;NO--GET A PAGE
	SUBL2	#2,R7			; Sub size of count word from new count
40$:	MOVL	R8,-4(R12)		;STORE POINTER TO STRING IN ARG POINTERS
	MOVW	R4,(R8)+		;STORE CHARACTER COUNT
	MOVC3	R4,@MAB$L_DVPTR(R5),(R8);COPY THE DEFAULT STRING
	MOVL	R3,R8			;UPDATE FREE POINTER
50$:	INCL	W^MAC$GL_MC_ARGCT	;NEXT ARGUMENT
	SOBGTR	(SP),10$		;CHECK ALL ARGS
60$:	TSTL	(SP)+			;CLEAR EXHAUSTED COUNT FROM STACK

GET_ARG_EXIT:
	MOVL	W^MAC$GL_BLKPTR,R0	;RETURN INPUT BLOCK ADDRESS IN R0
	POPR	#^M<R7,R8,R12>		;RESTORE REGISTERS
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UPDATES THE ARGUMENT POINTER POINTER IN THE INPUT
;	BLOCK.
;
;--

SET_ARG_PTR:
	PUSHR	#^M<R0,R1>		;SAVE REGISTERS
	MOVL	W^MAC$GL_ARGPTR,R0	;GET POINTER TO ARGUMENT POINTERS
	MOVZBL	MNB$B_ARGCT(R6),R1	;GET TOTAL # ARGS
	SUBL2	W^MAC$GL_MC_ARGCT,R1	;FIGURE INDEX FOR THIS ARG
	MOVL	R8,(R0)[R1]		;STORE POINTER TO ARG
	POPR	#^M<R0,R1>		;RESTORE REGISTERS
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UPDATES THE ARGUMENT POINTER POINTER FOR THE
;	GIVEN KEYWORD.
;
;--

SET_ARG_PKW:
	PUSHL	R0			;SAVE R0
	MOVL	W^MAC$GL_ARGPTR,R0	;POINT TO ARGUMENT POINTERS
	MOVZBL	MAB$B_ARGNO(R1),R1	;GET KEYWORD ARGUMENT NUMBER
	MOVL	R8,-4(R0)[R1]		;STORE POINTER TO ARG
	POPL	R0			;RESTORE R0
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES A PAGE OF VM AND LINKS IT INTO THE
;	PAGE LIST FOR THE CURRENT INPUT BLOCK (POINTED TO BY MAC$GL_BLKPTR).
;
; Inputs:
;
;	R1 = Number of bytes required
;
; Outputs:
;
;	R7 = Number of free bytes in block
;	R8 = Pointer to first free byte
;
;--

ALL_INP_PAGE:
	BSBW	MAC$ALL_BLOCK		; Allocate block
	PUSHL	R1			; Save number of pages allocated
	ASHL	#9,R1,R7		; Convert size to bytes
	SUBL2	#MXB$K_BLKSIZ,R7	; and compute number of free bytes
	MOVL	R0,R8			;SET R8 POINTING TO NEW PAGE
	MOVL	W^MAC$GL_BLKPTR,R1	;GET POINTER TO INPUT BLOCK
	ASSUME	MXB$L_LINK  EQ 0
	ASSUME 	MXB$L_PAGES EQ MXB$L_LINK+4
	MOVL	INP$L_PAGP(R1),(R8)+	;LINK NEW PAGE INTO PAGE LIST
	MOVL	R0,INP$L_PAGP(R1)	;...
	MOVL	(SP)+,(R8)+		; Store block size in block
	RSB

	.END
