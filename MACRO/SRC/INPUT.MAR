	.TITLE	MAC$INPUT GET NEXT CHARACTER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 21-AUG-78
;
; MODIFIED BY:
;
;	V03.01	MTR0011		Mike Rhodes	18-Mar-1982
;		Add logic to routine MAC$GETLIN to trap non-RMS$_EOF errors
;		and non-SUM$_xxx errors.  This occurs when an illegal record
;		is encountered by RMS and it does not count as a SUM error,
;		which leaves us in an infinite loop trying to read the next line.
;		Fixes QAR #691.
;
;	V03.00	MTR0006		Mike Rhodes	15-Mar-1982
;		Modify MAC$GETCHR to allow ALL characters to be passed
;		when the FLG$V_DLIMSTR flag is set.  The characters allowed
;		to be passed include the semicolon (which was already passed)
;		and the hyphen, which at times was incorrectly treated as a
;		line continuation character.  Fixes SPR #11-42904.
;
;	V01.10	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.09	RN0010		R. Newland	5-Sep-1979
;		Mulitpage MXB blocks
;
;	V01.08	RN0005		R. Newland	27-Aug-1979
;		Remove .ALIGN LONG statements
;
;	V01.07	RN0002		R. Newland	01-Feb-1979
;		Changes for Source Update Merge, Get input lines
;		from SUM$LINE.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$RABDEF				;DEFINE RAB OFFSETS
	$MAC_GENVALDEF			;VAX-11 MACRO GENERAL SYMBOLS
	$MAC_CTLFLGDEF			;CONTROL FLAGS
	$MAC_INTCODDEF			;INTERMEDIATE CODE FILE SYMBOLS
	$MAC_INPBLKDEF			;DEFINE INPUT BLOCK OFFSETS
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_MNBDEF			;DEFINE MNB OFFSETS
	$MACMSGDEF			; Define message codes
	$STSDEF				;STATUS BITS
	DEFSUMCBL			; Define SUM control block symbols
;

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;


	.SBTTL	MAC$GETCHR GET NEXT CHARACTER FROM INPUT STREAM
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHENEVER A NEW CHARACTER IS NEEDED.
;	IT PERFORMS ALL THE HOUSEKEEPING FOR ENDS OF LINES, OUTPUTS
;	COMMANDS TO THE INT. FILE FOR NEW LINES, AND HANDLES CONTINUATION
;	LINES.
;
; CALLING SEQUENCE:
;
;	JSB	MAC$GETCHR
;
; INPUT PARAMETERS:
;
;	R10	LAST CHARACTER READ
;	R11	POINTS TO FLAGS (MAC$GL_FLAGS)
;		IF FLG$M_ALLCHR IS SET THEN SEMICOLONS WILL BE PASSED
;			BACK. IF THE FLAG IS CLEAR, SEMICOLONS AND
;			EVERYTHING FOLLOWING WILL BE IGNORED.
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R10	NEXT CHARACTER
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



	.PSECT	MAC$RO_CODE_P15,NOWRT,GBL,LONG

	.ENABL	LSB

MAC$GETCHR::
	PUSHL	R8			;SAVE R8
10$:	MOVAB	W^MAC$GL_LINEPT,R8	;POINT TO MAC$GL_LINEPT
20$:	CMPB	R10,#CR			;TIME TO READ NEW LINE?
	BNEQ	30$			;IF NEQ NO
25$:	MOVZBL	#BLNK,R10		;YES--PREVENT LOOPING ON CR
	MOVL	W^MAC$GL_INPUTP,R0	;ADDRESS INPUT BLOCK
	BISL2	#FLG$M_CONT,(R11)	;ALLOW CONTINUATION LINES
	JSB	@INP$L_GETL(R0)		;CALL INPUT ROUTINE TO READ NEXT LINE
	BBS	#FLG$V_MACTXT,(R11),20$	;BRANCH IF READING MACRO TEXT
	$INTOUT_WD INT$_NEWL,-		;YES--SIGNAL NEW LINE FOR PASS2
			<W^MAC$GL_LINENUM>
	BRB	20$			;CONTINUE
30$:	MOVZBL	@(R8),R10		;GET NEXT CHARACTER
	INCL	(R8)			;POINT TO NEXT CHARACTER
	TSTL	R10			;WAS CHARACTER A NULL?
	BEQL	30$			;IF EQL YES--GET NEXT CHARACTER
					; (GOD ONLY KNOWS WHERE NULLS COME FROM!)
	BBC	#FLG$V_DLIMSTR,(R11),35$ ;ALLOW SEMICOLONS AND HYPHENS?
	BRW	150$			;YES -- BYPASS OTHER TESTS.
35$:	BBS	#FLG$V_SPLALL,(R11),40$	;BRANCH IF SHOULD NOT EVEN CONSIDER
					;SEMI-COLONS
	CMPB	R10,#SEMI		;IS CHARACTER A SEMI-COLON?
	BNEQ	40$			;IF NEQ NO
	BLBS	(R11),40$		;YES--AND ARE WE PASSING ALL CHARS.?
					;(ALLCHR IS LOW BIT!!)
	MOVZBL	#CR,R10			;NO--CALL IT EOL
	BRW	150$			;TAKE THE QUICK EXIT
40$:	CMPB	R10,#HYPHEN		;LINE CONTINUATION?
	BNEQ	150$			;IF NEQ NO
	BBC	#FLG$V_CONT,(R11),150$	;YES--CONTINUATIONS ALLOWED?
	PUSHL	R10			;YES--SAVE CURRENT STATE
	PUSHL	(R8)			;SAVE MAC$GL_LINEPT
	BICL3	#^C<FLG$M_ALLCHR>,(R11),-(SP) ;SAVE ALLCHR STATE
	BICL2	#FLG$M_CONT!FLG$M_ALLCHR,(R11)	;DON'T RECURSE ON LINES THAT HAVE
	MOVZBL	#BLNK,R10		; ALL HYPHENS.
60$:	CMPB	R10,#BLNK		;IS CHARACTER A BLANK?
	BEQL	70$			;IF EQL YES
	CMPB	R10,#TAB		;NO--IS IT A TAB?
	BNEQ	80$			;IF NEQ NO
70$:	BSBW	MAC$GETCHR		;YES--SKIP OVER SPACES AND TABS
	BRB	60$			;FIND NON-BLANK,NON-TAB CHARACTER
80$:	CMPB	R10,#CR			;IS THIS EOL?
	BNEQ	130$			;IF NEQ NO
	BISL2	(SP)+,(R11)		;YES--RESTORE ALLCHR FLAG
	ADDL2	#2*4,SP			;AND SAVED CONTEXT NOT NEEDED
	BSBW	MAC$GETCHR		;READ NEXT LINE
	BBC	#FLG$V_OPRND,(R11),90$	;BRANCH IF NOT IN OPERAND FIELD
	BBCS	#FLG$V_CHKLPND,(R11),100$ ;SET CHKL PENDING AND BRANCH IF NONE PENDING
90$:	$INTOUT_X INT$_CHKL		;ENSURE ALIGNMENT OF CONTINUED LINES
100$:	CMPB	R10,#CR			;NULL LINE?
	BEQL	120$			;IF EQL YES
	CMPB	R10,#FF			;STILL LOOKING FOR NULL LINES
	BEQL	110$
	CMPB	R10,#SEMI		;
	BNEQ	140$
110$:	MOVZBL	#CR,R10			;TREAT AS EOL IF NULL
120$:	BSBW	MAC$GETCHR		;READ NEXT LINE
	BRB	100$			;FIND NON-NULL LINE
;
; NOT REALLY A CONTINUED LINE
;
130$:	BISL2	(SP)+,(R11)		;RESTORE ALLCHR FLAG
	POPL	(R8)			;RESTORE MAC$GL_LINEPT
	POPL	R10			;RESTORE CHARACTER
140$:	BISL2	#FLG$M_CONT,(R11)	;ALLOW CONTINUATIONS AGAIN
150$:	POPL	R8			;RESTORE R8
	RSB				;RETURN WITH CHARACTER IN R10

	.DSABL	LSB

	.SBTTL	MAC$GETLIN GET NEXT INPUT SOURCE LINE

;++
;	THIS ROUTINE IS CALLED TO GET THE NEXT LINE OF THE CURRENT
;	INPUT FILE AND PLACE IT IN MAC$AB_LINEBF.
;--

	.ENABL	LSB

MAC$GETLIN::
	MOVAB	W^MAC$INPUT_RAB,R0	;POINT TO THE RAB
	PUSHAL	W^MAC$GT_SCB		; Control block address
	CALLS	#1,G^SUM$LINE		; Get next input line
	BLBS	R0,40$			; If LBS then good read
	CMPL	R0,#RMS$_EOF		; Was error end-of-file?
	BEQL	8$			; Yes if EQL, try next file
	EXTZV	#STS$V_FAC_NO,#STS$S_FAC_NO,R0,R1 ; Get facility no
	CMPW	R1,#<SUM$_NORMAL@-16>	; SUM error?
	BEQL	2$			; Yes if EQL
	BICL3	#^CSTS$M_SEVERITY,R0,R1	; Copy and check the severity
	BEQL	MAC$GETLIN		; WARNING, try again
	BRB	8$			; ERROR or FATAL, try next file
2$:	BBS	#FLG$V_P2,(R11),5$	; Return line if Pass 2
	BSBW	SUM_ERROR		; Generate intermediate code if Pass 1
	BRB	MAC$GETLIN
5$:
	DECL	W^MAC$GL_LINENUM	; Don't increment line number
	BRB	40$
8$:
	BSBW	MAC$NXTINPFIL		;ELSE TRY TO OPEN NEXT FILE
	MOVZBL	#1,W^MAC$GL_SRCPAG	;RESET PAGE COUNT TO ONE
	BLBS	R0,MAC$GETLIN		;IF THERE IS ANOTHER FILE GO READ IT
10$:	MOVL	#^A/.END/,W^MAC$AB_LINEBF ;OOPS--NO FILE--FAKE A '.END'
	MOVZBW	#4,W^MAC$INPUT_RAB+RAB$W_RSZ ;WITH A SIZE OF 4 BYTES
	TSTL	W^MAC$GL_IF_LEVEL	;IN UNFINISHED CONDITIONAL?
	BLEQ	30$			;IF LEQ NO
	MOVB	#^A/C/,W^MAC$AB_LINEBF+4;YES--MAKE .END INTO .ENDC
	INCW	W^MAC$INPUT_RAB+RAB$W_RSZ ;COUNT THE CHARACTER
	BRB	40$			;CONTINUE
30$:	BBS	#FLG$V_P2,(R11),40$	;ONLY MESSAGE ON PASS 1
;***	$INTOUT_X INT$_FNEWL		;PRINT CONTENTS OF PREVIOUS LINE
	$INTOUT_LW INT$_WRN,-		;TELL OF MISSING END STATEMENT
	<#MAC$_MISSINGEND,#0>
40$:	MOVZWL	W^MAC$INPUT_RAB+RAB$W_RSZ,- ;SAVE LENGTH OF LINE
			R0
	MOVL	R0,W^MAC$GL_LINELN	;...
50$:	MOVAB	W^MAC$AB_LINEBF,R0	;GET ADDRESS OF LINE BUFFER
	MOVL	R0,W^MAC$GL_LINEPT	;SET UP LINE POINTER
	MOVL	R0,W^MAC$GL_ERRPTX	;RESET ERROR POINTER TO LINE START
	CMPB	(R0),#FF		;NEW SOURCE PAGE?
	BNEQ	60$			;IF NEQ NO
	INCL	W^MAC$GL_SRCPAG		;YES--COUNT NEW PAGE
60$:	ADDL2	W^MAC$GL_LINELN,R0	;FIGURE ADDRESS OF LAST CHARACTER
	MOVB	#CR,(R0)		;STORE CR FOR END OF LINE
	INCL	W^MAC$GL_LINENUM	;COUNT THIS LINE
	BBS	#FLG$V_P2,(R11),80$	;BRANCH IF THIS IS PASS 2
	INCL	W^MAC$GL_SRC_LCNT	;NO--COUNT LINE READ IN PASS 1
80$:
	CLRL	R1			; Initialise insert number
	BBS	#FLG$V_UPDFIL,(R11),90$	; Branch if file is being updated
	SUBL3	W^MAC$GL_LINBAS, -	; Compute line number
		W^MAC$GL_LINENUM,R0
	BBC	#FLG$V_SEQFIL,(R11),100$ ; Branch if not sequenced file
	MOVL	W^MAC$GL_RECHDBUF,R0	; Get sequenced line number
	BRB	100$
90$:
	MOVZWL	W^MAC$GT_SCB+SUM_W_LINE_NO,R0 ; Get original line number
	BBC	#SUM_V_SRCUPD, -	; Branch if line from source file
		W^MAC$GT_SCB+SUM_B_FLAGS,100$
	MOVZWL	W^MAC$GT_SCB+SUM_W_INSERT_NO,R1 ; Get insert number
100$:
	MOVW	R0,W^MAC$GW_LST_LINE	; Save listing line number
	MOVW	R1,W^MAC$GW_LST_INST	; and insert number
	RSB

	.DSABL	LSB
;
;
SUM_ERROR:
	TSTL	W^MAC$GL_LINENUM	; Error on very first line?
	BNEQ	5$			; No if NEQ
	BBSS	#FLG$V_FIRSTLN,(R11),5$
5$:
	CMPL	R0,#SUM$_EDITSCLSH	; Edits clash error?
	BNEQ	4$			; No if NEQ
	BBS	#SUM_V_SUBCLSH,	-	; Branch if not first clash
		MAC$GT_SCB+SUM_B_FLAGS,10$
	PUSHL	R0
	$INTOUT_X INT$_FNEWL		; Force new line
	POPL	R0
	BISL2	#STS$K_INFO,R0		; Make and information code
	$INTOUT_LW INT$_INFO,<R0,#0>	; Information message
	BRB	10$
4$:
	PUSHL	R0
	$INTOUT_X INT$_FNEWL		; Force new line
	POPL	R0
	$INTOUT_LW INT$_WRN,<R0,#0>	; Warning message
10$:
	$INTOUT_X INT$_SUME		; Source update merge error
	RSB

	.SBTTL	OPEN NEXT INPUT SOURCE FILE

;++
;	THIS ROUTINE IS CALLED TO OPEN THE NEXT INPUT FILE.
;	IF THE FILE IS SUCCESSFULLY OPENED AND CONNECTED,
;	R0 IS SET TO 1.  IF ANOTHER INPUT FILE CANNOT BE OPENED,
;	R0 IS 0.
;
;--

MAC$NXTINPFIL:
	PUSHR	#^M<R1,R2,R3,R4,R5>	;SAVE REGISTERS USED BY MOVC5
	PUSHAB	W^MAC$GT_SCB		; Supply SUM control block address
	CALLS	#1,G^SUM$CLOSE		; Close any update files
	$DISCONNECT RAB=W^MAC$INPUT_RAB	;DISCONNECT THE RECORD ACCESS
	MOVL	W^MAC$GL_CURINFDB,R0	;POINT TO CURRENT FDB
	$CLOSE	FAB=8(R0)		;CLOSE THE INPUT FILE
	MOVL	W^MAC$GL_LINENUM,-	;SET LINE BASE TO HIGHEST LINE NUMBER
			W^MAC$GL_LINBAS	; ...
	MOVC5	#0,(SP),#^A/ /,#39,-	;BLANK FILL THE RESULTANT FILENAME
			W^MAC$AB_SBT_FILE
	MOVL	W^MAC$GL_CURINFDB,R0	;GET ADDRESS OF FDB WE JUST CLOSED
	CMPL	R0,W^MAC$GL_INPQUE+4	;WAS IT THE LAST FDB
	BEQL	20$			;IF EQL YES
	MOVL	(R0),R0			;NO--LINK TO NEXT FDB
	BSBW	MAC$OPEN_INPUT		;OPEN NEXT INPUT FILE
	POPR	#^M<R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	RSB				;RETURN WITH LBS IN R0
;
; NO MORE INPUT FILES
;
20$:	CLRL	R0			;INDICATE NO MORE FILES
	POPR	#^M<R1,R2,R3,R4,R5>
	RSB

	.SBTTL	STAT4		SWITCH INPUT TO MACRO TEXT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS SEMANTIC ROUTINE SWITCHES THE POINTER TO THE CURRENT
;	INPU BLOCK TO POINT TO THE MACRO BEING EXPANDED.  FIRST THE
;	REAL MACRO ARGUMENTS ARE SCANNED AND AN INPUT BLOCK IS CREATED.
;	THEN MAC$GETCHR WILL READ CHARACTERS FROM THE MACRO TEXT
;	EXPANDER MAC$GET_MAC_LIN.
;
;--

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG
STAT4::					;STATEMENT = MACTXT
	BLBS	W^LST$G_MACROCALL+SYM$L_VAL,10$ ;BRANCH IF LISTING MACRO CALLS
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;NO--SEND FLAG TO PASS 2
10$:	MOVL	W^MAC$AL_VALSTACK[R7],R6 ;GET PTR TO MACRO MNB
	MOVZBL	#CRF$K_REF,R5		;THIS IS A REFERENCE
	BSBW	MAC$CREF_MACRO		;CROSS REFERENCE IF CREFFING
	TSTL	MNB$L_TXTP(R6)		;IS THERE ANY TEXT
	BEQL	20$			;IF EQL NO--TAKE THE QUICK OUT
	MOVL	R6,W^MAC$GL_MACPTR	;SAVE POINTER TO MACRO MNB
	MOVL	MNB$L_ARGP(R6),W^MAC$GL_KEYMAC ;SET PTR TO KEYWORD ARGS (IF ANY)
	BSBW	MAC$GET_ARGS		;SCAN REAL MACRO ARGS
					;AND SET UP INPUT BLOCK
	CLRL	W^MAC$GL_KEYMAC		;CLEAR POINTER TO KEYWORD ARGS
	MOVL	W^MAC$GL_BLKPTR,W^MAC$GL_INPUTP ;POINT TO NEW INPUT BLOCK
	BBCS	#FLG$V_MACTXT,(R11),20$	;FLAG READING MACRO TEXT
20$:	MOVZBL	#CR,R10			;FORCE READING OF NEW LINE
30$:	RSB

	.SBTTL	MEXIT		MACRO EXIT ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE POPS THE INPUT CONTEXT ONE LEVEL TO EFFECT AN
;	EXIT FROM A MACRO OR REPEAT-TYPE MACRO
;
;--

MEXIT::					;DIRECTIVE = KMEXIT

	.SBTTL	MAC$POP_INPUT	POP INPUT CONTEXT UP A LEVEL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE POPS THE INPUT CONTEXT A LEVEL.  ALL PAGES
;	ALLOCATED TO THE CURRENT INPUT BLOCK ARE DEALLOCATED.
;
;--

MAC$POP_INPUT::
	PUSHL	R6			;SAVE R6
	MOVL	W^MAC$GL_INPUTP,R6	;GET POINTER TO CURRENT INPUT BLOCK
	BBC	#FLG$V_MACTXT,(R11),10$	;BRANCH IF NOT READING MACRO TEXT
	MOVL	INP$L_RPTCNT(R6),R0	;YES--GET REPEAT COUNT (OR MACRO FLAG)
	BGEQ	10$			;IF GEQ NO NEED TO GO ANY FARTHER
	INCL	R0			;SEE IF IT WAS REPEAT THAT WENT TO 0
	BEQL	10$			;IF EQL YES
					;NO--IT WAS MACRO REDEFINING ITSELF
	BICL3	#^X80000000,INP$L_RPTCNT(R6),R6 ;YES--GET ADDRESS OF MNB
	BSBW	MAC$DEL_MAC_DEF		;AND DELETE THE MNB AND ASSOCIATES
	MOVL	W^MAC$GL_INPUTP,R6	;RE-GET THE INPUT BLOCK ADDRESS
10$:	MOVL	INP$L_LINK(R6),R0	;POP INPUT CONTEXT
	MOVL	R0,W^MAC$GL_INPUTP	;...
	CMPL	R0,#MAC$GL_PRMINBL	;READING FROM SOURCE FILE?
	BNEQ	20$			;IF NEQ NO
	BBCC	#FLG$V_MACTXT,(R11),20$	;YES--CLEAR MACTXT FLAG
20$:	MOVL	INP$L_IFVAL(R6),W^MAC$GL_IF_VALUE ;POP IF VALUE
	MOVL	INP$L_IFLVL(R6),W^MAC$GL_IF_LEVEL ;POP IF LEVEL
	MOVL	R6,R0			;COPY INPUT BLOCK ADDRESS
	MOVL	INP$L_PAGP(R6),R6	;LINK TO ANY OTHER PAGES
	BSBW	MAC$DEA_1_PAGE		; Deallocate block (always 1 page)
	BRB	40$			;GO DEALLOCATE INPUT BLOCK AND REST
					;OF INPUT CONTEXT PAGES
30$:
	MOVL	MXB$L_LINK(R6),R6	; Link to possible next page
	BSBW	MAC$DEAL_BLOCK		; Deallocate memory block
40$:
	MOVL	R6,R0			;POINT R0 FOR NEXT DEALLOCATION
	BNEQ	30$			;IF NEQ GO DO IT
	MOVZBL	#CR,R10			;FORCE NEW LINE
	POPL	R6			;RESTORE R6
	RSB

	.SBTTL	STATEMENTS	END-OF-LINE CLEANUP

;++
;	AFTER EACH STATEMENT SOME FLAGS NEED TO BE RESET.
;--

;MTXT1::					;MARS_TEXT = STATEMENT
;MTXT2::					;MARS_TEXT = MARS_TEXT STATEMENT
MTXT3::					;MARS_TEXT = DEOL
MTXT4::					;MARS_TEXT = MARS_TEXT DEOL
MTEXT:
					;BEFORE FOR THIS LINE
	$INTOUT_X INT$_CHKL		;ALIGN LISTING AND SOURCE
	BISL2	#FLG$M_BOL!FLG$M_EVALEXPR!FLG$M_COMPEXPR,- ;RESET BEGINNING OF LINE
			(R11)		;AND EVALUATE FLAGS
	CLRL	W^MAC$GL_ABSFLAG	;RESET ABSOLUTE FLAG
	CLRL	W^MAC$GL_PRMSEG		;NO EXPRESSION PSECT YET
	CLRL	W^MAC$GL_MOPPTR		;CLEAR POINTER TO OPERAND MODE BYTES
	BICL2	#FLG$M_OPRND!FLG$M_IFSTAT!FLG$M_NOREF,(R11) ;NOT  IN OPERAND FIELD
						;AND NOT IN AN IF
						;AND ALLOW PRMSYM TO REF SYMBOLS
	MOVB	#RDX$V_DECIMAL,W^MAC$GB_RDXNDX ;RESET TO DECIMAL RADIX
	RSB

	.END
