	.TITLE	MAC$CRFSUB	SUBROUTINES FOR USE WITH CREF/MACRO
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 28-AUG-78
;
; MODIFIED BY:
;
;	V01.06	RN0024		R. Newland		13-Dec-1979
;		Change cref output routine argument processing.
;
;	V01.05	RN0005		R. Newland	13-Aug-1979
;		Variable symbol name storage and remove .ALIGN LONG statments
;
;	V01.04	RN0002		R. Newland	01-Feb-1979
;		Changes for Source Update Merge, convert line number
;		into update format for updated line
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_CRFLAGDEF			;DEFINE CREF CONTROL FLAGS
	$MAC_MNBDEF			;DEFINE MACRO NAME BLOCK
	$MAC_OPRDEF			;DEFINE OPERAND DESCRIPTOR BITS
	$RABDEF				;DEFINE RAB OFFSETS
	DEFSUMCBL			; Define SUM control block symbols


	.PSECT	MAC$RO_CODE_P15,NOWRT,GBL,LONG

	.SBTTL	MAC$CVT_LIN_PAG	CONVERT LINE/PAGE TO ASCII FOR CREF

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS THE CURRENT LINE/PAGE NUMBER INTO ASCII
;	IN MAC$AB_LPBUF TO USE WHEN CALLING CREF WITH A REFERENCE
;	OR DEFINITION.
;
;	THE LINE AND PAGE NUMBERS ARE RETURNED IN THE FOLLOWING FORMAT:
;
;		LLLLL (PPPP)
;
;--

MAC$CVT_LIN_PAG::
	PUSHAB	W^MAC$AB_LPBUF		;STACK BUFFER ADDRESS
	MOVC5	#0,(SP),#^A/ /,#16,@(SP) ;BLANK FILL THE BUFFER
	MOVL	(SP),R1			;POINT TO THE BUFFER
	CLRB	(R1)+			;LEAVE ROOM FOR COUNT BYTE
	MOVZWL	W^MAC$GW_LST_LINE,R0	; Get listing line number
	BBC	#FLG$V_UPDFIL,(R11),10$	; Branch if input file is not being updated
	BBC	#SUM_V_SRCUPD, -	; Branch if line is not an update
		W^MAC$GT_SCB+SUM_B_FLAGS,10$
	BSBW	MAC$DEC_OUT_L2X		; Convert line number
	MOVL	R0,R1			; Reset character output pointer
	MOVB	#^A/./,(R1)+		; Insert separating '.'
	MOVZWL	W^MAC$GW_LST_INST,R0	; Get insert number
10$:	BSBW	MAC$DEC_OUT_L2X		;CONVERT LINE NUMBER
	ADDL3	#7,(SP),R1		;SKIP TO PAGE # FIELD
	MOVW	#^A/ (/,(R1)+		;START THE PAGE NUMBER
	MOVL	W^MAC$GL_SRCPAG,R0	;GET SOURCE PAGE NUMBER
	BSBW	MAC$DEC_OUT_L2X		;CONVERT PAGE NUMBER
	MOVB	#^A/)/,(R0)+		;FINISH PAGE NUMBER
	POPL	R1			;POINT TO BUFFER START AGAIN
	SUBL2	R1,R0			;FIGURE LENGTH OF STRING
	SUBB3	#1,R0,(R1)		;GET REAL LENGTH AND STORE IT
	RSB

	.SBTTL	MAC$CREF_ERROR	HANDLER FOR CREF ERRORS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED FROM CREF ON AN ERROR
;
;--

MAC$CRF_ERROR::
	.WORD	0			;REGISTER SAVE MASK
	MOVL	R0,W^MAC$GL_STATUS	;SET LATEST STATUS FOR EXIT
	PUSHL	#0			;NO FAO ARGUMENTS
	PUSHL	R0			;STACK THE ERROR CODE
	PUSHL	#2			;THERE ARE TWO LONGWORDS IN PACKET
	PUSHAQ	W^MAC$MACRO_NAME	;STACK ADDRESS OF FACILITY NAME
	CLRL	-(SP)			;ZERO ADDRESS OF ACTION ROUTINE
	PUSHAB	8(SP)			;PUSH ADDRESS OF MESSAGE BUFFER
	CALLS	#3,G^SYS$PUTMSG		;PRINT THE CREF ERROR
	BRW	MAC$LAST_CHANCE		;GO DIE UNGRACEFULLY

	.SBTTL	MAC$CRF_OUTPUT	OUTPUT CROSS-REFERENCE LINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY CREF TO OUTPUT A LINE:
;
; CALLING SEQUENCE:
;
;	CALLS	#1,MAC$CRF_OUTPUT
;
; INPUTS:
;
;	4(AP)	Address of line descriptor
;
;--

MAC$CRF_OUTPUT::
	.WORD	^M<R11>			;IN CASE WE NEED TO DO NEW PAGE
	BBC	#FLG$V_LSTXST,W^MAC$GL_FLAGS,20$ ;BRANCH IF NO LISTING FILE!
	TSTL	W^MAC$GL_LINE_CNT	;TIME FOR NEW PAGE?
	BGTR	10$			;IF GTR NO
	MOVAB	W^MAC$GL_FLAGS,R11	;ENSURE R11 POINTS TO FLAGS WORD
	BSBW	MAC$LST_PAG_HDR		;YES--OUTPUT PAGE HEADER
10$:	DECL	W^MAC$GL_LINE_CNT	;DEC. LINES LEFT ON PAGE
	MOVAB	W^MAC$LIST_RAB,R0	;POINT TO LISTING RAB
	MOVL	4(AP),R1		; Get address of line descriptor
	MOVW	(R1),RAB$W_RSZ(R0)	; Set record size
	MOVL	4(R1),RAB$L_RBF(R0)	; and record address
	$PUT	RAB=(R0),-		;WRITE LINE TO LISTING
		ERR=W^MAC$ERR_PUT
20$:	RET

	.SBTTL	MAC$CREF_SYM	EMIT CROSS REFERENCE INFO FOR SYMBOL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT CROSS REFERENCE INFORMATION
;	FOR A SYMBOL TO THE CROSS-REFERENCER.
;
; INPUTS:
;
;	R5	CRF$K_REF OR CRF$K_DEF
;	R6	SYMBOL BLOCK ADDRESS
;
;--

MAC$CREF_SYM::
	BBC	#CRF$V_SYMBOLS,-	;BRANCH IF NOT CREFFING SYMBOLS
		W^MAC$GL_CRF_FLG,30$	;...
	BBS	#FLG$V_XCRF,(R11),30$	;BRANCH IF .NOCROSS IN EFFECT
	BBS	#SYM$V_LOCAL,SYM$W_FLAG(R6),30$ ;DON'T CREF LOCAL SYMBOLS
	BBS	#SYM$V_XCRF,SYM$W_FLAG(R6),30$ ;BRANCH IF .NOCROSS THIS SYMBOL
;*****
; NEXT INSTRUCTION DEPENDS ON CRF$K_DEF=1
;*****
	BLBS	R5,5$			;BRANCH IF DEFINITION
	BBSS	#SYM$V_CRFO,SYM$W_FLAG(R6),10$ ;BRANCH IF INSERT KEY DONE
5$:	MOVZWL	SYM$W_FLAG(R6),-(SP)	;NO--INSERT KEY NOW
	PUSHAB	SYM$L_VAL(R6)		;STACK ADDRESS OF VALUE
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to counted name
	SUBL3	R0,R6,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFSYCTB	;STACK CONTROL TABLE ADDRESS
	CALLS	#4,G^CRF$INSRTKEY	;INSERT THE KEY IN CREF TABLE
10$:	PUSHL	R5			;STACK REF/DEF FLAG
	PUSHL	#0			;ASSUME A READ REFERENCE
	MOVL	W^MAC$GL_MOPPTR,R0	;GET POINTER TO OPERAND BYTES
	BEQL	20$			;IF EQL NOT INSTRUCTION--MUST BE READ
	BITW	#OPD$M_MODIFY!OPD$M_WRITE,(R0) ;IS IT MODIFY OR WRITE?
	BEQL	20$			;IF EQL NO--NOT DESTRUCTIVE
	MOVL	#1,(SP)			;YES--MARK FLAGS AS SUCH
20$:	PUSHAB	W^MAC$AB_LPBUF		;STACK REFERENCER NAME ADDRESS
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to counted name
	SUBL3	R0,R6,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFSYCTB	;STACK CONTROL TABLE ADDRESS
	BSBW	MAC$CVT_LIN_PAG		;CONVERT LINE/PAGE INTO LPBUF
	CALLS	#5,G^CRF$INSRTREF	;INSERT REF/DEF INTO CREF TABLE
	INCL	W^MAC$GL_CRF_CNT	;COUNT SYMBOL AS CREFFED
30$:	RSB

	.SBTTL	MAC$CREF_MACRO	EMIT CROSS REFERENCE INFO FOR MACRO

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT CROSS REFERENCE INFORMATION FOR
;	A MACRO TO THE CROSS-REFERENCER.
;
; INPUTS:
;
;	R5	CRF$K_REF OR CRF$K_DEF
;	R6	MACRO NAME BLOCK ADDRESS
;
;--

MAC$CREF_MACRO::
	BBC	#CRF$V_MACROS,-		;BRANCH IF NOT CREFFING MACROS
		W^MAC$GL_CRF_FLG,30$	;...
	BBS	#FLG$V_XCRF,(R11),30$	;BRANCH IF .NOCROSS IN EFFECT
	BBSS	#SYM$V_CRFO,MNB$W_FLAG(R6),10$ ;BRANCH IF INSERT DONE THIS MACRO
	MOVZWL	MNB$W_FLAG(R6),-(SP)	;NO--INSERT KEY NOW
	PUSHAB	MNB$L_PAGC(R6)		;STACK ADDRESS OF PAGE COUNT
	MOVZBL	MNB$B_NAME(R6),R0	; Get offset to counted name
	SUBL3	R0,R6,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFMCCTB	;STACK CONTROL TABLE ADDRESS
	CALLS	#4,G^CRF$INSRTKEY	;INSERT KEY INCREF TABLE
10$:	PUSHL	R5			;STAKC REF/DEF FLAG
	PUSHL	#0			;PUSH REFERENCER FLAGS (NYI)
	PUSHAB	W^MAC$AB_LPBUF		;STACK REFERENCER NAME ADDRESS
	MOVZBL	MNB$B_NAME(R6),R0	; Get offset to counted name
	SUBL3	R0,R6,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFMCCTB	;STACK CONTROL TABLE ADDRESS
	BSBW	MAC$CVT_LIN_PAG		;CONVERT LINE/PAGE INTO LPBUF
	CALLS	#5,G^CRF$INSRTREF	;INSERT REF/DEF INTO CREF TABLE
	INCL	W^MAC$GL_CRF_MCNT	;COUNT MACRO AS CREFFED
30$:	RSB

	.SBTTL	MAC$CREF_OPCODE	EMIT CREF INFO FOR OPCODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT CREF INFORMATION FOR AN
;	OPCODE.
;
; INPUTS:
;
;	R6	POINTS TO SYMBOL BLOCK
;
;--

MAC$CREF_OPCODE::
	BBC	#CRF$V_OPCODES,W^MAC$GL_CRF_FLG,30$ ;BRANCH IF NOT CREFFING OPCODES
	BBS	#FLG$V_XCRF,(R11),30$	;BRANCH IF .NOCROSS IN EFFECT
;
; BECAUSE THE OPCODE TABLE IS IN WRITE-ONLY MEMORY, WE MUST ALWAYS DO
; AN INSERT KEY. SORRY ABOUT THAT, FOLKS.
;
	PUSHL	#0			;STACK FLAGS
	PUSHAB	SYM$L_VAL(R6)		;STACK VALUE
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to counted name
	SUBL3	R0,R6,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFOPCTB	;STACK CONTROL TABLE ADDRESS
	CALLS	#4,G^CRF$INSRTKEY	;INSERT THE KEY
	PUSHL	#CRF$K_REF		;THIS IS A REFERENCE
	PUSHL	#0			;REFERENCER FLAGS
	PUSHAB	W^MAC$AB_LPBUF		;STACK REFERENCER NAME ADDRESS
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to counted name
	SUBL3	R0,R6,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFOPCTB	;STACK CONTROL TABLE ADDRESS
	BSBW	MAC$CVT_LIN_PAG		;CONVERT LINE/PAGE INTO LPBUF
	CALLS	#5,G^CRF$INSRTREF	;INSERT REFERENCE
	INCL	W^MAC$GL_CRF_OCNT	;COUNT OPCODE REFERENCE
30$:	RSB

	.SBTTL	MAC$CREF_DIR	EMIT CREF INFO FOR DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT CREF INFORMATION FOR A
;	DIRECTIVE.
;
; INPUTS:
;
;	R1	POINTER TO DIRECTIVE SYMBOL BLOCK
;
;--

MAC$CREF_DIR::
	BBC	#CRF$V_DIR,W^MAC$GL_CRF_FLG,30$ ;BRANCH IF NO CREF OF DIRECTIVES
	BBS	#FLG$V_XCRF,(R11),30$	;BRANCH IF .NOCROSS IN EFFECT
;
; THE DIRECTIVE TABLE, LIKE THE OPCODE TABLE, IS IN READ-ONLY MEMORY.
; THUS, WE MUST ALWAYS DO AN INSERT KEY.
;
	PUSHL	R1			;SAVE R1 (PTR TO SYM BLK)
	PUSHL	#0			;STACK FLAGS
	PUSHAB	L^MAC$GK_ZERO		;STACK VALUE
	MOVZBL	SYM$B_NAME(R1),R0	; Get offset to counted name
	SUBL3	R0,R1,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFDRCTB	;STACK CONTROL TABLE ADDRESS
	CALLS	#4,G^CRF$INSRTKEY	;INSERT THE KEY
	MOVL	(SP),R1			;REGET SYMBOL BLOCK ADDRESS
	PUSHL	#CRF$K_REF		;THIS IS A REFERENCE
	PUSHL	#0			;REFERENCER FLAGS
	PUSHAB	W^MAC$AB_LPBUF		;REFERENCER NAME ADDRESS
	MOVZBL	SYM$B_NAME(R1),R0	; Get offset to counted name
	SUBL3	R0,R1,-(SP)		; and form its address on stack
	PUSHAB	W^MAC$AL_CRFDRCTB	;STACK CONTROL TABLE ADDRESS
	BSBW	MAC$CVT_LIN_PAG		;CONVERT LINE/PAGE
	CALLS	#5,G^CRF$INSRTREF	;INSERT REFERENCE
	INCL	W^MAC$GL_CRF_DCNT	;COUNT DIRECTIVE REFERENCE
	POPL	R1			;GET SYMBOL BLOCK ADDRESS BACK
30$:	RSB

	.END
