	.TITLE	MAC$INTOUT WRITE CODE TO INTERMEDIATE BUFFER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V01.02	RN0005		R. Newland	27-Aug-1979
;		Remove .ALIGN LONG statements
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$MAC_GENVALDEF			;COMMON VAX-11 MACRO SYMBOLS
	$MAC_INTCODDEF			;DEFINE INT. FILE CODES
	$MAC_CTLFLGDEF			;FLAG BITS POINTED TO BY R11

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

	.SBTTL	MAC$INTOUT_LW WRITE TO INT. BUFFER IN LONGWORDS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PUT LONGWORDS FROM THE STACK INTO
;	THE INTERMEDIATE FILE.
;
; CALLING SEQUENCE:
;
;	PUSHL	LWN
;	PUSHL	LWN-1
;	.
;	.
;	PUSHL	LW1
;	BSBW	MAC$INTOUT_N_LW
;
; INPUTS:
;
;	LONGWORDS ON THE STACK
;
; OUTPUTS:
;
;	LONGWORDS POPPED FROM STACK AND PUT IN INTER. BUFFER.
;
;--

MAC$INTERR_3_LW::
	BBCC	#FLG$V_EXPOPT,(R11),.+1	;DO NOT ALLOW EXPRESSION OPT.
MAC$INTOUT_3_LW::
	MOVL	#14,R1			;BYTE COUNT TOTAL
	BSBB	OUT_LW			;JOIN COMMON CODE
	.BYTE	3			;TO STORE 3 LONGWORDS

MAC$INTERR_2_LW::
	BBCC	#FLG$V_EXPOPT,(R11),.+1	;DO NOT ALLOW EXPRESSION OPT.
MAC$INTOUT_2_LW::
	MOVL	#10,R1			;BYTE COUNT TOTAL
	BSBB	OUT_LW			;GO TO COMMON CODE
	.BYTE	2			;TO STORE 2 LONGWORDS

MAC$INTERR_1_LW::
	BBCC	#FLG$V_EXPOPT,(R11),.+1	;DO NOT ALLOW EXPRESSION OPT.
MAC$INTOUT_1_LW::
	MOVL	#6,R1			;BYTE COUNT TOTAL
	BSBB	OUT_LW			;GO TO COMMON CODE
	.BYTE	1			;TO STORE 1 BYTE
OUT_LW:
	SUBL3	R1,W^MAC$GL_INTCNT,R2	;SEE IF ROOM IN BUFFER
	BGTR	10$			;IF GTR YES
	BSBW	MAC$OUTFRAME		;NO--WRITE THE BUFFER
	SUBL3	R1,W^MAC$GL_INTCNT,R2	;UPDATE COUNT IN R2
10$:	MOVL	R2,W^MAC$GL_INTCNT	;UPDATE INT. COUNT
	MOVB	R1,(R9)+		;STORE COUNT BYTE
	MOVB	R0,(R9)+		;STORE ACTION BYTE
	MOVZBL	@(SP)+,R1		;GET LONGWORD COUNT AND CLEAR IMMEDIATE CALLER
	POPL	R0			;POP OFF RETURN ADDRESS
20$:	POPL	(R9)+			;GET NEXT LONGWORD
	SOBGTR	R1,20$			;LOOP FOR ALL
	JMP	(R0)			;RETURN TO CALLER

	.SBTTL	MAC$INTOUT_WD WRITE WORD (2 BYTES) TO INT. FILE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT ONE WORD (2 BYTES) TO
;	THE INTERMEDIATE FILE.
;
; CALLING SEQUENCE:
;
;	MOVZBL	#ACTION,R0
;	MOVZWL	DATA,R1
;	BSBW	MAC$INTOUT_WD
;
;--

MAC$INTOUT_WD::
	SUBL3	#4,W^MAC$GL_INTCNT,R2	;SEE IF ROOM IN BUFFER
	BGTR	10$			;IF GTR YES
	BSBB	MAC$OUTFRAME		;NO--WRITE THE BUFFER
	SUBL3	#4,W^MAC$GL_INTCNT,R2	;UPDATE R2
10$:	MOVL	R2,W^MAC$GL_INTCNT	;UPDATE INT. COUNT
	MOVB	#4,(R9)+		;COUNT IS 4 BYTES
	MOVB	R0,(R9)+		;STORE ACTION BYTE
	MOVW	R1,(R9)+		;STORE DATA WORD
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT A 'STORE IMMEDIATE' BYTE
;	COMMAND TO THE INTERMEDIATE FILE, AND ONLY STORE ONE BYTE
;	RATHER THAN A WHOLE LONGWORD.  NOTE THAT THE PASS 2 PROCESSOR
;	MUST NOT CARE THAT THERE IS ONLY A BYTE.
;
; INPUTS:
;
;	R0	BYTE TO STORE
;
;--

MAC$INTOUT_BY::
	SUBL3	#3,W^MAC$GL_INTCNT,-(SP) ;SEE IF ROOM
	BGTR	10$			;IF GTR YES
	BSBB	MAC$OUTFRAME		;NO--WRITE BUFFER
	SUBL3	#3,W^MAC$GL_INTCNT,(SP)	;UPDATE STACK
10$:	MOVL	(SP)+,W^MAC$GL_INTCNT	;UPDATE COUNT
	MOVB	#3,(R9)+		;STORE BYTE COUNT
	MOVB	#INT$_STIB,(R9)+	;STORE ACTION CODE
	MOVB	R0,(R9)+		;STORE DATA BYTE
	RSB

	.SBTTL	MAC$INTOUT_X WRITE ONLY ACTION CODE TO INT. FILE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OUTPUT ONLY AN ACTION CODE.  IT
;	IS USED WHEN AN ACTION CODE TAKES NO OTHER PARAMETERS
;	(FOR INSTANCE, INT$_CHKL).
;
; INPUT PARAMETERS:
;
;	R0	ACTION CODE
;
;--

MAC$INTOUT_X::
	SUBL3	#2,W^MAC$GL_INTCNT,-(SP) ;SEE IF ROOM IN BUFFER
	BGTR	10$			;IF GTR YES
	BSBB	MAC$OUTFRAME		;NO--OUTPUT CURRENT BUFFER
	SUBL3	#2,W^MAC$GL_INTCNT,(SP)	;ADJUST VALUE ON STACK
10$:	MOVL	(SP)+,W^MAC$GL_INTCNT	;SET NEW BUFFER COUNT
	MOVB	#2,(R9)+		;SET BYTE COUNT IN BUFFER
	MOVB	R0,(R9)+		;SET ACTION INTO BUFFER
	RSB

	.SBTTL	MAC$INTOUT_N PREPARE TO WRITE 'N' BYTES TO INT. FILE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PREPARES FOR SOMEONE TO EMIT 'N' BYTES TO THE
;	INTERMEDIATE FILE. 
;
; INPUT PARAMETERS:
;
;	R0	NUMBER OF BYTES IN FRAME, INCLUDING COUNT BYTE
;
;--

MAC$INTOUT_N::
	SUBL3	R0,W^MAC$GL_INTCNT,-(SP);IS THERE ENOUGH ROOM IN THE BUFFER?
	BGTR	10$			;IF GTR YES
	BSBB	MAC$OUTFRAME		;NO--WRITE BUFFER TO VIRT. MEMORY
	SUBL3	R0,W^MAC$GL_INTCNT,(SP)	;ADJUST THE COUNT ON THE STACK
10$:	MOVL	(SP)+,W^MAC$GL_INTCNT	;UPDATE THE BUFFER COUNT
	MOVB	R0,(R9)+		;STORE THE COUNT BYTE IN THE BUFFER
	RSB

	.SBTTL	COPY FRAME FROM INT. BUFFER TO VIRT. MEMORY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE INT. BUFFER DOES NOT HAVE ENOUGH
;	ROOM FOR THE NEXT FRAME.  THE COUNT IS FIXED IN THE CURRENT BLOCK,
;	A NEW BLOCK OF MEMORY IS ALLOCATED, AND THE POINTER AND COUNTER
;	ARE SET UP FOR IT.
;
;--

MAC$SETFRAME::
	PUSHR	#^M<R0,R1>		;SAVE REGISTERS
	BRB	FRAM_0			;JUST ALLOCATE THE BLOCK AND SETUP

MAC$OUTFRAME::
	PUSHR	#^M<R0,R1>		;PRESERVE ALL REGISTERS USED
	BSBB	MAC$FIXFRAME		;FIX BYTE COUNT IN CURRENT BLOCK
FRAM_0:
	MOVL	#INT$K_BUFSIZ,R0	;GET THE SIZE OF A BUFFER
	MOVL	R0,W^MAC$GL_INTCNT	;RESET THE COUNTER
	PUSHAB	12(R0)			;STACK # BYTES WE REALLY NEED
	MOVL	SP,R0			;SAVE PTR TO COUNT
	PUSHAL	W^MAC$GL_INTFRMPT	;STACK PTR TO RESULT LONGWORD
	PUSHL	R0			;STACK ADDRESS OF SIZE
	CALLS	#2,G^LIB$GET_VM		;ALLOCATE VM FOR NEXT BLOCK
	BLBC	R0,20$			;BRANCH IF ALLOC ERROR
	TSTL	(SP)+			;CLEAR COUNT FROM STACK
	MOVL	W^MAC$GL_INTFRMPT,R0	;GET PTR TO THE BLOCK
	INSQUE	(R0),@W^MAC$GL_INTQUE+4	;INSERT AT TAIL OF QUEUE
	MOVAB	8(R0),R9		;POINT TO THE COUNT WORD
	CLRL	(R9)+			;CLEAR IT AND SET UP R9 AS POINTER
	ADDL3	#INT$K_BUFWRN,R9,W^MAC$GL_INTWRNPT ;SET UP WARNING LIMIT
	POPR	#^M<R0,R1>		;RESTORE REGISTERS
	BBCC	#FLG$V_EXPOPT,(R11),.+1	;DO NOT ALLOW EXPRESSION OPT.
	RSB				;ALL DONE
20$:	BRW	MAC$ERR_NOMEM		;REPORT NO MEMORY TODAY AND QUIT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UPDATES THE BYTE COUNT IN THE CURRENT FRAME OF
;	THE INT. BUFFER.
;
;--

MAC$FIXFRAME::
	MOVL	W^MAC$GL_INTFRMPT,R0	;POINT TO THE CURRENT BLOCK
	SUBL3	R0,R9,R1		;FIGURE # BYTES USED IN IT
	SUBL3	#12,R1,8(R0)		;DON'T COUNT THE OVERHEAD BYTES
					; AND STORE COUNT IN OVH COUNT WORD
	ADDL2	8(R0),W^MAC$GL_INTPAGRQ	;UPDATE COUNT OF BYTES USED
	RSB

	.END
