	.TITLE	MAC$MAIN ENTRY POINT TO VAX-11 MACRO
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 25-AUG-78
;
; MODIFIED BY:
;
;	V02-048		BLS0143		Benn Schreiber		 6-Feb-1982
;		Change MOVZBL to MOVZWL due to nam$c_maxrss increase.
;
;	V02-047		BLS0057		Benn Schreiber		13-Jun-1981
;		Corrrect addressing modes to general
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS CONDITION VALUES
	$CLIDEF				;DEFINE CLI OFFSETS (CLI$A_UTILSERV)
	$MAC_GENVALDEF			;DEFINE COMMONLY USED SYMBOLS IN MACRO
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_INTCODDEF			;DEFINE INT. FILE OPCODES
	$MAC_CTLFLGDEF			;DEFINE FLAGS IN MAC$GL_FLAGS
	$MAC_MLFDEF			; Define MLF offsets

	.SBTTL	VAX-11 MACRO ASSEMBLER ENTRY POINT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THE ASSEMBLER IS ENTERED AT 'MAC$MACRO_ENTRY'.  THIS ROUTINE
;	SETS UP THE CLI CALLBACK ADDRESS, AND THEN PERFORMS
;	THE FOLLOWING ACTIONS:
;
;	1) RESET GLOBAL STORAGE
;	2) SET UP STORAGE FOR PASS1
;	3) GET A COMMAND AND VALIDATE
;	4) PERFORM PASS 1
;	5) INITIALIZE STORAGE FOR PASS 2
;	6) PERFORM PASS 2
;	7) CLOSE FILES AND RETURN TO IMAGE ACTIVATOR
;
; CALLING SEQUENCE:
;
;	CALLS	#1,MAC$MACRO_ENTRY
;
; INPUT PARAMETERS:
;
;	CLI$A_UTILSERV(AP)	CLI CALL BACK ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



	.PSECT	MAC$RO_CODE_COM,NOWRT,GBL,LONG

	.ENTRY	MAC$MACRO_ENTRY,^M<>	;MACRO-32 ENTRY POINT

	MOVL	SP,W^MAC$GL_INI_SP	;SAVE INITIAL SP FOR ERROR RECOVERY
	MOVL	AP,W^MAC$GL_INI_AP	;SAVE INITIAL AP FOR ERROR RECOVERY
	MOVL	FP,W^MAC$GL_INI_FP	;SAVE INITIAL FP FOR ERROR RECOVERY
	MOVAB	W^MAC$GL_FLAGS,R11	;POINT R11 TO THE FLAGS WORD
	CLRQ	(R11)			;CLEAR ALL FLAGS
	MOVL	CLI$A_UTILSERV(AP),-	;GET CLI CALL BACK ADDRESS
			W^MAC$GL_CLIADDR ; INTO A KNOWN LOCATION
GET_CMD:
	PUSHAB	W^MAC$GQ_RNT_TOT	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;BEGIN TIMING WHOLE ASSEMBLER RUN
	PUSHAB	W^MAC$GQ_RNT_INI	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;BEGIN TIMING INITIALIZATION
	$CREATE	FAB=W^MAC$TERM_FAB,-	;CREATE TERMINAL OUTPUT CHANNEL
		ERR=W^MAC$ERR_OPN_OUT
	BLBC	R0,MAC$LAST_CHANCE	;BRANCH IF ERROR
	$CONNECT RAB=W^MAC$TERM_RAB,-	;CONNECT THE RECORD STREAM
		ERR=W^MAC$ERR_OPN_OUT
	BLBC	R0,MAC$LAST_CHANCE	;BRANCH IF ERROR
;
; GET A COMMAND AND PROCESS IT
;
10$:
	MOVL	SP,W^MAC$GL_SAVE_SP	;SAVE STACK POINTER FOR ERROR RECOVERY
	BSBW	MAC$SETUP		;SET UP TO PROCESS A COMMAND
	PUSHAB	W^MAC$GQ_RNT_INI	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING INITIALIZATION
	BSBW	MAC$GETCMD		;PARSE A COMMAND LINE
	BSBW	MAC$INITP1		;INITIALIZE FOR PASS 1
	BSBW	MAC$PASS1		;PERFORM PASS 1 ON THE INPUT
	BSBW	MAC$INITP2		;INITIALIZE FOR PASS 2
	BSBW	MAC$PASS2_DRIVR		;PERFORM PASS 2
	BSBW	MAC$CLOSE_FILES		;CLOSE OUTPUT FILES
	BRB	MACRO_EXIT		;GO EXIT

MAC$LAST_CHANCE::
	MOVAB	W^MAC$GL_FLAGS,R11	;RESET R11 TO POINT TO FLAGS
					;(MAY HAVE BEEN WIPED)
	BSBW	MAC$CLS_DEL_OBJ		;DELETE OBJECT FILE IF IT EXISTS
	BSBW	MAC$CLOSE_FILES		;CLOSE THE REST OF THE FILES
	MOVL	W^MAC$GL_INI_SP,SP	;RESET SP
	MOVL	W^MAC$GL_INI_AP,AP	;AND AP
	MOVL	W^MAC$GL_INI_FP,FP	;AND FP
MACRO_EXIT:
	$DISCONNECT RAB=W^MAC$TERM_RAB	;DISCONNECT TERMINAL I/O
	$CLOSE 	FAB=W^MAC$TERM_FAB	;AND CLOSE THE FILE
	BBS	#FLG$V_MOREINP,W^MAC$GL_FLAGS,20$ ;BRANCH IF MORE INPUT FILES
	MOVL	W^MAC$GL_STATUS,R0	;GET THE FINAL STATUS
	BBCS	#STS$V_INHIB_MSG,R0,.+1	;DO NOT REPRINT THE ERROR MESSAGE
	$EXIT_S	R0			;EXIT WITH CODE IN R0
20$:	CLRL	@W^MAC$GL_INTQUE+4	;ZERO LINK IN LAST INTERMEDIATE BUFFER
	MOVAB	W^MAC$INP_NAM_BUF,-	;RESET RELATED FILE NAME BLOCK ADDRESS
		W^MAC$INPUT_RLFNM+NAM$L_RSA
	BSBW	MAC_DEAL_MEM		;DEALLOCATE DYNAMIC MEMORY STRUCTURES
	BRW	GET_CMD			;GO GET THE NEXT INPUT FILE

	.SBTTL	SETUP GLOBAL STORAGE TO PROCESS A COMMAND

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE INITIALIZES GLOBAL STORAGE IN PREPARATION
;	FOR PROCESSING A COMMAND LINE.
;
;--

MAC$SETUP:
	MOVC5	#0,(SP),#0,#MAC$GK_IMP_SIZ,W^MAC$GL_IMP_BEG ;CLEAR
					 ;IMPURE STORAGE
	MOVC5	#0,(SP),#0,#<HASHSZ+1>*4,- ;ZERO THE USER SYMBOL HASH TABLE
			W^MAC$AL_USYHSHTB
	MOVC5	#0,(SP),#0,#<HASHSZ+1>*4,- ;ZERO THE USER MACRO HASH TABLE
			W^MAC$AL_UMCHSHTB
;
; Translate logical name SYS$LP_LINES to get lines/page value.
;
	CALLS	#0,G^LIB$LP_LINES	; Get number of lines
	SUBL3	#9,R0,W^MAC$GL_LN_PAGE	; Set size allowing for 3 line top
					; margin, 3 line bottom margin and
					; 3 lines for header
;
; INITIALIZE LISTING HEADER BUFFER
;
	MOVC5	#0,(SP),#^A/ /,#MAC$K_HD_SIZE,- ;SET BUFFER TO SPACES
			W^MAC$AB_HD_TITLE
	MOVC5	#0,(SP),#^A/ /,#MAC$K_SBT_SIZ,- ;SET SUBTITLE BUFFER TO SPACES
			W^MAC$AB_SBT_IDNT
	MOVAB	W^MAC$AB_VERSION,R0	; Get address of version string
	MOVZBL	(R0)+,R1		;GET LENGTH OF VERSION STRING
	MOVC3	R1,(R0),W^MAC$AB_HD_VERSN ;COPY VERSION INTO BUFFER
	MOVAB	W^MAC$AB_DEF_TITL,R0	; Point to default title
	MOVZBL	(R0)+,R1		;GET LENGTH OF DEFAULT TITLE
	MOVC3	R1,(R0),W^MAC$AB_HD_TITLE ;SET AS DEFAULT HD_TITLE
	$ASCTIM_S TIMBUF=W^MAC$AL_ATIM_DSC ; Set time into buffer
	MOVAB	W^MAC$AB_HD_PAGE,R0	;POINT TO WHERE PAGE GOES
	MOVQ	#^A/Page   0/,(R0)+	; Store "Page   0"
	BISL2	#FLG$M_EVALEXPR,(R11)	;SET EVALUATE EXPRESSION
	MOVL	#1,W^MAC$GL_LSB		;START IN LSB 1
	CVTBL	#-1,W^MAC$GL_LIST_IT	;ASSUME LISTING
	MOVW	#30000.,W^MAC$GL_CRSYM	;START CREATED SYMBOLS AT 30000.
	MOVB	#RDX$V_DECIMAL,-	;SET RADIX TO DECIMAL
			W^MAC$GB_RDXNDX
	MOVAB	W^MAC$GL_INTQUE,R0	;INIT THE INT. FILE QUEUE
	MOVL	R0,(R0)			;...
	MOVAL	(R0)+,(R0)		;...
	MOVAB	W^MAC$GL_INPQUE,R0	;INIT THE INPUT FILE QUEUE
	MOVL	R0,(R0)			;...
	MOVAL	(R0)+,(R0)		;...
	MOVAB	W^MAC$GL_ERR_LIST,R0	;INIT THE ERROR LIST QUEUE
	MOVL	R0,(R0)			;...
	MOVAL	(R0)+,(R0)		;...
	MOVAB	W^MAC$GL_FREE_LST,R0	;INIT THE FREE PAGES LIST
	MOVL	R0,(R0)			;...
	MOVAL	(R0)+,(R0)		;...
	MOVAB	W^PSECT$BLANK,R0	;POINT TO THE BLANK PSECT
	MOVL	R0,W^MAC$GL_PSECTPTR	;START POINTER IN DEFAULT PSECT
	CLRL	PSC$L_CURLOC(R0)	;START AT 0
	CLRL	PSC$L_MAXLGTH(R0)	;...
	MOVAB	W^MAC$GL_SYM_PAGL,R0	;INIT THE SYMBOL PAGES QUEUE
	MOVL	R0,(R0)			;...
	MOVAL	(R0)+,(R0)		;...
	MOVZBL	#1,W^MAC$GL_PSECT	;PSECT 1
	MOVZBL	#1,W^MAC$GL_PSC_MAX	;START WITH 1
	BRW	MAC$SYSLIB_SET		;SET UP SYSTEM MACRO LIBRARY AND RETURN

	.SBTTL	DEALLOCATE DYNAMIC MEMORY STRUCTURES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED IF THERE ARE MULTIPLE ASSEMBLIES TO
;	DEALLOCATE ALL DYNAMIC MEMORY STRUCTURES.
;
;	(REGISTERS NOT SAVED--IN BETWEEN ASSEMBLIES)
;--

MAC_DEAL_MEM:
;
; DEALLOCATE SYMBOL PAGES
;
10$:	REMQUE	@W^MAC$GL_SYM_PAGL,R0	;GET NEXT CHUNK OF PAGES TO DEALLOCATE
	BVS	20$			;IF V-SET THEN ALL DONE
	MOVZWL	#<512*STB$K_PG_MISS>,R1	;GET SIZE OF CHUNK
	BSBB	DEAL_MEMORY		;DEALLOCATE THE MEMORY
	BRB	10$			;FREE ALL SYMBOL PAGES
;
; NOW DEALLOCATE THE INTERMEDIATE FILE
;
20$:	MOVL	W^MAC$GL_INTQUE,R2	;POINT AT THE INTERMEDIATE FILE
30$:	MOVL	R2,R0			;ANY MORE BLOCKS?
	BEQL	40$			;IF EQL NO
	MOVL	(R2),R2			;YES--LINK TO NEXT
	MOVZWL	#INT$K_BUFSIZ,R1	;GET SIZE OF THE BLOCK
	BSBB	DEAL_MEMORY		;DEALLOCTE THE BLOCK
	BRB	30$			;DEALLOCATE WHOLE INTER. FILE
;
; DEALLOCATE ANY MACROS DEFINED
;
40$:	MOVAB	W^MAC$AL_UMCHSHTB,R9	;POINT TO MACRO HASH TABLE
	MOVZWL	#<HASHSZ+1>,R8		;COUNT OF THE ENTRIES
50$:	MOVL	(R9)+,R7		;GET NEXT BUCKET POINTER
	BEQL	70$			;IF EQL NONE
60$:	MOVL	R7,R6			;SET POINTER INTO R6
	BEQL	70$			;IF EQL NO MORE
	MOVL	(R6),R7			;GET POINTER TO NEXT MNB OR 0
	BSBW	MAC$DEL_MAC_DEF		;DELETE THE MACRO DEF.
	BRB	60$			;CONTINUE DELETING ON THIS BUCKET
70$:	SOBGTR	R8,50$			;DELETE ALL MACRO DEFS.
;
; DELETE THE FREE PAGES LIST
;
80$:	REMQUE	@W^MAC$GL_FREE_LST,R0	;GET A PAGE
	BVS	90$			;IF V-SET NO MORE
	MOVZWL	W^MAC$GK_1_PG_SIZ,R1	;GET SIZE OF PAGE
	BSBB	DEAL_MEMORY		;DEALLOCATE THE PAGE
	BRB	80$			;CONTINUE
;
; DEALLOCATE THE MACRO LIBRARY QUEUE AND THE INPUT FILE QUEUE
;
90$:	REMQUE	@W^MAC$GL_MLB_QUE,R0	;GET NEXT MLB TO RELEASE
	BVS	100$			;IF VS NO MORE
	CMPL	R0,#MAC$SYSLIB_MLF	;IS THIS SYSLIB?
	BEQL	100$			;IF EQL YES--WE ARE DONE
	MOVZWL	#MLF$K_BLKSIZ,R1	;FIGURE BLOCK SIZE
	BSBB	DEAL_MEMORY		;DEALLOCATE IT
	BRB	90$
100$:	REMQUE	@W^MAC$GL_INPQUE,R0	;GET NEXT INPUT FILE BLOCK
	BVS	110$			;IF V-SET NO MORE
	MOVZWL	W^MAC$GK_1_PG_SIZ,R1	;BLOCK IS ONE PAGE
	BSBB	DEAL_MEMORY		;DEALLOCATE IT
	BRB	100$			;DO THEM ALL
110$:	RSB

;++
; ROUTINE TO DEALLOCATE MEMORY.
;
;	R0 - ADDRESS OF BLOCK
;	R1 - SIZE
;--

DEAL_MEMORY:
	PUSHL	R0			;STACK BLOCK ADDRESS
	MOVL	SP,R0			;REMEMBER ITS ADDRESS
	PUSHL	R1			;STACK BLOCK SIZE
	MOVL	SP,R1			;REMEMBER ITS ADDRESS
	PUSHL	R0			;STACK ADDRESS OF ADDRESS
	PUSHL	R1			;AND THE SIZE
	CALLS	#2,G^LIB$FREE_VM	;FREE THE MEMEORY
	ADDL2	#2*4,SP			;CLEAR THE STACK
	RSB

	.SBTTL	INITIALIZE FOR ONE PASS THROUGH THE SOURCE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES INITIALIZE THE STORAGE FOR ONE PASS THROUGH
;	THE SOURCE.
;
; CALLING SEQUENCE:
;
;	JSB	MAC$INITP1
; OR	JSB	MAC$INITP2
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	FOR MAC$INITP1 IT IS EXPECTED THAT MAC$GL_FLAGS HAS BEEN
;	ZEROED AND THAT R11 POINTS TO THE FLAGS.
;
;--

MAC$INITP2:				;ENTRY POINT FOR PASS 2 INITIALIZATION
	MOVL	W^MAC$GL_SYMPGPTR,R0	;GET POINTER TO LAST PAGES ALLOCATED
	BEQL	2$			;IF EQL NONE ALLOCATED
	INSQUE	(R0),W^MAC$GL_SYM_PAGL	;LINK LAST PAGES INTO SYMBOL PAGE QUEUE
2$:	MOVAB	W^MAC$AL_USYHSHTB,R9	;POINT TO USER SYMBOL HASH TABLE
	MOVZWL	#HASHSZ+1,R8		;LOAD UP SIZE OF TABLE
	BSBW	MAC$SORT_TABLE		;SORT THE SYMBOL TABLE
	PUSHAB	W^MAC$GQ_RNT_P2		;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;START TIMING PASS 2
	BBCS	#FLG$V_P2,(R11),10$	;FLAG PASS 2 IS UP
10$:	MOVC5	#0,(SP),#^A/ /,#MAC$K_SBT_SIZ,- ;BLANK FILL SUBTITLE BUFFER
			W^MAC$AB_SBT_IDNT
	MOVAB	W^MAC$AB_IDENT,R6	;POINT TO IDENT STORAGE
	MOVZBL	(R6)+,R7		;GET LENGTH OF IDENT
	BEQL	INIT_0			;IF EQL NO IDENT
	MOVC3	R7,(R6),W^MAC$AB_SBT_IDNT ;COPY IDENT INTO SUBTITLE BUFFER
20$:	LOCC	#TAB,R7,W^MAC$AB_SBT_IDNT ;FIND ANY TABS?
	BEQL	INIT_0			;IF EQL NO
	MOVB	#^A/ /,(R1)		;YES--CHANGE TO SPACE
	BRB	20$			;CHANGE ALL THE TABS

MAC$INITP1:				;REF LABEL
	PUSHAB	W^MAC$GQ_RNT_P1		;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;START TIMING PASS 1
	BSBW	MAC$SETFRAME		;GET BLOCK OF MEMORY AND SETUP
					;TO STORE IN INT. BUFFER (SETUP R9)

INIT_0:
	CLRL	W^MAC$GL_LIST_LVL	;START LISTING AT LEVEL 0
	CLRL	W^MAC$GL_LINE_CNT	;ZERO PAGE LINE COUNTER
	CLRL	W^MAC$GL_LPTPAG		;FIRST LISTING PAGE NUMBER
	MOVZBL	#1,W^MAC$GL_SRCPAG	;FIRST SOURCE PAGE NUMBER
	CLRL	W^MAC$GL_LINENUM	;FIRST LINE
	CLRL	W^MAC$GL_LINBAS		;INIT LINE BASE ALSO
	BISL2	#FLG$M_CONT,(R11)	;INDICATE CONTINUATION OK
	BBCC	#FLG$V_NEWPND,(R11),10$	;NEW PAGE NOT NEEDED
10$:	MOVAB	W^MAC$GL_PRMINBL,R0	;POINT TO PRIMARY INPUT BLOCK
	MOVL	R0,R1			;COPY IT
	MOVL	R1,W^MAC$GL_INPUTP	;SET UP INPUT POINTER
	MOVL	R0,(R0)+		;LINK IS TO ITSELF
	CLRL	(R0)+			;THERE IS NO NEXT LINE
	MOVAB	W^MAC$GETLIN,(R0)+	;SET ROUTINE TO GET NEXT LINE
	CLRQ	(R0)+			;CLEAR IFLVL AND IFVAL
	CLRL	(R0)+			;CLEAR PAGE POINTER
	CLRB	(R0)+			;CLEAR ARG COUNT
	MOVL	W^MAC$GL_INPQUE,R0	;GET PTR TO FIRST FDB IN INP. QUEUE
	BRW	MAC$OPEN_INPUT		;OPNE FILE AND RETURN

	.SBTTL	PERFORM PASS 1

;++
;
;	PASS 1
;
;--

MAC$PASS1:
	BBCC	#FLG$V_P2,(R11),.+1	;THIS IS PASS 1
;
; COPY THE INITIAL SETTINGS OF THE ENABLE/DISABLE AND LIST/NLIST
; FLAGS TO THE TOKEN BYTE IN EACH OF THE SYMBOL BLOCKS SO THEY
; CAN BE RESET AT THE START OF PASS 2.
;
	MOVAB	W^LST$G_DIRLIST,R5	;POINT TO DIRECTIVE LIST
10$:	MOVB	SYM$L_VAL(R5),SYM$B_TOKEN(R5) ;SAVE THE INITIAL SETTING
	MOVL	SYM$L_LINK(R5),R5	; Link to next
	BNEQ	10$
	MOVAB	W^ENB$G_OPTIONS,R5	;POINT TO ENABLE OPTIONS
20$:	MOVB	SYM$L_VAL(R5),SYM$B_TOKEN(R5) ;SAVE INITIAL SETTING
	MOVL	SYM$L_LINK(R5),R5	; Link to next
	BNEQ	20$			;LOOP FOR ALL
	$INTOUT_LW INT$_NEWP,#PSECT$MAIN ;ABSOLUTE PSECT
	$INTOUT_LW INT$_NEWP,#PSECT$BLANK ;BLANK PSECT
	$INTOUT_LW INT$_PSECT,#PSECT$BLANK ;START IN BLANK PSECT
	MOVL	SP,W^MAC$GL_SAVE_SP	;SAVE STACK POINTER
	BSBW	MAC$PARSE		;CALL PASS 1 DRIVER
;
; PASS 1 IS COMPLETED
;
;
; THE ROUTINE MAC$PARSE DOES NOT RETURN.  RATHER, WHEN THE END
; STATEMENT IS SEEN (OR FORCED), CONTROL WILL COME TO MAC$PASS1_END
; FOR A NORMAL END OF PASS 1 OR TO MAC$ABORT_PASS1 IF IT IS
; ABORTED.
;
MAC$ABORT_PASS1::
	BSBW	MAC$CLS_DEL_OBJ		;CLOSE AND DELETE OBJECT FILE
MAC$PASS1_END::
	MOVL	W^MAC$GL_SAVE_SP,SP	;RESTORE STACK POINTER
	$INTOUT_X INT$_END		;END OF INTERMEDIATE FILE
	BSBW	MAC$FIXFRAME		;FIX THE COUNT WORD IN LAST BUFFER
					; TO VIRTUAL MEMORY
	CLRL	@W^MAC$GL_INTQUE+4	;ZERO LINK IN LAST BUFFER
					; SO THAT PASS 2 CAN DETECT ERROR
	PUSHAB	W^MAC$GT_SCB		; Suplly SUM control block address
	CALLS	#1,G^SUM$CLOSE		; Close update files
	$DISCONNECT RAB=W^MAC$INPUT_RAB	;DISCONNECT THE RECORD STREAM
	MOVL	W^MAC$GL_CURINFDB,R0	;POINT TO CURRENT INPUT FDB
	$CLOSE	FAB=8(R0)		;CLOSE THE INPUT FILE
	BSBW	MAC$CLOSE_LIB		;CLOSE MACRO LIBRARY FILES
	PUSHAB	W^MAC$GQ_RNT_P1		;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING PASS 1
	RSB				;PASS 1 IS COMPLETED

	.END	MAC$MACRO_ENTRY
