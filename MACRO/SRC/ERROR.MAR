	.TITLE	MAC$ERROR	ERROR HANDLER FOR MACRO-32
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 26-SEP-1978
;
; MODIFIED BY:
;
;	V03.00	MTR0004		Mike Rhodes	15-Mar-1982
;		Modify routine MAC$PUT_MSG to flag any "external errors"
;		that is non-assembly errors issued by facilities such as
;		RMS, LBR, SUM, etc., in the flags word bits FLG$V_EXTERR
;		and FLG$V_EXTWRN.  Fixes SPR #11-41651(A).
;
;	V01.04	RN0011		R. Newland	11-Sep-1979
;		New librarian support
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$FABDEF				;DEFINE FAB OFFSETS
	$SHRDEF				;DEFINE SHARED MESSAGES
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$STSDEF				;DEFINE STATUS WORD BITS AND STUFF
	$NAMDEF				;DEFINE NAM OFFSETS
	$RABDEF				;DEFINE RAB OFFSETS
	$MAC_MLFDEF			; Define MLF offsets
	$RMSDEF				; Define RMS return codes

;
; OWN STORAGE
;
	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG

MAC$MACRO_NAME::			;MY NAME
	.LONG	20$-10$,10$
10$:	.ASCII	\MACRO\
20$:

	ERR_MASK=^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CLI_SUBSYS=^X30000		;***TEMP
	SRM$L_SAVE_PC=16		;***TEMP--SAVED PC IN CALL FRAME

	.PSECT	MAC$RO_CODE_P4,NOWRT,GBL,LONG

	.SBTTL	ERROR ACTION ROUTINES

;++
; Functional description:
;
;	This routine is called to report librarian open errors
;
; Inputs:
;	4(AP) = Address of MLF
;	R0    = LBR$ status code
;
;--
;
MAC$ERR_LBROPEN::
	.WORD	ERR_MASK
	EXTZV	#STS$V_FAC_NO,#STS$S_FAC_NO,R0,R1 ; Get facility number
	CMPL	R1,#<RMS$_NORMAL@-16>	; Is it an RMS error?
	BEQL	10$			; Yes if EQL
	PUSHL	#0			; No FAO arguments
	PUSHL	R0			; Status code
	PUSHL	#2			; Length of message packet
	BRW	MAC$PUT_MSG		; Output message and return
10$:
	MOVL	4(AP),R1		; Get MLF address
	PUSHL	R0			; RMS error code
	PUSHL	#0
	PUSHAB	MLF$Q_FNAMDS(R1)	; File name descriptor
	PUSHL	#1			; Number of FAO arguments
	PUSHL	#<SHR$_OPENIN!CLI_SUBSYS!STS$K_ERROR> ; Error code
	PUSHL	#5			; Length of message packet
	BRW	MAC$PUT_MSG		; Output message and return



;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE REPORTS AN ERROR.  R0 CONTAINS THE ADDRESS OF
;	A STRING DESCRIPTOR TO OUTPUT USING SHR$_TEXT.
;
;--

MAC$ERR_TEXT::
	.WORD	ERR_MASK
	PUSHL	R0			;STACK DESCRIPTOR ADDRESS
	PUSHL	#1			;ONE FAO ARGUMENT
	PUSHL	#<SHR$_TEXT!CLI_SUBSYS!STS$K_ERROR> ;MESSAGE CODE
	PUSHL	#3			;THREE ARGS IN PACKET
	BRW	MAC$PUT_MSG		;PUT MESSAGE AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THERE IS NO MEMORY AVAILABLE.
;	THE ERROR IS REPORTED.  IF PASS 1 IS IN PROGRESS, A JUMP
;	TO MAC$ABORT_PASS1 IS EXECUTED.  IF PASS 2 IS IN PROGRESS,
;	?
;
;--

MAC$ERR_NOMEM::
	CALLS	#0,W^MAC$ERR_NOMEM_0	;SO WE CAN RETURN CORRECTLY
	BRW	MAC$LAST_CHANCE		;PASS 2--NOTHING TO DO BUT DIE

MAC$ERR_NOMEM_0::
	.WORD	ERR_MASK		;ENTRY MASK
	PUSHL	#0			;NO FAO ARGS
	PUSHL	R0			;STACK ERROR CODE
	PUSHL	#2			;TOTAL SIZE OF PACKET
	BRW	MAC$PUT_MSG		;OUTPUT MESSAGE AND RETURN


;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO REPORT A BAD KEYWORD VALUE ERROR.
;	THE KEYWORD IN ERROR IS IN MAC$AB_TMPSYM.
;
;--

MAC$ERR_KEY_WD::
	.WORD	ERR_MASK
	MOVAB	L^MAC$AB_TMPSYM,R0	;POINT TO THE KEYWORD IN ERROR
	PUSHAB	1(R0)			;STACK ITS ADDRESS
	MOVZBL	(R0),-(SP)		;STACK ITS LENGTH
	PUSHAQ	0(SP)			;STACK POINTER TO DESCRIPTOR
	PUSHL	#1			;NUMBER OF ARGUMENTS
	PUSHL	#<SHR$_BADVALUE!CLI_SUBSYS!STS$K_ERROR> ;STACK MESSAGE CODE
	PUSHL	#3			;TOTAL SIZE OF PACKET
	BRW	MAC$PUT_MSG		;OUTPUT ERROR AND RETURN TO CALLER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN AN INTERNAL ERROR IS DETECTED.
;	THE ERROR IS REPORTED, AND THE ASSEMBLY IS ABORTED.
;
;--

MAC$ERR_INTERN::
	.WORD	ERR_MASK		;
	PUSHL	SRM$L_SAVE_PC(FP)	;STACK ADDRESS OF CALLER'S RETURN
	PUSHL	#1			;NUMBER OF ARGUMENTS
	PUSHL	#<SHR$_BADLOGICPC!CLI_SUBSYS!STS$K_ERROR> ;ERROR CODE
	PUSHL	#3			;TOTAL SIZE OF PACKET
	BRW	MAC$PUT_MSG		;CALL PUTMSG AND RETURN


;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES ARE CALLED FOR INPUT AND OUTPUT ERRORS.
;
;--

MAC$ERR_FIND::
MAC$ERR_MODIFY::
MAC$ERR_CONNECT::
MAC$ERR_DISCON::
	.WORD	ERR_MASK
	BSBB	RABERR
	.LONG	SHR$_RMSERROR!CLI_SUBSYS!STS$K_ERROR

MAC$ERR_GET::
	.WORD	ERR_MASK		;ENTRY MASK
	BSBB	RABERR			;PROCESS ERROR ON A RAB
	.LONG	SHR$_READERR!CLI_SUBSYS!STS$K_ERROR

MAC$ERR_PUT::
	.WORD	ERR_MASK
	BSBB	RABERR			;PROCESS RAB ERROR
	.LONG	SHR$_WRITEERR!CLI_SUBSYS!STS$K_ERROR

RABERR:	MOVL	4(AP),R1		;GET THE RAB ADDRESS
	MOVL	RAB$L_FAB(R1),R0	;GET THE FAB ADDRESS
	MOVQ	RAB$L_STS(R1),FAB$L_STS(R0) ;PUT ERROR IN COMMON PLACE
	BRB	FILERR			;PROCESS ERROR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES ARE CALLED TO PROCESS ERRORS OPENING INPUT OR
;	OUTPUT FILES, AND ERRORS CLOSING OUTPUT FILES.
;
;--

MAC$ERR_OPN_INP::
	.WORD	ERR_MASK
	BSBB	FABERR			;PROCESS FAB ERROR
	.LONG	SHR$_OPENIN!CLI_SUBSYS!STS$K_ERROR

MAC$ERR_OPN_OUT::
	.WORD	ERR_MASK
	BSBB	FABERR			;PROCESS FAB ERROR
	.LONG	SHR$_OPENOUT!CLI_SUBSYS!STS$K_ERROR

MAC$ERR_CLS_INP::
	.WORD	ERR_MASK
	BSBB	FABERR
	.LONG	SHR$_CLOSEIN!CLI_SUBSYS!STS$K_ERROR

MAC$ERR_CLS_OUT::
	.WORD	ERR_MASK
	BSBB	FABERR
	.LONG	SHR$_CLOSEOUT!CLI_SUBSYS!STS$K_ERROR

FABERR:	MOVL	4(AP),R0		;GET THE FAB ADDRESS
FILERR:	MOVL	FAB$L_NAM(R0),R1	;GET NAME BLOCK ADDRESS
	MOVL	NAM$L_RSA(R1),R3	;SET RESULTANT STRING ADDRESS
	MOVZBL	NAM$B_RSL(R1),R2	;AND LENGTH
	BNEQ	10$			;IF NEQ RESULTANT NAME FORMED
	MOVL	NAM$L_ESA(R1),R3	;GET ADDRESS OF EXPANDED STRING
	MOVZBL	NAM$B_ESL(R1),R2	;AND ITS LENGTH
	BNEQ	10$			;IF NEQ EXPANDED STRING FORMED
	MOVL	FAB$L_FNA(R0),R3	;USE INPUT FILE NAME
	MOVZBL	FAB$B_FNS(R0),R2	;AND SIZE
	BNEQ	10$			;IF NEQ GO USE IT
	MOVL	FAB$L_DNA(R0),R3	;TRY THE DEFAULT NAME NOW
	MOVZBL	FAB$B_DNS(R0),R2	;AND SIZE
10$:	MOVL	@(SP)+,R1		;GET THE ERROR CODE
	PUSHR	#^M<R2,R3>		;PUSH DESCRIPTOR FOR FILE NAME
	MOVQ	FAB$L_STS(R0),-(SP)	;PUSH RMS ERROR CODES
	CMPW	#<RMS$_EOF&^XFFFF>,(SP)	;WAS ERROR END OF FILE?
	BEQL	ERROR_EXIT		;IF EQL YES--NO ERROR NEEDED
	PUSHAQ	8(SP)			;ADDRESS OF NAME DESCRIPTOR
	PUSHL	#1			;NUMBER OF ARGUMENTS
	PUSHL	R1			;MESSAGE CODE
	PUSHL	#5			;TOTAL SIZE OF MESSAGE PACKET
;
; NOW SETUP TO CALL $PUTMSG TO OUTPUT THE MESSAGE
;
MAC$PUT_MSG::
	MOVL	4(SP),L^MAC$GL_STATUS	;SAVE MOST CURRENT STATUS
	MOVAB	MAC$GL_FLAGS,R11	;POINT TO THE GLOBAL ASSEM FLAGS
	BICL3	#^CSTS$M_SEVERITY,-	;COPY SEVERITY BITS FROM STATUS
		G^MAC$GL_STATUS,R2	;IS SEVERITY = WARNING?
	BEQL	10$			;BRANCH IF YES.
	CMPL	R2,#STS$K_INFO		;NO -- IS IT INFORMATION?
	BEQL	20$			;YES -- INFO DOESN'T COUNT
	BBCS	#FLG$V_EXTERR,(R11),20$	;ITS AN ERROR, SO FLAG IT.
	BRB	20$			;WATCH OUT FOR SUCCESSIVE ERRORS.
10$:	BBCS	#FLG$V_EXTWRN,(R11),20$	;ITS A WARNING, FLAG IT.
20$:	PUSHAQ	MAC$MACRO_NAME		;PUSH ADDRESS OF FACILITY NAME
	CLRL	-(SP)			;ZERO ADDRESS OF ACTION ROUTINE
	PUSHAB	8(SP)			;PUSH ADDRESS OF MESSAGE BUFFER
	CALLS	#3,G^SYS$PUTMSG		;PRINT THE MESSAGE
ERROR_EXIT:
	RET

	.END
