	.TITLE	MAC$MACLIN	GET MACRO LINE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V03.00	MTR0007		Mike Rhodes	15-Mar-1982
;		Modify the lexical function routines for %EXTARCT and %LOCATE.
;		The routine MACLIN_LXEXT now treats the starting position and
;		length values as unsigned integers.  MACLIN_LXLOC now, will not
;		count the text link byte which caused some problems previously.
;		Both modifications fix SPR #11-43353.
;
;	V02.12	CNH0044		Chris Hume	20-Nov-1980
;		Fixed handling of macro expansion block continuation linkages.
;
;	V01.11	RN0026		R. Newland	13-Jan-1980
;		Don't put unecessary CHKL's into intermediate code when
;		not listing macro expansions.
;
;	V01.10	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.09	RN0010		R. Newland	5-Sep-1979
;		Mulitpage MXB blocks
;
;	V01.08	RN0005		R. Newland	18-Aug-1978
;		Variable symbol storage and remove .ALIGN LONG statements
;
;
;	V01.07	RN0004		R. Newland	22-Jun-1979
;		Fix truncation error
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_MNBDEF			;DEFINE MNB OFFSETS
	$MAC_MTXDEF			;DEFINE MACRO SPECIAL OPERATORS
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_INPBLKDEF			;DEFINE INPUT BLOCK OFFSETS
	$MAC_INTCODDEF			;DEFINE INT. BUFFER CODES
	$MACMSGDEF			; Define message codes

;
; LOCAL DATA
;

	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG

MACLIN_MTXT_TAB:			;TABLE OF SPECIAL MACRO OPERATOR BYTES
	.BYTE	MTX$_TXTLNK,-		;TEXT LINK TO NEW PAGE
		MTX$_ARGMRK,-		;DUMMY ARGUMENT MARKER
		MTX$_LXLEN,-		;LEXICAL LENGTH FUNCTION
		MTX$_LXLOC,-		;LEXICAL LOCATE FUNCTION
		MTX$_LXEXT		;LEXICAL EXTRACT FUNCTION
LEN$K_MTXTAB	=	.-MACLIN_MTXT_TAB ;LENGTH OF TABLE

	.ALIGN	LONG
MACLIN_DISP_TAB:			;DISPATCH TABLE FOR SPECIAL OPERATORS
	.ADDRESS MACLIN_TXTLNK,-	;TEXT LINK
		MACLIN_ARGMRK,-		;ARGUMENT MARKER
		MACLIN_LXLEN,-		;LENGTH FUNCTION
		MACLIN_LXLOC,-		;LOCATE
		MACLIN_LXEXT		;EXTRACT

	.PSECT	MAC$RO_CODE_MAC,NOWRT,GBL,LONG

	.SBTTL	MAC$GET_IRC_LIN	GET NEXT LINE OF .IRPC

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO GET THE NEXT TEXT LINE WHILE
;	EXPANDING AN INDEFINITE REPEAT CHARACTER "MACRO".  IF
;	THE END OF THE TEXT IS NOT THE NEXT LINE, MAC$GET_IRC_LIN
;	WILL RETURN THE NEXT LINE.  IF IT IS THE END, AND THERE
;	ARE STILL MORE CHARACTERS IN THE INDEFINTE REPEAT STRING,
;	THE REPEAT WILL BE RESTARTED WITH THE NEXT CHARACTER.  IF
;	THERE ARE NO MORE CHARACTERS, THE INPUT CONTEXT IS POPPED,
;	TERMINATING THE INDEFINITE REPEAT.
;
;--

MAC$GET_IRC_LIN::
	MOVL	W^MAC$GL_INPUTP,R0	;POINT TO INPUT CONTEXT BLOCK
10$:	MOVL	INP$L_NXTL(R0),R1	;GET NEXT LINE POINTER
	BSBB	MAC_RPT_END_CHK		;SEE IF END OF REPEAT TEXT
					;  GO TO MAC$GET_MAC_LIN IF
					;  NOT END. RETURN ONLY IF END
	MOVL	INP$K_IRPSIZ+3(R0),R1	; Get pointer into IRPC string
	MOVZBL	(R1)+,-(SP)		;GET NEXT CHARACTER
	MOVL	R1,INP$K_IRPSIZ+3(R0)	; Set new pointer
	POPL	R1			;GET CHARACTER BACK
	MOVB	R1,INP$K_IRPSIZ+2(R0)	; Set new argument
	BNEQ	40$			;IF NEQ THERE IS MORE TO DO
	BRW	MAC$POP_INPUT		;NO--THIS IS THE END--POP INPUT CONTEXT
40$:	MOVL	INP$L_RPTCNT(R0),INP$L_NXTL(R0) ;RESET NEXT LINE POINTER
	BRB	10$			;REPEAT THE INDEFINITE REPEAT
					;WITH THE NEW CHARACTER
50$:	BRW	MAC$GET_MAC_LIN		;BRANCH AID TO GET TO FAR PLACES!

	.SBTTL	MAC$GET_IRP_LIN	GET NEXT LINE OF .IRP

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO GET THE NEXT TEXT LINE WHILE IN
;	AN INDEFINITE REPEAT EXPANSION.  IF THE END OF THE TEXT
;	IS NOT THE NEXT LINE, MAC$GET_MAC_LIN WILL RETURN THE
;	NEXT LINE.  IF IT IS THE END, AND THERE IS ANOTHER REAL
;	ARGUMENT, THE REPEAT IS RESTARTED WITH THE NEW REAL
;	ARGUMENT.   IF THERE ARE NO MORE REAL ARGUMENTS, THE
;	INPUT CONTEXT IS POPPED, TERMINATING THE INDEFINITE
;	REPEAT.
;
;--

MAC$GET_IRP_LIN::
	MOVL	W^MAC$GL_INPUTP,R0	;GET POINTER TO INPUT BLOCK
10$:	MOVL	INP$L_NXTL(R0),R1	;GET NEXT LINE POINTER
	BSBB	MAC_RPT_END_CHK		;SEE IF END OF REPEAT RANGE
					;  GO TO MAC$GET_MAC_LIN IF NOT
					;  RETURN ONLY IF END
	MOVAL	INP$K_IRPSIZ(R0),R1	; Point to real arg queue header
	REMQUE	@(R1),R1		;GET THE ADDR OF NEXT REAL ARG
	BVC	40$			;IF V-CLEAR THEN WE GOT AN ENTRY
	BRW	MAC$POP_INPUT		;NO MORE ARGS--POP INPUT CONTEXT
40$:	MOVAB	8(R1),INP$L_ARGS(R0)	;POINT TO ARG STRING IN INPUT BLOCK
	MOVL	INP$L_RPTCNT(R0),INP$L_NXTL(R0) ;RESET NEXT LINE POINTER
	BRB	10$			;PERFORM NEXT REPEAT

	.SBTTL	MAC$GET_RPT_LIN	GET NEXT LINE OF REPEAT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO GET THE NEXT TEXT LINE WHILE IN
;	A .REPT DIRECTIVE EXPANSION.  IF THE END OF THE TEXT IS
;	NOT THE NEXT LINE, MAC$GET_MAC_LIN WILL RETURN THE NEXT
;	LINE.  IF IT IS THE END, THE REPEAT COUNT IS DECREMENTED,
;	AND IF IT HAS GONE TO ZERO, THE INPUT CONTEXT IS POPPED,
;	THUS TERMINATING THE REPEAT.  IF IT HAS NOT GONE TO ZERO,
;	THE NEXT LINE POINTER IS RESET AND THE REPEAT BLOCK IS
;	EXPANDED AGAIN.
;
;--

MAC$GET_RPT_LIN::
	MOVL	W^MAC$GL_INPUTP,R0	;GET POINTER TO INPUT BLOCK
10$:	MOVL	INP$L_NXTL(R0),R1	;GET NEXT LINE POINTER
	BSBB	MAC_RPT_END_CHK		;SEE IF END OF REPEAT RANGE
					;  GO TO MAC$GET_MAC_LIN IF NOT
					;  RETURN ONLY IF END
30$:	SOBGEQ	INP$L_RPTCNT(R0),40$	;DEC. REPEAT COUNT AND GO IF NOT DONE
	BRW	MAC$POP_INPUT		;DONE--POP INPUT CONTEXT
40$:	MOVAB	INP$K_BLKSIZ(R0),INP$L_NXTL(R0) ; Reset text pointer
	BRB	10$			;PERFORM NEXT REPEAT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PICKS UP THE LINE LENGTH AND DETERMINES IF
;	IT IS REALLY A LINE OR THE END OF TEXT MARKER.  IF IT IS
;	REALLY A LINE, THE RETURN ADDRESS IS POPPED AND WE DISPATCH
;	TO MAC$GET_MAC_LIN.  RETURN ONLY IF END OF TEXT.
;
; INPUTS:
;
;	R1	POINTER TO WORD CONTAINING BYTE COUNT
;	R0	POINTER TO INPUT CONTEXT BLOCK
;
; OUTPUTS:
;
;	RETURN IS POPPED AND BRANCH IS MADE TO MAC$GET_MAC_LIN UNLESS
;	LINE LENGTH IS -1 (END OF TEXT MARKER).  TEXT LINKS ARE HANDLED.
;
;--

MAC_RPT_END_CHK:
	CVTWL	(R1)+,R2		;GET LENGTH OF LINE
	BGEQ	10$			;IF GEQ CERTAINLY NOT END OF TEXT
	ADDW3	#1,R2,R3		;IS IT END OF TEXT (-1)?
	BEQL	20$			;IF EQL YES
	CMPW	R2,#MTX$_TXTLNK!^XFF00	;NO--IS IT A TEXT LINK?
	BNEQ	10$			;IF NEQ NO--TEXT LINE WITH
					;  SPECIAL OPERATORS
	MOVL	(R1)+,R1		;YES--GET POINTER TO NEXT PAGE
	ADDL2	#MXB$K_BLKSIZ,R1	; Skip header infomation
	BRB	MAC_RPT_END_CHK		;CONTINUE CHECKING
10$:	TSTL	(SP)+			;CLEAR RETURN FROM STACK
	BRB	MAC$GET_MAC_LIN		;AND GO RETURN NEXT TEXT LINE
20$:	RSB				;RETURN ONLY IF END OF TEXT

	.SBTTL	MAC$GET_MAC_LIN	EXPAND NEXT LINE OF CURRENT MACRO

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY MAC$GETCHR WHEN IT IS TIME FOR A
;	NEW LINE.  THE NEXT LINE OF THE MACRO IS EXPANDED INTO
;	MAC$AB_LINEBF.
;
;--

MAC$GET_MAC_LIN::
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R12> ;SAVE REGISTERS
	MOVL	W^MAC$GL_INPUTP,R12	;POINT TO CURRENT INPUT BLOCK
	MOVAB	W^MAC$AB_LINEBF,R6	;POINT TO THE LINE BUFFER
	MOVL	R6,W^MAC$GL_LINEPT	;RESET LINE POINTER
	MOVZWL	#INP$K_BUFSIZ,R5	;LOAD MAX CHARACTER COUNT
	MOVL	INP$L_NXTL(R12),R7	;GET POINTER TO NEXT MACRO LINE
10$:	CVTWL	(R7)+,R8		;GET LENGTH OF LINE
	BGTR	MACLIN_COPY_LIN		;IF GTR NOT SPECIAL LINE
	BEQL	30$			;IF EQL BLANK (NULL LINE)
	ADDW3	#1,R8,R0		;NEGATIVE--ARE WE DONE?
	BEQL	20$			;IF EQL YES--DO END OF MACRO PROCESSING
	CMPW	R8,#MTX$_TXTLNK!^XFF00	;NO--SPECIAL TEXT LINK?
	BNEQ	MACLIN_NEXT_CH0		;IF NEQ NO--IT IS LINE WITH SPECIAL OPERATORS
	MOVL	(R7)+,R7		;YES--GET LINK TO NEXT
	ADDL2	#MXB$K_BLKSIZ,R7	; Skip header information
	BRB	10$			;CONTINUE
20$:	BRW	MACLIN_END_TEXT		;ELSE END OF MACRO TEXT
30$:	BRW	MACLIN_LINE_END		;BRANCH AID
MACLIN_NEXT_CH0:
	BICL2	#^X<^C<7FFF>>,R8	;TRIM LINE LENGTH TO 15 BITS
;
; HERE TO GET NEXT CHARACTER AND DISPATCH TO PROCESS IT
;
MACLIN_NEXT_CHR:
	TSTL	R8			;DONE WITH LINE?
	BLEQ	30$			;IF LEQ YES
	DECL	R8			;COUNT NEXT BYTE
	MOVB	(R7)+,R10		;GET NEXT CHARACTER
	BGTR	10$			;BRANCH IF DEFINITLY NOT SPECIAL
	LOCC	R10,#LEN$K_MTXTAB,-	;SEE IF IT IS A SPECIAL OPERATOR
		W^MACLIN_MTXT_TAB	;...
	BNEQ	20$			;IF NEQ YES--GO DISPATCH TO PROCESSOR
10$:	DECL	R5			;COUNT THE CHARACTER
	BLSS	MACLIN_NEXT_CHR		;DON'T STORE IF THERE IS NO ROOM
	MOVB	R10,(R6)+		;STORE THE CHARACTER
	BRB	MACLIN_NEXT_CHR		;GO FOR MORE
;
; DISPATCH TO SPECIAL OPERATOR PROCESSING ROUTINE
;
20$:	SUBL2	#MACLIN_MTXT_TAB,R1	;GET INDEX INTO DISPATCH TABLE
	PUSHL	W^MACLIN_DISP_TAB[R1]	;GET ROUTINE ADDRESS
	RSB				;RETURN TO EXECUTE ROUTINE
30$:	BRW	MACLIN_LINE_END		;DO END OF LINE PROCESSING
;
; HERE IF LINE CONTAINS NO SPECIAL OPERATORS OR TEXT LINKS. JUST COPY
; THE TEXT TO THE OUTPUT BUFFER
;
MACLIN_COPY_LIN:
	SUBL3	R8,#INP$K_BUFSIZ,-(SP)	; Compute bytes that will remain in buffer
	BGEQ	10$			; If GEQ bytes will fit in buffer
	MOVC3	#INP$K_BUFSIZ,(R7),(R6)	; Copy only bytes that will fit in buffer
	BRB	20$
10$:
	MOVC3	R8,(R7),(R6)		; Copy line to buffer
20$:
	POPL	R5			; Set number of bytes remaining
	ADDL2	R8,R6			; Point past end of line in buffer
	ADDL2	R8,R7			;UPDATE INPUT POINTER
	BRW	MACLIN_LINE_END		;DO END OF LINE PROCSSING

	.SBTTL	PROCESS ARGUMENT MARKERS AND TEXT LINKS

;
; MTX$_ARGMRK -- ARGUMENT MARKER.  GET THE ARG NUMBER AND STORE THE
; REPLACEMENT STRING FOR THAT ARGUMENT.
;
MACLIN_ARGMRK:
	MOVZBL	(R7)+,R10		;GET ARGUMENT NUMBER
	DECL	R8			;COUNT THE ARG MARKER
	MOVL	INP$L_ARGS-4(R12)[R10],R10 ;GET ARG DESCRIPTOR POINTER
	BEQL	MACLIN_NEXT_CHR		;IF EQL NO REPLACEMENT STRING
	MOVZWL	(R10)+,R4		;GET LENGTH OF REPLACEMENT STRING
	BEQL	MACLIN_NEXT_CHR		;IF EQL NO REPLACEMENT STRING
	CMPL	R4,R5			;STRING TOO LONG?
	BLEQ	10$			;IF LEQ NO
	MOVL	R5,R4			;YES--JUST COPY WHAT WILL FIT
	CVTBL	#-1,R5			;AND DON'T COPY ANY MORE AFTER
10$:	SUBL2	R4,R5			;UPDATE THE COUNTER
	PUSHL	R5			;SAVE THE COUNTER
	MOVC3	R4,(R10),(R6)		;COPY ARG INTO LINE BUFFER
	MOVL	R3,R6			;UPDATE BUFFER POINTER
	POPL	R5			;RETRIEVE COUNT
20$:	BRB	MACLIN_NEXT_CHR		;NEXT CHARACTER
;
; MTX$_TXTLNK -- TEXT LINK.  GET THE LINK TO THE NEXT PAGE.
;
MACLIN_TXTLNK:
	MOVL	(R7)+,R7		;LINK TO NEXT TEXT
	ADDL2	#MXB$K_BLKSIZ,R7	; Skip header information
	INCL	R8			;UNCOUNT LINK BYTE THAT WAS COUNTED
	BRW	MACLIN_NEXT_CHR		; and continue (don't count byte tho)

	.SBTTL	PROCESS LEXICAL LENGTH OPERATOR

;
; MTX$_LXLEN -- LEXICAL LENGTH FUNCTION.  THE NEXT BYTE IS AN ARGUMENT
; DESCRIPTOR.  IT CAN BE 0 (SPECIAL CANCEL), A LITERAL STRING, OR AN
; ARGUMENT MARKER.  PROCESS IT.
;
MACLIN_LXLEN:
	BSBW	MACLIN_GET_STR		;GET THE STRING ARGUMENT
	BLBC	R0,10$			;BRANCH IF THERE WAS AN ERROR
	MOVL	R4,R2			;POSITION FOR DECOUT
	BSBW	MACLIN_DECOUT		;OUTPUT THE STRING LENGTH
	BRB	20$			;GO DO REST OF LINE
10$:	BSBW	MACLIN_ZEROUT		;OUTPUT ZERO ON ERROR
20$:	BRW	MACLIN_NEXT_CHR		;DO REST OF LINE

	.SBTTL	PROCESS LEXICAL EXTRACT OPERATOR

;
; MTX$_LXEXT -- LEXICAL EXTRACT FUNCTION.  THERE ARE THREE ARGUMENTS:
; 1) A STARTING POSITION, 2) THE LENGTH OF THE STRING TO EXTRACT, AND
; 3) THE STRING TO EXTRACT FROM. 
;
MACLIN_LXEXT:
	BSBW	MACLIN_GET_VAL		;GET THE STARTING POSITION
	BLBC	R0,60$			;BRANCH IF ERROR
	TSTL	R1			;IS IT AN UNSIGNED INTEGER?
	BGEQ	10$			;YES -- SAVE IT
	MNEGL	R1,R1			;NO -- GET ITS ABS VALUE
10$:	PUSHL	R1			;SAVE STARTING POSITION
	BSBW	MACLIN_GET_VAL		;GET THE LENGTH
	BLBC	R0,110$			;BRANCH IF ERROR
	TSTL	R1			;IS IT AN UNSIGNED INTEGER?
	BGEQ	20$			;YES -- SAVE IT
	MNEGL	R1,R1			;NO -- GET ITS ABS VALUE
20$:	PUSHL	R1			;SAVE THE LENGTH
	BSBW	MACLIN_GET_STR		;GET THE STRING
	BLBC	R0,100$			;BRANCH IF ERROR
	TSTL	R4			;WAS STRING NULL?
	BEQL	100$			;IF EQL YES
;
; HERE WITH R10 POINTING TO STRING, R4 HAS THE LENGTH OF THE STRING,
; 0(SP) HAS THE LENGTH OF DESIRED EXTRACTION, AND 4(SP) HAS THE POSITION
; FROM WHICH TO START EXTRACTING
;
30$:	POPL	R3			;GET LENGTH OF STRING TO EXTRACT
	POPL	R2			;GET STARTING POSITION
	CMPL	R2,R4			;IS STARTPOS PAST STRING END?
	BGTR	MACLIN_LEX_EXIT		;IF GTR YES--RESULT IS NULL
	ADDL3	R2,R3,R1		;NO--FIGURE END POSITION
	CMPL	R1,R4			;PAST END OF STRING?
	BLEQ	40$			;IF LEQ NO
	SUBL3	R2,R4,R3		;YES--FIGURE # CHARS WE CAN GET
40$:	CMPL	R3,R5			;IS THERE ROOM FOR WHOLE STRING?
	BLEQ	50$			;IF LEQ YES
	MOVL	R5,R3			;NO--JUST STORE WHAT WE CAN
50$:	SUBL3	R3,R5,-(SP)		;UPDATE COUNT OF SPACE LEFT AND STACK
	MOVC3	R3,(R10)[R2],(R6)	;COPY STRING INTO LINE BUFFER
	MOVL	R3,R6			;UPDATE POINTER
	POPL	R5			;RETRIEVE UPDATED COUNT
60$:	BRB	MACLIN_LEX_EXIT		;GO FINISH UP
;
; CLEAN TWO WORDS FROM STACK AND EXIT
;
100$:	ADDL2	#2*4,SP			;CLEAR TWO LONGWORDS FROM STACK
	BRB	MACLIN_LEX_EXIT		;EXIT
;
; CLEAN ONE WORD FROM STACK AND EXIT
;
110$:	TSTL	(SP)+			;CLEAR ONE LONGWORD FROM STACK
MACLIN_LEX_EXIT:			;BRANCH AID
	BRW	MACLIN_NEXT_CHR		;GO DO REST OF LINE

	.SBTTL	PROCESS LEXICAL LOCATE OPERATOR

;
; MTX$_LXLOC -- LEXICAL LOCATE FUNCTION.  THERE ARE TWO MANDATORY ARGUMENTS:
; 1) THE SUBSTRING TO LOCATE, 2) THE STRING TO LOCATE IN.  THE THIRD
; ARGUMENT, THE STARTING POSITION, IS OPTIONAL.  IT WILL EITHER BE THERE
; OR THERE WILL BE AN MTX$_NOMORE BYTE IN ITS PLACE.
;
MACLIN_LXLOC:
	BSBW	MACLIN_GET_STR		;GET THE STRING
	BLBC	R0,50$			;BRANCH IF ERROR
;
; SAVE POINTERS FOR LATER USE
;
	MOVAB	W^MAC$AB_TMPBUF,R1	;POINT TO SAVE AREA
	MOVL	R4,(R1)+		;STORE LENGTH OF STRING
	MOVL	R10,(R1)+		;AND ITS ADDRESS
;
; PICK UP PARAMS FOR SECOND ARGUMENT (STRING TO LOCATE IN)
;
	BSBW	MACLIN_GET_STR		;GET THE SECOND ARGUMENT
	BLBC	R0,50$			;BRANCH IF ERROR
	MOVAB	W^MAC$AB_TMPBUF+8,R1	;POINT TO TEMP BUFFER
	MOVL	R4,(R1)+		;SAVE ITS LENGTH
	MOVL	R10,(R1)+		;AND LOCATION
;
; GET OPTIONAL STARTPOS ARGUMENT IF PRESENT
;
10$:	CMPB	(R7),#MTX$_NOMORE	;IS THERE NO STARTPOS ARG
	BNEQ	15$			;IF NEQ IT MAY BE THERE
	INCL	R7			;ITS NOT THERE--BUMP POINTER
	DECL	R8			;DEC. COUNTER
	CLRL	R1			;USE STARTPOS OF 0
	BRB	20$			;AND GO FINISH UP
15$:	CMPB	(R7),#MTX$_TXTLNK	;IS IT A TEXT LINK?
	BNEQ	17$			;IF NEQ NO
	INCL	R7			;YES--SKIP THE BYTE, BUT DONT COUNT IT!
	BSBW	MACLIN_LINK_CH0		;LINK TO NEXT PAGE
	BRB	10$			;AND TRY AGAIN
17$:	BSBW	MACLIN_GET_VAL		;NO--GET THE VALUE
	BLBC	R0,50$			;BRANCH IF ERROR
20$:	MOVAB	W^MAC$AB_TMPBUF,R0	;POINT TO TEMP BUFFER
	PUSHL	R5			;SAVE R5
	MOVQ	(R0)+,R4		;R4=SUBSTR LENGTH, R5=SUBSTR ADDR
	MOVQ	(R0)+,R2		;R2=STRING LENGTH, R3=STRING ADDR
	PUSHL	R4			;SAVE LENGTH OF SUBSTRING
	PUSHL	R2			;SAVE LENGTH OF STRING
	SUBL2	R1,R2			;DECREASE STRING LENGTH BY STARTPOS
	MATCHC	R4,(R5),R2,(R3)[R1]	;PERFORM THE LOCATE
	BNEQ	30$			;IF NEQ NOT FOUND
	SUBL3	R2,(SP)+,R2		;FIGURE STARTING POSITION
	SUBL2	(SP)+,R2		;R2 HAS STARTING POSITION
	BRB	40$			;JOIN COMMON CODE
30$:	POPL	R2			;NOT FOUND--RETURN STRING LENGTH
	TSTL	(SP)+			;CLEAR STACK
40$:	POPL	R5			;RESTORE R5
	BSBW	MACLIN_DECOUT		;OUTPUT THE DECIMAL VALUE
	BRB	MACLIN_LEX_EXIT
;
; ERROR--OUTPUT A ZERO
;
50$:	BSBW	MACLIN_ZEROUT		;OUTPUT A ZERO
	BRW	MACLIN_NEXT_CHR		;GO DO REST OF LINE

	.SBTTL	END OF LINE/END OF TEXT PROCESSING

;
; LINE IS DONE
;
MACLIN_LINE_END:
	TSTL	R5			;WAS LINE TOO LONG?
	BGEQ	10$			;IF GEQ NO
	$INTOUT_LW INT$_ERR,<#MAC$_LINTOOLONG,#0> ; Yes--error
	brb	15$
10$:	MOVB	#CR,(R6)+		;END LINE WITH CR
15$:	SUBL3	#MAC$AB_LINEBF+1,R6,R5	;FIGURE LINE LENGTH
	MOVL	R5,W^MAC$GL_LINELN	;SAVE FOR LATER
20$:	MOVL	R7,INP$L_NXTL(R12)	;SET NEXT LINE POINTER
	BLBS	W^LST$G_MACROXPAN+SYM$L_VAL,30$ ;BRANCH IF LISTING MACRO EXPANSIONS
	BLBS	W^LST$G_MACROBIN+SYM$L_VAL,30$ ;BRANCH IF LISTING MACRO BINARY
	TSTL	W^MAC$GL_LIST_LVL	;CHECK THE LISTING LEVEL
	BLEQ	40$			;BRANCH IF NOT LISTING
;
; MACRO LINE WILL BE LISTED.  EMIT LINE TO INTERMEDIATE BUFFER
;
30$:
	$INTOUT_X INT$_CHKL		; Align listing
	ADDL3	#4,R5,R0		; Figure size or record
	BSBW	MAC$INTOUT_N		;SET UP TO STORE THE LINE
	MOVB	#-1,-1(R9)		;SET SPECIAL MACRO LINE FLAG
	MOVB	#INT$_MACL,(R9)+	;STORE CODE
	MOVW	R5,(R9)+		;STORE LENGTH OF LINE
	MOVC3	R5,W^MAC$AB_LINEBF,(R9)	;COPY LINE INTO INT. BUFFER
	MOVL	R3,R9			;UPDATE THE POINTER
	BRB	MACLIN_EXIT		;FINISH UP
;
; MACRO LINE WILL NOT BE LISTED.
;
40$:	MOVZBL	#4,R0			;SET TO STORE 4 BYTES
	BSBW	MAC$INTOUT_N		;SET UP FOR THEM
	MOVB	#-1,-1(R9)		;SET SPECIAL MACRO LINE FLAG
	MOVB	#INT$_MACL,(R9)+	;STORE CODE
	CLRW	(R9)+			;ZERO LENGTH LINE
	BRB	MACLIN_EXIT		;GO FINISH UP
;
; WE REACHED THE END OF THE MACRO TEXT
;
MACLIN_END_TEXT:
	TSTL	W^MAC$GL_IF_LEVEL	;CHECK THE IF-LEVEL
	BEQL	10$			;SHOULD BE AT LEVEL 0
	$INTOUT_LW INT$_WRN,<#MAC$_UNTERMCOND,W^MAC$GL_LINEPT> ; No--error
10$:	BSBW	MAC$POP_INPUT		;POP AN INPUT LEVEL
	BRB	MACLIN_EX0		;SKIP R10 SET
MACLIN_EXIT:
	MOVZBL	#BLNK,R10		;RESET R10
MACLIN_EX0:
	MOVAB	W^MAC$AB_LINEBF,W^MAC$GL_ERRPTX ;SET ERROR TOKEN POINTER
	POPR	#^M<R3,R4,R5,R6,R7,R8,R12> ;RESTORE REGISTERS
	RSB

	.SBTTL	CHECK FOR LINK BYTE IN LEXICAL OPERATORS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THE LEXICAL OPERATORS MAY HAVE OPERANDS THAT SPAN ACROSS
;	PAGES.  IF THIS IS THE CASE, THERE WILL BE A TXTLNK BYTE.
;	THIS ROUTINE CHECKS FOR THAT, AND IF IT IS THE CASE, SPANS
;	TO THE NEW PAGE.
;
; INPUTS:
;
;	R10	THE BYTE IN QUESTION
;	R8	LINE COUNT
;	R7	LINE POINTER
;
; OUTPUTS:
;
;	R10,R8,R7 UPDATED IF R10 WAS A TXTLNK
;
;--

	.ENABL	LSB
MACLIN_LINK_CHK:
	CMPB	R10,#MTX$_TXTLNK	;IS IT A TEXTLINK?
	BNEQ	10$			;IF NEQ NO
MACLIN_LINK_CH0:
	MOVL	(R7)+,R7		;YES--LINK TO NEXT PAGE
	ADDL2	#MXB$K_BLKSIZ,R7	; Skip header information
	RSB				;RETURN
10$:	CALLS	#0,W^MAC$ERR_INTERN	;REPORT INTERNAL CONFUSION
	BRW	MAC$ABORT_PASS1		;TERMINATE PASS 1
	.DSABL	LSB

	.SBTTL	GET VALUE FOR LEXICAL OPERATOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PICKS UP THE NEXT ARGUMENT (IT MUST BE NUMERIC)
;	AND RETURNS IT TO THE CALLER.
;
; OUTPUTS:
;
;	R0	0	ERROR
;		1	OK
;	R1		VALUE IF R0=1
;
;--

	.ENABL	LSB
MACLIN_GET_VAL:
	DECL	R8			;COUNT NEXT BYTE
	CLRL	R0			;CLEAR IN CASE CANCEL BYTE
5$:	MOVZBL	(R7)+,R10		;GET ARG DESCRIPTOR BYTE
	BEQL	60$			;IF EQL SPECIAL CANCEL BYTE
MACLIN_GET_VL0:
	CMPB	R10,#MTX$_LITVAL	;IS IT A LITERAL VALUE?
	BEQL	10$			;IF EQL YES
	CMPB	R10,#MTX$_SYMADR	;IS IT AN ABSOLUTE SYMBOL ADDRESS?
	BEQL	20$			;IF EQL YES
	BSBW	MACLIN_LINK_CHK		;NO--SEE IF A TEXT LINK
	BRB	5$			;TRY AGAIN
;
; IT WAS A LITERAL VALUE--PICK IT UP
;
10$:	MOVL	(R7)+,R1		;GET THE VALUE
	BRB	50$			;EXIT WITH SUCCESS
;
; IT WAS A SYMBOL ADDRESS
;
20$:	MOVL	(R7)+,R1		;GET THE SYMBOL BLOCK ADDRESS
	PUSHL	R1			;SAVE SYMBOL ADDRESS
	BBS	#SYM$V_DEF,SYM$W_FLAG(R1),30$ ;BRANCH IF SYMBOL DEFINED
	MOVAB	L^MAC$AB_LINEBF(R5),R2	;SET UP LINE POINTER
	$INTOUT_LW INT$_ERR,<#MAC$_UNDEFSYM,R2> ; Send error to pass 2
	MOVL	(SP),R1			;RESET SYMBOL BLOCK ADDRESS
30$:	BBS	#SYM$V_ABS,SYM$W_FLAG(R1),40$ ;BRANCH IF ABSOLUTE
	$INTOUT_LW INT$_ERR,<#MAC$_SYMNOTABS,R2> ; No--error to pass 2
40$:	POPL	R1			;GET SYMBOL ADDRESS AGAIN
	MOVL	SYM$L_VAL(R1),R1	;GET THE SYMBOL VALUE
50$:	SUBL2	#4,R8			;COUNT 4 BYTES GONE
	MOVL	#1,R0			;RETURN SUCCESS
60$:	RSB
	.DSABL	LSB

	.SBTTL	GET STRING FOR LEXICAL OPERATOR


;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE RETURNS THE ADDRESS AND LENGTH OF THE NEXT ARGUMENT
;	FOR A LEXICAL OPERATOR (MUST BE STRING ARGUMENT).
;
; OUTPUTS:
;
;	R0	0	CANCEL WAS SEEN
;		1	OK
;	R4		LENGTH OF STRING
;	R10		ADDRESS
;
;--

MACLIN_GET_STR:
	DECL	R8			;COUNT NEXT BYTE
	CLRL	R0			;CLEAR IN CASE CANCEL BYTE
10$:	MOVZBL	(R7)+,R10		;GET ARG DESCRIPTOR BYTE
	BEQL	50$			;IF EQL SPECIAL CANCEL BYTE
	CMPB	R10,#MTX$_LITSTR	;IS IT A LITERAL STRING?
	BEQL	30$			;IF EQL YES
	CMPB	R10,#MTX$_ARGMRK	;NO--IS IT AN ARG MARKER?
	BEQL	20$			;IF EQL YES
	BSBW	MACLIN_LINK_CHK		;NO--SEE IF A TEXT LINK
	BRB	10$			;AND TRY AGAIN
;
; ARGUMENT MARKER
;
20$:	DECL	R8			;COUNT ARG NUMBER BYTE
	MOVZBL	(R7)+,R10		;GET ARG NUMBER
	CLRL	R4			;CLEAR LENGTH IN CASE NULL STRING
	MOVL	INP$L_ARGS-4(R12)[R10],R10 ;GET DESCRIPTOR POINTER
	BEQL	40$			;IF EQL NULL STRING
	MOVZWL	(R10)+,R4		;GET THE LENGTH OF THE STRING
					;AND LEAVE R10 POINTING AT STRING
	BRB	40$			;GO RETURN
;
; LITERAL STRING
;
30$:	MOVZWL	(R7)+,R4		;GET LENGTH OF LITERAL STRING
	MOVL	R7,R10			;POINT R10 TO START OF STRING
	ADDL2	R4,R7			;SKIP THE STRING
	SUBL2	R4,R8			;COUNT THE STRING
	SUBL2	#2,R8			;COUNT THE COUNT WORD
40$:	MOVL	#1,R0			;RETURN GOODLY
50$:	RSB				;DONE

	.SBTTL	OUTPUT DECIMAL NUMBER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS A DECIMAL NUMBER TO THE LINE BUFFER BEING
;	CREATED.
;
; INPUTS:
;
;	R2	NUMBER TO OUTPUT
;	R5	LINE COUNTER
;	R6	LINE POINTER
;
; OUTPUTS:
;
;	R5,R6	UPDATED
;	NUMBER OUTPUT
;
;--

MACLIN_ZEROUT:
	CLRL	R2			;OUTPUT A ZERO
MACLIN_DECOUT:
	CLRL	R3			;CLEAR HIGH WORD
10$:	EDIV	#10,R2,R2,R0		;DIVIDE BY 10
	ADDB2	#^A/0/,R0		;CONVERT TO ASCII
	PUSHL	R0			;AND STACK IT
	TSTL	R2			;ANY MORE TO DO?
	BEQL	20$			;IF EQL NO--UNSTACK AND OUTPUT
	BSBB	10$			;YES--RECURSE TILL 0
20$:	POPL	R0			;GET THE DIGIT BACK
	DECL	R5			;SEE IF ROOM TO STORE IT
	BLSS	30$			;IF LSS NO
	MOVB	R0,(R6)+		;STORE THE DIGIT
30$:	RSB				;RECURSE OR RETURN

	.END
