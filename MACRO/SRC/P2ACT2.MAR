	.TITLE	MAC$P2ACT2 PASS 2 ACTION ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 20-AUG-78
;
; MODIFIED BY:
;
;	V02.13	PCG0002		Peter George	16-Apr-1981
;		Set and clear DBGOUT control flag.
;
;	V02.12	CNH0046		Chris Hume	 2-Dec-1980
;		Taught P2$ERR (and relatives) to respect Parser Value Stack.
;
;	V02.11	CNH0036		Chris Hume	14-Jul-1980
;		Closed off some more areas where the assembler was writing
;		object records too long for the linker.  (P2ACT1.MAR 02.08)
;
;	V01.10	RN0029		R. Newland	20-Jan-1980
;		If error pointer is beyond column 132 do not print a
;		pointer.  This situation only occurs during macro
;		expansions which form a line longer than 132 characters.
;
;	V01.09	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.07	RN0019		R. Newland	23-Oct-1979
;		Improve error pointer positioning
;
;	V01.16	RN0013		R. Newland	27-Sep-1979
;		Use new symbols for PSECT options processing
;	V01.05	RN0005		R. Newland	13-Aug-1979
;		Remove .ALIGN LONG statements
;
;	V01.04	RN0002		R. Newland	01-Feb-1979
;		Changes for Source Update Merge, form listing line
;		number differently for updated files, and SUM error
;		reporting
;	V0.08	RN0021		R. Newland	28-Oct-1979
;		Correct listing of .ENTRY register mask value.
;		SPR 11-26384
;
;	V01.03	0005		B. Schreiber	10-JAN-1979
;		Correct record too long error with .PRINT directive.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_OBJCODDEF			;DEFINE OBJECT CODE RECORD TYPES
	$MAC_TIRCMDDEF			;DEFINE TIR COMMANDS
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE COMMON VALUES
	$MACMSGDEF			; Define message codes
	DEFSUMCBL			; Define SUM control block symbols

;
; LOCAL DATA
;
	.PSECT	MAC$P2ACT2_DATA,NOEXE,LONG

MAC$GL_P2_ERRPT::
	.LONG	0			;ERROR CODE GETS STORED HERE
	.LONG	0			;POINTER TO WHERE ERROR HAPPENED

	.PSECT	MAC$RO_CODE_P2,NOWRT,GBL,LONG

	.SBTTL	PASS 2 COMMANDS FOR PC

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE STACKS THE CURRENT PC ON THE LINKER'S STACK.
;
;--

P2$STKPC::
	$OBJ_CHKBYT #TIR$C_STA_PL	;COMMAND IS STACK PSECT BASE PLUS OFFSET
	$OBJ_OUTBYT_0 W^MAC$GL_PSECT	;EMIT PSECT NUMBER
	MOVAB	W^MAC$GL_PC,R5		;POINT TO PC
	$VPUSH	(R5)			;PUSH ONTO MY 'LINKER STACK'

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE EMITS 4 BYTES TO THE OBJECT FILE.
;
; INPUTS:
;
;	R5	POINTS TO 4 BYTES TO OUTPUT
;
;--

MAC$OUT_LW::
	MOVZBL	#4,R4			;SET UP COUNTER
10$:	$OBJ_OUTBYT (R5)+		;SEND A BYTE
	SOBGTR	R4,10$			;LOOP FOR FOUR
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE AUGMENTS THE PC.  THE PARAMETER PASSED IS THE
;	VALUE TO ADD TO THE CURRENT PC.
;
; INPUTS:
;
;	R8	POINTS TO LONGWORD VALUE TO ADD TO PC
;
;--

P2$AUGPC::
	BSBW	MAC$SET_PC		;RECORD PC
	ADDL2	(R8),W^MAC$GL_PC	;ADJUST PC
	BSBW	MAC$SET_PC		;RECORD NEW PC
	MOVL	W^MAC$GL_PSECTPTR,R0	;GET POINTER TO CURRENT PSECT
	BBC	#PSC$V_REL,PSC$W_OPTIONS(R0),10$ ;BRANCH IF NOT RELOCATABLE
	$OBJ_CHKBYT #TIR$C_CTL_AUGRB	;YES--AUGMENT RELOCATION BASE
	MOVL	R8,R5			;POINT AT VALUE TO OUTPUT
	BRB	MAC$OUT_LW		;BRANCH TO OUTPUT LONGWORD PC AUGMENTATION
10$:	RSB

	.SBTTL	STORE DATA FROM LINKER STACK

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES, P2$STOB,P2$STOW,P2$SPID,P2$STOL,P2$STOV,
;	P2$STSB, AND P2$STSW
;	ALL STORE SIGNED DATA FROM THE LINKER STACK INTO THE OBJECT
;	FILE.
;
;--

P2$STSB::				;STORE SIGNED BYTE
	$OBJ_CHKBYT #TIR$C_STO_SB	;STORE SIGNED BYTE COMMAND
	BRB	BYT_COM			;GO DO COMMON BYTE PROCESSING

P2$STOB::				;STORE BYTE
	$OBJ_CHKBYT #TIR$C_STO_B	;STORE BYTE COMMAND
BYT_COM:
	PUSHL	#1			;STACK COUNT OF BYTES
	BSBB	STO_COM			;GO TO COMMON CODE
	.ADDRESS MAC$AB_LST_END+2	;NEW LINE IF PAST HERE

P2$STSW::				;STORE SIGNED WORD
	$OBJ_CHKBYT #TIR$C_STO_SW	;STORE SIGNED WORD COMMAND
	BRB	WORD_COM		;DO COMMON WORD PROCESSING

P2$STOW::				;STORE WORD
	$OBJ_CHKBYT #TIR$C_STO_W	;STORE WORD COMMAND
WORD_COM:
	PUSHL	#2			;STACK COUNT OF BYTES
	BSBB	STO_COM			;GO TO COMMON CODE
	.ADDRESS MAC$AB_LST_END+4	;NEW LINE IF PAST HERE

P2$SPID::				;STORE PIC ADDRESS
	$OBJ_CHKBYT #TIR$C_STO_PIDR	;STORE PIC DATA REF
	BRB	P2_LONG

P2$STOL::				;STORE LONGWORD
	$OBJ_CHKBYT #TIR$C_STO_LW	;STORE LONGWORD COMMAND
	BRB	P2_LONG

P2$STOV::				;STORE FIELD
	$OBJ_CHKBYT #TIR$C_STO_VPS	;STORE FIELD COMMAND
P2_LONG:
	PUSHL	#4			;STACK COUNT OF BYTES
	BSBB	STO_COM			;GO TO COMMON CODE
	.ADDRESS MAC$AB_LST_END+8	;NEW LINE IF PAST HERE

STO_COM:
	MOVL	@(SP)+,R0		; Get line limit (and clear stack)
	BBC	#FLG$V_UPDFIL,(R11),5$	; Branch if file is not being updated
	ADDL2	#<MAC$AB_LST_OP2-MAC$AB_LST_END>,R0 ; Reserve space for audit
5$:
	CMPL	W^MAC$GL_LIST_PTR,R0	;TIME FOR NEW LINE?
	BGEQU	10$			;IF GEQ NO
	BSBW	P2$FNEWL		;YES--FORCE NEW LINE
10$:	POPL	R0			;GET COUNT OF BYTES BACK
	MOVB	#^A/'/,@W^MAC$GL_LIST_PTR ;SET QUOTE IN LISTING
	$MAC_LIST_BYTE R0		;LIST THE BYTE(S)
	RSB

	.SBTTL	STORE REPEATED DATA

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES, P2$STRB, P2$STRW, P2$STRL, P2$STRSB, AND
;	P2$STRSW STORE REPEATED DATA FROM THE LINKER STACK INTO THE
;	OBJECT FILE.
;
;--

P2$STRSB::				;STORE REPEATED SIGNED BYTE
	$OBJ_CHKBYT #TIR$C_STO_RSB	;STORE REPEATED SIGNED BYTE COMMMAND
	BRB	STRB_COM		;JOIN COMMON CODE

P2$STRB::				;STORE REPEATED BYTE
	$OBJ_CHKBYT #TIR$C_STO_RB	;STORE REPEATED BYTE COMMAND
STRB_COM:
	PUSHAB	W^MAC$AB_LST_END+2	;STACK END OF LINE MARKER
	MOVB	#1,-(SP)		;AND COUNT OF BYTES TO LIST PER VALUE
	BRB	STO_LOOP

P2$STRSW::				;STORE REPEATED SIGNED WORD
	$OBJ_CHKBYT #TIR$C_STO_RSW	;STORE REPEATED SIGNED WORD COMMAND
	BRB	STRW_COM		;JOIN COMMON CODE

P2$STRW::				;STORE REPEATED WORD
	$OBJ_CHKBYT #TIR$C_STO_RW	;STORE REPEATED WORD COMMAND
STRW_COM:
	PUSHAB	W^MAC$AB_LST_END+4	;STACK END OF LINE MARKER
	MOVB	#2,-(SP)		;STACK COUNT OF BYTES TO LIST PER VALUE
	BRB	STO_LOOP

P2$STRL::				;STORE REPEATED LONGWORD
	$OBJ_CHKBYT #TIR$C_STO_RL	;STORE REPEATED LONGWORD COMMAND
	PUSHAB	W^MAC$AB_LST_END+8	;STACK END OF LINE MARKER
	MOVB	#4,-(SP)		;STACK COUNT OF BYTES TO LIST PER VALUE

STO_LOOP:

	$VPOP	R6			;GET REPEAT COUNT
	TSTL	R6			;CHECK REPEAT COUNT
	BEQL	30$			;IF EQL ALL DONE
	$VPOP	-(SP)			;GET VALUE OFF VALUE STACK
10$:	CMPL	W^MAC$GL_LIST_PTR,5(SP)	;TIME FOR NEW LINE?
	BGEQU	20$			;IF GEQU NO
	BSBW	P2$FNEWL		;YES--FORCE NEW LINE
20$:	MOVB	#^A/'/,@W^MAC$GL_LIST_PTR ;STORE QUOTE IN LISTING
	$VPUSH	(SP)			;STACK THE VALUE ON VALUE STACK
	MOVAL	W^MAC$AL_VALSTACK[R7],R5;POINT R5 TO TOP OF VALUE STACK
	$MAC_LIST_BYTE 4(SP)		;LIST THE VALUE
	SOBGTR	R6,10$			;LOOP FOR ALL BYTES
	TSTL	(SP)+			;CLEAR SAVE VALUE FROM STACK
30$:	ADDL2	#5,SP			;CLEAR BYTE AND LONGWORD FROM STACK
	RSB

	.SBTTL	STORE IMMEDIATE DATA

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE STORES A BYTE OF DATA INTO THE OBJECT CODE
;
;--

P2$STIB::
	MOVAB	W^MAC$AB_LST_END+2,R0	;SET ADDRESS TO CHECK
	BSBB	CK_NWL			;SEE IF TIME FOR NEW LINE AND FORCE IF NEEDED
	MOVZBL	(R8),R0			;GET THE DATA BYTE
	$VPUSH	R0			;STACK IT
	TSTL	(R5)+			;KEEP R5 POINTING TO TOP OF STACK
	BSBW	MAC$CK_BYT_TRUN		;CHECK FOR TRUNCATION
	MOVB	(R8),R0			;GET THE BYTE VALUE
	BSBW	MAC$STOIM		;STORE INTO OBJECT CODE
	$MAC_LIST_BYTE #1		;LIST BYTE FROM STACK
	RSB				;EXIT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE STORES A WORD INTO THE OBJECT CODE
;
;--

P2$STIW::
	MOVAB	W^MAC$AB_LST_END+4,R0	;GET ADDRESS TO CHECK
	BSBB	CK_NWL			;SEE IF TIME FOR NEW LINE
	$VPUSH	(R8)			;STACK VALUE
	TSTL	(R5)+			;KEEP R5 POINTING TO TOP OF STACK
	BSBW	MAC$CK_WRD_TRUN		;CHECK FOR TRUNCATION
	MOVZBL	#2,R3			;SET TO STORE TWO BYTES
	BRB	STO_DAT			;STORE WORD AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE STORES A LONGWORD INTO THE OBJECT CODE
;
;--

P2$STIL::
	MOVAB	W^MAC$AB_LST_END+8,R0	;GET ADDRESS TO CHECK
	BSBB	CK_NWL			;SEE IF TIME FOR A NEW LINE
	$VPUSH	(R8)			;STACK VALUE
	TSTL	(R5)+			;KEEP R5 POINTING TO TOP OF STACK
	MOVZBL	#4,R3			;SET TO STORE 4 BYTES
STO_DAT:
	MOVL	R3,R4			;REMEMBER THE BYTE COUNT
10$:	MOVB	(R8)+,R0		;GET A BYTE
	BSBW	MAC$STOIM		;STORE INTO OBJECT CODE
	SOBGTR	R4,10$			;LOOP FOR ALL BYTES
	$MAC_LIST_BYTE R3		;LIST BYTES FROM STACK
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY THE STORE IMMEDIATE ROUTINES TO
;	SEE IF IT IS TIME FOR A NEW LISTING LINE.
;
; INPUTS:
;
;	R0	BOTTOM ADDRESS WE CAN GO TO
;
; OUTPUTS:
;
;	NEW LINE IF NOT GEQU R0.
;
;--

CK_NWL:
	CMPL	W^MAC$GL_LIST_PTR,R0	;TIME FOR A NEW LINE?
	BGEQU	10$			;IF GEQU NO
	BRW	P2$FNEWL		;YES--FORCE NEW LINE AND RETURN
10$:	RSB				;JUST RETURN

	.SBTTL	PSECT ACTION ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	P2$NEWP IS CALLED TO DEFINE A NEW PSECT DURING PASS 2.
;	THE PREVIOUS OBJECT RECORD IS WRITTEIN, AND A GSD RECORD
;	IS OUTPUT CONTAINING THE PSECT DEFINITION.  THE RECORD
;	TYPE IS THEN RESET TO TIR.
;
;--

P2$NEWP::
	MOVL	(R8),R6			;POINT TO PSECT DEFINITION BLOCK
	BBSS	#FLG$V_DBGOUT,(R11),.+1	;SET DEBUGGER RECORD FLAG
	MOVZBL	#OBJ$C_GSD,W^MAC$GL_RECTYP ;SET GSD RECORD TYPE
	BSBW	MAC$WRTOBJ		;WRITE PREVIOUS RECORD
	$OBJ_OUTBYT_0 #OBJ$C_GSD_PSC	;PSECT DEFINITION RECORD
	EXTZV	#PSC$V_ALIGNMENT,-	;EXTRACT ALIGNMENT FIELD
		#PSC$S_ALIGNMENT,-
		PSC$W_OPTIONS(R6),R0
	$OBJ_OUTBYT_0 R0		;OUTPUT ALIGNMENT
	$OBJ_OUTBYT_0 PSC$W_OPTIONS(R6)	;OUTPUT LOW BYTE OF FLAGS
	BICB3	#^C<PSC$M_ALLOPTNS@-8>,- ; Get remaining option bits
		PSC$W_OPTIONS+1(R6),R0
	$OBJ_OUTBYT_0 R0		;EMIT HI BYTE OF FLAGS
	BBS	#PSC$V_REL,PSC$W_OPTIONS(R6),10$ ;BRANCH IF RELOCATABLE PSECT
	CLRL	PSC$L_MAXLGTH(R6)	;ABSOLUTE--CLEAR MAX LENGTH
10$:	MOVAB	PSC$L_MAXLGTH(R6),R5	;POINT TO MAX LENGTH
	BSBW	MAC$OUT_LW		;OUTPUT THE MAX LENGTH TO OBJECT CODE
	BSBW	MAC$SYMNAMOUT		;OUTPUT PSECT NAME
	MOVZBL	#OBJ$C_TIR,W^MAC$GL_RECTYP ;RESET RECORD TYPE TO TIR
	BSBW	MAC$WRTOBJ		;WRITE OUT PSECT DEFINITION RECORD
	CLRL	PSC$L_MAXLGTH(R6)	;START AT RELATIVE ZERO
	BBCC	#FLG$V_DBGOUT,(R11),.+1	;CLEAR DEBUGGER RECORD FLAG
	RSB

	.SBTTL	CHANGE PSECT / RESTORE PSECT FROM STACK

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CHANGE PSECTS OR TO RESTORE A PSECT
;	FROM THE PSECT STACK.  CODE IS EMITTED TO THE OBJECT FILE TO
;	INFORM THE LINKER OF THE NEW PSECT
;
;--

P2$PSECT::
	BSBW	MAC$SET_PC		;RECORD PC
	MOVL	(R8),R6			;PICK UP POINTER TO PSECT BLOCK
	MOVAB	W^MAC$GL_PC,R3		;POINT TO PC WORD
	MOVL	PSC$L_MAXLGTH(R6),(R3)	;SET NEW PC
	BRB	PSECT_REST		;JOIN COMMON CODE

P2$REST::

	BSBW	MAC$SET_PC		;RECORD PC
	MOVL	(R8),R6			;PICK UP POINTER TO PSECT BLOCK
	MOVAB	W^MAC$GL_PC,R3		;POINT TO PC WORD
	MOVL	PSC$L_CURLOC(R6),(R3)	;SET NEW PC
PSECT_REST:
	MOVZBL	PSC$B_SEG(R6),W^MAC$GL_PSECT ;SET NEW PSECT NUMBER
	MOVL	R6,W^MAC$GL_PSECTPTR	;SET POINTER TO NEW PSECT
	BBS	#PSC$V_REL, -		;IF REL PSECT THEN CONTINUE
		PSC$W_OPTIONS(R6),3$
	BRW	40$			;ELSE ABS PSECT SO SKIP
3$:	$VPUSH	(R3)			;PUSH NEW PC ONTO VALUE STACK
	BBCS	#FLG$V_MEBLST,(R11),5$	;ENSURE DIRECTIVE GETS LISTED
5$:	MOVZBL	#4,R5			;ASSUME LONGWORD OFFSET
	MOVZBL	#TIR$C_STA_PL,R4	;...
	TSTW	2(R3)			;HIGH WORD OF PC ZERO?
	BNEQ	10$			;IF NEQ NO
	TSTW	(R3)			;YES--LOW WORD POSITIVE?
	BLSS	10$			;IF LSS NO
	MOVZBL	#2,R5			;YES--OPTIMIZE TO WORD
	MOVZBL	#TIR$C_STA_PW,R4	;...
	TSTB	1(R3)			;HIGH BYTE OF LOW WORD ZERO?
	BNEQ	10$			;IF NEQ NO
	TSTB	(R3)			;YES--LOW BYTE POSITIVE?
	BLSS	10$			;IF LSS NO
	MOVZBL	#1,R5			;YES--OPTIMIZE TO BYTE
	MOVZBL	#TIR$C_STA_PB,R4	;...
10$:	$OBJ_CHKBYT R4			;OUTPUT COMMAND
	$OBJ_OUTBYT_0 PSC$B_SEG(R6)	;OUTPUT PSECT NUMBER
20$:	$OBJ_OUTBYT_0 (R3)+		;OUTPUT PC
	SOBGTR	R5,20$			;LOOP FOR ALL BYTES
	$OBJ_CHKBYT #TIR$C_CTL_SETRB	;SET RELOCATION BASE COMMAND
	MOVZBL	#4,R4			;ASSUME FULL PC VALUE
	CMPW	W^MAC$GL_PSECTPTR,#PSECT$BLANK ;BLANK PSECT?
	BNEQ	30$			;IF NEQ NO
	TSTL	W^MAC$GL_PC		;YES--AND IS PC ZERO?
	BNEQ	30$			;IF NEQ NO
	MOVZBL	#2,R4			;YES--LIST WORD ONLY
30$:	MOVAL	W^MAC$AL_VALSTACK[R7],R5 ;POINT R5 TO TOP OF VALUE STACK
	MOVAB	W^MAC$AB_SEQ_NUM,W^MAC$GL_LIST_PTR ;POINT TO WHERE PC GOES
	$MAC_LIST_BYTE R4		;LIST PC
	$DEC_PC	R4			;WE REALLY DON'T WANT TO INC PC FOR THAT
	CMPB	R4,#2			;SHORT FORM PC?
	BNEQ	40$			;IF NEQ NO
	MOVZBL	#^A/ /,R0		;YES--LIST A SPACE
	BSBW	MAC$LST_CHAR		;...
40$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS A .SAVE DIRECTIVE IN PASS 2.
;	THE CURRENT PC IS RECORDED IN THE PSECT BLOCK.
;
;--

P2$SAVE::
	MOVL	(R8),R0			;POINT TO PSECT BLOCK
	MOVL	W^MAC$GL_PC,PSC$L_CURLOC(R0) ;SAVE PC IN PSECT BLOCK
	BBSS	#FLG$V_MEBLST,(R11),10$	;ENSURE DIRECTIVE GETS LISTED
10$:	RSB


	.SBTTL	ENTRY POINT DEFINITIONS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES AN ENTRY POINT DEFINITION IN PASS 2.
;	A GSD RECORD IS OUTPUT TO THE OBJECT FILE CONTAINING THE
;	EPT DEFINITION.
;
;--

P2$EPT::
	MOVZBL	#OBJ$C_GSD,W^MAC$GL_RECTYP ;NEXT RECORD IS GSD
	BSBW	MAC$WRTOBJ		;WRITE OUT PREVIOUS RECORD
	$OBJ_OUTBYT_0 #OBJ$C_GSD_EPM	;ENTRY POINT MASK
	$OBJ_OUTBYT_0 #0		;DATA TYPE
	MOVL	(R8)+,R6		;GET ID POINTER
	MOVZBL	#SYM$F_DEF,R0		;SET DEFINED FLAG
	BBS	#SYM$V_ABS,SYM$W_FLAG(R6),10$ ;BRANCH IF ABSOLUTE
	BISB2	#SYM$F_REL,R0		;NO--SET RELOCATABLE
10$:	BBC	#SYM$V_WEAK,SYM$W_FLAG(R6),20$ ;BRANCH IF NOT WEAK
	BISB2	#SYM$F_WEAK,R0		;YES--MARK IT
20$:	$OBJ_OUTBYT_0 R0		;EMIT FLAGS (LOW BYTE)
	$OBJ_OUTBYT_0 #0		;EMIT FLAGS (HI BYTE)
	$OBJ_OUTBYT_0 SYM$B_SEG(R6)	;OUTPUT SEGMENT #
	MOVAB	SYM$L_VAL(R6),R5	;POINT TO VALUE
	BSBW	MAC$OUT_LW		;EMIT LONGWORD VALUE
	$OBJ_OUTBYT_0 (R8)+		;STORE ENTRY MASK
	$OBJ_OUTBYT_0 (R8)		;...
	BSBW	MAC$SYMNAMOUT		;EMIT SYMBOL NAME
	MOVZBL	#OBJ$C_TIR,W^MAC$GL_RECTYP ;NEXT RECORD IS TIR
	MOVZBL	#2,R0			; Set to list 2 bytes
	BSBW	MAC$LIST_BYT_0		; List two bytes from value stack
	$OBJ_OUTBYT #TIR$C_STO_W	; Store word from linker stack
	BRW	W^MAC$WRTOBJ		;WRITE OUT GSD AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE EMITS CODE TO THE OBJECT FILE FOR THE LINKER
;	TO STACK THE ENTRY-POINT MASK FOR A SYMBOL.
;
;--

P2$STKEPT::
	$OBJ_CHKBYT #TIR$C_STA_EPM	;STACK ENTRY POINT MASK
	MOVL	(R8)+,R6		;GET ID POINTER
	BSBW	MAC$SYMNAMOUT		;SEND SYMBOL NAME
	$VPUSH	#0			;STACK 0 (WE DON'T KNOW VALUE)
	RSB

	.SBTTL	PROCESS ASSIGNMENT STATEMENT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESS ASSIGNMENT STATEMENTS DURING PASS 2.
;	THE SYMBOL BLOCK IS UPDATED FROM THE INTERMEDIATE FILE.
;
;--

P2$ASN::
	MOVL	(R8)+,R0		;GET POINTER TO SYMBOL BLOCK
	MOVB	(R8)+,SYM$B_SEG(R0)	;UPDATE SEGMENT
	MOVL	(R8)+,SYM$L_VAL(R0)	;UPDATE VALUE
	TSTB	(R8)			;IS SYMBOL RELOCATABLE?
	BNEQ	10$			;IIF NEQ YES
	BISW2	#SYM$M_ABS,SYM$W_FLAG(R0) ;NO--MAKE ABSOLUTE
	BRB	20$
10$:	BICW2	#SYM$M_ABS,SYM$W_FLAG(R0) ;YES--MAKE RELOCATABLE
20$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE NEWLINE COMMAND.  THE LINE NUMBER
;	PASSED IS MERELY STORED IN 'MAC$GL_P2_LINE'
;
;--

P2$NEWL::
	MOVZWL	(R8),W^MAC$GL_P2_LINE	;RECORD THE LINE NUMBER
	RSB

	.SBTTL	ALIGN SOURCE AND LISTING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE  ALIGNS THE LISTING FILE WITH THE SOURCE FILE.
;	SOURCE LINES ARE READ AND WRITTEN UNTIL MAC$GL_LINENUM IS
;	CAUGHT UP WITH MAC$GL_P2_LINE.
;
;--

P2$CHKL::
	BBCC	#FLG$V_MACL,(R11),10$	;MACRO LINE PRESENT (AND CLEAR FLAG)?
	BSBW	DUMP_MACRO		;YES--COPY INTO LINEBF
10$:	PUSHL	W^MAC$GL_LIST_IT	;SAVE LISTING FLAG
20$:	CMPL	W^MAC$GL_P2_LINE,W^MAC$GL_LINENUM ;ARE WE CAUGHT UP?
	BLEQ	40$			;IF LEQ YES
	MOVL	(SP),W^MAC$GL_LIST_IT	;NO--SET LISTING FLAG
	BSBW	MAC$WRTLST		;WRITE CURRENT LINE
	BSBW	MAC$GETLIN		;GET NEXT LINE
	BBCC	#FLG$V_MACLTB,(R11),25$	;NO TEXT IN MACRO BUFFER
25$:	PUSHL	W^MAC$GL_LIST_PTR	;SAVE LINE POINTER
	BSB	MAC$FORM_LINENO		; Form line no, audit trail
	POPL	W^MAC$GL_LIST_PTR	;RESTORE POINTER
	BRB	20$			;LOOP TILL WE CATCH UP
40$:	TSTL	(SP)+			;KEEP STACK CLEAN
	RSB

	.SBTTL	FORM LINE NUMBER AND AUDIT TRAIL

;++
; Functional description:
;
;	This routine forms the line number and audit trail of the
;	current line
;
; --
;
MAC$FORM_LINENO::
	MOVAB	W^MAC$AB_LST_LIN-1, -	; Point to where line number goes
		W^MAC$GL_LIST_PTR
	MOVZWL	W^MAC$GW_LST_LINE,R0	; Get listing line number
	MOVAL	W^MAC$GT_SCB,R6		; Set pointer to SUM control block
	BBC	#FLG$V_UPDFIL,(R11),10$	; Branch if file is not being updated
	BBS	#SUM_V_SRCUPD, -	; Branch if line is from update file
		SUM_B_FLAGS(R6),20$
10$:
	BSBW	MAC$DEC_OUT_R2L		; Output to listing
	BBCC	#SUM_V_DELETE, -	; Branch if no deleted line information
		SUM_B_FLAGS(R6),30$
	MOVAB	W^MAC$AB_LST_END,R1	; Set pointer to start of line
	MOVB	#^A/-/,(R1)+		; Insert '-'
	MOVZWL	SUM_W_INSERT_NO(R6),R0	; Get number of lines deleted
	BSBW	MAC$DEC_OUT_L2X		; Output to listing
	BRB	30$
20$:
	MOVZWL	SUM_W_INSERT_NO(R6),R0	; Get insert number
	BSBW	MAC$DEC_OUT_R2L		; Output to listing
	DECL	W^MAC$GL_LIST_PTR	; Decrement listing pointer
	MOVB	#^A/./,@W^MAC$GL_LIST_PTR ; and insert '.'
	BBC	#SUM_V_AUDIT,SUM_B_FLAGS(R6),30$ ; Branch if audit trail is off
	MOVC3	SUM_Q_AUDDS(R6), -	; Copy audit string to listing line
		@SUM_Q_AUDDS+4(R6),W^MAC$AB_LST_END
30$:
	RSB

	.SBTTL	ERROR TEXT HANDLING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE COPIES THE ERROR/WARN/PRINT TEXT INTO ETXBUF
;	TO MAKE IT AVAILABLE FOR PASS 2 HANDLING.
;
;--

P2$ETX::
	MOVZWL	(R8)+,R0		;GET THE LENGTH OF THE LINE
	MOVL	R0,W^MAC$GL_ETXLEN	;SET ITS LENGTH
	BLEQ	10$			;IF LEQ NO LINE TO SPEAK OF
	MOVC3	R0,(R8),W^MAC$AB_ETXBUF	;COPY INTO ERROR TEXT BUFFER
10$:	RSB

	.SBTTL	STORE MACRO SOURCE TEXT PASSED TO PASS 2

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE COPIES THE MACRO SOURCE LINE FROM THE INT. BUFFER
;	INTO THE MACRO LINE BUFFER, MAC$AB_TMPBUF.
;
;--

P2$MACL::
	BBCS	#FLG$V_MACL,(R11),10$	;IS THERE A MACRO LINE PRESENT?
	BSBB	DUMP_MACRO		;YES--COPY INTO LINE BUFFER
10$:	MOVZWL	(R8)+,R0		;GET LENGTH OF MACRO LINE
	MOVL	R0,W^MAC$GL_MLIN_LEN	;SAVE LENGTH OF LINE
	BLEQ	20$			;IF NULL LINE WE ARE DONE
	MOVC3	R0,(R8),W^MAC$AB_TMPBUF	;COPY LINE INTO MACRO LINE BUFFER
20$:	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WRITES THE CURRENT LISTING LINE, AND THEN
;	COPIES THE MACRO LINE FROM THE MACRO BUFFER (MAC$AB_TMPBUF)
;	INTO THE LINE BUFFER.
;
;--

DUMP_MACRO:
	BSBW	MAC$WRTLST		;WRITE CURRENT LINE
	MOVL	W^MAC$GL_MLIN_LEN,R0	;GET LENGTH OF MACRO LINE
	MOVL	R0,W^MAC$GL_LINELN	;SET THE LINE LENGTH
	BLEQ	10$			;IF LEQ DONE
	MOVC3	R0,W^MAC$AB_TMPBUF,-	;COPY LINE INTO LINE BUFFER
		W^MAC$AB_LINEBF
10$:	BBCS	#FLG$V_MACLTB,(R11),20$	;FLAG MACRO TEXT IN BUFFER
20$:	RSB

	.SBTTL	FORCE NEW LINE, PRINT LITERAL, SUBTITLE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE FORCES A NEW LISTING LINE, AND PRESERVES
;	THE PREVIOUS STATE OF THE LISTING FLAG MAC$GL_LIST_IT.
;
;--

P2$FNEWL::
	PUSHL	W^MAC$GL_LIST_IT	;SAVE LISTING FLAG
	BSBW	MAC$WRTLST		;FORCE NEW LINE
	POPL	W^MAC$GL_LIST_IT	;RESTORE LISTING FLAG
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PRINTS A LITERAL.  THE PC IS NOT AUGMENTED.
;
;--

P2$PRIL::
	$VPUSH	(R8)			;STACK THE VALUE TO PRINT
	TSTL	(R5)+			;KEEP R5 POINTING TO TOP OF STACK
	$MAC_LIST_BYTE #4
	$DEC_PC	#4			;DON'T INCREMENT PC THOUGH
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE COPIES THE SUBTITLE FROM THE INTERMEDIATE
;	BUFFER INTO THE SUBTITLE BUFFER, SO IT IS AVAILABLE FOR
;	LISTING PAGES.
;
;--

P2$SBTTL::
	MOVZBL	(R8)+,R0		;GET LENGTH OF SUBTITLE
	MOVC5	R0,(R8),#^A/ /,-	;COPY INTO THE SUBTITLE BUFFER
		#LST$K_TITLE_SIZ,-
		W^MAC$AB_SBT_SBTL
	RSB

	.SBTTL	SET LONGWORD VALUE, SET AND CLEAR FLAGS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO  SET THE VALUE CONTAINED IN
;	THE FIRST LONGWORD INTO THE LONGWORD POINTED TO BY
;	THE SECOND LONGWORD.  THIS IS USED FOR SETTING/CLEARING
;	LONGWORD FLAGS.
;
;--

P2$SETLONG::
	MOVL	(R8)+,@(R8)		;STORE THE LONGWORD
	RSB				;ALL DONE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE TWO ROUTINES, P2$SETFLAG AND P2$CLRFLAG, SET AND
;	CLEAR FLAGS IN THE MACRO FLAGS WORD MAC$GL_FLAGS.  THE
;	ONE BYTE OF DATA IS THE FLAG NUMBER TO SET/CLEAR.
;
;--

P2$SETFLAG::
	MOVZBL	(R8),R0			;GET FLAG NUMBER
	BBCS	R0,(R11),.+1		;SET THE FLAG
	RSB

P2$CLRFLAG::
	MOVZBL	(R8),R0			;GET FLAG NUMBER
	BBCC	R0,(R11),.+1		;CLEAR THE FLAG
	RSB

	.SBTTL	PASS 2 ERROR PROCESSING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES ERRORS DETECTED DURING PASS 2.
;	IT SETS UP A TWO LONGWORD BLOCK AND CALLS THE ERROR
;	PROCESSOR.
;
; INPUTS:
;
;	R0	MESSAGE INDEX
;
;--

MAC$PASS_2_ERR::
	PUSHL	R8			;SAVE INT. BUFFER POINTER
	MOVAB	W^MAC$GL_P2_ERRPT+4,R8	;POINT TO TEMP BUFFER
	CLRL	(R8)			; No error pointer
	MOVL	R0,-(R8)		;SET ERROR CODE
	BSBB	P2$ERR			;PROCESS THE ERROR
	POPL	R8			;RESTORE POINTER
	RSB

	.SBTTL	.PRINT DIRECTIVE PROCESSING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DOES THE PASS 2 PART OF .PRINT DIRECTIVE PROCESSING.
;	IF THERE WAS AN EXPRESSION, THE EXPRESSION IS SET INTO THE
;	BUFFER, FOLLOWED BY THE STRING FOLLOWING THE SEMI-COLON IN
;	THE .PRINT DIRECTIVE.  THE WHOLE LINE IS THEN OUTPUT TO THE
;	TERMINAL AND THE LISTING (IF THERE IS ONE).
;
;--

P2$PRT::
	BSBW	MAC$WRTLST		;WRITE LINE TO LISTING IF WE CAN
	PUSHL	W^MAC$GL_LIST_LVL	;SAVE LISTING LEVEL
	MOVZWL	#100,W^MAC$GL_LIST_LVL	;ENSURE IT GETS LISTED
	PUSHR	#^M<R5,R6,R7>		;SAVE REGISTERS
	MOVAB	W^MAC$AB_LST_END,R1	;POINT TO THE START OF THE BUFFER
	BSBB	GET_VAL_AND_TXT		;SET VALUE AND TEXT INTO BUFFER
	SUBL2	#MAC$AB_LINEBF,R3	;FIGURE LENGTH OF LINE
	MOVL	R3,W^MAC$GL_LINELN	;SET FOR OUTPUT ROUTINES
	BSBW	MAC$WRITE_TERM		;WRITE LINE TO TERMINAL
	POPR	#^M<R5,R6,R7>		;RESTORE REGISTERS
	POPL	W^MAC$GL_LIST_LVL	;AND THE LISTING LEVEL
	CLRL	W^MAC$GL_VALUE		;ENSURE NO CARRY-OVER
	MNEGL	#MAC$K_LIST_SIZE,W^MAC$GL_LINELN ;PREVENT PRINTING
						; OF LINE IN LISTING
	RSB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE GETS THE VALUE (IF ANY) SUPPLIED WITH
;	.ERROR/.WARN/.PRINT DIRECTIVES AND SETS IT INTO THE
;	BUFFER.  IT THEN STORES THE TEXT IN THE BUFFER.
;
; INPUTS:
;
;	R1	BUFFER POINTER
;
; OUTPUTS:
;
;	R3	UPDATED POINTER
;
;--

GET_VAL_AND_TXT:
	MOVL	W^MAC$GL_VALUE,R0	;GET THE EXPRESSION VALUE
	BEQL	10$			;BRANCH IF NO EXPRESSION
	BSBW	MAC$DEC_OUT_L2X		;OUTPUT EXPRESSION INTO BUFFER
	MOVL	R0,R1			;SET UPDATED POINTER
	MOVB	#^A/ /,(R1)+		;SEPARATE BY A SPACE
10$:	MOVL	R1,R3			;POSITION POINTER INTO R3
	MOVL	W^MAC$GL_ETXLEN,R6	;GET LENGTH OF TEXT LINE
	LOCC	#^A/;/,R6,W^MAC$AB_ETXBUF ;LOCATE THE SEMI-COLON IN TEXT
	BEQL	20$			;IF EQL NO SEMI-COLON--NO TEXT
	DECL	R0			;DON'T COUNT THE SEMI-COLON
	MOVC3	R0,1(R1),(R3)		;COPY TEXT INTO OUTPUT BUFFER
20$:	RSB				;DONE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES PROCESS ERRORS.  THE TWO LONGWORDS OF DATA ARE
;	1) THE MESSAGE INDEX AND 2)THE LINE POINTER (POINTING TO THE ERROR)
;
;--

P2$INFO::
	INCL	W^MAC$GL_INFOCNT	; Count an information message
	BRB	ERR_COM			; Join common code

P2$WRN::
	INCL	W^MAC$GL_WARNCT		;COUNT A WARNING
	BRB	ERR_COM			;JOIN COMMON CODE

P2$ERR::
	INCL	W^MAC$GL_ERRCT		;COUNT AN ERROR

ERR_COM:
	PUSHL	W^MAC$GL_LIST_LVL	;SAVE CURRENT LISTING LEVEL
	MOVZWL	#100,W^MAC$GL_LIST_LVL	;ENSURE ERRORS GET LISTED
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R9,R12> ;SAVE REGISTERS
;
; SAVE THE LINE/PAGE IN VIRTUAL MEMORY FOR PRINTING AT END
;
	MOVAB	W^MAC$GL_ERR_LIST+4,R0	;POINT TO ERROR LIST HEAD
	MOVL	(R0),R9			;GET LAST BLOCK OF ERRORS ADDRESS
	MOVAB	8(R9),R6		;POINT TO BOOKEEPING WORDS IN CASE IT EXISTS
	CMPL	R9,@-4(R0)		;DOES THE LIST EXIST?
	BNEQ	20$			;IF NEQ YES
;
; ALLOCATE TWO PAGES TO STORE LINES/PAGES ON
;
10$:	BSBW	MAC$ALL_2_PAGES		;ALLOCATE TWO PAGES OF VM
	MOVL	R0,R9			;POINT TO THE BLOCK
	MOVAB	8(R9),R6		;POINT R6 PAST 2 LONGWORDS OF QUEUE LINKS
	INSQUE	(R9),@W^MAC$GL_ERR_LIST+4 ;INSERT INTO THE ERROR QUEUE
	MOVAB	16(R9),(R6)		;SET POINTER TO FIRST FREE
	MOVZWL	#<<1024-16>/8>,12(R9)	;SET COUNT OF LINES/PAGES IN THIS CHUNK
20$:	TSTL	12(R9)			;SEE IF ROOM IN THIS CHUNK
	BLEQ	10$			;IF LEQ NO--ALLOCATE ONE
	MOVL	(R6),R9			;YES--GET POINTER TO FREE SPOT
	MOVZWL	W^MAC$GW_LST_LINE,R0	; Get listing line number
	ASHL	#16,R0,R0		; Shift to upper word (lower owrd 0)
	BBC	#FLG$V_UPDFIL,(R11),25$	; Branch if file  not being updated
	BBC	#SUM_V_SRCUPD, -	; Branch if line form source file
		W^MAC$GT_SCB+SUM_B_FLAGS,25$
	MOVW	W^MAC$GW_LST_INST,R0	; Put insert number into low word
25$:	MOVL	W^MAC$GL_SRCPAG,R1	;AND CURRENT PAGE NUMBER
	CMPL	R0,-4(R9)		;LINE/PAGE ALREADY RECORDED?
	BNEQ	30$			;IF NEQ NO
	CMPL	R1,-8(R9)		;MAYBE--WHAT ABOUT PAGE?
	BEQL	40$			;IF EQL YES
30$:	MOVL	R1,(R9)+		;STORE PAGE NUMBER
	MOVL	R0,(R9)+		;AND LINE NUMBER
	MOVL	R9,(R6)+		;SET POINTER TO NEXT FREE
	DECL	(R6)			;DECREASE COUNT OF REMAINING SPACE
40$:
ERR_COM_0:
	CLRL	R9			; Assume not generated error or warning
	TSTW	2(R8)			; Is facility value zero?
	BNEQ	3$			; No if NEQ
	BISW	#<MAC$_NORMAL@-16>,2(R8) ; Make it a MACRO error
	BRB	6$
3$:
	CMPW	2(R8),#<SUM$_NORMAL@-16> ; Is it a SUM error?
	BEQL	30$			; Yes if EQL
6$:
	CMPW	(R8),#<MAC$_GENERR&^XFFFF> ; Is this a generated warning?
	BEQL	10$			; Yes if EQL
	CMPW	(R8),#<MAC$_GENWRN&^XFFFF> ; of a generated error?
	BNEQ	20$			; No if NEQ
10$:	INCL	R9			; Flag generated error/warning
	BRB	30$			;AND SKIP PRINTING ON TERMINAL
;
; FIGURE COLUMN OF ERROR AND SAVE FOR LATER.  MUST BE DONE NOW SINCE
; WRTLST RE-INITIALIZES THE BUFFER.
;
20$:	MOVAB	W^MAC$AB_LINEBF,R6	;POINT TO THE SOURCE BUFFER
	CLRL	R4			;INIT COLUMN COUNT
	TSTL	4(R8)			; Is there an error pointer?
	BEQL	25$			; No if EQL
21$:	CMPB	(R6)+,#TAB		;IS THIS A TAB?
	BNEQ	22$			;IF NEQ NO
	BISL2	#7,R4			;YES--SKIP TO NEXT TAB STOP
22$:	INCL	R4			;NEXT CHARACTER POSITION
	CMPL	R6,4(R8)		;UP TO THE ERROR YET?
	BLSSU	21$			;IF LSSU NO
	DECL	R4			; Need 1 less space so that error
					; pointer is at this position
	CMPL	R4,#132			; Over end of line?
	BLSS	25$			; No if LSS
	CLRL	R4			; Don't have error pointer
25$:
	BSBW	MAC$WRITE_TERM		;WRITE LINE TO TERMINAL
	BSBW	MAC$WRTLST		;WRITE LINE TO LISTING FILE
30$:
	$GETMSG_S (R8),W^MAC$GL_LINEPT, - ; Get message text
		  L^MAC$GQ_LISTBFDS
	ADDL3	W^MAC$GL_LINEPT, -	; Set pointer
		L^MAC$GQ_LISTBFDS+4,R3
	MOVL	R3,R6			;UPDATE POINTER
	BLBC	R9,35$			; Branch if not generated error/warning
	MOVL	R6,R1			;YES--SET POINTER
	pushl	r4			; Protect the column count.
	BSBW	GET_VAL_AND_TXT		;GET THE VALUE AND TEXT
	popl	r4
	MOVL	R3,R6			;SET UPDATED POINTER
	BRB	60$			;JOIN COMMON CODE
;
; PAD LINE WITH SPACES UP TO THE POINT OF THE ERROR
;
35$:	SUBL3	#MAC$AB_LINEBF,R6,R5	;FIGURE CURRENT COLUMN
	TSTL	R4			; Is there to be an error pointer?
	BEQL	60$			; No if EQL
40$:	CMPL	R5,R4			;HAVE WE PADDED ENOUGH?
	BGEQ	50$			;IF GEQ YES
	MOVB	#^A/ /,(R6)+		;NO--PAD WITH SPACES
	INCL	R5			;MOVE TO NEXT COLUMN
	BRB	40$			;CONTINUE TILL DONE
;
; NOW POINT TO ERROR WITH EXCLAMATION MARK
;
50$:	MOVB	#^A/!/,(R6)+		;MARK THE ERROR
60$:	SUBL3	#MAC$AB_LINEBF,R6,R0	;FIGURE LENGTH OF LINE
	MOVZWL	R0,W^MAC$GL_LINELN	;SAVE FOR OUTPUT ROUTINES
	BSBW	MAC$WRITE_TERM		;WRITE TO THE TERMINAL
	BSBW	MAC$WRTLST		;WRITE TO LISTING
80$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R9,R12> ;RESTORE REGISTERS
	POPL	W^MAC$GL_LIST_LVL	;RESTORE LISTING LEVEL
	CLRL	W^MAC$GL_VALUE		;ENSURE NO CARRY-OVER ON VALUE
	RSB

;++
; Functional description:
;
;	This routine reports Source_update-merge errors
;
;--

P2$SUME::
	BSBW	MAC$GETLIN		; Get error line into buffer
	MOVAB	W^MAC$AB_LST_END,R6	; Set pointer to start of line
	MOVZWL	W^MAC$GL_LINELN,R8	; Get line length
	MOVC3	R8,W^MAC$AB_LINEBF,(R6)	; Copy to start of line
	ADDL2	#2,R8			; Insert two spaces
	ADDL2	R8,R6			; Point to end of line
	MOVW	#^A/  /,(R6)+
	MOVAB	MAC$GT_SCB,R8		; Get address of SUM control block
	MOVC3	SUM_Q_FILESP+0(R8), -	; Copy file specificaition
		@SUM_Q_FILESP+4(R8),(R6) ; to line
	ADDW2	SUM_Q_FILESP+0(R8),R6	; Point to end of line
	SUBL3	#MAC$AB_LINEBF,R6,R0	; Figure length of line
	MOVZWL	R0,W^MAC$GL_LINELN	; and save for output routines
	BSBW	MAC$WRITE_TERM		; Write to terminal
	BSBW	MAC$WRTLST		; and to listing file
	RSB

	.END
