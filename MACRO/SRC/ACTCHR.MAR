	.TITLE	MAC$ACTCHR	CHARACTER  STRING ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 21-AUG-78
;
; MODIFIED BY:
;
;	V02.02	MTR0001		Mike Rhodes	02-Feb-1982
;		Set FLG$V_DLIMSTR to pass ALL characters in a
;		delimited .ASCIx string.  Fix for QAR #890 and
;		SPR #11-42904.
;
;	V02.01  PCG0001		Peter George	10-Apr-1981
;		Clear registers and modes after NTYPE.
;
;	V01.12	RN0023		R. Newland	 2-Nov-1979
;		New message codes to get error message from system
;		message file.
;
;	V01.11	RN0016		R. Newland	19-Oct-1979
;		Don't output error messages when .NTYPE operand
;		argument is the PC.  SPR 11-26392
;
;	V01.10	RN0005		R. Newland	26-Aug-1979
;		Reorder macro definitions and remove .ALIGN LONG
;		and .DEBUG statements
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_INTCODDEF			;DEFINE INT. FILE CODES
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_INPBLKDEF			;DEFINE INPUT BLOCK OFFSETS
	$MAC_GRAMMARDEF			;DEFINE TERMINAL GRAMMER SYMBOLS
	$DSCDEF				;DEFINE ARG DESCRIPTORS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS
;

	ASC$_ASCIC	=	0		;ASCIC CODE
	ASC$_ASCID	=	1		;ASCID
	ASC$_ASCII	=	2		;ASCII
	ASC$_ASCIZ	=	3		;ASCIZ

	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

	.SBTTL	CHARACTER DATA GENERATING DIRECTIVES

;++
; FUNCTIONAL DESCRIPTION:
;
;	ASCIC IS CALLED WHEN A .ASCIC DIRECTIVE IS FOUND.  THE ASCII
;	STRING IS EMITTED WITH A PRECEDING COUNT BYTE
;
;--

ASCIC::					;CHAR_HEAD = KASCIC
	$INTOUT_LW INT$_STKL,#0		;STACK A 0
	$INTOUT_X INT$_STSB		;STORE SIGNED BYTE
	$INC_PC				;LEAVE ROOM FOR COUNT BYTE
	BSBB	ASC_COM			;JOIN COMMON CODE
	.BYTE	ASC$_ASCIC		;THIS IS INDEX FOR ASCIC

;++
; FUNCTIONAL DESCRIPTION:
;
;	ASCID IS CALLED WHEN A .ASCID DIRECTIVE IS FOUND.  THE
;	ASCII STRING IS EMITTED WITH A PRECEDING STRING DESCRIPTOR
;	CONSISTING OF '.LONG STRING_LENGTH,.+1'.
;
;--

ASCID::
	$INTOUT_LW INT$_STKL,#<<1@24>+<DSC$K_DTYPE_T@16>> ;START STRING DESCRIPTOR
	$INTOUT_X  INT$_STOL		;AND STORE IT
	$INC_PC	#4			;COUNT 4 BYTES
	$INTOUT_X  INT$_STKPC		;STACK CURRENT PC
	$INTOUT_LW INT$_STKL,#4		;4 BYTES PLUS 1
	$INTOUT_X  INT$_ADD		;POINT TO THE START OF THE STRING
	$INTOUT_X  INT$_SPID		;CALL IT PID?
	$INC_PC	#4			;COUNT 4 MORE BYTES
	BSBB	ASC_COM			;JOIN COMMON CODE
	.BYTE	ASC$_ASCID		;INDEX FOR ASCID

;++
; FUNCTIONAL DESCRIPTION:
;
;	ASCII IS CALLED TO PROCESS A .ASCII DIRECTIVE.  THE ASCII
;	STRING IS SCANNED AND CODE IS  EMITTED TO PASS 2 TO EMIT
;	THE STRING.
;
;--

ASCII::					;CHAR_HEAD = KASCII
	BSBB	ASC_COM			;JOIN COMMON CODE
	.BYTE	ASC$_ASCII		;INDEX FOR ASCII

;++
; FUNCTIONAL DESCRIPTION:
;
;	ASCIZ IS CALLED WHEN A .ASCIZ DIRECTIVE IS SCANNED.  THE
;	ASCII STRING IS EMITTED WITH A ZERO BYTE AT THE END.
;
;--

ASCIZ::					;CHAR_HEAD = KASCIZ
	BSBB	ASC_COM			;JOIN COMMON CODE
	.BYTE	ASC$_ASCIZ		;INDEX FOR ASCIZ
;
; COMMON CODE FOR ASCIC/ASCID/ASCII/ASCIZ
;
ASC_COM:
	MOVZBL	@(SP)+,W^MAC$GL_DIRFLG	;SET ASCIX INDEX
	CMPB	R10,#CR			;WAS THERE NO DELIMITER?
	BEQL	10$			;IF EQL YES--SYNTAX ERROR
	BBCS	#FLG$V_DLIMSTR,(R11),.+1 ;PASS ALL CHARACTERS IN STR.
	CLRL	W^MAC$GL_ASCCNT		;CLEAR  CHARACTER COUNT
	DECL	W^MAC$GL_LINEPT		;BACKUP TO REREAD DELIMITER
	BSBW	MAC$GETCHR		;REREAD DELIMITER
	BRB	GET_CHARS		;START SCANNING ASCII STRING
10$:	$MAC_ERR DIRSYNX		; Report syntax error
	BRW	MAC$ERRORPT		;AND RETURN

;++
; FUNCTIONAL DESCRIPTION:
;
;	CHRNUL IS CALLED WHEN A NULL CHARACTER '<>' IS SEEN WHILE
;	SCANNING AN ASCIX DIRECTIVE.  A NULL BYTE IS EMITTED AND
;	SCANNING CONTINUES.
;
;--

CHRNUL::				;CHAR_ARGS = DANGOPN DANGCLS
					;CHAR_ARGS = CHAR_ARGS DANGOPN DANGCLS
	CLRL	R0			;SET TO STORE NULL IMMED. BYTE
	BSBW	MAC$INTOUT_BY		;STORE IMMEDIATE BYTE
	$INC_PC				;COUNT THE CHARACTER
	INCL	W^MAC$GL_ASCCNT		;...
	BRB	GET_CHARS		;CONTINUE SCANNING STRING

;++
; FUNCTIONAL DESCRIPTION:
;
;	CHRARG IS CALLED WHEN AN EXPRESSION IN ANGLE BRACKETS IS
;	ENCOUNTERED WHILE SCANNING AN ASCIX STRING.  WHEN THE
;	ROUTINE 'GET_CHARS' FINDS AN ANGLE BRACKET, IT RETURNS TO
;	THE PARSER.  AFTER THE EXPRESSION IN ANGLE BRACKETS IS
;	SCANNED, THIS ROUTINE IS CALLED TO STORE THE EXPRESSION. 
;	SCANNING OF THE STRING THEN CONTINUES UNTIL END-OF-LINE.
;
;--

CHRARG::				;CHAR_ARGS = DANGOPN EXPR DANGCLS
					;CHAR_ARGS = CHAR_ARGS DANGOPN EXPR DANGCLS
	TSTL	W^MAC$GL_ABSFLAG	;ABSOLUTE EXPRESSION?
	BEQL	10$			;IF EQL YES
	BBSC	#FLG$V_EXPOPT,(R11),20$	;NO--DO NOT ALLOW EXPRESSION OPTIMIZATION
10$:	BBC	#FLG$V_EXPOPT,(R11),20$	;BRANCH IF CANNOT OPTIMIZE
	BSBW	MAC$OPTIMIZEXPR		;YES--DO IT
	MOVL	W^MAC$AL_VALSTACK-4[R7],R0 ;SET TO STORE IMMED. BYTE
	BSBW	MAC$INTOUT_BY		;STORE IMMEDIATE BYTE
	BRB	30$			;CONTINUE
20$:	$INTOUT_X INT$_STOB		;STORE BYTE
30$:	$INC_PC				;COUNT THE BYTE
	INCL	W^MAC$GL_ASCCNT		;...
;**;	BRB	GET_CHARS		;CONTINUE SCANNING STRING

;++
; FUNCTIONAL DESCRIPTION:
;
;	GET_CHARS IS A LOCAL ROUTINE TO SCAN ASCIX STRINGS.  ALL
;	CHARACTERS ARE PASSED.  THE STRING IS SCANNED UNTIL AN
;	END-OF-LINE.  IF A BRACKETED EXPRESSION IS FOUND, GET_CHARS
;	RETURNS TO THE PARSER TO GATHER THE EXPRESSION WITHIN THE
;	ANGLE BRACKETS, AND THEN CALL CHRARG TO STORE THE EXPRESSION
;	VALUE AND CONTINUE THE SCAN.
;
;--

GET_CHARS:
	BBCS	#FLG$V_EVALEXPR,(R11),.+1 ;ALLOW EXPRESSION EVALUATION
20$:	BSBW	MAC$SKIPSP		;IGNORE BLANKS
	CMPB	R10,#CR			;CARRIAGE RETURN?
	BEQL	70$			;IF EQL YES
	CMPB	R10,#^A/</		;NO--BRACKETED EXPRESSION?
	BEQL	70$			;IF EQL YES
	MOVB	R10,-(SP)		;NO--SAVE DELIMITER
	BBCS	#FLG$V_DLIMSTR,(R11),.+1 ;PASS ALL CHARS IN DLIM STR
	BBCS	#FLG$V_ALLCHR,(R11),30$	;PASS ALL CHARACTERS
30$:	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	CMPB	R10,(SP)		;MATCHING DELIMITER?
	BNEQ	40$			;IF NEQ NO
	BBSC	#FLG$V_ALLCHR,(R11),.+1	;YES--CLEAR ALL CHARS FLAG
	BBSC	#FLG$V_DLIMSTR,(R11),.+1 ; NO MORE HYPHENS AND SEMIS
	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	BRB	60$			;AND EXIT
40$:	CMPB	R10,#CR			;END OF LINE?
	BNEQ	50$			;IF NEQ NO
	$MAC_ERR UNTERMARG		; Yes--get message code
	BSBW	MAC$ERRORLN		;REPORT ERROR TO PASS 2
	BRB	60$			;EXIT
50$:	MOVL	R10,R0			;SET TO STORE IMMED. BYTE
	BSBW	MAC$INTOUT_BY		;STORE IMMEDIATE BYTE
	$INC_PC				;UP THE PC
	INCL	W^MAC$GL_ASCCNT		;COUNT THE CHARACTER
	BBCS	#FLG$V_DLIMSTR,(R11),.+1 ;ALLOW HYPHENS AND SEMIS
	BRB	30$			;CONTINUE SCANNING
;
; HERE IF CLOSING DELIMITER SEEN OR IF WE FOUND CR BEFORE CLOSING
; DELIMITER
;
60$:	INCL	SP			;KEEP THE STACK STRAIGHT
	BBCC	#FLG$V_ALLCHR,(R11),65$	;DO NOT PASS ALL CHARACTERS
65$:	CMPB	R10,#CR			;END OF LINE?
	BNEQ	20$			;IF NEQ NO--KEEP SCANNING
70$:	BBCC	#FLG$V_DLIMSTR,(R11),.+1 ;NO MORE HYPHENS AND SEMIS
	BBCS	#FLG$V_EXPOPT,(R11),.+1	;ALLOW EXPRESSION OPTIMIZATION
	BBCC	#FLG$V_ALLCHR,(R11),.+1	;DO NOT PASS SEMI COLONS ANY MORE
	MOVL	R9,W^MAC$GL_EXPPTR	;RESET EXPRESSION POINTERS
	MOVL	R9,W^MAC$GL_EXPEND	;...
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE EXPRESSION
	CLRL	W^MAC$GL_PRMSEG		;NO SEGMENT FOR EXPRESSION
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	CHARHD IS CALLED WHEN A .ASCIX DIRECTIVE HAS BEEN COMPLETELY
;	SCANNED.  ACTION TAKEN:
;
;	.ASCIC - EMIT THE CHARACTER COUNT BYTE
;	.ASCID - EMIT THE CHARACTER STRING DESCRIPTOR
;	.ASCII - NONE
;	.ASCIZ - EMIT A ZERO BYTE AT THE END OF THE STRING
;
;--

CHARHD::				;CHAR_STAT = CHAR_HEAD
					;CHAR_STAT = CHAR_HEAD CHAR_ARGS

	CASEB	W^MAC$GL_DIRFLG,#ASC$_ASCIC,- ;DISPATCH
			#ASC$_ASCIZ
10$:	.WORD	20$-10$			;ASCIC
	.WORD	30$-10$			;ASCID
	.WORD	40$-10$			;ASCII
	.WORD	50$-10$			;ASCIZ
	RSB				;NONE OF ABOVE

20$:	MOVL	W^MAC$GL_ASCCNT,R4	;ASCIC--GET LENGTH
	CMPL	R4,#255			;IS THE STRING TOO LONG?
	BLSSU	25$			;IF LSSU NO
	$MAC_ERR ASCTOOLONG		; Yes--get error code
	BSBW	MAC$ERRORLN		;REPORT THE ERROR
25$:	INCL	R4			;WHAT WE REALLY WANT IS LENGTH + 1
	BSBB	60$			;DO COMMON PART OF PROCESSING
	MOVL	W^MAC$GL_ASCCNT,R0	;GET THE CHARACTER COUNT
	BSBW	MAC$INTOUT_BY		;STORE IMMEDIATE BYTE
	$INTOUT_LW INT$_AUGPC,<W^MAC$GL_ASCCNT> ;RESET PC
	BRB	35$			;AND GO FINISH UP

30$:	MOVL	W^MAC$GL_ASCCNT,R4	;ASCID--GET CHARACTER COUNT
	CMPL	R4,#^XFFFF		;IS THE COUNT TOO LARGE?
	BLSSU	33$			;IF LSSU NO
	$MAC_ERR ASCTOOLONG		; Yes--get error code
	BSBW	MAC$ERRORLN		;REPORT ERROR TO PASS 2
33$:	ADDL2	#8,R4			;WHAT WE NEED IS LENGTH + 8
	BSBB	60$			;DO COMMON PROCESSING
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;DON'T LIST LINE
	MOVL	W^MAC$GL_ASCCNT,R4	;GET THE BYTE COUNT
	$INTOUT_LW INT$_STKL,R4		;STACK THE LONGWORD
	$INTOUT_X INT$_STOW		;STORE WORD
	ADDL3	#6,W^MAC$GL_ASCCNT,R2	;FIGURE PC ADJUSTMENT
	$INTOUT_LW INT$_AUGPC,<R2>	;RESET PC
	ADDL2	#8,R4			;UPDATE PC ADJUSTMENT
35$:	$INC_PC	R4			;RESTORE PC
	RSB

40$:					;ASCII
	RSB

50$:					;ASCIZ
	CLRL	R0			;SET TO STORE ZERO BYTE
	BSBW	MAC$INTOUT_BY		;STORE IMMEDIATE BYTE
	$INC_PC				;COUNT IT
	RSB
;
; COMMON ROUTINE FOR ASCIC AND ASCID
;
60$:	$DEC_PC	R4			;BACK UP PC
	MNEGL	R4,R3			;GET TWO'S COMPLEMENT OF LENGTH
	MOVZBL	#3,R0			;SET TO STORE 3 BYTES
	BSBW	MAC$INTOUT_N		;...
	MOVB	#INT$_SETFLAG,(R9)+	;CODE IS SET FLAG
	MOVB	#FLG$V_MEBLST,(R9)+	;FLAG # TO SET
	$INTOUT_LW INT$_AUGPC,R3	;BACKUP PC IN PASS 2
	$INTOUT_X INT$_FNEWL		;FORCE NEW LISTING LINE
	RSB

	.SBTTL	PACKED DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE READS A DECIMAL NUMBER WITH AN OPTIONAL LEADING
;	SIGN.  THE NUMBER IS THEN CONVERTED TO A PACKED DECIMAL STRING
;	AND OUTPUT TO THE INTERMEDIATE CODE AS A STRING OF STORE IMMEDIATE
;	BYTES.
;
;--

PACKED::				;DIRECTIVE = KPACKED
	BSBW	MAC$SKIPSP		;SKIP LEADING SPACES
	MOVB	#12,-(SP)		;ASSUME POSITIVE NUMBER
	CMPB	R10,#^A/+/		;WAS IT POSITIVE?
	BEQL	10$			;IF EQL YES
	CMPB	R10,#^A/-/		;NO--WAS IT NEGATIVE?
	BNEQ	20$			;NO--NO SIGN AT ALL
	MOVB	#13,(SP)		;YES--SET NEGATIVE SIGN
10$:	BSBW	MAC$GETCHR		;READ CHARACTER AFTER SIGN
20$:	CLRL	R6			;CLEAR DIGIT COUNTER
	MOVAB	W^MAC$AB_TMPBUF,R5	;POINT TO TEMP BUFFER
;
; HERE FOR EACH NEW CHARACTER
;
30$:	CMPB	R10,#^A/,/		;END OF NUMBER?
	BEQL	80$			;IF EQL YES
	CMPB	R10,#CR			;END OF LINE?
	BEQL	80$			;IF EQL YES
	BBC	#CHR$V_NUM_BER,-	;NO--IS CHARACTER A DIGIT?
		W^MAC$AB_CMSK_TAB(R10),50$ ;(BRANCH IF NOT)
	CMPL	R6,#31			;YES--ROOM TO STORE?
	BLSS	40$			;IF LSS YES
	$MAC_ERR PACTOOLONG		; No--string is too long
	BSBW	MAC$ERRORLN		;ISSUE ERROR
	BRB	70$			;
40$:	INCL	R6			;COUNT DIGIT WE STORE
	MOVB	R10,(R5)		;STORE DIGIT
	BICB2	#^XF0,(R5)+		;CONVERT TO BINARY DECIMAL
	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	BRB	30$			;CONTINUE CHECKING
50$:	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;GET TO A COMMA?
	BEQL	80$			;IF EQL YES
	CMPB	R10,#CR			;NO--EOL?
	BEQL	80$			;IF EQL YES
	$MAC_ERR NOTDECSTRG		; No-error
	BSBW	MAC$ERRORLN		;ISSUE ERROR MESSAGE
60$:	BSBW	MAC$GETCHR		;NEXT CHARACTER
70$:	CMPB	R10,#^A/,/		;GET TO COMMA?
	BEQL	80$			;IF EQL YES
	CMPB	R10,#CR			;NO--EOL?
	BNEQ	60$			;NO--KEEP LOOKING
;
; HERE WHEN DONE WITH NUMBER

80$:	TSTL	R6			;NULL STRING?
	BNEQ	90$			;IF NEQ NO
	CLRB	(R5)+			;YES--FAKE 0
	INCL	R6			;COUNT IT
90$:	MOVB	(SP)+,(R5)+		;STORE SIGN AT END OF STRING
	CMPB	R10,#^A/,/		;COMMA?
	BNEQ	140$			;IF NEQ NO
	PUSHL	R6			;YES--SAVE LENGTH
	BSBW	MAC$GETCHR		;GET NEXT CHR
	BSBW	MAC$SKIPSP		;SKIP SPACES
	BBC	#CHR$V_NUM_BER,-	;IS IT A LOCAL LABEL?
		W^MAC$AB_CMSK_TAB(R10),100$ ;(BRANCH IF NOT)
	BSBW	MAC$DNUMBER		;MAYBE--READ IT
	CMPL	R8,#ID			;WAS IT AN ID?
	BEQL	120$			;IF EQL YES--OK
	$MAC_ERR DIRSYNX		; No--syntax error
	BSBW	MAC$ERRORLN		;ISSUE ERROR
	BRB	130$			;
100$:	BSBW	MAC$SYMSCNUP		;SCAN SYMBOL NAME
	BLBS	R0,110$			;BRANCH IF GOT ONE
	$MAC_ERR DIRSYNX		; Syntax error
	BSBW	MAC$ERRORLN
	BRB	130$
110$:	BSBW	MAC$INSUSRSYMTB		;INSERT IN USER SYMTAB
120$:	BISW2	#SYM$M_DEF!SYM$M_ASN!SYM$M_ABS,- ;SET DEFINED BY ASSIGNMENT
		SYM$W_FLAG(R1)		;AND ABSOLUTE
	MOVL	(SP),SYM$L_VAL(R1)	;SET STRING LENGTH AS VALUE
	MOVZBL	#CRF$K_DEF,R5		;THIS IS A DEFINITION
	MOVL	R1,R6			;POINT R6 TO SYMBOL BLOCK
	BSBW	MAC$CREF_SYM		;CREF SYMBOL IF CREFFING
130$:	POPL	R6			;RESTORE LENGTH
140$:	ADDL3	#2,R6,R0		;ROUND NIBBLES UP TO BYTES
	ASHL	#-1,R0,R0		;R0 HAS NUMBER OF BYTES
	$INC_PC	R0			;UPDATE PC
	MOVAB	W^MAC$AB_TMPBUF,R5	;POINT TO TEMP BUFFER
	INCL	R6			;COUNT THE SIGN ALSO
	BLBC	R6,150$			;BRANCH IF EVEN NUMBER OF BYTES
	MOVB	(R5)+,R0		;NO--GET FIRST BYTE
	BSBW	MAC$INTOUT_BY		;EMIT TO PASS 2
	DECL	R6			;COUNT IT
150$:	TSTL	R6			;DONE?
	BLEQ	160$			;IF LEQ YES
	MOVB	(R5)+,R0		;NO--GET A NIBBLE
	ASHL	#4,R0,R0		;MAKE ROOM FOR OTHER NIBBLE
	BISB2	(R5)+,R0		;GET SECOND NIBBLE
	SUBL2	#2,R6			;EAT TWO BYTES
	BSBW	MAC$INTOUT_BY		;EMIT TO INTERM. BUFFER
	BRB	150$			;LOOP FOR ALL NIBBLES
160$:	RSB				;DONE

	.SBTTL	PC ALIGNMENT DIRECTIVES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE TWO ROUTINES MAKE THE PC EVEN OR ODD.
;
;--

EVEN::
	BLBS	W^MAC$GL_PC,ODD_EVEN	;BRANCH IF PC NEEDS ADJUSTING
	RSB				;NO--IT IS ALREADY EVEN

ODD::
	BLBS	W^MAC$GL_PC,ODD_EVEN_EXIT ;BRANCH IF PC IS OK ALREADY
ODD_EVEN:
	$INTOUT_LW INT$_AUGPC,#1	;AUGMENT PC BY ONE ON PASS 2
	$INC_PC				;AUGMENT PC NOW ALSO
ODD_EVEN_EXIT:
	RSB

	.SBTTL	PAGE	MOVE TO NEW LISTING PAGE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE EMITS CODE TO PASS 2 TO FORCE A NEW LISTING
;	PAGE.
;
;--

PAGE::
	$INTOUT_LW INT$_SETLONG,<#-1,#MAC$GL_LINE_CNT> ;FORCE NEW PAGE
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;DON'T LIST THE LINE
	RSB

	.SBTTL	ERROR/WARN/PRINT DIRECTIVES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE .WARN DIRECTIVE.  THE PROPER
;	CODES ARE STORED IN 'MAC$GL_VALUE' FOR LATER USE BY
;	ERROR2 OR ERROR1.
;
;--

WARN::					;ERROR_HEAD = KWARN
	$MAC_ERR GENWRN			; Get message code
	MOVZBL	#INT$_WRN,R1		;AND INT. BUFFER CODE
	BRB	ERR_COM			;GO TO COMMON CODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE .ERROR DIRECTIVE.  THE PROPER
;	CODES ARE STORED IN 'MAC$GL_VALUE' FOR LATER USE BY
;	ERROR2 OR ERROR1.
;
;--

ERROR::					;ERROR_HEAD = KERROR
	$MAC_ERR GENERR			; Get message code
	MOVZBL	#INT$_ERR,R1		;AND INT. BUFFER CODE
	BRB	ERR_COM			;GO TO COMMON CODE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PROCESSES THE .PRINT DIRECTIVE.  THE CODES
;	ARE SET IN 'MAC$GL_VALUE FOR LATER PROCESSING BY ERROR2
;	OR ERROR1.
;
;--

PRINT::					;ERROR_HEAD = KPRINT
	CLRL	R0			;NO MESSAGE FOR .PRINT
	MOVZBL	#INT$_PRT,R1		;SET THE INT. BUFFER CODE
;
; COMMON ROUTINE FOR ERROR/WARN/PRINT
;
ERR_COM:
	BBCC	#FLG$V_EVALEXPR,(R11),10$ ;DON'T SEND CODE TO PASS 2
10$:	MOVAB	W^MAC$GL_VALUE,R2	;POINT TO RESULT WORD
	MOVW	R1,(R2)+		;STORE THE INT. BUFFER CODE
	MOVW	R0,(R2)+		;STORE THE MESSAGE INDEX
;
; COPY LINE FOR PASS 2 ERROR HANDLING
;
20$:	MOVL	W^MAC$GL_LINELN,R6	;GET LENGTH OF LINE
	ADDL3	#4,R6,R0		;FIGURE SIZE OF RECORD
	BSBW	MAC$INTOUT_N		;MAKE ROOM FOR IT
	MOVB	#-1,-1(R9)		;SIGNAL SPECIAL LINE
	MOVB	#INT$_ETX,(R9)+		;STORE COMMAND
	MOVW	R6,(R9)+		;STORE LENGTH OF LINE
	MOVC3	R6,W^MAC$AB_LINEBF,(R9)	;COPY TEXT INTO BUFFER
	MOVL	R3,R9			;UPDATE POINTER
	RSB				;ALL DONE

;++
; FUNCTIONAL DESCRIPTION:
;
;	ERROR2 AND ERROR1 ARE CALLED AFTER A .ERROR/.WARN/.PRINT
;	DIRECTIVE HAS BEEN PROCESSED.  THE INTERMEDIATE CODE AND
;	THE MESSAGE INDEX ARE PICKED UP FROM THE STACK, AND EMITTED
;	TO THE INTERMEDIATE BUFFER, ALONG WITH THE INPUT LINE BUFFER
;	POINTER.  ERROR2 IS CALLED IF THERE WAS AN EXPRESSION TO
;	BE PRINTED.  ERROR1 IS CALLED IF THERE WAS NO EXPRESSION.
;
; NOTE: THE ERROR ROUTINES EXPECT THAT PRIL WILL LEAVE THE EXPR
;	SET IN MAC$GL_VALUE.
;
;
;--

ERROR2::				;DIRECTIVE = ERROR_HEAD EXPR
	$INTOUT_LW INT$_PRIL,<W^MAC$AL_VALSTACK[R7]> ;PRINT VALUE
	MOVAL	W^MAC$AL_VALSTACK-4[R7],R2 ;POINT TO WHERE THE DATA IS
	BRB	ERR_3			;GO FINISH UP

ERROR1::				;DIRECTIVE = ERROR_HEAD
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_VALUE> ;CLEAR VALUE RESIDUE IN PASS 2
	MOVAL	W^MAC$AL_VALSTACK[R7],R2 ;POINT TO WHERE THE DATA IS
ERR_3:	MOVZBL	#10,R0			;THERE WILL BE 10 BYTES
	BSBW	MAC$INTOUT_N		;SET UP FOR IT
	MOVB	(R2)+,(R9)+		;SET THE COMMAND FOR PASS 2
	INCL	R2			;SKIP A BYTE
	MOVZWL	(R2)+,(R9)+		;FIRST LONGWORD IS MESSAGE INDEX
	MOVL	W^MAC$GL_LINEPT,(R9)+	;SECOND LONGWORD IS LINE POINTER
	BBCS	#FLG$V_EVALEXPR,(R11),10$ ;ALLOW EXPRESSION EVALUATION
10$:	RSB

	.SBTTL	NCHR	NUMBER OF CHARACTERS DIRECTIVE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS DIRECTIVE DEFINES THE SYMBOL SUPPLIED WITH THE LENGTH
;	OF THE FOLLOWING STRING.
;
;--

NCHR::					;DIRECTIVE = KNCHR ID
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;COMMA?
	BNEQ	10$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
	BSBW	MAC$SKIPSP		;SKIP SPACES
10$:	BSBW	MAC$MAC_ARG_SCN		;SCAN THE ARGUMENT
	MOVL	W^MAC$AL_VALSTACK[R7],R6 ;POINT TO SYMBOL BLOCK
	BRW	FINISH_N_DIR		;FINISH PROCESSING DIRECTIVE

	.SBTTL	NARG	RETURN NUMBER OF ARGUMENTS IN MACRO CALL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS DIRECTIVE DEFINES THE SYMBOL SUPPLIED TO BE THE NUMBER
;	OF ARGUMENTS IN THE CURRENT MACRO CALL.  AN ERROR IS GENERATED
;	IF WE ARE NOT CURRENTLY EXPANDING A MACRO.
;
;--

NARG::					;DIRECTIVE = KNARG
	BSBW	MAC$SYMSCNUP		;SCAN THE ID
	BLBS	R0,10$			;BRANCH IF ID THERE
	$MAC_ERR DIRSYNX		; No--syntax error
	BRW	MAC$ERRORPT		;ISSUE ERROR AND RETURN
10$:	BSBW	MAC$INSUSRSYMTB		;INSERT IN USER SYMBOL TABLE
	MOVL	W^MAC$GL_INPUTP,R5	;POINT TO CURRENT INPUT BLOCK
	MOVL	R1,R6			;POINT TO SYMBOL BLOCK
	BBS	#FLG$V_MACTXT,(R11),20$	;BRANCH IF READING MACRO TEXT
	$MAC_ERR NOTINMACRO		; No--not in macro
	BSBW	MAC$ERRORPT		;ISSUE ERROR
20$:	MOVZBL	INP$B_ARGCT(R5),R0	;GET THE NUMBER OF ARGS
	BRW	FINISH_N_DIR		;GO FINISH PROCESSING DIRECITVE

	.SBTTL	NTYPE	ASSIGN OPERAND TYPE TO SYMBOL

;++
; FUNCTIONAL DESCRIPTION:
;
;--

NTHD2::					;NTYPE_HEAD = KNTYPE ID
	MOVL	W^MAC$AL_VALSTACK[R7],R0;GET ID BLOCK ADDRESS
	BRB	NTYP_0			;JOIN COMMON CODE

NTHD1::					;NTYPE_HEAD = KNTYPE ID DCOMMA
	MOVL	W^MAC$AL_VALSTACK-4[R7],R0 ;GET ID BLOCK ADDRESS
NTYP_0:	MOVL	R0,W^MAC$GL_ASNPTR	;SAVE ID BLOCK ADDRESS
	MOVL	W^MAC$GL_PC,W^MAC$GL_SAVE_PC ;SAVE PC ADDRESS
	CLRL	W^MAC$GL_ABSFLAG	;ASSUME ABSOLUTE EXPRESSION
	CMPL	R9,W^MAC$GL_INTWRNPT	;TIME TO FLUSH BUFFER?
	BLEQU	20$			;IF LEQ NO
	BSBW	MAC$OUTFRAME		;YES--FLUSH THE BUFFER
20$:	MOVL	R9,W^MAC$GL_EXPPTR	;SET EXPRESSION POINTER
	MOVL	R9,W^MAC$GL_EXPEND	;AND END OF EXPRESSION
	BBCC	#FLG$V_EVALEXPR,(R11),.+1 ;DO NOT EVALUATE EXPRESSION
	BISL2	#FLG$M_COMPEXPR!FLG$M_EXPOPT!FLG$M_NOREF,(R11) ;ASSUME COMPILE-TIME
						   ;AND ALLOW OPTIMIZATION
						 ;TELL PRMSYM NOT TO SET REF BIT
	MOVL	#1@4,W^MAC$GL_OPSIZE	;SET READ ACCESS MODE
	BBSS	#FLG$V_NTYPEPC,(R11),.+1 ; Suppress normal PC register checks
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE TWO ROUTINES PERFORM THE ACTUAL ASSIGNMENT OF THE
;	MODE/REGISTER TO THE SYMBOL POINTED TO BY MAC$GL_ASNPTR.
;
;--

NTYPE1::				;DIRECTIVE = NTYPE_HEAD
	$MAC_ERR DIRSYNX		; No REF!! error.
	BSBW	MAC$ERRORLN		;SO ISSUE A 
	CLRL	W^MAC$GL_VALUE		;CLEAR RESULT

NTYPE2::				;DIRECTIVE = NTYPE_HEAD REF
	MOVL	W^MAC$GL_SAVE_PC,W^MAC$GL_PC ;RESET PC
	MOVL	W^MAC$GL_ASNPTR,R6	;POINT TO THE SYMBOL BLOCK
	MOVZBL	W^MAC$GB_IMODE,R0	;GET IMODE
	ASHL	#4,R0,R0		;MAKE ROOM FOR IREG
	BISB2	W^MAC$GB_IREG,R0	;ADD IN IREG
	ASHL	#4,R0,R0		;MAKE ROOM FOR MODE
	BISB2	W^MAC$GB_MODE,R0	;ADD IN MODE
	ASHL	#4,R0,R0		;MAKE ROOM FOR REG
	BISB2	W^MAC$GB_REG,R0		;THE TYPE IS COMPLETE
FINISH_N_DIR:
	CLRL	W^MAC$GB_MODE		;CLEAR REGS AND MODE
	MOVL	R0,SYM$L_VAL(R6)	;STORE IN SYMBOL BLOCK
	CLRB	SYM$B_SEG(R6)		;DEFINE IN ABSOLUTE PSECT
	BSBW	MAC$MUL_DEF_CHK		;CHECK FOR MULTIPLY DEFINED
	BISW2	#SYM$M_DEF!SYM$M_ABS!SYM$M_ASN,- ;SET SYMBOL FLAGS
			SYM$W_FLAG(R6)	;
	MOVZBL	#CRF$K_DEF,R5		;THIS IS A DEFINITION
	BSBW	MAC$CREF_SYM		;CREF SYMBOL IF CREFFING
	BSBW	MAC$INTOUT_ASN		;OUTPUT ASN TO PASS 2
	$INTOUT_LW INT$_PRIL,<SYM$L_VAL(R6)> ;PRINT VALUE
	RSB

	.END
