	.TITLE	MAC$FINISH	ROUTINES FOR FINISHING ASSEMBLY
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 25-AUG-78
;
; MODIFIED BY:
;
;	V03.00	MTR0005		Mike Rhodes		15-Mar-1982
;		Modify routine MAC$DBG_PSECT to write a Position
;		Independent Data Reference (TIR$C_STO_PIDR) instead
;		of the Store Long Word (TIR$C_STO_LW).
;
;	V02.16	PCG0003		Peter George		07-May-1981
;		Create bug which causes global symbols that have
;		been suppressed from the symbol table to have their 
;		global symbol records suppressed.
;
;	V02.15	PCG0001		Peter George		06-Feb-1981
;		Filter out creation of PSECT DST if ABS specified.
;
;	V02.14	CNH0035		Chris Hume		12-Jun-1980
;		Prevented extraneous symbols at the end of two column (31
;		character) symbol table output.
;
;	V01.13	RN0022		R. Newland	31-Oct-1979
;		Translate SYS$LP_LINES to set lines/page
;
;	V01.12	RN0013		R. Newland	27-Sep-1979
;		Use new symbols for PSECT options processing
;
;	V01.11	RN0011		R. Newland	11-Sep-1979
;		New librarian support
;
;	V01.10	RN0008		R. Newland	29-Aug-1979
;		31 character symbols
;
;	V01.09	RN0005		R. Newland	13-Aug-1979
;		Variable symbol name storage
;
;	V01.08	RN0002		R. Newland	01-Feb-1979
;		Changes for Source Update Merge, information messages
;		count and line number format
;
;
;	V01.06	BLS21346	B. Schreiber	29-DEC-1978
;		Remove restriction that symbol must be referenced
;		and not absolute to be output to debugger.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_SYMBLKDEF			;SYMBOL BLOCK DEFINITIONS
	$MAC_MLFDEF			; Define MLF offsets
	$MAC_GENVALDEF			;GENERAL VALUES
	$MAC_CTLFLGDEF			;CONTROL FLAGS
	$MAC_CRFLAGDEF			;DEFINE CREF CONTROL FLAGS
	$MAC_TIRCMDDEF			;TIR COMMANDS
	$MAC_OBJCODDEF			;DEFINE OBJECT CODE COMMANDS
	$FABDEF				;DEFINE FAB OFFSETS
	$CRFDEF				; Define CRF offsets

;
; LOCAL SYMBOLS
;

DBG$C_PSECT	=	184		;PSECT NAME (1+11+N-ENTRY LENGTH)
DBG$C_SYMBOL	=	186		;SYMBOL NAME (1+7+N)
DBG$C_MODULE	=	188		;MODULE NAME (1+7+N)
DBG$C_MEND	=	189		;MODULE END (1+1)
DBG$C_ROUTINE	=	190		;ROUTINE NAME (1+7+N)
DBG$C_LIT_DAT	=	0		;LITERAL DATA
DBG$C_REL_DAT	=	1		;RELOCATABLE DATA
DBG$K_PSECT_LEN	=	12		;CONSTANT LENGTH OF PSECT ENTRY
DBG$K_SYMBOL_LN	=	8		;CONSTANT LENGTH OF SYMBOL ENTRY
DBG$K_MODULE_LN	=	8		;CONSTANT LENGTH OF MODULE ENTRY
DBG$K_MEND_LEN	=	2		;CONSTANT LENGTH OF MODULE END ENTRY
DBG$K_ROUTIN_LN	=	8		;CONSTANT LENGTH OF ROUTINE ENTRY

;
; LOCAL DATA
;

	.PSECT	MAC$RW_DATA,NOEXE,LONG

MAC$G_ERRBFDES::			;TO FAO THE ERROR LINE #'S
	.LONG	MAC$AB_LINE_END-MAC$AB_LST_END ;SIZE OF BUFFER
	.LONG	0			;FILLED IN WITH ADDRESS

	.SBTTL	MAC$SORT_TABLE SORT SYMBOL TABLE ALPHABETICALLY

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL SORT THE SYMBOL TABLE INTO AN ALPHABETIC
;	LINKED LIST.
;
; INPUTS:
;
;	R9	SYMBOL HASH TABLE ADDRESS
;	R8	SYMBOL HASH TABLE SIZE
;
; OUTPUTS:
;
;	MAC$GL_LINK_PTR	POINTER TO LINKED LIST OF SYMBOLS
;
;--

	.PSECT	MAC$RO_CODE_P3,NOWRT,GBL,LONG

MAC$SORT_TABLE::
	PUSHAB	W^MAC$GQ_RNT_SRT	;STACK TIME BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;BEGIN TIMING SYMBOL TABLE SORT
;
; THE FIRST STEP IS TO REMOVE ALL EMPTY SUBLIST LISTHEADS FROM THE TABLE
;
	MOVL	R9,R7			;COPY TABLE ADDRESS
	MOVL	R7,R6			;...
10$:	TSTL	(R7)+			;LIST HEAD EMPTY?
	BEQL	20$			;IF EQL YES
	MOVL	-4(R7),(R6)+		;NO--MOVE THE LISTHEAD ENTRY
20$:	SOBGTR	R8,10$			;SCAN ALL LISTHEADS
	CLRL	W^MAC$GL_LINK_PTR	;ASSUME NO ENTRIES
	SUBL3	R9,R6,R5		;CALCULATE SIZE OF TABLE IN BYTES
	BNEQ	SORT_LISTS		;BRANCH IF THERE ARE SOME ENTRIES
	BRW	SORT_EXIT		;ELSE GO EXIT
;
; NEXT, WE SORT THE SUBLISTS SUCH THAT THE FIRST SYMBOL IN EACH SUBLIST
; IS LESS THAN THE FIRST SYMBOL OF THE SUCCEEDING SUBLIST.
;
SORT_LISTS:
	MOVL	R9,R8			;COPY TABLE ADDRESS
10$:	MOVL	(R8)+,R7		;GET ADDRESS OF NEXT SYMBOL
	CMPL	R8,R6			;ANY MORE LISTHEADS IN TABLE?
	BEQL	MERGE_LISTS		;IF EQL NO
	MOVL	(R8),R5			;GET ADDRESS OF NEXT
	MOVZBL	SYM$B_NAME(R7),R0	; Get offset to name
	SUBL3	R0,R7,R0		; and form address of count/name
	MOVZBL	(R0)+,R2		; Get count and advance pointer to name
	MOVZBL	SYM$B_NAME(R5),R1	; Get offset to name
	SUBL3	R1,R5,R1		; and form address of count/name
	MOVZBL	(R1)+,R3		; Get count and advance pointer to name
	CMPC5	R2,(R0),#0,R3,(R1)	; Compare symbols
	BLSSU	10$			;IF LSS THEN ORDER CORRECT
	MOVL	R7,(R8)			;INVERT LISTHEAD ENTRIES
	MOVL	R5,-(R8)		;...
	CMPL	R8,R9			;AT FRONT OF LISTHEAD TABLE?
	BEQL	10$			;IF EQL YES
	TSTL	-(R8)			;NO--BACKUP ONE ENTRY
	BRB	10$
;
; NOW MERGE THE SUBLISTS INTO ONE MASTER SORTED LIST
;
MERGE_LISTS:
	MOVAB	W^MAC$GL_LINK_PTR,R8	;POINT TO MERGE LISTHEAD
	MOVL	R9,R7			;COPY LISTHEAD TABLE POINTER
10$:	MOVL	(R7)+,R5		;GET ADDRESS OF NEXT SYMBOL
	BNEQ	12$			; If NEQ more in this sublist
	BRW	70$
12$:
	BBS	#SYM$V_LOCAL,SYM$W_FLAG(R5),20$ ;BR IF LOCAL SYMBOL
	BBS	#SYM$V_DEF,SYM$W_FLAG(R5),15$ ;BRANCH IF DEFINED
	BBS	#SYM$V_EXTRN,SYM$W_FLAG(R5),15$ ;BRANCH IF DECLARED EXTERNAL
	BBC	#SYM$V_REF,SYM$W_FLAG(R5),30$ ;BRANCH IF NOT REFERENCED
					;(SYMBOL WAS USED IN .NTYPE DIRECTIVE
					;AND WAS NOT REF. OTHERWISE)
15$:	INCL	W^MAC$GL_SYM_NLOC	;COUNT NON-LOCAL SYMBOL
	MOVL	R5,SYM$L_LINK(R8)	; Link new symbol to old last
	MOVL	R5,R8			;MAKE NEW LAST SYMBOL
;
; IF .ENABLE GLOBAL AND SYMBOL IS UNDEFINED, DECLARE IT EXTERNAL NOW.
;
	BLBC	L^ENB$G_GLOBAL+SYM$L_VAL,30$ ;BRANCH IF DISABLE GLOBAL
	BBS	#SYM$V_DEF,SYM$W_FLAG(R5),30$ ;BRANCH IF SYMBOL DEFINED
	BBCS	#SYM$V_EXTRN,SYM$W_FLAG(R5),30$ ;DECLARE SYMBOL EXTERNAL
	BRB	30$			;GO AHEAD
20$:	INCL	W^MAC$GL_SYM_LOCL	;COUNT A LOCAL SYMBOL
30$:	MOVL	SYM$L_LINK(R5),-(R7)	; Remove symbol from list
	BNEQ	40$			;IF NEQ THEN MORE IN LIST
	TSTL	(R7)+			;ADVANCE LISTHEAD POINTER
40$:	CMPL	R7,R6			;ANY MORE SUBLISTS TO CONSIDER?
	BEQL	80$			;IF EQL NO
	MOVQ	R7,-(SP)		;SAVE MERGE PARMS (R7/R8)
50$:	MOVL	(R7)+,R8		;GET ADDRESS OF FIRST SUBLIST ENTRY
	CMPL	R7,R6			;ANY MORE SUBLISTS TO CONSIDER?
	BEQL	60$			;IF EQL NO
	MOVL	(R7),R5			;YES--GET ADDRESS OF FIRST SUBLIST ENTRY
	MOVZBL	SYM$B_NAME(R8),R0	; Get offset to first name
	SUBL3	R0,R8,R0		; and form address of count/name
	MOVZBL	(R0)+,R2		; Get count and advance pointer to name
	MOVZBL	SYM$B_NAME(R5),R1	; Get offset to second name
	SUBL3	R1,R5,R1		; and form address of count/name
	MOVZBL	(R1)+,R3		; Get count and advance pointer to name
	CMPC5	R2,(R0),#0,R3,(R1)	; Compare symbols
	BLSSU	60$			;IF LSS ORDER CORRECT
	MOVL	R8,(R7)			;SWAP SUBLISTS
	MOVL	R5,-4(R7)		;...
	BRB	50$			;CONTINUE
60$:	MOVQ	(SP)+,R7		;RESTORE MERGE PARAMETERS (R7/R8)
65$:	BRW	10$			; Continue merge
70$:	CMPL	R7,R6			;ANY MORE SUBLISTS TO CONSIDER?
	BNEQ	65$			; If NEQ yes
80$:	CLRL	SYM$L_LINK(R8)		; Clear forward link of last entry
SORT_EXIT:
	PUSHAB	W^MAC$GQ_RNT_SRT	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING SYMBOL TABLE SORT
	RSB

	.SBTTL	MAC$FINISH_ASM OUTPUT TRACEBACK, DEBUG INFO

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED AT THE END OF THE ASSEMBLY TO FINISH
;	THINGS UP.  IF ENABLED, TRACEBACK AND DEBUG INFORMATION IS
;	OUTPUT TO THE OBJECT FILE.  THE SYMBOL TABLE LISTING IS PRINTED.
;
;--

MAC$FINISH_ASM::
	PUSHR	#^M<R7,R8,R9>		;SAVE REGISTERS
	CLRL	R7			;RESET STACK POINTER
	BBS	#FLG$V_OBJXST,(R11),5$	; Branch if there is an object file
	BRW	85$			; No object file
5$:
	BLBC	L^ENB$G_TRACEBACK+SYM$L_VAL,85$ ; Branch if disable traceback
	MOVZBL	#OBJ$C_TBT,W^MAC$GL_RECTYP ;TRACEBACK RECORD TYPE
	BSBW	MAC$WRTOBJ		;WRITE OUT LAST TIR RECORD
	MOVAB	W^MAC$AB_TITLE,R5	;POINT TO TITLE STRING
	TSTB	(R5)			;WAS TITLE SUPPLIED?
	BNEQ	10$			;IF NEQ YES--GO USE IT
	MOVAB	L^MAC$AB_DEF_TITL,R5	;POINT TO DEFAULT TITLE STRING
10$:	ADDB3	(R5),#DBG$K_MODULE_LN-1,R0 ;FIGURE LENGTH OF ENTRY
	BSBW	MAC$STOIM		;STORE INTO OBJECT CODE
	MOVZBL	#DBG$C_MODULE,R0	;MODULE NAME
	BSBW	MAC$STOIM		;STORE IT
	MOVZBL	#5,R4			;SET A LOOP COUNT
20$:	CLRL	R0			;STRUCTURE LEVEL AND "MACRO?(?)
	BSBW	MAC$STOIM
	SOBGTR	R4,20$			;DO 5
	MOVZBL	(R5)+,R4		;GET CHARACTER COUNT
	MOVL	R4,R0			;COPY TO STORE IT
	BSBW	MAC$STOIM
40$:	MOVZBL	(R5)+,R0		;GET CHAR OF TITLE
	BSBW	MAC$STOIM		;STORE IMMEDIATE
	SOBGTR	R4,40$
;
; SEARCH SYMBOL TABLE AND EMIT ENTRY POINTS TO THE DEBUGGER
;
	MOVL	W^MAC$GL_LINK_PTR+SYM$L_LINK,R6	; Point to linked symbol list
	BEQL	80$			;IF EQL THERE IS NO LIST
60$:	BBC	#SYM$V_EPT,SYM$W_FLAG(R6),70$ ;BRANCH IF NOT EPT
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to name
	SUBL3	R0,R6,R0		; Form address of count/name
	ADDB3	#DBG$K_SYMBOL_LN-1,-	; Figure length of entry
		(R0),R0			; putting result in R0
	BSBW	MAC$STOIM
	MOVZBL	#DBG$C_ROUTINE,R0	;TYPE
	BSBW	MAC$STOIM
	CLRL	R0			;ZERO BYTE
	BSBW	MAC$STOIM
	BSBW	MAC$DBG_VAL_OUT		;OUTPUT ADDRESS
	BSBW	MAC$DBG_NAM_OUT		;OUTPUT NAME
70$:	MOVL	SYM$L_LINK(R6),R6	; Link to next symbol
	BNEQ	60$			;IF THERE IS ONE, GO PROCESS IT
;
; OUPTUT LABLES AND REFERENCED SYMBOLS FOR DEBUGGER
;
80$:	MOVZBL	#OBJ$C_DBG,W^MAC$GL_RECTYP ;SET DEBUG RECORD TYPE
	BSBW	MAC$WRTOBJ		;WRITE OUT THE TRACEBACK RECORDS
85$:	MOVL	W^MAC$GL_LINK_PTR,R6	;POINT TO SYMBOL LIST AGAIN
	BEQL	150$			;IF EQL THERE IS NO LIST
;
; BACK HERE FOR EACH SYMBOL IN THE LIST
;
90$:	MOVZWL	SYM$W_FLAG(R6),R3	;GET FLAGS FOR SYMBOL
	BBC	#SYM$V_DEBUG,R3,140$	;BRANCH IF NO DEBUG ATTRIBUTE
	BBC	#SYM$V_DEF,R3,140$	;BRANCH IF NOT DEFINED
;
; SYMBOL HAS DEBUG ATTRIBUTE AND IS DEFINED.
;
100$:	BISW2	#SYM$M_ODBG,SYM$W_FLAG(R6) ;SET DEBUG OUTPUT FLAG FOR SYMBOL
	BBS	#SYM$V_EPT,R3,140$	;BRANCH IF THIS IS AN ENTRY POINT
	BBC	#FLG$V_OBJXST,(R11),140$ ;BRANCH IF THERE IS NO OBJECT FILE
	BLBC	L^ENB$G_TRACEBACK+SYM$L_VAL,140$ ;BRANCH IF DISABLE TRACEBACK
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to name
	SUBL3	R0,R6,R0		; Form address of count/name
	ADDB3	#DBG$K_SYMBOL_LN-1,-	; Figure length of entry
		(R0),R0			; putting result in R0
	BSBW	MAC$STOIM
	MOVZBL	#DBG$C_SYMBOL,R0	;ASSUME A LABEL
	BSBW	MAC$STOIM		;STORE INTO OBJECT CODE
	BBS	#SYM$V_ABS,R2,110$	;BRANCH IF SYMBOL IS ABSOLUTE
;
; SYMBOL IS RELOCATABLE
;
	MOVZBL	#DBG$C_REL_DAT,R0	;RELOCATABLE DATA
	BSBW	MAC$STOIM
	BSBW	MAC$DBG_VAL_OUT		;OUTPUT SYMBOL ADDRESS
	BRB	130$
;
; SYMBOL IS ABSOLUTE
;
110$:	MOVZBL	#DBG$C_LIT_DAT,R0	;LITERAL DATA
	BSBW	MAC$STOIM
	MOVAB	SYM$L_VAL(R6),R5	;POINT TO SYMBOL VALUE
	MOVZBL	#4,R4			;LOOP COUNT
120$:	MOVB	(R5)+,R0		;GET BYTE OF VALUE
	BSBW	MAC$STOIM		;STORE INTO OBJECT CODE
	SOBGTR	R4,120$
;
; OUTPUT SYMBOL NAME
;
130$:	BSBW	MAC$DBG_NAM_OUT		;SEND NAME TO OBJECT FILE
140$:	MOVL	SYM$L_LINK(R6),R6	; Link to next symbol
	BNEQ	90$			;BRANCH IF THERE IS ONE
150$:	BBC	#FLG$V_OBJXST,(R11),PRINT_SYM_TABLE ;SKIP IF NO OBJECT FILE
	BLBC	L^ENB$G_TRACEBACK+SYM$L_VAL,PRINT_SYM_TABLE ;SKIP IF DISABLE TRACEBACK
	MOVZBL	#OBJ$C_TBT,W^MAC$GL_RECTYP ;SET FOR TRACEBACK RECORD TYPE
	BSBW	MAC$WRTOBJ		;WRITE OUT DEBUG RECORD
;
; OUTPUT PSECT NAMES AND END OF MODULE
;
	MOVAB	W^PSECT$BLANK,R6	;BLANK PSECT
	BSBW	MAC$DBG_PSECT		;OUTPUT INFORMATION
	MOVL	W^MAC$GL_PSC_LIST,R6	;GET FIRST PSECT ADDRESS
	BEQL	170$			;IF EQL NONE
160$:	BBC	#PSC$V_REL, -		;SUPPRESS ABS PSECTS
		PSC$W_OPTIONS(R6),165$
	BSBW	MAC$DBG_PSECT		;OUPTUT INFO
165$:	MOVL	SYM$L_LINK(R6),R6	; Link to next symbol
	BNEQ	160$			;IF NEQ THERE IS MORE
170$:	MOVZBL	#1,R0			;STORE LENGTH
	BSBW	MAC$STOIM
	MOVZBL	#DBG$C_MEND,R0		;MODULE END
	BSBW	MAC$STOIM
	BSBW	MAC$WRTOBJ		;WRITE OUT FINAL TRACEBACK RECORD

	.SBTTL	PRINT SYMBOL TABLE IN ALPHABETICAL ORDER

PRINT_SYM_TABLE:
	PUSHL	R10			;SAVE INT. BUFFER POINTER
	BBS	#FLG$V_LSTXST,(R11),10$	;BRANCH IF THERE IS LISTING FILE
	BRW	PRT_ERR_SUM		;NO--GO SEE ABOUT ERROR SUMMARY
10$:	PUSHAB	W^MAC$GQ_RNT_P2		;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING PASS 2 NOW
	PUSHAB	W^MAC$GQ_RNT_SYO	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;BEGIN TIMING SYMBOL TABLE OUTPUT
	MOVZBL	#1,W^MAC$GL_LIST_LVL	;FORCE SYMBOL TABLE TO LIST
	CLRL	R7			;RESET STACK POINTER
	MOVAB	L^MAC$AB_STB_MSG,R0	;POINT TO "SYMBOL TABLE" STRING
	MOVZBL	(R0)+,R1		;GET ITS LENGTH
	MOVC5	R1,(R0),#^A/ /, -	; Copy into subtitle buffer
			#LST$K_TITLE_SIZ+SYM$K_MAXLEN+1, -
			L^MAC$AB_SBT_IDNT	;(OVER IDENT AND SUBTITLE)
	CLRL	W^MAC$GL_DIRFLG		;CLEAR NEW PAGE OUTPUT FLAG
	MOVL	W^MAC$GL_LINK_PTR+SYM$L_LINK,R10 ; Point to symbol list
	BNEQ	20$			;IF NEQ GO PRINT SYMBOLS
	BRW	PRT_SYM_END		;ELSE ALL DONE HERE
20$:	INCL	W^MAC$GL_DIRFLG		;SET NEW PAGE OUTPUT FLAG
PRT_SYM_LOOP:
	BSBW	MAC$LST_PAG_HDR		;SKIP TO NEW PAGE
	MOVL	R10,R8			;POINT TO SYMBOL
	MOVL	W^MAC$GL_LN_PAGE,R5	; Lines of symbols/page
10$:	TSTL	R8			;END OF LIST?
	BEQL	20$			;IF EQL YES
	TSTL	R5			;NO--END OF PAGE?
	BLEQ	20$			;IF LEQ YES
	BBC	#SYM$V_SUPR, -		;BRANCH IF NOT SUPPRESSED SYMBOL
		SYM$W_FLAG(R8),15$ 
	MOVL	SYM$L_LINK(R8),R8	;LINK TO NEXT SYMBOL
	BRB	10$			;TRY AGAIN	
15$:	MOVL	SYM$L_LINK(R8),R8	;NOT SUPPRESSED, LINK TO NEXT SYMBOL
	SOBGEQ	R5,10$			;COUNT AND LOOP
20$:	MOVL	W^MAC$GL_LN_PAGE,R5	; Lines of symbols/page
	BBS	#FLG$V_SYM2COL,(R11),40$ ; Branch if two column listing
	MOVL	R8,R9			;R8 POINTS TO FIRST SYMBOL IN
					;SECOND COLUMN...NOW FIND FIRST
					;FOR THIRD COLUMN
30$:	TSTL	R9			;END OF LIST?
	BEQL	40$			;IF EQL YES
	TSTL	R5			;NO--END OF PAGE?
	BLEQ	40$			;IF LEQ YES
	BBC	#SYM$V_SUPR, -		;BRANCH IF NOT SUPPRESSED SYMBOL
		SYM$W_FLAG(R9),35$ 
	MOVL	SYM$L_LINK(R9),R9	;LINK TO NEXT SYMBOL
	BRB	30$			;TRY AGAIN	
35$:	MOVL	SYM$L_LINK(R9),R9	;NOT SUPPRESSED, LINK TO NEXT SYMBOL
	SOBGEQ	R5,30$			;COUNT AND LOOP
;
; NOW R10 POINTS TO FIRST SYMBOL OF FIRST COLUMN
;	R8 POINTS TO FIRST SYMBOL OF SECOND COLUMN
;	R9 POINTS TO FIRST SYMBOL OF THIRD COLUMN
;
40$:	PUSHL	W^MAC$GL_LN_PAGE	; Stack symbols/page
50$:	BSBW	MAC$LIST_INIT		;INIT LISTING BUFFER AND POINTER
53$:	MOVL	R10,R6			;POINT TO FIRST COLUMN SYMBOL
	BEQL	60$			;IF EQL THERE IS NONE
	BBC	#SYM$V_SUPR, -		;BRANCH IF NOT SUPPRESSED SYMBOL
		SYM$W_FLAG(R10),57$ 
	MOVL	SYM$L_LINK(R10),R10	;LINK TO NEXT SYMBOL
	BRB	53$			;TRY AGAIN	
57$:	MOVL	SYM$L_LINK(R10),R10	;NOT SUPPRESSED, LINK TO NEXT SYMBOL
	BSBW	MAC$PRT_SYM_INF		;PRINT THE SYMBOL INFORMATION
60$:	MOVL	R8,R6			;POINT TO SECOND COLUMN SYMBOL
	BEQL	70$			;IF EQL THERE IS NONE
	BBC	#SYM$V_SUPR, -		;BRANCH IF NOT SUPPRESSED SYMBOL
		SYM$W_FLAG(R8),65$ 
	MOVL	SYM$L_LINK(R8),R8	;LINK TO NEXT SYMBOL
	BRB	60$			;TRY AGAIN	
65$:	MOVL	SYM$L_LINK(R8),R8	;NOT SUPPRESSED, LINK TO NEXT SYMBOL
	BSBW	MAC$PRT_SYM_INF		;PRINT SYMBOL INFORMATION
70$:	BBS	#FLG$V_SYM2COL,(R11),80$	; Branch if two column listing
73$:	MOVL	R9,R6			;POINT TO THIRD COLUMN SYMBOL
	BEQL	80$			;IF EQL THERE IS NONE
	BBC	#SYM$V_SUPR, -		;BRANCH IF NOT SUPPRESSED SYMBOL
		SYM$W_FLAG(R9),77$ 
	MOVL	SYM$L_LINK(R9),R9	;LINK TO NEXT SYMBOL
	BRB	73$			;TRY AGAIN	
77$:	MOVL	SYM$L_LINK(R9),R9	;NOT SUPPRESSED, LINK TO NEXT SYMBOL
	BSBW	MAC$PRT_SYM_INF		;PRINT SYMBOL INFORMATION
80$:	CMPL	L^MAC$GL_LIST_PTR,#MAC$AB_LST_END ;LINE THERE?
	BLEQU	90$			;IF LEQ NO
	SUBL3	#MAC$AB_LINEBF,-	;YES--FIGURE LINE LENGTH
			L^MAC$GL_LIST_PTR,-
			W^MAC$GL_LINELN
	BSBW	MAC$WRTLST		;WRITE IT OUT
90$:	SOBGTR	(SP),50$		;LOOP FOR A PAGE
	TSTL	(SP)+			;CLEAN STACK
	BBC	#FLG$V_SYM2COL,(R11),95$	; Branch if not two column listing
	MOVL	R8,R9			; Get next symbol to print
95$:
	MOVL	R9,R10			;POINT FOR NEXT PAGE
	BEQL	100$			;IF EQL ALL DONE
	BRW	PRT_SYM_LOOP		;ELSE CONTINUE
100$:
PRT_SYM_END:
	PUSHAB	W^MAC$GQ_RNT_SYO	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;FINISH TIMING SYMBOL TABLE OUTPUT

	.SBTTL	PRINT PSECT SYNOPSIS

PRT_PSECT_SYNOP:
	PUSHAB	W^MAC$GQ_RNT_PSY	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;START TIMING PSECT SYNOPSIS
	TSTL	W^MAC$GL_DIRFLG		;WAS SYMBOL TABLE OUTPUT?
	BNEQ	10$			;IF NEQ YES
	CLRL	W^MAC$GL_LINE_CNT	;NO--ALWAYS OUTPUT NEW PAGE
10$:	PUSHL	#4			;# LINES WE ACTUALLY USED (-1)
	PUSHAB	L^MAC$AB_PSC_HDR	;STACK HEADER ADDRESS
	PUSHL	#5			;STACK # WE WILL USE
	ADDL2	W^MAC$GL_PSC_MAX,(SP)	;ADD TO GET TOTAL WE NEED
	PUSHAB	L^MAC$AB_PSS_MSG	;STACK SUBTITLE STRING
	CALLS	#4,W^NEW_SBT_CK_PAGE	;DO NEW PAGE IF NEEDED AND OUTPUT HEADER
	MOVAB	L^MAC$AB_PSC_HD2,R0	;POINT TO SECONDARY HEADER
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT SECONDARY HDR
	DECL	W^MAC$GL_LINE_CNT	;COUNT EXTRA LINE OUTPUT
	MOVAB	W^PSECT$MAIN,R6		;POINT TO ABS PSECT
	BSBW	MAC$PSECT_PRINT		;PRINT ITS INFO
	MOVAB	W^PSECT$BLANK,R6	;POINT TO BLANK PSECT
	BSBW	MAC$PSECT_PRINT		;PRINT ITS INFO
	MOVL	W^MAC$GL_PSC_LIST,R6	;GET PSECT LIST POINTER
	BEQL	30$			;IF EQL NO MORE
20$:	BSBW	MAC$PSECT_PRINT		;PRINT THIS PSECT
	MOVL	(R6),R6			;NEXT PSECT
	BNEQ	20$			;IF NEQ THERE IS A NEXT
30$:	PUSHAB	W^MAC$GQ_RNT_PSY	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING PSECT SYNOPSIS

	.SBTTL	PRINT CROSS-REFERENCE IF REQUESTED

PRT_CROSS_REF:
	TSTL	W^MAC$GL_CRF_FLG	;WAS THERE ANY CROSS REFERENCE?
	BEQL	40$			;IF EQL NO--SKIP IT ALL
	PUSHAB	W^MAC$GQ_RNT_CRF	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;START TIMING CREF PHASE
	CLRL	R9			;CLEAR INDEX INTO TABLES
10$:	MOVL	L^MAC$AL_CRF_TB5[R9],R0	;ARE WE DONE?
	BEQL	30$			;IF EQL YES
	MOVZBL	L^MAC$AB_CRF_TB6[R9],R1	;GET BIT # TO CHECK
	BBC	R1,W^MAC$GL_CRF_FLG,20$	;IF CLEAR TRY NEXT CREF AREA
	TSTL	(R0)			;DID WE CREF ANYTHING?
	BEQL	20$			;IF EQL NO--DO NEXT
	MOVL	L^MAC$AL_CRF_TB1[R9],R0	;GET HEADER ADDRESS
	MOVL	L^MAC$AL_CRF_TB2[R9],R1	;GET SECONDARY HEADER ADDRESS
	MOVL	L^MAC$AL_CRF_TB3[R9],R2	;GET CONTROL TABLE ADDRESS
	MOVL	L^MAC$AL_CRF_TB7[R9],R3	; Get column width flag
	BEQL	15$			; If EQL not a variable field
	MOVL	L^MAC$AL_CRF_TB8[R9], -	; Set KEY1FIELD entry
		CRF$L_K1FMTBL(R2)	; assuming narrow field
	BBC	R3,(R11),15$		; Branch if narrow column listing
	MOVL	L^MAC$AL_CRF_TB2W[R9],R1 ; Reset secondary header address
	MOVL	L^MAC$AL_CRF_TB9[R9], -	; Set KEY1FIELD ENTRY
		CRF$L_K1FMTBL(R2)	; for wide field
15$:
	MOVZBL	L^MAC$AB_CRF_TB4[R9],R3	;GET DEFS_REFS OR VALS_REFS
	BSBW	CREF_TREE_OUT		;DO THIS CREF
20$:	INCL	R9			;NEXT CREF
	BRB	10$			;DO IT
30$:	PUSHAB	W^MAC$GQ_RNT_CRF	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING CROSS REFERENCE
40$:	PUSHAB	W^MAC$GQ_RNT_TOT	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING OF ASSEMBLER NOW

	.SBTTL	OUTPUT CPU AND ELAPSED TIME STATISTICS

PRT_RUN_TIM:
	PUSHL	#4			;STACK # LINES WE WILL ACTUALLY OUTPUT
					;(-1 FOR WRTLST)
	PUSHAB	L^MAC$AB_IND_HDR	;STACK HEADER ADDRESS
	PUSHL	#8			;# LINES NEEDED
	PUSHAB	L^MAC$AB_RNT_MSG	;STACK SUBTITLE STRING
	CALLS	#4,W^NEW_SBT_CK_PAGE	;OUTPUT HEADERS AND NEW PAGE IF NECESSARY
	MOVAB	L^MAC$AB_RUN_HDR,R0	;POINT TO FIRST LINE MESSAGE
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT LINE
	DECL	W^MAC$GL_LINE_CNT	;COUNT EXTRA LINE FROM RUN_HDR
	MOVAB	L^MAC$AW_IND_NAMS,R9	;POINT TO TABLE OF NAMES
	MOVAB	L^MAC$AW_RNT_PTRS,R8	;POINT TO TABLE OF RUNTIME WORDS
	MOVAB	L^MAC$AW_TIM_PTRS,R6	;POINT TO TABLE OF ELAPSED QUADWORDS
20$:	MOVZWL	(R9)+,R0		;GET ADDRESS OF STRING
	BEQL	50$			;IF EQL ALL DONE
	MOVZWL	(R8)+,R1		;GET ADDRESS OF CPU TIME QUADWORD
	CLRQ	R2			;CLEAR R2,R3
	CLRL	R4			;CLEAR R4 ALSO
	EDIV	#100,(R1),R2,R1		;FRACTIONAL PART TO R1
	EDIV	#60,R2,R3,R2		;SECONDS TO R2
	EDIV	#60,R3,R4,R3		;MINUTES TO R3, HOURS IN R4
30$:	MOVZWL	(R6),-(SP)		;GET ADDRESS OF ELAPSED TIME QUADWORD
	PUSHL	R1			;...
	PUSHL	R2
	PUSHL	R3
	PUSHL	R4
	MOVZWL	(R6)+,R1		;POINT TO ELAPSED TIME QUADWORD
	PUSHL	8(R1)			;STACK THE # OF PAGE FAULTS
	PUSHL	R0			;STACK STRING ADDRESS
	MOVAB	L^MAC$AB_FAO_TIM,R0 	;POINT TO FAO CONTROL STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE LINE
	ADDL2	#7*4,SP			;CLEAR THE ARG LIST FROM THE STACK
	BRB	20$
50$:

	.SBTTL	PRINT MEMORY USE STATISTICS

PRT_MEM_USE:
	BSBW	MAC$WRT_BLNKLIN		;SKIP A LINE
	$ADJWSL_S PAGCNT=#0,WSETLM=W^MAC$GL_DIRFLG ;GET WS LIMIT
	PUSHL	W^MAC$GL_DIRFLG		;STACK WS LIMIT
	MOVAB	L^MAC$AB_WSL_FAO,R0	;POINT TO FAO CONTROL STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT
	ADDL2	#1*4,SP			;CLEAN THE STACK
	MOVL	L^MAC$GL_INTPAGRQ,R0	;GET # BYTES OF INT. BUFFER USED
	ADDL3	#^X1FF,R0,R1		;ROUND UP TO PAGES
	ASHL	#-9,R1,-(SP)		;CONVERT TO PAGES AND STACK
	PUSHL	R0			;STACK # BYTES OF INT. BUFFER
	MOVAB	L^MAC$AB_IFP_FAO,R0	;POINT TO FAO STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	ADDL2	#2*4,SP			;CLEAR THE STACK
	PUSHL	W^MAC$GL_SYM_LOCL	;STACK COUNT OF LOCAL SYMBOLS
	PUSHL	W^MAC$GL_SYM_NLOC	;STACK COUNT OF NON-LOCAL SYMBOLS
	MULL3	W^MAC$GL_SYMPGREQ,-	;COMPUTE # PAGES ALLOCATED
		#STB$K_PG_MISS,R0	;...
	PUSHL	R0			;STACK # PAGES ALLOCATED
	PUSHAB	L^MAC$AB_WERE_MG	;ASSUME MANY PAGES ALLOCATED
	SUBL3	#1,R0,R1		;WAS THERE ONLY ONE PAGE?
	BNEQ	10$			;IF NEQ NO
	MOVAB	L^MAC$AB_WAS_MSG,(SP)	;YES--USE "WAS" INSTEAD
10$:	MOVAB	L^MAC$AB_SYP_FAO,R0	;POINT TO FAO CONTROL STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	ADDL2	#4*4,SP			;CLEAR THE STACK
	PUSHL	W^MAC$GL_OBJ_RCNT	;STACK OBJECT RECORD COUNT
	MOVL	W^MAC$GL_SRC_LCNT,R0	;GET SOURCE RECORD COUNT
	PUSHAB	L^MAC$AB_WERE_MG	;ASSUME NOT 1 SOURCE LINE
	SUBL3	#1,R0,R1		;CHECK FOR 1 LINE
	BNEQ	20$			;IF NEQ NOT 1 LINE
	MOVAB	L^MAC$AB_WAS_MSG,(SP)	;1 LINE--USE "WAS"
20$:	PUSHL	R0			;STACK SOURCE RECORD COUNT
	MOVAB	L^MAC$AB_OBSR_FAO,R0	;GET FAO CTL STRING ADDRESS
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	ADDL2	#3*4,SP			;CLEAR THE STACK
	PUSHL	W^MAC$GL_MCDEF		;STACK # OF MACROS DEFINED
	MOVL	W^MAC$GL_MCPGRQ,R0	;GET # PAGES REQUIRED TO DO SO
	PUSHAB	L^MAC$AB_WERE_MG	;ASSUME NOT 1 PAGE
	SUBL3	#1,R0,R1		;CHECK FOR ONE PAGE
	BNEQ	30$			;IF NEQ NOT 1 PAGE
	MOVAB	L^MAC$AB_WAS_MSG,(SP)	;1 PAGE--USE "WAS"
30$:	PUSHL	R0			;STACK # PAGES
	MOVAB	L^MAC$AB_MCD_FAO,R0	;ADDRESS OF FAO CONTROL STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	ADDL2	#3*4,SP			;CLEAN THE STACK

	.SBTTL	PRINT MACRO LIBRARY USE STATISTICS

PRT_MLB_STATS:
	TSTL	W^MAC$GL_MLB_CNT	;WERE THERE ANY MLB'S?
	BGTR	10$			;IF GTR YES
	BRW	60$			;NO--SKIP ALL OF THIS
10$:	PUSHL	#4			;STACK # LINES USED BY HEADER (-1)
	PUSHAB	L^MAC$AB_MLB_HDR	;STACK HEADER ADDRESS
	ADDL3	#5+2,W^MAC$GL_MLB_CNT,-(SP) ;FIGURE TOTAL LINES USED AND STACK
	SUBL3	#1,W^MAC$GL_MLB_CNT,R0	;WAS THERE ONLY 1 LIBRARY?
	BLEQ	20$			;IF LEQ YES
	INCL	(SP)			;NO--PRINT TOTALS LINE ALSO
20$:	PUSHAB	L^MAC$AB_RNT_MSG	;STACK LINE 2 HEADER MESSAGE
	CALLS	#4,W^NEW_SBT_CK_PAGE	;OUTPUT HEADER AND PAGE IF NECESSARY
	MOVAB	L^MAC$AB_MLB_HD2,R0	;GET COLUMN HEADER MESSAGE
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	DECL	W^MAC$GL_LINE_CNT	;COUNT EXTRA LINE FROM MLB_HD2
	MOVL	W^MAC$GL_MLB_QUE,R6	;POINT TO THE MLB QUEUE
30$:
	PUSHL	MLF$L_MCDEF(R6)		;STACK NUMBER OF MACROS DEFINED
	PUSHAB	MLF$Q_FNAMDS(R6)	; Stack file name descriptor address
	MOVAB	L^MAC$AB_MLB_FAO,R0	;GET FAO CONTROL STRING ADDRESS
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	ADDL2	#2*4,SP			; Clear the stack
40$:	MOVL	(R6),R6			;LINK TO NEXT MLB
	CMPL	R6,#MAC$GL_MLB_QUE	;AT THE END OF THE QUEUE?
	BNEQ	30$			;IF NEQ NO
	SUBL3	#1,W^MAC$GL_MLB_CNT,R0	;WAS THERE ONLY ONE MLB?
	BLEQ	50$			;IF LEQ YES--SKIP TOTALS LINE
	PUSHL	W^MAC$GL_MLB_MDF	;STACK TOTAL NUMBER OF MACROS DEFINED
	PUSHAB	L^MAC$AB_MLB_TOT	; Stack descriptor of Totals string
	MOVAB	L^MAC$AB_MLB_FAO,R0	;POINT TO FAO CONTROL STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	ADDL2	#2*4,SP			; Clear the stack
50$:	BSBW	MAC$WRT_BLNKLIN		;SKIP A LINE
	PUSHL	W^MAC$GL_MLB_MDF	;STACK # MACROS DEFINED
	MOVL	W^MAC$GL_MLB_GET,R0	;GET # GETS REQUIRED
	PUSHAB	L^MAC$AB_WERE_MG	;ASSUME MANY GETS NEEDED
	SUBL3	#1,R0,R1		;SEE IF ONLY 1 GET
	BNEQ	55$			;IF NEQ NOT 1 GET
	MOVAB	L^MAC$AB_WAS_MSG,(SP)	;1 GET--SAY "WAS"
55$:	PUSHL	R0			;STACK # GETS REQUIRED
	MOVAB	L^MAC$AB_MLB_SUM,R0	;POINT TO FAO CONTROL STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT STRING
	ADDL2	#3*4,SP			;CLEAR STACK
60$:

	.SBTTL	PRINT ERROR SUMMARY

PRT_ERR_SUM:
	BSBW	MAC$WRT_BLNKLIN		;SKIP A LINE
	MOVL	L^MAC$GL_ERRCT,R10	;GET THE ERROR TOTAL
	MOVL	W^MAC$GL_WARNCT,R9	;AND THE WARNINGS
	MOVL	W^MAC$GL_INFOCNT,R8	; and the information messages
	ADDL3	R10,R9,R0		;WERE THERE ANY ERRORS/WARNINGS?
	ADDL2	R8,R0			; or information messages
	BNEQ	10$			;IF NEQ YES
	MOVAB	L^MAC$AB_NOERRM,R0	;NO--GET NO ERRORS MESSAGE
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT IT
	BRW	PRT_ERR_SUM_END		;ALL DONE
;
; THERE WERE ERRORS/WARNINGS. PRINT THAT.
;
10$:
	PUSHL	R8			; Stack information messages count
	PUSHL	R9			; warning count
	PUSHL	R10			;AND ERROR COUNT
	MOVAB	L^MAC$AB_ERRM,R0	;GET THE FAO STRING
	BSBW	MAC$FAOUTS		;FORMAT THE LINE
	ADDL2	#3*4,SP			; Pop three longwords from stack
	BSBW	MAC$TERM_BLANK		;WRITE ONE BLANK LINE TO TERMINAL
	MOVL	W^MAC$GL_LINELN,R0	;GET THE LINE LENGTH
	BSBW	MAC$WRITE_TERM		;WRITE LINE TO TERMINAL
	BSBW	MAC$WRTLST		;AND THE LISTING FILE
	MOVL	L^MAC$GL_ERR_LIST,R10	;GET PTR TO FIRST ERROR BLOCK
	CLRL	@L^MAC$GL_ERR_LIST+4	;CLEAR LINK WORD IN LAST BLOCK
	MOVAB	16(R10),R9		;POINT TO FIRST PAGE/LINE
	SUBL3	12(R10),#<<1024-16>/8>,R8 ;FIGURE PAGE/LINES IN THIS BLOCK
;
; BACK HERE FOR EACH NEW LINE OF LINE/PAGE NUMBERS
;
20$:	PUSHL	#5			;FIVE LINE/PAGES PER LISTING LINE
	MOVAB	L^MAC$AB_LST_END,W^MAC$G_ERRBFDES+4 ;SET BUFFER DESCRIPTOR
;
; HERE FOR EACH NEW LINE/PAGE ITEM ON A PAGE
;
30$:	PUSHL	(R9)+			;STACK THE PAGE NUMBER
	MOVL	#1,R0			; Assume insert number exists
	MOVZWL	(R9)+,-(SP)		; Stack insert number
	BNEQ	35$			; If NEQ insert number did exists
	CLRL	R0			; Set no insert number
	MOVL	4(SP),(SP)		; and move up line number
35$:
	PUSHL	R0			; Stack number of insert numbers (0 or 1)
	PUSHL	R0			; Stack number of '.'s (0 or 1)
	MOVZWL	(R9)+,-(SP)		; Stack line number
	MOVL	SP,R0			;COPY STACK ADDRESS
	$FAOL_S CTRSTR=L^MAC$AB_LPG_FMT,- ;FORMAT THE LINE/PAGE
		OUTBUF=L^MAC$G_ERRBFDES,-
		OUTLEN=L^MAC$GL_LINELN,-
		PRMLST=(R0)
	ADDL2	#14,W^MAC$G_ERRBFDES+4	;UPDATE POINTER FOR NEXT FAO (12 BYTES/LINE/PAGE)
	ADDL2	#5*4,SP			;DELETE FIVE LONGWORDS FROM STACK
	SOBGTR	R8,40$			;BRANCH IF NOT DONE THIS BLOCK
	MOVL	(R10),R10		;YES--LINKE TO NEXT
	BEQL	50$			;IF EQL ALL DONE
	MOVAB	16(R10),R9		;POINT TO FIRST LINE/PAGE
	SUBL3	12(R10),#<<1024-16>/8>,R8 ;FIGURE LINE/PAGES IN THIS BLOCK
40$:	SOBGTR	(SP),30$		;LOOP FOR 5 LINE/PAGES
50$:	TSTL	(SP)+			;CLEAR STACK
	SUBL3	#MAC$AB_LINEBF,W^MAC$G_ERRBFDES+4,- ;FIGURE LINE LENGTH
			R0
	MOVL	R0,L^MAC$GL_LINELN	;SAVE LINE LENGTH
	BSBW	MAC$WRITE_TERM		;WRITE LINE TO TERMINAL
	BSBW	MAC$WRTLST		;WRITE THE LINE
	TSTL	R10			;ANY MORE TO DO?
	BNEQ	20$			;IF NEQ YES
	BSBW	MAC$TERM_BLANK		;BLANK LINE TO TERMINAL
PRT_ERR_SUM_END:

	.SBTTL	PRINT COMMAND LINE

PRT_CMD_LIN:
	BSBW	MAC$WRT_BLNKLIN		;SKIP A LINE
	PUSHL	L^MAC$GL_CMDLIN		;STACK COMMAND LINE ADDRESS
	PUSHL	L^MAC$GL_CMDLEN		;AND ITS LENGTH
	MOVAB	L^MAC$AB_CMD_FAO,R0	;POINT TO FAO CONTROL STRING
	BSBW	MAC$FAOUTS		;FORMAT THE STRING
	ADDL3	L^MAC$GL_ERRCT,L^MAC$GL_WARNCT,R0 ;ERRORS OR WARNINGS?
	ADDL2	W^MAC$GL_INFOCNT,R0	; or information messages?
	BEQL	10$			;IF EQL NO
	BSBW	MAC$WRITE_TERM		;YES--WRITE TO TERMINAL ALSO
10$:	BSBW	MAC$WRTLST		;WRITE TO LISTING FILE
	ADDL2	#2*4,SP			;CLEAR 2 LW FROM STACK
FIN_ASM_EXIT:
	POPL	R10			;RESTORE R10
	POPR	#^M<R7,R8,R9>		;RESTORE REGISTERS
	RSB				;**EXIT FROM MAC$FINISH_ASM

	.SBTTL	OUTPUT ONE PHASE OF CROSS REFERENCE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS ONE PHASE OF THE CROSS REFERENCE.
;
; INPUTS:
;
;	R0	POINTER TO HEADER MESSAGE (THE ONE INSIDE THE BOX)
;	R1	POINTER TO SECONDARY HEADER (NAME,DEFINED,REFERENCES...)
;	R2	POINTER TO CREF CONTROL TABLE
;	R3	CRF$K_VALS_REFS OR CRF$K_DEFS_REFS
;
;--

CREF_TREE_OUT:
	CLRL	L^MAC$GL_LINE_CNT	;ALWAYS FORCE NEW PAGE FOR CREF
	PUSHL	R3			;SAVE REFS OR DEFS_REFS FLAG
	PUSHL	R2			;SAVE CREF CONTROL BLOCK ADDRESS
	PUSHL	R1			;SAVE SECONDARY HEADER MSG
	PUSHL	#4			;STACK # LINES USED BY HEADER (-1)
	PUSHL	R0			;STACK HEADER MESSAGE ADDRESS
	PUSHL	#5+4			;STACK # LINES ACTUALLY NEEDED
	PUSHAB	L^MAC$AB_CRF_MSG	;STACK LINE 2 HEADER MESSAGE
	CALLS	#4,W^NEW_SBT_CK_PAGE	;DO HEADER THING
	DECL	L^MAC$GL_LINE_CNT	;COUNT EXTRA LINE OUTPUT BY SECONDARY HEADER
	POPL	R0			;GET THE DEFS/REFS... STRING
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT (NO ARGS)
	POPL	R0			;GET CREF CONTROL BLOCK ADDRESS
	POPL	R1			;GET THE REFS OR DEFS_REFS FLAG
	PUSHL	#CRF$K_DELETE		;DELETE TREE FLAG FOR CREF
	PUSHL	R1			;SET REFS OR DEFS_REFS FLAG ON STACK
	PUSHL	W^MAC$GL_LN_PAGE	;# LINES ON SUBSEQUENT PAGES
	PUSHL	L^MAC$GL_LINE_CNT	;# LINES ON FIRST PAGE
	PUSHL	#132			;WIDTH OF A LINE
	PUSHL	R0			;CREF CONTROL BLOCK ADDRESS
	CALLS	#6,G^CRF$OUT		;OUTPUT CROSS REFERENCE
	RSB

	.SBTTL	SET UP FOR NEW SUBTITLE AND CHECK NEW PAGE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PUTS A NEW LINE IN THE SUBTITLE BUFFER FOR
;	PSECT SYNOPSIS AND THE RUN STATISTICS.
;
; INPUTS:
;
;	4(AP)	ADDRESS OF STRING TO PUT IN TITLE BUFFER (COUNT,TEXT)
;	8(AP)	# LINES NEEDED LEFT ON PAGE
;	12(AP)	ADDRSS OF HEADER MESSAGE
;	16(AP)	# LINES ACTUALLY USED BY HEADER (-1)
;
;--


NEW_SBT_CK_PAGE:
	.WORD	0			;ENTRY MASK
	MOVL	4(AP),R0		;GET SUBTITLE STRING ADDRESS
	MOVZBL	(R0)+,R1		;GET ITS LENGTH
	MOVC5	R1,(R0),#^A/ /,-	;COPY OVER SUBTITLE AND IDENT
		#LST$K_TITLE_SIZ+SYM$K_MAXLEN+1, -
			L^MAC$AB_SBT_IDNT
	SUBL3	8(AP),L^MAC$GL_LINE_CNT,R0 ;SEE IF ROOM LEFT ON PAGE
	BGTR	10$			;IF GTR YES
	BSBW	MAC$LST_PAG_HDR		;NO--MAKE NEW PAGE NOW
10$:	MOVL	12(AP),R0		;GET ADDRESS OF HEADER MESSAGE
	BSBW	MAC$WRT_FAOUTS		;FORMAT AND OUTPUT THE STRING
	SUBL2	16(AP),L^MAC$GL_LINE_CNT;UPDATE THE LINES LEFT COUNT
	RET				;ALL DONE

	.SBTTL	OUTPUT SYMBOL NAME AND VALUE FOR DEBUG

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS THE NAME OF A SYMBOL FOR THE DEBUGGER.
;
; INPUTS:
;
;	R6	POINTS TO SYMBOL BLOCK
;
;--

MAC$DBG_NAM_OUT:
	MOVZBL	SYM$B_NAME(R6),R4	; Get offset to name/count (which is
					; also total size of count and name
	SUBL3	R4,R6,R5		; Set pointer to count/name
10$:	MOVB	(R5)+,R0		;GET CHARACTER OF NAME
	BSBW	MAC$STOIM
	SOBGTR	R4,10$			;LOOP FOR WHOLE NAME
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE VALUE OF A SYMBOL FOR THE DEBUGGER.
;
; INPUTS:
;
;	R6	POINTS TO SYMBOL BLOCK
;
;--

MAC$DBG_VAL_OUT:
	$OBJ_CHKBYT #TIR$C_STA_PL	;STACK PSECT PLUS LONGOWORD
	$OBJ_OUTBYT SYM$B_SEG(R6)	;SYMBOL'S SEGMENT
	MOVAB	SYM$L_VAL(R6),R5	;POINT TO VALUE
	BSBW	MAC$OUT_LW		;OUTPUT VALUE
	$OBJ_CHKBYT #TIR$C_STO_LW	;STORE LONGWORD
	RSB

	.SBTTL	OUTPUT PSECT RECORDS TO DEBUG

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS PSECT INFORMATION TO THE DEBUGGER
;
; INPUTS:
;
;	R6	POINTS TO SYMBOL BLOCK FOR PSECT
;
;--

MAC$DBG_PSECT:
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to symbol count/name
	SUBL3	R0,R6,R0		; Form address of count/name
	ADDB3	(R0),#DBG$K_PSECT_LEN-1,R0 ; Figure size
	BSBW	MAC$STOIM		;STORE IT
	MOVZBL	#DBG$C_PSECT,R0		;PSECT TYPE
	BSBW	MAC$STOIM
	CLRL	R0			;MBZ BYTE
	BSBW	MAC$STOIM
	$OBJ_CHKBYT #TIR$C_STA_PB	;STACK PSECT BASE PLUS BYTE OFFSET
	$OBJ_OUTBYT SYM$B_SEG(R6)	;SYMBOL SEGMENT NUMBER
	CLRL	R0			;USE OFFSET OF 0
	BSBW	MAC$OUTOBJ
	$OBJ_CHKBYT #TIR$C_STO_PIDR	;STORE POSITION INDEPENDENT DATA REFERENCE.
	BSBW	MAC$DBG_NAM_OUT		;SEND PSECT NAME
	MOVAB	SYM$L_VAL(R6),R5	;POINT TO LENGTH
	MOVZBL	#4,R4			;LOOP COUNT
10$:	MOVB	(R5)+,R0		;GET BYTE OF VALUE
	BSBW	MAC$STOIM		;
	SOBGTR	R4,10$
	RSB

	.SBTTL	PRINT PSECT INFORMATION FOR 1 PSECT

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PRINTS THE PSECT SYNOPSIS FOR ONE PSECT.
;
; INPUTS:
;
;	R6	PSECT BLOCK ADDRESS
;
;--

MAC$PSECT_PRINT:
	BSBW	MAC$LIST_INIT		;INIT LISTING BUFFER
	MOVZBL	PSC$B_SEG(R6),R0	;GET SEGMENT NUMBER
	PUSHL	R0			;STACK IT
	PUSHL	R0			;TWICE FOR FAO
	PUSHL	PSC$L_MAXLGTH(R6)	;STACK THE MAX LENGTH
	PUSHL	(SP)			;COPY IT (HEX AND DEC OUTPUT)
	BGTR	5$			;BRANCH IF POSITIVE LENGTH
	CLRL	4(SP)			;ELSE PRINT DECIMAL AS 0
5$:	MOVZBL	PSC$B_NAME(R6),R0	; Get offset to symbol count/name
	SUBL3	R0,R6,-(SP)		; and put its address on stack
	MOVAB	L^MAC$AB_PSS_FAO,R0	;POINT TO FAO CONTROL STRING
	BSBW	MAC$FAOUTS		;FORMAT STRING
	ADDL2	#5*4,SP			;CLEAR THE STACK
	ADDL3	#MAC$K_LIST_SIZE,L^MAC$GL_LINELN,R0 ;FIGURE LENGTH OF LINE SO FAR
	MOVAB	L^MAC$AB_LST_END(R0),-	;INIT LISTING POINTER
			L^MAC$GL_LIST_PTR
	MOVZWL	PSC$W_OPTIONS(R6),R5	;GET PSECT OPTIONS
	MOVL	#1,R4			;FIRST BIT
	PUSHL	#PSC$K_NO_OPTNS		; Loop once for each option
;
; LOOP, PRINTING PSECT OPTIONS
;
10$:	BSBW	PSECT_OPT_MATCH		;PRINT THIS OPTION
	ADDL2	R4,R4			;NEXT BIT
	SOBGTR	(SP),10$		;LOOP FOR ALL
	TSTL	(SP)+			;CLEAN STACK
	MOVZWL	PSC$W_OPTIONS(R6),R4	;COPY OPTIONS AGAIN
	BICL2	#^XPSC$M_ALLOPTNS,R4	; Trim all but alignment
	BISW2	#PSC$M_ALIGNFLG,R4	;SET THE ALIGNMENT FLAG BIT
	MOVL	R4,R5			;POSITIVE SENSE
	BSBW	PSECT_OPT_MATCH		;PRINT ALIGNMENT
	BLBS	R0,20$			;BRANCH IF FOUND
	ASHL	#-PSC$V_ALIGNMENT,R4,R0	;GET ALIGNMENT
	BSBW	MAC$DEC_OUT_L2R		;OUTPUT ALIGNMENT
20$:	SUBL3	#MAC$AB_LINEBF,L^MAC$GL_LIST_PTR,- ;FIGURE LINE LENGTH
			L^MAC$GL_LINELN
	BRW	MAC$WRTLST		;WRITE LINE TO LISTING AND RETURN

	.SBTTL	MATCH PSECT OPTIONS FOR PRINTING

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PRINTS EITHER 'XXX' OR 'NOXXX' FOR A GIVEN
;	PSECT OPTION.
;
; INPUTS:
;
;	R4	BIT VALUE
;	R5	OPTIONS
;
;--

PSECT_OPT_MATCH:
	MOVW	R4,R0			;COPY BITS
	BEQL	10$			;IF EQL NOT COMPLEMENTED
	BITW	R0,R5			;NEGATIVE POLARITY?
	BNEQ	10$			;IF NEQ NO
	MCOMW	R0,R0			;YES--GET COMPLEMENTED VALUE
10$:	MOVAB	L^PSC$G_OPTIONS,R3	;POINT TO PSECT OPTIONS
20$:	CMPW	R0,SYM$L_VAL+2(R3)	;IS THIS IT?
	BEQL	30$			;IF EQL YES
	MOVL	SYM$L_LINK(R3),R3	; No--link to next
	BNEQ	20$			;IF NEQ GO ON
	CLRL	R0			;RETURN 0 FOR NOT FOUND
	RSB
30$:	MOVZBL	SYM$B_NAME(R3),R0	; Get offset to count/name
	SUBL3	R0,R3,R0		; and form its address
	MOVZBL	(R0)+,R1		;COPY THE SIZE
	MOVL	L^MAC$GL_LIST_PTR,R2	;GET LISTING POINTER
	PUSHR	#^M<R4,R5>		;SAVE OPTION PARAMETERS
	CMPB	R1,#3			;IS IT LESS THAN 3-CHAR NAME?
	BGTR	40$			;IF GTR NO
	TSTW	(R2)+			;YES--BUMP POINTER BY TWO
40$:	MOVC3	R1,(R0),(R2)		;COPY INTO BUFFER
	POPR	#^M<R4,R5>		;RESTORE OPTION PARAMS
	ADDL2	#6,L^MAC$GL_LIST_PTR	;TAB TO NEXT OPTION
	MOVZBL	#1,R0			;RETURN FOUND
	RSB

	.SBTTL	PRINT SYMBOL INFORMATION FOR ONE SYMBOL

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PRINTS THE SYMBOL INFORMATION FOR ONE SYMBOL
;
; INPUTS:
;
;	R6	POINTS TO THE SYMBOL BLOCK
;
;--

MAC$PRT_SYM_INF:
	PUSHR	#^M<R6,R7,R8,R9,R10>
	MOVL	L^MAC$GL_LIST_PTR,R10	;GET CURRENT POINTER
	PUSHL	R10			;COPY ONTO STACK
	MOVZBL	SYM$B_NAME(R6),R0	; Get offset to symbol count/name
	SUBL3	R0,R6,R0		; and form its address
	MOVZBL	(R0)+,R1		; Get count and advance pointer to name
	MOVC3	R1,(R0),(R10)		; Copy into listing buffer
	ADDL3	#<SYM$K_TWOCOL-1>,(SP),R10 ; Point past end of name
	BBC	#FLG$V_SYM2COL,(R11),5$	; Branch if not 2 column listing
	ADDL2	#<SYM$K_MAXLEN-SYM$K_TWOCOL+1>,R10 ; Allow for 31 character symbol
5$:
	BBC	#SYM$V_ASN,SYM$W_FLAG(R6),10$ ;BRANCH IF NOT ASSIGNED SYMBOL
	MOVB	#^A/=/,(R10)+		;YES--STORE EQUAL SIGN
	BRB	20$
10$:	MOVB	#^A/ /,(R10)+
20$:	ADDL2	#9,R10			;MAKE ROOM FOR VALUE
	MOVL	R10,L^MAC$GL_LIST_PTR	;STORE CURRENT POINTER
	PUSHL	R10			;SAVE ON STACK ALSO
	BBS	#SYM$V_DEF,SYM$W_FLAG(R6),30$ ;BRANCH IF SYMBOL DEFINED
	MOVC5	#0,(SP),#^A/*/,#8,-8(R10) ;NO--FILL VALUE FIELD WITH STARS
	BRB	40$
30$:	INCL	R7			;DEFINED--STACK VALUE
	MOVL	SYM$L_VAL(R6),L^MAC$AL_VALSTACK[R7] ;...
	MOVZBL	#4,R0			;LIST LONGWORD VALUE
	BSBW	MAC$LIST_BYT_0		;...
40$:	POPL	R10			;RESTORE POINTER
	MOVZWL	SYM$W_FLAG(R6),R0	;GET SYMBOL FLAGS
	BBC	#SYM$V_WEAK,R0,50$	;BRANCH IF NOT WEAK
	MOVB	#^A/W/,0(R10)		;YES--FLAG IT
50$:	BBS	#SYM$V_ABS,R0,60$	;BRANCH IF ABSOLUTE SYMBOL
	BBC	#SYM$V_DEF,R0,60$	;NO--BRANCH IF DEFINED
;
; SYMBOL IS RELOCATABLE AND DEFINED
;
	MOVB	#^A/R/,1(R10)		;FLAG RELOCATABLE
60$:	BBC	#SYM$V_GLOBL,R0,70$	;BRANCH IF NOT GLOBAL SYMBOL
	MOVB	#^A/G/,2(R10)		;YES--FLAG IT
70$:	BBC	#SYM$V_EXTRN,R0,80$	;BRANCH IF NOT EXTERNAL
	MOVB	#^A/X/,3(R10)		;YES--FLAG IT
80$:	BBC	#SYM$V_ODBG,R0,90$	;BRANCH IF NO DEBUG OUTPUT FOR SYMBOL
	MOVB	#^A/D/,4(R10)		;YES--FLAG IT
90$:	BITW	#SYM$M_DEF!SYM$M_GLOBL!SYM$M_EXTRN,R0 ;
	BNEQ	100$			;IF DEFINED, GLOBAL OR EXTERNAL
	MOVB	#^A/U/,5(R10)		;NO--MARK AS UNDEFINED
100$:	ADDL2	#9,R10			;MOVE TO PSECT SPOT
	MOVL	R10,L^MAC$GL_LIST_PTR	;STORE POINTER
	BBS	#SYM$V_ABS,R0,110$	;BRANCH IF ABSOLUTE
	MOVZBL	SYM$B_SEG(R6),R0	;GET SEGMENT NUMBER
	INCL	R7			;STACK IT
	MOVL	R0,L^MAC$AL_VALSTACK[R7] ;...
	MOVZBL	#1,R0			;LIST ONE BYTE
	BSBW	MAC$LIST_BYT_0		;...
110$:	ADDL3	#40,(SP)+,L^MAC$GL_LIST_PTR ; Figure new pointer and store it
	BBC	#FLG$V_SYM2COL,(R11),120$ ; Branch if not 2 column listing
	ADDL2	#18,L^MAC$GL_LIST_PTR	; Allow for larger symbol name
120$:
	POPR	#^M<R6,R7,R8,R9,R10>	;RESTORE REGS
	RSB

MAC$LIST_INIT:
	MOVAB	L^MAC$AB_LST_END,R0	;POINT TO BUFFER
	MOVL	R0,L^MAC$GL_LIST_PTR	;SET POINTER
	MOVC5	#0,(SP),#^A/ /,#132,(R0);FILL BUFFER WITH BLANKS
	RSB

	.END
