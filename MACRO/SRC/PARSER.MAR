	.TITLE	MAC$PARSER PARSER FOR VAX-11 MACRO
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 28-AUG-78
;
; MODIFIED BY:
;
;	V02.06	HJ0001		Herb Jacobs	14-Aug-1980
;		Performance improvement to parse driver loop.
;
;	V01.05	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error messages from system
;		message file.
;
;	V01.04	RN0005		R. Newland	27-Aug-1979
;		Remove .ALIGN LONG statements and change L^ to W^.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_GENVALDEF			;DEFINE COMMON SYMBOLS
	$MAC_CTLFLGDEF			;DEFINE BIT FLAGS
	$MAC_INTCODDEF			;DEFINE INT. FILE ACTIONS
	$MACMSGDEF			; Define message codes

;
; EQUATED SYMBOLS:
;

ELSE_CODE	=	-3		;ELSE CODE
CONT_CODE	=	-4		;CONTINUE CODE
SCAN_CODE	=	9998.		;SCAN CODE
ERR_CODE	=	9999.		;ERROR CODE
ERR_MAX		=	9.		;MAX ERROR CODE

;
; OWN STORAGE:
;


	.SBTTL	MAC$PARSE PARSE VAX-11 MACRO PROGRAM

;++
; FUNCTIONAL DESCRIPTION:
;	THE PARSE ROUTINE PERFORMS THE FOLLOWING ACTIONS:
;
;	1) INITIALIZE VARIABLES
;
;	2) MAKE AN INITIAL CALL TO 'MAC$GETCHR' TO GET THE FIRST
;	   CHARACTER (AND FIRST DATA RECORD)
;
;	3) MAKE AN INITIAL CALL TO 'MAC$TOKEN' TO DETERMINE THE
;	   FIRST LEXICAL ITEM, AND TO CLASSIFY IT INTO ONE OF
;	   THE LEXICAL CLASS.
;
;	4) IT THEN DETERMINES THE NEXT TRANSITION STATE BY USING
;	   THE CURRENT STATE AS <J> THE INDEX INTO THE STATE TABLE
;	   OF TRANSITIONS.
;
;	5) THE JTH TRANSITION STATE IS THEN COMPARED TO THE CLASS
;	   OF THE TOKEN.  IF IT IS EQUAL TO THE <CLASS> OR IT IS
;	   EQUAL TO THE <ELSE_CODE> THEN A 'MATCH' IS PERFORMED
;	   AND THE SEQUENCE STARTS BACK AT 4).
;
;	6) IF THE <TRANSITION> DID NOT MATCH EITHER THE <ELSE_CODE>
;	   OR THE <CLASS> THEN IF THE <TRANSITION> EQUALS THE
;	   <CONT_CODE> THEN <J>, THE INDEX INTO THE <TRANSITION>
;	   TABLE IS CHANGED TO BE THE JTH ITEM IN THE <ACTION>
;	   TABLE.  IF IT DOES NOT EQUAL THE CONTINUE CODE <J> IS
;	   SIMPLY INCREMENTED BY 1.
;
;	7) ACTION NOW CONTINUES AT 5).
;
;
; CALLING SEQUENCE:
;
;	JSB	MAC$PARSE
;
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;	R11	POINTER TO 'MAC$GL_FLAGS'
;	R10	CURRENT CHARACTER
;	R9	FRAME BUFFER POINTER
;	R8	TOKEN RETURNED FROM MAC$TOKEN AND SEMANTIC ROUTINES
;	R7	EXPRESSION STACK POINTER (0-100)
;	-----------------------------------------------------------
;	REGISTERS R11-R7 MUST NOT BE ALTERED BY SEMANTIC ROUTINES.
;	REGISTERS R6-R0 ARE AVAILABLE FOR SEMANTIC ROUTINES TO USE
;	WITHOUT SAVING (SEE LRPTAB FOR A LIST OF SEMANITC ROUTINES).
;	IN ADDITION, ANY ROUTINES CALLED BY 'MAC$TOKEN' MAY ALTER
;	REGISTERS R0-R6.
;	-----------------------------------------------------------
;	R6	TOKEN IN PASS 1
;	R5	POINTER INTO PARSE TABLES
;	R4	CURRENT PARSE STATE
;	R3	ACTION
;	R2-R0	SCRATCH
;
;--



	.PSECT	MAC$RO_CODE_P1,NOWRT,GBL,LONG

MAC$PARSE::
	BBCS	#FLG$V_BOL,(R11),.+1	;FLAG BEGINNING OF LINE
	BBCS	#FLG$V_SKAN,(R11),.+1	;FLAG SCANNING PERMITTED
	BBCC	#FLG$V_OPRND,(R11),.+1	;NOT IN OPERAND FIELD
	BBCC	#FLG$V_CRSEEN,(R11),.+1	;FLAG CR NOT SEEN YET FOR TOKEN
	MOVZBL	#CR,R10			;FORCE READING OF NEW LINE
	BSBW	MAC$GETCHR		;GET FIRST CHARACTER
	CLRL	R7			;INIT PARSE STACK POINTER
	BSBW	MAC$TOKEN		;GET FIRST TOKEN TYPE
	CLRL	R4			;CLEAR CURRENT STATE
	MOVL	R8,R6			;SET CURRENT TOKEN CLASS
	.ENABL	LSB
;
; THIS CODE IS DEPENDENT ON THE SIZE OF THE ENTRIES IN THE SYMLST TABLE!
;
PARSE_LOOP:
10$:	MOVL	R4,R5			;COPY CURRENT STATE
15$:	MOVAB	L^PAT$AB_SYMLST[R5],R2	;GET ADDRESS OF STATE TABLE OFFSET
	TSTW	R6			;ERROR PROCESSING TOKEN CLASS?
	BNEQ	20$			;IF NE NO
18$:	CMPB	#ERR_MAX,(R2)		;TOKEN CLASS ERROR?
	BGEQU	40$			;IF GTRU YES
	CMPB	#CONT_CODE,(R2)+	;TOKEN CLASS EQUAL ELSE OR CONTINUE?
	BGTRU	18$			;BRANCH IF NEITHER TO STILL SEARCH
	BRB	25$			;PROCESS ELSE OR CONTINUE

20$:	CMPB	(R2),R6			;STATE EQUAL TO TOKEN CLASS?
	BEQL	40$			;IF EQ YES
	CMPB	#CONT_CODE,(R2)+	;TOKEN CLASS EQUAL ELSE OR CONTINUE?
	BGTRU	20$			;BRANCH IF NEITHER TO STILL SEARCH
25$:	BNEQ	41$			;BRANCH IF ELSE
	MOVAB	L^PAT$AB_SYMLST+1,R3	;GET ADDR OF START OF TABLE (FIX R2+1)
	SUBL	R3,R2			;FORM OFFSET INTO TABLE
	CVTWL	L^PAT$AW_ACTION[R2],R5	;GET CONTINUE LOCATION
	BRB	15$
;
; PERFORM MATCH
;
; THIS CODE IS DEPENDENT ON THE SIZE OF THE ENTRIES IN THE SYMLST TABLE!
;
41$:	DECL	R2			;ADJUST R2, WE WENT 1 TO FAR
40$:	MOVAB	L^PAT$AB_SYMLST,R3	;GET ADDRESS OF START OF TABLE
	SUBL	R3,R2			;FORM OFFSET INTO TABLE
	CVTWL	L^PAT$AW_ACTION[R2],R3	;GET ACTION TO PERFORM
	CMPW	#ERR_CODE,R3		;ERROR DETECTED?
	BNEQ	60$			;IF NEQ NO
	TSTW	R6			;BACKTRACKING ERROR?
	BNEQ	50$			;IF NEQ NO
	DECL	R7			;YES--BACK UP PARSE STACK POINTER
	MOVL	W^MAC$AL_PSTACK[R7],R4	; Back up to previous state
50$:	CLRL	R6			;START BACKTRACKING IF NOT ALREADY
	BRB	10$			;...
60$:	CMPW	#-SCAN_CODE,R3		;LOOK AHEAD (NO SCAN)?
	BGEQ	70$			;IF GEQ YES
	MOVL	R4,W^MAC$AL_PSTACK[R7]	; No--save current state
	MOVL	W^MAC$GL_VALUE,W^MAC$AL_VALSTACK[R7] ; ...
70$:	TSTW	R3			;TIME TO READ NEXT TOKEN?
	BLSS	90$			;IF LSS NO
;
; READ NEXT TOKEN
;
	MOVL	R3,R4			;SET CURRENT STATE TO ACTION
	INCL	R7			;ADVANCE STACK POINTER
	BBSS	#FLG$V_SKAN,(R11),80$	;BR IF OK TO SCAN FOR NEXT TOKEN
					; AND SET SCAN OK FLAG
	MOVL	W^MAC$GL_VNEXT,-	;RESET CONTEXT,
			W^MAC$GL_VALUE	;	symbol already scanned
	MOVL	W^MAC$GL_NEXT,R6	;	during a look-ahead
	BRW	10$			;CONTINUE SCANNING
80$:	PUSHR	#^M<R4,R5,R6>		;SAVE REGISTERS
	BSBW	MAC$TOKEN		;GET NEXT TOKEN
	POPR	#^M<R4,R5,R6>		;RESTORE REGISTERS
	MOVL	R8,R6			;SET CLASS TO TOKEN TYPE
	BRW	10$			;CONTINUE SCANNING
;
; CALL SEMANTIC ROUTINE TO PERFORM REDUCTION TO NON-TERMINAL STATE
;
90$:	CMPW	R3,#-SCAN_CODE		;NO-SCAN?
	BGTR	100$			;IF GTR THEN NOT NO-SCAN
	ADDW2	#SCAN_CODE,R3		;NO-SCAN--CORRECT ACTION CODE
	DECL	R7			;BACK UP STACK POINTER
	MOVL	R6,W^MAC$GL_NEXT	; Save current flags
	MOVL	W^MAC$GL_VALUE,-
			W^MAC$GL_VNEXT	; Save current value
	BBCC	#FLG$V_SKAN,(R11),100$	;PROHIBIT SCANNING
100$:	MOVL	W^MAC$AL_VALSTACK[R7],-
			W^MAC$GL_VALUE	; Get current value
	MNEGL	R3,R3			;GET ACTION ROUTINE NUMBER
	MOVL	L^PAT$AL_SEM[R3],R2	;GET ADDRESS OF SEMANTIC ROUTINE
	BEQL	110$			;IF EQL NULL ACTION
	PUSHR	#^M<R3,R4,R5,R6>	;SAVE REGISTERS
MAC$CALL_SEM::
	JSB	(R2)			;CALL SEMANTIC ROUTINE
	POPR	#^M<R3,R4,R5,R6>	;RESTORE REGISTERS
110$:	MOVZBL	L^PAT$AB_POP(R3),R2	;GET NUMBER OF ITEMS TO POP
	SUBL2	R2,R7			;"POP" THE STACK
	MOVL	W^MAC$AL_PSTACK[R7],R4	; Get current state
	MOVL	W^MAC$GL_VALUE,-
			W^MAC$AL_VALSTACK[R7] ; Put result on stack
	MOVZBL	L^PAT$AB_LHS(R3),R6	;PICK UP CLASS OF LEFT HAND SIDE
	BRW	10$			;CONTINUE SCANNING
;
; THE FOLLOWING ARE ROUTINES WHICH NEED TO BE DEFINED FOR THE
; GRAMMAR.  IT IS A NO-OP SEMANTIC ROUTINE.
;
GOAL::
	RSB
	.DSABL	LSB

	.SBTTL	MAC$TOKEN GET NEXT LEXICAL TOKEN

;++
;	THE NEXT LEXICAL TOKEN TYPE IS RETURNED IN R8.  THE VALUE
;	ASSOCIATED WITH THE TOKEN IS RETURNED IN MAC$GL_VALUE.
;--

MAC$TOKEN::
	MOVL	W^MAC$GL_ERRPTX,-
			W^MAC$GL_ERRPT	;POINT TO PREVIOUS TOKEN
	MOVL	W^MAC$GL_LINEPT,-
			W^MAC$GL_ERRPTX	;POINT TO THIS TOKEN
	CLRQ	W^MAC$GL_VALUE		;DEFAULT VALUE IS 0
10$:	BSBW	MAC$SKIPSP		;SKIP SPACES
	BBS	#CHR$V_ILL_CHR,-	;BRANCH IF ILLEGAL CHR.
		W^MAC$AB_CMSK_TAB(R10),40$
	MOVL	MAC$AL_CHRTAB[R10],R8	;NO--GET TOKEN FOR CHARACTER
	BBCC	#31.,R8,30$		;BR IF NOT A TOKEN
	CMPB	R10,#CR			;IS CHARACTER A CARRIAGE RETURN?
	BNEQ	20$			;IF NEQ NO--GET NEXT CHARACTER
	BBSC	#FLG$V_CRSEEN,(R11),20$	;YES--HAVE WE SEEN IT BEFORE?
					;    (AND CLEAR FLAG)
	BBCS	#FLG$V_CRSEEN,(R11),.+1	;NO--SET FLAG FOR LATER
	RSB				;RETURN WITH CR TOKEN
20$:	BRW	W^MAC$GETCHR		;GET NEXT CHARACTER
					;AND RETURN TO CALLER
;
; CHARACTER IS NOT A TOKEN--CALL SCANNING ROUTINE
;
30$:	JMP	(R8)			;DISPATCH TO SCANNING ROUTINE
;
; CHARACTER IS ILLEGAL
;
40$:
MAC$CHRERR::				;ENTRY FROM MAC$XUPARROW
					; (MAC$XUPARROW IS JMP'ED TO
					; FROM MAC$TOKEN)
	$MAC_ERR ILLCHR			; Get message code
	BSBB	MAC$ERRORLN		;REPORT CHARACTER ERROR
	BSBW	MAC$GETCHR		;GET NEXT CHARACTER
	BRB	MAC$TOKEN		;GET NEXT TOKEN

;++
;	ERROR ROUTINES
;	ENTER WITH R0 CONTAINING THE ERROR MESSAGE INDEX.
;--

	.ENABL	LSB

MAC$ERRORPX::				;ERROR USING MAC$GL_ERRPTX
	PUSHL	W^MAC$GL_ERRPTX		;STACK POINTER
	BRB	10$

MAC$ERRORPT::				;ERROR USING MAC$GL_ERRPT
	PUSHL	W^MAC$GL_ERRPT		;STACK POINTER
	BRB	10$

MAC$ERRORLN::				;ERROR USING MAC$GL_LINEPT
	PUSHL	W^MAC$GL_LINEPT		;STACK POINTER
10$:	BBCC	#FLG$V_EXPOPT,(R11),.+1	;DO NOT ALLOW EXPRESSION OPT.
	PUSHL	R0			;STACK ERROR MESSAGE INDEX
	MOVZBL	#INT$_ERR,R0		;SET INT. CODE FOR ERROR
	BSBW	MAC$INTOUT_2_LW		;OUTPUT TO INT. FILE
					;(NOTE: MUST BE BSBW/RSB; SEE
					; INTOUT.MAR)
	RSB				;ALL DONE

	.DSABL	LSB

	.END
