	.TITLE	MAC$GETCMD	GET COMMAND MODULE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 28-AUG-78
;
; MODIFIED BY:
;
;	V03-000		MTR0010		Mike Rhodes		15-Mar-1982
;		Remove $CLIDEFQUALMACR macro, since the symbols which it
;		defined are globally available during the build.
;
;	V02-014		MTR0002		Mike Rhodes		01-Dec-1981
;		Modify the /DEBUG action routine to allow the SYMBOLS and
;		TRACEBACK qualifier values to coexist in a qualifier list
;		without negating one another.
;
;	V02-013		MTR0001		Mike Rhodes		09-Nov-1981
;		Add a new action routine (called by the CLI parsing routines)
;		to process the /[NO]DEBUG qualifier and its parameters.  The
;		processing consists of setting/clearing bits in the options
;		vector MAC$GL_ENLISF.
;
;	V02-012		BLS0057		Benn Schreiber		13-Jun-1981
;		Correct reference to SUM$OPEN to use General addressing mode
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_MLFDEF			; Define MLF offsets
	$MAC_CTLFLGDEF			;DEFINE VAX MACRO CONTROL FLAGS
	$MAC_SYMBLKDEF			;DEFINE MAX LENGTH OF SYMBOL NAME
	$MAC_CRFLAGDEF			;DEFINE CREF FLAG BITS
	$CLIDEF				;CLI DEFINITIONS
	$FABDEF				;DEFINE FAB OFFSETS
	$NAMDEF				;DEFINE NAM BLOCK OFFSETS

;
; EQUATED SYMBOLS:
;

	_VIELD	MAC,1,<-
		LIST,-			;LIST FILE PRESENT FLAG
		OBJECT,-		;OBJECT FILE PRESENT FLAG
		INPFIL,-		;INPUT FILE IS PRESENT
		CROSSREF,-		;CROSS REFERENCE REQUESTED
		<LIBRARY,,M>, -		;Input file is a library
		<UPDATE,,M>, -		;Input file has updates
		>

;
; OWN STORAGE:
;

	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG

INP_DEFEXT:
	.ASCIC	/.MAR/			;DEFAULT FILE SPEC FOR INPUT
10$:
	.PSECT	MAC$CLIWORKDATA,NOEXE,LONG

CLIWORK:
	.BLKB	CLI$K_WORKAREA		;RESULT PARSE WORK AREA

UPDATE_LIST:
	.BLKL	1			; Update list address

	.PSECT	MAC$CLI_ARGLST,NOEXE,NOWRT,GBL,LONG

OBJ_ARGLIST:
	$ARGLST	3,OBJ_DESC,CLIWORK,-	;ARGUMENT LIST FOR CALL BACK
		MAC$GL_CTLMSK			; TO PARSE OBJECT FILE
LST_ARGLIST:
	$ARGLST	3,LIST_DESC,CLIWORK,-	;ARG LIST FOR CALL BACK
		MAC$GL_CTLMSK			; TO PARSE LIST FILE
INP_ARGLIST:
	$ARGLST	3,INP_DESC,CLIWORK,-	;ARG LIST FOR CALL BACK
		MAC$GL_CTLMSK		; TO PARSE INPUT FILES

	.PSECT	MAC$RO_DATA,NOWRT,NOEXE,GBL,LONG

;
; CLI CALL BACK DATA STRUCTURES
;

	.PSECT	MAC$CLIDATSTR,NOEXE,LONG

CROS_DESC:				;QUALIFIER DESCRIPTOR FOR /CROSS
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_CROS,-
		SETLST=MAC_V_CROSSREF,-	;SET THE BIT
		TRUACT=MACR_CROS	;PROCESS ANY VALUES

SHOW_DESC:				;QUALIFIER DESCRIPTOR FOR /SHOW
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_SHOW,-
		TRUACT=MACR_SHOW
NOSH_DESC:				;QUALIFIER DESCRIPTOR FOR /NOSHOW
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_NOSH,-
		TRUACT=MACR_NOSH
	.LONG	0			;MARK END


LIBR_DESC:				;QUALIFIER DESCRIPTOR FOR /LIBRARY
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_LIBR,-
		SETLST=MAC_V_LIBRARY -
		TSTLST=MAC_V_UPDATE -
		TRUACT=LIBR_FILE

ENAB_DESC:				;QUALIFIER DESCRIPTOR FOR /ENABLE
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_ENAB,-
		TRUACT=MACR_ENAB

DISA_DESC:				;QUALIFIER DESCRIPTOR FOR /DISABLE
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_DISA,-
		TRUACT=MACR_DISA

DEBU_DESC:				;QUALIFIER DESCRPITOR FOR /DEBUG
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_DEBU,-
		QDFLGS=CLI$V_QDEXPA,-
		TRUACT=MACR_DEBU,-
		FLSACT=MACR_NODE

UPDA_DESC:				;QUALIFER DESCRIPTOR FOR /UPDATE
	$CLIQUALDESC	-
		QDCODE=CLI$K_MACR_UPDA, -
		SETLST=MAC_V_UPDATE -
		TSTLST=MAC_V_LIBRARY -
		TRUACT=MACR_UPDA

	.LONG	0
INPUTQUALEND:

ASCII_VALUE:				;REQUEST DESCRIPTOR FOR ASCII VALUE
	$CLIREQDESC	-
		RQTYPE=CLI$K_ASCIIVAL	;CONVERT AN ASCII STRING
GETCMD:	$CLIREQDESC	-		;REQUEST DESCRIPTOR FOR GET COMMAND LINE
		RQTYPE=CLI$K_GETCMD

INIPRS:	$CLIREQDESC	-		;REQUEST DESCRIPTOR FOR INIT
		RQTYPE=CLI$K_INITPRS,-
		ERRACT=CLI_ERROR

PRSDON:	$CLIREQDESC	-		;REQUEST DESCRIPTOR FOR REQUEST DONE
		RQTYPE=CLI$K_ENDPRM1,-	;COMPLETED WITH PARAMETER SET ONE
		ERRACT=CLI_ERROR

OBJ_DESC:
	$CLIREQDESC	-
		RQTYPE=CLI$K_OUTPUT1,-
		BITNUM=MAC_V_OBJECT,-
		ERRACT=CLI_ERROR,-
		PRSACT=OBJ_FILE

LIST_DESC:
	$CLIREQDESC	-
		RQTYPE=CLI$K_OUTPUT2,-
		BITNUM=MAC_V_LIST,-
		ERRACT=CLI_ERROR,-
		PRSACT=LIST_FILE,-
		QUALST=CROS_DESC

INP_DESC:
	$CLIREQDESC	-
		RQTYPE=CLI$K_INPUT1,-
		RQFLGS=CLI$V_PARMREQ,-	;REQUIRE AT LEAST 1 INPUT FILE
		BITNUM=MAC_V_INPFIL,-
		ERRACT=CLI_ERROR,-
		PRSACT=INP_FILE,-
		QUALST=LIBR_DESC

	.SBTTL	PARSE COMMAND LINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MAKES THE CALLS BACK TO CLI TO PARSE THE
;	COMMAND LINE.  IT FIRST MAKES A CALL BACK TO CLI TO
;	GET THE COMMAND LINE SO IT MAY BE INCLUDED IN THE LISTING.
;
; CALLING SEQUENCE:
;
;	NONE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	MAC$GL_CLIADDR	CONTAINS THE ADDRESS OF THE CLI
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



	.PSECT	MAC$RO_CODE_P35,NOWRT,GBL,LONG

MAC$GETCMD::
	PUSHR	#^M<R7,R8,R9,R10,R11>	;SAVE REGISTERS
	PUSHAB	L^MAC$GQ_RNT_CMD	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_ON	;BEGIN TIMING COMMAND PROCESSING
	PUSHAB	L^GETCMD		;SET UP STACK
	CALLS	#1,@MAC$GL_CLIADDR	;RECALL CLI TO GET COMMAND LINE
	MOVL	L^GETCMD+CLI$Q_RQDESC,-	;SAVE THE LENGTH OF THE COMMAND LINE
			L^MAC$GL_CMDLEN	; ...
	MOVL	L^GETCMD+CLI$Q_RQDESC+4,- ;AND ITS ADDRESS
			L^MAC$GL_CMDLIN	; TO PRINT ON LISTING AND/OR TERMINAL
	BBSC	#FLG$V_MOREINP,(R11),5$	;BRANCH IF NOT FIRST CALL
	PUSHAB	L^CLIWORK		;STACK ARGS TO RECALL CLI
	PUSHAB	L^INIPRS		; FOR THE INITIATE PARSE CALL
	CALLS	#2,@MAC$GL_CLIADDR	;RECALL CLI TO INITIATE PARSE
;
; PARSE OBJECT FILE
;
5$:	CALLG	OBJ_ARGLIST,-		;RECALL CLI TO PARSE OBJECT FILE
			@MAC$GL_CLIADDR
;
; PARSE LIST FILE
;
	CALLG	LST_ARGLIST,-		;RECALL CLI TO PARSE LISTING FILE
			@MAC$GL_CLIADDR
;
; PARSE INPUT FILES
;
10$:	CLRL	L^MAC$GL_DIRFLG		;CLEAR LIBRARY FLAG
	CLRL	L^UPDATE_LIST		;Clear update list address
	BICL2	#<MAC_M_LIBRARY!MAC_M_UPDATE>, - ;Clear qualifer true bits
		MAC$GL_CTLMSK		; /LIB and /UPD only mutually exclusive
					; on a sinlge file-spec
	CALLG	INP_ARGLIST,-		;RECALL CLI TO PARSE AN INPUT FILE
			@MAC$GL_CLIADDR
	BICB2	#CLI$M_PARMREQ,-	;AFTER FIRST INPUT FILE
			L^INP_DESC+CLI$B_RQFLGS ; ALL INPUTS ARE OPTIONAL
	BBS	#CLI$V_CONCATINP,-	;IF THERE ARE MORE INPUTS
		L^INP_DESC+CLI$B_RQSTAT,10$ ; THEN GO GET THEM
;
; TERMINATE PARSE
;
	PUSHAB	L^CLIWORK		;PUSH CLI WORK ADDRESS
	PUSHAB	L^PRSDON		;AND DESCRIPTOR ADDRESS
	CALLS	#2,@MAC$GL_CLIADDR	;...
	BBC	#CLI$V_MOREINP,-	;BRANCH IF NO MORE INPUT FILES
		L^PRSDON+CLI$B_RQSTAT,20$ ; TO PROCESS
	BBSS	#FLG$V_MOREINP,(R11),.+1 ;THERE ARE--FLAG MAIN PROGRAM
20$:	MOVAB	L^MAC$GL_INPQUE,R0	;POINT TO THE INPUT QUEUE
	CMPL	4(R0),R0		;WERE THERE ANY INPUT FILES?
	BNEQ	OPEN_OUTPUTS		;IF NEQ YES--GO AHEAD
	MOVAB	W^MAC$MSG_NO_FILE,R0	;NO--GET MESSAGE ADDRESS
	CALLS	#0,W^MAC$ERR_TEXT	;REPORT THE ERROR
	BRW	MAC$LAST_CHANCE		;AND GO DIE
;
; OPEN OBJECT AND LISTING FILES IF REQUESTED
;
OPEN_OUTPUTS:
	MOVAB	L^MAC$GL_CTLMSK,R10	;POINT TO CONTROL MASK
	BBC	#MAC_V_OBJECT,(R10),20$	;BRANCH IF NO OBJECT FILE
	$CREATE	FAB=L^MAC$OBJECT_FAB,-	;CREATE THE OBJECT FILE
		ERR=L^MAC$ERR_OPN_OUT
	BLBC	R0,40$			;BRANCH IF OPEN ERROR
	$CONNECT RAB=L^MAC$OBJECT_RAB,-	;CONNECT THE RECORD STREAM
		ERR=L^MAC$ERR_OPN_OUT
	BLBC	R0,40$			;BRANCH IF CONNECT ERROR
	BBCS	#FLG$V_OBJXST,L^MAC$GL_FLAGS,- ;FLAG OBJECT FILE OPEN
			20$
20$:	BBC	#MAC_V_LIST,(R10),30$	;BRANCH IF NO LISTING FILE
	$CREATE	FAB=L^MAC$LIST_FAB,-	;CREATE THE LISTING FILE
		ERR=L^MAC$ERR_OPN_OUT
	BLBC	R0,40$			;BRANCH IF OPEN ERROR
	$CONNECT RAB=L^MAC$LIST_RAB,-	;CONNECT THE RECORD STREAM
		ERR=L^MAC$ERR_OPN_OUT
	BLBC	R0,40$			;BRANCH IF CONNECT ERROR
	BBCS	#FLG$V_LSTXST,L^MAC$GL_FLAGS,- ;FLAG THERE IS A LISTING FILE
			30$
30$:	BBC	#MAC_V_CROSSREF,(R10),35$ ;BRANCH IF NOT CROSS-REFERENCE
	BBSS	#FLG$V_CRF,(R11),35$	;YES--SET IN FLAGS WORD
35$:	PUSHAB	L^MAC$GQ_RNT_CMD	;STACK TIMING BLOCK ADDRESS
	CALLS	#1,W^MAC$TIMER_OFF	;STOP TIMING COMMAND PROCESSING
	POPR	#^M<R7,R8,R9,R10,R11>	;RESTORE REGISTERS
	RSB
;
; COULD NOT OPEN A FILE
;
40$:	BRW	MAC$LAST_CHANCE		;LAST CHANCE HANDLER

	.SBTTL	ACTION ROUTINE FOR INPUT FILE SPECIFICATION

;++
; FUNCTIONAL DESCRIPTION
;
;	THIS ROUTINE CREATES A FAB AND LINKS IT INTO THE LIST OF
;	INPUT FABS.  IT THEN OPENS THE FILE TO MAKE SURE IT EXISTS
;	BEFORE EXITING.
;
;--

INP_FILE:
	.WORD	^M<R2,R3,R4,R5,R6>	;REGISTER SAVE MASK
	BLBC	L^MAC$GL_DIRFLG,10$	;BRANCH IF NOT LIBRARY FILE
	BRW	INP_LIBR_FILE		;ELSE GO HANDLE LIBRARY SPECIALLY
10$:	CALLG	L^MAC$G_1_PAGE,G^LIB$GET_VM ;ALLOCATE AN FDB
	BLBS	R0,20$			;BR IF SUCCESS
	BRW	100$			;NO--GO REPORT ERROR
20$:	MOVL	W^MAC$GL_BASEADDR,R6	;GET BLOCK ADDRESS
	MOVC5	#0,(SP),#0,#512,(R6)	;CLEAR THE BLOCK
	ADDL2	#8,R6			;POINT TO FDB (SKIP THE LINKS)
	MOVW	#<<FAB$C_BLN>@8+FAB$C_BID>,- ;IDENTIFY AS A FAB WITH
			FAB$B_BID(R6)	; IDENT AND LENGTH
	BISB2	#FAB$M_GET,FAB$B_FAC(R6) ;SET FOR GETS
	MOVB	L^INP_DEFEXT,FAB$B_DNS(R6) ;SET LENGTH OF DEFAULT NAME STRING
	MOVAB	L^INP_DEFEXT+1,FAB$L_DNA(R6) ;AND ITS ADDRESS
	MOVAB	L^MAC$INPUT_XAB,-	;STORE ADDRESS OF XAB FOR DATE
			FAB$L_XAB(R6)
	MOVAB	FAB$C_BLN(R6),R1	;POINT TO NAM BLOCK
	MOVL	R1,FAB$L_NAM(R6)	;STORE NAM ADDRESS IN FAB
	SUBL3	#NAM$C_BLN+FAB$C_BLN+12,#512,R2 ;FIGURE LENGTH LEFT FOR
					; RESULTANT FILENAME STRING
	MOVB	R2,NAM$B_RSS(R1)	;STORE IN NAM BLOCK
	MOVAB	NAM$C_BLN+4(R1),NAM$L_RSA(R1) ;AND ITS ADDRESS
	MOVW	#<<NAM$C_BLN>@8+NAM$C_BID>,- ;IDENTIFY NAM BLOCK
			FAB$C_BLN+NAM$B_BID(R6)	; AS A NAM BLOCK
	MOVAB	L^MAC$INPUT_RLFNM,NAM$L_RLF(R1) ;SET RELATED NAM BLOCK ADDRESS
	MOVAB	L^MAC$INP_NAM_BUF,NAM$L_ESA(R1) ;SET EXPANDED STRING BUFFER ADDRESS
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R1)	;AND ITS SIZE
	MOVL	4(AP),R1		;GET PARAMETER DESCRIPTOR ADDR
	MOVL	CLI$A_RQADDR(R1),-	;STORE ADDRESS OF FILENAME STRING
			FAB$L_FNA(R6)	; IN THE FAB
	MOVB	CLI$W_RQSIZE(R1),-	;STORE LENGTH OF FILENAME STRING
			FAB$B_FNS(R6)	; IN THE FAB
	$OPEN	FAB=(R6),-		;OPEN THE INPUT FILE TO ENSURE EXISTENCE
		ERR=W^MAC$ERR_OPN_INP
	BLBC	R0,120$			;BR IF THERE WAS AN ERROR
	MOVAB	FAB$C_BLN(R6),R1	;POINT TO NAM BLOCK
	MOVB	NAM$B_RSL(R1),FAB$B_FNS(R6) ;STORE LENGTH OF RESULTANT FILENAME
	MOVAB	NAM$C_BLN+4(R1),FAB$L_FNA(R6) ;AND ITS ADDRESS
	MOVB	NAM$B_ESL(R1),L^MAC$INPUT_RLFNM+NAM$B_RSL ;SETUP DUMMY
						;NAM BLOCK TO POINT TO
						;CURRENT EXPANDED FILE NAME
	MOVAB	NAM$C_BLN+4(R1),MAC$INPUT_RLFNM+NAM$L_RSA
	INSQUE	-8(R6),@L^MAC$GL_INPQUE+4	;AND INSERT FDB INTO THE INPUT QUEUE
	BLBS	W^MAC$GL_FINPTF,40$	;BRANCH IF NOT FIRST INPUT FILE
	INCL	W^MAC$GL_FINPTF		;FLAG FIRST INPUT FILE DONE
	MOVB	NAM$B_ESL(R1),L^MAC$FINPT_RLFNM+NAM$B_RSL ;SET LENGTH
	MOVC3	#NAM$C_MAXRSS,L^MAC$INP_NAM_BUF,- ;COPY EXPANDED NAME STRING
		L^MAC$FIN_NAM_BUF	;FOR OBJECT AND LISTING FILES
40$:	$CLOSE	FAB=(R6),-		;CLOSE FILE
		ERR=W^MAC$ERR_CLS_INP
	BLBC	R0,120$			;BRANCH IF CLOSE ERROR
	BBCS	#FAB$V_NAM,FAB$L_FOP(R6),.+1 ;SET OPEN BY NAM BLOCK
	MOVL	L^UPDATE_LIST, -	;Store update files list
		FAB$C_BLN+NAM$C_BLN(R6)
	BEQL	50$			;If EQL there is no list
	PUSHAL	FAB$C_BLN+NAM$C_BLN(R6)	;Update list
	PUSHAL	FAB$C_BLN(R6)		;NAM block address
	CALLS	#2,G^SUM$OPEN		;Open update files
	BLBC	R0,120$			;Error if LBC
50$:	RET
;
; COULD NOT ALLOCATE AN FDB
;
100$:	CALLS	#0,W^MAC$ERR_NOMEM_0	;REPORT ERROR
;
; COULD NOT OPEN INPUT FILE
;
120$:	BRW	MAC$LAST_CHANCE		;GO TO LAST CHANCE HANDLER

	.SBTTL	PROCESS LIBRARY FILE SPECIFIER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE /LIBRARY QUALIFIER IS SEEN
;	IN A FILE SPECIFICATION.  ALL THAT IS DONE IS TO SET THE
;	LOW BIT IN MAC$GL_DIRFLG.  THIS WILL CAUSE THE INP_FILE
;	ROUTINE TO TRANSFER CONTROL TO INP_LIBR_FILE WHEN IT IS
;	EVENTUALLY CALLED.
;
;--

LIBR_FILE:
	.WORD	0			;REGISTER SAVE MASK
	BISB	#1,L^MAC$GL_DIRFLG	;SET LIBRARY FILE FLAG FOR INP_FILE
	RET

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE INPUT SPECIFICATION IS COMPLETE
;	AND THE SPECIFICATION HAS /LIBRARY ON IT.  THE LIBRARY IS OPENED,
;	AND AN IN-CORE INDEX IS CREATED.
;
;--

INP_LIBR_FILE:
					;NO SAVE MASK SINCE WE BRW HERE
					;FROM INP_FILE
	BSBW	MAC$ALL_MLB_MLF		; Allocate and initialise MLF block
;
; Call librarian procedure to initialise library
;
	PUSHAB	MLF$X_NAMBLK(R6)	; Address of NAM block
	PUSHAB	L^MAC$GL_LIBTYPE	; Address of type = MLB
	PUSHAB	L^MAC$GL_LIBFUNC	; Address of function = READ
	PUSHAB	MLF$L_CTINDEX(R6)	; Address of control table index
	CALLS	#4,G^LBR$INI_CONTROL	; Initialise control block
	BLBC	R0,10$			; If LBC error
;
; Call librarian procedure to open library file
;
	MOVL	4(AP),R1		; Get CLI parameter block address
	PUSHAB	MLF$Q_FNAMDS(R6)	; Address of resultant length
	PUSHAB	MLF$Q_FNAMDS(R6)	; Address of resultant descriptor
	PUSHAB	L^MAC$INPUT_RLFNM	; Address of related file NAM block
	PUSHAB	L^MAC$MLB_DEFNAM	; Address of default file name descriptor
	PUSHL	#0			; Create options = 0
	PUSHAB	CLI$W_RQSIZE(R1)	; Address of file name descriptor
	PUSHAB	MLF$L_CTINDEX(R6)	; Address of control table index
	CALLS	#7,G^LBR$OPEN		; Open library file
	BLBC	R0,10$			; Error if LBC
	MOVAB	MLF$T_FNAM(R6),-	; Set up related name NAM block to
		MAC$INPUT_RLFNM+NAM$L_RSA ; point to current expanded file name
	MOVB	MLF$X_NAMBLK+NAM$B_ESL(R6),- ; Set up related file name block
		L^MAC$INPUT_RLFNM+NAM$B_RSL  ; to point to currect expanded name
	INSQUE	(R6),L^MAC$GL_MLB_QUE	;INSERT AT FRONT OF MLB QUEUE
	INCL	W^MAC$GL_MLB_CNT	; Increment macro library count
	RET				;RETURN TO CLI
;
; LIBRARY OPEN ERROR
;
10$:
	PUSHL	R6			; Address of MLF
	CALLS	#1,MAC$ERR_LBROPEN	; Report error
	BRW	MAC$LAST_CHANCE

	.SBTTL	ACTION ROUTINE FOR OBJECT AND LISTING FILES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES, LIST_FILE AND OBJ_FILE, ARE CALLED BY
;	CLI WHEN THE QUALFIERS ARE FOUND IN A COMMAND LINE.
;	THE INFORMATION IS FILLED IN THE PROPER FAB.
;
;--

LIST_FILE:
	.WORD	0			;REGISTER SAVE MASK
	MOVAB	L^MAC$LIST_FAB,R0	;GET THE FAB ADDRESS
	BRB	OPEN_FILE		;AND GO HANDLE THE REST

OBJ_FILE:
	.WORD	0			;REGISTER SAVE MASK
	MOVAB	L^MAC$OBJECT_FAB,R0	;GET THE FAB ADDRESS
OPEN_FILE:
	MOVL	4(AP),R1		;GET THE PARAMATER DESC. ADDRESS
	MOVL	CLI$A_RQADDR(R1),-	;STORE ADDRESS OF FILENAME STRING
			FAB$L_FNA(R0)	; IN THE FAB
	MOVB	CLI$W_RQSIZE(R1),-	;STORE LENGTH OF FILENAME STRING
			FAB$B_FNS(R0)	; IN THE FAB
	RET

	.SBTTL	PROCESS CROSS QUALIFIER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY CLI TO PROCESS THE /CROSS QUALIFIER.
;	THE KEYWORDS ARE SCANNED AND MAC$GL_CRF_FLG IS FILLED IN WITH
;	THE CORRESPONDING BITS.
;
;--

MACR_CROS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVAB	L^MAC$GL_FLAGS,R11	;POINT R11 TO FLAGS
	MOVL	4(AP),R7		;POINT TO PARAMETER DESCRIPTOR
	MOVAB	L^ASCII_VALUE,R6	;POINT TO ASCII REQUEST DESCRIPTOR
	TSTW	CLI$W_QDVALSIZ(R7)	;ARE THERE ANY VALUES?
	BNEQ	10$			;IF NEQ YES--GO GET THEM
	MOVZWL	#CRF$M_SYMBOLS!CRF$M_MACROS,- ;NO--SET THE DEFAULT
			L^MAC$GL_CRF_FLG      ;OF SYMBOLS AND MACROS
	RET				;AND LEAVE IT AT THAT
;
; LOOP, LOOKING UP KEYWORDS AND SETTING BITS IN MAC$GL_CRF_FLG
;
10$:	PUSHAB	(R7)			;STACK DESCRIPTOR ADDRESS
	PUSHAB	L^CLIWORK		;STACK WORKAREA ADDRESS
	PUSHL	R6			;STACK ASCII VALUE DESCRIPTOR
	CALLS	#3,@MAC$GL_CLIADDR	;REQUEST ASCII CONVERSION
	MOVZWL	CLI$W_RQSIZE(R6),R0	;GET LENGTH OF ASCII STRING
	BEQL	40$			;IF EQL THEN ALL DONE
	MOVAB	L^MAC$AB_TMPSYM,R1	;THERE IS A STRING--PT TO NAME BLK
	MOVB	R0,(R1)+		;STORE LENGTH OF STRING
	MOVC5	R0,@CLI$A_RQADDR(R6),-	;COPY NAME INTO TMPSYM
		#0,#SYM$K_MAXLEN,(R1)	;WITH ZERO FILL
	MOVAB	L^MAC$CRF_OPTIONS,R5	;POINT TO THE LIST OF OPTIONS
	BSBW	MAC$SRC_KEYS		;LOOK UP THE OPTION
	BLBS	R0,20$			;BRANCH IF FOUND
	CALLS	#0,W^MAC$ERR_KEY_WD	;ERROR--REPORT IT
	BRW	MAC$LAST_CHANCE		;AND EXIT
20$:	MOVL	SYM$L_VAL(R1),R0	;GET THE VALUE
	BGTR	30$			;IF GTR THEN OK
	MCOML	R0,R0			;ELSE THIS IS "NOXXXX"
	BICL2	R0,L^MAC$GL_CRF_FLG	;CLEAR THE CREF FLAG
	BRB	10$			;CONTINUE
30$:	BISL2	R0,L^MAC$GL_CRF_FLG	;SET IN CREF FLAGS
	BRB	10$			;GO GET NEXT OPTION
40$:	RET				;RETURN TO CLI

	.SBTTL	PROCESS SHOW/NOSHOW,ENABLE/DISABLE QUALIFIERS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS THE /SHOW QUALIFIER.
;	THE KEYWORDS ARE SCANNED AND THE APPROPRIATE BITS ARE
;	SET IN THE LIST/ENABLE FLAGS WORD, MAC$GL_ENLISF
;
;--

MACR_SHOW:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVL	#1,R10			;FLAG SETTING OPTIONS
	BRB	SHOW_NOSH		;

MACR_NOSH:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	CLRL	R10			;FLAG CLEARING OPTIONS
SHOW_NOSH:
	MOVAB	L^LST$G_DIRLIST,R9	;POINT TO SHORT NAME TABLE
	MOVAB	L^LST$G_LONGNAMES,R8	;AND LONG NAME TABLE
	BRB	SHOW_ENAB

MACR_ENAB:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVL	#1,R10			;FLAG SETTING OPTIONS
	BRB	ENAB_DSAB		;

MACR_DISA:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	CLRL	R10			;FLAG CLEARING OPTIONS
ENAB_DSAB:
	MOVAB	L^ENB$G_OPTIONS,R9	;POINT TO SHORT NAME TABLE
	MOVAB	L^ENB$G_LONGNAMES,R8	;AND LONG NAME TABLE
;
; COMMON CODE FOR ENABLE/DISABLE/SHOW/NOSHOW.  THE VALUES ARE SCANNED,
; BITS SET OR CLEARED IN SYMBOL BLOCK, AND BITS SET OR CLEARED IN
; MAC$GL_ENLISF (COMMAND ENABLE / LIST FLAGS) UNTIL NO MORE VALUES.
;
SHOW_ENAB:
	MOVAB	L^MAC$GL_FLAGS,R11	;R11 MUST POINT AT FLAGS
	MOVL	4(AP),R7		;POINT TO PARAM. DESCRIPTOR
	MOVAB	L^ASCII_VALUE,R6	;POINT TO ASCII REQUEST DESCRIPTOR
	TSTW	CLI$W_QDVALSIZ(R7)	;IS THERE A VALUE?
	BNEQ	10$			;IF NEQ YES
	RET				;***SHOULD DO DEFAULT THING!
10$:	PUSHAB	(R7)			;STACK DESCRIPTOR ADDRESS
	PUSHAB	L^CLIWORK		;STACK WORKAREA ADDRESS
	PUSHL	R6			;STACK ASCII VAL. DESCRIPTOR ADDRESS
	CALLS	#3,@MAC$GL_CLIADDR	;REQUEST ASCII CONVERSION
	MOVZWL	CLI$W_RQSIZE(R6),R0	;ANOTHER VALUE?
	BEQL	50$			;IF EQL NO--EXIT
	MOVAB	L^MAC$AB_TMPSYM,R1	;COPY TO TEMP BUFFER
	MOVB	R0,(R1)+		;COPY NAME LENGTH
	MOVC5	R0,@CLI$A_RQADDR(R6),-	;COPY NAME INTO TMPSYM
		#0,#SYM$K_MAXLEN,(R1)	;...
	MOVL	R9,R5			;LOOK UP NAME IN SHORT NAME TABLE
	BSBW	MAC$SRC_LIST		;IN THE SHORT NAMES
	BLBS	R0,30$			;BRANCH IF WE FOUND IT
	MOVL	R8,R5			;NO--TRY THE LONG NAMES
	BSBW	MAC$SRC_KEYS		;...
	BLBS	R0,20$			;BRANCH IF WE FOUND IT
	CALLS	#0,W^MAC$ERR_KEY_WD	;NO--ERROR--REPORT PROBLEM
	BRW	MAC$LAST_CHANCE		;AND EXIT
20$:	MOVL	SYM$L_VAL(R1),R1	;POINT TO THE REAL OPTION NAME BLOCK
	BEQL	10$			;BRANCH IF "NONE" (/SHOW W/NO VALUES)
30$:	BLBC	R10,40$			;BRANCH IF CLEARING OPTIONS
	BISW2	SYM$W_FLAG(R1),L^MAC$GL_ENLISF ;NO--SET IN COMMAND FLAGS
	CVTBL	#-1,SYM$L_VAL(R1)	;SET FLAG IN SYMBOL BLOCK
	BRB	10$			;PROCESS NEXT OPTION
40$:	BICW2	SYM$W_FLAG(R1),L^MAC$GL_ENLISF ;CLEAR IN COMMAND FLAGS
	CLRL	SYM$L_VAL(R1)		;AND IN SYMBOL BLOCK
	BRB	10$			;PROCESS NEXT OPTION
50$:	RET

	.SBTTL	PROCESS DEBUG/NODEBUG QUALIFIERS
;++
; FUNCTIONAL DESCRIPTION:
;
;	The /DEBUG qualifier (plus its associated parameters) issued with the
;	DCL MACRO command will behave in the same manner as issuing a com-
;	bination of the /ENABLE and /DISABLE qualifiers utilizing the DEBUG
;	and TRACEBACK parameters.
;
;	This routine searchs for a specific parameter for the /DEBUG command.
;	Upon recognition of a parameter, the associated action (setting and/or
;	clearing bits) is performed.  The list of parameters and thier
;	value/actions are enumerated below.
;--

MACR_NODE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVAB	DBG$G_LONGNAMES,R1	;DISABLE BOTH DEBUG AND TRACEBACK
	BRW	DEBU_NODE		;NO NEED TO DO ANY LOOK UPS, JUST DO IT

MACR_DEBU:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	CLRL	R10			;FLAG FOR SYMBOLS AND/OR TRACEBACK SEEN
	MOVAB	L^MAC$GL_FLAGS,R11	;R11 MUST POINT AT FLAGS
	MOVL	4(AP),R7		;POINT TO PARAM. DESCRIPTOR
	MOVAB	L^ASCII_VALUE,R6	;POINT TO ASCII REQUEST DESCRIPTOR
	TSTW	CLI$W_QDVALSIZ(R7)	;IS THERE A VALUE?
	BNEQ	DBG_NEXT_OPT		;IF NEQ YES
	RET				;***SHOULD DO DEFAULT THING!

DBG_NEXT_OPT:
	PUSHAB	(R7)			;STACK DESCRIPTOR ADDRESS
	PUSHAB	L^CLIWORK		;STACK WORKAREA ADDRESS
	PUSHL	R6			;STACK ASCII VAL. DESCRIPTOR ADDRESS
	CALLS	#3,@MAC$GL_CLIADDR	;REQUEST ASCII CONVERSION
	MOVZWL	CLI$W_RQSIZE(R6),R0	;ANOTHER VALUE?
	BNEQ	10$			;IF NEQ YES -- CONTINUE PROCESSING IT
	BRW	DBG_RETURN		;IF EQL NO -- EXIT
10$:	MOVAB	L^MAC$AB_TMPSYM,R1	;COPY TO TEMP BUFFER
	MOVB	R0,(R1)+		;COPY NAME LENGTH
	MOVC5	R0,@CLI$A_RQADDR(R6),-	;COPY NAME INTO TMPSYM
		#0,#SYM$K_MAXLEN,(R1)	;...
	MOVAB	G^DBG$G_LONGNAMES,R5	;LOOK UP THE OPTION IN THE LONG NAMES
	BSBW	MAC$SRC_KEYS		;...
	BLBS	R0,DEBU_NODE		;BRANCH IF WE FOUND IT
	CALLS	#0,W^MAC$ERR_KEY_WD	;NO--ERROR--REPORT PROBLEM
	BRW	MAC$LAST_CHANCE		;AND EXIT

;++
; COMMON CODE FOR DEBUG/NODEBUG.
; Bits are set/cleared in the symbol block and in MAC$GL_ENLISF
; (Command Enable/List Flags) until no more values are encountered.
;
; First execute some common code to set up addressing of the necessary 
; symbol blocks.
;--

DEBU_NODE:
	MOVAB	G^ENB$G_DEBUG,R2	;POINT TO DEBUG SYMBOL BLOCK ENTRY
	MOVAB	G^ENB$G_TRACEBACK,R3	;AND TO THE TRACEBACK ENTRY.

;++
; Begin looking for the specific qualifier parameters...
;
; The parameter code values are...
;
;     Value	Qualifier	Action
;	0	None		Disable both the DEBUG and TRACEBACK options
;	1	Symbols		Disable TRACEBACK and Enable DEBUG option
;	2	Traceback	Disable DEBUG and Enable TRACEBACK option
;	3	All (default)	Enable both the DEBUG and TRACEBACK options
;--

	MOVL	SYM$L_VAL(R1),R1	;CHECK WHICH OPTION WAS SELECTED
	BGTR	10$			;BRANCH IF PARAM IS NOT "NONE"
	BICW2	SYM$W_FLAG(R2),G^MAC$GL_ENLISF	;SINCE IT IS NONE, WE DISABLE
	CLRL	SYM$L_VAL(R2)		;BOTH THE DEBUG AND THE TRACE-
	BICW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF	;BACK QUALIFIER BITS IN THE
	CLRL	SYM$L_VAL(R3)		;GLOBAL AND LOCAL CONTROL BLOCKS.
	BRW	DBG_RETURN		;ALL DONE, CONTINUE OTHER PROCESSING.

10$:	CMPL	R1,#1			;CHECK FOR THE "SYMBOLS" QUAL
	BGTR	20$			;BRANCH IF NOT "SYMBOLS"
	BISW2	SYM$W_FLAG(R2),L^MAC$GL_ENLISF	;SET IN COMMAND FLAGS
	CVTBL	#-1,SYM$L_VAL(R2)	;SET FLAG IN SYMBOL BLOCK
	BLBS	R10,15$			;TRACEBACK or SYMBOLS PREVIOUSLY SET?
	BICW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF	;DISABLE TRACEBACK IN COMMAND
	CLRL	SYM$L_VAL(R3)		;FLAGS AND SYMBOL BLOCK
	MOVL	#1,R10			;SHOW THAT "SYMBOLS" HAS BEEN SEEN.
15$:	BRW	DBG_NEXT_OPT		;PROCESS NEXT OPTION

20$:	CMPL	R1,#2			;CHECK FOR THE "TRACEBACK" QUAL
	BGTR	30$			;BRANCH IF NOT "TRACEBACK"
	BISW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF	;SET IN COMMAND FLAGS
	CVTBL	#-1,SYM$L_VAL(R3)	;SET FLAG IN SYMBOL BLOCK
	BLBS	R10,25$			;SYMBOLS or TRACEBACK PREVIOUSLY SET?
	BICW2	SYM$W_FLAG(R2),L^MAC$GL_ENLISF	;DISABLE DEBUG IN COMMAND
	CLRL	SYM$L_VAL(R2)		;FLAGS AND SYMBOL BLOCK
	MOVL	#1,R10			;SHOW THAT "TRACEBACK" HAS BEEN SEEN.
25$:	BRW	DBG_NEXT_OPT		;PROCESS NEXT OPTION

;++
; IF you are here, we assume the ALL parameter was specified...
; In other words Both the DEBUG and TRACEBACK options are enabled.
;--

30$:	BISW2	SYM$W_FLAG(R2),G^MAC$GL_ENLISF
	CVTBL	#-1,SYM$L_VAL(R2)
	BISW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF
	CVTBL	#-1,SYM$L_VAL(R3)
	BRW	DBG_NEXT_OPT

;++
; That's all for now...continue with the other processing
;--

DBG_RETURN:	RET

	.SBTTL	PROCESS /UPDATE QUALIFIER

;++
; Functional description
;
;	This routine is called by CLI to process the /UPDATE qualifer.
;	The Source update merge procedure SUM$LIST is called to
;	process any values on the qualifier
;
; Inputs:
;
;	 4(AP)	= Address of parameter qualifier descriptor block
;	 8(AP)	= Address of utility service routine
;	12(AP)	= Contents of 1st longword of work area
;
; Outputs:
;
;	Update files list
;
;--

MACR_UPDA:
	.WORD	0			; Register save mask
	PUSHAL	UPDATE_LIST		; Address to put update files list
	PUSHAL	CLIWORK			; CLI work area address
	PUSHL	4(AP)			; Address of parameter qualifier block
	PUSHL	8(AP)			; Address of CLI utility service routine
	CALLS	#4,G^SUM$LIST_QUAL	; Process list
	RET				; RETURN TO CLI

	.SBTTL	ERROR HANDLING ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED ON A CLI ERROR.
;
; INPUTS:
;
;	4(AP)		ADDRESS OF REQUEST DESCRIPTOR WITH ERROR SEGMENT
;	8(AP)		ERROR CODE
;
; OUTPUTS:
;
;	ERROR IS PRINTED.
;
;
;--

	.PSECT	MAC$RO_CODE_P4,NOWRT,GBL,LONG

CLI_ERROR:
	.WORD	^M<R2,R3>		;REGISTER SAVE MASK
	MOVL	8(AP),R0		;GET THE ERROR CODE
	ADDL3	#CLI$W_RQSIZE+4,4(AP),R1 ;POINT A DESCRIPTOR FOR BAD SEGMENT
	CALLS	#0,CLI_ERROR_0		;CALL ROUTINE SO PUT_MSG WILL
					;RETURN TO US
	BRW	MAC$LAST_CHANCE		;ALL DONE NOW

CLI_ERROR_0:
	.WORD	0			;REGISTERS SAVED ABOVE
	PUSHL	(R1)			;PUSH ADDRESS OF START OF ERROR SEGMENT
	ADDL2	-(R1),(SP)		;FIND END OF ERROR SEGMENT
	ADDL3	L^GETCMD+CLI$W_RQSIZE,-	;FIND THE END OF
		L^GETCMD+CLI$W_RQSIZE+4,-(SP) ;THE ENTIRE COMMAND
	SUBL2	4(SP),(SP)		;NOW THE LENGTH OF THE COMMAND
	CMPL	(SP),#80		;IS THE LINE TOO LONG?
	BLEQU	10$			;IF LEQU NO
	MOVZBL	#80,(SP)		;YES--MAKE IT REASONABLE
10$:	PUSHAQ	(SP)			;STACK ADDRESS OF THAT DESCRIPTOR
	PUSHL	R1			;STACK ADDRESS OF ERROR SEGMENT
	PUSHL	#2			;NUMBER OF FAO ARGUMENTS
	PUSHL	#^X381B0		;***CLI$_BADTEXT
	CLRL	-(SP)			;ZERO FAO ARG COUNT
	PUSHL	R0			;PUSH ERROR CODE
	PUSHL	#6			;TOTAL # OF ERRORS IN BLOCK
	BRW	MAC$PUT_MSG		;OUTPUT THE MESSAGE AND RETURN TO CLI

	.END
