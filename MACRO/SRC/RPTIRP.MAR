	.TITLE	MAC$RPTIRP	REPEAT AND INDEFINITE REPEAT PROCESSORS
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 30-AUG-78
;
; MODIFIED BY:
;
;	V01.10	RN0023		R. Newland	 3-Nov-1979
;		New message codes to get error message from system
;		message file.
;
;	V01.08	RN0010		R. Newland	5-Sep-1979
;		Multipage MXB blocks
;
;	V01.09	RN0012		R. Newland	26-Sep-1979
;		Fix problem with angle bracket processing of .IRPC
;		string argument.  SPR 11-25871
;
;	V01.07	RN0005		R. Newland	13-Aug-1979
;		Variable symbol storage
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$MAC_CTLFLGDEF			;DEFINE CONTROL FLAGS
	$MAC_GENVALDEF			;DEFINE GENERAL VALUES
	$MAC_SYMBLKDEF			;DEFINE SYMBOL BLOCK OFFSETS
	$MAC_MNBDEF			;DEFINE MACRO NAME BLOCK
	$MAC_INPBLKDEF			;DEFINE INPUT BLOCK
	$MAC_INTCODDEF			;DEFINE INT. BUFFER CODES
	$MACMSGDEF			; Define message codes


;
; The following assumtions are made about the format of MNB and INP blocks
;
;
	ASSUME	MNB$L_LINK	EQ	0
	ASSUME	MNB$B_NAME	EQ	MNB$L_LINK+4
	ASSUME	MNB$L_TXTP	EQ	MNB$B_NAME+1
	ASSUME	MNB$W_FLAG	EQ	MNB$L_TXTP+4
	ASSUME	MNB$L_PAGP	EQ	MNB$W_FLAG+2
	ASSUME	MNB$L_PAGC	EQ	MNB$L_PAGP+4
	ASSUME	MNB$L_CRSYMF	EQ	MNB$L_PAGC+4
	ASSUME	MNB$B_ARGCT	EQ	MNB$L_CRSYMF+4
	ASSUME	MNB$L_ARGP	EQ	MNB$B_ARGCT+1
;
;
	ASSUME	INP$L_LINK	EQ	0
	ASSUME	INP$L_NXTL	EQ	INP$L_LINK+4
	ASSUME	INP$L_GETL	EQ	INP$L_NXTL+4
	ASSUME	INP$L_IFLVL	EQ	INP$L_GETL+4
	ASSUME	INP$L_IFVAL	EQ	INP$L_IFLVL+4
	ASSUME	INP$L_RPTCNT	EQ	INP$L_IFVAL+4
	ASSUME	INP$L_PAGP	EQ	INP$L_RPTCNT+4
	ASSUME	INP$B_ARGCT	EQ	INP$L_PAGP+4
	ASSUME	INP$L_ARGS	EQ	INP$B_ARGCT+1
;
;
;
	.PSECT	MAC$RW_DATA, NOEXE, LONG


BLOCK_SIZE:
	.BLKL	1			; Block size of MNB or MXB block

	.PSECT	MAC$RO_CODE_MAC,NOWRT,GBL,LONG

	.SBTTL	REPEAT DIRECTIVE PROCESSOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A .REPT DIRECTIVE IS SCANNED.
;	ALL THAT IS DONE IS TO CLEAR THE EVALUATE EXPRESSION FLAG
;	SO THAT NO CODE IS EMITTED TO PASS 2 TO EVALUATE EXPRESSIONS.
;
;--

REPTHD::				;REPT_HEAD = KREPT
	BBCC	#FLG$V_EVALEXPR,(R11),.+1 ;CLEAR EVALUATE EXPRESSION FLAG
	CLRL	W^MAC$GL_ABSFLAG	;LOOK FOR ABSOLUTE EXPRESSION
	RSB

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED AFTER THE REPEAT COUNT OF A .REPT
;	DIRECTIVE HAS BEEN EVALUATED.  THE REPEAT BODY IS LOADED
;	INTO MEMORY, AND AN INPUT BLOCK IS CREATED TO READ THE
;	REPEAT BODY.
;
;--

ERREPT::				;DIRECTIVE = REPT_HEAD ERR02
	$VPUSH	#0			;STACK A 0
	BSBB	REPT			;PROCESS THE REPEAT
	$VPOP	R0			;CLEAR THE STACK
	RSB

REPT::					;DIRECTIVE = REPT_HEAD EXPR
	BBCS	#FLG$V_EVALEXPR,(R11),.+1 ;RESET THE FLAG
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE A PAGE
	MOVL	R0,W^MAC$GL_BLKPTR	; Save address of block
	.IF GREATER <INP$K_BLKSIZ-MNB$K_BLKSIZ>
	ADDL3	#<INP$K_BLKSIZ-MNB$K_BLKSIZ>,R0,R6 ; Allow for greater size of INP
	.IFF
	MOVL	R0,R6			; Copy the address
	.ENDC
	MOVC5	#0,(SP),#0,#MNB$K_BLKSIZ,(R6) ; Zero the MACRO name block
	CLRL	-(SP)			;SET NO MACRO ARGUMENTS
	SUBL3	W^MAC$GL_BLKPTR,R3,R0	; Figure space used in block
	MOVL	R6,W^MAC$GL_MACPTR	; Save address for BDYSCN
	SUBL3	R0,#512,-(SP)		;FIGURE SPACE LEFT AND STACK
	PUSHL	R3			;STACK TEXT POINTER FOR CALLS
	BBCS	#FLG$V_RPTIRP,(R11),.+1 ;FLAG IN AN REPEAT/IRP
	MOVL	#CR,R10			;FORCE READING OF NEXT LINE
	BSBW	MAC$GETCHR		;READ THE FIRST CHAR OF BODY
	CALLS	#3,W^MAC$BODY_SCAN	;SCAN THE REPEAT TEXT BODY
	BBCC	#FLG$V_RPTIRP,(R11),.+1	;FLAG NOT IN REPEAT/IRP
;
; NOW WE WILL TURN THE MACRO NAME BLOCK AT THE BEGINNING OF THE
; BLOCK INTO AN INPUT BLOCK.
;
	MOVL	MNB$L_PAGP(R6),R0	;REMEMBER THE PAGE POINTER
	MOVL	W^MAC$GL_BLKPTR,R6	; Get address of block
	MOVL	W^MAC$GL_INPUTP,(R6)	;SET THE LINK
	MOVAL	(R6)+,W^MAC$GL_INPUTP	;AND MAKE THIS THE CURRENT INPUT BLOCK
	MOVL	W^MAC$GL_ARGPTR,R1	;GET POINTER TO WORD AFTER -1
	MOVAW	-(R1),(R6)+		;STORE POINTER TO END OF TEXT
					;SO THAT MAC$GET_RPT_LIN WILL
					;RESET
	MOVAB	W^MAC$GET_RPT_LIN,(R6)+	;SET ROUTINE TO GET NEXT LINE
	MOVAB	W^MAC$GL_IF_LEVEL,R1	;POINT TO IF LEVEL/VALUE
	MOVL	(R1),(R6)+		;SAVE OLD IF LEVEL
	CLRL	(R1)+			;SET NEW IF LEVEL
	MOVL	(R1),(R6)+		;SAVE OLD IF VALUE
	CLRL	(R1)			;SET NEW IF VALUE
	TSTL	W^MAC$GL_ABSFLAG	;DID WE GET AN ABSOLUTE EXPRESSION?
	BEQL	40$			;IF EQL YES
	MOVQ	R0,-(SP)		;SAVE R0/R1
	$MAC_ERR RPTCNTNABS		; No--get message code
	BSBW	MAC$ERRORPT		;REPORT ERROR TO PASS 2
	MOVQ	(SP)+,R0		;RESTORE R0/R1
	BRB	50$			;AND USE 0
40$:	MOVL	W^MAC$AL_VALSTACK[R7],R1;GET THE REPEAT COUNT
	BGEQ	100$			;IF GEQ OK
50$:	CLRL	R1			;ELSE REPEAT 0 TIMES
100$:	MOVL	R1,(R6)+		;SET THE REPEAT COUNT
	MOVL	R0,(R6)+		;SET THE PAGE POINTER
	CLRB	(R6)+			;NO ARGUMENTS
	CLRL	(R6)+			;CLEAR FIRST POINTER LONGWORD
	RSB				;RETURN TO READ IN REPEAT TEXT

	.SBTTL	INDEFINITE REPEAT DIRECTIVE PROCESSOR

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS UP INDEFINTE REPEAT LOOPS.  A MACRO NAME BLOCK
;	IS ALLOCATED AT THE BEGINNING OF A PAGE.  THE NAME IN THE MNB
;	WILL BE THE NAME OF THE FORMAL ARGUMENT FOR THE REPEAT.  THE
;	REAL ARGUMENTS ARE SCANNED AND INSERTED INTO A QUEUE.  THEN
;	THE REPEAT BODY IS READ INTO CORE.  AFTER THE TEXT IS SCANNED,
;	THE MACRO NAME BLOCK AT THE BEGINNING OF THE PAGE IS TRANSFORMED
;	INTO AN INPUT CONTEXT BLOCK. THE INPUT CONTEXT IS THEN SWITCHED
;	TO READ THE INDEFINTE REPEAT.
;
;--

	
IRPC::					;DIRECTIVE = KIRPC
	BBCS	#FLG$V_IRPC,(R11),IRP_0	;FLAG THIS IS IRPC AND GO
	BRB	IRP_0			;(IN CASE IT HAPPENED TO BE SET)

IRP::					;DIRECTIVE = KIRP
	BBCC	#FLG$V_IRPC,(R11),IRP_0	;FLAG THIS IS IRP (NOT IRPC)
IRP_0:	BLBS	W^LST$G_MACRODEF+SYM$L_VAL,10$ ; Branch if listing MACRO defs
	$INTOUT_LW INT$_SETLONG,<#0,#MAC$GL_LIST_IT> ;NO--SEND TO PASS 2
10$:	BSBW	MAC$SYMSCNUP		;SCAN FORMAL ARG NAME
	BLBS	R0,20$			;BRANCH IF WE FOUND ONE
	$MAC_ERR NOFORMLARG		; No--get message code
	BRW	MAC$ERRORLN		;ISSUE ERROR AND RETURN
20$:	PUSHR	#^M<R7,R8,R12>		;SAVE REGISTERS
	BSBW	MAC$ALL_1_PAGE		;ALLOCATE A PAGE
	MOVZWL	#512,W^BLOCK_SIZE	; Set size of current block
	MOVL	R0,R12			;REMEMBER START OF CURRENT PAGE
	MOVL	R0,W^MAC$GL_BLKPTR	; Save block address
;
; NOW WE WILL SET UP AN MNB AT THE BEGINNING OF THE PAGE.  THE MACRO
; NAME WILL BE THE FORMAL ARGUMENT NAME.
;
	MOVAB	W^MAC$AB_TMPSYM,R1	;POINT TO FORMAL ARG NAME
	MOVZBL	(R1),R2			; Get length of name
	INCL	R2			; and include count byte
	ADDL3	R2,#MNB$K_BLKSIZ,R3	; Get total bytes required for MNB
	SUBL3	R3,#INP$K_IRPSIZ,R3	; Is this less than size of INP block?
	BEQL	25$			; No if EQL
	ADDL2	R3,R0			; Add size difference to MNB address
25$:
	MOVB	R2,-(SP)
	MOVC3	R2,(R1),(R0)		; Copy formal arg name into MNB
	MOVL	R3,R8			; Save pointer
	MOVL	R8,W^MAC$GL_MACPTR
	CLRL	(R3)+			; Clear link word
	MOVB	(SP)+,(R3)+		; Store offset to name
	MOVW	#1,(R3)+		;STORE ARG # (OVER FIRST WORD OF
					; THE TEXT POINTER)
	CLRQ	(R3)+			; Clear second word of text pointer,
					; the flags word and page pointer
	CLRQ	(R3)+			; Clear PAGC and CRFSYM
	MOVB	#1,(R3)+		;ARG COUNT
	MOVL	R8,(R3)+		;STORE POINTER TO ARGUMENT
	MOVL	R3,W^MAC$GL_ARGPTR	;SAVE POINTER TO REAL ARG QUEUE
	MOVAL	(R3),(R3)		;INIT THE REAL ARG QUEUE
	MOVAL	(R3)+,(R3)+		;...
					;(NOTE: IF THIS IS IRPC THESE WORDS
					; WILL GET CHANGED LATER.)
	MOVL	R3,R7			;SET POINTER INTO R7 FOR LATER
	BSBW	MAC$SKIPSP		;SKIP SPACES
	CMPB	R10,#^A/,/		;STOP ON A COMMA?
	BNEQ	30$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
	BSBW	MAC$SKIPSP		;AND SKIP SPACES
30$:	BBCC	#FLG$V_ENDMCH,(R11),40$	;FLAG NO LEFT ANGLE BRACKET SEEN
40$:	BBS	#FLG$V_IRPC,(R11),50$	; If .IRPC let ARGSCN look after
					; angle bracket processing
	CMPB	R10,#^A/</		; Left angle bracket?
	BNEQ	50$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--SKIP IT
	BBCS	#FLG$V_ENDMCH,(R11),50$	;FLAG WE SAW IT
50$:	CMPB	R10,#CR			;ARE WE AT EOL?
	BNEQ	SCAN_REAL_ARGS		; If NEQ no--there are real arguments
	BRW	NULL_REAL_ARGS		; No actual arguments

	.ENABL	LSB

;
; NOW SCAN THE REAL ARGUMENTS, AND STORE THEM IN VIRTUAL MEMORY.
; THEY WILL BE LINKED TOGETER IN A QUEUE.  THE QUEUE HEADER IS
; LOCATED AT THE BEGINNING OF THE PAGE + MNB$K_BLKSIZ.  FOLLOWING
; THE QUEUE HEADER IS A LONGWORD POINTER TO THE INDEFINTE REPEAT
; TEXT.  THIS WILL BE FILLED IN LATER.
;
SCAN_REAL_ARGS:
	BBCS	#FLG$V_RPTIRP,(R11),.+1	;FLAG IN A REPEAT/IRP
	CMPB	R10,#^A/>/		;RIGHT ANGLE BRACKET?
	BNEQ	20$			;IF NEQ NO
	BSBW	MAC$GETCHR		;YES--GET NEXT CHARACTER
	BSBW	MAC$SKIPSP		;THEN SKIP SPACES
	CMPB	R10,#CR			;STOP ON END OF LINE?
	BEQL	90$			;IF EQL YES--GO SCAN BODY
10$:	$MAC_ERR DIRSYNX		; No--get message code
	BSBW	MAC$ERRORLN		;ISSUE MESSAGE TO PASS 2
20$:	BSBW	MAC$MAC_ARG_SCN		;SCAN THE REAL ARG
	MOVL	R0,R6			;REMEMBER THE LENGTH OF THE ARG
	BNEQ	40$			;IF NEQ OK
	CMPB	R10,#CR			;NULL ARG--DID WE STOP ON EOL?
	BNEQ	40$			;IF NEQ NO--OK
	BBS	#FLG$V_IRPC,(R11),90$	; Branch if .IRPC
	BBC	#FLG$V_ENDMCH,(R11),INGEST_BODY	;YES--BRANCH IF NO STARTING "<"
	$MAC_ERR DIRSYNX		; Missing right angle bracket
	BSBW	MAC$ERRORLN		;ISSUE MESSAGE TO PASS 2
	BRB	INGEST_BODY		;FINISH UP
40$:	SUBL3	R12,R7,R0		;FIGURE SPACE USED ON PAGE
	SUBL3	R0,W^BLOCK_SIZE,R0	; Figure space left on block
	SUBL2	R6,R0			;SEE IF ENOUGH ROOM FOR ARGUMENT
	SUBL2	#10,R0			; AND ARG LINK (2 LW) AND BYTE COUNT
	BGTR	50$			;BRANCH IF THERE IS ROOM
	ADDL3	#<MXB$K_BLKSIZ+10>,R6,R1 ; Compute total size of block required
	BSBW	MAC$ALL_BLOCK		; and allocate block of memory
	ASHL	#9,R1,W^BLOCK_SIZE	; Set size of new block in bytes
	MOVL	R0,R12			;SAVE PTR TO CURRENT PAGE
	ASSUME	MXB$L_LINK  EQ 0
	ASSUME	MXB$L_PAGES EQ MXB$L_LINK+4
	MOVL	MNB$L_PAGP(R8),(R0)+	;LINK INTO PAGE LIST
	MOVL	R1,(R0)+		; Store block size in block
	MOVL	R12,MNB$L_PAGP(R8)	;...
	MOVL	R0,R7			;UPDATE POINTER TO FREE SPOT
50$:	MOVL	W^MAC$GL_ARGPTR,R0	;POINT TO THE ARGUMENT QUEUE HEAD
	BBS	#FLG$V_IRPC,(R11),100$	;BRANCH IF THIS IS IRPC
	INSQUE	(R7),@4(R0)		;INSERT NEW ARG AT END QUEUE
	ADDL2	#8,R7			;SKIP THE ARG QUEUE LINK WORDS
	MOVW	R6,(R7)+		;STORE LENGTH OF ARGUMENT
	MOVC3	R6,W^MAC$AB_TMPBUF,(R7)	;COPY ARG INTO PAGE
	MOVL	R3,R7			;UPDATE PAGE POINTER
	BRW	SCAN_REAL_ARGS
;
; THE REAL ARGUMENTS WERE NULL
;
NULL_REAL_ARGS:
90$:	BBC	#FLG$V_IRPC,(R11),INGEST_BODY ;BRANCH IF IRP (NOT IRPC)
	MOVL	W^MAC$GL_ARGPTR,R0	;IRPC--PICK UP QUEUE HEAD
	CLRL	R6			;CLEAR LENGTH OF STRING TO COPY
;
; THIS IS AN IRPC.  SET UP THE "ARGUMENT" FOR MAC$GET_IRC_LIN.
; THEN COPY THE ARGUMENT STRING AND MARK THE END WITH A 0 BYTE.
;
100$:	MOVW	#1,(R0)+		;SET THE LENGTH OF THE ARGUMENT
	CLRB	(R0)+			;CLEAR THE BYTE. (GET_IRC WILL
					;FILL IT IN).
	MOVAL	4(R0),(R0)+		;SET UP THE POINTER INTO THE
					;STRING TO IRPC OVER
	MOVC3	R6,W^MAC$AB_TMPBUF,(R0)	;COPY THE IRPC STRING OUT
	CLRB	(R3)+			;MARK THE END WITH A ZERO BYTE
	MOVL	R3,R7			;UPDATE PAGE POINTER
	.DSABL	LSB
;
; HERE WHEN ALL ARGUMENTS HAVE BEEN SCANNED. NOW SCAN THE INDEFINTE
; REPEAT BODY AND STORE IT IN VIRTUAL MEMORY ALSO.
;

INGEST_BODY:
	PUSHL	R8			;POINT TO THE ONE ARGUMENT
	SUBL3	R12,R7,R0		;FIGURE SPACE USED
	SUBL3	R0,W^BLOCK_SIZE,-(SP)	; Figure space left
	CMPL	(SP),#6			;IS THERE ENOUGH ROOM?
	BGTR	10$			;IF GTR YES
	BSBW	MAC$ALL_1_PAGE		;NO--ALLOCATE A PAGE
	MOVL	R0,R12			;SAVE POINTER TO CURRENT PAGE
	MOVL	MNB$L_PAGP(R8),(R0)+	;LINK INTO PAGE LIST
	MOVL	#1,(R0)+		; Store block size in block
	MOVL	R12,MNB$L_PAGP(R8)	;...
	MOVL	R0,R7			;UPDATE POINTER TO FREE SPOT
	MOVZWL	#<512-MXB$K_BLKSIZ>,(SP) ; Correct count on stack
10$:	PUSHL	R7			;STACK POINTER FOR TEXT
	MOVZBL	#CR,R10			;FORCE READING OF NEW LINE
	BSBW	MAC$GETCHR		;READ FIRST CHARACTER OF THE BODY
	CALLS	#3,W^MAC$BODY_SCAN	;SCAN THE REPEAT BODY
	BBCC	#FLG$V_RPTIRP,(R11),.+1	;FLAG NOT IN REPEAT/IRP
;
; NOW TURN THE MNB INTO AN INPUT CONTEXT BLOCK AND SWITCH TO THE
; NEW CONTEXT BLOCK.
;
	MOVL	MNB$L_PAGP(R8),R0	;GET THE PAGE POINTER
	MOVL	W^MAC$GL_BLKPTR,R8	; Get address for INP block
	MOVL	W^MAC$GL_INPUTP,(R8)	;SET LINK INTO INPUT CONTEXT BLOCK
	MOVL	W^MAC$GL_MACPTR,R6	; Get address of MNB
	MOVAL	(R8)+,W^MAC$GL_INPUTP	;SET AS NEW INPUT CONTEXT BLOCK
	MOVL	W^MAC$GL_ARGPTR,R1	;GET POINTER TO WORD AFTER -1
	MOVAW	-(R1),(R8)+		;STORE PTR TO END OF TEXT SO
					;THAT MAC$GET_IRP_LIN WILL GET
					;FIRST REAL ARGUMENT
	BBC	#FLG$V_IRPC,(R11),20$	;BRANCH IF THIS WAS IRP
	MOVAB	W^MAC$GET_IRC_LIN,(R8)+	;NO--IRPC--SET INPUT LINE ROUTINE
	BRB	30$			;CONTINUE
20$:	MOVAB	W^MAC$GET_IRP_LIN,(R8)+	;ADDRESS OF ROUTINE TO GET NEXT LINE
30$:	MOVAB	W^MAC$GL_IF_LEVEL,R1	;POINT TO IF LEVEL/VALUE
	MOVL	(R1),(R8)+		;SAVE OLD IF LEVEL
	CLRL	(R1)+			;SET NEW IF LEVEL
	MOVL	(R1),(R8)+		;SAVE OLD IF VALUE
	CLRL	(R1)			;CLEAR NEW IF VALUE
	MOVL	R7,(R8)+		;STORE START OF TEXT POINTER
	MOVL	R0,(R8)+		;STORE THE PAGE POINTER
	MOVB	#1,(R8)+		;ONE ARGUMENT
	BBCC	#FLG$V_IRPC,(R11),40$	;BRANCH IF NOT IRPC (AND CLEAR FLAG)
	MOVAL	MNB$K_BLKSIZ(R6),(R8)+	;IRPC--POINT TO OUR "ARGUMENT"
	BRB	50$			;CONTINUE
40$:	CLRL	(R8)+			;CLEAR ARG POINTER--INPUT ROUTINE
					;WILL SET IT LATER
50$:
IRP_EXIT:
	POPR	#^M<R7,R8,R12>		;RESTORE REGISTERS
	RSB				;RETURN TO READ FROM IRP TEXT

	.END
