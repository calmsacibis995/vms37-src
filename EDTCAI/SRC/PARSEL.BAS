1	sub parsel(passed_source$)
2     !****************************************************************************&
      !*									  *&
      !*  COPYRIGHT (c) 1978, 1980, 1982 BY					  *&
      !*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		  *&
      !*  ALL RIGHTS RESERVED.							  *&
      !* 									  *&
      !*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *&
      !*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *&
      !*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *&
      !*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *&
      !*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *&
      !*  TRANSFERRED.								  *&
      !* 									  *&
      !*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *&
      !*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *&
      !*  CORPORATION.								  *&
      !* 									  *&
      !*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *&
      !*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		  *&
      !* 									  *&
      !*									  *&
      !****************************************************************************&
      !****************************************************************************
50    !	&
      !	****	Version 2.0		2-JUN-81 &
      !
100   !	&
      !	****	Program Description &
      !
300   !	&
      !	****	Files &
      !
400   !	&
      !	****	Variable Directory &
      !
800   !	&
      !	****	Dimension the arrays &
      !	&
      !	&
    \	common (parsl)	buf_number%, &
			buffer_ptr(4%,2%), &
			range_list(1%,15%), &
			command%, &
			line_11, &
			line_12, &
			line_21, &
			line_22, &
			option_n%, &
			option_m%, &
			error_code%, &
			file$(12%,2%)=80%, &
			command$, &
			buffer_1$, &
			buffer_2$, &
			line_11$, &
			line_12$, &
			line_21$, &
			line_22$, &
			sub_string_1$, &
			sub_string_2$, &
			file_name$, &
			option$, &
			error_text$=80%, &
			command_list$(20%)=11% &
      !
900   !	&
      !	****	Begin Functions &
      !
905	def fn_skip_abbr%(f_temp%,f_temp$) &
      !	&
      !	This function will check the current location in the source line for &
      !	a legitimate abbreviation of the passed word, and skip all characters &
      !	which are legal abbreviations. &
      !	&
      !	The passed values are	F_TEMP% - location in SOURCE_LINE$ to begin &
      !					  checking for the abbreviation &
      !				F_TEMP$ - complete word to be checked against &
      !	&
      !	The return value is either the location in SOURCE_LINE$ for the first &
      !	character which did not match, and was a legal delimiter, or 0% if the &
      !	word was not bounded by a legal delimiter. &
      !	&
    \	f_temp$=edit$(f_temp$,8%+128%) &
    \	f_temp1$=seg$(source_line$,f_temp%-1%,f_temp%-1%) &
    \	goto 908 if f_temp1$>="A" and f_temp1$<="Z" &
      !	&
    \	f_temp1%=pos(f_temp$,"*",1%)-1% &
    \	goto 908 if f_temp1%<1% &
    \	goto 908 if seg$(source_line$,f_temp%,f_temp%+f_temp1%-1%)<>left$(f_temp$,f_temp1%) &
    \	f_temp%=f_temp%+f_temp1% &
    \	f_temp1%=f_temp1%+2%
906	goto 907 if seg$(f_temp$,f_temp1%,f_temp1%)<>seg$(source_line$,f_temp%,f_temp%) &
    \	f_temp%=f_temp%+1% &
    \	f_temp1%=f_temp1%+1% &
    \	goto 906 if f_temp%<=len(source_line$) and f_temp1%<=len(f_temp$)
907   !	&
      !	At this point, either a character did not match, or it ran off the end &
      !	of the SOURCE_LINE$, which amounts to the same thing.  Now check to &
      !	see if the next character is alphabetic.  If so, then this word is not &
      !	bounded by a legal delimiter, and so must be rejected. &
      !	&
    \	f_temp1$=seg$(source_line$,f_temp%,f_temp%) &
    \	goto 908 if f_temp1$>="A" and f_temp1$<="Z" &
    \	fn_skip_abbr%=f_temp% &
    \	fnexit
908   !	&
      !	Here an error has occurred, so set the flag accordingly. &
      !	&
    \	fn_skip_abbr%=0% &
    \	fnend
910	def fn_non_blank% &
      !	&
      !	This function will return the location of the next non blank character &
      !	past the CUR_CHAR% location in SOURCE_LINE$. &
      !
911	goto 912 if seg$(source_line$,cur_char%,cur_char%)<>" " &
    \	cur_char%=cur_char%+1% &
    \	goto 911 if cur_char%<=len(source_line$)
912	fn_non_blank%=cur_char% &
    \	fnend
915	def fn_value(f_temp$) &
      !	&
      !	This function will return the numeric value of the argument.  It takes &
      !	care of those obnoxious errors generated by the VAL function. &
      !	&
    \	on error goto 916 &
    \	f_temp$="999" if f_temp$="[EOB]" &
    \	f_temp=val(f_temp$) &
    \	goto 917
916	f_temp=0 &
    \	resume 917
917	fn_value=f_temp &
    \	fnend
920	def fn_which_line(f_temp%) &
      !	&
      !	This function will return the line number of FILE$(F_TEMP%,BUFFER_NUMBER%). &
      !	&
    \	f_temp1%=pos(file$(f_temp%,buffer_number%)," ",1%) &
    \	f_temp$=left$(file$(f_temp%,buffer_number%),f_temp1%-1%) &
    \	fn_which_line=fn_value(f_temp$) &
    \	fnend
925	def fn_find_text%(f_temp$) &
      !	&
      !	This function will return the line address of the text F_TEMP$ in the &
      !	array FILE$.  There are two possibilities, based on the value of the &
      !	variable DIRECTION%, as follows: &
      !	&
      !	DIRECTION% = -1%  search from the previous line of the buffer to the &
      !			  beginning of the buffer. &
      !		     +1%  search from the current line of the buffer to the &
      !			  end of the buffer. &
      !	&
    \	goto 926 if direction%<0% &
      !	&
      !	Here search forward to the end of the buffer &
      !	&
    \	for f_temp%=buffer_ptr(current_line_address%,buffer_number%) to &
		    buffer_ptr(ending_line_address%,buffer_number%) &
    \		f_temp1%=pos(file$(f_temp%,buffer_number%)," ",1%) &
    \		f_temp1%=1% if f_temp1%<1% &
    \		goto 927 if pos(edit$(file$(f_temp%,buffer_number%),32%),f_temp$,f_temp1%)>0% &
    \	next f_temp% &
    \	f_temp%=0% &
    \	goto 927
926   !	&
      !	Here search backward to the beginning of the buffer &
      !	&
    \	for f_temp%=buffer_ptr(current_line_address%,buffer_number%)-1% to 1% step -1% &
    \		f_temp1%=pos(file$(f_temp%,buffer_number%)," ",1%) &
    \		f_temp1%=1% if f_temp1%<1% &
    \		goto 927 if pos(edit$(file$(f_temp%,buffer_number%),32%),f_temp$,f_temp1%)>0% &
    \	next f_temp% &
    \	f_temp%=0% &
    \	goto 927
927	fn_find_text%=f_temp% &
    \	fnend
930	def fn_find_line_number%(f_temp$) &
      !	&
      !	This function will return the address of the line number F_TEMP$. &
      !	&
    \	f_temp0=fn_value(f_temp$) &
    \	for f_temp%=1% to buffer_ptr(ending_line_address%,buffer_number%) &
    \		f_temp1=fn_value(left$(file$(f_temp%,buffer_number%),pos(file$(f_temp%,buffer_number%)," ",1%))) &
    \		f_temp2=fn_value(left$(file$(f_temp%+1%,buffer_number%),pos(file$(f_temp%+1%,buffer_number%)," ",1%))) &
    \		if f_temp0<=f_temp1 then &
			fn_find_line_number%=f_temp% &
    \			fnexit &
			else &
			if f_temp0>f_temp1 and f_temp0<f_temp2 then &
				fn_find_line_number%=f_temp%+1% &
    \				fnexit
931	next f_temp% &
    \	fn_find_line_number%=0% &
    \	fnend &

1000  !	&
      !	****	Begin Main Routine &
      !	&
    \	on error goto 19000 &
    \	source_line$=edit$(passed_source$,1%+4%+8%+16%+32%+128%) &
      !	&
      !	Set some constants &
      !	&
    \	true%=0% &
    \	false%=1% &
      !	&
    \	beginning_line_number%=0% &
    \	current_line_number%=1% &
    \	ending_line_number%=2% &
    \	current_line_address%=3% &
    \	ending_line_address%=4% &
      !	&
    \	gosub 10300				! initialize the commands &
      !	&
      !	Initialize the returned (common) variables &
      !	&
    \	range_list(i%,j%)=0% for j%=0% to 15% for i%=0% to 1% &
    \	command%=0% &
    \	line_11=0% &
    \	line_12=0% &
    \	line_21=0% &
    \	line_22=0% &
    \	option_n%=0% &
    \	option_m%=0% &
    \	error_code%=0% &
    \	command$="" &
    \	buffer_1$="" &
    \	buffer_2$="" &
    \	buffer_number%=buf_number% &
    \	line_11$="" &
    \	line_12$="" &
    \	line_21$="" &
    \	line_22$="" &
    \	sub_string_1$="" &
    \	sub_string_2$="" &
    \	file_name$="" &
    \	option$="" &
    \	error_text$=""
1100  !	&
      !	If the first character of the line is not alphabetic, then this is a &
      !	TYPE command.  Supply the TYPE keyword. &
      !	&
    \	temp$=left$(source_line$,1%) &
    \	source_line$="TYPE "+source_line$ if temp$<"A" or temp$>"Z" &
      !	&
      !	Pre-edit the source line to change the keywords to their actual value at &
      !	this point, (such as changing "THRU" to ":").  This makes the later job &
      !	of parsing much easier. &
      !	&
    \	cur_char%=1%
1110	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 1115 if temp$=" "			! skip blanks &
    \	temp%=pos("%BE.LOTFRWA",temp$,1%)	! find a keyletter &
    \	if temp%>0% then &
		on temp% goto 1120,1130,1140,1150,1160,1170,1180,1190,1200,1210,1220
1112	if temp$='"' or temp$="'" then		! don't translate stuff in quotes &
		temp%=pos(source_line$,temp$,cur_char%+1%) &
    \		temp%=len(source_line$)+1% if temp%<1% &
    \		cur_char%=temp%
1115	cur_char%=cur_char%+1% &
    \	if cur_char%<=len(source_line$) then 1110 &
					else 1300
1120  !	&
      !	Eliminate the % symbol &
      !	&
    \	source_line$=left$(source_line$,cur_char%-1%)+right$(source_line$,cur_char%+1%) &
    \	goto 1110
1130  !	&
      !	Convert either the BEGIN, BEFORE, or BUFFER keywords &
      !	&
    \	temp$=seg$(source_line$,cur_char%,cur_char%+2%) &
    \	goto 1131 if temp$="BEG" &
    \	goto 1134 if temp$="BEF" &
    \	goto 1137 if temp$="BUF" &
    \	goto 1115
1131	temp%=fn_skip_abbr%(cur_char%,"BEG*IN") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(beginning_line_number%,buffer_number%))+ &
		right$(source_line$,temp%) &
    \	goto 1115
1134	temp%=fn_skip_abbr%(cur_char%,"BEF*ORE") &
    \	goto 1115 if temp%<1% &
    \	temp1%=buffer_ptr(current_line_address%,buffer_number%)-1% &
    \	temp1%=1% if temp1%<1% &
    \	temp$=left$(file$(temp1%,buffer_number%),pos(file$(temp1%,buffer_number%)," ",1%)-1%) &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(beginning_line_number%,buffer_number%))+":"+temp$+ &
		right$(source_line$,temp%) &
    \	goto 1115
1137	temp%=fn_skip_abbr%(cur_char%,"BUF*FER") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		"="+ &
		edit$(right$(source_line$,temp%),8%) &
    \	goto 1115
1140  !	&
      !	Convert the keyword END &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"E*ND") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(ending_line_number%,buffer_number%))+ &
		right$(source_line$,temp%) &
    \	goto 1115
1150  !	&
      !	Convert . to the current line number &
      !	&
    \	temp$=seg$(source_line$,cur_char%-1%,cur_char%-1%) &
    \	goto 1115 if temp$<>" " and temp$<>":" &
    \	temp$=seg$(source_line$,cur_char%+1%,cur_char%+1%) &
    \	goto 1115 if temp$<>" " and temp$<>"+" and temp$<>"-" and temp$<>"#" &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(current_line_number%,buffer_number%))+ &
		right$(source_line$,cur_char%+1%) &
    \	goto 1115
1160  !	&
      !	Convert the keyword LAST &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"L*AST") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(current_line_number%,buffer_number%))+ &
		right$(source_line$,temp%) &
    \	goto 1115
1170  !	&
      !	Get rid of the keyword ORIGINAL &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"O*RIGINAL") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		right$(source_line$,temp%) &
    \	goto 1110
1180  !	&
      !	Convert the keyword THRU to : &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"THRU*") &
    \	goto 1115 if temp%<1% &
    \	source_line$=edit$(left$(source_line$,cur_char%-1%),128%)+ &
		":"+ &
		edit$(right$(source_line$,temp%),8%) &
    \	goto 1115
1190  !	&
      !	Convert the keyword FOR to # &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"FOR*") &
    \	goto 1115 if temp%<1% &
    \	source_line$=edit$(left$(source_line$,cur_char%-1%),128%)+ &
		"#"+ &
		edit$(right$(source_line$,temp%),8%) &
    \	goto 1115
1200  !	&
      !	Convert the keyword REST &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"REST*") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(current_line_number%,buffer_number%))+ &
		":"+ &
		num1$(buffer_ptr(ending_line_number%,buffer_number%))+ &
		right$(source_line$,temp%) &
    \	goto 1115
1210  !	&
      !	Convert the keyword WHOLE &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"W*HOLE") &
    \	goto 1115 if temp%<1% &
    \	source_line$=left$(source_line$,cur_char%-1%)+ &
		num1$(buffer_ptr(beginning_line_number%,buffer_number%))+ &
		":"+ &
		num1$(buffer_ptr(ending_line_number%,buffer_number%))+ &
		right$(source_line$,temp%) &
    \	goto 1115
1220  !	&
      !	Convert the keyword AND to , &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"AND*") &
    \	goto 1115 if temp%<1% &
    \	source_line$=edit$(left$(source_line$,cur_char%-1%),128%)+ &
		","+ &
		edit$(right$(source_line$,temp%),8%) &
    \	goto 1115
1300  !	&
      !	Finished with the modification of keywords &
      !	&
    \	source_line$=edit$(source_line$,8%+16%+128%)	! get rid of any spaces &
						! that may have cropped up &
      !	&
      !	****	Now find which command it is &
      !	&
    \	for i%=1% to 20% &
    \		cur_char%=pos(command_list$(i%),"*",1%)-1% &
    \		goto 1310 if left$(source_line$,cur_char%)=left$(command_list$(i%),cur_char%) &
    \	next i% &
      !	&
      !	Complain about an unknown command. &
      !	&
    \	temp%=pos(source_line$," ",1%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	error_text$="The command '"+left$(source_line$,temp%-1%)+"' is not an EDT command." &
    \	error_code%=1% &
    \	goto 9500
1310	command%=i% &
    \	command$=left$(command_list$(command%),cur_char%)+right$(command_list$(command%),cur_char%+2%) &
    \	cur_char%=fn_skip_abbr%(1%,command_list$(command%)) &
						! go to the end of the command &
    \	if cur_char%<1% then			! oops, not a good command &
		error_text$="The command must be the first word on the line, followed by a space." &
    \		error_code%=1% &
    \		goto 9500
2000  !	&
      !	****	Now go to the particular section to parse each type of command &
      !	&
    \	cur_char%=fn_non_blank%			! find the next nonblank character &
      !	&
    \	on command% goto 2100,2200,2300,2400,2500,2600,2700,2800,2900,3000, &
			 3100,3200,3300,3400,3500,3600,3700,3800,3900,4000
2100  !	&
      !	****	Change [range] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		for i%=1% to buffer_ptr(ending_line_address%,buffer_number%) &
    \			range_list(range_ptr%,i%)=i% &
    \			range_list(range_ptr%,0%)=range_list(range_ptr%,0%)+1% &
    \		next i% &
    \		line_11=1% &
    \		line_12=buffer_ptr(ending_line_address%,buffer_number%) &
    \		goto 9000
2200  !	&
      !	****	COpy [range] TO [range] [/Query] [/Duplicate:n] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 2210 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_11=range_list(range_ptr%,1%) &
    \		line_12=range_list(range_ptr%,1%)
2210	cur_char%=fn_non_blank% &
    \	goto 9000 if cur_char%>len(source_line$) &
    \	if seg$(source_line$,cur_char%,cur_char%+1%)<>"TO" then &
		error_text$="The COPY command must have two ranges separated by the keyword TO." &
    \		error_code%=1% &
    \		goto 9500
2220  !	&
      !	Now to parse the second range &
      !	&
    \	cur_char%=cur_char%+2% &
    \	range_ptr%=1% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)=0% then &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_21=range_list(range_ptr%,1%) &
    \		line_22=range_list(range_ptr%,1%) &
    \		goto 2230 &
		else &
		if range_list(range_ptr%,0%)=1% then &
			line_21=first_line% &
    \			line_21$=first_line$ &
    \			line_22=second_line% &
    \			line_22$=second_line$ &
    \			buffer_2$=buffer_name$ &
    \			goto 2230 &
			else &
			error_text$="The second range of a COPY command must be a single line." &
    \			error_code%=1% &
    \			goto 9500
2230	cur_char%=fn_non_blank% &
    \	temp%=fn_skip_abbr%(cur_char%,"/Q*UERY") &
    \	goto 2240 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/QUERY" &
    \	goto 9000
2240	gosub 10200 &
    \	if error_code%<>0% then 9500 &
			   else 9000
2300  !	&
      !	****	DEFine Macro macro-name &
      !	&
    \	cur_char%=fn_non_blank% &
    \	temp%=fn_skip_abbr%(cur_char%,"M*ACRO") &
    \	if temp%<1% then &
		error_text$="The DEFINE command must be followed by the keyword MACRO." &
    \		error_code%=1% &
    \		goto 9500
2310	cur_char%=temp% &
    \	cur_char%=fn_non_blank% &
    \	temp%=pos(source_line$," ",cur_char%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	file_name$=seg$(source_line$,cur_char%,temp%-1%) &
    \	cur_char%=temp% &
    \	cur_char%=fn_non_blank% &
    \	if file_name$<>"" then &
		goto 9000 &
		else &
		error_text$="The DEFINE MACRO command must be followed by a macro name." &
    \		error_code%=1% &
    \		goto 9500
2400  !	&
      !	****	Delete [range] [/Query] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 2410 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_11=range_list(range_ptr%,1%) &
    \		line_12=range_list(range_ptr%,1%)
2410	cur_char%=fn_non_blank% &
    \	temp%=fn_skip_abbr%(cur_char%,"/Q*UERY") &
    \	goto 9000 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/QUERY" &
    \	goto 9000
2500  !	&
      !	****	EXit [file name] [/SEQuence:n:m] [/SAve] &
      !	&
    \	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 2510 if (temp$>="A" and temp$<="Z") &
		  or (temp$>="0" and temp$<="9") &
    \	goto 2520 if temp$="/" &
    \	goto 9000
2510  !	&
      !	Pick up the file name &
      !	&
    \	temp%=pos(source_line$," ",cur_char%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	temp1%=pos(source_line$,"/",cur_char%) &
    \	temp1%=len(source_line$)+1% if temp1%<1% &
    \	temp%=temp1% if temp%>temp1% &
    \	file_name$=seg$(source_line$,cur_char%,temp%-1%) &
    \	cur_char%=temp% &
    \	cur_char%=fn_non_blank%
2520	temp%=fn_skip_abbr%(cur_char%,"/SA*VE") &
    \	goto 2530 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/SAVE" &
    \	goto 9000
2530	gosub 10200 &
    \	if error_code%<>0% then 9500 &
			   else 9000
2600  !	&
      !	****	Find range &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		error_text$="The FIND command requires a range." &
    \		error_code%=1% &
    \		goto 9500
2700  !	&
      !	****	Help [topic] [topic] &
      !	&
    \	cur_char%=len(source_line$)+1% &
    \	goto 9000
2800  !	&
      !	****	INClude file name [range] &
      !	&
    \	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 2810 if (temp$>="A" and temp$<="Z") &
		  or (temp$>="0" and temp$<="9") &
    \	error_text$="The INCLUDE command requires a file name." &
    \	error_code%=1% &
    \	goto 9500
2810  !	&
      !	Pick up the file name &
      !	&
    \	temp%=pos(source_line$," ",cur_char%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	temp1%=pos(source_line$,"/",cur_char%) &
    \	temp1%=len(source_line$)+1% if temp1%<1% &
    \	temp%=temp1% if temp%>temp1% &
    \	file_name$=seg$(source_line$,cur_char%,temp%-1%) &
    \	cur_char%=temp% &
    \	cur_char%=fn_non_blank% &
      !	&
      !	Now pick up the possible range &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_11=range_list(range_ptr%,1%) &
    \		line_12=range_list(range_ptr%,1%) &
    \		goto 9000
2900  !	&
      !	****	Insert [range] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_11=range_list(range_ptr%,1%) &
    \		line_12=range_list(range_ptr%,1%) &
    \		goto 9000
3000  !	&
      !	****	Move [range] TO [range] [/Query] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 3010 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_21=range_list(range_ptr%,1%) &
    \		line_22=range_list(range_ptr%,1%)
3010	cur_char%=fn_non_blank% &
    \	goto 9000 if cur_char%>len(source_line$) &
    \	if seg$(source_line$,cur_char%,cur_char%+1%)<>"TO" then &
		error_text$="The MOVE command must have two ranges separated by the keyword TO." &
    \		error_code%=1% &
    \		goto 9500
3020  !	&
      !	Now to parse the second range &
      !	&
    \	cur_char%=cur_char%+2% &
    \	range_ptr%=1% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_21=first_line% &
    \		line_21$=first_line$ &
    \		line_22=second_line% &
    \		line_22$=second_line$ &
    \		buffer_2$=buffer_name$ &
    \		goto 3030 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_21=range_list(range_ptr%,1%) &
    \		line_22=range_list(range_ptr%,1%)
3030	cur_char%=fn_non_blank% &
    \	temp%=fn_skip_abbr%(cur_char%,"/Q*UERY") &
    \	goto 9000 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/QUERY" &
    \	goto 9000
3100  !	&
      !	****	[Substitute] Next [/string/string[/]] &
      !	&
    \	goto 3800
3200  !	&
      !	****	Print file name [range] &
      !	&
    \	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 3210 if (temp$>="A" and temp$<="Z") &
		  or (temp$>="0" and temp$<="9") &
    \	error_text$="The PRINT command requires a file name." &
    \	error_code%=1% &
    \	goto 9500
3210  !	&
      !	Pick up the file name &
      !	&
    \	temp%=pos(source_line$," ",cur_char%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	temp1%=pos(source_line$,"/",cur_char%) &
    \	temp1%=len(source_line$)+1% if temp1%<1% &
    \	temp%=temp1% if temp%>temp1% &
    \	file_name$=seg$(source_line$,cur_char%,temp%-1%) &
    \	cur_char%=temp% &
    \	cur_char%=fn_non_blank% &
      !	&
      !	Now pick up the possible range &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		for i%=1% to buffer_ptr(ending_line_address%,buffer_number%) &
    \			range_list(range_ptr%,i%)=i% &
    \			range_list(range_ptr%,0%)=range_list(range_ptr%,0%)+1% &
    \		next i% &
    \		line_11=1% &
    \		line_12=buffer_ptr(ending_line_address%,buffer_number%) &
    \		goto 9000
3300  !	&
      !	****	QUIT [/SAve] &
      !	&
    \	cur_char%=fn_non_blank% &
    \	temp%=fn_skip_abbr%(cur_char%,"/SA*VE") &
    \	goto 9000 if temp%<1% &
    \	option$="/SAVE" &
    \	cur_char%=temp% &
    \	goto 9000
3400  !	&
      !	****	Replace [range] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_11=range_list(range_ptr%,1%) &
    \		line_12=range_list(range_ptr%,1%) &
    \		goto 9000
3500  !	&
      !	****	RESequence [range] [/SEQuence:n:m] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 3510 &
		else &
		for i%=1% to buffer_ptr(ending_line_address%,buffer_number%) &
    \			range_list(range_ptr%,i%)=i% &
    \			range_list(range_ptr%,0%)=range_list(range_ptr%,0%)+1% &
    \		next i% &
    \		line_11=1% &
    \		line_12=buffer_ptr(ending_line_address%,buffer_number%) &
    \		goto 3510
3510	cur_char%=fn_non_blank% &
    \	gosub 10200 &
    \	if error_code%<>0% then 9500 &
			   else 9000
3600  !	&
      !	****	SEt [parameter] &
      !	&
    \	cur_char%=len(source_line$)+1% &
    \	goto 9000
3700  !	&
      !	****	SHow [parameter] &
      !	&
    \	cur_char%=len(source_line$)+1% &
    \	goto 9000
3800  !	&
      !	****	Substitute/string/string[/range] [/Brief:n] [/Query] [/NOType] &
      !	&
    \	cur_char%=fn_non_blank% &
    \	delimiter$=seg$(source_line$,cur_char%,cur_char%) &
    \	if (delimiter$>="A" and delimiter$<="Z") &
	or (delimiter$>="0" and delimiter$<="9") then &
		error_text$="The SUBSTITUTE command cannot take letters or digits as delimiters." &
    \		error_code%=1% &
    \		goto 9500
3810	temp%=pos(source_line$,delimiter$,cur_char%+1%) &
    \	if temp%<1% then &
		error_text$="The SUBSTITUTE command requires at least two delimiters." &
    \		error_code%=1% &
    \		goto 9500
3820	sub_string_1$="/"+seg$(source_line$,cur_char%+1%,temp%-1%)+"/" &
    \	cur_char%=temp% &
    \	temp%=pos(source_line$,delimiter$,cur_char%+1%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	sub_string_2$="/"+seg$(source_line$,cur_char%+1%,temp%-1%)+"/" &
    \	cur_char%=temp%+1% &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 3830 &
		else &
		for i%=buffer_ptr%(current_line_address%,buffer_number%) to &
		       buffer_ptr(ending_line_address%,buffer_number%) &
    \			range_list(range_ptr%,i%)=i% &
    \			range_list(range_ptr%,0%)=range_list(range_ptr%,0%)+1% &
    \		next i% &
    \		line_11=buffer_ptr(current_line_address%,buffer_number%) &
    \		line_12=buffer_ptr(ending_line_address%,buffer_number%) &
    \		goto 3830
3830	temp%=fn_skip_abbr%(cur_char%,"/NOT*YPE") &
    \	goto 3840 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/NOTYPE" &
    \	goto 9000
3840	temp%=fn_skip_abbr%(cur_char%,"/Q*UERY") &
    \	goto 3850 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/QUERY" &
    \	goto 9000
3850	temp%=fn_skip_abbr%(cur_char%,"/B*RIEF") &
    \	goto 9000 if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/BRIEF" &
    \	gosub 10250 &
    \	goto 9000
3900  !	&
      !	****	[Type] [range] &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 9000 &
		else &
		range_list(range_ptr%,0%)=1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(current_line_address%,buffer_number%)+1% &
    \		range_list(range_ptr%,1%)=buffer_ptr(ending_line_address%,buffer_number%) &
			if range_list(range_ptr%,1%)>buffer_ptr(ending_line_address%,buffer_number%) &
    \		line_11=range_list(range_ptr%,1%) &
    \		line_12=range_list(range_ptr%,1%) &
    \		goto 9000
4000  !	&
      !	****	Write file name [range] [/SEQuence:n:m] &
      !	&
    \	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 4010 if (temp$>="A" and temp$<="Z") &
		  or (temp$>="0" and temp$<="9") &
    \	error_text$="The WRITE command requires a file name." &
    \	error_code%=1% &
    \	goto 9500
4010  !	&
      !	Pick up the file name &
      !	&
    \	temp%=pos(source_line$," ",cur_char%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	temp1%=pos(source_line$,"/",cur_char%) &
    \	temp1%=len(source_line$)+1% if temp1%<1% &
    \	temp%=temp1% if temp%>temp1% &
    \	file_name$=seg$(source_line$,cur_char%,temp%-1%) &
    \	cur_char%=temp% &
    \	cur_char%=fn_non_blank% &
      !	&
      !	Now pick up the possible range &
      !	&
    \	range_ptr%=0% &
    \	gosub 10000 &
    \	goto 9500 if error_code%<>0% &
    \	if range_list(range_ptr%,0%)>0% then &
		line_11=first_line% &
    \		line_11$=first_line$ &
    \		line_12=second_line% &
    \		line_12$=second_line$ &
    \		buffer_1$=buffer_name$ &
    \		goto 4020 &
		else &
		for i%=1% to buffer_ptr(ending_line_address%,buffer_number%) &
    \			range_list(range_ptr%,i%)=i% &
    \			range_list(range_ptr%,0%)=range_list(range_ptr%,0%)+1% &
    \		next i% &
    \		line_11=1% &
    \		line_12=buffer_ptr(ending_line_address%,buffer_number%) &
    \		goto 4020
4020	gosub 10200 &
    \	if error_code%<>0% then 9500 &
			   else 9000
9000  !	&
      !	****	Clean up after successful parsing of the command line &
      !	&
    \	cur_char%=fn_non_blank% &
    \	if cur_char%<=len(source_line$) then &
		error_code%=1% &
    \		temp$=seg$(source_line$,cur_char%,cur_char%) &
    \		error_text$="The phrase '"+right$(source_line$,cur_char%)+"' has no meaning at that point." &
    \		error_text$="Please use only one command per line in this course." if temp$=";" &
    \		goto 9500 if temp$<>"/" &
    \		error_text$="The option '"+right$(source_line$,cur_char%)+"' cannot be used with "+command$ &
    \		error_text$="Please use only one option at a time in this course." if option$<>"" &
    \		goto 9500
9010  !	&
      !	Here the entire range has been parsed so that there are lists of array &
      !	addresses in the array RANGE_LIST.  Now translate these addresses &
      !	into real line numbers. &
      !	&
    \	line_11=fn_which_line(line_11) &
    \	line_12=fn_which_line(line_12) &
    \	line_21=fn_which_line(line_21) &
    \	line_22=fn_which_line(line_22) &
      !	&
    \	for range_ptr%=0% to 1% &
    \		for i%=1% to range_list(range_ptr%,0%) &
    \			range_list(range_ptr%,i%)=fn_which_line(range_list(range_ptr%,i%)) &
    \		next i% &
    \	next range_ptr% &
    \	subexit
9500  !	&
      !	****	Clean up after unsuccessful parsing of the command line &
      !	&
    \	subexit &

10000 !	&
      !	****	Parse a range specification &
      !	&
    \	error_text$="" &
    \	error_code%=0% &
    \	direction%=+1% &
    \	range_cnt%=0% &
    \	buffer_name$="" &
      !	&
    \	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%)
10010	goto 10020 if cur_char$<>"=" &
      !	&
      !	Parse the buffer name &
      !	&
    \	cur_char%=cur_char%+1%			! skip past the = &
    \	cur_char%=fn_non_blank%			! find the buffer name &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	if cur_char$<"A" or cur_char$>"Z" then &
		error_text$="Buffer names must begin with a letter." &
    \		error_code%=1% &
    \		return
10013	temp%=pos(source_line$," ",cur_char%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	buffer_name$=seg$(source_line$,cur_char%,temp%-1%) &
						! extract the buffer name &
    \	for i%=0% to 2% &
    \		goto 10016 if buffer_name$=file$(0%,i%) &
    \	next i% &
    \	error_text$="In this course, please use only previously created buffer names." &
    \	error_code%=1% &
    \	return
10016	buffer_number%=i% &
    \	cur_char%=temp%+1% &
    \	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	if range_ptr%=0% then &
		range_list(range_ptr%,0%)=buffer_ptr(ending_line_address%,buffer_number%) &
    \		range_list(range_ptr%,i%)=i% for i%=1% to range_list(range_ptr%,0%) &
    \		first_line%=1% &
    \		second_line%=range_list(range_ptr%,0%)
10020 !	&
      !	Now that we have the buffer name, we can start parsing the line ranges &
      !	&
    \	gosub 10100				! get a single line number &
    \	return if error_code%<>0% &
    \	first_line%=line_number% &
    \	first_text$=line_text$ &
      !	&
      !	Now check the second half of the range &
      !
10030	goto 10040 if cur_char$<>":" &
    \	if range_cnt%>1% then &
		error_text$="The colon can only separate single line ranges." &
    \		error_code%=1% &
    \		return
10032	cur_char%=cur_char%+1% &
    \	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	gosub 10100				! get another range &
    \	return if error_code%<>0% &
    \	second_line%=line_number% &
    \	second_text$=line_text$ &
    \	if range_cnt%<>2% then &
		error_text$="The colon can only separate single line ranges." &
    \		error_code%=1% &
    \		return
10035	range_cnt%=range_cnt%-2% &
    \	if first_line%<=second_line% then &
		for i%=first_line% to second_line% &
    \			range_cnt%=range_cnt%+1% if range_cnt%<15% &
    \			range_list(range_ptr%,range_cnt%)=i% &
    \		next i% &
		else &
		for i%=first_line% to second_line% step -1% &
    \			range_cnt%=range_cnt%+1% if range_cnt%<15% &
    \			range_list(range_ptr%,range_cnt%)=i% &
    \		next i%
10037	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%)
10040	goto 10050 if cur_char$<>"," &
      !	&
      !	A comma separates individual line ranges.  Simply move the character &
      !	pointer past the comma, and go back for more. &
      !	&
    \	cur_char%=cur_char%+1% &
    \	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 10020
10050	temp%=fn_skip_abbr%(cur_char%,"A*LL") &
    \	goto 10060 if temp%<1%			! they didn't specify ALL &
    \	cur_char%=temp% &
    \	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	if cur_char$<>"'" and cur_char$<>'"' then &
		error_text$="Quoted strings must have balanced quotes." &
    \		error_code%=1% &
    \		return
10051 !	&
      !	Pick up the string &
      !	&
    \	temp%=pos(source_line$,cur_char$,cur_char%+1%)	! find its match &
    \	if temp%<1% then			! oops, no match &
		error_text$="Quoted strings must have balanced quotes." &
    \		error_code%=1% &
    \		return
10052	line_text$=seg$(source_line$,cur_char%+1%,temp%-1%) &
    \	cur_char%=temp%+1% &
    \	cur_char%=fn_non_blank% &
    \	if line_text$="" then &
		error_text$="The ALL option requires a quoted string." &
    \		error_code%=1% &
    \		return
10053	if no_line_specified%=true% then	! no lines specified, default &
						! to the whole buffer &
		range_cnt%=buffer_ptr(ending_line_address%,buffer_number%) &
    \		range_list(range_ptr%,i%)=i% for i%=1% to range_cnt% &
    \		first_line%=1% &
    \		second_line%=range_cnt%
10054 !	&
      !	Here search for the LINE_TEXT$ in the lines specified in RANGE_LIST. &
      !	&
      !	Now eliminate all those lines without the string in them &
      !	&
    \	for i%=1% to range_cnt% &
    \		temp$=edit$(file$(range_list(range_ptr%,i%),buffer_number%),32%) &
    \		range_list(range_ptr%,i%)=0% if pos(temp$,line_text$,pos(temp$," ",1%))<1% &
					     or temp$="[EOB]" &
    \	next i% &
      !	&
      !	Now that all of the specified lines without the LINE_TEXT$ in them are &
      !	set to 0%, eliminate all of the 0%. &
      !	&
    \	for i%=range_cnt% to 1% step -1% &
    \		if range_list(range_ptr%,i%)<1% then &
			for j%=i% to range_cnt% &
    \				range_list(range_ptr%,j%)=range_list(range_ptr%,j%+1%) &
    \			next j% &
    \			range_cnt%=range_cnt%-1% &
    \			range_cnt%=0% if range_cnt%<1%
10057	next i% &
    \	goto 10060 if range_cnt%<1% &
    \	first_line%=range_list(range_ptr%,1%) &
    \	second_line%=range_list(range_ptr%,range_cnt%)
10060	return if no_line_specified%=true% and buffer_name$<>"" and range_ptr%=0% &
    \	range_list(range_ptr%,0%)=range_cnt% &
    \	return
10100 !	&
      !	****	Subroutine to parse a single line range &
      !	&
      !	This routine will take a range specification in the form &
      !	&
      !		[-] ["string" / 'string'] [#[.#]] [{+ / - / #} n] &
      !	&
      !	and convert it to a pointer to the line specified in the file. &
      !	&
      !	The return values are: &
      !	&
      !		LINE_TEXT$    =	text ("string" or 'string') which points to &
      !				the line specified.  This is null if no string &
      !				was specified. &
      !		LINE_NUMBER%  =	the line number specified (by whatever method &
      !				the student chose). &
      !	&
    \	line_number%=buffer_ptr(current_line_address%,buffer_number%) &
    \	line_text$="" &
    \	no_line_specified%=true% &
    \	return if cur_char%>len(source_line$) &
    \	return if seg$(source_line$,cur_char%,cur_char%)="/" &
    \	return if seg$(source_line$,cur_char%,cur_char%+1%)="TO" &
      !	&
      !	First check if they want to search backwards &
      !	&
    \	if cur_char$="-" then &
		direction%=-1%			! set the search that way &
    \		no_line_specified%=false% &
    \		cur_char%=cur_char%+1% &
    \		cur_char%=fn_non_blank% &
    \		cur_char$=seg$(source_line$,cur_char%,cur_char%)
10110	goto 10120 if cur_char$<>"'" and cur_char$<>'"' &
      !	&
      !	Parse the string &
      !	&
    \	temp%=pos(source_line$,cur_char$,cur_char%+1%)	! find its match &
    \	if temp%<1% then			! oops, no match &
		error_text$="Quoted strings must have balanced quotes." &
    \		error_code%=1% &
    \		return
10115	line_text$=seg$(source_line$,cur_char%+1%,temp%-1%) &
						! extract the string &
    \	line_number%=fn_find_text%(line_text$) &
    \	if line_number%<1% then &
		temp$="below" &
    \		temp$="above" if direction%<1% &
    \		error_text$="The string '"+line_text$+"' was not found "+temp$+" the current line." &
    \		error_code%=1% &
    \		return
10116	no_line_specified%=false% &
    \	cur_char%=temp%+1% &
    \	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 10130
10120	goto 10130 if (cur_char$<"0" or cur_char$>"9") and cur_char$<>"." and cur_char%<=len(source_line$) &
      !	&
      !	Collect and translate the number &
      !	&
    \	temp$=cur_char$ &
    \	no_line_specified%=false%
10121	cur_char%=cur_char%+1% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 10122 if (cur_char$<"0" or cur_char$>"9") and cur_char$<>"." &
    \	temp$=temp$+cur_char$ &
    \	goto 10121
10122	if direction%<1% then &
		cur_char$="-" &
    \		delimiter$="-" &
    \		goto 10133 &
		else &
		line_number%=fn_find_line_number%(temp$) &
    \		if line_number%<1% then &
			error_text$="The line number '"+temp$+"' was not found in the file." &
    \			error_code%=-1%		! This is the only time in &
						! which the ERROR_CODE% < 0%. &
						! This way, a line number not &
						! found can be treated as a &
						! non-fatal error &
    \			return
10123	cur_char%=fn_non_blank% &
    \	cur_char$=seg$(source_line$,cur_char%,cur_char%)
10130 !	&
      !	At this point the line number specified (by either a string or an &
      !	actual line number) may be modified by a +, -, or # sign. &
      !	&
    \	delimiter$=cur_char$ &
    \	increment%=0% &
    \	goto 10135 if cur_char$<>"+" and cur_char$<>"-" and cur_char$<>"#" &
      !	&
      !	There is a number at this point &
      !	&
    \	cur_char%=cur_char%+1% &
    \	cur_char%=fn_non_blank% &
    \	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	temp$="1" if temp$="" &
    \	cur_char%=cur_char%+1% &
    \	if temp$<"0" or temp$>"9" then &
		error_text$="The "+delimiter$+" sign must be followed by an integer number." &
    \		error_code%=1% &
    \		return
10131	cur_char$=seg$(source_line$,cur_char%,cur_char%) &
    \	goto 10132 if cur_char$<"0" or cur_char$>"9" &
    \	temp$=temp$+cur_char$ &
    \	cur_char%=cur_char%+1% &
    \	goto 10131 if cur_char%<=len(source_line$)
10132	if cur_char$="." then &
		error_text$="The "+delimiter$+" sign must be followed by an integer number." &
    \		error_code%=1% &
    \		return
10133	increment%=fn_value(temp$) &
    \	if range_cnt%>=15% then &
		error_text$="Please do not specify more than 15 line numbers in this course." &
    \		error_code%=1% &
    \		return
10134	on pos("+-#",delimiter$,1%) goto 10135,10136,10137
10135 !	&
      !	Handle + &
      !	&
    \	range_cnt%=range_cnt%+1% &
    \	line_number%=line_number%+increment% &
    \	line_number%=buffer_ptr(ending_line_address%,buffer_number%) &
		if line_number%>buffer_ptr(ending_line_address%,buffer_number%) &
    \	range_list(range_ptr%,range_cnt%)=line_number% &
    \	goto 10140
10136 !	&
      !	Handle - &
      !	&
    \	range_cnt%=range_cnt%+1% &
    \	line_number%=line_number%-increment% &
    \	line_number%=1% if line_number%<1% &
    \	range_list(range_ptr%,range_cnt%)=line_number% &
    \	goto 10140
10137 !	&
      !	Handle # &
      !	&
    \	temp%=line_number%-1%
10138	temp%=temp%+1% &
    \	range_cnt%=range_cnt%+1% &
    \	range_list(range_ptr%,range_cnt%)=temp% &
    \	increment%=increment%-1% &
    \	goto 10138 if temp%<buffer_ptr(ending_line_address%,buffer_number%) &
		  and range_cnt%<15% &
		  and increment%>0%
10140	return
10200 !	&
      !	****	Subroutine to parse /SEQ*UENCE[:n[:m]] &
      !	&
    \	temp%=fn_skip_abbr%(cur_char%,"/SEQ*UENCE") &
    \	return if temp%<1% &
    \	cur_char%=temp% &
    \	option$="/SEQUENCE"
10250	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	return if temp$<>":" &
    \	temp%=pos(source_line$,":",cur_char%+1%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	option_n%=fn_value(seg$(source_line$,cur_char%+1%,temp%-1%)) &
    \	cur_char%=temp% &
    \	temp$=seg$(source_line$,cur_char%,cur_char%) &
    \	return if temp$<>":" &
    \	temp%=pos(source_line$,":",cur_char%+1%) &
    \	temp%=len(source_line$)+1% if temp%<1% &
    \	option_m%=fn_value(seg$(source_line$,cur_char%+1%,temp%-1%)) &
    \	cur_char%=temp% &
    \	return
10300 !	&
      !	****	Subroutine to set up the command list the first time &
      !	&
    \	return if command_list$(1%)="CH*ANGE" &
      !	&
    \	command_list$(1%)="CH*ANGE" &
    \	command_list$(2%)="CO*PY" &
    \	command_list$(3%)="DEF*INE" &
    \	command_list$(4%)="D*ELETE" &
    \	command_list$(5%)="EX*IT" &
    \	command_list$(6%)="F*IND" &
    \	command_list$(7%)="H*ELP" &
    \	command_list$(8%)="INC*LUDE" &
    \	command_list$(9%)="I*NSERT" &
    \	command_list$(10%)="M*OVE" &
    \	command_list$(11%)="N*EXT" &
    \	command_list$(12%)="P*RINT" &
    \	command_list$(13%)="QUIT*" &
    \	command_list$(14%)="REP*LACE" &
    \	command_list$(15%)="RES*EQUENCE" &
    \	command_list$(16%)="SE*T" &
    \	command_list$(17%)="SH*OW" &
    \	command_list$(18%)="S*UBSTITUTE" &
    \	command_list$(19%)="T*YPE" &
    \	command_list$(20%)="W*RITE" &
      !	&
    \	return
19000 !	&
      !	****	Error handler &
      !
19999 !	&
      !	No error handling has worked up to here, so die &
      !	&
    \	resume 32000
32000 !	&
      !	Exit &
      !
32767	subend
