	.TITLE	POOL	DISPLAY NON-PAGED POOL ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	DUMP NON-PAGED POOL ROUTINES
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V02-008	KTA0069		Kerbey T. Altmann	24-Jan-1982
;		Add SHOW POOL/SRP.
;
;	V02-007	KTA0062		Kerbey T. Altmann	04-Jan-1982
;		Modify a few global locations to access new pool
;		sizes and starting addresses.
;
;	V02-006	KTA0044		Kerbey T. Altmann	11-Nov-1981
;		Add SHOW POOL/LRP.
;
;	V03-005	KTA0029		Kerbey Altmann	01-Aug-1981
;		1. Add more entries to BLOCK_TABLE.
;		2. Add SHOW POOL range.
;		3. Add SHOW POOL/HEADER and /FREE
;
;	V03-004	KTA0027		Kerbey Altmann	28-Jul-1981
;		Modify to accept sub-typable blocks.
;
;	V003	MTR0001		Mike Rhodes	22-Jun-1981
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;		Change default addressing mode to longword.
;		Remove references to $SDAMSGDEF macro.
;
;	V002	TMH0002		Tim Halvorsen	07-Feb-1981
;		Convert word displacements to longword displacements
;		Fix end-of-pool edge condition when dumping a pool
;		which ends with a block in use.
;
;	V001	TMH0001		Tim Halvorsen	30-Sep-1980
;		Use $EQU rather than $EQULST to obtain block type
;		code strings because MDL no longer produces $EQULST.
;--

	.PAGE
	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	.nocross
	$OPTDEF			; OPTION DEFINITIONS
	$ACBDEF
	$ADPDEF			; DEFINE SYMBOLS FOR BLOCK TABLE
	$AQBDEF
	$BRDDEF
	$CDDBDEF
	$CDRPDEF
	$CEBDEF
	$CRBDEF
	$CXBDEF
	$DDBDEF
	$DPTDEF
	$FCBDEF
	$FKBDEF
	$GSDDEF
	$IDBDEF
	$IRPDEF
	$IRPEDEF
	$JIBDEF
	$KFHDEF
	$KFIDEF
	$LOGDEF
	$MTLDEF
	$MVLDEF
	$PBHDEF
	$PCBDEF
	$PDBDEF
	$PFLDEF
	$PQBDEF
	$PTRDEF
	$RBMDEF
	$RSBDEF
	$RVTDEF
	$RVXDEF
	$SHBDEF
	$TQEDEF
	$UCBDEF
	$VCADEF
	$VCBDEF
	$VECDEF
	$WCBDEF
	.cross

IRP_SIZE =	<IRP$C_LENGTH+^XF>&<^C<^XF>>

	.PAGE
	.SBTTL	STORAGE DEFINITIONS

;
;	STORAGE DEFINITIONS
;
	.default displacement,long

	.PSECT	SDADATA,NOEXE,WRT

;
; NOTE: Following two locations must be contiguous!!!
;
SPACE_USED:
	.BLKL	1			; TOTAL SPACE IN USE
TOTAL_SPACE:
	.BLKL	1			; TOTAL SPACE AVAILABLE
IRP_POOL_START:
	.BLKL	1			; START OF IRP POOL
IRP_BITMAP:
	.LONG	0			; ADDRESS OF IRP POOL BITMAP

;
;	DEFINE SELECTION CONDITIONS FOR VARIOUS BLOCK TYPES
;

	NONP =	1			; BIT FOR NON-PAGED POOL
	PAGD =	2			; BIT FOR PAGED POOL

	.MACRO	BLOCK	TYPE,MIN=0,MAX=<^X7FFF>,POOL=NONPAGED,GRAN=<^XF>
	.BYTE	DYN$C_'TYPE
	.WORD	MIN
	.WORD	<MAX+^XF>&^C<^XF>
	.IF	IDN,<POOL>,<NONPAGED>
	.BYTE	NONP
	.IFF
	.IF	IDN,<POOL>,<PAGED>
	.BYTE	PAGD
	.IFF
	.IF	IDN,<POOL>,<ANYPOOL>
	.BYTE	NONP!PAGD
	.IFF
	.ERROR	; ILLEGAL POOL SPECIFICATION
	.ENDC
	.ENDC
	.ENDC
	.BYTE	GRAN
	.ENDM

BLOCK_TABLE:
	BLOCK	ACB,ACB$L_KAST+4,IRP$C_LENGTH
BLK_TBL_SIZ=.-BLOCK_TABLE
	BLOCK	ADP,ADP$C_MBAADPLEN,1536
	BLOCK	AQB,AQB$C_LENGTH,AQB$C_LENGTH,GRAN=0
	BLOCK	BRDCST,BRD$C_LENGTH,GRAN=0
	BLOCK	CDRP,CDRP$C_LENGTH,CDRP$C_LENGTH+CDRP$C_BT_LEN+16
	BLOCK	CEB,IRP$C_LENGTH,IRP$C_LENGTH
	BLOCK	CRB,CRB$C_LENGTH,CRB$L_INTD2+VEC$C_LENGTH
	BLOCK	CXB,CXB$C_LENGTH
	BLOCK	DDB,DDB$C_LENGTH,DDB$C_LENGTH
	BLOCK	DPT,DPT$C_LENGTH,GRAN=0
	BLOCK	ERP,0,0				; NOT IN LOCAL MEMORY
	BLOCK	EXTGSD,GSD$C_LENGTH,GSD$C_LENGTH,PAGED,GRAN=0
	BLOCK	FCB,FCB$C_LENGTH,FCB$C_LENGTH+16
	BLOCK	FRK,FKB$C_LENGTH,FKB$C_LENGTH
	BLOCK	GSD,GSD$C_LENGTH,GSD$C_LENGTH,PAGED,GRAN=0
	BLOCK	IDB,IDB$C_LENGTH,IDB$C_LENGTH+8*4	; EXTRA 8 DUE TO ERROR IN INIT
	BLOCK	IRP,IRP$C_LENGTH,IRP$C_LENGTH
	BLOCK	IRPE,IRPE$C_LENGTH,IRP$C_LENGTH
	BLOCK	JIB,JIB$C_LENGTH,JIB$C_LENGTH
	BLOCK	KFH,KFH$C_LENGTH,2060,PAGED,GRAN=0	; 12 header + max 4 blocks header
	BLOCK	KFI,KFI$C_LENGTH,,PAGED
	BLOCK	LOG,LOG$C_LENGTH,LOG$C_LENGTH+LOG$C_NAMLENGTH,ANYPOOL
	BLOCK	MBX,0,0				; NOT IN LOCAL MEMORY
	BLOCK	MTL,MTL$C_LENGTH,MTL$C_LENGTH,PAGED
	BLOCK	MVL,MVL$C_FIXLEN
	BLOCK	PBH,PBH$C_LENGTH,PBH$C_LENGTH
	BLOCK	PCB,PCB$C_LENGTH,PCB$C_LENGTH,GRAN=0
	BLOCK	PDB,PDB$C_LENGTH,PDB$C_LENGTH
	BLOCK	PFL,PFL$C_LENGTH
	BLOCK	PIB,0,0				; NOT STANDARD BLOCK FORMAT
	BLOCK	PTR,PTR$L_PTR0,,ANYPOOL
	BLOCK	PQB,PQB$C_LENGTH,PQB$C_LENGTH
	BLOCK	RBM,RBM$C_LENGTH,GRAN=0
	BLOCK	RSB,RSB$C_LENGTH,RSB$C_LENGTH+RSB$K_MAXLEN+1
	BLOCK	RVT,RVT$C_LENGTH
	BLOCK	RVX,RVX$C_LENGTH,RVX$C_LENGTH
	BLOCK	SHB,SHB$C_LENGTH,SHB$C_LENGTH
	BLOCK	SHMCEB,0,0			; NEVER IN LOCAL MEMORY
	BLOCK	SHMGSD,0,0			; NEVER IN LOCAL MEMORY
	BLOCK	SHRBUFIO,0,0			; NEVER IN LOCAL MEMORY
	BLOCK	SLAVCEB,CEB$C_LENGTH+12,CEB$C_LENGTH+12
	BLOCK	TQE,TQE$C_LENGTH,TQE$C_LENGTH
	BLOCK	UCB,UCB$C_LENGTH,GRAN=0
	BLOCK	VCB,VCB$C_LENGTH,VCB$C_LENGTH,GRAN=0
	BLOCK	WCB,WCB$C_LENGTH
	.BYTE	0			; END OF TABLE


	.MACRO	$DEFINI	NAME,P1,P2
LAST_VALUE =	0
LAST_VALUE_MAIN = 0
SUBTF =		0
NSUBT =		0
LAST_SYM =	0
SYM =		0
	.PSECT	DYNMAP,LONG
DYN_MAP::
	.PSECT	DYNPTR,LONG
DYN_PTR::
	.PSECT	DYNTAB
DYN_TAB::
	.ASCIC	/UNKNOWN/
LASTPC=.				; **** TEMP UNTIL BUG IN MACRO FIXED **
	.ENDM	$DEFINI

	.MACRO	$EQU SYMBOL,VALUE
	.PSECT	DYNTAB
	.=LASTPC
	.IF EQ <LAST_VALUE_MAIN-VALUE>
	    .=.-L-1
	.ENDC
	LAST_SYM = .-DYN_TAB
	S = %LOCATE(<_>,SYMBOL)+1
	L = %LENGTH(SYMBOL)-S
	.ASCIC	/%EXTRACT(S,L,SYMBOL)/
	LASTPC=.			; **** TEMP UNTIL BUG IN MACRO FIXED **
	.IF NE <LAST_VALUE_MAIN-VALUE>
	    DIFF = VALUE-LAST_VALUE-1
	    .IF EQ DIFF
	        .IF NE SUBTF
	            NSUBT = NSUBT+1
	        .IFF
	            .PSECT DYNMAP
	            .BYTE  0
		    .PSECT DYNPTR
		    .WORD  SYM
	        .ENDC
	    .ENDC
	    .IF GT DIFF
	        .IF NE SUBTF
		    .PSECT DYNMAP
	            .BYTE  NSUBT
		    .PSECT DYNPTR
		    .WORD  SYM
	            SUBTF = 0
	            DIFF = VALUE-LAST_VALUE_MAIN-1
	        .IFF
		    .PSECT DYNMAP
	            .BYTE  0
		    .PSECT DYNPTR
		    .WORD  SYM
	        .ENDC
	            .REPT  DIFF
		      .PSECT DYNMAP
	              .BYTE  -1
		      .PSECT DYNPTR
		      .WORD  0
	            .ENDR
	    .ENDC
	    .IF LT DIFF
	        SUBTF = 1
	        NSUBT = 1
	    .ENDC
	    LAST_VALUE = VALUE
	    .IF EQ SUBTF
	        LAST_VALUE_MAIN = VALUE
		SYM = LAST_SYM
	    .ENDC
	.ENDC
	SYMBOL = VALUE
	.ENDM	$EQU

	.MACRO	$DEFEND NAME,P1,P2
END_SYM=LAST_VALUE_MAIN+1
	.PSECT	DYNTAB
	.BYTE	-1
	$EQU	END	256
	.ENDM	$DEFEND

	.nocross
	$DYNDEF				; EXPAND THE DYN SYMBOLS SPECIALLY
	.cross

	.PSECT	DYNCNT,LONG
DYN_CNT:
	.BLKW	END_SYM
DYN_CNT_SIZ=.-DYN_CNT
	.PSECT	DYNBYTES,LONG
DYN_BYTES:
	.BLKL	END_SYM
DYN_BYT_SIZ=.-DYN_BYTES
	.MDELETE $DEFINI,$EQU,$DEFEND

	.PSECT	POOL,EXE,NOWRT

	.DEFAULT DISPLACEMENT,LONG
	.PAGE
	.SBTTL	SHOW_POOL_RANGE -- DISPLAY DYNAMIC STORAGE POOLS
;---
;
;	DISPLAY AND FORMAT THE CONTENTS OF THE NON-PAGED AND PAGED
;	DYNAMIC STORAGE POOL OR ANY RANGE THEREOF.
;
; INPUTS:
;
;	OPTIONS = OPTIONS FLAGS (RANGE OR LENGTH BITS RELEVANT)
;	ESP	= END OF POOL
;		(OR, IF LENGTH BIT SET)
;	ESP	= SIZE OF POOL
;	ESP+4	= START OF POOL
;
; OUTPUTS:
;
;	NONE
;---

	.ENTRY	SHOW_POOL_RANGE,^M<R2,R3,R4,R5,R6,R10,R11>

	MOVAB	OPTIONS, R6		; POINT TO OPTIONS WORD
	MOVL	(R6), R2
	BBS	#OPT$V_IRP, R2, 20$	; /IRP NOT ALLOWED
	BITL	#OPT$M_NONPAGED!OPT$M_PAGED, R2	; IF NEITHER SPECIFIED...
	BNEQ	10$			; THEN
	BBSS	#OPT$V_NONPAGED,(R6),10$	; SET /NONPAGED
10$:	MOVL	ESP, R1			; POINT TO EXPRESSION STACK
	BBS	#OPT$V_RANGE, R2, 30$	; RANGE SPECIFIED
	BBS	#OPT$V_LENGTH, R2, 40$	; LENGTH SPECIFIED
20$:	CLRL	R0			; SYNTAX ERROR
	RET

30$:	MOVL	4(R1),R5		; R5 = LOWEST ADDRESS
	SUBL3	R5,(R1),R4		; R4 = SIZE
	BBSS	#OPT$V_LENGTH,(R6),50$	; SET A SINGLE BIT FOR RANGE
	BRB	50$

40$:	MOVQ	(R1),R4			; R5 = LOWEST ADDRESS

50$:	BRW	SCAN_POOL		; JOIN COMMON CODE
	.PAGE
	.SBTTL	SHOW_POOL -- DISPLAY DYNAMIC STORAGE POOLS
;---
;
;	SHOW_POOL
;
;	DISPLAY AND FORMAT THE CONTENTS OF THE NON-PAGED AND PAGED
;	DYNAMIC STORAGE POOL.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABLE LSB
	.ENTRY	SHOW_POOL,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	CLRL	SPACE_USED			; INITIALIZE SPACE USAGE
	MOVC5	#0,(SP),#0,#DYN_CNT_SIZ,DYN_CNT ; AND TYPE COUNTS
	MOVC5	#0,(SP),#0,#DYN_BYT_SIZ,DYN_BYTES ; AND BYTE COUNTS
	MOVAB	BUFFER,R11			; R11 = GETMEM BUFFER
	MOVAB	OPTIONS,R3			; PTR TO OPTIONS WORD
	BITL	#OPT$M_IRP!OPT$M_LRP!OPT$M_SRP!-
		 OPT$M_NONPAGED!OPT$M_PAGED,(R3); SOMETHING SET?
	BNEQ	10$				; BRANCH IF SO
	BISL	#OPT$M_IRP!OPT$M_LRP!OPT$M_SRP!-
		 OPT$M_NONPAGED!OPT$M_PAGED,(R3); SET /ALL
10$:	BBC	#OPT$V_IRP,(R3),30$		; SKIP IF NO /IRP
;
;	SCAN CONTENTS OF IRP LOOKASIDE LIST
;
	SUBHD	<IRP lookaside list>
	SKIP	PAGE
	BBS	#OPT$V_SUMMARY,(R3),20$	; SKIP IF SUMMARY ONLY
	PRINT	0,<!_!_!_Dump of blocks allocated from IRP lookaside list>
	SKIP	3
20$:	MOVZBL	#IRP_SIZE,R10		; R10 = IRP BLOCK SIZE
	REQMEM	@EXE$GL_SPLITADR,R7	; ADDRESS OF IRP LOOKASIDE LIST
	REQMEM	@IOC$GL_IRPCNT,R8	; NUMBER OF IRP SLOTS ALLOCATED
	REQMEM	@IOC$GL_IRPFL,R9	; HEAD OF IRP LIST
	MOVL	IOC$GL_IRPFL,R6		; ADDRESS OF HEAD
	CALLS	#0,W^DO_ILRP		; SCAN THE IRP FREELIST
30$:	BBS	#OPT$V_LRP,OPTIONS,35$	; /LRP PRESENT?
	BRW	42$			; NO, SKIP THE LRP
;
;	SCAN CONTENTS OF LRP LOOKASIDE LIST
;
35$:	CLRL	SPACE_USED			; INITIALIZE SPACE USAGE
	MOVC5	#0,(SP),#0,#DYN_CNT_SIZ,DYN_CNT ; AND TYPE COUNTS
	MOVC5	#0,(SP),#0,#DYN_BYT_SIZ,DYN_BYTES ; AND BYTE COUNTS
	SUBHD	<LRP lookaside list>
	SKIP	PAGE
	BBS	#OPT$V_SUMMARY,OPTIONS,40$	; SKIP IF SUMMARY ONLY
	PRINT	0,<!_!_!_Dump of blocks allocated from LRP lookaside list>
	SKIP	3
40$:	REQMEM	@IOC$GL_LRPSIZE,R10	; R10 = LRP BLOCK SIZE
	REQMEM	@IOC$GL_LRPSPLIT,R7	; ADDRESS OF LRP LOOKASIDE LIST
	REQMEM	@IOC$GL_LRPCNT,R8	; NUMBER OF LRP SLOTS ALLOCATED
	REQMEM	@IOC$GL_LRPFL,R9	; HEAD OF IRP LIST
	MOVL	IOC$GL_LRPFL,R6		; ADDRESS OF HEAD
	CALLS	#0,W^DO_ILRP		; SCAN THE LRP FREELIST
42$:	BBS	#OPT$V_SRP,OPTIONS,45$	; /SRP PRESENT?
	BRW	SCAN_POOL		; NO, SKIP THE SRP
;
;	SCAN CONTENTS OF SRP LOOKASIDE LIST
;
45$:	CLRL	SPACE_USED			; INITIALIZE SPACE USAGE
	MOVC5	#0,(SP),#0,#DYN_CNT_SIZ,DYN_CNT ; AND TYPE COUNTS
	MOVC5	#0,(SP),#0,#DYN_BYT_SIZ,DYN_BYTES ; AND BYTE COUNTS
	SUBHD	<SRP lookaside list>
	SKIP	PAGE
	BBS	#OPT$V_SUMMARY,OPTIONS,47$	; SKIP IF SUMMARY ONLY
	PRINT	0,<!_!_!_Dump of blocks allocated from SRP lookaside list>
	SKIP	3
47$:	REQMEM	@IOC$GL_SRPSIZE,R10	; R10 = SRP BLOCK SIZE
	REQMEM	@IOC$GL_SRPSPLIT,R7	; ADDRESS OF SRP LOOKASIDE LIST
	REQMEM	@IOC$GL_SRPCNT,R8	; NUMBER OF SRP SLOTS ALLOCATED
	REQMEM	@IOC$GL_SRPFL,R9	; HEAD OF IRP LIST
	MOVL	IOC$GL_SRPFL,R6		; ADDRESS OF HEAD
	CALLS	#0,W^DO_ILRP		; SCAN THE LRP FREELIST
;
;	SCAN CONTENTS OF DYNAMIC NON-PAGED POOL 
;
SCAN_POOL:
	MOVL	OPTIONS,R10		; PICK UP OPTIONS
	BBC	#OPT$V_NONPAGED,R10,60$	; BRANCH IF NOT SPECIFIED
	SUBHD	<Non-paged dynamic storage pool>
	SKIP	PAGE
	BBS	#OPT$V_SUMMARY,R10,50$ ; SKIP IF SUMMARY ONLY
	PRINT	0,<!_!_!_Dump of blocks allocated from non-paged pool>
	SKIP	3
50$:
	ADDL3	EXE$GL_NONPAGED,#4,R6	; ADDRESS OF FREE SPACE LIST
	REQMEM	@MMG$GL_NPAGEDYN,R2	; NO, USE BEGINNING OF NON-PAGED POOL
	REQMEM	@MMG$GL_NPAGNEXT	; ENDING ADDRESS OF POOL
	BICW	#^X1FF,R1		; LOW 9 BITS ARE FLAGS
	SUBL2	R2,R1			; LENGTH OF STORAGE POOL
	MOVL	#NONP,R3		; BITS FOR NON-PAGED
	BSBB	SET_UP_DUMP		; GO DUMP IT
;
;	SCAN CONTENTS OF DYNAMIC PAGED POOL 
;
60$:	BBC	#OPT$V_PAGED,R10,80$	; BRANCH IF NOT SPECIFIED
	SUBHD	<Paged dynamic storage pool>
	SKIP	PAGE
	BBS	#OPT$V_SUMMARY,R10,70$	; SKIP IF SUMMARY ONLY
	PRINT	0,<!_!_!_Dump of blocks allocated from paged pool>
	SKIP	3
70$:
	MOVL	EXE$GL_PAGED,R6		; ADDRESS OF FREE SPACE LIST
	REQMEM	@MMG$GL_PAGEDYN,R2	; BEGINNING OF PAGED POOL
	REQMEM	@SGN$GL_PAGEDYN		; NO, USE LENGTH OF POOL
	MOVL	#PAGD,R3		; BITS FOR PAGED
	BSBB	SET_UP_DUMP		; DUMP IT
80$:
	MOVL	#1,R0			; SUCCESS
	RET
	.DISABLE LSB

;
;	R1 = MAXIMUM LENGTH
;	R2 = MINIMUM START ADDRESS
;	R3 = POOL TYPE BITS
;	R4 = LENGTH (IF RANGE)
;	R5 = START ADDRESS (IF RANGE)
;	R6 = HEAD OF POOL
;
SET_UP_DUMP:
	BBC	#OPT$V_LENGTH,R10,30$	; RANGE SET?
	CMPL	R5,R2			; ADDRESS MUST BE START OR GREATER
	BGEQU	10$			; OKAY
	MOVL	R2,R5			; IT'S NOT, USE MIN
10$:	ADDL3	R1,R2,R0		; MAX ENDING ADDRESS
	SUBL3	R5,R0,-(SP)		; GET MAX LENGTH	
	CMPL	R4,(SP)			; USE GIVEN MUST BE LESS OR EQUAL
	BLEQU	20$			; OKAY
	MOVL	(SP),R4			; IT'S NOT, USE MAX
20$:	TSTL	(SP)+			; CLEAN STACK
	BRB	40$			; JOIN COMMON

30$:	MOVQ	R1,R4			; USE THE DEFAULT
40$:	PUSHR	#^M<R3,R4,R5,R6>	; PUSH THE PARAMETERS
	CALLS	#4,B^DUMP_POOL		; DUMP THE POOL
	RSB

	.PAGE
	.SBTTL	DUMP_POOL, DISPLAY DYNAMIC STORAGE POOL
;---
;
;	THIS ROUTINE DISPLAYS THE CONTENTS (AS BEST IT CAN) OF
;	A GIVEN DYNAMIC STORAGE POOL.
;
; INPUTS:
;	4(AP)  = BIT MASK FOR TYPE OF POOL
;	8(AP)  = LENGTH OF POOL
;	12(AP) = ADDRESS OF BEGINNING OF STORAGE POOL
;	16(AP) = ADDRESS OF FREE STORAGE LISTHEAD
;
;---
DUMP_POOL:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R11>

	MOVAB	L^BUFFER,R11		; R11 = SCRATCH BUFFER
	CLRL	4(R11)			; ZERO LENGTH
	CLRL	SPACE_USED		; INITIALIZE SPACE USAGE
	MOVC5	#0,(SP),#0,#DYN_CNT_SIZ,DYN_CNT ; ZERO COUNTS
	MOVC5	#0,(SP),#0,#DYN_BYT_SIZ,DYN_BYTES ; ZERO BYTE COUNTS
	MOVL	12(AP),R2		; SET ADDRESS OF POOL
	ADDL3	R2,8(AP),R4		; ENDING ADDRESS OF POOL
	MOVL	8(AP),TOTAL_SPACE	; TOTAL SPACE IN POOL
	REQMEM	@16(AP),R3		; END+1 OF FIRST USED AREA

	CMPL	R2,R3			; IS FIRST BLOCK FREE?
	BLEQU	50$			; BRANCH IF NOT
10$:	MOVL	R3,R6			; START OF FREE AREA
;
; WE ARE NOW POINTING TO THE NEXT FREE CHUNK.  USING ITS LINK POINTER
; AND ITS LENGTH, COMPUTE THE STARTING AND ENDING ADDRESS OF THE NEXT
; CHUNK OF ALLOCATED MEMORY.
;
20$:	REQMEM	(R6),(R11),#8		; LINK ADDRESS + LENGTH
	ADDL3	R6,4(R11),R2		; ADDRESS FOLLOWING FREE BLOCK
	MOVL	R2,R7			; MAKE A COPY
	CMPL	R2,12(AP)		; IS IT LESS THAN START?
	BGEQU	30$			; NO, OKAY
	MOVL	12(AP),R2		; USE SPECIFIED START ADDRESS
30$:	MOVL	(R11),R3		; ADDRESS FOLLOWING USED AREA
	BNEQ	40$			; BRANCH IF NOT END OF FREE LIST
	MOVL	R4,R3			; IF END OF FREE LIST, USE END OF POOL
40$:	CMPL	R3,12(AP)		; WITHIN RANGE OF SPECIFIED ADDRESS?
	BLSSU	10$			; NO, LOOK FOR NEXT BLOCK
	CMPL	R7,R4			; CHECK IF END OF POOL
	BLSSU	50$			; BRANCH IF NOT YET DONE
	BRW	120$

50$:	BBC	#OPT$V_FREE,OPTIONS,55$	; IF /FREE THEN
	MOVL	4(R11),R7		; LENGTH OF FREE AREA
	BEQL	55$			; NONE
	MNEGL	#1,-(SP)		; SET FOR "[free]"
	MOVQ	R6,-(SP)		; LENGTH AND ADDRESS
	CALLS	#3,W^POOL_BLOCK		; PRINT IT OUT
;
; DETERMINE THE BOUNDS OF THE BLOCK WE ARE NOW POINTING TO.
;
55$:	REQMEM	(R2),(R11),#12		; MUST BE AT LEAST 3 LONGWORDS
	MOVZWL	IRP$W_SIZE(R11),R5	; GET LENGTH OF BLOCK
	BEQL	60$			; BRANCH IF BAD LENGTH
	SUBL3	R2,R3,R1		; MAXIMUM ALLOWABLE LENGTH
	CMPL	R5,R1			; CHECK FOR REASONABLE LENGTH
	BGTR	60$			; BRANCH IF BAD LENGTH
	ADDL2	#^XF,R5			; ROUND TO NEAREST 16 BYTES
	BICL2	#^XF,R5
	BSBW	CHECK_BLOCK		; MAKE ADDITIONAL BLOCK CHECKS
	BLBS	R0,90$			; BRANCH IF VALID TYPE
;
; IF WE CANNOT MAKE SENSE OUT OF THE BLOCK CONTENTS, LOOKAHEAD AND
; TRY TO LOCATE THE NEXT BLOCK WHICH LOOKS REASONABLE.
;
60$:	MOVL	R2,R6			; INITIALIZE LOOKAHEAD POINTER
70$:	ADDL2	#16,R6			; LOOKAHEAD EACH 16 BYTES
	CMPL	R6,R3			; CHECK IF END OF AREA
	BGEQU	80$			; BRANCH IF END
	REQMEM	(R6),(R11),#12		; FIRST 3 LONGWORDS
	MOVZWL	IRP$W_SIZE(R11),R1	; CHECK IF SIZE VALID
	BEQL	70$			; SKIP IF BAD LENGTH
	SUBL3	R2,R3,R0		; MAXIMUM ALLOWABLE LENGTH
	CMPL	R1,R0			; CHECK FOR REASONABLE LENGTH
	BGTRU	70$			; SKIP IF BAD LENGTH
	BSBW	CHECK_BLOCK		; MAKE ADDITIONAL BLOCK CHECKS
	BLBC	R0,70$			; BRANCH IF ILLEGAL BLOCK
80$:
	SUBL3	R2,R6,R5		; LENGTH OF BLOCK
	CLRL	R1			; USE 0 AS BLOCK TYPE
;
; THE BOUNDS OF THE BLOCK HAVE BEEN DETERMINED - DISPLAY THE CONTENTS
;
90$:	INCW	DYN_CNT[R1]		; INCREMENT COUNT FOR TYPE
	ADDL	R5,DYN_BYTES[R1]	; INCREMENT BYTES USED FOR THIS TYPE
	PUSHL	R1			; TYPE OF BLOCK
	BEQL	100$			; SKIP SUBTYPE IF ZERO
	BISB	IRP$B_TYPE+1(R11),1(SP)	; SET POSSIBLE SUBTYPE
100$:	PUSHL	R5			; LENGTH OF BLOCK
	PUSHL	R2			; ADDRESS OF BLOCK
	CALLS	#3,W^POOL_BLOCK		; DUMP POOL BLOCK
	ADDL	R5,R2			; INCREMENT POINTER
	ADDL	R5,SPACE_USED		; INCREMENT SPACE USAGE
	CMPL	R2,R3			; CHECK IF END OF USED AREA
	BGEQU	110$			; BRANCH IF END
	CMPL	R2,R4			; CHECK IF END OF RANGE
	BGEQU	120$			; BRANCH IF END
	BRW	55$			; CONTINUE IF NOT
;
; END OF USED AREA REACHED - SKIP TO NEXT FREE CHUNK AND LOOP
;
110$:	CMPL	R3,R4			; ARE WE ARE THE END OF THE POOL?
	BGEQU	120$			; BRANCH IF SO
	MOVL	R3,R6			; SKIP TO NEXT FREE BLOCK
	BRW	20$
;
; END OF POOL REACHED - DISPLAY STATISTICS
;
120$:	SKIP	PAGE
	PRINT	0,<Summary of pool contents>
	CALLS	#0,W^SHOW_COUNTS	; DISPLAY TYPE COUNTS
130$:
	STATUS	SUCCESS
	RET

	.DISABLE	LSB
	.PAGE
;
;	LOCAL SUBROUTINE TO CHECK IF BLOCK IS VALID
;
; INPUTS:
;	R7    = SCRATCH REGISTER
;	R11   = ADDRESS OF FIRST 16 BYTES IN LOCAL STORAGE
;	4(AP) = MASK FOR TYPE OF POOL
;
; OUTPUTS:
;	R0    = STATUS
;	R1    = BLOCK TYPE
;

CHECK_BLOCK:
;
; CHECK THE TYPE - 1) IS IT NON-ZERO, 2) IS IT A TYPE DEFINED IN THE
; $DYNDEF MACRO, 2) IF IT IS SUBTYPEABLE, IS THE SUBTYPE WITHIN RANGE?
;
	MOVZBL	IRP$B_TYPE(R11),R1	; PICK UP TYPE
	BEQL	60$			; BRANCH IF NOT VALID TYPE
	MOVB	DYN_MAP[R1],R7		; CHECK VALIDITY
	BLSS	60$			; BRANCH IF NOT VALID TYPE
	BEQL	10$			; BRANCH IF NOT SUBTYPABLE
	MOVB	IRP$B_TYPE+1(R11),R0	; PICK UP POSSIBLE SUBTYPE
	BEQL	10$			; ZERO IS OKAY
	CMPB	R0,R7			; CHECK RANGE
	BGTRU	60$			; OUT OF RANGE, NOT VALID
;
; NOW MAKE SPECIAL CHECKS ON PARAMETERS DEFINED IN BLOCK_TABLE -
; MAX AND MIN SIZE, TYPE OF POOL, AND GRANULARITY.
;
10$:	MOVAB	BLOCK_TABLE,R0		; ADDRESS START OF TABLE
20$:	TSTB	(R0)			; CHECK IF END OF TABLE
	BEQL	50$			; BRANCH IF TABLE EXAUSTED
	CMPB	R1,(R0)+		; CHECK IF TYPE IN TABLE
	BEQL	30$			; BRANCH IF FOUND
	ADDL	#BLK_TBL_SIZ-1,R0	; SKIP TO NEXT ENTRY IN TABLE
	BRB	20$			; AND LOOP UNTIL DONE

30$:	MOVZWL	IRP$W_SIZE(R11),R7	; PICK UP SIZE
	CMPW	R7,(R0)+		; CHECK AGAINST MINIMUM
	BLSSU	60$			; BRANCH IF ILLEGAL
	CMPW	R7,(R0)+		; CHECK AGAINST MAXIMUM
	BGTRU	60$			; BRANCH IF ILLEGAL
	BITB	4(AP),(R0)+		; CAN THIS BLOCK BE IN THIS POOL?
	BEQL	60$			; NO, LEAVE
	BITB	R7,(R0)+		; CHECK GRANULARITY OF BLOCK
	BNEQ	60$			; BRANCH IF NOT GRANULAR
40$:	MOVL	#1,R0			; MARK BLOCK VALID
	RSB

50$:	BITB	R7,#^F			; DEFAULT GRANULARITY = 16 BYTES
	BEQL	40$			; BRANCH IF GRANULARITY OK

60$:	CLRQ	R0			; MARK BLOCK ILLEGAL - UNKNOWN
	RSB

	.PAGE
;
;	LOCAL SUBROUTINE TO CREATE LRP-IRP USAGE BITMAP
;
;	R6  =	Lookaside list head
;	R7 -->	Start of pool for lookaside list
;	R8  =	Number of blocks in lookaside list
;	R9 -->	Lookaside list head
;	R10 =	Size of block
;	R11-->	Scratch buffer
;

	.ENABLE LSB
DO_ILRP:
	.WORD	0

	PUSHL	R8			; HOLD
	ASHL	#-3,R8,R0		; CALC LENGTH OF BITMAP
	ADDL3	#1,R0,-(SP)		; NUMBER OF BYTES FOR BITMAP
	MOVL	IRP_BITMAP,R8		; ADDRESS OF BITMAP
	BNEQ	5$			; BRANCH IF ALREADY ALLOCATED
	PUSHL	(SP)			; AMOUNT NEEDED
	CALLS	#1,ALLOCATE		; ALLOCATE THE SPACE FOR THE BITMAP
	MOVL	R1,IRP_BITMAP		; AND SAVE ADDRESS OF IT
	MOVL	R1,R8
5$:	MOVC5	#0,(SP),#0,(SP),(R8)	; ZERO BITMAP
	MOVQ	(SP)+,R4		; CLEAN STACK & R5 = # OF BLOCKS
10$:	CMPL	R9,R6			; CHECK IF END OF LIST
	BEQL	30$			; BRANCH IF END OF LIST
	SUBL3	R7,R9,R0		; CALCULATE OFFSET FROM START OF IRPS
	BLEQ	20$			; BRANCH IF ILLEGAL POOL ADDRESS
	DIVL	R10,R0			; GET INDEX INTO BITMAP
	CMPL	R0,R5			; CHECK IF BIT NUMBER TOO LARGE
	BGEQU	20$			; BRANCH IF OUTSIDE OF BITMAP
	BBSS	R0,(R8),20$		; SET BIT IN BITMAP FOR THIS FREE IRP
20$:	REQMEM	(R9),R9			; GET FIRST LONGWORD AND FOLLOW CHAIN
	BRB	10$

30$:	MULL3	R10,R5,TOTAL_SPACE	; TOTAL BYTES FOR IRP LIST
	ADDL3	R7,TOTAL_SPACE,R3	; ENDING ADDRESS OF SCAN
	CLRL	R6			; INIT BITMAP INDEX
;
;	SCAN THE IRP LOOKASIDE POOL FOR ALLOCATED BLOCKS
;
40$:	CMPL	R7,R3			; CHECK IF DONE WITH SCAN
	BGEQ	100$			; BRANCH IF DONE
	BBS	R6,@IRP_BITMAP,110$	; BRANCH IF BLOCK ON FREE LIST
	ADDL	R10,SPACE_USED		; INCREMENT SPACE USAGE
	REQMEM	(R7),(R11),#32		; GET ENOUGH TO USE
	MOVZBL	IRP$B_TYPE(R11),R0	; GET BLOCK TYPE CODE
	BEQL	50$			; BRANCH IF UNKNOWN
	TSTB	DYN_MAP[R0]		; CHECK IF TYPE LEGAL
	BGEQ	60$			; BRANCH IF OK
50$:	CLRL	R0			; ZERO = UNKNOWN
60$:	INCW	DYN_CNT[R0]		; INCREMENT COUNT FOR TYPE
	ADDL	R10,DYN_BYTES[R0]	; INCREMENT BYTES USED FOR TYPE
70$:	PUSHL	R0			; BLOCK TYPE
	BEQL	80$			; SKIP SUBTYPE IF ZERO
	BISB	IRP$B_TYPE+1(R11),1(SP)	; SET POSSIBLE SUBTYPE
80$:	PUSHL	R10			; BLOCK LENGTH
	PUSHL	R7			; BLOCK ADDRESS
	CALLS	#3,B^POOL_BLOCK		; DUMP CONTENTS OF BLOCK
90$:	ADDL	R10,R7			; NEXT BLOCK
	INCL	R6			; INCREMENT BITMAP INDEX
	BRB	40$			; CONTINUE UNTIL DONE

100$:	SKIP	PAGE
	PRINT	0,<Summary of lookaside list>
	CALLS	#0,W^SHOW_COUNTS	; DISPLAY BLOCK TYPE COUNTS
	RET

110$:	BBC	#OPT$V_FREE,OPTIONS,90$	; SKIP BLOCK UNLESS /FREE
	MNEGL	#1,-(SP)		; SET TO PRINT "[Free]"
	BRB	80$			; DO IT
	.DISABLE LSB
	.PAGE
;
;	LOCAL SUBROUTINE TO DUMP CONTENTS OF POOL BLOCK
;
;	4(AP) = ADDRESS OF BLOCK
;	8(AP) = LENGTH OF BLOCK
;	12(AP) = TYPE OF BLOCK (0 IF UNKNOWN)
;	13(AP) = POSSIBLE SUBTYPE
;

	.ENABL	LSB

FREE_STR:
	.ASCIC	/[Free]/

POOL_BLOCK:
	.WORD	^M<R2,R3,R4,R5,R6>

	MOVL	OPTIONS,R6		; PICK UP THE OPTIONS WORD
	BBC	#OPT$V_SUMMARY,R6,5$	; SKIP IF SUMMARY ONLY
	RET

5$:	TSTL	12(AP)			; FLAG SET?
	BGEQ	15$			; NORMAL
	MOVAL	FREE_STR,R4		; ADDRESS OF "[FREE]"
	BRB	25$			; PRINT IT
	
15$:	MOVZBL	12(AP),R0		; TYPE OF BLOCK
	MOVZWL	DYN_PTR[R0],R4		; OFFSET FROM DYN_TAB TO SYMBOL NAME
	MOVAB	DYN_TAB[R4],R4		; ADDRESS OF SYMBOL NAME
	MOVZBL	DYN_MAP[R0],R1		; PICK UP INFO ON TYPE
	BEQL	20$			; NOT SUB-TYPABLE, CONTINUE
	MOVZBL	13(AP),R2		; PICK UP POSSIBLE SUBTYPE
	BEQL	20$			; NONE, CONT
	CMPB	R2,R1			; CHECK LEGAL RANGE
	BGTR	20$			; OUT OF RANGE, CONT
10$:	MOVZBL	(R4)+,R0		; LENGTH OF SYMBOL
	ADDL	R0,R4			; STEP OVER IT
	SOBGTR	R2,10$			; DO IT UNTIL SYMBOL VALUE
20$:	BBC	#OPT$V_TYPE,R6,25$	; SKIP IF NO /TYPE=
	MOVL	R4,R5			; COPY POINTER
	MOVZBL	(R5)+,R0		; PICK UP LENGTH
	CMPB	R0,STRUCTURE		; DO LENGTHS MATCH?
	BNEQ	90$			; NO, SO NO HOPE OF CHAR MATCH
	CMPC3	R0,(R5),@STRUCTURE+4	; DO CHAR MATCH?
	BNEQ	90$			; NO, NO MATCH AT ALL
25$:	PUSHL	8(AP)			; LENGTH OF BLOCK
	PUSHL	4(AP)			; ADDRESS OF BLOCK
	PUSHL	R4			; PUSH ADDRESS OF SYMBOL
	PRINT	3,<!7AC !8XL !5UL>
30$:
	REQMEM	@4(AP),BUFFER,#16	; 16 BYTES PER LINE
	MOVAL	BUFFER,R0
	PUSHL	R0			; ADDRESS OF DATA
	PUSHL	#16			; LENGTH OF STRING
	PUSHL	(R0)+
	PUSHL	(R0)+
	PUSHL	(R0)+
	PUSHL	(R0)+
	PRINT	6,<!3(_)!4(9XL) !AF>	; PRINT DUMP LINE
	ADDL2	#16,4(AP)		; INCREMENT ADDRESS
	SUBL2	#16,8(AP)		; DECREMENT LENGTH
	BLEQ	90$			; DONE, LEAVE
	BBC	#OPT$V_HEADER,R6,30$	; MORE TO DO
90$:
	RET

	.DSABL	LSB

	.PAGE
;
;	LOCAL SUBROUTINE TO DISPLAY THE BLOCK TYPE COUNTS
;

	.ENABL	LSB

SHOW_COUNTS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>

	SKIP	1			; PRINT BLANK LINE
	MOVAB	DYN_PTR,R2		; ADDRESS OF SYMBOL TABLE
	MOVAB	DYN_CNT,R3		; ADDRESS OF COUNT TABLE
	MOVAB	DYN_BYTES,R4		; ADDRESS OF BYTE USAGE TABLE
	MOVZWL	#END_SYM,R7		; NUMBER OF SYMBOLS TO LOOK AT
	MOVQ	SPACE_USED,R8		; PICK UP SOME VALUES
	BBC	#OPT$V_LENGTH,OPTIONS,5$; FOR RANGE SPECIFIED
	CMPL	R8,R9			; IS SPACE_USED > TOTAL_SPACE?
	BLEQU	5$			; NO
	MOVL	R8,R9			; YES, THEN SET EQUAL
5$:	DIVL3	#100,R8,R5		; COMPUTE SPACE USED/100
10$:
	MOVL	(R4)+,R1		; GET # BYTES FOR THIS TYPE
	MOVZWL	(R2)+,R6		; OFFSET FOR SYMBOL
	MOVZWL	(R3)+,R0		; GET NEXT COUNT
	BEQL	20$			; SKIP IF ZERO
	DIVL3	R5,R1,-(SP)		; GET PERCENTAGE USAGE
	PUSHL	R1			; GET BYTE COUNT FOR THIS TYPE
	PUSHAB	DYN_TAB[R6]		; ADDRESS OF SYMBOL
	PUSHL	R0
	PRINT	4,<!5UW  !9AC = !8UL  (!UL%)>
20$:
	SOBGEQ	R7,10$

	SUBL3	R8,R9,-(SP)		; SPACE LEFT TO USE
	MOVQ	R8,-(SP)		; TOTAL SPACE AVAILABLE
	SKIP	1
	PRINT	3,<Total space used = !UL out of !UL total bytes, !UL bytes left>
	MULL	#100,R8			; SET UP FOR PERCENTAGE
	DIVL3	R9,R8,-(SP)
	SKIP	1
	PRINT	1,<Total space utilization = !UL%>
	RET

	.DSABL	LSB


	.END
