	.TITLE	MMG	PAGE TABLE FORMATTING ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	THIS MODULE CONTAINS ROUTINES RELATING TO FORMATTED
;	A SPECIFIED PAGE TABLE.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V02-034	KTA0034		Kerbey T. Altmann	04-Sep-1981
;		Fix problem with KTA0029 - use of /ALL with SHOW PAGE.
;
;	V02-007	KTA0029		Kerbey T. Altmann	03-Jul-1981
;		Add new routine for SHOW PAGE range.
;
;	V02-006	LJK0030		Lawrence J. Kenah	20-Jul-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V02-005	LJK0029		Lawrence J. Kenah	20-Jul-1981
;		Make listheads for three physical page lists longwords instead 
;		of words and change all references to these listheads.
;
;	004	MTR0001		Mike Rhodes	22-Jun-1981
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;
;		1.  Correct branch address out of range error after first call 
;		to GETMEM in routine DISPLAY_SPT.
;
;		2.  Correct branch address out of range errors in routine
;		DUMP_PTE (local section for formatting the PFN structures
;		associated with the current PTE).
;
;		Change default addressing mode to longword.
;		Remove ref's to $SDAMSGDEF macro.
;
;	003	TMH0003		TIM HALVORSEN		05-MAY-1980
;		FIX LOOKUP OF WSLE TO SKIP IF NO PFN. ALSO, USE WORD
;		CONTEXT ADDRESSING MODE RATHER THAN LONGWORD WHEN DEALING
;		WITH THE WSLX ARRAY.
;
;--

	.PAGE
	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$DMPDEF				; Dump file definitions
	$OPDEF				; Define opcode equivalences
	$OPTDEF				; Options definitions
	$PFNDEF				; Page frame data definitions
	$PHDDEF				; Process header definitions
	$PTEDEF				; Page table entry definitions
	$TPADEF				; TPARSE definitions
	$VADEF				; Virtual address definitions
	$WSLDEF				; Working set list definitions

	.PAGE
	.SBTTL	STORAGE DEFINTIONS
;
;	WRITABLE STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

BUFFER:
	.BLKL	16			; GETMEM WORK BUFFER

SDA$GL_MAXPFN:
	.BLKL	1			; VALUE OF MMG$GL_MAXPFN
	MMG$GW_BIGPFN = SDA$GL_MAXPFN + 2
SDA$AB_STATE:
	.BLKL	1			; VALUE OF PFN$AB_STATE
SDA$AB_TYPE:
	.BLKL	1			; PFN$AB_TYPE
SDA$AW_REFCNT:
	.BLKL	1			; PFN$AW_REFCNT
SDA$AL_BAK:
	.BLKL	1			; PFN$AL_BAK
SDA$AL_PTE:
	.BLKL	1			; PFN$AL_PTE
SDA$Ax_FLINK:
	.BLKL	1			; PFN$AW_FLINK
SDA$Ax_BLINK:
	.BLKL	1			; PFN$AW_BLINK
SDA$Ax_WSLX:
	.BLKL	1			; WORKING SET INDEX

	.PSECT	MMG,EXE,NOWRT

	.DEFAULT DISPLACEMENT,LONG

	.PAGE
	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

PTECTL1:
	STRING	<!_!XL    !XL !XL    !AD !AD !AD !AD !AD>
PTECTL2_WORD:
	STRING	<!_!XL    !XL !XL    !AD !AD !AD !AD !AD !AD !AD !XB   !XB !6UW   !XL   !XL  !XW  !XW>
PTECTL2_LONG:
	STRING	<!_!XL    !XL !XL    !AD !AD !AD !AD !AD !AD !AD !XB   !XB !6UW   !XL   !XL  !XL  !XL>

PROT_TABLE:
	.ASCII	/NONE/
	.ASCII	/****/
	.ASCII	/KW  /
	.ASCII	/KR  /
	.ASCII	/UW  /
	.ASCII	/EW  /
	.ASCII	/ERKW/
	.ASCII	/ER  /
	.ASCII	/SW  /
	.ASCII	/SREW/
	.ASCII	/SRKW/
	.ASCII	/SR  /
	.ASCII	/URSW/
	.ASCII	/UREW/
	.ASCII	/URKW/
	.ASCII	/UR  /

OWNER_TABLE:
	.ASCII	/KESU/

TYPE_TABLE:
	.ASCII	/TRANS/
	.ASCII	/GPTX /
	.ASCII	/PGFIL/
	.ASCII	/STX  /
	.ASCII	/DZERO/
	.ASCII	/VALID/
	.ASCII	/IOPAG/
	.ASCII	/     /

LOC_TABLE:
	.ASCII	/FREELST /
	.ASCII	/MDFYLST /
	.ASCII	/BADLIST /
	.ASCII	/RELPEND /
	.ASCII	/RDERROR /
	.ASCII	/PAGEOUT /
	.ASCII	/PAGEIN  /
	.ASCII	/ACTIVE  /

PAGTYP_TABLE:
	.ASCII	/PROCESS /
	.ASCII	/SYSTEM  /
	.ASCII	/GLOBAL  /
	.ASCII	/GBLWRT  /
	.ASCII	/PPGTBL  /
	.ASCII	/GPGTBL  /
	.ASCII	/        /
	.ASCII	/        /

MODIFY_TABLE:
	.ASCII	/ M/

WSLOCK_TABLE:
	.ASCII	/ L/

	.PAGE
	.SBTTL	INIT_PFN -- INITIALIZE FOR EXAMINING PFN DATA BASE
;---
;
;	INIT_PFN
;
;	THIS ROUTINE MUST BE CALLED BEFORE ANY REFERENCES ARE
;	MADE TO THE PFN DATA BASE.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	R0 = SUCCESS FLAG
;	SDA$A... CELLS ARE INITIALIZED
;
;---

INIT_PFN::
	.WORD	0

	REQMEM	@MMG$GL_MAXPFN,SDA$GL_MAXPFN
	REQMEM	@PFN$AB_STATE,SDA$AB_STATE
	REQMEM	@PFN$AB_TYPE,SDA$AB_TYPE
	REQMEM	@PFN$AW_REFCNT,SDA$AW_REFCNT
	REQMEM	@PFN$AL_BAK,SDA$AL_BAK
	REQMEM	@PFN$AL_PTE,SDA$AL_PTE
	REQMEM	@PFN$Ax_FLINK,SDA$Ax_FLINK
	REQMEM	@PFN$Ax_BLINK,SDA$Ax_BLINK
	REQMEM	@PFN$Ax_WSLX,SDA$Ax_WSLX
	RET

	.PAGE
	.SBTTL	DISPLAY_PFN	DISPLAY MEMORY MANAGEMENT DATA
;---
;
;	DISPLAY_PFN
;
;	THIS ROUTINE IS RESPONSIBLE FOR PRINTING ALL INFORMATION
;	RELATING TO THE MEMORY MANAGEMENT DATA BASE.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---
	.ENABL	LSB

.ENTRY	DISPLAY_PFN,^M<R2,R3,R4,R5,R6>

	CALLS	#0,INIT_PFN		; SETUP TO READ PFN DATA
	BBC	#OPT$V_SINGLEPFN,OPTIONS,20$	; BRANCH IF LIST WANTED
;
;	DISPLAY A SINGLE SPECIFIED PFN ENTRY
;
	MOVL	TPA$L_NUMBER(AP),R6	; R6 = PFN TO DISPLAY
	CMPL	R6,SDA$GL_MAXPFN	; CHECK IF PFN VALID
	BGEQU	10$			; BRANCH IF INVALID PFN
	CALLS	#0,W^PFN_TITLE		; DISPLAY THE TITLE LINE
	CALLS	#0,W^SHOW_PFN		; DISPLAY THE PFN DATA
	SKIP	1
	MOVL	#1,R0
	RET
10$:
	PUSHL	SDA$GL_MAXPFN
	PRINT	1,<Invalid PFN number (maximum is !XL)>
	RET
20$:
	MOVL	SCH$GL_FREECNT,R2	; ADDRESS OF COUNT ARRAY
	MOVL	PFN$AL_LOLIMIT,R3	; ADDRESS OF LOLIMIT ARRAY
	MOVL	PFN$AL_HILIMIT,R4	; ADDRESS OF HILIMIT ARRAY
	MOVL	PFN$AL_HEAD,R5		; ADDRESS OF LIST HEADS

	BBC	#OPT$V_FREE,OPTIONS,30$	; BRANCH IF NO FREE LIST
	SUBHD	<Free page list>
	SKIP	PAGE
	CALLS	#0,W^SHOW_PFN_LIST	; DISPLAY FREE PAGE LIST
30$:
	TSTL	(R2)+
	TSTL	(R3)+
	TSTL	(R4)+
	TSTL	(R5)+
	BBC	#OPT$V_MODIFIED,OPTIONS,40$	; BRANCH IF NO MODIFIED
	SUBHD	<Modified page list>
	SKIP	PAGE
	CALLS	#0,B^SHOW_PFN_LIST	; DISPLAY MODIFIED PAGE LIST
40$:
	TSTL	(R2)+
	TSTL	(R3)+
	TSTL	(R4)+
	TSTL	(R5)+
	BBC	#OPT$V_BAD,OPTIONS,50$	; BRANCH IF NO BAD LIST
	SUBHD	<Bad page list>
	SKIP	PAGE
	CALLS	#0,B^SHOW_PFN_LIST	; DISPLAY BAD PAGE LIST
;
;	PRINT ENTIRE PFN DATA FROM ENTRY 0 TO N
;
50$:
	BBC	#OPT$V_WHOLEPFN,OPTIONS,70$	; BRANCH IF NOT WANTED
	SUBHD	<PFN data base>
	MOVAB	W^PFN_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE
	SKIP	PAGE
	CLRL	R6			; START AT PFN 0
60$:	CALLS	#0,SHOW_PFN		; SHOW PFN IN R6
	INCL	R6			; SKIP TO NEXT PFN
	CMPL	R6,SDA$GL_MAXPFN	; CHECK IF LAST PFN
	BLSSU	60$			; LOOP UNTIL DONE
70$:
	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.PAGE
	.SBTTL	SHOW_PFN_LIST, DISPLAY PFN LIST
;---
;
;	SHOW_PFN_LIST
;
;	THIS ROUTINE DISPLAYS THE PFN DATA FOR THE FREE,
;	MODIFIED AND BAD PAGE LISTS.
;
;   INPUTS:
;
;	R2 = ADDRESS OF COUNT LONGWORD
;	R3 = ADDRESS OF LOLIMIT LONGWORD
;	R4 = ADDRESS OF HILIMIT LONGWORD
;	R5 = ADDRESS OF LIST HEAD LONGWORD
;
;---

	.ENABL	LSB

SHOW_PFN_LIST:
	.WORD	^M<R6>

	SKIP	1
	GETMEM	(R2),-(SP)		; GET LIST COUNT
	BLBC	R0,10$
	PRINT	1,<Count:        !12SL>
10$:
	GETMEM	(R3),-(SP)		; GET LIST LOLIMIT
	BLBC	R0,20$
	PRINT	1,<Lolimit:      !12SL>
20$:
	GETMEM	(R4),-(SP)		; GET LIST HILIMIT
	BLBC	R0,30$
	PRINT	1,<High limit:   !12SL>
30$:
	CALLS	#0,B^PFN_TITLE		; PRINT HEADING LINE
	MOVAB	PFN_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE
	GETMEM	(R5),R6			; GET LIST HEAD
	BLBS	R0,35$
80$:	BRW	90$
35$:
	BNEQ	40$			; BRANCH IF NON-EMPTY LIST
	PRINT	0,<*** List is empty ***>
	BRW	90$
40$:
	CALLS	#0,W^SHOW_PFN		; DISPLAY PFN IN R6
		PFN_REFERENCE	-
	MOVAW	<@SDA$Ax_FLINK[R6],R1>,-
		LONG_OPCODE=MOVAL,-
		IMAGE=SDA
	GETMEM	(R1)
	BLBC	R0,90$			; SKIP IF ERROR
		PFN_REFERENCE	-
	MOVZWL	<R1,R6>,-		; SKIP TO NEXT ENTRY IN LIST
		LONG_OPCODE=MOVL,-
		IMAGE=SDA
	BEQL	90$			; LOOP UNTIL END OF LIST
	BRW	40$
90$:
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	RET

	.DSABL	LSB

	.SBTTL	PFN_TITLE, DISPLAY PFN HEADING LINE
;---
;
;	PFN_TITLE
;
;	DISPLAY THE HEADING LINE FOR THE PFN DATA DISPLAY
;
;---

	.ENABLE		LOCAL_BLOCK

PFN_TITLE:
	.WORD	0

	SKIP	1
	PFN_DISP_IF_BIGPFN_THEN
		PRINT	0,<  PFN      PTE ADDRESS    BAK      REFCNT    FLINK     BLINK       TYPE           STATE>
		PRINT	0,<  ----     -----------  --------   ------    -----     -----     ----------     ---------->
	PFN_DISP_ELSE
		PRINT	0,<PFN    PTE ADDRESS    BAK      REFCNT  FLINK BLINK     TYPE           STATE>
		PRINT	0,<----   -----------  --------   ------  ----- -----   ----------     ---------->
	PFN_DISP_ENDIF
	SKIP	1
	RET

	.DISABLE	LOCAL_BLOCK

	.SBTTL	SHOW_PFN, SHOW DATA ON A SINGLE PFN ENTRY
;---
;
;	SHOW_PFN
;
;	THIS ROUTINE DISPLAYS THE PFN DATA BASE ASSOCIATED
;	WITH A SINGLE PAGE FRAME NUMBER.
;
; INPUTS:
;
;	R6 = PAGE FRAME NUMBER
;
; OUTPUTS:
;
;	THE ENTRY IS DISPLAYED.
;
;---
	.ENABL	LSB

SHOW_PFN:
	.WORD	0

	MOVAB	@SDA$AB_STATE[R6],R1	; GET PFN STATE
	GETMEM	(R1)
	BLBC	R0,70$			; SKIP IF ERROR
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,R1,R0
	PUSHAQ	LOC_TABLE[R0]		; ADDRESS OF STRING
	PUSHL	#7			; LENGTH OF STRING
	MOVZBL	R1,-(SP)
	MOVAB	@SDA$AB_TYPE[R6],R1	; GET PFN TYPE
	GETMEM	(R1)
	BLBC	R0,70$			; SKIP IF ERROR
	EXTZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,R1,R0
	PUSHAQ	PAGTYP_TABLE[R0]	; ADDRESS OF STRING
	PUSHL	#7			; LENGTH OF STRING
	MOVZBL	R1,-(SP)
		PFN_REFERENCE	-
	MOVAW	<@SDA$Ax_BLINK[R6],R1>,-
		LONG_OPCODE=MOVAL,-
		IMAGE=SDA
	GETMEM	(R1)
70$:	BLBC	R0,80$			; SKIP IF ERROR
		PFN_REFERENCE	-
	MOVZWL	<R1,-(SP)>,-		; BACKWARD LINK
		LONG_OPCODE=MOVL,-
		IMAGE=SDA
		PFN_REFERENCE	-
	MOVAW	<@SDA$Ax_FLINK[R6],R1>,-
		LONG_OPCODE=MOVAL,-
		IMAGE=SDA
	GETMEM	(R1)
80$:	BLBC	R0,90$			; SKIP IF ERROR
		PFN_REFERENCE	-
	MOVZWL	<R1,-(SP)>,-		; FORWARD LINK
		LONG_OPCODE=MOVL,-
		IMAGE=SDA
	MOVAW	@SDA$AW_REFCNT[R6],R1
	GETMEM	(R1)
	BLBC	R0,90$			; SKIP IF ERROR
	MOVZWL	R1,-(SP)		; REFERENCE COUNT
	MOVAL	@SDA$AL_BAK[R6],R1
	GETMEM	(R1),-(SP)		; BACKING STORE ADDRESS
	BLBC	R0,90$			; SKIP IF ERROR
	MOVAL	@SDA$AL_PTE[R6],R1
	GETMEM	(R1),-(SP)		; ADDRESS OF PAGE TABLE ENTRY
	BLBC	R0,90$			; SKIP IF ERROR
	PUSHL	R6			; PFN INDEX
	PFN_DISP_IF_BIGPFN_THEN		; If greater than 32 Mbytes, then use longword format
		PRINT	12,<!XL     !XL   !XL   !5UW    !XL !XL    !XB !AD     !XB !AD>
	PFN_DISP_ELSE			; Otherwise, use word format
		PRINT	12,<!XW     !XL   !XL   !5UW    !XW !XW    !XB !AD     !XB !AD>
	PFN_DISP_ENDIF
90$:	RET

	.DSABL	LSB

	.PAGE
	.SBTTL	DISPLAY_SPT_RANGE -- DISPLAY SYSTEM PAGE TABLE W/RANGE
;---
;
;	DISPLAY_SPT_RANGE
;
;	THIS ROUTINE FORMATS THE ENTIRE CONTENTS OF THE SYSTEM
;	PAGE TABLE, OR ANY SUBRANGE THEREOF.
;
;   INPUTS:
;
;	OPTIONS	= OPTIONS FLAGS (RANGE OR LENGTH BITS RELEVANT)
;	ESP	= START OF PAGE TABLE VA
;		(OR, IF LENGTH BIT SET)
;	ESP	= SIZE OF PAGE TABLE VA
;	ESP+4	= HIGH LIMIT OF PAGE TABLE VA
;
;   OUTPUTS:
;
;	NONE
;
;---

.ENTRY	DISPLAY_SPT_RANGE,^M<R2,R3,R4,R5>

	MOVAB	OPTIONS, R0		; POINT TO OPTIONS WORD
	MOVL	(R0), R2
3$:	MOVL	ESP, R1			; POINT TO EXPRESSION STACK
	BBS	#OPT$V_RANGE, R2, 10$	; RANGE SPECIFIED
	BBS	#OPT$V_LENGTH, R2, 20$	; LENGTH SPECIFIED
5$:	CLRL	R0			; SYNTAX ERROR
	RET

10$:	MOVL	4(R1),R4		; R4 = LOWEST ADDRESS
	SUBL3	R4,(R1),R3		; R3 = SIZE
	BBSS	#OPT$V_LENGTH,(R0),30$	; SET A SINGLE BIT FOR RANGE
	BRB	30$

20$:	MOVQ	(R1),R3			; R4 = LOWEST ADDRESS

30$:	BICW	#^X1FF,R4		; ROUND DOWN
	ADDL2	#^X1FF,R3
	ASHL	#-9,R3,R3		; MAKE NUMBER OF ENTRIES
	BRB	DISP			; JOIN COMMON CODE
	.PAGE
	.SBTTL	DISPLAY_SPT	DISPLAY SYSTEM PAGE TABLE
;---
;
;	DISPLAY_SPT
;
;	THIS ROUTINE FORMATS THE ENTIRE CONTENTS OF THE SYSTEM
;	PAGE TABLE.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---
	.ENABL	LSB

.ENTRY	DISPLAY_SPT,^M<R2,R3,R4,R5>

	BBCC	#OPT$V_LENGTH,OPTIONS,DISP ; CLEAR IT, IF SET BY /ALL
DISP:	CALLS	#0,INIT_PFN		; SETUP TO READ PFN DATA
;
;	DISPLAY THE SYSTEM PAGE TABLE
;
	BBC	#OPT$V_SYSTEM,OPTIONS,10$ ; BRANCH IF NOT SELECTED
	SUBHD	<System page table>
	SKIP	PAGE
	GETMEM	@MMG$GL_SYSPHD		; ADDRESS OF SYSPHD
	BLBS	R0,5$			;Branch if ok...else
	BRW	90$			;...Return
5$:	PUSHL	R1
	MOVAB	BUFFER,R2
	GETMEM	PHD$L_P0BR(R1),(R2),#8  ; GET VIRTUAL SBR,SLR
	BLBS	R0,6$			; OKAY
	BRW	90$			; BRANCH IF ERROR
6$:	PUSHL	(R2)			; STARTING ADDRESS
	MOVL	#^X80000000,R5		; STARTING ADDRESS BEING MAPPED
	BBS	#OPT$V_LENGTH,OPTIONS,7$; IF RANGE NOT SPECIFIED...
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,4(R2),R3  ; #ENTRIES
	MOVL	R5,R4			; STARTING ADDRESS
7$:	SUBL3	R5,R4,R5		; OFFSET INTO AREA
	ASHL	#-7,R5,R5		; TURN INTO NUMBER OF ENTRIES TO SKIP
	ADDL	R5,(SP)			; UPDATE START ENTRY
	MOVQ	R3,-(SP)		; #ENTRIES,START ADDR	
	CALLS	#4,B^DUMP_PTE		; FORMAT PAGE TABLE
	BBCC	#OPT$V_LENGTH,OPTIONS,10$ ; CLEAR IT OUT
;
;	DISPLAY THE GLOBAL PAGE TABLE
;
10$:	BBC	#OPT$V_GLOBAL,OPTIONS,90$ ; BRANCH IF NOT SELECTED
	SUBHD	<Global page table>
	SKIP	PAGE
	GETMEM	@MMG$GL_SYSPHD,-(SP)	; ADDRESS OF PROCESS HEADER
	GETMEM	@MMG$GL_GPTE,R2		; ADDRESS OF FIRST GPTE
	BLBC	R0,90$
	GETMEM	@MMG$GL_MAXGPTE		; ADDRESS OF LAST+1 GPTE
	BLBC	R0,90$
	PUSHL	R2			; STARTING ADDRESS OF PAGE TABLE
	BBS	#OPT$V_LENGTH,OPTIONS,30$ ; IF RANGE NOT SPECIFIED...
	SUBL3	R2,R1,R3		; LENGTH OF PAGE TABLE
	CLRL	R4			; FIRST PAGETABLE ENTRY
30$:	ASHL	#-7,R4,R5		; TURN INTO NUMBER OF ENTRIES TO SKIP
	ADDL	R5,(SP)			; UPDATE START ENTRY
	MOVQ	R3,-(SP)
	CALLS	#4,B^DUMP_PTE		; FORMAT PAGE TABLE
90$:
	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.PAGE
	.SBTTL	DUMP_PTE -- FORMAT THE PAGE TABLE
;---
;
;	DUMP_PTE
;
;	THIS ROUTINE FORMATS AND PRINTS A SPECIFIED PAGE
;	TABLE GIVEN ITS ADDRESS AND LENGTH.  THE ADDRESS
;	OF THE PROCESS HEADER MUST ALSO BE GIVEN TO ACCESS
;	THE WORKING SET LIST.
;
;   INPUTS:
;
;	 4(AP)	= ENTRIES OF PAGE TABLE TO DUMP
;	 8(AP)	= STARTING ADDRESS OF REGION BEING MAPPED
;	12(AP)	= STARTING ADDRESS OF PAGE TABLE
;	16(AP)	= ADDRESS OF PROCESS HEADER
;
;	ASSUMES THAT INIT_PFN HAS ALREADY BEEN CALLED.
;
;   OUTPUTS:
;
;	THE PAGE TABLE IS FORMATTED AND PRINTED.
;
;---

SCRATCH_SIZE 	= 24*4			; 24 LONGWORDS

.ENTRY	DUMP_PTE,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

	.ENABL	LSB

	CALLS	#0,W^PTE_TITLE		; PRINT SUB-HEADING LINE
	MOVAB	W^PTE_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE
	CLRQ	R9			; INITIALIZE STATE TO NORMAL
	TSTL	4(AP)			; CHECK IF ANY TO DUMP
	BGTR	10$			; BRANCH IF SO
	RET
10$:
	MOVAB	-SCRATCH_SIZE(SP),SP	; RESERVE SPACE FOR FAO PARAMS
	MOVL	SP,R2			; R2 USED TO STORE PARAMS
;
;	FORMAT THE PAGE TABLE ENTRY
;
	MOVL	8(AP),(R2)+		; MAPPING ADDRESS
	MOVL	12(AP),(R2)+		; VIRTUAL ADDRESS OF ENTRY
	TRYMEM	@12(AP)			; GET PAGE TABLE ENTRY
	BLBS	R0,20$			; IF ENTRY FOUND
	MOVL	#1,R0
	BSBW	PTE_STATE		; SET STATE = 1 (INVALID MEMORY)
	BRW	80$			; AND SKIP THIS ENTRY
20$:
	MOVL	R1,R3			; SAVE PTE IN R3
	BNEQ	30$			; BRANCH IF NOT NULL PAGE
	MOVL	#2,R0
	BSBW	PTE_STATE		; SET STATE = 2 (NULL PAGES)
	BRW	80$			; AND SKIP THIS ENTRY
30$:
	CLRL	R0
	BSBW	PTE_STATE		; SET STATE TO NORMAL
	
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R3,R8  ; GET PFN IF PRESENT
	MOVL	#5,R4			; TYPE CODE FOR VALID
	MOVL	R3,(R2)+		; STORE PTE IN FAO LIST
	BGEQ	32$			; BRANCH IF NOT VALID
	CMPL	R8,PHYS_PAGES		; CHECK IF LEGAL
	BGEQ	31$			; BRANCH IF INVALID PFN
	CMPL	R8,SDA$GL_MAXPFN	; CHECK IF WITHIN PFN DATABASE
	BGEQ	36$			; BYPASS PFN LOOKUP IF SO
	BRB	40$			; GOOD PFN
31$:
	INCL	R4			; TYPE CODE FOR I/O PAGE
	BRB	36$			; AND INDICATE INVALID PFN
32$:
	EXTZV	#PTE$V_TYP0,#1,R3,R4	; BRING TYP0 AND TYP1
	BBC	#PTE$V_TYP1,R3,34$	; TOGETHER
	BISL	#2,R4			; SET HIGH ORDER BIT
34$:
	TSTL	R4			; 0 = TRANSITION OR DZERO
	BNEQ	36$			; BRANCH IF NOT
	TSTL	R8			; PFN SHOULD BE 0 FOR DZERO
	BNEQ	40$			; BRANCH IF TRANSITION
	MOVL	#4,R4			; TYPE CODE FOR DZERO
36$:
	MNEGL	#1,R8			; INDICATE NO PFN
;
;	R3 = PTE LONGWORD
;	R4 = PTE TYPE CODE
;	R8 = PFN OR -1 IF NONE
;
40$:
	MULL2	#5,R4			; INDEX INTO TYPE TABLE
	MOVL	#5,(R2)+		; LENGTH OF STRING
	MOVAB	TYPE_TABLE[R4],(R2)+	; ADDRESS OF STRING
	CLRQ	R6			; ASSUME MODIFY/LOCK BITS OFF
	BBC	#PTE$V_VALID,R3,45$	; BRANCH IF NOT VALID
	EXTZV	#PTE$V_MODIFY,#1,R3,R7	; GET MODIFY BIT FROM PTE
	BBS	#31,R8,45$		; BRANCH IF NO PFN
	BBS	#31,8(AP),45$		; BRANCH IF SPT
		PFN_REFERENCE	-
	MOVAW	<@SDA$Ax_WSLX[R8],R1>,-	; ADDRESS OF WSLX FIELD
		LONG_OPCODE=MOVAL,-
		IMAGE=SDA
	GETMEM	(R1)			; GET LONGWORD
	BLBC	R0,45$			; IF NOT FOUND
	CVTWL	R1,R1			; EXTEND FIELD
	BEQL	45$			; BRANCH IF NOT A WSL INDEX
	MOVAL	@16(AP)[R1],R1		; ADDRESS OF WSL ENTRY
	GETMEM	(R1)			; GET WSL LONGWORD
	EXTZV	#WSL$V_WSLOCK,#1,R1,R6	; WSL LOCK BIT
45$:
	EXTZV	#PTE$V_PROT,#PTE$S_PROT,R3,R1	; GET PROTECTION CODE
	MOVL	#4,(R2)+		; LENGTH OF STRING
	MOVAL	PROT_TABLE[R1],(R2)+	; PAGE PROTECTION
	MOVL	#1,(R2)+		; SIZE OF MODIFY STRING
	MOVAB	MODIFY_TABLE[R7],(R2)+	; ADDRESS OF STRING
	MOVL	#1,(R2)+		; SIZE OF WSLOCK STRING
	MOVAB	WSLOCK_TABLE[R6],(R2)+	; ADDRESS OF STRING
	EXTZV	#PTE$V_OWN,#PTE$S_OWN,R3,R1  ; GET PAGE OWNER
	MOVL	#1,(R2)+		; LENGTH OF STRING
	MOVAB	OWNER_TABLE[R1],(R2)+	; ADDRESS OF STRING
	BBC	#31,R8,50$		; BRANCH IF PFN VALID
	$FAOL_S PTECTL1,LIST+RAB$W_RSZ,LINE_DESCR,-SCRATCH_SIZE(FP)
	CALLS	#0,PUT_LINE		; OUTPUT LINE
	BRW	80$			; SKIP TO NEXT ENTRY
;
;	FORMAT THE PFN STRUCTURES ASSOCIATED WITH THIS PTE
;
50$:
	MOVAB	@SDA$AB_TYPE[R8],R1
	GETMEM	(R1)
	BLBC	R0,70$			; SKIP IF ERROR
	EXTZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,R1,R1  ; GET PAGE TYPE
	MOVL	#7,(R2)+		; LENGTH OF STRING
	MOVAQ	PAGTYP_TABLE[R1],(R2)+	; ADDRESS OF STRING
	MOVAB	@SDA$AB_STATE[R8],R1
	GETMEM	(R1)
	BLBC	R0,70$			; SKIP IF ERROR
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,R1,R1	; GET PAGE LOCATION
	MOVL	#7,(R2)+		; LENGTH OF STRING
	MOVAQ	LOC_TABLE[R1],(R2)+	; ADDRESS OF STRING
	MOVAB	@SDA$AB_STATE[R8],R1
	GETMEM	(R1)			; GET STATE FIELD
	BLBC	R0,70$			; SKIP IF ERROR
	MOVZBL	R1,(R2)+
	MOVAB	@SDA$AB_TYPE[R8],R1
	GETMEM	(R1)			; GET TYPE FIELD
	BLBS	R0,71$
70$:	BRW	80$			; SKIP IF ERROR
71$:	MOVZBL	R1,(R2)+
	MOVAW	@SDA$AW_REFCNT[R8],R1
	GETMEM	(R1)			; COUNT OF PAGE REFERENCES
	BLBC	R0,70$			; SKIP IF ERROR
	MOVZWL	R1,(R2)+
	MOVAL	@SDA$AL_BAK[R8],R1
	GETMEM	(R1)			; BACKING STORE ADDRESS
	BLBC	R0,70$			; SKIP IF ERROR
	MOVL	R1,(R2)+
	MOVAL	@SDA$AL_PTE[R8],R1
	GETMEM	(R1)			; ADDRESS OF PTE
	BLBC	R0,70$			; SKIP IF ERROR
	MOVL	R1,(R2)+
		PFN_REFERENCE	-
	MOVAW	<@SDA$Ax_FLINK[R8],R1>,-
		LONG_OPCODE=MOVAL,-
		IMAGE=SDA
	GETMEM	(R1)			; FORWARD PAGE LIST LINK
	BLBC	R0,70$			; SKIP IF ERROR
		PFN_REFERENCE	-
	MOVZWL	<R1,(R2)+>,-
		LONG_OPCODE=MOVL,-
		IMAGE=SDA
		PFN_REFERENCE	-
	MOVAW	<@SDA$Ax_BLINK[R8],R1>,-
		LONG_OPCODE=MOVAL,-
		IMAGE=SDA
	GETMEM	(R1)			; BACKWARD PAGE LIST LINK
	BLBC	R0,80$			; SKIP IF ERROR
		PFN_REFERENCE	-
	MOVZWL	<R1,(R2)+>,-
		LONG_OPCODE=MOVL,-
		IMAGE=SDA
					; For larger than 32 Mbytes, use longword format
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=74$
		$FAOL_S PTECTL2_LONG,LIST+RAB$W_RSZ,LINE_DESCR,-SCRATCH_SIZE(FP)
					; Otherwise, use word format
	PFN_DISP_ELSE			ELSE_CODE=74$ , COMMON_CODE=77$
		$FAOL_S PTECTL2_WORD,LIST+RAB$W_RSZ,LINE_DESCR,-SCRATCH_SIZE(FP)
	PFN_DISP_ENDIF		COMMON_CODE=77$
	CALLS	#0,PUT_LINE		; OUTPUT LINE
;
;	SKIP TO NEXT PAGE TABLE ENTRY
;
80$:
	MOVAB	SCRATCH_SIZE(SP),SP	; DEALLOCATE FAO SPACE
	ADDL2	#4,12(AP)		; NEXT PTE
	ADDL2	#512,8(AP)		; INCREMENT MAPPING ADDRESS
	DECL	4(AP)			; DECREMENT REPEAT COUNT
	BLEQ	90$			; EXIT IF DONE
	BRW	10$
90$:
	CLRL	R0
	BSBW	PTE_STATE		; TERMINATE CURRENT STATE
	STATUS	SUCCESS
	RET

	.DSABL	LSB

;
;	SUBROUTINE TO PRINT THE SUB-HEADING LINE
;

	.ENABLE		LOCAL_BLOCK

PTE_TITLE:
	.WORD	0

	SKIP	1
	PFN_DISP_IF_BIGPFN_THEN		; For larger than 32 Mbytes, use longword format
		PRINT	0,-
		<!_ ADDRESS       SVAPTE    PTE     TYPE  PROT  BITS PAGTYP    LOC STATE TYPE  REFCNT   BAK       SVAPTE    FLINK      BLINK>
	PFN_DISP_ELSE			; Otherwise, use word format
		PRINT	0,-
		<!_ ADDRESS       SVAPTE    PTE     TYPE  PROT  BITS PAGTYP    LOC STATE TYPE  REFCNT   BAK       SVAPTE  FLINK  BLINK>
	PFN_DISP_ENDIF
	SKIP	1
	RET

	.DISABLE	LOCAL_BLOCK

	.PAGE
	.SBTTL	PTE_STATE	SET STATE OF PTE DISPLAY
;---
;
;	PTE_STATE
;
;	SET STATE OF RUNNING SCAN OF PAGE TABLE AND PRINT ANY
;	STATUS MESSAGES FROM THE PREVIOUS STATE.
;
;   INPUTS:
;
;	R0  =	REQUESTED NEW STATE
;	R9  =	CURRENT STATE
;	R10 =	REPITITION COUNT IN SAME STATE
;
;   OUTPUTS:
;
;	R9  =	NEW STATE
;	R10 =	UPDATED REPITITION COUNT
;
;---

	.ENABL	LSB

PTE_STATE:
	CMPL	R0,R9			; CHECK IF ALREADY IN STATE
	BNEQ	10$			; BRANCH IF NOT
	INCL	R10			; INCREMENT REPITITION COUNT
	RSB
10$:
	PUSHL	R0			; SAVE NEW STATE
	CMPL	R9,#1			; CHECK IF BYPASSING BAD MEMORY
	BNEQ	20$			; BRANCH IF NOT
	SKIP	1
	PUSHL	R10
	PRINT	1,<!_-------- !UL ENTRIES NOT IN MEMORY>
	SKIP	1
	BRB	80$
20$:
	CMPL	R9,#2			; CHECK IF SKIPPING NULL PAGES
	BNEQ	80$			; BRANCH IF NOT
	SKIP	1
	PUSHL	R10
	PRINT	1,<!_-------- !UL NULL PAGE!%S>
	SKIP	1
80$:
	POPL	R9			; SET NEW STATE
	MOVL	#1,R10			; INITIALIZE REPITITION COUNTER
	RSB

	.DSABL	LSB


	.END
