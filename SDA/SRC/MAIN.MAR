	.TITLE	MAIN	SYSTEM DUMP ANALYZER MAIN PROGRAM
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	THIS PROGRAM ACCEPTS A DUMP FILE FROM A SYSTEM
;	CRASH AND THE SYSTEM SYMBOL TABLE CORRESPONDING
;	TO THE SYSTEM BEING ANALYZED, AND OUTPUTS A
;	LISTING CONTAINING THE FORMATTED SYSTEM DATA
;	STRUCTURES AND MEMORY AT THE TIME OF THE CRASH.
;	THE PROGRAM CAN ALSO BE USED INTERACTIVELY TO
;	INTERROGATE THE SYSTEM DUMP INFORMATION.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V03-001	KTA0093		Kerbey T. Altmann	05-Apr-1982
;		Modifications to allow PAGEFILE.SYS to be a dumpfile.
;		Also use SYS$LP_LINES to calculate page size.
;
;	V008	BLS0122		Benn Schreiber	15-Dec-1981
;		Correct reference to SCREEN_INFO
;
;	V007	MTR0001		Mike Rhodes	22-Jun-1981
;		Allow user to select a directory from which SDA will read
;		the system symbol table SYS.STB .  The user may select a
;		directory of his choice via inclusion of the "/SYMBOLS"
;		qualifier on the DCL ANALYZE command.  The selection algorithm
;		is pretty straight forward...and is included here.
;
;**++**									**++**
;		If ANALYZE was invoked via DCL;
;		Then
;			If /SYMBOLS is present and nonblank;
;			Then
;				Use the value of /SYMBOLS (e.g. directory spec);
;			Else
;				Use a default of SYS$SYSTEM: ;
;			Endif;
;		Else
;			Use the directory that the dump file came from;
;		End;
;**--**									**--**
;
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;
;		Change default addressing to longword.
;
;		Remove references to $SDAMSGDEF macro.
;
;		Remove old Help file FAB and RAB.
;
;	V006	TMH0006		Tim Halvorsen	22-May-1981
;		Do not show "Dump taken on ..." message if
;		analyzing the running system.
;
;	V005	TMH0005		Tim Halvorsen	20-May-1981
;		Add indirect FABs and RABs.  Do not request upcasing
;		from terminal driver, as upcasing will be done by
;		command parser now.  Change version number to 3.0.
;
;	V004	TMH0004		Tim Halvorsen	03-Feb-1981
;		Allow program to be invoked via new ANALZYE/SYSTEM
;		or ANALYZE/CRASH_DUMP DCL commands.
;
;	V003	TMH0003		Tim Halvorsen	23-Sep-1980
;		Change reference to SCR$INFO to SCR$SCREEN_INFO.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$STSDEF			; COMPLETION CODE FIELDS
	$DSCDEF			; DESCRIPTOR DEFINITIONS
	$EMBDEF <CR>		; ERROR LOG DEFINITIONS
	$DMPDEF			; DUMP FILE DEFINITIONS
	$DIBDEF			; DEVICE INFORMATION BUFFER
	$DCDEF			; DEVICE TYPE DEFINITIONS
	$DEVDEF			; DEVICE CHARACTERISTICS
	$JPIDEF			; GETJPI REQUEST DEFINITIONS
	$SHRDEF			; SHARED MESSAGE DEFINITIONS
	$SCRDEF			; SCREEN PACKAGE DEFINITIONS
	$CHFDEF			; CONDITION HANDLING FACILITY DEFINITIONS
	$CLIDEF			; OLD CLI INTERFACE DEFINITIONS

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	STORAGE DEFINITIONS

;
;	READ/WRITE STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT,LONG

VERSION_FLAGS::
	.BLKL	1			; DESCRIBES SYSTEM VERSION

OUTPUT_FILE::
	.BLKQ	1			; OUTPUT FILE NAME DESCRIPTOR

CURRENT_SYSTEM::
	.BLKL	1			; TRUE IF EXAMINING CURRENT SYSTEM

PAGE_NUMBER::
	.BLKL	1			; CURRENT PAGE NUMBER

LINE_COUNT::
	.LONG	0			; LINES FOR CURRENT PAGE

HEADING_LINES:
	.BLKL	1			; LINES USED FOR PAGE HEADING

PROMPT_LINES = 4			; NO. LINES USED FOR PAGE_WAIT

PAGE_SIZE::
	.BLKL	1			; MAX. LINES/PAGE


CURRENT_TIME:				; CURRENT DATE AND TIME
	.LONG	24
	.LONG	TIME_BUFFER
TIME_BUFFER:
	.BLKB	24			; ONLY GET FIRST 24 CHARS


	.PSECT	BUFFERS,NOEXE,WRT

BUFFER::
	.BLKB	512			; BUFFER FOR GENERAL USE

INPUT_BUFFER:
INPUT_BUF_LEN = 80
	.BLKB	INPUT_BUF_LEN

SCR_INFO:
	.BLKB	SCR$C_LENGTH

DUMP_HEADER::
DUMP_HEADER_LEN	== 3*512		; 3 BLOCKS
	.BLKB	DUMP_HEADER_LEN

LINE_DESCR::
	.LONG	LIST_BUFFER_LEN
	.LONG	LIST_BUFFER
LIST_BUFFER:
LIST_BUFFER_LEN	= 132
	.BLKB	LIST_BUFFER_LEN

CMND_DESCR::				; OUTPUT BUFFER DESCRIPTOR
	.LONG	CMND_BUFFER_LEN
	.LONG	CMND_BUFFER
CMND_BUFFER::
CMND_BUFFER_LEN == 80
	.BLKB	CMND_BUFFER_LEN

STB_BUFFER==BUFFER			; OVERLAP MISC. BUFFER
STB_BUFFER_LEN = 512

HELP_BUFFER:
HELP_BUFFER_LEN = 80
	.BLKB	HELP_BUFFER_LEN


	.PSECT	RMSBLOCKS,NOEXE,WRT,LONG

DUMPF::	$FAB	DNM=<SYSDUMP.DMP>,-
		NAM=DUMPN,-		; ADDRESS OF NAM BLOCK
		FAC=<BIO,GET>		; BLOCK I/O

DUMPN:	$NAM	ESA=DUMP_EXPNAME,-	; EXPANDED NAME STRING BUFFER
		ESS=NAM$C_MAXRSS	; LENGTH OF BUFFER

DUMP_EXPNAME:
	.BLKB	NAM$C_MAXRSS		; EXPANDED NAME STRING

DUMPR::	$RAB	FAB=DUMPF, -
		ROP=BIO, -		; BLOCK I/O ACCESS
		BKT=1, -		; BOZO'S BUCKET #1
		UBF=DUMP_HEADER, -	; BUFFER ADDRESS
		USZ=DUMP_HEADER_LEN	; BUFFER LENGTH

SAVDMPF: $FAB	DNM=<.DMP>,-		; DEFAULT NAME STRING
		FOP=SUP,-		; SUPERSEDE OLD VERSION ON CREATE
		FAC=<BIO,PUT>,-		; BLOCK I/O
		RFM=FIX,-		; RECORD FORMAT IS FIXED
		MRS=512			; 512 BYTE RECORDS

SAVDMP:: $RAB	FAB=SAVDMPF,-		; ADDRESS OF FAB BLOCK
		ROP=BIO			; BLOCK I/O ACCESS

LISTF:	$FAB	FAC=<PUT,UPD>, -	; PUT/UPDATE
		DNM=<SYSDUMP.LIS>,-	; DEFAULT NAME STRING
		MRS=133, -		; MAXIMUM RECORD SIZE
		ORG=SEQ, -		; SEQUENTIAL ORGANIZATION
		RAT=CR, -		; CR CARRIAGE CONTROL
		RFM=VAR,-		; FIXED LENGTH RECORDS
		NAM=LISTN		; ADDRESS OF NAM BLOCK

LIST::	$RAB	FAB=LISTF, -
		MBF=2, -		; DOUBLE BUFFERED
		MBC=16, -		; 16 BLOCKS AT A TIME
		RAC=SEQ, -		; SEQUENTIAL ACCESS
		RBF=LIST_BUFFER, -	; BUFFER ADDRESS
		RSZ=0, -		; EMPTY BUFFER
		UBF=LIST_BUFFER, -	; DUMMY READ BUFFER
		USZ=LIST_BUFFER_LEN, -	; BUFFER LENGTH
		ROP=WBH			; WRITE BEHIND (DOUBLE BUFFER)

LISTN:	$NAM	ESS=NAM$C_MAXRSS	; MAXIMUM EXPANDED SIZE

INDFAB:	$FAB	FAC=GET,-		; READ OPERATIONS
		DNM=<.COM>		; DEFAULT NAME STRING

INDRAB:: $RAB	FAB=INDFAB,-		; ADDRESS OF FAB
		UBF=INPUT_BUFFER,-	; ADDRESS OF INPUT BUFFER
		USZ=INPUT_BUF_LEN	; BUFFER LENGTH

INPUTF:	$FAB	FNM=<SYS$INPUT>, -
		FAC=GET, -		; GET OPERATIONS ONLY
		FOP=INP			; STANDARD SYS$INPUT

INPUT::	$RAB	FAB=INPUTF, -
		ROP=PMT, -		; READ WITH PROMPT
		UBF=INPUT_BUFFER, -	; BUFFER FOR INPUT
		USZ=INPUT_BUF_LEN	; BUFFER LENGTH

OUTPUTF: $FAB	FNM=<SYS$OUTPUT>, -
		RAT=CR, -		; EACH LINE NEEDS LF/CR
		FAC=PUT			; PUT OPERATIONS ONLY

OUTPUT:: $RAB	FAB=OUTPUTF, -
		UBF=CMND_BUFFER, -	; OUTPUT BUFFER
		USZ=CMND_BUFFER_LEN	; OUTPUT BUFFER LENGTH

STBF::	$FAB	FNM=<SYS.STB;0>, -
		FAC=GET			; GET OPERATIONS ONLY

STB::	$RAB	FAB=STBF, -
		UBF=STB_BUFFER, -	; BUFFER ADDRESS
		USZ=STB_BUFFER_LEN	; BUFFER LENGTH

	.PSECT	MAIN,EXE,NOWRT,LONG

	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

SYSTEM_ENTITY:
	.ASCID	'SYSTEM'
CRASH_ENTITY:
	.ASCID	'CRASH_DUMP'
DUMPFILE_ENTITY:
	.ASCID	'DUMP_FILE'
SYMBOLS_ENTITY:
	.ASCID	'SYMBOLS'

DEV_PROMPT:
	.ASCIC	<10>'Enter name of dump file > '

SYS$SYSTEM:
	.ASCID	'SYS$SYSTEM:'

STARTUP:
	.ASCII	'STARTUP'		; NAME OF STARTUP PROCESS
STARTUP_LEN = . - STARTUP

	.SBTTL	MAIN PROGRAM
;---
; 	START - MAIN PROGRAM ENTRY POINT
;
;	CALL INITIALIZATION ROUTINES AND FORMAT THE SYSTEM DUMP
;	BY CALLING THE INDIVIDUAL FORMATTING ROUTINES ONE AT A
;	TIME.
;---

	.ENABL	LSB

	.ENTRY	START,^M<R2,R9>

	MOVAB	HANDLER,(FP)		; INITIALIZE CONDITION HANDLER
	CALLS	#0,W^OPEN_FILES		; OPEN INPUT/OUTPUT FILES
	CALLS	#0,MAP_DUMP		; MAP DUMP INTO VIRTUAL MEMORY
	CALLS	#0,READ_SYMBOLS		; READ SYSTEM SYMBOL TABLE
	CALLS	#0,GET_DUMP_INFO	; GET DUMP FILE INFORMATION
	CALLS	#0,W^EXIT_IF_OLD	; IF OLD DUMP AT STARTUP TIME

	SKIP	PAGE			; ERASE SCREEN
	BLBC	CURRENT_SYSTEM,3$	; BRANCH IF ANALYZING A DUMP
	PRINT	0,<VAX/VMS System analyzer>
;	PUSHL	#0
;	PRINT	1,<!17%D>
	BRB	8$

3$:	PRINT	0,<VAX/VMS System dump analyzer>
	PRINT	0,< >
	MOVL	ERLPTR,R9		; ADDRESS OF ERROR LOG ENTRY
	$ASCTIM_S TIMADR=EMB$Q_CR_TIME(R9),TIMBUF=CURRENT_TIME
	PUSHAQ	CURRENT_TIME
	PRINT	1,<Dump taken on !AS>
	ASHL	#-3,EMB$L_CR_CODE(R9),R0	; MESSAGE NUMBER
	BEQL	8$			; BRANCH IF NO MESSAGE
	MOVAB	BUG$T_MESSAGES,R1	; ADDRESS OF MESSAGES
5$:
	MOVZBL	(R1)+,R2		; LENGTH OF MESSAGE
	ADDL2	R2,R1			; SKIP TO NEXT MESSAGE
	SOBGTR	R0,5$			; LOOP UNTIL FOUND
	PUSHL	R1			; ADDRESS OF BUGCHECK MESSAGE
	PRINT	1,<!AC>
8$:
	PRINT	0,<>			; BLANK LINE
;
;	SET CURRENT PROCESS = PROCESS THAT CRASHED
;
	CALLS	#0,CURPROC		; SET TO CURRENT PROCESS

;
;	ACCEPT COMMANDS UNTIL END OF FILE
;
10$:
	CLRL	LINE_COUNT		; AVOID END OF PAGE PROMPTS
	CALLS	#0,GET_COMMANDS		; ACCEPT AND EXECUTE COMMANDS
	CMPL	R0,#MSG$_EOF		; CHECK IF END OF FILE
	BEQL	50$			; BRANCH IF SO
	CMPL	R0,#MSG$_EXITCMD	; DID WE JUST EXIT A LEVEL?
	BNEQ	10$			; BRANCH IF NOT
	CLRQ	SUB_HEADING		; CLEAR CURRENT HEADING
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	SKIP	PAGE			; ERASE PREVIOUS JUNK
	BRB	10$
50$:
	TSTL	OUTPUT_FILE		; OUTPUT FILE SPECIFIED?
	BEQL	90$			; BRANCH IF NOT
	CALLS	#0,PRINT_INDEX		; PRINT TABLE OF CONTENTS
90$:
	CALLS	#0,MARK_DUMP		; MARK DUMP ANALYZED
	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.SBTTL	OPEN_FILES - OPEN INPUT/OUTPUT FILES
;---
;	OPEN_FILES
;
;	THE FOLLOWING FILES WILL BE OPENED:
;
;	 - SYSTEM DUMP FILE (SYSDUMP.DMP)
;	 - SYSTEM SYMBOL TABLE (SYS.STB)
;	 - COMMAND FILE FOR RUN-TIME OPTIONS
;
;---

	.ENTRY	OPEN_FILES,^M<R2,R3,R4,R5,R6>

	$OPEN	INPUTF			; OPEN INPUT FILE
	SIGNAL	RMS,INPUTF
	$CONNECT INPUT
	SIGNAL	RMS,INPUT

	$CREATE	OUTPUTF			; OPEN OUTPUT FILE
	SIGNAL	RMS,OUTPUTF
	$CONNECT OUTPUT
	SIGNAL	RMS,OUTPUT

	PUSHAB	SCR_INFO		; ADDRESS OF SCREEN INFORMATION
	CALLS	#1,G^SCR$SCREEN_INFO	; GET SCREEN INFO INTO BUFFER
	MOVZWL	SCR_INFO+SCR$W_PAGESIZE,R0	; GET PAGE SIZE
	SUBL3	#PROMPT_LINES,R0,PAGE_SIZE	; SET PAGE SIZE
;
;	If the command line entities SYSTEM or CRASH_DUMP are defined
;	and "present", initialize as "current system" or dump file
;	respectively.
;
	clrl	r6			;set DCL flag = .FALSE.
	subl	#cli$c_reqdesc,sp	; Allocate old CLINT request block
	movc5	#0,(sp),#0,#cli$c_reqdesc,(sp) ; Zero request block
	movab	input,r2		; Set address of RAB (after MOVC)
	movb	#cli$k_getcmd,cli$b_rqtype(sp) ; Set "get command" request
	pushl	sp			; Push address of request descriptor
	calls	#1,g^sys$cli		; Call old CLI interface for verb type
	blbc	r0,45$			; Branch if not a DCL command
	cmpb	cli$b_rqstat(sp),#cli$k_verb_fore ; Foreign command?
	beql	45$			; Branch if so
	cmpb	cli$b_rqstat(sp),#cli$k_verb_mcr  ; or MCR command?
	beql	45$			; Branch if so

	pushab	system_entity		; address of entity descriptor
	calls	#1,g^cli$present	; Check if /SYSTEM specified
	blbs	r0,40$			; branch if present
	pushab	crash_entity		; address of entity descriptor
	calls	#1,g^cli$present	; Check if /CRASH_DUMP specified
	blbc	r0,45$			; branch if absent
	pushab	dumpfile_entity		; address of entity descriptor
	calls	#1,g^cli$present	; Check if dump filespec present
	blbc	r0,45$			; Branch if absent
	clrq	-(sp)			; Recieve buffer descriptor
	movb	#dsc$k_class_d,dsc$b_class(sp) ; Set to dynamic desc.
	pushl	sp			; address of return buffer
	pushab	dumpfile_entity		; address of entity descriptor
	calls	#2,g^cli$get_value	; Get dump filespec from command line
	blbc	r0,45$			; Branch if absent
	movw	(sp),rab$w_rsz(r2)	; set length of filespec
	movl	4(sp),rab$l_rbf(r2)	; set address of filespec
	clrq	-(sp)			; Recieve buffer descriptor
	movb	#dsc$k_class_d,dsc$b_class(sp) ; Set to dynamic desc.
	pushl	sp			; address of return buffer
	pushab	symbols_entity		;address of symbols descriptor
	calls	#2,g^cli$get_value	;Check if /SYMBOLS specified and 
					;   get its value if it was.
	bisb2	#1,r6			;set DCL flag = .TRUE.
	brw	6$			; and open dump/stb files

40$:	brb	4$			; analyze current running system
;
;	Attempt to get file name from foreign command line
;
45$:	MOVAB	DEV_PROMPT,R0
	MOVB	(R0)+,RAB$B_PSZ(R2)	; PROMPT LENGTH
	MOVL	R0,RAB$L_PBF(R2)	; PROMPT STRING
	pushl	r0			; Prompt descriptor
	movzbl	rab$b_psz(r2),-(sp)
	clrq	-(sp)			; Recieve buffer descriptor
	movb	#dsc$k_class_d,dsc$b_class(sp) ; Set to dynamic desc.
	pushab	8(sp)			; Address of prompt desc.
	pushab	4(sp)			; Address of buffer desc.
	calls	#2,G^lib$get_foreign	; Get the command line
	blbc	r0,1$			; branch if any error
	movw	(sp),rab$w_rsz(r2)	; set length of line
	movl	4(sp),rab$l_rbf(r2)	; set address of line
	brb	2$			; Process command line
50$:
	$GET	(R2)			; OBTAIN DUMP DEVICE
2$:
	CLRL	CURRENT_SYSTEM		; PRESET TO NON-CURRENT SYS.
	CMPW	RAB$W_RSZ(R2),#1	; MUST BE EXACTLY 1 CHAR.
	BNEQ	1$			; BRANCH IF NOT
	CMPB	@RAB$L_RBF(R2),#^A'*'	; SEE CURRENT RUNNING SYSTEM?
	BNEQ	1$			; BRANCH IF NOT
4$:	MOVL	#1,CURRENT_SYSTEM	; EXAMINE CURRENT SYSTEM
	MOVAB	STBF,R4			; SETUP R4 FOR STB CODE
	BRW	25$			; OPEN STB FILE
1$:
	CMPL	R0,#RMS$_EOF		; CHECK IF END OF FILE
	BNEQ	5$			; BRANCH IF NOT
	INSV	#STS$K_SEVERE, -	; MUST EXIT IMAGE IF EOF
		#STS$V_SEVERITY,#STS$S_SEVERITY,R0
5$:
	SIGNAL	RMS,(R2)		; CHECK STATUS OF $GET OPERATION
6$:
	MOVAB	DUMPF,R3		; ADDRESS OF FAB
	MOVL	FAB$L_NAM(R3),R5	; ADDRESS OF NAM BLOCK
	MOVL	RAB$L_RBF(R2),FAB$L_FNA(R3)	; SET DEVICE NAME
	CVTWB	RAB$W_RSZ(R2),FAB$B_FNS(R3)
	BNEQ	8$			; BRANCH IF NON-EMPTY STRING
	MOVL	SYS$SYSTEM+4,FAB$L_FNA(R3)	; GET FROM SYS$SYSTEM
	MOVB	SYS$SYSTEM,FAB$B_FNS(R3)
8$:
	$OPEN	(R3)			; ATTEMPT TO OPEN THE FILE
	BLBS	R0,10$
	MOVL	FAB$L_STV(R3),R1	; SECONDARY ERROR CODE
	BRB	15$			; AND OUTPUT ERROR MESSAGE
10$:
	$CONNECT DUMPR
	BLBS	R0,20$			; BRANCH IF SUCCESSFUL
	MOVL	DUMPR+RAB$L_STV,R1
15$:
	PUSHL	NAM$L_ESA(R5)		; DESCRIPTOR OF FILE NAME
	MOVZBL	NAM$B_ESL(R5),-(SP)
	MOVQ	R0,-(SP)		; PUSH RMS ERROR CODES
	PUSHAB	8(SP)			; ADDRESS OF DESCRIPTOR
	PUSHL	#1			; NUMBER OF FAO ARGUMENTS
	PUSHL	#MSG$_OPENIN		; ERROR OPENING INPUT FILE
	TSTB	RAB$B_PSZ(R2)		; ARE WE PROMPTING FOR FILESPEC?
	BEQL	18$			; IF NOT, EXIT PROGRAM ON ANY ERROR
	INSV	#STS$K_WARNING, -	; CHANGE SEVERITY TO WARNING
		#STS$V_SEVERITY,#STS$S_SEVERITY,(SP)
18$:	CALLS	#5,G^LIB$SIGNAL		; OUTPUT ERROR MESSAGE
	ADDL	#8,SP			; REMOVE DESCRIPTOR FROM STACK
	BRW	50$			; ALLOW USER TO TRY AGAIN

20$:
	MOVAB	STBF,R4
	BLBC	R6,22$			;INVOKED VIA DCL?
	TSTW	(SP)			;WAS /SYMBOLS NONBLANK?
	BEQL	25$			;NO, SO USE SYS$SYSTEM:
	MOVB	FAB$B_FNS(R4),FAB$B_DNS(R4) ;MAKE "SYS.STB;0" THE DEFAULT FILE
	MOVL	FAB$L_FNA(R4),FAB$L_DNA(R4)
	MOVL	4(SP),FAB$L_FNA(R4)	;USER SUPPLIED DIRECTORY SPEC
	MOVB	(SP),FAB$B_FNS(R4)	;  TAKEN FROM THE /SYMBOLS QUAL.
	BRW	28$			;ATTEMPT TO OPEN THE FILE
22$:
	MOVL	NAM$L_ESA(R5),FAB$L_DNA(R4)  ; SET DEFAULT FROM DUMP
	MOVB	NAM$B_ESL(R5),FAB$B_DNS(R4)
	$OPEN	(R4)			; OPEN THE STB FILE
	CMPL	R0,#RMS$_FNF		; CHECK IF STB FILE THERE
	BNEQ	30$			; BRANCH IF OK
25$:	MOVL	SYS$SYSTEM+4,FAB$L_DNA(R4)	; SET TO TRY SYS$SYSTEM
	MOVB	SYS$SYSTEM,FAB$B_DNS(R4)

28$:	$OPEN	(R4)			; OPEN THE STB FILE
30$:	BLBS	R0,35$			; BRANCH IF SUCCESSFUL
	PUSHL	FAB$L_FNA(R4)		; DESCRIPTOR OF FILE NAME
	MOVZBL	FAB$B_FNS(R4),-(SP)
	PUSHL	FAB$L_STV(R4)		; PUSH RMS SECONDARY STATUS
	PUSHL	R0			; PUSH RMS PRIMARY STATUS
	PUSHAB	8(SP)			; ADDRESS OF DESCRIPTOR
	PUSHL	#1			; NUMBER OF FAO ARGUMENTS
	PUSHL	#MSG$_OPENIN		; ERROR OPENING INPUT FILE
	CALLS	#5,G^LIB$SIGNAL		; OUTPUT ERROR MESSAGE
	ADDL	#8,SP			; REMOVE DESCRIPTOR FROM STACK

35$:	$CONNECT STB
	SIGNAL	RMS,STB

	RET

	.SBTTL	EXIT_IF_OLD - EXIT IF OLD DUMP AT STARTUP TIME
;---
;
;	THIS ROUTINE WILL EXIT THE PROGRAM IF WE ARE CALLED
;	FROM STARTUP.COM AT BOOT TIME AND IF THE DUMP HAS
;	ALREADY BEEN ANALYZED.  OPERATOR SHUTDOWN CRASHES
;	ARE ALSO IGNORED AS THEY DO NOT CONSTITUTE A REAL
;	CRASH.
;
;   INPUTS:
;
;	DUMP_HEADER CONTAINS THE DUMP HEADER BLOCKS
;	ERLPTR CONTAINS A POINTER TO THE ERROR LOG ENTRY
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	EXIT_IF_OLD,^M<R2>

;
;	CHECK IF WE ARE IN SYSTEM STARTUP PROCEDURE
;

	ALLOC	15,R2			; ALLOCATE 15 BYTE BUFFER
	CLRL	-(SP)			; CREATE GETJPI REQUEST LIST
	PUSHL	R2			; ADDRESS TO RECEIVE LENGTH
	PUSHL	4(R2)			; ADDRESS OF OUTPUT BUFFER
	PUSHL	#<JPI$_PRCNAM@16>!15	; REQUEST CODE AND BUFLTH
	MOVL	SP,R1
	$GETJPI_S ITMLST=(R1)		; GET NAME OF THIS PROCESS
	SIGNAL
	CMPC5	(R2),@4(R2),#^A' ',#STARTUP_LEN,STARTUP
	BNEQ	90$			; BRANCH IF NOT STARTUP TIME

;
;	EXIT IF DUMP HAS ALREADY BEEN ANALYZED OR IS EMPTY
;
	BITW	#<<1@DMP$V_OLDDUMP> ! <1@DMP$V_EMPTY>>,-
		 DUMP_HEADER+DMP$L_FLAGS
	BNEQ	20$

;
;	... OR IF OPERATOR SHUTDOWN
;
	MOVL	ERLPTR,R1		; ADDRESS OF ERROR LOG ENTRY
	BICL3	#7,EMB$L_CR_CODE(R1),R1	; GET BUGCHECK CODE OF CRASH
	CMPL	R1,#BUG$_OPERATOR	; CHECK IF OPERATOR SHUTDOWN
	BNEQ	90$			; BRANCH IF NOT
;
;	EXIT THE IMAGE - FLUSH THE REMAINING INPUT COMMANDS
;
20$:
	BBS	#DEV$V_TRM,INPUTF+FAB$L_DEV,40$	; SKIP IF TERMINAL
30$:
	$GET	INPUT			; FLUSH THE INPUT STREAM
	BLBS	R0,30$			; CONTINUE UNTIL ALL DATA READ
40$:
	$EXIT_S				; EXIT THE IMAGE
90$:
	STATUS	SUCCESS
	RET

	.SBTTL	PAGE_WAIT - GIVE END-OF-PAGE PROMPT ON SCREEN
;---
;
;	PAGE_WAIT
;
;	THIS ROUTINE CAUSES AN END-OF-PAGE PROMPT TO BE GIVEN
;	ON THE BOTTOM OF THE SCREEN.  IF THE USER SIMPLY HITS
;	RETURN, HE WILL CONTINUE OUT OF THIS ROUTINE TO PRINT
;	THE NEXT PAGE.  IF HE ENTERS SOME OTHER COMMAND, THE
;	CURRENT COMMAND WILL BE ABORTED.
;
; INPUTS:
;
;	IF LINE_COUNT = 0, NO PROMPT WILL BE ISSUED.
;
;---

	.ENABL	LSB

	.ENTRY	PAGE_WAIT,^M<>

	TSTL	OUTPUT_FILE		; CHECK IF ANY OUTPUT FILE
	BNEQ	5$			; SKIP IF LISTING FILE
	BBC	#SCR$V_SCREEN,SCR_INFO+SCR$L_FLAGS,5$ ; SKIP SCROLLING
	TSTL	LINE_COUNT		; 0 FORCES NO PROMPT
	BNEQ	10$			; BRANCH IF PROMPT WANTED
5$:	RET
10$:
	CLRL	LINE_COUNT		; CLEAR BEFORE ANYTHING ELSE
	SKIP	3			; MOVE UP IF SCROLLING
	PUSHL	#1			; COLUMN 1
	MOVZWL	SCR_INFO+SCR$W_PAGESIZE,R0	; GET PAGE SIZE
	SUBL3	#3,R0,-(SP)		; 3RD FROM BOTTOM LINE
	CALLS	#2,G^SCR$SET_CURSOR	; SET CURSOR POSITION
	PRINT	0,<    Press RETURN for more.>
12$:
	CALLS	#0,GET_COMMANDS		; PROMPT FOR COMMAND
	BLBC	R0,14$			; BRANCH IF EMPTY LINE
13$:
	SIGNAL	0,BACKUP		; SILENTLY ABORT COMMAND
14$:
	CMPL	R0,#MSG$_BACKUP		; ARE WE BACKING UP?
	BEQL	13$			; CONTINUE BACK TO MAIN LEVEL
	CMPL	R0,#MSG$_EOF		; CHECK IF END OF FILE (EXIT)
	BEQL	15$			; BRANCH IF SO
	CMPL	R0,#MSG$_EXITCMD	; ARE WE EXITING COMMAND?
	BEQL	15$			; BRANCH IF SO
	RET
15$:
	SIGNAL	0,EXITCMD		; EXIT AND ERASE SCREEN

	.SBTTL	NEW_PAGE - BEGIN A NEW PAGE ON THE LISTING
;---
;
;	NEW_PAGE
;
;	THIS ROUTINE WILL CAUSE A NEW PAGE TO BE WRITTEN AND
;	WILL OUTPUT THE PAGE HEADING AND CURRENT SUB-HEADING.
;
;   INPUTS:
;
;	PAGE_NUMBER = CURRENT PAGE NUMBER
;
;   OUTPUTS:
;
;	PAGE_NUMBER IS UPDATED
;	LINE_COUNT IS INITIALIZED
;
;---

	.ENABL	LSB

	.ENTRY	NEW_PAGE,^M<>

	TSTL	SUB_HEADING		; ANY SUB-HEADING?
	BEQL	10$			; SKIP CHECK IF NOT
	CMPL	LINE_COUNT,HEADING_LINES ; ANY NEW LINES BESIDES TITLE?
	BEQL	90$			; IF NOT, SKIP PAGE EJECT
10$:
	CALLS	#0,PAGE_WAIT		; GIVE BOTTOM OF PAGE PROMPT
	CLRL	LINE_COUNT		; CLEAR BEFORE ANYTHING ELSE
	INCL	PAGE_NUMBER		; INCREMENT PAGE NUMBER
	TSTL	OUTPUT_FILE		; CHECK IF LISTING FILE
	BEQL	50$			; NO HEADINGS IF NOT
	PRINT	0,<!^>			; PRINT FORM FEED
	PUSHL	PAGE_NUMBER
	PUSHAQ	CURRENT_TIME
	PRINT	2,<VAX/VMS 3.0 -- System Dump Analysis!_!_!_!_!_!AS!_!_!_Page !UL>
	PUSHAQ	SUB_HEADING		; SECTION HEADING
	PRINT	1,<!AS>
	SKIP	3			; 3 BLANK LINES
60$:
	TSTL	HEADING_ROUTINE		; ANY HEADING ROUTINE?
	BEQL	90$			; BRANCH IF NOT
	CALLS	#0,@HEADING_ROUTINE	; CALL THE ROUTINE
90$:
	MOVL	LINE_COUNT,HEADING_LINES ; REMEMBER # HEADING LINES
	RET
50$:
;	SKIP SUB-HEADING IF NOT SCREEN ORIENTED DEVICE
	BBC	#SCR$V_SCREEN,SCR_INFO+SCR$L_FLAGS,90$
	PUSHL	#1			; FROM COLUMN 1
	PUSHL	#1			; LINE 1
	CALLS	#2,G^SCR$ERASE_PAGE	; ERASE ENTIRE SCREEN
	PUSHAQ	SUB_HEADING		; SECTION HEADING
	PRINT	1,<!AS>
	PUSHL	SUB_HEADING		; CHARACTERS IN HEADING
	PRINT	1,<!#*->
	BRB	60$

	.DSABL	LSB

	.PAGE
	.SBTTL	PRINT -- FORMAT AND PRINT A SINGLE LINE
;---
;
;	PRINT
;
;	THIS ROUTINE IS INVOKED FROM THE PRINT MACRO TO FORMAT
;	AND PRINT A SINGLE LINE.
;
;   INPUTS:
;
;	 4(AP) = ADDRESS OF CONTROL STRING
;	 8(AP) = FAO PARAMETERS (AS MANY AS NEEDED)
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	PRINT,^M<>

	PUSHAL	8(AP)			; ADDRESS OF PARAMETER LIST
	PUSHAQ	LINE_DESCR		; BUFFER DESCRIPTOR
	PUSHAL	LIST+RAB$W_RSZ		; TO RECEIVE LENGTH OF LINE
	PUSHL	4(AP)			; ADDRESS OF CONTROL STRING
	CALLS	#4,G^SYS$FAOL		; FORMAT LINE
	CALLS	#0,B^PUT_LINE		; OUTPUT LINE
	RET

	.PAGE
	.SBTTL	PUT_LINE - OUTPUT A LINE TO THE LISTING FILE
;---
;
;	PUT_LINE
;
;	THIS ROUTINE OUTPUTS A SINGLE PRINT LINE TO THE LISTING
;	FILE.  THE NUMBER OF LINES ON THE PAGE IS ACCOUNTED FOR
;	AND A NEW PAGE WILL BE ISSUED WHEN THE PAGE IS FULL.
;
;   INPUTS:
;
;	LINE_COUNT	= NUMBER OF LINES ON CURRENT PAGE
;
;   OUTPUTS:
;
;	LINE_COUNT IS UPDATED
;
;---

	.ENABL	LSB

	.ENTRY	PUT_LINE,^M<R2,R3,R4,R5,R6,R7,R8>

	MOVAL	LINE_COUNT,R6		; ADDRESS OF LINE COUNT
	MOVAL	LIST,R8			; ADDRESS OF LIST RAB
	CLRL	R7			; R7=0 IF TERMINAL OUTPUT
	TSTL	OUTPUT_FILE		; OUTPUT FILE SPECIFIED?
	BEQL	10$			; BRANCH IF NOT
	MOVL	#1,R7			; R7=1 IF LISTING OUTPUT
10$:
	INCL	(R6)			; ASSUME 1 LINE PRINTED
	BLBS	R7,5$			; BRANCH IF LISTING FILE
	CMPW	RAB$W_RSZ(R8),SCR_INFO+SCR$W_WIDTH
					; CHECK IF OVER SIZE OF SCREEN
	BLEQU	5$			; BRANCH IF OK
	INCL	(R6)			; ACCOUNT FOR 2 LINES
5$:
	CMPL	(R6),PAGE_SIZE
	BLEQ	20$			; BRANCH IF STILL ROOM
	TSTL	PAGE_SIZE		; CHECK IF VALID PAGE SIZE
	BLEQ	20$			; BRANCH IF NO PAGE SIZE (FILE)
	MOVW	RAB$W_RSZ(R8),-(SP)	; SAVE LINE LENGTH
	SUBL2	#LIST_BUFFER_LEN,SP	; ALLOCATE SPACE FOR LINE
	MOVC3	#LIST_BUFFER_LEN,LIST_BUFFER,(SP)  ; SAVE LINE
	SKIP	PAGE
	MOVC3	#LIST_BUFFER_LEN,(SP),LIST_BUFFER  ; RESTORE LINE
	ADDL2	#LIST_BUFFER_LEN,SP	; DEALLOCATE SPACE
	MOVW	(SP)+,RAB$W_RSZ(R8)	; RESTORE LINE LENGTH
	BRW	10$			; TRY AGAIN
20$:
	BLBS	R7,50$			; BRANCH IF LISTING FILE
	MOVAB	OUTPUT,R2
	MOVW	RAB$W_RSZ(R8),RAB$W_RSZ(R2)
	MOVL	LINE_DESCR+4,RAB$L_RBF(R2)
	$PUT	(R2)			; OUTPUT TO TERMINAL
	SIGNAL	RMS,(R2)
	RET
50$:
	$PUT	(R8)			; OUTPUT RECORD TO THE FILE
	SIGNAL	RMS,(R8)
	MOVC5	#0,(SP),#^A' ',#LIST_BUFFER_LEN,LIST_BUFFER
	CLRW	RAB$W_RSZ(R8)		; RESET TO EMPTY LINE
	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.PAGE
	.SBTTL	SKIP_LINES - SKIP ANY NUMBER OF BLANK LINES
;---
;
;	SKIP_LINES
;
;	THIS ROUTINE WILL OUTPUT A SPECIFIED NUMBER OF BLANK
;	LINES TO THE LISTING FILE.
;
;   INPUTS:
;
;	4(AP)	= THE NUMBER OF LINES TO SKIP
;
;   OUTPUTS:
;
;	THE BLANK LINES ARE OUTPUT
;
;---

	.ENTRY	SKIP_LINES,^M<>

	TSTL	4(AP)			; CHECK IF ALREADY DONE
	BEQL	90$
10$:
	CLRW	LIST+RAB$W_RSZ		; EMPTY LINE
	CALLS	#0,PUT_LINE		; OUTPUT A BLANK LINE
	SOBGTR	4(AP),10$
90$:
	RET

	.PAGE
	.SBTTL	OPEN_OUTPUT -- OPEN THE OUTPUT LISTING FILE
;---
;
;	OPEN_OUTPUT
;
;	OPEN THE OUTPUT LISTING FILE AND SETUP TO
;	BEGIN LISTING OUTPUT.
;
;   INPUTS:
;
;	OUTPUT_FILE = DESCRIPTOR OF FILE NAME
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	OPEN_OUTPUT,^M<R2,R3,R4,R5,R6>

	MOVAB	LIST,R3			; ADDRESS THE RAB
	MOVL	RAB$L_FAB(R3),R2	; ADDRESS THE FAB
	MOVL	FAB$L_NAM(R2),R4	; ADDRESS THE NAM BLOCK
;
;	CLOSE THE PREVIOUS LISTING FILE, IF ANY
;
	TSTB	FAB$B_FNS(R2)		; WAS FILE ALREADY OPEN?
	BEQL	20$			; BRANCH IF NOT
	CALLS	#0,PRINT_INDEX		; PRINT TABLE OF CONTENTS
	$CLOSE	(R2)			; CLOSE LISTING FILE
	SIGNAL	RMS,(R2)
;
;	DETERMINE IF PARAMETER GIVEN IS A TERMINAL OR LISTING DEVICE
;
20$:	MOVB	OUTPUT_FILE,FAB$B_FNS(R2)	; SET FILE NAME
	MOVL	OUTPUT_FILE+4,FAB$L_FNA(R2)
	ALLOC	NAM$C_MAXRSS,R5		; ALLOCATE STRING BUFFER
	MOVL	4(R5),NAM$L_ESA(R4)	; SET ADDRESS OF BUFFER
	$PARSE	(R2)			; GET EXPANDED FILE NAME
	SIGNAL	RMS,(R2)
	MOVZBL	NAM$B_ESL(R4),(R5)	; SET LENGTH OF STRING
	ALLOC	DIB$C_LENGTH,R6		; ALLOCATE GETDEV BUFFER
	$GETDEV_S DEVNAM=(R5),PRIBUF=(R6)
	SIGNAL
	MOVL	4(R6),R1		; ADDRESS THE BUFFER
	CMPB	DIB$B_DEVCLASS(R1),#DC$_TERM	; TERMINAL?
	BEQL	50$			; BRANCH IF SO
;
;	OPEN LISTING FILE AND SET PAGE SIZES
;
	$CREATE	(R2)			; OPEN LISTING FILE
	SIGNAL	RMS,(R2)
	$CONNECT (R3)			; CONNECT TO OUTPUT STREAM
	SIGNAL	RMS,(R3)
	CALLS	#0,G^LIB$LP_LINES	; FIND THE CURRENT PAGE SIZE
	SUBL3	#6,R0,PAGE_SIZE		; INITIALIZE PAGE SIZE
	CLRL	PAGE_NUMBER		; START AT PAGE 1
	CLRL	LINE_COUNT		; NEW PAGE
	$ASCTIM_S TIMBUF=CURRENT_TIME	; GET CURRENT DATE/TIME
	CALLS	#0,DUMMY_INDEX		; PRINT DUMMY TABLE OF CONTENTS
	RET
;
;	OPEN TERMINAL FOR OUTPUT AND SET PAGE SIZES
;
50$:	CLRL	OUTPUT_FILE		; SIGNAL TO USE TERMINAL
	CLRB	FAB$B_FNS(R2)		; MARK NO LISTING FILE OPEN
	MOVZBL	DIB$L_DEVDEPEND+3(R1),R0	; GET PAGE SIZE
	SUBL3	#PROMPT_LINES,R0,PAGE_SIZE	; SET PAGE SIZE
	CLRL	LINE_COUNT		; NEW PAGE
	MOVL	#1,R0			; SUCCESS
	RET


	.END	START
