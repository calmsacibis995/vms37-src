	.TITLE	RMS	Display RMS Data Structures
	.SBTTL	Copyright Notice
	.IDENT	'V03-003'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	Program Description
;++
;   Facility
;
;	System Dump Analyzer
;
;   Abstract
;
;	This module contains code to dump most internal (and some user)
;	RMS data structures. 
;
;   Environment
;
;	Native mode, User mode
;
;   Author
;
;	K. E. Kinnear	September 1980 - July 1981
;
;   Modified by
;
;	V03-003	MLJ0084		Martin L. Jack		30-Mar-1982
;		Fix reference to IFB$B_KBUFSZ.
;
;	V03-002	KEK0027		K. E. Kinnear		1-Mar-1982
;		Add error messages for no RMS structures and premature
;		termination of the structure dump.  Also update IRAB,
;		GBD, and GBPB to RMSINTSTR V02-085.
;
;	V03-001	KEK0022		K. E. Kinnear		3-Feb-1982
;		Correct buffer reporting in GBD summary.
;
;	V3A Source Merge
;
;	V03-010 KEK0017		K. E. Kinnear		6-Jan-1982
;		Add FWA, GBH, and GBD summary dump routines.
;
;	V03-009 KEK0016		K. E. Kinnear		17-Dec-1981
;		Improve tracing code for global buffer debug.
;
;	V03-008 KEK0015		K. E. Kinnear 		11-Dec-1981
;		Remove READAHEAD flags from cache and BLB flags.
;
;	V03-007	KEK0013		K. E. Kinnear		23-Oct-1981
;		New BLB flags, make AVLCL show for all orgs, and FRBPTR
;		for rel and indexed orgs.
;
;	V03-006	KEK0012		K. E. Kinnear		9-Sep-1981
;		Add trace support and initialization so that it
;		fails quietly on no-P1 space processes.
;
;	V03-005	KEK0011		K. E. Kinnear		2-Sep-1981
;		Fix references to $BCBDEF which has gone away.
;		Remove references to RLS$V_KEEP_ACC which has also
;		gone away.
;		Fix sequential problem in SHOW_BLB_SUM.
;
;	V03-004 KEK0010		K. E. Kinnear		26-Aug-1981
;		React to changes to internal RMS structures for
;		global buffering.  Support for BLB, and changes to
;		IFAB and IRAB.  Preliminary support for GBD, GBH, and
;		TRC structures.
;
;	V03-003	KEK0009		K. E. Kinnear		15-Aug-1981
;		Update for changes in IFB, IRB, IDX for prolog 3
;		files.
;
;	V03-002	KEK0005		K. E. Kinnear		1-Aug-1981
;		React to changing RMS structures.  RFA_ID in
;		IRAB went from a word to a byte.
;--

	.PAGE
	.SBTTL	Declarations
;
;	Symbol Defintions
;

	$CHFDEF			; Condition Handling Definitions
	$OPTDEF			; Parsing options
	$TPADEF			; TPARSE definitions

;
;	RMS and SYSTEM definitions
;

	$ASBDEF					; Asynchronous context block
	$BDBDEF					; Buffer descriptor block
	$BLBDEF					; Bucket lock block
	$CCBDEF					; Channel control block
	$CSHDEF					; Cache control bits
	$DCDEF					; Device class and type defns
	$DDBDEF					; Device data block def
	$DEVDEF					; Device characteristic bits
	$DRCDEF					; Directory cache definitions
	$DYNDEF					; System control block idents
	$FABDEF					; File access block
	$FCBDEF					; File control block
	$FRBDEF					; File resource block
	$FWADEF					; File string work area
	$GBDDEF					; Global buffer discriptor
	$GBHDEF					; Global buffer header
	$GBPBDEF				; Global buffer param block
	$IDXDEF					; Index Descriptor definitions
	$IFBDEF					; Internal FAB definitions
	$IMPDEF					; Process I/O control area
	$IRBDEF					; Internal RAB definitions
	$NAMDEF					; Name access block
	$PLGDEF					; Prologue (VBN 1) of indexed file
	$RABDEF					; Record access block
	$RLBDEF					; Record lock block
	$RLSDEF					; Release bit definitions
	$RMSDEF					; RMS message definitions
	$SFDDEF					; Shared file descriptor block
	$SIFBDEF 				; Shared IFAB definitions
	$TRCDEF					; Trace block definition
	$UCBDEF					; Unit control block defns
	$WCBDEF					; Window control block
	$XABDEF					; Extended access blocks
	$XABFHCDEF				; XAB - file header
	$XABALLDEF				; XAB - allocation
	$XABDATDEF				; XAB - date/time
	$XABRDTDEF				; XAB - revision date/time
	$XABPRODEF				; XAB - protection
	$XABTRMDEF				; XAB - terminal
	$XABSUMDEF				; XAB - indexed summary
	$XABKEYDEF				; XAB - indexed keys

	.PAGE
	.SBTTL	Macro Definitions
;
;	Macro Definitions
;

;
; GET -- Get a particular control block in memory.
;

	.MACRO	GET	BLOCK,ADDR,ERRADDR,BUFFER,?LAB,?LAB1

	.IF NB	ADDR
	MOVAL	ADDR,BLOCK-4
	BNEQ	LAB1
	BRW	ERRADDR
LAB1:
	.ENDC

	.IF NB	BUFFER
	PUSHAL	BUFFER
	.IFF
	PUSHAL	BLOCK
	.ENDC

	CALLS	#1,GET_'BLOCK
	BLBS	R0,LAB
	CLRL	BLOCK-4
	BRW	ERRADDR
LAB:

	.IF NB	BUFFER
	MOVAB	BUFFER,R2
	.IFF
	MOVAB	BLOCK,R2
	.ENDC

	.ENDM

;
; SHOW -- Format a control block on the output file.
;

	.MACRO	SHOW	BLOCK,BUFFER

	.IF NB	BUFFER
	PUSHAL	BUFFER
	.IFF
	PUSHAL	BLOCK
	.ENDC

	CALLS	#1,SHOW_'BLOCK

	.ENDM

;
; TABLE Macro which subtracts a number from symbol values for
; bits whose values are all over 32.
;

	.MACRO	TABLEM	N,PREFIX,VALUES
	.IRP	VALUE,VALUES
	.SAVE
	.PSECT	__RMSLIT,EXE,NOWRT
$$$	=	.
	.ASCIC	\VALUE\
	.RESTORE
	.LONG	'PREFIX''VALUE'-<N>
	.LONG	$$$
	.ENDR
	.LONG	-1,-1
	.ENDM	TABLEM

;
; CASETBL macro, builds lists of information which
; is indexed by specific values.
;

	.MACRO	CASETBL	VALUES
	.IRP	VALUE,VALUES
	.SAVE
	.PSECT	__RMSLIT,EXE,NOWRT
$$$	=	.
	.ASCIC	\VALUE\
	.RESTORE
	.LONG	$$$
	.ENDR
	.ENDM	CASETBL

;
; Macro to push and adjust a descriptor for an !AF FAO parameter.
;

	.MACRO	PUSHD2	VALUE,ADDRESS
	PUSHL	ADDRESS+4(R3)
	ADDL2	VALUE,(SP)
	PUSHL	ADDRESS(R3)
	.ENDM

;
; Macro to print the two longwords of a descriptor.
;

	.MACRO	PRINTD	BLOCK,NAME
	PUSHL	BLOCK''NAME'+4(R3)
	PUSHL	BLOCK''NAME'(R3)
	.IF LESS_THAN 6-%LENGTH(NAME)
	PRINT	2,<-
NAME':	!XL		-
		!XL>
	.IFF
	PRINT	2,<-
NAME':		!XL		-
		!XL>
	.ENDC
	.ENDM

;
; Macro to print the two longwords of a descriptor and print out
; the string pointed to by the descriptor.
;
; MUST BE USED WITHIN LOCAL SYMBOL BLOCK!
;
; ONLY FOR USE IN SHOW_FWA!
;
; REQUIRES R5 TO BE OFFSET FOR FWA DESCRIPTORS!
;

	.MACRO	DUMPDF	NAME,?X
	PRINTD	FWA$Q_,NAME
	TSTL	FWA$Q_'NAME'(R3)
	BEQL	X
	MOVAL	FWA$Q_'NAME'(R3),R2
	CALLS	#0,FWADD
X:
	.ENDM


;
; Macro to translate bits for fields at the beginning of the FWA
;

	.MACRO	FWABITS	TAG
	MOVL	#ALLOCSZ,(SP)
	MOVZBL	FWA$B_'TAG'FLGS(R3),-(SP)
	PUSHAB	TAG'_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	FWA$B_'TAG'FLGS(R3),-(SP)
	PRINT	2,<-
TAG'FLGS:	!XB	!AS>
	.ENDM



	.PAGE
	.SBTTL	Storage Definitions
;
; Storage Definitions
;

	.PSECT	SDADATA,NOEXE,WRT

;
; /DISPLAY Options
;

RMS_DIS_OPT::.LONG OPT$M_RMSALL		; master options word
RMS_IFI::.WORD	0			; contains IFI value (0=all)

;
; "real" options for main routine: SHOW_RMS1
;

RMS_DIS_OPT1:.LONG 0			; dynamic options word
RMS_IFI1:.WORD	0			; dynamic ifi word

;
; Temporary options work area
;

RMS_DIS_TMP::.LONG 0			; holds options from TPARSE !DISPLAY
RMS_IFI_TMP::.WORD 0			; holds IFI value from TPARSE !DISPLAY
RMS_DIS_TMP1::.LONG 0			; work area for !DISPLAY

;
; General Temporary Data Storage
;

IFI:	.WORD	0			; Current IFI on which we are working
IFBS:	.WORD	0			; number of ifabs seen this run

;
; Buffer areas into which are read the various control blocks from the dump.
;
;	All are in the format:
;
;		.LONG	0
;	LABEL:	.BLKB	length of structure
;
;	where the longword prior to the label contains the virtual address
;	of this control block in the actual dump, or 0 if block doesn't
;	exist or couldn't be read.
; 

IFABTBL:.BLKL	IMP$C_ENTPERSEG+1
	.LONG	0
IFAB:	.BLKB	IFB$C_BLN
	.LONG	0
IRAB:	.BLKB	IRB$C_BLN_IDX
	.LONG	0
BDB:	.BLKB	BDB$C_BLN
	.LONG	0
FWA:	.BLKB	FWA$C_BLN
	.LONG	0
FAB:	.BLKB	FAB$C_BLN
	.LONG	0
RAB:	.BLKB	RAB$C_BLN
	.LONG	0
NAM:	.BLKB	NAM$C_BLN
	.LONG 	0
CCB:	.BLKB	CCB$C_LENGTH
	.LONG	0
WCB:	.BLKB	WCB$C_LENGTH+512
WCBEND:
	.LONG	0
FCB:	.BLKB	FCB$C_LENGTH
	.LONG	0
IDX:	.BLKB	IDX$C_FIXED_BLN+32
	.LONG	0
ASB:	.BLKB	ASB$C_BLN_IDX
	.LONG	0
UCB:	.BLKB	UCB$C_LENGTH
	.LONG	0
DDB:	.BLKB	DDB$C_LENGTH
	.LONG	0
RLB:	.BLKB	RLB$C_BLN
	.LONG	0
BLB:	.BLKB	BLB$C_BLN
	.LONG	0
GBD:	.BLKB	GBD$C_BLN
	.LONG	0
GBH:	.BLKB	GBH$C_BLN
	.LONG	0
TRC:	.BLKB	TRC$C_BLN

	.PSECT	RMS,EXE,NOWRT

	.PAGE
	.SBTTL	Read-only Data Definitions

;
;	Read-only Data Definitions
;

DEV_CHR:TABLE	DEV$V_,<ALL,AVL,CCL,DIR,DMT,ELG,FOD,FOR,-
		GEN,IDV,MBX,NET,ODV,RCK,REC,RND,RTM,SDI,-
		SHR,SPL,SQD,SWL,TRM,WCK>

NAM_CHR:TABLE	NAM$V_,<EXP_DEV,EXP_DIR,EXP_NAME,EXP_TYPE,-
		EXP_VER,GRP_MBR,HIGHVER,LOWVER,NODE,PPF,-
		QUOTED,WILDCARD,WILD_DIR,WILD_GRP,WILD_MBR,-
		WILD_NAME,WILD_SFD1,WILD_SFD2,WILD_SFD3,-
		WILD_SFD4,WILD_SFD5,WILD_SFD6,WILD_SFD7,-
		WILD_TYPE,WILD_UFD,WILD_VER>

FAC_CHR:TABLE	FAB$V_,<BIO,BRO,DEL,GET,PUT,TRN,UPD>

RAT_CHR:TABLE	FAB$V_,<BLK,CR,FTN,PRN>

BKP_CHR:TABLEM	32,IFB$V_,<BUSY,EOF,PPF_IMAGE,ASYNC,ASYNCWAIT,ACCESSED,-
		ANSI_D,RWC,DMO,SPL,SCF,DLT,DFW,SQO,PPF_INPUT,NFS,-
		WRTACC,MSE,CREATE,NORECLK,RW_ATTR,TMP,TEF,SIFB_OWND,-
		SEQFIL,SEARCH,RMS_STALL,NWA,DAP_OPEN,DAP,NSP>

IRBBKP_CHR:TABLEM 32,IRB$V_,<BUSY,EOF,PPF_IMAGE,ASYNC,ASYNCWAIT,FIND_LAST,-
		PUTS_LAST,BIO_LAST,BRO_SW,FIND,WRITE,RAHWBH,SKIP_NEXT,-
		DUP,UNLOCK_RP,PPF_EOF,PPF_SKIP,PPF_FNDSV,IDX_ERR,RRV_ERR,-
		UPDATE,UPD_NRP,ABOVELCKD,GBLBUFF,RMS_STALL,DAP_CONN>

BDB_CHR:TABLE	BDB$V_,<AST_DCL,DRT,IOP,NOLOCATE,PRM,VAL,WFO>

ORG_TBL:CASETBL	<Sequential,Relative,Indexed>


RFM_TBL:CASETBL	<UDF,FIX,VAR,VFC>

RFMORG_TBL:CASETBL <SEQ,REL,IDX>

SPL_CHR:TABLE	IRB$V_,<BKT_NO_LO,REC_W_LO,CONT_BKT,CONT_R,EMPTY_BKT,-
		DUPS_SEEN,BKT_NO,BIG_SPLIT,SPL_IDX,EMPT_SEEN>

SCH_CHR:TABLE	IRB$V_,<POSINSERT,SRCHGT,POSDELETE,NEW_IDX,SRCHGE,-
		NORLS_RNF,FIRST_TIM,PRM>

IDX_CHR1:TABLE	IDX$V_,<DUPKEYS,CHGKEYS,NULKEYS,INITIDX,IDX_COMPR,COUNT_DUP>

IDX_CHR0:TABLE	IDX$V_,<DUPKEYS,NORFA,PRG_D_RFA,IDX_COMPR,INITIDX,COUNT_DUP,-
		KEY_COMPR,REC_COMPR>

IDX_TBL:CASETBL	<STRING,SGNWORD,UNSGNWORD,SGNLONG,UNSGNLONG,PACKED>

IDX_TBL1:CASETBL <V2_BKT,CMPIDX,NCMPIDX,CMPCMP,CMPNCMP,NCMPCMP,NCMPNCMP>

CCB_CHR:TABLE	CCB$V_,<AMB>

AMODE_TBL:CASETBL <,Kernel,Executive,Supervisor,User,Invalid>

WCBSHR_CHR:TABLE WCB$V_,<READ,WRITE,NOTFCP,SHRWCB,OVERDRAWN>

WCBACC_CHR:TABLE WCB$V_,<NOWRITE,DLOCK,SPOOL,WRITECK,SEQONLY,WRITEAC,-
		 READCK,NOREAD,NOTRUNC>

PRO_TBL:CASETBL	<,R,W,RW,E,RE,WE,RWE,D,RD,WD,RWD,ED,RED,WED,RWED>

FCB_CHR:TABLE	FCB$V_,<DIR,MARKDEL,BADBLK,EXCL,SPOOL,RMSLOCK>

CSH_CHR:TABLE	CSH$V_,<LOCK,NOWAIT,NOREAD,NOBUFFER>

RLS_CHR:TABLE	RLS$V_,<RETURN,WRT_THRU,KEEP_LOCK,DEQ>

RLB_CHR:TABLE	RLB$V_,<WAIT,CR,PW,PR>

OPT_CHR:TABLE	OPT$V_,<IFB,IRB,IDX,BDB,BDBSUM,ASB,CCB,WCB,FCB,FAB,-
		RAB,RLB,NAM,XAB,BLB,GBD,GBH,TRC,BLBSUM,FWA,GBDSUM>

BLB_CHR:TABLE	BLB$V_,<LOCK,NOWAIT,NOREAD,NOBUFFER,IOLOCK,DFW>

BLB_TBL:CASETBL	<NL,CR,CW,PR,PW,EX,??>

GBH_CHR:TABLE	GBH$V_,<CACHE_IN,CACHE_OUT,RLS_IN,RLS_OUT,QIO_START,-
		QIO_DONE,STALL,THREADGO,BLB_ENQ,BLB_GRANT,BLB_DEQ,-
		BLB_BLOCK,F1,F2,F3,F4>

GBD_CHR:TABLE	GBD$V_,<VALID>

PASS_CHR:TABLE	FWA$V_,<DUPOK,NAMEFLG,TYPEFLG,RLF_PASS,FNA_PASS,NAM_DVI,-
		CUR_VER>

FLD_CHR:TABLEM	FWA$B_FLDFLGS*8,FWA$V_,<VERSION,TYPE,NAME,DIR,DEVICE>

WILD_CHR:TABLEM	FWA$B_WILDFLGS*8,FWA$V_,<EXP_VER,EXP_TYPE,EXP_NAME,WC_VER,-
		WC_TYPE,WC_NAME,EXP_DIR,EXP_DEV>

PARSE_CHR:TABLEM FWA$B_PARSEFLGS*8,FWA$V_,<WILDCARD,NODE,QUOTED,GRPMBR,-
		WILD_DIR>

DIR_CHR:TABLEM	FWA$B_DIRFLGS*8,FWA$V_,<DIR1,DIR2>

DIRWC_CHR:TABLEM FWA$B_DIRWCFLGS*8,FWA$V_,<WILD_UFD,WILD_SFD1>

LN_CHR:TABLEM	FWA$B_LNFLG*8,FWA$V_,<LOGNAME,OBJTYPE,NETSTR,DEV_UNDER,-
		FILEFOUND,REMRESULT,DFLT_MFD,ROOT_DIR>

;
; Local Strings
;

PIOSTRING:	STRING	<PIO$GW_IIOIMPA>
TRACE_DEPTH:	STRING	<RMS$TRACE_DEPTH>
TRACE_FLAGS:	STRING	<RMS$TRACE_FLAGS>
GSTRING:	STRING	<G>		; GBPB signal for BDBSUM
SPSTRING:	STRING	< >		; opposite of above 

;
; Constant Data Declarations
;

ALLOCSZ	=	135		; size of data buf alloc'ed on stack

	.PAGE
	.SBTTL	SHOW_RMS1 -- Display RMS Data Structures
;+++
; SHOW_RMS1 -- Display RMS Data Stuctures
;
; Inputs:
;
;	None.
;
; Outputs:
;
;	RMS Structures displayed.
;---

	.ENABL	LSB
SHOW_RMS1::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVAL	RMS_HANDLER,(FP)	; Establish handler for SHOW RMS
	MOVAB	IFABTBL,R6		; setup address for IFAB table

;
; Look up PIO$GW_IIOIMPA is SDA symbol table, so it may be redefined
; for ITESTD.
;

	CLRW	IFBS			; no IFAB's found yet
	PUSHAL	PIOSTRING		; argument for symbol_value
	CALLS	#1,SYMBOL_VALUE
	MOVL	R1,R9			; put value (if any) in right register
	BLBS	R0,5$			; branch if ok
	MOVL	PIO$GW_IIOIMPA,R9	; get address of image i/o impure area
5$:	ADDL	#IMP$L_IFABTBL,R9	; form pointer to table pointer
	GETMEM	(R9),(R6)		; get P1 space address
	BLBC	R0,15$			; if none, don't complain
	SKIP	PAGE
	CLRW	IFI			; initialize IFI

;
; Got a new table
;

10$:	MOVL	(R6),R9			; get next link to IFAB table
	BNEQ	18$

15$:	TSTW	IFBS			; found any IFAB's?
	BNEQ	17$			; yes, don't message

;
; SIGNAL the fact that there are no RMS structures
;

	SIGNAL	0,NOIMGRMS		; no image RMS structures

17$:	BRW	900$
18$:	GETMEM	(R9),(R6),#<IMP$C_ENTPERSEG+1>*4 ; read in image IFAB table
	BLBC	R0,15$			; can't read in table
	MOVL	#IMP$C_ENTPERSEG,R7	; number of entries in table
	MOVL	R6,R3			; set up address of first IFAB slot
	TSTL	(R3)+			; space over link to next IFAB table
;
; Scan thru IFAB table -- 0 means no entry here
;
;	R3 = pointer into IFABTBL buffer at next IFAB address
;	R6 = address of IFABTBL buffer in local memory
;	R7 = number of entries in IFAB table
;	R9 = virtual address of IFAB table
;

20$:	INCW	IFI			; bump IFI value
	GET	IFAB,@(R3)+,800$	; find IFAB if any, 080$ on error
	INCW	IFBS			; we found an IFAB, so count it
;
; If this is display for specific IFI, then check here, and go around
; everything else!
;

	TSTW	RMS_IFI1			; specific IFI?
	BEQL	25$			; if eql no
	CMPW	RMS_IFI1,IFI		; this the one?
	BEQL	25$			; if eql yes
	BRW	800$			; just like its not there

;
; SHOW IFAB
;
 
25$:	SHOW	IFAB

;
; Get and Show ASB if any for this IFAB and if enabled.
;

	BITL	#OPT$M_ASB,RMS_DIS_OPT1	; ASB display enabled?
	BEQL	30$			; if eql no
	GET	ASB,@IFB$L_ASBADDR+IFAB,30$
	SHOW	ASB

;
; Display index descriptors (IDX$) if indexed file.
;

30$:	CMPB	IFB$B_ORGCASE+IFAB,#IFB$C_IDX ;is file indexed?
	BNEQ	40$			; if neq no -- skip index descriptors

;
; Do we need the IDX descriptors at all?
;

	BITL	#OPT$M_IDX,RMS_DIS_OPT1	; display the IDX descriptors?
	BEQL	40$			; if eql no

	GET	IDX,@IFB$L_IDX_PTR(R2),40$
	BRB	37$			; enter display loop in progress

35$:	GET	IDX,@IDX$L_IDXFL(R2),40$
37$:	SHOW	IDX
	BRB	35$

;
; If it looks like the first BDB contains a FWA, see if we can dump it.
;

40$:	BBS	#OPT$V_FWA,RMS_DIS_OPT1,41$ ; if we dont want FWA, skip it
	BRW	43$
41$:	BBS	#IFB$V_SEARCH,IFAB,42$	; if this is a "search" IFAB, we've
					; got a FWA in the first BDB for sure
	MOVL	#IFB$L_BDB_FLNK,R2	; see if any BDB's
	ADDL2	IFAB-4,R2		; form virt addr of q header
	CMPL	IFB$L_BDB_FLNK+IFAB,R2	; queue have anything in it?
	BEQL	43$			; if eql no
	CMPL	IFB$L_BDB_FLNK+IFAB,IFB$L_BDB_BLNK+IFAB ; only 1 BDB?
	BNEQ	43$			; if neq more than one
	BBS	#IFB$V_ACCESSED,IFAB,43$ ; if accessed not like to have FWA
42$:	GET	BDB,@IFB$L_BDB_FLNK+IFAB,43$ ; get first BDB if any
	GET	FWA,@BDB$L_ADDR(R2),43$	; get our best guess for a FWA
	SHOW	FWA

;
; Start on path to file id.  First find and dump CCB, then WCB, then FCB.
;

43$:	BITL	#<OPT$M_CCB!OPT$M_WCB!OPT$M_FCB>,RMS_DIS_OPT1 ; any of these?
	BNEQ	44$
	BRW	46$
44$:	MOVZWL	IFB$W_CHNL+IFAB,CCB-4
	PUSHAL	CCB
	CALLS	#1,GET_CCB
	BLBS	R0,45$
	BRW	46$

45$:	SHOW	CCB
	GET	WCB,@CCB$L_WIND+CCB,46$
	SHOW	WCB
	GET	FCB,@WCB$L_FCB(R2),46$
	SHOW	FCB

;
; Scan thru IRAB chain and show individual IRAB's
;

46$:	BITL	#<OPT$M_IRB!OPT$M_ASB!OPT$M_RLB>,RMS_DIS_OPT1
	BNEQ	49$
	BRW	60$
49$:	MOVAL	IRAB,R2
	MOVL	IFB$L_IRAB_LNK+IFAB,IRB$L_IRAB_LNK(R2) ; set initial addr IRAB
50$:	GET	IRAB,@IRB$L_IRAB_LNK+IRAB,60$
	SHOW	IRAB

;
; If ASB display enabled, Get and Show the ASB (if any).
;

	BITL	#OPT$M_ASB,RMS_DIS_OPT1
	BEQL	52$
	GET	ASB,@IRB$L_ASBADDR+IRAB,50$
	SHOW	ASB

;
; Display all RLB's attached to this IRAB
;

52$:	BITL	#OPT$M_RLB,RMS_DIS_OPT1	; is it selected?
	BNEQ	55$			; if neq yes
54$:	BRW	50$
55$:	MOVL	IRB$L_RLB_LNK+IRAB,RLB$L_LNK+RLB ; set up  pointer to 1st rlb
	BEQL	54$
	SKIP	PAGE
57$:	GET	RLB,@RLB$L_LNK+RLB,50$
	SHOW	RLB
	BRB	57$

;
; Scan thru BDB list and show information from BDB's
;

60$:	CALLS	#0,SHOW_BDB_SUM		; show summary of BDB's if selected
	CALLS	#0,SHOW_BLB_SUM		; show summary of BLB's if selected
	BITL	#OPT$M_BDB,RMS_DIS_OPT1
	BEQL	70$
	MOVL	IFAB-4,R2		; get virt addr of IFAB
	ADDL2	#IFB$L_BDB_FLNK,R2	; form virt addr of queue header
	CMPL	R2,IFB$L_BDB_FLNK+IFAB  ; does queue header point to itself?
	BEQL	70$			; if eql yes -- queue empty
	MOVL	IFB$L_BDB_FLNK+IFAB,BDB ; initialize first BDB
	SKIP	PAGE
65$:	GET	BDB,@BDB$L_FLINK+BDB,70$
	SHOW	BDB
	CMPL	IFB$L_BDB_BLNK+IFAB,BDB-4 ; is this the last BDB?
	BNEQ	65$			; if neq no

;
; Scan through the BLB list and print out contents
;

70$:	BBS	#IFB$V_NORECLK,IFAB,71$	; if this doesn't have BLB's
	CMPB	IFB$B_ORGCASE+IFAB,#IFB$C_SEQ ; is this seq?
	BNEQ	72$
71$:	BRW	80$
72$:	BITL	#OPT$M_BLB,RMS_DIS_OPT1	; should we do BLB's at all?
	BEQL	80$			; if eql no, exit
	MOVL	IFAB-4,R2		; address of ifab
	ADDL2	#IFB$L_BLBFLNK,R2	; "real" address of blbflnk
	CMPL	R2,IFB$L_BLBFLNK+IFAB	; does queue point to itself
	BEQL	80$			; if eql yes -- no blb's
	MOVL	IFB$L_BLBFLNK+IFAB,BLB  ; put blb address in BLB
	SKIP	PAGE
73$:	GET	BLB,@BLB$L_FLNK+BLB,80$
	SHOW	BLB
	CMPL	IFB$L_BLBBLNK+IFAB,BLB-4 ; is this last blb?
	BNEQ	73$			; if neq no, go for more

;
; Try to dump GBH if any.  Get the GBH in SDA memory if anyone down
; stream needs it, even if we don't want to dump it explicitly.
;

80$:	BITL	#<OPT$M_GBH!OPT$M_GBD!OPT$M_GBDSUM!OPT$M_TRC>,-
		RMS_DIS_OPT1
	BNEQ	82$			; need GBH
81$:	BRW	800$			; don't need GBH
82$:	TSTL	IFB$L_GBH_PTR+IFAB	; do we have one?
	BEQL	81$			; if eql no, skip all who need it
	GET	GBH,@IFB$L_GBH_PTR+IFAB,800$
	BBC	#OPT$V_GBH,RMS_DIS_OPT1,90$ ; we don't dump the GBH
	SHOW	GBH

90$:	CALLS	#0,SHOW_GBD_SUM
	
;
; If tracing enabled, then get values of rms$trace_depth and rms$trace_flags
; and pass them on to SHOW_TRACE.
;

100$:	BBC	#OPT$V_TRC,RMS_DIS_OPT1,800$ ; if not enabled
	CLRL	R2			; initialize trace depth
	PUSHAL	TRACE_DEPTH		; get set to look up symbol
	CALLS	#1,SYMBOL_VALUE		; look up value of RMS$TRACE_DEPTH
	BLBC	R0,102$			; if lbc then no symbol, use default
	MOVL	R1,R2			; use value of RMS$TRACE_DEPTH
102$:	PUSHL	R2			; put on stack for call to SHOW_TRACE
	MOVL	#-1,R2			; default for trace flags
	PUSHAL	TRACE_FLAGS		; set up for look up
	CALLS	#1,SYMBOL_VALUE		; look up value of RMS$TRACE_FLAGS
	BLBC	R0,104$			; if lbc then no symbol, use default
	BICL	R1,R2			; use value of RMS$TRACE_FLAGS as list
					;  of things NOT to trace.
104$:	PUSHL	R2			; push on stack for  call to SHOW_TRACE
	ADDL3	#GBH$L_TRC_FLNK,GBH-4,-(SP) ; get address of trace queue
	PUSHAL	GBH$L_TRC_FLNK+GBH	; add local (SDA) address of queue
	CALLS	#4,SHOW_TRACE
;
; End of processing for specific IFAB and its subsidiary control blocks.
;

800$:	DECL	R7			; one less in this table
	BEQL	810$			; if eql table empty now
	BRW	20$			; go back and get next entry from table

;
; Current table exhausted -- try to get new table segment
;

810$:	BRW	10$			; go back for more table

900$:	STATUS	SUCCESS			; end of IFAB tables
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_RMS -- Display current default RMS Data Struct.
;+++
; SHOW_RMS -- Print out default RMS structures 
;
; Inputs:
;
;	RMS_DIS_OPT = Display options for this command.
;	RMS_IFI     =   "
;
; Outputs:
;
;	None.
;---

SHOW_RMS::.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVL	RMS_DIS_OPT,RMS_DIS_OPT1
	MOVW	RMS_IFI,RMS_IFI1
	CALLS	#0,SHOW_RMS1
	RET

;+++
; SHOW_RMS_DIS -- Print out RMS structures specified by /DISPLAY qualifer.
;
; Inputs:
;
;	RMS_DIS_TMP = Display options for this command.
;	RMS_IFI_TMP = "
;
; Outputs:
;
;	None.
;---

SHOW_RMS_DIS::.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVL	RMS_DIS_TMP,RMS_DIS_OPT1
	MOVW	RMS_IFI_TMP,RMS_IFI1
	CALLS	#0,SHOW_RMS1
	RET

	.PAGE
	.SBTTL	SHOW_RMS_OPT
;+++
; SHOW_RMS_OPT -- Print out current SET RMS, SHOW RMS options.
;
; Inputs:
;
;	RMS_DIS_OPT = Current RMS display options.
;	RMS_IFI	    = IFI for which to display structures.
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_RMS_OPT::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	SKIP	1
	ALLOC	ALLOCSZ,R4		; Create some stack space for translate
	PUSHL	RMS_DIS_OPT		; put longword bit argument on stack
	PUSHAB	OPT_CHR			; translation table for options bits
	CALLS	#2,TRANSLATE_BITS	; perform translation
	PUSHL	R4			; put result back on stack
	PRINT	1,<-
RMS Display Options: !AS>
	MOVZWL	RMS_IFI,-(SP)		; put IFI value on stack
	BEQL	10$			; if all IFI
	PRINT	1,<-
Display RMS structures only for IFI=!UW.>
	BRB	20$
10$:	PRINT	0,<-
Display RMS structures for all IFI values.>
20$:	SKIP	1
	STATUS	SUCCESS
	RET
	.DSABL	LSB

	.SBTTL	RMS_HANDLER -- SHOW RMS exception handler
;+++
; RMS_HANDLER -- Turn ACCVIO's into INVBLKTYP from SHOW RMS
;
; Inputs:
;
;	4(AP) = Pointer to SIGNAL arguments.
;	8(AP) = Pointer to MECHANISM arguments.
;
; Outputs:
;
;	Resignal if not ACCVIO.
;
;	Turn ACCVIO into INVBLKYP and unwind to caller of SHOW_RMS.
;---

RMS_HANDLER:
	.WORD	^M<R2,R3>
	MOVQ	4(AP),R2		; Get addresses of arrays
	CMPL	CHF$L_SIG_NAME(R2),#SS$_ACCVIO ; is this access violation?
	BNEQ	10$			; if neq no
	MOVL	#MSG$_RMSTERM,CHF$L_SIG_NAME(R2) ; reset the error
10$:	MOVZWL	#SS$_RESIGNAL,R0		; continue ...
	RET

	.PAGE
	.SBTTL	SHOW_IFAB -- Print out useful contents of IFAB
;+++
; SHOW_IFAB -- Print out useful contents of IFAB
;
; Inputs:
;
;	4(AP) = Address of local buffer containing IFAB
;
; Outputs:
;
;	IFAB information printed.
;---

	.ENABL	LSB
SHOW_IFAB::
	.WORD	^M<R2,R3,R4>

;
; Do we need to show this structure?
;

	BITL	#OPT$M_IFB,RMS_DIS_OPT1  ; Show IFAB?
	BNEQ	2$			; if neq yes
	BRW	100$			; if eql no
2$:	MOVL	4(AP),R3		; R3 = address
	SKIP	PAGE
	MOVZBL	IFB$B_ORGCASE(R3),R2	; get the organization byte
	MOVL	ORG_TBL[R2],-(SP)	; put the descriptor on stack
	MOVZWL	IFI,-(SP)		; put current IFI on stack
	PUSHL	-4(R3)			; get set up to print out address
	PRINT	0,<-
=============>
	PRINT	3,<-
IFAB Address: !XL		IFI: !XW	Organization: !AC>
	PRINT	0,<-
=============         		----     	------------->
	SKIP	1
	ALLOC	ALLOCSZ,R4		; allocate data area for text str
	PUSHL	(R3)			; set up argument -- dev chr bits
	PUSHAB	DEV_CHR			; address of table describing bits
	CALLS	#2,TRANSLATE_BITS	; only two args to keep descrip around
	PUSHL	R4			; address of descriptor
	PUSHL	(R3)			; device characteristics bits
	PRINT	2,<-
PRIMDEV:	!XL   !AS>
	MOVL	#ALLOCSZ,(SP)		; reset size of allocated buffer
	PUSHL	IFB$L_BKPBITS(R3)	; get bookkeeping bits
	PUSHAB	BKP_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4			; buffer which contains string
	PUSHL	IFB$L_BKPBITS(R3)	; get the bits again
	PRINT	2,<-
BKPBITS:	!XL   !AS>
	MOVZBL	IFB$B_BID(R3),-(SP)	; block ID
	MOVZBL	IFB$B_BLN(R3),-(SP)	; block length
	PRINT	2,<-
BLN:		!XB			-
BID:		!XB>
	MOVZBL	IFB$B_MODE(R3),-(SP)	; mode
	MOVZBL	IFB$B_EFN(R3),-(SP)	; event flag number
	PRINT	2,<-
EFN:		!XB			-
MODE:		!XB>
	PUSHL	IFB$L_ASBADDR(R3)	; ASB address
	PUSHL	IFB$L_IOS(R3)		; I/O status Block
	PRINT	2,<-
IOS:		!XL		-
ASBADDR:	!XL>
	PUSHL	IFB$L_ARGLST(R3)	; User argument list
	PUSHL	IFB$L_IOS4(R3)		; end of I/O status block
	PRINT	2,<-
IOS4:		!XL		-
ARGLST:		!XL>
	MOVZWL	IFB$W_CHNL(R3),-(SP)	; I/O channel number
	PUSHL	IFB$L_IRAB_LNK(R3)	; link to IRAB list
	PRINT	2,<-
IRAB_LNK:	!XL		-
CHNL:		!XW>
	MOVL	#ALLOCSZ,(SP)		; reset size of allocated buffer
	MOVZBL	IFB$B_FAC(R3),-(SP)	; FAC bits for translate
	PUSHAB	FAC_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	IFB$B_FAC(R3),-(SP)	; FAC bits
	PRINT	2,<-
FAC:		!XB	   !AS>
	MOVZBL	IFB$B_ORGCASE(R3),R2
	MOVL	ORG_TBL[R2],-(SP)
	MOVZBL	IFB$B_ORGCASE(R3),-(SP)	; organization
	PRINT	2,<-
ORGCASE:	!XB	   !AC>
	PUSHL	IFB$L_NWA_PTR(R3)	; Network work area
	PUSHL	IFB$L_LAST_FAB(R3)	; last user FAB address
	PRINT	2,<-
LAST_FAB:	!XL		-
NWA_PTR:	!XL>
	PUSHL	IFB$L_FRB_PTR(R3)
	PRINT	1,<-
FRB_PTR:	!XL>
	MOVZWL	IFB$W_DEVBUFSIZ(R3),-(SP) ; default dev buffer size
	PUSHL	IFB$L_BDB_FLNK(R3)	; BDB forward link
	PRINT	2,<-
BDB_FLNK:	!XL		-
DEVBUFSIZ:	!XW	!-!8UW.>
	MOVZWL	IFB$W_RTDEQ(R3),-(SP)	; default extend qty
	PUSHL	IFB$L_BDB_BLNK(R3)	; BDB backward link
	PRINT	2,<-
BDB_BLNK:	!XL		-
RTDEQ:		!XW	!-!8UW.>
	EXTZV	#IFB$V_RFM,#4,IFB$B_RFMORG(R3),R2 ; get record format into R2
	MOVL	RFM_TBL[R2],-(SP)	; put string on stack
	MOVZBL	IFB$B_RFMORG(R3),-(SP)	; record format
	PRINT	2,<-
RFMORG:		!XB	   !AC>
	MOVL	#ALLOCSZ,(SP)		; reset size of allocated buffer
	MOVZBL	IFB$B_RAT(R3),-(SP)	; record attributes for trans
	PUSHAB	RAT_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	IFB$B_RAT(R3),-(SP)	; record attributes
	PRINT	2,<-
RAT:		!XB	   !AS>
	PUSHL	IFB$L_HBK(R3)		; highest block alloc
	MOVZWL	IFB$W_LRL(R3),-(SP)	; longest record length
	PRINT	2,<-
LRL:		!XW	!-!8UW.	-
HBK:		!XL!-!8UL.>
	PUSHL	IFB$L_EBK(R3)		; end of file block
	MOVZWL	IFB$W_FFB(R3),-(SP)	; first free byte
	PRINT	2,<-
FFB:		!XW	!-!8UW.	-
EBK:		!XL!-!8UL.>
	MOVZBL	IFB$B_BKS(R3),-(SP)	; bucket size
	MOVZBL	IFB$B_FSZ(R3),-(SP)	; header size
	PRINT	2,<-
FSZ:		!XB	!-!8UB.	-
BKS:		!XB	!-!8UB.>
	MOVZWL	IFB$W_MRS(R3),-(SP)	; maximum record size
	MOVZWL	IFB$W_DEQ(R3),-(SP)	; default extend size
	PRINT	2,<-
DEQ:		!XW	!-!8UW.	-
MRS:		!XW	!-!8UW.>

	PUSHL	IFB$L_NRP_LIST(R3)	; last, multi-use, longword
	PRINT	1,<-
NRP_LIST:	!XL		-
RNS_LEN:	!-!XL!-!8UL.>
	PUSHL	IFB$L_SFSB_PTR(R3)
	PUSHL	IFB$L_LOCK_BDB(R3)	; lockbdb address
	PRINT	2,<-
LOCK_BDB:	!XL		-
SFSB_PTR:	!XL>
	MOVZWL	IFB$W_AVGBPB(R3),-(SP)
	MOVZWL	IFB$W_AVLCL(R3),-(SP)
	PRINT	2,<-
AVLCL:		!XW	!-!8UW.	-
AVGBPB:		!XW	!-!8UW.>
	PUSHL	IFB$L_GBH_PTR(R3)
	PRINT	1,<-
GBH_PTR:	!XL>

;
; Case to organization dependent code
;

	CASEB	IFB$B_ORGCASE(R3),#0,#2 ; branch to org dependant code
5$:	.WORD	10$-5$			; sequential
	.WORD	15$-5$			; relative
	.WORD	15$-5$			; indexed
	STATUS	NOTVALID
	RET
 
;
; Sequential organization dependant code
;

10$:	MOVL	#ALLOCSZ,(SP)		; reset size of allocated buffer
	PUSHL	IFB$L_AS_DEV(R3)	; get set up to trans char bits
	PUSHAB	DEV_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	PUSHL	IFB$L_AS_DEV(R3)	; assigned dev characteristic bits
	PRINT	2,<-
AS_DEV:		!XL   !AS>
	MOVZWL	IFB$W_ASDEVBSIZ(R3),-(SP) ; assigned dev buffer size
	PRINT	1,<-
ASDEVBSIZ:	!XW	!-!8UW.>
	BRW	100$

;
; Code common to relative and indexed, but not sequential
;

15$:	PUSHL	IFB$L_BLBFLNK(R3)
	PRINT	1,<-
BLBFLNK:	!XL>
	PUSHL	IFB$L_BLBBLNK(R3)
	PRINT	1,<-
BLBBLNK:	!XL>

	CASEB	IFB$B_ORGCASE(R3),#1,#2
16$:	.WORD	20$-16$			; relative
	.WORD	30$-16$			; indexed

;
; Relative organization dependant code
;

20$:	PUSHL	IFB$L_DVBN(R3)		; first data bucket VBN
	PUSHL	IFB$L_MRN(R3)		; maximum record number
	PRINT	2,<-
MRN:		!XL		-
DVBN:		!XL!-!8UL.>
	BRW	100$

;
; Indexed organization dependant code
;

30$:	MOVZBL	IFB$B_AVBN(R3),-(SP)	; VBN  of 1st area descriptor
	PUSHL	IFB$L_IDX_PTR(R3)	; pointer to primary key idx desc
	PRINT	2,<-
IDX_PTR:	!XL		-
AVBN:		!XB	!-!8UB.>
	MOVZBL	IFB$B_NUM_KEYS(R3),-(SP) ; number of keys in file
	MOVZBL	IFB$B_AMAX(R3),-(SP)	; total number of area descriptors
	PRINT	2,<-
AMAX:		!XB	!-!8UB.	-
NUM_KEYS:	!XB	!-!8UB.>
	MOVZWL	IFB$W_KBUFSZ(R3),-(SP) ; key buffer size
	MOVZBL	IFB$B_UBUFSZ(R3),-(SP) ; update buffer size
	PRINT	2,<-
UBUFSZ:		!XB	!-!8UB.	-
KBUFSZ:		!XB	!-!8UB.>
	MOVZBL	IFB$B_EXTRABUF(R3),-(SP) ; number of buffers for cacheing
	MOVZBL	IFB$B_PLG_VER(R3),-(SP) ; prolog version
	PRINT	2,<-
PLG_VER:	!XB			-
EXTRABUF:	!XB	!-!8UB.>

100$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_IDX
;+++
; SHOW_IDX -- Display useful contents of index descriptor.
;
; Inputs:
;
;	4(AP) = Address of buffer containing index descriptor.
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_IDX:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of buffer into R3
	ENSURE	23
	SKIP	2
	PUSHL	-4(R3)			; virtual address of IDX
	PRINT	1,<-
IDX Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	MOVZBL	IDX$B_BID(R3),-(SP)
	PUSHL	IDX$L_IDXFL(R3)
	PRINT	2,<-
IDXFL:		!XL		-
BID:		!XB>
	MOVZBL	IDX$B_BLN(R3),-(SP)
	MOVZBL	IDX$B_IANUM(R3),-(SP)
	PRINT	2,<-
IANUM:		!XB	!-!8UB.	-
BLN:		!XB>
	MOVZBL	IDX$B_LANUM(R3),-(SP)
	MOVZBL	IDX$B_DANUM(R3),-(SP)
	PRINT	2,<-
DANUM:		!XB	!-!8UB.	-
LANUM:		!XB	!-!8UB.>
	MOVZBL	IDX$B_ROOTLEV(R3),-(SP)
	MOVZBL	IDX$B_IDXBKTSZ(R3),-(SP)
	PRINT	2,<-
IDXBKTSZ:	!XB	!-!8UB.	-
ROOTLEV:	!XB	!-!8UB.>
	PUSHL	IDX$L_ROOTVBN(R3)
	MOVZBL	IDX$B_DATBKTSZ(R3),-(SP)
	PRINT	2,<-
DATBKTSZ:	!XB	!-!8UB.	-
ROOTVBN:	!XL!-!8UL.>

;
; Translate and dump the flags
;


	ALLOC	ALLOCSZ,R4
	MOVZBL	IDX$B_FLAGS(R3),-(SP)
	TSTB	IDX$B_KEYREF(R3)	; is it primary key?
	BNEQ	5$			; if neq no
	PUSHAB	IDX_CHR0
	BRB	7$
5$:	PUSHAB	IDX_CHR1		; seconday key, use other table
7$:	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	IDX$B_FLAGS(R3),-(SP)
	PRINT	2,<-
FLAGS:		!XB	   !AS>
	MOVZBL	IDX$B_DATATYPE(R3),R2
	MOVL	IDX_TBL[R2],-(SP)
	MOVZBL	IDX$B_DATATYPE(R3),-(SP)
	PRINT	2,<-
DATATYPE:	!XB	   !AC>
	MOVZBL	IDX$B_NULLCHAR(R3),-(SP)
	PUSHL	#1
	MOVZBL	IDX$B_SEGMENTS(R3),-(SP)
	PRINT	3,<-
SEGMENTS:	!XB	!-!8UB.	-
NULLCHR:	!XB	"!AF">
	MOVZBL	IDX$B_KEYSZ(R3),-(SP)
	MOVZBL	IDX$B_KEYREF(R3),-(SP)
	PRINT	2,<-
KEYREF:		!XB	!-!8UB.	-
KEYSZ:		!XB	!-!8UB.>
	MOVZWL	IDX$W_MINRECSZ(R3),-(SP)
	MOVZWL	IDX$W_IDXFILL(R3),-(SP)
	PRINT	2,<-
IDXFILL:	!XW	!-!8UW.	-
MINRECSZ:	!XW	!-!8UW.>
	MOVZWL	IDX$W_DATFILL(R3),-(SP)
	PRINT	1,<-
DATFILL:	!XW	!-!8UW.>
	MOVZBL	IDX$B_IDXBKTYP(R3),R2
	MOVL	IDX_TBL1[R2],-(SP)
	MOVZBL	IDX$B_IDXBKTYP(R3),-(SP)
	PRINT	2,<-
IDXBKTYP:	!XB	   !AC>
	MOVZBL	IDX$B_DATBKTYP(R3),R2
	MOVL	IDX_TBL1[R2],-(SP)
	MOVZBL	IDX$B_DATBKTYP(R3),-(SP)
	PRINT	2,<-
DATBKTYP:	!XB	   !AC>

;
; Display the specific segments
;

	MOVAW	IDX$W_POSITION(R3),R2	; get starting address of segments
	MOVZBL	IDX$B_SEGMENTS(R3),R4	; get number of segments
	ASHL	#2,R4,R4		; multiply by 4 (1 longword / segment)
	ADDL2	R2,R4			; R4 = address beyond last segment
	SKIP	1
	PRINT	0,<-
	POSITION		SIZE		TYPE>
	PRINT	0,<-
	--------		----		---->
	SKIP	1

10$:	CMPL	R2,R4			; beyond last segment?
	BEQL	90$			; if eql yes -- exit
	MOVZBL	3(R2),R0		; get datatype
	MOVL	IDX_TBL[R0],-(SP)	; get string on stack
	MOVZBL	3(R2),-(SP)		; datatype
	CLRL	-(SP)			; make some room on stack
	MOVZWL	(R2)+,-(SP)		; put size on stack first
	MOVZBL	(R2)+,4(SP)		; put position into previous hole
	TSTB	(R2)+			; step over datatype
	PRINT	4,<-
       !XW!-!8UW.          !XB!-!8UB.      !XB   !AC>
	BRB	10$

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_FWA
;+++
; SHOW_FWA -- Show information in FWA.
;
;  Inputs:
;
;	4(AP) = Address of buffer containing FWA
;
;  Outputs:
;
;	Information printed out for FWA.
;--

	.ENABL	LSB
SHOW_FWA:
	.WORD	^M<R2,R3,R4,R5>
	MOVL	4(AP),R3
	SKIP	PAGE
	PUSHL	-4(R3)
	PRINT	1,<-
FWA Address: !XL>
	PRINT	0,<-
------------>
;
; Form value which will be used to adjust descriptors in the
; FWA.  If  x=address in FWA, y=address of FWA in users image, z=address of
; FWA in SDA, then address of descriptor in SDA = x-y+z.  This is also
; x+(-y+z) = x+(z-y).  We now form (z-y) in R5.
;

	MOVL	R3,R5			; copy z (address of FWA in SDA)
	SUBL2	-4(R3),R5		; form z-y
	ALLOC	ALLOCSZ,R4
;
; Now dump the bit fields
;

	PUSHL	FWA$Q_FLAGS(R3)
	PRINT	1,<-
FLAGS:		!XL>
	PUSHL	FWA$Q_FLAGS+4(R3)
	PRINT	1,<-
		!XL>
	SKIP	1
	FWABITS	PASS
	FWABITS	FLD
	FWABITS	WILD
	FWABITS	PARSE
	FWABITS	DIR
	FWABITS	DIRWC
	MOVL	#ALLOCSZ,(SP)
	MOVZBL	FWA$B_LNFLG(R3),-(SP)
	PUSHAB	LN_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	FWA$B_LNFLG(R3),-(SP)
	PRINT	2,<-
LNFLG:		!XB	!AS>
	SKIP	1

;
; More normal dumping of intermediate FWA cells
;

	PUSHAB	FWA$B_DIRTERM(R3)	; address of string
	PUSHL	#1			; length of string
	MOVZBL	FWA$B_DIRTERM(R3),-(SP) ; value of string
	PRINT	3,<-
DIRTERM:	!XB	"!AF">

	MOVZBL	FWA$W_ESCIFI(R3),-(SP)
	PUSHL	FWA$L_ESCSTRING(R3)
	PRINT	2,<-
ESCSTRING:	!XL		-
ESCIFI:		!XW	!-!8UW.>
	MOVZBL	FWA$B_XLTTBL(R3),-(SP)
	MOVZBL	FWA$B_XLTMODE(R3),-(SP)
	PRINT	2,<-
XLTMODE:	!XB			-
XLTTBL:		!XB>
	PRINTD	FWA$Q_,XLTBUF1
	PRINTD	FWA$Q_,FIB
	PUSHL	FWA$L_DIRBDB(R3)
	PUSHL	FWA$L_BUFFLG(R3)
	PRINT	2,<-
BUFFLG:		!XL		-
DIRBDB:		!XL>
	MOVZWL	FWA$W_FNAMSIZ(R3),-(SP)
	PUSHL	FWA$L_XLTSIZ(R3)
	PRINT	2,<-
XLTSIZ:		!XL!-!8UL.	-
FNAMSIZ:	!XW	!-!8UW.>
	PRINTD	FWA$Q_,LOGNAME
	PUSHL	FWA$L_LOOKUP(R3)
	PUSHL	FWA$L_UIC(R3)
	PRINT	2,<-
UIC:		!XL		-
LOOKUP:		!XL>
	MOVZWL	FWA$W_PRO(R3),-(SP)
	PUSHL	FWA$L_DEVNODADR(R3)
	PRINT	2,<-
DEVNODADR:	!XL		-
PRO:		!XW>
	PRINTD	FWA$Q_,XLTBUF2
	PRINTD	FWA$Q_,DIR
	MOVZWL	FWA$W_UCHAR(R3),-(SP)
	PUSHL	FWA$L_XLTCNT(R3)
	PRINT	2,<-
XLTCNT:		!XL!-!8UL.		-
UCHAR:		!XW>
	MOVZBL	FWA$B_SUBNODCNT(R3),-(SP)
	MOVZBL	FWA$B_DIRLEN(R3),-(SP)
	PRINT	2,<-
DIRLEN:		!XB	!-!8UB.		-
SUBNODCNT:	!XB	!-!8UB.>
	PUSHL	FWA$L_BUF_PTR(R3)
	PRINT	1,<-
BUF_PTR:	!XL>

;
; Dump Descriptors
;

	SKIP	1
	PRINTD	FWA$Q_,NODE
	DUMPDF	DEVICE
	DUMPDF	DIR1
	DUMPDF	DIR2
	DUMPDF	<DIR1+16>
	DUMPDF	<DIR1+24>
	DUMPDF	<DIR1+32>
	DUMPDF	<DIR1+40>
	DUMPDF	<DIR1+48>
	DUMPDF	<DIR1+56>
	DUMPDF	NAME
	DUMPDF	TYPE
	DUMPDF	RNS
	DUMPDF	VERSION
	PRINTD	FWA$Q_,QUOTED
	
	SKIP	1
	PRINTD	FWA$Q_,NODE1
	PRINTD	FWA$Q_,<NODE1+8>
	PRINTD	FWA$Q_,<NODE1+16>
	PRINTD	FWA$Q_,<NODE1+24>
	PRINTD	FWA$Q_,<NODE1+32>
	PRINTD	FWA$Q_,<NODE1+40>
	PRINTD	FWA$Q_,<NODE1+48>
	PRINTD	FWA$Q_,<NODE1+56>

;
; Additional non-descriptor cells
;

	SKIP	1
	PUSHAB	FWA$B_UNDERLINE(R3)
	PUSHL	#1
	MOVZBL	FWA$B_UNDERLINE(R3),-(SP)
	PRINT	3,<-
UNDERLINE:	!XB	"!AF">
	PUSHAL	FWA$T_ROOT_DIR(R3)
	PRINT	1,<-
ROOT_DIR:	!AC>

100$:	STATUS	SUCCESS
	RET
	.DSABL	LSB

;+++
; FWADD -- Dump descriptors in FWA
;
; Inputs:
;
;	R2=Address of descriptor.
;	R5=Offset to add to address for local descriptor pointer.
;
; Outputs:
;
;	String printed if possible.
;---

	.ENABL	LSB
FWADD:	.WORD	^M<R2,R3,R4,R5>
	PUSHL	4(R2)			; see if descriptor points into FWA
	SUBL2	FWA-4,(SP)		; offset from FWA
	CMPL	#FWA$C_BLN,(SP)+	; within FWA?
	BLSSU	10$			; if blssu no

;
; Within FWA -- dump more or less normally
;

	PUSHL	4(R2)			; address in process
	ADDL2	R5,(SP)			; correction previously calc for FWA
	PUSHL	(R2)			; length
	BRW	20$			; print statement 

;
; See if we can find it...
;

10$:	ALLOC	ALLOCSZ,R4		; make some space for it
	CMPL	(R2),(R4)		; is it enough space?
	BGTRU	30$			; if gtr no
	GETMEM	@4(R2),@4(R4),(R2)	; get memory if possible
	BLBC	R0,30$			; if lbc then couldn't get it
	PUSHL	4(R4)			; push address of string
	PUSHL	(R2)			; length too
	
20$:	PRINT	2,<-
			  !AF>

30$:	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_CCB
;+++
; SHOW_CCB -- Show information from CCB.
;
; Inputs:
;
;	4(AP) = Address of buffer containing CCB
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_CCB:
	.WORD	^M<R2,R3,R4>
	BITL	#OPT$M_CCB,RMS_DIS_OPT1	; show ccb's?
	BNEQ	1$			; if neq yes
	BRW	90$			; if eql no
1$:	MOVL	4(AP),R3		; get ccb buffer address
	SKIP	PAGE
	PUSHL	-4(R3)			; address in dump of CCB
	PRINT	1,<-
CCB Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	PUSHL	CCB$L_WIND(R3)		; address of window control block
	PUSHL	CCB$L_UCB(R3)		; UCB address of the device
	PRINT	2,<-
UCB:		!XL		-
WIND:		!XL>
	ALLOC	ALLOCSZ,R4
	MOVZBL	CCB$B_STS(R3),-(SP)
	PUSHAB	CCB_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	CCB$B_STS(R3),-(SP)
	PRINT	2,<-
STS:		!XB	   !AS>
	MOVZBL	CCB$B_AMOD(R3),R2
	CMPL	#5,R2
	BGTR	30$
	MOVL	#5,R2
30$:	MOVL	AMODE_TBL[R2],-(SP)
	MOVZBL	CCB$B_AMOD(R3),-(SP)
	PRINT	2,<-
AMOD:		!XB	   !AC>
	PUSHL	CCB$L_DIRP(R3)
	MOVZWL	CCB$W_IOC(R3),-(SP)
	PRINT	2,<-
IOC:		!XW	!-!8UW.	-
DIRP:		!XL>
90$:	STATUS 	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_WCB
;+++
; SHOW_WCB -- Show information from Window Control Block.
;
; Inputs:
;
;	4(AP) = Address of buffer containing WCB.
;
; Outputs:
;
;	None.
;---
	.ENABL	LSB
SHOW_WCB:
	.WORD	^M<R2,R3,R4,R5>
	BITL	#OPT$M_WCB,RMS_DIS_OPT1  ; display wcb's?
	BNEQ	1$			; if neq yes
	BRW	90$			; if eql no
1$:	MOVL	4(AP),R3		; address of buffer with WCB
	ENSURE	19
	SKIP	2
	PUSHL	-4(R3)			; address in dump of WCB
	PRINT	1,<-
WCB Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	MOVZWL	WCB$W_SIZE(R3),-(SP)
	PUSHL	WCB$L_WLFL(R3)
	PRINT	2,<-
WLFL:		!XL		-
SIZE:		!XW	!-!8UW.>
	MOVZBL	WCB$B_TYPE(R3),-(SP)
	PUSHL	WCB$L_WLBL(R3)
	PRINT	2,<-
WLBL:		!XL		-
TYPE:		!XB>
	ALLOC	ALLOCSZ,R4
	MOVZBL	WCB$B_ACCESS(R3),-(SP)
	PUSHAB	WCBSHR_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	WCB$B_ACCESS(R3),-(SP)
	PRINT	2,<-
ACCESS:		!XB	   !AS>
	PUSHL	WCB$L_ORGUCB(R3)
	BITB	#WCB$M_SHRWCB,WCB$B_ACCESS(R3) ; is this shared WCB?
	BNEQ	10$			; if neq yes
 
;
; Unshared WCB -- print PID of owner
;

	PUSHL	WCB$L_PID(R3)
	PRINT	2,<-
PID:		!XL		-
ORGUCB:		!XL>
	BRB	20$

;
; Shared WCB -- print reference count of WCB
;

10$:	MOVZWL	WCB$W_REFCNT(R3),-(SP)
	PRINT	2,<-
REFCNT:		!XW	!-!8UW.	-
ORGUCB:		!XL>

20$:	MOVL	#ALLOCSZ,(SP)		; reset buffer on stack
	MOVZWL	WCB$W_ACON(R3),-(SP)
	PUSHAB	WCBACC_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZWL	WCB$W_ACON(R3),-(SP)
	PRINT	2,<-
ACON:		!XW	   !AS>
	PUSHL	WCB$L_FCB(R3)		; FCB address
	MOVZWL	WCB$W_NMAP(R3),-(SP)	; number of map pointers
	PRINT	2,<-
NMAP:		!XW	!-!8UW.	-
FCB:		!XL>
	PUSHL	WCB$L_RVT(R3)
	PUSHL	WCB$L_STVBN(R3)
	PRINT	2,<-
STVBN:		!XL!-!8UL.	-
RVT:		!XL>
	
;
; Print out all mapping pointers that fit into our buffer.
;

	SKIP	1
	PRINT	0,<-
	   VBN	   Starting LBN			    Count>
	PRINT	0,<-
	   ---	   ------------			    ----->
	SKIP	1
	MOVL	WCB$L_STVBN(R3),R5	; initial VBN for this window
	MOVAB	WCB$W_P1_COUNT(R3),R2	; address of start of mapping pointers
	MOVZWL	WCB$W_NMAP(R3),R4	; number of mapping pointer
	MULL2	#6,R4			; number of bytes of mapping pointers
	ADDL2	R2,R4			; address beyond end of mapping ptrs
	CMPL	R4,#WCBEND		; is it beyond the buffer?
	BLEQ	30$			; if leq no -- its ok
	MOVAL	WCBEND,R4		; set new end of buffer
	SKIP	1
	PRINT	0,<-
	Pointer table doesn't fit SDA memory buffer>
	SKIP	1

30$:	CMPL	R2,R4			; end of pointers yet?
	BGEQ	90$			; if geq yes -- exit
	MOVZWL	(R2)+,-(SP)		; get size
	PUSHL	(R2)+			; get LBN
	PUSHL	R5			; push VBN
	ADDL2	8(SP),R5		; adjust VBN for next time
	PRINT	3,<-
   !12UL.   !XL !-!12UL.	    !XW !-!8UW.>
	BRB	30$

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL
;+++
; SHOW_FCB -- Show information from File Control Block.
;
; Inputs:
;
;	4(AP) = Address of buffer containing FCB.
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_FCB:
	.WORD	^M<R2,R3,R4>
	BITL	#OPT$M_FCB,RMS_DIS_OPT1	; display FCB's?
	BNEQ	1$			; if neq yes
	BRW	90$			; if eql no
1$:	MOVL	4(AP),R3		; address of FCB buffer
	ENSURE	19
	SKIP	2
	PUSHL	-4(R3)			; address of FCB in dump
	PRINT	1,<-
FCB Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	MOVZWL	FCB$W_SIZE(R3),-(SP)
	PUSHL	FCB$L_FCBFL(R3)
	PRINT	2,<-
FCBFL:		!XL		-
SIZE:		!XW	!-!8UW.>
	MOVZBL	FCB$B_TYPE(R3),-(SP)
	PUSHL	FCB$L_FCBBL(R3)
	PRINT	2,<-
FCBBL:		!XL		-
TYPE:		!XB>
	PUSHL	FCB$L_EXFCB(R3)
	MOVZWL	FCB$W_ACNT(R3),-(SP)
	PRINT	2,<-
ACNT:		!XW	!-!8UW.	-
EXFCB:		!XL>
	PUSHL	FCB$L_WLFL(R3)
	MOVZWL	FCB$W_LCNT(R3),-(SP)
	PRINT	2,<-
LCNT:		!XW	!-!8UW.	-
WLFL:		!XL>
	PUSHL	FCB$L_WLBL(R3)
	MOVZWL	FCB$W_WCNT(R3),-(SP)
	PRINT	2,<-
WCNT:		!XW	!-!8UW.	-
WLBL:		!XL>

;
; display the status bits in the FCB
;

	ALLOC	ALLOCSZ,R4
	MOVZWL	FCB$W_STATUS(R3),-(SP)
	PUSHAB	FCB_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZWL	FCB$W_STATUS(R3),-(SP)
	PRINT	2,<-
STATUS:		!XW	    !AS>
	MOVZWL	FCB$W_FID_RVN(R3),-(SP)
	MOVZWL	FCB$W_FID_NUM(R3),-(SP)
	PRINT	2,<-
FID_NUM:	!XW	!-!8UW.	-
FID_RVN:	!XW	!-!8UW.>
	MOVZWL	FCB$W_SEGN(R3),-(SP)
	MOVZWL	FCB$W_FID_SEQ(R3),-(SP)
	PRINT	2,<-
FID_SEQ:	!XW	!-!8UW.	-
SEGN:		!XW	!-!8UW.>
	PUSHL	FCB$L_STLBN(R3)
	PUSHL	FCB$L_STVBN(R3)
	PRINT	2,<-
STVBN:		!XL!-!8UL.	-
STLBN:		!XL!-!8UL.>
	PUSHL	FCB$L_HDLBN(R3)
	PUSHL	FCB$L_FILESIZE(R3)
	PRINT	2,<-
FILESIZE:	!XL!-!8UL.	-
HDLBN:		!XL!-!8UL.>
	MOVZWL	FCB$W_UICMEMBER(R3),-(SP)
	MOVZWL	FCB$W_UICGROUP(R3),-(SP)
	PRINT	2,<-
UICGROUP:	!OW			-
UICMEMBER:	!OW>

;
; Display the file protection !
;

	MOVL	#12,R4
	
10$:	EXTZV	R4,#4,FCB$W_FILEPROT(R3),R2 ; get the next prot nibble
	XORL2	#^XF,R2			; complement lower four bits
	MOVL	PRO_TBL[R2],-(SP)	; push descriptor for this nibble
	SUBL2	#4,R4			; move to next section of word
	BGEQ	10$			; if geq then more to go

20$:	MOVZWL	FCB$W_FILEPROT(R3),-(SP)
	PRINT	5,<-
FILEPROT:	!XW	   System:!AC, Owner:!AC, Group:!AC, World:!AC>
	MOVZWL	FCB$W_VERSIONS(R3),-(SP)
	PUSHL	FCB$L_EFBLK(R3)
	PRINT	2,<-
EFBLK:		!XL!-!8UL.	-
VERSIONS:	!XW	!-!8UW.>
	MOVZWL	FCB$W_DIRSEQ(R3),-(SP)
	MOVZWL	FCB$W_TCNT(R3),-(SP)
	PRINT	2,<-
TCNT:		!XW	!-!8UW.	-
DIRSEQ:		!XW>
	CMPW	#1,FCB$W_ACNT(R3)	; is this file open by more than one?
	BLSS	30$			; if lss yes
	BRW	90$			; if geq no -- exit

;
; Here we will attempt to print out the WCB addresses and associated
; PID's for all the accessors of this file.
;

30$:	MOVL	FCB-4,R4		; get virtual address of FCB
	ADDL2	#FCB$L_WLFL,R4		; create virt addr of queue head
	MOVAB	WCB,R2
	MOVL	FCB$L_WLFL(R3),WCB$L_WLFL(R2) ; set up starting address 1st WCB
	SKIP	1
	PRINT	0,<-
		Current Accessors>
	PRINT	0,<-
		----------------->
	SKIP	1
	PRINT	0,<-
       WCB Address		PID>
	PRINT	0,<-
       -----------		--->
	SKIP	1

40$:	GET	WCB,@WCB$L_WLFL(R2),90$
	BITB	#WCB$M_SHRWCB,WCB$B_ACCESS(R2) ; is this shared WCB?
	BEQL	50$			; if eql no
 
;
; Shared WCB -- print out access count instead of PID
;

	MOVZWL	WCB$W_REFCNT(R2),-(SP)
	PUSHL	WCB-4
	PRINT	2,<-
	!XL	REFCNT: !XW !-!8UW.>
	BRB	60$

50$:	PUSHL	WCB$L_PID(R2)
	PUSHL	WCB-4
	PRINT	2,<-
	!XL	      !XL>
60$:	CMPL	R4,WCB$L_WLFL(R2)
	BNEQ	40$

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_IRAB
;+++
; SHOW_IRAB -- Show information from IRAB.
;
; Inputs:
;
;	4(AP) = Address of IRAB in buffer in memory.
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_IRAB:
	.WORD	^M<R2,R3,R4>
	BITL	#OPT$M_IRB,RMS_DIS_OPT1	; display IRAB's?
	BNEQ	1$			; if neq yes
	BRW	90$			; if no -- exit
1$:	MOVL	4(AP),R3		; get address of buffer into R3
	SKIP	PAGE
	MOVZWL	IRB$W_OWN_ISI(R3),-(SP) ; push ISI value for this IRAB
	PUSHL	-4(R3)			; real address of this IRAB
	PRINT	2,<-
IRAB Address: !XL		ISI: !XW>
	PRINT	0,<-
-------------			---->
	SKIP	1
	PUSHL	IRB$L_IFAB_LNK(R3)	; address of FAB to which this lnkd
	PRINT	1,<-
IFAB_LNK:	!XL>
	ALLOC	ALLOCSZ,R4		; make a buffer to trans BKP bits
	PUSHL	IRB$L_BKPBITS(R3)	; set of the bits for a call
	PUSHAB	IRBBKP_CHR		; address of translation table
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	PUSHL	IRB$L_BKPBITS(R3)	; the bit again, this time for display
	PRINT	2,<-
BKPBITS:	!XL   !AS>
	MOVZBL	IRB$B_BID(R3),-(SP)	; block ID
	MOVZBL	IRB$B_BLN(R3),-(SP)	; block length
	PRINT	2,<-
BLN:		!XB			-
BID:		!XB>
	MOVZBL	IRB$B_MODE(R3),-(SP)	; mode
	MOVZBL	IRB$B_EFN(R3),-(SP)	; event flag number
	PRINT	2,<-
EFN:		!XB			-
MODE:		!XB>
	PUSHL	IRB$L_ASBADDR(R3)	; ASB address
	PUSHL	IRB$L_IOS(R3)		; I/O status Block
	PRINT	2,<-
IOS:		!XL		-
ASBADDR:	!XL>
	PUSHL	IRB$L_ARGLST(R3)	; User argument list
	PUSHL	IRB$L_IOS4(R3)		; end of I/O status block
	PRINT	2,<-
IOS4:		!XL		-
ARGLST:		!XL>
	PUSHL	IRB$L_CURBDB(R3)	; current BDB pointer
	PUSHL	IRB$L_IRAB_LNK(R3)	; link to IRAB list
	PRINT	2,<-
IRAB_LNK:	!XL		-
CURBDB:		!XL>
	PUSHL	IRB$L_NXTBDB(R3)	; next BDB
	PUSHL	IRB$L_LAST_RAB(R3)	; most recently used RAB in users space
	PRINT	2,<-
LAST_RAB:	!XL		-
NXTBDB:		!XL>
	PUSHL	IRB$L_RLB_LNK(R3)
	PRINT	1,<-
RLB_LNK:	!XL>
 
;
; Case now for some organization dependant fields
;

	CASEB	IFB$B_ORGCASE+IFAB,#0,#2
2$:	.WORD	10$-2$			; Sequential
	.WORD	20$-2$			; Relative
	.WORD	30$-2$			; Indexed
	BRW	99$			; organization error

;
; Sequential
;

10$:	PUSHL	IRB$L_RP_VBN(R3)	; VBN from current record pointer
	PUSHL	IRB$L_NRP_VBN(R3)	; VBN from next record pointer
	PRINT	2,<-
NRP_VBN:	!XL!-!8UL.	-
RP_VBN:		!XL!-!8UL.>
	PUSHL	IRB$L_RP_OFF(R3)	; current record pointer offset
	PUSHL	IRB$L_NRP_OFF(R3)	; next record pointer offset
	PRINT	2,<-
NRP_OFF:	!XL!-!8UL.	-
RP_OFF:		!XL!-!8UL.>
	BRW	40$

;
; Relative
;

20$:	PUSHL	IRB$L_RP_VBN(R3)	; record pointer VBN
	PUSHL	IRB$L_NRP_VBN(R3)	; next record pointer VBN
	PRINT	2,<-
NRP_VBN:	!XL!-!8UL.	-
RP_VBN:		!XL!-!8UL.>
	PUSHL	IRB$L_RP(R3)
	PUSHL	IRB$L_NRP(R3)
	PRINT	2,<-
RP:		!XL!-!8UL.	-
NRP:		!XL!-!8UL.>
	PUSHL	IRB$L_RP_OFF(R3)
	PUSHL	IRB$L_NRP_OFF(R3)
	PRINT	2,<-
NRP_OFF:	!XL!-!8UL.	-
RP_OFF:		!XL!-!8UL.>
	MOVZWL	IRB$W_RP_OFF(R3),-(SP)
	MOVZWL	IRB$W_NRP_OFF(R3),-(SP)
	PRINT	2,<-
NRP_OFF:	!XW	!-!8UW.	-
RP_OFF:		!XW	!-!8UW.>
	PUSHL	IRB$L_CURVBN(R3)
	PRINT	1,<-
CURVBN:		!XL!-!8UL.>
	BRW	40$

;
; Indexed
;

30$:	MOVZBL	IRB$B_NRP_KREF(R3),-(SP)
	PUSHL	IRB$L_NRP_PTR(R3)
	PRINT	2,<-
NRP_PTR:	!XL		-
NRP_KREF:	!XB	!-!8UB.>
	MOVL	#ALLOCSZ,(SP)
	MOVZBL	IRB$B_CACHEFLGS(R3),-(SP)
	PUSHAB	CSH_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	IRB$B_CACHEFLGS(R3),-(SP)
	PRINT	2,<-
CACHEFLGS:	!XB	   !AS>
	MOVZBL	IRB$B_RP_KREF(R3),-(SP)
	EXTZV	#IRB$V_NEW_BKTS,#2,IRB$B_SPL_BITS(R3),-(SP)
	PRINT	2,<-
NEWBKTS:	!XB	!-!8UB.	-
RP_KREF:	!XB	!-!8UB.>
	MOVL	#ALLOCSZ,(SP)		; reset buffer size on stack
	MOVZBL	IRB$B_SPL_BITS(R3),-(SP) ; bits for translation
	PUSHAB	SPL_CHR			; address of translation table
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4			; buffer full of bit names
	MOVZBL	IRB$B_SPL_BITS(R3),-(SP) ; bit values again
	PRINT	2,<-
SPL_BITS:	!XB	   !AS>
	MOVZWL	IRB$W_SPLIT(R3),-(SP)
	MOVZWL	IRB$W_POS_INS(R3),-(SP)
	PRINT	2,<-
POS_INS:	!XW	!-!8UW.	-
SPLIT:		!XW	!-!8UW.>
	PUSHL	IRB$L_PTR_VBN(R3)
	PUSHL	IRB$L_LST_REC(R3)
	PRINT	2,<-
LST_REC:	!XL!-!8UL.	-
PRT_VBN:	!XL!-!8UL.>
	MOVZWL	IRB$W_SPLIT_2(R3),-(SP)
	MOVZWL	IRB$W_SPLIT_1(R3),-(SP)
	PRINT	2,<-
SPLIT_1:	!XL!-!8UL.	-
SPLIT_2:	!XL!-!8UL.>

;
; Common path again
;

40$:	MOVZBL	IRB$B_BCNT(R3),-(SP)	; buffer count
	PUSHL	IRB$L_OWNER_ID(R3)	; full owner ID longword
	PRINT	2,<-
OWNER_ID:	!XL		-
BCNT:		!XB	!-!8UB.>
	MOVZBL	IRB$B_MBC(R3),-(SP)	; multibuffer count
	MOVZWL	IRB$W_OWN_ISI(R3),-(SP) ; ISI of this IRAB
	PRINT	2,<-
OWN_ISI:	!XW	!-!8UW.	-
MBC:		!XB	!-!8UB.>
	MOVZWL	IRB$W_OWN_ID(R3),-(SP)  ; process ID (low word)
	MOVZBL	IRB$B_PPF_ISI(R3),-(SP)
	PRINT	2,<-
PPF_ISI:	!XB	!-!8UB.	-
OWN_ID:		!XW>

;
; Case for organization dependant fields
;

	CASEB	IFB$B_ORGCASE+IFAB,#0,#2
41$:	.WORD	50$-41$			; sequential
	.WORD	60$-41$			; relative
	.WORD	70$-41$			; indexed
	BRW	99$			; organization error

;
; Sequential
;

50$:	MOVZWL	IRB$W_CSIZ(R3),-(SP)
	PUSHL	IRB$L_TEMP0(R3)
	PRINT	2,<-
TEMP0:		!XL		-
CSIZ:		!XW	!-!8UW.>
	MOVZWL	IRB$W_RTOTLSZ(R3),-(SP)
	MOVZWL	IRB$W_ROVHDSZ(R3),-(SP)
	PRINT	2,<-
ROVHDSZ:	!XW	!-!8UW.	-
RTOTLSZ:	!XW	!-!8UW.>
	MOVZBL	IRB$B_POST_CCTL(R3),-(SP)
	MOVZBL	IRB$B_PRE_CCTL(R3),-(SP)
	PRINT	2,<-
PRE_CCTL:	!XB	!-!8UB.	-
POST_CCTL:	!XB	!-!8UB.>
	MOVZBL	IRB$B_NVBNS(R3),-(SP)
	PUSHL	IRB$L_TEMP1(R3)
	PRINT	2,<-
TEMP1:		!XL		-
NVBNS:		!XB	!-!8UB.>
	BRW	90$

;
; Relative 
;

60$:	MOVZBL	IRB$W_CSIZ(R3),-(SP)
	PRINT	1,<-
CSIZ:		!XB	!-!8UB.>
	BRW	90$

;
; Indexed
;

70$:	MOVZBL	IRB$B_STOPLEVEL(R3),-(SP)
	PRINT	1,<-
STOPLEVEL:	!XB	!-!8UB.>
	MOVL	#ALLOCSZ,(SP)		; reset buffer size on stack
	MOVZBL	IRB$B_SRCHFLAGS(R3),-(SP) ; push bits to translate
	PUSHAB	SCH_CHR			;  address of translate table
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4			; address of text string
	MOVZBL	IRB$B_SRCHFLAGS(R3),-(SP) ; bits again
	PRINT	2,<-
SRCHFLAGS:	!XB	   !AS>
	PUSHL	IRB$L_UPDBUF(R3)
	PUSHL	IRB$L_KEYBUF(R3)
	PRINT	2,<-
KEYBUF:		!XL		-
UPDBUF:		!XL>
	PUSHL	IRB$L_UPD_BDB(R3)
	PUSHL	IRB$L_RFA_VBN(R3)
	PRINT	2,<-
RFA_VBN:	!XL!-!8UL.	-
UPD_BDB:	!XL>
	PUSHL	IRB$L_LAST_VBN(R3)
	MOVZWL	IRB$W_RFA_ID(R3),-(SP)
	PRINT	2,<-
RFA_ID:		!XW			-
LAST_VBN:	!XL!-!8UL.>
	MOVZWL	IRB$W_LAST_ID(R3),-(SP)
	MOVZBL	IRB$B_KEYSZ(R3),-(SP)
	PRINT	2,<-
KEYSZ:		!XB	!-!8UB.	-
LAST_ID:	!XW>
	PUSHL	IRB$L_LOCK_BDB(R3)
	MOVZWL	IRB$W_SAVE_POS(R3),-(SP)
	PRINT	2,<-
SAVE_POS:	!XW			-
LOCK_BDB:	!XL>
	PUSHL	IRB$L_MIDX_TMP1(R3)
	PUSHL	IRB$L_VBN_LEFT(R3)
	PRINT	2,<-
VBN_LEFT:	!XL!-!8UL.	-
MIDX_TMP1:	!XL>
	PUSHL	IRB$L_MIDX_TMP2(R3)
	PUSHL	IRB$L_VBN_RIGHT(R3)
	PRINT	2,<-
VBN_RIGHT:	!XL!-!8UL.	-
MIDX_TMP2:	!XL>
	PUSHL	IRB$L_MIDX_TMP3(R3)
	PUSHL	IRB$L_VBN_MID(R3)
	PRINT	2,<-
VBN_MID:	!XL!-!8UL.	-
MIDX_TMP3:	!XL>
	PUSHL	IRB$L_LST_NCMP(R3)
	PUSHL	IRB$L_REC_COUNT(R3)
	PRINT	2,<-
REC_COUNT:	!XL!-!8UL.	-
LST_NCMP:	!XL>
	PUSHL	IRB$L_SPL_COUNT(R3)
	MOVZBL	IRB$B_DIFF_CHAR(R3),-(SP)
	PRINT	2,<-
DIFF_CHAR:	!XB	!-!8UB.	-
SPL_COUNT:	!XL!-!8UL.>
	MOVZWL	IRB$W_NID_RIGHT(R3),-(SP)
	MOVZWL	IRB$W_NID_MID(R3),-(SP)
	PRINT	2,<-
NID_MID:	!XW			-
NID_RIGHT:	!XW>
	MOVZWL	IRB$W_RFA_NID(R3),-(SP)
	PRINT	1,<-
RFA_NID:	!XW>

90$:	STATUS	SUCCESS
	RET
99$:	STATUS	NOTVALID
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_BDB_SUM
;+++
; SHOW_BDB_SUM -- Show one line summaries of important BDB information.
;
; Inputs:
;
;	None.
;
; Implicit Inputs:
;
;	RMS_DIS_OPT1 = Display options.
;	IFAB	    = Block buffer with valid (current) IFAB.
;
; Outputs:
;
;	None.
;
; Implicit Outputs:
;
;	Current BDB buffer destroyed.
;---

	.ENABLE	LSB
SHOW_BDB_SUM:
	.WORD	^M<R2,R3,R4>
	BBS	#OPT$V_BDBSUM,RMS_DIS_OPT1,10$ ; branch if summary enabled
5$:	BRW	90$			; optimize branches
10$:	MOVL	IFAB-4,R2		; virtual address of current IFAB
	ADDL2	#IFB$L_BDB_FLNK,R2	; virtual address of BDB queue header
	CMPL	R2,IFB$L_BDB_FLNK+IFAB	; does queue header point to itself?
	BEQL	5$			; if eql yes -- empty queue, exit
	MOVL	IFB$L_BDB_FLNK+IFAB,BDB ; initialize BDB buffer to point to 1st
	SKIP	PAGE			; we're really going to print something
	PRINT	0,<-
				BDB Summary>
	PRINT	0,<-
				----------->
	SKIP	1
	PRINT	0,<-
  BDB						 CACHE_>
	PRINT	0,<-
Address USERS SIZE  NUMB    VBN   BLB_PTR   ADDR   VAL   FLGS>
	PRINT	0,<-
------- ----- ----  ----    ---   -------   ----   ---   ---->
	SKIP	1

;
; Allocate memory for translate bits output.
;

	ALLOC	ALLOCSZ,R4

;
; Main loop -- get BDB's from list and display important info, one line
; per BDB.
;

20$:	GET	BDB,@BDB$L_FLINK+BDB,90$
	MOVL	#ALLOCSZ,(SP)		; reset size of allocated buffer
	MOVZBL	BDB$B_FLGS(R2),-(SP)	; get flags byte for translate
	PUSHAB	BDB_CHR			; address of bit table for translate
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4			; push result string for PRINT
	MOVZBL	BDB$B_CACHE_VAL(R2),-(SP)
	PUSHL	BDB$L_ADDR(R2)
	PUSHL	BDB$L_BLB_PTR(R2)
	PUSHL	BDB$L_VBN(R2)
	MOVZWL	BDB$W_NUMB(R2),-(SP)
	MOVZWL	BDB$W_SIZE(R2),-(SP)
	MOVZWL	BDB$W_USERS(R2),-(SP)
	
;
; If we have a GBPB instead of a BDB then flag it.
;

	PUSHAL	SPSTRING		; assume BDB
	CMPB	#GBPB$C_BID,BDB$B_BID(R2) ; is it GBPB?
	BNEQ	30$			; if neq no
	MOVAL	GSTRING,(SP)		; flag as GBPB
30$:	PUSHL	-4(R2)
	PRINT	10,<-
!XL!AS!3UW !5UW !5UW !7SL !XL !XL !3UB !AS>
	CMPL	IFB$L_BDB_BLNK+IFAB,-4(R2) ; done?
	BEQL	90$			; if eql yes
	BRW	20$			; if neq then go for more

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_BLB_SUM
;+++
; SHOW_BLB_SUM -- Show one line summaries of important BLB information.
;
; Inputs:
;
;	None.
;
; Implicit Inputs:
;
;	RMS_DIS_OPT1 = Display options.
;	IFAB	    = Block buffer with valid (current) IFAB.
;
; Outputs:
;
;	None.
;
; Implicit Outputs:
;
;	Current BLB buffer destroyed.
;---

	.ENABLE	LSB
SHOW_BLB_SUM:
	.WORD	^M<R2,R3,R4>
	BBS	#IFB$V_NORECLK,IFAB,5$	; if no blb's on this IFAB
	CMPB	IFB$B_ORGCASE+IFAB,#IFB$C_SEQ ; is file sequential?
	BEQL	5$			; if eql yes, exit
	BBS	#OPT$V_BLBSUM,RMS_DIS_OPT1,10$ ; branch if summary enabled
5$:	BRW	90$			; optimize branches
10$:	MOVL	IFAB-4,R2		; virtual address of current IFAB
	ADDL2	#IFB$L_BLBFLNK,R2	; virtual address of BLB queue header
	CMPL	R2,IFB$L_BLBFLNK+IFAB	; does queue header point to itself?
	BEQL	5$			; if eql yes -- empty queue, exit
	MOVL	IFB$L_BLBFLNK+IFAB,BLB ; initialize BLB buffer to point to 1st
	SKIP	PAGE			; we're really going to print something
	PRINT	0,<-
				BLB Summary>
	PRINT	0,<-
				----------->
	SKIP	1
	PRINT	0,<-
  BLB      BDB            MODE>
	PRINT	0,<-
Address  Address   OWNER  HELD   VBN   LOCK_ID  VALSEQNO    BLBFLGS>
	PRINT	0,<-
-------  -------   -----  ----   ---   -------  --------    ------->
	SKIP	1

;
; Allocate memory for translate bits output.
;

	ALLOC	ALLOCSZ,R4

;
; Main loop -- get BLB's from list and display important info, one line
; per BLB.
;

20$:	GET	BLB,@BLB$L_FLNK+BLB,90$
	MOVL	#ALLOCSZ,(SP)		; reset size of allocated buffer
	MOVZBL	BLB$B_BLBFLGS(R2),-(SP)	; get flags byte for translate
	PUSHAB	BLB_CHR			; address of bit table for translate
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4			; push result string for PRINT
	PUSHL	BLB$L_VALSEQNO(R2)
	PUSHL	BLB$L_LOCK_ID(R2)
	PUSHL	BLB$L_VBN(R2)
	MOVZBL	BLB$B_MODEHELD(R2),R3
	CMPB	#6,R3
	BGTRU	22$
	MOVZBL	#6,R3
22$:	PUSHL	BLB_TBL[R3]
	PUSHL	BLB$L_OWNER(R2)
	PUSHL	BLB$L_BDB_ADDR(R2)
	PUSHL	-4(R2)
	PRINT	8,<-
!XL !XL !XL !AC !7UL  !XL !XL !AS>
	CMPL	IFB$L_BLBBLNK+IFAB,-4(R2) ; done?
	BEQL	90$			; if eql yes
	BRW	20$			; if neq then go for more

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_BDB
;+++
; SHOW_BDB -- Show information from BDB.
;
; Inputs:
;
;	4(AP) = Address of BDB in local memory.
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_BDB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of BDB into R3
	ENSURE	17
	SKIP	1
	PUSHL	-4(R3)			; real address of BDB
	CMPB	#GBPB$C_BID,BDB$B_BID(R3) ; is it GBPB
	BNEQ	10$			;if neq no
	PRINT	1,<-
GBPB Address: !XL>
	PRINT	0,<-
------------->
	BRB	20$
10$:	PRINT	1,<-
BDB Address: !XL>
	PRINT	0,<-
------------>
20$:	SKIP	1
	MOVZBL	BDB$B_BID(R3),-(SP)	; block ID
	PUSHL	BDB$L_FLINK(R3)		; forward BDB link
	PRINT	2,<-
FLINK:		!XL		-
BID:		!XB>
	MOVZBL	BDB$B_BLN(R3),-(SP)	; block length
	PUSHL	BDB$L_BLINK(R3)		; back link for BDB chain
	PRINT	2,<-
BLINK:		!XL		-
BLN:		!XB>
	ALLOC	ALLOCSZ,R4		; make some space for translate bits
	MOVZBL	BDB$B_FLGS(R3),-(SP)	; push flags byte for translate
	PUSHAB	BDB_CHR			; address of translate table
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	BDB$B_FLGS(R3),-(SP)	; flags again for print this time
	PRINT	2,<-
FLGS:		!XB	   !AS>
	PUSHL	BDB$L_BLB_PTR(R3)
	MOVZWL	BDB$W_USERS(R3),-(SP)	; use count
	PRINT	2,<-
USERS:		!XW	!-!8UW.	-
BLB_PTR:	!XL>
	MOVZWL	BDB$W_BUFF_ID(R3),-(SP)
	MOVZBL	BDB$B_CACHE_VAL(R3),-(SP)
	PRINT	2,<-
CACHE_VAL:	!XB	!-!8UB.	-
BUFF_ID:	!XW	!-!8UW.>
	MOVZWL	BDB$W_NUMB(R3),-(SP)	; number of bytes in use
	MOVZWL	BDB$W_SIZE(R3),-(SP)	; buffer size
	PRINT	2,<-
SIZE:		!XW	!-!8UW.	-
NUMB:		!XW	!-!8UW.>
	PUSHL	BDB$L_VBN(R3)		; VBN for this buffer
	PUSHL	BDB$L_ADDR(R3)		; address of buffer
	PRINT	2,<-
ADDR:		!XL		-
VBN:		!XL!-!8UL.>
	CMPB	#GBPB$C_BID,BDB$B_BID(R3) ; is it GBPB
	BNEQ	30$			; if neq no
	PUSHL	GBPB$L_GBD_PTR(R3)
	PUSHL	GBPB$L_VBNSEQNO(R3)
	PRINT	2,<-
VBNSEQNO:	!XL		-
GBD_PTR:	!XL>
	BRW	90$
	
30$:	PUSHL	BDB$L_WAIT(R3)
	PUSHL	BDB$L_VBNSEQNO(R3)
	PRINT	2,<-
VBNSEQNO:	!XL		-
WAIT:		!XL>
	PUSHL	BDB$L_CURBUFADR(R3)
	PUSHL	BDB$L_WK1(R3)
	PRINT	2,<-
WK1:		!XL		-
CURBUFADR:	!XL>
	MOVZBL	BDB$B_PRE_CCTL(R3),-(SP)
	MOVZBL	BDB$B_REL_VBN(R3),-(SP)
	PRINT	2,<-
REL_VBN:	!XB	!-!8UB.	-
PRE_CCTL:	!XB>
	MOVZBL	BDB$B_POST_CCTL(R3),-(SP)
	MOVZBL	BDB$B_VAL_VBNS(R3),-(SP)
	PRINT	2,<-
VAL_VBNS:	!XB	!-!8UB.	-
POST_CCTL:	!XB>
	PUSHL	BDB$L_IOSB(R3)
	PRINT	1,<-
IOSB:		!XL>
	PUSHL	BDB$L_IOSB+4(R3)
	PRINT	1,<-
		!XL>
90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_BLB
;+++
; SHOW_BLB -- Show information from BLB.
;
; Inputs:
;
;	4(AP) = Address of BLB in local memory.
;
; Outputs:
;
;	None.
;---

	.ENABL	LSB
SHOW_BLB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of BLB into R3
	ENSURE	16
	SKIP	1
	PUSHL	-4(R3)			; real address of BLB
	PRINT	1,<-
BLB Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	MOVZBL	BLB$B_BID(R3),-(SP)	; block ID
	PUSHL	BLB$L_FLNK(R3)		; forward BLB link
	PRINT	2,<-
FLNK:		!XL		-
BID:		!XB>
	MOVZBL	BLB$B_BLN(R3),-(SP)	; block length
	PUSHL	BLB$L_BLNK(R3)		; back link for BLB chain
	PRINT	2,<-
BLNK:		!XL		-
BLN:		!XB>
	ALLOC	ALLOCSZ,R4		; make some space for translate bits
	MOVZBL	BLB$B_BLBFLGS(R3),-(SP)	; push flags byte for translate
	PUSHAB	BLB_CHR			; address of translate table
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	BLB$B_BLBFLGS(R3),-(SP)	; flags again for print this time
	PRINT	2,<-
BLBFLGS:	!XB	   !AS>
	MOVZBL	BLB$B_MODEHELD(R3),R2
	CMPB	#6,R2
	BGTRU	10$
	MOVZBL	#6,R2
10$:	PUSHL	BLB_TBL[R2]	
	MOVZBL	BLB$B_MODEHELD(R3),-(SP)
	PUSHL	BLB$L_BDB_ADDR(R3)
	PRINT	3,<-
BDB_ADDR:	!XL		-
MODEHELD:	!XB         !AC>
	PUSHL	BLB$L_OWNER(R3)
	PUSHL	BLB$L_VBN(R3)
	PRINT	2,<-
VBN:		!XL!-!8UL.	-
OWNER:		!XL>
	PUSHL	BLB$L_LOCK_ID(R3)
	MOVZWL	BLB$W_LKSTS(R3),-(SP)
	PRINT	2,<-
LKSTS:		!XW			-
LOCK_ID:	!XL>
	PUSHL	BLB$L_RESDSC(R3)
	PRINT	1,<-
RESDSC:		!XL>
	PUSHL	BLB$L_RESDSC+4(R3)
	PRINT	1,<-
RESDSC+4:	!XL>
	PUSHL	BLB$L_VALSEQNO(R3)
	PUSHL	BLB$L_VALBLK(R3)
	PRINT	2,<-
VALBLK:		!XL		-
VALSEQNO:	!XL!-!8UL.>
	PUSHL	BLB$L_VALBLK+4(R3)
	PRINT	1,<-
VALBLK+4:	!XL>
	PUSHL	BLB$L_VALBLK+8(R3)
	PRINT	1,<-
VALBLK+8:	!XL>
	PUSHL	BLB$L_VALBLK+12(R3)
	PRINT	1,<-
VALBLK+12:	!XL>
	STATUS	SUCCESS
	RET
	.DSABL	LSB

	.PAGE
	.SBTTL	SHOW_RLB
;+++
; SHOW_RLB -- Show information from the RLB.
;
; Inputs:
;
;	4(AP) = Address of buffer containing RLB.
;
; Outputs:
;
;	RLB displayed.
;---

SHOW_RLB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of block buffer
	ENSURE	10
	SKIP	1
	PUSHL	-4(R3)			; push virtual addresss of RLB
	PRINT	1,<-
RLB Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	MOVZBL	RLB$B_BID(R3),-(SP)
	PUSHL	RLB$L_LNK(R3)
	PRINT	2,<-
LNK:		!XL		-
BID:		!XB>
	MOVZBL	RLB$B_BLN(R3),-(SP)
	MOVZWL	RLB$W_OWNER(R3),-(SP)
	PRINT	2,<-
OWNER:		!XW	!-!8UW.	-
BLN:		!XB>
	MOVZWL	RLB$W_RFA4(R3),-(SP)
	PUSHL	RLB$L_RFA0(R3)
	PRINT	2,<-
RFA0:		!XL!-!8UL.	-
RFA4:		!XW	!-!8UW.>
	ALLOC	ALLOCSZ,R4
	MOVZBL	RLB$B_FLAGS(R3),-(SP)
	PUSHAB	RLB_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZBL	RLB$B_FLAGS(R3),-(SP)
	PRINT	2,<-
FLAGS:		!XB	!AS>
	PUSHL	RLB$L_LOCK_ID(R3)
	MOVZWL	RLB$W_STATUS(R3),-(SP)
	PRINT	2,<-
STATUS:		!XW			-
LOCK_ID:	!XL>
	STATUS	SUCCESS
	RET

	.PAGE
	.SBTTL	SHOW_ASB
;+++
; SHOW_ASB -- Show useful information from ASB.
;
; Inputs:
;
;	4(AP) = Address of block buffer.
;
; Outputs:
;
;	ASB Displayed.
;---

	.ENABLE	LSB
SHOW_ASB:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of ASB
	SKIP	PAGE
	PUSHL	-4(R3)
	PRINT	1,<-
ASB Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1
	MOVZBL	ASB$B_BLN(R3),-(SP)
	MOVZBL	ASB$B_ARGCNT(R3),-(SP)
	PRINT	2,<-
ARGCNT:		!XB	!-!8UB.	-
BLN:		!XB	!-!8UB.>
	MOVZBL	ASB$B_STKSIZ(R3),-(SP)
	PUSHL	ASB$L_FABRAB(R3)
	PRINT	2,<-
FABRAB:		!XL		-
STKSIZ:		!XB	!-!8UB.>
	PUSHL	ASB$L_ERR(R3)
	PRINT	1,<-
ERR:		!XL>
	PUSHL	ASB$L_SUC(R3)
	PRINT	1,<-
SUC:		!XL>
	SKIP	1
	MOVAL	ASB$L_REGS(R3),R2
	MOVL	(R2)+,-(SP)
	PRINT	1,<-
R6:		!XL>
	MOVL	(R2)+,-(SP)
	PRINT	1,<-
R7:		!XL>
	MOVL	(R2)+,-(SP)
	PRINT	1,<-
R8:		!XL>
	MOVL	(R2)+,-(SP)
	PRINT	1,<-
R10:		!XL>
	MOVL	(R2)+,-(SP)
	PRINT	1,<-
R11:		!XL>
	TSTB	ASB$B_STKSIZ(R3)	; is there any stack?
	BEQL	90$			; if eql no
	SKIP	1
	PRINT	0,<-
Saved Stack:>
	PRINT	0,<-
------------>
	SKIP	1
	MOVL	-4(R3),R2		; get real address of ASB
	ADDL2	#ASB$L_REGS,R2		; skip to saved registers
	ADDL2	#20,R2			; skip over saved registers
	PUSHL	R2			; this is "stack pointer"
	MOVZBL	ASB$B_STKSIZ(R3),-(SP)	; this is "length of stack space"
	ADDL3	(SP),R2,-(SP)		; this is "initial addr of stack"
	CALLS	#3,DUMP_STACK		; dump formatted stack
	BRW	100$
90$:	STATUS	SUCCESS
100$:	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_GBH
;+++
; SHOW_GBH -- Show useful information from Global Buffer Header.
;
;  Inputs:
;
;	 4(AP) = Address of block containing GBH.
;
;  Outputs:
;
;	GBH displayed.
;---

SHOW_GBH:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of block buffer
	SKIP	PAGE			; format display
	PUSHL	-4(R3)			; address of GBH
	PRINT	1,<-
GBH Address: !XL>
	PRINT	0,<-
------------>
	SKIP	1			; one line down
	MOVZBL	GBH$B_BID(R3),-(SP)
	PUSHL	GBH$L_GBD_FLNK(R3)
	PRINT	2,<-
GBD_FLNK:	!XL		-
BID:		!XB>
	MOVZBL	GBH$B_BLN(R3),-(SP)
	PUSHL	GBH$L_GBD_BLNK(R3)
	PRINT	2,<-
GBD_BLNK:	!XL		-
BLN:		!XB>
	ALLOC	ALLOCSZ,R4
	MOVZWL	GBH$W_TRC_FLGS(R3),-(SP)
	PUSHAB	GBH_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	MOVZWL	GBH$W_TRC_FLGS(R3),-(SP)
	PRINT	2,<-
FLGS:		!XW	   !AS>
	PUSHL	GBH$L_TRC_FLNK(R3)
	PUSHL	GBH$L_GBD_START(R3)
	PRINT	2,<-
GBD_START:	!XL		-
TRC_FLNK:	!XL>
	PUSHL	GBH$L_TRC_BLNK(R3)
	PUSHL	GBH$L_GBD_END(R3)
	PRINT	2,<-
GBD_END:	!XL		-
TRC_BLNK:	!XL>
	PUSHL	GBH$L_SCAN_NUM(R3)
	PUSHL	GBH$L_GBD_NEXT(R3)
	PRINT	2,<-
GBD_NEXT:	!XL		-
SCAN_NUM:	!XL!-!8UL.>
	PUSHL	GBH$L_HIT(R3)
	PUSHL	GBH$L_READ(R3)
	PRINT	2,<-
READ:		!XL!-!8UL.	-
HIT:		!XL!-!8UL.>
	PUSHL	GBH$L_MISS(R3)
	PUSHL	GBH$L_WRITE(R3)
	PRINT	2,<-
WRITE:		!XL!-!8UL.	-
MISS:		!XL!-!8UL.>
	PUSHL	GBH$L_GS_SIZE(R3)
	PUSHL	GBH$L_DFW_WRITE(R3)
	PRINT	1,<-
DFW_WRITE:	!XL!-!8UL.	-
GS_SIZE:	!XL!-!8UL.>
	STATUS	SUCCESS
	RET
	.PAGE
	.SBTTL	SHOW_GBD_SUM
;+++
; SHOW_GBD_SUM -- Show summary of GBD information.  In this case that's
; all there is in a GBD.
;
;  Inputs:
;
;	 None.
;
;  Outputs:
;
;	 None.
;--

	.ENABL	LSB
SHOW_GBD_SUM:
	.WORD	^M<R2,R3,R4,R5>
	BBS	#OPT$V_GBDSUM,RMS_DIS_OPT1,10$
5$:	BRW	90$
10$:	MOVAB	GBD,R2			; set up R2 with block buff address
	MOVL	GBH-4,-4(R2)		; begin to set up for "1st" GBD

	ASSUME	GBH$L_GBD_FLNK EQ 0

	MOVL	GBH,GBD$L_FLINK(R2)	; set up forward link
	BEQL	5$
	SKIP	PAGE
	PRINT	0,<-
				GBD Summary>
	PRINT	0,<-
				----------->
	SKIP	1
	PRINT	0,<-
  GBD	 USE				    REL_  CACHE_>
	PRINT	0,<-
Address  CNT  SIZE  NUMB    VBN  BKTSEQNUM  ADDR   VAL   FLAGS>
	PRINT	0,<-
-------  ---  ----  ----    ---  ---------  ----   ---   ----->
	SKIP	1

	ALLOC	ALLOCSZ,R4
	CLRL	R3			; R3 = count of GBD's
	MOVL	GBH$L_GBD_BLNK+GBH,R5	; R5 = address of last GBD
	ADDL2	GBH-4,R5		; make absolute address

20$:	ADDL2	-4(R2),GBD$L_FLINK(R2)	; make rel addr abs addr
	GET	GBD,@GBD$L_FLINK(R2),90$
	INCL	R3			; count the GBD's found

	MOVL	#ALLOCSZ,(SP)
	MOVZBL	GBD$B_FLAGS(R2),-(SP)
	PUSHAB	GBD_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4

	MOVZBL	GBD$B_CACHE_VAL(R2),-(SP)
	PUSHL	GBD$L_REL_ADDR(R2)
	PUSHL	GBD$L_BKTSEQNUM(R2)
	PUSHL	GBD$L_VBN(R2)
	MOVZWL	GBD$W_NUMB(R2),-(SP)
	MOVZWL	GBD$W_SIZE(R2),-(SP)
	MOVZWL	GBD$W_USECNT(R2),-(SP)
	PUSHL	-4(R2)
	PRINT	9,<-
!XL !3UW !5UW !5UW !7SL !XL !XL !3UB !AS>
	CMPL	-4(R2),R5		; is it last GBD?
	BEQL	80$			; if eql yes
	BRW	20$			; go back for more

80$:	PUSHL	R3			; print count of GBD's
	SKIP	1
	PRINT	1,<-
	!8UL. GBD's>

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB
	.PAGE
	.SBTTL	SHOW_TRACE
;+++
; SHOW_TRACE -- Show trace information from trace block pool.
;
; Inputs:
;
;	 4(AP) = Address of trace queue header in SDA process
;	 8(AP) = Address of trace queue header in dumped process
;	12(AP) = Trace flags (1=yes)
;	16(AP) = Depth to trace (0=all)
;
; Outputs:
;
;	Trace contents dumped to current output file/device.
;---

	.ENABL	LSB
SHOW_TRACE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVQ	4(AP),R4		; get arguments
	MOVQ	12(AP),R6		; more arguments
	MOVAL	TRC,R2			; address of TRC block buffer

;
; Note well that trace queue is a self relative queue!
;
; R2 = Address of trace block buffer (in SDA)
; R4 = Address of trace queue header (in SDA)
; R5 = Address of trace queue header in process being dumped
; R6 = Trace Flags
; R7 = Depth (0=all)
;

3$:	MOVL	4(R4),TRC$L_BLNK(R2)	; move q header back link
	BNEQ	5$			; if neq queue is not empty
	BRW	90$			; if eql empty queue
5$:	MOVL	R5,-4(R2)		; fake up address of trc block
					;  from address of queue header
	MOVL	(R4),TRC$L_FLNK(R2)	; set up to scan queue from front
	TSTL	R7			; check trace depth
	BEQL	15$			; do entire q -- we're already set
	MOVL	4(R4),R9		; begin to form real address of end
	ADDL	R5,R9			; form real address from self rel one
	INCL	R7			; bump depth to account for algorithm

;
; At this point, we have a non-zero depth.  We will scan the trace queue
; from the front until we have passed over the necessary number of queue
; entries.  No dumping is done at this point, as we are going in the wrong
; order.  After we have passed over the proper number of queue entries, the
; we will enter the loop that scans them in the other direction, dumping
; as it goes.
;
; R2 = address of trace queue block buffer ( TRC )
; R7 = Depth (initially +1)
; R9 = Address of last trace queue entry (when we get there we're done)
;

10$:	ADDL	-4(R2),TRC$L_FLNK(R2)	; make self-rel q absolute address
	GET	TRC,@TRC$L_FLNK(R2),90$	; get next trace queue element
	DECL	R7			; count this one in the down count
	BEQL	15$			; we've done enough
12$:	CMPL	-4(R2),R9		; are we done with all elements?
	BNEQ	10$			; if neq no, do some more
	BRW	3$			; yes, too bad.  Go dump them all.

;
; Now we are about to go into the loop which scans from the trace
; element currently in the TRC block buffer, forward until the
; beginning of the queue.  The TRC block buffer either has the depth+1'th
; element in it, or it has enough of the queue header such that
; scanning forward from it will work.
;

15$:	MOVL	TRC$L_FLNK(R2),R9	; begin to form address of newest entry
	ADDL	-4(R2),R9			; turn it into absolute address

;
; Set up constant part of header
;

	SKIP	PAGE
	PRINT	0,<-
				RMS Trace>
	PRINT	0,<-
				--------->
	SKIP	3
	ALLOC	ALLOCSZ,R4		; set up translate bits buffer
	PRINT	0,<-
          PROC								  TRC>
	PRINT	0,<-
OPERATION  IN  STRUCTURE    VBN 			SEQUENCE        ADDRESS>
	PRINT	0,<-
---------  --  ---------    --- 			--------        ------->
	SKIP 1

;
; R2 = pointer to TRC block buffer
; R6 = trace flags
; R9 = pointer to latest entry in the trace queue, after which we should stop
;

20$:	ADDL	-4(R2),TRC$L_BLNK(R2)	; turn rel into absolute address
	GET	TRC,@TRC$L_BLNK(R2),90$	; get next trace block

;
; Process this trace block for display information
;

	BITL	TRC$W_FUNCTION(R2),R6	; is this trace block wanted?
	BNEQ	21$
	BRW	50$
21$:	MOVL	#ALLOCSZ,(SP)		; renew translate_bits buffer
	MOVZWL	TRC$W_FUNCTION(R2),-(SP) ; put bits to translate
	PUSHAB	GBH_CHR			; translation table
	CALLS	#2,TRANSLATE_BITS	; do the translation

	PUSHL	-4(R2)			; virtual address of trace block
	MOVZWL	TRC$W_SEQNUM(R2),-(SP)	; sequence number of this trace block
	PUSHL	TRC$L_VBN(R2)
	PUSHL	TRC$L_STRUCTURE(R2)
	MOVZWL	TRC$W_PID(R2),-(SP)	; just process index portion of pid
	PUSHL	R4			; the function type
	PRINT	6,<-
!9AS !XW !XL !7UL 			 !5UW          !XL>


	BITL	#<GBH$M_CACHE_IN!GBH$M_RLS_IN>,TRC$W_FUNCTION(R2) ; interesting
	BEQL	25$			; if eql no, just do return2

;
; Dump the argument flags for cache and release
;
; If not cache or release, just dump return status (ARG_FLG for now)
;

	MOVL	#ALLOCSZ,(SP)
	PUSHL	TRC$L_ARG_FLG(R2)
	PUSHAB	RLS_CHR
	BBS	#GBH$V_RLS_IN,TRC$W_FUNCTION(R2),22$
	MOVAB	CSH_CHR,(SP)
22$:	CALLS	#2,TRANSLATE_BITS

	PUSHL	R4
	PUSHL	TRC$L_ARG_FLG(R2)
	PRINT	2,<-
				ARGFLG=!XL !AS>
	BRB	30$
25$:	PUSHL	TRC$L_ARG_FLG(R2)
	PRINT	1,<-
				R0=!XL>

;
; Symbolize the return addresses
;

30$:	TSTL	TRC$L_RETURN1(R2)	; should we dump returns?
	BEQL	35$			; if return1=0 then no.
	MOVL	#ALLOCSZ,(SP)		; reset string buffer
	PUSHL	R4			; address of buffer descriptor
	PUSHL	TRC$L_RETURN1(R2)	; address of return
	CALLS	#2,SYMBOLIZE		; get string for this symbol
	PUSHL	R1			; address of descriptor
	PUSHL	TRC$L_RETURN1(R2)	; address itself
	PRINT	2,<-
				RETURN=!XL !AS>
	MOVL	#ALLOCSZ,(SP)
	PUSHL	R4
	PUSHL	TRC$L_RETURN2(R2)
	CALLS	#2,SYMBOLIZE
	PUSHL	R1
	PUSHL	TRC$L_RETURN2(R2)
	PRINT	2,<-
				       !XL !AS>

;
; If this element is proper, then dump the BDB information held within
; the element.  Allow TRC$L_BDB_ADDR = 0 to signal no BDB information.
;

35$:	TSTL	TRC$L_BDB_ADDR(R2)	; if the address = 0
	BEQL	40$			; if eql yes, skip BDB
	PUSHL	TRC$L_BDB_SEQ(R2)	; buffer sequence number
	MOVZWL	TRC$W_BDB_BUFF(R2),-(SP)
	MOVZBL	TRC$B_BDB_CACHE(R2),-(SP)
	MOVZWL	TRC$W_BDB_USERS(R2),-(SP)
	PUSHL	TRC$L_BDB_ADDR(R2)
	PRINT	5,<-
			        BDB=!XL U=!4UW C=!XB B=!XW S=!XL>

;
; Interpret and dump flags, if any.
;

	TSTB	TRC$B_BDB_FLAGS(R2)
	BEQL	40$
	MOVL	#ALLOCSZ,(SP)
	MOVZBL	TRC$B_BDB_FLAGS(R2),-(SP)
	PUSHAB	BDB_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	PRINT	1,<-
				  F=!AS>

;
; Print the BLB trace information if the TRC$L_BLB_ADDR doesn't equal zero.
;

40$:	TSTL	TRC$L_BLB_ADDR(R2)
	BEQL	50$
	PUSHL	TRC$L_BLB_SEQ(R2)	; blb sequence number
	PUSHL	TRC$L_BLB_LOCK(R2)
	MOVZBL	TRC$B_BLB_MODE(R2),R3	; get the mode held byte
	CMPB	#6,R3			; is it less then 6
	BGTRU	42$			; if gtru then yes
	MOVZBL	#6,R3			; set to 6 (i.e. ??)
42$:	PUSHL	BLB_TBL[R3]		; set translation into args
	PUSHL	TRC$L_BLB_ADDR(R2)
	PRINT	4,<-
			        BLB=!XL M=!AC L=!XL    S=!XL>

;
; Interpret flags (if any).
;

	TSTB	TRC$B_BLB_FLAGS(R2)
	BEQL	50$
	MOVL	#ALLOCSZ,(SP)
	MOVZBL	TRC$B_BLB_FLAGS(R2),-(SP)
	PUSHAB	BLB_CHR
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4
	PRINT	1,<-
				  F=!AS>
;
; End of display, loop for next trace element
;

50$:	CMPL	-4(R2),R9		; is this the last element?
	BEQL	90$
	BRW	20$

90$:	STATUS	SUCCESS
	RET
	.DSABL	LSB 
	.PAGE
	.SBTTL	SHOW_NAM
;+++
; SHOW_NAM -- Show valuable information in NAM block.
;
; Inputs:
;
;	4(AP) = Address of NAM block in "Block Buffer".
;
; Outputs:
;
;	None.
;---

SHOW_NAM:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R2		; Get address of buffer in R2
	PUSHAL	NAM$T_DVI(R2)		; Push address of Device ID Field
	PUSHL	NAM$L_ESA(R2)		; Expanded string address
	MOVZBL	NAM$B_ESL(R2),-(SP)	; Expanded string length
	PUSHL	NAM$L_RSA(R2)		; Resultant string address
	MOVZBL	NAM$B_RSL(R2),-(SP)	; Resultant string length
	PRINT	5,<-
Resultant String Name:	!AF!/-
Expanded String Name:	!AF!/-
Device Identification:	!AC>
	PRINT	0,<-
					RVN	File #	  File Seq. #!/-
					---	------	  ----------->
	ALLOC	80,R4			; Allocate buffer for status bits
	PUSHL	NAM$L_FNB(R2)		; Set up args to TRANSLATE_BITS
	PUSHAB	NAM_CHR			; Character translation table
	CALLS	#2,TRANSLATE_BITS
	PUSHL	R4			; Send buffer to print routine
	PUSHL	NAM$L_FNB(R2)		; Send bare bits too
	PRINT	2,<-
Status Bits (FNB):	!XL	!AS>
	PUSHL	NAM$L_WCC(R2)		; Set up wildcard context bits
	PRINT	1,<-
Wildcard Context:	!XL>
	RET
	.PAGE
	.SBTTL	GET_IFAB
;+++
; GET_IFAB -- Get and Verify IFAB from Dump.
;
; Inputs:
;
;	4(AP) = Block Buffer.
;
; Outputs:
;
;	Buffer contains IFAB if success.
;	If failure, BUFFER-4 = 0.
;---

GET_IFAB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; Get address of buffer
	GETMEM	@-4(R3),(R3),#IFB$C_BLN
	BLBC	R0,100$
	CMPB	#IFB$C_BID,IFB$B_BID(R3)
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_IDX
;+++
; GET_IDX -- Get and verify Index descriptor.
;
; Inputs:
;
;	4(AP) = Address of block buffer.
;
; Outputs:
;
;	Buffer contains index descriptor.
;---

GET_IDX:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer
	GETMEM	@-4(R3),(R3),#IDX$C_FIXED_BLN+32
	BLBC	R0,100$
	CMPB	#IDX$C_BID,IDX$B_BID(R3)
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_FWA
;+++
; GET_FWA -- Get and verify FWA if any.
;
;  Inputs:
;
;	4(AP) = Address of block buffer for FWA.
;
;  Outputs:
;
;	Buffer contains FWA.
;---

GET_FWA:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer
	GETMEM	@-4(R3),(R3),#FWA$C_BLN
	BLBC	R0,100$
	CMPB	FWA$B_UNDERLINE(R3),#^A'_' ; is there an underline in the 
					; right place?
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_CCB
;+++
; GET_CCB -- Get and verify Channel Control Block from dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer.
;
; Outputs:
;
;	Block buffer contains CCB.
;---

GET_CCB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3
	GETMEM	@CTL$GL_CCBBASE,(R3),#4
	SUBL3	-4(R3),(R3),-4(R3)
	GETMEM	@-4(R3),(R3),#CCB$C_LENGTH
	BLBC	R0,100$
	STATUS	INVBLKTYP
	TSTB	CCB$B_AMOD(R3)
	BEQL	100$
	STATUS	SUCCESS
100$:	RET
	.PAGE
	.SBTTL	GET_WCB
;+++
; GET_WCB -- Get and verify Window Contol Block from dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer.
;
; Outputs:
;
;	Block buffer contains WCB.
;---

GET_WCB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3
	GETMEM	@-4(R3),(R3),#WCB$C_LENGTH+512
	BLBC	R0,100$
	CMPB	#DYN$C_WCB,WCB$B_TYPE(R3)
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_FCB
;+++
; GET_FCB -- Get and verify File Control Block from dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer.
;
; Outputs:
;
;	Block buffer contains FCB.
;---

GET_FCB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3
	GETMEM	@-4(R3),(R3),#FCB$C_LENGTH
	BLBC	R0,100$
	CMPB	#DYN$C_FCB,FCB$B_TYPE(R3)
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_IRAB
;+++
; GET_IRAB -- Get and Verify IRAB from Dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer for IRAB.
;
; Outputs:
;
;	IRAB in block buffer if success, R) contains
;	code if failure.
;---

GET_IRAB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; get address of IRAB buffer
	GETMEM	@-4(R3),(R3),#IRB$C_BLN_IDX ; get what is supposed to be IRAB
	BLBC	R0,100$			; if error
	CMPB	#IRB$C_BID,IRB$B_BID(R3) ; is this really IRAB?
	BNEQ	99$			; if ne no, must be imposter
	CMPL	IRB$L_IFAB_LNK(R3),IFAB-4 ; is this correct IRAB for IFAB?
	BNEQ	99$			; if neq, then no.  Error
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET

	.PAGE
	.SBTTL	GET_BDB
;+++
; GET_BDB -- Get and verify BDB.
;
; Inputs:
;
;	4(AP) = Address of buffer to fill with BDB.
;
; Ouputs:
;
;	None.
;---

GET_BDB:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer for BDB
	GETMEM	@-4(R3),(R3),#BDB$C_BLN
	BLBC	R0,100$			; if error in memory access
	CMPB	#BDB$C_BID,BDB$B_BID(R3) ; is this valid BDB?
	BNEQ	95$
90$:	STATUS	SUCCESS
	RET
95$:	CMPB	#GBPB$C_BID,BDB$B_BID(R3) ; is it perchance GBPB?
	BEQL	90$			; if eql yes, allow it.
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_BLB
;+++
; GET_BLB -- Get and verify BLB.
;
; Inputs:
;
;	4(AP) = Address of buffer to fill with BLB.
;
; Ouputs:
;
;	None.
;---

GET_BLB:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer for BLB
	GETMEM	@-4(R3),(R3),#BLB$C_BLN
	BLBC	R0,100$			; if error in memory access
	CMPB	#BLB$C_BID,BLB$B_BID(R3) ; is this valid BLB?
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_GBD
;+++
; GET_GBD -- Get and verify GBD.
;
;  Inputs:
;
;	4(AP) = Address of buffer to fill with GBD.
;
;  Ouputs:
;
;	Valid GBD.
;---

GET_GBD:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer for GBD
	GETMEM	@-4(R3),(R3),#GBD$C_BLN
	BLBC	R0,100$			; if error in memory access
	CMPB	#GBD$C_BID,GBD$B_BID(R3) ; is this valid GBD?
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_TRC
;+++
; GET_TRC -- Get and verify TRC.
;
; Inputs:
;
;	4(AP) = Address of buffer to fill with TRC.
;
; Ouputs:
;
;	None.
;---

GET_TRC:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer for TRC
	GETMEM	@-4(R3),(R3),#TRC$C_BLN
	BLBC	R0,100$			; if error in memory access
	CMPB	#TRC$C_BID,TRC$B_BID(R3) ; is this valid TRC?
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_GBH
;+++
; GET_GBH -- Get and verify GBH.
;
; Inputs:
;
;	4(AP) = Address of buffer to fill with GBH.
;
; Ouputs:
;
;	None.
;---

GET_GBH:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of buffer for GBH
	GETMEM	@-4(R3),(R3),#GBH$C_BLN
	BLBC	R0,100$			; if error in memory access
	CMPB	#GBH$C_BID,GBH$B_BID(R3) ; is this valid GBH?
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_RLB
;+++
; GET_RLB -- Get an RLB from the dump file.
;
; Inputs:
;
;	4(AP) = Address of block buffer for RLB.
;
; Outputs:
;
;	RLB in block buffer.
;---

GET_RLB:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3		; address of block buffer
	GETMEM	@-4(R3),(R3),#RLB$C_BLN ; get memory from dump for this rlb
	BLBC	R0,100$			; if error pass it back up
	CMPB	#RLB$C_BID,RLB$B_BID(R3) ; is this rlb?
	BNEQ	99$			; if neq no -- error
	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET

	.PAGE
	.SBTTL	GET_ASB
;+++
; GET_ASB -- Get an ASB from Dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer for ASB.
;
; Outputs:
;
;	ASB in block buffer.
;---

GET_ASB:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3
	GETMEM	@-4(R3),(R3),#ASB$C_BLN_IDX
	BLBC	R0,100$
	STATUS	SUCCESS
100$:	RET
	.PAGE
	.SBTTL	GET_FAB
;+++
; GET_FAB -- Get and Verify FAB from Dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer for FAB.
;	IFI   = Contains the IFI of the current IFAB.
;
; Outputs:
;
;	FAB in block buffer if success, R0 contains
;	code if failure.  BUFFER-4 = 0 if failure.
;---
 
GET_FAB:
	.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3
	GETMEM	@-4(R3),(R3),#FAB$C_BLN
	BLBC	R0,100$

	CMPB	#FAB$C_BID,FAB$B_BID(R3)
	BNEQ	99$
	CMPW	IFI,FAB$W_IFI(R3)	; Is this the FAB for this IFAB
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET
	.PAGE
	.SBTTL	GET_NAM
;+++
; GET_NAM -- Get and Verify NAM block from Dump.
;
; Inputs:
;
;	4(AP) = Address of block buffer for NAM block.
;
; Outputs:
;
;	Block buffer contains NAM block if success,
;	BUFFER-4 = 0 if failure, R0 = status.
;---

GET_NAM:.WORD	^M<R2,R3,R4>
	MOVL	4(AP),R3
	GETMEM	@-4(R3),(R3),#NAM$C_BLN
	BLBC	R0,100$
	CMPB	#NAM$C_BID,NAM$B_BID(R3)
	BNEQ	99$
90$:	STATUS	SUCCESS
	RET
99$:	STATUS	INVBLKTYP
100$:	RET

	.END
