	.TITLE	COMMANDS	PARSE AND EXECUTE SDA COMMANDS
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	THIS MODULE ACCEPTS COMMANDS FROM THE PRIMARY
;	INPUT DEVICE AND PERFORMS THE SYNTAX PARSING.
;	THE CORRECT ROUTINE IS THEN CALLED TO EXECUTE
;	THE COMMAND.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V007	MTR0002		Mike Rhodes	 27-Jul-1981
;		Change SDA help to not prompt.
;
;	V006	MTR0001		Mike Rhodes	19-Jun-1981
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;
;		Change default addressing mode to longword.
;
;		1.  Remove references to macro $SDAMSGDEF.
;
;		2.  Modify routine GET_COMMANDS reference to condition
;		handler entry point (from CMD_HANDLER to HANDLER) for
;		standardized error handling.
;
;		3.  Rewrite routine DISPLAY_HELP to use the librarian
;		routine LBR$OUTPUT_HELP.
;
;	V005	TMH0005		Tim Halvorsen	21-May-1981
;		Remove READ/RELOCATE modifications in previous update,
;		since the relocation must be done within ADD_SYMBOL
;		based on whether the symbol already exists or not (we
;		can't relocate the values for symbols which already exist,
;		such as structure definitions).
;
;	V004	TMH0004		Tim Halvorsen	20-May-1981
;		Upcase all commands.  Add '@' and SEARCH commands.
;		Add READ/RELOCATE qualifier.  Increase size of symbolize
;		string buffer on EXAMINE command.
;
;	V003	TMH0003		Tim Halvorsen	07-Feb-1981
;		Add EXAMINE/INSTRUCTION.
;
;	V002	TMH0002		Tim Halvorsen	19-Dec-1980
;		Fix current process context so that it remembers /SYSTEM
;		from one SHOW PROCESS to another.
;
;	V001	TMH0001		Tim Halvorsen	30-Sep-1980
;		Use general addressing to reference LIB$SIGNAL
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$TPADEF			; TPARSE DEFINITIONS
	$PCBDEF			; PROCESS CONTROL BLOCK
	$PHDDEF			; PROCESS HEADER DEFINITIONS
	$OPTDEF			; DEFINE BITS IN OPTIONS WORD
	$SHRDEF			; SHARED ERROR MESSAGES
	$DMPDEF			; DUMP HEADER DEFINITIONS
	$EMBDEF <CR>		; CRASH ERROR LOG ENTRY
	$FABDEF			; FILE ACCESS BLOCK
	$RABDEF			; RECORD ACCESS BLOCK
	$OBJDEF			; OBJECT MODULE DEFINITIONS
	$STSDEF			; MESSAGE FIELD DEFINITIONS
	$CHFDEF			; CONDITION HANDLER FIELD DEFINITIONS
	$SSDEF			; SYSTEM SERVICE CONDITION CODE DEF'S
	$HLPDEF			; HELP LIBRARY MASK DEFINITIONS


	.SBTTL	STORAGE DEFINITIONS
;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

HELP_FLAGS:	.LONG	HLP$M_PROCESS!- ;Library search & Prompt options
			HLP$M_GROUP!-
			HLP$M_SYSTEM
HELP_LIBRARY:	.ASCID	/SYS$HELP:SDA.HLB/

TPARSE_BLOCK:
	.LONG	TPA$K_COUNT0		; LONGWORD IN BLOCK
	.LONG	TPA$M_ABBREV		; ABBREVIATIONS ALLOWED
	.BLKL	TPA$K_COUNT0-1		; REMAINDER OF BLOCK

; STACK USED FOR EVALUATION OF EXPRESSIONS
ESP::	.LONG	EXPR_STACK		; STACK POINTER
	.BLKL	50
EXPR_STACK:				; STARTING STACK POINTER

INPUT_RAB:
	.LONG	INPUT			; ADDRESS OF CURRENT INPUT RAB
					; INITIALLY PRIMARY INPUT RAB
					; (MAY BE CHANGED TO INDIRECT RAB)

OPTIONS::
	.BLKL	1			; OPTIONS FOR COMMAND

RELOCATE_BASE::
	.BLKL	1			; READ/RELOCATE BASE ADDRESS

PROC_NAME::
	.BLKQ	1			; PROCESS NAME

SYMBOL_NAME::
	.BLKQ	1			; SYMBOL NAME

FILE_DESC::
	.BLKQ	1			; FILE NAME DESCRIPTOR

PROC_INDEX::
	.LONG	-1			; PROCESS INDEX

PROC_PID::
	.BLKL	1			; PROCESS PID

CURRENT_PID:
	.BLKL	1			; PID OF PROCESS RUNNING DURING CRASH

ADDRESS::
	.LONG	0			; CURRENT MEMORY ADDRESS

DATALEN:
	.LONG	0			; LENGTH OF PREVIOUS DATA ITEM

SYMBOL_DESC::
	.BLKQ	1			; SYMBOL NAME TO BE DEFINED

	.PSECT	COMMANDS,EXE,NOWRT,LONG

;
; READ-ONLY STORAGE DEFINITIONS
;

	.MACRO	NORMAL FIRST,LAST	; MACRO TO DEFINE "NORMAL" INSTRUCTIONS
.=NORMAL_INSTRS+FIRST
	.IF B	LAST			; IF LAST UNSPECIFIED, LOOP ONCE
	$$ = 1
	.IFF
	$$ = LAST+1-FIRST
	.ENDC
	.REPT	$$
	.BYTE	1
	.ENDR
	.ENDM

NORMAL_INSTRS:				; BYTEMASK OF REASONABLE INSTRUCTIONS
					; (ITS ONLY A BYTEMASK CAUSE I DON'T
					;  KNOW HOW TO CONSTRUCT THE BITMASK).
	.REPT	256/8
	.QUAD	0			; PRESET ALL TO "UNREASONABLE"
	.ENDR

	.SAVE				; SAVE CURRENT "."
	NORMAL	4,5			; RET THRU RSB
	NORMAL	12,27			; PROBER THRU BLEQU
	NORMAL	30,31			; BGEQU THRU BLSSU
	NORMAL	40,41			; MOVC3 THRU CMPC3
	NORMAL	44,45			; MOVC5 THRU CMPC5
	NORMAL	48,50			; BSBW THRU CVTWL
	NORMAL	58			; LOCC
	NORMAL	60			; MOVZWL
	NORMAL	120			; ASHL
	NORMAL	124,139			; CLRQ THRU BICB3
	NORMAL	144,145			; MOVB THRU CMPB
	NORMAL	147,156			; BITB THRU ROTL
	NORMAL	158,171			; MOVAB THRU BICW3
	NORMAL	176,183			; MOVW THRU DECW
	NORMAL	186,187			; PUSHR THRU POPR
	NORMAL	192,206			; ADDL2 THRU MNEGL
	NORMAL	208,215			; MOVL THRU DECL
	NORMAL	218,233			; MTPR THRU BLBC
	NORMAL	236,240			; CMPV THRU INSV
	NORMAL	242,245			; AOBLSS THRU SOBGTR
	NORMAL	250,251			; CALLG THRU CALLS
	NORMAL	255			; BUGCHECK
	.RESTORE

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	GET_COMMANDS -- ACCEPT AND EXECUTE COMMANDS
;---
;
;	GET_COMMANDS
;
;	THIS ROUTINE ACCEPTS THE NEXT COMMAND FROM THE PRIMARY
;	INPUT FILE, PARSES THE COMMAND AND EXECUTES IT.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	R0 = TRUE IF COMMAND EXECUTED, FALSE IF EMPTY LINE
;
;---
	.ENABL	LSB

PROMPT:
	.ASCIC	<10>'SDA> '

GET_COMMANDS::
	.WORD	^M<R2,R3>

	MOVAL	HANDLER,(FP)		; SETUP CONDITION HANDLER
	MOVAB	TPARSE_BLOCK,R3		; SET ADDRESS OF TPARSE BLOCK
;	WARNING -- THE HANDLER KNOWS ABOUT THE FOLLOWING 2 LINES
	PUSHL	OPTIONS			; SAVE OPTIONS LONGWORD
	MOVQ	SUB_HEADING,-(SP)	; SAVE CURRENT HEADING

	MOVL	INPUT_RAB,R2		; ADDRESS OF INPUT RAB
	MOVAB	CMND_BUFFER,RAB$L_UBF(R2)	; INPUT BUFFER
	MOVW	#CMND_BUFFER_LEN,RAB$W_USZ(R2)
	MOVAL	PROMPT+1,RAB$L_PBF(R2)	; PROMPT ADDRESS
	MOVB	PROMPT,RAB$B_PSZ(R2)	; PROMPT LENGTH
	CLRL	LINE_COUNT		; 1ST PAGE EJECT W/O PROMPT
	$GET	(R2)
	CMPL	#RMS$_EOF,R0		; CHECK IF END OF FILE
	BNEQ	10$			; BRANCH IF NOT
	SIGNAL	0,EOF			; SIGNAL END OF FILE
10$:
	SIGNAL	RMS,(R2)		; CHECK FOR OTHER RMS ERRORS

;
;	IF THE ESCAPE KEY WAS TYPED, REPEAT THE LAST COMMAND.
;

	CMPW	RAB$L_STV(R2),#^X1B	; IS TERMINATOR ESCAPE KEY?
	BNEQ	45$			; BRANCH IF NOT
	CALLG	(R3),REPEAT_COMMAND	; RESTORE PREV. COMMAND
	BRB	50$			; AND EXECUTE IT

;
;	PARSE THE COMMAND
;

45$:	MOVL	RAB$L_RBF(R2),TPA$L_STRINGPTR(R3)
	MOVZWL	RAB$W_RSZ(R2),TPA$L_STRINGCNT(R3)
	BNEQ	50$			; BRANCH IF NOT EMPTY
	CLRL	R0			; INDICATE EMPTY LINE
	BRB	90$			; EXIT
50$:
	PUSHAB	TPA$L_STRINGCNT(R3)	; ADDRESS OF INPUT STRING DESCRIPTOR
	PUSHL	(SP)			; OVERWRITE STRING WITH RESULT
	CALLS	#2,G^STR$UPCASE		; UPCASE COMMAND LINE
	CLRL	OPTIONS			; INITIALIZE OPTIONS LONGWORD
	CLRL	RELOCATE_BASE		; INITIALIZE RELOCATION BASE
	MOVAL	EXPR_STACK,ESP		; INITIALIZE EXPRESSION STACK
	MOVQ	TPA$L_STRINGCNT(R3),-(SP) ; SAVE DESCRIPTOR OF COMMAND
	PUSHAL	L^SDA_KEY		; KEY TABLE ADDRESS
	PUSHAL	L^SDA_STATE		; STATE TABLE ADDRESS
	PUSHL	R3			; TPARSE BLOCK
	CALLS	#3,G^LIB$TPARSE		; PARSE AND EXECUTE THE COMMAND
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	MOVQ	(SP)+,TPA$L_STRINGCNT(R3) ; RESTORE COMMAND DESCRIPTOR
	BLBS	R0,80$			; BRANCH IF NO ERROR
;
;	SIGNAL SYNTAX ERROR FROM PARSE
;
	EXTZV	#16,#16,R0,R1		; CHECK FACILITY CODE
	BNEQ	60$			; BRANCH IF NOT SDA ERROR MSG
	SIGNAL				; SIGNAL ERROR CONDITION
	BRB	80$
60$:
	MOVL	#SHR$_SYNTAX!<3@16>,R0	; CLI-W-SYNTAX MESSAGE
	PUSHAB	TPA$L_TOKENCNT(R3)	; DESCRIPTOR OF BAD TOKEN
	SIGNAL	1			; SIGNAL WITH 1 FAO ARG.
80$:
	STATUS	SUCCESS			; COMMAND EXECUTED
90$:
	MOVQ	(SP)+,SUB_HEADING	; RESTORE SUB_HEADING
	POPL	OPTIONS			; RESTORE OPTIONS WORD
	RET

	.DSABL	LSB

	.SBTTL	INDIRECT_COMMAND --INDIRECT FILE PROCESSING
;+
;	INDIRECT_COMMAND
;
; INPUTS:
;
;	AP = ADDRESS OF TPARSE CONTROL BLOCK
;
; OUTPUTS:
;
;	ACTION ROUTINE TO OPEN AN INDIRECT COMMAND FILE
;	AND PROCESS THE COMMANDS.
;-
	.ENTRY	INDIRECT_COMMAND, ^M<R2, R3, R4, R5>

	MOVAB	INDRAB, R3		; R3 = ADDRESS OF RAB
	MOVL	RAB$L_FAB(R3),R2	; R2 = ADDRESS OF FAB
	CMPL	INPUT_RAB, R3		; ONLY ONE LEVEL OF INDIRECTION
	BEQL	10$			; BR IF RECURSIVE AND EXIT

	CVTWB	TPA$L_TOKENCNT(AP),-
		FAB$B_FNS(R2)		; SET FILE NAME LENGTH
	MOVL	TPA$L_TOKENPTR(AP),-
		FAB$L_FNA(R2)		; SET FILE NAME ADDRESS

	$OPEN	(R2)			; ATTEMPT TO OPEN THE FILE
	BLBS	R0, 20$			; BRANCH IF OK
	PUSHL	FAB$L_FNA(R2)		; CREATE DESCRIPTOR OF FILE NAME
	MOVZBL	FAB$B_FNS(R2), -(SP)
	MOVQ	R0, -(SP)		; RMS ERROR CODES
	INSV	#STS$K_WARNING,-	; CHANGE SEVERITY TO WARNING
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		(SP)
	PUSHAB	8(SP)			; ADDRESS OF FILE NAME DESCRIPTOR
	PUSHL	#1			; NUMBER OF FAO ARGUMENTS
	PUSHL	#SHR$_OPENIN!<3@16>	; "ERROR OPENING INPUT FILE !AS"
	CALLS	#5, G^LIB$SIGNAL	; OUTPUT ERROR MESSAGE
10$:	BRW	50$			; EXIT WITH SUCCESS

20$:	$CONNECT (R3)			; CONNECT FOR RECORD ACCESS
	SIGNAL	RMS, (R3)		; REPORT ANY ERRORS

	CALLG	(AP),REPEAT_COMMAND	; GET DESCRIPTOR OF @ COMMAND
	SUBL	TPA$L_STRINGCNT(AP),SP	; ALLOCATE BUFFER TO HOLD @ COMMAND
	PUSHR	#^M<R2,R3>
	MOVC	TPA$L_STRINGCNT(AP),@TPA$L_STRINGPTR(AP),8(SP) ; PUSH ONTO STACK
	POPR	#^M<R2,R3>
	PUSHL	TPA$L_STRINGCNT(AP)	; SAVE LENGTH OF @ COMMAND STRING
	PUSHL	INPUT_RAB		; SAVE RAB ACROSS PROCEDURE
	MOVL	R3, INPUT_RAB		; SETUP INDIRECT FILES RAB AS INPUT
30$:
	CLRL	LINE_COUNT		; AVOID END OF PAGE PROMPTS
	CALLS	#0, GET_COMMANDS	; ACCEPT AND EXECUTE COMMANDS
	CMPL	R0, #MSG$_EOF		; CHECK IF END OF FILE
	BEQL	40$			; BRANCH IF SO
	CMPL	R0, #MSG$_EXITCMD	; DID WE JUST EXIT A LEVEL?
	BNEQ	30$			; BRANCH IF NOT
	CLRQ	SUB_HEADING		; CLEAR CURRENT HEADING
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	SKIP	PAGE			; ERASE PREVIOUS JUNK
	BRB	20$
40$:
	POPL	INPUT_RAB		; RESTORE RAB ADDRESS
	POPL	TPA$L_STRINGCNT(AP)	; RESTORE LENGTH OF @ STRING
	MOVL	SP,TPA$L_STRINGPTR(AP)	; SET ADDRESS OF COPY OF STRING
	CALLG	(AP),SAVE_COMMAND	; SAVE AS PREVIOUS COMMAND
	$CLOSE	FAB=(R2)		; CLOSE THE COMMAND FILE
	SIGNAL	RMS,(R2)		; REPORT ANY ERRORS
50$:
	MOVL	#1, R0			; RETURN SUCCESS
	RET

	.SBTTL	EXIT_COMMAND -- PROCESS EXIT COMMAND
;---
;
;	EXIT_COMMAND
;
;	EXIT COMMAND ACTION ROUTINE
;
;   OUTPUTS:
;
;	END OF FILE IS SIGNALED
;
;---

EXIT_COMMAND::
	.WORD	0

	SIGNAL	0,EOF			; SIGNAL END OF FILE

	.SBTTL	DEFINE_SYMBOL -- DEFINE LOCAL SYMBOL
;---
;
;	DEFINE_SYMBOL
;
;	THIS ROUTINE ADDS A SYMBOL TO THE LOCAL SYMBOL
;	TABLE WITH AN ASSOCIATED VALUE.
;
;   INPUTS:
;
;	AP = ADDRESS OF TPARSE PARAMETER BLOCK
;	SYMBOL_DESC = DESCRIPTOR OF SYMBOL
;	TPA$L_NUMBER(AP) = VALUE TO BE ASSIGNED TO SYMBOL
;
;---

DEFINE_SYMBOL::
	.WORD	0

	PUSHL	TPA$L_NUMBER(AP)		; VALUE OF SYMBOL
	MOVQ	SYMBOL_DESC,-(SP)		; SYMBOL DESCRIPTOR
	CALLS	#3,ADD_SYMBOL			; ADD TO SYMBOL TABLE
	RET

	.SBTTL	SHOW_SYMBOL -- DISPLAY SYMBOL VALUE
;---
;
;	SHOW_SYMBOL
;
;	THIS ROUTINE DISPLAYS THE VALUE OF A SPECIFIED SYMBOL
;	AND THE CONTENTS OF THAT MEMORY LOCATION IF POSSIBLE.
;
;   INPUTS:
;
;	SYMBOL_NAME = DESCRIPTOR OF SYMBOL
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_SYMBOL::
	.WORD	^M<R2>

	MOVAB	SYMBOL_NAME,R2		; ADDRESS OF SYMBOL NAME DESC.
	CMPL	OPTIONS,#OPT$M_ALL	; CHECK IF WANTS ALL SYMBOLS
	BEQL	70$			; BRANCH IF SO
	PUSHL	R2			; DESCRIPTOR
	CALLS	#1,SYMBOL_VALUE		; GET SYMBOL VALUE
	BLBC	R0,50$			; IF NOT FOUND
	CMPL	R1,#^XC0000000		; CHECK IF INTERNAL SYMBOL
	BGEQU	50$			; DO NOT SHOW INTERNAL SYMBOLS
	MOVL	R1,ADDRESS		; SAVE SYMBOL VALUE
	TRYMEM	(R1)			; GET CONTENTS OF LOCATION
	BLBC	R0,20$			; IF NOT AN ADDRESS
	PUSHL	R1			; CONTENTS OF LOCATION
	PUSHL	ADDRESS			; SYMBOL VALUE
	PUSHL	R2			; DESCRIPTOR ADDRESS
	PRINT	3,<!AS = !XL :  !XL>
	RET
20$:
	PUSHL	ADDRESS			; SYMBOL VALUE
	PUSHL	R2			; DESCRIPTOR ADDRESS
	PRINT	2,<!AS = !XL>
	RET
50$:
	PUSHL	R2			; DESCRIPTOR ADDRESS
	SIGNAL	1,BADSYM		; UNKNOWN SYMBOL
	RET
70$:
	CALLG	(R2),PRINT_SYMBOLS	; PRINT ALL SYMBOLS
	RET

	.DSABL	LSB

	.SBTTL	SHOW_EXPR -- SHOW RESULT OF EVALUATE COMMAND
;---
;
;	SHOW_EXPR
;
;	DISPLAY THE RESULT OF AN EVALUATE COMMAND.
;
;   INPUTS:
;
;	TPA$L_NUMBER(AP) = RESULT OF EXPRESSION
;
;   OUTPUTS:
;
;	RESULT IS DISPLAYED.
;
;---

SHOW_EXPR::
	.WORD	0

	PUSHL	TPA$L_NUMBER(AP)	; GET RESULT OF EXPRESSION
	PRINT	1,<Hex = !XL   Decimal = !-!SL>
	RET

	.SBTTL	EXAM_MEMORY -- EXAMINE MEMORY LOCATIONS
;---
;
;	EXAM_MEMORY
;
;	DISPLAY THE CONTENTS OF A SPECIFIED RANGE OF MEMORY
;
;   INPUTS:
;
;	EXPRESSION STACK CONTAINS ARGUMENTS OF RANGE
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

EXAM_MEMORY::
	.WORD	^M<R2,R3,R4,R5>

	MOVL	OPTIONS,R2
	BICL3	#OPT$M_RANGE!OPT$M_LENGTH!OPT$M_INST,R2,R0
					; CHECK IF ANY OPTIONS SPECIFIED
	BEQL	40$			; BRANCH IF NOT
	BBC	#OPT$V_P0,R2,10$	; CHECK IF /P0 SPECIFIED
	CALLS	#0,SHOW_P0		; SHOW P0 SPACE
10$:	BBC	#OPT$V_P1,R2,20$	; CHECK IF /P1 SPECIFIED
	CALLS	#0,SHOW_P1		; SHOW P1 SPACE
20$:	BBC	#OPT$V_SYSTEM,R2,30$	; CHECK IF /SYSTEM SPECIFIED
	CALLS	#0,SHOW_SYSTEM		; SHOW SYSTEM SPACE
30$:	RET

40$:
	MOVL	ESP,R3			; EXPRESSION STACK POINTER
	BBS	#OPT$V_RANGE,R2,50$	; BRANCH IF RANGE SPECIFIED
	BBS	#OPT$V_LENGTH,R2,55$	; BRANCH IF LENGTH SPECIFIED
	MOVAB	EXPR_STACK,R0
	CMPL	R3,R0			; CHECK IF STACK EMPTY
	BEQLU	60$			; IF NO ARGS, USE NEXT LONGWORD
	CMPL	(R3),#^XC0000000	; CHECK IF INTERNAL REGISTER
	BGEQU	70$			; DO NOT SET ADDRESS IF SO
	MOVL	(R3),ADDRESS		; SET NEW "CURRENT" ADDRESS
	BRB	70$
50$:
	CLRL	-(SP)			; DISABLE PAGING
	SUBL3	4(R3),(R3),-(SP)	; LENGTH - 1 OF RANGE
	INCL	(SP)			; LENGTH TO DUMP
	BRB	58$
55$:
	CLRL	-(SP)			; DISABLE PAGING
	PUSHL	(R3)			; LENGTH TO DUMP
58$:
	PUSHL	4(R3)			; STARTING ADDRESS
	MOVL	(SP),ADDRESS		; SET NEW "CURRENT" ADDRESS
	TSTL	OUTPUT_FILE		; AVOID SUBHEADNG IF NOT A FILE
	BEQL	59$			; BRANCH IF NOT
	SUBHD	<MEMORY DUMP>
	SKIP	PAGE
59$:	BBS	#OPT$V_INST,OPTIONS,57$ ; BRANCH IF RANGE OF INSTRUCTIONS
	CALLS	#3,DUMP			; DUMP MEMORY
	RET
57$:	BRW	150$			; GO SHOW RANGE OF DATA ITEMS
	
;
; NO ADDRESS SPECIFIED - SKIP TO NEXT DATA ITEM
;
60$:	MOVAL	ADDRESS,R3
	ADDL	DATALEN,(R3)		; SET "." TO NEXT DATA SEGMENT
;
; DISPLAY DATA AT "ADDRESS".
;
70$:	CLRL	LINE_COUNT		; INHIBIT PAGE EJECTS
	MOVAB	BUFFER,R5		; ADDRESS OF INSTRUCTION/DATA BUFFER
	ALLOC	40,R2			; ALLOCATE SYMBOLIZE OUTPUT BUFFER
	BBS	#OPT$V_INST,OPTIONS,100$ ; BRANCH IF INSTRUCTION MODE
	MOVL	#4,DATALEN		; SET LENGTH OF DATA SEGMENT
	TRYMEM	@(R3),(R5),#4		; GET LONGWORD
	BLBC	R0,90$			; IF NOT AVAILABLE
	PUSHL	R5			; ADDRESS OF COPY OF DATA ITEM
	PUSHL	#4			; LENGTH OF DATA ITEM
	PUSHL	R1			; CONTENTS OF LOCATION
	PUSHL	R2			; ADDRESS OF OUTPUT BUFFER
	PUSHL	(R3)			; ADDRESS TO TRANSLATE
	CALLS	#2,SYMBOLIZE		; TRANSLATE TO SYMBOL+OFFSET
	TSTL	(R1)			; CHECK LENGTH OF RESULT STRING
	BEQL	80$			; BRANCH IF NOT TRANSLATED
	PUSHL	R1			; ADDRESS OF STRING DESCRIPTOR
	PRINT	4,<!AS:  !XL   "!AF">
	RET
80$:
	PUSHL	(R3)
	PRINT	4,<!XL:  !XL   "!AF">
	RET

90$:	PUSHL	(R3)			; ADDRESS
	SIGNAL	1,NOTINPHYS		; NOT IN PHYSICAL MEMORY
	RET

;
; EXAMINE/INSTRUCTION
;

100$:	TRYMEM	@(R3),(R5),#64		; GET MAXIMUM LENGTH OF INSTRUCTION
	BLBC	R0,90$			; IF NOT AVAILABLE
	ALLOC	128,R4			; BUFFER FOR INSTRUCTION TEXT
	PUSHL	R5			; ADDRESS OF INSTRUCTION STREAM
	PUSHAB	INSTR_VALUE		; ADDRESS OF SYMBOLIZE ROUTINE
	PUSHL	R4			; ADDRESS TO RETURN LENGTH
	PUSHL	R4			; ADDRESS OF OUTPUT BUFFER DESCRIPTOR
	PUSHAL	12(SP)			; ADDRESS OF INSTRUCTION STREAM POINTER
	CALLS	#4,G^LIB$INS_DECODE	; DECODE INSTRUCTION
	BLBC	R0,190$			; AND SIGNAL ANY ERRORS
	SUBL3	R5,(SP)+,DATALEN	; SAVE LENGTH OF INSTRUCTION
	PUSHL	R4			; PUSH ADDRESS OF INSTRUCTION TEXT
	PUSHL	R2			; ADDRESS OF RESULT BUFFER
	PUSHL	(R3)			; ADDRESS TO TRANSLATE
	CALLS	#2,SYMBOLIZE		; TRANSLATE TO SYMBOL+OFFSET
	TSTL	(R1)			; CHECK LENGTH OF RESULT STRING
	BEQL	180$			; BRANCH IF NOT TRANSLATED
	PUSHL	R1			; ADDRESS OF STRING DESCRIPTOR
	PRINT	2,<!AS:  !AS>
	RET
180$:	PUSHL	(R3)
	PRINT	2,<!XL:  !AS>
	RET
190$:	SIGNAL	0,NOINSTRAN		; SIGNAL ANY ERRORS FROM DECODE
	RET

;
; RANGE OF INSTRUCTIONS TO BE DUMPED
;

150$:	BICL	#OPT$M_RANGE!OPT$M_LENGTH,OPTIONS ; INDICATE ONLY ADDRESS
	MOVAB	EXPR_STACK,ESP		; POP ALL ARGUMENTS OFF STACK
	ADDL3	(SP),4(SP),R5		; GET ENDING ADDRESS
	CLRL	DATALEN			; DO NOT SKIP FIRST INSTRUCTION
	MOVAL	ADDRESS,R3
;
; ATTEMPT TO LOCATE THE FIRST INSTRUCTION WHICH MAKES SENSE IN THE RANGE.
; THIS IS DONE BY ATTEMPTING TO INTERPRET N INSTRUCTIONS IN A ROW WHICH
; APPEAR IN THE LIST OF "NORMAL" INSTRUCTIONS.  IF WE CAN'T MAKE SENSE
; OUT OF N IN A ROW, THEN WE INCREMENT "." BY 1 BYTE AND TRY AGAIN.
; IF THE ENTIRE RANGE IS EXHAUSTED WITHOUT FINDING A VALID SEQUENCE,
; THEN GIVE UP AND RESET "." BACK TO THE ORIGINALLY REQUESTED ADDRESS
; AND SHOW THE USER THE CRAP.
;
	CMPL	4(SP),#16		; IS THE PRE-SCAN WORTH IT?
	BLSS	155$			; BRANCH IF NOT
152$:	CALLS	#0,TRY_SEQUENCE	; EXAMINE NEXT N INSTRUCTIONS
	BLBS	R0,154$			; BRANCH IF THEY ARE REASONABLE
	INCL	(R3)			; SKIP AHEAD ONE BYTE
	CMPL	(R3),R5			; END OF RANGE?
	BLSSU	152$			; LOOP IF NOT
	MOVL	(SP),(R3)		; RESET "." TO ORIGINAL ADDRESS
	BRB	155$
154$:	SUBL3	(SP),(R3),-(SP)		; NUMBER OF BYTES SKIPPED
	BEQL	155$			; SKIP MESSAGE IF NOTHING SKIPPED
	SIGNAL	1,INSKIPPED		; INFORM NUMBER OF BYTES SKIPPED
;
; SHOW THE RANGE OF INSTRUCTIONS, UPDATING "." ON EACH INSTRUCTION
;
155$:	CALLS	#0,EXAM_MEMORY		; RECURSIVELY SHOW NEXT DATA ITEM
	CMPL	(R3),R5			; END OF RANGE YET?
	BLSSU	155$			; LOOP UNTIL DONE
	MOVL	#1,R0			; SUCCESS
	RET

	.DSABL	LSB

	.SBTTL	INSTR_VALUE, SYMBOLIZE ADDRESS INTO BUFFER
;---
;
;	OUTPUT A STRING DESCRIBING AN ADDRESS.  THE ADDRESS IS CONVERTED
;	TO A "REAL" ADDRESS BY COMPUTING THE OFFSET FROM THE INSTRUCTION
;	BUFFER.  THEN THE SYMBOL TABLE IS SEARCHED FOR THE CLOSEST SYMBOL.
;	IF NOT FOUND IN THE SYMBOL TABLE, A LONGWORD HEX STRING IS WRITTEN.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF LONGWORD CONTAINING ADDRESS
;	8(AP) = ADDRESS OF RESULT BUFFER DESCRIPTOR
;	12(AP) = ADDRESS OF WORD TO RECEIVE RESULT LENGTH
;	16(AP) = ADDRESS OF FLAG: 1 IF ABSOLUTE ADDRESS, 0 IF RELATIVE ADDRESS
;
; OUTPUTS:
;
;	THE STRING IS WRITTEN INTO THE RESULT BUFFER.
;---

XL_STRING:
	.ASCID	'!XL'

INSTR_VALUE:				; SYMBOLIZE INSTRUCTION VALUE
	.WORD	^M<R2,R3>

	MOVL	@4(AP),R2		; GET VALUE (ARGUMENT BY REFERENCE)
	MOVL	8(AP),R3		; GET ADDRESS OF DESCRIPTOR
	BLBS	@16(AP),5$		; BRANCH IF ABSOLUTE ADDRESS
	MOVAB	BUFFER,R0		; ADDRESS OF INSTRUCTION BUFFER
	SUBL	R0,R2			; GET OFFSET FROM INSTRUCTION
	ADDL	ADDRESS,R2		; AND COMPUTE "REAL" ADDRESS
5$:	PUSHL	R3			; ADDRESS OF RESULT BUFFER
	PUSHL	R2			; VALUE TO BE CONVERTED
	CALLS	#2,SYMBOLIZE		; CONVERT TO SYMBOL+OFFSET
	TSTL	(R1)			; ANYTHING RETURNED IN BUFFER?
	BEQL	10$			; BRANCH IF NOT
	MOVW	(R1),@12(AP)		; RETURN LENGTH TO CALLER
	MOVL	#1,R0
	RET
10$:	SUBL	#2,SP			; ADDRESS TO RETURN FAO LENGTH
	PUSHL	R2			; ABSOLUTE VALUE
	PUSHL	R3			; ADDRESS OF RESULT BUFFER
	PUSHAL	8(SP)			; ADDRESS OF WORD TO RECEIVE LENGTH
	PUSHAB	XL_STRING		; ADDRESS OF FAO CONTROL STRING
	CALLS	#4,G^SYS$FAO		; CONVERT INTO BUFFER
	MOVW	(SP)+,@12(AP)		; RETURN LENGTH TO CALLER
	MOVL	#1,R0			; SUCCESS
	RET

	.SBTTL	TRY_SEQUENCE, DETERMINE IF INSTRUCTIONS VALID
;---
;
; SCAN THE CURRENT INSTRUCTION STREAM LOOKING FOR N INSTRUCTIONS IN
; A ROW WHICH "MAKE SENSE", ACCORDING TO A LIST OF "NORMAL" INSTRUCTIONS.
;
; INPUTS:
;
;	ADDRESS = "REAL" ADDRESS OF INSTRUCTION STREAM
;
; OUTPUTS:
;
;	R0 = TRUE IF STREAM REASONABLE, ELSE FALSE
;---

TRY_SEQUENCE:
	.WORD	^M<R3,R4,R5>

	MOVAB	BUFFER,R5		; GET ADDRESS OF INSTRUCTION BUFFER
	MOVL	ADDRESS,R3		; GET CURRENT "."
	MOVL	#4,R4			; INITIALIZE LOOP COUNT
10$:	TRYMEM	(R3),(R5),#64		; GET MAXIMUM LENGTH OF INSTRUCTION
	BLBC	R0,90$			; IF NOT AVAILABLE
	MOVZBL	(R5),R0			; PICK UP OPCODE
	BLBC	NORMAL_INSTRS(R0),80$	; BRANCH IF UNREASONABLE INSTRUCTION
	PUSHL	R5			; ADDRESS OF INSTRUCTION STREAM
	CLRQ	-(SP)			; NO SYMBOLIZE ROUTINE OR RETLEN
	PUSHL	SP			; ADDRESS OF NULL BUFFER DESCRIPTOR
	PUSHAL	12(SP)			; ADDRESS OF INSTRUCTION STREAM POINTER
	CALLS	#4,G^LIB$INS_DECODE	; DECODE INSTRUCTION
	BLBC	R0,90$			; IF ERROR, RETURN UNREASONABLE
	SUBL3	R5,(SP)+,R0		; CALCULATE LENGTH OF INSTRUCTION
	ADDL	R0,R3			; AND POINT TO NEXT INSTRUCTION
	SOBGTR	R4,10$			; TRY NEXT INSTRUCTION
	MOVL	#1,R0			; RETURN SEQUENCE IS REASONABLE
90$:	RET
80$:	CLRL	R0			; RETURN SEQUENCE UNREASONABLE
	RET

	.SBTTL	SET_PROCESS -- SELECT SPECIFIED PROCESS
;---
;
;	SET_PROCESS
;
;	SETUP FOR DISPLAY OF A SPECIFIED PROCESS
;
;   INPUTS:
;
;	OPTIONS = OPTIONS MASK (ONLY SYSPROC IS CHECKED)
;	PROC_NAME = PROCESS NAME
;	PROC_INDEX = PROCESS INDEX (MUTALLY EXCLUSIVE)
;
;   OUTPUTS:
;
;	PROC_PID = PROCESS PID (0 IF CURRENT PROCESS)
;	BADPROC IF NOT FOUND
;
;	ALL ERRORS ARE SIGNALLED IMMEDIATELY
;
;---

	.ENTRY	SET_PROCESS,-
		^M<R2,R3,R4,R5,R6,R7,R8>

;
;	IF /SYSTEM SPECIFIED, SET TO "SYSTEM PROCESS"
;
	BBC	#OPT$V_SYSPROC,OPTIONS,10$ ; BRANCH IF NOT SPECIFIED
	MNEGL	#1,R8			; SET TO -1 (SYSTEM)
5$:	MOVL	@MMG$AL_SYSPCB,PCBADR	; SET SYSTEM PCB ADDRESS
	BRB	20$
;
;	IF PROCESS INDEX GIVEN, OBTAIN PCB ADDRESS FROM VECTOR
;
10$:
	TSTL	PROC_NAME		; WAS NAME SPECIFIED 
	BNEQ	50$			; BRANCH IF SO
	REQMEM	@SCH$GL_MAXPIX		; MAXIMUM INDEX NUMBER
	CVTWL	PROC_INDEX,R8		; CHECK IF "SYSTEM PROCESS"
	BLSS	5$			; BRANCH IF SO
	CMPL	R8,R1			; CHECK IF IN RANGE
	BGTRU	40$			; ERROR IF BAD INDEX
	REQMEM	@SCH$GL_PCBVEC		; VECTOR OF PCB ADDRESSES
	MOVAL	(R1)[R8],R1		; ADDRESS OF POINTER TO PCB
	REQMEM	(R1),PCBADR		; STORE ADDRESS OF PCB
20$:
	REQMEM	@PCBADR,PCB,#PCB$C_LENGTH ; GET ENTIRE PCB
	BRW	70$
40$:
	BRW	80$			; FAILURE
;
;	LOOKUP SPECIFIED NAME IN ALL PCBS
;
50$:
	REQMEM	@SCH$GL_PCBVEC		; VECTOR OF PCB ADDRESSES
	MOVL	R1,R6			; SAVE ADDRESS OF VECTOR
	REQMEM	@SCH$GL_MAXPIX		; MAXIMUM PROCESS INDEX
	MOVL	R1,R7			; SAVE NUMBER OF SLOTS
	CLRL	R8			; INITIALIZE CURRENT INDEX
60$:
	MOVAL	(R6)[R8],R1		; ADDRESS OF POINTER TO PCB
	REQMEM	(R1),PCBADR		; GET ADDRESS OF PCB
	REQMEM	@PCBADR,PCB,#PCB$C_LENGTH  ; READ ENTIRE PCB
	MOVZBL	PCB+PCB$T_LNAME,R0	; GET LENGTH OF NAME
	CMPC5	R0,PCB+PCB$T_LNAME+1,#^A' ', -
		PROC_NAME,@PROC_NAME+4	; CHECK IF CORRECT PROCESS
	BEQL	70$			; BRANCH IF YES
	AOBLEQ	R7,R8,60$		; LOOP UNTIL FOUND
	BRW	80$			; FAILURE
70$:
	CLRQ	PROC_NAME		; CLEAR SO WE DON'T RE-SEARCH
	MOVL	PCB+PCB$L_PHD,R1	; ADDRESS OF PROCESS HEADER
	BEQL	75$			; BRANCH IF NOT RESIDENT
	REQMEM	(R1),PHD,#PHD$C_LENGTH	; READ ENTIRE PHD
	MOVL	PCB+PCB$L_PHD,PHDADR	; SAVE PHD ADDRESS
	MOVC	#16,PHD+PHD$L_P0BR,P0BR	; GET RELOCATION REGISTERS
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,P0LR,P0LR
	BRB	79$
75$:	CLRL	PHDADR			; SET PHD NOT RESIDENT
	MOVC5	#0,(SP),#0,#16,P0BR	; ZERO RELOCATION REGISTERS
79$:	MOVL	R8,PROC_INDEX		; SAVE PROCESS INDEX
	MOVL	PCB+PCB$L_PID,PROC_PID	; SAVE PROCESS PID
;
;	ZERO THE PROC_PID IF THE PROCESS IS THE CURRENT PROCESS.
;	THIS AVOIDS UNNECESSARY OVERHEAD ON THE RUNNING SYSTEM DISPLAYS.
;
	CMPL	CURRENT_PID,PROC_PID	; IS PROC_PID SAME AS CUR. PROCESS?
	BNEQ	90$			; BRANCH IF NOT
	CLRL	PROC_PID		; IF SO, ZERO PROC_PID FOR QAST
90$:	STATUS	SUCCESS
	RET
80$:
	CLRQ	PROC_NAME		; CLEAR BAD PROCESS NAME
	SIGNAL	0,BADPROC		; NO SUCH PROCESS
	RET

	.SBTTL	CURPROC -- SET RELOCATION TO CURRENT PROCESS
;---
;
;	CURPROC
;
;	THIS ROUTINE SETS UP THE RELOCATION REGISTERS TO
;	REFER TO THE PROCESS EXECUTING WHEN THE SYSTEM
;	CRASHED.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	P0BR-P1LR ARE SETUP FOR "CRASH" PROCESS
;
;---

CURPROC::
	.WORD	^M<R2,R3,R4,R5>

	GETMEM	@SCH$GL_CURPCB		; ADDRESS OF CURRENT PCB
	RETIFERR
	MOVL	R1,PCBADR		; SAVE ADDRESS OF PCB
	MOVAB	L^PCB,R3		; ADDRESS OF OWN PCB
	GETMEM	(R1),(R3),#PCB$C_LENGTH	; READ ENTIRE PCB
	RETIFERR
	CVTWL	PCB$L_PID(R3),PROC_INDEX ; SAVE PROCESS INDEX
;	MOVL	PCB$L_PID(R3),PROC_PID	; SAVE PROCESS PID
	MOVL	PCB$L_PID(R3),CURRENT_PID ; SAVE PID OF CURRENT PROCESS
	CLRL	PROC_PID		; DO NOT SWITCH CONTEXT IN GETMEM
	MOVL	PCB$L_PHD(R3),PHDADR	; SAVE PHD ADDRESS
	MOVAB	L^PHD,R4		; ADDRESS OF OWN PHD
	GETMEM	@PCB$L_PHD(R3),(R4),#PHD$C_LENGTH  ; READ ENTIRE PHD
	RETIFERR
	MOVC	#16,PHD$L_P0BR(R4),P0BR	; GET P0BR - P1LR
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,P0LR,P0LR   ; ELIM. ASTLVL
	RET

	.SBTTL	SHOW_PROCESS -- DISPLAY SPECIFIED PROCESS
;---
;
;	SHOW_PROCESS
;
;	DISPLAY SELECTED FIELDS FROM A SPECIFIED PROCESS
;
;   INPUTS:
;
;	PROC_NAME OR PROC_INDEX CONTAINS WHICH PROCESS
;
;   OUTPUTS:
;
;	NONE
;
;---

ALL:	.ASCII	'ALL'

SHOW_PROCESS::
	.WORD	^M<R2,R3,R4,R5>

	CMPC5	#3,ALL,#^A' ',PROC_NAME,@PROC_NAME+4
	BNEQ	10$			; BRANCH IF NOT ALL
	CALLS	#0,DISPLAY_PROCS	; DISPLAY ALL PROCESSES
	RET
10$:
	CALLS	#0,SET_PROCESS		; SETUP TO READ PROCESS
	BLBC	R0,90$			; BRANCH IF ERROR
	CALLS	#0,DISPLAY_PROCESS	; DISPLAY INFORMATION
90$:
	STATUS	SUCCESS
	RET

	.SBTTL	DISPLAY_HELP -- DISPLAY HELP INFORMATION
;---
;
;	DISPLAY_HELP
;
;	DISPLAY PORTIONS OF THE HELP FILE BASED ON THE TYPE
;	OF INFORMATION REQUESTED IN THE HELP COMMAND.
;
;   INPUTS:
;
;	AP POINTS TO THE TPARSE BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

DISPLAY_HELP::
	.WORD	^M<>
	MOVAL	HELPHAND,(FP)		;Establish Condition Handler
	PUSHAL	G^LIB$GET_INPUT		;Address of input routine
	PUSHAL	HELP_FLAGS		;Library search & Prompt options
	PUSHAQ	HELP_LIBRARY		;Address of library name descriptor
	PUSHAL	TPA$L_TOKENCNT(AP)	;Address of input line descriptor
	PUSHL	#0			;Text line width -- Defaulted
	PUSHAL	G^LIB$PUT_OUTPUT	;Address of output routine
	CALLS	#6,G^LBR$OUTPUT_HELP	;Does the obvious...
	BLBS	R0,10$			;Any problems?
	PUSHL	R0			;YES,...
	CALLS	#1,G^LIB$SIGNAL		;    Send it to the condition handler
10$:	STATUS	SUCCESS			;All's well that ends well...
	RET

	.DSABL	LSB
;
;	Condition Handler for Display_Help.
;

	.ENABL	LSB

HELPHAND:
	.WORD	^M<>
	MOVL	4(AP),R0		;Get address of Signal Array
;
;	Check to see if this is a SEVERE or FATAL exception...
;	if it is, then CHANGE the severity to ERROR and resignal the
;	condition,  else, just resignal the condition.
;
	CMPZV	#STS$V_SEVERITY,-	;Position of Severity Field
		#STS$S_SEVERITY,-	;Size of the Severity Field
		CHF$L_SIG_NAME(R0),-	;Base address of comparison field
		#STS$K_SEVERE		;Test value
	BNEQ	10$			;Its not a FATAL severity.
;
;	If we are here, then we do have a FATAL severity code in our
;	condition value, sooo... we must CHANGE the severity to ERROR.
;
	INSV	#STS$K_ERROR,-		;The desired severity code.
		#STS$V_SEVERITY,-	;Position of Severity Field
		#STS$S_SEVERITY,-	;Size of the Severity Field
		CHF$L_SIG_NAME(R0)	;Base address of Signal Name

10$:	MOVZWL	#SS$_RESIGNAL,R0	;Send condition to HANDLER.
	RET

	.DSABL	LSB

	.SBTTL	READ_SYMFILE, Read symbols from given file
;----
;
;	READ_SYMFILE
;
;	This command can be executed to add symbol definitions
;	to the working symbol table by reading object modules
;	containing GST entries and defining all symbols found.
;
;   Inputs:
;
;	FILE_DESC - Descriptor of file specification
;
;   Outputs:
;
;	The symbols are added to the symbol table.
;
;----

sym_default:
	.ascii	'.STB'
sym_def_len = .-sym_default

	.entry	read_symfile,-
		^m<r2,r3,r4,r5>

	movab	file_desc,r0		; Address of file descriptor
	movab	stbf,r2			; R2 = Address of FAB
	movab	stb,r3			; R3 = Address of RAB
	cvtwb	(r0),fab$b_fns(r2)	; Set file name length
	movl	4(r0),fab$l_fna(r2)	; Set file name address
	movb	#sym_def_len,fab$b_dns(r2)	; Set default length
	movab	sym_default,fab$l_dna(r2)	; Set default address
	$open	(r2)			; Attempt to open the file
	blbs	r0,5$			; branch if ok
	pushl	fab$l_fna(r2)		; Create descriptor of file name
	movzbl	fab$b_fns(r2),-(sp)
	movq	r0,-(sp)		; RMS error codes
	insv	#sts$k_warning,-	; Change severity to warning
		#sts$v_severity,#sts$s_severity,(sp)
	pushab	8(sp)			; Address of file name descriptor
	movl	#shr$_openin!<3@16>,r0	; "Error opening input file !AS"
	signal	1			; Signal with 1 FAO argument
	brb	95$			; exit with success
5$:	$connect (r3)			; Connect for record access
	signal	RMS,(r3)		; Report any errors
	calls	#0,rewind_stb		; Rewind the file
10$:
	calls	#0,get_symbol		; Get next symbol in file
	blbc	r0,90$			; Branch if end of file
	pushl	obj$l_sym_value(r1)	; Value of symbol
	pushal	obj$t_sym_name+1(r1)	; Address of symbol
	movzbl	obj$t_sym_name(r1),-(sp); Length of symbol
	calls	#3,add_symbol		; Add to symbol table
	brb	10$
90$:
	$close	(r2)			; Close the file
	signal	RMS,(r2)		; Signal any errors
95$:	status	success
	ret

	.sbttl	SEARCH_MEMORY
;+
;	search memory for the longword pattern
;
; Inputs:
;
;	expr_stack	-->	pattern
;				end_addr or length
;				start_addr
;
; Outputs:
;
;	None
;-
	.enabl	lsb

	.entry	search_memory,^M<r2,r3,r6,r7,r8>

	movl	options, r2		; Get options
	movl	esp, r3		; point to expression stack
	movl	8(r3), r6		; r6 --> start addr
	movl	4(r3), r7		; r7 --> end addr or length
	bbs	#opt$v_range, r2, 10$	; br if range option
	addl	r6, r7			; add start addr to length
10$:	movl	(r3), r8		; r8 --> value to search for
;
;	Search from (r6) to (r7) for r8
;
	pushl	r8
	pushl	r7
	pushl	r6
	print	3,<Searching from !XL to !XL for !XL...>
20$:
	cmpl	r6, r7			; check for end of search
	bgtru	40$			; GTR if range searched
	trymem	(r6)			; get contents of location
	blbc	r0, 30$			; if not an address
	cmpl	r8, r1			; does this location match?
	bneq	30$			; Br if not
;
;	Here with a match
;
	pushl	r6			; push address of match
	print	1,<Match at !XL>	; print it out
30$:	addl	#4, r6			; step on a longword
	brb	20$			; go look at the next
40$:
	movl	#1, r0			; O.K. status
	ret				;

	.dsabl	lsb


	.END
