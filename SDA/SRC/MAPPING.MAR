	.TITLE	MAPPING	DUMP MEMORY MAPPING ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	DUMP MEMORY MAPPING ROUTINES
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY:
;
;	V03-001	KTA0093		Kerbey T. Altmann	05-Apr-1982
;		Modifications to use PAGEFILE.SYS as dumpfile.
;
;	V02-007	KDM0063		Kathleen D. Morse	04-Aug-1981
;		Increment dump version number to 2.
;
;	V02-006	MTR0001		Mike Rhodes		22-Jun-1981
;		Change default addressing mode to longword.
;		Remove references to $SDAMSGDEF macro.
;
;	V02-005	KDM0041		Kathleen D. Morse	02-Mar-1981
;		Remove local definitions for DMP$ symbols.
;
;	V02-004	TMH0004		Tim Halvorsen		01-Mar-1981
;		Fix ASSUME in processing memory controller descriptors.
;
;	V02-003	TMH0003		Tim Halvorsen		10-Feb-1981
;		Change severity on REQMEM status from severe to error.
;		to avoid having image exit.
;		Do not report "file locked by another user" errors when
;		marking dump file analyzed.
;
;	V02-002	TMH0002		Tim Halvorsen		19-Jan-1981
;		Allow dumps which are not long enough to contain all
;		memory on the system as long as it contains the system
;		page table.  Issue warning message when dump file isn't
;		quite long enough, giving the number of blocks it should be.
;
;	V02-001	TMH0001		Tim Halvorsen		19-Oct-1980
;		Support dumps from systems with 2 discontiguous memory
;		controllers.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$STSDEF			; STATUS FIELD DEFINITIONS
	$JPIDEF			; GETJPI DEFINITIONS
	$SECDEF			; CRMPSC ARGUMENT DEFINITIONS
	$DMPDEF			; DUMP FILE DEFINITIONS
	$PRTDEF			; PROTECTION CODES
	$PTEDEF			; PAGE TABLE ENTRY DEFINITIONS
	$RPBDEF			; RESTART PARAMETER BLOCK
	$VADEF			; VIRTUAL ADDRESS DEFINITIONS

	.SBTTL	STORAGE DEFINTIONS
;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

PHYS_PAGES::
	.BLKL	1			; PHYSICAL MEMORY SIZE

AVLRANGE:
	.LONG	^X200			; STARTING ADDRESS (SPECIFY P0 RANGE)
	.LONG	^X3FFFFFFF		; ENDING ADDRESS
MAPRANGE:
	.BLKL	2			; STARTING,ENDING ADDRESS

MAPPED_SBR::
	.BLKL	1			; ADDRESS OF SPT IN MAPPED AREA

GETMEM_BUFFER::
	.BLKL	1			; FOR 1 LONGWORD TRANSFERS

DEMAND_ZERO:
	.BLKL	1			; ADDRESS OF DEMAND ZERO PAGE

P0BR::	.BLKL	1			; P0 BASE REGISTER
P0LR::	.BLKL	1			; P0 LENGTH REGISTER
P1BR::	.BLKL	1			; P1 BASE REGISTER
P1LR::	.BLKL	1			; P1 LENGTH REGISTER

	.PSECT	MAPPING,EXE,NOWRT

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	MAP_DUMP - MAP THE DUMP INTO VIRTUAL MEMORY
;---
;	MAP_DUMP
;
;	THIS ROUTINE ATTEMPTS TO MAP THE DUMP FILE AS A PRIVATE
;	SECTION INTO THE PROCESS REGION OF VIRTUAL MEMORY.  IF
;	THE MAPPING CANNOT BE DONE, AN ERROR IS RETURNED TO THE
;	CALLER.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	R0 = SUCCESS/FAILURE FLAG
;	IF SUCCESS, THE DUMP CAN NOW BE ACCESSED BY READING THE
;	CORRESPONDING VIRTUAL MEMORY LOCATION.
;---

	.ENABL	LSB

	.ENTRY	MAP_DUMP,^M<R2,R3,R4,R5,R9>

	BLBC	CURRENT_SYSTEM,5$	; BRANCH IF EXAMING DUMP
	MOVL	#1,R0			; SUCCESS
	RET				; IF CURRENT SYSTEM, EXIT
5$:
	MOVAL	DUMPR,R2
	$READ	(R2)			; READ DUMP HEADER (3 BLOCKS)
	SIGNAL	RMS,(R2)
	MOVL	RAB$L_RBF(R2),R9	; GET ADDRESS OF DUMP HEADER
	MOVAL	DUMPF,R2
	$CLOSE	(R2)			; CLOSE DUMP FILE
	SIGNAL	RMS,(R2)
	BBS	#DMP$V_EMPTY,DUMP_HEADER+DMP$L_FLAGS,15$
					; LEAVE NOW IF DUMP IS EMPTY
	MOVL	#FAB$M_UFO,FAB$L_FOP(R2)	; USER FILE OPEN
	$OPEN	(R2)			; RE-OPEN FILE FOR CRMPSC
	SIGNAL	RMS,(R2)
	CMPW	DMP$W_DUMPVER(R9),#2	; VERSION MUST BE < 2
	BGTR	10$			; IF NOT, NOT A VALID DUMP FILE
	XORL3	DMP$L_SYSVER(R9),DMP$L_CHECK(R9),R0 ; R0=(SYSVER XOR CHECK)
	INCL	R0			; IS CHECK IS ONE'S COMP. OF SYSVER?
	BNEQ	10$			; BRANCH IF NOT VALID
;   THIS CODE ASSUMES THAT THE SYSTEM PAGE TABLE IS AT THE
;   END OF MAIN PHYSICAL MEMORY.
	CLRL	R3			; INIT PAGE COUNTER
	ASSUME	DMP$C_NMEMDSC EQ RPB$C_NMEMDSC
	MOVZBL	#DMP$C_NMEMDSC,R4	; MAX # OF MEMORY DESCRIPTORS
	MOVAB	DUMP_HEADER+DMP$L_MEMDSC,R5 ; GET ADR OF MEMORY DESCRIPTORS
7$:	EXTZV	#DMP$V_PAGCNT,#DMP$S_PAGCNT,(R5),R0 ; GET PAGE CNT FOR THIS MEM
	BEQL	8$			; BR IF NO MORE MEMORY DESCRIPTORS USED
	ADDL2	R0,R3			; ACCUMULATE TOTAL # OF PAGES
	ASSUME	DMP$C_MEMDSCSIZ EQ RPB$C_MEMDSCSIZ
	ADDL2	#DMP$C_MEMDSCSIZ,R5	; GET NEXT MEMORY DESCRIPTOR
	SOBGTR	R4,7$			; LOOP ONCE FOR EACH MEMORY DESCRIPTOR
8$:	CMPL	R3,#512			; MUST BE AT LEAST 256K (1/4 MEG)
	BLSSU	10$			; BRANCH IF UNREASONABLE
	CMPL	R3,#^XFFFF		; MAXIMUM OF 32MEG FOR NOW
	BLSSU	20$			; BRANCH IF OK
10$:	SIGNAL	0,DUMPEMPTY		; SIGNAL NO VALID DUMP FOUND
	RET

15$:	CALLS	#0,EXIT_IF_OLD		; ONLY CALLING TO FLUSH INPUT
	BRB	10$			; LEAVE QUIETLY
20$:
	MOVAL	MAPRANGE,R4
	$CRMPSC_S INADR=AVLRANGE, -	; MAP SECTION
		RETADR=(R4), -		; RESULT ADDRESS RANGE
		CHAN=FAB$L_STV(R2), -	; CHANNEL AS RETURNED BY OPEN
		FLAGS=#SEC$M_EXPREG, -	; READABLE/EXPAND REGION SECTION
		PAGCNT=R3, -		; NUMBER OF PAGES TO MAP
		VBN=#4			; STARTING BLOCK IN FILE
	SIGNAL
	SUBL3	(R4),4(R4),R2		; LENGTH MAPPED - 1
	INCL	R2			; TOTAL LENGTH OF SECTION
	ASHL	#-9,R2,R2		; LENGTH OF SECTION IN PAGES
	MOVL	R2,PHYS_PAGES		; SAVE LENGTH OF DUMP FILE
	CMPL	R2,R3			; DO WE HAVE ENTIRE DUMP?
	BGEQ	30$			; BRANCH IF OK
	PUSHL	R3			; LENGTH DESIRED
	PUSHL	R2			; LENGTH SUCCESSFULLY MAPPED
	SIGNAL	2,SHORTDUMP		; INSUFFICIENT DUMP FILE SPACE
;
;	LOCATE THE SYSTEM PAGE TABLE IN THE DUMP FILE.  IF THE
;	DUMP FILE WASN'T LONG ENOUGH TO GET IT, ISSUE A FATAL ERROR.
;
30$:	ASHL	#-9,DMP$L_SBR(R9),R3	; GET PFN OF SYSTEM PAGE TABLE
	BSBW	LOCATE_PFN		; LOCATE PFN WITHIN DUMP FILE
	BLBC	R0,35$			; BRANCH IF ERROR
	MOVL	R7,MAPPED_SBR		; SAVE ADDRESS OF MAPPED SPT
	CMPL	R3,PHYS_PAGES		; BLOCK WITHIN DUMP FILE?
	BLEQU	40$			; BRANCH IF WITHIN RANGE
35$:	SIGNAL	0,SPTNOTFND		; SYSTEM PAGE TABLE NOT DUMPED
;
;	INITIALIZE A BLOCK OF ZEROS FOR DEMAND ZERO REQUESTS
;
40$:	PUSHL	#512			; LENGTH IN BYTES TO ALLOCATE
	CALLS	#1,ALLOCATE		; ALLOCATE STORAGE
	SIGNAL				; SIGNAL IF ANY ERRORS
	MOVL	R1,DEMAND_ZERO		; SAVE ADDRESS OF PAGE
	MOVC5	#0,(SP),#0,#512,(R1)	; USE AS DEMAND ZERO PAGE
	RET

	.DSABL	LSB

	.SBTTL	SAVE_DUMP, Save dump file into another file

;---
;
;	SAVE_DUMP	- SAVE filespec Command
;
;	This command copies the entire contents of the dump
;	file to another file specified by the first parameter
;	of the command.
;
;---

MAX_SIZE =	63*512			; Max. size of I/O transfer

	.ENTRY	SAVE_DUMP,-
		^M<R2,R3,R4,R5,R6>

	BLBC	CURRENT_SYSTEM,5$	; Branch if not running system
	CLRL	R0			; Signal syntax error - not allowed
	RET

5$:	MOVAB	SAVDMP,R3		; R3 = RAB for new file
	MOVL	RAB$L_FAB(R3),R2	; R2 = FAB for new file
	MOVAB	FILE_DESC,R0		; Address of filespec descriptor
	MOVB	(R0),FAB$B_FNS(R2)	; Set length of file spec.
	MOVL	4(R0),FAB$L_FNA(R2)	; Set address of file spec.
	$CREATE	(R2)			; Create new file
	SIGNAL	RMS,(R2)
	$CONNECT (R3)
	SIGNAL	RMS,(R3)
	MOVAB	DUMP_HEADER,RAB$L_RBF(R3) ; Set buffer address
	MOVW	#DUMP_HEADER_LEN,RAB$W_RSZ(R3)
	$WRITE	(R3)			; Write out dump header blocks
	SIGNAL	RMS,(R3)
	MOVL	MAPRANGE,RAB$L_RBF(R3)	; Set starting buffer address
	MOVW	#MAX_SIZE,RAB$W_RSZ(R3)	; Set to max. transfer size
	ASHL	#9,PHYS_PAGES,R6	; Get file size in bytes in R6
10$:
	CMPL	R6,#MAX_SIZE		; Less than full transfer left?
	BGTR	15$			; Branch if not
	MOVW	R6,RAB$W_RSZ(R3)	; Set size of last transfer
15$:	$WRITE	(R3)			; Write into output file
	SIGNAL	RMS,(R3)
	MOVZWL	RAB$W_RSZ(R3),R0	; Get length just transferred
	ADDL	R0,RAB$L_RBF(R3)	; Increment buffer address
	SUBL	R0,R6			; Subtract from loop count
	BGTR	10$			; Continue until done
	$CLOSE	(R2)			; Close output file
	SIGNAL	RMS,(R2)
	.WEAK	SDA$RELEASE_DUMP	; Do not force this in
	MOVAL	G^SDA$RELEASE_DUMP,R0	; See if it's there
	BEQL	20$			; No, leave
	PUSHL	DUMPF+FAB$L_NAM		; Yes, pass address of NAM block
	CALLS	#1,(R0)			; to the routine
	CMPL	S^#SS$_WASSET,R0	; Did it return the blocks?
	BNEQ	20$			; No, leave
	BBSS	#DMP$V_EMPTY,DUMP_HEADER+DMP$L_FLAGS,20$ ; Yes, set the bit
20$:	RET

	.SBTTL	MARK_DUMP -- MARK DUMP ANALYZED
;---
;
;	MARK_DUMP
;
;	SET A FLAG IN THE DUMP FILE TO INDICATE THAT THE
;	DUMP HAS BEEN ANALYZED AT LEAST ONCE.
;
;   INPUTS:
;
;	DUMP IS STILL MAPPED.
;
;   OUTPUTS:
;
;	DUMP IS UNMAPPED AND FILE IS CLOSED.
;
;---

	.ENTRY	MARK_DUMP,^M<R2,R3,R4>

	MOVAL	DUMP_HEADER,R4
	BBS	#DMP$V_EMPTY,DMP$L_FLAGS(R4),10$  ; Get rid of it if empty
	BBC	#DMP$V_OLDDUMP,DMP$L_FLAGS(R4),10$
	RET
10$:
	$DELTVA_S MAPRANGE		; UNMAP SECTION
	SIGNAL
	MOVAL	DUMPF,R2
	MOVAL	DUMPR,R3
	$DASSGN_S FAB$L_STV(R2)		; DEASSIGN CHANNEL
	SIGNAL
	CLRL	FAB$L_FOP(R2)		; CLEAR UFO OPTION
	MOVB	#FAB$M_BIO!FAB$M_GET!FAB$M_PUT,FAB$B_FAC(R2)
	$OPEN	(R2)			; RE-OPEN DUMP FILE
	CMPW	R0,#RMS$_PRV&^XFFFF	; PRIVILEGE VIOLATION?
	BEQL	15$			; SKIP IF NO PRIVILEGE
	CMPW	R0,#RMS$_FLK&^XFFFF	; FILE LOCKED BY ANOTHER USER?
	BNEQ	20$			; SKIP UPDATE IF SO
15$:	RET
20$:	SIGNAL	RMS,(R2)
	$CONNECT (R3)
	SIGNAL	RMS,(R3)
	MOVL	#1,RAB$L_BKT(R3)	; READ BLOCKS 1-3
	MOVL	R4,RAB$L_UBF(R3)	; SET BUFFER ADDRESS
	MOVL	#DUMP_HEADER_LEN,RAB$W_USZ(R3)	; AND LENGTH
	BISL3	#<1@DMP$V_OLDDUMP>, -	; NOTE DUMP ANALYZED
		DMP$L_FLAGS(R4),-(SP)	; AND SAVE POSSIBLE EMPTY FLAG
	$READ	(R3)			; RE-READ DUMP HEADER
	SIGNAL	RMS,(R3)
	POPL	DMP$L_FLAGS(R4)		; RESTORE OLD COPY OF FLAGS
	$WRITE	(R3)			; RE-WRITE HEADER
	SIGNAL	RMS,(R3)
	$CLOSE	(R2)			; CLOSE FILE FOR GOOD
	SIGNAL	RMS,(R2)
	RET

	.SBTTL	GETMEM - READ DUMP MEMORY AREA
;---
;	GETMEM
;
;	THIS ROUTINE TRANSFERS AN AREA FROM THE MEMORY IN THE
;	DUMP FILE TO THE CALLERS RETURN BUFFER.  IT PERFORMS
;	THE NECESSARY ADDRESS TRANSLATION TO LOCATE THE DATA
;	IN THE DUMP FILE.
;
;   INPUTS:
;
;	0(AP)	=	NUMBER OF LONGWORD ARGUMENTS
;	4(AP)	=	STARTING VIRTUAL ADDRESS IN DUMP
;	8(AP)	=	(OPTIONAL) RETURN BUFFER ADDRESS
;	12(AP)	=	(OPTIONAL) LENGTH OF TRANSFER, DEFAULT=4
;
;	P0BR-P1LR MUST BE SET IF ANY P0 OR P1 ADDRESSES 
;	ARE TO BE TRANSLATED.
;
;   OUTPUTS:
;
;	R0 = SUCCESS IF BUFFER FOUND AND TRANSFERRED,
;	     FAILURE IF ADDRESS NOT VALID OR NOT AVAILABLE.
;	R1 = FIRST LONGWORD OF MEMORY RETRIEVED.
;
;---

	.ENTRY	GETMEM,0
	CALLG	(AP),B^TRYMEM		; ATTEMPT TO READ MEMORY
	BLBS	R0,90$			; BRANCH IF SUCCESSFUL
	CMPL	R0,#SS$_NOPRIV		; NOT ENOUGH PRIVILEGE?
	BEQL	OTHER			; BRANCH IF SO
	PUSHL	4(AP)			; ADDRESS UNABLE TO READ
	SIGNAL	1,NOREAD		; WRITE WARNING MESSAGE
90$:	RET

	.ENTRY	REQMEM,0
	CALLG	(AP),B^TRYMEM		; ATTEMPT TO READ MEMORY
	BLBS	R0,90$			; BRANCH IF SUCCESSFUL
	CMPL	R0,#SS$_NOPRIV		; NOT ENOUGH PRIVILEGE?
	BEQL	OTHER			; BRANCH IF SO
	PUSHL	4(AP)			; ADDRESS UNABLE TO READ
	STATUS	NOREAD			; GET MESSAGE CODE
	INSV	#STS$K_ERROR,-		; CHANGE TO ERROR INSTEAD OF WARNING
		#STS$V_SEVERITY,#STS$S_SEVERITY,R0
	SIGNAL	1			; WRITE WITH 1 ARGUMENT
90$:	RET

OTHER:	SIGNAL				; SIGNAL OTHER MESSAGES
	RET

	.ENTRY	TRYMEM,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

	MOVL	4(AP),R9		; GET STARTING LOCATION DESIRED
	CMPL	(AP),#3			; CHECK ALL ARGUMENTS SPECIFIED
	BGEQ	5$			; BRANCH IF ALL THERE
	MOVAB	GETMEM_BUFFER,R3	; USE TEMPORARY SCRATCH BUFFER
	MOVL	#4,R8			; ONE LONGWORD
	BRB	7$
5$:
	MOVL	8(AP),R3		; GET DESTINATION ADDRESS
	MOVL	12(AP),R8		; GET LENGTH DESIRED
7$:
	MOVL	R3,R10			; SAVE START OF BUFFER
;
;	TRANSLATE ADDRESS IF INTERNAL REGISTER
;
	CMPZV	#30,#2,R9,#^B11		; INTERNAL REG. ADDRESS SPACE?
	BNEQ	4$			; BRANCH IF NOT
	MOVZWL	R9,R9			; GET OFFSET INTO PHD
	ADDL	PHDADR,R9		; BIAS BY PHD ADDRESS
4$:
;
;	IF EXAMINING CURRENT RUNNING SYSTEM, THEN ISSUE A
;	SPECIAL KERNEL MODE AST TO THE PROCESS TO OBTAIN
;	THE REQUESTED MEMORY.
;
	BLBC	CURRENT_SYSTEM,10$	; EXAMINING CURRENT SYSTEM?
	PUSHL	PROC_PID		; CURRENT PROCESS PID
	PUSHL	R8			; LENGTH TO TRANSFER
	PUSHL	R3			; DESTINATION ADDRESS
	PUSHL	R9			; VIRTUAL ADDRESS
	CALLS	#4,GETPROCMEM		; GET PROCESS MEMORY
	BLBS	R0,50$			; BRANCH IF SUCCESSFUL
	CMPL	R0,#SS$_TIMEOUT		; MEMORY REQUEST TIMED OUT?
	BNEQ	90$			; BRANCH IF NOT
	CLRL	PROC_PID		; RETURN TO CURRENT USER CONTEXT
					; TO ALLOW SYSTEM SPACE REQUESTS THRU
	BRB	90$			; EXIT WITH STATUS

10$:	PUSHL	R8			; LENGTH DESIRED
	PUSHL	R9			; STARTING ADDRESS DESIRED
	CALLS	#2,B^MAPMEM		; PERFORM ADDRESS TRANSLATION
	BLBC	R0,90$			; BRANCH IF ANY ERROR
	MOVC	R6,(R7),(R3)		; TRANSFER INTO USER BUFFER
	ADDL2	R6,R9			; INCREMENT VIRTUAL ADDRESS
	SUBL2	R6,R8			; DECREMENT LENGTH TO DO
	BGTR	10$			; LOOP UNTIL DONE

	STATUS	SUCCESS
50$:	MOVL	(R10),R1		; RETURN FIRST WORD FOR FREE
90$:	RET

	.SBTTL	PUTMEM, STORE INTO MAPPED MEMORY RANGE
;---
;
;	THIS IS USED TO STORE INTO A GIVEN DUMP MEMORY RANGE
;	SO THAT A SVPCTX CAN BE SIMULATED FROM THE CRASH
;	REGISTERS INTO THE PROCESS'S HARDWARE PCB.
;
; INPUTS:
;
;	4(AP) = ADDRESS IN DUMP MEMORY
;	8(AP) = ADDRESS IN LOCAL MEMORY
;	12(AP) = LENGTH OF TRANSFER
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
;---

	.ENTRY	PUTMEM,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

	MOVL	4(AP),R10		; DESTINATION ADDRESS
	MOVL	8(AP),R9		; SOURCE ADDRESS
	MOVL	12(AP),R8		; LENGTH TO DO
;
;	MAP INTERNAL REGISTER ADDRESS SPACE
;
	CMPZV	#30,#2,R10,#^B11	; INTERNAL REGISTER SPACE?
	BNEQ	5$			; BRANCH IF NOT
	MOVZWL	R10,R10			; GET OFFSET INTO PHD
	ADDL	PHDADR,R10		; MAP INTO PROCESS PHD
5$:
;
;	TRANSFER INTO DUMP MEMORY
;
10$:	PUSHL	R8			; LENGTH DESIRED
	PUSHL	R10			; DUMP ADDRESS
	CALLS	#2,B^MAPMEM		; MAP THE ADDRESS RANGE
	BLBC	R0,90$			; BRANCH IF ERROR
	ADDL3	R6,R7,-(SP)		; SET ENDING ADDRESS
	PUSHL	R7			; SET BEGINNING ADDRESS
	MOVL	SP,R5			; MARK THE LOCATION
	$SETPRT_S  INADR=(R5),-		; DESCRIPTOR
		   PROT=#PRT$C_UW	; USER WRITABLE
	ADDL	#8,SP			; CLEAN ADDRESS RANGE OFF STACK
	BLBC	R0,90$			; LEAVE IF ERROR SO NO ACCVIO
	MOVC	R6,(R9),(R7)		; TRANSFER INTO DUMP MEMORY
	ADDL	R6,R10			; INCREMENT DESTINATION ADDRESS
	ADDL	R6,R9			; INCREMENT SOURCE ADDRESS
	SUBL	R6,R8			; DECREMENT LENGTH
	BGTR	10$			; BRANCH IF MORE TO DO
	STATUS	SUCCESS
90$:
	RET

	.SBTTL	MAPMEM, MAP A GIVEN ADDRESS RANGE INTO LOCAL MEMORY
;---
;
;	THIS ROUTINE PERFORMS ALL NECESSARY ADDRESS TRANSLATION
;	IN ORDER TO REFERENCE A GIVEN RANGE OF DUMP MEMORY.
;
; INPUTS:
;
;	4(AP) = STARTING ADDRESS OF DUMP MEMORY
;	8(AP) = LENGTH OF DESIRED RANGE
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R7 = ADDRESS IN LOCAL VIRTUAL MEMORY OF DUMP MEMORY
;	R6 = LENGTH THAT CAN BE SUCCESSFULLY REFERENCED
;		IN LOCAL MEMORY BEFORE ANOTHER TRANSLATION
;		MUST BE DONE (END OF PAGE BOUNDARY).
;---
	.ENABL	LSB

	.ENTRY	MAPMEM,^M<R2,R3,R4,R5>

	MOVL	4(AP),R4		; GET STARTING ADDRESS
	MOVL	8(AP),R6		; PRESET LENGTH TO TRANSFER
	EXTZV	#VA$V_VPN,#VA$S_VPN,R4,R2  ; VIRTUAL PAGE NUMBER
	ADDL3	R4,R6,R3		; ENDING ADDRESS + 1
	DECL	R3			; COMPUTE ENDING ADDRESS
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R3  ; GET VPN OF ENDING ADDRESS
	CMPL	R2,R3			; IS IT IN THE SAME PAGE?
	BEQL	20$			; BRANCH IF SO
	ADDL3	R4,#<1@VA$V_VPN>,R3	; INCREMENT VPN OF ADDRESS
	BICL2	#^X1FF,R3		; COMPUTE ADDRESS OF NEXT PAGE
	SUBL3	R4,R3,R6		; RESET LENGTH TO REST OF PAGE
20$:
	BBS	#VA$V_SYSTEM,R4,50$	; BRANCH IF SYSTEM REGION
	BBS	#VA$V_P1,R4,30$		; BRANCH IF P1 SPACE
	CMPL	R2,P0LR		; CHECK IF IN BOUNDS
	BGEQ	NOTVALID		; BRANCH IF NOT
	MOVAL	@P0BR[R2],R3		; ADDRESS OF P0PTE
	BRB	40$
30$:
	CMPL	R2,P1LR		; CHECK IF IN BOUNDS
	BLSS	NOTVALID		; BRANCH IF NOT LEGAL
	MOVAL	@P1BR[R2],R3		; ADDRESS OF P1PTE
40$:
	SUBL	#4,SP			; ALLOCATE RETURN BUFFER
	MOVL	SP,R1			; (DO NOT WIPE OUT CALLER'S
					; GETMEM_BUFFER! HAS PARTIAL
					; RESULTS IN IT
	TRYMEM	(R3),(R1),#<4>		; GET PTE
	POPL	R2			; GET PTE LONGWORD IN R2
	BLBC	R0,NOTVALID		; IF NOT FOUND
	BRB	60$
50$:
	CMPL	R2,DUMP_HEADER+DMP$L_SLR   ; CHECK IF IN BOUNDS
	BGTR	NOTVALID		; IF NOT, THEN NOT VALID
	MOVL	@MAPPED_SBR[R2],R2	; GET PAGE TABLE ENTRY
60$:
	BLSS	70$			; BRANCH IF VALID
	BEQL	NOTVALID		; BRANCH IF NO ACCESS (NULL)
	BBS	#PTE$V_TYP0,R2,NOTVALID	; ALLOW TRANSITION/DZERO PAGES
	BBS	#PTE$V_TYP1,R2,NOTVALID
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R3	; PFN=0 FOR DZERO PAGES
	BNEQ	70$			; MAP PAGES IN TRANSITION
	MOVL	DEMAND_ZERO,R7		; SET ADDRESS OF ZERO PAGE
	BRB	80$
NOTVALID:
	STATUS	NOTVALID		; RETURN ERROR
	RET
70$:
	BBS	#PTE$S_PFN-1,R2,NOTVALID  ; I/O PAGES ARE NOT VALID
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R3	; PHYSICAL PAGE NUMBER
	BSBB	LOCATE_PFN		; FIND PFN WITHIN DUMP FILE
	BLBC	R0,NOTVALID		; ERROR IF PFN NOT FOUND IN DUMP
	CMPL	R3,PHYS_PAGES		; VALID BLOCK NUMBER?
	BGTR	NOTVALID		; WE GOT LOST
	EXTZV	#VA$V_BYTE,#VA$S_BYTE,4(AP),R2 ; GET OFFSET INTO PAGE
	ADDL	R2,R7			; RETURN MAPPED ADDRESS
80$:
	STATUS	SUCCESS			; RETURN SUCCESSFUL
	RET

	.DSABL	LSB

	.SBTTL	LOCATE_PFN, FIND PAGE WITHIN DUMP FILE
;---
;
;	LOCATE A GIVEN PFN IN THE MAPPED DUMP FILE AND RETURN
;	THE VIRTUAL BLOCK NUMBER (VBN) FROM THE START OF THE
;	FIRST BLOCK DUMPED (NOT COUNTING THE DUMP HEADER BLOCKS).
;
; INPUTS:
;
;	R3 = PFN
;
; OUTPUTS:
;
;	R0 = TRUE IF MAPPED BY DESCRIPTORS, FALSE IF OUT OF RANGE
;	R3 = VBN OF BLOCK CONTAINING SPECIFIED PAGE
;	R7 = ADDRESS OF MAPPED PAGE IN VIRTUAL MEMORY
;
;	R0-R5 DESTROYED.
;---

LOCATE_PFN:
	CLRL	R2			; INITIALIZE ACCUMULATED PAGE COUNT
	ASSUME	DMP$C_NMEMDSC EQ RPB$C_NMEMDSC
	MOVZBL	#DMP$C_NMEMDSC,R4	; # OF MEMORY CONTROLLER DESCRIPTORS
	MOVAB	DUMP_HEADER+DMP$L_MEMDSC,R5 ; GET ADR OF FIRST MEMORY DESCRIPTOR
72$:	EXTZV	#DMP$V_PAGCNT,#DMP$S_PAGCNT,(R5),R0 ; GET PAGE CNT FOR THIS MEM
	BEQL	76$			; BR IF NO MORE MEMORY DESCRIPTORS USED
	MOVL	4(R5),R7		; GET BASE PFN FOR THIS MEMORY
	CMPL	R7,R3			; IS DESIRED PAGE IN THIS MEMORY?
	BGTR	74$			; BR ON NO, ADD IN PAGCNT & GET NXT MEM
	ADDL2	R0,R7			; GET PFN OF PAGE PAST THIS MEMORY
	CMPL	R3,R7			; IS DESIRED PAGE IN THIS MEMORY?
	BLSS	76$			; BY ON YES, PAGE IS FOUND IN THIS MEM
74$:	ADDL2	R0,R2			; ACCUMULATE TOTAL # OF PAGES
	ASSUME	DMP$C_MEMDSCSIZ EQ RPB$C_MEMDSCSIZ
	ADDL2	#DMP$C_MEMDSCSIZ,R5	; NEXT MEMORY CONTROLLER DESCRIPTOR
	SOBGTR	R4,72$			; LOOP ONCE FOR EACH MEMORY DESCRIPTOR
76$:	SUBL2	R0,R7			; GET BASE PFN FOR MEMORY
	SUBL2	R7,R3			; COMPUTE OFFSET TO PAGE W/IN MEMORY
	BLSS	80$			; BRANCH IF NOT IN RANGE
	ADDL2	R2,R3			; CONVERT PFN TO VBN WITHIN MEMORY DUMP
	ASHL	#9,R3,R2		; CONVERT TO BYTE OFFSET
	ADDL3	MAPRANGE,R2,R7		; COMPUTE ADDRESS OF MAPPED PAGE
	MOVL	#1,R0			; SUCCESS
	RSB
80$:	CLRL	R0			; FAILURE - PFN NOT MAPPED BY DUMP
	RSB


	.END
