	.TITLE	PARSE		Parse tables for SDA commands
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	This module contains the parse tables which
;	are used to parse SDA commands.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V02-010	KTA0069		Kerbey T. Altmann	24-Jan-1982
;		Add SHOW POOL/SRP. Fix SHO SYM/ALL sym.
;
;	V02-009	KEK0017		K. E. Kinnear	6-Jan-1982
;		Add FWA, GBH, and GBD summary to parse tables.
;
;	V02-008	KEK0014		K. E. Kinnear	7-Dec-1981
;		Change SET RMS optionspec syntax slightly to make
;		it more DCL-like.
;
;	V02-007	KTA0044		Kerbey T. Altmann	13-Nov-1981
;		Add SHOW POOL/LRP.
;
;	V02-006	KEK0010		K. E. Kinnear	26-Aug-1981
;		Add new structures for SHOW PROC/RMS: BLB,
;		BLB/SUMMARY, GBD, GBH, TRC.
;
;	V02-005 DJD0001		Darrell Duffy	17-August-1981
;		Fix bug in expression parsing
;
;	V02-004	KTA0030		Kerbey Altmann	03-Aug-1981
;		1) Add SHOW POOL range.
;		2) Add SHOW POOL/TYP=xxx.
;		3) Add SHOW PAGE range.
;		4) Add SHOW HEADER.
;
;	V003	KEK0004		K. E. Kinnear	11-July-1981
;		Add SHOW RMS, SET RMS, and SHOW PROC/RMS commands.
;
;	V002	TMH0002		Tim Halvorsen	20-May-1981
;		Add '@', SEARCH, SHOW STACK range, READ/RELOCATE commands.
;
;	V001	TMH0001		Tim Halvorsen	07-Feb-1981
;		Add EXAMINE/INSTRUCTION.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$TPADEF			; TPARSE DEFINITIONS
	$OPTDEF			; DEFINE BITS IN OPTIONS WORD

SEMI	= ^A';'
COLON	= ^A':'

	.SBTTL	DATA STORAGE
;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,WRT,NOEXE

PREV_BUFFER:
	.BLKB	80		; HOLDS PREVIOUS COMMAND
PREV_COMMAND:
	.LONG	0
	.ADDRESS PREV_BUFFER

	.SBTTL	PARSER STATE TABLE
;
;	STATE TABLE FOR DUMP ANALYZER COMMANDS
;

	$INIT_STATE SDA_STATE,SDA_KEY

	$STATE	START
	$TRAN	'READ',READ_CMD
	$TRAN	'REPEAT',START,REPEAT_COMMAND
	$TRAN	TPA$_LAMBDA,,SAVE_COMMAND
	$STATE
	$TRAN	'@',INDIRECT_CMD
	$TRAN	'COPY',COPY_CMD
	$TRAN	'DEFINE',DEFINE
	$TRAN	'EXAMINE',EXAMINE
	$TRAN	'FORMAT',FORMAT_CMD
	$TRAN	'HELP',HELP_CMD
	$TRAN	'SET',SET
	$TRAN	'SEARCH',SEARCH
	$TRAN	'SHOW',SHOW
	$TRAN	'EVALUATE',EVALUATE
	$TRAN	'EXIT',EXIT_CMD
	$TRAN	'!',TPA$_EXIT
	$TRAN	TPA$_EOS,TPA$_EXIT

;
;	SEARCH start:end = object
;	       start;length = object
;

	$STATE	SEARCH
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	SEMI,,,OPT$M_LENGTH,OPTIONS
	$TRAN	COLON,,,OPT$M_RANGE,OPTIONS
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	'='
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,SEARCH_MEMORY

;
;	@filespec
;

	$STATE	INDIRECT_CMD
	$TRAN	!COLLECT,TPA$_EXIT,INDIRECT_COMMAND,,FILE_DESC

;
;	SHOW PROCESS name /options
;	SHOW SUMMARY
;	SHOW PAGE_TABLE
;	SHOW PFN_DATA
;	SHOW POOL /IRP /NONPAGED /ALL
;	SHOW CRASH
;	SHOW STACK /mode   (default is current stack)
;	SHOW SYMBOL name /ALL
;	SHOW DEVICE device /ALL
;	SHOW RMS
;

	$STATE	SHOW
	$TRAN	'CRASH',TPA$_EXIT,DISPLAY_CRASH
	$TRAN	'DEVICE',DEVICE
	$TRAN	'HEADER',TPA$_EXIT,PRINT_HEADER
	$TRAN	'PAGE_TABLE',PAGE_TABLE
	$TRAN	'PFN_DATA',PFN_DATA
	$TRAN	'POOL',POOL
	$TRAN	'PROCESS',PROCESS
	$TRAN	'RMS',SHOW_RMS
	$TRAN	'STACKS',STACK
	$TRAN	'SUMMARY',TPA$_EXIT,PROCESS_SUMMARY
	$TRAN	'SYMBOLS',SYMBOL

;
;	SHOW RMS
;

	$STATE	SHOW_RMS
	 $TRAN	!EOL,TPA$_EXIT,SHOW_RMS_OPT

	$STATE	EOL
	 $TRAN	'!',TPA$_EXIT
	 $TRAN	TPA$_EOS,TPA$_EXIT

;
;	SET OUTPUT filespec
;	SET PROCESS name /INDEX=n
;	SET RMS/DISPLAY=(opt1,opt2,...,optn)
;

	$STATE	SET
	$TRAN	'OUTPUT',SET_OUTPUT
	$TRAN	'PROCESS',SET_PROC
	$TRAN	'RMS',SET_RMS

;
;	SET OUTPUT filespec
;

	$STATE	SET_OUTPUT
	$TRAN	!COLLECT,,,,OUTPUT_FILE
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,OPEN_OUTPUT

;
;	SUB-EXPRESSION TO COLLECT ALL REMAINING CHARACTERS
;

	$STATE	COLLECT
	$TRAN	TPA$_ANY		; MUST HAVE AT LEAST 1 CHAR.
	$STATE	COLLECT_LOOP
	$TRAN	!SNARF,COLLECT_LOOP
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE	SNARF
	$TRAN	TPA$_EOS,TPA$_FAIL
	$TRAN	'!',TPA$_FAIL
	$TRAN	TPA$_ANY,TPA$_EXIT

;
;	SET RMS=opt
;	        (opt1,opt2,...,optn)
;

	$STATE	SET_RMS
	 $TRAN	!DISPLAY,TPA$_EXIT,END_SET_RMS

	$STATE	DISPLAY
	 $TRAN	TPA$_LAMBDA,,SETUP_RMS_TMP
	$STATE
	 $TRAN	':'
	 $TRAN	'='
	$STATE
	 $TRAN	!DIS_OPT,TPA$_EXIT
	 $TRAN	'('
	$STATE	NXT_OPT
	 $TRAN	!DIS_OPT
	$STATE
	 $TRAN	<','>,NXT_OPT
	 $TRAN	')',TPA$_EXIT

	$STATE	DIS_OPT
	 $TRAN	TPA$_LAMBDA,,SETUP_DIS_OPT
	$STATE
	 $TRAN	!ATM_OPT,DIS_OPT_EXIT
	 $TRAN	'N'
	$STATE
	 $TRAN	'O'
	$STATE
	 $TRAN	!ATM_OPT,,,OPT$M_NO,RMS_DIS_TMP1
	$STATE	DIS_OPT_EXIT
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT,STORE_TMP1_OPT

	$STATE	ATM_OPT
	 $TRAN	'ALL',IFI,,OPT$M_RMSALL,RMS_DIS_TMP1
	 $TRAN	'ASB',TPA$_EXIT,,OPT$M_ASB,RMS_DIS_TMP1
	 $TRAN	'BDB',TPA$_EXIT,,OPT$M_BDB,RMS_DIS_TMP1
	 $TRAN	'BDBSUM',TPA$_EXIT,,OPT$M_BDBSUM,RMS_DIS_TMP1
	 $TRAN	'BLB',TPA$_EXIT,,OPT$M_BLB,RMS_DIS_TMP1
	 $TRAN	'BLBSUM',TPA$_EXIT,,OPT$M_BLBSUM,RMS_DIS_TMP1
	 $TRAN	'CCB',TPA$_EXIT,,OPT$M_CCB,RMS_DIS_TMP1
	 $TRAN	'FAB',TPA$_EXIT,,OPT$M_FAB,RMS_DIS_TMP1
	 $TRAN	'FCB',TPA$_EXIT,,OPT$M_FCB,RMS_DIS_TMP1
	 $TRAN	'FWA',TPA$_EXIT,,OPT$M_FWA,RMS_DIS_TMP1
	 $TRAN	'GBD',TPA$_EXIT,,OPT$M_GBD,RMS_DIS_TMP1
	 $TRAN	'GBDSUM',TPA$_EXIT,,OPT$M_GBDSUM,RMS_DIS_TMP1
	 $TRAN	'GBH',TPA$_EXIT,,OPT$M_GBH,RMS_DIS_TMP1
	 $TRAN	'IDX',TPA$_EXIT,,OPT$M_IDX,RMS_DIS_TMP1
	 $TRAN	'IFAB',IFI,,OPT$M_IFB,RMS_DIS_TMP1
	 $TRAN	'IFB',IFI,,OPT$M_IFB,RMS_DIS_TMP1
	 $TRAN	'IRAB',TPA$_EXIT,,OPT$M_IRB,RMS_DIS_TMP1
	 $TRAN	'IRB',TPA$_EXIT,,OPT$M_IRB,RMS_DIS_TMP1
	 $TRAN	'NAM',TPA$_EXIT,,OPT$M_NAM,RMS_DIS_TMP1
	 $TRAN	'RAB',TPA$_EXIT,,OPT$M_RAB,RMS_DIS_TMP1
	 $TRAN	'RLB',TPA$_EXIT,,OPT$M_RLB,RMS_DIS_TMP1
	 $TRAN	'TRC',TPA$_EXIT,,OPT$M_TRC,RMS_DIS_TMP1
	 $TRAN	'WCB',TPA$_EXIT,,OPT$M_WCB,RMS_DIS_TMP1
	 $TRAN	'XAB',TPA$_EXIT,,OPT$M_XAB,RMS_DIS_TMP1
	 $TRAN	'*',TPA$_EXIT,STORE_STAR

	$STATE	IFI
	 $TRAN	':'
	 $TRAN	'='
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE	IFI2
	 $TRAN	'ALL',TPA$_EXIT,CLR_IFI_TMP
	 $TRAN	!EXPRESSION,TPA$_EXIT,STORE_IFI_TMP

;
;	EVALUATE expression
;

	$STATE	EVALUATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,SHOW_EXPR

;
;	EXAMINE start:end /P0 /P1 /SYSTEM /ALL /INSTRUCTION
;	EXAMINE start;length
;

	$STATE	EXAMINE
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,EXAMINE_EXPRESSION
	$STATE
	$TRAN	'P0',EXAM_OK,,OPT$M_P0,OPTIONS
	$TRAN	'P1',EXAM_OK,,OPT$M_P1,OPTIONS
	$TRAN	'SYSTEM',EXAM_OK,,OPT$M_SYSTEM,OPTIONS
	$TRAN	'ALL',EXAM_OK,,OPT$M_ALL,OPTIONS
	$TRAN	'INSTRUCTION',,,OPT$M_INST,OPTIONS

	$STATE	EXAMINE_EXPRESSION
	$TRAN	TPA$_EOS,EXAM_OK
	$TRAN	'!',EXAM_OK
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_EOS,EXAM_OK
	$TRAN	'!',EXAM_OK
	$TRAN	'/',EXAM_QUALS
	$TRAN	SEMI,,,OPT$M_LENGTH,OPTIONS
	$TRAN	COLON,,,OPT$M_RANGE,OPTIONS
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	'/',EXAM_QUALS
	$TRAN	TPA$_LAMBDA,EXAM_OK
	$STATE	EXAM_QUAL_LOOP
	$TRAN	TPA$_EOS,EXAM_OK
	$TRAN	'!',EXAM_OK
	$TRAN	'/'
	$STATE	EXAM_QUALS
	$TRAN	'INSTRUCTION',EXAM_QUAL_LOOP,,OPT$M_INST,OPTIONS
	$STATE	EXAM_OK
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,EXAM_MEMORY

;
;	EXPRESSION ANALYSIS FOR EXAMINE ARGUMENTS
;
;	THIS REDUCTION TABLE USES A SEPARATE STACK FOR PARSING
;	TOKENS AS THEY ENCOUNTERED.  THE RESULT OF THE LAST
;	OPERATION IS ALWAYS PLACED IN TPA$L_NUMBER TO RETURN
;	TO THE CALLING TRANSITION ROUTINE.
;

	$STATE	EXPRESSION
	$TRAN	!TERM
	$STATE	EXPOP
	$TRAN	'+',ADDITION
	$TRAN	'-',SUBTRACTION
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE	ADDITION
	$TRAN	!EXPRESSION,TPA$_EXIT,ADD2
	$STATE	SUBTRACTION
	$TRAN	!TERM, EXPOP, SUB2
;	$TRAN	!EXPRESSION,TPA$_EXIT,SUB2

	$STATE	TERM
	$TRAN	!FACTOR
	$STATE
	$TRAN	'@',ARITH_SHIFT
	$TRAN	'*',MULTIPLICATION
	$TRAN	!DIVISION,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE	ARITH_SHIFT
	$TRAN	!TERM,TPA$_EXIT,SHIFT2
	$STATE	MULTIPLICATION
	$TRAN	!TERM,TPA$_EXIT,MULT2
	$STATE	DIVISION
	$TRAN	'/'
	$STATE
	$TRAN	!TERM,TPA$_EXIT,DIV2

	$STATE	FACTOR
	$TRAN	'-',NEGATE
	$TRAN	'(',PARENS
	$TRAN	'@',INDIRECT
	$TRAN	'.',TPA$_EXIT,EVAL_DOT
	$TRAN	TPA$_SYMBOL,TPA$_EXIT,EVAL_SYMBOL
	$TRAN	!CONSTANT,TPA$_EXIT,EVAL_CONSTANT
	$STATE	NEGATE
	$TRAN	!FACTOR,TPA$_EXIT,NEG1
	$STATE	INDIRECT
	$TRAN	!FACTOR,TPA$_EXIT,EVAL_CONTENTS
	$STATE	PARENS
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	')',TPA$_EXIT

	$STATE	CONSTANT
	$TRAN	'+',CONSTANT
	$TRAN	'^',RADIX
	$TRAN	!HEX,TPA$_EXIT

	$STATE	RADIX
	$TRAN	'O',OCTAL
	$TRAN	'X',HEX
	$TRAN	'D',DECIMAL

	$STATE	OCTAL
	$TRAN	TPA$_OCTAL,TPA$_EXIT

	$STATE	DECIMAL
	$TRAN	TPA$_DECIMAL,TPA$_EXIT

	$STATE	HEX
	$TRAN	'G',SYSREG
	$TRAN	'H',CTLREG
	$TRAN	TPA$_HEX,TPA$_EXIT
	$STATE	SYSREG
	$TRAN	TPA$_HEX,TPA$_EXIT,ADD8000
	$STATE	CTLREG
	$TRAN	TPA$_HEX,TPA$_EXIT,ADD7FFE

;
;	SHOW PROCESS [name/ALL] [/INDEX=n] [/SYSTEM]
;		/WORKING_SET_LIST		[or WSL]
;		/PROCESS_SECTION_TABLE		[or PST]
;		/PAGE_TABLES			[or PPT]
;		/REGISTERS
;		/PCB
;		/PHD
;		/ALL
;		/RMS [=opt]
;		     [=(opt1,opt2,...,optn)]
;

	$STATE	PROCESS
	$TRAN	!PROC_OPTS,TPA$_EXIT,SHOW_PROCESS
	$TRAN	TPA$_SYMBOL,,,,PROC_NAME
	$STATE
	$TRAN	!PROC_OPTS,TPA$_EXIT,SHOW_PROCESS

	$STATE	PROC_OPTS
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	'!',TPA$_EXIT
	$TRAN	'/'
	$STATE
	$TRAN	'INDEX'
	$TRAN	'SYSTEM',PROC_OPTS,,OPT$M_SYSPROC,OPTIONS
	$TRAN	'WORKING_SET_LIST',PROC_OPTS,,OPT$M_WSL,OPTIONS
	$TRAN	'WSL',PROC_OPTS,,OPT$M_WSL,OPTIONS
	$TRAN	'PROCESS_SECTION_TABLE',PROC_OPTS,,OPT$M_PST,OPTIONS
	$TRAN	'PST',PROC_OPTS,,OPT$M_PST,OPTIONS
	$TRAN	'PAGE_TABLES',PROC_OPTS,,OPT$M_PPT,OPTIONS
	$TRAN	'PPT',PROC_OPTS,,OPT$M_PPT,OPTIONS
	$TRAN	'REGISTERS',PROC_OPTS,,OPT$M_REGS,OPTIONS
	$TRAN	'PCB',PROC_OPTS,,OPT$M_PCB,OPTIONS
	$TRAN	'PHD',PROC_OPTS,,OPT$M_PHD,OPTIONS
	$TRAN	'ALL',PROC_OPTS,,<OPT$M_PCB!OPT$M_PHD!OPT$M_REGS!-
OPT$M_WSL!OPT$M_PST!OPT$M_PPT>,OPTIONS
	$TRAN	!RMS,PROC_OPTS,,OPT$M_RMS,OPTIONS
	$STATE
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_HEX,PROC_OPTS,,,PROC_INDEX

;
;	SHOW PROCESS/RMS [=opt]
;			 [=(opt1,opt2,...,optn)]
;

	$STATE	RMS
	 $TRAN	'RMS'
	$STATE
	 $TRAN	!DISPLAY,TPA$_EXIT,,OPT$M_RMSD,OPTIONS
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT

;
;	SET PROCESS name /INDEX=n /SYSTEM
;

	$STATE	SET_PROC
	$TRAN	!INDEX
	$TRAN	TPA$_SYMBOL,,,,PROC_NAME
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,SET_PROCESS

	$STATE	INDEX
	$TRAN	'/'
	$STATE
	$TRAN	'INDEX'
	$TRAN	'SYSTEM',TPA$_EXIT,,OPT$M_SYSPROC,OPTIONS
	$STATE
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_HEX,TPA$_EXIT,,,PROC_INDEX

;
;	SHOW POOL /IRP /NONPAGED /PAGED /ALL /SUMMARY /HEADER
;

	$STATE	POOL
	$TRAN	TPA$_EOS,TPA$_EXIT,SHOW_POOL
	$TRAN	'!',TPA$_EXIT,SHOW_POOL
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,POOL_RANGE
	$STATE
	$TRAN	'IRP',POOL,,OPT$M_IRP,OPTIONS
	$TRAN	'LRP',POOL,,OPT$M_LRP,OPTIONS
	$TRAN	'SRP',POOL,,OPT$M_SRP,OPTIONS
	$TRAN	'NONPAGED',POOL,,OPT$M_NONPAGED,OPTIONS
	$TRAN	'PAGED',POOL,,OPT$M_PAGED,OPTIONS
	$TRAN	'ALL',POOL,,OPT$M_IRP!OPT$M_NONPAGED!OPT$M_PAGED,OPTIONS
	$TRAN	'SUMMARY',POOL,,OPT$M_SUMMARY,OPTIONS
	$TRAN	'HEADER',POOL,,OPT$M_HEADER,OPTIONS
	$TRAN	'FREE',POOL,,OPT$M_FREE,OPTIONS
	$TRAN	'TYPE',,,OPT$M_TYPE,OPTIONS
	$STATE
	$TRAN	'='
	$TRAN	':'
	$STATE
	$TRAN	TPA$_SYMBOL,POOL,,,STRUCTURE

;
;	SHOW POOL  start:end
;		   start;length
;

	$STATE	POOL_RANGE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	SEMI,,,OPT$M_LENGTH,OPTIONS
	$TRAN	COLON,,,OPT$M_RANGE,OPTIONS
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,SHOW_POOL_RANGE

;
;	SHOW STACK /mode
;

	$STATE	STACK
	$TRAN	TPA$_EOS,TPA$_EXIT,PRINT_STACKS
	$TRAN	'!',TPA$_EXIT,PRINT_STACKS
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,STACK_RANGE
	$STATE
	$TRAN	'INTERRUPT',STACK,,OPT$M_ISP,OPTIONS
	$TRAN	'KERNEL',STACK,,OPT$M_KSP,OPTIONS
	$TRAN	'EXECUTIVE',STACK,,OPT$M_ESP,OPTIONS
	$TRAN	'SUPERVISOR',STACK,,OPT$M_SSP,OPTIONS
	$TRAN	'USER',STACK,,OPT$M_USP,OPTIONS
	$TRAN	'ALL',STACK,,OPT$M_ALL,OPTIONS

;
;	SHOW STACK start:end
;		   start;length
;

	$STATE	STACK_RANGE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	SEMI,,,OPT$M_LENGTH,OPTIONS
	$TRAN	COLON,,,OPT$M_RANGE,OPTIONS
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,PRINT_ANY_STACK

;
;	SHOW PFN_DATA <optional pfn>
;

	$STATE	PFN_DATA
	$TRAN	'/',PFN_OPTION
	$TRAN	!EXPRESSION,,,OPT$M_SINGLEPFN,OPTIONS
	$TRAN	TPA$_LAMBDA,,,OPT$M_FREE!OPT$M_MODIFIED!OPT$M_BAD!OPT$M_WHOLEPFN,OPTIONS
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,DISPLAY_PFN

	$STATE	PFN_OPTS
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,DISPLAY_PFN
	$STATE	PFN_OPTION
	$TRAN	'FREE',PFN_OPTS,,OPT$M_FREE,OPTIONS
	$TRAN	'MODIFIED',PFN_OPTS,,OPT$M_MODIFIED,OPTIONS
	$TRAN	'BAD',PFN_OPTS,,OPT$M_BAD,OPTIONS
	$TRAN	'SYSTEM',PFN_OPTS,,OPT$M_WHOLEPFN,OPTIONS
	$TRAN	'ALL',PFN_OPTS,,OPT$M_FREE!OPT$M_MODIFIED!OPT$M_BAD!OPT$M_WHOLEPFN,OPTIONS

;
;	SHOW PAGE_TABLE/SYSTEM/GLOBAL/ALL
;

	$STATE	PAGE_TABLE
	$TRAN	'/',PAGE_OPTION
	$TRAN	TPA$_LAMBDA,,,OPT$M_SYSTEM!OPT$M_GLOBAL,OPTIONS
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,DISPLAY_SPT
	$TRAN	TPA$_LAMBDA,PAGE_RANGE

	$STATE	PAGE_OPTS
	$TRAN	'/'
	$TRAN	TPA$_EOS,TPA$_EXIT,DISPLAY_SPT
	$TRAN	TPA$_LAMBDA,PAGE_RANGE
	$STATE	PAGE_OPTION
	$TRAN	'SYSTEM',PAGE_OPTS,,OPT$M_SYSTEM,OPTIONS
	$TRAN	'GLOBAL',PAGE_OPTS,,OPT$M_GLOBAL,OPTIONS
	$TRAN	'ALL',PAGE_OPTS,,OPT$M_ALL,OPTIONS


;
;	SHOW PAGE  start:end
;		   start;length
;

	$STATE	PAGE_RANGE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	SEMI,,,OPT$M_LENGTH,OPTIONS
	$TRAN	COLON,,,OPT$M_RANGE,OPTIONS
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,DISPLAY_SPT_RANGE

;
;	SHOW SYMBOL[/ALL] [name] [/ALL]
;

	$STATE	SYMBOL
	$TRAN	'/',SYMBOL_OPTS
	$TRAN	TPA$_SYMBOL,SYM,,,SYMBOL_NAME
	$TRAN	TPA$_EOS,TPA$_EXIT,SHOW_SYMBOL
	$STATE	SYM
	$TRAN	'/'
	$TRAN	TPA$_EOS,TPA$_EXIT,SHOW_SYMBOL
	$STATE	SYMBOL_OPTS
	$TRAN	'ALL',SYMBOL,,OPT$M_ALL,OPTIONS

;
;	SHOW DEVICE device
;

	$STATE	DEVICE
	$TRAN	TPA$_SYMBOL,TPA$_EXIT,DISPLAY_DEVICE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,DISPLAY_DEVICE

;
;	DEFINE symbol = value
;

	$STATE	DEFINE
	$TRAN	TPA$_SYMBOL,,,,SYMBOL_DESC
	$STATE
	$TRAN	'='
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,DEFINE_SYMBOL

;
;	HELP COMMAND 
;

	$STATE	HELP_CMD
	$TRAN	TPA$_EOS,TPA$_EXIT,DISPLAY_HELP
	$TRAN	!COLLECT,TPA$_EXIT,DISPLAY_HELP

;
;	EXIT COMMAND
;

	$STATE	EXIT_CMD
	$TRAN	TPA$_EOS,TPA$_EXIT,EXIT_COMMAND
	$TRAN	TPA$_STRING,TPA$_EXIT,EXIT_COMMAND

;
;	READ filespec
;

	$STATE	READ_CMD
	$TRAN	!READ_QUALS
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	!COLLECT,,,,FILE_DESC
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,READ_SYMFILE

	$STATE	READ_QUALS
	$TRAN	'/'
	$STATE
	$TRAN	'RELOCATE'
	$STATE
	$TRAN	'='
	$STATE
	$TRAN	!EXPRESSION,TPA$_EXIT,STORE_RELOCATION

;
;	COPY filespec
;

	$STATE	COPY_CMD
	$TRAN	!COLLECT,,,,FILE_DESC
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,SAVE_DUMP

;
;	FORMAT address /TYPE=struct
;

	$STATE	FORMAT_CMD
	$TRAN	!FORMAT_OPTS
	$STATE
	$TRAN	!EXPRESSION
	$STATE
	$TRAN	!FORMAT_OPTS
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,FORMAT

	$STATE	FORMAT_OPTS
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE
	$TRAN	'TYPE'
	$STATE
	$TRAN	'='
	$TRAN	':'
	$STATE
	$TRAN	TPA$_SYMBOL,,,,STRUCTURE
	$STATE
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,,1,OPTIONS


	$END_STATE

	.PSECT	PARSE,EXE,NOWRT

	.SBTTL	EXPRESSION ANALYSIS ACTION ROUTINES
;---
;
;	EXPRESSION ANALYSIS ACTION ROUTINES
;
;	THESE ROUTINES ARE CALLED FROM THE EXPRESSION ANALYSIS
;	PARSING TRANSITIONS TO EVALUATE ARGUMENTS USING A SEPARATE
;	STACK SPACE.
;
;   INPUTS:
;
;	AP = ADDRESS OF TPARSE PARAMETER BLOCK
;
;---

ADD2:	.WORD	0
	BSBB	EVAL_SETUP
	ADDL2	(R1)+,(R1)		; ADD 2 ARGUMENTS, RESULT ON TOP
	BRB	STORE

MULT2:	.WORD	0
	BSBB	EVAL_SETUP
	MULL2	(R1)+,(R1)		; MULTIPLY 2 ARGUMENTS, RESULT ON TOP
	BRB	STORE

SUB2:	.WORD	0
	BSBB	EVAL_SETUP
	SUBL2	(R1)+,(R1)		; SUBTRACT 2 ARGUMENTS, RESULT ON TOP
	BRB	STORE

DIV2:	.WORD	0
	BSBB	EVAL_SETUP
	TSTL	(R1)			; DO NOT ALLOW DIVIDE BY ZERO
	BEQL	FAILURE
	DIVL2	(R1)+,(R1)		; DIVIDE 2 ARGUMENTS, RESULT ON TOP
	BRB	STORE

SHIFT2:	.WORD	0
	BSBB	EVAL_SETUP
	MOVL	(R1)+,R0		; GET SHIFT COUNT
	ASHL	R0,(R1),(R1)		; SHIFT LEFT BY COUNT
	BRB	STORE

NEG1:	.WORD	0
	BSBB	EVAL_SETUP
	MNEGL	(R1),(R1)		; NEGATE 1 ARGUMENT, RESULT ON TOP
	BRB	STORE

EVAL_CONSTANT:
	.WORD	0
	BSBB	EVAL_SETUP
	MOVL	TPA$L_NUMBER(AP),-(R1)	; PUSH RESULT FROM TPARSE
	BRB	STORE

EVAL_SETUP:
	MOVL	ESP,R1			; R1 = STACK POINTER
	RSB

STORE:
	MOVL	(R1),TPA$L_NUMBER(AP)	; SAVE RESULT FOR CALLER
	MOVL	R1,ESP			; STORE STACK POINTER
	MOVL	#1,R0
	RET

FAILURE:
	CLRL	R0
	RET

EVAL_SYMBOL:
	.WORD	0
	PUSHAQ	TPA$L_TOKENCNT(AP)	; DESCRIPTOR OF SYMBOL NAME
	CALLS	#1,SYMBOL_VALUE		; TRY TO FIND IN SYMBOL TABLE
	BLBC	R0,FAILURE
	PUSHL	R1
	BSBB	EVAL_SETUP
	POPL	-(R1)			; PUSH RESULT ONTO STACK
	BRB	STORE

EVAL_DOT:
	.WORD	0
	BSBB	EVAL_SETUP
	MOVL	ADDRESS,-(R1)
	BRB	STORE

EVAL_CONTENTS:
	.WORD	0
	BSBB	EVAL_SETUP
	REQMEM	@(R1)			; GET CONTENTS OF LOCATION
	PUSHL	R1
	BSBB	EVAL_SETUP
	POPL	(R1)			; AND REPLACE ARG. ON TOP OF STACK
	BRB	STORE

ADD8000:				; ADDRESS IN SYSTEM REGION
	.WORD	0
	ADDL	#^X80000000,TPA$L_NUMBER(AP) ; ADD BASE OF SYSTEM REGION
	RET

ADD7FFE:				; ADDRESS IN CONTROL REGION
	.WORD	0
	ADDL	#^X7FFE0000,TPA$L_NUMBER(AP) ; CONTROL REGION
	RET

	.SBTTL	STORE_RELOCATION, STORE READ/RELOCATE VALUE
;---
;
;	STORE THE VALUE OF THE READ/RELOCATE QUALIFIER.
;
; INPUTS:
;
;	TPA$_L_NUMBER(AP) = RELOCATION BASE
;
; OUTPUTS:
;
;	RELOCATE_BASE = RELOCATION BASE
;---

STORE_RELOCATION:
	.WORD	0

	MOVL	TPA$L_NUMBER(AP),RELOCATE_BASE
	RET

	.SBTTL	SAVE_COMMAND, SAVE THE CURRENT COMMAND
;---
;
;	SAVE THE CURRENT COMMAND IN THE COMMAND BUFFER
;	SO THAT A LATER 'REPEAT' COMMAND CAN RECALL IT.
;
; INPUTS:
;
;	TPA$L_STRINGCNT(AP) = DESCRIPTOR OF STRING
;
; OUTPUTS:
;
;	PREV_COMMAND = DESCRIPTOR OF SAVED STRING
;
;---

SAVE_COMMAND::
	.WORD	^M<R2,R3,R4,R5>

	MOVW	TPA$L_STRINGCNT(AP),PREV_COMMAND
	MOVC	TPA$L_STRINGCNT(AP),@TPA$L_STRINGPTR(AP),-
		@PREV_COMMAND+4
	MOVL	#1,R0
	RET

	.SBTTL	REPEAT_COMMAND, REPEAT THE PREVIOUS COMMAND
;---
;
;	STORE THE PREVIOUS COMMAND IN THE COMMAND BUFFER
;	AND RESTART THE PARSE.
;
; INPUTS:
;
;	PREV_COMMAND = DESCRIPTOR OF PREVIOUS COMMAND
;
; OUTPUTS:
;
;	TPA$L_STRINGCNT(AP) = THE PREVIOUS COMMAND IS RELOADED
;
;---

REPEAT_COMMAND::
	.WORD	0

	MOVQ	PREV_COMMAND,TPA$L_STRINGCNT(AP)
	RET

	.SBTTL	Action Routines for SET|SHOW RMS/DISPLAY=optionspec
;+++
; SETUP_RMS_TMP -- Setup the temporary RMS options word.
;
; Inputs:
;
;	None.
;
; Outputs:
;
;	RMS_DIS_TMP = 0
;	RMS_IFI_TMP = 0
;---

SETUP_RMS_TMP:	.WORD	0
	CLRL	RMS_DIS_TMP
	CLRW	RMS_IFI_TMP
	MOVL	#1,R0
	RET

;+++
; STORE_TMP1_OPT -- Merge this particular option into temporary option word.
;
; Inputs:
;
;	RMS_DIS_TMP1 = Outcome of !DIS_OPT state (Possibly containing OPT$M_NO)
;
; Outputs:
;
;	RMS_DIS_TMP is set or cleared with value of RMS_DIS_TMP1 depending
;		    on value of OPT$M_NO in RMS_DIS_TMP1.
;---

STORE_TMP1_OPT:	.WORD	0
	BITL	#OPT$M_NO,RMS_DIS_TMP1	; was this display option "no'ed"?
	BNEQ	10$			; if neq yes
	BISL	RMS_DIS_TMP1,RMS_DIS_TMP
	MOVL	#1,R0
	RET
10$:	BICL	RMS_DIS_TMP1,RMS_DIS_TMP
	MOVL	#1,R0
	RET

;+++
; END_SET_RMS -- Finish the SET RMS Command.
;
; Inputs:
;
;	Final outputs of the SET RMS command:
;		RMS_DIS_TMP
;		RMS_IFI_TMP
;
; Outputs:
;
;	Permanent display options set:
;		RMS_DIS_OPT = RMS_DIS_TMP
;		RMS_IFI	    = RMS_IFI_TMP
;---

END_SET_RMS:.WORD	0
	MOVL	RMS_DIS_TMP,RMS_DIS_OPT
	MOVW	RMS_IFI_TMP,RMS_IFI
	MOVL	#1,R0
	RET

;+++
; STORE_IFI_TMP -- Set the temporary IFI from the results of !EXPRESSION.
;
; Inputs:
;
;	TPA$L_NUMBER(AP) = Results of !EXPRESSION
;
; Outputs:
;
;	RMS_IFI_TMP contains above value.
;---

STORE_IFI_TMP:.WORD	0
	MOVW	TPA$L_NUMBER(AP),RMS_IFI_TMP
	MOVL	#1,R0
	RET

;+++
; CLR_IFI_TMP -- Clear RMS_IFI_TMP.
;
; Inputs:
;
;	None.
;
; Outputs:
;
;	RMS_IFI_TMP = 0
;---

CLR_IFI_TMP:.WORD 0
	CLRW	RMS_IFI_TMP
	MOVL	#1,R0
	RET

;+++
; SETUP_DIS_OPT -- Setup for !DIS_OPT state.
;
; Inputs:
;
;	None.
;
; Outputs:
;
;	RMS_DIS_TMP1 = 0
;---

SETUP_DIS_OPT:.WORD	0
	CLRL	RMS_DIS_TMP1
	MOVL	#1,R0
	RET

;+++
; STORE_STAR -- Include into temporary options previous perm options.
;
; Inputs:
;
;	RMS_DIS_OPT = Permanent options.
;	RMS_IFI = Permanent IFI.
;
; Outputs:
;
;	RMS_DIS_TMP1 = RMS_DIS_OPT - OPT$M_NO
;	RMS_IFI_TMP = RMS_IFI
;---

STORE_STAR:.WORD 0
	PUSHL	RMS_DIS_OPT
	BICL	#OPT$M_NO,(SP)
	POPL	RMS_DIS_TMP1
	MOVW	RMS_IFI,RMS_IFI_TMP
	MOVL	#1,R0
	RET


	.END
