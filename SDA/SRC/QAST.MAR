	.TITLE	QAST - GET DATA FROM ANOTHER PROCESS
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	ROUTINES TO OBTAIN MEMORY FROM ANOTHER PROCESS ON
;	THE RUNNING SYSTEM.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V004	TMH0004		Tim Halvorsen	21-May-1981
;		Add additional checks in memory fetch, to prevent
;		machine checks when attempting to access I/O space
;		with a MOVC3 instruction.
;
;	V003	TMH0003		Tim Halvorsen	07-Feb-1981
;		Change word displacements to longword displacements
;
;	V002	TMH0002		Tim Halvorsen		16-Dec-1980
;		Force the image counter to be incremented on any request
;		which has returns SS$_TIMEOUT, to prevent any response from
;		ever attempting to store the completion status into the
;		longword allocated on the stack, long after the routine
;		has returned and deallocated that longword.
;		Fix suspension code to set/clear SUSPEN flag in PCB while
;		performing suspend.  Check SUSPEN flag as well as state
;		when deciding whether to wake the destination process
;		because state may still be COM in last AST trying to get
;		the guy back into SUSP state.
;
;	V001	TMH0001		Tim Halvorsen		23-Oct-1980
;		Allow memory reads of suspended processes.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;

	$ACBDEF				; AST CONTROL BLOCK DEFINITIONS
	$PRIDEF				; PRIORITY DEFINITIONS
	$IPLDEF				; IPL DEFINITIONS
	$PCBDEF				; PROCESS CONTROL BLOCK
	$PHDDEF				; PROCESS HEADER
	$PSLDEF				; PSL DEFINITIONS
	$SSDEF				; STATUS DEFINITIONS
	$STATEDEF			; PROCESS STATE VALUES
	$MCHKDEF			; MACHINE CHECK PROTECTION MASK
	$VADEF				; VIRTUAL ADDRESS DEFINITIONS
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$RPBDEF				; RESTART PARAMETER BLOCK

;
;	DEFINE EXTENSIONS TO THE AST CONTROL BLOCK
;
	$DEFINI	PKT

PKT_ORIGPID	=	ACB$L_AST	; PID OF REQUESTOR
PKT_ADDR	=	ACB$L_ASTPRM	; ADDRESS OF REQUESTED DATA

.		=	ACB$L_KAST+4

$DEF	PKT_QAST	.BLKL		; ADDRESS OF SCH$QAST
$DEF	PKT_DEANON	.BLKL		; ADDRESS OF EXE$DEANONPAGED
$DEF	PKT_WAITK	.BLKL		; ADDRESS OF SCH$WAITK
$DEF	PKT_SUSP	.BLKL		; ADDRESS OF SCH$GQ_SUSP
$DEF	PKT_SUSPSIZ			; LENGTH OF RE-SUSPEND ACB

$DEF	PKT_RETLOC	.BLKL		; ADDRESS TO RETURN DATA
$DEF	PKT_LEN		.BLKL		; LENGTH OF DATA
$DEF	PKT_STATUS	.BLKL		; STATUS OF TRANSFER
$DEF	PKT_STATLOC	.BLKL		; ADDRESS TO RETURN STATUS
$DEF	PKT_WAKE	.BLKL		; ADDRESS OF SCH$WAKE
$DEF	PKT_ALBUF	.BLKL		; ADDRESS OF EXE$ALLOCBUF
;$DEF	PKT_PRTCT	.BLKL		; ADDRESS OF EXE$MCHK_PRTCT
$DEF	PKT_IMGCNT	.BLKL		; PHD$L_IMGCNT OF REQUESTOR
$DEF	PKT_FLAGS	.BLKB		; FLAGS BYTE
	_VIELD	PKT,0,<-
		<SUSPEND,,M>,-		; RE-SUSPEND PROCESS AFTER MEMORY FETCH
		>
$DEF	PKT_SIZE			; TOTAL SIZE OF FIXED PORTION
$DEF	PKT_DATABUF			; START OF DATA TO BE MOVED
					; AST CODE FOLLOWS DATA
	$DEFEND	PKT

	.DEFAULT DISPLACEMENT,LONG

	.PSECT	DATA,NOEXE,WRT

QAST_COUNT:
	.LONG	0			; QAST REQUEST COUNTER

	.PSECT	QAST,EXE,NOWRT

SECONDS	=	10*1000*1000		; 1 SECOND IN DELTA TIME

TIMEOUT:
	.LONG	-3*SECONDS,-1		; 3 SECOND TIMEOUT COUNT

	.SBTTL	GETPROCMEM - GET MEMORY FROM ANOTHER PROCESS
;---
;
;	READ MEMORY FROM ANOTHER PROCESS ON THE RUNNING SYSTEM.
;
; INPUTS:
;
;	04(AP) = LOCATION TO READ IN OTHER PROCESS CONTEXT
;	08(AP) = ADDRESS OF BUFFER IN LOCAL MEMORY TO RECIEVE TRANSFER
;	12(AP) = LENGTH OF TRANSFER
;	16(AP) = PID OF OTHER PROCESS
;
; OUTPUTS:
;
;	SS$_NORMAL	- MEMORY TRANSFERRED OK
;	SS$_ACCVIO 	- UNABLE TO ACCESS MEMORY
;	SS$_NOPRIV 	- NOT ENOUGH PRIVILEGE (CMKRNL)
;	SS$_NONEXPR	- NON-EXISTANT PROCESS OR INVALID PID
;---
	.ENTRY	GETPROCMEM,0

	PUSHL	#SS$_TIMEOUT		; PRESET TO TIMED OUT STATUS
	PUSHL	SP			; ADDRESS OF LONGWORD TO GET STATUS
	MOVQ	12(AP),-(SP)		; MOVE LENGTH AND PID
	MOVQ	4(AP),-(SP)		; MOVE SOURCE AND DESTINATION ADDRESSES
	PUSHL	#5			; NUMBER OF ARGUMENTS
	PUSHL	SP			; ADDRESS OF ARGUMENT LIST
	PUSHAB	QAST			; ADDRESS OF KERNEL MODE ROUTINE
	CALLS	#2,G^SYS$CMKRNL		; CALL ROUTINE IN KERNEL MODE
	BLBC	R0,90$			; IF ERROR, EXIT WITH STATUS
	ADDL	#6*4,SP			; REMOVE ARGUMENT LIST
	CMPL	R0,#3			; AST OUTSTANDING?
	BEQL	90$			; IF NOT, EXIT WITH SUCCESS
	INCL	QAST_COUNT		; INCREMENT THE COUNTER
	$SETIMR_S ASTADR=B^QAST_TIMEOUT,- ; SCHEDULE TIMEOUT REQUEST
		REQIDT=QAST_COUNT,-	; ASTPRM OF QAST COUNTER
		DAYTIM=TIMEOUT		; ADDRESS OF TIMEOUT DELTA TIME
	$HIBER_S			; WAIT FOR AST TO COMPLETE
	$CANTIM_S			; CANCEL OUTSTANDING TIMER REQUESTS
;
; HIBERNATE COULD HAVE COMPLETED DUE TO THE FOLLOWING REASONS:
;	1) WAKE FROM AST RESPONSE, REQUEST SUCCESSFUL
;	2) WAKE FROM TIMEOUT, REQUEST UNSUCCESSFUL, AST CANCELED BY TIMEOUT
;	3) WAKE FROM 'WAKE PENDING' FLAG, WHICH COMPLETES $HIBER IMMEDIATELY.
;		(NOT SURE WHAT SCENIOS CAUSE THIS, BUT BETTER SAFE...)
;
;	FOR CASE #3, WE CAN LIMIT THE DAMAGE BY CANCELING THE OUTSTANDING
;	AST SO THAT IT DOESN'T COME BACK AND WIPE OUT OUR STACK WITH THE
;	COMPLETION STATUS OR WIPE OUT OUR BUFFER WITH THE MEMORY.
;
	CMPL	(SP),#SS$_TIMEOUT	; HAS REQUEST HAS COME BACK YET?
	BNEQ	50$			; BRANCH IF IT HAS
	$CMKRNL_S B^REJECT_RESPONSE	; DONT LET AST EVER COME BACK
50$:	MOVL	(SP)+,R0		; GET RETURN STATUS
90$:	RET				; EXIT WITH SUCCESS

	.SBTTL	QAST_TIMEOUT - AST ROUTINE CALLED WHEN QAST TIMES OUT
;---
;
;	THIS AST ROUTINE IS CALLED WHEN A SPECIAL KERNEL MODE
;	AST REQUEST TO ANOTHER PROCESS TIMES OUT.  THE IMAGE
;	COUNTER IS INCREMENTED CAUSING THE KAST ROUTINE (WHEN
;	IT EVER GETS GOING AGAIN) TO DROP IT ON THE FLOOR.  THE
;	CURRENT PROCESS IS WOKEN UP.  THE STATUS LONGWORD HAS
;	BEEN PRESET TO SS$_TIMEOUT SO THAT IT KNOWS THE REQUEST
;	FAILED.
;
; INPUTS:
;
;	4(AP) = QAST REQUEST NUMBER
;
; OUTPUTS:
;
;	NONE
;---

QAST_TIMEOUT:
	.WORD	0

	CMPL	4(AP),QAST_COUNT	; IS THIS FOR THE CURRENT QAST?
	BNEQ	90$			; IF NOT, IGNORE THE TIMEOUT
	$CMKRNL_S B^REJECT_RESPONSE	; INCREMENT THE IMAGE COUNTER
	$WAKE_S				; WAKEUP THE CURRENT PROCESS
90$:	RET

REJECT_RESPONSE:
	.WORD	0
	MOVL	@SCH$GL_CURPCB,R0	; ADDRESS OF CURRENT PCB
	MOVL	PCB$L_PHD(R0),R1	; ADDRESS OF PHD
	INCL	PHD$L_IMGCNT(R1)	; INCREMENT IMAGE COUNTER
	RET

	.SBTTL	QAST - QUEUE MEMORY REQUEST TO ANOTHER PROCESS
;---
;
;	QAST - QUEUE AST TO READ MEMORY FROM ANOTHER PROCESS
;
; INPUTS:
;	04(AP) - LOCATION OF DATA
;	08(AP) - RETURN LOCATION
;	12(AP) - LENGTH OF TRANSFER
;	16(AP) - PID OF TARGET PROCESS
;	20(AP) - ADDRESS TO RETURN STATUS
;
; IMPLICIT INPUTS:
;
;	THE FOLLOWING SYMBOLS REFER TO LONGWORDS WHICH CONTAIN THE
;	VALUE OF THE SYMBOL FOR THE CURRENT RUNNING EXECUTIVE:
;
;	SCH$GL_CURPCB
;	SCH$GL_MAXPIX
;	SCH$GL_PCBVEC
;	SCH$GQ_SUSP
;	PHV$GL_PIXBAS
;	SGN$GL_BALSETCT
;	SWP$GL_BALBASE
;	SWP$GL_BSLOTSZ
;	MMG$GL_SPTBASE
;	EXE$GL_RPB
;	EXE$ALLOCBUF
;	EXE$DEANONPAGED
;	EXE$MCHK_PRTCT
;	SCH$QAST
;	SCH$WAKE
;	SCH$WAITK
;
; OUTPUTS:
;
;	R0 = 1 IF THE SPECIAL KERNEL MODE AST IS STILL OUTSTANDING
;		(IMPLIES HIBERNATE NEEDED IN CALLING ROUTINE)
;	R0 = 3 IF NO SPECIAL KERNEL AST WAS ISSUED (AVOID HIBERNATE)
;
;	SS$_ACCVIO = NO READ ACCESS TO MEMORY
;	SS$_NONEXPR = NON-EXISTANT PROCESS OR INVALID PID
;
;---

QAST:	.WORD	^M<R2,R3,R4,R5,R6>

;
; CHECK ACCESSIBILITY OF SYSTEM VA BECAUSE ALTHOUGH A PROBE INSTRUCTION
; WILL RETURN SUCCESS (PTE VALID), PAGEFAULT DOES NOT ALLOW ONE TO
; FAULT IN SOME ONE ELSES PROCESS PAGE TABLE PAGE (WHOSE WORKING SET
; DO YOU PUT IT IN?, ETC.) AND FAKES AN ACCESS VIOLATION ON THE MOVC.
; THUS, WE MUST MUCK IN SYSTEM SPACE IN THE CONTEXT OF THE PROCESS WHICH
; OWNS THE BALANCE SET SLOT TO AVOID PROBLEMS DISPLAYING HIS PROCESS
; PAGE TABLE.  ALSO, CHECK IF BEYOND END OF SYSTEM VIRTUAL MEMORY, AS
; PROBE DOES NOT DETECT THIS CONDITION, AND PAGEFAULT ABORTS ON IT.
;
	MOVL	16(AP),R6		; ASSUME SWITCHING TO "CURRENT" PROCESS
 	BBC	#VA$V_SYSTEM,4(AP),5$	; CONTEXT SWITCH IF NOT SYSTEM SPACE
	BICL3	#^X1FF,4(AP),R2		; CLEAR PAGE OFFSET
	SUBL3	@SWP$GL_BALBASE,R2,R0	; BELOW BALANCE SET SLOTS?
	BLSS	20$			; IF NOT, CHECK IF I/O SPACE
	ASHL	#-9,R0,R0		; COMPUTE BALANCE SET PAGE NUMBER
	DIVL	@SWP$GL_BSLOTSZ,R0	; PROCESS HEADER INDEX
	CMPW	R0,@SGN$GL_BALSETCT	; BEYOND END OF BALANCE SET SLOTS?
	BGEQ	8$			; IF SO, CHECK IF LEGAL AT ALL
	MOVL	@SCH$GL_CURPCB,R4	; GET ADDRESS OF CURRENT PCB
	MOVL	PCB$L_PHD(R4),R5	; GET ADDRESS OF CURRENT PHD
	CMPW	R0,PHD$W_PHVINDEX(R5)	; THIS PROCESS'S HEADER?
	BEQL	5$			; IF SO, OK TO USE THIS PROCESS CONTEXT
	MOVL	@PHV$GL_PIXBAS,R1	; GET ADDRESS OF HEADER/PIX ARRAY
	CVTWL	(R1)[R0],R0		; GET PROCESS INDEX OWNING BALANCE SLOT
	BLSS	80$			; ACCVIO IF NOBODY OWNS THE SLOT
	MOVL	@SCH$GL_PCBVEC,R1	; GET ADDRESS OF PCB ADDRESS ARRAY
	MOVL	(R1)[R0],R4		; GET PCB OWNING BALANCE SET SLOT
	MOVL	PCB$L_PID(R4),R6	; GET PID OF PROCESS WHICH OWNS SLOT
5$:	BRW	50$			; USE THAT PROCESS CONTEXT
;
;	SYSTEM ADDRESS IS BELOW THE BALANCE SET SLOTS.  CHECK IF MAPPED
;	BY ANY ACTIVE MEMORY CONTROLLER.  IF NOT, THEN ASSUME ITS I/O
;	SPACE AND DISALLOW TRANSFER.
;
20$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R3 ; EXTRACT SYSTEM PAGE NUMBER
	MOVL	@MMG$GL_SPTBASE,R1	; GET VIRTUAL BASE OF SPT
	MOVL	(R1)[R3],R3		; GET PAGE TABLE ENTRY
	BGEQ	40$			; IF NOT VALID, CAN'T BE I/O SPACE
					; (ALLOW TRANSFER TO CAUSE PAGEFAULT)
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R3,R3 ; GET PFN
	MOVL	@EXE$GL_RPB,R1		; GET RPB ADDRESS
	MOVAB	RPB$L_MEMDSC(R1),R1	; START OF MEMORY CONTROLLER DESC'S
	MOVL	#RPB$C_NMEMDSC,R2	; SIZE OF ARRAY
	ASSUME	RPB$V_BASEPFN EQ 32
	ASSUME	RPB$S_BASEPFN EQ 32
25$:	SUBL3	4(R1),R3,R0		; PFN LESS THAN BASE ADDRESS?
	BLSSU	28$			; IF SO, SKIP TO NEXT ONE
	CMPZV	#RPB$V_PAGCNT,#RPB$S_PAGCNT,(R1),R0 ; WITHIN RANGE OF MEMORY?
	BGTRU	40$			; IF SO, ALLOW ACCESS TO LOCATION
28$:	ADDL	#RPB$C_MEMDSCSIZ,R1	; SKIP TO NEXT DESCRIPTOR
	SOBGTR	R2,25$			; AND LOOP UNTIL END OF ARRAY
	BRB	80$			; NOT MAPPED BY ANY CONTROLLER, ACCVIO
;
;	SYSTEM ADDRESS IS ABOVE THE BALANCE SET SLOTS.  CHECK IF BEYOND
;	END OF SYSTEM VIRTUAL ADDRESS SPACE.
;
8$:	CMPL	R2,@MMG$GL_MAXGPTE	; LEGAL SYSTEM VA?
	BLSSU	40$			; IF GPTE, DON'T NEED TO SWITCH CONTEXT
80$:	MOVZWL	#SS$_ACCVIO,R0		; IF NOT, ACCESS VIOLATION
	RET
;
;	READ MEMORY FROM CURRENT PROCESS CONTEXT
;
40$:	MOVPSL	-(SP)			; GET CURRENT PSL
	INSV	#PSL$C_KERNEL,#PSL$V_PRVMOD,#PSL$S_PRVMOD,(SP)
	PUSHAB	42$			; ADDRESS FOLLOWING REI
	REI				; SET PREVIOUS MODE TO KERNEL
42$:	MOVL	4(AP),R2		; GET SOURCE BUFFER ADDRESS
	MOVQ	8(AP),R3		; GET DESTINATION ADDRESS AND LENGTH
	IFNORD	R4,(R2),80$		; CHECK FOR READ ACCESS
	IFNOWRT	R4,(R3),80$		; CHECK FOR WRITE ACCESS
;	PUSHAB	B^45$			; END OF RECOVERY BLOCK ADDESS
;	MOVL	#<MCHK$M_LOG!MCHK$M_MCK!MCHK$M_NEXM!MCHK$M_UBA>,R0 ; PROTECT MASK
;	JSB	@EXE$MCHK_PRTCT		; INHIBIT MACHINE CHECKS
	MOVC	R4,(R2),(R3)		; MOVE DATA TO BUFFER
;	RSB				; END OF PROTECTED CODE
;45$:	BLBC	R0,80$			; BRANCH IF MACHINE CHECK OCCURRED
	MOVL	#3,R0			; SET NO AST OUTSTANDING
90$:	RET
;
;	READ MEMORY FROM SOME OTHER PROCESS CONTEXT
;
50$:	TSTL	R6			; ANY PID TO SWITCH TO?
	BEQL	40$			; BRANCH IF NOT
	MOVZWL	#SS$_NONEXPR,R0		; ASSUME BAD PID
	SUBW3	R6,@SCH$GL_MAXPIX,R1	; CHECK FOR LEGAL INDEX
	INCW	R1			; MAXPIX+1 = "SYSTEM PROCESS"
	BEQL	40$			; SKIP AST IF "SYSTEM PROCESS"
	BLSS	90$			; BR IF ILLEGAL INDEX
	ADDL3	#PKT_SIZE+CODELEN,12(AP),R1	; TOTAL SIZE OF BUFFER
	JSB	@EXE$ALLOCBUF		; ALLOCATE BUFFER FOR CODE
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	MOVL	R2,R5			; SAVE ADDRESS OF PACKET
	MOVL	R6,ACB$L_PID(R5)	; SET TARGET PID
	MOVB	#1@ACB$V_KAST,ACB$B_RMOD(R5)	; SET SPECIAL KERNEL AST
	MOVL	12(AP),R0		; GET LENGTH OF TRANSFER
	MOVAB	PKT_SIZE(R5)[R0],ACB$L_KAST(R5) ; SET ADDRESS FOR AST
	MOVL	R0,PKT_LEN(R5)		; SET LENGTH OF TRANSFER
	MOVL	4(AP),PKT_ADDR(R5)	; SET ADDRESS FOR FETCH
	MOVL	8(AP),PKT_RETLOC(R5)	; AND ADDRESS OF RETURN LOCATION
	MOVL	#SS$_ACCVIO,PKT_STATUS(R5) ; ASSUME NO READ ACCESS
	MOVL	20(AP),PKT_STATLOC(R5)	; ADDRESS TO RETURN STATUS
	MOVL	@SCH$GL_CURPCB,R4	; GET ADDRESS OF CURRENT PCB
	MOVL	PCB$L_PHD(R4),R0	; GET PHD ADDRESS
	MOVL	PCB$L_PID(R4),PKT_ORIGPID(R5)	; SET PID FOR RETURN
	MOVL	PHD$L_IMGCNT(R0),PKT_IMGCNT(R5)	; SET IMGCNT OF REQUESTOR
	CLRB	PKT_FLAGS(R5)		; AND CLEAR FLAGS BYTE
	PUSHL	R5			; SAVE REGS FOR MOVC
	MOVC3	#CODELEN,B^CODE,@ACB$L_KAST(R5)	; COPY CODE SEGMENT
	POPL	R5			; RESTORE REGISTERS
	MOVL	SCH$QAST,PKT_QAST(R5)	; COPY ABSOLUTE ADDRESSES IN EXECUTIVE
	MOVL	SCH$WAKE,PKT_WAKE(R5)
	MOVL	EXE$DEANONPAGED,PKT_DEANON(R5)
	MOVL	SCH$WAITK,PKT_WAITK(R5)
	MOVL	SCH$GQ_SUSP,PKT_SUSP(R5)
	MOVL	EXE$ALLOCBUF,PKT_ALBUF(R5)
;	MOVL	EXE$MCHK_PRTCT,PKT_PRTCT(R5)
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	MOVZWL	ACB$L_PID(R5),R0	; GET DESTINATION PID
	MOVL	@SCH$GL_PCBVEC,R1	; GET ADDRESS OF PCB VECTOR
	MOVL	(R1)[R0],R4		; GET DESTINATION PCB ADDRESS
	CMPW	PCB$W_STATE(R4),#SCH$C_SUSP	; IF PROCESS SUSPENDED
	BEQL	100$			; THEN RESUME IT
	CMPW	PCB$W_STATE(R4),#SCH$C_SUSPO	; OR SUSPENDED AND OUTSWAPPED
	BEQL	100$			; THEN RESUME IT
	BBS	#PCB$V_SUSPEN,PCB$L_STS(R4),100$ ; OR IF NOW BEING SUSPENDED
	JSB	@PKT_QAST(R5)		; QUEUE AST FOR TARGET
	SETIPL	#0			; DROP IPL, BLOCK IS GONE
	RET				; RETURN TO ORIGINAL MODE
;
;	RESUME DESTINATION PROCESS AND QUEUE ANOTHER AST SO THAT
;	THE PROCESS WILL BE RE-SUSPENDED FOLLOWING MEMORY AST.
;
100$:	MOVB	#PKT_M_SUSPEND,PKT_FLAGS(R5)	; MARK PROCESS IN SUSPEND STATE
	JSB	@PKT_QAST(R5)		; QUEUE AST TO THE TARGET PROCESS
	SETIPL	#0			; LOWER IPL, BLOCK IS NOW GONE
	$RESUME_S PIDADR=PCB$L_PID(R4)	; RESUME PROCESS SO AST WILL EXECUTE
	RET				; RETURN
;
;	CODE PLACED IN NON-PAGED BUFFER EXECUTED IN
;	DESTINATION PROCESS CONTEXT.
;
CODE:	IFNORD	PKT_LEN(R5),@PKT_ADDR(R5),10$	; BRANCH IF NOT READABLE
	PUSHR	#^M<R4,R5>		; SAVE REGISTERS
;	PUSHAB	B^5$			; END OF RECOVERY BLOCK ADDESS
;	MOVL	#<MCHK$M_LOG!MCHK$M_MCK!MCHK$M_NEXM!MCHK$M_UBA>,R0 ; PROTECT MASK
;	JSB	@PKT_PRTCT(R5)		; INHIBIT MACHINE CHECKS
	MOVC	PKT_LEN(R5),@PKT_ADDR(R5),PKT_DATABUF(R5) ; GET DATA
;	RSB				; END OF PROTECTED CODE
5$:	POPR	#^M<R4,R5>		; RESTORE REGISTERS
;	BLBC	R0,10$			; BRANCH IF MACHINE CHECK OCCURRED
	MOVL	#SS$_NORMAL,PKT_STATUS(R5) ; SET SUCCESS ON TRANSFER
10$:	ASSUME	PKT_V_SUSPEND EQ 0
	BLBC	PKT_FLAGS(R5),40$	; BRANCH IF NOT RE-SUSPENDING
	BBSS	#PCB$V_SUSPEN,PCB$L_STS(R4),40$ ; SKIP IF SUSPEND BEING DONE
					; MARK PROCESS BEING PLACED IN 'SUSP'
	MOVZBL	#PKT_SUSPSIZ+SUSPLEN,R1	; TOTAL SIZE OF SUSPEND AST
	JSB	@PKT_ALBUF(R5)		; ALLOCATE AST BUFFER TO SUSPEND PROC
	BLBC	R0,40$			; IF NO MEMORY, LEAVE IT RESUMED
	MOVL	ACB$L_PID(R5),ACB$L_PID(R2)	; SUSPEND CURRENT PROCESS
	MOVB	#1@ACB$V_KAST,ACB$B_RMOD(R2)	; SPECIAL KERNEL AST
	MOVAB	PKT_SUSPSIZ(R2),ACB$L_KAST(R2)	; SET ADDRESS OF CODE
	ASSUME	PKT_DEANON EQ PKT_QAST+4
	MOVQ	PKT_QAST(R5),PKT_QAST(R2)	; COPY QAST, DEANON ADDRESSES
	ASSUME	PKT_SUSP EQ PKT_WAITK+4
	MOVQ	PKT_WAITK(R5),PKT_WAITK(R2)	; COPY WAITK,SUSP ADDRESSES
	PUSHR	#^M<R2,R5>		; SAVE REGISTERS
	MOVC	S^#SUSPLEN,B^SUSP,@ACB$L_KAST(R2) ; COPY SUSPEND CODE INTO BLOCK
	POPL	R5			; GET SAVED R2 INTO R5
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	JSB	@PKT_QAST(R5)		; QUEUE THE RE-SUSPEND AST
	POPL	R5			; GET SAVED ADDRESS OF CURRENT ACB
40$:	MOVL	PKT_ORIGPID(R5),ACB$L_PID(R5)	; SET PID FOR RETURN AST
	MOVB	#1@ACB$V_KAST,ACB$B_RMOD(R5)	; SET FOR KAST AGAIN
	MOVAB	B^REPLY,ACB$L_KAST(R5)	; SET NEW AST ADDRESS
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	JMP	@PKT_QAST(R5)		; QUEUE RETURN AST AND EXIT
;
;	CODE PLACED IN NON-PAGED BUFFER EXECUTED IN
;	ORIGINATOR PROCESS CONTEXT TO RETURN MEMORY
;	TO REQUESTED BUFFER AND RETURN COMPLETION STATUS.
;
REPLY:	MOVL	PCB$L_PHD(R4),R0	; GET ADDRESS OF PROCESS HEADER
	CMPL	PKT_IMGCNT(R5),PHD$L_IMGCNT(R0)	; CHECK IF STILL SAME IMAGE
	BNEQ	DEALOC			; IF NOT, DROP TRANSFER ON FLOOR
	IFNOWRT	PKT_LEN(R5),@PKT_RETLOC(R5),130$ ; BRANCH IF NOT WRITABLE
	PUSHL	R5			; SAVE REGISTER
	MOVC	PKT_LEN(R5),PKT_DATABUF(R5),@PKT_RETLOC(R5) ; MOVE DATA
	POPL	R5			; RESTORE REGISTER
130$:	IFNOWRT	#4,@PKT_STATLOC(R5),140$ ; BRANCH IF STATUS NOT WRITABLE
	MOVL	PKT_STATUS(R5),@PKT_STATLOC(R5)	; RETURN STATUS
140$:	MOVL	ACB$L_PID(R5),R1	; GET PID FOR WAKE
	SETIPL	#IPL$_SYNCH		; RAISE TO SYNCH
	JSB	@PKT_WAKE(R5)		; WAKE REQUESTOR PROCESS
	BRB	DEALOC			; DEALLOCATE AST AND EXIT

;
;	CODE PLACED IN NON-PAGED BUFFER EXECUTED IN DESTINATION
;	PROCESS CONTEXT IN ORDER TO RE-SUSPEND A PROCESS WHICH
;	IS SUPPOSED TO BE SUSPENDED BUT WAS RESUMED IN ORDER TO
;	LET THE MEMORY AST EXECUTE.
;
SUSP:	SETIPL	#IPL$_SYNCH		; DISABLE SYSTEM EVENTS
50$:	BBSC	#PCB$V_RESPEN,PCB$L_STS(R4),60$ ; SKIP IF RESUME PENDING
	MOVL	PKT_SUSP(R5),R2		; GET ADDRESS OF SUSPEND QUEUE HEAD
	MOVPSL	-(SP)			; MOVE PSL TO STACK
	JSB	@PKT_WAITK(R5)		; PLACE PROCESS IN WAIT QUEUE
	BRB	50$			; ON RESUME (RESPEN=1), CLEANUP, EXIT
60$:	BBCC	#PCB$V_SUSPEN,PCB$L_STS(R4),DEALOC ; CLEAR SUSPEND IN PROGRESS
DEALOC:	SETIPL	#IPL$_ASTDEL		; RESTORE IPL
	MOVL	R5,R0			; SET ADDRESS FOR RELEASE
	JMP	@PKT_DEANON(R5)		; FREE BLOCK
SUSPLEN = .-SUSP			; SIZE OF SUSPEND CODE SEGMENT

CODELEN = .-CODE			; SIZE OF ENTIRE CODE SEGMENT

	.END
