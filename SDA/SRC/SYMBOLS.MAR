	.TITLE	SYMBOLS	SYSTEM SYMBOL TABLE ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	ROUTINE TO READ THE SYSTEM SYMBOL TABLE AND
;	MANIPULATE THE INTERNAL SORTED SYMBOL TABLE.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V02-017	KTA0071		Kerbey T. Altmann	29-Jan-1982
;		Add yet more symbols for yet more new pool allocs.
;
;	V02-016	KTA0062		Kerbey T. Altmann	04-Jan-1982
;		Add symbols for new pool allocations.
;
;	V02-015	KTA0044		Kerbey T. Altmann	12-Nov-1981
;		Add symbols for LRP lists.
;
;	V02-014	KTA0027		Kerbey T. Altmann	30-Jul-1981
;		Modify to use new table for DYN symbols present
;		in module POOL. Also support negative offsets.
;
;	V02-13	KEK0004		K. E. Kinnear		29-Jul-1981
;		Add CTL$GL_CCBBASE and PIO$GW_IIOIMPA for new
;		SHOW PROC/RMS command.
;
;	V02-012	LJK0030		Lawrence J. Kenah	20-Jul-1981
;		Changed PFN$AW_name symbols for BLINK, FLINK, and WSLX
;		to use PFN$Ax_name.
;
;	V02-011	LJK0029		Lawrence J. Kenah	20-Jul-1981
;		Make listheads for three physical page lists longwords instead 
;		of words and change all references to these listheads.
;
;	V03-010	KTA0024		Kerbey T. Altmann	15-Jul-1981
;		Add new symbol CTL$AL_STACKLIM.
;
;	V009	MTR0001		Mike Rhodes	22-Jun-1981
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;		Change default addressing mode to longword.
;		Remove ref's to $SDAMSGDEF macro.
;
;	V008	TMH0008		Tim Halvorsen	22-May-1981
;		Add new required symbols for QAST crash protection.
;
;	V007	TMH0007		Tim Halvorsen	21-May-1981
;		Perform relocation of new symbols via READ/RELOCATE
;
;	V006	TMH0006		Tim Halvorsen	20-May-1981
;		Speed up symbolization by a factor of 100 or so
;		Speed up FORMAT command by using alphabetized tree
;		to find symbols, rather than value-ordered tree.
;		(Thanks to Barry Scott in Reading, England).
;
;	V005	TMH0005		Tim Halvorsen	08-Feb-1981
;		Add symbols marking the start of drivers and machine check.
;
;	V004	TMH0004		Tim Halvorsen	19-Jan-1981
;		Remove all word offset references to r/w data cells
;		to fix truncation errors.
;
;	V003	TMH0003		Tim Halvorsen	19-Jan-1981
;		Speed up symbol table creation by avoiding search
;		to see if the symbol already exists in the table.
;		During initialization, it is assumed that no symbols
;		are duplicated.
;
;	V002	TMH0002		Tim Halvorsen	23-Oct-1980
;		Attempt to symbolize addresses in P0 space to facilitate
;		debugging of processes like ACP's, etc.
;		Add SCH$GQ_SUSP and SCH$WAITK required symbols
;
;	V001	TMH0001		Tim Halvorsen	30-Sep-1980
;		Add EXE$GB_CPUTYPE to required symbol list
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$RABDEF			; RMS RECORD ACCESS BLOCK
	$STSDEF			; COMPLETION CODE FIELDS
	$DMPDEF			; DUMP FILE DEFINITIONS
	$EMBDEF <CR>		; ERROR LOG ENTRY DEFINITIONS
	$OBJDEF			; OBJECT MODULE DEFINITIONS
	$SYMDEF			; SDA SYMBOL TABLE DEFINITIONS
	$NODEDEF		; TREE NODE DEFINITIONS
	$TPADEF			; TPARSE DEFINITIONS
	$IRPDEF			; IRP DEFINITIONS (FOR BLOCK TYPE)
	$PHDDEF			; PHD DEFINITIONS (FOR INTERNAL SYMS)
	$DPTDEF			; DPT DEFINITIONS

	.SBTTL	SYSTEM SYMBOLS USED IN THE ANALYSIS
;
;	THIS DEFINES THE SYSTEM SYMBOLS AND THEIR VALUES TO BE
;	USED LATER IN THE ANALYSIS OF THE DUMP.  EACH ENTRY IS
;	VARIABLE LENGTH, WITH THE FIRST LONGWORD CONTAINING THE
;	VALUE AND THE REMAINING BYTES HOLDING THE COUNTED STRING.
;	THE TABLE IS TERMINATED BY A LONGWORD OF -1.
;

	.PSECT	ZREQSYMS,NOEXE,WRT	; PUT AFTER DATA, BEFORE CODE

	.MACRO	SYMBOL	NAME,OPTIONAL
NAME::
	.IF	B,OPTIONAL
	.LONG	0		; REQUIRED SYMBOL
	.IFF
	.LONG	1		; OPTIONAL SYMBOL (MAY NOT BE THERE)
	.ENDC
	.ASCIC	\NAME\
	.ENDM

REQ_SYMBOLS:
	SYMBOL	CTL$AL_STACK	; PROCESS STACKS INFORMATION
	SYMBOL	CTL$AL_STACKLIM	; PROCESS STACKS LIMIT INFORMATION
	SYMBOL	CTL$GL_CCBBASE	; START OF CHANNEL CONTROL AREA
	SYMBOL	CTL$GL_IMGHDRBF,OPTIONAL ; IMAGE HEADER BUFFER ADDRESS
	SYMBOL	EXE$GB_CPUTYPE	; PROCESSOR TYPE CODE
	SYMBOL	EXE$GL_NONPAGED	; NON-PAGED FREE LIST HEAD
	SYMBOL	EXE$GL_PAGED	; PAGED FREE LIST HEAD
	SYMBOL	EXE$GL_RPB	; RESTART PARAMETER BLOCK ADDRESS
	SYMBOL	EXE$GL_SPLITADR	; ADDRESS OF IRP LOOKASIDE POOL
	SYMBOL	EXE$GQ_SYSTIME	; SYSTEM ABSOLUTE TIME IN NANOSECONDS
	SYMBOL	EXE$AL_STACKS	; SYSTEM STACK INFORMATION
	SYMBOL	EXE$GL_INTSTK	; ADDRESS OF INTERRUPT STACK
	SYMBOL	EXE$MCHK	; ADDRESS OF MACHINE CHECK TRANSFER VECTOR
	SYMBOL	IOC$GL_DEVLIST	; HEAD OF DDB LIST
	SYMBOL	IOC$GL_DPTLIST	; HEAD OF DPT LIST
	SYMBOL	IOC$GL_IRPCNT	; NUMBER OF IRP ENTRIES AVAILABLE
	SYMBOL	IOC$GL_IRPFL	; IRP FREE LIST HEAD
	SYMBOL	IOC$GL_LRPCNT	; NUMBER OF LRP ENTRIES AVAILABLE
	SYMBOL	IOC$GL_LRPFL	; LRP FREE LIST HEAD
	SYMBOL	IOC$GL_LRPSIZE	; LRP PACKET SIZE
	SYMBOL	IOC$GL_LRPSPLIT	; ADDRESS OF LRP LOOKASIDE POOL
	SYMBOL	IOC$GL_SRPCNT	; NUMBER OF SRP ENTRIES AVAILABLE
	SYMBOL	IOC$GL_SRPFL	; SRP FREE LIST HEAD
	SYMBOL	IOC$GL_SRPSIZE	; SRP PACKET SIZE
	SYMBOL	IOC$GL_SRPSPLIT	; ADDRESS OF LRP LOOKASIDE POOL
	SYMBOL	MMG$AL_SYSPCB	; ADDRESS OF SYSTEM PROCESS HEADER
	SYMBOL	MMG$FRSTRONLY	; ADDRESS OF READ-ONLY EXEC CODE
	SYMBOL	MMG$IMGHDRBUF	; IMAGE HEADER BUFFER (P1 SPACE)
	SYMBOL	MMG$GL_GPTE	; FIRST GLOBAL PAGE TABLE ENTRY
	SYMBOL	MMG$GL_MAXGPTE	; MAXIMUM GLOBAL PAGE TABLE ENTRY
	SYMBOL	MMG$GL_MAXPFN	; MAX PFN COVERED BY PFN DATA BASE
	SYMBOL	MMG$GL_RMSBASE	; ADDRESS OF RMS CODE
	SYMBOL	MMG$GL_SBR	; PHYSICAL ADDRESS OF SPT
	SYMBOL	MMG$GL_SPTLEN	; LENGTH OF SPT IN PAGES
	SYMBOL	MMG$GL_SPTBASE	; ADDRESS OF SYSTEM PAGE TABLE
	SYMBOL	MMG$GL_SYSPHD	; ADDRESS OF SYSTEM PROCESS HEADER
	SYMBOL	MMG$GL_NPAGEDYN ; ADDRESS OF NON-PAGED POOL
	SYMBOL	MMG$GL_NPAGNEXT	; ADDRESS OF END OF NON-PAGED POOL
	SYMBOL	MMG$GL_PAGEDYN	; ADDRESS OF PAGED POOL
	SYMBOL	PIO$GW_IIOIMPA	; ADDRESS OF I/O IMPURE AREA
	SYMBOL	PFN$AB_STATE	; CURRENT STATE OF PAGE FRAME
	SYMBOL	PFN$AB_TYPE	; TYPE OF PAGE FRAME ENTRY
	SYMBOL	PFN$AL_BAK	; BACKING STORE ADDRESS
	SYMBOL	PFN$AL_HILIMIT	; MAXIMUM THRESHOLD FOR PAGE LISTS
	SYMBOL	PFN$AL_LOLIMIT	; MINIMUM THRESHOLD FOR PAGE LISTS
	SYMBOL	PFN$AL_PTE	; ADDRESS OF PROCESS PTE
	SYMBOL	PFN$AX_BLINK	; BACKWARD PAGE LIST LINK
	SYMBOL	PFN$AX_FLINK	; FORWARD PAGE LIST LINK
	SYMBOL	PFN$AL_HEAD	; HEADERS FOR PAGE LISTS
	SYMBOL	PFN$AW_REFCNT	; REFERENCE COUNT FOR PAGE
	SYMBOL	PFN$AX_WSLX	; WORKING SET LIST INDEX
	SYMBOL	PFN$A_BASE	; BASE ADDRESS OF PFN ARRAYS
	SYMBOL	SCH$GL_CURPCB	; CURRENT PCB ADDRESS
	SYMBOL	SCH$GL_FREECNT	; ADDRESS OF PAGE LIST COUNTS
	SYMBOL	SCH$GL_PCBVEC	; VECTOR OF PCB ADDRESSES
	SYMBOL	SCH$GL_MAXPIX	; MAXIMUM PROCESS INDEX
	SYMBOL	SGN$GL_PAGEDYN	; LENGTH OF PAGED POOL
	SYMBOL	SGN$GW_ISPPGCT	; INTERRUPT STACK PAGE COUNT
	SYMBOL	SWP$A_KSTK	; ADDRESS OF SWAPPER STACK
	SYMBOL	SWP$K_KSTKSZ	; LENGTH OF SWAPPER STACK
	SYMBOL	SYS$GQ_VERSION	; VERSION OF SYSTEM (E.G. 6.01)
;
;	SYMBOLS USED TO EXAMINE CURRENT RUNNING SYSTEM
;
	SYMBOL	EXE$ALLOCBUF	; ALLOCATE NON-PAGED STORAGE
	SYMBOL	EXE$DEANONPAGED	; DEALLOCATE NON-PAGED STORAGE
	SYMBOL	EXE$MCHK_PRTCT	; MACHINE CHECK PROTECTION
	SYMBOL	PHV$GL_PIXBAS	; ADDRESS OF BALANCE SLOT TO PIX WORD ARRAY
	SYMBOL	SCH$QAST	; QUEUE AN AST TO ANOTHER PROCESS
	SYMBOL	SCH$WAKE	; WAKE A PROCESS
	SYMBOL	SCH$WAITK	; PLACE PROCESS IN WAIT QUEUE
	SYMBOL	SCH$GQ_SUSP	; SUSPEND WAIT QUEUE HEADER
	SYMBOL	SGN$GL_BALSETCT	; NUMBER OF BALANCE SET SLOTS
	SYMBOL	SWP$GL_BSLOTSZ	; SIZE OF EACH BALANCE SET SLOT IN PAGES
	SYMBOL	SWP$GL_BALBASE	; STARTING ADDRESS OF BALANCE SET SLOTS

REQ_SYMBOLS_LEN = . - REQ_SYMBOLS

RMS:	.ASCID	'RMS'		; STRING FOR SYMBOL "RMS"
MCHK:	.ASCID	'MCHK'		; STRING FOR SYMBOL "MCHK"

	.SBTTL	STORAGE DEFINTIONS
;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

STB_PTR:
	.BLKL	1			; POINTER FOR SCANNING STB FILE

TRANSLTH:
	.BLKL	1			; RESULT DESCRIPTOR FOR
	.BLKL	1			; "SYMBOLIZE" ROUTINE

SYMFL:					; SYMBOL VALUE TREE ROOT
	.BLKL	1
ALPFL:					; ALPHABETIC TREE ROOT
	.BLKL	1
NSYMBOLS:				; NUMBER OF SYMBOLS IN TABLE
	.BLKL	1

OFFSET_TABLE:
	.BLKL	2			; STARTING/ENDING ADDRESSES

STRUCTURE::
	.BLKL	2			; DESCRIPTOR OF STRUCTURE NAME

	.PSECT	SYMBOLS,EXE,NOWRT

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

	.MACRO	DEFINE	REG,VALUE,?L1
	.SAVE
	.PSECT	LITERALS,EXE,NOWRT
L1:	STRING	<REG>
	.RESTORE
	.LONG	L1
	.IF	B,<VALUE>
	.LONG	^XC0000000+PHD$L_'REG'
	.IFF
	.LONG	VALUE
	.ENDC
	.ENDM

REG_TABLE:
	DEFINE	R0
	DEFINE	R1
	DEFINE	R2
	DEFINE	R3
	DEFINE	R4
	DEFINE	R5
	DEFINE	R6
	DEFINE	R7
	DEFINE	R8
	DEFINE	R9
	DEFINE	R10
	DEFINE	R11
	DEFINE	R12
	DEFINE	R13
	DEFINE	AP,<^XC0000000+PHD$L_R12>
	DEFINE	FP,<^XC0000000+PHD$L_R13>
	DEFINE	USP
	DEFINE	SSP
	DEFINE	ESP
	DEFINE	KSP
	DEFINE	PC
	DEFINE	PSL
	DEFINE	P0BR
	DEFINE	P0LR,<^XC0000000+PHD$L_P0LRASTL>
	DEFINE	P1BR
	DEFINE	P1LR
	DEFINE	G,<^X80000000>
	DEFINE	H,<^X7FFE0000>
	.QUAD	0			; END OF TABLE

PRTCTL1:
	STRING	<!15AC !XL!12* >
PRTCTL2:
	STRING	^/!15AC !XL => !XL/

TRANSCTL1:
	STRING	<!AC+!3XL>		; SYMBOL+OFFSET

TRANSCTL2:
	STRING	<!AC>			; SYMBOL (IF 0 OFFSET)

	.SBTTL	REWIND_STB - REWIND SYSTEM SYMBOL TABLE FILE
;---
;
;	REWIND_STB
;
;	THIS ROUTINE INITIALIZES THINGS SO THAT ANOTHER PASS
;	CAN BE MADE OVER THE SYSTEM SYMBOL TABLE FILE.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	THE FILE IS REWOUND.
;	STB_PTR = 0 TO INDICATE NO RECORDS READ YET.
;
;---

REWIND_STB::
	.WORD	0

;	$REWIND	STB			; REWIND ACTUAL FILE
;	SIGNAL	RMS,STB
	CLRL	STB_PTR			; INITIALIZE SCAN POINTER
	RET

	.SBTTL	GET_SYMBOL - GET NEXT GSD SYMBOL ENTRY FROM STB
;---
;
;	GET_SYMBOL
;
;	THIS ROUTINE GETS THE NEXT GSD-SYMBOL DEFINTION
;	ENTRY FROM THE SYSTEM SYMBOL TABLE FILE.
;
;   INPUTS:
;
;	STB_PTR = POINTER TO THE NEXT GSD ENTRY IN THE RECORD
;		  OR ZERO IF THE FILE IS REWOUND.
;
;   OUTPUTS:
;
;	R0 = FALSE IF END OF FILE IS REACHED, ELSE TRUE
;	R1 = POINTER TO THE SYMBOL DEFINITION ENTRY
;
;---

GET_SYMBOL::
	.WORD	^M<R2,R3,R4,R5>

	MOVAL	STB,R3
	MOVZWL	RAB$W_RSZ(R3),R2	; GET LENGTH OF RECORD
	MOVAB	STB_BUFFER(R2),R2	; ENDING ADDRESS OF RECORD
	MOVL	STB_PTR,R1		; GET BUFFER POINTER
	BNEQ	20$			; BRANCH IF VALID
10$:
	$GET	(R3)			; GET NEXT STB RECORD
	CMPL	R0,#RMS$_EOF		; CHECK FOR END OF FILE
	BNEQ	15$			; IF NOT, GO ON
	CLRL	R0			; INDICATE FAILURE
	RET
15$:	SIGNAL	RMS,(R3)		; CHECK FOR RMS ERROR
	MOVAB	STB_BUFFER,R1		; INITIALIZE POINTER
	CMPB	OBJ$B_TYPE(R1),#OBJ$C_GSD  ; ONLY LOOK AT GSD RECORDS
	BNEQ	10$			; BRANCH IF NOT GSD RECORD
	MOVZWL	RAB$W_RSZ(R3),R2	; GET LENGTH OF RECORD
	ADDL	R1,R2			; ENDING ADDRESS OF RECORD
	INCL	R1			; SKIP RECORD IDENTIFICATION
20$:
	CMPL	R1,R2			; CHECK IF END OF RECORD
	BGEQU	10$			; BRANCH IF SO
	MOVZBL	OBJ$B_GSD_TYPE(R1),R0	; GET GSD ENTRY TYPE CODE
	ASSUME	OBJ$C_GSD_PSC EQ 0
	ASSUME	OBJ$C_GSD_SYM EQ 1
	ASSUME	OBJ$C_GSD_EPM EQ 2
	ASSUME	OBJ$C_GSD_PRO EQ 3
	CASE	R0,TYPE=B,-		; CASE ON GSD ENTRY TYPE CODE
		<30$,25$,40$,10$>
	PUSHL	R0			; OUTPUT UNKNOWN TYPE
	SIGNAL	1,BADGSD		; UNKNOWN TYPE OF GSD ENTRY
	BRB	10$			; SKIP TO NEXT RECORD
;
;	OBJ$C_GSD_SYM - GLOBAL SYMBOL DEFINITION
;
25$:	BBC	#OBJ$V_SYM_DEF,OBJ$W_SYM_FLAGS(R1),27$ ; BRANCH IF REFERENCE
	MOVZBL	OBJ$T_SYM_NAME(R1),R0	; GET LENGTH OF STRING
	MOVAB	OBJ$T_SYM_NAME+1(R1)[R0],STB_PTR ; SKIP PAST ENTRY
	STATUS	SUCCESS
	RET
;
;	OBJ$C_GSD_SYM - GLOBAL SYMBOL REFERENCE
;
27$:	MOVZBL	OBJ$T_SYM_NAME-5(R1),R0	; LENGTH OF STRING
	MOVAB	OBJ$T_SYM_NAME-5+1(R1)[R0],R1 ; SKIP PAST ENTRY
	BRB	20$			; CONTINUE SEARCHING
;
;	OBJ$C_GSD_PSC - PSECT DEFINITION
;
30$:	MOVZBL	OBJ$T_PSC_NAME(R1),R0		; GET LENGTH OF STRING
	MOVAB	OBJ$T_PSC_NAME+1(R1)[R0],R1	; SKIP THIS ENTRY
	BRB	20$			; CONTINUE SEARCHING
;
;	OBJ$C_GSD_EPM - ENTRY POINT AND MASK DEFINITION
;
40$:	MOVZBL	OBJ$T_EPM_NAME(R1),R0	; LENGTH OF NAME
	MOVAB	OBJ$T_EPM_NAME+1(R1)[R0],STB_PTR  ; SAVE POINTER
;	THE FOLLOWING MAKES THE EPM ENTRY LOOK LIKE A SYM ENTRY.
	PUSHL	R1			; SAVE POINTER TO ENTRY
	INCL	R0			; LENGTH OF COUNTED STRING
	MOVC	R0,OBJ$T_EPM_NAME(R1),OBJ$T_SYM_NAME(R1)
	MOVL	(SP)+,R1		; RESTORE POINTER TO ENTRY
	STATUS	SUCCESS
	RET

	.SBTTL	ADD_SYMBOL -- ADD SYMBOL TO SYMBOL TABLE
;---
;
;	ADD_SYMBOL
;
;	THIS ROUTINE ADDS A SYMBOL TO THE LOCAL SYMBOL TABLE.
;
;   INPUTS:
;
;	4(AP) = LENGTH OF SYMBOL
;	8(AP) = ADDRESS OF SYMBOL
;	12(AP) = SYMBOL VALUE
;	RELOCATE_BASE = SYMBOL RELOCATION BASE (NON-ZERO ON READ/RELOCATE)
;			(ONLY USED ON NEW SYMBOLS, NOT ON SYMBOL REPLACEMENTS)
;
;---

	.ENTRY	ADD_SYMBOL,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

;
;	TRUNCATE SYMBOL TO 31 CHARACTERS
;
	CMPW	4(AP),#31		; 31 CHARACTERS?
	BLEQ	5$			; BRANCH IF NO PROBLEM
	MOVW	#31,4(AP)		; TRUNCATE TO 31 CHARACTERS
5$:
;
;	SEARCH SYMBOL TABLE TO SEE IF ALREADY EXISTS
;
	MOVL	ALPFL,R7		; ROOT OF ALPHA SORTED TREE
10$:	BEQL	50$			; BRANCH IF NOT IN SYMBOL TABLE
	MOVL	NODE$L_PTR(R7),R6	; ADDRESS OF SYMBOL TABLE ENTRY
	MOVZBL	SYM$T_SYMBOL(R6),R0	; LENGTH OF SYMBOL
	CMPC5	4(AP),@8(AP),#^A' ',R0,SYM$T_SYMBOL+1(R6)
	BEQL	40$			; BRANCH IF FOUND
	BGTRU	20$			; BRANCH IF GREATER
	MOVL	NODE$L_LEFT(R7),R7	; GO TO LEFT BRANCH OF TREE
	BRB	10$			; CONTINUE DOWN TREE
20$:	MOVL	NODE$L_RIGHT(R7),R7	; GO TO RIGHT SIDE OF TREE
	BRB	10$			; CONTINUE DOWN TREE
;
;	SYMBOL ALREADY EXISTS, SIMPLY RE-DEFINE VALUE
;
40$:	MOVL	12(AP),SYM$L_VALUE(R6)	; RE-DEFINE SYMBOL
	BRB	90$			; AND EXIT
;
;	CREATE NEW SYMBOL TABLE ENTRY (RELOCATING VALUE, IF NECESSARY)
;
50$:	MOVQ	4(AP),R2		; GET DESCRIPTOR OF SYMBOL NAME
	MOVL	12(AP),R4		; AND GET VALUE OF SYMBOL
	TSTL	RELOCATE_BASE		; ARE WE RELOCATING?
	BEQL	15$			; BRANCH IF NOT
	ASHL	#-16,R4,R0		; GREATER THAN 16k?
	BNEQ	15$			; ONLY RELOCATE PROGRAM OFFSETS
	ADDL	RELOCATE_BASE,R4	; RELOCATE THE SYMBOL
15$:	BSBB	ADD_NEW_ENTRY		; ADD NEW SYMBOL TABLE ENTRY
	
90$:	STATUS	SUCCESS			; RETURN SUCCESS
	RET

	.SBTTL	ADD_NEW_ENTRY, ADD NEW ENTRY TO TABLE
;---
;
;	INSERT A NEW SYMBOL TABLE ENTRY INTO THE SYMBOL TABLE
;
;   INPUTS:
;
;	R2/R3 = DESCRIPTOR OF SYMBOL
;	R4 = SYMBOL VALUE
;
; OUTPUTS:
;
;	SYMBOL ENTRY INSERTED INTO CORRECT POSITION
;
;	R2-R5, R8-R11 DESTROYED.
;---

ADD_NEW_ENTRY:
	PUSHL	#SYM$C_LENGTH		; LENGTH OF BLOCK
	CALLS	#1,ALLOCATE		; ALLOCATE A SYMBOL TABLE ENTRY
	MOVL	R1,R8			; SET ADDRESS OF NEW ENTRY
	MOVL	R4,SYM$L_VALUE(R8)	; STORE VALUE
	MOVB	R2,SYM$T_SYMBOL(R8)	; SET SYMBOL LENGTH
	MOVC3	R2,(R3),SYM$T_SYMBOL+1(R8)
	INCL	NSYMBOLS		; INCREMENT NUMBER OF SYMBOLS
;
;	INSERT ENTRY INTO ASCENDING VALUE ORDERED TREE
;
	MOVL	SYMFL,R9		; INITIALIZE AT ROOT OF TREE
	MOVAB	B^COMPARE_VALUE,R11	; ADDRESS OF COMPARE ROUTINE
	BSBB	INSERT			; INSERT INTO VALUE TREE
	MOVL	R9,SYMFL		; SET NEW ROOT OF TREE
;
;	INSERT ENTRY INTO ASCENDING ALPHABETICALLY ORDERED TREE
;
	MOVL	ALPFL,R9		; INITIALIZE AT ROOT OF TREE
	MOVAB	B^COMPARE_ALPHA,R11	; ADDRESS OF COMPARE ROUTINE
	BSBB	INSERT			; INSERT INTO ALPHA TREE
	MOVL	R9,ALPFL		; SET NEW ROOT OF TREE
	RSB

	.SBTTL	COMPARE_VALUE, COMPARE SYMBOL ENTRIES BY VALUE
;---
;
;	COMPARE THE VALUES OF 2 ENTRIES
;
; INPUTS:
;
;	R8 = ADDRESS OF SYMBOL TABLE ENTRY TO BE INSERTED
;	R9 = ADDRESS OF CURRENT NODE
;
; OUTPUTS:
;
;	PSL CONDITIONS SET.
;---

COMPARE_VALUE:
	MOVL	NODE$L_PTR(R9),R2	; ADDRESS OF SYMBOL TABLE ENTRY
	CMPL	SYM$L_VALUE(R8),SYM$L_VALUE(R2)
	RSB

	.SBTTL	COMPARE_ALPHA, COMPARE SYMBOL ENTRIES BY NAME
;---
;
;	COMPARE THE STRING NAMES OF 2 ENTRIES
;
; INPUTS:
;
;	R8 = ADDRESS OF SYMBOL TABLE ENTRY TO BE INSERTED
;	R9 = ADDRESS OF CURRENT NODE
;
; OUTPUTS:
;
;	PSL CONDITIONS SET.
;---

COMPARE_ALPHA:
	MOVL	NODE$L_PTR(R9),R2	; ADDRESS OF SYMBOL TABLE ENTRY
	CMPB	SYM$T_SYMBOL+1(R8),SYM$T_SYMBOL+1(R2)	; CHECK 1ST CHAR
	BNEQ	90$			; BRANCH IF THATS ENOUGH
	MOVZBL	SYM$T_SYMBOL(R8),R0	; GET LENGTH OF NEW NAME
	MOVZBL	SYM$T_SYMBOL(R2),R1	; GET LENGTH OF CURRENT NAME
	CMPC5	R0,SYM$T_SYMBOL+1(R8),#^A' ',-	; COMPARE STRINGS
		R1,SYM$T_SYMBOL+1(R2)
90$:	RSB

	.SBTTL	INSERT, RECURSIVE ROUTINE TO INSERT INTO TREE
;---
;
;	INSERT
;
;	RECURSIVE SUBROUTINE TO INSERT THE NEW NODE INTO THE TREE
;
; INPUTS:
;
;	R8  = POINTER TO NEW SYMBOL TABLE ENTRY
;	R9  = POINTER TO CURRENT NODE IN TREE
;	R11 = ADDRESS OF ROUTINE TO COMPARE NEW AND CURRENT KEYS
;
; OUTPUTS:
;
;	R9 = NEW POINTER TO CURRENT NODE IN TREE
;---

INSERT:	TSTL	R9			; NULL POINTER? (BOTTOM OF TREE)
	BNEQ	10$			; BRANCH IF NOT
;
;	REACHED BOTTOM OF TREE - INSERT INTO TREE AT BOTTOM
;
	PUSHL	#NODE$C_LENGTH		; LENGTH OF NODE
	CALLS	#1,ALLOCATE		; ALLOCATE A NEW NODE
	MOVL	R1,R9			; SET ADDRESS OF NEW NODE
	MOVL	R8,NODE$L_PTR(R9)	; SET ADDR OF SYMBOL ENTRY
	CLRQ	NODE$L_LEFT(R9)		; ZERO LEFT AND RIGHT POINTERS
	CLRW	NODE$W_BAL(R9)		; SET BALANCE TO ZERO
	MOVL	#1,R0			; INDICATE NOT BALANCED
	RSB
;
;	CHECK IF KEY IS TO THE LEFT OR RIGHT SUBTREE
;
10$:	JSB	(R11)			; COMPARE KEY ON CURRENT NODE
	BGTRU	200$			; BRANCH IF TO THE RIGHT SIDE
;	BEQL	300$			; BRANCH IF ALREADY EXISTS
;
;	INSERT THE NODE INTO THE LEFT SUBTREE
;
	PUSHL	R9			; SAVE POINTER OF FATHER
	MOVL	NODE$L_LEFT(R9),R9	; SETUP POINTER TO LEFT SON
	BSBB	INSERT			; INSERT INTO LEFT SUBTREE
	MOVL	R9,R1			; SAVE NEW ADDRESS OF SUBTREE
	POPL	R9			; RETURN TO FATHER NODE
	MOVL	R1,NODE$L_LEFT(R9)	; POINT TO NEW LEFT SUBTREE
	BLBS	R0,110$			; BRANCH IF NOT BALANCED
40$:	BRW	90$			; EXIT
50$:	BRW	80$			; EXIT - MARK IN BALANCE
;
;	THE LEFT SUBTREE HAS GROWN HIGHER - RESTORE BALANCE
;
110$:	DECW	NODE$W_BAL(R9)		; PERFORM LEFT SHIFT OF TREE
	BEQL	50$			; EXIT IF IN PERFECT BALANCE
	BLBS	NODE$W_BAL(R9),40$	; EXIT IF AVL BLANACED
	MOVL	NODE$L_LEFT(R9),R1	; R1 = POINTER TO LEFT SUBTREE
	TSTW	NODE$W_BAL(R1)		; TEST BALANCE ON THAT SIDE
	BGEQ	120$			; BRANCH IF NEED DOUBLE ROTATION
;	PERFORM SINGLE LL ROTATION
	MOVL	NODE$L_RIGHT(R1),NODE$L_LEFT(R9)
	MOVL	R9,NODE$L_RIGHT(R1)
	CLRW	NODE$W_BAL(R9)		; MARK IN BALANCE
	MOVL	R1,R9			; SET NEW ROOT OF SUBTREE
	BRW	250$			; INDICATE IN PERFECT BALANCE
;	PERFORM DOUBLE LR ROTATION
120$:	MOVL	NODE$L_RIGHT(R1),R2	; R2 = RIGHT SON OF LEFT SUBTREE
	MOVL	NODE$L_LEFT(R2),NODE$L_RIGHT(R1)
	MOVL	R1,NODE$L_LEFT(R2)
	MOVL	NODE$L_RIGHT(R2),NODE$L_LEFT(R9)
	MOVL	R9,NODE$L_RIGHT(R2)
	CLRW	NODE$W_BAL(R9)		; INITIALIZE BALANCE INDICATORS
	CLRW	NODE$W_BAL(R1)
	TSTW	NODE$W_BAL(R2)		; CHECK BALANCE OF NEW SUBTREE
	BEQL	240$			; SKIP IF IN BALANCE
	BGTR	130$			; BRANCH IF LEFT SIDE HEAVY
	MOVW	#1,NODE$W_BAL(R9)	; MARK RIGHT SIDE HEAVY
	BRB	240$			; SET NEW SUBTREE AND EXIT
130$:	MNEGW	#1,NODE$W_BAL(R1)	; MARK LEFT SIDE HEAVY
	BRB	240$			; SET NEW SUBTREE AND EXIT
;
;	INSERT NEW NODE INTO RIGHT SUBTREE
;
200$:	PUSHL	R9			; SAVE POINTER OF FATHER
	MOVL	NODE$L_RIGHT(R9),R9	; SETUP POINTER TO RIGHT SON
	BSBW	INSERT			; INSERT INTO LEFT SUBTREE
	MOVL	R9,R1			; SAVE NEW ADDRESS OF SUBTREE
	POPL	R9			; RETURN TO FATHER NODE
	MOVL	R1,NODE$L_RIGHT(R9)	; POINT TO NEW RIGHT SUBTREE
	BLBC	R0,90$			; EXIT IF BALANCED
;
;	THE RIGHT SUBTREE HAS GROWN HIGHER - RESTORE BALANCE
;
	INCW	NODE$W_BAL(R9)		; PERFORM RIGHT SHIFT OF TREE
	BEQL	80$			; EXIT IF IN PERFECT BALANCE
	BLBS	NODE$W_BAL(R9),90$	; EXIT IF AVL BLANACED
	MOVL	NODE$L_RIGHT(R9),R1	; R1 = POINTER TO RIGHT SUBTREE
	TSTW	NODE$W_BAL(R1)		; TEST BALANCE ON THAT SIDE
	BLEQ	220$			; BRANCH IF NEED DOUBLE ROTATION
;	PERFORM SINGLE RR ROTATION
	MOVL	NODE$L_LEFT(R1),NODE$L_RIGHT(R9)
	MOVL	R9,NODE$L_LEFT(R1)
	CLRW	NODE$W_BAL(R9)		; MARK IN BALANCE
	MOVL	R1,R9			; SET NEW ROOT OF SUBTREE
	BRB	250$			; INDICATE IN PERFECT BALANCE
;	PERFORM DOUBLE RL ROTATION
220$:	MOVL	NODE$L_LEFT(R1),R2	; R2 = LEFT SON OF RIGHT SUBTREE
	MOVL	NODE$L_RIGHT(R2),NODE$L_LEFT(R1)
	MOVL	R1,NODE$L_RIGHT(R2)
	MOVL	NODE$L_LEFT(R2),NODE$L_RIGHT(R9)
	MOVL	R9,NODE$L_LEFT(R2)
	CLRW	NODE$W_BAL(R9)		; INITIALIZE BALANCE INDICATORS
	CLRW	NODE$W_BAL(R1)
	TSTW	NODE$W_BAL(R2)		; CHECK BALANCE OF NEW SUBTREE
	BEQL	240$			; SKIP IF IN BALANCE
	BGTR	230$			; BRANCH IF LEFT SIDE HEAVY
	MOVW	#1,NODE$W_BAL(R1)	; MARK RIGHT SIDE HEAVY
	BRB	240$			; SET NEW SUBTREE AND EXIT
230$:	MNEGW	#1,NODE$W_BAL(R9)	; MARK LEFT SIDE HEAVY
;
;	SET NEW POINTER TO SUBTREE
;
240$:	MOVL	R2,R9			; SET NEW SUBTREE
;
;	MARK SUBTREE IN PERFECT BALANCE
;
250$:	CLRW	NODE$W_BAL(R9)		; MARK IN PERFECT BALANCE
;
;	RETURN R0 FALSE TO INDICATE NEITHER SIDE IS HEAVY
;
80$:	CLRL	R0			; MARK IN BALANCE
90$:	RSB

	.SBTTL	ALLOCATE, ALLOCATE DYNAMIC MEMORY
;---
;
;	THIS ROUTINE ALLOCATES DYNAMIC MEMORY BY EXPANDING THE
;	REGION IF NECESSARY TO OBTAIN THE REQUESTED AMOUNT OF
;	MEMORY.
;
; INPUTS:
;
;	4(AP) = SIZE OF BLOCK TO ALLOCATE
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = ADDRESS OF ALLOCATED BLOCK
;
;	ANY ERRORS ARE SIGNALLED IMMEDIATELY.
;---

	.ENTRY	ALLOCATE,0

	PUSHAL	-(SP)			; RECEIVES ADDRESS OF MEMORY
	PUSHAL	4(AP)			; LENGTH TO ALLOCATE
	CALLS	#2,G^LIB$GET_VM		; ALLOCATE MEMORY
	SIGNAL				; SIGNAL IF NO STORAGE
	MOVL	(SP)+,R1		; RETURN ADDRESS TO CALLER
	RET				; RETURN WITH STATUS

	.SBTTL	DEALLOCATE, DEALLOCATE DYNAMIC MEMORY
;---
;
;	DEALLOCATE DYNAMIC MEMORY
;
; INPUTS:
;
;	4(AP) = STARTING ADDRESS TO DEALLOCATE
;	8(AP) = LENGTH TO DEALLOCATE
;
; OUTPUTS:
;
;	R0 = STATUS
;
;	ANY ERROR IS SIGNALLED IMMEDIATELY.
;---

	.ENTRY	DEALLOCATE,0

	PUSHAL	4(AP)			; STARTING ADDRESS
	PUSHAL	8(AP)			; LENGTH
	CALLS	#2,G^LIB$FREE_VM	; DEALLOCATE STORAGE
	SIGNAL				; SIGNAL ANY ERRORS
	RET

	.SBTTL	READ_SYMBOLS -- READ STB SYMBOLS INTO SYMBOL TABLE
;---
;
;	READ_SYMBOLS
;
;	THIS ROUTINE READS ALL THE SYSTEM SYMBOLS INTO DYNAMIC
;	STORAGE AND CREATES A LIST IN ASCENDING ORDER BY
;	SYMBOL VALUE.  THIS MAKES IT POSSIBLE TO TRANSFORM
;	A GIVEN VALUE INTO A SYMBOL NAME AND AN OFFSET BY
;	SCANNING THE SYMBOL TABLE UNTIL THE CORRECT AREA
;	IS DETERMINED.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	SYMFL = LIST HEADER FOR SORTED VALUE LIST
;	ALPFL = LIST HEADER FOR SORTED ALPHABETIC LIST
;
;---

	.ENTRY	READ_SYMBOLS,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	CALLS	#0,REWIND_STB		; REWIND THE STB FILE
	CLRL	NSYMBOLS		; ZERO NUMBER OF SYMBOLS
	CLRL	SYMFL			; INITIALIZE TREE ROOTS
	CLRL	ALPFL
;
;	READ GLOBAL SYMBOLS FROM SYS.STB INTO SYMBOL TABLE
;
10$:
	CALLS	#0,GET_SYMBOL		; GET NEXT SYMBOL ENTRY
	BLBC	R0,20$			; BRANCH IF END OF FILE
	MOVAB	OBJ$T_SYM_NAME(R1),R3	; GET ADDRESS OF ASCIC SYMBOL NAME
	MOVZBL	(R3)+,R2		; GET LENGTH AND ADDRESS
	MOVL	OBJ$L_SYM_VALUE(R1),R4	; GET VALUE OF SYMBOL
	BSBW	ADD_NEW_ENTRY		; ADD NEW SYMBOL (ASSUME NOT IN TABLE)
	BRB	10$			; CONTINUE UNTIL ALL SYMBOLS READ
20$:
	$CLOSE	STBF			; CLOSE SYSTEM SYMBOLS FILE
;
;	SAVE SPECIFIC SYMBOL VALUES IN REQUIRED SYMBOLS TABLE
;
	MOVAB	REQ_SYMBOLS,R6		; INITIALIZE TABLE POINTER
	MOVAB	REQ_SYMBOLS_LEN(R6),R7	; ENDING ADDRESS OF TABLE
30$:	PUSHAB	5(R6)			; CONSTRUCT STRING DESCRIPTORR
	MOVZBL	4(R6),-(SP)
	PUSHL	SP			; ADDRESS OF DESCRIPTOR
	CALLS	#3,SYMBOL_VALUE		; LOOKUP SYMBOL
	BLBC	R0,40$			; BRANCH IF NOT FOUND
	MOVL	R1,(R6)			; STORE VALUE OF SYMBOL
	BRB	50$			; GO ON TO NEXT SYMBOL
40$:
	BLBS	(R6),50$		; IGNORE IF OPTIONAL SYMBOL
	PUSHAB	4(R6)			; ADDRESS OF COUNTED STRING
	SIGNAL	1,NOREQ			; SIGNAL SYMBOL NOT FOUND
50$:
	MOVZBL	4(R6),R0		; LENGTH OF SYMBOL
	MOVAB	5(R6)[R0],R6		; INCREMENT POINTER
	CMPL	R6,R7			; CHECK IF END OF TABLE
	BLSSU	30$			; CONTINUE IF MORE TO DO
;
;	DEFINE SDA PERMANENT SYMBOLS (R0, ETC.)
;
	MOVAB	REG_TABLE,R2		; ADDRESS OF REGISTER TABLE
70$:
	MOVQ	(R2)+,R3		; GET SYMBOL ADDRESS, VALUE
	BEQL	80$			; BRANCH IF END OF TABLE
	PUSHL	R4			; VALUE OF SYMBOL
	MOVQ	(R3),-(SP)		; DESCRIPTOR OF SYMBOL
	CALLS	#3,ADD_SYMBOL		; ADD TO SYMBOL TABLE
	BRB	70$			; CONTINUE UNTIL DONE
;
;	DEFINE SPECIAL SYMBOL "RMS" TO BE BASE ADDRESS OF RMS
;
80$:	REQMEM	@MMG$GL_RMSBASE,-(SP)	; GET BASE OF RMS CODE
	MOVQ	RMS,-(SP)		; DESCRIPTOR OF RMS SYMBOL
	CALLS	#3,ADD_SYMBOL		; ADD TO SYMBOL TABLE
;
;	ADD SPECIAL SYMBOLS MARKING THE STARTING ADDRESS OF EACH DRIVER.
;	EACH SYMBOL WILL MARK THE START OF THE DRIVER PROLOGUE TABLE (DPT).
;
90$:	SUBL	#DPT$C_LENGTH,SP	; ALLOCATE BUFFER TO READ DPT'S
	MOVL	SP,R7			; AND SAVE ADDRESS OF IT
	TRYMEM	@IOC$GL_DPTLIST,DPT$L_FLINK(R7)	; SET ADDRESS OF FIRST DPT
	BLBC	R0,100$			; BRANCH IF ERROR
95$:	MOVL	DPT$L_FLINK(R7),R8	; SKIP TO NEXT DPT
	CMPL	R8,IOC$GL_DPTLIST	; CHECK IF BACK TO LISTHEAD
	BEQL	100$			; BRANCH IF END OF LIST
	TRYMEM	(R8),(R7),#DPT$C_LENGTH	; READ THE ENTIRE DPT
	BLBC	R0,100$			; BRANCH IF ERROR
	PUSHL	R8			; PUSH REAL ADDRESS OF ACTUAL DPT
	PUSHAB	DPT$T_NAME+1(R7)	; PUSH DESCRIPTOR OF DRIVER NAME
	MOVZBL	DPT$T_NAME(R7),-(SP)
	CALLS	#3,ADD_SYMBOL		; ADD TO SYMBOL TABLE
	BRB	95$
;
; ADD SPECIAL SYMBOLS FOR CPU-SPECIFIC LOADABLE CODE
;
100$:	MOVL	EXE$MCHK,R0		; GET ADDRESS OF EXE$MCHK VECTOR
					; (OF THE FORM: JMP @#MCHK_CODE)
	REQMEM	2(R0),-(SP)		; GET ACTUAL ADDRESS OF MCHK CODE
	MOVQ	MCHK,-(SP)		; PUSH DESCRIPTOR OF MCHK SYMBOL
	CALLS	#3,ADD_SYMBOL		; ADD TO SYMBOL TABLE

	STATUS	SUCCESS
	RET

	.SBTTL	PRINT_SYMBOLS -- PRINT ALL SYSTEM SYMBOLS
;---
;
;	PRINT_SYMBOLS
;
;	THIS ROUTINE PRINTS ALL THE SYSTEM SYMBOLS IN ASCENDING
;	VALUE ORDER AND THEIR ASSOCIATED VALUE.  IF A GENERIC
;	NAME IS SUPPLIED, THEN PRINT ONLY THOSE SYMBOLS STARTING
;	WITH THE GIVEN STRING.
;
;   INPUTS:
;
;	AP = ADDRESS OF DESCRIPTOR OF GENERIC NAME, IF ANY.
;	ALPFL = LIST HEADER FOR SORTED ALPHABETIC LIST
;	SYMFL = LIST HEADER FOR SORTED VALUE LIST
;
;   OUTPUTS:
;
;	NONE
;
;---

PRTBUFLEN	= 36			; CHARACTERS PER LINE SEGMENT
PRTBUFSIZ	= 8+PRTBUFLEN		; BYTES PER SEGMENT BUFFER
ROWS		= 54 			; ROWS PER COLUMN
COLUMNS		= 3 			; COLUMNS PER PAGE
STORAGE_SIZE	= ROWS*COLUMNS*PRTBUFSIZ ; # BYTES FOR ONE PAGE

PRINT_SYMBOLS::
	.WORD	^M<R2,R3,R4,R6,R7,R8,R9,R10,R11>

	SUBHD	<Symbols sorted by name>
	SKIP	PAGE
	MOVL	ALPFL,R9		; ROOT OF VALUE TREE
	BSBB	PRINT_LIST		; PRINT ENTIRE LIST

	SUBHD	<Symbols sorted by value>
	SKIP	PAGE
	MOVL	SYMFL,R9		; ROOT OF ALPHABETIC TREE
	BSBB	PRINT_LIST		; PRINT ENTIRE LIST
	RET

;
;	PRINT ENTIRE SYMBOL LIST
;
;	AP = ADDRESS OF DESCRIPTOR OF GENERIC NAME
;	R2 = ADDRESS OF LIST HEADER
;	R3 = LONGWORD INDEX TO LINK WITHIN SYMBOL RECORD
;

PRINT_LIST:
	PUSHL	#STORAGE_SIZE		; LENGTH OF BUFFER STORAGE
	CALLS	#1,ALLOCATE		; ALLOCATE BUFFER STORAGE
	MOVL	R1,R7			; SAVE ADDRESS OF BUFFER MATRIX
	MOVZWL	#ROWS*COLUMNS,R0	; REPEAT COUNT
	MOVL	R7,R4			; ADDRESS OF BUFFER MATRIX
5$:
	MOVL	#PRTBUFLEN,(R4)		; INITIALIZE DESCRIPTOR
	MOVAL	8(R4),4(R4)
	ADDL2	#PRTBUFSIZ,R4
	SOBGTR	R0,5$			; INIT. ALL DESCRIPTORS
	PUSHAB	TRAVERSE		; INIT CO-ROUTINE ADDRESS

10$:
	MOVL	R7,R4			; ADDRESS OF BUFFER MATRIX
	MOVZWL	#ROWS*COLUMNS,R6	; LOOP COUNT
20$:
	JSB	@(SP)+			; GET THE NEXT ENTRY
	BLBC	R0,90$			; BRANCH IF DONE
	MOVL	NODE$L_PTR(R9),R2	; ADDRESS OF SYMBOL TABLE ENTRY
	CMPL	SYM$L_VALUE(R2),#^XC0000000  ; CHECK IF INTERNAL SYMBOL
	BGEQU	20$			; SKIP SYMBOL IF SO
	TSTW	(AP)			; ANY GENERIC NAME?
	BEQL	25$			; BRANCH IF NOT
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS FOR CMPC
	CMPC	(AP),@4(AP),SYM$T_SYMBOL+1(R2) ; GENERIC MATCH?
	BEQL	22$			; BRANCH IF MATCH
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	BRB	20$			; KEEP LOOKING FOR MATCH
22$:	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
25$:	TRYMEM	@SYM$L_VALUE(R2)	; ATTEMPT TO READ CONTENTS
	BLBC	R0,30$			; IF LOCATION CANNOT BE READ
	PUSHL	R1			; CONTENTS OF LOCATION
	PUSHL	SYM$L_VALUE(R2)		; SYMBOL VALUE
	PUSHAB	SYM$T_SYMBOL(R2)	; SYMBOL NAME
	PUSHL	R4			; BUFFER DESCRIPTOR
	PUSHL	#0
	PUSHAB	PRTCTL2
	CALLS	#6,G^SYS$FAO		; FORMAT STRING
	BRB	50$
30$:
	PUSHL	SYM$L_VALUE(R2)		; SYMBOL VALUE
	PUSHAB	SYM$T_SYMBOL(R2)	; SYMBOL NAME
	PUSHL	R4			; BUFFER DESCRIPTOR 
	PUSHL	#0
	PUSHAB	PRTCTL1			; CONTROL STRING
	CALLS	#5,G^SYS$FAO		; FORMAT STRING
50$:
	ADDL2	#PRTBUFSIZ,R4		; NEXT OUTPUT DESCRIPTOR
	SOBGTR	R6,20$			; CONTINUE UNTIL PAGE FULL
	BSBB	PRINT_PAGE		; PRINT ENTIRE PAGE
	BRW	10$			; CONTINUE UNTIL DONE
90$:
	CLRL	(R4)			; ZERO DESCRIPTOR LENGTH
	ADDL2	#PRTBUFSIZ,R4
	SOBGTR	R6,90$			; ZERO REMAINING DESCRIPTORS
	BSBB	PRINT_PAGE		; PRINT LAST PAGE
	PUSHL	#STORAGE_SIZE		; LENGTH TO DEALLOCATE
	PUSHL	R7			; ADDRESS OF BUFFER STORAGE
	CALLS	#2,DEALLOCATE		; RELEASE STORAGE SPACE
	RSB

;
;	PRINT ENTIRE PAGE OF DESCRIPTORS
;

	.ENABL	LSB

PRINT_PAGE:
	MOVL	#ROWS,R6		; LINES TO PRINT
	MOVL	R7,R4			; R4 => 1ST SEGMENT IN EACH ROW
10$:
	ADDW3	(R4),ROWS*PRTBUFSIZ(R4),R0 ; ADD FIRST 2 LENGTHS
	ADDW	2*ROWS*PRTBUFSIZ(R4),R0	; ADD IN THIRD LENGTH
	BEQL	20$			; SKIP NULL LINES
	PUSHAQ	<2*ROWS*PRTBUFSIZ>(R4)
	PUSHAQ	<1*ROWS*PRTBUFSIZ>(R4)
	PUSHAQ	(R4)
	PRINT	3,<!AS!8* !AS!8* !AS>	; PRINT LINE
20$:	ADDL2	#PRTBUFSIZ,R4		; SKIP TO NEXT ROW
	SOBGTR	R6,10$			; LOOP UNTIL DONE
	RSB

	.DSABL	LSB

	.SBTTL	TRAVERSE, COROUTINE TO TRAVERSE A TREE
;---
;
;	TRAVERSE
;
;	THIS COROUTINE RETURNS THE NEXT ENTRY IN A TREE BY
;	TRAVERSING THE TREE IN PREORDER FASHION.  THE COROUTINE
;	TERMINATES AND RETURNS WITH R0 FALSE IF NO MORE ENTRIES
;	EXIST.
;
; INPUTS:
;
;	R9  = ADDRESS OF CURRENT NODE
;
; OUTPUTS:
;
;	R9 = ADDRESS OF NEXT NODE IN SEQUENCE
;	R0 = TRUE IF MORE TO GO, FALSE IF DONE
;
;	R11 IS DESTROYED.
;
;---

TRAVERSE:
	MOVL	(SP),R11		; SAVE RETURN ADDRESS
10$:	PUSHL	R9			; SAVE FATHER
	BEQL	90$			; EXIT IF NULL NODE
	MOVL	NODE$L_LEFT(R9),R9	; POINT TO LEFT SUBTREE
	BSBB	10$			; TRAVERSE THE LEFT HALF
	POPL	R9			; RESTORE FATHER
	MOVL	#1,R0			; TELL USER MORE TO COME
	JSB	(R11)			; CALL THE USER WITH NODE
	ADDL	#4,SP			; THROW THE RETURN ADDRESS AWAY
	PUSHL	R9			; SAVE FATHER
	MOVL	NODE$L_RIGHT(R9),R9	; POINT TO RIGHT SUBTREE
	BSBB	10$			; TRAVERSE THE RIGHT HALF
90$:	POPL	R9			; RESTORE FATHER
	CLRL	R0			; INDICATE NO MORE
	RSB

	.SBTTL	ALP_TRAVERSE -- TRAVERSE ALPHA TREE ON PREFIX MATCH
;---
;
;	ALP_TRAVERSE
;
;	This is a coroutine, like TRAVERSE, which scans the tree in
;	postorder, making a cocall on each node until the end of the
;	tree is reached.  It takes as an argument a prefix string
;	and only returns those nodes which match the prefix string.
;
;	INPUTS:
;
;	R6	Length of prefix string
;	R7	Address of each prefix string
;	R9	Listhead node
;
;	OUTPUTS:
;
;	R9	Address of current node
;	R10	Symbol block address for this node
;	R0	TRUE iff R9 contains a valid node address and scan hasn't ended
;
;	R11	is destroyed
;---

ALP_TRAVERSE:
	MOVL	(SP),R11		; Save return address
10$:
	TSTL	R9			; Reached terminal node?
	BEQL	40$			; Return if so
	MOVL	NODE$L_PTR(R9),R10	; Get symbol block
	CMPC3	R6,(R7),SYM$T_SYMBOL+1(R10) ; Compare prefix string
	BEQL	30$			; J if exact match, must return node
	BLSSU	20$			; J if less
	MOVL	NODE$L_RIGHT(R9),R9	; Greater - go right
	BRB	10$			; and loop
20$:
	MOVL	NODE$L_LEFT(R9),R9	; Less - go left
	BRB	10$			; and loop
30$:
	PUSHL	R9			; Equal - save this node
	MOVL	NODE$L_LEFT(R9),R9	; Scan left subtree
	BSBB	10$			; ...
	POPL	R9			; retrieve current node
	MOVL	NODE$L_PTR(R9),R10	; Get symbol block
	MOVL	#1,R0			; Show node present
	JSB	(R11)			; Cocall our caller
	MOVL	(SP)+,R11		; Replace return address
	PUSHL	R9			; Save R9 again
	MOVL	NODE$L_RIGHT(R9),R9	; Now scan right subtree
	BSBB	10$			; ...
	POPL	R9			; Recover node address
40$:	CLRL	R0			; Show no more to scan
	RSB				; And get out

	.SBTTL	SYMBOLIZE -- CONVERT VALUE TO SYMBOL AND OFFSET
;---
;
;	SYMBOLIZE
;
;	THIS ROUTINE ACCEPTS A VALUE AND RETURNS A STRING WHICH
;	CONTAINS A SYMBOL AND OFFSET CORRESPONDING TO THAT VALUE.
;
;   INPUTS:
;
;	 4(AP)	= VALUE TO BE TRANSLATED
;	 8(AP)	= ADDRESS OF QUADWORD RESULT STRING DESCRIPTOR
;
;   OUTPUTS:
;
;	THE STRING IS RETURNED IN THE RESULT BUFFER
;	R1	= ADDRESS OF DESCRIPTOR OF RESULT STRING
;
;---

SYMBOLIZE::
	.WORD	^M<R2,R3,R9,R11>

	MOVAL	TRANSLTH,R3
	MOVQ	@8(AP),(R3)		; PRESET RESULT DESCRIPTOR

	BBS	#31,4(AP),20$		; BRANCH IF SYSTEM ADDRESS
	BBS	#30,4(AP),20$		; BRANCH IF CONTROL REGION
	CMPL	4(AP),#^X200		; IS ADDRESS IN FIRST PAGE?
	BGEQU	20$			; IF NOT, ATTEMPT LOOKUP
10$:
	MOVL	R3,R1			; R1 -> OUTPUT STRING
	CLRL	(R1)			; RETURN NULL STRING
	RET
;
;	Search value ordered tree to find symbol.  The last symbol which
;	we pass on the way down the tree, whose value is less than the
;	value we are looking for, will be the largest symbol in the
;	tree which is less than the value (honest!).
;
20$:	CLRL	R2			; CLEAR 'LAST SMALLER VALUE' POINTER
	MOVL	SYMFL,R9		; GET TREE HEAD
30$:	BEQL	60$			; J IF REACHED TERMINAL NODE
	MOVL	NODE$L_PTR(R9),R0	; GET SYMBOL BLOCK
	CMPL	4(AP),SYM$L_VALUE(R0)	; COMPARE AGAINST KEY VALUE
	BEQL	50$			; J IF EXACT MATCH, LOOK NO MORE
	BLSSU	40$			; J IS LESS - TAKE LEFT BRANCH
	MOVL	R0,R2			; KEY IS LARGER - REMEMBER SYMBOL
	MOVL	NODE$L_RIGHT(R9),R9	; GO RIGHT
	BRB	30$			; AND LOOP
40$:	MOVL	NODE$L_LEFT(R9),R9	; KEY IS SMALLER - GO LEFT
	BRB	30$			; AND LOOP
50$:	MOVL	R0,R2			; EXACT MATCH - REMEMBER IT

					; BEST SYMBOL NOW IN R2
60$:	TSTL	R2			; FOUND A SYMBOL?
	BEQL	10$			; STRAIGHT OUT IF NOT
	SUBL3	SYM$L_VALUE(R2),4(AP),R1 ; OFFSET VALUE
	CMPL	R1,#^XFFF		; MUST NOT BE OVER 3 DIGITS
	BGTRU	10$			; IF SO, DO NOT TRANSLATE
	PUSHL	R1			; OFFSET VALUE
	PUSHAB	SYM$T_SYMBOL(R2)	; SYMBOL NAME
	PUSHL	8(AP)			; RESULT STRING DESCRIPTOR
	PUSHL	R3			; RESULT LENGTH
	TSTL	R1			; CHECK IF ZERO OFFSET
	BNEQ	70$			; BRANCH IF NONZERO
	PUSHAL	TRANSCTL2
	CALLS	#4,G^SYS$FAO		; FORMAT OUTPUT STRING
	BRB	80$
70$:	PUSHAL	TRANSCTL1		; CONTROL STRING
	CALLS	#5,G^SYS$FAO		; FORMAT OUTPUT STRING
80$:	MOVL	R3,R1			; R1 -> OUTPUT DESCRIPTOR
	RET

	.SBTTL	SYMBOL_VALUE -- GET VALUE OF SPECIFIED SYMBOL
;---
;
;	SYMBOL_VALUE
;
;	THIS ROUTINE RETURNS THE VALUE OF A GIVEN SYMBOL
;
;   INPUTS:
;
;	4(AP) = ADDRESS OF SYMBOL DESCRIPTOR
;
;   OUTPUTS:
;
;	R0 = TRUE IF SYMBOL FOUND
;	R1 = VALUE OF SYMBOL IF FOUND
;
;---

SYMBOL_VALUE::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>

	MOVQ	@4(AP),R8		; GET DESCRIPTOR
	MOVL	ALPFL,R7		; ROOT OF TREE
20$:
	TSTL	R7			; NULL POINTER?
	BEQL	80$			; IF NOT FOUND
	MOVL	NODE$L_PTR(R7),R6	; ADDRESS OF SYMBOL TABLE ENTRY
	MOVZBL	SYM$T_SYMBOL(R6),R0	; LENGTH OF SYMBOL
	CMPC5	R8,(R9),#^A' ',R0,SYM$T_SYMBOL+1(R6)
	BEQL	30$			; BRANCH IF NOT FOUND
	BGTRU	25$			; BRANCH IF GREATER
	MOVL	NODE$L_LEFT(R7),R7	; GO TO LEFT BRANCH OF TREE
	BRB	20$			; CONTINUE DOWN TREE
25$:	MOVL	NODE$L_RIGHT(R7),R7	; GO TO RIGHT BRANCH
	BRB	20$			; CONTINUE DOWN TREE
30$:	MOVL	#1,R0			; SYMBOL FOUND
	MOVL	SYM$L_VALUE(R6),R1	; VALUE OF SYMBOL
	RET
80$:
	CLRL	R0			; SYMBOL NOT FOUND
	RET

	.sbttl	FORMAT, Process the FORMAT command
;---
;
;	This routine processes the FORMAT command which
;	specifies an address and the symbol prefix used
;	to specify the type of data structure.  The symbol
;	table will be searched for all symbols containing
;	that structure and an ordered offset table is constructed
;	with pointers to the actual symbol table entries.
;	Only one offset table may be in use at any time.
;	A later specification of another structure in a FORMAT
;	command overrides the current specification.
;
; Inputs:
;
;	AP = TPARSE block (TPA$L_NUMBER contains the address)
;	OPTIONS = Non-zero if structure specified, else zero.
;	STRUCTURE = Quadword descriptor of structure string.
;
;---
	.enabl	lsb

typetab:
	.ascii	'QBWLTC'		; Valid types for FORMAT
typelen = .-typetab

	.entry	FORMAT,-
		^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

	movl	tpa$l_number(ap),address ; Set current location
	tstl	options			; Any new structure specified?
	bneq	10$			; If so, check the string
;
;	Obtain the structure name from the block type
;
	addl3	tpa$l_number(ap),#irp$b_type,r0
	getmem	(r0)			; Get the block type
	blbc	r0,80$			; Branch if cannot read
	movzbl	r1,r1			; Zero-extend the field
	beql	5$			; Branch if invalid
	cvtbl	dyn_map[r1],r2		; Pick up symbol info
	blss	5$			; Branch if invalid
	movzwl	dyn_ptr[r1],r2		; Pick up offset in name table
	movab	dyn_tab[r2],r2		; Address of name
	movzbl	(r2)+,structure		; Set length of name
	movl	r2,structure+4		; Set address of name
	brb	10$


5$:	signal	0,invblktyp		; Signal invalid block type
80$:	movl	#1,r0
	ret
;
;	Check string specified in structure descriptor
;
10$:	movq	structure,r6		; Get descriptor of string
	cmpw	r6,#9			; Check if reasonable length
	bgtr	5$			; Error if not
;
;	Construct table of symbol table pointers for this structure,
;	sorted in ascending value order.
;
	bsbw	sort_offsets		; Construct offset table
	movq	offset_table,r6		; Get starting/ending table addresses
	cmpl	r6,r7			; Anything in table?
	bneq	50$			; Branch if table non-empty
	pushab	structure		; Address of structure name
	signal	1,nosymbols		; Signal no symbols found
	movl	#1,r0
	ret
;
;	Format the data structure
;
50$:	movl	@(r6),r8		; Pick up first offset
	bleq	60$			; Negative/zero okay
	clrl	r8			; If positive, start with zero
60$:	cmpl	r6,r7			; End of table yet?
	bgequ	90$			; Branch if so
	movl	(r6)+,r9		; Get address of symbol entry
	clrl	line_count		; No page ejects during display
	movab	sym$t_symbol(r9),r10	; Address of symbol to display
	addl3	#1,structure,r1		; Character index to data type
	movb	sym$t_symbol+1(r9)[r1],r1 ; Get data type character
	cmpl	sym$l_value(r9),r8	; Check against current offset
	blss	95$			; Process duplicate symbols
	bgtr	200$			; Process un-named data
	locc	r1,#typelen,typetab	; Index into type table
	case	r0,type=b,limit=#1,-	; Case on data type
		<100$,110$,120$,130$,140$,120$>
90$:	movl	#1,r0
	ret
;
;	Process duplicate symbol with the same offset
;
95$:	cmpb	r1,#^a/C/		; Is this a xxx$C_yyy symbol?
	bneq	100$			; No
	movl	r7,r6			; Yes, get the last one
	movl	(r6),r9			; Pick up its information
100$:	pushab	sym$t_symbol(r9)	; Address of symbol name
	print	1,<           !24AC>	; Print only symbol name
	brb	60$
;
;	Process un-named data
;
null:	.ascic	''			; Null string

200$:	subl	#4,r6			; Back up over skipped symbol
	movab	b^null,r10		; Leave blank for symbol
	subl3	r8,sym$l_value(r9),r4	; Length of unnamed bytes
	brb	201$
;
;	Process ASCIC text data
;
110$:	movab	buffer,r2		; Address of work buffer
	getmem	@tpa$l_number(ap)[r8],(r2),#32 ; Read ASCIC string
	blbc	r0,90$			; If cannot read, skip this
	cmpb	(r2),#32		; Check if reasonable length
	bgtru	115$			; If not, process as un-named
	pushab	1(r2)			; Address of ASCIC string
	movzbl	(r2),-(sp)		; Length of string
	pushab	sym$t_symbol(r9)	; Address of symbol name
	pushab	@tpa$l_number(ap)[r8]	; Address of data
	print	4,<!XL   !24AC"!AF">
	movzbl	(r2),r0			; Get length of string
	addl	r0,r8			; Add string length
	incl	r8			; plus one for length byte
115$:	brw	60$
;
;	Process longword data
;
120$:	movl	#4,r4			; Length to display
	brb	201$
;
;	Process word data
;
130$:	movl	#2,r4			; Length to display
	brb	201$
;
;	Process byte data
;
140$:	movl	#1,r4			; Length to display
;
;	Process any type of data
;
201$:	extzv	#0,#2,r8,r3		; Extract longword alignment
	subl3	r3,#4,r3		; Bytes to display
	movl	r3,r5			; Save for later
	cmpl	r3,r4			; More than enough?
	bleq	205$			; Branch if ok
	movl	r4,r3			; If so, only print that much
205$:	getmem	@tpa$l_number(ap)[r8]	; Read remaining bytes
	blbc	r0,230$			; Branch if cannot read
	movl	r3,r0			; Loop count
210$:	movzbl	r1,-(sp)		; Display the byte
	ashl	#-8,r1,r1		; Shift to next byte
	decl	r0			; Decrement byte count
	bgtr	210$			; Loop until done
	pushl	r3			; Number of bytes valid
	subl	r3,r5			; Amount truncated from left
	ashl	#1,r5,-(sp)		; 2 positions/byte
	pushl	r10			; Address of symbol name
	pushab	@tpa$l_number(ap)[r8]	; Address of data
	print	4,<!XL   !24AC!#* !#(XB)>
	ashl	#2,r3,r0		; Bytes still on stack
	addl	r0,sp			; Clean up stack
220$:	addl	r3,r8			; Skip data printed
	brw	60$
230$:	movl	#1,r0
	ret

	.dsabl	lsb

	.sbttl	sort_offsets, sort offsets for a given structure
;---
;
;	sort_offsets
;
;	This routine constructs a table of symbols for a given
;	structure, sorted by value.  The table is then used by
;	the FORMAT command to display the contents of a structure.
;
; Inputs:
;
;	r6/r7 = Descriptor of structure prefix string
;
; Outputs:
;
;	offset_table = Pointer to array of addresses into symbol table entries
;				sorted in numeric order.
;---
sort_offsets:
;
;	Allocate buffer to hold ordered offset table
;
	movaq	offset_table,r2		; Address of quadword
	movl	(r2),r8			; Address of previous table
	bneq	15$			; Branch if already exists
	pushl	#<256*4>*2		; Maximum of 256 offsets, 2 tables:
					; 256 pointers to sym entries
					; 256 symbol values, to optimize sorting
					; (minimizes page faults into symtable)
	calls	#1,allocate		; Allocate the storage
	movl	r1,r8			; Save address of table
	movl	r8,(r2)
	movl	r8,4(r2)		; Mark table empty
	brb	16$
;
;	If table already holds offset symbols for the desired
;	structure, skip searching the entire symbol table.
;
15$:	cmpl	r8,4(r2)		; Check if any entries
	bgequ	16$			; Skip if none
	movl	(r8),r1			; Get pointer to first symbol
	movzbl	sym$t_symbol(r1),r0	; Get length of first symbol
	cmpl	r0,r6			; Greater than prefix length?
	blequ	16$			; Skip compare if so
	cmpc3	r6,(r7),sym$t_symbol+1(r1) ; Same prefix?
	bneq	16$			; if not, create new structure
	rsb				; else just go use it

30$:	movl	r8,offset_table+4	; mark last valid table entry
	rsb				; exit with newly constructed table
;
;	Find the highest node in the alpha tree containing the required
;	prefix.  This is the parent of all other nodes with the prefix,
;	so then traverse the subtree rooted in this node.  Use a simple
;	insertion sort to get the symbols in increasing order of value.
;
16$:	movl	alpfl,r9			; get root of alpha table
	pushab	alp_traverse			; push prefix-scan routine
20$:	jsb	@(sp)+				; get next symbol
	blbc	r0, 30$				; J if end of tree reached
	movab	sym$t_symbol+1(r10)[r6], r3	; setup pointer to end of prefix
	movzbl	sym$t_symbol(r10),r2		; Get length of symbol
	subl	r6,r2				; Length left after prefix
	cmpl	r2,#4				; Must be at least 4 chars left
	blss	20$				; If not, no match
	cmpb	(r3)+,#^a'$'			; Must be followed by $
	beql	25$				; Branch if valid
	cmpb	-1(r3),#^a'_'			; Allow underscore as alternate
	bneq	20$				; Branch if not valid
25$:	movl	r3,r4				; Save pointer
	locc	(r3)+,#typelen,typetab		; Check if valid type
	beql	20$				; Branch if not a valid type
	cmpb	(r3)+,#^a'_'			; Must be followed by underscore
	bneq	20$				; Branch if not
;
;	We have a valid symbol.  Search up value table to find the right
;	place to insert, then shuffle up all the following entries in
;	both tables.
;
	movl	offset_table,r1		; get start of pointer array
	movab	256*4(r1),r2		; get start of value array
	movl	sym$l_value(r10),r3	; save symbol value
	cmpb	(r4),#^a/C/		; is it a xxx$C_yyy symbol?
	bneq	26$			; no, skip on
	bisl2	#^x70000000,r3		; make large number so end of table
26$:	cmpl	r1,r8			; reached end of table yet?
	bgequ	28$			; J if so
	cmpl	r3,(r2)+		; found right place yet?
	blss	27$			; J if so (signed branch for neg off)
	tstl	(r1)+			; else advance STRUC_TBL pointer too
	brb	26$			; and loop
27$:					; found place to insert!
	tstl	-(r2)			; back off VAL_TBL pointer
28$:	movl	(r2),r5			; save existing table entries
	movl	(r1),r4			; ...
	movl	r10,(r1)+		; save symbol entry pointer
	movl	r3,(r2)+		; and value
	movl	r5,r3			; get values to temp registers
	movl	r4,r10			; ...
	cmpl	r1,r8			; reached end of table yet?
	blequ	28$			; loop if not
	movl	r1,r8			; save new end pointer
	brb	20$

	.sbttl	translate_bits, translate bit mask to alpha string
;---
;
;	translate_bits
;
;	This routine translates a given bit mask into a string
;	of the names of each of the bits set in the mask, each
;	separated by delimiters.
;
; Inputs:
;
;	4(ap)	= address of bit definition table
;	8(ap)	= bit mask to translate
;	12(ap)	= descriptor of output buffer
;
;	The bit definition table is formatted as follows:
;
;	value1,address1
;	value2,address2
;	value3,address3
;	etc.
;	-1,-1
;
;	where "value" is the bit number and "address" is the
;	address of the counted ascii name string associated
;	with that bit.
;
; Outputs:
;
;	The output buffer contains the name string.
;	12(ap)	= descriptor of result string
;
; Calling sequence:
;
;	alloc	80,r2			; allocate output buffer
;	movzwl	ucb$w_sts(r3),-(sp)	; bit mask to translate
;	pushab	unit_status		; address of definition table
;	calls	#2,translate_bits	; translate bits into names
;
;	Notice that the output buffer descriptor is not included
;	in the argument count so that it stays on the stack after
;	the routine is finished.
;
;---

translate_bits::
	.word	^m<r2,r3,r4,r5,r6>

	clrl	r2			; starting bit number
	movq	4(ap),r3		; get table address & bit mask
	movq	12(ap),r5		; output buffer length,pointer
10$:
	bbc	r2,r4,50$		; skip if bit not set
	movl	r3,r0			; starting address of table
20$:
	cmpl	(r0)+,r2		; matches bit number?
	beql	30$			; branch if yes
	tstl	(r0)+			; end of table?
	bgeq	20$			; continue searching if not
	brb	50$			; if not found, ignore bit
30$:
	movl	(r0)+,r1		; address of name string
	movzbl	(r1)+,r0		; length of string
	subl	r0,r5			; decrement buffer space left
	blss	90$			; branch if not enough room
	cmpl	r6,16(ap)		; check if first name in string
	beql	35$			; branch if so
	decl	r5			; decrement buffer space left
	blss	90$			; branch if not enough room
	movb	#^a',',(r6)+		; insert comma in between names
35$:
	movb	(r1)+,(r6)+		; concatenate name to string
	sobgtr	r0,35$
50$:
	incl	r2			; next bit in mask
	cmpl	r2,#31			; are we done with longword?
	bleq	10$			; loop if not

90$:
	subl3	16(ap),r6,12(ap)	; length of result string
	status	success
	ret


	.END
