	.TITLE	DUMP	MEMORY DUMP ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	DUMP MEMORY ROUTINES
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V001	MTR0001		Mike Rhodes	22-Jun-1981
;		A.  Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;		B.  Change default addressing mode to longword.
;		C.  Remove references to $SDAMSGDEF macro.
;
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$DMPDEF			; DUMP FILE DEFINITIONS
	$VADEF			; VIRTUAL ADDRESS DEFINITIONS
	$PCBDEF			; PROCESS CONTROL BLOCK
	$PHDDEF			; PROCESS HEADER

	.SBTTL	STORAGE DEFINITIONS

;
;	STORAGE DEFINITIONS
;


	.PSECT	DUMP,EXE,NOWRT,LONG

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	SHOW_SYSTEM - DUMP SYSTEM REGION VIRTUAL MEMORY 
;---
;
;	SHOW_SYSTEM
;
;	DISPLAY THE SYSTEM REGION VIRTUAL ADDRESS SPACE
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_SYSTEM::
	.WORD	^M<R2>

	SUBHD	<System region memory>
	SKIP	PAGE
	PUSHL	#1			; ENABLE PAGING
	EXTV	#0,#31,MMG$FRSTRONLY,-(SP)   ; LENGTH OF DUMP
	ASHL	#VA$V_SYSTEM,#1,-(SP)	; STARTING ADDRESS
	CALLS	#3,DUMP		; DUMP UP TO READ-ONLY CODE
	SKIP	PAGE
	PUSHL	#1			; ENABLE PAGING
	GETMEM	@MMG$GL_SPTBASE,-(SP)	; GET ADDRESS OF SPT
	BLBC	R0,90$			; SKIP REST IF ERROR
	GETMEM	@EXE$GL_INTSTK		; ADDRESS OF INTERRUPT STACK
	BLBC	R0,90$			; SKIP REST IF ERROR
	SUBL	R1,(SP)			; LENGTH OF BALANCE SLOTS+SYSPHD
	PUSHL	R1			; ADDRESS OF BALANCE SLOTS
	CALLS	#3,DUMP		; DUMP DYNAMIC SYSTEM REGION
90$:
	STATUS	SUCCESS
	RET

	.SBTTL	SHOW_P0 -- SHOW P0 VIRTUAL MEMORY
;---
;
;	SHOW_P0
;
;	DISPLAY P0 VIRTUAL ADDRESS SPACE
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_P0::
	.WORD	^M<R2>

	SUBHD	<Process region memory>
	SKIP	PAGE
	PUSHL	#1			; ENABLE PAGING
;	MOVL	#<80@9>,R2		; MAXIMUM TO PRINT (80 PAGES)
	ASHL	#9,P0LR,-(SP)		; LENGTH OF PROCESS REGION
;	CMPL	(SP),R2			; CHECK IF OVER MAXIMUM
;	BLEQ	10$			; BRANCH IF OK
;	MOVL	R2,(SP)			; SET TO MAXIMUM
10$:
	PUSHL	#0			; STARTING ADDRESS
	CALLS	#3,DUMP			; DUMP PROCESS REGION
	RET

	.SBTTL	SHOW_P1 -- DISPLAY P1 VIRTUAL MEMORY
;---;
;
;	SHOW_P1
;
;	PRINT P1 VIRTUAL ADDRESS SPACE
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_P1::
	.WORD	^M<R2>

	SUBHD	<Control region memory>
	SKIP	PAGE
	PUSHL	#1			; ENABLE PAGING
	ADDL3	#12,CTL$AL_STACK,R1	; ADDRESS OF USPINI
	GETMEM	(R1)			; GET USPINI
	BLBC	R0,90$			; SKIP REST IF ERROR
;	MOVL	#<80@9>,R2		; MAXIMUM TO PRINT (80 PAGES)
	SUBL3	R1,#^X80000000,-(SP)	; LENGTH
;	CMPL	(SP),R2			; CHECK IF OVER MAXIMUM
;	BLEQ	10$			; BRANCH IF OK
;	MOVL	R2,(SP)			; SET TO MAXIMUM
10$:
	PUSHL	R1			; STARTING ADDRESS
	CALLS	#3,DUMP			; DUMP THE CONTROL REGION
90$:
	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.SBTTL	DUMP - DUMP SPECIFIED MEMORY AREA
;---
;
;	DUMP
;
;	THIS ROUTINE IS CALLED TO PRODUCE A READABLE DISPLAY
;	OF A SPECIFIED AREA OF MEMORY ON A PRINTER PAGE.  ZEROS
;	ARE SUPPRESSED AND A MESSAGE IS GIVEN INDICATING THE
;	EXTENT OF THE ZERO AREA.  THE MEMORY IS SHOWN IN BOTH
;	HEXIDECIMAL AND ASCII.
;
;   INPUTS:
;
;	4(AP) = STARTING ADDRESS OF THE BUFFER
;	8(AP) = LENGTH OF THE BUFFER (BYTES)
;	12(AP) = TRUE IF PAGING ENABLED, ELSE FALSE
;
;   OUTPUTS:
;
;	THE MEMORY IS DUMPED STARTING WITH THE FIRST MEMORY
;	LOCATION.  NO SPECIAL HEADERS ARE PRINTED.
;
;---

	.ENABL	LSB

DUMP::
	.WORD	^M<R2,R4,R5,R6>

	MOVL	#32,R6		; ASSUME 32 BYTES/LINE
	MOVL	#^X1F,R1	; 32 BYTE GRANULATION
	MOVAL	BUFFER,R2
	TSTL	OUTPUT_FILE	; OUTPUT LISTING SPECIFIED?
	BNEQ	5$		; BRANCH IF YES
	MOVL	#16,R6		; ONLY 16 BYTES/LINE FOR TERMINALS
	MOVL	#^XF,R1		; 16 BYTE GRANULATION
5$:
	CLRQ	R4		; SET CURRENT STATE TO NORMAL
;	BICL	R1,4(AP)	; BACKUP TO LAST 32 BYTE BOUNDARY
	ADDL	R1,8(AP)	; ROUND LIMIT TO NEXT 32 BYTES
	BICL	R1,8(AP)
	BGTR	10$		; BRANCH IF NON-ZERO
	RET
10$:
	TRYMEM	@4(AP),(R2),R6  ; GET NEXT N BYTES FROM DUMP
	BLBS	R0,20$		; BRANCH IF MEMORY OK
	MOVL	#1,R0
	BSBB	DUMP_STATE	; SET STATE = 1 (BYPASS INVALID MEMORY)
	BRB	60$		; AND SKIP THIS LOOP
20$:
	SKPC	#0,R6,(R2)	; CHECK IF NON-ZERO BUFFER
	BNEQ	30$		; BRANCH IF NON-ZERO
	MOVL	#2,R0
	BSBB	DUMP_STATE	; SET STATE = 2 (BYPASS ZEROS)
	BRB	60$		; AND SKIP THIS LOOP
30$:
	CLRL	R0
	BSBB	DUMP_STATE	; SET STATE TO NORMAL
	MOVL	4(AP),R1	; STARTING VIRTUAL ADDRESS
	BSBB	DUMP_LINE	; DUMP A SINGLE LINE
60$:
	ADDL2	R6,4(AP)	; INCREMENT CURRENT ADDRESS
	SUBL2	R6,8(AP)	; DECREMENT LENGTH
	BGTR	10$		; CONTINUE UNTIL DONE
	CLRL	R0
	BSBB	DUMP_STATE	; TERMINATE CURRENT STATE (IF ANY)
	MOVL	#1,R0		; SUCCESS
	RET

	.DSABL	LSB

	.PAGE
;---
;
;	SUBROUTINE TO PRINT A SINGLE LINE OF A MEMORY DUMP
;
;	R1 = STARTING VIRTUAL ADDRESS OF MEMORY
;	R2 = ADDRESS OF LOCAL COPY OF MEMORY
;	R6 = LENGTH TO DUMP (EITHER 16 OR 32 BYTES)
;	12(AP) = TRUE IF PAGING ENABLED, ELSE FALSE
;---
	.ENABL	LSB

DUMP_LINE:
	PUSHL	R1		; DUMP ADDRESS
	PUSHL	R2		; ADDRESS OF MEMORY
	PUSHL	R6		; LENGTH OF STRING
	MOVL	R2,R0
	ASHL	#-2,R6,R1	; REPEAT COUNT (# LONGWORDS)
40$:	PUSHL	(R0)+
	SOBGTR	R1,40$		; PUSH LONGWORDS
	BBS	#5,R6,50$	; BRANCH IF 32 BYTES/LINE
	PRINT	7,<!XL !XL !XL !XL  !AF     !XL>
	BRB	60$
50$:	PRINT	11,<!XL !XL !XL !XL !XL !XL !XL !XL  !AF     !XL>
60$:	BLBS	12(AP),90$	; BRANCH IF PAGING ENABLED
	CLRL	LINE_COUNT	; ELSE INHIBIT PAGE EJECTS
90$:	RSB

	.DSABL	LSB

	.PAGE
;---
;
;   SUBROUTINE TO SET STATE OF DUMPING PROCESS
;
;	R0 = STATE NUMBER TO ENTER (IF NOT ALREADY THERE)
;		0 = NORMAL MEMORY
;		1 = BYPASS INVALID MEMORY
;		2 = ZERO MEMORY
;	R4 = CURRENT STATE
;	R5 = NUMBER OF BYTES BYPASSED IN CURRENT STATE
;	R6 = BYTES DISPLAYED PER LINE
;---

	.ENABL	LSB

DUMP_STATE:
	CMPL	R0,R4		; CHECK IF ALREADY IN STATE
	BNEQ	10$		; BRANCH IF NOT
	ADDL2	R6,R5		; INCREMENT BYPASS COUNTER
	RSB
10$:
	PUSHL	R0		; SAVE NEW STATE
	CMPL	R4,#1		; CHECK IF BYPASSING INVALID MEMORY
	BNEQ	20$		; BRANCH IF NOT
	SKIP	1
	SUBL3	#1,4(AP),-(SP)	; ENDING ADDRESS
	SUBL3	R5,4(AP),-(SP)	; STARTING ADDRESS
	PRINT	2,<Virtual locations !XL through !XL are not in physical memory>
	SKIP	1
	BRB	80$
20$:
	CMPL	R4,#2		; CHECK IF BYPASSING ZEROS
	BNEQ	80$		; BRANCH IF NOT
	CMPL	R5,#48		; ONLY SHOW IF MORE THAN 48 BYTES
	BLEQ	25$		; BRANCH IF LESS (NOT WORTH MESSAGE)
	SKIP	1
	SUBL3	#1,4(AP),-(SP)	; ENDING ADDRESS
	SUBL3	R5,4(AP),-(SP)	; STARTING ADDRESS
	PRINT	2,<Zeros suppressed from !XL through !XL>
	SKIP	1
	BRB	80$
25$:
	PUSHL	R2		; SAVE ORIGINAL BUFFER ADDRESS
	SUBL	R6,SP		; ALLOCATE BUFFER
	MOVL	SP,R2		; SET ADDRESS OF BUFFER
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC5	#0,(SP),#0,R6,(R2)	; ZERO THE BUFFER
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
28$:	SUBL3	R5,4(AP),R1	; STARTING VIRTUAL ADDRESS
	BSBW	DUMP_LINE	; DUMP A SINGLE LINE OF ZEROS
	SUBL	R6,R5		; DECREMENT AMOUNT LEFT TO DO
	BGTR	28$		; CONTINUE UNTIL DONE
	ADDL	R6,SP		; DEALLOCATE BUFFER
	POPL	R2		; RESTORE BUFFER ADDRESS
80$:
	POPL	R4		; SET NEW STATE
	MOVL	R6,R5		; INITIALIZE BYPASS COUNTER
	RSB

	.DSABL	LSB


	.END
