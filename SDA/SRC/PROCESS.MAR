	.TITLE	PROCESS	PROCESS FORMATTING ROUTINES
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	ROUTINES TO FORMAT PROCESS INFORMATION
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V008	TMH0008		Tim Halvorsen		06-Feb-1982
;		Zero JIB block in local memory if we are unable to read
;		it, or if it does not exist.
;
;	V02-007	KTA0034		Kerbey T. Altmann	04-Sep-1981
;		Shuffle parameters in call to DUMP_PTE to agree with
;		calling sequence.
;
;	V006	KEK0004		K. E. Kinnear	16-July-1981
;		Add SHOW PROCESS/RMS command.
;
;	V005	MTR0001		Mike Rhodes	22-Jun-1981
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;		Change default addressing mode to longword.
;		Remove references to $SDAMSGDEF macro.
;
;	V004	TMH0004		Tim Halvorsen	07-Feb-1981
;		Change word displacements to longword displacements
;
;	V003	TMH0010		Tim Halvorsen	30-Sep-1980
;		Do not use $EQULST to obtain process state strings
;		since MDL no longer produces references to that macro.
;
;	V002	TMH0009		Tim Halvorsen	25-Aug-1980
;		Remove references to SEC$S_xxx for single bit fields.
;
;	V001	TMH0006		Tim Halvorsen	05-May-1980
;		Fix working set display: WSLE is blown after any empty
;		entry, first unlocked entry should read first locked one.
;		Fix bug in show_pst which wiped out the lib$get_vm free
;		list and eventually caused an access violation.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$PCBDEF			; PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF			; PROCESS HEADER DEFINITIONS
	$WSLDEF			; WORKING SET LIST DEFINITIONS
	$SECDEF			; SECTION TABLE DEFINITIONS
	$IFDDEF			; IMAGE FILE DESCRIPTOR DEFINITIONS
	$JIBDEF			; JOB INFORMATION BLOCK DEFINITIONS
	$OPTDEF			; OPTION DEFINITIONS

;
;	LOCAL MACRO DEFINITIONS
;

	.MACRO	CSTABLE,LEN
	CSL =	LEN
	.ENDM


	.MACRO	CS,TEXT
	SAV = .
	.ASCIC	\TEXT\
	. = SAV + CSL
	.ENDM

	.SBTTL	STORAGE DEFINITIONS
;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

	.default displacement,long

PCBADR::
	.BLKL	1			; ADDRESS OF PCB

PCB::
	.BLKB	PCB$C_LENGTH		; BUFFER TO HOLD PCB

PHDADR::
	.BLKL	1			; ADDRESS OF PHD

PHD::
	.BLKB	PHD$C_LENGTH		; BUFFER TO HOLD PHD

JIBADR::	
	.BLKL	1			; ADDRESS OF JIB
JIB::
	.BLKB	JIB$C_LENGTH		; BUFFER TO HOLD JIB

	.PSECT	PROCESS,EXE,NOWRT

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

NOTAVAIL:
	.ASCIC	'-- IMAGE NAME NOT AVAILABLE --'

	.MACRO	$DEFINI NAME,P1,P2
	.ENDM
	.MACRO	$DEFEND NAME,P1,P2
	.ENDM
	.MACRO	$EQU SYMBOL,VALUE
S = %LOCATE(<_>,SYMBOL)+1
L = %LENGTH(SYMBOL)-S
	.ASCIC	/%EXTRACT(S,L,SYMBOL)/
	.BLKB	8-<L+1>
	.ENDM	$EQU

STATE_TABLE:
	.ASCIC	'ILLEGAL'		; FOR ZERO CASE
	$STATEDEF			; TABLE OF PROCESS STATE NAMES

	.MDELETE	$DEFINI,$DEFEND,$EQU

PROCESS_STATUS:
	TABLE	PCB$V_,<RES,DELPEN,FORCPEN,INQUAN,PSWAPM,RESPEN,SSFEXC,-
		SSFEXCE,SSFEXCS,SSFEXCU,SSRWAIT,SUSPEN,WAKEPEN,WALL,-
		BATCH,NOACNT,SWPVBN,ASTPEN,PHDRES,HIBER,LOGIN,NETWRK,-
		PWRAST,NODELET>


GBL_TABLE:
	.ASCIC	''
	.ASCIC	'GBL '
CRF_TABLE:
	.ASCIC	''
	.ASCIC	'CRF '
DZRO_TABLE:
	.ASCIC	''
	.ASCIC	'DZERO '
WRT_TABLE:
	.ASCIC	''
	.ASCIC	'WRT '

VALID_TABLE:
	.ASCIC	''
	.ASCIC	' VALID'
PAGTYP_TABLE:
	.ASCIC	'PROCESS'
	.ASCIC	'SYSTEM '
	.ASCIC	'GLOBAL '
	.ASCIC	'GBLWRT '
	.ASCIC	'PPGTBL '
	.ASCIC	'GPGTBL '
	.ASCIC	'       '
	.ASCIC	'       '
MODIFY_TABLE:
	.ASCIC	''
	.ASCIC	' MODIFIED'
WSLOCK_TABLE:
	.ASCIC	''
	.ASCIC	' WSLOCK'
PFNLOCK_TABLE:
	.ASCIC	''
	.ASCIC	' PFNLOCK'
GOODPAGE_TABLE:
	.ASCIC	''
	.ASCIC	' GOODPAGE'

AST_TABLE:
	CSTABLE	8
	CS	NONE
	CS	K
	CS	E
	CS	KE
	CS	S
	CS	KS
	CS	ES
	CS	KES
	CS	U
	CS	KU
	CS	EU
	CS	KEU
	CS	SU
	CS	KSU
	CS	ESU
	CS	KESU

HDRSTR1:
	STRING	<Process !XB dump: !AC>

	.SBTTL	DISPLAY_PROCS -- DISPLAY PROCESS DATA
;---
;
;	DISPLAY_PROCS
;
;	SHOWS INFORMATION ABOUT EACH PROCESS IN THE SYSTEM.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

DISPLAY_PROCS::
	.WORD	^M<R2,R3,R4>

	REQMEM	@SCH$GL_PCBVEC,R2	; VECTOR OF PCB ADDRESSES
	REQMEM	@SCH$GL_MAXPIX,R3	; GET MAXIMUM PROCESS INDEX

	CLRL	R4			; INITIALIZE CURRENT INDEX
10$:
	MOVAL	(R2)[R4],R1		; ADDRESS OF POINTER TO PCB
	REQMEM	(R1),PCBADR		; GET ADDRESS OF PCB
	REQMEM	@PCBADR,PCB,#PCB$C_LENGTH	; GET PCB
	TSTW	PCB+PCB$L_PID		; CHECK IF PROCESS INDEX = 0
	BNEQ	20$			; BRANCH IF NOT
	TSTL	R4			; CHECK IF NULL PROCESS SLOT
	BNEQ	90$			; SKIP IF NOT
20$:
	TSTL	PCB+PCB$L_PHD		; SWAPPED OUT?
	BEQL	30$			; BRANCH IF SO
	REQMEM	@PCB+PCB$L_PHD,PHD,#PHD$C_LENGTH ; READ PHD
	MOVAL	P0BR,R0			; 4 LONGWORDS
	MOVAB	PHD,R1
	MOVQ	PHD$L_P0BR(R1),(R0)	; SETUP RELOCATION REGISTERS
	MOVQ	PHD$L_P1BR(R1),8(R0)
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,4(R0),4(R0)
30$:	MOVL	PCB+PCB$L_PID,PROC_PID	; SET PID OF PROCESS TO READ
	CALLS	#0,B^DISPLAY_PROCESS	; DISPLAY PROCESS INFORMATION
90$:
	AOBLEQ	R3,R4,100$		; CONTINUE UNTIL DONE
	BRB	110$
100$:	BRW	10$
110$:	STATUS	SUCCESS
	RET

	.SBTTL	DISPLAY_PROCESS -- DISPLAY PROCESS INFORMATION
;---
;
;	DISPLAY_PROCESS
;
;	THIS ROUTINE FORMATS ALL INFORMATION ABOUT A SINGLE
;	PROCESS GIVEN THE PROCESS CONTROL BLOCK.
;
;   INPUTS:
;
;	PCB = PROCESS CONTROL BLOCK FOR PROCESS
;
;   OUTPUTS:
;
;	NONE
;
;---

DISPLAY_PROCESS::
	.WORD	^M<R2,R3,R4,R5>
	MOVC5	#0,(SP),#0,#JIB$C_LENGTH,JIB	; PRE-ZERO JIB IN CASE NOT THERE
	MOVL	PCB+PCB$L_JIB,JIBADR	; CHECK FOR JIB
	BEQL	5$			; BR IF NONE
	REQMEM	@JIBADR,JIB,#JIB$C_LENGTH	; GET JIB
5$:
	MOVAL	PCB,R2
	MOVAL	PHD,R3
	ALLOC	50,R4			; 50 BYTE BUFFER FOR HEADER
	PUSHAB	PCB$T_LNAME(R2)		; PROCESS NAME
	PUSHL	PCB$L_PID(R2)		; PROCESS INDEX
	PUSHL	R4
	PUSHL	R4
	PUSHAB	HDRSTR1			; FAO CONTROL STRING
	CALLS	#5,G^SYS$FAO		; FORMAT TITLE STRING
	PUSHL	R4
	CALLS	#1,SET_HEADING		; SET NEW HEADING
	SKIP	PAGE

	MOVL	OPTIONS,R4
	BITL	#^C<OPT$M_SYSPROC>,R4	; CHECK IF ANY OPTION SPECIFIED
	BEQL	10$			; DEFAULT IS PCB
	BBC	#OPT$V_PCB,R4,20$	; CHECK IF /PCB SPECIFIED
10$:
	CALLS	#0,SHOW_PCB		; SHOW SOME PCB FIELDS
20$:
	BITL	#<OPT$M_PHD! -		; IF ANY OF THESE OPTIONS CHOSEN
		OPT$M_REGS! -
		OPT$M_WSL! -
		OPT$M_PST! -
		OPT$M_PPT>,R4
	BEQL	70$			; SKIP READING PHD IF NONE
	TSTL	PCB$L_PHD(R2)		; PROCESS RESIDENT?
	BEQL	80$			; BRANCH IF NOT
	REQMEM	@PCB$L_PHD(R2),(R3),#PHD$C_LENGTH  ; READ PROCESS HEADER

	BBC	#OPT$V_PHD,R4,30$	; CHECK IF /PHD SPECIFIED
	CALLS	#0,SHOW_PHD		; SHOW PROCESS HEADER
30$:	BBC	#OPT$V_REGS,R4,40$	; CHECK IF /REGS SPECIFIED
	CALLS	#0,SHOW_REGS		; SHOW SAVED REGISTERS
40$:	BBC	#OPT$V_WSL,R4,50$	; CHECK IF /WSL SPECIFIED
	CALLS	#0,SHOW_WSL		; SHOW WORKING SET LIST
50$:	BBC	#OPT$V_PST,R4,60$	; CHECK IF /PST SPECIFIED
	CALLS	#0,SHOW_PST		; SHOW PROCESS SECTION TABLE
60$:	BBC	#OPT$V_PPT,R4,70$	; CHECK IF /PPT SPECIFIED
	CALLS	#0,SHOW_PPT		; SHOW PROCESS PAGE TABLES
70$:	BBC	#OPT$V_RMS,R4,75$	; CHECK IF /RMS SPECIFIED
	BBS	#OPT$V_RMSD,R4,71$	; CHECK IF /RMS=... SPECIFIED
	CALLS	#0,SHOW_RMS		; SHOW CURRENTLY SELECTED RMS STRUCTS
	BRB	75$			; EXIT
71$:	CALLS	#0,SHOW_RMS_DIS		; SHOW RMS STURCTS SPECIFIED ON 
					;  THIS COMMAND
75$:	STATUS	SUCCESS
	RET

80$:	SIGNAL	0,NOTRES		; PROCESS NOT RESIDENT
	BRB	70$			; MUST RETURN SUCCESS TO TPARSE

	.SBTTL	SHOW_PCB -- SHOW PROCESS CONTROL BLOCK
;---
;
;	SHOW_PCB
;
;	THIS ROUTINE FORMATS SOME INTERESTING FIELDS IN THE
;	PROCESS CONTROL BLOCK FOR EASY READING.
;
;   INPUTS:
;
;	PCB = CURRENT PROCESS CONTROL BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_PCB:
	.WORD	^M<R2>

	MOVAL	PCB,R2
	ENSURE	12
	ALLOC	80			; 80 BYTE OUTPUT BUFFER
	PUSHL	PCB$L_STS(R2)		; PROCESS STATUS
	PUSHAB	PROCESS_STATUS		; BIT DEFINITION TABLE	
	CALLS	#2,TRANSLATE_BITS	; TRANSLATE BITS INTO NAMES
	PUSHL	SP			; ADDRESS OF RESULT DESCRIPTOR
	PUSHL	PCB$L_STS(R2)
	PRINT	2,<Process status:  !XL   !AS>
	SKIP	1
	PUSHL	JIBADR			; ADDRESS OF JIB
	PUSHL	PCBADR			; ADDRESS OF PCB
	PRINT	2,<-
PCB address              !XL    -
JIB address              !XL>
	PUSHL	PCB$L_OWNER(R2)		; CREATOR PID
	PUSHL	JIB+JIB$L_MPID		; MASTER PID
	PRINT	2,<-
Master PID               !XL    -
Creator PID              !XL>
	PUSHL	JIB+JIB$W_PRCCNT
	PUSHL	PCB$L_PID(R2)
	PRINT	2,<-
PID                      !XL    -
Subprocess count         !8UW>
	PUSHL	PCB$L_WSSWP(R2)
	PUSHL	PCB$L_PHD(R2)
	PRINT	2,<-
PHD address              !XL    -
Swapfile disk address    !XL>
	PUSHL	PCB$W_TMBU(R2)
	MOVZWL	PCB$W_STATE(R2),R1
	PUSHAQ	STATE_TABLE[R1]
	PRINT	2,<-
State                       !5AC    -
Termination mailbox          !XW>
	MOVZBL	PCB$B_ASTEN(R2),R1
	PUSHAQ	AST_TABLE[R1]
	MOVZBL	PCB$B_PRI(R2),-(SP)
	SUBL3	(SP),#31,(SP)
	PRINT	2,<-
Current priority         !8UB    -
AST's enabled                !4AC>
	MOVZBL	PCB$B_ASTACT(R2),R1
	PUSHAQ	AST_TABLE[R1]
	MOVZBL	PCB$B_PRIB(R2),-(SP)
	SUBL3	(SP),#31,(SP)
	PRINT	2,<-
Base priority            !8UB    -
AST's active                 !4AC>
	PUSHL	PCB$W_ASTCNT(R2)
	PUSHL	PCB$W_MEM(R2)
	PUSHL	PCB$W_GRP(R2)
	PRINT	3,<-
UIC                     [!3OW,!3OW]    -
AST's remaining          !8UW>
	PUSHL	PCB$W_BIOLM(R2)		; BUFFERED I/O LIMIT
	PUSHL	PCB$W_BIOCNT(R2)	; BUFFERED I/O COUNT
	PUSHL	PCB$W_MTXCNT(R2)	; MUTEX COUNT
	PRINT	3,<-
Mutex count              !8UW    -
Buffered I/O count/limit   !6UW/!UW>
	PUSHL	PCB$W_DIOLM(R2)
	PUSHL	PCB$W_DIOCNT(R2)
	PUSHL	PCB$B_WEFC(R2)
	PRINT	3,<-
Waiting EF cluster       !8UB    -
Direct I/O count/limit     !6UW/!UW>
	PUSHL	JIB+JIB$L_BYTLM
	PUSHL	JIB+JIB$L_BYTCNT
	PUSHL	PCB$L_WTIME(R2)
	PRINT	3,<-
Starting wait time       !XL    -
BUFIO byte count/limit     !6UW/!UW>
	PUSHL	JIB+JIB$W_FILCNT
	PUSHL	PCB$L_EFWM(R2)
	PRINT	2,<-
Event flag wait mask     !XL    -
# open files allowed left  !6UW>
	PUSHL	JIB+JIB$W_TQCNT
	PUSHL	PCB$L_EFCS(R2)
	PRINT	2,<-
Local EF cluster 0       !XL    -
Timer entries allowed left !6UW>
	PUSHL	PCB$W_APTCNT(R2)
	PUSHL	PCB$L_EFCU(R2)
	PRINT	2,<-
Local EF cluster 1       !XL    -
Active page table count    !6UW>
	PUSHL	PCB$W_PPGCNT(R2)
	PUSHL	PCB$L_EFC2P(R2)
	PRINT	2,<-
Global cluster 2 pointer !XL    -
Process WS page count      !6UW>
	PUSHL	PCB$W_GPGCNT(R2)
	PUSHL	PCB$L_EFC3P(R2)
	PRINT	2,<-
Global cluster 3 pointer !XL    -
Global WS page count       !6UW>

	RET

	.SBTTL	SHOW_PHD -- SHOW PROCESS HEADER
;---
;
;	SHOW_PHD
;
;	FORMAT THE FIELDS FROM THE PROCESS HEADER.
;
;   INPUTS:
;
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_PHD:
	.WORD	^M<R2>

	MOVAL	PHD,R2			; ADDRESS OF PROCESS HEADER
	SKIP	2
	ENSURE	12
	PRINT	0,<Process header>
	PRINT	0,<-------------->
	SKIP	1
	PUSHL	PHD$L_CPUTIM(R2)
	PUSHL	PHD$L_FREP0VA(R2)
	PRINT	2,<-
First free P0 address      !8XL!4* -
Accumulated CPU time       !8XL>
	PUSHL	PHD$W_QUANT(R2)
	PUSHL	PHD$L_FREPTECNT(R2)
	PRINT	2,<-
Free PTEs between P0/P1    !8UL!4* -
CPU since last quantum     !8XW>
	PUSHL	JIB+JIB$W_PRCLIM
	PUSHL	PHD$L_FREP1VA(R2)
	PRINT	2,<-
First free P1 address      !8XL!4* -
Subprocess quota           !8UW>
	PUSHL	PHD$W_ASTLM(R2)
	PUSHL	JIB+JIB$L_PGFLCNT
	PRINT	2,<-
Free page file pages       !8UL!4* -
AST limit                  !8UW>
	PUSHL	PHD$W_PHVINDEX(R2)
	PUSHL	PHD$B_DFPFC(R2)
	PRINT	2,<-
Page fault cluster size    !8UB!4* -
Process header index       !8XW>
	PUSHL	PHD$W_BAK(R2)
	PUSHL	PHD$B_PGTBPFC(R2)
	PRINT	2,<-
Page table cluster size    !8UB!4* -
Backup address vector      !8XW>
	PUSHL	PHD$W_WSLX(R2)
	PUSHL	PHD$W_FLAGS(R2)
	PRINT	2,<-
Flags                      !8XW!4* -
WSL index save area        !8XW>
	PUSHL	PHD$W_PTCNTLCK(R2)
	PUSHL	PHD$L_DIOCNT(R2)
	PRINT	2,<-
Direct I/O count           !8UL!4* -
PTs having locked WSLs     !8UW>
	PUSHL	PHD$W_PTCNTVAL(R2)
	PUSHL	PHD$L_BIOCNT(R2)
	PRINT	2,<-
Buffered I/O count         !8UL!4* -
PTs having valid WSLs      !8UW>
	PUSHL	PHD$W_PTCNTACT(R2)
	PUSHL	PHD$L_CPULIM(R2)
	PRINT	2,<-
Limit on CPU time          !8XL!4* -
Active page tables         !8UW>
	PUSHL	PHD$W_PTCNTMAX(R2)
	PUSHL	JIB+JIB$L_PGFLQUOTA
	PRINT	2,<-
Maximum page file count    !8UL!4* -
Maximum active PTs         !8UW>
	PUSHL	PHD$W_WSFLUID(R2)
	PUSHL	PHD$L_PAGEFLTS(R2)
	PRINT	2,<-
Total page faults          !8UL!4* -
Guaranteed fluid WS pages  !8UW>
	PUSHL	PHD$W_EXTDYNWS(R2)
	PUSHL	JIB+JIB$W_FILLM
	PRINT	2,<-
File limit                 !8UW!4* -
Extra dynamic WS entries   !8UW>
	PUSHL	PHD$L_PTWSLELCK(R2)
	PUSHL	JIB+JIB$W_TQLM
	PRINT	2,<-
Timer queue limit          !8UW!4* -
Locked WSLE counts array   !8XW>
	PUSHL	PHD$L_PTWSLEVAL(R2)
	PUSHL	PHD$L_PAGFIL(R2)
	PRINT	2,<-
Paging file index          !8XL!4* -
Valid WSLE counts array    !8XW>

	RET

	.SBTTL	SHOW_REGS -- SHOW SAVED PROCESS REGISTERS
;---
;
;	SHOW_REGS
;
;	DISPLAY THE SAVED PROCESS REGISTERS
;
;   INPUTS:
;
;	PHD = CURRENT PROCESS HEADER
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_REGS:
	.WORD	^M<R2>

	SKIP	2
	ENSURE	7
	PRINT	0,<Saved process registers>
	PRINT	0,<----------------------->
	SKIP	1
	MOVAL	PHD,R2			; ADDRESS OF PROCESS HEADER
	PUSHL	PHD$L_R3(R2)
	PUSHL	PHD$L_R2(R2)
	PUSHL	PHD$L_R1(R2)
	PUSHL	PHD$L_R0(R2)
	PRINT	4,<R0   = !XL    R1   = !XL    R2   = !XL    R3   = !XL>
	PUSHL	PHD$L_R7(R2)
	PUSHL	PHD$L_R6(R2)
	PUSHL	PHD$L_R5(R2)
	PUSHL	PHD$L_R4(R2)
	PRINT	4,<R4   = !XL    R5   = !XL    R6   = !XL    R7   = !XL>
	PUSHL	PHD$L_R11(R2)
	PUSHL	PHD$L_R10(R2)
	PUSHL	PHD$L_R9(R2)
	PUSHL	PHD$L_R8(R2)
	PRINT	4,<R8   = !XL    R9   = !XL    R10  = !XL    R11  = !XL>
	PUSHL	PHD$L_PSL(R2)
	PUSHL	PHD$L_PC(R2)
	PUSHL	PHD$L_R13(R2)
	PUSHL	PHD$L_R12(R2)
	PRINT	4,<AP   = !XL    FP   = !XL    PC   = !XL    PSL  = !XL>
	PUSHL	PHD$L_USP(R2)
	PUSHL	PHD$L_SSP(R2)
	PUSHL	PHD$L_ESP(R2)
	PUSHL	PHD$L_KSP(R2)
	PRINT	4,<KSP  = !XL    ESP  = !XL    SSP  = !XL    USP  = !XL>
	PUSHL	PHD$L_P1LR(R2)
	PUSHL	PHD$L_P1BR(R2)
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,PHD$L_P0LRASTL(R2),-(SP)
	PUSHL	PHD$L_P0BR(R2)
	PRINT	4,<P0BR = !XL    P0LR = !XL    P1BR = !XL    P1LR = !XL>

	RET

	.SBTTL	SHOW_WSL -- SHOW WORKING SET LIST
;---
;
;	SHOW_WSL
;
;	THIS ROUTINE FORMATS INFORMATION ABOUT THE PROCESSES
;	WORKING SET LIST FROM THE PROCESS HEADER.
;
;   INPUTS:
;
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_WSL:
	.WORD	^M<R2,R3,R4,R5,R6>

	SKIP	2
	ENSURE	8
	PRINT	0,<Working set information>
	PRINT	0,<----------------------->
	SKIP	1
	MOVAL	PHD,R2
	MOVZWL	PHD$W_WSLIST(R2),R3	; BIAS TO WORKING SET LIST
	DECL	R3			; ADJUST BIAS
	SUBL3	R3,PHD$W_WSAUTH(R2),-(SP) ; CURRENT AUTHORIZED SIZE
	PUSHL	PHD$W_WSLIST(R2)	; 1ST WSL ENTRY
	PRINT	1,<First WSL entry          !XW        Current authorized working set size   !UW>
	SUBL3	R3,PHD$W_DFWSCNT(R2),-(SP) ; DEFAULT WORKING SET SIZE
	PUSHL	PHD$W_WSLOCK(R2)	; 1ST LOCKED WSL ENTRY
	PRINT	1,<First locked entry       !XW        Default (initial) working set size    !UW>
	SUBL3	R3,PHD$W_WSQUOTA(R2),-(SP) ; MAXIMUM WORKING SET ALLOWED
	PUSHL	PHD$W_WSDYN(R2)		; 1ST DYNAMIC ENTRY
	PRINT	1,<First dynamic entry      !XW        Maximum working set allowed (quota)   !UW>
	PUSHL	PHD$W_WSNEXT(R2)	; LAST ENTRY REPLACED
	PRINT	1,<Last entry replaced      !XW>
	PUSHL	PHD$W_WSLAST(R2)	; LAST ENTRY IN LIST
	PRINT	1,<Last entry in list       !XW>
	TSTW	PHD$W_WSLIST(R2)	; CHECK IF REASONABLE
	BGTR	5$			; BRANCH IF OK
	RET
5$:
	SKIP	2
	ENSURE	8
	PRINT	0,<Working set list>
	PRINT	0,<---------------->
	CVTWL	PHD$W_WSLAST(R2),R6	; LONGWORD OFFSET TO LAST ENTRY
	INCL	R6			; LONGWORDS IN PHD+WSL
	ASHL	#2,R6,R6		; R6 = LENGTH IN BYTES
	PUSHL	R6			; LENGTH TO ALLOCATE
	CALLS	#1,ALLOCATE		; ALLOCATE SPACE FOR PHD+WSL
	MOVL	R1,R2			; ADDRESS OF PHD/WSL BUFFER
	GETMEM	@PCB+PCB$L_PHD,(R2),R6	; GET ENTIRE WORKING SET LIST
	BLBC	R0,90$			; SKIP IF CANNOT BE READ

	CALLS	#0,WSL_TITLE		; PRINT THE HEADING LINES
	MOVAB	WSL_TITLE,HEADING_ROUTINE ; SET HEADING ROUTINE
	MOVZWL	PHD$W_WSLIST(R2),R3	; STARTING INDEX OF LIST
	MOVZWL	PHD$W_WSLAST(R2),R4	; LAST ENTRY TO DUMP
	DECL	R3			; ADJUST FOR FIRST ITERATION
	CLRL	R5			; EMPTY WSLE COUNT
10$:
	INCL	R3			; INCREMENT INDEX
	CMPL	R3,R4			; CHECK IF DONE
	BLEQ	20$			; BRANCH IF OK
90$:
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	PUSHL	R6			; LENGTH OF BUFFER
	PUSHL	R2			; ADDRESS OF PHD+WSL BUFFER
	CALLS	#2,DEALLOCATE		; DEALLOCATE BUFFER
	RET
20$:
	MOVL	(R2)[R3],R0		; GET ENTRY
	BBS	#WSL$V_VALID,R0,30$	; BRANCH IF VALID
	INCL	R5			; INCREMENT EMPTY ENTRIES
	BRB	10$
30$:
	TSTL	R5			; CHECK IF EMPTY ENTRIES
	BEQL	40$			; BRANCH IF NOT
	PUSHL	R0			; SAVE PENDING WSLE
	PUSHL	R5
	SKIP	1
	PRINT	1,<!_ ----  !UL empty entries>
	SKIP	1
	CLRL	R5			; RESET EMPTY WSLE COUNT
	POPL	R0			; RESTORE PENDING WSLE TO SHOW
40$:
	EXTZV	#WSL$V_GOODPAGE,#1,R0,R1
	PUSHAB	GOODPAGE_TABLE[R1]
	EXTZV	#WSL$V_PFNLOCK,#1,R0,R1
	PUSHAB	PFNLOCK_TABLE[R1]
	EXTZV	#WSL$V_WSLOCK,#1,R0,R1
	PUSHAB	WSLOCK_TABLE[R1]
	EXTZV	#WSL$V_MODIFY,#1,R0,R1
	PUSHAB	MODIFY_TABLE[R1]
	EXTZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R0,R1
	PUSHAQ	PAGTYP_TABLE[R1]
	EXTZV	#WSL$V_VALID,#1,R0,R1
	PUSHAB	VALID_TABLE[R1]
	BICL3	#^X1FF,R0,-(SP)		; VIRTUAL ADDRESS
	PUSHL	R3			; INDEX
	PRINT	8,<!_ !XW  !XL    !AC !5(AC)>
	BRW	10$

	.DSABL	LSB

;
;	THIS ROUTINE PRINTS THE HEADING LINES FOR EACH PAGE
;	OF THE WORKING SET LIST DISPLAY.
;
WSL_TITLE:
	.WORD	0

	SKIP	1
	PRINT	0,<!_INDEX   ADDRESS    STATUS>
	SKIP	1
	RET

	.SBTTL	SHOW_PST -- SHOW PROCESS SECTION TABLE
;---
;
;	SHOW_PST
;
;	DISPLAY THE PROCESS SECTION TABLE
;
;   INPUTS:
;
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

SHOW_PST:
	.WORD	^M<R2,R3,R4,R5,R6,R7>

	SKIP	2
	ENSURE	5
	PRINT	0,<Process section table information>
	PRINT	0,<--------------------------------->
	SKIP	1
	MOVAL	PHD,R2
	PUSHL	PHD$W_PSTLAST(R2)	; LAST PST ENTRY ALLOCATED
	PRINT	1,<!_Last entry allocated     !XW>
	PUSHL	PHD$W_PSTFREE(R2)
	PRINT	1,<!_First free PST entry     !XW>
	TSTW	PHD$W_PSTLAST(R2)	; CHECK IF REASONABLE
	BLSS	5$			; BRANCH IF OK
	RET
5$:
	SKIP	2
	ENSURE	8
	PRINT	0,<Process section table>
	PRINT	0,<--------------------->
	CALLS	#0,PST_TITLE		; PRINT TITLE LINE
	MOVAB	PST_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE
	CVTWL	PHD$W_PSTLAST(R2),R0	; LAST ENTRY ALLOCATED
	ADDL3	PCB+PCB$L_PHD,PHD$L_PSTBASOFF(R2),R7  ; BASE ADDRESS
	MOVAL	(R7)[R0],R4		; ADDRESS OF LOWEST ENTRY
	SUBL2	R4,R7			; LENGTH OF PST IN USE
	PUSHL	R7			; LENGTH TO ALLOCATE
	CALLS	#1,ALLOCATE		; ALLOCATE PST BUFFER
	MOVL	R1,R6			; SAVE ADDRESS OF PST BUFFER
	GETMEM	(R4),(R6),R7		; GET USED PART OF PST
	RETIFERR			; SKIP IF ERROR READING

	MOVL	R7,R3			; SET LENGTH OF PST TO SCAN
	MOVAB	(R6)[R7],R4		; FIRST ENTRY + 1
	CLRL	R5			; INITIALIZE PST INDEX
10$:
	SUBL2	#SEC$C_LENGTH,R4	; DECREMENT ADDRESS
	SUBL2	#SEC$C_LENGTH/4,R5	; DECREMENT INDEX
	SUBL2	#SEC$C_LENGTH,R3	; DECREMENT BUFFER LENGTH
	BGEQ	20$			; BRANCH IF OK
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	PUSHL	R7			; LENGTH TO DEALLOCATE
	PUSHL	R6			; ADDRESS OF PST BUFFER
	CALLS	#2,DEALLOCATE		; DEALLOCATE PST BUFFER
	STATUS	SUCCESS
	RET
20$:
	EXTZV	#SEC$V_GBL,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	GBL_TABLE[R1]
	EXTZV	#SEC$V_CRF,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	CRF_TABLE[R1]
	EXTZV	#SEC$V_DZRO,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	DZRO_TABLE[R1]
	EXTZV	#SEC$V_WRT,#1,SEC$W_FLAGS(R4),R1
	PUSHAB	WRT_TABLE[R1]
	PUSHL	SEC$W_SECXBL(R4)	; BACKWARD LINK
	PUSHL	SEC$W_SECXFL(R4)	; FORWARD LINK
	PUSHL	SEC$L_REFCNT(R4)	; REFERENCE COUNT
	PUSHL	SEC$L_CCB(R4)		; CCB ADDRESS
	EXTZV	#SEC$V_PFC,#SEC$S_PFC,SEC$L_VPXPFC(R4),-(SP)
	PUSHL	SEC$L_VBN(R4)		; STARTING BLOCK NUMBER
	PUSHL	SEC$L_WINDOW(R4)	; WINDOW CONTROL BLOCK
	PUSHL	SEC$L_PAGCNT(R4)	; PAGE COUNT
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,SEC$L_VPXPFC(R4),R1
	ASHL	#9,R1,-(SP)		; VIRTUAL ADDRESS OF SECTION
	PUSHL	R5			; SECTION TABLE INDEX
	PRINT	14,<!_ !XW     !XL !XL   !XL  !XL   !4UL  !XL  !4UL     !XW  !XW   !4(AC)>
	BRW	10$

	.DSABL	LSB

;
;	SUBROUTINE TO PRINT THE SUB-HEADING LINE
;
PST_TITLE:
	.WORD	0
	
	SKIP	1
	PRINT	0,<!_INDEX      ADDRESS   PAGES     WINDOW     VBN    CLUSTER  CHANNEL  REFCNT  FLINK BLINK   FLAGS>
	SKIP	1
	RET

	.SBTTL	SHOW_PPT -- SHOW PROCESS PAGE TABLES
;---
;
;	SHOW_PPT
;
;	THIS ROUTINE DISPLAYS THE CONTENTS OF THE P0 AND
;	P1 PAGE TABLES FOR THE CURRENT PROCESS.
;
;   INPUTS:
;
;	PCB = PROCESS CONTROL BLOCK
;	PHD = PROCESS HEADER BLOCK
;
;   OUTPUTS:
;
;	NONE
;
;---

SHOW_PPT:
	.WORD	^M<R2,R3>

	CALLS	#0,INIT_PFN		; SETUP ACCESS TO PFN DATA BASE
	MOVAL	PCB,R2
	MOVAL	PHD,R3
	SKIP	2
	ENSURE	8
	PRINT	0,<P0 page table>
	PRINT	0,<------------->
	SKIP	1
	PUSHL	PCB$L_PHD(R2)		; ADDRESS OF PROCESS HEADER
	PUSHL	PHD$L_P0BR(R3)		; ADDRESS OF P0 PAGE TABLE
	PUSHL	#0			; STARTING ADDRESS BEING MAPPED
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,PHD$L_P0LRASTL(R3),-(SP) ; NUM ENTRIES
	CALLS	#4,DUMP_PTE		; FORMAT PAGE TABLE

	SKIP	2
	ENSURE	8
	PRINT	0,<P1 page table>
	PRINT	0,<------------->
	SKIP	1
	MOVL	PHD$L_P1LR(R3),R1	; GET P1LR
	BEQL	90$			; SKIP IF ZERO
	SUBL3	R1,#^X200000,R1		; TOTAL PAGES ALLOCATED
	ASHL	#9,R1,R0		; SIZE OF P1 SPACE IN BYTES
	PUSHL	PCB$L_PHD(R2)		; ADDRESS OF PROCESS HEADER
	MOVL	PHD$L_P1LR(R3),R2	; GET NUMBER OF PAGES
	PUSHAL	@PHD$L_P1BR(R3)[R2]	; STARTING ADDRESS OF TABLE
	SUBL3	R0,#^X80000000,-(SP)	; STARTING ADDRESS BEING MAPPED
	PUSHL	R1			; TOTAL PAGES IN TABLE
	CALLS	#4,DUMP_PTE		; FORMAT PAGE TABLE

90$:	RET

	.SBTTL	PROCESS_SUMMARY -- DISPLAY LIST OF RUNNING PROCESSES
;---
;
;	PROCESS_SUMMARY
;
;	PRINT A LIST OF THE PROCESSES CURRENTLY RUNNING
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

PROCESS_SUMMARY::
	.WORD	^M<R2,R3,R4,R5,R6,R7>

	SUBHD	<Current process summary>
	SKIP	PAGE
	CALLS	#0,SUMMARY_TITLE	; PRINT SUBHEADING LINE
	MOVAB	SUMMARY_TITLE,HEADING_ROUTINE	; SET HEADING ROUTINE

	REQMEM	@SCH$GL_PCBVEC,R2	; VECTOR OF PCB ADDRESSES
	REQMEM	@SCH$GL_MAXPIX,R3	; GET MAXIMUM PROCESS INDEX
	MOVL	R2,R7			; ADDRESS OF NULL PROCESS SLOT
	MOVAB	PCB,R4
	MOVAB	PHD,R5
10$:
	REQMEM	(R2)			; GET ADDRESS OF NEXT PCB
	GETMEM	(R1),(R4),#PCB$C_LENGTH  ; READ ENTIRE PCB
	BLBC	R0,12$			; SKIP IF ERROR READING
	TSTW	PCB$L_PID(R4)		; CHECK IF NULL PROCESS
	BNEQ	15$			; BRANCH IF NOT
	CMPL	R2,R7			; IS THIS THE REAL NULL PROCESS?
	BEQL	15$			; OK IF NULL PROCESS
12$:	BRW	50$			; BYPASS THIS ENTRY
15$:
	TSTL	PCB$L_PHD(R4)		; CHECK IF ZERO
	BEQL	18$			; BRANCH IF SWAPPED OUT
	TRYMEM	@PCB$L_PHD(R4),(R5),#PHD$C_LENGTH  ; READ PROCESS HEADER
	BLBS	R0,20$			; BRANCH IF OK
18$:
	ADDW3	PCB$W_PPGCNT(R4),PCB$W_GPGCNT(R4),R0
	MOVZWL	R0,-(SP)		; WORKING SET SIZE (PHYS. MEM.)
	PUSHL	PCB$W_MEM(R4)		; UIC MEMBER
	PUSHL	PCB$W_GRP(R4)		; UIC GROUP
	SUBB3	PCB$B_PRI(R4),#31,R1	; CURRENT PRIORITY
	MOVZBL	R1,-(SP)
	MOVZWL	PCB$W_STATE(R4),R1	; CURRENT STATE
	PUSHAQ	STATE_TABLE[R1]
	PUSHAB	PCB$T_LNAME(R4)		; PROCESS NAME
	PUSHL	PCB$L_PID(R4)		; PROCESS IDENTIFICATION
	PRINT	7,<!XL !15AC --- SWAPPED OUT ---            !5AC !2UB [!3OB,!3OB] !4UW>
	BRW	50$
20$:
	ADDW3	PCB$W_PPGCNT(R4),PCB$W_GPGCNT(R4),R0
	MOVZWL	R0,-(SP)		; WORKING SET SIZE (PHYS. MEM.)
	PUSHL	PCB$W_MEM(R4)		; UIC MEMBER
	PUSHL	PCB$W_GRP(R4)		; UIC GROUP
	SUBB3	PCB$B_PRI(R4),#31,R1	; CURRENT PRIORITY
	MOVZBL	R1,-(SP)
	MOVZWL	PCB$W_STATE(R4),R1	; CURRENT STATE
	PUSHAQ	STATE_TABLE[R1]
	PUSHAB	NOTAVAIL		; PRESET TO USE "NOT AVAILABLE" STRING
	CALLS	#0,READ_IMAGE		; READ IMAGE FILE NAME
	BLBC	R0,25$			; BRANCH IF ERROR READING
	MOVL	R6,(SP)			; ADDRESS OF NAME BUFFER
25$:
	PUSHAB	PCB$T_LNAME(R4)		; PROCESS NAME
	PUSHL	PCB$L_PID(R4)		; PROCESS IDENTIFICATION
	PRINT	8,<!XL !15AC !30AC !5AC !2UB [!3OB,!3OB] !4UW>
50$:
	ADDL2	#4,R2			; NEXT PCB ADDRESS
	DECL	R3			; DECREMENT ITERATION COUNT
	BLSS	90$			; BRANCH IF FINISHED
	BRW	10$			; CONTINUE UNTIL DONE

90$:
	CALLS	#0,SET_PROCESS		; RESET PROCESS PAGE REGISTERS
	STATUS	SUCCESS
	RET

	.DSABL	LSB

;
;	SUBROUTINE TO PRINT TITLE LINE
;
SUMMARY_TITLE:
	.WORD	0

	SKIP	1
	PRINT	0,<   PID   Process name    Image name!20* State Pri    UIC   WKSET>
	PRINT	0,<   ---   ------------    ----------!20* ----- ---    ---   ----->
	SKIP	1
	RET

	.SBTTL	READ_IMAGE, READ IMAGE FILE NAME STRING
;---
;
;	SUBROUTINE TO READ THE IMAGE FILE NAME FOR THE
;	PROCESS DESCRIBED BY THE SPECIFIED PCB AND PHD.
;
;	R4 = ADDRESS OF PCB
;	R5 = ADDRESS OF PHD
;	CALL
;	R0 = SUCCESS/FAILURE FLAG
;	R6 = ADDRESS OF BUFFER CONTAINING ASCIC FILE NAME
;
;---

READ_IMAGE:
	.WORD	^M<R2>

	MOVAB	L^BUFFER,R6		; SET BUFFER ADDRESS
	CLRB	(R6)			; PRESET TO NULL STRING
	CMPW	PCB$L_PID(R4),#1	; CHECK IF INDEX = 0 OR 1
	BLEQU	50$			; IF NULL,SWAPPER SKIP THIS
	MOVAQ	P0BR,R0
	MOVQ	PHD$L_P0BR(R5),(R0)	; SETUP RELOCATION REGISTERS
	MOVQ	PHD$L_P1BR(R5),8(R0)
	EXTZV	#PHD$V_P0LR,#PHD$S_P0LR,4(R0),4(R0)
	MOVL	PCB$L_PID(R4),PROC_PID	; SET PROCESS PID TO READ
	BLBS	VERSION_FLAGS,10$	; BRANCH IF RELEASE 2
;
;	VMS RELEASE 1 - IMAGE FILE NAME RESIDES IN IFD BUFFER
;
	MOVL	MMG$IMGHDRBUF,R1	; ADDRESS OF IMAGE BUFFER
	TRYMEM	4(R1),R2		; GET ADDRESS OF IFD
	BLBC	R0,90$			; BRANCH IF ERROR
	TRYMEM	IFD$W_FILNAMOFF(R2)	; GET OFFSET TO FILE NAME
	BLBC	R0,90$			; BRANCH IF ERROR
	CVTWL	R1,R1
	BEQL	50$			; BRANCH IF ZERO OFFSET
	TRYMEM	(R2)[R1],(R6),#32	; GET ASCIC IMAGE FILE NAME
	BLBC	R0,90$			; BRANCH IF ERROR
	CMPB	(R6),#32		; CHECK IF OVER 32 CHARACTERS
	BLEQU	50$			; BRANCH IF OK
	MOVB	#32,(R6)		; TRUNCATE TO 32 CHARACTERS
50$:	MOVL	#1,R0			; SET NO IMAGE NAME
90$:	CLRL	PROC_PID		; CLEAR PID ON EXIT SO THAT MEMORY
					; REQUESTS FOR SYSTEM SPACE WILL GO
					; FASTER (DON'T NEED THIS CONTEXT)
	RET
;
;	VMS RELEASE 2 - IMAGE FILE DESCRIBED BY IFD$Q_CURPROG
;
10$:	TRYMEM	@CTL$GL_IMGHDRBF	; READ ADDRESS OF IMAGE HEADER
	BLBC	R0,90$			; BRANCH IF ERROR
	TSTL	R1			; ANY IMAGE HEADER?
	BEQL	50$			; BRANCH IF NONE
	TRYMEM	4(R1)			; READ IFD POINTER
	BLBC	R0,90$			; BRANCH IF ERROR
	TRYMEM	IFD$Q_CURPROG(R1),(R6),#8	; READ DESCRIPTOR
	BLBC	R0,90$			; BRANCH IF ERROR
	MOVZBL	(R6),R0			; CHECK LENGTH OF STRING
	BEQL	50$			; BRANCH IF NULL
	TRYMEM	@4(R6),1(R6),R0		; READ FILE NAME STRING
	BLBC	R0,90$			; BRANCH IF ERROR
	BRB	50$			; SUCCESS


	.END
