	.TITLE	CRASH	DISPLAY CRASH RELATED INFORMATION
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	THIS MODULE CONTAINS ROUTINES TO FORMAT INFORMATION
;	SAVED AT CRASH TIME.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V02-005	KDM0063		Kathleen D. Morse	03-Aug-1981
;		Change version number in dump header to 2.  Make SDA
;		understand dumps with and without the PCB in the error
;		log message.  Add process name and id to bugcheck error
;		log message.
;
;	V02-004	KDM0061		Kathleen D. Morse	24-Jul-1981
;		Fix pointer to bugcheck error log message in first
;		block of dump file, so that it points past the header
;		information that is now at negative offsets.
;
;	V02-003	MTR0001		Mike Rhodes		22-Jun-1981
;		A.  Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;		B.  Change default addressing mode to longword.
;		C.  Remove references to $SDAMSGDEF macro.
;
;	V02-002	TMH0002		Tim Halvorsen		20-May-1981
;		Increase size of image filespec buffer.
;
;	V02-001	TMH0001		Tim Halvorsen		30-Sep-1980
;		Update SHOW CRASH for 11/750 processor registers.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$DMPDEF			; DUMP FILE DEFINITIONS
	$EMBDEF <CR,ET,HD>	; CRASHDUMP ERROR LOG ENTRY
	$ERLDEF			; ERROR LOG DEFINITIONS
	$PCBDEF			; PROCESS CONTROL BLOCK
	$PHDDEF			; PROCESS HEADER DEFINITIONS
	$IFDDEF			; IMAGE FILE DESCRIPTOR
	$PSLDEF			; PROGRAM STATUS LONGWORD

	.SBTTL	STORAGE DEFINITIONS

;
;	STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT

ERLPTR::
	.BLKL	2			; ADDRESS OF ERROR LOG ENTRY


	.PSECT	CRASH,EXE,NOWRT,LONG

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

;
;	TABLE OF BUGCHECK CODES WHICH CAUSE THE CONSOLE TO
;	WIPE OUT MOST OF THE REGISTERS.  THIS TABLE IS TAKEN
;	DIRECTLY FROM THE CODE IN POWERFAIL.
;
RESTART_BUGS:
	.LONG	BUG$_IVLISTK		; INVALID INTERRUPT STACK
	.LONG	BUG$_DBLERR		; DOUBLE ERROR HALT
	.LONG	BUG$_HALT		; HALT INSTRUCTION
	.LONG	BUG$_ILLVEC		; ILLEGAL VECTOR CODE
	.LONG	BUG$_NOUSRWCS		; NO USER WCS FOR VECTOR
	.LONG	BUG$_ERRHALT		; ERROR PENDING ON HALT
	.LONG	BUG$_CHMONIS		; CHM ON INTERRUPT STACK
	.LONG	0			; --- END OF TABLE

	.SBTTL	DISPLAY_CRASH -- DISPLAY CRASH INFORMATION
;---
;
;	DISPLAY_CRASH
;
;	THIS ROUTINE DISPLAYS ALL RELATED INFORMATION REGARDING
;	THE SAVED STATE OF THE PROCESSOR AT THE TIME OF THE
;	SYSTEM BUGCHECK EXCEPTION.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

	.ENTRY	DISPLAY_CRASH,-
		^M<R2,R9>

	SUBHD	<System crash information>	; SET NEW HEADING
	SKIP	PAGE

	MOVL	ERLPTR,R9		; ADDRESS OF ERROR LOG ENTRY
	ALLOC	24,R2			; ALLOCATE SPACE FOR DATE/TIME
	$ASCTIM_S TIMADR=EMB$Q_CR_TIME(R9),TIMBUF=(R2)
	PUSHL	R2
	PRINT	1,<Time of system crash: !AS>

	SKIP	2
	GETMEM	@SYS$GQ_VERSION,-(SP)	; GET SYSTEM VERSION
	PUSHL	SP			; ADDRESS OF STRING
	PUSHL	#4			; LENGTH OF STRING
	PRINT	3,<Version of system: VAX/VMS VERSION !AD>

	ASHL	#-3,EMB$L_CR_CODE(R9),R0	; MESSAGE NUMBER
	BEQL	25$			; SKIP IF NO MESSAGE
	MOVAB	L^BUG$T_MESSAGES,R1	; ADDRESS OF MESSAGES
20$:
	MOVZBL	(R1)+,R2		; LENGTH OF MESSAGE
	ADDL2	R2,R1			; SKIP TO NEXT MESSAGE
	SOBGTR	R0,20$			; LOOP UNTIL FOUND
	PUSHL	R1			; ADDRESS OF BUGCHECK MESSAGE
	SKIP	2
	PRINT	1,<Reason for BUGCHECK exception: !AC>

25$:
	GETMEM	@SCH$GL_CURPCB		; GET CURRENT PROCESS'S PCB
	BLBC	R0,26$			; BRANCH IF DATA NOT AVAILABLE
	CLRQ	-(SP)			; INITIALIZE A BUFFER TO HOLD
	CLRQ	-(SP)			; THE CURRENT PROCESS'S NAME
	MOVL	SP,R2			; REMEMBER ADDRESS OF BUFFER
	GETMEM	PCB$T_LNAME(R1),(R2),#16 ; GET CURRENT PROCESS'S NAME
	PUSHL	R2			; PROCESS NAME
	SKIP	2
	PRINT	1,<Process currently executing: !AC>
	ADDL	#16,SP			; CLEAN BUFFER OFF STACK
26$:

	CALLS	#0,CURPROC		; SET TO CURRENT PROCESS
	MOVL	MMG$IMGHDRBUF,R1	; ADDRESS OF HEADER BUFFER
	TRYMEM	4(R1),R2		; GET ADDRESS OF IFD
	BLBC	R0,30$			; IF NOT AVAILABLE
	TRYMEM	IFD$W_FILNAMOFF(R1)	; GET OFFSET TO FILE NAME
	BLBC	R0,30$			; BRANCH IF NOT AVAILABLE
	CVTWL	R1,R1			; CONVERT TO LONGWORD
	SUBL	#64,SP			; ALLOCATE BUFFER FOR FILESPEC
	MOVL	SP,R0
	TRYMEM	(R2)[R1],(R0),#64	; GET ASCIC IMAGE FILE NAME
	BLBC	R0,30$			; BRANCH IF NOT AVAILABLE
	PUSHL	SP
	SKIP	2
	PRINT	1+<64/4>,<Current image file name: !AC>

30$:
	EXTZV	#PSL$V_IPL,#PSL$S_IPL,EMB$L_CR_PSL(R9),-(SP)
	SKIP	2
	PRINT	1,<Current IPL: !UL  (decimal)>

	SKIP	5
	ENSURE	7
	PRINT	0,<General registers:>
	SKIP	1
;
;	IF THE BUGCHECK CODE WAS ANY OF THE ONES THAT COME
;	BACK FROM THE CONSOLE ROM VIA POWERFAIL RESTART, THEN
;	DO NOT PRINT THE REGISTERS AS THEY HAVE BEEN WIPED OUT.
;
	BICL3	#7,EMB$L_CR_CODE(R9),R0	; BUGCHECK CODE (CLEAR FLAG)
	MOVAL	RESTART_BUGS,R1		; TABLE OF RESTART BUGCHECKS
40$:
	CMPL	R0,(R1)+		; CHECK IF MATCHES
	BEQL	45$			; BRANCH IF SO
	TSTL	(R1)			; END OF TABLE?
	BNEQ	40$			; CONTINUE UNTIL DONE
	BRB	50$			; PRINT REGISTERS
45$:
	PUSHL	EMB$L_CR_R11(R9)	; PSL
	PUSHL	EMB$L_CR_R10(R9)	; PC
	PRINT	2,<!_PC  = !XL   PSL = !XL>
	SKIP	1
	PRINT	0,<!_Remaining registers not available -- wiped out by console>
	SKIP	1
	PRINT	0,<Processor registers:>
	SKIP	1
	PUSHL	EMB$L_CR_SCBB(R9)
	PUSHL	EMB$L_CR_SLR(R9)
	PUSHL	EMB$L_CR_SBR(R9)
	PRINT	1,<!_SBR    = !XL>
	PRINT	1,<!_SLR    = !XL>
	PRINT	1,<!_SCBB   = !XL>
	BRW	60$			; PRINT KSP-ISP REGISTERS
50$:
	PUSHL	EMB$L_CR_R3(R9)
	PUSHL	EMB$L_CR_R2(R9)
	PUSHL	EMB$L_CR_R1(R9)
	PUSHL	EMB$L_CR_R0(R9)
	PRINT	4,<!_R0  = !XL   R1  = !XL   R2  = !XL   R3  = !XL>
	PUSHL	EMB$L_CR_R7(R9)
	PUSHL	EMB$L_CR_R6(R9)
	PUSHL	EMB$L_CR_R5(R9)
	PUSHL	EMB$L_CR_R4(R9)
	PRINT	4,<!_R4  = !XL   R5  = !XL   R6  = !XL   R7  = !XL>
	PUSHL	EMB$L_CR_R11(R9)
	PUSHL	EMB$L_CR_R10(R9)
	PUSHL	EMB$L_CR_R9(R9)
	PUSHL	EMB$L_CR_R8(R9)
	PRINT	4,<!_R8  = !XL   R9  = !XL   R10 = !XL   R11 = !XL>
	PUSHL	EMB$L_CR_PC(R9)
	PUSHL	EMB$L_CR_SP(R9)
	PUSHL	EMB$L_CR_FP(R9)
	PUSHL	EMB$L_CR_AP(R9)
	PRINT	4,<!_AP  = !XL   FP  = !XL   SP  = !XL   PC  = !XL>
	PUSHL	EMB$L_CR_PSL(R9)
	PRINT	1,<!_PSL = !XL>
	SKIP	4
	ENSURE	10
	PRINT	0,<Processor registers:>
	SKIP	1
	GETMEM	@EXE$GB_CPUTYPE		; GET TYPE OF CPU
	BLBC	R0,780$			; IF NOT FOUND, ASSUME 11/780
	CASE	R1,TYPE=B,-		; DISPATCH ON CPU TYPE
		LIMIT=#PR$_SID_TYP780,-
		<780$,-			; 11/780
		750$>			; 11/750
					; ALL OTHERS USE 11/780
;
;	11/780 INTERNAL REGISTERS
;
780$:	PUSHL	EMB$L_CR_ACCS(R9)
	PUSHL	EMB$L_CR_PCBB(R9)
	PUSHL	EMB$L_CR_P0BR(R9)
	PRINT	3,<!_P0BR   = !XL     PCBB   = !XL     ACCS   = !XL>
	PUSHL	EMB$L_CR_SBIFS(R9)
	PUSHL	EMB$L_CR_SCBB(R9)
	PUSHL	EMB$L_CR_P0LR(R9)
	PRINT	3,<!_P0LR   = !XL     SCBB   = !XL     SBIFS  = !XL>
	PUSHL	EMB$L_CR_SBISC(R9)
	PUSHL	EMB$L_CR_ASTLVL(R9)
	PUSHL	EMB$L_CR_P1BR(R9)
	PRINT	3,<!_P1BR   = !XL     ASTLVL = !XL     SBISC  = !XL>
	PUSHL	EMB$L_CR_SBIMT(R9)
	PUSHL	EMB$L_CR_SISR(R9)
	PUSHL	EMB$L_CR_P1LR(R9)
	PRINT	3,<!_P1LR   = !XL     SISR   = !XL     SBIMT  = !XL>
	PUSHL	EMB$L_CR_SBIER(R9)
	PUSHL	EMB$L_CR_ICCS(R9)
	PUSHL	EMB$L_CR_SBR(R9)
	PRINT	3,<!_SBR    = !XL     ICCS   = !XL     SBIER  = !XL>
	PUSHL	EMB$L_CR_SBITA(R9)
	PUSHL	EMB$L_CR_ICR(R9)
	PUSHL	EMB$L_CR_SLR(R9)
	PRINT	3,<!_SLR    = !XL     ICR    = !XL     SBITA  = !XL>
	PUSHL	EMB$L_CR_SBIS(R9)
	PUSHL	EMB$L_CR_TODR(R9)
	PRINT	2,<!_                      TODR   = !XL     SBIS   = !XL>
	SKIP	1
	BRW	60$
;
;	11/750 INTERNAL REGISTERS
;
750$:	PUSHL	EMB$L_CR_ACCS(R9)
	PUSHL	EMB$L_CR_PCBB(R9)
	PUSHL	EMB$L_CR_P0BR(R9)
	PRINT	3,<!_P0BR   = !XL     PCBB   = !XL     ACCS   = !XL>
	PUSHL	EMB$L_CR_TBDR(R9)
	PUSHL	EMB$L_CR_SCBB(R9)
	PUSHL	EMB$L_CR_P0LR(R9)
	PRINT	3,<!_P0LR   = !XL     SCBB   = !XL     TBDR   = !XL>
	PUSHL	EMB$L_CR_CADR(R9)
	PUSHL	EMB$L_CR_ASTLVL(R9)
	PUSHL	EMB$L_CR_P1BR(R9)
	PRINT	3,<!_P1BR   = !XL     ASTLVL = !XL     CADR   = !XL>
	PUSHL	EMB$L_CR_MCESR(R9)
	PUSHL	EMB$L_CR_SISR(R9)
	PUSHL	EMB$L_CR_P1LR(R9)
	PRINT	3,<!_P1LR   = !XL     SISR   = !XL     MCESR  = !XL>
	PUSHL	EMB$L_CR_CAER(R9)
	PUSHL	EMB$L_CR_ICCS(R9)
	PUSHL	EMB$L_CR_SBR(R9)
	PRINT	3,<!_SBR    = !XL     ICCS   = !XL     CAER   = !XL>
	PUSHL	EMB$L_CR_CMIERR(R9)
	PUSHL	EMB$L_CR_ICR(R9)
	PUSHL	EMB$L_CR_SLR(R9)
	PRINT	3,<!_SLR    = !XL     ICR    = !XL     CMIERR = !XL>
	PUSHL	EMB$L_CR_TODR(R9)
	PRINT	1,<!_                      TODR   = !XL>
	SKIP	1
60$:
	PUSHL	EMB$L_CR_ISP(R9)
	PRINT	1,<!_ISP    = !XL>
	PUSHL	EMB$L_CR_USP(R9)
	PUSHL	EMB$L_CR_SSP(R9)
	PUSHL	EMB$L_CR_ESP(R9)
	PUSHL	EMB$L_CR_KSP(R9)
	PRINT	1,<!_KSP    = !XL>
	PRINT	1,<!_ESP    = !XL>
	PRINT	1,<!_SSP    = !XL>
	PRINT	1,<!_USP    = !XL>
	RET

	.SBTTL	PRINT_HEADER -- PRINT THE DUMP FILE HEADER BLOCKS
;---
;
;	PRINT_HEADER
;
;	DUMP THE CONTENTS OF THE DUMP FILE HEADER BLOCKS
;
;   INPUTS:
;
;	DUMP_HEADER = DUMP FILE HEADER (3 BLOCKS)
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENABL	LSB

PRINT_HEADER::
	.WORD	^M<R2>

	SUBHD	<Dump file header>
	SKIP	PAGE
	MOVAL	DUMP_HEADER,R2		; STARTING ADDRESS
	MOVL	#3*512,R3		; LENGTH TO DUMP
10$:
	PUSHL	R2			; DUMP ADDRESS
	PUSHL	R2			; ADDRESS OF ASCII STRING
	PUSHL	#32			; LENGTH OF STRING
	MOVL	#8,R0			; REPEAT COUNT
20$:
	PUSHL	(R2)+
	SOBGTR	R0,20$			; PUSH NEXT 8 LONGWORDS
	PRINT	11,<!XL !XL !XL !XL !XL !XL !XL !XL  !AF     !XL>
	SUBL2	#32,R3			; DECREMENT LENGTH
	BGTR	10$			; CONTINUE UNTIL DONE
	RET

	.DSABL	LSB

	.SBTTL	GET_DUMP_INFO -- GET DUMP HEADER INFO
;---
;
;	GET_DUMP_INFO
;
;	FIND THE ERROR LOG ENTRY AND SAVE IT.  IF THE
;	ENTRY CANNOT BE FOUND, GENERATE A DUMMY ENTRY.
;
;   INPUTS:
;
;	NONE
;
;   OUTPUTS:
;
;	ERLPTR = ADDRESS OF ERROR LOG ENTRY
;
;---
	.ENABL	LSB

GET_DUMP_INFO::
	.WORD	^M<R2,R8,R9>

;
;	SET FLAGS DESCRIBING THE VERSION OF THE SYSTEM
;
	CLRL	VERSION_FLAGS		; PRESET FLAGS LONGWORD
	GETMEM	@SYS$GQ_VERSION		; READ THE SYSTEM VERSION
	CMPW	R1,#^A'1.'		; 1.0 EXECUTIVE? (1.01,1.5 ALSO)
	BEQL	2$			; BRANCH IF NOT
	MOVL	#1,VERSION_FLAGS	; INDICATE VERSION 2
2$:
	BLBC	CURRENT_SYSTEM,3$	; BRANCH IF EXAMINING DUMP FILE
	BRW	30$			; SETUP FOR CURRENT SYSTEM
3$:
	MOVAB	DUMP_HEADER+DMP$L_CRASHERL,ERLPTR ; SET PTR TO ERROR LOG ENTRY
	CMPW	DUMP_HEADER+DMP$W_DUMPVER,#2 ; IS ERR MSG HDR AT NEG OFFSETS?
	BLSS	1$			; BR IF NO, (VMS V2 FORMAT)
	ADDL	#EMB$K_LENGTH,ERLPTR	; POINT PAST THE ERRMSG HDR (VMS V3)
1$:
	MOVL	ERLPTR,R9		; ADDRESS OF ERROR LOG ENTRY
;
;	THE FOLLOWING CODE ADJUSTS THE SAVED SP SINCE IT WAS
;	NOT SAVED UNTIL AFTER THE PC,PSL WAS ADDED TO THE STACK.
;
4$:	ADDL2	#2*4,EMB$L_CR_SP(R9)	; ADJUST DUE TO BUGCHECK
;
;	STORE THE CURRENT SP (R14) INTO THE CORRESPONDING PROCESSOR
;	REGISTER CORRESPONDING TO THE ACCESS MODE ONLY IF KERNEL OR
;	INTERRUPT STACK.  IF OTHER STACK, THEN USE THE PROCESSOR
;	REGISTER BECAUSE BUGCHECK HAS TO MOVE THE INFO TO THE KERNEL
;	MODE STACK AND IN THE PROCESS, WIPES THE SP REGISTER.
;	
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,EMB$L_CR_PSL(R9),R1
	BEQL	10$			; BRANCH IF KERNEL/INTERRUPT
	MOVL	EMB$L_CR_KSP(R9)[R1],EMB$L_CR_SP(R9) ; FIX SP VALUE
	BRB	6$
10$:	BBS	#PSL$V_IS,EMB$L_CR_PSL(R9),5$	; BRANCH IF ISP
	MOVL	EMB$L_CR_SP(R9),EMB$L_CR_KSP(R9)[R1]	; R14 TO PR[MODE+1]
	BRB	6$
5$:	MOVL	EMB$L_CR_SP(R9),EMB$L_CR_ISP(R9)	; R14 TO PR[0]
6$:
;
;	SIMULATE A SVPCTX INSTRUCTION IN ORDER TO MAKE THE HARDWARE
;	PCB IN THE PROCESS HEADER CORRESPOND TO THE SAVED REGISTERS
;	AT THE TIME OF THE CRASH.
;
	GETMEM	@SCH$GL_CURPCB		; ADDRESS OF CURRENT PCB
	BLBC	R0,21$			; BRANCH IF CANNOT READ
	GETMEM	PCB$L_PHD(R1),R2	; GET ADDRESS OF CURRENT PHD
	BLBC	R0,21$			; BRANCH IF CANNOT READ
	TSTL	R2			; PHD VALID?
	BEQL	21$			; SKIP IF NOT
	PUTMEM	PHD$L_KSP(R2),EMB$L_CR_KSP(R9),#4*4 ; SET KSP - USP
	PUTMEM	PHD$L_R0(R2),EMB$L_CR_R0(R9),#14*4 ; SET R0 - R13
	PUTMEM	PHD$L_PC(R2),EMB$L_CR_PC(R9),#2*4 ; SET PC,PSL
21$:	RET

;
;	EXAMINE CURRENT RUNNING SYSTEM -- CREATE A DUMMY
;	ERROR LOG ENTRY AND DUMP HEADER.
;
30$:	MOVAB	DUMP_HEADER,R8		; ADDRESS OF DUMP HEADER
	BBSS	#DMP$V_OLDDUMP,DMP$L_FLAGS(R8),32$ ; FLAG DUMP ANALYZED
32$:	PUSHL	#EMB$C_CR_LENGTH	; LENGTH OF CRASH LOG ENTRY
	CALLS	#1,ALLOCATE		; ALLOCATE STORAGE
	MOVL	R1,ERLPTR		; SAVE ADDRESS OF ERL BUFFER
	MOVL	R1,R9			; REFERENCE OFF R9
	GETMEM	@EXE$GQ_SYSTIME,EMB$Q_CR_TIME(R9),#8 ; SET DATE/TIME
	GETMEM	@MMG$GL_SPTLEN,R2	; LENGTH OF SPT IN LONGWORDS
	GETMEM	@MMG$GL_SBR		; PHYSICAL ADDRESS OF SPT
	MOVAL	(R1)[R2],R1		; COMPUTE PHYSICAL MEMORY SIZE
	ASHL	#-9,R1,PHYS_PAGES	; SAVE MEMORY SIZE IN PAGES
	GETMEM	@SCH$GL_CURPCB,R2	; GET ADDRESS OF CURRENT PCB
	BLBC	R0,35$			; BRANCH IF ERROR
	GETMEM	PCB$L_PID(R2),EMB$L_CR_PID(R9),#4 ; GET PID OF CURRENT PROCESS
	GETMEM	PCB$T_LNAME(R2),EMB$T_CR_LNAME(R9),#16 ; AND ALSO NAME
35$:	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.END
