.TITLE	UFD - CREATE DIRECTORY FILE

	 .IDENT	 /V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ELLEN	R SIMICH 1 APR 76
;
; ANDREW C. GOLDSTEIN  23-JUN-78  13:37


	.ENABL	LC

.SBTTL	MACRO CALLS AND	DEFINITIONS

; MACROS FROM SYSTEM LIBRARY

	.MCALL	FSRSZ$,FDBDF$,FDOP$A,FDRC$A,FDBK$A,OFNB$W,WRITE$,CLOSE$
	.MCALL	FINIT$,WAIT$,DELET$,DIR$,QIOW$,QIOW$S,GMCR$,GLUN$,EXIT$S


; MACRO	TO CALL	QIO ROUTINE

.MACRO	QIO	DPB
	JSR	R5,XQIO
	.WORD	DPB
.ENDM	QIO

; MACRO	FOR SOB'S

	.IF	NDF	R$$EIS
.MACRO	SOB	RX,LABEL
	DEC	RX
	BNE	LABEL
.ENDM	SOB
	.ENDC


UFDLUN=1
UFDEFN=1
COLUN=2
COEFN=2

EX$SUC	= 1
EX$ERR	= 3
FD.MNT	= 100000
FD.F11	= 40000
U.C1	= 4
UC.CON	= 200

.SBTTL	ASSORTED DATA -	DPB'S AND THE FDB

;
; GET COMMAND LINE
;
GCML:	GMCR$
;
; GET LUN INFO
;
GLUN:	GLUN$	UFDLUN,LUNBUF
;
; READ ATTRIBUTES FROM CONTAINING DIRECTORY
;
RATT:	QIOW$	IO.RAT,UFDLUN,UFDEFN,,IOSTAT,,<$FDB+F.FNB+N.DID,RATBLK,,,,>
;
; WRITE	ATTRIBUTES TO NEW DIRECTORY
;
WATT:	QIOW$	IO.WAT,UFDLUN,UFDEFN,,IOSTAT,,<$FDB+F.FNB,WATBLK,,,,>


;
; FCS STRUCTURES TO CREATE NEW FILE
;
	FSRSZ$	0


$FDB:	FDBDF$
	FDOP$A	UFDLUN,$UDEV
	FDRC$A	FD.RWM
	FDBK$A	DATBUF,512.,,,IOSTAT

.SBTTL	OTHER RANDOM DATA
;
; READ ATTRIBUTES CONTROL BLOCK
;
RATBLK:	.BYTE	-4,32.		; RECORD ATTRIBUTES
	.WORD	RECATT
	.BYTE	-3,4		; FILE CHARACTERISTICS
	.WORD	$FCHAR
	.BYTE	-21.,4		; FILE OWNER UIC
	.WORD	$FOWN
	.BYTE	-22.,2		; FILE PROTECTION
	.WORD	$FPRO
	.WORD	0		; END
;
; WRITE	ATTRIBUTES CONTROL BLOCK
;
WATBLK:	.BYTE	4,32.		; RECORD ATTRIBUTES
	.WORD	RECATT
	.BYTE	3,4		; FILE CHARACTERISTICS
	.WORD	$FCHAR
	.BYTE	-21.,4		; FILE OWNER UIC
	.WORD	$FOWN
	.BYTE	22.,2		; FILE PROTECTION
	.WORD	$FPRO
	.WORD	0		; END
;
; RECORD ATTRIBUTES
;
RECATT:	.BLKB	32.
;
; RANDOM VARIABLES - PARSER OUTPUT
;
$UUIC::	.WORD	0,0		; FILE OWNER
$UPRO::	.WORD	0		; PROTECTION
$UALL::	.WORD	0		; RECORDS TO ALLOCATE
$UDEV::	.WORD	0,0,0,0,0,0	; DEVICE NAME DESCRIPTOR (NULL DIR & FILE)


$NAMEL::.BLKW	1		; TOTAL LENGTH OF DIRECTORY STRING
$NAMEC::.WORD	0		; COUNT	OF NAMES GIVEN
$NAMEP::.WORD	0		; POINTER TO NEXT AVAILABLE NAME
$NAME1::.BLKW	3		; FIRST	DIRECTORY NAME
$NAME2::.BLKW	3		; SECOND DIRECTORY NAME
$NAME3::.BLKW	3		; THIRD	DIRECTORY NAME
$NAME4::.BLKW	3		; FOURTH DIRECTORY NAME
$NAME5::.BLKW	3		; FIFTH	DIRECTORY NAME
$NAME6::.BLKW	3		; SIXTH	DIRECTORY NAME
$NAME7::.BLKW	3		; SEVENTH DIRECTORY NAME
$NAME8::.BLKW	3		; EIGHTH DIRECTORY NAME
;
; FILE DATA
;
$FOWN::	.WORD	0,0		; FILE OWNER
$FPRO::	.WORD	0		; FILE PROTECTION
$FCHAR::.WORD	0,0		; FILE CHARACTERISTICS

.EXSTS::.WORD	0		; EXIT STATUS
ERRNUM:	.WORD	0		; ERROR	INDEX
CRFLG:	.WORD	0		; CREATION FLAG
IOSTAT:	.BLKW	2		; I/O STATUS BLOCK

STRING::			; STRING BUFFER
LUNBUF:				; AND BUFFER FOR GET LUN INFO
DATBUF:	.BLKB	512.		; DATA BUFFER

.SBTTL  ERROR MESSAGES

	.PSECT	MSGSTR,D
;
; ERROR	MESSAGE	INDEX TABLE
;
ERRMSG:	.WORD	ERRM0
	.WORD	ERRM1
	.WORD	ERRM2
	.WORD	ERRM3
	.WORD	ERRM4
	.WORD	ERRM5
	.WORD	ERRM6
	.WORD	ERRM7
	.WORD	ERRM8
	.WORD	ERRM9
	.WORD	ERRM10
	.WORD	ERRM11
;
; THE ERROR MESSAGES THEMSELVES
;
ERRM0:	.ASCIZ	<15>"UFD -- can't read MCR command buffer"
ERRM1:	.ASCIZ	<15>"UFD -- syntax error"
ERRM2:	.ASCIZ	<15>"UFD -- device not in system"
ERRM3:	.ASCIZ	<15>"UFD -- not	Files-11 device"
ERRM4:	.ASCIZ	<15>"UFD -- directory already exists"
ERRM5:	.ASCIZ	<15>"UFD -- failed to create directory"
ERRM6:	.ASCIZ	<15>"UFD -- volume not mounted"
ERRM7:	.ASCIZ	<15>"UFD -- too	many subdirectory levels"
ERRM8:	.ASCIZ	<15>"UFD -- access failure on existing directory"
ERRM9:	.ASCIZ	<15>"UFD -- close failure on directory file"
ERRM10:	.ASCIZ	<15>"UFD -- failed to initialize directory"
ERRM11:	.ASCIZ	<15>"UFD -- directory string is too long"
	.EVEN

.SBTTL  MAIN PROGRAM

;+
;
; *** -	$UFD - ENTRY FOR UFD MAIN PROGRAM
;
; CREATING A UFD BASICALLY INVOLVES FOLLOWING THE GIVEN	DIRECTORY PATCH
; UNTIL	WE FIND	SOMETHING MISSING. DIRECTORIES NOT PRESENT ARE CREATED UNTIL
; THE END OF THE DIRECTORY STRING IS REACHED. EACH DIRECTORY CREATED
; INHERITS BY DEFAULT THE ATTRIBUTES, OWNERSHIP, AND PROTECTION	OF THE
; PREVIOUS DIRECTORY.
;
;-


	.PSECT	CODE


;
; INITIALIZE AND PARSE THE COMMAND LINE.
;
$UFD::
	CLR	ERRNUM		; INIT ERROR INDEX
	MOV	#1,$FDB+F.ERR	; INIT ERROR STATUS

	DIR$	#GCML		; READ THE COMMAND LINE
	BCC	10$
	JMP	CMLERR		; NO COMMAND LINE

10$:	MOV	#$NAME1,$NAMEP	; SET UP NAME BLOCK POINTER
	CLR	$NAMEC		; INIT NAME COUNT
	MOV	#1,$NAMEL	; INIT NAME LENGTH
	MOV	#1,R1		; SET BLANK RECOGNITION
	MOV	#.UFDKT,R2	; GET KEYWORD TABLE
	MOV	@#$DSW,R3	; GET COMMAND LINE LENGTH
	MOV	#GCML+2,R4	; GET COMMAND LINE ADDR
	MOV	#.PSTRT,R5	; GET START STATE FOR PARSER
	CALL	.TPARS		; AND PARSE THE	COMMAND	LINE
	BCC	20$
	JMP	SYNERR		; SYNTAX ERROR
;
; ASSIGN THE DEVICE AND	CHECK THE CHARACTERISTICS
;
20$:	FINIT$			; INIT FCS
	MOV	#$FDB,R0
	MOV	#$FDB+F.FNB,R1
	MOV	#$UDEV,R2
	CLR	R3
	CALL	.PRSDV		; PARSE	DEVICE NAME
	BCS	30$
	DIR$	#GLUN		; GET LUN INFO

	MOV	LUNBUF+U.C1,R1	;ERS CHECK FOR VALID SWITCHES
	BIC	#^C<FD.MNT!FD.F11!77>,R1
	CMP	#FD.MNT!FD.F11!FD.DIR,R1

	BEQ	40$
	JMP	NDDEV		; ANYTHING ELSE	- OUT
30$:	JMP	BADDEV		; DEVICE DOES NOT EXIST
;
; INIT THE FILE	NAME IN	THE FDB	TO ".DIR;1" AND	START WITH THE MFD.
;
40$:	MOV	#^RDIR,F.FTYP(R0)
	MOV	#1,F.FVER(R0)
	MOV	#4,F.FNB+N.DID(R0)
	MOV	#4,F.FNB+N.DID+2(R0)
	CLR	F.FNB+N.DID+4(R0)

	MOV	#$NAME1,R5	; POINT	TO FIRST NAME
;
; NOW LOOP, SEARCHING FOR THE NEXT FILE	NAME
;
50$:	MOV	#$FDB+F.FNAM,R1
	MOV	(R5)+,(R1)+
	MOV	(R5)+,(R1)+
	MOV	(R5)+,(R1)+
	MOV	#$FDB+F.FNB,R1
	CLR	(R1)		; INDICATE NO FILE
	CALL	.FIND
	BCS	80$		; BRANCH IF NOT	FOUND

				; RE-ENTER HERE	FOR NEWLY CREATED DIRECTORY
60$:	MOV	F.FNB(R0),F.FNB+N.DID(R0) ; COPY FILE ID TO DIRECTORY ID
	MOV	F.FNB+2(R0),F.FNB+N.DID+2(R0)
	MOV	F.FNB+4(R0),F.FNB+N.DID+4(R0)
	DEC	$NAMEC		; COUNT	NAMES GIVEN
	BGT	50$
;
;WE GET	HERE WHEN ALL DIRECTORIES HAVE BEEN FOUND OR CREATED
;
	TST	CRFLG		; SEE IF WE CREATED ANYTHING
	BNE	70$		; BRANCH IF YES
	JMP	DUPLIC		; ALL THERE - DUPLICATE	DIRECTORY
70$:	JMP	EXIT		; SUCCESS
;
; WE GET HERE WHEN A LOOKUP FAILS. EITHER (HOPEFULLY) THE DIRECTORY DOESN'T
; EXIST, OR THERE WAS AN ERROR.
;
80$:	CMPB	#IE.NSF,F.ERR(R0) ; CHECK ERROR	STATUS
	BEQ	110$		; BRANCH IF NOT	FOUND
90$:	CMPB	F.ERR(R0),#IE.PRI ; CHECK FOR PRIVILEGE	VIOLATION
	BNE	100$		; BRANCH IF NOT
	CMP	F.FNB+N.DID(R0),#4 ; CHECK FOR MFD
	BNE	100$		; BRANCH IF NOT
	JMP	VNMO		; PRIVILEGE VIOLATION ON MFD MEANS VOL NOT MOUNTED
100$:	JMP	ACCFAI		; OTHER	ERROR

110$:	QIO	RATT		; READ ATTRIBUTES OF PRECEDING DIRECTORY
	BCS	90$		; BRANCH IF ERROR
;
; INITIALIZE THE ATTRIBUTES OF THE NEW DIRECTORY AND COPY THE RECORD
; ATTRIBUTES INTO THE FDB. NOTE	THAT WE	DISTINGUISH LEVEL 1 FROM LEVEL 2
; DIRECTORIES BY THE RECORD TYPE (FIXED	VERSUS VARIABLE).
;
	BIS	#UC.CON,$FCHAR	; FORCE	CONTIGUOUS
	MOV	$UUIC,R1	; CHECK	UIC FROM PARSER
	BIS	$UUIC+2,R1  
	BEQ	120$		; BRANCH IF DEFAULT
	MOV	$UUIC,$FOWN
	MOV	$UUIC+2,$FOWN+2

120$:	BIS	#104210,$FPRO	; DEFAULT PROTECTION HAS NO DELETE PERMIT
	MOV	$UPRO,R1	; CHECK	PROTECTION FROM	PARSER
	BEQ	130$		; BRANCH IF DEFAULT
	MOV	R1,$FPRO

130$:	MOV	R0,R1
	MOV	#RECATTR,R2	; POINT	TO ATTRIBUTES
	MOV	#7,R3		; WORD COUNT
140$:	MOV	(R2)+,(R1)+	; COPY ATTRIBUTES INTO FDB
	SOB	R3,140$

	MOV	$UALL,R1	; GET DESIRED NUMBER OF	ENTRIES
	ASR	R1		; COMPUTE # OF BLOCKS
	ASR	R1		; /16 FOR LEVEL	2
	ASR	R1		; /32 FOR LEVEL	1
	ASR	R1
	CMPB	F.RTYPE(R0),#R.FIX
	BNE	150$		; BRANCH IF LEVEL 2
	ASR	R1
150$:	INC	R1		; ROUND	UP TO AT LEAST 1 BLOCK
	MOV	R1,F.CNTG(R0)	; AND SET IN FDB
;
; NOW CREATE THE DIRECTORY FILE	AND WRITE THE ATTRIBUTES. IF IT	IS A
; LEVEL	2 DIRECTORY, WRITE THE INITIAL EMPTY FIRST BLOCK.
;
	OFNB$W	R0
	BCS	NCREAT		; BRANCH ON CREATE FAILURE
	QIO	WATT		; WRITE	ATTRIBUTES
	BCS	180$		; BRANCH ON FAILURE

	CMPB	F.RTYPE(R0),#R.FIX
	BEQ	170$		; BRANCH IF LEVEL 1
	MOV	#DATBUF,R1	; POINT	TO BUFFER
	MOV	#255.,R2	; WORD COUNT
	MOV	#-1,(R1)+	; END OF DATA MARKER
160$:	CLR	(R1)+		; THE REST IS ZERO
	SOB	R2,160$	 
	WRITE$	R0		; WRITE	INITIAL	BLOCK
	BCS	180$		
	WAIT$	R0
	BCS	180$

170$:	MOV	F.FNB(R0),-(SP)	; SAVE THE FILE	ID ACROSS THE CLOSE
	CLOSE$	R0		; CLOSE	THE FILE
	MOV	(SP)+,F.FNB(R0)
	BCS	CLOSEF
	INC	CRFLG		; SET THE CREATED FLAG
	BR	60$		; BRANCH BACK FOR NEXT LEVEL
;
; WE GET HERE IF EITHER	THE WRITE ATTRIBUTES OR	THE DATA WRITE FAILS
; DELETE THE DIRECTORY AND QUIT.
;
180$:	MOV	F.ERR(R0),-(SP)	; SAVE ERROR STATUS FOR	MESSAGE
	DELET$	R0
	MOV	(SP)+,F.ERR(R0)
	BR	INIFAI

.SBTTL	ERROR EXITS
;
; BRANCHES TO THE ERROR	EXITS BUMP UP AN ERROR INDEX WHICH IS
; USED TO LOCATE THE APPROPRIATE ERROR MESSAGE.	THE MESSAGE IS
; OUTPUT TO "CO".
;

NAMLEN::INC	ERRNUM		; NAME TOO LONG
INIFAI:	INC	ERRNUM		; INITIALIZATION FAILURE
CLOSEF:	INC	ERRNUM		; CLOSE	FAILURE
ACCFAI:	INC	ERRNUM		; ACCESS FAILURE ON DIRECTORY
NAMLEV::INC	ERRNUM		; TOO MANY LEVELS
VNMO:	INC	ERRNUM		; VOLUME NOT MOUNTED
NCREAT:	INC	ERRNUM		; FAILED TO CREATE
DUPLIC:	INC	ERRNUM		; DUPLICATE DIRECTORY
NDDEV:	INC	ERRNUM		; NOT A	DIRECTORY DEVICE
BADDEV:	INC	ERRNUM		; BAD DEVICE NAME
SYNERR::INC	ERRNUM		; SYNTAX ERROR
CMLERR:				; COMMAND LINE I/O ERROR
	MOV	ERRNUM,R0	; GET ERROR INDEX
	ASL	R0
	MOV	ERRMSG(R0),R0	; GET ERROR MESSAGE ADDR
	CALL	PRTMSG		; AND PRINT IT

	MOVB	$FDB+F.ERR,R1	; GET ERROR STATUS FROM	FDB
	BGE	20$		; BRANCH IF NO ERROR
	TSTB	$FDB+F.ERR+1	; CHECK	FOR DIRECTIVE ERROR
	BGE	10$
	SUB	#128.,R1	; USE DIRECTIVE	ERROR MESSAGES
10$:	MOV	#DATBUF,R0	; BUILD	MESSAGE	STRING IN DATA BUFFER
	MOV	R0,R2
	MOV	#ERRM0,R3	; GET MESSAGE HEADER
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	CALL	.FCSER		; GET I/O ERROR	MESSAGE	STRING
	MOV	R2,R0		; GET BACK START OF BUFFER
	CALL	PRTMSG		; ABD PRINT IT

20$:	MOV	#EX$ERR,R0	; SET ERROR STATUS
EXIT:	CALL	$EXST		; EXIT WITH STATUS

;
; EXIT WITH STATUS
;
$EXST:	EXIT$S

.SBTTL	ERROR MESSAGE PRINTER

;+
;
; CALL:	CALL	PRTMSG
;
;	R0 = ADDRESS OF	ASCIZ STRING
;
; PRINTS THE GIVEN MESSAGE TEXT	ON THE CONSOLE LUN
;
;-

PRTMSG:	MOV	R0,R1
10$:	TSTB	(R1)+		; LOOK FOR THE TERMINATOR
	BEQ	20$
	BR	10$
20$:	SUB	R0,R1		; COMPUTE CHARACTER COUNT

	QIOW$S	#IO.WVB,#COLUN,#COEFN,,,,<R0,R1,<#' >>
	RETURN

.SBTTL	QIO CALL ROUTINE

;+
;
; CALL:	JSR	R5,XQIO
;	.WORD	DPB
;	(RETURN)
;
;-


XQIO:	DIR$	(R5)+		; DO IT
	BCS	10$		; CHECK	FOR DIRECTIVE ERROR
	MOVB	IOSTAT,$FDB+F.ERR ; CHECK FOR I/O ERROR
	BGT	10$
	SEC			; SET CARRY ON ERROR
	RTS	R5

10$:	MOV	@#$DSW,$FDB+F.ERR
	RTS	R5



	.END	$UFD
