	.TITLE	UFDPTB - PARSER	STATE TABLE

.SBTTL	TITLE PAGE

.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  23-JUN-78  14:16


.SBTTL	MACRO CALLS AND DEFINTIONS

; SYSTEM MACRO CALLS

	.MCALL	FHDOF$,ISTAT$,STATE$,TRAN$

	FHDOF$

.SBTTL	IMPURE DATA

	.PSECT	IMPURE,D

GRCNT:	.BLKW	1		; GROUP	COUNTER	FOR PROTECTION PARSE
SAVUIC:	.BLKW	2		; TEMP STORAGE FOR UIC


.SBTTL	STATE TABLE FOR PARSER

LAB	= '<
RAB	= '>

	ISTAT$  .UFDST,.UFDKT
;
; READ OVER COMMAND NAME
;
	.GLOBL .PSTRT

	STATE$  .PSTRT
	TRAN$	40,DEV,SETSP
	TRAN$	$ANY,.PSTRT
;
; READ DEVICE AND UNIT NUMBER
;
	STATE$  DEV
	TRAN$	!LOGNAM,DEV2,SETDEV
	TRAN$	$LAMDA,DIR

	STATE$	DEV2
	TRAN$	':
;
; READ DIRECTORY STRING
;
	STATE$	DIR
	TRAN$	!UIC,OPTS,MAKUIC
	TRAN$	!NAME
;
; SCAN FOR OPTIONS AND END OF LINE
;
	STATE$  OPTS
	TRAN$	$EOS,$EXIT
	TRAN$	'/

	STATE$
	TRAN$	"UIC",UIC1
	TRAN$	"ALLOC",ALC
	TRAN$	"PRO",PRO
;
; SET OWNER UIC
;
	STATE$  UIC1
	TRAN$	'=

	STATE$  
	TRAN$	!UIC,OPTS
;
; SET ALLOCATION
;
	STATE$  ALC
	TRAN$	'=

	STATE$
	TRAN$	$DNUMB,,SETALC

	STATE$
	TRAN$	'.,OPTS
	TRAN$	$LAMDA,OPTS
;
; PROTECTION
;
	STATE$  PRO
	TRAN$	'=

	STATE$
	TRAN$	'[,,IGROUP

	STATE$  SPRO
	TRAN$	'],OPTS,ENDGRP
	TRAN$	<',>,SPRO,NXGRP
	TRAN$	'R,SPRO,SETRP
	TRAN$	'W,SPRO,SETWP
	TRAN$	'E,SPRO,SETEP
	TRAN$	'D,SPRO,SETDP
;
; READ UIC
;
	STATE$  UIC
	TRAN$	LAB,UIC0
	TRAN$	'[

	STATE$	UIC0 
	TRAN$	$NUMBR,,SETGN

	STATE$
	TRAN$	<',>

	STATE$
	TRAN$	$NUMBR,,SETPN

	STATE$
	TRAN$	RAB,$EXIT,GETUIC
	TRAN$	'],$EXIT,GETUIC
;
; READ ALPHA DIRECTORY NAME
;
	STATE$  NAME
	TRAN$	LAB,NAME1
	TRAN$	'[

	STATE$  NAME1
	TRAN$	$STRNG,,MAKER5

	STATE$
	TRAN$	'.,NAME1
	TRAN$	RAB,$EXIT
	TRAN$	'],$EXIT
;
; MATCH	LOGICAL	NAME STRING
;
	STATE$  LOGNAM
	TRAN$	$STRNG,LNAM1
	TRAN$	'$,LNAM1
	TRAN$	'_,LNAM1

	STATE$	LNAM1
	TRAN$	$STRNG,LNAM1
	TRAN$	'$,LNAM1
	TRAN$	'_,LNAM1
	TRAN$	$LAMDA,$EXIT

	STATE$ 


.SBTTL	ACTION ROUTINES	FOR THE	COMMAND	LINE PARSER

	.PSECT	CODE
;
; SET SPACE FLUSH MODE AFTER PASSING COMMAND NAME
;
SETSP:	BIC	#1,.PFLAG
	RETURN
;
; DEVICE NAME
;
SETDEV:	MOV	.PSTCN,$UDEV
	MOV	.PSTPT,$UDEV+2
	RETURN
;
; PPN -	GROUP NUMBER
;
SETGN:	MOV	.PNUMB,SAVUIC+2
	BR	TSTPN
;
; PPN -	PROGRAMMER NUMBER
;
SETPN:	MOV	.PNUMB,SAVUIC
TSTPN:	TST	.PNUMH		;CHECK IF NUMBER IS IN RANGE
	BEQ	10$		; BRANCH IF OK
	ADD	#2,(SP)		; OVER 65K - REJECT TRANSITION
10$:	RETURN
;
; STORE	UIC FOR	REAL ON	SUCCESSFUL MATCH
;
GETUIC:	MOV	SAVUIC,$UUIC
	MOV	SAVUIC+2,$UUIC+2
	RETURN
;
; TO HERE FOR ACTION ROUTINE DETECTED SYNTAX ERRORS
;
SYNTAX:	JMP	SYNERR
;
; NUMBER OF ENTRIES TO ALLOCATE
;
SETALC:	MOV	.PNUMB,$UALL
	RETURN
;
; CONVERT PPN TO RAD-50	FILE NAME
;
MAKUIC:	TSTB	$UUIC+1		; UIC MUST BE LIMITED TO BYTE VALUES
	BNE	SYNTAX		
	TSTB	$UUIC+3		; UIC MUST BE LIMITED TO BYTE VALUES
	BNE	SYNTAX
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	MOV	R3,-(SP)
	MOV	#STRING,R2	; POINT	TO STRING BUFFER
	CLR	R3		; GET UIC (LOW BYTES OF	EACH HALF)
	BISB	$UUIC+2,R3
	SWAB	R3
	BISB	$UUIC,R3
	MOV	#3,R4		; REQUEST NO PUNCTUATION, LEADING ZERS
	CALL	.PPASC		; CONVERT UIC TO ASCII
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	BR	R50
;
; CONVERT NAME TO RAD-50
;
MAKER5:	MOV	R5,-(SP)
	MOV	.PSTPT,R0	; GET ADDRESS OF NAME STRING
	MOV	.PSTCN,R1	; AND COUNT
	ADD	R1,$NAMEL	; ACCUMULATE DIRECTORY LENGTH
	INC	$NAMEL
	CMP	$NAMEL,#60.	; LIMIT IS 60 CHARACTERS
	BLOS	20$
	JMP	NAMLEN
20$:	MOV	#STRING,R2	; POINT TO STRING BUFFER
30$:	MOVB	(R0)+,(R2)+	; COPY	STRING INTO ZERO FILLED	BUFFER
	SOB	R1,30$

R50:	CMP	R2,#STRING+9.	; CHECK LENGTH	OF NAME	STRING
	BHI	SYNTAX		; LIMITED TO 9	CHARACTERS
	CLRB	(R2)+		; ZERO	PAD THE	STRING
	CLRB	(R2)+
	CLRB	(R2)+
	MOV	$NAMEP,R5	; POINT TO NAME BLOCK
	CMP	$NAMEC,#8.	; CHECK COUNT OF NAMES	SO FAR
	BLO	40$
	JMP	NAMLEV
40$:	MOV	#STRING,R0	; CHECK COUNT OF NAMES	SO FAR
	CALL	$CAT5		; CONVERT TO RAD-50
	MOV	R1,(R5)+	; PUT IN NAME
	CALL	$CAT5		; GET 2ND RAD-50 WORD
	MOV	R1,(R5)+
	CALL	$CAT5		; GET 3RD RAD-50 WORD
	MOV	R1,(R5)+
	MOV	R5,$NAMEP	; SET UP FOR NEXT NAME
	MOV	(SP)+,R5
	INC	$NAMEC
	RETURN
;
; SET PERMISSIONS
; INITIALIZE
;
IGROUP:	MOV	#4,GRCNT
;
; MOVE TO NEXT PERMISSIONS CATEGORY
;
NXGRP:	SEC			; FORCE ONES
	ROR	$UPRO
	ASR	$UPRO		; SHIFT TO NEXT GROUP
	ASR	$UPRO
	ASR	$UPRO
	DEC	GRCNT		; COUNT GROUPS
	BLT	SYNTAX		; TOO MANY IS AN ERROR
	RETURN
;
; SET READ PERMIT
;
SETRP:	BIC	#FP.RDV*10000,$UPRO
	RETURN
;
; SET WRITE PERMIT
;
SETWP:	BIC	#FP.WRV*10000,$UPRO
	RETURN
;
; SET EXTEND PERMIT
;
SETEP:	BIC	#FP.EXT*10000,$UPRO
	RETURN
;
; SET DELETE PERMIT
;
SETDP:	BIC	#FP.DEL*10000,$UPRO
	RETURN
;
; END OF PROTECTION SPEC
;
ENDGRP:	TST	GRCNT		; CHECK THE GROUP COUNT
	BNE	SYNTAX		; MUST HAVE 4
	RETURN

	.END
