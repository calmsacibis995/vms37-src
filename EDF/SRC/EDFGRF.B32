%TITLE 'EDF$GRAPH plotting module'
MODULE EDF$GRAPH (
		  IDENT = 'V03-000',
		  ADDRESSING_MODE ( EXTERNAL    = GENERAL,
    				    NONEXTERNAL = GENERAL )
		 )  =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY: VAX-11 RMS EDIT/FDL
!
! ABSTRACT:
!
!
! ENVIRONMENT:  VMS V3A
!
!
!--
!
! AUTHOR:  Tamar Krichevsky	, CREATION DATE: 31-JUL-81
!
! MODIFIED BY:
!
!**

!
! TABLE OF CONTNETS
!

FORWARD ROUTINE
    EDF$GRAPH	      : NOVALUE,	!Driver for the plot routines
    GET_GRAPH_INFO    : NOVALUE,       	!Determines plot characteristics 
    PLOT_LINE_GRAPH   : NOVALUE,	!Plots a simple graph (line graph)
    MOVE_LINE_GRAPH   : NOVALUE, 	!Changes the shape of a simple graph
    PLOT_SURFACE_GRAPH: NOVALUE,	!Plots a tabular graph (surface plot)
    ERASE_PAGE	      : NOVALUE,	!Erases a screen
    DRAW_Y_AXIS	      : NOVALUE,	!Draws the y-axis line
    LABEL_Y_AXIS      : NOVALUE,	!Puts the y-axis descriptive labels out
    PUT_ROW_SEGMENT   : NOVALUE,	!Put a segment of a graph's row to the terminal
    MOVE_CURSOR_REGIS : NOVALUE,	!Position the cursor (REGIS terminals)
    PUT_REGIS_TEXT    : NOVALUE,	!Build and put a REGIS text command
    SHADE_ROW_REGIS   : NOVALUE,	!Shade a segment of the graph -- VT125
    DRAW_BARS_REGIS   : NOVALUE,	!Draw the bars for the VT125 line graph
    DRAW_X_AXIS       : NOVALUE		!Format x-axis lablels
    ;


!
! INCLUDE FILES
!


LIBRARY
    'SYS$LIBRARY:STARLET.L32'
    ;


!
! MACROS
!

MACRO
    DSC$L_U1 = 32, 0, 32, 0 %,	!Field in the array descriptor for the first 
    				!dimension's upper bound
    DSC$L_U2 = 40, 0, 32, 0 %,	!Field in the array descriptor for the second
    				!dimension's upper bound


    !Translate the given value into ASCII.
    TRANSLATE_VALUE ( CTRSTR_ADR, RESULT_LEN, DESC_ADR, PARAM_LIST) =
	BEGIN
	LOCAL  RTN_STATUS;	!Return status from $FAOL system service
	!Translate, and if not successful, then signal the error.
	IF NOT ( RTN_STATUS = $FAOL( CTRSTR = CTRSTR_ADR,
				     OUTLEN = RESULT_LEN,
				     OUTBUF = DESC_ADR,
				     PRMLST = PARAM_LIST ))
	THEN
	    SIGNAL( .RTN_STATUS );
	END
    %,


    !Put the given text to reqested location on the screen.
    PUT_TEXT( DESC_ADR, ROW, COLUMN ) =
	BEGIN
	LOCAL RTN_STATUS;	!Return status from RTL call
	IF NOT ( RTN_STATUS = LIB$PUT_SCREEN( DESC_ADR, 
					      ROW,
					      COLUMN
					     ))
	THEN
	    SIGNAL( .RTN_STATUS );
	END
    %,


    !Put the given text to the terminal; let REGIS position it.
    PUT_REGIS( DESC_ADR ) =
	BEGIN
	LOCAL RTN_STATUS;	!Return status from RTL call
	IF NOT ( RTN_STATUS = LIB$PUT_OUTPUT( DESC_ADR ))
	THEN
	    SIGNAL( .RTN_STATUS );
	END
    %

;


!
! EQUATED SYMBOLS
!

LITERAL
    TRUE		= 1,
    FALSE		= 0,
    SUCCESS		= 1,
    FAILURE		= 0,
    ALL_BITS_SET	= 255,	!Unsigned -1, used for comparisons
    FULLWORD		= 4,	!Number of bytes in a BLISS-32 fullword
    QUAD		= 8,	!Size of a quad word -- for declarations
    NULL		= 	!Longword of null characters
			  %CHAR(0,0,0,0)
    ;

LITERAL
    INVALID_GRAPH_CODE  = 100,	!Signal arguement - graph code is off the wall
    INVALID_LABEL	= 101,	!Signal arguement - y-axis label is too long
    FIRST_ROW		= 1,	!Position on screen of first row
    FIRST_COLUMN	= 1,	!Position on screen of first column

    NO_LAST_INDEX	= -1,	!LAST_INDEX value -- signals that graph is to
    				!be drawn with axes (as opposed to moved)
    NO_VALUE		= -1,	!Signals that or y of the pixel address is to 
    				!be left out (i.e. - [,y] or [x,] )

    MAX_PAGE_WIDTH	= 132,	!Maximum number of columns on a page
    SCREEN_BUFFER_SIZE  = 512,	!Size of buffer for formatting graphs
    MAX_BUCKET_SIZE	= 32,	!Maximum number of block a bucket can contain
    SURFACE_GRAPH_LEN	= 19,	!Maximum number of rows in a tabular graph
    LINE_GRAPH_LEN	= 10,	!Maximum number of rows in a line graph
    SEPARATOR_WIDTH	= 2,	!Number columns a plotted value occupies 
    HEADER_HIEGHT	= 3,	!Number of lines in the x-axis header

    GRF$_LINE		=  0,	!Code for line  graph
    GRF$_SRF_INCREASING =  1,   !Code for surface graphs with increasing values
    GRF$_SRF_DECREASING =  2,	!Code for surface graphs with decreasing values
    GRF$_REGIS_POS	=  0,	!Code for position command
    GRF$_REGIS_VCTR	=  1,	!Code for vector command
    GRF$_REGIS_SHADE	=  2,	!Code for shaded vector command

    CHAR_WIDTH		=  9,	!Width, in pixels,  of a text-character cell
    CHAR_HEIGHT		= 15,	!Height, in pixels, of a text_character cell
    UNIT_WIDTH		= 18,	!Width, in pixels, of a column
    UNIT_HEIGHT		= 18,	!Height, in pixels, of a row
    RIGHT_SIDE_LOC	= 767,	!Right most pixel address
    BOTTOM_LOC		= 479,	!Bottom most pixel address
    AXIS_SHIFT		= 5,	!Number of pixels from origin axes are located
    BACKGROUND_INTENSITY= '0',	!Code for background intensity
    LIGHT_INTENSITY	= '3',	!Code for light color (green on color monitor)
    MEDIUM_INTENSITY	= '2',	!Code for medium color (yellow)
    DARK_INTENSITY	= '1',	!code for dark color (red)
    				!Location of graph's x-origin on a VT125
    X_ORIGIN		= RIGHT_SIDE_LOC - (UNIT_WIDTH * MAX_BUCKET_SIZE)
    ;

BIND
    REGIS_SET_UP = %ASCID %STRING(
	    				!Set terminal into REGIS mode
    		 	   %CHAR(27),'Pp',
			    		!Set default screen characteristics
			   'S[0,0] (A[0,0] [767,479], I(d), S1)',
			    		!Set default writing characteristics
			   'W(V, I(w), F3, M1, N0, P1, P(M2), S0)'
    			  ),

    					!Change output color map to RED, YELLOW
    					!and GREEN colors to signify good, fair
    					!poor regions of the surface graph.OP
    COLOR_SET_RYG = %ASCID %STRING(
			   'S( M0 (l0)   (a      l0)',	    ! background, black
			   '   M1 (l35)  (a h120 l30 s30)', ! dark RED
			   '   M2 (l65)  (a h150 l70 s50)', ! medium YELLOW
			   '   M3 (l100) (a h240 l35 s30))' ! light GREEN
			 ),

			    		!Change output color mapping to a 
			    		!more pleasing set of colors
    COLOR_SET_BLUE = %ASCID %STRING(
			   'S( M0 (l0)   (a      l0)',	    ! background, black
			   '   M1 (l35)  (a h5   l30 s20)', ! dark blue
			   '   M2 (l65)  (a h325 l60 s60)', ! medium blue
			   '   M3 (l100) (a h245 l80 s10))' ! light blue
			 ),


    REGIS_ON    =			!Set terminal into REGIS mode
    		  %ASCID %STRING(  %CHAR(27),'Pp' ),

    REGIS_OFF	= 			!Turn off regis mode
    		  %ASCID %STRING( %CHAR(27), '\' )
    ;

!
! Structure declarations used for system defined structures to
! save typing.  These structures are byte sized.
!

STRUCTURE
    BBLOCK [O, P, S, E; N] =
	[N]
	(BBLOCK+O)<P,S,E>,

    BBLOCKVECTOR [I, O, P, S, E; N, BS] =
	[N*BS]
	((BBLOCKVECTOR+I*BS)+O)<P,S,E>,

    TWO_DIM_ARRAY[ ROW, COL, DESC_ADR; S, E ] =
	[ 0 ]
	    BEGIN
	    LOCAL DESC_ADR_LCL : REF BBLOCK;

	    DESC_ADR_LCL = DESC_ADR;
	    (.DESC_ADR_LCL[ DSC$A_POINTER ] + 
		( ROW * .DESC_ADR_LCL[ DSC$L_M2 ] + COL ) * %UPVAL)<0, S, E>
	    END
	;

!
! OWN STORAGE
!

OWN
    !The following information is needed each time EDF$GRAPH is entered.
    !Therefore, it is maintained across calls.
    DEVICE_TYPE	 : BYTE INITIAL( ALL_BITS_SET ),!Type of terminal for this session
    DEVICE_FLAGS : BLOCK[ 1 ],			!DEC supported terminal
    Y_AXIS_LINE 				!Column on which y-axis falls
    ;

!
! EXTERNAL REFERENCES
!
EXTERNAL LITERAL
    EDF$_INTSWERR			!Message code for internal software
    ;  					!error.  This value is used when 
    					!signalling a wrong graph code or 
    					!peculiar y-axis label.


EXTERNAL ROUTINE
    LIB$SCREEN_INFO,			!Retrieve terminal characteristics.
    LIB$SET_BUFFER,			!Set buffer mode on.
    LIB$ERASE_PAGE,			!Erase the screen. 
    LIB$PUT_SCREEN,			!Write output to screen.
    LIB$PUT_BUFFER,			!Set buffer mode off.
    LIB$PUT_OUTPUT			!Write a line of output to SYS$OUTPUT
    ;

%SBTTL 'EDF$GRAPH main routine'
GLOBAL ROUTINE EDF$GRAPH( GRAPH_TYPE, XY_ARRAY_DESC, CURRENT_INDEX, LAST_INDEX,
    			  Y_HIGH,     Y_LOW,         Y_INCR,	    
    			  Y_LABEL_DESC,		     SHADE_ARRAY_DESC
    			) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Determine the user's terminal type and characteristics.  Set up a 
!	buffer to hold the graph as it is being created.  Plot the requested
!	graph.  (Line, Surface)  Put the graph to the user's terminal.
!
!	If a line graph is requested and the last index (LAST_INDEX 
!	parameter) equals -1, then the plot will be drawn with the axes and
!	labels; if the previous index (LAST_INDEX) is 0 or greater, then
!	the graph will be "moved" -- only the inside of the graph will be
!	redrawn.  Should the user's terminal be something other than a 
!	DIGITAL supported video terminal, hard copy or foreign terminal,
!	the graph will always be completely replotted.
!
!
! FORMAL PARAMETERS:
!
!	GRAPH_TYPE	: one byte code which determines which type of graph
!    			  will be plotted on this code.
!	XY_ARRAY_DESC	: address of the array descriptor which points to the
!			  array containing the data to be plotted.
!	CURRENT_INDEX	: the current index on the y axsis of the array which
!			  contains the data for the requested line  graph.
!	Y_LOW, Y_HIGH, Y_INCR : the low, high and increment values for the y
!    			  axsis.
!	XY_ARRAY_DESC	: address of the array descriptor which points to the
!			  array containing the shading information for VT125
!			  surface plots.
!
!
! IMPLICIT INPUTS:
!
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!	DEVICE_TYPE  :  also returned by LIB$SCREEN_INFO.  If all bits are set,
!			then this is the first time EDF$GRAPH is being called.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None, unless an nonrecoverable condition is encountered.  EDF$GRAPH
!	will signal the condition for the caller to handle.
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

    MAP
	XY_ARRAY_DESC	 : REF BBLOCK,	!Descriptor for the data array
	SHADE_ARRAY_DESC : REF BBLOCK	!Descriptor for the shading array
        ;

    LOCAL
    	OLD_BUFFER,			!Address of previous screen buffer,
    					!if any existed -- otherwise, zero.
	RTN_STATUS,			!Status returned from external calls
	NEW_SURFACE_GRAPH : BYTE,	!Set if graph will be completely rewritten
    	XY_ARRAY	: 		!Array to hold the data to be plotted
	    REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],
    	SHADE_ARRAY	: 		!Array of shading information
	    REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],


	!This vector and its descriptor will be used to format the different
	!graphs, before they are written to the user's terminal.
    	!
	SCREEN_BUFFER	:		!Buffer for the output.
	    VECTOR[ SCREEN_BUFFER_SIZE, BYTE ],
	SCREEN_BUFFER_DESC :		!Descriptor for the buffer
	    BBLOCK[ DSC$K_Z_BLN ]
	;


    !Do we know what kind of terminal are we dealing with?
    !
    IF .DEVICE_TYPE EQLU ALL_BITS_SET
    THEN

	!This is the first time EDF$GRAPH has been called.  Determine the 
	!terminal type and check to make sure it is possible to write a 
	!plot to the terminal given its charateristics.
    	!
	GET_GRAPH_INFO();


    !Initialize the screen buffer's descriptor and then set buffer mode on
    !
    SCREEN_BUFFER_DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    SCREEN_BUFFER_DESC[ DSC$B_DTYPE ]	= DSC$K_DTYPE_Z;
    SCREEN_BUFFER_DESC[ DSC$W_LENGTH ]  = SCREEN_BUFFER_SIZE;
    SCREEN_BUFFER_DESC[ DSC$A_POINTER ] = SCREEN_BUFFER;


    !Prepare for putting graphs to the user's terminal.
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN

    	!Turn REGIS mode on and set up default screen characteristics.
    	!
    	PUT_REGIS( REGIS_SET_UP )

    ELSE

	!Set up bufferring for hard copy and ANSI terminals
	!
	IF NOT ( RTN_STATUS = LIB$SET_BUFFER( SCREEN_BUFFER_DESC, OLD_BUFFER ))
	THEN

	    !An error has occured while setting buffer mode.
	    !
	    SIGNAL( .RTN_STATUS );


    !Which kind of graph was requested?
    !
    SELECTONE ..GRAPH_TYPE OF
	SET

	!Line graph
	!
	[ GRF$_LINE ] :	
	    BEGIN
	    IF NOT .DEVICE_FLAGS[ SCR$V_REGIS ]
    			AND
    	      ..LAST_INDEX NEQU NO_LAST_INDEX 
    			AND 
    	       .DEVICE_FLAGS[ SCR$V_SCREEN ]
	    THEN

		!A line graph was plotted during the last call and the 
		!terminal is a video;  just the shape of the "curve" needs to 
		!be changed.
    		!
		MOVE_LINE_GRAPH( .XY_ARRAY_DESC, ..CURRENT_INDEX, ..LAST_INDEX)

	    ELSE

		!Either this is the first time for the graph or the user's
		!terminal is hard copy.  The whole graph must be redrawn.
    		!
		PLOT_LINE_GRAPH( .XY_ARRAY_DESC, ..CURRENT_INDEX, 
    				 .Y_LABEL_DESC, .SHADE_ARRAY_DESC );
	    END;

	!Surface graph
	!
	[ GRF$_SRF_INCREASING, GRF$_SRF_DECREASING ] :
	    BEGIN
	    IF ..LAST_INDEX NEQU NO_LAST_INDEX AND .DEVICE_FLAGS[ SCR$V_SCREEN ]
	    THEN 

		!The last graph which was plotted was the same type of surface
    		!graph.  Rewrite the contents of the surface graph and leave 
    		!the axes alone.
		!
    		NEW_SURFACE_GRAPH = FALSE

	    ELSE

	    	!Write a whole new surface graph, icluding the axes.
	    	!
	    	NEW_SURFACE_GRAPH = TRUE;

	    PLOT_SURFACE_GRAPH( ..GRAPH_TYPE, .XY_ARRAY_DESC,   ..Y_HIGH, 
	    		  	..Y_LOW,      ..Y_INCR,	        .Y_LABEL_DESC,
    				.NEW_SURFACE_GRAPH,     .SHADE_ARRAY_DESC
    			       );
	    END;


    	[ OTHERWISE ] :
    	    SIGNAL( EDF$_INTSWERR, 1, INVALID_GRAPH_CODE );

	TES
    ;


    !Clean up before exitting.
    !
    IF (NOT .DEVICE_FLAGS[ SCR$V_REGIS ])
    THEN
    	BEGIN    

	!Put graph to the terminal.
	!
	IF NOT (RTN_STATUS = LIB$PUT_BUFFER( OLD_BUFFER ))
	THEN
	    SIGNAL( .RTN_STATUS);
    	END
    ELSE

    	!Turn REGIS mode off
    	!
	PUT_REGIS( REGIS_OFF );

    RETURN;
END;					! End of routine EDF$GRAPH

%SBTTL 'Get the graph characteristics'
ROUTINE GET_GRAPH_INFO  : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Determine the terminal characteristics.  Determine the width of the
!	graph.  Set up any screen characteristics, if this is a terminal
!	which understands REGIS.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	Y_AXIS_LINE  :  column which contains the y-axis line.  This value
!			is only output for non-REGIS terminals.
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!	DEVICE_TYPE  :  also returned by LIB$SCREEN_INFO.  If all bits are set,
!			then this is the first time EDF$GRAPH is being called.
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	If the user's terminla understands REGIS, the screen defaults may be
!	altered.
!
!--

BEGIN

LITERAL
    SKINNY_LINE		= 80,
    FAT_LINE		= 132,
    WIDTH_BOUNDARY	= 100	!Minimum columns needed to format a wider graph
    ;

LOCAL
    RTN_STATUS,			!Return status from external calls
    LINE_WIDTH	    : WORD,	!Width of page for this session
    LINES_PER_PAGE  : WORD	!Number of lines per page on the terminal
    ;


    !Determine the terminal type and characteristics.
    !
    IF NOT ( RTN_STATUS = LIB$SCREEN_INFO( DEVICE_FLAGS,  DEVICE_TYPE, 
					   LINE_WIDTH,    LINES_PER_PAGE
					 ))
    THEN

	!An error has occured while obtaining the device information.
    	!
	SIGNAL( .RTN_STATUS );


    !If terminal understands REGIS, set up screen characteristics needed
    !for plotting the graphs.  Otherwise, position the y-axis line.
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
	Y_AXIS_LINE  = X_ORIGIN - AXIS_SHIFT

    ELSE

        !Determine where the y-axis line should be positioned. 
    	!
	IF  (.LINE_WIDTH LEQ WIDTH_BOUNDARY 
		    OR 
	    (NOT .DEVICE_FLAGS[ SCR$V_SCREEN ]))
	THEN

	    !Have the right most column of the graph fall on the right most 
    	    !column of the page.  If the user's terminal is a hard copy (bit 
    	    !zero clear in DEVICE_FLAGS), then have the y-axis line fall to 
    	    !the left -- to reduce the number of characters being printed.  
    	    !
	    Y_AXIS_LINE = SKINNY_LINE - 
			  ((MAX_BUCKET_SIZE + 1) * SEPARATOR_WIDTH) + 1
	ELSE

    	    !If the line is wide enough, then center the graph across the line.
    	    !
	    Y_AXIS_LINE = (FAT_LINE -
			  ((MAX_BUCKET_SIZE + 1) * SEPARATOR_WIDTH)) / 2;

    RETURN;
END;					! End of routine GET_GRAPH_INFO

%SBTTL 'Plot a line graph'
ROUTINE PLOT_LINE_GRAPH( XY_ARRAY_DESC, CURRENT_INDEX, Y_LABEL_DESC, 
    			 SHADE_ARRAY_DESC ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	For each row in the graph:  write the y-axis label and mark 
!	all x-values in the x,y pairs with the y-values which belong 
!	in this row.  Draw and label the x-axis.
!
!
! FORMAL PARAMETERS:
!
!	XY_ARRAY_DESC	:  address of the descriptor for the data array
!	CURRENT_INDEX	:  index of the "row" (first dimension) requested 
!			   for graphing
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	A line graph
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	Filling of SCREEN_BUFFER; adjusting the values in SCREEN_BUFFER_DESC.
!
!--

BEGIN

MAP
    XY_ARRAY_DESC : REF BBLOCK;	!Descriptor for the data array


LOCAL
    XY_ARRAY		: 		!Array to hold the data to be plotted
	    REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],
    RTN_STATUS,			!Status returned from external calls
    DIM2,			!Index for the array's second dimension
    ROW_LABEL,			!Label for y-axis value
    ROW_POS,			!Current row on graph
    COLUMN_POS,			!Column postion for output
    SEPARATOR_CHAR,		!Dummy arguement to PUT_ROW_SEGMENT
    CURRENT_VALUE,		!Current xy-value to be plotted
    REPEAT_COUNT		!Number of times current xy-value is in row
    ;


    !Erase the screen to give the graph a "clean slate".
    !
    ERASE_PAGE();


    !Set up colors for the graph.
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
    	PUT_REGIS( COLOR_SET_BLUE );


    !Draw and label the y-axis
    !
    DRAW_Y_AXIS( LINE_GRAPH_LEN, GRF$_LINE, NULL, NULL );
    LABEL_Y_AXIS( .Y_LABEL_DESC, LINE_GRAPH_LEN );


    !Create x-axis labels and put them to the screen
    !
    DRAW_X_AXIS( LINE_GRAPH_LEN );


    !Inititalize those variables needed to create the graph's "curve".
    !
    DIM2 	   = 0;
    SEPARATOR_CHAR = NULL;


    !For each row (y-value) in the graph:
    !
    INCR ROW_COUNT FROM 0 TO (LINE_GRAPH_LEN - 1)
    DO
	BEGIN

	!Determine which row is being written and what it's label is.
    	!
	ROW_POS   = .ROW_COUNT + 1;
        ROW_LABEL = LINE_GRAPH_LEN - .ROW_COUNT;


	!If there are more elements for this row of the xy-array and they have
    	!the correct value, then print their value.
    	!
	WHILE (.DIM2 LEQ .XY_ARRAY_DESC[ DSC$L_U2 ]
			AND
	       (.XY_ARRAY[ .CURRENT_INDEX,.DIM2,.XY_ARRAY_DESC ] GEQ .ROW_LABEL
    			OR
	       .XY_ARRAY[ .CURRENT_INDEX,.DIM2,.XY_ARRAY_DESC ] LEQ 0))
	DO
	    BEGIN

	    !Save the current xy-value for comparisons; determine the position
	    !in the row.
	    !
	    CURRENT_VALUE = .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC ];
	    COLUMN_POS	  = .DIM2;


	    !Compare the current value to all subsequent values in the row
	    !until a value which is not equal is encountered.  Keep a count
	    !of the equal values, so the right number can be printed in the 
	    !graph.
    	    !
	    DIM2 = .DIM2 + 1;
	    WHILE .DIM2 LEQ .XY_ARRAY_DESC[ DSC$L_U2 ]
    			AND
    		  (.CURRENT_VALUE EQL .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC ]
	    		OR
	          .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC] LEQ 0)
	    DO
		DIM2 = .DIM2 + 1;


	    !Calculate the number of equal values and write them out.
    	    !
	    REPEAT_COUNT = .DIM2 - .COLUMN_POS;

	    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
	    THEN
    		BEGIN
    		IF .CURRENT_VALUE GTR 0
    		THEN
    		    DRAW_BARS_REGIS( .ROW_POS, .COLUMN_POS, .REPEAT_COUNT );
    		END

	    ELSE
		PUT_ROW_SEGMENT( .CURRENT_VALUE, .REPEAT_COUNT,   .COLUMN_POS,
				 .ROW_POS, .SEPARATOR_CHAR, .CURRENT_INDEX,
				 .SHADE_ARRAY_DESC);

	    END;			!DIM2

    	END;    			!ROW_COUNT

END;					! End of routine PLOT_LINE_GRAPH

%SBTTL 'Move the curve on a line graph'
ROUTINE MOVE_LINE_GRAPH (XY_ARRAY_DESC, CURRENT_INDEX, LAST_INDEX ) : 
NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	MOVE_LINE_GRAPH changes the existing curve of the graph.
!	It checks each value in the current row of th xy-array against 
!	the appropriate value in the last row.  If there is a difference, 
!	the old value is erased and the new value is written out at the 
!	proper location.
!
! FORMAL PARAMETERS:
!
!	XY_ARRAY_DESC 	:  Address of xy-array descriptor
!	CURRENT_INDEX	:  Index of current row to be plotted, in xy-array
!	LAST_INDEX 	:  Index of last row to be plotted
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

MAP
    XY_ARRAY_DESC : REF BBLOCK;	!Descriptor for the data array

LITERAL
    CTRSTR_LEN = 4,		!Length of the control string
    LEN_FIELD  = 1		!Position of length field in the control string
    ;

LOCAL
    XY_ARRAY		: 		!Array to hold the data to be plotted
	    REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],
    ROW_POS,			!Current row on graph
    COLUMN_POS,			!Column postion for output
    BUFFER	       :	!Buffer for building the output
	VECTOR[ MAX_PAGE_WIDTH, BYTE ],
    DESC               :	!Descriptor for BUFFER
    	BBLOCK[ DSC$K_Z_BLN ]
    ;

BIND
    CTRSTR_DESC = %ASCID'!2UB'
    ;

    !Intialize variables
    !
    (BUFFER) 		  = '    ';
    DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    DESC[ DSC$B_DTYPE ]	  = DSC$K_DTYPE_Z;
    DESC[ DSC$A_POINTER ] = BUFFER;


    !For each value:
    INCR DIM2 FROM 0 TO .XY_ARRAY_DESC[ DSC$L_U2 ]
    DO

	!If the value at the current index is not equal to the value at the
	!old index, then the curve must be altered... erase the old value
	!and write the new one in the appropriate row.
    	!
	IF .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC ] 
	    	NEQ
	   .XY_ARRAY[ .LAST_INDEX, .DIM2, .XY_ARRAY_DESC ]
	THEN
	    BEGIN

	    !Erase the old value.
    	    !
	    INCR CHAR_POS FROM 0 TO ( SEPARATOR_WIDTH - 1 ) DO
		BUFFER[ .CHAR_POS ] = ' ';
	    DESC[ DSC$W_LENGTH ]    = SEPARATOR_WIDTH;


	    !Determine which row the value to be erased is in.
    	    !
	    IF .XY_ARRAY[ .LAST_INDEX, .DIM2, .XY_ARRAY_DESC ] GEQ LINE_GRAPH_LEN
    			OR
    	       .XY_ARRAY[ .LAST_INDEX, .DIM2, .XY_ARRAY_DESC ] LEQ 0
	    THEN
		ROW_POS = FIRST_ROW
	    ELSE
		ROW_POS = LINE_GRAPH_LEN - 
			  .XY_ARRAY[ .LAST_INDEX, .DIM2, .XY_ARRAY_DESC ] + 1;


	    !Which column does it reside in?
    	    !
	    COLUMN_POS  = (.DIM2 + 1) * SEPARATOR_WIDTH + .Y_AXIS_LINE;


	    !Write over the old value with blanks.
    	    !
	    PUT_TEXT( DESC, ROW_POS, COLUMN_POS );


	    !Translate the new value to be placed on the curve.
    	    !
	    IF .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC ] LEQ 0
	    THEN

		BEGIN
	    	(BUFFER[ 0 ])        = '  ';
		DESC[ DSC$W_LENGTH ] = SEPARATOR_WIDTH;
		END

	    ELSE
		TRANSLATE_VALUE( CTRSTR_DESC,  DESC[ DSC$W_LENGTH ], DESC,
				 XY_ARRAY[ .CURRENT_INDEX, .DIM2,
	    				   .XY_ARRAY_DESC ]);

	    
	    !Determine which row the value to be written should be in.
    	    !
	    IF .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC ] GEQ LINE_GRAPH_LEN
	    		OR
	       .XY_ARRAY[ .CURRENT_INDEX, .DIM2, .XY_ARRAY_DESC ] LEQ 0
	    THEN
		ROW_POS = FIRST_ROW
	    ELSE
		ROW_POS = LINE_GRAPH_LEN - 
			  .XY_ARRAY[ .CURRENT_INDEX,.DIM2,.XY_ARRAY_DESC ] + 1;


	    !Write over the old value with blanks.
    	    !
	    PUT_TEXT( DESC, ROW_POS, COLUMN_POS );
	    END;
END;					! End of routine MOVE_LINE_GRAPH

%SBTTL 'Create a surface graph'
ROUTINE PLOT_SURFACE_GRAPH( GRAPH_TYPE, XY_ARRAY_DESC, Y_HIGH, Y_LOW, Y_INCR,
	    	            Y_LABEL_DESC, NEW_SURFACE_GRAPH, SHADE_ARRAY_DESC )
    : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	PLOT_SURFACE_GRAPH produces a "table" from the xy-array.  For each 
!	row in the array, each value in the row is printed.  If the terminal
!	understands REGIS, then shade the background.
!
! FORMAL PARAMETERS:
!
!	GRAPH_TYPE	:  type of table being produced (increasing or 
!    			   decreasing values
!	XY_ARRAY_DESC	:  address of xy-array descriptor
!	Y_HIGH		:  high value of y-axis numeric label
!	Y_LOW		:  low value of numeric label
!	Y_INCR 		:  increment of numeric labels
!	NEW_SURFACE_GRAPH :  set if complete new graph will be written
!	SHADE_ARRAY_DESC  :  Descriptor for array containing shading info
!
! IMPLICIT INPUTS:
!
!	Y_AXIS_LINE  :  column which contains the y-axis line.  This value
!			is considered for non-REGIS terminals only.
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!
! IMPLICIT OUTPUTS:
!
!	Y_AXIS_LINE  :  column which contains the y-axis line.  This value
!			is only output for REGIS terminals.
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

MAP
    XY_ARRAY_DESC : REF BBLOCK;	!Descriptor for the data array


LOCAL
    XY_ARRAY		: 		!Array to hold the data to be plotted
	    REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],
    SEPARATOR_CHAR	: WORD,	!Character for visually separating bands of values
    RTN_STATUS,			!Status returned from external calls
    MAX_ROWS,			!Number of rows in the surface graph
    DIM1,			!Index for first dimension of xy-array
    DIM2,			!Index for second dimension of xy-array
    ROW_LABEL,			!Label for y-axis value
    CURRENT_VALUE,		!Current value in row, for comparisons
    REPEAT_COUNT,		!Number of values equal to current value
    ROW_POS,			!Current row on graph
    COLUMN_POS			!Column postion for output
    ;

    !Determine the number of rows in the graph.
    !
    IF SURFACE_GRAPH_LEN LEQ ((.Y_HIGH - .Y_LOW) / .Y_INCR)
    THEN
    	MAX_ROWS = SURFACE_GRAPH_LEN - 1
    ELSE
    	MAX_ROWS = ((.Y_HIGH - .Y_LOW) / .Y_INCR);


    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
    	BEGIN

    	!Choose separator character.  Set up colors for this graph.
    	!
    	SEPARATOR_CHAR = NULL;
	PUT_REGIS( COLOR_SET_RYG );
	END

    ELSE

	!Choose the appropriate separator character
	!
	IF .GRAPH_TYPE EQL GRF$_SRF_DECREASING
	THEN
	    SEPARATOR_CHAR = '\'
	ELSE
	    SEPARATOR_CHAR = '/';


    IF .NEW_SURFACE_GRAPH
    THEN
	BEGIN

	!Erase the screen to give the graph a "clean slate".
	!
    	ERASE_PAGE();


    	!Draw and label the y-axis
    	!
	DRAW_Y_AXIS( .MAX_ROWS+1, .GRAPH_TYPE, .Y_HIGH, .Y_INCR );
    	LABEL_Y_AXIS( .Y_LABEL_DESC, .MAX_ROWS+1 );


	!Draw and label the x-axis
	!
	DRAW_X_AXIS( .MAX_ROWS+1 );
	END;


    !For each row:
    !
    INCR DIM1 FROM 0 TO  .MAX_ROWS 
    DO
	BEGIN

	!Reinitialize values for this row. If terminal understands regis,
	!move the cursor to the beginning of the this row.  Shade the row
    	!according to the information passed in the shade array.
    	!
	ROW_POS = .MAX_ROWS - .DIM1 + 1;
    	IF .DEVICE_FLAGS[ SCR$V_REGIS ]
	THEN
    	    BEGIN
	    MOVE_CURSOR_REGIS( GRF$_REGIS_POS, X_ORIGIN, 
    			       (.ROW_POS - 1) * UNIT_HEIGHT,
    			       NO_VALUE, NO_VALUE );
    	    SHADE_ROW_REGIS( .DIM1, (.ROW_POS * UNIT_HEIGHT), .SHADE_ARRAY_DESC);
	    MOVE_CURSOR_REGIS( GRF$_REGIS_POS, X_ORIGIN, 
    			       (.ROW_POS - 1) * UNIT_HEIGHT + 1,
    			       NO_VALUE, NO_VALUE );
    	    END;



	!For each element in the row:
    	!
	DIM2 = 0;
	WHILE .DIM2 LEQ .XY_ARRAY_DESC[ DSC$L_U2 ]
	DO 
	    BEGIN

	    !Save the current xy-value for comparisons; determine the position
	    !in the row.
	    !
	    CURRENT_VALUE = .XY_ARRAY[ .DIM1, .DIM2, .XY_ARRAY_DESC ];
	    COLUMN_POS	  = .DIM2;


	    !Compare the current value to all subsequent values in the row
	    !until a value which is not equal is encountered.  Keep a count
	    !of the equal values, so the right number can be printed in the 
	    !graph.
    	    !
	    DIM2 = .DIM2 + 1;
	    WHILE .DIM2 LEQ .XY_ARRAY_DESC[ DSC$L_U2 ]
    			AND
    		  (.CURRENT_VALUE EQL .XY_ARRAY[ .DIM1, .DIM2, .XY_ARRAY_DESC ]
	    		OR
	           .XY_ARRAY[ .DIM1, .DIM2, .XY_ARRAY_DESC] LEQ 0 )
	    DO
		DIM2 = .DIM2 + 1;


	    !Calculate the number of equal values and write them out.
    	    !
	    REPEAT_COUNT = .DIM2 - .COLUMN_POS;
	    PUT_ROW_SEGMENT( .CURRENT_VALUE, .REPEAT_COUNT, .COLUMN_POS,
	    		     .ROW_POS,	     .SEPARATOR_CHAR, .DIM1,
			     .SHADE_ARRAY_DESC);

	    END;			!DIM2
	END;				!ROW_COUNT


END;					! End of routine PLOT_SURFACE_GRAPH

%SBTTL 'Erase the screen or page'
ROUTINE ERASE_PAGE : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Starting in the first row and column erase the page.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

LOCAL
    RTN_STATUS,			!Status returned from RTL call
    ROW_POS,			!Row to start erasing from
    COLUMN_POS			!Column to start erasing from
    ;

    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN

    	!Erase screen using REGIS command.
    	!
    	PUT_REGIS( %ASCID 'S(e)' )

    ELSE
    	BEGIN

	!Erase the screen to give the graph a "clean slate".
	!
	ROW_POS    = FIRST_ROW;
	COLUMN_POS = FIRST_COLUMN;
	IF NOT ( RTN_STATUS = LIB$ERASE_PAGE( ROW_POS, COLUMN_POS ))
	    THEN

	    !An error has occured while erasing the page.
	    !
	    SIGNAL( .RTN_STATUS );

    	END;

    RETURN;
END;					! End of routine ERASE_PAGE


%SBTTL 'Draw y-axis for surface graph'
ROUTINE DRAW_Y_AXIS ( GRAPH_LEN, GRAPH_TYPE, Y_HIGH, Y_INCR ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	DRAW_Y_AXIS draws the y-axis line and writes the numeric labels.
!
! FORMAL PARAMETERS:
!
!	GRAPH_LEN	:  number of rows in the graph
!	GRAPH_TYPE	:  type of graph being drawn
!	Y_HIGH		:  high value for y-axis numeric labels
!	Y_INCR		:  increment for y-axis numeric labels
!
! IMPLICIT INPUTS:
!
!	Y_AXIS_LINE  :  column which contains the y-axis line.  
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	Output to the terminal
!
!--

BEGIN

LOCAL
    ROW_POS,				!Row where label is to be placed
    COLUMN_POS,				!Column in which the label starts
    ROW_LABEL,				!Numeric label for y-axis
    X_AXIS_LINE,			!Location of x-axis line
    CTRSTR_DESC,			!Address of control string 
    BUFFER	       :		!Buffer for building the output
	VECTOR[ MAX_PAGE_WIDTH, BYTE ],
    DESC               :		!Descriptor for BUFFER
    	BBLOCK[ DSC$K_Z_BLN ]
    ;

BIND
    CTRSTR_DESC1 = %ASCID'!2UB',
    CTRSTR_DESC2 = %ASCID'!UL'
    ;

    !Inititalize variables
    !
    (BUFFER)		  = '    ';
    DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    DESC[ DSC$B_DTYPE ]	  = DSC$K_DTYPE_Z;
    DESC[ DSC$A_POINTER ] = BUFFER;

    IF .GRAPH_TYPE EQL GRF$_LINE
    THEN
    	CTRSTR_DESC = CTRSTR_DESC1
    ELSE
    	CTRSTR_DESC = CTRSTR_DESC2;


    !If this is a regis terminal, draw the axis line
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
	BEGIN

    	!Position the cursor at the begining of the vector.
    	!
	MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .Y_AXIS_LINE, FIRST_ROW, 
    			   NO_VALUE, NO_VALUE );

    	!Draw a vector finishing at the the x-axis line.
    	!
	X_AXIS_LINE = UNIT_HEIGHT * (.GRAPH_LEN ) + AXIS_SHIFT;
	MOVE_CURSOR_REGIS( GRF$_REGIS_VCTR, NO_VALUE, .X_AXIS_LINE, 
    			   NO_VALUE, NO_VALUE );
	END;


    !For each row of the graph:
    !
    INCR ROW_COUNT FROM 0 TO .GRAPH_LEN - 1
    DO
    	BEGIN

	!Initialize variables for this row
	!
    	DESC[ DSC$W_LENGTH ] = MAX_PAGE_WIDTH;
	ROW_POS = .ROW_COUNT + 1;

    	IF .GRAPH_TYPE EQL GRF$_LINE
	THEN
	    ROW_LABEL = .GRAPH_LEN - .ROW_COUNT
	ELSE
	    ROW_LABEL = .Y_HIGH - (.Y_INCR * .ROW_COUNT);


	!If this is a line graph or an "even" row, put the numeric label along
	!the y-axis line.  This is for readability... too many numeric 
	!labels make it hard to read the graph.
	!
	IF .GRAPH_TYPE EQL GRF$_LINE
		OR
	(.ROW_COUNT MOD 2) EQL 0
	THEN
	    TRANSLATE_VALUE( .CTRSTR_DESC, DESC[ DSC$W_LENGTH ], DESC, ROW_LABEL )
	ELSE
	    DESC[ DSC$W_LENGTH ] = 0;


	!If this is the first label for the line graph, an "*" is really
	!desired to denote that the numbers in this row are large. Replace
    	!the numeric label with a "*".
	!
	IF .GRAPH_TYPE EQL GRF$_LINE AND .ROW_COUNT EQL 0
	THEN
	    BEGIN
	    (BUFFER)             = ' *';
	    DESC[ DSC$W_LENGTH ] = SEPARATOR_WIDTH;
	    END;


	!Determine column to start the string in and write it out.
	!
    	IF .DEVICE_FLAGS[ SCR$V_REGIS ] 
    	THEN
    	    BEGIN
	    COLUMN_POS = .Y_AXIS_LINE - (.DESC[ DSC$W_LENGTH ]+1) * CHAR_WIDTH;
	    MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, 
    			       (.ROW_POS - 1) * UNIT_HEIGHT + 1, 
       			       NO_VALUE, NO_VALUE );
	    PUT_REGIS_TEXT( DESC, LIGHT_INTENSITY );
    	    END

	ELSE
    	    BEGIN

	    !Add the y-axis line delimiter to the output string.
	    !
	    BUFFER[ .DESC[ DSC$W_LENGTH ] ] = '|';
	    DESC[ DSC$W_LENGTH ]	    = .DESC[ DSC$W_LENGTH ] + 1;

	    COLUMN_POS = .Y_AXIS_LINE - .DESC[ DSC$W_LENGTH ] + 1;
	    PUT_TEXT( DESC, ROW_POS, COLUMN_POS );
    	    END;

	END;
END;					! End of routine DRAW_Y_AXIS

%SBTTL 'Label the y-axis for a surface graph'
ROUTINE LABEL_Y_AXIS( Y_LABEL_DESC, GRAPH_LEN ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Draw the y-axis and write the numeric labels.
!
! FORMAL PARAMETERS:
!
!	Y_LABEL_DESC  :  Address of descriptor for descriptive labels
!	GRAPH_LEN     :  The number of rows in the graph
!
! IMPLICIT INPUTS:
!
!	Y_AXIS_LINE  :  column which contains the y-axis line.  
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

LITERAL
    LABEL_WIDTH = 15
    ;

LOCAL
    ROW_POS,				!Row where label is to be placed
    COLUMN_POS,				!Column in which the label starts
    STRING_LEN,				!Length of remaining string 
    STRING_START,			!Address of first character
    CURRENT_LEN,			!Length of remaining string
    WORD_START,				!Address of first character in word
    WORD_END,				!Address of last character in word
    WORD_COUNT,				!Number of words in label
    DESC               :		!Descriptor for output buffer
    	BBLOCK [ DSC$K_Z_BLN ]
    ;

MAP
    Y_LABEL_DESC       :		!Descriptor for y-axis labels
    	REF BBLOCK
    ;

    !Initialize variables
    !
    DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    DESC[ DSC$B_DTYPE ]	  = DSC$K_DTYPE_Z;
    STRING_LEN   = .Y_LABEL_DESC[ DSC$W_LENGTH ];
    CURRENT_LEN  = .STRING_LEN;
    STRING_START = .Y_LABEL_DESC[ DSC$A_POINTER ];
    WORD_START   = .STRING_START;
    WORD_END	 = .STRING_START;
    WORD_COUNT   = 0;


    !Count the number of words in the label
    !
    UNTIL .CURRENT_LEN GTRU .STRING_LEN 
    DO 
    	BEGIN

	!Find the start of the next word.
	!
	WORD_START  = CH$FIND_NOT_CH( .CURRENT_LEN, .WORD_END, ' ');
	CURRENT_LEN = .STRING_LEN - ( .WORD_START - .STRING_START );


	IF .WORD_START EQL 0
	THEN

	    !There are no more words in the string. Finish processing.
	    !  
    	    EXITLOOP;

    	!Find the end of the next word.
	!
	WORD_END    = CH$FIND_CH( .CURRENT_LEN, .WORD_START, ' ');
	CURRENT_LEN = .STRING_LEN - ( .WORD_END - .STRING_START );


    	IF (.WORD_END - .WORD_START + 1) GTR LABEL_WIDTH
    	THEN

	    !Word is too longer than the maximum width allowed (LABEL_WIDTH)
	    !
	    SIGNAL( EDF$_INTSWERR, 1, INVALID_LABEL );


	!Count the new word.
	WORD_COUNT = .WORD_COUNT + 1;
 	END;


    IF .WORD_COUNT GTR (.GRAPH_LEN / 2) OR .WORD_COUNT EQL 0
    THEN

	!There are more words than lines to write them on or there are none.
	!
	SIGNAL( EDF$_INTSWERR, 1, INVALID_LABEL );


    !Put the label to the screen.  Determine in which row and column the
    !first word of the label is to be positioned.
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ] 
    THEN
	COLUMN_POS = .Y_AXIS_LINE - ( LABEL_WIDTH  * CHAR_WIDTH )
    ELSE
    	COLUMN_POS = .Y_AXIS_LINE - LABEL_WIDTH;


    IF (.COLUMN_POS LSSU 1)
    THEN
	COLUMN_POS = 1;


    ROW_POS = (.GRAPH_LEN - .WORD_COUNT) / 2;
    IF NOT ((.ROW_POS MOD 2) EQL 0)
    THEN
	ROW_POS = .ROW_POS - 1;


    !Extract next word from string and print it in the proper place.
    !
    CURRENT_LEN = .Y_LABEL_DESC[ DSC$W_LENGTH ];
    WORD_START  = .STRING_START;
    WORD_END    = .STRING_START;


    DECR LOOP_INDEX FROM .WORD_COUNT TO 1 DO
    	BEGIN
	
	!Find the start of the next word.
	!
	WORD_START  = CH$FIND_NOT_CH( .CURRENT_LEN, .WORD_END, ' ');
	CURRENT_LEN = .STRING_LEN - ( .WORD_START - .STRING_START );


	!Find the end of the next word.
	!
	WORD_END    = CH$FIND_CH( .CURRENT_LEN, .WORD_START, ' ');
	CURRENT_LEN = .STRING_LEN - ( .WORD_END - .STRING_START );

	IF .WORD_END EQL 0
	THEN
	    WORD_END = .STRING_START + .Y_LABEL_DESC[ DSC$A_POINTER ];


	!Adjust Output buffer descriptor to point to the current word.
	!
	DESC[ DSC$W_LENGTH ]  = .WORD_END - .WORD_START;
	DESC[ DSC$A_POINTER ] = .WORD_START;


	!Write this part of the label on the graph and decide where next
	!word should be written.
	!
    	IF .DEVICE_FLAGS[ SCR$V_REGIS ] 
    	THEN
    	    BEGIN
	    MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, 
    			       (.ROW_POS - 1) * UNIT_HEIGHT, 
    			       NO_VALUE, NO_VALUE );
	    PUT_REGIS_TEXT( DESC, LIGHT_INTENSITY );
    	    END

	ELSE
	    PUT_TEXT( DESC, ROW_POS, COLUMN_POS );


	ROW_POS = .ROW_POS + 2;
	END;				!Print loop
END;					! End of routine LABEL_Y_AXIS

%SBTTL 'Write a portion of a graph'
ROUTINE PUT_ROW_SEGMENT( CURRENT_VALUE, REPEAT_COUNT,	COLUMN_POS, 
    			 ROW_POS,       SEPARATOR_CHAR, DIM1,
    			 SHADE_ARRAY_DESC ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	PUT_ROW_SEGMENT places a requested number of repetions of the current
!	value in a buffer and put the buffer to the terminal in the proper
!	place.
!
! FORMAL PARAMETERS:
!
!	CURRENT_VALUE   : Current value to be printed in the row segment
!    	REPEAT_COUNT	: Number of times the value is to be printed
!	COLUMN_POS	: Column in which row segment starts
!	ROW_POS		: Row in which row segment is to be written
!	SEPARATOR_CHAR	: Character used to delimit "good" section
!	DIM1		: Index into SHADE_ARRAY
!	SHADE_ARRAY_DESC: Descriptor for the array of shading information
!
! IMPLICIT INPUTS:
!
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	Output to the terminal.
!
!--

BEGIN

LITERAL
    TWO_DIGITS = 10		!First two digit number
    ;

LOCAL
    SHADE_ARRAY	       :	!Array containing shading values
    	REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],
    BUFFER	       :	!Buffer for building the output
	VECTOR[ MAX_PAGE_WIDTH, BYTE ],
    DESC               :	!Descriptor for BUFFER
    	BBLOCK[ DSC$K_Z_BLN ],
    REGION_FOUND       :  BYTE	!Flag -- set if we need to delimit "good" area
    ;

BIND
    CTRSTR_DESC = %ASCID'!2UB' 
    ;

    !Inititalize variables
    !
    (BUFFER)		  = '    ';
    DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    DESC[ DSC$B_DTYPE ]	  = DSC$K_DTYPE_Z;
    DESC[ DSC$A_POINTER ] = BUFFER;
    DESC[ DSC$W_LENGTH  ] = SEPARATOR_WIDTH;
    REGION_FOUND	  = FALSE;


    !If this is an invalid value, then use blanks to fill the row segment.
    !Otherwise, translate the value into ASCII.
    !
    IF .CURRENT_VALUE LEQ 0
    THEN
	(BUFFER) = '  '
    ELSE
    	TRANSLATE_VALUE( CTRSTR_DESC, DESC[ DSC$W_LENGTH ], DESC,
    			 CURRENT_VALUE );


    !If the start of this row segement is also the start of a "good" section,
    !then flag it so that the end of the "good" section can be looked for.
    !
    IF .SEPARATOR_CHAR NEQ NULL
		AND
       .CURRENT_VALUE LSS TWO_DIGITS
    		AND
       .SHADE_ARRAY[.DIM1, .COLUMN_POS, .SHADE_ARRAY_DESC] 
    	EQL (LIGHT_INTENSITY - '0')
    THEN
    	REGION_FOUND = TRUE;


    !For each repition of the value:
    !
    INCR LOOP_COUNT FROM 1 TO (.REPEAT_COUNT - 1)
    DO
	BEGIN

    	!Copy the ASCII value into the next available position in the buffer.
    	!
	CH$MOVE( SEPARATOR_WIDTH, BUFFER, 
    		 (BUFFER + (.LOOP_COUNT * SEPARATOR_WIDTH)));
	DESC[ DSC$W_LENGTH ] = .DESC[ DSC$W_LENGTH ] + SEPARATOR_WIDTH;


	!If the end of the "good" area is encountered, put in a delimiter.
	!
	IF .REGION_FOUND 
		AND
	   .SHADE_ARRAY[.DIM1, (.COLUMN_POS + .LOOP_COUNT), .SHADE_ARRAY_DESC]
	   NEQ (LIGHT_INTENSITY - '0')
	THEN
	    BEGIN
	    BUFFER[ .DESC[ DSC$W_LENGTH ] - 2 ] = .SEPARATOR_CHAR;
	    REGION_FOUND = FALSE;
	    END;

	END;


    !If this is the beginning or the end of the "good" area of the graph, 
    !place a visual separator in the front of the buffer.  If separator is 
    !more than one byte in length, this won't work -- it only moves one 
    !byte into the buffer at the specified position.
    !
    IF .SEPARATOR_CHAR NEQ NULL
		AND
       .CURRENT_VALUE LSS TWO_DIGITS
    		AND
       (.SHADE_ARRAY[.DIM1, .COLUMN_POS, .SHADE_ARRAY_DESC] 
    	EQL (LIGHT_INTENSITY - '0')
    		OR
       .SHADE_ARRAY[.DIM1, .COLUMN_POS - 1, .SHADE_ARRAY_DESC] 
    	EQL (LIGHT_INTENSITY - '0'))
    THEN
    	BUFFER[ 0 ] = .SEPARATOR_CHAR;


    !If the end of the "good" region has not been encountered, then assume
    !the region ends with the row segment. Put the separator at the end.
    !
    IF .REGION_FOUND
    THEN
	BEGIN
	BUFFER[ .DESC[DSC$W_LENGTH] ] = .SEPARATOR_CHAR;
	DESC[ DSC$W_LENGTH ] = .DESC[ DSC$W_LENGTH ] + 1;
	END;


    !Put the buffer out to the terminal.
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
    	PUT_REGIS_TEXT( DESC, BACKGROUND_INTENSITY )
    ELSE
	BEGIN
	COLUMN_POS = (.COLUMN_POS + 1) * SEPARATOR_WIDTH + .Y_AXIS_LINE;
        PUT_TEXT( DESC, ROW_POS, COLUMN_POS );
	END;

    RETURN;
END;					! End of routine PUT_ROW_SEGMENT

%SBTTL 'Position the cursor on a given pixel address'
ROUTINE MOVE_CURSOR_REGIS (COMMAND_TYPE, X_POS, Y_POS, INTENSITY, SHADE_LINE)
    	: NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!
!	MOVE_CURSOR_REGIS builds REGIS commands to move the cursor to a 
!	specified position, draw a vector from the current postion to a
!	another postion, or draw a vector with shading to a relative line.
!	Send the command to the terminal.
!
!	>>>NOTE: all pixel addresses are absolute, except the line to be
!		 shaded which is relative to the current postion.
!
! FORMAL PARAMETERS:
!
!	COMMAND_TYPE : code to indicate if a postion or vector command is
!		       being built
!	X_POS	     : x-value address of pixel
!	Y_POS	     : y-value address of pixel
!	INTENSITY    : intensity of the shaded area
!	SHADE_LINE   : relative pixel address of the shade line 
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

BIND
    POS_CMD_START  = UPLIT( 'P[' ),	!Command to move cursor
    COMMAND_MID    = UPLIT( ',' ),	!X and Y value separator
    COMMAND_END    = UPLIT( ']' ),	!Command terminator
    VCTR_CMD_START = UPLIT( 'V(W(I3))[][' ),	!Vector command start
    SHADE_CMD_1    = UPLIT( 'V(W (S1 S[,' ),	!First part of shade command
    SHADE_CMD_2    = UPLIT( '] I3))[][+' )	!Remainder of command start
    ;


LITERAL
    POS_CMD_START_LEN  = %CHARCOUNT( 'P[' ),
    CMD_MID_LEN	       = %CHARCOUNT( ',' ),
    CMD_END_LEN        = %CHARCOUNT( ']' ),
    VCTR_CMD_START_LEN = %CHARCOUNT( 'V(W(I3))[][ ' ),	
    SHADE_CMD_1_LEN    = %CHARCOUNT( 'V(W (S1 S[,' ),
    SHADE_CMD_2_LEN    = %CHARCOUNT( '] I3))[][+' ),
    INTENSITY_LOC      = 7		!Distance to intensity indicator from end
    ;


LOCAL
    TEMP_DESC : 			!Record temporary changes in buffer here
    	BBLOCK[ DSC$K_Z_BLN ]
    	INITIAL ( 0, 0 ),
    BUFFER    :				!Buffer to build REGIS command
    	VECTOR[ MAX_PAGE_WIDTH, BYTE ],
    DESC      :				!Descriptor for the buffer
    	BBLOCK[ DSC$K_Z_BLN ]
    ;

BIND
    CTRSTR = %ASCID '!UL'
    ;


    !Initialize descriptor
    !
    DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    DESC[ DSC$B_DTYPE ]	  = DSC$K_DTYPE_Z;
    DESC[ DSC$A_POINTER ] = BUFFER;


    !Place start of command string in buffer
    !
    SELECTONE .COMMAND_TYPE OF
    	SET

    	!Positon cursor
    	!
	[ GRF$_REGIS_POS ] :
	    BEGIN
	    CH$MOVE( POS_CMD_START_LEN, POS_CMD_START, BUFFER);
	    DESC[ DSC$W_LENGTH ] = POS_CMD_START_LEN;
	    END;

    	!Draw vector
    	!
	[ GRF$_REGIS_VCTR ] :
	    BEGIN
	    CH$MOVE( VCTR_CMD_START_LEN, VCTR_CMD_START, BUFFER);
	    DESC[ DSC$W_LENGTH ] = VCTR_CMD_START_LEN;
	    END;

    	!Draw a shaded vector
    	!
	[ GRF$_REGIS_SHADE ] :
	    BEGIN
	    CH$MOVE( SHADE_CMD_1_LEN, SHADE_CMD_1, BUFFER);
	    DESC[ DSC$W_LENGTH ] = SHADE_CMD_1_LEN;


	    !Translate shade line address into ASCII and place in command.
	    !
	    TEMP_DESC[ DSC$W_LENGTH ] = MAX_PAGE_WIDTH - .DESC[ DSC$W_LENGTH ];
	    TEMP_DESC[ DSC$A_POINTER ] = 
		            .DESC[ DSC$A_POINTER ] + .DESC[ DSC$W_LENGTH ];
	    TRANSLATE_VALUE( CTRSTR, TEMP_DESC[ DSC$W_LENGTH ], TEMP_DESC, 
    			    SHADE_LINE );
	    DESC[ DSC$W_LENGTH ] = 
    			    .DESC[ DSC$W_LENGTH ] + .TEMP_DESC[ DSC$W_LENGTH ];


	    CH$MOVE( SHADE_CMD_2_LEN, SHADE_CMD_2, 
    		     BUFFER[ .DESC[ DSC$W_LENGTH ]  ]);
	    DESC[ DSC$W_LENGTH ] = .DESC[ DSC$W_LENGTH ] + SHADE_CMD_2_LEN;


	    !Place desired intensity in command string.
	    !
    	    BUFFER[ .DESC[ DSC$W_LENGTH ] - INTENSITY_LOC ] = 
    			.INTENSITY;
	    END;
    	TES;


    !If there is an x value, translate it and put it in the command string.
    !
    IF .X_POS NEQ NO_VALUE
    THEN
	BEGIN

	TEMP_DESC[ DSC$W_LENGTH ]  = MAX_PAGE_WIDTH - .DESC[ DSC$W_LENGTH ];
	TEMP_DESC[ DSC$A_POINTER ] = 
		.DESC[ DSC$A_POINTER ] + .DESC[ DSC$W_LENGTH ];
	TRANSLATE_VALUE( CTRSTR, TEMP_DESC[ DSC$W_LENGTH ], TEMP_DESC, X_POS );
    	DESC[ DSC$W_LENGTH ]       =  
    		.DESC[ DSC$W_LENGTH ] + .TEMP_DESC[ DSC$W_LENGTH ];
	END;


    !Put comma in to separate x and y values.  If separator is more than one
    !byte this will not work!!!
    !
    BUFFER[ .DESC[ DSC$W_LENGTH ] ] = .COMMAND_MID;
    DESC[ DSC$W_LENGTH ]	    = .DESC[ DSC$W_LENGTH ] + CMD_MID_LEN;


    !If there is a y value, translate it and put it in the command string.
    !
    IF .Y_POS NEQ NO_VALUE
    THEN
	BEGIN

	TEMP_DESC[ DSC$W_LENGTH ]  = MAX_PAGE_WIDTH - .DESC[ DSC$W_LENGTH ];
	TEMP_DESC[ DSC$A_POINTER ] = 
		.DESC[ DSC$A_POINTER ] + .DESC[ DSC$W_LENGTH ];
	TRANSLATE_VALUE( CTRSTR, TEMP_DESC[ DSC$W_LENGTH ], TEMP_DESC, Y_POS );
    	DESC[ DSC$W_LENGTH ]       =  
    		.DESC[ DSC$W_LENGTH ] + .TEMP_DESC[ DSC$W_LENGTH ];
	END;


    !Finish command string.
    !
    BUFFER[ .DESC[ DSC$W_LENGTH ] ] = .COMMAND_END;
    DESC[ DSC$W_LENGTH ]	    = .DESC[ DSC$W_LENGTH ] + CMD_END_LEN;


    !Write the command string.
    !
    PUT_REGIS( DESC );


    RETURN;

END;					! End of routine MOVE_CURSOR_REGIS


%SBTTL 'Put REGIS text to the terminal'
ROUTINE PUT_REGIS_TEXT ( DESC, INTENSITY ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Build a REGIS text command and put it out.  This procedure assumes the
!	cursor is already at the desired position.
!
! FORMAL PARAMETERS:
!
!	DESC	  :  address of descriptor for test string to be put out
!	INTENSITY :  intensity at which text is to be written
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

MAP
    DESC : REF BBLOCK			!Descriptor for text to be output
    ;

BIND
    COMMAND_START = UPLIT( %STRING( 'T( W(i3))', %CHAR(39) )),
    COMMAND_END   = UPLIT( %STRING( %CHAR(39)) )
    ;

LITERAL
    CMD_START_LEN = %CHARCOUNT( %STRING( 'T( W(i3))', %CHAR(39) )),
    CMD_END_LEN	  = %CHARCOUNT( %STRING (%CHAR(39)) ),
    INTENSITY_LOC = 4
    ;

LOCAL
    CMD_BUFFER :			!Buffer to build REGIS command
    	VECTOR[ MAX_PAGE_WIDTH, BYTE ],
    CMD_DESC   :				!Descriptor for the buffer
    	BBLOCK[ DSC$K_Z_BLN ]
    ;


    !Initialize.
    !
    CMD_DESC[ DSC$B_CLASS ]   = DSC$K_CLASS_Z;
    CMD_DESC[ DSC$B_DTYPE ]   = DSC$K_DTYPE_Z;
    CMD_DESC[ DSC$A_POINTER ] = CMD_BUFFER;


    !Build start of command string.
    !
    CH$MOVE( CMD_START_LEN, COMMAND_START, CMD_BUFFER );
    CMD_DESC[ DSC$W_LENGTH ]  = CMD_START_LEN;
    CMD_BUFFER[ .CMD_DESC[DSC$W_LENGTH] - INTENSITY_LOC ] = .INTENSITY;


    !Copy text to be written into command buffer.
    !
    CH$MOVE( .DESC[ DSC$W_LENGTH ], .DESC[ DSC$A_POINTER ],
    	     	(CMD_BUFFER + .CMD_DESC[ DSC$W_LENGTH ] ));
    CMD_DESC[ DSC$W_LENGTH ] = 
    		.CMD_DESC[ DSC$W_LENGTH ] + .DESC[ DSC$W_LENGTH ];


    !Put command terminator at end of string. WARNING!!! If more than one
    !character is used as a terminator this won't work.  This only places one
    !byte in the buffer.
    !
    CMD_BUFFER[ .CMD_DESC[ DSC$W_LENGTH ] ] = .COMMAND_END;
    CMD_DESC[ DSC$W_LENGTH ] = .CMD_DESC[ DSC$W_LENGTH ] + CMD_END_LEN;
    

    !Write the command string out.
    !
    PUT_REGIS( CMD_DESC );


    RETURN;
END;					! End of routine PUT_REGIS_TEXT

%SBTTL 'Shade a row of the graph'
ROUTINE SHADE_ROW_REGIS ( DIM1, SHADE_LINE, SHADE_ARRAY_DESC ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Determine the length of the vector to be drawn, where the shading
!	line is to be located and the intesity of the shaded area.
!
! FORMAL PARAMETERS:
!
!	DIM1		: index for the current row of the shade array
!	SHADE_LINE	: realtive location of the shade line
!	SHADE_ARRAY_DESC: descriptor for the array of shading information
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

MAP
    SHADE_ARRAY_DESC : REF BBLOCK	!Descriptor for the shading array
    ;

LOCAL
    SHADE_ARRAY	  :		!Array of intesities for shading
    	REF TWO_DIM_ARRAY[ LONG, UNSIGNED ],
    DIM2,			!Index for second dimension of xy-array
    CURRENT_VALUE,		!Current value in row, for comparisons
    REPEAT_COUNT,		!Number of values equal to current value
    ROW_POS,			!Current row on graph
    COLUMN_POS,			!Column postion for output
    VECTOR_LEN			!Location of x-origin when working with a VT125
    ;



    !For each element in the row:
    !
    DIM2 = 0;
    WHILE .DIM2 LEQ .SHADE_ARRAY_DESC[ DSC$L_U2 ]
    DO 
	BEGIN

	!Save the current xy-value for comparisons; determine the position
	!in the row.
	!
	CURRENT_VALUE = .SHADE_ARRAY[ .DIM1, .DIM2, .SHADE_ARRAY_DESC ];
	COLUMN_POS	  = .DIM2;


	!Compare the current value to all subsequent values in the row
	!until a value which is not equal is encountered.  Keep a count
	!of the equal values, so the right number can be printed in the 
	!graph.
	!
	DIM2 = .DIM2 + 1;
	WHILE .DIM2 LEQ .SHADE_ARRAY_DESC[ DSC$L_U2 ]
		    AND
	      .CURRENT_VALUE EQL .SHADE_ARRAY[ .DIM1, .DIM2, .SHADE_ARRAY_DESC ]
	DO
	    DIM2 = .DIM2 + 1;


	!Calculate the number of equal values and draw a shade line of the
	!appropriate length (number-of-equal-values * unit-width).
	!
	REPEAT_COUNT = .DIM2 - .COLUMN_POS;
    	VECTOR_LEN   = .REPEAT_COUNT * UNIT_WIDTH;
    	MOVE_CURSOR_REGIS( GRF$_REGIS_SHADE, .VECTOR_LEN, NO_VALUE, 
    			   .CURRENT_VALUE + '0', .SHADE_LINE );

    END;			!DIM2
END;					! End of routine SHADE_ROW_REGIS

%SBTTL 'Draw a portion of the bar graph'
ROUTINE DRAW_BARS_REGIS ( Y_VALUE, X_VALUE, REPEAT_COUNT ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Draw the bars for the current row segment of the REGIS line graph.
!
! FORMAL PARAMETERS:
!
!	Y_VALUE	     :  The row in which contains the top of the bar.
!	X_VALUE      :  The first column of this row segment
!	REPEAT_COUNT :  The number of bars to be drawn
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

LITERAL
    BAR_GAP = 2			!Number of ixels between bars in hte graph
    ;

LOCAL
    ROW_POS,			!Y value for a pixel address
    COLUMN_POS,			!X value for a pixel address
    SHADE_LINE			!Line to which bar is shaded
    ;

    !Initialize values.
    !
    ROW_POS    = ( .Y_VALUE - 1 ) * UNIT_HEIGHT;
    COLUMN_POS = ( .X_VALUE * UNIT_WIDTH ) + X_ORIGIN + 1 ;
    SHADE_LINE = LINE_GRAPH_LEN * UNIT_HEIGHT;


    !Move the cursor to the starting postion.
    !
    MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, .ROW_POS, 
		      NO_VALUE, NO_VALUE );


    !For each bar in the line graph:
    !
    DECR LOOP_COUNT FROM (.REPEAT_COUNT - 1) TO 0
    DO
	BEGIN

	!Draw a vector; shade it to the bottom of the graph.
	!
	MOVE_CURSOR_REGIS( GRF$_REGIS_SHADE, (UNIT_WIDTH - BAR_GAP), NO_VALUE, 
			  DARK_INTENSITY, .SHADE_LINE );


	!Move the cursor over, to create spaces between the bars.
	!
	COLUMN_POS = .COLUMN_POS + UNIT_WIDTH;
	MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, NO_VALUE, 
    			   NO_VALUE, NO_VALUE );

	END;

END;					! End of routine DRAW_BARS_REGIS


%SBTTL 'Format the x-axis headers'
ROUTINE DRAW_X_AXIS ( GRAPH_LEN ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Draw the x-axis line and then write the x-axis numeric and
!	descriptive labels.  These are the same for all graphs.
!
! FORMAL PARAMETERS:
!
!	GRAPH_LEN	:  the number of rows in a the graph
!
! IMPLICIT INPUTS:
!
!	Y_AXIS_LINE  :  column which contains the y-axis line.  
!	DEVICE_FLAGS :	a longword of flags which are set or cleared by
!			LIB$SCREEN_INFO depending on the terminal 
!			characteristics.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

LITERAL
    INCR_VAL   = 5,		!The increment between x_value labels
    TWO_VALUES = 2		!For formatting last x-value label
    ;

LOCAL
    RTN_STATUS,			!Status returned from external calls
    ROW_POS,			!Row postion for output
    COLUMN_POS,			!Column postion for output
    ROW_INCR,			!Distance to next row
    COLUMN_INCR,		!Distance to next column
    Y_ORIGIN,			!Left most column in graph
    CHARACTER_WIDTH,		!Width of character, for calculations
    PLOT_WIDTH,			!The width of the current graph
    BUFFER	       :	!Buffer for building the output
	VECTOR[ MAX_PAGE_WIDTH, BYTE ],
    DESC               :	!Descriptor for BUFFER
    	BBLOCK[ DSC$K_Z_BLN ]
    ;

BIND
    				!Header for the x-axis
    X_AXIS_HEADER  = %ASCID'Bucket Size (number of blocks)',
    				!Numeric label for the x-axis
    X_AXIS_LABEL_N = PLIT ( %ASCID' 1',
    			    %ASCID' 5',
    			    %ASCID'10',
    			    %ASCID'15',
    			    %ASCID'20',
    			    %ASCID'25',
    			    %ASCID'30',
    			    %ASCID'32'
    			) : VECTOR,
    				!Formatting for the x-axis line
    AXIS_LINE	   = PLIT ( %ASCID'+- + - - - + - - - - + - - - - + - - - - + - - - - + - - - - + - +'
    			  ) : VECTOR;    			    

    !Initialize values for distance between rows and columns.  Draw x-axis
    !line.
    !
    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
	BEGIN


	!Initialize.
	!
	ROW_INCR    = 3;
	COLUMN_INCR = 0;
	Y_ORIGIN        = .Y_AXIS_LINE + AXIS_SHIFT;
	CHARACTER_WIDTH = CHAR_WIDTH;


	!Position x-axis line. Draw it.
    	!	
	ROW_POS    = UNIT_HEIGHT * ( .GRAPH_LEN ) + AXIS_SHIFT;
    	COLUMN_POS = .Y_AXIS_LINE;


    	MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, .ROW_POS );
    	COLUMN_POS = .Y_ORIGIN + ( MAX_BUCKET_SIZE * UNIT_WIDTH );
    	MOVE_CURSOR_REGIS( GRF$_REGIS_VCTR, .COLUMN_POS, NO_VALUE );
	END

    ELSE
	BEGIN

	!Initialize.
	!
	ROW_INCR    = 1;
	COLUMN_INCR = SEPARATOR_WIDTH;
	Y_ORIGIN        = .Y_AXIS_LINE;
	CHARACTER_WIDTH = 1;


	!Position x-axis line. Draw it.
	!
	ROW_POS    = .GRAPH_LEN + 1;
    	COLUMN_POS = .Y_ORIGIN;
	PUT_TEXT( .AXIS_LINE, ROW_POS, COLUMN_POS );
	END;


    !Move cursor to the beginning of the next row, put out first numeric label.
    !
    ROW_POS         = .ROW_POS + .ROW_INCR;
    COLUMN_POS      = .Y_ORIGIN + .COLUMN_INCR;


    IF .DEVICE_FLAGS[ SCR$V_REGIS ]
    THEN
	BEGIN
	MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, .ROW_POS );
	PUT_REGIS_TEXT( .X_AXIS_LABEL_N[ 0 ], LIGHT_INTENSITY );
	ROW_INCR    =  CHAR_HEIGHT + SEPARATOR_WIDTH;
	COLUMN_INCR =  UNIT_WIDTH;
	END

    ELSE
	PUT_TEXT ( .X_AXIS_LABEL_N[ 0 ], ROW_POS, COLUMN_POS );


    !For each subsequent numeric label: positon cursor and write the label.
    !
    INCR DESC_PTR FROM 1  TO (.(X_AXIS_LABEL_N - FULLWORD) - TWO_VALUES )
    DO

	BEGIN
	COLUMN_POS = .Y_ORIGIN + ( .COLUMN_INCR * INCR_VAL * .DESC_PTR );
	IF .DEVICE_FLAGS[ SCR$V_REGIS ] 
	THEN
	    BEGIN
    	    COLUMN_POS = .COLUMN_POS - UNIT_WIDTH;
	    MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, NO_VALUE);
	    PUT_REGIS_TEXT( .X_AXIS_LABEL_N[ .DESC_PTR ], LIGHT_INTENSITY );
	    END

	ELSE
	    PUT_TEXT( .X_AXIS_LABEL_N[ .DESC_PTR ], ROW_POS, COLUMN_POS );
	END;


    !Position and write the last numeric label.
    !
    COLUMN_POS = .COLUMN_POS + .COLUMN_INCR * TWO_VALUES;
    IF .DEVICE_FLAGS[ SCR$V_REGIS ] 
    THEN
	BEGIN
	MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, NO_VALUE );
	PUT_REGIS_TEXT( .X_AXIS_LABEL_N[ .(X_AXIS_LABEL_N - FULLWORD) - 1 ],
    			LIGHT_INTENSITY );
	END

    ELSE
	PUT_TEXT( .X_AXIS_LABEL_N[ .( X_AXIS_LABEL_N - FULLWORD ) - 1 ],
    	          ROW_POS, COLUMN_POS);


    !Put the descriptive labels out.
    !
    ROW_POS = .ROW_POS + .ROW_INCR;
    PLOT_WIDTH  = MAX_BUCKET_SIZE * .COLUMN_INCR;
    COLUMN_POS = (.PLOT_WIDTH - (.X_AXIS_HEADER<0,8> * .CHARACTER_WIDTH) )/2 
		 + .Y_ORIGIN;


    IF .DEVICE_FLAGS[ SCR$V_REGIS ] 
    THEN
	BEGIN
	MOVE_CURSOR_REGIS( GRF$_REGIS_POS, .COLUMN_POS, .ROW_POS );
	PUT_REGIS_TEXT( X_AXIS_HEADER, LIGHT_INTENSITY );
	END

    ELSE
	PUT_TEXT( X_AXIS_HEADER, ROW_POS, COLUMN_POS );

END;					! End of routine DRAW_X_AXIS

END
ELUDOM
