	.TITLE	ZIOSRV
	.IDENT	/V03000/

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
; WRITTEN BY
;	M. JACK
;
; MODULE FUNCTION
;	I/O SERVICES FOR THE TASK IMAGE PATCHING UTILITY
;


;+
;	GLOBAL DEFINITIONS
;-

	.MCALL	FSRSZ$,	FDBDF$,	FDAT$A,	FDRC$A,	FDBK$A,	FDOP$A,	NMBLK$
	.MCALL	GCMLB$,	GCML$,	READ$,	WRITE$,	WAIT$,	PUT$S,	FDOF$L
	.MCALL	FCSBT$,	NBOF$L,	GCMLD$,	CSI$,	CALL,	RETURN

CSIERR==8.			; ERROR IN FILE SPECIFICATION
OPNERR==9.			; OPEN FAILURE ON TASK FILE
CMIERR==10.			; ERROR ON COMMAND INPUT
TRNERR==11.			; TRANSMIT ERROR ON TASK FILE
SEGERR==15.			; SEGMENT TABLE OVERFLOW

SIGXIT==-1			; SIGNAL VALUE FOR EXIT

ABSOLU==1			; /AB SWITCH BIT
RDONLY==2			; /RO SWITCH BIT
LSTING==4			; /LI SWITCH BIT

	FDOF$L
	FCSBT$
	NBOF$L
	GCMLD$
	CSI$

	FSRSZ$	2

	.SBTTL	GLOBAL STORAGE


;+
;	FILE DESCRIPTOR BLOCK FOR TASK IMAGE
;-

TSKFDB::FDBDF$
	FDRC$A	FD.RWM
	FDBK$A	BLKBUF,512.
	FDOP$A	6,CSIBLK+C.DSDS,TSKDFN

TSKDFN:	NMBLK$	,EXE,,SY,0


;+
;	FILE DESCRIPTOR BLOCK FOR OUTPUT DEVICE
;-

OUTFDB::FDBDF$
	FDAT$A	R.VAR,FD.CR
	FDRC$A	,OUTBUF
	FDOP$A	2,,OUTDFN

OUTDFN:	NMBLK$	ZAP,CMO


;+
;	CONTROL BLOCK FOR GET COMMAND LINE
;-

CMLBLK::GCMLB$	1,ZAP

UNDSCO:	.ASCII	<15><12>"_"
UNDSCL=	.-UNDSCO
	.EVEN

CMLLEN==CMLBLK+G.CMLD
CMLADR==CMLBLK+G.CMLD+2


;+
;	CONTROL BLOCK FOR COMMAND STRING INTERPRETER
;-

CSIBLK::.BLKB	C.SIZE


;+
;	MISCELLANEOUS STORAGE
;-

STATBK::.BLKW	5		; STATISTICS BLOCK FOR OPEN
SAVRAT::.BLKB	S.FATT		; AREA TO SAVE FILE'S RECORD ATTRIBUTES
BLKBUF::.BLKW	256.		; BUFFER FOR TASK IMAGE BLOCK
OUTBUF::.BLKB	80.		; BUFFER FOR OUTPUT BLOCK
BLKNUM::.BLKW	2		; VBN OF TASK FILE
STKLIM::.WORD	200		; STACK OVERFLOW LIMIT(INITIAL VALUE)
WRITBK::.BLKW			; WRITE-BACK FLAG
OUTPTR::.WORD	OUTBUF		; CURRENT BYTE IN OUTBUF
SWITCH::.BLKW			; COMMAND-LEVEL SWITCH WORD
SEGTAB::.WORD	SGSTART		; SEGMENT TABLE BASE POINTER
SEGEND::.WORD	SGFIN		; SEGMENT TABLE END ADDRESS+1
TSKLIM::.LIMIT



;+
;	SEGMENT DESCRIPTOR TABLE
;	SIZE SET BY TKB EXTTSK= OR INSTALL INC=
;	MUST BE ROOM FOR AT LEAST ONE DESCRIPTOR (5 WORDS).
;
;-

	.PSECT	ZAPSG0
SGSTART:

	.PSECT	ZAPSG1
SGFIN:

	.PSECT


	.SBTTL	COMAND -- COMMAND INPUT

;+
;
; GLOBAL ROUTINE COMAND
;
; FUNCTION
;	READ A COMMAND
;
; INPUTS
;	LINE INPUT VIA GCML$
;
; OUTPUTS
;	CMLLEN	- LENGTH OF THE COMMAND IN BYTES
;	CMLADR	- BUFFER CONTAINING COMMAND STRING IN ASCII
;	VALUE	- NONE
;
;-

COMAND::
	GCML$	#CMLBLK,#UNDSCO,#UNDSCL	; PROMPT FOR A COMMAND
	BCC	2$		; CONTINUE IF NO ERRORS
	CMPB	#GE.EOF,G.ERR(R0) ; CHECK FOR END OF FILE
	BEQ	1$		; CONTINUE IF IT IS EOF
	MOV	#CMIERR,R0	; ANOTHER ERROR - TERMINATE
	BR	ERROR		;
1$:	MOV	#1,CMLLEN	; FAKE AN "X" COMMAND ON EOF
	MOVB	#'X,@CMLADR	;
2$:	RETURN			; RETURN TO CALLER

	.SBTTL	FCSREAD -- READ A BLOCK FROM TASK IMAGE

;+
;
; GLOBAL ROUTINE REG0 FCSREAD(VBN)
;
; FUNCTION
;	READ A BLOCK FROM THE TASK IMAGE INTO THE IN-CORE BUFFER
;	POSSIBLY, REWRITE THE EXISTING BLOCK
;
; INPUTS
;	VBN	- POINTER TO A TWO-WORD VIRTUAL BLOCK NUMBER
;	BLKNUM	- VBN OF THE BLOCK IN MEMORY
;
; OUTPUTS
;	BLKBUF	- CONTAINS THE BLOCK IDENTIFIED BY VBN
;	VALUE	- NONE
;
;-

FCSREAD::
	CMP	(R0)+,BLKNUM	; CHECK IF THE BLOCK IS ALREADY IN CORE
	BNE	1$		;
	CMP	(R0),BLKNUM+2	;
	BEQ	2$		;
1$:	CALL	REWRIT		; REWRITE OLD BLOCK IF NEEDED
	MOV	(R0),BLKNUM+2	; COPY THE BLOCK NUMBER INTO BLKNUM
	MOV	(R0),TSKFDB+F.BKVB+2 ; AND ALSO THE FDB
	MOV	-(R0),BLKNUM	;
	MOV	(R0),TSKFDB+F.BKVB
	READ$	#TSKFDB		; READ THE BLOCK
	BCS	TSKERR
	WAIT$	R0		; WAIT FOR COMPLETION
	BCS	TSKERR		;
2$:	RETURN			; RETURN TO CALLER

	.SBTTL	REWRIT -- REWRITE BLOCK IF MODIFIED

;+
;
; GLOBAL ROUTINE REWRIT
;
; FUNCTION
;	REWRITE A TASK IMAGE BLOCK IF IT HAS BEEN MODIFIED WHILE
;	IN CORE
;
; INPUTS
;	BLKBUF	- TASK IMAGE BLOCK
;	WRITBK	- IF NONZERO, BLOCK WAS MODIFIED
;
; OUTPUTS
;	WRITBK	- CLEARED
;	VALUE	- NONE
;
; NOTE
;	IF THE FILE WAS OPENED FOR READ-ONLY, NO WRITE IS ISSUED,
;	AS THIS WOULD CAUSE AN ERROR TO BE RETURNED
;
;-

REWRIT::
	TST	WRITBK		; TEST IF BLOCK MODIFIED
	BEQ	2$		; BLOCK WAS NOT MODIFIED
	CLR	WRITBK		; CLEAR THE FLAG
	BIT	#RDONLY,SWITCH	; TEST IF READ-ONLY ACCESS
	BNE	2$		; BRANCH IF READONLY
	MOV	R0,-(SP)	; SAVE R0
	MOV	BLKNUM,TSKFDB+F.BKVB ; SET VBN INTO FDB
	MOV	BLKNUM+2,TSKFDB+F.BKVB+2
	WRITE$	#TSKFDB		; ISSUE THE WRITE
	BCS	1$		;
	WAIT$	R0		; WAIT FOR COMPLETION
1$:	MOV	(SP)+,R0	; RESTORE R0
	BCS	TSKERR		;
2$:	RETURN			; RETURN TO CALLER

	.SBTTL	EOL -- WRITE LINE TO CONSOLE LOG

;+
;
; GLOBAL ROUTINE EOL
;
; FUNCTION
;	WRITE A LINE ON THE CONSOLE LOG
;
; INPUTS
;	OUTPTR	- POINTER TO NEXT FREE BYTE IN OUTBUF
;	OUTBUF	- BUFFER FOR PRINT LINE
;
; OUTPUTS
;	OUTPTR	- REINITIALIZED
;	VALUE	- NONE
;
;-

EOL::
	MOV	OUTPTR,-(SP)	; COMPUTE RECORD LENGTH
	SUB	#OUTBUF,@SP	;
	PUT$S	#OUTFDB,,(SP)+	; WRITE THE RECORD
	BCS	TERMIN		; TERMINATE IF PUT FAILS
	MOV	#OUTBUF,OUTPTR	; REINITIALIZE POINTER
	RETURN			; RETURN TO CALLER

	.SBTTL	ERROR HANDLERS

;+
;	ERROR HANDLERS FOR I/O PACKAGE
;
;	TSKERR	- OUTPUT I/O ERROR MESSAGE AND EXIT
;	ERROR	- OUTPUT MESSAGE (NUMBER IN R0) AND EXIT
;	TERMIN	- EXIT
;-

TSKERR::MOV	#TRNERR,R0	; SET MESSAGE NUMBER IN R0
ERROR:	CALL	ERRPRT		; CALL ERROR MESSAGE OUTPUT ROUTINE
TERMIN:	MOV	#SIGXIT,R0	; SET SIGNAL VALUE IN R0
	JMP	$SIGNL		; SIGNAL

	.SBTTL	TRANSLATE -- TRANSLATE VIRTUAL ADDRESS TO VBN AND BYTE

;+
;
; GLOBAL ROUTINE TRANSLATE(VIRORG,VIRADR,VBNOUT,BUFPTR)
;
; FUNCTION
;	PERFORM ADDRESS TRANSLATION FROM VIRTUAL TO REAL
;
; INPUTS
;	VIRORG	- POINTER TO TWO WORD VIRTUAL ORIGIN DATA
;	VIRADR	- THE VIRTUAL ADDRESS
;
;		  THE VIRTUAL ORIGIN IS A 32-BIT QUANTITY TO WHICH IS
;		  ADDED THE DESIRED VIRTUAL ADDRESS, TO YIELD A NINE-BIT
;		  BYTE OFFSET WITHIN BLOCK IN BITS 0-8 AND A 23-BIT
;		  VIRTUAL BLOCK NUMBER IN BITS 9-31.
;
; OUTPUTS
;	VBNOUT	- TWO WORD AREA FILLED WITH VBN AS CALCULATED
;	BUFPTR	- POINTER WITHIN BLKBUF TO THE BYTE AS CALCULATED
;	VALUE	- NONE
;
;-

TRANSLATE::
	JSR	R1,$SAV3	; SAVE REGISTERS
	MOV	20(SP),R2	; POINT TO VIRTUAL ORIGIN DATA
	MOV	(R2)+,R0	; LOAD DATA INTO R0-R1
	MOV	@R2,R1		;
	ADD	16(SP),R1	; ADD THE VIRTUAL ADDRESS
	ADC	R0		;
	MOV	12(SP),R2	; POINT TO REAL ADDRESS OUTPUT WORD
	MOV	R1,@R2		; PUT LOW ORDER 9 BITS THERE
	BIC	#177000,@R2	;
	ADD	#BLKBUF,@R2	; ADD ORIGIN OF BUFFER
	MOV	#9.,R3		; SHIFT VBN RIGHT 9 BITS INTO POSITION
1$:	ASR	R0		;
	ROR	R1		;
	DEC	R3		;
	BNE	1$		;
	BIC	#177600,R0	; CLEAR HIGH-ORDER 9 BITS
	MOV	14(SP),R2	; POINT TO VBN OUTPUT AREA
	MOV	R0,(R2)+	; MOVE RESULT VBN
	MOV	R1,@R2		;
	RETURN			; RETURN TO CALLER

	.SBTTL	BYTSXT -- BYTE SIGN EXTENSION

;+
; GLOBAL ROUTINE REG0 BYTSXT(V)
;
; FUNCTION
;	SIGN EXTEND BYTE TO WORD
;
; INPUTS
;	V	- BYTE
;
; OUTPUTS
;	VALUE	- WORD
;
;-

BYTSXT::
	MOVB	R0,R0		; BECAUSE BLISS CAN'T
	RETURN			; RETURN TO CALLER

	.END
