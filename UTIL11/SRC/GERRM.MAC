	IDENT	0010,GERRM,<GET ERROR MESSAGE STRING>

; B. SCHREIBER	22-SEP-77
;
;	BLS030 -- LOOK FOR MESSAGE FILE ON LB: RATHER THAN SY:
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	31-APR-74

	.IF	GT,R$$11M


	.MCALL	FILIO$
	FILIO$			;DEFINE THE I/O FUNCTION CODES LOCALLY
;
	.MCALL	NMBLK$,QIO$,WTSE$S,DIR$,CALL,RETURN

	IMPURE

DIRNMB:	NMBLK$	001002,DIR,,LB,0

	.=DIRNMB+N.DID
	.WORD	4,4
	.=DIRNMB+S.FNB

QIODPB:	QIO$	,,32.,,EOIOST,,<,,,,,>

	.EOLUN==QIODPB+Q.IOLU
	.EOEFN==QIODPB+Q.IOEF

.ERRBF::.BLKB	1000
EOIOST:	.BLKW	2
;+
;
; GET ERROR MESSAGE FROM FILE
;
; CALLING SEQUENCE:
;
;	CALL	.GERRM
;
; INPUTS:
;
;	R0=STRING ADDRESS TO RETURN STRING
;	R1=MESSAGE FILE POINTER (FNB FOR 11M, STRING DESCRIPTOR FOR 11D)
;	R2=RECORD NUMBER (64. BYTE FIXED LENGTH RECORDS)
;
; OUTPUTS:
;
;	C=0 IF SUCCESSFUL, C=1 IF FAILED
;	R0=UPDATED STRING ADDRESS
;	R1=NO. OF CHARACTER ADDED
;	R2-R5 PRESERVED
;
;-

	PURE.I
.GERRM::JSR	R5,$SAVRG
	TST	N.DID(R1)	;IS DIRECTORY ID SET?
	BNE	20$		;BRANCH IF YES
	MOV	#DIRNMB,R4
	TST	(R4)
	BNE	10$
	CALL	FIND		;FIND THE DIRECTORY ID
	BCS	90$		;BRANCH IF NO MESSAGE FILE
10$:	MOV	(R4)+,N.DID(R1) ; SET DIECTORY ID
	MOV	(R4)+,N.DID+2(R1) ;
	MOV	(R4)+,N.DID+4(R1)
20$:	TST	(R1)		;IS FILE ID ALREADY PRESENT
	BNE	30$		;BRANCH IF YES
	MOV	R1,R4		;
	CALL	FIND		;FIND THE MESSAGE
	BCS	90$		;BRANCH IF NO MESSAGE FILE
30$:				;
	MOV	#IO.ACR,QIODPB+Q.IOFN
	CALL	CLRDPB		;SET R5 TO BE WORD PARAM BLOCK
	MOV	R1,(R5)		;FNB

	.IF	GT,R$$DPB

	MOV	#100000,8.(R5)	;ENABLE ACCESS BIT
	.ENDC

	CALL	QIOWAT		;ISSUE ACCESS I/O AND WAIT
	BCS	90$		;BRANCH IF FAILED TO ACCESS
	MOV	R2,R4
	DEC	R4
	CLC			;SHIFT R4 3 BITS RIGHT
	ROR	R4
	ASR	R4
	ASR	R4
	INC	R4		;SINCE VBN'S START AT 1
	MOV	#IO.RVB,QIODPB+Q.IOFN
	CALL	CLRDPB
	MOV	#.ERRBF,(R5)+	;ADDRESS TO READ INTO
	MOV	#512.,(R5)+	;SIZE OF TRANSFER
	CMP	(R5)+,(R5)+
	MOV	R4,(R5)		;VBN TO READ
	CALL	QIOWAT		;ISSUE READ QI/O AND WAIT
	ROR	R4		;SAVE CARRY
	MOV	#IO.DAC,QIODPB+Q.IOFN
	CALL	CLRDPB
	MOV	R1,(R5)		;FILE TO DEACCESS
	CALL	QIOWAT		;ISSUE THE DEACCESS QI/O
	BCS	90$
	ROL	R4		;RESTORE C BIT FROM READ
	BCS	90$		;BRANCH IF READ FAILED
	MOV	R2,R5
	DEC	R5
	BIC	#177770,R5	;R5=RECORD NO. WITHIN BLOCK
	SWAB	R5		;ASH #6,R5, SHIFT LEFT 6
	ASR	R5
	ASR	R5
	ADD	#.ERRBF,R5	;FORM R5=ADDRESS OF RECORD
	MOV	R0,R3
	MOV	#64.,R4
50$:	MOVB	(R5)+,(R0)+	;MOVE UP TO 64. BYTES ASCIZ
	BEQ	55$
	SOB	R4,50$
	BR	60$
55$:	DEC	R0		;DON'T COUNT THE NULL
60$:	MOV	R0,R1		;
	SUB	R3,R1		;FORM BYTE COUNT, C=0
	BEQ	95$		;IF NULL RECORD, RETURN ERR
	RETURN
90$:	CLR	R1
95$:	SEC
	RETURN
;+
; ISSUE A FIND QI/O
;
; CALLING SEQUENCE:
;
;	CALL	FIND
;
; INPUTS:
;
;	R4=FNB
;
; OUTPUTS:
;
;	C=0 IF SUCCESSFUL, C=1 IF ERROR
;	R5 ALTERED, R0-R4 PRESERVED
;
;-
FIND:
	MOV	#IO.FNA,QIODPB+Q.IOFN
	CALL	CLRDPB
	.IF	GT,R$$DPB

	MOV	R4,10.(R5)	;STORE FNB

	.IFF

	MOV	R4,(R5)

	.ENDC
	CALL	QIOWAT		;ISSUE THE FIND QI/O AND WAIT
	RETURN
;+
; CLEAR THE 6 WORD PARAMETER AREA OF THE QIODPB
;
; CALLING SEQUENCE:
;
;	CALL	CLRDPB
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0-R4 PRESERVED
;	R5 POINTS 1ST WORD OF 6 WORD PARAMETER BLOCK
;
;-
CLRDPB:
	MOV	#QIODPB+24.,R5	;POINT TO LAST +2 WORD
	MOV	#6,-(SP)	;CLEAR 6 WORDS
10$:	CLR	-(R5)		;
	DEC	(SP)
	BGT	10$
	TST	(SP)+
	RETURN
;+
;
; ISSUE THE QIO AND WAIT - QIODPB ALL SET UP.
;
; CALLING SEQUENCE:
;
;	CALL	QIOWAT
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	C=0 IF SUCCESSFUL, C=1 IF ERROR
;
;-
QIOWAT:
	DIR$	#QIODPB
	BCS	10$
	WTSE$S	.EOEFN
	TSTB	EOIOST		;NEGATIVE STATUS IS AN ERROR
	BGT	10$		;BRANCH IF OK, C=0
	SEC
10$:	RETURN

	.IFF			;IF THIS IS FOR RSX11D

	.MCALL	RETURN,MOUT$S

	IMPURE
.ERRBF::.BLKB	3*80.		;ENOUGH SPACE FOR 3 LINES
	ERRBFS=.-.ERRBF
EOIOST:	.BLKW	2		;I/O STATUS BLOCK FOR MO CALL
.EOLUN::.BLKW	1		;LUN FOR MO, PATCH AND PREASSIGN TO MO

	PURE.I
.GERRM::CLR	-(SP)		;SET UP A ZERO COUNT TO RETURN IF ERROR
	MOUT$S	R1,,R2,CONT,USBUF,#.ERRBF,#ERRBFS,#EOIOST,.EOLUN
	BCS	20$
	SEC
	MOVB	EOIOST,R1	;COMPLETED SUCCESSFULLY?
	BMI	20$		;BRANCH IF NO
	MOV	.ERRBF+2,R1	;LENGTH OF RECORD RETURNED
	BEQ	20$		;BRANCH IF EMPTY
	MOV	R1,(SP)		;PUT REAL COUNT ON STACK
	MOV	R1,-(SP)	;PUSH ANOTHER COPY FOR MOVE LOOP
	MOV	#.ERRBF+4,R1
10$:	MOVB	(R1)+,(R0)+	;MOVE THE RECORD TO THE USER STRING
	DEC	(SP)
	BGT	10$
	TST	(SP)+		;POP THE EXPIRED COUNT AND CLEAR CARRY
20$:	MOV	(SP)+,R1	;RECOVER THE SAVED COUNT OR 0 IF ERROR
	RETURN

	.ENDC
;
;
	.END
