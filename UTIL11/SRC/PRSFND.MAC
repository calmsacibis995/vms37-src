	IDENT	0120,PRSFND,<PARSE, FIND, ETC.>
; ALTERED:
; E. H. MARISON	27-FEB-77 13:42 (TAKE <*> AND <*,*>)
; ANDREW C. GOLDSTEIN  13-FEB-78  19:25
; ALTERED THURSDAY 22-AUG-74 12:10
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN 12-JUNE 73
;
	.MCALL	NBOF$L,IOERR$,FILIO$
	NBOF$L			;DEFINE FNB OFFSETS LOCALLY
	IOERR$			;DEFINE I/O ERROR CODES LOCALLY
	FILIO$			;DEFINE THE I/O FUNCTION CODES LOCALLY
;
	.MCALL	CALL,RETURN,FDBDF$,FDAT$A,FDOP$A,FCSBT$
;
	FCSBT$	DEF$L
	FLDSOF			;DEFINE FILE DESCRIPTOR OFFSETS
;
	NB.SD1=400		;WILD CARD IN PROJECT #
	NB.SD2=1000		;WILD CARD IN PROGRAMMER #
	NB.SDI=NB.SD1!NB.SD2	;WILD CARD IN DIRECTORY
;
; SCRATCH STORAGE FOR WILD UIC LOGIC CONSISTS
; OF A FILE NAME BLOCK FOLLOWED BY THE FOLLOWING EXTRA WORDS
	N.WNM1=S.FNB		;2 WORDS FOR RAD50 NON WILD CARD
				;PROJECT OR PROGRAMMER NAME
	N.WNM2=N.WNM1+4		;5 WORDS OF STRING STORAGE FOR
				;ASCII FORM OF CURRENT DIRECTORY NAME
	S.WUIC=S.FNB+14.	;NO. OF BYTES IN SCRATCH AREA
;
	DIRTYP=<'D-100>*50*50+<<'I-100>*50>+<'R-100> ;.RAD50 DIR
	MFDNAM=<'0-22>*50*50+<<'0-22>*50>+<'0-22> ;.RAD50 000

	.SBTTL	.WPARS - WILD CARD UIC PARSE
;
	PURE.I
;+
; WILD CARD UIC PARSE
; CALLING SEQUENCE:
;	CALL	.WPARS
; INPUTS:
;	R0=FDB
;	R1=FILE NAME BLOCK ADDRESS
;	R2=FILE DESCRIPTOR POINTER
;	R3=DEFAULT FILE NAME BLOCK
;	R4=ADDR OF SCRATCH AREA FOR WILD UIC LOGIC
; OUTPUTS:
;	C=0 IF SUCCESSFUL, C=1 IF ERROR
;	ALL REGISTERS PRESERVED
; OPERATION:
;	PERFORMS A NORMAL CALL TO .PARSE, AND IF A BAD DIRECTORY
; INDICATION IS RETURNED, ATTEMPTS TO PARSE AND SET UP FOR WILD UIC'S
; IF A SUCCESSFUL INDICATION IS RETURNED, THE DIRECTORY ID
; IS SET UP POINTING AT THE FIRST DIRECTORY TO BE USED
;-
.WPARS::MOV	#NB.SNM!NB.SVR,N.STAT(R4)
	CALL	.PARSE
	BCC	60$		;BRANCH IF PARSE SUCCESSFUL
	CMPB	#IE.BDI,F.ERR(R0) ;BAD DIRECTORY NAME?
	BNE	58$		;BRANCH IF NO, REPORT ERROR
; SEE IF WILD CARD DIRECTORY NAME
	TST	N.DIRD(R2)	;IF NULL DIRECTORY DESCRIPTOR
	BEQ	58$		;THEN REPORT ERROR
	CALL	PRSDIR
	BCS	60$		;BRANCH IF BAD DIRECTORY SYNTAX
	BIT	#NB.SDI,N.STAT(R4)
	BEQ	58$		;BRANCH IF NO WILD UIC'S
; IT'S A WILD CARD DIRECTORY NAME
	MOV	#DIRTYP,N.FTYP(R4) ;FILE TYPE "DIR"
	CLR	N.NEXT(R4)
	MOV	#-1,N.DID(R4)	;DOING FIND'S IN MFD
	MOV	#-1,N.DID+2(R4)
	CLR	N.DID+4(R4)
	MOV	N.DVNM(R1),N.DVNM(R4)
	MOV	N.UNIT(R1),N.UNIT(R4)
	CALL	.NXDIR		;SET UP TO USE THE NEXT DIRECTORY
	BCS	60$
	CALL	.PARSE
	MOV	N.STAT(R4),-(SP)
	BIC	#^C<NB.SDI>,@SP
	BIS	(SP)+,N.STAT(R1) ;SET WILD DIR BITS IN FNB STATUS
	RETURN
58$:	SEC
60$:	RETURN


	.SBTTL	.FNDNX - FIND THE NEXT FILE
;+
; FIND THE NEXT FILE IN THIS (OR NEXT) DIRECTORY
; CALLING SEQUENCE:
;	CALL	.FNDNX
; INPUTS:
;	R0=FDB ADDRESS
;	R1=FILE NAME BLOCK ADDRESS
;	R2=ADDRESS OF SCRATCH BLOCK FOR UIC WILD CARD LOGIC
; OUPUTS:
;	C=0 IF SUCCESSFUL, C=1 IF FAILURE
;	ALL REGISTERS PRESERVED
; OPERATION:
;	FINDS THE NEXT FILE IN THE CURRENT DIRECTORY (EVEN IF
; WILD CARD NAME, TYPE AND DEFAULT VERSION).  OPTIONALLY WILL
; CROSS TO THE NEXT WILD CARD DIRECTORY IF R2 NON ZERO (AND
; IF WILD CARD UIC'S ARE PRESENT).
;-
	.ENABL	LSB

.FNDNX::BIT	#NB.NXD,N.STAT(R1) ; CHECK IF "NEXT DIRECTORY" FLAG IS ON
	BNE	90$		; YES - FORCE NEXT DIRECTORY
	TST	TDRFDB+F.FNB+N.DID ; SEE IF SCRATCH DIRECTORY IS IN USE
	BNE	FNDNX1		; BRANCH IF YES
	CALL	.FIND
	BCC	FNDNX2		; BRANCH IF OK
	CMPB	F.ERR(R0),#IE.BAD ; CHECK FOR WILD CARD, DEFAULT VERSION
				; NOT SUPPORTED (OLD SYSTEM)
	BNE	FNDNX2		; BRANCH IF ANYTHING ELSE
;
; HANDLE THE SPECIAL CASE OF WILD CARD FIND OF NEWEST OR OLDEST VERSION
FNDNX1:	TST	N.NEXT(R1)	;FIRST FILE IN CLASS?
	BNE	10$		;BRANCH IF NOT
	CALL	TDRINI		;YES, INIT TEMP DIRECTORY
	BCS	40$		;BRANCH IF FAILED
10$:	MOV	N.FVER(R1),-(SP)
20$:	MOV	N.STAT(R1),-(SP)
	BIS	#NB.SVR,N.STAT(R1) ;FIND ANY VERSION FIRST
	CALL	.FIND
	BCS	60$		;BRANCH IF NO MORE FILES
	MOV	N.NEXT(R1),-(SP)
	CLR	N.STAT(R1)
	CLR	N.NEXT(R1)
	MOV	4(SP),N.FVER(R1) ;SAVED FILE VERSION (0 OR -1)
	CALL	.FIND		;FIND NEWEST (OR OLDEST)
	BCS	50$		;BRANCH IF FAILED (SHOULDN'T HAPPEN)
	CALL	TDRENT		;HAVE WE ALREADY FOUND THIS ONE
	MOV	(SP)+,N.NEXT(R1)
	MOV	(SP)+,N.STAT(R1)
	BCS	30$
	TST	(SP)+		;POP THE SAVED VERSION
	BR	FNDNX3
; IF DUPLICATE ERROR, WE'VE SEEN THIS FILE BEFORE, DON'T "FIND" IT AGAIN
30$:	CMPB	#IE.DUP,TDRFDB+F.ERR
	BEQ	20$		;GO FIND ANOTHER
	TST	(SP)+
;
; ERROR FROM INIT OR ENTER IN TMP DIRECTORY
40$:	MOVB	TDRFDB+F.ERR,F.ERR(R0)
	BR	80$
;
; COULDN'T FIND NEWEST OR OLDEST VERSION - CAN'T THINK OF A REASON
50$:	MOV	(SP)+,N.NEXT(R1)
	BR	70$
;
; FAILED TO FIND NEXT FILE IN CLASS, ALL DONE
60$:	CALL	TDRDEL		;DELETE THE TEMP DIRECTORY
70$:	MOV	(SP)+,N.STAT(R1)
	MOV	(SP)+,N.FVER(R1)
80$:	SEC
FNDNX2:	BCC	FNDNX3
	CMPB	#IE.NSF,F.ERR(R0) ;IF "NO SUCH FILE"
	BNE	100$		;BRANCH IF NOT
90$:	TST	R2		;ALLOWED TO CROSS DIRECTORIES?
	BEQ	100$		;BRANCH IF NOT
	BIT	#NB.SDI,N.STAT(R1) ;ANY WILD UIC'S
	BEQ	100$		;BRANCH IF NOT
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	R2,R4
	MOV	F.DSPT(R0),R2
	MOV	F.DFNB(R0),R3
	CALL	.NXDIR
	MOV	R4,R2
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	BCC	.FNDNX		;IF FOUND NEW DIRECTORY, FIND NEXT FILE
100$:	SEC
	BR	110$
FNDNX3:	TST	N.NEXT(R1)	; SEE IF THERE ARE NAME LEVEL WILD CARDS
	BNE	110$		; BRANCH IF YES
	BIT	#NB.SDI,N.STAT(R1) ; CHECK FOR WILD CARD UIC
	BEQ	110$		; BRANCH IF NOT
	BIS	#NB.NXD,N.STAT(R1) ; FORCE NEW DIRECTORY ON NEXT FIND
				; IN CASE OF WILD UIC, SINGLE NAME
110$:	RETURN

	.DSABL	LSB

	.SBTTL	.NXDIR - FIND NEXT WILD CARD DIRECTORY
;+
; SET UP FOR NEXT WILD CARD DIRECTORY
; CALLING SEQUENCE:
;	CALL	.NXDIR
; INPUTS:
;	R0=FDB ADDRESS
;	R1=FILE NAME BLOCK ADDRESS
;	R2=FILE DESCRIPTOR POINTER
;	R3=DEFAULT FILE NAME BLOCK
;	R4=ADDR OF SCRATCH AREA FOR WILD UIC LOGIC
; OUTPUTS:
;	C=0 IF SUCCESSFUL, C=1 IF FAILED
;	ALL REGISTERS PRESERVED
; OPERATION:
;	FINDS THE NEXT DIRECTORY THAT MEETS THE WILD CARD CRITERIA
; IF ONLY THE PROJECT # WAS WILD, THEN THE PROG NAMES MUST MATCH
; AND VICE-VERSA.  DIRECTORY NAMES OF MORE THAN 6 CHARS WILL NOT
; SATISFY THE MATCH, AND LIKEWISE, ANY NAME BEGINNING WITH 000
; (RAD50) WILL ALSO NOT MATCH.  THIS MEANS THE MFD WILL
; NOT BE FOUND.
;	WHEN A DIRECTORY IS FOUND, IT'S ID IS PLACED
; IN THE DIRECTORY ID SLOT IN THE FILE NAME BLOCK.
; ALSO THE DIRECTORY STRING IS GENERATED AND POINTED TO BY F.DSPT
; IF PRESENT, OR THE DIRECTORY ID IS PUT INTO THE
; DEFAULT NAME BLOCK IF IT IS PRESENT.
;-
.NXDIR::BIC	#NB.NXD,N.STAT(R1) ;CLEAR DIRECTORY CROSSING FLAG
	BIT	#NB.SDI,N.STAT(R4) ;WILD CARD UIC'S?
	BEQ	90$		;BRANCH IF NO
	CALL	$SAVAL
10$:	MOV	R1,-(SP)
	MOV	R4,R1
	CALL	.FIND		;FIND THE NEXT DIRECTORY
	MOV	(SP)+,R1
	BCS	100$
; FOUND ONE, SEE IF IT MATCHE OUR REQUIREMENTS
	CMP	#MFDNAM,N.FNAM(R4) ;DON'T ALLOW MFD
	BEQ	10$
; MATCH PROJ OR PROG NAME IF NECESSARY
	BIT	#NB.SD1,N.STAT(R4) ;WILD CARD PROJ #?
	BNE	20$		;BRANCH IF YES
	CMP	N.WNM1(R4),N.FNAM(R4)
	BNE	10$		;BRANCH IF PROJ NAMES DISAGREE
20$:	BIT	#NB.SD2,N.STAT(R4) ;WILD CARD PROGRAMMER #?
	BNE	30$		;BRANCH IF YES
	CMP	N.WNM1+2(R4),N.FNAM+2(R4)
	BNE	10$		;BRANCH IF PROG NAMES DISAGREE
	TST	N.FNAM+4(R4)	;NO 7-9 CHAR NAMES
	BNE	10$
; THIS DIRECTORY IS JUST FINE, SET UP THE FILE NAME BLOCK DIRECTORY ID
; AND ALSO SET THE DIR NAME POINTER IN F.DSPT IF PRESENT
; OR THE DIRECTORY ID IN F.DFNB IF F.DSPT IS 0
30$:	MOV	N.FID(R4),N.DID(R1)
	MOV	N.FID+2(R4),N.DID+2(R1)
	MOV	N.FID+4(R4),N.DID+4(R1)
	CLR	N.NEXT(R1)	;START AT BEGINNING OF DIRECTORY
; SET UP STRING WITH DIRECTORY NAME, AND POINT TO IT FROM
; THE FILE DESCRIPTOR POINTER
	MOV	R2,R5		;SAVE THE FILE DECRIPTOR POINTER
	BEQ	80$		;SKIP THIS IF NULL POINTER
	MOV	R4,R0
;
; ATTEMPT TO CONVERT DIRECTORY NAME INTO DIRECTORY STRING; CHECK IF FIRST
; CHARACTER IS ALPHABETIC.
;
	ADD	#N.WNM2,R0	;R0=ADDRESS OF STRING AREA
	MOV	N.FNAM(R4),R1	;R1=1ST RAD50 FILE NAME WORD
	MOV	R0,R3		; SAVE START OF STRING
	MOVB	#'[,(R0)+	; START TO CONSTRUCT DIRECTORY STRING
	CALL	$C5TA		; FIRST 3 CHARACTERS
	CMPB	1(R3),#'A	; SEE IF STRING IS ALPHABETIC
	BLO	60$		; BRANCH IF NOT - USE PPN FORMAT
	MOV	N.FNAM+2(R4),R1	; CONTINUE CONVERTING NAME
	CALL	$C5TA
	MOV	N.FNAM+4(R4),R1
	CALL	$C5TA
40$:	CMPB	-(R0),#40	; BACK UP OVER TRAILING SPACES
	BEQ	40$
	MOV	R0,R1
	SUB	R3,R1		; COMPUTE LENGTH SO FAR (SHORT ONE CHAR)
	CMP	R1,#9.		; IF NAME IS 9 CHARACTERS LONG, WE MUST
	BGE	50$		; PUNT THE LAST CHARACTER BECAUSE OF BUFFER LENGTH
	INC	R0		; ELSE GET BACK LAST CHAR
50$:	MOVB	#'],(R0)+	; END OF DIRECTORY STRING
	MOV	R0,R2		; SHUFFLE REGISTERS FOR CODE BELOW
	MOV	R3,R0
	BR	70$
;
; FIRST CHARACTER OF DIRECTORY STRING IS NUMERIC. CONVERT TO PPN FORMAT.
;
60$:	MOV	R3,R0		; RESTORE BUFFER ADDRESS
	MOV	N.FNAM(R4),R1	; GET FIRST WORD OF NAME AGAIN
	CALL	C5TB		;CONVERT RAD50 TO BINARY IN R1
	MOV	R1,-(SP)	;SAVE PROJECT #
	MOV	N.FNAM+2(R4),R1
	CALL	C5TB		;CONVERT 2ND RAD50 WORD
	CLR	R3
	BISB	(SP)+,R3	;PROJECT #
	SWAB	R3
	BISB	R1,R3		;R3 =.BYTE PROG#,PROJ#
	MOV	R0,R2		;R2=SCRATCH AREA STRING ADR
	CLR	R4
	CALL	.PPASC		;PPN TO ASCII STRING

70$:	MOV	R0,N.DIRD+2(R5)	;R5=F.DSPT, STORE STRING ADDRESS
	SUB	R0,R2		;CALCULATE DIRECTORY STRING SIZE
	MOV	R2,N.DIRD(R5)	;AND STORE IT IN F.DSPT
	BR	100$
;
; SET DIRECTORY ID IN DEFAULT NAME BLOCK, SINCE THERE
; WAS NO FILE DESCRIPTOR POINTER TO PUT A STRING IN
80$:	TST	R3		;ANY DEFAULT FILE NAME BLOCK?
	BEQ	100$		;BRANCH IF NO
	MOV	N.FID(R4),N.DID(R3)
	MOV	N.FID+2(R4),N.DID+2(R3)
	MOV	N.FID+4(R4),N.DID+4(R3)
	RETURN
90$:	MOVB	#IE.NSF,F.ERR(R0)
	SEC
100$:	RETURN

	.SBTTL	.WLDVC - CHECK FOR WILD CARDS WITH DEFAULT VERSION
;
;+
; CHECK IF DEFAULT VERSION WITH WILD CARD NAME OR TYPE
; CALLING SEQUENCE:
;	CALL	.WLDVC
; INPUTS:
;	R0=FDB ADDRESS
;	R1=FILE NAME BLOCK
; OUTPUTS:
;	C=1 IF WILD NAME OR TYPE, AND DEFAULT VERSION
;	C=0 IF NOT
;	ALL REGISTERS PRESERVED
;-
.WLDVC::BIT	#NB.SNM!NB.STP,N.STAT(R1)
	BEQ	10$
	BIT	#NB.SVR,N.STAT(R1) ;REQUIRE WILD VERSION
	BNE	10$
	TST	N.FVER(R1)	;OR EXPLICIT VERSION
	BEQ	5$
	CMP	#-1,N.FVER(R1)
	BNE	10$
5$:	SEC
	RETURN
10$:	CLC
	RETURN

	.SBTTL	USEFUL SUBROUTINES
;
;+
; PARSE THE DIRECTORY STRING, ALLOWING WILD CARD UIC'S
; CALLING SEQUENCE:
;	CALL	PRSDIR
; INPUTS:
;	R0=FDB
;	R1=FILE NAME BLOCK
;	R2=FILE DESCRIPTOR POINTER
;	R3=DEFAULT FILE NAME BLOCK
;	R4=SCRATCH AREA TO BE INITIALIZED WITH WILD CARD
;		UIC INFORMATION
; OUTPUTS:
;	C=0 IF OK, C=1 IF BAD SYNTAX IN DIRECTORY STRING
;	ALL REGISTERS PRESERVED
; OPERATION:
;	SETS UP THE STATUS WORD (N.STAT) IN THE FNB OF THE
; SCRATCH AREA WITH THE APPROPRIATE WILD CARD UIC BITS, AND STORES
; THE EXPLICIT PROJECT NAME (RAD50) AND PROGRAMER NAME
; IN N.WNM1, N.WNM1+2 (R4).
;-
PRSDIR:	CALL	$SAVAL
	MOV	R4,-(SP)
	MOV	R4,R1
	ADD	#N.WNM1,R1
	CALL	PRSUI1
	MOV	(SP)+,R4
	BCS	40$
	MOV	-(R3),R1	;R1=PROJECT #
	MOV	R4,R0
	ADD	#N.WNM2,R0	;SCRATCH STRING ADDRESS
	CALL	CDRNM		;CONVERT NUMBER TO RAD50  (1 WORD)
	MOV	R1,(R3)+	;STORE RAD50 BACK IN N.WNM1(R4)
	BCC	10$
; NUMBER WAS TOO BIG, WAS IT -1, IF SO, SET WILD BIT
	CMP	#-1,R1
	BNE	40$		;OTHERWISE SYNTAX ERROR
	BIS	#NB.SD1,N.STAT(R4) ;SET WILD PROJECT #
10$:	MOV	@R3,R1		;R1=PROGRAMMER #
	MOV	R4,R0
	ADD	#N.WNM2,R0
	CALL	CDRNM
	MOV	R1,@R3		;STORE RAD50
	BCC	20$
	CMP	#-1,R1
	BNE	40$		;BRANCH IF SYNTAX ERROR
	BIS	#NB.SD2,N.STAT(R4) ;SET WILD CARD PROGRAMMER #
20$:	CLC
	RETURN
30$:	TST	(SP)+
40$:	SEC
	RETURN
;
;+
; PARSE UIC STRING INTO BINARY PROJ AND PROG NUMBERS (2 WORDS)
; CALLING SEQUENCE:
;	CALL	.PRSUI
; INPUTS:
;	R1=ADDRESS OF 2 WORD BLOCK TO STORE PPN
;	R2=FILE DESCRIPTOR POINTER
; OUTPUTS:
;	C=0 OK, C=1 IF SUNTAX ERROR
;	ALL REGISTERS PRESERVED
;	@R1 = PROJECT # OR -1 IF *
;	2(R1) = PROGRAMMER # OR -1 IF *
; ALTERNATE ENTRY:
;	CALL	PRSUI1
; INPUTS:
;	SAME
; OUTPUTS:
;	SAME EXCEPT REGISTERS NOT PRESERVED
;	R3= ADDRESS OF PROGRAMMER # (2ND WORD)
;	R0 PRESERVED, R2,R4,R5 ALTERED
;-
.PRSUI::
	JSR	R5,.SAVR1
PRSUI1:	MOV	R1,R3		;R3=ADR TO RETURN PROJECT #
	MOV	N.DIRD(R2),R1	;R1=SIZE OF DIRECTORY STRING
	MOV	N.DIRD+2(R2),R2	;R2=ADDRESS OF DIRECOTRY STRING
;
; CHANGE < TO [ AND > TO ]
;
	MOV	R1,-(SP)	; SAVE SIZE AND ADDR
	MOV	R2,-(SP)
	CMPB	#'<,(R2)	; MUST START WITH [ OR <
	BNE	20$
	MOVB	#'[,(R2)	; CHANGE < TO [
10$:	CMPB	#'>,(R2)+	; FIND   >
	BNE	15$
	MOVB	#'],-(R2)	; CHANGE TO ]
	BR	20$		; AND CONTINUE
15$:	DEC R1			; COUNT CHAR AND LOOP
	BNE	10$
20$:	MOV	(SP)+,R2	; RESTORE ADDR AND SIZE
	MOV	(SP)+,R1
	CMPB	#'[,(R2)+	;REQUIRE LEADING "["
	BNE	70$
	DEC	R1		;COUNT THE "["
	CMPB	#'*,(R2)	;CHECK FOR STRING OF "[*]"
	BNE	50$
	CMPB	#'],1(R2)
	BEQ	80$		;YES - ALTERNATE FORM OF WILD DIRECTORY
50$:	MOV	#',,R4		;R4=TERMINATOR CHARACTER
	CALL	SCNCVT		;CONVERT PROJECT #
	BCS	60$		;BRANCH IF BAD SYNTAX
	TST	(R3)+		;R3= ADDRESS TO STORE PROG #
	MOV	#'],R4		;R4=TERMINATING CHAR
	CALL	SCNCVT		;CONVERT PROGRAMMER #
60$:	RETURN
;
70$:	SEC
	RETURN
;
; HANDLE "[*]" FORM OF WILD CARD DIRECTORY
;
80$:	MOV	#-1,(R3)	;SET WILD CARD CODE FOR UIC
	MOV	(R3)+,(R3)
	CLC
	RETURN

;+
; SCAN ASCII STRING UNTIL FIND TERMINATING CHAR
; CONVERT TO NUMBER OR -1 IF WILD CARD, RETURN @R3
; CALLING SEQUENCE:
;	CALL	SCNCVT
; INPUTS:
;	R1 = STRING SIZE
;	R2 = STRING ADDRESS
;	R3 = ADDRESS TO RETURN VALUE
;	R4 = TERMINATING CHARACTER TO MATCH
; OUTPUTS:
;	C=0 IF OK, C=1 IF SYNTAX ERROR
;	R1,R2 UPDATED TO REFLECT CHARACTERS SCANNED
;	R4,R5 ALTERED
;	R0,R3 PRESERVED
;-
SCNCVT:	MOV	R2,R5		;SAVE STARTING CHARACTER ADDRESS
10$:	CMPB	R4,(R2)+
	BEQ	20$		;BRANCH IF THIS IS THE TERMINATOR
	SOB	R1,10$
	SEC			;RAN OUT OF CHARACTER, BAD SYNTAX
	RETURN
20$:	DEC	R1		;COUNT TERMINATOR
	CMPB	#'*,@R5		;WILD CARD?
	BNE	30$		;BRANCH IF NO
	MOV	#-1,@R3
	CLC
	RETURN
30$:	MOV	R2,R4
	SUB	R5,R4
	DEC	R4		;R4 = SIZE OF NUMERIC STRING
	CALL	.ODCVT
	RETURN
;
;+
; CONVERT PROJECT OR PROGRAMMER NUMBER IN R1 TO 3 CHAR RAD50 NAME
;	RETURNED IN R1
; CALLING SEQUENCE:
;	CALL	CDRNM
; INPUTS:
;	R0=STRING ADDRESS TO STORE CHARS IN (SCRATCH)
;	R1=NUMBER TO CONVERT
; OUTPUTS:
;	C=0 IF CONVERTED, C=1 IF HIGH BYTE OF R1 NON ZERO
;	R1=RAD50 CONVERSION OF NUMBER
;	R0,R2 ALTERED
;	R3-R5 PRESERVED
;-
CDRNM:	BIT	#177400,R1
	BEQ	20$		;BRANCH IF NO HIGH ORDER BITS SET
	SEC
	RETURN
20$:	MOV	PC,R2		;R2 NON 0, DON'T SUPPRESS LEAD 0'S
	CALL	$CBOMG		;CONVERT BINARY TO OCTAL MAGNITUDE
	SUB	#3,R0		;R0 POINTS AT LAST 3 CHARS
	CALL	$CAT5		;CONVERT ASCII TO RAD50
	CLC
	RETURN
;
;+
; CONVERT RAD50 NUMBER IN R1 TO BINARY VALUE IN R1
; CALLING SEQUENCE:
;	CALL	C5TB
; INPUTS:
;	R0=STRING ADDRESS (SCRATCH)
;	R1=RAD50 VALUE TO CONVERT
; OUTPUTS:
;	R1=BINARY VALUE
;	R0,R3-R5 PRESERVED
;	R2 ALTERED
;-
C5TB:	MOV	R0,-(SP)
	CALL	$C5TA		;CONVERT RAD50 TO ASCII
	CLRB	@R0
	SUB	#3,R0
	CALL	$COTB		;CONVERT OCTAL STRING TO BINARY
	MOV	(SP)+,R0
	RETURN
;
;
	.END

