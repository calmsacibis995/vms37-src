	.TITLE	ZOPEN
	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
; WRITTEN BY
;	M. JACK
;
; MODULE FUNCTION
;	I/O SERVICES FOR THE TASK IMAGE PATCHING UTILITY
;


;+
;	GLOBAL DEFINITIONS
;-

	.MCALL	FINIT$,	OPEN$W,	GCML$,	CSI$1,	CSI$2,	OPEN$,	FDOF$L
	.MCALL	FCSBT$,	NBOF$L,	GCMLD$,	CSI$,	CSI$SW,	CSI$ND,	CALL
	.MCALL	RETURN, GTSK$S, GPRT$S

	FDOF$L
	FCSBT$
	NBOF$L
	GCMLD$
	CSI$

	.SBTTL	SWITCH TABLE

;+
;	SWITCH TABLE FOR COMMAND STRING INTERPRETER
;-

SWITAB:	CSI$SW	RO,RDONLY,SWITCH,SET	; READ ONLY OPEN
	CSI$ND

	.SBTTL	FCSOPEN -- READ FILE SPECIFICATION AND OPEN FILES

;+
;
; GLOBAL ROUTINE FCSOPEN
;
; FUNCTION
;	INITIALIZE FCS AND OPEN FILES
;
; INPUTS
;	COMMAND STRING
;
; OUTPUTS
;	INITIALIZATION AND FILES OPENED
;
;-

FCSOPEN::
	JSR	R1,$SAV3	; SAVE REGISTERS
	FINIT$			; INITIALIZE FCS
	CLR	BLKNUM		; INITIALIZE VARIABLES
	CLR	BLKNUM+2	;
	CLR	WRITBK		;
	MOV	#ABSOLU,SWITCH	; DEFAULT ABSOLUTE MODE

	OPEN$W	#OUTFDB		; OPEN CONSOLE DEVICE
	BCS	10$		; TERMINATE IF OPEN FAILS

	CALL	SEGINIT		;INITIALIZE THE SEGMENT DESCRIPTOR TABLE

2$:	BISB	#GE.IND!GE.COM,CMLBLK+G.MODE ; ENABLE @ AND ;
	GCML$	#CMLBLK		; READ A COMMAND LINE
	BCC	3$		; CONTINUE IF NO ERRORS
	CMPB	#GE.EOF,G.ERR(R0) ; TEST FOR END OF FILE
	BEQ	10$		; EXIT IF END OF FILE
	MOV	#CMIERR,R0	; SET ERROR CODE IN R0
	BR	9$		; BRANCH TO OUTPUT MESSAGE

3$:	CSI$1	#CSIBLK,CMLBLK+G.CMLD+2,CMLBLK+G.CMLD ; PARSE FILE SPEC
	BCS	4$		; TEST FOR ERROR
	TST	C.CMLD(R0)	; SKIP NULL LINES
	BEQ	2$
	CSI$2	R0,INPUT	; CHECK FOR INPUT FILES
	BCS	4$		; THERE SHOULD BE NONE
	BITB	#CS.DVF!CS.DIF!CS.NMF!CS.WLD!CS.MOR,C.STAT(R0)
	BNE	4$		;
	CSI$2	R0,OUTPUT,#SWITAB ; CHECK FOR OUTPUT FILE
	BCS	4$		; CHECK FOR ERROR
	BITB	#CS.WLD!CS.MOR,C.STAT(R0) ; MUST NOT HAVE THESE
	BNE	4$		;
	BITB	#CS.NMF,C.STAT(R0) ; FILE NAME MUST BE PRESENT
	BEQ	4$		;

	MOV	#TSKFDB,R0	; LOAD FDB ADDRESS
	MOV	#STATBK,F.STBK(R0) ; INSERT STATISTICS BLOCK ADDRESS
	MOVB	#FO.RD,F.FACC(R0) ; ASSUME READ ACCESS
	BIT	#RDONLY,SWITCH	; TEST /RO SPECIFIED
	BNE	1$		; BRANCH IF IT WAS
	MOVB	#FO.MFY,F.FACC(R0) ; ASSUME MODIFY ACCESS
1$:	OPEN$	R0		; OPEN THE FILE
	BCS	6$		; BRANCH IF OPEN FAILED

	MOV	R0,R1		; POINT TO FDB
	MOV	#SAVRAT,R2	; POINT TO SAVE AREA
	MOV	#S.FATT/2,R3	; SET UP WORD COUNT
8$:	MOV	(R1)+,(R2)+	; SAVE RECORD ATTRIBUTES
	DEC	R3		; COUNT WORDS
	BNE	8$		;

	MOV	R0,R1		;
	ADD	#F.HIBK,R1	;
	MOV	STATBK+4,(R1)+	; SET END OF FILE DATA WITH
	MOV	STATBK+6,(R1)+	;  FILE SIZE FROM STATISTICS
	MOV	STATBK+4,(R1)+	;   BLOCK SINCE CHANCES ARE
	MOV	STATBK+6,@R1	;    EOF DATA IS WRONG
	INC	(R1)+		;
	CLR	(R1)+		;

	BICB	#GE.IND!GE.COM,CMLBLK+G.MODE ; DISABLE @ AND ;
	RETURN			; RETURN TO CALLER

;+
;	ERROR HANDLING
;-

6$:	MOV	#OPNERR,R0	; OPEN FAILURE
	BR	7$		;
4$:	MOV	#CSIERR,R0	; BAD FILESPEC
7$:	CALL	ERRPRT		; OUTPUT ERROR MESSAGE
	BR	2$		; GIVE USER A SECOND TRY

9$:	CALL	ERRPRT		; OUTPUT FATAL GCML ERROR MESSAGE
10$:	MOV	#SIGXIT,R0	; SET SIGNAL VALUE IN R0
	JMP	$SIGNL		; SIGNAL

	.SBTTL	VIRTZERO -- CALCULATE VIRTUAL ZERO DATA

;+
;
; GLOBAL ROUTINE REG0 VIRTZERO(SEGPTR,FUDGE)
;
; FUNCTION
;	CALCULATE VIRTUAL ZERO DATA FROM START BLOCK AND LOAD POINT
;
; INPUTS
;	SEGPTR	- POINTER TO ZAP SEGMENT TABLE ENTRY
;	FUDGE	- AMOUNT TO ADJUST STARTING DISK BLOCK
;
; OUTPUTS
;	SEGPTR	- SEGVIRT FILLED IN
;	VALUE	- NONE
;
;-

VIRTZERO::
	JSR	R1,$SAV3	; SAVE REGISTERS
	CLR	R2		; LOAD STARTING DISK BLOCK IN DP
	MOV	(R0)+,R3	;
	ADD	12(SP),R3	; ADJUST BY FUDGE AMOUNT
	MOV	#9.,R1		; SHIFT LEFT 9 BITS TO POSITION
1$:	ASL	R3		;
	ROL	R2		;
	DEC	R1		;
	BNE	1$		;
	SUB	(R0)+,R3	; SUBTRACT LOAD ADDRESS
	SBC	R2		;
	TST	(R0)+		; SKIP OVER A WORD
	MOV	R2,(R0)+	; PUT DOWN ANSWER
	MOV	R3,@R0		;
	RETURN			; RETURN TO CALLER

	.SBTTL	ROVZRO -- VIRTUAL ZERO CALCULATION FOR READONLY PSECTS

;+
;
; GLOBAL ROUTINE ROVZRO(BLKALN,HDRVBN,OFF32W,SEGPTR)
;
; FUNCTION
;	COMPUTE THE VIRTUAL ZERO FOR A READONLY AREA
;
; INPUTS
;	BLKALN	- NONZERO IF RO SECTION IS BLOCK ALIGNED (MULTI-USER)
;	HDRVBN	- VBN OF TASK HEADER TIMES 1000 OCTAL
;		  (WHAT THE OFF32W IS RELATIVE TO)
;	OFF32W	- OFFSET IN 32-WORD BLOCKS FROM HDRVBN AS COMPUTED
;		  FROM THE PAR TEMPLATES
;	SEGPTR	- POINTER TO SEGMENT DESCRIPTION ENTRY
;
; OUTPUTS
;	SEGPTR	- SEGVIRT FILLED IN
;	VALUE	- NONE
;
;-

ROVZRO::
	JSR	R1,$SAV5	; SAVE REGISTERS
	MOV	16(SP),R2	; POINT TO SEGMENT DESCRIPTOR
	CLR	R3		; LOAD OFF32W IN DP
	MOV	20(SP),R4	;
	MOV	#6,R5		; LOAD LOOP COUNT
1$:	ASL	R4		; SHIFT OFF32W LEFT 6 IN DP
	ROL	R3		;
	DEC	R5		;
	BNE	1$		;
	CLR	R0		; LOAD HDRVBN IN DP
	MOV	22(SP),R1	;
	ADD	R4,R1		; ADD OFF32W*64 AND HDRVBN IN DP
	ADC	R0		;
	ADD	R3,R0		;
	TST	24(SP)		; IS R/O SECTION BLOCK ALIGNED
	BEQ	2$		; SKIP IF NOT
	ADD	#777,R1		; ROUND TO BLOCK BOUNDARY
	ADC	R0		;
	BIC	#777,R1		;
2$:	SUB	2(R2),R1	; SUBTRACT LOAD ADDRESS IN DP
	SBC	R0		;
	MOV	R0,6(R2)	; PUT ANSWER DOWN
	MOV	R1,10(R2)	;
	RETURN			; RETURN TO CALLER

	.SBTTL SEGINIT -- SEGMENT DESCRIPTOR TABLE INITIALIZATION

;+
;
; ROUTINE SEGINIT
;
; FUNCTION
;	INITIALIZE THE SEGMENT TABLE POINTERS, AND STACK OVERFLOW
;
; INPUTS
;	NONE
;
; OUTPUTS
;	SEGMENT TABLE POINTERS SET AND STACK OVERFLOW SETUP
;	VALUE - NONE
;
;-

SEGINIT:
	MOV	TSKLIM,STKLIM		;SET THE STACK OVERFLOW VALUE
	ADD	#32.,STKLIM		;32 BYTES OF OVERFLOW
	CMP	SEGTAB,SEGEND		;DID TKB DO IT?
	BNE	2$			;YES THEN QUIT NOW
	GTSK$S	#BLKBUF			;GET THE TASK HIGH ADDRESS
	BCS	1$			;GIVE UP ON ERROR
	MOV	BLKBUF+26.,R0		;
	GPRT$S	,#BLKBUF		;GET THE TASK BASE ADDRESS
	BCS	1$			;GIVE UP ON ERROR
	ADD	$DSW,R0			;ADD IN THE BASE
	BIC	#1,R0			;ROUND DOWN AND MAKE EVEN
	MOV	R0,SEGEND		;STORE TOP ADDR
	MOV	TSKLIM+2,SEGTAB		;BASE OF TABLE
2$:	SUB	#10.,SEGEND		;ROOM FOR OVERFLOW AND ROUNDING
	CMP	SEGTAB,SEGEND		;ANY ROOM AT ALL?
	BHIS	1$			;NOT ENOUGH
	RETURN

1$:	MOV	#SEGERR,R0		;SEGMENT TABLE OVERLFOW
	MOV	#SIGXIT,R0		;SET SIGNAL VALUE
	JMP	$SIGNL			;SIGNAL


	.END
