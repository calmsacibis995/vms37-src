	.TITLE	ON - ON ERROR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ON ERROR DCLS COMMAND EXECUTION
;
; D. N. CUTLER 20-MAY-77
;
; MODIFIED BY:
;
;	V004	TMH0004		Tim Halvorsen	28-Dec-1981
;		Remove roundup before ALLDYNMEM - now done inside routine.
;
;	V003	TMH0003		Tim Halvorsen	27-Apr-1981
;		Make use of PRC_L_INDEPTH to determine if level 0 or not.
;
;	V002	TMH0002		Tim Halvorsen	11-Feb-1981
;		Use DCL$MARK rather than R6 as an error display pointer.
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARK and DCL$MARKEDTOKEN routines.
;
;	V001	TMH0001		Tim Halvorsen	09-Sep-1980
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
LEVELTBL:				;SEVERIY LEVEL TABLE
	.ASCII	<2>/ERRO/		;ERROR
	.ASCII	<4>/SEVE/		;SEVERE ERROR
	.ASCII	<0>/WARN/		;WARNING
	.ASCII	<1>/CONT/		;CONTROL Y
LEVELEND:				;

	.SBTTL	ON ERROR
;+
; DCL$ON - ON ERROR
;
; THIS ROUTINE IS CALLED AS  AN INTERNAL COMMAND TO EXECUTE THE ON DCLS COMMAND.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE ON CLAUSE IS PARSED AND THE CORRESPONDING ERROR LEVEL IS COMPUTED.
;	STORAGE IS ALLOCATED FOR THE THEN CLAUSE AND IT IS COPIED FOR SUBSEQUENT
;	REFERENCE WHEN AN ON CONDITION ACTUALLY EXISTS.
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO ESTABLISH ON CONDITION PARAMETERS.
;
;		R0 = DCL$_ONERR - INVALID ERROR LEVEL SPECIFIED.
;		R0 = DCL$_ONLEVL - ON CONDITION CAN NOT BE ESTABLISHED AT CURRENT
;			COMMAND LEVEL.
;		R0 = DCL$ONOVF - NO ROOM FOR ON CONDITION COMMAND TEXT.
;		R0 = DCL$_PARMDEL - INVALID PARAMETER DELIMITER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = DCL$NORMAL - NORMAL COMPLETION.
;-
 
DCL$ON::				;ON ERROR
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BSBW	90$			;CHECK FOR BLANK TERMINATOR
	BSBW	80$			;MOVE TERMINATOR, GET TOKEN, AND CHECK
	CMPL	#4,R1			;ERROR LEVEL LONGER THAN 4 CHARACTERS
	BGEQ	10$			;IF GEQ NO
	MOVL	#4,R1			;SET LENGTH OF ERROR LEVEL TO 4
10$:	MOVAB	LEVELTBL,R5		;GET ADDRESS OF ERROR LEVEL NAME TABLE
	MOVL	#<LEVELEND-LEVELTBL>/5,R7 ;SET LOOP COUNT
20$:	MOVQ	R1,R3			;COPY ERROR LEVEL NAME PARAMETERS
	MOVZBL	(R5)+,R8		;SAVE ERROR LEVEL NUMBER
	MOVL	R5,R0			;SET ADDRESS OF ERROR LEVEL NAME
	TSTL	(R5)+			;POINT TO NEXT ENTRY IN TABLE
30$:	CMPB	(R0)+,(R4)+		;CHARACTERS MATCH?
	BNEQ	40$			;IF NEQ NO
	SOBGTR	R3,30$			;ANY MORE CHARACTERS TO COMPARE?
	BRB	50$			;
40$:	SOBGTR	R7,20$			;ANY MORE ENTRIES TO COMPARE?
	STATUS	ONERR			;SET INVALID ERROR LEVEL SPECIFIED STATUS
	RSB				;
 
;
; LEGAL ERROR LEVEL - PARSE THEN CLAUSE
;
 
50$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBB	80$			;MOVE TERMINATOR, GET TOKEN, AND CHECK
	STATUS	INVKEY			;ASSUME INVALID KEYWORD
	CMPL	(R2),#^A'THEN'		;CHECK FOR REQUIRED KEYWORD
	BNEQ	79$			;BR IF NOT VALID
	BSBW	DCL$MOVCHAR		;MOVE SPACE DELIMITER
	BSBW	DCL$SETNBLK		;SET TO FIRST NON-BLANK CHARACTER
	BSBW	DCL$MARK		;MARK START OF THEN CLAUSE
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) ;DISABLE "@" FILE RECOGNITION
60$:	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BNEQ	60$			;UNTIL END OF LINE
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;ENABLE "@" FILE RECOGNITION
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF THEN CLAUSE
					; (INCLUDING EOL CHARACTER)
	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND IN PROGRESS
	CMPB	#WRK_C_INPBUFSIZ,R1	;ON COMMAND TEXT TOO LARGE FOR INPUT BUFFER?
	BLSSU	130$			;IF LSSU YES
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),70$ ;IF SET, NONINTERACTIVE JOB
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL NONZERO?
	BEQL	110$			;IF EQL NO
70$:	MOVQ	R1,R6			;SAVE DESCRIPTOR OF THEN CLAUSE
	DISABLE				;DISABLE CONTROL Y/C AST'S
	CLRQ	(SP)+			;REMOVE RETURN INFORMATION FROM STACK
	BLBC	R8,72$			;BR IF ON CONDITION COMMAND
	BSBB	DCL$ONCTLYRST		;RESET ON CONTROL Y COMMAND
	BRB	74$			;
72$:	BSBB	DCL$ONRESET		;RESET ON ERROR PARAMETERS
74$:	ADDL3	#1,R6,R1		;ADD BYTE FOR LENGTH
	BSBW	DCL$ALLDYNMEM		;ALLOCATE THE MEMORY
	BLBC	R0,120$			;IF LBC ALLOCATION FAILURE
	BLBC	R8,76$			;BR IF DOING ON CONDITION
	MOVL	R2,PRC_L_ONCTLY(R11)	;SET ON CONTROL Y HANDLER
	BRB	78$			;
76$:	MOVL	R2,PRC_L_ONERROR(R11)	;SAVE ADDRESS OF ON ERROR TEXT BUFFER
	MOVW	R8,PRC_W_ONLEVEL(R11)	;SAVE ON ERROR LEVEL
78$:	MOVB	R1,(R2)+		;SAVE LENGTH OF ON TEXT BUFFER
	MOVC	R6,(R7),(R2)		;MOVE TEXT TO ON ERROR BUFFER
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
79$:	RSB				;
 
;
; MOVE TERMINATOR, GET TOKEN, AND CHECK FOR BLANK TERMINATOR
;
 
80$:	BSBW	DCL$MOVTOKN		;MOVE TERMINATOR AND GET TOKEN
90$:	CMPB	#^A/ /,R0		;BLANK TERMINATOR?
	BNEQ	100$			;IF NEQ NO
	RSB				;
100$:	TSTL	(SP)+			;CLEAN STACK
	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER
	RSB				;
 
;
; INVALID ON CONDITION LEVEL
;
 
110$:	STATUS	ONLEVL			;SET INVALID ON CONDITION LEVEL STATUS
	RSB				;
 
;
; NO ROOM TO ALLOCATE ON COMMAND TEXT
;
 
120$:	STATUS	ONOVF			;SET NO ROOM FOR COMMAND TEXT STATUS
	RSB				;
 
;
; ON COMMAND TEXT TOO LARGE FOR INPUT BUFFER
;
 
130$:	STATUS	ONCOMD			;SET ON COMMAND TO COMPLEX STATUS
	RSB				;

	.SBTTL	RESET ON ERROR PARAMETERS
;+
; DCL$ONRESET - RESET ON ERROR PARAMETERS
;
; THIS ROUTINE IS CALLED TO RESET THE ON ERROR PARAMETERS TO THEIR DEFAULT
; VALUES.
;
; INPUTS:
;
;	NONE.
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED.
;
; OUTPUTS:
;
;	IF AN ON ERROR COMMAND BUFFER IS CURRENTLY ALLOCATED, THEN IT IS RETURNED
;	TO THE DYNAMIC STORAGE REGION. THE ON ERROR LEVEL IS SET TO 'ERROR' AND
;	THE ON ERROR COMMAND TEXT POINTER IS CLEARED.
;-
	.ENABL	LSB
 
DCL$ONCTLYRST::				;ON CONTROL Y RESET
	MOVAB	PRC_L_ONCTLY(R11),R1	;ADDRESS OF HANDLER
	BRB	10$			;
 
DCL$ONRESET::				;RESET ON ERROR PARAMETERS
	MOVAB	PRC_L_ONERROR(R11),R1	;GET ADDRESS OF ON ERROR COMMAND TEXT
	MOVW	#2,PRC_W_ONLEVEL(R11)	;RESET ON ERROR LEVEL TO ERROR
10$:	MOVL	(R1),R0			;GET PRVIOUS HANDLER
	BEQL	20$			;IF EQL NONE
	CLRL	(R1)			;RESET PREVIOUS HANDLER
	PUSHAB	W^DCL$T_DEFONTXT	;GET ADDRESS OF DEFAULT "ON" TEXT
	CMPL	(SP)+,R0		;CHECK IF THAT IS THE STRING HERE
	BEQL	20$			;IF YES, DON'T DEALLOCATE THAT
	MOVZBL	(R0),R1			;GET LENGTH OF ON ERROR COMMAND TEXT
	BSBW	DCL$DEADYNMEM		;DEALLOCTE THE MEMORY
20$:	RSB				;
 
	.END
