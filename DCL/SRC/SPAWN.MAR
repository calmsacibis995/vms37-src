	.TITLE	SPAWN - MULTI-PROCESSING COMMANDS
	.IDENT	'V03-012'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; AUTHOR:
;
;	Tim Halvorsen, May 1981
;
; MODIFIED BY:
;
;	V012	PCG0006		Peter George	23-Apr-1982
;		Generalize /INPUT and /OUTPUT test so that all 
;		non-directory oriented device specs are recursively 
;		translated.
;
;	V011	SBL0001		Steven Lionel	21-Apr-1982
;		Check for /INPUT, /OUTPUT and command strings being
;		too long.  Don't return subprocess status as function
;		value of DCL$SPAWN2.
;
;	V010	PCG0005		Peter George	13-Apr-1982
;		Set default file specification field in FAB before
;		parsing /INPUT or /OUTPUT.  Do not ever default input
;		to NL: in /WAIT case.  Eliminate process termination
;		window.
;
;	V009	PCG0004		Peter George	31-Mar-1982
;		Accept logical names in /INPUT and /OUTPUT.
;		Check /INPUT for TRM and PPF.
;		Check terminal characteristics.
;
;	V008	PCG0003		Peter George	29-Mar-1982
;		Propagate hang-ups from child to parent.
;
;	V007	PCG0002		Peter George	04-Mar-1982
;		Fix bugs which cause:
;		- termination mailboxes to overflow
;		- CTXT to be overwritten by large symbols
;		- process creation failures to go unreported
;		- /NOWAIT subprocesses to $WAKE their parents
;
;	V006	TMH0006		Tim Halvorsen	19-Feb-1982
;		Fix bug in SPAWN which causes the linked list of pending
;		subprocesses to be "looped" whenever you try to create a
;		second subprocess without /PROCESS.
;		Increase size of termination mailbox, to allow more msgs.
;
;	V005	TMH0005		Tim Halvorsen	19-Jan-1982
;		Translate logical names SYS$INPUT and SYS$OUTPUT recursively.
;		Fix bug introduced in PCG0001 which caused any error to be
;		masked and overwritten with success on exit path.
;
;	V004	PCG0001		Peter George	13-Jan-1982
;		Save and restore AST context.
;
;	V003	TMH0003		Tim Halvorsen	06-Jan-1982
;		Save and restore event flag settings before and after
;		SPAWN and ATTACH routines.  Change to use event flags
;		21-23 rather than 0-2, to avoid possibility of conflict.
;
;	V002	TMH0002		Tim Halvorsen	28-Dec-1981
;		Add code to subprocess termination so that a caller
;		can request that a AST be called and/or an event flag
;		be set when a subprocess goes away.  Allow the caller
;		to specify the address of a longword to receive the
;		termination status when the process terminates.
;		Allow the caller to specify whether CLI symbols and/or
;		logical names are to be copied to the subprocess.
;
;	V001	TMH0001		Tim Halvorsen	1-Dec-1981
;		Add entry points to enable these routines to be
;		used from programs via CLI callbacks.
;		Fix multiple use of event flag numbers.
;		Prevent ATTACH to the current process.
;		Cause automatic logout in subprocess if either
;		the input filespec or the command string is specified.
;		Move autologout flag from cmdstr to header record.
;		Copy verification flag to subprocess.
;		Use PRIB field in SPWN rather than separate GETJPI request.
;		Detect termination of subprocess while attempting to write
;		context to its mailbox, preventing mailbox I/O hangs.
;		Return final status of subprocess upon SPAWN completion.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	PTRDEF				;DEFINE TOKEN DESCRIPTORS
	SYMDEF				;DEFINE SYMBOL TABLE ENTRY
	SPWNDEF				;DEFINE SPAWN LOCAL STORAGE
	CTXDEF				;DEFINE PROCESS CONTEXT MESSAGES
	TMBXDEF				;DEFINE TERMINATION MAILBOX STRUCTURE
	$DIBDEF				;DEFINE GETDEV INFO BUFFER
	$JPIDEF				;DEFINE GETJPI ITEM CODES
	$DVIDEF				;DEFINE GETDVI ITEM CODES
	$PQLDEF				;DEFINE PROCESS QUOTA TYPE CODES
	$LOGDEF				;DEFINE LOGICAL NAME ENTRY
	$ACCDEF				;TERMINATION RECORD FORMAT
	$CLIMSGDEF			;CLI MESSAGE CODES
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$FABDEF				;DEFINE FAB FIELDS
	$NAMDEF				;DEFINE NAM FIELDS
	$TT2DEF				;DEFINE DEVDEPEND2 FIELDS
;
; DEFINE EVENT FLAG NUMBERS USED HERE
;

	MIN_EFN = 21			; MINIMUM EVENT FLAG USED
	ASYNCH_EFN = 21			; EFN USED IN NON-AST ASYNCHRONOUS QIO
	SYNCH_EFN = 22			; EFN USED IN NON-AST SYNCHRONOUS QIOW
	AST_EFN = 23			; EFN USED IN AST-LEVEL QIO OR QIOW
	MAX_EFN = 23			; MAXIMUM EVENT FLAG USED

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

ATTMBX_MAXMSG = 16			; MAXIMUM SIZE OF ATTACH REQUEST MESSAGE

LOGINOUT:
	.ASCIC	'SYS$SYSTEM:LOGINOUT'	; IMAGE TO INITIALIZE DCL

PRCNAM_NAME:
	.ASCIC	'!AS_!UL'		; FAO STRING FOR DEFAULT PROCESS NAME
ATTACH_NAME:
	.ASCIC	'DCL$ATTACH_!XL'	; FAO STRING FOR ATTACH LOGNAME

SYS$INPUT:
	.ASCIC	'SYS$INPUT'		; DEFAULT INPUT STREAM
SYS$OUTPUT:
	.ASCIC	'SYS$OUTPUT'		; DEFAULT OUTPUT STREAM
NL:
	.ASCIC	'_NL:'			; NULL DEVICE
COM:
	.ASCIC	'.COM'			; DEFAULT INPUT FILE TYPE
LOG:
	.ASCIC	'.LOG'			; DEFAULT OUTPUT FILE TYPE

	.SBTTL	SPAWN COMMAND
;+
; DCL$SPAWN - SPAWN COMMAND
;
; THIS ROUTINE IS CALLED TO EXECUTE THE DCL SPAWN COMMAND.  THE SPAWN
; COMMAND CREATES A "CLONED" SUBPROCESS WITH THE FOLLOWING CONTEXT COPIED
; FROM THE PARENT TO THE SUBPROCESS:
;
;	1) ALL CLI SYMBOLS
;	2) ALL PROCESS LOGICAL NAMES
;	3) DEFAULT DISK AND DIRECTORY
;	5) CURRENT PROCESS PRIVILEGES
;	6) CURRENT COMMAND VERIFICATION STATE
;	7) CURRENT "ON CONTROL" (OUT-OF-BAND) STATE
;
; NO PROCESS PERMANENT OPEN FILES ARE COPIED, NOR IS ANY IMAGE OR PROCEDURE
; CONTEXT.  THE SUBPROCESS IS SET TO PROCEDURE LEVEL 0.  LOGIN.COM IS NOT
; EXECUTED, BOTH BECAUSE THE CONTEXT IS COPIED SEPARATELY AND TO CAUSE THE
; SUBPROCESS TO INITIALIZE QUICKLY.  THE PARENT IS LEFT IN HIBERNATION STATE
; UNTIL THE SUBPROCESS TERMINATES OR TRANSFERS CONTROL BACK TO THE PARENT VIA
; THE ATTACH COMMAND.
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
;	R2-R9 DESTROYED.
;-
 
DCL$SPAWN::
;
; ALLOCATE SOME SPACE FOR SPAWN STORAGE
;
	MOVZWL	#SPWN_C_LENGTH,R1	; LENGTH OF STORAGE TO ALLOCATE
	BSBW	DCL$ALLDYNMEM		; ALLOCATE STORAGE
	BLBS	R0,10$			; BRANCH IF OK
	RSB				; IF ERROR DETECTED, REPORT IT
10$:	MOVL	R2,R6			; POINT TO SPWN STORAGE
	MOVC5	#0,(R1),#0,#SPWN_C_LENGTH,(R6)	; ZERO THE BLOCK
					; (WITHOUT DESTROYING R1)
	MOVW	R1,SPWN_W_SIZE(R6)	; STORE SIZE OF BLOCK
	BISW	#SPWN_M_LOG!SPWN_M_WAIT!-	; ASSUME /LOG, /WAIT
		SPWN_M_CLISYM!SPWN_M_LOGNAM,-	; COPY CLI SYMBOLS & LOGNAMES
		SPWN_W_FLAGS(R6)
	MNEGB	#1,SPWN_B_EFN(R6)	; DO NOT SET EVENT FLAG ON TERMINATION
;
; PROCESS THE VERB QUALIFIERS ON THE COMMAND LINE
;
40$:	BSBW	DCL$GETDVAL		; GET NEXT TOKEN
	BLBC	R0,43$			; IF EOL, END OF PROCESSING
	CMPL	R5,#PTR_K_COMDQUAL	; VERB QUALIFIER?
	BEQL	42$			; BRANCH IF SO
	CMPL	R5,#PTR_K_PARAMETR	; PARAMETER (COMMAND STRING)?
	BNEQ	40$			; IF NOT, IGNORE IT
	MOVQ	R1,SPWN_Q_CMDSTR(R6)	; SAVE DESCRIPTOR OF COMMAND STRING
	BRB	40$
43$:	BRW	50$			; END OF COMMAND PARSING
42$:	CMPB	R1,#CLI$K_SPAW_INPU	; /INPUT?
	BEQL	45$
	CMPB	R1,#CLI$K_SPAW_OUTP	; /OUTPUT?
	BEQL	46$
	CMPB	R1,#CLI$K_SPAW_LOG	; /LOG?
	BEQL	47$
	CMPB	R1,#CLI$K_SPAW_PROC	; /PROCESS_NAME?
	BEQL	48$
	CMPB	R1,#CLI$K_SPAW_WAIT	; /WAIT?
	BEQL	49$
	BRB	40$			; IF NONE OF THE ABOVE QUALS, IGNORE IT
49$:	SETBIT	SPWN_V_WAIT,SPWN_W_FLAGS(R6)	; ASSUME /WAIT
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,40$ ; IGNORE IF NOT /NOWAIT
	CLRBIT	SPWN_V_WAIT,SPWN_W_FLAGS(R6)	; CLEAR WAIT FLAG
	BRB	40$
47$:	SETBIT	SPWN_V_LOG,SPWN_W_FLAGS(R6)	; ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,40$ ; IGNORE IF NOT /NOLOG
	CLRBIT	SPWN_V_LOG,SPWN_W_FLAGS(R6)	; CLEAR LOG MESSAGE FLAG
	BRB	40$
45$:	CMPB	R4,#PTR_K_COLON		; IS A VALUE PRESENT?
	BNEQ	40$			; IF NOT, USE DEFAULT
	BSBW	DCL$GETDVAL		; GET /INPUT VALUE
	MOVQ	R1,SPWN_Q_INPUT(R6)	; USE EXPLICIT INPUT STREAM
	BRB	40$
46$:	CMPB	R4,#PTR_K_COLON		; IS A VALUE PRESENT?
	BNEQ	40$			; IF NOT, USE DEFAULT
	BSBW	DCL$GETDVAL		; GET /OUTPUT VALUE
	MOVQ	R1,SPWN_Q_OUTPUT(R6)	; USE EXPLICIT OUTPUT STREAM
	BRB	40$
48$:	CMPB	R4,#PTR_K_COLON		; IS A VALUE PRESENT?
	BNEQ	41$			; IF NOT, USE DEFAULT
	BSBW	DCL$GETDVAL		; GET VALUE
	MOVQ	R1,SPWN_Q_PRCNAM(R6)	; USE EXPLICIT PROCESS NAME
	SETBIT	SPWN_V_PRCNAM,SPWN_W_FLAGS(R6) ; SET PROCESS NAME SPECIFIED
41$:	BRW	40$
;
; THE PARSING IS COMPLETE, AND ALL OPTIONS ARE SET INTO THE SPWN
; BLOCK.  NOW PERFORM THE SPAWN OPERATION.
;
50$:	BSBB	DCL$SPAWN2		; PERFORM THE SPAWN OPERATION
	BLBC	R0, 60$			; TEST FOR FAILURE OF SPAWN ITSELF
	MOVL	R1, R0			; GET SUBPROCESS TERMINATION STATUS
60$:	RSB

	.SBTTL	SPAWN A SUBPROCESS
;---
;
; THIS ROUTINE IS CALLED TO PERFORM THE ACTUAL CREATION OF THE SUBPROCESS.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN PARAMETER BLOCK
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = FINAL STATUS FROM COMPLETED SUBPROCESS
;	SPWN_L_PID(R6) = PID OF SUBPROCESS (IF NOWAIT FLAG SPECIFIED)
;---

DCL$SPAWN2::
	PUSHR	#^M<R2,R3,R4,R5,R7,R8>	; SAVE REGISTERS
;
; CONTROL/Y AST'S ARE DISABLED THROUGHOUT THIS COMMAND, TO ENSURE THAT
; MAILBOXES WHICH ARE CREATED HERE ARE CORRECTLY DELETED, ETC.  AS A
; RESULT, WE MUST PERIODICALLY CHECK THE HANGUP FLAG IN CASE A HANGUP
; IS DETECTED WHILE WE ARE OPERATING.
;
	MOVL	PRC_L_OUTOFBAND(R11),-	; SAVE OUT-OF-BAND ENABLE MASK
		SPWN_L_OUTOFBAND(R6)
	CLRL	R1			; DISABLE ALL OUT-OF-BAND AST'S
	BSBW	DCL$RESETOOB
;
; SAVE THE CURRENT SETTINGS OF THE EVENT FLAGS USED DURING THIS ROUTINE,
; SO THAT WE CAN RESTORE THEM ON EXIT.  THIS IS SO THAT THE IMAGE CONTEXT
; IS NOT DESTROYED BY EITHER THE SPAWN DCL COMMAND OR LIB$SPAWN.
;
	MOVAL	-(SP),R0		; PUSH EVENT FLAG STATES ON STACK
	$READEF_S EFN=#0,-		; READ EVENT FLAG CLUSTER 0
		STATE=(R0)		; INTO LONGWORD ON STACK
;
; PRE-CLEAR THE TERMINATION EVENT FLAG, IF ONE IS SPECIFIED.
;
	TSTB	SPWN_B_EFN(R6)		; EVENT FLAG SPECIFIED?
	BLSS	2$			; BRANCH IF NONE
	$CLREF_S EFN=SPWN_B_EFN(R6)	; PRE-CLEAR IT
;
; SAVE THE PREVIOUS ACCESS MODE, FOR PROBING RETURN STATUS AND DELIVERING
; TERMINATION ASTS.
;
2$:	MOVPSL	R0			; GET CURRENT PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R0,R0 ; EXTRACT PREVIOUS ACMODE
	MOVB	R0,SPWN_B_ACMODE(R6)	; SAVE THE ACCESS MODE
;
; ALLOCATE SOME SCRATCH STORAGE ON THE STACK
;
	MOVAB	-512(SP),SP		; ALLOCATE SCRATCH BUFFER ON STACK
	PUSHL	SP			; CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZWL	#512,-(SP)
	MOVL	SP,R8			; AND POINT TO IT

;
; FIND A TERMINATION MAILBOX SLOT
;
	ASSUME	TMBX_L_LINK EQ 0
	MOVAB	PRC_L_TMBX(R11),R7	; GET ADDRESS OF TMBX BLOCK LIST HEAD
10$:	MOVL	TMBX_L_LINK(R7),R7	; GET NEXT BLOCK IN LIST
	BEQL	20$			; CREATE NEW MBX IF END OF LIST
	CMPB	TMBX_B_REFS(R7),-	; DOES MBX HAVE ANY OPEN SLOTS?
		#TMBX_C_MAXREFS
	BEQL	10$			; NO, LOOK AT NEXT MBX IN LIST
	INCB	TMBX_B_REFS(R7)		; YES, GRAB ONE
	MOVW	TMBX_W_UNIT(R7),-	; COPY THE UNIT NUMBER
		SPWN_W_UNIT(R6)		
	BRW	50$			; NO NEED TO CREATE A MBX

;
; ALLOCATE A NEW TMBX BLOCK AND LINK IT INTO THE LIST.
;
20$:	MOVZWL	#TMBX_C_LENGTH,R1	; LENGTH OF STORAGE TO ALLOCATE
	BSBW	DCL$ALLDYNMEM		; ALLOCATE STORAGE
	BLBC	R0,92$			; BRANCH ON ERROR
	MOVL	R2,R7			; SET ADDRESS OF TMBX BLOCK
	MOVB	#1,TMBX_B_REFS(R7)	; SET REFERENCE COUNT TO MAILBOX
	MOVL	R11,TMBX_L_PRC(R7)	; STORE BASE OF PROCESS WORK AREA
	MOVL	PRC_L_TMBX(R11),-	; INSERT BLOCK INTO LINKED LIST
		TMBX_L_LINK(R7)
	MOVL	R7,PRC_L_TMBX(R11)

;
; CREATE THE MAILBOX AND ENABLE THE AST.
;
	$CREMBX_S CHAN=TMBX_W_CHANNEL(R7),- ; CREATE A TERMINATION MAILBOX
		BUFQUO=#TMBX_C_MAXREFS*ACC$C_TERMLEN	; NEED TO HOLD AS MANY 
					; MESSAGES AS ALLOWED BROTHERS
	BLBC	R0,91$			; BRANCH ON ERROR
	$QIO_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,- ; SET ATTENTION AST ON MAILBOX
		CHAN=TMBX_W_CHANNEL(R7),-
		EFN=#ASYNCH_EFN,-
		P1=W^TERMINATION_AST,-	; ADDRESS OF AST ROUTINE
		P2=R7			; PASS TMBX BLOCK
	BLBS	R0,5$			; BRANCH IF OK
	PUSHL	R0			; SAVE ERROR STATUS
	$DASSGN_S CHAN=TMBX_W_CHANNEL(R7) ; DELETE TERMINATION MAILBOX
	POPL	R0			; RESTORE ERROR STATUS
91$:	BRW	SPAWN_EXIT		; EXIT WITH ERROR STATUS
92$:	BRW	SPAWN_EXIT_NOTMBX	; EXIT WITHOUT DEALLOCATING TMBX

;
; GET UNIT NUMBER OF TERMINATION MAILBOX
;
5$:	$GETCHN_S CHAN=TMBX_W_CHANNEL(R7),-	 ; GET MAILBOX INFORMATION
		PRIBUF=(R8)
	BLBC	R0,91$				 ; BRANCH ON ERROR
	MOVW	DIB$W_UNIT+8(R8),SPWN_W_UNIT(R6) ; SAVE MAILBOX UNIT NUMBER
	MOVW	DIB$W_UNIT+8(R8),TMBX_W_UNIT(R7) ;   IN BOTH SPWN AND TMBX

;
; CREATE AN INPUT MAILBOX TO COPY THE CONTEXT TO THE SUBPROCESS
;
50$:	$CREMBX_S CHAN=SPWN_W_CHAN(R6)	; CREATE COMMUNICATIONS MAILBOX
	BLBC	R0,95$			; BRANCH ON ERROR
	CLRL	-(SP)			; CREATE GETDVI ITEM LIST
	PUSHAB	SPWN_Q_MBXNAM(R6)	; ADDRESS OF WORD TO RECEIVE LENGTH
	MOVQ	(R8),-(SP)		; SET DESCRIPTOR OF BUFFER
	MOVW	#DVI$_DEVNAM,2(SP)	; REQUEST COMPLETE DEVICE NAME
	MOVL	SP,R0
	$GETDVI_S CHAN=SPWN_W_CHAN(R6),- ; GET MAILBOX DEVICE NAME
		EFN=#SYNCH_EFN,-
		ITMLST=(R0)
	ADDL	#4*4,SP			; POP GETDVI ITEM LIST
	BLBC	R0,95$			; BRANCH IF ERROR DETECTED
	MOVL	4(R8),SPWN_Q_MBXNAM+4(R6) ;SET ADDRESS OF BUFFER
	SUBW	SPWN_Q_MBXNAM(R6),(R8)	; MARK DEVICE NAME NO LONGER SCRATCH
	ADDL	SPWN_Q_MBXNAM(R6),4(R8)
	BRB	55$			; CREATE THE PROCESS
95$:	BRW	SPAWN_EXIT		; PROCESS ERROR CONDITION

;
; CREATE AN ATTACH MAILBOX TO HANDLE RE-ATTACH REQUESTS TO THIS PROCESS.
;
55$:	BSBW	CREATE_ATTMBX		; CREATE OUR ATTACH MAILBOX
	BLBC	R0,95$			; BRANCH IF ERROR DETECTED

;
; DETERMINE IF AN AUTOMATIC LOGOUT SHOULD OCCUR AFTER EXECUTION OF THE
; COMMAND STRING.  IF ONLY THE COMMAND STRING WAS SPECIFIED, THEN LOGOUT
; AFTER IT IS EXECUTED AND DEFAULT THE INPUT TO THE NULL DEVICE. IF BOTH 
; THE COMMAND STRING AND /INPUT WERE SPECIFIED, THEN CAUSE THE COMMAND 
; STRING TO BE EXECUTED FIRST, FOLLOWED BY THE /INPUT STREAM.  IF NEITHER 
; /INPUT NOR A COMMAND LINE WAS SPECIFIED, AND SPAWNING /NOWAIT, THEN
; DEFAULT THE INPUT TO THE CURRENT SYS$INPUT AND SKIP ALL INPUT PARSING 
; AND CHECKING.
;
60$:	CMPW	SPWN_Q_CMDSTR(R6),#132	; COMMAND STRING TOO LONG?
	BLEQU	61$			; SKIP IF NOT
	MOVL	#CLI$_BUFOVF,R0		; COMMAND BUFFER OVERFLOW
	BRW	SPAWN_EXIT		; EXIT WITH STATUS
61$:	TSTW	SPWN_Q_INPUT(R6)	; /INPUT SPECIFIED?
	BNEQ	70$			; MAKE INPUT EXECUTED AFTER CMDSTR
					; BY KEEPING AUTOLOGO FLAG OFF
	MOVZBL	SYS$INPUT,SPWN_Q_INPUT(R6)	; GET LENGTH OF "SYS$INPUT"
	MOVAB	SYS$INPUT+1,SPWN_Q_INPUT+4(R6)	; GET ADDRESS OF STRING
	TSTW	SPWN_Q_CMDSTR(R6)	; ANY COMMAND STRING SPECIFIED?
	BEQL	70$			; IF SO, IMPLIED LOGOUT
	SETBIT	SPWN_V_AUTOLOGO,SPWN_W_FLAGS(R6) ; SET IMPLIED LOGOUT FLAG
	BBS	#SPWN_V_WAIT,SPWN_W_FLAGS(R6),70$ ; SKIP IF /WAIT
	MOVZBL	NL,SPWN_Q_INPUT(R6)	; GET LENGTH OF "NL:"
	MOVAB	NL+1,SPWN_Q_INPUT+4(R6) ; GET ADDRESS OF STRING
	BRW	80$			; NO NEED TO PARSE "NL:"

;
; PARSE INPUT FILE SPECIFICATION
;
70$:	MOVAB	-FAB$C_BLN-NAM$C_BLN(SP),SP	; ALLOCATE STORAGE
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN,(SP)	; ZERO THE STORAGE
	MOVL	SP,R4				; GET BASE OF FAB
	MOVAB	FAB$C_BLN(R4),R5		; GET BASE OF NAM
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R4)	; INITIALIZE FAB
	SETBIT	FAB$V_PPF,FAB$L_FOP(R4)		; USE PROCESS I/O SEGMENT
	CMPW	SPWN_Q_INPUT(R6),#255		; NAME TOO LONG?
	BLEQU	711$				; IF SO, ERROR
	MOVL	#CLI$_INVFILSPE,R0		; INVALID FILE SPEC
	BRB	712$				; EXIT WITH STATUS
711$:	MOVB	SPWN_Q_INPUT(R6),FAB$B_FNS(R4)	; INSERT FILE NAME INTO FAB
	MOVL	SPWN_Q_INPUT+4(R6),FAB$L_FNA(R4)
	MOVB	COM,FAB$B_DNS(R4)		; INSERT DEFAULT FILE TYPE
	MOVAB	COM+1,FAB$L_DNA(R4)
	MOVL	R5,FAB$L_NAM(R4)		; GET POINTER TO NAM BLOCK
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R5)	; INITIALIZE NAM
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R5)	; POINT TO RESULT SPACE
	MOVL	4(R8),NAM$L_ESA(R5)
	$PARSE	FAB=(R4)			; PARSE THE FILE SPEC
712$:	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; RESTORE SP (NOTE THAT FAB
						; AND NAM ARE STILL USED BELOW)
	BLBC	R0,71$				; EXIT IF ERROR

;
; IF INPUT IS FROM A NON-DIRECTORY ORIENTED DEVICE, THEN RECURSIVELY 
; TRANSLATE THE LOGICAL NAME. IF INPUT IS FROM A DIRECTORY ORIENTED DEVICE, 
; BUT IS A PPF, THEN SIGNAL AN ERROR. IF INPUT IS FROM A DIRECTORY ORIENTED
; DEVICE, AND NOT A PPF, THEN USE THE ESS AS SYS$INPUT.
;
	PUSHL	#0				; ASSUME INPUT IS NOT A TERMINAL
	BBC	#DEV$V_TRM,FAB$L_DEV(R4),713$	; IS INPUT A TERMINAL?
	MOVL	#1,(SP)				; INDICATE INPUT IS A TERMINAL
713$:	BBC	#DEV$V_DIR,FAB$L_DEV(R4),74$	; IS INPUT A NON-DIR DEVICE?
	POPL	R0				; RESTORE THE STACK
	BBC	#NAM$V_PPF,NAM$L_FNB(R5),72$	; PPF FILE?
	MOVL	#CLI$_SPWNIO,R0  		; SET STATUS
71$:	BRW	SPAWN_EXIT			; EXIT WITH ERROR

;
; INPUT IS A DIRECTORY ORIENTED DEVICE AND NOT A PPF, USE THE ESS AS SYS$INPUT.
; ALSO, SET THE EOF SILENT LOGOUT FLAG.
;
72$:	MOVZBL	NAM$B_ESL(R5),R0		; GET LENGTH OF RESULT STRING
	MOVL	R0,SPWN_Q_INPUT(R6)		; USE RESULT AS INPUT FILE SPEC
	MOVL	NAM$L_ESA(R5),SPWN_Q_INPUT+4(R6)
	SUBL	R0,(R8)				; REMOVE RESULT FROM SCRATCH AREA
	ADDL	R0,4(R8)
	SETBIT	SPWN_V_EOFLOGO,SPWN_W_FLAGS(R6) ; SET EOF SILENT LOGOUT FLAG
	BRW	80$

;
; INPUT IS FROM A NON-DIRECTORY ORIENTED DEVICE, RECURSIVELY TRANSLATE THE 
; LOGICAL NAME.
;
74$:	MOVQ	SPWN_Q_INPUT(R6),R2	; COPY DESCRIPTOR OF DEVICE NAME
	MOVQ	(R8),R4			; COPY DESCRIPTOR OF SCRATCH AREA
	BSBW	TRANSLATE		; TRANSLATE LOGICAL NAME
	MOVQ	R4,SPWN_Q_INPUT(R6)	; SAVE EQUIVALENCE STRING
	SUBW	R1,(R8)			; MARK TRANSLATION NO LONGER SCRATCH
	ADDL	R1,4(R8)

;
; CHECK TERMINAL CHARACTERISTICS.  DO NOT SPAWN THE SUBPROCESS IF THE 
; TERMINAL HAS AN ASSOCIATED MAILBOX.  ISSUE A WARNING IF OUT-OF-BAND OR
; CTRL/C AST'S ARE DECLARED FOR THE TERMINAL.
;
	TSTL	(SP)+			; IS DEVICE A TERMINAL?
	BEQL	80$			; NO, THEN SKIP TESTS
	MOVAL	-(SP),R2		; ALLOCATE LONGWORD FOR CHANNEL NUMBER
	SUBL	#12,SP			; ALLOCATE DEVICE CHARACTERISTICS BUFFER
	MOVL	SP,R3			; SAVE BUFFER ADDRESS
	$ASSIGN_S DEVNAM=SPWN_Q_INPUT(R6),-	; GET A CHANNEL TO THE TERMINAL
		CHAN=(R2)
	BLBC	R0,78$			; BRANCH IF ERROR
	$QIOW_S	FUNC=#IO$_SENSEMODE,- 	; GET TERMINAL CHARACTERISTICS
		CHAN=(R2),-
		EFN=#SYNCH_EFN,-
		P1=(R3),-
		P2=#12
	BLBC	R0,78$			; BRANCH IF ERROR
	$DASSGN_S CHAN=(R2) 		; DEASSIGN TERMINAL CHANNEL
	BLBC	R0,78$			; BRANCH IF ERROR
	MOVL	#CLI$_TRMMBX,R0		; ASSUME ASSOCIATED TERMINAL MBX
	BBS	#TT2$V_DCL_MAILBX,8(R3),78$	; EXIT WITH ERROR IF TRUE
	BBS	#TT2$V_DCL_OUTBND,8(R3),76$	; SIGNAL WARNING IF OUT-OF-BAND AST'S
	BBC	#TT2$V_DCL_CTRLC,8(R3),77$	; SIGNAL WARNING IF CTRL/C AST'S
76$:	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),77$ ;BRANCH IF /NOLOG SPECIFIED
	MOVL	#CLI$_ASTDCL,R0		; SET STATUS
	CLRL	R2			; NO FAO ARGUMENT
	BSBW	MESSAGE			; ISSUE WARNING
77$:	ADDL	#4+12,SP		; RESTORE STACK
	BRB	80$			; CONTINUE

78$:	ADDL	#4+12,SP		; RESTORE STACK
79$:	BRW	SPAWN_EXIT		; EXIT WITH ERROR

;
; CHECK THAT INPUT FILE SPEC IS NOT TOO LONG FOR $CREPRC TO HANDLE.
;
80$:	MOVL	#CLI$_INVFILSPE,R0		; ASSUME SPEC IS TOO LONG
	CMPW	#63,SPWN_Q_INPUT(R6)		; IS IT REALLY?
	BLSSU	79$				; YES, THEN ERROR

;
; IF OUTPUT FILE SPECIFICATION NOT SPECIFIED, THEN USE CURRENT SYS$OUTPUT
;
	TSTW	SPWN_Q_OUTPUT(R6)		; OUTPUT FILESPEC SPECIFIED?
	BNEQ	81$				; BRANCH IF SO
	MOVZBL	SYS$OUTPUT,SPWN_Q_OUTPUT(R6)	; GET LENGTH OF "SYS$OUTPUT"
	MOVAB	SYS$OUTPUT+1,SPWN_Q_OUTPUT+4(R6); GET ADDRESS OF STRING

;
; PARSE OUTPUT FILE SPECIFICATION
;
81$:	MOVAB	-FAB$C_BLN-NAM$C_BLN(SP),SP	; ALLOCATE STORAGE
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN,(SP)	; ZERO THE STORAGE
	MOVL	SP,R4				; GET BASE OF FAB
	MOVAB	FAB$C_BLN(R4),R5		; GET BASE OF NAM
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R4)	; INITIALIZE FAB
	SETBIT	FAB$V_PPF,FAB$L_FOP(R4)		; USE PROCESS I/O SEGMENT
	CMPW	SPWN_Q_OUTPUT(R6),#255		; FILE NAME TOO LONG?
	BLEQU	811$				; ERROR IF SO
	MOVL	#CLI$_INVFILSPE,R0		; INVALID FILE SPECIFICATION
	BRB	812$				; EXIT WITH STATUS
811$:	MOVB	SPWN_Q_OUTPUT(R6),FAB$B_FNS(R4)	; INSERT FILE NAME INTO FAB
	MOVL	SPWN_Q_OUTPUT+4(R6),FAB$L_FNA(R4)
	MOVB	LOG,FAB$B_DNS(R4)		; INSERT DEFAULT FILE TYPE
	MOVAB	LOG+1,FAB$L_DNA(R4)
	MOVL	R5,FAB$L_NAM(R4)		; GET POINTER TO NAM BLOCK
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R5)	; INITIALIZE NAM
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R5)	; POINT TO RESULT SPACE
	MOVL	4(R8),NAM$L_ESA(R5)
	$PARSE	FAB=(R4)			; PARSE THE FILE SPEC
812$:	MOVAB	FAB$C_BLN+NAM$C_BLN(SP),SP  	; RESTORE SP (NOTE THAT FAB
						; AND NAM ARE STILL USED BELOW)
	BLBC	R0,84$				; EXIT IF ERROR

;
; IF OUTPUT IS FROM A NON-DIRECTORY ORIENTED DEVICE, THEN RECURSIVELY 
; TRANSLATE THE LOGICAL NAME. IF OUTPUT IS FROM A DIRECTORY ORIENTED DEVICE, 
; BUT IS A PPF, THEN SIGNAL AN ERROR. IF OUTPUT IS FROM A DIRECTORY ORIENTED
; DEVICE, AND NOT A PPF, THEN USE THE ESS AS SYS$OUTPUT.
;
	BBC	#DEV$V_DIR,FAB$L_DEV(R4),87$	; IS OUTPUT A NON-DIR DEVICE?
	BBC	#NAM$V_PPF,NAM$L_FNB(R5),82$	; PPF FILE?
	MOVL	#CLI$_SPWNIO,R0  		; SET STATUS
84$:	BRW	SPAWN_EXIT			; EXIT WITH ERROR

;
; OUTPUT IS A DIRECTORY OREINTED DEVICE, AND NOT A PPF, USE THE ESS AS 
; SYS$OUTPUT.
;
82$:	MOVZBL	NAM$B_ESL(R5),R0		; GET LENGTH OF RESULT STRING
	MOVL	R0,SPWN_Q_OUTPUT(R6)		; USE RESULT AS OUTPUT FILE SPEC
	MOVL	NAM$L_ESA(R5),SPWN_Q_OUTPUT+4(R6)
	SUBL	R0,(R8)				; REMOVE RESULT FROM SCRATCH AREA
	ADDL	R0,4(R8)
	BRB	88$

;
; OUTPUT IS FROM A NON-DIRECTORY ORIENTED DEVICE, RECURSIVELY TRANSLATE THE 
; LOGICAL NAME
;
87$:	MOVQ	SPWN_Q_OUTPUT(R6),R2	; COPY DESCRIPTOR OF DEVICE NAME
	MOVQ	(R8),R4			; COPY DESCRIPTOR OF SCRATCH AREA
	BSBW	TRANSLATE		; TRANSLATE LOGICAL NAME
	MOVQ	R4,SPWN_Q_OUTPUT(R6)	; SAVE EQUIVALENCE STRING
	SUBW	R1,(R8)			; MARK TRANSLATION NO LONGER SCRATCH
	ADDL	R1,4(R8)

;
; CHECK THAT OUTPUT FILE SPEC IS NOT TOO LONG FOR $CREPRC TO HANDLE.
;
88$:	MOVL	#CLI$_INVFILSPE,R0		; ASSUME SPEC IS TOO LONG
	CMPW	#63,SPWN_Q_INPUT(R6)		; IS IT REALLY?
	BLSSU	84$				; YES, THEN ERROR

;
; DETERMINE BASE PRIORITY FOR NEW SUBPROCESS FROM CURRENT BASE PRIORITY
;
	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAL	SPWN_L_PRIB(R6)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PRIB@16+4		; REQUEST CURRENT BASE PRIORITY
;
; DETERMINE CURRENT IMAGE COUNT (FOR USE BY TERMINATION AST)
;
	CLRL	-(SP)			; NO RETLEN ADDRESS
	PUSHAL	SPWN_L_IMAGCNT(R6)	; SET BUFFER ADDRESS
	PUSHL	#JPI$_IMAGECOUNT@16+4	; REQUEST CURRENT IMAGE COUNT
;
; DETERMINE CURRENT VALUES OF NON-DEDUCTIBLE QUOTAS, AND CREATE A QUOTA
; LIST WHICH WILL BE USED TO SET THE QUOTAS OF THE SUBPROCESS.
;
	MOVAB	SPWN_G_QUOTAS(R6),R3	; GET ADDRESS OF SPACE FOR LIST
	CLRL	-(SP)			; NO RETLEN ADDRESS
	MOVB	#PQL$_ASTLM,(R3)+	; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+			; SET BUFFER ADDRESS
	PUSHL	#JPI$_ASTLM@16+4	; REQUEST CURRENT ASTLM
	CLRL	-(SP)			; NO RETLEN ADDRESS
	MOVB	#PQL$_BIOLM,(R3)+	; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+			; SET BUFFER ADDRESS
	PUSHL	#JPI$_BIOLM@16+4	; REQUEST CURRENT BIOLM
	CLRL	-(SP)			; NO RETLEN ADDRESS
	MOVB	#PQL$_DIOLM,(R3)+	; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+			; SET BUFFER ADDRESS
	PUSHL	#JPI$_DIOLM@16+4	; REQUEST CURRENT DIOLM
	CLRL	-(SP)			; NO RETLEN ADDRESS
	MOVB	#PQL$_WSDEFAULT,(R3)+	; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+			; SET BUFFER ADDRESS
	PUSHL	#JPI$_WSSIZE@16+4	; REQUEST CURRENT WSDEFAULT
	CLRL	-(SP)			; NO RETLEN ADDRESS
	MOVB	#PQL$_WSQUOTA,(R3)+	; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+			; SET BUFFER ADDRESS
	PUSHL	#JPI$_WSQUOTA@16+4	; REQUEST CURRENT WSQUOTA
	CLRL	-(SP)			; NO RETLEN ADDRESS
	MOVB	#PQL$_WSEXTENT,(R3)+	; SET TYPE CODE IN PQL LIST
	PUSHAL	(R3)+			; SET BUFFER ADDRESS
	PUSHL	#JPI$_WSEXTENT@16+4	; REQUEST CURRENT WSEXTENT
	MOVB	#PQL$_LISTEND,(R3)+	; TERMINATE PQL LIST
	MOVL	SP,R0			; GET ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0),-		; GET CURRENT QUOTA VALUES
		EFN=#SYNCH_EFN
	ADDL	#8*12+4,SP		; POP ITEM LIST
;
; INSERT THE CURRENT SPWN BLOCK INTO THE LINKED LIST OF PENDING SUBPROCESSES,
; SO THAT IN CASE THE SUBPROCESS DIES WHILE WE ARE ATTEMPTING TO FEED IT
; CONTEXT, THE SUBPROCESS TERMINATION AST ROUTINE CAN DO SOMETHING ABOUT IT.
;
	SETBIT	SPWN_V_ACTIVE,SPWN_W_FLAGS(R6)	; MARK BLOCK CURRENTLY "ACTIVE"
	MOVL	PRC_L_SPWN(R11),SPWN_L_LINK(R6) ; INSERT INTO LINKED LIST
	MOVL	R6,PRC_L_SPWN(R11)	; PASS ADDRESS OF SPWN TO TERMINATION
					; AST, SO WE CAN FIND OUT IF IT DIES
;
; CONSTRUCT THE PROCESS NAME OF THE FORM <USERNAME>_1.  THE TRAILING
; NUMBER WILL BE INCREMENTED UNTIL WE FIND A UNIQUE PROCESS NAME.
;
	BBS	#SPWN_V_PRCNAM,SPWN_W_FLAGS(R6),SPAWN_PROCESS ; BRANCH IF /PROCESS GIVEN
	MOVL	#1,R4			; START WITH POSTFIX #1
CONSTRUCT_PRCNAM: 
	MOVAB	SPWN_Q_PRCNAM(R6),R3	; GET ADDRESS OF DESCRIPTOR SPACE
	CLRL	-(SP)			; MARK END OF JPI LIST
	PUSHL	R3			; ADDRESS TO STORE RETURN LENGTH
	MOVQ	(R8),-(SP)		; DESCRIPTOR OF STRING BUFFER
	MOVW	#JPI$_USERNAME,2(SP)	; SET PARAMETER ID TO RETRIEVE
	MOVL	SP,R0			; SET ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0),-		; GET USERNAME STRING
		EFN=#SYNCH_EFN
	ADDL	#4*4,SP			; REMOVE ITEM LIST FROM STACK
	MOVL	4(R8),4(R3)		; SET ADDRESS OF BUFFER
	LOCC	#^A' ',(R3),@4(R3)	; FIND END OF NAME
	SUBL	R0,(R3)			; TRUNCATE TO FIRST SPACE (IF ANY)
	ADDL3	(R3),4(R8),-(SP)	; COMPUTE SPACE LEFT AFTER PRCNAM
	SUBL3	(R3),(R8),-(SP)
	MOVAB	PRCNAM_NAME,R1		; GET ADDRESS OF FAO STRING
	MOVZBL	(R1)+,R0		; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R0,-(SP)		; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0			; GET ADDRESS OF DESCRIPTOR
	$FAO_S	CTRSTR=(R0),-		; CONSTRUCT MAILBOX DEVICE NAME
		OUTBUF=8(R0),-
		OUTLEN=8(R0),-
		P1=R3,-			; ADDRESS OF USERNAME DESCRIPTOR
		P2=R4			; PROCESS NUMBER
	ADDL	#8,SP			; POP FAO CONTROL STRING DESCRIPTOR
	MOVQ	(SP)+,(R3)		; SET PROCESS NAME DESCRIPTOR
;
; CREATE THE SUBPROCESS
;
SPAWN_PROCESS:
	MOVAB	LOGINOUT,R1		; CONSTRUCT DESCRIPTOR OF IMAGE NAME
	MOVZBL	(R1)+,R0
	MOVQ	R0,-(SP)		; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0
	$CREPRC_S IMAGE=(R0),-		; CREATE THE PROCESS
		INPUT=SPWN_Q_INPUT(R6),-
		OUTPUT=SPWN_Q_OUTPUT(R6),-
		ERROR=SPWN_Q_MBXNAM(R6),-	; ERROR = COMM. MAILBOX NAME
		PRCNAM=SPWN_Q_PRCNAM(R6),-	; PROCESS NAME (USERNAME_1)
		BASPRI=SPWN_L_PRIB(R6),-	; PROPAGATE BASE PRIORITY
		QUOTA=SPWN_G_QUOTAS(R6),-	; PROPAGATE NON-DEDUCTIBLE QUOTAS
		MBXUNT=SPWN_W_UNIT(R6),-	; TERMINATION MAILBOX
		PIDADR=SPWN_L_SUBPID(R6)	; RECEIVE PID HERE
	ADDL	#8,SP			; POP DESCRIPTOR OF IMAGE NAME
	CMPW	R0,#SS$_DUPLNAM		; PROCESS NAME ALREADY EXIST?
	BNEQ	10$			; IF NOT, PROCESS AS ANY OTHER ERROR
	BBS	#SPWN_V_PRCNAM,SPWN_W_FLAGS(R6),10$ ;BRANCH IF /PROCESS GIVEN
	ACBL	#63,#1,R4,CONSTRUCT_PRCNAM ; INCREMENT NUMBER AFTER PROCESS NAME
10$:	BLBC	R0,39$			; IF ERROR CREATING PROCESS, REPORT IT

;
; WRITE /LOG MESSAGE INDICATING PROCESS WAS CREATED
;
	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),20$ ;BRANCH IF /NOLOG SPECIFIED
	MOVAB	SPWN_Q_PRCNAM(R6),R1	;ADDRESS OF PROCESS NAME
	MOVL	#CLI$_SPAWNED,R0	;MESSAGE CODE
	BSBW	MESSAGE 		;OUTPUT MESSAGE

;
; IF USER WANTS TO "ATTACH" TO SUBPROCESS, THEN ISSUE MESSAGE TELLING HIM
; WHICH PROCESS WE ARE GOING TO.  DO THIS BEFORE WE WRITE THE CONTEXT,
; WHILE WE STILL HAVE CONTROL OVER THE TERMINAL.
;
20$:	BBC	#SPWN_V_WAIT,SPWN_W_FLAGS(R6),30$ ; SKIP IF /NOWAIT
	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),30$ ; SKIP IF /NOLOG SPECIFIED
	MOVAB	SPWN_Q_PRCNAM(R6),R1	;ADDRESS OF PROCESS NAME
	MOVL	#CLI$_ATTACHED,R0	;MESSAGE CODE
	BSBW	MESSAGE			;OUTPUT MESSAGE

;
; WRITE CONTEXT TO SUBPROCESS VIA MAILBOX.  IF AN ERROR OCCURS AT THIS POINT,
; WE MUST DELETE THE PROCESS TO AVOID HAVING IT HANG AROUND FOR NOTHING.
;
30$:	BSBW	WRITE_CONTEXT		; WRITE CONTEXT TO SUBPROCESS
	BLBS	R0,35$			; BRANCH IF OK
	PUSHL	R0			; SAVE STATUS CODE
	$DELPRC_S PIDADR=SPWN_L_SUBPID(R6) ; DELETE THE SUBPROCESS
	POPL	R0			; RESTORE STATUS CODE
	BRB	RETURNED		; SIGNAL THE ORIGINAL ERROR, OR THE
					; SUBPROCESS ABNORMAL STATUS (IF ANY)
;
; CLEANUP CONTEXT MAILBOX, TO ELIMINATE POOL USAGE AS SOON AS POSSIBLE.
;
35$:	$DASSGN_S CHAN=SPWN_W_CHAN(R6)	; CLEANUP MAILBOX (THUS, POOL USAGE)
					; WHILE WAITING FOR RE-ATTACH
	MOVL	#1,R0			; IGNORE STATUS FROM DEASSIGN

;
; IF USER WANTS SUBPROCESS TO PROCEED ASYNCHRONOUSLY, THEN SKIP WAITING FOR IT
;
	BBS	#SPWN_V_WAIT,SPWN_W_FLAGS(R6),40$ ; DETACH IF /WAIT
	BBCC	#SPWN_V_ACTIVE,SPWN_W_FLAGS(R6),- ; MARK SUBPROCESS ASYNCHRONOUS
		RETURNED 		; BRANCH IF SUBPROCESS INACTIVE
					; (SUBPROCESS HAS BEEN TERMINATED)
39$:	MOVL	#1, R1			; MAKE "SUBPROCESS STATUS" SUCCESS
	BRB	SPAWN_EXIT		; DO NOT WAIT FOR IT TO COMPLETE

;
; MARK THIS PROCESS DETACHED, AND SHOULD NO LONGER USE TERMINAL
;
40$:	SETBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)	; MARK PROCESS DETACHED

;
; WAIT FOR PROCESS TO RETURN CONTROL HERE (VIA ATTACH OR TERMINATION)
;
50$:	BSBW	CHECK_FOR_HANGUP	; CHECK FOR HANGUP AST
	$HIBER_S			; HIBERNATE WAITING FOR WAKEUP
	BBC	#SPWN_V_ACTIVE,SPWN_W_FLAGS(R6),55$  ; BRANCH IF SUBPROCESS INACTIVE
					; (SUBPROCESS HAS BEEN TERMINATED)
	BBS	#PRC_V_DETACHED,PRC_W_FLAGS(R11),50$ ; BRANCH IF STILL DETACHED
55$:	CLRBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)	; MARK PROCESS ATTACHED

;
; WE HAVE RETURNED VIA A RE-ATTACH REQUEST TO THIS PROCESS, OR THE
; SUBPROCESS HAS TERMINATED.
;
RETURNED:
	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),40$ ;BRANCH IF /NOLOG SPECIFIED
	PUSHL	R0			; SAVE FINAL STATUS
	BSBW	RETURNED_MESSAGE	; WRITE MESSAGE SAYING WE HAVE RETURNED
	POPL	R0			; RESTORE FINAL STATUS
;
; TEST TO SEE IF THIS IS A REATTACH.  MOVE TERMINATION STATUS TO R1
;
40$:	MOVL	SPWN_L_STATUS(R6),R1	; ANY STATUS RETURNED BY SUBPROCESS?
	BEQL	EXIT_FROM_ATTACH	; BRANCH IF NOT (CAME BACK VIA ATTACH)

;
; THE DIRECTIVE IS ESSENTIALLY COMPLETE.  CLEANUP AND REPORT
; ANY ERRORS WHICH WERE DETECTED.
;
; FIRST CHECK TO SEE IF THE TERMINATION MAILBOX IS NEEDED ANY LONGER.
; IF NOT, THEN DEASSIGN IT AND REMOVE ITS TMBX BLOCK FROM THE LIST.
;
SPAWN_EXIT:
	BLBS	R0,10$			; BRANCH IF SUCCESSFUL /NOWAIT (OR /WAIT)
	TSTL	SPWN_L_STATUS(R6)	; DID SUBPROCESS TERMINATE?
	BNEQ	10$			; IF SO, TERMINATION MBX TAKEN CARE OF
	DECB	TMBX_B_REFS(R7)		; DECREMENT REFERENCE COUNT TO MAILBOX
	BNEQ	10$			; BRANCH IF STILL OUTSTANDING USES
	MOVQ	R0,-(SP)		; SAVE ERROR AND TERMINATION STATUS
	$DASSGN_S CHAN=TMBX_W_CHANNEL(R7) ; DELETE TERMINATION MAILBOX
	MOVL	TMBX_L_LINK(R7),PRC_L_TMBX(R11) ; REMOVE BLOCK FROM LIST
	MOVL	R7,R0			; SET ADDRESS OF BLOCK
	MOVZWL	#TMBX_C_LENGTH,R1	; SET LENGTH OF BLOCK
	BSBW	DCL$DEADYNMEM		; DEALLOCATE BLOCK
	MOVQ	(SP)+,R0		; RESTORE ERROR AND TERMINATION STATUS
;
; EXIT FROM HERE IF THE TERMINATION MAILBOX SHOULD NOT BE DEALLOCATED
; (EITHER BECAUSE IT ALREADY HAS BEEN, BECAUSE IT IS STILL NEEDED, OR
; BECAUSE IT WAS NEVER ALLOCATED.)
;
10$:
SPAWN_EXIT_NOTMBX:
	MOVQ	R0,-(SP)		; SAVE ERROR AND TERMINATION STATUS
	BSBW	DELETE_ATTMBX		; DELETE OUR ATTACH MAILBOX
	$DASSGN_S CHAN=SPWN_W_CHAN(R6)	; DEASSIGN CONTEXT MAILBOX CHANNEL
	BBC	#SPWN_V_ACTIVE,SPWN_W_FLAGS(R6),10$ ;BRANCH IF ASYNCHRONOUS REQUEST
	MOVL	SPWN_L_LINK(R6),PRC_L_SPWN(R11) ; REMOVE BLOCK FROM LIST
	MOVL	R6,R0			; SET ADDRESS OF BLOCK
	MOVZWL	SPWN_W_SIZE(R6),R1	; SET LENGTH OF BLOCK
	BSBW	DCL$DEADYNMEM		; DEALLOCATE BLOCK
10$:	MOVQ	(SP)+,R0		; RESTORE ERROR AND TERMINATION STATUS

;
; RESTORE STACK, EVENT FLAGS, CONTROL KEY AST'S, AND STATUS.
;
EXIT_FROM_ATTACH:
	TSTL	R1			; EXITING FROM ATTACH?
	BNEQ	5$			; NO, THEN SKIP
	MOVL	#1,R1			; YES, THEN SET NORMAL STATUS
5$:	MOVAB	512+8(SP),SP		; POP SCRATCH STORAGE OFF STACK
	POPL	R2			; PICK UP SAVED EVENT FLAG CLUSTER 0
	MOVQ	R0,-(SP)		; SAVE ERROR AND TERMINATION STATUS
	MOVL	#MIN_EFN,R3		; SET FIRST EVENT FLAG USED
	MOVL	#MAX_EFN,R4		; SET LAST EVENT FLAG USED
	BSBW	RESTORE_EFC		; RESTORE EVENT FLAG SETTINGS
	MOVL	SPWN_L_OUTOFBAND(R6),R1	; RESTORE OUT-OF-BAND ENABLE MASK
	BSBW	DCL$RESETOOB		; RESTORE AST'S
	POPR	#^M<R0,R1,R2,R3,R4,R5,R7,R8>	; RESTORE REGISTERS
;
; IF HANGUP PENDING, ABORT PROCESS
;
	BBC	#PRC_V_HANGUP,-		; IF SET, HANG-UP PENDING
		PRC_W_FLAGS(R11),10$	
	ADDL 	#8,SP			; POP TWO PC'S OFF THE STACK
	BRW	DCL$ABORT		; LOG THE PROCESS OUT
10$:	RSB				; EXIT

	.SBTTL	ATTACH COMMAND
;+
; DCL$ATTACH - ATTACH COMMAND
;
; THIS ROUTINE IS CALLED TO EXECUTE THE DCL ATTACH COMMAND.  THE ATTACH
; COMMAND TRANSFERS EXCLUSIVE CONTROL OF THE TERMINAL FROM THIS PROCESS
; TO ANOTHER PROCESS BY MUTUAL COOPERATION.  A MESSAGE IS SENT TO THE
; "DESTINATION" PROCESS'S ATTACH REQUEST MAILBOX ASKING IF IT WANTS TO
; HAVE CONTROL OF THE TERMINAL.  THE DESTINATION PROCESS RESPONDS WITH
; A YES/NO REPLY DEPENDING ON ITS STATE.  IF IT RESPONDS WITH YES, THEN
; WE MARK OURSELVES DETACHED, AND WAIT FOR A RE-ATTACH REQUEST.
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;-
 
DCL$ATTACH::
;
; GET THE PROCESS NAME OR PID FROM THE COMMAND LINE
;
	CLRL	R6			; MARK NO PROCESS NAME SUPPLIED YET
	CLRL	R8			; MARK NO PID SUPPLIED YET
40$:	BSBW	DCL$GETDVAL		; GET NEXT TOKEN
	BLBC	R0,50$			; BRANCH IF END OF LINE
	CMPL	R5,#PTR_K_COMDQUAL	; VERB QUALIFIER?
	BEQL	42$			; BRANCH IF SO
	CMPL	R5,#PTR_K_PARAMETR	; PARAMETER (PROCESS NAME)?
	BNEQ	40$			; IF NOT, IGNORE IT
	MOVQ	R1,R6			; SAVE DESCRIPTOR OF PROCESS NAME
	BRB	40$
42$:	CMPB	R1,#CLI$K_ATTA_IDEN	; /IDENTIFICATION?
	BNEQ	40$			; IF NOT, IGNORE IT
	CMPB	R4,#PTR_K_COLON		; IS A VALUE PRESENT?
	BNEQ	40$			; IF NOT, USE DEFAULT
	BSBW	DCL$GETDVAL		; GET /IDENT VALUE
	MOVQ	R1,R2			; PASS DESCRIPTOR OF VALUE STRING
	MOVZBL	#PRC_K_HEX,R1		; DEFAULT RADIX = HEX
	BSBW	DCL$CNVASCBIN		; CONVERT TO BINARY
	BNEQ	45$			; BRANCH IF CONVERSION ERROR
	MOVL	R1,R8			; SAVE PID AWAY
	BRB	40$
45$:	STATUS	EXPSYN			; EXPRESSION SYNTAX ERROR
	RSB
50$:	BSBB	DCL$ATTACH2		; PERFORM ACTUAL ATTACH OPERATION
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	BSBW	RETURNED_MESSAGE	; WRITE MESSAGE SAYING WE HAVE RETURNED
	MOVL	#1,R0			; INDICATE SUCCESS
90$:	RSB				; RETURN WITH STATUS

	.SBTTL	PERFORM ATTACH OPERATION
;---
;
; ALTERNATE ENTRY POINT, USED BY ATTACH CLI CALLBACK.  NO USE OF THE
; WRK AREA MUST BE MADE AFTER THIS POINT, SINCE CLI CALLBACKS OPERATE
; WITHOUT ANY SUCH AREA.
;
; INPUTS:
;
;	R6/R7 = DESCRIPTOR OF PROCESS NAME
;	R8 = PID OF DESTINATION PROCESS
;	R11 = ADDRESS OF PRC AREA
;
;	EITHER THE PID OR PROCESS NAME MUST BE SPECIFIED.
;
; OUTPUTS:
;
;	R0 = FINAL STATUS
;
;---

DCL$ATTACH2::
;
; CONTROL/Y AST'S ARE DISABLED THROUGHOUT THIS COMMAND, TO ENSURE THAT
; MAILBOXES WHICH ARE CREATED HERE ARE CORRECTLY DELETED, ETC.  AS A
; RESULT, WE MUST PERIODICALLY CHECK THE HANGUP FLAG IN CASE A HANGUP
; IS DETECTED WHILE WE ARE OPERATING.
;
	PUSHL	PRC_L_OUTOFBAND(R11)	; SAVE OUT-OF-BAND ENABLE MASK
	CLRL	R1			; DISABLE ALL OUT-OF-BAND AST'S
	BSBW	DCL$RESETOOB
;
; SAVE THE CURRENT SETTINGS OF THE EVENT FLAGS USED DURING THIS ROUTINE,
; SO THAT WE CAN RESTORE THEM ON EXIT.  THIS IS SO THAT THE IMAGE CONTEXT
; IS NOT DESTROYED BY EITHER THE SPAWN DCL COMMAND OR LIB$SPAWN.
;
	MOVAL	-(SP),R0		; PUSH EVENT FLAG STATES ON STACK
	$READEF_S EFN=#0,-		; READ EVENT FLAG CLUSTER 0
		STATE=(R0)		; INTO LONGWORD ON STACK
;
; LOOKUP THE PROCESS, AND IF PRESENT, GET THE PID
;
	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4		; REQUEST PID, SET BUFFER LENGTH
	PUSHR	#^M<R6,R7,R8>		; PUSH PROCESS NAME DESCRIPTOR, PID
	MOVL	SP,R0
	$GETJPI_S ITMLST=12(R0),-	; GET PID OF THE PROCESS
		EFN=#SYNCH_EFN,-
		PRCNAM=(R0),-
		PIDADR=8(R0)
	ADDL	#3*4,SP			; POP PRCNAM DESCRIPTOR, PID
	POPL	R2			; GET THE DESTINATION PID
	ADDL	#3*4,SP			; POP ITEM LIST
	BLBS	R0,55$			; BRANCH IF PROCESS FOUND
49$:	BRW	90$			; REPORT ERROR
;
; MAKE SURE WE AREN'T TRYING TO ATTACH TO OURSELVES
;
55$:	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4		; REQUEST OUR PID, SET BUFFER LENGTH
	MOVL	SP,R0
	$GETJPI_S ITMLST=(R0),-		; GET PID OF THIS PROCESS
		EFN=#SYNCH_EFN
	POPL	R1			; GET OUR PID
	ADDL	#3*4,SP			; CLEANUP STACK
	MOVL	#CLI$_REFUSED,R0	; ASSUME AN ERROR
	CMPL	R1,R2			; TRYING TO ATTACH TO OURSELF?
	BEQL	49$			; IF SO, REJECT THE OPERATION
;
; CREATE ATTACH MAILBOX FOR THIS PROCESS TO RECEIVE RE-ATTACH REQUESTS.
; IT IS DONE NOW, SO THAT ANY ERRORS DETECTED WILL CAUSE THE ENTIRE
; OPERATION TO FAIL, RATHER THAN SENDING THE ATTACH REQUEST TO THE
; OTHER PROCESS, AND THEN FINDING OUT WE CAN'T CREATE THE RE-ATTACH
; MAILBOX.
;
	BSBW	CREATE_ATTMBX		; CREATE ATTACH MAILBOX
	BLBC	R0,49$			; BRANCH IF ERROR DETECTED
;
; CREATE ATTACH$PID LOGICAL NAME FOR DESTINATION ATTACH MAILBOX
;
	SUBL	#30,SP			; ALLOCATE ROOM FOR NAME
	PUSHL	SP			; CREATE DESCRIPTOR FOR NAME
	PUSHL	#30
	MOVAB	ATTACH_NAME,R1		; GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R0,-(SP)		; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0
	$FAO_S	CTRSTR=(R0),-		; CONSTRUCT LOGICAL NAME
		OUTBUF=8(R0),-
		OUTLEN=8(R0),-
		P1=R2			; FROM PID FOR THIS PROCESS
	ADDL	#8,SP			; POP FAO STRING DESCRIPTOR
;
; ASSIGN CHANNEL TO ATTACH MAILBOX
;
	MOVAL	-(SP),R0		; ADDRESS OF LOGICAL NAME DESCRIPTOR
	$ASSIGN_S DEVNAM=4(R0),-	; ASSIGN CHANNEL TO MAILBOX
		CHAN=(R0)
	POPL	R2			; GET CHANNEL OF MAILBOX
	ADDL	#8+30,SP		; DEALLOCATE LOGNAME BUFFER
	BLBS	R0,60$			; BRANCH IF OK
	BRW	85$			; REPORT THAT WE CANNOT DO IT
;
; GET SYS$INPUT TRANSLATION (TERMINAL DEVICE NAME).  IT WILL BE PASSED
; TO THE DESTINATION PROCESS, SO THAT IT CAN DECIDE WHETHER TO ACCEPT
; THE REQUEST OR NOT.  ATTACH REQUESTS ARE ONLY ACCEPTED WHEN THE SYS$INPUT
; TRANSLATIONS FOR THE SOURCE AND DESTINATION PROCESSES ARE THE SAME.
;
60$:	MOVZWL	#ATTMBX_MAXMSG,R4	; SET SIZE OF SCRATCH BUFFER
	SUBL	R4,SP			; ALLOCATE SCRATCH BUFFER FOR STRING
	MOVL	SP,R5			; CREATE DESCRIPTOR OF BUFFER
	BSBW	INPUT_DEVICE		; GET INPUT DEVICE NAME
	BLBS	R0,61$			; CONTINUE IF SUCCESSFUL
	BRW	81$			; BRANCH IF ERROR
61$:	MOVQ	R4,-(SP)		; PUSH SYS$INPUT TRANSLATION

;
; SEND REQUEST TO DESTINATION ATTACH REQUEST MAILBOX AND GET REPLY
;
	BSBW	CHECK_FOR_HANGUP	; CHECK FOR HANGUP AST
	MOVAQ	-(SP),R4		; ALLOCATE IOSB FOR I/O REQUESTS
	$QIOW_S FUNC=#IO$_WRITEVBLK,-	; WRITE TO MAILBOX
		CHAN=R2,-
		EFN=#SYNCH_EFN,-
		IOSB=(R4),-
		P1=@12(R4),P2=8(R4)	; RECORD = SYS$INPUT TRANSLATION
	BLBC	R0,80$			; BRANCH IF ERROR
	MOVZWL	(R4),R0			; GET FINAL STATUS FROM IOSB
	BLBC	R0,80$			; BRANCH IF ERROR
	MOVAL	-(SP),R3		; ALLOCATE RECORD BUFFER
	$QIOW_S	FUNC=#IO$_READVBLK,-	; READ RESPONSE FROM MAILBOX
		CHAN=R2,-
		EFN=#SYNCH_EFN,-
		IOSB=(R4),-
		P1=(R3),P2=#4		; TO LONGWORD BUFFER
	POPL	R3			; POP RECORD BUFFER
	BLBC	R0,80$			; BRANCH IF ERROR
	MOVZWL	(R4),R0			; GET FINAL STATUS FROM IOSB
	BLBC	R0,80$			; BRANCH IF ERROR
	ADDL	#8+ATTMBX_MAXMSG+8,SP	; CLEAN STACK
	$DASSGN_S CHAN=R2		; DEASSIGN CHANNEL TO ATTACH MAILBOX
;
; IF DESTINATION PROCESS SAYS NO TO ATTACH REQUEST, REPORT IT TO THE USER
;
	BLBC	R3,85$			; BRANCH IF DESTINATION PROCESS SAYS NO
;
; MARK THIS PROCESS DETACHED, AND SHOULD NO LONGER USE TERMINAL
;
	SETBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11)	; MARK PROCESS DETACHED
;
; WAIT FOR PROCESS TO RETURN CONTROL HERE (FROM ATTACH OR TERMINATION)
;
70$:	BSBW	CHECK_FOR_HANGUP	; CHECK FOR HANGUP AST
	$HIBER_S			; HIBERNATE WAITING FOR WAKEUP
	BBS	#PRC_V_DETACHED,PRC_W_FLAGS(R11),70$ ; BRANCH IF STILL DETACHED
	MOVL	#1,R0			; SET SUCCESSFUL
	BRB	90$			; AND EXIT

;
; CLEANUP FROM ERROR DETECTED WHILE HAVING CHANNEL OPEN TO ATTACH MAILBOX
;
81$:	SUBL	#16,SP			; FUDGE STACK FOR ALTERNATE ERROR ENTRY
80$:	ADDL	#8+ATTMBX_MAXMSG+8,SP	; CLEAN STACK
	$DASSGN_S CHAN=R2		; DEASSIGN CHANNEL TO ATTACH MAILBOX
85$:	MOVL	#CLI$_REFUSED,R0	; ATTACH REQUEST REFUSED
90$:	MOVL	R0,R6			; SAVE FINAL STATUS CODE
	BSBW	DELETE_ATTMBX		; DELETE OUR ATTACH MAILBOX
	POPL	R2			; PICK UP SAVED EVENT FLAG CLUSTER 0
	MOVL	#MIN_EFN,R3		; SET FIRST EVENT FLAG USED
	MOVL	#MAX_EFN,R4		; SET LAST EVENT FLAG USED
	BSBW	RESTORE_EFC		; RESTORE EVENT FLAG SETTINGS
	POPL	R1			; RESTORE OUT-OF-BAND ENABLE MASK
	BSBW	DCL$RESETOOB		; RESTORE AST'S
	MOVL	R6,R0			; RESTORE EXIT STATUS
	RSB				; EXIT

	.SBTTL	CREATE ATTACH REQUEST MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO CREATE AN ATTACH REQUEST MAILBOX FOR
; THIS PROCESS TO RECEIVE ATTACH REQUESTS FROM OTHER PROCESSES.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

CREATE_ATTMBX:
	PUSHL	R2			; SAVE REGISTERS
;
; CREATE ATTACH MAILBOX AND LOGICAL NAME, SHOULD ANY OTHER PROCESS DESIRE
; TO RE-ATTACH TO THIS PROCESS LATER ON.
;
	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_PID@16+4		; REQUEST OUR PID, SET BUFFER LENGTH
	MOVL	SP,R0
	$GETJPI_S ITMLST=(R0),-		; GET PID OF THIS PROCESS
		EFN=#SYNCH_EFN
	POPL	R2			; GET OUR PID
	ADDL	#3*4,SP			; CLEANUP STACK
	SUBL	#30,SP			; ALLOCATE ROOM FOR NAME
	PUSHL	SP			; CREATE DESCRIPTOR FOR NAME
	PUSHL	#30
	MOVAB	ATTACH_NAME,R1		; GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		; CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R0,-(SP)		; PUSH DESCRIPTOR ONTO STACK
	MOVL	SP,R0
	$FAO_S	CTRSTR=(R0),-		; CONSTRUCT LOGICAL NAME
		OUTBUF=8(R0),-
		OUTLEN=8(R0),-
		P1=R2			; FROM PID FOR THIS PROCESS
	ADDL	#8,SP			; POP FAO STRING DESCRIPTOR
	MOVL	SP,R0			; ADDRESS OF LOGICAL NAME DESCRIPTOR
	$CREMBX_S CHAN=PRC_W_ATTMBX(R11),-	; CREATE ATTACH MAILBOX
		BUFQUO=#ATTMBX_MAXMSG,-		; ONLY NEEDS TO HOLD 1 MESSAGE
		PROMSK=#^B1111111100001111,-	; ONLY GIVE OWNER R/W ACCESS
		LOGNAM=(R0)
	ADDL	#30+8,SP		; CLEANUP STACK
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	$QIO_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,- ; SET ATTENTION AST ON MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-
		EFN=#ASYNCH_EFN,-
		P1=W^ATTACH_AST,-	; ADDRESS OF AST ROUTINE
		P2=R11			; PASS ADDRESS OF CLI STORAGE
90$:	POPL	R2			; RESTORE REGISTERS
	RSB

	.SBTTL	DELETE ATTACH REQUEST MAILBOX
;---
;
; THIS ROUTINE IS CALLED TO DELETE THE ATTACH REQUEST MAILBOX
; FOR THIS PROCESS.  THIS IS DONE AFTER WE COME BACK FROM DETACHED
; STATE, SINCE AFTER THAT POINT, WE CAN NO LONGER ACCEPT ATTACH REQUESTS.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

DELETE_ATTMBX:
	$DASSGN_S CHAN=PRC_W_ATTMBX(R11) ;DELETE ATTACH MAILBOX
	CLRW	PRC_W_ATTMBX(R11)	;MARK CHANNEL NO LONGER VALID
	RSB

	.SBTTL	WRITE RETURNED MESSAGE
;---
;
; THIS ROUTINE WRITES A MESSAGE INDICATING THAT TERMINAL CONTROL
; HAS RETURNED TO THIS PROCESS.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;---

RETURNED_MESSAGE:
;
; OUTPUT MESSAGE SAYING THAT CONTROL OF THE TERMINAL HAS RETURNED
; TO THIS PROCESS
;
	SUBL	#16,SP			;ALLOCATE SCRATCH BUFFER FOR PRCNAM
	PUSHL	SP			;CREATE DESCRIPTOR OF BUFFER
	PUSHL	#16
	MOVL	SP,R0
	CLRL	-(SP)			;MARK END OF JPI LIST
	PUSHL	R0			;ADDRESS TO STORE RETURN LENGTH
	MOVQ	(R0),-(SP)		;DESCRIPTOR OF STRING BUFFER
	MOVW	#JPI$_PRCNAM,2(SP)	;SET PARAMETER ID TO RETRIEVE
	MOVL	SP,R0			;SET ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0),-		;GET CURRENT PROCESS NAME
		EFN=#SYNCH_EFN
	ADDL	#4*4,SP			;REMOVE ITEM LIST FROM STACK
	MOVL	SP,R1			;ADDRESS OF PROCESS NAME
	MOVL	#CLI$_RETURNED,R0	;MESSAGE CODE
	BSBW	MESSAGE			;OUTPUT MESSAGE
	ADDL	#8+16,SP		;CLEAN STACK
	RSB

	.SBTTL	WRITE CONTEXT TO SUBPROCESS
;---
;
; THIS ROUTINE WRITES THE PROCESS CONTEXT RECORDS TO THE SUBPROCESS
; INITIALIZATION ROUTINE VIA THE CONTEXT MAILBOX.  EACH RECORD HAS
; A TYPE FIELD WHICH DISTINGUISHES THE DIFFERENT TYPES OF INFORMATION
; WHICH CAN BE PASSED FROM PARENT TO SUBPROCESS.
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN STORAGE
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;---

WRITE_CONTEXT:
	PUSHR	#^M<R2,R3,R4,R5,R7>	; SAVE REGISTERS
;
; CONSTRUCT THE HEADER CONTEXT RECORD, WHICH CONTAINS SUCH THINGS AS PROCESS
; PRIVILEGES, ETC.
;
	MOVAB	-CTX_C_MAXLEN(SP),SP	; ALLOCATE BUFFER FOR CONTEXT RECORDS
	MOVL	SP,R7			; SAVE ADDRESS OF BUFFER
	MOVZWL	#CTX_C_HEADER,CTX_W_TYPE(R7)	; SET TYPE OF RECORD
	CLRQ	-(SP)			; SET END OF ITEM LIST, RETLEN ADDRESS
	PUSHAQ	CTX_Q_PROCPRIV(R7)	; SET ADDRESS OF BUFFER
	PUSHL	#JPI$_PROCPRIV@16!8	; SET GETJPI ITEM CODE AND LENGTH
	MOVL	SP,R0			; ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0),-		; GET INFORMATION
		EFN=#SYNCH_EFN
	ADDL	#4*4,SP			; POP GETJPI ITEM LIST
	CLRB	CTX_B_FLAGS(R7)		; CLEAR THE FLAGS BYTE
	BBC	#SPWN_V_AUTOLOGO,SPWN_W_FLAGS(R6),15$ ; BRANCH IF NOT SET
	SETBIT	CTX_V_AUTOLOGO,CTX_B_FLAGS(R7)
15$:	BBC	#SPWN_V_EOFLOGO,SPWN_W_FLAGS(R6),16$ ; BRANCH IF NOT SET
	SETBIT	CTX_V_EOFLOGO,CTX_B_FLAGS(R7)
16$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),18$ ; COPY VERIFICATION FLAG
	SETBIT	CTX_V_VERIFY,CTX_B_FLAGS(R7)
18$:	MOVL	#CTX_C_HDRLEN,R3	; COMPUTE SIZE OF RECORD
	MOVL	SPWN_L_OUTOFBAND(R6),-	; GET OUT-OF-BAND AST MASK
		CTX_L_OUTOFBAND(R7)
	BSBW	WRITE_MAILBOX		; WRITE THE RECORD TO THE MAILBOX
	BLBC	R0,19$			; BRANCH IF ERROR DETECTED
;
; WRITE THE COMMAND STRING RECORD TO THE MAILBOX
;
	TSTW	SPWN_Q_CMDSTR(R6)	; ANY COMMAND STRING?
	BEQL	20$			; BRANCH IF NOT
	CMPW	SPWN_Q_CMDSTR(R6),#CTX_C_MAXLEN-CTX_T_CMDSTR ; CHECK IF BIGGER THAN OUR BUFFER
	BLEQU	10$			; BRANCH IF OK
	MOVZWL	#CTX_C_MAXLEN-CTX_T_CMDSTR,SPWN_Q_CMDSTR(R6) ; ELSE, TRUNCATE STRING
10$:	MOVW	#CTX_C_CMDSTR,CTX_W_TYPE(R7) ; SET TYPE OF RECORD
	MOVC	SPWN_Q_CMDSTR(R6),@SPWN_Q_CMDSTR+4(R6),CTX_T_CMDSTR(R7)
	SUBL	R7,R3			; COMPUTE LENGTH OF RECORD
	BSBW	WRITE_MAILBOX		; WRITE THE RECORD TO THE MAILBOX
19$:	BLBC	R0,29$			; BRANCH IF ERROR DETECTED
;
; WRITE THE PROCESS LOGICAL NAMES TO THE MAILBOX
;
20$:	BBC	#SPWN_V_LOGNAM,SPWN_W_FLAGS(R6),40$ ; BRANCH IF NOT REQUESTED
	MOVW	#CTX_C_LOGNAM,CTX_W_TYPE(R7) ; SET TYPE OF RECORD
	MOVL	G^CTL$GL_LOGTBL,R4	; GET ADDRESS OF HASH TABLE
	MOVZWL	-4(R4),R5		; GET SIZE OF HASH TABLE
	SUBL	#12,R5			; SUBTRACT OUT OVERHEAD
	BICL	#^XF,R5			; ROUND DOWN
	ADDL	R4,R5			; COMPUTE ENDING ADDRESS OF TABLE
30$:	CMPL	R4,R5			; END OF TABLE?
	BGEQU	40$			; BRANCH IF DONE
	MOVAL	(R4)+,R3		; GET ADDRESS OF LISTHEAD
35$:	MOVL	(R3),R3			; SKIP TO NEXT ENTRY IN LIST
	BEQL	30$			; BRANCH IF END OF LIST
	CMPB	LOG$B_AMOD(R3),#PSL$C_EXEC ; EXECUTIVE OR KERNEL MODE?
	BLEQU	35$			; IF SO, SKIP IT - CANNOT BE PROPAGATED
	MOVB	LOG$B_AMOD(R3),CTX_B_ACMODE(R7) ; STORE ACCESS MODE
	MOVAB	LOG$T_NAME(R3),R1	; ADDRESS OF 1ST COUNTED STRING
	PUSHR	#^M<R3,R4,R5>		; SAVE REGISTERS
	MOVAB	CTX_T_LOGNAM(R7),R3	; POINT TO BUFFER
	MOVZBL	(R1)+,R0		; CONSTRUCT DESCRIPTOR OF LOGNAM
	MOVB	R0,(R3)+		; COPY LENGTH OF LOGICAL NAME
	MOVC	R0,(R1),(R3)		; COPY LOGICAL NAME STRING
	MOVZBL	(R1)+,R0		; GET LENGTH OF EQUIVALENCE NAME
	MOVW	R0,(R3)+		; COPY WORD LENGTH OF EQUIVALENCE NAME
	MOVC	R0,(R1),(R3)		; COPY EQUIVALENCE NAME STRING
	SUBL	R7,R3			; COMPUTE SIZE OF CONTEXT RECORD
	SUBW3	#CTX_W_ENTSIZE,R3,CTX_W_ENTSIZE(R7) ; SET SIZE OF ENTRY
	BSBB	WRITE_MAILBOX		; WRITE THE RECORD TO THE MAILBOX
	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
29$:	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	BRB	35$			; LOOP UNTIL END OF THIS LIST
;
; WRITE THE DCL GLOBAL SYMBOLS TO THE MAILBOX
;
40$:	BBC	#SPWN_V_CLISYM,SPWN_W_FLAGS(R6),50$ ; BRANCH IF NOT REQUESTED
	MOVAB	PRC_Q_GLOBAL(R11),R4	; GET ADDRESS OF GLOBAL LISTHEAD
	MOVB	#CTX_C_GLOBAL,CTX_B_SYMTAB(R7) ; SET WHICH SYMBOL TABLE
	BSBB	WRITE_SYMBOLS		; WRITE ALL GLOBAL SYMBOLS
	MOVAB	PRC_Q_LOCAL(R11),R4	; GET ADDRESS OF LOCAL LISTHEAD
	MOVB	#CTX_C_LOCAL,CTX_B_SYMTAB(R7) ; SET WHICH SYMBOL TABLE
	BSBB	WRITE_SYMBOLS		; WRITE ALL LOCAL SYMBOLS
;
; WRITE AN END-OF-FILE TO THE MAILBOX AND WAIT FOR COMPLETION, SO THAT
; WE DON'T DELETE THE MAILBOX BEFORE THE SUBPROCESS EVEN GETS A CHANCE
; TO ASSIGN A CHANNEL TO IT.
;
50$:	$QIOW_S FUNC=#IO$_WRITEOF,-	; WRITE AN EOF TO MAILBOX
		CHAN=SPWN_W_CHAN(R6),-
		EFN=#SYNCH_EFN
90$:	MOVAB	CTX_C_MAXLEN(SP),SP	; DEALLOCATE RECORD BUFFER
	POPR	#^M<R2,R3,R4,R5,R7>	; RESTORE REGISTERS
	RSB

	.SBTTL	WRITE RECORD TO CONTEXT MAILBOX
;---
;
; WRITE A RECORD TO THE MAILBOX WITHOUT WAITING FOR A READER
;
; INPUTS:
;
;	R6 = ADDRESS OF SPWN STORAGE
;	R7 = ADDRESS OF RECORD TO BE OUTPUT
;	R3 = LENGTH OF RECORD TO BE OUTPUT
;
; OUTPUTS:
;
;	R0 = FINAL STATUS
;---

WRITE_MAILBOX:
	BSBW	CHECK_FOR_HANGUP	; CHECK FOR HANGUP AST
	$QIOW_S	FUNC=#IO$_WRITEVBLK!IO$M_NOW,-	; WRITE TO MAILBOX WITHOUT WAITING
		CHAN=SPWN_W_CHAN(R6),-
		EFN=#SYNCH_EFN,-
		IOSB=SPWN_Q_IOSB(R6),-
		P1=(R7),P2=R3		; ADDRESS/LENGTH OF BUFFER
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	MOVZWL	SPWN_Q_IOSB(R6),R0	; GET FINAL STATUS
90$:	RSB

	.SBTTL	WRITE ALL SYMBOLS IN A SYMBOL TABLE
;---
;
;	WRITE ALL THE SYMBOL RECORDS TO THE MAILBOX FROM A
;	SPECIFIED SYMBOL TABLE.
;
; INPUTS:
;
;	CTX_B_SYMTAB(R7) = TYPE OF SYMBOL TABLE
;	R4 = ADDRESS OF SYMBOL TABLE LISTHEAD
;	R6 = ADDRESS OF SPWN STORAGE
;	R7 = ADDRESS OF CONTEXT RECORD BUFFER
;
; OUTPUTS:
;
;	R0-R5 DESTROYED.
;---

WRITE_SYMBOLS:
	MOVW	#CTX_C_CLISYM,CTX_W_TYPE(R7) ; SET TYPE OF RECORD
	MOVL	R4,R5			; SAVE FOR END-OF-LIST CHECK
45$:	MOVL	(R4),R4			; GET NEXT SYMBOL ENTRY IN LIST
	CMPL	R4,R5			; END OF LIST?
	BEQL	50$			; BRANCH IF SO
	ASSUME	SYM_K_STRING EQ CTX_C_STRING
	ASSUME	SYM_K_PERM EQ CTX_C_PERM
	ASSUME	SYM_K_BINARY EQ CTX_C_BINARY
	MOVB	SYM_B_TYPE(R4),CTX_B_SYMTYPE(R7) ; COPY SYMBOL TYPE CODE
	MOVB	SYM_B_NONUNIQUE(R4),CTX_B_NONUNIQUE(R7) ; COPY UNIQUENESS POINT
	MOVZBL	SYM_T_SYMBOL(R4),R0	; GET LENGTH OF SYMBOL NAME
	CMPB	SYM_B_TYPE(R4),#SYM_K_BINARY ; BINARY VALUE?
	BNEQ	47$			; BRANCH IF NOT
	ADDL	#4+1,R0			; COMPUTE LENGTH OF ASCIC NAME + VALUE
	BRB	48$
47$:	MOVAB	SYM_T_SYMBOL+1(R4)[R0],R1 ; ADDRESS OF WORD-COUNTED VALUE STRING
	MOVZWL	(R1),R1			; GET LENGTH OF VALUE STRING
	MOVAB	3(R1)[R0],R0		; COMPUTE LENGTH OF ASCIC NAME + VALUE
48$:	CMPW	R0,#<CTX_C_MAXLEN-CTX_T_SYMBOL>	; WILL SYMBOL VALUE FIT?
	BGTRU	60$			; IF LARGER, THEN NO
	PUSHR	#^M<R4,R5>		; SAVE REGISTERS
	MOVC	R0,SYM_T_SYMBOL(R4),CTX_T_SYMBOL(R7) ; MOVE NAME + VALUE
	POPR	#^M<R4,R5>		; RESTORE REGISTERS
	SUBL	R7,R3			; COMPUTE SIZE OF RECORD
	SUBW3	#CTX_W_ENTSIZE,R3,CTX_W_ENTSIZE(R7) ; SET SIZE OF ENTRY
	BSBB	WRITE_MAILBOX		; WRITE RECORD TO MAILBOX
	BRB	45$			; LOOP UNTIL TABLE EXHAUSTED
50$:	RSB

;
; WE HAVE ENCOUNTERED AN OVERSIZED SYMBOL.  ISSUE A WARNING MESSAGE SAYING
; THAT WE ARE IGNORING IT AND THEN PROCEED.
;
60$:	BBC	#SPWN_V_LOG,SPWN_W_FLAGS(R6),45$ ;BRANCH IF /NOLOG SPECIFIED
	MOVAB	SYM_T_SYMBOL+1(R4),-(SP); PUSH DESCRIPTOR OF THE
	MOVZBL	SYM_T_SYMBOL(R4),-(SP)	;  SYMBOL NAME
	MOVL	SP,R1			; ADDRESS OF THE DESCRIPTOR
	MOVL	#CLI$_SYMTOOLNG,R0	; MESSAGE CODE
	BSBW	MESSAGE			; OUTPUT MESSAGE
	ADDL	#4*2,SP			; CLEAN STACK
	BRW	45$			; PROCESS NEXT SYMBOL


	.SBTTL	CHECK FOR PENDING HANGUP AST
;---
;
; THIS ROUTINE IS CALLED TO CHECK IF A HANGUP AST HAS COME IN SINCE
; WE STARTED THE COMMAND EXECUTION.  IF SO, THE PROCESS IS TERMINATED.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

CHECK_FOR_HANGUP:
	BBC	#PRC_V_HANGUP,PRC_W_FLAGS(R11),90$ ; BRANCH IF NO HANGUP PENDING
	BRW	DCL$RESTART		; ABORT PROCESS
90$:	RSB

	.SBTTL	TRANSLATE LOGICAL NAME
;---
;
; THIS ROUTINE TRANSLATES A LOGICAL NAME RECURSIVELY UP TO 10 TIMES
; AND PLACES THE FINAL EQUIVALENCE STRING INTO A GIVEN BUFFER.
; ANY PROCESS PERMANENT FILE (PPF) BINARY DATA FOUND IN THE EQUIVALENCE
; STRING IS STRIPPED BEFORE BEING RETURNED TO THE CALLER.
;
; INPUTS:
;
;	R2/R3 = DESCRIPTOR OF LOGICAL NAME
;	R4/R5 = DESCRIPTOR OF RESULT BUFFER
;
; OUTPUTS:
;
;	R1 = AMOUNT OF RESULT BUFFER WHICH WAS USED
;	R4/R5 = DESCRIPTOR OF EQUIVALENCE STRING
;
;	R0,R2,R3 DESTROYED.
;---
TRANSLATE:
	MOVQ	R4,-(SP)		; PUSH DESCRIPTOR OF ORIGINAL BUFFER
	PUSHR	#^M<R2,R3,R4,R5>	; PUSH LOGNAM, EQUIV DESCRIPTORS
	MOVQ	R2,-(SP)		; ALLOC AND INIT ROOM FOR FINAL DESCRIPTOR
	MOVAB	16(SP),R2		; GET ADDRESS OF EQUIVALENCE DESCRIPTOR
	MOVL	#10,R5			; MAXIMUM RECURSION DEPTH
10$:	$TRNLOG_S LOGNAM=-8(R2),-	; TRANSLATE SYS$INPUT
		RSLBUF=8(R2),-
		RSLLEN=(R2)
	CMPW	R0,#SS$_NOTRAN		; NO TRANSLATION?
	BEQL	50$			; BRANCH IF NOT
	MOVQ	(R2),(SP)		; SAVE DESCRIPTOR OF LAST TRANSLATION
	MOVQ	(R2),-8(R2)		; COPY EQUIVALENCE NAME TO LOGNAME
	MOVQ	(R2),R0			; PICK UP DESCRIPTOR OF TRANSLATION
	CMPB	-1(R0)[R1],#^A':'	; IS LAST CHARACTER A COLON?
	BNEQ	20$			; BRANCH IF NOT
	DECW	-8(R2)			; IF COLON ON TRANSLATION, REMOVE IT
					; BEFORE ATTEMPTING RECURSIVE TRNLOG
20$:	SOBGTR	R5,10$			; LOOP UNTIL TRANSLATED
50$:	MOVQ	(SP)+,R4		; PICK UP EQUIV DESCRIPTOR
	MOVZWL	R4,R1			; SAVE AMOUNT OF BUFFER USED UP
	ADDL	#24,SP			; POP DESCRIPTORS
	TSTW	R4			; NON-NULL STRING?
	BEQL	75$			; IF SO, NO LEADING ESCAPE POSSIBLE
	CMPB	(R5),#^X1B		; LEADING ESCAPE CHARACTER?
	BNEQ	75$			; BRANCH IF NOT
	SUBW	#4,R4			; REMOVE ESCAPE SEQUENCE
	ADDL	#4,R5
75$:	RSB

	.SBTTL	GET INPUT DEVICE NAME
;---
;
; THIS ROUTINE CALLS THE $GETDVI SYSTEM SERVICE TO GET THE INPUT DEVICE NAME.
; IT PLACES THE DEVICE NAME IN THE SPECIFIED BUFFER AND PROPAGATES THE 
; STATUS RETURNED BY $GETDVI TO THE CALLER.
;
; INPUTS:
;
;	R4/R5 = DESCRIPTOR OF RETURN BUFFER
;
; OUTPUTS:
;
;	R0 = STATUS RETURNED BY $GETDVI
;
;---

INPUT_DEVICE:
	MOVQ	R1,-(SP)		; SAVE REGISTERS
	CLRL	-(SP)			; CREATE GETDVI ITEM LIST
	PUSHAB	-12(SP)			; RETURN LENGTH ON STACK
	PUSHL	R5			; ADDRESS OF RESULT BUFFER
	PUSHL	R4			; LENGTH OF RESULT BUFFER
	MOVW	#DVI$_DEVNAM,2(SP)	; REQUEST COMPLETE DEVICE NAME
	MOVL	SP,R0			; GET ADDRESS OF ITEM LIST
	MOVAB	SYS$INPUT,R2		; GET DESCRIPTOR OF "SYS$INPUT"
	MOVZBL	(R2)+,R1
	MOVQ	R1,-(SP)		; PUSH DESCRIPTOR ON STACK
	MOVL	SP,R1			; GET ADDRESS OF DESCIPTOR
	$GETDVI_S DEVNAM=(R1),- 	; GET TERMINAL DEVICE NAME
		EFN=#SYNCH_EFN,-
		ITMLST=(R0)
	ADDL	#2*4,SP			; REMOVE DEVNAM DESCRIPTOR FROM STACK
	MOVZWL	(SP),R4			; GET LENGTH OF RESULT
	ADDL	#4*4,SP			; POP GETDVI ITEM LIST
	MOVQ	(SP)+,R1		; RESTORE REGISTERS
	RSB

	.SBTTL	RESTORE EVENT FLAG CLUSTER
;---
;
; THIS ROUTINE RESTORES THE SETTINGS OF A SPECIFIED NUMBER OF
; EVENT FLAGS.
;
; INPUTS:
;
;	R2 = LONGWORD CONTAINING SAVED EVENT FLAG CLUSTER
;	R3/R4 = RANGE OF EVENT FLAGS TO RESTORE
;
; OUTPUTS:
;
;	NO REGISTERS ARE DESTROYED.
;---

RESTORE_EFC:
	PUSHR	#^M<R0,R1,R3,R4>	; SAVE REGISTERS
	SUBL	R3,R4			; COMPUTE NUMBER OF FLAGS - 1
20$:	BBC	R3,R2,30$		; BRANCH IF EVENT FLAG WAS CLEAR
	$SETEF_S EFN=R3			; RESTORE EVENT FLAG TO 1
	BRB	40$
30$:	$CLREF_S EFN=R3			; RESTORE EVENT FLAG TO 0
40$:	INCL	R3			; SKIP TO NEXT EVENT FLAG
	SOBGEQ	R4,20$			; LOOP UNTIL DONE
	POPR	#^M<R0,R1,R3,R4>	; RESTORE REGISTERS
	RSB

	.SBTTL	OUTPUT A MESSAGE
;---
;
; THIS ROUTINE OUTPUTS A MESSAGE
;
; INPUTS:
;
;	R0 = MESSAGE CODE
;	R1 = ADDITIONAL PARAMETER (IF NON-ZERO)
;
; OUTPUTS:
;
;	NO REGISTERS ARE DESTROYED.
;---

MESSAGE:
	PUSHL	R1			;ADDRESS OF OPTIONAL PARAMETER
	PUSHL	#1			;NUMBER OF FAO ARGUMENTS
	PUSHL	R0			;MESSAGE CODE
	PUSHL	#2			;ASSUME 2 ARGS
	TSTL	R1			;IS R1 VALID?
	BEQL	10$			;NO, THEN 2 ARGS
	MOVL	#3,(SP)			;YES, THEN 3 ARGS
10$:	MOVL	SP,R0			;GET ADDRESS OF SIGNAL VECTOR
	BSBW	DCL$PUTMSG		;OUTPUT MESSAGE
	MOVL	4(SP),R0		;RESTORE R0
	MOVL	12(SP),R1		;RESTORE R1
	ADDL	#4*4,SP			;CLEAN STACK
	RSB				;RETURN


	.SBTTL	ATTACH REQUEST AST FROM ANOTHER PROCESS
;---
;
; THIS AST ROUTINE HANDLES AN ATTACH REQUEST FROM ANOTHER PROCESS
; THROUGH THE ATTACH MAILBOX ASSOCIATED WITH THIS PROCESS.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	NONE
;---

ATTACH_AST:
	.WORD	^M<R2,R3,R4,R5,R11>

	MOVL	4(AP),R11		; GET ADDRESS OF CLI PROCESS WORK AREA
	MOVAB	-ATTMBX_MAXMSG(SP),R5	; ALLOCATE RECORD BUFFER

;
; GET SYS$INPUT TRANSLATION (TERMINAL DEVICE NAME).  IT WILL BE CHECKED
; AGAINST THE TRANSLATION PASSED FROM THE REQUESTING PROCESS, TO ENSURE
; THAT THEY ARE THE SAME.  ATTACH REQUESTS ARE ONLY ACCEPTED WHEN THE SYS$INPUT
; TRANSLATIONS FOR THE SOURCE AND DESTINATION PROCESSES ARE THE SAME.
;
	MOVAB	-16(R5),SP		; ALLOCATE TERMINAL NAME BUFFER
	MOVL	#16,R4			; SET SIZE OF TERMINAL NAME BUFFER
	MOVL	SP,R5			; CREATE DESCRIPTOR OF BUFFER
	BSBW	INPUT_DEVICE		; GET INPUT DEVICE NAME
	BLBS	R0,5$			; BRANCH IF SUCCESSFUL
	BRW	90$			; BRANCH IF ERROR
5$:	MOVQ	R4,-(SP)		; PUSH SYS$INPUT TRANSLATION
	MOVAQ	-(SP),R2		; ALLOCATE IOSB AND GET ADDRESS
					; OF IOSB + TERMINAL DESCRIPTOR

;
; IF HANGUP AST IS PENDING, THEN WAKEUP PROCESS SO WE CAN TERMINATE
;
	BBS	#PRC_V_HANGUP,PRC_W_FLAGS(R11),80$ ; WAKE UP IF HANGUP PENDING

;
; GET THE ATTACH REQUEST MESSAGE FROM THE MAILBOX.  IF THERE IS MORE THAN
; ONE MESSAGE IN THE MAILBOX, ONLY HONOR THE LAST ONE.
;
	CLRL	R3			; ASSUME NO MESSAGE READ
10$:	$QIOW_S	FUNC=#IO$_READVBLK!IO$M_NOW,-	; READ THE ATTACH MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-
		EFN=#AST_EFN,-
		IOSB=(R2),-
		P1=(R5),P2=#ATTMBX_MAXMSG
	BLBC	R0,20$			; BRANCH IF ERROR
	BLBC	(R2),20$		; BRANCH IF ERROR (EOF)
	CVTWL	2(R2),R3		; SAVE LENGTH OF LAST MESSAGE
	BRB	10$			; LOOP UNTIL MAILBOX CLEANED OUT
20$:	TSTL	R3			; ANY MESSAGE READ?
	BEQL	90$			; IF NOT, IGNORE ATTENTION AST
	CLRL	R4			; ASSUME THE ANSWER IS "NO"
	CMPC5	R3,(R5),#0,8(R2),@12(R2) ; DOES THEIR INPUT STREAM MATCH OURS?
	BNEQ	30$			; IF NOT, TELL THEM NO
	BBC	#PRC_V_DETACHED,PRC_W_FLAGS(R11),30$ ; IF NOT DETACHED, SAY NO
	INCL	R4			; ELSE, RESPOND WITH YES
30$:	MOVL	SP,R2			; RESTORE ADDRESS OF IOSB
	MOVL	R4,(R5)			; MOVE RECORD INTO RECORD BUFFER
	$QIOW_S	FUNC=#IO$_WRITEVBLK,-	; WRITE YES/NO RESPONSE TO MAILBOX
		CHAN=PRC_W_ATTMBX(R11),-
		EFN=#AST_EFN,-
		IOSB=(R2),-
		P1=(R5),P2=#4		; ONLY A LONGWORD
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	BLBC	(R2),90$		; BRANCH IF ERROR DETECTED
	BLBC	R4,90$			; IF ANSWER WAS NO, THEN EXIT
	CLRBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11) ; MARK NO LONGER DETACHED
80$:	$WAKE_S				; WAKE UP CURRENT PROCESS
90$:	$QIO_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,-
		CHAN=PRC_W_ATTMBX(R11),-
		EFN=#AST_EFN,-
		P1=ATTACH_AST,-		; ADDRESS OF AST ROUTINE
		P2=R11			; PASS ADDRESS OF CLI STORAGE
	RET

	.SBTTL	SUBPROCESS TERMINATION AST ROUTINE
;---
;
; THIS AST IS CALLED WHEN A MESSAGE IS WRITTEN INTO THE TERMINATION
; MAILBOX, INDICATING THAT A SUBPROCESS HAS GONE AWAY.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF TMBX AREA
;
; OUTPUTS:
;
;	NONE
;---

LGI$_FACILITY = 211			; LOGINOUT FACILITY CODE

TERMINATION_AST:
	.WORD	^M<R2,R3,R5,R6,R7,R11>

	MOVL	4(AP),R7		; GET ADDRESS OF TMBX BLOCK
	MOVL	TMBX_L_PRC(R7),R11	; GET ADDRESS OF CLI PROCESS WORK AREA
	MOVAB	-8-ACC$C_TERMLEN(SP),SP	; ALLOCATE BUFFER SPACE
10$:	MOVL	SP,R2			; ADDRESS OF IOSB + RECORD BUFFER
	$QIOW_S	FUNC=#IO$_READVBLK!IO$M_NOW,- ; READ THE TERMINATION MAILBOX
		CHAN=TMBX_W_CHANNEL(R7),-
		EFN=#AST_EFN,-
		IOSB=(R2),-
		P1=8(R2),P2=#ACC$C_TERMLEN
	BLBC	R0,9$			; BRANCH IF ERROR
	BLBS	(R2),11$		; BRANCH IF MESSAGE READ
9$:	BRW	20$			; MAILBOX CLEANED OUT - PROCEED
;
; SEARCH THE LIST OF OUTSTANDING SUBPROCESS CONTEXT BLOCKS LOOKING FOR
; A MATCH WITH THE SUBPROCESS WHICH JUST TERMINATED.
;
	ASSUME	SPWN_L_LINK EQ 0
11$:	MOVAB	PRC_L_SPWN(R11),R5	; GET ADDRESS OF SPWN BLOCK LISTHEAD
12$:	MOVL	SPWN_L_LINK(R5),R6	; GET ADDRESS OF NEXT ENTRY IN LIST
	BEQL	10$			; IF NOT IN LIST, IGNORE MESSAGE
	CMPL	ACC$L_PID+8(R2),SPWN_L_SUBPID(R6) ; DOES PID MATCH?
	BEQL	14$			; BRANCH IF SO
	MOVL	R6,R5			; SKIP TO NEXT ENTRY IN LIST
	BRB	12$			; KEEP LOOPING
;
; THE PROCESS WHICH JUST TERMINATED HAS BEEN FOUND IN THE LIST OF
; CURRENTLY ACTIVE SPAWNED PROCESSES.  TAKE ANY ACTIONS WHICH WERE
; REQUESTED WHEN THE PROCESS WAS INITIATED (SUCH AS SETTING AN EVENT
; FLAG, QUEUEING AN AST, OR STORING THE TERMINATION STATUS).
;
14$:	MOVL	ACC$L_FINALSTS+8(R2),SPWN_L_STATUS(R6) ; SAVE FINAL STATUS
	BNEQ	15$			; BRANCH IF STATUS IS VALID
	MOVL	#1,SPWN_L_STATUS(R6)	; IF "NO STATUS", RETURN SUCCESS
15$:	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,-	; IS MESSAGE FROM LOGINOUT?
		SPWN_L_STATUS(R6),#LGI$_FACILITY
	BEQL	25$			; YES, THEN DO NOT INHIBIT MESSAGE
	SETBIT	#STS$V_INHIB_MSG,SPWN_L_STATUS(R6) ; DO NOT PRINT MSG TWICE
25$:	MOVL	SPWN_L_STSADR(R6),R0	; SHOULD STATUS BE RETURNED TO CALLER?
	BEQL	16$			; BRANCH IF NOT
	IFNOWRT	#4,@SPWN_L_STSADR(R6),16$,SPWN_B_ACMODE(R6) ; SKIP IF NOT WRITABLE
	MOVL	SPWN_L_STATUS(R6),@SPWN_L_STSADR(R6) ; RETURN STATUS TO CALLER
16$:	CLRQ	-(SP)			; CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		; SET BUFFER ADDRESS
	PUSHL	#JPI$_IMAGECOUNT@16+4	; REQUEST IMAGE COUNT, SET BUFFER LENGTH
	MOVL	SP,R0			; SET ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0),-		; GET PROCESS IMAGE COUNT
		EFN=#AST_EFN
	POPL	R1			; GET OUR PID
	ADDL	#3*4,SP			; CLEANUP STACK
	CMPL	R1,SPWN_L_IMAGCNT(R6)	; SAME IMAGE AS ISSUED SPAWN?
	BNEQ	18$			; NO, THEN DO NOT QUEUE AST OR SET EF
	TSTL	SPWN_L_ASTADR(R6)	; AST ROUTINE REQUESTED?
	BEQL	17$			; BRANCH IF NOT
	$DCLAST_S ASTADR=@SPWN_L_ASTADR(R6),- ; QUEUE THE AST
		ASTPRM=SPWN_L_ASTPRM(R6),-
		ACMODE=SPWN_B_ACMODE(R6)
17$:	TSTB	SPWN_B_EFN(R6)		; EVENT FLAG REQUESTED?
	BLSS	18$			; BRANCH IF NOT
	$SETEF_S EFN=SPWN_B_EFN(R6)	; SET THE EVENT FLAG
;
; IN CASE THE SUBPROCESS WAS CURRENTLY ACCEPTING ITS CONTEXT, PREVENT THE
; PARENT FROM HANGING TRYING TO SEND MESSAGES TO THE CONTEXT MAILBOX.
;
18$:	BBC	#SPWN_V_ACTIVE,SPWN_W_FLAGS(R6),19$ ; SKIP IF NOT ACTIVE
	$CANCEL_S CHAN=SPWN_W_CHAN(R6)	; STOP ANY CURRENT WRITES TO MAILBOX
	$DASSGN_S CHAN=SPWN_W_CHAN(R6)	; PREVENT FURTHER WRITES TO MAILBOX
	CLRW	SPWN_W_CHAN(R6)		; INDICATE CHANNEL WAS "REMOVED"

;
; ASSUME THAT THE SUBPROCESS THAT JUST DIED WAS "ATTACHED" AND IS LOGGING
; ITSELF OUT.  ALSO, ASSUME THAT THE CURRENT PROCESS (THE PARENT) WAS
; "DETACHED" AND SHOULD NOW BE AWAKENED TO RECEIVE CONTROL.
;
; NOTE THAT THESE ASSUMPTIONS ARE NOT VALID IN THE CASE OF AN "ATTACHED"
; COUSIN DELETING ITS "DETACHED" COUSIN.
;
19$:	BBC	#SPWN_V_WAIT,SPWN_W_FLAGS(R6),21$  ; SKIP IF /NOWAIT
	CLRBIT	PRC_V_DETACHED,PRC_W_FLAGS(R11) ; MARK NO LONGER DETACHED
	$WAKE_S				; WAKE UP CURRENT PROCESS

;
; INDICATE THAT ONE LESS SUBPROCESS NEEDS TO USE THE MAILBOX.
;
21$:	DECB	TMBX_B_REFS(R7)		; DECREMENT REFERENCE COUNT TO MAILBOX

;
; IF THE SUBPROCESS WAS CREATED NOWAIT, THEN REMOVE THE BLOCK FROM THE
; LIST OF OUTSTANDING PROCESSES, AND DEALLOCATE IT.
;
	BBSC	#SPWN_V_ACTIVE,SPWN_W_FLAGS(R6),13$ ; DO NOT DEALLOC. IF ACTIVE
					; MARK SUBPROCESS NO LONGER ACTIVE
	ASSUME	SPWN_L_LINK EQ 0
	MOVL	(R6),(R5)		; REMOVE FROM LINKED LIST NOW THAT
					; THE PROCESS IS NO LONGER ACTIVE
	MOVL	R6,R0			; SET ADDRESS OF BLOCK
	MOVZWL	SPWN_W_SIZE(R6),R1	; SET LENGTH OF BLOCK
	BSBW	DCL$DEADYNMEM		; DEALLOCATE SPWN BLOCK
13$:	BRW	10$			; LOOP UNTIL MAILBOX CLEANED OUT

;
; IF REF COUNT FOR THIS MAILBOX IS NOW ZERO, THEN DEASSIGN IT AND REMOVE
; THE TMBX BLOCK FROM THE LINKED LIST.  OTHERWISE, RE-ENABLE WRITE ATTENTION 
; AST ON THE MAILBOX.
;
20$:	TSTB	TMBX_B_REFS(R7)		; TEST REFERENCE COUNT TO MAILBOX
	BNEQ	80$			; BRANCH IF STILL OUTSTANDING USES
	$DASSGN_S CHAN=TMBX_W_CHANNEL(R7) ; DELETE TERMINATION MAILBOX
	MOVL	TMBX_L_LINK(R7),PRC_L_TMBX(R11) ; REMOVE BLOCK FROM LIST
	MOVL	R7,R0			; SET ADDRESS OF BLOCK
	MOVZWL	#TMBX_C_LENGTH,R1	; SET LENGTH OF BLOCK
	BSBW	DCL$DEADYNMEM		; DEALLOCATE BLOCK
	BRB	90$			; DO NOT BOTHER RESETING THE AST
80$:	$QIO_S	FUNC=#IO$_SETMODE!IO$M_WRTATTN,- ; RESET ATTENTION AST ON MAILBOX
		CHAN=TMBX_W_CHANNEL(R7),-
		EFN=#AST_EFN,-
		P1=TERMINATION_AST,-	; ADDRESS OF AST ROUTINE
		P2=R7			; PASS ADDRESS OF CLI STORAGE
90$:	RET

	.END
