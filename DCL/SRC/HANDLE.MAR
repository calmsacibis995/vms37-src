	.TITLE	HANDLE - CONDITION AND CONTROL/Y AST ROUTINES
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; CONDITION AND CONTROL Y AST HANDLER ROUTINES  
;
; D. N. CUTLER 29-MAR-77  
;
; MODIFIED BY:
;
;	V03-001	PHL0045		Peter H. Lipman	14-Apr-1982
;		Control Y rundown of privileged images delayed until
;		command dispatching to allow CONTINUE, SPAWN, and
;		ATTACH commands.
;
;		Set image privileges to process privileges, saving the
;		image privileges to be restored by CONTINUE
;
;	V018	PCG0003		Peter George	08-Feb-1982
;		Modify CTRL/T handler to correctly handle undefined
;		SYS$NODE and to save and restore event flag #31.
;
;	V017	PCG0002		Peter George	31-Dec-1981
;		Add support for CTRL/T AST's.
;
;	V016	TMH0016		Tim Halvorsen	28-Dec-1981
;		Support extra fields in spawn request block
;		to allow caller to be notified of subprocess
;		termination via any of ast, efn, status block.
;		Support spawn flags to inhibit copying of CLI
;		symbols and/or logical names to subprocess.
;
;	V015	TMH0015		Tim Halvorsen	28-Dec-1981
;		Remove roundup before ALLDYNMEM - now done inside routine.
;
;	V014	TMH0014		Tim Halvorsen	1-Dec-1981
;		Add SPAWN and ATTACH callbacks.
;		Add probes when reading user descriptors to prevent
;		access violations.
;
;	V013	ROW0050		Ralph O. Weber	24-NOV-1981
;		Remove conversion of numeric valued symbols to binary from 
;		define-symbol callback.  Fix get-symbol callback to properly 
;		convert to ASCII negative-valued binary-number symbols.  
;		Enhance all CTRL/Y processing -- both callback and AST routine 
;		-- to use longword out-of-band characters enable mask.  Also 
;		enhance enable/disable callbacks to return previous longword 
;		out-of-band characters enable mask.
;
;	V012	PCG0001		Peter George	04-NOV-1981
;		Correct generation of dummy AST argument lists for 
;		control/y AST handler.
;
;		ROW0030		Ralph O. Weber	7-SEP-1981
;	V011	Modify get-symbol-value callback facility to ALWAYS copy 
;		symbol value to expansion buffer.  The expansion buffer is 
;		readable in user mode where are the symbol heap storage area 
;		is not.  Copying to the expansion buffer allows use to keep 
;		the symbol heap storage area no-access in user mode.  For 
;		binary-valued symbols simulate the conversion performed by 
;		DCL$CBTA_DEC but return buffer overflow if insufficient 
;		expansion buffer.  Get-symbol's smarts regarding undefined 
;		symbols has been increased.  Control/Y protection added to 
;		delete-symbol callback support.
;
;	V010	ROW0028		Ralph O. Weber  6-SEP-1981
;		Modify define-symbols callback handler to provide for creation 
;		of binary value symbols as well as string value symbols.  
;		Added in-place conversion of character string to longword 
;		value.  If conversion fails, string valued symbol is created.  
;		Otherwise, binary valued symbol is created.
;
;	V009	ROW0026		Ralph O. Weber	3-SEP-1981
;		Add callback handler "routines" to: a) get the value of a 
;		symbol, b) delete a local/global symbol.
;
;	V008	TMH0008		Tim Halvorsen	28-May-1981
;		Create a simulated control/y call frame in the PAUSE
;		function, so that if image exit is forced (via the EXIT
;		command), the call frame can be plugged with status
;		SS$_CLIFRCEXT, and the PC plugged to EXE$EXIT_IMAGE.
;
;	V007	TMH0007		Tim Halvorsen	27-Apr-1981
;		Make use of routine to obtain address of PRC area.
;		Make use of PRC_L_INDEPTH to determine if level 0 or not.
;
;	V006	TMH0006		Tim Halvorsen	03-Apr-1981
;		Change method of locating PRC area.
;
;	V005	TMH0004		Tim Halvorsen	26-Mar-1981
;		Append a leading $ to the front of the chained
;		image filespec, so that it can be processed as
;		a foreign command.
;
;	V004	TMH0004		Tim Halvorsen	15-Feb-1981
;		Use R10 rather than FP as WRK address.
;		Define user-defined symbols as string type.
;
;	V003	TMH0003		Tim Halvorsen	27-Jan-1981
;		Allow abbreviatable symbols to be defined using the
;		CLI callback.  Fix length checks in chain and command
;		callbacks from 488 to 132.  Remove leading space from
;		buffered string.
;
;	V002	TMH0002		Tim Halvorsen	25-Sep-1980
;		Accept descriptors in DEFGBL with non-zero classes.
;		Fix typo in enable control/y routine.
;
;	V001	TMH0001		Tim Halvorsen	09-Jul-1980
;		Make condition handler resignal.  CLI initialization
;		simply sets EXE$CATCH_ALL as the handler in the top-most
;		frame so that errors are reported.  This enables the
;		debugger to catch exceptions.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	SYMDEF				; DEFINE TYPES OF SYMBOLS
	SPWNDEF				; DEFINE SPAWN PARAMETER BLOCK
	$CLIMSGDEF			; DEFINE ERROR/STATUS CODES
	$CLIDEF				; DEFINE REQUEST BLOCK FORMATS
	$CLISERVDEF			; DEFINE CLI SERVICE CODE
	$DEVDEF				; DEFINE DEVICE CHARACTERISTIC BITS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$PPDDEF				; PROCESS PERMANENT DEFINITIONS
	$RABDEF				; DEFINE RAB OFFSETS

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

	.SBTTL	CHANGE MODE TO SUPERVISOR HANDLER
;+
; DCL$CHANGE_MODE - CHANGE MODE TO SUPERVISOR HANDLER
;
; THIS ROUTINE IS ENTERED WHEN A CHANGE MODE TO SUPERVISOR INSTRUCTION IS
; EXECTED BY THE RESULT PARSER IN USER MODE OR THE CLI PROPER IN SUPER MODE.
;
; INPUTS:
;
;	 (SP) = CHANGE MODE ARGUMENT
;	4(SP) = PC AFTER CHANGE MODE INSTRUCTION
;	8(SP) = PSL OF CHANGE MODE INSTRUCTION
;
; OUTPUTS:
;
;	A CHECK IS MADE TO SEE IF THE
;	PREVIOUS MODE WAS USER OR SUPERVISOR.
;
;	PREVIOUS MODE USER:
;
;		THIS IS REQUEST FOR SERVICE FROM THE RUNNING IMAGE.
;		THE REQUEST IS DECODED AND PROCESSED, THE RETURN
;		IS MADE TO THE POINT OF CALL WITH STATUS OF REQUEST.
;
;	PREVIOUS MODE SUPERVISOR:
;
;		THIS IS RESERVED FOR COMMAND PROCESSING ERRORS.
;-
 
DCL$CHANGE_MODE::			;HANDLE CHANGE MODE TO SUPERVISOR
	BBS	#PSL$V_CURMOD,8(SP),10$	;BR IF CHANGE MODE FROM USER
 
;
; CHANGE MODE FROM SUPER
;
 
	BRW	DCL$RESTART		;*** NYI ***
 
;
; BUILD A FRAME THAT LOOKS LIKE AN AST FRAME, EXCEPT THAT IN PLACE OF
; THE SAVE R1 IS THE CHANGE MODE ARGUMENT, AND ZERO FOR SAVED R0 AND
; THE AST ARGUMENT.
;
 
10$:	BSBW	CLI$GET_PRC		;GET ADDRESS OF CLI PROCESS WORK AREA
	CLRQ	-(SP)			;DUMMY SAVED R0 AND AST ARGUMENT
	PUSHL	#5			;NUMBER OF ARGUMENTS IN AST ROUTINE
	CALLG	(SP),B^30$		;CREATE A CALL FRAME IN SUPER MODE
	ADDL	#<4*4>,SP		;CLEAR ARGUMENTS AND ARG COUNT
	TSTL	R0			;INTERNAL ERROR?
	BGTR	20$			;BR IF NO
	MNEGL	R0,R0			;MAKE POSITIVE
	BISW	#^XE000,R0		;INCLUDE SUBSYSTEM AND PRIVATE
	MULL	#4,R0			;SCALE TO PROPER PLACE
20$:	REI				;RETURN TO USER
 
30$:	.WORD	0			;REGISTERS SAVED BY RESULT PARSER
	CASE	12(AP),-		;DECODE USER REQUEST
		LIMIT = #CLI$K_PAUSE,-	;LOW LIMIT OF REQUEST
		TYPE = W,<-		;CASE ON 16 BIT VALUE
		PAUSE,-			;REQUEST IS PAUSE
		DEFLOC,-		; DEFINE IN LOCAL TABLE
		DEFGBL,-		; DEFINE IN GLOBAL TABLE
		CHAIN,-			;IMAGE TO LATER INVOKE
		COMMAND,-		;COMMAND LINE TO LATER PROCESS
		CREALOG,-		;CREATE PROCESS LOGICAL NAME
		DELELOG,-		;DELETE PROCESS LOGICAL NAME
		DISACTRLY,-		;DISABLE CONTROL Y
		ENABCTRLY,-		;RE-ENABLE CONTROL Y
		GETSYM,-		; GET A SYMBOL VALUE
		DELELCL,-		; DELETE A LOCAL SYMBOL
		DELEGBL,-		; DELETE A GLOBAL SYMBOL
		DISAOOB,-		;DISABLE OUT-OF-BAND CHARACTER(S)
		ENABOOB,-		;RE-ENABLE OUT-OF-BAND CHARACTER(S)
		SPAWN,-			;SPAWN A SUBPROCESS
		ATTACH,-		;ATTACH TO A PROCESS
		>			;
 
INVREQ:	MOVL	#CLI$_INVREQTYP,R0	;SET ERROR CODE
	RET				;
 
PAUSE:	MOVL	PRC_L_INPRAB(R11),R0	;GET PROCESS INPUT RAB
	BBC	#DEV$V_TRM,RAB$L_CTX(R0),INVREQ ;CAN'T PAUSE IF NOT INTERACTIVE
	MOVL	8(FP),AP		;POP CALL FRAME GENERATED BY CALL TO
	MOVL	12(FP),FP		;30$ OFF THE STACK
	ADDL	#5*4,SP			;RESTORE AP,FP, AND SP
	BRW	DCL$SCNTRLY		;SIMULATE A CONTROL/Y
 
;
; DEFINE A SYMBOL FOR THE PROCESS
;
 
	.ENABL	LSB

DEFLOC:	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF THE SYMBOL TABLE
	BRB	10$			;
DEFGBL:	MOVAB	PRC_Q_GLOBAL(R11),R5	;SET ADDRESS OF PROPER TABLE
10$:	MOVQ	4(R9),R3		;SET SYMBOL NAME DESCRIPTOR
	MOVZWL	R3,R3			;GET LENGTH OF SYMBOL NAME
	IFNORD	R3,(R4),ACCVIO		;ERROR IF CANNOT READ IT
	MOVQ	12(R9),R1		;SET SYMBOL VALUE DESCRIPTOR
	MOVZWL	R1,R1			;GET LENGTH OF VALUE
	BEQL	20$			;IF NULL VALUE, SKIP PROBE
	IFNORD	R1,(R2),ACCVIO		;ERROR IF CANNOT READ IT
20$:	MOVL	#SYM_K_STRING,R0	;SET TYPE OF CLI SYMBOL
	BSBW	DCL$ALLOCSYMABR		;CREATE THE SYMBOL
	RET				;ALL DONE

	.DSABL	LSB

ACCVIO:	MOVZWL	#SS$_ACCVIO,R0		;SIGNAL ACCESS VIOLATION
	RET

;
; Get a symbol's value
;
; WARNING:
; The returned value string MUST be copied from the area pointed to by
; the descriptor to a user-defined non-volitile area before the callback
; facility is used again.  The callback facility may overwrite the area
; which it uses to build the returned value string.

GETSYM:
	MOVL	PRC_L_SAVFP(R11), R10	;Get address of work area descriptor.
	MOVQ	4(R9), R1		;Get symbol name to search for.
	MOVZWL	R1,R1			;Get low order word
	IFNORD	R1,(R2),ACCVIO		;Error if cannot read it
	BSBW	DCL$SEARCH		;Search for it.
	BLBC	R0, NOSUCHSYM		;Check for symbol not found.
	CVTLB	R4, 3(R9)		;Return local/global table indicator.
	MOVL	WRK_L_EXPANDPTR(R10), 16(R9) ;Return address of string.
	TSTL	R2			;Check for binary valued symbol.
	BEQL	50$			;Branch if binary valued symbol.
	PUSHAB	WRK_G_BUFFER+WRK_C_CMDBUFSIZ(R10) ;Compute number of characters
	SUBL3	WRK_L_EXPANDPTR(R10), (SP)+, R0 ;remaining in expansion buffer.
	CMPL	R1, R0			;Enough space for symbol string value?
	BGTR	90$			;Branch if not enough space.
	MOVL	R1, 12(R9)		;Return length of string symbol.
	MOVC3	R1, (R2), @16(R9)	;Copy string to expansion buffer.
	BRB	70$			;Go to common exit code.
50$:	TSTL	R1			;Check for a negative number.
	BGEQ	55$			;If not, skip extra negative stuff.
	MOVB	#^A/-/, @WRK_L_EXPANDPTR(R10) ;For negative numbers, put a
	INCL	WRK_L_EXPANDPTR(R10)	;leading minus sign in ASCII string,
	MNEGL	R1, R1			;and negate value before converting.
55$:	BSBB	100$			;Call binary to ASCII converter.
	SUBL3	16(R9), WRK_L_EXPANDPTR(R10), - ;Compute number of bytes in
		12(R9)				;converted value string.
	MOVL	16(R9), WRK_L_EXPANDPTR(R10) ;Restore expansion buf. ptr.
70$:	MOVL	#1, R0			;Signal successful lookup.
	RET				;Return to caller.
;
; Return expansion buffer too small status.
;
90$:	MOVL	#CLI$_BUFOVF, R0
	RET
;
; Recursive routine to output the ASCII number, high order digits first
; without any leading spaces or zeros.
;
100$:	CLRL	R2			;Clear high part of dividend.
	EDIV	#10, R1, R1, R2		;Isolate next digit.
	ADDL3	#^A/0/, R2, -(SP)	;Convert digit to ASCII and save it.
	TSTL	R1			;Any more digits to convert?
	BEQL	130$			;Branch if no more digits.
	BSBB	100$			;Else convert next digit.
130$:	PUSHAB	WRK_G_BUFFER+WRK_C_CMDBUFSIZ(R10) ;Is the expansion buffer
	CMPL	(SP)+, WRK_L_EXPANDPTR(R10) ;full?
	BLEQU	90$			;Branch if expansion buffer full.
	POPL	R1			;Get next character digit.
	MOVB	R1, @WRK_L_EXPANDPTR(R10) ;Put it in the expansion buffer.
	INCL	WRK_L_EXPANDPTR(R10)	;Increment expansion buffer pointer.
	RSB

NOSUCHSYM:
	MOVL	#CLI$_UNDSYM, R0	;Signal symbol not found and
	RET				;return error to caller.

;
; Delete a local/global symbol.
;

	.ENABL	LSB
DELELCL:
	MOVAQ	PRC_Q_LOCAL(R11), R0	;Setup address of the
	BRB	10$			;proper symbol table.
DELEGBL:
	MOVAQ	PRC_Q_GLOBAL(R11), R0
10$:	MOVQ	4(R9), R1		;Get symbol name.
	MOVZWL	R1,R1			;Get low order length
	IFNORD	R1,(R2),ACCVIO2		;Error if cannot read it
	BSBW	DCL$SEARCHT		;Search for the symbol.
	BLBC	R0, NOSUCHSYM		;Branch if symbol not found.
	CMPB	SYM_B_TYPE(R3), -	;Check for a permanent
		#SYM_K_PERM		;symbol (can't delete them).
	BEQL	80$			;Branch if permanent symbol.
	DISABLE				;Protect from CTRL/Y ASTs.
	BSBW	DCL$DEALLOCSYM		;Delete the symbol.
	ENABLE				;Restore CTRL/Y ASTs.
80$:	MOVL	#1, R0			;Return a successful status
	RET				;to the caller.
	.DSABL	LSB
	
ACCVIO2:
	BRW	ACCVIO			;SIGNAL ACCESS VIOLATION
;
; ENABLE OR DISABLE PROCESSING OF CONTROL Y OR OUT-OF-BAND AST'S
;

DISACTRLY:
	BICL3	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11),R1 ;Disable CTRL/Y.
	BSBW	DCL$RESETOOB
	BRB	NORM_EXIT
ENABCTRLY:
	BISL3	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11),R1 ;Re-enable CTRL/Y.
	BSBW	DCL$RESETOOB
	BRB	NORM_EXIT

DISAOOB:				;Disable out-of-band character(s).
	BSBB	CHECKMASK		;Check for legal out-of-band mask.
	BICL3	4(R9),PRC_L_OUTOFBAND(R11),R1	;Set mask for reset routine
	BSBW	DCL$RESETOOB		;Disable appropriate oob AST's
	BRB	NORM_EXIT

ENABOOB:				;Re-enable out-of-band character(s).
	BSBB	CHECKMASK		;Check for legal out-of-band mask.
	BISL3	4(R9),PRC_L_OUTOFBAND(R11),R1	;Set mask for reset routine
	BSBW	DCL$RESETOOB		;Disable appropriate oob AST's


NORM_EXIT:
	MOVL	#1,R0			;SET SUCCESS
ERR_EXIT:
	RET

CHECKMASK:
	MOVL	PRC_L_OUTOFBAND(R11), -	;Return current out-of-band 
		8(R9) 			;character(s) enable bits.
	BITL	#^C< -			;Check for any illegal bits set.
		PRC_M_CTRLT ! -
		PRC_M_CTRLY   -
		>, 4(R9)
	BNEQ	10$			;If no illegal bits are set, return
	RSB				;to caller and finish processing.
10$:	MOVL	#CLI$_BADCTLMSK, R0	;Otherwise, quit right now returning
	RET				;an appropriate error status.

;
; ACCEPT IMAGE NAME OR COMMAND LINE TO BE EXECUTED AFTER
; CURRENT IMAGE COMPLETES
;

	.ENABL	LSB
CHAIN:					;ACCEPT IMAGE NAME FOR LATER
	MOVZBL	#PRC_M_CHAIN,R5		;SET THE BIT MASK FOR CHAIN'S
	MOVAQ	PRC_Q_IMAGENAME(R11),R6	; AND GET POINTER TO THE DESCRIPTOR
	BRB	10$			;GO JOIN THE COMMON CODE

COMMAND:				;ACCEPT COMMAND LINE FOR LATER
	MOVZBL	#PRC_M_CMD,R5		;SET THE BIT MASK FOR COMMAND LINE'S
	MOVAQ	PRC_Q_COMMAND(R11),R6	; AND GET POINTER TO THE DESCRIPTOR
10$:	IFNORD	8(R9),@12(R9),ACCVIO3	;ERROR IF CANNOT READ THE STRING
	BICB	R5,PRC_B_FLAGS2(R11)	;TURN THE FEATURE OFF INITIALLY
	MOVW	8(R9),2(R6)		;SET NEW SIZE FROM CALLING DESC
	BSBW	DCL$ALLDEACMD		;GO DEALLOCATE/RE-ALLOCATE SPACE
	BLBC	R0,ERR_EXIT		;EXIT NOW IF FAILURE...
	TSTL	R1			;ANY NEW SIZE?
	BEQL	NORM_EXIT		;NOPE, GO SET SUCCESS AND EXIT
	BISB	R5,PRC_B_FLAGS2(R11)	;YEP, SO TURN (BACK) ON THE FEATURE
	MOVQ	R1,(R6)			;LOAD DESCRIPTOR
	BBC	#PRC_V_CHAIN,R5,20$	;IF IMAGE CHAINING, APPEND $ TO IT
	MOVB	#^A'$',(R2)+		;SO THAT IT CAN BE TREATED AS FOREIGN
20$:	MOVC	8(R9),@12(R9),(R2)	;MOVE IN THE STRING
	CLRB	(R3)			;AND ENSURE IT'S TERMINATED
	BRB	NORM_EXIT		;SET SUCCESS AND EXIT
	.DSABL	LSB

;
; DEFINE OR DEASSIGN A SUPERVISOR MODE LOGICAL NAME
;

CREALOG:				;CREATE A PROCESS LOGICAL NAME
	$CRELOG_S #2,4(R9),12(R9),#PSL$C_SUPER	;PERFORM SERVICE IN SUPER MODE
	RET				;RETURN STATUS OF SERVICE DIRECTLY
DELELOG:				;DELETE PROCESS LOGICAL NAME
	$DELLOG_S #2,4(R9),#PSL$C_SUPER	;REMOVE LOGICAL NAME FROM TABLE
RET:	RET				;RETURN STATUS OF SERVICE DIRECTLY

ACCVIO3:
	BRW	ACCVIO			;REPORT ACCESS VIOLATION

;
; SPAWN A SUBPROCESS
;

SPAWN:	MOVZWL	#SPWN_C_LENGTH,R1	;SET LENGTH TO ALLOCATE
	BSBW	DCL$ALLDYNMEM		;ALLOCATE STORAGE FOR SPAWN BLOCK
	BLBC	R0,RET			;BRANCH IF ERROR DETECTED
	MOVL	R2,R6			;POINT TO BLOCK
	MOVC5	#0,(R1),#0,#SPWN_C_LENGTH,(R6)	;ZERO THE BLOCK
					; (WITHOUT DESTROYING R1)
	MOVW	R1,SPWN_W_SIZE(R6)	;SET SIZE OF BLOCK
	TSTW	CLI$Q_CMDSTR(R9)	;COMMAND STRING PRESENT?
	BEQL	10$			;BRANCH IF NOT
	IFNORD	CLI$Q_CMDSTR(R9),@CLI$Q_CMDSTR+4(R9),ACCVIO3
	MOVQ	CLI$Q_CMDSTR(R9),SPWN_Q_CMDSTR(R6) ;PASS CMDSTR DESCRIPTOR
	CLRW	SPWN_Q_CMDSTR+2(R6)
10$:	TSTW	CLI$Q_INPUT(R9)		;INPUT FILESPEC PRESENT?
	BEQL	20$			;BRANCH IF NOT
	IFNORD	CLI$Q_INPUT(R9),@CLI$Q_INPUT+4(R9),ACCVIO3
	MOVQ	CLI$Q_INPUT(R9),SPWN_Q_INPUT(R6)	;PASS INPUT FILESPEC
	CLRW	SPWN_Q_INPUT+2(R6)
20$:	TSTW	CLI$Q_OUTPUT(R9)	;OUTPUT FILESPEC PRESENT?
	BEQL	30$			;BRANCH IF NOT
	IFNORD	CLI$Q_OUTPUT(R9),@CLI$Q_OUTPUT+4(R9),ACCVIO3
	MOVQ	CLI$Q_OUTPUT(R9),SPWN_Q_OUTPUT(R6)	;PASS OUTPUT FILESPEC
	CLRW	SPWN_Q_OUTPUT+2(R6)
30$:	TSTW	CLI$Q_PRCNAM(R9)	;PROCESS NAME PRESENT?
	BEQL	40$			;BRANCH IF NOT
	IFNORD	CLI$Q_PRCNAM(R9),@CLI$Q_PRCNAM+4(R9),ACCVIO3
	MOVQ	CLI$Q_PRCNAM(R9),SPWN_Q_PRCNAM(R6)	;PASS PROCESS NAME
	CLRW	SPWN_Q_PRCNAM+2(R6)
	SETBIT	#SPWN_V_PRCNAM,SPWN_W_FLAGS(R6)	;FLAG PRCNAM PRESENT
40$:	BBS	#CLI$V_NOWAIT,CLI$B_FLAGS(R9),41$	;BRANCH IF FLAG SET
	SETBIT	#SPWN_V_WAIT,SPWN_W_FLAGS(R6)	;INDICATE IF WE SHOULD WAIT
41$:	BBS	#CLI$V_NOCLISYM,CLI$B_FLAGS(R9),42$	;BRANCH IF FLAG SET
	SETBIT	#SPWN_V_CLISYM,SPWN_W_FLAGS(R6)	;INDICATE TO COPY CLI SYMBOLS
42$:	BBS	#CLI$V_NOLOGNAM,CLI$B_FLAGS(R9),50$	;BRANCH IF FLAG SET
	SETBIT	#SPWN_V_LOGNAM,SPWN_W_FLAGS(R6)	;INDICATE TO COPY LOGNAMES
50$:	MOVL	CLI$L_ASTADR(R9),SPWN_L_ASTADR(R6)	;COPY AST ADDRESS
	MOVL	CLI$L_ASTPRM(R9),SPWN_L_ASTPRM(R6)	;COPY AST PARAMETER
	MOVB	CLI$B_EFN(R9),SPWN_B_EFN(R6)		;COPY EVENT FLAG #
	MOVL	CLI$L_LSTSTATUS(R9),SPWN_L_STSADR(R6)	;RECEIVES FINAL STATUS
	BSBW	DCL$SPAWN2		;SPAWN THE SUBPROCESS
	MOVL	SPWN_L_SUBPID(R6),CLI$L_OUTPID(R9) ;PASS SUBPROCESS PID (IN CASE NOWAIT)
	RET


;
; ATTACH THE TERMINAL TO ANOTHER PROCESS (ESSENTIALLY A CO-ROUTINE CALL)
;

ATTACH:	CLRL	R6			;MARK NO PROCESS NAME SUPPLIED
	MOVL	CLI$L_PID(R9),R8	;GET PID OF DESTINATION PROCESS
	BSBW	DCL$ATTACH2		;ATTACH TO SPECIFIED PROCESS
	RET

	.SBTTL	ALLOCATE CHAIN STRING STORAGE
;+
; DCL$ALLDEACMD - DEALLOCATE/RE-ALLOCATE CHAIN/COMMAND STRING STORAGE
;
; INPUTS:
;
;	R6 -> DESC W/ NEW SIZE @ 2(R6)
;
; OUTPUTS:
;
;	R0 =  STATUS
;	R1 =  NEW SIZE
;	R2 -> NEW BLOCK
;	R3,R4 = UNDEFINED
;-
DCL$ALLDEACMD::				;DEALLOCATE/RE-ALLOCATE CHAIN/COMMAND
	DISABLE				;DISABLE CONTROL/Y & C AST'S
	MOVZWL	(R6),R1			;GET CURRENT ALLOCATED SIZE
	BEQL	10$			;NONE
	MOVL	4(R6),R0		;SOME, GET POINTER TO BLOCK TO RETURN
	BSBW	DCL$DEADYNMEM		; AND GO RETURN IT
	CLRW	(R6)			;  THEN SAY IT'S NOW NULL
10$:	MOVL	#1,R0			;PRESET SUCCESS STATUS
	MOVZWL	2(R6),R1		;GET NEW DESCRIPTOR'S SIZE
	BEQL	20$			;ZERO LENGTH, JUST EXIT STATUS=SUCCESS
	CLRL	(R6)			;REAL LENGTH, BUT DON'T KEEP SAYING SO
	MOVL	#CLI$_ILLVAL,R0		;PRE-SET ERROR CODE
	CMPW	R1,#WRK_C_INPBUFSIZ	;DOES TEXT FIT WITH ROOM TO SPARE?
	BGTRU	20$			;BRANCH IF NOT
	ADDL	#2,R1			;ADD IN ROOM FOR '$' + TRAILING EOL
	BSBW	DCL$ALLDYNMEM		;GET THE DYNAMIC MEMORY SPACE
20$:	ENABLE				;ENABLE CONTROL/Y&C
	RSB				;EXIT

	.SBTTL	CONTROL Y AST HANDLER
;+
; DCL$CONTRLY - CONTROL Y AST HANDLER
;
; THIS ROUTINE IS CALLED WHEN A CONTROL Y AST OCCURS WHILE RUNNING IN USER
; OR SUPERVISOR MODE.
;
; INPUTS:
;
;	AP = ADDRESS OF AST ARGUMENT LIST.
;
; OUTPUTS:
;
;	THE CONTROL Y AST IS RE-ENABLED AND A CHECK IS MADE TO SEE IF THE
;	PREVIOUS MODE WAS USER OR SUPERVISOR.
;
;	PREVIOUS MODE USER:
;
;		A COMMAND WORK AREA IS ALLOCATED ON THE STACK, THE PROCESS
;		SAVED ARGUMENT AND FRAME POINTERS ARE MOVED TO THE COMMAND
;		WORK AREA, THE CURRENT ARGUMENT AND FRAME POINTERS ARE SAVED
;		IN THE PROCESS SAVE AREA, AST'S ARE ENABLED, AND THE COMMAND
;		INTERPRETER RESTART POINT IS JUMPED TO.
;
;	PREVIOUS MODE SUPERVISOR:
;
;		IF CONTROL Y AST'S ARE CURRENTLY SOFTWARE DISABLED, THEN THE
;		AST IS DISMISSED IMMEDIATELY. OTHERWISE THE SAVED PROCESS
;		ARGUMENT AND FRAME POINTERS ARE RESTORED, AST'S ARE ENABLED,
;		AND THE COMMAND INTERPRETER RESTART POINT IS JUMPED TO.
;-
	.ENABL	LSB

	.ENTRY	DCL$CONTRLY,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BSBW	CLI$GET_PRC		;GET ADDRESS OF CLI PROCESS WORK AREA
	CMPW	#SS$_HANGUP,4(AP)	;TERMINAL LINE HANGUP?
	BNEQ	10$			;IF NEQ NO
	SETBIT	PRC_V_HANGUP,PRC_W_FLAGS(R11) ;SET HANGUP PENDING
	BRB	15$			;NO MORE CONTROL Y'S ALLOWED
10$:	BSBW	DCL$ENBCONTRLY		;RE-ENABLE CONTROL Y AST
	BBC	#PRC_V_CTRLY,PRC_L_OUTOFBAND(R11),35$ ;BR IF NOT ALLOWED
15$:	BBS	#PSL$V_CURMOD,20(AP),60$ ;IF SET, PREVIOUS MODE USER
	TSTL	PRC_L_ONCTLY(R11)	;USER DEFINED ACTION
	BNEQ	30$			;BR IF YES - EXCUTE THE COMMAND
	PUSHAB	W^DCL$LOW_LIMIT		;GET ADDRESS OF LOWER ADDRESS LIMIT
	CMPL	(SP)+,16(AP)		;ADDRESS WITHIN LIMITS?
	BGTRU	20$			;IF GTRU NO
	PUSHAB	W^DCL$HIGH_LIMIT	;GET ADDRESS OF HIGH ADDRESS LIMIT
	CMPL	(SP)+,16(AP)		;ADDRESS WITHIN LIMITS?
	BGTRU	50$			;IF GTRU YES
20$:	BBS	#PRC_V_DISABL,PRC_W_FLAGS(R11),30$ ;IF SET, CONTROL Y/C AST'S DISABLED
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),40$ ;IF SET, AT CONTROL Y/C LEVEL
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	40$			;IF EQL YES
30$:	BISW	#PRC_M_CNTRLY,PRC_W_FLAGS(R11) ;SET CONTROL Y/C REQUEST
35$:	RET				;
 
;
; PREVIOUS MODE SUPERVISOR
;
 
40$:	MOVL	PRC_L_SAVFP(R11),FP	;RESTORE SAVED FRAME POINTER
	MOVL	FP,R10			;SET ADDRESS OF WRK AREA
	BRB	70$			;
 
;
; WE HAVE DETECTED A CONTROL/Y WHILE ACTIVATING AN IMAGE BUT BEFORE
; THE IMAGE WAS ACTUALLY STARTED IN USER MODE.
;
; CREATE DUMMY CONTROL Y/C AST FRAME WHICH CAN EVENTUALLY BE PLUGGED
; WITH A MODIFIED R0 AND PC/PSL (EXE$EXIT_IMAGE) BY IMAGE RUNDOWN.
;
 
50$:	MOVL	PRC_L_SAVFP(R11),FP	;RESTORE SAVED FRAME POINTER
	MOVL	FP,R10			;SET ADDRESS OF WRK AREA
	SUBL3	#6*4,WRK_L_SAVSP(R10),R6 ;ALLOCATE DUMMY AST ARGUMENT LIST
	MOVC3	#6*4,(AP),(R6)		;MOVE REAL LIST INTO ALLOCATED SPACE
	MOVL	R6,SP			;RESET STACK POINTER 

;
; ASSUME DUMMY CONTROL Y/C AST FRAME IS ON TOP OF STACK.
;

DCL$SCNTRLY::				;SUPERVISOR CONTROL Y/C
	MOVL	SP,AP			;SET ARGUMENT POINTER
	PUSHAB	B^80$			;SET RETURN ADDRESS
	MOVQ	AP,-(SP)		;SAVE ARGUMENT AND FRAME POINTERS
	CLRQ	-(SP)			;CLEAR PSW, MASK, AND HANDLER ADDRESS
	MOVL	SP,FP			;SET NEW FRAME POINTER
 
;
; PREVIOUS MODE USER
;
 
60$:	MOVAB	WRK_K_LENGTH(FP),SP	;ALLOCATE COMMAND WORK AREA
	MOVL	FP,R10			;SET ADDRESS OF WRK AREA
	MOVQ	PRC_L_SAVAP(R11),WRK_L_SAVAP(R10) ;SAVE ARGUMENT AND FRAME POINTERS
	ADDL	#20,AP			;POINT TO SAVED PSL
	MOVQ	AP,PRC_L_SAVAP(R11)	;SAVE CURRENT ARGUMENT AND FRAME POINTERS
70$:	BISW	#PRC_M_YLEVEL,PRC_W_FLAGS(R11) ;SET CONTROL Y/C LEVEL
	CHMK	#0			;ENABLE AST'S
	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND IN EXECUTION
	TSTL	PRC_L_ONCTLY(R11)	;USER DEFINED ACTION?
	BNEQ	72$			;BRANCH IF YES
	BBC	#PRC_V_PRIV,PRC_B_FLAGS2(R11),75$ ;BRANCH IF NOT PRIVILEGED IMAGE
;
; SAVE THE IMAGE PRIVILEGES FOR THE CONTINUE COMMAND TO RESTORE
; SET THE IMAGE PRIVILEGES TO THE PROCESS PRIVILEGES
;
	BSBW	DCL$SAVE_PRIVS		;
	BRB	75$
72$:	BSBW	DCL$RUNDWNI		;RUNDOWN BUT PRESERVE INDIRECT LEVELS
	BISW	#PRC_M_CNTRLY,PRC_W_FLAGS(R11) ;SET CONTROL Y/C REQUEST
75$:	BRW	DCL$RESTART		;
 
;
; CONTINUE AFTER SIMULATED CONTROL Y/C AST FROM USER MODE
;
 
80$:	ADDL	#8,SP			;REMOVE DUMMY AST COUNT AND ASTPRM
	POPR	#^M<R0,R1>		;RESTORE SAVED R0 AND R1 (PLUGGED)
	REI				;RETURN TO EXE$EXIT_IMAGE (PLUGGED)
	.DSABL	LSB

	.SBTTL	CONTROL T AST HANDLER
;+
; DCL$CONTRLT - CONTROL T AST HANDLER
;
; THIS ROUTINE IS CALLED WHEN A CONTROL T AST OCCURS.
;
; INPUTS:
;
;	AP = ADDRESS OF AST ARGUMENT LIST.
;
; OUTPUTS:
;
;	THE CONTROL T AST IS AUTOMATICALLY RE-ENABLED AND A LINE OF PROCESS
;	STATUS INFORMATION IS OUTPUT.
;-
CTRLT_ARGS = 0

.MACRO	CTRLT	NAME,LENGTH=4
.WORD	LENGTH
.WORD	JPI$_'NAME
CTRLT_ARGS = CTRLT_ARGS+1
ITEM_'NAME' = 12 * <8-CTRLT_ARGS>
BUFF_'NAME' = -4 * CTRLT_ARGS
.ENDM

CTRLT_TABLE:
	CTRLT	PAGEFLTS
	CTRLT	GPGCNT
	CTRLT	PPGCNT
	CTRLT	CPUTIM
	CTRLT	DIRIO
	CTRLT	BUFIO
	CTRLT	PRCNAM,16
	CTRLT	IMAGNAME,64

CTRLTMSG:
	.ASCII	&!AS!AS !AS !9AS CPU=!%T PF=!UL IO=!UL MEM=!UL&
CTRLTMSGEND:
DCL:	.ASCII	/  (DCL)  /
DCLEND:
NODE:	.ASCII	/SYS$NODE/
NODEEND:

	.ENTRY	DCL$CONTRLT,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	SP,R11				;SAVE STACK POINTER

;
; GET NODE NAME BY TRANSLATING SYS$NODE.  THEN REMOVE LEADING UNDERSCORE
; AND PAD WITH LEADING BLANKS TO RIGHT JUSTIFY IT.
;
	SUBL	#12,SP				;SPACE FOR NODE NAME
	PUSHL	SP				;ADDRESS OF SPACE
	MOVZBL	#12,-(SP)			;LENGTH OF NODE NAME
	MOVL	SP,R10				;ADDRESS OF DESCRIPTOR

	PUSHAB	NODE				;ADDRESS OF "SYS$NODE"
	MOVZBL	#NODEEND-NODE,-(SP)		;LENGTH OF "SYS$NODE"
	MOVL	SP,R0				;ADDRESS OF DESCRIPTOR

	$TRNLOG_S	LOGNAM=(R0),-		;CALL TRANSLATE LOGICAL
			RSLLEN=(R10),-
			RSLBUF=(R10)
	BLBC	R0,10$				;IF PROBLEM, THEN EXIT

	DECW	(R10)				;REMOVE UNDERSORE FROM NODE NAME
	INCL	4(R10)

	CMPL	R0,#SS$_NOTRAN			;SUCCESSFULLY TRANSLATED?
	BNEQ	5$				;YES, THEN SKIP
	CLRL	(R10)				;NO, THEN USE NULL STRING

;
; GET SYSTEM TIME.
;
5$:	PUSHL	SP				;PUSH BUFFER ADDR (USE SYS$NODE DESC)
	MOVZBL	#8,-(SP)			;PUSH BUFFER LENGTH
	MOVL	SP,R9
	$ASCTIM_S	TIMLEN=(R9),-		;GET CURRENT TIME
			TIMBUF=(R9),-
			CVTFLG=#1
	BLBS	R0,20$				;IF PROBLEM, THEN EXIT
10$:	BRW	150$

;
; GET JPI INFORMATION.
;
20$:	CLRL	-(SP)				;MARK END OF LIST
	MOVL	SP,R5				;INIT LIST PTR
	SUBL	#12*CTRLT_ARGS,SP		;INIT BUFFER PTR
	MOVAB	CTRLT_TABLE,R2			;INIT TABLE PTR
	CLRL	R3				;INIT ARG COUNT

30$:	MOVAW	-12(R5),-(R5)			;SET RETURN LEN ADDR
	MOVZWL	(R2),R0				;GET BUFFER LENGTH
	SUBL	R0,SP				;ALLOCATE BUFFER
	MOVL	SP,-(R5)			;SET BUFFER ADDR
	MOVL	(R2)+,-(R5)			;SET LEN AND TYPE
	AOBLEQ	#CTRLT_ARGS-1,R3,30$		;LOOP TILL END OF LIST

	$CLREF_S	EFN=#31			;CLEAR EVENT FLAG
	MOVL	R0,R3				;SAVE PREVIOUS STATUS

	$GETJPI_S	ITMLST=(R5),-		;GET JOB/PROCESS INFO
			EFN=#31
	MOVL	#1,R2				;ASSUME SUCCESS
	BLBS	R0,35$				;IF SUCCESS, THEN SKIP
	CLRL	R2				;MARK ERROR
35$:	CMPL	R3,#SS$_WASCLR			;WAS THE EF ORIGINALLY CLEAR?
	BNEQ	36$				;NO, THEN SET IT
	$CLREF_S	EFN=#31			;CLEAR EVENT FLAG
	BRB	37$				;SKIP
36$:	$SETEF_S	EFN=#31			;SET EVENT FLAG
37$:	BLBC	R2,10$				;IF PROBLEM WITH GETJPI, THEN EXIT

	EMUL	#-100000,BUFF_CPUTIM(R5),#0,-(SP)   ;CONVERT CPUTIME TO 100NS UNITS
	MOVL	SP,R6
	ADDL	BUFF_PPGCNT(R5),BUFF_GPGCNT(R5)	;CALCULATE PAGE COUNT
	ADDL	BUFF_DIRIO(R5),BUFF_BUFIO(R5)	;CALCULATE I/O TOTAL
	CLRW	ITEM_PRCNAM+2(R5)		;CLEAR JPI CODE
	MOVAB	ITEM_PRCNAM(R5),R8		;STORE ADDRESS OF DESC
	CLRW	ITEM_IMAGNAME+2(R5)		;CLEAR JPI CODE
	MOVAB	ITEM_IMAGNAME(R5),R7		;STORE ADDRESS OF DESC

;
; IF THE IMAGNAME IS NULL, THEN USE "(DCL)".  OTHERWISE, GET THE NINE 
; CHARACTER FILE NAME FROM THE IMAGE NAME.
;
	TSTW	(R7)				;IS IMAGE NAME NULL?
	BNEQ	40$				;NO, THEN EXTRACT NAME
	MOVZBL	#DCLEND-DCL,(R7)		;INSERT DEFAULT STRING
	MOVAB	DCL,4(R7)
	BRB	100$	

40$:	MOVQ	(R7),R2				;GET LENGTH AND ADDRESS
50$:	LOCC	#^A/:/,R2,(R3)			;FIND COLON
	BEQL	60$				;BRANCH IF NOT FOUND
	SUBL3	#1,R0,R2			;GET NEW LENGTH
	ADDL3	#1,R1,R3			;GET NEW ADDRESS
	BRB	50$				;LOOK FOR ANOTHER COLON	
60$:	LOCC	#^A/]/,R2,(R3)			;FIND CLOSING BRACKET
	BNEQ	70$				;BRANCH IF FOUND
	LOCC	#^A/>/,R2,(R3)			;FIND CLOSING BRACKET
	BEQL	80$				;BRANCH IF NOT FOUND
70$:	SUBL3	#1,R0,R2			;GET NEW LENGTH
	ADDL3	#1,R1,R3			;GET NEW ADDRESS
80$:	LOCC	#^A/./,R2,(R3)			;FIND PERIOD
	BEQL	90$				;BRANCH IF NOT FOUND
	SUBL	R0,R2				;REMOVE FILE TYPE
90$:	MOVQ	R2,(R7)				;STORE LENGTH AND ADDRESS


;
; CALL FAO TO FORMAT THE MESSAGE.
;
100$:	SUBL	#132,SP				;ALLOCATE SPACE FOR FAO RESULT
	PUSHL	SP				;PUSH BUFFER ADDR
	MOVZBL	#132,-(SP)			;PUSH BUFFER LENGTH
	MOVL	SP,R2

	PUSHAB	CTRLTMSG			;ADDRESS OF CTRL STRING
	MOVZBL	#CTRLTMSGEND-CTRLTMSG,-(SP)	;LENGTH OF CTRL STRING
	MOVL	SP,R3

	$FAO_S	CTRSTR = (R3),-
		OUTLEN = (R2),-
		OUTBUF = (R2),-
		P1 = R10,-			;NODE NAME
		P2 = R8,-			;PROCESS NAME
		P3 = R9,-			;CURRENT TIME
		P4 = R7,-			;IMAGE NAME
		P5 = R6,-			;CPU TIME
		P6 = BUFF_PAGEFLTS(R5),-	;PAGE FAULTS
		P7 = BUFF_BUFIO(R5),-		;I/O TOTAL
		P8 = BUFF_GPGCNT(R5)		;MEMORY USAGE
	BLBC	R0,150$				;IF PROBLEM, THEN EXIT

	MOVQ	(SP)+,R0			;POP CTRL STRING DESC

;
; BROADCAST THE MESSAGE.
;
	MOVL	#CTL$AG_CLIDATA+PPD$T_INPDVI,R1	;GET ADDR OF DEVICE NAME
	MOVZBL	(R1)+,R0			;LENGTH OF DEVICE NAME
	MOVQ	R0,-(SP)			;CREATE DESCRIPTOR

	$BRDCST_S	MSGBUF=(R2),-		;BROADCAST THE MESSAGE
			DEVNAM=(R3)

150$:	MOVL	R11,SP				;RESTORE STACK PTR
	RET


	.SBTTL	ENABLE CONTROL Y AST
;+
; DCL$ENBCONTRLY - ENABLE CONTROL Y AST
;
; THIS ROUTINE IS CALLED TO ENABLE CONTROL Y AST'S ON THE INPUT CHANNEL.
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = FINAL REQUEST STATUS.
;-
 
DCL$ENBCONTRLY::				;ENABLE CONTROL Y AST
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),90$ ;IF SET, NOT INTERACTIVE JOB
	MOVL	PRC_L_INPRAB(R11),R0		;GET ADDRESS OF INPUT RAB
	BBC	#DEV$V_TRM,RAB$L_CTX(R0),90$	;IF CLR, 'INPUT' NOT FROM TERMINAL
	$QIOW_S	EFN=#31,-			;EVENT FLAG
		CHAN=PRC_W_INPCHAN(R11),-	;INPUT CHANNEL
		FUNC=#IO$_SETMODE!IO$M_CTRLYAST,- ;FUNCTION CODE
		P1=W^DCL$CONTRLY,-		;AST ROUTINE ADDRESS
		P3=#PSL$C_SUPER			;ACCESS MODE
90$:	RSB

	.SBTTL	ENABLE/DISABLE CTRL/T AST'S
;+
; DCL$ENBCONTRLT - ENABLE/DISABLE CTRL/T AST'S
;
; THIS ROUTINE IS CALLED TO ENABLE/DISABLE CTRL/T AST'S ON THE 
; INPUT CHANNEL.
;
; INPUTS:
;
;	R1  = CONTROL MASK
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = FINAL REQUEST STATUS.
;-
 
DCL$ENBCONTRLT:					;ENABLE/DISABLE CONTROL T AST
	MOVQ	R2,-(SP)			;GET TWO REGISTERS TO WORK WITH
	MOVAL	DCL$CONTRLT,R2			;GET ADDRESS OF AST ROUTINE
	PUSHL	#PRC_M_CTRLT			;SET CHARACTER MASK
	CLRL	-(SP)				;USE SHORT FORM OF MASK
	MOVL	SP,R3				;GET ADDRESS OF MASK BLOCK
	BBS	#PRC_V_CTRLT,R1,10$		;SKIP IF ENABLING CTRL/T'S
	CLRL	R2				;CLEAR ADDRESS OF AST ROUTINE
10$:	$QIOW_S	EFN=#31,-			;EVENT FLAG
		CHAN=PRC_W_INPCHAN(R11),-	;INPUT CHANNEL
		FUNC=#IO$_SETMODE!IO$M_OUTBAND,- ;FUNCTION CODE
		P1=(R2),-			;AST ROUTINE ADDRESS
		P2=R3,-				;ADDRESS OF CHARACTER MASK
		P3=#PSL$C_SUPER			;ACCESS MODE
	MOVQ	(SP)+,R2			;POP STACK
	MOVQ	(SP)+,R2			;RESTORE REGISTERS
	RSB

	.SBTTL	RESET OUT-OF-BAND AST'S
;+
; DCL$RESETOOB - RESET OUT-OF-BAND AST'S
;
; THIS ROUTINE IS CALLED TO ENABLE OR DISABLE OUT-OF-BAND AST'S ON THE INPUT 
; CHANNEL.
;
; INPUTS:
;
;	R1  = CONTROL MASK.  BITS ARE SET IF AST SHOULD BE ENABLED, CLEAR
;	      IF AST SHOULD BE DISABLED.
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
;-
 
DCL$RESETOOB::					;ENABLE OR DISABLE OUT-OF-BAND AST
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),90$ ;IF SET, NOT INTERACTIVE JOB
	MOVL	PRC_L_INPRAB(R11),R0		;GET ADDRESS OF INPUT RAB
	BBC	#DEV$V_TRM,RAB$L_CTX(R0),90$	;IF CLR, 'INPUT' NOT FROM TERMINAL

	PUSHL	R1				;SAVE AST CHARACTER MASK
	BBC	#PRC_V_CTRLT,R1,10$		;SKIP IF DISABLING CTRL/T'S
	BBS	#PRC_V_CTRLT,PRC_L_OUTOFBAND(R11),30$  ;SKIP IF ALREADY ENABLED
	BRB	20$				;ENABLE CTRL/T AST
10$:	BBC	#PRC_V_CTRLT,PRC_L_OUTOFBAND(R11),30$  ;SKIP IF ALREADY DISABLED
20$:	BSBW	DCL$ENBCONTRLT			;ENABLE/DISABLE CTRL/T AST'S

30$:	MOVL	(SP)+,PRC_L_OUTOFBAND(R11)	;SET OUT-OF-BAND MASK
90$:	RSB


	.SBTTL	COMMAND INTERPRETER CONDITION HANDLER
;+
; DCL$CONDHAND - COMMAND INTERPRETER CONDITION HANDLER
;
; THIS ROUTINE IS CALLED AS THE RESULT OF AN EXCEPTION CONDITION THAT OCCURS
; WHILE EXECUTING IN THE COMMAND INTERPRETER.
;
; INPUTS:
;
;	MECHANISM AND SIGNAL VECTORS
;
; OUTPUTS:
;
;	ANY EXIT HANDLERS ARE CANCELLED AND THE CONDITION IS RESIGNALLED.
;-
 
	.ENTRY	DCL$CONDHAND,^M<>
	$CANEXH_S			;CANCEL ANY EXIT HANDLERS
	CLRL	R0			;RESIGNAL THE CONDITION
	RET

	.END
