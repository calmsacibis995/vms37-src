	.TITLE	INITIAL - COMMAND INTERPRETER INITIALIZATION
	.IDENT	'V03-015'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 29-MAR-77
;
; COMMAND LANGUAGE INTERPRETER INITIALIZATION
;
; MODIFICATIONS:
;
;	V015	PCG0003		Peter George	22-Apr-1982]
;		Add another SYS$ERROR sanity check.
;
;	V014	PCG0002		Peter George	22-Jan-1982
;		Update to structure level 5 tables.
;
;	V013	PCG0001		Peter George	12-Jan-1982
;		Do not set CTRL/T bit in OUTOFBAND bitmask.  Modify P1-P8
;		processing so that one byte hex FF is transformed to a null
;		string.  Pass OUTOFBAND context to spawned process.
;
;	V012	TMH0012		Tim Halvorsen	22-Dec-1981
;		Move autologout flag from cmdstr to header record.
;		Accept verification flag passed in context record.
;		Propagate EOF silent logout flag from context to PRC.
;
;	V011	TMH0011		Tim Halvorsen	30-Nov-1981
;		Zero initial level 0 indirect frame, in order to
;		establish an initial value for the F$SEARCH context
;		listhead, as well as any new cells which get defined later.
;
;	V010	TMH0010		Tim Halvorsen	20-Nov-1981
;		Add code to handle CLISYM spawn context records.
;		Convert NOCTLY flag to use OUTOFBAND enable bitmask.
;
;	V009	TMH0009		Tim Halvorsen	29-Oct-1981
;		Add code to initialize based on SPAWN context.
;
;	V008	BLS0089		Benn Schreiber	20-Oct-1981
;		Update to structure level 4 tables
;
;	V007	TMH0007		Tim Halvorsen	12-Oct-1981
;		Allocate exactly 8 indirect frames from the storage area
;		in P1 space, so that extra space in P1 will not inadvertedly
;		be used as indirect levels that were never intended to be
;		supported.  This is done to fix the number of supported
;		indirect levels at 8.
;
;	V006	TMH0006		Tim Halvorsen	09-Aug-1981
;		Accept structure level 3 tables as well as level 2.
;		Level 3 is the same as 2, except that the pointer
;		table is longword offsets rather than word offsets.
;
;	V005	TMH0005		Tim Halvorsen	27-Jul-1981
;		Fix reference to tables sharable image to be PIC.
;
;	V004	TMH0004		Tim Halvorsen	13-Jun-1981
;		Use new format of string symbol table entries,
;		a word-counted string value.
;		Fix word-relative reference to DCLTABLES sharable
;		image to be general addressing mode.
;
;	V003	TMH0003		Tim Halvorsen	27-Apr-1981
;		Add routine CLI$GET_PRC to set address of PRC in R11.
;
;	V002	TMH0002		Tim Halvorsen	02-Apr-1981
;		Initialize PRC area to communicate to new LOGIN
;		protocol.
;
;	V001	TMH0001		Tim Halvorsen	09-Jul-1980
;		Move initialization of SP to first instruction so that
;		the debugger initialization can branch around it.
;---

;
; MACRO LIBRARY CALLS
;
 
	$PPDDEF				; PROCESS PERMANENT DATA AREA
	PRCDEF				; CLI PROCESS WORK AREA
	PRDDEF				; CLI PROCESS RMS AREA
	WRKDEF				; COMMAND WORK AREA
	IDFDEF				; INDIRECT PROCEDURE FRAME
	SYMDEF				; SYMBOL TABLE DEFINITIONS
	VECDEF				; COMMAND TABLE HEADER AREA
	CTXDEF				; SPAWN CONTEXT RECORD FORMATS
	$FABDEF				; FILE ACCESS BLOCK
	$RABDEF				; RECORD ACCESS BLOCK
	$PSLDEF				; PROCESSOR STATUS FIELDS
	$DIBDEF				; GETDEV CHARACTERISTICS BLOCK
	$LOGDEF				; LOGICAL NAME TABLE CODES
	$CLIMSGDEF			; CLI MESSAGE CODES

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

SYS$ERROR:
	.ASCIC	'SYS$ERROR'

;
; TABLE OF RESERVED SYMBOLS
;
RESERVED:				;
	.BYTE	1			;MAXIMUM LENGTH OF SEVERITY LEVEL
	.ASCIC	'$SEVERITY'		;ERROR SEVERITY LEVEL SYMBOL
	.BYTE	PRC_L_SEVERITY		;OFFSET TO SEVERITY VALUE ADDRESS
	.BYTE	10			;MAXIMUM LENGTH OF STATUS VALUE
	.ASCIC	'$STATUS'		;STATUS VALUE SYMBOL
	.BYTE	PRC_L_STATUS		;OFFSET TO STATUS VALUE ADDRESS
	.BYTE	0			; --- END OF TABLE

	.SBTTL	COMMAND INTERPRETER START UP
;+
; DCL$STARTUP - COMMAND INTERPRETER START UP
;
; THIS ENTRY POINT IS JUMPED TO AT THE CONCLUSION OF LOGGING A USER ONTO
; THE SYSTEM. ALL INPUT AND OUTPUT FILES ARE OPEN AND THE COMMAND LANGUAGE
; INDEPENDENT DATA AREA HAS BEEN INITIALIZED.
;-
 
	.PSECT	DCL$$BASE,BYTE,RD,NOWRT

	MOVL	G^CTL$AL_STACK+8,SP	;RELOAD SUPERVISOR STACK POINTER
	CLRL	FP			;INDICATE NO PREVIOUS FRAME
	CALLG	(SP),W^DCL$STARTUP	;SETUP INITIAL CALL FRAME
	$EXIT_S

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
DCL$STARTUP::				;COMMAND INTERPRETER START UP
	.WORD	^M<>			;ENTRY MASK
	CLRL	-(SP)			;SETUP DUMMY PSL (@PRC_L_SAVAP=PRVPSL)
	CALLG	(SP),B^10$		;CREATE DUMMY FP AFTER DUMMY AP
	RET
10$:	.WORD	0
	MOVAB	W^DCL$CONDHAND,(FP)	;ESTABLISH CONDITION HANDLER
	MOVAB	W^DCL$UTLSERV+2,G^CTL$AL_CLICALBK ; SET CALL BACK VECTOR
	MOVAB	G^CTL$AG_CLIDATA,R10	;GET ADDRESS OF PPD
;
; INITIALIZE CLI PROCESS WORK AREA
;
	MOVL	PPD$Q_CLIREG+4(R10),R11	;GET ADDRESS OF CLI PRIVATE STORAGE
	MOVC5	#0,(SP),#0,PPD$Q_CLIREG(R10),(R11) ;ZERO ALL STORAGE
	MOVQ	AP,PRC_L_SAVAP(R11)	;SAVE INITIAL ARGUMENT AND FRAME POINTERS
	MOVW	PPD$W_INPCHAN(R10),PRC_W_INPCHAN(R11)	;COPY INPUT CHANNEL
	BBC	#PPD$V_MODE,PPD$W_FLAGS(R10),20$	;COPY JOB MODE
	BISW	#PRC_M_MODE!PRC_M_VERIFY,PRC_W_FLAGS(R11) ;AND TURN VERIFY ON
20$:	BISL	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11) 	;ENABLE CTRL/Y 
	BBC	#PPD$V_NOCTLY,PPD$W_FLAGS(R10),25$	;COPY NOCONTROLY MODE
	CLRBIT	PRC_V_CTRLY,PRC_L_OUTOFBAND(R11)
25$:	MOVAB	G^DCL$AL_TAB_VEC,PRC_L_TAB_VEC(R11)	;ADDRESS OF DATABASE
	MOVW	#4,PRC_B_EXMDEPWID(R11)	;SET EXAMINE MODE TO HEX,WIDTH TO 4
;
; FOR BATCH JOBS, SETUP TO EXIT ON ERRORS.  FOR INTERACTIVE JOBS,
; DO AN IMPLIED "SET NOON".
;
	MOVW	#2,PRC_W_ONLEVEL(R11)	;ASSUME "ON ERROR THEN EXIT"
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),30$ ;IF BATCH JOB, THIS IS OK
	MOVW	#2@8!8,PRC_W_ONLEVEL(R11) ;IF INTERACTIVE, "SET NOON"
;
; INITIALIZE CLI SYMBOL TABLE
;
30$:	MOVAB	PRC_Q_GLOBAL(R11),R0	;GET ADDRESS OF GLOBAL TABLE LISTHEAD
	MOVL	R0,(R0)			;INIT GLOBAL SYMBOL TABLE EMPTY
	MOVL	(R0)+,(R0)+
	ASSUME	PRC_Q_LABEL EQ PRC_Q_GLOBAL+8
	MOVL	R0,(R0)			;INIT LABEL TABLE EMPTY
	MOVL	(R0)+,(R0)+
	ASSUME	PRC_Q_LOCAL EQ PRC_Q_LABEL+8
	MOVL	R0,(R0)			;INIT CURRENT LOCAL SYMBOL TABLE EMPTY
	MOVL	(R0)+,(R0)+
	MOVQ	PPD$Q_CLISYMTBL(R10),R0	;GET LENGTH/ADDRESS OF REGION
	MOVL	R1,PRC_Q_ALLOCREG(R11)	;INIT LISTHEAD OF ALLOCATION REGION
	CLRL	(R1)+			;CLEAR LINK TO NEXT FREE BLOCK
	MOVL	R0,(R1)			;SET LENGTH OF THIS FREE BLOCK
;
; CREATE RESERVED SYMBOLS $STATUS AND $SEVERITY
;
	MOVAB	RESERVED,R6		; GET ADDRESS OF RESERVED SYMBOLS
	MOVAB	PRC_Q_GLOBAL(R11),R5	; GET ADDRESS OF SYMBOL TABLE LISTHEAD
40$:	MOVZBL	(R6)+,R1		; GET MAXIMUM LENGTH OF VALUE STRING
	BEQL	50$			; IF EQL END OF TABLE
	MOVL	R6,R2			; SET ANY ADDRESS FOR SYMBOL VALUE
	MOVZBL	(R6)+,R3		; CONSTRUCT DESCRIPTOR OF SYMBOL NAME
	MOVL	R6,R4
	ADDL	R3,R6			; ADJUST TO ADDRESS OFFSET
	MOVZBL	#SYM_K_PERM,R0		; DEFINE SYMBOL AS PERMANENT
	BSBW	DCL$ALLOCSYM		; ALLOCATE AND INSERT PERMENENT SYMBOL
	MOVZBL	SYM_T_SYMBOL(R1),R0	; GET LENGTH OF SYMBOL NAME
	MOVAB	SYM_T_SYMBOL+1(R1)[R0],R0 ; GET ADDRESS OF SYMBOL VALUE
	CLRW	(R0)+			; CLEAR LENGTH OF SYMBOL VALUE
	MOVZBL	(R6)+,R1		; GET OFFSET TO ADDRESS OF SYMBOL VALUE
	ADDL	R11,R1			; CALCULATE ADDRESS TO STORE VALUE ADDRESS
	MOVL	R0,(R1)			; SET ADDRESS OF SYMBOL VALUE
	BRB	40$
;
; FOR BATCH JOBS, CREATE SYMBOLS P1 THRU P8 AS THE JOB PARAMETERS
;
50$:	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),70$ ;BRANCH IF NOT BATCH JOB
	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVAB	-64(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
	PUSHL	#64
	PUSHL	#^A'P0'			;PUSH PROTOTYPE LOGICAL/SYMBOL NAME
	PUSHL	SP			;AND CONSTRUCT DESCRIPTOR OF IT
	PUSHL	#2
	MOVL	SP,R6			;GET ADDRESS OF DESCRIPTOR
	MOVL	#8,R7			;LOOP 8 TIMES
60$:	MOVL	#64,12(R6)		;RESET LENGTH OF BUFFER
	INCB	9(R6)			;INCREMENT SYMBOL NAME
	$TRNLOG_S LOGNAM=(R6),-		;TRANSLATE LOGICAL NAME P#
		RSLBUF=12(R6),-		;INTO BUFFER ON STACK
		RSLLEN=12(R6),-
		DSBMSK=#3		;DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPL	R0,#SS$_NORMAL		;SUCCESS?
	BEQL	65$			;IF NOT,
	CLRL	12(R6)			;SET THE SYMBOL TO NULL STRING
65$:	CMPW	12(R6),#1		;ONE CHARACTER?
	BNEQ	66$			;BR IF NO
	CMPB	@16(R6),#^XFF		;HEX FF?
	BNEQ	66$			;BR IF NO
	CLRL	12(R6)			;SET TO NULL STRING
66$:	MOVQ	12(R6),R1		;GET DESCRIPTOR OF SYMBOL VALUE
	MOVQ	(R6),R3			;GET DESCRIPTOR OF SYMBOL NAME
	MOVZBL	#SYM_K_STRING,R0	;DEFINE SYMBOL AS A STRING
	BSBW	DCL$ALLOCSYM		;DEFINE SYMBOL IN SYMBOL TABLE
	SOBGTR	R7,60$			;LOOP UNTIL ALL SYMBOLS DONE
	MOVAB	8+4+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
;
; INITIALIZE PROCESS RMS DATA AREA
;
70$:	MOVAB	PRC_C_LENGTH(R11),R8	;SET ADDRESS OF RMS STRUCTURES (PRD)
	MOVAB	PRD_G_FAB(R8),PRC_L_INDFAB(R11)	;ADDRESS OF GENERAL PURPOSE FAB
	ASSUME	PRD_G_FAB EQ 0		;ASSUME FAB AT START OF STRUCTURE
	MOVAB	PRD_G_INPRAB(R8),R9	;SET ADDRESS OF INPUT RAB
	MOVAB	PRD_G_OUTRAB(R8),R7	;SET ADDRESS OF OUTPUT RAB
	ASSUME	FAB$B_BID EQ 0
	ASSUME	FAB$B_BLN EQ 1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,PRD_G_FAB(R8)	;SET FAB ID/LENGTH
	MOVAB	PRD_G_NAM(R8),FAB$L_NAM(R8) ;SET ADDRESS OF NAM BLOCK
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,PRD_G_NAM(R8)	;SET NAM ID/LENGTH
	MOVW	#RAB$C_BID+<RAB$C_BLN@8>,RAB$B_BID(R9)	;SET RAB ID/LENGTH
	MOVW	PPD$W_INPISI(R10),RAB$W_ISI(R9)		;SET INPUT ISI
	MOVW	RAB$B_BID(R9),RAB$B_BID(R7)		;SET RAB ID/LENGTH
	MOVW	PPD$W_OUTISI(R10),RAB$W_ISI(R7)		;SET OUTPUT ISI
	MOVL	R8,RAB$L_FAB(R9)			;SET ADDRESS OF FAB
	MOVL	R8,RAB$L_FAB(R7)			;SET ADDRESS OF FAB
; SET PPF DIRECT ACCESS, SO THAT RMS USER-MODE EOF CHECKING IS NOT DONE
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R9)	;ENABLE DIRECT ACCESS
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R7)	;TO INPUT STREAMS
	ASSUME	RAB$W_ISI EQ RAB$B_BLN+1
	MOVL	RAB$B_BID(R9),PRD_G_ALTINPRAB(R8)	;SET RAB ID/LENGTH/ISI
	MOVL	RAB$B_BID(R7),PRD_G_ALTOUTRAB(R8)	;SET RAB ID/LENGTH/ISI
; STORE DEVICE CHARACTERISTICS IN THE RAB$L_CTX FIELD SO THAT RAB IS ENOUGH
	MOVL	PPD$L_INPDEV(R10),RAB$L_CTX(R9)	; INPUT DEVICE CHARACTERISTICS
	MOVL	PPD$L_OUTDEV(R10),RAB$L_CTX(R7)	; OUTPUT DEVICE CHARACTERISTICS
; LIMIT ALLOCATION OF BLOCKS/BUFFERS ON PPF STREAM (PIOSEG SPACE IS LIMITED)
	MOVB	#1,RAB$B_MBC(R9)	;ONLY ALLOCATE 1 BLOCK/BUFFER
	MOVB	#-1,RAB$B_MBF(R9)	;ONLY ALLOCATE 1 BUFFER/STREAM
	ASSUME	RAB$B_MBC EQ RAB$B_MBF+1
	MOVW	RAB$B_MBF(R9),RAB$B_MBF(R7)	; SET MBC/MBF FOR ALL RABS
	MOVW	RAB$B_MBF(R9),PRD_G_ALTINPRAB+RAB$B_MBF(R8)
	MOVW	RAB$B_MBF(R9),PRD_G_ALTOUTRAB+RAB$B_MBF(R8)
; SET READ-WITH-PROMPT ON ALL RABS USED TO READ INPUT COMMANDS
	SETBIT	RAB$V_PMT,PRD_G_ALTINPRAB+RAB$L_ROP(R8) ;SET READ WITH PROMPT
	SETBIT	RAB$V_PMT,PRD_G_INPRAB+RAB$L_ROP(R8)    ;SET READ WITH PROMPT
; USE SAME RAB FOR BOTH INPUT AND OUTPUT IF THEY BOTH POINT TO THE SAME STREAM
; (THIS IS FOR CODE SEGMENTS WHICH DECIDE IF THEY ARE THE SAME BY COMPARING
; THE INPUT AND OUTPUT RAB ADDRESSES RATHER THAN THEIR ISI'S)
	CMPW	RAB$W_ISI(R7),RAB$W_ISI(R9) ;ARE INPUT AND OUTPUT THE SAME?
	BNEQ	75$			;BRANCH IF NOT
	MOVL	R9,R7			;USE INPUT RAB FOR OUTPUT
; STORE FAB/RAB ADDRESSES IN PRC AREA FOR EASY ACCESS
75$:	MOVL	R7,PRC_L_ERRRAB(R11)	;SET ADDRESS OF ERROR RAB
	MOVL	R7,PRC_L_OUTRAB(R11)	;SET ADDRESS OF OUTPUT RAB
	MOVL	R9,PRC_L_INPRAB(R11)	;SET ADDRESS OF INPUT RAB
	MOVL	R7,PRC_L_INDOUTRAB(R11)	;SET ADDRESS OF INDIRECT OUTPUT RAB
	MOVL	R9,PRC_L_INDINPRAB(R11)	;SET ADDRESS OF INDIRECT INPUT RAB
;
; INITIALIZE INDIRECT FRAME STACK & LEVEL 0 FRAME.  IF WE HAVE ENOUGH SPACE,
; ALLOCATE ROOM FOR EXACTLY 8 FRAMES.  IF NOT, GET AS MANY FRAMES AS POSSIBLE.
;
	MOVAB	PRC_C_LENGTH+PRD_C_XLENGTH(R11),- ;SET LIMIT OF INDIRECT FRAMES
		PRC_L_STACKLM(R11)	;TO WHAT IS AVAILABLE
	ADDL3	PPD$Q_CLIREG(R10),PPD$Q_CLIREG+4(R10),R0 ;GET END+1 OF REGION
	MOVAB	-512(R0),R0		;*** DO NOT USE LAST PAGE - TO CATCH
					;*** BUG IN DCL WHICH REFERENCES OFF
					;*** THE END OF THE INDIRECT STACK
					;*** BEYOND OUR STORAGE AREA.
	MOVAB	-IDF_K_LENGTH(R0),R9	;ADDRESS OF LEVEL 0 FRAME
	MOVAB	-8*IDF_K_LENGTH(R9),R0	;COMPUTE BASE OF STACK W/8 FRAMES
	CMPL	R0,PRC_L_STACKLM(R11)	;ROOM FOR EXACTLY 8 FRAMES?
	BLEQU	77$			;IF NOT, USE WHATEVER ROOM WE HAVE
	MOVL	R0,PRC_L_STACKLM(R11)	;ELSE, LIMIT TO EXACTLY 8 FRAMES
77$:	MOVL	R9,PRC_L_STACKPT(R11)	;SET INDIRECT FRAME STACK POINTER
	MOVL	R9,PRC_L_IDFLNK(R11)	;SET LINK POINTER
	MOVC5	#0,(SP),#0,#IDF_C_LENGTH,(R9) ;ZERO LEVEL 0 FRAME
					;(IDF_L_LNK=0 TO TERMINATE LIST)
					;(IDF_L_SEARCHCTX=0 TO INITIALIZE LIST)
	MOVW	PPD$W_OUTIFI(R10),PRC_W_ERRIFI(R11) ;SAVE ERROR IFI
	MOVW	PPD$W_OUTIFI(R10),IDF_W_OUTIFI(R9) ;SAVE OUTPUT IFI
	MOVW	PPD$W_INPIFI(R10),IDF_W_INPIFI(R9) ;SAVE INPUT IFI
	MOVW	RAB$W_ISI(R7),IDF_W_OUTISI(R9)	;SAVE OUTPUT ISI
	MOVL	PPD$L_OUTDEV(R10),IDF_L_OUTRABCTX(R9) ;SAVE OUTPUT DEVCHAR
	MOVL	PPD$L_INPDEV(R10),IDF_L_INPRABCTX(R9) ;SAVE INPUT DEVCHAR
	MOVC	#16,PPD$T_OUTDVI(R10),IDF_T_OUTDVI(R9) ;COPY OUTPUT DEVICE NAME
	MOVC	#PPD$C_DVIFID,PPD$T_INPDVI(R10),- ;COPY INPUT DEVICE NAME/IDS
		IDF_T_INPDVI(R9)
;
; STACK INITIALIZATION PROCEDURES PROC1 THRU PROC(PPD$B_NPROCS)
;
	MOVAB	-64(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZBL	#64,-(SP)
	MOVQ	#^A'PROC0',-(SP)	;PUSH PROTOTYPE PROCEDURE NAME
	PUSHL	SP			;AND CONSTRUCT DESCRIPTOR OF IT
	PUSHL	#5
	MOVL	SP,R6			;GET ADDRESS OF DESCRIPTOR
	MOVZBL	PPD$B_NPROCS(R10),R7	;GET NUMBER OF INITIAL PROCEDURES
	ADDB	R7,12(R6)		;SET TO LAST PROCEDURE NAME
80$:	MOVZBL	#64,16(R6)		;RESET LENGTH OF BUFFER
	$TRNLOG_S LOGNAM=(R6),-		;TRANSLATE LOGICAL NAME PROC#
		RSLBUF=16(R6),-		;INTO BUFFER ON STACK
		RSLLEN=16(R6),-
		DSBMSK=#3		;DON'T LOOK IN GROUP OR SYSTEM TABLES
	CMPW	R0,#SS$_NOTRAN		;NO TRANSLATION?
	BEQL	85$			;IF SO, SKIP THIS ONE
	MOVQ	16(R6),R2		;GET DESCRIPTOR OF PROCEDURE NAME
	CLRL	R4			;SPECIFY PRIMARY OUTPUT FILE
	MOVL	#1,R1			;SUPPRESS RMS ERROR MESSAGES
	BSBW	DCL$PUSHPROC		;PUSH PROCEDURE ONTO INDIRECT STACK
					;IGNORE ANY ERRORS (LIKE FNF, ETC.)
85$:	DECB	12(R6)			;DECREMENT PROCEDURE NUMBER
	SOBGTR	R7,80$			;LOOP UNTIL ALL SYMBOLS DONE
	MOVAB	8+8+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
;
; RUNDOWN LOGINOUT IMAGE, THUS DELETING ALL USER-MODE LOGICAL NAMES
;
	$RUNDWN_S #PSL$C_USER		;RUNDOWN LOGIN IMAGE
;
; IF THIS PROCESS IS A SUBPROCESS WHICH WAS CREATED BY THE DCL SPAWN
; COMMAND, THEN OPEN THE MAILBOX CONTAINING THE PROCESS CONTEXT AND
; INITIALIZE THIS PROCESS.
;
	CLRQ	-(SP)			;CREATE GETJPI ITEM LIST
	PUSHAB	-2*4(SP)		;SET BUFFER ADDRESS
	PUSHL	#JPI$_OWNER@16+4	;REQUEST PARENT PID, SET BUFFER LENGTH
	MOVL	SP,R0
	$GETJPI_S ITMLST=(R0)		;GET PID OF PARENT PROCESS
	POPL	R9			;GET PID
	ADDL	#3*4,SP			;CLEANUP STACK
	TSTL	R9			;IS THIS A SUBPROCESS?
	BEQL	120$			;IF NOT, SKIP SPAWN INITIALIZATION
	MOVAB	-64(SP),SP		;ALLOCATE BUFFER ON STACK
	PUSHL	SP			;CONSTRUCT DESCRIPTOR OF BUFFER
	MOVZBL	#64,-(SP)
	MOVL	SP,R6			;POINT TO BUFFER DESCRIPTOR
	SUBL	#4,SP			;ALLOCATE SCRATCH LONGWORD FOR ACMODE
	MOVAB	SYS$ERROR,R2		;GET ADDRESS OF ASCIC STRING
	MOVZBL	(R2)+,R1		;CONSTRUCT DESCRIPTOR OF STRING
	MOVQ	R1,-(SP)		;PUSH DESCRIPTOR OF SYS$ERROR
	$TRNLOG_S LOGNAM=-12(R6),-	;TRANSLATE SYS$ERROR
		RSLBUF=(R6),-
		RSLLEN=(R6),-
		DSBMSK=#3,-		;ONLY SEARCH PROCESS LOGNAME TABLE
		ACMODE=-4(R6)
	CMPB	-4(R6),#PSL$C_SUPER	;SUPERVISOR MODE SYS$ERROR?
	BNEQ	100$			;IF NOT, THEN NO CONTEXT WAS PASSED
	CMPL	@4(R6),#^A'_MBA'	;IS MAILBOX NAME A PHYSICAL DEVICE?
	BNEQ	90$			;IF NOT, INVALID SPAWN - DELETE LOGNAM
	BSBW	SPAWN_CONTEXT		;INITIALIZE BASED ON SPAWN CONTEXT
90$:	MOVL	SP,R0			;GET ADDRESS OF 'SYS$ERROR' DESCRIPTOR
	$DELLOG_S LOGNAM=(R0),-		;DELETE SUPERVISOR MODE SYS$ERROR
		TBLFLG=#LOG$C_PROCESS,-	;LEAVING EXECUTIVE MODE SYS$ERROR
		ACMODE=#PSL$C_SUPER	;(WHICH IS EQUIVALENT TO SYS$OUTPUT)
100$:	MOVAB	8+4+8+64(SP),SP		;DEALLOCATE SCRATCH STORAGE
;
; MAKE SURE COMMAND TABLES HAVE A VALID STRUCTURE LEVEL NUMBER
;
120$:	MOVL	PRC_L_TAB_VEC(R11),R0	; GET ADDRESS OF SYNTAX TABLES
	CMPB	VEC_B_STRLVL(R0),#2	; STRUCTURE 2 TABLES?
	BLSSU	BADSTR			; BRANCH IF NOT STR LEVEL 2 OR BETTER
	CMPB	VEC_B_STRLVL(R0),#5	; LEVEL MUST BE 2-5
	BGTRU	BADSTR			; BRANCH IF ILLEGAL FORMAT TABLES
;
; ENABLE CONTROL/Y AST ROUTINE AND OUT-OF-BAND AST ROUTINES.
;
	BSBW	DCL$ENBCONTRLY		; ENABLE CONTROL Y AST'S
	MOVL	PRC_L_OUTOFBAND(R11),R1	; GET AST CHARACTER MASK
	CLRL	PRC_L_OUTOFBAND(R11)	; FORCE INITIALIZATION
	BSBW	DCL$RESETOOB		; ENABLE/DISABLE APPROPRIATE AST'S
;
; ENABLE CHANGE MODE TO SUPERVISOR HANDLING ROUTINE
;
	$DCLCMH_S W^DCL$CHANGE_MODE	; SET CHANGE MODE TO SUPER HANDLER
	BLBC	R0,INITIAL_ERROR	; BRANCH IF ERROR DETECTED
;
; PROCESS FIRST COMMAND LINE
;
	BRW	DCL$RESTART		; START COMMAND INTERPRETATION

;
; ILLEGAL OR UNRECOGNIZED TABLE STRUCTURE LEVEL
;
BADSTR:	MOVL	#CLI$_BADSTRLVL,R0	;ERROR MESSAGE CODE

INITIAL_ERROR:
	MOVL	SP,R10			;SET BASE ADDRESS OF WRK
	MOVAB	WRK_C_LENGTH(SP),SP	;ALLOCATE WRK TO SIGNAL MESSAGE
	MOVW	#WRK_M_COMMAND,WRK_W_FLAGS(R10)	;CLEAR FLAGS, SET WRK_V_COMMAND
					;TO MARK NO ERROR TEXT SEGMENT
	BSBW	DCL$ERRORMSG		;ISSUE ERROR MESSAGE
	BRW	DCL$ABORT		;AND EXIT PROCESS

	.SBTTL	SPAWN_CONTEXT, INITIALIZE BASED ON SPAWN CONTEXT
;---
;
; THIS ROUTINE IS CALLED TO INITIALIZE THE SUBPROCESS FROM THE CONTEXT
; PASSED FROM THE PARENT PROCESS DURING EXECUTION OF A SPAWN COMMAND.
;
; INPUTS:
;
;	R6 = ADDRESS OF DESCRIPTOR OF MAILBOX DEVICE NAME
;		(PASSED TO SUBPROCESS AS SYS$ERROR TRANSLATION)
;	R9 = PID OF PARENT PROCESS
;	R11 = ADDRESS OF PRC AREA
;
; OUTPUTS:
;
;	THE CONTEXT IS INITIALIZED, IF POSSIBLE.
;
;	R0-R8 DESTROYED.
;---

SPAWN_CONTEXT:
	ASSUME	DIB$C_LENGTH LE CTX_C_MAXLEN
	MOVAB	-CTX_C_MAXLEN(SP),SP	;ALLOCATE DIB/CTX STORAGE
	PUSHL	SP			;CREATE DESCRIPTOR OF DIB BUFFER
	MOVZWL	#CTX_C_MAXLEN,-(SP)
	MOVAL	-(SP),R2		;ALLOCATE CHANNEL LONGWORD
	$ASSIGN_S DEVNAM=(R6),-		;ASSIGN A CHANNEL TO THE MAILBOX
		CHAN=(R2)
	BLBC	R0,90$			;IF ERROR, SKIP IT
	$GETCHN_S CHAN=(R2),-		;GET DEVICE CHARACTERISTICS
		PRIBUF=4(R2)
	BLBC	R0,50$			;IF ERROR, SKIP IT
	BBC	#DEV$V_MBX,DIB$L_DEVCHAR+12(R2),50$ ;IF NOT MAILBOX, SKIP IT
;
; READ NEXT RECORD FROM MAILBOX AND PROCESS IT
;
10$:	MOVL	SP,R2			;GET ADDRESS OF CHAN,IOSB,BUFFER
	$QIOW_S FUNC=#IO$_READVBLK,-	;READ NEXT RECORD
		CHAN=(R2),-
		IOSB=4(R2),-		;RE-USE DESCRIPTOR AS IOSB
		P1=12(R2),-		;ADDRESS OF RECEIVE BUFFER
		P2=#CTX_C_MAXLEN	;SIZE OF RECEIVE BUFFER
	BLBC	R0,50$			;IF SUBMIT ERROR, SKIP IT
	BLBC	4(R2),50$		;IF I/O ERROR (OR EOF), EXIT
	CMPL	8(R2),R9		;IS TRANSMITTER OUR PARENT PROCESS?
	BNEQ	50$			;IF NOT, SKIP IT
	MOVZWL	6(R2),R4		;GET SIZE OF RECORD
	MOVAB	12(R2),R5		;POINT TO CTX RECORD
	PUSHAB	10$			;RETURN TO TOP OF LOOP AFTER PROCESSING
	; THESE ROUTINES MAY DESTROY R0-R8
	; ON ENTRY, R4/R5 = DESCRIPTOR OF CTX RECORD
	CASE	CTX_W_TYPE(R5),TYPE=W,<- ;CASE ON TYPE OF RECORD
		SPAWN_HEADER,-		;HEADER RECORD
		SPAWN_CMDSTR,-		;COMMAND STRING
		SPAWN_LOGNAM,-		;LOGICAL NAME
		SPAWN_CLISYM>		;CLI SYMBOL
	RSB				;IF UNKNOWN, SKIP RECORD
50$:	$DASSGN_S CHAN=(R2)		;DEASSIGN CHANNEL TO MAILBOX
90$:	MOVAB	4+8+CTX_C_MAXLEN(SP),SP	;DEALLOCATE SCRATCH STORAGE
	RSB

;
; PROCESS A SPAWN HEADER CONTEXT RECORD
;

SPAWN_HEADER:
	MNEGL	#1,-(SP)		;CREATE PRIVILEGE MASK WITH ALL
	MNEGL	#1,-(SP)		;THE PRIVILEGE BITS SET
	MOVL	SP,R0			;GET ADDRESS OF IT
	$SETPRV_S PRVADR=(R0),-		;DISABLE ALL PRIVILEGES
		  PRMFLG=#1,-		;
		  ENBFLG=#0		;
	ADDL	#8,SP			;DEALLOCATE PRIVILEGE MASK ON STACK
	$SETPRV_S PRVADR=CTX_Q_PROCPRIV(R5),- ;ENABLE NEW PRIVILEGES
		  PRMFLG=#1,-		;
		  ENBFLG=#1		;
	BBC	#CTX_V_AUTOLOGO,CTX_B_FLAGS(R5),10$ ;COPY SILENT LOGOUT FLAG
	SETBIT	PRC_V_AUTOLOGO,PRC_W_FLAGS(R11)
10$:	BBC	#CTX_V_EOFLOGO,CTX_B_FLAGS(R5),20$ ;COPY EOF SILENT LOGOUT FLAG
	SETBIT	PRC_V_EOFLOGO,PRC_W_FLAGS(R11)
20$:	CLRBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11)	;ASSUME FLAG OFF
	BBC	#CTX_V_VERIFY,CTX_B_FLAGS(R5),30$ ;COPY VERIFICATION FLAG
	SETBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11)
30$:	MOVL	CTX_L_OUTOFBAND(R5),-	;COPY OUT-OF-BAND AST MASK
		PRC_L_OUTOFBAND(R11)  
	RSB

;
; PROCESS COMMAND STRING RECORD
;

SPAWN_CMDSTR:
	MOVAB	PRC_Q_COMMAND(R11),R6	;POINT TO COMMAND DESCRIPTOR AREA
	SUBW3	#CTX_T_CMDSTR,R4,R7	;COMPUTE SIZE OF COMMAND STRING
	MOVW	R7,2(R6)		;SET SIZE OF COMMAND STRING
	BSBW	DCL$ALLDEACMD		;ALLOCATE BUFFER TO HOLD COMMAND
	BLBC	R0,90$			;IF ERROR, SKIP IT
	MOVQ	R1,(R6)			;STORE DESCRIPTOR OF BUFFER
	MOVC	R7,CTX_T_CMDSTR(R5),(R2) ;STORE COMMAND STRING IN BUFFER
	CLRB	(R3)			;AND ENSURE THAT ITS TERMINATED
	SETBIT	PRC_V_CMD,PRC_B_FLAGS2(R11) ;MARK COMMAND PENDING
90$:	RSB

;
; PROCESS SPAWN LOGICAL NAME RECORDS
;

SPAWN_LOGNAM:
	MOVZBL	CTX_B_ACMODE(R5),R0	;GET ACMODE OF LOGICAL NAME
	CMPB	R0,#PSL$C_SUPER		;IS ACMODE HIGHER THAN SUPER?
	BLSS	90$			;IF EXEC OR KERNEL, CANNOT DEFINE IT
	PUSHAB	CTX_T_LOGNAM+1(R5)	;PUSH DESCRIPTOR OF LOGNAM
	MOVZBL	CTX_T_LOGNAM(R5),-(SP)
	ADDL3	(SP),4(SP),R2		;POINT TO WORD COUNTED EQLNAM
	MOVZWL	(R2)+,R1		;CONSTRUCT DESCRIPTOR OF EQLNAM
	PUSHR	#^M<R1,R2>		;PUSH DESCRIPTOR OF EQLNAM
	MOVL	SP,R3			;GET ADDRESS OF STACK
	$CRELOG_S LOGNAM=8(R3),-	;CREATE LOGICAL NAME
		EQLNAM=(R3),-
		ACMODE=R0,-
		TBLFLG=#LOG$C_PROCESS
	ADDL	#4*4,SP			;CLEANUP STACK
90$:	RSB

;
; PROCESS SPAWN CLI SYMBOL RECORDS
;

SPAWN_CLISYM:
	ASSUME	CTX_C_STRING EQ SYM_K_STRING
	ASSUME	CTX_C_PERM EQ SYM_K_PERM
	ASSUME	CTX_C_BINARY EQ SYM_K_BINARY
	MOVZBL	CTX_B_SYMTYPE(R5),R0	; R0 = SYMBOL TYPE
	MOVAB	CTX_T_SYMBOL(R5),R4	; GET ADDRESS OF ASCIC NAME
	MOVZBL	(R4)+,R3		; R3/R4 = DESCRIPTOR OF SYMBOL NAME
	ADDL3	R3,R4,R2		; POINT TO JUST AFTER SYMBOL NAME
	ASSUME	CTX_C_STRING EQ 0
	ASSUME	CTX_C_PERM EQ 1
	ASSUME	CTX_C_BINARY EQ 2
	CASE	R0,TYPE=B,<-		; CASE ON SYMBOL TYPE
		10$,-			; STRING
		10$,-			; PERMANENT STRING
		20$>			; BINARY
	RSB				; SKIP UNKNOWN TYPES
10$:	MOVZWL	(R2)+,R1		; R1/R2 = DESCRIPTOR OF STRING VALUE
	BRB	40$
20$:	MOVL	(R2),R1			; R1 = LONGWORD BINARY VALUE
40$:	MOVL	R5,R6			; COPY ADDRESS OF CTX RECORD
	ASSUME	CTX_C_GLOBAL EQ 0
	ASSUME	CTX_C_LOCAL EQ 1
	CASE	CTX_B_SYMTAB(R5),TYPE=B,<-	; CASE ON SYMBOL TABLE
		50$,-			; GLOBAL SYMBOL TABLE
		60$>			; LOCAL SYMBOL TABLE
	RSB				; IGNORE UNKNOWN SYMBOL TABLE NUMBER
50$:	MOVAB	PRC_Q_GLOBAL(R11),R5	; R5 = ADDRESS OF GLOBAL SYMBOL LISTHEAD
	BRB	70$
60$:	MOVAB	PRC_Q_LOCAL(R11),R5	; R5 = ADDRESS OF LOCAL TABLE LISTHEAD
70$:	BSBW	DCL$ALLOCSYM		; ADD SYMBOL (R0-R5 ARE ARGUMENTS)
	BLBC	R0,90$			; BRANCH IF ERROR DETECTED
	MOVB	CTX_B_NONUNIQUE(R6),SYM_B_NONUNIQUE(R1) ; SET UNIQUENESS POSITION
90$:	RSB

	.SBTTL	CLI$GET_PRC, GET ADDRESS OF PRC STRUCTURE
;---
;
;	THIS ROUTINE IS CALLED TO GET THE ADDRESS OF THE CLI
;	OWN STORAGE AREA (PRC).
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;---

CLI$GET_PRC::
	MOVAB	G^CTL$AG_CLIDATA,R11	;GET ADDRESS OF PPD
	MOVL	PPD$L_PRC(R11),R11	;SET ADDRESS OF CLI OWN STORAGE
	RSB
 
	.END	DCL$STARTUP
