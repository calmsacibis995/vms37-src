	.TITLE	READREC - READ AN INPUT RECORD
	.IDENT	'V03-006'
	.DEFAULT DISPLACEMENT,WORD

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ABSTRACT:
;
;	These routines are called by the lexical processing routines to
;	perform functions which are optional to the basic lexical routines,
;	but are required by CLI parsing.
;
; AUTHOR:
;
;	Tim Halvorsen, Jan-1982
;
; MODIFIED BY:
;
;	V006	PCG0003		Peter George	21-Apr-1982
;		Do not trash R2 when doing RSA $GET.
;
;	V005	PCG0002		Peter George	07-Apr-1982
;		Fix differences between first $GET and RSA-case
;		$GET that occasionally cause commands to be ignored.
;
;	V004	PCG0001		Peter George	15-Mar-1982
;		Mark position before indirect processing.
;		Do not upcase token following apostraphe in a comment.
;
;	V003	TMH0003		Tim Halvorsen	10-Feb-1982
;		Increase the number of retries in TMH0002 to an intense number
;		to really get the job done so it works.
;
;	V002	TMH0002		Tim Halvorsen	23-Jan-1982
;		Increase number of retries on record stream active
;		error from RMS, to allow sufficient time for I/O to
;		complete before bombing away the RMS I/O.
;
;	V001	TMH0001		Tim Halvorsen	07-Jan-1982
;		Call DCL$ERRORMSG in the character manipulation error
;		reporting routine.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$RABDEF				;DEFINE RAB OFFSETS
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

	.SBTTL	READ NEXT INPUT RECORD
;+
; DCL$INPUT - READ NEXT INPUT RECORD
;
; READS THE NEXT INPUT RECORD AND PLACES IT INTO THE INPUT BUFFER.
; THE CHARACTER POINTER IS RESET TO THE BEGINNING OF THE RECORD.  A
; SYMBOL SUBSTITUTION PASS IS PERFORMED IF A SINGLE OCCURRENCE OF A
; SINGLE QUOTE IS DETECTED IN THE RECORD.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;	R10 = ADDRESS OF WRK AREA
;
; OUTPUTS:
;
;	WRK_L_CHARPTR POINTS TO BEGINNING OF INPUT RECORD, WHICH
;		HAS BEEN TERMINATED BY A NULL BYTE.
;
;	R0 = FIRST CHARACTER IN INPUT BUFFER
;-
DCL$INPUT::				;INPUT NEXT RECORD
	PUSHR	#^M<R2,R3,R4>		;SAVE REGISTERS
;
; IF AUTOLOGO FLAG SET AND WE ARE AT LEVEL 0 OR CTRL/Y LEVEL,
; THEN DELETE THIS PROCESS TO PERFORM AN IMPLIED LOGOUT BUT WITHOUT
; ANY LOGOUT MESSAGE.  THIS IS FOR THE SPAWN COMMAND.
;
REINP:	BBC	#PRC_V_AUTOLOGO,PRC_W_FLAGS(R11),4$ ;BRANCH IF FLAG NOT SET
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),4$ ;BR IF DOING AN INQUIRE
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),1$ ;IF SET, AT CONTROL Y/C LEVEL
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	4$			;BRANCH IF NOT
1$:	BRW	SILENT_LOGOUT		;PERFORM SILENT LOGOUT
;
; GET ADDRESS OF THE RAB ASSOCIATED WITH THIS INDIRECT LEVEL
;
4$:	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),5$ ;IF SET, QUERY IN PROGRESS
	MOVL	PRC_L_INDINPRAB(R11),R4	;GET ADDRESS OF LEVEL N RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
5$:	MOVL	PRC_L_INPRAB(R11),R4	;GET ADDRESS OF LEVEL 0 RAB
;
; SETUP PROMPT STRING
;
10$:	MOVAB	-WRK_C_MSGBUFSIZ(SP),SP	;ALLOCATE SPACE FOR PROMPT STRING
	MOVL	SP,R0			;SAVE ADDRESS OF PROMPT STRING STORAGE
	MOVL	R0,RAB$L_PBF(R4)	;SET ADDRESS OF PROMPT STRING
	MOVL	WRK_L_PROMPT(R10),R2	;GET ADDRESS OF PROMPT STRING
	MOVZBL	(R2)+,R1		;NOW THE LENGTH OF THE STRING
	CMPB	R1,#WRK_C_MSGBUFSIZ-2	;BIGGER THAN OUR BUFFER?
	BLEQU	15$			;BRANCH IF OK - COPY IT
	MOVB	#WRK_C_MSGBUFSIZ-2,R1	;IF PROMPT TOO BIG, TRUNCATE IT
15$:	ADDB3	#2,R1,RAB$B_PSZ(R4)	;SET LENGTH OF PROMPT STRING
	MOVW	#<10@8>+13,(R0)+	;INSERT CARRIAGE RETURN/LINE FEED PAIR
20$:	MOVB	(R2)+,(R0)+		;MOVE CHARACTER TO PROMPT BUFFER
	SOBGTR	R1,20$			;ANY MORE TO MOVE?
;
; READ THE NEXT INPUT RECORD
;
	MOVZBW	#WRK_C_INPBUFSIZ,RAB$W_USZ(R4) ;SET SIZE OF INPUT BUFFER
	MOVAB	WRK_G_INPBUF-2(R10),R2	;GET ADDRESS OF INPUT BUFFER
	MOVL	R2,RAB$L_UBF(R4)	;SET ADDRESS OF INPUT BUFFER
	MOVAB	-1(R2),WRK_L_CHARPTR(R10) ;SET POINTER FOR GET CHARACTER
	DISABLE				;DISABLE CONTROL Y/C AST'S
	BBC	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),21$ ;SKIP IF NOT INQUIRING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)	;SET INDIRECT PPF
21$:	$GET	RAB=(R4)		;GET NEXT RECORD FROM INPUT FILE
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)	;CLEAR INDIRECT PPF
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BLBC	R0,40$			;IF LBC I/O ERROR
22$:	MOVZWL	RAB$W_RSZ(R4),R3	;GET LENGTH OF INPUT RECORD
	MOVAB	WRK_C_MSGBUFSIZ(SP),SP	;DEALLOCATE PROMPT STRING STORAGE
	CLRB	(R2)[R3]		;SET EOL INDICATOR
;
; IF GOTO MODE AND THERE ARE NO COLONS ON THE LINE, RE-ISSUE READ NOW
; AS AN OPTIMIZATION.
;
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),24$ ;BRANCH IF NOT IN GOTO MODE
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),24$ ;SKIP IF IN CTRL/Y LEVEL
	LOCC	#^A':',R3,(R2)		;LINE HAVE ANY POSSIBLE LABELS?
	BNEQ	30$			;IF POSSIBLY A LABEL, CHECK IT OUT
23$:	BRW	50$			;ELSE, SKIP LINE AND READ NEXT LINE
;
; SUBSTITUTE ANY SYMBOLS WHICH ARE DELIMITED BY SINGLE QUOTES
;
24$:	LOCC	#^A/'/,R3,(R2)		;LINE HAVE POSSIBLE STRING SUBSTITUTION?
	BEQL	25$			;IF EQL NO
	BSBW	EXPAND			;EXPAND LINE IF APPROPRIATE
;
; IF VERIFY MODE, WRITE A COPY OF THE COMMAND LINE TO THE LOG FILE
;
25$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),30$ ;IF CLR, NO LINE VERIFICATION
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),30$ ;IF SET, AT CONTROL Y/C LEVEL
	CMPL	R4,PRC_L_INDOUTRAB(R11)	;READ FROM OUTPUT?
	BEQL	30$			;IF EQL YES, DON'T RE-ECHO
	MOVL	R3,R1			;THE LENGTH OF THE LINE
	BSBW	DCL$MSGOUT		;OUTPUT INPUT LINE
;
; IF WE JUST READ A FULL-LINE COMMENT, RE-ISSUE READ NOW AS AN OPTIMIZATION.
; 
30$:	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),33$ ;MUST TAKE IMMEDIATE ACTION
					;IF CTRLY HIT - SKIP OPTIMIZATION
	CLRL	R4			;SET NO DOLLAR SIGN SEEN FLAG
32$:	LOCC	(R2)+,#5,B^39$		;CHECK FOR SPECIAL CHARS
	BEQL	33$			;IF EQL NO MATCH
	SUBL	#3,R0			;BLANK OR TAB?
	BLSS	32$			;IF LSS YES
	BEQL	33$			;IF EQL END OF LINE
	DECL	R0			;DOLLAR SIGN OR COMMENT?
	BGTR	23$			;IF GTR COMMENT
	BBCS	#0,R4,32$		;IF CLR, FIRST DOLLAR SIGN
;
; IF THE PREVIOUS RECORD ENDED WITH TRAILING SPACES OR TABS,
; INSERT A SPACE AT THE FRONT OF THE CURRENT INPUT RECORD SO
; THAT PARAMETERS ARE DELIMITED PROPERLY.
;
33$:	BBCC	#WRK_V_TRAILSPC,WRK_W_FLAGS(R10),35$ ;IF CLR, NO TRAILING SPACE SEEN
	MOVB	#^A/ /,R0		;SET SPACE CHARACTER
	BSBW	DCL$BACKUPCHAR		;APPEND TO FRONT OF INPUT BUFFER
35$:	POPR	#^M<R2,R3,R4>		;RESTORE REGISTERS
	MOVAB	DCL$T_REPROMPT,WRK_L_PROMPT(R10) ;SET FOR CONTINUATION PROMPT
	BSBW	DCL$GETCHAR		;GET FIRST CHARACTER OF NEW RECORD
	RSB
 
39$:	.ASCII	/!$/<0>/ 	/	;SPECIAL CHARACTERS

;
; AN INPUT I/O ERROR HAS OCCURRED.  IF WE GOT "RECORD STREAM ACTIVE",
; TRY CANCELING ALL I/O ON THE INPUT CHANNEL AND REISSUE THE READ.
;
40$:	CMPW	R0,#RMS$_RSA&^XFFFF	;ERROR RECORD STREAM ACTIVE
	BNEQ	45$			;IF NO CHECK FOR END_OF_FILE
	; WE DON'T WANT TO HAVE TO CANCEL AN RMS I/O UNLESS NECESSARY.
	; RETRY UP SEVERAL TIMES TO ALLOW CURRENT WRITE I/O TO COMPLETE.
	; THIS AVOIDS SPURIOUS WRITE ABORT MESSAGES FROM USER PROGRAMS,
	; CAUSED BY CANCELING AN RMS I/O OPERATION.
	MOVZWL	#1000,R2		;SETUP RETRY COUNT
	BBC	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),42$ ;SKIP IF NOT INQUIRING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)	;SET INDIRECT PPF
42$:	$GET	RAB=(R4)		;SEE IF THE WAITING GAVE RMS SOME TIME
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)	;CLEAR INDIRECT PPF
	BLBS	R0,43$			;THE WAIT DID THE TRICK, GO AHEAD NOW
	CMPW	R0,#RMS$_RSA&^XFFFF	;RECORD STREAM STILL ACTIVE?
	BNEQ	45$			;BRANCH IF NOT
	SOBGTR	R2,42$			;RETRY UNTIL STREAM BECOMES INACTIVE
	$CANCEL_S PRC_W_INPCHAN(R11)	;IF NO LUCK, STOP THE I/O ON THAT CHANNEL
	$WAIT	RAB=(R4)		;WAIT FOR I/O TO COMPLETE
	MOVAB	WRK_C_MSGBUFSIZ(SP),SP	;DEALLOCATE PROMPT STRING STORAGE
	BRB	50$			;TRY TO READ AGAIN
43$:	MOVAB	WRK_G_INPBUF-2(R10),R2	;GET ADDRESS OF INPUT BUFFER
	BRW	22$			;PROCESS THE INPUT LINE

;
; IF WE ARE AT END OF FILE, TERMINATE THE CURRENT PROCEDURE LEVEL AND
; READ THE NEXT RECORD FROM THE PREVIOUS PROCEDURE LEVEL.
;
45$:	MOVAB	WRK_C_MSGBUFSIZ(SP),SP	;DEALLOCATE PROMPT STRING STORAGE
	CMPW	R0,#RMS$_EOF&^XFFFF	;END OF FILE?
	BNEQ	60$			;IF NEQ NO
	CLRB	(R2)			;SET END OF LINE INDICATOR
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),55$ ;IF SET, AT CONTROL Y/C LEVEL
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),55$ ;BR IF DOING AN INQUIRE
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	57$			;IF EQL, YES
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT FILE
;
; IF WE JUST RETURNED BACK TO LEVEL 0, FORCE THE PROMPT STRING BACK TO NORMAL
; BEFORE RE-ISSUING A READ FOR THE NEXT COMMAND.
;
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	50$			;BRANCH IF NOT
	MOVAB	DCL$T_PROMPT,WRK_L_PROMPT(R10) ;RESET TO NORMAL LEVEL 0 PROMPT
;
; IF INDIRECT FILE RECOGNITION IS DISABLED, THIS IS A FLUSH OF A
; COMMAND WITH "-" AS THE LAST CHARACTER.  RETURN AN EOL CHARACTER.
; OTHERWISE, PROCESS THE LINE JUST READ
;
50$:	BBC	#PRC_V_IND,PRC_W_FLAGS(R11),56$ ;IF BIT IS SET,
55$:	BRW	33$			;THEN DOING A FLUSH
56$:	BRW	REINP			;ELSE READ THE NEXT LINE
;
; IF WE GOT AN END OF FILE WHILE READING THE LEVEL 0 PROCEDURE IN A
; NON-INTERACTIVE JOB, TERMINATE THE JOB STEP.  IGNORE EOF'S (CTRL/Z)
; IN AN INTERACTIVE JOB.
;
57$:	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),59$ ;BR IF NOT IN A GOTO
	BSBW	DCL$DEALGOTO		;DEALLOCATE AST CONTROL BLOCK
	STATUS	USGOTO			;SET FINAL STATUS OF UNSTATISFIED GOTO
	SETBIT WRK_V_COMMAND,WRK_W_FLAGS(R10) ;MARK COMMAND EXECUTION ERROR
	ERRMSG				;PRINT THE ERROR
58$:	BSBW	DCL$SET_STATUS		;GIVE ERROR HANDLER A CHANCE
59$:	BBS	#PRC_V_EOFLOGO,PRC_W_FLAGS(R11),SILENT_LOGOUT ;IF SILENT LOGOUT REQUESTED
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),50$ ;IF NOT BATCH JOB, IGNORE EOF
	BRW	DCL$ABORT		;LOG OUT BATCH JOB
;
; SOME OTHER TYPE OF I/O ERROR HAS OCCURRED.  ISSUE AN ERROR MESSAGE,
; THEN TERMINATE THE CURRENT PROCEDURE LEVEL AND PARSE THE NEXT COMMAND.
;
60$:	SETBIT WRK_V_COMMAND,WRK_W_FLAGS(R10) ;MARK COMMAND EXECUTION ERROR
	ERRMSG				;OUTPUT ERROR MESSAGE
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),STATUS ;IF SET, CNTL Y/C LEVEL
	BBS	#WRK_V_INQUIRE,WRK_W_FLAGS(R10),STATUS ; SKIP IF IN INQUIRE
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	70$			;IF NEQ NO
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),58$ ;BR IF BATCH
	BRB	STATUS			;
70$:	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT FILE
	POPR	#^M<R0>			;RESTORE ERROR/STATUS VALUE
STATUS:	BSBW	DCL$SET_STATUS		;SET COMPLETION STATUS
	BRW	DCL$RESTART
;
; PERFORM A SILENT LOGOUT BY CANCELING THE SUPERVISOR MODE EXIT HANDLERS
; (SO THAT THE PROCESS IS DELETED), AND INVOKING $EXIT WITH THE LATEST
; STATUS FOR THIS PROCESS.
;
SILENT_LOGOUT::
	$CANEXH_S			;CANCEL SUPERVISOR MODE EXIT HANDLERS
	$EXIT_S	PRC_L_LSTSTATUS(R11)	;EXIT PROCESS WITH FINAL STATUS

	.SBTTL	EXPAND INPUT LINE
;---
; EXPAND - EXPAND INPUT LINE WITH SYMBOL SUBSTITUTIONS
;
; SUBROUTINE TO EXPAND INPUT LINE BY EXECUTING ALL STRING SUBSTITUTION
; COMMANDS.  THE UNUSED AREA IN THE EXPANSION BUFFER IS USED TEMPORARILY
; TO HOLD THE EXPANDED COPY OF THE COMMAND LINE.  AFTER ALL SUBSTITUTIONS
; ARE PERFORMED, THE EXPANDED COPY IS COPIED BACK INTO THE INPUT RECORD
; BUFFER SO THAT SEMANTIC PARSING CAN CONTINUE.
;
; INPUTS:
;
;	WRK_L_CHARPTR = POINTER TO NEW INPUT RECORD
;
; OUTPUTS:
;
;	R2 = ADDRESS OF NEW INPUT RECORD
;	R3 = LENGTH OF NEW INPUT RECORD, EXCLUDING NULL AT END OF LINE
;	WRK_L_CHARPTR = POINTER TO EXPANDED INPUT RECORD
;---
 
EXPAND:					;EXPAND INPUT LINE
	PUSHR	#^M<R4,R5,R6,R7,R8,R9>	;SAVE REGISTERS
	PUSHL	WRK_L_MARKPTR(R10)	;SAVE MARKER POINTER
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE EXPANSION BUFFER POINTER
	MOVW	WRK_W_FLAGS(R10),-(SP)	;SAVE CURRENT PARSING FLAGS
	BISW	#WRK_M_INPSUBST!WRK_M_NOUPCASE!WRK_M_STAR,WRK_W_FLAGS(R10)
					;PREVENT PROCESSING OF !,-,@,ETC.
					;AND PREVENT UPCASING OF INPUT CHARS
					;AND ACCEPT '*' AS A TERMINATOR
	CLRW	-(SP)			;INITIALIZE ITERATION COUNTER
;
; GET NEXT CHARACTER FROM INPUT RECORD
;
10$:	BSBW	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT LINE
	CMPB	R0,#^A/'/		;STRING SUBSTITUTION COMMAND?
	BNEQ	70$			;IF NEQ NO
	BBC	#WRK_V_QUOTE,WRK_W_FLAGS(R10),20$ ;IF LBC NOT IN QUOTE
	BSBW	DCL$SETCHAR		;CHECK NEXT CHARACTER
	CMPB	R0,#^A/'/		;NEXT CHARACTER ALSO SINGLE QUOTE?
	BNEQ	60$			;IF NEQ NO
	BSBW	DCL$GETCHAR		;GOBBLE SECOND SINGLE QUOTE
	BRB	20$			;TRY SYMBOL SUBSTITUTION
;
; ONE SINGLE QUOTE WAS DETECTED IN A DOUBLE QUOTED STRING - TREAT LITERALLY
;
60$:	MOVZBL	#^A/'/,R0		;INSERT SINGLE QUOTE WITHIN STRING
;
; IF COMMENT IS DETECTED, THEN DO SUBSTITUTIONS BUT IF AN ERROR IS
; DETECTED, THEN NO ERROR IS ISSUED AND A NULL STRING IS SUBSTITUTED.
;
70$:	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(R10),80$ ;BRANCH IF IN QUOTED STRING
	CMPB	R0,#^A'!'		;START OF COMMENT STRING?
	BNEQ	80$			;BRANCH IF NOT A COMMENT
	SETBIT	WRK_V_COMMENT,WRK_W_FLAGS(R10) ;MARK WE ARE IN A COMMENT
					;SO THAT ERRORS ARE NOT REPORTED
;
; WRITE THE CURRENT CHARACTER INTO THE EXPANSION BUFFER AND LOOP
;
80$:	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN EXPANSION BUFFER
	BNEQ	10$			;IF NOT EOL, KEEP SCANNING
	BRW	90$			;END OF LINE - TERMINATE SCAN
;
; SYMBOL SUBSTITUTION REQUESTED.  GET THE SYMBOL AND SEARCH THE SYMBOL
; TABLE, AND IF NOT FOUND THERE, TRY AS A LEXICAL FUNCTION.
;
20$:	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE PLACE IN EXPANSION BUFFER
	MOVW	WRK_W_FLAGS(R10),-(SP)	;SAVE LEXICAL FLAGS
	BICW	#WRK_M_QUOTE,WRK_W_FLAGS(R10)
	BBS	#WRK_V_COMMENT,-	;ARE WE IN A COMMENT?
		WRK_W_FLAGS(R10),22$
	BICW	#WRK_M_NOUPCASE,WRK_W_FLAGS(R10)  ;NO, THEN UPCASE THE SYMBOL
					;PRETEND WE'RE NOT IN A STRING
					;SO GETOKEN STOPS BEFORE END-OF-STRING
22$:	MOVZBL	#^A/'/,R0		;INSERT SINGLE QUOTE WITHIN STRING
	BSBW	DCL$PUTCHAR		;IN CASE SUBSTITION NOT ALLOWED
	BSBW	DCL$GETOKEN		;GET/COPY NEXT TOKEN
;
; IF IN COMMENT, ONLY ALLOW F$VERIFY TO BE SUBSTITUTED
;
	BBC	#WRK_V_COMMENT,WRK_W_FLAGS(R10),28$ ;BRANCH IF NOT IN COMMENT
	CMPL	R1,#4			;AT LEAST 4 CHARACTER TOKEN?
	BLSS	25$			;IF NOT, SKIP SYMBOL SUBSTITUTION
	MOVL	(R2),-(SP)		;PUSH FIRST FOUR CHARACTERS
	MOVQ	R1,-(SP)		;SAVE DESCRIPTOR
	MOVZBL	#4,R1			;CREATE TEMPORARY DESCRIPTOR
	MOVAB	8(SP),R2
	BSBW	DCL$REMBLANKS		;UPCASE THE SYMBOL
	MOVQ	(SP)+,R1		;RESTORE THE REGISTERS
	CMPL	(SP)+,#^A'F$VE'		;IS IT F$VERIFY WITHIN A COMMENT?
	BEQL	28$			;IF SO, ALLOW SUBSTITUTION
25$:	MOVL	WRK_L_EXPANDPTR(R10),2(SP) ;COPY 'SYMBOL TO EXPANSION BUFFER
	BRB	50$
28$:	TSTL	R1			;ZERO LENGTH SYMBOL?
	BEQL	40$			;IF EQL YES
	MOVQ	R1,R6			;SAVE STRING PARAMETERS
	BSBW	DCL$SEARCH		;SEARCH FOR SYMBOL
	BLBS	R0,40$			;IF LBS SYMBOL DEFINITION FOUND
	CLRBIT	WRK_V_INPSUBST,WRK_W_FLAGS(R10) ;DO PROCESSING OF !,-,@,ETC.
					;TO ALLOW CONTINUATIONS IN FUNCT. ARGS
	BBC	#WRK_V_COMMENT,-	;ARE WE IN A COMMENT?
		WRK_W_FLAGS(R10),32$
	MOVQ	R6,R1			;YES, THEN UPCASE "F$VERIFY"
	BSBW	DCL$REMBLANKS
	MOVQ	R1,R6	
32$:	BSBW	DCL$LEXIF		;EVALUATE LEXICAL FUNCTION
40$:	BSBW	DCL$CVT_STRING		;CONVERT RESULT TO CHARACTER STRING
	SETBIT	WRK_V_INPSUBST,WRK_W_FLAGS(R10) ;DISABLE !,-,@,ETC.
;
; TRAILING SINGLE QUOTES ARE OPTIONAL AFTER SYMBOL - GOBBLE IT
;
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER
	CMPB	R0,#^A/'/		;SYMBOL END WITH SINGLE QUOTE?
	BNEQ	30$			;BRANCH IF TRAILING SINGLE QUOTE
	BSBW	DCL$GETCHAR		;GOBBLE TRAILING QUOTE
;
; APPEND THE SYMBOL TRANSLATION TO THE FRONT OF THE INPUT BUFFER
; AND RESET THE INPUT POINTER TO POINT TO IT.  THIS IS DONE IN CASE
; THERE ARE ANY SINGLE QUOTES IN THE TRANSLATION WHICH REQUIRE SUBSTITUTION.
;
30$:	SUBL	R1,WRK_L_CHARPTR(R10)	;CALCULATE ADDRESS TO COPY STRING
	MOVL	WRK_L_CHARPTR(R10),R0	;POINT TO NEW POSITION IN INBUF
	MOVC	R1,(R2),1(R0)		;CONCATENATE STRING TO INPUT BUFFER
;
; A MAXIMUM OF 1000 SUBSTITUTIONS IS ALLOWED PER LINE, TO PREVENT ANY
; INFINITE LOOPS FROM OCCURRING DUE TO RECURSIVE SUBSTITUTIONS.
;
50$:	MOVW	(SP)+,WRK_W_FLAGS(R10)	;RESTORE FLAGS QUOTE AND NOUPCASE
	POPL	WRK_L_EXPANDPTR(R10)	;RETRIEVE ADDRESS IN EXPANSION BUFFER
	ACBW	#1000,#1,(SP),10$	;CHECK FOR SUBSTITUTION LOOP
	STATUS	EXPSYN			;EXPRESSION SYNTAX ERROR
	ADDL3	R6,R7,WRK_L_EXPANDPTR(R10) ;POINT AT END OF SYMBOL
	MOVAB	-(R7),WRK_L_MARKPTR(R10) ;SET ADDRESS OF "'"
	BRW	DCL$PARSERR		;REPORT ERROR
;
; END OF LINE DETECTED.  MOVE EXPANDED LINE BACK INTO THE INPUT BUFFER
; FOR THE LEXICAL PROCESSING.
;
90$:	MOVL	4(SP),R7		;GET SAVED EXPANSION POINTER
	SUBL3	R7,WRK_L_EXPANDPTR(R10),R9 ;CALCULATE LENGTH OF EXPANDED LINE
	MOVAB	WRK_G_INPBUF+WRK_C_INPBUFSIZ(R10),R8 ;FIND END OF INPUT BUFFER
	SUBL	R9,R8			;COMPUTE ADDRESS TO MOVE LINE TO
	MOVC	R9,(R7),(R8)		;MOVE EXPANDED LINE TO END OF INPUT BUFFER
	MOVQ	R8,R2			;SET INPUT LINE PARAMETERS
	DECL	R3			;DECREMENT LENGTH TO EXCLUDE EOL CHAR
	MOVAB	-1(R2),WRK_L_CHARPTR(R10);SET ADDRESS OF EXPANDED INPUT LINE
	TSTW	(SP)+			;REMOVE ITERATION COUNTER FROM STACK
	MOVW	(SP)+,WRK_W_FLAGS(R10)	;RESTORE CURRENT PARSING FLAGS
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	POPL	WRK_L_MARKPTR(R10)	;RESTORE MARKER POINTER
	POPR	#^M<R4,R5,R6,R7,R8,R9>	;RESTORE REGISTERS
	RSB

	.SBTTL	SPECIAL TOKEN LEXICAL PROCESSING
;---
;
; THIS ROUTINE IS CALLED TO PROCESS LEXICAL TOKENS WITH SPECIAL CHARACTERS.
; THE LIST OF CHARACTERS ARE:
;
;	&SYMBOL		- TOKEN IS SUBSTITUTED WITH SYMBOL VALUE
;	@FILESPEC	- TOKEN IS SUBSTITUTED WITH FIRST RECORD CONTAINED
;			  IN THE ASSOCIATED PROCEDURE FILE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PRC AREA
;	R10 = ADDRESS OF WRK AREA
;	R0 = FIRST CHARACTER IN TOKEN
;
; ADDITIONAL INPUT AND OUTPUT SPECIFICATIONS ARE GIVEN WITH EACH ROUTINE.
;
;---

DCL$SPECIAL::
	CMPB	R0,#^A'&'		;SUBSTITUTION?
	BEQL	AMPERSAND		;BRANCH IF SO
	CMPB	R0,#^A'@'		;INDIRECTION?
	BEQL	INDIRECT		;BRANCH IF SO
	RSB				;IF NOT KNOWN, IGNORE IT

	.SBTTL	PROCESS &SYMBOL CONSTRUCT
;---
;
; HANDLE &SYMBOL CONSTRUCT.
;
; INPUTS:
;
;	R0 = CHARACTER IN INPUT BUFFER (&)
;	R1/R2 = DESCRIPTOR OF TOKEN, INCLUDING "&" CHARACTER
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;	R1/R2 = DESCRIPTOR OF UPDATED TOKEN
;
;	THE EXPANSION BUFFER WILL BE OVERWRITTEN WITH SYMBOL VALUE
;
;---
AMPERSAND:
	PUSHR	#^M<R2,R3,R4,R5>	;SAVE REGISTERS
	INCL	R2			;POINT TO SYMBOL NAME
	DECL	R1			;ADJUST LENGTH OF SYMBOL NAME
	BEQL	40$			;BRANCH IF NULL SYMBOL NAME
	BSBW	DCL$SYM_STRING		;SEARCH LOCAL/GLOBAL SYMBOL TABLES
40$:	MOVC	R1,(R2),@(SP)		;OVERWRITE "&SYMBOL" WITH ITS VALUE
	MOVL	R3,WRK_L_EXPANDPTR(R10)	;SET NEW EXPANSION BUFFER POINTER
	POPR	#^M<R2,R3,R4,R5>	;RESTORE REGISTERS
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;CALCULATE LENGTH OF NEW TOKEN
	RSB

	.SBTTL	PROCESS @FILESPEC CONSTRUCT
;---
;
; HANDLE @FILESPEC CONSTRUCT.
;
; INPUTS:
;
;	R0 = CHARACTER IN INPUT BUFFER (@)
;
;	AT THIS POINT, ONLY THE @ HAS BEEN SEEN, AND THE FILESPEC
;	HAS NOT YET BEEN PROCESSED.
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;---
INDIRECT:
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),90$ ;SKIP IF SEARCHING FOR A LABEL
	BBSS	#PRC_V_IND,PRC_W_FLAGS(R11),90$ ;SKIP IF INDIRECTION DISABLED
					;AND DISABLE WHILE PROCESSING FILESPEC
	BSBW	DCL$MARK		;MARK CURRENT POSITION
	BSBW	DCL$STACKIND		;STACK CURRENT INDIRECT LEVEL
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECTION AGAIN
	BLBC	R0,DCL$CHARERROR	;BRANCH IF ERROR DETECTED
	BSBW	DCL$INPUT		;GET FIRST LINE, CHARACTER OF PROCEDURE
90$:	RSB

	.SBTTL	ERROR HANDLER IN CHARACTER INPUT ROUTINES
;---
;
; THIS ROUTINE IS CALLED TO PERFORM ANY SPECIAL PROCESSING WHEN AN
; ERROR IS DETECTED BY THE CHARACTER INPUT ROUTINES.
;
; INPUTS:
;
;	R0 = STATUS CODE
;
; OUTPUTS:
;
;	NONE
;---
DCL$CHARERROR::
	BSBW	DCL$ERRORMSG		;REPORT ERROR MESSAGE
	PUSHL	R0			;SAVE STATUS CODE
	BSBW	DCL$FLUSH		;FLUSH INPUT BUFFER
	POPL	R0			;RESTORE STATUS CODE
	BSBW	DCL$SET_STATUS		;SET COMPLETION STATUS
	BRW	DCL$RESTART		;START THE PARSING ALL OVER AGAIN

	.END
