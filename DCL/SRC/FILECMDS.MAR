	.TITLE	FILECMDS - FILE I/O COMMAND EXECUTION
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; FILE I/O DCLS COMMAND EXECUTION
;
;	CLOSE FILE
;	OPEN FILE
;	READ FILE
;	WRITE FILE
;
; D. N. CUTLER 12-FEB-78
;
; MODIFIED BY:
;
;	V011	PCG0001		Peter George	07-Feb-1982
;		Do not open files with undefined record format.
;
;	V010	TMH0010		Tim Halvorsen	31-Dec-1981
;		Add READ/PROMPT=prompt-string
;
;	V009	TMH0009		Tim Halvorsen	28-Dec-1981
;		Remove roundup before ALLDYNMEM - now done inside routine.
;
;	V008	TMH0008		Tim Halvorsen	04-Sep-1981
;		Fix bug in READ of special PPF file (SYS$OUTPUT, etc.)
;		which causes RAB$L_FAB to be corrupted.
;		Add WRITE/UPDATE.
;		Store status into $STATUS when branch is taken to /END
;		or /ERROR.
;		Set $STATUS to RMS$L_STS rather than CLI$_OPENIN on
;		open or create errors.
;
;	V007	TMH0007		Tim Halvorsen	22-Jul-1981
;		Add OPEN/APPEND, READ/[NO]LOCK.
;
;	V006	TMH0006		Tim Halvorsen	13-Jun-1981
;		Add OPEN/SHARE and READ/KEY=key/INDEX=n
;		Change READ command to read record into buffer
;		on stack, to allow handling of larger record sizes.
;		Compute correct ending address of WRITE output buffer.
;
;	V005	TMH0005		Tim Halvorsen	27-Apr-1981
;		Rename PRC_L_CLIWRK0 to PRC_L_PPFLIST.
;
;	V004	TMH0004		Tim Halvorsen	14-Apr-1981
;		Make OPEN_CREATE a global entry point.
;
;	V003	TMH0003		Tim Halvorsen	22-Mar-1981
;		Do not compress quotes from the ppf logical name,
;		since it is now being done automatically by value parsing.
;
;	V002	TMH0001		Tim Halvorsen	15-Feb-1981
;		Remove all references to R10.
;		Use R10 rather than FP as WRK address.
;		Define READ symbols as string type.
;		Use SYM_STRING rather than SEARCH to get string value.
;		Scan all parameter qualifiers on OPEN, in case more
;		than one is specified.  Allow both /READ and /WRITE
;		on OPEN to specify read/write access to a file.
;
;	V001	TMH0001		Tim Halvorsen	02-Sep-1980
;		Use WRK_L_RSLNXT rather than global register R10.
;		Convert to use MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	IDFDEF				;DEFINE INDIRECT FRAME OFFSETS
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	$CLIMSGDEF			;DEFINE ERROR/STATUS CODES
	$FABDEF				;DEFINE FAB OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$NAMDEF				;DEFINE NAME BLOCK OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS LONG WORD VALUES
 
;
; PROCESS PERMANENT FILE PREFIX
;
 
ESCAPE=27
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
;
; DATA INPUT PROMPT
;
DATAP:	.ASCIC	'Data:	'

;
; DEFAULT FILE NAME STRING
;
DFSPEC:	.ASCIC	'.DAT'
;
; KEYWORDS FOR OPEN/SHARE
;
READ:	.ASCII	'READ'
WRITE:	.ASCII	'WRIT'

	.SBTTL	CLOSE FILE
;+
; DCL$CLOSE - CLOSE FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE CLOSE FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED FILE IS CLOSED.
;-
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
DCL$CLOSE::				;CLOSE FILE
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
	BSBW	GETID			;GET FILE IDENTIFICATION
	BLBC	R0,10$			;IF LBC FILE ID NOT FOUND
	BSBW	CHECKPPF		;CHECK FOR PROCESS PERMANENT FILE
	BEQL	10$			;IF EQL YES
	MOVQ	R3,-(SP)		;BUILD LOGICAL NAME DECRIPTOR
	MOVL	SP,R0			;SAVE ADDRESS OF DESCRIPTOR
	$DELLOG_S #LOG$C_PROCESS,(R0),#PSL$C_SUPER ;DELETE LOGICAL NAME
	ADDL	#8,SP			;REMOVE DESCRIPTOR FROM STACK
	MOVL	-(R9),(R7)		;REMOVE FILE DESCRIPTOR FROM LIST
	MOVL	PRC_L_INDFAB(R11),R8	;GET ADDRESS OF INDIRECT FAB
	MOVW	RAB$L_CTX+4(R9),FAB$W_IFI(R8) ;INSERT INTERNAL FILE INDEX
	MOVL	R9,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVZBL	#<RAB$C_BLN+4+7>&^C<7>,R1 ;SET LENGTH OF BLOCK TO DEALLOCATE
	BSBW	DCL$DEADYNMEM		;DEALLOCATE FILE DESCRIPTOR BLOCK
	$CLOSE	FAB=(R8)		;CLOSE FILE
10$:	RSB				;

	.SBTTL	OPEN FILE
;+
; DCL$OPEN - OPEN FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE OPEN FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED FILE IS OPENED AND A FILE DESCRIPTOR IS CONSTRUCTED.
;-
 
DCL$OPEN::				;OPEN FILE
	MOVL	PRC_L_INDFAB(R11),R8	;GET ADDRESS OF INDIRECT FAB
	CLRW	FAB$W_IFI(R8)		;CLEAR INTERNAL FILE INDEX
	CLRW	FAB$W_MRS(R8)		;USED FOR FLAGS TO "OPEN_CREATE"
	CLRL	FAB$L_ALQ(R8)		;CLEAR ALLOCATION QUANTITY
	CLRW	FAB$W_DEQ(R8)		;CLEAR DEFAULT FILE EXTENSION QUANTITY
	CLRB	FAB$B_FAC(R8)		;CLEAR FILE ACCESS TYPE
	CLRB	FAB$B_SHR(R8)		;CLEAR FILE SHARING
	MOVL	#FAB$M_PPF,FAB$L_FOP(R8) ;SET FILE OPEN OPTIONS
	MOVB	DFSPEC,FAB$B_DNS(R8)	;SET SIZE OF DEFAULT NAME STRING
	MOVAB	DFSPEC+1,FAB$L_DNA(R8)	;SET ADDRESS OF DEFAULT NAME STRING
	MOVB	#FAB$C_SEQ,FAB$B_ORG(R8);SET FILE ORGANIZATION ASSUMING CREATE
	MOVB	#FAB$M_PRN,FAB$B_RAT(R8) ;SET RECORD ATTRIBUTE TYPE
	MOVB	#FAB$C_VFC,FAB$B_RFM(R8) ;SET RECORD FORMAT
20$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BEQL	30$			;BRANCH IF DONE WITH SCAN
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	20$			;IF NEQ NO
	CMPB	#CLI$K_OPEN_READ,R1	;READ QUALIFER?
	BEQL	10$			;IF EQL YES
	CMPB	#CLI$K_OPEN_WRIT,R1	;WRITE QUALIFIER?
	BEQL	25$			;BRANCH IF YES
	CMPB	#CLI$K_OPEN_APPE,R1	;APPEND QUALIFIER?
	BEQL	26$			;BRANCH IF YES
	CMPB	#CLI$K_OPEN_SHAR,R1	;SHARE QUALIFIER?
	BEQL	28$			;BRANCH IF YES
	CMPB	#CLI$K_OPEN_ERRO,R1	;SUPRESS ERROR PRINTOUT?
	BNEQ	20$			;IF NEQ NO
	BISW	#2,FAB$W_MRS(R8)	;YES, SET PARAM TO "OPEN_CREATE"
	BRB	20$
10$:	BISB	#FAB$M_GET,FAB$B_FAC(R8) ;MARK /READ EXPLICITLY SPECIFIED
	BICW	#1,FAB$W_MRS(R8)	;USE $OPEN IN "OPEN_CREATE"
	BRB	20$
26$:	BISW	#4,FAB$W_MRS(R8)	;SET EOF ROP BIT ON CONNECT (/APPEND)
	BISB	#FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_FAC(R8) ;MARK WRITABLE
	BRB	20$
25$:	BISB	#FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_FAC(R8) ;MARK /WRITE EXPLICITLY SPECIFIED
	BISW	#1,FAB$W_MRS(R8)	;USE $CREATE IN "OPEN_CREATE"
	BRB	20$			;
28$:	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_SHR(R8) ;ASSUME /SHARE=WRITE
	CMPB	R4,#PTR_K_COLON		;DOES A VALUE FOLLOW /SHARE?
	BNEQ	20$			;IF NOT, GO WITH DEFAULT
	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE OF QUALIFIER
	CMPL	R1,#4			;MORE THAN 4 CHARACTERS?
	BLEQ	29$			;BRANCH IF NOT
	MOVL	#4,R1			;TRUNCATE TO 4 CHARACTER KEYWORD
29$:	MOVQ	R1,R6			;SAVE DESCRIPTOR
	MOVB	#FAB$M_GET,FAB$B_SHR(R8) ;ALLOW OTHERS TO READ FILE
	CMPC3	R6,(R7),READ		;/SHARE=READ?
	BEQL	20$			;BRANCH IF YES
	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_SHR(R8) ;ALLOW OTHERS TO READ/WRITE
	CMPC3	R6,(R7),WRITE		;/SHARE=WRITE?
	BEQL	20$			;BRANCH IF YES
	STATUS	IVKEYW			;INVALID KEYWORD
	RSB

30$:	BBC	#FAB$V_GET,FAB$B_FAC(R8),40$ ;IF /READ EXPLICITLY PRESENT,
	BICW	#1,FAB$W_MRS(R8)	;USE $OPEN EVEN IF /WRITE SPECIFIED TOO
40$:	TSTB	FAB$B_FAC(R8)		;WERE EITHER /READ OR /WRITE SPECIFIED?
	BNEQ	45$			;BRANCH IF AT LEAST ONE WAS
	BISB	#FAB$M_GET,FAB$B_FAC(R8) ;ASSUME /READ IF NOTHING SPECIFIED
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
45$:	BSBW	GETID			;GET FILE ID
	BLBS	R0,60$			;IF LBS FILE ALREADY DEFINED
	MOVQ	R3,R6			;SAVE LOGICAL NAME PARAMETERS
	MOVZBL	#RAB$C_BLN+4,R1		;GET SIZE OF BLOCK REQUIRED
	BSBW	DCL$ALLDYNMEM		;ALLOCATE FILE DESCRIPTOR BLOCK
	BLBC	R0,50$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,R9			;SAVE ADDRESS OF ALLOCATED BLOCK
	BSBW	DCL$GETDVAL		;GET FILE DESCRIPTOR VALUES
	MOVB	R1,FAB$B_FNS(R8)	;SET SIZE OF FILE NAME
	MOVL	R2,FAB$L_FNA(R8)	;SET ADDRESS OF FILE NAME
	MOVZWL	FAB$W_MRS(R8),R2	;GET FLAGS
	CLRW	FAB$W_MRS(R8)		;NO MAXIMUM RECORD SIZE
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	MOVL	R8,R0			;FAB ADDRESS TO OPEN/CREATE
	MOVL	R2,R1			;PASS OPEN/CREATE FLAGS (LOW 2 BITS)
	BSBW	DCL$OPEN_CREATE		;OPEN/CREATE THE FILE
	BLBC	R0,90$			;BRANCH IF ERROR
	MOVL	#CLI$_INVRFM,R0		;ASSUME RECORD FORMAT IS UNDEFINED
	CMPB	#FAB$C_UDF,FAB$B_RFM(R8);RECORD FORMAT UNDEFINED?
	BEQL	80$			;YES, THEN CLOSE FILE AND SET STATUS
	BLBS	R2,70$			;BRANCH IF CREATE
 
;
; OPEN FILE FOR READ ACCESS
;
 
	PUSHL	R2			;SAVE FLAGS
	MOVC	#RAB$C_BLN,@PRC_L_INPRAB(R11),4(R9) ;COPY INPUT RAB
	POPL	R2			;RESTORE FLAGS
	BBC	#2,R2,75$		;/APPEND?
	SETBIT	RAB$V_EOF,RAB$L_ROP+4(R9) ;SET EOF BIT FOR CONNECT
	BRB	75$			;PERFORM THE CONNECT
 
;
; SYMBOL TABLE OVERFLOW
;
 
50$:	STATUS	SYMOVF			;SET SYMBOL TABLE OVERFLOW
60$:	RSB				;
 
;
; OPEN FILE FOR WRITE ACCESS
;
 
70$:	MOVC	#RAB$C_BLN,@PRC_L_OUTRAB(R11),4(R9) ;COPY OUTPUT RAB
75$:	CLRW	RAB$W_ISI+4(R9)		;CLEAR INTERNAL STREAM INDEX
	$CONNECT RAB=4(R9)		;CONNECT RECORD STREAM
	BLBS	R0,100$			;IF LBS SUCCESSFUL CONNECT
 
;
; CONNECT OR LOGICAL NAME CREATION FAILURE
;
 
80$:	PUSHL	R0			;SAVE STATUS
	$CLOSE	FAB=(R8)		;CLOSE FILE
	POPL	R0			;RETREIVE STATUS
 
;
; OPEN FAILURE
;
 
90$:	PUSHL	R0			;SAVE STATUS
	MOVL	R9,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVZBL	#<RAB$C_BLN+4+7>&^C<7>,R1 ;SET SIZE OF BLOCK TO RELEASE
	BSBW	DCL$DEADYNMEM		;DEALLOCATE FILE DESCRIPTOR BLOCK
	POPL	R0			;RESTORE STATUS
	RSB				;
 
;
; SET IMPLIED CARRIAGE CONTROL IN ISI VALUE
;
 
100$:	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,- ;SET IMPLIED CARRIAGE CONTROL
		#RAB$S_PPF_RAT,RAB$W_ISI+4(R9) ;
 
;
; FILE SUCCESSFULLY OPEN - CREATE LOGICAL NAME AND MERGE INTO FILE DESCRIPTOR LIST
;
 
	MOVL	FAB$L_NAM(R8),R1	;GET ADDRESS OF NAME BLOCK
	SUBL	#16,SP			;ALLOCATE SPACE TO STORE DEVICE NAME
	MOVZBL	NAM$T_DVI(R1),R0	;GET LENGTH OF DEVICE NAME
	PUSHL	R0			;SAVE LENGTH OF DEVICE NAME
	MOVC	R0,NAM$T_DVI+1(R1),4(SP) ;COPY DEVICE IDENTIFICATION
	POPL	R0			;RESTORE REGISTER
	PUSHL	#ESCAPE			;BUILD INTERNAL FILE INDEX STRING
	MOVW	FAB$W_IFI(R8),2(SP)	;
	PUSHAB	(SP)			;BUILD EQUIVALENCE NAME DESCRIPTOR
	PUSHAB	4(R0)			;SET LENGTH OF EQUIVALENCE STRING
	MOVL	SP,R0			;SAVE ADDRESS OF EQUIVALENCE DESCRIPTOR
	MOVQ	R6,-(SP)		;BUILD LOGICAL NAME DESCRIPTOR
	MOVL	SP,R1			;SAVE ADDRESS OF LOGICAL NAME DESCRIPTOR
	$CRELOG_S #LOG$C_PROCESS,(R1),(R0),#PSL$C_SUPER ;CREATE LOGICAL NAME
	ADDL	#16+4+8+8,SP		;REMOVE DESCRIPTOR FROM STACK
	BLBC	R0,80$			;IF LBC CREATION FAILURE
	MOVZWL	FAB$W_IFI(R8),RAB$L_CTX+4(R9) ;RAB$L_CTX = FAB$W_IFI
	MOVB	FAB$B_ORG(R8),RAB$L_CTX+2+4(R9) ;RAB$L_CTX+2 = FAB$B_ORG
	MOVL	PRC_L_PPFLIST(R11),(R9)	;INSERT NEW FILE DESCRIPTOR INTO LIST
	MOVL	R9,PRC_L_PPFLIST(R11)	;
	RSB				;

	.SBTTL	READ FILE
;+
; DCL$READ - READ FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE READ FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	A RECORD IS READ FROM THE SPECIFIED FILE AND STORED IN THE SPECIFIED
;	STRING VARIABLE.
;-
 
MAXRECSIZE	= 1024			;MAXIMUM LENGTH OF INPUT RECORD

DCL$READ::				;READ FILE
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
	BSBW	GETID			;GET FILE IDENTIFICATION
	BLBS	R0,5$			;BRANCH IF FILE SPECIFICATION IS OK
	RSB				;EXIT WITH ERROR
5$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR OF SYMBOL NAME
	MOVQ	R1,R3			;SAVE SYMBOL NAME DESCRIPTOR
	BSBW	DCL$CHKALPHA		;CHECK IF FIRST CHARACTER IS LEGAL
	BLBC	R0,20$			;IF LBC NO
10$:	DECL	R1			;ANY MORE CHARACTERS TO CHECK?
	BLEQ	25$			;IF LEQ NO
	INCL	R2			;POINT TO NEXT CHARACTER
	BSBW	DCL$CHKALPHA		;CHECK IF ALPHABETIC, DOLLAR, OR UNDERSCORE
	BLBS	R0,10$			;IF LBS YES
	CMPB	#^A/0/,(R2)		;POSSIBLY NUMERIC?
	BGTRU	20$			;IF GTRU NO
	CMPB	#^A/9/,(R2)		;NUMERIC?
	BGEQU	10$			;IF GEQU YES
20$:	STATUS	IVSYMB			;SET INVALID SYMBOL STATUS
	BRW	DSPXIT			;
;
; OBTAIN VALUES OF /KEY, /INDEX, /PROMPT AND PRESENCE OF /DELETE, /[NO]LOCK
;
25$:	MOVQ	R3,R6			;SAVE DESCRIPTOR OF SYMBOL NAME
	ASSUME	RAB$C_SEQ EQ 0
	CLRB	RAB$B_RAC(R9)		;ASSUME /KEY ABSENT (SEQUENTIAL READ)
	CLRB	RAB$B_PSZ(R9)		;NO PROMPT STRING SPECIFIED YET
	SETBIT	RAB$V_PMT,RAB$L_ROP(R9)	;ASSUME PROMPTING ENABLED, THOUGH
	CLRBIT	RAB$V_NLK,RAB$L_ROP(R9)	;ASSUME /LOCK
	CLRBIT	RAB$V_RRL,RAB$L_ROP(R9)	;ASSUME RECORD LOCK CHECKING ON READ
	CLRL	-(SP)			;ASSUME /DELETE ABSENT (NO DELETION)
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD TOKEN POINTER
30$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BEQL	60$			;BRANCH IF DONE WITH SCAN
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	30$			;IF NEQ NO
	CMPB	#CLI$K_READ_KEY,R1	;/KEY QUALIFIER?
	BEQL	35$			;BRANCH IF YES
	CMPB	#CLI$K_READ_INDE,R1	;/INDEX QUALIFER?
	BEQL	40$			;BRANCH IF YES
	CMPB	#CLI$K_READ_PROM,R1	;/PROMPT QUALIFIER?
	BEQL	42$			;BRANCH IF YES
	CMPB	#CLI$K_READ_LOCK,R1	;/LOCK QUALIFIER?
	BEQL	45$			;BRANCH IF YES
	CMPB	#CLI$K_READ_DELE,R1	;/DELETE QUALIFIER?
	BNEQ	30$			;BRANCH IF NOT
	MOVL	#1,(SP)			;MARK $DELETE TO BE DONE AFTER $GET
	BRB	30$

45$:	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,30$ ;BRANCH IF /LOCK SPECIFIED (DEFAULT)
	SETBIT	RAB$V_NLK,RAB$L_ROP(R9)	;INHIBIT AUTOMATIC LOCKING ON GET
	SETBIT	RAB$V_RRL,RAB$L_ROP(R9)	;INHIBIT RECORD LOCK CHECKING AS WELL
	BRB	30$

35$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /KEY
	MOVB	R1,RAB$B_KSZ(R9)	;ASSUME KEY IS A STRING
	MOVL	R2,RAB$L_KBF(R9)
	MOVB	#RAB$C_KEY,RAB$B_RAC(R9) ;TELL RMS TO READ BY KEY
	BRB	30$

42$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /PROMPT
	MOVL	R2,RAB$L_PBF(R9)	;SET PROMPT ADDRESS
	MOVB	R1,RAB$B_PSZ(R9)	;SET PROMPT SIZE
	BNEQ	30$			;BRANCH IF NON-NULL
	CLRBIT	RAB$V_PMT,RAB$L_ROP(R9)	;MARK NULL PROMPT BY TURNING IT OFF
	BRB	30$

40$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /INDEX
	MOVQ	R1,R4			;SAVE DESCRIPTOR OVER CALL
	MOVQ	R1,R2			;SET DESCRIPTOR OF STRING TO CONVERT
	MOVZBL	#PRC_K_DEC,R1		;SET RADIX FOR CONVERSION
	BSBW	DCL$CNVASCBIN		;CONVERT DECIMAL ASCII TO BINARY
	BNEQ	32$			;IF ERROR, REPORT INVALID VALUE
	MOVB	R1,RAB$B_KRF(R9)	;STORE ISAM INDEX NUMBER
	BRB	30$
32$:	MOVQ	R4,R3			;SET DESCRIPTOR OF ERROR TEXT
	STATUS	IVCHAR			;INVALID CHARACTER
	ADDL	#4,SP			;POP /DELETE FLAG OFF STACK
	BRW	DSPXIT			;REPORT ERROR AND EXIT

;
; READ RECORD
;

60$:	MOVAB	-MAXRECSIZE(SP),SP	;ALLOCATE INPUT BUFFER ON STACK
	MOVL	SP,R8			;GET ADDRESS OF INPUT BUFFER
	MOVW	#MAXRECSIZE,RAB$W_USZ(R9) ;SET SIZE OF RECORD BUFFER
	MOVL	R8,RAB$L_UBF(R9)	;SET ADDRESS OF RECORD BUFFER
	;&&& This is a bug.  RAB$L_CTX is set to FAB$L_DEV for special PPF
	;&&& files like SYS$COMMAND, etc.
	CMPB	RAB$L_CTX+2(R9),#FAB$C_IDX ;ORG = ISAM?
	BEQL	65$			;IF SO, SKIP SETTING OF PROMPT STRING
	TSTB	RAB$B_PSZ(R9)		;PROMPT STRING EXPLICITLY SPECIFIED?
	BNEQ	65$			;IF NOT, SET THE FOLLOWING DEFAULT
	MOVB	DATAP,RAB$B_PSZ(R9)	;SET SIZE OF PROMPT STRING
	MOVAB	DATAP+1,RAB$L_PBF(R9)	;SET ADDRESS OF PROMPT STRING
65$:	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	$GET	RAB=(R9)		;READ NEXT RECORD FROM FILE
	BLBC	R0,80$			;IF LBC I/O ERROR
	MOVZWL	RAB$W_RSZ(R9),R1	;GET SIZE OF RECORD READ
	MOVL	R8,R2			;SET ADDRESS OF RECORD READ
	MOVQ	R6,R3			;SET DESCRIPTOR OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVL	#SYM_K_STRING,R0	;SET TYPE TO STRING
	BSBW	DCL$ALLOCSYM		;ALLOCATE AND INSERT SYMBOL IN TABLE
	BLBC	R0,80$			;IF LBC ALLOCATION FAILURE
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	BLBC	MAXRECSIZE(SP),80$	;BRANCH IF /DELETE NOT SPECIFIED
	$DELETE	RAB=(R9)		;DELETE CURRENT RECORD JUST READ
80$:	MOVAB	MAXRECSIZE+4(SP),SP	;DEALLOCATE INPUT BUFFER
;
; RESTORE RAB TO ORIGINAL STATE - SO THAT IN CASE WE ARE DEALING WITH A
; STANDARD PPF RAB, SUCH AS SYS$INPUT, NORMAL USE OF THE RAB FOR PROCEDURE
; INPUT IS NOT MESSED UP.
;
	SETBIT	RAB$V_PMT,RAB$L_ROP(R9)	;ALWAYS HAVE PROMPTING ENABLED
	CLRBIT	RAB$V_NLK,RAB$L_ROP(R9)	;TURN OFF RECORD LOCKING
	CLRBIT	RAB$V_RRL,RAB$L_ROP(R9)	;   AND RECORD LOCK CHECKING
	RSB				;

	.SBTTL	WRITE FILE
;+
; DCL$WRITE - WRITE FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE WRITE FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LIST OF STRING VARIABLES IS COLLECTED TOGETHER INTO A
;	SINGLE RECORD AND WRITTEN TO THE SPECIFIED FILE.
;-
 
DCL$WRITE::				;WRITE FILE
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
	BSBW	GETID			;GET FILE IDENTIFICATION
	BLBS	R0,5$			;BRANCH IF OK
	RSB				;RETURN WITH ERROR
5$:	MOVAB	WRK_G_RECORD(R10),R7	;GET ADDRESS OF OUTPUT BUFFER
	MOVL	R7,RAB$L_RBF(R9)	;SET ADDRESS OF OUTPUT BUFFER
	MOVAB	WRK_G_BUFFER+WRK_C_CMDBUFSIZ(R10),R8 ;ENDING ADDRESS OF BUFFER
10$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	MOVL	R4,R6			;SAVE TERMINATOR CLASS NUMBER
	MOVZBL	(R2),R5			;SAVE STARTING CHARACTER OF PARAMETER
	BSBW	DCL$COMPSTRING		;COMPRESS STRING
	MOVQ	R1,-(SP)		;SAVE COMPRESSED STRING DESCRIPTOR
	CMPB	#^A/"/,R5		;STRING LITERAL?
	BEQL	20$			;IF EQL YES
	BSBW	DCL$SYM_STRING		;SEARCH FOR SYMBOL DEFINITION
	BLBC	R0,60$			;IF LBC SEARCH FAILURE
20$:	STATUS	BUFOVF			;ASSUME OUTPUT BUFFER WILL OVERFLOW
	MOVQ	(SP)+,R3		;RETRIEVE SAVED STRING DESCRIPTOR
30$:	DECL	R1			;ANY MORE CHARACTERS TO MOVE?
	BLSS	40$			;IF LSS NO
	CMPL	R7,R8			;ANY ROOM IN OUTPUT BUFFER?
	BEQL	DSPXIT			;IF EQL NO
	MOVB	(R2)+,(R7)+		;MOVE CHARACTER TO OUTPUT BUFFER
	BRB	30$			;
40$:	CMPL	#PTR_K_COMMA,R6		;ANY MORE PARAMETERS TO COLLECT?
	BEQL	10$			;IF EQL YES
	SUBL	RAB$L_RBF(R9),R7	;CALCULATE LENGTH OF OUTPUT RECORD
	MOVW	R7,RAB$W_RSZ(R9)	;SET LENGTH OF OUTPUT RECORD
;
; OBTAIN PRESENCE OF /UPDATE QUALIFIER
;
	CLRL	R6			;ASSUME /UPDATE ABSENT (NO $UPDATE)
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD TOKEN POINTER
70$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BEQL	75$			;BRANCH IF DONE WITH SCAN
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	70$			;IF NEQ NO
	CMPB	#CLI$K_WRIT_UPDA,R1	;/UPDATE QUALIFIER?
	BNEQ	70$			;BRANCH IF NOT
	MOVL	#1,R6			;MARK $UPDATE TO BE DONE, NOT $PUT
	BRB	70$
75$:	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	BLBC	R6,78$			;BRANCH IF NOT /UPDATE
;
; UPDATE RECORD
;
	$UPDATE	RAB=(R9)		;UPDATE RECORD
	RSB
;
; OUTPUT RECORD
;
78$:	;&&& This is a bug.  RAB$L_CTX is set to FAB$L_DEV for special PPF
	;&&& files like SYS$COMMAND, etc.
	CMPB	RAB$L_CTX+2(R9),#FAB$C_IDX ;ORG = ISAM?
	BNEQ	45$			;BRANCH IF NOT
	MOVB	#RAB$C_KEY,RAB$B_RAC(R9) ;IF ISAM, ALWAYS INSERT IN KEY ORDER
45$:	$PUT	RAB=(R9)		;OUTPUT RECORD
	RSB				;
 
;
; UNDEFINED SYMBOL
;
 
60$:	MOVQ	(SP)+,R3		;RETREIVE STRING DESCRIPTOR
	STATUS	UNDSYM			;SET UNDEFINED SYMBOL STATUS
 
;
; CALCULATE ADDRESS OF DISPLAY SEGMENT AND CLEAR COMMAND IN EXECUTION
;
 
DSPXIT:	MOVL	R4,WRK_L_MARKPTR(R10)	;SET ADDRESS OF DISPLAY SEGMENT
	ADDL3	R3,R4,WRK_L_EXPANDPTR(R10) ;CALCULATE ENDING ADDRESS OF DISPLAY SEGMENT
	CLRBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;DISPLAY ERROR TEXT WITH MESSAGE
	RSB				;

	.SBTTL	RMSOPEN, RMSCREATE - OPEN/CREATE FILE
;+
; DCL$RMSOPEN   - OPEN INPUT FILE
; DCL$RMSCREATE - CREATE OUTPUT FILE
;
; THESE ROUTINES OPEN AN EXISTING FILE OR CREATE A NEW OUTPUT FILE
; GIVEN A FAB WHICH IS ALREADY SET UP TO CALL THE $OPEN OR $CREATE
; RMS SERVICES DIRECTLY.  IN ADDITION TO PERFORMING THE SPECIFIED
; RMS SERVICE THIS CODE PRODUCES GOOD ERROR MESSAGES.
;
; INPUTS:
;
;	R0  = ADDRESS OF FAB
;
; IMPLICIT INPUTS:
;
;	FAB$L_FNA AND FAB$B_FNS DESCRIBE THE FILE NAME STRING
;	FAB$L_NAM POINTS TO A NAME BLOCK
;	THE NAME BLOCK IN TURN HAS NO RESULT STRING OR EXPANDED STRING
;	ADDRESS SET UP
;
; OUTPUTS:
;
;	R0 = STATUS - IF ERROR, INIHIBIT MSG BIT IS SET
;	R1 ALTERED
;	ALL OTHER REGISTERS PRESERVED
;
;-
DCL$RMSOPEN::
	CLRL	R1			;CODE FOR OPEN FUNCTION
	BRB	DCL$OPEN_CREATE
DCL$RMSCREATE::
	MOVL	#1,R1			;CODE FOR CREATE FUNCTION
;
; DCL$OPEN_CREATE - ALTERNATE ENTRY POINT TO OPEN OR CREATE A FILE
;
; INPUTS:
;
;	R0 = FAB ADDRESS
;	R1 = FLAGS
;	     BIT 0 = 0 FOR OPEN
;		   = 1 FOR CREATE
;	     BIT 1 = 0 FOR NORMAL ERROR REPORTS IF ERROR
;		   = 1 IF NOT SUPPOSED TO ISSUE ERROR REPORT
;
DCL$OPEN_CREATE::
	PUSHR	#^M<R2,R3,R4>		;SAVE SOME REGISTERS
	MOVQ	R0,R2			;R2=FAB ADR
					;R3=OPEN/CREATE, ERR REPORT FLAGS
	MOVL	FAB$L_NAM(R2),R4	;NAME BLOCK ADDRESS
	MOVAL	-<<NAM$C_MAXRSS+3>&^C<3>>(SP),SP ;RESERVE NAME STRING BUFFER
	MOVL	SP,NAM$L_RSA(R4)	;SET RESULT NAME STRING ADDRESS
	MOVL	SP,NAM$L_ESA(R4)	;SET EXPANDED NAME STRING ADDRESS
	ASSUME	NAM$B_RSS+1 EQ NAM$B_RSL
	MOVZBW	#NAM$C_MAXRSS,NAM$B_RSS(R4) ;RESULT STRING BUFFER SIZE
					;ZERO RESULT STRING LENGTH
	ASSUME	NAM$B_ESS+1 EQ NAM$B_ESL
	MOVZBW	#NAM$C_MAXRSS,NAM$B_ESS(R4) ;EXPANDED STRING BUFFER SIZE
					;ZERO EXPANDED STRING LENGTH
	BLBS	R3,20$			;BRANCH IF CREATE FUNCTION
	$OPEN	(R2)			;OPEN THE FILE
	BRB	30$
20$:	$CREATE	(R2)			;CREATE THE FILE
30$:	BLBS	R0,80$			;BRANCH IF SUCCESSFUL
;
; ERROR OPENING OR CREATING THE FILE
;
	PUSHL	SP			;ADDRESS OF RESULT NAME STRING
	MOVZBL	NAM$B_RSL(R4),-(SP)	;RESULT STRING SIZE
	BNEQ	50$			;BRANCH IF THERE WAS A RESULT STRING
	MOVZBL	NAM$B_ESL(R4),(SP)	;EXPANDED NAME STRING SIZE
	BNEQ	50$			;BRANCH IF THERE WAS AN EXPANDED NAME STRING
	MOVL	FAB$L_FNA(R2),4(SP)	;USE ORIGINAL FILE NAME, SET ADR
	MOVZBL	FAB$B_FNS(R2),(SP)	;SIZE OF ORIGINAL NAME
;
; NOW BUILD THE PUTMSG PARAMETER LIST
;
50$:	PUSHL	FAB$L_STV(R2)		;STV FOR THE RMS ERROR CODE
	PUSHL	R0			;RMS ERROR CODE
	PUSHAQ	8(SP)			;ADDRESS OF FILE NAME STRING DESCRIPTOR
	PUSHL	#1			;FAO ARGUMENT COUNT
	MOVW	#<CLI$_NORMAL & STS$M_FAC_NO>@-16,-(SP) ;PUT IN CLI FACILITY CODE
	MOVW	#<<SHR$_OPENIN & ^C<STS$M_SEVERITY>> ! -
		<STS$K_ERROR @ STS$V_SEVERITY>>,-(SP) ;ASSUME FUNCTION IS OPEN
	BLBC	R3,60$			;BRANCH IF IT IS OPEN
	MOVW	#<<SHR$_OPENOUT & ^C<STS$M_SEVERITY>> ! -
		<STS$K_ERROR @ STS$V_SEVERITY>>,(SP) ;IT WAS A CREATE
60$:	PUSHL	#5			;NUMBER OF PARAMETERS TO PUTMSG
	BBS	#1,R3,70$		;BRANCH IF NOT REPORTING ERROR
	MOVL	SP,R0			;ADDRESS OF PUTMSG PARAMETER LIST
	BSBW	DCL$PUTMSG		;DO THE PUTMSG CALL
70$:	BISL3	#STS$M_INHIB_MSG,16(SP),R0 ;RECOVER THE OPEN ERROR CODE (STS)
					;AND SET THE INHIBIT MESSAGE FLAG
	ADDL	#<6*4+8>,SP		;CLEAN OFF THE PUTMSG ARG LIST
					;AND THE FILE NAME DESCRIPTOR
80$:	MOVAL	<<NAM$C_MAXRSS+3>&^C<3>>(SP),SP ;NAME STRING SIZE TO RESERVE
	ASSUME	NAM$B_RSS+1 EQ NAM$B_RSL
	CLRW	NAM$B_RSS(R4)		;CLEAN UP THE NAME BLOCK
	ASSUME	NAM$B_ESS+1 EQ NAM$B_ESL
	CLRW	NAM$B_ESS(R4)		;NAME STRINGS ARE NOT VALID
	POPR	#^M<R2,R3,R4>		;RESTORE SAVED REGISTERS
	RSB

	.SBTTL	LOCAL SUBROUTINES
;+
; CHECKPPF - CHECK FOR PROCESS PERMANENT FILE
;
; THIS ROUTINE IS CALLED TO CHECK IF AN ISI VALUE IS FOR A PROCESS PERMANENT FILE.
;
; INPUTS:
;
;	R6 = ISI VALUE.
;
; OUTPUTS:
;
;	Z = 0 IF NOT PROCESS PERMANENT FILE.
;
;	Z = 1 IF PROCESS PERMANENT FILE WITH:
;
;		R5 = ADDRESS OF ASSOCIATED RAB.
;-
 
CHECKPPF:				;CHECK FOR PROCESS PERMANENT FILE
	MOVL	PRC_L_STACKPT(R11),R1	;GET CURRENT INDIRECT STACK POINTER
	MOVL	PRC_L_INDINPRAB(R11),R5	;GET ADDRESS OF CURRENT INPUT RAB
	CMPW	R6,IDF_W_INPIFI(R1)	;IFI MATCH?
	BEQL	10$			;IF EQL YES
	MOVL	PRC_L_INDOUTRAB(R11),R5	;GET ADDRESS OF CURRENT OUTPUT RAB
	CMPW	R6,IDF_W_OUTIFI(R1)	;IFI MATCH?
	BEQL	10$			;IF EQL YES
	MOVL	PRC_L_ERRRAB(R11),R5	;GET ADDRESS OF CURRENT ERROR RAB
	CMPW	R6,PRC_W_ERRIFI(R11)	;IFI MATCH?
	BEQL	10$			;IF EQL YES
4$:
	TSTL	IDF_L_LNK(R1)		;AT OUTER COMMAND LEVEL?
	BEQL	6$
	MOVL	IDF_L_LNK(R1),R1	;POINT BACK ONE LEVEL
	BRB	4$
6$:
	MOVL	PRC_L_INPRAB(R11),R5	;GET LEVEL-0 (SYS$COMMAND) INPUT RAB
	CMPW	R6,IDF_W_INPIFI(R1)	;IFI MATCH?
10$:	RSB				;

;+
; GETID - GET FILE ID
;
; THIS ROUTINE IS CALLED TO CONVERT THE FILE IDENTIFIER TO BINARY AND SEARCH THE
; FILE DESCRIPTOR LIST FOR A MATCH.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO FIND SPECIFIED FILE ID.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL FILE DESCRIPTOR LIST SEARCH WITH:
;
;		R3 = LENGTH OF LOCIAL FILE NAME.
;		R4 = ADDRESS OF LOGICAL FILE NAME.
;		R5 = ADDRESS OF FILE DESCRIPTOR BLOCK.
;		R6 = FILE IDENTIFICATION NUMBER.
;		R7 = ADDRESS OF PREVIOUS FILE DESCRIPTOR.
;		R9 = ADDRESS OF ASSOCIATED RAB.
;
;	WRK_L_RSLNXT IS SET TO THE NEXT PARAMETER AFTER THE FILE ID.
;-
 
GETID:					;GET FILE ID
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD RESULT DESCRIPTOR POINTER
10$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_PARAMETR,R5	;PARAMETER DESCRIPTOR?
	BNEQ	10$			;IF NEQ NO
	MOVQ	R1,R3			;SAVE LOGICAL FILE PARAMETERS
	MOVQ	R1,-(SP)		;BUILD LOGICAL NAME DESCRIPTOR
	MOVL	SP,R5			;SAVE ADDRESS OF LOGICAL NAME DESCRIPTOR
	MOVZBL	#LOG$C_NAMLENGTH,R6	;GET MAXIMUM LENGTH OF LOGICAL NAME
	SUBL	R6,SP			;ALLOCATE LOGICAL NAME TRANSLATION BUFFER
	PUSHAB	(SP)			;BUILD TRANSLATION BUFFER DESCRIPTOR
	PUSHL	R6			;
	MOVL	SP,R6			;SAVE ADDRESS OF BUFFER DESCRIPTOR
	MOVL	#10,R2			;SET MAXIMUM LOOP COUNT
20$:	$TRNLOG_S (R5),(R5),(R6)	;TRANSLATE LOGICAL NAME
	CMPW	S^#SS$_NORMAL,R0	;NORMAL COMPLETION?
	BNEQ	80$			;IF NEQ NO
	CMPW	#4,(R5)			;TRANSLATED NAME LARGE ENOUGH?
	BGTRU	30$			;IF GTRU NO
	CMPW	#ESCAPE,8(R6)		;PROCESS PERMANENT FILE IFI?
	BEQL	40$			;IF EQL YES
30$:	MOVL	4(R6),4(R5)		;SET FOR NEXT TRANSLATION
	SOBGTR	R2,20$			;ANY MORE TANSLATIONS LEFT?
	BRB	80$			;
40$:	MOVW	10(R6),R6		;GET INTERNAL FILE INDEX
	MOVAB	LOG$C_NAMLENGTH+8+8(SP),SP ;REMOVE LOGICAL NAMES FROM STACK
	BSBW	CHECKPPF		;CHECK IF PROCESS PERMANENT FILE
	BEQL	70$			;IF EQL YES
	MOVAB	PRC_L_PPFLIST(R11),R7	;GET ADDRESS OF PREVIOUS FILE DESCRIPTOR
50$:	MOVL	(R7),R5			;GET ADDRESS OF NEXT FILE DESCRIPTOR
	BEQL	85$			;IF EQL END OF LIST
	CMPW	R6,RAB$L_CTX+4(R5)	;FILE IDENTIFICATION MATCH?
	BEQL	60$			;IF EQL YES
	MOVL	R5,R7			;SAVE ADDRESS OF PREVIOUS ENTRY
	BRB	50$			;
60$:	TSTL	(R5)+			;POINT TO ACTUAL RAB
70$:	MOVL	R5,R9			;SET ADDRESS OF ASSOCIATED RAB
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	BRB	90$			;
 
;
; FILE IDENTIFICATION NOT FOUND
;
 
80$:	MOVAB	LOG$C_NAMLENGTH+8+8(SP),SP ;REMOVE LOGICAL NAMES FROM STACK
85$:	STATUS	UNDFIL			;SET UNDEFINED FILE STATUS
 
;
; CALL THE CALLER BACK AS A CO-ROUTINE SO THAT /END= AND /ERR= QUALIFIERS CAN BE
; PROCESSED IN ONE PLACE.
;
 
90$:	JSB	@(SP)+			;CALL CALLER BACK
	BLBS	R0,110$			;IF LBS SUCCESSFUL COMPLETION
	MOVZBL	#CLI$K_OPEN_END_,R7	;ASSUME END OF FILE
	CMPL	#RMS$_EOF,R0		;END OF FILE?
	BNEQ	100$			;IF NEQ NO
	BSBB	LABEL_CHECK		;CHECK FOR END OF FILE LABEL
100$:	MOVZBL	#CLI$K_OPEN_ERRO,R7	;SET FOR ERROR
	BSBB	LABEL_CHECK		;CHECK FOR ERROR LABEL
110$:	RSB				;

;+
; LABEL_CHECK - CHECK FOR LABEL
;
; THIS ROUTINE IS CALLED TO SCAN THE COMMAND LEVEL QUALIFIERS FOR AN /ERROR=
; OF /END_OF_FILE= QUALIFIER.
;
; INPUTS:
;
;	R7 = TYPE OF QUALIFIER TO SCAN FOR.
;	R8 = SAVED FINAL STATUS VALUE.
;
; OUTPUTS:
;
;	THE RESULT PARSE TABLE IS SCANNED FOR A QUALIFIER TYPE MATCH. IF A MATCH
;	IS FOUND, THEN A GOTO THE SPECIFIED LABEL IS EXECUTED. ELSE A RETURN TO
;	THE CALLER IS EXECUTED.
;-
 
LABEL_CHECK:				;CHECK LABEL
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD RESULT DESCRIPTOR POINTER
	MOVL	R0,R8			;SAVE FINAL STATUS VALUE
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF DESCRIPTORS?
	BEQL	20$			;IF EQL YES
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	10$			;IF NEQ NO
	CMPL	R1,R7			;QUALIFIER TYPE MATCH?
	BNEQ	10$			;IF NEQ NO
	MOVL	R8,R0			;RESTORE ERROR STATUS CODE
	MOVZWL	PRC_W_ONLEVEL(R11),-(SP) ;SAVE CURRENT ON CONDITION
	MOVW	#8,PRC_W_ONLEVEL(R11)	;TEMPORARILY "SET NOON"
	BSBW	DCL$SET_STATUS		;SET INTO $STATUS; ALWAYS RETURN HERE
	CVTLW	(SP)+,PRC_W_ONLEVEL(R11) ;DO A "SET ON"
	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	BRW	DCL$GOTO		;EXECUTE GOTO
20$:	MOVL	R8,R0			;RESTORE FINAL STATUS
	RSB				;
 
	.END
