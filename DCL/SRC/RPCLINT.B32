MODULE rpclint (IDENT='V03-024',
	ADDRESSING_MODE(NONEXTERNAL=LONG_RELATIVE,
			EXTERNAL=GENERAL)) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  Command language interface routines
!
! ABSTRACT:
!
!	These routines are used to enable a newly activated
!	image to obtain the command parameters and qualifiers
!	from the command language interpreter.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Tim Halvorsen, Mar 1980
!
! Modified by:
!
!	V024	PCG0010		Peter George	09-Apr-1982
!		Fix access violation caused by requesting a
!		$VERB from a DCL command.
!
!	V023	PCG0009		Peter George	24-Mar-1982
!		Remove BIND for NO_WRK_AREA.  Add BYTE attribute
!		to bind for LAST_PARAM.
!
!	V022	PCG0008		Peter George	17-Mar-1982
!		Add CLI$_CONCAT alternate success code to
!		DCL$GET_VALUE.  Implement $VERB reserved entity
!		type.  Remove all references to SEEN_BITS.
!
!	V021	PCG0007		Peter George	05-Feb-1982
!		Strip leading dollar sign from $LINE value.
!
!	V020	PCG0006		Peter George	19-Jan-1982
!		Modify DCL$DISPATCH to use .ADDRESS user routine 
!		addresses.
!
!	V019	TMH0019		Tim Halvorsen	30-Dec-1981
!		Remove temporary definitions of CLI$_PRESENT, etc.
!		and obtain their real values from the message symbols.
!		Fix bug in DISPATCH which did one too many indirections
!		to decide what type of routine/image it was.
!
!	V018	PCG0005		Peter George	03-Dec-1981
!		Deallocate user WRK area in DCL$ENDPARSE.
!
!	V017	PCG0004		Peter George	02-Dec-1981
!		Get LIB$:DCLDEF.
!
!	V016	BLS0112		Benn Schreiber	25-Nov-1981
!		Fix accvio in dcl$endparse
!
!	V015	PCG0003		Peter George	05-Nov-1981
!		Replace call to DCL$GETDCLWRK with a CLI callback.
!
!	V014	PCG0002		Peter George	30-Oct-1981
!		Change LIB$:UTILDEF to SHRLIB$:UTILDEF.
!
!	V013	PCG0001		Peter George	30-Oct-1981
!		Move guts of CLINT from CLE into DCL.
!		Format each CLI$... routine as a DCL$... callback.
!		Remove all prompting.  Convert own storage into
!		dynamically allocated data structures.
!		Remove all references to RTL routines.
!		Add DCL$GETLINE utility.  Do not use DCL callback
!		mechanism; reference internal DCL routines directly.
!		Change PSECT addtributes to be compatible with rest
!		DCL code.
!
!	V012	TMH0012		Tim Halvorsen	09-Oct-1981
!		Deallocate and re-initialize prompted value list
!		when re-initializing a new parse.
!
!	V011	TMH0011		Tim Halvorsen	08-Sep-1981
!		Check validity of CLI WRK structure to prevent
!		access violations when using these routines with
!		an mismatched CLI.  This is only done until these
!		routines are moved to the CLI proper to avoid such
!		mismatches.
!
!	V010	TMH0010		Tim Halvorsen	28-May-1981
!		Add missing support for BATCH attribute.
!		Replace STR$UPCASE references with calls to local
!		subroutine instead.
!
!	V009	TMH0009		Tim Halvorsen	01-Apr-1981
!		While searching for the last occurrance of
!		a qualifier, do not match command qualifiers
!		which match the number if the qualifier is
!		parameter only.
!
!	V008	TMH0008		Tim Halvorsen	22-Mar-1981
!		Return the entire value string when requesting
!		a qualifier value of the form keyword=value.
!
!	V007	TMH0007		Tim Halvorsen	18-Feb-1981
!		Allow the interface to be used to obtain the
!		values off the original command line before
!		the first call to the user-mode DCL parsing
!		routines (CLI$DCL_PARSE).
!
!	V006	TMH0006		Tim Halvorsen	15-Jan-1981
!		Fix CLI$GL_WRK reference to use general addressing
!		mode so that it works in large programs.
!
!	V005	TMH0005		Tim Halvorsen	03-Jan-1981
!		Rename CLI$L_WRK to CLI$GL_WRK.
!		Add routine to dispatch to user processing routines.
!
!	V004	TMH0004		Tim Halvorsen	19-Dec-1980
!		Change unknown entity prompting so that it asks if the
!		entity is present, and then asks for its value.
!
!	V003	TMH0003		Tim Halvorsen	07-Dec-1980
!		Remove handling of unknown/static output descriptors as
!		PL/I varying strings since PL/I now correctly inserts the
!		correct descriptor class into its varying descriptors.
!
!	V002	TMH0002		Tim Halvorsen	26-Nov-1980
!		Change all SELECT clauses to CASE to improve speed.
!		Make flags word global so that LIB$DCL_PARSE can
!		re-initialize the flag on each new command line.
!		Attempt to reference weak symbol CLI$GL_WRK which may
!		be defined by LIB$DCL_PARSE as its address of the WRK
!		buffer, in lieu of the CLI WRK area.  If the weak symbol
!		is not satisfied, then use the CLI WRK area as usual.
!
!	V001	TMH0001		Tim Halvorsen	13-Nov-1980
!		Prompt for unrecognized entities so that a utility
!		which has not been defined as a command can be used.
!		Produce 4 distinct values from CLI$PRESENT.

!--

!
! Include files
!

LIBRARY 'SYS$LIBRARY:LIB';		! VMS common definitions
					! (LIB only needed for PCB STS flags)

REQUIRE 'SHRLIB$:UTILDEF';		! Common VMS BLISS definitions

REQUIRE 'LIB$:CLIDEF';			! CLI definitions
REQUIRE 'LIB$:DCLDEF';			! DCL definitions

!
! Table of contents
!

LINKAGE
    find_entity_linkage = call : GLOBAL(block=9,number=10,type=11);

EXTERNAL ROUTINE
    sys$cli;

FORWARD ROUTINE
    initialize : NOVALUE,		! Initialize own storage
    dcl$present,			! Determine if entity present
    dcl$getvalue,			! Get value of entity
    dcl$dispatch,			! Dispatch to user processing routine
    find_entity : find_entity_linkage,	! Find entity in database
    parameter_value,			! Get next parameter value
    qualifier_value,			! Get next qualifier value
    reserved_value,			! Get a reserved entity value
    find_verb :		NOVALUE,	! Find the verb in the command tables
    token_string :	NOVALUE,	! Copy token string to descriptor
    get_terminator,			! Find the value terminator
    batch_job,				! True if batch job or not
    upcase :		NOVALUE,	! Upcase a string in-place
    get_param_token,			! Find next parameter value on line
    last_occurrence,			! Find last occurrence of qualifier
    dcl$getline,			! Get command line
    dcl$endparse;			! Signal any unprocessed modifiers

!
! Change name of the PSECT's to conform to DCL standards.
!
PSECT PLIT = DCL$ZCODE(EXECUTE, ALIGN(0));
PSECT CODE = DCL$ZCODE(EXECUTE, ALIGN(0));

!
! Get values of status messages.
!

EXTERNAL LITERAL
    cli$_concat,			! Value is terminated with a plus
    cli$_present,			! Entity is explicitly present
    cli$_negated,			! Entity is explicitly not present
    cli$_defaulted,			! Entity is implicitly present
    cli$_absent;			! Entity is implicitly not present

!
! Define entity type numbers (for internal classification of entities)
!

LITERAL
    min_entity = 1,			! Minimum entity type number
    param_entity = 1,			! Entity is a parameter
    qual_entity = 2,			! Entity is a qualifier
    reserved_entity = 3,		! Entity is a reserved word
    max_entity = 3;			! Maximum entity type number

$shr_messages(msg,3,			! Prefix MSG$_ with CLI facility
	(syntax,severe));

LITERAL
    msg$_noentity = msg$_syntax;	! Provide temporary definition

!
! Macro to get address of token descriptor given token index
!

MACRO token_desc(index) =
    wrk [wrk_g_result] + (index-1)*ptr_c_length%;

!
! Weak reference to cell containing address of parsing work area
! If not resolved, a run-time call to CLI is made to determine its
! address.  If resolved, that means the cell was defined by the user-mode
! DCL parsing routines.
!

EXTERNAL
    ctl$gl_clintown : REF BBLOCK,	! Address of pointer to own storage
    ctl$gl_dclprsown : REF BBLOCK;	! Address of pointer to wrk area

!
! Table of reserved entity names
!

BIND
    reserved_words = UPLIT BYTE(
	%ASCIC '$LINE',			! Returns entire command line
	%ASCIC '$VERB',			! Returns verb name (as defined)
	0);				! -- End of list


ROUTINE initialize (get_vm) : NOVALUE =

!---
!
!	This routine is called on the first call to this
!	interface package.  It initializes the own storage
!	and sets up for result parsing.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	OWN storage initialized.
!---

BEGIN

BUILTIN
    PROBEW,				! True if location writable
    PROBER;				! True if location readable

LOCAL
    token :	REF BBLOCK,		! Address of token descriptor
    index,				! Token index
    plm :	REF BBLOCK,		! Address of parameter limit block
    req_desc :	BBLOCK [cli$c_reqdesc],	! Callback request descriptor
    rpw :	BBLOCK [cli$c_workarea],! Result parse work area
    req_flags : BITVECTOR [32],		! Callback request flags
    status;


IF NOT (status = (.get_vm) 			! Get memory for own storage
	(%REF(dcl_c_size), ctl$gl_clintown))
   THEN SIGNAL (.status);			! If unsuccessful, then abort

BEGIN
    BIND 
	wrk = ctl$gl_dclprsown : REF BBLOCK,
	prmlim = ctl$gl_clintown [dcl_l_prmlim] : VECTOR,
	last_entity = ctl$gl_clintown [dcl_l_entity],
	last_token = ctl$gl_clintown [dcl_l_token],
	last_param = ctl$gl_clintown [dcl_b_param] : BYTE;

IF .wrk EQL 0					! If wrk pointer is zero
   THEN BEGIN
	CH$FILL (0,cli$c_reqdesc,req_desc);	! Zero request desc block
	req_desc [cli$b_rqtype] = cli$k_initprs;! Set request type
	IF NOT (status = SYS$CLI (req_desc, rpw,! Init result parsing
			req_flags))		! solely to get
	   THEN SIGNAL (.status);		! rpw [rpw_l_dclwrk]
	wrk = .rpw [rpw_l_dclwrk];		! Get address of wrk area
	END;

!
! Verify validity of CLI WRK area pointer, to ensure that we aren't
! trying to deal with a mismatched WRK structure.
!
ctl$gl_clintown [dcl_v_nowrkarea] = true;

token = wrk [wrk_g_result];		! Point to first entry in array
IF NOT PROBER(%REF(psl$c_user),%REF(ptr_c_length),.token) ! If not readable,
    OR .token [ptr_v_type] GTRU ptr_k_endline	! Or invalid type code,
    OR .token [ptr_v_term] GTRU ptr_k_lparen	! Or invalid terminator code,
    OR .token [ptr_v_term] LSSU ptr_k_blank
    OR .wrk [wrk_l_rslnxt] LSSA wrk [wrk_g_result] ! Or invalid RSL pointer,
    OR .wrk [wrk_l_rslnxt] GTRA wrk [wrk_g_result] + wrk_c_rslbufsiz
THEN
    RETURN;				! Return with invalid WRK

token = .wrk [wrk_l_proptr];		! Get address of parameter entities
IF .token NEQ 0
THEN
    IF NOT PROBER(%REF(psl$c_user),%REF(10),.token) ! If invalid pointer,
    THEN
	RETURN;				! Return with invalid WRK

token = .wrk [wrk_l_quablk];		! Get address of qualifier entities
IF .token NEQ 0
THEN
    IF NOT PROBER(%REF(psl$c_user),%REF(10),.token) ! If invalid pointer,
    THEN
	RETURN;				! Return with invalid WRK

ctl$gl_clintown [dcl_v_nowrkarea] = false;	! Mark WRK area is valid

!
! Initialize OWN storage
!

CH$FILL(0,16*plm_c_size,prmlim);	! Zero parameter limit descriptors

index = 0;				! Start at first token descriptor
plm = prmlim;				! Point to first parameter limit

status = get_param_token(index,token);	! Get first parameter token,

WHILE .status				! Until no more parameters
DO
    BEGIN
    plm [plm_b_fstdesc] = .index;	! Save starting token for parameter
    plm [plm_b_nxtdesc] = .index;	! and set next token to process

    WHILE status = get_param_token(index,token) ! Scan for next parameter value
    DO
	BEGIN
	BIND preceeding_token = .token - ptr_c_length: BBLOCK;
	IF .preceeding_token [ptr_v_term] EQL ptr_k_blank ! If start of next parameter
	THEN
	    EXITLOOP;			! then stop for a second
	END;

    plm [plm_b_lstdesc] = .index-1;	! Save ending token for prev. parameter
    plm [plm_b_trmdesc] = .index;	! Save parameter terminator token
    plm = .plm + plm_c_size;		! Skip to next parameter limit
    END;

last_entity = 0;			! Set no previous entity processed
last_param = 0;				! Set no previous parameter
END;					! Outer limit of scope of BIND

RETURN true;
END;

GLOBAL ROUTINE dcl$present (rqdesc, rqwork, rqbits) =

!---
!
!	Determine if an entity is present on the command line.
!
! Inputs:
!
!	name = Address of entity name descriptor
!
! Outputs:
!
!	routine value = True if present, else false.
!---

BEGIN

MAP 
   rqdesc : REF BBLOCK;

GLOBAL REGISTER
    block=9:	REF BBLOCK,		! Address of entity descriptor block
    number=10,				! Parameter/qualifier number
    type=11;				! Entity type

LOCAL
    token:	REF BBLOCK;		! Address of token descriptor

IF .ctl$gl_clintown EQL 0			! If not yet initialized,
   THEN initialize (.rqdesc [cli$a_prsact]);	! then initialize parsing

return_if_error(find_entity(rqdesc [cli$w_rqsize]));	! Find entity

CASE .type FROM min_entity TO max_entity
OF
    SET
    [reserved_entity]:
	RETURN cli$_present;		! Reserved is always present

    [param_entity]:
	BEGIN
	LOCAL plm: REF BBLOCK;
	BIND 
	    prmlim = ctl$gl_clintown [dcl_l_prmlim] : VECTOR,
	    last_param = ctl$gl_clintown [dcl_b_param] : BYTE;
	plm = prmlim [.number-1];	! Find limits of this parameter
	last_param = .number;		! Save last parameter # requested
	IF .plm [plm_b_fstdesc] NEQ 0	! If there,
	THEN
	    RETURN cli$_present		! then indicate present
	ELSE IF .block [ent_w_defval] NEQ 0	! Or has default value,
	THEN
	    RETURN cli$_defaulted	! then indicate defaulted
	ELSE
	    RETURN cli$_absent;		! else indicate not present
	END;

    [qual_entity]:
	BEGIN
	token = last_occurrence(.block, .number); ! Find last occurrence of qualifier

	IF .token EQL 0				! If no occurrence found,
	THEN
	    IF .block [ent_v_deftrue]		! If defaulted,
		OR (.block [ent_v_batdef] AND batch_job())
	    THEN
		RETURN cli$_defaulted		! then indicate defaulted
	    ELSE
		RETURN cli$_absent;		! else indicate not present

	IF NOT .token [ptr_v_negate]		! If not negated,
	THEN
	    RETURN cli$_present			! then indicate present
	ELSE
	    RETURN cli$_negated;		! else indicate explicitly negated
	END;
   TES;

END;

GLOBAL ROUTINE dcl$getvalue (rqdesc, rqwork, rqbits) =

!---
!
!	This routine is called to obtain the next value
!	associated with a named entity on the command line.
!
! Inputs:
!
!	name = Address of entity name descriptor
!	retdesc = Address of a return buffer descriptor
!
! Outputs:
!
!	True = A value was returned (there may be more).
!	False = There is no more values associated with entity.
!
!	All other errors are signaled.
!---

BEGIN

MAP 
   rqdesc : REF BBLOCK;

GLOBAL REGISTER
    block=9:	REF BBLOCK,		! Address of entity descriptor block
    number=10,				! Parameter/qualifier number
    type=11;				! Entity type

IF .ctl$gl_clintown EQL 0			! If not yet initialized,
   THEN initialize (.rqdesc [cli$a_prsact]);	! then initialize parsing

!
! Search for the entity descriptor block, either parameter or qualifier
!

return_if_error(find_entity(rqdesc [cli$w_rqsize]));	! Find entity

!
! If entity is a parameter, then return next value in parameter list
!

CASE .type FROM min_entity TO max_entity	! Based on entity type
OF
    SET
    [param_entity]:	parameter_value(.block, .number, rqdesc [cli$w_rqsize]);
    [qual_entity]:	qualifier_value(.block, .number, rqdesc [cli$w_rqsize]);
    [reserved_entity]:	reserved_value(.number, rqdesc [cli$w_rqsize]);
    TES
    
END;

GLOBAL ROUTINE dcl$dispatch (rqdesc, rqwork, rqbits) =

!---
!
!	This routine can be called to dispatch to any verb processing
!	routines if the command has the ROUTINE attribute.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	The verb routine is called (if any).
!
!	The status passed back from the routine is returned in R0.
!	If no routine is specified, success is returned.
!---

BEGIN

MAP 
   rqdesc : REF BBLOCK;

BUILTIN
    PROBER;				! True if location can be read

LOCAL
    ptr;				! Pointer to offset to user routine

IF .ctl$gl_clintown EQL 0			! If not yet initialized,
   THEN initialize (.rqdesc [cli$a_prsact]);	! then initialize parsing

!
! The value of WRK_L_IMAGE may have the following meanings:
!	1) If number between 0-128, treat as internal CLI routine index
!	2) If its an address in P1 space, it points to an ASCIC image name
!	3) If its an address in P0 space, it points to offset to routine
!
BEGIN

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

ptr = .wrk [wrk_l_image];		! Get pointer to offset longword

IF .ptr <30,2> EQL 0			! If the address is in P0 space,
    AND .ptr GEQU 128			! and not an CLI routine index
THEN
    IF PROBER(%REF(psl$c_user),%REF(4),.ptr) ! If location can be read,
    THEN
	RETURN (.ptr)();		! then call user routine
END;

RETURN true;
END;    

ROUTINE find_entity (name): find_entity_linkage =

!---
!
!	Locate a given entity by entity name string and return
!	the address of the descriptor corresponding to that entity.
!
! Inputs:
!
!	name = Address of entity name descriptor
!
! Outputs:
!
!	block = Address of entity descriptor
!	type = Entity type
!	number = Parameter or qualifier number
!
!	routine value = True if found, else false
!
!	If entity not found, an error is signaled.
!---

BEGIN

MAP
    name:	REF BBLOCK;		! Address of entity name descriptor

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

EXTERNAL REGISTER
    block=9:	REF BBLOCK,		! Address of descriptor block
    number=10,				! Parameter/qualifier number
    type=11;				! Entity type

LOCAL
    label_buffer: VECTOR [32,BYTE],	! Buffer for upcased entity label
    entity_name: VECTOR [2],		! Descriptor for above buffer
    found,
    ptr:	REF BBLOCK;		! Point to scan reserved word table

!
! If we don't have a valid set of tables to search, exit with failure
!

IF .ctl$gl_clintown [dcl_v_nowrkarea]	! If WRK is not valid,
THEN
    RETURN false;

!
! Upcase the entity name string
!

entity_name [0] = .name [dsc$w_length];	! Use the original string length
entity_name [1] = label_buffer;
CH$COPY(.name [dsc$w_length], .name [dsc$a_pointer], 0, 32, label_buffer);
upcase(entity_name);			! Upcase the string

!
! Search parameters for entity first.
!

block = .wrk [wrk_l_proptr];		! Get address of first block
found = false;				! Assume entity not found
number = 1;				! Start at parameter 1

WHILE .block NEQ 0			! Until end of parameter list
DO
    BEGIN
    IF .block [ent_w_label] NEQ 0	! If label specified,
    THEN
	BEGIN
	LOCAL entity_label;
	entity_label = .block + .block [ent_w_label];
	IF CH$EQL(.entity_name [0], .entity_name [1],
		CH$RCHAR_A(entity_label), .entity_label, 0)
	THEN
	    EXITLOOP found = true;	! then exit successful
	END
    ELSE IF .block [ent_w_name] NEQ 0	! Else if name specified,
	AND .block [ent_b_type] NEQ ent_c_parameter ! and not a parameter,
    THEN
	BEGIN
	LOCAL entity_label;
	entity_label = .block + .block [ent_w_name];
	IF CH$EQL(.entity_name [0], .entity_name [1],
		CH$RCHAR_A(entity_label), .entity_label, 0)
	THEN
	    EXITLOOP found = true;	! then exit successful
	END;

    IF .block [ent_b_next] NEQ 0	! If not end of list
    THEN
	block = .block + .block [ent_b_next]	! then skip to next block
    ELSE
	EXITLOOP;			! else terminate loop
    number = .number + 1;		! Increment parameter number
    END;

IF .found				! If entity found
THEN
    BEGIN
    type = param_entity;		! indicate parameter entity
    RETURN true;
    END;

!
! Search the qualifier list.
!

block = .wrk [wrk_l_quablk];		! Get address of first block
number = 1;				! Start at parameter 1

WHILE .block NEQ 0			! Until end of qualifier list
DO
    BEGIN
    LOCAL entity_label;
    entity_label = .block + .block [ent_w_label]; ! Assume label there
    IF .block [ent_w_label] EQL 0	! If label not specified,
    THEN
	entity_label = .block + .block [ent_w_name]; ! then use qualifier name
    IF CH$EQL(.entity_name [0], .entity_name [1],
	CH$RCHAR_A(entity_label), .entity_label, 0)
    THEN
	EXITLOOP found = true;		! then exit successful
    IF .block [ent_b_next] NEQ 0	! If not end of list
    THEN
	block = .block + .block [ent_b_next]	! then skip to next block
    ELSE
	EXITLOOP;			! else terminate loop
    number = .number + 1;
    END;

IF .found				! If entity found
THEN
    BEGIN
    type = qual_entity;			! indicate qualifier entity
    RETURN true;
    END;

!
! Search the list of reserved entity names
!

number = 1;				! Start at first reserved word
ptr = reserved_words;			! Point to beginning of table

WHILE CH$RCHAR(.ptr) NEQ 0		! Until end of table
DO
    BEGIN
    IF CH$EQL(.entity_name [0], .entity_name [1], CH$RCHAR(.ptr), .ptr+1, 0)
    THEN
	EXITLOOP;			! then exit the loop
    ptr = CH$RCHAR_A(ptr) + .ptr;	! Skip to next reserved word
    number = .number + 1;		! Increment reserved word number
    END;

IF CH$RCHAR(.ptr) NEQ 0			! If found,
THEN
    BEGIN
    type = reserved_entity;		! and indicate entity type
    RETURN true;
    END;

SIGNAL(msg$_noentity,1,.name);		! Signal the error

RETURN false;				! Return unsuccessful

END;

ROUTINE parameter_value (entity, number, retdesc) =

!---
!
!	This routine returns the next value in the list for
!	a given parameter.
!
! Inputs:
!
!	entity = Address of parameter descriptor block
!	number = Parameter number
!	retdesc = Address of return descriptor to receive value
!
! Outputs:
!
!	retdesc = Next value string in list
!
!	routine value = True if value returned, else false.
!---

BEGIN

MAP
    entity : REF BBLOCK,		! Address of entity descriptor block
    retdesc : REF BBLOCK;		! Address of return descriptor

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK,
    prmlim = ctl$gl_clintown [dcl_l_prmlim] : VECTOR,
    last_entity = ctl$gl_clintown [dcl_l_entity],
    last_param = ctl$gl_clintown [dcl_b_param] : BYTE;

LOCAL
    found,				! True if value returned
    string:	VECTOR [2],		! String descriptor
    token:	REF BBLOCK,		! Address of next token descriptor
    plm:	REF BBLOCK;		! Address of parameter limit

found = false;				! Mark value not yet found
string [0] = 0;				! Present to null string

plm = prmlim [.number-1];		! Find limits for the parameter

last_param = .number;			! Save last parameter # requested
last_entity = .entity;			! Remember last entity processed

!
! If parameter has a default value and the parameter was not
! supplied, then return the default value.
!

IF .plm [plm_b_fstdesc] EQL 0		! If parameter not given
    AND .entity [ent_w_defval] NEQ 0	! and parameter has a default value,
THEN
    BEGIN
    LOCAL defval: REF VECTOR [,BYTE];
    defval = .entity + .entity [ent_w_defval];
    string [0] = CH$RCHAR_A(defval);	! Set default value into descriptor
    string [1] = .defval;
    plm [plm_b_fstdesc] = 1;		! Force next call to return nothing
    found = true;			! Mark value found
    END

!
! If there are parameter values still left to be returned, then find
! the next value (ignoring embedded parameter qualifiers) and return it.
!

ELSE
    WHILE .plm [plm_b_nxtdesc] NEQ 0	! While range not yet exhausted,
	AND .plm [plm_b_nxtdesc] LEQU .plm [plm_b_lstdesc]
    DO
	BEGIN
	token = token_desc(.plm [plm_b_nxtdesc]); ! Get token descriptor
	IF .token [ptr_v_type] EQL ptr_k_parametr	! If parameter,
	THEN
	    BEGIN
	    token_string(.token, string);	! Return next parameter value
	    plm [plm_b_nxtdesc] = .plm [plm_b_nxtdesc] + 1; ! Skip to next token
	    found = get_terminator (.token, ptr_k_parametr);! Set return status by terminator
	    EXITLOOP;			! and quit looping for now
	    END
	ELSE
	    plm [plm_b_nxtdesc] = .plm [plm_b_nxtdesc] + 1; ! Else, skip to next
	END;

retdesc [dsc$w_length] = .string [0];	! Return value string
retdesc [dsc$a_pointer] = .string [1];

RETURN .found;				! Indicate if value returned
END;

ROUTINE qualifier_value (entity, number, retdesc) =

!---
!
!	Return the next value in a qualifier value list.
!
! Inputs:
!
!	entity = Address of qualifier descriptor block
!	number = Qualifier number
!	retdesc = Address of return descriptor to receive value
!
! Outputs:
!
!	retdesc = Next value in list
!
!	routine value = True if value returned, else false.
!---

BEGIN

MAP
    entity : REF BBLOCK,		! Address of entity descriptor block
    retdesc : REF BBLOCK;		! Address of return descriptor

BIND 
    last_entity = ctl$gl_clintown [dcl_l_entity],
    last_token = ctl$gl_clintown [dcl_l_token];

LOCAL
    found,				! True if value found
    string:	VECTOR [2],		! Descriptor of value string
    token:	REF BBLOCK,		! Address of token descriptor
    last:	REF BBLOCK;		! Last occurrence of given qualifier

string [0] = 0;				! Preset to null string
found = false;				! Preset to no value found

!
! If we are still doing the same entity as last time, set our
! position to where we left off last time.
!

IF .last_entity EQL .entity		! If this is not the first time thru
THEN					! for this entity
    token = .last_token			! then set to where we left off

!
! Find the last occurrence of the qualifier on the command line
!

ELSE
    BEGIN
    last = last_occurrence(.entity, .number);	! Find last occur. of qualifier

    !
    ! If any occurrence found at all (and not negated), then set current
    ! position to first value in list.  If negated, return false.
    ! If occurrence has no value, supply default value (if any).
    !

    token = 0;				! Assume no value found at all
    IF .last NEQ 0			! If any occurrence found,
    THEN
	BEGIN
	IF NOT .last [ptr_v_negate]	! and last occur. not negated,
	THEN
	    BEGIN
	    last = .last+ptr_c_length;	! Next token after qualifier
	    IF .last [ptr_v_type] EQL ptr_k_qualvalu ! If qualifier has any value,
	    THEN
		token = .last		! then set to first value in list
	    ELSE
		IF .entity [ent_w_defval] NEQ 0 ! If default value on qualifier,
		THEN
		    BEGIN
		    LOCAL defval: REF VECTOR [,BYTE];
		    defval = .entity + .entity [ent_w_defval];
		    string [0] = CH$RCHAR_A(defval); ! Set default value into descriptor
		    string [1] = .defval;
		    found = true;
		    END;
	    END;
	END

    !
    ! If no occurrence found at all and defaulted present, give default value.
    !

    ELSE
	IF (.entity [ent_v_deftrue]	! If defaulted present
		OR (.entity [ent_v_batdef] AND batch_job()))
	    AND .entity [ent_w_defval] NEQ 0 ! and default value on qualifier,
	THEN
	    BEGIN
	    LOCAL defval: REF VECTOR [,BYTE];
	    defval = .entity + .entity [ent_w_defval];
	    string [0] = CH$RCHAR_A(defval); ! Set default value into descriptor
	    string [1] = .defval;
	    found = true;
	    END;
    END;

!
! If qualifier value is present on the line, then return the next value
! and save our position for the next iteration.  We must scan all value
! tokens until the terminator is not a colon, so that a value of the form
! 'keyword=value' is returned in its entireity.
!

IF .token NEQ 0				! If token pointer valid,
    AND .token [ptr_v_type] EQL ptr_k_qualvalu	! and next token is a value,
THEN
    BEGIN
    LOCAL offset_to_first,offset_to_last,
	previous_token:	REF BBLOCK;
    offset_to_first = .token [ptr_v_offset]; ! Save offset to first character
    DO
	BEGIN
	offset_to_last = .token [ptr_v_offset];
	token_string(.token,string);	! Get descriptor of token
	found = get_terminator (.token, ptr_k_qualvalu);! Set return status by terminator
	previous_token = .token;	! Remember address of previous token
	token = .token + ptr_c_length;	! Skip to next token
	END
    UNTIL .token [ptr_v_type] NEQ ptr_k_qualvalu ! loop thru all tokens
	OR .previous_token [ptr_v_term] NEQ ptr_k_colon; ! until we hit next value
    string [0] = .string [0] + (.offset_to_last - .offset_to_first);
    string [1] = .string [1] - (.offset_to_last - .offset_to_first);
    END;

last_entity = .entity;			! Remember which one we just did
last_token = .token;			! and where we left off in value list

retdesc [dsc$w_length] = .string [0];	! Return value string
retdesc [dsc$a_pointer] = .string [1];

RETURN .found;				! and indicate if value returned
END;

ROUTINE reserved_value (number, retdesc) =

!---
!
!	Return the value associated with a reserved entity name.
!
! Inputs:
!
!	number = Reserved word number
!	retdesc = Address of return buffer descriptor
!
! Outputs:
!
!	retdesc = Value string.
!
!	routine value = True if value returned, else false.
!---

BEGIN

MAP
    retdesc : REF BBLOCK;		! Address of return descriptor

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

LOCAL
    string:	VECTOR [2];		! String descriptor

CASE .number FROM 1 TO 2		! Based on reserved word number
OF
    SET
    [1]:				! $LINE reserved word
	BEGIN
	LOCAL token: REF BBLOCK;
	token = wrk [wrk_g_result];	! Start at first token descriptor

	WHILE .token [ptr_v_type] NEQ ptr_k_endline	! Until end of command line
	DO
	    token = .token + ptr_c_length;	! then skip to next one

	string [0] = .token [ptr_v_offset];	! Line length is offset to eol
	string [1] = wrk [wrk_g_buffer];	! and set address of input buffer
	
	IF CH$RCHAR (.string [1]) EQL %C'$'	! If line is preceeded with "$"
	   THEN BEGIN				! then strip it off
		string [0] = .string [0] - 1;
		string [1] = .string [1] + 1;
		END;

	END;

    [2]:					! $VERB reserved word
	BEGIN
	LOCAL token: REF BBLOCK,
	      verb:  VECTOR [2];
	token = wrk [wrk_g_result];		! Start at first token descriptor
	verb [0] = .token [ptr_v_offset];	! Verb length is offset first token
	verb [1] = wrk [wrk_g_buffer];		! and set address of input buffer
	IF .token [ptr_v_type] NEQ ptr_k_endline ! End of command line?
	   THEN verb [0] = .verb [0] - 1;	! No, then backup a character

	IF CH$RCHAR (.verb [1]) EQL %C'$'	! If verb is preceeded with "$"
	   THEN BEGIN				! then strip it off
		verb [0] = .verb [0] - 1;
		verb [1] = .verb [1] + 1;
		END;

	IF .verb [0] GTRU 4			! If length is greater than four
	   THEN verb [0] = 4;			! Then shorten it
	ctl$gl_clintown [dcl_l_verb] = ..verb[1]; ! Get verb from command string
	verb [1] = ctl$gl_clintown [dcl_l_verb];  ! Get address of own storage

	find_verb (verb, string);		! Get verb from tables
	END;

    TES;

retdesc [dsc$w_length] = .string [0];		! Return value string
retdesc [dsc$a_pointer] = .string [1];

RETURN true;
END;

ROUTINE find_verb (input, output): NOVALUE =

!---
!
!	Find the specified verb string in the command tables.
!
! Inputs:
!
!	input  =  Address of descriptor of verb to look up
!	output =  Address of descriptor to supply with found verb
!
! Outputs:
!
!	output =  As described above
!---

BEGIN

MAP
    input:	REF VECTOR,
    output:	REF VECTOR;

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

LOCAL
    verb_ptr,			! Address in tables at which verb was found
    table : REF BBLOCK;		! Address of tables

.input [1] = ..input [1] OR %X'00000080';	! Set bit in first char to ensure match
table = .wrk [wrk_l_tab_vec];		! Get address of tables

!
! Find the verb in the verb table.
!
verb_ptr = CH$FIND_SUB (.table [vec_l_verbend] - .table [vec_l_verbtbl],
			.table [vec_l_verbtbl] + .table,
			.input [0], .input [1]);

!
! Pass the verb name back in the same own storage that we got the command
! string verb in.
!
output [0] = 4;
output [1] = ctl$gl_clintown [dcl_l_verb];
CH$MOVE (4, .verb_ptr, .output [1]);
.output [1] = ..output [1] AND %X'FFFFFF7F';

END;

ROUTINE token_string (token, retdesc): NOVALUE =

!---
!
!	Create a string descriptor of a token string
!
! Inputs:
!
!	token = Address of token descriptor
!	retdesc = Address of quadword to receive string descriptor
!
! Outputs:
!
!	retdesc = Descriptor of token string
!---

BEGIN

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK;

MAP
    token:	REF BBLOCK,		! Address of token descriptor
    retdesc:	REF VECTOR [2];		! Address of quadword

retdesc [0] = .token [ptr_v_value];	! Setup descriptor of string
retdesc [1] = wrk [wrk_g_buffer] + .token [ptr_v_offset];

END;

ROUTINE get_terminator (token, type) =

!---
!
!	Return status according to the type of the value terminator.
!	Skip to next entity of the specified type (or EOL if it comes first)
!	and return true or cli$_concat, depending on the terminator type of 
!	the previous entity.
!
! Inputs:
!
!	token = Address of token descriptor
!	type  = Type of token being terminated
!			ptr_k_parametr => parameter
!			ptr_k_qualvalu => qualifier value
!
! Outputs:
!
!	status indicates type of terminator
!---

BEGIN

MAP
    token:	REF BBLOCK;		! Address of token descriptor

LOCAL 
    last_token: REF BBLOCK,		! Address of last token examined
    next_token: REF BBLOCK;		! Address of next token on command line

last_token = .token;
next_token = .token + ptr_k_length;
WHILE (.next_token [ptr_v_type] NEQ ptr_k_endline) AND
      (.next_token [ptr_v_type] NEQ .type)
DO BEGIN 
   last_token = .next_token;
   next_token = .next_token + ptr_k_length;
   END;   

IF .last_token [ptr_v_term] EQL ptr_k_plus
   THEN RETURN cli$_concat
   ELSE RETURN true;

END;

ROUTINE batch_job =

!---
!
!	This routine returns a boolean value indicating whether
!	the current process is a batch job or not.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	Routine value is true if a batch job, else false
!---

BEGIN

LOCAL
    pcb_sts:	BBLOCK [4],		! PCB status flags
    item_list:	BBLOCK [16];		! GETJPI item list

!
! Get job status flags to determine type of job
!

item_list [0,0,16,0] = 4;		! Buffer length
item_list [2,0,16,0] = jpi$_sts;	! JPI code
item_list [4,0,32,0] = pcb_sts;		! Buffer address
item_list [8,0,32,0] = 0;		! Address to return item length
item_list [12,0,32,0] = 0;		! End of item list

return_if_error($GETJPI(ITMLST = item_list));	! Obtain PCB flags

RETURN .pcb_sts <$BITPOSITION(pcb$v_batch),1>;	! True if batch job

END;

ROUTINE upcase (desc): NOVALUE =

!---
!
!	Upcase a string in-place
!
! Inputs:
!
!	desc = Address of string descriptor
!
! Outputs:
!
!	The string is upcased.
!---

BEGIN

MAP
    desc: REF BBLOCK;

REGISTER
    ptr: REF VECTOR [,BYTE],
    char: BYTE;				! Character to test

ptr = .desc [dsc$a_pointer];		! Starting address of string
DECR count FROM .desc [dsc$w_length]-1	! Upcase the characters
DO
    BEGIN
    char = CH$RCHAR_A(ptr);		! Get next character
    IF .char GEQU 'a'			! Lower case letter?
	 AND .char LEQU 'z'
    THEN
	ptr [-1] = .char - ('a' - 'A');	! Convert to upper
    END;

END;

ROUTINE get_param_token (index, rettoken) =

!---
!
!	Get the next token in the command line which is a parameter value.
!
! Inputs:
!
!	index = Address of longword containing previous token index.
!	rettoken = Address of longword to receive token descriptor address
!
! Outputs:
!
!	index = Address of longword containing token index of parameter.
!	rettoken = Address of longword containing token descriptor address.
!
!	routine value = True if parameter value found, false if eol detected.
!---

BEGIN

BIND
    wrk = ctl$gl_dclprsown : REF BBLOCK;

LOCAL
    token:	REF BBLOCK;		! Address of token descriptor

token = token_desc(..index);		! Get starting token descriptor address

WHILE .token [ptr_v_type] NEQ ptr_k_endline	! Until end of line reached
DO
    BEGIN
    token = .token + ptr_c_length;	! skip to next token
    .index = ..index + 1;		! Increment token index
    IF .token [ptr_v_type] EQL ptr_k_parametr	! If parameter found
    THEN
	BEGIN
	.rettoken = .token;		! then return token
	RETURN true;			! and indicate found
	END;
    END;

RETURN false;				! Indicate no parameter found

END;

ROUTINE last_occurrence (entity, number) =

!---
!
!	Locate the last occurrence of a qualifier on the command
!	line and return the token descriptor.  
!
! Inputs:
!
!	entity = Address of entity descriptor block
!	number = Qualifier number to search for
!
! Outputs:
!
!	routine value = Address of token descriptor if found, else 0
!---

BEGIN

MAP
    entity:	REF BBLOCK;		! Address of entity descriptor

BIND 
    wrk = ctl$gl_dclprsown : REF BBLOCK,
    prmlim = ctl$gl_clintown [dcl_l_prmlim] : VECTOR,
    last_param = ctl$gl_clintown [dcl_b_param] : BYTE;

LOCAL
    last:	REF BBLOCK,		! Address of token for last occurrence
    token:	REF BBLOCK,		! Address of current token
    index;				! Index of current token

!
! If the qualifier has local or positional placement, then search for
! a parmqual starting at the last parameter value returned until the
! next parameter value.
!

IF .entity [ent_v_parm]			! If local or position placement,
    AND .last_param NEQ 0		! and we have recently requested a parm
THEN
    BEGIN
    LOCAL
	plm: REF BBLOCK;		! Address of parameter limit descriptor
    plm = prmlim [.last_param-1];	! Limits of last parameter requested
    index = .plm [plm_b_nxtdesc];	! Start following last value returned
    WHILE .index NEQ 0			! While range not yet exhausted,
	AND .index LEQU .plm [plm_b_lstdesc]
    DO
	BEGIN
	token = token_desc(.index);	! Get token descriptor
	IF .token [ptr_v_type] EQL ptr_k_parametr ! If a parameter value,
	THEN
	    EXITLOOP;			! then stop the parameter search
	IF .token [ptr_v_type] EQL ptr_k_parmqual ! If parameter qualifier,
	    AND .token [ptr_v_value] EQL .number  ! and its ours,
	THEN 
	    RETURN .token		! Return descriptor of parmqual
	ELSE
	    index = .index + 1;		! Else, skip to next one
	END;
    END;

!
! If the qualifier is local only, return false as it was not found
! on any parameter in the loop above.
!

IF .entity [ent_v_parm]			! If allowed on parameters,
    AND NOT .entity [ent_v_verb]	! and not on verbs,
THEN
    RETURN 0;
					! then return not found

!
! Now search for the last occurrence as a command qualifier.
!

last = 0;				! Indicate no occurrences found
index = 1;
token = token_desc(1);			! Start at first token descriptor

WHILE .token [ptr_v_type] NEQ ptr_k_endline	! Until end of command line
DO
    BEGIN
    IF .token [ptr_v_type] EQL ptr_k_comdqual	! If token is a qualifier
	AND .token [ptr_v_value] EQL .number	! and its our qualifier
    THEN
	last = .token;			! Save last occurrence of qualifier
    token = .token + ptr_c_length;	! Skip to next token
    index = .index + 1;			! and increment token index
    END;

RETURN .last;				! Return address of token descriptor

END;

GLOBAL ROUTINE dcl$getline (rqdesc, rqwork, rqbits) =

!---
!
!	This routine is called to obtain the complete command line,
!	including the verb.
!
! Outputs:
!
!	The command line is returned via the quadword descriptor 
!	contained within the request descriptor block.
!
!	Routine always returns true status.
!---

BEGIN

MAP
    rqdesc : REF BBLOCK;

LOCAL 
    req_desc :	BBLOCK [cli$c_reqdesc],		! Callback request descriptor
    rpw :	BBLOCK [cli$c_workarea],	! Result parse work area
    req_flags : BITVECTOR [32],			! Callback request flags
    token  :	REF BBLOCK,
    wrk :	REF BBLOCK;

CH$FILL (0,cli$c_reqdesc,req_desc);		! Zero request desc block
req_desc [cli$b_rqtype] = cli$k_initprs;	! Set request type
SYS$CLI (req_desc, rpw,req_flags);		! Init result parsing solely 
						! to get rpw [rpw_l_dclwrk]
wrk = .rpw [rpw_l_dclwrk];			! Get address of wrk area
token = wrk [wrk_g_result];			! Start at first token descriptor

WHILE .token [ptr_v_type] NEQ ptr_k_endline	! Until end of command line
DO token = .token + ptr_c_length;		! then skip to next one

rqdesc [cli$w_rqsize] = .token [ptr_v_offset];	! Line length is offset to eol
rqdesc [cli$a_rqaddr] = wrk [wrk_g_buffer];	! and set address of input buffer

IF CH$RCHAR (.rqdesc [cli$a_rqaddr]) EQL %C'$'	! If line is preceeded with "$"
   THEN BEGIN					! then strip it off
	rqdesc [cli$w_rqsize] = .rqdesc [cli$w_rqsize] - 1;
	rqdesc [cli$a_rqaddr] = .rqdesc [cli$a_rqaddr] + 1;
	END;

RETURN true;    
END;

GLOBAL ROUTINE dcl$endparse (rqdesc, rqwork, rqbits) =

!---
!
!	This routine is called when the user has completed
!	all command line parsing.  It checks that all qualifiers
!	which appeared on the command line were processed in one
!	way or another by the utility.
!
! Inputs:
!
!	The address of the RTL lib$free_vm routine is contained
!	in cli$a_rqaddr.
!
! Outputs:
!
!	None
!---

BEGIN

BUILTIN
    PROBEW;				! True if location writable

MAP 
   rqdesc : REF BBLOCK;

!
! If clint own storage is allocated, then deallocate it.
!
IF .ctl$gl_clintown NEQ 0
   THEN (.rqdesc [cli$a_absact])
	  (%REF(dcl_c_size), .ctl$gl_clintown);
ctl$gl_clintown = 0;		

!
! If user mode  WRK area, then deallocate it.
! Zero pointer no matter what mode WRK area is.
!
IF .ctl$gl_dclprsown NEQ 0
   THEN IF PROBEW(%REF(psl$c_user),%REF(-wrk_k_length),.ctl$gl_dclprsown) 
	   THEN (.rqdesc [cli$a_absact])
		  (%REF(-wrk_k_length), .ctl$gl_dclprsown);
ctl$gl_dclprsown = 0;

RETURN true;
END;

END
ELUDOM
