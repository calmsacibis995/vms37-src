	.TITLE	EXPRESS - EXPRESSION ANALYSIS
	.IDENT	'V03-009'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; EXPRESSION ANALYSIS
;
; D. N. CUTLER 9-MAY-77
;
; MODIFIED BY:
;
;	V009	PCG0004		Peter George	05-Apr-1982
;		Try to anticipate stack overflow when doing
;		string concatenation.
;
;	V008	PCG0003		Peter George	04-Mar-1982
;		Do not overwrite right hand string buffer in 
;		<num> <str-rel> <num> case.
;
;	V007	PCG0002		Peter George	22-Feb-1982
;		Do not convert integers to strings via their logical
;		values.  Do not optimize unary operators.  
;
;	V006	PCG0001		Peter George	28-Jan-1982
;		Allow lower case t and y to indicate logical true.
;		Make everything else, i.e., except TtYy, indicate
;		logical false.
;		
;	V005	TMH0005		Tim Halvorsen	20-Mar-1981
;		Clear R2 in CVT_BINARY to indicate to caller that
;		the resultant expression is binary.
;
;	V004	TMH0004		Tim Halvorsen	11-Feb-1981
;		Use DCL$MARK rather than R6 as display parameter.
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Remove all references to R10.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$BACKUPMOVE routine.
;		Fix bug which causes the symbol table to be
;		overwritten whenever a string->numeric conversion
;		fails while parsing a lexical function argument
;		during a GOTO scan.
;		Add typed expressions.  Return the result value in
;		registers r1/r2.
;		On successful completion, leave MARKPTR set to beginning
;		of expression so that semantic errors detected later by
;		the caller will show the entire expression as being in error.
;		Add "+" string concatenation operator and "-" string
;		reduction operator.
;		Use DCL$COMPRESS so that errors show strings correctly.
;
;	V003	TMH0003		Tim Halvorsen	06-Feb-1981
;		Reset display parameter (R6) on successful exit in case
;		of errors by a caller.
;
;	V002	TMH0002		Tim Halvorsen	13-Jan-1981
;		Allow string expressions and return type of expression
;		to caller (string or numeric).  Allow lexical functions
;		in expressions.  Make expression analysis recursive.
;		Accept "," and ")" as expression terminators in order to
;		allow expressions within lexical function arguments.
;
;	V001	TMH0001		Tim Halvorsen	09-Sep-1980
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	$CLIMSGDEF			;DEFINE ERROR/STATUS CODES
 
;
; LOCAL MACROS
;
; GENERATE OPERATOR/OPERAND TABLE AND SYMBOL NAMES
;
 
	.MACRO	GENOP NAME,INDEX,TYPE,PREC,CHAR,?L1,?L2,?L3,?L4
OPI_K_'NAME=INDEX
	.IF IDN	<TYPE>,<OPERATOR>
OPP_K_'NAME=PREC
	.IF DIF	<NAME>,<SOS>
	.IF DIF	<NAME>,<EOS>
	.IF DIF	<NAME>,<STORE>
L1:	.BYTE	L4-L1
	.BYTE	L3-L2
	.IF NB	<CHAR>
L2:	.ASCII	\CHAR\
	.IFF
L2:	.ASCII	/NAME/
	.ENDC
L3:	.BYTE	OPP_K_'NAME
L4:	.BYTE	OPI_K_'NAME
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDM	GENOP
 
;
; LOCAL SYMBOLS
;
; DEFINE STACK ITEM OFFSETS
;
 
	$DEFINI	STK
 
$DEF	STK_W_TYPE	.BLKW	1	;STACK ITEM TYPE
$DEF	STK_W_PREC			;OPERATOR PRECEDENCE
$DEF	STK_W_SIZE	.BLKW	1	;SIZE OF OPERAND VALUE IN BYTES
$DEF	STK_L_ADDR	.BLKL	1	;ADDRESS OF OPERAND VALUE
$DEF	STK_K_LENGTH			;LENGTH OF STACK ITEM
 
	$DEFEND	STK
 
;
; LOCAL DATA
;
; OPERATOR TABLE
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

OPTAB:	GENOP	SOS,30,OPERATOR,0	;START OF STATEMENT
	GENOP	EOS,32,OPERATOR,1	;END OF STATEMENT
	GENOP	LPAREN,34,OPERATOR,2,<(> ;LEFT PARENTHESIS
	GENOP	RPAREN,36,OPERATOR,3,<)> ;RIGHT PARENTHESIS
	GENOP	STORE,38,OPERATOR,0	;STORE RESULT
	GENOP	AND,0,OPERATOR,5	;BOOLEAN AND
	GENOP	NOT,2,OPERATOR,6	;BOOLEAN NOT
	GENOP	OR,4,OPERATOR,4		;BOOLEAN OR
	GENOP	ADD,6,OPERATOR,8,<+>	;INTEGER ADD
	GENOP	SUB,8,OPERATOR,8,<->	;INTEGER SUBTRACT
	GENOP	MUL,10,OPERATOR,9,<*>	;INTEGER MULTIPLY
	GENOP	DIV,12,OPERATOR,9,</>	;INTEGER DIVIDE
	GENOP	NEG,14,SPECIAL		;INTEGER NEGATE
	GENOP	POS,16,SPECIAL		;INTEGER NOOP
OPP_K_NEG=OPP_K_DIV+1			;ONE GREATER THAN HIGEST ARITHMETIC
OPP_K_POS=OPP_K_DIV+1			;ONE GREATER THAN HIGEST ARITHMETIC
	GENOP	EQ,18,OPERATOR,7	;ARITHMETIC EQUAL
	GENOP	GE,20,OPERATOR,7	;ARITHMETIC GREATER OR EQUAL
	GENOP	GT,22,OPERATOR,7	;ARITHMETIC GREATER
	GENOP	LE,24,OPERATOR,7	;ARITHMETIC LESS OR EQUAL
	GENOP	LT,26,OPERATOR,7	;ARITHMETIC LESS
	GENOP	NE,28,OPERATOR,7	;ARITHMETIC NOT EQUAL
	GENOP	EQS,40,OPERATOR,7	;STRING EQUAL
	GENOP	GES,42,OPERATOR,7	;STRING GREATER OR EQUAL
	GENOP	GTS,44,OPERATOR,7	;STRING GREATER
	GENOP	LES,46,OPERATOR,7	;STRING LESS OR EQUAL
	GENOP	LTS,48,OPERATOR,7	;STRING LESS
	GENOP	NES,50,OPERATOR,7	;STRING NOT EQUAL
OPI_K_OPERAND = 52			;LOWEST OPERAND INDEX
	GENOP	STRING,52,OPERAND	;UNEVALUATED CHARACTER STRING OPERAND
	GENOP	STACK,54,OPERAND	;EVALUATED ON-STACK OPERAND
	.BYTE	0			;TABLE TERMINATOR BYTE

;
; SIZE OF EXPRESSION ANALYSIS STACK
;

PARSESTKSIZ = 132			;SIZE OF PARSE STACK
TRIADSTKSIZ = 364			;SIZE OF TRIAD STACK

;
; LOCAL VARIABLES ON STACK
;

		$DEFINI
NESTLVL:	.BLKB	1		; CURRENT LEVEL OF NESTING
REQMODE:	.BLKB	1		; REQUIRED EXPRESSION MODE
					; (0=CAN BE ANY MODE)
CURMODE:	.BLKB	1		; CURRENT EXPRESSION MODE
		.BLKB	1
RESULT:		.BLKQ	1		; EXPRESSION RESULT
LOCALSIZ:
		$DEFEND

;
; 'TRUE' AND 'FALSE'  VALUES
;
 
TRUE:	.ASCII	'TRUE'			;
FALSE:	.ASCII	'FALSE'			;
TRUSYM:	.ASCII	'TtYy'			; NOTE-ORDER IS ASSUMED ELSEWHERE


	.SBTTL	EVALUATE BINARY EXPRESSION
;+
; DCL$BINEXPR - EVALUATE BINARY EXPRESSION
;
; THIS ROUTINE IS CALLED TO ANALYZE AN EXPRESSION AND RETURN AN ARITHMETIC RESULT.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = BINARY LONGWORD VALUE
;
;	R2,R3 DESTROYED.
;-

DCL$BINEXPR::
	BSBB	DCL$EXPRESS		;EVALUATE EXPRESSION
	BLBS	R0,DCL$CVT_BINARY	;IF OK, CONVERT RESULT TO BINARY
	RSB

	.SBTTL	CONVERT STRING OPERAND TO BINARY
;+
; DCL$CVT_BINARY - CONVERT STRING OPERAND TO BINARY
;
; THIS ROUTINE IS CALLED TO CONVERT A EXPRESSION RESULT TO BINARY.
; IF THE RESULT IS ALREADY BINARY, THEN THAT VALUE IS RETURNED.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
;	R1/R2 = QUADWORD DESCRIBING EXPRESSION VALUE:
;		IF R2 NONZERO, R1/R2 ARE A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = BINARY LONGWORD VALUE
;	R2 = 0 (TO INDICATE RESULT IS BINARY)
;
;	R3 DESTROYED.
;-

DCL$CVT_BINARY::
	TSTL	R2			;STRING OR BINARY VALUE?
	BEQL	80$			;OK IF BINARY VALUE
	PUSHL	R2			;SAVE STARTING ADDRESS OF STRING
	MOVQ	R1,R2			;COPY STRING DESCRIPTOR
	MOVZBL	PRC_B_DEFRADIX(R11),R1	;SET RADIX FOR CONVERSION
	BSBW	DCL$CNVASCBIN		;CONVERT TO BINARY
	POPR	#^M<R2>			;RESTORE STARTING ADDRESS OF STRING
	BEQL	80$			;IF SUCCESSFUL, EXIT WITH R1
;
; INVALID CHARACTER IN STRING-CHECK FOR BEGINNING LETTER "TtYy"
; IF "T", "t", "Y", OR "y", THEN RETURN 1, ELSE RETURN 0.
;
	LOCC	(R2),#4,TRUSYM		;CHECK FOR TRUE CHARACTERS
	BEQL	70$			;BRANCH IF NONE FOUND
	MOVL	#1,R1			;SET RESULT TO TRUE
	BRB	80$			;SKIP
70$:	CLRL	R1			;SET RESULT TO FALSE
80$:	MOVL	#1,R0			;SUCCESSFUL
	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB

	.SBTTL	EXPRESSION ANALYSIS
;+
; DCL$EXPRESS - EXPRESSION ANALYSIS
;
; THIS ROUTINE IS CALLED TO ANALYZE AN EXPRESSION AND RETURN A BINARY
; OR CHARACTER STRING RESULTANT VALUE.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = QUADWORD DESCRIBING EXPRESSION VALUE:
;		IF R2 NONZERO, R1/R2 ARE A STRING DESCRIPTOR
;		IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;
;	R3 DESTROYED.
;-
 
DCL$EXPRESS::				;ANALYZE EXPRESSION
	MOVB	#PRC_K_DEC,R1		;SET TO DEFAULT DECIMAL RADIX
DCL$EXPRADIX::				;ALTERNATE ENTRY-RADIX SET EXTERNALLY
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,AP> ;SAVE REGISTERS
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE CURRENT PARSE POSITION
	MOVB	R1,PRC_B_DEFRADIX(R11)	;SET THE RADIX FOR LATER
	BISW	#WRK_M_STAR,WRK_W_FLAGS(R10) ;SET ASTERISK TERMINATOR FLAG

	SUBL	#LOCALSIZ,SP		;ALLOCATE SCRATCH SPACE ON STACK
	MOVL	SP,R7			;POINT TO SCRATCH SPACE
	CLRB	NESTLVL(R7)		;INITIALIZE PARENTHESIS NESTING LEVEL
	MOVB	R3,REQMODE(R7)		;SET EXPECTED EXPRESSION MODE

	MOVL	SP,R8			;SET ADDRESS OF PARSE STACK
	MOVAB	-<TRIADSTKSIZ+PARSESTKSIZ>(SP),SP ;ALLOCATE SPACE FOR STACKS
	MOVL	SP,R9			;SET BASE ADDRESS OF TRIAD STACK
	MOVL	#<OPP_K_SOS>@16+OPI_K_SOS,-(R8) ;INITIALIZE PARSE STACK
	MOVQ	(R8),-(R8)		;DUPLICATE FIRST ITEM FOR ERROR CHECK
 
;
; PARSE NEXT ITEM
;
 
10$:	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	20$			;IF NEQ NO
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
20$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/./,R0		;OPERATOR?
	BEQL	25$			;IF NEQ NO
	BSBW	DCL$GETOKEN		;GET NEXT TOKEN FROM INPUT BUFFER
	BEQL	40$			;IF EQL NONE
	CMPW	STK_W_TYPE(R8),#OPI_K_OPERAND ;TOS AN OPERAND?
	BLSS	80$			;BR IF OPERATOR IS TOP
	CMPL	#4,R1			;POSSIBLY 'THEN' KEY WORD?
	BNEQ	80$			;IF NEQ NO
	CMPL	#^A/THEN/,(R2)		;'THEN' KEYWORD?
	BEQL	130$			;IF SO, TERMINATE EXPRESSION PARSE

;
; PARSE OPERAND TOKEN
;
 
80$:	BSBW	PARSE_OPERAND		;PARSE THE OPERAND
					;(RESULTS MAY BE PLACED ON STACK) 
	BLBC	R0,35$			;EXIT IF ERROR DETECTED
	BRW	170$			;STACK THE OPERAND PARAMETERS

;
; PARSE .XX. OPERATORS
;
 
25$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET NEXT BLANK TOKEN
	CMPB	#^A/./,R0		;TERMINATOR PERIOD?
	BNEQ	30$			;IF NEQ NO
	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR TO EXPANSION BUFFER
30$:	BSBW	FIND_OPERATOR		;SEARCH OPERATOR TABLE
	BLBS	R0,50$			;IF FOUND, PROCESS OPERATOR
35$:	BRW	EXIT			;EXIT WITH ERROR
 
;
; PARSE OPERATOR CHARACTER
;
; TERMINATE EXPRESSION IF END-OF-LINE OR RIGHT PAREN W/O CORRESP. LEFT
;
 
40$:	MOVL	WRK_L_EXPANDPTR(R10),R2	;SET ADDRESS OF START OF SYMBOL
	CMPB	R0,#^A')'		;RIGHT PAREN?
	BNEQ	45$			;BRANCH IF NOT
	TSTB	NESTLVL(R7)		;IS THERE A CORRESPONDING LEFT PAREN?
	BLEQ	130$			;IF NO LEFT PAREN, TERMINATE EXPRESSION
45$:	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR TO EXPANSION BUFFER
	BEQL	130$			;IF EQL END OF LINE
	MOVL	#1,R1			;SET LENGTH OF STRING
	BSBW	FIND_OPERATOR		;SEARCH OPERATOR TABLE
	BLBS	R0,50$			;IF FOUND, PROCESS THE OPERATOR
	BSBW	DCL$BACKUPMOVE		;BACKUP MOST RECENT MOVCHAR

;
; MARK END OF EXPRESSION
;

130$:	MOVZBL	#OPP_K_EOS,R1		;SET END OF STATEMENT PRECEDENCE VALUE
	MOVZBL	#OPI_K_EOS,R3		;SET END OF STATEMENT OPERATOR INDEX
	BRB	140$			;FORCE EVERYTHING TO TRIAD STACK

;
; PROCESS OPERATOR
;
; IF LEFT PARENTHESIS, INCREMENT THE NESTING LEVEL AND MAKE SURE
; AN OPERATOR PRECEEDS IT.
;

50$:	CMPL	#OPI_K_LPAREN,R3	;LEFT PARENTHESIS?
	BNEQ	53$			;IF NEQ NO
	INCB	NESTLVL(R7)		;INCREMENT PAREN NESTING LEVEL
	CMPW	STK_W_TYPE(R8),#OPI_K_OPERAND ;TOP OF STACK OPERAND?
	BLSS	170$			;IF GTR NO
	BRW	250$			;REPORT EXPRESSION SYNTAX ERROR

;
; CHECK FOR LEGITIMATE UNARY OPERATORS.  CONVERT PLUS AND MINUS TO INTEGER
; NOOP AND NEGATE.  PLACE OPERATOR ON STACK.
;

53$:	CMPW	STK_W_TYPE(R8),#OPI_K_OPERAND	;TOS AN OPERATOR?
	BGEQ	140$				;IF NO
	CMPW	#OPI_K_ADD,R3			;THIS A UNARY PLUS?
	BNEQ	57$				;IF NEQ NO, SKIP TO NEXT
	MOVW	#OPI_K_POS,R3			;CONVERT THIS TO INTEGER NOOP
	MOVW	#OPP_K_POS,R1			;...
	BRB	170$				;GO STACK THIS
57$:	CMPW	#OPI_K_SUB,R3			;THIS A UNARY MINUS?
	BNEQ	63$				;IF NEQ NO
	MOVW	#OPI_K_NEG,R3			;CONVERT THIS TO NEGATE
	MOVW	#OPP_K_NEG,R1			;...
	BRB	170$				;GO STACK THIS 
63$:	CMPW	#OPI_K_NOT,R3			;NOT LPAREN, ADD OR SUB. ONLY LEGAL
	BEQL	170$				;IF .NOT., STACK OPERATOR
	BRW	250$				;GO REPORT SYNTAX ERROR
 
;
; COMPARE OPERATOR PRECEDENCE VALUE WITH OPERATOR IN NEXT TO LAST ITEM ON STACK
;
 
140$:	CMPW	STK_W_TYPE+STK_K_LENGTH(R8),#OPI_K_OPERAND ;PREVIOUS ITEM OPERATOR?
	BGEQ	150$			;IF LEQ NO
	CMPW	STK_W_PREC+STK_K_LENGTH(R8),R1 ;STACK OPERATOR HIGHER PRECEDENCE?
	BGEQ	190$			;IF GEQ YES
150$:	CMPL	#OPI_K_RPAREN,R3	;CURRENT OPERATOR RIGHT PARENTHESIS?
	BNEQ	160$			;IF NEQ NO
	DECB	NESTLVL(R7)		;DECREMENT PAREN NESTING LEVEL
	CMPW	#OPI_K_NOT,STK_W_TYPE+STK_K_LENGTH(R8)	;OPERATOR BOOLEAN NOT?
	BEQL	190$					;IF EQL YES
	CMPW	#OPI_K_NEG,STK_W_TYPE+STK_K_LENGTH(R8)	;OPERATOR NEGATE?
	BEQL	190$					;IF EQL YES
	CMPW	#OPI_K_POS,STK_W_TYPE+STK_K_LENGTH(R8)	;OPERATOR INTEGER NOOP?
	BEQL	190$					;IF EQL YES
	CMPW	#OPI_K_LPAREN,STK_W_TYPE+STK_K_LENGTH(R8) ;OPERATOR LEFT PAREN?
	BNEQ	250$			;IF NEQ NO
	MOVQ	(R8)+,(R8)		;REMOVE LEFT PARENTHESIS FROM STACK
	BRB	180$			;
160$:	CMPL	#OPI_K_EOS,R3		;END OF STATEMENT OPERATOR?
	BEQL	270$			;IF EQL YES

;
; STACK ITEM ONTO INTERMEDIATE PARSE STACK
;

170$:	MOVL	R2,-(R8)		;STACK NEW ITEM
	MOVW	R1,-(R8)		;
	MOVW	R3,-(R8)		;
	CMPL	R8,R9			;PARSE STACK OVERFLOW?
	BLEQU	240$			;IF LEQU YES
180$:	BRW	10$			;
 
;
; UNSTACK TRIAD FROM PARSE STACK
;
 
190$:	PUSHR	#^M<R1,R3>		;SAVE OPERATOR PARAMETERS
	CMPW	STK_W_TYPE(R8),#OPI_K_OPERAND ;TOP ITEM ON STACK OPERAND?
	BLSS	255$			;IF GTR NO
	MOVQ	(R8)+,R4		;REMOVE RIGHT HAND OPERAND FROM STACK
	MOVQ	(R8)+,R2		;REMOVE OPERATOR FROM STACK
	CMPW	#OPI_K_NOT,R2		;BOOLEAN NOT?
	BEQL	220$			;IF EQL YES
	CMPW	STK_W_TYPE(R8),#OPI_K_OPERAND ;TOP ITEM ON STACK OPERAND?
	BGEQ	210$			;IF YES
	CMPW	#OPI_K_NEG,R2		;OPERATOR UNARY MINUS?
	BEQL	220$			;IF EQL YES
	CMPW	#OPI_K_POS,R2		;OPERATOR INTEGER NOOP?
	BNEQ	255$			;IF NEQ NO
	BRB	220$			;
210$:	MOVQ	(R8)+,R0		;REMOVE LEFT HAND OPERAND FROM STACK
220$:	MOVL	R9,-(R8)		;PUSH ADDRESS OF STACK OPERAND
	MOVZBL	#OPI_K_STACK,-(R8)	;PUSH OPERAND INDEX VALUE
	CMPL	R9,R8			;TRIAD STACK OVERFLOW?
	BGTRU	245$			;IF GTRU YES
	MOVQ	R4,(R9)+		;PUSH RIGHT HAND OPERAND
	MOVZWL	R2,(R9)+		;PUSH OPERATOR INDEX
	MOVQ	R0,(R9)+		;PUSH LEFT HAND OPERAND
230$:	POPR	#^M<R1,R3>		;RETRIEVE OPERATOR PARAMETERS
	BRW	140$			;
 
;
; EXPRESION TOO COMPLEX
;
 
245$:	ADDL	#8,SP			;POP SAVED R1,R3 OFF STACK
240$:	STATUS	COMPLX			;SET COMPLEX EXPRESSION STATUS
	BRB	260$			;
 
;
; EXPRESSION SYNTAX ERROR
;
 
255$:	ADDL	#8,SP			;POP SAVED R1,R3 OFF STACK
250$:	STATUS	EXPSYN			;SET EXPRESSION SYNTAX ERROR STATUS
260$:	BRW	EXIT			;AND EXIT
 
;
; END OF STATEMENT - CHECK FOR VALID PARSE
;
 
270$:	CMPW	STK_W_TYPE(R8),#OPI_K_OPERAND ;TOP ITEM ON STACK OPERAND?
	BLSS	250$			;ERROR IF NOT
	MOVQ	(R8)+,(R9)+		;MOVE RIGHT HAND OPERAND TO TRIAD STACK
	CMPW	#OPI_K_SOS,STK_W_TYPE(R8) ;TOP OF STACK START OF STATEMENT?
	BNEQ	250$			;IF NEQ NO
	MOVZBL	#OPI_K_STORE,(R9)	;INSERT STORE OPERATOR
	BRW	EVALUATE		;EVALUATE THE EXPRESSION

	.SBTTL	SEARCH OPERATOR TABLE
;+
; FIND_OPERATOR - SEARCH OPERATOR TABLE
;
; THIS ROUTINE SEARCHES THE OPERATOR TABLE, GIVEN A STRING, TO
; LOCATE THE OPERATOR PRECEDENCE AND INDEX.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF STRING
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = OPERATOR PRECEDENCE
;	R3 = OPERATOR INDEX
;
;	R4,R5 DESTROYED.
;-
FIND_OPERATOR:
	MOVAB	OPTAB,R0		;GET ADDRESS OF OPERATOR TABLE
40$:	MOVL	R0,R5			;RETRIEVE ADDRESS OF NEXT OPERATOR ENTRY
	MOVZBL	(R5)+,R0		;GET OFFSET TO NEXT OPERATOR ENTRY
	BEQL	80$			;IF EQL END OF TABLE
	ADDL	R5,R0			;CALCULATE ADDRESS OF NEXT ENTRY
	CMPB	R1,(R5)+		;LENGTH OF NAMES MATCH?
	BNEQ	40$			;IF NEQ NO
	MOVQ	R1,R3			;COPY OPERATOR DESCRIPTOR
50$:	CMPB	(R4)+,(R5)+		;CHARACTERS MATCH?
	BNEQ	40$			;IF NEQ NO
	SOBGTR	R3,50$			;ANY MORE CHARACTERS TO MATCH?
	MOVZBL	(R5)+,R1		;GET OPERATOR PRECEDENCE VALUE
	MOVZBL	(R5),R3			;GET OPERATOR INDEX VALUE
	MOVL	#1,R0			;SUCCESS
	RSB
80$:	STATUS	IVOPER			;REPORT INVALID OPERATOR
	RSB

	.SBTTL	PARSE_OPERAND - PARSE OPERAND TOKEN
;+
; PARSE_OPERAND - PARSE OPERAND TOKEN
;
; THIS ROUTINE IS CALLED TO PARSE AN OPERAND TOKEN AND RETURN
; THE OPERAND PARAMETERS DESCRIBING THE OPERAND.
;
; INPUTS:
;
;	R1/R2 = STRING DESCRIPTOR OF OPERAND
;
; OUTPUTS:
;
;	R0 = STATUS
;
;	THE CALLER'S STACK MAY BE UPDATED IN ORDER TO SAVE
;	INTERMEDIATE STRINGS OR BINARY VALUES.
;-

PARSE_OPERAND:
	MOVZBL	(R2),-(SP)		;SAVE STARTING CHARACTER OF SYMBOL
	BSBW	DCL$COMPRESS		;COMPRESS QUOTED STRING
	MOVZBL	#OPI_K_STRING,R3	;ASSUME CHARACTER STRING LITERAL
	CMPL	#^A/"/,(SP)+		;STRING LITERAL?
	BEQL	170$			;IF EQL YES
	CMPB	#^A/%/,(R2)		;NUMERIC RADIX OPERATOR?
	BEQL	105$			;BR IF YES-ITS A NUMBER
	CMPB	#^A/0/,(R2)		;POSSIBLY NUMERIC CONSTANT?
	BGTRU	90$			;IF GTRU NO
	CMPB	#^A/9/,(R2)		;NUMERIC CONSTANT?
	BGEQU	105$			;IF GEQU YES
90$:	PUSHL	R7			;SAVE ADDRESS OF STACK STORAGE
	MOVQ	R1,R6			;COPY DESCRIPTOR FOR DCL$LEXIF
	BSBW	DCL$SEARCH		;SEARCH SYMBOL TABLE FOR VALUE
	BLBS	R0,95$			;IF LBC SEARCH FAILURE
	BSBW	DCL$LEXIF		;GET VALUE OF LEXICAL FUNCTION
95$:	POPL	R7			;RESTORE ADDRESS OF STACK STORAGE
	BLBC	R0,110$			;BRANCH IF NOT A FUNCTION
	TSTL	R2			;BINARY OR STRING?
	BEQL	96$			;BRANCH IF BINARY
	POPL	R0			;PICK UP RETURN ADDRESS
	SUBL	R1,SP			;ALLOCATE SPACE FOR STRING ON STACK
	PUSHL	R0			;RESTORE RETURN ADDRESS
	MOVL	R1,R6			;SAVE STRING SIZE
	MOVC	R1,(R2),4(SP)		;COPY STRING OPERAND TO STACK
	MOVL	R6,R1			;RESTORE STRING SIZE
	MOVAB	4(SP),R2		;SET ADDRESS OF COPIED STRING
96$:	POPL	R0			;PICK UP RETURN ADDRESS
	MOVQ	R1,-(SP)		;PUSH VALUE DESCRIPTOR ONTO STACK
	MOVL	SP,R2			;SET ADDRESS OF ON-STACK OPERAND
	PUSHL	R0			;RESTORE RETURN ADDRESS
	MOVZBL	#OPI_K_STACK,R3		;SET TYPE OF ITEM
170$:	MOVL	#1,R0			;SUCCESS
	RSB
;
; PARSE NUMERIC OPERAND
;
105$:	MOVQ	R1,R2			;COPY DESCRIPTOR
	MOVZBL	PRC_B_DEFRADIX(R11),R1	;SET RADIX FOR CONVERSION
	BSBW	DCL$CNVASCBIN		;CONVERT TO BINARY LONGWORD
	BNEQ	108$			;BRANCH IF CONVERSION ERROR
	CLRL	R2			;MARK VALUE IS BINARY
	BRB	96$			;AND STORE IT ON THE STACK

108$:	STATUS	IVCHAR			;ERROR CONVERTING NUMBER
	RSB
110$:	STATUS	UNDSYM			;SET UNDEFINED SYMBOL STATUS
	RSB

;
; EVALUATE THE EXPRESSION WHICH NOW CONSISTS OF TRIADS ORDERED
; BY PRECEDENCE, DESCRIBING THE ARGUMENTS AND OPERATORS IN THE
; ORDER THEY ARE TO BE EVALUATED.
;
 
EVALUATE:				;EVALUATE EXPRESSION
	MOVAB	-TRIADSTKSIZ-PARSESTKSIZ(R7),R9 ;GET STARTING ADDRESS OF TRIAD STACK
10$:	MOVL	R9,AP			;ADDRESS TO STORE RESULT
	BSBW	FETCH			;FETCH RIGHT HAND OPERAND PARAMETERS
	MOVL	(R9)+,R6		;FETCH OPERATOR INDEX
	CMPL	R6,#OPI_K_EQS		;STRING OPERATOR?
	BGEQ	20$			;IF GEQ YES
	CMPL	R6,#OPI_K_STORE		;STORE OPERATOR?
	BEQL	40$			;IF EQL YES
	CMPL	R6,#OPI_K_ADD		;ADD?
	BEQL	12$			;BRANCH IF SO
	CMPL	R6,#OPI_K_SUB		;SUB?
	BNEQ	15$			;BRANCH IF NOT

;
; (+) OR (-) OPERATORS.  DECIDE IF STRING OR ARITHMETIC OPERATOR SHOULD BE
; APPLIED.  ASSUME ARITHMETIC UNLESS BOTH SIDES ARE STRINGS
;

12$:	BSBW	OPERAND			;GET RIGHT HAND OPERAND DESCRIPTOR
	BEQL	15$			;IF BINARY, DO AN INTEGER ADD
	MOVQ	R1,R4			;SAVE RIGHT HAND OPERAND STRING DESCRIPTOR
	BSBW	FETCH			;FETCH LEFT HAND OPERAND PARAMETERS
	BSBW	OPERAND			;GET LEFT HAND OPERAND DESCRIPTOR
	BEQL	14$			;IF BINARY, ATTEMPT ARITHMETIC OPERATION
	MOVQ	R1,R2			;SAVE LEFT HAND OPERAND DESCRIPTOR
	JSB	W^STRINGDISP-OPI_K_ADD[R6] ;PERFORM STRING OPERATION
					;(RESULTANT STRING PLACED ONTO STACK)
	MOVQ	R4,(AP)			;STORE RESULTANT STRING DESCRIPTOR
	BRB	10$
14$:	SUBL	#8+4+8,R9		;BACKUP TRIAD STACK
	BSBW	FETCH			;RE-FETCH LEFT HAND OPERAND
	MOVL	(R9)+,R6		;RE-FETCH OPERATOR INDEX

;
; ARITHMETIC RELATIONAL OR BOOLEAN OPERATOR
;
 
15$:	BSBW	NUMERIC			;CONVERT RIGHT HAND OPERAND TO NUMERIC
	MOVL	R0,R4			;SAVE RIGHT HAND OPERAND VALUE
	BSBW	FETCH			;FETCH LEFT HAND OPERAND PARAMETERS
	CMPL	R6,#OPI_K_NOT		;BOOLEAN NOT OPERATOR?
	BEQL	30$			;IF EQL YES
	CMPL	R6,#OPI_K_NEG		;INTEGER NEGATION?
	BEQL	30$			;IF EQL YES
	CMPL	R6,#OPI_K_POS		;INTEGER NOOP?
	BEQL	30$			;IF EQL YES
	BSBW	NUMERIC			;CONVERT LEFT HAND OPERAND TO NUMERIC
	MOVL	R0,R2			;SAVE LEFT HAND OPERAND VALUE
	CMPL	R2,R4			;COMPARE RIGHT AND LEFT HAND OPERANDS
	BRB	30$			;

40$:	BRB	41$ 			;CONTINUE TO STORE RESULT CODE
;
; STRING RELATIONAL OPERATOR
;
 
20$:	BSBW	STRING			;CONVERT RIGHT HAND OPERAND TO STRING
	PUSHL	WRK_L_EXPANDPTR(R10)	;ASSUME RESULT IS IN EXPANSION BUFFER
	CMPL	R2,WRK_L_EXPANDPTR(R10)	;IS RESULT IN EXPANSION BUFFER
	BNEQ	25$			;IF NOT, THEN SKIP
	ADDL	R1,WRK_L_EXPANDPTR(R10)	;MOVE EXPANSION POINTER PAST STRING
25$:	MOVQ	R1,R4			;SAVE RIGHT HAND OPERAND STRING DESCRIPTOR
	BSBW	FETCH			;FETCH LEFT HAND OPERAND PARAMETERS
	BSBW	STRING			;CONVERT LEFT HAND OPERAND TO STRING
	MOVQ	R1,R2			;SAVE LEFT HAND OPERAND DESCRIPTOR
	SUBL	#OPI_K_EQS-OPI_K_EQ,R6	;NORMALIZE OPERATOR INDEX
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	CMPC5	R2,(R3),#0,R4,(R5)	;COMPARE RIGHT AND LEFT HAND OPERANDS
30$:	JSB	W^DISPATCH[R6]		;EXECUTE OPERATOR SPECIFIC ROUTINE
	MOVL	R4,(AP)			;STORE OPERATION RESULT
	CLRL	4(AP)			;INDICATE RESULT IS BINARY
	BRW	10$			;
 
;
; STORE RESULT OPERATOR
;
 
41$:	BSBB	OPERAND			;GET DESCRIPTOR OF RIGHT-HAND OPERAND
	BEQL	50$			;BRANCH IF BINARY RESULT
	MOVAB	WRK_G_BUFFER(R10),R0	;GET ADDRESS OF EXPANSION BUFFER
	SUBL	WRK_L_EXPANDPTR(R10),R0	;CALCULATE HOW MUCH HAS BEEN USED
	SUBL3	R0,#WRK_C_CMDBUFSIZ,R0	;CALCULATE HOW MUCH IS LEFT
	CMPL	R0,R1			;WILL RESULT FIT?
	BGTR	45$			;YES, THEN STORE IT AWAY
	STATUS 	BUFOVF			;SET OVERFLOW STATUS
	BRB	EXIT			;EXIT WITH ERROR
45$:	MOVL	R1,R6			;SAVE LENGTH OF STRING
	MOVC	R1,(R2),@WRK_L_EXPANDPTR(R10) ;COPY IT TO THE EXPANSION BUFFER
	MOVL	R6,R1			;RETURN LENGTH OF RESULT STRING
	MOVL	WRK_L_EXPANDPTR(R10),R2	;AND ADDRESS OF RESULT STRING
50$:	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
EXIT:	MOVAB	LOCALSIZ(R7),SP		;DEALLOCATE SCRATCH STACKS
	POPR	#^M<R3,R4,R5,R6,R7,R8,R9,AP> ;RESTORE REGISTERS
	BLBC	R0,90$			;BRANCH IF ERROR EXIT
	MOVL	R3,WRK_L_MARKPTR(R10)	;LEAVE MARKPTR SET TO START OF EXPR.
90$:	RSB				;

	.SBTTL	FETCH NEXT OPERAND FROM TRIAD STACK
;
; FETCH - FETCH NEXT OPERAND FROM TRIAD STACK
;
 
FETCH:	MOVZWL	(R9)+,R0		;GET TYPE OF OPERAND
	MOVZWL	(R9)+,R1		;GET LENGTH OF OPERAND
	MOVL	(R9)+,R2		;GET ADDRESS OF OPERAND
	RSB				;

	.SBTTL	GET OPERAND DESCRIPTOR
;
; OPERAND - GET OPERAND DESCRIPTOR FROM OPERAND PARAMETERS
;
; Z BIT SET ON R2 (ADDRESS), Z=1 INDICATES BINARY, Z=0 INDICATES STRING
;
OPERAND:
	CMPL	#OPI_K_STACK,R0		;STACK OPERAND?
	BNEQ	10$			;BRANCH IF NOT
	MOVQ	(R2),R1			;GET OPERAND DESCRIPTOR
	MOVZBL	#OPI_K_STRING,R0	;MARK OPERAND NOW A STRING
10$:	TSTL	R2			;SET CONDITION CODES ON TYPE
	RSB	

	.SBTTL	CONVERT STRING PARAMETERS TO STRING OPERAND
;
; STRING - CONVERT OPERAND TO CHARACTER STRING
;
; IF THE OPERAND IS EVALUATED, THEN RETURN ITS DESCRIPTOR IF ITS
; A STRING, AND IF NUMERIC, CONVERT IT TO ASCII DECIMAL.
; IF THE OPERAND IS AN UNEVALUATED CHARACTER OR NUMERIC STRING LITERAL,
; SIMPLY RETURN WITH THE DESCRIPTOR.
;
 
STRING:					;STRING OPERAND
	BSBB	OPERAND			;GET OPERAND DESCRIPTOR
	BNEQ	10$			;IF STRING, EXIT WITH DESCRIPTOR
	PUSHL	R3			;SAVE R3
	BSBW	DCL$CVT_STRING		;CONVERT TO STRING
	POPL	R3			;RESTORE R3
10$:	RSB				;

	.SBTTL	CONVERT OPERAND PARAMETERS TO NUMERIC VALUE
;
; NUMERIC - CONVERT OPERAND PARAMETERS TO NUMERIC VALUE
;
 
NUMERIC:				;NUMERIC OPERAND
;
; IF THE OPERAND IS ALREADY BINARY FROM A PREVIOUS EVALUATION, RETURN IT
;
	BSBB	OPERAND			;GET OPERAND DESCRIPTOR
	BEQL	30$			;IF BINARY, RETURN WITH VALUE IN R1
;
; CONVERT A NUMERIC STRING TO A BINARY LONGWORD
;
	MOVZBL	PRC_B_DEFRADIX(R11),-(SP) ;SAVE DEFAULT RADIX
	CMPL	#OPI_K_STRING,R0	;IS THIS A CHARACTER STRING LITERAL?
	BEQL	10$			;IF SO, USE DEFAULT RADIX
	MOVZBL	#PRC_K_DEC,PRC_B_DEFRADIX(R11) ;OTHERWISE, USE DECIMAL RADIX
10$:	BSBW	DCL$CVT_BINARY		;CONVERT STRING TO BINARY
	CVTLB	(SP)+,PRC_B_DEFRADIX(R11) ;RESTORE DEFAULT RADIX
	BLBC	R0,85$			;BRANCH IF ERROR DETECTED
30$:	MOVL	R1,R0			;SET VALUE
	RSB				;

85$:	BSBW	DCL$MARK		;MARK START OF ERROR SEGMENT
	MOVB	(R2),R0			;PICK UP FIRST BYTE OF STRING
	BSBW	DCL$PUTCHAR		;WRITE CHARACTER INTO BUFFER
					;SO THAT ERROR REPORTING CAN
					;DISPLAY THE CHARACTER
	TSTL	(SP)+			;CLEAN STACK OF PREVIOUS CALLER
	STATUS	IVCHAR			;INVALID CHARACTER
	BRW	EXIT			;RETURN TO CALLER'S CALLER

	.SBTTL	DISPATCH STRING OPERATION FUNCTION
;
; DISPATCH FUNCTIONS WHICH RESULT IN STRINGS
;
STRINGDISP:
	BRB	CONCAT			;STRING CONCATENATION
	BRB	REDUCE			;STRING REDUCTION

	.SBTTL	STRING CONCATENATION OPERATOR
;
; THIS ROUTINE PROCESSES THE STRING CONCATENATION OPERATOR AND STORES
; THE RESULTANT STRING ON THE CALLER'S STACK.
;
; INPUTS:
;
;	R2/R3 = STRING DESCRIPTOR OF LEFT-HAND SIDE
;	R4/R5 = STRING DESCRIPTOR OF RIGHT-HAND SIDE
;
; OUTPUTS:
;
;	R4/R5 = STRING DESCRIPTOR OF RESULTANT STRING
;
;	R0-R3,R6 DESTROYED.
;
CONCAT:	POPL	R6			;POP CALLER'S RETURN ADDRESS
	ADDL3	R2,R4,R0		;COMPUTE SIZE OF RESULTANT STRING
	SUBL	R0,SP			;ALLOCATE SPACE ON CALLER'S STACK
	PROBEW	#0,#128,-128(SP)	;CHECK FOR STACK OVERFLOW
	BNEQ	10$			;CONTINUE IF SUCCESSFUL
	STATUS	BUFOVF			;SET STATUS
	BRW	EXIT			;EXIT WITH STATUS
10$:	PUSHL	R0			;SAVE SIZE OF RESULTANT STRING
	MOVQ	R4,-(SP)		;SAVE DESCRIPTOR OF RIGHT-SIDE
	MOVC	R2,(R3),12(SP)		;COPY FIRST STRING ONTO STACK
	MOVQ	(SP)+,R4		;RESTORE DESCRIPTOR OF RIGHT-SIDE
	MOVC	R4,(R5),(R3)		;APPEND SECOND STRING TO FIRST
	POPL	R4			;RESTORE SIZE OF RESULTANT STRING
	MOVL	SP,R5			;SET ADDRESS OF RESULTANT STRING
	JMP	(R6)			;RETURN

	.SBTTL	STRING REDUCTION OPERATOR
;
; THIS ROUTINE PROCESSES THE STRING REDUCTION OPERATOR (-) AND STORES
; THE RESULTANT STRING ON THE CALLER'S STACK.
;
; INPUTS:
;
;	R2/R3 = STRING DESCRIPTOR OF LEFT-HAND SIDE
;	R4/R5 = STRING DESCRIPTOR OF RIGHT-HAND SIDE
;
; OUTPUTS:
;
;	R4/R5 = STRING DESCRIPTOR OF RESULTANT STRING
;
;	R0-R3,R6 DESTROYED.
;
REDUCE:	PUSHR	#^M<R2,R3>		;SAVE LEFT SIDE OPERAND
	MATCHC	R4,(R5),R2,(R3)		;LOCATE SUBSTRING WITHIN STRING
	BNEQ	50$			;BRANCH IF NOT FOUND IN LEFT SIDE
	MOVQ	R2,R0			;SAVE DESCRIPTOR OF PIECE AFTER MATCH
	POPR	#^M<R2,R3,R6>		;GET LEFT SIDE AND RETURN ADDRESS
	SUBL3	R4,R2,R4		;COMPUTE SIZE OF RESULTANT STRING
	SUBL3	R0,R4,R2		;COMPUTE SIZE OF PIECE BEFORE MATCH
	SUBL	R4,SP			;ALLOCATE SPACE ON CALLER'S STACK
	PUSHR	#^M<R0,R1,R4>		;SAVE REGISTERS
	MOVC	R2,(R3),12(SP)		;COPY PIECE BEFORE MATCH INTO RESULT
	MOVQ	(SP)+,R0		;GET DESCRIPTOR OF PIECE AFTER MATCH
	MOVC	R0,(R1),(R3)		;APPEND PIECE AFTER MATCH INTO RESULT
	POPL	R4			;RESTORE SIZE OF RESULTANT STRING
	MOVL	SP,R5			;SET ADDRESS OF RESULTANT STRING
	JMP	(R6)			;RETURN
;
; SUBSTRING NOT FOUND IN STRING - RETURN MAIN STRING INTACT
;
50$:	MOVQ	(SP)+,R4		;RETURN DESCRIPTOR OF LEFT SIDE
	RSB

	.SBTTL	DISPATCH BINARY/LOGICAL OPERATOR
;
; DISPATCH BINARY/LOGICAL OPERATOR FUNCTION
;
; INPUTS:
;
;	R2/R3 = LEFT HAND OPERAND
;	R4/R5 = RIGHT HAND OPERAND
;
; OUTPUTS:
;
;	R4/R5 = RESULT VALUE
;
 
DISPATCH:				;
	BRB	AND			;BOOLEAN AND
	BRB	NOT			;BOOLEAN NOT
	BRB	OR			;BOOLEAN OR
	BRB	ADD			;INTEGER ADD
	BRB	SUB			;INTEGER SUBTRACT
	BRB	MUL			;INTEGER MULTIPLY
	BRB	DIV			;INTEGER DIVIDE
	BRB	NEG			;INTEGER NEGATION
	BRB	POS			;INTEGER NOOP
	BRB	EQL			;EQUAL
	BRB	GEQ			;GREATER OR EQUAL
	BRB	GTR			;GREATER
	BRB	LEQ			;LESS OR EQUAL
	BRB	LSS			;LESS
;	BRB	NEQ			;NOT EQUAL
 
;
; NOT EQUAL
;
 
NEQ:	BNEQ	SETRUE			;IF NEQ SETRUE RESULT
	BRB	SETFALSE
 
;
; BOOLEAN AND
;
 
AND:	MCOML	R2,R2			;COMPLEMENT LEFT HAND OPERAND
	BICL	R2,R4			;FORM BOOLEAN AND FUNCTION
	RSB				;
 
;
; BOOLEAN NOT
;
 
NOT:	MCOML	R4,R4			;FORM BOOLEAN NOT FUNCTION
	RSB				;
 
;
; BOOLEAN OR
;
 
OR:	BISL	R2,R4			;FORM BOOLEAN OR FUNCTION
	RSB				;
 
;
; INTEGER ADD
;
 
ADD:	ADDL	R2,R4			;FORM ARITHMETIC SUM
	RSB				;
 
;
; INTEGER SUBTRACT
;
 
SUB:	SUBL3	R4,R2,R4		;FORM ARITHMETIC DIFFERENCE
	RSB				;
 
;
; INTEGER MULTIPLY
;
 
MUL:	MULL	R2,R4			;FORM ARITHMETIC PRODUCT
	RSB				;
 
;
; INTEGER DIVIDE
;
 
DIV:	TSTL	R4			;DIVIDE BY ZERO ATTEMPT?
	BNEQ	20$			;BR IF NO
	SETBIT	#31,R4			;MAKE RESULT THE HIGHEST NEGATIVE NUMBER
	TSTL	R2			;SOURCE NEGATIVE?
	BLSS	10$			;BR IF YES
	MCOML	R4,R4			;MAKE THE LARGEST POSITIVE NUMBER
10$:	RSB				;
20$:	DIVL3	R4,R2,R4		;FORM ARITHMETIC QUOTIENT
	RSB				;
 
 
;
; INTEGER NEGATION
;
 
NEG:	MNEGL	R4,R4			;NEGATE OPERAND
	RSB				;
 
;
; INTEGER NOOP
;
 
POS:	RSB				;NOOP
 
;
; EQUAL
;
 
EQL:	BEQL	SETRUE			;IF EQL SETRUE RESULT
	BRB	SETFALSE
 
;
; GREATER OR EQUAL
;
 
GEQ:	BGEQ	SETRUE			;IF GEQ SETRUE RESULT
	BRB	SETFALSE
 
;
; GREATER
;
 
GTR:	BGTR	SETRUE			;IF GTR SETRUE RESULT
	BRB	SETFALSE
 
;
; LESS OF EQUAL
;
 
LEQ:	BLEQ	SETRUE			;IF LEQ SETRUE RESULT
	BRB	SETFALSE
 
;
; LESS
;
 
LSS:	BLSS	SETRUE			;IF LSS SETRUE RESULT

;
; RETURN FALSE RESULT
;

SETFALSE:
	CLRL	R4			;SET RESULT FALSE
	RSB

;
; RETURN TRUE RESULT
;
 
SETRUE:	MOVL	#1,R4			;SET RESULT TRUE
	RSB				;
 
	.END
