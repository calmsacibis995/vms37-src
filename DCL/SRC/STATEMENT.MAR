	.TITLE	STATEMENT - ARITHMETIC ASSIGNMENT AND STRING EQUATE PROCESSING
	.IDENT	'V03-008'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ARITHMETIC ASSIGNMENT AND STRING EQUATE STATEMENT PROCESSING
;
; D. N. CUTLER 16-MAY-77
;
; MODIFIED BY:
;
;	V008	PCG0003		Peter George	20-Apr-1982
;		Correctly handle substring assignment when previous
;		value is an integer.
;
;	V007	PCG0002		Peter George	26-Mar-1982
;		Correctly handle substring cases when previous value 
;		was not found.
;
;	V006	PCG0001		Peter George	15-Mar-1982
;		Pick symbol up from appropriate symbol table when
;		doing substring substitutions.
;
;	V005	TMH0005		Tim Halvorsen	07-Sep-1981
;		Allow abbreviated symbol definitions (*) on assignment
;		statements (=).
;		Fix access violation in arithmetic vield insertion.
;
;	V004	TMH0004		Tim Halvorsen	11-Feb-1981
;		Use DCL$MARK rather than R6 as error segment pointer.
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Remove all references to R10.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARKEDTOKEN routine.
;		Set symbol type when calling ALLOCSYM
;		Make use of DCL$COMPRESS routine.
;
;	V003	TMH0003		Tim Halvorsen	06-Feb-1981
;		Update display parameter after each substring token
;		in case of syntax errors in the substring specification.
;
;	V002	TMH0002		Tim Halvorsen	14-Jan-1981
;		Accept expressions in substring arguments.  Ignore any
;		spaces after the ] in substring assignments.
;
;	V001	TMH0001		Tim Halvorsen	09-Sep-1980
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

	.SBTTL	SUBSTRING ASSIGNMENT STATEMENT
;+
; DCL$SUBASSIGN - SUBSTRING ASSIGNMENT
;
; THIS ROUTINE IS CALLED WHEN A SYMBOL DEFINITION IS TERMINATED WITH A LEFT SQUARE
; BRACKET.
;
; INPUTS:
;
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE POSITION AND SIZE PARAMETERS ARE PARSED AND THE ASSIGNMENT IS DISPATCHED
;	TO THE PROPER ASSIGNMENT STATEMENT PROCESSOR.
;-
 
DCL$SUBASSIGN::				;SUBSTRING ASSIGNMENT
	MOVQ	R1,-(SP)		;SAVE SYMBOL NAME PARAMETERS
	MOVL	WRK_L_EXPANDPTR(R10),R9	;SAVE PTR TO FIELD SPECIFICATION
	BSBW	DCL$MOVCHAR		;MOVE RIGHT BRACKET
	BSBW	DCL$EXPRESS		;EVALUATE POSITION EXPRESSION
	BLBC	R0,90$			;BRANCH IF ERROR
	MOVL	R1,R8			;SAVE POSITION PARAMETER
	BSBW	DCL$MOVCHAR		;MOVE NEXT CHARACTER
	CMPB	R0,#^A','		;COMMA?
	BNEQ	20$			;ERROR IF NOT
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$EXPRESS		;EVALUATE SIZE EXPRESSION
	BLBC	R0,90$			;BRANCH IF ERROR
	MOVL	R1,R7			;SAVE SIZE PARAMETER
	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR TO COMMAND BUFFER
	CMPB	R0,#^A']'		;RIGHT BRACKET?
	BNEQ	20$			;ERROR IF NOT
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETNBLK		;PEEK AT NEXT CHARACTER IN COMMAND BUFFER
	CMPB	#^A/=/,R0		;ARITHMETIC ASSIGNMENT?
	BEQL	60$			;IF EQL YES
	CMPB	#^A/:/,R0		;STRING EQUATE (:=)?
	BNEQ	20$			;IF NEQ NO
	BSBW	DCL$MOVCHAR		;MOVE NEXT CHARACTER TO COMMAND BUFFER
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN COMMAND BUFFER
	CMPB	#^A/=/,R0		;STRING EQUATE (:=)?
	BEQL	50$			;BRANCH IF OK
20$:	STATUS	SYMDEL			;INVALID SUBSTRING DELIMITER
90$:	ADDL	#8,SP			;POP SAVED SYMBOL NAME DESCRIPTOR
	RSB
;
; STRING ASSIGNMENT -- [POS,CHARS] := STRING
;
50$:	MOVQ	(SP)+,R1		;RESTORE SYMBOL NAME PARAMETERS
	MOVL	R2,WRK_L_MARKPTR(R10)	;RESET ERROR DISPLAY POINTER
	MOVL	#1,R6			;SET SUBSTRING INDICATOR
	BRW	EQUATE			;
;
; NUMERIC ASSIGNMENT -- [POS,BITS] = EXPRESSION
;
60$:	MOVQ	(SP)+,R1		;RESTORE SYMBOL NAME PARAMETERS
	MOVL	R2,WRK_L_MARKPTR(R10)	;RESET ERROR DISPLAY POINTER
	MOVL	#1,R6			;SET SUBSTRING INDICATOR
	BRB	EVALUATE		;

	.SBTTL	EVALUATE ASSIGNMENT STATEMENT
;+
; DCL$EVALUATE - EVALUATE ASSIGNMENT STATEMENT
;
; THIS ROUTINE IS CALLED TO PROCESS AN ASSIGNMENT STATEMENT.
;
; INPUTS:
;
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;	R9 = ADDRESS OF FIELD SPECIFICATION.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES EXPRESSION ANALYSIS OR ASSIGNMENT FAILURE.
;
;		R0 = DCL$_COMPLX - EXPRESSION TOO COMPLEX.
;		R0 = DCL$_EXPSYN - EXPRESSION SYNTAX ERROR.
;		R0 = DCL$_IVCHAR - INVALID NUMERIC CHARACTER.
;		R0 = DCL$_IVOPER - INVALID EXPRESSION OPERATOR.
;		R0 = DCL$_IVSYMB - INVALID SYMBOL CHARACTER.
;		R0 = DCL$_SYMDEL - INVALID SYMBOL DELIMITER.
;		R0 = DCL$_SYMOVF - SYMBOL TABLE OVERFLOW.
;		R0 = DCL$_UNDSYM - UNDEFINED SYMBOL.
;		R0 = DCL$_INVRANGE  - FIELD SPECIFICATION OUT OF BOUNDS
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = DCL$_NORMAL - NORMAL COMPLETION.
;-
 
DCL$EVALUATE::				;EVALUATE ASSIGNMENT STATEMENT
	CLRL	R6			;CLEAR BIT FIELD SUBSTRING INDICATOR
;
; ON ENTRY, IF R6 = 1,
;
;	R7 = SUBSTRING FIELD WIDTH
;	R8 = SUBSTRING STARTING BIT NUMBER
;
EVALUATE:				;EVALUATE EXPRESSION
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
	CMPL	#32,R7			;FIELD WIDTH GREATER THAN LONGWORD?
	BGEQU	10$			;IF GEQU NO
	MOVL	#32,R7			;REDUCE FIELD WIDTH TO A LONGWORD
10$:	BSBW	CHECKSYM		;CHECK SYMBOL AND SAVE PARAMETERS
	PUSHR	#^M<R6,R7,R8,R9>	;SAVE BIT FIELD SUBSTRING PARAMETERS
	BSBW	DCL$EXPRESS		;EVALUATE ARITHMETIC EXPRESSION
	POPR	#^M<R6,R7,R8,R9>	;RESTORE BIT FIELD SUBSTRING PARAMETERS
	POPR	#^M<R3,R4,R5>		;RETRIEVE SYMBOL NAME PARAMETERS
	BLBS	R0,12$			;BRANCH IF OK
	RSB				;EXIT WITH ERROR
;
; IF NO SUBSTRING SPECIFIED, STORE VALUE IN SYMBOL
;
12$:	BLBS	R6,15$			;IF LBC NO BIT FIELD SUBSTRING SPECIFIED
	MOVL	#SYM_K_STRING,R0	;ASSUME STRING VALUE
	TSTL	R2			;STRING VALUE?
	BNEQ	13$			;BRANCH IF SO
	MOVL	#SYM_K_BINARY,R0	;SET TO BINARY VALUE
13$:	BSBW	DCL$ALLOCSYMABR		;ALLOCATE AND INSERT SYMBOL IN TABLE
	BRW	70$			;CLEANUP INPUT STREAM
;
; FIND PREVIOUS VALUE OF SYMBOL
;
15$:	TSTL	R2			;INSERTING STRING INTO BIT FIELD?
	BEQL	16$			;OK IF NOT
	BRW	IVCHAR			;ERROR IF SO
16$:	PUSHR	#^M<R1,R3,R4,R5>	;SAVE EXPRESSION AND SYMBOL NAME PARAMETERS
	MOVQ	R3,R1			;SET SYMBOL NAME PARAMETERS FOR SEARCH
	MOVAB	PRC_Q_LOCAL(R11),R0	;GET ADDRESS OF LOCAL SYMBOL TABLES
	CMPL	R5,R0			;WHICH TABLES SHOULD WE SEARCH?
	BNEQ	17$			;IF NEQ, THEN GLOBAL
	BSBW	DCL$SEARCH_LOCAL	;SEARCH LOCAL SYMBOL TABLES
	BRB	18$			;SKIP NEXT SEARCH
17$:	BSBW	DCL$SEARCH_GLOBAL	;SEARCH GLOBAL SYMBOL TABLE
18$:	BLBS	R0,20$			;BRANCH IF SUCCESSFUL SEARCH
	CLRL	R1			;UNSUCESSFUL, ASSUME NULL STRING
;
; IF PREVIOUS VALUE WAS AN INTEGER, THEN PERFORM BOUNDS CHECKING AND THEN
; INSERT THE NEW VALUE INTO THE LONGWORD.
;
20$:	TSTL	R2			;BINARY VALUE?
	BNEQ	25$			;BRANCH IF NOT
	CMPL	#32,R8			;STARTING BIT OUTSIDE LONGWORD?
	BLEQU	23$			;IF LEQU YES
	ADDL3	R7,R8,R0		;FIND ENDING BIT
	CMPL	#32,R0			;IS IT OUTSIDE THE LONGWORD?
	BLSSU	23$			;IF LSSU YES
	INSV	(SP)+,R8,R7,R1		;INSERT BIT FIELD INTO LONGWORD
	MOVL	#SYM_K_BINARY,R0	;SET TYPE OF SYMBOL
	BRW	55$			;STORE THE SYMBOL AWAY
23$:	MOVL	R9,WRK_L_MARKPTR(R10)	;RESET PTR TO ERROR SEGMENT
	ADDL	#4*4,SP			;RESTORE THE STACK
	MOVL	#CLI$_INVRANGE,R0	;SET INVALID RANGE
	RSB
;
; INITIALIZE THE EXPANSION BUFFER (IT WILL HOLD THE RESULT) AND 
; CALCULATE THE EXTENT OF THE STRING INSERTION
;
25$:	MOVAB	WRK_G_BUFFER+255(R10),WRK_L_EXPANDPTR(R10) ;RELOAD ADDRESS OF EXPANSION BUFFER
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	ADDL3	R7,R8,R6		;CALCULATE ENDING BIT NUMBER
	ADDL	#7,R6			;ROUND UP TO NEXT BYTE
	DIVL	#8,R6			;CALCULATE ENDING BYTE NUMBER
	MOVL	R1,R5			;SAVE LENGTH OF SYMBOL STRING
;
; MOVE PREVIOUS STRING VALUE INTO THE EXPANSION BUFFER
;
27$:	DECL	R5			;ANY MORE CHARACTERS TO COPY?
	BLSS	30$			;IF LSS NO
	MOVZBL	(R2)+,R0		;GET NEXT SYMBOL CHARACTER
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN COMMAND BUFFER
	BRB	27$			;
;
; EXTEND THE STRING AS NEEDED
;
30$:	SUBL3	R1,R6,R5		;CALCULATE NUMBER OF EXTENSION CHARACTERS
	BLEQ	50$			;IF LEQ NO EXTENSION REQUIRED
	MOVL	R6,R1			;SET LENGTH OF RESULTANT STRING
40$:	CLRL	R0			;CLEAR EXTENSION BYTE
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN COMMAND BUFFER
	SOBGTR	R5,40$			;ANY MORE EXTENSION CHARACTERS?
;
; INSERT THE VALUE INTO THE STRING
;
50$:	MOVAB	WRK_G_BUFFER+255(R10),R2 ;GET ADDRESS OF NEW SYMBOL VALUE
	INSV	(SP)+,R8,R7,(R2)	;INSERT BIT FIELD SUBSTRING
	MOVL	#SYM_K_STRING,R0	;SET TYPE OF SYMBOL
;
; STORE THE SYMBOL AWAY
;
55$:	POPR	#^M<R3,R4,R5>		;RETRIEVE SYMBOL PARAMETERS
	BSBW	DCL$ALLOCSYM		;ALLOCATE AND INSERT SYMBOL IN TABLE
;
; ENSURE THAT THERE ARE NO MORE CHARACTERS IN THE INPUT STREAM
;
70$:	SETBIT	WRK_M_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND EXECUTION IN PROGRESS
	BLBC	R0,90$			;IF LBC SYMBOL ALLOCATION ERROR
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BNEQ	SYMDEL			;IF NEQ INVALID SYMBOL DELIMITER
	STATUS	NORMAL			;SET NORMAL COMPLETION
90$:	RSB				;
 
IVCHAR:	STATUS	IVCHAR			;INVALID NUMERIC CHARACTER
	RSB

SYMDEL:	STATUS	SYMDEL			;SET INVALID SYMBOL DELIMITER
	RSB				;

	.SBTTL	PROCESS STRING EQUATE STATEMENT
;+
; DCL$EQUATE - PROCESS STRING EQUATE STATEMENT
;
; THIS ROUTINE IS CALLED TO PROCESS A STRING EQUATE STATEMENT.
;
; INPUTS:
;
;	R0 = TERMINATOR CHARACTER.
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SYMBOL ALLOCATION FAILURE.
;
;		R0 = DCL$_INSYMB - INVALID SYMBOL CHARACTER.
;		R0 = DCL$_SYMDEL - INVALID SYMBOL DELIMITER.
;		R0 = DCL$_SYMOVF - SYMBOL TABLE OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL ALLOCATION.
;
;		R0 = DCL$_NORMAL - NORMAL COMPLETION.
;-
 
DCL$EQUATE::				;PROCESS STRING EQUATE STATEMENT
	CLRL	R6			;CLEAR SUBSTRING INDICATOR
;
; ON ENTRY, IF R6 = 1,
;
;	R7 = SUBSTRING FIELD WIDTH
;	R8 = SUBSTRING STARTING CHARACTER NUMBER
;
EQUATE:					;EQUATE SYMBOL
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
	BSBW	CHECKSYM		;CHECK SYMBOL AND SAVE PARAMETERS
	BSBW	DCL$SETNBLK		;SET TO FIRST NON-BLANK CHARACTER
	BSBW	DCL$MARK		;MARK CURRENT POSITION IN BUFFER
20$:	BSBW	DCL$MOVCHAR		;COPY NEXT CHARACTER INTO THE BUFFER
	BNEQ	20$			;UNTIL END OF LINE
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF MARKED STRING
	DECL	R1			;SUBTRACT OUT EOL
	BEQL	40$			;IF EQL NULL STRING VALUE
	BSBW	DCL$COMPRESS		;COMPRESS QUOTED STRING
40$:	PUSHAB	DCL$ALLOCSYMABR		;GUESS AT ALLOWING ABBREVIATED SYMBOL
	BLBS	R6,41$			;IF LBS, SUBSTRING SPECIFIED
	BRW	120$			;BRANCH IF NOT SUBSTRING ASSIGNMENT
;
; FIND PREVIOUS VALUE OF SYMBOL
;
41$:	MOVQ	R1,-(SP)		;SAVE EQUIVALENCE STRING PARAMETERS
	MOVQ	12(SP),R1		;RETRIEVE SYMBOL NAME PARAMETERS
	MOVAB	PRC_Q_LOCAL(R11),R0	;GET ADDRESS OF LOCAL SYMBOL TABLES
	CMPL	20(SP),R0		;WHICH TABLES SHOULD WE SEARCH?
	BNEQ	47$			;IF NEQ, THEN GLOBAL
	BSBW	DCL$SEARCH_LOCAL	;SEARCH LOCAL SYMBOL TABLES
	BRB	48$			;SKIP NEXT SEARCH
47$:	BSBW	DCL$SEARCH_GLOBAL	;SEARCH GLOBAL SYMBOL TABLE
48$:	BLBS	R0,49$			;BRANCH IF SUCCESSFUL SEARCH
	CLRL	R1			;UNSUCCESSFUL, ASSUME NULL STRING
;
; IF PREVIOUS VALUE WAS AN INTEGER, CONVERT IT TO A STRING 
;
49$:	MOVAB	WRK_G_BUFFER+255(R10),WRK_L_EXPANDPTR(R10) ;RELOAD ADDRESS OF COMMAND BUFFER
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	CLRL	R6			;CLEAR STRING POSITION COUNT
	TSTL	R2			;BINARY VALUE?
	BNEQ	50$			;BRANCH IF NOT
	MOVL	R1,R0			;BINARY VALUE TO BE CONVERTED TO ASCII
	BSBW	DCL$CBTA_DEC		;PUT RESULT IN COMMAND BUFFER
;
; MOVE OLD STRING INTO BUFFER, UNTIL SUBSTRING POSITION IS REACHED
;
50$:	CMPL	R6,R8			;SUBSTRING POSITION REACHED?
	BEQL	70$			;IF EQL YES
	MOVZBL	#^A' ',R0		;ASSUME NO INPUT CHARACTERS LEFT
	TSTL	R1			;ANY MORE CHARACTERS IN INPUT STRING
	BEQL	60$			;IF EQL NO
	DECL	R1			;REDUCE NUMBER OF CHARACTERS REMAINING
	MOVZBL	(R2)+,R0		;GET NEXT CHARACTER FROM INPUT STRING
60$:	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN COMMAND BUFFER
	INCL	R6			;INCREMENT STRING POSITION
	BRB	50$			;
;
; SUBSTRING POSITION HAS BEEN FOUND, INSERT THE SUBSTRING
;
70$:	ADDL	R7,R8			;CALCULATE POSITION BEYOND SUBSTRING
	MOVQ	(SP)+,R3		;RETRIEVE SUBSTRING PARAMETERS
	ADDL	R7,R2			;CALCULATE ADDRESS OF NEXT CHARACTER
	SUBL	R7,R1			;REDUCE NUMBER OF CHARACTERS REMAINING
	BGEQ	80$			;IF GEQ MORE CHARACTERS IN INPUT STRING
	CLRL	R1			;CLEAR NUMBER OF CHARACTERS REMAINING
80$:	CMPL	R6,R8			;END OF SUBSTRING?
	BEQL	100$			;IF EQL YES
	MOVZBL	#^A/ /,R0		;ASSUME NO MORE CHARACTERS IN SUBSTRING
	TSTL	R3			;ANY MORE CHARACTERS IN SUBSTRING?
	BEQL	90$			;IF EQL NO
	DECL	R3			;REDUCE NUMBER OF CHARACTERS IN SUBSTRING
	MOVZBL	(R4)+,R0		;GET NEXT CHARACTER FROM SUBSTRING
90$:	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN COMMAND BUFFER
	INCL	R6			;INCREMENT STRING POSITION
	BRB	80$			;
;
; APPEND ANY OLD VALUE CHARACTERS THAT ARE LEFT TO THE END OF THE STRING
;
100$:	DECL	R1			;ANY MORE CHARACTERS IN INPUT STRING?
	BLSS	110$			;IF LSS NO
	MOVZBL	(R2)+,R0		;GET NEXT CHARACTER FROM INPUT STRING
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN COMMAND BUFFER
	BRB	100$			;
110$:	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF RESULTANT STRING
	MOVAB	DCL$ALLOCSYM,(SP)	;DON'T ALLOW ANY ABBREVIATION
;
; STORE FINAL VALUE INTO SYMBOL
;
; R1 = DESCRIPTOR OF SYMBOL VALUE
; (SP) = ROUTINE TO INSERT ENTRY INTO SYMBOL TABLE
; 4(SP) = DESCRIPTOR OF SYMBOL NAME
; 12(SP) = ADDRESS OF SYMBOL TABLE LISTHEAD
;
120$:	POPL	R6			;RETRIEVE SUBROUTINE ADDRESS
	POPR	#^M<R3,R4,R5>		;RETRIEVE SYMBOL PARAMETERS
	CMPB	R1,#255			;STRING TO LONG
	BLEQU	130$			;IF LEQU NO
	MOVZBL	#255,R1			;TRUNCATE TO MAXIMUM LENGTH
130$:	MOVL	#SYM_K_STRING,R0	;SET TYPE OF SYMBOL
	JSB	(R6)			;ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE
	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND EXECUTION IN PROGRESS
	BLBC	R0,140$			;IF LBC ERROR
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
140$:	RSB				;

	.SBTTL	LOCAL SUBROUTINES
;
; CHECKSYM - CHECK SYMBOL AND SAVE PARAMETERS
;
 
CHECKSYM:				;CHECK SYMBOL
	POPR	#^M<R4>			;REMOVE RETURN ADDRESS FROM STACK
	BSBW	DCL$CHKALPHA		;VERIFY IT IS VALID
	BLBC	R0,30$			;BR IF INVALID FIRST CHARACTER
	CMPL	R1,#255			;SYMBOL NAME TO LARGE
	BGTRU	30$			;IF GTRU YES
	MOVAB	PRC_Q_LOCAL(R11),R3	;ASSUME LOCAL SYMBOL TABLE
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/=/,R0		;ANOTHER EQUAL SIGN?
	BNEQ	20$			;IF NEQ NO
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	MOVAB	PRC_Q_GLOBAL(R11),R3	;SET FOR GLOBAL SYMBOL TABLE
20$:	PUSHR	#^M<R1,R2,R3>		;SAVE SYMBOL PARAMETERS
	DISABLE				;DISABLE CONTROL Y/C AST'S
	CLRQ	(SP)+			;REMOVE RETURN INFORMATION FROM STACK
	JMP	(R4)			;
 
;
; INVALID SYMBOL CHARACTER
;
 
30$:	STATUS	IVSYMB			;SET INVALID SYMBOL CHARACTER
	RSB				;

	.SBTTL	CHECK A CHARACTER FOR VALID ALPHA
;+
; DCL$CHKALPHA - CHECK A CHARACTER FOR VALID ALPHA
;
; THIS ROUTINE CHECKS THAT THE CHARACTER POINTED TO BY R2 IS VALID
; FIRST CHARACTER FOR A SYMBOL.
;
; INPUTS:
;
;	R2 = ADDRESS OF CHARACTER
;
; OUTPUT:
;
;	R0 LOW BIT CLEAR IS NOT ACCEPTABLE
;	R1 LOW BIT SET IS ACCEPATBLE CHARACTER
;-
 
DCL$CHKALPHA::				; CHAECK VALID ALPHA
	CLRL	R0			; ASSUME INVALID
	CMPB	(R2),#^A/$/		; NOW TRY FOR DOLLAR SIGN
	BEQL	10$			; BR IF THAT MATCHES
	CMPB	(R2),#^A/A/		; CHECK LOW LIMIT FOR ALPHA
	BLSSU	20$			; BR IF FAILED
	CMPB	(R2),#^A/Z/		; NOW CHECK HI LIMIT
	BLEQU	10$			; BR IF VALID CHARACTER
	CMPB	(R2),#^A/_/		; TRY PSEUDO ALPHA
	BNEQ	20$			; BR IF NOT VALID
10$:	INCL	R0			; SET SUCESSFUL STATUS
20$:	RSB				; RETURN WITH STATUS
 
	.END
