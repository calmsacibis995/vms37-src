	.TITLE	MESSAGE - MESSAGE OUTPUT ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; MESSAGE OUTPUT ROUTINES
;
; D. N. CUTLER 28-MAR-77
;
; MODIFIED BY:
;
;	V003	TMH0003		Tim Halvorsen	13-May-1981
;		Fix bounds check when assembling error text segment on stack
;		to prevent overwriting the stack.
;
;	V002	TMH0002		Tim Halvorsen	11-Feb-1981
;		Use WRK_L_MARKPTR rather than R6 as error segment
;		display pointer.
;		Avoid writing error segment line when we are at the
;		end of the line.
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Use R10 rather than FP as WRK address.
;
;	V001	TMH0001		Tim Halvorsen	08-Sep-1980
;		Convert to use MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$IODEF				;DEFINE I/O FUNCTION CODES
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS LONGWORD VALUES
	$SFDEF				;DEFINE CALL FRAME

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

	.SBTTL	OUTPUT ERROR MESSAGE
;+
; DCL$ERRORMSG - OUTPUT ERROR MESSAGE
;
; THIS ROUTINE IS CALLED TO OUTPUT AN ERROR MESSAGE AND DISPLAY THE SEGMENT
; OF THE COMMAND LINE THAT IS IN ERROR.
;
; INPUTS:
;
;	R0 = ERROR NUMBER.
;	WRK_L_MARKPTR = ADDRESS OF START OF TOKEN IN EXPANSION BUFFER.
;	WRK_L_EXPANDPTR = ADDRESS OF NEXT BYTE IN EXPANSION BUFFER.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE APPROPRIATE ERROR MESSAGE IS DISPLAYED ALONG WITH THE SEGMENT OF
;	THE COMMAND LINE IN ERROR.
;
;	R0 IS PRESERVED ACROSS CALL.
;-
 
DCL$ERRORMSG::				;OUTPUT ERROR MESSAGE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE REGISTERS
	MNEGL	R0,R1			;COMMAND INTERPRETER ERROR?
	BLEQ	10$			;IF LEQ NO
	MULL3	#4,R1,R0		;SHIFT MESSAGE NUMBER TO CORRECT PLACE
	BISL	#<CLI$_ABKEYW&<STS$M_FAC_NO!STS$M_FAC_SP>>,R0 ;INSERT FACNUM
10$:	BBS	#STS$V_INHIB_MSG,R0,60$ ;BR IF NO MESSAGE DESIRED
	PUSHL	#0			;CREATE PUTMSG VECTOR (FAO COUNT)
	PUSHL	R0			;SET STATUS CODE
	PUSHL	#2			;# ARGS ON PUTMSG VECTOR
	MOVL	SP,R0			;ADDRESS OF THE BUFFER DESCRIPTOR
	BSBB	DCL$PUTMSG		;SIGNAL PUTMSG VECTOR AT (R0)
	ADDL	#3*4,SP			;POP EVERYTHING UP TO BUFFER AND DESC.
;
;	OUTPUT OFFENDING TEXT IF ERROR IN COMMAND LINE
;
	BBS	#WRK_V_COMMAND,WRK_W_FLAGS(R10),60$ ;BR IF COMMAND IN EXECUTION
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF CURRENT PARSE STRING
	TSTB	(R2)			;DOES TOKEN START WITH EOL CHAR?
	BEQL	60$			;IF SO, ASSUME AT EOL AND SKIP TEXT
	TSTL	R1			;WILL ANY TOKEN BE SHOWN?
	BGTRU	15$			;IF SO, GO SHOW THE TOKEN
	MOVL	WRK_L_CHARPTR(R10),R0	;GET INPUT RECORD POINTER
	TSTB	1(R0)			;ARE WE ARE END OF LINE?
	BEQL	60$			;IF NO ERROR TOKEN AND EOL, SKIP IT
15$:	MOVAB	-WRK_C_MSGBUFSIZ(SP),SP	;ALLOCATE SPACE TO STORE MESSAGE
	MOVL	SP,R3			;AND SET POINTER TO BUFFER
	MOVW	#^A/  /,(R3)+		;PUT SEPARATOR IN BUFFER
	MOVB	#^A/\/,(R3)+		;AND DELIMIT THE BAD PART OF THE COMMAND
	MOVZWL	#WRK_C_MSGBUFSIZ-4,R0	;GET MAXIMUM SIZE OF ERROR SEGMENT
	CMPL	R1,R0			;ERROR SEGMENT BIGGER THAN BUFFER?
	BLSSU	17$			;BRANCH IF WITHIN BOUNDS
	MOVL	R0,R1			;TRUNCATE SEGMENT SIZE
17$:	MOVC	R1,(R2),(R3)		;WRITE ERROR SEGMENT TO BUFFER
	MOVB	#^A/\/,(R3)+		;SET TRAILING SEPARATOR
	MOVAB	WRK_C_MSGBUFSIZ-1(SP),R4 ;R4=ENDING ADDRESS IN BUFFER
	ADDL3	#1,WRK_L_CHARPTR(R10),R1 ;POINT AT NEXT BYTE IN INPUT
30$:	CMPL	R3,R4			;ANY ROOM FOR MORE DATA?
	BGTRU	40$			;BR IF NO MORE ROOM
	MOVB	(R1)+,(R3)+		;STORE A BYTE
	BNEQ	30$			;BR IF NOT END_OF_LINE
	DECL	R3			;BACK OVER EOL
40$:	MOVL	SP,R2			;START OF THE LINE BUFFER
	SUBL3	R2,R3,R1		;FIND LENGTH OF LINE
	BSBB	DCL$ERROUT		;OUTPUT ERROR MESSAGE
	MOVAB	WRK_C_MSGBUFSIZ(SP),SP	;CLEAR MESSAGE BUFFER FROM STACK
60$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	RSB				;

	.SBTTL	PUTMSG OUTPUT ROUTINE
;---
;
;	THIS ROUTINE OUTPUTS A GIVEN PUTMSG MESSAGE VECTOR
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R0 = ADDRESS OF PUTMSG VECTOR
;
; OUTPUTS:
;
;	NONE
;---
DCL$PUTMSG::
	DISABLE				; DISABLE CONTROL Y/C AST'S
	PUSHL	#^A'DCL '		; FACILITY NAME
	PUSHL	SP			; MAKE DESCRIPTOR OF NAME
	PUSHL	#3
	PUSHL	SP			; SET ADDRESS OF FACNAM
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,4(R0),-
		#<CLI$_ABKEYW&STS$M_FAC_NO>@-STS$V_FAC_NO
	BEQL	10$			; BRANCH IF OUR FACILITY
	CLRL	(SP)			; IF NOT OUR FACILITY, ZERO FACNAM PARAMETER
10$:	PUSHL	#0			; NO ACTION ROUTINE
	PUSHL	R0			; R0 = ADDRESS OF MESSAGE VECTOR
	CALLS	#6,G^SYS$PUTMSG		; WRITE THE MESSAGE TO SYS$ERROR,OUTPUT
	ENABLE				; RE-ENABLE CONTROL/Y AST'S
	BBC	#WRK_V_COMMAND,WRK_W_FLAGS(R10),90$ ; BRANCH IF NO IMAGE ACTIVE
	BSBW	DCL$CHECK_AST		; CHECK FOR PENDING AST
90$:	RSB

	.SBTTL	ERROR FILE MESSAGE OUTPUT
;+
; DCL$ERROUT - ERROR FILE MESSAGE OUTPUT
;
; THIS ROUTINE IS CALLED TO OUTPUT A MESSAGE TO THE ERROR FILE.
;
; INPUTS:
;
;	R1 = LENGTH OF MESSAGE.
;	R2 = ADDRESS OF MESSAGE.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE MESSAGE IS WRITTEN TO THE ERROR FILE AND CONTROL IS RETURNED
;	TO THE CALLER.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
DCL$ERROUT::				;ERROR CHANNEL MESSAGE OUTPUT
	MOVL	PRC_L_ERRRAB(R11),R0	;SET ADDRESS OF ERROR FILE RAB
	PUSHR	#^M<R1,R2>		;SAVE MESSAGE PARAMETERS
	BSBB	20$			;OUTPUT ERROR MESSAGE
	POPR	#^M<R1,R2>		;RESTORE MESSAGE PARAMETERS
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),30$ ;BR IF AT CONTROL Y LEVEL
	CMPL	PRC_L_ERRRAB(R11),-	;CHECK IF ERROR AND OUTPUT ARE
		PRC_L_INDOUTRAB(R11)	;THE SAME FILE (OR DEVICE).
	BEQL	30$			;IF EQL YES, DON'T REPRINT MESSAGE
					;ELSE JOIN MESSAGE OUTPUT

	.SBTTL	OUTPUT FILE MESSAGE OUTPUT
;+
; DCL$MSGOUT - OUTPUT FILE MESSAGE OUTPUT
;
; THSI ROUTINE IS CALLED TO OUTPUT A MESSAGE TO THE OUTPUT FILE.
;
; INPUTS:
;
;	R1 = LENGTH OF MESSAGE.
;	R2 = ADDRESS OF MESSAGE.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE MESSAGE IS WRITTEN TO THE OUTPUT FILE AND CONTROL IS RETURNED
;	TO THE CALLER.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
DCL$MSGOUT::				;MESSAGE OUTPUT
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET ADDRESS OF INDIRECT OUTPUT RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;BR IF NOT IN CONTROL Y
	MOVL	PRC_L_OUTRAB(R11),R0	;SET ADDRESS OF OUTPUT FILE RAB
20$:	DISABLE				;DISABLE CONTROL Y/C AST'S
	MOVW	R1,RAB$W_RSZ(R0)	;SET SIZE OF OUTPUT RECORD
	MOVL	R2,RAB$L_RBF(R0)	;SET ADDRESS OF OUTPUT RECORD
	$PUT	RAB=(R0)		;OUTPUT RECORD
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BBC	#WRK_V_COMMAND,WRK_W_FLAGS(R10),30$ ;IF CLR, NO COMMAND EXECUTION
	BSBW	DCL$CHECK_AST		;CHECK FOR PENDING AST
30$:	RSB				;
	.DSABL	LSB
 
	.END
