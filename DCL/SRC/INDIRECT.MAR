	.TITLE	INDIRECT - INDIRECT FILE MANIPULATION ROUTINES
	.IDENT	'V03-017'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 2-MAY-77
;
; INDIRECT FILE MANIPULATION ROUTINES
;
; MODIFIED BY:
;
;	V017	PCG0003		Peter George	16-Mar-1982
;		Signal @<filespec>/OUTPUT syntax errors only
;		once.
;
;	V016	PCG0002		Peter George	25-Feb-1982
;		Add a leading underscore to concealed device
;		names returned in the NAM$T_DVI field.
;
;	V015	PCG0001		Peter George	28-Jan-1982
;		Call DCL$SET_STATUS after encountering an
;		unsatisfied goto.
;
;	V014	TMH0014		Tim Halvorsen	02-Jan-1982
;		Fix optimization which closes two indirect levels
;		at a time if the caller is at EOF, so that the local
;		symbols and labels are deallocated.
;
;	V013	TMH0013		Tim Halvorsen	30-Nov-1981
;		Add code to initialize F$SEARCH context list when
;		creating a new indirect frame, and code to cleanup
;		list when unstacking an indirect frame.
;
;	V012	TMH0012		Tim Halvorsen	12-Oct-1981
;		Fix off-by-one error in indirect stack limit checking.
;
;	V011	TMH0011		Tim Halvorsen	02-Sep-1981
;		Clear SHR field in FAB before re-using the general
;		purpose FAB to pop an indirect level.
;
;	V010	TMH0010		Tim Halvorsen	10-Aug-1981
;		Fix optimization which closes two indirect levels
;		at a time if the caller is at EOF, so that the output
;		file is closed.
;
;	V009	TMH0009		Tim Halvorsen	09-Aug-1981
;		Only perform TMH0008 if sys$input points to a random access
;		device (i.e. not a terminal).
;
;	V008	TMH0008		Tim Halvorsen	23-Jul-1981
;		Get the current record position of the SYS$INPUT stream
;		just before closing the procedure file when moving to a
;		deeper indirect level.  This is done because an indirect
;		accessor of SYS$INPUT (a program) may have advanced the
;		current record position since the last time we did a $GET.
;
;	V007	TMH0007		Tim Halvorsen	13-Jun-1981
;		Re-initialize SHR field of FAB before using it
;		to open a procedure file.
;
;	V006	TMH0006		Tim Halvorsen	13-May-1981
;		Save WRK_L_MARKPTR over STACKIND routine, and ensure
;		that it is relocated on stack shifts.
;
;	V005	TMH0005		Tim Halvorsen	27-Apr-1981
;		Change stack & unstack to clock (increment) the cell
;		PRC_L_INDCLOCK so that COMMAND can determine if we
;		have entered or exited a procedure during a GETCHAR call.
;		Make use of cell PRC_L_INDEPTH to determine if level 0 or not.
;
;	V004	TMH0004		Tim Halvorsen	10-Apr-1981
;		Break into several routines so that DCL initialization
;		can stack procedures using these subroutines.
;
;	V003	TMH0003		Tim Halvorsen	20-Mar-1981
;		Fix scanning of P1 to include the case when a space
;		delimiter after the filespec was thrown away as insignificant.
;		Pass value context into PROCFILE.
;
;	V002	TMH0002		Tim Halvorsen	11-Feb-1981
;		Use DCL$MARK rather than R6 as a display parameter.
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Remove all references to R10.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARKEDTOKEN routine.
;		Define procedure parameters as string type.
;		Make use of DCL$COMPRESS routine.
;
;	V001	TMH0001		Tim Halvorsen	26-Aug-1980
;		Use WRK_L_RSLNXT rather than R10 as token descriptor pointer.
;		Convert to MDL structures.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	IDFDEF				;DEFINE INDIRECT FRAME OFFSETS
	PRDDEF				;PROCESS RMS DATA
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$FABDEF				;DEFINE FAB OFFSETS
	$RABDEF				;DEFINE RAB OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$NAMDEF				;DEFINE NAM OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
 
;
; LOCAL SYMBOLS
;
 
SYMBOLS=8				;MAXIMUM NUMBER OF INDIRECT FILE SYMBOLS
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
INPFILE:				;INPUT FILE DEFAULT NAME STRING
	.ASCII	/.COM/			;
INPUTNAM:				;'INPUT' LOGICAL NAME TEXT
	.ASCII	<9>/SYS$INPUT/		;
OUTFILE:				;OUTPUT FILE DEFAULT NAME STRING
	.ASCII	/.LIS/			;
OUTPUTNAM:				;'OUTPUT' LOGICAL NAME TEXT
	.ASCII	<10>/SYS$/		;
OUTQUAL:.ASCII	/OUTPUT/		; REST OF NAME AND THE QUALIFIER

	.SBTTL	STACK INDIRECT FILE
;+
; DCL$STACKIND - STACK INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO STACK THE CURRENT INDIRECT FILE LEVEL AND TO PARSE
; AND OPEN THE NEXT INDIRECT FILE.
;
; INPUTS:
;
;	IT IS ASSUMED THAT THE INDIRECT FILE PROCESSING FLAG IS SET.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE SPECIFICATION IS SAVED ON THE INDIRECT FILE
;	STACK AND THE NEXT INDIRECT FILE IS PROCESSED.
;
;	R0 LOW BIT CLEAR INDICATES INDIRECT FILE PROCESSING FAILURE.
;
;		R0 = DCL$_ATLAST - INDIRECT FILE SPECIFICATION NOT LAST ITEM ON
;			COMMAND LINE.
;		R0 = DCL$_DEFOVF - ATTEMPT TO DEFINE MORE THAN EIGHT PARAMETERS.
;		R0 = DCL$_STKOVF - INDIRECT FILE INTERNAL STACK OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = DCL$_NORMAL - NORMAL COMPLETION.
;-
 
DCL$STACKIND::				;STACK INDIRECT FILE
	BSBW	SETIND			;SET INDIRECT PROCESSING UP
	MOVAB	-<<SYMBOLS+1>*8>(SP),SP ;ALLOCATE SPACE FOR SYMBOL DESCRIPTORS
	CLRL	-(SP)			;CLEAR COUNT OF GENERATED SYMBOLS
	DECL	WRK_L_CHARPTR(R10)	;BACK UP TO AT SIGN
10$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	MOVZBL	#PTR_K_PARAMETR,R3	;SET TOKEN CONTEXT FOR FILESPEC
	BSBW	DCL$PROCFILE		;PROCESS FILE SPECIFICATION
	BLBC	R0,15$			;IF LBC PARSE FAILURE
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;SLASH?
	BNEQ	20$			;IF NEQ NO
	BSBW	DCL$MOVTOKN		;MOVE TERMINATOR AND GET NEXT TOKEN
	CMPL	R1,#4			;MORE THAN MAX MATCH NAME
	BLSS	13$			;BR IF NO
	MOVL	#4,R1			;ONLY CHECK FOR 4 CHARS
13$:	PUSHL	R0			;SAVE TERMINATION CHARACTER
	CMPC	R1,(R2),OUTQUAL		;CHECK FOR VALID QUAL
	BEQL	14$			;BR IF OK
	POPL	R0			;RESTORE TERMINATION CHARACTER
	STATUS	IVKEYW			;SET ILLEGAL QUALIFIER CODE
	BRB	15$			;
14$:	POPL	R0			;RESTORE TERMINATION CHARACTER
	CMPB	#^A/=/,R0		;EQUAL SIGN TERMINATOR?
	BEQL	10$			;IF EQL YES
	CMPB	#^A/:/,R0		;COLON TERMINATOR?
	BEQL	10$			;IF EQL YES
	STATUS	IVVALU			;SET INVALID VALUE SYNTAX
15$:	BRW	80$			;
 
;
; FILE SPECIFICATIONS PARSED - PARSE SYMBOL DEFINITIONS
;
; IF THE FILESPEC WAS FOLLOWED BY A SPACE, THAT SPACE MAY HAVE BEEN THROWN
; AWAY IF THE FIRST CHARACTER IN P1 MAKES IT INSIGNIFICANT.
;
 
20$:	MOVAB	4(SP),R8		;GET ADDRESS OF SYMBOL DESCRIPTOR STORAGE
	BSBW	DCL$SETNBLK		;IGNORE BLANKS AFTER FILESPEC
30$:	BSBW	DCL$MARK		;MARK POSITION OF FIRST NON-BLANK
40$:	BSBW	DCL$MOVCHAR		;COPY A CHARACTER FROM INPUT BUUFER
	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(R10),40$ ;LOOP IF IN A QUOTED STRING
	BEQL	45$			;BR IF END OF LINE
	CMPB	#^A' ',R0		;IS THIS A TERMINATOR
	BNEQ	40$			;BR IF NO - KEEP LOOKING FOR TERMINATOR
45$:	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF PARAMETER
	DECL	R1			;REMOVE COUNT FOR TERMINATOR
	BEQL	60$			;IF NULL STRING - NO MORE SYMBOLS
	CMPB	#^A/"/,(R2)		;SYMBOL START WITH A QUOTE
	BNEQ	50$			;IF NO - LEAVE THE SYMBOL ALONE
	BSBW	DCL$COMPRESS		;ELSE REMOVE THE QUOTE PAIRS
50$:	MOVQ	R1,(R8)+		;STORE SYMBOL DESCRIPTOR
	AOBLEQ	#SYMBOLS,(SP),30$	;ANY MORE SYMBOL DEFINITIONS ALLOWED?
	STATUS	DEFOVF			;SET SYMBOL DEFINITION OVERFLOW
	BRB	80$			;
 
;
; RUN DOWN ANY IMAGE CURRENTLY RUNNING
;
 
60$:	PUSHL	WRK_L_RSLNXT(R10)	;SAVE POINTER INTO WRK AREA
	BSBW	DCL$RUNDOWN		;RUN DOWN IMAGE AND INDIRECT LEVELS
	SUBL3	(SP)+,WRK_L_RSLNXT(R10),R0 ;CALCULATE LENGTH OF STACK SHIFT
	ADDL	R0,<<<SYMBOLS+1>*8>+4+<9*4>>(SP) ;RELOCATE SAVED WRK_L_RSLNXT
	ADDL	R0,<<<SYMBOLS+1>*8>+4+<10*4>>(SP) ;RELOCATE SAVED WRK_L_RSLEND
	ADDL	R0,<<<SYMBOLS+1>*8>+4+<11*4>>(SP) ;RELOCATE SAVED WRK_L_EXPANDPTR
	ADDL	R0,<<<SYMBOLS+1>*8>+4+<12*4>>(SP) ;RELOCATE SAVED WRK_L_MARKPTR

;
; STACK COMMAND PROCEDURE
;

	MOVL	<<<SYMBOLS+1>*8>+4+<9*4>>(SP),WRK_L_RSLNXT(R10) ;RETRIEVE ADDRESS OF DESCRIPTORS
	BSBW	DCL$GETDVAL		;GET INPUT FILE DESCRIPTOR VALUES
	MOVQ	R1,-(SP)		;SAVE INPUT FILESPEC
	CLRL	R4			;ASSUME NO OUTPUT FILESPEC
	BSBW	DCL$GETDVAL		;GET OUTPUT FILESPEC
	BLBC	R0,65$			;IF NONE, PASS IN NULL FILESPEC
	MOVQ	R1,R4			;SET OUTPUT FILESPEC ARGUMENT
65$:	MOVQ	(SP)+,R2		;SET INPUT FILESPEC ARGUMENT
	CLRL	R1			;SIGNAL ALL RMS ERRORS
	BSBW	DCL$PUSHPROC		;PUSH PROCEDURE ONTO INDIRECT STACK
	BLBC	R0,80$			;BRANCH IF ERROR DETECTED
;
; CREATE SYMBOLS P1-P8
;
	MOVAB	(SP),R8			;GET ADDRESS OF NUMBER OF SYMBOL DEFINITIONS
	MOVL	(R8),R6			;GET NUMBER OF SYMBOL DEFINITIONS
	MOVZWL	#^A/P0/,(R8)+		;SET GENERATED SYMBOL PROTOTYPE
	MOVL	#SYMBOLS,R7		;NUMBER OF SYMBOLS TO GENERATE
70$:	CLRL	R1			;ASSUME NO MORE SYMBOLS DEFINED
	DECL	R6			;IS THERE ANY MORE TO DEFINE
	BLSS	75$			;BR IF NO - DEFINE AS NULL STRING
	MOVQ	(R8)+,R1		;GET VALUE DESCRIPTOR
75$:	INCB	1(SP)			;INCREMENT SYMBOL NUMBER
	MOVL	#2,R3			;SET LENGTH OF SYMBOL NAME
	MOVAB	(SP),R4			;SET ADDRESS OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;GET ADDRESS OF LOCAL SYMBOL TABLE LISTHEAD
	MOVL	#SYM_K_STRING,R0	;SET SYMBOL TYPE IS STRING
	BSBW	DCL$ALLOCSYM		;ALLOCATE AND INSERT SYMBOL TABLE ENTRY
	BLBC	R0,80$			;IF LBC ALLOCATION FAILURE
	SOBGTR	R7,70$			;ANY MORE SYMBOL TO PROCESS?
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	BRB	INDXIT

80$:
INDXIT:	MOVAB	<<SYMBOLS+1>*8>+4(SP),SP ;DEALLOCATE SYMBOL DESCRIPTOR STORAGE
	PUSHL	R0			;SAVE FINAL STATUS
	BRW	STKXIT			;

	.SBTTL	PUSH PROCEDURE ONTO INDIRECT STACK
;+
; DCL$PUSHPROC - PUSH PROCEDURE ONTO INDIRECT STACK
;
; THIS ROUTINE IS CALLED TO INITIALIZE A NEW INDIRECT FRAME
; ON THE INDIRECT PROCEDURE STACK.
;
; INPUTS:
;
;	R1 = 1 IF RMS ERRORS SHOULD NOT BE SIGNALED, ELSE 0
;	R2/R3 = DESCRIPTOR OF INPUT FILESPEC
;	R4/R5 = DESCRIPTOR OF OUTPUT FILESPEC
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0 = STATUS (NOT SIGNALED)
;-

DCL$PUSHPROC::
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,AP>
	MOVL	PRC_L_STACKPT(R11),R6	;GET CURRENT INDIRECT STACK POINTER
	MOVAB	-IDF_K_LENGTH(R6),R8	;CALCULATE NEW INDIRECT STACK POINTER
	CMPL	R8,PRC_L_STACKLM(R11)	;INDIRECT STACK OVERFLOW?
	BGEQU	2$			;BRANCH IF OK
	STATUS	STKOVF			;SET INDIRECT STACK OVERFLOW
80$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,AP>
	RSB
 
;
; THE NEW INDIRECT FILE FRAME IS FORMED ON THE STACK AND LINKED TO ANY
; PREVIOUS FRAMES.  THE STACK OVERFLOW CHECK HAS BEENY PERFORMED AT THIS POINT
;

2$:	INCL	PRC_L_INDEPTH(R11)	; SET NEW INSTACK STACK DEPTH
	INCL	PRC_L_INDCLOCK(R11)	; INCREMENT TOTAL STACKS OR UNSTACKS
	MOVL	R8,PRC_L_STACKPT(R11)	; ALLOCATE NEW STACK FRAME
	MOVL	PRC_L_IDFLNK(R11),R6	; GET ADDRESS OF CURRENT INDIRECT FRAME
	MOVL	R6,IDF_L_LNK(R8)	; LINK NEW FRAME INTO TOP OF
	MOVAL	IDF_L_LNK(R8), -	; INDIRECT FILE FRAME LIST
		PRC_L_IDFLNK(R11)
;
; R6 = Pointer to current stack frame
; R8 = Pointer to new stack frame
;
	MOVL	PRC_L_INDFAB(R11),AP	;GET ADDRESS OF INDIRECT FAB
	MOVQ	PRC_Q_LOCAL(R11),IDF_Q_LOCAL(R6) ;SAVE LOCAL SYMBOL TABLE LISTHEAD
	MOVQ	PRC_Q_LABEL(R11),IDF_Q_LABEL(R6) ;SAVE LABEL SYMBOL TABLE LISTHEAD
	MOVW	PRC_W_ONLEVEL(R11),IDF_W_ONLEVEL(R6) ;SAVE ON ERROR LEVEL NUMBER
	MOVL	PRC_L_ONERROR(R11),IDF_L_ONERROR(R6) ;SAVE ON ERROR COMMAND TEXT
	MOVAB	PRC_Q_LABEL(R11),R0	;GET ADDRESS OF LABEL TABLE LISTHEAD
	MOVL	R0,(R0)			;SET ADDRESS OF LISTHEAD AS FORWARD LINK
	MOVL	(R0)+,(R0)+		;SET ADDRESS OF LISTHEAD AS BACKWARD LINK
	MOVL	R0,(R0)			;SET ADDRESS OF LISTHEAD AS FORWARD LINK
	MOVL	(R0)+,(R0)+		;SET ADDRESS OF LISTHEAD AS BACKWARD LINK
	CLRL	PRC_L_ONERROR(R11)	;CLEAR ADDRESS OF ON ERROR COMMAND TEXT
	MOVW	#2,PRC_W_ONLEVEL(R11)	;RESET ON ERROR LEVEL TO ERROR
	MOVL	PRC_L_ONCTLY(R11),IDF_L_ONCTLY(R6) ;SAVE ON CONTROL Y COMMAND
	BEQL	5$			;BR IF THERE WAS NONE
	MOVAB	W^DCL$T_DEFONTXT,PRC_L_ONCTLY(R11) ;SET DEFUALT FOR NEXT LEVEL
5$:	MOVW	#1@IDF_V_INPOPN,IDF_W_FLAG(R8) ;SET INPUT FILE OPEN FLAG
	CLRL	IDF_L_SEARCHCTX(R8)	;INITIALIZE F$SEARCH CONTEXT LIST
;
; PROPAGATE THE OUTPUT STREAM TO THE NEW INDIRECT FRAME, SO THAT IN CASE
; NO OUTPUT FILESPEC IS SPECIFIED FOR THE NEW PROCEDURE, THE SAME OUTPUT
; FILE IS USED.
;
	ASSUME	IDF_W_OUTISI EQ IDF_W_OUTIFI+2
	MOVL	IDF_W_OUTIFI(R6),IDF_W_OUTIFI(R8) ;SAVE PREVIOUS INTERNAL FILE INDEX
	MOVL	IDF_L_OUTRABCTX(R6),IDF_L_OUTRABCTX(R8) ;SAME FOR RAB CONTEXT
	MOVC	#16,IDF_T_OUTDVI(R6),IDF_T_OUTDVI(R8) ;SAVE PREVIOUS DEVICE NAME
;
; CLOSE INPUT FILE FROM PREVIOUS INDIRECT LEVEL AND REMEMBER THE CURRENT
; POSITION IN THE FILE, SO THAT ON RETURN, WE CAN RESET THE POSITION.
;
	MOVL	PRC_L_INDINPRAB(R11),R2	;SET CURRENT INDIRECT RAB POINTER
	CMPL	R2,PRC_L_INPRAB(R11)	;IS THIS THE PRIMARY INPUT STREAM?
	BEQL	7$			;BR IF YES-THAT NEVER GETS CLOSED
	BBC	#DEV$V_RND,RAB$L_CTX(R2),6$ ;SKIP IF NOT A DISK FILE
	MNEGW	#1,IDF_W_INPRFA(R6)	;ASSUME END OF FILE
	$FIND	RAB=(R2)		;GET THE CURRENT RECORD POSITION (IT
	CMPW	R0,#RMS$_EOF&^XFFFF	;MAY HAVE BEEN ADVANCED BY AN INDIRECT
	BEQL	6$			;ACCESSOR SINCE OUR LAST $GET).
	MOVL	RAB$W_RFA(R2),IDF_W_INPRFA(R6) ;SAVE RECORD POSITION IN FILE
	MOVW	RAB$W_RFA+4(R2),IDF_W_INPRFA+4(R6)
6$:	MOVW	IDF_W_INPIFI(R6),FAB$W_IFI(AP) ;SET INTERNAL FILE IDENTIFICATION
	$CLOSE	FAB=(AP)		;
;
; OPEN INPUT PROCEDURE FILE
;
7$:	CLRW	IDF_W_INPIFI(R8)	;CLEAR INPUT FILE INTERNAL INDEX
	MOVQ	4(SP),R1		;GET INPUT FILESPEC (R2/R3 ON ENTRY)
	MOVB	R1,FAB$B_FNS(AP)	;SET SIZE OF FILE NAME STRING
	MOVL	R2,FAB$L_FNA(AP)	;SET ADDRESS OF FILE NAME STRING
	MOVB	#4,FAB$B_DNS(AP)	;SET SIZE OF DEFAULT NAME STRING
	MOVAB	INPFILE,FAB$L_DNA(AP)	;SET ADDRESS OF DEFAULT NAME STRING
	MOVB	#FAB$M_GET,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVL	#FAB$M_INP!FAB$M_PPF!FAB$M_SQO,- ;SET FILE OPEN OPTIONS
		FAB$L_FOP(AP)
	CLRB	FAB$B_SHR(AP)		;CLEAR FILE SHARING OPTIONS
	CLRW	FAB$W_IFI(AP)		;CLEAR INTERNAL FILE INDEX
	MOVL	AP,R0			;ADDRESS OF FAB
	CLRL	R1			;ASSUME OPEN WITH ERROR REPORTING
	BLBC	(SP),8$			;IF ERROR REPORTING DISABLED,
	MOVL	#2,R1			;DO OPEN WITHOUT ERROR REPORTING
8$:	BSBW	DCL$OPEN_CREATE		;OPEN INDIRECT INPUT FILE
	BLBC	R0,9$			;IF LBC OPEN FAILURE
	MOVL	FAB$L_NAM(AP),R7	;GET ADDRESS OF INDIRECT NAME BLOCK
	MOVW	FAB$W_IFI(AP),IDF_W_INPIFI(R8) ;SAVE INPUT FILE INTERNAL INDEX
	MOVAB	PRD_G_ALTINPRAB(AP),R6	;GET ALTERNATE INPUT RAB
	MOVL	FAB$L_DEV(AP),RAB$L_CTX(R6) ;SAVE DEVICE CHARACTERISTICS
	MOVL	RAB$L_CTX(R6),IDF_L_INPRABCTX(R8) ;AND A COPY IN THE STACK FRAME
	BBC	#NAM$V_CNCL_DEV,-	;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),15$
	MOVZBL	NAM$T_DVI(R7),R0	;GET LENGTH OF DEVICE NAME
	CMPB	R0,#<NAM$C_DVI-2>	;IS THERE ROOM FOR EXTRA "_"?
	BGTRU	15$			;IF GTRU, THEN NO	
	MOVC	R0,NAM$T_DVI+1(R7),-	;SHIFT STRING OVER ONE CHARACTER
		NAM$T_DVI+2(R7)
	INCB	NAM$T_DVI(R7)		;INCREMENT THE LENGTH
15$:	MOVC	#28,NAM$T_DVI(R7),-	;COPY DEVICE,FILE AND DIRECTORY ID'S
		IDF_T_INPDVI(R8)	;INTO INDIRECT STACK FRAME
	MOVL	AP,RAB$L_FAB(R6)	;LINK FAB TO RAB
	$CONNECT RAB=(R6)		;CONNECT TO NEW INPUT
9$:	BLBC	R0,10$			;IF LBC CONNECT FAILURE
	CLRBIT	RAB$M_PPF_IND,RAB$W_ISI(R6) ;MAKE SURE INDIRECT FLAG IS CLEAR
	MOVL	R6,PRC_L_INDINPRAB(R11)	;SET INDIRECT INPUT RAB
;
; CREATE OUTPUT FILE, IF SPECIFIED
;
	MOVQ	12(SP),R1		;GET OUTPUT FILESPEC (R4/R5 ON ENTRY)
	TSTL	R1			;OUTPUT FILE SPECIFIED?
	BNEQ	3$			;BRANCH IF SO
	BRW	20$			;SKIP IF NOT
3$:	MOVAB	OUTFILE,FAB$L_DNA(AP)	;SET ADDRESS OF DEFAULT NAME STRING
	MOVB	#FAB$M_PUT,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVB	R1,FAB$B_FNS(AP)	;SET SIZE OF FILENAME STRING
	MOVL	R2,FAB$L_FNA(AP)	;SET ADDRESS OF FILE NAME STRING
	MOVL	#FAB$M_PPF!FAB$M_SQO,FAB$L_FOP(AP) ;SET FILE OPEN OPTIONS
	MOVB	#FAB$C_SEQ,FAB$B_ORG(AP) ;SET FILE ORGANIZATION TYPE
	MOVB	#FAB$M_PRN,FAB$B_RAT(AP) ;SET RECORD ATTRIBUTE TYPE TO PRINT
	MOVB	#FAB$C_VFC,FAB$B_RFM(AP) ;SET RECORD FORMAT TYPE-FIXED CONTROL
	CLRW	FAB$W_IFI(AP)		;CLEAR INTERNAL FILE INDEX
	MOVL	AP,R0			;ADDRESS OF FAB
	MOVL	#1,R1			;ASSUME CREATE WITH ERROR REPORTING
	BLBC	(SP),4$			;IF ERROR REPORTING DISABLED,
	MOVL	#3,R1			;DO CREATE WITHOUT ERROR REPORTING
4$:	BSBW	DCL$OPEN_CREATE		;CREATE NEW OUTPUT FILE
	BLBC	R0,10$			;IF LBC CREATION FAILURE
	MOVW	FAB$W_IFI(AP),IDF_W_OUTIFI(R8) ;SAVE OUTPUT FILE INTERNAL INDEX
	MOVAB	PRD_G_ALTOUTRAB(AP),R2	;GET ALTERNATE OUTPUT RAB ADDRESS
	MOVL	FAB$L_DEV(AP),RAB$L_CTX(R2) ;SAVE DEVICE CHARACTERISTICS HERE
	MOVL	RAB$L_CTX(R2),IDF_L_OUTRABCTX(R8) ;AND HERE AS WELL
	MOVAB	(R2),PRC_L_INDOUTRAB(R11) ;SET ADDRESS OF OUTPUT RAB
	CLRW	RAB$W_ISI(R2) 		;CLEAR INTERNAL STREAM INDEX
	MOVL	AP,RAB$L_FAB(R2)	;LINK FAB TO RAB
	$CONNECT RAB=(R2)		;CONNECT TO OUTPUT
10$:	BLBC	R0,50$			;IF LBS CONNECT FAILURE
	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,- ;SET TO USE IMPLIED
		#RAB$S_PPF_RAT,RAB$W_ISI(R2) ;CR/LF FOR OUTPUT
	MOVW	RAB$W_ISI(R2),IDF_W_OUTISI(R8) ;COPY OUTPUT ISI TO STACK FRAME
	BBC	#NAM$V_CNCL_DEV,-	;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),18$
	MOVZBL	NAM$T_DVI(R7),R0	;GET LENGTH OF DEVICE NAME
	CMPB	R0,#<NAM$C_DVI-2>	;IS THERE ROOM FOR EXTRA "_"?
	BGTRU	18$			;IF GTRU, THEN NO	
	MOVC	R0,NAM$T_DVI+1(R7),-	;SHIFT STRING OVER ONE CHARACTER
		NAM$T_DVI+2(R7)
	INCB	NAM$T_DVI(R7)		;INCREMENT THE LENGTH
18$:	MOVC	#16,NAM$T_DVI(R7),IDF_T_OUTDVI(R8) ;SAVE DEVICE IDENTIFICATION
20$:	BSBW	CREATE			;CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
	STATUS	NORMAL
	BRW	80$			;EXIT WITH SUCCESS
 
;
; OPEN, CONNECT, OR SYMBOL ALLOCATION FAILURE
;
 
50$:	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	BSBB	UNSTACK			;UNSTACK PREVIOUS INDIRECT FILE
	POPR	#^M<R0>			;RETRIEVE ERROR/STATUS VALUE
	BRW	80$			;EXIT WITH STATUS

	.SBTTL	UNSTACK INDIRECT FILE SPECIFICATION
;+
; DCL$UNSTACK - UNSTACK INDIRECT FILE SPECIFICATION
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT INDIRECT FILE AND TO UNSTACK THE
; PREVIOUS SPECIFICATION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE IS CLOSED AND ALL LOCAL SYMBOLS FOR THE LEVEL
;	ARE DEALLOCATED. THE PREVIOUS INDIRECT FILE IS THEN UNSTACKED AND REOPENED.
;
;	R0 LOW BIT CLEAR INDICATES UNSUCCESSFUL COMPLETION.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;	ALL ERRORS ARE SIGNALED BEFORE RETURNING TO CALLER.
;-
 
DCL$UNSTACK::				;UNSTACK INDIRECT FILE SPECIFICATION
	$DELLOG_S	TBLFLG=#LOG$C_PROCESS,- ;DELETE ANY USER DEFINED
			ACMODE=#PSL$C_USER	;LOGICAL NAMES.
	BSBB	SETIND			;SETUP INDIRECT PROCESSING
	PUSHL	S^#SS$_NORMAL		;ASSUME NORMAL COMPLETION
	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),10$ ;IF CLR, NO GOTO IN PROGRESS
	BSBW	DCL$DEALGOTO		;DEALLOCATE THE SPACE
	STATUS	USGOTO			;SET UNSATISFIED GOTO STATUS
	MOVL	R0,(SP)			;SET COMPLETION STATUS
	ERRMSG				;OUTPUT ERROR MESSAGE
	BSBW	DCL$SET_STATUS		;GIVE ERROR HANDLER'S A CHANCE
10$:	BSBB	UNSTACK			;UNSTACK TO PREVIOUS LEVEL
	MOVAB	WRK_G_INPBUF-1(R10),-	;SET STARTING ADDRESS OF INPUT
		WRK_L_CHARPTR(R10)	;BUFFER AS LAST BYTE FETCHED
	CLRB	WRK_G_INPBUF(R10)	;SET EOL AS NEXT BYTE TO FETCH
STKXIT:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,AP> ;RESTORE REGISTERS
					; R0=STATUS, R1=ORIGINAL FLAGS
	POPL	WRK_L_RSLNXT(R10)	;RESTORE TOKEN DESCRIPTORS BACK TO
	POPL	WRK_L_RSLEND(R10)	;WHERE THEY WERE WHEN WE STARTED
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	POPL	WRK_L_MARKPTR(R10)	;RESTORE MARKER POINTER
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BBS	#WRK_V_COMMAND,R1,10$	;BR IF COMMAND WAS SET
	BICW	#WRK_M_COMMAND,WRK_W_FLAGS(R10) ;CLEAR COMMAND IN PROGRESS
10$:	RSB				;
 
;
; SETIND - SETUP INDIRECT
;
; SAVE THE NON-VOLATILE REGISTERS AND THE COMMAND WORK FLAGS, THEN SET COMMAND
;
 
SETIND:	POPR	#^M<R0>			;GET RETURN PC
	DISABLE				;DISABLE CONTROL Y/C AST'S
	PUSHL	WRK_L_MARKPTR(R10)	;SAVE CURRENT MARKER POINTER
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE CURRENT EXPANSION BUFFER POINTER
	PUSHL	WRK_L_RSLEND(R10)	;SAVE CURRENT ENDING TOKEN ADDRESS
	PUSHL	WRK_L_RSLNXT(R10)	;SAVE CURRENT POSITION IN TOKEN ARRAY
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,AP> ;SAVE REGISTERS
	PUSHL	WRK_W_FLAGS(R10)	;SAVE PREVIOUS COMMAND FLAGS
	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND IN PROGRESS
	JMP	(R0)			;RETURN TO CALLER

	.SBTTL	UNSTACK NEXT INDIRECT FILE
;---
;
; UNSTACK - UNSTACK NEXT INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT INDIRECT FILE AND UNSTACK THE
; CONTEXT INFORMATION FOR THE PREVIOUS LEVEL INDIRECT FILE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	NONE
;
;	R0-R8,AP ARE DESTROYED.
;---
 
UNSTACK:				;UNSTACK INDIRECT FILE
	MOVL	PRC_L_INDFAB(R11),AP	;GET ADDRESS OF SCRATCH FAB
	MOVL	PRC_L_IDFLNK(R11),R8	; GET ADDRESS OF CURRENT INDIRECT FRAME
;
; CLOSE CURRENT INPUT PROCEDURE FILE
;
	MOVW	IDF_W_INPIFI(R8),FAB$W_IFI(AP) ;RESTORE INTERNAL FILE INDEX
	$CLOSE	FAB=(AP)		;CLOSE INDIRECT INPUT FILE
;
; CLOSE CURRENT OUTPUT FILE IF THE CURRENT OUTPUT FILE IS DIFFERENT
; FROM THE PREVIOUS LEVEL.
;
5$:	CMPW	IDF_W_OUTIFI(R8),-	;SEE IF THE OUTPUT FILE CHANGED
		IDF_W_OUTIFI+IDF_K_LENGTH(R8) ;FROM PREVIOUS COMMAND LEVEL
	BEQL	10$			;BR IF NO
	MOVW	IDF_W_OUTIFI(R8),FAB$W_IFI(AP) ;RESTORE INTERNAL FILE INDEX
	$CLOSE	FAB=(AP)		;CLOSE INDIRECT OUTPUT FILE
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET POINTER TO INDIRECT OUTPUT RAB
	MOVW	IDF_W_OUTISI+IDF_K_LENGTH(R8),- ;GET ISI FROM PREVIOUS OUTPUT
		RAB$W_ISI(R0)		;AND SET INTO RAB
	MOVL	IDF_L_OUTRABCTX+IDF_K_LENGTH(R8),- ;RESTORE STACKED CONTEXT-
		RAB$L_CTX(R0)		;VALUE FROM PREVIOUS STACK FRAME
	MOVL	PRC_L_OUTRAB(R11),R1	;GET DIRECT OUTPUT RAB
	CMPW	RAB$W_ISI(R0),RAB$W_ISI(R1) ;IS OUTPUT NESTED AT ALL?
	BNEQ	10$			;BR IF YES
	MOVL	R1,PRC_L_INDOUTRAB(R11)	;SET INDIRECT OUTPUT AND OUTPUT THE SAME
;
; DEALLOCATE LOCAL SYMBOLS AND LABELS FOR CURRENT LEVEL
;
10$:	REMQUE	@PRC_Q_LOCAL(R11),R3	;REMOVE NEXT ENTRY FROM LOCAL SYMBOL TABLE
	BVC	20$			;IF VC ENTRY REMOVED
	REMQUE	@PRC_Q_LABEL(R11),R3	;REMOVE NEXT ENTRY FROM LOCAL LABEL TABLE
	BVS	30$			;IF VS TABLE EMPTY
20$:	BSBW	DCL$DEALLOCSYM		;DEALLOCATE SYMBOL ENTRY
	BRB	10$			;
;
; DEALLOCATE F$SEARCH CONTEXT BLOCKS FOR CURRENT LEVEL
;
30$:	MOVL	IDF_L_SEARCHCTX(R8),R3	;GET FIRST ENTRY OFF F$SEARCH LIST
	BEQL	32$			;BRANCH IF NONE LEFT
	MOVL	(R3),IDF_L_SEARCHCTX(R8) ;REMOVE FROM LINKED LIST
	CLRB	FAB$B_FNS+8(R3)		;SET NULL PRIMARY FILESPEC
	$PARSE	FAB=8(R3)		;TERMINATE SEARCH SEQUENCE
	MOVL	R3,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVL	4(R0),R1		;GET SIZE OF ENTRY IN BYTES
	BSBW	DCL$DEADYNMEM		;DEALLOCATE CONTEXT BLOCK
	BRB	30$			;LOOP UNTIL LIST CLEANED OUT
;
; RESET ON CONDITIONS BACK TO DEFAULTS
;
32$:	BSBW	DCL$ONRESET		;RESET ON ERROR PARAMETERS
	BSBW	DCL$ONCTLYRST		;AND THE ON CONTROL Y HANDLER
;
; POINT BACK TO THE PREVIOUS INDIRECT FRAME
;
	MOVL	IDF_L_LNK(R8), -	; UNLINK FRAME FROM INDIRECT LIST
		PRC_L_IDFLNK(R11)	; AND RESET FRAME POINTER
	MOVAB	IDF_K_LENGTH(R8), -	; REMOVE CURRENT INDIRECT FRAME FROM
		PRC_L_STACKPT(R11)	; STACK AND RESET STACK POINTER
	DECL	PRC_L_INDEPTH(R11)	; SET NEW INDIRECT STACK DEPTH
	INCL	PRC_L_INDCLOCK(R11)	; COUNT TOTAL STACKS OR UNSTACKS
	MOVL	PRC_L_IDFLNK(R11),R8	; POINT TO PREVIOUS INDIRECT FRAME
;
; RESTORE THE SAVED CONTEXT FROM THE PREVIOUS INDIRECT FRAME
;
	MOVQ	IDF_Q_LOCAL(R8),PRC_Q_LOCAL(R11) ;RESTORE LOCAL SYMBOL TABLE LISTHEAD
	MOVQ	IDF_Q_LABEL(R8),PRC_Q_LABEL(R11) ;RESTORE LOCAL LABEL TABLE LISTHEAD
	MOVW	IDF_W_ONLEVEL(R8),PRC_W_ONLEVEL(R11) ;RESTORE ON ERROR LEVEL NUMBER
	MOVL	IDF_L_ONERROR(R8),PRC_L_ONERROR(R11) ;RESTORE ADDRESS OF COMMAND TEXT
	MOVL	IDF_L_ONCTLY(R8),PRC_L_ONCTLY(R11) ;AND THE ON CONTROL T HANDLER
;
; RE-OPEN THE INPUT PROCEDURE FILE ASSOCIATED WITH THE PREVIOUS
; INDIRECT FRAME.  IF WE ARE POSITIONED TO END-OF-FILE, THEN DON'T
; BOTHER RE-OPENING THIS LEVEL, AND GO BACK ONE MORE.
;
	CMPW	IDF_W_INPRFA(R8),#^XFFFF ;END OF FILE?
	BNEQ	35$			;BRANCH IF NOT
	BRW	5$			;IF EOF, UNSTACK ANOTHER LEVEL
35$:	MOVL	PRC_L_INPRAB(R11),-	;ASSUME RETURNING TO LEVEL ZERO AND-
		PRC_L_INDINPRAB(R11)	;SET INPUT AS INDIRECT INPUT ALSO
	BBC	#IDF_V_INPOPN,IDF_W_FLAG(R8),40$ ;BR IF GOING TO LEVEL 0
	MOVAB	PRD_G_ALTINPRAB(AP),R6	;GET THE ALTERNATE INPUT RAB
	MOVL	R6,PRC_L_INDINPRAB(R11)	;SET THAT IS INDIRECT INPUT RAB
	MOVL	IDF_L_INPRABCTX(R8),-	;RESTORE STACKED DEVICE CHARACTERISTICS-
		RAB$L_CTX(R6)		;VALUE FROM STACK FRAME
	MOVL	FAB$L_NAM(AP),R7	;ADDRESS OF NAME BLOCK
	MOVC	#28,IDF_T_INPDVI(R8),-	;COPY PREVIOUS INPUT DEVICE,FILE AND-
		NAM$T_DVI(R7)		;DIRECTORY ID'S INTO NAME BLOCK
	MOVB	#FAB$M_GET,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVL	#FAB$M_INP!FAB$M_PPF!FAB$M_SQO!FAB$M_NAM,- ;SET FILE OPEN OPTIONS
		FAB$L_FOP(AP)
	CLRB	FAB$B_FNS(AP)		;REMOVE RESIDUAL FILE NAME SIZE
	CLRB	FAB$B_SHR(AP)		;CLEAR FILE SHARING OPTIONS
	$OPEN	FAB=(AP)		;OPEN PREVIOUS INPUT
37$:	BLBS	R0,38$			;BRANCH IF SUCCESSFUL
	BSBW	DCL$ERRORMSG		;REPORT ERROR MESSAGE
	BRB	40$
38$:	CLRBIT	FAB$V_NAM,FAB$L_FOP(AP)	;REMOVE OPEN BY NAME BLOCK FLAG
	MOVW	FAB$W_IFI(AP),IDF_W_INPIFI(R8) ;SET NEW INPUT IFI
	CLRW	RAB$W_ISI(R6)		;ZERO PREVIOUS INTERNAL SEQUENCE NUMBER
	$CONNECT RAB=(R6)		;CONNECT TO PREVIOUS INPUT
	BLBC	R0,37$			;BRANCH IF UNSUCCESSFUL
	BBC	#DEV$V_RND,RAB$L_CTX(R6),40$ ;SKIP IF NOT A DISK FILE
	MOVW	IDF_W_INPRFA+4(R8),RAB$W_RFA4(R6) ;COPY RECORD FILE ADDRESS FROM
	MOVL	IDF_W_INPRFA(R8),RAB$W_RFA(R6) ;FROM INDIRECT STACK TO RAB
	BEQL	40$			;BR IF PREVIOUS FILE AT TOP_OF_FILE
	MOVB	#RAB$C_RFA,RAB$B_RAC(R6) ;SET ACCESS MODE TO RECORD FILE ADR
	$FIND	RAB=(R6)		;SET TO NEXT RECORD POSITION
	ASSUME	RAB$C_SEQ EQ 0
	CLRB	RAB$B_RAC(R6)		;SET ACCESS TO SEQUENTIAL
40$:

	.SBTTL	CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
;---
;
; CREATE - CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
;
; THIS ROUTINE IS CALLED TO CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
; BASE ON THE CURRENT INDIRECT FILE DEPTH.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R8 = ADDRESS OF CURRENT INDIRECT FRAME
;
; OUTPUTS:
;
;	R0-R5 DESTROYED.
;---
 
CREATE:					;
	MOVL	PRC_L_INDINPRAB(R11),R0	;GET INDIRECT INPUT RAB ADDRESS
	MOVAB	IDF_T_INPDVI(R8),R2	;GET ADDRESS OF INPUT DEVICE IDENTIFICATION
	BICW3	#FAB$M_PPF_IND,-	;GET INTERNAL FILE ID FOR INPUT -
		IDF_W_INPIFI(R8),R3	;ALWAYS CLEAR INDIRECT BIT IF SET
	MOVAB	INPUTNAM,R5		;GET ADDRESS OF INPUT LOGICAL NAME
	BSBB	10$			;CREATE 'INPUT' LOGICAL NAME
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET INDIRECT OUTPUT RAB ADDRESS
	MOVAB	IDF_T_OUTDVI(R8),R2	;GET ADDRESS OF OUTPUT DEVICE IDENTIFICATION
	BICW3	#FAB$M_PPF_IND,-	;GET INTERNAL FILE ID FOR OUTPUT FILE -
		IDF_W_OUTIFI(R8),R3	;ALWAYS CLEAR INDIRECT BIT IF SET
	MOVAB	OUTPUTNAM,R5		;GET ADDRESS OF OUTPUT LOGICAL NAME
;
; R0 = RAB ADDRESS
; R2 = ADDRESS OF ASCIC DEVICE NAME
; R3 = IFI CORRESPONDING TO FILE
; R5 = ADDRESS OF ASCIC LOGICAL NAME
;
10$:	SUBL	#16,SP			;ALLOCATE SPACE TO STORE DEVICE NAME
	MOVZBL	(R2)+,R0		;GET LENGTH OF DEVICE NAME
	PUSHR	#^M<R0,R3,R5>		;SAVE REGISTERS
	MOVC	R0,(R2),12(SP)		;COPY DEVICE IDENTIFICATION
	MOVB	#^A/:/,(R3)		;APPEND THE :
	POPR	#^M<R0,R3,R5>		;RESTORE REGISTERS
	MOVZBL	#27,-(SP)		;INSERT ESCAPE AND TYPE ZERO
	MOVW	R3,2(SP)		;INSERT INTERNAL FILE INDEX
	PUSHL	SP			;BUILD DESCRIPTOR FOR EQUIVALENCE NAME
	PUSHAB	5(R0)			;SET LENGTH OF LOGICAL NAME
	MOVL	SP,R0			;SAVE ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	MOVZBL	(R5)+,R4		;GET LENGTH OF LOGICAL NAME
	MOVQ	R4,-(SP)		;BUILD LOGICAL NAME DESCRIPTOR
	MOVL	SP,R1			;SAVE ADDRESS OF LOGICAL NAME DESCRIPTOR
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	$CRELOG_S #LOG$C_PROCESS,(R1),(R0),#PSL$C_SUPER ;CREATE LOGICAL NAME
	BRB	30$			;
20$:	$DELLOG_S #LOG$C_PROCESS,(R1),#PSL$C_SUPER ;DELETE LOGICAL NAME
30$:	ADDL	#36,SP			;CLEAN STACK
	RSB				;
 
	.END
