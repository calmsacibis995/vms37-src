	.TITLE	IMAGECTRL - IMAGE CONTROL
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; IMAGE CONTROL DCLS COMMAND EXECUTION
;
;	CONTINUE IMAGE EXECUTION
;	DEBUG IMAGE EXECUTION
;	STOP IMAGE EXECUTION
;
; D. N. CUTLER 4-APR-77
;
; MODIFIED BY:
;
;	V03-001	PHL0045		Peter H. Lipman	15-Apr-1982
;		Add closed routine to save and restore image privileges.
;		Call this from the control/y handler if control/y out
;		of a privileged image to save image privs and set them
;		to process privs.  Call from CONTINUE command to restore
;		image privs.
;
;		The above is to allow SPAWN, ATTACH, and CONTINUE commands
;		to work after control/y out of privileged image.
;
;	V006	PCG0002		Peter George	24-Feb-1982
;		Zero CTL$GL_CLINTOWN and CTL$GL_DCLPRSOWN in DCL$STOP.
;
;	V005	PCG0001		Peter George	08-Dec-1981
;		Call DCL$ABORT instead of DCL$LOGOUT to STOP a batch job.
;
;	V004	TMH0004		Tim Halvorsen	27-Apr-1981
;		Make use of PRC_L_INDEPTH to determine if level 0 or not.
;
;	V003	TMH0003		Tim Halvorsen	21-Mar-1981
;		Fix bug in TMH0002 which failed to properly
;		deallocate YLEVEL WRK area.
;		Do not compress quotes from process name in STOP,
;		since it is now being done automatically in value parsing.
;
;	V002	TMH0002		Tim Halvorsen	14-Feb-1981
;		Use R10 rather than FP as WRK address.
;		Set NOSTAT bit in CONTINUE routine.
;
;	V001	TMH0001		Tim Halvorsen	03-Sep-1980
;		Convert to use MDL structures and remove macro references.
;		Relocate WRK_L_RSLEND after stack shift in RUNDOWN.
;---

;
; MACRO LIBRARY CALLS
;
 
	$PPDDEF				;PROCESS PERMANENT DATA AREA
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
 
;
; LOCAL DATA
;
; HEX CONVERSION TABLE
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
HEXTAB:	.ASCII	/FEDCBA9876543210/	;

	.SBTTL	CONTINUE IMAGE EXECUTION
;+
; DCL$CONTINUE - CONTINUE IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE CONTINUE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	IF A PREVIOUS IMAGE WAS INTERRUPTED VIA A CONTROL Y AST, THEN THE
;	CURRENT COMMAND CONTEXT IS REMOVED FROM THE STACK AND CONTROL IS
;	RETURNED TO THE IMAGE. OTHERWISE THIS COMMAND IS A NOPERATION.
;-
 
	.ENABL	LSB
DCL$CONTINUE::				;CONTINUE IMAGE EXECUTION
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10) ;DO NOT SET STATUS ON SUCCESS
	BSBW	TESTMODE		;TEST PREVIOUS MODE
	BBC	#PRC_V_PRIV,PRC_B_FLAGS2(R11),10$  ;BR IF UNPRIVILEGED IMAGE
	BSBW	RESTORE_PRIVS		;RESTORE IMAGE PRIVILEGE
10$:	RET				;

	.SBTTL	DEBUG IMAGE EXECUTION
;+
; DCL$DEBUG - DEBUG IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEBUG DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	IF A PREVIOUS IMAGE WAS INTERRUPTED VIA A CONTROL Y AST, THEN A
;	DEBUG EXCEPTION IS GENERATED FOR THE IMAGE. OTHERWISE THIS COMMAND
;	IS A NOPERATION.
;-
 
DCL$DEBUG::				;DEBUG IMAGE EXECUTION
	BSBW	TESTMODE		;TEST PREVIOUS MODE
	MOVAB	B^20$,16(FP)		;RESET AST RETURN ADDRESS
	ASHL	#PSL$V_PRVMOD,#<PSL$C_SUPER@2>! - ;CONSTRUCT PROPER PSL
		PSL$C_USER,-(SP)	;
	PUSHAB	10$			;SET PC
	REI				;
 
;
; CONTROL IS REGAINED AT THIS POINT WITH:
;
;	00(SP) = NUMBER OF AST ARGUMENTS (ALWAYS 5).
;	04(SP) = AST PARAMETER.
;	08(SP) = SAVED R0.
;	12(SP) = SAVED R1.
;	16(SP) = IMAGE PC.
;	20(SP) = IMAGE PSL.
;
 
20$:	ADDL	#8,SP			;REMOVE NUMBER OF ARGUMENTS AND PARAMETER
	POPR	#^M<R0,R1>		;RESTORE SAVED REGISTERS
	MOVZWL	#SS$_DEBUG,-(SP)	;SET EXCEPTION NAME
	PUSHL	#3			;SET NUMBER OF EXCEPTION ARGUMENTS
	JMP	@#EXE$REFLECT		;REFLECT EXCEPTION
	.DSABL	LSB

	.SBTTL	STOP IMAGE EXECUTION
;+
; DCL$STOP - STOP IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE STOP DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	IF A PROCESS NAME OR IDENTIFICATION IS SPECIFIED, THEN THAT PROCESS IS
;	DELETED.
;
;	IF THE JOB IS A NONINTERACTIVE JOB, THEN THE JOB IS LOGGED OFF THE SYSTEM
;	WITH A STATUS OF NORMAL COMPLETION. OTHERWISE ALL INDIRECT FILE LEVELS ARE
;	UNSTACKED AND A TEST IS MADE TO DETERMINE IF AN IMAGE WAS INTERRUPTED VIA
;	A CONTROL C/Y. IF A PREVIOUS IMAGE WAS INTERRUPTED, THEN THE CONTEXT OF THE
;	RUN COMMAND THAT INITIATED IMAGE EXECUTION IS REMOVED FROM THE STACK AND
;	RMS-32 IS CALLED TO CLOSE ALL OPEN IMAGE FILES. OTHERWISE NO OPERATION IS
;	PERFORMED.
;-
 
DCL$STOP::				;STOP IMAGE EXECUTION
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10) ;MARK TO NOT CHANGE $STATUS
	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	40$			;IF NEQ NO
10$:	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT LEVEL
	BRB	10$			;
20$:	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),30$ ;IF SET, NONINTERACTIVE JOB
	BSBW	TESTMODE		;TEST PREVIOUS MODE
	MOVL	WRK_L_SAVFP(R10),R10	;RESTORE SAVED WRK ADDRESS
	BSBW	DCL$SHUTDOWN		;CLOSE FILES OF PREVIOUS IMAGE
	CLRL	G^CTL$GL_CLINTOWN	;ZERO CLINT OWN STORAGE POINTER
	CLRL	G^CTL$GL_DCLPRSOWN	;ZERO DCL PARSE OWN STORAGE
	$RUNDWN_S #PSL$C_USER		;RUN DOWN PREVIOUS IMAGE
	BICB	#<PRC_M_EXEONLY ! PRC_M_PRIV>,- ;SINCE IMAGE IS NOW GONE
		PRC_B_FLAGS2(R11)	;NO NEED TO PROTECT IT
	MOVL	R10,FP			;RESET FP SO YLEVEL WRK IS DEALLOCATED
					;ON RETURN TO DCL$RESTART.
	RSB				;

;
; CLOSE ALL PROCESS PERMANENT FILES STILL OPEN
;
30$:	MOVL	PRC_L_INDFAB(R11),R9	;GET ADDRESS OF INDIRECT FAB
	MOVAB	PRC_L_PPFLIST(R11),R2	;GET ADDRESS OF FILE DESCRIPTOR LISTHEAD
35$:	MOVL	(R2),R2			;GET ADDRESS OF NEXT FILE DESCRIPTOR
	BEQL	37$			;IF EQL END OF LIST
	MOVW	RAB$L_CTX+4(R2),FAB$W_IFI(R9) ;INSERT INTERNAL FILE INDEX
	$CLOSE	FAB=(R9)		;CLOSE FILE
	BRB	35$			;
;
; ACTIVATE LOGOUT IMAGE
;
37$:	MOVL	PRC_L_LSTSTATUS(R11),-	;PASS FINAL STATUS TO LOGOUT
		G^CTL$AG_CLIDATA+PPD$L_LSTSTATUS
	BRW	DCL$ABORT		;LOG PROCESS OUT
 
;
; DELETE PROCESS
;
 
40$:	CLRL	-(R9)			;CLEAR PROCESS IDENTIFICATION
	MOVL	R8,R7			;COPY ADDRESS OF SCRATCH DESCRIPTOR
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER SPECIFIED?
	BNEQ	70$			;IF NEQ NO
	BSBW	DCL$GETDVAL		;GET VALUE PARAMETERS
	MOVQ	R1,R2			;SAVE VALUE PARAMETERS
50$:	DECL	R2			;ANY MORE CHARACTERS TO CONVERT?
	BLSS	60$			;IF LSS NO
	LOCC	(R3)+,#16,HEXTAB	;SEARCH FOR HEX CHARACTER MATCH
	BEQL	80$			;IF EQL VALUE SYNTAX ERROR
	MULL	#16,(R9)		;SCALE ACCUMULATED RESULT
	ADDL	R0,(R9)			;ADD IN NEXT DIGIT
	DECL	(R9)			;SUBTRACT OUT CHARACTER COUNT
	BRB	50$			;
60$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	70$			;IF NEQ NO
	CLRL	R7			;CLEAR DESCRIPTOR ADDRESS
70$:	MOVQ	R1,(R8)			;SAVE PROCESS NAME PARAMETERS
	$DELPRC_S (R9),(R7)		;DELETE PROCESS
	RSB				;
80$:	STATUS	IVVALU			;SET INVALID VALUE SYNTAX STATUS
	RSB				;

	.SBTTL	TEST PREVIOUS MODE
;
; SUBROUTINE TO TEST PREVIOUS MODE AND DISABLE CONTROL Y AST
;
 
TESTMODE:				;TEST PREVIOUS MODE
	SETBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y AST
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
	BBC	#PSL$V_CURMOD,@PRC_L_SAVAP(R11),10$ ;IF CLR, PREVIOUS MODE SUPERVISOR
	MOVQ	WRK_L_SAVAP(R10),PRC_L_SAVAP(R11) ;RESTORE ARGUMENT AND FRAME POINTERS
	RSB				;
 
;
; PREVIOUS MODE SUPERVISOR
;
 
10$:	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	STATUS	NORMAL			;SET COMPLETION STATUS
	RSB				;

	.SBTTL	SAVE/RESTORE IMAGE PRIVILEGES
;+
; DCL$SAVE_PRIVS - SAVE PRIVILEGED IMAGE PRIVILEGES
;		   SET IMAGE PRIVILEGES TO PROCESS PRIVILEGES
; RESTORE_PRIVS  - RESTORE PRIVILEGED IMAGE PRIVILEGES FROM
;		   SAVED COPY
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	PRC_Q_SAVEPRIV(R11) - SAVED IMAGE PRIVILEGE TO BE USED BY
;		RESTORE_PRIVS
;
; OUTPUTS:
;
;	R0,R1,R2 DESTROYED OTHERS PRESERVED
;	PRC_Q_SAVEPRIV(R11) - PREVIOUS VALUE OF IMAGE PRIVILEGES
;-
DCL$SAVE_PRIVS::
	$SETPRV_S PRMFLG=#1,-	;READ PROCESS PERMANENT PRIVILEGES
		  PRVPRV=PRC_Q_SAVEPRIV(R11)
RESTORE_PRIVS:
	MNEGL	#1,-(SP)	;FORM MASK OF ALL PRIVS FOR DISABLE
	MNEGL	#1,-(SP)
	MOVAQ	-(SP),R2	;RESERVE 2ND MASK, R2 = ADR
	$SETPRV_S ENBFLG=#0,-	;DISABLE ALL PROCESS PRIVILEGES
		  PRVADR=8(R2),-
		  PRVPRV=(R2)	;SAVING OLD COPY
	$SETPRV_S ENBFLG=#1,-	;ENABLE THE SAVED PRIVILEGES
		  PRVADR=PRC_Q_SAVEPRIV(R11)
	MOVQ	(R2),PRC_Q_SAVEPRIV(R11) ;SAVE PREVIOUS PRIVILEGES
	ADDL	#16,SP		;CLEAN OFF 2 PRIV MASKS
	RSB

	.SBTTL	RUN DOWN IMAGE AND INDIRECT LEVELS
;+
; DCL$RUNDOWN - RUN DOWN IMAGE AND INDIRECT LEVELS
;
; THIS SUBROUTINE IS CALLED TO CHECK WHETHER INDIRECT LEVELS SHOULD BE RUN DOWN
; AND TO CLOSE RMS-32 FILES AND RUN DOWN THE PREVIOUS IMAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF THE CURRENT LEVEL IS CONTROL Y/C, THEN ALL INDIRECT FILES ARE UNSTACKED.
;	IF THE PREVIOUS MODE WAS USER, THEN THE USER IMAGE EXIT HANDLERS ARE
;	EXECUTED. THE PREVIOUS IMAGE IS ALWAYS RUNDOWN.
;-
	.ENABL	LSB
 
DCL$RUNDWNI::				;RUN DOWN BUT PRESERVE INDIRECT LEVEL
	MOVAB	B^20$,R0		;SET EXIT HANDLER RETURN ADDRESS
	BRB	5$			;
 
DCL$RUNDOWN::				;RUN DOWN IMAGE AND INDIRECT LEVELS
	MOVAB	B^10$,R0		;SET EXIT HANDLER RETURN ADDRESS
5$:	SETBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
	PUSHL	R0			;PUSH PROPER RETURN ADDRESS
	MOVL	PRC_L_SAVAP(R11),R0	;GET ADDRESS OF PREVIOUS PSL
	BBC	#PSL$V_CURMOD,(R0),10$	;IF CLR, PREVIOUS MODE SUPERVISOR
	BICB	#<PSL$M_FPD!PSL$M_TP!PSL$M_CM>@-24,3(R0) ; RESET BITS IN PSL
	MOVAB	@#EXE$EXIT_IMAGE,-(R0)	;RESET USER RETURN ADDRESS
	MOVZWL	#SS$_CLIFRCEXT,-8(R0)	;SET EXIT CAUSE INTO SAVED R0
	SUBL3	R10,SP,WRK_L_SAVSP(R10)	;SAVE RELATIVE ADDRESS OF TOP OF STACK
	MOVQ	WRK_L_SAVAP(R10),R8	;RETRIEVE PREVIOUS ARGUMENT AND FRAME POINTERS
	MOVQ	R8,PRC_L_SAVAP(R11)	;SAVE IN PROCESS WORK AREA
	SUBL	R10,WRK_L_RSLNXT(R10)	;CONVERT PARSE POINTER TO RELATIVE ADDRESS
	SUBL	R10,WRK_L_RSLEND(R10)	;CONVERT END POINTER TO RELATIVE ADDRESS
	MOVAB	8(R0),R7		;GET ADDRESS OF END OF ARGUMENT LIST + 4
	SUBL	FP,R7			;CALCULATE LENGTH OF CALL FRAME AND ARGLIST
	SUBL	R7,SP			;CALCULATE NEW TOP OF STACK ADDRESS
	MOVC	R7,(FP),(SP)		;MOVE CALL FRAME AND ARGUMENT LIST
	SUBL3	SP,FP,R7		;CALCULATE LENGTH OF COMMAND BUFFER AND ARGLISTS
	SUBL3	R7,R9,FP		;CALCULATE NEW TOP OF STACK ADDRESS
	MOVC	R7,(SP),(FP)		;COLLAPSE STACK REMOVING FIRST COMMAND CONTEXT
	ADDL	R9,WRK_L_SAVSP(R9)	;CALCULATE NEW COMMAND STACK POINTER
	ADDL	R9,WRK_L_RSLNXT(R9)	;CONVERT PARSE POINTER TO REAL ADDRESS
	ADDL	R9,WRK_L_RSLEND(R9)	;CONVERT END POINTER TO REAL ADDRESS
	RET				;RETURN TO EXE$EXIT_IMAGE
					;  THEN TO 10$ OR 20$
10$:	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT LEVEL
	BRB	10$			;
20$:	TSTL	G^CTL$GL_IMGHDRBF	;IS THERE STILL AN IMAGE ACTIVE?
	BEQL	30$			;BRANCH IF NOT
	$RUNDWN_S #PSL$C_USER		;RUN DOWN IMAGE (THE HARD WAY)
	BICB	#<PRC_M_EXEONLY ! PRC_M_PRIV>,- ;SINCE IMAGE IS NOW GONE
		PRC_B_FLAGS2(R11)	;NO NEED TO PROTECT IT
30$:	RSB				;
	.DSABL	LSB

	.SBTTL	SHUT DOWN IMAGE
;+
; DCL$SHUTDOWN - SHUT DOWM IMAGE
;
; THIS ROUTINE IS CALLED TO CLOSE ALL FILES OPENED BY THE JUST EXECUTED IMAGE
; AND TO CLOSE THE IMAGE ACTIVATION FILE.
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	ALL FILES OPENED BY THE JUST EXECUTED IMAGE ARE CLOSED BY CALLING RMS-32,
;	DATA RECORDS ARE SKIPPED IN THE INPUT STREAM, AND THE IMAGE FILE IS CLOSED.
;
;		R2 = NUMBER OF DATA RECORDS SKIPPED IN THE INPUT STREAM.
;-
 
DCL$SHUTDOWN::				;SHUT DOWN IMAGE
	BSBW	DCL$ALLOCBUF		;ALLOCATE BUFFER AND DESCRIPTOR
10$:	MOVZBL	#WRK_C_MSGBUFSIZ,(R2)	;RESET SIZE OF MESSAGE BUFFER
	PUSHL	#0			;RUN DOWN ONLY IMAGE FILES
	PUSHAB	(R2)			;SET ADDRESS OF MESSAGE BUFFER DESCRIPTOR
	CALLS	#2,@#SYS$RMSRUNDWN	;RUNDOWN RMS-32 FILES
	BLBC	R0,10$			;IF RUNDOWN FAILURE CONTINUE WITH NEXT FILE
	MOVAB	WRK_C_MSGBUFSIZ+8(SP),SP ;DEALLOCATE MESSAGE BUFFER AND DESCRIPTOR
	CLRL	R2			;CLEAR COUNT OF RECORDS SKIPPED
	MOVL	PRC_L_INDINPRAB(R11),R3	;GET ADDRESS OF INDIRECT RAB
	MOVQ	RAB$W_RFA(R3),-(SP)	;SAVE RFA OF LAST COMMAND
	BBS	#DEV$V_TRM,RAB$L_CTX(R3),30$ ;IF SET, DEVICE IS TERMINAL
	BITB	#PRC_M_CHAIN!PRC_M_CMD,PRC_B_FLAGS2(R11) ;CHAIN A/O COMMAND?
	BNEQ	30$			;NO SKIP IF EITHER IS PENDING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R3) ;CONVERT TO NONPRIVILEGED ISI
20$:	INCL	R2			;INCREMENT NUMBER OF RECORDS SKIPPED
	$GET	RAB=(R3)		;GET NEXT RECORD FROM INDIRECT FILE
	BLBS	R0,20$			;IF LBS SUCCESS
	DECL	R2			;ADJUST FOR LAST RECORD
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R3) ;CONVERT BACK TO PRIVILEGED ISI
30$:	MOVQ	(SP)+,RAB$W_RFA(R3)	;RESTORE RFA OF LAST COMMAND
	RSB				;
 
	.END
