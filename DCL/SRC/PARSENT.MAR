	.TITLE	PARSENT - PARSE PARAMETERS AND QUALIFIERS
	.IDENT	'V03-010'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 24-MAR-77
;
; PROCESS QUALIFIER SPECIFICATION
;
; MODIFICATIONS:
;
;	V010	PCG0003		Peter George	12-Apr-1982
;		Enforce nonnegatable attribute.
;
;	V009	PCG0002		Peter George	25-Jan-1982
;		Create shared DCL$SEARCH_VERB subroutine.
;		Deal with structure level 5 tables (.ADDRESS routines).
;		Allow non-ambiguous matches of less than 4 character
;		long qualifiers.
;
;	V008	PCG0001		Peter George	31-Dec-1981
;		Allow values on negated parameters and qualifiers.
;
;	V007	TMH0007		Tim Halvorsen	22-Dec-1981
;		Allow @ to be passed in the RESTOFLINE entity value
;		without having to pass it in a quoted string.  This
;		is useful for the command string passed to SPAWN.
;
;	V006	TMH0006		Tim Halvorsen	25-Aug-1981
;		Add support for value type RESTOFLINE, which gobbles
;		the rest of the command string as the entity value.
;		Invalidate all qualifier numbers in the token array
;		when we make a transition to another syntax list, so
;		that old qualifiers cannot be referenced, and so that
;		old qualifiers don't get confused with new ones.
;		Remember qualifier number which invoked the first syntax
;		change, for the GETOPT callback (SET/SHOW).
;
;	V005	TMH0005		Tim Halvorsen	30-Mar-1981
;		Set correct terminators on qualifier value lists
;		(colon on comdqual, not lparen; and blank/slash/etc.
;		on last qualvalu, not rparen).
;
;	V004	TMH0004		Tim Halvorsen	19-Mar-1981
;		Generalize qualifier value parsing to allow a list
;		of file specifications, and make it a separate routine.
;		Combine PROCFILE module into this module and remove
;		checking of the limits of UIC format directories and
;		version numbers to reduce the code size and reduce the
;		knowledge of filespecs to just what is needed to determine
;		where the filespec ends.  Rename module to PARSENT to
;		indicate that it now parses all types of entities.
;
;	V003	TMH0003		Tim Halvorsen	11-Feb-1981
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARKEDTOKEN routine.
;		Make use of DCL$COMPRESS routine.
;		Avoid enforcing VALREQ when the qualifier is negated.
;
;	V002	TMH0002		Tim Halvorsen	13-Nov-1980
;		Compute address of value terminator correctly when value
;		is enclosed in double quotes.
;
;	001	TMH0001		Tim Halvorsen	08-Jul-1980
;		Use new MDL structures.
;---

;
; MACRO LIBRARY CALLS
;
 
	VECDEF				; DEFINE VECTOR AT FRONT OF TABLES
	CMDDEF				; DEFINE COMMAND DESCRIPTOR BLOCK
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR
	ENTDEF				; DEFINE QUALIFIER DESCRIPTOR BLOCK
	CHGDEF				; DEFINE CHANGE LIST FORMAT
	$CLIMSGDEF			; CLI MESSAGES

	.SBTTL	PROCESS QUALIFIER SPECIFICATION
;+
; DCL$PROCQUAL - PROCESS QUALIFIER SPECIFICATION
;
; THIS ROUTINE IS CALLED TO PARSE A QUALIFIER SPECIFICATION AND EMIT A
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO PARSE QUALIFIER SPECIFICATION.
;
;		R0 = DCL$_ABKEYW - AMBIGUOUS KEYWORD IN QUALIFIER.
;		R0 = DCL$_IMCHNG - MULTIPLE ATTEMPT TO CHANGE IMAGE NAME.
;		R0 = DCL$_IVKEYW - INVALID KEYWORD IN QUALIFIER.
;		R0 = DCL$_IVQLOC - INVALID QUALIFIER LOCATION.
;		R0 = DCL$_IVVALU - INVALID QUALIFIER VALUE SYNTAX.
;		R0 = DCL$_NOKEYW - NO KEYWORD IN QUALIFIER.
;		R0 = DCL$_NOQUAL - NO QUALIFIERS ALLOWED ON COMMAND.
;		R0 = DCL$_NOVALU - NO VALUE ALLOWED ON QUALIFIER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL PARSE WITH THE QUALIFIER
;		DESCRIPTOR EMITTED AND THE QUALIFIER SPECIFICATION COPIED
;		TO THE COMMAND BUFFER.
;
;		R0 = DCL$_NORMAL - NORMAL COMPLETION.
;-
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
DCL$PROCQUAL::				;PROCESS QUALIFIER SPECIFICATION
	PUSHR	#^M<R6,R7,R8>		;SAVE REGISTERS
	CLRL	-(SP)			;CLEAR KEYWORD NEGATION FLAG
	BISW	#WRK_M_QUAL,WRK_W_FLAGS(R10) ;SET QUALIFIER PROCESSING IN PROGRESS
	BSBW	DCL$MOVCHAR		;MOVE SLASH TERMINATOR
	BSBW	DCL$MARK		;MARK CURRENT POSITION IN BUFFER
	BSBW	DCL$GETOKEN		;GET QUALIFIER NAME
	BNEQ	10$			;IF NEQ THEN PROCESS
	BRW	90$			;ELSE DONE
10$:	MOVL	R1,AP			;SAVE ORIGINAL TOKEN SIZE
	CMPL	#4,R1			;KEYWORD LESS THAN 5 CHARACTERS?
	BGEQ	20$			;IF GEQ YES
	MOVL	#4,R1			;SET TO ONLY COMPARE 4 CHARACTERS
20$:	CLRQ	R6			;CLEAR QUALIFIER NUMBER AND INITIAL OFFSET
	CLRQ	-(SP)			;SET NULL AS QUALIFIER FOUND
	STATUS	NOQUAL			;ASSUME NO QUALIFIERS ALLOWED ON COMMAND
	MOVL	WRK_L_QUABLK(R10),R8	;GET ADDRESS OF QUALIFIER DESCRIPTORS
	BEQL	85$			;IF EQL NONE
30$:	ADDL	R6,R8			;GET ADDRESS OF NEXT QUALIFIER DESCRIPTOR
	CVTWL	ENT_W_NAME(R8),R0	;GET OFFSET TO ASCIC QUALIFIER NAME
	MOVAB	(R8)[R0],R5		;FIND ADDRESS OF QUALIFIER KEY LENGTH
	MOVAB	1(R8)[R0],R0		;FIND ADDRESS OF QUALIFIER KEY TEXT
	MOVQ	R1,R3			;COPY QUALIFIER STRING DESCRIPTOR
60$:	CMPB	#^A/ /,(R0)		;END OF QUALIFIER TEXT?
	BEQL	65$			;BR IF YES
	CMPB	(R0)+,(R4)+		;IS THIS THE QUALIFIER WERE LOOKIN FOR?
	BNEQ	70$			;BR IF DEFINITELY NOT!
	SOBGTR	R3,60$			;BR IF MORE TO CHECK

	CMPL	#4,AP			;IS INPUT QUALIFIER LESS THAT FOUR CHARS
	BLEQ	65$			;NO, THEN SKIP
	CMPB	AP,(R5)			;IS TABLE QUALIFIER SAME LENGTH
	BNEQ	65$			;NO, THEN SKIP
	ADDL	#8,SP			;YES, THEN WE HAVE A UNIQUE MATCH
	BRW	110$			;RESTORE STACK AND BRANCH

65$:	TSTL	4(SP)			;FIND MATCH BEFORE?
	BEQL	67$			;BR IF NOT AMBIGUOUS
	BISL	#2,8(SP)		;SET AMBIGUOUS BIT
67$:	MOVQ	R7,(SP)			;SAVE MATCHED QUALIFIER VALUES
70$:	INCL	R7			;INCREMENT QUALIFIER NUMBER
	CVTBL	ENT_B_NEXT(R8),R6	;GET OFFSET TO NEXT QUALIFIER DESCRIPTOR
	BNEQ	30$			;IF NEQ TRY AGAIN
 
;
; ALL QUALIFERS HAVE BEEN CHECK WITHOUT AMBIGUITY
;	NOW SEE IF ANY MATCHED
;
	STATUS	ABKEYW			;ASSUME AMBIGUOUS
	BBSC	#1,8(SP),85$		;BR IF TRUE
	MOVQ	(SP)+,R7		;RESTORE MATCHED QUALIFER PARAMETERS
	BNEQ	110$			;BR IF ONE WAS FOUND
 
;
; QUALIFIER DESCRIPTOR TABLE EXHAUSTED - TRY NEGATION
;
 
	XORL	#1,(SP)			;COMPLEMENT NEGATION FLAG
	SUBL3	#2,AP,R1		;REDUCE CHARACTER COUNT
	BLEQ	80$			;IF LEQ NO MATCH POSSIBLE
	CMPW	#^A/NO/,(R2)+		;KEYWORD START WITH 'NO'?
	BEQL	10$			;IF EQL YES
 
;
; INVALID KEYWORD IN QUALIFIER
;
 
80$:	STATUS	IVKEYW			;SET INVALID KEYWORD STATUS
	BRB	100$			;
85$:	CLRQ	(SP)+			;REMOVE PARAMETER FROM THE STACK
	BRB	100$			;TAKE ERROR EXIT
 
;
; NO KEYWORD IN QUALIFIER
;
 
90$:	STATUS	NOKEYW			;SET NO KEYWORD STATUS
100$:	BRW	390$			;
 
;
; VALID KEYWORD MATCH FOUND - CHECK VALIDITY
;
 
110$:	INCL	R7			;ADJUST TO ACTUAL QUALIFIER NUMBER
	STATUS	IVQLOC			;ASSUME INVALID QUALIFIER LOCATION
	BBS	#WRK_V_VERB,WRK_W_FLAGS(R10),120$ ;IF SET, PROCESSING VERB
	BBS	#ENT_V_PARM,ENT_L_FLAGS(R8),125$ ;IF SET, ALLOWED ON PARAMETERS
120$:	BBC	#ENT_V_VERB,ENT_L_FLAGS(R8),100$ ;IF CLR, NOT ALLOWED ON VERBS

;
; PROCESS CHANGE LIST - IF ANY
;

125$:	CVTWL	ENT_W_SYNTAX(R8),R6	;GET OFFSET TO CHANGE LIST
	BNEQ	128$			;CONTINUE IF CHANGE LIST
	BRW	150$			;BRANCH IF NO CHANGE LIST
128$:	ADDL	R8,R6			;GET ADDRESS OF CHANGE LIST
	TSTB	WRK_B_CMDOPT(R10)	;FIRST SYNTAX CHANGE SO FAR?
	BNEQ	131$			;ONLY RECORD THE FIRST CHANGE MADE
	MOVB	R7,WRK_B_CMDOPT(R10)	;SAVE QUAL # INDUCING THE FIRST CHANGE
					; FOR GETOPT CALLBACK (SET/SHOW)
131$:	BBC	#CHG_V_IMAGE,CHG_B_FLAGS(R6),145$ ; BRANCH IF NO IMAGE CHANGE
	CVTWL	CHG_W_IMAGE(R6),R0	;GET OFFSET TO ASCIC IMAGE NAME
	BEQL	145$			;IF EQL NO CHANGE
	BGEQ	132$			;BRANCH IF OFFSET
	MNEGL	R0,R0			;GET INDEX INTO IMAGE NAME TABLE
	BRB	135$
132$:	ADDL	R6,R0			;GET ADDRESS OF ASCIC IMAGE NAME
	CMPL	R0,#128			;INTERNAL ROUTINE INDEX?
	BLSS	135$			;YES, THEN SKIP
	BBS	#30,R0,135$		;SKIP IF NOT IN P0 SPACE
	MOVL	WRK_L_TAB_VEC(R10),R1	;GET ADDRESS OF TABLES VECTOR
	CMPB	VEC_B_STRLVL(R1),#5	;STRUCTURE LEVEL 5? (.ADDRESS ROUTINE)
	BGEQ	133$			;BRANCH IF NO
	ADDL	(R0),R0			;GET .ADDRESS FROM SRO
	BRB	135$			;SKIP NEXT CONVERSION
133$:	MOVL	(R0),R0			;GET .ADDRESS
135$:	MOVL	R0,WRK_L_IMAGE(R10)	;SET INDEX NUMBER OF NEW IMAGE NAME

145$:	BBC	#CHG_V_PARMS,CHG_B_FLAGS(R6),147$ ; BRANCH IF NO PARAMETER CHANGE
	EXTZV	#CHG_V_MINPARM,#CHG_S_MINPARM,- ;EXTRACT MINIMUM PARAMETERS
		CHG_B_PARMCNT(R6),WRK_L_MINPARM(R10)
	EXTZV	#CHG_V_MAXPARM,#CHG_S_MAXPARM,- ;EXTRACT MAXIMUM PARAMETERS
		CHG_B_PARMCNT(R6),WRK_L_MAXPARM(R10)
	CVTWL	CHG_W_PARMS(R6),R0	;GET OFFSET TO NEW PARAMETER LIST
	BEQL	147$			;IF NONE, LEAVE PROPTR AS IS
	ADDL	R6,R0			;GET ADDRESS OF PARAMETER LIST
	MOVL	R0,WRK_L_PROPTR(R10)	;RESET ADDRESS OF PARAMETER LIST
147$:	BBC	#CHG_V_QUALS,CHG_B_FLAGS(R6),150$ ; BRANCH IF NO QUAL CHANGE
	CVTWL	CHG_W_QUALS(R6),R0	;GET OFFSET TO NEW QUALIFIER LIST
	BEQL	150$			;IF NONE, LEAVE QUABLK AS IS
	ADDL	R6,R0			;GET ADDRESS OF QUALIFIER LIST
	MOVL	R0,WRK_L_QUABLK(R10)	;RESET ADDRESS OF QUALIFIER LIST
;
; INVALIDATE ALL QUALIFIERS IN THE TOKEN ARRAY, INCLUDING THE QUALIFIER
; WE ARE CURRENT PROCESSING, SO THAT ALL QUALIFIERS IN THE PREVIOUS SYNTAX
; ARE NO LONGER ACCESSIBLE.  THIS IS DONE TO PREVENT PREVIOUS QUALIFIERS
; FROM BEING CONFUSED WITH THE CURRENT QUALIFIER NUMBERING SCHEME.  THE
; INVALIDATION IS DONE BY ZEROING THE QUALIFIER NUMBER IN THE TOKEN ARRAY,
; ESSENTIALLY TO RECORD THAT A QUALIFIER WAS DETECTED IN THAT POSITION, BUT
; THAT IT DOESN'T REPRESENT ANY QUALIFIER IN THE CURRENT QUALIFIFER LIST.
;
	CLRL	R7			;INVALIDATE THIS QUAL #
	MOVAB	WRK_G_RESULT-PTR_C_LENGTH(R10),R0 ;GET ADDRESS OF TOKEN ARRAY
148$:	ADDL	#PTR_C_LENGTH,R0	;SKIP TO NEXT ENTRY
	CMPL	R0,WRK_L_RSLNXT(R10)	;REACHED LAST ENTRY STORED?
	BGEQU	150$			;BRANCH IF SO
	ASSUME	PTR_K_COMDQUAL EQ 0
	ASSUME	PTR_K_PARMQUAL EQ 1
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,(R0),#PTR_K_PARMQUAL ;QUALIFIER?
	BGTRU	148$			;SKIP IF NOT
	INSV	#0,#PTR_V_VALUE,#PTR_S_VALUE,(R0) ;ZERO QUAL # (INVALIDATE IT)
	BRB	148$			;LOOP UNTIL ALL QUALIFIERS INVALIDATED
 
;
; KEYWORD VALID - CHECK NEGATION AND GENERATE QUALIFIER DESCRIPTOR
;
 
150$:	BLBC	(SP),160$		;IF LBC QUALIFIER NOT NEGATED
	STATUS	NOTNEG			;ASSUME QUALIFIER NOT NEGATABLE
	BBS	#ENT_V_NEG,ENT_L_FLAGS(R8),160$ ;IF CLR, NOT NEGATABLE
	BRW	390$			;EXIT WITH ERROR
160$:	MOVZBL	#PTR_K_COMDQUAL,R5	;ASSUME COMMAND QUALIFIER
	BBS	#WRK_V_VERB,WRK_W_FLAGS(R10),170$ ;IF SET, PROCESSING VERB
	BBC	#ENT_V_PARM,ENT_L_FLAGS(R8),170$ ;IF CLR, COMMAND QUALIFIER
	MOVZBL	#PTR_K_PARMQUAL,R5	;SET TYPE TO PARAMETER QUALIFIER
170$:	MOVL	(SP),R6			;COPY NEGATION FLAG
	PUSHL	R8			;SAVE ADDRESS OF ENTITY DESCRIPTOR
	MOVL	WRK_L_MARKPTR(R10),R8	;RETRIEVE STARTING ADDRESS OF QUALIFIER
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	POPL	R8			;RESTORE ADDRESS OF ENTITY DESCRIPTOR
 
;
; CHECK FOR VALUE
;
 
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	R0,#^A'='		;VALUE SPECIFIED?
	BEQL	200$			;IF EQL YES
	CMPB	R0,#^A':'		;VALUE SPECIFIED?
	BEQL	200$			;IF EQL YES
	BLBS	(SP),380$		;OK IF QUALIFIER NEGATED AND NO VALUE
	STATUS	VALREQ			;ASSUME VALUE REQUIRED ERROR
	BBS	#ENT_V_VALREQ,ENT_L_FLAGS(R8),390$ ;IF SET, REPORT VALUE IS REQUIRED
	BRB	380$			;OTHERWISE, ITS OK
200$:	STATUS	NOVALU			;ASSUME NO VALUE ALLOWED
	BBC	#ENT_V_VAL,ENT_L_FLAGS(R8),390$	;IF CLR, VALUE NOT ALLOWED

;
; PROCESS QUALIFIER VALUE
;
 
	MNEGL	#2,R5			;SET VALUE STATE VARIABLE
	BSBW	DCL$MOVCHAR		;MOVE EQUAL SIGN
	BSBW	DCL$SETNBLK		;PEEK AT FIRST NON-BLANK AFTER (=)
	CMPB	R0,#^A'('		;START OF VALUE LIST?
	BEQL	240$			;BR IF YES
	BSBW	DCL$BACKUPMOVE		;RESTORE EQUAL SIGN DELIMITER
	BRB	250$			;AND PARSE THE SINGLE VALUE
240$:	INCL	R5			;MARK LIST IS PRESENT
250$:	MOVZBL	#PTR_K_QUALVALU,R3	;SET TOKEN TYPE
	BSBW	DCL$PARSE_VALUE		;PARSE VALUE STRING
	BLBC	R0,390$			;BRANCH IF ERROR DETECTED
	INCL	R5			;COUNT UP THE VALUES SEEN
	BLSS	380$			;BR IF SINGLE VALUE QUALIFIER
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER
	CMPB	R0,#^A','		;TERMINATER SAY MORE VALUES COMING?
	BEQL	250$			;IF MORE COMING, PROCESS THEM
	CMPB	R0,#^A')'		;END OF VALUE LIST?
	BNEQ	350$			;IF NO-ITS AN ERROR
	BSBW	DCL$MOVCHAR		;COPY RIGHT PARENTHESIS DELIMITER
	BSBW	DCL$TESTBLANK		;THROW AWAY INSIGNIFICANT TRAILING BLANKSK
	BSBW	DCL$GENTERM		;SET ACTUAL TERMINATOR INSTEAD OF RPAREN
					;SINCE END OF LIST CAN BE DEDUCED BY
					;NON-QUALVALU TOKEN; AND SINCE BLANK
					;TERMINATOR MARKS A PARAMETER NEXT.
	TSTL	R5			;DID WE GET MORE THAN ONE VALUE?
	BEQL	380$			;BR IF NO (PARENS WERE NOP)
	STATUS	ONEVAL			;ASSUME ONLY ONE VALUE ALLOWED
	BBC	#ENT_V_LIST,ENT_L_FLAGS(R8),390$ ;ERROR IF NO LISTS ALLOWED
	BRB	380$			;CONTINUE
 
;
; INVALID QUALIFIER VALUE SYNTAX
;
 
350$:	STATUS	IVVALU			;SET INVALID SYNTAX
	BRB	390$			;
 
;
; SINGLE VALUE QUALIFIER
;
 
380$:	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION
390$:	ADDL	#4,SP			;CLEAN STACK
	BICW	#WRK_M_QUAL,WRK_W_FLAGS(R10) ;CLEAR QUALIFIER PROCESSING IN PROGRESS
	POPR	#^M<R6,R7,R8>		;RESTORE REGISTERS
	RSB				;

	.SBTTL	PARSE VALUE STRING
;+
; DCL$PARSE_VALUE - PARSE A SINGLE VALUE IN A VALUE LIST
;
; THIS ROUTINE IS CALLED TO SCAN A SINGLE VALUE AND STORE
; THE TOKEN DESCRIPTOR WHICH DESCRIBES IT.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	R10 = ADDRESS OF COMMAND WORK AREA
;
;	CHARACTER POINTER POINTS TO DELIMITER JUST BEFORE THE VALUE STRING
;
; OUTPUTS:
;
;	R0 = STATUS
;
;	INSIGNIFICANT BLANKS ARE THROWN AWAY FOLLOWING THE VALUE.
;	CHARACTER POINTER POINTS TO DELIMITER JUST AFTER THE VALUE STRING.
;
;	ONE (OR TWO) TOKEN DESCRIPTORS ARE OUTPUT DEPENDING ON WHETHER
;	THE SYNTAX WAS 'VALUE' OR 'KEYWORD=VALUE'.
;-

DCL$PARSE_VALUE::
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	BBS	#ENT_V_FILE,ENT_L_FLAGS(R8),5$	;BR IF VALUE IS A FILE SPEC
	MOVZBL	ENT_B_VALTYPE(R8),R0	;GET VALUE TYPE
	CMPB	R0,#ENT_C_INFILE	;INPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_C_OUTFILE	;OUTPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_C_NODE		;NODE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_DEVICE	;DEVICE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_DIR		;DIRECTORY SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_UIC		;UIC SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_RESTOFLINE	;REST OF LINE AS VALUE STRING?
	BNEQ	10$			;BRANCH IF NOT
;
; PROCESS VALUE TYPED AS "RESTOFLINE"
;
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE @ INDIRECTION, SO THAT @
					;CAN BE PASSED IN THE VALUE
	BSBW	DCL$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
8$:	BSBW	DCL$MOVCHAR		;COPY NEXT CHARACTER
	BNEQ	8$			;LOOP UNTIL END OF LINE
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;RE-ENABLE @ INDIRECTION AGAIN
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF MARKED TOKEN
	DECL	R1			;SUBTRACT OUT EOL CHARACTER
	BRB	60$			;STORE THE TOKEN AND EXIT
;
; PROCESS VALUE TYPED AS INFILE, OUTFILE, NODE, DEVICE, DIR OR UIC
;
5$:	BSBW	DCL$PROCFILE		;PARSE THE FILE SPEC
	BRB	90$
;
; PROCESS VALUE TYPED AS STRING (UNTYPED)
;
10$:	BSBW	DCL$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
20$:	BSBW	DCL$GTBTOKEN		;COPY TOKEN INTO EXPANSION BUFFER
	TSTW	ENT_W_KEYWORDS(R8)	;DOES VALUE TAKE KEYWORDS?
	BEQL	30$			;IF NOT, IGNORE EMBEDDED '=:'
	CMPB	R0,#^A'='		;VALUE SEPARATOR?
	BEQL	50$			;BR IF YES
	CMPB	R0,#^A':'		;CHECK IF END OF KEY AND START OF VALUE
	BEQL	50$			;BR IF YES
30$:	LOCC	R0,S^#370$-360$,B^360$	;CHECK FOR VALUE STRING TERMINATOR
	BNEQ	50$			;BR IF TERMINATOR FOUND
	BSBW	DCL$MOVCHAR		;COPY CHARACTER WHICH STOPPED GETOKEN
	BRB	20$			;KEEP GETTING TOKENS UNTIL END OF VALUE
50$:	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF VALUE STRING
	BEQL	80$			;ERROR IF NO VALUE
	BSBW	DCL$COMPRESS		;COMPRESS QUOTED STRING
60$:	MOVL	(SP),R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6			;CLEAR FLAGS
	MOVQ	R1,R7			;SET LENGTH OF VALUE
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	BSBW	DCL$SETCHAR		;GET TERMINATOR CHARACTER
	CMPB	R0,#^A'='		;IS THIS KEYWORD=VALUE CONSTRUCT?
	BEQL	10$			;BR IF YES
	CMPB	R0,#^A':'		;CHECK FOR ALTERNATE SYNTAX
	BEQL	10$			;BR IF YES-GET THE VALUE PART
	BSBW	DCL$TESTBLANK		;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	DCL$GENTERM		;AND SET TERMINATOR IN LAST TOKEN
	MOVL	#1,R0			;SET SUCCESSFUL
90$:	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

80$:	STATUS	IVVALU			;SET INVALID SYNTAX
	BRB	90$
 
;
; VALID TERMINATOR LIST FOR VALUE STRINGS
;
360$:	.ASCII	\ +,/()\<0>		; SPACE,PLUS,COMMA,SLASH,PARENS AND EOL
370$:

	.SBTTL	PROCESS FILE SPECIFICATION
;+
; DCL$PROCFILE - PROCESS FILE SPECIFICATION.
;
; THIS ROUTINE IS CALLED TO SCAN A FILE SPECIFICATION FOR SYNTACTIC CORRECT-
; NESS AND TO EMIT A FILE DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R3 = VALUE CONTEXT (PTR_K_QUALVALU OR PTR_K_PARAMETR) FOR DESCRIPTOR
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF FILE SPECIFICATION STRING, IF SUCCESSFUL
;-
 
DCL$PROCFILE::				;PROCESS FILE SPECIFICATION
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR CHARACTER
	BSBW	DCL$MARK		;MARK CURRENT POSITION IN BUFFER
	BSBW	DCL$GETOKEN		;GET NEXT TOKEN
5$:	BEQL	20$			;IF EQL NONE
 
;
; TOKEN OBTAINED - FORM MUST BE:
;
;	'NODE::' OR,
;	'DEVICE:' OR,
;	'FILENAME.' OR,
;	'FILENAME;' OR,
;	'FILENAME '.
;
 
	CMPB	#^A/:/,R0		;NODE OR DEVICE NAME?
	BNEQ	60$			;IF NEQ NO
 
;
; NODE OR DEVICE NAME
;
 
	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR TO COMMAND BUFFER
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/:/,R0		;NODE NAME?
	BNEQ	10$			;IF NEQ NO
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BRB	5$			;LOOP TO ALLOW ANOTHER NODE NAME

10$:	BSBW	DCL$GTBTOKEN		;GET NEXT BLANK TOKEN
	BNEQ	60$			;IF NEQ TOKEN OBTAINED
 
;
; NO TOKEN OBTAINED - FORM MUST BE:
;
;	'[DIRECTORY]' OR,
;	'<DIRECTORY>' OR,
;	'.TYPE' OR,
;	';VERSION'.
;
 
20$:	CMPB	#^A/[/,R0		;DIRECTORY?
	BEQL	30$			;IF EQL YES
	CMPB	#^A/</,R0		;DIRECTORY?
	BNEQ	60$			;IF NEQ NO
30$:	MOVAB	2(R0),AP		;SAVE DIRECTORY TERMINATOR CHARACTER
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	CMPB	#^A/,/,R0		;OLD STYLE DIRECTORY?
	BNEQ	40$			;IF NEQ NO
 
;
; OLD STYLE DIRECTORY - FORM IS:
;
;	'[GROUP,MEMBER]'.
;
 
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	CMPB	R0,AP			;EXPECTED TERMINATOR?
	BEQL	50$			;BRANCH IF YES
120$:	STATUS	DIRECT			;RETURN INVALID DIRECTORY SYNTAX
	BRB	900$			;AND EXIT WITH ERROR
 
;
; NEW STYLE DIRECTORY - FORM IS:
;
;	'<SUB.SUB...SUB>'.
;
 
40$:	CMPB	R0,AP			;EXPECTED TERMINATOR?
	BEQL	50$			;IF EQL YES
	CMPB	#^A/./,R0		;SUBDIRECTORY?
	BEQL	45$			;IF EQL, TERMINATOR OK
	CMPB	#^A/-/,R0		;BACKUP SYMBOL?
	BNEQ	120$			;IF NEQ, INVALID SYNTAX
45$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BRB	40$			;
50$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
 
;
; FILENAME, TYPE, OR VERSION - FORM MUST BE:
;
;	'FILENAME.' OR,
;	'FILENAME;' OR,
;	'FILENAME ' OR,
;	'.TYPE' OR,
;	';VERSION'.
;
 
60$:	CMPB	#^A/./,R0		;FILE TYPE?
	BNEQ	70$			;IF NEQ NO
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	CMPB	#^A/./,R0		;NEW VERSION FORMAT?
	BEQL	80$			;IF EQL YES
 
;
; FILE VERSION - FORM MUST BE:
;
;	';VERSION'.
;
 
70$:	CMPB	#^A/;/,R0		;FILE VERSION?
	BNEQ	100$			;IF NEQ NO
80$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BNEQ	100$			;IF NON-NULL, GOT VERSION STRING
	CMPB	#^A/-/,R0		;NEGATIVE VERSION?
	BNEQ	100$			;IF NEQ NO
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN

;
; FILE SPECIFICATION SCANNED - CHECK RESULT
;
 
100$:	STATUS	NULFIL			;ASSUME NULL FILE SPECIFICATION
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF PARAMETER STRING
	BEQL	900$			;IF NONE, EXIT WITH ERROR
	MOVQ	R1,R7			;COPY DESCRIPTOR
	CLRL	R6			;CLEAR FLAGS
	MOVL	(SP),R5			;GET VALUE CONTEXT (R3 ON ENTRY)
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	MOVQ	R7,R1			;RETURN FILESPEC DESCRIPTOR TO CALLER
	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION
900$:	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB				;

	.SBTTL	SEARCH VERB TABLE
;---
; DCL$SEARCH_VERB - SEARCH VERB TABLE AND OBTAIN VERB INFORMATION
;
; THIS ROUTINE SEARCHES THE VERB TABLE FOR A SPECIFIED STRING.
; IF FOUND, THE VERB ATTRIBUTES ARE STORED IN THE COMMAND WORK AREA.
;
; INPUTS:
;
;	R8 = ADDRESS OF COMMAND TABLES
;	R1 = LENGTH OF VERB TOKEN
;	R2 = ADDRESS OF VERB TOKEN
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	THE COMMAND WORK AREA IS INITIALIZED IF VERB FOUND
;---

DCL$SEARCH_VERB::
	PUSHR	#^M<R6,R7>		;SAVE REGISTERS
	MOVQ	R1,R4			;SAVE COMMAND VERB DESCRIPTOR
	CMPL	#4,R4			;COMMAND VERB LESS THAN 5 CHARACTERS?
	BGEQ	20$			;IF GEQ YES
	MOVL	#4,R4			;SET TO SCAN ONLY 4 CHARACTERS
20$:	BISB	#^X80,(R5)		;SET HIGH ORDER BIT TO FORCE COMMAND MATCH
	ADDL3	VEC_L_COMDPTR(R8),R8,R7	;SET BASE OF POINTER IN PROMPT BUFFER
	SUBL3	VEC_L_VERBTBL(R8),-	;COMPUTE LENGTH OF DCL VERB
		VEC_L_VERBEND(R8),R0	;TABLE (IN BYTES)
	DIVL3	#4,R0,R6		; ... IN VERBS (4 BYTES PER VERB)
	ADDL3	VEC_L_VERBTBL(R8),R8,R1	;COMPUTE ADDRESS OF VERB TABLE
	MATCHC	R4,(R5),R0,(R1)		;SCAN FOR VERB MATCH
	BEQL	25$			;BR IF VERB MATCH
	ADDL3	VEC_L_USERPTR(R8),R8,R7	;SET BASE ADDRESS OF USER PROMPT BUFFER
	SUBL3	VEC_L_USRCMD(R8),-	;COMPUTE LENGTH OF USER VERB
		VEC_L_USREND(R8),R0	;TABLE (IN BYTES)
	DIVL3	#4,R0,R6		; ... IN VERBS
	ADDL3	VEC_L_USRCMD(R8),R8,R1	;COMPUTE ADDRESS OF USER VERB TABLE
	MATCHC	R4,(R5),R0,(R1)		;SCAN FOR VERB MATCH
	BEQL	25$			;BRANCH IF MATCH FOUND
	STATUS	IVVERB			;INVALID VERB
	BRW	90$
25$:	MOVL	R8,WRK_L_TAB_VEC(R10)	;SAVE ADDRESS OF TABLES VECTOR
	ADDL	R4,R2			;CALCULATE BYTES REMAINING INCLUDING SUBSTRING
	DIVL3	#4,R2,R8		;CALCULATE COMPLEMENT COMMAND INDEX
	SUBW3	R8,R6,R8		;CALCULATE VERB INDEX
	MOVL	WRK_L_TAB_VEC(R10),R1	;GET ADDRESS OF TABLES VECTOR
	CMPB	VEC_B_STRLVL(R1),#2	;STRUCTURE LEVEL 2? (WORD OFFSETS)
	BEQL	27$			;BRANCH IF YES
	MOVAL	(R7)[R8],R0		;GET ADDRESS OF CMD BLOCK OFFSET
	MOVL	(R0)+,R8		;GET DISPLACEMENT TO COMMAND BLOCK
	BRB	28$
27$:	MOVAW	(R7)[R8],R0		;GET ADDRESS OF COMMAND BLOCK DISPLACEMENT
	CVTWL	(R0)+,R8		;GET DISPLACEMENT TO COMMAND BLOCK
28$:	ADDL	R0,R8			;CALCULATE ADDRESS OF COMMAND BLOCK
	BBS	#CMD_V_ABREV,CMD_B_FLAGS(R8),30$ ;IF SET, NON UNIQUE ACCEPTABLE
	SUBL	R4,R3			;BACKUP TO START OF VERB ENTRY FOUND
	CMPC5	R4,(R5),#^A' ',#4,(R3)	;EXACT MATCH?
	BEQL	30$			;IF EXACT MATCH, IGNORE AMBIGUITY
	MATCHC	R4,(R5),#7,(R3)		;SCAN FOR DUPLICATE MATCH
	BNEQ	30$			;IF NEQ UNIQUE MATCH
	STATUS	ABVERB			;AMBIGUOUS COMMAND VERB
	BRB	90$
;
; VERB MATCH FOUND - EXTRACT ATTRIBUTES FROM COMMAND DESCRIPTOR BLOCK
;
30$:	MOVB	CMD_B_VERBTYP(R8),WRK_B_VERBTYP(R10)	;SET VERB GENERIC TYPE
	EXTZV	#CMD_V_MINPARM,-	;EXTRACT MINIMUM NUMBER OF PARAMETERS
		#CMD_S_MINPARM,CMD_B_PARMCNT(R8),WRK_L_MINPARM(R10)
	EXTZV	#CMD_V_MAXPARM,-	;EXTRACT MAXIMUM NUMBER OF PARAMETERS
		#CMD_S_MAXPARM,CMD_B_PARMCNT(R8),WRK_L_MAXPARM(R10)
	CVTWL	CMD_W_IMAGE(R8),R0	;GET OFFSET TO IMAGE NAME
	BGEQ	35$			;BRANCH IF POSITIVE
	MNEGL	R0,R0			;GET INDEX INTO IMAGE NAME TABLE
	BRB	38$
35$:	BSBB	CONVERT_SRO		;GET ADDRESS OF IMAGE NAME
	CMPL	R0,#128			;INTERNAL ROUTINE INDEX?
	BLSS	38$			;YES, THEN SKIP
	BBS	#30,R0,38$		;SKIP IF NOT IN P0 SPACE
	MOVL	WRK_L_TAB_VEC(R10),R1	;GET ADDRESS OF TABLES VECTOR
	CMPB	VEC_B_STRLVL(R1),#5	;STRUCTURE LEVEL 5? (.ADDRESS ROUTINE)
	BGEQ	36$			;BRANCH IF NO
	ADDL	(R0),R0			;GET .ADDRESS FROM SRO
	BRB	38$			;SKIP NEXT CONVERSION
36$:	MOVL	(R0),R0			;GET .ADDRESS
38$:	MOVL	R0,WRK_L_IMAGE(R10)	;ADDRESS OF USER IMAGE
	CVTWL	CMD_W_QUALS(R8),R0	;GET OFFSET TO FIRST QUALIFIER DESC
	BSBB	CONVERT_SRO		;GET ADDRESS OF QUALIFIER DESCRIPTORS
	MOVL	R0,WRK_L_QUABLK(R10)	;SET ADDRESS QUALIFIER DESCRIPTORS
	CVTWL	CMD_W_PARMS(R8),R0	;GET OFFSET TO FIRST POSITIONAL ENTITY
	BSBB	CONVERT_SRO		;GET ADDRESS OF PARAMETER DESCRIPTORS
	MOVL	R0,WRK_L_PROPTR(R10)	;SAVE ADDRESS OF PARAMETER DESCRIPTORS
	CVTWL	CMD_W_OUTPUTS(R8),R0	;GET OFFSET TO OUTPUT LIST
	BSBB	CONVERT_SRO		;GET ADDRESS OF OUTPUT LIST
	MOVL	R0,WRK_L_PAROUT(R10)	;SAVE ADDRESS OF OUTPUT LIST
	CLRL	WRK_L_PARMCNT(R10)	;CLEAR COUNT OF PARAMETERS
	CLRB	WRK_B_CMDOPT(R10)	;CLEAR ENTITY # CAUSING SYNTAX CHANGE
	MOVL	#1,R0			;SUCCESSFUL
90$:	BICB	#^X80,(R5)		;CLEAR TOP BIT OF 1ST CHAR IN LINE
	POPR	#^M<R6,R7>		;RESTORE REGISTERS
	RSB
 
;
; CALCULATE ADDRESS FROM SELF-RELATIVE DISPLACEMENT
;
 
CONVERT_SRO:
	TSTL	R0			;CHECK DISPLACEMENT
	BEQL	110$			;IF EQL NONE
	ADDL	R8,R0			;CALCULATE ACTUAL ADDRESS
110$:	RSB				;

	.END
