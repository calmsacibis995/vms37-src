	.TITLE	EXAMDEP - EXAMINE AND DEPOSIT COMMANDS
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; EXAMINE / DEPOSIT DCLS COMMAND EXECUTION
;
; W. H. BROWN 28-JUL-1977
;
; MODIFIED BY:
;
;	V003	TMH0003		Tim Halvorsen	22-May-1981
;		Prevent infinite loop when attempting to examine location -2.
;
;	V002	TMH0002		Tim Halvorsen	11-Feb-1981
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Use DCL$MARK rather than R6 as error segment pointer.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARKEDTOKEN routine.
;		Set NOSTAT bit in EXAMINE, DEPOSIT routines.
;
;	V001	TMH0001		Tim Halvorsen	02-Sep-1980
;		Use WRK_L_RSLNXT rather than global register R10.
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	PTRDEF				; DEFINE TOKEN DESCRIPTOR
	$CLIMSGDEF			; DEFINE ERROR/STATUS CODES
	$CLIDEFQUALEXAM			; AND LIKEWISE FOR EXAMIN
	$PSLDEF				; PROCESSOR STATUS LONG WORDS

;
; LCOAL DEFINITIONS
;
; DISPLAY CONTROL MODE
;
 
	HEXMOD	=  0			; EXAMINE MODE IS HEX
	DECMOD	=  1			; EXAMINE MODE IS DECIMAL
	OCTMOD	=  2			; EXAMINE MODE IS OCTAL
	ASCMOD	= -1			; EXAMINE MODE IS ASCII
;
; WIDTH CONTROL VALUES
;
	LONGWID	= 4			; LONG WORD WIDTH
	BYTEWID	= 1			; BYTE WIDTH
	WORDWID	= 2			; WORD WIDTH
 
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE	BYTE,RD,NOWRT
 
; DISPLAY WIDTH CONTROL ARRAYS FOR EACH MODE
;
BW:	.BYTE	2,3,3,1			; DISPLAY WIDTH FOR BYTE OF EACH MODE
WW:	.BYTE	4,5,6,2			; LIKEWISE FOR WORD WIDTH
LW:	.BYTE	8,10,8,4		; AND THE SAME FOR LONGWORDS
 
;
; RADIX TABLE FOR NUMERIC CONVERSION.	NOTE:	RADIX 0 IS ASCII CONVERT
;
RADIX:	.BYTE	16,10,8			; RADIX CONVERT TABLE
 
;
; BIT ARRAY TO DEFINE WHICH OPTIONS EFFECT MODE OR WIDTH.
; BIT SET INDICATES MODE SPECIFIER.
;
 
TYPE:	.BYTE	<1@CLI$K_EXAM_ASCI>!-	; ASCII IS A MODE SWITCH
		<1@CLI$K_EXAM_DECI>!-	; DECIMAL IS A MODE SWITCH
		<1@CLI$K_EXAM_HEXA>!-	; HEXIDECIMAL
		<1@CLI$K_EXAM_OCTA>	; AND OCTAL
 
;
; QUALIFIER VALUE TABLE.  THIS ARRAY HAS THE ASSOCIATED DATA FOR
; THE RESPECTIVE OPTION TO BE LOADED INTO THE TABLE.
;
VALU:	.BYTE	ASCMOD,BYTEWID,DECMOD,HEXMOD,LONGWID,OCTMOD,WORDWID
 

	.SBTTL	EXAM/DEPO COMMAND 
;+
; DCL$EXAMINE - EXAMINE MEMORY COMMAND
;
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE EXAMINE
;	DCLS COMMAND.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; WORK AREA LOCATIONS:
;
;	PRC_L_EXMDEPADR HAS "DOT"
;	PRC_B_EXMDEPWID HAS CURRENT WIDTH, IE: BYTE, WORD, LONGWORD.
;	PRC_B_EXMDEPMOD HAS CURRENT MODE, IE: HEX, ASCII, DECIMAL, OCTAL.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT RADIX AND WIDTH ARE SET TO THOSE SPECIFIED,IF ANY.
;	THE SPECIFIED LOCATION(S) ARE DISPLAYED IN THE CURRENT RADIX AND WIDTH.
;-
	.ENABL	LSB
 
DCL$EXAMINE::				;
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10) ;DO NOT SET STATUS ON SUCCESS
	BSBW	GETIVL			; GET LOCATION
	PUSHL	R8			; SAVE VALUE
	TSTB	R0			; END-OF-LINE?
	BEQL	20$			; BR IF YES
	CMPB	#^A/:/,R0		; LIST?
	BEQL	10$			; BR IF OK
	BRW	EXPSYN			; ALL DONE - SYNTAX ERROR
10$:	BSBW	DCL$MOVCHAR		; COPY COLON INTO COMMAND BUFFER
	BSBW	GETVAL			; FIND OTHER LIMIT
20$:	MOVAB	(R8)+,PRC_L_EXMDEPADR(R11) ; SET NEW "DOT"
	POPL	R7			; SET NEXT ADDRESS TO EXAMINE
EXAMIN:	MOVL	R7,R0			; GET A COPY OF CURRENT ADDRESS
	MOVAB	(SP),R2			; BUFFER TO USE
	BSBW	DCL$CNVHXL		; FORMAT HEX LONGWORD
	MOVW	#^A/: /,(R2)+		; SEPARATE ADDRESS FOR CONTENTS
	CLRL	R1			; BUFFER WIDTH ADJUSTMENT OF ZERO
40$:	ADDL	R1,R2			; POINT AT NEXT FREE BYTE
	MOVB	#^A/ /,(R2)+		; SPACE OUT FOR NEATNESS
	MOVZBL	PRC_B_EXMDEPWID(R11),R3	; GET WIDTH OF CELL TO DISPLAY
	IFNORD	R3,(R7),50$,#PSL$C_USER ; CHECK FOR USER ACCESS TO DATA
	BBS	#PRC_V_EXEONLY,PRC_B_FLAGS2(R11),50$ ; NOT READABLE IF EXECUTE ONLY
	CVTBL	PRC_B_EXMDEPMOD(R11),R1	; MODE WE ARE DISPLAYING IN
	BLSS	90$			; BR IF ASCII MODE
	CMPL	R3,#2			; CHECK WIDTH OF DISPLAY
	BGTR	70$			; IF GTR THAN WIDTH IS LONGWORD
	BEQL	60$			; BR IF WORD WIDTH
	MOVZBL	(R7)+,R0		; BYTE WIDTH - GET VALUE
	MOVZBL	BW[R1],R3		; WIDTH OF FORMATED DISPLAY
	BRB	80$			;
50$:	MOVL	R7,R8			; TERMINATE DISPLAY AFTER THIS LINE
	MOVL	#^A/****/,(R2)+		; INDICATE ACCESS VIOLATION
	BRB	110$			; SHOW WHAT WE HAVE TO SHOW
60$:	MOVZWL	(R7)+,R0		; VALUE
	MOVZBL	WW[R1],R3		; GET WIDTH FOR WORD DISPLAY
	BRB	80$			; 
70$:	MOVL	(R7)+,R0		; VALUE
	MOVZBL	LW[R1],R3		; WIDTH OF FORMATTED DISPLAY
80$:	PUSHR	#^M<R3>			; SAVE WIDTH
	MOVZBL	RADIX[R1],R1		; RADIX
	BSBW	DCL$CNVNUM		; GET VALUE
	POPR	#^M<R0>			; GET WIDTH OF DISPLAY INTO R0
	BRB	110$			;
90$:	DECL	R2			; BACK OVER SPACE
	MOVL	R3,R0			; COPY WIDTH OF DISPLAY
100$:	MOVB	(R7)+,(R2)		; COPY DATA INTO OUTPUT BUFFER
	CMPB	(R2)+,#^A/ /		; CHARACTER PRINTABLE ?
	BGEQ	105$			; BR IF YES
	MOVB	#^A/./,-1(R2)		; IF NO-PRINT A "DOT"
105$:	SOBGTR	R3,100$			; MOVE ENOUGH BYTES?
110$:	SUBL3	SP,R2,R1		; SET BYTE COUNT IN THE LINE
	MOVL	SP,R2			; STARTING ADDRESS
	ADDL	R1,R0			; ADD COUNT FOR NEXT DISPLAY
	CMPB	R0,#76			; ENOUGH ROOM FOR STRING PLUS SPACE
	BGEQU	120$			; BR IF NOT ENOUGH
	CMPL	R7,R8			; FINISHED?
	BGEQU	120$			; BR IF NO MORE TO PRINT
	BRW	40$			; ELSE PRINT SOME MORE
120$:	BSBW	DCL$MSGOUT		; PRINT IT
	CMPL	R7,R8			; DONE?
	BGEQU	130$			; BR IF YES
	BRW	EXAMIN			; ELSE FORMAT ANOTHER LINE
130$:	STATUS	NORMAL
160$:	BRW	EXIT			; EXIT
 
;+
; GETIVL - GET INITIAL VALUE FROM THE COMMAND LINE.
;
; GETVAL - GET NEXT VALUE FROM THE COMMAND LINE.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; WORK AREA LOCATIONS:
;
;	PRC_L_EXMDEPADR HAS "DOT"
;	PRC_B_EXMDEPWID HAS CURRENT WIDTH, IE: BYTE, WORD, LONGWORD.
;	PRC_B_EXMDEPMOD HAS CURRENT MODE, IE: HEX, ASCII, DECIMAL, OCTAL.
;
; OUTPUTS:
;
;	ANY QUALIFIERS IN THE COMMAND LINE PRECEEDING THE NEXT VALUE
;	ARE PROCESSED AND THE NEXT EXPRESSION ON THE COMMAND LINE
;	IS EVALUATED AND RETURN IN R8.  REGISTERS R0 TO R8 ARE MODIFIED.
;	WRK_L_EXPANDPTR IS UPDATED TO THE NEXT BYTE IN THE EXPANSION BUFFER.
;-
 
	.ENABL	LSB
 
10$:	.ASCII	<0>\:=,\		; SPECIAL TERMINATORS FOR "DOT"
11$:
;
; RADIX CONVERT TABLE - COVERT DISPLAY MODE TO RADIX INDEX
;
	.BYTE	PRC_K_HEX		; MINUS ONE INDEX(ASCII)-CONVERT IN HEX
15$:	.BYTE	PRC_K_HEX,PRC_K_DEC,PRC_K_OCT ; RADIX TRANSLATE
 
GETIVL:	POPR	#^M<R0>			; GET RETURN ADDRESS
	MOVL	SP,WRK_L_SAVSP(R10)	; MARK THE STACK FOR ERRORS
	MOVAB	-80(SP),SP		; ALLOCATE A LINE BUFFER
	PUSHL	R0			; REPLACE RETURN ADDRESS
GETVAL:	BSBB	130$			; PEEK AT NEXT CHARACTER IN INPUT
	BSBW	DCL$MARK		; MARK CURRENT PARSE POSITION
	CMPB	#^A/ /,R0		; BLANK?
	BNEQ	20$			; BR IF NO AND CONTINUE
	BSBW	DCL$MOVCHAR		; ELSE COPY SPACE TO BUFFER
	BRB	GETVAL			; TRY AGAIN
20$:	CMPB	R0,#^A\/\		; QUALIFIER COMMING?
	BNEQ	40$			; BR IF NO QUALIFIER IN SIGHT
	BSBW	DCL$PROCQUAL		; PROCESS THE QUALIFIER
	BLBC	R0,EXIT			; BR IF ERROR IN QUALIFIER
	SUBL3	#PTR_C_LENGTH,WRK_L_RSLNXT(R10),R1 ; ADDRESS OF PREVIOUS TOKEN DESCRIPTOR
	MOVB	PTR_B_VALUE(R1),R0	; GET QUALIFIER CODE
	MOVAB	PRC_B_EXMDEPWID(R11),R1	; ASSUME CHANGING WIDTH
	BBC	R0,TYPE,30$		; BR IF ASSUMED CORRECTLY
	INCL	R1			; POINT AT MODE LOCATION
30$:	MOVB	VALU-1[R0],(R1)		; SET MODE OR WIDTH
	BRB	GETVAL			; TRY FOR MORE
40$:	CLRL	R8			; ZERO ACCUMULATOR
	CMPB	#^A/./,R0		; REFERENCE TO LAST LOCATION
	BNEQ	50$			; BR IF NO
	MOVL	PRC_L_EXMDEPADR(R11),R8	; GET THE PREVIOUS LOCATION
	BSBW	DCL$MOVCHAR		; PUT DOT INTO COMMAND BUFFER
	BSBB	130$			; LOOK AT NEXT CHAR
	LOCC	R0,#<11$-10$>,10$	; ANY OF THE SPECIAL TERMINATORS
	BNEQ	130$			; BR IF YES-NO EXPRESSION TO EVALUATE
50$:	PUSHL	R8			; SAVE INITIAL VALUE
	CVTBL	PRC_B_EXMDEPMOD(R11),R1	; GET MODE OF OPERATION
	MOVZBL	15$[R1],R1		; CONVERT TO SYSTEM STANDARD RADIX
	BSBW	DCL$EXPRADIX		; EXPRESSION WITH RADIX
	BLBC	R0,EXIT			; BR IF ERROR EVALUATING EXPRESSION
	BSBW	DCL$MARK		; MARK CURRENT PARSE POSITION
	ADDL3	R1,(SP)+,R8		; GET FINAL VALUE TO WORK WITH
130$:	BSBW	DCL$SETNBLK		; PEEK AT NEXT NON-BLANK CHAR
	RSB				;
 
EXPSYN:	STATUS	EXPSYN			; SYNTAX ERROR
EXIT:	MOVL	WRK_L_SAVSP(R10),SP	; CLEAR THE STACK
	RSB				; RETURN TO CALLER
	.DSABL	LSB
 
OVRFLW:	STATUS	OVRFLW			; VALUE TO LARGE FOR CELL
	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(R10) ; INDICATE ERROR DURING EXECUTION
	BRB	EXIT			; SHOW ERROR
 
;+
; DCL$DEPOSIT - DEPOSIT DATA IN MEMORY
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEPOSIT
;	DCLS COMMAND.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; WORK AREA LOCATIONS:
;
;	PRC_L_EXMDEPADR HAS "DOT"
;	PRC_B_EXMDEPWID HAS CURRENT WIDTH, IE: BYTE, WORD, LONGWORD.
;	PRC_B_EXMDEPMOD HAS CURRENT MODE, IE: HEX, ASCII, DECIMAL, OCTAL.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT RADIX AND WIDTH ARE SET TO THOSE SPECIFIED,IF ANY.
;	THE SPECIFIED LOCATION(S) ARE SET IN THE CURRENT RADIX AND WIDTH.
;-
 
SHFCNT:	.BYTE	-8,-16,0,-31		; SHIFT COUNT FOR SIGN EXTEND
 
DCL$DEPOSIT::				; DEPOSIT DATA IN MEMORY
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10) ;DO NOT SET STATUS ON SUCCESS
	BSBW	GETIVL			; INIT AND GET VALUE
	CMPB	#^A/=/,R0		; VALID TERMINATOR
	BNEQ	EXPSYN			; BR ON SYNTAX ERROR
	PUSHL	R8			; SAVE INITIAL VALUE
	MOVL	R8,R7			; SET AS LAST LOCATION USED("DOT").
10$:	BSBW	DCL$MOVCHAR		; MOVE TERMINATOR
	CMPB	PRC_B_EXMDEPMOD(R11),#ASCMOD ; DOING ASCII
	BNEQ	40$			; BR IF NO
	BSBW	DCL$MARK		; MARK CURRENT POSITION IN BUFFER
20$:	BSBW	DCL$MOVCHAR		; MOVE NEXT CHARACTER
	BNEQ	20$			; UNTIL END OF LINE
	BSBW	DCL$MARKEDTOKEN		; GET DESCRIPTOR OF STRING
	DECL	R1			; DISCOUNT EOL CHARACTER
	BEQL	40$			; BR IF NULL STRING
	BSBW	DCL$COMPSTRING		; COMPRESS THE STRING
	IFNOWRT	R1,(R7),90$,#PSL$C_USER	; VERFIFY PROPER ACCESS
	BBS	#PRC_V_EXEONLY,PRC_B_FLAGS2(R11),90$ ; NOT WRITEABLE IF EXECUTE ONLY
	MOVC3	R1,(R2),(R7)		; STORE THE DATA
	MOVL	R3,R7			; SET ENDING ADDRESS
	BRB	90$			; SHOW THE DAMAGE
40$:	MOVZBL	PRC_B_EXMDEPWID(R11),R2	; SET WIDTH OF OPERATION
	IFNOWRT	R2,(R7),90$,#PSL$C_USER	; VERIFY PROPER ACCESS
	BBS	#PRC_V_EXEONLY,PRC_B_FLAGS2(R11),90$ ; NOT WRITEABLE IF EXECUTE ONLY
	PUSHL	R7			; SAVE ADDRESS TO DEPOSIT
	BSBW	GETVAL			; GET VALUE
	POPL	R7			; RESTORE THE ADDRESS
	MOVZBL	PRC_B_EXMDEPWID(R11),R2	; SET WIDTH
	MOVZBL	SHFCNT-1[R2],R1		; GET SHIFT COUNT
	ASHL	R1,R8,R1		; GET THE SIGN OF THE VALUE
	BEQL	50$			; BR IF POSITIVE NUMBER
	INCL	R1			; NEGATIVE SIGN?
	BEQL	50$			; BR IF NO-OVERFLOW HAS OCCURED
	BRW	OVRFLW
50$:	SUBL	#2,R2			; DECODE WIDTH
	BGTR	70$			; BR IF LONGWORD
	BLSS	60$			; BR IF BYTE
	MOVW	R8,(R7)+		; STORE DATA
	BRB	80$			;
60$:	MOVB	R8,(R7)+		; STORE DATA
	BRB	80$			;
70$:	MOVL	R8,(R7)+		; ETC
80$:	TSTB	R0			; END OF LINE
	BEQL	90$			; BR IF YES
	BRW	10$
90$:	MOVAB	(R7),R8			; SET UPPER LIMIT
	MOVL	R7,PRC_L_EXMDEPADR(R11)	; SET "DOT"
	POPL	R7			; GET FIRST VALUE
	BRW	EXAMIN			; PRINT THE RESULT
;+
; DCL$CNVNUM - CONVERT NUMBER
;
; THIS ROUTINE CONVERTS A BINARY NUMBER INTO A ASCII STRING IN ANY RADIX
; FROM 2-9 OR HEX.
;
; INPUTS:
;	R0 = NUMBER
;	R1 = RADIX
;	R2 = BUFFER TO STORE RESULT
;	R3 = NUMBER OF CHARACTERS
;
; ALTERNATE ENTRY DCL$CNVHXL - FOR CONVERSION OF HEX LONG WORDS
;
;
; OUTPUTS:
;	THE NUMBER IS CONVERTED TO  STRING, AND THE BUFFER POINTER
;	IS ADVANCE TO BEYOND THE LAST CHARACTER.
;-
 
DCL$CNVHXL::				; CONVERT HEX LONG WORD
	MOVL	#8,R3			; SET NUMBER OF CHARATERS TO OUTPUT
	MOVL	#16,R1			; AND RADIX
 
DCL$CNVNUM::				; CONVERT NUMBER TO STRING
	MOVL	R1,AP			; SAVE RADIX IN SCRATCH REGISTER
	CLRL	R1			; SET EXTENDED WORD OF ZERO
10$:	EDIV	AP,R0,R0,-(SP)		; REMOVE THE RADIX
	ADDB	#^A/0/,(SP)		; CONVERT TO ASCII
	CMPB	(SP),#^A/9/		; DECIMAL NUMBER
	BLEQU	20$			; BR IF YES
	ADDB	#7,(SP)			; SET TO HEX CHARACTER
20$:	DECL	R3			; COUNT DOWN THE NUMBER OF CHARACTERS
	BEQL	40$			; BR IF DONE
	BGTR	30$			; BR IF NO ZERO SUPPRESSION
	TSTL	R0			; ANY MORE DATA?
	BEQL	40$			; BR IF NO
30$:	BSBB	10$			; CONVERT NEXT DIGIT
40$:	CVTLB	(SP)+,(R2)+		; STORE A DIGIT
	RSB				; UNWIND RECURSIVE LOOP
 
	.END
