	.TITLE	COMMAND - PROCESS NEXT COMMAND
	.IDENT	'V03-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PROCESS NEXT COMMAND 
;
; D. N. CUTLER  22-MAR-77
;
;  MODIFIED BY:
;
;	V03-002	PHL0049		Peter H. Lipman	23-Apr-1982
;		Use common DCL$FORCEXIT routine to rundown the
;		privileged image.  It relocates possible address
;		in R2 if stack was shuffled.
;
;	V03-001	PHL0045		Peter H. Lipman	14-Apr-1982
;		Delay rundown of privileged image until command dispatch
;		to allow CONTINUE, SPAWN, and ATTACH commands.
;
;	V017	PCG0001		Peter George	08-Feb-1982
;		Clear WRK block at beginning of command processing.
;		Use common DCL$SEARCH_VERB instead of local SEARCH_VERB.
;
;	V016	TMH0016		Tim Halvorsen	02-Jan-1982
;		Setup use of new character processing routines in
;		the new module READREC before calling character parsing
;		routines.
;
;	V015	TMH0015		Tim Halvorsen	29-Oct-1981
;		Double size of scratch buffer to internal routines.
;		This allows SHOW SYMBOL to display symbols which are
;		longer than 255 characters.
;
;	V014	TMH0014		Tim Halvorsen	05-Sep-1981
;		Disallow indirection when peeking at the next character
;		after the colon in a label so that we don't have the
;		indirect level shifted on us.  Otherwise, the label gets
;		stored in the label table for the wrong level.
;
;	V013	TMH0013		Tim Halvorsen	26-Aug-1981
;		Initialize CMDOPT cell which indicates the first
;		syntax change made.
;
;	V012	TMH0012		Tim Halvorsen	09-Aug-1981
;		Accept structure level 3 tables as well as level 2.
;		Level 3 is the same, except that the pointer table
;		is longword offsets rather than word offsets.
;
;	V011	TMH0011		Tim Halvorsen	30-Jul-1981
;		Do not use underscore prompt if in ctrl/y level, even
;		though we may still be in a procedure context.
;
;	V010	MTR0001		Mike Rhodes	 9-Jul-1981
;		Add new prompt selection logic based on PRC_L_INDEPTH,
;		to routine DCL$CMDSTART.
;
;		If PRC_L_INDEPTH is zero;
;		Then
;			WRK_L_PROMPT(R10) = '$ ';	!Main command level.
;		Else
;			WRK_L_PROMPT(R10) = '$_';	!Indirect command level.
;		Endif;
;
;	V009	TMH0009		Tim Halvorsen	27-Apr-1981
;		Rename PRC_L_INDEPTH to PRC_L_INDCLOCK.  Make use
;		of new cell PRC_L_INDEPTH to determine if we
;		are level 0 or not.
;
;	V008	TMH0008		Tim Halvorsen	05-Apr-1981
;		Rewrite DCL$ABORT to take advantage of normal
;		external image execution path, so that it sets
;		up the scratch stack and buffer descriptor.
;
;	V007	TMH0007		Tim Halvorsen	20-Mar-1981
;		Do not allow labels in level 0 interactive mode.
;		Call general value parsing routine rather than assuming
;		that all parameters are file specifications.  This means
;		that all definitions of parameters which take filespecs
;		must be declared as one in the tables to be compatible.
;
;	V006	TMH0006		Tim Halvorsen	16-Mar-1981
;		Output space after foreign command filespec.
;
;	V005	TMH0005		Tim Halvorsen	11-Feb-1981
;		Use DCL$MARK rather than R6 as a display pointer.
;		Use WRK_L_EXPANDPTR rather than R9.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARKEDTOKEN routine.
;		Pass symbol type when creating symbols
;		Call SYM_STRING rather than SEARCH to get symbols.
;		Set NOSTAT bit in EOD routine.
;		Ignore NOSTAT bit in CMD block since it is now set by
;		the individual routines that need it.
;		Clean up on controly code and remove an unneeded instruction.
;
;	V004	TMH0004		Tim Halvorsen	11-Oct-1980
;		Do not sort token table if external image.  The existing
;		check for external image was incomplete.
;
;	V003	TMH0003		Tim Halvorsen	08-Oct-1980
;		Do not report an ambiguous verb if its an exact match.
;
;	V002	TMH0002		Tim Halvorsen	29-Aug-1980
;		Use new MDL structures.  Create subroutines SEARCH_VERB
;		and ISSUE_PROMPT.  Remove allocation of scratch prompt
;		string storage in DCL$RESTART.  Process qualifiers typed
;		at a required parameter prompt as parameter qualifiers.
;		Terminate command processing if control/z typed at a
;		prompt.  Remove uses of R10 as result parse array pointer
;		so that it can be used as the base register of WRK --
;		use WRK_L_RSLNXT instead.  Add comments liberally.
;
;	V001	TMH0001		Tim Halvorsen	06-Jun-1980
;		Fix ambiguity detection in verb parsing
;--

;
; MACRO LIBRARY CALLS
;
 
	VECDEF				; DEFINE TABLE VECTOR
	CMDDEF				; COMMAND DESCRIPTOR BLOCK
	ENTDEF				; ENTITY DESCRIPTOR BLOCK
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	SYMDEF				; DEFINE SYMBOL ENTRY OFFSETS
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	$CLIMSGDEF			; DEFINE ERROR/STATUS VALUES
	$DEVDEF				; DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				; DEFINE RAB OFFSETS

CTRLZ	= 26				; CONTROL/Z CHARACTER
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

DCL$T_PROMPT::
	.ASCIC	'$ '			; DEFAULT PROMPT STRING
DCL$T_REPROMPT::
	.ASCIC	'$_'			;CONTINUATION PROMPT STRING

	.SBTTL	PROCESS NEXT COMMAND
;+
; DCL$RESTART - PROCESS NEXT COMMAND
;
; THIS ROUTINE IS THE CENTRAL COMMAND PARSE AND DISPATCH ROUTINE FOR THE
; STARLET DCLS COMMAND LANGUAGE INTERPRETER. IT INITIALIZES FOR THE NEXT
; COMMAND, READS AND PARSES THE COMMAND FOR SYNTACTIC CORRECTNESS, AND THEN
; EXECUTES THE APPROPRIATE IMAGE.
;
; INPUTS:
;
;	FP =	ADDRESS OF WRK STRUCTURE
;	R11 =	ADDRESS OF PRC STRUCTURE
;
; OUTPUTS:
;
;	COMMAND IS READ, PARSED, AND AN IMAGE IS ACTIVATED.
;-
	.ENABL	LSB

DCL$RESTART::				;RESTART ENTRY POINT
	MOVL	FP,R10			;SET BASE ADDRESS OF WRK
	MOVAB	W^DCL$HYPHEN-1,WRK_L_CHARPTR(R10) ;SET TO FORCE INPUT ON NEXT GET


	.SBTTL	PROCESS REST OF COMMAND
;+
; DCL$CMDSTART - PROCESS REST OF COMMAND
;
; THIS ROUTINE IS THE CENTRAL COMMAND PARSE AND DISPATCH ROUTINE FOR THE
; STARLET DCLS COMMAND LANGUAGE INTERPRETER. IT INITIALIZES FOR THE COMPLETION
; OF THE CURRENT COMMAND LINE, READS AND PARSES THE COMMAND FOR SYNTACTIC 
; CORRECTNESS, AND THEN EXECUTES THE APPROPRIATE IMAGE.
;
; INPUTS:
;
;	FP =	ADDRESS OF WRK STRUCTURE
;	R11 =	ADDRESS OF PRC STRUCTURE
;	WRK_L_CHARPTR(FP) =	POINTER INTO COMMAND INPUT BUFFER
;	WRK_G_BUFFER(FP) =	COMMAND EXPANSION BUFFER
;	WRK_G_INPBUF(FP) =	COMMAND INPUT BUFFER
;
; OUTPUTS:
;
;	COMMAND IS READ, PARSED, AND AN IMAGE IS ACTIVATED.
;-

DCL$CMDSTART::				;COMMAND PROCESSING ENTRY POINT
;
; ALLOCATE AND INITIALIZE COMMAND SCRATCH WORK AREA
;
	MOVAB	WRK_K_LENGTH(FP),SP	;ALLOCATE COMMAND IMPURE AREA
					;AND RESET STACK POINTER
	MOVL	FP,R10			;SET BASE ADDRESS OF WRK
	MOVAB	DCL$T_PROMPT,WRK_L_PROMPT(R10)	;SET ADDRESS OF PROMPT STRING
	TSTL	PRC_L_INDEPTH(R11)	;ARE WE AT COMMAND LEVEL 0?
	BEQL	2$			;YES -- PROMPT STRING = '$ '
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),2$ ;USE '$ ' IF CONTROL/Y LEVEL
	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),2$ ;(ALSO IF CTRL/Y JUST HIT)
	MOVAB	DCL$T_REPROMPT,WRK_L_PROMPT(R10) ;NO -- PROMPT STRING = '$_'
2$:	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;SET ADDRESS OF EXPANSION BUFFER
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;SET ADDRESS OF RESULT PARSE TABLE
	MOVAB	DCL$INPUT,WRK_L_READRTN(R10)	;SET RECORD INPUT ROUTINE
	MOVAB	DCL$SPECIAL,WRK_L_SPECRTN(R10)	;SET SPECIAL PROCESSING ROUTINE
	MOVAB	DCL$CHARERROR,WRK_L_ERRORRTN(R10) ;SET ERROR HANDLER ROUTINE
	CLRW	WRK_W_FLAGS(R10)	;RESET COMMAND FLAGS
	CLRL	WRK_L_RSLEND(R10)	;ZERO ADDRESS OF LAST TOKEN DESCRIPTOR
	ASSUME  <WRK_L_QUABLK-WRK_L_PROPTR> EQ 4
	CLRQ	WRK_L_QUABLK(R10)	;ZERO QUABLK AND PROPTR
	ASSUME  <WRK_L_MINPARM-WRK_L_MAXPARM> EQ 4
	CLRQ	WRK_L_MINPARM(R10)	;ZERO MINPARM AND MAXPARM
	CLRL	WRK_L_IMAGE(R10)	;ZERO ADDRESS OF IMAGE NAME
	ASSUME  <WRK_L_PAROUT-WRK_L_PARMCNT> EQ 4
	CLRQ	WRK_L_PAROUT(R10)	;ZERO PAROUT AND PARMCNT
	BICW	#PRC_M_DISABL!-		;RE-ENABLE CONTROL Y/C'S
		PRC_M_IND,PRC_W_FLAGS(R11) ;RE-ENABLE @ PROCESSING
	CLRBIT	PRC_V_RUNDEF,PRC_B_FLAGS2(R11) ;CLEAR IMAGE RUN DEFAULT FLAG
;
; IF CONTROL/Y PENDING, EXECUTE "ON CONTROLY" STATEMENT
;
	BBCC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),11$ ;BRANCH IF NOT CONTROL Y/C
	MOVL	PRC_L_ONCTLY(R11),R1	;GET ADDRESS OF ACTION COMMAND
	BEQL	5$			;BR IF NO ACTION OUTSTANDING
	MOVZBL	(R1)+,R0		;GET THE ADDRESS AND COUNT
	MOVC	R0,(R1),WRK_G_INPBUF(R10) ;MOVE COMMAND INTO BUFFER
	BRB	15$			;CLEAR GOTO, THEN PROCESS COMMAND
5$:	SETBIT	PRC_V_YLEVEL,PRC_W_FLAGS(R11) ;SET CONTROL Y/C LEVEL
	BRB	20$
;
; IF CHAINED COMMAND OR CHAINED IMAGE, COPY COMMAND INTO COMMAND BUFFER
; AND DEALLOCATE STORAGE USED TO HOLD THE COMMAND.
;
11$:	MOVAQ	PRC_Q_COMMAND(R11),R6	;GET DESCRIPTOR OF COMMAND LINE
	BBSC	#PRC_V_CMD,PRC_B_FLAGS2(R11),13$ ;BRANCH IF USER COMMAND SETUP
	BBCC	#PRC_V_CHAIN,PRC_B_FLAGS2(R11),20$ ;BRANCH IF NOT USER CHAIN
	MOVAQ	PRC_Q_IMAGENAME(R11),R6	;GET DESCRIPTOR OF IMAGE TO INVOKE
	SETBIT	PRC_V_RUNDEF,PRC_B_FLAGS2(R11) ;SET RUN DEFAULT
13$:	MOVC	(R6),@4(R6),WRK_G_INPBUF(R10) ;SET STRING IN BUFFER
	BSBW	DCL$ALLDEACMD		;GO DEALLOCATE THE SPACE
;
; IF CONTROL IS TO BE TRANSFERED TO AN ON-CONTROLY CONDITION OR A CHAINED
; COMMAND, THEN TERMINATE ANY FORWARD GOTO IN PROGRESS.
;
15$:	MOVAB	WRK_G_INPBUF-1(R10),WRK_L_CHARPTR(R10) ;SET POINTER BEFORE RECORD
	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),20$ ;BR IF NOT IN A GOTO
	BSBW	DCL$DEALGOTO		;DEALLOCATE THE CONTROL BLOCK
;
; IF HANGUP PENDING, ABORT PROCESS
;
20$:	BBC	#PRC_V_HANGUP,PRC_W_FLAGS(R11),22$ ;IF SET, HANGUP PENDING
	BRW	DCL$ABORT		; LOG PROCESS OUT
;
; IF CHAINED IMAGE, CALL THE IMAGE IMMEDIATELY
;
22$:	BBC	#PRC_V_RUNDEF,PRC_B_FLAGS2(R11),23$ ;BRANCH IF NOT CHAIN IMAGE
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BRW	FORVERB			;PARSE AS FOREIGN COMMAND
;
; BEGIN PARSING THE INPUT RECORD, STRIP LEADING '$' (IF ANY)
;
25$:	BRW	DCL$RESTART		;NULL LINE - START OVER

23$:	BSBW	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	BEQL	25$			;IF EQL NULL LINE
30$:	CMPB	#^A/$/,R0		;DOLLAR SIGN?
	BNEQ	40$			;IF NEQ NO-PROCESS THE COMMAND
	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;RESET EXPANSION BUFFER POINTER
	BSBW	DCL$MOVCHAR		;PUT DOLLAR SIGN IN BUFFER
	PUSHL	PRC_L_INDCLOCK(R11)	;SAVE CURRENT INDIRECT CHANGE COUNT
	BSBW	DCL$SETNBLK		;POINT AT NEXT NON-BLANK CHARACTER
	BEQL	25$			;BRANCH IF NULL LINE TO DCL$RESTART
	CMPL	PRC_L_INDCLOCK(R11),(SP)+ ;INDIRECT LEVEL CHANGE?
	BNEQ	30$			;IF YES-LOOK FOR LEADING DOLLAR SIGN
;
; GET FIRST TOKEN FROM COMMAND LINE (EITHER VERB, SYMBOL OR LABEL)
;
40$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$GETOKEN		;GET COMMAND VERB, SYMBOL, OR LABEL
	BEQL	60$			;IF EQL NO VERB, SYMBOL, OR LABEL
	CMPB	#^A':',R0		;LABEL OR STRING EQUATE TERMINATOR?
	BEQL	45$			;BRANCH IF LABEL
	BRW	90$			;ELSE, VERB OR ASSIGNMENT STATEMENT
 
;
; LABEL OR STRING EQUATE ENCOUNTERED.  WE TEMPORARILY DISALLOW INDIRECTION
; WHEN PEEKING AT THE NEXT CHARACTER AFTER THE COLON, SO THAT IF AN "@"
; APPEARS JUST AFTER THE LABEL, WE DON'T GET SHIFTED TO THE NEXT LEVEL
; BEFORE WE GET A CHANCE TO PUT THE LABEL ENTRY IN THE RIGHT TABLE.
;
 
45$:	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;TEMPORARILY DISALLOW INDIRECTION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;RESTORE INDIRECTION
	CMPB	#^A/=/,R0		;EQUAL SIGN?
	BEQL	70$			;IF EQL YES
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),50$ ;IF SET, AT CONTROL Y/C LEVEL
	MOVL	PRC_L_INDINPRAB(R11),R0	;DEVICE CHAR SAVED IN CURRENT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R0),55$ ;IF TRM, ISSUE WARNING MESSAGE
	BBC	#DEV$V_RND,RAB$L_CTX(R0),50$ ;IF NOT RANDOM DEVICE, IGNORE IT
	MOVAB	PRC_Q_LABEL(R11),R5	;GET ADDRESS OF LABEL TABLE LISTHEAD
	MOVQ	R1,R3			;SET LABEL NAME PARAMETERS
	MOVAB	RAB$W_RFA(R0),R2	;SET ADDRESS OF RECORD FILE ADDRESS
	MOVZBL	#6,R1			;SET LENGTH OF RECORD FILE ADDRESS
	MOVL	#SYM_K_LABEL,R0		;SET TYPE OF SYMBOL
	DISABLE				;DISABLE CONTROL Y/C AST'S
	BSBW	DCL$ALLOCSYM		;ALLOCATE AND INSERT LABEL IN TABLE
	BLBC	R0,130$			;IF LBC ALLOCATION FAILURE
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),50$ ;IF CLR, NO GOTO
	MOVL	PRC_L_SYMBOL(R11),R2	;GET ADDRESS OF GOTO LABEL NAME
	MOVZBL	(R2)+,R3		;GET LENGTH OF GOTO LABEL
	CMPB	SYM_T_SYMBOL(R1),R3	;LENGTH OF LABEL NAMES MATCH?
	BNEQ	100$			;IF NEQ NO
	CMPC	R3,SYM_T_SYMBOL+1(R1),(R2) ;SYMBOL NAMES MATCH?
	BNEQ	100$			;IF NEQ NO
	CLRBIT	PRC_V_GOTO,PRC_W_FLAGS(R11) ;CLEAR GOTO IN PROGRESS FLAG
	MOVL	PRC_L_SYMBOL(R11),R2	;GET ADDRESS OF GOTO LABEL NAME
	MOVZBL	(R2)+,R1		;GET LENGTH OF GOTO LABEL
	BSBW	DCL$POSITION		;POSITION FILE TO GOTO LABEL
	BSBW	DCL$DEALGOTO		;DEALLOCATE THE GOTO LABEL
	BRB	110$			;REREAD GOTO LINE (THIS TIME W/VERIFY
					;AND SUBSTITUTIONS ENABLED)
55$:	ERRMSG	NOLBLS			;SIGNAL LABEL NOT ALLOWED HERE
50$:	BRW	DCL$CMDSTART		;START COMMAND OVER
 
;
; NO COMMAND VERB, SYMBOL, OR LABEL
;
 
60$:	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),100$ ;IF SET, GOTO IN PROGRESS
	BRW	NOCOMD			;ELSE BAD COMMAND LINE SYNTAX
 
;
; STRING EQUATE
;
 
70$:	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),80$ ;IF SET, AT CONTROL Y/C LEVEL
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),100$ ;IF SET, GOTO IN PROGRESS
80$:	BSBW	DCL$EQUATE		;PROCESS STRING EQUATE STATEMENT
	BRB	130$			;
 
;
; COMMAND VERB OR ASSIGNMENT ENCOUNTERED
;
 
90$:	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),SYMBOL ;IF SET, AT CONTROL Y/C LEVEL
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),SYMBOL ;IF CLR, NO GOTO IN PROGRESS
100$:	BSBW	DCL$FLUSH		;FLUSH COMMAND BUFFER
110$:	BRW	DCL$RESTART		;
 
;
; ASSIGNMENT STATEMENT, SUBSTRING EQUATE, OR COMMAND VERB
;
 
SYMBOL:	CMPB	#^A/[/,R0		;SUBSTRING OF BIT FIELD SUBSTRING ASSIGNMENT?
	BNEQ	120$			;IF NEQ NO
	BSBW	DCL$SUBASSIGN		;PROCESS SUBSTRING OR BIT FIELD ASSIGNMENT
	BRB	130$			;
120$:	CMPB	#^A/=/,R0		;SYMBOL ASSIGNMENT?
	BNEQ	COMMAND			;IF NEQ NO
	BSBW	DCL$EVALUATE		;EVALUATE ARITHMETIC ASSIGNMENT STATEMENT
130$:	BRW	ERROR_EXIT		;
 
;
; TRANSLATE FIRST TOKEN ON COMMAND LINE (IF POSSIBLE)
;
 
COMMAND:PUSHR	#^M<R1,R2>		;SAVE COMMAND VERB PARAMETERS
	BSBW	DCL$SYM_STRING		;SEARCH FOR SYMBOL DEFINITION
	MOVQ	R1,R4			;SAVE VALUE PARAMETERS
	POPR	#^M<R1,R2>		;RESTORE COMMAND VERB PARAMETERS
	TSTL	R4			;SYMBOL DEFINED AND HAVE VALUE?
	BNEQ	135$			;IF NEQ YES
	BRW	PRCVERB			;IF NOT SYMBOL, SEARCH VERB TABLE

;
; SUBSTITUTE LEADING SYMBOL NAME WITH ITS VALUE
;

135$:	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;RESET EXPANSION BUFFER POINTER
	ADDL3	#1,WRK_L_CHARPTR(R10),R6 ;GET CHARACTER POINTER
	CMPB	#^A/ /,(R6)		;ALREADY A BLANK HERE?
	BEQL	140$			;IF EQL YES
	MOVB	#^A/ /,-(R6)		;ELSE INSERT A TRAILING BLANK
140$:	CMPB	#^A/'/,-1(R5)[R4]	;DOES THE SYMBOL END WITH '?
	BNEQ	150$			;IF NEQ NO
	DECL	R4			;ELSE REMOVE THE ' FROM THE SYMBOL
	INCL	R6			; AND REMOVE THE ADDED TRAILING BLANK
150$:	SUBL	R4,R6			;BACK UP OVER SYMBOL'S LENGTH
	SUBL3	#1,R6,WRK_L_CHARPTR(R10) ;STORE NEW CHARACTER POINTER
	MOVC	R4,(R5),(R6)		;MOVE TRANSLATED COMMAND TO INPUT BUFFER
	CMPB	#^A/!/,(R6)		;COMMAND NOP'D?
	BEQL	100$			;BR IF YES AND FLUSH THE BUFFER
	CMPB	#^A/@/,(R6)		;PROCEDURE FILE?
	BEQL	INDFILE			;IF EQL YES
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
 
	.DSABL	LSB

;
; IF SYMBOL DEFINES FOREIGN COMMAND, INVOKE IMAGE.  ELSE, SEARCH VERB TABLE.
;
 
	CMPB	#^A/$/,R0		;DOLLAR SIGN?
	BNEQ	CMDVERB			;IF NEQ NO
FORVERB:				;COME HERE FOR CHAINED COMMANDS
	MOVZBL	#PTR_K_PARAMETR,R3	;SET TOKEN CONTEXT OF FILESPEC
	BSBW	DCL$PROCFILE		;PROCESS FILE SPECIFICATION
	BLBC	R0,ERROR		;IF LBC FILE SPECIFICATION ERROR
	SUBL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10) ;UNDO RESULT TOKEN DESCRIPTOR
	MOVQ	R1,-(SP)		;SAVE FILENAME DESCRIPTOR PARAMETERS
	BSBW	PROCFORN		;PROCESS FOREIGN COMMAND
	MOVB	#CLI$K_VERB_FORE,WRK_B_VERBTYP(R10) ;SET FOREIGN COMMAND
	POPR	#^M<R1,R2>		;RESTORE FILENAME DESCRIPTOR PARAMETERS
	BRW	EXECEXT			;
 
;
; COMMAND PROCEDURE FILE
;
 
INDFILE:				;COMMAND PROCEDURE FILE
	BRW	DCL$CMDSTART		;
 
;
; NO COMMAND VERB ,SYMBOL, OR LABEL
;
 
NOCOMD:	STATUS	NOCOMD			;SET NO COMMAND STATUS
ERROR:	BRW	ERROR_EXIT
 
;
; STANDARD COMMAND VERB
;
 
CMDVERB:
	BSBW	DCL$GETOKEN		;GET COMMAND VERB TOKEN
	BEQL	NOCOMD			;ERROR IF NULL LINE

PRCVERB:
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ;BR IF NOT AT ^Y LEVEL
	BBC	#PSL$V_CURMOD,@PRC_L_SAVAP(R11),10$ ;IF CLR PREVIOUS MODE SUPER
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE "@" FILE RECOGNITION
10$:	MOVL	PRC_L_TAB_VEC(R11),R8	;GET ADDRESS OF DATA BASE VECTOR
	BSBW	DCL$SEARCH_VERB		;SEARCH VERB TABLE FOR VERB
	BLBC	R0,ERROR		;BRANCH IF ERROR
;
; IF THE COMMAND SHOULD BE IMMEDIATELY DISPATCHED, DO IT NOW
;
	BBS	#CMD_V_FOREIGN,CMD_B_FLAGS(R8),90$ ; BRANCH IF FOREIGN
	BBC	#CMD_V_IMMED,CMD_B_FLAGS(R8),PARSE_VERB_QUALS ;BR IF NOT IMMEDIATE
	EXTZV	#0,#7,WRK_L_IMAGE(R10),R3 ;GET INTERNAL IMAGE INDEX
	BRW	IMMED

90$:	BSBW	PROCFORN		; PROCESS FOREIGN COMMAND
	BRW	BUILD_IMAGE
 
;
; PROCESS COMMAND QUALIFIERS
;
 
PARSE_VERB_QUALS:
	SETBIT	WRK_V_VERB,WRK_W_FLAGS(R10) ;SET VERB PROCESSING FLAG
;
; TREAT FIRST VERB QUALIFIER AS AN KEYWORD IF P1 ACTUALLY TAKES A KEYWORD
; (E.G. SET/TERMINAL -> SET TERMINAL)
;
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	MOVL	WRK_L_PROPTR(R10),R1	;GET ADDRESS OF P1 DESCRIPTOR
	BEQL	PARSE_QUAL		;BR IF NO PROMPT DESCRIPTOR
	TSTW	ENT_W_KEYWORDS(R1)	;IS P1 TAKE A KEYWORD VALUE?
	BEQL	PARSE_QUAL		;IF NOT, PROCESS AS QUALIFIER
	MOVL	WRK_L_CHARPTR(R10),R0	;GET CURRENT CHARACTER POINTER
	MOVB	#^A/ /,1(R0)		;SET QUALIFIER SLASH TO A BLANK
	BRB	PARSE_PARMS		;PROCESS AS PARAMETER
;
; PROCESS ALL LEADING QUALIFIERS
;
PARSE_QUAL:
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$PROCQUAL		;PROCESS QUALIFIER
	BLBS	R0,PARSE_QUAL		;IF LBS SUCCESSFUL COMPLETION
	BRW	ERROR_EXIT		;EXIT WITH ERROR
;
; PROCESS COMMAND PARAMETERS
;
PARSE_PARMS:
	CLRBIT	WRK_V_VERB,WRK_W_FLAGS(R10) ;CLEAR VERB PROCESSING
150$:	MOVL	WRK_L_PROPTR(R10),R8	;GET ADDRESS OF P1 DESCRIPTOR
	MOVL	WRK_L_PARMCNT(R10),R0	;GET PARAMETER # BEING PARSED
	BEQL	155$			;BRANCH IF NO LOOP NEEDED
152$:	MOVZBL	ENT_B_NEXT(R8),R1	;GET OFFSET TO NEXT DESCRIPTOR
	ADDL	R1,R8			;SKIP TO NEXT ENTITY DESCRIPTOR
	SOBGTR	R0,152$			;LOOP UNTIL PARAMETER FOUND
155$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BEQL	END_OF_LINE		;IF EQL END OF LINE
	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	230$			;IF NEQ NO
160$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	TSTL	WRK_L_MAXPARM(R10)	;PARAMETERS ALLOWED ON THIS COMMAND?
	BEQL	200$			;BR IF NONE ALLOWED
	TSTW	ENT_W_KEYWORDS(R8)	;DOES PARAMETER TAKE KEYWORD VALUE?
	BNEQ	180$			;IF SO, PROCESS AS QUALIFIER
	MOVZBL	#PTR_K_PARAMETR,R3	;SET CLASSIFICATION OF VALUE STRING
	BSBW	DCL$PARSE_VALUE		;PROCESS PARAMETER VALUE
170$:	BLBC	R0,260$			;IF LBC PARSE ERROR
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	190$			;IF NEQ NO
180$:	BSBW	DCL$PROCQUAL		;PROCESS QUALIFIER SPECIFICATION
	BRB	170$			;
190$:	CMPB	#^A/,/,R0		;MULTIPLE PARAMETERS?
	BEQL	210$			;IF EQL YES
	CMPB	#^A/+/,R0		;CONCATENATED PARAMETERS?
	BEQL	220$			;IF EQL YES
	TSTW	ENT_W_KEYWORDS(R8)	;DOES PARAMETER TAKE KEYWORD VALUE?
	BNEQ	150$			;IF SO, PARAMETER TREATED AS QUALIFIER
	INCL	WRK_L_PARMCNT(R10)	;INCREMENT COUNT OF PARAMETERS
	CMPL	WRK_L_PARMCNT(R10),WRK_L_MAXPARM(R10) ;MAXIMUM PARAMETERS EXCEEDED?
	BGTR	200$			;BR IF YES
	BRB	150$			;
 
;
; MAXIMUM PARAMETER COUNT EXCEEDED
;
 
200$:	STATUS	MAXPARM			;ASSUME MAXIMUM PARAMETERS EXCEEDED
	BRB	260$			;
 
;
; PARAMETER LIST SPECIFIED
;
 
210$:	BBS	#ENT_V_LIST,ENT_L_FLAGS(R8),160$ ;IF SET, LISTS ALLOWED
	STATUS	NOLIST			;SET NO LISTS ALLOWED STATUS
	BRB	260$			;
 
;
; PARAMETER CONCATENATION SPECIFIED
;
 
220$:	BBS	#ENT_V_CONCAT,ENT_L_FLAGS(R8),160$ ;IF SET, CONCATENATION ALLOWED
	STATUS	NOCCAT			;SET NO CONCATENATION ALLOWED STATUS
	BRB	260$			;
 
;
; INVALID PARAMETER DELIMITER
;
 
230$:	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
260$:	BRW	ERROR_EXIT		;
 
;
; ALL COMMAND INPUT PROCESSED - CHECK FOR SUFFICIENT PARAMETERS
;
 
END_OF_LINE:
	BBSS	#WRK_V_PROMPT,WRK_W_FLAGS(R10),PROMPT ;IF SET ALREADY PROMPTING
	CMPL	WRK_L_PARMCNT(R10),WRK_L_MINPARM(R10) ;SUFFICIENT PARAMETERS?
	BGEQ	BUILD_IMAGE		;IF GEQ YES
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),PROMPT ;IF SET, AT CONTROL Y/C LEVEL
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	250$			;IF NEQ NO
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),PROMPT ;IF CLR, INTERACTIVE MODE
250$:	STATUS	INSFPRM			;SET INSUFFICIENT PARAMETERS
	BRW	ERROR_EXIT		;
 
;
; PROMPT FOR ADDITIONAL PARAMETERS
;
 
PROMPT:
	CMPL	WRK_L_PARMCNT(R10),WRK_L_MAXPARM(R10) ;ALL PARAMETERS PROCESSED?
	BGEQ	BUILD_IMAGE		;IF GEQ YES
	BSBW	ISSUE_PROMPT		;ISSUE PROMPT AND GET RECORD
	TSTB	R0			;CHECK FIRST CHARACTER
	BEQL	300$			;IF EQL NULL LINE
	CMPB	R0,#CTRLZ		;CONTROL/Z?
	BNEQ	292$			;BRANCH IF NOT
	BRW	DCL$RESTART		;CONTROL/Z TYPED - START ALL OVER AGAIN
292$:	CMPB	R0,#^A'/'		;LEADING QUALIFIER?
	BNEQ	295$			;BRANCH IF NOT
	BRW	PARSE_QUAL		;PROCESS PARAMETER QUALIFIER(S)
295$:	MOVB	#^A/ /,@WRK_L_CHARPTR(R10) ;INSERT BLANK AT FRONT OF BUFFER
	DECL	WRK_L_CHARPTR(R10)	;BACK UP CHARACTER POINTER
	BRW	PARSE_PARMS		;PROCESS PARAMETER

300$:	BSBW	DCL$CHECK_AST		;CHECK FOR PENDING CONTROL Y/C AST
	BBS	#ENT_V_VALREQ,ENT_L_FLAGS(R8),PROMPT ;IF SET, PARAMETER REQUIRED
 
;
; BUILD IMAGE NAME DESCRIPTOR
;
 
BUILD_IMAGE:
	MOVL	WRK_L_IMAGE(R10),R3	;GET IMAGE NAME INDEX NUMBER
	BBC	#30,R3,320$		;BR IF THIS NOT A USER IMAGE?
	MOVL	R3,R2			;ADDRESS OF IMAGE NAME COUNTED STRING
	MOVZBL	(R2)+,R1		;GET COUNT TO R1, ADDRESS TO R2
	BRB	EXECEXT			;GO EXECUTE THAT
320$:	BBSC	#7,R3,EXECINT		;IF SET, INTERNAL COMMAND
	DECL	R3			;CONVERT TO RELATIVE IMAGE NAME INDEX
	MOVL	PRC_L_TAB_VEC(R11),R2	;GET ADDRESS OF DATA BASE VECTOR
	ADDL	VEC_L_IMAGETBL(R2),R2	;AND GET ADDRESS OF IMAGE TABLE
	BSBW	DCL$LOCATE		;LOCATE IMAGE NAME STRING
 
;
; EXECUTE EXTERNAL COMMAND
;
 
EXECEXT:				;EXECUTE EXTERNAL COMMAND
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3	;SET EXTERNAL IMAGE COMMAND INDEX
 
;
; EXECUTE INTERNAL COMMAND
;
 
EXECINT:				;EXECUTE INTERNAL COMMAND
	PUSHR	#^M<R1,R2,R3>		;SAVE IMAGE NAME PARAMETERS
	MOVZBL	#PTR_K_ENDLINE,R5	;SET ITEM TYPE TO END OF LINE
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#1,R7			;SET LENGTH OF ITEM
	MOVL	WRK_L_EXPANDPTR(R10),R8	;SET STARTING ADDRESS OF ITEM
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	POPR	#^M<R1,R2,R3>		;RESTORE IMAGE NAME PARAMETERS
;
; SORT TOKEN DESCRIPTOR TABLE INTO CMDQUAL,PARM,PARMQUAL ORDER
; FOR INTERNAL CLI ROUTINES TO MAKE GETDVAL PROCESSING EASIER.
;
	BBS	#30,WRK_L_IMAGE(R10),70$ ;SKIP IF NOT INDEX (IF ADDR. OF IMAGE)
	BBC	#7,WRK_L_IMAGE(R10),70$	;SKIP IF INDEX TO EXTERNAL IMAGE
	MOVAB	WRK_G_RESULT(R10),R7	;GET ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVL	R7,R8			;COPY ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVAB	-WRK_C_RSLBUFSIZ(SP),SP	;ALLOCATE TEMPORARY DESCRIPTOR ARRAY
	MOVL	SP,R9			;SAVE ADDRESS OF TEMPORARY DESCRIPTOR ARRAY
10$:	CMPL	R7,WRK_L_RSLNXT(R10)	;END OF RESULT DESCRIPTOR ARRAY?
	BEQL	30$			;IF EQL YES
	MOVL	(R7)+,(R9)		;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;COMMAND QUALIFIER?
		(R9),#PTR_K_COMDQUAL	;
	BNEQ	10$			;IF NEQ NO
	CLRL	-4(R7)			;CLEAR COMMAND QUALIFIER DESCRIPTOR
	TSTL	(R9)+			;POINT TO NEXT ITEM IN TEMPORARY ARRAY
20$:	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;QUALIFIER VALUE?
		(R7),#PTR_K_QUALVALU	;
	BNEQ	10$			;IF NEQ NO
	MOVL	(R7),(R9)+		;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	CLRL	(R7)+			;CLEAR QUALIFIER VALUE DESCRIPTOR
	BRB	20$			;

30$:	MOVL	R7,R5			;COPY ADDRESS OF LAST DESCRIPTOR + 4
40$:	CMPL	R7,R8			;ANY MORE DESCRIPTORS TO EXAMINE?
	BEQL	50$			;IF EQL NO
	MOVL	-(R7),R6		;GET DESCRIPTOR
	BEQL	40$			;IF EQL NONE
	MOVL	R6,-(R5)		;MOVE DESCRIPTOR TO NEW POSITION
	BRB	40$			;
50$:	CMPL	R9,SP			;ANY MORE TEMPORARY DESCRIPTORS?
	BEQL	60$			;IF EQL NO
	MOVL	-(R9),-(R5)		;MOVE DESCRIPTOR TO NEW POSITION
	BRB	50$			;
60$:	MOVAB	WRK_C_RSLBUFSIZ(SP),SP	;DEALLOCATE TEMPORARY DESCRIPTOR ARRAY
;
; SETUP SCRATCH STORAGE FOR USE BY INTERNAL ROUTINES
;
70$:	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND EXECUTION IN PROGRESS
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RESET NEXT TOKEN TO RETRIEVE
 
;
; INTERNAL COMMAND PARAMETERS:
;
;	R1 = LENGTH OF IMAGE FILENAME (IF ANY).
;	R2 = ADDRESS OF IMAGE FILENAME (IF ANY).
;
;    R8 AND R9 ARE SET UP AFTER THE CONDITIONAL RUNDOWN CALL BELOW
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; IMMEDIATE COMMAND PARAMETERS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
 
IMMED:					;IMMEDIATE COMMAND EXECUTION
	BBC	#PRC_V_PRIV,PRC_B_FLAGS2(R11),10$  ;BR IF UNPRIVILEGED IMAGE
;
; NEED TO RUN DOWN PRIVILEGED IMAGE, BUT ALLOW THE FOLLOWING COMMANDS
;
	CMPB	#IMG_K_CONTINUE & ^X7F,R3	;CONTINUE COMMAND?
	BEQL	10$			;BR IF YES
	CMPB	#IMG_K_SPAWN & ^X7F,R3	;SPAWN COMMAND?
	BEQL	10$			;BR IF YES
	CMPB	#IMG_K_ATTACH & ^X7F,R3	;ATTACH COMMAND?
	BEQL	10$			;BR IF YES
	BSBW	DCL$FORCEXIT		;RUN DOWN THE PRIVILEGED IMAGE
10$:	MOVL	SP,R9			;SET ADDRESS OF SCRATCH STACK
	MOVAB	-512(SP),SP		;ALLOCATE SCRATCH AREA BEFORE STACK
	PUSHAB	(SP)			;BUILD SCRATCH BUFFER DESCRIPTOR
	MOVZWL	#512,-(SP)
	MOVL	SP,R8			;SET ADDRESS OF SCRATCH BUFFER DESCRIPTOR
	BSBB	IMAGECASE		;EXECUTE INTERNAL IMAGE
;
; THE FOLLOWING CODE IS DUPLICATED IN IMAGEXECT FOR EXTERNAL IMAGES
; BECAUSE IT MUST BE DONE BEFORE IMAGE RUNDOWN, NOT AFTERWARDS.
;
ERROR_EXIT:				;ERROR EXIT
	BLBS	R0,10$			;IF LBS SUCCESSFUL COMPLETION
	BSBW	DCL$ERRORMSG		;OUTPUT SYSTEM ERROR MESSAGE
10$:	BSBW	DCL$SET_STATUS		;SET COMPLETION STATUS
	BSBW	DCL$FLUSH		;FLUSH COMMAND BUFFER
	BRW	DCL$RESTART		;


	.MACRO	INTIMAGE NAME
	.WORD	DCL$'NAME'-10$
IMG_K_'NAME = $INTIMAGE$
$INTIMAGE$ = $INTIMAGE$ + 1
	.ENDM

IMAGECASE:
	CASEB	R3,#0,#<90$-10$>/2-1
10$:					;BASE ADDRESS OF CASE TABLE
	.LIST	MEB
	INTIMAGES			;GENERATE INTERNAL IMAGE CASE TABLE
	.NLIST	MEB
90$:
	MOVZWL	#SS$_ILLSER,R0		;SET SERVICE ERROR
	RSB

	.SBTTL	CALL LOGINOUT TO ABORT THE PROCESS
;----
; DCL$ABORT
;
; CONTROL IS TRANSFERRED HERE TO ABORT THE PROCESS BY CALLING
; THE LOGINOUT IMAGE.  CARE IS TAKEN TO SETUP THE RESULT
; PARSE DESCRIPTORS SO THAT LOGINOUT CAN USE RESULT PARSING
; AS IF LOGOUT WAS GIVEN AS A COMMAND LINE.
;
; INPUTS:
;
;	NONE
;----

DCL$ABORT::
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RESET RESULT ARRAY PTR
	MOVAB	WRK_G_BUFFER(R10),R2	;GET ADDRESS OF EXPANSION BUFFER
	MOVL	R2,WRK_L_EXPANDPTR(R10) ;RESET EXPANSION PTR
	MOVL	#^A'LOGO',(R2)		;STORE VERB INTO BUFFER
	MOVL	#4,R1			;SET LENGTH OF VERB
	MOVZBL	#IMG_K_LOGOUT,WRK_L_IMAGE(R10)	;SET ROUTINE IN CASE NOT FOUND
	MOVL	PRC_L_TAB_VEC(R11),R8	;GET ADDRESS OF DATA BASE VECTOR
	BSBW	DCL$SEARCH_VERB		;LOCATE COMMAND DEFINITION FOR
					;LOGOUT CLI INTERFACE (IGNORE ERRORS)
	BRW	BUILD_IMAGE		;PROCESS LOGOUT COMMAND

	.SBTTL	EOD/DECK COMMANDS
;+
; DCL$EOD/DCL$DECK
;
; THESE COMMANDS ARE PROCESSED BY RMS AND SHOULD NOT BE SEEN BY THE CLI.
; RMS PASSES THEM THROUGH IF THE SYNTAX OR VALUE IS BAD.  ONE CASE IS
; NOT TREATED AS AN ERROR, THAT IS "EOD" ALONE ON A LINE.  THIS COULD
; HAPPEN IF THE STATEMENT WAS ENTERED WITHOUT AN IMAGE RUN.
;-
 
DCL$EOD::				;
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10) ;DO NOT SET STATUS ON SUCCESS
	BSBW	DCL$SETNBLK		;LOOK FOR NEXT CHARATER IN LINE
	BNEQ	DCL$DECK		;BR IF NOT A NULL LINE
	STATUS	NORMAL			;SET OK STATUS
	RSB				;
 
DCL$DECK::				;
	STATUS	IVVALU			; ASSUME ERROR WAS INVALID VALUE
	RSB

	.SBTTL	CHECK FOR CONTROL Y/C AST PENDING
;+
; DCL$CHECK_AST - CHECK FOR CONTROL Y/C AST PENDING
;
; THIS ROUTINE IS CALLED TO CHECK FOR A PENDING CONTROL Y/C AST.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF A CONTROL Y/C AST IS PENDING, THEN CONTROL IS TRANSFERED TO THE COMMAND
;	RESTART ENTRY POINT. OTHERWISE CONTROL IS RETURNED TO THE CALLER.
;-
 
	.ENABL	LSB
DCL$CHECK_AST::				;CHECK FOR PENDING CONTROL Y/C AST
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),50$ ;IF CLR, NO CONTROL Y/C REQUEST
10$:	BRW	DCL$RESTART		;

	.SBTTL	ENABLE/DISABLE CONTROL Y/C AST'S
;+
; DCL$DISABLE - DISABLE CONTROL Y/C AST'S
;
; THIS ROUTINE IS CALLED TO DISABLE/ENABLE CONTROL Y/C AST'S.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CONTROL Y/C AST'S ARE DISABLED, THE PREVIOUS ENABLE STATE IS SAVED, AND
;	A CO-ROUTINE CALL IS MADE BACK TO THE CALLER. WHEN CONTROL RETURNS, THE
;	AST STATE IS RESTORED TO ITS VALUE BEFORE THE DISABLE.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL
;-
 
DCL$DISABLE::				;DISABLE CONTROL Y/C AST'S
	PUSHL	(SP)			;COPY RETURN ADDRESS
	MOVZWL	PRC_W_FLAGS(R11),4(SP)	;SAVE PREVIOUS DISABLE STATE
	SETBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	JSB	@(SP)+			;CALL THE CALLER BACK
	BBS	#PRC_V_DISABL,4(SP),40$	;IF SET, AST'S PREVIOUSLY DISABLED
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF SET, AT CONTROL Y/C LEVEL
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	30$			;IF NEQ NO
20$:	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),10$ ;IF SET, CONTROL Y/C REQUEST
30$:	CLRBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;ENABLE CONTROL Y/C AST'S
40$:	POPL	(SP)			;REMOVE PREVIOUS STATE FROM STACK
50$:	RSB				;
	.DSABL	LSB

	.SBTTL	FLUSH COMMAND BUFFER
;+
; DCL$FLUSH - FLUSH COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO READ CHARACTERS FROM THE COMMAND BUFFER UNTIL AN
; END OF LINE IS ENCOUNTERED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	INDIRECT FILE RECOGNITION IS DISABLED AND CHARACTERS ARE READ FROM THE
;	INPUT BUFFER UNTIL AN END OF LINE IS ENCOUNTERED.
;-
 
DCL$FLUSH::				;FLUSH COMMAND BUFFER
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ; IF AT ^Y LEVEL DON'T FLUSH
	MOVL	PRC_L_INDINPRAB(R11),R0	; GET CURRENT INPUT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R0),20$ ; LIKEWISE FOR TERMINALS
	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;SET BUFFER TO RECEIVE ANY CONT. LINES
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
10$:	BSBW	DCL$GETCHAR		;GET CHARACTER FROM INPUT BUFFER
	BNEQ	10$			;IF NEQ NOT END OF LINE
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE RECOGNITION
20$:	RSB				;

	.SBTTL	ISSUE PROMPT AND GET RESPONSE
;---
; ISSUE_PROMPT - ISSUE PROMPT AND GET RESPONSE
;
; THIS ROUTINE IS CALLED WHEN A REQUIRED PARAMETER IS MISSING
; TO PROMPT THE USER FOR MORE INPUT.
;
; INPUTS:
;
;	WRK_L_PARMCNT = # PARAMETERS OBTAINED SO FAR
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;---

ISSUE_PROMPT:
	PUSHL	WRK_L_PROMPT(R10)	;SAVE PREVIOUS PROMPT STRING ADDRESS
	MOVL	PRC_L_TAB_VEC(R11),R5	;GET ADDRESS OF TABLE VECTOR
	MOVZBL	VEC_B_PROMPTMAX(R5),R5	;GET SIZE OF THE BIGGEST PROMPT STRING
	ADDL	#16,R5			;PLUS EXTRA FOR COUNT,COLON,ETC.
	SUBL	R5,SP			;PLUS STORAGE TO BUILD PROMPT STRING
	CVTWL	ENT_W_PROMPT(R8),R0	;GET PROMPT STRING INDEX NUMBER
	BSBB	CONVERT_SRO		;GET ADDRESS OF PROMPT STRING
	MOVL	SP,R3			;GET ADDRESS OF STORAGE TO BUILD PROMPT STRING
	MOVL	PRC_L_TAB_VEC(R11),R2	;GET ADDRESS OF TABLES VECTOR
	MOVB	VEC_B_PROMPTMAX(R2),(R3)+ ; SET LENGTH OF PROMPT STRING
	MOVW	#^A'$_',(R3)+		;INSERT PREFIX CHARACTERS
	MOVZBL	(R0)+,R1		;LENGTH IN R1, ADDRESS IN R0
	CMPB	R1,(SP)			;PROMPT BIGGER THAN BUFFER?
	BLEQU	280$			;BRANCH IF OK
	MOVZBL	(SP),R1			;ONLY COPY AS MUCH AS WE HAVE ROOM FOR
280$:	MOVB	(R0)+,(R3)+		;MOVE CHARACTER TO PROMPT STRING
	SOBGTR	R1,280$			;ANY MORE TO MOVE?
	MOVB	#^A/:/,(R3)+		;INSERT SUFFIX CHARACTERS
290$:	MOVB	#^A/ /,(R3)+		;PAD PROMPT WITH BLANKS
	SUBL3	SP,R3,R1		;GET NUMBER OF CHARACTERS IN PROMPT
	CMPB	R1,(SP)			;CHECK IF PADDED ENOUGH
	BLEQ	290$			;BR IF NO
	MOVL	SP,WRK_L_PROMPT(R10)	;SET ADDRESS OF NEW PROMPT STRING
	SETBIT	WRK_V_INQUIRE,WRK_W_FLAGS(R10) ;MAKE IT LOOK LIKE INQUIRE
					;SO WE GET BACK CONTROL/Z'S (EOF)
	BSBW	DCL$FORNBLK		;FORCE NONBLANK CHARACTER
	BNEQ	300$			;BRANCH IF NON-NULL
	MOVL	PRC_L_INPRAB(R11),R1	;GET ADDRESS OF INPUT RAB
	CMPW	RAB$L_STS(R1),#RMS$_EOF&^XFFFF ; END OF FILE?
	BNEQ	300$			;BRANCH IF NOT
	MOVZBL	#CTRLZ,R0		;RETURN WITH CONTROL/Z CHARACTER
300$:	CLRBIT	WRK_V_INQUIRE,WRK_W_FLAGS(R10) ;CLEAR INQUIRE FLAG
	ADDL	R5,SP			;DEALLOCATE PROMPT BUFFER STORAGE
	POPL	WRK_L_PROMPT(R10)	;RESTORE PREVIOUS PROMPT ADDRESS
	RSB				;AND RETURN WITH FIRST CHARACTER IN R0

CONVERT_SRO:
	TSTL	R0			;CHECK DISPLACEMENT
	BEQL	110$			;IF EQL NONE
	ADDL	R8,R0			;CALCULATE ACTUAL ADDRESS
110$:	RSB				;

	.SBTTL	PROCESS FOREIGN COMMAND
;---
; PROCFORN - GENERATE RESULT DESCRIPTOR FOR FOREIGN COMMAND LINE
;
; PROCESS FOREIGN COMMAND AND BUILD TOKEN DESCRIPTOR
; FOR THE REST OF THE LINE AFTER THE VERB.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	A TOKEN DESCRIPTOR IS GENERATED FOR THE LINE
;---

PROCFORN:				;PROCESS FOREIGN COMMAND
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE INTERPRETATION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	R0,#^A' '		;BLANK?
	BNEQ	5$			;BRANCH IF NO LEADING BLANK
	BSBW	DCL$MOVCHAR		;MOVE BLANK BEFORE MARK
5$:	BSBW	DCL$MARK		;MARK POSITION AFTER FILESPEC & BLANK
10$:	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BNEQ	10$			;UNTIL END OF LINE
	DECL	WRK_L_EXPANDPTR(R10)	;BACKUP OVER EOL CHARACTER
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF REST OF LINE
	MOVQ	R1,R7			;COPY DESCRIPTOR
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#PTR_K_PARAMETR,R5	;SET ITEM TYPE TO PARAMETER
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE TABLE DESCRIPTOR
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE INTERPRETATION
	RSB				;

	.END
