	.TITLE	LOGICAL - LOGICAL NAME COMMANDS
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; LOGICAL NAME DCLS COMMAND EXECUTION
;
;	ALLOCATE DEVICE
;	ASSIGN LOGICAL NAME
;	DEALLOCATE DEVICE
;	DEASSIGN LOGICAL NAME
;	DEFINE LOGICAL NAME
;
; D. N. CUTLER 31-MAR-77
;
; MODIFIED BY:
;
;	V007	PCG0002		Peter George	11-Jan-1982
;		Call DCL$COMPRESS with the equivalence name.
;		Do not remove bracketing quotes.
;
;	V006	PCG0001		Peter George	07-Dec-1981
;		Strip leading and trailing quotation marks off the
;		equivalence name since its type is being changed 
;		to $INFILE.
;
;	V005	TMH0005		Tim Halvorsen	27-Aug-1981
;		Fix processing of DELSYM qualifiers so that unknown
;		qualifiers (like those which have been invalidated
;		due to a syntax change) are ignored.
;
;	V004	TMH0004		Tim Halvorsen	22-Mar-1981
;		Do not compress logical & equivalence strings anymore,
;		since it is now done automatically by value parsing.
;
;	V003	TMH0003		Tim Halvorsen	16-Feb-1981
;		Use R10 rather than FP as WRK address.
;		Fix check of SYM_B_TYPE since it now takes a value.
;
;	V002	TMH0002		Tim Halvorsen	21-Jan-1981
;		Accept more than one generic device name to search in ALLOCATE.
;		Make allocation and logical replaced messages lowercase.
;
;	V001	TMH0001		Tim Halvorsen	09-Sep-1980
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	SYMDEF				;DEFINE SYMBOL TABLE OFFSETS
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$LOGDEF				;DEFINE LOG OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$CLIDEFQUALASSI			;DEFINE ASSIGN QUALIFIER NUMBERS
	$CLIDEFQUALDEAL			;DEFINE DEALLOCATE QUALIFIER NUMBERS
	$CLIDEFQUALDEAS			;DEFINE DEASSIGN QUALIFIER NUMBERS
	$CLIDEFQUALDEFI			;DEFINE DEFINE QUALIFIER NUMBERS
	$CLIDEFQUALDELE			;DEFINE QUALIFIERS FOR DELETE
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
ALLOCATE:				;ALLOCATE TEXT
	.ASCII	' allocated'
A:
SUPERSEDE:				;LOGICAL NAME SUPERSEDED MESSAGE
	.ASCII	'Previous logical name assignment replaced'
B:
 
; THE FOLLOWING TABLES ARE USED BY SUBROUTINE TABNUM TO DETERMIN THE
; THE MEANING OF QUALIFIERS FOR THE VARIOUS COMMANDS.  THE TABLE HAS
; AN ENTRY FOR A QUALIFIER THAT MUST BE HANDLED WITH THE LENGTH OF
; THE TABLE AS THE ZEROTH ENTRY AND A VALUE RELATIVE THAT IS INDEXED
; THE THE QUALIFIER CODE NUMBER.  A VALUE OF ZERO INDICATES THAT THE
; QUALIFIER IS THE ALL QUALIFIER. A NEGATIVE VALUE IS THE NEGATIVE
; OF THE MODE TO MAKE LOGICAL NAME ASSIGNMENTS (IE: USER, SUPER).
; A POSITIVE VALUE IS THE TABLE NUMBER (IE: PROCESS, GROUP, SYSTEM) PLUS 1.
;
ALL_QUAL = 0				; THE CONTENTS FOR "ALL" IS ZERO
 
	ASSUME	CLI$K_DEAL_ALL	EQ 1	;
DEALTBL:.BYTE	1,ALL_QUAL		; TABLE FOR DEALLOCATE
DEFITBL:				; TABLE FOR DEFINE
ASSITBL:.BYTE	5			; SAME AS FOR ASSIGN
	ASSUME	CLI$K_ASSI_SYST EQ 1	;
	ASSUME	CLI$K_DEFI_SYST EQ 1	;
	ASSUME	CLI$K_ASSI_GROU EQ 2	;
	ASSUME	CLI$K_DEFI_GROU EQ 2	;
	ASSUME	CLI$K_ASSI_PROC EQ 3	;
	ASSUME	CLI$K_DEFI_PROC EQ 3	;
	.BYTE	LOG$C_SYSTEM+1,LOG$C_GROUP+1,LOG$C_PROCESS+1
	ASSUME	CLI$K_ASSI_USER EQ 4	;
	ASSUME	CLI$K_DEFI_USER EQ 4	;
	ASSUME	CLI$K_ASSI_SUPE EQ 5	;
	ASSUME	CLI$K_DEFI_SUPE EQ 5	;
	.BYTE	-PSL$C_USER,-PSL$C_SUPER; ACCESS MODE OF ENTRY
 
DEASTBL:.BYTE	6			; TABLE FOR DEASSIGN
	ASSUME	CLI$K_DEAS_SYST EQ 1	;
	ASSUME	CLI$K_DEAS_GROU EQ 2	;
	ASSUME	CLI$K_DEAS_PROC EQ 3	;
	.BYTE	LOG$C_SYSTEM+1,LOG$C_GROUP+1,LOG$C_PROCESS+1
	ASSUME	CLI$K_DEAS_ALL	EQ 4	;
NULTBL:	.BYTE	ALL_QUAL
	ASSUME	CLI$K_DEAS_USER EQ 5	;
	ASSUME	CLI$K_DEAS_SUPE EQ 6	;
	.BYTE	-PSL$C_USER,-PSL$C_SUPER

	.SBTTL	ALLOCATE DEVICE
;+
; DCL$ALLOCATE - ALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ALLOCATE
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS ALLOCATED AND ASSIGNED THE SPECIFIED LOGICAL
;	NAME. IF THE LOGICAL NAME WAS PREVIOUSLY ASSIGNED, THEN A MESSAGE TO
;	THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
	.ENABL	LSB
 
DCL$ALLOCATE::				;ALLOCATE DEVICE
	CLRL	R6			;SET NO TERMINATOR YET
	MOVZWL	#SS$_NOSUCHDEV,R7	;PRESET ERROR STATUS
3$:	BSBW	DCL$GETDVAL		;GET FIRST PARAMETER VALUE
	CMPB	R6,#PTR_K_BLANK		;LAST PARAMETER VALUE IN LIST?
	BEQL	9$			;EXIT WITH ERROR IF SO
	CMPB	R5,#PTR_K_PARAMETR	;PARAMETER VALUE?
	BNEQ	9$			;EXIT WITH ERROR IF NOT
	MOVL	R4,R6			;SAVE TERMINATOR TYPE CODE
	BSBW	DCL$COMPSTRING		;REMOVE ANY DOUBLE QUOTES
	MOVQ	R1,-(R9)		;PUSH THE DESCRIPTOR ONTO STACK
	CMPB	#^A/:/,-1(R2)[R1]	;DEVICE NAME END WITH A COLON?
	BNEQ	5$			;IF NEQ NO
	DECL	(R9)			;REDUCE LENGTH OF DEVICE NAME
5$:	$ALLOC_S (R9),(R8),(R8)		;ALLOCATE DEVICE
	MOVL	R0,R7			;SAVE FINAL STATUS
	BLBC	R0,3$			;IF ERROR, TRY NEXT DEVICE IN LIST
	MOVQ	(R8),-(R9)		;SAVE DEVICE NAME DESCRIPTOR
	ADDL3	(R8)+,(R8),R0		;CALCULATE ADDRESS TO APPEND TEXT
	MOVC	#A-ALLOCATE,ALLOCATE,(R0) ;APPEND TEXT TO DEVICE NAME
	MOVL	(R8),R2			;GET STARTING ADDRESS OF DEVICE NAME
	MOVW	#^A/  /,-(R2)		;INSERT 2 LEADING SPACES
	SUBL3	R2,R3,R1		;CALCULATE LENGTH OF MESSAGE
	BSBW	DCL$MSGOUT		;OUTPUT ALLOCATION MESSAGE
8$:	BSBW	DCL$GETDVAL		;GET NEXT PARAMETER VALUE
	CMPB	R5,#PTR_K_PARAMETR	;PARAMETER VALUE?
	BEQL	6$			;CONTINUE IF LOGICAL NAME FOUND
	BRW	40$			;EXIT IF NOT
6$:	CMPB	R6,#PTR_K_BLANK		;END OF P1 LIST?
	BEQL	7$			;IF P2 FOUND, ASSIGN THE LOGICAL NAME
	MOVL	R4,R6			;COPY TERMINATOR TYPE CODE
	BRB	8$			;LOOP UNTIL P2 OR EOL FOUND
7$:	MOVZBL	#PSL$C_SUPER,R6		;SET ACMODE OF LOGNAM ASSIGNMENT
	MOVZBL	#LOG$C_PROCESS,R7	;SET LOGICAL NAME TABLE
	BRB	10$			;ASSIGN LOGICAL NAME
9$:	MOVL	R7,R0			;RESTORE FINAL STATUS
	BRB	50$			;AND EXIT

	.SBTTL	ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;+
; DCL$ASSIGN - ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ASSIGN
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. IF A PREVIOUS LOGICAL ASSIGNMENT IS SUPERSEDED, THEN A
;	MESSAGE TO THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
DCL$ASSIGN::				;ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
	MOVAB	ASSITBL,R6		;TABLE FOR QUALIFIERS
	BSBW	TABNUM			;GET TABLE NUMBER AND EQUIVALENCE NAME
	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUE
10$:	CMPB	#^A/:/,-1(R2)[R1]	;LOGICAL NAME END WITH COLON?
	BNEQ	20$			;IF NEQ NO
	DECL	R1			;REDUCE LENGTH OF LOGICAL NAME
20$:	MOVQ	R1,-(R9)		;SAVE LOGICAL NAME DESCRIPTOR
	MOVQ	8(R9),R1		;SET UP EQUIVALENCE NAME DESCRIPTOR
	BRB	30$			;

	.SBTTL	DEFINE LOGICAL NAME EQUIVALENCE
;+
; DCL$DEFINE - DEFINE LOGICAL NAME EQUIVALENCE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEFINE
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. IF A PREVIOUS LOGICAL ASSIGNMENT IS SUPERSEDED, THEN A
;	MESSAGE TO THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
DCL$DEFINE::				;DEFINE LOGICAL NAME EQUIVALENCE
	MOVAB	DEFITBL,R6		;SET QUALIFIER TABLE
	BSBW	TABNUM			;GET TABLE NUMBER AND COMPRESS LOGICAL NAME
	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUE
	MOVQ	(R9),-(R9)		;COPY LOGICAL NAME STRING DESCRIPTOR
30$:	BSBW	DCL$COMPRESS		;COMPRESS QUOTED STRING
	MOVQ	R1,8(R9)		;RETURN DESCRIPTOR TO WORK AREA
	$CRELOG_S R7,(R9),8(R9),R6	;CREATE LOGICAL NAME AS SPECIFIED
	CMPW	#SS$_SUPERSEDE,R0	;PREVIOUS ASSIGNMENT SUPERSEDED?
	BNEQ	50$			;IF NEQ NO
	MOVZBL	#B-SUPERSEDE,R1		;GET LENGTH OF SUPERSEDE MESSAGE
	MOVAB	SUPERSEDE,R2		;GET ADDRESS OF SUPERSEDE MESSAGE
	BSBW	DCL$MSGOUT		;OUTPUT MESSAGE
40$:	STATUS	NORMAL			;SET NORMAL COMPLETION
50$:	RSB				;
	.DSABL	LSB

	.SBTTL	DEALLOCATE DEVICE
;+
; DCL$DEALLOCATE - DEALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEALLOCATE
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS DEALLOCATED OR ALL DEVICES ARE DEALLOCATED.
;-
 
DCL$DEALLOCAT::				;DEALLOCATE DEVICE
	MOVAB	DEALTBL,R6		;GET QUALIFIER TABLE
	BSBB	GETDEV			;GET DEVICE NAME TO DEALLOCATE
	$DALLOC_S (R9)			;DEALLOCATE DEVICE
	RSB				;

	.SBTTL	DEASSIGN LOGICAL NAME EQUIVALENCE
;+
; DCL$DEASSIGN - DEASSIGN LOGICAL NAME EQUIVALENCE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEASSIGN DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME EQUIVALENCE OR ALL LOGICAL NAME EQUIVALENCES
;	ARE DEASSIGNED.
;-
 
DCL$DEASSIGN::				;DEASSIGN LOGICAL NAME EQUIVALENCE
	MOVAB	DEASTBL,R6		;SET TABLE ADDRESS FOR QUALIFIERS
	BSBB	GETDEV			;GET DEVICE NAME TO DEASSIGN
	$DELLOG_S R7,(R9),R6		;DEASSIGN LOGICAL NAME EQUIVALENCE
	RSB				;
 
;+
; GETDEV - GET DEVICE NAME
;
; COMMON ROUTINE TO GET A DEVICE NAME AND REMOVE COLON IF PRESENT
;
; INPUTS:	SAME AS DEASSIGN AND DEALLOCATE, PLUS
;		R6 IS VALUE OF PROPER ALL QUALIFIER.
;-
 
GETDEV:	BSBB	TABNUM			;GET TABLE NUMBER AND COMPRESS LOGICAL NAME
	BEQL	10$			;BR IF DOING ALL
	CMPB	#^A/:/,-1(R2)[R1]	;STRING END WITH A COLON
	BNEQ	10$			;BR IF NO
	DECL	(R9)			;REMOVE COLON FROM STRING
10$:	RSB				;

	.SBTTL	GET LOGICAL NAME TABLE NUMBER
;
; SUBROUTINE TO GET LOGICAL NAME TABLE NUMBER
;
; ON INPUT R6 IS QUALIFIER DECODE TABLE
;
; ON OUTPUT, R6 = PROCESSOR MODE FOR ASSIGNMENT
;	     R7 = TABLE NUMBER FOR ASSIGNMENT
;	     'Z'= 1 IF "ALL" QUALIFIER SEEN
 
TABNUM:	MOVZBL	#LOG$C_PROCESS,R7	;ASSUME PROCESS LOGICAL NAME TABLE
	PUSHL	#PSL$C_SUPER		;MODE OF LOGICAL NAME ASSIGNMENT
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_PARAMETR,R5	;ITEM TYPE PARAMETER?
	BLEQ	40$			;IF LEQ END OF LINE OR PARAMETER
	CMPL	R1,(R6)			;QUALIFIER IN RANGE OF TABLE?
	BGTRU	10$			;IGNORE IT
	CVTBL	(R1)[R6],R0		;GET QUALIFIER CODE
	BEQL	25$			;BR IF ALL QUALIFIER
	BGTR	20$			;BR IF TABLE NUMBER
	MNEGL	R0,(SP)			;SET PROCESSOR MODE FOR ASSIGNMENT
	BRB	10$			;GET NEXT
20$:	MOVAB	-(R0),R7		;SET TABLE NUMBER FOR ASSIGNMENT
	BRB	10$			;GET NEXT
25$:	CLRL	R9			;SET UP FOR DEALLOCTE OR DEASSIGN ALL
	BRB	10$			;PROCESS NEXT
40$:	POPL	R6			;GET MODE FOR LOGICAL NAME ASSIGNMENT
	TSTL	R9			;ALL SEEN?
	BEQL	50$			;BR IF YES
	MOVQ	R1,-(R9)		;SAVE DESCRIPTOR FOR NAME
50$:	RSB				;

	.SBTTL	DELETE SYMBOL FROM SYMBOL TABLE
;+
; DCL$DELSYM - DELETE SYMBOL FROM SYMBOL TABLE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO DELETE EITHER A
; SPECIFIC SYMBOL OR ALL SYMBOLS FROM A SPECIFIED SYMBOL TABLE.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED SYMBOL,IF IT EXISTS, IS DELETED,
;		ELSE NO SUCH SYMBOL IS RETURNED;
;	OR THE ENTIRE CONTENTS OF THE SPECIFIED TABLE IS DELETED.
;	PERMANENT SYMBOLS ARE NEVER DELETED.
;-
 
DCL$DELSYM::				; DELETE SYMBOL FROM TABLE
	MOVAQ	PRC_Q_LOCAL(R11),R7	; ASSUME DELETING FROM THE LOCAL TABLE
	CLRL	R8			; AND THAT ONLY DOING A SPECIFIC SYMBOL
10$:	BSBW	DCL$GETDVAL		; GET NEXT RESULT DESCRIPTOR
	CMPB	#PTR_K_PARAMETR,R5	;IS THIS A PARAMETER?
	BLEQ	30$			;BR IF YES
	CMPB	R1,#CLI$K_DLSY_ALL	; /ALL?
	BEQL	20$			; BR IF ALL
	CMPB	R1,#CLI$K_DLSY_LOCA	; /LOCAL?
	BEQL	15$			; BR IF LOCAL TABLE
	CMPB	R1,#CLI$K_DLSY_GLOB	; /GLOBAL?
	BNEQ	10$			; IF NOT, IGNORE IT
	MOVAQ	PRC_Q_GLOBAL(R11),R7	; SET PROPER TABLE ADDRESS
	BRB	10$			; BR FOR MORE
15$:	MOVAQ	PRC_Q_LOCAL(R11),R7	; MAKE SURE TABLE ADDRESS IS CORRECT
	BRB	10$			;
20$:	MOVL	#1,R8			; SET DOING ALL FLAG
	BRB	10$			;
30$:	BLBS	R8,50$			; BR IF DOING ALL
	MOVL	R7,R0			; SET TABLE ADDRESS
	BSBW	DCL$SEARCHT		; SEARCH THE TABLE FOR THE SYMBOL
	BLBC	R0,40$			; DEALLOCTE
	BSBB	55$			; TEST AND DEALLOCATE
	BRB	70$			;
40$:	STATUS	UNDSYM			; NO SUCH SYMBOL
	RSB				; EXIT WITH ERROR STATUS
50$:	MOVL	(R7),R3			; GET ADDRESS OF NEXT SYMBOL
	CMPL	R7,R3			; DONE?
	BEQL	70$			; BR IF YES
	PUSHAB	50$			; RETURN ADDRESS FOR DEALLOCATE
55$:	CMPB	SYM_B_TYPE(R3),#SYM_K_PERM ; PERMANENT SYMBOL?
	BEQL	60$			; BR IF YES - DON'T DEALLOCATE IT
	BRW	DCL$DEALLOCSYM		; DEALLOCATE IT
60$:	TSTL	(SP)+			; CLEAR INTERMEDIATE RETURN
70$:	STATUS	NORMAL			;
	RSB
 
	.END
