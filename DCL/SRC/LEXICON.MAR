	.TITLE	LEXICON - LEXICAL FUNCTION PARSE AND EXECUTION ROUTINES
	.IDENT	'V03-025'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; LEXICAL FUNCTION PARSE AND EXECUTION SUPPORT ROUTINES
;
; D. N. CUTLER 3-FEB-78
;
; MODIFIED BY:
;
;	V025	PCG0010		Peter George	16-Mar-1982
;		Fill date field returned by F$CVTIME with a zero.
;		Make DCL$REMBLANKS a global routine.
;
;	V024	PCG0009		Peter George	23-Feb-1982
;		Correct F$GETJPI's handling of no priv case.
;
;	V023	PCG0008		Peter George	07-Feb-1982
;		Only list privs that are present in F$GETJPI.
;
;	V022	PCG0007		Peter George	04-Feb-1982
;		If F$LOGICAL fails to find the specified logical name,
;		then upcase and try again.  Add some missing fields and
;		privilege mask processing to F$GETJPI.  Add ACPTYPE 
;		processing to F$GETDVI.
;
;	V021	PCG0006		Peter George	03-Feb-1982
;		Fix F$SEARCH so it deallocates the context on exit
;		for non-wild filespecs.
;
;	V020	PCG0005		Peter George	20-Jan-1982
;		Have F$SEARCH save context even if stream identifier
;		is not specified.  Allow blanks and lower case letters
;		in keyword parameters. Have F$GETDVI return with more
;		appropriate errors messages.  Add EXISTS keyword for
;		F$GETDVI.  Use "invalid keyword" message when signalling
;		errors in item names.
;
;	V019	PCG0004		Peter George	19-Jan-1982
;		Remove F$PARSE(,,,"QUOTED") and change F$BINARY to
;		F$INTEGER.
;
;	V018	TMH0018		Tim Halvorsen	28-Dec-1981
;		Remove roundup before ALLDYNMEM - now done inside routine.
;
;	V017	PCG0003		Peter George	09-Dec-1981
;		Make DCL$CBTA_DEC,OCT handle negative numbers.
;
;	V016	TMH0016		Tim Halvorsen	25-Nov-1981
;		Rewrite F$SEARCH to use internally stored context
;		for each search sequence "stream".  This is because
;		a longword is simply not enough to hold all the context
;		necessary, and it is not desirable to require that the
;		user keep strings containing binary data to hold the
;		context.
;
;	V015	PCG0015		Peter George	04-Nov-1981
;		Implement F$FILE(,"PRO").
;		Replace F$GETDEV with F$GETDVI.
;
;	V014	TMH0014		Tim Halvorsen	27-Oct-1981
;		Do not accept delta time strings in F$CVTIME.
;		Fix bug in F$PRIVILEGE when the second keyword
;		is negated.
;		Add support for ALL keyword in F$SETPRV.
;
;	V013	TMH0013		Tim Halvorsen	26-Oct-1981
;		Fix bug in F$CVTIME which returns string of wrong
;		length (off by one).
;		Add F$PRIVILEGE and F$SETPRV functions.
;
;	V012	PCG0001		Peter George	16-Oct-1981
;		Do not clear top of stack in F$CVUI and F$CVSI.
;		Have F$FILE recognize RFM of STM, STMLF, and STMCR.
;
;	V011	TMH0011		Tim Halvorsen	04-Sep-1981
;		Add F$GETSYI
;		Add DEVDEPND2 field to F$GETDEV
;		Change OWNER and PID fields of F$GETJPI to be returned
;		as strings rather than binary numbers
;
;	V010	TMH0010		Tim Halvorsen	14-Aug-1981
;		Add TRM,MNT,ALL,MBX,SWL keywords to GETDEV.
;		If owner UIC is zero, return null string rather than [0,0].
;		Return GETDEV-PID as a string, rather than a longword.
;		If PID zero, return as null string rather than 00000000.
;
;	V009	TMH0009		Tim Halvorsen	11-Aug-1981
;		Add DEVDEPEND to F$GETDEV item list.
;		Remove GETDEV-VPROT and FILE-PRO until something
;		is coded to return them as strings, rather than bitmasks.
;
;	V008	TMH0008		Tim Halvorsen	11-Aug-1981
;		Add F$GETDEV lexical function.
;
;	V007	TMH0007		Tim Halvorsen	21-May-1981
;		Fix F$USER so that it doesn't use the FORMAT_UIC
;		routine, because it pads on the left with zeros,
;		incompatible with the previous release.
;
;	V006	TMH0006		Tim Halvorsen	18-May-1981
;		Add F$CVTIME.
;
;	V005	TMH0005		Tim Halvorsen	14-May-1981
;		Add F$PARSE, F$SEARCH, and F$FILE_ATTRIBUTES.
;
;	V004	TMH0004		Tim Halvorsen	16-Mar-1981
;		Have F$MODE return the additional value NETWORK.
;		Return null/zero if SS$_SUSPENDED error is detected
;		from F$GETJPI, rather than signaling an error.  Remove
;		SUSPENDED check from PID, since it will never be used.
;		Add LOGINTIM to the list of valid JPI items.
;		Add functions F$BINARY and F$STRING.
;
;	V003	TMH0003		Tim Halvorsen	04-Feb-1981
;		Do not issue any error messages when substituting
;		a lexical function within a comment string.
;		Use DCL$MARK rather than R6 as a error display pointer.
;		Use WRK_L_EXPANDPTR rather than global register R9.
;		Do not perform any lookahead except using SETCHAR
;		to avoid spuriously setting the quote flag when
;		determining whether given string is a function.
;		Also remove skipping of spaces after the function
;		name to avoid backing up the input pointer if the
;		name is not a function, since backing up over
;		continuations is impossible.
;		Report error if undefined symbol used as string argument.
;		Report error if required argument is missing.
;		Use R10 rather than FP as WRK address.
;		Make use of DCL$MARKEDTOKEN routine.
;		Add F$GETJPI and F$PID functions.
;		Return either binary or string values to caller.
;		Accept numeric values in string arguments by converting
;		the numeric value to a decimal string and using that
;		string as the argument.
;
;	V002	TMH0002		Tim Halvorsen	11-Jan-1981
;		Use standard GETOKEN routine instead of GETXSYM
;		and allow lexical functions or expressions as
;		arguments to lexical functions.  Use WRK_L_CHARPTR
;		instead of R10.
;
;	V001	TMH0001		Tim Halvorsen	09-Sep-1980
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	IDFDEF				;DEFINE INDIRECT FRAME BLOCK
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$DIBDEF				;DEFINE DEVICE INFORMATION FIELDS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS BITS
	$DVIDEF				;DEFINE GETDVI INFORMATION FIELDS
	$JPIDEF				;DEFINE JOB/PROCESS INFORMATION ID'S
	$SYIDEF				;DEFINE GETSYI INFORMATION ID'S
	$PCBDEF				;DEFINE STS FLAG BITS FOR F$MODE
	$FABDEF				;FAB DEFINITIONS
	$NAMDEF				;NAM DEFINITIONS
	$XABDEF				;XAB DEFINITIONS
	$XABALLDEF			;ALLOCATION XAB DEFINITIONS
	$XABDATDEF			;DATE/TIME XAB DEFINITIONS
 	$XABFHCDEF			;FILE HEADER XAB DEFINITIONS
	$XABPRODEF			;PROTECTION XAB DEFINITIONS
	$XABSUMDEF			;SUMMARY ISAM XAB DEFINITIONS

;
; FUNCTION ARGUMENT DEFINITIONS
;
 
MAX_ARGS = 16				;MAXIMUM NUMBER OF ARGUMENTS ALLOWED
NPARM=0					;NUMBER OF PARAMETERS
P1=4					;STACK OFFSET TO PARAMETER 1
P2=12					;STACK OFFSET TO PARAMETER 2
P3=20					;STACK OFFSET TO PARAMETER 3
P4=28					;STACK OFFSET TO PARAMETER 4
P5=36					;STACK OFFSET TO PARAMETER 5
P6=44					;STACK OFFSET TO PARAMETER 6
 
;
; DEFINE FORMAT OF LONGWORD DESCRIBING FUNCTION ARGUMENTS
;
;	BYTE 0:		NUMBER OF ARGUMENTS ALLOWED WITH FUNCTION
;	BYTES 1-3:	ARRAY OF 4 NIBBLES, EACH NIBBLE DESCRIBING AN ARGUMENT
;
;			BITS 0-1: TYPE OF VALUE ALLOWED
;					0 = BINARY
;					1 = STRING
;					2 = REFERENCE TO SYMBOL NAME
;					3 = EITHER STRING OR BINARY
;			BIT 2:	  TRUE IF ARGUMENT OPTIONAL, ELSE REQUIRED
;			BIT 3:	  UNUSED
;
;	IF THE NUMBER OF ARGUMENTS EXCEEDS 4, THEN ALL REMAINING ARGUMENTS
;	ARE TREATED AS "EITHER STRING OR BINARY".
;

ARG_V_TYPE	= 0			; STARTING POSITION OF TYPE FIELD
ARG_S_TYPE	= 2			; SIZE OF TYPE FIELD
ARG_C_BINARY	= 0			; BINARY
ARG_C_STRING	= 1			; STRING
ARG_C_SYMREF	= 2			; REFERENCE TO SYMBOL NAME
ARG_C_ANY	= 3			; EITHER STRING OR BINARY
ARG_V_OPTIONAL	= 2			; TRUE IF ARGUMENT OPTIONAL
ARG_V_KEYWORD   = 3			; TRUE IF KEYWORD ARGUMENT
ARG_C_ENTSIZE	= 8			; SIZE OF ENTRY (NAME PLUS ARGS)

;
; MACRO TO GENERATE LEXICAL FUNCTION DEFINITION TABLE
;
 
	.MACRO	FIRST4	NAME
	.NCHR	$ZZ$,NAME
	$XX$ = 128
	.IRPC	$YY$,NAME
	.BYTE	^A"$YY$"!$XX$
	$XX$ = 0
	.ENDR
	.REPT	4-$ZZ$
	.ASCII	" "
	.ENDR
	.ENDM	FIRST4

	.MACRO	FUNCARG	TYPE,PRESENCE=REQUIRED,FORMAT=VALUE
;	RETURNS $XX$ WITH NIBBLE DESCRIBING ARGUMENT
	$XX$ = -1
	.IIF IDN %EXTRACT(0,1,TYPE),<N>,	$XX$ = ARG_C_BINARY
	.IIF IDN %EXTRACT(0,1,TYPE),<S>,	$XX$ = ARG_C_STRING
	.IIF IDN %EXTRACT(0,1,TYPE),<R>,	$XX$ = ARG_C_SYMREF
	.IIF IDN %EXTRACT(0,1,TYPE),<A>,	$XX$ = ARG_C_ANY
	.IF LT	$XX$
	.ERROR	;INVALID ARGUMENT TYPE.  (STRING, NUMERIC, REFERENCE OR ANY)
	.ENDC
	.IIF IDN <PRESENCE><OPTIONAL>, $XX$ = $XX$ + <1@ARG_V_OPTIONAL>
	.IIF IDN <FORMAT><KEYWORD>, $XX$ = $XX$ + <1@ARG_V_KEYWORD>
	.ENDM	FUNCARG

	.MACRO	FUNCT	NAME,ARGTYPES,FLAGS
	FIRST4	%EXTRACT(0,4,NAME)
	NARGS = 0
	.IRP	$ZZ$,<ARGTYPES>
	NARGS = NARGS + 1
	.ENDR
	.IF IDN <FLAGS><VARIABLE>
	NARGS = MAX_ARGS
	.ENDC
	$ARGS$ = 0
	$BIT$ = 0
	.IRP	$YY$,<ARGTYPES>
	FUNCARG	$YY$
	$ARGS$ = $ARGS$ + <$XX$ @ $BIT$>
	$BIT$ = $BIT$ + 4
	.IIF GT	$BIT$-24, .ERROR ;TOO MANY EXPLICTLY DEFINED ARGUMENTS
	.ENDR
	.LONG	NARGS + <$ARGS$ @ 8>
	.ENDM	FUNCT

;
; LEXICAL FUNCTION DEFINITION TABLE
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

LXFUNTABLE:
	FUNCT	CVSINTEGER,	<N,N,S>		;CONVERT SIGNED INTEGER
	FUNCT	CVUINTEGER,	<N,N,S>		;CONVERT UNSIGNED INTEGER
	FUNCT	CVTIME,		<S>		;CONVERT TO COMPARABLE TIME STRING
	FUNCT	DIRECTORY			;DEFAULT DIRECTORY STRING
	FUNCT	EXTRACT,	<N,N,S>		;EXTRACT SUBSTRING FROM STRING
	FUNCT	FAO,		<S,ANY,ANY,-	;FAO SERVICE
				ANY,ANY,ANY>,VARIABLE 
	FUNCT	FILE_ATTRIBUTES,<S,-		;GET FILE ATTRIBUTES
				<S,REQUIRED,KEYWORD>>
	FUNCT	GETDVI,		<S,-		;GETDVI SYSTEM SERVICE
				<S,REQUIRED,KEYWORD>>
	FUNCT	GETJPI,		<S,-		;GETJPI SYSTEM SERVICE
				<S,REQUIRED,KEYWORD>>
	FUNCT	GETSYI,		<<S,REQUIRED,KEYWORD>>	;GETSYI SYSTEM SERVICE
	FUNCT	INTEGER,	<ANY>		;CONVERT EXPRESSION TO INTEGER
	FUNCT	LENGTH,		<S>		;STRING LENGTH IN BINARY
	FUNCT	LOCATE,		<S,S>		;FIND OFFSET TO SUBSTRING
	FUNCT	LOGICAL,	<S>		;LOGICAL NAME TRANSLATION
	FUNCT	MESSAGE,	<N>		;GET MESSAGE STRING
	FUNCT	MODE				;KEYWORD DESCRIBING TYPE OF JOB
	FUNCT	PARSE,		<-		;PARSE A FILESPEC
				<S>,-		;	PRIMARY FILESPEC
				<S,OPTIONAL>,-	;   	DEFAULT FILESPEC
				<S,OPTIONAL>,-	;   	RELATED (STICKY) FILESPEC
				<S,OPTIONAL,KEYWORD>>;	FILESPEC FIELD DESIRED
	FUNCT	PID,		<REF>		;GET NEXT PROCESS ID STRING
	FUNCT	PRIVILEGE,	<<S,REQUIRED,KEYWORD>>	;TRUE IF PRIVS ARE SET/CLEAR
	FUNCT	PROCESS				;PROCESS NAME STRING
	FUNCT	SEARCH,		<S,<N,OPTIONAL>> 	;GET NEXT WILDCARD FILESPEC
	FUNCT	SETPRV,		<<S,REQUIRED,KEYWORD>>	;SETPRV SYSTEM SERVICE
	FUNCT	STRING,		<ANY>		;CONVERT EXPRESSION TO STRING
	FUNCT	TIME				;TIME OF DAY STRING
	FUNCT	USER				;UIC STRING
	FUNCT	VERIFY,		<<N,OPTIONAL>>	;VERIFY MODE IN BINARY, AND
						;OPTIONALLY CHANGE VERIFY MODE

LXFUNTABLEN=.-LXFUNTABLE		;LENGTH OF LEXICAL FUNCTION TABLE

;
; MACRO TO DEFINE VALID $GETJPI ITEMS WHICH MAY BE USED IN F$GETJPI
;

	.MACRO	GETJPI	NAME,TYPE=BINARY,JPINAME
	.IF NB	JPINAME
	.WORD	JPI$_'JPINAME
	.IFF
	.WORD	JPI$_'NAME
	.ENDC
	$XX$ = 0
	.IIF IDN <TYPE><BINARY>,	$XX$=0
	.IIF IDN <TYPE><STRING>,	$XX$=1
	.IIF IDN <TYPE><HEX>,		$XX$=2
	.IIF IDN <TYPE><PRIV>,		$XX$=3
	.BYTE	$XX$
	.ASCIC	"NAME"
	.ENDM	GETJPI

;
; DEFINE VALID $GETJPI ITEMS WHICH MAY BE USED IN F$GETJPI
;

GETJPI_TABLE:
	GETJPI	ACCOUNT,STRING
	GETJPI	APTCNT
	GETJPI	ASTACT
	GETJPI	ASTCNT
	GETJPI	ASTEN
	GETJPI	ASTLM
	GETJPI	AUTHPRIV,PRIV
	GETJPI	BIOCNT
	GETJPI	BIOLM
	GETJPI	BUFIO
	GETJPI	BYTCNT
	GETJPI	BYTLM
	GETJPI	CPULIM
	GETJPI	CPUTIM
	GETJPI	CURPRIV,PRIV
	GETJPI	DFPFC
	GETJPI	DFWSCNT
	GETJPI	DIOCNT
	GETJPI	DIOLM
	GETJPI	DIRIO
	GETJPI	EFCS
	GETJPI	EFCU
	GETJPI	EFWM
	GETJPI	ENQCNT
	GETJPI	ENQLM
	GETJPI	EXCVEC,HEX
	GETJPI	FILCNT
	GETJPI	FILLM
	GETJPI	FINALEXC,HEX
	GETJPI	FREP0VA
	GETJPI	FREP1VA
	GETJPI	FREPTECNT
	GETJPI	GPGCNT
	GETJPI	GRP
	GETJPI	IMAGNAME,STRING
	GETJPI	IMAGPRIV,PRIV
	GETJPI	JOBPRCCNT
	GETJPI	LOGINTIM,STRING
	GETJPI	MEM
	GETJPI	OWNER,HEX
	GETJPI	PAGEFLTS
	GETJPI	PAGFILCNT
	GETJPI	PGFLQUOTA
	GETJPI	PID,HEX
	GETJPI	PPGCNT
	GETJPI	PRCCNT
	GETJPI	PRCLM
	GETJPI	PRCNAM,STRING
	GETJPI	PRI
	GETJPI	PRIB
	GETJPI	PROCPRIV,PRIV
	GETJPI	SITESPEC
	GETJPI	STATE
	GETJPI	STS
	GETJPI	MODE,STRING,STS		; SPECIAL - KEYWORD DESCRIBING JOB MODE
	GETJPI	TERMINAL,STRING
	GETJPI	TMBU
	GETJPI	TQCNT
	GETJPI	TQLM
	GETJPI	UIC
	GETJPI	USERNAME,STRING
	GETJPI	VIRTPEAK
	GETJPI	VOLUMES
	GETJPI	WSAUTH
	GETJPI	WSAUTHEXT
	GETJPI	WSEXTENT
	GETJPI	WSPEAK
	GETJPI	WSQUOTA
	GETJPI	WSSIZE
	.LONG	0

;
; MACRO TO DEFINE VALID $GETSYI ITEMS WHICH MAY BE USED IN F$GETSYI
;

	.MACRO	GETSYI	NAME,TYPE=BINARY,SYINAME
	.IF NB	SYINAME
	.WORD	SYI$_'SYINAME
	.IFF
	.WORD	SYI$_'NAME
	.ENDC
	$XX$ = 0
	.IIF IDN <TYPE><BINARY>,	$XX$=0
	.IIF IDN <TYPE><STRING>,	$XX$=1
	.BYTE	$XX$
	.ASCIC	"NAME"
	.ENDM	GETSYI

;
; DEFINE VALID $GETSYI ITEMS WHICH MAY BE USED IN F$GETSYI
;

GETSYI_TABLE:
	GETSYI	VERSION,STRING
	GETSYI	SID
	GETSYI	CPU
	.LONG	0

;
; PRODUCE A TABLE OF ASCIC NAMES DESCRIBING EACH OF THE PROCESS STATES
;

	.MACRO	$DEFINI NAME,P1,P2
	.ENDM
	.MACRO	$DEFEND NAME,P1,P2
	.ENDM
	.MACRO	$EQU SYMBOL,VALUE
S = %LOCATE(<_>,SYMBOL)+1
L = %LENGTH(SYMBOL)-S
	.ASCIC	/%EXTRACT(S,L,SYMBOL)/
	.BLKB	8-<L+1>
	.ENDM	$EQU

STATE_TABLE:
	.ASCIC	'ILLEGAL'		; FOR ZERO CASE
	$STATEDEF			; TABLE OF PROCESS STATE NAMES

	.MDELETE	$DEFINI,$DEFEND,$EQU


;
; MACRO TO DEFINE VALID DATA ITEMS WHICH MAY BE USED IN F$FILE_ATTRIBUTES
;

	.MACRO	FILITEM	NAME,BLOCK,FIELD,SIZE,BITNUM,TYPE=BINARY
	$XX$ = 0
	.IIF IDN <BLOCK><FAB>,		$XX$=0
	.IIF IDN <BLOCK><NAM>,		$XX$=1
	.IIF IDN <BLOCK><XABALL>,	$XX$=2
	.IIF IDN <BLOCK><XABDAT>,	$XX$=3
	.IIF IDN <BLOCK><XABFHC>,	$XX$=4
	.IIF IDN <BLOCK><XABPRO>,	$XX$=5
	.IIF IDN <BLOCK><XABSUM>,	$XX$=6
	.BYTE	$XX$			; RMS BLOCK ID
	$XX$ = 0
	.IIF NB	<FIELD>,$XX$ = 'FIELD'
	.BYTE	$XX$			; OFFSET TO FIELD IN RMS BLOCK
	$XX$ = 0
	.IIF IDN <SIZE><BIT>,		$XX$=1
	.IIF IDN <SIZE><BYTE>,		$XX$=8
	.IIF IDN <SIZE><WORD>,		$XX$=16
	.IIF IDN <SIZE><LONG>,		$XX$=32
	.BYTE	$XX$			; SIZE OF FIELD
	$XX$ = 0
	.IIF NB <BITNUM>,$XX$ = 'BITNUM'
	.BYTE	$XX$			; BIT NUMBER
	$XX$ = 0
	.IIF IDN <TYPE><BINARY>,	$XX$=0
	.IIF IDN <TYPE><DATE>,		$XX$=1
	.IIF IDN <TYPE><ASCIC>,		$XX$=2
	.IIF IDN <TYPE><FILEID>,	$XX$=3
	.IIF IDN <TYPE><ORG>,		$XX$=4
	.IIF IDN <TYPE><RAT>,		$XX$=5
	.IIF IDN <TYPE><RFM>,		$XX$=6
	.IIF IDN <TYPE><UIC>,		$XX$=7
	.IIF IDN <TYPE><PROT>,		$XX$=8
	.IIF IDN <TYPE><EOF>,		$XX$=9
	.IIF IDN <TYPE><BOOLEAN>,	$XX$=10
	.BYTE	$XX$			; TYPE OF DATA ITEM
	.ASCIC	"NAME"			; ASCIC NAME OF DATA ITEM
	.ENDM	FILITEM

;
; DEFINE XAB BLOCK ID'S AND LENGTHS
;

XAB_INFO:
	.BYTE	XAB$C_ALL,XAB$C_ALLLEN
	.BYTE	XAB$C_DAT,XAB$C_DATLEN
	.BYTE	XAB$C_FHC,XAB$C_FHCLEN
	.BYTE	XAB$C_PRO,XAB$C_PROLEN
	.BYTE	XAB$C_SUM,XAB$C_SUMLEN

;
; DEFINE VALID DATA ITEMS WHICH MAY BE USED IN F$FILE_ATTRIBUTES
;

FILE_TABLE:
	FILITEM	ALQ,FAB,FAB$L_ALQ,SIZE=LONG	;ALLOCATION QUANTITY
	FILITEM	BKS,FAB,FAB$B_BKS,SIZE=BYTE	;BUCKET SIZE
	FILITEM	BLS,FAB,FAB$W_BLS,SIZE=WORD	;BLOCK SIZE
	FILITEM	DEQ,FAB,FAB$W_DEQ,SIZE=WORD	;DEFAULT EXTENSION QUANTITY
	FILITEM	FSZ,FAB,FAB$B_FSZ,SIZE=BYTE	;FIXED CONTROL AREA SIZE
	FILITEM	MRN,FAB,FAB$L_MRN,SIZE=LONG	;MAXIMUM RECORD NUMBER
	FILITEM	MRS,FAB,FAB$W_MRS,SIZE=WORD	;MAXIMUM RECORD SIZE
	FILITEM	ORG,FAB,FAB$B_ORG,SIZE=BYTE,TYPE=ORG	;FILE ORGANIZATION
	FILITEM	RAT,FAB,FAB$B_RAT,SIZE=BYTE,TYPE=RAT	;RECORD ATTRIBUTES
	FILITEM	RFM,FAB,FAB$B_RFM,SIZE=BYTE,TYPE=RFM	;RECORD FORMAT
	FILITEM	CTG,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_CTG,TYPE=BOOLEAN ;CONTIGUOUS
	FILITEM	CBT,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_CBT,TYPE=BOOLEAN ;CONTIGUOUS-BEST-TRY
	FILITEM	RCK,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_RCK,TYPE=BOOLEAN ;READ CHECK
	FILITEM	WCK,FAB,FAB$L_FOP,SIZE=BIT,BITNUM=FAB$V_WCK,TYPE=BOOLEAN ;WRITE CHECK
	FILITEM	CDT,XABDAT,XAB$Q_CDT,TYPE=DATE	;CREATION DATE/TIME
	FILITEM	EDT,XABDAT,XAB$Q_EDT,TYPE=DATE	;EXPIRATION DATE/TIME
	FILITEM	RDT,XABDAT,XAB$Q_RDT,TYPE=DATE	;REVISION DATE/TIME
	FILITEM	BDT,XABDAT,XAB$Q_BDT,TYPE=DATE	;BACKUP DATE/TIME
	FILITEM	RVN,XABDAT,XAB$W_RVN,SIZE=WORD	;REVISION NUMBER
	FILITEM	UIC,XABPRO,XAB$W_MBM,SIZE=LONG,TYPE=UIC ;OWNER UIC STRING
	FILITEM	GRP,XABPRO,XAB$W_GRP,SIZE=WORD	;OWNER GROUP NUMBER
	FILITEM	MBM,XABPRO,XAB$W_MBM,SIZE=WORD	;OWNER MEMBER NUMBER
	FILITEM	PRO,XABPRO,XAB$W_PRO,SIZE=WORD,TYPE=PROT ;FILE PROTECTION BITMASK
	FILITEM	EOF,XABFHC,XAB$L_EBK,SIZE=LONG,TYPE=EOF	;END-OF-FILE BLOCK NUMBER
	FILITEM	NOA,XABSUM,XAB$B_NOA,SIZE=BYTE	;NUMBER OF AREAS
	FILITEM	NOK,XABSUM,XAB$B_NOK,SIZE=BYTE	;NUMBER OF KEYS
	FILITEM	PVN,XABSUM,XAB$W_PVN,SIZE=WORD	;PROLOGUE VERSION NUMBER
	FILITEM	DID,NAM,NAM$W_DID,TYPE=FILEID	;DIRECTORY ID NUMBER
	FILITEM	FID,NAM,NAM$W_FID,TYPE=FILEID	;FILE ID NUMBER
	FILITEM	DVI,NAM,NAM$T_DVI,TYPE=ASCIC	;DEVICE NAME STRING
	.QUAD	0

;
; MACRO TO DEFINE VALID F$PARSE FILESPEC FIELDS
;

	.MACRO	FILFLD	NAME,LENGTH,ADDRESS
	.ASCIC	"NAME"
	.BYTE	LENGTH			;OFFSET TO LENGTH BYTE IN NAM
	.BYTE	ADDRESS			;OFFSET TO ADDRESS LONGWORD IN NAM
	.ENDM

;
; DEFINE VALID FILESPEC FIELDS WHICH MAY BE RETURNED BY F$PARSE
;

PARSE_FIELDS:
	FILFLD	NODE,NAM$B_NODE,NAM$L_NODE
	FILFLD	DEVICE,NAM$B_DEV,NAM$L_DEV
	FILFLD	DIRECTORY,NAM$B_DIR,NAM$L_DIR
	FILFLD	NAME,NAM$B_NAME,NAM$L_NAME
	FILFLD	TYPE,NAM$B_TYPE,NAM$L_TYPE
	FILFLD	VERSION,NAM$B_VER,NAM$L_VER
	.BYTE	0

;
; MACRO TO DEFINE VALID $GETDVI ITEMS WHICH MAY BE USED IN F$GETDVI
;

	.MACRO	GETDVI	NAME,TYPE=BINARY,DVINAME
	.IF NB	DVINAME
	.WORD	DVI$_'DVINAME
	.IFF
	.WORD	DVI$_'NAME
	.ENDC
	$XX$ = 0
	.IIF IDN <TYPE><BINARY>,	$XX$=0
	.IIF IDN <TYPE><STRING>,	$XX$=1
	.IIF IDN <TYPE><UIC>,		$XX$=2
	.IIF IDN <TYPE><BOOLEAN>,	$XX$=3
	.IIF IDN <TYPE><HEX>,		$XX$=4
	.IIF IDN <TYPE><PROT>,		$XX$=5
	.IIF IDN <TYPE><ACP>,		$XX$=6
	.BYTE	$XX$
	.IF IDN <TYPE><BOOLEAN>
	.BYTE	DEV$V_'NAME
	.IFF
	.BYTE	0
	.ENDC
	.ASCIC	"NAME"
	.ENDM	GETDVI

DEV$V_CONCEALED = -1		;SYMBOLS REQUIRED FOR FAKE BOOLEAN FLAGS
DEV$V_EXISTS = -2

;
; DEFINE VALID $GETDVI ITEMS WHICH MAY BE USED IN F$GETDVI
;

GETDVI_TABLE:
	GETDVI	DEVCHAR
	GETDVI	DEVCLASS
	GETDVI  DEVTYPE
	GETDVI	DEVBUFSIZ
	GETDVI	DEVDEPEND
	GETDVI	UNIT
	GETDVI	PID,HEX
	GETDVI	OWNUIC,UIC
	GETDVI	VPROT,PROT
	GETDVI	ERRCNT
	GETDVI	OPCNT
	GETDVI	RECSIZ
	GETDVI	MAXBLOCK
	GETDVI	DEVDEPEND2
	GETDVI	REFCNT
	GETDVI	DEVNAM,STRING
	GETDVI	VOLNAM,STRING
	GETDVI  SECTORS
	GETDVI	TRACKS
	GETDVI	CYLINDERS
	GETDVI	FREEBLOCKS
	GETDVI	LOGVOLNAM,STRING
	GETDVI	VOLNUMBER
	GETDVI	VOLCOUNT
	GETDVI	ROOTDEVNAM,STRING
	GETDVI	NEXTDEVNAM,STRING
	GETDVI	TRANSCNT
	GETDVI	MOUNTCNT
	GETDVI	CLUSTER
	GETDVI	MAXFILES
	GETDVI	SERIALNUM
	GETDVI	ACPPID,HEX
	GETDVI	ACPTYPE,ACP

	GETDVI	SPLDEVNAM,STRING,DEVNAM
	GETDVI	CONCEALED,BOOLEAN,DEVCHAR
	GETDVI	EXISTS,BOOLEAN,DEVCHAR

	GETDVI	REC,BOOLEAN,DEVCHAR
	GETDVI	CCL,BOOLEAN,DEVCHAR
	GETDVI	TRM,BOOLEAN,DEVCHAR
	GETDVI	DIR,BOOLEAN,DEVCHAR
	GETDVI	SDI,BOOLEAN,DEVCHAR
	GETDVI	SQD,BOOLEAN,DEVCHAR
	GETDVI	SPL,BOOLEAN,DEVCHAR
	GETDVI	OPR,BOOLEAN,DEVCHAR
	GETDVI	NET,BOOLEAN,DEVCHAR
	GETDVI	FOD,BOOLEAN,DEVCHAR
	GETDVI	SHR,BOOLEAN,DEVCHAR
	GETDVI	GEN,BOOLEAN,DEVCHAR
	GETDVI	AVL,BOOLEAN,DEVCHAR
	GETDVI	MNT,BOOLEAN,DEVCHAR
	GETDVI	MBX,BOOLEAN,DEVCHAR
	GETDVI	DMT,BOOLEAN,DEVCHAR
	GETDVI	ELG,BOOLEAN,DEVCHAR
	GETDVI	ALL,BOOLEAN,DEVCHAR
	GETDVI	FOR,BOOLEAN,DEVCHAR
	GETDVI	SWL,BOOLEAN,DEVCHAR
	GETDVI	IDV,BOOLEAN,DEVCHAR
	GETDVI	ODV,BOOLEAN,DEVCHAR
	GETDVI	RND,BOOLEAN,DEVCHAR
	GETDVI	RTM,BOOLEAN,DEVCHAR
	GETDVI	RCK,BOOLEAN,DEVCHAR
	GETDVI	WCK,BOOLEAN,DEVCHAR
	.QUAD	0			; END = ZERO LENGTH NAME

;
; BUILD TABLE OF ACP TYPES
;

	$XX$ = 1
	.MACRO	ACP NAME
	ASSUME	DVI$C_ACP_'NAME EQ $XX$
	$XX$ = $XX$ + 1
	.ASCIC	"NAME"
	.BLKB	8 - <%LENGTH(NAME)+1>
	.ENDM	ACP

ACP_TABLE:
	.ASCIC	'ILLEGAL'
	ACP	F11V1
	ACP	F11V2
	ACP	MTA
	ACP	NET
	ACP	REM
	.ASCIC	'ILLEGAL'

;
; RESULTANT RETURN STRINGS FOR STATE AND MODE RETURN VALUES
;
 
BATCH:
	.ASCIC	'BATCH'			;BATCH JOB
INTERACTIVE:
	.ASCIC	'INTERACTIVE'		;INTERACTIVE JOB
DETACHED:
	.ASCIC	'DETACHED'		;DETACHED JOB
NETWORK:
	.ASCIC	'NETWORK'		;NETWORK JOB

NOALL:	.ASCII	'NOALL'			;KEYWORD FOR [NO]ALL PRIVILEGES
FALSE:	.ASCIC	'FALSE'			;BOOLEAN FALSE VALUE
TRUE:	.ASCIC	'TRUE'			;BOOLEAN TRUE VALUE

	.SBTTL	EVALUATE LEXICAL FUNCTION STRING
;---
; DCL$FUNCTION - EVALUATE A LEXICAL FUNCTION STRING
;
; THIS ROUTINE CAN BE CALLED TO EVALUATE A STRING WHICH CONTAINS
; A LEXICAL FUNCTION AND ITS ARGUMENTS, AND RETURNS ITS VALUE.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF FUNCTION/SYMBOL STRING
;	R3/R4 = DESCRIPTOR OF SCRATCH STORAGE
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF VALUE STRING (NULL IF ERROR)
;---
	.IF DF	SUPRESS_CODE		;NOBODY CALLS THIS AT THE MOMENT

DCL$FUNCTION::
	PUSHR	#^M<R3,R4,R5,R6,R7>	;SAVE REGISTERS
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE EXPANSION BUFFER POINTER
	PUSHL	WRK_L_CHARPTR(R10)	;SAVE INPUT BUFFER POINTER
	STATUS	BUFOVF			;ASSUME BUFFER OVERFLOW
	CMPL	R1,R3			;CHECK IF STRING TOO BIG FOR BUFFER
	BGEQ	90$			;SKIP IT IF ITS TOO LONG
	MOVL	R4,WRK_L_EXPANDPTR(R10)	;PUT EXPANSION IN FRONT OF BUFFER
	MOVAB	-2(R4)[R3],R0		;CALCULATE ENDING ADDRESS OF BUFFER
	SUBL	R1,R0			;SUBTRACT LENGTH OF INPUT STRING
	MOVL	R0,WRK_L_CHARPTR(R10)	;SET INPUT CHARACTER POINTER TO STRING
	MOVC	R1,(R2),1(R0)		;STORE INPUT STRING ON STACK
	CLRB	(R3)+			;TERMINATE INPUT STRING WITH EOL CHAR
	BSBW	DCL$GETOKEN		;GET FUNCTION NAME STRING
	MOVQ	R1,R6			;AND PASS TO DCL$LEXIF
	BSBB	DCL$LEXIF		;EVALUATE LEXICAL FUNCTION
90$:	POPL	WRK_L_CHARPTR(R10)	;RESTORE INPUT BUFFER POINTER
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	POPR	#^M<R3,R4,R5,R6,R7>	;RESTORE REGISTERS
	RSB

	.ENDC

	.SBTTL	LEXICAL FUNCTION DISPATCHER
;+
; DCL$LEXIF - LEXICAL FUNCTION DISPATCH ROUTINE
;
; THIS ROUTINE IS CALLED WHEN A STRING SUBSTITUTION IS SPECIFIED AND THE STRING
; IS CURRENTLY UNDEFINED.
;
; INPUTS:
;
;	R6 = LENGTH OF SYMBOL NAME.
;	R7 = ADDRESS OF SYMBOL NAME.
;	R10 = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	THE SYMBOL NAME IS MATCHED WITH THE LEXICAL FUNCTION TABLE. IF NO MATCH
;	OCCURS, THEN A NULL STRING IS RETURNED FOR SUBSTITUTION IN THE ORIGINAL
;	COMMAND LINE. IF A MATCH OCCURS, THEN THE APPROPRIATE LEXICAL FUNCTION
;	IS EVALUATED AND THE RESULTANT STRING IS RETURNED.
;
;	R1/R2 = A QUADWORD DESCRIBING THE FUNCTION RESULT
;		IF R2 NONZERO, THEN R1/R2 IS A STRING DESCRIPTOR
;		IF R2 ZERO, THEN R1 IS A BINARY LONGWORD VALUE.
;
;	INPUT AND EXPANSION POINTERS ARE UPDATED AS APPROPRIATE.
;-
 
DCL$LEXIF::				;LEXICAL FUNCTION DISPATCH
	PUSHR	#^M<R3,R4,R5,R6,R7,R8,R9,AP> ; SAVE REGISTERS
	MOVL	SP,AP			;MARK STACK ADDRESS
	CMPL	#6,R6			;SPECIFIED NAME LONGER THAN 6 CHARACTERS?
	BGTRU	10$			;IF GTRU NO
	MOVL	#6,R6			;REDUCE LENGTH TO 6 CHARACTERS
10$:	CMPW	#^A/F$/,(R7)+		;POSSIBLY LEXICAL FUNCTION NAME?
	BNEQ	60$			;IF NEQ NO
	BSBW	DCL$SETCHAR		;CHECK CHARACTER AFTER FUNCTION NAME
	CMPB	#^A/(/,R0		;POSSIBLY LEXICAL FUNCTION?
	BNEQ	60$			;IF NEQ NO
	SUBL	#2,R6			;REDUCE LENGTH OF FUNCTION NAME
	BGTR	18$			;IF LEQ NOT LEXICAL FUNCTION NAME
60$:	CLRQ	R0			;FAILURE, NO SUCH FUNCTION, NULL VALUE
	MOVL	SP,R2			;INDICATE RESULT IS A STRING
	BRW	90$			;EXIT
70$:	STATUS	IVFNAM			;SET INVALID FUNCTION NAME STATUS
	BRB	85$
80$:	STATUS	ABFNAM			;SET AMBIGUOUS FUNCTION NAME STATUS
85$:	MOVAW	-(R7),WRK_L_MARKPTR(R10) ;SET STARTING ADDRESS OF FUNCTION NAME
	BRW	DCL$PARSERR

;
; SEARCH LEXICAL FUNCTION NAME TABLE FOR A MATCH
;
18$:	BSBW	DCL$MOVCHAR		;COPY ( CHARACTER
	BISB	#^X80,(R7)		;SET FORCE MATCH FLAG
	MATCHC	R6,(R7),#LXFUNTABLEN,LXFUNTABLE ;SEARCH FOR FUNCTION NAME MATCH
	BNEQ	70$			;BRANCH IF NO MATCH FOUND
	ADDL	R6,R2			;CALCULATE BYTES REMAINING INCLUDING SUBSTRING
	DIVL3	#ARG_C_ENTSIZE,R2,R8	;CALCULATE COMPLETE TABLE ENTRY NUMBER
	MATCHC	R6,(R7),#10,(R3)	;SCAN FOR DUPLICATE MATCH
	BEQL	80$			;IF EQL DUPLICATE MATCH FOUND
;
; DETERMINE THE FUNCTION INDEX (R8) AND RETRIEVE THE NUMBER OF ARGUMENTS
; THAT THE FUNCTION TAKES AS WELL AS THE ARGUMENT TYPES (NUMERIC OR STRING).
;
	SUBL3	R8,#LXFUNTABLEN/ARG_C_ENTSIZE,R8 ;CALCULATE REAL FUNCTION INDEX
	ASSUME	ARG_C_ENTSIZE EQ 8
	MOVAQ	LXFUNTABLE+4[R8],R7	;POINT TO ARGUMENT INFORMATION LONGWORD
	MOVL	(R7),R7			;SAVE IT IN REGISTER
;
; PARSE EACH FUNCTION ARGUMENT, STORING EITHER THE STRING DESCRIPTOR OR
; THE NUMERIC VALUE IN THE ARGUMENT DESCRIPTORS.  STRINGS ARE SAVED ON
; THE STACK IN ORDER TO MAKE FUNCTIONS RECURSIVE.
;
	MOVAB	-<MAX_ARGS*8+4>(SP),SP	;ALLOCATE ARGUMENT DESCRIPTORS + COUNT
	MOVC5	#0,(SP),#^XFF,#MAX_ARGS*8,4(SP) ;INIT ALL ARGS TO MISSING (-1)
	PUSHL	AP			;SAVE STARTING STACK ADDRESS IN -4(AP)
	MOVAB	4(SP),AP		;POINT TO START OF ARGUMENT LIST
	MOVL	AP,R5			;ADDRESS OF NEXT DESCRIPTOR TO FILL
	CLRL	(R5)+			;INITIALIZE # ARGUMENTS SPECIFIED

20$:	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS AND TABS
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	CMPB	NPARM(AP),R7		;ANY MORE ARGUMENTS TO PROCESS?
	BLSS	21$			;IF GEQ YES
	BRW	50$			;END OF ARGUMENTS
21$:	MOVL	#ARG_C_ANY,R6		;ASSUME EITHER BINARY OR STRING
	CMPB	NPARM(AP),#6		;BEYOND EXPLICITLY DEFINED ARGS?
	BGEQ	23$			;IF SO, ASSUME "ANY"
	ASHL	#2,NPARM(AP),R6		;CALCULATE OFFSET TO NIBBLE
	ADDL	#8,R6			;BIT POSITION OF NIBBLE IN R7
	EXTZV	R6,#8,R7,R6		;EXTRACT NIBBLE DESCRIBING ARGUMENT
					;AND NIBBLE DESCRIBING NEXT ARGUMENT
					;AS WELL, FOR END-OF-LIST CHECKS
;
; CHECK IF ARGUMENT MISSING
;
23$:	CMPB	R0,#^A','		;CHECK IF ARGUMENT NULL
	BEQL	28$			;BRANCH IF NULL
	CMPB	R0,#^A')'		;CHECK IF ARGUMENT NULL
	BEQL	28$			;BRANCH IF NULL
;
; PARSE ARGUMENT EXPRESSION
;
	CMPZV	#ARG_V_TYPE,#ARG_S_TYPE,R6,#ARG_C_SYMREF ;REFERENCE TO SYMBOL?
	BEQL	30$			;BRANCH IF SO
	BSBW	DCL$EXPRESS		;GET VALUE OF EXPRESSION
	BLBC	R0,22$			;BRANCH IF ERROR DETECTED
;
; VERIFY THAT THE EXPRESSION ARGUMENT WAS THE EXPECTED TYPE (STRING OR BINARY)
; IF IT WASN'T, THEN CONVERT THE EXPRESSION TO THE PROPER MODE, IF POSSIBLE.
;
	CMPZV	#ARG_V_TYPE,#ARG_S_TYPE,R6,#ARG_C_ANY ;ANY TYPE ALLOWED?
	BEQL	40$			;BRANCH IF SO
	TSTL	R2			;CHECK IF STRING OR BINARY LONGWORD
	ASSUME	ARG_C_BINARY EQ 0
	ASSUME	ARG_C_STRING EQ 1
	BLBS	R6,27$			;BRANCH IF EXPECTED STRING ARGUMENT
	BEQL	40$			;OK IF EXPECTED NUMERIC AND GOT IT
	BSBW	DCL$CVT_BINARY		;CONVERT STRING TO BINARY
	BLBC	R0,22$			;BRANCH IF ERROR DETECTED
	BRB	40$
27$:	BNEQ	40$			;OK IF EXPECTED STRING AND GOT IT
	MOVL	R1,R0			;SET BINARY VALUE TO CONVERT
	BSBW	DCL$CBTA_DEC		;CONVERT BINARY VALUE TO DECIMAL STRING
	BRB	40$			;USE CONVERTED STRING AS ARGUMENT
;
; AN ERROR HAS OCCURRED.  IF WE ARE IN A GOTO OR COMMENT, JUST STORE
; AN ARGUMENT OF NULL OR ZERO AND CONTINUE.
;
22$:	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),24$ ;SKIP ERRORS WHILE IN GOTO
	BBS	#WRK_V_COMMENT,WRK_W_FLAGS(R10),24$ ;SKIP IF IN COMMENT
	BRW	DCL$PARSERR		;OTHERWISE, REPORT THE ERROR
24$:	CLRQ	R1			;IF IN GOTO, CONTINUE WITH A ZERO
	BRB	40$
;
; PROCESS AN EMPTY ARGUMENT.  IF ALLOWED, -1 WILL APPEAR IN THE QUADWORD
; TO INDICATE MISSING ARGUMENT.
;
28$:	BBS	#ARG_V_OPTIONAL,R6,43$	;BRANCH IF OPTIONAL VALUES ALLOWED
	BSBW	DCL$MOVCHAR		;MOVE DELIMITER TO EXPANSION BUFFER
29$:	BRW	100$			;AND REPORT INVALID DELIMITER STATUS
;
; PARSE ARGUMENT TO BE STORED BY REFERENCE RATHER THAN BY VALUE
;
30$:	BSBW	DCL$GETOKEN		;GET ARGUMENT SYMBOL OR LITERAL
	CMPB	(R2),#^A'"'		;QUOTED STRING?
	BEQL	29$			;IF SO, ERROR - NOT BY REFERENCE
;
; STORE STRING ARGUMENT ON STACK TO PRESERVE IT OVER RECURSION
;
40$:	TSTL	R2			;STRING ARGUMENT?
	BEQL	42$			;IF NOT, JUST STORE LONGWORD
	BBC	#ARG_V_KEYWORD,R6,41$	;KEYWORD ARGUMENT?
	BSBW	DCL$REMBLANKS		;YES, THEN REMOVE BLANKS AND UPCASE
41$:	SUBL	R1,SP			;ALLOCATE SPACE FOR STRING ON STACK
	MOVL	R1,(R5)+		;SAVE STRING LENGTH
	MOVL	SP,(R5)+		;SAVE (COPIED) STRING ADDRESS
	PUSHL	R5			;SAVE REGISTERS
	MOVC	R1,(R2),4(SP)		;SAVE ARGUMENT STRING ON STACK
	POPL	R5			;RESTORE REGISTERS
	BRB	45$

42$:	MOVQ	R1,(R5)			;STORE VALUE IN QUADWORD
43$:	ADDL	#8,R5			;SKIP TO NEXT ARGUMENT DESCRIPTOR
45$:	INCL	NPARM(AP)		;INCREMENT # ARGUMENTS FOUND
	BSBW	DCL$SETNBLK		;SKIP TRAILING SPACES
	CMPB	NPARM(AP),R7		;LAST PARAMETER TO PROCESS?
	BEQL	50$			;IF EQL YES
	BSBW	DCL$MOVCHAR		;GET NEXT INPUT CHARACTER
	CMPB	#^A/,/,R0		;TRAILING COMMA?
	BNEQ	48$			;BRANCH IF NOT
	BRW	20$			;LOOP THRU ALL ARGUMENTS
48$:	CMPB	R7,#6			;VARIABLE # ARGUMENTS?
	BGTRU	55$			;BRANCH IF SO
	BBS	#4+ARG_V_OPTIONAL,R6,55$ ;OK IF NEXT ARGUMENT IS OPTIONAL
	BRB	100$			;ERROR IF REQUIRED ARGUMENT NOT PRESENT

50$:	BSBW	DCL$MOVCHAR		;GET NEXT INPUT CHARACTER
55$:	CMPB	#^A/)/,R0		;TRAILING RIGHT PARENTHESIS?
	BNEQ	100$			;IF NEQ NO
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
;
; CONSTRUCT A DESCRIPTOR OF SCRATCH BUFFER SPACE AND CALL THE APPROPRIATE
; LEXICAL FUNCTION ROUTINE TO OBTAIN THE RESULT STRING.
;
	MOVL	WRK_L_EXPANDPTR(R10),R3	;BUILD DESCRIPTOR OF SCRATCH AREA
	SUBL3	WRK_L_EXPANDPTR(R10),WRK_L_CHARPTR(R10),R2 ;SET UNUSED LENGTH
	BSBB	DISPATCH		;DISPATCH FUNCTION
;
; R1/R2 NOW DESCRIBE THE FUNCTION RESULT:
;	IF R2 NONZERO, R1/R2 ARE A STRING DESCRIPTOR
;	IF R2 ZERO, R1 IS A BINARY LONGWORD VALUE
;
; RESULTANT STRING MIGHT NOW RESIDE ON THE STACK (E.G. AN EXTRACT
; OF AN ARGUMENT STORED ON THE STACK).  WE MUST COPY IT TO THE EXPANSION
; BUFFER BEFORE RETURNING IT TO THE CALLER.
;
	TSTL	R2			;CHARACTER STRING?
	BEQL	58$			;BRANCH IF NOT
	MOVL	R1,R6			;SAVE LENGTH OF STRING
	MOVC	R1,(R2),@WRK_L_EXPANDPTR(R10) ;COPY IT TO UNUSED EXPANSION AREA
	MOVL	R6,R1			;RETURN LENGTH OF RESULT STRING
	MOVL	WRK_L_EXPANDPTR(R10),R2	;AND ADDRESS OF RESULT STRING
58$:	MOVL	#1,R0			;SUCCESS
	MOVL	-(AP),SP		;REMOVE ALL TEMPORARIES FROM STACK
90$:	POPR	#^M<R3,R4,R5,R6,R7,R8,R9,AP> ; RESTORE REGISTERS
	RSB
 
;
; INVALID SYMBOL DELIMITER
;
 
100$:	STATUS	SYMDEL			;SET INVALID SYMBOL DELIMITER STATUS
	MOVL	WRK_L_CHARPTR(R10),WRK_L_EXPANDPTR(R10) ;SET ADDRESS OF NEXT CHARACTER IN BUFFER
	SUBL3	#1,WRK_L_EXPANDPTR(R10),WRK_L_MARKPTR(R10) ;SET ADDRESS OF INVALID DELIMITER
	TSTB	@WRK_L_CHARPTR(R10)	;AT END OF LINE?
	BNEQ	110$			;IF NEQ NO
	DECL	WRK_L_CHARPTR(R10)	;BACK UP TO END OF LINE
110$:	BRW	DCL$PARSERR		;

;
; DISPATCH TO PROPER LEXICAL FUNCTION ROUTINE
;
; ON INPUT TO ROUTINE:
;
;	R2/R3 = DESCRIPTOR OF SCRATCH AREA
;	R10 = ADDRESS OF PARSING WORK AREA (WRK)
;	R11 = ADDRESS OF PROCESS WORK AREA (PRC)
;
;	P1(AP) = DESCRIPTOR OF FIRST ARGUMENT VALUE
;	P2(AP) = DESCRIPTOR OF SECOND ARGUMENT VALUE
;	P3(AP) = DESCRIPTOR OF THIRD ARGUMENT VALUE
;	ETC. (UP TO MAX_ARGS)
;
; ON OUTPUT FROM ROUTINE:
;
;	R1/R2 = A QUADWORD DESCRIBING THE FUNCTION RESULT
;		IF R2 NONZERO, THEN R1/R2 IS A STRING DESCRIPTOR
;		IF R2 ZERO, THEN R1 IS A BINARY LONGWORD VALUE.
;
;	R3-R9 DESTROYED.
;
 
DISPATCH:
	CASE	R8,<-
		F$CVSINTEGER,-		;CONVERT SIGNED INTEGER
		F$CVUINTEGER,-		;CONVERT UNSIGNED INTEGER
		F$CVTIME,-		;CONVERT TO COMPARABLE DATE/TIME
		F$DIRECTORY,-		;DEFAULT DIRECTORY
		F$EXTRACT,-		;EXTRACT SUBSTRING FROM STRING
		F$FAO,-			;FORMATTED ASCII OUTPUT
		F$FILE,-		;GET FILE ATTRIBUTES
		F$GETDVI,-		;GETDVI SYSTEM SERVICE
		F$GETJPI,-		;GETJPI SYSTEM SERVICE
		F$GETSYI,-		;GETSYI SYSTEM SERVICE
		F$INTEGER,-		;CONVERT TO INTEGER
		F$LENGTH,-		;STRING LENGTH
		F$LOCATE,-		;LOCATE SUBSTRING
		F$LOGICAL,-		;LOGICAL NAME TRANSLATION
		F$MESSAGE,-		;GET MESSAGE
		F$MODE,-		;JOB MODE
		F$PARSE,-		;PARSE FILE SPECIFICATION
		F$PID,-			;GET NEXT PROCESS ID
		F$PRIVILEGE,-		;TRUE IF PRIVS SET/CLEAR
		F$PROCESS,-		;PROCESS NAME
		F$SEARCH,-		;SEARCH FOR NEXT WILDCARD FILESPEC
		F$SETPRV,-		;SETPRV SYSTEM SERVICE
		F$STRING,-		;CONVERT TO ASCII STRING
		F$TIME,-		;CURRENT TIME AND DATE
		F$USER,-		;USER IDENTIFICATION
		F$VERIFY,-		;VERIFY MODE
		>			;
	CLRL	R1			;RETURN NULL STRING
	RSB				;

	.SBTTL	CONVERT TO INTEGER
;+
; F$INTEGER - CONVERT TO INTEGER
;
; THIS FUNCTION CONVERTS ANY VALUE TO AN INTEGER
;
;	F$INTEGER(EXPRESSION)
;
; INPUTS:
;
;	P1(AP) = EXPRESSION RESULT
;
; OUTPUTS:
;
;	R1 = INTEGER
;	R2 = 0 (TO INDICATE RESULT IS BINARY RATHER THAN ASCII)
;-

F$INTEGER:
	MOVQ	P1(AP),R1		;GET EXPRESSION VALUE
	BSBW	DCL$CVT_BINARY		;CONVERT STRING TO BINARY
	BLBC	R0,90$			;BRANCH IF ERROR
	RSB
90$:	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	CONVERT SIGNED AND UNSIGNED INTEGER FIELD
;+
; F$CVSINTEGER - CONVERT SIGNED INTEGER
; F$CVUINTEGER - CONVERT UNSIGNED INTEGER
;
; THIS LEXICAL FUNCTION RETURNS THE BINARY DATA EXTRACTED FROM AN ARBITRARY
; FIELD IN A STRING.
;
;	F$CVSINTEGER(POSITION, SIZE, STRING)
;	F$CVUINTEGER(POSITION, SIZE, STRING)
;
; INPUTS:
;
;	P1(AP) = STARTING BIT NUMBER
;	P2(AP) = NUMBER OF BITS
;	P3(AP) = DESCRIPTOR OF TEXT STRING.
;
; OUTPUTS:
;
;	R1 = CONVERTED BINARY LONGWORD
;	R2 = 0 TO INDICATE BINARY DATA TYPE
;-
 
	.ENABL	LSB
F$CVSINTEGER:				;CONVERT SIGNED INTEGER
	MOVL	#1,R5			;SET SIGNED CONVERSION INDICATOR
	BRB	10$			;
F$CVUINTEGER:				;CONVERT UNSIGNED INTEGER
	CLRL	R5			;SET UNSIGNED CONVERSION INDICATOR
10$:	CMPL	#32,P2(AP)		;SIZE VALUE GREATER THAN 1 LONGWORD?
	BGEQ	20$			;IF GEQ NO
	MOVL	#32,P2(AP)		;REDUCE TO LONGWORD SIZE
20$:	CLRL	R1			;ASSUME FIELD IS NOT DEFINED
	ADDL3	P2(AP),P1(AP),R3	;CALCULATE ENDING BIT POSITION
	MULL3	#8,P3(AP),R2		;CALCULATE SIZE OF STRING IN BITS
	CMPL	P1(AP),R2		;FIELD POSITION BEYOND END OF STRING?
	BGEQ	60$			;IF GEQ YES
	SUBL	R3,R2			;FIELD POSITION TOTALLY WITHIN STRING?
	BGEQ	30$			;IF GEQ YES
	CLRL	R5			;FORCE UNSIGNED EXTRACT
	ADDL	R2,P1(AP)		;REDUCE SIZE OF FIELD
30$:	BLBS	R5,50$			;IF LBS SIGNED CONVERSION
	EXTZV	P1(AP),P2(AP),@P3+4(AP),R1 ;EXTRACT FIELD
	BRB	60$			;
50$:	EXTV	P1(AP),P2(AP),@P3+4(AP),R1 ;EXTRACT SIGNED FIELD
60$:	CLRL	R2			;MARK RESULT IS BINARY DATA
	RSB				;
	.DSABL	LSB

	.SBTTL	CONVERT TO COMPARABLE DATE/TIME STRING
;+
; F$CVTIME - CONVERT TO COMPARABLE DATE/TIME STRING
;
; THIS FUNCTION CONVERTS A STANDARD VMS DATE/TIME STRING INTO A
; STRING OF THE FORM "YYYY-MM-DD HH:MM:SS.NN", WHICH CAN BE COMPARED
; TO ANOTHER STRING OF THE SAME FORM USING THE STRING COMPARISION
; OPERATORS.
;
;	F$CVTIME(TIME)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF DATE/TIME STRING
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF COMPARABLE DATE/TIME STRING
;-

MONTH_TABLE:
	.ASCII	'JAN-FEB-MAR-APR-MAY-JUN-JUL-AUG-SEP-OCT-NOV-DEC-'
MONTH_NO_TABLE:
	.ASCII	'010203040506070809101112??'

F$CVTIME:
	MOVQ	R2,-(SP)		;BUILD TIME BUFFER DESCRIPTOR
	CMPL	#23+23,(SP)		;TIME BUFFER LARGE ENOUGH?
	BGTRU	80$			;IF GTRU NO
	MOVAQ	-(SP),R2		;SET ADDRESS OF TIME BUFFER DESCRIPTOR
	$BINTIM_S TIMBUF=P1(AP),-	;CONVERT INPUT DATE/TIME TO BINARY
		TIMADR=(R2)
	BLBC	R0,70$			;BRANCH IF ERROR DETECTED
	TSTL	4(R2)			;IS QUADWORD NEGATIVE?
	BLSS	50$			;IF SO, ERROR.  DELTA TIME NOT ALLOWED
	$ASCTIM_S TIMADR=(R2),-		;CONVERT BACK TO STANDARD ASCII TIME
		TIMBUF=8(R2),-
		TIMLEN=8(R2)
	ADDL	#8,SP			;POP QUADWORD BUFFER OFF STACK
	BLBC	R0,70$			;BRANCH IF CONVERSION FAILURE
	MOVQ	(SP)+,R1		;RETRIEVE DESCRIPTOR OF TIME STRING
	MOVAB	MONTH_TABLE,R4		;POINT TO MONTH TABLE
	CLRL	R0			;START WITH MONTH #0
10$:	CMPL	3(R2),(R4)+		;DOES MONTH MATCH?
	BEQL	20$			;BRANCH IF FOUND
	AOBLSS	#12,R0,10$		;LOOP UNTIL END OF TABLE
20$:	MOVAB	23(R2),R3		;POINT TO SECOND DATE/TIME BUFFER
	MOVL	7(R2),(R3)+		;MOVE YEAR NUMBER
	MOVB	#^A'-',(R3)+		;MOVE DASH
	MOVW	MONTH_NO_TABLE[R0],(R3)+;MOVE MONTH NUMBER
	MOVB	#^A'-',(R3)+		;MOVE DASH
	CMPB	#^X20,(R2)		;IS DAY A SINGLE DIGIT?
	BNEQ	30$			;NO, THEN SKIP
	MOVB	#^A'0',(R2)		;YES, THEN INSERT ZERO
30$:	MOVW	(R2),(R3)+		;MOVE DAY NUMBER
	MOVQ	11(R2),(R3)+		;MOVE 12 CHARACTERS OF TIME STRING
	MOVL	19(R2),(R3)+
	MOVAB	23(R2),R2		;RETURN RESULTANT DATE/TIME STRING
	MOVL	#22,R1			;LENGTH IS ALWAYS 22
	RSB

50$:	MOVZWL	#SS$_IVTIME,R0		;DELTA TIMES ARE NOT ALLOWED HERE
70$:	BRW	ERROR			;REPORT SYSTEM SERVICE ERROR
80$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW

	.SBTTL	RETURN DEFAULT DIRECTORY NAME STRING
;+
; F$DIRECTORY - RETURN DEFAULT DIRECTORY NAME STRING
;
; THIS LEXICAL FUNCTION RETURNS THE ADDRESS AND LENGTH OF THE CURRENT DEFAULT
; DIRECTORY STRING.
;
;	F$DIRECTORY()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF DEFAULT DIRECTORY STRING.
;	R2 = ADDRESS OF DEFAULT DIRECTORY STRING.
;-
 
F$DIRECTORY:				;RETURN DEFAULT DIRECTORY STRING
	MOVAB	@#PIO$GT_DDSTRING,R2	;GET ADDRESS OF DEFAULT DIRECTORY STRING
	MOVZBL	(R2)+,R1		;GET LENGTH OF DEFAULT DIRECTORY STRING
	RSB				;

	.SBTTL	EXTRACT SUBSTRING FROM STRING
;+
; F$EXTRACT - EXTRACT SUBSTRING FROM STRING
;
; THIS LEXICAL FUNCTION EXTRACTS A SUBSTRING FROM AN ARGUMENT STRING AND RETURNS
; ITS DESCRIPTOR.
;
;	F$EXTRACT(POSITION, SIZE, STRING)
;
; INPUTS:
;
;	P1(AP) = STARTING CHARACTER NUMBER (BASED AT ZERO)
;	P2(AP) = NUMBER OF CHARACTERS
;	P3(AP) = DESCRIPTOR OF TEXT STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EXTRACTED SUBSTRING.
;	R2 = ADDRESS OF EXTRACTED SUBSTRING.
;-
 
F$EXTRACT:
	CLRL	R1			;ASSUME NULL SUBSTRING
	CMPL	P1(AP),P3(AP)		;STARTING POSITION BEYOND END OF STRING
	BGEQU	10$			;IF GTRU YES
	MOVL	P2(AP),R1		;GET NUMBER OF CHARACTERS TO EXTRACT
	ADDL3	P1(AP),P3+4(AP),R2	;CALCULATE STARTING ADDRESS OF SUBSTRING
	SUBL	P1(AP),P3(AP)		;REDUCE APPARENT STRING LENGTH BY POSITION
	SUBL	R1,P3(AP)		;REDUCE STRING BY LENGTH OF SUBSTRING
	BGEQU	10$			;IF GEQU STRING LENGTH SUFFICIENT
	ADDL	P3(AP),R1		;CALCULATE ACTUAL LENGTH OF SUBSTRING
10$:	RSB

	.SBTTL	FAO SYSTEM SERVICE
;+
; F$FAO - FORMATTED ASCII OUTPUT
;
; THIS LEXICAL FUNCTION INVOKES THE $FAO SYSTEM SERVICE WITH
; EITHER STRINGS OR LONGWORDS AS ARGUMENTS, DEPENDING ON THE
; TYPE OF THE ARGUMENT.
;
; F$FAO(CTRSTR,ARG1,ARG2,...)
;
; INPUTS:
;
;	NPARM(AP) = NUMBER OF ARGUMENTS SPECIFIED
;	P1(AP) = FIRST ARGUMENT
;	P2(AP) = SECOND ARGUMENT
;	ETC.
;
; OUTPUTS:
;
;	R1/R2 = RESULTANT STRING FROM $FAO
;-

F$FAO:
	MOVQ	R2,-(SP)		;ADDRESS OF RESULT BUFFER DESCRIPTOR
	MOVL	SP,R2			;ADDRESS OF BUFFER DESCRIPTOR
	SUBL3	#1,NPARM(AP),R0		;GET NUMBER OF FAO ARGUMENTS
	MOVAQ	P2(AP)[R0],R1		;START AT LAST ARGUMENT + 1
10$:	TSTL	-4(R1)			;BINARY LONGWORD OR STRING DESCRIPTOR?
	BNEQ	15$			;BRANCH IF STRING
	SUBL	#8,R1			;SKIP TO NEXT ARGUMENT
	PUSHL	(R1)			;PUSH LONGWORD BINARY VALUE
	BRB	20$
15$:	PUSHAQ	-(R1)			;PUSH ADDRESS OF DESCRIPTOR
20$:	SOBGTR	R0,10$			;LOOP THRU ALL FAO ARGUMENTS
	PUSHL	SP			;ADDRESS OF PARAMETER LIST
	PUSHL	R2			;ADDRESS OF BUFFER DESCRIPTOR
	PUSHL	R2			;ADDRESS OF WORD TO RECEIVE LENGTH
	PUSHAQ	P1(AP)			;ADDRESS OF STRING DESCRIPTOR
	CALLS	#4,G^SYS$FAOL		;INVOKE FAO SERVICE
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVL	R2,SP			;POP FAO ARGUMENTS OFF STACK
	POPR	#^M<R1,R2>		;RETRIEVE DESCRIPTOR OF RESULT STRING
30$:	RSB

90$:	ADDL3	#8,R2,SP		;CLEAN STACK
	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	GET FILE ATTRIBUTES
;+
; F$FILE_ATTRIBUTES - GET FILE INFORMATION
;
; THIS LEXICAL FUNCTION RETURNS A SPECIFIED ATTRIBUTE FOR A FILE
; BY USING THE RMS OPEN SYSTEM SERVICE TO OBTAIN THE INFORMATION.
;
;	F$FILE_ATTRIBUTES(FILESPEC,ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF FILE SPECIFICATION
;	P2(AP) = DESCRIPTOR OF RMS ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$FILE:
	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF SCRATCH SPACE
	MOVL	SP,R9			;SAVE ADDRESS OF DESCRIPTOR
	MOVAB	FILE_TABLE,R7		;GET ADDRESS OF TABLE
10$:	MOVZBL	5(R7),R8		;GET LENGTH OF ITEM NAME
	BEQL	15$			;BRANCH IF END OF TABLE
	CMPC5	P2(AP),@P2+4(AP),#0,R8,6(R7) ;DOES ITEM NAME MATCH?
	BEQL	20$			;BRANCH IF ITEM FOUND
	MOVAB	6(R7)[R8],R7		;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$			;LOOP UNTIL FOUND
15$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	BRW	P2_ERROR
20$:	MOVAB	-FAB$C_BLN(SP),SP	;ALLOCATE FAB ON STACK
	MOVL	SP,R6			;GET ADDRESS OF FAB
	MOVC5	#0,(SP),#0,#FAB$C_BLN,(R6) ;ZERO STORAGE
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R6) ;INITIALIZE FAB
	MOVZBL	(R7),R0			;GET BLOCK INDEX
	CMPL	R0,#1			;FAB OR NAM BLOCK?
	BLSSU	50$			;BRANCH IF FAB ONLY IS NEEDED
	BEQL	40$			;BRANCH IF NAM BLOCK IS ALSO NEEDED
	MOVZWL	XAB_INFO-4[R0],R2	;GET XAB BLOCK ID & LENGTH
	ASHL	#-8,R2,R1		;ISOLATE BLOCK LENGTH
	SUBL	R1,SP			;ALLOCATE SPACE FOR XAB ON STACK
	ASSUME	XAB$B_BLN EQ XAB$B_COD+1
	MOVW	R2,XAB$B_COD(SP)	;STORE XAB BLOCK ID/LENGTH
	CLRL	XAB$L_NXT(SP)		;INDICATE ONLY XAB IN CHAIN
	MOVL	SP,FAB$L_XAB(R6)	;POINT TO XAB BLOCK
	BRB	50$
40$:	MOVAB	-NAM$C_BLN(SP),SP	;ALLOCATE SPACE FOR NAM BLOCK
	MOVC5	#0,(SP),#0,#NAM$C_BLN,(SP) ;ZERO STORAGE
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(SP) ;INITIALIZE NAM
	MOVL	SP,FAB$L_NAM(R6)	;POINT TO NAM BLOCK
50$:	MOVB	P1(AP),FAB$B_FNS(R6)	;SET PRIMARY FILESPEC
	MOVL	P1+4(AP),FAB$L_FNA(R6)
	MOVB	#FAB$M_GET,FAB$B_FAC(R6);READ-ONLY ACCESS
	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_UPI,FAB$B_SHR(R6) ;ALLOW OTHERS
	SETBIT	FAB$V_PPF,FAB$L_FOP(R6)	;USE PROCESS I/O SEGMENT (SINCE THERE
					;   MAY NOT BE ANY IMAGE I/O SEGMENT)
	$OPEN	FAB=(R6)		;OPEN THE FILE TO GET REQUESTED INFO
	BLBC	R0,85$			;IF ERROR, RETURN NULL STRING
	$CLOSE	FAB=(R6)		;CLOSE THE FILE AGAIN
	MOVZBL	1(R7),R5		;GET OFFSET TO FIELD
	BEQL	60$			;BRANCH IF NONE
	ADDL	SP,R5			;POINT TO FIELD
	MOVZBL	2(R7),R4		;GET LENGTH OF FIELD
	BEQL	60$			;BRANCH IF NONE
	MOVZBL	3(R7),R0		;GET STARTING BIT NUMBER
	EXTZV	R0,R4,(R5),R1		;FETCH CONTENTS OF FIELD
60$:	PUSHAB	B^90$			;RETURN AFTER CASE
	BRB	GET_FILE_ITEM		;GET DATA ITEM

85$:	MOVL	FAB$L_STV(R6),R1	;GET SECONDARY STATUS FROM $OPEN
	BEQL	88$			;BRANCH IF NONE
	MOVL	R1,R0			;REPORT SECONDARY ACP STATUS, NOT RMS
88$:	MOVAB	8(R9),SP		;CLEANUP STACK
	BRW	P1_ERROR		;REPORT ERROR

90$:	MOVAB	8(R9),SP		;DEALLOCATE STORAGE ON STACK
	RSB

GET_FILE_ITEM:
	CASE	4(R7),TYPE=B,<-		;CASE ON TYPE OF FIELD
		100$,-			;BINARY
		200$,-			;DATE/TIME
		300$,-			;ASCIC STRING
		400$,-			;FILE ID STRING
		500$,-			;FILE ORGANIZATION
		600$,-			;RECORD ATTRIBUTES
		700$,-			;RECORD FORMAT
		800$,-			;OWNER UIC
		900$,-			;PROTECTION
		1000$,-			;EOF - # BLOCKS IN USE
		1100$>			;BOOLEAN

;
; RETURN BINARY NUMBER
;
100$:	CLRL	R2			;INDICATE BINARY RESULT
	RSB
;
; RETURN DATE/TIME STRING
;
200$:	$ASCTIM_S (R9),(R9),(R5)	;CONVERT TO ASCII DATE/TIME STRING
	MOVQ	(R9),R1			;GET DESCRIPTOR OF STRING
	RSB
;
; RETURN ASCIC STRING
;
300$:	MOVZBL	(R5)+,R1		;GET LENGTH OF STRING
	CMPL	R1,(R9)			;ENOUGH ROOM FOR STRING?
	BGTRU	310$			;BRANCH IF NOT
	PUSHL	R1			;SAVE LENGTH OF STRING
	MOVC	R1,(R5),@4(R9)		;STORE INTO SCRATCH BUFFER
	POPL	R1			;RESTORE LENGTH OF STRING
	MOVL	4(R9),R2		;GET ADDRESS OF STRING
	RSB
310$:	STATUS	BUFOVF			;SIGNAL BUFFER OVERFLOW
	BRW	P2_ERROR
;
; RETURN FILE ID NUMBER
;
400$:	MOVL	R5,R4			;PASS ADDRESS OF FILE ID
	BRW	FORMAT_FILEID		;FORMAT INTO ASCII STRING
;
; RETURN FILE ORGANIZATION
;
	ASSUME	FAB$C_SEQ EQ 0		; ^X00
	ASSUME	FAB$C_REL EQ 16		; ^X10
	ASSUME	FAB$C_IDX EQ 32		; ^X20
505$:	.ASCII	'SEQ REL IDX'

500$:	ASHL	#-4,R1,R1		;GET UPPER NIBBLE AS INDEX
	MOVAL	505$[R1],R2		;SET ADDRESS OF STRING
	MOVL	#3,R1			;SET LENGTH OF STRING
	RSB
;
; RETURN RECORD ATTRIBUTES (RAT)
;
	ASSUME	FAB$M_FTN EQ 1
	ASSUME	FAB$M_CR EQ 2
	ASSUME	FAB$M_PRN EQ 4
605$:	.ASCIC	'FTN'
	.ASCIC	'CR'
	.BLKB	1			;PAD TO LONGWORD BOUNDARY
	.ASCIC  'PRN'
	.ASCIC	''			;USE NULL IF FFS FAILS

600$:	FFS	#0,#3,(R5),R1		;FIND FIRST BIT SET
	MOVAL	605$[R1],R2		;SET ADDRESS OF STRING
	MOVZBL	(R2)+,R1		;SET LENGTH OF STRING
	RSB
;
; RETURN RECORD FORMAT (RFM)
;
	ASSUME	FAB$C_UDF EQ 0
	ASSUME	FAB$C_FIX EQ 1
	ASSUME	FAB$C_VAR EQ 2
	ASSUME	FAB$C_VFC EQ 3
	ASSUME	FAB$C_STM EQ 4
	ASSUME	FAB$C_STMLF EQ 5
	ASSUME	FAB$C_STMCR EQ 6
705$:	.ASCII	'UDF FIX VAR VFC STM STMLF   STMCR   '
707$:	.BYTE	3,3,3,3,3,5,0,5
700$:	CMPL	#6,R1			;IS RFM ON 4 BYTE OFFSET?
	BNEQ	710$			;YES, SKIP
	MOVL	#7,R1			;NO, SET OFFSET
710$:	MOVAL	705$[R1],R2		;SET ADDRESS OF STRING
	MOVZBL	707$[R1],R1		;SET LENGTH OF STRING
	RSB
;
; RETURN OWNER UIC
;
800$:	MOVL	R1,R4			;PASS UIC LONGWORD
	BRW	FORMAT_UIC		;CONVERT INTO ASCII FORM

;
; RETURN FILE PROTECTION
;
900$:	MOVL	R1,R4			;PASS PROTECTION WORD
	BRW	FORMAT_PROT		;CONVERT INTO ASCII FORM

;
; RETURN # BLOCKS IN USE
;
1000$:	TSTW	XAB$W_FFB-XAB$L_EBK(R5)	;FIRST FREE BYTE = 0?
	BNEQ	1010$			;IF NOT, EBK = BLOCKS IN USE
	DECL	R1			;ELSE DON'T COUNT LAST BLOCK
1010$:	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB
;
; RETURN BOOLEAN TRUE/FALSE
;
1100$:	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

	.SBTTL	GETDVI SYSTEM SERVICE
;+
; F$GETDVI - GET DEVICE/VOLUME INFORMATION
;
; THIS LEXICAL FUNCTION INVOKES THE $GETDVI SYSTEM SERVICE TO
; OBTAIN ANY PIECE OF INFORMATION FROM A GIVEN DEVICE.
;
;	F$GETDVI(DEVNAM,ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF DEVICE NAME
;		
;	P2(AP) = DESCRIPTOR OF $DVI ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$GETDVI:
	MOVL	R2,-(SP)		;SAVE LENGTH OF SCRATCH BUFFER
	CLRL	-(SP)			;ALLOCATE A LONGWORD FOR DEVCHAR
	MOVL	SP,R5			;MAKE R5 POINT TO IT
	CLRL	-(SP)			;INDICATE BOTTOM OF ITEM LIST	
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE DEVCHAR LENGTH
	PUSHL	R5			;ADDRESS OF BUFFER TO RECEIVE DEVCHAR
	PUSHL	#4			;SIZE OF DEVCHAR BUFFER
	MOVW	#DVI$_DEVCHAR+1,2(SP)	;SECONDARY DEVICE DEVCHAR ITEM CODE
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE ITEM LENGTH
	MOVQ	R2,-(SP)		;SAVE DESCRIPTOR OF SCRATCH ITEM BUFFER
	MOVAB	GETDVI_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVL	R6,R7			;GET ADDRESS OF ENTRY
	ADDL	#4,R6			;GET ADDRESS OF ASCIC ITEM NAME
	MOVZBL	(R6),R8			;GET LENGTH OF ITEM NAME
	BEQL	80$			;BRANCH IF END OF TABLE
	CMPC5	P2(AP),@P2+4(AP),#0,R8,1(R6) ;DOES ITEM NAME MATCH?
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R8,R6			;SKIP TO NEXT ENTRY IN TABLE
	ADDL	#1,R6			;BE SURE TO COUNT THE COUNT
	BRB	10$			;LOOP UNTIL FOUND
20$:	MOVW	(R7),2(SP)		;SET ITEM CODE INTO LIST
30$:	MOVL	SP,R0			;GET ADDRESS OF ITEM LIST
	$GETDVI_S DEVNAM=P1(AP),-	;GET INFORMATION ON SPECIFIED DEVICE
		ITMLST=(R0),-
		EFN=#0
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	MOVL	R0,R4			;SAVE STATUS
	$WAITFR_S EFN=#0		;WAIT FOR COMPLETION OF GETDVI
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	BBC	#DEV$V_SPL,(R5),50$	;SPOOLED DEVICE?
	CLRL	R6			;SET SPOOLED FLAG
	MOVW	#DVI$_DEVCHAR,14(SP)	;GET DEVCHAR OF PRIMARY DEVICE
	CMPW	#DVI$_DEVNAM,2(SP)	;ARE WE GETTING DEVICE NAME?
	BNEQ	40$			;NO, THEN NO SPECIAL PROCESSING
	CMPB	#9,4(R7)		;ARE WE GETTING SPOOLED DEVICE NAME?
	BNEQ	40$			;NO, THEN NO SPECIAL PROCESSING
	BRB	30$			;YES, THEN DON'T INCR ITEM CODE
40$:	MOVW	4(R5),(SP)		;RESET RESULT LENGTH
	INCW	2(SP)			;GET SECONDARY DEVICE DATA
	BRB	30$			;RETRY
50$:	CLRW	2(SP)			;CLEAR ITEM CODE, LEAVING RETLEN
	MOVQ	(SP)+,R1		;GET DESCRIPTOR OF STRING/LONGWORD
	ADDL3	#8,R5,SP		;RESTORE STACK
	BRB	GETDVI_VALUE		;GET VALUE
;
; NO SUCH ITEM NAME
;
80$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	ADDL3	#8,R5,SP		;CLEAN STACK
	BRW	P2_ERROR		;REPORT THE ERROR
;
; ERROR DETECTED BY GETDVI
;
90$:	ADDL3	#8,R5,SP		;CLEAN STACK
	CMPL	#SS$_IVDEVNAM,R0	;YES, IS NAME INVALID?
	BEQL	93$			;YES, THEN CHECK EXISTS BIT
	CMPL	#SS$_NOSUCHDEV,R0	;NO, THEN DOES DEVICE EXIST?
	BNEQ	95$			;NO, THEN DON'T CHECK BIT
93$:	CMPB	#DEV$V_EXISTS,3(R7)	;DO WE CARE IF IT EXISTS
	BNEQ	95$			;NO, THEN REPORT ERROR
	CLRL	R1			;YES, THEN RETURN FALSE
	BRW	FORMAT_BOOLEAN		;RETURN THE VALUE
95$:	BRW	P1_ERROR		;REPORT THE ERROR
;
; NORMAL PROCESSING FOR LONGWORDS, STRINGS AND HEX VALUES
;
GETDVI_VALUE:
	CASE	2(R7),TYPE=B,<-		;CASE ON TYPE OF FIELD
		100$,-			;BINARY
		200$,-			;ASCIC STRING
		300$,-			;OWNER UIC
		400$,-			;BOOLEAN
		500$,-			;HEX STRING
		600$,-			;PROTECTION MASK
		700$>			;ACP TYPE

;
; RETURN BINARY VALUE
;
100$:	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB

;
; RETURN ASCII STRING
;
200$:	CMPW	#DVI$_DEVNAM,2(R7)	;ARE WE GETTING DEVICE NAME?
	BNEQ	210$			;NO, THEN NO SPECIAL PROCESSING
	CMPB	#9,4(R7)		;ARE WE GETTING SPOOLED DEVICE NAME?
	BNEQ	210$			;NO, THEN NO SPECIAL PROCESSING
	TSTL	R6			;IS DEVICE SPOOLED?
	BEQL	210$			;YES, THEN USE FETCHED NAME
	CLRL	R1			;NO, THEN RETURN NULL STRING
210$:	RSB

;
; RETURN OWNER UIC
;
300$:	MOVL	(R2),R4			;PASS UIC LONGWORD
	BRW	FORMAT_UIC		;CONVERT INTO ASCII FORM

;
; RETURN BOOLEAN TRUE/FALSE
;
400$:	CLRL	R1			;ASSUME FALSE
	TSTB	3(R7)			;ARE WE CHECKING FOR CONCEALED OR EXISTS
	BGEQ	410$			;NO, GET FIELD OF DEVCHAR
	CMPB	#DEV$V_CONCEALED,3(R7)	;ARE WE CHECKING FOR CONCEALED
	BNEQ	420$			;NO, THEN MUST BE EXISTS AND MUST BE TRUE
	CMPL	#SS$_CONCEALED,R4	;YES, IS DEVICE CONCEALED?
	BNEQ	430$			;NO, RETURN FALSE
	BRB	420$			;YES, RETURN TRUE
410$:	MOVZBL	3(R7),R7		;GET MASK
	BBC	R7,(R2),430$		;TEST BIT, BRANCH IF FALSE
420$:	INCL	R1			;SET TRUE
430$:	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

;
; RETURN HEX STRING
;
500$:	MOVL	(R2),R0			;PASS HEX LONGWORD AS ARGUMENT
	BEQL	210$			;IF ZERO, RETURN NULL STRING
	BRW	DCL$CBTA_HEX		;CONVERT HEX TO STRING AND EXIT

;
; RETURN PROTECTION STRING
;
600$:	MOVL	(R2),R4			;PASS PROTECTION MASK 
	BRW	FORMAT_PROT		;CONVERT INTO ASCII FORM

;
; RETURN ACP TYPE
;
700$:	MOVL	(R2),R0			;GET ACP TYPE NUMBER
	MOVAQ	ACP_TABLE[R0],R2	;GET ADDRESS OF ASCIC ACP TYPE
	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF ACP TYPE
	RSB

	.SBTTL	GETJPI SYSTEM SERVICE
;+
; F$GETJPI - GET JOB/PROCESS INFORMATION
;
; THIS LEXICAL FUNCTION INVOKES THE $GETJPI SYSTEM SERVICE TO
; OBTAIN ANY PIECE OF INFORMATION FROM A GIVEN PROCESS.
;
;	F$GETJPI(PID,ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF PID STRING OF DESIRED PROCESS,
;			NULL OR 0 FOR CURRENT PROCESS
;	P2(AP) = DESCRIPTOR OF $JPI ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$GETJPI:
	BSBW	DCL$MARK		;MARK POSITION IN EXPANSION BUFFER
	CLRQ	-(SP)			;CLEAR LENGTH AND ITEM ID OF LAST ITEM
					;AND ALLOCATE SPACE FOR PID LONGWORD
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE LENGTH
	MOVQ	R2,-(SP)		;SAVE DESCRIPTOR OF SCRATCH BUFFER
	MOVAB	GETJPI_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVL	(R6)+,R7		;GET JPI CODE(0:15),FLAGS(16:23),
					;   ITEM STRING LENGTH(24:31)
	BNEQ	15$			;SKIP IF NOT AT END OF TABLE
	BRW	80$			;ERROR IF END OF TABLE
15$:	MOVZBL	-1(R6),R8		;GET LENGTH OF ITEM NAME
	CMPC5	P2(AP),@P2+4(AP),#0,R8,(R6) ;DOES ITEM NAME MATCH?
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R8,R6			;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$			;LOOP UNTIL FOUND
20$:	MOVW	R7,2(SP)		;SET ITEM CODE INTO LIST
	MOVQ	P1(AP),R2		;GET DESCRIPTOR OF PID STRING
	MOVZBL	#PRC_K_HEX,R1		;SET RADIX FOR CONVERSION
	BSBW	DCL$CNVASCBIN		;CONVERT HEX STRING TO BINARY IN R1
	BNEQ	70$			;BRANCH IF CONVERSION ERROR
	MOVL	R1,16(SP)		;STORE PID LONGWORD
	MOVL	SP,R0			;GET ADDRESS OF ITEM LIST
	$GETJPI_S PIDADR=16(R0),-	;GET INFORMATION ON SPECIFIED PROCESS
		ITMLST=(R0),-
		EFN=#0
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	$WAITFR_S EFN=#0		;WAIT FOR COMPLETION OF GETJPI
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	CLRW	2(SP)			;CLEAR ITEM CODE, LEAVING RETLEN
	POPR	#^M<R1,R2,R3,R4,R5>	;GET DESCRIPTOR OF STRING/LONGWORD
					;AND CLEAN STACK
	CMPW	R7,#JPI$_STS		;ASKING FOR STS?
	BNEQ	30$			;IF NOT, THEN SKIP
	BRW	STS_MODE		;IF SO, CHECK IF USER WANTED "MODE"
30$:	CMPW	R7,#JPI$_LOGINTIM	;ASKING FOR LOGIN TIME?
	BNEQ	40$			;IF NOT, THEN SKIP
	BRW	GETJPI_LOGINTIM		;IF SO, FORMAT AS DATE/TIME
40$:	CMPW	R7,#JPI$_STATE		;ASKING FOR STATE?
	BNEQ	50$			;IF NOT, THEN SKIP
	BRW	GETJPI_STATE		;IF SO, RETURN STATE KEYWORD
50$:	CMPW	R7,#JPI$_UIC		;ASKING FOR UIC?
	BNEQ	60$			;IF NOT, THEN SKIP
	BRW	GETJPI_UIC		;IF SO, FORMAT UIC SPECIALLY
60$:	EXTZV	#16,#8,R7,R7		;EXTRACT ITEM TYPE FIELD
	BRW	GETJPI_VALUE		;GET VALUE
;
; ERROR CONVERTING PID STRING TO A BINARY LONGWORD
;
70$:	STATUS	EXPSYN			;EXPRESSION SYNTAX ERROR
	BRB	90$
;
; NO SUCH ITEM NAME
;
80$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
;
; ERROR DETECTED BY GETJPI
;
90$:	ADDL	#5*4,SP			;CLEAN STACK
	CMPW	R0,#SS$_SUSPENDED	;SUSPENDED ERROR?
	BEQL	95$			;RETURN NULL/ZERO IF SUSPENDED
	BRW	P2_ERROR		;REPORT ERROR
95$:	CLRL	R1			;RETURN NULL STRING
	RSB
;
; NORMAL PROCESSING FOR LONGWORDS, STRINGS AND HEX VALUES
;
GETJPI_VALUE:
	CASE	R7,TYPE=B,<-		;CASE ON ITEM TYPE
		10$,-			;BINARY
		20$,-			;STRING
		30$,-			;HEX STRING
		40$>			;PRIVILEGE LIST
;
; RETURN BINARY VALUE
;
10$:	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
20$:	RSB
;
; RETURN HEX STRING
;
30$:	CLRL	R1			;ASSUME RETURNING NULL STRING
	MOVL	(R2),R0			;PASS LONGWORD PID AS ARGUMENT
	BEQL	20$			;IF ZERO, RETURN NULL STRING
	BRW	DCL$CBTA_HEX		;CONVERT PID TO STRING AND EXIT
;
; RETURN PRIVILEGE LIST
;
40$:	MOVQ	(R2),-(SP)		;PUSH PRIVILEGE MASK ON STACK
	MOVL	SP,R6			;GET ADDRESS OF MASK
	CLRL	R1			;START WITH PRIV #0
45$:	BBC	R1,(R6),50$		;SKIP IF PRIV IS NOT PRESENT
	BSBW	ADD_PRIV_STATE		;APPEND EACH KEYWORD TO STRING
50$:	AOBLSS	#64,R1,45$		;LOOP FOR EACH PRIV IN MASK
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF STRING
	MOVL	WRK_L_MARKPTR(R10),-	;RESTORE POSITION IN EXPANSION BUFFER
		WRK_L_EXPANDPTR(R10)
	TSTL	R1			;WERE NO PRIVS FOUND?
	BEQL	55$			;YES, THEN NO TRAILING COMMA
	DECL	R1			;REMOVE TRAILING COMMA
55$:	ADDL	#8,SP			;RESTORE STACK
	RSB
;
; SPECIAL PROCESSING FOR "LOGINTIM"
;
GETJPI_LOGINTIM:
	PUSHL	R2			;ADDRESS OF RESULT BUFFER
	PUSHL	#23			;RESULT BUFFER LENGTH
	MOVL	SP,R0
	$ASCTIM_S TIMBUF=(R0),-		;CONVERT QUADWORD TIME TO ASCII
		TIMADR=(R2)
	MOVQ	(SP)+,R1		;PICK UP RESULTANT STRING DESCRIPTOR
	RSB
;
; SPECIAL PROCESSING FOR "STATE"
;
GETJPI_STATE:
	MOVL	(R2),R0			;GET STATE NUMBER
	MOVAQ	STATE_TABLE[R0],R2	;GET ADDRESS OF ASCIC STATE NAME
	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF STATE NAME
	RSB
;
; SPECIAL PROCESSING FOR "UIC"
;
GETJPI_UIC:
	MOVL	(R2),R4			;GET UIC LONGWORD
	BSBW	FORMAT_UIC		;FORMAT UIC INTO ASCII STRING
	RSB
;
; WE JUST GOT JPI$_STS - CHECK IF USER WANTS "MODE"
;
STS_MODE:
	BBC	#16,R7,90$		;BRANCH IF WANTED BINARY FORM (STS)
					;ELSE, RETURN STRING FORM (MODE)
	MOVL	(R2),R1			;GET STS LONGWORD
	MOVAB	NETWORK,R2		;ASSUME NETWORK
	BBS	#PCB$V_NETWRK,R1,10$	;BRANCH IF NETWORK JOB
	MOVAB	BATCH,R2		;ASSUME BATCH
	BBS	#PCB$V_BATCH,R1,10$	;BRANCH IF BATCH JOB
	MOVAB	INTERACTIVE,R2		;IF NONE OF THE ABOVE, THEN INTERACTIVE
10$:	MOVZBL	(R2)+,R1		;GET LENGTH OF STRING
	RSB
90$:	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB

	.SBTTL	GETSYI SYSTEM SERVICE
;+
; F$GETSYI - GET SYSTEM INFORMATION
;
; THIS LEXICAL FUNCTION INVOKES THE $GETSYI SYSTEM SERVICE TO
; OBTAIN ANY PIECE OF INFORMATION FOR THE CURRENT SYSTEM.
;
;	F$GETSYI(ITEM)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF $SYI ITEM NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT DATA
;-

F$GETSYI:
	CLRL	-(SP)			;CLEAR LENGTH AND ITEM ID OF LAST ITEM
	PUSHAB	-12(SP)			;ADDRESS OF WORD TO RECEIVE LENGTH
	MOVQ	R2,-(SP)		;SAVE DESCRIPTOR OF SCRATCH BUFFER
	MOVAB	GETSYI_TABLE,R6		;GET ADDRESS OF TABLE
10$:	MOVL	(R6)+,R7		;GET SYI CODE(0:15),FLAGS(16:23),
					;   ITEM STRING LENGTH(24:31)
	BEQL	80$			;BRANCH IF END OF TABLE
	MOVZBL	-1(R6),R8		;GET LENGTH OF ITEM NAME
	CMPC5	P1(AP),@P1+4(AP),#0,R8,(R6) ;DOES ITEM NAME MATCH?
	BEQL	20$			;BRANCH IF ITEM FOUND
	ADDL	R8,R6			;SKIP TO NEXT ENTRY IN TABLE
	BRB	10$			;LOOP UNTIL FOUND
20$:	MOVW	R7,2(SP)		;SET ITEM CODE INTO LIST
	MOVL	SP,R0			;GET ADDRESS OF ITEM LIST
	$GETSYI_S ITMLST=(R0),-		;GET INFORMATION
		EFN=#0
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	$WAITFR_S EFN=#0		;WAIT FOR COMPLETION OF GETSYI
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	CLRW	2(SP)			;CLEAR ITEM CODE, LEAVING RETLEN
	POPR	#^M<R1,R2,R3,R4>	;GET DESCRIPTOR OF STRING/LONGWORD
					;AND CLEAN STACK
	BBS	#16,R7,30$		;BRANCH IF ITEM IS A STRING
	MOVL	(R2),R1			;GET LONGWORD VALUE
	CLRL	R2			;INDICATE RESULT IS BINARY
30$:	RSB
;
; NO SUCH ITEM NAME
;
80$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
;
; ERROR DETECTED BY GETSYI
;
90$:	ADDL	#4*4,SP			;CLEAN STACK
	BRW	P1_ERROR		;REPORT ERROR

	.SBTTL	RETURN LENGTH OF STRING
;+
; F$LENGTH - RETURN LENGTH OF STRING
;
; THIS LEXICAL FUNCTION RETURNS THE LENGTH OF ITS ARGUMENT AS A DECIMAL STRING.
;
;	F$LENGTH(STRING)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF STRING.
;
; OUTPUTS:
;
;	R1 = STRING LENGTH
;	R2 = 0 TO INDICATE RESULT IS BINARY
;-
 
F$LENGTH:				;RETURN LENGTH OF STRING
	MOVL	P1(AP),R1		;GET VALUE TO BE CONVERTED
	CLRL	R2			;INDICATE BINARY RESULT
	RSB

	.SBTTL	LOCATE SUBSTRING IN STRING
;+
; F$LOCATE - LOCATE SUBSTRING IN STRING
;
; THIS LEXICAL FUNCTION RETURNS THE STARTING POSITION OF A SUBSTRING IN ANOTHER
; STRING. IF THE SUBSTRING IS NOT CONTAINED IN THE SPECIFIED STRING, THEN THE
; LENGTH OF THE SPECIFIED STRING IS RETURNED.
;
;	F$LOCATE(SUBSTRING, STRING)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF SUBSTRING.
;	P2(AP) = DESCRIPTOR OF STRING TO BE SEARCHED.
;
; OUTPUTS:
;
;	R1 = NUMBER INDICATING POSITION WITHIN STRING
;	R2 = 0 TO INDICATE RESULT IS BINARY
;-
 
F$LOCATE:				;LOCATE SUBSTRING IN STRING
	MATCHC	P1(AP),@P1+4(AP),P2(AP),@P2+4(AP) ;SEARCH FOR SUBSTRING MATCH
	BNEQ	10$			;IF NEQ NO MATCH FOUND
	SUBL	P1(AP),R3		;CALCULATE STARTING ADDRESS OF SUBSTRING
10$:	SUBL3	P2+4(AP),R3,R1		;CALCULATE STARTING POSITION OF SUBSTRING
	CLRL	R2			;MARK RESULT IS BINARY
	RSB

	.SBTTL	LOGICAL NAME TRANSLATION
;+
; F$LOGICAL - LOGICAL NAME TRANSLATION
;
; THIS LEXICAL FUNCTION OBTAINS THE TRANSLATION FOR A SPECIFED LOGICAL NAME AND
; RETURN THE EQUIVALENCE NAME.
;
;	F$LOGICAL(LOGICAL_NAME)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF LOGICAL NAME STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EQUIVALENCE STRING.
;	R2 = ADDRESS OF EQUIVALENCE STRING.
;-
 
F$LOGICAL:				;LOGICAL NAME TRANSLATION
	MOVAB	P1(AP),R0		;GET ADDRESS OF LOGICAL NAME DESCRIPTOR
	MOVQ	R2,-(SP)		;SAVE EQUIVALENCE NAME DESCRIPTOR
	MOVQ	R2,-(SP)		;SET EQUIVALENCE NAME DESCRIPTOR
	MOVL	SP,R1			;SET ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S (R0),(R1),(R1)	;TRANSLATE LOGICAL NAME
	MOVQ	(SP)+,R1		;RETRIEVE EQUIVALENCE NAME PARAMETERS
	BLBC	R0,90$			;IF LBC TRANSLATION FAILURE
	CMPW	#SS$_NOTRAN,R0		;DID TRANSLATION ACTUALLY OCCUR?
	BEQL	10$			;IF EQL, THEN NO
	ADDL	#8,SP			;RESTORE STACK
	BRB	20$			;EXAMINE RESULT
;
; TRY AGAIN WITH UPCASED LOGICAL NAME STRING.
;
10$:	MOVQ	P1(AP),R1		;CREATE LOGICAL NAME DESCRIPTOR
	BSBW	DCL$REMBLANKS		;UPCASE THE LOGICAL NAME STRING
	MOVQ	R1,-(SP)		;PUT THE LOGICAL NAME DESC ON THE STACK
	MOVL	SP,R0			;SET ADDRESS OFF LOGICAL NAME DESCRIPTOR
	MOVAB	8(SP),R1		;SET ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S (R0),(R1),(R1)	;TRANSLATE LOGICAL NAME
	ADDL	#8,SP			;REMOVE THE LOGICAL NAME DESCRIPTOR
	MOVQ	(SP)+,R1		;RETRIEVE EQUIVALENCE NAME PARAMETERS
	BLBC	R0,90$			;IF LBC TRANSLATION FAILURE
	CMPW	#SS$_NOTRAN,R0		;DID TRANSLATION ACTUALLY OCCUR?
	BEQL	30$			;IF EQL, THEN NO
;
; STRIP ESCAPE SEQUENCE OFF EQUIVALENCE NAME STRING.
;
20$:	TSTL	R1			;ZERO LENGTH VALUE?
	BEQL	40$			;IF EQL YES
	CMPB	#27,(R2)		;FIRST CHARACTER ESCAPE?
	BNEQ	40$			;IF NEQ NO
	ADDL	#4,R2			;POINT PAST ESCAPE SEQUENCE
	SUBL	#4,R1			;REDUCE LENGTH OF EQUIVALENCE STRING
	BGEQ	40$			;IF GEQ OKAY
30$:	CLRL	R1			;SET TO RETURN NULL STRING
40$:	RSB				;
 
;
; LOGICAL NAME TRANSLATION FAILURE
;
 
90$:	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	GET MESSAGE TEXT
;+
; F$MESSAGE - GET MESSAGE TEXT
;
; THIS LEXICAL FUNCTION OBTAINS THE MESSAGE TEXT ASSOCIATED WITH A MESSAGE CODE.
;
;	F$MESSAGE(CODE)
;
; INPUTS:
;
;	P1(AP) = MESSAGE CODE
;
; OUTPUTS:
;
;	R1 = LENGTH OF MESSAGE TEXT STRING.
;	R2 = ADDRESS OF MESSAGE TEXT STRING.
;-
 
F$MESSAGE:				;GET MESSAGE TEXT
	MOVQ	R2,-(SP)		;SET MESSAGE BUFFER DESCRIPTOR
	MOVL	SP,R0			;SET ADDRESS OF MESSAGE BUFFER DESCRIPTOR
	$GETMSG_S P1(AP),(R0),(R0),#15	;GET MESSAGE TEXT
	MOVQ	(SP)+,R1		;RETRIEVE MESSAGE TEXT PARAMETERS
	RSB

	.SBTTL	RETURN JOB MODE
;+
; F$MODE - RETURN JOB MODE
;
; THIS LEXICAL FUNCTION RETURNS A STRING THAT IS EITHER "INTERACTIVE" OR "BATCH"
; DEPENDENT ON THE JOB MODE.
;
;	F$MODE()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF JOB MODE DESCRIPTION STRING.
;	R2 = ADDRESS OF JOB MODE DESCRIPTION STRING.
;-
 
F$MODE:					;RETURN JOB MODE
	CLRQ	-(SP)			;MARK END OF LIST, NO RETLEN
	PUSHAB	-2*4(SP)		;SET BUFFER ADDRESS
	PUSHL	#JPI$_STS@16+4		;REQUEST STS FLAGS, SET BUFFER LENGTH
	MOVL	SP,R0			;SET ADDRESS OF TIME LIST
	$GETJPI_S ITMLST=(R0)		;GET PCB STATUS BITS
	BLBC	R0,50$			;IF LBC SERVICE FAILURE
	MOVAB	NETWORK,R2		;ASSUME NETWORK
	BBS	#PCB$V_NETWRK,(SP),10$	;BRANCH IF NETWORK JOB
	MOVAB	BATCH,R2		;ASSUME BATCH
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),10$ ;BR IF BATCH, DETACHED (OR NETWORK)
	MOVAB	INTERACTIVE,R2		;IF NONE OF THE ABOVE, THEN INTERACTIVE
10$:	MOVZBL	(R2)+,R1		;GET LENGTH OF STRING
	ADDL	#4*4,SP			;DEALLOCATE GETJPI ITEM LIST
	RSB

50$:	BRW	ERROR			;REPORT ERROR IN FUNCTION

	.SBTTL	PARSE A FILE SPECIFICATION
;+
; F$PARSE - PARSE A FILE SPECIFICATION
;
; THIS FUNCTION PERFORMS A $PARSE SYSTEM SERVICE RETURNING THE
; ENTIRE (OR OPTIONALLY ONLY PARTS OF THE) EXPANDED FILESPEC.
;
; INPUTS:
;
;	P1(AP) = PRIMARY FILESPEC
;	P2(AP) = DEFAULT FILESPEC
;	P3(AP) = RELATED FILESPEC (FOR TEMPORARY STICKYNESS)
;	P4(AP) = NAME OF A FILESPEC FIELD
;		IF NOT SPECIFIED, THE ENTIRE FILESPEC IS RETURNED.
;
;	P2,P3 AND P4 ARE ALL OPTIONAL (INDICATED BY A -1 IN THE FIRST LONGWORD)
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF EXPANDED FILE SPECIFICATION
;-

F$PARSE:
	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF SCRATCH BUFFER
	MOVL	SP,R9			;SAVE ADDRESS OF DESCRIPTOR
	MOVAB	-NAM$C_BLN-FAB$C_BLN-NAM$C_MAXRSS-NAM$C_BLN(SP),SP ;ALLOCATE STORAGE
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN+NAM$C_MAXRSS+NAM$C_BLN,(SP) ;ZERO STORAGE
	MOVL	SP,R7			;GET ADDRESS OF NAM
	MOVAB	NAM$C_BLN(R7),R6	;GET ADDRESS OF FAB
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R6) ;INITIALIZE FAB
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R7) ;INITIALIZE NAM
	MOVL	R7,FAB$L_NAM(R6)	;SET POINTER TO NAM BLOCK
	SETBIT	FAB$V_PPF,FAB$L_FOP(R6)	;USE PROCESS I/O SEGMENT (SINCE THERE
					;   MAY NOT BE ANY IMAGE I/O SEGMENT)
	MOVB	P1(AP),FAB$B_FNS(R6)	;STORE PRIMARY NAME STRING INTO FAB
	MOVL	P1+4(AP),FAB$L_FNA(R6)
	TSTL	P2(AP)			;P2 SPECIFIED?
	BLSS	20$			;BRANCH IF NOT
	MOVB	P2(AP),FAB$B_DNS(R6)	;STORE DEFAULT NAME STRING INTO FAB
	MOVL	P2+4(AP),FAB$L_DNA(R6)
20$:	TSTL	P3(AP)			;P3 SPECIFIED?
	BLSS	25$			;BRANCH IF NOT
	MOVAB	FAB$C_BLN+NAM$C_MAXRSS(R6),R0	;ADDRESS OF RELATED NAM
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R0) ;INITIALIZE RELATED NAM
	MOVB	P3(AP),NAM$B_RSL(R0)	;INITIALIZE RELATED FILESPEC
	MOVL	P3+4(AP),NAM$L_RSA(R0)
	MOVL	R0,NAM$L_RLF(R7)	;POINT TO RELATED NAM BLOCK
25$:	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R7)	;SET SIZE OF EXPANDED BUFFER
	MOVAB	FAB$C_BLN(R6),NAM$L_ESA(R7)	;SET ADDRESS OF RESULT BUFFER
	$PARSE	FAB=(R6)		;SETUP EXPANDED NAME STRING, NAM FIELDS
					;(SUCH AS FID,DID,DVI,ESL)
	BLBS	R0,28$			;BRANCH IF OK
	CLRB	NAM$B_ESL(R7)		;RETURN NULL ON ANY PARSE ERROR
28$:	MOVZBL	#NAM$B_ESL,R1		;ASSUME USING ENTIRE EXPANDED STRING
	MOVZBL	#NAM$L_ESA,R2
	TSTL	P4(AP)			;FIELD SPECIFIED?
	BLSS	40$			;IF NOT, RETURN ENTIRE EXPANDED STRING
	MOVAB	PARSE_FIELDS,R4		;GET ADDRESS OF TABLE
30$:	MOVZBL	(R4),R5			;GET LENGTH OF ITEM NAME
	BEQL	35$			;BRANCH IF END OF TABLE
	CMPC5	P4(AP),@P4+4(AP),#0,R5,1(R4) ;DOES ITEM NAME MATCH?
	BEQL	38$			;BRANCH IF ITEM FOUND
	MOVAB	3(R4)[R5],R4		;SKIP TO NEXT ENTRY IN TABLE
	BRB	30$			;LOOP UNTIL FOUND
35$:	STATUS	IVKEYW			;UNDEFINED ITEM NAME
	BRW	P4_ERROR
38$:	MOVZBL	(R3)+,R1		;GET OFFSET TO FIELD LENGTH
	MOVZBL	(R3)+,R2		;GET OFFSET TO FIELD ADDRESS
40$:	MOVZBL	(R7)[R1],R1		;GET LENGTH OF EXPANDED STRING
	ADDL	R7,R2			;GET ADDRESS OF EXPANDED STRING ADDRESS
	CMPL	R1,(R9)			;ENOUGH ROOM FOR STRING?
	BGTRU	60$			;BRANCH IF NOT
	PUSHL	R1			;SAVE REGISTERS
	MOVC	R1,@(R2),@4(R9)		;COPY INTO SCRATCH BUFFER
	POPL	R3			;SAVE LENGTH OF EXPANDED STRING
	TSTL	NAM$L_WCC(R7)		;DID RMS SAVE ANY INTERNAL CONTEXT?
	BEQL	50$			;BRANCH IF NOT
	ASSUME	FAB$B_DNS EQ FAB$B_FNS+1
	CLRW	FAB$B_FNS(R6)		;SET PRIMARY/DEFAULT FILESPECS TO NULL
	$PARSE	FAB=(R6)		;TERMINATE WILDCARD SEQUENCE TO GET RMS
					;TO DEALLOCATE INTERNAL CONTEXT STORAGE
50$:	MOVL	R3,R1			;GET LENGTH OF RESULTANT STRING
	MOVL	4(R9),R2		;SET ADDRESS OF STRING
	MOVAB	8(R9),SP		;DEALLOCATE STORAGE
	RSB

60$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW

	.SBTTL	GET NEXT PROCESS ID
;+
; F$PID - GET NEXT PROCESS ID
;
; THIS FUNCTION PERFORMS A WILDCARD GETJPI FUNCTION TO RETURN THE
; NEXT PROCESS PID IN SEQUENCE, GIVEN THE WILDCARD CONTEXT.
;
;	F$PID(CONTEXT_SYMBOL)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF SYMBOL NAME
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF PID CONVERTED TO AN ASCII STRING
;-

F$PID:
	CLRQ	-(SP)			;CLEAR LAST ITEM AND RETLEN ADDRESS
	PUSHAB	-8(SP)			;ADDRESS TO RECEIVE PID
	PUSHL	#JPI$_PID@16+4		;SET ITEM CODE AND BUFLEN
	MNEGL	#1,-(SP)		;ASSUME CONTEXT LONGWORD OF -1 (BEGIN)
	MOVQ	P1(AP),R1		;GET DESCRIPTOR OF SYMBOL NAME
	BSBW	DCL$SEARCH		;FIND SYMBOL IN SYMBOL TABLE
	BLBC	R0,10$			;IF NOT FOUND, SEARCH FROM BEGINNING
	TSTL	R2			;STRING VALUE?
	BNEQ	10$			;IF SO, START SEARCH AT BEGINNING
	TSTL	R1			;TOP BIT MUST BE SET FOR VALID PID CTX
	BGEQ	10$			;IF NOT OK, START SEARCH AT BEGINNING
	MOVL	R1,(SP)			;STORE CONTEXT LONGWORD ON STACK
10$:	MOVL	SP,R0			;GET ADDRESS OF CONTEXT/ITEM LIST
	$GETJPI_S PIDADR=(R0),-		;GET NEXT PID IN SEQUENCE
		ITMLST=4(R0)
	BLBS	R0,20$			;BRANCH IF NO ERROR
	CMPW	R0,#SS$_NOPRIV		;NO PRIVILEGE TO GET INFO?
	BEQL	10$			;IF SO, TRY NEXT PROCESS
	CMPW	R0,#SS$_NOMOREPROC	;NO MORE PROCESSES?
	BNEQ	80$			;IF NOT, REPORT ERROR
	CLRQ	(SP)			;RETURN NULL PID ON THIS INVOCATION
20$:	POPL	R1			;GET NEW CONTEXT LONGWORD
	MOVQ	P1(AP),R3		;SET DESCRIPTOR OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVL	#SYM_K_BINARY,R0	;SET TYPE IS BINARY LONGWORD
	DISABLE				;DISABLE CONTROL/Y AST'S
	BSBW	DCL$ALLOCSYM		;REPLACE VALUE OF SYMBOL
	ENABLE				;RE-ENABLE CONTROL/Y AST'S
	POPR	#^M<R0,R1,R2,R3>	;GET PID OF NEXT PROCESS & CLEAN STACK
	MOVL	SP,R2			;MARK VALUE IS A STRING
	MOVL	R0,R1			;END OF WILDCARD SEARCH?
	BEQL	30$			;IF SO, RETURN WITH A NULL STRING
	BSBW	DCL$CBTA_HEX		;CONVERT PID TO STRING AND EXIT
30$:	RSB

80$:	ADDL	#5*4,SP			;CLEAN STACK
	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	CHECK IF SPECIFIED PRIVS ARE SET OR CLEAR
;+
; F$PRIVILEGE - CHECK IF SPECIFIED PRIVILEGES ARE SET OR CLEAR
;
; THIS LEXICAL FUNCTION CAN BE USED TO DETERMINE WHETHER THE CURRENT PROCESS
; HAS A GIVEN SET OF PRIVILEGES ON OR OFF, DEPENDING ON THE KEYWORDS GIVEN.
; THE ARGUMENT IS A COMMA SEPARATED LIST OF PRIVILEGE KEYWORDS ABOUT WHICH
; THE CALLER IS INTERESTED.  IF THE PREFIX "NO" APPEARS ON THE KEYWORD, THEN
; THE FUNCTION CHECKS IF THE PRIVILEGE IS OFF.  OTHERWISE, THE FUNCTION CHECKS
; THAT THE PRIVILEGE IS ON.  THE FINAL VALUE OF THE FUNCTION IS THE "AND" OF
; ALL OF THE PRIVILEGE CHECKS - THAT IS, IT RETURNS TRUE IF ALL THE PRIVILEGES
; ARE SET AS SPECIFIED.
;
;	F$PRIVILEGE(PRVSTATES)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF A COMMA SEPARATED LIST OF PRIVILEGE KEYWORDS.
;
; OUTPUTS:
;
;	R1/R2 = BOOLEAN TRUE OR FALSE STRING
;-

F$PRIVILEGE:
	MOVL	R3,R6			;GET ADDRESS OF SCRATCH QUADWORD
	$SETPRV_S PRVPRV=(R6),-		;GET CURRENT PERMANENT PRIVILEGES
		PRMFLG=#1		;
	MOVQ	P1(AP),R4		;GET DESCRIPTOR OF COMMA SEPARATED LIST
10$:	MOVQ	R4,R2			;ASSUME NO COMMA IN LIST
	LOCC	#^A',',R4,(R5)		;LOCATE END OF NEXT KEYWORD
	BEQL	20$			;BRANCH IF NOT FOUND, USE ENTIRE STRING
	SUBL3	R0,R4,R2		;ISOLATE NEXT KEYWORD
20$:	MOVAB	-(R0),R4		;CHOP KEYWORD OFF STRING
	MOVAB	1(R1),R5
	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF KEYWORD
	PUSHAL	-(SP)			;PUSH ADDRESS OF WORD TO GET BIT NUMBER
	PUSHAB	8(SP)			;PUSH ADDRESS OF DESCRIPTOR
	CALLS	#2,G^PRV$PRIVBIT	;LOOKUP KEYWORD AND GET PRIV. BIT #
	POPR	#^M<R1,R2,R3>		;CLEANUP STACK
	BLBC	R0,70$			;IF ERROR, SIGNAL IT
	CMPW	(R3),#^A'NO'		;IS KEYWORD NEGATED?
	BEQL	30$			;IF SO, CHECK IF PRIVILEGE OFF
	BBC	R1,(R6),50$		;BRANCH IF PRIVILEGE NOT ON
	BRB	40$
30$:	BBS	R1,(R6),50$		;BRANCH IF PRIVILEGE NOT OFF
40$:	TSTL	R4			;ANY MORE KEYWORDS LEFT?
	BGTR	10$			;IF NOT, LOOP UNTIL DONE
	MOVL	#1,R1			;RETURN SUCCESS
	BRB	60$

50$:	CLRL	R1			;RETURN FAILURE
60$:	BRW	FORMAT_BOOLEAN		;RETURN "TRUE" OR "FALSE"

70$:	CMPL	#PRV$_NOTUNQ,R0		;AMBIGUOUS KEYWORD?
	BNEQ	75$			;IF NOT, EXIT WITH INVALID KEYWORD
	STATUS	ABKEYW			;SET AMBIGUOUS KEYWORD ERROR
	BRB	80$
75$:	STATUS	IVKEYW			;SET INVALID KEYWORD
80$:	BRW	P1_ERROR		;REPORT ERROR

	.SBTTL	RETURN PROCESS NAME
;+
; F$PROCESS - RETURN PROCESS NAME
;
; THIS LEXICAL FUNCTION OBTAINS THE CURRENT PROCESS NAME AND RETURN A DESCRIPTOR
; FOR IT.
;
;	F$PROCESS()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF PROCESS NAME.
;	R2 = ADDRESS OF PROCESS NAME.
;-
 
F$PROCESS:				;RETURN PROCESS NAME
	CLRL	-(SP)			;CLEAR LENGTH AND ITEM ID OF LAST ITEM
	PUSHAB	-12(SP)			;PUSH ADDRESS TO STORE LENGTH
	MOVQ	R2,-(SP)		;PUSH OUTPUT BUFFER DESCRIPTOR
	CMPL	#15,(SP)		;BUFFER BIG ENOUGH TO HOLD PROCESS NAME?
	BGTRU	2$			;IF GTRU NO
	MOVW	#JPI$_PRCNAM,2(SP)	;SET PROCESS NAME IDENTIFICATION
	MOVL	SP,R0			;SET ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0)		;GET PROCESS NAME
	CLRW	2(SP)			;CLEAR ITEM IDENTIFICATION
	BLBC	R0,3$			;IF LBC SERVICE FAILURE
	POPR	#^M<R1,R2,R3,R4>	;RETRIEVE PROCESS NAME PARAMETERS
	RSB				;
2$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW
3$:	BRW	ERROR			;REPORT ERROR IN R0

	.SBTTL	GET NEXT WILDCARD FILESPEC
;+
; F$SEARCH - GET NEXT WILDCARD FILESPEC
;
; THIS FUNCTION INVOKES THE $SEARCH SYSTEM SERVICE TO RETURN THE NEXT
; FILESPEC IN SEQUENCE, GIVEN THE WILDCARD CONTEXT.  IF THE EXPANDED
; NAME STRING IS NOT WILDCARD, THE EXPANDED NAME STRING IS CONVERTED
; INTO A RESULTANT NAME STRING.
;
;	F$SEARCH(ENM, STREAM_ID)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF EXPANDED NAME STRING
;	P2(AP) = OPTIONAL BINARY STREAM IDENTIFIER, DEFAULTS TO 0
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF RESULTANT FILESPEC
;-

F$SEARCH:
;
; SEARCH THE LIST OF SEARCH CONTEXT BLOCKS FOR THE REQUESTED STREAM.
; THE CONTEXT IS MATCHED BASED ON A USER SPECIFIED 32-BIT BINARY NUMBER.
;
; EACH CONTEXT BLOCK HAS THE FOLLOWING FORMAT:
;
;	LONGWORD POINTER TO NEXT BLOCK, 0 MEANS END OF LIST
;	LENGTH OF THIS BLOCK IN BYTES
;	FAB BLOCK   (FAB$L_CTX CONTAINS THE USER STREAM IDENTIFIER, P2)
;	NAM BLOCK
;	EXPANDED NAME STRING BUFFER
;	RESULTANT NAME STRING BUFFER
;	PRIMARY FILESPEC BUFFER
;
; ON OUTPUT FROM THIS PARAGRAPH:
;
;	R6 = ADDRESS OF CURRENT CONTEXT BLOCK, IF FOUND
;	R7 = ADDRESS OF PREVIOUS CONTEXT BLOCK IN LINKED LIST
;
	MOVL	PRC_L_STACKPT(R11),R0	;GET ADDRESS OF CURRENT INDIRECT FRAME
	MOVAB	IDF_L_SEARCHCTX(R0),R7	;GET ADDRESS OF LISTHEAD
10$:	MOVL	(R7),R6			;GET ADDRESS OF NEXT CONTEXT BLOCK
	BEQL	20$			;BRANCH IF CONTEXT NOT FOUND
	CMPL	P2(AP),FAB$L_CTX+8(R6)	;DOES THE STREAM IDENTIFIER MATCH?
	BEQL	15$			;BRANCH IF CONTEXT FOUND
	MOVL	R6,R7			;SKIP TO NEXT BLOCK IN LIST
	BRB	10$			;AND CONTINUE SEARCHING
;
; CONTEXT BLOCK FOUND IN LIST.  IF THE INPUT FILESPEC HAS CHANGED,
; THEN RESTART THIS STREAM WITH NEW FILESPEC.
;
15$:	MOVAB	8(R6),R5		;SET ADDRESS OF FAB
	MOVAB	FAB$C_BLN(R5),R4	;SET ADDRESS OF NAM
	MOVZBL	FAB$B_FNS(R5),R0	;GET SIZE OF PREVIOUS FILESPEC
	CMPC5	R0,@FAB$L_FNA(R5),#0,P1(AP),@P1+4(AP) ;SAME FILESPEC?
	BNEQ	28$			;IF NOT, RESTART SEARCH SEQUENCE
	BRW	30$			;ELSE, CONTINUE WHERE WE LEFT OFF
;
; THE CONTEXT WAS NOT FOUND AMONG THE EXISTING CONTEXT BLOCKS FOR THIS
; INDIRECT LEVEL.  CREATE A NEW CONTEXT BLOCK BY PARSING THE INPUT
; FILESPEC, P1, AND INSERTING THE CONTEXT BLOCK INTO THE LIST.
;
20$:	MOVZWL	#8+FAB$C_BLN+NAM$C_BLN+<3*NAM$C_MAXRSS>,R1 ;SET SIZE OF BLOCK
	BSBW	DCL$ALLDYNMEM		;ALLOCATE CONTEXT BLOCK
	BLBS	R0,25$			;BRANCH IF OK
	STATUS	SYMOVF			;SYMBOL TABLE OVERFLOW
	BRW	P1_ERROR		;REPORT ERROR
25$:	MOVL	R2,R6			;SAVE ADDRESS OF ALLOCATED BLOCK
	MOVL	(R7),(R6)		;INSERT INTO LINKED LIST
	MOVL	R6,(R7)
	MOVL	R1,4(R6)		;STORE SIZE IN NEWLY ALLOCATED BLOCK
	MOVC5	#0,(SP),#0,#FAB$C_BLN+NAM$C_BLN,8(R6)	;ZERO REST OF BLOCK
	MOVAB	8(R6),R5		;SET ADDRESS OF FAB
	MOVAB	FAB$C_BLN(R5),R4	;SET ADDRESS OF NAM
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R5) ;INITIALIZE FAB
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1
	MOVW	#NAM$C_BID+<NAM$C_BLN@8>,NAM$B_BID(R4) ;INITIALIZE NAM
	MOVL	R4,FAB$L_NAM(R5)	;SET POINTER TO NAM BLOCK
	SETBIT	FAB$V_PPF,FAB$L_FOP(R5)	;USE PROCESS I/O SEGMENT (SINCE THERE
					;   MAY NOT BE ANY IMAGE I/O SEGMENT)
	MOVL	P2(AP),FAB$L_CTX(R5)	;SAVE USER SEARCH STREAM IDENTIFIER
28$:	MOVB	P1(AP),FAB$B_FNS(R5)	;STORE PRIMARY NAME STRING INTO FAB
	MOVAB	NAM$C_BLN+<2*NAM$C_MAXRSS>(R4),FAB$L_FNA(R5)
	PUSHR	#^M<R4,R5>		;SAVE REGISTERS
	MOVC5	P1(AP),@P1+4(AP),#0,#NAM$C_MAXRSS,@FAB$L_FNA(R5)
	POPR	#^M<R4,R5>		;RESTORE REGISTERS
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R4) ;SET DESCRIPTOR OF ESA BUFFER
	MOVAB	NAM$C_BLN(R4),NAM$L_ESA(R4)
	MOVB	#NAM$C_MAXRSS,NAM$B_RSS(R4) ;SET DESCRIPTOR OF RESULT BUFFER
	MOVAB	NAM$C_BLN+NAM$C_MAXRSS(R4),- ;FOR $SEARCH (DONE HERE SINCE IT
		NAM$L_RSA(R4)		;DOESN'T CHANGE DURING ENTIRE SEQUENCE)
	$PARSE	FAB=(R5)		;SETUP EXPANDED NAME STRING, NAM FIELDS
	BLBC	R0,50$			;(SUCH AS FID,DID,DVI,ESL)
;
; SEARCH CONTEXT BLOCK IS NOW ASSOCIATED WITH THIS STREAM (IT WAS EITHER
; FOUND IN THE LIST, OR CREATED).  IF THE INPUT FILESPEC HAS CHANGED,
; THEN START OVER WITH NEW FILESPEC.  OTHERWISE, SEARCH FOR THE NEXT
; FILESPEC IN SEQUENCE.
;
30$:	$SEARCH	FAB=(R5)		;SEARCH FOR NEXT FILESPEC 
	BLBC	R0,50$			;BRANCH IF ERROR DETECTED
	BBS	#NAM$V_WILDCARD,NAM$L_FNB(R4),40$ ;IF WILDCARD, LEAVE CONTEXT
	BSBB	DELCTX			;DEALLOCATE THE CONTEXT BLOCK
40$:	MOVZBL	NAM$B_RSL(R4),R1	;GET LENGTH OF RESULTANT STRING
	MOVL	NAM$L_RSA(R4),R2	;GET ADDRESS OF RESULTANT STRING
	RSB
;
; AN ERROR HAS BEEN DURING EITHER THE $PARSE OR $SEARCH FUNCTIONS.
; IN ANY CASE, TERMINATE THIS SEARCH SEQUENCE BY REMOVING THE CONTEXT
; BLOCK FROM THE LIST.  RETURN A NULL STRING IF NMF OR FNF.  OTHERWISE,
; REPORT THE ERROR AS A SYNTAX ERROR.
;
50$:	CLRB	NAM$B_RSL(R4)		;RETURN NULL STRING ON NORMAL ERROR
	BSBB	DELCTX			;DEALLOCATE THE CONTEXT BLOCK
	MOVL	FAB$L_STS(R5),R0	;GET PRIMARY RMS STATUS
	BLBS	R0,40$			;IF SUCCESSFUL, RETURN STRING
	CMPW	R0,#RMS$_NMF&^XFFFF	;NO MORE FILES?
	BEQL	40$			;IF SO, RETURN NULL STRING
	CMPW	R0,#RMS$_FNF&^XFFFF	;FILE NOT FOUND?
	BEQL	40$			;IF SO, RETURN NULL STRING
	MOVL	FAB$L_STV(R5),R1	;GET SECONDARY (ACP) STATUS
	BEQL	55$			;BRANCH IF NONE
	MOVL	R1,R0			;RETURN SECONDARY STATUS, NOT RMS STATUS
55$:	BRW	P1_ERROR		;REPORT ERROR
;
; DEALLOCATE THE CONTEXT BLOCK
;
;	R6 = POINTER TO CONTEXT BLOCK
;	R7 = POINTER TO PREVIOUS BLOCK IN LIST
;
;	R0-R3 DESTROYED.
;
DELCTX:	MOVL	(R6),(R7)		;REMOVE FROM LINKED LIST
	MOVL	R6,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVL	4(R6),R1		;SET SIZE OF BLOCK TO DEALLOCATE
	BSBW	DCL$DEADYNMEM		;DEALLOCATE CONTEXT BLOCK
	RSB

	.SBTTL	SET/CLEAR SPECIFIED PRIVILEGES
;+
; F$SETPRV - SET OR CLEAR THE SPECIFIED LIST OF PRIVILEGES
;
; THIS FUNCTION SETS OR CLEARS (DEPENDING ON WHETHER A "NO" IS PREFIXED
; TO THE PRIVILEGE KEYWORD) THE SPECIFIED LIST OF PRIVILEGES IN THE PROCESS
; PERMANENT PRIVILEGE MASK.  THE PREVIOUS STATES OF THE LISTED PRIVILEGES
; ARE RETURNED AS THE VALUE OF THE FUNCTION.  NOTE THAT ONLY THE PREVIOUS
; STATES OF THE PRIVILEGES LISTED IN THE ARGUMENT ARE RETURNED, TO AVOID
; DEALING WITH STRINGS OF EXCESSIVE LENGTH.
;
;	F$SETPRV(PRVSTATES)
;
; INPUTS:
;
;	P1(AP) = DESCRIPTOR OF A COMMA SEPARATED LIST OF PRIVILEGE KEYWORDS.
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF COMMA SEPARATED LIST OF KEYWORDS INDICATING
;		THE PREVIOUS STATES OF THESE PRIVILEGES.
;-

F$SETPRV:
	MOVAQ	-(SP),R6		;GET ADDRESS OF SCRATCH QUADWORD
	BSBW	DCL$MARK		;MARK POSITION IN EXPANSION BUFFER
	$SETPRV_S PRVPRV=(R6),-		;GET CURRENT PERMANENT PRIVILEGES
		  PRMFLG=#1
	MOVQ	P1(AP),R4		;GET DESCRIPTOR OF COMMA SEPARATED LIST
10$:	MOVQ	R4,R2			;ASSUME NO COMMA IN LIST
	LOCC	#^A',',R4,(R5)		;LOCATE END OF NEXT KEYWORD
	BEQL	20$			;BRANCH IF NOT FOUND, USE ENTIRE STRING
	SUBL3	R0,R4,R2		;ISOLATE NEXT KEYWORD
20$:	MOVAB	-(R0),R4		;CHOP KEYWORD OFF STRING
	MOVAB	1(R1),R5
	PUSHR	#^M<R2,R3>		;SAVE REGISTERS
	CMPC5	#3,W^NOALL+2,#0,R2,(R3)	;IS KEYWORD = "ALL"?
	BEQL	22$			;BRANCH IF SO
	CMPC5	#5,W^NOALL,#0,R2,(R3)	;IS KEYWORD = "NOALL"?
22$:	POPR	#^M<R2,R3>		;RESTORE REGISTERS
	BNEQ	30$			;BRANCH IF NOT
	CLRL	R1			;START WITH PRIVILEGE #0
25$:	BSBW	ADD_PRIV_STATE		;APPEND PRIVILEGE KEYWORD TO STRING
	AOBLSS	#64,R1,25$		;FOR EACH PRIVILEGE IN MASK
	BRB	40$
30$:	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF KEYWORD
	PUSHAL	-(SP)			;ADDRESS OF LONGWORD TO RECEIVE BIT #
	PUSHAB	8(SP)			;SET ADDRESS OF KEYWORD
	CALLS	#2,G^PRV$PRIVBIT	;LOOKUP KEYWORD
	POPR	#^M<R1,R2,R3>		;AND GET PRIVILEGE BIT NUMBER IN R1
	BLBC	R0,51$			;BRANCH IF ERROR DETECTED
	BSBB	ADD_PRIV_STATE		;APPEND PRIVILEGE KEYWORD TO STRING
40$:	MOVQ	R2,-(SP)		;PUSH DESCRIPTOR OF KEYWORD
	PUSHL	R6			;SET ADDRESS OF PRIVILEGE MASK
	PUSHAB	4(SP)			;SET ADDRESS OF KEYWORD
	CALLS	#2+2,G^PRV$SETPRIV	;ENABLE/DISABLE SPECIFIED PRIVILEGE
51$:	BLBC	R0,50$			;BRANCH IF ERROR DETECTED
	TSTL	R4			;ANY MORE KEYWORDS?
	BGTR	10$			;IF SO, LOOP UNTIL DONE
	MNEGL	#1,-(SP)		;CREATE PRIVILEGE MASK WITH ALL
	MNEGL	#1,-(SP)		;THE PRIVILEGE BITS SET
	MOVL	SP,R2			;GET ADDRESS OF IT
	$SETPRV_S PRVADR=(R2),-		;DISABLE ALL PRIVILEGES
		  PRMFLG=#1,-		;
		  ENBFLG=#0		;
	$SETPRV_S PRVADR=(R6),-		;ENABLE NEW PRIVILEGES
		  PRMFLG=#1,-		;
		  ENBFLG=#1		;
	ADDL	#16,SP			;CLEANUP STACK
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF STRING
	MOVL	WRK_L_MARKPTR(R10),WRK_L_EXPANDPTR(R10)	;RESTORE POSITION IN EXPANSION BUFFER
	DECL	R1			;DO NOT RETURN TRAILING COMMA
	RSB
	
50$:	CMPL	#PRV$_NOTUNQ,R0		;AMBIGUOUS KEYWORD?
	BNEQ	55$			;IF NOT, EXIT WITH INVALID KEYWORD
	STATUS	ABKEYW			;SET AMBIGUOUS KEYWORD ERROR
	BRB	80$
55$:	STATUS	IVKEYW			;SET INVALID KEYWORD
80$:	ADDL	#8,SP			;CLEANUP STACK
	BRW	P1_ERROR		;REPORT ERROR

	.SBTTL	APPEND PRIVILEGE STATE TO STRING
;---
; ADD_PRIV_STATE - APPEND PRIVILEGE STATE (IN KEYWORD FORM) TO STRING.
;
; THIS ROUTINE APPENDS THE PRIVILEGE KEYWORD ASSOCIATED WITH A GIVEN
; PRIVILEGE BIT AND MASK TO THE CURRENT STRING BEING ASSEMBLED IN THE
; EXPANSION BUFFER.  IF THE PRIVILEGE BIT NUMBER DOES NOT CORRESPOND
; TO A KEYWORD, NOTHING IS APPENDED TO THE STRING AND NO ERROR IS RETURNED.
;
; INPUTS:
;
;	R1 = PRIVILEGE BIT NUMBER
;	R6 = ADDRESS OF PRIVILEGE MASK
;
; OUTPUTS:
;
;	THE KEYWORD (NEGATED IF THE PRIVILEGE IS OFF) IS APPENDED TO THE
;	STRING.
;
;	R0 DESTROYED.
;---

ADD_PRIV_STATE:
	PUSHL	R1			;SAVE PRIVILEGE BIT NUMBER
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE CURRENT POSITION IN BUFFER
	BBS	R1,(R6),30$		;BRANCH IF PRIVILEGE WAS PREVIOUSLY SET
	MOVZBL	#^A'N',R0		;INSERT AN "N" INTO THE BUFFER
	BSBW	DCL$PUTCHAR
	MOVZBL	#^A'O',R0		;INSERT AN "O" INTO THE BUFFER
	BSBW	DCL$PUTCHAR
30$:	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF EXPANSION BUFFER
	SUBL3	(SP),WRK_L_CHARPTR(R10),-(SP) ;SCRATCH AREA LEFT
	PUSHL	SP			;ADDRESS OF WORD TO GET RETLEN
	PUSHAB	4(SP)			;ADDRESS OF BUFFER DESCRIPTOR
	PUSHL	R1			;SET PRIVILEGE BIT NUMBER
	CALLS	#3,G^PRV$KEYWORD	;GET KEYWORD ASSOCIATED WITH BIT NUMBER
	ADDL3	(SP)+,(SP)+,R1		;POINT TO STRING END+1
	BLBC	R0,50$			;IF NO SUCH PRIVILEGE, APPEND NOTHING
	ADDL	#4,SP			;THROW AWAY SAVED EXPANSION POINTER
	MOVL	R1,WRK_L_EXPANDPTR(R10)	;INSERT INTO EXPANSION BUFFER
	MOVZBL	#^A',',R0		;INSERT AN "," INTO THE BUFFER
	BSBW	DCL$PUTCHAR
90$:	POPL	R1			;RESTORE PRIVILEGE BIT NUMBER
	RSB

50$:	POPL	WRK_L_EXPANDPTR(R10)	;BACKUP POSITION IN BUFFER
	BRB	90$			;AND EXIT WITHOUT APPENDING ANYTHING

	.SBTTL	CONVERT EXPRESSION TO ASCII STRING
;+
; F$STRING - CONVERT TO ASCII STRING
;
; THIS FUNCTION CONVERTS ANY EXPRESSION INTO AN ASCII STRING.  IF THE
; EXPRESSION IS A BINARY VALUE, IT IS CONVERTED INTO DECIMAL ASCII.
;
;	F$STRING(EXPRESSION)
;
; INPUTS:
;
;	P1(AP) = EXPRESSION VALUE
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF VALUE STRING
;-

F$STRING:
	MOVQ	P1(AP),R1		;GET EXPRESSION VALUE
	BSBW	DCL$CVT_STRING		;CONVERT TO ASCII STRING
	BLBC	R0,90$			;BRANCH IF ERROR DETECTED
	RSB
90$:	BRW	P1_ERROR		;REPORT ERROR AND DISPLAY P1

	.SBTTL	RETURN CURRENT TIME AND DATE
;+
; F$TIME - RETURN CURRENT TIME AND DATE
;
; THIS LEXICAL FUNCTION OBTAINS THE CURRENT TIME AND DATE AND RETURNS A STRING
; DESCRIPTOR FOR IT.
;
;	F$TIME()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF TIME AND DATE STRING.
;	R2 = ADDRESS OF TIME AND DATE STRING.
;-
 
F$TIME:					;RETURN TIME AND DATE
	MOVQ	R2,-(SP)		;BUILD TIME BUFFER DESCRIPTOR
	CMPL	#23,(SP)		;TIME BUFFER LARGE ENOUGH?
	BGTRU	50$			;IF GTRU NO
	MOVL	SP,R0			;SET ADDRESS OF TIME BUFFER DESCRIPTOR
	$ASCTIM_S (R0),(R0)		;GET CURRENT TIME
	MOVQ	(SP)+,R1		;RETRIEVE TIME BUFFER PARAMETERS
	BLBC	R0,60$			;IF LBC CONVERSION FAILURE
	RSB				;

50$:	BRW	BUFOVF			;REPORT BUFFER OVERFLOW
60$:	BRW	ERROR			;REPORT SYSTEM SERVICE ERROR

	.SBTTL	RETURN USER IDENTIFICATION CODE
;+
; F$USER - RETURN USER IDENTIFICATION CODE
;
; THIS LEXICAL FUNCTION FUNCTION CONVERTS THE USER IDENTIFICATION CODE TO AN
; ASCII STRING AND RETURNS A DESCRIPTOR FOR IT.
;
;	F$USER()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF USER IDENTIFICATION CODE.
;	R2 = ADDRESS OF USER IDENTIFICATION CODE.
;-
 
F$USER:					;RETURN USER IDENTIFICATION CODE
	BSBW	DCL$MARK		;MARK POSITION IN BUFFER
	MOVB	#^A/[/,R0		;GET LEFT BRACKET
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN EXPANSION BUFFER
	CLRQ	-(SP)			;CLEAR LAST ITEM AND LENGTH ADDRESS
	PUSHAB	-8(SP)			;PUSH ADDRESS TO STORE USER IDENTIFICATION
	PUSHL	#JPI$_UIC@16+4		;SET PARAMETER ID AND LENGTH
	MOVL	SP,R0			;SET ADDRESS OF TIME LIST
	$GETJPI_S ITMLST=(R0)		;GET USER IDENTIFICATION CODE
	BLBC	R0,ERROR		;IF LBC SERVICE FAILURE
	MOVZWL	2(SP),R0		;GET GROUP CODE
	BSBW	DCL$CBTA_OCT		;CONVERT GROUP CODE TO ASCII
	ADDL3	R1,R2,WRK_L_EXPANDPTR(R10) ;INSERT INTO EXPANSION BUFFER
	MOVZBL	#^A/,/,R0		;SET SEPARATOR CHARACTER
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN EXPANSION BUFFER
	MOVZWL	(SP),R0			;GET MEMBER CODE
	BSBW	DCL$CBTA_OCT		;CONVERT MEMBER CODE TO ASCII
	ADDL3	R1,R2,WRK_L_EXPANDPTR(R10) ;INSERT INTO EXPANSION BUFFER
	ADDL	#4*4,SP			;REMOVE ITEM LIST FROM STACK
	MOVB	#^A/]/,R0		;GET RIGHT BRACKET
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN OUTPUT BUFFER
	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF STRING
	MOVL	WRK_L_MARKPTR(R10),WRK_L_EXPANDPTR(R10)	;RESTORE POSITION IN EXPANSION BUFFER
	RSB				;

	.SBTTL	RETURN VERIFY MODE
;+
; F$VERIFY - RETURN VERIFY MODE
;
; THIS LEXICAL FUNCTION RETURNS A BOOLEAN VARIABLE THAT DESCRIBES THE CURRENT
; STATE OF THE VERIFY MODE AND, IN ADDITION, WILL SET OR CLEAR VERIFICATION
; IF A NON-NULL ARGUMENT IS SPECIFIED AND IT'S NOT DURING A GOTO SCAN.
;
;	F$VERIFY()	-OR-	F$VERIFY(NEW_VERIFY_MODE)
;
; INPUTS:
;
;	P1(AP) = OPTIONAL NEW VERIFY MODE (1 TO SET, 0 TO CLEAR)
;		(-1 IF UNSPECIFIED)
;
; OUTPUTS:
;
;	R1 = BOOLEAN RESULT
;	R2 = 0 TO INDICATE RESULT IS BINARY
;-
 
F$VERIFY:				;RETURN VERIFY MODE
	MOVL	#1,R8			;ASSUME VERIFY IS CURRENTLY ON
	BBS	#PRC_V_VERIFY,PRC_W_FLAGS(R11),10$ ;BR IF ON
	CLRL	R8			;MARK VERIFY TURNED OFF
10$:	TSTL	P1(AP)			;A NON-NULL ARGUMENT?
	BLSS	30$			;NOPE, IT'S NULL, NO CHANGES
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),30$ ;NO CHANGES MADE IF GOTO
	CLRBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11) ;TURN OFF VERIFICATION
	BLBC	P1(AP),30$		;LEAVE VERIFY OFF IF LBC
	SETBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11) ;ELSE TURN ON VERIFICATION
30$:	MOVL	R8,R1			;RETURN BOOLEAN RESULT
	CLRL	R2			;INDICATE RESULT IS BINARY
	RSB				;

	.SBTTL	ERROR RETURNS
 
;
; BUFFER OVERFLOW
;
 
BUFOVF:	STATUS	BUFOVF			;SET BUFFER OVERFLOW STATUS
ERROR:	BSBW	DCL$MARK		;SET FOR NO SEGMENT DISPLAY
	BRB	DCL$PARSERR

;
; SIGNAL ERROR WITH AN ARGUMENT AS THE ERROR SEGMENT
;

P1_ERROR:
	MOVAB	P1(AP),R2		;USE P1 AS ERROR SEGMENT
	BRB	PN_ERROR
P2_ERROR:
	MOVAB	P2(AP),R2		;USE P2 AS ERROR SEGMENT
	BRB	PN_ERROR
P4_ERROR:
	MOVAB	P4(AP),R2		;USE P4 AS ERROR SEGMENT

PN_ERROR:
	CLRL	R1			;PRESET TO RETURN NULL STRING
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),30$ ;RETURN NULL IF IN GOTO
	BBS	#WRK_V_COMMENT,WRK_W_FLAGS(R10),30$ ;RETURN NULL IF IN COMMENT
	MOVL	4(R2),WRK_L_MARKPTR(R10) ;SET START OF ERROR SEGMENT
	ADDL3	(R2),4(R2),WRK_L_EXPANDPTR(R10) ;SET END OF ERROR SEGMENT
	BRB	DCL$PARSERR		;REPORT ERROR
30$:	RSB				;RETURN WITH FUNCTION=NULL/ZERO

;
; ERROR EXIT FROM LEXICAL FUNCTION STRING EXPANSION
;
 
DCL$PARSERR::				;
	BSBW	DCL$ERRORMSG		;OUTPUT ERROR MESSAGE
	PUSHL	R0			;SAVE FINAL STATUS
	BSBW	DCL$FLUSH		;FLUSH COMMAND
	POPL	R0			;RETRIEVE FINAL STATUS
	BSBW	DCL$SET_STATUS		;SET COMMAND STATUS
	BRW	DCL$RESTART		;

	.SBTTL	CONVERT UIC TO ASCII STRING
;+
; FORMAT_UIC - CONVERT BINARY UIC TO ASCII STRING
;
; CONVERTS A BINARY UIC LONGWORD INTO AN ASCII STRING
;
; INPUTS:
;
;	R4 = UIC LONGWORD
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING
;
;-

UIC:	.ASCIC	'[!3OB,!3OB]'

FORMAT_UIC:
	MOVAB	UIC,R1			;GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		;CREATE DESCRIPTOR OF FAO STRING
	MOVQ	R0,-(SP)		;PUSH ONTO STACK
	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF SCRATCH BUFFER
	PUSHL	#9
	MOVL	SP,R0
	ASHL	#-16,R4,R1		;GET GROUP NUMBER
	$FAO_S	CTRSTR=8(R0),-		;FORMAT INTO ASCII STRING
		OUTBUF=(R0),-		;ADDRESS OF RESULT BUFFER
		OUTLEN=(R0),-		;WORD TO RECEIVE RESULT LENGTH
		P1=R1,-			;GROUP NUMBER
		P2=R4			;MEMBER NUMBER
	POPR	#^M<R1,R2,R3,R4>	;GET DESCRIPTOR OF STRING
					;AND CLEAN STACK
	RSB

	.SBTTL	CONVERT PROTECTION MASK TO ASCII STRING
;+
; FORMAT_PROT - CONVERT BINARY PROTECTION MASK TO ASCII STRING
;
; CONVERTS A BINARY PROTECTION MASK WORD INTO AN ASCII STRING
;
; INPUTS:
;
;	R4 = UIC LONGWORD
;	R10 = BASE ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING
;
; REGISTER USAGE:
;
;	R0,R1,R2,R3,R7,R8
;-

ACCESS:	.ASCII	/RWED/
PROTECTMSG:
	.ASCII	/SYSTEM=!AD, OWNER=!AD, GROUP=!AD, WORLD=!AD/
PROTECTEND:

FORMAT_PROT:
	MOVL	SP,R3			;START A SCRATCH AREA ON THE STACK
	SUBL	#4*8,SP			;ALLOCATE FAO ARGUMENT DESCRIPTORS

	MOVZBL	#12,R8			;SET OUTER LOOP INDEX
10$:	CLRL	-(SP)			;ALLOCATE SPACE FOR FAO ARG BUFFER
	CLRQ	-(R3)			;ZERO FAO ARG DESCRIPTOR
	EXTZV	R8,#4,R4,R1		;EXTRACT ONE PROTECTION FIELD
	MCOML	R1,R2			;COMPLEMENT IT
	BITL	#^XF,R2			;ALL ACCESS DENIED?
	BEQL	40$			;IF EQL, YES
	CLRL	R7			;CLEAR INNER LOOP INDEX
	MOVAB	(SP),4(R3)		;PUT ADDR OF BUFFER IN DESCRIPTOR
	CLRL	(R3)			;CLEAR BUFFER LENGTH

20$:	BBS	R7,R1,30$		;IF SET, ACCESS DENIED
	MOVB	ACCESS[R7],@(R3)[SP]	;MOVE ACCESS CHARACTER INTO BUFFER
	INCL	(R3)			;INCREMENT BUFFER LENGTH
30$:	AOBLSS	#4,R7,20$		;CHECKED ALL FOUR BITS?

40$:	ACBB	#0,#-4,R8,10$		;CHECKED ALL FOUR MODES?

	PUSHAB	PROTECTMSG		;PUSH DESCRIPTOR FOR CONTROL STRING 
	PUSHL	#PROTECTEND-PROTECTMSG
	PUSHL	WRK_L_EXPANDPTR(R10)	;PUSH DESCRIPTOR TO RECEIVE FAO OUTPUT
	PUSHL	#PROTECTEND-PROTECTMSG+4
	MOVL	SP,R0			;SAVE POINTER TO TOP OF STACK
	$FAOL_S	CTRSTR=8(R0),-		;GENERATE FORMATTED ASCII STRING
		OUTBUF=(R0),-
		OUTLEN=(R0),-
		PRMLST=(R3)

	MOVQ	(SP),R1			;MOVE OUTPUT DESCRIPTOR INTO R1/R2
	ADDL	#16*4,SP		;RESTORE STACK
	RSB	

	.SBTTL	CONVERT FILE ID TO ASCII STRING
;+
; FORMAT_FILEID - CONVERT FILE ID TO ASCII STRING
;
; INPUTS:
;
;	R4 = ADDRESS OF 3-WORD FILE ID
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING
;-

FILEID:	.ASCIC	'(!UW,!UW,!UB)'

FORMAT_FILEID:
	MOVAB	FILEID,R1		;GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0		;CREATE DESCRIPTOR OF FAO STRING
	MOVQ	R0,-(SP)		;PUSH ONTO STACK
	PUSHL	WRK_L_EXPANDPTR(R10)	;CREATE DESCRIPTOR OF SCRATCH BUFFER
	SUBL3	WRK_L_EXPANDPTR(R10),WRK_L_CHARPTR(R10),-(SP)
	MOVL	SP,R0
	$FAO_S	CTRSTR=8(R0),-		;FORMAT INTO ASCII STRING
		OUTBUF=(R0),-		;ADDRESS OF RESULT BUFFER
		OUTLEN=(R0),-		;WORD TO RECEIVE RESULT LENGTH
		P1=(R4),-		;FILE NUMBER
		P2=2(R4),-		;SEQUENCE NUMBER
		P3=4(R4)		;RELATIVE VOLUME NUMBER
	POPR	#^M<R1,R2,R3,R4>	;GET DESCRIPTOR OF STRING
					;AND CLEAN STACK
	RSB

	.SBTTL	CONVERT BINARY TO BOOLEAN STRING
;+
; FORMAT_BOOLEAN - CONVERT BINARY TO ASCII BOOLEAN STRING
;
; INPUTS:
;
;	R1 = STATUS (ONLY BOTTOM BIT CHECKED)
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF ASCII STRING (TRUE OR FALSE)
;-

FORMAT_BOOLEAN:
	MOVAB	FALSE,R2		;ASSUME FALSE
	BLBC	R1,10$			;BRANCH IF FALSE
	MOVAB	TRUE,R2			;SET TRUE
10$:	MOVZBL	(R2)+,R1		;SET DESCRIPTOR OF BOOLEAN STRING
	RSB

	.SBTTL	CONVERT BINARY TO 8-DIGIT HEX
;+ 
; CBTA_HEX - CONVERT BINARY TO HEX STRING
;
; CONVERT A BINARY NUMBER TO A HEX STRING OF EXACTLY 8 DIGITS.
;
; INPUTS:
;
;	R0 = NUMBER TO BE CONVERTED.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED VALUE.
;	R2 = ADDRESS OF CONVERTED VALUE.
;-
DIGIT_TABLE:
	.ASCII	'0123456789ABCDEF'

DCL$CBTA_HEX::
	MOVL	#8,R3			;INITIALIZE NUMBER OF DIGITS STORED
	ADDL3	R3,WRK_L_EXPANDPTR(R10),R2 ;POINT TO END+1 OF BUFFER SPACE
10$:	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#16,R0,R0,R1		;ISOLATE NEXT DIGIT
	MOVB	DIGIT_TABLE[R1],-(R2)	;CONVERT DIGIT TO ASCII AND SAVE
	SOBGTR	R3,10$			;CONVERT EXACTLY 8 DIGITS
	MOVL	#8,R1			;RETURN LENGTH OF HEX STRING
	RSB

	.SBTTL	CONVERT BINARY TO ZERO SUPRESSED ASCII
;+ 
; CBTA_DEC - CONVERT BINARY TO ASCII BASE TEN
; CBTA_OCT - CONVERT BINARY TO ASCII BASE EIGHT
;
; THESE ROUTINES ARE CALLED TO CONVERT A BINARY NUMBER TO A LEFT JUSTIFIED, ZERO
; SUPRESSED, ASCII STRING.  THE RESULTANT STRING IS PLACED IN THE EXPANSION
; BUFFER AND THE EXPANSION POINTER IS UPDATED.
;
; INPUTS:
;
;	R0 = NUMBER TO BE CONVERTED.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED VALUE.
;	R2 = ADDRESS OF CONVERTED VALUE.
;-
	.ENABL	LSB

DCL$CBTA_OCT::				;CONVERT BINARY TO ASCII BASE EIGHT
	MOVZBL	#8,R3			;SET CONVERSION RADIX
	BRB	10$			;
DCL$CBTA_DEC::				;CONVERT BINARY TO ASCII BASE TEN
	MOVZBL	#10,R3			;SET CONVERSION RADIX
10$:	MOVL	WRK_L_EXPANDPTR(R10),R2	;MARK POSITION IN BUFFER
	TSTL	R0			;IS NUMBER NEGATIVE?
	BGEQ	15$			;NO, THEN SKIP
	MNEGL	R0,R4			;YES, THEN CHANGE SIGN AND SAVE VALUE
	MOVZBL	#^A"-",R0		;GET NEGATIVE SIGN
	BSBW	DCL$PUTCHAR		;PUT IT IN THE EXPANSION BUFFER
	MOVL	R4,R0			;RECOVER VALUE
15$:	BSBB	20$			;PUT ASCII CHARACTERS INTO BUFFER
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;GET DESCRIPTOR OF RESULTANT STRING
	MOVL	R2,WRK_L_EXPANDPTR(R10)	;RESET EXPANSION BUFFER POINTER
	RSB
;
; RECURSIVE ROUTINE TO OUTPUT THE ASCII NUMBER, HIGH ORDER DIGITS FIRST
; WITHOUT ANY LEADING SPACES OR ZEROS.
;
20$:	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R3,R0,R0,R1		;ISOLATE NEXT DIGIT
	ADDL3	#^A'0',R1,-(SP)		;CONVERT DIGIT TO ASCII AND SAVE
	TSTL	R0			;ANY MORE DIGITS TO CONVERT?
	BEQL	30$			;IF EQL NO
	BSBB	20$			;CONVERT NEXT DIGIT
30$:	POPL	R0			;RETRIEVE NEXT CHARACTER
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN EXPANSION BUFFER
	RSB

	.DSABL	LSB
 

	.SBTTL	REMOVE BLANKS AND UPCASE STRING
;+ 
; DCL$REMBLANKS - REMOVE BLANKS AND UPCASE STRING
;
; THIS ROUTINE IS CALLED TO UPCASE AND REMOVE ALL THE BLANKS FROM THE INPUT 
; STRING.  THE RESULTANT STRING IS RETURNED VIA THE INPUT DESCRIPTOR.
; 
; INPUTS:
;
;	R1 = LENGTH OF INPUT STRING
;	R2 = ADDRESS OF INPUT STRING
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED STRING
;	R2 = ADDRESS OF CONVERTED STRING
;	R3,R4 = USED INTERNALLY
;-

DCL$REMBLANKS::
	TSTL	R1				; IS LENGTH ZERO
	BEQL	50$				; YES, THEN DONE
	MOVL	R2,R3				; COPY ADDRESS OF STRING
	MOVL	R2,R4				; COPY ADDRESS OF STRING
10$:	CMPB	#^X20,(R3)			; IS CHARACTER A BLANK
	BNEQ	20$				; NO, GO TO UPCASE
	INCL	R3				; YES, REMOVE IT
	BRB	40$				; SKIP MOVING AND UPCASING
20$:	CMPB	#^A/a/,(R3)			; IS CHARACTER GEQ a
	BGTR	30$				; NO, THEN SKIP UPCASING
	CMPB	#^A/z/,(R3)			; IS CHARACTER LEQ z
	BLSS	30$				; NO, THEN SKIP UPCASING
	SUBB	#^X20,(R3)			; YES, THEN UPCASE
30$:	MOVB	(R3)+,(R4)+			; MOVE CHARACTER
40$:	SOBGTR	R1,10$				; LOOP TILL DONE
	SUBL3	R2,R4,R1			; CALCULATE NEW LENGTH
50$:	RSB

	.END
