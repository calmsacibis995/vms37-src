	.TITLE	IMAGEXECT - IMAGE EXECUTION
	.IDENT	'V03-010'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; IMAGE EXECUTION BY EXTERNAL IMAGE COMMAND OR RUN COMMAND
;
; D. N. CUTLER 4-APR-77
;
; MODIFIED BY:
;
;	V03-010	PHL0049		Peter H. Lipman		23-Apr-1982
;		Make closed routine for DCL$FORCEXIT for use in running
;		down a privileged image at the command dispatcher
;		in module COMMAND.
;
;	V02-009	PCG0004		Peter George		07-Apr-1982
;		Check for silent logout in DCL$LOGOUT.
;
;	V02-008	PCG0003		Peter George		16-Mar-1982
;		Add DCL$EOJ routine.
;
;	V02-007	PCG0002		Peter George		04-Nov-1981
;		Allocate dummy AST argument list before calling
;		DCL$SCNTRLY.
;
;	V02-006	PCG0001		Peter George		28-Oct-1981
;		Zero CTL$GL_CLINTOWN and CTL$GL_DCLPRSOWN before 
;		image rundown.
;
;	V02-005	LJK0062		Lawrence J. Kenah	10-Sep-1981
;		Add call to perform activation time address relocation.
;
;	V004	TMH0004		Tim Halvorsen	27-Apr-1981
;		Rename PRC_L_CLIWRK0 to PRC_L_PPFLIST.
;		Use new cell PRC_L_INDEPTH to determine if level 0 or not.
;		Make use of new routine to determine PRC address.
;
;	V003	TMH0003		Tim Halvorsen	03-Apr-1981
;		Change method of locating PRC area.  Remove code
;		in DCL$LOGOUT to setup the scratch stack and buffer
;		descriptor since it is now done in DCL$ABORT as well
;		as normal command dispatching.  Remove code which
;		deletes all logical names from the supervisor mode
;		logical name table, as these names may want to be
;		passed from one job step to another, and it allows
;		execution of a test version of LOGINOUT on logout.
;
;	V002	TMH0002		Tim Halvorsen	13-Feb-1981
;		Remove all references to R10.
;		Use R10 rather than FP as WRK address.
;
;	V001	TMH0001		Tim Halvorsen	09-Sep-1980
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	$PPDDEF				;PROCESS PERMANENT DATA AREA
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;RESULT PARSE DESCRIPTORS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$CHFDEF				;DEFINE CONDITION ARGLIST OFFSETS
	$FABDEF				;DEFINE FAB OFFSETS
	$IFDDEF				;IMAGE FILE DESCRIPTOR DEFINITIONS
	$IHDDEF				;IMAGE HEADER DESCRIPTOR DEFINTITIONS
	$NAMDEF				;DEFINE NAME BLOCK OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS LONG WORD VALUES
	$CLIDEF				;DEFINE IMAGE ARGUMENT LIST FORMAT
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
EXTDEFAULT:				;EXTERNAL COMMAND IMAGE DEFAULT STRING
	.ASCIC	'SYS$SYSTEM:.EXE'
RUNDEFAULT:				;RUN COMMAND IMAGE DEFAULT STRING
	.ASCIC	'.EXE'
LOGOUTIMG:				;FILENAME TEXT STRING FOR LOGOUT IMAGE
	.ASCIC	'LOGINOUT'
MCRIMG:					;IMAGE FOR MCR COMMAND
	.ASCIC	'RSX'
SYSPRINT:				;DEFAULT QUEUE LOGICAL NAME
	.ASCII	'SYS$PRINT'
SYSPRTSIZ = . - SYSPRINT		;SIZE OF THAT STRING

;
; DEFINE IMAGE NAMES
;
	.MACRO	INTIMAGE NAME
IMG_K_'NAME = $INTIMAGE$
$INTIMAGE$ = $INTIMAGE$ + 1
	.ENDM

	INTIMAGES

	.SBTTL	RUN IMAGE
;+
; DCL$RUN - RUN IMAGE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE RUN COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFED IMAGE IS INITIATED.
;-
 
DCL$RUN::				;RUN IMAGE
	BICW	#<PRC_M_DBGQUAL!PRC_M_DBGTRUE>,- ;CLEAR DEBUG QUALIFIER SEEN,
		PRC_W_FLAGS(R11)	;AND DEBUG QUALIFIER TRUE FLAGS.
	CLRQ	-(SP)			;MAKE A SCRATCH BUFFER
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPB	R5,#PTR_K_ENDLINE	;IS THIS THE END OF THE PARAMETERS?
	BEQL	30$			;BR IF YES
	CMPB	R5,#PTR_K_PARAMETR	;IS THIS THE FILE TO RUN?
	BEQL	20$			;BR IF YES
	BISW	#<PRC_M_DBGQUAL!PRC_M_DBGTRUE>,- ;SET DEBUG QAULIFIER SEEN
		PRC_W_FLAGS(R11)	;AND ASSUME QUALIFIER TRUE
	BLBC	R3,10$			;BR IF NOT NEQATED
	CLRBIT	PRC_V_DBGTRUE,PRC_W_FLAGS(R11) ;SET STATE TO FALSE
	BRB	10$			;
20$:	MOVQ	R1,(SP)			;SAVE FILE SPECIFICATION DESCRIPTOR
	BRB	10$			;LOOK FOR MORE
30$:	POPR	#^M<R1,R2>		;GET FILE SPEC OF FILE TO RUN
	BRW	SETRUNDEF		;SET RUN DEFAULT AND GO RUN IT

	.SBTTL	TERMINATE THE JOB
;----
; DCL$EOJ
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EFFECT A LOGOUT WHEN 
; END_OF_JOB IS DETECTED.  CARE IS TAKEN TO SETUP THE RESULT PARSE DESCRIPTORS 
; SO THAT LOGINOUT CAN USE RESULT PARSING AS IF A LOGOUT COMMAND LINE HAD
; BEEN SPECIFIED.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE LOGOUT IMAGE IS INITIATED.
;----

DCL$EOJ::
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RESET RESULT ARRAY PTR
	MOVAB	WRK_G_BUFFER(R10),R2	;GET ADDRESS OF EXPANSION BUFFER
	MOVL	R2,WRK_L_EXPANDPTR(R10) ;RESET EXPANSION PTR
	MOVL	#^A'LOGO',(R2)		;STORE VERB INTO BUFFER
	MOVL	#4,R1			;SET LENGTH OF VERB
	MOVZBL	#IMG_K_LOGOUT,WRK_L_IMAGE(R10)	;SET ROUTINE IN CASE NOT FOUND
	MOVL	PRC_L_TAB_VEC(R11),R8	;GET ADDRESS OF DATA BASE VECTOR
	BSBW	DCL$SEARCH_VERB		;LOCATE COMMAND DEFINITION FOR
					;LOGOUT CLI INTERFACE (IGNORE ERRORS)
	MOVAB	WRK_G_RESULT(R10),-	;RESET ADDRESS OF NEXT DESCRIPTOR
		WRK_L_RSLNXT(R10)	;  IN RESULT PARSE AREA

	.SBTTL	LOGOUT PROCESS
;+
; DCL$LOGOUT - LOGOUT THE PROCESS
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE LOGOUT 
; COMMAND OR TO EFFECT A LOGOUT WHEN END_OF_FILE OCCURS FOR A DETACED JOB.
; ALSO, MAY BE ENTERED IF A HANGUP OCCURS ON A PROCESS WITH A DIAL UP INPUT.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE LOGOUT IMAGE IS INITIATED.
;-
 
DCL$LOGOUT::				;LOGOUT OFF THE PROCESS

;
; IF SILENT LOGOUT SPECIFIED, THEN SKIP LOGOUT AND BRANCH TO THERE.
;
	BBC	#PRC_V_AUTOLOGO,PRC_W_FLAGS(R11),10$ ; BRANCH IF FLAG NOT SET
	BRW	SILENT_LOGOUT

;
; RUN DOWN ANY PROCEDURES OR IMAGES STILL ACTIVE
;
10$:	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT LEVEL
	BRB	10$			;
;
; CLOSE ALL PROCESS PERMANENT FILES STILL OPEN
;
20$:	MOVL	PRC_L_INDFAB(R11),R9	;GET ADDRESS OF INDIRECT FAB
	MOVAB	PRC_L_PPFLIST(R11),R2	;GET ADDRESS OF FILE DESCRIPTOR LISTHEAD
30$:	MOVL	(R2),R2			;GET ADDRESS OF NEXT FILE DESCRIPTOR
	BEQL	40$			;IF EQL END OF LIST
	MOVW	RAB$L_CTX+4(R2),FAB$W_IFI(R9) ;INSERT INTERNAL FILE INDEX
	$CLOSE	FAB=(R9)		;CLOSE FILE
	BRB	30$			;
;
; ACTIVATE LOGOUT IMAGE
;
40$:	MOVL	PRC_L_LSTSTATUS(R11),-	;PASS FINAL STATUS TO LOGOUT
		G^CTL$AG_CLIDATA+PPD$L_LSTSTATUS
	MOVAB	LOGOUTIMG,R2		;START OF THE COUNTED STRING
	BRB	SETIMGNAME		;GO SET LENGTH, DEFAULT, & EXECUTE IT

	.SBTTL	MCR COMMAND
;+
; DCL$MCR - EXECUTE THE MCR COMMAND
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE MCR COMMAND 
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE FIRST TOKEN ON THE COMMAND LINE IS USED TO ACTIVATE AN IMAGE.
;	IF THE COMMAND LINE IS NULL, THE MCR IMAGE IS ACTIVATED.
;-
 
	.ENABL	LSB
DCL$MCR::				;EXECUTE THE MCR COMMAND
	BSBW	DCL$GETDVAL		;GET DECSRIPTOR VALUE
	MOVL	R1,R4			;COPY LENGTH OF STRING
	BNEQ	10$			;BR IF IMAGE NAME SUPPLIED
	MOVAB	MCRIMG,R2		;SET ADDRESS OF IMAGE NAME
SETIMGNAME:				;SET IMAGE NAME, DEFAULT, & EXECUTE IT
	MOVZBL	(R2)+,R1		;SET IMAGE NAME LENGTH
	BRB	SETIMGDEF		;GO SET DEFAULT AND EXECUTE IT
10$:	LOCC	#^A/ /,R1,(R2)		;FIND SPACE DELIMITER
	SUBL	R0,R4			;FIND LENGTH OF TOKEN
	LOCC	#^A/[/,R4,(R2)		;LOOK FOR A DIRECTORY
	BNEQ	20$			;BR IF DIRECTORY IN THE SPEC
	LOCC	#^A/</,R4,(R2)		;TRY OTHER SYNTAX
	BEQL	30$			;BR IF NO DIRECTORY FOUND
20$:	BBSS	#PRC_V_RUNDEF,PRC_B_FLAGS2(R11),30$ ;USE RUN DEFAULT
30$:	MOVL	R4,R1			;GET BYTE COUNT OF IMAGE TO RUN
	.DSABL	LSB

	.SBTTL	EXTERNAL COMMAND EXECUTION
;+
; DCL$EXTIMAGE - EXTERNAL COMMAND EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO INITIATE EXECUTION OF AN
; EXTERNAL IMAGE.
;
; INPUTS:
;
;	R1 = LENGTH OF IMAGE FILE SPECIFICATION.
;	R2 = ADDRESS OF IMAGE FILE SPECIFICATION.
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFED IMAGE IS INITIATED.
;-
 
DCL$EXTIMAGE::				;EXTERNAL COMMAND EXECUTION
SETIMGDEF:				;SET CORRECT DEFAULT FOR IMAGE
	BICW	#<PRC_M_DBGQUAL!PRC_M_DBGTRUE>,- ;CLEAR DEBUG QUALIFIER SEEN,
		PRC_W_FLAGS(R11)	;AND DEBUG QUALIFIER TRUE FLAGS.
	MOVAB	EXTDEFAULT,R3		;SET IMAGE DEFAULT FOR EXTERNAL IMAGE
	BBCC	#PRC_V_RUNDEF,PRC_B_FLAGS2(R11),FORCEXIT ;CORRECT DEFAULT?
SETRUNDEF:				;SET RUN DEFAULT FOR IMAGE
	MOVAB	RUNDEFAULT,R3		;SET IMAGE DEFAULT FOR RUN'S
;
; FORCE IMAGE EXIT IF ONE IS ACTIVE
;
; INPUTS:
;
;	R1 = LENGTH OF IMAGE FILE SPECIFICATION
;	R2 = ADDRESS OF IMAGE FILE SPECIFICATION
;	R3 = ADDRESS OF COUNTED ASCII STRING FOR DEFAULT FILE NAME
;
 
FORCEXIT:				;FORCE IMAGE EXIT
	BSBW	DCL$FORCEXIT		;

	.SBTTL	INITIATE IMAGE
;
; INITIATE AN IMAGE BY ENTERING USER MODE AND THEN SETTING UP THE INITIAL CALL
; FRAMES AND ESTABLISHING A CATCH-ALL CONDITION HANDLER.
;
; INPUTS:
;
;	R1 = LENGTH OF IMAGE FILE SPECIFICATION
;	R2 = ADDRESS OF IMAGE FILE SPECIFICATION
;	R3 = ADDRESS OF COUNTED ASCII STRING FOR DEFAULT FILE NAME
;
 
	.ENABL	LSB
INITIATE:				;INITIATE IMAGE
	BBSS	#PRC_V_EXIT,PRC_W_FLAGS(R11),10$ ;IF SET, EXIT HANDLER ESTABLISHED
	MOVAB	W^DCL$EXITHAND,PRC_L_EXTHND(R11) ;SET ADDRESS OF EXIT HANDLER
	MOVAB	PRC_L_EXTCOD(R11),PRC_L_EXTPRM(R11) ;SET ADDRESS OF REASON FOR EXIT
	PUSHL	R1			;REMEMBER LENGTH OF IMAGE FILE SPEC
	$DCLEXH_S PRC_L_EXTBLK(R11)	;DECLARE EXIT HANDLER
	MOVL	(SP)+,R1		;RESTORE LENGTH OF IMAGE FILE SPEC
	BLBS	R0,10$			;BRANCH IF SUCCESSFUL
	RSB				;RETURN IF ERROR
 
;
; SET UP IMAGE ADDRESS SPACE
;
 
10$:	MOVAL	G^MMG$IMGHDRBUF,R5	;ADDRESS TO RETURN IMAGE HEADER INFO
	MOVQ	R1,-(SP)		;PUT IMAGE NAME DSC ON STACK
	MOVL	SP,R1			;GET ADR OF FILNAM STRING DESCRIPTOR
	MOVZBL	(R3)+,R2		;GET SIZE OF DEFAULT NAME STRING
	MOVQ	R2,-(SP)		;PUT DEFAULT NAME DSC ON STACK
	MOVL	SP,R0			;GET ADR OF DFLTNAM STRING DESCRIPTOR
	$IMGACT_S -			;ACTIVATE THE IMAGE
		NAME=(R1),-		;ADDRESS OF FILE NAME DESCRIPTOR
		DFLNAM=(R0),-		;ADDRESS OF DEFAULT NAME DESCRIPTOR
		HDRBUF=(R5)		;ADDRESS OF IMAGE HEADER BUFFER
	BLBC	R0,11$			;BRANCH IF ACTIVATION ERROR
	ADDL	#16,SP			;CLEAN OFF IMGACT DESCRIPTORS
	BRW	30$			;AND GO ACTIVATE THE IMAGE
11$:	CLRQ	(SP)			;SET UP NULL RESULT NAME DESCRIPTOR
	MOVL	R0,R3			;SAVE STATUS
	$RUNDWN_S #PSL$C_USER		;RUN DOWN IMAGE
	CLRL	R4			;INIT NULL STV FROM FAB
	MOVL	8(R5),R5		;FAB ADDRESS OF ERROR IF ANY
	BEQL	14$			;BRANCH IF NONE PRESENT
	MOVL	FAB$L_FNA(R5),R2	;ORIGINAL FILE NAME ADDRESS
	BEQL	14$			;BRANCH IF FAB IS EMPTY
	MOVZBL	FAB$B_FNS(R5),R1	;SIZE OF ORIGINAL FILE NAME STRING
	MOVQ	R1,8(SP)		;USE THIS FOR ORIGINAL FILE NAME
	MOVL	FAB$L_STV(R5),R4	;GET FAB'S STV FIELD
	MOVL	FAB$L_NAM(R5),R0	;GET ADDRESS OF NAME BLOCK
	MOVL	NAM$L_RSA(R0),R2	;ADDRESS OF NAME STRING
	MOVZBL	NAM$B_RSL(R0),R1	;SIZE OF RESULT NAME STRING IF ANY
	BNEQ	12$			;BRANCH IF IT EXISTS
	MOVZBL	NAM$B_ESL(R0),R1	;EXPANDED NAME STRING SIZE IF ANY
	BEQL	14$			;BRANCH IF NO NAME TO OUTPUT
12$:	MOVQ	R1,(SP)			;RESULT/EXPANDED NAME STRING
14$:	MOVL	SP,R5			;R5 IS ADR OF NAME DESCRIPTORS
;
; 0(SP) = DESCRIPTOR FOR RESULT/EXPANDED FILE NAME
; 8(SP) = DESCRIPTOR FOR ORIGINAL FILE NAME
;
	MOVL	#CLI$_IMGNAME,R2	;ERROR CODE FOR 2ND MSG
	CMPL	#RMS$_FNF,R3		;IF ORIGINAL ERR IS FILE NOT FOUND
	BNEQ	16$
	CLRL	R3			;THEN 3RD MSG IS NULL
	MOVL	#CLI$_IMAGEFNF,R2	;AND 2ND IS "IMAGE FILE NOT FOUND"
;
; NOW BUILD THE PUTMSG ARGUMENT
;
16$:	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,R3,#1 ;IF THIS IS AN RMS ERROR CODE
	BNEQ	17$
	PUSHL	R4			;THEN USE SAVED STV FROM FAB
17$:	PUSHL	R3			;ERROR CODE FOR 3RD MSG
	TSTL	(R5)			;IF NO RESULT NAME STRING
	BNEQ	18$
	CMPL	#CLI$_IMGNAME,R2		;THEN SKIP THE IMAGE NAME MESSAGE
	BEQL	182$
18$:	PUSHAQ	(R5)			;ADR OF DESCRIPTOR FOR RSLT NAME
	PUSHL	#1			;ONE FAO ARGUMENT
	PUSHL	R2			;ERR CODE FOR 2ND MSG
182$:	PUSHAQ	8(R5)			;ADR OF DESCRIPTOR FOR ORIG NAME
	PUSHL	#1			;ONE FAO ARGUMENT
	PUSHL	#<SHR$_ACTIMAGE ! -	;ERR CODE FOR 1ST MSG
		<CLI$_IMGNAME & STS$M_FAC_NO>>
	SUBL3	SP,R5,-(SP)		;FORM SIZE OF ARG LIST IN BYTES
	DIVL	#4,(SP)			;ARG LIST SIZE IN LONG WORDS
;
; NOW OUTPUT THE ERROR MESSAGES
;
	MOVL	SP,R0			;ADDRESS OF PUTMSG PARAMETERS
	BSBW	DCL$PUTMSG		;CALL THE PUTMSG FACILITY
	ADDL3	#16,R5,SP		;POP ALL INFO OFF STACK
	MOVL	R3,R0			;GET ERROR CODE TO RETURN
	BNEQ	19$			;BRANCH IF THIS IS THE ONE
	MOVL	R2,R0			;ONLY 2 MESSAGES, USE THE 2ND
19$:	BBSS	#STS$V_INHIB_MSG,R0,20$	;INHIBIT ERROR MESSAGE OUTPUT
20$:	RSB				;RETURN WITH STATUS CODE IN R0
 
;
; RAISE ACCESS LEVEL TO USER
;
 
30$:
	MOVL	(R5),R1			;GET ADDRESS OF IMAGE HEADER
	CMPL	S^#SS$_NORMAL,R0	;IF OTHER THAN NORMAL COMPLETION
	BEQL	35$
	CMPL	#SS$_SYSVERDIF,R0	;"SYSTEM VERSION MISMATCH"?
	BNEQ	32$			;BRANCH IF NOT, JUST REPORT IT
	CMPW	#IHD$L_SYSVER,IHD$W_ACTIVOFF(R1) ;IF RELEASE 1 IMAGE
					;WITH NO SYSVER STORED IN HEADER
	BGEQ	35$			;THEN AVOID ISSUING SPURIOUS WARNING
32$:	PUSHR	#^M<R1,R5>		;SAVE REGISTERS REQUIRED BELOW
	BSBW	DCL$ERRORMSG		;PRINT ALTERNATE SUCCESS MESSAGE
	POPR	#^M<R1,R5>		;RESTORE SAVED REGISTERS
35$:
	BBC	#IHD$V_LNKNOTFR,-	;BRANCH IF TRANSFER ADDRESS PRESENT
		IHD$L_LNKFLAGS(R1),37$
	$RUNDWN_S #PSL$C_USER		;OTHERWISE RUN DOWN THE IMAGE
	MOVL	#CLI$_NOTFR,R0		;AND RETURN STATUS OF "NO TRANSFER ADDRESS"
	RSB
37$:	MOVL	4(R5),R0		;IMAGE FILE DESCRIPTOR BLOCK ADDRESS

	ASSUME	IFD$V_EXEONLY+1 EQ IFD$V_PRIV
	ASSUME	PRC_V_EXEONLY+1 EQ PRC_V_PRIV
	EXTZV	#IFD$V_EXEONLY,#2,IFD$W_FLAGS(R0),R0 ;GET "EXECUTE ONLY"
					;AND "PRIVILEGED IMAGE BITS"
	INSV	R0,#PRC_V_EXEONLY,#2,PRC_B_FLAGS2(R11) ;SAVE IN PROCESS FLAGS
	MOVL	SP,WRK_L_SAVSP(R10)	;SAVE CURRENT STACK POINTER
	ASHL	#PSL$V_PRVMOD,#PSL$C_USER@2+PSL$C_USER,-(SP) ;SET USER PSL
	PUSHAB	B^50$			;SET USER PC
DCL$LOW_LIMIT::				;LOW LIMIT OF CONTROL Y/C ADDRESS RANGE
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),40$ ;IF CLR, NO AST PENDING
	MOVQ	R0,-(SP)		;PUSH R0 AND R1
	MOVQ	#5,-(SP)		;PUSH #5 AND ZERO ASTPRM
	BRW	DCL$SCNTRLY		;SIMULATE A CONTROL Y
40$:	REI				;ENTER USER MODE
DCL$HIGH_LIMIT::			;HIGH LIMIT OF CONTROL Y/C ADDRESS RANGE
 
;
; BUILD TOP LEVEL CALL FRAME
;
 
50$:	CLRQ	AP			;CLEAR INITIAL ARGUMENT AND FRAME POINTERS
	CALLS	#0,B^60$		;CONSTRUCT TOP LEVEL CALL FRAME
 
;
; ESTABLISH CATCH-ALL CONDITION HANDLER AND CALL IMAGE
;
 
60$:	.WORD	0			;ENTRY MASK
	MOVAB	G^EXE$CATCH_ALL,(FP)	;ESTABLISH CATCH-ALL HANDLER
	$SETEXV_S #2,G^EXE$CATCH_ALL	;ESTABLISH LAST CHANCE HANDLER
	$IMGFIX_S			;PERFORM ADDRESS RELOCATION
	BLBC	R0,110$
	MOVQ	G^MMG$IMGHDRBUF,R4	;GET IMAGE HEADER DESCRIPTOR
 
	ASSUME	CLI$V_DEBUG   EQ 0
	ASSUME	CLI$V_DBGTRU  EQ 1
	ASSUME	PRC_V_DBGTRUE EQ PRC_V_DBGQUAL+1
 
	EXTZV	#PRC_V_DBGQUAL,#2,-	;BUILD PROTOTYPE CLI OPTIONS VALUE BY
		PRC_W_FLAGS(R11),-(SP)	;GETTING THE DEBUG QUALIFIER AND STATE
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),70$ ;BR IF NOT A BATCH JOB
	SETBIT	CLI$V_BATCH,(SP)	;OR IN THE BATCH BIT IF THIS IS BATCH
70$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),80$ ;BR IF VERIFY IS CLEAR
	SETBIT	CLI$V_VERIFY,(SP)	;PROPOGATE VERIFY IF TRUE
80$:	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	90$			;IF EQL YES
	SETBIT	CLI$V_INDIRECT,(SP)	;PASS INDIRECT NON ZERO FLAG
90$:	BITB	#<CLI$M_INDIRECT!CLI$M_BATCH>,(SP) ;COMMANDS COMING FROM FILE?
	BEQL	100$			;BR IF TERMINAL JOB
	BBC	#CLI$V_VERIFY,(SP),100$	;BR IF VERIFY NOT REQUESTED
	SETBIT	CLI$V_VFYINP,(SP)	;INDICATE INPUT VERIFY IS NEEDED
100$:	PUSHL	IHD$L_LNKFLAGS(R4)	;PASS LINKTIME OPTION FLAGS
	MOVQ	R4,-(SP)		;NEXT TWO PARAMETERS IN USER FRAME
	PUSHAB	W^DCL$UTLSERV		;SET ADDRESS OF UTILITY ROUTINE DISPATCHER
	MOVZWL	IHD$W_ACTIVOFF(R4),R0	;OFFSET TO ACTIVATION DATA (TRANSFER VECTORS)
	ADDL	R4,R0			;ADDRESS OF TRANSFER VECTOR ARRAY
	PUSHAL	(R0)			;ADDRESS OF TRANSFER VECTOR ARRAY
	CALLS	#6,@(R0)+		;CALL IMAGE ENTRY POINT
110$:	JMP	G^EXE$EXIT_IMAGE	;
	.DSABL	LSB

	.SBTTL	DCL$FORCEXIT - FORCE IMAGE EXIT
;+
; FORCE IMAGE EXIT IF ONE IS ACTIVE
;
; INPUTS:
;
;	R2 = POSSIBLE ADDRESS OF ITEM ON STACK
;
; OUTPUTS:
;
;	R2 = RELOCATED ADDRESS IF STACK IS SHUFFLED
;	R0 ALTERED, R1, R3 PRESERVED
;-
 
DCL$FORCEXIT::				;FORCE IMAGE EXIT
	MOVL	SP,R0			;SAVE SP ADR IN ORDER TO DETECT A SHUFFLE
	PUSHR	#^M<R0,R1,R2,R3>	;SAVE NAME STRING PARAMETERS
	BSBW	DCL$RUNDOWN		;RUN DOWN PREVIOUS IMAGE AND INDIRECT LEVELS
	POPR	#^M<R0,R1,R2,R3>	;RESTORE NAME STRING PARAMETERS
	CMPL	R0,SP			;WAS THE STACK SHUFFLED?
	BEQL	10$			;BRANCH IF NOT
	CMPL	R2,R0			;WAS NAME STRING ON THE STACK?
	BLSSU	10$			;BRANCH IF NOT
	SUBL	R0,R2			;ADJUST THE ADDRESS
	ADDL	SP,R2			;TO REFLECT THE SHUFFLE
10$:	RSB

	.SBTTL	ALLOCATE BUFFER AND BUILD DESCRIPTOR
;+
; DCL$ALLOCBUF - ALLOCATE BUFFER AND BUILD DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO ALLOCATE A MESSAGE BUFFER ON THE STACK AND BUILD
; A BUFFER DESCRIPTOR FOR THE BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	A MESSAGE BUFFER IS ALLOCATED ON THE STACK.
;
;	R2 = ADDRESS OF BUFFER DESCRIPTOR.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
DCL$ALLOCBUF::				;ALLOCATE BUFFER AND BUILD DESCRIPTOR
	POPR	#^M<R0>			;SAVE RETURN ADDRESS
	MOVAB	-WRK_C_MSGBUFSIZ(SP),SP	;ALLOCATE SPACE TO STORE FORMAT STRING
	PUSHAB	(SP)			;BUILD OUTPUT BUFFER DESCRIPTOR
	MOVZBL	#WRK_C_MSGBUFSIZ,-(SP)	;
	MOVL	SP,R2			;COPY ADDRESS OF OUTPUT BUFFER DESCRIPTOR
	JMP	(R0)			;

	.SBTTL	COMMAND INTERPRETER EXIT HANDLER
;+
; DCL$EXITHAND - COMMAND INTERPRETER EXIT HANDLER
;
; THIS ROUTINE IS ENTERED WHEN A PREVIOUSLY INITIATED IMAGE EXITS. ITS FUNC-
; TION IS TO CLEAN UP THE STACK, SHUTDOWN THE IMAGE, AND RETURN CONTROL TO THE
; ADDRESS SPECIFIED BY THE TOP LONGWORD OF THE STACK.
;
; INPUTS:
;
;	@4(AP) = REASON FOR EXIT.
;
; OUTPUTS:
;
;	THE SAVED FRAME POINTER IS RESTORED, THE STACK IS CLEANED UP, IMAGE
;	SHUT DOWN IS PERFORMED,  AND CONTROL IS RETURNED TO THE ADDRESS SPECIFIED
;	BY THE TOP LONGWORD OF THE STACK.
;
;	R0 = REASON FOR EXIT.
;-
 
	.ENTRY	DCL$EXITHAND,^M<>

	BSBW	CLI$GET_PRC		;GET ADDRESS OF CLI WORK AREA
	BICW	#PRC_M_EXIT,PRC_W_FLAGS(R11) ;CLEAR EXIT HANDLER ESTABLISHED
	MOVL	PRC_L_SAVFP(R11),FP	;RESTORE SAVED FRAME POINTER
	MOVL	FP,R10			;AND RESTORE WRK ADDRESS
;
; ISSUE ERROR MESSAGE (IF ANY) RETURNED BY IMAGE IN R0
;
10$:	MOVL	@4(AP),R0		;RETRIEVE FINAL EXIT STATUS
	BLBS	R0,20$			;BRANCH IF SUCCESSFUL
	CMPL	R0,#SS$_CLIFRCEXT	;NEVER ISSUE CLI FORCED EXIT MESSAGE
	BEQL	20$			;IF IMPLIED IMAGE RUNDOWN
	BSBW	DCL$ERRORMSG		;ISSUE ERROR MESSAGE USING PER-IMAGE
					;MESSAGES IF PRESENT
;
; RUNDOWN ALL RMS FILES AND FLUSH ANY DATA RECORDS
;
20$:	BSBW	DCL$SHUTDOWN		;SHUT DOWN IMAGE
	TSTL	R2			;ANY DATA RECORDS SKIPPED?
	BEQL	30$			;IF EQL NO
	STATUS	SKPDAT			;SET SKIPPED DATA STATUS
	BSBW	DCL$ERRORMSG		;OUTPUT ERROR MESSAGE
;
; ZERO COMMAND INTERPRETER COMMAND POINTERS
;
30$:	CLRL	G^CTL$GL_CLINTOWN	;ZERO CLINT OWN STORAGE POINTER
	CLRL	G^CTL$GL_DCLPRSOWN	;ZERO DCL PARSE OWN STORAGE
;
; RUNDOWN THE IMAGE
;
	$RUNDWN_S  #PSL$C_USER		;RUN DOWN THE IMAGE
	BICB	#<PRC_M_EXEONLY ! PRC_M_PRIV>,PRC_B_FLAGS2(R11)
					;RESET "EXECUTE ONLY" AND
					;"PRIVILEGED" IMAGE BITS
;
; RESTORE STACK POINTER TO SP SAVED ON THE ACTIVATE CALL
;
	MOVL	WRK_L_SAVSP(R10),SP	;RESTORE SAVED STACK POINTER
;
; SET THE FINAL RETURN STATUS IN $STATUS AND TAKE ANY ON CONDITION
;
	MOVL	@4(AP),R0		;GET FINAL IMAGE STATUS
	BLBS	R0,40$			;BRANCH IF SUCCESSFUL
	CMPL	R0,#SS$_CLIFRCEXT	;NEVER SET IMPLIED IMAGE RUNDOWN STATUS
	BEQL	50$			;BRANCH IF FORCED EXIT
40$:	BSBW	DCL$SET_STATUS		;SET $STATUS AND TAKE ON CONDITION
					;NOTE: WILL NOT RETURN IF ON CONDITION
;
; SET STATUS TO SUCCESS AND SET NOSTAT BIT TO INDICATE STATUS ALREADY SET
;
50$:	SETBIT	#WRK_V_NOSTAT,WRK_W_FLAGS(R10) ;INDICATE STATUS ALREADY SAVED
	MOVL	#1,R0			;AND SET SUCCESSFUL
	RSB				;RETURN TO CALLER (COMMAND OR RUNDOWN)
 
	.END
