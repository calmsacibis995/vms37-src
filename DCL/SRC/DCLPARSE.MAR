	.TITLE	DCLPARSE - PARSE A DCL COMMAND
	.IDENT	'V03-008'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; AUTHOR: TIM HALVORSEN, NOV 1980
;
; MODIFIED BY:
;
;	V008	PCG0006		Peter George	16-Mar-1982
;		Correct signs on some instances of WRK_K_LENGTH.
;
;	V007	PCG0005		Peter George	17-Feb-1982
;		Use WRK_G_DCLPRSBUF instead of WRK_G_INPBUF.
;
;	V006	PCG0004		Peter George	25-Jan-1982
;		Share DCL$SEARCH_VERB with COMMAND.MAR.
;
;	V005	PCG0003		Peter George	19-Jan-1982
;		Handle structure level 5 tables - .ADDRESS routine addresses.
;
;	V004	TMH0004		Tim Halvorsen	02-Jan-1982
;		Replace references to CLIPRSENT and CLICHRMAN modules
;		to corresponding routines in PARSENT and CHARMANIP modules,
;		to avoid having to maintain both modules, when they are
;		almost the same thing.
;		Initialize CMDOPT cell.
;
;	V003	PCG0002		Peter George	05-Nov-1981
;		Add $SSDEF and $CLIDEF macro calls.
;		Change DCL$ERRORMSG back to LIB$SIGNAL.
;
;	V002	PCG0001		Peter George	30-Oct-1981
;		Remove this routine from the CLE and integrate it
;		within the DCL callback mechanism.  Expect parameters in
;		callback format.  Dynamically allocate and/or deallocate
;		user mode work area and clint own storage.  Use DCL$ERRORMSG
;		in place of LIB$SIGNAL.  Use user supplied routine addresses
;		in place of LIB$GET_VM and LIB$FREE_VM.  Change psect name
;		from CLI$CODE to DCL$ZCODE.
;
;	V001	TMH0001		Tim Halvorsen	09-Aug-1981
;		Accept structure level 3 tables as well as level 2.
;		Level 3 is the same, except that the pointer table
;		is longword offsets rather than word offsets.
;--

;
; MACRO LIBRARY CALLS
;
 
	DCLDEF				; DEFINE CLINT OWN STORAGE AREA
	VECDEF				; DEFINE TABLE VECTOR
	CMDDEF				; COMMAND DESCRIPTOR BLOCK
	ENTDEF				; ENTITY DESCRIPTOR BLOCK
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	SYMDEF				; DEFINE SYMBOL ENTRY OFFSETS
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	$SSDEF				; DEFINE SYSTEM MESSAGES
	$CLIDEF				; CLI DEFINITIONS
	$CLIMSGDEF			; DEFINE ERROR/STATUS VALUES
	$STSDEF				; DEFINE STATUS CODE FIELDS
	$DEVDEF				; DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				; DEFINE RAB OFFSETS

CTRLZ	= 26				; CONTROL/Z CHARACTER

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

NORMAL_PROMPT:
	.ASCIC	'$ '			; DEFAULT PROMPT STRING
HYPHEN:
	.ASCII	'-'<0>			; HYPHEN STRING

	.SBTTL	PARSE A DCL COMMAND
;+
; DCL$DCLPARSE - PARSE A DCL COMMAND STRING
;
; THIS ROUTINE PARSES A DCL COMMAND STRING GIVEN THE ADDRESS OF THE COMMAND
; TABLES WHICH DESCRIBE THE SYNTAX OF THE COMMAND SET.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF REQUEST DESCRIPTOR 
;
; OUTPUTS:
;
;	NONE
;-

	.ENTRY	DCL$DCLPARSE,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVAL	G^CTL$GL_DCLPRSOWN,R2	;GET ADDRESS OF WRK POINTER

	MOVL 	4(AP),R11		;GET ADDRESS OF REQUEST DESCRIPTOR
	TSTL	CLI$A_RQADDR(R11)	;COMMAND STRING SPECIFIED?
	BNEQ	15$			;YES, THEN BRANCH

;
; IF NO COMMAND STRING IS SPECIFIED, THEN CAUSE ALL SUBSEQUENT
; INTERFACE REQUESTS TO REFER TO THE ALREADY PARSED ORIGINAL
; COMMAND LINE.  THIS IS DONE BY DEALLOCATING THE USER MODE
; WRK BLOCK, DEALLOCATING THE CLINT OWN STORAGE, AND ZEROING THE 
; POINTERS TO BOTH OF THESE AREAS, CAUSING THE INTERFACE ROUTINES
; TO BE REINITIALIZED WITH THE THE SUPERVISOR MODE WRK BLOCK.
;

	TSTL	(R2)			;WRK BLOCK ALLOCATED?
	BEQL	5$			;NO, THEN BRANCH
	PROBEW	#PSL$C_USER,-		;USER WRITABLE?
		#-WRK_K_LENGTH,WRK_K_LENGTH(R2)
	BNEQ	3$			;NO, THEN BRANCH
					;YES, THEN DEALLOCATE
	PUSHL	#-WRK_K_LENGTH		;LENGTH OF LOCAL WRK BLOCK
	PUSHL	R2			;ADDRESS OF LONGWORD CONTAINING ADDRESS
	PUSHAL	4(SP)			;ADDRESS OF WORD CONTAINING LENGTH
	CALLS	#2,@CLI$A_ABSACT(R11)	;DEALLOCATE WRK BLOCK
	MOVL	(SP)+,R0		;RESTORE THE STACK	
3$:	CLRL	(R2)			;INDICATE BLOCK NO LONGER EXISTS

;
; IF CLINT OWN STORAGE IS ALLOCATED, THEN FREE IT SO THAT SUBSEQUENT 
; INTERFACE REQUESTS CAUSE THE OWN STORAGE TO BE REINITIALIZED.
;

5$:	MOVAL	G^CTL$GL_CLINTOWN,R2	;GET ADDRESS OF CLINT OWN POINTER
	TSTL	(R2)			;CLINT OWN STORAGE ALLOCATED?
	BEQL	10$			;NO, THEN BRANCH
					;YES, THEN DEALLOCATE
	PUSHL	#DCL_C_SIZE		;LENGTH OF CLINT OWN STORAGE
	PUSHL	R2			;ADDRESS OF LONGWORD CONTAINING ADDRESS
	PUSHAL	4(SP)			;ADDRESS OF WORD CONTAINING LENGTH
	CALLS	#2,@CLI$A_ABSACT(R11)	;DEALLOCATE CLINT OWN STORAGE
	CLRL	(R2)			;INDICATE STORAGE NO LONGER EXISTS
	MOVL	(SP)+,R0		;RESTORE THE STACK	

10$:	STATUS	NORMAL			;RETURN SUCCESSFUL
	RET
	
;
; IF NO USER MODE WORK AREA HAS BEEN ALLOCATED BEFORE, THEN ALLOCATE 
; AND INITIALIZE ONE NOW.
;

15$:	MOVL	(R2),R10		;LOCAL WRK BLOCK ALLOCATED?
	BEQL	17$			;NO, THEN BRANCH
	PROBEW	#PSL$C_USER,-		;USER WRITABLE?
		#-WRK_K_LENGTH,WRK_K_LENGTH(R2)
	BEQL	20$			;YES, THEN BRANCH
					;NO, THEN ALLOCATE
17$:	PUSHL	#-WRK_K_LENGTH		;LENGTH TO ALLOCATE
	PUSHL	SP			;PLACE TO RETURN ADDRESS
	PUSHAL	4(SP)			;ADDRESS OF LONGWORD CONTAINING LENGTH
	CALLS	#2,@CLI$A_PRSACT(R11)	;ALLOCATE DYNAMIC MEMORY
	BLBS	R0,18$			;BRANCH IF OK
	BRW	90$			;BRANCH IF ERROR
18$:	ADDL3	(SP)+,#-WRK_K_LENGTH,(R2);COMPUTE ENDING ADDRESS OF WORK AREA
	MOVL	(R2),R10		;GET ADDRESS OF PARSING WORK AREA
	CLRL	WRK_L_READRTN(R10)	;SET NO CONTINUATION INPUT
	CLRL	WRK_L_SPECRTN(R10)	;AND NO SPECIAL CHARACTER PROCESSING
	MOVAB	ERROR,WRK_L_ERRORRTN(R10) ;SET ADDRESS OF ERROR HANDLER

;
; IF CLINT OWN STORAGE IS ALLOCATED, THEN FREE IT SO THAT SUBSEQUENT 
; INTERFACE REQUESTS CAUSE THE OWN STORAGE TO BE REINITIALIZED.
;

20$:	MOVAL	G^CTL$GL_CLINTOWN,R2	;GET ADDRESS OF CLINT OWN POINTER
	TSTL	(R2)			;CLINT OWN STORAGE ALLOCATED?
	BEQL	30$			;NO, THEN BRANCH
					;YES, THEN DEALLOCATE
	PUSHL	#DCL_C_SIZE		;LENGTH OF CLINT OWN STORAGE
	PUSHL	R2			;ADDRESS OF LONGWORD CONTAINING ADDRESS
	PUSHAL	4(SP)			;ADDRESS OF WORD CONTAINING LENGTH
	CALLS	#2,@CLI$A_ABSACT(R11)	;DEALLOCATE CLINT OWN STORAGE
	CLRL	(R2)			;INDICATE STORAGE NO LONGER EXISTS
	MOVL	(SP)+,R0		;RESTORE THE STACK	

;
; FILL IN MORE WRK AREA FIELDS
;

30$:	MOVAB	NORMAL_PROMPT,WRK_L_PROMPT(R10) ;SET ADDRESS OF PROMPT STRING
	MOVAB	WRK_G_BUFFER(R10),WRK_L_EXPANDPTR(R10) ;SET ADDRESS OF EXPANSION BUFFER
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;SET ADDRESS OF RESULT PARSE TABLE
	CLRW	WRK_W_FLAGS(R10)		;RESET COMMAND FLAGS

;
; COPY INPUT STRING INTO SCRATCH AREA
;
	MOVQ	@CLI$A_RQADDR(R11),R0	;GET DESCRIPTOR
	CMPW	R0,#WRK_C_DCLBUFSIZ	;CHECK IF TOO BIG FOR INPUT BUFFER
	BGTRU	40$			;BRANCH IF STRING IS TOO BIG
	MOVAB	WRK_G_DCLPRSBUF-1(R10),WRK_L_CHARPTR(R10) ;SET INPUT STRING POINTER
	MOVC	R0,(R1),WRK_G_DCLPRSBUF(R10) ;COPY STRING INTO INPUT BUFFER
	CLRB	(R3)			;PUT NULL STOPPER AS END-OF-LINE
;
; GET FIRST TOKEN FROM COMMAND LINE
;
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$GETOKEN		;GET COMMAND VERB
	BEQL	50$			;IF NONE, RETURN ERROR
	MOVL	CLI$A_ERRACT(R11),R8	;GET ADDRESS OF COMMAND TABLES
	BSBW	DCL$SEARCH_VERB		;SEARCH VERB TABLE FOR VERB
	BLBC	R0,90$			;BRANCH IF ERROR
	BRB	PARSE_VERB_QUALS

40$:	MOVZWL	#SS$_BUFFEROVF,R0	;INPUT STRING IS TOO BIG
	BRB	90$

50$:	STATUS	NOCOMD			;SET NO COMMAND STATUS
90$:	BRW	EXIT

;
; PROCESS COMMAND QUALIFIERS
;

PARSE_VERB_QUALS:
	BISW	#WRK_M_VERB,WRK_W_FLAGS(R10) ;SET VERB PROCESSING FLAG
;
; TREAT FIRST VERB QUALIFIER AS AN KEYWORD IF P1 ACTUALLY TAKES A KEYWORD
; (E.G. SET/TERMINAL -> SET TERMINAL)
;
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A'/',R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	MOVL	WRK_L_PROPTR(R10),R1	;GET ADDRESS OF P1 DESCRIPTOR
	BEQL	PARSE_QUAL		;BR IF NO PROMPT DESCRIPTOR
	TSTW	ENT_W_KEYWORDS(R1)	;IS P1 TAKE A KEYWORD VALUE?
	BEQL	PARSE_QUAL		;IF NOT, PROCESS AS QUALIFIER
	MOVL	WRK_L_CHARPTR(R10),R0	;GET CURRENT CHARACTER POINTER
	MOVB	#^A' ',1(R0)		;SET QUALIFIER SLASH TO A BLANK
	BRB	PARSE_PARMS		;PROCESS AS PARAMETER

;
; PROCESS ALL LEADING QUALIFIERS
;

PARSE_QUAL:
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A'/',R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$PROCQUAL		;PROCESS QUALIFIER
	BLBS	R0,PARSE_QUAL		;IF LBS SUCCESSFUL COMPLETION
	BRW	EXIT

;
; PROCESS COMMAND PARAMETERS
;

PARSE_PARMS:
	BICW	#WRK_M_VERB,WRK_W_FLAGS(R10) ;CLEAR VERB PROCESSING
150$:	MOVL	WRK_L_PROPTR(R10),R8	;GET ADDRESS OF P1 DESCRIPTOR
	MOVL	WRK_L_PARMCNT(R10),R0	;GET PARAMETER # BEING PARSED
	BEQL	155$			;BRANCH IF NO LOOP NEEDED
152$:	MOVZBL	ENT_B_NEXT(R8),R1	;GET OFFSET TO NEXT DESCRIPTOR
	ADDL	R1,R8			;SKIP TO NEXT ENTITY DESCRIPTOR
	SOBGTR	R0,152$			;LOOP UNTIL PARAMETER FOUND
155$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BEQL	END_OF_LINE		;IF EQL END OF LINE
	CMPB	#^A' ',R0		;BLANK?
	BNEQ	230$			;IF NEQ NO
160$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	TSTL	WRK_L_MAXPARM(R10)	;PARAMETERS ALLOWED ON THIS COMMAND?
	BEQL	200$			;BR IF NONE ALLOWED
	TSTW	ENT_W_KEYWORDS(R8)	;DOES PARAMETER TAKE KEYWORD VALUE?
	BNEQ	180$			;IF SO, PROCESS AS QUALIFIER
	MOVZBL	#PTR_K_PARAMETR,R3	;SET CLASSIFICATION OF VALUE STRING
	BSBW	DCL$PARSE_VALUE		;PROCESS PARAMETER VALUE
170$:	BLBC	R0,260$			;IF LBC PARSE ERROR
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A'/',R0		;QUALIFIER?
	BNEQ	190$			;IF NEQ NO
180$:	BSBW	DCL$PROCQUAL		;PROCESS QUALIFIER
	BRB	170$			;
190$:	CMPB	#^A',',R0		;MULTIPLE PARAMETERS?
	BEQL	210$			;IF EQL YES
	CMPB	#^A'+',R0		;CONCATENATED PARAMETERS?
	BEQL	220$			;IF EQL YES
	TSTW	ENT_W_KEYWORDS(R8)	;DOES PARAMETER TAKE KEYWORD VALUE?
	BNEQ	150$			;IF SO, PARAMETER TREATED AS QUALIFIER
	INCL	WRK_L_PARMCNT(R10)	;INCREMENT COUNT OF PARAMETERS
	CMPL	WRK_L_PARMCNT(R10),WRK_L_MAXPARM(R10) ;MAXIMUM PARAMETERS EXCEEDED?
	BGTR	200$			;BR IF YES
	BRB	150$			;
 
;
; MAXIMUM PARAMETER COUNT EXCEEDED
;
 
200$:	STATUS	MAXPARM			;ASSUME MAXIMUM PARAMETERS EXCEEDED
260$:	BRW	EXIT
 
;
; PARAMETER LIST SPECIFIED
;
 
210$:	BBS	#ENT_V_LIST,ENT_L_FLAGS(R8),160$ ;IF SET, LISTS ALLOWED
	STATUS	NOLIST			;SET NO LISTS ALLOWED STATUS
	BRB	260$
 
;
; PARAMETER CONCATENATION SPECIFIED
;
 
220$:	BBS	#ENT_V_CONCAT,ENT_L_FLAGS(R8),160$ ;IF SET, CONCATENATION ALLOWED
	STATUS	NOCCAT			;SET NO CONCATENATION ALLOWED STATUS
	BRB	260$
 
;
; INVALID PARAMETER DELIMITER
;
 
230$:	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
	BRB	260$
 
;
; ALL COMMAND INPUT PROCESSED - CHECK FOR SUFFICIENT PARAMETERS
;
 
END_OF_LINE:
	BBSS	#WRK_V_PROMPT,WRK_W_FLAGS(R10),PROMPT ;IF SET ALREADY PROMPTING
	CMPL	WRK_L_PARMCNT(R10),WRK_L_MINPARM(R10) ;SUFFICIENT PARAMETERS?
	BGEQ	NORMAL_EXIT		;IF GEQ YES
 
;
; PROMPT FOR ADDITIONAL PARAMETERS
;
 
PROMPT:
	CMPL	WRK_L_PARMCNT(R10),WRK_L_MAXPARM(R10) ;ALL PARAMETERS PROCESSED?
	BGEQ	NORMAL_EXIT		;IF GEQ YES
;&&& PERFORM PROMPTING HERE
;	BLBC	R0,250$			;EXIT IF ANY ERROR
;	BSBW	DCL$SETCHAR		;SET TO FIRST CHARACTER
;	TSTB	R0			;CHECK FIRST CHARACTER
;	BEQL	300$			;IF EQL NULL LINE
;	CMPB	R0,#CTRLZ		;CONTROL/Z?
;	BEQL	NORMAL_EXIT		;CONTROL/Z TYPED - EXIT SUCCESSFUL
;	CMPB	R0,#^A'/'		;LEADING QUALIFIER?
;	BNEQ	295$			;BRANCH IF NOT
;	BRW	PARSE_QUAL		;PROCESS PARAMETER QUALIFIER(S)
;295$:	MOVB	#^A' ',@WRK_L_CHARPTR(R10) ;INSERT BLANK AT FRONT OF BUFFER
;	DECL	WRK_L_CHARPTR(R10)	;BACK UP CHARACTER POINTER
;	BRW	PARSE_PARMS		;PROCESS PARAMETER
;
;300$:	BBS	#ENT_V_VALREQ,ENT_L_FLAGS(R8),PROMPT ;IF SET, PARAMETER REQUIRED
;	BRB	NORMAL_EXIT		;ELSE, SKIP OPTIONAL PARAMETER PROMPT
; 
250$:	CMPL	WRK_L_PARMCNT(R10),WRK_L_MINPARM(R10) ;SUFFICIENT PARAMETERS?
	BGEQ	NORMAL_EXIT		;IF GEQ YES
	STATUS	INSFPRM			;SET INSUFFICIENT PARAMETERS
	BRB	EXIT

NORMAL_EXIT:
	STATUS	NORMAL
EXIT:
	PUSHL	R0			;SAVE RETURN STATUS
	MOVZBL	#PTR_K_ENDLINE,R5	;SET ITEM TYPE TO END OF LINE
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#1,R7			;SET LENGTH OF ITEM
	MOVL	WRK_L_EXPANDPTR(R10),R8	;SET STARTING ADDRESS OF ITEM
	BSBW	DCL$GENDESCR		;GENERATE END-OF-LINE TOKEN
	POPL	R0			;RESTORE RETURN STATUS
;
;	CONVERT INTERNAL STATUS CODES (NEGATIVE NUMBERS) TO STANDARD
;	VMS STATUS CODES SO THAT THEY CAN BE RECOGNIZED.
;
	BGEQ	10$			;BRANCH IF NORMAL STATUS LONGWORD
	MNEGL	R0,R0			;GET POSITIVE NUMBER
	ASHL	#2,R0,R0		;SHIFT INTO PROPER POSITION
	BISL	#<CLI$_ABKEYW&<STS$M_FAC_NO!STS$M_FAC_SP>>,R0 ;INSERT FACNUM
10$:	BLBS	R0,90$			;BRANCH IF SUCCESSFUL
	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	CALLS	#1,G^LIB$SIGNAL		;SIGNAL THE ERROR
90$:	RET

;
; HANDLE ERRORS DETECTED BY THE CHARACTER INPUT ROUTINES
;

ERROR:	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	CALLS	#1,G^LIB$SIGNAL		;SIGNAL THE ERROR
	RET				;RETURN TO CALLER

	.END
