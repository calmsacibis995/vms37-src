	.TITLE	CHARMANIP - CHARACTER MANIPULATION ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; CHARACTER MANIPULATION ROUTINES
;
; D. N. CUTLER 28-MAR-77
;
; MODIFIED BY:
;
;	V017	TMH0017		Tim Halvorsen	07-Jan-1982
;		Move DCL$COMPSTRING routine here from DESCRVAL module
;		for the benefit of those standalone programs which use
;		this module with the DCL sub-command parsing module.
;		Do not call DCL$ERRORMSG from this module, but instead
;		do the work in the WRK_L_ERRORRTN routine, to make this
;		routine independant of external signalling mechanisms.
;
;	V016	TMH0016		Tim Halvorsen	02-Jan-1982
;		Replace all processing of @, & and reading an input
;		record with calls to routines specified in the WRK
;		block.  This allows more than one type of parsing to
;		use these routines in a flexible way.
;
;	V015	TMH0015		Tim Halvorsen	22-Dec-1981
;		Fix automatic logout, so that it is checked just after
;		an EOF from a procedure file.
;		Add support for silent logout on level 0 EOF (rather than
;		normal transfer of control to the LOGOUT image).
;		Use $EXIT service to perform silent logout, rather than
;		$DELPRC, so that final status is passed back.
;
;	V014	TMH0014		Tim Halvorsen	21-Dec-1981
;		In the event that a CTRL/Y AST interrupts while a write
;		to the terminal is in progress, it is possible to get to
;		the $GET for the prompt before the write completes (for
;		especially long lines).  In this case, we do not want to
;		perform a CANCEL to blow away the RMS write in progress,
;		but instead, want to spin for a while to allow the write
;		to complete.  This prevents "abort" errors from being
;		signalled by programs such as TYPE when a CTRL/Y interrupts
;		a write and we cancel it in order to put out the prompt.
;		The change made here causes the $GET to be retried 10 times
;		before attempting the cancel, to allow normal I/O's to
;		complete, and yet still cancel anything which is hung up.
;		If one of the retries indicates that RMS "came ready" while
;		we were spinning, then we proceed as if the delay never
;		happened.
;
;	V013	TMH0013		Tim Halvorsen	21-Dec-1981
;		Gobble trailing apostrophe when there is no symbol following
;		the initial apostrophe.  This has the effect of making two
;		substitution apostrophes next to each other a no-op.
;		This was broken in TMH0005.
;
;	V012	TMH0012		Tim Halvorsen	16-Nov-1981
;		Perform implied automatic logout using $DELPRC if the
;		AUTOLOGO flag is set when attempting to read from the
;		level 0 input stream.
;
;	V011	TMH0011		Tim Halvorsen	29-Oct-1981
;		Do not execute any lexical functions except F$VERIFY
;		within comments.  F$VERIFY is excluded from this check
;		solely because a number of users have already made use
;		of the statement "$ ! 'F$VERIFY(0)'" to turn off verify
;		mode silently.
;
;	V010	MTR0010		Mike Rhodes	08-Jul-1981
;		Reset prompt string when returning to level 0.
;
;	V009	TMH0009		Tim Halvorsen	28-May-1981
;		Limit size of prompt string (from INQUIRE command)
;		to size of buffer allocated on stack.
;
;	V008	TMH0008		Tim Halvorsen	27-Apr-1981
;		Make use of PRC_L_INDEPTH to determine if level 0 or not.
;
;	V007	TMH0007		Tim Halvorsen	20-Mar-1981
;		Add DCL$GENTERM routine to set the terminal class
;		in the previous token descriptor.
;		Fix symbol substitution to re-disable continuations
;		after lexical function but before gobbling the trailing
;		quote, to remain compatible with procedures which do a
;		substitution (w/o trailing quote) just before continuation.
;
;	V006	TMH0006		Tim Halvorsen	15-Mar-1981
;		Exit from comment/null-line optimization if
;		control/y has been hit.
;
;	V005	TMH0005		Tim Halvorsen	06-Feb-1981
;		Do not issue errors during substitutions in comment strings.
;		Disallow upcasing in symbol expansion when in quoted strings.
;		Use WRK_L_MARKPTR rather than R6 as error display pointer.
;		Use WRK_L_EXPANDPTR rather than R9.
;		Add DCL$BACKUPCHAR, DCL$BACKUPMOVE routines.
;		Add DCL$MARK and DCL$MARKEDTOKEN routines.
;		Accept '*' as a terminator for substitution tokens.
;		Use R10 rather than FP as WRK address.
;		Allow continuations within lexical function arguments.
;		Call SYM_STRING rather than SEARCH for symbol strings.
;		Add DCL$COMPRESS routine
;		As an optimization, while in GOTO mode, skip all lines
;		which don't have any colons in them and don't perform
;		symbol substitution.
;		Do not report errors from DCL$UNSTACK as they are already
;		signaled before returning to the caller.
;
;	V004	TMH0004		Tim Halvorsen	03-Feb-1981
;		Avoid destruction of quote flag during a SETCHAR (peek)
;		so that it can be called during a quoted string for the
;		symbol substitution pass.  Fix symbol substitution pass
;		to clear quote flag before doing a GETOKEN in within a
;		string, or else GETOKEN won't stop until end of string.
;		Fix EXPAND to use SETCHAR rather than doing its own backup.
;		Prevent null character from appearing at the end of
;		lines which are written to the verification log.
;		Add a flag to prevent processing of special characters
;		(continuation,indirection,comment,spaces,tabs) while in
;		the symbol substitution pass.
;		Add a flag to prevent upcasing in GETCHAR so that it can
;		be set while transferring normal characters, but to allow
;		upcasing during symbol and function processing.
;
;	V003	TMH0003		Tim Halvorsen	11-Jan-1981
;		Use standard GETOKEN routine during input record
;		symbol substitution pass.
;
;	V002	TMH0002		Tim Halvorsen	19-Sep-1980
;		Fix access violation when attempting to signal RSL buffer
;		overflow.
;
;	V001	TMH0001		Tim Halvorsen	26-Aug-1980
;		Use WRK_L_RSLNXT as input to GENDESCR rather than R10
;		Convert to MDL structures.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

DCL$HYPHEN::				;HYPHEN STRING
	.ASCII	/-/<0>			;
TERMCLASS:				;ITEM TERMINATOR STRING
	.ASCII	\),+/: \		;
TERMTAB:				;TERMINATOR TABLE
	.ASCII	\:/+,-()]>?=^#\<0>	;
BLANKTAB:				;SIGNIFICANT BLANK SEPARATOR
	.ASCII	\@*'[<.; !	\
ENDTERM:				;REF LABEL

	.SBTTL	LOCATE STRING BY INDEX NUMBER
;+
; DCL$LOCATE - LOCATE STRING BY INDEX NUMBER
;
; THIS ROUTINE IS CALLED TO LOCATE A STRING IN A CHARACTER ARRAY BY COUNTING
; THE OCCURANCES OF CHARACTERS WITH BIT 7 SET.
;
; INPUTS:
;
;	R2 = ADDRESS OF CHARACTER ARRAY.
;	R3 = STRING INDEX NUMBER.
;
; OUTPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;-
 
DCL$LOCATE::				;LOCATE STRING BY INDEX NUMBER
	CLRL	R1			;CLEAR INITIAL LENGTH
10$:	ADDL	R1,R2			;POINT TO NEXT ENTRY IN TABLE
	MOVZBL	(R2)+,R1		;GET COUNT
	SOBGEQ	R3,10$			;ANY MORE STRINGS TO SKIP OVER?
	RSB				;

	.SBTTL	GENERATE RESULT PARSE DESCRIPTOR
;+
; DCL$GENDESCR - GENERATE RESULT PARSE DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO GENERATE A LONGWORD DESCRIPTOR FOR A RESULT PARSE
; ITEM.
;
; INPUTS:
;
;	R5 = ITEM TYPE.
;	R6 = ITEM FLAGS.
;	R7 = ITEM VALUE.
;	R8 = STARTING ADDRESS OF ITEM.
;	WRK_L_EXPANDPTR = ADDRESS OF TERMINATOR CHARACTER IN EXPANSION BUFFER.
;
; OUTPUTS:
;
;	THE SPECIFIED FIELDS ARE PACKED TOGETHER TO FORM A RESULT PARSE
;	DESCRIPTOR LONGWORD AND THE RESULTANT VALUE IS STORED IN THE RESULT
;	PARSE TABLE.
;-
 
DCL$GENDESCR::				;GENERATE RESULT PARSE DESCRIPTOR
	MOVL	WRK_L_RSLNXT(R10),R1	;GET ADDRESS OF NEXT FREE DESCRIPTOR
	PUSHAB	WRK_G_RESULT+WRK_C_RSLBUFSIZ(R10) ;GET ENDING ADDRESS OF RESULT BUFFER
	CMPL	(SP)+,R1		;ROOM FOR ANOTHER DESCRIPTOR?
	BGTRU	20$			;BRANCH IF OK
	STATUS	RSLOVF			;SET ERROR STATUS
	BRW	ERROR
20$:	INSV	R7,#PTR_V_VALUE,#PTR_S_VALUE,- ;INSERT VALUE FIELD
		PTR_L_DESCR(R1)
	PUSHAB	WRK_G_BUFFER(R10)	;GET ADDRESS OF EXPANSION BUFFER
	SUBL3	(SP)+,R8,R0		;CALCULATE OFFSET TO ITEM
	INSV	R0,#PTR_V_OFFSET,#PTR_S_OFFSET,- ;INSERT OFFSET TO ITEM
		PTR_L_DESCR(R1)
	INSV	R6,#PTR_V_FLAGS,#PTR_S_FLAGS,- ;INSERT ITEM FLAGS
		PTR_L_DESCR(R1)
	INSV	R5,#PTR_V_TYPE,#PTR_S_TYPE,- ;INSERT ITEM TYPE
		PTR_L_DESCR(R1)
	ADDL	#4,WRK_L_RSLNXT(R10)	;POINT TO NEXT ITEM IN BUFFER
	MOVL	WRK_L_RSLNXT(R10),WRK_L_RSLEND(R10) ; REMEMBER LAST TOKEN
	MOVZBL	@WRK_L_EXPANDPTR(R10),R0 ;GET TERMINATOR CHARACTER

	.SBTTL	SET TERMINATOR CLASS IN LAST DESCRIPTOR
;+
; DCL$GENTERM - SET TERMINATOR CLASS IN PREVIOUS TOKEN DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO SET THE TERMINATOR CLASS IN THE TOKEN
; DESCRIPTOR MOST RECENTLY STORED VIA DCL$GENDESCR.
;
; INPUTS:
;
;	R0 = TERMINATOR CHARACTER
;
; OUTPUTS:
;
;	NONE
;-

DCL$GENTERM::
	CMPB	R0,#^A'='		;EQUAL TERMINATOR?
	BEQL	20$			;IF YES, SET CLASS=COLON
	CMPB	R0,#^A'('		;LEFT PARENTHESIS?
	BEQL	30$			;IF YES, SET CLASS
	LOCC	R0,#TERMTAB-TERMCLASS,TERMCLASS ;SEARCH FOR TERMINATOR IN TABLE
	BNEQ	50$			;IF FOUND - USE INDEX # AS CLASS
	ASSUME	PTR_K_BLANK EQ 1
	INCL	R0			;SET TERMINATOR CLASS TO BLANK
	BRB	50$
20$:	MOVZBL	#PTR_K_COLON,R0		;SET TERMINATOR CLASS TO COLON
	BRB	50$
30$:	MOVZBL	#PTR_K_LPAREN,R0	;SET TERMINATOR CLASS TO LPAREN
50$:	MOVL	WRK_L_RSLNXT(R10),R1	;GET ADDRESS OF NEXT FREE DESCRIPTOR
	INSV	R0,#PTR_V_TERM,#PTR_S_TERM,- ;INSERT TERMINATOR CLASS NUMBER
		-PTR_C_LENGTH(R1)	;IN LAST TOKEN DESCRIPTOR STORED
	RSB

	.SBTTL	COMPRESS QUOTED STRING IN EXPANSION BUFFER
;+
; DCL$COMPRESS - COMPRESS QUOTED STRING IN EXPANSION BUFFER
;
; THIS ROUTINE IS CALLED TO COMPRESS A QUOTED STRING WHICH IS
; THE LAST TOKEN IN THE EXPANSION BUFFER.  THE QUOTES ARE REMOVED
; FROM THE STRING AND THE EXPANSION BUFFER POINTER IS RESET TO THE
; NEW END OF THE STRING.
;
; INPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF COMPRESSED STRING.
;	R2 = ADDRESS OF COMPRESSED STRING.
;
;	WRK_L_EXPANDPTR POINTS TO THE END OF THE COMPRESSED STRING.
;
;	R3,R4 DESTROYED.
;-
 
DCL$COMPRESS::
	BSBB	DCL$COMPSTRING		;COMPRESS STRING IN PLACE
	ADDL3	R1,R2,WRK_L_EXPANDPTR(R10) ;RESET POINTER JUST PAST NEW STRING
	RSB

	.SBTTL	COMPRESS QUOTED STRING IN-PLACE
;+
; DCL$COMPSTRING - COMPRESS QUOTED STRING IN PLACE
;
; THIS ROUTINE IS CALLED TO COMPRESS A QUOTED STRING.
;
; INPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;
; OUTPUTS:
;
;	THE SPECIFIED STRING IS COMPRESSED REMOVING PAIRED QUOTES.
;
;		R1 = LENGTH OF COMPRESSED STRING.
;		R2 = ADDRESS OF COMPRESSED STRING.
;
;	R3,R4 DESTROYED.
;-

DCL$COMPSTRING::			;COMPRESS QUOTED STRING
	MOVL	R2,R3			;COPY BASE ADDRESS OF STRING
	MOVL	R3,R4			;COPY BASE ADDRESS OF STRING
	CLRL	R0			;CLEAR QUOTATION FLAG
10$:	CMPB	#^A/"/,(R3)		;NEXT CHARACTER A QUOTE?
	BNEQ	20$			;IF NEQ NO
	INCL	R3			;ADJUST PAST QUOTE
	BBCS	#0,R0,30$		;IF CLR, JUST ENTERING QUOTE
	DECL	R1			;DECREMENT NUMBER OF CHARACTERS REMAINING
	BLEQ	40$			;IF LEQ NONE
	CMPB	#^A/"/,(R3)		;NEXT CHARACTER ALSO A QUOTE?
	BEQL	20$			;IF EQL YES
	BICL	#1,R0			;CLEAR QUOTE IN PROGRESS
20$:	MOVB	(R3)+,(R4)+		;COPY CHARACTER AND COMPRESS
30$:	SOBGTR	R1,10$			;ANY MORE CHARACTERS TO SCAN?
40$:	SUBL3	R2,R4,R1		;CALCULATE LENGTH OF COMPRESSED STRING
	RSB

	.SBTTL	MARK POSITION IN EXPANSION BUFFER
;+
; DCL$MARK - MARK CURRENT POSITION IN EXPANSION BUFFER
;
; MARK THE CURRENT POSITION OF THE SEGMENT BEING PARSED
; SO THAT IF ANY ERROR OCCURS LATER, THE SEGMENT CAN BE
; SHOWN IN THE ERROR MESSAGE.  THE MARKED POSITION IS
; ALSO USED TO OBTAIN THE LENGTH AND ADDRESS OF THE STRING
; MOVED INTO THE EXPANSION BUFFER SINCE THE LAST MARK.
;
; INPUTS:
;
;	WRK_L_EXPANDPTR = CURRENT POINTER INTO EXPANSION BUFFER
;
; OUTPUTS:
;
;	WRK_L_MARKPTR = POSITION OF SEGMENT NOW BEING PARSED
;---
DCL$MARK::
	MOVL	WRK_L_EXPANDPTR(R10),WRK_L_MARKPTR(R10)	;COPY CURRENT EXPANSION BUFFER ADDRESS
	RSB

	.SBTTL	GET DESCRIPTOR OF EXPANSION STRING
;+
; DCL$MARKEDTOKEN - GET DESCRIPTOR OF MARKED EXPANSION STRING
;
; THIS ROUTINE IS CALLED TO OBTAIN THE LENGTH AND ADDRESS OF THE
; STRING COMPOSED OF ALL CHARACTERS WRITTEN INTO THE EXPANSION BUFFER
; SINCE THE LAST CALL TO DCL$MARK.
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1 = LENGTH OF STRING
;	R2 = ADDRESS OF STRING
;	Z SET IF R1=0
;-
DCL$MARKEDTOKEN::
	MOVL	WRK_L_MARKPTR(R10),R2	;GET ADDRESS OF STRING
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;COMPUTE LENGTH OF STRING
	RSB

	.SBTTL	GET NEXT NONBLANK CHARACTER
;+
; DCL$GETNBLK - GET NEXT NONBLANK CHARACTER FROM INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE NEXT NONBLANK CHARACTER FROM THE INPUT
; BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CHARACTERS ARE OBTAINED FROM THE INPUT BUFFER UNTIL A NONBLANK
;	CHARACTER IS ENCOUNTERED.
;
;	R0 = NONBLANK CHARACTER.
;-
 
DCL$GETNBLK::				;GET NEXT NONBLANK CHARACTER
	BSBW	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	BRW	DCL$GETCHAR		;RETURN NEXT CHARACTER TO CALLER

	.SBTTL	MOVE CHARACTER TO EXPANSION BUFFER AND GET BLANK TOKEN
;+
; DCL$MOVBTOKN - MOVE CHARACTER TO EXPANSION BUFFER AND GET BLANK TOKEN
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED OPERATION OF MOVING THE NEXT
; CHARACTER TO THE EXPANSION BUFFER AND THEN OBTAINING THE NEXT BLANK TOKEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS MOVED TO THE EXPANSION BUFFER AND THEN THE NEXT
;	BLANK TOKEN IS OBTAINED.
;-
 
DCL$MOVBTOKN::				;MOVE CHARACTER AND GET TOKEN
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO EXPANSION BUFFER
	BRB	DCL$GTBTOKEN		;GET NEXT BLANK TOKEN

	.SBTTL	MOVE CHARACTER TO EXPANSION BUFFER AND GET TOKEN
;+
; DCL$MOVTOKN - MOVE CHARACTER TO EXPANSION BUFFER AND GET TOKEN
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED OPERATION OF MOVING THE NEXT
; CHARACTER TO THE EXPANSION BUFFER AND THEN OBTAINING THE NEXT TOKEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS MOVED TO THE EXPANSION BUFFER AND THEN THE NEXT
;	TOKEN IS OBTAINED.
;-
 
DCL$MOVTOKN::				;MOVE CHARACTER AND GET TOKEN
	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO EXPANSION BUFFER

	.SBTTL	GETOKEN - GET NEXT TOKEN
;+
; DCL$GETOKEN - GET TOKEN FROM INPUT BUFFER WITH INSIGNIFICANT LEADING BLANKS
; DCL$GTBTOKEN - GET TOKEN FROM INPUT BUFFER WITH SIGNIFICANT LEADING BLANKS
;
; THIS ROUTINE IS CALLED TO SCAN THE INPUT BUFFER UNTIL A DELIMITER IS FOUND.
; WHILE THE BUFFER IS BEING SCANNED, THE RESULTANT TOKEN IS COPIED INTO THE
; EXPANSION BUFFER. WHEN A TERMINATOR IS RECOGNIZED, THE DESCRIPTOR FOR THE
; TOKEN IS RETURNED TO THE CALLER ALONG WITH THE TERMINATOR.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 = TERMINATOR CHARACTER.
;	R1 = LENGTH OF OUTPUT TOKEN.
;	R2 = ADDRESS OF OUTPUT TOKEN.
;
;	Z = 1 IF NO TOKEN IS BEING RETURNED.
;	Z = 0 IF A TOKEN IS BEING RETURNED.
;-

DCL$GETOKEN::				;GET TOKEN FROM INPUT BUFFER
	BSBB	DCL$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
DCL$GTBTOKEN::				;GET TOKEN FROM INPUT BUFFER
	SUBL3	R10,WRK_L_EXPANDPTR(R10),R2 ;FIND OFFSET OF FIRST BYTE IN TOKEN
10$:	BSBW	DCL$MOVCHAR		;MOVE CHARACTER TO EXPANSION BUFFER
	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(R10),10$ ;IF SET, QUOTE IN PROGRESS
	BBS	#WRK_V_STAR,WRK_W_FLAGS(R10),20$ ;IF SET, ASTERISK IS TERMINATOR
	CMPB	#^A'*',R0		;ASTERISK?
	BEQL	10$			;IF EQL YES
20$:	LOCC	R0,#ENDTERM-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BEQL	10$			;IF EQL TERMINATOR NOT FOUND
	DECL	WRK_L_EXPANDPTR(R10)	;BACK UP TO TERMINATOR
	MOVZBL	(R1),R0			;RETRIEVE TERMINATOR
	CMPB	#^A' ',R0		;WAS TERMINATOR A BLANK?
	BNEQ	30$			;IF NEQ NO
	MOVL	WRK_L_CHARPTR(R10),R1	;GET CURRENT CHARACTER POINTER
	LOCC	1(R1),#BLANKTAB-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BNEQ	10$			;IF NEQ INSIGNIFICANT BLANK
	MOVZBL	#^A' ',R0		;RESET BLANK TERMINATOR
30$:	BSBW	DCL$BACKUPCHAR		;RESTORE TERMINATOR TO INPUT BUFFER
	ADDL	R10,R2			;FIND ADDRESS OF FIRST BYTE IN TOKEN
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;CALCULATE LENGTH OF ITEM
	BEQL	50$			;IF EQL NO TOKEN
	CMPB	(R2),#^A'&'		;TOKEN START WITH AMPERSAND?
	BNEQ	50$			;IF NEQ NO
	TSTL	WRK_L_SPECRTN(R10)	;ANY SPECIAL PROCESSING ROUTINE?
	BEQL	50$			;IF NOT, SKIP IT
	MOVZBL	(R2),R0			;PICK UP CHARACTER
	JSB	@WRK_L_SPECRTN(R10)	;CALL SPECIAL PROCESSING ROUTINE
					;AND RETURN WITH SUBSTITUTED VALUE
50$:	RSB

	.SBTTL	FORCE NONBLANK CHARACTER
;+
; DCL$FORNBLK - FORCE NONBLANK CHARACTER
;
; THIS ROUTINE IS CALLED TO FORCE AN INPUT AND THEN SET THE CHARACTER POINTER
; TO THE NEXT NONBLANK CHARACTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER POINTER IS SET TO POINT TO A STRING CONTAINING
;	A HYPHEN FOLLOWED BY AN END OF LINE. A SET NONBLANK OPERATION IS
;	THEN PERFORMED.
;-
 
DCL$FORNBLK::				;FORCE NONBLANK CHARACTER
	MOVAB	DCL$HYPHEN-1,WRK_L_CHARPTR(R10) ;SET TO FORCE INPUT ON NEXT GET

	.SBTTL	POINT TO NEXT NONBLANK CHARACTER
;+
; DCL$SETNBLK - POINT TO NEXT NONBLANK CHARACTER IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO SET THE INPUT BUFFER POINTER TO THE NEXT NONBLANK
; CHARACTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CHARACTERS ARE OBTAINED FROM THE INPUT BUFFER UNTIL A NONBLANK CHAR-
;	ACTER IS ENCOUNTERED AND THE INPUT BUFFER POINTER IS RETURNED TO ITS
;	POSITION BEFORE THE LAST GET CHARACTER OPERATION.
;
;	R0 = NONBLANK CHARACTER.
;-
 
	.ENABL	LSB
DCL$SETNBLK::				;POINT TO NEXT NONBLANK CHARACTER
	EXTZV	#WRK_V_QUOTE,#1,WRK_W_FLAGS(R10),-(SP) ; SAVE QUOTATION FLAG
10$:	BSBB	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	50$			;IF EQL END OF LINE
	CMPB	R0,#^A' '		;BLANK?
	BEQL	10$			;IF EQL YES
	BRB	30$			;BACKUP BEFORE CHARACTER AND EXIT

	.SBTTL	PEEK AT NEXT CHARACTER
;+
; DCL$SETCHAR - PEEK AT NEXT CHARACTER IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE NEXT CHARACTER IN THE INPUT BUFFER
; WITHOUT MOVING THE BUFFER POINTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS OBTAINED FROM THE INPUT BUFFER AND THE CHARACTER
;	POINTER IS RETURNED TO ITS POSITION BEFORE THE GET CHARACTER OPERATION.
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER.
;+
 
DCL$SETCHAR::				;PEEK AT NEXT CHARACTER
	EXTZV	#WRK_V_QUOTE,#1,WRK_W_FLAGS(R10),-(SP) ; SAVE QUOTATION FLAG
	BSBB	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	50$			;IF EQL END OF LINE
30$:	DECL	WRK_L_CHARPTR(R10)	;BACK UP INPUT BUFFER POINTER
40$:	INSV	(SP)+,#WRK_V_QUOTE,#1,WRK_W_FLAGS(R10);RESTORE QUOTATION FLAG
	RSB				;
50$:	TSTL	(SP)+			;IGNORE SAVED QUOTATION FLAG ON EOL
	RSB
	.DSABL	LSB

	.SBTTL	BYPASS INSIGNIFICANT BLANKS
;+
; DCL$TESTBLANK - BYPASS INSIGNIFICANT BLANKS IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO TEST IF THE NEXT CHARACTER IN THE INPUT BUFFER IS
; A SIGNIFICANT BLANK, AND IF IT IS NOT SIGNIFICANT, THROW IT AWAY.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;-
 
DCL$TESTBLANK::				;TEST FOR SIGNIFICANT BLANK
	BSBB	DCL$MOVCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	DCL$BACKUPMOVE		;IF NEQ NO
	BSBB	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	LOCC	R0,#BLANKTAB-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BEQL	DCL$BACKUPMOVE		;BR IF BLANK IS SIGNIFICANT
	MOVL	WRK_L_EXPANDPTR(R10),R0	;GET POINTER INTO EXPANSION BUFFER
	MOVB	(R1),-1(R0)		;PUT REAL TERMINATOR OVER BLANK
	INCL	WRK_L_CHARPTR(R10)	;ADJUST POINTER FOR THE BLANK

	.SBTTL	BACKUP CHARACTER FROM EXPANSION TO INPUT BUFFER
;+
; DCL$BACKUPMOVE - BACKUP ONE CHARACTER FROM EXPANSION TO INPUT BUFFER
;
; THIS ROUTINE RESTORES THE CHARACTER MOST RECENTLY WRITTEN INTO THE EXPANSION
; BUFFER BACK INTO THE INPUT BUFFER AND RESETS THE POINTERS.  THIS EFFECTIVELY
; TAKES BACK THE MOST RECENT "MOVCHAR".
;
; INPUTS:
;
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	THE CHARACTER IS COPIED BACK INTO THE INPUT BUFFER AND THE POINTERS
;	ARE RESET.
;-
DCL$BACKUPMOVE::
	DECL	WRK_L_EXPANDPTR(R10)	;BACK UP EXPANSION BUFFER POINTER
	MOVB	@WRK_L_EXPANDPTR(R10),R0 ;GET CHARACTER

	.SBTTL	BACKUP CHARACTER TO INPUT BUFFER
;+
; DCL$BACKUPCHAR - BACKUP ONE CHARACTER TO INPUT BUFFER
;
; THIS ROUTINE WRITES A GIVEN CHARACTER BACK INTO THE INPUT BUFFER (AT THE
; BEGINNING) AND RESETS THE INPUT POINTER.
;
; INPUTS:
;
;	R0 = CHARACTER TO BE WRITTEN
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	THE CHARACTER IS APPENDED TO THE FRONT OF THE INPUT BUFFER
;	AND THE POINTERS ARE RESET.
;-
DCL$BACKUPCHAR::
	MOVB	R0,@WRK_L_CHARPTR(R10)	;WRITE CHARACTER INTO INPUT BUFFER
	DECL	WRK_L_CHARPTR(R10)	;BACK UP INPUT BUFFER POINTER
	RSB

	.SBTTL	MOVE CHARACTER FROM INPUT TO EXPANSION BUFFER
;+
; DCL$MOVCHAR - MOVE CHARACTER TO EXPANSION BUFFER
;
; THIS ROUTINE IS CALLED TO MOVE A CHARACTER FROM THE INPUT BUFFER TO THE
; EXPANSION BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS OBTAINED FROM THE INPUT BUFFER AND WRITTEN INTO
;	THE EXPANSION BUFFER.
;
;	R0 = CHARACTER MOVED
;	Z SET IF R0=0
;-
 
DCL$MOVCHAR::				;MOVE CHARACTER TO EXPANSION BUFFER
	BSBB	DCL$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER

	.SBTTL	PUT CHARACTER IN EXPANSION BUFFER
;+
; DCL$PUTCHAR - PUT CHARACTER IN EXPANSION BUFFER
;
; THIS ROUTINE IS CALLED TO WRITE A CHARACTER INTO THE EXPANSION BUFFER.
;
; INPUTS:
;
;	R0 = CHARACTER TO BE WRITTEN IN EXPANSION BUFFER.
;	WRK_L_EXPANDPTR = ADDRESS OF NEXT BYTE IN EXPANSION BUFFER.
;
; OUTPUTS:
;
;	THE SPECIFIED CHARACTER IS WRITTEN INTO THE EXPANSION BUFFER AFTER
;	HAVING CHECKED FOR BUFFER OVERFLOW.
;
;	R0 = CHARACTER WRITTEN
;	Z SET IF R0=0
;-
 
DCL$PUTCHAR::				;PUT CHARACTER IN EXPANSION BUFFER
	PUSHAB	WRK_G_BUFFER+WRK_C_CMDBUFSIZ(R10) ;END OF EXPANSION AREA
	CMPL	(SP)+,WRK_L_EXPANDPTR(R10) ;ROOM FOR ANOTHER CHARACTER?
	BLEQU	10$			;IF LEQU NO
	MOVB	R0,@WRK_L_EXPANDPTR(R10) ;STORE CHARACTER IN EXPANSION BUFFER
	INCL	WRK_L_EXPANDPTR(R10)	;INCREMENT EXPANSION POINTER
	TSTB	R0			;RETURN WITH PSL SET FOR CHARACTER
	RSB				;
10$:	STATUS	BUFOVF			;SET ERROR STATUS
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;CLEAR INDIRECT IN PROGRESS
	BRW	ERROR			;

	.SBTTL	GET CHARACTER FROM INPUT BUFFER
;+
; DCL$GETCHAR - GET CHARACTER FROM INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO GET THE NEXT CHARACTER FROM THE INPUT BUFFER.
; IT HANDLES INDIRECT FILES, QUOTES, CONTINUATION, AND BLANK SUPPRESSION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS READ FROM THE INPUT BUFFER AND RETURNED TO THE
;	CALLER.
;
;	R0 = CHARACTER READ.
;-
DCL$GETCHAR::				;GET NEXT CHARACTER FROM INPUT BUFFER
	PUSHL	R1			;SAVE REGISTER
NEXTCHAR:				;GET NEXT CHARACTER
	INCL	WRK_L_CHARPTR(R10)	;UPDATE INPUT BUFFER POINTER
CURRCHAR:				;GET CURRENT CHARACTER
	MOVL	WRK_L_CHARPTR(R10),R1	;GET CHARACTER POINTER
	MOVZBL	(R1)+,R0		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	EOL			;IF EQL END OF LINE
	CMPB	#^A/"/,R0		;QUOTE?
	BEQL	QUOTE			;IF EQL YES
	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(R10),EXITCHAR ;EXIT IF IN QUOTED STRING
	BBS	#WRK_V_INPSUBST,WRK_W_FLAGS(R10),20$ ;IF SUBSTITUTITION PASS
	CMPB	#^A/!/,R0		;EXCLAMATION?
	BEQL	TRUNCATE
	CMPB	#^A/-/,R0		;HYPHEN?
	BEQL	CONTINUATION
	CMPB	#^A/ /,R0		;BLANK?
	BEQL	BLANK
	CMPB	#^A/@/,R0		;AT SIGN?
	BEQL	INDIRECT
	CMPB	#^A/	/,R0		;TAB?
	BEQL	TAB
20$:	BBS	#WRK_V_NOUPCASE,WRK_W_FLAGS(R10),EXITCHAR ;SKIP IF NO UPCASING
	CMPB	#^A/a/,R0		;LOWER CASE LETTER?
	BGTRU	EXITCHAR		;IF GTRU NO
	CMPB	#^A/z/,R0		;LOWER CASE LETTER?
	BLSSU	EXITCHAR		;IF LSSU NO
	BICB	#^X20,R0		;CONVERT TO UPPER CASE
EXITCHAR:				;EXIT WITH CHARACTER
	POPL	R1			;RESTORE REGISTER
	TSTB	R0			;SET CONDITION CODES BASED ON CHARACTER
	RSB				;
;
; STRING QUOTATION DELIMITER DETECTED.  INVERT QUOTE FLAG.
;
QUOTE:	XORW	#WRK_M_QUOTE,WRK_W_FLAGS(R10) ;INVERT QUOTE FLAG
	BRB	EXITCHAR		;
;
; COMMENT CHARACTER DETECTED.  FAKE AN END OF LINE CONDITION.
;
TRUNCATE:
	CLRB	-(R1)			;SET END OF LINE IN BUFFER
	BRB	CURRCHAR
;
; END OF LINE DETECTED.  TERMINATE ANY STRING AND EXIT
;
EOL:	BICW	#WRK_M_QUOTE,WRK_W_FLAGS(R10) ;CLEAR QUOTE IN PROGRESS
	DECL	WRK_L_CHARPTR(R10)	;BACK UP INPUT BUFFER POINTER
	BRB	EXITCHAR
;
; TAB DETECTED.  CONVERT TO A SPACE.
;
TAB:	MOVZBL	#^A/ /,R0		;SET CHARACTER TO A BLANK
;
; COMPRESS MULTIPLE SPACES AND TABS INTO A SINGLE SPACE
;
BLANK:	MOVB	R0,@WRK_L_CHARPTR(R10)	;STORE BLANK IN INPUT BUFFER
	CMPB	#^A/ /,(R1)+		;NEXT CHARACTER A BLANK?
	BEQL	30$			;IF EQL YES
	CMPB	#^A/	/,-1(R1)	;NEXT CHARACTER A TAB?
	BNEQ	40$			;IF NEQ NO
30$:	INCL	WRK_L_CHARPTR(R10)	;INCREMENT CHARACTER POINTER
	BRB	BLANK			;
;
; STRIP ANY TRAILING SPACES ON THE END OF THE LINE
;
40$:	TSTB	-(R1)			;NEXT CHARACTER END OF LINE?
	BEQL	TRUNCATE		;IF EQL YES
	CMPB	#^A/!/,(R1)		;NEXT CHARACTER EXCLAMATION?
	BEQL	TRUNCATE		;IF EQL YES
	CMPB	#^A/-/,(R1)+		;HYPHEN?
	BNEQ	EXITCHAR		;IF NEQ NO
	SETBIT	WRK_V_TRAILSPC,WRK_W_FLAGS(R10) ;INDICATE TRAILING SPACES SEEN
;
; CONTINUATION CHARACTER DETECTED.  IF ITS THE LAST CHARACTER ON
; THE LINE, READ THE NEXT INPUT RECORD AND READ ITS FIRST CHARACTER.
;
CONTINUATION:
	TSTB	(R1)			;NEXT CHARACTER END OF LINE?
	BEQL	NEXT_RECORD		;IF EQL YES
	CMPB	#^A/!/,(R1)		;NEXT CHARACTER EXCLAMATION?
	BEQL	NEXT_RECORD		;IF EQL YES
	CMPB	#^A/ /,(R1)+		;NEXT CHARACTER A BLANK?
	BEQL	CONTINUATION		;IF EQL YES
	CMPB	#^A/	/,-1(R1)	;NEXT CHARACTER A TAB?
	BEQL	CONTINUATION		;IF EQL YES
	CLRBIT	WRK_V_TRAILSPC,WRK_W_FLAGS(R10) ;CLEAR TRAILING SPACE FLAG
	BRB	EXITCHAR		;
;
; INDIRECTION (@) REQUESTED
;
INDIRECT:
	TSTL	WRK_L_SPECRTN(R10)	;ANY SPECIAL PROCESSING ROUTINE?
	BEQL	EXITCHAR		;IF NOT, RETURN @ CHARACTER
	JSB	@WRK_L_SPECRTN(R10)	;CALL SPECIAL PROCESSING ROUTINE
	BRB	EXITCHAR		;EXIT WITH NEXT CHARACTER
;
; READ THE NEXT RECORD, AND RESTART THE GETCHAR SCAN.
;
NEXT_RECORD:
	TSTL	WRK_L_READRTN(R10)	;ANY INPUT ROUTINE?
	BEQL	EXITCHAR		;IF NOT, RETURN EOL CHARACTER
	JSB	@WRK_L_READRTN(R10)	;CALL INPUT ROUTINE
	BRB	EXITCHAR		;EXIT WITH FIRST CHARACTER
 
;
; ERROR EXIT FROM CHARACTER INPUT ROUTINES
;
 
ERROR:	TSTL	WRK_L_ERRORRTN(R10)	;ANY ERROR HANDLER ROUTINE?
	BEQL	90$			;IF NOT, IGNORE ERROR
	JSB	@WRK_L_ERRORRTN(R10)	;CALL ERROR HANDLER
90$:	RSB

	.END
