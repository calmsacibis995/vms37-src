	.TITLE	SET - SET PARAMETER DCLS COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; SET PARAMETER DCLS COMMAND EXECUTION
;
;	SET DIRECTORY
;	SET PROTECTION
;	SET USER IDENTIFICATION CODE
;	SET VERIFY MODE
;
; D. N. CUTLER 17-APR-77
;
; MODIFIED BY:
;
;	V007	PCG0001		Peter George	29-Dec-1981
;		Generalize SET [NO]CONTROL_Y command to handle CTRL/T's.
;
;	V006	ROW0049		Ralph O. Weber	24-NOV-1981
;		Replace use of PRC_M_NOCTLY in PRC_W_FLAGS with use of 
;		PRC_M_CTRLY in PCR_L_OUTOFBAND.  NB: the former flag was one 
;		when CTRL/Y ASTs were not processed; the later flag is a one 
;		when CTRL/Y ASTs must be prcessed.
;
;	V005	RAS0032		Ron Schaefer	11-Sep-1981
;		Change SET DEFAULT logic to account for __device names.
;
;	V004	MTR0001		Mike Rhodes	 7-Jul-1981
;		Modify DCL$SETUIC to ONLY change the UIC and not the default
;		directory spec as before.
;
;	V002	TMH0002		Tim Halvorsen	15-Feb-1981
;		Use R10 rather than FP as WRK address.
;
;	V001	TMH0001		Tim Halvorsen	02-Sep-1980
;		Use WRK_L_RSLNXT rather than global register R10.
;		Convert to MDL structures and remove macro references.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$LOGDEF				;LOGICAL NAME DEFINITIONS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
	$CLIMSGDEF			;DEFINE CLI RELATED ERRORS
	$CLIDEFQUALSET			;DEFINE SET QUALIFER NUMBERS
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
ACCESS:					;ACCESS PROTECTION CODES
	.ASCII	/DEWR/			;
CLASS:					;PROTECTION CLASSES
	.ASCII	/WGOS/			;
DCL$T_DSKNAM::				;STRING FOR DEFAULT DEVICE
	.ASCIC	/SYS$DISK/		;THE NAME

	.SBTTL	SET USER IDENTIFICATION CODE
;+
; DCL$SETUIC - SET USER IDENTIFICATION CODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET USER
; IDENTIFICATION CODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT USER IDENTIFICATION CODE IS ESTABLISHED,
;	THEN THE CURRENT DEFAULT DIRECTORY IS CHANGED TO MATCH.
;-
 
DCL$SETUIC::				;SET USER IDENTIFICATION CODE
	ADDL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10)	;SKIP OPTION DESCRIPTOR
	BSBW	DCL$GETDVAL		;GET THE VALUE OF THE TOKEN DESCRIPTOR
;
;	TRANSLATE THE OVERALL STRING TO GET 1 LEVEL OF TRANSLATION
;
	MOVQ	R1,-(R9)		;PUSH DESCRIPTOR INTO SCRATCH STACK
	PUSHL	R2			;ADDRESS OF STRING IN BUFFER
	PUSHL 	#63			;MAXIMUM STRING TO RETURN
	MOVL	SP,R0			;GET ADDRESS OF OUTPUT DESCRIPTOR
	$TRNLOG_S (R9),(R0),(R0)	;TRANSLATE THE NAME
	MOVQ	(SP)+,R4		;RESET THE RESULTANT STRING DESCRIPTOR
	MOVL	#MAX_TRANS_LVLS,AP	;SET MAX TRANSLATION COUNTER
;
;	LOCATE THE DEVICE PORTION OF THE STRING.  INCLUDE ANY NODE
;	NAMES AS WELL.
;
	CLRB	(R5)[R4]		;MARK THE END OF STRING
	LOCC	#^A/:/,R4,(R5)		;LOOK FOR DEVICE NAME DELIMITER
	BEQL	30$			;BRANCH IF NO DEVICE HERE
	CMPB	(R1)+,(R1)		;IS THIS A NODE NAME?
	BNEQ	20$			;BR IF ONLY DEVICE
	MOVAB	1(R1),R3		;SET ADDRESS OF END OF NODE STRING
	SUBL	#2,R0			;AND LENGTH OF REMAINDER
	LOCC	#^A/:/,R0,(R3)		;SEE IF DEVICE NAME IS HERE
	BEQL	10$			;BR IF NONE-JUST USE NODE
	MOVAB	1(R1),R3		;SET END OF DEVICE NAME
10$:	MOVL	R3,R5			;SET END OF EQUIVALENCE NAME FOR DISK
20$:	SUBL	R5,R1			;FIND LENGTH OF DEVICE NAME
	SUBL	R1,R4			;ADJUST DIRECTORY STRING LENGTH
30$:	BSBB	CVTUIC			;CONVERT GROUP NUMBER
	CMPB	#^A/,/,(R5)		;END WITH A COMMA?
	BNEQ	50$			;IF NEQ NO
	MOVW	R0,-(R9)		;SAVE GROUP NUMBER
	BSBB	CVTUIC			;CONVERT MEMBER NUMBER
	MOVW	R0,-(R9)		;SAVE MEMBER NUMBER
	$CMKRNL_S B^SETUIC,(R9)		;SET USER IDENTIFICATION CODE
					; NOTE: R4,R5=DESCRIPTOR FOR DIRECTORY
40$:	RSB				;
50$:	STATUS	INVUIC			;SET INVALID UIC SYNTAX
	RSB				;
 
;
; CONVERT UIC COMPONENT
;
 
DCL$CVTUIC::
CVTUIC:	CLRQ	R0			;CLEAR ACCUMULATION AND CHARACTER
10$:	INCL	R5			;POINT TO NEXT CHARACTER
	SUBB3	#^A/0/,(R5),R1		;GET NEXT CHARACTER
	BLSS	20$			;IF LSS NOT DIGIT
	CMPL	#8,R1			;OCTAL DIGIT?
	BLEQ	20$			;IF LEQ NO
	MOVAQ	(R1)[R0],R0		;ACCUMULATE RESULT
	BRB	10$			;
20$:	RSB				;
 
;
; SET USER IDENTIFICATION CODE
;
 
SETUIC:	.WORD	0			;ENTRY MASK
	MOVL	@#SCH$GL_CURPCB,R0	;GET CURRENT PROCESS PCB ADDRESS
	MOVL	(AP),PCB$L_UIC(R0)	;SET USER IDENTIFICATION CODE
	STATUS	NORMAL			;
	RET				;
 

	.SBTTL	SET DEFAULT DEVICE AND/OR DIRECTORY
;+
; DCL$SETDEFALT - SET DEFAULT DEVICE AND/OR DIRECTORY
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET DEFAULT
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R4,R5 = STRING DESCRIPTOR FOR DIRECTORY PORTION
;	SYS$DISK = DEFAULT DISK
;	THE CURRENT DEFAULT DIRECTORY IS ESTABLISHED.
;-
MAX_TRANS_LVLS = 10			;MAXIMUM TRANSLATION LEVELS ALLOWED
 
DCL$SETDEFALT::				;SET DEFAULT DEVICE AND/OR DIRECTORY
	ADDL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10)	;SKIP OPTION DESCRIPTOR
	BSBW	DCL$GETDVAL		;GET THE VALUE OF TOKEN DESCRIPTOR
;
;	TRANSLATE THE OVERALL STRING TO GET 1 LEVEL OF TRANSLATION
;
	MOVL	#MAX_TRANS_LVLS,AP	;SET MAX TRANSLATION COUNTER
	MOVQ	R1,-(R9)		;PUSH DESCRIPTOR INTO SCRATCH STACK
	MOVQ	(R8),-(R9)		;PUSH SCRATCH DESCRIPTOR
	$TRNLOG_S 8(R9),(R9),(R9)	;TRANSLATE THE NAME
	MOVQ	(R9)+,R4		;CLEAR RESULT DESCRIPTOR OFF STACK
	CMPW	(R5),#^A'__'		;IS TRANSLATION A HIDDEN DEVICE?
	BEQL	2$			;IGNORE TRANSLATION IF SO
	MOVL	R4,(R9)			;SET RESULT STRING LENGTH
	MOVC3	R4,(R5),@4(R9)		;COPY TRANSLATION TO ORIGINAL BUFFER
	MOVQ	(R9),R4			;SETUP STRING DESCRIPTOR
	BRB	5$			;PARSE STRING

;
;	IF THE TRANSLATION YIELDED A HIDDEN DEVICE NAME,
;	PRETEND THAT IT DID NOT TRANSLATE.
;	HOWEVER MAKE SURE THE LAST CHAR IS A ":" AS THERE REALLY IS
;	A DEVICE NAME PRESENT.
;
2$:	MOVQ	(R9),R4			;GET SOURCE DESCRIPTOR
	CMPB	-1(R5)[R4],#^A':'	;IS LAST CHAR A COLON?
	BEQL	5$			;CONTINUE IF SO
	MOVB	#^A':',(R5)[R4]		;APPEND A COLON IF NOT
	INCL	R4			;COUNT IT AS WELL

;
;	LOCATE THE DEVICE PORTION OF THE STRING.  INCLUDE ANY NODE
;	NAMES FOUND AS WELL.
;
5$:	CLRB	(R5)[R4]		;MARK END OF STRING
	LOCC	#^A/:/,R4,(R5)		;LOOK FOR DEVICE NAME DELIMITER
	BEQL	51$			;BR IF NO DEVICE HERE
	CMPB	(R1)+,(R1)		;IS THIS A NODE NAME?
	BNEQ	20$			;BR IF ONLY DEVICE
	MOVAB	1(R1),R3		;SET ADDRESS OF END OF NODE STRING
	SUBL	#2,R0			;AND LENGTH OF REMAINDER
	LOCC	#^A/:/,R0,(R3)		;SEE IF DEVICE NAME IS HERE
	BEQL	10$			;BR IF NONE-JUST USE NODE
	MOVAB	1(R1),R3		;SET END OF DEVICE NAME
10$:	MOVL	R3,R1			;SET END OF EQUIVALENCE NAME FOR DISK
20$:	MOVL	R5,R2			;SAVE START OF DEVICE STRING
	MOVL	R1,R5			;SET START OF DIRECTORY STRING
	SUBL	R2,R1			;FIND LENGTH OF DEVICE NAME
	SUBL	R1,R4			;ADJUST DIRECTORY STRING LENGTH
;
;	IF THE DEVICE PORTION = 'SYS$DISK', THEN IGNORE IT.
;
	MOVAB	DCL$T_DSKNAM,R7		;ADDRESS OF DEVICE NAME COUNTED STRING
	MOVZBL	(R7)+,R6		;GET LENGTH AND ADDRESS OF FIRST BYTE
	SUBL3	R6,R1,R0		;FIND DIFFERENCE IN NAME STRING SIZES
	DECL	R0			;CHECK IF 1 BYTE DIFFERENCE(THE COLON!)
	BNEQ	30$			;BR IF NO-CAN'T BE THE SPECIAL NAME
	PUSHR	#^M<R1,R2>		;SAVE REGISTERS TO BE USED
	CMPC3	R6,(R2),(R7)		;CHECK FOR RESERVED SYSTEM NAME
	POPR	#^M<R1,R2>		;RESTORE VALUES
51$:	BEQL	50$			;BR IF NO DEVICE NAME ASSIGNMENT NEEDED
;
;	IF THE DEVICE PORTION HAS A TRANSLATION AND IT CONTAINS A
;	DIRECTORY SPECIFICATION, THEN REPEAT USING THE TRANSLATION
;	IF A DIRECTORY WAS SPECIFIED IN ADDITION, THEN REPORT AN ERROR
;	THAT 2 DIRECTORY SPECIFICATIONS APPEARED IN THE SAME STRING.
;
30$:	MOVQ	R1,-(R9)		;PUSH DESCRIPTOR INTO SCRATCH STACK
	DECL	(R9)			;DO NOT SEND COLON INTO TRNLOG
	MOVQ	(R8),-(R9)		;PUSH SCRATCH BUFFER DESCRIPTOR
	$TRNLOG_S 8(R9),(R9),(R9)	;TRANSLATE THE NAME
	BLBC	R0,40$			;BRANCH IF NO TRANSLATION
	CMPW	@4(R9),#^A'__'		;DID TRANSLATION GIVE HIDDEN DEVICE?
	BEQL	40$			;PROCEED AS IF NO TRANSLATION
	LOCC	#^A'[',(R9),@4(R9)	;IS THERE A DIRECTORY IN THERE?
	BEQL	40$			;IGNORE UNLESS DEVICE/DIR TRANSLATION
	TSTL	R4			;ANY DIRECTORY SPECIFIED EXPLICITLY?
	BNEQ	38$			;IF SO, THEN ERROR IN SPECIFICATION
	MOVC	(R9),@4(R9),(R2)	;COPY STRING BACK INTO ORIGINAL BUFFER
	MOVL	(R9),R4			;SET LENGTH OF NEW STRING
	MOVL	12(R9),R5		;SET ADDRESS OF ORIGINAL BUFFER
	ADDL	#16,R9			;REMOVE SAVED DESCRIPTOR FROM STACK
	SOBGTR	AP,35$			;LIMIT TRANSLATION LEVELS
38$:	STATUS	DIRECT			;ERROR IN DIRECTORY SPECIFICATION
	RSB
35$:	BRW	5$			;CONTINUE TRANSLATION DEVICE PORTION
40$:	ADDL	#8,R9			;POP TRANSLATED DESC. OFF STACK
	MOVQ	(R9)+,R1		;RESTORE DEVICE PORTION DESCRIPTOR
	INCL	R1			;RESTORE COLON TO END OF STRING
;
;	CREATE/UPDATE THE LOGICAL NAME SYS$DISK WHICH HOLDS THE CURRENT
;	DEFAULT DISK DEVICE.
;
	PUSHR	#^M<R1,R2,R6,R7>	;DESCRIPTORS FOR LOGICAL AND EQUIVALENCE NAME
	PUSHL	#0			;ACCESS MODE IS DEFAULTED
	PUSHAQ	4(SP)			;ADDRESS OF EQUIVALENCE NAME DESCRITPOR
	PUSHAQ	16(SP)			;DESCRIPTOR OF NAME TO RELATE WITH
	PUSHL	#LOG$C_PROCESS		;TABLE NUMBER
	CALLS	#8,@#SYS$CRELOG		;CLEAR DESCRIPTOR ON RETURN
	BLBC	R0,99$			;BR IF ERROR CREATING NAME
;
;	CHANGE THE DEFAULT DIRECTORY SPECIFICATION (IF ANY)
;
50$:	TSTL	R4			;ANY DIRECTORY FIELD
	BEQL	90$			;BR IF NO
	PUSHR	#^M<R4,R5>		;DESCRIPTOR FOR DIRECTORY NAME
	CLRQ	-(SP)			;ZEROS AS ARGUMENTS 2 & 3
	PUSHAB	8(SP)			;ADDRESS OF DIRECTORY STRING
	CALLS	#5,G^SYS$SETDDIR	;SET THE DEFAULT DIRECTORY
	BLBC	R0,99$			;BR IF ERROR FROM RMS
90$:	STATUS	NORMAL			;ASSUME ALL IS AOK
99$:	RSB

	.SBTTL	SET PROTECTION
;+
; DCL$SETPROT - SET PROTECTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET PROTECTION
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT PROTECTION IS ESTABLISHED.
;-
 
DCL$SETPROT::				;SET PROTECTION
	MOVZWL	@#PIO$GW_DFPROT,R9	;GET DEFAULT PROTECTION VALUE
	ADDL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10)	;SKIP PAST OPTION DESCRIPTOR
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_QUALVALU,R5	;QUALIFIER VALUE?
	BNEQ	40$			;IF NEQ NO
	LOCC	(R2),#4,CLASS		;LOCATE PROTECTION CLASS
	BEQL	60$			;IF EQL INVALID CLASS
	DECL	R0			;CALCULATE STARTING BIT NUMBER
	MULL3	#4,R0,R8		;
	INSV	#^XF,R8,#4,R9		;START WITH NO ACCESS
	CMPB	#PTR_K_COLON,R4		;PROTECTION VALUE SPECIFIED?
	BNEQ	10$			;IF NEQ NO
	BSBW	DCL$GETDVAL		;GET PROTECTION VALUE DESCRIPTOR
	MOVL	R1,R7			;SAVE LENGTH OF VALUE STRING
20$:	LOCC	(R2)+,#4,ACCESS		;LOCATE PROTECTION CODE
	BEQL	50$			;IF EQL INVALID PROTECTION CODE
	DECL	R0			;CALCULATE RELATIVE BIT NUMBER IN FIELD
	ADDL	R8,R0			;CALCULATE ACTUAL BIT NUMBER
	BBCC	R0,R9,30$		;ALLOW SPECIFIED ACCESS
30$:	SOBGTR	R7,20$			;ANY MORE TO SCAN?
	BRB	10$			;
40$:	PUSHL	R9			;SET NEW DEFAULT PROTECTION ARGUMENT
	CLRL	-(SP)			;ZERO ADDRESS OF RETURN DESCRIPTOR
	PUSHAL	4(SP)			;ADDRESS OF NEW PROTECTION
	CALLS	#3,@#SYS$SETDFPROT	;SET DEFAULT PROTECTION
	RSB				;
50$:	STATUS	IVPROT			;SET INVALID PROCTECTION CODE
	RSB				;
60$:	STATUS	INVKEY			;SET INVALID KEYWORD
	RSB				;

	.SBTTL	SET VERIFY MODE
;+
; DCL$SETVERIFY - SET VERIFY MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET VERIFY
; MODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE VERIFY MODE IS ESTABLISHED.
;-
 
DCL$SETVERIFY::				;SET VERIFY MODE
	BISW	#PRC_M_VERIFY,PRC_W_FLAGS(R11) ;ASSUME VERIFICATION IS SPECIFIED
	BSBW	DCL$GETDVAL		;GET OPTION DESCRIPTOR
	BLBC	R3,10$			;IF LBC VERIFICATION SPECIFIED
	BICW	#PRC_M_VERIFY,PRC_W_FLAGS(R11) ;DISABLE VERIFICATION
10$:	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;

	.SBTTL	SET ON MODE
;+
; DCL$SETON - SET ON MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET ON
; MODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE ON MODE IS ESTABLISHED.
;-
 
DCL$SETON::				;SET ON MODE
	BSBW	DCL$GETDVAL		;GET THE DESCRIPTOR FOR "ON"
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	MOVAB	PRC_W_ONLEVEL(R11),R1	;GET ADDRESS OF ON LEVEL CODE
	CMPB	#8,(R1)			;CHECK "ON" LEVEL FOR RESERVED LEVEL
	BLBS	R3,20$			;BR IF OPTION WAS NEGATED (NOON)
	BLSS	10$			;BR IF "ON" ALREADY ACTIVE
	MOVB	1(R1),(R1)		;RESET TO SAVED VALUE
10$:	RSB				;
20$:	BEQL	30$			;BR IF "ON" ALREADY AT RESEVED LEVEL
	MOVB	(R1),1(R1)		;SAVE PREVIOUS "ON" LEVEL
	MOVB	#8,(R1)			;SET TO RESERVED LEVEL
30$:	RSB				;END OF NOON HANDLING

	.SBTTL	SET CONTROL ENABLE/DISABLE
;+
; DCL$SETCTLY - SET CONTROL MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET CONTROL=KEY
; MODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	CONTROL Y AND OUT-OF-BAND AST'S ARE ENABLED OR DISABLED FOR THIS 
;	PROCESS.
;-
CONTROL_CHARS:
	.ASCII	/ Y    T                   /
 
DCL$SETCTLY::				;SET CONTROL MODE
	CLRL	-(SP)			;ALLOCATE CHAR MASK ON STACK
	BSBW	DCL$GETDVAL		;GET OPTION DESCRIPTOR
	MOVL	R3,R6			;SAVE [NO] STATUS FOR FUTURE USE

10$:	BSBW	DCL$GETDVAL		;GET FIRST LETTER
	BLBC	R0,20$			;IF ABSENT, THEN ASSUME Y
	CMPB	R5,#PTR_K_QUALVALU	;MAKE SURE IT IS A QUALIFIER VALUE
	BNEQ	10$			;IF NOT GET NEXT VALUE
	BRB	30$			;VALIDATE QUALIFIER VALUE

20$:	BSBB	CTRLY			;OTHERWISE, SET CONTROL_Y BY DEFAULT
	BRB	80$			;ALL DONE

30$:	CMPB	#1,R1			;IS PARAMETER A SINGLE LETTER?
	BNEQ	90$			;RETURN ERROR IF NOT
	LOCC	(R2),#26,CONTROL_CHARS	;IS IT A VALID LETTER
	BEQL	90$			;RETURN ERROR IF NOT
	BBSS	R0,(SP),40$		;SET CHAR BIT IN MASK
40$:	BSBW	DCL$GETDVAL		;GET NEXT PARAMETER
	BLBC	R0,50$			;EXIT LOOP IF ALL HAVE BEEN INSPECTED
	CMPB	R5,#PTR_K_QUALVALU	;MAKE SURE IT IS A QUALIFIER VALUE
	BNEQ	40$			;IF NOT GET NEXT VALUE
	BRB	30$			;VALIDATE QUALIFIER VALUE
	
50$:	BISL3	(SP),PRC_L_OUTOFBAND(R11),R1	;GET CHARACTER MASK
	BLBC	R6,70$			;IF LBC, THEN ENABLE SPECIFIED
	BBC	#PRC_V_CTRLY,(SP),60$	;IF NOT CTRL/Y, THEN SKIP
	BSBB	CTRLY			;DO SPECIAL CTRL/Y PROCESSING
60$:	BICL3	(SP),PRC_L_OUTOFBAND(R11),R1      ;SET MASK FOR DISABLE
70$:	BSBW	DCL$RESETOOB		;ENABLE/DISABLE APPROPRIATE AST ROUTINES
	
80$:	MOVL	(SP)+,R0		;RESTORE STACK
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;

90$:	MOVL	(SP)+,R0		;RESTORE STACK
	STATUS	INVKEY			;SET ERROR STATUS
	RSB				;
 
CTRLY:	BISL	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11)  ;ASSUME ENABLE SPECIFIED
	BLBC	R6,10$			;IF LBC, THEN ENABLE SPECIFED
	BICL	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11)  ;CLEAR CTRL/Y BIT IN MASK
	BSBW	W^DCL$ONCTLYRST		;RESET CONTROL Y COMMAND TEXT
10$:	RSB

	.END
 
