	.TITLE	TTYCHARO - Terminal driver character output routine
	.IDENT	'V03-006'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES USED FOR THE OUTPUT OF CHARACTERS.
;
;	***** This module never destroys the contents of R0 *****
;
; AUTHOR:
;
;	R.HEINEN 11-AUG-1976
;
; Revision history:
;
;	V03-006	RKS006		RICK SPITZ		22-APR-1982
;		ADD FIX FOR DZ11S (V3A ONLY)
;
;	V03-005	RKS005		RICK SPITZ		15-APR-1982
;		SET DMA STATE PRIOR TO FORK TO PREVENT SPURRIOUS INTERRUPT
;		CALLING WRITE DONE WHILE TWP IS OWNED BY FORK PROCESS.
;		FIX CONTROL O ABORT WHILE DMA OUTPUT IN PROGRESS.
;
;	V03-004	RKS004		RICK SPITZ		5-APR-1982
;		USE SEPERATE CELL IN UCB TO CONTAIN INPUT AND OUTPUT
;		ESCAPE RULES
;
;	V03-003	RKS003		RICK SPITZ		1-APR-1982
;		Change logic at the end of MOVEREADATA to not format
;		characters if only a read/noecho.
;
;	V03-002	ROW0073		Ralph O. Weber		25-MAR-1982
;		Attempt to fix NOWRAP delete at end-of-line by allowing 
;		UCB$W_TT_CURSOR to continue incrementing after screen width is 
;		reached.  Then base delete mechanism on whether ...CURSOR is 
;		beyond screen width or not.  Some additional revision was 
;		required to make TAB deletion on a scope terminal work.  Also 
;		enhanced FORMAT to allow /NOWRAP terminals to avoid character-
;		by-character output, even at or past the right-hand margin.
;
;	V03-001	RKS0001		RICK SPITZ		23-MAR-1982
;		HANDLE ALTERNATE ESCAPE CHARS FOR UPPERCASE TERMINALS.
;		FIX NOWRAP DELETE AT END OF LINE.
;		WRAP TAB AT EOL ON VT100 TERMINALS.
;
;	V02-041	RKS0041		RICK SPITZ		23-FEB-1982
;		DONT ECHO TAB IN LOCAL ECHO MODE
;
;	V02-040	RKS0040		RICK SPITZ		16-FEB-1982
;		REPORT SS$_DATAOVERUN ERROR RATHER THAN PARITY WHEN
;		TYPE TYPEAHEAD OVERFLOWS
;
;	V02-039	RKS0039		RICK SPITZ		8-FEB-1982
;		CONVERT R2 TO LONGWORD PRIOR TO USE
;
;	V02-038	RKS0038		RICK SPITZ		24-JAN-1982
;		RESTORE R2 AFTER ALTERNATE CLASS DRIVER INVOKED.
;		CHANGE PER CHARACTER TIMER TO 250MS.
;		REPAIR DMA COMPLETION LOGIC.
;
;	V02-037	RKS0037		RICK SPITZ		15-DEC-1981
;		ENHANCE FORMAT LINE ROUTINE TO USE SCANC INSTRUCTION.
;		USE TABLE FOR ADJUST CURSOR LOGIC.
;		REVISE BROADCAST COMPLETION LOGIC TO NOT
;		DELAY UPON COMPLETION. SET DEFAULT FORK IPL TO QUEAST
;		FOR BROADCAST RETURN.
;		ENHANCE DMA SETUP LOGIC.USE SYSGEN PARAM FOR DMA OUTPUT SIZE.
;		RESTRUCTURE FORMAT_CHAR LOGIC TO SPEED IT UP.
;		ALWAYS RESET CURSOR ON ESCAPE OUTPUT AND RECOGNIZE ANSICRT.
;		ALLOW FOR ALTERNATE ESCAPE ON UPPERCASE TERMINALS.
;		ADD SUPPORT FOR ALTERNATE CLASS DRIVER.
;		ENHANCE MULTIECHO TO SUPPORT ALTERNATE LENGTH.
;
;	V02-036	JLV0127		Jake VanNoy		1-Dec-1981
;		Add local echo logic.
;
;	V02-035	JLV0112		Jake VanNoy		6-Nov-1981
;		Initialize R2 in powerfail code path.
;
;	V02-034	JLV0096		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS. Changed fork back to 
;		EXE$BRDCSTCOM to use TTY$L_WB_RETADDR. Change call
;		in BRDCST from PORT_STOP to PORT_STOP2 if terminal
;		is a scope.
;
;	V02-033	RKS033		RICK SPITZ			20-AUG-1981
;		ADD SUPPORT FOR ALTERNATE TYPEAHEAD SIZE.
;		ADD SUPPORT FOR ESCAPE MODIFIER ON READ.
;
;	V02-032	RKS032		RICK SPITZ			12-AUG-1981
;		FIX STR_EXIT TO HANDLE R2 CORRECTLY.
;		ENABLE DMA FOR BURST AND FORMATTED OUTPUT.
;		CREATE DMA EXIT ENTRY FOR WRITE DISPATCHING.
;		ADD POWER FAIL RECOVERY FOR STRING OUTPUT.
;		UNLOCK WRITE FORK DURING DMA FAILURE.
;		
;	V02-031 RKS031		RICK SPITZ			27-JULY-1981
;		THIS MODULE HAS BEEN SIGNIFICANTLY CHANGED TO SUPPORT
;		THE CLASS/PORT TERMINAL STRUCTURE. SUPPORT FOR DMA OUTPUT
;		AS WELL AS BURST OUTPUT HAS BEEN ADDED.
;		THE ROUTINE TTY$GETNEXTCHAR IS NOW ACCESSED BY 
;		PORT DRIVERS VIA A UCB VECTOR.
;		THE ROUTINE NOW RETURNS CHARACTERS, A STRING,OR
;		SIGNALS THAT ALL CURRENT OUTPUT IS COMPLETE.
;		TO SUPPORT THIS ALL SINGLE CHARACTER OUTPUT MUST USE THE
;		FORM MOVZBL TO LOAD A SINGLE CHARACTER INTO R3 TO BE
;		PASSED TO THE PORT FOR OUTPUT.
;		
;		XON/XOFF TRANSMISSION HAS BEEN MOVED TO THE PORT DRIVER.
;
;		AT THE CONCLUSION OF PASSALL OUTPUT, BOTH CURSOR AND
;		LAST CHARACTER ARE NOW RESET SINCE THEY ARE UNKNOWN.
;
;	V02-029	SPF001		Steve Forgey			19-Dec-1980
;		Remove support of terminal/host synch RTE.
;
;--
;
; Bug revision history:
;
;	V02-030	RKS030		RICK SPITZ			26-FEB-1981
;		CORRECT FILL TO NOT UPDATE UCB$B_LASTC TO PREVENT
;		FREE LINEFEED FORM BREAKING WITH NOZERO FILL
;
;	V02-028	RKS028		RICK SPITZ			18-SEP-1980
;		CORRECT COMPARE TO WORK WITH 8 BIT CHARACTERS.
;--

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS
;

	$BRDDEF				; Broadcast desecriptor block
	$CRBDEF				; DEFINE CRB
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL'S
	$IRPDEF				; DEFINE IRP
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRIDEF				; DEFINE PRIORITY CLASSES
	$RSNDEF				; DEFINE RESOURCE NUMBERS
	$UBADEF				; DEFINE UBA OFFSETS
	$UCBDEF				; DEFINE UCB
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE EXTENDED TERMINAL CHARS
	$VECDEF				; DEFINE CRB VECTOR
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
 
	.PSECT	$$$115_DRIVER,LONG	; DEFINE NON-PAGED PSECT

	.SBTTL	TTY$GETNEXTCHAR - GET NEXT CHARACTER(S)
;++
; TTY$GETNEXTCHAR - GET NEXT CHARACTER(S)
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS WITH THE NEXT CHARACTER(S) TO BE OUTPUT ON THE UNIT.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
; 
; OUTPUTS:
;
;	R0 = ALWAYS PRESERVED!!
;
;	R3 = 	0 	AND CC = ZERO - NO CHARACTER TO OUTPUT
;		CHAR	AND CC = PLUS - SINGLE CHARACTER TO OUTPUT
;		ADDRESS	AND CC = NEG  - BURST (R2 = LENGTH)
;				 (ADDRESS AND LENGTH ALSO IN UCB)
;
;	R5 = UCB ADDRESS
;--

TTY$GETNEXTCHAR::
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE OF UNIT
;
; GET CURRENT STATE OF THE OUTPUT
;
GETNEXTCHAR:				; INTERNAL ENTRY
	CMPW	#TTY$M_ST_WRITE,(R2)	; TRY WRITING GENERAL CASE FIRST
	BEQL	WRITING			; IF EQL THEN GO
	CMPW	#TTY$M_ST_READ,(R2)	; TRY READING GENERAL CASE NEXT
	BNEQ	10$			; NO, GO TO 10$
	BRW	MOVEREADATA		; IF EQL THEN GO
10$:
	FFS	#0,#TTY$V_ST_READ+1,(R2),R4; GET THE NEXT MOST IMPORTANT OUTPUT STATE
	CASE	R4,TYPE=B,<-		; ENTER THAT STATE'S ROUTINE
	INTEXIT,-			; CONTROL S
	FILLING,-			; FILL IN PROGESS
	CURSOROVRFLOW,-			; CURSOR OVERFLOW
	SENDLINEFEED,-			; LINE FEED TO BE INSERTED
	MULTIECHOING,-			; MULTI ECHO IS PROGRESS
	DMAEXIT,-			; DMA WRITE IN PROGRESS
	WRITING,-			; WRITE IN PROGRESS
	BRDCST,-			; BROADCAST to be completed
	EOLSEEN,-			; EOL SEEN
	CONTROLR,-			; CONTROL R IN PROGRESS
	MOVEREADATA>			; READ IN PROGRESS
;
; EXIT INTERRUPT
;
INTEXIT:				; EXIT INTERRUPT
	CLRL	R3			; SET NO RETURN CHARACTER
	RSB				; RETURN

	.SBTTL	WRITING - WRITE state action routine

;++
; WRITING - CONTINUE WRITE I/O OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN ALL EXTRA OUTPUT IS COMPLETE
; AND A WRITE OPERATION IS IN PROGRESS.
;
; THE NEXT AVAILABLE CHARACTER IS EXTRACTED FROM THE USER BUFFER
; AND GIVEN TO THE ECHO FORMAT ROUTINES TO OUTPUT CORRECTLY.
;
; IF CONTROL O HAS STOPPED THE OUTPUT THE OPERATION IS COMPLETED.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; Implicit inputs:
;
;	UCB$L_TT_WRTBUF	- address of write buffer
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE TERMINAL STATE VECTOR
;	R3 = CHARACTER TO OUTPUT IF ANY
;	R5 = UCB ADDRESS
;--

	.ENABLE	LSB
WRITING:
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Get address of buffer block.
	IF_STATE CTRLO,60$		; COMPLETE I/O OF CONTROL O
	MOVL	TTY$L_WB_NEXT(R4),R3	; GET ADDRESS OF NEXT CHARACTER
	CMPL	R3,TTY$L_WB_END(R4)	; DONE?
	BGEQU	50$			; IF GEQU THEN YES
	IF_STATE <PASALL,WRTALL>,BURST
	BRW	FORMAT			; FORMAT FOR OUTPUT

;
; WRITE I/O DONE
;

50$:					; Normal return.
	IF_STATE -			; Branch forward if this is
		BRDCST,80$		; a broadcast message.
	IF_NOT_STATE	<PASALL,WRTALL>,55$
	CLRW	UCB$W_TT_CURSOR(R5)	; AT CONCLUSION OF PASSALL/WRITALL
	CLRB	UCB$B_TT_LASTC(R5)	; STATE IS UNKNOWN
55$:
	MOVW	#SS$_NORMAL,-		; Load success status code into
		TTY$W_WB_STATUS(R4)	; buffer header.
	BRB	70$			; CONTINUE

;
; CONTROL O TYPED OR CONTROL Y OR C
;

60$:					; Control-O.
	IF_STATE -			; Branch forward if this is a
		BRDCST,80$		; broadcast message.
	MOVW	#SS$_CONTROLO,-		; Load control-O status code
		TTY$W_WB_STATUS(R4)	; into buffer header.

70$:					; Complete transfer.
	SUBL3	TTY$L_WB_NEXT(R4),-	; Calculate number of characters
		TTY$L_WB_END(R4),R3	; not output to terminal.
	SUBW	R3,TTY$W_WB_BCNT(R4)	; Adjust transfer count.
	BSBW	TTY$WRITEDONE		; Do I/O done.
	BRW	TTY$GETNEXTCHAR		; Get the next character.

80$:					; Complete a broadcast write.
	CLR_STATE -			; Clear broadcast state.
		<WRITE,WRTALL>
	MOVL	TTY$L_WB_END(R4),-	; Pretend all the message has
		TTY$L_WB_NEXT(R4)	; been output already.
	BRW	GETNEXTCHAR		; And go handle it.

WRITE_END:
	IF_STATE BRDCST,80$		; SKIP IF BROADCAST
	IF_STATE CTRLO,60$		; CONTROL O
	BRB	70$			; COMPLETE WITH CURRENT STATUS

	.DISABLE	LSB
	
	.PAGE
	.SBTTL BURST/STRING - SET UP OUTPUT FOR BURST MODE
;++
; BURST/STRING -- SET UP OUTPUT FOR BURST MODE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS THE ADDRESS AND LENGTH OF THE CURRENT 
; OUTPUT TO THE CALLER. DUETIM IS COMPUTED BASED ON THE LENGTH OF THE
; OUTPUT. THE CURRENT WRITE POINTERS ARE UPDATED TO REFLECT THE
; NUMBER OF CHARACTERS INCLUDED IN THE BURST.
;
; INPUTS:
;	R3 = ADDRESS OF NEXT CHARACTER
;	R4 = TWP ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3 = ADDRESS OF NEXT CHARACTER
;	R5 = UCB ADDRESS
;	UCB$L_TT_OUTADR = ADDRESS OF START OF BURST
;	UCB$L_TT_OUTLEN = LENGHT OF BURST
;--
	.ENABLE LSB
5$:
	BRW	POWER				; RESTART CURRENT I/O

BURST:
	SUBL3	R3,TTY$L_WB_END(R4),R2		; COMPUTE LENGTH OF RECORD

STR_EXIT:
	DSBINT	,R1				; DISABLE TO POWER
	BBS	#UCB$V_POWER,UCB$W_STS(R5),5$	; CHECK FOR POWER FAIL
	ENBINT	R1				; REENABLE INTERRUPTS
	MOVZWL	R2,R2				; CONVERT TO WORD VALUE
	ADDL	R2,TTY$L_WB_NEXT(R4)		; UPDATE NEXT CHARACTER ADDRESS
	MOVW	R2,UCB$W_TT_OUTLEN(R5)		; SET OUTPUT SIZE
	MOVL	R3,UCB$L_TT_OUTADR(R5)		; SET OUTPUT ADDRESS
	BBC	#TT2$V_DMA,-			; IF DMA CONTROLLER, CHECK SIZE
		UCB$L_TT_DEVDP1(R5),STR_TIMESET

	CMPW	R2,G^TTY$GW_DMASIZE		; LARGE ENOUGH FOR DMA?
	BLEQ	STR_TIMESET			; NO OUTPUT NORMALLY
	CLRL	TTY$L_WB_MAP(R4)		; SHOW NO MAPS ALLOCATED
	BRW	DMA				; START DMA

	.DISABLE	LSB

STR_TIMESET:
	DIVL3	#4,R2,R1			; COMPUTE PER CHARACTER TIMER
	ADDL	#2,R1				; BIAS BY MINIMUM TIMEOUT
	ADDL3	R1,G^EXE$GL_ABSTIM,-		; CALCULATE TIMEOUT PERIOD
		UCB$L_DUETIM(R5)
	BISB	#UCB$M_INT!UCB$M_TIM,-		; SET TIMEOUT, OUTPUT ACTIVE
		UCB$W_STS(R5)
	TSTL	R3				; SET NEGATIVE CC TO SIGNAL 
						; STRING OUTPUT
	RSB


	.PAGE
	.SBTTL FORMAT - FORMAT STRING FOR OUTPUT
;++
; FORMAT -- FORMAT STRING FOR OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS THE ADDRESS AND LENGTH OF A PORTION OF THE
; CURRENT FORMATTED OUTPUT STRING TO THE CALLER.
; IF NO SIGNIFICANT PORTION OF THE STRING CAN BE FOUND, IT
; DEFAULTS TO SINGLE CHARACTER FORMAT MODE.
; DUETIM IS COMPUTED BASED ON THE LENGTH OF THE
; OUTPUT. THE CURRENT WRITE POINTERS ARE UPDATED TO REFLECT THE
; NUMBER OF CHARACTERS INCLUDED IN THE BURST.
; 
;
; INPUTS:
;	R2 = ADDRESS OF UNIT STATE VECTOR
;	R3 = ADDRESS OF NEXT CHARACTER
;	R4 = TWP ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF UNIT STATE VECTOR
;	R3 = ADDRESS OF NEXT CHARACTER
;	R5 = UCB ADDRESS
;	UCB$L_TT_OUTADR = ADDRESS OF START OF BURST
;	UCB$L_TT_OUTLEN = LENGHT OF BURST
;
;		 OR
;	R3 = NEXT CHARACTER TO OUTPUT
;--
FORMAT:
	PUSHL	R0				; CSR MUST ALWAYS BE PRESERVED
	IF_STATE <ESC_O>,FORMAT_X		; IF ESCAPE IN PROGRESS, SPECIAL
	SUBL3	R3,TTY$L_WB_END(R4),R0		; CALCULATE LENGTH OF STRING
	BBC	#TT$V_WRAP, UCB$L_DEVDEPEND(R5), 5$ ; Branch if /NOWRAP.
	SUBW3	#1,UCB$W_DEVBUFSIZ(R5),-	; COMPUTE EOL-1
		R1
	SUBW2	UCB$W_TT_CURSOR(R5),R1		; COMPUTE ROOM TILL EOL-1
	BLEQU	FORMAT_X			; EOL REACHED

	CVTWL	R1,R1				;
	CMPL	R1,R0				; OUTPUT SIZE IS LESS OF TWO
	BLEQ	10$
5$:	MOVL	R0,R1				; ACTUAL IS LESS

10$:
	MOVZBL	(R3),R0				; TEST FIRST CHARACTER
	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
		W^TTY$A_TYPE[R0]
	BNEQ	FORMAT_X

	PUSHR	#^M<R1,R2,R3>			; SAVE LENGTH, ADDRESS
	SCANC	R1,(R3),W^TTY$A_TYPE,-		; SKIP ALL NON SPECIALS 
	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>
						; TO ALLOW SINGLE BURST OUTPUT
20$:
	POPR	#^M<R1,R2,R3>			; RESTORE LENGTH , ADDRESS
	SUBL	R0,R1				; COMPUTE NUMBER CHARS FOUND
	BEQL	FORMAT_X			; YES
	ADDW	R1,UCB$W_TT_CURSOR(R5)		; UPDATE FINAL CURSOR
						; THIS ASSUMES ALL CHARS
						; < SPACE ARE SPECIALS
	CLR_STATE <NL,SKIPLF,WRAP>		; 
	MOVL	R1,R2				; LENGTH OF STRING TO OUTPUT
	POPL	R0				; RESTORE
	SUBL3	#1,R2,R1			; CALC N-1
	MOVB	(R3)[R1],UCB$B_TT_LASTC(R5)	; LASTC IS FINAL CHARACTER OUTPUT
	BRW	STR_EXIT			; TAKE COMMON STRING EXIT

FORMAT_X:
	POPL	R0				; RESTORE
	MOVZBL	(R3),R3				; GET CHARACTER
	INCL	TTY$L_WB_NEXT(R4)		; BUMP NEXT POINTER
	BRW	FORMAT_CHAR			; HANDLE AS SINGLE

	.PAGE
	.SBTTL DMA - HANDLE DMA OUTPUT
;++
; DMA -- HANDLE DMA OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE HANDLES ALLOCATION AND LOADING OF MAP REGISTERS
; TO HANDLE DMA OUTPUT. MAP REGISTERS ARE ALLOCATED IN PAIRS
; TO ALLOW OUTPUT BURSTS UP TO 512 BYTES. TRANSFERS LARGER THAN
; THAT ARE DONE IN SEQMENTS. IF INSUFFICIENT MAPS ARE AVAILABLE,
; THE TRANSFER IS DONE CHARACTER MODE.
; THIS ROUTINE RETURNS TO THE CALLER WITH UCB$M_INT SET AND CC = ZERO
; TO SIGNAL THE CALLER THAT NO OUTPUT IS TO BE DONE AS A RESULT
; OF THIS CALL. A FORK ON THE TWP IS QUEUED TO ALLOW ALLOCATION 
; AND LOADING OF THE
; MAP REGISTERS. OUTPUT IS INITIATED BY INVOKING THE PORT DRIVER
; START DMA ENTRY.
; 
;
; INPUTS:
;	R3 = ADDRESS OF NEXT CHARACTER
;	R4 = TWP ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3 = 0
;	R5 = UCB ADDRESS
;	UCB$M_INT = 1
;	TWP QUEUED TO FORK QUEUE
;--
	
DMAEXIT:				; DMA COMPLETION
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; GET ADDRESS OF WRITE BUFFER
;
; GENERAL DMA ENTRY. IT HANDLES START, CONTINUATION, AND COMPLETION
;

DMA:
	TSTB	TTY$B_WB_FIPL(R4)	; FORK ACTIVE?
	BEQL	10$			; NO 
	BRW	INTEXIT			; DO NOT FORK. FORK PROCESS WILL
					; HANDLE CONDITION ON EXIT

10$:	PUSHAL	INTEXIT			; FOR FORK RETURN
	BISB	#UCB$M_INT,UCB$W_STS(R5); INTERLOCK TO PREVENT OUTPUT/ECHO
	BBSS	#TTY$V_SX_DMA,UCB$Q_TT_STATE(R5),-
		15$			; SHOW DMA ACTIVE
15$:	MOVL	R5,R3			; SAVE UCB ADDRESS
	MOVL	R4,R5			; FORK ON TWP

	MOVB	UCB$B_FIPL(R3),-
		TTY$B_WB_FIPL(R5)	; LOCK FORK BLOCK
	FORK				; RETURN TO INTERRUPT ROUTINE AND
					; FORK TO ALLOCATE MAP REGISTERS
	MOVL	R5,R4			; R4 = TWP
	MOVL	R3,R5			; R5 = UCB

	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET ADDRESS OF NEXT STRING
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; LENGTH OF OUTPUT
	BEQL	DMA_DONE		; YES

	TSTL	TTY$L_WB_MAP(R4)	; MAP ALLOCATED YET?
	BEQL	DMA_START		; NO, GO ALLOCATE

	CMPL	R2,#512			; NEXT BURST TOO LONG?
	BLEQ	DMA_CONTINUE		; NO
	MOVZWL	#512,R2
	BRB	DMA_CONTINUE		; YES SO SET TO MAX SIZE

DMA_DONE:				; DMA COMPLETION
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	TTY$L_WB_MAP(R4),-
		CRB$L_INTD+VEC$W_MAPREG(R0); RESTORE MAP FIELD IN CRB
	BEQL	3$			; SKIP IF NONE
	JSB	G^IOC$RELMAPREG		; RELEASE MAP REGISTERS
3$:	JSB	TTY$LOCK		; INTERLOCK
	CLR_STATE DMA			; RESET DMA ACTIVE
	BICB	#UCB$M_INT,UCB$W_STS(R5)	;RESET INT EXPECTED
	CLRB	TTY$B_WB_FIPL(R4)	; UNLOCK FORK BLOCK
	BBSC	#TTY$V_SX_DMAABO, -
		(R2),10$		; CLEAR ABORT /IF ABORT ,EXIT STATUS
;
;	CALL GETNEXTCHAR TO CONTINUE PROCESSING
;
	MOVL	UCB$L_TT_PORT(R5),R0	; GET PORT ADDRESS
	BSBW	TTY$GETNEXTCHAR		; GET NEXT STREAM
	BNEQ	5$
	BRW	INTEXIT			; NO DATA READY (OR NEXT DMA QUEUED)
5$:	JMP	@PORT_STARTIO(R0)	; START NEXT BURST

10$:	BRW	WRITE_END		; COMPLETE WRITE

DMA_START:
	CMPL	R2,#512			; TOO LONG?
	BLEQ	5$			; NO
	MOVZWL	#512,R2			; SET SIZE TO MAX
5$:
	PUSHR	#^M<R0,R1,R2,R3>
	MOVZBL	#2,R3			; REQUEST 2 MAP REGISTERS
	JSB	G^IOC$ALOUBAMAPN	; 
	BLBS	R0,10$			; SUCCESS
	BRW	DMA_FAIL		; INSUFFICIENT REGISTERS AVAILABLE
10$:	POPR	#^M<R0,R1,R2,R3>
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R0),-
		TTY$L_WB_MAP(R4); SAVE  MAP FIELD IN WRITE BUFFER
DMA_CONTINUE:
	DSBINT	UCB$B_DIPL(R5)
	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE CHARACTER POINTER
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	JSB	STR_TIMESET		; COMPUTE TIMEOUT


;		R3 - STRING ADDRESS
;		R2 - LENGTH
;		R4 - WRITE BUFFER
;		R5 - UCB

	PUSHR	#^M<R2,R4,R5>
5$:	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_ADP(R0),R1	; CONFIG REGISTER
	EXTZV	#VEC$V_MAPREG,#VEC$S_MAPREG,-
		TTY$L_WB_MAP(R4),R0		; GET STARTING MAP REGISTER
	MOVAL	UBA$L_MAP(R1)[R0],R1	; GET 1ST MAP REGISTER ADDRESS
	
	BICL3	#^X80000000,R3,R4	; CALC SVAPTE OF BUFFER
	ASHL	#-9,R4,R4		; ISOLATE PAGE
	MOVL	G^MMG$GL_SPTBASE,R5	; GETS VAPTE OF BUFFER
	MOVAL	(R5)[R4],R4		; INTO R4
	BICL	#^C^X1FF,R3		; COMPUTE BYTE OFFSET IN PAGE

;	LOAD MAP REGISTERS
;		R0 - MAP REGISTER NUMBER
;		R1 - ADDRESS OF FIRST MAP REGISTER
;		R2 - BUFFER LENGTH
;		R3 - BYTE OFFSET IN PAGE
;		R4 - SVAPTE OF BUFFER

	MOVZBL	#2,R2
10$:	MOVL	(R4)+,R5		; GET CONTENTS OF NEXT PTE

;	THIS CODE ASSUMES THAT DMA IS FROM NONPAGED POOL

	INSV	#^X400,#21,#11,R5	; SET VALID BIT, DATA PATH 0
	MOVL	R5,(R1)+		; LOAD INTO MAP REGISTER
	SOBGTR	R2,10$
		
	POPR	#^M<R2,R4,R5>		; RESTORE LENGTH,WRITE BUFFER, UCB
	INSV	R0,#9,#9,R3		; COMPUTE UNIBUS ADDRESS
	EXTZV	#16,#2,R3,R0		; GET HIGH 2 UNIBUS ADDRESS BITS
	INSV	R0,#14,#2,R2		; MERGE WITH BYTE COUNT 

	BBS	#TTY$V_SX_DMAABO,-
		UCB$Q_TT_STATE(R5),20$	; IF ABORT, SKIP TRANSFER

	MOVL	UCB$L_TT_PORT(R5),R0	; ACCESS PORT VECTOR
	JSB	@PORT_START_DMA(R0)	; INITIATE DMA

	CLRB	TTY$B_WB_FIPL(R4)	; UNLOCK FORK	
	ENBINT
	RSB				; RETURN TO FORK DISPATCHER
20$:
	ENBINT
	BRW	DMA_DONE		; COMPLETE TRANSFER

DMA_FAIL:

	POPR	#^M<R0,R1,R2,R3>		; RESTORE SAVED REGISTERS
	BBC	#TTY$V_SX_DMAABO,-
		UCB$Q_TT_STATE(R5),5$		; IF ABORT, SKIP TRANSFER
	BRW	DMA_DONE	
5$:
	JSB	TTY$LOCK			; RAISE TO DEVICE IPL
	CLR_STATE DMA				; RESET DMA STATE
	CLRB	TTY$B_WB_FIPL(R4)		; UNLOCK FORK	

	MOVZWL	UCB$W_TT_OUTLEN(R5),R2		; GET SIZE OF TRANSFER
	MOVL	UCB$L_TT_PORT(R5),R0		; ACCESS PORT VECTOR
	JSB	STR_TIMESET			; SET UP TIMER/UCB VALUES
	JSB	@PORT_STARTIO(R0)		; START I/O CHARACTER MODE
	RSB					; RETURN TO FORK DISPATCHER



	.SBTTL MOVEREADATA - MOVE CHARACTER FROM TYPEAHEAD TO READ BUFFER
;++
; MOVEREADATA -- MOVE CHARACTER FROM TYPEAHEAD BUFFER TO READ BUFFER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE MOVES A CHARACTER FROM THE TYPEAHEAD BUFFER AND STARTS
; THE ECHO. 
;
; NON-IMMEDIATE ACTION CONTROL SEQUENCES ARE HANDLED HERE.
;
; BEFORE RETURNING A CHARACTER FOR ECHO IT IS CONVERTED TO ITS
; MULTIPLE ECHO STRING IF APPROPRIATE. IN THIS CASE THE CHARACTER
; RETURNED IS THE FIRST OF THE MULTIPLE ECHO CHARACTERS.
;
; INPUTS:
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3 = CHARACTER IF ANY (CC = EQL )
;	R5 = UCB ADDRESS
;--
MOVEREADATA:				;
	TSTW	UCB$W_TT_INAHD(R5)	; ANY TYPEAHEAD DATA?
	BEQL	35$			; IF EQL THEN NO
;
; MOVE CHARACTER OUT OF TYPEAHEAD BUFFER
;
	MOVL	UCB$L_TT_TYPAHD(R5),R4	; ADDRESS TYPEAHEAD BUFFER
	MOVZBL	@TTY$L_TA_GET(R4),R3	; GET THE CHARACTER
;
; SEE IF DELETE SEQUENCE SHOULD BE TERMINATED
;
	IF_NOT_STATE DEL,50$		; IN DELETE STATE?
	CMPB	R3,#TTY$C_DELETE	; IS THIS CHARACTER A DELETE?
	BEQL	50$			; IF YES THEN GO ON
	CLR_STATE DEL			; TERMINATE DELETE SEQUENCE
;
; TERMINATE DELETE SEQUENCE IF NOT IN NO-ECHO
;
	MOVZBL	#^A/\/,R3		; SET OUTPUT CHARACTER
	BRW	FORMAT_CHAR		; FORMAT THE CHARACTER
;
; TYPEAHEAD BUFFER EXHAUSTED
;
20$:	BRW	XON			; CONTINUE
35$:	IF_STATE <TYPFUL>,20$		; BR IF TYPEAHEAD FULL
;
; THE TYPEAHEAD BUFFER HAS NOW BEEN EMPTIED INTO THE SYSTEM BUFFER.
; IF PROCESSING A READ WITH ZERO SECOND TIMEOUT, RETURN THE DATA
; TO THE USER IMMEDIATELY.
;
	BBC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),40$; BR IF NOT READ WITH TIMEOUT.
	CMPL	TTY$A_MAXTIME,UCB$L_TT_RDUE(R5); ZERO SECOND TIMEOUT?
	BNEQ	40$			; BR IF NOT.
	MOVW	#SS$_TIMEOUT,UCB$W_BOFF(R5); SET TIMEOUT COMPLETION STATUS.
	BSBW	TTY$READONE		; COMPLETE REQUEST.
;
; DISMISS INTERRUPT
;
40$:	CLRL	R3			; SET NO RETURN CHARACTER.
	RSB
;
; ALTMODE - CHANGE ^O175,176 TO ESCAPE IF NOT LOWER CASE TERMINAL
;
45$:

	CMPB	#^X7D,R3		; ALT MODE?
	BEQL	47$			; YES
	CMPB	#^X7E,R3		; ALT MODE?
	BNEQ	153$			; NO
47$:	MOVZBL	#TTY$C_ESCAPE,R3	; CHANGE CHARACTER TO ESCAPE
	BRB	155$			; CONTINUE
;
; ACTUALLY REMOVE CHARACTER FROM BUFFER
;
50$:	DECW	UCB$W_TT_INAHD(R5)	; ADJUST NUMBER OF TYPEAHEAD CHARACTERS
;
; CHECK FOR BUFFER WRAP AROUND
;
	AOBLSS	TTY$L_TA_END(R4),TTY$L_TA_GET(R4),60$; POINTER PAST END?
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_GET(R4); RESET POINTER
60$:
;
; CHECK IF ALTERNATE DRIVER REQUIRED
;
	MOVL	UCB$L_IRP(R5),R1	; ADDRESS PACKET
	BBC	#IO$V_EXTEND,-		; DOES THIS FUNCTION SPECIFY SPECIAL?
		IRP$W_FUNC(R1),65$	; IF NOT SKIP
	BRW	ALTREAD			; DISPATCH IT
;
; SKIP TESTS FOR SECOND CONTROL SEQUENCE SET IF PASSALL
;

65$:	IF_STATE <PASALL,NOFLTR>,150$	; 
	CASE	W^TTY$A_TYPE[R3],TYPE=B,LIMIT=#1@TTY$V_CH_CTRL2,-
		<CTRLR,CTRLU,DELCHAR>
;
; INSERT THE CHARACTER
;
150$:	IF_STATE	<PASALL,ESC>,155$; IF PASSALL OR ESC THEN NO CONVERT
	BBC	#TT$V_LOWER,UCB$L_DEVDEPEND(R5),45$; BR IF NO LOWER CASR ON UNIT
	BBC	#IO$V_CVTLOW,IRP$W_FUNC(R1),155$; BR IF NOT CONVERT LOW
153$:	BBC	#TTY$V_CH_LOWER,W^TTY$A_TYPE[R3],155$; BR IF NOT LOWER CHARACTER
	BICW	#^X020,R3		; CONVERT TO UPPER CASE
155$:	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
	MOVB	R3,@TTY$L_RB_NXT(R4)	; INSERT CHARACTER
	INCL	TTY$L_RB_NXT(R4)	; ADJUST POINTER
	INCW	UCB$W_BCNT(R5)		; ADD TO COUNT
;
; PROCESS ESCAPE SEQUENCES AND ESCAPES
;
	BBC	#TTY$V_SX_ESCAPE,(R2),200$; BR IF NOT ESCAPE TERMINAL
	IF_STATE ESC,160$		; ALREADY IN ESCAPE SEQUENCE?
	CMPB	R3,#TTY$C_ESCAPE	; ESCAPE CHARACTER?
	BNEQ	200$			; CONTINUE NORMALLY
	CLRB	UCB$B_TT_ESC(R5)	; SET FIRST SYNTAX RULE
	SET_STATE ESC			; BEGIN ESCAPE SEQUENCE
	MOVW	R3,IRP$L_MEDIA(R1)	; SET TERMINATOR CHARACTER
	INCW	IRP$L_MEDIA+2(R1)	; START TERMINATOR SIZE
	BRB	210$			; CONTINUE
;
; ESCAPE SEQUENCE IN PROGRESS - CHECK SYNTAX
;
160$:	INCW	IRP$L_MEDIA+2(R1)	; ADJUST SIZE OF ESCAPE SEQUENCE
	BSBW	ESCSYNTAX		; CHECK CHAR AGAINST SYNTAX
	BGTR	210$			; VALID CHAR, CONTINUE INPUT
	BEQL	197$			; VALID CHAR, SEQUENCE COMPLETE
;
; ESCAPE SYNTAX ERROR
;
195$:	SET_STATE BADESC		; SET BAD ESCAPE
197$:	CLR_STATE ESC			; SET SEQUENCE DONE
	BISW	#IO$M_TRMNOECHO,IRP$W_FUNC(R1); SET TO FORCE NO ECHO
	BRB	221$			; AND SEQUENCE IS OVER
;
; NON ESCAPE SEQUENCE TERMINATION TEST
;
200$:	BBS	R3,@IRP$B_CARCON(R1),220$; BR IF TERMINATOR
;
; CHECK FOR FULL BUFFER
;
210$:	CMPW	UCB$W_BCNT(R5),IRP$W_BCNT(R1); TEST BUFFER FULL
	BLSSU	230$			; IF LSS THEN NOT FULL
	CLRW	IRP$L_MEDIA(R1)		; SET NO TERMINATOR
	BICW	#IO$M_TRMNOECHO,IRP$W_FUNC(R1); FORCE POSSIBLE ECHO
	BRB	221$			; AND CONTINUE
;
; TERMINATOR FOUND BUT BUFFER NOT FULL
;
220$:	MOVW	R3,IRP$L_MEDIA(R1)	; SAVE LAST CHARACTER FOR STATUS
	INCW	IRP$L_MEDIA+2(R1)	; SET TERMINATOR SIZE
221$:	SUBW	IRP$L_MEDIA+2(R1),UCB$W_BCNT(R5); ADJUST TRANSFER SIZE
	SET_STATE <EOL>			; SET END OF LINE SEEN
225$:	BBS	#IO$V_TRMNOECHO,IRP$W_FUNC(R1),240$; BR IF NOT TERM NOECHO
;
; TEST FOR ECHO NEEDS
;
230$:	IF_STATE	<NOECHO,ESC>,250$; IF NOECHO OR ESC THEN BRANCH
	BRW	FORMAT_CHAR		;
240$:	BRW	GETNEXTCHAR		; VECTOR TO TRANSFER MORE CHARACTERS

250$:	IF_STATE ESC,240$		; CONTINUE IF ESCAPE
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_TT_DEVDP1(R5),240$ ; NO FORMATTING IF NOT LOCAL ECHO
	BBS	#IO$V_NOECHO, -
		IRP$W_FUNC(R1),240$	; OR READ NOECHO
	BRW	FORMAT_LOCAL		; OTHERWISE, LOCAL ECHO TERMINAL, FORMAT

	.ENABL	LSB

;
; CONTROL U PROCESSING
;
CTRLU:	IF_NOT_STATE ESC,10$		; IF IN ESCAPE SEQUENCE THEN DELETE ESCAPE
	BSBW	DELESCAPE		; DELETE THE ESCAPE SEQUENCE
10$:	CLRW	UCB$W_BCNT(R5)		; GET NO BUFFERED CHARACTERS
	ADDL3	#TTY$L_RB_DATA,UCB$L_SVAPTE(R5),@UCB$L_SVAPTE(R5); ADJUST POINTER

	IF_NOT_STATE NOECHO,11$		; BRANCH IF ECHO
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_TT_DEVDP1(R5),12$	; BRANCH IF NOT LOCAL ECHO
11$:
	MOVAB	W^TTY$A_CTRLU,R4	; ADDRESS MULTIECHO STRING
	IF_STATE PROMPT,20$		; IF PROMPT THEN TREAT SPECIAL
	BRB	40$			; CONTINUE
12$:	MOVZWL	UCB$W_BOFF(R5),R4	; GET PROMPT SIZE
	ADDL3	R4,UCB$L_SVAPTE(R5),@UCB$L_SVAPTE(R5); ADJUST POINTERFOR NOECHO
15$:	BRW	MOVEREADATA		;
;
; CONTROL R PROCESSING
;
CTRLR:	IF_STATE <ESC>,15$		; NO ACTION IF ESCAPE OR NO ECHO
	IF_NOT_STATE NOECHO,18$		; BRANCH IF ECHO
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_TT_DEVDP1(R5),15$	; BRANCH IF NOT LOCAL ECHO

18$:	ADDL3	#TTY$L_RB_DATA,UCB$L_SVAPTE(R5),@UCB$L_SVAPTE(R5);RESET POINTER
	MOVAB	W^TTY$A_CTRLR,R4	; ADDRESS MULTIECHO STRING
20$:	SET_STATE	<CTRLR>		; SET CONTROL R STATE
40$:	BRW	STRTMULTI		; START MULTIPLE OUTPUT SEQUENCE
 
	.DSABL	LSB

;
; DISPATCH TO READ ROUTINE IN ALTERNATE DRIVER
;
ALTREAD:

	MOVL	UCB$L_TT_ALTDRV(R5),R4	; GET ALTERNATE CLASS VECTOR
	BEQL	20$			; NONE ACTIVE
	JSB	@CLASS_PUTNXT(R4)	; CALL READ ROUTINE
	BLSS	5$			; ECHO STRING
	BNEQ	10$			; ECHO CHARACTER
	BRW	TTY$GETNEXTCHAR		; NO ECHO REQUESTED
5$:
	MOVL	R3,R4
	MOVW	R2,UCB$W_TT_ALTLEN(R5)
	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS
	BRW	STRTMULTI		; START STRING
10$:
	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS
	BRW	FORMAT_CHAR		; OUTPUT SINGLE CHARACTER
20$:	
	MOVZBW	#SS$_ABORT,UCB$W_BOFF(R5); SET STATUS
	BSBW	TTY$READONE		; COMPLETE THE I/O
	BRW	TTY$GETNEXTCHAR		; CONTINUE
	


	.SBTTL	FILLING - continue outputting fill characters

;++
; FILLING - CONTINUE FILL OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHILE THE TRM$V_FILL STATE IS ON.
; THE FILL COUNT IS DECREMENTED AND IF NON 0 A FILL IS OUTPUT
; IF THE COUNT GOES TO 0 THEN THE FILL STATE IS CLEARED.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = 0
;	R5 = UCB ADDRESS
;--
FILLING:				; OUTPUT CONTINUING FILLS
	DECB	UCB$B_TT_FILL(R5)	; ADJUST FILL COUNT
	BNEQ	25$			; IF NEQ THEN NOT DONE YET
	CLR_STATE FILL			; SET CONDITION OFF
25$:	CLRL	R3			; SET FILL CHARACTER
	BRW	OUTPUTANDWAIT1		; OUTPUT THE CHARACTER

	.SBTTL	EOLSEEN - handle end of line condition

;++
; EOLSEEN - END OF LINE SEEN
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AFTER AN END OF LINE CHARACTER HAS
; TERMINATED A READ RECORD AND THE ECHO OF THAT CHARACTER IS COMPLETE.
;
; THE ACTION IS TO COMPLETE THE READ OPERATION AND IF NECESSARY,
; SEND AN XOFF.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--
EOLSEEN:				; END READ OPERATION
	MOVZBW	#SS$_NORMAL,UCB$W_BOFF(R5); SET STATUS
	BSBW	TTY$READONE		; COMPLETE THE I/O
	BRW	TTY$GETNEXTCHAR		; CONTINUE

	.SBTTL	XOFF - output an XOFF character

	.ENABL	LSB
 
;++
; XON - SEND XON
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO SEND AN XON 
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = XON 
;	R5 = UCB ADDRESS
;--
XON:					; SEND AN XON

	CLR_STATE <TYPFUL>
	MOVZBL	#TTY$C_XON,R3		; SET XON CHARACTER

20$:	BITL	#TT$M_HOSTSYNC!TT$M_READSYNC,UCB$L_DEVDEPEND(R5); HOST OR READ SYNC?
	BNEQ	25$			; BR IF NOT NEEDED
	IF_STATE <OVRFLO>,30$		; PROCESS OVERFLOW CONDITION
24$:	BRW	GETNEXTCHAR		;
25$:
	CLR_STATE <OVRFLO>		; RESET CONDITION
	BRW	OUTPUTANDWAIT		; OUTPUT CHARACTER
 
30$:
	CLR_STATE <OVRFLO>		; RESET CONDITION
	MOVW	#SS$_DATAOVERUN,UCB$W_BOFF(R5); COMPLETE READ IN ERROR
	JSB	TTY$READONE
	BRB	24$			; CONTINUE

	.DSABL	LSB

	.SBTTL	CONTROLR - continue output after control-R

;++
; CONTROLR - CONTINUE OUTPUT AFTER A CONTROL R
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE DATA CONTAINED IN THE READ OPERATION
; BUFFERED I/O BLOCK. 
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT IF ANY
;	R5 = UCB ADDRESS
;--
CONTROLR:				; CONTINUE CONTROL R OUTPUT
;
; CONTINUE CONTROL R OUTPUT
;
	MOVZWL	UCB$W_BOFF(R5),R4	; GET PROMPT SIZE
	MOVZWL	UCB$W_BCNT(R5),R3	; GET CURRENT NUMBER OF BUFFERED CHARACTERS
	ADDL	R4,R3			; CALC TOTAL
	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
	ADDL	R4,R3			; POINT TO LAST CHARACTER IN READ BUFFER
	CMPL	R3,TTY$L_RB_NXT(R4)	; DONE?
	BEQL	120$			; IF EQL THEN YES
	IF_STATE CTRLO,120$		; ALSO DONE IF CONTROL O
	MOVZBL	@TTY$L_RB_NXT(R4),R3	; GET NEXT CHARACTER
	INCL	TTY$L_RB_NXT(R4)	; ADJUST POINTER
	BRW	FORMAT_CHAR		; OUTPUT READ DATA
;
; END OF CONTROL R
;
120$:	CLR_STATE <CTRLR,CTRLO>
	MOVL	R3,TTY$L_RB_NXT(R4)	; RESET PUT POINTER IN READ BUFFER
	BRW	GETNEXTCHAR

	.SBTTL	DELESCAPE - delete in progress escape sequence

;++
; DELETE AN ESCAPE SEQUENCE IN PROGRESS
;
; THIS ROUTINE IS USED BY THE CONTROL U AND DELETE LOGIC TO RESET
; AND DELETE THE ESCAPE SEQUENCE IN PROGRESS
;
DELESCAPE:				; DELETE CURRENT ESCAPE SEQUENCE
	MOVL	UCB$L_IRP(R5),R1	; GET ADDRESS OF PACKET.
	MOVZWL	IRP$L_MEDIA+2(R1),R4	; GET THE SIZE OF THE SEQUENCE
	SUBW	R4,UCB$W_BCNT(R5)	; ADJUST TRANSFER SIZE FOR SEQUENCE
	SUBW	R4,@UCB$L_SVAPTE(R5)	; ADJUST DATA POINTER
	CLRL	IRP$L_MEDIA(R1)		; CLEAR ESCAPE AND ESCAPE LENGTH
	CLR_STATE <ESC,BADESC>
10$:	RSB				; RETURN

	.SBTTL	DELCHAR - delete character routine

;++
; DELCHAR - DELETE CHARACTER ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE DELETES THE LAST TYPED CHARACTER FROM THE READ BUFFER.
; THEN IT SETS UP THE PROPER ECHO SEQUENCE FOR THE DELETED CHARACTER.
;
; INPUTS:
;
;	R2 = ADDRESS OF TTY STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF TTY STATE VECTOR
;	R5 = UCB ADDRESS
;--
DELCHAR:				;
	TSTW	UCB$W_BCNT(R5)		; ANY DATA?
	BEQL	30$			; IF EQL THEN NO
;
; IF ESCAPE SEQUENCE IN PROGRESS THEN DELETE ENTIRE STRING
;
	IF_STATE ESC,25$		; DELETE ESCAPE SEQUENCE
	DECW	UCB$W_BCNT(R5)		; ADJUST COUNT OF DATA CHARACTERS
	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
	DECL	TTY$L_RB_NXT(R4)	; ADJUST POINTER WORD
	MOVZBL	@TTY$L_RB_NXT(R4),R3	; GET THE CHARACTER
	IF_NOT_STATE NOECHO,5$		; BRANCH IF ECHO
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_TT_DEVDP1(R5),30$	; BRANCH IF NOT LOCAL ECHO

;
; TEST FOR SPECIAL DELETES
;
5$:	CMPB	R3,#TTY$C_TAB		; TAB?
	BNEQ	55$			; IF NEQ THEN OUTPUT JUST THE CHARACTER
	BBS	#TT$V_SCOPE,UCB$L_DEVDEPEND(R5),40$; BR IF SCOPE
	BRW	75$			; BR IF NOT SCOPE

25$:	BSBW	DELESCAPE		; DELETE ESCAPE SEQUENCE
30$:	BRW	MOVEREADATA		; VECTOR TO CONTINUE

;
; DELETE A TAB ON A SCOPE
;
40$:	MOVL	TTY$L_RB_NXT(R4),R3	; POINT TO END OF DATA
	MOVAB	TTY$L_RB_DATA(R4),R4	; POINT TO DATA START
	CLRL	-(SP)			; SET UP CURSOR COUNTER
10$:	CMPL	R3,R4			; BUFFER START?
	BEQL	15$			; THEN REFERENCE POINT FOUND
	CMPB	-(R3),#TTY$C_CR		; CARRIAGE RETURN?
	BEQL	20$			; IF EQL THEN REFERENCE POINT FOUND
	CMPB	(R3),#TTY$C_TAB		; TAB?
	BEQL	20$			; IF EQL THEN REFERENCE POINT FOUND
	CMPB	(R3),#TTY$C_BLANK	; CURSOR CHANGE CHARACTER?
	BLSSU	10$			; IF LSSU THEN NO
	INCL	(SP)			; ADJUST FAKE CURSOR
	BRB	10$			; CONTINUE
15$:	ADDW	TTY$W_RB_ORGHOR-TTY$L_RB_DATA(R4),(SP); IF BUFFER START FOUND, ASSUME INITIAL CURSOR
20$:	BICL3	#^X0FFFFFFF8,(SP)+,R4	; GET MOD 8 OF CURSOR
	TSTW	UCB$W_TT_CURSOR(R5)	; Have we wrapped?
	BEQL	60$			; Branch to simulate CTRL-R, if yes.
	CMPW	UCB$W_TT_CURSOR(R5), UCB$W_DEVBUFSIZ(R5) ; At extreme right?
	BLSSU	45$			; Branch if within screen bounds.
	BGTRU	47$			; Branch if beyond right edge.
	INCL	R4			; Adjust number of backspaces for
	BICL	#^C7, R4		; right-hand edge effects.
	BEQL	66$			; If no backspace, just delete at edge.
	DECW	UCB$W_TT_CURSOR(R5)	; Adjust cursor value for one less BS.
45$:	MOVAB	W^TTY$A_DELCRTTAB[R4],R4; Get address backspaces string.
	BRB	70$			; Go output them.

47$:	SUBW	#7, R4			; Adjust off-the-screen cursor
	ADDW	R4, UCB$W_TT_CURSOR(R5)	; position for deleted tab.
	BRB	66$			; Go do delete-at-edge.

;
; NORMAL CHARACTER DELETE
;
55$:	
	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
	W^TTY$A_TYPE[R3]		; TEST FOR SPECIAL
	BNEQ	62$			; NON PRINTING CHARACTER

	BBC	#TT$V_SCOPE,UCB$L_DEVDEPEND(R5),75$; BR IF NOT SCOPE
;
; IF THE CURSOR IS AT THE LEFT MARGIN AND DATA IS PRESENT,
; FORCE A CONTROL R IN STEAD OF A BACKSPACE.
;
	TSTW	UCB$W_TT_CURSOR(R5)	; CURSOR AT LEFT MARGIN?
	BNEQ	66$			; BR IF NORMAL BACKSPACE NEEDED
;
; FORCE CONTROL R FOR RUBOUT RESPONSE
;
60$:	
	TSTW	UCB$W_BCNT(R5)		; DATA PRESENT?
	BNEQ	63$			; IF DATA PRESENT, ECHO IT
62$:	BRW	MOVEREADATA		; IF NO DATA THEN NO RESPONSE
63$:	ADDL3	#TTY$L_RB_DATA,UCB$L_SVAPTE(R5),@UCB$L_SVAPTE(R5); SET UP INITIAL POINTER
	SET_STATE <CTRLR,NL>		;
65$:	BRW	CONTROLR		; START CONTROL R OUTPUT
;
; NORMAL BACKSPACE RUBOUT RESPONSE
;
66$:	MOVZBL	#TTY$C_BLANK,R3		; ASSUME SPACE IS FIRST CHARACTER
	CMPW	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5); AND EXTREME RIGHT?
	BGEQU	100$			; IF YES THEN ONLY OUTPUT SPACE
;
; DELETE IS IN MID SCREEN
;
	MOVAB	W^TTY$A_BACKSPACE+1,R4	; ADDRESS BACKSPACE STRING
70$:	MOVZBL	#TTY$C_BS,R3		; START STRING WITH BACKSPACE
	BRB	90$			; START OUTPUT
75$:	BBSS	#TTY$V_ST_DEL,4(R2),95$	; IF NOT FIRST TIME THEN OUTPUT CHARACTER
	MOVAB	UCB$W_BUFQUO(R5),R4	; ADDRESS STRING SPACE
	MOVZBW	R3,(R4)			; AND PUT THE CHARACTERS THERE
;
; OUTPUT "\" TO START OR END DELETE SEQUENCE
;
80$:	MOVZBL	#^A@\@,R3		; FOR FIRST TIME OUTPUT "\"
90$:	MOVL	R4,UCB$L_TT_MULTI(R5)	; ADDRESS STRING
	SET_STATE MULTI			;
95$:	BRB	FORMAT_CHAR		; START UP OUTPUT
100$:
	DECW	UCB$W_TT_CURSOR(R5)	; ADJUST CURSOR
	BRW	OUTPUTANDWAIT		; VECTOR FOR SPACE ONLY RESPONSE

	.SBTTL	FORMAT_LOCAL - FORMAT CHARACTER FOR OUTPUT
 
;++
; FORMAT_LOCAL - FIND PROPER OUTPUT FOR SPECIFIED CHARACTER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TRANSLATES THE SPECIFIED CHARACTER FOR OUTPUT
; ON THE TARGET UNIT FOR A NOECHO TERMINAL. THE OUTPUT OF THE 
; SEQUENCE MAY BE THE STARTUP OF THE PROPER MULTIECHO
; STRING. OTHERWISE, CURSOR ADJUSTMENT IS ALSO DONE HERE FOR PRINTING
; CHARACTERS AND FORM CHARACTERS. 
; IT IS POSSIBLE FOR THE RESULT TO BE NO OUTPUT.
;
; SEE EACH SPECIAL CHARACTER ROUTINE FOR MORE DETAILS ON ECHOING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO TRANSLATE
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT NEXT IF ANY
;	R5 = UCB ADDRESS
;--

FORMAT_LOCAL:
	CASE	W^TTY$A_TYPE[R3],LIMIT=#1@TTY$V_CH_SPEC,TYPE=B,<-
			BSPACE,-
			TAB_LOCAL,-
			LINEFEED,-
			VTAB,-
			FORM,-
			CARRIAGE,-
			CTRLZ,-
			ESCAPE>
;
; SPECIAL FORMATTING WAS NOT NEEDED - SIMPLY INCREMENT CURSOR
; FOR THE LOCALLY-ECHOED CHARACTER AND CONTINUE.
;
	BSBB	ADJUST_CURSOR		; ADJUST CURSOR
	BRW	GETNEXTCHAR		; GET ANOTHER CHARACTER


	.SBTTL	FORMAT_CHAR - FORMAT CHARACTER FOR OUTPUT
 
	.ENABL	LSB
;++
; FORMAT_CHAR - FIND PROPER OUTPUT FOR SPECIFIED CHARACTER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TRANSLATES THE SPECIFIED CHARACTER FOR OUTPUT
; ON THE TARGET UNIT. THE OUTPUT OF THE SEQUENCE IS EITHER
; THE ORIGIONAL CHARACTER OR A STARTUP OF THE PROPER MULTIECHO
; STRING. CURSOR ADJUSTMENT IS ALSO DONE HERE FOR PRINTING
; CHARACTERS AND FORM CHARACTERS. IT IS POSSIBLE FOR THE RESULT TO BE NO OUTPUT.
;
; SEE EACH SPECIAL CHARACTER ROUTINE FOR MORE DETAILS ON ECHOING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO TRANSLATE
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT NEXT IF ANY
;	R5 = UCB ADDRESS
;--
5$:	IF_NOT_STATE <ESC_O>,OUTPUTANDWAIT; BR IF NOT OUTPUT ESC
	BSBW	ESCSYNTAX_O		; CHECK CHAR AGAINST ESC SYNTAX
	BGTR	OUTPUTANDWAIT		; SYNTAX OK, OUTPUT CHARACTER
	BBSC	#TTY$V_ST_ESC_O,4(R2),-	; SEQUENCE ENDED CORRECTLY
		OUTPUTANDWAIT		; CLEAR STATE AND BRANCH ALWAYS
FORMAT_CHAR:
	IF_STATE <PASALL,ESC_O,WRTALL>,5$	; BR IF FORMAT NOT NEEDED
	CASE	W^TTY$A_TYPE[R3],LIMIT=#1@TTY$V_CH_SPEC,TYPE=B,<-		
			BSPACE,-
			TAB,-
			LINEFEED,-
			VTAB,-
			FORM,-
			CARRIAGE,-
			CTRLZ,-
			ESCAPE>

	PUSHAB	OUTPUTANDWAIT		; SET RETURN PC FOR ADJUST_CURSOR
					; AND FLOW INTO ADJUST_CURSOR

	.DSABL	LSB


	.SBTTL	ADJUST_CURSOR - Increment cursor and set wrap if needed

ADJUST_CURSOR:				; ADJUST CURSOR 

	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
	W^TTY$A_TYPE[R3]		; TEST FOR SPECIAL
	BNEQ	30$			; NON SPACING CHARACTER
	INCW	UCB$W_TT_CURSOR(R5)	; ADJUST CURSOR
	CMPW	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5) ; OVERRUN?
	BGEQU	5$			; YES

25$:	CLR_STATE -			; Set not at newline,
		<NL,SKIPLF,WRAP>	; clear SKIPLF and WRAP.
30$:	RSB

5$:	BBS	#TT$V_WRAP,UCB$L_DEVDEPEND(R5),10$; BR IF WRAP ENABLED
	BEQL	25$			; IF EQL THEN AT END OF LINE AND OK
	BBS	#TT$V_SCOPE, -		; IF SCREEN TERMINAL,CONTINUE
		UCB$L_DEVDEPEND(R5),25$	;
	TSTL	(SP)+			; DO NOT RETURN TO BSB TO DROP 
	BRW	DROP			; IF HARDCOPY,DROP CHARACTER
10$:	SET_STATE	CURSOR		; SET CURSOR OVERFLOWED
	BRB	25$
 

	.SBTTL	OUTPUTANDWAIT - OUTPUT CHARACTER AND WAIT FOR INTERRUPT
;++
; OUTPUTANDWAIT - OUTPUT A CHARACTER AND WAIT INTERRUPT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY THE OUTPUT INTERRUPT ROUTINES TO RETURN
; TO THE DEVICE DEPENDENT CODE TO OUTPUT A CHARACTER. THEIR RETURN
; CAUSES THE UNIT TO ENTER A WAIT FOR INTERRUPT STATE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	THE UNIT IS PLACED IN A WAIT FOR INTERRUPT STATE
;	AND THE CONDITION CODES ARE SET TO PLUS INDICATING
;	SINGLE CHARACTER IN R3.
;
;	R5 = UCB ADDRESS
;--
OUTPUTANDWAIT:				; OUTPUT CHARACTER AND WAIT ENTRY
	MOVB	R3,UCB$B_TT_LASTC(R5)	; SAVE LAST CHARACTER OUTPUT
OUTPUTANDWAIT1:
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5); SET FUTURE TIMEOUT
	DSBINT	,R1			; SET TO POWER FAIL LEVEL
	BBS	#UCB$V_POWER,UCB$W_STS(R5),POWER; POWER FAILED BEFORE HERE?
	BISB	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5); ENABLE TIMER AND INTERRUPT
	ENBINT	R1			; ENABLE INTERRUPTS
	BICPSW	#^X0C			; SIGNAL SINGLE CHARACTER
	RSB				; AND RETURN WITH CHARACTER
;
; POWER FAIL EXIT
;
POWER:	ENBINT	R1			; RE-ENABLE INTERRUPTS
	BICW	#UCB$M_POWER,UCB$W_STS(R5); RESET POWERFAIL
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE VECTOR
	SET_STATE REFRSH		; FORCE READS TO BE REFRESHED
	BSBW	TTY$RESTARTIO		; SET UP THE CURRENT I/O
	BRW	GETNEXTCHAR		; CONTINUE AGAIN


	.SBTTL	CURSOROVRFLOW - insert newline to handle end of line

	.ENABL	LSB

;++
; CURSOROVRFLOW - INSERT A NEWLINE IN THE OUTPUT STREAM
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO INJECT A CR/LF IN THE OUTPUT
; STREAM REGARDLESS OF THE CURRENT STATE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_CR
;	R5 = UCB ADDRESS
;--
CURSOROVRFLOW:				;
	CLR_STATE CURSOR		; CLEAR THE CONDITION
	SET_STATE WRAP			; Signal WRAPping.
	MOVZBL	#TTY$C_CR,R3		; SET FIRST CHARACTER IS CARRIAGE RETURN
	BRB	110$			; CONTINUE WITH CARRIAGE RETURN CODE

	.SBTTL	CARRIAGE - format a carriage return

;++
; CARRIAGE - FORMAT FOR CARRIAGE RETURN
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP THE PROPER FILL FOR A CARRIAGE RETURN ON
; THE TARGET UNIT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_CR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_CR
;	R5 = UCB ADDRESS
;--
CARRIAGE:				;
	CLR_STATE <NL>			; SET NOT AT NEW LINE.
	IF_STATE -			; If in a write state, branch
		WRITE,115$		; forward.
	IF_NOT_STATE -			; If not in a read state, also
		READ,115$		; branch forward.
	IF_NOT_STATE CTRLR,110$		; 
	MOVZWL	UCB$W_BOFF(R5),R4	; GET PROMPT SIZE
	ADDL	UCB$L_SVAPTE(R5),R4	; CALC ADDRESS OF PROMPT END
	CMPL	@UCB$L_SVAPTE(R5),R4	; IS THIS CR PAST END OF PROMPT?
	BGEQU	110$			; Yes. Force LF and skip next real one.
	ADDL3	#TTY$L_RB_DATA,-	; Find start of prompt string.
		UCB$L_SVAPTE(R5),R4
	CMPL	@UCB$L_SVAPTE(R5),R4	; Are we at start of prompt?
	BNEQ	115$			; No. No forced LF.
110$:
	SET_STATE <SENDLF,SKIPLF>	; SET STATE TO FORCE LF AND SKIP NEXT REAL ONE
115$:
	CLRW	UCB$W_TT_CURSOR(R5)	; RESET HORIZON
	CMPB	UCB$B_TT_LASTC(R5), -	; OPTIMIZATION: WAS LAST CHAR
		#TTY$C_CR		; A CARRIAGE RETURN?
	BEQL	DROP			; YES, DON'T OUTPUT ANOTHER
	MOVB	UCB$B_TT_CRFILL(R5),UCB$B_TT_FILL(R5); SET UP FILL
	BEQL	120$			; IF EQL THEN OUTPUT
	SET_STATE FILL			; OTHERWISE OUTPUT
120$:	BRW	OUTPUTANDWAIT
DROP:	BRW	GETNEXTCHAR		; CONTINUE IN NEXT LOGICAL STATE

	.SBTTL	SENDLINEFEED - output a line feed

;++
; SENDLINEFEED - INSERT LINE FEED IN OUTPUT STREAM
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO INSERT A LINE FEED IN THE OUTPUT STREAM.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_LF
;	R5 = UCB ADDRESS
;--
SENDLINEFEED:				; SEND OUT A LINE FEED
	CLR_STATE SENDLF		; CLEAR CONDITION
	MOVZBL	#TTY$C_LF,R3		; SET TO OUTPUT LINE FEED
	BRB	200$			; CONTINUE IN LINE FEED CODE

	.SBTTL	LINEFEED - format a line feed

;++
; LINEFEED - FORMAT LINE FEED FOR TARGET UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP THE PROPER FILL FOR A LINE FEED ON THE TARGET
; UNIT AND ADJUSTS THE CURSOR AND VERTICAL LINE COUNT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_LF
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_LF
;	R5 = UCB ADDRESS
;--
LINEFEED:
	BBSC	#TTY$V_ST_SKIPLF,4(R2),DROP; SKIP AND SET OFF SKIP CONDITION
;
; NOTE THAT BECAUSE OF ACBB'S SIGNED BRANCH IT IS NOT APPROPRIATE HERE.
;
200$:	TSTW	UCB$W_TT_CURSOR(R5)	; LINE FEED AT CURSOR 0 IS NEWLINE
	BNEQ	210$			; IF NEQ THEN NO NL POSSIBLE
	SET_STATE NL			; SET NEW LINE
210$:	INCB	UCB$B_TT_LINE(R5)	; ADJUST VERTICAL COUNT
	CMPB	UCB$B_TT_LINE(R5),UCB$L_DEVDEPEND+3(R5);
	BLSSU	215$			; IF LSSU THEN NO PAGE CROSS
	CLRB	UCB$B_TT_LINE(R5)	; RESET VERTICAL POSITION
215$:	IF_NOT_STATE WRITE,220$		; BR IF NOT WRITE
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Address current write buffer.
	MOVL	TTY$L_WB_IRP(R4),R4	; Get associated IRP address.
	BEQL	220$			; Branch if no IRP.
	INCW	IRP$L_MEDIA(R4)		; COUNT LINE
220$:	MOVB	UCB$B_TT_LFFILL(R5),UCB$B_TT_FILL(R5); INSERT TO CAUSE FILL
	BEQL	225$			; OUTPUT IF NO FILL NEEDED
	SET_STATE FILL			; OUTPUT FILL CHARACTERS
225$:	BRW	OUTPUTANDWAIT

	.SBTTL	ESCAPE - format an escape character

;++
; ESCAPE - FORMAT A ESCAPE BASED ON OPERATION AND TARGET UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE FORMATS ESCAPES.
;
; READ OPERATION:
;
;	A "$" IS ECHOED IF THE ESCAPE IS A TERMINATOR.
;
; WRITE OPERATION:
;
;	THE ESCAPE IS OUTPUT. ON TERMINALS WITH THE CHARACTERISTIC TT$M_ESCAPE,
;	THE REMAINDER OF THE SEQUENCE IS CHECKED FOR SYNTACTIC CORRECTNESS.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = ESCAPE
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = ESCAPE OR "$"
;	R5 = UCB ADDRESS
;--
ESCAPE:					; OUTPUT ESCAPE STRING
	IF_NOT_STATE EOL,250$		; ALSO IF NOT TERMINATOR
	MOVZBL	#TTY$C_DOLLAR,R3	; OTHERWISE ECHO DOLLAR SIGN
	BSBW	ADJUST_CURSOR		; ADJUST CURSOR 
	BRW	OUTPUTANDWAIT		; AND OUTPUT
;
; OUTPUT ESCAPE ON WRITE OR CONTROL R
;
250$:
	BBS	#TT2$V_ANSICRT,UCB$L_DEVDEPND2(R5),255$ ; BR IF ANSI TERMINAL
	BBS	#TT$V_ESCAPE,UCB$L_DEVDEPEND(R5),255$; BR IF ESCAPE TERMINAL
	CMPB	#TT$_VT5X,UCB$B_DEVTYPE(R5) ;VT5X OR VT100 TERMINAL?
	BLEQU	252$			; If LEQU, then maybe.
	BRB	260$			; Otherwise, no.

252$:
	CMPB	#TT$_VT100+32,UCB$B_DEVTYPE(R5);
	BGTRU	255$			; If GTRU, then yes.
	BRB	260$			; Otherwise, no.

255$:
	SET_STATE <ESC_O>		; OUTPUTTING AN ESCAPE SEQUENCE
	CLRB	UCB$B_TT_ESC_O(R5)	; SET FIRST ESC SYNTAX RULE
260$:
	CLRW	UCB$W_TT_CURSOR(R5)	; ZERO CURSOR (COLUMN) POSITION
	BRW	OUTPUTANDWAIT

	.SBTTL	CTRLZ - output control-Z

;++
; CTRLZ - OUTPUT A CONTROL Z BASED ON THE OPERATION
;
; FUNCTIONAL DESCRIPTION:
;
; IF THE CURRENT OPERATION IS A READ AND THE ^Z IS A TERMINATOR THE ECHO ^Z.
;
; INPUTS:
;
; 	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CONTROL Z
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CONTROL Z
;	R4 = ADDRESS OF THE MULTIECHO STRING FOR CONTROL Z IF APPROP.
;	R5 = UCB ADDRESS
;--
CTRLZ:					; CONTROL Z
	IF_NOT_STATE READ,300$		; OUTPUT 26(8) IF NOT READ
	IF_NOT_STATE EOL,300$		; ^Z IF TERMINATOR
	MOVAB	W^TTY$A_CTRLZ,R4	; ADDRESS MULTIECHO STRING
	BRW	STRTMULTI		; START OUTPUT
300$:	BRW	OUTPUTANDWAIT

	.SBTTL	BACKSPACE - output a backspace

;++
; BACKSPACE - OUTPUT A BACKSPACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS A BACKSPACE ON  A TERMINAL.
; SEVERAL CONDITIONS EXIST:
;
; MULTIPLE ECHO IS PROGRESS --
;
;		DECREMENT THE CURSOR AND CONTINUE.
;
; Read in progress and no data -- output the backspace.
;
; READ IN PROGRESS AND DATA -- OUTPUT A BS/SPACE/BS STRING.
;
; WRITE IN PROGRESS -- OUTPUT BS.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_BS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_BS
;	R4 = ADDRESS OF THE BS/SPACE/BS STRING IF APPROP.
;	R5 = UCB ADDRESS
;--
BSPACE:					; BACKSPACE
	IF_STATE MULTI,430$		; IF MULTI STATE THE OUTPUT
;
; IF NOT IN READ THEN OUTPUT DIRECTLY
;
	IF_NOT_STATE READ,430$		;
;
; IF IN READ THEN ECHO BS/SPACE/BS IF ANY PRESENT DATA
;
	TSTW	UCB$W_BCNT(R5)		; ANY DATA YET?
	BEQL	430$			; If no data, then output char.
	MOVAB	W^TTY$A_BACKSPACE+1,UCB$L_TT_MULTI(R5); ADDRESS MULTIECHO STRING
;
; WRITE OF A BACKSPACE
;
430$:	DECW	UCB$W_TT_CURSOR(R5)	; ADJUST HORIZON
	BRW	OUTPUTANDWAIT		; OUTPUT THE CHARACTER
435$:	BRW	GETNEXTCHAR		; CONTINUE

	.SBTTL	VTAB - output a vertical tab

;++
; VTAB - OUTPUT A VERTICAL TAB
; FORM - OUTPUT A FORM FEED
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP THE PROPER OUTPUT STRING FOR A VTAB OF FORM FEED
; ON THE TARGET UNIT.  VTAB TRANSLATES TO 4 LINE FEEDS. AND FORM FEED
; TO MULTIPLE LINE FEEDS BASED ON THE PRESENCE OF MECHANICAL HELP
; AND THE CURRENT VERTICAL LINE POSITION. TO AVOID THE NECESSITY
; FOR A LARGE NUMBER OF LF DATA BYTES THE FORM FEED CAUSES A MULTI
; ECHO STRING OF 4 LINE FEEDS FOLLOWED BY ANOTHER FORM FEED TO BE
; OUTPUT UNTIL A PAGE CROSS TAKES PLACE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = C_VTAB OR C_FF
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--
VTAB:	MOVAB	W^TTY$A_VTAB,R4		; SET UP OUTPUT
	BRW	STRTMULTI		; START MULTIPLE OUTPUT
;
; FORM FEED
;
FORM:	BBC	#TT$V_MECHFORM, -	; BRANCH IF TERMINAL DOES NOT
		UCB$L_DEVDEPEND(R5), -	; SUPPORT MECHNICAL FORM FEEDS
		505$			;
	CLRB	UCB$B_TT_LINE(R5)	; RESET LINE POSITION
	BRW	OUTPUTANDWAIT		;
505$:	CLRL	R4			; SEND MULTIPLE LINE FEEDS
	SUBB3	UCB$B_TT_LINE(R5),UCB$L_DEVDEPEND+3(R5),R4; GET NUMBER TO END OF PAGE
	CMPB	R4,#4			; OUTPUT THE LF'S IN GROUPS OF 8
	BGTRU	520$			; IF GTRU THEN MORE THAN 4 TO OUTPUT
510$:	SUBL3	R4,#4,R4		; ADJUST FOR OFFSET FROM 4
	MOVAB	W^TTY$A_FORM[R4],R4	; GET THE ADDRESS OF THE STRING
	BRB	STRTMULTI		; START OUTPUT
520$:	MOVAB	W^TTY$A_LONGFORM,R4	; GET ADDRESS TO STRING
	BRB	STRTMULTI		;

	.SBTTL	TAB - Output a tab.

;++
; TAB - OUTPUT A TAB ON THE TARGET TERMINAL BASED ON CURSOR POSITION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO OUTPUT A TAB ON THE TARGET UNIT.
; IF THE TERMINAL HAS MECHANICAL TAB THEN THE TAB GOES DIRECT.
; OTHERWISE, THE CURSOR POSITION IS USED TO CALC. HOW MANY BLANKS
; TO OUTPUT TO MOVE THE CURSOR TO THE NEXT TAB STOP.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_TAB
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_TAB
;	R4 = ADDRESS OF TAB MULTIECHO STRING IF APPROP.
;	R5 = UCB ADDRESS
;--
TAB:	EXTZV	#0,#3,UCB$W_TT_CURSOR(R5),R4; GET HORIZON POINTER
	BBS	#TT$V_MECHTAB,UCB$L_DEVDEPEND(R5),530$; OUTPUT IF MECHANICAL HELP
525$:	MOVAB	W^TTY$A_TAB[R4],R4	; ADDRESS STRING TO OUTPUT
	BRB	STRTMULTI		; START MULTIPLE OUTPUT
;
; MECHANICAL TAB TERMINAL
;
; THIS ROUTINE ASSUMES THAT THE TABS ARE SET ON 8'S
;
530$:	CMPB	#TT$_VT5X,UCB$B_DEVTYPE(R5); IN RANGE FOR SPECIAL CASE VT5X
	BGTRU	535$			; IF GTR THEN NO
	CMPB	#TT$_VT100+32,UCB$B_DEVTYPE(R5); 
	BLEQU	535$			; 
	SUBW3	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5),R3; DISTANCE FROM RIGHT
	BLEQU	534$			; IF LEQU THEN SKIP TEST
	CMPW	#8,R3			; IN LAST TAB SPACE?
	BGEQU	525$			; IF TRUE THEN SKIP MECH TAB
534$:	MOVZBL	#TTY$C_TAB,R3		;
535$:	BICW	R4,UCB$W_TT_CURSOR(R5)	; SETUP CURSOR STOP ON 8
	ADDW	#8,UCB$W_TT_CURSOR(R5)	;
	CLR_STATE -			; No longer at newline; haven't
		<NL,WRAP>		; just wrapped.
	BRW	OUTPUTANDWAIT		;
;
; FOR LOCAL TABS, TRACK POSITION, BUT DON'T ECHO
;

TAB_LOCAL:
	EXTZV	#0,#3,UCB$W_TT_CURSOR(R5),R4; GET HORIZON POINTER
	BICW	R4,UCB$W_TT_CURSOR(R5)	; SETUP CURSOR STOP ON 8
	ADDW	#8,UCB$W_TT_CURSOR(R5)	;
	CLR_STATE -	
		<NL,WRAP>
	BRW	GETNEXTCHAR		; GET NEXT OUTPUT CHARACTER

 
	.DSABL	LSB

	.SBTTL	STRTMULTI - Start multiecho sequence

;++
; STRTMULTI - START MULTIECHO ON UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE STARTS A SPECIFIED MULTIECHO STRING OUT ON A UNIT.
; THE FIRST CHARACTER IS PICKED OUT AND THE ADDRESS OF THE REMAINDER
; IS PLACED IN UCB$L_TT_MULTI FOLLOWED BY THE SETTING OF THE MULTIECHO
; IN PROGRESS STATE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R4 = ADDRESS OF THE MULTIECHO STRING
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = FIRST CHARACTER
;	R5 = UCB ADDRESS
;--
STRTMULTI:
	SET_STATE MULTI			; SET THE STATE
	MOVL	R4,UCB$L_TT_MULTI(R5)	; INSERT ADDRESS TO REMAINDER

	.SBTTL	MULTIECHOING - Continue outputting multiecho sequence

;++
; MULTIECHOING - CONTINUE MULTIECHO STRING OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN TTY$V_ST_MULTI IS SET. THE NEXT
; CHARACTER IN THE STRING ADDRESSED BY UCB$L_MULTIECHO IS OUTPUT.
; IF THE NEXT CHARACTER IS ZERO THEN THE STRING OUTPUT IS COMPLETE
; AND THE MULTIECHO CONDITION IS RESET FOLLOWED BY A RETURN TO
; THE OUTPUT STATE ANALYSIS ROUTINE IN GETNEXTCHAR.
; IF A LENGTH IS SPECIFIED, THEN IT IS USED TO DETECT THE
; END OF STRING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
;	UCB$W_TT_ALTLEN = ALTERNATE LENGTH
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT ( FALL THROUGH TO ECHOFORMAT )
;	R5 = UCB ADDRESS
;--
MULTIECHOING:				; CONTINUE STRING MULTI ECHO
	MOVZBL	@UCB$L_TT_MULTI(R5),R3	; GET NEXT MULTI ECHO CHARACTER
	BNEQ	10$			; IF NEQ THEN CONTINUE
	TSTW	UCB$W_TT_ALTLEN(R5)	; CHECK FOR LENGTH
	BNEQ	10$
	CLR_STATE MULTI			; RESET STATE
	BRW	GETNEXTCHAR		; CONTINUE

10$:	INCL	UCB$L_TT_MULTI(R5)	; ADJUST POINTER
	TSTW	UCB$W_TT_ALTLEN(R5)	; CHECK FOR LENGTH
	BEQL	20$			; NONE
	DECW	UCB$W_TT_ALTLEN(R5)	; USE IF SPECIFIED
	BNEQ	20$
	CLR_STATE MULTI			; RESET STATE
20$:	BRW	FORMAT_CHAR		;


	.SBTTL	ESCSYNTAX -- CHECK ESCAPE SEQUENCE SYNTAX

;++
; FUNCTIONAL DESCRIPTION:
;	This routine checks the syntax of escape sequences, one
;	character at a time.
;
; INPUTS:
;	R3 contains the next character to be checked for correct syntax
;	UCB$B_TT_ESC(R5) contains a offset to the next syntax
;		rule in the TTY$A_ESCAPE syntax table for input data.
;	UCB$B_TT_ESC_O(R5) contains the offset for output data.
;	Assume R4 is available
;
; OUTPUTS:
;	Condition codes are set:
;	CC = POSITIVE means the character is syntactically correct
;	CC = EQUAL means syntactic correctness and sequence is complete
;	CC = NEGATIVE means error in parsing sequence
;
;	If CC = POSITIVE the UCB$B_TT_ESC (ESC_O) offset is updated.
;--

;
; INPUT ESCAPE SEQUENCES
;

ESCSYNTAX:
	MOVZBL	UCB$B_TT_ESC(R5),R4	; GET CURRENT STATE
	BSBB	E_SYNTAX
	MOVB	R4,UCB$B_TT_ESC(R5)	; SAVE STATE
	RSB

;
; OUPUT ESCAPE SEQUENCES
;

ESCSYNTAX_O:
	MOVZBL	UCB$B_TT_ESC_O(R5),R4	; GET CURRENT STATE
	BSBB	E_SYNTAX
	MOVB	R4,UCB$B_TT_ESC_O(R5)	; SAVE CURRENT STATE
	RSB


;
; GENERAL SEQUENCE HANDLER
;

E_SYNTAX::

10$:	CMPB	R3, W^TTY$A_ESCAPE[R4]	; check range of character
	BLSSU	20$			; branch if not this rule
	CMPB	R3, W^TTY$A_ESCAPE+1[R4]; lower than high limit?
	BGTRU	20$			; look to next rule

	MOVB	W^TTY$A_ESCAPE+2[R4],-	; character is valid
		R4			; save offset to next rule

	RSB				; offset=POS => next rule exists
					; offset=0 => end of sequence

;
; Continue looking for correct sequence rule
;
20$:	TSTB	W^TTY$A_ESCAPE+2[R4]	; any next rule?
	BEQL	30$			; no; bad syntax
	ADDL	#3, R4			; offset to next rule
	BRB	10$			; continue syntax check
30$:	
	MNEGL	#1, R4			; error in sequence
	RSB


	.SBTTL	BRDCST - Complete a broadcast operation.

;++
; BRDCST - Complete a broadcast
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine gains control when a broadcast message has been
;	entirely output on the terminal. If holdscreen was in effect
;	before the broadcast, restore the holdscreen state.
;	This routine forks on the write buffer block. The fork process
;	will regain control in the broadcast system service code. After
;	the fork process is queued, control returns to TTY$GETNXTWRITE
;	in TTYSTRSTP.
;
; INPUTS:
;
;	R2	- address of the UCB state vector
;	R5	- address of the UCB
;
; OUTPUTS:
;
;	In the fork process, registers will be:
;
;		R3	- contents of TTY$L_WB_END field
;		R5	- address of buffer header block
;
;	In TTY$GETNXTWRITE, 2 words are on the stack:
;
;		0(SP)	- address of state longword
;		4(SP)	- address of the UCB
;
;--

BRDCST:					; Complete broadcast.
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Get address of write buffer
					; header.
	CMPL	TTY$L_WB_NEXT(R4),-	; Is the starting address the
		TTY$L_WB_END(R4)	; same as the ending address?
	BGTRU	10$			; No. Must have already checked
					; for holdscreen restoration.
	BBC	#TT$V_HOLDSCREEN,-	; If holdscreen not specified,
		UCB$L_DEVDEPEND(R5),10$	; just branch.
	INCL	TTY$L_WB_NEXT(R4)	; Change next pointer so that
					; holdscreen code happens once.
	MOVAB	W^TTY$A_HLDSCREEN,R4	; Set up holdscreen multiecho
					; sequence.
	BRW	STRTMULTI		; Output sequence.

10$:					; Finish the broadcast.
	CLR_STATE -			; Turn off the broadcast
		<BRDCST,BRDP>		; state bits.
	MOVL	UCB$L_TT_PORT(R5),R1	; Access port vector
	BBCC	#TTY$V_SX_CTRLSP, -	; Were we in CTRL-S state
		(R2),15$		; before broadcast?
	BBS	#31,UCB$L_DEVDEPND2(R5),-; Skip for DZ11s
		15$
	JSB	@PORT_STOP(R1)		; Stop port output
15$:
	PUSHAB	20$			; Set up a return from
					; TTY$GETNXTWRITE.
	PUSHR	#^M<R2,R5>		; Save state and UCB address.
	PUSHAB	G^TTY$GETNXTWRITE	; Want control to return to
					; GETNXTWRITE after queuing
					; fork process to complete
					; broadcast.
	PUSHL	TTY$L_WB_RETADDR(R4)	; Want fork process to gain control
					; in SYSBRDCST or other completion routine
	MOVL	R4,R5			; Make buffer header the fork
					; block.
	MOVB	#IPL$_QUEUEAST,-	; Fork IPL is 6
		TTY$B_WB_FIPL(R4)	; in case we destroyed it.
	MOVL	TTY$L_WB_END(R4),R3	; Set up end address of message
					; string for fork process use.
	JMP	G^EXE$FORK		; Fork.

20$:					; Control returns here from
	BRW	TTY$GETNEXTCHAR		; GETNXTWRITE, and goes off to
					; find the next character to 
					; output.

	.SBTTL	End of module

	.END
