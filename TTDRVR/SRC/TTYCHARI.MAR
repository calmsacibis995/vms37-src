	.TITLE	TTYCHARI - terminal input character routines
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES NEEDED FOR CHARACTER INPUT.
;
; AUTHOR:
;
;	R.HEINEN  11-AUG-1976
;
; Revision history:
;
;	V02-026	RKS0026		RICK SPITZ			25-JAN-1982
;		CHANGE CONTROL O LOGIC TO WORK WITH BURST MODE OUTPUT
;		(PREVENT WRAP IN MID LINE)
;
;	V02-025	RKS0025		RICK SPITZ			15-DEC-1981
;		CHANGE INSPOST CALL TO WRITE POST IN CTRLC,Y LOGIC.
;
;	V02-024	RKS0024		RICK SPITZ			20-NOV-1981
;		ADD OUT OF BAND SUPPORT
;
;	V02-023	JLV0099		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-022	RKS022		RICK SPITZ			20-AUG-1981
;		ADD ALTERNATE TYPEAHEAD SIZE SUPPORT
;
;	V02-021	RKS021		RICK SPITZ			12-AUG-1981
;		CORRECT DEFINITION NAMES
;
;	V02-020	JLV0062		Jake VanNoy			10-Aug-1981
;		Added autobaud code.
;		
;	V02-019	RKS019		RICK SPITZ			27-JULY-1981
;		SEVERAL NEW FEATURES HAVE BEEN ADDED TO SUPPORT THE 
;		CLASS/PORT STRUCTURE OF THE TERMINAL SERVICES. THESE
;		INCLUDE ENHANCEMENTS TO SUPPORT QUADWORD STATE AND
;		MOVING MOST XON/XOFF LOGIC TO THE PORT DRIVER. THE
;		PORT FUNCTIONS RESUME AND STOP(2) ARE USED TO HANDLE
;		RECEIVED CONTROL S AND Q. LOGIC TO HANDLE CONTROL S
;		DURING A BROADCAST IS ALSO INCLUDED.
;
;	V02-018	RKS018		RICK SPITZ			26-FEB-1981
;		REMOVE V2.0 AUDIT TRAILS
;
;--

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS
;
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL'S
	$IRPDEF				; DEFINE IRP
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$SSDEF				; DEFINE SYSTEM SERVICE STATUS CODES
	$UCBDEF				; DEFINE UCB
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE TERMINAL CHARACTERISTICS
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
 
	.PSECT	$$$115_DRIVER,LONG	; DEFINE NON-PAGED PSECT

	.SBTTL	CONTROLC, CONTROLY handlers
 
	.ENABL	LSB

;++
; CONTROLC - SIGNAL CONTROL C INPUT
; CONTROLY - SIGNAL CONTROL Y INPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CONTROL C OR Y IS TYPED.
; THE ACTION IS TO SIGNAL, VIA AN AST, THE HOLDER OF THE AST ENABLE.
; IF NO ENABLE IS PRESENT, AN ATTEMPT IS MADE TO SIGNAL THE JOB CONTROLLER
; IF IT HAS NOT BEEN SIGNALED.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
; 	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
;--

CONTROLC:				; ENTRY FOR CONTROL C
	MOVAL	UCB$L_TT_CTRLC(R5),R4	; GET ADDRESS OF CONTROL C AST LIST
	TSTL	(R4)			; EMPTY?
	BEQL	10$			; IF EQL THEN NO CTRLC
	MOVAB	W^TTY$A_CTRLC,R3	; ADDRESS EVENTUAL OUTPUT STRING
	MOVZWL	#SS$_CONTROLC,UCB$W_BOFF(R5)	; SET STATUS AND ZERO COUNT
	BRB	15$
;
; CONTROL Y PROCESSING
;

CONTROLY:
10$:	MOVAL	UCB$L_TT_CTRLY(R5),R4	; GET ADDRESS OF CONTROL Y AST LIST
	TSTL	(R4)			; EMPTY LIST?
	BNEQ	13$			; No, branch forward.
	BRW	100$			; Yes. Don't process it.

13$:
	MOVAB	W^TTY$A_CTRLY,R3	; ADDRESS EVENTUAL OUTPUT STRING
	MOVZWL	#SS$_CONTROLY,UCB$W_BOFF(R5)	; SET STATUS AND ZERO COUNT
15$:	MOVL	R3,UCB$L_TT_MULTI(R5)	; SET UP FOR MULTIECHO
	JSB	G^COM$DELATTNAST	; DELIVER ATTENTION ASTS
	BSBW	TTY$PURGE_AHEAD		; PURGE THE TYPEAHEAD
	SET_STATE MULTI			;
	BBC	#TT$V_HOLDSCREEN,UCB$L_DEVDEPEND(R5),20$; BR IF NOT IN HOLD SCREEN.
	ADDL	#7,UCB$L_TT_MULTI(R5)	; ADJUST STRING ADDRESS TO REMOVE
					; HOLDSCREEN, SEND ^Y OR ^C, AND
					; REINSTATE HOLDSCREEN.
20$:
	MOVAB	UCB$L_TT_WFLINK(R5),R1	; Get start of write queue.
	MOVL	R1,R3			; Copy it to check for end.

30$:
	MOVL	TTY$L_WB_FLINK(R3),R3	; Get next entry.
	CMPL	R3,R1			; At end of queue?
	BEQL	50$			; Yes. Branch forward.
	MOVL	TTY$L_WB_IRP(R3),R4	; Get associated IRP address.
	BEQL	30$			; If no IRP, it's a broadcast,
					; leave it in the queue.
	MOVL	TTY$L_WB_BLINK(R3),R3	; Get entry's backward link.
	REMQUE	@TTY$L_WB_FLINK(R3),R4	; Remove the link.
	BSBW	TTY$WRITEPOST		; Queue it for completion
	BRB	30$			; Try for next link.

50$:					; Stop the current I/Os.
	IF_NOT_STATE -			; Branch forward if no read is
		READ,60$		; currently in progress.
	CLR_STATE -			; Clear escape bits.
		<ESC,BADESC>
	MOVL	UCB$L_IRP(R5),R4	; Get address of IRP.
	CLRL	IRP$L_MEDIA(R4)		; Clear terminators.
	BSBW	TTY$READONE		; Complete the read.

60$:					; Check for a write to complete.
	IF_STATE -			; Ignore broadcasts.
		BRDCST,70$
	IF_NOT_STATE -			; Branch forward if no write is
		WRITE,70$		; in progress.
	MOVL	UCB$L_TT_PORT(R5),R3	; Access port vector
	JSB	@PORT_ABORT(R3)		; Abort any current output activity
	JSB	@PORT_RESUME(R3)	; Restart output
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write packet.
	MOVW	UCB$W_BOFF(R5),-	; Put status code in the
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete the I/O.

70$:					; And echo the control char.
	BRB	CANCEL_CTRLS		; CANCEL CONTROL S AND BEGIN ECHO

	.SBTTL	CONTROLX handler

;++
; CONTROLX - PURGE TYPEAHEAD BECAUSE OF CONTROL X INPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PURGES THE TYPEAHEAD BUFFER AND IF THE REASON IS THAT
; A CONTROL X WAS TYPED DURING A READ THEN A CONTROL U IS INSERTED IN
; THE INPUT STREAM TO PURGE THE CURRENT INPUT LINE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CONTROL U - IF CONTROL X TYPED DURING READ
;	R5 = UCB ADDRESS
;--

CONTROLX:
	BSBW	TTY$PURGE_AHEAD		; PURGE TYPEAHEAD
	IF_NOT_STATE READ,75$		; DONE IF NO READ IN PROGRESS
	MOVZBL	#TTY$C_CTRLU,R3		; FORCE A CONTROL U IN INPUT STREAM
	BRB	100$			; CONTINUE AND BUFFER CHARACTER

	.SBTTL	CONTROLS handler

;++
; CONTROLS - STOP OUTPUT TO UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE USER TYPES A CONTROL S.
; ON UNITS THAT DO NOT HAVE THE TM$_NOTTSYNC CHARACTERISTIC, THE OUTPUT
; IS STOPPED BY TURNING THE OUTPUT INTERRUPT ENABLE BIT IN THE UCB
; OFF. A control-S is ignored if a broadcast is underway.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

CONTROLS:
	BBC	#TT$V_TTSYNC,UCB$L_DEVDEPEND(R5),100$; TERMINAL SYNCH?
	MOVL	UCB$L_TT_PORT(R5),R1	; ACCESS PORT VECTOR
	IF_STATE BRDP,80$		; IGNORE IF BROADCAST IN PROGRESS
	JSB	@PORT_STOP(R1)		; STOP PORT OUTPUT
75$:					; IGNORE CHARACTER OR RETURN WITH NO OUTPUT
	CLRL	R3			; SET NO CHARACTER TO RETURN
	RSB				; AND RETURN TO DRIVER CODE
80$:
	JSB	@PORT_STOP2(R1)		; STOP PORT OUTPUT (LIMITED TIME)
	BRB	75$

	.SBTTL	CONTROLQ handler

;++
; CONTROLQ - START OUTPUT ON CONTROL S STOPPED UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE STARTS OUTPUT ON A UNIT WHICH IS STOPPED BECAUSE
; OF CONTROL S.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

CONTROLQ:
	BBS	#TT$V_TTSYNC,UCB$L_DEVDEPEND(R5),CANCEL_CTRLS; TERMINAL SYNCH?
100$:	BRW	BUFFER_CHAR		; BUFFER THE CHARACTER NORMALLY
 

	.SBTTL	CONTROLO handler

;++
; CONTROLO - START OR STOP OUTPUT ON UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TOGGLES THE OUTPUT ENABLE OF A UNIT.
; OUTPUT IS STOPPED UNTIL THE NEXT READ OPERATION, IO$_WRTCANCTRLO
; OR CONTROL O.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

CONTROLO:

	IF_NOT_STATE READ,120$		; IF NOT READ THEN HONOR
	IF_NOT_STATE CTRLR,75$		; IF CONTROL R THEN IGNORE
120$:	XORW	#<TTY$M_ST_CTRLO>,4(R2)	; FLOP CONTROL O BIT
	IF_STATE	BRDCST,75$
	IF_NOT_STATE CTRLO,CANCEL_CTRLS	; IF NOW CLEAR THEN START OUTPUT
	MOVL	UCB$L_TT_PORT(R5),R1	; ACCESS PORT VECTOR
	JSB	@PORT_ABORT(R1)		; ABORT PORT OUTPUT
	MOVAB	W^TTY$A_CTRLO,UCB$L_TT_MULTI(R5); INSERT ADDRESS OF STRING
	SET_STATE MULTI
	TSTW	UCB$W_TT_CURSOR(R5)	; IF CURSOR AT 0 THEN OUTPUT NEWLINE
	BNEQ	CANCEL_CTRLS
	INCL	UCB$L_TT_MULTI(R5)	; OUTPUT LINE FEED FIRST
;
; RESTART OUTPUT ON STOPPED UNIT
;
; ENTRY FROM CONTROLY AND CONTROLC
;

CANCEL_CTRLS:
	MOVL	UCB$L_TT_PORT(R5),R1	; ACCESS PORT VECTOR
	JSB	@PORT_RESUME(R1)	; RESUME ANY PORT OUTPUT
	BRW	BEGIN_ECHO		; BEGIN OUTPUT
 
	.DSABL	LSB

	.SBTTL	TTY$PUTNEXTCHAR - BUFFER CHARACTER 

;++
; TTY$PUTNEXTCHAR - BUFFER CHARACTER 
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED BY PORT DRIVERS TO PASS INPUT CHARACTERS.
;
; CHARACTERS RECEIVED ON NON PASSALL UNITS ARE FILTERED FOR IMMEDIATE
; CONTROL SEQUENCES. THESE SEQUENCES REPRESENT:
;
;	CONTROL Y -- 	CAUSES THE TYPEAHEAD BUFFER TO BE PURGED, THE
;		     	ENABLED PROCESS TO RECEIVE AN AST, A "^Y" TO
;			BE OUTPUT AND THE CURRENT OPERATION IF ANY TO
;			BE COMPLETED WITH A ZERO TRANSFER COUNT FOR READ 
;			AND AS IF CONTROL O FOR WRITE.
;
;	CONTROL C --	CAUSES THE RECEIVER OF CONTROL C AST'S OR THE RECEIVER
;			OF CONTROL Y AST'S TO BE SIGNALLED AS IN CONTROL Y.
;
;	CONTROL X -- 	CAUSES THE CONTENTS OF THE TYPEAHEAD BUFFER
;			TO BE PURGED AND A CONTROL U TO BE INSERTED
;			IN THE INPUT STREAM IF A READ IS IN PROGRESS.
;
;	CONTROL S --	CAUSES ALL OUTPUT ON UNIT TO STOP UNTIL
;			CONTROL Q,Y OR C.
;
;	CONTROL Q --	RESETS CONTROL S MODE AND STARTS OUTPUT UP.
;
; SLAVE MODE ( NO UNSOLICITED INPUT ) UNITS MUST HAVE OUTSTANDING
; READS OTHERWISE THE CHARACTER, AFTER CONTROL CHARACTER FILTERING
; IS IGNORED.
;
; INPUTS:
;	R3 = CHARACTER TO BUFFER
;	R5 = UCB
;	R1,R2,R4 ARE AVAILABLE FOR USE
;
; OUTPUTS:	
;
;	R3 =	0	AND CC = ZERO
;		CHAR	AND CC = PLUS
;		ADDRESS	AND CC = NEGATIVE	
;	
;	R5 = UCB ADDRESS
;--

TTY$PUTNEXTCHAR::
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATUS OF UNIT
	BITW	#TT$M_EIGHTBIT,UCB$L_DEVDEPEND(R5); 8BIT TERMINAL?
	BNEQ	5$			; IF NEQ THEN YES
	BICB	#^X080,R3		; STRIP 8TH BIT
;
; AVOID CHECK FOR PASSALL MODE
;
5$:	IF_STATE PASALL,BUFFER_CHAR	; NO CONTROL SEQS IF PASSALL
;
; CHECK FOR OUT OF BAND CHARACTER
;
	CMPB	R3,#^A/ /		; CONTROL CHARACTER?
	BGEQU	BUFFER_CHAR		; NO
	BBC	R3,UCB$L_TT_OUTBAND(R5),10$	; NOT IN SUMMARY MASK
	MOVAL	UCB$L_TT_BANDQUE(R5),R4		; ADDRESS OF QUEUE
	JSB	G^COM$DELCTRLAST		; DELIVER ANY OUTSTANDING ASTS
	BBSC	#15,R3,10$			; DONT STRIP CHARACTER
	BRW	DISMISS		
;
; CHECK FOR CONTROL SEQUENCE CHARACTER
;
10$:
	CASE	W^TTY$A_TYPE[R3],TYPE=B,LIMIT=#1@TTY$V_CH_CTRL,-
		<CONTROLC,CONTROLO,CONTROLQ,CONTROLS,CONTROLX,CONTROLY>

	.SBTTL	BUFFER_CHAR - puts character into typeahead buffer

;++
; BUFFER_CHAR - INSERT CHARACTER INTO TYPEAHEAD BUFFER
;
; FUNCTIONAL DESCRIPTION:
;
; AT THIS POINT WE KNOW THAT THE CHARACTER DOES NOT REPRESENT SOME IMMEDIATE
; ACTION.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO BUFFER
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R3,R5 ARE PRESERVED
;--

BUFFER_CHAR:				; BUFFER CHARACTER
	IF_STATE READ,40$		; IF READ THEN BUFFER CHARACTER
	BBS	#TT$V_NOTYPEAHD,UCB$L_DEVDEPEND(R5),5$; IF SLAVED TERMINAL, IGNORE CHARACTER
	TSTW	UCB$W_REFC(R5)		; UNIT REF COUNT 0?
	BEQL	10$			; IF EQL THEN JOB CONTROLLER POSSIBILITY
	TSTL	UCB$L_AMB(R5)		; USER ASSOCIATED MAILBOX?
	BEQL	50$			; IF EQL THEN NO
	BBS	#TT$V_MBXDSABL,UCB$L_DEVDEPEND(R5),50$; BR IF NOT ENABLED
	BBS	#UCB$V_TT_NOTIF,UCB$W_DEVSTS(R5),50$; BR IF ALREADY NOTIFIED
	BRB	15$			; CONTINUE IN COMMON
5$:	BRW	DISMISS			; CONTINUE

; Before checking terminator, check for autobaud detect

10$:	BBC	#TT2$V_AUTOBAUD,UCB$L_TT_DEVDP1(R5),12$ ; Branch if no autobaud
	BSBW	TTY$AUTOBAUD		; Check for correct baud rate

12$:	BBC	R3,W^TTY$A_STANDARD,50$	; IF NOT TERMINATOR THEN NOT FOR JOBCTLRLR
	BBS	#UCB$V_JOB,UCB$W_DEVSTS(R5),50$; IF ALREADY NOTIFIED THEN GO
	MOVAB	G^OPA$UCB0,R4		; ADDRESS CONSOLE UCB
	CMPL	R4,R5			; IS THIS THE CONSOLE
	BEQL	15$			; IF EQL THEN SKIP TERMINAL ENABLED TEST
	TSTW	G^SYS$GL_JOBCTLMB+UCB$W_DEVSTS; TERMINALS ENABLED FOR JOBCTLR?
	BLEQ	5$			; IF LEQ THEN DISMISS
15$:	MOVL	#TTY$V_ST_UNSOL,R4	; ASK FOR UNSOLICITED DATA FORK
	PUSHL	R3			;
	BSBW	TTY$CRE_FORK		; FORK TO SEND MESSAGE
	POPL	R3
	BRB	50$			; AND BUFFER CHARACTER
;
; RESET READ TIMEOUT DUE TIME
;
40$:	BBC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),50$; BR IF NO TIMEOUT
	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
	MOVZWL	TTY$W_RB_TIMOS(R4),R4	; GET THE NUMBER OF SECONDS
	BEQL	50$			; BR IF READ WITH ZERO SECOND TIMEOUT.
	ADDL3	R4,G^EXE$GL_ABSTIM,UCB$L_TT_RDUE(R5); RESET THE TIME
;
; BUFFER CHARACTER IN CIRCULAR TYPEAHEAD BUFFER
;
; TEST TO SEE IF THE NUMBER OF CHARACTERS IN THE TYPEAHEAD IS CRITICAL
; THIS TEST DOES NOT WORK FOR TYPEAHEAD BUFFERS BIGGER THAN 32K BYTES.
;
50$:
	BBC	#TT2$V_ALTYPEAHD,-	; SKIP IF NORMAL TYPE AHEAD SIZE
		UCB$L_TT_DEVDP1(R5),55$
	
	SUBW3	G^TTY$GW_ALTALARM,G^TTY$GW_ALTYPAHD,R4	; WITHIN N CHARS OF TYPAHD FULL?
	ACBW	R4,#1,UCB$W_TT_INAHD(R5),60$		; BRANCH IF NO
	ADDW2	G^TTY$GW_ALTALARM,R4			; MAX # TYPEAHEAD CHARS
	BRB	57$					; JOIN COMMON PATH

55$:	SUBW3	#8,G^TTY$GW_TYPAHDSZ,R4		; WITHIN 8 CHARS OF TYPAHD FULL?
	ACBW	R4,#1,UCB$W_TT_INAHD(R5),60$	; BRANCH IF NO
	ADDW2	#8,R4			; MAX # TYPEAHEAD CHARS
57$:	MOVL	UCB$L_TT_PORT(R5),R1	; ACCESS PORT VECTOR
	JSB	@PORT_XOFF(R1)		; SEND XOFF
	SET_STATE <TYPFUL>		; SET UP STOP SEQUENCE
	CMPW	R4,UCB$W_TT_INAHD(R5)	; TYPEAHEAD BUFFER OVERFLOW?
	BGEQ	60$			; IF GEQ THEN NO OVERFLOW - BUFFER CHARACTER
	DECW	UCB$W_TT_INAHD(R5)	; RESET COUNT ON OVERFLOW
	SET_STATE <OVRFLO>		; INDICATE OVERFLOW CONDITION
	BRB	BEGIN_ECHO		; START THE SEQUENCE
;
; INSERT CHARACTER IN TYPEAHEAD BUFFER
;
60$:	MOVL	UCB$L_TT_TYPAHD(R5),R4	; ADDRESS TYPEAHEAD BUFFER
	BEQL	NO_BUFFER		; IF EQL THEN NONE
	MOVB	R3,@TTY$L_TA_PUT(R4)	; INSERT CHARACTER IN BUFFER
	AOBLSS	TTY$L_TA_END(R4),TTY$L_TA_PUT(R4),70$; INDEX AND BR IF NOT AROUND
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_PUT(R4); RESET POINTER
70$:	
;
; BEGIN ECHO ON READ
;
BEGIN_ECHO:
;
; START UP OUTPUT IF NOT ALREADY STARTED
;
	BITW	#UCB$M_INT,UCB$W_STS(R5); INTERRUPT EXPECTED?
	BNEQ	DISMISS			; IF NEQ THEN YES
	BRW	TTY$GETNEXTCHAR		; FIND THE NEXT CHARACTER FOR THIS UNIT
;
; NO TYPEAHEAD BUFFER - ALLOCATE ONE
;
NO_BUFFER:				;
	CLRW	UCB$W_TT_INAHD(R5)	; SET NO BUFFERED CHARACTERS
	MOVL	#TTY$V_ST_GETAHD,R4	; ASK FOR TYPEAHEAD FORK
	BSBW	TTY$CRE_FORK		; CREATE THE FORK FOR ALLOCATION
;
; DISMISS INTERRUPT - NOTHING TO DO
;
DISMISS:
	CLRL	R3			; SET NO RETURN CHARACTER
	RSB				; RETURN

	.SBTTL	End of module

	.END
