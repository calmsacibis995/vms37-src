	.TITLE	DZDRIVER - Port Driver for DZ-11 support
	.IDENT	'V03-009'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	DZ PORT DRIVER
;
; AUTHOR:
;
;	RICK SPITZ
;
; Revision history:
;
;	V03-009	RKS0009		RICK SPITZ		29-MAR-1982
;		QUADWORD ALIGN TQE FOR EFFICIENCY
;
;	V03-008	RKS0008		RICK SPITZ		23-FEB-1982
;		SET RTS/DTR IN EXTERNAL LOOPBACK DIAG MODE.
;
;	V03-007	RKS0007		RICK SPITZ		8-FEB-1982
;		DO NOT ALLOW DRIVER UNLOAD.
;		FIX CHARACTER TIMEOUT VALUE
;
;	V03-006	RKS0006		RICK SPITZ		15-DEC-1981
;		FIX MAINTENANCE BIT OFFSETS, ADD EXTERNAL LOOPBACK SUPPORT.
;		USE SYSGEN PARAMETERS FOR CLASS DPT ADDRESS, PARITY,RSPEED.
;		MOVE IDB FIELD DEFINITION TO TTYDEF.
;		RESET ANY DMA FLAGS.
;
;	V03-005	JLV0098		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V03-004	RKS004		RICK SPITZ			20-AUG-1981
;		FORK PRIOR TO QUEUEING ENTRY IN TIMER QUEUE
;
;	V03-003	RKS003		RICK SPITZ			15-AUG-1981
;		RAISE IPL PRIOR TO INVOKING MODEM TRANSITION ROUTINE IN
;		DZ-11 MODEM POLLER
;
;	V03-002	JLV0063		Jake VanNoy			10-Aug-1981
;		Add AUTOBAUD code to frame error logic.
;
;	V03-001	RKS001		RICK SPITZ			28-SEPT-1981
;		THIS MODULE IS NEW STARTING WITH VMS V3. IT ACTS AS THE
;		PORT DRIVER FOR BOTH DZ-11 AND DZ-32 INTERACES. IT REPLACES
;		THE FUNCTIONALITY PREVIOUSLY PROVIDED BY THE MODULE TTZINTDSP.
;
;
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; EXTERNAL DEFINITIONS:
;
	$ACBDEF				; DEFINE ACB
	$CRBDEF				; DEFINE CRB
	$DCDEF				; DEVICE DEFINITIONS
	$DDBDEF				; DEFINE DDB
	$DYNDEF				; Dynamic structure definitions
	$IDBDEF				; DEFINE IDB OFFSETS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IRPDEF				; IRP definitions
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL TYPES
	$TT2DEF				; DEFINE EXTENDED DEFINITIONS
	$TQEDEF				; DEFINE TIMER QUEUE OFFSETS
	$UCBDEF				; DEFINE UCB
	$UBADEF				; DEFINE UBA
	$VECDEF				; DEFINE VECTOR FOR CRB
	$TTYMACS			; DEFINE TERMINAL DRIVER MACROS
	$TTYDEFS			; DEFINE TERMINAL DRIVER SYMBOLS
	$TTYMODEM			; DEFINE MODEM DEFINITIONS


;
; LOCAL STORAGE
;
	.PSECT	$$$105_PROLOGUE

;
; Driver prologue table:
;

DZ$DPT::				; DRIVER START
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=DZ$END,-		; End and offset to INIT's vectors
		UCBSIZE=UCB$C_TT_LENGTH,- ; SIZE OF UCB
		FLAGS=DPT$M_NOUNLOAD,-	; DO NOT ALLOW UNLOAD
		ADAPTER=UBA,-		; ADAPTER TYPE
		DEFUNITS=8,-		; Number of units to create
		NAME=DZDRIVER,-		; NAME OF DRIVER
		VECTOR=PORT_VECTOR	; PORT DRIVER VECTOR TABLE
	DPT_STORE INIT
	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-; CHARACTERISTICS
			DEV$M_REC!-	;
			DEV$M_AVL!-	;
			DEV$M_IDV!-	;
			DEV$M_ODV!-	;
			DEV$M_TRM!-	;
			DEV$M_CCL>
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM;
	DPT_STORE UCB,UCB$B_TT_DETYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_TT_DESIZE,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_TT_DECHAR,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_TT_DECHA1,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_DESPEE,@B,TTY$GB_DEFSPEED; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_DESPEE+1,@B,TTY$GB_RSPEED; DEFAULT SPEED
	DPT_STORE UCB,UCB$B_TT_DEPARI,@B,TTY$GB_PARITY	; DEFAULT PARITY 
	DPT_STORE UCB,UCB$B_TT_PARITY,@B,TTY$GB_PARITY	; DEFAULT PARITY
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_TT_DEVDP1,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_SPEED,@B,TTY$GB_DEFSPEED	; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_SPEED+1,@B,TTY$GB_RSPEED	; DEFAULT SPEED
	DPT_STORE UCB,UCB$B_DIPL,B,21			; DEVICE IPL
	DPT_STORE UCB,UCB$L_TT_WFLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_WBLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_RTIMOU,L,0		; Zero read timed out disp.
	DPT_STORE UCB,UCB$W_VPROT,@W,TTY$GW_PROT    	; Default protection
	DPT_STORE UCB,UCB$L_OWNUIC,@L,TTY$GL_OWNUIC 	; Default owner UIC
	DPT_STORE DDB,DDB$L_DDT,D,DZ$DDT

	DPT_STORE REINIT
	DPT_STORE CRB,CRB$L_INTD+4,D,DZ11$INTINP	; RECEIVER INTERRUPT
	DPT_STORE CRB,CRB$L_INTD2+4,D,DZ11$INTOUT	; TRANSMITTER INTERRUPT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,DZ$INITIAL  ; CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,DZ$INITLINE; UNIT INIT
	DPT_STORE END

	DDTAB	DEVNAM = DZ,-	; DUMMY DZ PORT DRIVER DISPATCH TABLE
		START  = 0,-
		FUNCTB = 0

	.PSECT	$$$115_DRIVER

;
; THE ASSOCIATED CLASS DRIVER USES THIS TABLE TO COMMAND THE PORT DRIVER.
; THE ADDRESS OF THIS TABLE IS CONTAINED IN THE TERMINAL UCB EXTENSION AREA.
; THE OFFSET DEFINITONS ARE DEFINED BY TTYDEFS.
;

PORT_VECTOR:			

;
; DZ-11 SPECIFIC DISPATCH TABLE
;

DZ11_VECTOR:
	.LONG	DZ11$STARTIO -	DZ$DPT		; START NEW OUTPUT
	.LONG	DZ$DISCONNECT -	DZ$DPT		; HANGUP PORT
	.LONG	DZ$SET_LINE -	DZ$DPT		; SET NEW SPEED/PARITY
	.LONG	DZ11$DS_SET -	DZ$DPT		; SET OUTPUT MODEM SIGNALS
	.LONG	DZ11$XON -	DZ$DPT		; SEND XON SEQUENCE
	.LONG	DZ11$XOFF -	DZ$DPT		; SEND XOFF SEQUENCE
	.LONG	DZ$STOP -	DZ$DPT		; STOP OUTPUT
	.LONG	DZ$STOP2 -	DZ$DPT		; STOP OUTPUT UP TO 2 SECONDS
	.LONG	DZ$ABORT -	DZ$DPT		; ABORT OUTPUT IN PROGRESS
	.LONG	DZ11$RESUME -	DZ$DPT		; RESUME STOPPED OUTPUT
	.LONG	DZ11$SET_MODEM -DZ$DPT		; PORT SPECIFIC MODEM INITIALIZATION
	.LONG	DZ$NULL -	DZ$DPT		; 
	.LONG	DZ11$MAINT -	DZ$DPT		; INVOKE MAINTENANCE FUNCTION

;
; DZ-32 SPECIFIC DISPATCH TABLE
;

DZ32_VECTOR:
	.LONG	DZ32$STARTIO -	DZ$DPT		; START NEW OUTPUT
	.LONG	DZ$DISCONNECT -	DZ$DPT		; HANGUP PORT
	.LONG	DZ$SET_LINE -	DZ$DPT		; SET NEW PARITY/SPEED
	.LONG	DZ32$DS_SET -	DZ$DPT		; SET NEW OUTPUT MODEM SIGNALS
	.LONG	DZ32$XON -	DZ$DPT		; SEND XON
	.LONG	DZ32$XOFF -	DZ$DPT		; SEND XOFF
	.LONG	DZ$STOP -	DZ$DPT		; STOP CURRENT OUTPUT
	.LONG	DZ$STOP2 -	DZ$DPT		; STOP OUTPUT FOR UP TO 2 SECONDS
	.LONG	DZ$ABORT -	DZ$DPT		; ABORT CURRENT OUTPUT
	.LONG	DZ32$RESUME -	DZ$DPT		; RESUME STOPPED OUTPUT
	.LONG	DZ$NULL -	DZ$DPT		;
	.LONG	DZ$NULL -	DZ$DPT		
	.LONG	DZ32$MAINT - 	DZ$DPT		; INVOKE MAINTENANCE FUNCTIONS
	.LONG	0


DZ$NULL:					; NULL PORT ROUTINE
	RSB


	.PAGE
	.SBTTL	REGISTER DEFINITIONS
 
;
; CSR BIT DEFINITIONS ( CSR ) ( READ/WRITE )
;
	$VIELD	DZCSR,0,<-
		<MODE,1,M>,-	; DZ32 - MODE/ DZ11 - UNUSED
		<DS_ENAB,1,M>,-	; DZ32 - DATA SET INTERRUPT ENABLE
		<,1,>,-		; UNUSED
		<MAINT,1,M>,-	; LINE TURNAROUND
		<CLEAR,1,M>,-	; MASTER RESET
		<MASTENAB,1,M>,-; MASTER SCAN ENABLE
		<RCVINT,1,M>,-	; RECEIVER INTERRUPT ENABLE
		<RCVRDY,1,M>,-	; RECEIVER READY
		<LINE,3,M>,-	; LINE NUMBAE (0 - 7)
		<DS_CHG,1,M>,-	; DZ32 - DATA SET INTERRUPT
		<,2,>,-		; UNUSED
		<SNDINT,1,M>,-	; TRANSMIT INTERRUPT ENABLE
		<SNDRDY,1,M>-	; TRANSMITTER READY
		> 
;
; RECEIVER BUFFER ( CSR+2 ) ( READ ONLY )
;
	$VIELD	DZRCV,0,<-
		<BUF,8,M>,-	; RECEIVER DATA
		<LINE,3,M>,-	; LINE NUMBER (0 - 7)
		<,1,>,-
		<PARERR,1,M>,-	; PARITY ERROR
		<FRAMER,1,M>,-	; FRAME ERROR
		<OVERRUN,1,M>,-	; OVERRUN ERROR
		<VALID,1,M>-	; DATA VALID
		> 
;
; LINE PARAMETER REGISTER ( CSR+2 ) ( WRITE ONLY )
;
 
	$VIELD	DZLPR,0,<-
		<LINE,3,M>,-	; LINE NUMBER (0-7)
		<SIZE,2,M>,-	; CHARACTER SIZE
		<STOP,1,M>,-	; NUMBER STOP BITS
		<PARITY,1,M>,-	; PARITY ENABLE
		<ODD,1,M>,-	; ODD PARITY
		<SPEED,4,M>,-	; LINE SPEED
		<CLOCK,1,M>,-	; RECEIVER CLOCK	 
		<SPLIT,1,M>,-	; DZ32 - SPLIT SPEED
		>

;
; DZ-32 SPECIFIC MODEM CONTROL
;

	$VIELD	DZLCS1,8,<-
		<,7,>,-
		<ACK,1,M>,-	; READY FOR COMMAND/ UPDATE OUTPUT MODEM
		>


	
	.PAGE
	.SBTTL	CONTROLLER INITIALIZATION 



;++
; DZ$INITIAL - INITIALIZE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AT SYSTEM STARTUP AND POWER RECOVERY.
;
; INPUTS:
;
;	R4 = ADDRESS OF THE UNIT CSR
;	R5 = IDB OF UNIT
;	R8 = ADDRESS OF THE UNIT CRB
;
; OUTPUTS:
;
;	R2 is destroyed.
;
; IMPLICIT INPUTS:
;
;	IPL = IPL$_POWER
;
;--
DZ$INITIAL::				; INITIALIZE DZ UNIT
;
; SET UP CONTROLLER
;
	MOVL	G^TTY$GL_DPT,R1		; GET CLASS DRIVER DPT ADDRESS
	MOVZWL	DPT$W_VECTOR(R1),R0	; GET ADDRESS OF CLASS VECTOR
	ADDL3	R0,R1,R0		; CALCULATE VIRTUAL ADDRESS
	
; RELOCATE CLASS VECTOR TABLE

5$:
	TSTL	(R0)			; ALREADY RELOCATED OR DONE?
	BLEQ	10$			; YES
	ADDL	R1,(R0)+		; ADD BIAS
	BRB	5$			; LOOP TILL DONE

; RELOCATE PORT VECTOR TABLE

10$:
	MOVAL	DZ$DPT,R1
	MOVAL	PORT_VECTOR,R0
20$:
	TSTL	(R0)			; ALREADY RELOCATED OR DONE?
	BLEQ	25$			; YES
	ADDL	R1,(R0)+
	BRB	20$



25$:	MOVW	#DZCSR$M_CLEAR,(R4)	; INIT CONTROLLER RESET

;
;	WAIT TILL CONTROLLER INIIALIZATION IS COMPLETE
;
	TIMEWAIT	#100,#DZCSR$M_CLEAR,(R4),W,.FALSE.

	MOVW	#<<DZCSR$M_MASTENAB>!-	;
		<DZCSR$M_RCVINT>!-	; ENABLE RECEIVER INTERRUPTS
		<DZCSR$M_SNDINT>!-	; ENABLE TRANSMITTER INTERRUPTS
		<DZCSR$M_DS_ENAB>!-	; ENABLE DZ-32 DATA SET INTERRUPTS
		<DZCSR$M_MODE>>,(R4)	; ENABLE ENHANCED MODE ON DZ-32
	BLBC	R0,DZ$CTRL_ERROR

	MOVW	(R4),R2			; GET NEW STATUS
	BBS	#DZCSR$V_MODE,R2,110$	; BRANCH IF DZ-32 CONTROLLER

100$:
	MOVB	#DT$_DZ11,CRB$B_TT_TYPE(R8); CONTROLLER IS DZ11

	CLRW	CRB$B_TT_RING(R8)	; RESET CURRENT DZ-11 MODEM STATE
	RSB

110$:	;DZ-32 CONTROLLER SPECIFIC INIT
	
	MOVB	#DT$_DZ32,CRB$B_TT_TYPE(R8)	; CONTROLLER IS DZ-32
	CLRB	IDB$B_TT_ENABLE(R5)		; RESET DZ-32 LINE ENABLE
	MOVB	IDB$B_TT_ENABLE(R5),7(R4) 	; RESET TRANSMIT LINE ENABLES
	RSB

DZ$CTRL_ERROR:
	RSB
	
	.PAGE
	.SBTTL	UNIT INITIALIZATION
;++
; DZ$INITLINE - UNIT INITIALIZATION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS A SIMPLE UNIT INITIALIZATION.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R5 ARE PRESERVED.
;--

DZ$INITLINE::				
	MOVL	G^TTY$GL_DPT,R1		; ADDRESS OF CLASS DPT
	MOVZWL	DPT$W_VECTOR(R1),R0	; LOCATE CLASS DRIVER VECTOR TABLE
	ADDL	R0,R1			; RELOCATE BASE ADDRESS
	MOVL	R1,UCB$L_TT_CLASS(R5)	; SET TERMINAL CLASS DRIVER VECTOR

	MOVL	UCB$L_CRB(R5),R4	; CHECK FOR DZ-32 CONTROLLER
	CMPB	#DT$_DZ32,CRB$B_TT_TYPE(R4) 	; IS IT DZ-32 ?
	BEQL	5$				; YES	
	MOVAL	DZ11_VECTOR,UCB$L_TT_PORT(R5)	; SET DZ-11 PORT VECTOR TABLE
	BRB	8$
5$:	MOVAL	DZ32_VECTOR,UCB$L_TT_PORT(R5)	; SET DZ-32 PORT VECTOR TABLE
8$:	MOVL	CLASS_GETNXT(R1),UCB$L_TT_GETNXT(R5)
	MOVL	CLASS_PUTNXT(R1),UCB$L_TT_PUTNXT(R5)
	MOVL	UCB$L_DDB(R5),R0	; GET DDB ADDRESS
	MOVL	CLASS_DDT(R1),DDB$L_DDT(R0)
	MOVL	CLASS_DDT(R1),UCB$L_DDT(R5)	; SET DDT ADDRESS IN UCB
;

	BISW	#UCB$M_ONLINE,UCB$W_STS(R5); SET ONLINE
10$:	ASHL	UCB$W_UNIT(R5),#1,R3	; BUILD UNIT'S BIT MASK
	MOVW	R3,UCB$B_ERTCNT(R5)	; SAVE IT

	BBS	#UCB$V_POWER,UCB$W_STS(R5),-
		20$			; SKIP IF POWER FAIL RECOVERY
	TSTW	UCB$W_REFC(R5)		; ANY CHANNELS ATTACHED?
	BNEQ	20$			; YES, DON'T REINIT UCB
	BICL	#TT2$M_DMA,UCB$L_TT_DECHA1(R5) ; INSURE DMA NOT SET FOR DZ
	MOVL	UCB$L_TT_CLASS(R5),R1	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R1)	; INIT UCB FIELDS
20$:
	JSB	DZ$SET_LINE		; INIT SPEED/PARITY
	
	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS
	CMPB	#DT$_DZ11,CRB$B_TT_TYPE(R4)	; CONTROLLER DZ11?
	BEQL	25$			; YES

;
; INIT DZ-32 ALTERNATE INTERRUPT VECTORS
;
	MOVAL	DZ32$INTINP,CRB$L_INTD+4(R4)	; INIT RECEIVER VECTOR
	MOVAL	DZ32$INTOUT,CRB$L_INTD2+4(R4)	; INIT TRANSMITTER VECTOR

;
; INIT RECEIVER MODEM STATUS FOR DZ-32
;
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; GET CSR ADDRESS
	
; WAIT TILL MODEM CONTROL READY FOR COMMNAD

	TIMEWAIT #100,#DZLCS1$M_ACK,4(R4),W,.TRUE.
	BLBC	R0,DZ$UNIT_ERROR
	MOVW	UCB$W_UNIT(R5),4(R4)		; REQUEST STATUS ON LINE

; WAIT FOR COMPLETION

	TIMEWAIT #100,#DZLCS1$M_ACK,4(R4),W,.TRUE. 
	BLBC	R0,DZ$UNIT_ERROR
	MOVB	4(R4),UCB$B_TT_DS_RCV(R5)	; UPDATE RECEIVER MODEM STATUS

25$:
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),-
		30$			; SKIP IF NOT MODEM LINE
	PUSHL	R2
	MOVZBL	#MODEM$C_INIT,R1	; INIT MODEM PROTOCOL
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_DS_TRAN(R0)	; INVOKE TO INIT MODEM PROTOCOL
	POPL	R2
30$:
	RSB
;
; ERROR DETECTED DURING INITIALIZATION
;

DZ$UNIT_ERROR:
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5)	; UNIT NOT ON LINE
	RSB

	.PAGE
	.SBTTL	DISCONNECT LINE
;++
; DZ$DISCONNECT - SHUT OFF UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED WHEN FOR SOME REASON THE UNIT MUST BE DISCONNECTED.
;
;
; INPUTS:
;
;	R5 = UBC ADDRESS
;
; OUTPUTS:
;
;	R3,R4 ARE USED.
;--

DZ$DISCONNECT::				; DISCONNECT UNIT
	PUSHR	#^M<R0,R1,R2>
	MOVL	#MODEM$C_SHUTDWN,R1	; SIGNAL RESET
	MOVL	UCB$L_TT_CLASS(R5),R0	; ACCESS CLASS VECTOR TABLE
	JSB	@CLASS_DS_TRAN(R0)	; INVOKE MODEM TRANSITION ROUTINE
	POPR	#^M<R0,R1,R2>
	RSB

	.PAGE
	.SBTTL	MAINTENANCE ROUTINES
;++
; DZ$MAINT - MAINTENANCE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS MAINTENANCE FUNCTIONS FOR THE DZ .
;
;
; INPUTS:
;
;	R5 = UBC ADDRESS
;	UCB$B_TT_MAINT = FUNCTION TO BE PERFORMED
;
; OUTPUTS:
;
;--

DZ32$MAINT:
	BITB	#IO$M_LOOP@-7,-			; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	5$				; NO
	MOVZBL	#^X40,R2			; SPECIFY LOOPBACK CODE
	BRB	10$
5$:
	BITB	#IO$M_UNLOOP@-7,-		; RESET LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	15$				; NO
	MOVZWL	#^X7200,R2			; SPECIFY UNLOOP CODE (BOTH)
10$:
	JSB	DZ32$DS_SET			; UPDATE CONTROLLER
	MOVZBL	#1,R0				; INDICATE SUCCESS
	RSB
15$:
	BITB	#IO$M_LOOP_EXT@-7,-		; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	20$				; NO
	MOVZBL	#^X72,R2			; SPECIFY LOOPBACK CODE
	BRB	10$

20$:						; CHECK OTHER FUNCTIONS

DZ11$MAINT:
	BITB	#IO$M_LINE_OFF@-7,-		; LINE OFF
		UCB$B_TT_MAINT(R5)
	BEQL	10$				; NO
	BISB	#UCB$M_TT_DSBL,-		; DISABLE LINE
		UCB$B_TT_MAINT(R5)
	BRB	20$
10$:
	BITB	#IO$M_LINE_ON@-7,-			; LINE ON
		UCB$B_TT_MAINT(R5)
	BEQL	30$				; NO
	BICB	#UCB$M_TT_DSBL,-		; REENABLE LINE
		UCB$B_TT_MAINT(R5)
20$:
	JSB	DZ$SET_LINE			; IMPLEMENT FUNCTION
	MOVZBL	#1,R0
	RSB
30$:
	CLRL	R0
	RSB


	.PAGE
	.SBTTL	OUTPUT MODEM CONTROL
;++
; DZ$DS_SET - SET OUTPUT MODEM SIGNALS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE OUTPUT MODEM SIGNALS FOR THE SPECIFIED UNIT
;
; INPUTS:
;
;	R2 = LOW BYTE - SIGNALS TO ACTIVATE
;	     HIGH BYTE- SIGNALS TO DEACTIVATE
;	
;	R5 = UBC ADDRESS
;	
; OUTPUTS:
;
;	R0-R3 ARE USED.
;--

DZ11$DS_SET:
	PUSHL	R4			; SAVE 
	BISB	R2,UCB$B_TT_DS_TX(R5)	; SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		; ACCESS SIGNALS TO RESET
	BICB	R2,UCB$B_TT_DS_TX(R5)	; RESET THEM
	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3
					; GET CSR ADDRESS
	EXTZV	#TT$V_DS_DTR,#1,UCB$B_TT_DS_TX(R5),R1
					; GET CURRENT DTR FOR LINE
	ASHL	UCB$W_UNIT(R5),R1,R1	; SHIFT TO RELATIVE LINE POSITION
	BICB	UCB$B_ERTCNT(R5),CRB$B_TT_DTR(R4)
					; RESET CURRENT DTR FOR THAT LINE
	BISB	R1,CRB$B_TT_DTR(R4)	; SET IT IF NEED BE
	MOVB	CRB$B_TT_DTR(R4),5(R3)	; UPDATE DTR STATUS FOR LINES
	POPL	R4
	RSB

DZ32$DS_SET:
	PUSHL	R4			; SAVE 
	BISB	R2,UCB$B_TT_DS_TX(R5)	; SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		; ACCESS SIGNALS TO RESET
	BICB	R2,UCB$B_TT_DS_TX(R5)	; RESET THEM
	MOVL	UCB$L_CRB(R5),R4	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3
	TIMEWAIT #100,#DZLCS1$M_ACK,4(R3),W,.TRUE.	; WAIT FOR READY
	MOVZWL	UCB$B_TT_DS_TX-1(R5),-(SP)		; CREATE TEMP LOCATION
	MOVB	UCB$W_UNIT(R5),(SP)	; SET UNIT NUMBER
	BISW	#DZLCS1$M_ACK,(SP)	; ENABLE NEW OUTPUT SIGNALS
	CVTLW	(SP)+,4(R3)		; SET NEW OUPUT MODEM SIGNALS
	POPL	R4
	RSB
	
	.PAGE
	.SBTTL	DZ-11 MODEM POLLER
;++
; DZ$TIMER - POLL FOR DZ-11 MODEM TRANSITIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CHECKS FOR DZ-11 CONTROLLER MODEM
; TRANSITION. IT UPDATES THE INPUT MODEM STATUS FOR EACH
; LINE AND CALLS THE CLASS TRANSITION ROUTINE FOR EACH LINE WITH
; A CHANGE.
;
; INPUTS:
;
;	R5 - TQE ADDRESS
;
; OUTPUTS:
;
;	R0 - R4 DESTROYED
;	
;--

DZ$TIMER:
	PUSHR	#^M<R5,R6>		
	MOVAL	DZ$L_DIALUP,R4		; GET DZ TIMER LIST HEAD
5$:
	MOVL	(R4),R4			; GET NEXT CRB ADDRESS
	BNEQ	15$			; PROCESS LINES FOR THIS CRB
	POPR	#^M<R5,R6>		;  RESTORE REGISTERS
	RSB				; RETURN FROM TIMER IMTERRUPT
;
;	TEST LINES ON THIS CONTROLLER FOR A TRANSITION
;

15$:
	PUSHL	R4			; SAVE TIMER THREAD
	SUBL	#CRB$L_DZ_MODEM,R4	; GET ACTUAL CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3 ; GET CSR ADDRESS
	CMPW	CRB$B_TT_RING(R4),6(R3)	; ANY TRANSITIONS
	BEQL	60$			; NONE
;
;	FIND WHICH SIGNALS CHANGED AND UPDATE THEM
;
	MOVB	6(R3),R2		; GET NEW RING
	XORB3	R2,CRB$B_TT_RING(R4),R0	; FIND TRANSITIONED LINES
	MOVB	R2,CRB$B_TT_RING(R4)	; UPDATE CURRENT RING
	MOVB	7(R3),R2		; GET NEW CARRIER
	XORB3	R2,CRB$B_TT_CARRIER(R4),R6
	BISB	R6,R0			; FLAG LINES WITH TRANSITIONED CARRIER
	MOVB	R2,CRB$B_TT_CARRIER(R4)	; UPDATE CURRENT CARRIER
;
;	PROCESS TRANSITIONED LINES
;

50$:	FFS	#0,#8,R0,R1		; FIND NEXT LINE NEEDING SERVICE
	BEQL	60$			; DONE
	BBCC	R1,R0,55$		; RESET ATTENTION BIT FOR THIS LINE
55$:
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R6
	MOVL	IDB$L_UCBLST(R6)[R1],R5	; GET UCB FOR THAT LINE
	BEQL	50$			; NONE
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),50$
					; SKIP IF NOT MODEM LINE
	DSBINT	UCB$B_DIPL(R5)			; RAISE TO DEVICE IPL
	EXTZV	R1,#1,CRB$B_TT_RING(R4),R6	; GET RING FOR THAT LINE
	INSV	R6,#TT$V_DS_RING,#1,-		; UPDATE IT IN UCB
		UCB$B_TT_DS_RCV(R5)
	EXTZV	R1,#1,CRB$B_TT_CARRIER(R4),R6	; GET CD FOR THAT LINE
	INSV	R6,#TT$V_DS_CARRIER,#1,-	; UPDATE IT IN UCB
		UCB$B_TT_DS_RCV(R5)
	BISB	#<TT$M_DS_DSR!TT$M_DS_CTS>,-	; ASSUME CTS AND DSR ALWAYS SET
		UCB$B_TT_DS_RCV(R5)
	MOVB	UCB$B_TT_DS_RCV(R5),R2	; GET CURRENT RECV MODEM STATUS
	MOVZBL	#MODEM$C_DATASET,R1	; SIGNAL DATASET TRANSITION
	MOVL	UCB$L_TT_CLASS(R5),R6	; GET CLASS VECTOR TABLE
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE VOLITAL REGISTERS
	JSB	@CLASS_DS_TRAN(R6)	; SIGNAL TRANSITION
	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE REGISTERS
	ENBINT				; RESTORE IPL
	BRB	50$

60$:
	POPL	R4			; RESTORE TIMER THREAD
	BRW	5$


	.PAGE
	.SBTTL	RECEIVER INTERRUPT SERIVCE
;++
; DZ$INTINP - DZ RECEIVER READY INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CHARACTER IS AVAILABLE IN THE UNIT'S
; SILO. THE CHARACTER IS EXTRACTED AND IS PASSED TO THE ASSOCIATED
; CLASS DRIVER. IF THE CLASS DRIVER RETURNS CHARACTERS(S) THEN NEW
; OUTPUT IT INITIATED (NORMALLY ECHO).
;
; INPUTS:
;
;	00(SP) = ADDRESS OF IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED WHEN THE SILO IS EMPTY.
;
;--
DZ11$INTINP::				; DZ-11 INPUT INTERRUPTS
;
; GET THE CSR ADDRESS
;
	MOVL	@(SP)+,R4		; GET THE IDB ADDRESS
	PUSHL	R4			; SAVE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE CHARACTER FROM THE INTERFACE
;
25$:	MOVW	2(R0),R3		; GET THE CHARACTER,ERRORS AND LINE NUMBER
	BGEQ	100$			;SILO EMPTY
	BITW	#<DZRCV$M_PARERR>!-
		<DZRCV$M_OVERRUN>!-
		<DZRCV$M_FRAMER>,R3	;ERRORS?
	BNEQ	50$			;YES,PROCESS THEM
27$:	ASHL	#-8,R3,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		; 
	MOVZBL	R3,R3			; CLEAR THE HIGH BYTES OF CHARACTER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB FOR THAT LINE
	BEQL	25$			; IF EQL THEN NOT THERE
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BLEQ	40$			; NONE OR STRING OUTPUT
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE THE CHARACTER IN TANK
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BISW	UCB$B_ERTCNT(R5),4(R0)	;  ENABLE LINE
30$:	MOVL	(SP),R4			; GET IDB ADDRESS
	BRB	25$			; CONTINUE
40$:
	BEQL	30$			; NO CHARACTER
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST
		UCB$W_TT_HOLD(R5)
	BISW	UCB$B_ERTCNT(R5),4(R0)	;  ENABLE LINE
	BRB	30$
;
; SILO EMPTY OR CHARACTER IN ERROR
;
50$:
;
; PROCESS PARITY, FRAME OR OVERRUN ERROR
;
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5; GET UCB ADDRESS
	BEQL	70$			; IF EQL THEN NO UCB
	MOVL	UCB$L_TT_CLASS(R5),R2	; GET CLASS DISPATCH

60$:	JSB	@CLASS_READERROR(R2)	; SIGNAL ERROR
	BNEQ	27$			; BRANCH WITH CHARACTER TO MAIN PATH
70$:	BITW	#^X080,(R0)		; VALID CHARACTER IN SILO NOW?
	BNEQ	30$			; IF NEQ THEN YES
100$:	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI

	.PAGE
;
; DZ-32 INPUT INTERRUPT SERVICE
;

DZ32$INTINP::				; DZ-32 INPUT INTERRUPTS
;
; GET THE CSR ADDRESS
;
	MOVL	@(SP)+,R4		; GET THE IDB ADDRESS
	PUSHL	R4			; SAVE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE CHARACTER FROM THE INTERFACE
;
25$:	MOVW	2(R0),R3		; GET THE CHARACTER,ERRORS AND LINE NUMBER
	BGEQ	100$			;SILO EMPTY
	BITW	#<DZRCV$M_PARERR>!-
		<DZRCV$M_OVERRUN>!-	;ERRORS?
		<DZRCV$M_FRAMER>,R3	;ERRORS?
	BNEQ	50$			;YES,PROCESS THEM
27$:	ASHL	#-8,R3,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		; 
	MOVZBL	R3,R3			; CLEAR THE HIGH BYTES OF CHARACTER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB FOR THAT LINE
	BEQL	25$			; IF EQL THEN NOT THERE
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BLEQ	40$			; NONE OR STRING OUTPUT
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE THE CHARACTER IN TANK
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
28$:
	MOVL	(SP),R4			; RESTORE IDB ADDRESS
	BISB	UCB$B_ERTCNT(R5),-	;  ENABLE LINE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)

30$:	MOVL	(SP),R4			; GET IDB ADDRESS
	BRB	25$			; CONTINUE
40$:
	BEQL	30$			; NO CHARACTER
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST
		UCB$W_TT_HOLD(R5)
	BRB	28$
;
; SILO EMPTY OR CHARACTER IN ERROR
;
50$:
;
; PROCESS PARITY, FRAME OR OVERRUN ERROR
;
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET UCB ADDRESS
	BEQL	70$			; IF EQL THEN NO UCB
	MOVL	UCB$L_TT_CLASS(R5),R2	; GET CLASS DISPATCH

60$:	JSB	@CLASS_READERROR(R2)	; SIGNAL ERROR
	BNEQ	27$			; BRANCH WITH CHARACTER TO MAIN PATH
70$:	BITW	#^X080,(R0)		; VALID CHARACTER IN SILO NOW?
	BNEQ	30$			; IF NEQ THEN YES
100$:
	MOVW	(R0),R3			; TEST FOR MODEM TRANSITION
	BBS	#DZCSR$V_DS_CHG,R3,200$	; BRANCH IF MODEM TRANSITION
110$:	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI
200$:
	MOVB	6(R0),R3		; GET NEW RECEIVE MODEM SIGNALS
	BICL3	#^C<7>,R3,R2		; ISOLATE UNIT NUMBER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET ASSOCAITED UCB
	BEQL	110$			; NONE
	MOVB	R3,UCB$B_TT_DS_RCV(R5)	; UPDATE INPUT MODEM SIGNALS
	BBC	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),-
		110$			; DON'T NOTIFY IF NOT MODEM LINE
	MOVZBL	R3,R2			; LOAD ARGUMENT
	MOVZBL	#MODEM$C_DATASET,R1	; MODEM TRANSITION
	MOVL	UCB$L_TT_CLASS(R5),R3	; ACCESS CLASS VECTORS
	JSB	@CLASS_DS_TRAN(R3)	; SIGNAL TRANSITION
	BRB	110$			; DISMISS INTERRUPT

	.PAGE
	.SBTTL	 START I/O ROUTINE
;++
; DZ$STARTIO - START I/O OERATION ON DZ
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED FROM THE DEVICE INDEPENDENT TERMINAL STARTIO
; ROUTINE TO ENABLE OUTPUT INTERRUPTS ON AN IDLE DZ UNIT.
;
; INPUTS:
;
;	R3 =	CHARACTER	AND	CC = PLUS
;		ADDRESS		AND	CC = NEGATIVE
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
DZ11$STARTIO::				; START I/O ON UNIT
	BGEQ	20$			; SINGLE CHARACTER
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
10$:	MOVL	UCB$L_CRB(R5),R1	; GET CRB OF UNIT
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1; GET CSR
	BISW	UCB$B_ERTCNT(R5),4(R1)	;  ENABLE LINE
	RSB				; RETURN TO CALLER
20$:
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE OUTPUT CHARACTER
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BRB	10$


DZ32$STARTIO::				; START I/O ON UNIT
	BGEQ	20$			; SINGLE CHARACTER SPECIFIED
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
10$:	MOVL	UCB$L_CRB(R5),R1	; GET CRB OF UNIT
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R4	; GET IDB ADDRESS
	MOVL	(R4),R1			; GET CSR ADDRESS
	BISB	UCB$B_ERTCNT(R5),IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R1)
	RSB				; RETURN TO CALLER
20$:
	MOVB	R3,UCB$W_TT_HOLD(R5)	; SAVE OUTPUT CHARACTER
	BISW	#TTY$M_TANK_HOLD,-	; SIGNAL CHARACTER IN TANK
		UCB$W_TT_HOLD(R5)
	BRB	10$
 
	.PAGE
	.SBTTL	PORT ROUTINES  STOP,RESUME,XON,XOFF
;++
; DZ$XOFF -	SEND XOFF
; DZ$XON -	SEND XON
; DZ$STOP -	STOP OUTPUT
; DZ$STOP2 -	ALTERNATE STOP
; DZ$ABORT -	ABORT CURRENT OUTPUT
; DZ$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
	.ENABLE	LSB
;
; SCHEDULE XOFF TO BE SEND
;
DZ11$XOFF:
	BISW	#TTY$M_TANK_XOFF,UCB$W_TT_HOLD(R5)	; SCHEDULE XOFF
	BRB	5$					; JOIN COMMON CODE
;
; SCHEDULE XON TO BE SENT
;
DZ11$XON:
	BISW	#TTY$M_TANK_XON,UCB$W_TT_HOLD(R5)	; SCHEDULE XON
5$:
	BBS	#UCB$V_INT,UCB$W_STS(R5),10$		; IF OUTPUT ACTIVE,
							; FINISHED
	PUSHL	R1					; SAVE A REGISTER
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1		; GET CSR ADDRESS
	BISW	UCB$B_ERTCNT(R5),4(R1)			; ENABLE LINE
	POPL	R1
	BBSS	#UCB$V_INT,UCB$W_STS(R5),10$		; SHOW OUTPUT ACTIVE
10$:
	RSB
	.DISABLE	LSB
;
; STOP PORT OUTPUT
;
DZ$STOP:
	BBSS	#TTY$V_ST_CTRLS,-
		UCB$Q_TT_STATE(R5),5$			; BLOCK NEW OUTPUT
5$:
	BISW	#TTY$M_TANK_STOP,-			; SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	RSB
;
; STOP PORT OUTPUT FOR UP TO 2 SECONDS
;
DZ$STOP2:						; USED FOR BROADCAST DELAY
	BBSS	#TTY$V_ST_CTRLS,-
		UCB$Q_TT_STATE(R5),5$			; BLOCK NEW OUTPUT
5$:
	BISW	#TTY$M_TANK_STOP2,-			; SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	BISB	#UCB$M_TIM,UCB$W_STS(R5)		; SHOW TIMER ACTIVE
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
	RSB
;
; ABORT ANY CURRENT PORT OUTPUT ACTIVITY
;
DZ$ABORT:
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),-	; RESET BURST ACTIVE
		10$					; 
10$:
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
							; IN CASE OUTPUT ACTIVE
	RSB

;
; RESUME PREVIOUSLY STOPPED PORT OUTPUT
;
DZ11$RESUME:
	PUSHL	R1					; SAVE A REGISTER
	BBCC	#TTY$V_ST_CTRLS,UCB$Q_TT_STATE(R5),-	; ALLOW CLASS OUTPUT
		5$
5$:	BICW	#TTY$M_TANK_STOP!TTY$M_TANK_STOP2-
		,UCB$W_TT_HOLD(R5)			; RESET STOP CONDITIONS
	BBS	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),20$	; BURST IN PROGRESS
10$:							; CHAR IN TANK OR OTHER
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
	BRB	30$
20$:
	MOVZWL	UCB$W_TT_OUTLEN(R5),R1			; GET NUMBER CHARACTERS
	DIVL	#4,R1					; COMPUTE CHAR TIMEOUT
	ADDL	#2,R1					; ADD MINIMUM BIAS
	ADDL3	R1,G^EXE$GL_ABSTIM,-			; RESTORE TIMER FOR BURST
		UCB$L_DUETIM(R5)
30$:
	BISB	#UCB$M_TIM,UCB$W_STS(R5)		; SIGNAL TIMER ACTIVE
	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1),R1		; GET CSR ADDRESS
	BISW	UCB$B_ERTCNT(R5),4(R1)			; ENABLE LINE
	BBSS	#UCB$V_INT,UCB$W_STS(R5),40$		; SHOW OUTPUT ACTIVE
40$:
	POPL	R1
	RSB

	.ENABLE	LSB
;
; SCHEDULE XOFF TO BE SENT
;
DZ32$XOFF:
	BISW	#TTY$M_TANK_XOFF,UCB$W_TT_HOLD(R5)	; SCHEDULE XOFF
	BRB	5$					; JOIN COMMON CODE
;
; SCHEDULE XON TO BE SENT
;
DZ32$XON:
	BISW	#TTY$M_TANK_XON,UCB$W_TT_HOLD(R5)	; SCHEDULE XON
5$:
	BBS	#UCB$V_INT,UCB$W_STS(R5),10$		; IF OUTPUT ACTIVE,
							; FINISHED
	PUSHR	#^M<R1,R4>				; SAVE  REGISTERS
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R4		; GET IDB ADDRESS
	MOVL	(R4),R1					; GET CSR ADDRESS
	BISB	UCB$B_ERTCNT(R5),IDB$B_TT_ENABLE(R4)	; ENABLE LINE
	MOVB	IDB$B_TT_ENABLE(R4),7(R1)
	POPR	#^M<R1,R4>
	BBSS	#UCB$V_INT,UCB$W_STS(R5),10$		; SHOW OUTPUT ACTIVE
10$:
	RSB
	.DISABLE	LSB

;
; RESUME STOPPED OUTPUT
;
DZ32$RESUME:
	PUSHR	#^M<R1,R4>				; SAVE REGISTERS
	BBCC	#TTY$V_ST_CTRLS,UCB$Q_TT_STATE(R5),-	; ALLOW CLASS OUTPUT
		5$
5$:	BICW	#TTY$M_TANK_STOP!TTY$M_TANK_STOP2-
		,UCB$W_TT_HOLD(R5)			; RESET STOP CONDITIONS
	BBS	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),20$	; BURST IN PROGRESS
10$:							; CHAR IN TANK OR OTHER
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
	BRB	30$
20$:
	MOVZWL	UCB$W_TT_OUTLEN(R5),R1
	DIVL	#4,R1					; COMPUTE CHAR TIMEOUT
	ADDL	#2,R1					; ADD MINIMUM BIAS
	ADDL3	R1,G^EXE$GL_ABSTIM,-			; RESTORE TIMER FOR BURST
		UCB$L_DUETIM(R5)
30$:
	BISB	#UCB$M_TIM,UCB$W_STS(R5)		; SIGNAL TIMER ACTIVE
	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	MOVL	UCB$L_CRB(R5),R1			; ACCESS CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R4		; GET IDB ADDRESS
	MOVL	(R4),R1					; GET CSR ADDRESS
	BISB	UCB$B_ERTCNT(R5),IDB$B_TT_ENABLE(R4)	; ENABLE LINE
	MOVB	IDB$B_TT_ENABLE(R4),7(R1)
	BBSS	#UCB$V_INT,UCB$W_STS(R5),40$		; SHOW OUTPUT ACTIVE
40$:
	POPR	#^M<R1,R4>
	RSB

	.PAGE
	.SBTTL	OUTPUT INTERRUPT SERVICE
;++
; DZ$INTOUT - DZ-11 OUTPUT INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE DZ-11 FINDS A LINE ENABLED
; AND AN EMPTY UART. THE CORRESPONDING UCB IS FOUND AND 
; ANY OUTSTANDING PORT OUTPUT IS DONE. WHEN ALL OUTSTANDING PORT
; OUTPUT IS COMPLETED, THE CLASS DRIVER IS CALLED TO RETURN THE NEXT
; CHARACTER OR STRING TO BE OUTPUT. IF NO MORE OUTPUT IS FOUND, THEN
; THE LINE IS DISBALED.
;
; INPUTS:
;
;	SP(00) = ADDRESS OF THE IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 SAVED ON THE STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED.
;
;--
DZ11_OUT_EXIT:				; EXIT OUTPUT INTERRUPT
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				; DISMISS INTERRUPT

DZ11$INTOUT::				; DZ-11 OUTPUT INTERRUPT SERVICE

DZ11_OUT_LOOP:
	MOVL	@(SP),R4		; GET THE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE LINE INFO FROM THE CSR
;

	MOVW	(R0),R2			; GET THE CSR VALUE
	BGEQ	DZ11_OUT_EXIT		; NO MORE LINES
	ASHL	#-8,R2,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5; GET THE UCB ADDRESS
	BEQL	DZ11_OUT_LOOP		; IF EQL THEN DISMISS 
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	DZ11_BURST		; YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-			; DISPATCH
		DZ11_XOFF,-			; SEND XOFF
		DZ11_XON,-			; SEND XON
		DZ11_STOP,-			; STOP OUTPUT
		DZ11_STOP2,-			; ALTERNATE STOP
		DZ11_CHAR,-			; CHAR IN TANK
		DZ11_BURST,-			; BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BLSS	DZ11_START_BURST	; BURST SPECIFIED
	BEQL	50$			; NONE
;
; OUTPUT A CHARACTER TO THE DZ-11
;
20$:	MOVZBW	R3,6(R0)		; OUTPUT CHARACTER
	BRB	DZ11_OUT_LOOP
;
; DISABLE OUTPUT ON THIS LINE
;
50$:
	BBS	#UCB$V_INT,-		; IF INT EXP, THEN DON'T RESET,
		UCB$W_STS(R5),DZ11_OUT_LOOP
					; COULD HAVE BEEN SET DURING CALLBACK

	BICW	UCB$B_ERTCNT(R5),4(R0)	; RESET THE OUTPUT ENABLE
	BRB	DZ11_OUT_LOOP


DZ11_START_BURST:
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
;
;  CONTINUE BURST OUTPUT
;
DZ11_BURST:
	MOVB	@UCB$L_TT_OUTADR(R5),-	; OUTPUT NEXT BYTE
		6(R0)		
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	DZ11_OUT_LOOP		; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
	BRW	DZ11_OUT_LOOP
;
; OUTPUT SINGLE CHARACTER
;
DZ11_CHAR:
	MOVB	UCB$W_TT_HOLD(R5),6(R0)	; OUTPUT CHAR IN TANK
	BICW	#TTY$M_TANK_HOLD,-	; SHOW TANK EMPTY
		UCB$W_TT_HOLD(R5)	
	BRW	DZ11_OUT_LOOP
;
; STOP THE OUTPUT
;
DZ11_STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; RESET OUTPUT ACTIVE
	BICW	UCB$B_ERTCNT(R5),4(R0)	; RESET THE OUTPUT ENABLE
	BRW	DZ11_OUT_LOOP
DZ11_STOP2:
	BICB	#UCB$M_INT,UCB$W_STS(R5); SHOW OUTPUT NOT ACTIVE
	BICW	UCB$B_ERTCNT(R5),4(R0)	; RESET THE OUTPUT ENABLE
	BRW	DZ11_OUT_LOOP

	.ENABLE	LSB
;
; SEND XON OR XOFF CHARACTER
;

DZ11_XOFF:
	BICW	#TTY$M_TANK_XOFF,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	BBC	#TTY$V_SX_TYPFUL,-
		UCB$Q_TT_STATE(R5),10$	; SKIP IF NOT TYPEAHEAD FULL

	BBS	#TT$V_HOSTSYNC,UCB$L_DEVDEPEND(R5),10$ ; XOFF CORRECT
	MOVZBL	#TTY$C_BELL,R3		; USE BELL CHARACTER
	BRB	25$
10$:
	MOVZBL	#TTY$C_XOFF,R3		; USE XOFF
	BRB	20$
DZ11_XON:
	BICW	#TTY$M_TANK_XON,-	; RESET XON STATE
		UCB$W_TT_HOLD(R5)
	MOVZBL	#TTY$C_XON,R3		; SEND XON
20$:
	BITL	#TT$M_HOSTSYNC!TT$M_READSYNC,-
		UCB$L_DEVDEPEND(R5)	; HOST OR READ SYNC TERMINAL?
	BEQL	30$			; NO, SKIP OUTPUT
25$:	MOVB	R3,6(R0)		; OUTPUT CHARACTER
30$:	BRW	DZ11_OUT_LOOP
	.DISABLE	LSB

	.PAGE
;
; DZ-32 OUTPUT INTERRUPT SERVICE CODE
;

DZ32_OUT_EXIT:				; EXIT OUTPUT INTERRUPT
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				; DISMISS INTERRUPT

DZ32$INTOUT::				; DZ-32 OUTPUT INTERRUPT SERVICE
DZ32_OUT_LOOP:
	MOVL	@(SP),R4		; GET THE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE LINE INFO FROM THE CSR
;

	MOVW	(R0),R2			; GET THE CSR VALUE
	BGEQ	DZ32_OUT_EXIT
	ASHL	#-8,R2,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5; GET THE UCB ADDRESS
	BEQL	DZ32_OUT_LOOP		; IF EQL THEN DISMISS 
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	DZ32_BURST		; YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-			; DISPATCH
		DZ32_XOFF,-			; SEND XOFF
		DZ32_XON,-			; SEND XON
		DZ32_STOP,-			; STOP OUTPUT
		DZ32_STOP2,-			; ALTERNATE STOP
		DZ32_CHAR,-			; CHAR IN TANK
		DZ32_BURST,-			; BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BLSS	DZ32_START_BURST	; BURST SPECIFIED
	BEQL	50$			; NONE
;
; OUTPUT A CHARACTER TO THE DZ-32
;
20$:	MOVB	R3,6(R0)		; OUTPUT CHARACTER
	BRW	DZ32_OUT_LOOP

;
; DISABLE OUTPUT ON THIS LINE
;
50$:
	BBS	#UCB$V_INT,-		; IF INT EXP, THEN DON'T RESET,
		UCB$W_STS(R5),DZ32_OUT_LOOP
					; COULD HAVE BEEN SET DURING CALLBACK

	MOVL	@(SP),R4		; GET IDB ADDRESS
	BICB	UCB$B_ERTCNT(R5),-	; RESET THE OUTPUT ENABLE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)
	BRW	DZ32_OUT_LOOP


DZ32_START_BURST:
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
DZ32_BURST:
	MOVB	@UCB$L_TT_OUTADR(R5),-	; OUTPUT NEXT BYTE
		6(R0)		
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	DZ32_OUT_LOOP		; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
	BRW	DZ32_OUT_LOOP
;
; OUTPUT SINGLE CHARACTER
;
DZ32_CHAR:
	MOVB	UCB$W_TT_HOLD(R5),6(R0)	; OUTPUT CHAR IN TANK
	BICW	#TTY$M_TANK_HOLD,-	; SHOW TANK EMPTY
		UCB$W_TT_HOLD(R5)	
	BRW	DZ32_OUT_LOOP
;
; STOP OUTPUT
;
DZ32_STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; RESET OUTPUT ACTIVE
	MOVL	@(SP),R4		; GET IDB ADDRESS
	BICB	UCB$B_ERTCNT(R5),-	; RESET THE OUTPUT ENABLE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)
	BRW	DZ32_OUT_LOOP
DZ32_STOP2:
	BICB	#UCB$M_INT,UCB$W_STS(R5); SHOW OUTPUT NOT ACTIVE
	MOVL	@(SP),R4		; GET IDB ADDRESS
	BICB	UCB$B_ERTCNT(R5),-	; RESET THE OUTPUT ENABLE
		IDB$B_TT_ENABLE(R4)
	MOVB	IDB$B_TT_ENABLE(R4),7(R0)
	BRW	DZ32_OUT_LOOP

	.ENABLE	LSB
;
; SEND XON OR XOFF
;
DZ32_XOFF:
	BICW	#TTY$M_TANK_XOFF,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	BBC	#TTY$V_SX_TYPFUL,-
		UCB$Q_TT_STATE(R5),10$	; SKIP IF NOT TYPEAHEAD FULL

	BBS	#TT$V_HOSTSYNC,UCB$L_DEVDEPEND(R5),10$ ; XOFF CORRECT
	MOVZBL	#TTY$C_BELL,R3		; USE BELL CHARACTER
	BRB	25$
10$:
	MOVZBL	#TTY$C_XOFF,R3		; USE XOFF
	BRB	20$
DZ32_XON:
	BICW	#TTY$M_TANK_XON,-	; RESET XON STATE
		UCB$W_TT_HOLD(R5)
	MOVZBL	#TTY$C_XON,R3		; SEND XON
20$:
	BITL	#TT$M_HOSTSYNC!TT$M_READSYNC,-
		UCB$L_DEVDEPEND(R5)	; HOST OR READ SYNC TERMINAL?
	BEQL	30$			; NO, SKIP OUTPUT
25$:	MOVB	R3,6(R0)		; OUTPUT CHARACTER
30$:	BRW	DZ32_OUT_LOOP


	.DISABLE	LSB
	.PAGE
	.SBTTL	SET SPEED, PARITY PARAMETERS

;++
; DZ$SET_LINE - RESET SPEED, PARITY
;
; FUNCTIONAL DESCRIPTION:
;
; INPUTS:
;
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;
;	R4 USED
;--

DZ$SET_LINE:
	MOVL	UCB$L_CRB(R5),R4	; ADDRESS CRB
;
;	SET UP LINE SPEED AND PARITY
;
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; GET THE CSR ADDRESS VIA CRB
	CLRL	-(SP)				; RESET A TEMPORARY LOCATION
	SUBB3	#1,UCB$W_TT_SPEED(R5),1(SP)	; ADJUST DATA BASE SPEED
	MOVB	UCB$B_TT_PARITY(R5),(SP); SET PARITY,STOP, CHARACTER SIZE
	BICW	#^XF007,(SP)		; CLEAR SPECIAL FIELDS
	BBS	#UCB$V_TT_DSBL,-	; SKIP CLOCK ENABLE IF LINE DISABLED
		UCB$B_TT_MAINT(R5),3$
	BISW	#<DZLPR$M_CLOCK>,(SP)
3$:
	BISW	UCB$W_UNIT(R5),(SP)	; SET LINE NUMBER
	BITW	#DZCSR$M_MODE,(R4)	; DZ32 CONTROLLER?
	BNEQ	10$			; YES
5$:
	CVTLW	(SP)+,2(R4)		; INSERT AS LINE PARAMETER
	RSB

;	 HANDLE DZ-32 SPECIFIC FUNCTIONS
10$:
	CMPB	UCB$W_TT_SPEED(R5),-	; TRANSMIT/RECEIVE THE SAME
		UCB$W_TT_SPEED+1(R5)
	BEQL	5$			; YES, NO SPLIT SPEED
	TSTB	UCB$W_TT_SPEED+1(R5)	; RECEIVE SPEED SPECIFIED?
	BEQL	5$			; NO, NO SPLIT SPEED

; SET SPLIT SPEED
	
	BISW	#DZLPR$M_SPLIT,(SP)	; SET SPLIT SPEED BIT
	BRB	5$			; COMPLETE SETUP

	.PAGE

	.SBTTL	INITIALIZE DZ-11 MODEM POLLING

;++
; DZ$SET_MODEM - INIT MODEM POLLING
;
; FUNCTIONAL DESCRIPTION:
;
; INIT DZ-11 MODEM TRANSITION POLLING IF NOT ALREADY ACTIVE. LINK CRB
; FOR CURRENT LINE INTO MODEM TRANSITION POLLING LIST
;
; INPUTS:
;
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;
;	R0-R4 USED
;--

DZ11$SET_MODEM:
	MOVL	UCB$L_CRB(R5),R4	; ADDRESS CRB
	TSTL	DZ$L_DIALUP		; DZ-11 POLLING ALREADY ACTIVE?
	BNEQ	5$			; YES, SKIP STARTUP
	PUSHR	#^M<R3,R4,R5>
	MOVAL	DZ$TIMQUENT,R5		; ADDRESS OF TIMER ENTRY
	MOVB	#IPL$_QUEUEAST,TQE$B_RQTYPE(R5) ; SET FORK IPL
	PUSHAB	4$			; RETURN ADDRESS
	BRW	30$			; QUEUE FORK
4$:	POPR	#^M<R3,R4,R5>	
5$:
	MOVAL	CRB$L_DZ_MODEM(R4),R3	; ADDRESS OF DZ CRB THREAD
	MOVAL	DZ$L_DIALUP,R1		; ADDRESS OF DZ TIMER LIST HEAD
	MOVL	R1,R2
;
; LINK CRB INTO DZ-11 MODEM POLLER LIST IF NEEDED
;
10$:
	CMPL	(R2),R3			; IS CRB ON LIST
	BEQL	20$			; YES, DONE
	MOVL	(R2),R2			; POINT TO NEXT CRB
	BNEQ	10$			; LOOK FOR NEXT
	MOVL	(R1),(R3)		; LINK CRB AT LIST HEAD
	MOVL	R3,(R1)			;
20$:
	RSB
30$:
	JSB	G^EXE$FORK		; FORK TO QUEUE TIMER ENTRY
	DSBINT	#IPL$_SYNCH
	MOVAB	W^DZ$TIMER,TQE$L_FPC(R5); ADDRESS OF TIMER SERVICE ROUTINE
	MOVL	G^TTY$GL_DELTA,TQE$Q_DELTA(R5)
					; INTERVAL IS SYSGEN PARAMETER
	MOVB	#TQE$C_SSREPT,TQE$B_RQTYPE(R5)
	MOVQ	G^EXE$GQ_SYSTIME,R0
	ADDL	G^TTY$GL_DELTA,R0
	ADWC	#0,R1
	JSB	G^EXE$INSTIMQ		; INSERT INTO TIMER QUEUE
	ENBINT				; RESTORE IPL
	RSB

	.PAGE

	.PSECT	$$$117_DATA,QUAD
;
;	DZ-11 TIMER DATA STRUCTURES FOR DETECTION OF DZ-11 MODEM TRANSITIONS
;

DZ$L_DIALUP:
		.LONG	0			; LINKED LIST OF DZ-11 CRB'S 
						;  USING MODEM CONTROL
DZ$TIMQUENT:					; TIMER QUE ENTRY USED TO
						; SAMPLE DZ-11 MODEM SIGNALS
						; ON PERIODIC BASIS
	.ALIGN	QUAD
	.BLKB	TQE$C_LENGTH
	STO_TQE	TQE$W_SIZE,WORD,TQE$C_LENGTH,DZ$TIMQUENT
	STO_TQE	TQE$B_TYPE,BYTE,DYN$C_TQE,DZ$TIMQUENT
	STO_TQE	TQE$B_RQTYPE,BYTE,TQE$C_SSREPT,DZ$TIMQUENT


DZ$END:					; End of driver

	.END
