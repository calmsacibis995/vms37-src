	.TITLE	TTYFDT - Terminal driver function decision routines
	.IDENT	'V03-003'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT: THIS MODULE CONTAINS THE FUNCTION DECISION ROUTINES FOR TERMINAL
; RELATED I/O FUNCTIONS.
;
; AUTHOR: R.HEINEN 23-SEPT-76 VERSION V06
;
; Revision history:
;
;	V03-003	RKS0003		RICK SPITZ			05-APR-1982
;		ALLOW PASSALL DATA DURING UPCASE CONVERSION
;
;	V03-002	RKS0002		RICK SPITZ			31-MAR-1982
;		ADD SPECIAL CHARACTERISTIC BITS FOR DCL SPAWN
;		TRANSLATE LOWER CASE OUTPUT ON UPPERCASE DEVICES.
;		FIX SECURITY PROBLEM WITH AP AND TERMINATOR BITMAPS
;
;	V03-001	RKS0001		RICK SPITZ			23-MAR-1982
;		CORRECT ALTERNATE CLASS DRIVER DISPATCHING.
;		REPAIR SECURITY PROBLEM WITH USE OF AP.
;
;	V02-035	ROW0065		Ralph O. Weber			31-JAN-1982
;		Move test for IO$V_EXTEND in TTY$FDTREAD so as to eliminate 
;		executing duplicate code in both the regular class driver FDT 
;		and the alternate class driver FDT.  Add alternate class 
;		driver legal function test before dispatching to alternate 
;		class driver FDT.
;
;	V02-034	RKS034		RICK SPITZ			24-JAN-1982
;		IRP$W_TT_PRMPT+2 ENHANCED TO SPECIFY INITIAL READ FIELD OFFSET
;
;	V02-033	RKS033		RICK SPITZ			15-DEC-1981
;		ADD SUPPORT FOR ALTERNATE CLASS DRIVER.
;		REMOVE LOGIO REQUIREMENT FOR CONTROL Y ASTS.
;		REPAIR SET_MODEM MAINTENANCE FUNCTION.
;
;	V02-032	RKS032		RICK SPITZ			8-NOV-1981
;		ADD OUT OF BAND SUPPORT
;
;	V02-031	JLV0101		Jake VanNoy			27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-030	RKS030		RICK SPITZ			15-SEP-1981
;		REDEFINE DIAGNOSTIC MODEM BIT
;
;	V02-029	RKS029		RICK SPITZ			26-AUG-1981
;		ADD MAINT ENABLE BIT
;
;	V02-028	RKS028		RICK SPITZ			20-AUG-1981
;		ADD SUPPORT FOR ESCAPE MODIFIER ON READ
;
;	V02-027	RKS027		RICK SPITZ			30-APR-1981
;		THIS MODULE HAS BEEN ENHANCED TO SUPPORT QUADWORD STATE
;		AND DEVDEPEND STRUCTURES. ALSO ENHANCEMENTS WERE ADDED
;		TO SUPPORT CHANGES TO THE STRUCTURE OF THE UCB INCLUDING
;		SPLIT SPEED.
;		SUPPORT FOR DIAGNOSTIC MAINTENANCE FUNCTIONS HAS BEEN ADDED
;		AS WELL AS NEW FIELDS IN THE TWP. THIS ALLOWS FORKING 
;		ON THE TWP TO ALLOW ALLOCATION/DEALLOCATION OF MAP REGISTERS. 
;
;	V02-026	RKS026		RICK SPITZ			26-FEB-1981
;		DELETE V2.0 AUDIT TRAIL
;
;	V02-025	SPF0001		Steve Forgey			19-Dec-1980
;		Add RTE prompt support.
;
;
;--

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS:
;
	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$ARBDEF				; DEFINE ACCESS RIGHTS BLOCK
;	$CADEF				; DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$DDTDEF				; DEFINE DDT OFFSETS
	$DYNDEF				; DEFINE DYNAMIC MEMORY BLOCK TYPES
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL CONSTANTS
	$IRPDEF				; DEFINE I/O PACKET OFFSETS
	$JIBDEF				; DEFINE JIB OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PRVDEF				; DEFINE PRIVILEGES
	$PSLDEF				; DEFINE PSL OFFSETS
	$SSDEF				; Define system status codes
	$UCBDEF				; DEFINE UCB
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; EXTENDED TERMINAL CHARACTERISTICS
	$TTYMACS			; TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
;
; LOCAL DEFINITIONS
;
; QIO ARGUMENT LIST OFFSETS
;
P1 = 0
P2 = 4
P3 = 8
P4 = 12
P5 = 16
P6 = 20
 
	.PSECT	$$$115_DRIVER,LONG

	.SBTTL	TTY$FDTREAD - FUNCTION DECISION ROUTINE FOR TERMINAL READ FUNCTIONS
;++
; TTY$FDTREAD - FUNCTION DECISION ROUTINE FOR TERMINAL READ
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ACTION ROUTINE FOR TERMINAL READS.
;
; THE TERMINAL READ QIO PARAMETERS ARE:
;
;	P1 = ADDRESS OF THE BUFFER TO RECEIVE THE DATA RECORD
;	P2 = SIZE OF THE P1 BUFFER
;	P3 = NUMBER OF SECONDS TO WAIT FOR CHARACTERS (IO$M_TIMED ONLY)
;	P4 = ADDRESS OF TERMINATOR CLASS BITMASK OR 0 IF STANDARD
;	P5 = ADDRESS OF PROMPT STRING FOR IO$_READPROMPT
;	P6 = SIZE OF PROMPT STRINT FOR IO$_READPROMPT
;
; THE FUNCTION PARAMETERS ARE VALIDATED AND IF CORRECT, THE PACKET IS
; QUEUED ON THE UNIT I/O QUEUE.
; THE PACKET CONTAINS THE FOLLOWING:
;
;	1. IRP$Q_TT_STATE IS SET UP TO BE THE NEW TERMINAL STATES AT THE
;	   TIME THE READ OPERATION IS STARTED.
;	2. IRP$L_SVAPTE CONTAINS THE ADDRESS OF THE READ BUFFER
;	   FORMATTED AS FOLLOWS.
;
;		.LONG	ADDRESS TO STORE DATA
;		.LONG	USER BUFFER VIRTUAL ADDRESS
;		.WORD	SIZE
;		.WORD	TYPE
;		.WORD	STORAGE FOR STARTING CURSOR POSITION
;		.WORD TIMEOUT COUNT	
;		PROMPT STRING
;		READ BUFFER
;		TERMINATOR MASK FOR NONSTANDARD CLASSES
;
;	3. IRP$L_TT_TERM ADDRESSES THE TERMINATOR BITMASK
;	4. IRP$W_FUNC<0:6> ARE SET FOR A FAST CASE ON FUNCTION TYPE
;	5. IRP$W_BOFF IS THE QUOTA FOR THE I/O
;	6. IRP$W_BCNT IS THE READ REQUEST SIZE
;
; STATE BIT USAGE.
;
;	FOR IO$_READPBLK, TTY$V_ST_PASSALL IS SET.
;	FOR IO$_READPROMPT, TTY$V_ST_PROMPT AND TTY$V_ST_CTRLR ARE SET.
;		CTRLR WILL FORCE THE PROMPT OUT WHEN THE READ IS STARTED.
;
;	FOR IO$M_NOECHO, TTY$V_ST_NOECHO IS SET.
;	FOR IO$M_NOFILTR, TTY$V_ST_NOFILTR IS SET.
;	For IO$M_REFRESH, TTY$V_ST_REFRSH is set.
;
; INPUTS:
;
;	R3 = ADDRESS OF THE PACKET FOR THIS REQUEST
;	R4 = CURRENT PCB
;	R5 = UCB ADDRESS
;	R6 = ASSIGNED CCB
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
;
; OUTPUTS:
;
;	THE I/O IF IN ERROR IS COMPLETED VIA "EXE$ABORTIO".
;	THE I/O IF VALID IS QUEUED TO THE DRIVER BY "EXE$QIODRVPKT".
;
; COMPLETION CODES:
;
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER.
;	SS$_EXQUOTA - OVER QUOTA FOR BUFFERED I/O
;	SS$_INSFMEM - INSUFFICIENT MEMORY
;--

TTY$FDTREAD::				;
	BBC	#IO$V_EXTEND,-		; CHECK IF ALTERNATE CLASS REQUIRED
		IRP$W_FUNC(R3),2$	; 
	BRW	200$			; DISPATCH ALTERNATE FDT
2$:

	PUSHL	R3			; SAVE PACKET ADDRESS
;
; SET PROPER STATE BITS FOR READ FUNCTIONS FROM FUNCTION MODIFIERS
;
; NOTE THE CORRESPONDENCE OF THE VALUES
;
	ASHL	#TTY$V_ST_NOECHO-	; Move function code and its
		-IO$V_NOECHO,-		; modifiers into bits 9-25 of
		IRP$W_FUNC(R3),R8	; a register.
	BICL	#^C<TTY$M_ST_NOECHO!-	; Clear all bits except NOECHO
		TTY$M_ST_NOFLTR!-	; NOFLTR, and
		TTY$M_ST_ESCAPE!-	; ESCAPE
		TTY$M_ST_REFRSH>,R8	; REFRESH if specified.
	MOVZWL	#TTY$M_ST_READ,-
		IRP$Q_TT_STATE(R3)	; INIT AND ADD READ
;
; CHECK ACCESS TO READ BUFFER
;
	MOVL	P1(AP),R0		; GET BUFFER ADDRESS AND SIZE
	MOVZWL	P2(AP),R1		;
	BNEQ	5$			; IF NEQ THEN ACTUAL READ
	BBCS	#TTY$V_ST_EOL,-
		IRP$Q_TT_STATE(R3),10$	; SET EOL AND BRANCH
5$:	JSB	G^EXE$READCHK		; CHECK READ ACCESS FOR BUFFER
					; NO RETURN MEANS NO ACCESS
10$:	MOVQ	R0,R9			; COPY INPUT BUFFER PARAMS
	CLRL	R7			; ASSUME 0 BUFFER SIZE
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#IO$_READPBLK; PASSALL?
	BEQL	12$			; IF EQL THEN YES
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; TEMP READ PASSALL
		IRP$W_FUNC(R3),#IO$_TTYREADALL
	BNEQ	20$			; NO, BRANCH
12$:

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,15$	; IF FLAG OFF BYPASS NEXT INST.
	INCL	G^PMS$GL_PASSALL	; ELSE INCR PASSALL COUNTER

	.ENDC

15$:	BBCS	#TTY$V_ST_PASALL,R8,50$	; SET PASSALL MODE AND BR
;
; DO SPECIAL FUNCTION LOGIC FOR READ WITH PROMPT
;
20$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READPROMPT?
		IRP$W_FUNC(R3),#IO$_READPROMPT
	BEQL	22$			; YES, BRANCH
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READ PASSALL W/PROMPT?
		IRP$W_FUNC(R3),#IO$_TTYREADPALL
	BNEQ	50$			; BRANCH IF NO
	BBCS	#TTY$V_ST_PASALL,R8,22$	; SET PASSALL BIT IN VECTOR
22$:
;
; SEE IF NO PROMPT IS SPECIFIED
;
	MOVZWL	P6(AP),R7		; GET SIZE OF PROMPT
	BEQL	50$			; IF EQL THEN MAKE THIS NORMAL READ
;
; READ WITH PROMPT
;

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,30$	; IF FLAG OFF, BYPASS NEXT INST
	INCL	G^PMS$GL_RWP		; INCR READ WITH PROMPT COUNTER
	CMPL	#12,R7			; \ISOLATE READ WITH PROMPTS
	BGTR	25$			; /GREATER THAN 12 CHARS
	INCL	G^PMS$GL_LRGRWP		; INCR CTR FOR PROMPTS > 12 CHARS
25$:	ADDL2	R7,G^PMS$GL_RWPSUM	; KEEP RUNNING SUM OF RWP SIZES

	.ENDC

30$:	BISL	#TTY$M_ST_PROMPT,R8	; INSERT BITS FOR PROMPT
	BISL	#TTY$M_ST_CTRLR,IRP$Q_TT_STATE(R3); INSERT BITS FOR PROMPT
	MOVL	P5(AP),R0		; GET PROMPT BUFFER ADDRESS
;
; CHECK ACCESS TO PROMPT STRING
;
	MOVZWL	R7,R1			; GET SIZE PROMPT
	JSB	G^EXE$WRITECHK		; CHECK PROMPT BUFFER ACCESS
					; NO RETURN MEANS NO ACCESS
	MOVL	R0,R6			; COPY PROMPT STRING ADDRESS
	ADDL	R10,R1			; ADJUST PROMPT SIZE TO OVERALLOCATE
	MOVW	R10,IRP$W_BCNT(R3)	; SAVE ACTUAL READ SIZE
	BBSS	#IRP$V_FUNC,IRP$W_STS(R3),50$; RESET TRANSFER DIRECTION
50$:	ADDW3	#TTY$L_RB_DATA,R7,IRP$W_TT_PRMPT(R3); ADJUST PROMPT SIZE FOR HEADER
	CLRW	IRP$W_TT_PRMPT+2(R3)	; ZERO INITIAL READ OFFSET
	ADDL	#TTY$L_RB_DATA,R1	; ADJUST SIZE FOR BLOCK HEADER
	BBC	#TT$V_SCRIPT,UCB$L_DEVDEPEND(R5),55$; RTE TERMINAL LINE ?
	INCW	IRP$W_TT_PRMPT(R3)	; ADD RTE PROMPT SIZE
	INCL	R1			; ADD RTE PROMPT SIZE
	BISL2	#TTY$M_ST_PROMPT,R8	; ENSURE FUNCTION IS A RWP
	BISL2	#TTY$M_ST_CTRLR,-
		IRP$Q_TT_STATE(R3)	; ENSURE FUNCTION IS A RWP
	BBSS	#IRP$V_FUNC,IRP$W_STS(R3),55$; ENSURE TRANFER DIRECTION RESET
55$:	MOVAB	TTY$A_STANDARD,IRP$L_TT_TERM(R3); ASSUME STANDARD TERMINATORS
	MOVL	P4(AP),IRP$L_MEDIA(R3)	; GET ADDRESS OF TERMINATOR BITMASK
	BEQL	65$			; IF EQL THEN STANDARD
	MOVL	IRP$L_MEDIA(R3),R2	; RETRIEVE ADDRESS
	MOVZWL	R1,IRP$B_CARCON(R3)	; SAVE OFFSET IN BUFFER BLOCK
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ACCESS VIOLATION
	IFNORD	#8,(R2),70$		; DESC. ACCESSIBLE?
	MOVL	4(R2),R11		; GET BITMAP ADDRESS
	MOVZWL	(R2),R10		; GET BITMAP SIZE
	BEQL	60$			; IF EQL THEN SHORT FORM
	CMPW	R10,#32			; CHECK FOR VALID LENGTH
	BLEQU	57$			; RANGE OK	
	MOVZWL	#32,R10			; USE MAXIMUM
57$:	IFNORD	R10,(R11),70$		; BITMAP ACCESSIBLE?
60$:	ADDL	#16,R1			; ASSUME NOT EIGHTBIT
;
; BY RIGHTS, THIS TEST SHOULD NOT BE MADE HERE, THE DEVICE COULD
; CHANGE STATES BETWEEN NOW AND THE TIME THE READ TERMINATOR
; TEST IS MADE. THIS MEANS THAT THE TERMINATOR TEST MAY NOT BE CORRECT
; ON THE INTERIM I/O.
;
	BBC	#TT$V_EIGHTBIT,UCB$L_DEVDEPEND(R5),65$; BR IF NOT EIGHTBIT TTY
	ADDL	#16,R1			; MAKE BITMAP 8-BIT SIZE
;
; ALLOCATE HEADER + PROMPT + DATA + BITMASK
;
; CHECK FOR BUFFERED I/O QUOTA
;
65$:	JSB	G^EXE$BUFFRQUOTA	; CHECK QUOTA
	BLBC	R0,70$			; SIGNAL ERROR IF LOW CLEAR
;
; ALLOCATE THE BUFFER
;
	JSB	G^EXE$ALLOCBUF		; ALLOCATE THE BUFFER
70$:	POPL	R3			; RESTORE PACKET
	BLBS	R0,72$			; CONTINUE IF NO ERROR
	BRW	100$			; IF ERROR, THEN ABORT I/O
72$:					;
	BBC	#TT$V_SCRIPT,UCB$L_DEVDEPEND(R5),74$; RTE SCRIPT LINE ?
	MOVAB	TTY$L_RB_DATA(R2),R0	; GET ADDRESS FOR RTE PROMPT CHARACTER
	ADDL2	R7,R0
	MOVB	@#PMS$GB_PROMPT,(R0)	; INSERT RTE PROMPT
74$:	MOVL	R2,IRP$L_SVAPTE(R3)	; SAVE ADDRESS OF BUFFERED I/O BLOCK
	MOVW	R1,IRP$W_BOFF(R3)	; SAVE BLOCK SIZE AS QUOTA
;
; ADJUST BUFFERED I/O QUOTA
;
	MOVL	PCB$L_JIB(R4),R4	; GET JIB ADDRESS
	MOVZWL	R1,R1			; CONVERT TO LONG WORD COUNT
	SUBL	R1,JIB$L_BYTCNT(R4)	; ADJUST QUOTA WORD
;
;	MARK PACKET AS TERMINAL I/O
;
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3)	; SET FLAG FOR GREATER PRIORITY
					; INCREMENTS UPON COMPLETION
;
; SET UP BUFFERED I/O BLOCK
;
	MOVL	R9,TTY$L_RB_UVA(R2)	; INSERT USER VIRTUAL ADDRESS
	MOVAB	TTY$L_RB_DATA(R2),TTY$L_RB_NXT(R2); INSERT POINTER TO DATA AREA
	PUSHR	#^M<R2,R3,R5>		; SAVE REGISTERS
	MOVL	IRP$L_MEDIA(R3),R4	; ADDRESS BITMAP ADDRESS
	BEQL	90$			; IF EQL THEN STANDARD

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,75$	; IF FLAG OFF, BYPASS NEXT INSTRUCTION
	INCL	G^PMS$GL_NOSTDTRM	; ELSE, INCR NON STD. TERMINATOR CTR
	TSTL	P6(AP)			; \CHECK IF PROMPT SIZE
	BEQL	75$			; /= 0
	INCL	G^PMS$GL_RWPNOSTD	; INCR CTR OF RWP WITH NON STD TERMS

	.ENDC

75$:	ADDL	R2,IRP$L_TT_TERM(R3)	; CALC ADDR OF BITMAP SPACE
	SUBW	IRP$W_TT_PRMPT(R3),R1	; CALC BITMAP SIZE
	SUBW	IRP$W_BCNT(R3),R1	;
	TSTW	R10			; CHECK SIZE OF MAP
	BNEQ	80$			; IF NEQ THEN SPECIFIED
	MOVZBL	#4,R10			; SET SIZE OF SHORT FORM
	MOVAB	4(R4),R11		; ADDRESS SHORT FORM LONG WORD
80$:	MOVC5	R10,(R11),#0,R1,@IRP$L_TT_TERM(R3); COPY BITMAP
90$:	MOVL	(SP)+,R2		; RETRIEVE BLOCK ADDRESS
	MOVW	P3(AP),TTY$W_RB_TIMOS(R2); GET TIMEOUT COUNT
;
; READ WITH PROMPT?
;
	BBC	#TTY$V_ST_PROMPT,R8,95$	; BR IF NOT PROMPT READ
	MOVL	4(SP),R5		; GET UCB ADDRESS
	BBC	#TT$V_LOWER,-
		UCB$L_DEVDEPEND(R5),150$; BRANCH IF UPPER CASE ONLY
93$:
	MOVC3	R7,(R6),TTY$L_RB_DATA(R2); COPY PROMPT STRING TO BUFFERED BLOCK

95$:	POPR	#^M<R3,R5>		; RESTORE IRP ADDRESS
;
; QUEUE I/O PACKET TO UNIT
;
	MOVL	R8,IRP$Q_TT_STATE+4(R3)	; PUT STATE DATA IN PACKET
	INSV	#TTY$C_FC_READ,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3)
	JMP	G^EXE$QIODRVPKT		; INSERT PACKET ON QUEUE
;
; ERROR IN PROCESSING
;
100$:	JMP	G^EXE$ABORTIO		; THE I/O IS DONE

; TRANSLATE TO UPPERCASE

150$:
	BBS	#TTY$V_ST_PASALL,R8,93$	; NO TRANSLATE IF PASSALL
	BBS	#TTY$V_SX_PASALL,-	;
		UCB$Q_TT_STATE(R5),93$
160$:
	MOVAB	TTY$L_RB_DATA(R2),R2	; GET DESTINATION ADDRESS
	BSBW	MOVE_TRANSLATE		; TRANSLATE DATA
	BRB	95$

	.PAGE
;
; DISPATCH TO FDT IN ALTERNATE CLASS DRIVER
;
200$:
	MOVL	UCB$L_TT_ALTDRV(R5),R0	; GET ALTERNATE CLASS DRIVER VECTOR
	BEQL	210$			; NONE, ERROR
	JMP	@CLASS_DDT(R0)		; DISPATCH TO FDT ROUTINE

210$:
	MOVZWL	#SS$_ILLIOFUNC,R0	; SIGNAL ERROR
	BRB	100$

	.SBTTL	TTY$FDTWRITE - Function decision routine for terminal writes

;++
; TTY$FDTWRITE - FUNCTION DECISION ROUTINE FOR TERMINAL WRITE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ROUTINE FOR TERMINAL WRITE FUNCTIONS.
;
; THE QIO PARAMETERS FOR TERMINAL WRITES ARE:
;
;	P1 = ADDRESS OF THE BUFFER
;	P2 = SIZE OF THE BUFFER
;	P3 = UNUSED
;	P4 = CARRIAGE CONTROL SPECIFIER (SEE EXE$CARRIAGE)
;
; THE FUNCTION PARAMETERS ARE VALIDATED AND IF CORRECT, a write packet
; that points to the IRP is sent to the terminal driver's write start
; I/O routine (ALTSTART in the DDT).
;
;
; 	IRP$W_BOFF CONTAINS THE QUOTA FOR THIS I/O
;	IRP$W_BCNT CONTAINS THE TRANSFER COUNT
;	IRP$W_FUNC IS SET FOR A FAST CASE ON FUNCTION TYPE
;
; FOR IO$_WRITEPBLK OR IO$M_NOFORMAT, TTY$V_ST_WRTALL IS SET TO PREVENT
; FORMATTING OF THE DATA.
;
;	If IO$_REFRESH is specified, this routine sets TTY$V_ST_REFRSH
;	to refresh a delayed read when the write completes.
;
; INPUTS:
;
;	R3 = I/O PACKET
;	R4 = PCB OF PROCESS
;	R5 = UCB
;	R6 = ASSIGNED CCB
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF FIRST USER QIO PARAMETER
;
; OUTPUTS:
;
;	IF THE I/O IS IN ERROR THEN IT IS COMPLETED BY "EXE$ABORTIO".
;	If the I/O is valid, then the address of the buffered block is
;	loaded into R3, and the block queued to EXE$ALTQUEPKT.
;
; COMPLETION CODES:
;
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER ( FROM "EXE$WRTCHK" )
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR REQUEST
;	SS$_EXQUOTA - BUFFERED I/O QUOTA EXCEEDED
;--

TTY$FDTWRITE::				;
	MOVL	P1(AP),R6		; GET USER BUFFER VIRTUAL ADDRESS
	CLRL	IRP$B_CARCON(R3)	; ASSUME NO CARRIAGE CONTROL SPECIFIER
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,R7,#IO$_WRITEPBLK; WRITE PHYSICAL BLOCK?
	BEQL	10$			; IF EQL THEN YES
	MOVL	P4(AP),IRP$B_CARCON(R3)	; GET CARRIAGE CONTROL SPECIFIER
	JSB	G^EXE$CARRIAGE		; CONVERT THE CARRIAGE CONTROL
10$:	MOVZBL	IRP$B_CARCON(R3),R8	; CALC NUMBER OF EXTRA PLACES
	MOVZBL	IRP$B_CARCON+2(R3),R2	; NEEDED FOR CONTROL
	ADDL	R2,R8			;
	MOVL	R6,R0			; SET UP FOR WRITE CHECK CALL
	MOVZWL	P2(AP),R7		; GET TRANSFER SIZE
	MOVL	R7,R1			; COPY TRANSFER SIZE
	BEQL	12$			; SKIP CHECK IF ZERO
	JSB	G^EXE$WRITECHK		; CHECK BUFFER ACCESS
;
; INIT STATE FIELD
;					; NO RETURN MEANS NO ACCESS
12$:
	CLRQ	IRP$Q_TT_STATE(R3)	; INIT STATE REGION
	MOVZWL	#<TTY$M_ST_WRITE>,-
		IRP$Q_TT_STATE(R3)	; INIT WRITE FUNCTION
;
; SET WRITE PASSALL STATE FOR WRTPASSALL
;
	BBS	#IO$V_NOFORMAT,IRP$W_FUNC(R3),15$; BR IF NO FORMAT SPECIFIED
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#IO$_WRITEPBLK; PASSALL WRITE?
	BNEQ	20$			; No passall, branch forward.

15$:
	BBSS	#TTY$V_ST_WRTALL,-	; Set no format mode for
		IRP$Q_TT_STATE+4(R3),20$	; write.


20$:	PUSHR	#^M<R3,R4,R5>		; SAVE SOME REGISTERS
	MOVAB	TTY$L_WB_DATA+4(R8)[R1],R1; ADD HEADER TO REQUEST AND CARRIAGE CONTROL
;
; CHECK BUFFERED I/O QUOTA
;
	JSB	G^EXE$BUFFRQUOTA	; CHECK QUOTA
	BLBS	R0,30$			; Branch forward on success.
	BRW	105$			; Otherwise, branch to error.

;
; Allocate the buffer.
;

30$:
	JSB	G^EXE$ALLOCBUF		; Allocate buffered I/O block.
	BLBS	R0,40$			; Branch forward on success.
	BRW	105$			; Otherwise, branch to error

40$:
					; exit.
	MOVL	(SP),R3			; RESTORE PACKET ADDRESS
	MOVL	R2,IRP$L_SVAPTE(R3)	; SAVE BLOCK ADDRESS IN PACKET
	ADDW	R8,IRP$W_BCNT(R3)	; ADJUST TRANSFER SIZE FOR CARRIAGE CONTROL
;
; ADJUST QUOTA
;
	MOVL	PCB$L_JIB(R4),R8	; GET JIB ADDRESS
	MOVZWL	R1,R1			; CONVERT COUNT TO LONGWORD
	SUBL	R1,JIB$L_BYTCNT(R8)	; ADJUST BUFFERED I/O QUOTA
	MOVW	R1,IRP$W_BOFF(R3)	; SAVE BLOCK SIZE AS QUOTA

;
;	MARK PACKET AS TERMINAL I/O
;
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3)	; SET FLAG FOR GREATER PRIORITY
					; INCREMENTS UPON COMPLETION
;
; SET UP THE BLOCK
;
	MOVZBL	#DYN$C_TWP,-		; Insert block type.
		TTY$B_WB_TYPE(R2)
	MOVL	R3,TTY$L_WB_IRP(R2)	; Insert IRP address.
	MOVAB	TTY$L_WB_DATA(R2),-	; Insert start of data address
		TTY$L_WB_NEXT(R2)	; in "next character" field.
	ADDL	#TTY$L_WB_DATA,R2	; POINT TO DATA
;
; INSERT INITIAL CARRIAGE CONTROL
;
	MOVAB	IRP$B_CARCON(R3),R8	; INSERT THE CHARACTERS
	BSBB	110$			;
;
; CHECK FOR UPPERCASE ONLY
;
	BBC	#TT$V_LOWER,-		; CHECK IF LOWER CASE ALLOWED
		UCB$L_DEVDEPEND(R5),150$	
;
; COPY USER DATA TO BUFFER
;
50$:	MOVC3	R7,(R6),(R2)		; MOVE THE DATA
	MOVL	R3,R2			; COPY CURRENT END OF DATA
;
; THE USER DATA IS COPIED -- ADD TRAILING CARRIAGE RETURN IF NECESS.
;
60$:	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
	MOVAB	IRP$B_CARCON+2(R3),R8	;
	BSBB	110$			; INSERT CHARACTERS

;
; If the write function specified IO$_REFRESH, set the appropriate bit
; position for the UCB state bits.
;

95$:					; Check for REFRESH bit.
	BBC	#IO$V_REFRESH,-		; If REFRESH is not specified,
		IRP$W_FUNC(R3),100$	; just branch forward.
	BBSS	#TTY$V_ST_REFRSH,-	; Otherwise, set the refresh
		IRP$Q_TT_STATE+4(R3),100$	; bit for the state longword.

;
; COMPLETE THE WRITE OPERATION
;
100$:	MOVL	IRP$L_SVAPTE(R3),R1	; GET BLOCK ADDRESS
	MOVL	R2,TTY$L_WB_END(R1)	; INSERT ADDRESS OF DATA END
	INSV	#TTY$C_FC_WRITE,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	MOVW	IRP$W_BCNT(R3),-	; Move the character count
		TTY$W_WB_BCNT(R1)	; into the write packet.
	BBC	#TT$V_HALFDUP, -	; branch if full duplex
		UCB$L_DEVDEPEND(R5), -	; if half duplex, call normal
		102$			; tty$startio entry point
	JMP	G^EXE$QIODRVPKT		; R3/addr of write IRP
102$:
	MOVL	R1,R3			; Set up write block address.
	JSB	G^EXE$ALTQUEPKT		; Queue packet to driver's write
					; STARTIO routine.
	JMP	G^EXE$QIORETURN		; Return to requesting process.
;
; ERROR IN PROCESSING
;
105$:	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
	JMP	G^EXE$ABORTIO		; ABORT THE I/O
;
; SUBROUTINE TO INSERT PRE/SUF CARRIAGE CONTROL
;
110$:	MOVZBL	(R8),R0			; GET NUMBER OF CHARACTERS
	BEQL	130$			; IF EQL THEN NONE
	MOVB	1(R8),(R2)+		; INSERT CHARACTER
	BNEQ	130$			; IF NEQ THEN DONE
	MOVB	#TTY$C_CR,-1(R2)	; INSERT CARRIAGE RETURN TO START
	INCW	IRP$W_BCNT(R3)		; INCREASE BYTE COUNT FOR CR
120$:	MOVB	#TTY$C_LF,(R2)+		; INSERT LINE FEEDS
	SOBGTR	R0,120$			; UNTIL DONE
130$:	RSB				;

;
; TRANSLATE TO UPPERCASE
;
150$:
	BBS	#TTY$V_ST_WRTALL,-		; If no format mode 
		IRP$Q_TT_STATE+4(R3),50$	; no translate.
	BBS	#TTY$V_SX_PASALL,-		; Or passall
		UCB$Q_TT_STATE(R5),50$

	BSBW	MOVE_TRANSLATE
	BRW	60$

	.SBTTL	TTY$FDTSETM -- FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE
;++
; TTY$FDTSETM - FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE FUNCTIONS.
; THERE ARE TWO BASIC FUNCTIONS -- SET UP FOR CONTROL C AND SET MODE.
;
; THE FUNCTION CODE IS SET FOR A FAST CASE ON TYPE
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = PCB ADDRESS OF CURRENT PROCESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS FOR ASSIGNED UNIT
;	AP = ADDRESS OF ARGUMENT LIST AT USER PARAMETERS
;
; OUTPUTS:
;
;	THE FUNCTION IS COMPLETED HERE BY "EXE$FINISHIO".
;
; IMPLICIT OUTPUTS:
;
; 	R3,R5 ARE PRESERVED.
;--
TTY$FDTSETM::				;
	INSV	#TTY$C_FC_SETM,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	MOVL	UCB$L_TT_DEVDP1(R5),IRP$Q_TT_STATE+4(R3)	;INIT DEFAULT
	BRB	SET_COMMON

	.SBTTL	TTY$FDTSETC - FUNCTION DECISION ROUTINE FOR TERMINAL SET CHARS
;++
; TTY$FDTSETC - FUNCTION DECISION ROUTINE FOR TERMINAL SET CHARACTERISTICS FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE FUNCTIONS.
; THERE ARE TWO BASIC FUNCTIONS -- SET UP FOR CONTROL Y AND SET MODE.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = PCB ADDRESS OF CURRENT PROCESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS FOR ASSIGNED UNIT
;	AP = ADDRESS OF ARGUMENT LIST AT USER PARAMETERS
;
; OUTPUTS:
;
;	THE FUNCTION IS COMPLETED HERE BY "EXE$FINISHIO".
;
; IMPLICIT OUTPUTS:
;
; 	R3,R5 ARE PRESERVED.
;--
TTY$FDTSETC::				;
	INSV	#TTY$C_FC_SETC,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	MOVL	UCB$L_TT_DECHA1(R5),IRP$Q_TT_STATE+4(R3)	;INIT DEFAULT
SET_COMMON:
	BBC	#IO$V_HANGUP, -		; BRANCH IF NOT HANGUP
		IRP$W_FUNC(R3),10$	;
	BRW	HANGUP			; HANGUP IGNORES P1-PN.
10$:
	; LOOPBACK/CONTROL  DIAGNOSTIC FUNCTIONS?
	BITW	#<IO$M_MAINT>,IRP$W_FUNC(R3)
	BEQL	15$			; NO
	BRW	QMAINT			; YES
15$:
	MOVAB	UCB$L_TT_CTRLC(R5),R7	; ASSUME CONTROL C
	BBS	#IO$V_CTRLCAST,IRP$W_FUNC(R3),CTRLAST; BR IF CONTROL C
	MOVAB	UCB$L_TT_CTRLY(R5),R7	; ADDRESS LIST HEAD
	BBC	#IO$V_CTRLYAST,IRP$W_FUNC(R3),OUTBAND; BR IF NOT

CTRLAST:
	CLRL	R2			; NULL MASK
	JSB	G^COM$SETATTNAST	; ENTER SET UP CODE
	BBC	#IO$V_CTRLYAST, -	; BR IF NOT ENABLING CTRL-Y
		IRP$W_FUNC(R3),10$	; ASTS
	BBCC	#UCB$V_TT_HANGUP, -	; BR IF PROCESS HAS NOT TRIED
		UCB$W_DEVSTS(R5),10$	; TO HANG UP
;
; HANGUP MUST HAVE OCCURRED WHEN CTRL-Y ASTS WERE DISABLED.  SIGNAL
; THAT THIS PROCESS MUST BE DELETED.SIGNAL BIT CLEARED BY PREVIOUS INSTRUCTION
;
	MOVL	R7,R4			; SET ADDRESS OF AST LISTHEAD
	MOVL	(R4),R0			; GET ADDRESS OF AST BLOCK
	MOVZWL	#SS$_HANGUP, -		; AST PARAMETER IS HANGUP
		ACB$L_KAST+4(R0)	; NOTIFICATION
	JSB	G^COM$DELATTNAST	; DELIVER HANGUP AST IMMEDIATELY
	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS
10$:
	JMP	G^EXE$FINISHIOC		;
;
; ENABLE OUT OF BAND MASK
;
OUTBAND:
	BBC	#IO$V_OUTBAND,IRP$W_FUNC(R3),SET; NOT OUT OF BAND FUNCTION
	MOVAB	UCB$L_TT_BANDQUE(R5),R7		; GET LIST HEAD ADDRESS
	MOVAL	UCB$L_TT_OUTBAND(R5),R2		; GET CURRENT MASK ADDRESS
	JSB	G^COM$SETCTRLAST		; ENABLE/DISABLE AST
	JMP	G^EXE$FINISHIOC			; DONE
;
; PROCESS SET MODE OR CHARACTERISTICS
;
SET:					;
	MOVL	P1(AP),R1		; GET ADDRESS OF BUFFER
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ACCESS VIOLATION
	IFNORD	#8,(R1),BAD_SET		; BR IF NO ACCESS TO QUADWORD BUFFER
	MOVL	(R1),IRP$L_MEDIA(R3)	; SAVE NEW DATA
	MOVL	4(R1),IRP$Q_TT_STATE(R3); SAVE 1ST DEVDEPEND WORD
	CMPL	P2(AP),#12		; CHECK FOR SECOND DEVDEPEND ARGUMENT
	BLSSU	5$			; NONE
	IFNORD	#12,(R1),BAD_SET	; CHECK IF ADDRESSABLE
	MOVL	8(R1),IRP$Q_TT_STATE+4(R3)
					; GET 2ND DEVDEPEND WORD
5$:
	BBS	#IO$V_SET_MODEM,-	; IF SET MODEM DIAGNOSTIC FUNCTION
		IRP$W_FUNC(R3),QPKT	; THEN OK

	TSTW	2(R1)			; PAGE WIDTH 0?
	BLEQ	10$			; 0 IS BAD WIDTH
	CMPW	#TTY$C_MAXPAGWID,2(R1)	; RESTRICT WIDTH
	BGEQ	GOOD_SET		; FALL THROUGH IF > MAX
10$:
	MOVZWL	#SS$_BADPARAM,R0	; SET ERROR
BAD_SET:JMP	G^EXE$ABORTIO		; RETURN ON ERROR
GOOD_SET:
	MOVW	P3(AP),IRP$W_TT_PRMPT(R3) ; GET THE SPEED PARAMETER
	MOVW	P4(AP),IRP$W_TT_PRMPT+2(R3); SAVE FILLS
	MOVB	P5(AP),IRP$L_MEDIA(R3)	; SAVE PARITY
QPKT:	JMP	G^EXE$QIODRVPKT		; QUEUE PACKET TO DRIVER
HANGUP: INSV	#TTY$C_FC_N_SET,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3) ; SET
					;   SENSE, NO SET INVOLVED.
	BRB	QPKT			; AND CONTINUE
QMAINT:
	BBS	#IO$V_SET_MODEM,-	; IF SET MODEM DIAGNOSTIC FUNCTION
		IRP$W_FUNC(R3),SET	; THEN GET P1 BLOCK
	BRB	QPKT			; ELSE JUST QUEUE IT


	.SBTTL	SENSE MODE OR CHARACTERISTICS
;++
; TTY$FDTSENSEM - SENSE MODE
; TTY$FDTSENSEC - SENSE CHARACTERISTICS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PASSES THE CURRENT CHARACTERISTICS FOR SENSEMODE AND
; THE PERMANENT CHARACTERISTICS FOR SETCHAR.
; THE BUFFER RETURNED IS A QUADWORD.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	AP = ARG LIST FROM QIO
;
; OUTPUTS:
;
;	CONTROL IS PASSED TO EXE$FINISHIO ON SUCCESS
;	AND EXE$ABORTIO ON FAILURE
;
; STATUS RETURNS:
;
;	SS$_NORMAL - SUCCESSFULL
;	SS$_ACCVIO - BUFFER NOT ACCESSIBLE
;--
TTY$FDTSENSEM::				; SENSE MODE
	BSBB	COMMON_SENSE		; PROCESS ARG LIST
	MOVL	UCB$B_DEVCLASS(R5),(R1); RETURN CLASS, TYPE AND BUFFER SIZE
	MOVL	UCB$L_DEVDEPEND(R5),4(R1); RETURN DEVICE DEPENDENT LONG WORD
	CMPL	R11,#12			; ROOM FOR SECOND DEVDEPEND LONG WORD?
	BLSSU	5$			; NO
	MOVL	UCB$L_TT_DEVDP1(R5),8(R1); RETURN SECOND DEVDEPEND LONGWORD
	BSBW	GET_SPECIAL		; GET SPECIAL CHARACTERISTIC BITS
5$:	MOVL	UCB$W_TT_SPEED-2(R5),R0 ; RETURN SPEED
	BICL3	#^C<<UCB$M_TT_PARTY!UCB$M_TT_ODD>@16>,UCB$B_TT_PARITY-2(R5),R1;
	MOVW	UCB$B_TT_CRFILL(R5),R1	; INSERT FILL DATA
	MOVW	#SS$_NORMAL,R0		; SET STATUS
	JMP	G^EXE$FINISHIO		; COMPLETE THE I/O
;
;
TTY$FDTSENSEC::				; SENSE CHAR
	BSBB	COMMON_SENSE		; PROCESS ARG LIST
	MOVB	#DC$_TERM,(R1)		; SET CLASS
	MOVL	UCB$B_TT_DETYPE(R5),1(R1); RETURN TYPE AND BUFFER SIZE
	MOVL	UCB$L_TT_DECHAR(R5),4(R1); RETURN DEVICE DEPENDENT LONG WORD
	CMPL	R11,#12			; ROOM FOR SECOND DEVDEPEND LONG WORD?
	BLSSU	5$			; NO
	MOVL	UCB$L_TT_DECHA1(R5),8(R1); RETURN SECOND DEVDEPEND LONGWORD
	BSBW	GET_SPECIAL		; GET SPECIAL CHARACTERISTIC BITS
5$:	MOVL	UCB$W_TT_DESPEE-2(R5),R0; RETURN SPEED
	BICL3	#^C<<UCB$M_TT_PARTY!UCB$M_TT_ODD>@16>,UCB$B_TT_DEPARI-2(R5),R1;
	MOVW	UCB$B_TT_DECRF(R5),R1	; INSERT FILL DATA
	MOVW	#SS$_NORMAL,R0		; SET STATUS
	JMP	G^EXE$FINISHIO		; COMPLETE THE I/O

;
; COMMON SENSE SUBROUTINE
;
COMMON_SENSE:				;
	MOVL	P1(AP),R1		; ADDRESS BUFFER
	IFNOWRT	#8,(R1),30$		; BR IF NO ACCESS TO QUADWORD BUFFER
	BBC	#IO$V_TYPEAHDCNT,-	; IS FUNCTION SENSE TYPEAHEAD
		IRP$W_FUNC(R3), 20$	; INFO?  BRANCH IF NOT.
	CLRQ	(R1)			; ASSUME NO TYPAHD BUFFER
	MOVL	UCB$L_TT_TYPAHD(R5),R0	; ADDRESS OF TYPEAHEAD BUFFER
	BEQL	10$			; NO BUFFER
	MOVW	UCB$W_TT_INAHD(R5),(R1)	; GET # OF CHARS IN TYPAHD BUF
	MOVB	@TTY$L_TA_GET(R0),2(R1)	; GET LOOKAHEAD CHARACTER
10$:	MOVZWL	#SS$_NORMAL,R0		; SUCCESS STATUS
	JMP	G^EXE$FINISHIO		; COMPLETE THE I/O
20$:
	MOVL	P2(AP),R11		; GET SIZE ARGUMENT
	CMPL	R11,#12			; ROOM FOR SECOND DEVDEPEND SPECIFIED?
	BLSSU	25$			; NO
	IFNOWRT	#12,(R1),30$		; CHECK IF WRITE ACCESS
25$:
	BBC	#IO$V_RD_MODEM,-	; SKIP IF NOT READ MODEM FUNCTION
		IRP$W_FUNC(R3),28$
	CLRQ	(R1)			; INIT RETURN VALUES
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVB	CRB$B_TT_TYPE(R0),(R1)	; RETURN CONTROLLER TYPE
	MOVB	UCB$B_TT_DS_RCV(R5),2(R1); RETURN CURRENT RECEIVE MODEM SIGNALS
	BRB	10$			; FINISHED
28$:
	RSB

30$:
	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR STATUS
	JMP	G^EXE$ABORTIO		; ABORT THE IO

;
;	BUILD SPECIAL CHARACTERISTICS FOR DCL SPAWN
;	(NOTE: THESE CHARACTERISTICS ARE RESERVED FOR
;		FUTURE EXPANSION)
;
;INPUTS:
;	R1 - ADDRESS OF CHARACTERISTICS BUFFER
;
GET_SPECIAL:

	BICL	#<TT2$M_DCL_MAILBX!-	; RESET THEM ALL
		TT2$M_DCL_CTRLC!-
		TT2$M_DCL_OUTBND>,8(R1)	

	TSTL	UCB$L_AMB(R5)		; ANY ASSOCIATED MAILBOX?
	BEQL	5$			; NO
	BISL	#TT2$M_DCL_MAILBX,8(R1)	; YES, SO BUILD CHARACTERISTIC
5$:
	TSTL	UCB$L_TT_CTRLC(R5)	; ANY ENABLED CONTROL C?
	BEQL	10$			; NO
	BISL	#TT2$M_DCL_CTRLC,8(R1)	; YES, SO BUILD IT
10$:
	TSTL	UCB$L_TT_BANDQUE(R5)	; ANY ENABLE OUT OF BANDS?
	BEQL	15$			; NO
	BISL	#TT2$M_DCL_OUTBND,8(R1); YES, SO BUILD IT
15$:
	RSB
	
	.PAGE
	.SBTTL	MOVE TRANSLATE - TRANSLATE TO UPPERCASE
;++
;
; MOVE_TRANSLATE
;
; THIS ROUTINE MOVES AND TRANSLATES LOWERCASE OUTPUT DATA FOR 
; UPPERCASE TERMINALS. IT PARSES ESCAPE SEQUENCES FOR ANSI, VT100
; AND VT52 TERMINALS, AND REFRAINS FROM TRANSLATION OF ANY DATA
; IN ESCAPE OR CONTROL SEQUENCES.
;
; INPUTS:
;	R2 = DESTINATION ADDRESS
;	R5 = UCB ADDRESS
;	R6 = SOURCE ADDRESS
;	R7 = LENGTH
;
; OUTPUTS:
;	R2 = END OF DESTINATION STRING +1
;	R5 = UCB ADDRESS
;
;	R0 - R4 DESTROYED

MOVE_TRANSLATE:

	TSTL	R7			; NULL STRING
	BEQL	30$			; YES
10$:
	MOVZBL	(R6)+,R3		; GET NEXT CHAR TO MOVE
	CMPB	#TTY$C_ESCAPE,R3	; ESCAPE ?
	BEQL	40$			; YES, GO CHECK FOR SEQUENCE
	BBC	#TTY$V_CH_LOWER,-	; SKIP IF NOT LOWER CASE
		W^TTY$A_TYPE[R3],20$
	BICW	#^X20,R3		; CONVERT TO UPPER CASE
20$:
	MOVB	R3,(R2)+
	SOBGTR	R7,10$			; CONTINUE UNTIL DONE
30$:
	RSB

40$:
	MOVB	R3,(R2)+		; COPY ESCAPE
	DECL	R7			; ADJUST COUNT
	BEQL	30$			; QUIT IF DONE
	BBS	#TT2$V_ANSICRT,-	; CHECK FOR DEVICES WITH ANSI SEQUENCES
		UCB$L_DEVDEPND2(R5),45$
	BBS	#TT$V_ESCAPE,-
		UCB$L_DEVDEPEND(R5),45$
	CMPB	#TT$_VT5X,UCB$B_DEVTYPE(R5)
	BGTRU	10$
;
45$:
	CLRL	R4			; INIT SYNTAX RULE
50$:	MOVZBL	(R6)+,R3		; GET NEXT SEQUENCE CHARACTER
	BSBW	E_SYNTAX		; CHECK ESCAPE SEQUENCE SYNTAX
	BLEQ	20$			; ENDED OK, OR FAILURE
	MOVB	R3,(R2)+
	SOBGTR	R7,50$			; CONTINUE TILL END
	RSB	


	.END
