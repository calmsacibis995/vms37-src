	.TITLE	TTYSUB - Terminal driver miscellaneous subroutines
	.IDENT	'V03-020'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES COMMON TO ALL TERMINAL DRIVER FUNCTIONS.
;
; AUTHOR:
;
;	R.HEINEN  11-AUG-1976
;
; Revision history:
;
;	V03-020	RKS0020		RICK SPITZ		20-APR-1982
;		CHANGE THE WAY THAT STOP2 TIMEOUTS ARE DETERMINED,
;		SINCE DMF-32 DOES NOT USE UCB$W_TT_TANK
;
;	V03-019	JLV0206		Jake VanNoy		 5-APR-1982
;		Add setting RDUE in last deassign so that autobaud will 
;		ignore input for one second after hangup.
;
;	V03-018	JLV0205		Jake VanNoy		 1-APR-1982
;		Change logic in TTY$RESTARTIO to look for local echo
;		terminals.
;
;	V03-017	ROW0075		Ralph O. Weber		26-MAR-1982
;		Enhance the modem-protocol timer routine, TT$TIMER, to use 
;		EXE$AL_TQENOREPT to signal when no further repeats of its TQE 
;		are desired.  Also corrected two other minor problems 
;		regarding alignment of TQE and possible zeros in 
;		IDB$L_UCBLST.
;
;	V03-016	RKS0016		RICK SPITZ		23-MAR-1982
;		DISABLE REPORTING FRAMMING ERRORS SINCE IT CAUSES
;		PROBLEMS ON NOISY DIALUP LINES.
;
;	V03-015	RKS0015		RICK SPITZ		22-FEB-1982
;		RESTORE FIPL IN BROADCAST ABORT LOGIC.
;
;	V03-014	RKS0014		RICK SPITZ		16-FEB-1982
;		RETURN SPECIFIC ERRORS ON INPUT FAILURE RATHER THAN
;		ONLY PARITY.
;		ENHANCE STOP2 TIME OUT TO INDICATE CONTROLS PENDING.
;		WHEN CREATING TYPEAHEAD, DON'T INSERT DATA IF NULL.
;
;	V03-013	RKS0013		RICK SPITZ		15-FEB-1982
;		REMOVE RESUME IN CANCEL I/O LOGIC. ONLY DO IT
;		AT LAST DEASSIGN.
;
;	V03-012	RKS0012		RICK SPITZ		01-FEB-1982
;		RESTORE R2 AFTER MODEM RUNDOWN
;
;	V03-011	RKS0011		RICK SPITZ		24-JAN-1982
;		ADD FIND DRIVER ROUTINE
;
;	V03-010	RKS0010		RICK SPITZ		11-JAN-1982
;		FLUSH CONTROLY LIST ON DEASSIGN, RATHER THAN LAST DEASSIGN.
;
;	V03-009	RKS0009		RICK SPITZ		15-DEC-1981
;		CHECK FOR HANGUP PRIOR TO RESETTING PERM CHARACTERISTICS.
;		DEALLOCATE TYPEAHEAD BUFFER ON LAST DEASSIGN.
;		ADD RING WAIT STATE IN MODEM CONTROL.
;		RESTORE PERM MODEM STATE IN LAST DEASSIGN.
;		CHANGE CALLS FROM INSPOST TO WRITEPOST.
;		REMOVE TTY$INSPOST ROUTINE.
;
;	V03-008	RKS0008		RICK SPITZ		20-NOV-1981
;		ADD OUT OF BAND SUPPORT.
;		REMOVE CHECK FOR BRDP IN ATTENTION ROUTINE BEFORE
;		RESETTING STOP2.
;
;	V02-007	JLV0097		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS. Fork to TTY$L_WB_RETADDR instead
;		of EXE$BRDCSTCOM in STOP_BROADCASTS.
;
;	V03-006	JLV0087		Jake VanNoy			29-Sep-1981
;		Put timeout in autobaud logic to prevent getting stuck
;		at a sampling rate of 600 baud. 
;
;	V03-005	JLV0071		Jake VanNoy			28-Aug-1981
;		Add hangup on last deassign.
;
;	V03-004	RKS004		RICK SPITZ			20-AUG-1981
;		ADD SUPPORT FOR ALTERNATE TYPAHEAD SIZE.
;		FORK TO IPL 6 PRIOR TO INSERTING TIMER ENTRY.
;		ADD OUT OF BAND AST ROUTINES.
;
;	V03-003	RKS003		Rick Spitz			12-Aug-1981
;		ZERO MODEM TIMER VALUE ON TIMER CANCEL TO INDICATE IDLE.
;		Correct constant and UCB definition names.
;
;	V03-002	JLV0060		Jake VanNoy			10-Aug-1981
;		Add autobaud routines.
;
;	V03-001	RKS001		RICK SPITZ			27-JULY-1981
;		THIS MODULE HAS BEEN ENHANCED TO SUPPORT THE CLASS/PORT
;		STRUCTURE OF THE TERMINAL SERVICES. THIS INCLUDES SUPPORT
;		FOR QUADWORD STATE FIELDS AND A COMMON READ ERROR ROUTINE.
;		THE MODEM CONTROL HAS BEEN REWRITTEN TO CONFORM TO
;		DEC STANDARD 52. THE MODEM ROUTINES HAVE BEEN INCLUDED IN 
;		THIS MODULE AND ARE ACCESSABLE BY PORT DRIVERS VIA THE
;		CLASS DRIVER VECTOR TABLE.
;		THE DEVICE TIMEOUT LOGIC HAS BEEN ENHANCED TO SUPPORT
;		CONTROL S DURING A BROADCAST.
;
;
;--

	.SBTTL	Declarations


;
; EXTERNAL SYMBOLS
;

	$ACBDEF				; 
	$CANDEF				; DEFINE CANCEL DEFINITIONS
	$CRBDEF				; DEFINE CRB
	$IDBDEF				; DEFINE IDB OFFSETS
	$DCDEF				; DEFINE DEVICE CODES
	$DPTDEF				; DEFINE DPT OFFSETS
	$DYNDEF				; DEFINE DYNAMIC REGION TYPES
	$IODEF				; Define I/O function codes
	$IPLDEF				; Define IPLs.
	$IRPDEF				; DEFINE IRP
	$MSGDEF				; DEFINE MESSAGE TYPES
	$PCBDEF				; DEFINE PCB
	$SSDEF				; Define system message codes
	$UCBDEF				; DEFINE UCB
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE TERMINAL CHARACTERISTICS
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$VECDEF				; DEFINE CRB VECTOR
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
	$TTYMODEM			; DEFINE TERMINAL MODEM SYMBOLS
	$TQEDEF				; TIMER QUEUE DEFINITIONS

 
	.PSECT	$$$115_DRIVER,QUAD		; DEFINE NON-PAGED PSECT

	.SBTTL	TTY$LOCK - SETUP IPL AND REGISTERS

;++
; TTY$LOCK - SETUP IPL AND REGISTER CO-ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS IS A CO-ROUTINE THAT DISABLES INTERRUPTS TO THE IPL IN UCB$B_DIPL
; AND SETS UP A POINTER TO THE UNIT STATE VECTOR.
;
; SUBSEQUENT RETURN CAUSES IPL TO BE RETURNED.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R1 IS DESTROYED.
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--

TTY$LOCK::				; SETUP IPL AND REGISTERS
	MOVL	(SP),R1			; GET RETURN ADDRESS
	MFPR	#PR$_IPL,(SP)		; SET IPL TO AT LEAST DRIVER IPL
	CMPB	UCB$B_DIPL(R5),(SP)	; If already at device IPL or
	BLEQU	10$			; higher, branch forward.
	SETIPL	UCB$B_DIPL(R5)		; Else, raise to device IPL.
10$:	MOVAB	UCB$Q_TT_STATE(R5),R2	; SETUP STATE VECTOR POINTER
	JSB	(R1)			; CALL CALLER BACK
	ENBINT				; ENABLE INTERRUPTS
	RSB				;

	.SBTTL	TTY$SETUP_UCB - SETUP TERMINAL UCB

;++
; TTY$SETUP_UCB - SETUP TERMINAL UCB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED DURING SYSTEM STARTUP TO SET UP TERMINAL UCBS.
; THE UCB IS ZEROED EXCEPT FOR THE SPEED AND FILL COUNTS. THE CURSOR IS
; SET TO 1 TO FORCE A CR-LF. THE HOLDING TANK IS INVALIDATED. THE FORK BLOCK
; IS INITIALIZED.
;
; If the write queue is not yet initialized (indicated by zeroes in the
; listhead), initialize the queue.
;
; Initialize the read timed out dispatch (UCB$L_TT_RTIMOU).
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;
;	R0-R4 ARE PRESERVED.
;--

TTY$SETUP_UCB::				; SET UP THE UCB
	PUSHR	#^M<R0>			;
	MOVW	#1,UCB$W_TT_CURSOR(R5)	; SET BAD CURSOR TO FORCE CRLF
	CLRW	UCB$W_TT_HOLD(R5)	; INIT HOLDING TANK
	MOVAB	W^TTY$FORK_ADDR,UCB$L_FPC(R5); SET UP FORK ADDRESS
	MOVL	UCB$W_TT_DESPEE(R5),UCB$W_TT_SPEED(R5); SET UP TEMP CHARS
	MOVB	UCB$B_TT_DEPARI(R5),UCB$B_TT_PARITY(R5);SET UP DEFAULT PARITY
	MOVL	UCB$B_TT_DETYPE(R5),UCB$B_DEVTYPE(R5);
	BICL3	#^C<TT$M_REMOTE>,UCB$L_DEVDEPEND(R5),R0; SAVE CURRENT REMOTE STATE
	BICL3	#TT$M_REMOTE,UCB$L_TT_DECHAR(R5),UCB$L_DEVDEPEND(R5);
	BISL	R0,UCB$L_DEVDEPEND(R5)	; KEEP PREVIOUS SETTING
	BICB3	#^C<TT$M_PASSALL!TT$M_NOECHO>,UCB$L_DEVDEPEND(R5),R0; GET PASSALL AND NOECHO STATE
	MOVL	UCB$L_TT_DECHA1(R5),UCB$L_TT_DEVDP1(R5)	; SET UP DEFAULT CHAR WORD 2
	INSV	R0,#TTY$V_ST_PASALL,#2,UCB$Q_TT_STATE+4(R5); RESET CURRENT STATE
	POPR	#^M<R0>

;
; Initialize the write queue.
;

	TSTL	UCB$L_TT_WFLINK(R5)	; Is the queue initialized?
	BNEQ	10$			; Yes. Don't redo it.
	MOVAB	UCB$L_TT_WFLINK(R5),-	; Initialize queue to point to
		UCB$L_TT_WFLINK(R5)	; itself in both directions.
	MOVAB	UCB$L_TT_WFLINK(R5),-	; Now the backward link.
		UCB$L_TT_WBLINK(R5)

10$:

;
; Initialize read timed out dispatch.
;

	MOVAB	B^TTY$RTIMOU,UCB$L_TT_RTIMOU(R5) ; Set read timed out dispatch

	RSB				; Return.

	.SBTTL	TTY$RTIMOU - READ TIMED OUT ENTRY

;++
; TTY$RTIMOU - Read timed out entry (from time dependent schedular)
;
; Functional description:
;
; This routine is called from the time dependent schedular via the UCB
; offset UCB$L_TT_RTIMOU whenever a timed read times out.  It completes
; the read with time SS$_TIMEOUT error and, then, continues terminal
; processing.
;
; Inputs:
;
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	R0,R1,R2,R3,R4 are destroyed.
;	R5 is preserved.
;--

TTY$RTIMOU:				; Read timed out entry
	MOVAB	UCB$Q_TT_STATE(R5),R2	; Address state vector
	MOVW	#SS$_TIMEOUT,UCB$W_BOFF(R5) ; Set I/O completion status
	BSBW	TTY$READONE		; Go complete the read
10$:	RSB				; Return
	.PAGE
;++
; TTY$READERROR - READ ERROR OCCURED ON LINE
;
; Functional description:
;
; This routine is called from a terminal port driver to report
; a read error on a line. It completes the read with error in the
; event a read is active, or just returns if no read is active.
;
; Inputs:
;
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	R0,R1,R2,R3 are destroyed.
;	R4,R5 are preserved.
;--
	.ENABLE	LSB

TTY$READERROR::
	PUSHL	R4				; SAVE R4
	MOVZWL	#SS$_PARITY,R4			; ASSUME PARITY
	MOVAB	UCB$Q_TT_STATE(R5),R2		; ADDRESS STATE DATA
	BBS	#13,R3,TTY$FRAMERROR		; BRANCH IF FRAME ERROR
	BBS	#12,R3,10$			; BRANCH IF PARITY ERROR
	MOVZWL	#SS$_DATAOVERUN,R4		; OVERUN ERROR
10$:	IF_NOT_STATE	READ,15$		; SKIP IF NO READ ACTIVE
	MOVW	R4,UCB$W_BOFF(R5)		; SET ERROR CODE TO RETURN
	BSBW	TTY$READONE			; COMPLETE THE REQUEST
15$:	POPL	R4				; RESTORE R4
	CLRL	R3				; SET NO CHARACTER TO OUTPUT
	RSB

18$:
	MOVZWL	#SS$_PARITY,R4			; SET ERROR TYPE
	BBC	#TT$V_PARITY,-
		UCB$B_TT_PARITY(R5),15$		; IF NOT ENABLED, THEN DROP
	BRB	10$				; DROP CHARACTER, NO ERROR
	
;++
; TTY$FRAMERROR - FRAME READ ERROR OCCURED ON LINE
;
; Functional description:
;
; This routine is branched to from a TTY$READERROR to report a frame
; read error on a line. It compares time against the
; last autobaud attempt, and if a "sufficient" (avg 0.5 seconds) has
; passed, the sampling baud rate is toggled between 9600 and 600. 
; The toggling to 600 baud will time out in less than 3 seconds.
; 
; Inputs:
;
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	Baud rate may change.
;	R4,R5 are preserved.
;--
TTY$FRAMERROR:

; Check if we should attempt autobaud on this line

	TSTW	UCB$W_REFC(R5)		; Terminal in use ?
	BNEQ	18$			; Branch if yes

	BBC	#TT2$V_AUTOBAUD,UCB$L_TT_DEVDP1(R5),18$ ; Check AUTOBAUD

; check time to see that it's been "awhile".
; note that you want to throw away multiple-character, single-keystroke
; characters after the first. This check gives between 0 and one second.
; It doesn't seem necessary to make it be at least one second.

	CMPL	UCB$L_TT_RDUE(R5),-
		G^EXE$GL_ABSTIM		; check against current
	BEQL	18$			; exit if equal

; make sure there is no valid data in R3, if so, leave it for TTY$AUTOBAUD and
; don't toggle baud rate

	TSTB	R3			; test
	BNEQ	30$			; Branch if data there

; time is OK - continue by checking baud rate

	MOVZBL	#TT$C_BAUD_9600,R4	; Assume set to 9600 baud
	CMPB	#TT$C_BAUD_9600,-
		UCB$W_TT_SPEED(R5) 	; At 9600 ?
	BNEQ	20$			; no, set 9600
;
; Toggle to 600 baud for 2 to 3 seconds
;
	MOVZBL	#TT$C_BAUD_600,R4	; otherwise, set 600 baud
	SET_STATE -
		<AUTOP>			; Set state autobaud pending
	ADDL3	#3,G^EXE$GL_ABSTIM,-
		UCB$L_DUETIM(R5)	; Set timeout for ~ 2.5 seconds
	BISW	#UCB$M_TIM,UCB$W_STS(R5); Set timeout expected

20$:	BSBW	SET_SPEED		; Set line speed
	MOVL	G^EXE$GL_ABSTIM,-
		UCB$L_TT_RDUE(R5)   	; set time
30$:	POPL	R4			; Restore R4
	TSTB	R3			; Set condition code 
	RSB				; Return
	.DISABLE LSB


	.SBTTL	TTY$AUTOBAUD -  SENSE AND SET BAUD RATE 

;++
; TTY$AUTOBAUD - Sense and Set baud rate 
;
; Functional description:
;
; This routine is called from the TTYCHARI module when a job controller  
; character has been detected. It assumes the character typed was a carriage
; return. The default sampling speed is 9600. If the terminal is set at baud
; rates 1200 - 9600, the algorithm will detect the proper baud rate on one
; character and set to it. If the baud rate is other than that, READERROR will
; detect a framing error and set the sampling rate to 600. A second carriage
; return then sampled at 600 baud can map the 50-600 baud range. Using the 9600
; or 600 baud table the algorithm matches the character read to a specific baud
; rate. No split speed detection is allowed. 
;
; Inputs:
;
;	IPL = Device IPL
;	R5 = UCB address
;
; Outputs:
;
;	Baud rate can change.
;	R3 will be changed to <CR>, or a space
;	R4 is destroyed.
;	R5 is preserved.
;--

TTY$AUTOBAUD::

	CMPL	UCB$L_TT_RDUE(R5),-
		G^EXE$GL_ABSTIM		; compare to current
	BEQL	50$			; branch if too soon

	BBCC	#7,R3,10$		; Clear high order bit

; check baud rate

10$:	MOVAB	TTY$AB_9600,R4		; set 9600 baud table
	CMPB	#TT$C_BAUD_9600,UCB$W_TT_SPEED(R5) ; speed at 9600 ?
	BEQL	20$			; branch if yes

	MOVAB	TTY$AB_600,R4		; set 600 baud table
	CMPB	#TT$C_BAUD_600,UCB$W_TT_SPEED(R5) ; speed at 600 ?
	BEQL	20$			; branch if no

	MOVZBL	#TT$C_BAUD_9600,R4	; Wrong baud baud rate for sampling
	BSBW	SET_SPEED		; Set to 9600
	BRB	50$			; Exit

; now test character

20$:	CMPB	R3,(R4)+		; input same as table ?
	BEQL	30$			; branch to set speed if yes
	INCL	R4			; increment past baud rate
	TSTB	(R4)			; end of list
	BGEQ	20$			; loop if >= 0
	BRB	50$			; no match

; Set speed, zero speed+1 to indicate not split speed

30$:	MOVZBW	(R4),R4			; set baud rate
	BSBB	SET_SPEED		; Set line speed

	BICW	#UCB$M_TIM,UCB$W_STS(R5) ; Clear timeout expected
	CLR_STATE <AUTOP>		; Clear AUTOBAUD pending
	MOVZBL	#TTY$C_CR,R3		; Set carriage return as input
	MOVL	G^EXE$GL_ABSTIM,-
		UCB$L_TT_RDUE(R5)	; Set time this path taken
40$:	RSB
;
; No appropriate mapping was found, make sure that character isn't a terminator
;
50$:	MOVZBL	#TTY$C_BLANK,R3		; Invalidate character
	RSB

SET_SPEED:
	MOVZBW	R4,UCB$W_TT_SPEED(R5) 	; set speed, zero out speed+1
	MOVL	UCB$L_TT_PORT(R5),R4	; access port vector
	JSB	@PORT_SET_LINE(R4)	; Set line speed
	RSB				; Return

	.SBTTL	TTY$CANCELIO - CANCEL I/O ON TERMINAL

;++
; TTY$CANCELIO - CANCEL I/O, DEASSIGN, AND DEALLOCATE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO STOP CURRENT I/O  ON A TERMINAL UNIT.
;
; THE ASSOCIATED CHANNEL'S READ OR WRITE I/O IS CANCELED ALONG WITH
; A FLUSH OF CONTROL-C AST REQUESTS. 
; IF THIS OPERATION IS DONE ON A UNIT WITH A ZERO REFERENCE COUNT, THE CONTROL
; Y ASTS ARE FLUSHED, THE TYPEAHEAD BUFFER IS DEALLOCATED AND THE UNIT
; IS INITIALIZED FOR THE NEXT USER.
;
; This routine always clears the control-O state bit, and also clears
; the control-S state bit if the UCB reference count is zero.
;
; INPUTS:
;
;	R2 = NEGATIVE OF THE CHANNEL NUMBER
;	R3 = CURRENT I/O PACKET ADDRESS
;	R4 = PCB OF CANCELING PROCESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R4,R5 ARE PRESERVED
;--

TTY$CANCELIO::				; CANCELIO TTY USAGE
	PUSHR	#^M<R4,R5,R6,R7>	; Save registers.
	PUSHAB	W^130$			; SET UP RETURN ADDRESS
	MOVL	R2,R6			; COPY CHANNEL NUMBER
	BSBW	TTY$LOCK		; SETUP IPL AND REGISTERS

;
; Empty the write queue.
;

	MOVAB	UCB$L_TT_WFLINK(R5),R1	; Get first buffer in queue.
	MOVL	R1,R7			; Copy buffer address.

10$:					; Empty write queue.
	MOVL	TTY$L_WB_FLINK(R7),R7	; Get next buffer.
	CMPL	R7,R1			; Is this the end of queue?
	BEQL	40$			; Yes. Branch past loop.
	MOVL	TTY$L_WB_IRP(R7),R0	; Get address of associated IRP.
	BEQL	10$			; Branch if broadcast buffer
					; (leave these in queue).
	BBS	#IRP$V_VIRTUAL,-	; Don't dequeue virtual I/O
		IRP$W_STS(R0),10$	; packet.
	CMPL	IRP$L_PID(R0),-		; Compare packet's PID with
		PCB$L_PID(R4)		; current process' PID.
	BNEQ	10$			; No match. Go to next packet.
	CMPW	R6,IRP$W_CHAN(R0)	; Does the channel match?
	BNEQ	10$			; No. Go to next packet.
	BBC	#IRP$V_BUFIO,-		; Branch on direct I/O.
		IRP$W_STS(R0),20$
	BICW	#IRP$M_FUNC,-		; Otherwise, clear function of
		IRP$W_STS(R0)		; buffered I/O.

20$:					; Set up I/O completion.
	MOVZWL	#SS$_CANCEL,-		; Return CANCEL error status
		UCB$W_BOFF(R5)		; code.
	PUSHL	R4			; Save R4
	MOVL	TTY$L_WB_BLINK(R7),R7	; Get backward link.
	REMQUE	@TTY$L_WB_FLINK(R7),R4	; Remove buffer from queue.
	BSBW	TTY$WRITEPOST		; QUEUE IT FOR COMPLETION
	POPL	R4			; Restore R4
	BRB	10$			; Get next buffer in queue.

;
; See if a read is in progress. Cancel it if it was initiated by the
; canceling process.
;

40$:
	
					; Check for read in progress.
	BBC	#UCB$V_BSY,-		; Branch if no read in progress.
		UCB$W_STS(R5),50$
	CMPL	PCB$L_PID(R4),IRP$L_PID(R3); PID MATCH?
	BNEQ	50$			; Branch if no match.
	CMPW	R6,IRP$W_CHAN(R3)	; CHANNEL MATCH?
	BNEQ	50$			; Branch if no match.
	IF_NOT_STATE -			; Proceed if this is not a read.
		READ,50$
	CLR_STATE -			; Clear escape bits.
		<ESC,BADESC>
	PUSHR	#^M<R4>			; Save the PCB address.
	MOVL	UCB$L_IRP(R5),R4	; Get address of IRP.
	CLRL	IRP$L_MEDIA(R4)		; Clear terminators.
	MOVZWL	#SS$_ABORT,-		; Set up abort status code.
		UCB$W_BOFF(R5)
	BSBW	TTY$READONE		; Complete the read.

45$:					; Remember to restore register.
	POPR	#^M<R4>			; Restore PCB address.

50$:					; Check for a write in progress.
	IF_NOT_STATE -			; If no write request is in
		WRITE,80$		; progress, branch.
	IF_STATE -			; If broadcast, branch without
		BRDCST,80$		; stopping the write.
	MOVL	UCB$L_TT_WRTBUF(R5),R7	; Get address of write buffer.
	MOVL	TTY$L_WB_IRP(R7),R0	; Get associated IRP.
	CMPL	IRP$L_PID(R0),-		; See if packet's PID matches
		PCB$L_PID(R4)		; process' PID.
	BNEQ	80$			; Branch if no match.
	CMPW	R6,IRP$W_CHAN(R0)	; See if channels match.
	BNEQ	80$			; No. Don't stop this write.
	MOVL	UCB$L_TT_PORT(R5),R7	; Access port vector
	JSB	@PORT_ABORT(R7)		; Abort any current output activity
	MOVZWL	#SS$_ABORT,-		; Set abort status in the
		UCB$W_BOFF(R5)		; UCB status word.
	PUSHR	#^M<R4>			; Save the PCB address.
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write packet.
	MOVW	UCB$W_BOFF(R5),-	; Put status code in the
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete the I/O.
	POPR	#^M<R4>			; Restore PCB address.

;
; RELEASE THE CONTROL C AST BLOCKS
;
80$:	MOVAB	UCB$L_TT_CTRLC(R5),R7	; ADDRESS THE CONTROL C ENABLE LIST 
	CLRL	R2			; SPECIFY NULL MASK
	JSB	G^COM$FLUSHATTNS	; FLUSH THE LIST
;
; FLUSH OUT OF BAND ASTS
;
	MOVAB	UCB$L_TT_BANDQUE(R5),R7	; ADDRESS THE OUT OF BAND LIST
	MOVAL	UCB$L_TT_OUTBAND(R5),R2	; GET CURRENT SUMMARY MASK
	JSB	G^COM$FLUSHCTRLS	; DO IT
	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS
;
; FLUSH CONTROL Y AST QUEUE
;
	CMPW	R8,#CAN$C_DASSGN	; IS THIS A DEASSIGN?
	BNEQ	81$			; NO, SKIP
	MOVAB	UCB$L_TT_CTRLY(R5),R7	; ADDRESS LIST HEAD FOR CONTROL Y ENABLE
	CLRL	R2			; SPECIFY NULL MASK
	JSB	G^COM$FLUSHATTNS	; FLUSH LIST
	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS
;
; SEE IF THIS IS THE LAST DEASSIGN
;
81$:	TSTW	UCB$W_REFC(R5)		; REF COUNT 0?
	BEQL	82$			; YES IT IS
	BRW	125$			; KEEP JOB CONTROLLER AND TYPEAHEAD IF NON-ZERO
82$:
	BICW	#UCB$M_TT_HANGUP,UCB$W_DEVSTS(R5)
;
;	DELETE TYPEAHEAD BUFFER
;
	MOVL	UCB$L_TT_TYPAHD(R5),R0	; GET ADDRESS OF TYPE AHEAD
	BEQL	83$			; NONE
	CLRL	UCB$L_TT_TYPAHD(R5)
	JSB	G^COM$DRVDEALMEM	; DEALLOCATE TYPE AHEAD BUFFER
83$:	BSBW	TTY$PURGE_AHEAD		; PURGE TYPE AHEAD BUFFER
	

	BICL3	#^C<TT$M_HOLDSCREEN>,UCB$L_DEVDEPEND(R5),-(SP); GET CURRENT HOLDSCREEN MODE
;
; CHECK FOR HANGUP  
;
	BBC	#TT2$V_HANGUP,-
		UCB$L_TT_DEVDP1(R5),85$	; BRANCH IF LOGOUT/NOHANGUP
	MOVL	UCB$L_TT_PORT(R5),R4	; ADDRESS PORT VECTOR TABLE
	JSB	@PORT_DISCONNECT(R4)	; RESET SPEED AND UCB

85$:

;
; CHECK FOR NEED TO REACTIVATE MODEM PROCESSING
;

	BBS	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),87$	; CURRENT STATE IS MODEM
	BBC	#TT$V_MODEM,UCB$L_TT_DECHAR(R5),88$	; NO CHANGE
	MOVZBL	#MODEM$C_INIT,R1			; NEED TO RESTART MODEM
	JSB	TRANSITION
	BRB	88$

87$:
	BBS	#TT$V_MODEM,UCB$L_TT_DECHAR(R5),88$	; NO CHANGE
	MOVZBL	#MODEM$C_SHUTDWN,R1			; SHUT DOWN MODEM
	JSB	TRANSITION
88$:
	MOVAL	UCB$Q_TT_STATE(R5),R2	; RESTORE STATE ADDRESS

;
; RESTORE PERM CHARACTERISTICS
;

	JSB	TTY$SETUP_UCB		; SETUP UCB FIELDS
	MOVL	G^EXE$GL_ABSTIM,-
		UCB$L_TT_RDUE(R5)   	; SET TIME TO "TURN OFF" AUTOBAUD
	MOVL	UCB$L_TT_PORT(R5),R4	; ADDRESS PORT VECTOR TABLE
	JSB	@PORT_SET_LINE(R4)	; RESET SPEED AND UCB

	POPL	R0			; GET PREVIOUS HOLD SCREEN STATE
	BEQL	90$			; IF EQL THEN WAS OFF
					; WAS ON
	MOVAB	W^TTY$A_RLSCREEN,UCB$L_TT_MULTI(R5); ASSUME NOW OFF
	BBS	#TT$V_HOLDSCREEN,UCB$L_DEVDEPEND(R5),110$; BR IF STILL ON
	BRB	100$			; BR TO SET ON
90$:	MOVAB	W^TTY$A_HLDSCREEN,UCB$L_TT_MULTI(R5); ASSUME NO ON
	BBC	#TT$V_HOLDSCREEN,UCB$L_DEVDEPEND(R5),110$; BR IF NOT NOW ON
100$:	SET_STATE MULTI			; SET MULTI ECHO STATE
110$:	BBCC	#UCB$V_JOB,UCB$W_DEVSTS(R5),120$; RESET JOB CONTROLLER OWNERSHIP BIT
120$:	
	MOVL	UCB$L_TT_PORT(R5),R1	; ACCESS PORT VECTOR
	JSB	@PORT_RESUME(R1)	; CONTINUE ANY PORT OUTPUT
	
125$:	CLR_STATE	<CTRLO>		; Clear control-O state always.
	BRW	TTY$STARTOUTPUT		; RESTART ANY STOPPED OUTPUT
130$:	POPR	#^M<R4,R5,R6,R7>	; Restore registers.
	RSB				; RETURN

	.SBTTL	TTY$CRE_FORK - General purpose driver fork routine

;++
; TTY$CRE_FORK - CREATE FORK ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE FORKS IN THE UCB FOR EITHER OF TWO REASONS:
;
;	1. UNSOLICITED DATA - SEND MESSAGE TO OWNER
;	2. NO TYPEAHEAD BUFFER - ALLOCATE ONE
;
; INPUTS:
;
;	R2 = UNIT STATE VECTOR ADDRESS
;	R3 = CHARACTER TO BUFFER FOR TYPEAHEAD NEEDED
;	R4 = FORK REASON STATE BIT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R5 ARE PRESERVED.

;--

TTY$CRE_FORK::				; CREATE FORK
	IF_STATE <GETAHD,UNSOL>,10$	; IF FORK IN PROGRESS THEN NO FORK HERE
	BBSS	R4,4(R2),5$		; SET THE REASON
5$:	PUSHAB	B^TTY$FORK_ADDR		; SET FORK ROUTINE ADDRESS
	JMP	G^EXE$FORK		; CREATE FORK PROCESS
10$:	BBSS	R4,4(R2),15$		; SET THEN REASON ANY WAY
15$:	RSB

	.WORD	ATTENTION-.		; SET UP ATTENTION INTERRUPT
TTY$FORK_ADDR::
;
; ATTENTION FORK PROCESS
;
10$:	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS UNIT STATE
;
; HANDLE UNSOLICITED DATA
;
	IF_NOT_STATE <UNSOL>,70$	; BR IF NOT UNSOLICITED DATA
;
; SEND UNSOLICITED DATA MESSAGE
;
	MOVZBL	#MSG$_TRMUNSOLIC,R4	; SET MESSAGE TYPE
	TSTW	UCB$W_REFC(R5)		; IF REF COUNT 0 THEN 
	BEQL	50$			; JOB CONTROLLER
	MOVL	UCB$L_AMB(R5),R3	; GET USER'S MAILBOX
	BEQL	65$			; IF EQL THEN NONE
	BBS	#UCB$V_TT_NOTIF,UCB$W_DEVSTS(R5),65$; BR IF ALREADY NOTIFIED
	BRB	55$			; CONTINUE
50$:	MOVAB	G^SYS$GL_JOBCTLMB,R3	; ADDRESS JOB CONTROLLER MAILBOX
	BBS	#UCB$V_JOB,UCB$W_DEVSTS(R5),65$; BR IF NOTIFIED ALREADY
55$:	JSB	G^EXE$SNDEVMSG		; SEND THE MESSAGE
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE VECTOR
	BLBC	R0,65$			; IF FAILED THEN LEAVE DATA BASE UNCHANGED
	TSTW	UCB$W_REFC(R5)		; REF COUNT 0?
	BNEQ	60$			; IF NEQ THEN USER
	BISW	#UCB$M_JOB,UCB$W_DEVSTS(R5); SET NOTIFIED
	BRB	65$			; LOOK TO UNSOLICITED DATA
60$:	BISW	#UCB$M_TT_NOTIF,UCB$W_DEVSTS(R5); SET NOTIFIED
65$:	CLR_STATE <UNSOL>
;
; CHECK FOR TYPEAHEAD BUFFER FETCH
;
70$:	IF_NOT_STATE <GETAHD>,80$
	TSTL	UCB$L_TT_TYPAHD(R5)	; ALREADY ALLOCATED?
	BNEQ	75$			; IF NEQ THEN YES
	BBC	#TT2$V_ALTYPEAHD,-	; SKIP IF NORMAL SIZE
		UCB$L_TT_DEVDP1(R5),72$
	MOVZWL	G^TTY$GW_ALTYPAHD,R1	; ALLOCATE THE TYPEAHEAD BUFFER
	BRB	73$
72$:	MOVZWL	G^TTY$GW_TYPAHDSZ,R1	; ALLOCATE THE TYPEAHEAD BUFFER
73$:	ADDL	#TTY$L_TA_DATA,R1	; PLUS SPACE FOR HEADER
	JSB	G^EXE$ALONONPAGED		; 
	MOVL	R2,R4			; COPY BLOCK ADDRESS
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE VECTOR
	BLBC	R0,75$			; IF FAILURE THEN TOUGH
	MOVW	R1,TTY$W_TA_SIZE(R4)	; SET UP SIZE
	MOVAB	(R4)[R1],TTY$L_TA_END(R4); SET UP END POINTER
	MOVB	#DYN$C_TYPAHD,TTY$B_TA_TYPE(R4);
	DSBINT	UCB$B_DIPL(R5)		; LOCK TERMINAL DATA BASE
	MOVL	R4,UCB$L_TT_TYPAHD(R5)	; STORE ADDRESS
	BSBB	TTY$PURGE_AHEAD		; SET UP THE BLOCK
	MOVB	UCB$L_FR3(R5),TTY$L_TA_DATA(R4); INSERT DATA
	BEQL	74$			; SKIP INSERT IF NULL
	INCL	@UCB$L_TT_TYPAHD(R5)	; POINT TO NEXT PLACE
	INCW	UCB$W_TT_INAHD(R5)	;
74$:	BBSC	#TTY$V_ST_GETAHD,4(R2),90$; CLEAR STATE AND BR
75$:	CLR_STATE <GETAHD>
80$:	DSBINT	UCB$B_DIPL(R5)		; LOCK OUT TERMINAL INTERRUPTS
90$:	IF_NOT_STATE <UNSOL,GETAHD>,100$; EXIT IF DONE
	ENBINT				; LOWER IPL
	BRW	10$			; AND TRY AGAIN
100$:	BSBW	TTY$STARTOUTPUT		; BEGIN NEXT STATE
	ENBINT
	RSB

	.SBTTL TTY$PURGE_AHEAD - PURGE TYPEAHEAD BUFFER 

;++
; TTY$PURGE_AHEAD - PURGE THE CONTENTS OF THE TYPEAHEAD BUFFER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RESETS THE TYPEAHEAD BUFFER POINTERS TO REFLECT NO 
; DATA PRESENT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R3,R5 ARE PRESERVED.
;--

TTY$PURGE_AHEAD::			; PURGE TYPEAHEAD
	CLRW	UCB$W_TT_INAHD(R5)	; SET NO DATA IN TYPEAHEAD BUFFER
	MOVL	UCB$L_TT_TYPAHD(R5),R4	; GET TYPE AHEAD BUFFER ADDRESS
	BEQL	55$			; IF EQL THEN NONE
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_PUT(R4); RESET PUT POINTER
	MOVL	(R4)+,(R4)		; RESET GET POINTER
50$:	BBCC	#TTY$V_ST_TYPFUL,4(R2),55$; TYPE AHEAD FULL AND INPUT STOPPED?
	CLR_STATE <OVRFLO>		; RESET OVERFLOW CONDITION
	MOVL	UCB$L_TT_PORT(R5),R1	; ACCESS PORT VECTOR
	JSB	@PORT_XON(R1)		; SEND XON
55$:	RSB

	.SBTTL	TTY$SETUP_READ - Set up UCB and states for a read

;++
; TTY$SETUP_READ - get ready to initiate a read operation
;
; Functional description:
;
;	This routine copies IRP fields into the UCB, disables mailbox,
;	sets up a timed-out read, cancels control-O, purges the type
;	ahead buffer, etc. as instructed by the IRP.
;
;	This routine is called by both TTY$STARTIO to start a read, and
;	TTY$RESTARTIO to restart a read after a powerfailure or after
;	a write completes.
;
; Inputs:
;
;	R2	- address of the UCB state bits
;	R3	- address of the IRP
;	R5	- address of the UCB
;
; Outputs:
;
;	R0, R2, R3, and R5 must be preserved.
;
;	R4 is destroyed.
;
;--

TTY$SETUP_READ::
	MOVL	IRP$L_SVAPTE(R3),R4	; Get buffered block address.
	MOVW	UCB$W_TT_CURSOR(R5),-	; Save the current cursor
		TTY$W_RB_ORGHOR(R4)	; position.

;
; Check to see if mailbox should be disabled.
;

	BBC	#IO$V_DSABLMBX,-	; Branch forward if disable
		IRP$W_FUNC(R3),10$	; mailbox not requested.
	BBSS	#TT$V_MBXDSABL,-	; Otherwise, disable it.
		UCB$L_DEVDEPEND(R5),10$

;
; Set up read with time out if necessary.
;

10$:
	BBC	#IO$V_TIMED,-		; Branch forward if read with
		IRP$W_FUNC(R3),30$	; timeout not requested.
	MOVL	TTY$A_MAXTIME,-		; Assume zero second timeout
		UCB$L_TT_RDUE(R5)	; (meaning just empty typeahead
					; buffer into read buffer).
	MOVZWL	TTY$W_RB_TIMOS(R4),R4	; Get number of seconds to wait
					; between each character.
	BEQL	20$			; Branch if none.
	ADDL3	R4,G^EXE$GL_ABSTIM,-	; Calculate and store the due
		UCB$L_TT_RDUE(R5)	; time.

20$:
	BISW	#UCB$M_TT_TIMO,-	; Set the "this is a read with
		UCB$W_DEVSTS(R5)	; timeout" bit.

;
; Always turn off control-O state.
;

30$:
	CLR_STATE -			; Always clear control-O state.
		<CTRLO>

;
; Handle a readsync terminal.
;

	BBC	#TT$V_READSYNC,-	; Branch forward if terminal is
		UCB$L_DEVDEPEND(R5),40$	; not in readsync mode.
	IF_STATE -			; If in EOL state, don't issue
		EOL,40$			; an XON code.
	MOVL	UCB$L_TT_PORT(R5),R1	; Access port vector
	JSB	@PORT_XON(R1)		; Send XON

40$:
	RSB				; Return to caller.

	.SBTTL	TTY$RESTARTIO - RESTART CURRENT I/O

;
;++
; TTY$RESTARTIO - RESTART CURRENT I/O
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine restarts an interrupted read or write request. Such
;	requests may have been interrupted due to a powerfail or
;	to coincident read and write requests.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UNIT UCB ADDRESS
;
; OUTPUTS:
;
;	R2,R5 ARE PRESERVED.
;--

TTY$RESTARTIO::				; RESTART THE I/O
	IF_NOT_STATE WRITE,10$		; IF NOT WRITE THEN CONTINUE
	IF_STATE WRTALL,30$		; If passall mode, no special
					; restart is required.
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Get address of write buffer.
	IF_STATE -			; If broadcasting a message,
		BRDCST,30$		; branch forward.
	MOVL	UCB$L_TT_PORT(R5),R3	; Access port vector
	JSB	@PORT_ABORT(R3)		; Abort any output activity
	CLRW	TTY$W_WB_BCNT(R4)	; No. Clear output byte count.
	MOVAB	TTY$L_WB_DATA(R4),-	; And reset the start of data
		TTY$L_WB_NEXT(R4)	; pointer.
	RSB				; Return.

10$:
	IF_NOT_STATE READ,30$		; BR IF READ NOT IN PROGRESS
	MOVL	UCB$L_IRP(R5),R3	; Get address of IRP.
	BSBW	TTY$SETUP_READ		; Setup for the read operation.
	IF_STATE -			; Continue without special
		 PASALL,20$		; handling if PASSALL
	IF_NOT_STATE -			; or NOECHO ...
		NOECHO,15$		;
	BBC	#TT2$V_LOCALECHO, -	; without local echo.
		UCB$L_TT_DEVDP1(R5),20$	; 
15$:	IF_NOT_STATE -			; Also no special handling if
		REFRSH,30$		; REFRESH state is not set.
	MOVAB	W^TTY$A_CTRLU+2,-	; Set up multi-echo string
		UCB$L_TT_MULTI(R5)	; to control-R the read.
	SET_STATE -			; Set the control-R and
		<CTRLR,MULTI>		; multiecho states to force it.
	ADDL3	#TTY$L_RB_DATA,-	; Readdress the start of the
		UCB$L_SVAPTE(R5),-	; prompt string.
		@UCB$L_SVAPTE(R5)

20$:
	BBS	#IO$V_REFRESH,-		; If the read specified a
		IRP$W_FUNC(R3),30$	; refresh, don't cancel it.
	CLR_STATE -			; Otherwise, cancel refresh
		REFRSH			; state.

30$:
	RSB				; CONTINUE

	.SBTTL	ATTENTION - UNIT TIMEOUT, POWERFAIL ATTENTION ROUTINE

;++
; ATTENTION - UNIT TIMEOUT, POWERFAIL ATTENTION ROUTINE
;
; THIS ROUTINE IS ENTERED VIA THE UCB$L_FPC ON POWERFAIL OR TIMEOUT.
; THE ACTION IS TO RESTART THE I/O IF THE POWER FAILED AND TO CANCEL IT
; IF A TIMEOUT OCCURRED.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--

ATTENTION:				; ATTENTION INTERRUPT
	BSBW	TTY$LOCK		; SET IPL AND REGISTERS
	BBCC	#UCB$V_POWER,UCB$W_STS(R5),20$; CANCEL IF NOT POWERFAIL

;
; POWER FAILED WHILE THIS UNIT WAS WAITING FOR AN INTERRUPT.
;

	BSBW	TTY$RESTARTIO		; Restart in progress I/O.
	MOVL	UCB$L_TT_PORT(R5),R3	; Access port vector
	JSB	@PORT_RESUME(R3)		; CONTINUE ANY STOPPED LINES
	BRW	TTY$STARTOUTPUT		; BEGIN THE I/O AGAIN
;
; CHECK FOR BROADCAST TIMEOUT
;
20$:
	IF_NOT_STATE BRDP,40$		; SKIP IF BROADCAST NOT ACTIVE
	SET_STATE	<CTRLSP>	; SHOW CONTROLS PENDING
	MOVL	UCB$L_TT_PORT(R5),R3	; ACCESS PORT VECTOR
	JSB	@PORT_RESUME(R3)	; RESUME OUTPUT ON LINE,
					; SINCE TIMER EXPIRED
	RSB
;
; CHECK FOR AUTOBAUD AT 600 BAUD TIMEOUT
;
40$:	IF_NOT_STATE	AUTOP,50$	; SKIP IF NOT
	MOVZBW	#TT$C_BAUD_9600,-
		UCB$W_TT_SPEED(R5)	; SET 9600 BAUD
	MOVL	UCB$L_TT_PORT(R5),R3	; ACCESS PORT VECTOR
	JSB	@PORT_SET_LINE(R3)	; RESET SPEED ON LINE,
					;  SINCE TIMER EXPIRED
	RSB

;
; ACTUAL HARDWARE TIMEOUT
;

50$:					; Handle timeout.
	INCW	UCB$W_ERRCNT(R5)	; BUMP ERROR COUNTER
	MOVZWL	#SS$_TIMEOUT,-		; Load status code into the
		UCB$W_BOFF(R5)		; UCB status word.
	BSBW	STOP_BROADCASTS		; Stop all broadcasts on unit.

60$:
	IF_NOT_STATE -			; Branch forward if not in a
		 WRITE,70$		; write state.
	MOVL	UCB$L_TT_PORT(R5),R3	; Access port vector
	JSB	@PORT_ABORT(R3)		; Abort any output activity
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write buffer.
	MOVW	UCB$W_BOFF(R5),-	; Save status in the write
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete this write.

70$:					; Check for a read.
	IF_NOT_STATE -			; Branch forward if not reading.
		READ,80$
	CLR_STATE -			; Clear escape states.
		<ESC,BADESC>
	MOVL	UCB$L_IRP(R5),R4	; GET CURRENT PACKET
	CLRL	IRP$L_MEDIA(R4)		; SET NO TERMINATORS
	BSBW	TTY$READONE		; COMPLETE READ
80$:
	RSB

	.SBTTL	STOP_BROADCASTS - fork a broadcast packet back to VMS

;++
;
; Functional description:
;
;	Send a broadcast packet's completion signal back to the
;	broadcast system service. Then empty all broadcast packets
;	out of the write queue.
;
; Inputs:
;
;	R2	- address of state bits longword
;	R5	- address of the device's UCB
;
; Outputs:
;
;	Registers R1-R6 are preserved.
;
;--

STOP_BROADCASTS:
	PUSHR	#^M<R1,R2,R3,R4,R5,R6>	; Save registers.
	MOVL	R5,R6			; Save the UCB address.
	CLR_STATE BRDP			; Reset any broadcast pending
	IF_NOT_STATE -			; Branch forward if no broadcast
		BRDCST,10$		; is underway.
	CLR_STATE -			; Signal completion of the
		<WRITE,WRTALL,BRDCST>	; broadcast.
	MOVL	UCB$L_TT_PORT(R5),R1	; Access port vector
	JSB	@PORT_ABORT(R1)		; Stop any output active
	MOVL	UCB$L_TT_WRTBUF(R6),R5	; Get address of write packet.
	BSBB	Q_FORK_PACKET		; Queue broadcast packet to
					; fork queue.

10$:
	MOVAB	UCB$L_TT_WFLINK(R6),R1	; Get start of write queue.
	MOVL	R1,R2			; Copy it to check for end.

20$:
	MOVL	TTY$L_WB_FLINK(R2),R2	; Get next entry.
25$:
	CMPL	R2,R1			; At end of queue?
	BEQL	30$			; Yes. Branch forward.
	TSTL	TTY$L_WB_IRP(R2)	; Is this a broadcast packet?
	BNEQ	20$			; No. Leave it and go the next.
	REMQUE	TTY$L_WB_FLINK(R2),R5	; Remove the link.
	MOVL	TTY$L_WB_FLINK(R2),R2	; Save next entry.
	BSBB	Q_FORK_PACKET		; Queue the packet to the fork
					; queue.
	BRB	25$			; Try for next link.

30$:					; Stop the current I/Os.
	POPR	#^M<R1,R2,R3,R4,R5,R6>	; Restore registers.
	RSB				; Return.

;
; Little subroutine to queue a fork process with a broadcast packet.
;

Q_FORK_PACKET:
	PUSHR	#^M<R1,R2>		; Save 2 registers.
	PUSHAB	10$			; Name a return address.
	PUSHL	TTY$L_WB_RETADDR(R5)	; Name the fork address.
	MOVB	#IPL$_QUEUEAST,-	; Restore FIPL in TWP
		TTY$B_WB_FIPL(R5)

	MOVL	TTY$L_WB_END(R5),R3	; Specify end of data address.
	JMP	G^EXE$FORK		; Queue a fork process.

10$:
	POPR	#^M<R1,R2>		; Restore the saved registers.
	RSB				; Return to caller.

	.PAGE
	.SBTTL	MODEM ROUTINES

;	MODEM CONTROL DATA AREA



TT$L_DIALUP::					;ROOT OF MODEM TIMER CRB LIST
	.LONG	0
TT$W_REFCNT:
	.WORD	0				;COUNT OF TIMERS IN USE
TT$W_TIMCTRL:
	.WORD	0				;FLAG WORD 


	.ALIGN	QUAD
TT$TIMQUENT:					;TIMER QUE ENTRY FOR MODEM TIMER
	.BLKB	TQE$C_LENGTH			;ALLOCATE BLOCK HERE
	STO_TQE	TQE$W_SIZE,WORD,TQE$C_LENGTH,TT$TIMQUENT
	STO_TQE	TQE$B_TYPE,BYTE,DYN$C_TQE,TT$TIMQUENT
	STO_TQE	TQE$B_RQTYPE,BYTE,TQE$C_SSREPT,TT$TIMQUENT


	.page
;++
; TRANSITION	-	PROCESS TRANSITION ELEMENTS ON MODEM/TIMER STATUS EVENT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED ON ALL MODEM TRANSITIONS SUCH AS MODEM SIGNAL CHANGES,
; TIMER EXPIRATIONS AND CONTROL. THE TRANSITION ELEMENTS CONTAINED IN THE
; STATE TABLE ASSOCIATED WITH THE CURRENT STATE ARE SCANNED. IF A MATCH IS 
; FOUND, THEN A NEW STATE IS DECLARED. UPON DECLARING A NEW STATE,
; OUTPUT MODEM SIGNALS MAY BE SET OR RESET, TIMERS MAY BE STARTED OR
; CANCELLED AND ACTION ROUTINES MAY BE INVOKED.
;
; INPUTS:
;
;	R1 =	TRANSITION TYPE
;	R2 =	TYPE SPECIFIC ARGUMENT
;			DATASET - NEW RCV MODEM MASK
;	R5 =	UCB ADDRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
TRANSITION::
	MOVAL	STATE_INIT+MODEM$C_ST_LENGTH,R3	;ROOT OF STATE TABLE + OFFSET
	MOVZWL	UCB$W_TT_DS_ST(R5),R4
	ADDL	R3,R4
	CASE	R1,TYPE=B,<INIT,SHUTDWN,TRAN_LOOP,TRAN_LOOP,TRAN_LOOP>
INIT:
	JSB	MODEM$LINK_CRB			;LINK INTO CRB CHAIN
	MOVL	#IDLE-STATE_INIT,R2
	BRW	DECLARE_STATE			;INIT MODEM CONTROL
SHUTDWN:
	MOVL	#SHUTDOWN-STATE_INIT,R2		;DECLARE SHUTDOWN STATE
	BRW	DECLARE_STATE			;TRANSITION TO NEW STATE
TRAN_LOOP:
	MOVZBL	(R4),R3				;GET TRANSITION ELEMENT TYPE
	CASE	R3,TYPE=B,<DATASET,TIME,END,DIALTYPE,DZ11,NOMODEM>
						;DISPATCH TO TRANSITION SERVICE
;
END:		;LAST TRANSITION FOR STATE
	RSB

;
TIME:		;TIMEOUT TRANSITION ELEMENT TYPE
	CMPB	#MODEM$C_TIMER,R1		;TIMEOUT TRANSITION CALL
	BNEQ	NEXT_TRAN			;NO PROCESS NEXT ELEMENT
	BRW	NEW_STATE			;DECLARE NEW STATE

;
DATASET:	;DATASET TRANSITION ELEMENT TYPE
	CMPB	#MODEM$C_DATASET,R1		;MODEM INTERRUPT?
	BNEQ	10$				;NO , DONT UPDATE STATUS
	MOVB	R2,UCB$B_TT_DS_RCV(R5)		;UPDATE STATUS
10$:
	MOVZBL	UCB$B_TT_DS_RCV(R5),R2		;GET CURRENT STATUS
	TSTB	MODEM$B_TRAN_ONMASK(R4)		;MASK ACTIVE
	BEQL	15$				;NO
	MCOMB	MODEM$B_TRAN_ONMASK(R4),R3	;GET COMPLEMENT OF MASK
	BICB	R3,R2				;ISOLATE BITS OF INTEREST
	XORB	MODEM$B_TRAN_ONMASK(R4),R2	;TEST IF BOTH ON
	BEQL	20$				;YES
15$:
	MOVZBL	UCB$B_TT_DS_RCV(R5),R2		;GET CURRENT STATUS
	TSTB	MODEM$B_TRAN_OFFMASK(R4)	;MASK ACTIVE
	BEQL	NEXT_TRAN			;NO
	BITB	MODEM$B_TRAN_OFFMASK(R4),R2	;TEST SIGNALS OFF CASE
	BEQL	20$				;YES OFF, DECLARE NEW STATE
	BRW	NEXT_TRAN
20$:
	BRW	NEW_STATE			;ENTER NEW STATE

;
DIALTYPE:
	BITB	MODEM$B_TRAN_ONMASK(R4),-	;CHECK FOR MATCH
		G^TTY$GB_DIALTYP
	BEQL	NEXT_TRAN			;NO MATCH
	BRW	NEW_STATE			;ENTER NEW STATE
DZ11:
	MOVL	UCB$L_CRB(R5),R1		;GET CRB ADDRESS
	CMPB	CRB$B_TT_TYPE(R1),#DT$_DZ11	;IS CONTROLLER A DZ11?
	BNEQ	NEXT_TRAN
	BRW	NEW_STATE
NOMODEM:
	BBS	#TT$V_MODEM,UCB$L_DEVDEPEND(R5),-
		10$				;IF MODEM LINE, CONTINUE
	BRW	NEW_STATE			;LINE NO LONGER MODEM
10$:
	BRB	NEXT_TRAN

;
NEXT_TRAN:	;LOOK AT NEXT TRANSITION ELEMENT
	ADDL	#MODEM$C_TRAN_LENGTH,R4		;POINT TO NEXT ELEMENT
	BRW	TRAN_LOOP


	.page
;++
; DECLARE_STATE	-	DECLARE NEW STATE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO DECLARE A NEW MODEM STATE. IT HANDLES STARTING
; OR CANCELLING TIMERS, SETTING NEW MODEM OUTPUT SIGNALS (VIA THE PORT)
; AND INVOKING ACTION ROUTINES.
;
; INPUTS:
;
;	R2 =	NEW STATE BEING DECLARED
;	R5 =	UCB ADDRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
NEW_STATE:					;ALTERNATE ENTRY FOR CHANGING 
						;STATE FOR TRANSITION ELEMENT
	MOVZWL	MODEM$W_TRAN_NSTATE(R4),R2	;GET OFFSET TO NEXT STATE

DECLARE_STATE:
	MOVW	R2,UCB$W_TT_DS_ST(R5)		;SET NEW STATE
	MOVAL	STATE_INIT,R4			;ROOT OF STATE TABLE
	ADDL	R2,R4				;POINT TO STATE ENTRY
	MOVZWL	MODEM$W_ST_TIMER(R4),R2		;GET TIMER VALUE
	JSB	MODEM_TIMER			;SET NEW TIMER OR
						;CANCEL PREVIOUS IF ZERO
	MOVZWL	MODEM$B_ST_ONMASK(R4),R2	;GET SET SIGNAL MASK
						;TURN LOW BYTE ON,HIGH BYTE OFF
	BEQL	5$				;NULL FIELDS
	MOVL	UCB$L_TT_PORT(R5),R0		;ADDRESS PORT VECTOR TABLE
	JSB	@PORT_DS_SET(R0)		;SET NEW MODEM SIGNAL(S)
5$:
	MOVZWL	MODEM$W_ST_ROUTINE(R4),R2	;ACTION ROUTINE PRESENT?
	BEQL	10$				;NO
	MOVAL	STATE_INIT,R0
	ADDL	R0,R2				;COMPUTE ADDRESS OF ACTION ROUTINE
	JSB	(R2)				;INVOKE ACTION ROUTINE
10$:
	MOVL	#MODEM$C_NULL,R1
	BRW	TRANSITION			;DECLARE NULL TRANSITION IN NEW STATE
						;(TO PROCESS ANY PRESET 
						; MODEM SIGNALS)


	.PAGE
;++
; MODEM_TIMER	-	SET/RESET MASTER MODEM TIMER ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE STARTS OR CANCELS A MODEM PROTECOL TIMER FOR A LINE.
; ONE TQE IS USED TO TIME ALL ACTIVE LINES. THE TQE ONLY REMAINS ACTIVE
; SO LONG AS AT LEAST ONE TIMER IS NEEDED. SUBSEQUENT TIMERS USE THE
; SAME TQE. WHEN ALL CURRENT TIMERS EXPIRE THE TQE IS REMOVED FROM
; THE SYSTEM TIMER QUEUE UNTIL NEEDED AGAIN.
; SINCE TIMERS ARE ONLY NEEDED DURING TRANSITIONS, THIS IS A LOW OVERHEAD
; ACTIVITY. 
;
; INPUTS:
;
;	R2 =	NEW TIMEOUT VALUE OR 0 TO CANCEL ANY OUTSTANDING
;	R5 =	UCB ADDRESS
;
; OUTPUTS:
;	R0-R3	DESTROYED
;--
MODEM_TIMER:
	PUSHL	R4
	MOVL	UCB$L_CRB(R5),R4		;CRB ADDRESS
	TSTL	R2				;CANCEL?
	BEQL	TIMER_CANCEL			;YES

	;NEED TO INIT TIMER FOR LINE
	MOVW	R2,UCB$W_TT_DS_TIM(R5)	;SET TIME TO WAIT
	MOVB	CRB$B_TT_TIMMASK(R4),R0		;GET CURRENT STATE
	BISB	UCB$B_ERTCNT(R5),CRB$B_TT_TIMMASK(R4)	;SET LINE ACTIVE
	BITB	UCB$B_ERTCNT(R5),R0		;WAS IT ALREADY ACTIVE?
	BNEQ	5$				;YES, SKIP INC REFCNT
	INCW	TT$W_REFCNT			;BUMP IN USE COUNTER
5$:
	BICW	#TIMCTRL$M_CANCEL,TT$W_TIMCTRL	;RESET ANY CANCEL REQUEST
	BBC	#TIMCTRL$V_ACTIVE,TT$W_TIMCTRL,10$ ;TIMER NOT CURRENTLY ACTIVE
	BRB	TIMER_END
10$:						;NEED TO RESTART TIMER
	PUSHL	R5				;SAVE UCB ADDRESS
	MOVAL	TT$TIMQUENT,R5			;
	MOVB	#IPL$_QUEUEAST,TQE$B_RQTYPE(R5)	;SET UP FORK IPL
	PUSHAB	20$				;RETURN ADDRESS
	BRB	30$				;QUEUE FORK

20$:	POPL	R5				;RESTORE UCB ADDRESS
	BISW	#TIMCTRL$M_ACTIVE,TT$W_TIMCTRL	;SHOW TIMER ACTIVE
	BRB	TIMER_END
30$:
	JSB	G^EXE$FORK
	DSBINT	#IPL$_SYNCH			;INTERLOCK TO ENTER TIMER ENTRY
	MOVAB	W^TT$TIMER,TQE$L_FPC(R5)	;SET TIMEOUT ROUTINE ADDRESS
	MOVL	#5000000,TQE$Q_DELTA(R5)	;SET REPEAT AMOUNT (500MS)
	MOVB	#TQE$C_SSREPT,TQE$B_RQTYPE(R5)	;SET REPEATING TYPE
	MOVQ	G^EXE$GQ_SYSTIME,R0		;CURRENT SYSTEM TIME
	ADDL	#5000000,R0			;TIMEOUT DUE IN 500MS
	ADWC	#0,R1				;
	JSB	G^EXE$INSTIMQ			;INSERT IN TIMER QUEUE
	ENBINT					;RESTORE IPL
	RSB

TIMER_CANCEL:
	CLRW	UCB$W_TT_DS_TIM(R5)			;RESET TO INDICATE IDLE
	MOVB	CRB$B_TT_TIMMASK(R4),R0
	BICB	UCB$B_ERTCNT(R5),CRB$B_TT_TIMMASK(R4)	;RESET TIMER FOR THIS
	BITB	UCB$B_ERTCNT(R5),R0			; LINE. 
	BNEQ	10$
	BRB	20$				;TIMER NOT ACTIVE ON LINE
10$:
	DECW	TT$W_REFCNT
20$:
	TSTW	TT$W_REFCNT			;ANY ACTIVE TIMERS?
	BNEQ	TIMER_END			;YES

	;NO ACTIVE TIMERS  SO,	
	;TIMER NEEDS TO BE CANCELLED

	BISW	#TIMCTRL$M_CANCEL,TT$W_TIMCTRL	;REQUEST TIMER CANCEL

TIMER_END:
	POPL	R4
	RSB

	.PAGE
;++
; TT$TIMER	-	TIMER INTERRUPT ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS INVOKED UPON THE EXPIRATION OF THE MODEM PROTECOL TQE.
; IT COUNTS DOWN ALL ACTIVE TIMERS AND INVOKES THE TRANSITION
; ROUTINE FOR ANY LINES THAT HAVE TIMED OUT. THE ROUTINE REQUEUES THE
; TQE INTO THE SYSTEM TIMER QUEUE UNLESS ALL ACTIVE TIMERS HAVE
; EXPIRED.
;
; INPUTS:
;
;	R5 =	TQE ADDRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
TT$TIMER:
	PUSHR	#^M<R5,R6>
	MOVAL	TT$L_DIALUP,R4			;GET ROOT OF CRB LIST
5$:
	MOVL	(R4),R4				;GET NEXT CRB ADDRESS
	BNEQ	15$				;PROCESS LINES FOR CRB
	POPR	#^M<R5,R6>
	DSBINT	#31				;INTERLOCK 
	BBC	#TIMCTRL$V_CANCEL,TT$W_TIMCTRL,10$	;DONT CANCEL TIMER
	BICW	#<TIMCTRL$M_ACTIVE!TIMCTRL$M_CANCEL>-
		,TT$W_TIMCTRL			;RESET CANCEL +TIMER ACTIVE BITS
	MOVAL	G^EXE$AL_TQENOREPT, R5		; Point R5 to no-repeat TQE
						; thus ending timer thread.
10$:
	ENBINT
	RSB
15$:
	PUSHL	R4				;SAVE TIMER THREAD
	SUBL	#CRB$L_TT_MODEM,R4		;GET ACTUAL CRB ADDRESS

	;PROCESS LINES WITH ACTIVE TIMERS
	MOVB	CRB$B_TT_TIMMASK(R4),R6		;GET CRB TIMER ACTIVE MASK
20$:
	FFS	#0,#8,R6,R2			;FIND FIRST LINE
	BEQL	40$				;NO MORE, TRY NEXT LINE
	BBCC	R2,R6,25$			;RESET FLAG FOR THAT LINE
25$:
	MOVL	CRB$L_INTD+VEC$L_IDB(R4),R3	;GET ADRESS OF IDB
	MOVL	IDB$L_UCBLST(R3)[R2],R5		;GET UCB FOR THAT LINE
	BEQL	20$				; If UCBaddr = 0, skip it.
	MOVB	#MODEM$C_TIMER,R1		;SET TRANSITION TYPE
	PUSHR	#^M<R4>
	DSBINT	UCB$B_DIPL(R5)			;INTERLOCK WITH DEVICE INTERRUPTS
	DECW	UCB$W_TT_DS_TIM(R5)		;COUNT DOWN LINE
	BNEQ	30$				;NOT TIME YET
	DECW	TT$W_REFCNT			;
	BICB	UCB$B_ERTCNT(R5),CRB$B_TT_TIMMASK(R4)
	JSB	TRANSITION			;INVOKE TRANSITION ROUTINE
	;LOWER IPL
30$:
	ENBINT
	POPR	#^M<R4>
	BRB	20$				;LOOK FOR NEXT LINE
40$:
	POPL	R4				; RESTORE TIMER THREAD
	BRW	5$
	
	.PAGE
;++
; MODEM$LINK_CRB	
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO LINK THE ASSOCIATED CRB OF A UCB
; REQUIRING MODEM CONTROL INTO THE MODEM PROTECOL TIMER QUEUE.
; NOTE THAT THIS QUEUE IS SEPERATE FROM THE DZ-11 SPECIFIC
; MODEM TRANSITION POLLING QUEUE.
;
; INPUTS:
;
;	R5 =	UCB ADDRRESS
;
; OUTPUTS:
;	R0-R4	DESTROYED
;--
;
;	CHECK IF CRB NEEDS INSERTION ON MODEM TIMER QUEUE
;
MODEM$LINK_CRB:

	MOVL	UCB$L_CRB(R5),R4		; GET CRB ADDRESS
	MOVAL	TT$L_DIALUP,R1			; ADDRESS OF LIST HEAD
	MOVAL	CRB$L_TT_MODEM(R4),R3		; GET CRB THREAD
	MOVL	R1,R2
10$:
	CMPL	(R2),R3				; CRB ON LIST
	BEQL	20$				; YES
	MOVL	(R2),R2				; POINT TO NEXT
	BNEQ	10$				; IF NOT END, LOOK AGAIN
	MOVL	(R1),(R3)			; LINK AT LIST HEAD
	MOVL	R3,(R1)
20$:	
	MOVL	UCB$L_TT_PORT(R5),R0		; ADDRESS PORT VECTOR TABLE
	JSB	@PORT_SET_MODEM(R0)		; INVOKE ANY PORT SPECIFIC SETUP
	RSB

	.page
	.sbttl	MODEM STATE TABLES
;++
; MODEM CONTROL STATE TABLES
;
; FUNCTIONAL DESCRIPTION:
;
;	 THIS TABLE CONTAINS STATE ENTRIES. EACH STATE CORRESPONDS TO
; A MODEM PROTECOL STATE. EACH STATE ENTRY CONSISTS OF A MODEM SIGNAL
; MASK TO BE SET ON STATE ENTRY, AN INITIAL TIMER VALUE TO BE STARTED ON 
; STATE ENTRY AND AN OPTIONAL ACTION ROUTINE.
;	FOLLOWING THE STATE ENTRY ARE TRANSITION ELEMENTS. ON ANY
; TRANSITION : TIMEOUT, MODEM INTERRUPT, OR PROGRAM DECLARED, EACH
; TRANSITION ELEMENT IS PROCESSED SEQUENTIALLY. THE LAST TRANSITION ELEMENT
; IS ALWAYS AN END TRANSITION ELEMENT WHICH SIGNALS THAT
; NO TRANSITION OCCURS IF IT IS PROCESSED. OTHER TRANSITION ELEMENT TYPES
; MAKE CONDITIONAL TESTS AND MAY DECLARE A NEW STATE IF THE APPROPRIATE
; CONDITIONS HOLD TRUE. 
;--


;	MODEM STATE MACRO DEFINITIONS
;

	.macro	state	name,onmask=0,offmask=0,timer,routine
name:
	.byte	onmask
	.byte	offmask
	.if	nb	timer
	.word	<timer*2>
	.if_false
	.word	0
	.endc
	.if	nb	routine
	.word	routine-state_init
	.if_false
	.word	0
	.endc
	.endm	state

	.macro	tran	type,nstate,onmask=0,offmask=0
	.if	idn type,end
	.byte	modem$c_tran_end
	.if_false
	.byte	modem$c_tran_'type',0
	.word	nstate-state_init
	.byte	offmask
	.byte	onmask
	.endc
	.endm	tran

	.PAGE

STATE_INIT:

;
; LINE NOT UNDER MODEM CONTROL
;
	STATE	OFF			
	TRAN	END

;
; INITIAL MODEM STATE
;
	STATE	IDLE,OFFMASK=<TT$M_DS_DTR!TT$M_DS_RTS>,TIMER=2
	TRAN	DIALTYPE,ONMASK=02,NSTATE=RINGWAIT
	TRAN	TIME,NSTATE=WAIT
	TRAN	END

;
; WAIT FOR RING PRIOR TO SETTING DTR
;

	STATE	RINGWAIT
	TRAN	DATASET,ONMASK=<TT$M_DS_RING>,NSTATE=INIT2
	TRAN	END

;
; WAIT FOR DTR AND RTS
; (IF DZ-11 GO DO SUBSET SUPPORT)
;
	STATE	WAIT,ONMASK=<TT$M_DS_DTR!TT$M_DS_RTS>
	TRAN	DZ11,NSTATE=DZWAIT
	TRAN	DATASET,ONMASK=TT$M_DS_DSR,NSTATE=INIT1
	TRAN	END

;
; DZ-11 SUBSET SUPPORT
; WAIT FOR CARRIER OR RING
;
	STATE	DZWAIT
	TRAN	DATASET,ONMASK=<TT$M_DS_CARRIER>,NSTATE=TRANSMIT
	TRAN	DATASET,ONMASK=<TT$M_DS_RING>,NSTATE=INIT2
	TRAN	END

;
; DELAY 
;
	STATE	INIT1,TIMER=1
	TRAN	TIME,NSTATE=INIT2
	TRAN	END

;
; START TIMER AND WAIT FOR CTS AND CARRIER
; IF TIMER EXPIRES, SHUTDOWN LINE
;
	STATE	INIT2,ONMASK=<TT$M_DS_DTR!TT$M_DS_RTS>,TIMER=30
	TRAN	TIME,NSTATE=SHUTDOWN
	TRAN	DATASET,ONMASK=<TT$M_DS_CTS!TT$M_DS_CARRIER!TT$M_DS_DSR>,-
		NSTATE=TRANSMIT
	TRAN	END

;
; NORMAL TRANSMIT STATE
; 
	STATE	TRANSMIT,ROUTINE=LOGIN
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=SHUTDOWN
	TRAN	DATASET,OFFMASK=TT$M_DS_CARRIER,NSTATE=TRANSMIT1
	TRAN	END

;
; LOSS OF CARRIER DETECTED
;
	STATE	TRANSMIT1,TIMER=2
	TRAN	DIALTYPE,ONMASK=01,NSTATE=SHUTDOWN
	TRAN	TIME,NSTATE=SHUTDOWN
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=SHUTDOWN
	TRAN	DATASET,ONMASK=TT$M_DS_CARRIER,NSTATE=TRANSMIT
	TRAN	END

;
; DELAY PRIOR TO COMPLETE SHUTDOWN
;
	STATE	SHUTDOWN,TIMER=1,OFFMASK=TT$M_DS_DTR,ROUTINE=LOGOUT
	TRAN	TIME,NSTATE=SHUT1
	TRAN	END

;
; COMPLETE SHUTDOWN
; AND THEN REINIT
;
	STATE	SHUT1,TIMER=2
	TRAN	NOMODEM,NSTATE=OFF
	TRAN	TIME,NSTATE=IDLE
	TRAN	DATASET,OFFMASK=TT$M_DS_DSR,NSTATE=IDLE
	TRAN	END

	.PAGE
	.SBTTL	MODEM ACTION ROUTINES
;
;	LOGIN/LOGOUT CODE

;	THESE ROUTINES ACT AS ACTION ROUTINES FOR MODEM CONNECTION
; 	AND DISCONECTION. ON CONNECTION THE REMOTE BIT IS SET.
;	ON DISCONNECT A CONTROL Y AST IS FIRED WITH HANGUP STATUS
;	TO SIGNAL THE CLI. ALSO ANY OUTSTANDING ATTENTION ASTS ARE
; 	FIRED.
;
LOGIN:
	BBSS	#TT$V_REMOTE,UCB$L_DEVDEPEND(R5),5$	;SET REMOTE TERMINAL
5$:	RSB

LOGOUT:
	PUSHR	#^M<R0,R1,R2>
	DSBINT	UCB$B_DIPL(R5)
	BBCC	#TT$V_REMOTE,UCB$L_DEVDEPEND(R5),10$	;RESET REMOTE TERMINAL
10$:	
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE VECTOR FOR UNIT
	MOVAB	UCB$L_TT_CTRLY(R5),R4	; ADDRESS CONTROL Y AST LIST
	MOVL	R4,R0			; COPY LIST ADDRESS
	TSTL	(R0)			;LIST HEAD EMPTY?
	BNEQ	75$			;NO,PROCESS HANGUP ASTS
	TSTW	UCB$W_REFC(R5)		;IS THIS UNIT OWNED OR ACTIVE?
					;(OR IS IT LOGGED OUT)
	BEQL	75$			;NOT ACTIVE,SO SKIP FLAG SETTING
	BISW	#UCB$M_TT_HANGUP,-
		UCB$W_DEVSTS(R5)	;SET HANGUP FLAG TO NOTIFY NEXT CTRL-Y
					;ATTENTION AST WHEN IT IS QUEUED.
75$:	MOVL	(R0),R0			; GET NEXT ENTRY
	BEQL	80$			; IF EQL THEN DONE
	MOVZWL	#SS$_HANGUP,ACB$L_KAST+4(R0); INSERT NEW PARAM FOR AST
	BRB	75$			; CONTINUE UNTIL DONE
80$:	JSB	G^COM$DELATTNAST	; DELIVER THE AST'S

;
; Now stop all I/O on this unit.
;

	MOVZWL	#SS$_HANGUP,UCB$W_BOFF(R5) ; SET THE RETURN STATUS
	MOVAB	UCB$L_TT_WFLINK(R5),R1	; Get start of write queue.
	MOVL	R1,R3			; Copy it to check for end.

90$:
	MOVL	TTY$L_WB_FLINK(R3),R3	; Get next entry.
	CMPL	R3,R1			; At end of queue?
	BEQL	110$			; Yes. Branch forward.
	MOVL	TTY$L_WB_IRP(R3),R4	; Get associated IRP address.
	BEQL	90$			; If no IRP, it's a broadcast,
					; leave it in the queue.
	MOVL	TTY$L_WB_BLINK(R3),R3	; Get entry's backward link.
	REMQUE	@TTY$L_WB_FLINK(R3),R4	; Remove the link.
	BSBW	TTY$WRITEPOST		; Queue it for completion
	BRB	90$			; Try for next link.

110$:					; Stop the current I/Os.
	IF_NOT_STATE -			; Branch forward if no read is
		READ,120$		; currently in progress.
	CLR_STATE -			; Clear escape bits.
		<ESC,BADESC>
	MOVL	UCB$L_IRP(R5),R4	; Get address of IRP.
	CLRL	IRP$L_MEDIA(R4)		; Clear terminators.
	BSBW	TTY$READONE		; Complete the read.
120$:					; Check for a write to complete.
	IF_STATE -			; Ignore broadcasts.
		BRDCST,130$
	IF_NOT_STATE -			; Branch forward if no write is
		WRITE,130$		; in progress.
	MOVL	UCB$L_TT_WRTBUF(R5),R3	; Get address of write packet.
	MOVW	UCB$W_BOFF(R5),-	; Put status code in the
		TTY$W_WB_STATUS(R3)	; packet.
	BSBW	TTY$WRITEDONE		; Complete the I/O.

130$:					; And echo the control char.
	ENBINT				; LOWER IPL
	MOVL	#MSG$_TRMHANGUP,R4	; SET MESSAGE TYPE
	MOVL	UCB$L_AMB(R5),R3	; GET ASSOC MAILBOX
	BEQL	180$			; IF EQL THEN NONE
	JSB	G^EXE$SNDEVMSG		; INSERT MAILBOX MESSAGE
180$:
	POPR	#^M<R0,R1,R2>
	RSB


	.PAGE
	.SBTTL	FIND DRIVER
;++
; FIND_DRIVER - LOCATE ALTERNATE TERMINAL CLASS DRIVER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SEARCHES FOR THE SPECIFIED CLASS DRIVER AND
; RETURNS THE ADDRESS OF ITS DPT.
;
; INPUTS:
;
;	R1 - ADDRESS OF DRIVER NAME DESCRIPTOR
;
; OUTPUTS:
;
;	R0 - RETURN CODE
;--

FIND_DRIVER::
	PUSHR	#^M<R2,R3,R4,R5,R6,R7>
	MOVZBL	(R1)+,R4		;GET SIZE OF DRIVER NAME
	MOVL	R1,R5			;GET ADDR OF DRIVER NAME
	MOVAB	G^IOC$GL_DPTLIST,R6	;GET ADDR OF DPT LIST
	MOVL	R6,R7			;SAVE IT
10$:
	MOVL	DPT$L_FLINK(R6),R6	;GET ADDR OF NEXT DRIVER PROLOGUE
	CMPL	R6,R7			;END OF LIST?
	BEQL	20$			;BR IF YES
	MOVAB	DPT$T_NAME(R6),R1	;GET ADDR OF DRIVER NAME
	MOVZBL	(R1)+,R0		;GET SIZE OF DRIVER NAME
	CMPC5	R0,(R1),#0,R4,(R5)	;COMPARE DRIVER NAMES
	BNEQ	10$			;BR IF NOT EQUAL
	MOVL	R6,R1			;SET ADDR OF DRIVER PROLOGUE
	MOVB	#1,R0			;SIGNAL SUCCESS
	BRB	25$
20$:
	CLRB	R0
25$:
	POPR	#^M<R2,R3,R4,R5,R6,R7>
	RSB



	.SBTTL	End of module

TT_END::				; End of Terminal Class Driver
	.END
