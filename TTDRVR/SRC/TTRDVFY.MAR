	.TITLE	TTRDVFY - RESERVED FOR FUTURE EXPANSION
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1982                                                      *
;*  BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.			    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************
;

;++
;
; FACILITY:
;
; ABSTRACT:
;
;
; ENVIRONMENT:
;
;
;--
;
; AUTHOR: RICK SPITZ	, CREATION DATE: 1-JAN-1982
;
; MODIFIED BY:
;
;**


	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	.ENABLE	SUPPRESSION

	$DYNDEF
	$IODEF
	$IRPDEF
	$JIBDEF
	$SSDEF
	$TTYDEF
	$TTDEF
	$TT2DEF
	$TTYMACS
	$TTYDEFS

	P1 = 0
	P2 = 4
	P3 = 8
	P4 = 12
	P5 = 16
	P6 = 20


	.DISABLE	SUPPRESSION
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	.=0
$DEFINI	TTY$VB

$DEF	TTY$L_VB_PIC			; ADDRESS OF PICTURE STRING
			.LONG	0
$DEF	TTY$L_VB_DATA			; ADDRESS OF START OF READ FIELD
			.LONG	0
$DEF	TTY$L_VB_ADDR			; TEMP ADDRESS OF OUTPUT STRING
			.LONG	0
$DEF	TTY$W_VB_SIZE			; FIELD SIZE
			.WORD	0
$DEF	TTY$W_VB_RSIZE			; SUBFIELD SIZE (RIGHT JUSTIFY)
			.WORD	0
$DEF	TTY$W_VB_OFFSET			; OFFSET INTO FIELD
			.WORD	0
$DEF	TTY$W_VB_BUFSIZE		; READ BUFFER SIZE
			.WORD	0
$DEF	TTY$W_VB_LEN			; TEMP STRING LENGTH
			.WORD	0
$DEF	TTY$W_VB_CTRL			; CONTROL FIELD
			.WORD	0

$VIELD	TTV,0,<-
	<R_JUST,,M>-		; RIGHT JUSTIFY
	<AUTO_TAB,,M>-		; FIELD IS AUTO TAB
	<ESCAPE,,M>-		; ** NEED TO RESERVE A GAP ***
	>
$DEF	TTY$K_VB_LENGTH

$DEFEND TTY$VB

	.=0
$DEFINI	TTY$PB

$DEF	TTY$Q_PB_PROMPT			; PROMPT DESCRIPTOR
			.QUAD	0
$DEF	TTY$Q_PB_INITIAL		; INITIAL STRING
			.QUAD	0
$DEF	TTY$Q_PB_PIC			; PICTURE STRING
			.QUAD	0
$DEF	TTY$W_PB_OFFSET			; INITIAL OFFSET
			.WORD	0
$DEF	TTY$W_PB_TYPE			; CONTROL INFORMATION
			.WORD	0

$DEF	TTY$K_PB_LENGTH

$DEFEND	TTY$PB

;
;	CONTROL INFORMATION SAVED ON STACK
;
	.=0
$DEFINI	TTY$SV

$DEF	TTY$Q_SV_PIC
			.QUAD	0
$DEF	TTY$Q_SV_INITIAL
			.QUAD	0
$DEF	TTY$Q_SV_PROMPT
			.QUAD	0
$DEF	TTY$K_SV_LENGTH

$DEFEND	TTY$SV

.PAGE

;
;	VERIFICATION ARRAY
;

ALPHA_UPPER = 1
ALPHA_LOWER = 2
NUM09 = 4
PLUS_MINUS = 8
PRINTABLE = 16
CHAR_ALL = 32


	.PSECT $$$115_DRIVER,LONG

VERIFY_ARRAY:
	.REPEAT	32
.BYTE	CHAR_ALL
	.ENDR
	.REPEAT 11
.BYTE	CHAR_ALL!PRINTABLE
	.ENDR
.BYTE	CHAR_ALL!PRINTABLE!PLUS_MINUS
.BYTE	CHAR_ALL!PRINTABLE
.BYTE	CHAR_ALL!PRINTABLE!PLUS_MINUS
	.REPEAT 2
.BYTE	CHAR_ALL!PRINTABLE
	.ENDR
	.REPEAT 10
.BYTE	CHAR_ALL!PRINTABLE!NUM09
	.ENDR
	.REPEAT 7
.BYTE	CHAR_ALL!PRINTABLE
	.ENDR
	.REPEAT	26
.BYTE	CHAR_ALL!PRINTABLE!ALPHA_UPPER
	.ENDR
	.REPEAT 6
.BYTE	CHAR_ALL!PRINTABLE
	.ENDR
	.REPEAT	26
.BYTE	CHAR_ALL!PRINTABLE!ALPHA_LOWER
	.ENDR
	.REPEAT 4
.BYTE	CHAR_ALL!PRINTABLE
	.ENDR
.BYTE	CHAR_ALL
	.REPEAT 128
.BYTE	CHAR_ALL
	.ENDR

.PAGE



;
; OWN STORAGE:
;



;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;	NONE
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--


	.SBTTL	TERMINAL CLASS DRIVER PROLOGUE TABLE
	.PSECT	$$$105_PROLOGUE

;
; CLASS DRIVER DPT
;

TT$DPT::				; DRIVER START
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=TT_END,-		; END OF CLASS DRIVER
		UCBSIZE=UCB$C_TT_LENGTH,- ; SIZE OF UCB
		ADAPTER=NULL,-		; ADAPTER TYPE
		NAME=TTRDVFY,-		; NAME OF DRIVER
		VECTOR=CLASS_VECTOR	; CLASS VECTOR TABLE
	DPT_STORE INIT
	DPT_STORE REINIT
	DPT_STORE END



	.SBTTL	DRIVER DISPATCH TABLE AND FUNCTION DECISION TABLE
;
; DRIVER DISPATCH TABLE
;
	DDTAB	TT,-			; DRIVER DISPATCH TABLE
		0,-			; START IO OPERATION
		0,-			; UNEXPECTED INTERRUPT
		FUNCTION,-		; FUNCTION DECISION TABLE
		0,-			; CANCEL I/O
		0,-			; REGISTER DUMP ROUTINE
		0,-			; SIZE OF DIAGNOSTIC BUFFER
		0,-			; SIZE OF ERROR LOG BUFFER
		0,-			; Unit initialization routine
		0			; Alternate START I/O

;
; FUNCTION DECISION TABLE FOR ALL TERMINALS
;
FUNCTION:
	FUNCTAB	,-			; LEGAL FUNCTIONS
		<READPROMPT,-
		TTYREADPALL,-
		>
	FUNCTAB	,-			; BUFFERED I/O FUNCTIONS
		<READPROMPT,-
		TTYREADPALL,-
		>
	FUNCTAB	TTY$FDTREAD,<READPROMPT,TTYREADPALL>

	.PAGE

;	THIS TABLE IS USED FOR COMMUNICATION WITH THE TERMINAL CLASS DRIVER.
;	IT INITIALLY CONTAINS RELATIVE OFFSETS TO VARIOUS ROUTINES AND
;	DATA STRUCTURES NEEDED BY TERMINAL PORT DRIVERS. AT DRIVER LOAD
;	THE RELATIVE OFFSETS ARE RELOCATED TO ACTUAL VIRTUAL ADDRESSES.
;	THE LIST IS TERMINATED BY A 0 LONGWORD TO SIGNAL THE RELOCATION
;	ROUTINE WHERE THE LIST TERMINATES.

CLASS_VECTOR:
	.LONG	NULL - TT$DPT; GET NEXT STRING
	.LONG	VERIFY- TT$DPT	; PUT NEXT STRING
	.LONG	NULL - TT$DPT	; ROUTINE TO INIT UCB
	.LONG	NULL - TT$DPT	; ROUTINE TO HANDLE MODEM TRANSITIONS

	.LONG	TTY$FDTREAD	;**POINTER TO FDT ROUTINE**
				; REPLACES CLASS DRIVER DDT ADDRESS
	.LONG	NULL
	.LONG	0				; END OF LIST

NULL:	RSB

	.PSECT	$$$115_DRIVER,LONG


	.SBTTL	TTY$FDTREAD - FUNCTION DECISION ROUTINE FOR READ FUNCTIONS
;++
; TTY$FDTREAD - FUNCTION DECISION ROUTINE FOR TERMINAL READ
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ACTION ROUTINE FOR TERMINAL READS.
;
; THE TERMINAL READ QIO PARAMETERS ARE:
;
;	P1 = ADDRESS OF THE BUFFER TO RECEIVE THE DATA RECORD
;	P2 = SIZE OF THE P1 BUFFER
;	P3 = NUMBER OF SECONDS TO WAIT FOR CHARACTERS (IO$M_TIMED ONLY)
;	P4 = ADDRESS OF TERMINATOR CLASS BITMASK OR 0 IF STANDARD
;	P5 = ADDRESS OF CONTROL BUFFER FOR IO$_READPROMPT
;	P6 = SIZE OF PROMPT STRINT FOR IO$_READPROMPT
;
; THE FUNCTION PARAMETERS ARE VALIDATED AND IF CORRECT, THE PACKET IS
; QUEUED ON THE UNIT I/O QUEUE.
; THE PACKET CONTAINS THE FOLLOWING:
;
;	1. IRP$Q_TT_STATE IS SET UP TO BE THE NEW TERMINAL STATES AT THE
;	   TIME THE READ OPERATION IS STARTED.
;	2. IRP$L_SVAPTE CONTAINS THE ADDRESS OF THE READ BUFFER
;	   FORMATTED AS FOLLOWS.
;
;		.LONG	ADDRESS TO STORE DATA
;		.LONG	USER BUFFER VIRTUAL ADDRESS
;		.WORD	SIZE
;		.WORD	TYPE
;		.WORD	STORAGE FOR STARTING CURSOR POSITION
;		.WORD TIMEOUT COUNT	
;		PROMPT STRING
;		READ BUFFER
;		TERMINATOR MASK FOR NONSTANDARD CLASSES
;
;	3. IRP$L_TT_TERM ADDRESSES THE TERMINATOR BITMASK
;	4. IRP$W_FUNC<0:6> ARE SET FOR A FAST CASE ON FUNCTION TYPE
;	5. IRP$W_BOFF IS THE QUOTA FOR THE I/O
;	6. IRP$W_BCNT IS THE READ REQUEST SIZE
;
; STATE BIT USAGE.
;
;	FOR IO$_READPBLK, TTY$V_ST_PASSALL IS SET.
;	FOR IO$_READPROMPT, TTY$V_ST_PROMPT AND TTY$V_ST_CTRLR ARE SET.
;		CTRLR WILL FORCE THE PROMPT OUT WHEN THE READ IS STARTED.
;
;	FOR IO$M_NOECHO, TTY$V_ST_NOECHO IS SET.
;	FOR IO$M_NOFILTR, TTY$V_ST_NOFILTR IS SET.
;	For IO$M_REFRESH, TTY$V_ST_REFRSH is set.
;
; INPUTS:
;
;	R3 = ADDRESS OF THE PACKET FOR THIS REQUEST
;	R4 = CURRENT PCB
;	R5 = UCB ADDRESS
;	R6 = ASSIGNED CCB
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
;
; OUTPUTS:
;
;	THE I/O IF IN ERROR IS COMPLETED VIA "EXE$ABORTIO".
;	THE I/O IF VALID IS QUEUED TO THE DRIVER BY "EXE$QIODRVPKT".
;
; COMPLETION CODES:
;
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER.
;	SS$_EXQUOTA - OVER QUOTA FOR BUFFERED I/O
;	SS$_INSFMEM - INSUFFICIENT MEMORY
;--

TTY$FDTREAD::				;
;
; SET PROPER STATE BITS FOR READ FUNCTIONS FROM FUNCTION MODIFIERS
;
; NOTE THE CORRESPONDENCE OF THE VALUES
;
	ASHL	#TTY$V_ST_NOECHO-	; Move function code and its
		-IO$V_NOECHO,-		; modifiers into bits 9-25 of
		IRP$W_FUNC(R3),R8	; a register.
	BICL	#^C<TTY$M_ST_NOECHO!-	; Clear all bits except NOECHO
		TTY$M_ST_NOFLTR!-	; NOFLTR, and
		TTY$M_ST_ESCAPE!-	; ESCAPE
		TTY$M_ST_REFRSH>,R8	; REFRESH if specified.
	MOVZWL	#TTY$M_ST_READ,-
		IRP$Q_TT_STATE(R3)	; INIT AND ADD READ
;
; CHECK ACCESS TO READ BUFFER
;
	MOVL	P1(AP),R0		; GET BUFFER ADDRESS AND SIZE
	MOVZWL	P2(AP),R1		;
	BEQL	35$			; IF ZERO THEN ERROR
5$:	JSB	G^EXE$READCHK		; CHECK READ ACCESS FOR BUFFER
					; NO RETURN MEANS NO ACCESS

10$:	MOVQ	R0,R9			; COPY INPUT BUFFER PARAMS
					; R9 - ADDRESS, R10 - LENGTH
;
; DO SPECIAL FUNCTION LOGIC 
;
20$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READPROMPT?
		IRP$W_FUNC(R3),#IO$_READPROMPT
	BEQL	22$			; YES, BRANCH
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READ PASSALL W/PROMPT?
		IRP$W_FUNC(R3),#IO$_TTYREADPALL
	BNEQ	35$			; BRANCH IF NO
	BBCS	#TTY$V_ST_PASALL,R8,22$	; SET PASSALL BIT IN VECTOR
22$:
;
; SEE IF NO CONTROL IS SPECIFIED
;
	MOVZWL	P6(AP),R7		; GET SIZE OF CONTROL BUFFER
	BEQL	35$			; IF EQL THEN ERROR

30$:	BISL	#TTY$M_ST_PROMPT,R8	; INSERT BITS FOR PROMPT
	BISL	#TTY$M_ST_CTRLR,IRP$Q_TT_STATE(R3); INSERT BITS FOR PROMPT
	MOVL	P5(AP),R0		; GET CONTROL BUFFER ADDRESS
;
; CHECK ACCESS TO PROMPT STRING
;
	MOVZWL	R7,R1			; GET SIZE OF CONTROL BUFFER
	CMPL	R1,#TTY$K_PB_LENGTH	; LARGE ENOUGH?
	BGEQU	40$			; YES
35$:	BRW	150$

40$:
	JSB	G^EXE$WRITECHK		; CHECK PROMPT BUFFER ACCESS
					; NO RETURN MEANS NO ACCESS
	MOVL	R0,R6			; COPY PROMPT STRING ADDRESS

	MOVZWL	TTY$Q_PB_PROMPT(R6),R1	; GET PROMPT LENGTH
	MOVL	TTY$Q_PB_PROMPT+4(R6),R0; GET ADDRESS
	PUSHL	R0			; SAVE PROMPT ADDRESS
	PUSHL	R1			; SAVE LENGTH
	MOVL	R1,R7			; INIT TOTAL LENGTH
	ADDL	#3,R7			; ROUND UP TO NEXT LONGWORD
	BICL	#3,R7
	JSB	G^EXE$WRITECHK

	MOVZWL	TTY$Q_PB_INITIAL(R6),R1	; GET INITIAL STRING LENGTH
	MOVL	TTY$Q_PB_INITIAL+4(R6),R0 ; GET ADDRESS
	PUSHL	R0			; SAVE INITIAL ADDRESS
	PUSHL	R1			; SAVE LENGTH
	ADDL	R1,R7			; SUM TOTAL LENGTH
	JSB	G^EXE$WRITECHK

	MOVZWL	TTY$Q_PB_PIC(R6),R1	; GET PICTURE LENGTH
	MOVL	TTY$Q_PB_PIC+4(R6),R0	; GET ADDRESS
	PUSHL	R0			; SAVE ADDRESS
	PUSHL	R1			; SAVE LENGTH
	MOVL	SP,R11			; SAVE POINTER TO STACKED ARRAY
	ADDL	R1,R7
	JSB	G^EXE$WRITECHK

	CMPW	TTY$Q_SV_INITIAL(R11),-
		TTY$Q_SV_PIC(R11)
	BNEQ	70$			; ERROR, PIC DOES NOT MATCH DATA

	CMPW	R10,TTY$Q_SV_INITIAL(R11); CHECK IF READ LONG ENOUGH
	BLEQ	70$			; NO
		
	PUSHL	R3			; SAVE IRP ADDRESS

	BBSS	#IRP$V_FUNC,IRP$W_STS(R3),50$; RESET TRANSFER DIRECTION
50$:
	ADDW3	TTY$Q_SV_PROMPT(R11),#TTY$L_RB_DATA,-
		IRP$W_TT_PRMPT(R3)	; SAVE PROMPT SIZE 
	ADDL3	#TTY$L_RB_DATA+TTY$K_VB_LENGTH,-
		R7,R1			; ADJUST SIZE FOR BLOCK HEADER
55$:

;
; CHECK FOR BUFFERED I/O QUOTA
;
65$:	JSB	G^EXE$BUFFRQUOTA	; CHECK QUOTA
	BLBC	R0,67$			; SIGNAL ERROR IF LOW CLEAR
;
; ALLOCATE THE BUFFER
;
	JSB	G^EXE$ALLOCBUF		; ALLOCATE THE BUFFER
					; R2 IS ALLOCATED BUFFER
	POPL	R3			; RESTORE PACKET
	BLBS	R0,72$			; CONTINUE IF NO ERROR

67$:	BRW	200$			; IF ERROR, THEN ABORT I/O WITH STATUS

70$:
	BRW	150$			; IF ERROR, THEN ABORT I/O BAD PARAMETER
72$:					;

74$:	MOVL	R2,IRP$L_SVAPTE(R3)	; SAVE ADDRESS OF BUFFERED I/O BLOCK
	MOVW	R1,IRP$W_BOFF(R3)	; SAVE BLOCK SIZE AS QUOTA
;
; ADJUST BUFFERED I/O QUOTA
;
	MOVL	PCB$L_JIB(R4),R4	; GET JIB ADDRESS
	MOVZWL	R1,R1			; CONVERT TO LONG WORD COUNT
	SUBL	R1,JIB$L_BYTCNT(R4)	; ADJUST QUOTA WORD
;
;	MARK PACKET AS TERMINAL I/O
;
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3)	; SET FLAG FOR GREATER PRIORITY
					; INCREMENTS UPON COMPLETION
;
; SET UP BUFFERED I/O BLOCK
;	R2 = ALLOCATED BUFFER
;	R3 = IRP
;	R4 = PCB
;	R5 = UCB
;	R7 = LENGTH OF PROMPT+INITIAL+PIC
;	R11= ADDRESS OF STACKED PARAMETERS
;

	MOVL	R9,TTY$L_RB_UVA(R2)	; INSERT USER VIRTUAL ADDRESS
	MOVAB	TTY$L_RB_DATA(R2),TTY$L_RB_NXT(R2); INSERT POINTER TO DATA AREA
	PUSHR	#^M<R3,R4,R5>		; SAVE REGISTERS

90$:
	MOVW	P3(AP),TTY$W_RB_TIMOS(R2); GET TIMEOUT COUNT


	MOVZWL	TTY$Q_SV_PROMPT(R11),R0	; GET PROMPT SIZE
	MOVAL	TTY$L_RB_DATA(R2),R9	; ADDRESS OF DATA START
	ADDL	R9,R7			; ADDRESS OF POINTER BLOCK
	MOVL	R7,TTY$L_RB_EXTEND(R2)	; SAVE IT
	ADDL	R0,R9			; ADDRESS OF READ FIELD

	MOVL	TTY$Q_SV_PROMPT+4(R11),R1; GET PROMPT ADDRESS
	MOVC3	R0,(R1),TTY$L_RB_DATA(R2) ; COPY TO BUFFER

	MOVZWL	TTY$Q_SV_INITIAL(R11),R0	; GET INITIAL STRING SIZE
	MOVL	TTY$Q_SV_INITIAL+4(R11),R1 ; GET ADDRESS
	MOVL	R9,R4			; ADDRESS OF FIELD START
	ADDL	R0,R9			; GET NEXT ADDRESS
	MOVL	R4,TTY$L_VB_DATA(R7)	; SAVE ADDRESS
	MOVW	R0,TTY$W_VB_SIZE(R7)	; SAVE FIELD SIZE
	MOVC3	R0,(R1),(R4)		; COPY TO BUFFER

	MOVZWL	TTY$Q_PB_PIC(R6),R0	; LENGTH OF PIC STRING
	MOVL	TTY$Q_PB_PIC+4(R6),R1	; GET ADDRESS
	MOVL	R9,R4			; GET START OF PICTURE FIELD ADDRESS
	MOVL	R4,TTY$L_VB_PIC(R7)	; SAVE STARTING ADDRESS
	MOVC3	R0,(R1),(R4)		; COPY DATA TO BUFFER


95$:	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS

	MOVW	R10,TTY$W_VB_BUFSIZE(R7); SAVE SIZE OF READ BUFFER
	MOVW	TTY$W_PB_TYPE(R6),-	; GET SPECIAL BITS
		TTY$W_VB_CTRL(R7)
	BICW	#^C<TTV$M_R_JUST!-	; CLEAR UNEXPECTED BITS
		TTV$M_AUTO_TAB>,-
		TTY$W_VB_CTRL(R7)	

	MOVW	TTY$W_PB_OFFSET(R6),R0	; GET OFFSET INTO FIELD
	CMPW	R0,TTY$Q_SV_INITIAL(R11); VALID?
	BGTRU	150$			; ERROR

	BBS	#TTV$V_R_JUST,TTY$W_VB_CTRL(R7),-
		110$			; SKIP IF RIGHT JUSTIFY

;
; SCAN PICTURE STRING FOR FIRST NON MARKER
;

97$:
	TSTB	@TTY$L_VB_PIC(R7)[R0]	; MARKER?
	BNEQ	98$
	INCW	R0			; POINT TO NEXT
	CMPW	R0,TTY$W_VB_SIZE(R7)	; PAST END?
	BGEQ	150$			; ERROR
	BRB	97$
98$:
	MOVW	R0,TTY$W_VB_OFFSET(R7)	; SAVE STARTING OFFSET
	MOVW	R0,IRP$W_TT_PRMPT+2(R3) ; OFFSET INTO INITIAL STRING

;
; QUEUE I/O PACKET TO UNIT
;
100$:
	MOVL	R8,IRP$Q_TT_STATE+4(R3)	; PUT STATE DATA IN PACKET
	INSV	#TTY$C_FC_READ,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3)
	JMP	G^EXE$QIODRVPKT		; INSERT PACKET ON QUEUE

;
; RIGHT JUSTIFY FIELD SPECIFIC CODE
;
110$:
	MOVW	R0,IRP$W_TT_PRMPT+2(R3)	; OFFSET INTO INITIAL STRING
	BEQL	150$
	MOVW	R0,TTY$W_VB_RSIZE(R7)	; SAVE SUBFIELD SIZE
	DECW	R0
	MOVW	R0,TTY$W_VB_OFFSET(R7)	; INTERNAL OFFSET IS ZERO BASE
	BRB	100$

;
; ERROR IN PROCESSING
;
150$:	MOVZWL	#SS$_BADPARAM,R0

200$:	JMP	G^EXE$ABORTIO		; THE I/O IS DONE


	.PAGE

VERIFY:
	PUSHL	R0
	PUSHL	R2

	MOVL	UCB$L_SVAPTE(R5),R4		; GET READ BUFFER
	MOVL	TTY$L_RB_EXTEND(R4),R2		; GET ADDRESS OF POINTER ARRAY
	BBS	#TTV$V_ESCAPE,TTY$W_VB_CTRL(R2),-; SKIP IF PROCESSING ESCAPE
		10$
	BBC	#TTV$V_R_JUST,TTY$W_VB_CTRL(R2),-; BRANCH IF LEFT JUSTIFY MODE
		LEFT_JUSTIFY
	BRW	RIGHT_JUSTIFY
10$:	BRW	ESCAPE_TERM

;
; THIS ROUTINE HANDLES LEFT JUSTIFIED FIELDS
;

LEFT_JUSTIFY:

	MOVZWL	TTY$W_VB_OFFSET(R2),R1		; GET CURRENT OFFSET INTO FIELD
	MOVZBL	@TTY$L_VB_PIC(R2)[R1],R0	; ADDRESS CORRESPONDING PIC VALUE

; Check to see if this character is valid in this position

	MOVAL	G^VERIFY_ARRAY,R4			; ADDRESS OF TABLE ENTRY
	BITB	R0,(R4)[R3]			; CHAR VALID ?
	BNEQ	10$				; YES, 
	BRW	TERM				; ELSE TERMINATOR
10$:	MOVB	R3,@TTY$L_VB_DATA(R2)[R1]	; STORE INTO READ BUFFER
20$:
	INCW	R1				; POINT TO NEXT POSITION
	CMPW	R1,TTY$W_VB_SIZE(R2)		; FIELD FULL?
	BGEQ	FULL_1				; YES, WITH SINGLE CHARACTER

; Check for trailing marker characters to be skipped

	TSTB	@TTY$L_VB_PIC(R2)[R1]		; NEXT POSITION MARKER?
	BNEQ	OUTPUT_1			; NO, OUTPUT 1 CHARACTER

	DECL	R1				; POINT TO PREVIOUS POSITION
	MOVAB	@TTY$L_VB_DATA(R2)[R1],-	; SAVE ADDRESS OF STRING TO OUTPUT
		TTY$L_VB_ADDR(R2)
	MOVZBL	#1,R0				; INIT COUNT OF CHARACTERS IN STRING
30$:
	INCL	R1				; POINT TO NEXT POSITION
	CMPW	R1,TTY$W_VB_SIZE(R2)		; FIELD FULL
	BLSS	35$				; NO
	BRW	FULL_1				; YES, SO DON'T OUTPUT
						; TRAILING MARKERS
35$:
	TSTB	@TTY$L_VB_PIC(R2)[R1]		; NEXT SLOT A MARKER
	BNEQ	45$				; NO
	INCW	R0				; COUNT MARKERS
	BRB	30$				; CONTINUE LOOKING
40$:
	MOVW	R0,TTY$W_VB_LEN(R2)		; SAVE STRING LENGTH
	BRW	FULL_S				; FIELD FULL, OUTPUT STRING
45$:
	MOVW	R0,TTY$W_VB_LEN(R2)		; SAVE STRING LENGTH
	BRW	OUTPUT_S			; OUTPUT STRING

OUTPUT_S:					; OUTPUT A STRING
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE NEW OFFSET
	MOVW	R1,UCB$W_BCNT(R5) 		; FILL REQUIRED FIELD
	MOVL	TTY$L_VB_ADDR(R2),R3		; GET ADDRESS
	MOVZWL	TTY$W_VB_LEN(R2),R2		; GET LENGTH
	BRB	EXIT

OUTPUT_1:					; OUTPUT CHARACTER IN R3
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE NEW OFFSET
	MOVW	R1,UCB$W_BCNT(R5) 		; FILL REQUIRED FIELD
EXIT:
	POPL	R4
	POPL	R0
	BBC	#TTY$V_SX_NOECHO,(R4),10$	; SKIP IF ECHOING
	CLRL	R3				; NO ECHO
10$:
	TSTL	R3				; SET CONDITION CODES
	RSB

FULL_1:						; FIELD FULL, OUTPUT SINGLE CHARACTER
	MOVL	(SP),R4				; GET STATE ADDRESS
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE NEW OFFSET
	MOVW	TTY$W_VB_SIZE(R2),UCB$W_BCNT(R5); FILL REQUIRED FIELD
	BBSS	#TTY$V_SX_EOL,(R4),5$		; SIGNAL END OF LINE
5$:	
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	CLRL	IRP$L_MEDIA(R4)			; SIGNAL NO TERMINATOR
	BRB	EXIT

FULL_S:						; FIELD FULL, OUTPUT STRING
	MOVL	(SP),R4				; GET STATE ADDRESS
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE NEW OFFSET
	MOVW	TTY$W_VB_SIZE(R2),UCB$W_BCNT(R5); FILL REQUIRED FIELD
	BBSS	#TTY$V_SX_EOL,(R4),5$		; SIGNAL END OF LINE
5$:	
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	CLRL	IRP$L_MEDIA(R4)			; SIGNAL NO TERMINATOR
	MOVL	TTY$L_VB_ADDR(R2),R3		; GET ADDRESS
	MOVZWL	TTY$W_VB_LEN(R2),R2		; GET LENGTH
	BRB	EXIT
TERM:
	MOVL	(SP),R4				; GET STATE ADDRESS
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE ENDING OFFSET
	MOVW	TTY$W_VB_SIZE(R2),UCB$W_BCNT(R5); FILL REQUIRED FIELD
	CMPB	#^X1b,R3			; ESCAPE ?
	BEQL	10$				; YES
	BBSS	#TTY$V_SX_EOL,(R4),5$		; SIGNAL END OF LINE
5$:	
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	MOVZBW	R3,IRP$L_MEDIA(R4)		; TERMINATOR
	MOVB	R3,@TTY$L_VB_PIC(R2)		; STORE IN BUFFER
	MOVW	#1,IRP$L_MEDIA+2(R4)		; TERM LENGTH
	MOVB	R1,IRP$L_MEDIA+1(R4)		; OFFSET TO INVALID CHAR
	CLRL	R3				; NO ECHO
	BRB	EXIT
;
; SIGNAL ESCAPE SEQUENCE ACTIVE
;
10$:
	BISW	#TTV$M_ESCAPE,TTY$W_VB_CTRL(R2)	; SIGNAL ACTIVE
	CLRB	UCB$B_TT_ESC(R5)		; INIT SYNTAX RULE
	BRB	5$				; SKIP SETTING END





	.PAGE

RIGHT_JUSTIFY:

	MOVZWL	TTY$W_VB_OFFSET(R2),R1		; GET CURRENT OFFSET
3$:
	MOVZBL	@TTY$L_VB_PIC(R2)[R1],R0	; GET PICTURE VALUE
	BNEQ	5$				; NOT A MARKER
	DECL	R1				; CHECK FOR END
	BGEQ	3$				; NOT YET
	CLRL	R1
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE CURRENT OFFSET
	BRW	FIELD_FULL			; FULL OF MARKERS
5$:
	MOVAL	G^VERIFY_ARRAY,R4		; CHAR VALID IN THIS POSITION?
	BITB	R0,(R4)[R3]
	BNEQ	10$				; OK
	BRW	RIGHT_TERM		
;
; SHIFT DATA IN INPUT FIELD
;
10$:
	MOVW	R1,TTY$W_VB_OFFSET(R2)		; SAVE CURRENT OFFSET
	
	MOVL	TTY$L_VB_DATA(R2),R0		; 0 OFFSET (END OF FIELD)
	CLRL	R1				; INIT DESTINATION POINTER

; FIND FIRST VALID DESTINATION

20$:
	TSTB	@TTY$L_VB_PIC(R2)[R1]		; MARKER?
	BNEQ	30$				; NO, POSITION IS OK
	INCL	R1				; LOOK FOR NEW DESTINATION
	CMPW	R1,TTY$W_VB_RSIZE(R2)		; PAST END?
	BLSSU	20$				; NO, IT IS STILL OK
	BRW	FIELD_FULL
30$:
	MOVL	R1,R4				; INIT SOURCE POINTER

; FIND NEW SOURCE

40$:
	INCL	R4
	CMPW	R4,TTY$W_VB_RSIZE(R2)		; PAST END?
	BLSSU	50$				; NO
	BRW	100$				; SHIFT COMPLETE
50$:
	TSTB	@TTY$L_VB_PIC(R2)[R4]		; MARKER?
	BEQL	40$				; YES, LOOK AGAIN
	MOVB	(R4)[R0],(R1)[R0]		; SHIFT THE DATA
	MOVL	R4,R1				; OLD SOURCE IS NEW DESTINATION
	BRB	40$

; SHIFT COMPLETE

100$:
	MOVB	R3,(R1)[R0]			; STORE NEW CHARACTER INTO
						; END POSITION
	DECW	TTY$W_VB_OFFSET(R2)		; POINT TO NEXT POSITION
	BGEQU	110$				; NOT DONE YET
	CLRW	TTY$W_VB_OFFSET(R2)
	BRB	FIELD_FULL
110$:
	BRB	RIGHT_ECHO


FIELD_FULL:
	MOVL	(SP),R4				; GET STATE ADDRESS
	MOVW	TTY$W_VB_SIZE(R2),UCB$W_BCNT(R5); FILL REQUIRED FIELD
	BBSS	#TTY$V_SX_EOL,(R4),5$		; SIGNAL END OF LINE
5$:	
	BBSS	#TTY$V_SX_ESC_O,(R4),10$	; SIGNAL ESCAPE ACTIVE
10$:
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	CLRL	IRP$L_MEDIA(R4)			; SIGNAL NO TERMINATOR

RIGHT_ECHO:
	MOVL	UCB$L_SVAPTE(R5),R3		; GET READ BUFFER
	MOVAL	TTY$L_RB_DATA(R3),R3		; ADDRESS START OF DATA
	MOVL	TTY$L_VB_DATA(R2),R1		; ADDRESS START OF INITIAL STRING
	SUBL	R3,R1				; COMPUTE LENGTH OF PROMPT
	MOVZWL	TTY$W_VB_RSIZE(R2),R2		; GET SIZE OF FIELD
	ADDL	R1,R2				; COMPUTE OUTPUT LENGTH
	BRW	EXIT				; RETURN TO CALLER


RIGHT_TERM:
	MOVL	(SP),R4				; GET STATE ADDRESS
	MOVW	TTY$W_VB_SIZE(R2),UCB$W_BCNT(R5); FILL REQUIRED FIELD
	CMPB	#^X1b,R3			; ESCAPE ?
	BEQL	10$				; YES
	BBSS	#TTY$V_SX_EOL,(R4),5$		; SIGNAL END OF LINE
5$:	
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	MOVZBW	R3,IRP$L_MEDIA(R4)		; TERMINATOR
	MOVB	R3,@TTY$L_VB_PIC(R2)		; STORE IN BUFFER
	MOVW	#1,IRP$L_MEDIA+2(R4)		; TERM LENGTH
	MOVB	TTY$W_VB_OFFSET(R2),-
		IRP$L_MEDIA+1(R4)		; OFFSET TO INVALID CHAR
	CLRL	R3				; NO ECHO
	BRW	EXIT
;
; SIGNAL ESCAPE SEQUENCE ACTIVE
;
10$:
	BISW	#TTV$M_ESCAPE,TTY$W_VB_CTRL(R2)	; SIGNAL ACTIVE
	CLRB	UCB$B_TT_ESC(R5)		; INIT SYNTAX RULE
	BRB	5$				; SKIP SETTING END


	.PAGE

ESCAPE_TERM:
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	MOVZBL	IRP$L_MEDIA+2(R4),R1		; GET CURRENT OFFSET
	INCW	IRP$L_MEDIA+2(R4)		; BUMP TERM LENGTH
	ADDW3	IRP$L_MEDIA+2(R4),-		; COMPUTE FIELD SIZE+TERM
		TTY$W_VB_SIZE(R2),R0
	CMPW	R0,TTY$W_VB_BUFSIZE(R2)		; DOES IT FIT?
	BGEQU	20$				; OVERRUN

	MOVB	R3,@TTY$L_VB_PIC(R2)[R1]	; STORE THE DATA

	BSBW	ESCSYNTAX			; PARSE ESCAPE SEQUENCE
	BGTR	10$				; SEQUENCE OK, CONTINUE
	BLSS	20$				; SEQUENCE ERROR

; SEQUENCE COMPLETED NORMALLY
	
	MOVL	(SP),R4				; GET STATE ADDRESS
	BBSS	#TTY$V_SX_EOL,(R4),5$		; SIGNAL END OF LINE
5$:	
	CLRL	R3
	BRW	EXIT


10$:
	CLRL	R3				; NO ECHO
	BRW	EXIT				; DONE


20$:						; ESCAPE SEQ ERROR
	MOVL	(SP),R4				; GET STATE ADDRESS
	BBSS	#TTY$V_SX_EOL,(R4),25$		; SIGNAL END OF LINE
25$:	
	BBSS	#TTY$V_SX_BADESC,(R4),30$
30$:
	CLRL	R3
	BRW	EXIT


	.PAGE
	.SBTTL	ESCSYNTAX -- CHECK ESCAPE SEQUENCE SYNTAX

;++
; FUNCTIONAL DESCRIPTION:
;	This routine checks the syntax of escape sequences, one
;	character at a time.
;
; INPUTS:
;	R3 contains the next character to be checked for correct syntax
;	UCB$B_TT_ESC(R5) contains a offset to the next syntax
;		rule in the TTY$A_ESCAPE syntax table
;	Assume R4 is available
;
; OUTPUTS:
;	Condition codes are set:
;	CC = POSITIVE means the character is syntactically correct
;	CC = EQUAL means syntactic correctness and sequence is complete
;	CC = NEGATIVE means error in parsing sequence
;
;	If CC = POSITIVE the UCB$B_TT_ESC offset is updated.
;--
ESCSYNTAX:
	MOVZBL	UCB$B_TT_ESC(R5), R4	; get syntax rule
10$:	CMPB	R3, W^TTY$A_ESCAPE[R4]	; check range of character
	BLSSU	20$			; branch if not this rule
	CMPB	R3, W^TTY$A_ESCAPE+1[R4]; lower than high limit?
	BGTRU	20$			; look to next rule
	MOVB	W^TTY$A_ESCAPE+2[R4],-	; character is valid
		UCB$B_TT_ESC(R5)	; save offset to next rule
	RSB				; offset=POS => next rule exists
					; offset=0 => end of sequence
;
; Continue looking for correct sequence rule
;
20$:	TSTB	W^TTY$A_ESCAPE+2[R4]	; any next rule?
	BEQL	30$			; no; bad syntax
	ADDL	#3, R4			; offset to next rule
	BRB	10$			; continue syntax check
30$:	MNEGL	#1, R4			; error in sequence
	RSB

	.PAGE
	.SBTTL	ESCAPE SYNTAX TABLE
;
; ESCAPE SYNTAX TABLE
;
TTY$A_ESCAPE::				; ESCAPE SYNTAX TABLE
;
; ESCAPE SEQUENCE <ESC><;><32:47>....<48:126>
;
	.ASCII	/;;/			; ";"
	.BYTE	10$-TTY$A_ESCAPE	;
;
; ESCAPE SEQUENCE <ESC><?><32:47>....<48:126>
;
	.ASCII	/??/			; "?"
	.BYTE	10$-TTY$A_ESCAPE	;
;
; ESCAPE SEQUENCE <ESC><O><32:47>....<64:126>
;
	.ASCII	/OO/			; "O"
	.BYTE	20$-TTY$A_ESCAPE	;
;
; ESCAPE SEQUENCE <ESC><Y><32:126><32:126>
;
	.ASCII	/YY/			; "Y"
	.BYTE	30$-TTY$A_ESCAPE	;
;
; ANSI CONTROL SEQUENCES <ESC><[><48:63>...<32:47>...<64:126>
;
	.ASCII	/[[/			; "["
	.BYTE	15$-TTY$A_ESCAPE

;
; ESCAPE SEQUENCE <ESC><32:47>....<48:126>
;
10$:	.ASCII	! /!			; SPACE TO "/"
	.BYTE	10$-TTY$A_ESCAPE	; INTERMEDIATE CHARACTER
	.ASCII	/0/<126>		; "0" TO END
	.BYTE	0			; FINAL
15$:	.ASCII	/0?/			; "0" TO "?"
	.BYTE	15$-TTY$A_ESCAPE
20$:	.ASCII	! /!			; SPACE TO "/"
	.BYTE	20$-TTY$A_ESCAPE
	.ASCII	/@/<126>		; "@" TO END
	.BYTE	0			; END OF ESC O.
30$:	.ASCII	! !<126>		; SPACE TO END
	.BYTE	40$-TTY$A_ESCAPE
40$:	.ASCII	! !<126>		;
	.BYTE	0			;
;
; ESCAPE SEQUENCES WITH MEANING FOR OUTPUT
;
; THERE IS A CORRELATION BETWEEN THIS TABLE AND CODE!
;
TTY$A_ESC_OUT::
	.ASCIC	/ABCDHIYFGKZ>=\[/		;



TT_END:
	.END
