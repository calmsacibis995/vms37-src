	IDENT	0001,DMPBLK,<FORMAT DATA BLOCK>
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN 30-MARCH-73
;

; THE FUNCTION OF THIS ROUTINE IS TO
; DUMP A 256. WORD BLOCK FROM INBUF TO FDBOUT
	.SBTTL	DMPBLK, DMPBYT, BYTOUT, EDPUT, ERRPT0
DMPBLK::
	MOV	#INBUF,R2	;DUMP IN WORD MODE
	MOV	IOSTBK+2,R5	; GET BYTE COUNT
	ADD	#15.,R5		; ROUND UP TO ONE LINE
	ASR	R5		; COMPUTE LINE COUNT
	ASR	R5
	ASR	R5
	ASR	R5
	BEQ	35$		; IF EQ PRINT NOTHING
 
	BIT	#HEXBIT,DMPCTL	; DUMPING HEX?
	BNE	40$		; IF NE THEN YES
	BIT	#R50BIT,DMPCTL	;***HBB1 SKIP BYTE CHECK IF RAD50
	BNE	20$		;***HBB1 IF NE THEN YES
	BIT	#BYTBIT,DMPCTL
	BNE	DMPBYT		;BRANCH IF BYTE MODE

20$:	MOV	BYTNUM,-(R2)	;STORE LINE NUMBER BEFORE DATA
	ADD	#20,BYTNUM
	MOV	#FM04MG,R1	;***HBB1 ASSUME OCTAL
	BIT	#R50BIT,DMPCTL	;***HBB1 IS IT REALY RAD50
	BEQ	30$		;***HBB1 BR IF NO
	MOV	#FM06MG,R1	;***HBB1 SET UP RAD50 CMD LINE
	BR	31$		;***RJH SET UP FOR DECIMAL
30$:				;***HBB1
	BIT	#DECBIT,DMPCTL	;***RJH DECIMAL?
	BEQ	31$		;***RJH NO? -- STILL OCTAL
	MOV	#FM07MG,R1	; SET DECIMAL STRING
31$:	CALL	EDPUT
	ADD	#18.,R2		;POINT AT NEXT SET OF DATA
	SOB	R5,20$
35$:	RETURN
40$:	JMP	HEXDMP		;***RJH ENTER HEX DMP CONTROL
;
; DUMP A 256 WORD BLOCK IN BYTE MODE
DMPBYT::
	MOV	R2,R3		; CROCK!!!!!!!!!!!
10$:	MOV	FDBOUT+F.NRBD+2,R0
	MOV	#FM05MG,R1
	MOV	#BYTNUM,R2
	CALL	$EDMSG
	ADD	#16.,BYTNUM
	MOV	#16.,R4		;16 BYTES PER LINE
20$:	MOVB	(R3)+,R1
	CALL	BYTOUT
	SOB	R4,20$
	MOV	R0,R1
	SUB	FDBOUT+F.NRBD+2,R1
	PUT$	#FDBOUT,,R1,WRTERR
	SOB	R5,10$		;DON THE NEXT LINE IF ANY
	RETURN

; TRANSLATE THE BYTE IN R1 TO THE STRING IN R0
BYTOUT::	BIC	#177400,R1	;CLEAR HIGH ORDER BITS
	BIT	#ASCBIT!HEXBIT,DMPCTL	; ASCII OR HEX FORMAT?
	BNE	BYTASC		;BRANCH IF YES
	CALL	BYTOU2		;1ST 2 BITS TO OCTAL DIGIT
	CALL	BYTOU1		;2ND OCTAL DIGIT
	CALL	BYTOU1		;3RD OCTAL DIGIT
	MOVB	#' ,(R0)+
	RETURN
;
; ASCII MODE, CONTROL CHARS BECOME ^ FOLLOWED BY LETTER (CHAR+100)
; LOWER CASE BECOME % FOLLOWED BY LETTER (CHAR-40)
BYTASC::	MOVB	#' ,(R0)+
18$:	BIC	#177600,R1	; REMOVE GARBAGE
	CMPB	#40,R1		; CONTROL CHARACTER?
	BLOS	20$
	ADD	#100,R1		;CONTROL CHARACTER
	MOVB	#'^,(R0)+
	BR	40$
20$:	CMPB	#140,R1		;LOWER CASE?
	BHI	30$		;BRANCH IF PRINTABLE CHARACTER
	SUB	#40,R1		;LOWER CASE CHARACTER
	MOVB	#'%,(R0)+
	BR	40$
30$:	MOVB	#' ,(R0)+
40$:	MOVB	R1,(R0)+	;STORE CHARACTER
	RETURN
;
; OUTPUT BYTE IN OCTAL
BYTOU1:	ASL	R1
BYTOU2:	ASL	R1
	ASL	R1
	SWAB	R1
	ADD	#'0,R1
	MOVB	R1,(R0)+
	CLRB	R1
	SWAB	R1
	RETURN

;
; HEX DMP ROUTINES
;
;	R2= ADDRESS OF INPUT BUFFER
;	R5= NUMBER OF LINES TO OUTPUT
;
HEXDMP:
	MOV	FDBOUT+F.NRBD+2,R0; GET ADDRESS OF OUTPUT BUF
	MOV	#DIGITS,R4	; ADDRESS ADDRESS OF CONVERT ROUTINE
	MOV	#43.,-(SP)	; SET DEFAULT FOR LINE END
	BIT	#LNGBIT,DMPCTL	; LONG WORD?
	BNE	10$		; IF NE THEN YES
	MOV	#47.,@SP	; WORD?
	BIT	#WRDBIT,DMPCTL	; IF NE THEN WORD SET MODE
	BNE	10$		; IF NE THEN YES
	MOV	#55.,@SP	; ELSE BYTE
10$:	MOVB	BYTNUM,R1	; OUTPUT LINE BYTE NUMBER
	ADD	@SP,R0		; POINT TO END OF LINE
	CALL	@R4		; CONVERT TWO DIGITS
	MOVB	BYTNUM+1,R1	; OUTPUT NEXT TWO
	CALL	@R4		;
	MOVB	#11,-(R0)
	MOV	#16.,R3		; SET NUMBER OF BYTES TO OUTPUT
	ADD	R3,BYTNUM	; UPDATE BYTE NUMBER
50$:	MOVB	(R2)+,R1	; GET BYTE
	CLR	-(SP)		; SET FLAG FOR SPACE ON EVERY BYTE
	BIT	#LNGBIT,DMPCTL	; LONG WORD?
	BEQ	55$		; IF EQ THEN NO
	MOV	#3,@SP		; SET LONG WORD SPACE MASK
	BR	60$
55$:	BIT	#WRDBIT,DMPCTL	; WORD?
	BEQ	60$		; IF EQ THEN NO
	MOV	#1,@SP		; SET WORD MASK
60$:	BIT	(SP)+,R3	; SET IF SPACE IS NEEDED
	BNE	65$		; IF NE THEN NO
	MOVB	#40,-(R0)	; INSERT SPACE
65$:	CALL	@R4		; OUTPUT IT
	SOB	R3,50$		; OUTPUT 16. BYTES
	MOV	(SP)+,R1	; GET SIZE OF LINE
	MOVB	#12,-(R0)	; INSERT NEW LINE
	MOVB	#15,-(R0)	;
	PUT$	#FDBOUT,,R1,WRTERR; OUTPUT STRING
	DEC	R5
	BNE	HEXDMP
	RETURN
DIGITS:	BIC	#177400,R1	; RESET UPPER BYTE
	ASL	R1		; SEPARATE DIGIT FIELDS
	ASL	R1
	ASL	R1
	ASL	R1
	CLC
	RORB	R1
	RORB	R1
	RORB	R1
	RORB	R1
	CALL	@PC		; DO TWO DIGITS
	MOV	#48.,-(SP)	; SET FIRST DISPLACEMENT
	CMPB	R1,#9.		; IF LE THAN 9 THEN OK
	BLE	10$		; BR IF LE
	MOV	#55.,@SP	; RESET DISPLACEMENT
10$:	ADD	(SP)+,R1	; DISPLACE CHARACTER
	MOVB	R1,-(R0)	; INSERT CHARACTER IN OUTPUT
	SWAB	R1		; OUTPUT OTHER CHAR NEXT TIME THROUGH
	RETURN
	.END
