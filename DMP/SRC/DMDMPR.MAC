	IDENT	0004.2,DMDMPR,<DUMP MAIN PROGRAM>
; ALTERED:
; ANDREW C. GOLDSTEIN  2 APR 75  12:59
; ALTERED WEDNESDAY 30-JAN-74 21:10
; ALTERED 10-MAR-76 H.B. BOSWELL  ADD RAD50 MODE DUMP  HBB1
; ALTERED 4/1/76 R.HEINEN ADD HEX DUMP SWITCH /HX/LW/WD
; ALTERED 4/10/76 R.HEINEN ADD RECORD DMP MODE /RC
; ALTERED 9/3/76 R.HEINEN FIX LONG TIME BUG IN IE.VER DETECTION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN 30-MARCH-73
; 23-JUL-74 R.HEINEN FOR RSX11M
;	16-SEPT-77  G.RITTENBURG
;
;	GR001	EXIT WITH STATUS ADDED
;
;	23-SEPT.-77 G.RITTENBURG
;
;	GR002----SOB INSTRUCTION REMOVED
;
;	PAUL KOBAR	10-AUG-78
;		PK001 -- ADDED CODE FOR /HD VALUES AND /HF SWITCH
;
;

	.SBTTL	DUMP THE DESIRED BLOCKS OF THE FILE
;
; DUMP THE NEXT BLOCK

	PURE.I

	.ENABL	LSB

NXTBLK::	MOV	#INBUF,R1	;ZERO THE BUFFER
	MOV	.WORDS,R2	;SINCE PRINTING ENTIRE BUFFER 
10$:	CLR	(R1)+		;EVEN IF SHORT BLOCK WAS READ
	SOB	R2,10$
	MOV	#FDBIN,R0
	BIT	#LBNBIT,DMPCTL	;LOGICAL BLOCKS?
	BEQ	20$		;BRANCH IF VIRTUAL BLOCKS
;
; DO LOGICAL I/O
	MOV	BLKNUM,LBN	; SET BLOCK NUMBERS
	MOV	BLKNUM+2,LBN+2
	MOV	#IO.RLB,R1
	MOV	#5,R2
	MOV	#READLB,R3
	CALL	.XQIO		;READ THE NEXT LOGICAL BLOCK
	MOV	@#.FSRPT,R2
	MOV	A.IOST+2(R2),IOSTBK+2
	BCS	29$		; BRANCH ON ERROR
	BR	30$
;
; READ VIRTUAL BLOCKS FROM SPECIFIED FILE
;
20$:	BIT	#RECBIT,DMPCTL	; RECORD I/O
	BEQ	28$		; IF NE THEN YES
	GET$S	R0		; GET THE RECORD
	BCS	29$		; IF C-SET THEN CHECK EOF CONDITION
	MOV	F.NRBD(R0),IOSTBK+2; INIT BYTE COUNT TO DMP
	BIT	#3,RECNUM	; OUTPUT HEADR EVERY 4 LINES
	BNE	21$		; IF NE THEN NO HEADER
	PUT$	#FDBOUT,#HEADER,HEADSZ,WRTERR
21$:	MOV	#MOPRM,R2	; ADDRESS EDMSG PARAM BLOCK
	MOV	#FM03SZ,@R2	; SET UP RECORD NUMBER MESSAGE
	MOV	#FM03MG,2(R2)	;
	MOV	RECNUM+2,4(R2)	; INSERT RECORD NUMBER
	MOV	RECNUM,6(R2)	;
	ADD	#1,RECNUM	; INCREMENT RECORD NUMBER
	CMP	#10000.,RECNUM	; 10000. ?
	BNE	22$		; IF NE THEN OK
	CLR	RECNUM		; RESET RECORD NUMBER
	INC	RECNUM+2
22$:	MOV	IOSTBK+2,10(R2); INSERT RECORD SIZE
	MOV	#RCNOMG,R1	; SET MESSAGE TO PRINT
	CALL	EDPUT		; OUTPUT MESSAGE
	CLR	BYTNUM		; RESET BYT NUMBER
	CALL	DMPBLK		; DUMP THE BLOCK
	PUT$	#FDBOUT,#HEADER+1,#4,WRTERR
	JMP	NXTBLK		; DMP THE NEXT RECORD
28$:	READ$	R0		;READ THE NEXT BLOCK
	BCS	CKEOF		;BRANCH IF QI/O ERROR
	WAIT$	R0		;WAIT FOR I/O DIONE
29$:	BCS	CKEOF		;BRANCH IF ERROR
;
; NOW WRITE THE PAGE HEADER
30$:	PUT$	#FDBOUT,#HEADER,HEADSZ,WRTERR
	MOV	#MOPRM,R2	;R2=ADDRESS OF PARAM BLOCK
	MOV	#FM03SZ,@R2	;SET UP BLOCK NO. MESSAGE
	MOV	#FM03MG,2(R2)
	MOV	BLKNUM,4(R2)	; INSERT BLOCK NUMBERS IN PARAMS
	MOV	BLKNUM+2,6(R2)
	INC	FBLOCK
	ADD	#1,BLKNUM+2	; INCREMENT BLOCK NUMS
	ADC	BLKNUM
	MOV	IOSTBK+2,10(R2)
	MOV	#VBNOMG,R1	;SAY "VIRTUAL BLOCK"
	BIT	#LBNBIT,DMPCTL	;UNLESS LOGICAL BLOCK MODE
	BEQ	40$
	MOV	#LBNOMG,R1	;USE "LOGICAL BLOCK"
40$:	CALL	EDPUT
	CMPB	#IE.VER,FDBIN+F.ERR ; SEE IF THERE WAS A PARITY ERROR
	BNE	50$		; NO
	PUT$	#FDBOUT,#BADPMG,#BADPSZ,WRTERR ; OUTPUT MESSAGE
50$:	BIT	#MDBIT,DMPCTL	;UNLESS IN MEMORY DUMP MODE
	BNE	60$
	CLR	BYTNUM		; RESET BYTE NUMBER
60$:	BIT	#HFBIT,DMPCT2	;HEADER FORMAT?			
	BEQ	62$						
	CMP	#000401,INBUF+H.FLEV	;IS IT FILES11?		
	BNE	62$			;IF NOT,DUMP AS BLOCK	
	MOV	#INBUF,R0	;HEADER MODE			
	MOV	#MOPRM,R1	;BUFFER FOR $EDMSG		
	CALL	DMPHDR						
	BR	65$						
62$:	CALL	DMPBLK		;BLOCK MODE			
65$:	CMPB	#IE.EOT,FDBIN+F.ERR ; SEE IF WE ARE AT END OF TAPE	
	BNE	70$		; NO
	PUT$	#FDBOUT,#EOT1MG,#EOT1SZ,WRTERR ; OUTPUT MESSAGE
80$:	JMP	RSTART
70$:	CMP	FBLOCK,LBLOCK	;DONE ALL BLOCKS?
	BHI	80$
130$:	JMP	NXTBLK		;BRANCH IF MORE TO DO
;
; ERROR READING INPUT FILE - PROBABLY EOF
CKEOF::	CMPB	#IE.EOF,F.ERR(R0)
	BEQ	110$
	CMPB	#IE.EOT,F.ERR(R0) ; SEE IF AT END OF TAPE
	BEQ	30$		; IF SO, IGNORE FOR NOW
	CMPB	#IE.VER,F.ERR(R0) ; LIKEWISE FOR PARITY ERROR
	BNE	90$		; NEITHER
	MOV	#512.,IOSTBK+2	; FAKE A BYTE COUNT OF 512
	BR	30$		; AND DUMP IT ANYWAY
90$:	ERROUT	ER09,0,0	;I/O ERROR
	MOV	#2,.EXSTS	;FATAL ERROR
100$:	JMP	RSTART

110$:	PUT$	#FDBOUT,#EOF1MG,#EOF1SZ,WRTERR
	INC	FBLOCK		;COUNT EOF AS LOGICAL BLOCK
	BIT	#LBNBIT,DMPCTL
	BEQ	100$
	BITB	#FD.SQD,FDBIN+F.RCTL ; CHECK IF SEQ DEVICE (MAGTAPE)
	BEQ	100$		; QUIT IF NOT
	JMP	NXTBLK

;
; ERROR WRITING LISTING FILE
WRTERR::	ERROUT	ER10,0,0
	MOV	#2,.EXSTS	;FATAL ERROR
	JMP	RSTART

	.DSABL	LSB
	.END
