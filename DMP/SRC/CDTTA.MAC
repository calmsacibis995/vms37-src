	.TITLE	$CDTTA - CONVERT DATE AND TIME TO ASCII

	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  20 JUN 76  14:12

	SMACIT

	.MACRO	$SAVRG
	JSR	R5,$SAVRG
	.ENDM	$SAVRG



	.MACRO	.QUAD	WORD
	$$$B1=0
	$$$B2=0
	$$$B3=0
	$$$B4=0
	$$$B5=0
	$$$B6=0
	$$$B7=0
	$$$B8=0
	.IRPC	D,WORD
	$$$B1=$$$B1*10.+D'.
	$$$C=$$$B1/256.
	$$$B1=$$$B1&^O377
	$$$B2=$$$B2*10.+$$$C
	$$$C=$$$B2/256.
	$$$B2=$$$B2&^O377
	$$$B3=$$$B3*10.+$$$C
	$$$C=$$$B3/256.
	$$$B3=$$$B3&^O377
	$$$B4=$$$B4*10.+$$$C
	$$$C=$$$B4/256.
	$$$B4=$$$B4&^O377
	$$$B5=$$$B5*10.+$$$C
	$$$C=$$$B5/256.
	$$$B5=$$$B5&^O377
	$$$B6=$$$B6*10.+$$$C
	$$$C=$$$B6/256.
	$$$B6=$$$B6&^O377
	$$$B7=$$$B7*10.+$$$C
	$$$C=$$$B7/256.
	$$$B7=$$$B7&^O377
	$$$B8=$$$B8*10.+$$$C
	$$$C=$$$B8/256.
	$$$B8=$$$B8&^O377
	.ENDM
	$$$W1=$$$B2*256.+$$$B1
	$$$W2=$$$B4*256.+$$$B3
	$$$W3=$$$B6*256.+$$$B5
	$$$W4=$$$B8*256.+$$$B7
	.LIST	MEB
	.WORD	$$$W1,$$$W2
	.WORD	$$$W3,$$$W4
	.NLIST	MEB
	.ENDM	.QUAD

;
; SOME CONSTANTS
;

	.RADIX	10

QNS:	.QUAD	10000000	; TENTHS OF MICROSECONDS IN A SECOND
QND:	.QUAD	864000000000	; TENTHS OF MICROSECONDS IN A DAY

FDAYS = 365*4+1			; NUMBER OF DAYS IN 4 YEARS
				; AND NUMBER OF QUARTER DAYS IN A YEAR
CDAYS = FDAYS*25-1		; NUMBER OF DAYS IN A CENTURY
QDAYL = 15025			; NUMBER OF DAYS IN QUADRICENTURY, LOW
QDAYH = 2			; NUMBER OF DAYS IN QUADRICENTURY, HIGH
DS15L = 65176			; NUMBER OF DAYS BETWEEN 1-JAN-1501 AND
DS15H = 1			; 17-NOV-1858, LOW AND HIGH


	.RADIX

;+
;
; *** - $CDTTA	CONVERT DATE/TIME TO ASCII
;
; THIS ROUTINE CONVERTS THE STANDARD DATE/TIME REPRESENTATION INTO
; AN ASCII STRING. THE FORMATTING OF THE STRING IS CONTROLLED BY
; OPTION BITS ON INPUT.
;
; INPUTS:
;
;	R0 = ADDRESS TO STORE ASCII STRING
;	R1 = ADDRESS OF 64 BIT DATE/TIME
;	R2 = OPTION FLAGS:
;	   BIT 0 = 1 IF DATE NOT WANTED
;	   BIT 1 = 1 IF TIME NOT WANTED
;	   BIT 2 = 1 IF TIME WANTED IN AM/PM
;	   BIT 3 = 1 IF SECONDS NOT WANTED
;
; OUTPUTS:
;
;	R0 UPDATED TO END OF GENERATED STRING
;	OTHER REGISTERS PRESERVED
;
; THE DATE ALGORITHM BELOW ACCOUNTS FOR THE COMMON LEAP YEAR CYCLES -
; EVERY FOURTH YEAR IS, EXCEPT EVERY 100TH ISN'T, EXCEPT EVERY 400TH
; IS. YEAR 2000 IS A LEAP YEAR. THE CODE IS BASED ON ALGORITHMS
; WRITTEN BY PETER CONKLIN, JOHN BARNABY, DAVID ROSENBERG, AND MIKE SPEIR.
;
;-

$CDTTA::
	$SAVRG				; SAVE ALL REGISTERS
	PUSH R1,R2
	LET R5 := R0
	LET SP := SP - #16.		; ALLOCATE TWO QUAD SLOTS
	LET R3 := SP + #8.
	$CALL $DIVQ <#QND,R1,SP,R3>	; SPLIT DATE/TIME INTO DAY AND TIME
;
; TOP OF STACK CONTAINS DAYS SINCE 17-NOV-1858. CONVERT THIS TO A
; REAL DATE.
;
	IF #1 OFF.IN 16.(SP)		; DO IF DATE REQUESTED
	  LET R3 := (SP)		; DAY SINCE 17-NOV-1858 IS
	  LET R2 := 2(SP)		; LESS THAN 32 BITS
	  				; ADD THE OFFSET SO WE HAVE THE NUMBER
	  				; OF DAYS SINCE 1-JAN-1501. THIS ALIGNS
	  				; LEAP YEAR CYCLES SO THAT THE SUBSEQUENT
	  				; TRUNCATIONS AND ROUND-OFFS WORK.
	  LET R3 := R3 + #DS15L
	  LET R2 := R2 + CARRY + #DS15H
	  				; DIVIDE BY THE NUMBER OF DAYS IN
	  				; A QUADRICENTURY
	  $CALL $DIVD <#QDAYH,#QDAYL,R2,R3>
	  				; R0,R1 = DAYS INTO THIS QUADRICENTURY
	  				; R3 = QUADRICENTURIES SINCE 1501
	  LET R3 := R3 L.SHIFT 2	; CONVERT TO CENTURIES
	  PUSH R3			; AND SAVE
	  ASL R1			; CONVERT NUMBER OF DAYS INTO
	  ROL R0			; NUMBER OF QUARTER DAYS
	  ASL R1			; BY MULTIPLYING BY 4
	  ROL R0
	  LET R3 := R1
	  LET R2 := R0
	  				; DIVIDE BY THE AVERAGE NUMBER OF
	  				; QUARTER DAYS IN A CENTURY
	  $CALL $DIVD <#QDAYH,#QDAYL,R2,R3>
	  				; R0,R1 = QUARTER DAYS INTO CENTURY
	  				; R3 = CENTURIES IN THIS QUAD CENTURY
	  LET (SP) := (SP) + R3		; ADD TO ACCUMULATED TIME
;
; BY BASING THE TIME AT 1501, WE HAVE PLACED THE CENTURY WITH THE EXTRA
; LEAP DAY INTO THE FIRST CENTURY OF THE QUADRICENTURY. NOW DISCARD ANY
; FRACTION OF A DAY LEFT FROM THE PREVIOUS DIVISION AND ADD IN 3/4
; OF A DAY TO FORCE THE LEAP YEAR INTO THE LAST YEAR OF EACH 4 YEAR
; CYCLE.
;
	  LET R1 := R1 SET.BY #3
	  LET R3 := R1			; NOW DIVIDE BY THE AVERAGE NUMBER OF
	  LET R2 := R0			; QUARTER DAYS IN A YEAR
	  $CALL $DIVD <#0,#FDAYS,R2,R3>
	  LET R2 := R1 R.SHIFT 2 + #1	; NUMBER OF DAY IN YEAR
	  $CALL $MUL <#100.,(SP)+>	; COMPUTE # YEARS IN CENTURIES
	  LET R1 := R1 + R3 + #1501.	; COMPUTE TRUE CALENDAR YEAR
	  PUSH R1			; SAVE FOR FINAL OUTPUT
;
; FIND OUT WHETHER THIS YEAR IS A LEAP YEAR. IF NOT, BIAS THE DAY IF
; IT IS PAST FEBRUARY SINCE THE MONTH TABLE IS WRITTEN FOR A LEAP YEAR.
;
	  LET R4 := #1			; INIT LEAP YEAR FLAG TO NO
	  $CALL $DIV <(SP),#400.>	; EVERY 400TH IS A LEAP YEAR
	  IF R1 EQ #0
	    LET R4 := #0
	  ELSE
	    $CALL $DIV <(SP),#100.>	; EVERY 100TH IS NOT
	    IF R1 NE #0
	      $CALL $DIV <(SP),#4>	; AND EVERY 4TH IS
	      IF R1 EQ #0 THEN LET R4 := #0
	    END
	  END
	  				; IF THIS IS NOT A LEAP YEAR,
	  				; BIAS THE DAY UP ONE IF IT IS
	  				; PAST FEBRUARY.
	  IF R2 HI #31.+28. THEN LET R2 := R2 + R4
;
; SCAN THE MONTH TABLE AND FIND OUT WHAT MONTH THIS IS.
;
	  FOR R1 := #0 TO #11.
	    LET R0 :B= $DAYTB(R1)	; GET NUMBER OF DAYS IN MONTH
	    IF R2 LOS R0 LEAVE LOOP
	    LET R2 := R2 - R0
	  END LOOP
;
; R2 = DAY, R1 = MONTH
; START TO CRANK OUT THE ASCII DATE
;
	  PUSH R1
	  $CALL $CBDMG <R5,R2,#0>	; DAY NUMBER
	  LET (R0)+ :B= #'-		; DASH
	  				; INDEX INTO THE MONTH NAME TABLE
	  LET R1 := (SP) L.SHIFT 1 + (SP)+ + #$MONTB
	  LET (R0)+ :B= (R1)+		; FILL IN MONTH NAME
	  LET (R0)+ :B= (R1)+
	  LET (R0)+ :B= (R1)+
	  LET (R0)+ :B= #'-		; DASH
	  $CALL $CBDMG <R0,(SP)+,#0>	; ADD YEAR
	  LET (R0)+ :B= #40		; AND A SPACE
	  LET R5 := R0			; SAVE THE POINTER WHILE WE MESS
	END  				; WITH THE TIME OF DAY
;
; NOW CONVERT THE TIME OF DAY TO ASCII
;
	IF #2 OFF.IN 16.(SP)		; DO IF TIME REQUESTED
	  LET R1 := SP + #8.		; POINT TO TIME ON STACK
	  LET R3 := SP
	  LET SP := SP - #8.		; ALLOCATE ONE MORE QUAD
	  $CALL $DIVQ <#QNS,R1,SP,R3>	; REDUCE TO TIME IN SECONDS
	  POP R3,R2			; WHICH IS EXPRESSIBLE IN 32 BITS
	  CMP (SP)+,(SP)+		; CLEAN GARBAGE FROM STACK
	  $CALL $DIVD <#0,#60.,R2,R3>	; DIVIDE OUT SECONDS
	  PUSH R1			; AND SAVE THEM
	  $CALL $DIVD <R0,#60.,R2,R3>	; DIVIDE OUT MINUTES
	  PUSH R1			; AND SAVE
	  $CALL $DIVD <R0,#24.,R2,R3>	; AND DIVIDE OUT HOURS
	  				; OUTPUT ASCII TIME OF DAY
	  $CALL C2D <R1>
	  LET (R5)+ :B= #':
	  $CALL C2D <(SP)+>
	  POP R0			; GET SECONDS
	  IF #10 OFF.IN 16.(SP)		; IF SECONDS WANTED
	    LET (R5)+ :B= #':
	    $CALL C2D <R0>
	  END
	  LET R0 := R5			; RETURN FINAL STRING POINTER
	END
	LET SP := SP + #16.		; FINAL STACK CLEANUP
	POP R2,R1
	RETURN

;+
;
; *** - C2D	CONVERT BINARY TO 2 DECIMAL DIGITS
;
; THIS ROUTINE IS USED TO OUTPUT THE COMPONENTS OF THE TIME
;
; INPUTS:
;
;	R0 = BINARY VALUE
;
; OUTPUTS:
;
;	TWO DIGITS STORED AT R5
;	R5 BUMPED BY 2
;	R0,R1 CLOBBERED
;
;-

C2D:	
	$CALL $DIV <R0,#10.>		; SPLIT THE DIGITS
	LET R0 := R0 + #'0		; CONVERT TO ASCII
	LET R1 := R1 + #'0
	LET (R5)+ :B= R0		; AND STORE
	LET (R5)+ :B= R1
	RETURN



	.END
