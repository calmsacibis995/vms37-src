	IDENT	0004.3,DMPSTP,<DMP SETUP ROUTINES>
; ALTERED:
; ANDREW C. GOLDSTEIN  5 NOV 76  16:53
; ALTERED WEDNESDAY 30-JAN-74 21:10
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN 30-MARCH-73
; FOR RSX11M 20-JUL-74 R.HEINEN
; ALTERED 4/1/76 R.HEINEN ADD HEX DMP /HX/LW/WD
; ALTERED 4/10/76 R.HEINEN ADD RECORD MODE DMP /RC
;	25-JUL-77 G.RITTENBURG
;
;	GR001	TAPE DENSITY SWITCH ADDED
;
;	16-SEPT-77 G.RITTENBURG
;
;	GR002	EXIT WITH STATUS ADDED
;
;	23-SEPT.-77 G.RITTENBURG
;
;	GR003----ATTACH DEVICE IF LP: OR TI:
;
;	GR004---G.RITTENBURG 22-JUN-1978
;	REWIND SWITCH ADDED
;
; 	GR005---G.RITTENBURG 20-JUL-78
;	CORRECTION TO ATTACH DEVICE CODE
;
;
	.MCALL	FDBK$R,FDBF$R

	PURE.I

;
; GOT A COMMAND, CHECK IT'S SYNTAX
CHECK::	CSI$1	#CSIBLK,GCMLCB+G.CMLD+2,GCMLCB+G.CMLD
	MOV	C.CMLD(R0),GCMLCB+G.CMLD
	BCC	T25
	CALL	.SYNER		; SEND SYNTAX ERROR
	MOV	#2,.EXSTS	;FATAL ERROR
AGAI:	JMP	AGAIN

; GOT A SYNTACTICALLY CORRECT COMMAND LINE
; NOW GET THE INPUT SPEC AND OPEN THE FILE
T25:	MOV	#IFNPT,R1
	CALL	INCSI		;GET THE INPUT SPEC
	BCS	32$
	MOV	#OFNPT,R1
	CALL	OUTCSI		;GET THE OUTPUT SPEC
	BCS	32$
	BIT	#CS.MOR!CS.WLD,INSPEC
	BNE	30$
	BIT	#CS.MOR!CS.WLD,OUSPEC
	BNE	30$
	BIT	#RECBIT,DMPCTL	; CHECK ILLEGAL /RC SWITCH
	BEQ	35$		; IF EQ THEN OK
	BIT	#BLBIT,DMPCTL	; BLOCKS SPECIFIED?
	BEQ	35$		; IF EQ THEN OK
	ERROUT	ER16
	MOV	#2,.EXSTS	;FATAL ERROR
	BR	AGAI		; ISSUE ERROR
;
; NO WILD CARDS OR LISTS ALLOWED IN INPUT OR OUTPUT SPEC
30$:	ERROUT	ER08
	MOV	#2,.EXSTS	;FATAL ERROR
	BR	AGAI
;
; BAD SWITCH OR VALUE ERROR FROM CSI$2
32$:	ERROUT	ER07
	MOV	#2,.EXSTS	;FATAL ERROR
	BR	AGAI
;
; NO ILLEGAL SWITCHESPRESENT
35$:	BIT	#IDBIT,DMPCTL	;TYPE THE IDENT MESSAGE?
	BEQ	37$
	ERROUT	IDNT		;YES
	BR	AGAI
;
37$:	BIT	#BABIT,DMPCTL	; IF /BA SPEC THEN ACCEPT VALUES
				; AND GO ON
	BNE	AGAI
	TST	INSPEC
	BNE	40$
	ERROUT	ER14		;NO INPUT FILE SPECIFIED
	MOV	#2,.EXSTS	;FATAL ERROR
	BR	AGAI
40$:	
	MOV	#FDBIN,R0
	FDRC$R	R0,#FD.RWM		; ASSUME READ/WRITE
	FDBK$R	R0,#INBUF,#512.,,,#IOSTBK;
;
; PARSE THE DEVICE NAME FIRST
;
	MOV	#FDBIN+F.FNB,R1
	MOV	F.DSPT(R0),R2
	MOV	F.DFNB(R0),R3
	CALL	.PRSDV		;PARSE THE DEVICE NAME AND UNIT
	BCC	63$
	ERROUT	ER12		;BAD DEVICE NAME
	MOV	#2,.EXSTS	;FATAL ERROR
	JMP	AGAI
63$:	BITB	#FD.SQD!FD.REC,F.RCTL(R0) ; SEQUENTIAL DEVICE?
	BEQ	48$		; IF EQ THEN NO
64$:	MOV	R2,-(SP)	; SAVE R2
	MOV	R1,-(SP)	; SAVE R1
	BIT	#RWBIT,DMPCT2	; TEST FOR REWIND
	BEQ	65$		; NO,TEST FOR PE
	MOV	#IO.RWD,R1	; SET FOR REWIND
	CLR	R2		; NO OPTIONAL PMTRS
	CALL	.XQIO		; EXECUTE REWIND
65$:	BIT	#PEBIT,DMPCT2	; DENSITY SPEC'D.?
	BEQ	87$		;DO NOTHING
	MOV	#IO.STC,R1	; SET FOR STC COMMAND
	MOV	#1,R2		;SINGLE PARAMETER
	CMP	DENSTY,#1600.	; 1600 BPI?
	BEQ	81$		; YES,BRANCH
	CMP	DENSTY,#800.	; 800 BPI?
	BEQ	83$		; YES BRANCH
	MOV	#2,.EXSTS	;NO IS FATAL ERROR FOR NOW
	JMP	ERRDEN
83$:	MOV	#ST08,R3	; SET FOR 800 BPI
	BR	85$
81$:	MOV	#ST16,R3	; SET FOR 1600 BPI
85$:	CALL	.XQIO	;EXECUTE IO.STC
87$:	MOV	(SP)+,R1	; RESTORE R1
	MOV	(SP)+,R2	;RESTORE R2
	FDBK$R	R0,,.BYTES
	MOV	.BYTES,BYTCNT	;
	BR	43$
48$:	MOV	#512.,BYTCNT
	FDBK$R	R0,,#512.
43$:	BIT	#CS.NMF!CS.DIF,INSPEC
	BNE	50$		;BRANCH IF FILE NAME WAS SPECIFIED
	ADD	#N.FLID,R2	;R2=FILE ID ADR IF /FI WAS USED
	MOV	(R2)+,(R1)+	;MOVE TO FILE NAME BLOCK
	BEQ	44$		;BRANCH IF /FI NOT SPECIFIED
	MOV	(R2)+,(R1)+	;MOVE REMAINING FILE ID WORDS
	MOV	(R2)+,(R1)+
	BR	50$		;OPEN THE FILE BY ITS FILE ID
;
; MUST BE LOGICAL BLOCK MODE, NO FILE NAME OR FILE ID
;
44$:	BIT	#RECBIT,DMPCTL	; RECORD BIT SET?
	BEQ	46$		; IF EQ THEN OK
	ERROUT	ER16		; ISSUE ERROR
	MOV	#2,.EXSTS	; FATAL ERROR
	BR	45$		; CONTINUE
46$:	BIT	#BLBIT,DMPCTL	;REQUIRE /BLOCK SWITCH
	BNE	47$
	ERROUT	ER15		;/BLOCK SWITCH NOT PRESENT
	MOV	#2,.EXSTS	; FATAL ERROR
45$:	JMP	AGAI
47$:	BIS	#LBNBIT,DMPCTL	;NOTE LOGICAL BLOCK MODE
	BIC	#HDBIT,DMPCTL
	BR	60$		;GO DUMP THE BLOCKS
;
; VIRTUAL BLOCK MODE, DUMP SPECIFIED FILE
;
50$:	MOV	#STBLK,FDBIN+F.STBK
	TST	F.FNB+N.FID(R0)		; FID PRESENT?
	BNE	61$			; BR IF YES
	MOV	#F.FNB+FDBIN,R1
	MOV	F.DSPT(R0),R2
	MOV	F.DFNB(R0),R3
	CALL	.PARSE
	BCS	90$
61$:	BIT	#RECBIT,DMPCTL		; RECORD MODE?
	BEQ	62$			; IF NE THEN YES
	FDRC$R	R0,#0,#INBUF,.BYTES
	CLR	RECNUM			; RESET RECORD NUMBER
	CLR	RECNUM+2		;
62$:	
	OFNB$	R0,#<FA.SHR!FO.RD>
	BCS	90$		;BRANCH IF CAN'T OPEN FILE
;
; CHECK TO SEE IF FILE APPEARS TO BE EMPTY, IF SO USE SIZE FROM
; STATISTICS BLOCK TO SET THE END OF FILE.
; EFBK =0 IF FILE WASN'T WRITTEN BY FCS, EFBK = 1 AND FFBY =0
; IF FILE WAS PARTIALLY WRITTEN AND NOT CLOSED PROPERLY.
	TST	F.EFBK(R0)
	BNE	60$
	MOV	F.EFBK+2(R0),R1
	BEQ	55$		;BRANCH IF EFBK=0
	TST	F.FFBY(R0)
	BNE	60$
;
; FFBY = 0, IF EFBK=1, THE FILE IS EMPTY
	DEC	R1
	BNE	60$
55$:	MOV	STBLK+4,F.EFBK(R0)
	MOV	STBLK+6,F.EFBK+2(R0)
	ADD	#1,F.EFBK+2(R0)
	ADC	F.EFBK(R0)
	CLR	F.FFBY(R0)
;
; NOW OPEN THE LISTING FILE
60$:	MOV	#512.,FDBOUT+F.OVBS ;FOR LARGE LOCATE MODE RECORDS
	MOV	#FDBOUT,R0	; ADDR OUTPUT FDB
	TST	F.FNB+N.FID(R0)		; IF FID PRESENT
	BNE	71$			; NO INITIAL PARSE
	MOV	#F.FNB+FDBOUT,R1
	MOV	F.DSPT(R0),R2
	MOV	F.DFNB(R0),R3
	CALL	.PARSE
	BCS	72$
71$:	OFNB$	R0,#<FO.WRT>
	BCS	72$	;BRANCH IF UNSUCCESSFUL
	BITB	#FD.REC,F.RCTL(R0) ;LP: OR TI:?
	BEQ	98$	;NO BRANCH
	MOV	#IO.ATT,R1	;SET FUNCTION TO ATTACH DEVICE
	CLR	R2		;NO EXTRA PARAMETERS
	CALL	.XQIO		;ATTACH DEVICE
	BIS  #SPLBIT,DMPCT2  ; INSURE DETACH AT COMPLETION
	BR	98$			;CONTINUE
;
; FAILED TO OPEN OUTPUT FILE
72$:	ERROUT	ER05,0,0
	MOV	#2,.EXSTS	; FATAL ERROR
	BR	95$
;
; FAILED TO OPEN INPUT FILE
90$:	CMPB	#IE.NSF,F.ERR(R0) ;IF "NO SUCH FILE" ERROR
	BNE	92$
	ERROUT	ER06,0		;GIVE THAT ERROR MESSAGE
	MOV	#2,.EXSTS	; FATAL ERROR
	BR	95$
92$:	ERROUT	ER04,0,0	;OTHERWISE GIVE THE GENERAL ONE
	MOV	#2,.EXSTS	; FATAL ERROR
95$:	JMP	RSTART
98$:	JMP	RODUMP		; GOTO DUMP VIA ROOT
ERRDEN:	ERROUT	ER17
	JMP	AGAI

	.END

