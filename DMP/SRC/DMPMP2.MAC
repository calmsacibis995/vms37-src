	IDENT 0003,DMPMP2,<DUMP MAP AREA>
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
; PAUL J KOBAR	10-AUG-78
;
; MODIFIED BY:
;
;	0003	ACG0153		Andrew C. Goldstein,	29-Feb-1980  20:04
;		Fix handling of extension headers
;
;	0002	ACG0134		Andrew C. Goldstein,	18-Feb-1980  17:24
;		Fix map pointer count in header dump
;
;+
; DMPMP2
;
; FORMAT AND PRINT THE INFORMATION IN THE MAP AREA 
;
; INPUT
;	R5 = HEADER BLOCK BUFFER ADDRESS
;
; OUTPUT
;	R0 = EXTENSION SEGMENT FILE NUMBER
;	R1 = EXTENSION SEGMENT FILE SEQUENCE
;
;-

;
;	DEFINE TEXT FORMATS FOR $EDMSG (IN EDPUT)
;
	.NLIST	BEX
;
; DEFINE ODS2 OFFSETS
;
	.MCALL	FHDL2$
;
	FHDL2$
;
	PURE.D


;
;	DEFINE MAP AREA LABEL TEXT
;
MAP0:	.ASCII /MAP AREA%N/
MAP1:	.ASCII /	H.USE		%B = %D.%N/
MAP2:	.ASCII /	RETRIEVAL POINTERS%N/
MAP31:	.ASCII /	TYPE	COUNT		LBN%N/
	.ASCIZ //
MAP32:	.ASCII /	%D	%T.		%T.	%VP%N/
	.ASCIZ //


CHK0:	.ASCII /CHECKSUM%N/
CHK1:	.ASCII /	H.CKSM		%P%N/
	.ASCIZ //
CHK2:	.ASCIZ /** INVALID CHECKSUM - SHOULD BE %P%N/

	.EVEN

;
	PURE.I

DMPMP2::

;
;MAP AREA
;	R4=ADDRESS OF MAP AREA IN BLOCK BUFFER
;
;FORMAT NEXT RECORD
;	H.USE, RETRIEVAL POINTER HEADINGS
;
	MOV	#MAP0,R1
	MOV	ARGBLK,R2
	MOV	R5,(R2)
	ADD	#H.USE,(R2)
	CLR	2(R2)
	MOVB	H.USE(R5),2(R2)
	CALL	EDPUT
;
;FORMAT NEXT RECORD
;	RETRIEVAL POINTERS
;
	CLR	R3
	BISB	H.USE(R5),R3	;USED WORDS
	BEQ	CHKSUM		;IF 0 GO TO CHECK SUM RECORD
	CLR	R4		;POINT TO RETRIEVAL POINTERS
	BISB	H.MPOF(R5),R4
	ASL	R4
	ADD	R5,R4
	MOV	ARGBLK,R2	; POINT TO ARGUMENT BLOCK
	MOV	R2,2(R2)	; FORM POINTERS TO
	ADD	#16,2(R2)	; COUNT
	MOV	R2,4(R2)	; AND
	ADD	#22,4(R2)	; LBN
RTRV0:	MOV	ARGBLK,R2
	MOV	(R4),R1		; GET FIRST WORD
	BIC	#37777,R1	; MASK TO LEAVE THE TYPE BITS
	CLC			; ENSURE 'C' BIT CLEAR
	ROL	R1		; AND ROTATE TYPE BITS TO
	ROL	R1		; BITS 0 AND 1
	ROL	R1
	MOV	R1,(R2)+	; STORE RETRIEVAL POINTER TYPE
	MOV	(R2)+,R0	; SET POINTER TO COUNT AND LBN
	TST	(R2)+		; ADVANCE ARGBLK POINTER OVER LBN POINTER
	TST	R1		; IS RETREIVAL POINTER TYPE 0?
	BNE	10$		; IF NE THEN NOT TYPE 0
	CLR	(R0)+		; COUNT FIELD  IS 0
	CLR	(R0)+
	CLR	(R0)+		; HIGH ORDER LBN IS 0
	MOV	(R4),(R0)	; GET PLACEMENT VALUE
	BIC	#140000,(R0)+	; AND CLEAR OUT TYPE BITS
	BR	40$		; BRANCH TO COMMON CODE
10$:
	CMP	R1,#1		; IS RETRIEVAL POINTER TYPE 1?
	BNE	20$		; NO IF NE
	CLR	(R0)+		; HIGH ORDER COUNT IS 0
	MOV	(R4),(R0)	; GET COUNT VALUE
	BIC	#177400,(R0)	; BUT ENSURE HI BYTE IS CLEAR
	INC	(R0)+		; MAKE TRUE COUNT
	MOVB	1(R4),(R0)	; GET HIGH ORDER LBN
	BIC	#177700,(R0)+	; AND CLEAR TYPE BITS
	MOV	2(R4),(R0)+	; STORE LOW ORDER LBN
	BR	40$		; BRANCH TO COMMON CODE
20$:
	CMP	R1,#2		; IS RETRIEVAL POINTER TYPE 2?
	BNE	30$		; NO IF NE
	CLR	(R0)+		; HIGH ORDER COUNT = 0
	MOV	(R4),(R0)	; STORE LOW ORDER LBN
	BIC	#140000,(R0)	; AND CLEAR TYPE BITS
	INC	(R0)+		; MAKE TRUE COUNT
	MOV	4(R4),(R0)+	; STORE HIGH ORDER
	MOV	2(R4),(R0)+	; AND LOW ORDER LBN
	BR	40$		; BRANCH TO COMMON CODE
30$:
	MOV	(R4),(R0)	; STORE HIGH ORDER COUNT
	BIC	#140000,(R0)+	; AND CLEAR TYPE BITS
	MOV	2(R4),(R0)	; STORE LOW ORDER COUNT
	ADD	#1,(R0)+	; MAKE TRUE COUNT
	ADC	-4(R0)		; ALL 30 BITS OF IT
	MOV	6(R4),(R0)+	; STORE HIGH ORDER
	MOV	4(R4),(R0)+	; AND LOW ORDER LBN	
40$:
	INC	R1		; NUMBER OF WORDS = TYPE + 1
	MOV	R1,(R2)+	; SET NUMBER OF WORDS TO DUMP IN OCTAL
	SUB	R1,R3		; SUBTRACT FROM WORDS IN USE
50$:
	MOV	(R4)+,(R2)+	; STORE RETRIEVAL WORD
	SOB	R1,50$		; BACK UNTIL ALL DONE
	MOV	#MAP32,R1	; SET FORMAT POINTER
	MOV	ARGBLK,R2	; AND ARGUMENT BLOCK POINTER
	CALL	EDPUT
	TST	R3		; MORE TO DUMP?
	BNE	RTRV0

;
;FORMAT NEXT RECORD
;	H.CKSM
;
CHKSUM:	MOV	#CHK0,R1
	MOV	H.CKSM(R5),(R2)
	CALL	EDPUT

; CALCULATE AND COMPARE CHECKSUM
	MOV	#255.,R3
	CLR	R1
	MOV	R5,R0
CHKTST:	ADD	(R0)+,R1
	SOB	R3,CHKTST
	CMP	R1,H.CKSM(R5)
	BEQ	CHKEND
	MOV	R1,(R2)
	MOV	#CHK2,R1
	CALL	EDPUT
CHKEND:

; RETURN FILE NUMBER AND SEQUENCE NUMBER
	MOV	H.EFNU(R5),R0
	MOV	H.EFSQ(R5),R1
	MOV	H.ERVN(R5),R2
	RETURN
	.END
