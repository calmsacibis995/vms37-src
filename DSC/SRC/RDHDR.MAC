	$BEGIN	RDHDR,0016,<READ FILE HEADER>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  17-AUG-76  23:15
;
; ANDREW C. GOLDSTEIN  13-FEB-1980
; ACG0133 - RETURN HEADER VALID FLAG
;
; ANDREW C. GOLDSTEIN  15-JAN-1980  20:52
; ACG0107 - RETURN MAP STATUS FLAG
;
; **GR01---G.RITTENBURG 23-OCT-1978
; CONDITIONALIZED FOR 11M
;

	.IF	NDF,R$$NVX
	.MCALL	FHDL2$
	FHDL2$				; DEFINE FILE HEADER FORMAT
	.ENDC

;+
;
; *** - $RDHDR	READ FILE HEADER FROM INPUT DISK
;
; *** - $RDHDO	READ FILE HEADER FROM OUTPUT DISK
;
; THIS ROUTINE READS THE HEADER FOR THE INDICATED FILE INTO THE
; APPROPRIATE HEADER BUFFER AND CHECKS ITS CORRECTNESS.
;
; INPUTS:
;
;	R2, R3 = FILE NUMBER OF HEADER
;
; OUTPUTS:
;
;	CC - C	CLEAR IF ALL OK
;		SET IF ERROR (MESSAGE PRINTED)
;	R4 = BUFFER CONTROL BLOCK ADDRESS
;	R5 = ADDRESS OF HEADER BUFFER
;	$FNU CONTAINS FILE NUMBER
;	HEADER READ INTO $IHBF OR $OHBF
;	OTHER REGISTERS CLOBBERED
;
;
; *** - $VFYHD	VERIFY FILE HEADER
;
; THIS ROUTINE VERIFIES THAT THE INDICATED BLOCK IS A FILE HEADER.
;
; INPUTS:
;
;	R4 = BCB OF HEADER
;	R5 = ADDRESS OF HEADER
;
; OUTPUTS:
;
;	CC - C	CLEAR IF HEADER
;		SET IF NOT
;	R4, R5 PRESERVED, OTHER REGISTERS CLOBBERED
;
;-

$RDHDR::
	LET $HDVAL := #0		; MARK HEADER NOT VALID
	LET R4 := #$IHHD		; USE INPUT HEADER BUFFER
RDHDR1:	LET R0 := #INLUN		; READ FROM INPUT DEVICE
	LET R1 := $INDEV		; GET DEVICE TABLE ADDR
	IF #KY.NIP SET.IN $FLAG1	;IF TAPE O.P. FLAGGED
	  LET R5 := #$OXBF
	ELSE
	  LET R5 := #$IXBF		; AND INPUT INDEX FILE HEADER
	END
	GOTO RDCOM

$RDHDO::
	LET R4 := #$OHHD		; USE OUTPUT HEADER BUFFER
RDHDO1:	LET R0 := #OUTLUN		; READ FROM OUTPUT DEVICE
	LET R1 := $OUDEV		; GET DEVICE TABLE ADDR
	LET R5 := #$OXBF		; AND OUTPUT INDEX FILE HEADER

RDCOM:	LET $FNU := R3			; SAVE FILE NUMBER
	PUSH R0				; AND LUN
	LET R3 := R3 + V.IBSZ(R1)	; ADD SIZE OF INDEX FILE BITMAP
	LET R2 := R2 + CARRY		; TO FILE NUMBER
;
; ACCOUNT FOR THE BOOT BLOCK, HOME BLOCK, BACKUP HOME BLOCK AND
; THE BACKUP COPY OF THE INDEX FILE HEADER.
;
; EACH OCCUPIES ONE CLUSTER OF VBNS AND LBNS. (CLUSTER FACTOR*4)+1
;
	MOV  V.CLF(R1),-(SP)		; CLUSTER FACTOR TO TEMP.
	ASL  (SP)			; MULT BY
	ASL  (SP)			;         FOUR.
	ADD  (SP)+,R3
	ADC  R2
	$CALL $MPVBN <,,R2,R3,,R5>	; MAP TO LBN
	POP R0				; GET LUN INTO R0
	ON.ERROR
	  LET $HDMAP := #-1
	  ERRP ER.FNU			; FILE NUMBER NOT MAPPED
	  JUMPTO EXIT
	END
	LET $HDMAP := #0
	$CALL $RDWLN <R0,,R2,R3,R4>	; READ THE HEADER
	ON.ERROR
	  ERRP ER.RHD
	ELSE
;
; MAKE SURE THAT THIS IS A REAL FILE HEADER
;
$VFYHD::  				; ENTRY TO VERIFY A HEADER
	  IF H.FLEV(R5) NE #1001	; CHECK FILE STRUCTURE LEVEL
	    ERRP ER.FLV
	  ELSE
	    LET $HDVAL := #1
	    IF H.FNUM(R5) EQ #0
	      ERRP ER.DEL
	    ELSE
	      IFB  #SC.MDL SET.IN H.SCHA(R5)
		ERRP ER.DEL 
	      ELSE
		IF H.FNUM(R5) NE $FNU	; CHECK FILE NUMBER
		  ERRP ER.FNO
		ELSE
		  $CALL $CKSUM		; CHECK THE CHECKSUM
		  ON.ERROR THEN ERRP ER.HCK
		END
	      END
	    END
	  END
	END
EXIT:	ON.ERROR THEN LET B.STAT(R4) := B.STAT(R4) OFF.BY B.STAT(R4)
	RETURN

;+
;
; *** - $RDNXH	READ NEXT EXTENSION HEADER FROM INPUT DISK
;
; *** - $RDNXO	READ NEXT EXTENSION HEADER FROM OUTPUT DISK
;
; THIS ROUTINE READS THE NEXT EXTENSION HEADER OF THE INDICATED FILE.
; AN ERROR RETURN IS MADE IF NONE EXISTS OR IF AN ERROR OCCURRED.
;
; INPUTS:
;
;	R4 = BUFFER CONTROL BLOCK FOR NEW HEADER
;	R5 = ADDRESS OF PRESENT HEADER
;
; OUTPUTS:
;
;	CC - C	CLEAR IF NO ERRORS
;		SET IF ERROR OR NO EXTENSION HEADER
;	R5 = BUFFER ADDRESS OF NEW HEADER
;	$BAVBN UPDATED (INPUT FILES ONLY)
;	APPROPRIATE LUN ASSIGNED TO NEW DISK
;
;-

$RDNXH::
	PUSH  #0			; SET FLAG FOR INPUT
	GOTO RDNXCM

$RDNXO::
	PUSH  #1			; SET FLAG FOR OUTPUT

RDNXCM:
	POP R0
	MOV  H.FSEG(R5),-(SP)		; SAVE EXTENSION SEGMENT NUMBER.
	LET  R1  :=  H.ERVN(R5)		; GET EXTENSION RVN.
	LET R2  :=  R1			; HI PART OF FILE # TO R2.
	SWAB  	R2			
	BIC	#^C<377>,R2
	LET R3  :=  H.EFNU(R5)
	IF RESULT IS NE			; IF EXTENSION HEADER EXISTS
	  PUSH H.EFSQ(R5)		; GET EXTENSION FILE SEQ #
	  IF R0 EQ #0			; IF INPUT
	    $CALL $SWID <,R1>		; SWITCH TO NEW VOLUME
	    ON.NOERROR THEN $CALL RDHDR1 <,,R2,R3,R4>
	  ELSE				; IF OUTPUT DEVICE
	    $CALL $SWOD <,R1>		; SWITCH TO NEW VOLUME
	    ON.NOERROR THEN $CALL RDHDO1 <,,R2,R3,R4>
	  END
	  ON.NOERROR
;
; CHECK THE EXTENSION HEADER FOR CONSISTENCY
;
	    IF (SP)+ EQ H.FSEQ(R5)	; CHECK FILE SEQUENCE NUMBER
	      LET (SP) := (SP) + #1	; BUMP SAVED SEGMENT NUMBER
	      IF (SP)+ EQ H.FSEG(R5)	; CHECK SEGMENT NUMBER
		RETURN NOERROR		; GOOD EXTENSION HEADER
	      ELSE
		ERRP ER.ESN
	      END
	    ELSE
	      ERRP ER.ESQ
	      TST (SP)+			; CLEAN SEG NUMBER FROM STACK
	    END
	  ELSE				; ERROR READING HEADER -
	    CMP (SP)+,(SP)+		; MESSAGE ALREADY PRINTED
	  END
	ELSE
	  TST (SP)+			; CLEAN THE STACK
	END
	RETURN ERROR
	.END

