	$BEGIN  DSCPAR,0035,<COMMAND PARSER FOR DSC UTILITY>

; ALTERED:
; GEORGE RITTENBURG  24-SEP-76  15:47
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  19-NOV-76  1:24
; GEORGE RITTENBURG	11-MAR-77  001 CONDITIONAL FOR 11D AND IAS INSERTED
;G.RITTENBURG	6-APR-77 MODIFIED FOR VFY/CMP DISK TO/FROM TAPE
; G.RITTENBURG 12-SEPT.77 SUPPORT FOR RM03 AND RL01 ADDED
; G.RITTENBURG  9-NOV-77 SUPPORT FOR DF AND DS DEVICES REMOVED FOR
; STAND ALONE VERSION ONLY
; GR001--- G.RITTENBURG JAN.3,1978
; CORRECTION TO ELIMINATE POSSIBILITY OF COPY TO ITSELF
; GR002---G.RITTENBURG 22-JUN-1978
; CORRECTIONS TO 11S SIZING ROUTINES
; **GR03---G.RITTENBURG 1,OCT,1978
; RP07 AND RL01/RL02 SUPPORT ADDED TO SIZE RTNES (11S)
;
; MODIFIED BY:
;
;	X0035	RLRTU78		Robert L. Rappaport		9-July-1980
;		ADDED A LINE TO THE STATE TABLE TO MAP DENSITY=6250 INTO
;		DENSITY=800.  SINCE THE VMS TFDRIVER DEFAULT DENSITY IS
;		6250, A SET CHARACTERISTICS ASKING FOR 800 BPI DENSITY WILL
;		AUTOMATICALLY DEFAULT TO 6250 BPI.
;


	.MCALL	ALUN$S,QIOW$C,GLUN$C,GTSK$C
	.MCALL  QIO$S,WTSE$S,NMBLK$,DIR$
	NMBLK$
RPCS=0
RPDS=-4
RSCS2=10
RSDT=26
XSTSIZ=40.				; SIZE OF EXPANDED STRING AREA.

	.SBTTL	PURE DATA

;
;
		.PSECT PARDAT,D
;
; PROMPT STRING TO GET COMMAND LINE
;
	PROMPT:	.ASCII	"DSC2>"
PROMPL	= .-PROMPT

	.EVEN



	.SBTTL	IMPURE DATA

;
; SCRATCH STORAGE FOR THE PARSER
;
VNUM:	.BLKW	1		; POINTER TO VOLUME COUNT WORD
DEVPT:	.BLKW	1		; POINTER TO VOLUME TABLE
CML::	.BLKW	1		; POINTER TO START OF COMMAND LINE
.IF  DF,R$$11S


	.MACRO  TABENT   DEV
		.ASCII  /'DEV'/
		.WORD   $'DEV'INT	; 'DEV' INTERUPT ADDRESS
	.ENDM	TABENT

INTADD:		.BLKW		1	;DEV. INTERUPT ADDRESS TABLE
MMDEV:  .ASCII /MM/
DEVTAB:	TABENT	DK
	TABENT  DM
; THE FOLLOWIN CONDITIONAL INSERTED N0V.9,1977
		.IF DF,R$SPEC
		  TABENT  DF
		  TABENT  DS
		.ENDC
	TABENT	DP
	TABENT	DB
	TABENT	MT
	TABENT	MM
	TABENT  DL
	TABENT  DR
DEVEND:
.ENDC

;
; DIRECTIVE PARAMETER BLOCK FOR LOGICAL NAME TRANSLATION.
;
LNDPB:	.BYTE	145.,8.			; DIRECTIVE CODE & DPB SIZE.
	.WORD	3			; USE RMS MODE.
	.WORD	0			; NO LUN.
	.WORD	.PSTCN			; ADDR OF TPARS SCANNED STRG DESC.
	.WORD	0			; DEFAULT NAME STRING NOT USED.
	.WORD	0			; MUST BE ZERO.
	.WORD	FNB			; ADDR OF FILE NAME BLOCK.
	.WORD	EXPSTG			; ADDR OF EXPANDED STRING DESC.
;
; FILE NAME BLOCK.
;
FNB:	.BLKB	N.UNIT+2
;
; EXPANDED STRING AREA AND DESCRIPTOR FOR SAME.
;
XPSTG:	.BLKB	XSTSIZ			; EXPANDED STRING AREA.
EXPSTG:	.WORD	0			; SIZE OF ABOVE AREA.
	.WORD	XPSTG			; ADDR OF EXPANDED STRING AREA.

	.SBTTL	MAIN PARSER ROUTINE

;+
;
;
		.PSECT
;
; *** - $DSCPR - DSC COMMAND LINE PARSER
;
; THIS ROUTINE ACCEPTS A COMMAND LINE (FROM THE TERMINAL OR MCR
; COMMAND BUFFER), PARSES IT, AND LEAVES THE RESULTS IN THE
; PARSER OUTPUT AREA.
;
; INPUTS:	NONE
;
; OUTPUTS:	AS DOCUMENTED IN THE DSC IMPURE AREA
;
;-

$DSCPR::
;
; ACQUIRE A COMMAND LINE
;
	$CALL	.GTCML <,,,#PROMPL,#PROMPT>
	IF R3 EQ #0 GOTO $DSCPR		; IGNORE NULL LINES
	LET CML := R4			; SAVE COMMAND LINE ADDRESS
;
; NOW CALL THE PARSER
;
	LET $IFLAG := #KY.MRG		; INITIAL FLAG VALUE
	$CALL	.TPARS <,#0,#DSCKTB,R3,R4,#START>
	ON.ERROR
		LET R4 := R4 + .PSTCN	; R4 POINTS TO REMAINDER OF STRING
		ERROR   ER.SYN		; SYNTAX ERROR
	END

	.IF DF,  R$$11S
	IF #KY.NCP SET.IN $FLAG1
	  TST (SP)+			; NON-COPY OPERATION
	  JUMPTO $DSC
	END
;CURRENT COMMAND WAS TO SET HDWRE. SWITCHES.
;
	.ENDC
IF  $IVNUM EQ #0 THEN ERROR ER.SYN  ;CHECK FOR NO INPUT DEV.
;
; CHECK FOR IDENTICAL INPUT AND OUTPUT DISK
;
	LET R0 := #$IVTAB
	LET R1 := #$OVTAB
	IF (R0) EQ (R1) AND 2(R0) EQ 2(R1) THEN ERROR ER.SYN
;
;CHECK FOR CONSISTENT SWITCHES
;
	LET R0 := $IFLAG
	IF #KY.TAP SET.IN R0
	  LET R0 := R0 OFF.BY #KY.ITP
	ELSE
	  LET R0 := R0 OFF.BY #KY.IDK
	END
	LET R1 := $OFLAG
	IF #KY.TAP SET.IN R1
	  LET R1 := R1 OFF.BY #KY.OTP
	ELSE
	  LET R1 := R1 OFF.BY #KY.ODK
	END
	LET R0 := R0 SET.BY R1
	IF RESULT IS NE THEN ERROR ER.ILS
	   LET $FLAG1 := $FLAG1 SET.BY #40000
	   IF #KY.TAP OFF.IN $OFLAG
		LET $FLAG1 := $FLAG1 OFF.BY #40000
	   END
	   IF #KY.TAP SET.IN $IFLAG
	       LET $FLAG1 := $FLAG1 SET.BY #100000
	   END
	   IF #KY.VER SET.IN $OFLAG OR #KY.CMP SET.IN $OFLAG
		   IF  $FLAG1 EQ #140000 THEN ERROR ER.ILS
	   END
	RETURN

	.SBTTL	PARSER STATE TABLE

	.MCALL	ISTAT$,STATE$,TRAN$

	ISTAT$	DSCSTB,DSCKTB
;
; INIT FOR OUTPUT DEVICES
;
	STATE$	START
	TRAN$	$LAMDA,,IODEV
;
; READ OUTPUT DEVICE LIST
;
	STATE$
	TRAN$	!DEVLST
;
; READ "=" AND INIT FOR INPUT DEVICES
;
	STATE$
	TRAN$	$EOS,$EXIT
	TRAN$	'=,,IIDEV
;
; READ INPUT DEVICE LIST
;
	STATE$
	TRAN$	!DEVLST

	STATE$
	TRAN$	$EOS,$EXIT
;
; SUBEXPRESSION TO READ LIST OF DEVICE NAMES
;
	STATE$	DEVLST
	TRAN$	$STRNG,,LOGNAM		;DEVICE NAME/UNIT, OR LOGICAL NAME.

	STATE$	DEV1
	TRAN$	':			; DEVICE SPEC ENDS WITH COLON

	STATE$
	TRAN$	<',>,DEVLST		; LOOP FOR MULTIPLE DEVICES
	TRAN$	'/,OPTS			; SWITCHES
	TRAN$	$STRNG,OPTS1,SETLAB	; LABEL STRING
	TRAN$	$LAMDA,$EXIT
;
; OPTION PROCESSING
;
	STATE$	OPTS1
	TRAN$	'/,OPTS			; GET NEXT SWITCH
	TRAN$	$LAMDA,$EXIT

	STATE$	OPTS
	TRAN$	"RW",OPTS1,,KY.RWD,$IFLAG	; REWIND
	TRAN$	"DENS",DENS			; TAPE DENSITY
	TRAN$	"AP",OPTS1,,KY.APD,$IFLAG	; APPEND
	TRAN$	"NMG",OPTS1,SETNMG		; NO MERGE
	TRAN$	"BAD",BAD			; BAD BLOCK PROCESSING
	TRAN$	"VE",OPTS1,,KY.VER,$IFLAG	; VERIFY AFTER COPY
	TRAN$	"CMP",OPTS1,,KY.CMP,$IFLAG	; COMPARE ONLY
.IF  DF,R$$11S

TRAN$	"UNIT",USTAT
TRAN$	"VEC",VSTAT
TRAN$	"CSR",CSTAT
TRAN$	"TM02",TSTAT

STATE$ USTAT
TRAN$ '=

STATE$
TRAN$	$NUMBR,HWDOP,STUNI

STATE$	VSTAT
TRAN$	'=

STATE$
TRAN$	$NUMBR,HWDOP,STVEC

STATE$ CSTAT
TRAN$	'=

STATE$
TRAN$	$NUMBR,HWDOP,STCSR

STATE$ TSTAT
TRAN$	'=

STATE$
TRAN$		$NUMBR,HWDOP,STTM2

STATE$ HWDOP
TRAN$	'/,HWD1
TRAN$	$EOS,$EXIT

STATE$  HWD1
TRAN$	"UNIT",USTAT
TRAN$	"VEC",VSTAT
TRAN$	"CSR",CSTAT
TRAN$	"TM02",TSTAT

.ENDC
;
; SET TAPE DENSITY
;
	STATE$	DENS
	TRAN$	'=

	STATE$
	TRAN$	"800",DENS1
	TRAN$	"1600",OPTS1,,KY.160!KY.16B,$IFLAG
	TRAN$	"6250",OPTS1

	STATE$	DENS1
	TRAN$	':
;
; SET SPLIT DENSITY
;
	STATE$	DENS3
	TRAN$	"1600",OPTS1,SET16B
;
; BAD BLOCK PROCESSING SWITCHES
;
	STATE$	BAD
	TRAN$	'=

	STATE$	BAD1
	TRAN$	"MAN",BAD2,,KY.MAN,$IFLAG
	TRAN$	"NOAUTO",,,KY.NAU,$IFLAG

	STATE$	BAD2
	TRAN$	':,BAD1
	TRAN$	$LAMDA,OPTS1

;
; PROCESS THE TRANSLATED DEVICE NAME.
;
	STATE$	DNSYN			; DEVICE NAME UNIT SYNTAX.
	TRAN$	$ALPHA,,SETDEV		; FIRST DEV NAME CHAR

	STATE$
	TRAN$	$ALPHA,,SETDEV		; 2ND CHAR

	STATE$
	TRAN$	$LAMDA,,INIUNI		; INITIALIZE UNIT NUMBER TO ZERO.

	STATE$
	TRAN$	$ALPHA,UNIT,SETCON	; SET CONTROLLER OFFSET IF ANY.
	TRAN$	$LAMDA			; CONTROLLER LETTER IS OPTIONAL.

	STATE$	UNIT
	TRAN$	$NUMBR,COLON,SETUNT	; UNIT NUMBER (AND DEVICE SETUP)
	TRAN$	$LAMDA,,SETU0

	STATE$	COLON
	TRAN$	':,$EXIT
	STATE$

		.SBTTL  ACTION ROUTINES
;
; ACTION ROUTINE TO ATTEMPT TRANSLATION OF A LOGICAL NAME.
;
LOGNAM:
	LET	EXPSTG  :=  #XSTSIZ	; SET EXPANDED STRING SIZE.
	LET	.PSTCN  :=  .PSTCN  +  #1  ; PASS COLON TO DIRECTIVE.
	DIR$	#LNDPB			; ELEPHANT DIRECTIVE.
	LET	.PSTCN  :=  .PSTCN  -  #1  ; READJUST FOR MAINLINE PARSE.
	PUSH	 R3,R4,R5		; SAVE TPARS CONTEXT.
	$CALL	 .TPARS	 <,#0,#DSCKTB,EXPSTG,EXPSTG+2,#DNSYN>
	POP	 R5,R4,R3		; RESTORE TPARS CONTEXT.
	ON.NOERROR  GOTO  XITNRM
;
; IF THE DIRECTIVE FAILED, REJECT THE TRANSITION (SYNTAX ERROR).
;
	ADD	#2,(SP)			; RETURN @ CALL PLUS 4.
XITNRM:	RETURN


;
; SET UP FOR OUTPUT DEVICES
;
IODEV:	LET DEVPT := #$OVTAB
	LET VNUM := #$OVNUM
	RETURN
;
; SET UP FOR INPUT DEVICES
;
IIDEV:	LET DEVPT := #$IVTAB
	LET VNUM := #$IVNUM
	LET $OFLAG := $IFLAG
	LET $IFLAG := #0
	RETURN
;
; GET DEVICE NAME CHAR
;
SETDEV:	IF @VNUM GE #V.LENG THEN ERROR ER.TMD
	LET @DEVPT :B= .PCHAR
	LET DEVPT := DEVPT + #1
	RETURN
;
; INITIALIZE UNIT NUMBER TO ZERO.
;
INIUNI:	LET  @DEVPT  :=  #0
	RETURN
;
; ADJUST UNIT NUMBER BY CONTROLLER OFFSET.
; OFFSET EQU ((CONTROLLER LETTER - #101) * 16.)
;
SETCON:	LET  R0  :=  .PCHAR  -  #101	; A=0,B=1,C=2 ETC.
	LET  R0  :=  R0  L.SHIFT 4	; MULTIPLY BY 16.
	LET  @DEVPT  :=  R0		; STORE UNIT NUMBER.
	RETURN
;
;GET UNIT NUMBER AND SET UP DEVICE
;
.IF DF,R$$11S
SETUNT: IF .PNUMB GT #1 THEN ERROR ER.ILU
;STANDALONE MAX. IS 2 DEVICES
	LET @DEVPT  := .PNUMB

.IFF
SETUNT:	ADD	.PNUMB,@DEVPT		; ADD UNIT NUMBER TO CONTROLLER OFFSET.
.ENDC

SETU0:	LET R0 := DEVPT - #2
	LET R1 := R0 - #V.SIZ		; POINT TO PREVIOUS TABLE ENTRY
	WHILE R1 HI VNUM		; SCAN PRECEDING ENTRIES
	IF (R0) EQ (R1) AND 2(R0) EQ 2(R1) THEN ERROR ER.DUD
	  LET R1 := R1 - #V.SIZ		; FOR DUPLICATES
	END LOOP
	ALUN$S #INLUN,(R0),2(R0)
	ON.ERROR THEN ERROR ER.DEV
	GLUN$C INLUN,$LUNBF

	.IF   DF, R$$11D		;001 CONDITIONAL FOR 11D AND IAS

	CALL	$FILCW			;001

	.ENDC				;001
	LET $CW2+1 :B= #0  ;CLEAR HI BYTE  12-9-77

	IF #DV.SQD SET.IN $CW1
	  LET $IFLAG := $IFLAG SET.BY #KY.TAP
	  IF #KY.DSK SET.IN $IFLAG THEN ERROR ER.CDV
	  LET R1 := R0 - #V.SIZ		; POINT TO PREVIOUS TABLE ENTRY
	  IF @VNUM NE #0		; IF THERE IS ONE
	    IF (R1) NE (R0) THEN ERROR ER.MXT ; CHECK FOR MIXED TAPE DRIVS
	  END
	.IF	DF,R$$11S
	  $CALL LOCUCB			;TO GET UCB ADDRESS
	GOTO SIZE
	.IFF
	  JUMPTO CONT3
	.ENDC
	END
	IF #DV.F11 OFF.IN $CW1 THEN ERROR ER.F11
	.IF	DF,R$$11S
	$CALL LOCUCB		;TO GET UCB ADDR. IN R2
SIZE:	PUSH R3			;SAVE R3
	LET R3 := U.SCB(R2)	;R3 IS SCB ADDR
	LET U.ST2(R2) :B= U.ST2(R2) OFF.BY #US.OFL  ;SET DEV ON LINE
	LET R3 := S.CSR(R3)	;R3 IS CSR ADDR
	PUSH  @#4		;SAVE INTRPT ADDR
	LET @#4 := #TRAPA	;SET NEW INTRPT ADDR
	LET PS :B= #PR7		;LOCK OUT INTRPTS
	TST  (R3)		;IS CTRLR THERE?
	BCC  DEVCK		;YES BRANCH
	LET U.ST2(R2) :B= U.ST2(R2) SET.BY #US.OFL  ;SET DEV OFF LINE
	POP  @#4		;RESTORE INTRPT ADDR
	LET PS :B= #0		;ENABLE INTRPTS
	POP R3			;RESTORE R3
	JUMPTO CONT3
DEVCK:	POP @#4    ;		RESTORE INTRPT ADDR
	LET PS :B= #0		;ENABLE INTRPTS
	IF #DV.SQD SET.IN $CW1
		POP R3	;IF TAPE RESTORE R3
		JUMPTO CONT3  ;AND EXIT
	END
;
; THE FOLLOWING CONDITIONAL INSERTED NOV.9,1977
;
	.IF  DF,R$SPEC
;
	CMP	(R0),#"DF	;IS IT A DF DEV?
	BNE	DSDEV		;NO,TRY DS DEV
	MOV	U.CW3(R2),R3	;YES, R3 IS BLOCKS PER PLATTER
		;READ FIRST BLOCK ON NEXT PLATTER
RPTRD: QIO$S #IO.RLB,#INLUN,#EFN,,#$B1HD,,<#$B1DAT,#256.,,#0,R3>
		BCS	QIOER			;COMMAND REJECTED BY QIO
	WTSE$S  #EFN			;WAIT
	TSTB	$B1HD		;	TEST FOR ERROR
	BMI	ILBLK			;TO TEST FOR ILLEGAL BLOCK
	ADD	U.CW3(R2),R3		;BUMP R3 TO NEXT PLATTER
	BR	RPTRD			;TRY NEXT PLATTER
QIOER: ERROR ER.UDE			;QIO REJECT
ILBLK:	CMPB	#IE.BLK,$B1HD		;TEST FOR ILLEGAL BLOCK
	BEQ	SETDF		;YES, SET FOR DF DEV
	IF #IE.OFL SET.IN $B1HD THEN ERROR ER.DEV
	ERROR ER.UDE
SETDF:	CLR	$CW2		;SET HI WORD OF LBN TO 0B,
	MOV	R3,$CW3		;SET MAX. BLOCKS FROM R3
	JMP	LVSIZ			;GO TO EXIT
DSDEV:	CMP	(R0),#"DS	; DS DEVICE?
	BNE	RPDEV		; NO, TRY DP
	MOV	#40,10(R1)	; CLEAR DS SUB-SYSTEM
	MOVB	U.UNIT(R2),RSCS2(R1)  ; YES, SELECT UNIT
	MOV	 #1024,U.CW3(R2)	;SET UP FOR RS03
	CLR	U.CW2(R2)
	BIT	#10000,RSCS2(R1)	; IS DEVICE THERE?
	BEQ	10$			; YES, BRANCH
	BISB	#US.OFL,U.ST2(R2)	; SET DEVICE OFF LINE
	BR  11$		; TO EXIT
10$:	BIT	#2,RSDT(R1)		; DEVICE IS RS04?
	BEQ 11$		; TO EXIT
	ASL	U.CW3(R2)		; DOUBLE NO. OF BLOCKS
	BIS	#U2.R04,U.CW2(R2)	; SET RS04 BIT
11$:	JMP MAINXT	; AND EXIT
	.ENDC

RPDEV:	MOV	U.SCB(R2),R1		;R1 HAS SCB ADDRESS
	MOV	S.CSR(R1),R1		;R1 HAS CSR ADDRESS
	MOVB	U.UNIT(R2),R3 ; R3 IS PHYS. UNIT #
	CMP	(R0),#"DP		;DP DEVICE?
	BNE	DBDEV			;TRY DB DEVICE
	MOV	#40000.,U.CW3(R2)	;SET UCB FOR RP02
	CLR	U.CW2(R2)
	SWAB	R3
	MOV	R3,(R1)		;SELECT UNIT
	BICB	-(SP),(SP)+	;DELAY FOR UNIT SELECT
	BIT	#20000,RPDS(R1)		;TESTFOR RP03
	BEQ	EXT1		;NO, GO TO EXIT
	ASL	U.CW3(R2)		;DBLE BLKS IN UCB
	ROLB	U.CW2(R2)
EXT1:	JMP	MAINXT		; TO EXIT
DBDEV:	CMP	(R0),#"DB		;DB DEVICE?
	BNE	DMDEV			;NO TRY DM
	MOV	#40,10(R1)	;CLEAR DB SUB-SYSTEM
	MOVB	U.UNIT(R2),RSCS2(R1)	;SELECT UNIT
	MOV	26(R1),-(SP)	;GET DEV.TYPE REG.(SELECTS UNIT)
	TST	(SP)+		; CLEAN STACK
	MOVB	#2,U.CW2(R2)		;SET FOR RP04/05
	MOV	#117426,U.CW3(R2)
	BIT  #10000,RSCS2(R1)	;IS DEV THERE
	BEQ  10$		;YES,BRANCH
	BISB  #US.OFL,U.ST2(R2)   ;SET DEV OFF LINE
	BR  MAINXT
10$:	BIT	#2,RSDT(R1)		;TEST FOR RP06
	BEQ	MAINXT		;NO GO TO EXIT
	MOVB	#5.,U.CW2(R2)		;SET FOR RP06 IN
	MOV	#12990.,U.CW3(R2)	;UCB
	BR	MAINXT			;GO TO EXIT
DMDEV:
	CMP 	(R0),#"DM		;DM DEVICE?
	BNE	DRDEV			;NO, TRY DR
	MOV	#40,10(R1)		;CLEAR RK06 SUB-SYSTEM
	MOV  R3,10(R1)	; LOAD UNIT NO.
	MOV	#1,(R1)			;SELECT DRIVE
10$:	TSTB	(R1)			;WAIT FOR SERIAL MSG.
	BPL	10$
	BICB	#US.OFL,U.ST2(R2)	;ASSUME ON-LINE
	BIT	#10000,10(R1)		;DRIVE THERE ?
	BEQ	20$			;IF EQ,YES
	BISB	#US.OFL,U.ST2(R2)	;NO,SET OFF-LINE
	BR	MAINXT
20$:	MOV	#64766,U.CW3(R2)	;ASSUME RK06
	BIT  	#400,12(R1)		;RK06 ?
	BEQ	MAINXT			;IF EQ, YES
	MOV	#151036,U.CW3(R2)	;NO, ITS RK07
	BR	MAINXT
DRDEV:	CMP	(R0),#"DR		;DR DEVICE ?
	BNE	DLDEV		;NO,TRY DL
	MOV	#40,10(R1)		;CLEAR MASSBUS CNTRLR
	MOV  R3,10(R1)	; LOAD UNIT NO.
	MOV	26(R1),R3		;SELECT UNIT
	BICB	#US.OFL,U.ST2(R2)	;ASSUME ON-LINE
	BIT	#10000,10(R1)		;DEVICE THERE ?
	BEQ	RM3TST	; EQ IS YES,TEST RM03/RP07
	BISB	#US.OFL,U.ST2(R2)	;SET OFF-LINE
	BR	MAINXT	; AND EXIT
RM3TST:	MOV	#2,U.CW2(R2)	;ASSUME RM03
	MOV	#1140,U.CW3(R2)
	BIT	#753,R3		; IS IT RP07?
	BEQ	MAINXT		; EQ IS NO,EXIT
	MOV	#10,U.CW2(R2)	; SET RP07 SIZE
	MOV	#133500,U.CW3(R2) ; AND EXIT
	BR	MAINXT
DLDEV:	CMP	(R0),#"DL	; DL DEVICE ?
	BNE	MAINXT		; NO, EXIT
	MOV	#24000,U.CW3(R2)	; ASSUME RL01
	MOV	#13,4(R1)	; LOAD MESSAGE CODES
	SWAB	R3		; POSITION UNIT NO.
	BIS	#4,R3		;MERGE GET STATUS FCN.
	MOV	R3,(R1)		;GET DRIVE STATUS
5$:	TSTB	(R1)		; WAIT
	BPL	5$
	BIT	#200,6(R1)	; IS IT RL02 ?
	BEQ	MAINXT		; NO, EXIT
	ASL	U.CW3(R2)	; DOUBLE SIZE IN UCB
				; AND FALL THRU TO EXIT
MAINXT:	MOVB	U.CW2(R2),$CW2		;STORE DEV.SIZE
	MOV	U.CW3(R2),$CW3
	GOTO LVSIZ
TRAPA:   LET 2(SP) := 2(SP) SET.BY #1	;SET C BIT
	RTI				;AND RETURN
LVSIZ:	POP	R3			;RESTORE R3
	.ENDC
 	  LET $IFLAG := $IFLAG SET.BY #KY.DSK
	  IF #KY.TAP SET.IN $IFLAG THEN ERROR ER.CDV
	  LET V.FRBK(R0) := $CW3
	  LET V.FRBK+2(R0) :B= $CW2
	
CONT3:
	LET DEVPT := DEVPT + #V.SIZ-2
	LET @VNUM := @VNUM + #1
	RETURN
;
; STORE LABEL STRING
;
SETLAB:	LET R0 := .PSTCN		; GET BYTE COUNT
	IF R0 GT #12. THEN ERROR ER.LAB
	LET R1 := .PSTPT
	LET R2 := VNUM			; ADDRESS OF LABEL BUFFER
	TST (R2)+			; FOLLOWS UNIT COUNT
	THRU R0
	  LET (R2)+ :B= (R1)+		; COPY LABEL
	END LOOP
	LET R0 := #12. - .PSTCN		; COMPUTE UNUSED SPACE
	IF RESULT IS GT
	  THRU R0
	    LET (R2)+ :B= #40		; PAD WITH BLANKS
	  END LOOP
	END
	RETURN
;
; SET SPLIT TAPE DENSITY - 800/1600
;
SET16B:	LET $IFLAG := $IFLAG SET.BY #KY.160
	RETURN
;
; SET NO MERGE MODE
;
SETNMG:	LET $OFLAG := $OFLAG OFF.BY #KY.MRG
	LET $IFLAG := $IFLAG OFF.BY #KY.MRG
	RETURN

	.IF	DF,R$$11S

LOCUCB:	PUSH R3		;SAVE R3
	LET R1 :=	$DEVHD	;R1 POINTS AT 1ST DCB
	REPEAT
CONT:
		IF (R0) EQ D.NAM(R1) LEAVE LOOP
		;THIS MAY BE CORRECT DCB
		LET R1 :=	D.LNK(R1)
		;R1 POINTS AT NEXT DCB
		IF R1 EQ #0 THEN ERROR ER.DEV
		;DEVICE NOT IN SYSTEM
	END LOOP
		IFB 2(R0) LO D.UNIT(R1) THEN GOTO CONT
		IFB 2(R0) HI D.UNIT+1(R1) THEN GOTO CONT
		;IF EITHER TEST FAILED,WRONG DCB
	LET R2 := D.UCB(R1)	;R2 POINTS AT 1ST UCB
	LET R3 :B= D.UNIT(R1)		;R3 IS LOW UNIT NO.
	NEG  R3				;R3 IS NEG. OF LOW UNIT NO.
	LET R3 := R3 + 2(R0)		;R3 IS REL. UNIT NO.
	REPEAT
		IF  R3 EQ #0 LEAVE LOOP  ;CORRECT UCB
		LET R3 := R3 - #1	;DECR.R3
		LET R2 := R2 + D.UCBL(R1)	;NEXT UCB
	END LOOP
	LET $UCBAD := R2		;STORE UCB ADDRESS
	POP R3
	RETURN
STUNI:
	LET R2 := $UCBAD	;R2 POINTS AT UCB
	LET U.UNIT(R2) :B= .PNUMB ;STORE UNIT NO.
	LET $FLAG1 := $FLAG1 SET.BY #KY.NCP ; SET NON-COPY COMMAND
	RETURN
STVEC:
	IF .PNUMB HI #376 THEN ERROR ER.VEC
	LET R2 := .PNUMB
	LET R2 := R2 OFF.BY #177774 ;MULTIPLE OF 4?
	IF R2 NE #0 THEN ERROR ER.VEC
		;IF EITHER TEST FAILED,ILLEGAL VECTOR
	LET R1 := #DEVTAB
	LET R0 := DEVPT - #V.SIZ	;R0 POINTS AT DEV. NAME
	REPEAT
		IF (R0) EQ (R1)+ LEAVE LOOP ;R1 POINTS AT CORRECT 
						;INTERUPT ADDRESS
	LET R1 := R1 + #2		;NEXT ENTRY IN TABLE
	IF R1 HI #DEVEND THEN ERROR ER.DEV
		;DEVICE NOT IN TABLE
	END LOOP
	LET INTADD := (R1)	;	STORE INTERRUPT ADDRESS
	PUSH R3
	LET R3 := $UCBAD
	LET R3 := U.SCB(R3)	;SCB ADDRESS
	LET R1 :B= S.VCT(R3)	;OLD VECT.ADDR./4
	LET R1 := R1 OFF.BY #177400
	LET R1 := R1 L.SHIFT 2	;ABSOLUTE ADDR
	LET R2 := .PNUMB	;R2 HAS NEW VECTOR
	LET (R1) := #$NONSI	;KILL INTERRUPT AT OLD ADDR
	LET (R2)  :=   INTADD ;STORE INT ADDR AT NEW VECTOR
	LET R2 := R2 R.SHIFT 2	;DIVIDE NEW VECT BY 4
	LET S.VCT(R3) :B= R2	;STORE NEW VECT IN SCB
	LET $FLAG1 := $FLAG1 SET.BY #KY.NCP ; SET NON-COPY COMMAND
	POP R3
	RETURN
STCSR:
	LET R1 := $UCBAD	;UCB ADDRESS
	LET PS :B= #PR7
	;LOCK OUT INTRPTS
	PUSH @#4		;SAVE INTRPT ADDRESS
	LET @#4 := #CONT2		;SET TRAP ADDRESS
	TST @.PNUMB		;SEE IF DEV. IS THERE
	BCC CONT1
			;YES BRANCH
	LET U.ST2(R1) :B= U.ST2(R1) SET.BY #US.OFL
	;SET DEV OFFLINE
	POP @#4			;RESTORE INTRPT ADDRESS
	LET PS :B= #0		;ENABLE INTRPTS
	ERROR ER.CSR
	;INVALID CSR
CONT1:	LET U.ST2(R1) :B= U.ST2(R1) OFF.BY #US.OFL
	;SET DEVICE ON LINE
	POP @#4			;RESTORE INTRPT ADDRESS
	LET PS :B= #0		;DROP PRIORITY
	LET R1 := U.SCB(R1)	;SCB ADDRESS
	LET S.CSR(R1) := .PNUMB	;STORE CSR IN SCB
	LET $FLAG1 := $FLAG1 SET.BY #KY.NCP ; SET NON-COPY COMMAND
	RETURN
	;ON INVALID CSR, TRAP TO HERE		;SET CARRY BIT IN SAVED PS
CONT2:	 LET 2(SP) := 2(SP) SET.BY #1
	RTI			;RETURN TO BCC CONT1
STTM2:	LET R1 := DEVPT - #V.SIZ	;R1 POINTS AT DEV. NAME
	IF (R1) NE MMDEV THEN ERROR ER.TM2
		;TM02 VALID ONLY ON MM DEVICES
	LET R1  := $UCBAD		;UCB ADDRESS
	IF .PNUMB HI #7 THEN ERROR ER.TM2
	LET U.CNT+2(R1) := .PNUMB	;STORE TM02 IN UCB
	LET $FLAG1 := $FLAG1 SET.BY #KY.NCP ; SET NON-COPY COMMAND
	RETURN
	.ENDC
	.END


