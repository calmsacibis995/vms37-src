	$BEGIN	DRDSU,0024,<READ VOLUME SUMMARY FROM DISK>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  3-AUG-78  16:12
;
; ANDREW C. GOLDSTEIN  28-FEB-1980  23:28
; ACG0151 - ADD CONDITIONAL ASSEMBLY FOR 11M VERSION
;
; ANDREW C. GOLDSTEIN  16-OCT-1979  19:49
; ACG0052 - FORMAT CHANGE OF CME DISK SIZE
;
; 001 11-MAR-77 G.RITTENBURG PARAMETER MISSING $GLUNC
;  002  11-MAR-77 G.RITTENBURG CONDITIONAL FOR 11D AND IAS INSERTED

;CORRECTED 1/27/77 G.RITTENBURG

; GR001--- G.RITTENBURG JAN.3,1978
; CORRECTION TO ALLOW DEFAULT TO FIRST FILE FOUND ON TAPE FROM CURRENT
; POSITION OF TAPE WHEN COMPARING TAPE OUTPUT AGAINST DISK AND NO TAPE
; FILESPEC IS SPECIFIED FOR TAPE.CORRECTION FROM 11M DSC
;
	.IF	NDF,R$$NVX
	.MCALL	GLUN$C,HMBL2$
	HMBL2$				; DEFINE HOME BLOCK LAYOUT
	.IFF
	.MCALL	GLUN$C
	.ENDC

;+
;
; *** - $DRDSU	READ VOLUME SUMMARY, DISK
;
; THIS ROUTINE RUMMAGES ABOUT THE DISK AND CONSTRUCTS THE VOLUME
; SUMMARY BLOCK IN THE I/O BUFFER.
;
; INPUTS:
;
;	INLUN ASSIGNED TO DESIRED DISK UNIT
;
; OUTPUTS:
;
;	SUMMARY BLOCK IN $BUF2
;	INDEX FILE HEADER IN $IXBF AND $IHBF
;	CURRENT ENTRY IN $IVTAB FILLED IN
;
;-

$DRDSU::
	GLUN$C	INLUN, $LUNBF		; GET VOLUME SIZE
	.IF	NDF,R$$NVX
	.IF	NDF,R$$11M
	GGOM$C	INLUN, $DEVGM		; GET DEVICE GEOMETRY
	.ENDC
	$CALL	$CMEFX			; REARRANGE GEOMETRY INFO IN LUNBUF.
	.ENDC
;
; FIRST SEARCH FOR THE HOME BLOCK
;
	$CALL	$DELTA			; COMPUTE HOME BLOCK SEARCH DELTA.
	LET R4 := #$B1HD		; USE I/O BUFFER #1
	LET R2 := #0			; START WITH LBN 1
	LET R3 := #1
	REPEAT
	  $CALL $RDW1B <,,R2,R3,R4>	; READ A BLOCK
	  ON.NOERROR
	    $CALL $CKSM1 <,#H.CHK1/2,,,,R5> ; COMPUTE FIRST CHECKSUM
	    ON.NOERROR
	      $CALL $CKSUM <,,,,,R5>	; COMPUTE SECOND CHECKSUM
	      ON.NOERROR		; DO FURTHER CHECKING.
		IF H.HBLB(R5) EQ R3 AND H.HBLB+2(R5) EQ R2
		  IF H.SBCL(R5) NE #0 AND H.HBVB(R5) NE #0 AND H.AHVB(R5) NE #0
		    IF H.IHVB(R5) NE #0 AND H.IBSZ(R5) NE #0 AND H.RSVF(R5) NE #0
		      LET R0 := H.IBLB(R5) SET.BY H.IBLB+2(R5)
		      IF RESULT IS NE
			LET R0 := H.FMAX(R5) SET.BY H.FMAX+2(R5)
			IF RESULT IS NE
			  LEAVE LOOP	; GOOD HOME BLOCK
			END
		      END
		    END
		  END
		END
	      END
	    END
	  ELSE				; IF I/O ERROR
	    IFB (R4) NE #IE.VER		; RETRY ONLY ON PARITY ERROR
	      				;ABOVE LINE CORRECTED 1-14-77 WAS 2(R4)
	      ERROR ER.IIR		; REPORT ALL OTHER ERRORS
	    END
	  END
	  LET  R3  :=  R3  +  $HBDLT	; TRY NEXT BLOCK IN SEARCH SEQ.
	  LET R2 := R2 + CARRY
	  LET  R2  :=  R2  +  $HBDLT+2
	  DCOMP R2,R3, $CW2,$CW3	; CHECK AGAINST VOLUME LIMIT
	  IF RESULT IS HI THEN ERROR ER.NHO
	  LET B.STAT(R4) := #0		; INVALIDATE THE BUFFER
	END LOOP
	LET $HOMLB := R3		; SAVE HOME BLOCK LBN
	LET $HOMLB+2 := R2

;
; WE HAVE FOUND THE VOLUME'S HOME BLOCK. DO FURTHER VALIDATION
; AND EXTRACT THE RELEVANT DATA.
;
	IF H.VLEV(R5) NE #1001 THEN ERROR ER.LEV  ; CHECK STRUCTURE LEVEL
	LET R3 := $INDEV		; GET POINTER INTO DEVICE TABLE
	LET V.RVN(R3) := H.RVN(R5)	; RELATIVE VOLUME NUMBER
	LET V.IBSZ(R3) := H.IBSZ(R5)	; INDEX FILE BITMAP SIZE
	LET V.IBLB(R3) := H.IBLB(R5)	; INDEX FILE BITMAP LBN
	LET V.IBLB+2(R3) := H.IBLB+2(R5)
	LET V.CLF(R3) := H.SBCL(R5)	; CLUSTER FACTOR
;
; DEFAULT THE FILE NAME TO THE VOLUME LABEL IF FORMER IS NULL
;
	LET R0 := #$OLAB		; POINT TO FILE NAME
	IFB (R0) EQ #0			; IF NULL
	  IF #KY.TAP SET.IN $OFLAG AND #KY.CMP SET.IN $OFLAG
		LET R1 := #0
	  ELSE
  		LET R2 := R5 + #H.INDN	; DEFAULT TO VOLUME NAME
		THRU R1 := #12.
		    LET (R0)+ :B= (R2)+		; COPY IN FILE NAME
		    IF RESULT IS EQ LEAVE LOOP	; NULL IS A TERMINATOR
		END LOOP
		IF R1 GT #0
		    LET R0 := R0 - #1		; BACK UP TO NULL
		    THRU R1
		      LET (R0)+ :B= #40		; PAD WITH BLANKS
		    END LOOP
		END
	  END
  	END
;
; INIT THE BUFFER WITH THE SUMMARY BLOCK PREAMBLE AND CLEAR THE REST
; ***** WARNING! THE FOLLOWING CODE ASSUMES THE FORMAT OF THE VOLUME
; ***** SUMMARY BLOCK AS DOCUMENTED IN THE ROOT MODULE.
;
	$CALL $BUFCK <,,,,#$B2HD>	; OBTAIN 2ND I/O BUFFER
	LET B.STAT(R4) := #1		; MARK BUFFER BUSY
	LET R0 := #$BUF2
	LET (R0)+ := #512.		; BYTE COUNT IS 512
	LET (R0)+ := #PF.SUM		; FLAG AS A SUMMARY BLOCK
	THRU R1 := #256.+<P.SIZ/2>-2
	  LET (R0)+ := #0		; ZERO THE REST OF THE PREAMBLE AND BLOCK
	END LOOP
	LET R0 := #$B2DAT+S.NAME	; FIRST CELL IS FILE NAME
	LET R2 := #$OLAB		; POINT TO USER FILE NAME
	THRU R1 := #12.
	  LET (R0)+ :B= (R2)+		; COPY IN FILE NAME
	END LOOP

	LET (R0)+ := V.DVNM(R3)		; COPY IN DEVICE NAME
	LET R1 := V.DVUN(R3)		; GET UNIT NUMBER
	$CALL $CBOMG <R0,R1,#0>		; CONVERT TO OCTAL
	THRU R1 := #$B2DAT+S.SNAM - R0
	  LET (R0)+ :B= #40		; PAD NAME WITH BLANKS
	END LOOP

	LET R2 := R5 + #H.SNAM		; POINT TO STRUCTURE NAME
	THRU R1 := #12.
	  LET (R0)+ :B= (R2)+		; COPY STRUCTURE NAME
	END LOOP
	LET R2 := R5 + #H.INDN		; POINT TO VOLUME NAME
	THRU R1 := #12.
	  LET (R0)+ :B= (R2)+		; COPY VOLUME NAME
	END LOOP

	LET (R0)+ := H.RVN(R5)		; STORE RELATIVE VOLUME NUMBER
	LET (R0)+ := H.NVOL(R5)		; AND NUMBER OF VOLUMES IN SET
	LET (R0)+ := H.SBCL(R5)		; AND CLUSTER FACTOR
	LET (R0)+ := $CW3		; VOLUME SIZE
	LET (R0)+ := $CW2
	LET (R0)+ := $CW3		; INIT SPACE USED TO VOLUME SIZE
	LET (R0)+ := $CW2
	LET R0 := #$B2DAT+S.IBSZ
	LET (R0)+ := H.IBSZ(R5)		; STORE INDEX FILE BITMAP SIZE
	LET (R0)+ := H.IBLB(R5)	; STORE INDEX FILE BITMAP LBN
	LET (R0)+ := H.IBLB+2(R5)
	LET (R0)+ := #BLKF		; TAPE BLOCKING FACTOR
	IF #KY.MRG SET.IN $OFLAG	; RECORD MERGE MODE FLAG
	  LET (R0)+ := #1
	ELSE
	  LET (R0)+ := #0
	END
	LET $B1HD+B.STAT := #0		; INVALIDATE THE HOME BLOCK

;
; SCAN THE INDEX FILE BITMAP TO DETERMINE THE NUMBER OF FILES AND
; THE HIGHEST FILE NUMBER
;
	PUSH V.IBSZ(R3)			; STORE NUMBER OF BLOCKS TO SCAN
	LET $LBN := V.IBLB(R3)		; GET STARTING LBN
	LET $LBN+2 := V.IBLB+2(R3)
	LET R2 := #0			; INIT FILE NUMBER
	LET R3 := #0
	FOR (SP) := (SP) DOWNTO #0
	  PUSH R2,R3
	  $CALL $RDW1B <,,$LBN+2,$LBN,#$B1HD> ; READ A BLOCK
	  POP R3,R2			; RESTORE FILE NUMBER
	  ON.ERROR THEN ERROR ER.IXB
	  LET R0 := #0
	  REPEAT
	    LET R1 := (R5)+		; GET NEXT BITMAP WORD
	    REPEAT
	      LET R3 := R3 + #01	; BUMP TO NEXT FILE NUMBER
	      LET R2 := R2 + CARRY
	      LET R1 := R1 R.ROTATE 1	; COUNT A BIT
	      IF RESULT IS CS		; IF SET
		LET $B2DAT+S.HFNU := R3	; SAVE FILE NUMBER
		LET $B2DAT+S.HFNU+2 := R2
		LET R0 := R0 + #1	; AND COUNT IT
	      END
	    UNTIL #17 OFF.IN R3		; REPEAT FOR WORD
	  UNTIL #7777 OFF.IN R3		; REPEAT FOR BLOCK
	  LET $B2DAT+S.NFIL := $B2DAT+S.NFIL + R0 ; ACCUMULATE # FILES
	  LET $B2DAT+S.NFIL+2 := $B2DAT+S.NFIL+2 + CARRY
	  LET $LBN := $LBN + #01	; BUMP BLOCK NUMBER
	  LET $LBN+2 := $LBN+2 + CARRY
	  LET B.STAT(R4) := #0		; DISCARD THE BUFFER
	END LOOP
	TST (SP)+			; CLEAN THE STACK

;
; NOW READ THE INDEX FILE HEADER AND RECORD THE INDEX FILE SIZE
; NOTE THAT $LBN HAS BEEN BUMPED TO THAT OF THE INDEX FILE HEADER.
; WHICH IS STORED CONTIGUOUS WITH THE INDEX FILE BITMAP.
;
	IF #KY.NIP  SET.IN  $FLAG1	; IF READING FROM OUTPUT DEVICE.
		LET R4 := #$OXHD
	ELSE
		LET R4 := #$IXHD
	END
	$CALL $RDW1B <,,$LBN+2,$LBN,R4> ; READ INDEX FILE HEADER
	ON.ERROR THEN ERROR ER.IXH
	$CALL $FILSZ <,,,,,R5>		; COMPUTE INDEX FILE SIZE
	LET $B2DAT+S.IFSZ := R1		; AND STORE IN SUMMARY
	LET $B2DAT+S.IFSZ+2 := R0
;
; SCAN THE STORAGE MAP AND COMPUTE THE NUMBER OF FREE BLOCKS ON THE
; VOLUME.
;
	$CALL $RDHDR <,,#0,#2>		; READ THE STORAGE MAP HEADER
	ON.ERROR THEN ERROR ER.SMH
	$CALL $MPVBN <,,#0,#2,,R5>	; MAP START OF BITMAP
	IF #KY.NIP SET.IN $FLAG1	; IF READING OUTPUT DEVICE
		LET R5 := $OUDEV
	ELSE 
		LET R5 := $INDEV	; POINT TO DEVICE TABLE
	END
	LET V.SBSZ(R5) := R1		; SAVE STORAGE MAP SIZE
	LET V.SBLB(R5) := R3		; AND LBN
	LET V.SBLB+2(R5) := R2
	PUSH R1
	FOR (SP) := (SP) DOWNTO #0	; FOR ALL BLOCKS IN BITMAP.
	  $CALL $RDW1B <,,R2,R3,#$B1HD>	; READ A BITMAP BLOCK
	  ON.ERROR THEN ERROR ER.SMB
	  LET B.STAT(R4) := #0		; INVALIDATE THE BUFFER WHILE WE HAVE A POINTER
	  THRU R0 := #256.		; SCAN THE BLOCK
	    LET R4 := (R5)+		; GET NEXT WORD
	    THRU R1 := #16.		; SCAN THE WORD
;
; DEDUCT FREE CLUSTERS FROM THE BLOCKS IN USE COUNT.
;
	      ROR  R4			; PICK OFF A BIT.
	      IF  RESULT  IS  CS	; FREE CLUSTER ?
	        SUB  $CLF,$B2DAT+S.USE	; DEDUCT 1 CLUSTER.
	        SBC  $B2DAT+S.USE+2
	      END
	    END LOOP
	  END LOOP
	  LET R3 := R3 + #01		; BUMP TO NEXT BLOCK
	  LET R2 := R2 + CARRY
	END LOOP
	TST (SP)+			; CLEAN THE STACK

	LET $IHHD+B.STAT := #0		; RELEASE HEADER BUFFER
	$CALL $RDHDR <,,#0,#3>		; READ BAD BLOCK FILE HEADER
	$CALL $FILSZ <,,,,,R5>		; COMPUTE FILE SIZE
	LET $B2DAT+S.USE := $B2DAT+S.USE - R1 ; DEDUCT FROM SPACE USED
	LET $B2DAT+S.USE+2 := $B2DAT+S.USE+2 - CARRY - R0

	;1/27/77 2 MINUS SIGNS REPLACED + SIGNS

	$CALL $CKSUM <,,,,,#$B2DAT>	; COMPUTE THE BLOCK CHECKSUM

	LET R0 := #$B2DAT+512.		; POINT TO END OF SUMMARY DATA
	IF #KY.NIP SET.IN $FLAG1	; IF READING FROM OUTPUT DEVICE
		LET R1 := #$OXBF
	ELSE
		LET R1 := #$IXBF	; AND TO INDEX FILE HEADER
	END
	LET R3 := #$IHBF		; AND TO HEADER BUFFER
	THRU R2 := #256.
	  LET (R0)+ := (R1)		; APPEND IT TO SUMMARY DATA
	  LET (R3)+ := (R1)+		; ALSO COPY TO HEADER BUFFER
	END LOOP

	IF #KY.NIP SET.IN $FLAG1	; IF TAPE O.P.
		LET R5 := $OUDEV
	ELSE
		LET R5 := $INDEV	; POINT TO DEVICE TABLE
	END
	LET V.FRBK(R5) := $CW3 - $B2DAT+S.USE ; COMPUTE FREE SPACE
	LET V.FRBK+2(R5) := $CW2 - CARRY - $B2DAT+S.USE+2
	RETURN





;
; COMPUTE THE DEVICE DEPENDENT HOME BLOCK SEARCH/PLACEMENT OFFSET.
;
$DELTA::
	MOV  #1,$HBDLT			; INITIALIZE DELTA.
	CLR  $HBDLT+2
	IF  $CYL  HI  #1  AND  $TRAK  HI  #1  ; MULTI CYL AND MULTI TRACK ?
	  ADD  $TRAK,$HBDLT		; INCR BY TRACKS PER CYLINDER.
	END
	IF  $SECT  HI  #1		; MULTIPLE SECTORS PER TRACK ?
	  IF  $CYL  HI  #1  OR  $TRAK  HI  #1  ; MULTI CYLINDER OR MULTI TRACK ?
	    $CALL  $MUL  <$SECT,$HBDLT>	; SECT PER TRACK * TRACKS PER CYLINDER.
	    ADD  $BFACT,R1
	    ADC  R0
	    MOV  R1,R2
	    MOV  R0,R1
	    $CALL  $DDIV <$BFACT,R1,R2> ; DIVIDE DELTA DOWN BY BLOCK FACTOR
	    MOV  R2,$HBDLT		; SAVE DELTA.
	    MOV  R1,$HBDLT+2
	  END
	END
	LET R0 := $HBDLT SET.BY $HBDLT+2
	IF RESULT IS EQ GOTO USE1
	$CALL $DDIV <#10.,$CW2,$CW3>
	DCOMP $HBDLT+2,$HBDLT, R1,R2
	IF RESULT IS HI
USE1:	  LET $HBDLT := #1
	  LET $HBDLT+2 := #0
	END
	RETURN


;
; REARRANGE THE GEOMETRY INFO IN $LUNBF FROM STARLET CME FORMAT TO
; RSX-11M FORMAT. ALSO, SET UP $CYL, $TRAK AND $SECT.
;
	.IF	NDF,R$$11M
$CMEFX::
	CLRB	$LUNBF+3		; CLEAR JUNK OFF UNIT NUMBER
	MOVB	$DEVGM,$SECT		; SAVE DEVICE GEOMETRY
	CLRB	$SECT+1
	MOVB	$DEVGM+1,$TRAK
	CLRB	$TRAK+1
	MOV	$DEVGM+2,$CYL
	CLRB	$CW2+1

	$CALL	$MUL <$SECT,$TRAK>	; MULTIPLY UP GEOMETRY
	MOV	R1,R3			; TO COMPUTE NUMBER
	MOV	R0,R2			; OF PHYSICAL BLOCKS
	$CALL	$DMUL <$CYL,,R2,R3>
	MOV	R1,R3
	MOV	R0,R2
	$CALL	$DIVD <$CW2,$CW3,R2,R3>	; DIVIDE BY LOGICAL SIZE
	MOV	R3,$BFACT		; TO COMPUTE BLOCKING FACTOR
	RETURN

;
; IF RUNNING UNDER 11M, THE DEVICE GEOMETRY IS NOT AVAILABLE. WE GET IT
; INSTEAD FROM THE FOLLOWING DEVICE TABLE.
;

	.IFF

;
; DEVICE DATA TABLE, CONTAINING DEVICE GEOMETRY, SIZE, AND BLOCKING FACTOR
; FOR ALL KNOWN DEVICES.
;
	.MACRO	.LONG	WORD
	$$$B1=0
	$$$B2=0
	$$$B3=0
	$$$B4=0
	.IRPC	D,WORD
	$$$B1=$$$B1*10.+D'.
	$$$C=$$$B1/256.
	$$$B1=$$$B1&^O377
	$$$B2=$$$B2*10.+$$$C
	$$$C=$$$B2/256.
	$$$B2=$$$B2&^O377
	$$$B3=$$$B3*10.+$$$C
	$$$C=$$$B3/256.
	$$$B3=$$$B3&^O377
	$$$B4=$$$B4*10.+$$$C
	$$$C=$$$B4/256.
	$$$B4=$$$B4&^O377
	.ENDM
	$$$H=$$$B4*256.+$$$B3
	$$$L=$$$B2*256.+$$$B1
	.WORD	$$$L,$$$H
	.ENDM	.LONG

	.MACRO	DEVDAT	SECT,TRACK,CYL,SIZE,BFACT
	.LONG	SIZE
	.WORD	SECT'.,TRACK'.,CYL'.,BFACT'.
	.ENDM	DEVDAT

DEVTAB:
	DEVDAT	  1    1   578      578  1	; DECtape
	DEVDAT	128    4     1      512  1	; TU58
	DEVDAT	 26    1    77      494  4	; RX01
	DEVDAT	 26    1    77      988  2	; RX02
	DEVDAT	 26    2    77     1989  2	; RX??
	DEVDAT	 12    2   200     4800  1	; RK05
	DEVDAT	 40    2   256    10240  2	; RL01
	DEVDAT	 40    2   512    20480  2	; RL02
	DEVDAT	 22    3   411    27126  1	; RK06
	DEVDAT	 22    3   815    53790  1	; RK07
	DEVDAT	 10   20   200    40000  1	; RP02
	DEVDAT	 10   20   400    80000  1	; RP03
	DEVDAT	 32    5   823   131680  1	; RM02/3
	DEVDAT	 22   19   411   171798  1	; RP04/5
	DEVDAT	 22   19   815   340670  1	; RP06
	DEVDAT	 31   14   559   242606  1	; RM80
	DEVDAT	 32   19   823   500384  1	; RM05
	DEVDAT	 50   32   630  1008000  1	; RP07
	.LONG	0

;
; THE FOLLOWING SUBROUTINE SEARCHES THE DEVICE TABLE FOR AN ENTRY WHOSE
; SIZE MATCHES THAT IN THE DEVICE CHARACTERISTICS, AND SETS UP THE GEOMETRY
; DATA.
;

$CMEFX::
	CLRB	$LUNBF+3		; CLEAR JUNK OFF UNIT NUMBER
	CLRB	$CW2+1			; CLEAR HIGH ORDER JUNK IN DISK SIZE
	MOV	#DEVTAB,R0		; POINT TO DEVICE TABLE

10$:	MOV	(R0),R1			; CHECK FOR ZERO ENTRY
	BIS	2(R0),R1
	BEQ	40$			; WHICH MEANS END OF TABLE
	CMP	$CW3,(R0)+		; COMPARE TABLE ENTRY AGAINST DEV CHAR
	BNE	20$
	CMP	$CW2,(R0)+		; COMPARE HIGH ORDER
	BEQ	30$			; MATCH - DO IT

	TST	-(R0)			; BACK UP FOR CONSISTENCY
20$:	ADD	#10.,R0			; BUMP TO NEXT TABLE ENTRY
	BR	10$			; AND LOOP

;
; FOUND A TABLE ENTRY
;
30$:	MOV	(R0)+,$SECT		; GET SECTORS
	MOV	(R0)+,$TRAK		; AND NUMBER OF TRACKS
	MOV	(R0)+,$CYL		; AND CLYINDERS
	MOV	(R0)+,$BFACT		; AND BLOCKING FACTOR
	RETURN				; EASY, ISN'T IT?

;
; DEVICE NOT FOUND
;
40$:	MOV	#$LUNBF,R0		; POINT TO GET LUN BUFFER
	ERROR	ER.F11			; SIGNAL ERROR

	.ENDC


	.END
