	.TITLE	$GDTIM - GET DATE AND TIME FROM SYSTEM

	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  17 JUN 76  17:17

	SMACIT

	.MACRO	$SAVRG
	JSR	R5,$SAVRG
	.ENDM	$SAVRG

	.MCALL	GTIM$S



	.MACRO	.QUAD	WORD
	$$$B1=0
	$$$B2=0
	$$$B3=0
	$$$B4=0
	$$$B5=0
	$$$B6=0
	$$$B7=0
	$$$B8=0
	.IRPC	D,WORD
	$$$B1=$$$B1*10.+D'.
	$$$C=$$$B1/256.
	$$$B1=$$$B1&^O377
	$$$B2=$$$B2*10.+$$$C
	$$$C=$$$B2/256.
	$$$B2=$$$B2&^O377
	$$$B3=$$$B3*10.+$$$C
	$$$C=$$$B3/256.
	$$$B3=$$$B3&^O377
	$$$B4=$$$B4*10.+$$$C
	$$$C=$$$B4/256.
	$$$B4=$$$B4&^O377
	$$$B5=$$$B5*10.+$$$C
	$$$C=$$$B5/256.
	$$$B5=$$$B5&^O377
	$$$B6=$$$B6*10.+$$$C
	$$$C=$$$B6/256.
	$$$B6=$$$B6&^O377
	$$$B7=$$$B7*10.+$$$C
	$$$C=$$$B7/256.
	$$$B7=$$$B7&^O377
	$$$B8=$$$B8*10.+$$$C
	$$$C=$$$B8/256.
	$$$B8=$$$B8&^O377
	.ENDM
	$$$W1=$$$B2*256.+$$$B1
	$$$W2=$$$B4*256.+$$$B3
	$$$W3=$$$B6*256.+$$$B5
	$$$W4=$$$B8*256.+$$$B7
	.LIST	MEB
	.WORD	$$$W1,$$$W2
	.WORD	$$$W3,$$$W4
	.NLIST	MEB
	.ENDM	.QUAD

;
; SOME CONSTANTS
;

	.RADIX	10

Q24:	.QUAD	24		; HOURS IN A DAY
Q60:	.QUAD	60		; MINUTES PER HOUR AND SECONDS PER MINUTE
QNS:	.QUAD	10000000	; TENTHS OF MICROSECONDS IN A SECOND

FDAYS = 365*4+1			; NUMBER OF DAYS IN 4 YEARS
CDAYS = FDAYS*25-1		; NUMBER OF DAYS IN A CENTURY
QDAYL = 15025			; NUMBER OF DAYS IN QUADRICENTURY, LOW
QDAYH = 2			; NUMBER OF DAYS IN QUADRICENTURY, HIGH
DS16L = 28652			; NUMBER OF DAYS BETWEEN 1-JAN-1601 AND
DS16H = 1			; 17-NOV-1858, LOW AND HIGH


	.RADIX

;+
;
; *** - $GDTIM	GET DATE AND TIME FROM SYSTEM
;
; THIS ROUTINE RETURNS THE CURRENT DATE AND TIME OBTAINED FROM
; THE OPERATING SYSTEM IN THE STANDARD DATE/TIME FORMAT - 64 BITS
; OF TENS OF NANO-SECONDS ELAPSED SINCE 17-NOV-1858.
;
; INPUTS:
;
;	R1 = ADDRESS OF 8 BYTE BUFFER FOR DATE/TIME
;
; OUTPUTS:
;
;	DATE/TIME IN SPECIFIED BUFFER
;	R2 = 0
;	ALL OTHER REGISTERS PRESERVED
;
;-

$GDTIM::
	$SAVRG				; SAVE REGISTERS
	PUSH R0,R1,#0
	LET SP := SP - #16.		; ALLOCATE DATE/TIME BUFFER ON STACK
	LET R1 := SP
	GTIM$S R1			; GET DATE AND TIME FROM SYSTEM
	LET (SP) := (SP) + #1900.	; PUT IN TRUE YEAR


;+
;
; *** - $CBDDT	CONVERT TO STANDARD DATE AND TIME
;
; THIS ALTERNATE ENTRY POINT IS USED BY THE ROUTINE $CATDT TO COMPLETE
; ITS CONVERSION. $CATDT PARSES THE ASCII DATE/TIME STRING INTO THE
; SAME FORMAT AS THAT RETURNED ABOVE, AND FALLS INTO THIS CODE FOR THE
; FINAL CONVERSION. THIS ENTRY IS JUMPED TO. ON ENTRY, THE STACK CONTAINS:
;
;	00(SP) - CALENDAR YEAR
;	02(SP) - MONTH (NUMBERED 1 - 12)
;	04(SP) - DAY (NUMBERED 1 - 31)
;	06(SP) - HOUR OF DAY
;	10(SP) - MINUTE OF HOUR
;	12(SP) - SECOND OF MINUTE
;	14(SP) - TICK OF SECOND
;	16(SP) - CLOCK RATE (TICKS PER SECOND)
;	20(SP) - SAVED R2
;	22(SP) - SAVED R1
;	24(SP) - SAVED R0
;	26(SP) - RETURN PC (TO $SAVRG ROUTINE)
;
; BASIC THEORY OF OPERATION:
;
; THIS ROUTINE ACCOUNTS FOR THE BASIC LEAP YEAR CYCLES - EVERY FOURTH
; YEAR IS, EXCEPT EVERY 100TH ISN'T, EXCEPT EVERY 400TH IS. YEAR
; 2000 IS A LEAP YEAR. THE CALENDAR YEAR IS CONVERTED TO YEARS SINCE
; 1601, MAKING THE LEAP YEAR UNDER DISPUTE THE LAST YEAR OF EACH OF
; THE 4, 100, AND 400 YEAR CYCLES. BY DIVIDING DOWN, WE COMPUTE THE
; INTEGER NUMBER OF EACH TYPE OF CYCLE ELAPSED SINCE 1601. EACH VALUE
; IS THEN MULTIPLIED BY THE EXACT NUMBER OF DAYS IN THAT CYCLE. THE
; SUM, REDUCED BY THE EXACT NUMBER OF DAYS FROM 1-JAN-1601 TO
; 17-NOV-1858, YIELDS THE NUMBER OF DAYS ELAPSED SINCE 17-NOV-1858.
;
;-

$CBDDT::
	LET R5 := 22(SP)		; POINT TO LOCATION OF DATE/TIME
	LET R3 := R5
	LET (R3)+ := #0			; INIT BUFFER CONTENTS
	LET (R3)+ := #0
	LET (R3)+ := #0
	LET (R3)+ := #0

	IF #1 OFF.IN 20(SP)		; SKIP DATE CONVERSION IF NONE
	  LET R4 := #1			; INIT LEAP YEAR FLAG TO NO
	  $CALL $DIV <(SP),#400.>	; EVERY 400TH IS A LEAP YEAR
	  IF R1 EQ #0
	    LET R4 := #0
	  ELSE
	    $CALL $DIV <(SP),#100.>	; EVERY 100TH IS NOT
	    IF R1 NE #0
	      $CALL $DIV <(SP),#4>	; AND EVERY 4TH IS
	      IF R1 EQ #0 THEN LET R4 := #0
	    END
	  END

	  LET R0 := (SP)+ - #1601.	; GET YEAR SINCE 1601
	  $CALL $DIV <R0,#400.>		; COMPUTE NUMBER OF QUADRICENTURIES
	  PUSH R0			; AND SAVE THAT
	  $CALL $DIV <R1,#100.>		; COMPUTE NUMBER OF CENTURIES
	  PUSH R0			; AND SAVE
	  $CALL $DIV <R1,#4.>		; COMPUTE NUMBER OF QUAD YEARS
	  PUSH R0			; AND SAVE

	  $CALL $MUL <#365.,R1>		; NUMBER OF DAYS SINCE LAST LEAP YEAR
	  LET (R5) := R1
	  $CALL $MUL <#FDAYS,(SP)+>	; NUMBER OF DAYS IN CENTURY
	  LET (R5) := (R5) + R1
	  $CALL $MUL <#CDAYS,(SP)+>	; NUMBER OF DAYS IN QUAD CENT
	  LET (R5) := (R5) + R1
	  LET 2(R5) := R0 + CARRY
	  $CALL $MUL <#CDAYS,(SP)>	; COMPUTE DAYS IN FULL QUAD CENT
	  ASL R1			; WHICH IS 4X DAYS IN CENTURY
	  ROL R0			; PLUS ONE
	  ASL R1			; THE FULL NUMBER OF DAYS IN A
	  ROL R0			; QUADRICENTURY IS BIGGER THAN
	  ADD (SP)+,R1			; 16 BITS, SO WE DO THIS KLUGE
	  ADC R0			; RATHER THAN PULL IN A DOUBLE MUL
	  LET (R5) := (R5) + R1
	  LET 2(R5) := 2(R5) + CARRY + R0
;
; NOW ADD IN THE DAYS IN THE MONTHS OF THE CURRENT YEAR AND THE DAY OF
; THE MONTH.
;
	  POP R0			; GET MONTHS
	  LET R1 := #1
	  REPEAT
	    LET R2 :B= $DAYTB-1(R1)	; GET # DAYS IN MONTHS
	    IF R1 EQ #2 THEN LET R2 := R2 - R4 ; ADJUST FEBRUARY
	    IF R1 HIS R0 LEAVE LOOP
	    LET (R5) := (R5) + R2
	    LET 2(R5) := 2(R5) + CARRY	; AND ACCUMULATE
	    LET R1 := R1 + #1		; BUMP TO NEXT MONTH
	  END LOOP
	  IF (SP) HI R2 GOTO ERROR	; CHECK DAY AGAINST SIZE OF MONTH
	  LET (R5) := (R5) + (SP)+	; ADD DAY OF MONTH
	  LET 2(R5) := 2(R5) + CARRY
;
; ADJUST TO NUMBER OF DAYS SINCE 17-NOV-1858
;
	  LET (R5) := (R5) - #DS16L
	  LET 2(R5) := 2(R5) - CARRY - #DS16H
	ELSE				; IF NO DATE CONVERSION
	  LET SP := SP + #6		; CLEAN DATE WORDS OFF STACK
	END
;
; NOW SCALE UP BY THE TIME UNITS AND ADD IN TIME OF DAY
;
	LET R4 := SP			; POINT TO REST OF PARAMETERS
	LET SP := SP - #8.		; ALLOCATE 64 BIT SCRATCH
	$CALL $MULQ <#Q24,R5,SP>	; CONVERT DAYS TO HOURS
	LET R3 := SP
	ADD (R4)+,(R3)+			; ADD IN HOURS OF DAY
	ADC (R3)+
	ADC (R3)+
	ADC (R3)+
	$CALL $MULQ <#Q60,SP,R5>	; CONVERT HOURS TO MINUTES
	LET R3 := R5
	ADD (R4)+,(R3)+			; ADD IN MINUTES OF HOUR
	ADC (R3)+
	ADC (R3)+
	ADC (R3)+
	$CALL $MULQ <R0,R5,SP>		; CONVERT MINUTES TO SECONDS
	LET R3 := SP
	ADD (R4)+,(R3)+			; ADD IN SECONDS OF MINUTE
	ADC (R3)+
	ADC (R3)+
	ADC (R3)+
	$CALL $MULQ <#QNS,SP,R5>	; CONVERT SECONDS TO 100 NS
	LET SP := SP + #18.		; CLEAN ALL JUNK OFF STACK
	POP R2,R1,R0			; RESTORE REGISTERS
	RETURN
;
; TO HERE IF THE DAY IS GREATER THAN THE NUMBER OF DAYS IN THE MONTH.
;
ERROR:	LET SP := SP + #14.		; CLEAN THE STACK
	LET R2 := #100000		; SET ERROR FLAG
	POP R1,R0
	RETURN ERROR



	.END
