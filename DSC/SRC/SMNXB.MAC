	$BEGIN	SMNXB,0004,<SET UP NEXT STORAGE MAP BIT>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  18-AUG-76  4:24
; PETER H. LIPMAN	27-FEB-74

;+
; *** - .SMNXB	SET UP TO TEST NEXT STORAGE MAP BIT
; 
; THIS ROUTINE ACCEPTS A MASK WORD AND ADDRESS IN THE CURRENT STORAGE
; MAP BLOCK AND CALCULATES THE MASK AND ADDRESS FOR THE NEXT BIT, CROSSING
; TO THE NEXT STORAGE MAP BLOCK IF NECESSARY. WHEN NECESSARY TO CROSS
; TO ANOTHER STORAGE MAP BLOCK THE CURRENT ONE IS WRITTEN IF NECESSARY
; AND THE NEXT ONE IS READ. A COUNT OF STORAGE MAP BLOCKS TO BE  SCANNED
; MUST BE INITIALIZED BEFORE THIS ROUTINE IS CALLED. THIS 
; COUNT IS USED TO SEE IF THE NEXT BLOCK SHOULD BE READ. THE
; NEXT BLOCK TO BE READ CORRECTLY WRAPS AROUND TO 1 IF THE NEXT BLOCK WOULD
; BE BEYOND THE END.
; 
; INPUTS:
; 
;	R0 = MASK WORD
;	R1 = ADDRESS IN BUFFER
;	R4 = DEVICE TABLE ADDRESS
;	.SMVBN = CURRENT STORAGE MAP BLOCK NUMBER
;	.SMCNT = NO. OF BLOCKS TO SCAN.
; 
; OUTPUT:
; 
;	C = 1 IF NO MORE BITS (CHECKED ALL BLOCKS)
;	C = 0 IF NEXT BIT IS SET TO TEST AND
;	R = 0 MASK
;	R1 = ADDRESS
;	.SMVBN = UPDATED IF CROSSED TO NEW BLOCK
;	.SMCNT DECREMENTED IF CROSSED TO NEW BLOCK
;	R2-R5	PRESERVED
;
;-

.SMNXB::
	ASL	R0		; SHIFT THE MASK
	BCC	20$		; BRANCH IF NOT LAST BIT
	ROL	R0		; SET INITIAL MASK
	TST	(R1)+		; AND NEXT WORD IN BUFFER
	CMP	#.SMBUF+512.-2,R1
	BHIS	20$		; BRANCH IF NOT BEYOND END OF BUFFER, C = 0
; 
; READ NEXT VIRTUAL BLOCK OF STORAGE BIT MAP, C = 1
; 
	ROR	R0		; C WAS 1, R0 WAS 1, R0  = 100000, C = 1
	MOV	-(R1),(R1)	; BACK UP CONTEXT TO LAST BIT LAST WORD
	DEC	.SMCNT		; TRIED ALL THE BLOCKS
	BLE	20$		; BRANCH IF YES, C = 1
	MOV	R3,-(SP)	; SAVE R3
	MOV	.SMVBN,R3
	INC	R3
	CMP	V.SBSZ(R4),R3	; IF BEYOND LAST BLOCK
	BHIS	10$
	MOV	#1,R3		; THEN WRAP TO BLOCK 1
10$:	CALL	.SMRVB
	MOV	(SP)+,R3	; RESTORE R3
	MOV	#.SMBUF,R1	; SET BUFFER ADDRESS
	CLR	R0		; CLEAR CARRY
	INC	R0		; SET R0 TO 1
20$:	RETURN



	.END
