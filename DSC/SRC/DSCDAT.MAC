	$BEGIN  DSCDAT,0046,<DATA BASE FOR DSC UTILITY>

; ALTERED:
; GEORGE RITTENBURG    20-SEP-76  14:15
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  16-OCT-1979  19:46
; ANDREW C. GOLDSTEIN  13-FEB-1980
; ACG0133 - ADD HEADER VALID FLAG
;
; ANDREW C. GOLDSTEIN  15-JAN-1980  20:45
; ACG0107 - ADD HEADER MAPPED FLAG
;
; ACG0052 - ADD BLOCKING FACTOR VARIABLE
; ANDREW C. GOLDSTEIN  3-AUG-78  16:33
; GEORGE RITTENBURG   5-APR-77	MODIFIED FOR CMP/VFY DISK TO/FROM TAPE
; GEORGE RITTENBURG 28-APR-78
; **GR01 CORRECTIONS FOR MULTI-REEL VERIFY
;
; ACG0014 - ANDREW C. GOLDSTEIN  10-JAN-1978
; ADD $RVN TO $HOLD AREA
; ADD BAD FILE HEADER LOGIC

;
; RANDOM PARAMETERS
;
BLKF   ==	4		; TAPE BLOCKING FACTOR
	.SBTTL	PARAMETERS

;
; LUN USAGE
;
TTYLUN ==	1		; CONSOLE I/O
INLUN  ==	2		; INPUT LUN
OUTLUN ==	3		; OUTPUT LUN
;
; EVENT  FLAGS
;
EFN    ==	2		; EVENT FLAG FOR DATA I/O
TTEFN	==	1		; EVENT FLAG FOR TTY I/O
;
; $ESTAT IS SIGNIFICANT ONLY FOR ON-LINE DSC
; $ESTAT IS THE STATUS WORD FOR EXIT WITH STATUS (SEE GTCML)
;  -1 INDICATES NO ERRORS
;  0 INDICATES AT LEAST 1 WARNING MESSAGE
;  2  INDICATES AT LEAST 1 FATAL ERROR MESSAGE
;  ONLY THE WORST CONDITION IS REPORTED AT EXIT TIME
$ESTAT::.WORD	 -1			; THIS LOC.WILL BE SET TO THE WORST CURRENT COND.
GCLFLG:: .BLKW   1		; MCR LINE FLAG

	.SBTTL	VOLUME SUMMARY BLOCK FORMAT

;
; THE FOLLOWING IS THE FORMAT OF THE VOLUME SUMMARY BLOCK. ONE SUCH
; BLOCK IS PRESENT AT THE FRONT OF A DSC FILE FOR EACH VOLUME IN THE
; VOLUME SET BEING BACKED UP. THE BLOCK IS 512 BYTES IN LENGTH AND
; HAS A SIMPLE ADDITIVE CHECKSUM IN THE LAST WORD. APPENDED TO THE
; SUMMARY BLOCK IS THE VOLUME'S INDEX FILE HEADER.
;

	.ASECT
.=0

S.NAME::.BLKB	12.		; TAPE FILE NAME
S.DVNM::.BLKB	12.		; SOURCE DEVICE NAME
S.SNAM::.BLKB	12.		; SOURCE STRUCTURE NAME
S.VNAM::.BLKB	12.		; SOURCE VOLUME LABEL
S.RVN::	.BLKW	1		; RELATIVE VOLUME NUMBER OF THIS UNIT
S.NVOL::.BLKW	1		; NUMBER OF VOLUMES IN SET
S.CLF::	.BLKW	1		; VOLUME CLUSTER FACTOR
S.VSIZ::.BLKW	2		; SOURCE DEVICE SIZE IN BLOCKS
S.USE::	.BLKW	2		; NUMBER OF BLOCKS IN USE
S.NFIL::.BLKW	2		; NUMBER OF FILES ON VOLUME
S.HFNU::.BLKW	2		; HIGHEST FILE NUMBER ON VOLUME
S.IFSZ::.BLKW	2		; SIZE OF INDEX FILE
S.IBSZ::.BLKW	1		; SIZE OF INDEX FILE BITMAP
S.IBLB::.BLKW	2		; STARTING LBN OF INDEX FILE BITMAP
S.BLKF::.BLKW	1		; DATA BLOCKING FACTOR
S.MRG::	.BLKW	1		; MERGE MODE FLAG
	.BLKB	510.-.		; UNUSED
S.CKSM::.BLKW	1		; BLOCK CHECKSUM
	.BLKB	512.		; INDEX FILE HEADER
S.SIZ::				; SIZE OF SUMMARY BLOCK

	.SBTTL	FILE ATTRIBUTE BLOCK FORMAT

;
; THE FOLLOWING IS THE FORMAT OF THE FILE ATTRIBUTE BLOCK. ONE SUCH
; BLOCK IS PRESENT IN THE TAPE FILE FOR EACH DISK FILE. IT CONTAINS
; A SUMMARY OF THE CHARACTERISTICS OF THE FILE AND IS PRESENT FOR
; USE BY THE INCREMENTAL RESTORE UTILITY.
;
; WARNING! ALTHOUGH THE ATTRIBUTE FORMAT IS DEFINED WITH PARAMETERS
; HERE, THE CODE THAT ACTUALLY BUILDS THE ATTRIBUTE BLOCK ASSUMES
; THIS FORMAT AND USES AUTO-INCREMENTS.
;

	.ASECT
.=0

A$ID1::	.BLKB	6		; .ASCII "BACKUP"
A$VER::	.BLKW	1		; .WORD 1 - VERSION NUMBER
A$FLN::	.BLKW	1		; BYTE COUNT OF FILE NAME
A$FNM::	.BLKB	80.		; FULL FILE NAME
A$ALQ::	.BLKW	2		; FILE SIZE IN VIRTUAL BLOCKS
A$ORG::	.BLKB	1		; FILE ORGANIZATION
A$RAT::	.BLKB	1		; RECORD ATTRIBUTES
A$RFM::	.BLKB	1		; RECORD FORMAT
A$FSZ::	.BLKB	1		; RECORD CONTROL AREA SIZE
A$BKS::	.BLKB	1		; BUCKET SIZE IN VIRTUAL BLOCKS
A$FLG::	.BLKB	1		; MULTI-SECTION FLAG
A$MRN::	.BLKW	2		; MAXIMUM RECORD NUMBER
A$MRS::	.BLKW	1		; MAXIMUM RECORD SIZE
A$FOP::	.BLKW	1		; CONTIGUOUS INDICATOR
A$CDT::	.BLKB	8.		; CREATION DATE
A$RDT::	.BLKB	8.		; REVISION DATE
A$EDT::	.BLKB	8.		; EXPIRATION DATE
A$BDT::	.BLKB	8.		; DATE/TIME OF LAST BACKUP.
A$PRG::	.BLKW	1		; OWNER PROGRAMMER #
A$PRJ::	.BLKW	1		; OWNER PROJECT
A$SYS::	.BLKB	1		; SYSTEM PROTECTION
A$OWN::	.BLKB	1		; OWNER PROTECTION
A$GRP::	.BLKB	1		; GROUP PROTECTION
A$WLD::	.BLKB	1		; WORLD PROTECTION
	.BLKB	2040.-.		; UNUSED
A$ID2::	.BLKB	6		; .ASCII "PUKCAB"
A$CD::	.BLKW	1		; CHECKSUM

	.SBTTL	IMPURE DATA

;
; THE ENTIRE IMPURE AREA IS ZEROED BY THE MAIN PROGRAM BEFORE
; EACH COMMAND. THIS STARTS HERE.
;

	.PSECT

$ZERO::

;
; INPUT AND OUTPUT VOLUME TABLES. EACH TABLE ENTRY REPRESENTS
; THE ASSIGNMENT AND STATE OF AN ACTIVE INPUT OR OUTPUT DEVICE.
; EACH ENTRY IS OF THE FOLLOWING FORMAT:
;
	.ASECT
.=0

V.DVNM::.BLKB	2		; DEVICE NAME (ASCII)
V.DVUN::.BLKW	1		; UNIT NUMBER (BINARY)
V.RVN::	.BLKW	1		; RELATIVE VOLUME NUMBER
V.HFNU::.BLKW	2		; HIGHEST FILE NUMBER USED
V.FRBK::.BLKW	2		; NUMBER OF FREE BLOCKS
V.FLBN::.BLKW	1		; FIRST FREE BLOCK
V.IBSZ::.BLKW	1		; INDEX FILE BITMAP SIZE
V.IBLB::.BLKW	2		; INDEX FILE BIMAP LBN
V.SBSZ::.BLKW	1		; STORAGE MAP SIZE
V.SBLB::.BLKW	2		; STORAGE MAP LBN
V.CLF::	.BLKW	1		; CLUSTER FACTOR
V.SIZ::				;SIZE OF TABLE ENTRY

	.PSECT
;
; NUMBER OF UNITS SUPPORTED.
;
.IF DF,R$$11S
V.LENG == 2                     ; STAND ALONE LIMIT IS 2
.IFF
V.LENG == 8.			; ON LINE LIMIT IS 8 UNITS.
.ENDC
;
; INPUT DEVICE TABLE
;
$IVNUM::.BLKW	1		; NUMBER OF UNITS IN USE
$ILAB::	.BLKB	12.		; SPACE FOR FILE LABEL
$INDEV::.BLKW	1		; POINTER TO CURRENT INPUT DEVICE
$IVTAB::.BLKB  	V.SIZ*V.LENG	; SPACE FOR V.LENG UNITS
;
; OUTPUT DEVICE TABLE
;
$OVNUM::.BLKW	1		; NUMBER OF UNITS IN USE
$OLAB::	.BLKB	12.		; SPACE FOR FILE LABEL
$OUDEV::.BLKW	1		; POINTER TO CURRENT OUTPUT DEVICE
$OVTAB::.BLKB	V.SIZ*V.LENG	; SPACE FOR V.LENG UNITS
;
; PARSER OUTPUT AREA. THE PARSER FILLS IN THE ABOVE DEVICE TABLES AND
; RETURNS ASSORTED ITEMS IN THE FOLLOWING AREA.
;
$IFLAG::.BLKW	1		; INPUT FILE FLAGS
$OFLAG::.BLKW	1		; OUTPUT FILE FLAGS, CONTAINING:
	KY.RWD == 1		; REWIND BEFORE USE
	KY.APD == 2		; APPEND TO TAPE
	KY.160 == 10		; 1600 BPI FILE DENSITY
	KY.16B == 40		; 1600 BPI BOOT DENSITY
	KY.DSK == 100		; DISK DEVICE
	KY.TAP == 200		; TAPE DEVICE
	KY.MRG == 400		; MERGE MODE
	KY.EOT == 1000		; END OF TAPE SEEN ON OUTPUT TAPE
	KY.LOS == 2000		; TAPE SYNCHRONIZATION LOST
	KY.NBO == 4000		; DISK VOLUME IS NOT BOOTABLE
	KY.MAN == 10000		; MANUAL BAD BLOCK PROCESSING
	KY.NAU == 20000		; NO AUTO BAD BLOCKS
	KY.VER == 40000		; VERIFY AFTER COPY
	KY.CMP == 100000	; COMPARE ONLY

				; FLAGS LEGAL FOR INPUT TAPES
	KY.ITP == KY.RWD!KY.TAP!KY.160!KY.16B
				; FLAGS LEGAL FOR OUTPUT TAPES
	KY.OTP == KY.APD!KY.MRG!KY.RWD!KY.TAP!KY.160!KY.16B!KY.VER!KY.CMP
				; FLAGS LEGAL FOR INPUT DISKS
	KY.IDK == KY.DSK
				; FLAGS LEGAL FOR OUTPUT DISKS
	KY.ODK == KY.DSK!KY.MRG!KY.MAN!KY.NAU!KY.VER!KY.CMP


$FLAG1::.BLKW	1		; MISCELLANEOUS FLAGS, CONTAINING:
	KY.NCP == 1		; NON-COPY OPERATION
	KY.NIP == 2		; OUTPUT USING INPUT ROUTINES
	KY.BSP == 4		; BACKSPACE FOR VERIFY
	KY.VFY == 8.		; VERIFY PASS
	KY.EOF == 16.		; END OF INPUT DETECTED
;
; RANDOM VARIABLES.
;
$SBMEF::.BLKW	2		; STORAGE BIT MAP END OF FILE VBN.
$HDMAP::.BLKW	1		; HEADER MAPPED FLAG
$HDVAL::.BLKW	1		; HEADER VALID FLAG
$CYL::	.BLKW	1		; # OF CYLINDERS ON VOLUME.
$TRAK::	.BLKW	1		; # OF TRACKS PER CYLINDER.
$SECT::	.BLKW	1		; # OF SECTORS PER TRACK.
$HBDLT::.BLKW	2		; DELTA OFFSET FOR HOME BLOCK SEARCH/PLACEMENT.
$BFACT::.BLKW	1		; BLOCKING FACTOR OF DISK
$DEVGM::.BLKW	2		; DISK DEVICE GEOMETRY
$SERLN::.BLKW	2		; PACK SERIAL NUMBER
$STAK::	.BLKW	1		; INITIAL STACK POINTER
$IWAIT::.BLKW	1		; HEADER FOR INPUT WAIT LIST
$OWAIT::.BLKW	1		; HEADER FOR OUTPUT WAIT LIST
$NVOL::	.BLKW	1		; NUMBER OF VOLUMES IN SET
$FID::  .BLKW   2		; FILE ID CURR. FILE
$RVN::  .BLKW   1		;REL. VOL. NO. CURR. FILE
$TFID:: .BLKW   3		; SAVED FID
$VBN::	.BLKW	2		; CURRENT VBN OF FILE
$WVBN::	.BLKW	2		; VBN FOR FILE WRITER
$TVBN::	.BLKW	2		; VBN OF EXPECTED TAPE BLOCK
$TESQN::.BLKW	1		; TAPE FILE SEGMENT NUMBER
$XESQN::	.BLKW  1	; SAVED $TESQN FOR NXT VFY PASS
$LBN::	.BLKW	2		; CURRENT LBN
$BLCNT::.BLKW	1		; TAPE BLOCK COUNT
$RELNI::.BLKW	1		; CURRENT INPUT TAPE REEL NUMBER .
$RELNO::.BLKW	1		; CURRENT OUTPUT TAPE REEL NUMBER .
$FNU::	.BLKW	1		; CURRENT FILE NUMBER BEING READ
$FISIZ::.BLKW	2		; SIZE OF CURRENT FILE
$TFSIZ::.BLKW   2		; SAVED FISIZ
$IIVBN::	.BLKW  2	;SAVED INIT INIT IP VBN FOR NXT VFY PASS
$OIVBN::	.BLKW  2	;SAVED INIT OP VBN FOR NXT VFY PASS
$BOLBN::.BLKW	2		; LBN OF BOOT FILE OF DISK
$BOVBN::.BLKW	2		; VBN IN BOOT FILE OF BOOTABLE IMAGE
$HOMLB::.BLKW	2		; LBN OF INPUT VOLUME HOME BLOCK
$HM2LB::.BLKW	2		; LBN OF OUTPUT VOLUME 2ND HOME BLOCK
$IHVBN::.BLKW	2		; SIZE OF CURRENT HEADER'S WORTH
$ALSIZ::.BLKW	2		; AMOUNT OF SPACE BEING ALLOCATED
$CURAL::.BLKW	4		; RESIDUAL ALLOCATION FROM LAST HEADER
$EXFLG::.BLKW	1		; FLAG TO INDICATE EXTENSION HEADER
$SWFLG::.BLKW	1		; FLAG TO INDICATE HEADER BUFFER SWAP
$UCBAD::.BLKW  1		; CURRENT UCB ADDRESS FOR HDW. SWITCHES

$THVBN::.BLKW	2		; SAVED IHVBN.
$OHVBN:: .BLKW 2		; SIZE OF CURRENT OUTPUT HDR'S WORTH
$HOLD::  .BLKW 10.		; TEMP STORAGE FOR PMTRS FOR VERIFY
				;$VBN-2WORDS
				;$FID-3 WORDS
				;$IHVBN- 2 WORDS
				;$FISIZ -2 WORDS

;
; BUFFER FOR GET LUN INFO DIRECTIVE.
;
$LUNBF::
$DVNM::	.BLKW	1		; DEVICE NAME
$DVUN::	.BLKW	1		; UNIT NUMBER
$CW1::	.BLKW	1		; CHARACTERISTICS WORDS
$CW2::	.BLKW	1
$CW3::	.BLKW	1
$CW4::	.BLKW	1
;
; I/O BUFFERS. EACH BUFFER IS PREFIXED WITH A BUFFER CONTROL BLOCK.
; THE FIRST 8 WORDS OF EACH DATA BUFFER ARE THE MAGTAPE RECORD
; PREAMBLE. THE BUFFER COTROL BLOCK CONTAINS THE FOLLOWING:
;
	.ASECT
.=0

B.IOST::.BLKW	2		; I/O STATUS BLOCK
B.LINK::.BLKW	1		; LINK TO NEXT ACTIVE CONTROL BLOCK
B.STAT::.BLKW	1		; STATUS WORD
B.SIZ::	; SIZE OF STATUS BLOCK,SAME AS ST.SIZ IN DSCBUF
;
; THE BLOCK PREAMBLE CONTAINS THE FOLLOWING:
;
	.ASECT
.=0

P.CNT::	.BLKW	1		; BYTE COUNT OF DATA
P.FLAG::.BLKW	1		; FLAGS WORD
P.VBN::	.BLKW	2		; STARTING VBN OF BLOCK
P.FID::	.BLKW	3		; FILE ID OF THIS BLOCK
	.BLKW	1		; SPARE
P.SIZ::				; SIZE OF PREAMBLE,SAME AS PR.SIZ IN DSCBUF
;
; BITS DEFINED IN THE PREAMBLE FLAGS WORD
;
PF.DAT == 1			; DATA BLOCK
PF.ATR == 2			; ATTRIBUTE BLOCK
PF.HDR == 4			; FILE HEADER
PF.RWR == 10			; REWRITE DATA
PF.SUS == 20			; SUSPECT DATA
PF.SUM == 40			; VOLUME SUMMARY DATA
PF.ERR == 100000		; ERROR IN THIS BLOCK

	.PSECT
;
; ***** CODE IN READ AND WRITE DATA FUNCTIONS MAKES USE OF THE ORDER
; ***** OF THE FOLLOWING AREAS. DO NOT SHUFFLE!
;
; SPARE BUFFER CONTROL BLOCKS FOR SCATTERED READS AND WRITES
;
$B1HD1::.BLKB	B.SIZ
$B1HD2::.BLKB	B.SIZ
$B1HD3::.BLKB	B.SIZ
;
; DATA BUFFERS, ALL ACTUAL DATA I/O (AND ALL TAPE I/O) PASS THROUGH
; HERE.
;
$B1HD:: .BLKB	B.SIZ	; BUFFER CONTROL BLOCK
$BUF1::	.BLKB	P.SIZ		;BLOCK PREAMBLE
$B1DAT::.BLKB	2048.		; DATA AREA
;
; SPARE BUFFER CONTROL BLOCKS FOR SCATTERED READS AND WRITES
;
$B2HD1::.BLKB	B.SIZ
$B2HD2::.BLKB	B.SIZ
$B2HD3::.BLKB	B.SIZ
;
; SECOND I/O BUFFER
;
$B2HD:: .BLKB	B.SIZ		;BUFFER CONTROL BLOCK
$BUF2:: .BLKB	P.SIZ		; BLOCK PREAMBLE
$B2DAT::.BLKB	2048.		; DATA AREA
;
; ***** CODE IN READ AND WRITE DATA FUNCTIONS MAKES USE OF THE ORDER
; ***** OF THE PRECEDING AREAS. DO NOT SHUFFLE!!
;
; FILE HEADER BUFFERS. THESE HOLD THE HEADER OF THE DISK FILE BEING
; READ OR WRITTEN AND ARE USED TO MAP THE FILE VBN'S.
;
$IHHD::	.BLKB	B.SIZ		; CONTROL BLOCK
$IHBF::	.BLKB	512.		; INPUT FILE HEADER BLOCK

H.VBN	== .-$IHBF
	.BLKW	2		; STARTING VBN OF THIS HEADER

$OHHD::	.BLKB	B.SIZ		; CONTROL BLOCK
$OHBF::	.BLKB	512.		; OUTPUT FILE HEADER BLOCK
	.BLKW	2		; STARTING VBN

;
; INDEX FILE HEADER BUFFERS. THESE HOLD THE HEADER OF THE INDEX FILE
; OF THE DISK BEING READ OR WRITTEN.
;
$IXHD::	.BLKB	B.SIZ		; CONTROL BLOCK
$IXBF::	.BLKB	512.		; INPUT INDEX FILE HEADER

$OXHD::	.BLKB	B.SIZ		; CONTROL BLOCK
$OXBF::	.BLKB	512.		; OUTPUT INDEX FILE HEADER

;;	;
;;	; STORAGE BITMAP BUFFER. USED TO ALLOCATE SPACE ON THE OUTPUT DISK.
;;	;
;;	$OBHD::	.BLKB	B.SIZ		; CONTROL BLOCK
;;	$OBBF::	.BLKB	512.		; BITMAP BUFFER
;;	
;;	;
;;	; INDEX FILE BITMAP BUFFER. USED TO FIND ACTIVE FILES ON THE INPUT
;;	; DEVICE.
;;	;
;;	$IXBHD::.BLKB	B.SIZ		; CONTROL BLOCK
;;	$IXBBF::.BLKB	512.		; INDEX FILE BITMAP BUFFER

$$$TMP=.
;
; TAPE LABEL BUFFERS. THESE ARE USED FOR LABEL PROCESSING ON INPUT
; AND OUTPUT TAPES. THEY OVERLAP THE INDEX FILE HEADER BUFFERS.
;
; INPUT TAPE
;
.=$IXHD

$IVHD::	.BLKB	B.SIZ		; CONTROL BLOCK
$IVBF::	.BLKB	80.		; VOLUME HEADER LABEL

$IF1HD::.BLKB	B.SIZ		; CONTROL BLOCK
$IF1BF::.BLKB	80.		; FILE HEADER LABEL #1

$IF2HD::.BLKB	B.SIZ		; CONTROL BLOCK
$IF2BF::.BLKB	80.		; FILE HEADER LABEL #2
;
;
; ADDITIONAL CONTROL BLOCKS FOR TAPE MARK I/O
;
$IF3HD::.BLKB	B.SIZ
$IF4HD::.BLKB	B.SIZ
$IF5HD::.BLKB	B.SIZ
$IF6HD::.BLKB	B.SIZ
;
; OUTPUT TAPE
;
.=$OXHD

$OVHD::	.BLKB	B.SIZ		; CONTROL BLOCK
$OVBF::	.BLKB	80.		; VOLUME HEADER LABEL

$OF1HD::.BLKB	B.SIZ		; CONTROL BLOCK
$OF1BF::.BLKB	80.		; FILE HEADER LABEL #1

$OF2HD::.BLKB	B.SIZ		; CONTROL BLOCK
$OF2BF::.BLKB	80.		; FILE HEADER LABEL #2
;
; ADDITIONAL CONTROL BLOCKS FOR TAPE MARK I/O
;
$OF3HD::.BLKB	B.SIZ
$OF4HD::.BLKB	B.SIZ
$OF5HD::.BLKB	B.SIZ
$OF6HD::.BLKB	B.SIZ

;
; DATA AREA FOR STORAGE MAP ALLOCATOR
; THIS OVERLAYS $BUF1 (INTO WHICH THE FILE ATTRIBUTE BLOCK WAS
; READ AND IS NO LONGER NEEDED).
;
.=$BUF1
;
; I/O BUFFER FOR STORAGE MAP
;
.SMBUF::.BLKB	512.
.SMVBN::.BLKW	1	; VBN OF STORAGE MAP IN BUFFER
.SMFLG::.BLKW	1	; BUFFER DIRTY FLAG
;
; ***DO NOT ALTER THE ORDER OF THE FOLLOWING LINES
;
.SVLBN::.BLKW	2	; SAVED LOGICAL BLOCK NUMBER
.SM1BT::.BLKW	2	; NUMBER OF BITS DESIRED/FOUND,BLOCKS RETURNED
.SM1MK::.BLKW	1	; SAVED MASK WORD FOR START OF SEARCH
.SM1AD::.BLKW	1	; SAVED BIT WORD ADDRESS FOR START OF SEARCH
.SM1VB::.BLKW	1	; SAVED VBN FOR START OF SEARCH
.SM2VB::.BLKW	1	; SAVED VBN FOR LARGEST CHUNK FOUND
.SM2AD::.BLKW	1	; SAVED BIT WORD ADDRESS FOR LARGEST CHUNK FOUND
.SM2MK::.BLKW	1	; SAVED MASK WORD FOR LARGEST CHUNK FOUND
.SM2BT::.BLKW	2	; NO. OF BITS IN LARGEST CHUNK
;
; ***DO NOT ALTER THE ORDER OF THE PRECEDING LINES
;
.SMEXT::.BLKB	1	; HIGH ORDER EXTEND SIZE
.SMCTL::.BLKB	1	; EXTEND CONTROL BYTE
	.BLKW	1	; LOW ORDER EXTEND SIZE
.SMCNT::.BLKW	1	; NO. OF BLOCKS OF STORAGE MAP NOT YET SCANNED
.USEPT::.BLKW	1	; POINTER TO M.USE IN MAP AREA OF FILE HEADER
.FREPT::.BLKW	1	; POINTER TO NEXT FREE RETRIEVAL POINTER

	EX.AC1 == 1	; EXTEND CONTIGUOUS FLAG

;
; ALLOCATION TABLE. THIS TABLE IS USED TO REPRESENT SPACE ALLOCATED
; ON THE VOLUME BY THE INITIALIZATION CODE.
; EACH ENTRY CONSISTS OF FOUR WORDS - A 32 BIT BLOCK
; COUNT, FOLLOWED BY A 32 BIT LBN. A ZERO COUNT INDICATES THAT NO
; SPACE IS IN USE. THE FIRST SEVERAL LOCATIONS ARE USED FOR SPECIFIC
; ARTIFACTS OF THE FILE STRUCTURE AND ARE TAGGED APPROPRIATELY.
;
; ***** THE FOLLOWING LOCATIONS ARE ORDERED. DO NOT SHUFFLE!
;

.=$BUF1+1024.

$BOOTB::.BLKW	4		; BOOT BLOCK CLUSTER
$HOME1::.BLKW	4		; HOME BLOCK 1 CLUSTER
$HOME2::.BLKW	4		; HOME BLOCK 2 CLUSTER
$IXHD2::.BLKW	4		; BACKUP INDEX FILE HEADER CLUSTER.
$INDXF::.BLKW	4		; INITIAL INDEX FILE

$SBM::	.BLKW	4		; STORAGE BITMAP FILE

$BADBK::.BLKW	500.		; SPACE FOR 125 BAD AREAS
$BADND::			; END OF TABLE

$VOLND::.BLKW	4		; DUMMY ENTRY TO ROUND UP END OF VOLUME

$BADP::	.BLKW	1		; POINTER TO NEXT FREE ENTRY IN BAD LIST

;
; ***** THE PRECEDING LOCATIONS ARE ORDERED. DO NOT SHUFFLE!
;

$CLF	== $B2DAT+S.CLF		; CLUSTER FACTOR IN SUMMARY BUFFER

$VOLSZ::.BLKW	2		; VOLUME SIZE ADJUSTED BY CLUSTER FACTOR

.=$$$TMP

;
; END OF AREA TO ZERO AT INIT TIME.
;

$ENDZ::

	.SBTTL	CALL DISPATCH TABLE

;
; THIS TABLE DISPATCHES THE DEVICE INDEPENDENT CALLS TO THE DEVICE
; DEPENDENT ROUTINES THAT PROCESS THE FUNCTIONS. IT IS SET UP
; ACCORDING TO THE NATURE OF THE INPUT AND OUTPUT DEVICES.
;

$INTAB::			; INPUT DEVICE FUNCTIONS
$INITI::.WORD	0		; INITIALIZE INPUT DEVICE
$RDSUM::.WORD	0		; READ VOLUME SUMMARY
$RDIXF::.WORD	0		; READ INDEX FILE DATA
$FIND::	.WORD	0		; FIND NEXT INPUT FILE
$RDEXH::.WORD	0		; READ FILE EXTENSION HEADER
$RDDAT::.WORD	0		; READ FILE DATA
$WATCK::.WORD	0		; WAIT FOR DATA INPUT
$FINI::	.WORD	0		; FINISH INPUT
$INTBL == <.-$INTAB>/2		; NUMBER OF ENTRIES IN TABLE

$OUTAB::			; OUTPUT DEVICE FUNCTIONS
$INITO::.WORD	0		; INITIALIZE OUTPUT DEVICE
$WTSUM::.WORD	0		; WRITE VOLUME SUMMARY
$WTIXF::.WORD	0		; WRITE INDEX FILE DATA
$ALLOC::.WORD	0		; ALLOCATE FILE
$DELHD::.WORD	0		; WRITE DELETED FILE HEADER
$WTEXH::.WORD	0		; WRITE FILE HEADER
$WTDAT::.WORD	0		; WRITE FILE DATA
$FINO::	.WORD	0		; FINISH OUTPUT
$FINDO::.WORD	0	; READ OUTPUT HEADER FOR VFY
$RDATO::     .WORD	0	; READ OUTPUT DATA BLOCK
$WATO::    .WORD	0	;WAIT OUTPUT DATA READ
$OUTBL == <.-$OUTAB>/2		; NUMBER OF ENTRIES IN TABLE

;
; POINTERS TO DISK FUNCTION ROUTINES
;

$INDSK::			; INPUT DEVICE FUNCTIONS FOR DISK
	.WORD	$NOOP		; INITIALIZE INPUT DEVICE
	.WORD	$DRDSU		; READ VOLUME SUMMARY, DISK
	.WORD	$DRDID		; READ INDEX FILE DATA, DISK
	.WORD	$DFIND		; FIND NEXT INPUT FILE, DISK
	.WORD	$DRDEX		; READ EXTENSION HEADER, DISK
	.WORD	$DRDDA		; READ FILE DATA, DISK
	.WORD	$DWCK		; WAIT FOR DATA INPUT, DISK
	.WORD	$NOOP		; FINISH INPUT, DISK

$OUDSK::			; OUTPUT DEVICE FUNCTIONS
	.WORD	$NOOP		; INITIALIZE OUTPUT, DISK
	.WORD	$DWTSU		; WRITE VOLUME SUMMARY, DISK
	.WORD	$DWTID		; WRITE INDEX FILE DATA, DISK
	.WORD	$DCREA		; CREATE FILE, DISK
	.WORD	$DLHDD		; DELETE FILE HEADER, DISK
	.WORD	$DEXTD		; EXTEND FILE, DISK
	.WORD	$DWTDA		; WRITE FILE DATA, DISK
	.WORD	$NOOP		; FINISH OUTPUT, DISK
	.WORD	$RDHDO		; READ HEADER OUTPUT DISK
	.WORD	$DRDDO		; READ DATA OUTPUT DISK
	.WORD	$DWCKO		;WAIT CHECK OUTPUT DATA READ

;
; POINTERS TO TAPE FUNCTION ROUTINES
;

$INTAP::			; INPUT DEVICE FUNCTIONS FOR TAPE
	.WORD	$TINI		; INITIALIZE INPUT, TAPE
	.WORD	$TRDSU		; READ VOLUME SUMMARY, TAPE
	.WORD	$TRDID		; READ INDEX FILE DATA, TAPE
	.WORD	$TFIND		; FIND NEXT INPUT FILE, TAPE
	.WORD	$TRDEX		; READ FILE EXTENSION HEADER, TAPE
	.WORD	$TRDDA		; READ FILE DATA, TAPE
	.WORD	$TWCK		; WAIT FOR DATA INPUT, TAPE
	.WORD	$TFINI		; FINISH INPUT, TAPE

$OUTAP::			; OUTPUT DEVICE FUNCTIONS
	.WORD	$TINO		; INITIALIZE OUTPUT, TAPE
	.WORD	$TWTSU		; WRITE VOLUME SUMMARY, TAPE
	.WORD	$TWTID		; WRITE INDEX FILE DATA, TAPE
	.WORD	$TCREA		; CREATE FILE, TAPE
	.WORD	$TDLHD		; DELETE FILE HEADER, TAPE
	.WORD	$TEXTD		; EXTEND FILE, TAPE
	.WORD	$TWTDA		; WRITE FILE DATA, TAPE
	.WORD	$TFINO		; FINISH OUTPUT, TAPE
	.WORD	$RDHTO		;READ HEADER OUTPUT TAPE
	.WORD	$TRDDO		; READ DATA OUTPUT TAPE
	.WORD	$TWCKO		;WAIT CHECK OUTPUT DATA READ


;
; ROUTINE FOR NO-OPED FUNCTIONS
;
$NOOP:	RETURN

	.SBTTL	OTHER PURE DATA

;
; BIT TABLE FOR FAST BIT NUMBER TO MASK CONVERSION
;
$BIT::	.BYTE	1,2,4,10,20,40,100,200



	.SBTTL	TRAP VECTOR

;
; THE TRAP VECTOR IS USED TO CATCH THE ERROR TRAPS. THE LOW BYTE OF
; THE TRAP INSTRUCTION IS THE ERROR CODE. A POSITIVE VALUE INDICATES
; A FATAL ERROR; A NEGATIVE VALUE INDICATES A DIAGNOSTIC.
;

$SSTVC::.WORD	0,0,0,0,0,0,$DSCER



	.END
