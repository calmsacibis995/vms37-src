	$BEGIN	DRDID,0015,<READ INDEX FILE DATA>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  11-AUG-78  17:36
; GR001--- G.RITTENBURG JAN.3,1978.
; CORRECTIONS TO TAKE CARE OF CASE WHERE THERE ARE NO UNUSED FILES
; ON THE INPUT DISK.CORRECTION FROM 11M DSC
;
; ACG0014 - ANDREW C. GOLDSTEIN - 9-FEB-1979
; CORRECTIONS TO ABOVE CORRECTION
;
;

	.IF	NDF,R$$NVX
	.MCALL	FHDL2$
	FHDL2$				; DEFINE FILE HEADER FORMAT
	.ENDC

;+
;
; *** - $DRDID	READ INDEX FILE DATA FROM DISK
;
; THIS ROUTINE READS THE DATA FROM THE INDEX FILE THAT NEEDS TO BE
; SAVED AND RESTORED. THIS INCLUDES THE BOOT BLOCK, THE HOME BLOCK,
; AND THE FILE SEQUENCE NUMBERS OF ALL UNUSED HEADERS. THE FIRST
; CALL (I.E., WITH "BLOCK NUMBER" 0) RETURNS THE FORMER DATA.
; SUBSEQUENT CALLS WITH HIGHER BLOCK NUMBERS PACK FILE NUMBERS AND
; FILE SEQUENCE NUMBERS INTO THE OUTPUT BUFFER.
;
; INPUTS:
;
;	R2,R3 = "BLOCK NUMBER"
;
; OUTPUTS:
;
;	CC - C	CLEAR IF NO ERRORS
;		SET IF NO MORE DATA
;	R2,R3 = UPDATED "BLOCK NUMBER"
;	R4 = $BUF2 CONTROL BLOCK
;	DATA IN $BUF2
;	OTHER REGISTERS CLOBBERED
;
;-

$DRDID::
	IF R2 EQ #0 AND R3 EQ #0	; IF FIRST CALL
	  				; READ BOOT AND HOME BLOCKS
	  $CALL $RDW1B <,,$HOMLB+2,$HOMLB,#$B2HD> ; READ THE HOME BLOCK PREVIOUSLY FOUND
	  ON.ERROR THEN ERROR ER.RHO
	  LET B.STAT(R4) := #0		; FREE BUFFER FOR READ BELOW
	  LET R3 := #$B2DAT+512.	; POINT TO 2ND DATA BLOCK OF BUFFER
	  THRU R2 := #256.		; AND COPY HOME BLOCK DOWN
	    LET (R3)+ := (R5)+
	  END LOOP

	  LET $VBN := #1		; SET TO VBN 1
	  LET $VBN+2 := #0
	  $CALL $DRDDA <,#1,,,#$B2HD>	
	  $CALL $WAITI <,,,,R4>		; AND WAIT FOR COMPLETION
	  ON.ERROR THEN ERROR ER.RHO
	  LET B.SIZ+P.CNT(R4) := #1024.	; INDICATE 2 BLOCKS OF DATA IN BUFFER
	  LET B.SIZ+P.FID(R4) := #1	; FILE ID OF INDEX FILE
	  LET B.SIZ+P.FID+2(R4) := #1
	  LET B.SIZ+P.FID+4(R4) := $RVN
	  PUSH R4
	  $CALL $BUFCK <,,,,#$B1HD>	; READY $BUF1 FOR FUTURE USE 
	  LET $BUF1 := #0		; INIT RESIDENT LBN 
	  LET $BUF1+2 := #0	
	  POP R4
	  LET R2 := #0
	  LET R3 := #1			; RETURN 1 FOR NEXT CALL
	  RETURN
	END

;
; IF R2 AND R3 ARE NON-ZERO, THEN THEY ARE THE NEXT FILE NUMBER TO
; CHECK FOR FILE SEQUENCE NUMBER RECORDING. CONTINUE SCANNING THE
; INDEX FILE BITMAP FOR IDLE FILE HEADERS.
;
	BEGIN MAKBUF
	  $CALL $BUFCK <,,,,#$B2HD>	; OBTAIN BUFFER #2 
	  LET B.STAT(R4) := #1		; MARK BUSY
	  LET $BUF2 := #$B2DAT		; INIT POINTER 
	  BEGIN SCANIX
NBLK:	    				; LOOP FOR BITMAP BLOCKS
	    IF R2 EQ #377 AND R3 EQ #177777
	      LET B.STAT(R4) := #0	; RELEASE THE BUFFER
	      RETURN ERROR		; AND SIGNAL END OF DATA
	    END
	    PUSH R2,R3			; SAVE FILE NUMBER
	    LET R1 := R2
	    LET R2 := R3 - #01		; DOWN 1 TO START AT 0
	    LET R1 := R1 - CARRY
	    $CALL $DDIV <#4096.,R1,R2>	; COMPUTE BLOCK OFFSET
	    PUSH R0			; SAVE REMAINDER
	    LET R5 := $INDEV		; GET DEVICE TABLE ADDRESS
	    IF R2 HIS V.IBSZ(R5)
	      LET SP := SP + #6		; CLEAN THE STACK
	      LEAVE SCANIX		; OFF END OF BITMAP
	    END
	    LET R3 := R2 + V.IBLB(R5)	; COMPUTE LBN
	    LET R2 := V.IBLB+2(R5) + CARRY
	    $CALL $RDWTA <,#512.,R2,R3,#$B1HD,#$B1DAT> ; READ BLOCK 
	    ON.ERROR THEN ERROR ER.IXB

	    POP R0			; GET BIT NUMBER IN BLOCK
	    $CALL $DIV <R0,#16.>	; SPLIT INTO WORD AND BIT
	    LET R0 := R0 L.SHIFT 1 + R5	; WORD ADDRESS
	    LET R1 := R1 + #1
	    LET R4 := #0
	    SEC
	    THRU R1			; FIND STARTING BIT
	      LET R4 := R4 L.ROTATE 1
	    END LOOP
	    POP R3,R2			; GET BACK FILE NUMBER

	    REPEAT
	      REPEAT
		IF R4 OFF.IN (R0)	; IF HEADER IS IDLE
		  PUSH R0,R4,R2,R3	; SAVE FILE NUMBER AND MASK
		  LET R5 := $INDEV
		  LET R3 := R3 + V.IBSZ(R5) ; COMPUTE HEADER VBN
		  LET R2 := R2 + CARRY
;
; ACCOUNT FOR THE BOOT BLOCK, HOME BLOCK, BACKUP HOME BLOCK AND
; THE BACKUP COPY OF THE INDEX FILE HEADER.
;
; EACH OCCUPIES ONE CLUSTER OF VBNS AND LBNS. (CLUSTER FACTOR*4)+1
;
		  MOV  V.CLF(R5),-(SP)	; CLUSTER FACTOR TO TEMP.
		  ASL  (SP)		; MULT BY
		  ASL  (SP)		;         FOUR.
		  ADD  (SP)+,R3
		  ADC  R2
		  $CALL $MPVBN <,,R2,R3,,#$IXBF>
		  ON.ERROR
		    LET SP := SP + #8.	; CLEAN STACK
		    LEAVE SCANIX	; HEADER OFF END OF FILE
		  END
		  $CALL $RDWTA <,#512.,R2,R3,#$B1HD1,#$B1DAT+512.> 
		  BEGIN CHECK
		    ON.NOERROR
		      IF (R5) EQ #27027 AND H.FNUM(R5) EQ #0 AND H.CKSM(R5) EQ #0
			IF H.FLEV(R5) EQ #1001 ; STRUCT LVL 2 VERSION 1.
			  LET R0 := H.FSEQ(R5) ; GET SEQ FOR REAL HEADERS
			  LEAVE CHECK
			END
		      END
		    END
		    LET R0 := #0	; OTHERWISE USE 0
		  END CHECK
		  LET B.STAT(R4) := #0	; INVALIDATE BUFFER
		  POP R3,R2		; GET BACK FILE NUMBER
		  LET R5 := $BUF2	; INSERTED 5-10-77
		  LET (R5)+ := R3	; STORE FILE NUMBER
		  LET (R5)+ := R2
		  LET (R5)+ := R0	; AND FILE SEQ NUMBER
		  LET $BUF2 := R5	
		  POP R4,R0		; RECOVER ADDRESS AND MASK
		  IF R5 HI #$B2DAT+2048.-6 LEAVE MAKBUF	; OUT IF FULL 
		END
		LET R3 := R3 + #01	; BUMP FILE NUMBER
		LET R2 := R2 + CARRY
		LET R4 := R4 L.ROTATE 1	; ADVANCE TO NEXT BIT
	      UNTIL RESULT IS CS	; LOOP ON BITS IN WORD
	      TST (R0)+			; NEXT WORD
	      LET R4 := #1
	    UNTIL R0 HIS #$B1DAT+512.	;UNTIL END OF BUFFER
	    LET $B1HD+B.STAT := #0	; INVALIDATE BITMAP
	    JUMPTO NBLK			; LOOP FOR BITMAP BLOCKS
	  END SCANIX

;
; TO HERE AT END OF INDEX FILE BITMAP
;
	  LET R3 := #177777		; RETURN HIGHEST NUMBER  ; *5-10-77
	  LET R2 := #377		; TO FORCE ERROR ON NEXT CALL
	  LET $B1HD+B.STAT := #0	; INVALIDATE BITMAP BUFFER 
	END MAKBUF

	LET $B1HD+B.STAT := #0		; INVALIDATE BITMAP BUFFER 
	LET R5 := $BUF2			; GET BUFFER POINTER 
	WHILE R5 LO #$B2DAT+2048.
	  LET (R5)+ := #0		; ZERO REST OF BUFFER
	END LOOP
	LET R0 := #$BUF2		; INIT BLOCK PREAMBLE 
	LET (R0)+ := #2048.		; BYTE COUNT
	LET (R0)+ := #PF.DAT		; FLAG WORD
	LET (R0)+ := R3			; VBN
	LET (R0)+ := R2
	LET (R0)+ := #1			; FILE ID
	LET (R0)+ := #1
	LET (R0)+ := $RVN
	LET (R0)+ := #0			; SPARE
	LET R4 := #$B2HD		; RETURN BUFFER DESCRIPTOR
	RETURN



	.END

