	$BEGIN	DFIND,0026,<READ NEXT FILE HEADER FROM DISK>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  22-AUG-79  23:27
;
; ANDREW C. GOLDSTEIN  12-FEB-1980
; ACG0133 - INCREMENT FILE SEQUENCE NUMBER ON BAD HEADERS
;
; ANDREW C. GOLDSTEIN  15-JAN-1980  20:47
; ACG0107 - DON'T WRITE BAD HEADER RECORDS FOR UNMAPPED HEADERS
;
; ACG0060 - ANDREW C. GOLDSTEIN 22-AUG-1979
; FIX RECORDING FILE NAME IN ATTRIBUTE BLOCK
;
; **GR01-GEORGE RITTENBURG-10,OCT,1978
; INITIALIZE O.P. BASE VBN FOR OUTPUT, CORRECTIONS FROM 11M DSC
;
; ACG0014 - ANDREW C. GOLDSTEIN  9-JAN-1978
; FIX REGISTER USAGE BUG, CHECKSUM HEADER AFTER MARKING NON-CONTIG
; ADD CODE TO RECORD BAD FILE HEADERS ON TAPE
;

	.IF	NDF,R$$NVX
	.MCALL	FHDL2$
	FHDL2$				; DEFINE FILE HEADER FORMAT
	.ENDC

;+
;
; *** - $DFIND	READ NEXT FILE HEADER FOM DISK
;
; THIS ROUTINE FINDS THE NEXT VALID FILE HEADER OF THE INPUT
; DISK AND READS IT INTO THE HEADER BUFFER. IT ALSO FORMATS THE
; FILE ATTRIBUTE BLOCK AND COPIES THE HEADER INTO THE I/O BUFFER
; FOR OUTPUT.
;
; INPUTS:
;
;	$FID CONTAINS LAST FILE ID PROCESSED
;	INLUN ASSIGNED TO INPUT DISK
;	INDEX FILE HEADER IN $IXBF
;
; OUTPUTS:
;
;	CC - C	CLEAR IF HEADER READ
;		SET IF NO MORE FILES ON THIS VOLUME
;	$FID CONTAINS FILE ID OF NEW HEADER
;	FILE HEADER IN $IHBF
;	  ATTRIBUTE BLOCK IN $BUF1
;	  HEADER BLOCK IN $BUF2
;	OR
;	  BAD FILE HEADER BLOCK IN $BUF1
;
;-

$DFIND::
;
; FIRST WE SCAN THE INDEX FILE BITMAP TO FIND THE NEXT ACTIVE FILE
; HEADER.
;
	BEGIN SCAN
	  REPEAT
	    $CALL $SWID <,$RVN>		; SWITCH TO CURRENT DISK
	    LET R5 := $INDEV		; POINT TO DEVICE TABLE ENTRY
	    LET $RVN := V.RVN(R5)	; GET CORRECT RVN FROM TABLE
	    LET R0 := $FID		; GET CURRENT FILE NUMBER PLUS 1
	    				; FOR NEXT, MINUS 1 FOR BITMAP OFFSET
	    IF RESULT IS EQ THEN RETURN ERROR ; WRAPPED AROUND - OUT
	    $CALL $DIV <R0,#4096.>	; 4096 BITS PER BLOCK
	    IF R0 HIS V.IBSZ(R5)	; IF NO MORE FILES HERE
	      LET $FID := #3		; RESET FILE NUMBER
	      LET $RVN := $RVN + #1	; BUMP TO NEXT VOLUME
	      IF $RVN HI $NVOL THEN RETURN ERROR ; THAT'S ALL, FOLKS!
	      GOTO $DFIND		; RESTART THE SCAN
	    END
	    PUSH R1			; SAVE BIT # IN BLOCK
	    LET R3 := V.IBLB(R5) + R0	; COMPUTE LBN
	    LET R2 := V.IBLB+2(R5) + CARRY
	    $CALL $RDW1B <,,R2,R3,#$IHHD> ; READ A BITMAP BLOCK
	    ON.ERROR THEN ERROR ER.IXB
	    LET B.STAT(R4) := #0	; INVALIDATE BUFFER NOW

	    $CALL $DIV <(SP)+,#8.>	; COMPUTE BYTE NUMBER
	    LET R4 := #0
	    LET R4 :B= R4 SET.BY $BIT(R1) ; GET CORRESPONDING BIT
	    IF #1 SET.IN R0
	      SWAB R4			; SET TO HIGH BYTE
	    END
	    LET R0 := R0 OFF.BY #1 + R5	; MAKE WORD ADDRESS
	    LET R3 := $FID		; KEEP TRACK OF FILE NUMBER
	    REPEAT			; LOOP ON WORDS
	      REPEAT			; LOOP ON BITS
		LET R3 := R3 + #1	; BUMP TO NEXT FILE NUMBER
		IF R4 SET.IN (R0) LEAVE SCAN ; FOUND ACTIVE HEADER
		LET R4 := R4 L.ROTATE 1	; NEXT BIT
	      UNTIL RESULT IS CS	; LOOP FOR BITS
	      TST (R0)+			; BUMP TO NEXT WORD
	      LET R4 := #1		; INIT STARTING BIT
	    UNTIL R0 HIS #$IHBF+512.	; UNTIL END OF BLOCK
	    LET $FID := R3		; NONE IN THIS BLOCK
	  END LOOP			; GO BACK TO TRY THE NEXT
	END SCAN
;
; FOUND AN ACTIVE FILE NUMBER - GO TRY TO READ THE HEADER
;
	LET $FID := R3			; STORE THE FILE NUMBER
	$CALL $RDHDR <,,#0,R3>
	ON.ERROR GOTO BADHDR		; IF IT FAILED, RECORD A BAD HEADER
	LET $FID+2 := H.FSEQ(R5)	; FILL IN FILE SEQ NUMBER
;
; IF MERGE MODE IS ON, WE WANT ONLY PRIMARY FILE HEADERS
;
	IF #KY.MRG SET.IN $OFLAG
	  IF H.FSEG(R5) NE #0		; IF THIS IS AN EXTENSION HEADER
	    LET B.STAT(R4) := #0	; DISCARD THE BUFFER
	    GOTO BADHDR			; AND RECORD BAD HEADER
	  END
	END
	GOTO $MAKAT			; GENERATE ATTRIBUTE BLOCK
;
; WE GET HERE IF BAD HEADER, OR AN EXTENSION HEADER IN MERGE MODE, WAS
; ENCOUNTERED. IT MUST BE RECORDED ON THE OUTPUT MEDIUM TO PREVENT
; UNINITIALIZED FILE HEADERS ON THE RESULTING OUTPUT DISK.
;
BADHDR:	IF $HDMAP NE #0 GOTO $DFIND
	IF $HDVAL EQ #0			; IF FILE HEADER WAS JUNK
	  LET R0 := #$IHBF
	  LET (R0)+ := #40446
	  LET (R0)+ := #-1
	  LET (R0)+ := #0
	  LET (R0)+ := #1001
	  THRU R1 := #252.
	    LET (R0)+ := #0
	  END
	END
	LET $IHBF+H.FNUM := $FID	; STORE RIGHT FILE NUMBER
	LET $IHBF+H.FSEQ := $IHBF+H.FSEQ + #1 ; BUMP THE FILE SEQUENCE NUMBER
	LET $IHBF+H.FRVN := #0
	$CALL $BUFCK <,,,,#$B1HD>	; GET BUFFER #1
	LET B.STAT(R4) := #1		; MARK BUSY
	LET R5 := #$BUF1		; POINT TO BUFFER PREAMBLE
	LET (R5)+ := #512.		; BYTE COUNT OF HEADER BLOCK
	LET (R5)+ := #PF.HDR!PF.ERR	; FLAG AS HEADER ERROR
	LET (R5)+ := #0			; ZERO VBN
	LET (R5)+ := #0
	LET (R5)+ := $FID		; FILE ID
	LET (R5)+ := $FID+2
	LET (R5)+ := $FID+4
	LET (R5)+ := #0			; SPARE WORD
	LET R0 := #$IHBF		; POINT TO HEADER
	THRU R1 := #256.		; COPY THE HEADER
	  LET (R5)+ := (R0)+
	END LOOP
	RETURN NOERROR

;+
;
; *** - $MAKAT	BUILD ATTRIBUTES FOR FILE HEADER
;
; THIS ENTRY POINT BUILDS AS ATTRIBUTE BLOCK FOR THE FILE HEADER
; JUST READ. IT ALSO COPIES THE HEADER INTO $BUF2 FOR LATER OUTPUT.
;
; INPUTS:
;
;	HEADER IF $IHBF
;
; OUTPUTS:
;
;	ATTRIBUTE BLOCK WITH PREAMBLE IN $BUF1
;	HEADER WITH PREAMBLE IN $BUF2
;
;-

$MAKAT::
	$CALL $BUFCK <,,,,#$B1HD>	; GET BUFFER #1 
	LET B.STAT(R4) := #1		; MARK BUFFER BUSY
	$CALL $BUFCK <,,,,#$B2HD>	; OBTAIN 2ND BUFFER 
	LET R5 := #$BUF1		; POINT TO BUFFER 
	LET (R5)+ := #2048.		; BYTE COUNT OF BLOCK
	LET (R5)+ := #PF.ATR		; FLAG FOR ATTRIBUTE BLOCK
	LET (R5)+ := #0			; VBN
	LET (R5)+ := #0
	LET (R5)+ := $FID		; FILE ID
	LET (R5)+ := $FID+2
	LET (R5)+ := $FID+4
	LET (R5)+ := #0			; SPARE WORD
	LET (R5)+ := #"BA		; ASCII IDENTIFICATION
	LET (R5)+ := #"CK
	LET (R5)+ := #"UP
	LET (R5)+ := #1			; ATTRIBUTE VERSION NUMBER
	LET R3 := $INDEV		; INPUT DEVICE TABLE
	TST (R5)+			; SKIP NAME COUNT WORD
	LET R0 := R5			; COPY POINTER
	LET (R0)+ := V.DVNM(R3)		; DEVICE NAME
	$CALL $CBOMG <R0,V.DVUN(R3),#0>	; UNIT NUMBER
	LET (R0)+ :B= #':		; DEVICE ENDS WITH ":"
	LET (R0)+ :B= #'[		; DIRECTORY STARTS WITH [
	$CALL	$CBOMG	<R0,$IHBF+H.PROJ,#0> ; CONVERT THE GROUP NUMBER.
	LET (R0)+ :B= #54		; INSERT A COMMA.
	$CALL	$CBOMG	<R0,$IHBF+H.PROG,#0> ; CONVERT THE MEMBER NUMBER.
	LET (R0)+ :B= #']		; DIRECTORY ENDS WITH ]
	LET R3 := #0
	LET R3 :B= R3 SET.BY $IHBF+H.IDOF ; FIND HEADER IDENT AREA
	LET R3 := R3 L.SHIFT 1 + #$IHBF+I.FNAM ; FILE NAME
;
; COPY FILE NAME, TYPE AND VERSION.
;
	THRU R1 := #20.			; COPY 20 BYTE FILE NAME
	  IFB (R3) EQ #40 LEAVE LOOP	; STOP ON TRAILING BLANK
	  LET  (R0)+  :B=  (R3)+	; COPY ONE BYTE.
	END	LOOP
	LET R1 := R0 - R5		; COMPUTE FILENAME BYTE COUNT
	LET -(R5) := R1
	THRU R4 := #80. - (R5)
	  LET (R0)+ :B= #0		; CLEAN OUT REST OF FILE NAME
	END LOOP

	LET R2 := R0			; SWITCH POINTERS AGAIN
	$CALL $FILSZ <,,,,,#$IHBF>	; COMPUTE FILE SIZE
	LET (R2)+ := R1
	LET (R2)+ := R0
	LET R1 :B= $IHBF+H.UFAT+F.RTYP	; GET RECORD TYPE
	LET R0 := R1 R.SHIFT 4 OFF.BY #^C17 ; EXTRACT FILE ORG
	LET (R2)+ :B= R0
	LET (R2)+ :B= $IHBF+H.UFAT+F.RATT ; RECORD ATTRIBUTES
	LET R1 := R1 OFF.BY #^C17	; EXTRACT RECORD FORMAT
	LET (R2)+ :B= R1
	LET (R2)+ :B= $IHBF+H.UFAT+F.HDSZ ; CONTROL AREA SIZE
	LET (R2)+ :B= $IHBF+H.UFAT+F.BKSZ ; BUCKET SIZE
	LET R1 := H.FSEG(R5)		; GET EXTENSION SEGMENT NUMBER
	LET R1 := R1 SET.BY H.EFNU(R5)	; AND EXT FILE NUMBER
	IF RESULT IS NE AND #KY.MRG OFF.IN $OFLAG
	  LET (R2)+ :B= #200		; SET MULTI-SEGMENT FLAG
	  				; AND MARK NON-CONTIGUOUS
	  LET $IHBF+H.UCHA :B= $IHBF+H.UCHA OFF.BY #UC.CON
	  $CALL $CKSUM <,,,,,R5>	; AND RE-CHECKSUM THE HEADER
	ELSE
	  LET (R2)+ :B= #0
	END
	LET (R2)+ := $IHBF+H.UFAT+F.LMRN ; MAX RECORD NUMBER
	LET (R2)+ := $IHBF+H.UFAT+F.HMRN
	LET (R2)+ := $IHBF+H.UFAT+F.RSIZ ; RECORD SIZE
	LET (R2) := #0			; SET CONTIGUOUS FLAG
	IFB #UC.CON SET.IN $IHBF+H.UCHA THEN LET (R2) := #1
	TST (R2)+

	LET R0 := #0
	LET R0 :B= R0 SET.BY $IHBF+H.IDOF ; FIND IDENT AREA AGAIN
	LET R0 := R0 L.SHIFT 1 + #$IHBF+I.CRDT ; CREATION DATE
	THRU  R1  :=  #<4*4>		; 4 DATES, 4 WORDS EACH.
	  MOV  (R0)+,(R2)+
	END  <LOOP>
	LET  R1  :=  R2			; POINT R1 INTO ATTRIB BLOCK.
	LET (R1)+  :=  $IHBF+H.PROG	; OWNER PROGRAMMER.
	LET (R1)+ := $IHBF+H.PROJ	; OWNER PROJECT
	LET R0 := $IHBF+H.FPRO		; GET FILE PROTECTION
	THRU R3 := #4			; BREAK IT UP INTO FIELDS
	  LET R2 := #0
	  THRU R4 := #4
	    ROR R0			; PICK OFF 4 BIT FIELD
	    ROR R2
	  END LOOP
	  SWAB R2
	  LET R2 := R2 R.SHIFT 4
	  LET (R1)+ :B= R2
	END LOOP
	THRU R0 := #<A$ID2-A$WLD-1>/2
	  LET (R1)+ := #0		; ZERO REST OF BLOCK
	END LOOP
	LET (R1)+ := #"PU		; PUT IN TRAILER IDENTIFIER
	LET (R1)+ := #"KC
	LET (R1)+ := #"AB
;
; NOW READ ANY EXTENSION HEADERS TO COMPUTE THE TOTAL FILE
; SIZE.
;
	IF #KY.MRG SET.IN $OFLAG	; IF MERGE MODE IS ON
	  PUSH $INDEV			; SAVE INPUT DEVICE ASSIGNMENT
	  REPEAT
	    $CALL $RDNXH <,,,,#$B2HD,R5> ; READ EXTENSION HEADER 
	    ON.ERROR LEAVE LOOP		; IF ANY
	    $CALL $FILSZ <,,,,,R5>	; COMPUTE NUMBER OF BLOCKS MAPPED
	    LET $B1DAT+A$ALQ := $B1DAT+A$ALQ + R1 ;ACCUMULATE FILE SIZE
	    LET $B1DAT+A$ALQ+2 := $B1DAT+A$ALQ+2 + CARRY + R0
	    LET B.STAT(R4) := #0	; DISCARD THE BUFFER
	  END LOOP
	  $CALL $SWID1 <(SP)+>		; RESTORE INPUT DEVICE ASSIGNMENT
	END

	$CALL $CKSM1 <,#A$CD/2,,,,#$B1DAT> ; COMPUTE CHECKSUM 
;
; FINALLY, FORMAT THE BLOCK PREAMBLE FOR THE HEADER BLOCK
; AND COPY IT INTO THE I/O BUFFER
;
	LET $B2HD+B.STAT := #1		; MARK BUSY
	LET R0 := #$BUF2		; POINT TO BLOCK PREAMBLE 
	LET R1 := #$BUF1		; COPY ATTRIBUTE BLOCK PREAMBLE
	THRU R2 := #P.SIZ/2		; SINCE THEY ARE ALMOST IDENTICAL
	  LET (R0)+ := (R1)+
	END LOOP
	LET P.FLAG-P.SIZ(R0) := #PF.HDR	; EXCEPT FOR THE FLAGS
	LET P.CNT-P.SIZ(R0) := #512.	; AND THE COUNT
	LET R1 := #$IHBF		; POINT TO INPUT HEADER BUFFER
	THRU R2 := #256.
	  LET (R0)+ := (R1)+		; COPY THE HEADER
	END LOOP
	LET (R1)+ := #0			; INIT BASE VBN FOR MAPPING
	LET (R1)+ := #0
	LET (R0)+ := #0
	LET (R0)+ := #0
	LET $FISIZ := $B1DAT+A$ALQ	; SET TOTAL FILE SIZE 
	LET $FISIZ+2 := $B1DAT+A$ALQ+2
	$CALL $FILSZ <,,,,,#$B2DAT>	; COMPUTE FILE HEADER SIZE
	LET $IHVBN := R1		; AND SAVE
	LET $IHVBN+2 := R0
	RETURN NOERROR



	.END

