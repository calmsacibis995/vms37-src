	$BEGIN	SMRVB,0005,<READ A STORAGE MAP BLOCK>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  14-AUG-76  0:48

;+
;
; *** - .SMRVB	READ A STORAGE MAP BLOCK
;
; THIS ROUTINE READS THE INDICATED STORAGE MAP BLOCK INTO .SMBUF.
; IF THE BUFFER CONTAINS A MODIFIED MAP BLOCK, IT IS WRITTEN FIRST.
;
; INPUTS:
;
;	R3 = VBN OF MAP BLOCK TO READ
;	   = 0 IF JUST WRITE DIRTY BUFFER
;	R4 = DEVICE TABLE ADDRESS
;	OUTLUN ASSIGNED TO DEVICE
;	.SMFLG	= 0 IF BUFFER IS CLEAN
;		= 1 IF BUFFER IS DIRTY
;
; OUTPUTS:
;
;	BUFFER WRITTEN IF NECESSARY
;	BLOCK READ INTO .SMBUF
;	ALL REGISTERS PRESERVED
;
;-

.SMRVB::
	$CALL $SAVAL			; SAVE ALL REGISTERS
	IF .SMFLG NE #0			; IF BUFFER IS DIRTY
	  PUSH R3,R4			; SAVE NEW VBN
	  LET R3 := .SMVBN + V.SBLB(R4)	; GET LBN OF OLD BLOCK
	  LET R2 := V.SBLB+2(R4) + CARRY
	  $CALL $WRI1B <,,R2,R3,#$B1HD>	; WRITE THE BLOCK
	  $CALL $WAITO <,,,,R4>
	  ON.ERROR THEN ERROR ER.WSM
	  LET .SMFLG := #0		; MARK BUFFER CLEAN AGAIN
	  POP R4,R3
	END

	IF R3 NE .SMVBN			; READ IF BLOCK NOT ALREADY THERE
	  IF R3 NE #0			; READ IF NOT JUST BUFFER FLUSH
	    LET $B1HD+B.STAT := #0	; INVALIDATE BUFFER
	    LET .SMVBN := R3		; SAVE THE NEW VBN
	    IF R3 HI V.SBSZ(R4)		; CHECK AGAINST BOUNDS
	      FATAL <TRIED TO READ OFF END OF BITMAP>
	    END
	    LET R3 := R3 + V.SBLB(R4)	; COMPUTE LBN
	    LET R2 := V.SBLB+2(R4) + CARRY
	    $CALL $RDWLN <#OUTLUN,,R2,R3,#$B1HD> ; READ IT
	    ON.ERROR THEN ERROR ER.RSM
	  END
	END
	RETURN



	.END
