	.TITLE	$CATDT - CONVERT ASCII STRING TO DATE AND TIME

	.IDENT	/V03000/

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  16 JUN 76  17:05


	SMACIT

	.MACRO	$SAVRG
	JSR	R5,$SAVRG
	.ENDM	$SAVRG

;+
;
; *** - $CATDT	CONVERT ASCII TO DATE/TIME
;
; THIS ROUTINE CONVERTS AN ASCII STRING REPRESENTATION OF DATE AND/OR
; TIME OF DAY TO THE STANDARD DATE/TIME REPRESENTATION. VALID SYNTAX
; IS AS FOLLOWS:
;
; EITHER DATE, OR TIME, OR BOTH MAY BE PRESENT, SEPARATED BY A BLANK OR
; TAB. TIME IS OF THE FORM "HH:MM:SS" OR "HH:MM" (24 HOUR TIME).
; DATE IS OF THE FORM MM/DD/YY, MM/DD/YYYY, DD-MMM-YY, OR DD-MMM-YYYY,
; WHERE DD IS NUMERICAL DAY OF MONTH, MM IS NUMERICAL MONTH, MMM
; IS ABBREVIATED ALPHABETIC MONTH, YY IS YEAR - 1900, AND YYYY IS FULL
; YEAR.
;
; INPUTS:
;
;	R0 = ADDRESS OF ASCII STRING
;	R1 = ADDRESS OF 8 BYTE DATE/TIME BUFFER
;
; OUTPUTS:
;
;	R0 = ADDRESS OF FIRST BYTE FOLLOWING DATE/TIME STRING
;	R2 = FLAGS
;	   BIT 0 = 1 IF DATE NOT GIVEN
;	   BIT 1 = 1 IF TIME NOT GIVEN
;	   BIT 15 = 1 IF SYNTAX ERROR
;	CC - C	CLEAR IF NO ERRORS
;		SET IF SYNTAX ERROR
;	DATE/TIME VALUE IN SPECIFIED BUFFER
;	OTHER REGISTERS ARE PRESERVED
;
;-

$CATDT::
	$SAVRG				; SAVE R3,R4,R5
;
; THIS ROUTINE BUILDS A DATE/TIME BLOCK ON THE STACK IDENTICAL TO
; THAT RETURNED BY THE GTIM$ DIRECTIVE. IT EXITS THROUGH COMMON
; CODE TO CONVERT THIS INTO THE 64 BIT FORMAT.
;
; SAVE REGISTERS AND INITIALIZE THE BLOCK ON THE STACK
;
	PUSH R0,R1,#3,#60.		; R0, R1, RETURN R2, AND TICKS/SEC
	THRU R1 := #7
	  PUSH #0
	END LOOP
;
; SCAN THE STRING
;
	WHILE 20(SP) NE #0		; QUIT IF BOTH DATE AND TIME SEEN
	  $CALL $CDTB <R0>		; CONVERT FIRST NUMBER
	  IFB R2 EQ #':			; IF COLON THIS IS A TIME
	    IF #2 OFF.IN 20(SP) GOTO SYNTAX ; OUT IF ALREADY SEEN TIME
	    LET 20(SP) := 20(SP) - #2	; NOTE TIME SEEN
	    LET 6(SP) := R1		; STORE HOURS IN BLOCK
	    $CALL $CDTB <R0>		; GET MINUTES
	    LET 10(SP) := R1		; STORE IN BLOCK
	    IF R2 EQ #':		; IF FOLLOWED BY A COLON
	      $CALL $CDTB <R0>		; GET SECONDS
	      LET 12(SP) := R1		; AND STORE
	    END

	  ELSE				; WASN'T TIME, MUST BE A DATE

	    IF #1 OFF.IN 20(SP) GOTO SYNTAX ; OUT IF ALREADY SEEN DATE
	    LET 20(SP) := 20(SP) - #1	; NOTE DATE SEEN
	    IF R2 EQ #'/		; IF FORMAT IS MM/DD/YY
	      LET 2(SP) := R1		; STORE MONTH
	      $CALL $CDTB <R0>		; CONVERT DAY
	      IF R2 NE #'/ GOTO SYNTAX	; "/" MUST FOLLOW
	      LET 4(SP) := R1		; STORE DAY
	    ELSE			; MUST BE OTHER DATE FORMAT
	      IF R2 NE #'- GOTO SYNTAX	; OTHER DELIMITER IS "-"
	      LET 4(SP) := R1		; STORE DAY
	      LET R5 := #$MONTB		; POINT TO TABLE OF MONTH NAMES
	      LET R1 := R0		; SAVE STRING POINTER
	      THRU R4 := #12.		; SEARCH THE MONTH TABLE
		IFB (R0)+ EQ (R5)+
		  IFB (R0)+ EQ (R5)+
		    IFB (R0)+ EQ (R5)+ LEAVE LOOP ; IF IT MATCHES
		  ELSE
		    TSTB (R5)+		; ELSE SKIP REST OF THIS NAME
		  END
		ELSE
		  CMPB (R5)+,(R5)+
		END
		LET R0 := R1		; BACK UP STRING POINTER
	      END LOOP			; AND TRY AGAIN
	      				; NOTE THAT A BAD MONTH WILL
	      				; RESULT IN MONTH # 13
	      LET 2(SP) := #13. - R4	; COMPUTE MONTH NUMBER
	      IFB (R0)+ NE #'- GOTO SYNTAX ; CHECK DELIMITER
	    END
	    $CALL $CDTB <R0>		; GET YEAR
	    IF R1 LO #100. THEN LET R1 := R1 + #1900.
	    LET (SP) := R1		; STORE YEAR
	  END
	  IF R2 NE #40 AND R2 NE #11 LEAVE LOOP
	END LOOP			; DONE IF TERMINATOR WAS NOT BLANK OR TAB
	LET R0 := R0 - #1		; BACK UP TO TERMINATOR
;
; DATE AND TIME IS BUILT ON THE STACK. CHECK NUMERICAL VALUES
; FOR CORRECTNESS.
;
	LET R2 := SP
	IF #1 OFF.IN 20(SP)		; CHECK DATE IF SEEN
	  IF (R2) LO #1859. OR (R2)+ HI #58000. GOTO SYNTAX
	  LET R1 := (R2)+		; PICK UP MONTH
	  IF R1 EQ #0 OR R1 HI #12. GOTO SYNTAX
	  LET R1 :B= $DAYTB-1(R1)		; GET DAYS IN MONTH
	  IF (R2) EQ #0 OR (R2)+ HI R1 GOTO SYNTAX
	ELSE
	  LET R2 := R2 + #6		; SKIP DATE CHECK
	END
					; CHECK TIME REGARDLESS
	IF (R2)+ HIS #24. GOTO SYNTAX
	IF (R2)+ HIS #60. GOTO SYNTAX
	IF (R2)+ HIS #60. GOTO SYNTAX
;
; HAVING BUILT THE BLOCK ON THE STACK, GO TO COMMON ROUTINE TO
; COMPUTE STANDARD FORMAT. (IT WILL CATCH WRONG FEB. 29.)
;
	LET 24(SP) := R0		; ADJUST RETURN R0
	JUMPTO $CBDDT
;
; TO HERE ON SYNTAX ERRORS
;

SYNTAX:	LET SP := SP + #18.		; CLEAN THE STACK
	POP R1				; RESTORE R1
	TST (SP)+			; THROW AWAY SAVED R0
	LET R2 := #100000		; SET ERROR BIT
	RETURN ERROR



	.END
