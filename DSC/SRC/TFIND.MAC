	$BEGIN  TFIND,0017,<FIND NEXT FILE ON TAPE>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  17-AUG-76  23:11
; GEORGE RITTENBURG  7-APR-77  MODIFIED FOR VFY/CMP DISK TO/FROM TAPE
; **GR01---G.RITTENBURG AUG.16,1978
; CORRECTION FOR MULTI-REEL O.P. TAPE VERIFY
;
; ACG0014 - ANDREW C. GOLDSTEIN  8-MAR-1979
; ADD CODE TO RECOGNIZE BAD HEADER RECORDS
	.IF	NDF,R$$NVX
	.MCALL	FHDL2$,ALUN$S
	FHDL2$				; DEFINE FILE HEADER OFFSETS
	.IFF
	.MCALL	ALUN$S
	.ENDC

;+
;
; *** - $TFIND	FIND NEXT FILE ON TAPE
;
; THIS ROUTINE READS THE ATTRIBUTE AND HEADER BLOCKS FOR THE NEXT FILE
; FROM THE TAPE AND CHECKS THEM FOR CONSISTENCY. IF WE ARE OUT OF
; SYNC, IT SEARCHES UNTIL THE ATTRIBUTE AND HEADER BLOCKS ARE FOUND.
;
; INPUTS:
;
;	INLUN ASSIGNED TO TAPE
;	$INDEV POINTING AT DEVICE TABLE ENTRY
;
; OUTPUTS:
;
;	CC - C	CLEAR IF ALL OK
;		SET IF ERROR
;	IF OK, $BUF1 CONTAINS ATTRIBUTE BLOCK,
;	AND $BUF2 AND $IHBF CONTAIN FILE HEADER
;	R5 = ADDRESS OF HEADER READ
;	IF ERROR, R4 POINTS AT BCB OF OFFENDING BUFFER
;
;-

$RDHTO::
	LET $FLAG1 := $FLAG1 SET.BY #KY.NIP ;FLAG O.P.
	LET R0 := $OUDEV
	ALUN$S  #INLUN,(R0),2(R0)	;ASGN LUN TO O.P.
	LET $B1HD+B.STAT := #0		;RELEASE BUFFR
$TFIND::

	$CALL $RDWAT <,#2048.+P.SIZ,,,#$B1HD> ; READ ATTR BLOCK
	ON.ERROR
	  IFB (R4) EQ #IE.EOF THEN RETURN ERROR	; END OF DATA
	  IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
	    ERROR ER.RAT
	  ELSE
	    ERRP ER.RAT			; PRINT MESSAGE
	  END
	ELSE				; IF NO I/O ERROR
	  IF P.FLAG(R5) NE #PF.ATR	; CHECK IF ATTR BLOCK
	    IF P.FLAG(R5) EQ #PF.HDR!PF.ERR ; CHECK IF BAD HEADER
	    LET B.STAT(R4) := #0	; RELEASE THE BUFFER
	      LET $FID := P.FID(R5)	; STORE FILE ID
	      LET $FID+2 := P.FID+2(R5)
	      LET $FID+4 := P.FID+4(R5)
	      GOTO FINDB		; USE COMMON EXIT CODE
	    END
	    IF #KY.LOS OFF.IN $IFLAG	;IF WE WERE IN SYNC
	      ERRP ER.PH1		; LOSS OF SYNC MESSAGE
	    END
	  ELSE				; YES, THIS IS AN ATTRIBUTE BLOCK
	    LET $FISIZ := $B1DAT+A$ALQ	; SET TOTAL FILE SIZE
	    LET $FISIZ+2 := $B1DAT+A$ALQ+2
;
; NOW READ THE FILE HEADER, WHICH SHOULD FOLLOW
;

	    LET $FNU := P.FID(R5)	; SET FILE NUMBER
	    $CALL $RDWAT <,#512.+P.SIZ,,,#$B2HD>
	    ON.ERROR
	      IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
		ERROR ER.RHT		;ABORT ON ERROR
	      ELSE
		ERRP ER.RHT		; PRINT I/O ERROR MESSAGE
		IFB (R4) EQ #IE.EOF THEN RETURN ERROR
	      END
	    ELSE
	      IF P.FLAG(R5) NE #PF.HDR	; CHECK IF HEADER BLOCK
		IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
		  ERROR ER.NXT		;ABORT IF NOT HDR
		ELSE
		  ERRP ER.NXT		; FAILED TO FIND HEADER
		  JUMPTO RESYN1		; INITIATE RESYNC PROCESSING
		END
	      END
	      LET $FID := P.FID(R5)	; GET FILE ID OF FILE
	      LET $FID+2 := P.FID+2(R5)
	      LET $FID+4 := P.FID+4(R5)
	      LET R5 := R5 + #P.SIZ	; POINT TO HEADER DATA
	      $CALL $VFYHD <,,,,,R5>	; SEE IF REAL FILE HEADER
	      ON.NOERROR
		IF #KY.LOS SET.IN $IFLAG THEN ERRP ER.RSY
		LET $IFLAG := $IFLAG OFF.BY #KY.LOS ; WE ARE IN SYNC
		JUMPTO FINDA		; YOU WIN
	      ELSE
		IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
		  ERROR ER.NXT
		END
	      END
	      LET $B2HD+B.STAT := #0	; INVALIDATE BUFFER FOR RETRY
	    END
	  END
	END
;
; WE ARE OUT OF SYNC, DUE TO AN I/O ERROR OR DATA MISMATCH.
;
	LET $IFLAG := $IFLAG SET.BY #KY.LOS ; NOTE THE FACT
	LET $B1HD+B.STAT := #0		; INVALIDATE BUFFER FOR RETRY
	JUMPTO $TFIND			; AND PROCEED TO SEARCH

FINDA:	LET $TESQN := #0		; INIT SEGMENT NUMBER
	$CALL $FILSZ <,,,,,#$B2DAT>	;GET SIZE OF THIS HDR.
	LET $TFSIZ := R1		;AND SAVE IT
	LET $TFSIZ+2 := R0
FINDB:	IF #KY.NIP SET.IN $FLAG1
	  LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP ; RESET TO I.P.
	  LET $OHBF+H.VBN := #0		;INIT.STARTING VBN
	  LET $OHBF+H.VBN+2 := #0
	  LET $OHVBN := $TFSIZ		;SET MAX.VBN THIS SEG.
	  LET $OHVBN+2 := $TFSIZ+2
	  LET $WVBN := #1
	  LET $WVBN+2 := #0
	  LET $OHHD+B.STAT := #1
	  LET R0 := $INDEV
	  ALUN$S #INLUN,(R0),2(R0)	;RE-ASGN LUN TO I.P.
	  LET R0 := #$OHBF		;COPY HDR INTO OHBF
	ELSE
	  IF $BUF1+P.FLAG EQ #PF.HDR!PF.ERR THEN RETURN NOERROR
	  LET $IHVBN := $TFSIZ		;SET MAX.VBN THIS SEG.
	  LET $IHVBN+2 := $TFSIZ+2
	  $CALL $BUFCK <,,,,#$IHHD>	; GET INDEX FILE HEADER BUFFER
	  LET B.STAT(R4) := #1		; MARK IT BUSY
	  LET R0 := #$IHBF		; COPY HEADER INTO IHBF
	END
	LET $TVBN := #1			;INIT TAPE VBN TO 1
	LET $TVBN+2 := #0
	LET $TFSIZ := $FISIZ		;SAVE SIZE OF FILE
	LET $TFSIZ+2 := $FISIZ+2
	LET $TFID := $FID		;SAVE FILE NO.
	LET $TFID+2 := $FID+2
	LET $TFID+4 := $FID+4
	THRU R1 := #256.
	  LET (R0)+ := (R5)+
	END LOOP
	RETURN NOERROR			; HEADER SUCCESSFULLY READ



	.END
