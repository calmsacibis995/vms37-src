	$BEGIN	DSC,0034,<DISK SAVE AND COMPRESS MAIN PROGRAM>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  1-NOV-76  22:44
;
; ANDREW C. GOLDSTEIN  20-MAR-1980  14:46
; ACG0160 - WAIT FOR I/O COMPLETION AT END OF COPY PASS
;
; ACG0014 - ANDREW C. GOLDSTEIN  9-JAN-1978
; FORCE NON-MERGE MODE IF VOLUME IS PART OF A VOLUME SET
; ADD LOGIC TO PROCESS BAD FILE HEADERS
;
; G.RITTENBURG 11-MAR-77	001  MISSING LINE INSERTED
; G.RITTENBURG  5-APR-77  	UPDATED FOR CMP/VFY DISK TO/FROM TAPE
; **GR01---G.RITTENBURG 12-OCT-1978
; CORRECTIONS TO REMOVE TROUBLESOME A$LUNS CALLS AND TO
; INSURE CORRECT ASIGNMENT OF LUNS TO DEVICES.
;
; **GR02---G.RITTENBURG 12-OCT-1978
; CORRECTION TO INITIALIZE STARTING O.P. VBN AND OHVBN
;
; **GR03---G.RITTENBURG 12-OCT-1978
; CORRECTIONS FOR MULTI-REEL VERIFY (SEE SWTAP)
;
; **GR04---G.RITTENBURG 12-OCT-1978
; REMOVE 2ND REWIND AND UNLOAD AT EOF-MULTI-REEL TAPE I.P.
;
; **GR05---G.RITTENBURG 12-OCT-1978
; CORRECTIONS AT RESYN1
; ALL ABOVE CORRECTIONS FROM 11M DSC.


	.MCALL	ALUN$S

;
; THIS IS THE MAIN PROGRAM OF DSC. IT INITIALIZES ITSELF, ACQUIRES
; A COMMAND, AND PROCESSES IT.
;
; FIRST INITIALIZE DSC BY ZEROING THE ENTIRE IMPURE AREA.
;

$DSC::	
	LET R0 := #$ZERO		; START OF AREA TO ZERO
	THRU R1 := #<$ENDZ-$ZERO>/2	; WORD COUNT
	  LET (R0)+ := #0
	END LOOP
	LET $STAK := SP			; SAVE THE STACK POINTER

;
; NOW ACQUIRE AND PARSE A COMMAND LINE. IF END OF CONSOLE INPUT
; IS REACHED, THE PARSER ROUTINE WILL EXIT RATHER THAN RETURN.
;
	$CALL $DSCPR

;
; ESTABLISH WHETHER THE INPUT AND OUTPUT ARE DISK OR TAPE, AND SET
; UP THE FUNCTION DISPATCH TABLES ACCORDINGLY.
;
	LET R0 := #$INTAB		; INPUT DISPATCH TABLE
	IF #KY.TAP SET.IN $IFLAG
	  LET R2 := #$INTAP		; TAPE INPUT
	ELSE
	  LET R2 := #$INDSK		; DISK INPUT
	END
	THRU R1 := #$INTBL		; TABLE WORD COUNT
	  LET (R0)+ := (R2)+		; COPY VECTORS INTO TABLE
	END LOOP

	LET R0 := #$OUTAB		; OUTPUT DISPATCH TABLE
	IF #KY.TAP SET.IN $OFLAG
	  LET R2 := #$OUTAP		; TAPE OUTPUT
	ELSE
	  LET R2 := #$OUDSK		; DISK OUTPUT
	END
	THRU R1 := #$OUTBL		; TABLE WORD COUNT
	  LET (R0)+ := (R2)+		; COPY VECTORS INTO TABLE
	END LOOP

;
; DO INPUT AND OUTPUT INITIALIZATION. IN THIS PROCESS, WE READ THE
; VOLUME SUMMARY (OF THE FIRST UNIT IF THIS IS A VOLUME SET).
;
	$CALL $ALUNI <#$IVTAB>		; ASSIGN LUN TO FIRST DEVICE
	$CALL @$INITI			; INIT INPUT DEVICE
	$CALL @$RDSUM			; READ DEVICE SUMMARY

;
; RECORD THE NUMBER OF VOLUMES BEING PROCESSED.
; IF THE INPUT IS A DISK VOLUME SET WHICH IS TO BE MERGED, THEN ALL
; THE UNITS MUST BE ON LINE. THE SAME HOLDS IF THE INPUT IS
; A MERGED VOLUME SET AND THE OUTPUT IS DISK.
;
	IF $B2DAT+S.RVN NE #0		; IF PART OF VOLUME SET
	  LET $OFLAG := $OFLAG OFF.BY #KY.MRG ; CLEAR MERGE MODE
	  LET $B2DAT+S.MRG := #0
	END

	IF #KY.MRG SET.IN $OFLAG
	  LET $NVOL := $B2DAT+S.NVOL	; SAVE NUMBER OF VOLUMES
	END
	LET R0 := $NVOL
	IF R0 EQ #0 THEN LET R0 := #1
	IF #KY.DSK SET.IN $IFLAG
	  IF $IVNUM HI R0 THEN ERROR ER.TMI ; TOO MANY DISKS
	  IF $IVNUM LO R0 THEN ERROR ER.TFI ; TOO FEW DISKS
	END
	IF #KY.DSK SET.IN $OFLAG
	  IF $OVNUM HI R0 THEN ERROR ER.TMO ; TOO MANY DISKS
	  IF $OVNUM LO R0 THEN ERROR ER.TFO ; TOO FEW DISKS
	END
;
; CHECK FOR COMPARE ONLY OPERATION
;
	IF #KY.CMP SET.IN $OFLAG THEN JUMPTO COMP

;
; NOW INIT THE FIRST OUTPUT DEVICE AND WRITE OUT THE VOLUME SUMMARY.
; THEN COPY THE INDEX FILE DATA.
;
	$CALL $ALUNO <#$OVTAB>		; ASSIGN LUN TO FIRST DEVICE
	$CALL @$INITO			; INIT OUTPUT DEVICE
	$CALL @$WTSUM			; AND WRITE THE SUMMARY TO IT

	LET R2 := #0			; INIT PSEUDO BLOCK NUMBER
	LET R3 := #0			; FOR INDEX FILE DATA
	REPEAT
	  $CALL @$RDIXF <,,R2,R3,#$B2HD> ; READ INDEX FILE DATA
	  ON.ERROR LEAVE LOOP		; RETURNS ERROR WHEN DONE
	  $CALL @$WTIXF <,,R2,R3,R4>	; WRITE INDEX FILE DATA
	END LOOP
	LET $IHHD+B.STAT := #0		; INVALIDATE FILE HEADER
	LET $OHHD+B.STAT := #0

;
; NOW, IF MERGE MODE IS IN EFFECT, COPY THE VOLUME SUMMARIES AND
; INDEX FILE HEADER AND DATA FOR ALL OF THE VOLUMES IN THE SET.
;
	PUSH #2				; KEEP COUNT ON STACK
	WHILE (SP) LOS $NVOL		; NOTE FIRST VOLUME IS DONE
	  IF #KY.DSK SET.IN $IFLAG	; IF INPUT IS DISK
	    LET R0 := $INDEV + #V.SIZ	; POINT TO NEXT UNIT
	    $CALL $ALUNI <R0>		; ASSIGN LUN TO IT
	  END
	  IF #KY.DSK SET.IN $OFLAG	; IF OUTPUT IS DISK
	    LET R0 := $OUDEV + #V.SIZ	; POINT TO NEXT UNIT
	    $CALL $ALUNO <R0>		; ASSIGN LUN TO IT
	  END

	  $CALL @$RDSUM			; READ VOLUME SUMMARY
	  $CALL @$WTSUM			; AND WRITE IT
	  LET R2 := #0			; INIT START "BLOCK NUMBER"
	  LET R3 := #0
	  REPEAT
	    $CALL @$RDIXF <,,R2,R3>	; READ INDEX FILE DATA
	    ON.ERROR LEAVE LOOP		; RETURNS ERROR WHEN DONE
	    $CALL @$WTIXF <,,R2,R3>	; WRITE INDEX FILE DATA
	  END LOOP
	  LET $IHHD+B.STAT := #0	; INVALIDATE FILE HEADER
	  LET $OHHD+B.STAT := #0
	  LET (SP) := (SP) + 1		;  001 THIS LINE WAS MISSING
	END LOOP			; LOOP FOR ALL UNITS
	TST (SP)+			; CLEAN THE STACK

;
; WE ARE NOW READY TO COPY THE FILE DATA. IF MERGE MODE, THIS IS
; DONE ONE VOLUME AT A TIME (IN ORDER BY RVN). IN EACH VOLUME,
; WE FIND ONE ACTIVE FILE HEADER AT A TIME. THE FILE IS CREATED ON
; THE OUTPUT DEVICE, AND THEN THE DATA BLOCKS ARE COPIED. IF
; MERGE MODE IS ON, THEN EXTENSION HEADERS OF THE FILE ARE COPIED
; TO THE OUTPUT DEVICE, FOLLOWED BY THE DATA OF THE FILE SEGMENT THAT
; THEY REPRESENT. IF MERGE MODE IS OFF, THEN EVERY HEADER IS CONSIDERED
; TO BE A SEPARATE FILE.
;
	IF $NVOL HI #0			; IF WE ARE DOING MULTI-VOLUME
	  LET $RVN := #1		; START WITH 1
	ELSE
	  LET $RVN := #0		; OTHERWISE IT IS 0
	END
	LET $FID := #3			; FIRST FILE ON EACH VOL IS MFD
	REPEAT				; LOOP FOR FILES ON VOLUME
FIND:	  $CALL @$FIND			; FIND NEXT FILE HEADER
	  ON.ERROR LEAVE LOOP		; EXIT LOOP WHEN DONE
	  IF $BUF1+P.FLAGS EQ #PF.HDR!PF.ERR ; CHECK FOR BAD HEADER RECORD
	    $CALL @$DELHD		; DELETE THE FILE HEADER
	    GOTO FIND			; AND LOOP
	  END
	  $CALL @$ALLOC			; ALLOCATE FILE ON OUTPUT VOLUME
	  LET $VBN := #1		; INIT VBN TO 1
	  LET $VBN+2 := #0
	  REPEAT			; LOOP FOR ALL FILE SEGMENTS
;
; ENTRY POINT TO RESUME COPY AFTER VERIFY PREVIOUS REEL.
;
COPY1::	    
	    DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
	    IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
	    REPEAT			; LOOP FOR BLOCKS IN FILE
	      DCOMP $VBN+2,$VBN, $IHVBN+2,$IHVBN
	      IF RESULT IS HI LEAVE LOOP ; DONE ALL BLOCKS IN FILE
	      $CALL @$RDDAT <,#BLKF,,,#$B1HD> ; START ONE READ
	      $CALL @$RDDAT <,#BLKF,,,#$B2HD> ; START OTHER READ
	      $CALL @$WATCK <,,,,#$B1HD> ; WAIT FOR FIRST COMPLETION
	      ON.ERROR THEN $CALL RESYNC
	      LET B.STAT(R4) := #0	; INVALIDATE THE BUFFER
	      $CALL @$WTDAT <,,,,R4>	; AND WRITE IT
	      ON.ERROR THEN $CALL RESYN1
	      $CALL @$WATCK <,,,,#$B2HD> ; WAIT FOR SECOND COMPLETION
	      ON.ERROR THEN $CALL RESYNC
	      LET B.STAT(R4) := #0	; INVALIDATE THE BUFFER
	      $CALL @$WTDAT <,,,,R4>	; AND WRITE IT
	      ON.ERROR THEN $CALL RESYN1
	    END LOOP			; LOOP FOR BLOCKS IN FILE SEGMENT
	    DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
	    IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
	    $CALL @$RDEXH		; READ EXTENSION HEADER
	    ON.ERROR THEN $CALL RESYN1
	    $CALL @$WTEXH		; WRITE EXTENSION HEADER
	    ON.ERROR
	      LET $IHHD+B.STAT := #0	; INVALIDATE FILE HEADERS
	      LET $OHHD+B.STAT := #0
	      GOTO FIND
	    END
	  END LOOP			; LOOP FOR EXTENSION HEADERS
	  LET $IHHD+B.STAT := #0	; INVALIDATE FILE HEADERS
	  LET $OHHD+B.STAT := #0
	END LOOP			; LOOP FOR FILES
;
; ALL DONE. FINISH INPUT AND OUTPUT AND GO TO THE TOP FOR
; ANOTHER COMMAND.
;
END:	$CALL  @$FINO   <#0>		; FINISH OUTPUT
	$CALL $BUFCK <,,,,#$B1HD>	; WAIT FOR FINAL I/O COMPLETION
	$CALL $BUFCK <,,,,#$B2HD>
;
; CHECK IF A VERIFY PASS IS REQUESTED
;
	IF #KY.VER SET.IN $OFLAG
	  IF #KY.VFY OFF.IN $FLAG1
	    ERRP ER.VFY			; SIGNAL START VERIFY
	    LET $FLAG1 := $FLAG1 SET.BY #KY.VFY	;INDICATE
	    				;VERIFY IN PROGRESS
	    LET SP := $STAK		;RESET SP
	    GOTO COMP			;START VERIFY
	  END
	END
	LET SP := $STAK			;RESET SP
	JUMPTO $DSC

;
; WE GET HERE TO DO A VERIFY PASS.
; NOTE THAT THIS CODE IS NOT GENERAL! IT WORKS FOR DISK TO DISK, DISK TO TAPE,
; OR TAPE TO DISK,SINGLE DISK VOLUME ONLY.

;  IF THIS IS A COMPARE ONLY OPERATION,POSITION I.P.AND O.P. VOLUMES
;

COMP::	LET $B2HD+B.STAT := #0		; DISCARD BUFFERS LEFT BY $RDSUM
	LET $RVN := #0			;SET $RVN TO ZERO
	LET $B1HD+B.STAT := #0
	LET $IHHD+B.STAT := #0
	LET $IXHD+B.STAT := #0
	LET $OHHD+B.STAT := #0
	LET $INDEV := #$IVTAB
	LET $OUDEV := #$OVTAB
	IF #KY.TAP SET.IN $OFLAG	;YES = TAPE OUTPUT
	  LET $OXHD+B.STAT := #0
	  LET $FLAG1 := $FLAG1 SET.BY #KY.NIP ;FLAG O.P.
	  $CALL $ALUNI  <#$OVTAB>	;ASGN INLUN TO O.P. 
	  $CALL $TRDSO			;INITIALIZE O.P.
	  LET R2 := #0
	  LET R3 := #0
	  LET $B2HD+B.STAT := #0	;RELEASE BUFFR
	  REPEAT
	    $CALL $TRDID <,,R2,R3,#$B2HD> ;SPACE PAST HOME &BOOT BLKS & IFBM
	    ON.ERROR LEAVE LOOP
	    LET B.STAT(R4) := #0
	  END LOOP
	  LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP ;RESET FOR I.P.
	ELSE
	  IF #KY.CMP SET.IN $OFLAG	;IF COMPARE FCN
	    $CALL $DRDSO		;INIT O.P. DISK
	  END
	END
	$CALL $ALUNI <#$IVTAB>		;ASSIGN INLUN TO I.P.
	$CALL $ALUNO <#$OVTAB>		; AND OUTLUN TO OUTPUT
	LET $B2HD+B.STAT := #0
	LET $IHHD+B.STAT := #0
	LET $B1HD+B.STAT := #0
	LET $IXHD+B.STAT := #0
	IF #KY.TAP SET.IN $IFLAG
	  				;INIT. AND READ SUMMARY BLK FROM I.P. TAPE
	  IF #KY.VFY SET.IN $FLAG1	;IF VERIFY
	    $CALL $TINI
	    $CALL $TRDSU
	  END
	  				;NOW READ HOME,BOOT,AND IFBM BLKS
	  LET R2 := #0
	  LET R3 := #0
	  LET $B2HD+B.STAT := #0	;RELEASE BUFFER
	  REPEAT
	    $CALL $TRDID <,,R2,R3,#$B2HD>
	    ON.ERROR LEAVE LOOP
	    LET B.STAT(R4) := #0
	  END LOOP
	ELSE
	  LET $B2HD+B.STAT := #0
	  IF #KY.CMP SET.IN $OFLAG	;IF COMPARE FCN
	    $CALL $DRDSU		; INIT I.P. DISK
	  END
	END
	LET $IHHD+B.STAT := #0		;RELEASE HEADER BUFFER
	LET $B2HD+B.STAT := #0		; DISCARD SUMMARY DATA ONLY

;
; THE VERIFY OPERATION IS VERY SIMILAR TO THE COPY OPERATION. WE FIND
; A FILE ON THE INPUT DISK, AND THEN READ THE CORRESPONDING FILE HEADER
; FROM THE OUTPUT DISK. THEN WE READ DATA BLOCKS FROM EACH FILE INTO
; EACH OF THE BUFFERS AND COMPARE THEM.
;
VFY:	
	LET $FID := #3			;INIT FILE NO. =3
	LET $RVN := #0
CONT:	
	$CALL @$FIND			; FIND NEXT FILE HEADER
	ON.ERROR
	  IF #KY.TAP OFF.IN $OFLAG	;IF TAPE O.P.
ENDVFY:	    LET SP := $STAK		;RESET SP
	    JUMPTO $DSC			;END OF I.P. AND O.P.  LAST VFY PASS
	  END
	END
	LET $B2HD+B.STAT := #0		; DISCARD HEADER
	LET $B1HD+B.STAT := #0		; DISCARD ATTRIBUTE BLOCK
	IF $BUF1+P.FLAGS EQ #PF.HDR!PF.ERR ; CHECK FOR DELETED HEADER
	  IF #KY.TAP SET.IN $OFLAG	; IF OUTPUT IS TAPE
	    $CALL @$FINDO <,,#0,$FID>	; GOBBLE DELETED HEADER FROM TAPE
	  END
	  JUMPTO CONT2			; NO FILE TO VERIFY
	END
	$CALL @$FINDO  <,,#0,$FID>	; READ OUTPUT FILE HDR
	ON.ERROR THEN GOTO ENDVFY
	LET $OHVBN := R1		; SET $OHVBN
	LET $OHVBN+2 := R0
	LET H.VBN(R5) := #0		; INIT STARTING VBN
	LET H.VBN+2(R5) := #0
	LET $VBN := #1			;INIT STARTING VBN
	LET $VBN+2 := #0
	LET $TVBN := $VBN
	LET $TVBN+2 := $VBN+2
	LET $WVBN := #1
	LET $WVBN+2 := #0
	REPEAT				; LOOP FOR ALL FILE SEGMENTS
	  				;ENTRY POINT TO RESUME VERIFY CURRENT REEL
COMP1::	  
	  DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
	  IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
	  REPEAT			; LOOP FOR BLOCKS IN FILE
	    LET R1 := $IHVBN - $VBN	; COMPUTE BLOCKS TO GO
	    LET R0 := $IHVBN+2 - CARRY - $VBN+2
	    IF RESULT IS MI LEAVE LOOP
	    LET R1 := R1 + #01
	    LET R0 := R0 + CARRY
	    IF RESULT IS NE OR R1 HI #4
	      LET R1 := #BLKF		; LIMIT TO BLOCKING FACTOR
	    END
	    LET $B1HD+B.STAT := #0	;RELEASE BUFFER
	    LET $B2HD+B.STAT := #0
	    PUSH R1			; SAVE BLOCKS COUNT
	    $CALL @$RDDAT <,R1,,,#$B1HD> ; READ DATA FROM INPUT
	    $CALL  @$WATCK  <,,,,#$B1HD> ; WAIT FOR COMPLETION
	    $CALL @$RDATO <,(SP)+,,,#$B2HD> ; READ O.P. DATA
	    LET $TVBN := $WVBN		;SAVE NEW VBN
	    LET $TVBN+2 := $WVBN+2
	    LET R0 := $BUF1+P.CNT	; SET NO. BYTES TO COMPARE
	    ASR R0			; CONVERT TO WORDS
	    LET R1 := #$B1DAT		; POINT TO DATA
	    LET R2 := #$B2DAT
	    THRU R0
	      IF (R1)+ NE (R2)+		; COMPARE DATA
		ERRP ER.VER		; VERIFICATION ERROR
		LEAVE LOOP
	      END
	    END LOOP
	    LET R0 := #$BUF1		; POINT TO MAIN BUFFERS
	    LET R1 := #$BUF2
	    THRU R2 := #B.SIZ*BLKF/2
	      LET -(R0) := #0		; CLEAN OUT ALL CONTROL BLOCKS
	      LET -(R1) := #0
	    END LOOP
	  END LOOP			; LOOP FOR BLOCKS IN FILE.
	  IF #KY.MRG OFF.IN $OFLAG THEN LEAVE LOOP ;END OF EXTENT NMG MODE
	  DCOMP $VBN+2,$VBN, $FISIZ+2,$FISIZ
	  IF RESULT IS HI LEAVE LOOP	; DONE ALL BLOCKS IN FILE
	  LET $B2HD+B.STAT := #0	; RELEASE $BUF2 FOR EXTEND HEADER
	  $CALL @$RDEXH			; READ EXTENSION HEADER
	  ON.ERROR LEAVE LOOP
	  LET $B2HD+B.STAT := #0	; DISCARD HEADER
	  IF #KY.TAP SET.IN $OFLAG	; IF OUTPUT IS TAPE
	    $CALL $RDWLN <#OUTLUN,,,,#$B2HD> ; EAT THE EXTENSION HEADER
	    LET $B2HD+B.STAT := #0	; DISCARD HEADER
	  END
	END LOOP			; LOOP FOR EXTENSION HEADERS
CONT2:	
	LET $IHHD+B.STAT := #0		; INVALIDATE HEADER BUFFERS
	LET $OHHD+B.STAT := #0
	LET $B1HD+B.STAT := #0		; RELEASE BUF1 0 LGTH FILE
	LET $B2HD+B.STAT := #0		; RELEASE BUF2 0 LGTH FILE
	JUMPTO CONT			; LOOP FOR ALL FILES


;+
;
; *** - RESYNC	RESYNCHRONIZE TAPE INPUT
;
; THIS ROUTINE IS CALLED WHEN THE INPUT TAPE IS OUT OF SYNC FROM WHERE
; WE THINK IT SHOULD BE. IT RETURNS IF WE JUST HAVE THE WRONG DATA
; BLOCK OF THE FILE. IF THINGS ARE REALLY BAD (I.E., WRONG BLOCK TYPE)
; IT TRANSFERS TO THE START OF THE FIND OPERATION FOR THE NEXT FILE.
; NOTE THAT THIS ROUTINE MUST BE EXECUTED EXACTLY ONE CALL AWAY FROM
; THE MAIN COPY LOOP.
;
; INPUTS:
;
;	R4 = BCB ADDRESS OF LAST TAPE BLOCK READ
;
;-

RESYNC:	
	IFB (R4) EQ #IE.EOF GOTO EOF
	LET R5 := R4 + #B.SIZ		; POINT TO DATA BUFFER
	IF P.FLAG(R5) EQ #PF.DAT	; IF WE HAVE DATA
	  IF P.FID(R5) EQ $FID AND P.FID+2(R5) EQ $FID+2 AND P.FID+4(R5) EQ $FID+4
	    				; AND FILE ID IS RIGHT
	    LET R1 := P.CNT(R5) + #511.	; GET BYTE COUNT
	    CLRB R1
	    SWAB R1			; TURN INTO BLOCK COUNT
	    ASR R1
	    LET $VBN := P.VBN(R5) + R1	; RESET VBN
	    LET $VBN+2 := P.VBN+2(R5) + CARRY
	    LET $TVBN := $VBN
	    LET $TVBN+2 := $VBN+2
	    RETURN			; AND PROCEED
	  END
	END
;
; ALTERNATE ENTRY FOR WHEN IT IS ALREADY CLEAR THAT WE ARE REALLY LOST.
;
RESYN1::
	IFB (R4) EQ #IE.EOF GOTO EOF	; OUT IF END OF FILE
	TST (SP)+			; THROW AWAY RETURN
	IF #KY.TAP SET.IN $IFLAG	; ONLY IF INPUT IS TAPE
	  ERRP ER.FSY			; PRINT MESSAGE
	  LET R5 := #-1			; SET UP TO BACKSPACE 1 BLOCK
	  WHILE $IWAIT NE #0		; WAIT FOR COMPLETION
	    $CALL $WAITI <,,,,$IWAIT>	; OF OUTSTANDING I/O
	    LET R5 := R5 + #-1		; AND COUNT IT
	  END LOOP
	  $CALL $SPACB  <,#INLUN,,,R4,R5>
	  IFB (R4) EQ #IE.EOF		; IF WE BANGED INTO EOF
	    $CALL $SPACF  <,#INLUN,,,R4,#1>
	  END
	END
	LET $IFLAG := $IFLAG SET.BY #KY.LOS ; OBSERVE THAT WE ARE LOST
	LET $B1HD+B.STAT := #0		;INVALIDATE BUFFERS
	LET $B2HD+B.STAT := #0
	LET $IHHD+B.STAT := #0		; AS WELL AS HEADERS
	LET $OHHD+B.STAT := #0
	JUMPTO FIND			; AND START LOOKING FOR A NEW FILE
;
; TO HERE IF WE HIT EOF ON THE INPUT TAPE
;
EOF:	TST (SP)+			; THROW AWAY RETURN
	JUMPTO END			; AND QUIT



	.END	$DSC

