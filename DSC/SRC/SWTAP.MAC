	$BEGIN	SWTAP,0016.2,<SWITCH TAPE UNIT>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  18-AUG-76  21:14
; GEORGE RITTENBURG 14-APR-77 MODIFIED FOR VFY/CMP DISK TO/FROM TAPE
;
; **GR01---G.RITTENBURG 23-OCT-1978
; CORRECTIONS FROM 11M AND CONDITIONALIZED FOR 11M
;
; ACG0014 - ANDREW C. GOLDSTEIN  10-JAN-1978
; ADD $RVN TO LIST STORED IN $HOLD, RE-INIT TAPE LABELS ONLY FOR OUTPUT TAPE


	.MCALL	ALUN$S
;
	.IF	NDF,R$$NVX
;
	.MCALL	FHDL2$
	FHDL2$
;
	.ENDC

;+
;
; *** - $SWITI	SWITCH TO NEXT INPUT TAPE
;
; THIS ROUTINE VERIFIES THE TRAILER LABEL SET ON THE CURRENT INPUT
; TAPE AND REWINDS IT AND SETS IT OFF-LINE. IT THEN FINDS THE NEXT
; AVAILABLE TAPE UNIT IN THE INPUT VOLUME TABLE, READIES IT FOR
; INPUT, AND VERIFIES THE HEADER LABEL SET.
;
; INPUTS:
;
;	R0 = BUFFER CONTROL BLOCK WITH EOF
;	INPUT LUN ASSIGNED TO TAPE UNIT
;	$INDEV POINTING AT CURRENT ENTRY IN TABLE
;	VOLUME LABEL IN $IVBF
;	FILE LABELS IN $IF1BF AND $IF2BF
;
; OUTPUTS:
;
;	INPUT UNIT ASSIGNED TO NEW TAPE UNIT
;	$OUDEV POINTING AT NEW DEVICE TABLE ENTRY
;	UPDATED VOLUME LABEL IN $IVBF
;	UPDATED FILE LABELS IN $IF1BF AND $IF2BF
;	OLD TAPE COMPLETED AND REWINDING
;	NEW TAPE SET UP
;	ALL REGISTERS PRESERVED
;
;-

$SWITI::
	$CALL $SAVAL			; SAVE ALL REGISTERS
	BEGIN RLAB
	  LET B.STAT(R0) := #0		; DISCARD BUFFER WITH EOF
	  LET R4 := B.LINK(R0)		; GET NEXT BCB IN WAIT LIST
	  PUSH R4			; AND SAVE IT
	  PUSH R0			; SAVE FIRST BCB FOR LATER USE
	  IF R4 NE #0			; IF WE WERE READING AHEAD
	    $CALL $WAITI <,,,,R4>	; IT SHOULD GET FIRST TRAILER
	    ON.ERROR THEN ERROR ER.ILB
	    IF B.LINK(R4) NE #0
	      FATAL <EXCESSIVE READ AHEAD FOUND>
	    END
	    LET R5 := R4 + #B.SIZ
	    LET R1 := 2(R4)		; BYTE COUNT READ
	    IF RESULT IS NE LEAVE RLAB	; IF NOT DUMMY READ
	  END
	  $CALL $RDWAT <,#80.,,,(SP)>	; READ TRAILER INTO BUFFER
	  ON.ERROR THEN ERROR ER.ILB
	END RLAB
	IF R1 NE #80. OR (R5) NE #"EO THEN ERROR ER.IFM
	IF 2(R5) EQ #"F1		; IF END OF FILE SET
;WE SHOULD ONLY GET HERE AT EOF ON TAPE I.P.DURING COPY OR VFY
;AND WHEN EOF OCCURS  ON O.P. DURING VFY PASS
	  IF #KY.VER SET.IN $OFLAG     ;IF VFY REQUESTED
		IF #KY.VFY OFF.IN $FLAG1 ;AND NOT YET EXCUTED
			LET B.STAT(R4) := #0 ;RELEASE BUFFER
			JUMPTO POSIT
		END
	  END
	IF #KY.NIP SET.IN $FLAG1 AND $RELNO EQ #1  ; IF CURR.TAPE
	; IS O.P. AND NOT FIRST REEL
		GOTO SKUNL		; SKIP REWIND UNLOAD
	ELSE
	  	IF #KY.NIP OFF.IN $FLAG1 AND $RELNI EQ #1  ;IF CURR.TAPE
	; IS I.P. AND NOT FIRST REEL
		   GOTO SKUNL		; SKIP REWIND UNLOAD
		END
	END
	 $CALL $RWNDU <,#INLUN,,,R4>
SKUNL:	  
	  LET (R4) :B= #IE.EOF		; SET EOF STATUS
	  CMP (SP)+,(SP)+		;CLEAN STACK
	  RETURN
	END
;WE CAN GET HERE AT EOV ON I.P. TAPE DURING COPY PASS OR
; AT EOV ON EITHER I.P. OR O.P. DURING VFY PASS
	IF 2(R5) NE #"V1 THEN ERROR ER.IFM
	LET B.STAT(R4) := #0		; RELEASE THE BUFFER

	$CALL $RDWAT <,#80.,,,(SP)>	; READ EOV2
	ON.ERROR THEN ERRP ER.ILB
	IF R1 NE #80. OR (R5) NE #"EO OR 2(R5) NE #"V2 THEN ERRP ER.IFM
	LET $IFLAG := $IFLAG OFF.BY #KY.EOT  ;CLEAR EOT COND.
	LET B.STAT(R4) := #0  ;RELEASE BUFFER
	IF #KY.VER SET.IN $OFLAG
		IF #KY.VFY OFF.IN $FLAG1
		   LET $FLAG1 := $FLAG1 OFF.BY #KY.BSP  ;CAN NOT BACKSPACE BEYOND EOT
		  JUMPTO POSIT		;TO POSITION I.P. TAPE FOR VERIFY
		  END
	END
;WE CAN GET HERE AT EOV I.P. DURING COPY PASS OR
; AT EOV EITHER I.P. OR O.P. DURING VFY PASS
	$CALL $RWNDU  <,#INLUN,,,R4>
;
; NOW FIND, READY, AND INITIALIZE THE NEXT INPUT TAPE
;
	IF #KY.NIP SET.IN $FLAG1 AND #KY.VER SET.IN $OFLAG		;IF TAPE O.P. VFY
		$CALL $SWCHO	;TO WRITE INITIAL PART OF TAPE
		JUMPTO CONTCP	;TO CONTINUE COPYING
	END
	IF #KY.NIP SET.IN $FLAG1
	   LET $RELNO := $RELNO + #1	; BUMP O.P. REEL NO.
	   LET $OUDEV := $OUDEV + #V.SIZ  ; BUMP TO NEXT DEVICE O.P.
	   LET R0 := $OUDEV - #$OVTAB
	   $CALL $DIV  <R0,#V.SIZ>
	   IF R0 HIS $OVNUM
		LET $OUDEV := #$OVTAB
    	   END
	   LET R0 := $OUDEV
	 ELSE
	    LET $RELNI := $RELNI + #1		; BUMP I.P. REEL NO.
	    LET $INDEV := $INDEV + #V.SIZ	; BUMP TO NEXT INPUT DEVICE 
	    LET R0 := $INDEV - #$IVTAB	; SEE IF WE WERE USING THE LAST
	    $CALL $DIV <R0,#V.SIZ>		; ENTRY IN THE DEVICE TABLE
	    IF R0 HIS $IVNUM
	    LET $INDEV := #$IVTAB		; YES - WRAP TO THE FIRST
	    END
	    LET R0 := $INDEV
        END 
	ALUN$S #INLUN,(R0),2(R0)	; ASSIGN THE LUN TO IT
;
; PREPARE THE IMAGES OF THE EXPECTED HEADER LABEL SET
;
	IF #KY.NIP SET.IN $FLAG1
	   LET R0 := #$OVBF+9.
	ELSE
   	   LET R0 := #$IVBF+9.		; POINT TO END OF VOLUME NAME
	END
	INCB (R0)			; BUMP SEQUENCE NUMBER IN NAME
	IFB (R0) HIS #'9
	  LET (R0) :B= #'0		; HANDLE THE CARRY
	  INCB -(R0)
	END
	IF #KY.NIP SET.IN $FLAG1
	   LET $OVBF+10. :B= #40
	   LET R0 := #$OF1BF+31.
	ELSE
   	   LET #$IVBF+10. :B= #40		; CLEAR MIXED DENSITY FLAG
	   LET R0 := #$IF1BF+31.		; POINT TO FILE SECTION NUMBER
	END
	THRU R1 := #4			; INCREMENT BY 1 (IN ASCII)
	  INCB -(R0)			; BUMP DIGIT
	  IFB (R0) LOS #'9 LEAVE LOOP
	  LET (R0) :B= #'0		; WRAP TO 0 ON CARRY
	END LOOP
;
; NOW LOOP UNTIL THE RIGHT TAPE REEL IS MOUNTED
;
REPEET:
	    $CALL $INRDY		; AND WAIT UNTIL IT IS READY
	    LET R4 := 2(SP)		;RESET R4
	    IF R0 NE #0			; TAPE MUST BE AT BOT
	      ERRP ER.BOT		; OUTPUT MESSAGE
	      JUMPTO RERPET		; AND WAIT TO BE FIXED
	    END
	IF #KY.NIP SET.IN $FLAG1	; IF TAPE O.P.
	   LET R5 := $OFLAG
	ELSE
	  LET R5 := $IFLAG
	END
	IF #KY.160 SET.IN R5	; NOW SET THE CORRECT DENSITY
	      $CALL $STI16		; 1600 BPI
	ELSE
	      $CALL $STI08		; OR 800 BPI
	END
;WE ARE NOW READY TO CHECK FRONT OF I.P. TAPE FOR COPY ONLY OPERATION OR
; TO COPY FROM/TO I.P. OR O.P. TAPE FOLLOWING VERIFY OPERATION
;
	   $CALL SPACTP
	   ON.ERROR THEN JUMPTO RERPET
	IF #KY.VER OFF.IN $OFLAG THEN JUMPTO FINISH
;IF NOT THE END OF A VERIFY PASS, JUMP.
	CONTCP:
		IF #KY.NIP SET.IN $FLAG1	; IF CURR. TAPE IS O.P.
		   LET R0 := $INDEV	;RE-ASGN LUN TO I.P.
		   ALUN$S #INLUN,(R0),2(R0)
	   IF $IHBF+H.FNUM NE $OHBF+H.FNUM ;IF I.P. AND O.P. HDRS NE
; BACK UP I.P. TO MATCH O.P.
		LET $FISIZ := $TFSIZ
		LET $FISIZ+2 := $TFSIZ+2	;SET $FISIZ
		LET $IHVBN := $OHVBN		;SET $IHVBN
		LET $IHVBN+2 := $OHVBN+2
		LET $FID := $TFID		;SET $FID
		LET $FID+2 := $TFID+2
		LET $IHHD+B.STAT := #0		;RELEASE I.P. HDR.
		LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP
		$CALL $RDHDR  <,,#0,$OHBF+H.FNUM>
		LET $IHBF+H.VBN := $OHBF+H.VBN	;SET INIT. VBN
		LET $IHBF+H.VBN+2 := $OHBF+H.VBN+2
	   END
		END
		LET $FLAG1 := $FLAG1 OFF.BY #37777	; RESET $FLAG1
	LET $XESQN := $TESQN			; SAVE $TESQN
		LET R0 := #$HOLD
		LET $VBN := $TVBN
		LET $VBN+2 := $TVBN+2
	LET $THVBN := $OHVBN			;SAVE $OHVBN
	LET $THVBN+2 := $OHVBN+2
		LET (R0)+ := $TVBN
		LET (R0)+ := $TVBN+2
		LET (R0)+ := $FID
		LET (R0)+ := $FID+2
		LET (R0)+ := $RVN
	LET (R0)+ := $OHBF+H.FNUM		;SAVE OP FILE ID
		LET (R0)+ := $IHVBN
		LET (R0)+ := $IHVBN+2
	LET $IIVBN := $IHBF+H.VBN
	LET $IIVBN+2 := $IHBF+H.VBN+2
	LET $OIVBN := $OHBF+H.VBN
	LET $OIVBN+2 := $OHBF+H.VBN+2
		LET (R0)+ := $FISIZ
		LET (R0)+ := $FISIZ+2
	;RESTORE FID IN PREFIXES
		LET R0 := #$BUF2+P.FID
		LET (R0)+ := $FID
		LET (R0)+ := $FID+2
		LET (R0)+ := $FID+4
		LET (R0) := #0
		LET R0 := #$BUF1+P.FID  ;AND IN OTHER PREFIX
		LET (R0)+ := $FID
		LET (R0)+ := $FID+2
		LET (R0)+ := $FID+4
	;RELEASE BUFFERS
		LET $B1HD+B.STAT := #0
		LET $B2HD+B.STAT := #0
		LET SP := $STAK	;CLEAN OUT STACK
		 ERRP ER.RSC
		JUMPTO COPY1		;RESUME COPY

RERPET:
	$CALL $RWNDU  <,#INLUN,,,R4>
	 LET B.STAT(R4) := #0
	JUMPTO REPEET		; TRY AGAIN
; READ AND VERIFY THE HEADER LABELS
;
SPACTP:
	    $CALL $RDWAT <,#80.,,,2(SP)>	; READ THE VOLUME HEADER LABEL
	    IF  #KY.NIP SET.IN $FLAG1		; IF CURRENT TAPE IS O.P.
		$CALL CKLAB <#$OVBF,,,,,R5>
	    ELSE
		    $CALL CKLAB <#$IVBF,,,,,R5>	; CHECK THE LABEL
	    END
	    ON.ERROR THEN RETURN ERROR
	    LET B.STAT(R4) := #0	; RELEASE THE BUFFER

	    $CALL $SPACB  <,#INLUN,,,R4,#1>
	    $CALL $INCK <,,,,R4>
	    ON.ERROR
	      ERRP ER.ILB
	      RETURN ERROR
	    END

	    $CALL $RDWAT <,#80.,,,R4>	; READ HDR1
	     IF #KY.NIP SET.IN $FLAG1			; IF CURR. TAPE IS O.P.
		$CALL CKLAB <#$OF1BF,,,,,R5>
	     ELSE
		    $CALL CKLAB <#$IF1BF,,,,,R5> ; VERIFY IT
	    END
	    ON.ERROR THEN RETURN ERROR
	    LET B.STAT(R4) := #0	; RELEASE THE BUFFER

	    $CALL $RDWAT <,#80.,,,R4>	; READ HDR2
	     IF #KY.NIP SET.IN $FLAG1			; IF CURR. TAPE IS O.P.
		$CALL CKLAB <#$OF2BF,,,,,R5>
	     ELSE
		    $CALL CKLAB <#$IF2BF,,,,,R5> ; VERIFY IT
	    END
	    ON.ERROR THEN RETURN ERROR
	    LET B.STAT(R4) := #0	; RELEASE THE BUFFER
		$CALL $SPACF  <,#INLUN,,,R4,#1>
		ON.ERROR THEN ERROR ER.DIR
		   IFB (R4) LT #0
			IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
			  ERROR ER.IIR
			ELSE
			   ERRP ER.IIR
			END
		   END
		LET $IFLAG := $IFLAG OFF.BY #KY.EOT
		LET B.STAT(R4) := #0
	    RETURN			; CORRECT TAPE IS ON LINE
;
; FINISH SETTING UP THE TAPE
;
FINISH:
	POP R4
	$CALL $READ <,#2048.+P.SIZ,,,R4> ; RE-ISSUE ORIGINAL READ
	$CALL $WAITI <,,,,R4>		; AND LET IT COMPLETE FOR SYMMETRY
	POP R4				; GET READ AHEAD BUFFER
	IF RESULT IS NE			; IF EXISTS
	  IF 2(R4) NE #0		; IF NOT A DUMMY READ
	    $CALL $READ <,#2048.+P.SIZ,,,R4> ; RE-ISSUE IT
	  ELSE
	    LET B.STAT(R4) := #3	; SET READ IN PROGRESS
	    $CALL $LINKI <,,,,R4>	; AND LINK TO WAIT LIST
	  END
	END
	RETURN				; DONE AND GOOD LUCK
;
; WE GET HERE TO POSITION I.P. OR O.P. TAPES FOR VERIFY OPERATION
;
POSIT::
	ERRP ER.VFY		;INDICATE BEGIN VFY PASS
	LET $FLAG1 := $FLAG1 SET.BY #KY.VFY
	IF $FLAG1 GT #0 AND $RELNO NE #1
	; IF CURR. TAPE IS O.P. AND NOT FIRST REEL

	    LET R0 := $OUDEV	; ASSIGN INLUN TO O.P. DEV.
	    ALUN$S #INLUN,(R0),2(R0)
	    LET $FLAG1 := $FLAG1 SET.BY #KY.NIP  ; INDICATE O.P.
	   GOTO SKCMP		; BRANCH
	ELSE
	    IF $FLAG1 LT #0 AND $RELNI NE #1
	; IF CURR. TAPE IS I.P. AND NOT FIRST REEL

		GOTO SKCMP	; BRANCH
	   END
	END
	LET SP := $STAK		;CLEAN OUT THE STACK
	JUMPTO COMP		;TO VERIFY 1ST REEL
SKCMP:	$CALL $RWND  <,#INLUN,,,R4>
	$CALL $INCK <,,,,R4>
	ERRP ER.BOT		;TAPE REWINDING
REPETE:
	$CALL $INRDY
	IF R0 NE #0 THEN GOTO REPETE  ;LOOP UNTIL TAPE AT BOT
	LET (SP) := #$B1HD
	LET $B1HD+B.STAT := #0
	IF $FLAG1 GT #0		; ONLY IF TAPE IS OUTPUT
	  LET $OF1BF := #"HD
	  LET $OF1BF+2 := #"R1
	  LET R0 := #$OF1BF+54.
	  THRU R1 := #3		;ZERO BLOCK COUNT
		LET (R0)+ := #"00
	  END LOOP
	  LET $OF2BF := #"HD
	  LET $OF2BF+2 := #"R2
	END
	$CALL SPACTP		;SPACE PAST FRONT OF TAPE
	ON.NOERROR THEN GOTO CNTVFY
	$CALL $RWNDU  <,#INLUN,,,R4>
	LET B.STAT(R4) := #0
	ERRP ER.BOT
	GOTO REPETE
CNTVFY:	LET R0 := $INDEV
	ALUN$S #INLUN,(R0),2(R0)	;RE-ASGN LUN TO I.P.
	LET R0 := #$HOLD
	LET $VBN := (R0)+
	LET $VBN+2 := (R0)+
	LET $FID := (R0)+
	LET $FID+2 := (R0)+
	LET $RVN := (R0)+
	LET $TFID := (R0)+
	LET $IHVBN := (R0)+
	LET $IHVBN+2 := (R0)+
	LET $FISIZ := (R0)+
	LET $FISIZ+2 := (R0)+
	LET $WVBN := $VBN
	LET $WVBN+2 := $VBN+2
	LET $OHVBN := $THVBN
	LET $OHVBN+2 := $THVBN+2
	LET $TFSIZ := $FISIZ		;RESTORE TFSIZ
	LET $TFSIZ+2 := $FISIZ+2
	LET $TVBN := $VBN
	LET $TVBN+2 := $VBN+2
	LET $IHBF+H.VBN := $IIVBN
	LET $IHBF+H.VBN+2 := $IIVBN+2
	LET $OHBF+H.VBN := $OIVBN
	LET $OHBF+H.VBN+2 := $OIVBN+2
	LET $TESQN := $XESQN
	IF #KY.NIP SET.IN $FLAG1 AND #KY.DSK SET.IN $IFLAG
	; IF TAPE O.P. AND DISK I.P.

		LET $IHHD+B.STAT := #0	;RELEASE HEADER BUFFER
		LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP  ;TURN OFF O.P.
		$CALL $RDHDR  <,,#0,$TFID>  ;RESTORE I.P. DISK HDR.
	ELSE
		IF #KY.NIP OFF.IN $FLAG1 AND #KY.DSK SET.IN $OFLAG
	; IF TAPE I.P. AND DISK O.P.

   		   LET $OHHD+B.STAT := #0	;RELEASE HEADER BUFFER
		   $CALL $RDHDO  <,,#0,$TFID> ;RESTORE O.P. DISK HDR.
		END
	END
		LET $FLAG1 := $FLAG1 OFF.BY #KY.NIP   ;TURN OFF O.P.
	; ABOVE RESTORES ORIGINAL DISK FILE HDR FOR VFY

	LET SP := $STAK		;CLEAN OUT THE STACK
	LET $B1HD+B.STAT := #0	;RELEASE BUFFERS
	LET $B2HD+B.STAT := #0
	LET $IWAIT := #0
	JUMPTO COMP1		;RESUME VERIFY


;+
;
; *** - CKLAB	CHECK CONTINUATION TAPE LABEL
;
; THIS ROUTINE VERIFIES THAT THE GIVEN FILE LABEL IS THE EXPECTED
; ONE.
;
; INPUTS:
;
;	CC - C	RESULT OF LABEL READ CALL
;	R0 = ADDRESS OF EXPECTED LABEL
;	R1 = BYTE COUNT READ
;	R5 = ADDRESS OF LABEL READ
;
; OUTPUTS:
;
;	CC - C	CLEAR IF OK
;		SET IF WRONG (MESSAGE PRINTED)
;	R1,R2,R3 CLOBBERED, OTHER REGISTERS PRESERVED
;
;-

CKLAB:	
	ON.ERROR			; IF ERROR READING LABEL
	  ERRP ER.ILB			; REPORT IT
	ELSE
	  IF R1 NE #80.			; CHECK BYTE COUNT READ
	    ERRP ER.IFM			; NOT ANSI IF WRONG
	  ELSE
	    BEGIN CHECK
	      LET R2 := R0		; COPY POINTERS, LEAVING
	      LET R3 := R5		; ORIGINALS FOR ERROR PRINTER
	      THRU R1 := #40.		; COMPARE LABELS
		IF (R2)+ NE (R3)+ LEAVE CHECK
	      END LOOP
	      RETURN NOERROR		; LABEL IS OK
	    END CHECK
	    ERRP ER.WRV			; REPORT WRONG VOLUME
	  END
	END
	RETURN				; (C IS SET)

;+
;
; *** - $SWITO	SWITCH TO NEXT OUTPUT TAPE
;
; THIS ROUTINE WRITES A VOLUME TRAILER LABEL SET ON THE CURRENT OUTPUT
; TAPE AND REWINDS IT AND SETS IT OFF-LINE. IT THEN FINDS THE NEXT
; AVAILABLE TAPE UNIT IN THE OUTPUT VOLUME TABLE, READIES IT FOR
; OUTPUT, AND WRITES A NEW VOLUME HEADER LABEL SET.
;
; INPUTS:
;
;	OUTPUT LUN ASSIGNED TO TAPE UNIT
;	$OUDEV POINTING AT CURRENT ENTRY IN TABLE
;	VOLUME LABEL IN $OVBF
;	FILE LABELS IN $OF1BF AND $OF2BF
;
; OUTPUTS:
;
;	OUTPUT UNIT ASSIGNED TO NEW TAPE UNIT
;	$OUDEV POINTING AT NEW DEVICE TABLE ENTRY
;	UPDATED VOLUME LABEL IN $OVBF
;	UPDATED FILE LABELS IN $OF1BF AND $OF2BF
;	OLD TAPE COMPLETED AND REWINDING
;	NEW TAPE LABELED
;	ALL REGISTERS PRESERVED
;
;-

$SWITO::
	$CALL $SAVAL			; SAVE ALL REGISTERS
	$CALL $TFINO <#1>		; FINISH THIS REEL
$SWCHO:
	LET $OFLAG := $OFLAG OFF.BY #KY.EOT ; CLEAR EOT CONDITION
;
; NOW FIND, READY, AND INITIALIZE THE NEXT OUTPUT TAPE
;
	LET $RELNO := $RELNO + #1	; BUMP TO NEXT REEL NUMBER O.P.
	LET $OUDEV := $OUDEV + #V.SIZ	; BUMP TO NEXT OUTPUT DEVICE
	LET R0 := $OUDEV - #$OVTAB	; SEE IF WE WERE USING THE LAST
	$CALL $DIV <R0,#V.SIZ>		; ENTRY IN THE DEVICE TABLE
	IF R0 HIS $OVNUM
	  LET $OUDEV := #$OVTAB		; YES - WRAP TO THE FIRST
	END
	LET R0 := $OUDEV
	ALUN$S #OUTLUN,(R0),2(R0)	; ASSIGN THE LUN TO IT
	REPEAT
	  $CALL $OTRDY			; AND WAIT UNTIL IT IS READY
	  IF R0 EQ #0 LEAVE LOOP	; TAPE MUST BE AT BOT
	  $CALL $RWNDU  <,#OUTLUN,,,R4>
	  ERRP ER.OBO			; AND OUTPUT MESSAGE
	END LOOP			; AND WAIT FOR HIM TO FIX IT
	IF #KY.160 SET.IN $OFLAG	; NOW SET THE CORRECT DENSITY
	  $CALL $STO16			; 1600 BPI
	ELSE
	  $CALL $STO08			; OR 800 BPI
	END
;
; PREPARE AND WRITE THE NEW VOLUME HEADER LABEL
;
	LET R0 := #$OVBF+9.		; POINT TO END OF VOLUME NAME
	INCB (R0)			; BUMP SEQUENCE NUMBER IN NAME
	IFB (R0) HIS #'9
	  LET (R0) :B= #'0		; HANDLE THE CARRY
	  INCB -(R0)
	END
	LET $OVBF+10. :B= #40		; CLEAR MIXED DENSITY FLAG
	$CALL $WRITE <,#80.,,,#$OVHD>	; WRITE THE VOLUME HEADER LABEL
	$CALL $WBOOT			; WRITE A BOOT ON THE TAPE
;
; NOW PREPARE AND WRITE THE NEW FILE HEADER LABELS
;
	LET $OF1BF := #"HD		; TURN BACK INTO "HDR1"
	LET $OF1BF+2 := #"R1
	LET R0 := #$OF1BF+31.		; POINT TO FILE SECTION NUMBER
	THRU R1 := #4			; INCREMENT BY 1 (IN ASCII)
	  INCB -(R0)			; BUMP DIGIT
	  IFB (R0) LOS #'9 LEAVE LOOP
	  LET (R0) :B= #'0		; WRAP TO 0 ON CARRY
	END LOOP
	LET R0 := #$OF1BF+54.		; POINT TO BLOCK COUNT
	THRU R1 := #6
	  LET (R0)+ :B= #'0		; INIT FIELD TO 0
	END LOOP
	$CALL $WRITE <,#80.,,,#$OF1HD>	; WRITE HDR1

	LET $OF2BF := #"HD		; TURN 2ND LABEL BACK INTO "HDR2"
	LET $OF2BF+2 := #"R2
	$CALL $WRITE <,#80.,,,#$OF2HD>	; AND WRITE IT

	$CALL $WEOF <,,,,#$OF3HD>	; WRITE THE TAPE MARK
	$CALL $WAITO <,,,,R4>	;WAIT FOR ALL OF THE ABOVE
	ON.ERROR
	   LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
	   ERROR ER.IOR		; SEND ERROR MESSAGE
	END
	RETURN				; DONE AND GOOD LUCK



	.END
