	$BEGIN	DWTDA,0007,<WRITE DATA TO DISK FILE>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  19-AUG-76  19:10
;
; GR001--- G.RITTENBURG FEB.20,1978
; CORRECTION FOR NON-MERGE MODE COPY,INHIBIT TRY TO EXTEND FILE.
;

;+
;
; *** - $DWTDA	WRITE DATA TO DISK FILE
;
; THIS ROUTINE WRITES THE INDICATED DATA BLOCKS TO THE OUTPUT DISK
; FILE FROM THE INDICATED DATA BUFFER. VIRTUAL BLOCKS ARE MAPPED
; TO LOGICAL BLOCKS USING THE OUTPUT FILE HEADER AND LOGICAL TRANSFERS
; ARE INITIATED AS NECESSARY. IF THE BUFFER'S BYTE COUNT IS ZERO, NO
; TRANSFER IS MADE.
;
; INPUTS:
;
;	R4 = INPUT BUFFER DESCRIPTOR
;
; OUTPUTS:
;
;	CC - C	CLEAR IF ALL OK
;		SET IF TRANSFER NOT ALL MAPPED
;	R4 = BUFFER DESCRIPTOR ADDRESS
;	TRANSFER FROM BUFFER INITIATED
;	OTHER REGISTERS CLOBBERED
;
;-

$DWTDA::
	LET R0 := R4
	THRU R1 := #B.SIZ*3/2		; CLEAN OUT SPARE BCB'S
	  LET -(R0) := #0
	END LOOP
	LET B.STAT(R4) := #0		; RELEASE BUFFER AFTER WRITE
	LET $WVBN := B.SIZ+P.VBN(R4)	; GET START VBN OF TRANSFER
	LET $WVBN+2 := B.SIZ+P.VBN+2(R4)
	LET R0 := B.SIZ+P.CNT(R4) + #511. ; GET BYTE COUNT, ROUNDED UP
	CLRB R0				; CONVERT TO BLOCK COUNT
	SWAB R0
	ASR R0
	PUSH R0				; SAVE BLOCK COUNT
	IF RESULT IS EQ GOTO EXIT	; NO TRANSFER IF ZERO
	PUSH R4,R4			; SAVE DESCRIPTOR ADDRESS
	LET (SP) := (SP) + #B.SIZ+P.SIZ	; BUILD START ADDRESS
	REPEAT
MAP:	  LET R5 := #$OHBF		; MAP USING OUTPUT FILE HEADER
	  LET R3 := $WVBN - H.VBN(R5)	; GET CURRENT VBN, ADJUSTED
	  LET R2 := $WVBN+2 - CARRY - H.VBN+2(R5) ; BY BASE VBN
	  $CALL $MPVBN <,,R2,R3,,R5>	; MAP TO LOGICAL
	  ON.ERROR
	   IF #KY.MRG SET.IN $OFLAG	; IF MERGE MODE
	    $CALL $FILSZ <,,,,R5>	; COMPUTE SIZE OF THIS HEADER
	    LET H.VBN(R5) := H.VBN(R5) + R1 ; UPDATE START VBN
	    LET H.VBN+2(R5) := H.VBN+2(R5) + CARRY + R0
	    LET R4 := #$OHHD		; GET HEADER BUFFER HEADER
	    LET B.STAT(R4) := #0	; RELEASE THE BUFFER
	    $CALL $RDNXO <,,,,R4,R5>	; TRY TO READ EXTENSION HEADER
	   ELSE
	    SEC		; NO EXT. COPYING IN NON MERGE MODE
	   END
	    ON.NOERROR GOTO MAP		; PROCEED
	    TST (SP)+			; DISCARD BUFFER POINTER
	    POP R4			; GET ORIGINAL BCB
	    LET B.IOST(R4) := #1	; FAKE A SUCCESSFUL COMPLETION
	    LET B.STAT(R4) := #2	; WRITE IN PROGRESS
	    $CALL $LINKO <,,,,R4>	; LINK ONTO WAIT LIST
	    TST (SP)+			; CLEAN THE STACK
	    ERRP ER.MPO			; PRINT MESSAGE
	    RETURN
	  END
	  IF R0 NE #0 OR R1 HI 4(SP)	; IF MORE BLOCKS MAPPED
	    LET R0 := #0		; THAN DESIRED,
	    LET R1 := 4(SP)		; REDUCE TO DESIRED NUMBER
	  END
	  LET $WVBN := $WVBN + R1	; BUMP VBN TO NEXT SEGMENT
	  LET $WVBN+2 := $WVBN+2 + CARRY
	  LET 4(SP) := 4(SP) - R1	; DECREMENT BLOCK COUNT
	  $CALL $MUL <#512.,R1>		; COMPUTE BYTE COUNT
	  POP R5			; GET CURRENT BUFFER ADDR
	  LET R0 := (SP)		; GET MAIN BCB
	  IF 2(SP) NE #0		; IF TRANSFER IS NOT COMPLETE
	    LET R4 := R4 - #B.SIZ	; BACK UP TO ANOTHER BCB
	    $CALL $WRITA <,R1,R2,R3,R4,R5> ; START THE WRITE
	    LET R5 := R5 + R1		; UPDATE BUFFER ADDRESS
	    PUSH R5			; AND SAVE FOR NEXT WRITE
	  ELSE				; IF THIS IS THE LAST
	    $CALL $WRITA <,R1,R2,R3,(SP)+,R5> ; WRITE WITH MAIN BCB
	    LEAVE LOOP
	  END
	END LOOP
EXIT:	TST (SP)+			; CLEAN THE STACK
	RETURN



	.END
