	$BEGIN	DSCIO,0027,<BASIC I/O FUNCTIONS FOR DSC>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  1-NOV-76  11:14
; GEORGE RITTENBURG APR-14-77 MODIFIED FOR VFY/CMP FOR DISK TO/FROM TAPE
;
; ANDREW C. GOLDSTEIN - 18-MAR-1980  16:26
; ACG0159 - FIX TAPE BLOCK COUNTING CONDITIONAL
;
; ANDREW C. GOLDSTEIN  20-FEB-1980
; ACG0140 - REMOVE BUFFER BUSY BUG CHECK
;
; ACG0014 - ANDREW C. GOLDSTEIN  9-MAR-1979
; FIX TAPE VERIFY CONTEXT SWITCH BUG


	.MCALL	QIOW$S,QIO$S,WTSE$S,CLEF$S

	.SBTTL	READ A BLOCK SYNCHRONOUSLY

;+
;
; *** - $RDW1B	READ 1 512 BYTE BLOCK AND WAIT FOR COMPLETION
;
; THIS ROUTINE READS A 512 BYTE BLOCK FROM THE INPUT DEVICE AND RETURNS
; WHEN THE TRANSFER HAS COMPLETED.
;
; INPUTS:
;
;	R2, R3 = HIGH AND LOW LBN
;	R4 =	BUFFER CONTROL BLOCK ADDRESS
;
; OUTPUTS:
;
;	I/O STATUS IN BUFFER CONTROL BLOCK
;	R1 =	BYTE COUNT TRANSFERRED
;	R5 =	BUFFER ADDRESS
;	CC - C	CLEAR IF NO ERRORS
;		SET IF ERROR
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;
; *** - $RDWAT	READ A BLOCK AND WAIT FOR COMPLETION
;
; THIS ALTERNATE ENTRY POINT ALLOWS A BLOCK OF ARBITRARY SIZE TO BE
; READ. INPUTS AND OUTPUTS ARE THE SAME AS FOR $RDW1B PLUS:
;
; INPUTS:
;
;	R1 = BYTE COUNT TO READ
;
;
; *** - $RDWTA	READ AND WAIT WITH ALTERNATE BUFFER
;
; THIS ROUTINE READS A BLOCK OF THE INDICATED SIZE INTO THE INDICATED
; BUFFER. INPUTS AND OUTPUTS ARE THE SAME AS FOR $RDWAT PLUS:
;
; INPUTS:
;
;	R5 = BUFFER ADDRESS
;
;
; *** - $RDWLN	READ A BLOCK FROM THE SPECIFIED LUN
;
; THIS ROUTINE READS A 512 BYTE BLOCK FROM THE DEVICE ASSIGNED TO THE
; SPECIFIED LUN INTO THE SPECIFIED BUFFER. INPUTS AND OUTPUTS
; ARE THE SAME AS FOR $RDW1B PLUS:
;
; INPUTS:
;
;	R0 = LUN
;
;-

$RDWLN::
	PUSH R0				; SAVE LUN
	LET R1 := #512.			; SET BYTE COUNT
	LET R5 := R4 + #B.SIZ		; USE BUFFER FOLLOWING BCB
	GOTO RDCOM

$RDW1B::
	LET R1 := #512.			; GET DEFAULT BYTE COUNT

$RDWAT::
	LET R5 := R4 + #B.SIZ		; DEFAULT BUFFER FOLLOWS BCB

$RDWTA::
	IF #KY.NIP SET.IN $FLAG1
	  IF #KY.TAP SET.IN $OFLAG AND R1 HI 80.
		GOTO RDCOMY
	  ELSE
		GOTO RDCOMX
	  END
	END
	IF #KY.TAP SET.IN $IFLAG AND R1 HI #80.
		GOTO RDCOMY
	END
RDCOMX:
	PUSH #INLUN			; DEFAULT TO INPUT LUN
RDCOM:	$CALL $BUFCK <,,,,R4>		; CHECK IF BUFFER AVAILABLE
	POP R0				; R0 = LUN
	QIOW$S	#IO.RLB,R0,#EFN,,R4,,<R5,R1,,R2,R3>
	LET B.STAT(R4) := #1		; MARK DATA IN BUFFER
	ON.ERROR THEN LET (R4) := @#$DSW ; RETURN DIRECTIVE ERROR
	REPEAT				; MAKE SURE TRANSFER IS REALLY COMPLETE
	  IFB (R4) NE #0 LEAVE LOOP
	  WTSE$S #EFN			; ELSE WAS ANOTHER COMPLETION
	  CLEF$S #EFN			; SO TRY AGAIN
	END LOOP
	IFB (R4) EQ #IE.EOT THEN LET (R4) := #1 ; IGNORE EOT ON INPUT
	LET R1 := 2(R4)			; RETURN BYTE COUNT TRANSFERRED
	RETURN (R4)			; RETURN I/O STATUS
RDCOMY:
	$CALL $READA
	$CALL  $WAITI
	LET R1 := 2(R4)
	RETURN

	.SBTTL	READ A BLOCK ASYNCHRONOUSLY

;+
;
; *** - $READ	READ A BLOCK FROM THE INPUT DEVICE
;
; THIS ROUTINE INITIATES A READ OPERATION FROM THE INPUT DEVICE.
;
; INPUTS:
;
;	R1 = BYTE COUNT
;	R2, R3 = HIGH AND LOW LBN
;	R4 = BUFFER CONTROL BLOCK
;
; OUTPUTS:
;
;	R5 = BUFFER ADDRESS
;	CC - C	CLEAR IF NO ERRORS
;		SET IF DIRECTIVE ERROR
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;
; *** - $READA	READ A BLOCK WITH ALTERNATE I/O BUFFER
;
; THIS ROUTINE INITIATES A READ OPERATION WITH AN ALTERNATE I/O BUFFER.
; INPUTS AND OUTPUTS ARE THE SAME AS FOR $READ PLUS:
;
; INPUTS:
;
;	R5 = BUFFER ADDRESS
;
;
; *** - $LINKI	LINK BUFFER CONTROL BLOCK
;
; THIS ENTRY POINT LINKS THE INDICATED BUFFER CONTROL BLOCK ONTO
; THE INPUT WAIT LIST.
;
; INPUTS:
;
;	R4 = BCB ADDRESS
;
; OUTPUTS:
;
;	BUFFER LINKED UP
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;-

$READ::
	LET R5 := R4 + #B.SIZ		; DEFAULT BUFFER ADDRESS

$READA::
	$CALL $BUFCK <,,,,R4>		; CHECK THAT BUFFER IS AVAILABLE
	QIO$S	#IO.RLB,#INLUN,#EFN,,R4,,<R5,R1,,R2,R3>
	ON.ERROR
	  LET (R4) := @#$DSW
	ELSE
	  LET B.STAT(R4) := #3		; MARK READ IN PROGRESS
$LINKI::
	  LET R0 := #$IWAIT-B.LINK	; GET HEAD OF WAIT LIST
	  WHILE B.LINK(R0) NE #0
	    LET R0 := B.LINK(R0)	; SEARCH FOR LAST ENTRY
	  END LOOP
	  LET B.LINK(R0) := R4		; LINK BCB ONTO CHAIN
	  LET B.LINK(R4) := #0
	END
	RETURN

	.SBTTL	READ A BLOCK ASYNCHRONOUSLY FROM OUTPUT

;+
;
; *** - $READO	READ A BLOCK FROM THE OUTPUT DEVICE
;
; THIS ROUTINE INITIATES A READ OPERATION FROM THE INPUT DEVICE.
;
; INPUTS:
;
;	R1 = BYTE COUNT
;	R2, R3 = HIGH AND LOW LBN
;	R4 = BUFFER CONTROL BLOCK
;	R5 = BUFFER ADDRESS
;
; OUTPUTS:
;
;	CC - C	CLEAR IF NO ERRORS
;		SET IF DIRECTIVE ERROR
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;-

$READO::
	$CALL $BUFCK <,,,,R4>		; CHECK THAT BUFFER IS AVAILABLE
	QIO$S	#IO.RLB,#OUTLUN,#EFN,,R4,,<R5,R1,,R2,R3>
	ON.ERROR
	  LET (R4) := @#$DSW
	ELSE
	  LET B.STAT(R4) := #3		; MARK READ IN PROGRESS
	  GOTO $LINKO			; LINK ONTO OUTPUT WAIT LIST
	END
	RETURN

	.SBTTL	WRITE A BLOCK TO THE OUTPUT DEVICE

;+
;
; *** - $WRI1B	WRITE 1 BLOCK TO THE OUTPUT DEVICE
;
; THIS ROUTINE INITIATES A 1 BLOCK WRITE.
;
; INPUTS:
;
;	R2, R3 = HIGH AND LOW LBN
;	R4 = BUFFER CONTROL BLOCK
;
; OUTPUTS:
;
;	R1 = BYTE COUNT (512)
;	R5 = BUFFER ADDRESS
;	CC - C	CLEAR IF NO ERRORS
;		SET IF DIRECTIVE ERROR
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;
; *** - $WRITE	WRITE A BLOCK
;
; THIS ROUTINE INITIATES A WRITE OPERATION TO THE OUTPUT DEVICE.
; INPUTS AND OUTPUTS ARE AS ABOVE, PLUS:
;
; INPUTS:
;
;	R1 = BYTE COUNT
;
;
; *** - $WRITA	WRITE ALTERNATE BUFFER
;
; THIS ROUTINE INITIATES A WRITE OPERATION USING THE ALTERNATE
; BUFFER ADDRESS SPECIFIED. INPUTS AND OUTPUTS ARE AS ABOVE, PLUS:
;
; INPUTS:
;
;	R5 = BUFFER ADDRESS
;
;
; *** - $WEOF	WRITE END OF FILE MARK ON TAPE
;
; THIS ROUTINE WRITES AN END OF FILE MARK ON THE OUTPUT TAPE.
;
; INPUTS:
;
;	R4 = BUFFER CONTROL BLOCK
;
; OUTPUTS:
;
;	CC - C	CLEAR IF NO ERRORS
;		SET IF DIRECTIVE ERROR
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;
; *** - $LINKO	LINK BUFFER CONTROL BLOCK
;
; THIS ENTRY POINT LINKS THE INDICATED BUFFER CONTROL BLOCK ONTO
; THE OUTPUT WAIT LIST.
;
; INPUTS:
;
;	R4 = BCB ADDRESS
;
; OUTPUTS:
;
;	BUFFER LINKED UP
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;-

$WEOF::	
	QIO$S	#IO.EOF,#OUTLUN,#EFN,,R4
	GOTO LINKB

$WRI1B::
	LET R1 := #512.			; DEFAULT BYTE COUNT

$WRITE::
	LET R5 := R4 + #B.SIZ		; DEFAULT BUFFER ADDRESS

$WRITA::
;
; IF OUTPUT IS MAGTAPE, COUNT THE BLOCK. IF IT IS AT END OF TAPE,
; DO A REEL SWITCH BEFORE WRITING THE BLOCK, UNLESS THIS IS A LABEL.
; NOTE THAT WE ONLY ALLOW REEL SWITCHING IN FRONT OF A DATA WRITE, SINCE
; THE VERIFY CONTEXT SWITCHING CODE DOES NOT WORK FOR THE OTHER CASES.
;
	IF #KY.TAP SET.IN $OFLAG
	  IF (SP) EQ #$TWDWT
	    IF #KY.EOT SET.IN $OFLAG AND R1 GT #80. THEN $CALL $SWITO
	  END
	  LET $BLCNT := $BLCNT + #1	; BUMP BLOCK COUNT
	END
	QIO$S	#IO.WLB,#OUTLUN,#EFN,,R4,,<R5,R1,,R2,R3>
LINKB:	ON.ERROR
	  LET (R4) := @#$DSW
	ELSE
	  LET B.STAT(R4) := B.STAT(R4) + #2 ; MARK TRANSFER IN PROGRESS
$LINKO::  
	  LET R0 := #$OWAIT-B.LINK	; GET HEAD OF WAIT LIST
	  WHILE B.LINK(R0) NE #0
	    LET R0 := B.LINK(R0)	; SEARCH FOR LAST ENTRY
	  END LOOP
	  LET B.LINK(R0) := R4		; LINK BCB ONTO CHAIN
	  LET B.LINK(R4) := #0
	END
	RETURN

	.SBTTL	BUFFER CHECK ROUTINE

;+
;
; *** - $BUFCK	CHECK IF BUFFER IS AVAILABLE
;
; THIS ROUTINE MAKES SURE THAT A PARTICULAR BUFFER IS AVAILABLE
; TO BE READ INTO. IF A WRITE IS IN PROGRESS, IT WAITS FOR COMPLETION.
;
; INPUTS:
;
;	R4 = BUFFER CONTROL BLOCK ADDRESS
;
; OUTPUTS:
;
;	R0 CLOBBERED, OTHER REGISTERS PRESERVED
;
;-

$BUFCK::
	IF B.STAT(R4) HIS #2		; CHECK THE BUFFER STATUS
	  $CALL $WAITO <,,,,R4>		; IF BUSY, WAIT IT OUT
	  ON.ERROR
	    LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
	    ERROR ER.IOR		;SEND ERROR MESSAGE
	  END
	END
	RETURN

	.SBTTL	WAIT ROUTINES

;+
;
; *** - $WAITI	WAIT FOR INPUT
;
; THIS ROUTINE WAITS FOR COMPLETION ON THE INDICATED BUFFER CONTROL
; BLOCK. IT ALSO CHECKS COMPLETION ON ALL READS PRECEDING AND RETURNS
; ANY ERRORS.
;
; INPUTS:
;
;	R4 = BUFFER CONTROL BLOCK TO WAIT ON
;
; OUTPUTS:
;
;	CC - C	CLEAR IF NO ERRORS
;		SET IF ANY I/O ERROR OCCURRED
;	R0 = LAST BCB WAITED ON (THE ONE WITH ERROR, IF ANY)
;	OTHER REGISTERS PRESERVED
;
; *** - $WAITO	WAIT FOR OUTPUT
;
; THIS ROUTINE WAITS FOR COMPLETION ON THE SPECIFIED OUTPUT TRANSFER.
; INPUTS AND OUTPUTS ARE THE SAME AS ABOVE.
;
;-

$WAITI::
	LET R0 := #$IWAIT		; INPUT WAIT LIST
	GOTO WCOM

$WAITO::
	LET R0 := #$OWAIT		; OUTPUT WAIT LIST

WCOM:	PUSH R5				; SAVE R5
	PUSH R0				; SAVE LIST HEAD
	LET R0 := (R0)			; POINT TO FIRST BCB
	REPEAT
	  REPEAT
	    IFB (R0) NE #0 LEAVE LOOP
	    WTSE$S #EFN
	    CLEF$S #EFN
	  END LOOP
	  LET B.STAT(R0) := B.STAT(R0) - #2 ; MARK TRANSFER COMPLETED
	  LET @(SP) := B.LINK(R0)	; UNLINK COMPLETED BCB
RETRY:	  IFB (R0) LT #0
	    IFB (R0) EQ #IE.EOT		; CHECK FOR END OF TAPE CONDITION
	      LET (R0) :B= #1		; IGNORE IT, BUT FLAG FOR OUTPUT TAPE
	      IF (SP) EQ #$OWAIT AND #KY.TAP SET.IN $OFLAG
		LET $OFLAG := $OFLAG SET.BY #KY.EOT
	      END
	    ELSE
		IF #KY.NIP SET.IN $FLAG1
		   LET R5 := $OFLAG
		ELSE
		   LET R5 := $IFLAG
		END
	      IFB (R0) EQ #IE.EOF AND (SP) EQ #$IWAIT AND #KY.TAP SET.IN R5
		IF #KY.EOT SET.IN $IFLAG LEAVE LOOP ; DON'T RECURSE REEL SWITCH
		LET $IFLAG := $IFLAG SET.BY #KY.EOT
		$CALL $SWITI		; SWITCH REELS ON EOF
		IFB (R0) LT #0 LEAVE LOOP ; OUT IF ERROR
	      ELSE
		LEAVE LOOP
	      END
	    END
	  END
	  IF R0 EQ R4 LEAVE LOOP
	  LET R0 := B.LINK(R0)		; LINK TO NEXT BCB
	  IF RESULT IS EQ
	    FATAL <BCB NOT IN LIST>
	  END
	END LOOP
	TST (SP)+			; CLEAN THE STACK
	POP R5				; RESTORE R5
	RETURN (R0)

	.SBTTL	WAIT ON DISK READ AND CHECK FOR ERRORS

;+
;
; *** - $DWCK	WAIT AND CHECK FOR ERRORS
;
; THIS ROUTINE WAITS FOR A DISK READ OPERATION TO COMPLETE ON AN I/O
; BUFFER AND CHECKS FOR I/O ERRORS. IF AN ERROR OCCURRS, A MESSAGE
; IS PRINTED.
;
; INPUTS:
;
;	R4 = FINAL BUFFER CONTROL BLOCK TO WAIT FOR
;	     (MUST BE ADDRESS OF PRIMARY BCB OF DATA BUFFER)
;
; OUTPUTS:
;
;	CC - C	CLEAR IF DATA TRANSFERRED
;		SET IF THIS WAS A DUMMY TRANSFER
;	R4 PRESERVED
;	ALL OTHER REGISTERS CLOBBERED
;
;-

$DWCK::
	REPEAT				; LOOP FOR ALL ERRORS
	  $CALL $WAITI <,,,,R4>		; WAIT ON BUFFER
	  ON.ERROR
	    ERRP ER.RDA			; PRINT MESSAGE ON ERROR
	    LET B.SIZ+P.FLAGS(R4) := B.SIZ+P.FLAGS(R4) SET.BY #PF.ERR
	  END
	  IF R0 EQ R4 LEAVE LOOP
	END LOOP
	RETURN NOERROR

	.SBTTL	WAIT ON DISK OUTPUT READ AND CHECK FOR ERRORS

;+
;
; *** - $DWCKO	WAIT AND CHECK FOR ERRORS
;
; THIS ROUTINE WAITS FOR A DISK READ OPERATION TO COMPLETE ON AN I/O
; BUFFER AND CHECKS FOR I/O ERRORS. IF AN ERROR OCCURRS, A MESSAGE
; IS PRINTED.
;
; INPUTS:
;
;	R4 = FINAL BUFFER CONTROL BLOCK TO WAIT FOR
;	     (MUST BE ADDRESS OF PRIMARY BCB OF DATA BUFFER)
;
; OUTPUTS:
;
;	CC - C	CLEAR IF DATA TRANSFERRED
;		SET IF THIS WAS A DUMMY TRANSFER
;	R4 PRESERVED
;	ALL OTHER REGISTERS CLOBBERED
;
;-

$DWCKO::
	REPEAT				; LOOP FOR ALL ERRORS
	  $CALL $WAITO <,,,,R4>		; WAIT ON BUFFER
	  ON.ERROR
	    LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
	    ERRP ER.RDO			; PRINT MESSAGE ON ERROR
	    LET B.SIZ+P.FLAGS(R4) := B.SIZ+P.FLAGS(R4) SET.BY #PF.ERR
	  END
	  IF R0 EQ R4 LEAVE LOOP
	END LOOP
	RETURN NOERROR

	.SBTTL	WAIT ON TAPE READ AND CHECK FOR ERRORS

;+
;
; *** - $TWCK	WAIT AND CHECK FOR ERRORS
;
; THIS ROUTINE WAITS FOR A TAPE READ OPERATION TO COMPLETE ON AN I/O
; BUFFER AND CHECKS FOR I/O ERRORS. IF AN ERROR OCCURRS, A MESSAGE
; IS PRINTED.
;
; INPUTS:
;
;	R4 = FINAL BUFFER CONTROL BLOCK TO WAIT FOR
;	     (MUST BE ADDRESS OF PRIMARY BCB OF DATA BUFFER)
;
; OUTPUTS:
;
;	CC - C	CLEAR IF DATA TRANSFERRED
;		SET IF THIS WAS A DUMMY TRANSFER
;	R4 PRESERVED
;	ALL OTHER REGISTERS CLOBBERED
;
;-

$TWCKO:	:
$TWCK::
	REPEAT				; LOOP FOR ALL ERRORS
	  $CALL $WAITI <,,,,R4>		; WAIT ON BUFFER
	  ON.ERROR
	    IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
	        ERROR ER.RDA
	    ELSE
		    ERRP ER.RDA			; PRINT MESSAGE ON ERROR
	    END
	    IFB (R4) EQ #IE.EOF
		IF #KY.NIP OFF.IN $FLAG1
			RETURN ERROR
		ELSE
			ERRP ER.IOR
			RETURN
		END
	    END
	  END
	  IF R0 EQ R4 LEAVE LOOP
	END LOOP
	LET R5 := R4 + #B.SIZ		; POINT TO BUFFER
	IF P.CNT(R5) EQ #0 THEN RETURN NOERROR
	LET R0 := P.FLAG(R5) OFF.BY #PF.ERR
	IF R0 NE #PF.DAT
	  IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
		ERROR  ER.NDA
	ELSE
		  ERRP ER.NDA
	  END
	ELSE
	  IF P.FID(R5) NE $FID OR P.FID+2(R5) NE $FID+2 OR P.FID+4(R5) NE $FID+4
	    IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
		ERROR ER.FID
	    ELSE
		    ERRP ER.FID
	    END
	  ELSE
	    IF P.VBN(R5) NE $TVBN OR P.VBN+2(R5) NE $TVBN+2
	      IF #KY.VFY SET.IN $FLAG1 OR #KY.CMP SET.IN $OFLAG
		ERROR ER.VBN
	      ELSE
		      ERRP ER.VBN
	      END
	    ELSE
	      LET R1 := P.CNT(R5) + #511. ; GET BYTE COUNT
	      CLRB R1
	      SWAB R1
	      ASR R1			; CONVERT TO BLOCK COUNT
	      LET $TVBN := $TVBN + R1	; UPDATE VBN
	      LET $TVBN+2 := $TVBN+2 + CARRY
	      LET $VBN := $TVBN		; CORRECT RUNNING VBN
	      LET $VBN+2 := $TVBN+2	; FOR TRUNCATION
	      IF #PF.ERR SET.IN P.FLAG(R5) THEN ERRP ER.BDA
	      RETURN NOERROR
	    END
	  END
	END
	RETURN

	.SBTTL	QIO CHECK ROUTINE

;+
;
; *** - $INCK	CHECK SUCCESSFUL COMPLETION OF INPUT QIOW
;
; *** - $OUTCK	CHECK SUCCESSFUL COMPLETION OF OUTPUT QIOW
;
; THESE ROUTINES TEST FOR SUCCESSFUL COMPLETION OF A QIO AND WAIT
; OPERATION. IF EITHER A DIRECTIVE ERROR OR AN I/O ERROR OCCURRED,
; THEY TAKE AN ERROR EXIT.
;
; INPUTS:
;
;	R4 = ADDRESS OF I/O STATUS BLOCK
;	CC - C	SET OR CLEARED BY PRECEDING DIRECTIVE
;	DIRECTIVE STATUS IN $DSW
;
; OUTPUTS:
;
;	ALL REGISTERS PRESERVED
;
;-

$INCK::
	ON.ERROR THEN ERROR ER.DIR	; CHECK FOR DIRECTIVE ERROR
	REPEAT
	  IFB (R4) NE #0 LEAVE LOOP	; WAIT FOR REAL COMPLETION
	  WTSE$S #EFN			; TRY AGAIN
	  CLEF$S #EFN
	END LOOP
	IFB (R4) EQ #IE.EOT THEN LET (R4) := #1 ; IGNORE EOT
	IFB (R4) LT #0 THEN ERROR ER.IIR ; CHECK FOR I/O ERROR
	RETURN				; RETURN IF ALL OK

$OUTCK::
	ON.ERROR THEN ERROR ER.DIR	; CHECK FOR DIRECTIVE ERROR
	REPEAT
	  IFB (R4) NE #0 LEAVE LOOP	; WAIT FOR REAL COMPLETION
	  WTSE$S #EFN			; TRY AGAIN
	  CLEF$S #EFN
	END LOOP
	IFB (R4) LT #0	; CHECK FOR I/O ERROR
	   LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
	   ERROR ER.IOR		; SEND ERROR MESSAGE
	END
	RETURN				; RETURN IF ALL OK


	; THE FOLLOWING SUB-ROUTINE IS CALLED TO SPACE BLOCKS ON TAPE
	;INPUTS
	;R1= LUN NO.
	; R4 = ADDRESS OF STATUS BLOCK
	; R5 = NO. BLOCKS TO SPACE- + = FWD. -- MINUS = BACK

$SPACB:: QIOW$S #IO.SPB,R1,#EFN,,R4,,<R5>
	 RETURN



	;THE FOLLOWING ROUTINE IS CALLED TO SPACE OVER TAPE MARKS (EOF MARKS)
	;INPUTS
	; R1 = LUN NO.
	; R4 = ADDRESS OF STATUS BLOCK
	; R5 = NO. EOF'S T0 SPACE OVER-POS. = FWD;NEG = BACK
$SPACF:: QIOW$S #IO.SPF,R1,#EFN,,R4,,<R5>
	 RETURN

	;THE FOLLOWING ROUTINE IS CALLED TO REWIND A TAPE
	; INPUTS
	; R1 = LUN NO.  ;R4 = ADDRESS OF STATUS BLOCK
$RWND::  QIOW$S #IO.RWD,R1,#EFN,,R4
	  RETURN


	; THE FOLLOWING ROUTINE IS CALLED TO REWIND AND UNLOAD A TAPE
	; INPUTS SAME AS FOR $RWND

$RWNDU::	QIOW$S #IO.RWU,R1,#EFN,,R4
		RETURN


	.END
