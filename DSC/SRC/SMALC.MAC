	$BEGIN	SMALC,0004,<STORAGE MAP ALLOCATION>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  20-AUG-76  1:24
; PETER H. LIPMAN	25-FEB-74
;
; THIS ROUTINE IS CRIBBED ALMOST VERBATIM FROM THE STORAGE MAP
; ALLOCATOR IN F11ACP.
; "PLAGIARIZE! PLAGIARIZE! (BUT REMEMBER ALWAYS TO CALL IT, PLEASE,
; RESEARCH.)" - N. I. LOBACHEVSKY.
; CORRECTED 11-MAR-77 G.RITTENBURG  001 [SEELINE 60$ +1 ]

;+
;
; *** - .SMALC	STORAGE MAP ALLOCATION ROUTINE
; 
; THIS ROUTINE ALLOCATES THE SPECIFIED NUMBER OF BLOCKS TO THE FILE.
; IF A NONCONTIGUOUS ALLOCATION IS REQUESTED, THEN IT ALLOCATES
; THE FIRST CHUNK OF BLOCKS IT FINDS LESS THAN OR EQUAL TO THE DESIRED NUMBER
; OF BLOCKS.
;
; INPUTS:
; 
;	R0,R1 = NUMBER OF BLOCKS TO ALLOCATE
;	R4 = DEVICE TABLE ENTRY
;	.SMCTL = ALLOCATION CONTROL BYTE
; 
; OUTPUT:
; 
;	C = 0 IF SUCCESSFUL
;	C = 1 IF DEVICE FULL
;	R0,R1 = COUNT OF ALLOCATED BLOCKS
;	R2,R3 = LBN IF C = 0
;	R5 ALTERED, R4 PRESERVED
; 
; EFFECTS:
; 
;	.SMBUF MAY CONTAIN A DIFFERENT STORAGE MAP BLOCK
;
;-
.SMALC::
	CLR	.SM2BT		; ZERO BIGGEST CHUNK FOUND SO FAR
	CLR	.SM2BT+2
	MOV	R1,R2
	MOV	R0,R1
	MOV	V.CLF(R4),R0	; R0=STORAGE MAP CLUSTER FACTOR
	CALL	$DDIV		; FORM R1,R2=NO. OF BITS DESIRED
	TST	R0		; ROUND UP IF REMAINDER IS NOT ZERO
	BEQ	10$
	ADD	#1,R2
	ADC	R1
10$:	MOV	R1,.SM1BT	; SAVE DESIRED NO. OF BITS
	MOV	R2,.SM1BT+2
	MOV	#.SMBUF,R1	; START AT FIRST WORD
	MOV	#1,R0		; AND FIRST BIT
; 
; CALCULATE THE BLOCK COUNT TO SCAN, ALLOWING A SCAN FROM THE CURRENT
; VBN TO THE END, AND IF NECESSARY FROM VBN 1 TO THE END AGAIN.
; THIS ALLOWS THE CONTIGUOUS ALLOCATION FROM THE CURRENT VBN -1 TO THE
; END OF THE STORAGE BIT MAP IF THAT PROVES TO BE THE ONLY WAY TO
; ALLOCATE THE DESIRED CONTIGUOUS CHUNK.
; 
	MOV	.SMVBN,R3	; R3=CURRENT VIRTUAL BLOCK NO. IN MEMORY
	DEC	R3		; IF VBN 1 IS IN MEMORY
	BEQ	30$		; NEED ONLY TAKE ONE FULL SCAN
	NEG	R3		; OTHERWISE CALCULATE BLOCKS LEFT TO END
	ADD	V.SBSZ(R4),R3
30$:	ADD	V.SBSZ(R4),R3	; ADD THE STORAGE BIT MAP SIZE
	MOV	R3,.SMCNT	; STORE BLOCK COUNT THAT MAY BE SCANNED
; 
; R0=BIT MASK, R1=BIT WORD ADDRESS SEARCH FOR A FREE BIT
; FIRST SEARCH WORD BY WORD FOR SPEED
; 
40$:	TST	(R1)		; CHECK CURRENT WORD
	BNE	70$		; BRANCH IF ANY BITS ARE FREE
50$:	CMP	R1,#.SMBUF+512.-2 ; CHECK FOR END OF BUFFER
	BHIS	80$		; BRANCH IF YES
	TST	(R1)+		; ADVANCE TO NEXT WORD
	BR	40$		; AND LOOP
;
; ENTER HERE TO RESUME SCANNING AFTER CONTIGUOUS CHECK HAS FAILED
;
60$:	TST	.SMCNT		; ALREADY TESTED THE LAST BLOCK OF BITS?
	BLE	80$		; BRANCH IF YES
				;   001   ABOVE LINE WAS BLE 60$
;
; CHECK INDIVIDUAL BITS OF A WORD
;
70$:	BIT	R0,(R1)		; IF THIS BIT AVAILABLE
	BNE	90$		; BRANCH IF YES
	ASL	R0		; MOVE TO NEXT BIT
	BCC	70$		; AND TRY
	ROL	R0		; CHECKED ALL BITS IN WORD - WRAP TO
	BR	50$		; FIRST AND TRY NEXT WORD

80$:	MOV	#100000,R0	; END OF BUFFER - SET LAST BIT
	CALL	.SMNXB		; SET UP TO TEST NEXT BLOCK
	BCC	40$		; BRANCH IF MORE BITS TO TEST
	RETURN			; ALLOCATION FAILED - RETURN C SET
; 
; FOUND FIRST FREE BIT, SCAN FOR DESIRED SIZE CHUNK
; 
90$:	MOV	#.SM1BT,R5
	MOV	(R5)+,R2	; R2,R3=DESIRED BIT COUNT
	MOV	(R5)+,R3
	MOV	R0,(R5)+	; SAVE MASK WORD
	MOV	R1,(R5)+	; AND BIT WORD ADDRESS
	MOV	.SMVBN,(R5)	; AND CURRENT VBN IN CORE
	MOV	R3,-(SP)	; SAVE DESIRED COUNT (LOW BITS)
	MOV	R2,-(SP)	; AND HIGH BITS
; 
; SCAN FOR DESIRED NO. OF BITS FREE STARTING AT BIT IN R0, WORD IN R1
; 
; WRAP AROUND ALLOCATION IS PREVENTED BY THE FACT THAT LOGICAL BLOCK 0
; IS ALLOCATED IN A FILES 11 STRUCTURE AS THE 1ST VBN OF THE INDEX FILE
; 
	MOV	#.CKFRE,R5
	CALL	.SMSCN
	BCC	120$		; BRANCH IF FOUND SPACE
; 
; CALCULATE SIZE OF CONTIGUOUS CHUNK FOUND ON TOP OF STACK
; 
	SUB	R3,2(SP)
	SBC	(SP)
	SUB	R2,(SP)
	BITB	#EX.AC1,.SMCTL	; IF NON CONTIGUOUS EXTEND, THEN ALL SET
	BEQ	120$		; NO. OF BITS ALLOCATED ON TOP OF STACK
; 
; CONTIGUOUS EXTEND AND DIDN'T FIND ENOUGH SPACE, KEEP TRACK OF
; BIGGEST CONTIGUOUS CHUNK FOUND.
; 
	MOV	#.SM2BT,R5
	MOV	(SP)+,R2	; R2,R3=SIZE OF CHUNK IN BITS
	MOV	(SP)+,R3
	CMP	R2,(R5)+	; IS IT LARGER THAN CURRENT LARGEST?
	BNE	100$
	CMP	R3,(R5)
100$:	BLOS	110$		; BRANCH IF NO
; 
; SAVE THIS AS THE LARGEST AREA
; 
	MOV	R3,(R5)
	MOV	R2,-(R5)
	MOV	#.SM1MK,R2
	MOV	(R2)+,-(R5)	; SM1MK TO SM2MK
	MOV	(R2)+,-(R5)	; SM1AD TO SM2AD
	MOV	(R2)+,-(R5)	; SM1VB TO SM2VB
; 
; R0=MASK WORD, R1=ADDRESS - TRY TO FIND A BIG ENOUGH PIECE
; 
110$:
	BR	60$
; 
; SUCCESSFUL ALLOCATION, NO. OF BITS ALLOCATED ON TOP OF STACK
; 0(SP)=HIGH BITS OF COUNT, 2(SP)=LOW BITS.
; 
120$:	MOV	V.SBSZ(R4),.SMCNT ; DISABLE BLOCK COUNT LOGIC IN .SMNXT
	MOV	.SM1VB,R3	; R3=VBN FOR 1ST BIT
	CALL	.SMRVB		; MAKE SURE STARTING BIT MAP BLOCK IS IN
	MOV	(SP),R2		; R2,R3=NO. OF BITS
	MOV	2(SP),R3
	MOV	.SM1MK,R0	; R0=STARTING MASK WORD
	MOV	.SM1AD,R1	; R1=STARTING WORD ADDRESS
	MOV	#.ALOBT,R5	; ALLOCATE THE BITS FOUND
	CALL	.SMSCN
; 
; CALCULATE NO. OF BLOCKS ALLOCATED AND STARTING LBN,
; 
130$:	MOV	V.CLF(R4),R0	; R0=CLUSTER FACTOR
	MOV	(SP)+,R2	; R2,R3=BIT COUNT ALLOCATED
	MOV	(SP)+,R3
	CALL	$DMUL		; CALCULATE R0,R1=NO. OF BLOCKS
	MOV	R0,.SM1BT	; STORE NO. OF BLOCK ALLOCATED
	MOV	R1,.SM1BT+2
; 
; CALCULATE LOGICAL BLOCK NUMBER
; 
	MOV	.SM1AD,R1
	SUB	#.SMBUF,R1	; R1=BYTE NO. IN BUFFER
	ASL	R1		; CALCULATE R1=BITS UP TO THE MARKED WORD
	ASL	R1
	ASL	R1
	MOV	.SM1MK,R2	; R2=MASK WORD
	CLC
140$:	ROR	R2		; SHIFT MASK BIT
	BCS	150$		; IF C=1, MASK=0
	INC	R1		; COUNT THE BITS
	BR	140$
150$:	MOV	R1,R3		; BIT NUMBER IN THIS BLOCK, R2=0
	MOV	.SM1VB,R0	; VBN OF BIT MAP BLOCK (STARTS AT 1)
	BR	170$
160$:	ADD	#512.*8.,R3	; ADD NO. OF BITS  PER BLOCK
	ADC	R2
170$:	SOB	R0,160$		; FOR EACH VBN UP TO THIS ONE
	MOV	V.CLF(R4),R0	; R0=CLUSTER FACTOR
	CALL	$DMUL		; FORM LBN IN R0,R1, RETURN C=0
	MOV	R1,R3		; MOVE LBN TO R2,R3
	MOV	R0,R2
	MOV	.SM1BT,R0	; GET COUNT IN R0,R1
	MOV	.SM1BT+2,R1
	RETURN



	.END

