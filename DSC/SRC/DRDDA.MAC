	$BEGIN	DRDDA,0011,< READ DATA FROM DISK>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  12-AUG-76  20:14
;
; **GR01---G.RITTENBURG 10-OCT-1978
; RELEASE ALTERNATE BUFFER CONTROL BLOCK FOR VERIFY DURING
; DISK TO TAPE COPY, CORRECTION FROM 11M DSC
;

;+
;
; *** - $DRDDA	READ DATA FROM DISK FILE
;
; THIS ROUTINE READS THE INDICATED DATA BLOCKS FROM THE INPUT DISK
; FILE INTO THE INDICATED DATA BUFFER. VIRTUAL BLOCKS ARE MAPPED
; TO LOGICAL BLOCKS USING THE INPUT FILE HEADER AND LOGICAL TRANSFERS
; ARE INITIATED AS NECESSARY. NOTE THAT A BLOCK COUNT CAUSES A DUMMY
; TRANSFER OF ZERO LENGTH.
;
; INPUTS:
;
;	R1 = BLOCK COUNT TO READ
;	$VBN = HIGH AND LOW STARTING VBN
;	R4 = INPUT BUFFER DESCRIPTOR
;
; OUTPUTS:
;
;	R4 = BUFFER DESCRIPTOR ADDRESS
;	$VBN UPDATED TO NEXT BLOCK
;	BUFFER PREAMBLE INITIALIZED
;	TRANSFER INTO BUFFER INITIATED
;	OTHER REGISTERS CLOBBERED
;
;-

$DRDDA::
	$CALL $BUFCK <,,,,R4>		; WAIT FOR BUFFER
	LET B.SIZ+P.VBN(R4) := $VBN	; SET UP STARTING VBN
	LET B.SIZ+P.VBN+2(R4) := $VBN+2	; IN PREAMBLE
	LET B.SIZ+P.CNT(R4) := #0	; INIT BYTE COUNT TO 0
	LET B.SIZ+P.FLAG(R4) := #PF.DAT	; SET DATA BLOCK FLAG
	PUSH R1				; SAVE BLOCK COUNT
	PUSH R4,R4			; SAVE DESCRIPTOR ADDRESS
	LET (SP) := (SP) + #B.SIZ+P.SIZ	; BUILD START ADDRESS
	REPEAT
	  LET R5 := #$IHBF		; MAP USING INPUT FILE HEADER
	  LET R3 := $VBN - H.VBN(R5)	; GET CURRENT VBN, ADJUSTED
	  LET R2 := $VBN+2 - CARRY - H.VBN+2(R5) ; BY BASE VBN
	  IF 4(SP) EQ #0 GOTO EXIT	; IF NULL TRANSFER
	  $CALL $MPVBN <,,R2,R3,,R5>	; MAP TO LOGICAL
	  ON.ERROR GOTO EXIT
	  IF R0 NE #0 OR R1 HI 4(SP)	; IF MORE BLOCKS MAPPED
	    LET R0 := #0		; THAN DESIRED,
	    LET R1 := 4(SP)		; REDUCE TO DESIRED NUMBER
	  END
	  LET $VBN := $VBN + R1		; BUMP VBN TO NEXT SEGMENT
	  LET $VBN+2 := $VBN+2 + CARRY
	  LET 4(SP) := 4(SP) - R1	; DECREMENT BLOCK COUNT
	  $CALL $MUL <#512.,R1>		; COMPUTE BYTE COUNT
	  POP R5			; GET CURRENT BUFFER ADDR
	  LET R0 := (SP)		; GET MAIN BCB
	  LET B.SIZ+P.CNT(R0) := B.SIZ+P.CNT(R0) + R1 ; ADD COUNT
	  IF 2(SP) NE #0		; IF TRANSFER IS NOT COMPLETE
	    LET R4 := R4 - #B.SIZ	; BACK UP TO ANOTHER BCB
	    LET B.STAT(R4) := #0	;RELEASE ALTERNATE BCB
	    $CALL $READA <,R1,R2,R3,R4,R5> ; START THE READ
	    LET R5 := R5 + R1		; UPDATE BUFFER ADDRESS
	    PUSH R5			; AND SAVE FOR NEXT READ
	  ELSE				; IF THIS IS THE LAST
	    $CALL $READA <,R1,R2,R3,(SP)+,R5> ; READ WITH MAIN BCB
	    LEAVE LOOP
	  END
	END LOOP
	TST (SP)+			; CLEAN THE STACK
	RETURN
;
; TO HERE IF THIS IS A DUMMY TRANSFER OR IF THE LAST EXTENT
; FAILED TO MAP.
;
EXIT:	TST (SP)+			; DISCARD BUFFER POINTER
	POP R4				; GET ORIGINAL BCB
	LET B.IOST(R4) := #1		; FAKE A SUCCESSFUL COMPLETION
	LET B.STAT(R4) := #3		; HOLDING DATA
	$CALL $LINKI <,,,,R4>		; LINK ONTO WAIT LIST
	TST (SP)+			; CLEAN THE STACK
	RETURN



	.END
