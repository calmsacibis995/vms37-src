	$BEGIN	DSCER,0033.2,<DSC ERROR REPORT MODULE>

; ALTERED:
; GEORGE RITTENBURG    21-SEP-76  9:27
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  1-NOV-76  21:48
; GEORGE RITTENBURG 6-APR-77 MODIFIED FOR VFY/CMP DISK TO/FROM TAPE
; THE FOLLOWING CORRECTIONS BY G.RITTENBURG JAN.3,1978
; GR001---CORRECTIONS TO ELIMINATE OVERFLOW OF MESSAGE BUFFER.
; GR002---CORRECTIONS TO ELIMINATE UNKNOWN ERROR MESSAGE AND
; TO DISPLAY ERROR CODE.
; GR003--- CORRECT ERROR MESSAGE GENERATION.
;
; **GR04---G.RITTENBURG 23-OCT-1978
; CORRECTIONS FROM 11M
;
; ACG0014 - ANDREW C. GOLDSTEIN
; ADD UPSUPPORTED TAPE FORMAT MESSAGE

	.IF	NDF,R$$NVX
	.MCALL	QIOW$S,FHDL2$
	FHDL2$			; DEFINE FILE HEADER FORMAT
	.IFF
	.MCALL	QIOW$S
	.ENDC

	.SBTTL	PURE AND IMPURE DATA

;
; IMPURE DATA
;
$CODE:	.BLKW	1			; SPACE FOR MESSAGE CODE
$PARAM:	.BLKW	12.			; MESSAGE PARAMETER BLOCK
$MBUF:	.BLKB	200.			; BUFFER FOR MESSAGE STRING FOR TYPING
COMMSG:   .BLKB   100.	;COMMON MESSAGE BUFFER FOR EDITING
FORM1:   .ASCII   \%2A%O:\
FORM2:   .ASCIZ   \%P,%P,%P%N%VA%N\
STDMSG:   .ASCII   \I/O ERROR   ON \



;
; MESSAGE PREFIX STRINGS FOR THE VARIOUS MESSAGE TYPES.
;
FATAL:	.ASCII	"DSC -- *FATAL* "	; FATAL ERROR
FATLL = .-FATAL

WARN:	.ASCII	"DSC -- *WARNING* "	; WARNING MESSAGE
WARNL = .-WARN

RDPRE:	.ASCII	"DSC -- "		; READY MESSAGE PREFIX
RDPRL = .-RDPRE

	.EVEN

	.SBTTL	ERROR MESSAGE CODE

;+
;
; *** - $DSCER	ERROR MESSAGE MODULE FOR DSC
;
; THIS ROUTINE IS ENTERED FROM THE TRAP VECTOR TO REPORT AN ERROR
; CONDITION. THE TRAP CODE IS THE ERROR CODE; IF POSITIVE, THE
; CURRENT COMMAND IS ABORTED; IF NEGATIVE, OPERATION IS RESUMED
; AFTER PRINTING THE MESSAGE.
;
; INPUTS:
;
;	STACK:	ERROR CODE * 2
;		PC
;		PS
;	ALL REGISTERS AT TIME OF TRAP
;
; OUTPUTS:
;
;	MESSAGE OUTPUT TO TERMINAL
;	ALL REGISTERS PRESERVED
;	CC - C	SET
;	RETURNS TO DSC INIT POINT IF TRAP CODE IS NEGATIVE
;
;-

$DSCER::
	LET $CODE := (SP)+		; SAVE THE ERROR CODE
	LET (SP) := (SP)+		; CLEAN PS OFF STACK
	IF #400 OFF.IN $CODE		; IF ABORT REQUESTED
	  LET SP := $STAK		; CLEAN THE ENTIRE STACK
	  PUSH #$DSC			; SET RETURN TO INIT POINT
	  LET $PARAM := #FATLL		; SET FATAL MESSAGE HEADER
	  LET $PARAM+2 := #FATAL
	  LET $ESTAT  :=  #2	;INDICATE FATAL ERROR OCCURRED
	ELSE
	  LET $CODE := - $CODE OFF.BY #^C377 ; MAKE CODE POSITIVE
	  LET $PARAM := #WARNL		; SET WARNING MESSAGE HEADER
	  LET $PARAM+2 := #WARN
	   IF $ESTAT  LT  #0	;IF NO WARN. OR FATAL YET
		LET $ESTAT  :=  #-2	; INDICATE WARNING MESSAGE SENT
	   END
	END
	$CALL $SAVAL			; SAVE ALL REGISTERS
;
;NOW MOVE BASIC PART OF MSG TO COMMON MESSAGE BUFFER
;
	LET R4 := #0		;OFFSET IN CURRENT MESSAGE
	LET R2 := $CODE		;ORIGINAL ERROR CODE
	LET R3 :=  #COMMSG	;1ST BYTE COMMON BUFFER
TAG1:	LET R1 := R2		;GET ERROR CODE
	IF R1 HI #MAXCOD
		FATAL <GARBAGE MESSAGE CODE>
	END
	LET R1 := $MSG(R1) + R4	;CURRENT POSITION IN MESSAGE
	LET R5 := R3		;CURRENT POS. IN COMMON BUFFER
	WHILEB (R1) NE #0	;UNTIL NULL CHAR
		LET (R5)+ :B= (R1)+	;MOVE CHAR. TO COMMON BUFFER
	END
	LET R1 := R2		;RESET R1TO ERR.CODE--
			;R5 IS ADDRESS OF NEXT BYTE IN COMM.BUFFR
	$CALL  @$MSV(R1)	;TO APPEND FORMAT CHARS.
;
; NOW CALL THE ACTION ROUTINE ASSOCIATED WITH THE ERROR
;
	LET R5 := #$PARAM+4		; POINT TO PARAMETER BLOCK
	LET R1 := SP + #6		;RESTORE R2,R3,R4
	LET R2 := (R1)+
	LET R3 := (R1)+
	LET R4 := (R1)+
	LET R1 := $CODE			; GET CODE
	$CALL @$ACT(R1)			; CALL THE ACTION ROUTINE
;
; NOW GENERATE THE MESSAGE FROM THE FORMAT STRING THE THE PARAMETER
; BLOCK PREPARED BY THE ACTION ROUTINE.
;
	LET R1 := $CODE			; GET CODE AGAIN
	LET R1 := #COMMSG		; GET ADDRESS OF COMMON BUFFER
	$CALL $EDMSG <#$MBUF,R1,#$PARAM>
					; AND OUTPUT TO TERMINAL
	QIOW$S #IO.WVB,#TTYLUN,#TTEFN,,,,<#$MBUF,R1,#0>
	IF $ESTAT EQ #-2
	   LET $ESTAT :=	#0  ;SET WARNING INDICATOR
	END
	RETURN ERROR

	.SBTTL	ERROR MESSAGE MACROS

;
; MACRO TO GENERATE ERROR MESSAGE TABLES. THE MESSAGE FORMAT STRINGS
; ARE ACCUMULATED, AND A POINTER TABLE IS BUILT, INDEXABLE BY MESSAGE
; CODE. ALSO, A POINTER TABLE FOR THE ACTION ROUTINES IS CONSTRUCTED.
;
	.MACRO	MSG	CODE,STRING
	ER.'CODE == $$CODE
	$$CODE = $$CODE + 1
	.PSECT	$$MSG
	...MSG = .
	.ASCIZ	\%N%VA'STRING\
	.PSECT	$$MST
	.WORD	...MSG
	.PSECT	$$ACT
	.WORD	AC.'CODE
	.PSECT  $$MSV
	.WORD  MV.'CODE
	.PSECT	$$MSG
	.ENDM	MSG

	.MACRO	MSGC	CODE,STRING
	ER.'CODE == $$CODE
	$$CODE = $$CODE + 1
	.PSECT	$$MSG
	...MSG = .
	.ASCII	\%N%VA'STRING\
	.PSECT	$$MST
	.WORD	...MSG
	.PSECT	$$ACT
	.WORD	AC.'CODE
	.PSECT   $$MSV
	.WORD   MV.'CODE
	.PSECT	$$MSG
	.ENDM	MSGC



;
; INITIALIZE ORIGINS OF THE TABLES
;
	.PSECT	$$MST
$MSG:

	.PSECT   $$MSV
$MSV:

	.PSECT	$$ACT
$ACT:

	$$CODE = 0

	.SBTTL	ERROR MESSAGES

	.NLIST	BEX

;
; THE MESSAGES THEMSELVES
;
		.IF NDF, R$$11S
;
; MESSAGES FOR ON-LINE DSC ONLY
;
MSG	UDE, <1 UNDEFINED ERROR>
MSG	CDV, <2 CONFLICTING DEV. TYPES;>
MSG	MXT, <3 MIXED TAPE TYPES;>
MSG	ILS, <4 ILLEGAL SWITCH;>
MSG	LAB, <5 FILE LABEL TOO LONG;>
MSG	SYN, <6 SYNTAX ERROR;>
MSG	DUD, <7 DUP. DEV. NAME;>
MSG	TMD, <8 TOO MANY DEV'S;>
MSG	DEV, <9 DEV. %2A%O: NOT IN SYSTEM>
MSG	F11, <10 DEV. %2A%O: NOT FILES-11>
MSG	BSY, <11 BAD BLOCK SYNTAX ERROR>
MSG	BCT, <12 BAD BLOCK COUNT TOO LARGE>
MSG	BRG, <13 BAD BLOCK CLUSTER OUT OF RANGE>
MSG	OBO, <14 OUTPUT TAPE %2A%O: NOT AT BOT>
MSG	TFU, <15 OUTPUT TAPE %2A%O: FULL>
MSG	NLV, <16 OUTPUT TAPE %2A%O: NOT ONLY REEL IN SET>
MSG	IFM, <17 TAPE %2A%O: NOT ANSI FORMAT>
MSG	NDS, <18 OUTPUT TAPE %2A%O: NOT DSC TAPE>
MSG	NFI, <19 TAPE %2A%O: A CONTINUATION TAPE>
MSG	DNS, <20 CANNOT DETERMINE DENSITY OF TAPE >
MSG	NHO, <21 FAILED TO FIND HOME BLOCK >
MSG	LEV, <22 FILE STRUCTURE LEVEL ON %2A%O: NOT SUPPORTED%N>
MSG	IXB, <23 A>
MSG	IXH, <24 B>
MSG	SMH, <25 CODE A>
MSG	SMB, <26 C>
MSG	RHO, <27 D>
MSG	RVN, <28 RELATIVE VOLUME %D OF SET NOT MOUNTED>
MSG	TMI, <29 TOO MANY DISKS FOR SET>
MSG	TFI,	 <30 TOO FEW DISKS FOR SET>
MSG	RHD, <31 I/O ERROR E ON %2A%O:, FILE ID >
MSG	FNU, <32 INPUT DEVICE %2A%O: FILE ID %P,%P NOT PRESENT>
MSG	DEL, <33 INPUT DEVICE %2A%O: FILE ID %P,%P IS DELETED>
MSG	FLV, <34 INPUT DEVICE %2A%O: FILE ID %P,%P UNSUPPORTED STRUCTURE LEVEL>
MSG	FNO, <35 INPUT DEVICE %2A%O: FILE ID %P,%P FILE NUMBER CHECK>
MSG	HCK, <36 INPUT DEVICE %2A%O: FILE ID %P,%P FILE HEADER CHECKSUM ERROR>
MSG	ESQ, <37 INPUT DEVICE %2A%O: FILE ID %P,%P SEQUENCE NUMBER CHECK>
MSG	ESN, <38 INPUT DEVICE %2A%O: FILE ID %P,%P SEGMENT NUMBER CHECK>
MSG	DIR, <39 DIRECTIVE ERROR - %VA%N>
MSG	IIR, <40 F>
MSGC	RDA, <41 I/O ERROR I ON %2A%O:%NFILE ID %P,%P,%P,VBN %P,%P%>
.ASCIZ	"N%VA%N"
MSG	VER, <42 VERIFICATION ERROR ON %2A%O:%NFILE ID %P,%P,%P, VBN >
MSG	BDA, <43 BAD DATA BLOCK ON %2A%O:%NFILE ID %P,%P,%P,VBN %P,%P%N>
MSG	RDY, <44 MOUNT REEL %D ON %2A%O: AND HIT RETURN>
MSG	VFY, <45 STARTING VERIFY PASS>
MSG	RSC, <46 RESUME COPYING>
MSG	WLK, <47 %2A%O: IS WRITE LOCKED. INSERT WRITE RING AND HIT RETURN>
MSG	FSY, <48 INPUT FILE ON %2A%O: WILL BE RESYNCHRONIZED>
MSG	DFU, <49 OUTPUT DEVICE %2A%O: FULL%N FILE ID >
MSG	HFU, <50 OUTPUT FILE HEADER FULL ON %2A%O:%N- FILE ID >
MSG	OFN, <51 OUTPUT FILE HEADER ON %2A%O: NOT MAPPED - FILE ID >
MSG	WXB, <52 G>
MSG	RXD, <53 FAILED TO READ FILE EXTENSION HEADER ON %2A%O: - FILE ID >
MSG	AHM, <54 FAILED TO ALLOCATE HOME BLOCK >
MSG	ALF, <55 INDEX FILE ALLOCATION FAILURE >
MSG	NBO, <56 OUTPUT DISK %2A%O: IS NOT BOOTABLE>
MSG	BBD, <57 INVALID BAD BLOCK DATA >
MSG	BFU, <58 BAD BLOCK FILE FULL >
MSG	NBD, <59 NO BAD BLOCK DATA FOUND >
MSG	DGP, <60 OUTPUT DEVICE %2A%O: IS A DIAGNOSTIC PACK. DO NOT USE IT!>
MSGC	VBN, <61 CODE B ON %2A%O:%NFILE ID %P,%P,%P%N - VBN %P,%P >
.ASCIZ	"EXPECTED, %P,%P FOUND%N"
MSG	NDA, <62 CODE C ON %2A%O:%NFILE ID %P,%P,%P%N - VBN %P,%P%N>
MSGC	FID, <63 CODE D ON %2A%O:%NFILE ID %P,%P,%P EXPECTED, %P,>
.ASCIZ	"%P,%P FOUND%N"
MSG	MPO, <64 FAILED TO MAP OUTPUT FILE ON %2A%O:%NFILE ID %P,%P,%P, VBN >
MSG	DEX, <65 OUTPUT DISK %2A%O: IS TOO SMALL - %P,%P BLOCKS NEEDED>
MSG	RSM, <66 C>
MSG	WSM, <67 H>
MSG	ILB, <68 J>
MSG	BOT, <69 INPUT TAPE ON %2A%O: MUST BE AT BOT>
MSG	WRV, <70 WRONG INPUT TAPE ON %2A%O:%N EXPECTING "%VA", FOUND "%VA">
MSG	PH1, <71  CODE E ON %2A%O: AFTER FILE ID >
MSG	RAT, <72 I/O ERROR K ON %2A%O:%NAFTER FILE ID >
MSG	RHT, <73 I/O ERROR L ON %2A%O:%NAFTER FILE ID >
MSG	RSY, <74 INPUT TAPE %2A%O: RESYNCHRONIZED AT FILE ID >
MSG	FNF, <75 TAPE FILE "%VA" NOT FOUND >
MSG	NNX, <76 EXPECTED EXTENSION HEADER NOT PRESENT ON %2A%O: - FILE ID >
MSG	NXT, <77  CODE F ON %2A%O: AFTER FILE ID >
MSG	RID, <78 M>
MSG	TID, <79 INDEX FILE DATA NOT PRESENT >
MSG	RSU, <80 N>
MSG	ITP, <81 VOLUME SUMMARY DATA NOT PRESENT >
MSG	WHD, <82 I/O ERROR O ON %2A%O: - FILE ID >
MSG	IVT, <83 UNSUPPORTED DSC TAPE FORMAT ON >
;

	.SBTTL	ERROR  MESSAGES

	.NLIST	BEX

;
; THE STAND-ALONE MESSAGES 
;
.IFF
;
; STAND-ALONE DSC MESSAGES
;
MSG	UDE,  <1>
MSG	CDV,  <2>
MSG	MXT,  <3>
MSG	ILS,  <4>
MSG	LAB,  <5>
MSG	SYN,  <6>
MSG	DUD,  <7>
MSG	TMD,  <8>
MSG	DEV,  <9-%2A%O:>
MSG	F11,  <10-%2A%O:>
MSG	BSY,  <11>
MSG	BCT,  <12>
MSG	BRG,  <13>
MSG	OBO,  <14-%2A%O:>
MSG	TFU,  <15-%2A%O:>
MSG	NLV,  <16-%2A%O:>
MSG	IFM,  <17-%2A%O:>
MSG	NDS,  <18-%2A%O:>
MSG	NFI,  <19-%2A%O:>
MSG	DNS,  <20->
MSG	NHO,  <21->
MSG	LEV,  <22-%2A%O:>
MSG	IXB,  <23 A>
MSG	IXH,  <24 B>
MSG	SMH,  <25 CODE A>
MSG	SMB,  <26 C>
MSG	RHO,  <27 D>
MSG	RVN,  <28-%D>
MSG	TMI,  <29>
MSG	TFI,  <30>
MSG	RHD,  <31-%2A%O:,>
MSG	FNU,  <32-%2A%O:-%P,%P>
MSG	DEL,  <33-%2A%O:-%P,%P>
MSG	FLV,  <34-%2A%O:-%P,%P>
MSG	FNO,  <35-%2A%O:-%P,%P>
MSG	HCK,  <36-%2A%O:-%P,%P>
MSG	ESQ,  <37-%2A%O:-%P,%P>
MSG	ESN,  <38-%2A%O:-%P,%P>
MSG	DIR,  <39-%VA%N>
MSG	IIR,  <40 F>
MSG	RDA,  <41-%2A%O:-%P,%P,%P-%P,%P%N%VA%N>
MSG	VER,  <42-%2A%O:%N-%P,%P,%P, VBN >
MSG	BDA,  <43-%2A%O:%N-%P,%P,%P-%P,%P%N-%VA%N>
MSG	RDY,  <44 MOUNT REL %D ON %2A%O: AND HIT RETURN>
MSG	VFY,  <45 START VFY PASS>
MSG	RSC,  <46 RESUME COPY>
MSG	WLK,  <47 %2A%O: WRITE LOCKED>
MSG	FSY,  <48-%2A%O:>
MSG	DFU,  <49-%2A%O:%N>
MSG	HFU,  <50-%2A%O:%N>
MSG	OFN,  <51-%2A%O:->
MSG	WXB,  <52 G>
MSG	RXD,  <53-%2A%O:->
MSG	AHM,  <54->
MSG	ALF,  <55->
MSG	NBO,  <56-%2A%O:>
MSG	BBD,  <57->
MSG	BFU,  <58->
MSG	NBD,  <59->
MSG	DGP,  <60-%2A%O:>
MSG	VBN,  <61-%2A%O:%N-%P,%P,%P%N-%P,%P-%P,%P%N>
MSG	NDA,  <62-%2A%O:%N-%P,%P,%P%N-%P,%P%N>
MSG	FID,  <63-%2A%O:%N-%P,%P,%P-%P,%P,%P%N>
MSG	MPO,  <64-%2A%O:%N-%P,%P,%P->
MSG	DEX,  <65-%2A%O:-%P,%P>
MSG	RSM,  <66 C>
MSG	WSM,  <67 H>
MSG	ILB,  <68 J>
MSG	BOT,  <69-%2A%O: MUST BE AT BOT>
MSG	WRV,  <70 WRONG TAPE-%2A%O:%N-%VA-%VA>
MSG	PH1,  <71 -%2A%O:->
MSG	RAT,  <72 -%2A%O:%N->
MSG	RHT,  <73 -%2A%O:%N->
MSG	RSY,  <74-%2A%O:->
MSG	FNF,  <75-%VA NOT FOUND->
MSG	NNX,  <76-%2A%O:->
MSG	NXT,  <77-%2A%O:->
MSG	RID,  <78 M>
MSG	TID,  <79->
MSG	RSU,  <80 N>
MSG	ITP,  <81->
MSG	WHD,  <82-%2A%O:->
MSG	IVT,  <83->

MSG	ILU,<SPECIFIED UNIT NUMBER EXCEEDS MAX. OF 1 >
MSG	VEC,<ILLEGAL VECTOR ADDRESS >
MSG	CSR,<INVALID CSR ADDRESS >
MSG	TM2,<INVALID TM02 ASSIGNMENT >
.ENDC


	MAXCOD = $$CODE-1*2
;
ER.TFM == ER.IFM
ER.NFV == ER.NFI
ER.IXO == ER.IXH
ER.TMO == ER.TMI
ER.TFO == ER.TFI
ER.RDO == ER.RDA
ER.IOR == ER.IIR
; THE PRECEDING ASSIGNMENTS SERVE TO ELIMINATE DUPLICATE ERROR MESSAGES
;
;			;CODED I/O MESSAGES
;CODE A =READING INDEX FILE BIT MAP
;CODE B + READING INDEX FILE HEADER
;CODE C = READING STORAGE BIT MAP
;CODE D = READING BOOT OR HOME BLOCK
;CODE E = READING FILE HEADER
;CODE F =INPUT DEVICE
;CODE G = WRITING INDEX FILE BIT MAP
;CODE H = WRITING STORAGE BIT MAP HEADER
;CODE I =READING INPUT DEVICE
;CODE J = IN INPUT TAPE LABELS
;CODE K = READING FILE ATTRIBUTES
;CODE L = READING FILE HEADER
;CODE M = READING INDEX FILE DATA
;CODE N = READING SUMMARY DATA
;CODE O =WRITING FILE HEADER
;
;
			;GENERAL ERROR MESSAGE CODES
;
;
;CODE A = FAILED TO READ STORAGE MAP HEADER
;CODE B = INPUT DATA OUT OF PHASE 
;CODE C = NON-DATA BLOCK ENCOUNTERED 
;CODE D = INPUT FILE OUT OF PHASE
;CODE E = FILE ATTRIBUTES OUT OF PHASE
;CODE F = FILE HEADER OUT OF PHASE


	.LIST	BEX
	.SBTTL	I/O ERROR TABLE MACROS

;
; MACRO TO GENERATE I/O ERROR MESSAGE TABLE. IT GENERATES THE MESSAGE
; STRINGS, AND 3 PARALLEL TABLES: THE ERROR CODES, THE STRING LENGTHS,
; AND THE STRING ADDRESSES.
;
	.MACRO	IOE	CODE,STRING	; I/O ERROR
	.PSECT	$$IOE
	.WORD	CODE&377
	.PSECT	$$MSG
	...MSG=.
	.ASCII	"STRING"
	...MSE=.
	.PSECT	$$IOSL
	.WORD	...MSE-...MSG
	.PSECT	$$IOS
	.WORD	...MSG
	.PSECT
	.ENDM	IOE

	.MACRO	QIOE	CODE,STRING	; DIRECTIVE ERROR
	.PSECT	$$IOE
	.WORD	CODE
	.PSECT	$$MSG
	...MSG=.
	.ASCII	"STRING"
	...MSE=.
	.PSECT	$$IOSL
	.WORD	...MSE-...MSG
	.PSECT	$$IOS
	.WORD	...MSG
	.PSECT
	.ENDM	QIOE


;
; INITIALIZE TABLE ORIGINS
;
	.PSECT	$$IOE
$IOE:

	.PSECT	$$IOSL
$IOSL:

	.PSECT	$$IOS
$IOS:

	.SBTTL	I/O ERROR MESSAGES


;
; THE I/O ERROR MESSAGES
;
IOE	IE.DNR, <DEVICE NOT READY>
IOE	IE.VER, <PARITY ERROR ON DEVICE>
IOE	IE.WLK, <DEVICE WRITE LOCKED>
IOE	IE.DAO, <DATA OVERRUN>
IOE	IE.PRI, <PRIVILEGE VIOLATION>
IOE	IE.BLK, <BAD BLOCK NUMBER>
IOE	IE.BBE, <BAD BLOCK ON DEVICE>
IOE	IE.FHE, <FATAL HARDWARE ERROR>
IOE	IE.EOF, <END OF FILE DETECTED>
IOE	IE.EOT, <END OF TAPE DETECTED>
IOE	IE.EOV, <END OF VOLUME DETECTED>
IOE	IE.OFL, <DEVICE OFF-LINE>
IOE	IE.BCC, <BLOCK CHECK OR CRC ERROR>
IOE	IE.IFC,  <ILLEGAL FUNCTION>
QIOE	IE.UPN, <INSUFFICIENT POOL SPACE>
QIOE	IE.HWR, <HANDLER NOT RESIDENT>
QIOE	0, <ERROR CODE IS>

	.PSECT	$$IOE
$IOEL = <.-$IOE>/2			; NUMBER OF ENTRIES

	.PSECT

	.SBTTL	ERROR ACTION ROUTINES

	.PSECT

;
; ACTION ROUTINES FOR THE VARIOUS ERROR CONDITIONS. EACH ACTION
; ROUTINE'S LABEL CORRESPONDS TO THE NAME OF THE ERROR MESSAGE.
; THE ACTION ROUTINE IS CALLED WITH R1 CONTAINING THE MESSAGE CODE
; TIMES 2 AND R5 POINTING TO THE THIRD WORD OF THE PARAMETER
; BLOCK. EACH ACTION ROUTINE FILLS IN THE PARAMETER BLOCK TO
; CORRESPOND TO THE FORMAT STRING.
;

AC.UDE:					; UNDEFINED ERROR
AC.BSY:					; BAD BLOCK SYNTAX
AC.BCT:					; BAD BLOCK COUNT
AC.BRG:					; BAD BLOCKS OUT OF RANGE
AC.SMH:					; ERROR READING STORAGE MAP HEADER
AC.TFI:					; TOO FEW INPUT DISKS
AC.TMI:					; TOO MANY INPUT DISKS
	RETURN				; NOOP ACTION

AC.DEV:					; DEVICE NOT IN SYSTEM
AC.F11:					; DEVICE NOT FILES-11
	LET R1 := R0
GETDEV:	LET (R5)+ := R1			; DEVICE NAME
	TST (R1)+
	LET (R5)+ := (R1)		; AND UNIT NUMBER
	RETURN


.IF  DF,R$$11S
AC.ILU:
AC.VEC:
AC.CSR:
AC.TM2:

.ENDC

AC.CDV:					; CONFLICTING DEVICES
AC.MXT:					; MIXED TAPE TYPES
AC.ILS:					; ILLEGAL SWITCH
AC.LAB:					; LABEL TOO LONG
AC.SYN:					; SYNTAX ERROR
AC.DUD:					; DUPLICATE DEVICES
AC.TMD:					; TOO MANY DEVICES
	LET R4 := R4 - CML		; LENGTH OF COMMAND PARSED
	LET (R5)+ := R4
	LET (R5)+ := CML		; ADDRESS OF COMMAND STRING
	RETURN

AC.RDY:					; TAPE READY
	IF R3 LT #$OVNUM			;IF TAPE I.P.
	   LET (R5)+ := $RELNI		; I.P.TAPE REEL NO.
	ELSE
	   LET (R5)+ := $RELNO		; O.P. TAPE REEL NO.
	END

AC.WLK:					; TAPE WRITE LOCKED
	LET R1 := R3			; R3 POINTS TO DEVICE NAME
	$CALL GETDEV

AC.RSC:					;RESUME COPY MESSAGE
AC.VFY:					; VERIFY PASS MESSAGE
	LET $PARAM := #RDPRL		; USE READY MESSAGE PREFIX
	LET $PARAM+2 := #RDPRE
	IF $ESTAT EQ #-2   ;IF ONLY THIS WARN. MSG. SO FAR
	   LET $ESTAT := #-1   ; RESET $ESTAT =SUCCESS
	END
	RETURN

AC.NDS:					; NOT A DSC TAPE
AC.OBO:					; TAPE NOT AT BOT
AC.TFU:					; TAPE FULL
AC.NLV:					; NOT LAST VOLUME
AC.DNS:					; CAN'T FIND DENSITY
AC.AHM:					; CAN'T ALLOCATE HOME BLOCK
AC.ALF:					; CAN'T ALLOCATE INDEX FILE
AC.NBO:					; VOLUME NOT BOOTABLE
AC.BBD:					; BAD BAD BLOCK DATA
AC.BFU:					; BAD BLOCK FILE FULL
AC.NBD:					; NO BAD BLOCK DATA
AC.DGP:					; DIAGNOSTIC PACK
GETDVO:	LET R1 := $OUDEV		; GET OUTPUT DEVICE NAME
	GOTO GETDEV

AC.NFI:					; NOT FIRST REEL
AC.IFM:					; NOT ANSI FORMAT
AC.FSY:					; TAPE WILL BE RESYNCED
AC.NHO:					; NO HOME BLOCK
AC.LEV:					; BAD STRUCTURE LEVEL
AC.BOT:					; TAPE NOT AT BOT
AC.TID:					; NO INDEX FILE DATA
AC.ITP:					; NO SUMMARY DATA
AC.IVT:					; UNSUPPORTED TAPE FORMAT
GETDVI:
	IF #KY.NIP SET.IN $FLAG1
		LET R1 := $OUDEV
	ELSE
		LET R1 := $INDEV
	END
	GOTO GETDEV

AC.DEX:					; OUTPUT DEVICE TOO SMALL
	$CALL GETDVO			; OUTPUT DEVICE NAME
	LET (R5)+ := $B2DAT+S.USE+2	; SPACE NEEDED
	LET (R5)+ := $B2DAT+S.USE
	RETURN

AC.WRV:					; WRONG INPUT TAPE
	IF #KY.NIP SET.IN $FLAG1
		$CALL GETDVO
	ELSE
		$CALL GETDVI			; INPUT DEVICE NAME
	END
	LET (R5)+ := #22.		; LABEL BYTE COUNT
	LET (R5)+ := R0			; EXPECTED LABEL
	LET (R5)+ := #22.		; LABEL BYTE COUNT
	LET R4 := R4 + #B.SIZ		; POINT TO BUFFER
	LET (R5)+ := R4			; LABEL READ
	RETURN

AC.FNF:					; TAPE FILE NOT FOUND
	IF #KY.NIP SET.IN $FLAG1
		LET R0 := #$OLAB
	ELSE
		LET R0 := #$ILAB		; SCAN INPUT LABEL STRING
	END
	LET R1 := R0
	REPEAT
	THRU R2 := #12.
	  IFB (R1)+ EQ #40 LEAVE LOOP	; LOOK FOR SPACE
	END LOOP
	LET R1 := R1 - R0 - #1		; COMPUTE BYTE COUNT
	LET (R5)+ := R1
	LET (R5)+ := R0			; STORE STRING DESCRIPTOR
	IF #KY.NIP SET.IN $FLAG1
		GOTO GETDVO
	ELSE
		GOTO GETDVI
	END

AC.IXB:					; ERROR IN INDEX BITMAP
AC.IXH:					; ERROR ON INDEX HEADER
AC.SMB:					; ERROR ON STORAGE MAP
AC.RHO:					; ERROR READING HOME
	IF #KY.NIP SET.IN $FLAG1
		$CALL GETDVO
	ELSE
		$CALL GETDVI
	END
	GOTO GETIOR			; GENERAL I/O MESSAGE

AC.RVN:					; CAN'T FIND RVN
	LET (R5)+ := R0			; RVN
	RETURN

AC.ESQ:					; EXTENSION SEQUENCE CHECK
AC.ESN:					; EXTENSION SEGMENT CHECK
AC.HCK:					; HEADER CHECKSUM ERROR
AC.DEL:					; FILE IS DELETED
AC.FLV:					; FILE STRUCTURE LEVEL
	IF #KY.NIP SET.IN $FLAG1
		$CALL GETDVO
	ELSE
		$CALL GETDVI			; INPUT DEVICE NAME
	END
	LET (R5)+ := $FNU		; FILE NUMBER
	LET (R5)+ := B.SIZ+H.FSEQ(R4)	; FILE SEQUENCE NUMBER
	RETURN

AC.FNU:					; FILE NUMBER NOT FOUND
AC.FNO:					; FILE NUMBER CHECK
	$CALL AC.DEL			; GET ABOVE DATA
	LET -2(R5) := #0		; BUT ZERO SEQUENCE NUMBER
	RETURN

AC.FID:					; FID MISMATCH ON TAPE
	$CALL GETIFI			; INPUT DEVICE & FID
	LET (R5)+ := B.SIZ+P.FID(R4)	; ALSO FOUND FID
	LET (R5)+ := B.SIZ+P.FID+2(R4)
	LET (R5)+ := B.SIZ+P.FID+4(R4)
	RETURN

AC.MPO:					; OUTPUT DATA NOT MAPPED
	$CALL GETOFI			; OUTPUT DEVICE & FID
	LET (R5)+ := $VBN+2		; AND VBN
	LET (R5)+ := $VBN
	RETURN
AC.OFN:					; OUTPUT FILE ID NOT MAPPED
	$CALL GETDVO			; OUTPUT DEVICE NAME
	LET (R5)+ := $FNU		; FILE NUMBER
	LET (R5)+ := #0			; ZERO SEQ NUMBER
	RETURN

AC.DFU:					; DEVICE FULL
AC.HFU:					; HEADER FULL
GETOFI:	$CALL GETDVO			; OUTPUT DEVICE NAME
	GOTO GETFID			; AND FILE ID

AC.PH1:					; ATTRIBUTES OUT OF PHASE
AC.RSY:					; INITIATING RESYNC
AC.NNX:					; NO EXTENSION HEADER
AC.RXD:					; CAN'T READ OUTPUT EX. HEADER
AC.NXT:					; HEADER OUT OF PHASE
GETIFI:
	IF #KY.NIP SET.IN $FLAG1
		$CALL GETDVO
	ELSE
		$CALL GETDVI
	END
GETFID:	LET (R5)+ := $FID		; FILE ID
	LET (R5)+ := $FID+2
	LET (R5)+ := $RVN
	RETURN

AC.NDA:					; NON DATA BLOCK
	$CALL GETIFI			; INPUT DEVICE & FID
	LET (R5)+ := $TVBN+2		; EXPECTED TAPE VBN
	LET (R5)+ := $TVBN
	RETURN

AC.VBN:					; WRONG VBN FOM TAPE
	$CALL AC.NDA

GETVBF:	LET (R5)+ := B.SIZ+P.VBN+2(R4)	; GET VBN FROM BUFFER HEADER
	LET (R5)+ := B.SIZ+P.VBN(R4)
	RETURN

AC.RAT:					; I/O ERROR READING ATTR.
AC.RHT:					; I/O READING HEADER FROM TAPE
	$CALL GETIFI			; GET INPUT DEVICE & FID
	GOTO GETIOR

AC.WHD:					; I/O ERROR WRITING FILE HEADER
	$CALL GETOFI			; OUTPUT DEVICE & FID
	GOTO GETIOR

AC.RHD:					; ERROR READING FILE HEADER
	$CALL AC.FNU			; ABOVE DATA
	GOTO GETIOR			; GENERAL I/O MESSAGE
AC.VER:					; VERIFICATION ERROR
	$CALL GETOFI			; GET OUTPUT DEVICE AND FILE ID
	GOTO GETVBF			; GET VBN

AC.BDA:					; BAD DATA
	$CALL GETIFI			; GET INPUT DEVICE & FID
	GOTO GETVBF			; VBN

AC.RDA:					; ERROR READING DATA
	$CALL AC.BDA
	GOTO GETIOR			; GENERAL I/O MESSAGE

AC.ILB:					; I/O ERROR ON TAPE LABELS
AC.RID:					; I/O ERROR ON INDEX FILE DATA
AC.RSU:					; I/O ERROR ON SUMMARY
AC.IIR:					; I/O ERROR ON INPUT DEVICE
	IF #KY.NIP SET.IN $FLAG1
		$CALL GETDVO
	ELSE
		$CALL GETDVI			; INPUT DEVICE NAME
	END
	GOTO GETIOR

AC.WXB:					; WRITING INDEX FILE BITMAP
AC.RSM:					; READING STORAGE MAP
AC.WSM:					; WRITING STORAGE MAP
	$CALL GETDVO			; OUTPUT DEVICE NAME

AC.DIR:					; DIRECTIVE ERROR
GETIOR:					; GENERAL I/O MESSAGE
	IFB (R4) GE #0 THEN LET R4 := R0 ; FIND STATUS BLOCK AT FAULT
	IFB 1(R4) GE #0 THEN LET 1(R4) :B= #0 ; CLEAN OUT FUNNY STATUS
	LET R0 := #$IOE			; POINT TO ERROR CODE TABLE
	THRU R1 := #$IOEL
	  IF (R4) EQ (R0)+ LEAVE LOOP	; SEARCH THE TABLE
	END LOOP			; IF NONE FOUND, USE LAST MESSAGE
	LET (R5)+ := $IOSL-$IOE-2(R0)	; MESSAGE BYTE COUNT
	LET (R5)+ := $IOS-$IOE-2(R0)	; MESSAGE ADDRESS
	LET (R5)+ :B= (R4)+  ; STORE ERROR CODE
	LET (R5)+ :B= (R4)
	RETURN


	.SBTTL CREATE MSG. IMAGE ROUTINE

;
MV.UDE:
MV.DEV:
MV.F11:
MV.BSY:
MV.BCT:
MV.BRG:
MV.OBO:
MV.TFU:
MV.NLV:
MV.IFM:
MV.NDS:
MV.NFI:
MV.LEV:
MV.RVN:
MV.TMI:
MV.TFI:
MV.FNU:
MV.DEL:
MV.FLV:
MV.FNO:
MV.HCK:
MV.ESQ:
MV.ESN:
MV.VFY:
MV.RSC:
MV.SMH:
MV.FSY:
MV.NBO:
MV.DGP:
MV.DEX:
MV.BOT:
MV.WRV:
	LET (R5)+ :B= #'%
	LET (R5)+ :B= #'N
	LET (R5) :B= #0
	RETURN
MV.VER:
MV.OFN:
MV.MPO:
	LET R3 := #FORM2 + #3
	THRU R4 := #7
		LET (R5)+ :B= (R3)+
	END LOOP
	LET (R5) :B= #0
	RETURN
MV.DFU:
MV.HFU:
MV.RXD:
MV.RSY:
MV.NNX:
MV.NXT:
MV.PH1:
	LET R3 := #FORM2
	THRU R4 := #10.
		LET (R5)+ :B= (R3)+
	END LOOP
	LET (R5) :B= #0
	RETURN
MV.RAT:
MV.RHT:
MV.WHD:
	LET R3 :=  #FORM2
	THRU R4 := #16.
		LET (R5)+ :B= (R3)+
	END LOOP
	GOTO RSUX
MV.RDY:
MV.WLK:
MV.BDA:
MV.VBN:
MV.NDA:
MV.FID:
	LET (R5) :B= #0
	RETURN
MV.CDV:
MV.MXT:
MV.ILS:
MV.LAB:
MV.SYN:
MV.DUD:
MV.TMD:
MV.ILU:
MV.VEC:
MV.CSR:
MV.TM2:
	LET R3 := #FORM2 + #10
	THRU R4 := #8.
		LET (R5)+ :B= (R3)+
	END LOOP
	RETURN

MV.NHO:
MV.AHM:
MV.ALF:
MV.DNS:
MV.BBD:
MV.BFU:
MV.NBD:
MV.FNF:
MV.TID:
MV.ITP:
MV.IVT:
	LET R3 := #FORM1
	THRU R4 := #6
		LET (R5)+ :B= (R3)+
	END LOOP
	LET (R5)+ :B= #'%
	LET (R5)+ :B= #'N
	LET (R5) :B= #0
	RETURN
MV.RHD:
	LET R3 := #FORM2 + #3
	THRU R4 := #13.
		LET (R5)+ :B= (R3)+
	END LOOP
	GOTO RSUX
MV.IXB:
MV.IXH:
MV.RHO:
MV.SMB:
MV.IIR:
MV.WXB:
MV.RSM:
MV.WSM:
MV.ILB:
MV.RID:
MV.RSU:
	LET R3 := #STDMSG + #10.
	LET (R3) :B= -(R5)
	LET R3 := #STDMSG
	THRU R4 := #15.
		LET (R5)+ :B= (R3)+
	END LOOP
	LET R3 := #FORM1
	THRU R4 := #6
		LET (R5)+ :B= (R3)+
	END LOOP
	$CALL MV.CDV

RSUX:	TSTB -(R5) 
MV.DIR:
MV.RDA:
	LET R3 := #FORM2 + #6
	THRU R4 := #4
	   LET (R5)+ :B= (R3)+
	END LOOP
	LET (R5) :B= #0		; STORE NULL
	RETURN

.END
