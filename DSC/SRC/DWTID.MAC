	$BEGIN	DWTID,0009,<WRITE INDEX FILE DATA>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  3-AUG-78  16:34
;
; ANDREW C. GOLDSTEIN  18-OCT-1979  10:20
; ACG0075 - ADD PACK SERIAL NUMBER TO HOME BLOCK
;
; GR01---G.RITTENBURG 23-OCT-1978
; CONDITIONALIZED FOR 11M
;
; **GR02---G.RITTENBURG 25-OCT-1978
; ABILITY TO CHANGE O.P. DISK ID ADDED
;
; ACG0014 - ANDREW C. GOLDSTEIN - 9-FEB-1979
; CORRECTION TO ABOVE EDIT
;
	.IF NDF,R$$NVX
	.MCALL	FHDL2$,HMBL2$
	FHDL2$				; DEFINE FILE HEADER OFFSETS
	HMBL2$				; DEFINE HOME BLOCK OFFSETS
	.ENDC

;+
;
; *** - $DWTID	WRITE INDEX FILE DATA
;
; THIS ROUTINE WRITES THE INITIAL DATA INTO THE INDEX FILE. ON ITS
; FIRST CALL, IT COPIES THE BOOT AND HOME BLOCKS INTO THE INDEX FILE.
; ON SUBSEQUENT CALLS, IT CREATES DELETED FILE HEADERS FOR THE LISTED
; FILE ID'S.
;
; INPUTS:
;
;	INDEX FILE DATA IN $BUF2
;	OUTPUT LUN ASSIGNED TO DISK
;	$OUDEV POINTS TO DEVICE TABLE ENTRY
;
; OUTPUTS:
;
;	INDEX FILE DATA WRITTEN
;	R2,R3 PRESERVED, OTHER REGISTERS CLOBBERED
;-

$DWTID::
	PUSH R2,R3			; SAVE "VBN"
	IF R2 NE #0 OR R3 NE #1		; IF NOT THE FIRST CALL
	  JUMPTO TST1CL
	END
;
; $BUF2 CONTAINS THE BOOT BLOCK AND THE HOME BLOCK IN THAT ORDER.
;
	LET $BOLBN := $B2DAT+6		; SAVE BOOT FILE LBN
	LET $BOLBN+2 := $B2DAT+4
	LET B.SIZ+P.CNT(R4) := #512.	; SET COUNT TO 1 BLOCK
	$CALL $DWTDA <,,,,#$B2HD>	; WRITE BOOT BLOCK
	$CALL $BUFCK <,,,,#$B2HD>	; WAIT FOR TRANSFER COMPLETION.
;
; COPY THE HOME BLOCK TO THE BEGINNING OF THE BUFFER
;
	LET R1 := #$BUF2
	LET R2 := #$B2DAT+512.
	THRU R0 := #256.
	  LET (R1)+ := (R2)+
	END LOOP
	LET R0 := $OUDEV		; GET DEVICE TABLE ENTRY
	LET R5 := #$BUF2
	LET H.HBVB(R5) := #2		; FIRST HOME BLOCK VBN
	LET H.AHLB(R5) := $HM2LB	; SET ALTERNATE HOME BLOCK LBN.
	LET H.AHLB+2(R5) := $HM2LB+2
	LET H.IHLB(R5) := $IXHD2+4	; SET BACKUP IDX HDR LBN.
	LET H.IHLB+2(R5) := $IXHD2+6
	LET R1 := V.CLF(R0)		; GET CLUSTER FACTOR
	ASL R1				; *2
	LET R1 := R1 + #1 + $HM2LB - $HOME2+4 ; COMPUTE ALT HOME BLOCK VBN
	LET H.AHVB(R5) := R1		; AND STORE IN HOME BLOCK
	LET H.IBLB(R5) := V.IBLB(R0)	; SET UP NEW INDEX FILE LBN.
	LET H.IBLB+2(R5) := V.IBLB+2(R0)
	LET R0 := #$OLAB		; POINT AT O.P. FILENAME
	IFB (R0) NE #0			; IF O.P. FILENAME SPEC'D,
	  LET R1 := R5 + #H.INDN	; ALTER O.P. VOLUME ID
	  THRU R2 := #12.
	    LET (R1)+ :B= (R0)+		; COPY NEW VOL. NAME
	  END LOOP
	END
;
; COPY IN THE SERIAL NUMBER OF THIS DISK
;
	LET H.SRLN(R5) := $SERLN
	LET H.SRLN+2(R5) := $SERLN+2
;
; FILL OUT THE BOOT BLOCK CLUSTER WITH HOME BLOCKS.
;
	LET R0 := $OUDEV
	LET R1 := V.CLF(R0) - #1	; CLUSTER SIZE MINUS BOOT BLOCK
	IF RESULT IS GT
	  LET H.HBLB(R5) := $BOOTB+4 + #01 ; INIT BLOCK LBN
	  LET H.HBLB+2(R5) := $BOOTB+6 + CARRY
	  THRU R1
	    $CALL WHMBLK		; WRITE ONE HOME BLOCK.
	  END
	END
;
; WRITE THE HOME BLOCK CLUSTER, WHICH COULD BE EITHER THE REAL ONE OR
; DUMMIES.
;
	LET H.HBLB(R5) := $HOME1+4
	LET H.HBLB+2(R5) := $HOME1+6
	LET R0 := $OUDEV
	LET R1 := V.CLF(R0)
	THRU R1
	  $CALL WHMBLK			; WRITE ONE HOME BLOCK.
	END
;
; FILL OUT THE BACKUP HOME BLOCK CLUSTER.
;
	LET H.HBLB(R5) := $HOME2+4	; SET LBN FROM ALLOC TABLE.
	LET H.HBLB+2(R5) := $HOME2+6
	LET R0 := $OUDEV
	LET R1 := V.CLF(R0)
	THRU R1
	  $CALL WHMBLK			; WRITE ONE HOME BLOCK.
	END
;
; NOW INITIALIZE THE INDEX FILE BITMAP
;
	$CALL INIXBM			; INIT INDEX FILE BITMAP.
	POP R3,R2
	RETURN NOERROR
TST1CL:	

;
; TO HERE FOR SUBSEQUENT CALLS. $BUF2 CONTAINS A LIST OF INACTIVE
; FILE HEADERS WITH THEIR FILE SEQUENCE NUMBERS. FOR EACH ONE,
; CONSTRUCT A DELETED FILE HEADER AND WRITE IT.
;
	$CALL $BUFCK <,,,,#$B1HD>	; USE BUF1
	LET B.STAT(R4) := #1		; MARK BUSY
	LET R0 := #$BUF1
	LET R5 := R0
	LET R1 := #$OXBF		; POINT TO INDEX FILE HEADER
	THRU R2 := #256.		; AS A PROTOTYPE HEADER
	  LET (R0)+ := (R1)+		; COPY IT IN
	END LOOP
	LET R0 := #$B2DAT		; POINT TO DATA
	REPEAT				; LOOP FOR ALL ENTRIES
	  LET H.FNUM(R5) := (R0)+	; GET FILE NUMBER
	  IF RESULT IS EQ LEAVE LOOP	; ZERO MEANS NO MORE
	  TST (R0)+			; 2ND WORD IS DUMMY
	  LET H.FSEQ(R5) := (R0)+	; GET FILE SEQ NUMBER
	  PUSH R0			; SAVE POINTER
	  $CALL $DLHDR <,,,,R4,R5>	; WRITE DELETED HEADER
	  POP R0
	UNTIL R0 HI #$B2DAT+2048.-6
	LET $B1HD+B.STAT := #0		; RELEASE THE BUFFERS
	LET $B2HD+B.STAT := #0
	POP R3,R2
	RETURN



;
; SUBROUTINE TO WRITE ONE HOME BLOCK.
;
WHMBLK:
	PUSH  	R1
	$CALL	$CKSM1  <,#H.CHK1/2,,,,R5>  ; COMPUTE NEW CHECKSUMS.
	$CALL	$CKSUM  <,,,,,R5>
	$CALL	$WRI1B  <,,H.HBLB+2(R5),H.HBLB(R5),#$B2HD>
	$CALL	$BUFCK	<,,,,R4>
	INC	H.HBVB(R5)		; INC VBN IN HOME BLOCK.
	ADD	#1,H.HBLB(R5)		; INC LBN IN HOME BLOCK.
	ADC	H.HBLB+2(R5)
	POP  	R1
	RETURN
;
; SUBROUTINE TO INITIALIZE THE INDEX FILE BITMAP.
;
INIXBM:
	LET R0 := #$BUF2
	THRU R1 := #256.
	  LET (R0)+ := #0		; ZERO OUT THE BUFFER
	END LOOP
	LET R0 := $OUDEV
	LET R3 := V.IBLB(R0)		; GET INDEX BITMAP LBN
	LET R2 := V.IBLB+2(R0)
	PUSH V.IBSZ(R0)			; GET BLOCK COUNT
	LET $BUF2 := #7			; TURN ON BITS FOR FIRST 3 FILES
	FOR (SP) := (SP) DOWNTO #0
	  $CALL $WRI1B <,,R2,R3,#$B2HD> ; WRITE THE BLOCK
	  $CALL $WAITO <,,,,R4>
	  ON.ERROR THEN ERROR ER.WXB
	  LET R3 := R3 + #01		; BUMP LBN
	  LET R2 := R2 + CARRY
	  LET $BUF2 := #0		; CLEAR FIRST WORD FOR NEXT TIME
	END LOOP
	TST (SP)+			; CLEAN THE STACK
	LET $B2HD+B.STAT := #0		; RELEASE THE BUFFER
	RETURN

	.END
