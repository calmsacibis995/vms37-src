	$BEGIN	DSCBD,0025,<DSC BAD BLOCK PROCESSING>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
; ANDREW C. GOLDSTEIN  24-MAR-1980  14:10
; ACG0163 - SUPPRESS DATA NOT FOUND MESSAGE IF AT LEAST FACTORY DATA FOUND
;
; ANDREW C. GOLDSTEIN  29-FEB-1980  16:46
; ACG0151 - FIX HANDLING OF BLOCKING FACTOR
;
; ANDREW C. GOLDSTEIN  17-OCT-1979  13:40
; ACG0052 - CHANGE IN DISK CHARACTERISTICS FORMAT; REDESIGN BAD BLOCK
; 	    PROCESSING TO ALWAYS CHECK FOR DEC-144 DATA

	.SBTTL	IMPURE DATA

;
; WORDS USED BY MANUAL BAD BLOCK INPUT
;
BLOCK:	.BLKW	2			; LBN OF BAD AREA
COUNT:	.BLKW	2			; COUNT OF BLOCKS
FLAGS:	.BLKW	1			; FLAGS WORD, CONTAINING:
	BA.END = 1			; EXIT FLAG



	.SBTTL	PURE DATA

;
; PROMPT STRING TO ASK FOR MANUAL BAD BLOCK DATA
;
PROMPT:	.ASCII	"DSC2> LBN(S)="
PROMPL = .-PROMPT


	.EVEN

	.SBTTL	MAIN BAD BLOCK ROUTINE

;+
;
; *** - $DSCBD	DSC BAD BLOCK PROCESSING
;
; THIS ROUTINE CONSTRUCTS THE INTERNAL BAD BLOCK TABLE FROM THE
; BAD BLOCK MAP ON THE OUTPUT DISK.
;
; INPUTS:
;
;	OUTLUN ASSIGNED TO DISK
;	$OUDEV POINTING TO DEVICE TABLE ENTRY
;
; OUTPUTS:
;
;	BAD BLOCK MAP IN $BADBK
;
;-

$DSCBD::
	LET $BADP := #$BADBK		; INIT BAD BLOCK POINTER
	IF $CW2 NE #0 OR $CW3 HI #4096.	; NO BAD BLOCK PROC ON SMALL DISKS
	  $CALL AUTO			; DO NORMAL AUTOMATIC PROCESSING
	END
	IF #KY.MAN SET.IN $OFLAG
	  $CALL MANUAL			; DO MANUAL BAD BLOCK PROCESSING
	END
;
; IF THE LAST CLUSTER OF THE VOLUME IS PARTIALLY OFF THE END
; OF THE TRUE VOLUME, DUE TO ROUND UP, MARK IT BAD.
;
	LET R2 := $VOLSZ - #1		; GET LAST LBN OF VOLUME,
	LET R1 := $VOLSZ+2 - CARRY	; ROUNDED UP TO NEXT CLUSTER
	DCOMP R1,R2 $CW2,$CW3		; COMPARE TO TRUE SIZE
	IF RESULT IS HIS
	  $CALL MAKBAD <,R1,R2,#1>	; MARK ONE CLUSTER BAD
	END
	RETURN

	.SBTTL	DEC-STD-144 BAD BLOCK HANDLING

;
; THIS ROUTINE SEARCHES THE LAST TRACK OF THE VOLUME FOR DEC-STD-144 BAD
; BLOCK DATA. SAID DATA IS RECOGNIZED BY THE PRESENCE OF TWO WORDS OF -1
; AT THE END OF THE BLOCK, AND THAT TWO BLOCKS READ CORRECTLY AND MATCH.
;

FOUND:	.BLKW	1			; DATA FOUND FLAG
UBDATA:	.BLKW	1			; # OF SOFTWARE BAD BLOCKS ON TRACK
FIRST:	.BLKW	1			; FIRST BLOCK READ FLAG
;
; FIRST, MARK THE LAST TRACK OF THE DISK BAD
;
AUTO:	
	LET FOUND := #0			; SHOW NOTHING FOUND
	LET $SERLN := #0		; ASSUME SERIAL NUMBER NOT AVAILABLE
	LET $SERLN+2 := #0
	$CALL $DIV <$SECT,$BFACT>	; COMPUTE TRACK SIZE IN BLOCKS
	LET R2 := $CW2			; GET VOLUME SIZE
	LET R3 := $CW3
	LET UBDATA := R0 - #10.
	PUSH R2,R3			; SAVE VOLUME SIZE
	LET R3 := R3 - R0		; BACK UP TO START OF LAST TRACK
	LET R2 := R2 - CARRY
	LET R4 := R0 - #1		; NO. SCTRS TO MAKE BAD MINUS 1
	PUSH	R2,R3			;SAVE LBN BEGIN LAST TRACK
	$CALL MAKBAD <,R2,R3,R4>
	POP R3,R2			; RECOVER START OF LAST TRACK
	IF #KY.NAU SET.IN $OFLAG THEN JUMPTO ENDBAD
LOOP:					; LOOP FOR FACTORY & USER DATA
	LET FIRST := #1			; MARK TRYING FOR FIRST BLOCK
	BEGIN FIND
	  REPEAT
	    $CALL $RDWLN <#OUTLUN,,R2,R3,#$B1HD> ; READ A BLOCK
	    ON.NOERROR
	      IF FIRST NE #0		; IF FIRST BLOCK READ
		IF 252.(R5) EQ #-1 AND 254.(R5) EQ #-1 ; LOOK FOR -1 AT END
		  LET FIRST := #0	; FOUND THE FIRST ONE
		  LET R0 := R5 + #512.
		  THRU R1 := #256.	; COPY BLOCK TO UPPER BUFFER
		    LET (R0)+ := (R5)+
		  END LOOP
		END
	      ELSE			; IF SECOND BLOCK READ
		LET R0 := R5
		LET R1 := R5 + #512.
		BEGIN CMP
		  THRU R4 := #256.	; COMPARE FIRST AND 2ND BLOCKS
		    IF (R0)+ NE (R1)+ LEAVE CMP
		  END LOOP
		  LEAVE FIND		; FOUND GOOD DATA
		END CMP
	      END
	    ELSE
	      IFB (R4) NE #IE.VER
		LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
		ERROR  ER.IOR		; SEND ERROR MESSAGE
	      END
	    END
	    LET $B1HD+B.STAT := #0	; DISCARD THE BUFFER FOR RETRY
	    LET R3 := R3 + #2		; TRY THE NEXT SECTOR
	    LET R2 := R2 + CARRY
	    DCOMP R2,R3, 2(SP),(SP)	; UNTIL WHOLE TRACK HAS BEEN TRIED
	    IF RESULT IS HIS LEAVE LOOP
	  END LOOP
	  IF FOUND NE #0 GOTO ENDBAD
	  CMP (SP)+,(SP)+		; CLEAN THE STACK
	  JUMPTO SOFTB			; NO -144 DATA - TRY FOR OLD FORMAT
	END FIND
;
; NOW ENTER EACH BAD CLUSTER INTO THE BAD BLOCK LIST.
;
	LET FOUND := #1			; SHOW DATA FOUND
	PUSH R2,R3			; SAVE CURRENT BLOCK NUMBER
	LET R4 := R5 + #6		; POINT TO BAD BLOCK DATA
	IF (R4)+ EQ #-1 THEN ERROR ER.DGP ; NON-ZERO MEANS DO NOT USE
	REPEAT
	  LET R0 := (R4)+		; GET NEXT CYLINDER NUMBER
	  IF R0 EQ #-1 LEAVE LOOP	; -1 IS END OF DATA
	  LET R0 := R0 OFF.BY #100000	; MASK OFF FLAG BIT
	  $CALL $MUL <R0,$TRAK>		; COMPUTE NUMBER OF TRACKS
	  LET -(SP) := (R4)+		; GET TRACK AND SECTOR
	  LET R3 := (SP)
	  SWAB R3
	  LET R3 := R3 OFF.BY #^C177	; ISOLATE TRACK
	  LET (SP) := (SP) OFF.BY #^C377 ; ISOLATE SECTOR
	  LET R3 := R3 + R1		; ADD IN TRACK NUMBER
	  LET R2 := R0 + CARRY
	  $CALL $DMUL <$SECT,,R2,R3>	; COMPUTE NUMBER OF SECTORS
	  LET R2 := R1 + (SP)+		;COMPUTE LBN
	  LET R1  := R0 + CARRY
	  $CALL $DDIV <$BFACT,R1,R2>	; DIVIDE DOWN BY BLOCKING FACTOR
	  $CALL MAKBAD <,R1,R2,#0>	; MARK 1 SECTOR BAD
	  ON.ERROR THEN ERRP ER.BBD	; BAD DATA IN DESCRIPTOR
	UNTIL R4 HIS #$BUF1+512.	; LOOP UNTIL END OF BUFFER
	LET $B1HD+B.STAT := #0
	LET R3 := $CW3 - (SP)+		; SEE HOW FAR WE WERE FOM THE END
	LET R2 := $CW2 - CARRY - (SP)+
	IF R2 EQ #0 AND R3 LE UBDATA GOTO ENDBAD ; OUT IF USER DATA ALREADY SEEN
	LET $SERLN := $BUF1		; SAVE AWAY PACK SERIAL NUMBER
	LET $SERLN+2 := $BUF1+2
	LET R3 := $CW3 - UBDATA		; POINT TO FIRST BLOCK OF USER DATA
	LET R2 := $CW2 - CARRY
	JUMPTO LOOP
ENDBAD:	CMP (SP)+,(SP)+			; CLEAN THE STACK
	RETURN

	.SBTTL	HANDLE OLD STYLE "BAD" DATA

;
; THIS ROUTINE READS THE BAD BLOCK DESCRIPTOR FROM THE END OF THE
; VOLUME, VERIFIES IT, AND FORMATS THE DATA INTO THE ALLOCATION MAP.
;
; FIRST SEARCH FROM THE BACK OF THE VOLUME FOR THE DESCRIPTOR.
;

SOFTB:	
	BEGIN AUTOB
	  LET R2 := $CW2		; GET END OF VOLUME
	  LET R3 := $CW3
	  BEGIN FIND
	    PUSH #32.
	    FOR (SP) := (SP) DOWNTO #0
	      LET R3 := R3 - #01	; BACK UP ONE BLOCK
	      LET R2 := R2 - CARRY
	      $CALL $RDWLN <#OUTLUN,,R2,R3,#$B1HD> ; READ A BLOCK
	      ON.NOERROR
		$CALL $CKSUM		; CHECK THE CHECKSUM
		ON.NOERROR
		  LET R4 := R5
		  IF (R4)+ EQ #1401 LEAVE FIND ; CHECK FOR FORMAT WORD
		END
	      ELSE			; LOOP ONLY ON PARITY ERROR
		IFB (R4) NE #IE.VER
		  LET $FLAG1 := $FLAG1 SET.BY #KY.NIP
		  ERROR  ER.IOR		; SEND ERROR MESSAGE
		END
	      END
	      LET $B1HD+B.STAT := #0	; DISCARD THE BUFFER FOR RETRY
	    END LOOP
	    ERRP ER.NBD			; BAD BLOCK DATA NOT FOUND
	    LEAVE AUTOB
	  END FIND
	  TST (SP)+			; CLEAN THE STACK
;
; BAD BLOCK DESCRIPTOR IS FOUND. FIRST MAKE AN ENTRY FOR THE
; DESCRIPTOR ITSELF.
;
	  $CALL MAKBAD <,R2,R3,#0>
;
; NOW ENTER EACH BAD CLUSTER INTO THE BAD BLOCK LIST.
;
	  PUSH (R4)+			; PUT COUNT ON STACK
	  LET 1(SP) :B= #0
	  LET (SP) := (SP) R.SHIFT 1
	  IF RESULT IS NE		; IF MAP IS NOT EMPTY

	    FOR (SP) := (SP) DOWNTO #0
	      LET R1 := #0
	      LET R1 :B= R1 SET.BY (R4)+ ; HIGH ORDER LBN
	      LET R3 := #0
	      LET R3 :B= R3 SET.BY (R4)+ ; GET COUNT FIELD
	      LET R2 := (R4)+		; LOW ORDER LBN
	      $CALL MAKBAD <,R1,R2,R3>	; ENTER CLUSTER IN BAD BLOCK LIST
	      ON.ERROR THEN ERRP ER.BBD	; BAD DATA IN DESCRIPTOR
	    END LOOP
	  END
	END AUTOB
	TST (SP)+			; CLEAN COUNT OFF STACK
	RETURN

	.SBTTL	MANUAL BAD BLOCK ENTRY

;
; THIS ROUTINE ACCEPTS BAD BLOCK DATA TYPED IN BY THE USER
; AFTER THE MANUAL OPTION HAS BEEN SPECIFIED IN THE COMMAND LINE.
;
; IT PROMPTS WITH THE STRING "DSC> BAD=". THE REPLY IS IN THE
; FORM "NNNN,MMMM", WHERE NNNN IS THE STARTING LBN OF THE BAD AREA
; AND MMMM IS AN OPTIONAL COUNT. IF THE COUNT IS NOT PRESENT IT
; IS ASSUMED TO BE 1. THIS ROUTINE WILL LOOP AND PROMPT FOR
; ADDITIONAL DATA UNTIL TERMINATED BY A NULL LINE.
;

MANUAL:	
	PUSH GCLFLG			; SAVE MCR FLAG AND
	LET GCLFLG := #0		; CLEAR IT TO FORCE INPUT
	REPEAT
	  $CALL .GTCML <,,,#PROMPL,#PROMPT> ; GET INPUT LINE
	  $CALL .TPARS <,#1,#BKYTB,R3,R4,#BSTRT> ; PARSE IT
	  ON.ERROR
	    ERRP ER.BSY			; SYNTAX ERROR
	  ELSE
	    IF #BA.END SET.IN FLAGS LEAVE LOOP
	    IF COUNT+2 NE #0
	      ERRP ER.BCT		; COUNT MUST BE ONE WORD
	    ELSE
	      LET R3 := COUNT - #1
	      $CALL MAKBAD <,BLOCK+2,BLOCK,R3>
	      ON.ERROR THEN ERRP ER.BRG	; BLOCK OUT OF RANGE
	    END
	  END
	END <REPEAT LOOP>
	POP GCLFLG			; RESTORE MCR FLAG
	RETURN

	.SBTTL	BAD BLOCK LIST SUBROUTINE

;+
;
; THIS ROUTINE ENTERS THE DISK CLUSTERS CONTAINING THE INDICATED
; BLOCKS INTO THE BAD BLOCK LIST. IF ALL OR PART OF THE BLOCKS
; INDICATED ARE REDUNDANT, THEY ARE MERGED INTO THE APPROPRIATE
; CLUSTER.
;
; INPUTS:
;
;	R1 = HIGH ORDER STARTING LBN
;	R2 = LOW ORDER STARTING LBN
;	R3 = BLOCK COUNT - 1
;
; R4 IS PRESERVED
;
;-

MAKBAD:	
	LET R5 := $BADP			; GET BAD BLOCK TABLE POINTER
	PUSH R1,R2			; SAVE LBN
	LET R2 := R2 + R3		; COMPUTE LBN PLUS COUNT
	LET R1 := R1 + CARRY
	$CALL $DDIV <$CLF,R1,R2>	; COMPUTE UPPER CLUSTER BOUNDARY
	LET R3 := R2 + #01		; INCLUDE WHOLE CLUSTER
	LET R2 := R1 + CARRY
	$CALL $DMUL <$CLF,,R2,R3>	; CONVERT BACK TO LBN
	LET (R5)+ := R1			; STORE IN NEW TABLE ENTRY
	LET (R5)+ := R0
	POP R2,R1			; GET BACK STARTING LBN
	$CALL $DDIV <$CLF,R1,R2>	; COMPUTE LOW CLUSTER BOUNDARY
	LET R3 := R2
	LET R2 := R1
	$CALL $DMUL <$CLF,,R2,R3>	; AND CONVERT BACK TO LBN
	LET (R5)+ := R1			; STORE STARTING LBN
	LET (R5)+ := R0
	LET R5 := R5 - #8.		; BACK UP POINTER
	DCOMP 2(R5),(R5), $VOLSZ+2,$VOLSZ ; CHECK IF WITHIN VOLUME
	IF RESULT IS HI THEN RETURN ERROR ; BLOCKS OUT OF BOUNDS
;
; NOW SEARCH THE BAD BLOCK MAP FOR AN AREA THAT OVERLAPS OR IS
; ADJACENT TO THE NEW AREA. IF ONE IS FOUND, MERGE THEM.
;
	BEGIN TEST
	  LET R3 := #$BADBK
	  REPEAT
	    IF R3 HIS $BADP LEAVE LOOP	; STOP AT END OF TABLE
	    LET R1 := (R3)+		; GET COUNT
	    LET R0 := (R3)+
	    BEGIN MERGE
	      PUSH 2(R3),(R3)		; MAKE TWO COPIES OF LBN
	      PUSH 2(R3),(R3)
	      LET (SP) := (SP) + R1	; ADD COUNT TO COMPUTE
	      LET 2(SP) := 2(SP) + CARRY + R0 ; END LBN

	      DCOMP 2(R3),(R3), 6(R5),4(R5) ; COMPARE START LBN'S
	      IF RESULT IS LO
		DCOMP 2(SP),(SP), 6(R5),4(R5) ; COMPARE END TO START
		IF RESULT IS LO LEAVE MERGE ; NO OVERLAP
		IF RESULT IS HI GOTO TESTE ; OVERLAP
		GOTO USE2		; ADJACENT
	      END
	      IF RESULT IS HI		; (FROM FIRST COMPARE)
		LET 4(SP) := 4(R5)	; CONSIDER USING START
		LET 6(SP) := 6(R5)	; OF NEW AREA
		DCOMP 2(R3),(R3), 2(R5),(R5) ; COMPARE START TO END
		IF RESULT IS HI LEAVE MERGE ; NO OVERLAP
		IF RESULT IS LO GOTO TESTE ; OVERLAP
	      ELSE			; FIRST COMPARE WAS EQUAL
TESTE:		DCOMP 2(SP),(SP), 2(R5),(R5) ; COMPARE END TO END
		IF RESULT IS LO
USE2:		  LET (SP) := (R5)	; USE END OF NEW REGION
		  LET 2(SP) := 2(R5)
		END
	      END
;
; IF WE MAKE IT TO HERE WE HAVE FOUND AN OLD AREA THAT OVERLAPS
; OR IS ADJACENT TO THE NEW ONE. THE STACK CONTAINS END LBN,
; FOLLOWED BY START LBN, OF THE MERGED AREA.
;
	      CMP -(R3),-(R3)		; BACK UP TO START OF POINTER
	      LET (SP) := (SP) - 4(SP)	; COMPUTE COUNT FROM
	      LET 2(SP) := 2(SP) - CARRY - 6(SP) ; LBN'S
	      LET (R3)+ := POP		; AND FILL IN OLD POINTER
	      LET (R3)+ := POP		; WITH NEW DATA
	      LET (R3)+ := POP
	      LET (R3)+ := POP
	      LEAVE TEST		; END OF PROCEDURE
	    END MERGE

	    LET SP := SP + #8.		; END OF THIS TEST - CLEAN STACK
	    CMP (R3)+,(R3)+		; BUMP TO NEXT TABLE ENTRY
	  END <REPEAT LOOP>		; AND LOOP THRU TABLE
;
; THE ENTIRE TABLE HAS BEEN SEARCHED AND NO OVERLAPS HAVE BEEN
; FOUND. CONVERT THE NEW ENTRY INTO THE STANDARD COUNT, LBN FORMAT
; AND BUMP THE END OF TABLE POINTER.
;
	  IF R5 HIS #$BADND THEN ERROR ER.BFU ; TABLE FULL
	  LET (R5) := (R5) - 4(R5)
	  LET 2(R5) := 2(R5) - CARRY - 6(R5)
	  LET $BADP := R5 + #8.
	END TEST
	RETURN

	.SBTTL	STATE TABLE TO PARSE MANUAL BAD BLOCK DATA

	.MCALL	ISTAT$,STATE$,TRAN$

	ISTAT$	BSTB,BKYTB

	STATE$	BSTRT
	TRAN$	$EOS,$EXIT,,BA.END,FLAGS ; EXIT ON NULL LINE
	TRAN$	$BLANK,BSTRT
	TRAN$	$NUMBR,,SETN		; LBN

	STATE$
	TRAN$	$EOS,$EXIT		; EXIT ON NO COUNT
	TRAN$	$BLANK,BSTRT
	TRAN$	<',>,BSTRT
	TRAN$	<':>

	STATE$
	TRAN$	$NUMBR,,SETC		; COUNT

	STATE$
	TRAN$	$EOS,$EXIT
	TRAN$	$BLANK,BSTRT
	TRAN$	<',>,BSTRT

	STATE$

	.SBTTL	ACTION ROUTINES FOR MANUAL BAD BLOCK PARSE

;
; SET LBN
;
SETN:	LET BLOCK := .PNUMB
	LET BLOCK+2 := .PNUMH
	LET COUNT := #1
	LET COUNT+2 := #0
	LET FLAGS := #0
	RETURN
;
; SET COUNT
;
SETC:	LET COUNT := .PNUMB
	LET COUNT+2 := .PNUMH
	RETURN



	.END
