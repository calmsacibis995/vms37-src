	$BEGIN	DSCAL,0011,<ALLOCATE SYSTEM FILES ON DISK>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; ANDREW C. GOLDSTEIN  3-AUG-78  16:31

	.SBTTL	MAIN ALLOCATION ROUTINE

;+
;
; *** - $DSCAL	ALLOCATE SYSTEM FILES ON DISK
;
; THIS ROUTINE ALLOCATES SPACE ON THE VOLUME FOR EACH OF THE
; ELEMENTS OF THE INITIAL FILE-11 STRUCTURE. ALLOCATION IS DONE
; BY CHOOSING A CANDIDATE LOCATION AND THEN CHECKING THE ALLOCATION
; LIST FOR CONFLICTS. IF A CONFLICT EXISTS, A NEW LOCATION IS CHOSEN
; ACCORDING TO AN ALGORITHM SPECIFIC TO THE ITEM BEING ALLOCATED.
;
; ***** NOTE: THIS ROUTINE ASSUMES ORDERING AND ADJACENCY OF THE ITEMS
; ***** IN THE ALLOCATION TABLE (FROM $BOOTB TO $BADBK). CHANGES TO THIS
; ***** ROUTINE AND CHANGES TO THE TABLE MUST BE COORDINATED!
;
; INPUTS:
;
;	BAD BLOCK DATA IN ALLOCATION TABLE
;	VOLUME PARAMETERS FROM SUMMARY BLOCK
;
; OUTPUTS:
;
;	ALLOCATION DATA IN ALLOCATION TABLE
;	ENTRIES IN DEVICE TABLE ENTRY
;
;-

$DSCAL::
	LET R4 := #$BOOTB		; POINT TO START OF TABLE
;
; ALLOCATE THE FIRST AVAILABLE CLUSTER AS THE BOOT BLOCK. IF IT IS
; NOT ZERO, ISSUE A MESSAGE THAT THE VOLUME IS NOT BOOTABLE.
;
	LET (R4) := $CLF		; ALLOCATE 1 CLUSTER
	$CALL ALOC <,,,#0,R4>		; SCAN FORWARD
	CMP (R4)+,(R4)+			; SKIP COUNT
	LET R0 := (R4)+ SET.BY (R4)+	; CHECK FOR ZERO
	IF RESULT IS NE
	  LET $OFLAG := $OFLAG SET.BY #KY.NBO
	  ERRP ER.NBO			; ISSUE MESSAGE TO THAT EFFECT
	END
;
; ALLOCATE PRIMARY AND SECONDARY HOME BLOCK CLUSTERS. IF CLUSTER FACTOR
; IS GREATER THAN 1 AND THE BOOT BLOCK IS ON 0, THEN PRIMARY HOME BLOCK
; CLUSTER IS REALLY A DUMMY SINCE THE TRUE HOME BLOCK IS LBN 1.
;
	LET (R4) := $CLF
	IF (R4) HI #1 AND R0 EQ #0
	  $CALL ALOCNX <,,,#0,R4>	; ALLOCATE DUMMY CLUSTER
	ELSE
	  $CALL ALOCHM <,,,,R4>		; ALLOCATE REAL HOME BLOCK
	END

;
; ALLOCATE THE ALTERNATE HOME BLOCK.
;
	LET  R4  :=  #$HOME2
	LET  (R4)  :=  $CLF		; ALLOCATE ONE CLUSTER.
	$CALL  ALOCHM <,,,,R4>
;
; ALLOCATE THE BACKUP COPY OF THE INDEX FILE HEADER.
;
	LET  R4  :=  #$IXHD2
	LET  (R4)  :=  $CLF
	$CALL  ALOCNX <,,,#0,R4>
;
; ALLOCATE THE INITIAL INDEX FILE.
;
	LET R4 := R4 + #8.
	LET R0 := $CLF			; ROUND ALLOCATION SIZE
	LET R2 := R0 - #1		; UP TO NEXT CLUSTER
	LET R2 := R2 + $B2DAT+S.IFSZ	; GET INDEX FILE SIZE
	LET R1 := $B2DAT+S.IFSZ+2 + CARRY
	PUSH  $CLF			; CLUSTER FACTOR TO TEMP.
	ASL  (SP)			; MULTIPLY
	ASL  (SP)			;           BY 4.
	LET R2 := R2 - (SP)+		; LESS BOOT AND HOME BLOCKS AND
	LET R1 := R1 - CARRY		; BACKUP INDX FILE HDR CLUSTERS.
	$CALL $DDIV <R0,R1,R2>
	LET R3 := R2
	LET R2 := R1
	$CALL $DMUL <$CLF,,R2,R3>	; R0,R1 = ADJUSTED SIZE
	LET R5 := R4
	LET (R5)+ := R1
	LET (R5)+ := R0
	$CALL ALOCNX <,,,#0,R4>
;
; ALLOCATE STORAGE MAP FILE. IF INDEX FILE POSITION IS MIDDLE OR
; END, ALLOCATE BEFORE INDEX FILE.
;
	LET R4 := R4 + #8.
	$CALL $DDIV <$CLF,$VOLSZ+2,$VOLSZ> ; COMPUTE # CLUSTERS IN VOLUME
	LET R2 := R2 + #8191.		; ROUND UP AND ADD ONE BLOCK
	LET R1 := R1 + CARRY
	$CALL $DDIV <#4096.,R1,R2>	; COMPUTE NUMBER OF BLOCKS
	LET $SBMEF+2 := R2 + #1		; SAVE STORAGE BIT MAP EOF VBN.
	LET $SBMEF := R1 + CARRY
	LET R2 := R2 + $CLF - #1	; IN BITMAP FILE
	$CALL $DDIV <$CLF,R1,R2>	; COMPUTE NUMBER OF CLUSTERS
	LET R3 := R2
	LET R2 := R1
	$CALL $DMUL <$CLF,,R2,R3>	; R0,R1 = BLOCKS ROUNDED UP TO CLUSTER
	LET (R4) := R1
	LET 2(R4) := R0
	$CALL ALOCNX <,,,#0,R4>
	RETURN

	.SBTTL	GENERAL ALLOCATION ROUTINE

;+
;
; *** - ALOC	ALLOCATE SPACE
;
; *** - ALOCNX	ALLOCATE NEXT AVAILABLE SPACE
;
; THIS ROUTINE SEARCHES FOR FREE SPACE FOR THE DESIRED NUMBER OF
; BLOCKS. THE ENTRY "ALOC" STARTS THE SEARCH AT THE LBN GIVEN IN
; THE TABLE ENTRY; THE ENTRY "ALOCNX" STARTS THE SEARCH AT THE
; LBN OF THE PREVIOUSLY ALLOCATED ITEM. THE ROUTINE SEARCHES EITHER
; FORWARDS OR BACKWARDS, AS REQUESTED. THE RESULTING STARTING LBN
; IS LEFT IN THE INDICATED BLOCK POINTER.
;
; INPUTS:
;
;	R3 = 0 TO SEARCH FORWARD
;	  >< 0 TO SEARCH BACKWARDS
;	R4 = ADDRESS OF TABLE ENTRY TO PROCESS
;
; OUTPUTS:
;
;	TABLE ENTRY UPDATED, R4 SAVED
;	ALL OTHER REGISTERS ARE CLOBBERED
;
;-

ALOCNX:	
	LET 4(R4) := -4(R4)		; COPY LBN OF
	LET 6(R4) := -2(R4)		; OF PRECEDING ENTRY

ALOC:	
	PUSH R3				; SAVE DIRECTION FLAG
	REPEAT
	  $CALL CKALOC <,,,,R4>		; SEE IF THIS SPACE IS USED
	  ON.NOERROR LEAVE LOOP		; IF NOT, DONE
	  IF (SP) EQ #0			; SEARCH FORWARD
	    LET R3 := R4
	    CMP (R3)+,(R3)+
	    LET (R3) := (R5)+		; GET COUNT OF
	    LET 2(R3) := (R5)+		; CONFLICTING SEGMENT
	    ADD (R5)+,(R3)+		; AND COMPUTE END LBN
	    ADC (R3)
	    ADD (R5)+,(R3)
	    DCOMP (R3),-(R3), $VOLSZ+2,$VOLSZ
	    IF RESULT IS HI THEN ERROR ER.ALF	; OFF END OF VOLUME
	  ELSE				; OR SEARCH BACKWARD
	    LET R3 := R4
	    CMP (R3)+,(R3)+
	    CMP (R5)+,(R5)+
	    LET (R3) := (R5)+		; USE STARTING LBN
	    LET 2(R3) := (R5)+		; OF CONFLICTING SEGMENT
	    SUB (R4),(R3)+		; AND BACK UP BY DESIRED SIZE
	    SBC (R3)
	    IF RESULT IS CS THEN ERROR ER.ALF
	    SUB 2(R4),(R3)
	    IF RESULT IS CS THEN ERROR ER.ALF	; OFF START OF VOLUME
	  END
	END <REPEAT LOOP>
	TST (SP)+			; CLEAN THE STACK
	RETURN

	.SBTTL	HOME BLOCK ALLOCATION ROUTINE

;+
;
; *** - ALOCHM	ALLOCATE HOME BLOCK
;
; THIS ROUTINE ALLOCATES THE INDICATED TABLE ENTRY IN THE FIRST
; AVAILABLE CLUSTER IN THE HOME BLOCK SEARCH SEQUENCE. THE STARTING
; POINT FOR THE ALLOCATION SEARCH IS THE LBN OF THE PRECEDING
; ENTRY.
;
; INPUTS:
;
;	R4 = ADDRESS OF TABLE ENTRY TO PROCESS
;
; OUTPUTS:
;
;	UPDATED TABLE ENTRY
;	R4 PRESERVED, ALL OTHER REGISTERS CLOBBERED
;
;-

ALOCHM:	
	LET R2 := #1			; STARTING LBN OF SEQUENCE
	LET R1 := #0
	REPEAT
	  PUSH R1,R2			; SAVE LBN ON STACK
	  $CALL $DDIV <$CLF,R1,R2>	; TRUNCATE TO CLUSTER BOUNDARY
	  LET R3 := R2
	  LET R2 := R1
	  $CALL $DMUL <$CLF,,R2,R3>
	  LET 4(R4) := R1
	  LET 6(R4) := R0
	  $CALL CKALOC <,,,,R4>		; SEE IF THIS SPACE IS FREE
	  ON.NOERROR LEAVE LOOP		; IF SO, THEN DONE
	  PUSH R4
	  $CALL $WRI1B <,,4(SP),2(SP),#$B2HD> ; GARBAGE THE REJECTED HOME
	  $CALL $WAITO <,,,,R4>		;  BLOCK TO PREVENT ACCIDENTAL USE
	  POP R4
	  POP R2,R1			; GET BACK LBN
	  LET R2 := R2 + $HBDLT		; TRY NEXT LOCATION.
	  LET R1 := R1 + CARRY
	  LET R1 := R1 + $HBDLT+2
	  DCOMP R1,R2, $VOLSZ+2,$VOLSZ	; CHECK FOR END OF VOLUME
	  IF RESULT IS HIS THEN ERROR ER.AHM
	END <REPEAT LOOP>
	LET $HM2LB := (SP)+		; SAVE LBN OF HOME BLOCK, WHICH WILL
	LET $HM2LB+2 := (SP)+		; WILL BE THE SECONDARY WHEN THROUGH
	RETURN

	.SBTTL	ALLOCATION CHECK ROUTINE

;+
;
; *** - CKALOC	 CHECK ALLOCATION
;
; THIS ROUTINE CHECKS IF THE INDICATED SECTION OF THE DISK IS
; ALREADY ALLOCATED. IF SO, IT RETURNS A POINTER TO THE CONFLICTING
; SEGMENT.
;
; INPUTS:
;
;	R4 = ADDRESS OF SEGMENT TO BE CHECKED
;
; OUTPUTS:
;
;	C = 0 IF SEGMENT IS NOT ALLOCATED
;	 >< 0 IF SEGMENT IS ALLOCATED AND
;	R5 = ADDRESS OF CONFLICTING SEGMENT
;
;	R4 PRESERVED, ALL OTHER REGISTERS ALTERED
;
; EACH SEGMENT IS DESCRIBED BY A FOUR WORD BLOCK CONTAINING (IN ORDER)
; LOW AND HIGH ORDER COUNT AND LOW AND HIGH ORDER LBN.
;
;-

CKALOC:	
	FOR.ABS R5 := #$BOOTB TO $BADP BY #8.
	  IF R4 NE R5			; DON'T CHECK SEGMENT AGAINST ITSELF
	    LET R3 := R5
	    LET R1 := (R3)+		; GET BLOCK COUNT OF THIS SEG
	    LET R0 := (R3)+
	    LET R2 := R0 SET.BY R1
	    IF RESULT IS NE		; ZERO COUNT MEANS NON-EXISTENT
	      LET R1 := R1 + (R3)+	; COMPUTE END LBN
	      LET R0 := R0 + CARRY + (R3)+
	      DCOMP R0,R1, 6(R4),4(R4)	; COMPARE END TO BEGINNING
	      IF RESULT IS HI
		LET R3 := R4
		LET R1 := (R3)+		; GET COUNT OF CANDIDATE SEG
		LET R0 := (R3)+
		LET R1 := R1 + (R3)+	; TO COMPUTE END LBN
		LET R0 := R0 + CARRY + (R3)+
		DCOMP 6(R5),4(R5), R0,R1 ; COMPARE BEGINNING TO END
		IF RESULT IS LO THEN RETURN ERROR
	      END
	    END
	  END
	END LOOP
	RETURN NOERROR



	.END
