MODULE FASTSCAN	(%TITLE	'Fast file scan'
		IDENT = 'V03-003'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!	This module contains the fast file scan routines.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 19-Nov-1980
!
! MODIFIED BY:
!
!	V03-003	MLJ0087		Martin L. Jack,	08-Apr-1982  16:45
!		Do not truncate the index file for ODS-1 version 2 because it
!		cannot be re-extended to multi-header dynamically.  Fix setting
!		of DIR_STATUS.
!
!	V03-002	MLJ0083		Martin L. Jack,	22-Mar-1982  13:25
!		Inhibit saving of scanned but not selected directories under
!		/INTERCHANGE, to save space on distribution media.
!
!	V03-001	MLJ0082		Martin L. Jack,	16-Mar-1982  18:42
!		Initialize DIR_STATUS before index file scan to avoid incorrect
!		results from SELECT_INPUT_FILE.
!
!	V02-011	MLJ0078		Martin L. Jack,	10-Feb-1982  15:30
!		Correct error in exclusion of aliased files introduced by
!		V02-007.
!
!	V02-010	MLJ0077		Martin L. Jack,	8-Feb-1982  15:11
!		Implement negative version numbers.
!
!	V02-009	MLJ0075		Martin L. Jack,	28-Jan-1982  20:16
!		Implement DIR_VERLIM and VERLIMIT attributes to support version
!		limit handling.  Add FIB$V_NORECORD to file accesses to support
!		file expiration handling.
!
!	V02-008	MLJ0063		Martin L. Jack,	22-Dec-1981  4:20
!		Support rooted directories.
!
!	V02-007	MLJ0062		Martin L. Jack,	4-Dec-1981  14:33
!		Implement /INCREMENTAL.
!
!	V02-006	MLJ0054		Martin L. Jack,	15-Oct-1981  19:26
!		Support segmented directory records.  Combine routines
!		ODS1_VOLUME_ATTRIBUTES and ODS2_VOLUME_ATTRIBUTES.  Remove
!		COM_IMP_NOBACK, as this must be computed on every file.
!		Implement /VOLUME.  Implement /IGNORE=INTERLOCK.  Integrate
!		GET_VM and FREE_VM jacket routines.
!
!	V02-005	MLJ0037		Martin L. Jack,	29-Aug-1981  16:04
!		Correct file selection with /IMAGE.
!
!	V02-004	MLJ0036		Martin L. Jack,	28-Aug-1981  17:55
!		Reimplement file scan.
!
!	V02-003	MLJ0025		Martin L. Jack,	8-May-1981  11:25
!		Implement latest-version selection.  Make /RECORD restartable.
!
!	V02-002	MLJ0018		Martin L. Jack,	7-Apr-1981  21:08
!		Restore expanded string length in input NAM block.
!
!	V02-001	MLJ0010		Martin L. Jack,	25-Mar-1981  16:33
!		Reorganize global storage.  Reorganize so that index file
!		processing occurs on one volume at a time to minimize global
!		storage requirement.  Incorporate "slow" file scan into fast
!		file scan so that BACKUP, not RMS, maintains directory context.
!		Add attributes check on directories so that spurious
!		"illegal format" errors are not produced.
!
!**

switches nooptimize;
REQUIRE 'SRC$:COMMON';
LIBRARY 'SYS$LIBRARY:LIB';


FORWARD ROUTINE
	FAST_FILE_SCAN:	NOVALUE,	! Scan with index file
	SLOW_FILE_SCAN:	NOVALUE,	! Scan without index file
	READ_HOMEBLOCK:	NOVALUE,	! Read and check home block
	VERIFY_HEADER,			! Check a file header
	PROCESS_FILE:	NOVALUE,	! Process one file
	DIR_SCAN:	NOVALUE,	! Driver for directory scan
	INIT_DIR_SCAN:	NOVALUE,	! Initialize directory scan
	RESET_DIR_SPEC:	NOVALUE,	! Reset selection filespec
	FIND_NEXT,			! Scan for next matching file
	FREE_DIR_DATA:	NOVALUE;	! Free directory scan context


EXTERNAL ROUTINE
	LIB$EXTRACT_CONCEALED: ADDRESSING_MODE(GENERAL),
					! Parse concealed device/root directory
	CHECKSUM,			! Compute file header checksum
	CHECKSUM2,			! Compute home block checksum
	GEN_FID_RECORD:	NOVALUE,	! Write FID record
	INIT_NAMEBLOCK:	NOVALUE,	! Initialize extended name block fields
	VOLUME_ATTRIBUTES:		! Write volume attribute record
			NOVALUE,
	SAVE_ONE_FILE:	NOVALUE,	! Routine to copy one file
	FILE_ERROR:	NOVALUE,	! Signal file-related error
	INIT_ATTR:	NOVALUE,	! Initialize attributes area
	LEFT_ONE,			! Find leftmost one bit in a word
	MAKE_STRING,			! Convert ODS-1 filename to ASCII
	INIT_SEL_INFO:	NOVALUE,	! Initialize selection information
	MATCH_DIRECTORY,		! Match directory specification
	MATCH_FILENAME,			! Match file name, type, and version
	SELECT_INPUT_FILE,		! Select input file based on qualifiers
	TERMINATE_SCAN,			! Test termination of directory scan
	FREE_VM:	NOVALUE,	! Free virtual memory
	GET_VM,				! Get virtual memory
	GET_ZERO_VM,			! Get and zero virtual memory
	LIB$SIGNAL:	ADDRESSING_MODE(GENERAL);
					! Signal a condition


EXTERNAL LITERAL
	BACKUP$_MAXVOLS,
	BACKUP$_PROCINDEX,
	BACKUP$_OPENDIR,
	BACKUP$_OPENIN,
	BACKUP$_READDIR,
	BACKUP$_BADDIR,
	BACKUP$_NOSUCHRVN,
	LIB$_INVFILSPE;


G$DEFINE();			! Define global common area


LITERAL
	MAX_VOLUMES=	255,		! Largest volume set
	DIR_BUF_COUNT=	16,		! Size of directory buffer
	INDEX_BUF_COUNT=64;		! Size of index file buffer


BIND
	MFD=		UPLIT BYTE (%ASCIC '000000');


BUILTIN
	TESTBITCC,
	TESTBITSC,
	CALLG,
	ROT;

GLOBAL ROUTINE FAST_FILE_SCAN: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the driver for the fast file scan.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_FAB	- Pointer to current input FAB.
!	INPUT_NAM	- Pointer to current input NAM block.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	RVN,					! Relative volume number
	FIB:		BBLOCK[10],		! FIB
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	STATUS,					! Status variable
	IOSB:		VECTOR[4,WORD];		! I/O status block


! Initialize FIB descriptor.
!
FIB_DESC[0] = 10;
FIB_DESC[1] = FIB;


! Allocate the general buffer.
!
COM_FLAGS[COM_DSBL_CHKPT] = TRUE;
FAST_BUFFER_SIZE = 512 * INDEX_BUF_COUNT;
FAST_BUFFER = GET_VM(512 * INDEX_BUF_COUNT);


! Loop over all volumes in the volume set.
!
RVN = 1;
DO
    BEGIN
    LOCAL
	ATR_DESC:	BBLOCK[12],	! Attribute list
	STATBLK:	BBLOCK[8],	! Statistics block
	ACCTL,				! FIB$M_WRITE or 0
	EOF,				! Index file EOF position
	CLUSTER,			! Cluster factor
	BITMAP_OFFSET,			! Index file bitmap VBN offset
	VBN;				! Current index file VBN


    ! Access the index file on RVN 1.
    !
    ACCTL = FIB$M_WRITE OR FIB$M_NORECORD;
    IF .QUAL[QUAL_IGNO_INTE] THEN ACCTL = FIB$M_NOLOCK OR FIB$M_NORECORD;
    FIB[FIB$L_ACCTL] = .ACCTL;
    FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
    FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
    FIB[FIB$W_FID_RVN] = .RVN;
    ATR_DESC[0,0,16,0] = 8;
    ATR_DESC[2,0,16,0] = ATR$C_STATBLK;
    ATR_DESC[4,0,32,0] = STATBLK;
    ATR_DESC[8,0,32,0] = 0;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC,
	P5=ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF .STATUS EQL SS$_WRITLCK
    THEN
	BEGIN
	ACCTL = FIB$M_NORECORD;
	FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
	FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
	FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
	FIB[FIB$W_FID_RVN] = .RVN;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.INPUT_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC,
	    P5=ATR_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	END;
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


    ! Read the home block.  If RVN 1, establish the size of the volume set
    ! and the structure level.
    !
    READ_HOMEBLOCK(.RVN, .FAST_BUFFER);


    ! Allocate the per-volume data.  Each variable between FAST_VOL_BEG and
    ! FAST_VOL_END is a pointer to a vector that varies with the number of
    ! volumes in the volume set.
    !
    IF .RVN EQL 1
    THEN
	BEGIN
	INCRA A FROM FAST_VOL_BEG TO FAST_VOL_END-%UPVAL BY %UPVAL DO
	    BEGIN
	    .A = GET_ZERO_VM(.COM_I_SETCOUNT*%UPVAL);
	    END;
	END;


    ! Initialize information from the home block.
    !
    IF .FAST_STRUCLEV EQL 2
    THEN
	BEGIN
	CLUSTER = .FAST_BUFFER[HM2$W_CLUSTER];
	FAST_IMAP_SIZE[.RVN-1] = .FAST_BUFFER[HM2$W_IBMAPSIZE];
	BITMAP_OFFSET = .CLUSTER*4 + 1;
	FAST_HDR_OFFSET[.RVN-1] = .CLUSTER*4 + .FAST_BUFFER[HM2$W_IBMAPSIZE];
	END
    ELSE
	BEGIN
	CLUSTER = 1;
	FAST_IMAP_SIZE[.RVN-1] = .FAST_BUFFER[HM1$W_IBMAPSIZE];
	BITMAP_OFFSET = 3;
	FAST_HDR_OFFSET[.RVN-1] = 2 + .FAST_BUFFER[HM1$W_IBMAPSIZE];
	END;


    ! Allocate memory for and read in index file bitmap.
    !
    FAST_IMAP[.RVN-1] = GET_VM(.FAST_IMAP_SIZE[.RVN-1] * 512);
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB,
	P1=.FAST_IMAP[.RVN-1],
	P2=.FAST_IMAP_SIZE[.RVN-1] * 512,
	P3=.BITMAP_OFFSET);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


    ! Read the index file header and get the EOF stored therein.
    !
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB,
	P1=.FAST_BUFFER + 512,
	P2=512,
	P3=.FAST_HDR_OFFSET[.RVN-1] + 1);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


    EOF = 0;
    IF .FAST_STRUCLEV EQL 2
	THEN EOF = ROT(.BBLOCK[BBLOCK[.FAST_BUFFER + 512, FH2$W_RECATTR], FAT$L_EFBLK], 16) - 1
	ELSE IF .FAST_BUFFER[HM2$B_STRUCVER] EQL 2
	    THEN EOF = ROT(.STATBLK[SBK$L_FILESIZE], 16);


    ! Now scan the volume's index file bitmap backwards, looking for the
    ! highest set bit.  The maximum of the EOF mark and the highest set
    ! bit is taken to be the true index file EOF.
    !
    DECR J FROM .FAST_IMAP_SIZE[.RVN-1] * 128 - 1 TO 0 DO
	BEGIN
	IF .VECTOR[.FAST_IMAP[.RVN-1], .J] NEQ 0
	THEN
	    BEGIN
	    EOF = MAXU(
		    .J*32 +
		    LEFT_ONE(.VECTOR[.FAST_IMAP[.RVN-1], .J]) +
		    .FAST_HDR_OFFSET[.RVN-1],
		.EOF);
	    EXITLOOP;
	    END;
	END;


    IF .QUAL[QUAL_IMAG]
    THEN
	BEGIN

	! Read the boot block.
	!
	STATUS = $QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=.INPUT_CHAN,
	    IOSB=IOSB,
	    P1=.FAST_BUFFER + 512,
	    P2=512,
	    P3=1);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


	! If the volume is bootable, save the LBN from the boot block.
	!
	FAST_BOOT_LBN[.RVN-1] = -1;
	IF .VECTOR[.FAST_BUFFER + 512, 1; ,WORD] EQL 0
	THEN
	    FAST_BOOT_LBN[.RVN-1] = ROT(.VECTOR[.FAST_BUFFER + 512, 1], 16);
	END;


    ! Deaccess the index file.
    !
    $QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.INPUT_CHAN);


    IF .QUAL[QUAL_IMAG]
    THEN
	BEGIN

	! Access the bitmap file.
	!
	FIB[FIB$L_ACCTL] = .ACCTL;
	FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
	FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;
	FIB[FIB$W_FID_RVN] = .RVN;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.INPUT_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


	! Read the storage control block.
	!
	STATUS = $QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=.INPUT_CHAN,
	    IOSB=IOSB,
	    P1=.FAST_BUFFER + 1024,
	    P2=512,
	    P3=1);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


	! Deaccess the bitmap file.
	!
	$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.INPUT_CHAN);


	! Generate the volume attribute record.
	!
	IF NOT .QUAL[QUAL_VOLU] OR .QUAL[QUAL_VOLU_VALUE] EQL .RVN
	THEN
	    VOLUME_ATTRIBUTES(
		.FAST_BUFFER,		! home block
		.FAST_BUFFER+512,	! boot block
		.FAST_BUFFER+1024,	! storage control block
		.EOF - .FAST_HDR_OFFSET[.RVN-1]);
	END;


    ! Access the index file.
    !
    FIB[FIB$L_ACCTL] = .ACCTL;
    FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
    FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
    FIB[FIB$W_FID_RVN] = .RVN;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


    ! Loop for all headers in the index file.  Read multiple blocks into a
    ! buffer and process them one at a time.
    !
    DIR_STATUS = 0;			! Used by SELECT_INPUT_FILE
    VBN = .FAST_HDR_OFFSET[.RVN-1] + 1;
    UNTIL .VBN GTRU .EOF DO
	BEGIN
	LOCAL
	    HEADER:	REF BBLOCK,	! Pointer to header
	    READ_COUNT;			! Blocks to read on current iteration


	! Establish the count of blocks to read and execute the read.
	!
	READ_COUNT = MINU(INDEX_BUF_COUNT, .EOF + 1 - .VBN);
	STATUS = $QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=.INPUT_CHAN,
	    IOSB=IOSB,
	    P1=.FAST_BUFFER,
	    P2=512 * .READ_COUNT,
	    P3=.VBN);
	IF .STATUS THEN STATUS = .IOSB[0];


	! If an error occurred, read each block separately, reporting any
	! errors.
	!
	IF NOT .STATUS
	THEN
	    BEGIN
	    INCR XVBN FROM 0 TO .READ_COUNT-1 DO
		BEGIN
		LOCAL
		    HEADER:	REF BBLOCK;		! Pointer to header


		HEADER = .FAST_BUFFER + .XVBN * 512;
		STATUS = $QIOW(
		    FUNC=IO$_READVBLK,
		    CHAN=.INPUT_CHAN,
		    IOSB=IOSB,
		    P1=.HEADER,
		    P2=512,
		    P3=.VBN + .XVBN);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    CH$FILL(0, 512, .HEADER);
		END;
	    END;


	! For each header, verify that it is a valid file header.
	! If it is, process it.
	!
	HEADER = .FAST_BUFFER;
	INCR XVBN FROM 0 TO .READ_COUNT-1 DO
	    BEGIN
	    LOCAL
		MAP_AREA:	REF BBLOCK,		! Pointer to map area
		FILE_NUMBER,				! Current file number
		FILE_ID:	BBLOCK[FID$C_LENGTH];	! Current file ID


	    ! Get a clean file ID.
	    !
	    FILE_NUMBER = .VBN + .XVBN - .FAST_HDR_OFFSET[.RVN-1];
	    FILE_ID[FID$W_NUM] = .FILE_NUMBER<0,16>;
	    FILE_ID[FID$B_NMX] = .FILE_NUMBER<16,8>;
	    IF .FAST_STRUCLEV EQL 2
		THEN FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_FID_SEQ]
		ELSE FILE_ID[FID$W_SEQ] = .HEADER[FH1$W_FID_SEQ];
	    FILE_ID[FID$B_RVN] = .RVN;


	    ! Generate the FID record for an image mode save.
	    !
	    IF
		.QUAL[QUAL_IMAG] AND
		.XVBN EQL 0 AND
		(NOT .QUAL[QUAL_VOLU] OR .QUAL[QUAL_VOLU_VALUE] EQL .RVN)
	    THEN
		GEN_FID_RECORD(.HEADER, .READ_COUNT, .FILE_NUMBER, .RVN);


	    ! Validate the header.  In ODS-2, a valid header is to be taken as
	    ! valid even if the index file bitmap shows it as available.  In
	    ! ODS-1, a header corresponding to a clear index file bitmap bit
	    ! is not to be examined.
	    !
	    STATUS = VERIFY_HEADER(.HEADER, FILE_ID);
	    IF
		.FAST_STRUCLEV EQL 1 AND
		NOT .BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1]
	    THEN
		STATUS = FALSE;


	    ! Clear the index file bitmap bit until we determine that the
	    ! header is not an extension header.
	    !
	    BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1] = FALSE;


	    IF .STATUS
	    THEN
		BEGIN

		! Header is valid.
		! Other processing executed only if not an extension header.
		!
		MAP_AREA = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
		IF
		    BEGIN
		    IF .FAST_STRUCLEV EQL 2
			THEN .HEADER[FH2$W_SEG_NUM] EQL 0
			ELSE .MAP_AREA[FM1$B_EX_SEGNUM] EQL 0
		    END
		THEN
		    BEGIN
		    LOCAL
			FCH:	REF BBLOCK;	! Pointer to characteristics


		    ! Make sure the index file bitmap indicates that the header
		    ! is valid.
		    !
		    BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1] = TRUE;


		    ! Get file characteristics pointer.
		    !
		    IF .FAST_STRUCLEV EQL 2
		        THEN FCH = HEADER[FH2$L_FILECHAR]
			ELSE FCH = HEADER[FH1$W_FILECHAR];


		    ! Evaluate file selection criteria for header.  However,
		    ! always reject files marked for delete.  If this is /IMAGE
		    ! mode, select all other valid files.
		    !
		    IF
			BEGIN
			IF .FCH[FCH$V_MARKDEL]
			THEN
			    TRUE
			ELSE
			    BEGIN
			    INIT_ATTR(.HEADER);
			    IF .QUAL[QUAL_IMAG]
				THEN FALSE
				ELSE NOT SELECT_INPUT_FILE(%B'001')
			    END
			END
		    THEN
			BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1] = FALSE;
		    END;
		END;


	    HEADER = .HEADER + 512;
	    END;


	VBN = .VBN + INDEX_BUF_COUNT;
	END;


    ! Deaccess the index file.
    !
    $QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.INPUT_CHAN);


    RVN = .RVN + 1;
    END
WHILE .RVN LEQU .COM_I_SETCOUNT;


! Free the general buffer.
!
FREE_VM(.FAST_BUFFER_SIZE, .FAST_BUFFER);
FAST_BUFFER = FAST_BUFFER_SIZE = 0;
COM_FLAGS[COM_DSBL_CHKPT] = FALSE;


! Scan all directories on all volumes.
!
INCR RVN FROM 1 TO .COM_I_SETCOUNT DO DIR_SCAN(.RVN);


! Allocate a buffer to read file headers.
!
FAST_BUFFER_SIZE = 512;
FAST_BUFFER = GET_VM(512);


! If this is /IMAGE mode, scan for and process lost files.
!
IF .QUAL[QUAL_IMAG]
THEN
    BEGIN
    INCR RVN FROM 1 TO .COM_I_SETCOUNT DO
	BEGIN

	! Scan bitmap for files not yet processed and process these.
	!
	INCR FILE_NUMBER FROM 1 TO .FAST_IMAP_SIZE[.RVN-1]*4096 DO
	    BEGIN
	    IF .BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1]
	    THEN
		BEGIN
		LOCAL
		    NAME_LENGTH,			! Length of filename
		    NAME_ADDRESS,			! Address of filename
		    RSA_DESC:		VECTOR[2],	! Descriptor for RSA
		    FILENAME:		VECTOR[20,BYTE];! Filename buffer


		! Access index file on current RVN.
		!
		FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
		IF .QUAL[QUAL_IGNO_INTE] THEN FIB[FIB$L_ACCTL] = FIB$M_NOLOCK OR FIB$M_NORECORD;
		FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
		FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
		FIB[FIB$W_FID_RVN] = .RVN;
		STATUS = $QIOW(
		    FUNC=IO$_ACCESS OR IO$M_ACCESS,
		    CHAN=.INPUT_CHAN,
		    IOSB=IOSB,
		    P1=FIB_DESC);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


		! Read file header.
		!
		STATUS = $QIOW(
		    FUNC=IO$_READVBLK,
		    CHAN=.INPUT_CHAN,
		    IOSB=IOSB,
		    P1=.FAST_BUFFER,
		    P2=512,
		    P3=.FAST_HDR_OFFSET[.RVN-1] + .FILE_NUMBER);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .STATUS);


		! Deaccess index file on current RVN.
		!
		$QIOW(
		    FUNC=IO$_DEACCESS,
		    CHAN=.INPUT_CHAN);


		! Set up file ID.
		!
	    	INPUT_NAM[NAM$W_FID_NUM] = .FILE_NUMBER;
	    	INPUT_NAM[NAM$B_FID_NMX] = .FILE_NUMBER<16,8>;
	    	INPUT_NAM[NAM$B_FID_RVN] = .RVN;
	    	INPUT_NAM[NAM$W_DID_NUM] = 0;
	    	INPUT_NAM[NAM$W_DID_SEQ] = 0;
	    	INPUT_NAM[NAM$W_DID_RVN] = 0;


		! Generate filename string from file header ident area.
		! Also get file sequence number.
		!
		IF .FAST_STRUCLEV EQL 2
		THEN
		    BEGIN
		    LOCAL
			P;

	    	    INPUT_NAM[NAM$W_FID_SEQ] = .FAST_BUFFER[FH2$W_FID_SEQ];
		    NAME_ADDRESS =
			BBLOCK[.FAST_BUFFER + .FAST_BUFFER[FH2$B_IDOFFSET]*2,
			    FI2$T_FILENAME];
		    NAME_LENGTH = FI2$S_FILENAME;
		    P = CH$FIND_CH(FI2$S_FILENAME, .NAME_ADDRESS, %C' ');
		    IF .P NEQ 0 THEN NAME_LENGTH = .P - .NAME_ADDRESS;
		    END
		ELSE
		    BEGIN
	    	    INPUT_NAM[NAM$W_FID_SEQ] = .FAST_BUFFER[FH1$W_FID_SEQ];
		    NAME_ADDRESS = FILENAME;
		    NAME_LENGTH = MAKE_STRING(
		    BBLOCK[.FAST_BUFFER + .FAST_BUFFER[FH1$B_IDOFFSET]*2,
			FI1$W_FILENAME] - $BYTEOFFSET(NMB$W_NAME),
			FILENAME) AND 65535;
		    END;
		RSA_DESC[0] = NAM$C_MAXRSS;
		RSA_DESC[1] = .INPUT_NAM[NAM$L_RSA];
		$FAO(
		    $DESCRIPTOR('!AS[]!AD'),
	    	    RSA_DESC,
	    	    RSA_DESC,
	    	    INPUT_QUAL[QUAL_DEV_DESC],
	    	    .NAME_LENGTH, .NAME_ADDRESS);
		INPUT_NAM[NAM$B_RSL] = .RSA_DESC[0];
		INIT_NAMEBLOCK(.INPUT_NAM);


		! Call the routine to process the file.
		!
	    	SAVE_ONE_FILE();
		END;
	    END;
	END;
    END;


! Free the file header buffer.
!
FREE_VM(.FAST_BUFFER_SIZE, .FAST_BUFFER);
FAST_BUFFER = FAST_BUFFER_SIZE = 0;


! Free memory for index file bitmaps.
!
INCR RVN FROM 1 TO .COM_I_SETCOUNT DO
    BEGIN
    FREE_VM(.FAST_IMAP_SIZE[.RVN-1] * 512, .FAST_IMAP[.RVN-1]);
    FAST_IMAP[.RVN-1] = 0;
    END;


! Free the per-volume data.
!
INCRA A FROM FAST_VOL_BEG TO FAST_VOL_END-%UPVAL BY %UPVAL DO
    BEGIN
    FREE_VM(.COM_I_SETCOUNT*%UPVAL, ..A);
    .A = 0;
    END;
END;

GLOBAL ROUTINE SLOW_FILE_SCAN: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the driver for the slow file scan.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
DIR_SCAN(1);
END;

ROUTINE READ_HOMEBLOCK(RVN,BUFFER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reads the first good home block of the currently open
!	index file into the buffer supplied.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.
!	BUFFER		- Pointer to buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	BUFFER		- Contains a valid home block.
!	COM_I_SETCOUNT	- Count of volumes in volume set.
!	FAST_STRUCLEV	- Structure level (1 or 2) of the volume set.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	BUFFER:		REF BBLOCK;	! Pointer to buffer
LOCAL
	STATUS,				! General status value
	IOSB:		VECTOR[4,WORD],	! I/O status block
	OLD_STATUS;			! Save status for error message


! We keep reading until we get a block that reads without errors and looks
! like a home block. Track any error status for the eventual error message.
!
OLD_STATUS = SS$_ABORT;
INCR VBN FROM 2 TO 100 DO
    BEGIN
    STATUS = $QIOW(
	FUNC=IO$_READVBLK,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB,
	P1=.BUFFER,
	P2=512,
	P3=.VBN);
    IF .STATUS THEN STATUS = .IOSB[0];

    IF NOT .STATUS
    THEN
	OLD_STATUS = .STATUS
    ELSE
	IF 
	    .BUFFER[HM2$B_STRUCLEV] EQL 2 AND
	    .BUFFER[HM2$W_HOMEVBN] EQL .VBN AND
	    .BUFFER[HM2$L_ALTIDXLBN] NEQ 0 AND
	    .BUFFER[HM2$W_CLUSTER] NEQ 0 AND
	    .BUFFER[HM2$W_HOMEVBN] NEQ 0 AND
	    .BUFFER[HM2$W_ALHOMEVBN] NEQ 0 AND
	    .BUFFER[HM2$W_ALTIDXVBN] NEQ 0 AND
	    .BUFFER[HM2$W_IBMAPVBN] NEQ 0 AND
	    .BUFFER[HM2$L_IBMAPLBN] NEQ 0 AND
	    .BUFFER[HM2$L_MAXFILES] NEQ 0 AND
	    .BUFFER[HM2$W_IBMAPSIZE] NEQ 0 AND
	    .BUFFER[HM2$W_RESFILES] NEQ 0 AND
	    CHECKSUM2(.BUFFER, $BYTEOFFSET(HM2$W_CHECKSUM1)) AND
	    CHECKSUM2(.BUFFER, $BYTEOFFSET(HM2$W_CHECKSUM2))
	THEN
	    BEGIN
	    IF .RVN EQL 1
	    THEN
		BEGIN
		FAST_STRUCLEV = 2;
		IF .BUFFER[HM2$W_SETCOUNT] GTRU MAX_VOLUMES
		    THEN SIGNAL(BACKUP$_MAXVOLS, 1, INPUT_QUAL[QUAL_DEV_DESC]);
		COM_I_SETCOUNT = .BUFFER[HM2$W_SETCOUNT];
		IF .COM_I_SETCOUNT EQL 0 THEN COM_I_SETCOUNT = 1;
		IF
		    .QUAL[QUAL_VOLU] AND
		    .QUAL[QUAL_VOLU_VALUE] GTRU .COM_I_SETCOUNT
		THEN
		    SIGNAL(
			BACKUP$_NOSUCHRVN,
			2, .QUAL[QUAL_VOLU_VALUE], .COM_I_SETCOUNT);
		CH$MOVE(
		    HM2$S_STRUCNAME,
		    BUFFER[HM2$T_STRUCNAME],
		    COM_I_STRUCNAME);
		END;
	    RETURN;
	    END
	ELSE IF 
	    .RVN EQL 1 AND
	    .BUFFER[HM2$B_STRUCLEV] EQL 1 AND
	    .BUFFER[HM1$W_CLUSTER] EQL 1 AND
	    .BUFFER[HM1$L_IBMAPLBN] NEQ 0 AND
	    .BUFFER[HM1$W_MAXFILES] NEQ 0 AND
	    .BUFFER[HM1$W_IBMAPSIZE] NEQ 0 AND
	    CHECKSUM2(.BUFFER, $BYTEOFFSET(HM1$W_CHECKSUM1)) AND
	    CHECKSUM2(.BUFFER, $BYTEOFFSET(HM1$W_CHECKSUM2))
	THEN
	    BEGIN
	    FAST_STRUCLEV = 1;
	    COM_I_SETCOUNT = 1;
	    IF
		.QUAL[QUAL_VOLU] AND
		.QUAL[QUAL_VOLU_VALUE] GTRU 1
	    THEN
		SIGNAL(
		    BACKUP$_NOSUCHRVN,
		    2, .QUAL[QUAL_VOLU_VALUE], .COM_I_SETCOUNT);
	    RETURN;
	    END;
    END;


! No good home block found.  Report failure.
!
SIGNAL(BACKUP$_PROCINDEX, 2, INPUT_QUAL[QUAL_DEV_DESC], .RVN, .OLD_STATUS);
END;

ROUTINE VERIFY_HEADER(HEADER,FILE_ID)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine determines if the block given it is a valid file header.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to header.
!	FILE_ID		- Purported file ID.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	0 if invalid file header
!	1 if valid file header
!	2 if deleted file header
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HEADER:		REF BBLOCK,	! file header arg
	FILE_ID:	REF BBLOCK;	! file ID arg


! First check the structure level.
!
IF .HEADER[FH2$B_STRUCLEV] NEQ .FAST_STRUCLEV
THEN
    RETURN 0;


IF .FAST_STRUCLEV EQL 2
THEN
    BEGIN

    ! Check the area offsets and the retrieval pointer use counts for
    ! consistency.
    !
    IF
	.HEADER[FH2$B_IDOFFSET] LSSU FH2$C_LENGTH/2 OR
	.HEADER[FH2$B_MPOFFSET] LSSU .HEADER[FH2$B_IDOFFSET] OR
	.HEADER[FH2$B_ACOFFSET] LSSU .HEADER[FH2$B_MPOFFSET] OR
	.HEADER[FH2$B_RSOFFSET] LSSU .HEADER[FH2$B_ACOFFSET] OR
	.HEADER[FH2$B_MAP_INUSE] GTRU .HEADER[FH2$B_ACOFFSET] - .HEADER[FH2$B_MPOFFSET]
    THEN
	RETURN 0;


    ! At this point, we have verified that the block at least once was a
    ! valid file header.
    !
    ! Look at the file number in the header. If zero, this is a 
    ! deleted header.
    !
    IF
	.HEADER[FH2$W_FID_NUM] EQL 0 AND
	.HEADER[FH2$B_FID_NMX] EQL 0
    THEN
	RETURN 2;


    ! Now compute the header checksum.
    !
    IF NOT CHECKSUM(.HEADER)
    THEN
	RETURN 2;


    ! Check file number and file sequence number.
    !
    IF
	.HEADER[FH2$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM] OR
	.HEADER[FH2$B_FID_NMX] NEQ .FILE_ID[FID$B_NMX] OR
	.HEADER[FH2$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
    THEN
	RETURN 2;
    END
ELSE
    BEGIN
    LOCAL
	MAP_AREA:	REF BBLOCK;


    ! Now point to the map area and make sure that the extension
    ! RVN is zero.  Also check the retrieval pointer format data.
    !
    MAP_AREA = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
    IF
	.MAP_AREA[FM1$B_EX_RVN] NEQ 0 OR
	.MAP_AREA[FM1$B_COUNTSIZE] NEQ 1 OR
	.MAP_AREA[FM1$B_LBNSIZE] NEQ 3
    THEN
	RETURN 0;


    ! Check the retrieval pointer counts for consistency with the
    ! available space.
    !
    IF
	.MAP_AREA[FM1$B_INUSE] GTRU .MAP_AREA[FM1$B_AVAIL] OR
	.MAP_AREA[FM1$B_AVAIL] GTRU 255 - (.MAP_AREA + FM1$C_POINTERS - .HEADER) / 2
    THEN
	RETURN 0;


    ! At this point, we have verified that the block at least once was a
    ! valid file header.
    !
    ! Look at the file number in the header. If zero, this is a 
    ! deleted header.
    !
    IF .HEADER[FH1$W_FID_NUM] EQL 0
    THEN
	RETURN 2;


    ! Now compute the header checksum.
    !
    IF NOT CHECKSUM(.HEADER)
    THEN
	RETURN 2;


    ! Check file number and file sequence number.
    !
    IF
	.HEADER[FH1$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM] OR
	.HEADER[FH1$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
    THEN
	RETURN 2;
    END;


! Header is OK.
!
RETURN 1;
END;

ROUTINE PROCESS_FILE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called when the next file that matches the selection
!	file specification has been located.  It completes the tests that
!	select files to be processed, and if these are passed, processes the
!	file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_NAM	- Contains resultant string and file ID.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	File processed if appropriate.
!
!--

BEGIN
LOCAL
	FILE_NUMBER,				! Clean file number
	RVN;					! Clean RVN


! Get clean file ID.
!
FILE_NUMBER = .INPUT_NAM[NAM$W_FID_NUM];
FILE_NUMBER<16,8> = .INPUT_NAM[NAM$B_FID_NMX];
RVN = .INPUT_NAM[NAM$B_FID_RVN];


IF .QUAL[QUAL_FAST]
THEN
    BEGIN

    ! First, make sure the RVN is in range.  Then, make sure the file number
    ! is in range.
    !
    IF .RVN GTRU .COM_I_SETCOUNT THEN RETURN;
    IF .FILE_NUMBER GTRU .FAST_IMAP_SIZE[.RVN-1]*4096 THEN RETURN;


    ! See if file is selected.  Only do synonyms once if /IMAGE specified.
    !
    IF .QUAL[QUAL_IMAG]
    THEN
	BEGIN
	IF TESTBITCC(BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1])
	THEN
	    RETURN;
	END
    ELSE
	BEGIN
	IF
	    NOT .BITVECTOR[.FAST_IMAP[.RVN-1], .FILE_NUMBER-1] AND
	    NOT .DIR_STATUS[D_STAT_SCANNED]
	THEN
	    RETURN;
	END;
    END;


! Finish evaluating selection criteria.
!
IF
    NOT .QUAL[QUAL_IMAG] AND
    NOT .DIR_STATUS[D_STAT_SCANNED]
THEN
    IF NOT SELECT_INPUT_FILE(%B'010') THEN RETURN;


! File is selected.  Process it.
!
SAVE_ONE_FILE();
END;

ROUTINE DIR_SCAN(RVN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the driver for a directory scan.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
FAST_RVN = .RVN;
INIT_DIR_SCAN(
    .INPUT_CHAN,
    .INPUT_NAM,
    INPUT_QUAL[QUAL_DEV_DESC],
    INPUT_QUAL[QUAL_EXP_DESC],
    .QUAL[QUAL_IMAG] + .QUAL[QUAL_OSAV]^2,
    .RVN,
    0);
WHILE FIND_NEXT() DO PROCESS_FILE();
FREE_DIR_DATA();
END;

GLOBAL ROUTINE INIT_DIR_SCAN(CHAN,NAM,DEV_DESC,SEL_DESC,FLAGS,RVN,LIMIT): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes context for a directory scan.
!
! INPUT PARAMETERS:
!	CHANNEL		- Channel assigned to volume set.
!	NAM		- Pointer to name block.
!	DEV_DESC	- Pointer to device name descriptor.
!	SEL_DESC	- Pointer to selection filespec descriptor.
!	FLAGS		- Bit 0 true to request an image scan.
!			  Bit 1 true to request immediate return on terminator.
!			  Bit 2 true to request return of scanned directories.
!	RVN		- Relative volume number.
!	LIMIT		- Pointer to vector of ODS-1 scan limits or 0.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	NAM:		REF BBLOCK;	! Pointer to name block
LOCAL
	ROOT_DIR,			! Status variable
	DIR_BUFFER:	BBLOCK[DIR$S_NAME], ! Buffer for root directory
	DIR_DESC:	BBLOCK[8],	! Descriptor for DIR_BUFFER
	RSA_DESC:	VECTOR[2];	! Descriptor for RSA


! Initialize the impure area.
!
CH$FILL(0, DIR_END-DIR_BEG, DIR_BEG);
DIR_FLAGS[D_INITIAL] = TRUE;


! Save the parameters.
!
DIR_CHAN = .CHAN;
DIR_NAM = .NAM;
DIR_NAM[NAM$W_DID_NUM] = FID$C_MFD;
DIR_NAM[NAM$W_DID_SEQ] = FID$C_MFD;
DIR_NAM[NAM$W_DID_RVN] = .RVN;
DIR_DEV_DESC = .DEV_DESC;


! Determine if a root directory is used.
!
DIR_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
DIR_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
DIR_DESC[DSC$W_LENGTH] = DIR$S_NAME;
DIR_DESC[DSC$A_POINTER] = DIR_BUFFER;
ROOT_DIR = LIB$EXTRACT_CONCEALED(.DEV_DESC, 0, DIR_DESC, 0, DIR_DESC);
IF NOT .ROOT_DIR AND .ROOT_DIR NEQ LIB$_INVFILSPE
THEN
    SIGNAL(BACKUP$_OPENIN + STS$K_SEVERE, 1, .DEV_DESC, .ROOT_DIR);


! If no root directory is used, establish the MFD as the root.
!
IF (IF NOT .ROOT_DIR THEN TRUE ELSE .DIR_DESC[DSC$W_LENGTH] EQL 0)
THEN
    BEGIN
    ROOT_DIR = FALSE;
    DIR_DESC[DSC$W_LENGTH] = 6;
    DIR_DESC[DSC$A_POINTER] = MFD + 1;
    DIR_NAM[NAM$W_FID_NUM] = FID$C_MFD;
    DIR_NAM[NAM$W_FID_SEQ] = FID$C_MFD;
    DIR_NAM[NAM$W_FID_RVN] = .RVN;
    END;


! Initialize the name block to describe the root directory, if specified,
! or the MFD.
!
RSA_DESC[0] = .NAM[NAM$B_RSS];
RSA_DESC[1] = .NAM[NAM$L_RSA];
$FAO(
    $DESCRIPTOR('!AS[000000]!AS.DIR;1'),
	    RSA_DESC,
	    RSA_DESC,
	    .DEV_DESC,
	    DIR_DESC);
NAM[NAM$B_RSL] = .RSA_DESC[0];
INIT_NAMEBLOCK(.NAM);


! If a root directory is used, look up the directory in the MFD of the
! selected RVN.  If found, establish it as the initial directory to be scanned.
!
IF .ROOT_DIR
THEN
    BEGIN
    LOCAL
	FIB:		BBLOCK[FIB$C_LENGTH],	! FIB
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	FNA_DESC:	VECTOR[2],		! Descriptor for filename
	STATUS,					! Status return
	IOSB:		VECTOR[4,WORD];		! I/O status block


    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_DID_NUM] = FID$C_MFD;
    FIB[FIB$W_DID_SEQ] = FID$C_MFD;
    FIB[FIB$W_DID_RVN] = .RVN;
    FIB_DESC[0] = FIB$C_LENGTH;
    FIB_DESC[1] = FIB;
    FNA_DESC[0] = .NAM[NAM$L_RSA] + .NAM[NAM$B_RSL] - .NAM[NAM$L_NAME];
    FNA_DESC[1] = .NAM[NAM$L_NAME];
    STATUS = $QIOW(
	FUNC=IO$_ACCESS,
	CHAN=.CHAN,
	IOSB=IOSB,
	P1=FIB_DESC,
	P2=FNA_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_OPENIN + STS$K_SEVERE, 1, RSA_DESC, .STATUS);


    DIR_NAM[NAM$W_FID_NUM] = .FIB[FIB$W_FID_NUM];
    DIR_NAM[NAM$W_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
    DIR_NAM[NAM$W_FID_RVN] = .FIB[FIB$W_FID_RVN];
    IF .DIR_NAM[NAM$B_FID_RVN] EQL 0 THEN DIR_NAM[NAM$B_FID_RVN] = .RVN;
    END;


! Initialize the level stack with the root of the selected RVN.
!
DIR_SP = DIR_STACK;
DIR_LEVELS = 1;
BBLOCK[DIR_STACK[D_FID], FID$W_NUM] = .DIR_NAM[NAM$W_FID_NUM];
BBLOCK[DIR_STACK[D_FID], FID$W_SEQ] = .DIR_NAM[NAM$W_FID_SEQ];
BBLOCK[DIR_STACK[D_FID], FID$W_RVN] = .DIR_NAM[NAM$W_FID_RVN];
DIR_STACK[D_VBN] = 1;


! Establish the selection file specification.  This will also set the
! terminator and status bits for the root level.
!
RESET_DIR_SPEC(.SEL_DESC, .FLAGS);
IF .LIMIT NEQ 0 THEN CH$MOVE(D_K_NLEVELS*%UPVAL, .LIMIT, DIR_SCANLIMIT);


! Two special cases for root directories:  Files in the root directory never
! match the selector, and the root directory is not saved initially.
!
IF .ROOT_DIR
THEN
    BEGIN
    DIR_STACK[D_DIR_MATCHES] = FALSE;
    DIR_FLAGS[D_INITIAL] = FALSE;
    END;
END;

GLOBAL ROUTINE RESET_DIR_SPEC(SEL_DESC,FLAGS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reinitializes context to change the selection file spec.
!
! INPUT PARAMETERS:
!	SEL_DESC	- Pointer to selection filespec descriptor.
!	FLAGS		- Bit 0 true to request an image scan.
!			  Bit 1 true to request immediate return on terminator.
!			  Bit 2 true to request return of scanned directories.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
INIT_SEL_INFO(.SEL_DESC, DIR_SEL_DIR, DIR_SEL_NTV, DIR_SEL_LATEST);
DIR_FLAGS[D_IMAGE_SCAN] = .FLAGS<0,1>;
DIR_FLAGS[D_HARD_STOP] = .FLAGS<1,1>;
IF NOT .QUAL[QUAL_INTE] THEN DIR_FLAGS[D_SCANNED_DIRS] = .FLAGS<2,1>;
IF .DIR_FLAGS[D_IMAGE_SCAN] THEN DIR_SEL_LATEST = +1;
CH$FILL(-1, D_K_NLEVELS*%UPVAL, DIR_SCANLIMIT);


INCRA D FROM DIR_STACK TO .DIR_SP BY D_S_ENTRY DO
    BEGIN
    MAP
	D:		REF BBLOCK;	! Pointer to stack entry
    LOCAL
	DESC:		VECTOR[2];	! Descriptor for directory string


    ! Establish the descriptor for the directory string at the current level.
    !
    IF .D EQLA DIR_STACK
    THEN
	BEGIN
	DESC[0] = %CHARCOUNT('000000');
	DESC[1] = UPLIT BYTE('000000');
	END
    ELSE
	BEGIN
	IF .D EQLA .DIR_SP
	    THEN DESC[0] = .DIR_STRING[0]
	    ELSE DESC[0] = .BBLOCK[.D + D_S_ENTRY, D_SAV_LEN];
	DESC[1] = DIR_STRING[1];
	END;


    ! Allocate the dynamic areas for this level.
    !
    BBLOCK[D[D_TERM_DESC], DSC$A_POINTER] = GET_VM(DIR$S_NAME);
    BBLOCK[D[D_NAME_DESC], DSC$A_POINTER] = GET_VM(DIR$S_NAME);


    ! Establish the match bit and the terminator specification for this level.
    !
    IF MATCH_DIRECTORY(
	DESC,
	DIR_SEL_DIR,
	D[D_TERM_DESC],
	D[D_TERM_VER],
	DIR_SEL_NTV)
    THEN D[D_DIR_MATCHES] = TRUE;
    END;
END;

GLOBAL ROUTINE FIND_NEXT=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine searches for the next file matching the specified
!	selection filespec.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	Directory scan context.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Directory scan context.  If a file was found, the name block contains
!	the resultant string and file ID.
!
! ROUTINE VALUE:
!	True if a file was found, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	N:		REF BBLOCK,	! Local copy of DIR_NAM
	D:		REF BBLOCK;	! Local copy of DIR_SP


N = .DIR_NAM;
D = .DIR_SP;
DIR_STATUS = DIR_VERLIMIT = 0;


! If the directory stack is now empty, we have completed the MFD.
!
IF .DIR_LEVELS LEQ 0
THEN
    BEGIN
    N[NAM$B_RSL] = 0;
    N[NAM$W_FID_NUM] = N[NAM$W_FID_SEQ] = N[NAM$W_FID_RVN] = 0;
    N[NAM$W_DID_NUM] = N[NAM$W_DID_SEQ] = N[NAM$W_DID_RVN] = 0;
    RETURN FALSE;
    END;


! Return the MFD if requested.
!
IF TESTBITSC(DIR_FLAGS[D_INITIAL]) AND .DIR_FLAGS[D_SCANNED_DIRS]
THEN
    BEGIN
    DIR_STATUS[D_STAT_VALID] = DIR_STATUS[D_STAT_SCANNED] = TRUE;
    RETURN TRUE;
    END;


! Loop until we find something or traverse past a possible match.
!
WHILE TRUE DO
    BEGIN
    LOCAL
	R:		REF BBLOCK,	! Local copy of D_REC
	V:		REF BBLOCK;	! Local copy of D_VER


    ! Push down to a lower directory if necessary.  This logic depends upon the
    ! resultant string in the name block being unmodified from the previous
    ! call.
    !
    IF NOT .DIR_FLAGS[D_SCAN_FAILED] THEN IF TESTBITSC(D[D_DIR_SCAN])
    THEN
	BEGIN

	! Push down the directory stack.
	!
	DIR_LEVELS = .DIR_LEVELS + 1;
	DIR_SP = D = .D + D_S_ENTRY;
	BBLOCK[D[D_FID], FID$W_NUM] = .N[NAM$W_FID_NUM];
	BBLOCK[D[D_FID], FID$W_SEQ] = .N[NAM$W_FID_SEQ];
	BBLOCK[D[D_FID], FID$W_RVN] = .N[NAM$W_FID_RVN];
	D[D_SAV_LEN] = .DIR_STRING[0];
	D[D_VBN] = 1;


	! Generate the new directory string.  If this is not the top level,
	! append a dot, and then append the directory name.
	!
	IF .DIR_STRING[0] NEQ 0 THEN DIR_STRING[0] = .DIR_STRING[0] + 1;
	DIR_STRING[0] = .DIR_STRING[0] + .N[NAM$B_NAME];
	END;


    ! Get a new chunk of directory if necessary.
    !
    IF .D[D_REC] GEQA .D[D_BUF_LIM]
    THEN
	BEGIN
	LITERAL
	    ATR_LENGTH=	MAXU(
			    $BYTEOFFSET(FH1$W_RECATTR)+32,
			    $BYTEOFFSET(FH2$W_FILEPROT)+2);
	LOCAL
	    FIB:	BBLOCK[10],		! FIB
	    FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	    STATUS,				! Status variable
	    IOSB:	VECTOR[4,WORD],		! I/O status block
	    HEADER:	BBLOCK[ATR_LENGTH],	! Beginning of file header
	    ATR_DESC:	BBLOCK[12];		! ACP attributes list


	! Access the current directory file.
	!
	FIB_DESC[0] = 10;
	FIB_DESC[1] = FIB;
	FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
	IF .QUAL[QUAL_IGNO_INTE] THEN FIB[FIB$L_ACCTL] = FIB$M_NOLOCK OR FIB$M_NORECORD;
	FIB[FIB$W_FID_NUM] = .BBLOCK[D[D_FID], FID$W_NUM];
	FIB[FIB$W_FID_SEQ] = .BBLOCK[D[D_FID], FID$W_SEQ];
	FIB[FIB$W_FID_RVN] = .BBLOCK[D[D_FID], FID$W_RVN];
	ATR_DESC[0,0,16,0] = ATR_LENGTH;
	ATR_DESC[2,0,16,0] = ATR$C_HEADER;
	ATR_DESC[4,0,32,0] = HEADER;
	ATR_DESC[8,0,32,0] = 0;
	STATUS = C$QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.DIR_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC,
	    P5=ATR_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    BEGIN

	    ! Report failure to access the directory.
	    !
	    SIGNAL(
		BACKUP$_OPENDIR,
		2,
		.DIR_DEV_DESC,
		(IF .DIR_STRING[0] EQL 0 THEN MFD ELSE DIR_STRING),
		.STATUS);


	    ! Readjust context so that processing of the directory is
	    ! aborted.
	    !
	    D[D_DIR_LEN] = 0;
	    END
	ELSE
	    BEGIN

	    ! If there is not currently a buffer, this is the first chunk of
	    ! this directory.  Determine whether the file is indeed a
	    ! directory, determine its size, and allocate the buffer.
	    !
	    IF .D[D_BUF_ADDR] EQL 0
	    THEN
		BEGIN

		! Ensure that the file is, in fact, a directory.  At this point
		! we know only that the filename is ".DIR;1".  Use the portion
		! of the file header that was obtained during the access.
		! Compute the file length if valid.  If invalid, leave the file
		! length zero to avoid processing the file.
		!
		D[D_DIR_LEN] = 0;
		DIR_STRUCLEV = .HEADER[FH2$B_STRUCLEV];
		IF .DIR_STRUCLEV EQL 2
		THEN
		    BEGIN
		    BIND
			RECATTR=	HEADER[FH2$W_RECATTR]: BBLOCK;

		    IF .HEADER[FH2$V_DIRECTORY]
		    THEN
			BEGIN
			D[D_DIR_LEN] = ROT(.RECATTR[FAT$L_EFBLK], 16);
			IF .RECATTR[FAT$W_FFBYTE] EQL 0
			    THEN D[D_DIR_LEN] = .D[D_DIR_LEN] - 1;
			D[D_FPRO] = .HEADER[FH2$W_FILEPROT];
			D[D_UIC] = .HEADER[FH2$L_FILEOWNER];
			D[D_VERLIM] = .BBLOCK[HEADER[FH2$W_RECATTR], FAT$W_VERSIONS];
			END;
		    END
		ELSE
		    BEGIN
		    BIND
			RECATTR=	HEADER[FH1$W_RECATTR]: BBLOCK;

		    IF
			.RECATTR[FAT$B_RTYPE] EQL FAT$C_FIXED AND
			.RECATTR[FAT$W_RSIZE] EQL NMB$C_DIRENTRY
		    THEN
			BEGIN
			D[D_DIR_LEN] = ROT(.RECATTR[FAT$L_EFBLK], 16);
			IF .RECATTR[FAT$W_FFBYTE] EQL 0
			    THEN D[D_DIR_LEN] = .D[D_DIR_LEN] - 1;
			D[D_FPRO] = .HEADER[FH1$W_FILEPROT];
			D[D_UIC] = .HEADER[FH1$B_UICMEMBER];
			(D[D_UIC])<16,16> = .HEADER[FH1$B_UICGROUP];
			D[D_VERLIM] = .BBLOCK[HEADER[FH1$W_RECATTR], FAT$W_VERSIONS];
			END;
		    END;


		! If the file looks like a directory and is not zero length,
		! allocate a buffer for it.
		!
		IF .D[D_DIR_LEN] NEQ 0
		THEN
		    BEGIN

		    ! Compute buffer length.  Try to read the entire directory
		    ! at one time, but no more than DIR_BUF_COUNT blocks.
		    ! However, for an ODS-1 directory on which a latest-version
		    ! scan is in progress, always read the entire directory.
		    !
		    D[D_BUF_LEN] = .D[D_DIR_LEN] * 512;
		    IF
			.D[D_BUF_LEN] GTRU DIR_BUF_COUNT*512 AND
			NOT (.DIR_STRUCLEV EQL 1 AND .DIR_SEL_LATEST LEQ 0)
		    THEN
			D[D_BUF_LEN] = DIR_BUF_COUNT*512;


		    ! Allocate memory for buffer.
		    !
		    D[D_BUF_ADDR] = GET_VM(.D[D_BUF_LEN]);
		    END;
		END;


	    ! If we are not yet beyond the end, size the portion of the
	    ! directory to be read on this pass and read it.
	    !
	    IF .D[D_VBN] LEQU .D[D_DIR_LEN]
	    THEN
		BEGIN
		LOCAL
		    READ_ADDRESS,	! Address for current read QIO
		    PROC_LENGTH;	! Bytes to process this time


		! Compute size of chunk to be processed on this iteration.
		!
		PROC_LENGTH = MINU(
		    .D[D_BUF_LEN],
		    (.D[D_DIR_LEN] - .D[D_VBN] + 1) * 512);
		D[D_BUF_LIM] = .D[D_BUF_ADDR] + .PROC_LENGTH;
		D[D_REC] = D[D_VER] = 0;


		! Loop to read the chunk of directory that will be processed on
		! this iteration.  Because the chunk might exceed 65535 bytes,
		! we must have a loop, though it is unlikely to be executed
		! more than once.
		!
		READ_ADDRESS = .D[D_BUF_ADDR];
		WHILE .READ_ADDRESS LSSA .D[D_BUF_LIM] DO
		    BEGIN
		    LOCAL
			READ_LENGTH;	! Size of current transfer in bytes


		    ! Compute size of this transfer.
		    !
		    READ_LENGTH = MINU(
			127 * 512,
			.D[D_BUF_LIM] - .READ_ADDRESS);


		    ! Read in the blocks.
		    !
		    STATUS = C$QIOW(
			FUNC=IO$_READVBLK,
			CHAN=.DIR_CHAN,
			IOSB=IOSB,
			P1=.READ_ADDRESS,
			P2=.READ_LENGTH,
			P3=.D[D_VBN]);
		    READ_ADDRESS = .READ_ADDRESS + .READ_LENGTH;
		    D[D_VBN] = .D[D_VBN] + .READ_LENGTH/512;
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			BEGIN
			SIGNAL(
			    BACKUP$_READDIR,
			    2,
			    .DIR_DEV_DESC,
			    (IF .DIR_STRING[0] EQL 0 THEN MFD ELSE DIR_STRING),
			    .STATUS);


			! Readjust context so that processing of the directory
			! is aborted.
			!
			D[D_DIR_LEN] = 0;
			D[D_BUF_LIM] = 0;
			EXITLOOP;
			END;
		    END;
		END;


	    ! Deaccess the directory file.
	    !
	    C$QIOW(
		FUNC=IO$_DEACCESS,
		CHAN=.DIR_CHAN);
	    END;
	END;


    ! If no more directory is available, pop up to the higher directory.
    !
    IF .D[D_REC] GEQA .D[D_BUF_LIM]
    THEN
	BEGIN

	! Deallocate dynamic memory.
	!
	IF .D[D_BUF_ADDR] NEQ 0
	THEN
	    FREE_VM(.D[D_BUF_LEN], .D[D_BUF_ADDR]);
	IF .BBLOCK[D[D_TERM_DESC], DSC$A_POINTER] NEQ 0
	THEN
	    FREE_VM(DIR$S_NAME, .BBLOCK[D[D_TERM_DESC], DSC$A_POINTER]);
	IF .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER] NEQ 0
	THEN
	    FREE_VM(DIR$S_NAME, .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER]);


	! Pop the directory stack.
	!
	DIR_STRING[0] = .D[D_SAV_LEN];
	CH$FILL(0, D_S_ENTRY, .D);
	DIR_SP = D = .D - D_S_ENTRY;
	DIR_LEVELS = .DIR_LEVELS - 1;


	! If the directory stack is now empty, we have completed the MFD.
	!
	IF .DIR_LEVELS LEQ 0
	THEN
	    BEGIN
	    N[NAM$B_RSL] = 0;
	    N[NAM$W_FID_NUM] = N[NAM$W_FID_SEQ] = N[NAM$W_FID_RVN] = 0;
	    N[NAM$W_DID_NUM] = N[NAM$W_DID_SEQ] = N[NAM$W_DID_RVN] = 0;
	    RETURN FALSE;
	    END;
	END;


    ! Adjust pointers to the next entry in the directory.
    !
    R = .D[D_REC];
    V = .D[D_VER];
    IF TESTBITCC(DIR_FLAGS[D_SCAN_FAILED])
    THEN
	BEGIN
	IF .DIR_STRUCLEV EQL 1
	THEN
	    BEGIN
	    WHILE TRUE DO
		BEGIN

		! Advance the record pointer to the next (or first) entry.
		!
		IF .R EQL 0
		THEN
		    R = .D[D_BUF_ADDR]
		ELSE
		    BEGIN
		    R = .R + NMB$C_DIRENTRY;
		    V = .V + 1;
		    END;


		! If there are no more entries, exit the loop.
		!
		IF .R GEQA .D[D_BUF_LIM] THEN EXITLOOP;


		! If the entry contains a non-zero file number, it is in use.
		!
		IF .R[NMB$W_FID_NUM] NEQ 0
		THEN
		    BEGIN

		    ! If the selection filespec selects latest version,
		    ! determine if this is the latest version, by scanning
		    ! the entire directory for a higher version.  
		    !
		    D[D_VER_COUNT] = 1;
		    IF .DIR_SEL_LATEST LEQ 0
		    THEN
			INCRA P
		 	FROM .D[D_BUF_ADDR]
			TO .D[D_BUF_ADDR] + .D[D_BUF_LEN] - NMB$C_DIRENTRY
			BY NMB$C_DIRENTRY DO
			    BEGIN
			    MAP
				P:		REF BBLOCK;

			    IF
				.(P[NMB$W_NAME])   EQL .(R[NMB$W_NAME])   AND
				.(P[NMB$W_NAME]+4) EQL .(R[NMB$W_NAME]+4) AND
				.P[NMB$W_VERSION] GTRU .R[NMB$W_VERSION]
			    THEN
				BEGIN
				D[D_VER_COUNT] = 0;
				EXITLOOP;
				END;
			    END;


		    ! Exit the loop with a valid entry, and D_VER_COUNT set.
		    !
		    EXITLOOP;
		    END;
		END;
	    END
	ELSE
	    BEGIN
	    WHILE TRUE DO
		BEGIN
		LOCAL
		    NEXT_RECORD;		! Pointer to next record


		! Advance the record and version pointers to the
		! next (or first) entry.
		!
		IF .R EQL 0
		THEN
		    R = .D[D_BUF_ADDR]
		ELSE
		    IF .V NEQ 0
		    THEN
			BEGIN
			NEXT_RECORD = .R[DIR$W_SIZE] + .R + 2;
			V = .V + DIR$C_VERSION;
			IF .V LEQA .NEXT_RECORD - DIR$C_VERSION THEN EXITLOOP;
			R = .NEXT_RECORD;
			END;


		! If there are no more entries, exit the loop.
		!
		IF .R GEQA .D[D_BUF_LIM] THEN EXITLOOP;


		IF .R[DIR$W_SIZE] EQL 65535
		THEN
		    BEGIN

		    ! End of this block.  Advance to next.
		    !
		    R = ((.R - .D[D_BUF_ADDR]) AND NOT 511) + .D[D_BUF_ADDR] + 512;
		    V = 0;
		    END
		ELSE
		    BEGIN

		    ! Point to where next record should start.  Make some
		    ! validity tests on the entry we are looking at.
		    !
		    NEXT_RECORD = .R[DIR$W_SIZE] + .R + 2;
		    IF
			BEGIN
			IF
			    .NEXT_RECORD GEQA ((.R - .D[D_BUF_ADDR]) AND NOT 511) + .D[D_BUF_ADDR] + 512 OR
									! Entry within block?
			    .R[DIR$W_SIZE] OR				! Length even?
			    .R[DIR$W_SIZE] LSSU DIR$C_LENGTH + DIR$C_VERSION
									! Long enough?
			THEN
			    TRUE
			ELSE
			    BEGIN
			    V = (.R + DIR$C_LENGTH + .R[DIR$B_NAMECOUNT] + 1) AND NOT 1;
			    .R[DIR$V_TYPE] NEQ DIR$C_FID OR		! Proper type code?
			    .V GEQA ((.R - .D[D_BUF_ADDR]) AND NOT 511) + .D[D_BUF_ADDR] + 512 - DIR$C_VERSION
									! Version entry within block?
			    END
			END
		    THEN
			BEGIN

			! Directory format error.  Report it and quit.
			!
			SIGNAL(
			    BACKUP$_BADDIR,
			    2,
			    .DIR_DEV_DESC,
			    (IF .DIR_STRING[0] EQL 0 THEN MFD ELSE DIR_STRING));


			! Adjust context to avoid processing this directory.
			!
			R = .D[D_BUF_LIM];
			D[D_DIR_LEN] = 0;
			END;


		    ! Found a valid entry.  Exit the loop.
		    !
		    EXITLOOP;
		    END;
		END;
	    END;
	D[D_REC] = .R;
	D[D_VER] = .V;
	END;


    ! If an entry was found, finish processing it.
    !
    IF .R LSSA .D[D_BUF_LIM]
    THEN
	BEGIN
	LOCAL
	    RSA_DESC:	VECTOR[2],		! Descriptor for RSA area
	    NAME:	REF VECTOR[,BYTE],	! Pointer to ASCIC name.typ
	    VERSION,				! Binary version number
	    FILE_NAME:	VECTOR[20,BYTE];	! Area to build ODS-1 filename


	! Get a pointer to the name.typ string and the version number.
	! Initialize the file ID in the name block.
	!
	IF .DIR_STRUCLEV EQL 2
	THEN
	    BEGIN
	    D[D_VER_COUNT] = .D[D_VER_COUNT] - 1;
	    IF
		.R[DIR$B_NAMECOUNT] NEQ .BBLOCK[D[D_NAME_DESC], DSC$W_LENGTH] OR
		CH$NEQ(
		    .R[DIR$B_NAMECOUNT],
		    R[DIR$T_NAME],
		    .R[DIR$B_NAMECOUNT],
		    .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER])
	    THEN
		BEGIN
		D[D_VER_COUNT] = 0;
		BBLOCK[D[D_NAME_DESC], DSC$W_LENGTH] = .R[DIR$B_NAMECOUNT];
		CH$MOVE(
		    .R[DIR$B_NAMECOUNT],
		    R[DIR$T_NAME],
		    .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER]);
		END;
	    NAME = R[DIR$B_NAMECOUNT];
	    VERSION = .V[DIR$W_VERSION];
	    DIR_VERLIMIT = .R[DIR$W_VERLIMIT];
	    N[NAM$W_FID_NUM] = .V[DIR$W_FID_NUM];
	    N[NAM$W_FID_SEQ] = .V[DIR$W_FID_SEQ];
	    N[NAM$W_FID_RVN] = .V[DIR$W_FID_RVN];
	    IF .N[NAM$B_FID_RVN] EQL 0
		THEN N[NAM$B_FID_RVN] = .BBLOCK[D[D_FID], FID$B_RVN];
	    END
	ELSE
	    BEGIN LOCAL T;
	    T = MAKE_STRING(.R, FILE_NAME[1]);
	    FILE_NAME[0] = CH$FIND_CH(.T, FILE_NAME[1], %C';') - FILE_NAME[1];
	    NAME = FILE_NAME;
	    VERSION = .R[NMB$W_VERSION];
	    N[NAM$W_FID_NUM] = .R[NMB$W_FID_NUM];
	    N[NAM$W_FID_SEQ] = .R[NMB$W_FID_SEQ];
	    N[NAM$W_FID_RVN] = 1;
	    END;


	! Initialize the resultant string in the name block.
	!
	RSA_DESC[0] = .N[NAM$B_RSS];
	RSA_DESC[1] = .N[NAM$L_RSA];
	$FAO(
	    $DESCRIPTOR('!AS[!AC]!AC;!UW'),
	    RSA_DESC,
	    RSA_DESC,
	    .DIR_DEV_DESC,
	    (IF .DIR_STRING[0] EQL 0 THEN MFD ELSE DIR_STRING),
	    .NAME,
	    .VERSION);
	N[NAM$B_RSL] = .RSA_DESC[0];
	INIT_NAMEBLOCK(.N);


	! Initialize the directory ID in the name block.
	!
	N[NAM$W_DID_NUM] = .BBLOCK[D[D_FID], FID$W_NUM];
	N[NAM$W_DID_SEQ] = .BBLOCK[D[D_FID], FID$W_SEQ];
	N[NAM$W_DID_RVN] = .BBLOCK[D[D_FID], FID$W_RVN];


	! Set the directory scan bits for the next iteration.
	!
	DIR_STATUS = 0;
	IF
	    .DIR_LEVELS LEQ D_K_NLEVELS-1 AND
	    (IF .N[NAM$B_TYPE] EQL 4
		THEN ..N[NAM$L_TYPE] EQL '.DIR'
		ELSE FALSE) AND
	    .VERSION EQL 1 AND
	    (.N[NAM$W_FID_NUM] NEQ FID$C_MFD OR
		.N[NAM$B_FID_NMX] NEQ 0)
	THEN
	    BEGIN
	    LOCAL
		STATUS,			! Status variable
	        DIR_DESC: VECTOR[2];	! Descriptor for new directory string


	    ! Note that this is a directory.
	    !
	    DIR_STATUS[D_STAT_VALID] = TRUE;


	    ! Generate the new directory string.  If this is not the top level,
	    ! append a dot, and then append the directory name.
	    !
	    DIR_DESC[0] = .DIR_STRING[0];
	    DIR_DESC[1] = DIR_STRING[1];
	    IF .DIR_DESC[0] NEQ 0
	    THEN
		BEGIN
		DIR_DESC[0] = .DIR_DESC[0] + 1;
		DIR_STRING[.DIR_DESC[0]] = %C'.';
		END;
	    CH$MOVE(
		.N[NAM$B_NAME],
		.N[NAM$L_NAME],
		DIR_STRING[.DIR_DESC[0]+1]);
	    DIR_DESC[0] = .DIR_DESC[0] + .N[NAM$B_NAME];


	    ! Temporarily push down the directory stack.
	    !
	    D = .D + D_S_ENTRY;


	    ! Allocate the dynamic areas for this level.
	    !
	    BBLOCK[D[D_TERM_DESC], DSC$A_POINTER] = GET_VM(DIR$S_NAME);
	    BBLOCK[D[D_NAME_DESC], DSC$A_POINTER] = GET_VM(DIR$S_NAME);


	    ! Match the directory specification against the pattern string to
	    ! determine if this directory should be scanned.  If it should not,
	    ! pop the directory stack.  Otherwise, finish initializing context.
	    !
	    IF .DIR_FLAGS[D_IMAGE_SCAN]
	    THEN
		STATUS = %B'11'
	    ELSE
		STATUS = MATCH_DIRECTORY(
		    DIR_DESC,
		    DIR_SEL_DIR,
		    D[D_TERM_DESC],
		    D[D_TERM_VER],
		    DIR_SEL_NTV);


	    IF .STATUS<1,1>
	    THEN
		BEGIN
		DIR_SP[D_DIR_SCAN] = DIR_STATUS[D_STAT_SCANNED] = TRUE;
		IF .STATUS
		    THEN D[D_DIR_MATCHES] = DIR_STATUS[D_STAT_FILE_SEL] = TRUE;
		END
	    ELSE
		BEGIN
		FREE_VM(DIR$S_NAME, .BBLOCK[D[D_TERM_DESC], DSC$A_POINTER]);
		FREE_VM(DIR$S_NAME, .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER]);
		CH$FILL(0, D_S_ENTRY, .D);
		END;


	    ! Pop the directory stack.
	    !
	    D = .DIR_SP;
	    END;


	! If this is image mode, the file always matches.
	!
	IF
	    .DIR_FLAGS[D_IMAGE_SCAN] AND
	    (NOT .DIR_FLAGS[D_SCANNED_DIRS] OR
		.N[NAM$W_FID_NUM] NEQ FID$C_MFD OR
		.N[NAM$B_FID_NMX] NEQ 0)
	THEN
	    BEGIN
	    IF .DIR_STATUS[D_STAT_VALID]
		THEN DIR_STATUS[D_STAT_DIR_SEL] = TRUE;
	    EXITLOOP;
	    END;


	! Test for scan termination.
	!
	IF
	    BEGIN
	    IF .DIR_STRUCLEV EQL 1
	    THEN
		.V GTRU .DIR_SCANLIMIT[.DIR_LEVELS-1] 
	    ELSE
		IF .BBLOCK[D[D_TERM_DESC], DSC$W_LENGTH] EQL 0
		THEN
		    FALSE
		ELSE
		    TERMINATE_SCAN(
			.NAME[0], NAME[1],
			.VERSION,
			.BBLOCK[D[D_TERM_DESC], DSC$W_LENGTH],
			.BBLOCK[D[D_TERM_DESC], DSC$A_POINTER],
			.D[D_TERM_VER])
	    END
	THEN
	    BEGIN
	    IF .DIR_FLAGS[D_HARD_STOP]
	    THEN
		BEGIN
		DIR_FLAGS[D_SCAN_FAILED] = TRUE;
		RETURN FALSE;
		END;


	    ! Adjust context to skip rest of this directory.
	    !
	    D[D_REC] = .D[D_BUF_LIM];
	    D[D_DIR_LEN] = 0;
	    END;


	! Match the selection file specification with the resultant string.
	!
	IF
	    .D[D_REC] LSSA .D[D_BUF_LIM] AND
	    .D[D_DIR_MATCHES] AND
	    (.DIR_SEL_LATEST GTR 0 OR .DIR_SEL_LATEST EQL .D[D_VER_COUNT]) AND
	    (NOT .DIR_FLAGS[D_SCANNED_DIRS] OR
		.N[NAM$W_FID_NUM] NEQ FID$C_MFD OR
		.N[NAM$B_FID_NMX] NEQ 0)
	THEN
	    BEGIN
	    LOCAL
		NTV_DESC:	VECTOR[2];	! Descriptor for n.t;v


	    ! Match the file specification.
	    !
	    NTV_DESC[0] = .N[NAM$L_RSA] + .N[NAM$B_RSL] - .N[NAM$L_NAME];
	    NTV_DESC[1] = .N[NAM$L_NAME];
	    IF MATCH_FILENAME(NTV_DESC, DIR_SEL_NTV)
	    THEN
		BEGIN
		IF .DIR_STATUS[D_STAT_VALID]
		    THEN DIR_STATUS[D_STAT_DIR_SEL] = TRUE;
		EXITLOOP;
		END;
	    END;


	! If scanned directories are requested, and the directory was not
	! selected above, return it anyway.
	!
	IF .DIR_FLAGS[D_SCANNED_DIRS] AND .D[D_DIR_SCAN]
	THEN
	    EXITLOOP;
	END;
    END;


TRUE
END;

GLOBAL ROUTINE FREE_DIR_DATA: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes the directory scan context.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	Directory scan context.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Directory scan context.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Free any dynamic storage that is currently allocated.
!
INCRA D FROM DIR_STACK TO DIR_STACK+D_K_NLEVELS*D_S_ENTRY-D_S_ENTRY BY D_S_ENTRY DO
    BEGIN
    MAP
	D:	REF BBLOCK;	! Pointer to directory stack entry

    IF .D[D_BUF_ADDR] NEQ 0
    THEN
	FREE_VM(.D[D_BUF_LEN], .D[D_BUF_ADDR]);
    IF .BBLOCK[D[D_TERM_DESC], DSC$A_POINTER] NEQ 0
    THEN
	FREE_VM(DIR$S_NAME, .BBLOCK[D[D_TERM_DESC], DSC$A_POINTER]);
    IF .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER] NEQ 0
    THEN
	FREE_VM(DIR$S_NAME, .BBLOCK[D[D_NAME_DESC], DSC$A_POINTER]);
    END;


! Reinitialize the impure storage.
!
CH$FILL(0, DIR_END-DIR_BEG, DIR_BEG);
END;

END
ELUDOM
