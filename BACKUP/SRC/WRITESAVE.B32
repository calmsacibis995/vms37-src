MODULE WRITESAVE(%TITLE	'Write Save Set'
		IDENT = 'V03-003'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!
!	This module contains routines to do the I/O involved in writing
!	save sets.
!
! ENVIRONMENT:
!
!	VAX/VMS user mode
!
!--
!
! AUTHOR:  Andrew C. Goldstein, CREATION DATE:  2-Sep-1980  19:17
!
! MODIFIED BY:
!
!	V03-003	ACG0289		Andrew C. Goldstein,	16-Apr-1982  16:33
!		Check for software write lock on tape
!
!	V03-002	ACG0276		Andrew C. Goldstein,	26-Mar-1982  19:07
!		Clean up size checking in seq disk save sets
!
!	V03-001	ACG0269		Andrew C. Goldstein,	22-Mar-1982  16:57
!		Use normal mode write in tape error rewrites
!
!	V02-015	ACG0257		Andrew C. Goldstein,	21-Jan-1982  18:51
!		Add support for lists of volume labels
!
!	V02-014	ACG0256		Andrew C. Goldstein,	19-Jan-1982  22:02
!		Add /PROTECTION and /OWNER to save set
!
!	V02-013	ACG0254		Andrew C. Goldstein,	19-Jan-1982  15:56
!		Use completion AST to detect EOT
!
!	V02-012	ACG0243		Andrew C. Goldstein,	21-Dec-1981  8:31
!		Detect EOT during write retries
!
!	V02-011	MLJ0054		Martin L. Jack,	31-Oct-1981  15:03
!		Implement network save sets.  Move STAACP globals to common.
!
!	V02-010	ACG0218		Andrew C. Goldstein,	1-Oct-1981  13:14
!		Inhibit normal write error recovery on /INTERCHANGE
!
!	V02-009	ACG0216		Andrew C. Goldstein,	4-Sep-1981  16:28
!		Fix spacing over empty files in /NOREWIND
!
!	V02-008	ACG0211		Andrew C. Goldstein,	20-Jul-1981  15:32
!		Implement sequential disk
!
!	V02-007	ACG209		Andrew C. Goldstein,	5-Jun-1981  15:23
!		Stop on excessive output error rate
!
!	V02-006	MLJ0025		Martin L. Jack,	8-May-1981  14:54
!		Reorganize qualifier database.  Move some global variables to
!		common.  Make routines non-global if possible.
!
!	V02-005	ACG0202		Andrew C. Goldstein,	23-Apr-1981  16:47
!		Fix handling of /SAVE on magtapes
!
!	V02-004	MLJ0020		Martin L. Jack,	20-Apr-1981  21:56
!		Implement /JOURNAL qualifier.
!
!	V02-003	MLJ0010		Martin L. Jack,	25-Mar-1981  15:23
!		Reorganize global storage.  Delete limiting of buffer count, as
!		COMMAND now does this.  Correct some references to OQUA_OUTP_FC
!		to be RWSV_SAVE_FAB.  Change OQUA_FILE to OQUA_SAVE.
!
!	V02-002	ACG0199		Andrew C. Goldstein,	9-Mar-1981  13:51
!		Fix reference to uninitialized RAB in WRITE_BLOCK
!
!	V02-001	ACG0187		Andrew C. Goldstein,	11-Feb-1981  19:34
!		Make unrecoverable save set write errors fatal
!
!**


LIBRARY	'SYS$LIBRARY:LIB';
REQUIRE	'SRC$:COMMON';
REQUIRE	'LIB$:BACKDEF.B32';

EXTERNAL LITERAL
	BACKUP$_OPENOUT,
	BACKUP$_FATALERR,
	BACKUP$_WRITEERR,
	BACKUP$_CLOSEOUT,
	BACKUP$_LABELERR,
	BACKUP$_MAXVOLS,
	BACKUP$_NOTANSI,
	BACKUP$_TAPEFULL,
	BACKUP$_CONTINUED,
	BACKUP$_DENSITY,
	BACKUP$_WRITERRS,
	BACKUP$_SAVSETCLU,
	BACKUP$_SOFTWERRS,
	BACKUP$_STARTVERIFY,
	BACKUP$_RESUME;


G$DEFINE();		! Define global common area

ROUTINE WRITE_AST (BCB, R0, R1, PC, PSL) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as a completion AST when a tape write
!	completes. It turns an EOT status into success and sets the
!	global EOT flag.
!
! CALLING SEQUENCE:
!	WRITE_AST (BCB, R0, R1, PC, PSL)
!
! INPUT PARAMETERS:
!	BCB: (AST parameter) - address of BCB for this operation
!	R0: R0 at time of AST
!	R1: R1 at time of AST
!	PC: PC at time of AST
!	PSL: PSL at time of AST
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	COM_FLAGS[COM_EOV]: set if EOT encountered
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	BCB		: REF BBLOCK;	! BCB argument

! Check for EOT status. Further qualification is not necessary since
! this routine is only invoked when writing tape.
!

IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFTAPE
THEN
    BEGIN
    COM_FLAGS[COM_EOV] = TRUE;
    BCB[BCB_IO_STATUS] = TRUE;
    END;

END;					! End of routine WRITE_AST

ROUTINE WRITE_ERROR (ERR_BCB) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles an error writing data to the output
!	save set.
!
! CALLING SEQUENCE:
!	WRITE_ERROR (ERR_BCB)
!
! INPUT PARAMETERS:
!	ERR_BCB: buffer control block on which the error occurred
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	INSQUE,
	REMQUE;

MAP
	ERR_BCB		: REF BBLOCK;	! BCB argument

LITERAL
	RETRY_COUNT	= 32;		! number of times to retry a write

LOCAL
	FAB		: REF BBLOCK,	! FAB of output file
	BCB		: REF BBLOCK,	! random BCB pointer
	TEMP1,				! temps to hold action routines
	TEMP2;

EXTERNAL ROUTINE
	WAIT,				! wait for I/O completion
	WRITE_BLOCK,			! write a buffer to output
	FREE_BUFFER,			! free a block buffer
	FILE_ERROR;			! signal file related error

! Asynchronous output errors are handled for tape and seq disk. What
! we do is first wait for completion of all pending writes, ignoring
! completion status, since they are now junk.
!

FAB = .RWSV_SAVE_FAB;
RWSV_OUT_ERRORS = .RWSV_OUT_ERRORS + 1;
IF NOT .BBLOCK[FAB[FAB$L_DEV], DEV$V_SQD]
OR .QUAL[QUAL_INTE]
THEN
    BEGIN
    FREE_BUFFER (.ERR_BCB);
    FILE_ERROR (BACKUP$_WRITEERR+STS$K_SEVERE, .FAB, .ERR_BCB[BCB_IO_STATUS]);
    RETURN;
    END;

UNTIL REMQUE (.OUTPUT_WAIT[0], BCB)
DO
    BEGIN
    TEMP1 = .BCB[BCB_SUCC_ACT];
    TEMP2 = .BCB[BCB_FAIL_ACT];
    BCB[BCB_SUCC_ACT] = 0;
    BCB[BCB_FAIL_ACT] = 0;
    WAIT (.BCB);
    BCB[BCB_SUCC_ACT] = .TEMP1;
    BCB[BCB_FAIL_ACT] = .TEMP2;
    INSQUE (.BCB, .RWSV_HOLD_LIST[1]);
    END;

! Iterate in the following loop until either we get the block in question
! written successfully or the operator gives up.
!
! Special case medium offline, since it clearly won't go away by itself.
! Check the output error rate. If it is excessive, complain.
!

WHILE TRUE
DO
    BEGIN
    IF .RWSV_OUT_ERRORS GTRU 100
    AND .RWSV_OUT_BLOCK_COUNT / .RWSV_OUT_ERRORS LSSU 10
    AND NOT .COM_FLAGS[COM_CONTINUE]
    THEN
	BEGIN
	INSQUE(.ERR_BCB, RWSV_HOLD_LIST[0]);
	FILE_ERROR (BACKUP$_WRITERRS, .FAB, .ERR_BCB[BCB_IO_STATUS]);
	COM_FLAGS[COM_CONTINUE] = TRUE;
	REMQUE (.ERR_BCB, BCB);
	END;

! Now attempt to rewrite the block in error. Wait for completion and
! check status; retry until it succeeds or we lose patience.
! Note that the first rewrite is done with error recovery inhibited,
! as are normal writes. After the first retry, we enable normal error
! recovery in the driver. The reason for this is that for some unknown
! reason, errors sometimes get "stuck" in the tape controller even
! though the tape is good. The driver's error retry sequence appears
! to clear them when simple transfer operations don't.
!

    DECR J FROM RETRY_COUNT TO 1
    DO
	BEGIN
	RWSV_OUT_BLOCK_COUNT = .RWSV_OUT_BLOCK_COUNT + 1;
	WRITE_BLOCK (.ERR_BCB, .J NEQ RETRY_COUNT);
	ERR_BCB[BCB_FAIL_ACT] = 0;
	REMQUE (.ERR_BCB, BCB);
	WAIT (.ERR_BCB);
	IF .ERR_BCB[BCB_IO_STATUS]
	THEN EXITLOOP;
	RWSV_OUT_ERRORS = .RWSV_OUT_ERRORS + 1;
	IF .ERR_BCB[BCB_IO_STATUS] EQL SS$_MEDOFL
	OR .ERR_BCB[BCB_IO_STATUS] EQL SS$_VOLINV
	THEN EXITLOOP;
	END;

    IF .ERR_BCB[BCB_IO_STATUS] THEN EXITLOOP;

    INSQUE (.ERR_BCB, RWSV_HOLD_LIST[0]);
    FILE_ERROR (BACKUP$_FATALERR, .FAB, .ERR_BCB[BCB_IO_STATUS]);
    REMQUE (.ERR_BCB, BCB);
    END;

! Now re-issue the writes on all the other buffers that were queued
! for write. The presumption is that if the above write finally
! succeeded, these will now, too.
!

UNTIL REMQUE (.RWSV_HOLD_LIST[0], BCB)
DO
    BEGIN
    RWSV_OUT_BLOCK_COUNT = .RWSV_OUT_BLOCK_COUNT + 1;
    WRITE_BLOCK (.BCB);
    END;

END;					! End of routine WRITE_ERROR

GLOBAL ROUTINE WRITE_BLOCK (BCB, RETRY) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine issues a write I/O for the specified buffer
!	onto the output save medium.
!
! CALLING SEQUENCE:
!	WRITE_BLOCK (BCB, RETRY)
!
! INPUT PARAMETERS:
!	BCB: buffer control block to be written
!	RETRY: (optional) 0 for normal no-retry tape write
!			  1 for write with error recovery enabled
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	ACTUALCOUNT,
	CRC,
	INSQUE;

MAP
	BCB		: REF BBLOCK;	! buffer control block arg

LOCAL
	STATUS,				! general status value
	HDR_SUM,			! CRC of block header
	BLOCK_SUM,			! CRC of entire block
	BUFFER		: REF BBLOCK,	! data buffer being written
	RAB		: REF BBLOCK,	! output RAB
	BLOCK_COUNT,			! number of blocks about to be written
	BLOCKS_ALLOC;			! blocks receiver from allocator

EXTERNAL ROUTINE
	FREE_BUFFER,			! free an I/O buffer
	SWITCH_VOLUME,			! switch to desired disk volume
	STA_EXTEND,			! extend save set file
	FILE_ERROR;			! signal file related error

! Set up pointers and compute the CRC's.
!

BUFFER = .BCB[BCB_BUFFER];
BUFFER[BBH$W_CHECKSUM] = 0;
BUFFER[BBH$L_CRC] = 0;
BLOCK_SUM = -1;
IF .QUAL[QUAL_CRC]
THEN CRC (RWSV_AUTODIN, %REF (-1), BCB[BCB_SIZE], .BUFFER, BLOCK_SUM)
ELSE BUFFER[BBH$V_NOCRC] = TRUE;

CRC (RWSV_CRC16, %REF (0), %REF (BBH$K_LENGTH), .BUFFER, HDR_SUM);
BUFFER[BBH$W_CHECKSUM] = .HDR_SUM;
BUFFER[BBH$L_CRC] = NOT .BLOCK_SUM;

! Issue the write I/O appropriate to the output medium.
!

BCB[BCB_SUCC_ACT] = 0;
BCB[BCB_FAIL_ACT] = WRITE_ERROR;

! Write through file system.
!

IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    RAB = RWSV_SAVE_FAB[FC_RAB];
    RAB[RAB$W_RSZ] = .BCB[BCB_SIZE];
    RAB[RAB$L_RBF] = .BUFFER;
    IF .RWSV_SAVE_FAB[FAB$V_BIO]
	THEN STATUS = $WRITE (RAB = .RAB)
	ELSE STATUS = $PUT (RAB = .RAB);
    IF NOT .STATUS
    THEN FILE_ERROR (BACKUP$_WRITEERR+STS$K_SEVERE,
		     .RWSV_SAVE_FAB, .RAB[RAB$L_STS], .RAB[RAB$L_STV]);
    FREE_BUFFER (.BCB);
    END

ELSE
    BEGIN

! Write to tape.
!

    IF .BBLOCK [RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_SQD]
    THEN
	BEGIN
	STATUS = $QIO  (CHAN = .RWSV_CHAN,
			FUNC = (IF .QUAL[QUAL_INTE]
				OR (IF ACTUALCOUNT () GEQU 2
				    THEN .RETRY
				    ELSE 0)
				THEN IO$_WRITELBLK
				ELSE IO$_WRITELBLK OR IO$M_INHRETRY),
			EFN  = BCB_S_WRITE,
			IOSB = BCB[BCB_IOSB],
			ASTADR = WRITE_AST,
			ASTPRM = .BCB,
			P1   = .BUFFER,
			P2   = .BCB[BCB_SIZE]
			);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_WRITEERR+STS$K_SEVERE,
			 .RWSV_SAVE_FAB, .STATUS);
	BCB[BCB_STATE] = BCB_S_WRITE;
	INSQUE (.BCB, .OUTPUT_WAIT[1]);
	END

! Write to sequential disk. Make sure space is available for both the
! current block, the next block, and the XOR block to follow. If the
! allocation fails, set EOV for force a volume switch before the next
! write.
!

    ELSE
	BEGIN
	CURRENT_MTL = .OUTPUT_MTL;
	SWITCH_VOLUME (.RWSV_VOL_NUMBER);
	BLOCK_COUNT = (.BCB[BCB_SIZE]+511) / 512;
	WHILE .RWSV_ALLOC LSSU
	    (IF .QUAL[QUAL_GROU_VALUE] NEQ 0
	     THEN .BLOCK_COUNT * 4
	     ELSE .BLOCK_COUNT * 3)
	DO
	    BEGIN
	    STATUS = STA_EXTEND (1^30, BLOCKS_ALLOC);
	    IF .STATUS
	    THEN
		RWSV_ALLOC = .RWSV_ALLOC + .BLOCKS_ALLOC
	    ELSE
		BEGIN
		COM_FLAGS[COM_EOV] = 1;
		EXITLOOP;
		END;
	    END;

	STATUS = S$QIO (CHAN = .RWSV_CHAN,
			FUNC = IO$_WRITEVBLK,
			EFN  = BCB_S_WRITE,
			IOSB = BCB[BCB_IOSB],
			P1   = .BUFFER,
			P2   = .BCB[BCB_SIZE],
			P3   = .RWSV_OUT_VBN
			);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_WRITEERR+STS$K_SEVERE,
			 .RWSV_SAVE_FAB, .STATUS);
	BCB[BCB_STATE] = BCB_S_WRITE;
	INSQUE (.BCB, .OUTPUT_WAIT[1]);
	RWSV_OUT_VBN = .RWSV_OUT_VBN + .BLOCK_COUNT;
	RWSV_ALLOC = .RWSV_ALLOC - .BLOCK_COUNT;
	END;
    END;

END;					! End of routine WRITE_BLOCK

ROUTINE INIT_SAVE_DISK (CONTINUE) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes an output disk volume for use as an
!	offline save set disk.
!
! CALLING SEQUENCE:
!	INIT_SAVE_DISK ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	disk initialized, corresponding VCB altered
!
!--

BEGIN

BUILTIN
	FFC;

BIND

! Home block file format string.
!

	FORMAT_DESC	= $DESCRIPTOR ('DECFILE11B') : VECTOR,

! Template attribute control list for create operation.
!

	ATTCTL_TEMPLATE	= UPLIT (
				WORD (ATR$S_SEGNUM, ATR$C_SEGNUM), LONG (0),
				WORD (ATR$S_UIC, ATR$C_UIC), LONG (0),
				WORD (ATR$S_FPRO, ATR$C_FPRO), LONG (0),
				WORD (ATR$S_CREDATE, ATR$C_CREDATE), LONG (0),
				WORD (ATR$S_REVDATE, ATR$C_REVDATE), LONG (0),
				WORD (2, ATR$C_ASCDATES), LONG (0),
				LONG (0)
				);

! Entries in the attribute control vector.
!

MACRO
	ATT_POINTER (N) = ATT_CONTROL[N*2+1] %;

LITERAL
	ATT_SEGNUM	= 0,
	ATT_UIC		= 1,
	ATT_PROT	= 2,
	ATT_CREDATE	= 3,
	ATT_REVDATE	= 4,
	ATT_REVNUM	= 5,
	ATCTL_LENGTH	= 6*8 + 4;

LOCAL
	MOUNT_MODE,			! mode in which to mount output disk
	STATUS,				! general status value
	FAO_DESC	: VECTOR [2],	! string descriptor for FAO
	IO_STATUS	: VECTOR [4, WORD], ! I/O status block
	FAB		: REF BBLOCK,	! FAB for save set file
	NAM		: REF BBLOCK,	! NAMe block for same
	VCB		: REF BBLOCK,	! VCB for volume
	DEVICE_CHAR	: BBLOCK [DIB$K_LENGTH], ! device characteristics buffer
	DEVCHAR_DESC	: VECTOR [2],	! descriptor for above
	LP		: REF BBLOCK,	! structure pointer
	P,				! byte pointer into index file bitmap
	B,				! bit pointer into index file bitmap
	FILE_NUMBER,			! free file number found
	FIB		: BBLOCK [FIB$C_LENGTH], ! FIB for create call
	FIB_DESC	: VECTOR [2],	! descriptor for above
	NAME_DESC	: VECTOR [2],	! file name descriptor
	ATT_CONTROL	: VECTOR [ATCTL_LENGTH/4], ! attribute control list
	FILE_PROT,			! file protection attribute
	REVNUM;				! file revision number attribute

EXTERNAL ROUTINE
	STA_MOUNT,			! mount save set disk volume set
	READY_DISK,			! ready save set disk volume
	FILE_ERROR,			! signal file related error
	SWITCH_VOLUME,			! switch to specified volume
	INITIALIZE_VOLUME,		! init volume from summary parameters
	STA_ENTER,			! make directory entry
	READ_HEADER;			! read file header block


! On the initial setup, prepare the mounted volume list and VCB's
! for the save set volumes.
!

MOUNT_MODE = 1;
IF NOT .CONTINUE
THEN
    BEGIN
    RWSV_OUT_VBN = 1;
    IF NOT .QUAL[QUAL_INIT] THEN MOUNT_MODE = 3;
    END;

! Find the VCB and set up context
!

VCB = READY_DISK (.MOUNT_MODE);
VCB[VCB_SAVESET] = TRUE;
IF NOT .CONTINUE
AND .QUAL[QUAL_INIT]
THEN VCB[VCB_NOTVOLSET] = TRUE;

! Get the output volume label. This comes from the disk if we are not
! initializing it; otherwise it comes from the command (either save set
! file name or /LABEL). The save set name in raw form also becomes the
! volume set name. Then append the volume number as two digits to the
! volume name if it did not come explicitly.
!

LP = 0;
IF .QUAL[QUAL_INIT]
OR .CONTINUE
OR .VCB[VCB_NOTVOLSET]
THEN
    BEGIN
    CH$COPY (.BBLOCK[RWSV_SAVE_FAB[FC_NAM], NAM$B_NAME],
	     .BBLOCK[RWSV_SAVE_FAB[FC_NAM], NAM$L_NAME],
	     ' ', 12, RWSV_VOLUME_ID);

    IF NOT .CONTINUE
    THEN
	BEGIN
	CH$MOVE (HM2$S_VOLNAME, RWSV_VOLUME_ID, OUTPUT_MTL[MTL_STRUCNAME]);
	CH$MOVE (HM2$S_VOLNAME, RWSV_VOLUME_ID, COM_O_STRUCNAME);
	END;

! If an explicit label was specified, get it. Use the segment number
! to pick the right entry from the label list. If we are out of list,
! use the first entry and append the volume number.
!

    IF .QUAL[QUAL_LABE]
    THEN
	BEGIN
	LP = .QUAL[QUAL_LABE_LIST];
	DECR J FROM .RWSV_SEG_NUMBER TO 1
	DO
	    BEGIN
	    LP = .LP[QUAL_NEXT];
	    IF .LP EQL 0 THEN EXITLOOP;
	    END;
	IF .LP NEQ 0
	THEN CH$MOVE (VL1$S_VOLLBL, LP[QUAL_LABE_VALUE], RWSV_VOLUME_ID)
	ELSE CH$MOVE (VL1$S_VOLLBL, BBLOCK [.QUAL[QUAL_LABE_LIST], QUAL_LABE_VALUE], RWSV_VOLUME_ID);
	END;
    END
ELSE
    BEGIN
    CH$MOVE (HM2$S_VOLNAME, OUTPUT_MTL[MTL_STRUCNAME], COM_O_STRUCNAME);
    END;

IF NOT .QUAL[QUAL_INIT]
AND NOT .CONTINUE
THEN
    BEGIN
    IF .VCB[VCB_CLUSTER] NEQ 1
    THEN SIGNAL (BACKUP$_SAVSETCLU);
    CH$MOVE (12, VCB[VCB_VOLNAME], RWSV_VOLUME_ID);
    RWSV_VOL_NUMBER = .VCB[VCB_RVN];
    END;

IF .LP EQL 0
THEN
    BEGIN
    P = CH$FIND_CH (HM2$S_VOLNAME-2, RWSV_VOLUME_ID, ' ');
    IF CH$FAIL (.P)
    THEN P = RWSV_VOLUME_ID + HM2$S_VOLNAME - 2;
    FAO_DESC[0] = 2;
    FAO_DESC[1] = .P;
    $FAO ($DESCRIPTOR ('!2ZL'),
	  0,
	  FAO_DESC,
	  .RWSV_VOL_NUMBER
	  );
    END;

! Do the remaining setup for initialization.
!

IF .QUAL[QUAL_INIT] OR .CONTINUE
THEN
    BEGIN
    OUTPUT_MTL[MTL_STRUCLEV] = 2;
    VCB[VCB_ODS_2] = TRUE;

    DEVCHAR_DESC[0] = DIB$K_LENGTH;
    DEVCHAR_DESC[1] = DEVICE_CHAR;
    $GETCHN (CHAN = .VCB[VCB_CHAN], PRIBUF = DEVCHAR_DESC[0]);

! Initialize the attributes buffer and call the initialize routine.
!

    CH$FILL (0, VSR_LENGTH, OUTPUT_ATTBUF);
    (OUTPUT_ATTBUF[VSR_VOLNAME]) = HM2$S_VOLNAME;
    (OUTPUT_ATTBUF[VSR_VOLNAME])+4 = RWSV_VOLUME_ID;
    (OUTPUT_ATTBUF[VSR_OWNERNAME]) = 12;
    (OUTPUT_ATTBUF[VSR_OWNERNAME])+4 = JPI_USERNAME;
    (OUTPUT_ATTBUF[VSR_FORMAT]) = .FORMAT_DESC[0];
    (OUTPUT_ATTBUF[VSR_FORMAT])+4 = .FORMAT_DESC[1];
    (OUTPUT_ATTBUF[VSR_VOLDATE]) = .JPI_DATE[0];
    (OUTPUT_ATTBUF[VSR_VOLDATE])+4 = .JPI_DATE[1];
    OUTPUT_ATTBUF[VSR_VOLOWNER] = (IF .QUAL[QUAL_O_OWN_UIC]
				   THEN .QUAL[QUAL_O_OWN_VALU]
				   ELSE .JPI_UIC);
    OUTPUT_ATTBUF[VSR_MAXFILES] = 1000;
    OUTPUT_ATTBUF[VSR_MAXFILNUM] = (IF .DEVICE_CHAR[DIB$L_MAXBLOCK] LSSU 4096
				    THEN 16
				    ELSE 50);
    OUTPUT_ATTBUF[VSR_VOLSTRUCT] = 2^8+1;
    OUTPUT_ATTBUF[VSR_RVN] = .RWSV_VOL_NUMBER;
    IF .RWSV_VOL_NUMBER EQL 1
    THEN OUTPUT_ATTBUF[VSR_RVN] = 0;
    OUTPUT_ATTBUF[VSR_PROTECT] = (IF .QUAL[QUAL_PROT]
				  THEN .QUAL[QUAL_PROT_VALUE]
				  ELSE %X'0000');
    OUTPUT_ATTBUF[VSR_FILEPROT] = %X'FF00';
    OUTPUT_ATTBUF[VSR_EXTEND] = 5;
    OUTPUT_ATTBUF[VSR_CLUSTER] = 1;
    OUTPUT_ATTBUF[VSR_RESFILES] = 9;
    OUTPUT_ATTBUF[VSR_WINDOW] = 7;
    OUTPUT_ATTBUF[VSR_LRU_LIM] = 3;

    INITIALIZE_VOLUME (.VCB, DEVICE_CHAR);
    END;

! Now create the save set file. Search the index file bitmap for an
! available file number; we assume 1 for a sequence number.
! On continuation volumes, we use the continuation file ID instead.
!

FAB = .RWSV_SAVE_FAB;
NAM = .FAB[FAB$L_NAM];
FAB[FAB$L_STS] = 1;
FAB[FAB$L_STV] = STA_OUT_CHAN;

IF .CONTINUE
THEN
    BEGIN
    NAM[NAM$W_FID_NUM] = FID$C_CONTIN;
    NAM[NAM$W_FID_SEQ] = FID$C_CONTIN;
    NAM[NAM$W_FID_RVN] = .RWSV_VOL_NUMBER;
    END

ELSE
    BEGIN
    P = CH$FIND_NOT_CH (.VCB[VCB_MAXFILIDX]/8, .VCB[VCB_IMAP], %X'FF');
    IF CH$FAIL (.P)
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB, SS$_IDXFILEFULL);
    FFC (%REF (0), %REF (8), .P, B);
    FILE_NUMBER = (.P - .VCB[VCB_IMAP]) * 8 + .B + 1;
    IF .FILE_NUMBER GTRU .VCB[VCB_MAXFILIDX]
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB, SS$_IDXFILEFULL);

! Set up the name block and then attempt to read the header block,
! to make sure it is present. Then make the directory entry.
!

    NAM[NAM$W_FID_NUM] = .FILE_NUMBER;
    NAM[NAM$W_FID_SEQ] = 1;
    NAM[NAM$B_FID_NMX] = .FILE_NUMBER<16,8>;
    NAM[NAM$B_FID_RVN] = .RWSV_VOL_NUMBER;
    END;

NAM[NAM$W_DID_NUM] = 4;
NAM[NAM$W_DID_SEQ] = 4;
NAM[NAM$W_DID_RVN] = .RWSV_VOL_NUMBER;

STATUS = READ_HEADER (NAM[NAM$W_FID], .OUTPUT_MTL[MTL_HEADER]);
IF NOT .STATUS
AND .STATUS NEQ SS$_NOSUCHFILE
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB, SS$_IDXFILEFULL);

STA_ENTER (.FAB);

! Now set up the FIB, name descriptor, and attribute list and create
! the file.
!

FIB_DESC[0] = FIB$C_LENGTH;
FIB_DESC[1] = FIB;
CH$FILL (0, FIB$C_LENGTH, FIB);
FIB[FIB$B_WSIZE] = 80;
FIB[FIB$W_FID_NUM] = .NAM[NAM$W_FID_NUM];
FIB[FIB$W_FID_SEQ] = .NAM[NAM$W_FID_SEQ];
FIB[FIB$W_FID_RVN] = .NAM[NAM$W_FID_RVN];
FIB[FIB$W_DID_NUM] = 4;
FIB[FIB$W_DID_SEQ] = 4;
FIB[FIB$W_DID_RVN] = 0;
FIB[FIB$L_EXVBN] = .RWSV_OUT_VBN;

NAME_DESC[0] = .NAM[NAM$B_NAME] + .NAM[NAM$B_TYPE] + .NAM[NAM$B_VER];
NAME_DESC[1] = .NAM[NAM$L_NAME];

CH$MOVE (ATCTL_LENGTH, ATTCTL_TEMPLATE, ATT_CONTROL);
ATT_POINTER[ATT_SEGNUM] = RWSV_SEG_NUMBER;
ATT_POINTER[ATT_UIC] = (IF .QUAL[QUAL_O_OWN_UIC]
		        THEN QUAL[QUAL_O_OWN_VALU]
		        ELSE JPI_UIC);
ATT_POINTER[ATT_PROT] = FILE_PROT;
ATT_POINTER[ATT_CREDATE] = JPI_DATE;
ATT_POINTER[ATT_REVDATE] = JPI_DATE;
ATT_POINTER[ATT_REVNUM] = REVNUM;
FILE_PROT = (IF .QUAL[QUAL_PROT]
	     THEN .QUAL[QUAL_PROT_VALUE]
	     ELSE %X'FA00');
REVNUM = 1;

STATUS = S$QIOW (CHAN = STA_OUT_CHAN,
		 IOSB = IO_STATUS,
		 FUNC = IO$_CREATE OR IO$M_CREATE OR IO$M_ACCESS,
		 P1   = FIB_DESC,
		 P2   = NAME_DESC,
		 P5   = ATT_CONTROL
		 );
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB, .STATUS);

RWSV_ALLOC = 0;
RWSV_IN_VBN_0 = .RWSV_OUT_VBN;

END;					! End of routine INIT_SAVE_DISK

ROUTINE INIT_SAVE_TAPE (CONTINUE) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes a magtape for an output save set.
!
! CALLING SEQUENCE:
!	INIT_SAVE_TAPE (CONTINUE)
!
! INPUT PARAMETERS:
!	CONTINUE: FALSE if this is a new save set
!		  TRUE if this is for the next continuation volume
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	FAB		: REF BBLOCK,	! pointer to output FAB
	STATUS,				! the usual status value
	TAPE_CHAR	: BBLOCK [4],	! magtape characteristics longword
	LABEL_BUFFER	: BBLOCK [80];	! buffer for tape labels

EXTERNAL ROUTINE
	READY_TAPE,			! make tape ready for I/O
	REWIND,				! rewind tape
	SENSE_CHAR,			! sense magtape characteristics
	SET_CHAR,			! set magtape characteristics
	SKIP_TM,			! skip tape marks
	SKIP_RECORD,			! skip tape record
	READ_LABEL,			! read file header label
	MAKE_VOL1,			! generate volume header label
	MAKE_HDR1,			! generate file header label 1
	MAKE_HDR2,			! generate file header label 2
	WRITE_LABEL,			! write file header label
	WRITE_TM,			! write tape mark
	FILE_ERROR,			! signal file related error
	LIB$CVT_DTB	: ADDRESSING_MODE (GENERAL);
					! convert decimal string to binary

! Set up the output tape.
!

FAB = .RWSV_SAVE_QUAL[QUAL_PARA_FC];
TAPE_CHAR = READY_TAPE (TRUE);

! If rewind is requested, do so and create the volume header label.
!

IF .QUAL[QUAL_REWI] OR .CONTINUE
THEN
    BEGIN
    REWIND ();
    IF NOT .CONTINUE THEN RWSV_FILE_NUMBER = 1;
    IF .QUAL[QUAL_DENS] OR .CONTINUE
    THEN
	BEGIN
	TAPE_CHAR = SENSE_CHAR ();
	TAPE_CHAR[MT$V_DENSITY] = .QUAL[QUAL_DENS_VALUE];
	SET_CHAR (.TAPE_CHAR);
	END;

    MAKE_VOL1 (LABEL_BUFFER);
    CH$COPY(VL1$S_VOLLBL, LABEL_BUFFER[VL1$T_VOLLBL], %C' ', 12, RWSV_VOLUME_ID);
    WRITE_LABEL (LABEL_BUFFER);

    IF .QUAL[QUAL_DENS] OR .CONTINUE
    THEN
	BEGIN
	TAPE_CHAR = SENSE_CHAR ();
	IF .TAPE_CHAR[MT$V_DENSITY] NEQ .QUAL[QUAL_DENS_VALUE]
	THEN FILE_ERROR (BACKUP$_DENSITY, .FAB);
	END;
    END

! Otherwise space to the end of tape and verify that we can actually
! append to it. Note that the "infinite" skip call will terminate on
! two consecutive tape marks, which could be either real EOV or an
! empty file. We tell what's what by the labels. Note that a read is
! necessary to advance over the double tape marks of an empty file.
!

ELSE
    BEGIN
    WHILE TRUE
    DO
	BEGIN
	SKIP_TM (32767);
	TAPE_CHAR = SENSE_CHAR ();
	IF .TAPE_CHAR[MT$V_EOT]
	THEN FILE_ERROR (BACKUP$_TAPEFULL, .FAB);

	SKIP_TM (-2);
	TAPE_CHAR = SENSE_CHAR ();
	IF NOT .TAPE_CHAR[MT$V_BOT]
	THEN
	    BEGIN
	    SKIP_RECORD (1);
	    STATUS = READ_LABEL (LABEL_BUFFER);
	    IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);
	    IF .LABEL_BUFFER[HD1$L_HD1LID] EQL 'EOF1'
	    THEN EXITLOOP;
	    IF .LABEL_BUFFER[HD1$L_HD1LID] EQL 'EOV1'
	    THEN FILE_ERROR (BACKUP$_CONTINUED, .FAB);
	    IF .LABEL_BUFFER[HD1$L_HD1LID] NEQ 'HDR1'
	    THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
	    END;
	SKIP_TM (1);
	SKIP_RECORD (1);
	END;				! end of EOV search loop

! Get the file set ID and file number from the EOT label, so
! we can correctly generate the new header label. Then position to the
! end of the label set. If the file number in the label is zero, this
! is a freshly initialized tape. In this case, rewind and read VOL1
! to position to where we will create HDR1, so the dummy file will
! be overwritten.
!

    CH$MOVE (HD1$S_FILESETID, LABEL_BUFFER[HD1$T_FILESETID], RWSV_FILESET_ID);
    IF NOT LIB$CVT_DTB (4, LABEL_BUFFER[HD1$T_FILESEQNO], RWSV_FILE_NUMBER)
    THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);

    IF .RWSV_FILE_NUMBER EQL 0
    THEN
	BEGIN
	REWIND ();
	STATUS = READ_LABEL (LABEL_BUFFER, 'VOL1');
	IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);
	CH$COPY(VL1$S_VOLLBL, LABEL_BUFFER[VL1$T_VOLLBL], %C' ', 12, RWSV_VOLUME_ID);
	END
    ELSE
	SKIP_TM (1);
    RWSV_FILE_NUMBER = .RWSV_FILE_NUMBER + 1;
    END;

QUAL[QUAL_DENS_VALUE] = .TAPE_CHAR[MT$V_DENSITY];

! Now write file header labels.
!

MAKE_HDR1 (LABEL_BUFFER);
WRITE_LABEL (LABEL_BUFFER);

MAKE_HDR2 (LABEL_BUFFER);
WRITE_LABEL (LABEL_BUFFER);

WRITE_TM ();

END;					! End of routine INIT_SAVE_TAPE

GLOBAL ROUTINE INIT_OUT_SAVE (CONTINUE) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes the output save set.
!
! CALLING SEQUENCE:
!	INIT_OUT_SAVE (CONTINUE)
!
! INPUT PARAMETERS:
!	CONTINUE: FALSE if this is a new save set
!		  TRUE if this is for the next continuation volume
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	FAB		: REF BBLOCK,	! pointer to output FAB
	RAB		: REF BBLOCK,	! pointer to output RAB
	PROT_XAB	: $XABPRO_DECL,	! protection XAB for file creates
	STATUS;				! the usual status value

EXTERNAL ROUTINE
	EXTRACT_FILENAME,		! extract file name from file string
	FILE_ERROR;			! signal file related error

! Do common setup. Get the next device spec in the list. If first
! time or end of list, start at the beginning.
!

IF .RWSV_SAVE_QUAL NEQ 0 THEN RWSV_SAVE_QUAL = .RWSV_SAVE_QUAL[QUAL_NEXT];
IF .RWSV_SAVE_QUAL EQL 0 THEN RWSV_SAVE_QUAL = .QUAL[QUAL_OUTP_LIST];
RWSV_SAVE_FAB = FAB = .RWSV_SAVE_QUAL[QUAL_PARA_FC];

IF NOT .CONTINUE
THEN
    BEGIN
    RWSV_SEG_NUMBER = -1;
    RWSV_VOL_NUMBER = 0;
    RWSV_IN_GROUP_SIZE = RWSV_XORSIZE = .QUAL[QUAL_GROU_VALUE];
    END;
RWSV_OUT_ERRORS = 0;
RWSV_OUT_BLOCK_COUNT = 0;
RWSV_OUT_GROUP_COUNT = 0;
RWSV_VOL_NUMBER = .RWSV_VOL_NUMBER + 1;
RWSV_SEG_NUMBER = .RWSV_SEG_NUMBER + 1;

! Open the save set file through RMS.
!

FAB[FAB$V_NAM] = TRUE;
IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    FAB[FAB$V_PUT] = TRUE;
    FAB[FAB$V_SUP] = TRUE;
    FAB[FAB$W_MRS] = .QUAL[QUAL_BLOC_VALUE];
    FAB[FAB$B_ORG] = FAB$C_SEQ;
    FAB[FAB$B_RAT] = 0;
    FAB[FAB$B_RFM] = FAB$C_FIX;
    IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
    THEN FAB[FAB$W_BLS] = .QUAL[QUAL_BLOC_VALUE];

    $XABPRO_INIT (XAB = PROT_XAB);
    PROT_XAB[XAB$W_PRO] = -1;
    IF .QUAL[QUAL_O_OWN_UIC]
    THEN PROT_XAB[XAB$L_UIC] = .QUAL[QUAL_O_OWN_VALU];
    IF .QUAL[QUAL_PROT]
    THEN PROT_XAB[XAB$W_PRO] = .QUAL[QUAL_PROT_VALUE];
    FAB[FAB$L_XAB] = PROT_XAB;
    END
ELSE
    FAB[FAB$V_UFO] = TRUE;

IF .QUAL[QUAL_SS_FILE]
OR .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
THEN
    BEGIN
    IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_NET]
    THEN
	FAB[FAB$V_BIO] = FAB[FAB$V_SQO] = TRUE;

    STATUS = $CREATE (FAB = .FAB);
    FAB[FAB$L_XAB] = 0;
    IF NOT .STATUS
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB,
		     .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
    IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SWL]
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB, SS$_WRITLCK);
    END
ELSE
    INIT_SAVE_DISK (.CONTINUE);

IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    RAB = FAB[FC_RAB];
    STATUS = $CONNECT (RAB = .RAB);
    IF NOT .STATUS
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .FAB,
		     .RAB[RAB$L_STS], .RAB[RAB$L_STV]);
    END
ELSE
    RWSV_CHAN = .FAB[FAB$L_STV];

IF NOT .CONTINUE
THEN EXTRACT_FILENAME (.FAB, COM_SSNAME);

! Set up the output if it is a  tape.
!

IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
AND NOT .QUAL[QUAL_SS_FILE]
THEN
    INIT_SAVE_TAPE (.CONTINUE);

END;					! End of routine INIT_OUT_SAVE

GLOBAL ROUTINE WRITE_BUFFER (BCB) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes the indicated buffer to the output save set.
!
! CALLING SEQUENCE:
!	WRITE_BUFFER (BCB)
!
! INPUT PARAMETERS:
!	BCB: address of buffer control block
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	INSQUE,
	CRC;				! compute CRC instruction

MAP
	BCB		: REF BBLOCK;	! buffer control block arg

LOCAL
	STATUS,				! general status value
	RAB		: REF BBLOCK,	! output RAB
	BUFFER		: REF BBLOCK,	! I/O buffer
	XOR_BUFFER	: REF BBLOCK,	! XOR accumulation buffer
	P1,				! buffer pointer
	P2;				! buffer pointer

EXTERNAL ROUTINE
	GET_BUFFER,			! get an I/O buffer
	FREE_BUFFER;			! free an I/O buffer

! Do the block preamble formatting.
!

BUFFER = .BCB[BCB_BUFFER];
CH$FILL (0, $BYTEOFFSET (BBH$W_FID), .BUFFER);
CH$FILL (0, BBH$K_LENGTH - $BYTEOFFSET (BBH$T_RESERVED2), BUFFER[BBH$T_RESERVED2]);
BUFFER[BBH$W_SIZE] = BBH$K_LENGTH;
BUFFER[BBH$W_OPSYS] = BACKUP$K_OPSYS;
BUFFER[BBH$W_SUBSYS] = BACKUP$K_BACKUP;
BUFFER[BBH$W_APPLIC] = BACKUP$K_DATABLOCK;
RWSV_OUT_SEQ = .RWSV_OUT_SEQ + 1;
RWSV_OUT_BLOCK_COUNT = .RWSV_OUT_BLOCK_COUNT + 1;
BUFFER[BBH$L_NUMBER] = .RWSV_OUT_SEQ;
BUFFER[BBH$W_STRUCLEV] = BBH$K_LEVEL1;
BUFFER[BBH$W_VOLNUM] = .RWSV_VOL_NUMBER;
BUFFER[BBH$L_BLOCKSIZE] = .BCB[BCB_SIZE];
(BUFFER[BBH$T_SSNAME])<0,8> =.COM_SSNAME[DSC$W_LENGTH];
CH$COPY (.COM_SSNAME[DSC$W_LENGTH],
	.COM_SSNAME[DSC$A_POINTER],
	0,
	BBH$S_SSNAME-1,
	BUFFER[BBH$T_SSNAME]+1);

! Accumulate the block into the running XOR. If the is the first block
! of a group, we have to allocate a new buffer.
!

IF .QUAL[QUAL_GROU_VALUE] NEQ 0
THEN
    BEGIN
    IF .RWSV_OUT_GROUP_COUNT EQL 0
    THEN
	BEGIN
	RWSV_XOR_BCB = GET_BUFFER ();
	XOR_BUFFER = .RWSV_XOR_BCB[BCB_BUFFER];
	CH$MOVE (.BCB[BCB_SIZE], .BUFFER, .XOR_BUFFER);
	XOR_BUFFER[BBH$W_APPLIC] = BACKUP$K_XORBLOCK;
	END
    ELSE
	BEGIN
	XOR_BUFFER = .RWSV_XOR_BCB[BCB_BUFFER];
	P1 = .BUFFER + BBH$K_COMMON;
	P2 = .XOR_BUFFER + BBH$K_COMMON;
	DECR J FROM (.BCB[BCB_SIZE]-BBH$K_COMMON)/16 TO 1
	DO
	    BEGIN
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    END;
	END;
    END;

! Finally write the block.
!

WRITE_BLOCK (.BCB);

! Bump the group count; if the group is full, write the XOR block.
! We do not write the XOR block if we are into EOV, since one is
! about to be written by FIN_OUT_SAVE anyway. In the boundary case,
! this means that we can end up with an XOR group of n+1 blocks,
! rather than another XOR group of one block. This gambit reduces by
! one the maximum number of blocks written after COM_EOV is raised.
!

IF .QUAL[QUAL_GROU_VALUE] NEQ 0
THEN
    BEGIN
    RWSV_OUT_GROUP_COUNT = .RWSV_OUT_GROUP_COUNT + 1;
    IF .RWSV_OUT_GROUP_COUNT GEQU .QUAL[QUAL_GROU_VALUE]
    AND NOT .COM_FLAGS[COM_EOV]
    THEN
	BEGIN
	RWSV_OUT_SEQ = .RWSV_OUT_SEQ + 1;
	RWSV_OUT_BLOCK_COUNT = .RWSV_OUT_BLOCK_COUNT + 1;
	XOR_BUFFER[BBH$L_NUMBER] = .RWSV_OUT_SEQ;
	WRITE_BLOCK (.RWSV_XOR_BCB);
	RWSV_OUT_GROUP_COUNT = 0;
	RWSV_XOR_BCB = 0;
	END;
    END;

END;					! End of routine WRITE_BUFFER

GLOBAL ROUTINE FIN_OUT_SAVE (CONTINUE) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine completes the writing of the output save set.
!
! CALLING SEQUENCE:
!	FIN_OUT_SAVE (CONTINUE)
!
! INPUT PARAMETERS:
!	CONTINUE: FALSE if this is the real end of the save set
!		  TRUE if this is the end of a save set volume
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	ROT,
	INSQUE,
	REMQUE;

LOCAL
	STATUS,				! general status value
	IO_STATUS	: VECTOR [4, WORD], ! I/O status block
	BCB		: REF BBLOCK,	! pointer to buffer control block
	XOR_BUFFER	: REF BBLOCK,	! buffer holding XOR block
	FAB		: REF BBLOCK,	! output FAB
	LABEL_BUFFER	: BBLOCK [80],	! buffer for tape labels
	DESCRIPTOR	: VECTOR [2],	! descriptor for above
	BLOCKS_ALLOC,			! blocks allocated or returned
	VCB		: REF BBLOCK,	! VCB of current disk volume
	RECATTR		: BBLOCK [FAT$C_LENGTH], ! record attributes buffer
	CONTINUE_FID	: BBLOCK [FID$C_LENGTH], ! save set extension file ID
	ATT_CONTROL	: BBLOCK [20];	! attribute control list

BIND
	ATT_CONTROL1	= ATT_CONTROL + 0 : BBLOCK,
	ATT_CONTROL2	= ATT_CONTROL + 8 : BBLOCK,
	ATTR_END	= ATT_CONTROL + 16;

EXTERNAL ROUTINE
	WAIT,				! wait for I/O completion
	FILE_ERROR,			! signal file related error
	FREE_BUFFER,			! free an I/O buffer
	GET_BUFFER,			! allocate an I/O buffer
	SWITCH_VOLUME,			! switch to desired disk volume
	STA_EXTEND,			! extend (or truncate) save set file
	STA_DISMOUNT_OUTPUT,		! dismount output disk volume
	STA_DISMOUNT,			! complete dismount
	INIT_IN_SAVE,			! initialize input save set
	READY_NEXT_VOLUME,		! set up continuation volume for input
	SAVE_VERIFY_REEL,		! verify a save set volume
	FIN_IN_SAVE,			! finish input save set
	UNLOAD,				! unload a tape volume
	SKIP_TM,			! skip tape marks
	MAKE_HDR1,			! generate file header label 1
	MAKE_HDR2,			! generate file header label 2
	WRITE_LABEL,			! write file header label
	WRITE_TM;			! write tape mark

! Write the final XOR block.
!

IF .RWSV_OUT_GROUP_COUNT NEQ 0
THEN
    BEGIN
    XOR_BUFFER = .RWSV_XOR_BCB[BCB_BUFFER];
    RWSV_OUT_SEQ = .RWSV_OUT_SEQ + 1;
    RWSV_OUT_BLOCK_COUNT = .RWSV_OUT_BLOCK_COUNT + 1;
    XOR_BUFFER[BBH$L_NUMBER] = .RWSV_OUT_SEQ;
    WRITE_BLOCK (.RWSV_XOR_BCB);
    RWSV_XOR_BCB = 0;
    RWSV_OUT_GROUP_COUNT = 0;
    END;

! Wait for all pending writes to complete.
!

UNTIL REMQUE (.OUTPUT_WAIT[0], BCB)
DO
    BEGIN
    WAIT (.BCB);
    FREE_BUFFER (.BCB);
    END;

! If the output is a file, close it.
!

FAB = .RWSV_SAVE_FAB;
IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    IF NOT .QUAL[QUAL_VERI]
    THEN
	BEGIN
	STATUS = $CLOSE (FAB = .FAB);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_CLOSEOUT+STS$K_SEVERE, .FAB,
			 .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
	END;
    END

! Generate and write the trailer label set for tape output.
!

ELSE
    BEGIN
    IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
    THEN
	BEGIN
	WRITE_TM ();

	MAKE_HDR1 (LABEL_BUFFER);
	IF .CONTINUE
	THEN LABEL_BUFFER[HD1$L_HD1LID] = 'EOV1'
	ELSE LABEL_BUFFER[HD1$L_HD1LID] = 'EOF1';
	DESCRIPTOR[0] = HD1$S_BLOCKCNT;
	DESCRIPTOR[1] = LABEL_BUFFER[HD1$T_BLOCKCNT];
	$FAO ($DESCRIPTOR ('!6ZL'),
		0,
		DESCRIPTOR,
		.RWSV_OUT_BLOCK_COUNT
		);
	WRITE_LABEL (LABEL_BUFFER);

	MAKE_HDR2 (LABEL_BUFFER);
	IF .CONTINUE
	THEN LABEL_BUFFER[HD1$L_HD1LID] = 'EOV2'
	ELSE LABEL_BUFFER[HD1$L_HD1LID] = 'EOF2';
	WRITE_LABEL (LABEL_BUFFER);

! Mark the end of tape with two tape marks.
!

	WRITE_TM ();
	WRITE_TM ();
	SKIP_TM (-3);

	IF NOT .QUAL[QUAL_VERI]
	THEN
	    BEGIN
	    IF .CONTINUE
	    THEN UNLOAD ();
	    $DASSGN (CHAN = .RWSV_CHAN);
	    RWSV_CHAN = 0;
	    END;
	END

! Finish up sequential disk. Return unused blocks, set up the record
! attributes, and deaccess the file.
!

    ELSE
	BEGIN
	CURRENT_MTL = .OUTPUT_MTL;
	SWITCH_VOLUME (.RWSV_VOL_NUMBER);
	STATUS = STA_EXTEND (-.RWSV_ALLOC, BLOCKS_ALLOC);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_CLOSEOUT+STS$K_SEVERE, .FAB, .STATUS);
	RWSV_EOF = .RWSV_OUT_VBN - 1;

	CH$FILL (0, FAT$C_LENGTH, RECATTR);
	RECATTR[FAT$B_RTYPE] = FAT$C_FIXED;
	RECATTR[FAT$W_RSIZE] = .QUAL[QUAL_BLOC_VALUE];
	RECATTR[FAT$W_MAXREC] = .QUAL[QUAL_BLOC_VALUE];

	IF .CONTINUE
	AND .RWSV_VOL_NUMBER LSSU 255
	THEN
	    BEGIN
	    RECATTR[FAT$L_EFBLK] = 1^31 - 1;
	    RECATTR[FAT$L_HIBLK] = 1^31 - 1;
	    CONTINUE_FID[FID$W_NUM] = FID$C_CONTIN;
	    CONTINUE_FID[FID$W_SEQ] = FID$C_CONTIN;
	    CONTINUE_FID[FID$W_RVN] = .RWSV_VOL_NUMBER + 1;
	    END
	ELSE
	    BEGIN
	    RECATTR[FAT$L_EFBLK] = ROT (.RWSV_OUT_VBN, 16);
	    RECATTR[FAT$L_HIBLK] = ROT (.RWSV_OUT_VBN+.RWSV_ALLOC+.BLOCKS_ALLOC-1, 16);
	    CONTINUE_FID[FID$W_NUM] = 0;
	    CONTINUE_FID[FID$W_SEQ] = 0;
	    CONTINUE_FID[FID$W_RVN] = 0;
	    END;

	ATT_CONTROL1[ATR$W_SIZE] = ATR$S_RECATTR;
	ATT_CONTROL1[ATR$W_TYPE] = ATR$C_RECATTR;
	ATT_CONTROL1[ATR$L_ADDR] = RECATTR;
	ATT_CONTROL2[ATR$W_SIZE] = ATR$S_EXTFID;
	ATT_CONTROL2[ATR$W_TYPE] = ATR$C_EXTFID;
	ATT_CONTROL2[ATR$L_ADDR] = CONTINUE_FID;
	ATTR_END = 0;

	STATUS = S$QIOW (CHAN = .RWSV_CHAN,
			 IOSB = IO_STATUS,
			 FUNC = IO$_MODIFY,
			 P5   = ATT_CONTROL
			 );
	IF .STATUS THEN STATUS = .IO_STATUS[0];
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_CLOSEOUT+STS$K_SEVERE, .FAB, .STATUS);
	STA_DISMOUNT_OUTPUT (.RWSV_VOL_NUMBER, .CONTINUE);

	IF NOT .QUAL[QUAL_VERI]
	THEN
	    BEGIN
	    S$QIOW (CHAN = .RWSV_CHAN,
		    IOSB = IO_STATUS,
		    FUNC = IO$_DEACCESS
		    );
	    STA_DISMOUNT (.RWSV_VOL_NUMBER);
	    IF .CONTINUE
	    THEN
		BEGIN
		$QIOW (CHAN = .CURRENT_VCB[VCB_CHAN],
		       FUNC = IO$_UNLOAD
		       );
		END;
	    END;
	END;
    END;

! Report the number of soft write errors.
!

IF .RWSV_OUT_ERRORS NEQ 0
THEN FILE_ERROR (BACKUP$_SOFTWERRS, .FAB, .RWSV_OUT_ERRORS);

! Now do the verify pass, if requested.
!

IF .QUAL[QUAL_VERI]
THEN
    BEGIN
    SIGNAL (BACKUP$_STARTVERIFY);
    COM_FLAGS[COM_VERIFYING] = TRUE;
    IF .RWSV_SEG_NUMBER EQL 0
    THEN INIT_IN_SAVE (TRUE)
    ELSE
	IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
	THEN READY_NEXT_VOLUME ();
    RWSV_IN_VBN = .RWSV_IN_VBN_0;
    RWSV_IN_ERRORS = 0;
    RWSV_IN_XORUSE = 0;
    SAVE_VERIFY_REEL ();
    FIN_IN_SAVE (.CONTINUE);
    COM_FLAGS[COM_VERIFYING] = FALSE;
    END;

IF .RWSV_VOL_NUMBER GEQU 255
THEN FILE_ERROR (BACKUP$_MAXVOLS, .FAB);

IF .CONTINUE THEN SIGNAL (BACKUP$_RESUME, 1, .RWSV_VOL_NUMBER+1);

END;					! End of routine FIN_OUT_SAVE

END
ELUDOM
