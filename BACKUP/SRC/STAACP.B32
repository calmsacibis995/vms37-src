MODULE STAACP	(%TITLE	'Standalone ACP'
		IDENT = 'V03-002'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!	This module contains the standalone ACP routines.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 01-Feb-1981
!
! MODIFIED BY:
!
!	V03-002	ACG0281		Andrew C. Goldstein,	5-Apr-1982  16:02
!		Add ODS-1 multi-header index file support
!
!	V03-001	ACG0279		Andrew C. Goldstein,	1-Apr-1982  14:20
!		Rework header processing in STA_EXTEND
!
!	V02-009	MLJ0081		Martin L. Jack,	26-Feb-1982  16:03
!		Implement RETAINMIN and RETAINMAX for new home block fields.
!
!	V02-008	MLJ0075		Martin L. Jack,	31-Jan-1982  7:26
!		Correct access violation introduced in V02-007.
!
!	V02-007	MLJ0062		Martin L. Jack,	10-Dec-1981  20:00
!		Rework STA_ACCESS to allow IO$_ACCESS without IO$M_ACCESS when
!		file is already accessed.  This is necessary to avoid spurious
!		FILALRACC errors when saving multi-header files.
!
!	V02-006	ACG0236		Andrew C. Goldstein,	8-Dec-1981  21:45
!		Check status from PACKACK function
!
!	V02-005	MLJ0054		Martin L. Jack,	20-Oct-1981  8:30
!		Implement /VOLUME.  Reconstruct quota file for /IMAGE output.
!		Release disk space on a failed IO$_CREATE.  Display pertinent
!		file name in error messages issued by STA_DISMOUNT_OUTPUT and
!		STA_INIT_HDRS.  Move globals to common.  Integrate GET_VM and
!		FREE_VM jacket routines.
!
!	V02-004	MLJ0040		Martin L. Jack,	3-Sep-1981  19:42
!		Clean up window on a failed IO$_CREATE to avoid
!		incorrect "file already accessed" errors.
!
!	V02-003	MLJ0039		Martin L. Jack,	3-Sep-1981  19:21
!		Include general-mode addressing where required.
!
!	V02-002	ACG0211		Andrew C. Goldstein,	22-Jul-1981  17:18
!		Add logic to create save set files
!
!	V02-001	MLJ0025		Martin L. Jack,	8-May-1981  14:24
!		Move setting of index file bitmap into WRITE_HEADER.  Improve
!		documentation.  Avoid creating window for IO$_ACCESS (and
!		disallow STATBLK attribute) unless file is actually accessed.
!		Do preliminary work for file placement.
!
!**

switches nooptimize;
REQUIRE 'SRC$:COMMON';
LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'LIB$:BACKDEF';


LINKAGE
	L_DQF_WRITE_ENTRY = CALL:
	    GLOBAL(
		DQF_BUFFER=11,
		DQF_RECORD=10,
		DQF_VBN=9,
		DQF_DEFAULT_PERM=8,
		DQF_DEFAULT_OVER=7);


FORWARD ROUTINE
	DQF_FIND_UIC,			! Search quota table for UIC
	DQF_MODIFY_USAGE:
			NOVALUE,	! Update usage data for UIC
	DQF_WRITE_ENTRY:L_DQF_WRITE_ENTRY NOVALUE,
					! Rewrite quota file entry
	ASSIGN_INPUT_CHANNEL,		! Assign a channel to input disk
	ASSIGN_OUTPUT_CHANNEL,		! Assign a channel to output disk
	SWITCH_VOLUME,			! Switch to relative volume
	VERIFY_HEADER,			! Check one file header
	READ_HEADER,			! Read one file header
	WRITE_HEADER,			! Write one file header
	CREATE_DELHDR:	NOVALUE,	! Create deleted file header
	TAKE_BLOCKS:	NOVALUE,	! Take blocks from free list
	STA_ALLOC_LBN,			! Allocate specific LBN
	STA_ALLOC_BEST,			! Allocate best fit
	FREE_BLOCKS:	NOVALUE,	! Return blocks to free list
	MAKE_POINTER1,			! Make map pointer (ODS-1)
	MAKE_POINTER,			! Make map pointer (ODS-2)
	CREATE_WINDOW,			! Create window block
	DELETE_WINDOW:	NOVALUE,	! Delete window block
	ADD_BLACKHOLE_MAP:
			NOVALUE,	! Add blackhole pointer to window
	ADD_WINDOW_MAP:	NOVALUE,	! Add map entry to window
	QIO_AST:	NOVALUE,	! Completion AST for R_W_VIRTUAL
	R_W_VIRTUAL,			! Read/write virtual
	STA_INIVOL:	NOVALUE,	! Initialize a volume
	STA_INIT_HDRS:	NOVALUE,	! Initialize file headers
	STA_WRITEBOOT:	NOVALUE,	! Rewrite boot block with boot LBN
	STA_MOUNT:	NOVALUE,	! Mount a volume set
	READY_DISK,			! Ready disk for save set
	STA_ENTER:	NOVALUE,	! Execute RMS ENTER function
	STA_EXTEND,			! Incrementally extend file
	STA_RDWRVBLK,			! Execute IO$_READVBLK, IO$_WRITEVBLK
	STA_ACCESS,			! Execute IO$_ACCESS
	CREATE_CLEANUP,			! Process allocation list after create
	CREATE_EXTHDR,			! Create extension header
	STA_CREATE,			! Execute IO$_CREATE
	STA_DEACCESS,			! Execute IO$_DEACCESS
	STA_MODIFY,			! Execute IO$_MODIFY
	STA_QIO,			! Dispatch ACP QIOs
	STA_QIOW,			! Execute $QIOW
	READ_ATTRIBUTES,		! Read attributes
	TO_ODS1_DATE:	NOVALUE,	! Convert 64-bit time to ODS-1 format
	WRITE_ATTRIBUTES;		! Write attributes


EXTERNAL ROUTINE
	CHECKSUM,			! Compute file header checksum
	CHECKSUM2,			! Compute home block checksum
	FILE_ERROR:	NOVALUE,	! Signal file-related error
	FROM_ODS1_DATE:	NOVALUE,	! Convert ODS-1 format to 64-bit time
	INITIALIZE_VOLUME:
			NOVALUE,	! Execute volume initialization
	MAKE_NAMEBLOCK:	NOVALUE,	! Convert filename to ODS-1 format
	FREE_VM:	NOVALUE,	! Deallocate virtual memory
	GET_VM,				! Allocate virtual memory
	GET_ZERO_VM,	 		! Allocate and clear virtual memory
	SYS$ASSIGN:	ADDRESSING_MODE(GENERAL);
					! Assign channel system service


EXTERNAL LITERAL
	BACKUP$_BADSETCNT,
	BACKUP$_DISKFRAG,
	BACKUP$_GETCHN,
	BACKUP$_INCRVN,
	BACKUP$_INCSETCNT,
	BACKUP$_INVATTVAL,
	BACKUP$_INVHOMBLK,
	BACKUP$_LARGECNT,
	BACKUP$_NOBITMAP,
	BACKUP$_NOHOMEBLK,
	BACKUP$_NOINDEXF,
	BACKUP$_NOVOLDATA,
	BACKUP$_ODS2SAVE,
	BACKUP$_OPENIN,
	BACKUP$_OPENOUT,
	BACKUP$_CLOSEOUT,
	BACKUP$_READBMAP,
	BACKUP$_READERR,
	BACKUP$_READIMAP,
	BACKUP$_READYREAD,
	BACKUP$_READYWRITE,
	BACKUP$_STRUCLEV,
	BACKUP$_VOLINSET,
	BACKUP$_WRITENABLE,
	BACKUP$_WRITEERR,
	BACKUP$_QUOTAFILE;


G$DEFINE();		! Define global common area


OWN
	RSA_DESC:	VECTOR[2],	! Descriptor for RSA in STA_DISMOUNT_OUTPUT
	DQF_QUOTA_FID:	BBLOCK[FID$C_LENGTH], ! File ID of quota file
	DQF_ROOT,			! Root of quota table
	DQF_COUNT;			! Count of entries in quota table


MACRO

	! Field definitions for extent list.
	!
	EXT_FLINK=	0,0,32,0 %,	! Forward link
	EXT_BLINK=	4,0,32,0 %,	! Backward link
	EXT_VCB=	8,0,32,0 %,	! Pointer to VCB for volume
	EXT_COUNT=	12,0,32,0 %,	! Count of blocks
	EXT_LBN=	16,0,32,0 %;	! LBN of blocks

LITERAL
	EXT_S_ENTRY=	20;		! Size of extent list entry in bytes


MACRO

	! Field definitions for create list.
	!
	CRT_FLINK=	0,0,32,0 %,	! Forward link
	CRT_BLINK=	4,0,32,0 %,	! Backward link

	CRT_FID_FQHDR=	8,0,32,0 %,	! Queue header for FID queue
	CRT_FID_BQHDR=	12,0,32,0 %,	!
	CRT_BLOCKS=	16,0,32,0 %,	! Blocks

	CRT_FID=	8,0,0,0 %,	! File ID
	CRT_FID_NUM=	8,0,16,0 %,	!
	CRT_FID_SEQ=	10,0,16,0 %,	!
	CRT_FID_RVNW=	12,0,16,0 %,	!
	CRT_FID_RVN=	12,0,8,0 %,	!
	CRT_FID_NMX=	13,0,8,0 %;	!


LITERAL
	CRT_S_BLOCKS=	20,		! Size of "blocks" entry
	CRT_S_FID=	14;		! Size of "FID" entry


BUILTIN
	CALLG,
	INSQUE,
	REMQUE,
	ROT;

ROUTINE DQF_FIND_UIC(UIC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds the quota table entry for a specified UIC,
!	creating it if necessary.
!
! INPUT PARAMETERS:
!	UIC		- The UIC.
!
! IMPLICIT INPUTS:
!	DQF_ROOT	- The root of the quota table structure.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	A pointer to the entry for the specified UIC.
!
! SIDE EFFECTS:
!	The entry may be created if required.
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK,	! Pointer to DQF entry
	Q:		REF BBLOCK;	! Pointer to link to DQF entry


! Search DQF table for a matching entry or to find where the new entry
! must be inserted.
!
Q = DQF_ROOT;				! Point to root of table
P = ..Q;				! Point to highest entry in table
WHILE .P NEQ 0 DO			! Until bottom of table reached
    BEGIN
    IF .UIC EQL .P[DQF_UIC]		! If correct entry
	THEN RETURN .P;			!     return it
    IF .UIC GTRU .P[DQF_UIC]		! If desired entry is on right branch
	THEN Q = P[DQF_RLINK]		!     point to right link word
	ELSE Q = P[DQF_LLINK];		!     otherwise to left link word
    P = ..Q;				! Point to right or left branch
    END;


! Allocate and initialize the new entry.
!
DQF_COUNT = .DQF_COUNT + 1;
.Q = GET_VM(DQF_S_ENTRY);
P = ..Q;
P[DQF_LLINK] = 0;
P[DQF_RLINK] = 0;
P[DQF_UIC] = .UIC;
P[DQF_USAGE] = 0;
P[DQF_PERMQUOTA] = -1;			! Flag that no quotas exist
P[DQF_OVERDRAFT] = -1;
.P
END;

ROUTINE DQF_MODIFY_USAGE(UIC,USAGE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine records used blocks.
!
! INPUT PARAMETERS:
!	UIC		- The UIC.
!	USAGE		- Count of blocks allocated.
!
! IMPLICIT INPUTS:
!	Disk quota table.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Disk quota table updated.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK;	! Pointer to DQF entry


P = DQF_FIND_UIC(.UIC);
P[DQF_USAGE] = .P[DQF_USAGE] + .USAGE;
END;

ROUTINE DQF_WRITE_ENTRY(P): L_DQF_WRITE_ENTRY NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes a quota file entry.
!
! INPUT PARAMETERS:
!	P		- Pointer to DQF entry.
!
! IMPLICIT INPUTS:
!	DQF_BUFFER	- Pointer to block buffer.
!	DQF_RECORD	- Pointer to next available record.
!	DQF_VBN		- Next VBN.
!	DQF_DEFAULT_PERM - Default PERMQUOTA.
!	DQF_DEFAULT_OVER - Default OVERDRAFT.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	P:		REF BBLOCK;	! Pointer to DQF entry
LOCAL
	STATUS,				! General status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block
EXTERNAL REGISTER
	DQF_BUFFER,
	DQF_RECORD:	REF BBLOCK,
	DQF_VBN,
	DQF_DEFAULT_PERM,
	DQF_DEFAULT_OVER;


! Recursively write all entries on the left branch.
!
IF .P[DQF_LLINK] NEQ 0 THEN DQF_WRITE_ENTRY(.P[DQF_LLINK]);


IF .DQF_RECORD GEQA .DQF_BUFFER + 512
THEN
    BEGIN
    STATUS = S$QIOW(
	FUNC=IO$_WRITEVBLK,
	CHAN=STA_OUT_CHAN,
	IOSB=IOSB,
	P1=.DQF_BUFFER,
	P2=512,
	P3=.DQF_VBN);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
    CH$FILL(0, 512, .DQF_BUFFER);
    DQF_RECORD = .DQF_BUFFER;
    DQF_VBN = .DQF_VBN + 1;
    END;


DQF_RECORD[DQF$L_FLAGS] = DQF$M_ACTIVE;
DQF_RECORD[DQF$L_UIC] = .P[DQF_UIC];
DQF_RECORD[DQF$L_USAGE] = .P[DQF_USAGE];
IF .P[DQF_PERMQUOTA] EQL -1 AND .P[DQF_OVERDRAFT] EQL -1
THEN
    BEGIN
    DQF_RECORD[DQF$L_PERMQUOTA] = .DQF_DEFAULT_PERM;
    DQF_RECORD[DQF$L_OVERDRAFT] = .DQF_DEFAULT_OVER;
    END
ELSE
    BEGIN
    DQF_RECORD[DQF$L_PERMQUOTA] = .P[DQF_PERMQUOTA];
    DQF_RECORD[DQF$L_OVERDRAFT] = .P[DQF_OVERDRAFT];
    END;
DQF_RECORD = .DQF_RECORD + DQF$C_LENGTH;


! Recursively write all entries on the right branch.
!
IF .P[DQF_RLINK] NEQ 0 THEN DQF_WRITE_ENTRY(.P[DQF_RLINK]);
END;

GLOBAL ROUTINE ASSIGN_INPUT_CHANNEL(DEVNAM,CHAN,ACMODE,MBXNAM)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called to assign a channel to the input disk.
!
! INPUT PARAMETERS:
!	As for the $ASSIGN system service.  (However, the channel number is
!	written as a longword because the pseudo-channel numbers are larger
!	than 16 bits).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	AP;


! If the standalone ACP is going to handle operations on the input disk, then
! return the special channel number.  Otherwise, let the request through to
! the real $ASSIGN service.
!
IF .INPUT_MTL NEQ 0
THEN
    BEGIN
    .CHAN = STA_IN_CHAN;
    SS$_NORMAL
    END
ELSE
    CALLG(.AP, SYS$ASSIGN)
END;

GLOBAL ROUTINE ASSIGN_OUTPUT_CHANNEL(DEVNAM,CHAN,ACMODE,MBXNAM)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called to assign a channel to the output disk.
!
! INPUT PARAMETERS:
!	As for the $ASSIGN system service.  (However, the channel number is
!	written as a longword because the pseudo-channel numbers are larger
!	than 16 bits).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	AP;


! If the standalone ACP is going to handle operations on the output disk, then
! return the special channel number.  Otherwise, let the request through to
! the real $ASSIGN service.
!
IF .OUTPUT_MTL NEQ 0
THEN
    BEGIN
    .CHAN = STA_OUT_CHAN;
    SS$_NORMAL
    END
ELSE
    CALLG(.AP, SYS$ASSIGN)
END;

GLOBAL ROUTINE SWITCH_VOLUME(RVN)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine switches to a specified relative volume.
!
! INPUT PARAMETERS:
!	RVN		- Relative volume number.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Channel number assigned to specified RVN.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS,				! general status value
	XVCB:		REF BBLOCK,	! VCB that will have channel deassigned
	VCB:		REF BBLOCK;	! VCB being switched to


! Locate VCB being switched to.
!
CURRENT_VCB = VCB = .CURRENT_MTL[MTL_VCB(.RVN-.CURRENT_MTL[MTL_RVN_BASE])];


IF .VCB[VCB_CHAN] NEQ 0
THEN
    BEGIN

    ! Volume already has channel assigned.  Make sure it is first (implemented
    ! as, not second) in the LRU list.
    !
    IF .CURRENT_MTL[MTL_CHAN_2] EQL .VCB
    THEN
	BEGIN
	CURRENT_MTL[MTL_CHAN_2] = .CURRENT_MTL[MTL_CHAN_1];
	CURRENT_MTL[MTL_CHAN_1] = .VCB;
	END;
    END
ELSE
    BEGIN

    ! No channel is assigned.  Take the channel away from the second entry
    ! in the LRU list. If it exists, wait for the I/O count to drop to zero
    ! and then deassign the channel.
    !
    XVCB = .CURRENT_MTL[MTL_CHAN_2];
    IF .XVCB NEQ 0
    THEN
	BEGIN
	WHILE TRUE DO
	    BEGIN
	    $CLREF(EFN=31);
	    IF .XVCB[VCB_IOCOUNT] LEQ 0 THEN EXITLOOP;
	    $WAITFR(EFN=31);
	    END;
	$DASSGN(CHAN=.XVCB[VCB_CHAN]);
	XVCB[VCB_CHAN] = 0;
	END;

    STATUS = $ASSIGN(DEVNAM=VCB[VCB_DEVICE], CHAN=VCB[VCB_CHAN]);
    IF NOT .STATUS
    THEN
	SIGNAL(
	    (IF .VCB[VCB_OUTPUT]
		THEN BACKUP$_OPENOUT + STS$K_SEVERE
		ELSE BACKUP$_OPENIN + STS$K_SEVERE),
	    1,
	    VCB[VCB_DEVICE],
	    .STATUS);
    CURRENT_MTL[MTL_CHAN_2] = .CURRENT_MTL[MTL_CHAN_1];
    CURRENT_MTL[MTL_CHAN_1] = .VCB;
    END;


! Return the channel number.
!
.VCB[VCB_CHAN]
END;

ROUTINE VERIFY_HEADER(HEADER,FILE_ID)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine determines if the block given it is a valid file header.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to header.
!	FILE_ID		- Purported file ID.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	0 if invalid file header
!	1 if valid file header
!	2 if deleted file header
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HEADER:		REF BBLOCK,	! file header arg
	FILE_ID:	REF BBLOCK;	! file ID arg


! First check the structure level.
!
IF .HEADER[FH2$B_STRUCLEV] NEQ .CURRENT_MTL[MTL_STRUCLEV]
THEN
    RETURN 0;


IF .CURRENT_MTL[MTL_STRUCLEV] EQL 2
THEN
    BEGIN

    ! Check the area offsets and the retrieval pointer use counts for
    ! consistency.
    !
    IF
	.HEADER[FH2$B_IDOFFSET] LSSU FH2$C_LENGTH/2 OR
	.HEADER[FH2$B_MPOFFSET] LSSU .HEADER[FH2$B_IDOFFSET] OR
	.HEADER[FH2$B_ACOFFSET] LSSU .HEADER[FH2$B_MPOFFSET] OR
	.HEADER[FH2$B_RSOFFSET] LSSU .HEADER[FH2$B_ACOFFSET] OR
	.HEADER[FH2$B_MAP_INUSE] GTRU .HEADER[FH2$B_ACOFFSET] - .HEADER[FH2$B_MPOFFSET]
    THEN
	RETURN 0;


    ! At this point, we have verified that the block at least once was a
    ! valid file header.
    !
    ! Look at the file number in the header. If zero, this is a 
    ! deleted header.
    !
    IF
	.HEADER[FH2$W_FID_NUM] EQL 0 AND
	.HEADER[FH2$B_FID_NMX] EQL 0
    THEN
	RETURN 2;


    ! Now compute the header checksum.
    !
    IF NOT CHECKSUM(.HEADER)
    THEN
	RETURN 2;


    ! Check file number and file sequence number.
    !
    IF
	.HEADER[FH2$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM] OR
	.HEADER[FH2$B_FID_NMX] NEQ .FILE_ID[FID$B_NMX] OR
	.HEADER[FH2$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
    THEN
	RETURN 2;
    END
ELSE
    BEGIN
    LOCAL
	MAP_AREA:	REF BBLOCK;


    ! Now point to the map area and make sure that the extension
    ! RVN is zero.  Also check the retrieval pointer format data.
    !
    MAP_AREA = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
    IF
	.MAP_AREA[FM1$B_EX_RVN] NEQ 0 OR
	.MAP_AREA[FM1$B_COUNTSIZE] NEQ 1 OR
	.MAP_AREA[FM1$B_LBNSIZE] NEQ 3
    THEN
	RETURN 0;


    ! Check the retrieval pointer counts for consistency with the
    ! available space.
    !
    IF
	.MAP_AREA[FM1$B_INUSE] GTRU .MAP_AREA[FM1$B_AVAIL] OR
	.MAP_AREA[FM1$B_AVAIL] GTRU 255 - (.MAP_AREA + FM1$C_POINTERS - .HEADER) / 2
    THEN
	RETURN 0;


    ! At this point, we have verified that the block at least once was a
    ! valid file header.
    !
    ! Look at the file number in the header. If zero, this is a 
    ! deleted header.
    !
    IF .HEADER[FH1$W_FID_NUM] EQL 0
    THEN
	RETURN 2;


    ! Now compute the header checksum.
    !
    IF NOT CHECKSUM(.HEADER)
    THEN
	RETURN 2;


    ! Check file number and file sequence number.
    !
    IF
	.HEADER[FH1$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM] OR
	.HEADER[FH1$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
    THEN
	RETURN 2;
    END;


! Header is OK.
!
RETURN 1;
END;

GLOBAL ROUTINE READ_HEADER(FILE_ID,BUFFER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reads one file header into the specified buffer.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of header to be read.
!	BUFFER		- Pointer to buffer.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if header successfully read, false otherwise.
!
! SIDE EFFECTS:
!	Header read into buffer.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	BUFFER:		REF BBLOCK;	! Pointer to header
LOCAL
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD],	! I/O status block
	FILE_NUMBER,			! Clean file number
	RVN,				! Clean RVN
	VCB:		REF BBLOCK;	! VCB for specified RVN


! Get a clean file number and RVN and validity check.  If failure,
! return failure.
!
FILE_NUMBER = .FILE_ID[FID$W_NUM];
FILE_NUMBER<16,8> = .FILE_ID[FID$B_NMX];
RVN = .FILE_ID[FID$B_RVN];
IF .RVN - .CURRENT_MTL[MTL_RVN_BASE] GEQU .CURRENT_MTL[MTL_SETCOUNT]
THEN RETURN SS$_DEVNOTMOUNT;
VCB = .CURRENT_MTL[MTL_VCB(.RVN-.CURRENT_MTL[MTL_RVN_BASE])];
IF .FILE_NUMBER GTRU .VCB[VCB_MAXFILIDX] THEN RETURN SS$_NOSUCHFILE;


! Read the header.
!
CURRENT_WCB = .VCB[VCB_INDEXF];
STATUS = R_W_VIRTUAL(
    0,
    0,
    IO$_READVBLK,
    IOSB,
    0,
    0,
    .BUFFER,
    512,
    .FILE_NUMBER + .VCB[VCB_HDR_OFFSET]);
$WAITFR(EFN=0);
IF .STATUS THEN STATUS = .IOSB[0];


! If failure, return failure.
!
IF NOT .STATUS
THEN
    RETURN .STATUS;


! Verify the header that was read.
!
IF NOT VERIFY_HEADER(.BUFFER, .FILE_ID)
THEN
    RETURN SS$_NOSUCHFILE;


! Successful completion.
!
SS$_NORMAL
END;

ROUTINE WRITE_HEADER(FILE_ID,BUFFER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine writes one file header from the specified buffer.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of header to be written.
!	BUFFER		- Pointer to buffer.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	Header written from buffer.
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	BUFFER:		REF BBLOCK;	! Pointer to header
LOCAL
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD],	! I/O status block
	FILE_NUMBER,			! Clean file number
	RVN,				! Clean RVN
	VCB:		REF BBLOCK;	! VCB for specified RVN


! Get a clean file number and RVN and validity check.  If failure,
! do nothing.
!
FILE_NUMBER = .FILE_ID[FID$W_NUM];
FILE_NUMBER<16,8> = .FILE_ID[FID$B_NMX];
RVN = .FILE_ID[FID$B_RVN];
IF .RVN - .CURRENT_MTL[MTL_RVN_BASE] GEQU .CURRENT_MTL[MTL_SETCOUNT]
THEN RETURN SS$_DEVNOTMOUNT;
VCB = .CURRENT_MTL[MTL_VCB(.RVN-.CURRENT_MTL[MTL_RVN_BASE])];
IF .FILE_NUMBER GTRU .VCB[VCB_MAXFILIDX] THEN RETURN SS$_NOSUCHFILE;


! Recompute the checksum.
!
CHECKSUM(.BUFFER);


! Write the block.
!
CURRENT_WCB = .VCB[VCB_INDEXF];
STATUS = R_W_VIRTUAL(
    0,
    0,
    IO$_WRITEVBLK,
    IOSB,
    0,
    0,
    .BUFFER,
    512,
    .FILE_NUMBER + .VCB[VCB_HDR_OFFSET]);
$WAITFR(EFN=0);
IF .STATUS THEN STATUS = .IOSB[0];


! If failure, return failure.
!
IF NOT .STATUS
THEN
    RETURN .STATUS;


! Set the index file bitmap bit.
!
IF .VCB[VCB_IMAP] NEQ 0
THEN
    IF
	(IF .BUFFER[FH2$B_STRUCLEV] EQL 2
	    THEN .BUFFER[FH2$W_FID_NUM] EQL 0
	    ELSE .BUFFER[FH1$W_FID_NUM] EQL 0)
    THEN
	BITVECTOR[.VCB[VCB_IMAP], .FILE_NUMBER-1] = FALSE
    ELSE
	BITVECTOR[.VCB[VCB_IMAP], .FILE_NUMBER-1] = TRUE;


! If this is the index file header, also rewrite
! the alternate header.
!
IF .FILE_NUMBER EQL FID$C_INDEXF AND .VCB[VCB_ODS_2]
THEN
    BEGIN
    STATUS = R_W_VIRTUAL(
	0,
	0,
	IO$_WRITEVBLK,
	IOSB,
	0,
	0,
	.BUFFER,
	512,
	.VCB[VCB_CLUSTER] * 3 + 1);
    $WAITFR(EFN=0);
    IF .STATUS THEN STATUS = .IOSB[0];


    ! If failure, return failure.
    !
    IF NOT .STATUS
    THEN
	RETURN .STATUS;
    END;


! Normal completion.
!
SS$_NORMAL
END;

ROUTINE CREATE_DELHDR(FILE_ID,HEADER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates a deleted file header.
!
! INPUT PARAMETERS:
!	FILE_ID		- File ID of the header.
!	HEADER		- Pointer to header buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Header buffer contains deleted header.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FILE_ID:	REF BBLOCK,	! Pointer to file ID
	HEADER:		REF BBLOCK;	! Pointer to header buffer


CH$FILL(0, 512, .HEADER);
IF .CURRENT_MTL[MTL_STRUCLEV] EQL 2
THEN
    BEGIN
    HEADER[FH2$B_IDOFFSET] = FH2$C_LENGTH / 2;
    HEADER[FH2$B_MPOFFSET] = (FH2$C_LENGTH + FI2$C_LENGTH) / 2;
    HEADER[FH2$B_ACOFFSET] = $BYTEOFFSET(FH2$W_CHECKSUM) / 2;
    HEADER[FH2$B_RSOFFSET] = $BYTEOFFSET(FH2$W_CHECKSUM) / 2;
    HEADER[FH2$B_STRUCVER] = 1;
    HEADER[FH2$B_STRUCLEV] = 2;
    HEADER[FH2$W_FID_SEQ] = .FILE_ID[FID$W_SEQ];
    CH$COPY(
	2, UPLIT BYTE ('.;'),
	%C' ',
	FI2$S_FILENAME, BBLOCK[.HEADER + FH2$C_LENGTH, FI2$T_FILENAME]);
    END
ELSE
    BEGIN
    HEADER[FH1$B_IDOFFSET] = FH1$C_LENGTH / 2;
    HEADER[FH1$B_MPOFFSET] = (FH1$C_LENGTH + FI1$C_LENGTH) / 2;
    HEADER[FH1$W_FID_SEQ] = .FILE_ID[FID$W_SEQ];
    HEADER[FH1$W_STRUCLEV] = FH1$C_LEVEL1;
    BBLOCK[.HEADER + FH1$C_LENGTH + FI1$C_LENGTH, FM1$B_COUNTSIZE] = 1;
    BBLOCK[.HEADER + FH1$C_LENGTH + FI1$C_LENGTH, FM1$B_LBNSIZE] = 3;
    BBLOCK[.HEADER + FH1$C_LENGTH + FI1$C_LENGTH, FM1$B_AVAIL] =
	(512-2-FH1$C_LENGTH-FI1$C_LENGTH-FM1$C_LENGTH)/2;
    END;
CHECKSUM(.HEADER);
END;

ROUTINE TAKE_BLOCKS(ACB,COUNT,LBN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine modifies the free blocks list.
!
! INPUT PARAMETERS:
!	ACB		- Pointer to allocation control block.
!	COUNT		- Count of blocks to allocate.
!	LBN		- Logical block number of blocks to allocate.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Allocation list modified.
!
!--

BEGIN
MAP
	ACB:		REF BBLOCK;		! Pointer to allocation block


IF .LBN EQL .ACB[ACB_LBN]
THEN
    BEGIN
    !
    ! Allocation from beginning of free extent.
    ! If the entire extent is allocated, free the block.
    !
    ACB[ACB_LBN] = .ACB[ACB_LBN] + .COUNT;
    ACB[ACB_COUNT] = .ACB[ACB_COUNT] - .COUNT;
    IF .ACB[ACB_COUNT] EQL 0
    THEN
	BEGIN
	LOCAL
	    DUMMY;			! Output for REMQUE

	REMQUE(.ACB, DUMMY);
	FREE_VM(ACB_S_ENTRY, .ACB);
	END;
    END
ELSE IF .ACB[ACB_LBN] + .ACB[ACB_COUNT] - .COUNT EQL .LBN
THEN
    BEGIN
    !
    ! Allocation from end of free extent.
    !
    ACB[ACB_COUNT] = .ACB[ACB_COUNT] - .COUNT;
    END
ELSE
    BEGIN
    !
    ! Allocation from middle of free extent.
    ! Generate a new block.
    !
    LOCAL
	NEW:	REF BBLOCK;	! Pointer to new ACB

    NEW = GET_VM(ACB_S_ENTRY);
    INSQUE(.NEW, .ACB);
    NEW[ACB_LBN] = .LBN + .COUNT;
    NEW[ACB_COUNT] = .ACB[ACB_LBN] + .ACB[ACB_COUNT] - .NEW[ACB_LBN];
    ACB[ACB_COUNT] = .LBN - .ACB[ACB_LBN];
    END;
END;

GLOBAL ROUTINE STA_ALLOC_LBN(COUNT,LBN)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine attempts to allocate an extent at a specific LBN.
!	No partial allocation is permitted.
!
! INPUT PARAMETERS:
!	COUNT		- Block count
!	LBN		- Logical block number
!
! IMPLICIT INPUTS:
!	CURRENT_VCB
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the allocation was made, false otherwise.
!
! SIDE EFFECTS:
!	Allocation list may be modified.
!
!--

BEGIN
LOCAL
	ACB:		REF BBLOCK;		! Pointer to ACB


ACB = .CURRENT_VCB[VCB_ACB_FLINK];
WHILE .ACB NEQ CURRENT_VCB[VCB_ACB_FLINK] DO
    BEGIN

    ! If this entry covers the requested extent, allocate it.
    !
    IF
	.LBN GEQU .ACB[ACB_LBN] AND
	.LBN + .COUNT LEQU .ACB[ACB_LBN] + .ACB[ACB_COUNT]
    THEN
	BEGIN
	TAKE_BLOCKS(.ACB, .COUNT, .LBN);
	RETURN TRUE;
	END;


    ! If this entry follows the requested extent, exit with failure.
    !
    IF .LBN LSSU .ACB[ACB_LBN]
    THEN
	EXITLOOP;


    ACB = .ACB[ACB_FLINK];
    END;


FALSE
END;

ROUTINE STA_ALLOC_BEST(RCOUNT,ACOUNT,LBN)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine attempts a best fit allocation of an extent.
!	Partial allocations are allowed.
!
! INPUT PARAMETERS:
!	RCOUNT		- Requested block count.
!	ACOUNT		- Pointer to where actual block count is stored.
!	LBN		- Pointer to where logical block number is stored.
!
! IMPLICIT INPUTS:
!	CURRENT_VCB
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the allocation was made, false otherwise.
!
! SIDE EFFECTS:
!	Allocation list may be modified.
!
!--

BEGIN
LOCAL
	RRCOUNT,				! Rounded RCOUNT
	MINACB:		REF BBLOCK,		! Smallest count larger than RCOUNT
	MAXACB:		REF BBLOCK,		! Largest count
	ACB:		REF BBLOCK;		! Pointer to ACB


RRCOUNT = (.RCOUNT + .CURRENT_VCB[VCB_CLUSTER] - 1) / .CURRENT_VCB[VCB_CLUSTER] * .CURRENT_VCB[VCB_CLUSTER];
ACB = .CURRENT_VCB[VCB_ACB_FLINK];
MINACB = MAXACB = 0;
WHILE .ACB NEQ CURRENT_VCB[VCB_ACB_FLINK] DO
    BEGIN

    ! Establish the smallest extent at least as large as the request,
    ! if one exists.
    !
    IF .ACB[ACB_COUNT] GEQU .RRCOUNT
    THEN
	IF .MINACB EQL 0
	THEN
	    MINACB = .ACB
	ELSE
	    IF .ACB[ACB_COUNT] LSSU .MINACB[ACB_COUNT]
	    THEN
		MINACB = .ACB;


    ! Establish the largest extent.
    !
    IF .MAXACB EQL 0
    THEN
	MAXACB = .ACB
    ELSE
	IF .ACB[ACB_COUNT] GTRU .MAXACB[ACB_COUNT]
	THEN
	    MAXACB = .ACB;


    ACB = .ACB[ACB_FLINK];
    END;


IF .MINACB NEQ 0
THEN
    BEGIN
    !
    ! Allocation completely satisfied from the smallest free extent larger
    ! than the request.  Blocks allocated from the beginning of the extent.
    !
    .ACOUNT = .RRCOUNT;
    .LBN = .MINACB[ACB_LBN];
    TAKE_BLOCKS(.MINACB, .RRCOUNT, .MINACB[ACB_LBN]);
    TRUE
    END
ELSE IF .MAXACB NEQ 0
THEN
    BEGIN
    !
    ! Allocation partially satisfied from the entire largest free extent.
    !
    .ACOUNT = .MAXACB[ACB_COUNT];
    .LBN = .MAXACB[ACB_LBN];
    TAKE_BLOCKS(.MAXACB, .MAXACB[ACB_COUNT], .MAXACB[ACB_LBN]);
    TRUE
    END
ELSE
    BEGIN
    .ACOUNT = 0;
    FALSE
    END
END;

GLOBAL ROUTINE FREE_BLOCKS(COUNT,LBN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine puts the specified blocks back onto the free list
!	for the currently active volume.
!
! INPUT PARAMETERS:
!	COUNT		- Count of blocks to be freed.
!	LBN		- Starting LBN.
!
! IMPLICIT INPUTS:
!	CURRENT_VCB	- Pointer to VCB for volume.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	ACB list altered.
!
!--

BEGIN
LOCAL
	ACB:		REF BBLOCK,	! ACB following released extent
	PREV_ACB:	REF BBLOCK,	! ACB preceding released extent
	ALLOC_ACB:	REF BBLOCK;	! ACB allocated or deallocated


! Protect against bogus parameters.
!
IF .COUNT EQL 0 THEN RETURN;


! Search the ACB list on the appropriate VCB for the ACB describing an extent
! following the extent to be released.  The ACB list is in LBN order.
!
ACB = CURRENT_VCB[VCB_ACB_FLINK];
DO ACB = .ACB[ACB_FLINK]
UNTIL .ACB EQL CURRENT_VCB[VCB_ACB_FLINK] OR .ACB[ACB_LBN] GTRU .LBN;
PREV_ACB = .ACB[ACB_BLINK];


! Check for contiguity with ACB or PREV_ACB or both and proceed accordingly.
!
IF
    .PREV_ACB NEQ CURRENT_VCB[VCB_ACB_FLINK] AND
    .PREV_ACB[ACB_LBN] + .PREV_ACB[ACB_COUNT] EQL .LBN
THEN
    IF
	.ACB NEQ CURRENT_VCB[VCB_ACB_FLINK] AND
	.LBN + .COUNT EQL .ACB[ACB_LBN]
    THEN
	BEGIN
	!
	! Contiguous with both.  Modify PREV_ACB to describe all 3 extents and
	! release ACB.
	!
	PREV_ACB[ACB_COUNT] = .PREV_ACB[ACB_COUNT] + .COUNT + .ACB[ACB_COUNT];
	REMQUE(.PREV_ACB, ALLOC_ACB);
	FREE_VM(ACB_S_ENTRY, .ALLOC_ACB);
	END
    ELSE
	BEGIN
	!
	! Contiguous with PREV_ACB but not ACB.  Modify PREV_ACB to describe
	! both extents.
	!
	PREV_ACB[ACB_COUNT] = .PREV_ACB[ACB_COUNT] + .COUNT;
	END
ELSE
    IF
	.ACB NEQ CURRENT_VCB[VCB_ACB_FLINK] AND
	.LBN + .COUNT EQL .ACB[ACB_LBN]
    THEN
	BEGIN
	!
	! Contiguous with ACB but not PREV_ACB.  Modify ACB to describe
	! both extents.
	!
	ACB[ACB_LBN] = .LBN;
	ACB[ACB_COUNT] = .ACB[ACB_COUNT] + .COUNT;
	END
    ELSE
	BEGIN
	!
	! Contiguous with neither.  Generate a new ACB.
	!
	ALLOC_ACB = GET_VM(ACB_S_ENTRY);
	INSQUE(.ALLOC_ACB, .PREV_ACB);
	ALLOC_ACB[ACB_COUNT] = .COUNT;
	ALLOC_ACB[ACB_LBN] = .LBN;
	END;
END;

GLOBAL ROUTINE MAKE_POINTER1(BUFFER,COUNT,LBN,UNMAPPED)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine appends retrieval pointers to the map area of an
!	ODS-1 file header describing the given count and LBN.
!
! INPUT PARAMETERS:
!	BUFFER		- Pointer to file header buffer
!	COUNT		- Block count
!	LBN		- Starting logical block number
!	UNMAPPED	- (optional) Number of blocks not mapped
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL or SS$_HEADERFULL.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	ACTUALCOUNT;

MAP
	BUFFER:		REF BBLOCK;	! Pointer to file header buffer
LOCAL
	CURRENT_COUNT,			! running block count
	CURRENT_LBN,			! running LBN
	MAP_AREA:	REF BBLOCK,	! pointer to map area
	MAP_POINTER:	REF BBLOCK;	! pointer to map area


! Compute the address in the file header where the pointer should go.
! Then determine the format of the pointer and build it.
!
MAP_AREA = .BUFFER + 2 * .BUFFER[FH2$B_MPOFFSET];
MAP_POINTER = .MAP_AREA + FM1$C_POINTERS + .MAP_AREA[FM1$B_INUSE]*2;
CURRENT_COUNT = .COUNT;
CURRENT_LBN = .LBN;


DO
    BEGIN

    ! Check for map area overflow.
    !
    IF .MAP_POINTER + 4 GTRA .BUFFER + $BYTEOFFSET(FH1$W_CHECKSUM)
    THEN
	BEGIN
	IF ACTUALCOUNT () GEQU 4
	THEN .UNMAPPED = .CURRENT_COUNT;
	RETURN SS$_HEADERFULL;
	END;


    ! Build the map pointer.
    !
    MAP_AREA[FM1$B_INUSE] = .MAP_AREA[FM1$B_INUSE] + 2;
    MAP_POINTER[FM1$B_HIGHLBN] = .CURRENT_LBN<16,8>;
    MAP_POINTER[FM1$B_COUNT] = MIN(.CURRENT_COUNT, 256) - 1;
    MAP_POINTER[FM1$W_LOWLBN] = .CURRENT_LBN<0,16>;
    MAP_POINTER = .MAP_POINTER + 4;


    ! Decrease residual count.
    !
    CURRENT_LBN = .CURRENT_LBN + MIN(.CURRENT_COUNT, 256);
    CURRENT_COUNT = .CURRENT_COUNT - MIN(.CURRENT_COUNT, 256);
    END
UNTIL .CURRENT_COUNT EQL 0;


SS$_NORMAL
END;

GLOBAL ROUTINE MAKE_POINTER(BUFFER,COUNT,LBN)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine appends a retrieval pointer to the map area of an
!	ODS-2 file header describing the given count and LBN.
!
! INPUT PARAMETERS:
!	BUFFER		- Pointer to file header buffer
!	COUNT		- Block count
!	LBN		- Starting logical block number
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	CURRENT_VCB	- Pointer to VCB for selected volume.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL or SS$_HEADERFULL.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	BUFFER:		REF BBLOCK;	! Pointer to file header buffer
LOCAL
	MAP_POINTER:	REF BBLOCK;	! pointer to map area


! Compute the address in the file header where the pointer should go.
! Then determine the format of the pointer and build it.
!
MAP_POINTER = .BUFFER + 2 * (.BUFFER[FH2$B_MPOFFSET] + .BUFFER[FH2$B_MAP_INUSE]);


IF .COUNT LEQU 256 AND .LBN LSSU 1^22
THEN
    BEGIN

    ! Check for map area overflow.
    !
    IF .MAP_POINTER + 4 GTRA .BUFFER + 2 * .BUFFER[FH2$B_ACOFFSET]
    THEN
	RETURN SS$_HEADERFULL;


    ! Build the map pointer.
    !
    MAP_POINTER[FM2$V_FORMAT] = FM2$C_FORMAT1;
    MAP_POINTER[FM2$B_COUNT1] = .COUNT - 1;
    MAP_POINTER[FM2$V_HIGHLBN] = .LBN<16,6>;
    MAP_POINTER[FM2$W_LOWLBN] = .LBN<0,16>;
    BUFFER[FH2$B_MAP_INUSE] = .BUFFER[FH2$B_MAP_INUSE] + 2;
    END
ELSE IF .COUNT LEQU 16384
THEN
    BEGIN

    ! Check for map area overflow.
    !
    IF .MAP_POINTER + 6 GTRA .BUFFER + 2 * .BUFFER[FH2$B_ACOFFSET]
    THEN
	RETURN SS$_HEADERFULL;


    ! Build the map pointer.
    !
    MAP_POINTER[FM2$V_FORMAT] = FM2$C_FORMAT2;
    MAP_POINTER[FM2$V_COUNT2] = .COUNT - 1;
    MAP_POINTER[FM2$L_LBN2] = .LBN;
    BUFFER[FH2$B_MAP_INUSE] = .BUFFER[FH2$B_MAP_INUSE] + 3;
    END
ELSE IF .COUNT LEQU 1^30
THEN
    BEGIN

    ! Check for map area overflow.
    !
    IF .MAP_POINTER + 8 GTRA .BUFFER + 2 * .BUFFER[FH2$B_ACOFFSET]
    THEN
	RETURN SS$_HEADERFULL;


    ! Build the map pointer.
    !
    .MAP_POINTER = ROT(.COUNT-1, 16);
    MAP_POINTER[FM2$V_FORMAT] = FM2$C_FORMAT3;
    MAP_POINTER[FM2$L_LBN3] = .LBN;
    BUFFER[FH2$B_MAP_INUSE] = .BUFFER[FH2$B_MAP_INUSE] + 4;
    END
ELSE
    SIGNAL(BACKUP$_LARGECNT, 1, CURRENT_VCB[VCB_DEVICE]);


SS$_NORMAL
END;

GLOBAL ROUTINE CREATE_WINDOW(P_HEADER,P_RVN,P_WINDOW,START_VBN,WINDOW_SIZE)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates a window block (or blocks) from a file
!	header, reading the extension headers as necessary.
!
! INPUT PARAMETERS:
!	P_HEADER	- Pointer to file header to be processed.
!	P_RVN		- Relative volume number of file header.
!	P_WINDOW	- Pointer to where window is returned.
!	START_VBN	- Starting VBN of file header.
!	WINDOW_SIZE	- Minimum size to allocate for window in pointers.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	CURRENT_MTL[MTL_FILESIZE] - Contains total space allocated to file.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LINKAGE
	L_MAP_POINTER=	JSB:
			GLOBAL(COUNT=6, LBN=7, MAP_POINTER=8);
EXTERNAL ROUTINE
	GET_MAP_POINTER: L_MAP_POINTER; ! Get value of ODS-2 file map pointer
LOCAL
	STATUS,				! Status return
	W_SIZE,				! size to allocate window
	DYNWCB:		REF BBLOCK,	! Pointer to dynamic WCB
	HEADER:		REF BBLOCK,	! Pointer to current file header
	RVN,				! RVN of current file header
	EXT_FILE_ID:	BBLOCK[FID$C_LENGTH],	! Extension file ID
	LOCAL_HEADER:	BBLOCK[512],	! Local area for file header
	LAST_WINDOW:	REF BBLOCK,	! Last block in window list
	WINDOW:		BBLOCK[WCB_S_HEADER + 255 * WCB_S_ENTRY],
	P:		REF BBLOCK;	! Pointer to current window entry

	
! Initialize.
!
.P_WINDOW = 0;
CURRENT_MTL[MTL_FILESIZE] = 0;
HEADER = .P_HEADER;
RVN = .P_RVN;
LAST_WINDOW = 0;
WINDOW[WCB_LINK] = 0;
WINDOW[WCB_VBN] = .START_VBN;
WINDOW[WCB_SIZE] = 0;
WINDOW[WCB_RVN] = .RVN;
WINDOW[WCB_FLAGS] = 0;
P = WINDOW + WCB_S_HEADER - WCB_S_ENTRY;


! Loop over this header and all of its extension headers.
!
WHILE TRUE DO
    BEGIN
    GLOBAL REGISTER
	COUNT=		6,		! Retrieval pointer count
	LBN=		7,		! Retrieval pointer LBN
	MAP_POINTER=	8: REF BBLOCK;	! Pointer to scan map area
    LOCAL
	END_MAP;			! Pointer to end of used map area


    ! Get pointers to the map area and the end of the used portion
    ! of the map area.
    !
    IF .HEADER[FH2$B_STRUCLEV] EQL 2
    THEN
	BEGIN
	MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;
	END_MAP = .MAP_POINTER + .HEADER[FH2$B_MAP_INUSE]*2;
	END
    ELSE
	BEGIN
	MAP_POINTER = .HEADER + .HEADER[FH1$B_MPOFFSET]*2;
	END_MAP = .MAP_POINTER + FM1$C_POINTERS + .MAP_POINTER[FM1$B_INUSE]*2;
	MAP_POINTER = .MAP_POINTER + FM1$C_POINTERS;
	END;


    ! Loop until entire map processed.
    !
    UNTIL .MAP_POINTER GEQA .END_MAP DO
	BEGIN

	! Get count and LBN.
	!
	IF .HEADER[FH2$B_STRUCLEV] EQL 2
	THEN
	    GET_MAP_POINTER()
	ELSE
	    BEGIN
	    LBN = .MAP_POINTER[FM1$W_LOWLBN];
	    LBN<16,8> = .MAP_POINTER[FM1$B_HIGHLBN];
	    COUNT = .MAP_POINTER[FM1$B_COUNT] + 1;
	    MAP_POINTER = .MAP_POINTER + 4;
	    END;


	! Count into total space.
	!
	CURRENT_MTL[MTL_FILESIZE] = .CURRENT_MTL[MTL_FILESIZE] + .COUNT;


	! Collapse with previous map pointer if contiguous with it and it is on
	! same RVN -- otherwise, generate new map pointer.
	!
	IF
	    BEGIN
	    IF .WINDOW[WCB_RVN] NEQ .RVN
	    THEN
		FALSE
	    ELSE IF .WINDOW[WCB_SIZE] NEQ 0
	    THEN
		.P[WCB_COUNT] + .P[WCB_LBN] EQL .LBN
	    ELSE
		FALSE
	    END
	THEN
	    P[WCB_COUNT] = .P[WCB_COUNT] + .COUNT
	ELSE
	    BEGIN
	    IF .WINDOW[WCB_SIZE] GEQU 255 OR .WINDOW[WCB_RVN] NEQ .RVN
	    THEN
		BEGIN

		! Window block has overflowed.  Move local window block to
		! dynamic space and initialize for new block.
		!
		WINDOW[WCB_FREE] = 0;
		DYNWCB = GET_VM(WCB_S_HEADER + .WINDOW[WCB_SIZE]*WCB_S_ENTRY);
		CH$MOVE(WCB_S_HEADER + .WINDOW[WCB_SIZE] * WCB_S_ENTRY, WINDOW, .DYNWCB);
		IF .LAST_WINDOW NEQ 0
		    THEN LAST_WINDOW[WCB_LINK] = .DYNWCB;
		IF ..P_WINDOW EQL 0 THEN .P_WINDOW = .DYNWCB;
		LAST_WINDOW = .DYNWCB;
		WINDOW[WCB_LINK] = 0;
		WINDOW[WCB_VBN] = 0;
		WINDOW[WCB_SIZE] = 0;
		WINDOW[WCB_RVN] = .RVN;
		WINDOW[WCB_FLAGS] = 0;
		P = WINDOW + WCB_S_HEADER - WCB_S_ENTRY;
		END;


	    ! Generate new pointer.
	    !
	    WINDOW[WCB_SIZE] = .WINDOW[WCB_SIZE] + 1;
	    P = .P + WCB_S_ENTRY;
	    P[WCB_COUNT] = .COUNT;
	    P[WCB_LBN] = .LBN;
	    END;
	END;


    ! Allocate a new window at each header boundary. This is necessary
    ! in creating the window for a multi-header ODS-1 index file, since
    ! the call below to read the extension header needs the first part
    ! of the window in place. The de-optimization otherwise caused
    ! is minimal.
    !
    W_SIZE = MAXU(.WINDOW[WCB_SIZE], .WINDOW_SIZE);
    DYNWCB = GET_VM(WCB_S_HEADER + .W_SIZE * WCB_S_ENTRY);
    WINDOW[WCB_FREE] = .W_SIZE - .WINDOW[WCB_SIZE];
    CH$MOVE(WCB_S_HEADER + .WINDOW[WCB_SIZE] * WCB_S_ENTRY, WINDOW, .DYNWCB);
    IF .LAST_WINDOW NEQ 0
	THEN LAST_WINDOW[WCB_LINK] = .DYNWCB;
    IF ..P_WINDOW EQL 0 THEN .P_WINDOW = .DYNWCB;
    LAST_WINDOW = .DYNWCB;
    WINDOW[WCB_VBN] = 0;
    WINDOW[WCB_SIZE] = 0;
    WINDOW[WCB_FLAGS] = 0;
    P = WINDOW + WCB_S_HEADER - WCB_S_ENTRY;


    ! If no extension header exists, finish up.
    !
    IF .CURRENT_MTL[MTL_SEQ_DISK]
    OR
	BEGIN
	IF .HEADER[FH2$B_STRUCLEV] EQL 2
	THEN
	    .HEADER[FH2$W_EX_FIDNUM] EQL 0
	    AND .HEADER[FH2$W_EX_FIDRVN] EQL 0
	ELSE
	    BEGIN
	    MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;
	    .MAP_POINTER[FM1$W_EX_FILNUM] EQL 0
	    END
	END
    THEN
	EXITLOOP;


    ! Get clean file number and RVN.
    !
    IF .HEADER[FH2$B_STRUCLEV] EQL 2
    THEN
	BEGIN
	EXT_FILE_ID[FID$W_NUM] = .HEADER[FH2$W_EX_FIDNUM];
	EXT_FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_EX_FIDSEQ];
	EXT_FILE_ID[FID$W_RVN] = .HEADER[FH2$W_EX_FIDRVN];
	END
    ELSE
	BEGIN
	EXT_FILE_ID[FID$W_NUM] = .MAP_POINTER[FM1$W_EX_FILNUM];
	EXT_FILE_ID[FID$W_SEQ] = .MAP_POINTER[FM1$W_EX_FILSEQ];
	EXT_FILE_ID[FID$W_RVN] = 1;
	END;
    IF .EXT_FILE_ID[FID$B_RVN] EQL 0 THEN EXT_FILE_ID[FID$B_RVN] = .RVN;


    ! Set up header and RVN for next trip through loop.
    !
    HEADER = LOCAL_HEADER;
    RVN = .EXT_FILE_ID[FID$B_RVN];


    ! Read extension file header.  If this fails,
    ! exit the loop.
    !
    STATUS = READ_HEADER(EXT_FILE_ID, .HEADER);
    IF NOT .STATUS
    THEN
	BEGIN
	DELETE_WINDOW(..P_WINDOW);
	RETURN .STATUS;
	END;
    WINDOW[WCB_RVN] = .RVN;
    END;


! Return success.
!
SS$_NORMAL
END;

ROUTINE DELETE_WINDOW(WINDOW): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes a window block (or blocks).
!
! INPUT PARAMETERS:
!	WINDOW		- Pointer to window block.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Window blocks released.
!
!--

BEGIN
MAP
	WINDOW:		REF BBLOCK;	! Pointer to window block
LOCAL
	W:		REF BBLOCK;	! Pointer to window block


W = .WINDOW;
WHILE .W NEQ 0 DO
    BEGIN
    LOCAL
	NEXT:		REF BBLOCK;	! Pointer to next window block

    NEXT = .W[WCB_LINK];		! Point to next block
    FREE_VM(				! Free current block
	WCB_S_HEADER + (.W[WCB_SIZE] + .W[WCB_FREE]) * WCB_S_ENTRY,
	.W);
    W = .NEXT;				! Advance to next block
    END;
END;

ROUTINE ADD_BLACKHOLE_MAP(P_WINDOW,COUNT): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine adds a black hole pointer to the specified window.
!	Write I/O's that map to a black hole pointer are discarded.
!
! INPUT PARAMETERS:
!	P_WINDOW	- Pointer to window block.
!	COUNT		- Count of blocks.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	W:		REF BBLOCK,	! Local pointer to window segment
	WINDOW:		REF BBLOCK;	! Address of new window allocated


! Find the last window block.
!
W = .P_WINDOW;
UNTIL .W[WCB_LINK] EQL 0 DO W = .W[WCB_LINK];


! If this window block already contains a pointer but is not a black hole,
! allocate a new one.  Since there is never a need for more than one mapping
! pointer, only allocate one.  However, if the window block is empty, transform
! it into a black hole.
!
IF NOT .W[WCB_BLACKHOLE] AND .W[WCB_SIZE] NEQ 0
THEN
    BEGIN
    WINDOW = GET_VM(WCB_S_ENTRY + WCB_S_HEADER);
    W[WCB_LINK] = .WINDOW;
    W = .WINDOW;
    W[WCB_LINK] = 0;
    W[WCB_VBN] = 0;
    W[WCB_RVN] = 0;
    W[WCB_FREE] = 1;
    W[WCB_SIZE] = 0;
    W[WCB_FLAGS] = 0;
    END;


! If no pointer exists yet, initialize it.  There can be no more than one
! pointer in a black hole window block.
!
IF .W[WCB_SIZE] EQL 0
THEN
    BEGIN
    W[WCB_BLACKHOLE] = TRUE;
    W[WCB_SIZE] = 1;
    W[WCB_FREE] = .W[WCB_FREE] - 1;
    BBLOCK[.W + WCB_S_HEADER, WCB_COUNT] = 0;
    BBLOCK[.W + WCB_S_HEADER, WCB_LBN] = 0;
    END;


! Finally add the blocks to the pointer.
!
BBLOCK[.W + WCB_S_HEADER, WCB_COUNT] =
    .BBLOCK[.W + WCB_S_HEADER, WCB_COUNT] + .COUNT;
END;

ROUTINE ADD_WINDOW_MAP(P_WINDOW,RVN,COUNT,LBN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine adds a window pointer mapping the specified blocks
!	to the specified window.  If the window is full or describes a
!	different RVN, an extension of the same size is added.
!
! INPUT PARAMETERS:
!	P_WINDOW	- Pointer to window block.
!	RVN		- Relative volume number of blocks to be added.
!	COUNT		- Count of blocks to be added.
!	LBN		- Starting LBN of blocks.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	W:		REF BBLOCK,	! Local pointer to window segment
	P:		REF BBLOCK,	! Pointer to window map entry
	SIZE,				! Size of new segment to allocate
	WINDOW:		REF BBLOCK;	! Address of new window allocated


! Find the last segment of the current window.
!
W = .P_WINDOW;
UNTIL .W[WCB_LINK] EQL 0 DO W = .W[WCB_LINK];


! If this segment has been used and if it describes blocks on a different
! RVN or if this segment is full, allocate a new one.
!
IF
    (.W[WCB_SIZE] NEQ 0 AND .W[WCB_RVN] NEQ .RVN) OR
    .W[WCB_FREE] EQL 0
THEN
    BEGIN
    SIZE = MAXU(.W[WCB_SIZE], 10);
    WINDOW = GET_VM(.SIZE * WCB_S_ENTRY + WCB_S_HEADER);
    W[WCB_LINK] = .WINDOW;
    W = .WINDOW;
    W[WCB_LINK] = 0;
    W[WCB_VBN] = 0;
    W[WCB_SIZE] = 0;
    W[WCB_FREE] = .SIZE;
    W[WCB_FLAGS] = 0;
    END;


! Finally add the pointer.  No attempt is made at agglomeration since we
! will never allocate an area that could be contiguous.
!
P = .W + WCB_S_HEADER + .W[WCB_SIZE]*WCB_S_ENTRY;
W[WCB_SIZE] = .W[WCB_SIZE] + 1;
W[WCB_FREE] = .W[WCB_FREE] - 1;
W[WCB_RVN] = .RVN;
P[WCB_COUNT] = .COUNT;
P[WCB_LBN] = .LBN;
END;

ROUTINE QIO_AST(VCB): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is a completion AST routine for the $QIO service in
!	routine R_W_VIRTUAL.  It decreases the pending I/O count for the
!	volume, and if it reaches zero, sets event flag 31.
!
! INPUT PARAMETERS:
!	VCB		- Pointer to VCB.
!	Remaining standard AST parameters (not used).
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Pending I/O count in VCB decreased.  EFN 31 may be set.
!
!--

BEGIN
MAP
	VCB:		REF BBLOCK;


VCB[VCB_IOCOUNT] = .VCB[VCB_IOCOUNT] - 1;
IF .VCB[VCB_IOCOUNT] LEQ 0 THEN $SETEF(EFN=31);
END;

ROUTINE R_W_VIRTUAL(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine maps a read or write virtual block QIO to the appropriate
!	read or write logical block QIO's using the current window.
!
! INPUT PARAMETERS:
!	As for $QIO(W) service.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!	CURRENT_WCB	- Pointer to WCB for current file.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL if execution is successful or SS$_ENDOFFILE if the
!	specified virtual block(s) are not completely within the file.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	IOSB:		REF VECTOR [,WORD];

LOCAL
	CHANNEL,			! Channel number
	W:		REF BBLOCK,	! Pointer to window block
	P:		REF BBLOCK,	! Pointer to window block entry
	N,				! VBN mapped so far
	LFUNC,				! Logical function code
	LP1, LP2, LP3;			! Local copies of P1, P2, P3


! Pick up local copies of P1, P2, and P3 so that they can advance as the
! transfer is done.  Get the appropriate logical function code.
!
LP1 = .P1;
LP2 = .P2;
LP3 = .P3;
LFUNC = .FUNC - IO$_READVBLK + IO$_READLBLK;


! The virtual block number must not be 0, and there must be a window.
!
IF .LP3 EQL 0 OR .CURRENT_WCB EQL 0
THEN
    RETURN SS$_ENDOFFILE;


! Loop over the window blocks.
!
W = .CURRENT_WCB;
N = .W[WCB_VBN];
WHILE .W NEQ 0 DO
    BEGIN
    P = .W + WCB_S_HEADER;


    ! Loop over the entries within the window block. Maintain the
    ! byte count in IOSB in case we exit.
    !
    DECR I FROM .W[WCB_SIZE] TO 1 DO
	BEGIN

	! If this entry maps the first VBN of the transfer, do it.
	!
	IF .LP3 GEQU .N AND .LP3 LSSU .N + .P[WCB_COUNT]
	THEN
	    BEGIN
	    LOCAL
		STATUS,
		XP2,
		XP3;


	    XP3 = .P[WCB_LBN] + .LP3 - .N;
	    XP2 = MINU(.LP2, (.P[WCB_COUNT] - .LP3 + .N) * 512);
	    IF .LP2 EQL .XP2 AND .LP1 EQL .P1
	    THEN
		BEGIN
		IF .W[WCB_BLACKHOLE]
		THEN
		    BEGIN
		    $SETEF(EFN=.EFN);
		    IF .IOSB NEQ 0 THEN IOSB[0] = SS$_NORMAL;
		    RETURN SS$_NORMAL;
		    END
		ELSE
		    BEGIN
		    LOCAL
			VCB:	REF BBLOCK;

		    VCB = .CURRENT_MTL[MTL_VCB(.W[WCB_RVN]-.CURRENT_MTL[MTL_RVN_BASE])];
		    CHANNEL = SWITCH_VOLUME(.W[WCB_RVN]);
		    STATUS = $QIO(
			FUNC=.LFUNC,
			CHAN=.CHANNEL,
			IOSB=.IOSB,
			EFN=.EFN,
			ASTADR=QIO_AST,
			ASTPRM=.VCB,
			P1=.LP1,
			P2=.XP2,
			P3=.XP3);


		    ! Increment the pending I/O count for this volume.
		    !
		    IF .STATUS THEN VCB[VCB_IOCOUNT] = .VCB[VCB_IOCOUNT] + 1;
		    RETURN .STATUS;
		    END
		END
	    ELSE
		BEGIN
		IF NOT .W[WCB_BLACKHOLE]
		THEN
		    BEGIN
		    LOCAL
			L_IOSB:	VECTOR[4,WORD];

		    CHANNEL = SWITCH_VOLUME(.W[WCB_RVN]);
		    STATUS = $QIOW(
			FUNC=.LFUNC,
			CHAN=.CHANNEL,
			IOSB=L_IOSB,
			P1=.LP1,
			P2=.XP2,
			P3=.XP3);
		    IF .STATUS THEN STATUS = .L_IOSB[0];
		    IF NOT .STATUS
		    THEN RETURN .STATUS;
		    END;
		END;
	    LP1 = .LP1 + .XP2;
	    LP2 = .LP2 - .XP2;
	    LP3 = .LP3 + .XP2 / 512;

	    ! Maintain byte count in IOSB and check for completion.
	    !
	    IF .IOSB NEQ 0
	    THEN
		BEGIN
		IOSB[0] = SS$_NORMAL;
		IOSB[1] = .P2 - .LP2;
		END;
	    IF .LP2 LEQ 0
	    THEN RETURN SS$_NORMAL;
	    END;


	! Advance to next entry.
	!
	N = .N + .P[WCB_COUNT];
	P = .P + WCB_S_ENTRY;
	END;


    ! Advance to next window block.
    !
    W = .W[WCB_LINK];
    END;


! There were not enough mapping pointers to advance to the specified virtual
! block number.  Therefore, return SS$_ENDOFFILE.
!
SS$_ENDOFFILE
END;

ROUTINE READ_HOMEBLOCK(CHANNEL,DEVICE_CHAR,HOME_BLOCK): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine reads the home block from a specified volume.
!
! INPUT PARAMETERS:
!	CHANNEL		- Channel number assigned to device.
!	DEVICE_CHAR	- Device characteristics of device.
!	HOME_BLOCK	- Buffer into which home block will be read.
!
! IMPLICIT INPUTS:
!	CURRENT_VCB
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HOME_BLOCK:	REF BBLOCK,	! Pointer to home block buffer
	DEVICE_CHAR:	REF BBLOCK;	! Pointer to device characteristics
LOCAL
	DELTA,				! Home block search delta
	BLOCKFACT,			! Device blocking factor
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


! Compute the home block search delta from the volume geometry, according
! to the following rules, where volume geometry is expressed in the order
! sectors, tracks, cylinders:
!
!	n x 1 x 1:	1
!	1 x n x 1:	1
!	1 x 1 x n:	1
!
!	n x m x 1:	n+1
!	n x 1 x m:	n+1
!	1 x n x m:	n+1
!
!	s x t x c:	(t+1)*s+1
!
BLOCKFACT = (.DEVICE_CHAR[DIB$B_SECTORS]
	       * .DEVICE_CHAR[DIB$B_TRACKS]
	       * .DEVICE_CHAR[DIB$W_CYLINDERS])
	       / .DEVICE_CHAR[DIB$L_MAXBLOCK];


DELTA = 1;


IF
    .DEVICE_CHAR[DIB$W_CYLINDERS] GTR 1 AND
    .DEVICE_CHAR[DIB$B_TRACKS] GTR 1
THEN
    DELTA = .DELTA + .DEVICE_CHAR[DIB$B_TRACKS];


IF
    .DEVICE_CHAR[DIB$B_SECTORS] GTR 1 AND
    (.DEVICE_CHAR[DIB$W_CYLINDERS] GTR 1 OR
	.DEVICE_CHAR[DIB$B_TRACKS] GTR 1)
THEN
    DELTA = (.DELTA * .DEVICE_CHAR[DIB$B_SECTORS] + .BLOCKFACT) / .BLOCKFACT;


IF
    .DELTA EQL 0 OR
    .DELTA GTRU .DEVICE_CHAR[DIB$L_MAXBLOCK] / 10
THEN
    DELTA = 1;


! Search for a valid home block.  The loop terminates when one is found.
! If an error other than a surface error occurs, or when the entire
! volume has been examined and no valid home block found, a fatal error
! is signalled.
!
INCRU LBN FROM 1 BY .DELTA DO
    BEGIN
    STATUS = $QIOW(
	FUNC=IO$_READLBLK,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=.HOME_BLOCK,
	P2=512,
	P3=.LBN);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF .STATUS
    THEN
	BEGIN
	IF
	    BEGIN
	    SELECTONE .HOME_BLOCK[HM2$B_STRUCLEV] OF
		SET

		[1]:
		    BEGIN
		    (.HOME_BLOCK[HM1$W_STRUCLEV] EQL HM1$C_LEVEL1 OR
		     .HOME_BLOCK[HM1$W_STRUCLEV] EQL HM1$C_LEVEL2) AND
		    .HOME_BLOCK[HM1$W_IBMAPSIZE] NEQ 0 AND
		    .HOME_BLOCK[HM1$L_IBMAPLBN] NEQ 0 AND
		    .HOME_BLOCK[HM1$W_MAXFILES] NEQ 0 AND
		    .HOME_BLOCK[HM1$W_CLUSTER] NEQ 0 AND
		    CHECKSUM2(.HOME_BLOCK, $BYTEOFFSET(HM1$W_CHECKSUM1)) AND
		    CHECKSUM2(.HOME_BLOCK, $BYTEOFFSET(HM1$W_CHECKSUM2))
		    END;


		[2]:
		    BEGIN
		    .HOME_BLOCK[HM2$L_HOMELBN] EQL .LBN AND
		    .HOME_BLOCK[HM2$L_ALTIDXLBN] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_CLUSTER] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_HOMEVBN] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_ALHOMEVBN] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_ALTIDXVBN] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_IBMAPVBN] NEQ 0 AND
		    .HOME_BLOCK[HM2$L_IBMAPLBN] NEQ 0 AND
		    .HOME_BLOCK[HM2$L_MAXFILES] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_IBMAPSIZE] NEQ 0 AND
		    .HOME_BLOCK[HM2$W_RESFILES] NEQ 0 AND
		    CHECKSUM2(.HOME_BLOCK, $BYTEOFFSET(HM2$W_CHECKSUM1)) AND
		    CHECKSUM2(.HOME_BLOCK, $BYTEOFFSET(HM2$W_CHECKSUM2))
		    END;


		[OTHERWISE]:
		    FALSE;


		TES
	    END
	THEN
	    EXITLOOP;
	END
    ELSE
	BEGIN
	IF .STATUS EQL SS$_ILLBLKNUM
	THEN
	    SIGNAL(BACKUP$_NOHOMEBLK, 1, CURRENT_VCB[VCB_DEVICE]);

	IF
	    .STATUS NEQ SS$_PARITY AND
	    .STATUS NEQ SS$_FORMAT AND
	    .STATUS NEQ SS$_DATACHECK
	THEN
	    SIGNAL(BACKUP$_READERR + STS$K_SEVERE, 1, CURRENT_VCB[VCB_DEVICE], .STATUS);
	END;
    END;
END;

GLOBAL ROUTINE STA_INIVOL: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes a volume.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	OUTPUT_ATTBUF	- Contains volume summary attributes.
!	OUTPUT_MTL	- Pointer to MTL for output volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	HOME_BLOCK:	BBLOCK[512],	! Home block buffer
	RVN,				! Actual RVN
	CHANNEL,			! Channel number
	DESC:		VECTOR[2],	! Descriptor
	DEVCHAR:	BBLOCK[DIB$C_LENGTH],	! Device characteristics
	STATUS;				! Status variable


! Find the MTL and VCB for the volume to be initialized.
!
RVN = .OUTPUT_ATTBUF[VSR_RVN];
IF .RVN EQL 0 THEN RVN = 1;
CURRENT_MTL = .OUTPUT_MTL;


! Make sure the number of output volumes specified in the command matches
! the number specified in the save set.
!
IF NOT .QUAL[QUAL_VOLU]
THEN
    IF
	BEGIN
	IF .COM_O_SETCOUNT EQL 0
	    THEN .CURRENT_MTL[MTL_SETCOUNT] NEQ 1
	    ELSE .CURRENT_MTL[MTL_SETCOUNT] NEQ .COM_O_SETCOUNT
	END
    THEN
	SIGNAL(BACKUP$_BADSETCNT);


! Make sure the relative volume number specified in the save set is
! within range.
!
IF .RVN-.CURRENT_MTL[MTL_RVN_BASE] GTRU .CURRENT_MTL[MTL_SETCOUNT]
THEN
    SIGNAL(BACKUP$_INVATTVAL);


! Assign a channel to the volume and get the device characteristics.
!
CURRENT_VCB = .CURRENT_MTL[MTL_VCB(.RVN-.CURRENT_MTL[MTL_RVN_BASE])];
CHANNEL = SWITCH_VOLUME(.RVN);
DESC[0] = DIB$C_LENGTH;
DESC[1] = DEVCHAR;
STATUS = $GETCHN(CHAN=.CHANNEL, PRIBUF=DESC);
IF NOT .STATUS
THEN
    SIGNAL(BACKUP$_GETCHN, 1, CURRENT_VCB[VCB_DEVICE]);


! If the initialization parameters are to be propagated from the output
! volume, read its home block and reinitialize OUTPUT_ATTBUF as appropriate.
!
IF NOT .QUAL[QUAL_INIT]
THEN
    BEGIN

    ! Read the home block.
    !
    READ_HOMEBLOCK(.CHANNEL, DEVCHAR, HOME_BLOCK);


    ! Make sure that the new structure level matches the old.  This is the
    ! only initialization parameter that must not change.
    !
    IF .HOME_BLOCK[HM2$B_STRUCLEV] NEQ .(OUTPUT_ATTBUF[VSR_VOLSTRUCT])<8,8>
    THEN
	SIGNAL(BACKUP$_STRUCLEV, 1, CURRENT_VCB[VCB_DEVICE]);


    ! Reinitialize the OUTPUT_ATTBUF area with the initialization parameters
    ! from the output volume.
    !
    IF .HOME_BLOCK[HM2$B_STRUCLEV] EQL 2
    THEN
	BEGIN
	BBLOCK[OUTPUT_ATTBUF[VSR_VOLNAME], DSC$W_LENGTH] = HM2$S_VOLNAME;
	BBLOCK[OUTPUT_ATTBUF[VSR_VOLNAME], DSC$A_POINTER] = HOME_BLOCK[HM2$T_VOLNAME];
	BBLOCK[OUTPUT_ATTBUF[VSR_OWNERNAME], DSC$W_LENGTH] = HM2$S_OWNERNAME;
	BBLOCK[OUTPUT_ATTBUF[VSR_OWNERNAME], DSC$A_POINTER] = HOME_BLOCK[HM2$T_OWNERNAME];
	(OUTPUT_ATTBUF[VSR_VOLDATE]) = .(HOME_BLOCK[HM2$Q_CREDATE]);
	(OUTPUT_ATTBUF[VSR_VOLDATE]+4) = .(HOME_BLOCK[HM2$Q_CREDATE]+4);
	OUTPUT_ATTBUF[VSR_VOLOWNER] = .HOME_BLOCK[HM2$L_VOLOWNER];
	OUTPUT_ATTBUF[VSR_MAXFILES] = .HOME_BLOCK[HM2$L_MAXFILES];
	OUTPUT_ATTBUF[VSR_PROTECT] = .HOME_BLOCK[HM2$W_PROTECT];
	OUTPUT_ATTBUF[VSR_FILEPROT] = .HOME_BLOCK[HM2$W_FILEPROT];
	OUTPUT_ATTBUF[VSR_RECPROT] = .HOME_BLOCK[HM2$W_RECPROT];
	OUTPUT_ATTBUF[VSR_VOLCHAR] = .HOME_BLOCK[HM2$W_VOLCHAR];
	OUTPUT_ATTBUF[VSR_EXTEND] = .HOME_BLOCK[HM2$W_EXTEND];
	OUTPUT_ATTBUF[VSR_CLUSTER] = .HOME_BLOCK[HM2$W_CLUSTER];
	OUTPUT_ATTBUF[VSR_WINDOW] = .HOME_BLOCK[HM2$B_WINDOW];
	OUTPUT_ATTBUF[VSR_LRU_LIM] = .HOME_BLOCK[HM2$B_LRU_LIM];
	OUTPUT_ATTBUF[VSR_INDEXLBN] = .HOME_BLOCK[HM2$L_IBMAPLBN];
	(OUTPUT_ATTBUF[VSR_RETAINMIN]) = .(HOME_BLOCK[HM2$Q_RETAINMIN]);
	(OUTPUT_ATTBUF[VSR_RETAINMIN]+4) = .(HOME_BLOCK[HM2$Q_RETAINMIN]+4);
	(OUTPUT_ATTBUF[VSR_RETAINMAX]) = .(HOME_BLOCK[HM2$Q_RETAINMAX]);
	(OUTPUT_ATTBUF[VSR_RETAINMAX]+4) = .(HOME_BLOCK[HM2$Q_RETAINMAX]+4);
	IF .HOME_BLOCK[HM2$W_RVN] EQL 1 AND .HOME_BLOCK[HM2$W_SETCOUNT] NEQ 0
	THEN
	    CH$MOVE(
		HM2$S_STRUCNAME,
		HOME_BLOCK[HM2$T_STRUCNAME],
		COM_O_STRUCNAME);
	END
    ELSE
	BEGIN
	OUTPUT_ATTBUF[VSR_STRUCLEV] = .HOME_BLOCK[HM1$W_STRUCLEV];
	BBLOCK[OUTPUT_ATTBUF[VSR_VOLNAME], DSC$W_LENGTH] = HM1$S_VOLNAME;
	BBLOCK[OUTPUT_ATTBUF[VSR_VOLNAME], DSC$A_POINTER] = HOME_BLOCK[HM1$T_VOLNAME2];
	BBLOCK[OUTPUT_ATTBUF[VSR_OWNERNAME], DSC$W_LENGTH] = HM1$S_OWNERNAME;
	BBLOCK[OUTPUT_ATTBUF[VSR_OWNERNAME], DSC$A_POINTER] = HOME_BLOCK[HM1$T_OWNERNAME];
	FROM_ODS1_DATE(HOME_BLOCK[HM1$T_CREDATE], OUTPUT_ATTBUF[VSR_VOLDATE]);
	OUTPUT_ATTBUF[VSR_VOLOWNER] = .(HOME_BLOCK[HM1$W_VOLOWNER])<0,8>;
	(OUTPUT_ATTBUF[VSR_VOLOWNER])<16,8> = .(HOME_BLOCK[HM1$W_VOLOWNER])<8,8>;
	OUTPUT_ATTBUF[VSR_MAXFILES] = .HOME_BLOCK[HM1$W_MAXFILES];
	OUTPUT_ATTBUF[VSR_PROTECT] = .HOME_BLOCK[HM1$W_PROTECT];
	OUTPUT_ATTBUF[VSR_FILEPROT] = .HOME_BLOCK[HM1$W_FILEPROT];
	OUTPUT_ATTBUF[VSR_EXTEND] = .HOME_BLOCK[HM1$B_EXTEND];
	OUTPUT_ATTBUF[VSR_WINDOW] = .HOME_BLOCK[HM1$B_WINDOW];
	OUTPUT_ATTBUF[VSR_LRU_LIM] = .HOME_BLOCK[HM1$B_LRU_LIM];
	OUTPUT_ATTBUF[VSR_INDEXLBN] = ROT(.HOME_BLOCK[HM1$L_IBMAPLBN], 16);
	END;
    END;


! Call the volume initialization routine to complete the work.
!
CURRENT_MTL[MTL_STRUCLEV] = .OUTPUT_ATTBUF[VSR_STRUCLEV];
CURRENT_VCB[VCB_ODS_2] = (.CURRENT_MTL[MTL_STRUCLEV] EQL 2);
INITIALIZE_VOLUME(.CURRENT_VCB, DEVCHAR);
END;

GLOBAL ROUTINE STA_INIT_HDRS(REC): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes file headers on an output volume to have the
!	file sequence numbers that they had originally.
!
! INPUT PARAMETERS:
!	REC		- Pointer to save set record, type BRH$K_FID.
!
! IMPLICIT INPUTS:
!	OUTPUT_MTL	- Pointer to MTL for output volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	REC:		REF BBLOCK;		! Pointer to save set record
LOCAL
	RSA:		VECTOR[NAM$C_MAXRSS,BYTE],	! Resultant string area
	CHANNEL,				! Channel for output volume
	STATUS,					! Status return
	IOSB:		VECTOR[4,WORD],		! I/O status block
	FILE_ID:	BBLOCK[FID$C_LENGTH],	! Current file ID
	FILE_NUMBER,				! File number of first header
	AREA,					! Pointer to allocated memory
	HDR:		REF BBLOCK,		! Pointer to current header
	SEQ:		REF BBLOCK;		! Cursor for sequence vector


! Initialize.
!
CURRENT_MTL = .OUTPUT_MTL;
IF .REC[BSA$B_FID_RVN] GEQU .CURRENT_MTL[MTL_SETCOUNT] + .CURRENT_MTL[MTL_RVN_BASE]
OR .REC[BSA$B_FID_RVN] LSSU .CURRENT_MTL[MTL_RVN_BASE]
THEN SIGNAL(BACKUP$_INVATTVAL);
CURRENT_VCB = .CURRENT_MTL[MTL_VCB(.REC[BSA$B_FID_RVN]-.CURRENT_MTL[MTL_RVN_BASE])];
RSA_DESC[0] = NAM$C_MAXRSS;
RSA_DESC[1] = RSA;
$FAO(
    $DESCRIPTOR('!AS[000000]INDEXF.SYS;1'),
    RSA_DESC,
    RSA_DESC,
    CURRENT_VCB[VCB_DEVICE]);


! Get memory for buffer.
!
AREA = GET_VM(512 * .REC[BSA$W_FID_COUNT]);


HDR = .AREA;
SEQ = .REC;
FILE_NUMBER = .REC[BSA$W_FID_NUM];
FILE_NUMBER<16,8> = .REC[BSA$B_FID_NMX];
INCR N FROM .FILE_NUMBER TO .FILE_NUMBER+.REC[BSA$W_FID_COUNT]-1 DO
    BEGIN
    IF .N GTRU .CURRENT_VCB[VCB_MAXFILIDX] THEN SIGNAL(BACKUP$_INVATTVAL);
    FILE_ID[FID$W_NUM] = .N;
    FILE_ID[FID$B_NMX] = .N<16,8>;
    FILE_ID[FID$W_SEQ] = .SEQ[BSA$W_FID_SEQ];
    FILE_ID[FID$B_RVN] = .REC[BSA$B_FID_RVN];
    IF
	BEGIN
	IF .N-1 LEQU 15
	THEN
	    .BITVECTOR[CURRENT_VCB[VCB_INIT_HDRS], .N-1]
	ELSE
	    FALSE
	END
    THEN
	BEGIN

	! Initial file header.  Reread it, rather than blowing it away.
	!
	READ_HEADER(FILE_ID, .HDR);
	END
    ELSE
	BEGIN

	! Initialize file header as a deleted header with the appropriate
	! file sequence number.
	!
	CREATE_DELHDR(FILE_ID, .HDR);
	END;
    HDR = .HDR + 512;
    SEQ = .SEQ + 2;
    END;


! Write out buffer to index file.
!
CHANNEL = SWITCH_VOLUME(.REC[BSA$B_FID_RVN]);
CURRENT_WCB = .CURRENT_VCB[VCB_INDEXF];
STATUS = R_W_VIRTUAL(
    0,
    0,
    IO$_WRITEVBLK,
    IOSB,
    0,
    0,
    .AREA,
    512 * .REC[BSA$W_FID_COUNT],
    .FILE_NUMBER + .CURRENT_VCB[VCB_HDR_OFFSET]);
$WAITFR(EFN=0);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);


! Release memory for buffer.
!
FREE_VM(512 * .REC[BSA$W_FID_COUNT], .AREA);
END;

GLOBAL ROUTINE STA_WRITEBOOT: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called to initialize the boot block.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	OUTPUT_ATTBUF	- Contains file attributes.
!	OUTPUT_MTL	- Pointer to MTL for output volume set.
!			  Boot file is accessed.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Boot block rewritten.
!
!--

BEGIN
LOCAL
	RSA:		VECTOR[NAM$C_MAXRSS,BYTE],	! Resultant string area
	BUFFER:		BBLOCK[512],	! Buffer for boot block
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


! Read the boot block from the relative volume on which the presently accessed
! file is located.
!
CURRENT_MTL = .OUTPUT_MTL;
CURRENT_VCB = .CURRENT_MTL[MTL_VCB(.CURRENT_MTL[MTL_FID_RVN]-.CURRENT_MTL[MTL_RVN_BASE])];
CURRENT_WCB = .CURRENT_VCB[VCB_INDEXF];
RSA_DESC[0] = NAM$C_MAXRSS;
RSA_DESC[1] = RSA;
$FAO(
    $DESCRIPTOR('!AS[000000]INDEXF.SYS;1'),
    RSA_DESC,
    RSA_DESC,
    CURRENT_VCB[VCB_DEVICE]);
STATUS = R_W_VIRTUAL(
    0,
    0,
    IO$_READVBLK,
    IOSB,
    0,
    0,
    BUFFER,
    512,
    1);
$WAITFR(EFN=0);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(BACKUP$_READERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
    RETURN;
    END;


! Update the boot LBN in the second longword of the boot block to point to
! the VBN given by OUTPUT_ATTBUF[FAR_BOOTVBN] of the presently accessed file.
! The file is assumed to be contiguous.
!
BUFFER[4,0,32,0] =
    ROT(
	.BBLOCK[BBLOCK[.CURRENT_MTL[MTL_WINDOW], WCB_S_HEADER,0,0,0], WCB_LBN] +
	.OUTPUT_ATTBUF[FAR_BOOTVBN] - 1,
    16);


! Rewrite the boot block.
!
STATUS = R_W_VIRTUAL(
    0,
    0,
    IO$_WRITEVBLK,
    IOSB,
    0,
    0,
    BUFFER,
    512,
    1);
$WAITFR(EFN=0);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
END;

GLOBAL ROUTINE STA_MOUNT (MODE, P_RVN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine mounts a volume set.
!
! INPUT PARAMETERS:
!	MODE		- 0: input volume to be read
!			  1: output volume to be initialized
!			  3: output volume to be updated
!	P_RVN (optional): if absent, completely mount entire volume set
!			  if n, mount RVN n of sequential save set
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_MTL	- Pointer to MTL for input volume set.
!	OUTPUT_MTL	- Pointer to MTL for output volume set.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LINKAGE
	L_MAP_POINTER=	JSB:
			GLOBAL(COUNT=6, LBN=7, MAP_POINTER=8);
LOCAL
	Q:		REF BBLOCK,	! Pointer to qualifier block
	MTL:		REF BBLOCK,	! Pointer to MTL block
	VCB:		REF BBLOCK,	! Pointer to VCB block
	SETCOUNT,			! Count of volumes in set
	CHANNEL,			! Channel number
	STATUS,				! System service status
	IOSB:		VECTOR[4,WORD],	! I/O status block
	DEVICE_CHAR:	BBLOCK[DIB$C_LENGTH],	! Device characteristics
	DESC:		VECTOR[2],	! Descriptor
	HOME_BLOCK:	BBLOCK[512],	! Home block buffer
	HEADER:		BBLOCK[512];	! Index file header buffer
BIND
	INDEX_FILE_ID = UPLIT WORD (FID$C_INDEXF, FID$C_INDEXF, 0),
	BITMAP_FILE_ID = UPLIT WORD (FID$C_BITMAP, FID$C_BITMAP, 0);
SWITCHES
	NOSAFE;
BUILTIN
	ACTUALCOUNT;
EXTERNAL ROUTINE
	GET_MAP_POINTER: L_MAP_POINTER; ! Get value of ODS-2 file map pointer


! Count the list of devices.
!
IF (IF .MODE THEN .OUTPUT_MTL EQL 0 ELSE .INPUT_MTL EQL 0)
THEN
    BEGIN
    Q = (IF .MODE THEN .QUAL[QUAL_OUTP_LIST] ELSE .QUAL[QUAL_INPU_LIST]);
    SETCOUNT = 0;
    WHILE .Q NEQ 0 DO
	BEGIN
	SETCOUNT = .SETCOUNT + 1;
	Q = .Q[QUAL_NEXT];
	END;


! Allocate the MTL and the VCB's.
!
    MTL = GET_ZERO_VM(MTL_S_ENTRY + .SETCOUNT * %UPVAL);
    CURRENT_MTL = .MTL;
    IF .MODE
    THEN
	BEGIN
	OUTPUT_MTL = .MTL;
	IF ACTUALCOUNT () GEQ 2 THEN MTL[MTL_SEQ_DISK] = 1;
	END
    ELSE
	INPUT_MTL = .MTL;
    MTL[MTL_SETCOUNT] = .SETCOUNT;
    MTL[MTL_RVN_BASE] = 1;
    MTL[MTL_HEADER] = GET_VM(512);

! Set up the skeleton VCB's
!

    Q = (IF .MODE THEN .QUAL[QUAL_OUTP_LIST] ELSE .QUAL[QUAL_INPU_LIST]);
    INCR RVN FROM 1 TO .SETCOUNT DO
	BEGIN
	MTL[MTL_VCB(.RVN-1)] = VCB = GET_ZERO_VM(VCB_S_ENTRY);
	VCB[VCB_RVN] = .RVN;
	VCB[VCB_ACB_FLINK] = VCB[VCB_ACB_BLINK] = VCB[VCB_ACB_FLINK];
	IF .MODE NEQ 0 THEN VCB[VCB_OUTPUT] = TRUE;
	VCB[VCB_FAB] = .Q[QUAL_PARA_FC];
	BBLOCK[VCB[VCB_DEVICE], DSC$W_LENGTH] =
	    .BBLOCK[Q[QUAL_DEV_DESC], DSC$W_LENGTH];
	BBLOCK[VCB[VCB_DEVICE], DSC$A_POINTER] =
	    .BBLOCK[Q[QUAL_DEV_DESC], DSC$A_POINTER];
	Q = .Q[QUAL_NEXT];
	END;
    END;

! Now go back and do the actual mount for those volumes requested.
!

IF .MODE
THEN CURRENT_MTL = MTL = .OUTPUT_MTL
ELSE CURRENT_MTL = MTL = .INPUT_MTL;
IF ACTUALCOUNT () LSS 2
OR .P_RVN NEQ 0
THEN INCR RVN
    FROM (IF ACTUALCOUNT () LSS 2 THEN 1 ELSE .P_RVN)
    TO .MTL[MTL_SETCOUNT] + .MTL[MTL_RVN_BASE] - 1
DO
    BEGIN
    CURRENT_VCB = VCB = .MTL[MTL_VCB(.RVN-.MTL[MTL_RVN_BASE])];
    VCB[VCB_RVN] = .RVN;
    CHANNEL = SWITCH_VOLUME (.RVN);

    ! Get device characteristics of the device.
    !
    DESC[0] = DIB$C_LENGTH;
    DESC[1] = DEVICE_CHAR;
    STATUS = $GETCHN(CHAN=.CHANNEL, PRIBUF=DESC);
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_GETCHN, 1, VCB[VCB_DEVICE], .STATUS);


    IF .MODE NEQ 1 OR .QUAL[QUAL_COMP]
    THEN
	BEGIN
	READ_HOMEBLOCK(.CHANNEL, DEVICE_CHAR, HOME_BLOCK);

	
	! Check the SETCOUNT and RVNs implied by the command against the
	! home block.
	!
	IF .RVN EQL 1
	THEN
	    BEGIN
	    MTL[MTL_STRUCLEV] = .HOME_BLOCK[HM2$B_STRUCLEV];
	    IF .HOME_BLOCK[HM2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		IF .SETCOUNT NEQ 1
		THEN
		    SIGNAL(BACKUP$_INCSETCNT);
		END
	    ELSE
		BEGIN
		IF .MODE AND NOT .QUAL[QUAL_COMP]
		THEN
		    BEGIN
		    IF .HOME_BLOCK[HM2$W_SETCOUNT] NEQ 0
		    THEN SIGNAL (BACKUP$_VOLINSET, 1, VCB[VCB_DEVICE]);
		    END
		ELSE
		    BEGIN
		    IF .HOME_BLOCK[HM2$W_SETCOUNT] EQL 0
		    AND .HOME_BLOCK[HM2$W_RVN] NEQ 0
		    THEN MTL[MTL_SEQ_DISK] = 1;
		    END;

		IF ACTUALCOUNT () LSS 2
		OR NOT .MTL[MTL_SEQ_DISK]
		THEN
		    BEGIN
		    IF
			BEGIN
			IF .SETCOUNT EQL 1
			THEN
			    .HOME_BLOCK[HM2$W_RVN] NEQ 0
			    AND .HOME_BLOCK[HM2$W_RVN] NEQ 1
			ELSE
			    .HOME_BLOCK[HM2$W_RVN] NEQ .RVN
			END
		    THEN
			SIGNAL(BACKUP$_INCRVN, 1, VCB[VCB_DEVICE]);


		    IF
			BEGIN
			IF .SETCOUNT EQL 1
			THEN
			    .HOME_BLOCK[HM2$W_SETCOUNT] NEQ 0
			    AND .HOME_BLOCK[HM2$W_SETCOUNT] NEQ 1
			ELSE
			    .HOME_BLOCK[HM2$W_SETCOUNT] NEQ .SETCOUNT
			END
		    THEN
			SIGNAL(BACKUP$_INCSETCNT);
		    END

		ELSE
		    BEGIN
		    IF .HOME_BLOCK[HM2$W_RVN] NEQ 0
		    THEN
			BEGIN
			RVN = .HOME_BLOCK[HM2$W_RVN];
			VCB[VCB_RVN] = .RVN;
			MTL[MTL_RVN_BASE] = .RVN;
			END
		    ELSE
			BEGIN
			VCB[VCB_NOTVOLSET] = 1;
			END;
		    END;

		CH$MOVE(
		    HM2$S_STRUCNAME,
		    HOME_BLOCK[HM2$T_STRUCNAME],
		    MTL[MTL_STRUCNAME]);
		END;
	    END
	ELSE
	    BEGIN
	    IF
		.HOME_BLOCK[HM2$W_RVN] NEQ .RVN OR
		CH$NEQ(
		    HM2$S_STRUCNAME, HOME_BLOCK[HM2$T_STRUCNAME],
		    HM2$S_STRUCNAME, MTL[MTL_STRUCNAME])
	    THEN
		SIGNAL(BACKUP$_INCRVN, 1, VCB[VCB_DEVICE]);
	    END;


	! Finish initializing the VCB.
	!
	CH$MOVE (HM2$S_VOLNAME, HOME_BLOCK[HM2$T_VOLNAME], VCB[VCB_VOLNAME]);
	IF .HOME_BLOCK[HM2$B_STRUCLEV] EQL 2
	THEN
	    BEGIN
	    VCB[VCB_ODS_2] = TRUE;
	    VCB[VCB_CLUSTER] = .HOME_BLOCK[HM2$W_CLUSTER];
	    VCB[VCB_HDR_OFFSET] = .HOME_BLOCK[HM2$W_CLUSTER] * 4 + .HOME_BLOCK[HM2$W_IBMAPSIZE];
	    VCB[VCB_MAXFILIDX] = .HOME_BLOCK[HM2$W_IBMAPSIZE] * 4096;
	    VCB[VCB_IMAP_LBN] = .HOME_BLOCK[HM2$L_IBMAPLBN];
	    STATUS = $QIOW(
		FUNC=IO$_READLBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=HEADER,
		P2=512,
		P3=.HOME_BLOCK[HM2$L_IBMAPLBN] + .HOME_BLOCK[HM2$W_IBMAPSIZE]);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF .STATUS THEN STATUS = VERIFY_HEADER(HEADER, INDEX_FILE_ID);
	    IF NOT .STATUS
	    THEN
		BEGIN
		STATUS = $QIOW(
		    FUNC=IO$_READLBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=HEADER,
		    P2=512,
		    P3=.HOME_BLOCK[HM2$L_ALTIDXLBN]);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF .STATUS
		THEN
		    BEGIN
		    STATUS = VERIFY_HEADER(HEADER, INDEX_FILE_ID);
		    IF NOT .STATUS THEN STATUS = SS$_BADFILEHDR;
		    END;
		END;
	    IF NOT .STATUS
	    THEN
		SIGNAL(BACKUP$_NOINDEXF, 1, VCB[VCB_DEVICE], .STATUS);
	    CREATE_WINDOW(HEADER, .RVN, VCB[VCB_INDEXF], 1, 0);

	    ! If we are going to write on this disk, also read in the
	    ! index file bitmap, and scan the storage map to build the
	    ! allocation table.
	    !
	    IF .MODE AND NOT .QUAL[QUAL_COMP]
	    THEN
		BEGIN
		LOCAL
		    BITS_SET,			! flag meaning ones seen
		    EXTENT_COUNT,		! count of extents found in bitmap
		    FIRST_SET,			! starting LBN of extent
		    LAST_SET;			! ending LBN of extent
		GLOBAL REGISTER
		    COUNT=		6,	! Retrieval pointer count
		    LBN=		7,	! Retrieval pointer LBN
		    MAP_POINTER=	8: REF BBLOCK; ! Pointer to scan map area
		BIND
		    BUFFER = HEADER : VECTOR;	! buffer to read bitmap

		VCB[VCB_OUTPUT] = TRUE;
		VCB[VCB_SAVESET] = TRUE;
		VCB[VCB_INIT_DONE] = TRUE;
		VCB[VCB_IMAP] = GET_VM(.VCB[VCB_MAXFILIDX]/8);
		STATUS = $QIOW(
		    FUNC=IO$_READLBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=.VCB[VCB_IMAP],
		    P2=.VCB[VCB_MAXFILIDX]/8,
		    P3=.VCB[VCB_IMAP_LBN]);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    SIGNAL(BACKUP$_READIMAP, 1, VCB[VCB_DEVICE], .STATUS);

		STATUS = $QIOW(
		    FUNC=IO$_READLBLK,
		    CHAN=.CHANNEL,
		    IOSB=IOSB,
		    P1=HEADER,
		    P2=512,
		    P3=.VCB[VCB_IMAP_LBN] + .VCB[VCB_MAXFILIDX]/4096 + 1);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF .STATUS
		THEN
		    BEGIN
		    STATUS = VERIFY_HEADER(HEADER, BITMAP_FILE_ID);
		    IF NOT .STATUS THEN STATUS = SS$_BADFILEHDR;
		    END;
		IF NOT .STATUS
		THEN
		    SIGNAL(BACKUP$_NOBITMAP, 1, VCB[VCB_DEVICE], .STATUS);

		MAP_POINTER = HEADER + .HEADER[FH2$B_MPOFFSET]*2;
		GET_MAP_POINTER ();
		COUNT = .COUNT - 1;
		IF .COUNT NEQ (((.DEVICE_CHAR[DIB$L_MAXBLOCK]+.VCB[VCB_CLUSTER]-1)
				 / .VCB[VCB_CLUSTER] + 4095) / 4096)
		THEN SIGNAL (BACKUP$_NOBITMAP, 1, VCB[VCB_DEVICE]);
		VCB[VCB_BITMAP_LBN] = .LBN + 1;

		EXTENT_COUNT = 0;
		BITS_SET = FALSE;
		INCR VBN FROM 0 TO .COUNT-1
		DO
		    BEGIN
		    STATUS = $QIOW(
			FUNC=IO$_READLBLK,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=BUFFER,
			P2=512,
			P3=.VCB[VCB_BITMAP_LBN] + .VBN);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			SIGNAL(BACKUP$_READBMAP, 1, VCB[VCB_DEVICE], .STATUS);
		    INCR J FROM 0 TO 127
		    DO
			BEGIN
			INCR K FROM 0 TO 31
			DO
			    BEGIN
			    IF NOT .BITS_SET
			    THEN
				BEGIN
				IF .BUFFER[.J] EQL 0 THEN EXITLOOP;
				IF .BITVECTOR [BUFFER[.J], .K]
				THEN
				    BEGIN
				    BITS_SET = TRUE;
				    FIRST_SET = (.VBN*4096 + .J*32 + .K) * .VCB[VCB_CLUSTER];
				    END;
				END
			    ELSE
				BEGIN
				IF .BUFFER[.J] EQL -1 THEN EXITLOOP;
				IF NOT .BITVECTOR [BUFFER[.J], .K]
				THEN
				    BEGIN
				    BITS_SET = FALSE;
				    LAST_SET = (.VBN*4096 + .J*32 + .K) * .VCB[VCB_CLUSTER];
				    FREE_BLOCKS (.LAST_SET-.FIRST_SET, .FIRST_SET);
				    EXTENT_COUNT = .EXTENT_COUNT + 1;
				    IF .EXTENT_COUNT GTR 100
				    THEN SIGNAL (BACKUP$_DISKFRAG, 1, VCB[VCB_DEVICE]);
				    END;
				END;
			    END;
			END;

		    CH$FILL (0, 512, BUFFER);
		    STATUS = $QIOW(
			FUNC=IO$_WRITELBLK,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=BUFFER,
			P2=512,
			P3=.VCB[VCB_BITMAP_LBN] + .VBN);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			SIGNAL(BACKUP$_WRITEERR+STS$K_SEVERE, 1, VCB[VCB_DEVICE], .STATUS);
		    END;
		IF .BITS_SET
		THEN FREE_BLOCKS (.COUNT*4096*.VCB[VCB_CLUSTER]-.FIRST_SET, .FIRST_SET);
		END;
	    END

	! Finish setup of ODS-1 disk. Save set processing is not supported.
	!
	ELSE
	    BEGIN
	    IF .MODE
	    THEN SIGNAL (BACKUP$_ODS2SAVE, 1, VCB[VCB_DEVICE]);
	    VCB[VCB_CLUSTER] = 1;
	    VCB[VCB_HDR_OFFSET] = 2 + .HOME_BLOCK[HM1$W_IBMAPSIZE];
	    VCB[VCB_MAXFILIDX] = .HOME_BLOCK[HM1$W_IBMAPSIZE] * 4096;
	    STATUS = $QIOW(
		FUNC=IO$_READLBLK,
		CHAN=.CHANNEL,
		IOSB=IOSB,
		P1=HEADER,
		P2=512,
		P3=ROT(.HOME_BLOCK[HM1$L_IBMAPLBN], 16) + .HOME_BLOCK[HM1$W_IBMAPSIZE]);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF .STATUS
	    THEN
		BEGIN
		STATUS = VERIFY_HEADER(HEADER, INDEX_FILE_ID);
		IF NOT .STATUS THEN STATUS = SS$_BADFILEHDR;
		END;
	    IF NOT .STATUS
	    THEN
		SIGNAL(BACKUP$_NOINDEXF, 1, VCB[VCB_DEVICE], .STATUS);
	    CREATE_WINDOW(HEADER, 1, VCB[VCB_INDEXF], 1, 0);
	    END;
	END;
    IF ACTUALCOUNT () GEQ 2
    AND .MTL[MTL_SEQ_DISK] THEN EXITLOOP;
    END;
END;

GLOBAL ROUTINE STA_DISMOUNT_OUTPUT (P_RVN, CONTINUE) : NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called at the completion of an image restore operation
!	and at the completion of each sequential disk output volume
!	to finish certain parts of the file structure:  index file bitmaps,
!	storage bitmaps, the quota file, and the VOLSET.SYS file.
!
! INPUT PARAMETERS:
!	P_RVN (optional): if present, specifies RVN to dismount
!			  if absent, dismount entire set
!	CONTINUE (optional): 1 indicating save set volume will be continued
!			     0 indicating last volume in set
!
! IMPLICIT INPUTS:
!	OUTPUT_MTL	- Pointer to MTL for output volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	RSA:		VECTOR[NAM$C_MAXRSS,BYTE],	! Resultant string area
	VCB:		REF BBLOCK,		! Pointer to VCB for volume
	SAVE_WCB,				! Saved window from MTL
	BUFFER:		BITVECTOR[4096],	! Block buffer
	FIB:		BBLOCK[10],		! FIB
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	STATUS,					! Status variable
	IOSB:		VECTOR[4,WORD];		! I/O status block
BUILTIN
	ACTUALCOUNT;


! Save the accessed file, if any, and do other initialization.
!
CURRENT_MTL = .OUTPUT_MTL;
SAVE_WCB = .CURRENT_MTL[MTL_WINDOW];
CURRENT_MTL[MTL_WINDOW] = 0;
RSA_DESC[1] = RSA;
FIB_DESC[0] = 10;
FIB_DESC[1] = FIB;


! Rebuild the quota file.
!
IF
    .QUAL[QUAL_OF11] AND NOT .QUAL[QUAL_VOLU] AND
    .DQF_QUOTA_FID[FID$W_NUM] NEQ 0
THEN
    BEGIN
    MAP
	BUFFER:		BBLOCK[512];		! Block buffer
    LOCAL
	FAT:		BBLOCK[FAT$C_LENGTH],	! Quota file attributes
	ATR_DESC:	BBLOCK[12];		! ACP attributes list
    GLOBAL REGISTER
	DQF_BUFFER=		11,
	DQF_RECORD=		10:	REF BBLOCK,
	DQF_VBN=		9,
	DQF_DEFAULT_PERM=	8,
	DQF_DEFAULT_OVER=	7;


    ! Access the quota file.
    !
    CURRENT_VCB = .CURRENT_MTL[MTL_VCB(0)];
    RSA_DESC[0] = NAM$C_MAXRSS;
    $FAO(
	$DESCRIPTOR('!AS[000000]QUOTA.SYS;1'),
	RSA_DESC,
	RSA_DESC,
	CURRENT_VCB[VCB_DEVICE]);
    FIB[FIB$L_ACCTL] = FIB$M_WRITE OR FIB$M_NOWRITE;
    FIB[FIB$W_FID_NUM] = .DQF_QUOTA_FID[FID$W_NUM];
    FIB[FIB$W_FID_SEQ] = .DQF_QUOTA_FID[FID$W_SEQ];
    FIB[FIB$W_FID_RVN] = .DQF_QUOTA_FID[FID$W_RVN];
    ATR_DESC[0,0,16,0] = ATR$S_RECATTR;
    ATR_DESC[2,0,16,0] = ATR$C_RECATTR;
    ATR_DESC[4,0,32,0] = FAT;
    ATR_DESC[8,0,32,0] = 0;
    STATUS = S$QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=STA_OUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC,
	P5=ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL(BACKUP$_OPENOUT + STS$K_ERROR, 1, RSA_DESC, .STATUS);
	RETURN;
	END;


    ! Scan the quota file to record the quotas in the quota table.
    !
    DQF_DEFAULT_PERM = 0;
    DQF_DEFAULT_OVER = 0;
    INCR VBN FROM 1 TO ROT(.FAT[FAT$L_EFBLK], 16) - 1 DO
	BEGIN

	! Read a block of the quota file.
	!
	STATUS = S$QIOW(
	    FUNC=IO$_READVBLK,
	    CHAN=STA_OUT_CHAN,
	    IOSB=IOSB,
	    P1=BUFFER,
	    P2=512,
	    P3=.VBN);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_READERR + STS$K_ERROR, 1, RSA_DESC, .STATUS)
	ELSE
	    INCRA P FROM BUFFER TO BUFFER+512-DQF$C_LENGTH BY DQF$C_LENGTH DO
		BEGIN
		MAP
		    P:		REF BBLOCK;	! Pointer to quota file entry
		LOCAL
		    Q:		REF BBLOCK;	! Pointer to quota table entry


		! Scan the quota entries in the block to extract the quotas.
		!
		IF .P[DQF$V_ACTIVE]
		THEN
		    BEGIN
		    IF .P[DQF$L_UIC] EQL 0
		    THEN
			BEGIN
			DQF_DEFAULT_PERM = .P[DQF$L_PERMQUOTA];
			DQF_DEFAULT_OVER = .P[DQF$L_OVERDRAFT];
			END;
		    Q = DQF_FIND_UIC(.P[DQF$L_UIC]);
		    Q[DQF_PERMQUOTA] = .P[DQF$L_PERMQUOTA];
		    Q[DQF_OVERDRAFT] = .P[DQF$L_OVERDRAFT];
		    END;
		END;
	END;


    ! Ensure that the allocated size of the quota file is sufficient for the
    ! records to be written into it.
    !
    IF ROT(.FAT[FAT$L_HIBLK], 16) LSSU .DQF_COUNT / (512/DQF$C_LENGTH)
    THEN
	BEGIN
	SIGNAL(BACKUP$_QUOTAFILE);
	S$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=STA_OUT_CHAN);
	RETURN;
	END;


    ! Rewrite the quota file.
    !
    CH$FILL(0, 512, BUFFER);
    DQF_BUFFER = DQF_RECORD = BUFFER;
    DQF_VBN = 1;
    IF .DQF_ROOT NEQ 0 THEN DQF_WRITE_ENTRY(.DQF_ROOT);


    ! Flush out the last block.
    !
    IF .DQF_RECORD NEQ .DQF_BUFFER
    THEN
	BEGIN
	STATUS = S$QIOW(
	    FUNC=IO$_WRITEVBLK,
	    CHAN=STA_OUT_CHAN,
	    IOSB=IOSB,
	    P1=.DQF_BUFFER,
	    P2=512,
	    P3=.DQF_VBN);
	DQF_VBN = .DQF_VBN + 1;
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
	END;


    ! Deaccess the quota file and rewrite the end of file pointer.
    !
    FAT[FAT$L_EFBLK] = ROT(.DQF_VBN, 16);
    STATUS = S$QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=STA_OUT_CHAN,
	IOSB=IOSB,
	P5=ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_CLOSEOUT + STS$K_ERROR, 1, RSA_DESC, .STATUS);
    END;


! Finish the VOLSET.SYS file.  It may be incorrect if any volume labels were
! changed by /NOINITIALIZE.
!
IF
    .CURRENT_MTL[MTL_SETCOUNT] GTRU 1 AND
    ACTUALCOUNT() EQL 0
THEN
    BEGIN
    LOCAL
	VBN,
	P;
    MAP
	BUFFER:		VECTOR[,BYTE];


    ! Access VOLSET.SYS file on RVN 1.
    !
    CURRENT_VCB = .CURRENT_MTL[MTL_VCB(0)];
    RSA_DESC[0] = NAM$C_MAXRSS;
    $FAO(
	$DESCRIPTOR('!AS[000000]VOLSET.SYS;1'),
	RSA_DESC,
	RSA_DESC,
	CURRENT_VCB[VCB_DEVICE]);
    FIB[FIB$L_ACCTL] = FIB$M_WRITE OR FIB$M_NOWRITE;
    FIB[FIB$W_FID_NUM] = FID$C_VOLSET;
    FIB[FIB$W_FID_SEQ] = FID$C_VOLSET;
    FIB[FIB$W_FID_RVN] = 1;
    STATUS = S$QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=STA_OUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_OPENOUT + STS$K_ERROR, 1, RSA_DESC, .STATUS);


    ! Initialize volume set name.
    !
    CH$COPY(VSL$S_NAME, COM_O_STRUCNAME, 0, 512, BUFFER);
    P = VSL$C_LENGTH;
    VBN = 1;


    INCR RVN FROM 1 TO .CURRENT_MTL[MTL_SETCOUNT] DO
	BEGIN

	! If block is full, write it and reinitialize.
	!
	IF .P GEQU 512
	THEN
	    BEGIN
	    STATUS = S$QIOW(
		FUNC=IO$_WRITEVBLK,
		CHAN=STA_OUT_CHAN,
		IOSB=IOSB,
		P1=BUFFER,
		P2=512,
		P3=.VBN);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);


	    ! Reinitialize buffer, pointer, counts.
	    !
	    CH$FILL(0, 512, BUFFER);
	    P = 0;
	    VBN = .VBN + 1;
	    END;


	! Initialize VSL entry.
	!
	CH$MOVE(
	    VSL$S_NAME,
	    BBLOCK[.CURRENT_MTL[MTL_VCB(.RVN-.CURRENT_MTL[MTL_RVN_BASE])], VCB_VOLNAME],
	    BBLOCK[BUFFER[.P], VSL$T_NAME]);


	P = .P + VSL$C_LENGTH;
	END;


    ! Write last block.
    !
    STATUS = S$QIOW(
	FUNC=IO$_WRITEVBLK,
	CHAN=STA_OUT_CHAN,
	IOSB=IOSB,
	P1=BUFFER,
	P2=512,
	P3=.VBN);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);


    ! Deaccess the file.
    !
    S$QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=STA_OUT_CHAN);
    END;


! If this is RVN 1 of a save set, it may be an externally initialized
! volume.  If it is being continued, we want to mark it as RVN 1 of a
! loosely coupled volume set.  Loop through the home blocks to do this.
!
CURRENT_VCB = .CURRENT_MTL[MTL_VCB(0)];
IF ACTUALCOUNT () GEQ 2
AND .P_RVN EQL 1
AND .CONTINUE
AND .CURRENT_VCB[VCB_NOTVOLSET]
THEN
    BEGIN
    MAP
	BUFFER:		BBLOCK;			! Block buffer


    ! Access the index file on RVN 1.
    !
    CURRENT_MTL[MTL_WINDOW] = .CURRENT_VCB[VCB_INDEXF];
    RSA_DESC[0] = NAM$C_MAXRSS;
    $FAO(
	$DESCRIPTOR('!AS[000000]INDEXF.SYS;1'),
	RSA_DESC,
	RSA_DESC,
	CURRENT_VCB[VCB_DEVICE]);
    CURRENT_WCB = .CURRENT_MTL[MTL_WINDOW];


! Loop, reading home blocks from the index file.
!

    INCR VBN FROM 2 TO .CURRENT_VCB[VCB_CLUSTER]*3
	DO
	BEGIN
	STATUS = R_W_VIRTUAL(
	    0,
	    0,
	    IO$_READVBLK,
	    IOSB,
	    0,
	    0,
	    BUFFER,
	    512,
	    .VBN);
	$WAITFR(EFN=0);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_READERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);


	IF NOT CHECKSUM2 (BUFFER, $BYTEOFFSET (HM2$W_CHECKSUM1))
	OR NOT CHECKSUM2 (BUFFER, $BYTEOFFSET (HM2$W_CHECKSUM2))
	THEN SIGNAL(BACKUP$_INVHOMBLK, 1, RSA_DESC);


! Write RVN and volume set name into home block and re-checksum.
!

	BUFFER[HM2$W_RVN] = 1;
	CH$MOVE (HM2$S_STRUCNAME, CURRENT_MTL[MTL_STRUCNAME], BUFFER[HM2$T_STRUCNAME]);
	CHECKSUM2 (BUFFER, $BYTEOFFSET (HM2$W_CHECKSUM1));
	CHECKSUM2 (BUFFER, $BYTEOFFSET (HM2$W_CHECKSUM2));

! Write back the updated home block.
!

	STATUS = R_W_VIRTUAL(
	    0,
	    0,
	    IO$_WRITEVBLK,
	    IOSB,
	    0,
	    0,
	    BUFFER,
	    512,
	    .VBN);
	$WAITFR(EFN=0);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
	END;


    CURRENT_MTL[MTL_WINDOW] = 0;
    END;


! Do each volume in the volume set.
!
INCR RVN
FROM (IF ACTUALCOUNT() EQL 0
    THEN .CURRENT_MTL[MTL_RVN_BASE]
    ELSE .P_RVN)
TO (IF ACTUALCOUNT() EQL 0
    THEN .CURRENT_MTL[MTL_RVN_BASE]+.CURRENT_MTL[MTL_SETCOUNT]-1
    ELSE .P_RVN)
DO
    BEGIN
    LOCAL
	VCB:		REF BBLOCK,		! Pointer to VCB
	CHANNEL,				! Channel assigned to volume
	OFFSET,					! Offset to bitmap block
	ACB:		REF BBLOCK;		! Pointer to ACB


    CURRENT_VCB = VCB = .CURRENT_MTL[MTL_VCB(.RVN-.CURRENT_MTL[MTL_RVN_BASE])];
    RSA_DESC[0] = NAM$C_MAXRSS;
    $FAO(
	$DESCRIPTOR('!AS[000000]INDEXF.SYS;1'),
	RSA_DESC,
	RSA_DESC,
	VCB[VCB_DEVICE]);
    CHANNEL = SWITCH_VOLUME(.RVN);


    ! Write the index file bitmap.
    !
    STATUS = $QIOW(
	FUNC=IO$_WRITELBLK,
	CHAN=.CHANNEL,
	IOSB=IOSB,
	P1=.VCB[VCB_IMAP],
	P2=.VCB[VCB_MAXFILIDX] / 8,
	P3=.VCB[VCB_IMAP_LBN]);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);


    ! Initialize for writing storage bitmap.
    !
    OFFSET = -1;
    ACB = .VCB[VCB_ACB_FLINK];
    RSA_DESC[0] = NAM$C_MAXRSS;
    $FAO(
	$DESCRIPTOR('!AS[000000]BITMAP.SYS;1'),
	RSA_DESC,
	RSA_DESC,
	VCB[VCB_DEVICE]);


    ! Loop for each ACB in the queue.
    !
    UNTIL REMQUE(.VCB[VCB_ACB_FLINK], ACB) DO
	BEGIN

	! Loop for each affected bit in the bitmap.  During the loop, N is the
	! offset within the storage bitmap of the affected bit.
	!
	INCRU N
	FROM .ACB[ACB_LBN] / .VCB[VCB_CLUSTER]
	TO .ACB[ACB_LBN] / .VCB[VCB_CLUSTER] + .ACB[ACB_COUNT] / .VCB[VCB_CLUSTER] - 1
	DO
	    BEGIN

	    ! If the current bit is not within the current bitmap block,
	    ! write out the completed block, if any, and initialize a new one.
	    !
	    IF .N<12,20> NEQ .OFFSET
	    THEN
		BEGIN
		IF .OFFSET NEQ -1
		THEN
		    BEGIN
		    STATUS = $QIOW(
			FUNC=IO$_WRITELBLK,
			CHAN=.CHANNEL,
			IOSB=IOSB,
			P1=BUFFER,
			P2=512,
			P3=.VCB[VCB_BITMAP_LBN] + .OFFSET);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS
		    THEN
			SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
		    END;
		CH$FILL(0, 512, BUFFER);
		OFFSET = .N<12,20>;
		END;


	    ! Set the appropriate bit to record the free cluster.
	    !
	    BUFFER[.N<0,12>] = TRUE;
	    END;


	! Free the ACB.
	!
	FREE_VM(ACB_S_ENTRY, .ACB);
	END;


    ! Flush the last block, if any.
    !
    IF .OFFSET NEQ -1
    THEN
	BEGIN
	STATUS = $QIOW(
	    FUNC=IO$_WRITELBLK,
	    CHAN=.CHANNEL,
	    IOSB=IOSB,
	    P1=BUFFER,
	    P2=512,
	    P3=.VCB[VCB_BITMAP_LBN] + .OFFSET);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    SIGNAL(BACKUP$_WRITEERR + STS$K_ERROR, 1, RSA_DESC, .STATUS);
	END;


    ! Free the index file bitmap buffers.
    !
    FREE_VM(.VCB[VCB_MAXFILIDX]/8, .VCB[VCB_IMAP]);
    VCB[VCB_IMAP] = 0;
    END;


! Restore the accessed file, if any.
!
CURRENT_MTL[MTL_WINDOW] = .SAVE_WCB;
END;

GLOBAL ROUTINE STA_DISMOUNT (P_RVN) : NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called after reading a volume of sequential
!	disk, to clean up the disk dependent data structures.
!
! INPUT PARAMETERS:
!	P_RVN (optional): if present, specifies RVN to dismount
!			  if absent, dismount entire set
!
! IMPLICIT INPUTS:
!	INPUT_MTL	- Pointer to MTL for input volume set.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	ACB		: REF BBLOCK;	! allocation control block


! Free the index file window.
!
CURRENT_VCB = .CURRENT_MTL[MTL_VCB(.P_RVN-.CURRENT_MTL[MTL_RVN_BASE])];
DELETE_WINDOW (.CURRENT_VCB[VCB_INDEXF]);
CURRENT_VCB[VCB_INDEXF] = 0;

! Free the index file bitmap buffers.
!
IF .CURRENT_VCB[VCB_IMAP] NEQ 0
THEN
    BEGIN
    FREE_VM(.CURRENT_VCB[VCB_MAXFILIDX]/8, .CURRENT_VCB[VCB_IMAP]);
    CURRENT_VCB[VCB_IMAP] = 0;
    END;

! Free any ACB's lying around.
!

WHILE NOT REMQUE (.CURRENT_VCB[VCB_ACB_FLINK], ACB)
DO
    BEGIN
    FREE_VM(ACB_S_ENTRY, .ACB);
    END;

! Clean up the VCB and MTL.
!

CURRENT_VCB[VCB_ODS_2] = 0;
CURRENT_VCB[VCB_INIT_DONE] = 0;
CURRENT_VCB[VCB_SAVESET] = 0;
CURRENT_VCB[VCB_NOTVOLSET] = 0;

DELETE_WINDOW (.CURRENT_MTL[MTL_WINDOW]);
CURRENT_MTL[MTL_WINDOW] = 0;

END;

GLOBAL ROUTINE READY_DISK (MOUNT_MODE) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets the disk ready as specified and returns the
!	address of the VCB.
!
! CALLING SEQUENCE:
!	READY_DISK (MOUNT_MODE)
!
! INPUT PARAMETERS:
!	MOUNT_MODE: mode disk is to be mounted in:
!			0 = read
!			1 = write, initialize
!			3 = write, no initialize
!
! IMPLICIT INPUTS:
!	RWSV_VOL_NUMBER: RVN of disk to mount
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	VCB of mounted disk
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	STATUS,				! system service status
	IO_STATUS	: VECTOR [4,WORD], ! I/O status block
	BUFFER		: BBLOCK [512],	! scratch I/O buffer
	VCB		: REF BBLOCK;	! VCB of volume being mounted

EXTERNAL ROUTINE
	MOUNT_MESSAGE,			! issue mount request and get reply
	FILE_ERROR;			! signal file related error


! Get the skeleton MTL and VCB's set up if they aren't yet.
!

IF .MOUNT_MODE THEN CURRENT_MTL = .OUTPUT_MTL ELSE CURRENT_MTL = .INPUT_MTL;
IF .CURRENT_MTL EQL 0
THEN STA_MOUNT (.MOUNT_MODE, 0);

! Find the next VCB to use and set it up.
!

IF .RWSV_VOL_NUMBER - .CURRENT_MTL[MTL_RVN_BASE] GEQU .CURRENT_MTL[MTL_SETCOUNT]
THEN CURRENT_MTL[MTL_RVN_BASE] = .RWSV_VOL_NUMBER;

VCB = .CURRENT_MTL[MTL_VCB(.RWSV_VOL_NUMBER-.CURRENT_MTL[MTL_RVN_BASE])];
SWITCH_VOLUME (.RWSV_VOL_NUMBER);

! Unless this is the first volume, start with operator assistance. Because
! not all disks can be spun down, there is the chance that a previous
! volume of the set is still in the drive.
!

IF .RWSV_SEG_NUMBER NEQ 0
THEN
    BEGIN
    IF .MOUNT_MODE
    THEN MOUNT_MESSAGE (BACKUP$_READYWRITE)
    ELSE MOUNT_MESSAGE (BACKUP$_READYREAD);
    END;

! Loop, checking for disk on line and write enabled if necessary,
! prompting to the user until satisfied.
!

WHILE TRUE
DO
    BEGIN
    STATUS = $QIOW (CHAN = .VCB[VCB_CHAN],
		    FUNC = IO$_PACKACK,
		    IOSB = IO_STATUS
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    AND .STATUS NEQ SS$_ILLIOFUNC
    AND (.STATUS NEQ SS$_NOPRIV
	 OR .RWSV_SEG_NUMBER GEQU .CURRENT_MTL[MTL_SETCOUNT])
    THEN FILE_ERROR (IF .MOUNT_MODE THEN BACKUP$_OPENOUT+STS$K_SEVERE
		     ELSE BACKUP$_OPENIN+STS$K_SEVERE, .VCB[VCB_FAB], .STATUS);

    STATUS = $QIOW (CHAN = .VCB[VCB_CHAN],
		    FUNC = IO$_READLBLK,
		    IOSB = IO_STATUS,
		    P1   = BUFFER,
		    P2   = 512,
		    P3   = 0
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF .STATUS EQL SS$_MEDOFL
    THEN
	BEGIN
	IF .MOUNT_MODE
	THEN MOUNT_MESSAGE (BACKUP$_READYWRITE)
	ELSE MOUNT_MESSAGE (BACKUP$_READYREAD);
	END

    ELSE IF NOT .STATUS
    THEN FILE_ERROR (IF .MOUNT_MODE THEN BACKUP$_OPENOUT+STS$K_SEVERE
		     ELSE BACKUP$_OPENIN+STS$K_SEVERE, .VCB[VCB_FAB], .STATUS)

    ELSE IF .MOUNT_MODE
    THEN
	BEGIN
	STATUS = $QIOW (CHAN = .VCB[VCB_CHAN],
			FUNC = IO$_WRITELBLK,
			IOSB = IO_STATUS,
			P1   = BUFFER,
			P2   = 512,
			P3   = 0
			);
	IF .STATUS THEN STATUS = .IO_STATUS[0];
	IF .STATUS EQL SS$_WRITLCK
	THEN MOUNT_MESSAGE (BACKUP$_WRITENABLE)

	ELSE IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .VCB[VCB_FAB], .STATUS)

	ELSE EXITLOOP;
	END

    ELSE EXITLOOP;
    END;

STA_MOUNT (.MOUNT_MODE, .RWSV_VOL_NUMBER);

.VCB
END;					! End of routine READY_DISK

! Entries in directory processing context vector
!

LITERAL
	CTX_CHANNEL	= 0,		! channel to use for directory
	CTX_COUNT	= 1,		! count of name string
	CTX_STRING	= 2,		! address of name string
	CTX_VERSION	= 3,		! version number
	CTX_VBN		= 4,		! VBN of directory block
	CTX_BUFFER	= 5,		! buffer address of current directory block
	CTX_ENTRY	= 6,		! address of directory record
	CTX_FILEVER	= 7,		! address of directory version entry
	CTX_FAB		= 8,		! FAB for operation
	CTX_EOF		= 9;		! size of directory file

ROUTINE NEXT_REC (ENTRY, DIR_CONTEXT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the next directory record and checks it for
!	consistency.
!
! CALLING SEQUENCE:
!	NEXT_REC (ENTRY, DIR_CONTEXT)
!
! INPUT PARAMETERS:
!	ENTRY: address of present record
!	DIR_CONTEXT: pointer to context block
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	address of next directory record
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	ENTRY		: REF BBLOCK,	! current directory record
	DIR_CONTEXT	: REF VECTOR;	! context block

LOCAL
	NEXT_ENTRY	: REF BBLOCK;	! new directory record

BIND
	CHANNEL		= DIR_CONTEXT[CTX_CHANNEL], 
	FND_COUNT	= DIR_CONTEXT[CTX_COUNT], 
	FND_STRING	= DIR_CONTEXT[CTX_STRING], 
	FND_VERSION	= DIR_CONTEXT[CTX_VERSION], 
	DIR_VBN		= DIR_CONTEXT[CTX_VBN],	
	DIR_BUFFER	= DIR_CONTEXT[CTX_BUFFER] : REF BBLOCK,
	DIR_ENTRY	= DIR_CONTEXT[CTX_ENTRY] : REF BBLOCK,
	DIR_VERSION	= DIR_CONTEXT[CTX_FILEVER] : REF BBLOCK,
	DIR_FAB		= DIR_CONTEXT[CTX_FAB],
	LAST_BLOCK	= DIR_CONTEXT[CTX_EOF]; 

EXTERNAL ROUTINE
	FILE_ERROR;			! signal file related error


! Find the next record by adding in the record size of the current entry.
! The count field of the next entry must be either 65535 or be contained
! within the block and even. Check the legality of the record type field.
!

IF .ENTRY[DIR$W_SIZE] LSSU DIR$C_LENGTH + DIR$C_VERSION
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADIRECTORY);
NEXT_ENTRY = .ENTRY + .ENTRY[DIR$W_SIZE] + 2;
IF .NEXT_ENTRY GEQA .DIR_BUFFER + 512
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADIRECTORY);

IF .NEXT_ENTRY[DIR$W_SIZE] NEQ 65535
THEN
    IF .NEXT_ENTRY<0,1>
    OR .(NEXT_ENTRY[DIR$W_SIZE])<0,1>
    OR .NEXT_ENTRY[DIR$V_TYPE] NEQ DIR$C_FID
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADIRECTORY);

RETURN .NEXT_ENTRY

END;					! end of routine NEXT_REC

ROUTINE DIR_SCAN (DIR_CONTEXT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine scans a directory, searching for the given entry.
!
!
! CALLING SEQUENCE:
!	DIR_SCAN (DIR_CONTEXT)
!
! INPUT PARAMETERS:
!	DIR_CONTEXT: context block for directory
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1 if entry found
!	0 if no match, in which case:
!		DIR_ENTRY = next record in collating sequence
!			  = 0 if whole directory scanned (name belongs off the end)
!		DIR_VERSION = next version in collating sequence if name & type matched
!			    = 0 if name or type did not match
!
! SIDE EFFECTS:
!	directory blocks read
!
!--

BEGIN

MAP
	DIR_CONTEXT	: REF VECTOR;	! name descriptor block arg

LABEL
	SEARCH_LOOP;			! body of search code

LOCAL
	STATUS,				! routine return status
	S_STATUS,			! system service status
	IO_STATUS	: VECTOR [4,WORD], ! I/O status block
	BLOCK,				! relative block number
	ENTRY		: REF BBLOCK,	! pointer to current directory record
	P		: REF BBLOCK;	! pointer to current directory version

BIND
	CHANNEL		= DIR_CONTEXT[CTX_CHANNEL], 
	FND_COUNT	= DIR_CONTEXT[CTX_COUNT], 
	FND_STRING	= DIR_CONTEXT[CTX_STRING], 
	FND_VERSION	= DIR_CONTEXT[CTX_VERSION], 
	DIR_VBN		= DIR_CONTEXT[CTX_VBN],	
	DIR_BUFFER	= DIR_CONTEXT[CTX_BUFFER] : REF BBLOCK,
	DIR_ENTRY	= DIR_CONTEXT[CTX_ENTRY] : REF BBLOCK,
	DIR_VERSION	= DIR_CONTEXT[CTX_FILEVER] : REF BBLOCK,
	DIR_FAB		= DIR_CONTEXT[CTX_FAB],
	LAST_BLOCK	= DIR_CONTEXT[CTX_EOF]; 

EXTERNAL ROUTINE
	FILE_ERROR;			! signal file related error


! Loop, scanning blocks of the directory until we hit EOF.
!

SEARCH_LOOP: BEGIN

STATUS = 0;
BLOCK = 1;
P = 0;
WHILE 1 DO
    BEGIN

    IF .BLOCK GTRU .LAST_BLOCK
    THEN LEAVE SEARCH_LOOP;
    S_STATUS = S$QIOW (CHAN = .CHANNEL,
		       IOSB = IO_STATUS,
		       FUNC = IO$_READVBLK,
		       P1   = .DIR_BUFFER,
		       P2   = 512,
		       P3   = .BLOCK
		       );
    IF .S_STATUS THEN S_STATUS = .IO_STATUS[0];
    IF NOT .S_STATUS THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, .S_STATUS);
    ENTRY = .DIR_BUFFER;

! Loop, scanning the records of the directory. A record size of -1 indicates
! the end of the block. We attempt to match name and type against the entry,
! under control of the various name control flags.
!

    UNTIL .ENTRY[DIR$W_SIZE] EQL 65535
    DO
	BEGIN
	IF .ENTRY[DIR$W_SIZE] + .ENTRY + 2 GEQA .DIR_BUFFER + 512
	THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADIRECTORY);

	P = .ENTRY + DIR$C_LENGTH + .ENTRY[DIR$B_NAMECOUNT] + 1 AND NOT 1;
	IF .P GEQA .DIR_BUFFER + 512 - DIR$C_VERSION
	THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADIRECTORY);

	IF (CASE CH$COMPARE (.ENTRY[DIR$B_NAMECOUNT],
			      ENTRY[DIR$T_NAME],
			     .FND_COUNT,
			     .FND_STRING
			     )
	    FROM -1 TO 1 OF
		SET

		[-1]:	0;	! no match - dir entry precedes name

		[0]:	1;	! match

		[1]:	BEGIN	! no match - dir entry is past name
			P = 0;
			LEAVE SEARCH_LOOP;
			END;
		TES)

! If the name and type match on a record, loop to process the versions of
! the record.
!

	THEN
	    BEGIN
	    UNTIL .P GEQA .ENTRY + .ENTRY[DIR$W_SIZE] + 2
	    DO
		BEGIN
		IF
		    BEGIN

		    IF (.FND_VERSION EQL 0
			 AND NOT .ENTRY[DIR$V_PREVREC]
		       )
		    THEN 1

		    ELSE IF .FND_VERSION GTR .P[DIR$W_VERSION]
		    THEN LEAVE SEARCH_LOOP

		    ELSE .FND_VERSION EQL .P[DIR$W_VERSION]

		    END

		THEN
		    BEGIN
		    STATUS = 1;
		    LEAVE SEARCH_LOOP;
		    END;

		P = .P + DIR$C_VERSION;
		END;			! end of record scanning loop

! We have gone through a directory record without finding a match.
! If no continuation records are present, we can quit now.
!

	    IF NOT .ENTRY[DIR$V_NEXTREC]
	    THEN LEAVE SEARCH_LOOP;

	    END;			! end of record processing conditional

	ENTRY = NEXT_REC (.ENTRY, .DIR_CONTEXT); ! get next record
	END;				! end of block scanning loop

    BLOCK = .BLOCK + 1;
    P = 0;
    END;				! end of block loop

END;					! end of block SEARCH_LOOP

! Return the record pointers in global storage and return status.
!

DIR_VBN = .BLOCK;
DIR_ENTRY = .ENTRY;
DIR_VERSION = .P;

RETURN .STATUS;

END;					! end of routine DIR_SCAN

GLOBAL ROUTINE STA_ENTER (FAB) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine enters the given file name in the specified directory.
!
! CALLING SEQUENCE:
!	STA_ENTER (FAB)
!
! INPUT PARAMETERS:
!	FAB: address of FAB for file to be entered
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	DIR_RECORD: record number of new directory entry
!	DIR_BUFFER: buffer address of current directory block
!	DIR_ENTRY: address of directory record
!	DIR_VERSION: address of directory version entry
!	DIR_END: end of directory data
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	directory altered
!
!--

BEGIN
MAP
	FAB		: REF BBLOCK;	! FAB argument

LOCAL
	STATUS,				! result of directory search
	NAM		: REF BBLOCK,	! address of name block
	IO_STATUS	: VECTOR [4,WORD], ! I/O status block
	BUFFER		: BBLOCK [512],	! I/O buffer to read directory
	FIB		: BBLOCK [FIB$C_ACCDATA], ! FIB to access directory
	FIB_DESC	: VECTOR [2],	! descriptor for above
	RECATTR		: BBLOCK [FAT$C_LENGTH], ! record attributes buffer
	FILECHAR	: BBLOCK [4],	! file characteristics longword
	ATT_CONTROL	: BBLOCK [20],	! attribute control list
	DIR_CONTEXT	: VECTOR [10],	! directory context block
	DIR_END		: REF BBLOCK,	! end of directory data
	NAME_LENGTH,			! length of file name, rounded even
	NEW_SIZE,			! size of new directory entry
	VERSIONS,			! version limit for entry
	FAO_DESC	: VECTOR [2];	! string descriptor for FAO

BIND
	ATT_CONTROL0	= ATT_CONTROL : BBLOCK,
	ATT_CONTROL1	= ATT_CONTROL+8 : BBLOCK,
	ATT_CONTROL2	= ATT_CONTROL+16 : BBLOCK;

BIND
	CHANNEL		= DIR_CONTEXT[CTX_CHANNEL], 
	FND_COUNT	= DIR_CONTEXT[CTX_COUNT], 
	FND_STRING	= DIR_CONTEXT[CTX_STRING], 
	FND_VERSION	= DIR_CONTEXT[CTX_VERSION], 
	DIR_VBN		= DIR_CONTEXT[CTX_VBN],	
	DIR_BUFFER	= DIR_CONTEXT[CTX_BUFFER] : REF BBLOCK,
	DIR_ENTRY	= DIR_CONTEXT[CTX_ENTRY] : REF BBLOCK,
	DIR_VERSION	= DIR_CONTEXT[CTX_FILEVER] : REF BBLOCK,
	DIR_FAB		= DIR_CONTEXT[CTX_FAB],
	LAST_BLOCK	= DIR_CONTEXT[CTX_EOF]; 

EXTERNAL ROUTINE
	FILE_ERROR,			! signal file related error
	LIB$CVT_DTB:	ADDRESSING_MODE(GENERAL),
					! convert decimal to binary
	INIT_NAMEBLOCK;			! initialize extended name block fields



! Access the directory.
!

DIR_FAB = .FAB;
DIR_BUFFER = BUFFER;
CHANNEL = .FAB[FAB$L_STV];
NAM = .FAB[FAB$L_NAM];

FIB_DESC[0] = FIB$C_ACCDATA;
FIB_DESC[1] = FIB;
FIB[FIB$L_ACCTL] = 0;
FIB[FIB$W_FID_NUM] = .NAM[NAM$W_DID_NUM];
FIB[FIB$W_FID_SEQ] = .NAM[NAM$W_DID_SEQ];
FIB[FIB$W_FID_RVN] = .NAM[NAM$W_DID_RVN];

ATT_CONTROL0[ATR$W_SIZE] = ATR$S_RECATTR;
ATT_CONTROL0[ATR$W_TYPE] = ATR$C_RECATTR;
ATT_CONTROL0[ATR$L_ADDR] = RECATTR;
ATT_CONTROL1[ATR$W_SIZE] = ATR$S_UCHAR;
ATT_CONTROL1[ATR$W_TYPE] = ATR$C_UCHAR;
ATT_CONTROL1[ATR$L_ADDR] = FILECHAR;
ATT_CONTROL2[0,0,32,0] = 0;

STATUS = S$QIOW (CHAN = .CHANNEL,
		 IOSB = IO_STATUS,
		 FUNC = IO$_ACCESS OR IO$M_ACCESS,
		 P1   = FIB_DESC,
		 P5   = ATT_CONTROL
		 );
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, .STATUS);

LAST_BLOCK = ROT (.RECATTR[FAT$L_EFBLK], 16);
IF .RECATTR[FAT$W_FFBYTE] EQL 0
AND .LAST_BLOCK NEQ 0
THEN LAST_BLOCK = .LAST_BLOCK - 1;

IF NOT .FILECHAR[FCH$V_DIRECTORY]
OR .RECATTR[FAT$B_RTYPE] NEQ FAT$C_VARIABLE
OR .RECATTR[FAT$B_RATTRIB] NEQ FAT$M_NOSPAN
OR .LAST_BLOCK EQL 0
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADIRECTORY);

! Search the directory for the indicated name. If the search succeeds, we
! have a duplicate entry. If the search failed, make a new entry.
!

FND_STRING = .NAM[NAM$L_NAME];
FND_COUNT = .NAM[NAM$L_VER] - .NAM[NAM$L_NAME];
IF .NAM[NAM$B_VER] LSSU 2
THEN FND_VERSION = 0
ELSE IF NOT LIB$CVT_DTB (.NAM[NAM$B_VER]-1, .NAM[NAM$L_VER]+1, FND_VERSION)
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADFILEVER);
IF .FND_VERSION GTRU 32767
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADFILEVER);

STATUS =  DIR_SCAN (DIR_CONTEXT);
IF .STATUS
AND .FND_VERSION NEQ 0
THEN
    FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_DUPFILENAME);

! Set up the position for the insert. Scan to the end of the
! records in the block.
!

NAME_LENGTH = .FND_COUNT + 1 AND NOT 1;
DIR_END = .DIR_ENTRY;

UNTIL .DIR_END[DIR$W_SIZE] EQL 65535
DO DIR_END = NEXT_REC (.DIR_END, DIR_CONTEXT);
DIR_END = .DIR_END + 2;

! If there was not a name match, we are constructing a whole new record.
! Compute the record size and see if there is enough space. If not, extend
! the directory. Then shuffle down the rest of the records and build the
! new entry.
!

IF .DIR_VERSION EQL 0
THEN
    BEGIN
    IF .FND_VERSION EQL 0
    THEN FND_VERSION = .FND_VERSION + 1;

    NEW_SIZE = DIR$C_LENGTH + DIR$C_VERSION + .NAME_LENGTH;
    IF .NEW_SIZE GTRU .DIR_BUFFER + 512 - .DIR_END
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_DIRFULL);

    CH$MOVE (.DIR_END-.DIR_ENTRY, .DIR_ENTRY, .DIR_ENTRY+.NEW_SIZE);

    DIR_ENTRY[DIR$W_SIZE] = .NEW_SIZE - 2;
    VERSIONS = (512+DIR$C_VERSION-2-.NEW_SIZE) / DIR$C_VERSION;
    IF .RECATTR[FAT$W_VERSIONS] NEQ 0
    THEN VERSIONS = .RECATTR[FAT$W_VERSIONS];
    DIR_ENTRY[DIR$W_VERLIMIT] = .VERSIONS;

    DIR_ENTRY[DIR$B_FLAGS] = DIR$C_FID;
    DIR_ENTRY[DIR$B_NAMECOUNT] = .FND_COUNT;
    CH$COPY (.FND_COUNT, .FND_STRING,
		0, .NAME_LENGTH, DIR_ENTRY[DIR$T_NAME]);

    DIR_VERSION = .DIR_ENTRY + .NEW_SIZE - DIR$C_VERSION;
    END


! Otherwise we are adding a new version to an existing entry. Then
! shuffle the rest of the directory down.
!

ELSE
    BEGIN
    IF  .FND_VERSION EQL 0
    THEN FND_VERSION = .DIR_VERSION[DIR$W_VERSION] + 1;

    IF DIR$C_VERSION GTRU .DIR_BUFFER + 512 - .DIR_END
    THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_DIRFULL);
    DIR_ENTRY[DIR$W_SIZE] = .DIR_ENTRY[DIR$W_SIZE] + DIR$C_VERSION;

    CH$MOVE (.DIR_END-.DIR_VERSION, .DIR_VERSION, .DIR_VERSION+DIR$C_VERSION);
    END;

! Now insert the version number and file ID into the version slot.
!

IF .FND_VERSION GTRU 32767
THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, SS$_BADFILEVER);
DIR_VERSION[DIR$W_VERSION] = .FND_VERSION;
DIR_VERSION[DIR$W_FID_NUM] = .NAM[NAM$W_FID_NUM];
DIR_VERSION[DIR$W_FID_SEQ] = .NAM[NAM$W_FID_SEQ];
DIR_VERSION[DIR$B_FID_NMX] = .NAM[NAM$B_FID_NMX];
DIR_VERSION[DIR$B_FID_RVN] = 0;

STATUS = S$QIOW (CHAN = .CHANNEL,
		 IOSB = IO_STATUS,
		 FUNC = IO$_WRITEVBLK,
		 P1   = .DIR_BUFFER,
		 P2   = 512,
		 P3   = .DIR_VBN
		 );
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, .STATUS);

STATUS = S$QIOW (CHAN = .CHANNEL,
		 IOSB = IO_STATUS,
		 FUNC = IO$_DEACCESS
		 );
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENOUT+STS$K_SEVERE, .DIR_FAB, .STATUS);

! Finally build the resultant string with version number.
!

IF .NAM[NAM$B_RSL] EQL 0
THEN
    BEGIN
    CH$MOVE (.NAM[NAM$B_ESL], .NAM[NAM$L_ESA], .NAM[NAM$L_RSA]);
    FAO_DESC[1] = .NAM[NAM$L_VER] + 1 + .NAM[NAM$L_RSA] - .NAM[NAM$L_ESA];
    FAO_DESC[0] = .NAM[NAM$B_RSS] - (.FAO_DESC[1] - .NAM[NAM$L_RSA]);
    IF .FAO_DESC[0] GTR 0
    THEN
	BEGIN
	$FAO ($DESCRIPTOR ('!UW'),
	      FAO_DESC[0],
	      FAO_DESC[0],
	      .FND_VERSION
	      );
	END
    ELSE
	FAO_DESC[0] = 0;
    NAM[NAM$B_RSL] = .FAO_DESC[1] + .FAO_DESC[0] - .NAM[NAM$L_RSA];
    INIT_NAMEBLOCK (.NAM);
    END;

END;					! end of routine STA_ENTER

GLOBAL ROUTINE STA_EXTEND (P_COUNT, RET_COUNT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine attempts to allocate the specified number of
!	blocks to the currently open file and appends them to the file.
!	When asked to return blocks, allocated blocks listed in the
!	window are recorded in the file header.
!
! CALLING SEQUENCE:
!	STA_EXTEND (P_COUNT, RET_COUNT)
!
! INPUT PARAMETERS:
!	P_COUNT: if positive, the number of new blocks to allocate
!		 if negative, the number of blocks to return; also
!		 the signal to build header map pointers.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL: MTL of file in process
!
! OUTPUT PARAMETERS:
!	RET_COUNT: address into which to return count of blocks allocated
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	success or failure status
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	STATUS,				! general status value
	BLOCK_COUNT,			! rounded form of requested count
	NEW_COUNT,			! count of new blocks allocated
	NEW_LBN,			! LBN of same
	MTL		: REF BBLOCK,	! address of MTL for volume set
	W		: REF BBLOCK,	! pointer to current window segment
	LAST_W		: REF BBLOCK,	! pointer to previous window
	WP		: REF BBLOCK;	! pointer to current window pointer


!  Round the block count and do setup.
!

BLOCK_COUNT = (.P_COUNT + .CURRENT_VCB[VCB_CLUSTER] - 1)
		/ .CURRENT_VCB[VCB_CLUSTER] * .CURRENT_VCB[VCB_CLUSTER];

.RET_COUNT = 0;
MTL = .CURRENT_MTL;
IF .MTL[MTL_WINDOW] EQL 0 THEN RETURN SS$_FILNOTACC;

! Attempt allocation if requested. Record the new blocks in the
! window.
!

IF .BLOCK_COUNT GTR 0
THEN
    BEGIN
    IF NOT STA_ALLOC_BEST (.BLOCK_COUNT, NEW_COUNT, NEW_LBN)
    THEN RETURN SS$_DEVICEFULL;
    ADD_WINDOW_MAP (.MTL[MTL_WINDOW], .MTL[MTL_FID_RVN], .NEW_COUNT, .NEW_LBN);
    .RET_COUNT = .NEW_COUNT;
    END

! Otherwise this is a request to truncate allocated blocks and finish
! off the file header. First truncate the requested number of blocks
! out of the window.
!

ELSE
    BEGIN
    BLOCK_COUNT = -.BLOCK_COUNT;
    UNTIL .BLOCK_COUNT LEQ 0
    DO
	BEGIN
	LAST_W = 0;
	W = .MTL[MTL_WINDOW];
	UNTIL .W[WCB_LINK] EQL 0
	DO
	    BEGIN
	    LAST_W = .W;
	    W = .W[WCB_LINK];
	    END;
	IF .W[WCB_SIZE] EQL 0 THEN EXITLOOP;

	WP = .W + WCB_S_HEADER + (.W[WCB_SIZE]-1) * WCB_S_ENTRY;
	IF .WP[WCB_COUNT] GTR .BLOCK_COUNT
	THEN
	    BEGIN
	    WP[WCB_COUNT] = .WP[WCB_COUNT] - .BLOCK_COUNT;
	    FREE_BLOCKS (.BLOCK_COUNT, .WP[WCB_LBN] + .WP[WCB_COUNT]);
	    .RET_COUNT = ..RET_COUNT - .BLOCK_COUNT;
	    EXITLOOP;
	    END

	ELSE
	    BEGIN
	    FREE_BLOCKS (.WP[WCB_COUNT], .WP[WCB_LBN]);
	    .RET_COUNT = ..RET_COUNT - .W[WCB_COUNT];
	    BLOCK_COUNT = .BLOCK_COUNT - .WP[WCB_COUNT];
	    W[WCB_SIZE] = .W[WCB_SIZE] - 1;
	    IF .W[WCB_SIZE] EQL 0
	    AND .LAST_W NEQ 0
	    AND .W[WCB_RVN] EQL .LAST_W[WCB_RVN]
	    THEN
		BEGIN
		DELETE_WINDOW (.W);
		LAST_W[WCB_LINK] = 0;
		END;
	    END;
	END;

! Now build map pointers in the file header using the pointers in the
! window.
!

    W = .MTL[MTL_WINDOW];
    UNTIL .W EQL 0
    OR .W[WCB_RVN] EQL .CURRENT_VCB[VCB_RVN]
    DO W = .W[WCB_LINK];

    UNTIL .W EQL 0
    DO
	BEGIN
	WP = .W + WCB_S_HEADER;
	DECR J FROM .W[WCB_SIZE] TO 1
	DO
	    BEGIN
	    STATUS = (IF .CURRENT_VCB[VCB_ODS_2]
		      THEN MAKE_POINTER ELSE MAKE_POINTER1)
		     (.MTL[MTL_HEADER], .WP[WCB_COUNT], .WP[WCB_LBN]);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    WP = .WP + WCB_S_ENTRY;
	    END;
	W = .W[WCB_LINK];
	END;
    END;

TRUE
END;					! End of routine STA_EXTEND

ROUTINE STA_RDWRVBLK(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes IO$_READVBLK and IO$_WRITEVBLK in the
!	standalone environment.
!
! INPUT PARAMETERS:
!	As for $QIO(W) system service.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	AP;


! Find the accessed file.  If none, error.
!
CURRENT_WCB = .CURRENT_MTL[MTL_WINDOW];
IF .CURRENT_WCB EQL 0 THEN RETURN SS$_FILNOTACC;


! Do the I/O.
!
CALLG(.AP, R_W_VIRTUAL)
END;

ROUTINE STA_ACCESS(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes IO$_ACCESS in the standalone environment.
!
! INPUT PARAMETERS:
!	As for $QIO(W) system service.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FUNC:		BBLOCK,		! I/O function code
	P1:		REF BBLOCK;	! Descriptor for FIB
LOCAL
	LOCAL_HEADER:	BBLOCK[512],	! Local header buffer
	HEADER:		REF BBLOCK,	! Pointer to header
	STATUS,
	VBN;				! Starting VBN of file




! If necessary, access the specified file.  In the standalone ACP, the only
! FIB field used is FIB$W_FID.
!
IF .P1 NEQ 0
THEN
    BEGIN
    LOCAL
	FIB:	REF BBLOCK;


    FIB = .P1[DSC$A_POINTER];


    IF .FUNC[IO$V_ACCESS]
    THEN
	BEGIN
	!
	! Access specified:  check for file already accessed, save the file
	! ID, set up to use the MTL header buffer, read the header, and create
	! the window.
	!
	IF .CURRENT_MTL[MTL_WINDOW] NEQ 0 THEN RETURN SS$_FILALRACC;
	CURRENT_MTL[MTL_FID_NUM] = .FIB[FIB$W_FID_NUM];
	CURRENT_MTL[MTL_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
	CURRENT_MTL[MTL_FID_RVNW] = .FIB[FIB$W_FID_RVN];
	HEADER = .CURRENT_MTL[MTL_HEADER];
	STATUS = READ_HEADER(FIB[FIB$W_FID_NUM], .HEADER);
	IF NOT .STATUS THEN RETURN .STATUS;
	VBN = 1;
	IF .P1[DSC$W_LENGTH] GEQU FIB$C_EXTDATA
	AND .FIB[FIB$L_EXVBN] NEQ 0
	THEN VBN = .FIB[FIB$L_EXVBN];
	STATUS = CREATE_WINDOW(.HEADER, .FIB[FIB$B_FID_RVN],
		 CURRENT_MTL[MTL_WINDOW], .VBN, .FIB[FIB$B_WSIZE]);
	IF NOT .STATUS THEN RETURN .STATUS;
	END
    ELSE
	BEGIN
	!
	! No access specified:  allow file already accessed, use the local
	! header buffer to avoid destroying context, and read the header.
	!
	HEADER = LOCAL_HEADER;
	STATUS = READ_HEADER(FIB[FIB$W_FID_NUM], .HEADER);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;
    END
ELSE
    BEGIN
    IF .CURRENT_MTL[MTL_WINDOW] EQL 0 THEN RETURN SS$_BADPARAM;
    HEADER = .CURRENT_MTL[MTL_HEADER];
    END;


! If specified, read attributes.
!
IF .P5 NEQ 0
THEN
    BEGIN
    STATUS = READ_ATTRIBUTES(.HEADER, .P5);
    IF NOT .STATUS THEN RETURN .STATUS;
    END;


! Completed normally.
!
SS$_NORMAL
END;

ROUTINE CREATE_CLEANUP(QUEUE_HEADERS,CREATE_STATUS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the extent list produced during an IO$_CREATE
!	and frees the disk extents if the create failed.  In any case, the
!	extent list, the create list, and the window are freed.
!
! INPUT PARAMETERS:
!	QUEUE_HEADERS	- Pointer to queue headers for extent list, create
!			  list, and used FID list.
!	CREATE_STATUS	- Create status.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	The create status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QUEUE_HEADERS:	REF VECTOR;	! Pointer to queue headers
LOCAL
	P:		REF BBLOCK;	! Pointer to list entry


! Free the extent list.
!
UNTIL REMQUE(.QUEUE_HEADERS[0], P) DO
    BEGIN

    ! If the create failed, release the allocated disk blocks.
    !
    IF NOT .CREATE_STATUS AND .P[EXT_COUNT] NEQ 0
    THEN
	BEGIN
	CURRENT_VCB = .P[EXT_VCB];
	FREE_BLOCKS(.P[EXT_COUNT], .P[EXT_LBN]);
	END;


    ! Deallocate the extent list entry.
    !
    FREE_VM(EXT_S_ENTRY, .P);
    END;	


! Free the create list.
!
UNTIL REMQUE(.QUEUE_HEADERS[2], P) DO
    BEGIN
    LOCAL
	Q:		REF BBLOCK;	! Pointer to FID block


    ! Free the FID blocks.
    !
    UNTIL REMQUE(.P[CRT_FID_FQHDR], Q) DO FREE_VM(CRT_S_FID, .Q);


    ! Deallocate the create list entry.
    !
    FREE_VM(CRT_S_BLOCKS, .P);
    END;	


! Free the used file ID list.
!
UNTIL REMQUE(.QUEUE_HEADERS[4], P) DO
    BEGIN
    LOCAL
	HEADER:		BBLOCK[512];	! File header buffer


    ! If the create failed, write a deleted file header.
    !
    IF NOT .CREATE_STATUS
    THEN
	BEGIN
	CREATE_DELHDR(P[CRT_FID], HEADER);
	WRITE_HEADER(P[CRT_FID], HEADER);
	END;


    ! Deallocate the create list entry.
    !
    FREE_VM(CRT_S_FID, .P);
    END;	


! Release the window if one exists.
!
IF NOT .CREATE_STATUS AND .CURRENT_MTL[MTL_WINDOW] NEQ 0
THEN
    BEGIN
    DELETE_WINDOW(.CURRENT_MTL[MTL_WINDOW]);
    CURRENT_MTL[MTL_WINDOW] = 0;
    END;


! Return the original status.
!
.CREATE_STATUS
END;

ROUTINE CREATE_EXTHDR(OLD_HDR,OLD_FILE_ID,NEW_HDR,NEW_FILE_ID)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine creates an extension header.
!
! INPUT PARAMETERS:
!	OLD_HDR		- Pointer to current file header.
!	OLD_FILE_ID	- File ID of current file header.
!	NEW_HDR		- Pointer to buffer where extension header is built.
!	NEW_FILE_ID	- File ID of extension file header.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for current volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	OLD_HDR:	REF BBLOCK,	! Pointer to file header
	OLD_FILE_ID:	REF BBLOCK,	! Pointer to file ID
	NEW_HDR:	REF BBLOCK,	! Pointer to file header
	NEW_FILE_ID:	REF BBLOCK;	! Pointer to file ID


IF .OLD_HDR[FH2$B_STRUCLEV] EQL 2
THEN
    BEGIN

    ! Make sure the segment number will not overflow.
    !
    IF .OLD_HDR[FH2$W_SEG_NUM] GEQU 65535
    THEN
	RETURN SS$_HEADERFULL;


    ! Put the extension linkage in the previous header.
    !
    OLD_HDR[FH2$W_EX_FIDNUM] = .NEW_FILE_ID[FID$W_NUM];
    OLD_HDR[FH2$W_EX_FIDSEQ] = .NEW_FILE_ID[FID$W_SEQ];
    OLD_HDR[FH2$W_EX_FIDRVN] = .NEW_FILE_ID[FID$W_RVN];
    IF .OLD_FILE_ID[FID$B_RVN] EQL .NEW_FILE_ID[FID$B_RVN]
	THEN OLD_HDR[FH2$B_EX_FIDRVN] = 0;
    END
ELSE
    BEGIN
    LOCAL
	MAP_AREA:	REF BBLOCK;	! Pointer to map area


    MAP_AREA = .OLD_HDR + .OLD_HDR[FH1$B_MPOFFSET]*2;


    ! Make sure the segment number will not overflow.
    !
    IF .MAP_AREA[FM1$B_EX_SEGNUM] GEQU 255
    THEN
	RETURN SS$_HEADERFULL;


    ! Put the extension linkage in the previous header.
    !
    MAP_AREA[FM1$W_EX_FILNUM] = .NEW_FILE_ID[FID$W_NUM];
    MAP_AREA[FM1$W_EX_FILSEQ] = .NEW_FILE_ID[FID$W_SEQ];
    END;


! If the old header and the new header occupy the same buffer, the old header
! is an extension header.  Otherwise, it is the primary header.  Write the old
! header if necessary.
!
IF .OLD_HDR EQL .NEW_HDR
THEN
    BEGIN
    LOCAL
	STATUS;				! Status variable

    IF
	NOT .QUAL[QUAL_VOLU] OR
	.QUAL[QUAL_VOLU_VALUE] EQL .OLD_FILE_ID[FID$B_RVN]
    THEN
	BEGIN
	STATUS = WRITE_HEADER(.OLD_FILE_ID, .OLD_HDR);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;
    END
ELSE
    CH$MOVE(512, .OLD_HDR, .NEW_HDR);


IF .NEW_HDR[FH2$B_STRUCLEV] EQL 2
THEN
    BEGIN

    ! Place the file ID in the new header.
    !
    NEW_HDR[FH2$W_FID_NUM] = .NEW_FILE_ID[FID$W_NUM];
    NEW_HDR[FH2$W_FID_SEQ] = .NEW_FILE_ID[FID$W_SEQ];
    NEW_HDR[FH2$B_FID_RVN] = 0;
    NEW_HDR[FH2$B_FID_NMX] = .NEW_FILE_ID[FID$B_NMX];


    ! Set the extension header back link to point to the primary header.
    !
    NEW_HDR[FH2$W_BK_FIDNUM] = .CURRENT_MTL[MTL_FID_NUM];
    NEW_HDR[FH2$W_BK_FIDSEQ] = .CURRENT_MTL[MTL_FID_SEQ];
    NEW_HDR[FH2$W_BK_FIDRVN] = .CURRENT_MTL[MTL_FID_RVNW];
    IF .NEW_HDR[FH2$B_BK_FIDRVN] EQL .NEW_FILE_ID[FID$B_RVN]
	THEN NEW_HDR[FH2$B_BK_FIDRVN] = 0;


    ! Finish initializing the new header.
    !
    NEW_HDR[FH2$W_SEG_NUM] = .NEW_HDR[FH2$W_SEG_NUM] + 1;
    NEW_HDR[FH2$W_EX_FIDNUM] = 0;
    NEW_HDR[FH2$W_EX_FIDSEQ] = 0;
    NEW_HDR[FH2$W_EX_FIDRVN] = 0;
    NEW_HDR[FH2$B_MAP_INUSE] = 0;
    NEW_HDR[FH2$V_CONTIG] = FALSE;
    NEW_HDR[FH2$V_LOCKED] = FALSE;
    BBLOCK[NEW_HDR[FH2$W_RECATTR], FAT$L_HIBLK] = 0;
    BBLOCK[NEW_HDR[FH2$W_RECATTR], FAT$L_EFBLK] = 0;
    BBLOCK[NEW_HDR[FH2$W_RECATTR], FAT$W_FFBYTE] = 0;


    ! Truncate the ident area to provide more space for the map area.
    ! Clear the map area.
    !
    NEW_HDR[FH2$B_MPOFFSET] = .NEW_HDR[FH2$B_IDOFFSET] + $BYTEOFFSET(FI2$W_REVISION) / 2;
    NEW_HDR[FH2$B_ACOFFSET] = $BYTEOFFSET(FH2$W_CHECKSUM) / 2;
    NEW_HDR[FH2$B_RSOFFSET] = $BYTEOFFSET(FH2$W_CHECKSUM) / 2;
    CH$FILL(0, 512 - .NEW_HDR[FH2$B_MPOFFSET]*2, .NEW_HDR + .NEW_HDR[FH2$B_MPOFFSET]*2);
    END
ELSE
    BEGIN
    LOCAL
	MAP_AREA:	REF BBLOCK;	! Pointer to map area


    MAP_AREA = .NEW_HDR + .NEW_HDR[FH1$B_MPOFFSET] * 2;


    ! Place the file ID in the new header.
    !
    NEW_HDR[FH1$W_FID_NUM] = .NEW_FILE_ID[FID$W_NUM];
    NEW_HDR[FH1$W_FID_SEQ] = .NEW_FILE_ID[FID$W_SEQ];


    ! Finish initializing the new header.
    !
    BBLOCK[NEW_HDR[FH1$W_RECATTR], FAT$L_HIBLK] = 0;
    BBLOCK[NEW_HDR[FH1$W_RECATTR], FAT$L_EFBLK] = 0;
    BBLOCK[NEW_HDR[FH1$W_RECATTR], FAT$W_FFBYTE] = 0;
    MAP_AREA[FM1$B_EX_SEGNUM] = .MAP_AREA[FM1$B_EX_SEGNUM] + 1;
    MAP_AREA[FM1$W_EX_FILNUM] = 0;
    MAP_AREA[FM1$W_EX_FILSEQ] = 0;
    MAP_AREA[FM1$B_INUSE] = 0;
    CH$FILL(0, .MAP_AREA[FM1$B_AVAIL] * 2, .MAP_AREA + FM1$C_POINTERS);
    END;


! Indicate success.
!
SS$_NORMAL
END;

ROUTINE STA_CREATE(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes IO$_CREATE in the standalone environment.
!
! INPUT PARAMETERS:
!	As for $QIO(W) system service.  However, a nonzero P6 points to
!	OUTPUT_ATTBUF, which indicates that the IO$_CREATE refers to a file
!	on an image output volume.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FUNC:		BBLOCK,		! I/O function code
	P1:		REF BBLOCK,	! Descriptor for FIB
	P2:		REF BBLOCK,	! Descriptor for filename
	P6:		REF BBLOCK;	! Pointer to OUTPUT_ATTBUF
LOCAL
	FIB:		REF BBLOCK,	! Pointer to FIB
	HEADER:		REF BBLOCK,	! Pointer to primary header
	EXT_HDR:	BBLOCK[512],	! Buffer for extension header
	CUR_HDR:	REF BBLOCK,	! Pointer to current header
	CUR_FID:	REF BBLOCK,	! Pointer to current file ID
	CHANNEL,			! Channel assigned to RVN
	CRT:		REF BBLOCK,	! Pointer to CRT entry
	STATUS,				! Status return
	TCOUNT,				! Total allocated block count
	HCOUNT,				! Count of file headers
	QUEUE_HEADERS:	VECTOR[6];	! Queue headers for:
					!     Allocated disk extents
					!     Required extents
					!     Used extension file IDs


! Check parameters.
!
IF .CURRENT_MTL[MTL_WINDOW] NEQ 0 THEN RETURN SS$_FILALRACC;


! Get file ID.
!
FIB = .P1[DSC$A_POINTER];
CURRENT_MTL[MTL_FID_NUM] = .FIB[FIB$W_FID_NUM];
CURRENT_MTL[MTL_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
CURRENT_MTL[MTL_FID_RVNW] = .FIB[FIB$W_FID_RVN];
IF .FIB[FIB$L_EXVBN] EQL 0 THEN FIB[FIB$L_EXVBN] = 1;


! Create header.
!
HEADER = .CURRENT_MTL[MTL_HEADER];
CH$FILL(0, 512, .HEADER);
IF .CURRENT_MTL[MTL_STRUCLEV] EQL 1
THEN
    BEGIN
    LOCAL
	NAMEBLOCK:	BBLOCK[NMB$C_LENGTH];

    HEADER[FH1$B_IDOFFSET] = FH1$C_LENGTH/2;
    HEADER[FH1$B_MPOFFSET] = (FH1$C_LENGTH+FI1$C_LENGTH)/2;
    HEADER[FH1$W_FID_NUM] = .FIB[FIB$W_FID_NUM];
    HEADER[FH1$W_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
    HEADER[FH1$W_STRUCLEV] = FH1$C_LEVEL1;
    IF .FIB[FIB$V_ALCON] THEN HEADER[FH1$V_CONTIG] = TRUE;
    MAKE_NAMEBLOCK(.P2[DSC$W_LENGTH], .P2[DSC$A_POINTER], NAMEBLOCK);
    CH$MOVE(
	10,
	NAMEBLOCK[NMB$W_NAME],
	BBLOCK[.HEADER + FH1$C_LENGTH, FI1$W_FILENAME]);
    BBLOCK[.HEADER + FH1$C_LENGTH + FI1$C_LENGTH, FM1$B_COUNTSIZE] = 1;
    BBLOCK[.HEADER + FH1$C_LENGTH + FI1$C_LENGTH, FM1$B_LBNSIZE] = 3;
    BBLOCK[.HEADER + FH1$C_LENGTH + FI1$C_LENGTH, FM1$B_AVAIL] =
	(512-2-FH1$C_LENGTH-FI1$C_LENGTH-FM1$C_LENGTH)/2;
    END
ELSE
    BEGIN
    HEADER[FH2$B_IDOFFSET] = FH2$C_LENGTH/2;
    HEADER[FH2$B_MPOFFSET] = (FH2$C_LENGTH+FI2$C_LENGTH)/2;
    HEADER[FH2$B_ACOFFSET] = $BYTEOFFSET(FH2$W_CHECKSUM)/2;
    HEADER[FH2$B_RSOFFSET] = $BYTEOFFSET(FH2$W_CHECKSUM)/2;
    HEADER[FH2$B_STRUCVER] = 1;
    HEADER[FH2$B_STRUCLEV] = 2;
    HEADER[FH2$W_FID_NUM] = .FIB[FIB$W_FID_NUM];
    HEADER[FH2$B_FID_NMX] = .FIB[FIB$B_FID_NMX];
    HEADER[FH2$W_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
    HEADER[FH2$W_BK_FIDNUM] = .FIB[FIB$W_DID_NUM];
    HEADER[FH2$W_BK_FIDSEQ] = .FIB[FIB$W_DID_SEQ];
    HEADER[FH2$W_BK_FIDRVN] = .FIB[FIB$W_DID_RVN];
    IF .FIB[FIB$V_ALCON] THEN HEADER[FH2$V_CONTIG] = TRUE;
    CH$COPY(
	.P2[DSC$W_LENGTH],
	.P2[DSC$A_POINTER],
	%C' ',
	FI2$S_FILENAME,
	BBLOCK[.HEADER + FH2$C_LENGTH, FI2$T_FILENAME]);
    END;


! Write attributes.
!
STATUS = WRITE_ATTRIBUTES(.HEADER, .P5);
IF NOT .STATUS THEN RETURN .STATUS;


! Create window.
!
STATUS = CREATE_WINDOW(
    .HEADER, 0, CURRENT_MTL[MTL_WINDOW],
    .FIB[FIB$L_EXVBN], MAXU(10, .FIB[FIB$B_WSIZE]));
IF NOT .STATUS THEN RETURN .STATUS;


! Process placement data.
!
TCOUNT = 0;
HCOUNT = 1;
QUEUE_HEADERS[0] = QUEUE_HEADERS[1] = QUEUE_HEADERS[0];
QUEUE_HEADERS[2] = QUEUE_HEADERS[3] = QUEUE_HEADERS[2];
QUEUE_HEADERS[4] = QUEUE_HEADERS[5] = QUEUE_HEADERS[4];
IF 
    BEGIN
    IF .P6 NEQ 0
	THEN .BBLOCK[P6[FAR_PLACEMENT], DSC$W_LENGTH] NEQ 0
	ELSE FALSE
    END
THEN
    BEGIN
    LOCAL
	CRT:		REF BBLOCK,	! Pointer to create list entry
	FID:		REF BBLOCK,	! Pointer to FID list entry
	PLC:		REF BBLOCK,	! Pointer to placement data
	PLC_END:	REF BBLOCK;	! Pointer beyond placement data


    ! Placement data exists.  Allocate a CRT entry and FID entry for the file
    ! ID in the FIB.
    !
    CRT = GET_VM(CRT_S_BLOCKS);
    INSQUE(.CRT, .QUEUE_HEADERS[2]);
    CRT[CRT_FID_FQHDR] = CRT[CRT_FID_BQHDR] = CRT[CRT_FID_FQHDR];
    CRT[CRT_BLOCKS] = 0;
    FID = GET_VM(CRT_S_FID);
    INSQUE(.FID, .CRT[CRT_FID_FQHDR]);
    FID[CRT_FID_NUM] = .FIB[FIB$W_FID_NUM];
    FID[CRT_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
    FID[CRT_FID_RVNW] = .FIB[FIB$W_FID_RVN];
    PLC = .BBLOCK[P6[FAR_PLACEMENT], DSC$A_POINTER];
    PLC_END = .PLC + .BBLOCK[P6[FAR_PLACEMENT], DSC$W_LENGTH];
    WHILE .PLC LSSA .PLC_END DO
	BEGIN
	LOCAL
	    TYPE;

	TYPE = .(.PLC)<0,8>;
	PLC = .PLC + 1;
	CASE .TYPE FROM BSA$K_PLC_FID TO BSA$K_PLC_PLLBN OF
	    SET

	    [BSA$K_PLC_FID]:
		BEGIN
		IF
		    BEGIN
		    IF .QUAL[QUAL_OF11] AND .QUAL[QUAL_VOLU]
		    THEN
			TRUE
		    ELSE
			BEGIN
			CRT = .QUEUE_HEADERS[2];
			WHILE .CRT NEQA QUEUE_HEADERS[2] DO
			    BEGIN
			    IF .PLC[FID$B_RVN] EQL .BBLOCK[.CRT[CRT_FID_FQHDR], CRT_FID_RVN] THEN EXITLOOP FALSE;
			    CRT = .CRT[CRT_FLINK];
			    END
			END
		    END
		THEN
		    BEGIN
		    CRT = GET_VM(CRT_S_BLOCKS);
		    INSQUE(.CRT, .QUEUE_HEADERS[3]);
		    CRT[CRT_FID_FQHDR] = CRT[CRT_FID_BQHDR] = CRT[CRT_FID_FQHDR];
		    CRT[CRT_BLOCKS] = 0;
		    END;
		FID = GET_VM(CRT_S_FID);
		INSQUE(.FID, .CRT[CRT_FID_BQHDR]);
		FID[CRT_FID_NUM] = .PLC[FID$W_NUM];
		FID[CRT_FID_SEQ] = .PLC[FID$W_SEQ];
		FID[CRT_FID_RVNW] = .PLC[FID$W_RVN];
		PLC = .PLC + BSA$S_PLC_FID;
		END;

	    [BSA$K_PLC_COUNT]:
		BEGIN
		CRT[CRT_BLOCKS] = .CRT[CRT_BLOCKS] + ..PLC;
		PLC = .PLC + BSA$S_PLC_COUNT;
		END;

	    [BSA$K_PLC_PLACE]:
		BEGIN
		CRT[CRT_BLOCKS] = .CRT[CRT_BLOCKS] + .PLC[BSA$L_PLC_COUNT];
		PLC = .PLC + BSA$S_PLC_PLACE;
		END;

	    [BSA$K_PLC_PLLBN]:
		BEGIN
		CRT[CRT_BLOCKS] = .CRT[CRT_BLOCKS] + .PLC[BSA$L_PLC_COUNT];
		PLC = .PLC + BSA$S_PLC_PLLBN;
		END;

	    [OUTRANGE]:
		RETURN CREATE_CLEANUP(QUEUE_HEADERS, BACKUP$_INVATTVAL);

	    TES;
	END;
    END
ELSE
    BEGIN
    LOCAL
	CRT:		REF BBLOCK,	! Pointer to create list entry
	FID:		REF BBLOCK;	! Pointer to FID list entry


    ! No placement data exists.  Allocate a degenerate list containing just
    ! the file ID in the FIB and BLOCKS equal to EXSZ.
    !
    CRT = GET_VM(CRT_S_BLOCKS);
    INSQUE(.CRT, .QUEUE_HEADERS[2]);
    CRT[CRT_FID_FQHDR] = CRT[CRT_FID_BQHDR] = CRT[CRT_FID_FQHDR];
    CRT[CRT_BLOCKS] = .FIB[FIB$L_EXSZ];
    FID = GET_VM(CRT_S_FID);
    INSQUE(.FID, .CRT[CRT_FID_FQHDR]);
    FID[CRT_FID_NUM] = .FIB[FIB$W_FID_NUM];
    FID[CRT_FID_SEQ] = .FIB[FIB$W_FID_SEQ];
    FID[CRT_FID_RVNW] = .FIB[FIB$W_FID_RVN];
    END;


! Allocate space, append map pointers and window pointers.
!
CRT = .QUEUE_HEADERS[2];
CUR_HDR = .HEADER;
CUR_FID = FIB[FIB$W_FID];
WHILE .TCOUNT LSSU .FIB[FIB$L_EXSZ] DO
    BEGIN
    LOCAL
        FID:		REF BBLOCK,	! Pointer to FID entry
        RCOUNT;				! Requested allocation from this CRT


    REMQUE(.CRT[CRT_FID_FQHDR], FID);	! Get first FID entry
    INSQUE(.FID, QUEUE_HEADERS[4]);


    ! Generate an extension header if this is not the primary file ID.
    !
    IF .CRT NEQA .QUEUE_HEADERS[2]
    THEN
	BEGIN
	STATUS = CREATE_EXTHDR(.CUR_HDR, .CUR_FID, EXT_HDR, FID[CRT_FID]);
	IF NOT .STATUS THEN RETURN CREATE_CLEANUP(QUEUE_HEADERS, .STATUS);
	CUR_HDR = EXT_HDR;
	CUR_FID = FID[CRT_FID];
	HCOUNT = .HCOUNT + 1;
	END;


    RCOUNT = MINU(.FIB[FIB$L_EXSZ] - . TCOUNT, .CRT[CRT_BLOCKS]);
    IF
	NOT .QUAL[QUAL_OF11] OR	! Sequential disk output
	NOT .QUAL[QUAL_VOLU] OR	! Not /VOLUME restore
	.QUAL[QUAL_VOLU_VALUE] EQL .FID[CRT_FID_RVN]
    THEN
	BEGIN
	LOCAL
	    VCB:		REF BBLOCK;	! VCB for RVN


	IF .FID[CRT_FID_RVN] - .CURRENT_MTL[MTL_RVN_BASE] GEQU .CURRENT_MTL[MTL_SETCOUNT]
	THEN
	    RETURN CREATE_CLEANUP(QUEUE_HEADERS, SS$_DEVNOTMOUNT);

	CURRENT_VCB = VCB = .CURRENT_MTL[MTL_VCB(.FID[CRT_FID_RVN]-.CURRENT_MTL[MTL_RVN_BASE])];

	IF NOT .VCB[VCB_INIT_DONE]
	THEN
	    SIGNAL(BACKUP$_NOVOLDATA, 1, VCB[VCB_DEVICE]);


	WHILE TRUE DO
	    BEGIN    
	    LOCAL
		EXT:	REF BBLOCK;	! Pointer to extent list entry


	    ! Generate extent list entry for new extent.
	    !
	    EXT = GET_VM(EXT_S_ENTRY);
	    INSQUE(.EXT, .QUEUE_HEADERS[0]);
	    EXT[EXT_VCB] = .VCB;


	    ! Try to allocate remaining blocks.
	    !
	    STA_ALLOC_BEST(.RCOUNT, EXT[EXT_COUNT], EXT[EXT_LBN]);


	    ! If no blocks were allocated, or if not enough blocks were
	    ! allocated and the allocation is required to be contiguous,
	    ! return device-full.
	    !
	    IF
		.EXT[EXT_COUNT] EQL 0 OR 
		.EXT[EXT_COUNT] LSSU .RCOUNT AND .FIB[FIB$V_ALCON]
	    THEN
		RETURN CREATE_CLEANUP(QUEUE_HEADERS, SS$_DEVICEFULL);


	    ! Append the map pointer.  For ODS-1, append one maximal pointer at
	    ! a time so that header overflow can be cleanly detected.  If the
	    ! header should fill, allocate an extension header from the list
	    ! hanging from the CRT entry.  If all headers have been used, fail.
	    !
	    BEGIN LOCAL L;
	    L = .EXT[EXT_LBN];
	    WHILE .L LSSU .EXT[EXT_LBN] + .EXT[EXT_COUNT] DO
		BEGIN LOCAL C;
		C = .EXT[EXT_LBN] + .EXT[EXT_COUNT] - .L;
		IF NOT .VCB[VCB_ODS_2]
		THEN
		    BEGIN
		    IF .C GTRU 256 THEN C = 256;
		    STATUS = MAKE_POINTER1(.CUR_HDR, .C, .L);
		    END
		ELSE
		    STATUS = MAKE_POINTER(.CUR_HDR, .C, .L);

		IF .STATUS
		THEN
		    L = .L + .C
		ELSE IF REMQUE(.CRT[CRT_FID_FQHDR], FID)
		THEN
		    RETURN CREATE_CLEANUP(QUEUE_HEADERS, SS$_HEADERFULL)
		ELSE
		    BEGIN
		    INSQUE(.FID, QUEUE_HEADERS[4]);
		    STATUS = CREATE_EXTHDR(
			.CUR_HDR, .CUR_FID, EXT_HDR, FID[CRT_FID]);
		    IF NOT .STATUS
			THEN RETURN CREATE_CLEANUP(QUEUE_HEADERS, .STATUS);
		    CUR_HDR = EXT_HDR;
		    CUR_FID = FID[CRT_FID];
		    HCOUNT = .HCOUNT + 1;
		    END;
		END;
	    END;


	    ! Append the window pointer.
	    !
	    ADD_WINDOW_MAP(
		.CURRENT_MTL[MTL_WINDOW],
		.FID[CRT_FID_RVN], .EXT[EXT_COUNT], .EXT[EXT_LBN]);


	    ! Count the allocation into the total, and determine if we need
	    ! to go around again for another extent.
	    !
	    TCOUNT = .TCOUNT + .EXT[EXT_COUNT];
	    IF .EXT[EXT_COUNT] GEQU .RCOUNT THEN EXITLOOP;
	    RCOUNT = .RCOUNT - .EXT[EXT_COUNT];
	    END;
	END
    ELSE
	BEGIN
	ADD_BLACKHOLE_MAP(.CURRENT_MTL[MTL_WINDOW], .CRT[CRT_BLOCKS]);
	TCOUNT = .TCOUNT + .CRT[CRT_BLOCKS];
	END;
    CRT = .CRT[CRT_FLINK];
    END;


! Initialize HIBLK.
!
IF
    NOT .QUAL[QUAL_OF11] OR	! Sequential disk output
    NOT .QUAL[QUAL_VOLU]	! Not /VOLUME restore
THEN
    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	THEN BBLOCK[HEADER[FH1$W_RECATTR], FAT$L_HIBLK] = ROT(.TCOUNT, 16)
	ELSE BBLOCK[HEADER[FH2$W_RECATTR], FAT$L_HIBLK] = ROT(.TCOUNT, 16);


! Write last extension header if it exists.
!
IF
    .CUR_HDR EQLA EXT_HDR AND
    (NOT .QUAL[QUAL_VOLU] OR .QUAL[QUAL_VOLU_VALUE] EQL .CUR_FID[FID$B_RVN])
THEN
    BEGIN
    STATUS = WRITE_HEADER(.CUR_FID, .CUR_HDR);
    IF NOT .STATUS THEN RETURN CREATE_CLEANUP(QUEUE_HEADERS, .STATUS);
    END;


! Write header and set index file bitmap bit.
!
IF
    NOT .QUAL[QUAL_OF11] OR	! Sequential disk output
    NOT .QUAL[QUAL_VOLU] OR	! Not /VOLUME restore
    .QUAL[QUAL_VOLU_VALUE] EQL .CURRENT_MTL[MTL_FID_RVN]
THEN
    BEGIN
    STATUS = WRITE_HEADER(CURRENT_MTL[MTL_FID], .HEADER);
    IF NOT .STATUS THEN RETURN CREATE_CLEANUP(QUEUE_HEADERS, .STATUS);
    END;


! Quota table maintenance.
!
IF .HEADER[FH2$B_STRUCLEV] EQL 2 AND .P6 NEQ 0 AND NOT .QUAL[QUAL_VOLU]
THEN
    BEGIN

    ! Locate and record file ID of QUOTA.SYS.
    !
    IF
	.BBLOCK[HEADER[FH2$W_RECATTR], FAT$B_RTYPE] EQL FAT$C_FIXED AND
	.BBLOCK[HEADER[FH2$W_RECATTR], FAT$B_RATTRIB] EQL 0 AND
	.BBLOCK[HEADER[FH2$W_RECATTR], FAT$W_RSIZE] EQL DQF$C_LENGTH AND
	.HEADER[FH2$V_CONTIG] AND
	.HEADER[FH2$W_BK_FIDNUM] EQL FID$C_MFD AND
	.HEADER[FH2$B_BK_FIDNMX] EQL 0 AND
	.HEADER[FH2$W_BK_FIDSEQ] EQL FID$C_MFD AND
	.FIB[FIB$B_FID_RVN] EQL 1 AND
	.P2[DSC$W_LENGTH] EQL %CHARCOUNT('QUOTA.SYS;1') AND
	CH$EQL(
	    %CHARCOUNT('QUOTA.SYS;1'), .P2[DSC$A_POINTER],
	    %CHARCOUNT('QUOTA.SYS;1'), UPLIT BYTE('QUOTA.SYS;1'))
    THEN
	BEGIN
	DQF_QUOTA_FID[FID$W_NUM] = .FIB[FIB$W_FID_NUM];
	DQF_QUOTA_FID[FID$W_SEQ] = .FIB[FIB$W_FID_SEQ];
	DQF_QUOTA_FID[FID$W_RVN] = .FIB[FIB$W_FID_RVN];
	END;


    ! Charge file space.
    !
    DQF_MODIFY_USAGE(.HEADER[FH2$L_FILEOWNER], .TCOUNT + .HCOUNT);
    END;


! Completed normally.
!
CREATE_CLEANUP(QUEUE_HEADERS, SS$_NORMAL)
END;

ROUTINE STA_DEACCESS(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes IO$_DEACCESS in the standalone environment.
!
! INPUT PARAMETERS:
!	As for $QIO(W) system service.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS;				! Status return


! Check that a file is accessed.
!
IF .CURRENT_MTL[MTL_WINDOW] EQL 0 THEN RETURN SS$_FILNOTACC;


! Write attributes if specified.
!
IF .P5 NEQ 0
THEN
    BEGIN
    STATUS = WRITE_ATTRIBUTES(.CURRENT_MTL[MTL_HEADER], .P5);
    IF NOT .STATUS THEN RETURN .STATUS;
    STATUS = WRITE_HEADER(CURRENT_MTL[MTL_FID], .CURRENT_MTL[MTL_HEADER]);
    IF NOT .STATUS THEN RETURN .STATUS;
    END;


! Delete the window.
!
DELETE_WINDOW(.CURRENT_MTL[MTL_WINDOW]);
CURRENT_MTL[MTL_WINDOW] = 0;
SS$_NORMAL
END;

ROUTINE STA_MODIFY(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes IO$_MODIFY in the standalone environment.
!
! INPUT PARAMETERS:
!	As for $QIO(W) system service.  However, a nonzero P6 points to
!	OUTPUT_ATTBUF, which indicates that the IO$_MODIFY refers to a
!	file on an image output volume.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	P1:		REF BBLOCK;	! Descriptor for FIB
LOCAL
	FIB:		REF BBLOCK,	! Pointer to FIB
	STATUS,				! Status variable
	RVN,				! RVN of current header
	HEADER:		REF BBLOCK,	! Pointer to file header
	FID:		REF BBLOCK,	! Pointer to current file ID
	EXT_FILE_ID:	BBLOCK [FID$C_LENGTH], ! FID of extension header
	LOCAL_HEADER:	BBLOCK [512];	! Local buffer for extension header


! Get the file ID if the file is not open.
!
HEADER = .CURRENT_MTL[MTL_HEADER];
FID = CURRENT_MTL[MTL_FID];
IF .CURRENT_MTL[MTL_WINDOW] EQL 0
THEN
    BEGIN
    IF .P1 EQL 0 THEN RETURN SS$_BADPARAM;
    FIB = .P1[DSC$A_POINTER];
    FID[FID$W_NUM] = .FIB[FIB$W_FID_NUM];
    FID[FID$W_SEQ] = .FIB[FIB$W_FID_SEQ];
    FID[FID$W_RVN] = .FIB[FIB$W_FID_RVN];
    STATUS = READ_HEADER(.FID, .HEADER);
    IF NOT .STATUS THEN RETURN .STATUS;
    END;
RVN = .FID[FID$B_RVN];


! Iterate over the headers of a multi-header file.
!

WHILE TRUE
DO
    BEGIN

! Write attributes.
!
    STATUS = WRITE_ATTRIBUTES(.HEADER, .P5);
    IF NOT .STATUS THEN RETURN .STATUS;


! Rewrite header.
!
    STATUS = WRITE_HEADER(.FID, .HEADER);
    IF NOT .STATUS THEN RETURN .STATUS;


! Quota table maintenance.  The file header must be charged.
!
    IF
	.HEADER[FH2$B_STRUCLEV] EQL 2 AND NOT .QUAL[QUAL_VOLU] AND
	.P6 NEQ 0 AND
	(.FIB[FIB$W_FID_NUM] GEQU FID$C_MFD OR .FIB[FIB$B_FID_NMX] NEQ 0)
    THEN
	DQF_MODIFY_USAGE(.HEADER[FH2$L_FILEOWNER], 1);

! Read and modify the next extension file header.
! Get clean file number and RVN.
!
    IF .HEADER[FH2$B_STRUCLEV] EQL 2
    THEN
	BEGIN
	EXT_FILE_ID[FID$W_NUM] = .HEADER[FH2$W_EX_FIDNUM];
	EXT_FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_EX_FIDSEQ];
	EXT_FILE_ID[FID$W_RVN] = .HEADER[FH2$W_EX_FIDRVN];
	END
    ELSE
	BEGIN
	LOCAL MAP_POINTER: REF BBLOCK;
	MAP_POINTER = .HEADER + .HEADER[FH1$B_MPOFFSET] * 2;
	EXT_FILE_ID[FID$W_NUM] = .MAP_POINTER[FM1$W_EX_FILNUM];
	EXT_FILE_ID[FID$W_SEQ] = .MAP_POINTER[FM1$W_EX_FILSEQ];
	EXT_FILE_ID[FID$W_RVN] = 0;
	END;
    IF .CURRENT_MTL[MTL_SEQ_DISK]
    OR (.EXT_FILE_ID[FID$W_NUM] EQL 0 AND .EXT_FILE_ID[FID$W_RVN] EQL 0)
    OR (.EXT_FILE_ID[FID$B_RVN] NEQ 0 AND .QUAL[QUAL_VOLU])
    THEN EXITLOOP;
    IF .EXT_FILE_ID[FID$B_RVN] EQL 0 THEN EXT_FILE_ID[FID$B_RVN] = .RVN;


! Set up header and RVN for next trip through loop.
!

    FID = EXT_FILE_ID;
    HEADER = LOCAL_HEADER;
    RVN = .EXT_FILE_ID[FID$B_RVN];

! Read extension file header.  If this fails,
! exit the loop.
!
    STATUS = READ_HEADER(EXT_FILE_ID, .HEADER);
    IF NOT .STATUS
    THEN RETURN .STATUS;
    END;


! Completed normally.
!
SS$_NORMAL
END;

GLOBAL ROUTINE STA_QIO(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the dispatcher for standalone ACP QIO functions.
!
! INPUT PARAMETERS:
!	As for $QIO(W) system service.
!
! IMPLICIT INPUTS:
!	INPUT_MTL	- Pointer to MTL for input volume set.
!	OUTPUT_MTL	- Pointer to MTL for output volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FUNC:		BBLOCK,		! I/O function code
	IOSB:		REF VECTOR [,WORD]; ! I/O status block
LOCAL
	STATUS;
BUILTIN
	AP;


IF .IOSB NEQ 0
THEN
    BEGIN
    IOSB[0] = 0;
    IOSB[1] = 0;
    IOSB[2] = 0;
    IOSB[3] = 0;
    END;


! Validate the channel number.  The standalone ACP uses special channel numbers
! larger than 16 bits to avoid interacting with VMS channel numbers, which are
! invalid here.  Set CURRENT_MTL to point to the MTL for the selected volume
! set.
!
IF
    BEGIN
    SELECTONE .CHAN OF
	SET

	[STA_IN_CHAN]:
	    BEGIN
	    CURRENT_MTL = .INPUT_MTL;
	    .CURRENT_MTL EQL 0
	    END;

	[STA_OUT_CHAN]:
	    BEGIN
	    CURRENT_MTL = .OUTPUT_MTL;
	    .CURRENT_MTL EQL 0
	    END;

	[OTHERWISE]:
	    TRUE;

	TES
    END
THEN
    RETURN SS$_IVCHAN;


! Dispatch to the function code specific processing routine.
!
CASE .FUNC[IO$V_FCODE] FROM IO$_WRITEVBLK TO IO$_MODIFY OF
    SET

    [IO$_WRITEVBLK, IO$_READVBLK]:
	BEGIN
	STATUS = CALLG(.AP, STA_RDWRVBLK);
	IF .STATUS THEN RETURN .STATUS;
	END;

    [IO$_ACCESS]:
	STATUS = CALLG(.AP, STA_ACCESS);

    [IO$_CREATE]:
	STATUS = CALLG(.AP, STA_CREATE);

    [IO$_DEACCESS]:
	STATUS = CALLG(.AP, STA_DEACCESS);

    [IO$_MODIFY]:
	STATUS = CALLG(.AP, STA_MODIFY);

    [INRANGE, OUTRANGE]:
	STATUS = SS$_ILLIOFUNC;

    TES;


! Return status in IOSB.
!
IF .IOSB NEQ 0
THEN
    BEGIN
    IOSB[0] = .STATUS<0,16>;
    END;


! Set the specified event flag and return success.
!
$SETEF(EFN=.EFN);
SS$_NORMAL
END;

GLOBAL ROUTINE STA_QIOW(EFN,CHAN,FUNC,IOSB,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes the $QIOW service for standalone functions.
!
! INPUT PARAMETERS:
!	As for $QIOW system service.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS;
BUILTIN
	AP;


STATUS = CALLG(.AP, STA_QIO);
IF NOT .STATUS THEN RETURN .STATUS;
$WAITFR(EFN=.EFN)
END;

ROUTINE READ_ATTRIBUTES(HEADER,ATRLIST)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes an ACP attributes list, returning the specified
!	attributes to the user.  Only attributes that are required by BACKUP
!	are processed.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to file header.
!	ATRLIST		- Pointer to ACP attributes list.
!
! IMPLICIT INPUTS:
!	CURRENT_MTL	- Pointer to MTL for selected volume set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status, SS$_NORMAL or SS$_BADATTRIB.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HEADER:		REF BBLOCK;		! Pointer to file header
LOCAL
	ATR:		REF BBLOCK;		! Pointer to attribute list


ATR = .ATRLIST;
WHILE .ATR[ATR$W_TYPE] NEQ 0 DO
    BEGIN
    LOCAL
	S_LEN,					! Source length for move
	S_ADR,					! Source address for move
	TEMP_AREA:	BBLOCK[10];		! Temporary buffer


    SELECTONE .ATR[ATR$W_TYPE] OF
	SET


	[ATR$C_RECATTR]:
	    BEGIN
	    S_LEN = FAT$C_LENGTH;
	    S_ADR = HEADER[FH2$W_RECATTR];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		S_ADR = HEADER[FH1$W_RECATTR];
	    END;


	[ATR$C_STATBLK]:
	    BEGIN
	    LOCAL
		WCB:	REF BBLOCK;

	    S_LEN = 8;
	    S_ADR = TEMP_AREA;
	    TEMP_AREA[0,0,32,0] = 0;
	    WCB = .CURRENT_MTL[MTL_WINDOW];
	    IF .WCB EQL 0 THEN RETURN SS$_BADATTRIB;
	    IF .WCB[WCB_LINK] EQL 0 AND .WCB[WCB_SIZE] EQL 1
	    THEN
		TEMP_AREA[0,0,32,0] =
		    ROT(.BBLOCK[WCB[WCB_S_HEADER,0,0,0], WCB_LBN], 16);
	    TEMP_AREA[4,0,32,0] = ROT(.CURRENT_MTL[MTL_FILESIZE], 16);
	    END;


	[ATR$C_HEADER]:
	    BEGIN
	    S_LEN = 512;
	    S_ADR = .HEADER;
	    END;


	[ATR$C_UIC]:
	    BEGIN
	    S_LEN = 4;
	    S_ADR = HEADER[FH2$L_FILEOWNER];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		TEMP_AREA<0,16> = .HEADER[FH1$B_UICMEMBER];
		TEMP_AREA<16,16> = .HEADER[FH1$B_UICGROUP];
		S_ADR = TEMP_AREA;
		END;
	    END;


	[ATR$C_UCHAR]:
	    BEGIN
	    S_LEN = 4;
	    S_ADR = HEADER[FH2$L_FILECHAR];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		TEMP_AREA<0,32> = .HEADER[FH1$W_FILECHAR];
		S_ADR = TEMP_AREA;
		END;
	    END;


	[ATR$C_EXTFID]:
	    BEGIN
	    IF .HEADER[FH2$B_STRUCLEV] NEQ 2
	    THEN RETURN SS$_BADATTRIB;
	    S_LEN = 6;
	    S_ADR = HEADER[FH2$W_EXT_FID];
	    END;


	[ATR$C_SEGNUM]:
	    BEGIN
	    IF .HEADER[FH2$B_STRUCLEV] NEQ 2
	    THEN RETURN SS$_BADATTRIB;
	    S_LEN = 2;
	    S_ADR = HEADER[FH2$W_SEG_NUM];
	    END;


	[OTHERWISE]:
	    RETURN SS$_BADATTRIB;


	TES;


    CH$COPY(.S_LEN, .S_ADR, 0, .ATR[ATR$W_SIZE], .ATR[ATR$L_ADDR]);
    ATR = .ATR + 8;
    END;


SS$_NORMAL
END;

GLOBAL ROUTINE TO_ODS1_DATE(SRC,DST): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine converts a date in 64-bit format to ODS-1 format.
!
! INPUT PARAMETERS:
!	SRC		- Address of quadword time value.
!	DST		- Address of 13-byte output buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	DST:		REF BBLOCK;		! Pointer to destination
LOCAL
	DESC:		VECTOR[2],		! Descriptor for buffer
	BUFFER:		BBLOCK[23];		! Buffer for converted time


! If the time value is 0, return the output area filled with binary zeros.
!
IF ..SRC EQL 0
THEN
    BEGIN
    CH$FILL(0, 13, .DST);
    RETURN;
    END;


! Convert the value.
!
DESC[0] = 23;				! Make descriptor
DESC[1] = BUFFER;
$ASCTIM(TIMBUF=DESC, TIMADR=.SRC);	! Convert time value
DST[0,0,16,0] = .BUFFER[0,0,16,0];	! Output DD
DST[2,0,24,0] = .BUFFER[3,0,24,0];	! Output MMM
DST[5,0,16,0] = .BUFFER[9,0,16,0];	! Output YY
DST[7,0,16,0] = .BUFFER[12,0,16,0];	! Output HH
DST[9,0,16,0] = .BUFFER[15,0,16,0];	! Output MM
DST[11,0,16,0] = .BUFFER[18,0,16,0];	! Output SS
END;

ROUTINE WRITE_ATTRIBUTES(HEADER,ATR_LIST)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes an ACP attributes list, writing the specified
!	attributes to the header.  Only attributes that are required by BACKUP
!	are processed.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to file header.
!	ATR_LIST	- Pointer to ACP attributes list.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status, SS$_NORMAL or SS$_BADATTRIB.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	HEADER:		REF BBLOCK;		! Pointer to file header
LOCAL
	ATR:		REF BBLOCK,		! Pointer to attribute list
	IDENT_AREA:	REF BBLOCK;		! Pointer to ident area of header


ATR = .ATR_LIST;
IDENT_AREA = .HEADER + .HEADER[FH2$B_IDOFFSET] * 2;
WHILE .ATR[ATR$W_TYPE] NEQ 0 DO
    BEGIN
    LOCAL
	S_LEN,					! Source length for move
	S_ADR,					! Source address for move
	D_LEN,					! Destination length for move
	D_ADR,					! Destination address for move
	TEMP_AREA:	BBLOCK[13];		! Temporary buffer


    S_LEN = .ATR[ATR$W_SIZE];
    S_ADR = .ATR[ATR$L_ADDR];


    CASE .ATR[ATR$W_TYPE] FROM ATR$C_UCHAR TO ATR$C_SEGNUM OF
	SET


	[ATR$C_UCHAR]:
	    BEGIN
	    LITERAL
		PROTECTED_CHAR=
		    FCH$M_CONTIG OR
		    FCH$M_SPOOL OR
		    FCH$M_BADBLOCK OR
		    FCH$M_MARKDEL,
		ODS1_CHAR=
		    FCH$M_NOBACKUP OR
		    FCH$M_READCHECK OR
		    FCH$M_WRITCHECK OR
		    FCH$M_CONTIGB OR
		    FCH$M_LOCKED OR
		    FCH$M_CONTIG OR
		    FCH$M_SPOOL OR
		    FCH$M_BADBLOCK OR
		    FCH$M_MARKDEL;


	    D_LEN = 4;
	    D_ADR = HEADER[FH2$L_FILECHAR];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		D_LEN = 2;
		D_ADR = HEADER[FH1$W_FILECHAR];
		END;


	    ! Get value from user attribute list.
	    !
	    CH$COPY(.S_LEN, .S_ADR, 0, .D_LEN, TEMP_AREA);


	    ! Get protected characteristics from file header.
	    !
	    TEMP_AREA =
		(.TEMP_AREA AND NOT PROTECTED_CHAR) OR
		(.(.D_ADR)<0,.D_LEN*8> AND PROTECTED_CHAR);


	    ! Make sure characteristics bits not used in ODS-1 are clear.
	    !
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		TEMP_AREA = .TEMP_AREA AND ODS1_CHAR;


	    S_LEN = .D_LEN;
	    S_ADR = TEMP_AREA;
	    END;


	[ATR$C_RECATTR]:
	    BEGIN
	    D_LEN = FAT$C_LENGTH;
	    D_ADR = HEADER[FH2$W_RECATTR];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		D_ADR = HEADER[FH1$W_RECATTR];
	    END;


	[ATR$C_ASCDATES]:
	    BEGIN
	    D_LEN = 2;
	    D_ADR = IDENT_AREA[FI2$W_REVISION];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		D_ADR = IDENT_AREA[FI1$W_REVISION];
	    END;


	[ATR$C_CREDATE]:
	    BEGIN
	    D_LEN = 8;
	    D_ADR = IDENT_AREA[FI2$Q_CREDATE];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		D_ADR = IDENT_AREA[FI1$T_CREDATE];
		TO_ODS1_DATE(.S_ADR, TEMP_AREA);
		S_LEN = 13;
		S_ADR = TEMP_AREA;
		D_LEN = 13;
		END;
	    END;


	[ATR$C_REVDATE]:
	    BEGIN
	    D_LEN = 8;
	    D_ADR = IDENT_AREA[FI2$Q_REVDATE];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		D_ADR = IDENT_AREA[FI1$T_REVDATE];
		TO_ODS1_DATE(.S_ADR, TEMP_AREA);
		S_LEN = 13;
		S_ADR = TEMP_AREA;
		D_LEN = 13;
		END;
	    END;


	[ATR$C_EXPDATE]:
	    BEGIN
	    D_LEN = 8;
	    D_ADR = IDENT_AREA[FI2$Q_EXPDATE];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		D_ADR = IDENT_AREA[FI1$T_EXPDATE];
		TO_ODS1_DATE(.S_ADR, TEMP_AREA);
		S_LEN = 13;
		S_ADR = TEMP_AREA;
		D_LEN = 7;
		END;
	    END;


	[ATR$C_BAKDATE]:
	    BEGIN
	    D_LEN = 8;
	    D_ADR = IDENT_AREA[FI2$Q_BAKDATE];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		D_LEN = 0;
	    END;


	[ATR$C_UIC]:
	    BEGIN
	    D_LEN = 4;
	    D_ADR = HEADER[FH2$L_FILEOWNER];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		BEGIN
		TEMP_AREA<0,8> = .(.S_ADR)<0,16>;
		TEMP_AREA<8,8> = .(.S_ADR)<16,16>;
		S_LEN = 2;
		S_ADR = TEMP_AREA;
		D_LEN = 2;
		D_ADR = HEADER[FH1$W_FILEOWNER];
		END;
	    END;


	[ATR$C_FPRO]:
	    BEGIN
	    D_LEN = 2;
	    D_ADR = HEADER[FH2$W_FILEPROT];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		D_ADR = HEADER[FH1$W_FILEPROT];
	    END;


	[ATR$C_RPRO]:
	    BEGIN
	    D_LEN = 2;
	    D_ADR = HEADER[FH2$W_RECPROT];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		D_LEN = 0;
	    END;


	[ATR$C_ACLEVEL]:
	    BEGIN
	    D_LEN = 1;
	    D_ADR = HEADER[FH2$B_ACC_MODE];
	    IF .HEADER[FH2$B_STRUCLEV] EQL 1
	    THEN
		D_LEN = 0;
	    END;


	[ATR$C_EXTFID]:
	    BEGIN
	    IF .HEADER[FH2$B_STRUCLEV] NEQ 2
	    THEN RETURN SS$_BADATTRIB;
	    D_LEN = 6;
	    D_ADR = HEADER[FH2$W_EXT_FID];
	    END;


	[ATR$C_SEGNUM]:
	    BEGIN
	    IF .HEADER[FH2$B_STRUCLEV] NEQ 2
	    THEN RETURN SS$_BADATTRIB;
	    D_LEN = 2;
	    D_ADR = HEADER[FH2$W_SEG_NUM];
	    END;


	[INRANGE, OUTRANGE]:
	    RETURN SS$_BADATTRIB;


	TES;


    CH$COPY(.S_LEN, .S_ADR, 0, .D_LEN, .D_ADR);
    ATR = .ATR + 8;
    END;


SS$_NORMAL
END;

END
ELUDOM
