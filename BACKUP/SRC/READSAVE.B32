MODULE READSAVE (%TITLE	'Read Save Set'
		IDENT = 'V03-003'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!
!	This module contains routines to do the I/O involved in reading
!	save sets.
!
! ENVIRONMENT:
!
!	VAX/VMS user mode
!
!--
!
! AUTHOR:  Andrew C. Goldstein, CREATION DATE:  2-Sep-1980  19:17
!
! MODIFIED BY:
!
!	V03-003	ACG0280		Andrew C. Goldstein,	2-Apr-1982  16:48
!		Add dot to save set name with null type
!
!	V03-002	ACG0277		Andrew C. Goldstein,	30-Mar-1982  15:30
!		Check for spurious change in save set name
!
!	V03-001	ACG0276		Andrew C. Goldstein,	26-Mar-1982  18:23
!		Allow XOR groups to be one larger than indicated,
!		reject non-BACKUP blocks quietly
!
!	V02-012	ACG0235		Andrew C. Goldstein,	8-Dec-1981  21:35
!		Backspace tape over small save sets for verify
!
!	V02-011	MLJ0054		Martin L. Jack,	31-Oct-1981  15:03
!		Implement network save sets.  Move STAACP globals to common.
!
!	V02-010	ACG0217		Andrew C. Goldstein,	10-Sep-1981  18:01
!		Validate tape block size in reading save sets
!
!	V02-009	ACG0211		Andrew C. Goldstein,	29-Jul-1981  16:52
!		Implement sequential disk save sets
!
!	V02-008	ACG0209		Andrew C. Goldstein,	5-Jun-1981  15:09
!		Stop on excessive input error rate
!
!	V02-007	MLJ0025		Martin L. Jack,	8-May-1981  13:48
!		Reorganize qualifier database.  Move global variables into
!		common.  Make routines non-global if possible.
!
!	V02-006	ACG0202		Andrew C. Goldstein,	23-Apr-1981  13:44
!		Fix handling of /SAVE on magtapes
!
!	V02-004	MLJ0018		Martin L. Jack,	7-Apr-1981  21:09
!		Correct signal parameters.
!
!	V02-003	MLJ0010		Martin L. Jack,	25-Mar-1981  15:38
!		Reorganize global storage.  Remove limiting of buffer count as
!		COMMAND now does this.  Change IQUA_FILE to IQUA_SAVE.  Ensure
!		that QIO service failures are fatal.  Correct V02-001 to apply
!		to continuation tapes.
!
!	V02-002	ACG0197		Andrew C. Goldstein,	5-Mar-1981  17:15
!		Make not first reel error fatal if image restore
!
!	V02-001	ACG0193		Andrew C. Goldstein,	26-Feb-1981  17:04
!		Allow null input save set name, add file type
!
!**


LIBRARY	'SYS$LIBRARY:LIB';
REQUIRE	'SRC$:COMMON';
REQUIRE	'LIB$:BACKDEF.B32';

EXTERNAL LITERAL
	BACKUP$_OPENIN,
	BACKUP$_READERR,
	BACKUP$_CLOSEIN,
	BACKUP$_SHORTBLOCK,
	BACKUP$_BLOCKCRC,
	BACKUP$_HDRCRC,
	BACKUP$_BLOCKLOST,
	BACKUP$_POSERROR,
	BACKUP$_POSITERR,
	BACKUP$_NOTBKBLOCK,
	BACKUP$_INVBLKHDR,
	BACKUP$_INVSTRUCT,
	BACKUP$_INVBLKSIZE,
	BACKUP$_INVFILEXT,
	BACKUP$_LABELERR,
	BACKUP$_NOTANSI,
	BACKUP$_NOTSAVESET,
	BACKUP$_NOT1STVOL,
	BACKUP$_WRONGVOL,
	BACKUP$_BADBLKSIZE,
	BACKUP$_FATALERR,
	BACKUP$_READERRS,
	BACKUP$_SOFTRERRS,
	BACKUP$_SSCHANGE,
	BACKUP$_XORERRS,
	BACKUP$_STARTVERIFY,
	BACKUP$_RESUME;

FORWARD ROUTINE
	READY_NEXT_VOLUME,
	NEXT_VOLUME;


G$DEFINE();		! Define global common area

ROUTINE READ_BLOCK (READ_AHEAD, CRC_CHECK) = 

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a block from the input save set.
!
! CALLING SEQUENCE:
!	READ_BLOCK (READ_AHEAD)
!
! INPUT PARAMETERS:
!	READ_AHEAD: TRUE to enable asynchronous read ahead
!		    FALSE to read just one block
!	CRC_CHECK: TRUE to check block CRC's, etc.
!		   FALSE to accept any block
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	address of BCB of buffer read
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	INSQUE,
	REMQUE,
	TESTBITCS,
	CRC;				! compute CRC instruction

LOCAL
	STATUS,				! general status value
	P		: REF BBLOCK,	! pointer to chase BCB list
	BCB		: REF BBLOCK,	! buffer control block
	BUFFER		: REF BBLOCK,	! the I/O buffer itself
	RAB		: REF BBLOCK,	! input RAB
	RECP		: REF BBLOCK,	! pointer to end of records
	BLOCK_CRC,			! CRC of data block
	HDR_CRC,			! CRC of block header
	CHECKSUM;			! output of CRC instruction

EXTERNAL ROUTINE
	FILE_ERROR	: NOVALUE,	! signal file-related error
	GET_BUFFER,			! get an I/O buffer
	FREE_BUFFER,			! free an I/O buffer
	WAIT;				! wait for I/O completion

! If reading from a file, allocate a buffer and read a block.
!

IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    IF NOT REMQUE (.INPUT_WAIT[0], BCB)
    THEN
	WAIT (.BCB)
    ELSE
	BEGIN
	BCB = GET_BUFFER ();

	RAB = RWSV_SAVE_FAB[FC_RAB];
	RAB[RAB$W_USZ] = .BCB[BCB_SIZE];
	RAB[RAB$L_UBF] = .BCB[BCB_BUFFER];
	BCB[BCB_STATUS] = TRUE;
	IF .RWSV_SAVE_FAB[FAB$V_BIO]
	THEN
	    BEGIN
	    STATUS = $READ (RAB = .RAB);
	    RAB[RAB$L_BKT] = 0;
	    RWSV_SAVE_FAB[FAB$V_SQO] = TRUE;
	    END
	ELSE
	    STATUS = $GET (RAB = .RAB);
	BCB[BCB_IO_BCOUNT] = .RAB[RAB$W_RSZ];
	IF NOT .STATUS
	THEN
	    BEGIN
	    IF .STATUS EQL RMS$_EOF
	    THEN
		BCB[BCB_STATUS] = SS$_ENDOFFILE
	    ELSE
		BEGIN
		BCB[BCB_STATUS] = .RAB[RAB$L_STS];
		BCB[BCB_STATUS2] = .RAB[RAB$L_STV];
		END;
	    END;
	END;
    END

! If we are reading from tape or sequential disk, grab I/O buffers
! and issue read ahead QIO's until half the buffer pool is used. Then
! wait for completion on the first buffer.
!

ELSE
    BEGIN
    P = .INPUT_WAIT[0];
    DECR J FROM (
	IF .READ_AHEAD
	THEN (.COM_BUFF_COUNT+1) / 2
	ELSE 1
	) TO 1
    DO
	BEGIN
	IF .P NEQ INPUT_WAIT[0]
	THEN P = ..P
	ELSE
	    BEGIN
	    BCB = GET_BUFFER ();
	    CH$FILL (0, BBH$K_LENGTH, .BCB[BCB_BUFFER]);

	    IF .BBLOCK [RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_SQD]
	    THEN
		BEGIN
		STATUS = $QIO  (CHAN = .RWSV_CHAN,
				FUNC = IO$_READLBLK,
				EFN  = BCB_S_READ,
				IOSB = BCB[BCB_IOSB],
				P1   = .BCB[BCB_BUFFER],
				P2   = .BCB[BCB_SIZE]
				);
		END

	    ELSE
		BEGIN
		BCB[BCB_BLOCKNUM] = .RWSV_IN_VBN;
		IF .RWSV_IN_VBN GEQU .RWSV_EOF
		THEN
		    BEGIN
		    BCB[BCB_STATUS] = SS$_ENDOFFILE;
		    STATUS = 1;
		    END
		ELSE
		    BEGIN
		    STATUS = S$QIO (CHAN = .RWSV_CHAN,
				    FUNC = IO$_READVBLK,
				    EFN  = BCB_S_READ,
				    IOSB = BCB[BCB_IOSB],
				    P1   = .BCB[BCB_BUFFER],
				    P2   = .BCB[BCB_SIZE],
				    P3   = .RWSV_IN_VBN
				    );
		    RWSV_IN_VBN = .RWSV_IN_VBN + (.BCB[BCB_SIZE]+511) / 512;
		    END;
		END;
	    IF NOT .STATUS
	    THEN
		FILE_ERROR(
		    BACKUP$_READERR + STS$K_SEVERE,
		    .RWSV_SAVE_FAB,
		    .STATUS);

	    BCB[BCB_SUCC_ACT] = 0;
	    BCB[BCB_FAIL_ACT] = 0;
	    BCB[BCB_STATE] = BCB_S_READ;
	    INSQUE (.BCB, .INPUT_WAIT[1]);
	    END;
	END;

    REMQUE (.INPUT_WAIT[0], BCB);
    WAIT (.BCB);
    BCB[BCB_STATUS2] = 0;
    END;

! Do basic validation checks on the buffer. It should be of the expected
! length, and the CRC's, if present, should check.
!

IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFTAPE
THEN BCB[BCB_IO_STATUS] = TRUE;

BUFFER = .BCB[BCB_BUFFER];
IF NOT .BCB[BCB_IO_STATUS]
THEN
    BEGIN
    IF NOT .QUAL[QUAL_SS_FILE]
    THEN BCB[BCB_IO_BCOUNT] = 0;
    IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
    THEN RETURN .BCB;
    IF .RWSV_IN_ORGERR[0]
    THEN
	BEGIN
	RWSV_IN_ORGERR[0] = .BCB[BCB_STATUS];
	RWSV_IN_ORGERR[1] = 0;
	END;
    END

ELSE IF .CRC_CHECK
THEN
    BEGIN
    IF .BCB[BCB_IO_BCOUNT] LSSU .BCB[BCB_SIZE]
    THEN
	BEGIN
	CH$FILL (0, .BCB[BCB_SIZE]-.BCB[BCB_IO_BCOUNT], .BUFFER+.BCB[BCB_IO_BCOUNT]);
	BCB[BCB_STATUS] = BACKUP$_SHORTBLOCK;
	END;
    END;

IF .CRC_CHECK
THEN
    BEGIN
    BLOCK_CRC = .BUFFER[BBH$L_CRC];
    HDR_CRC = .BUFFER[BBH$W_CHECKSUM];
    BUFFER[BBH$L_CRC] = 0;
    BUFFER[BBH$W_CHECKSUM] = 0;

    CRC (RWSV_CRC16, %REF (0), %REF (BBH$K_LENGTH), .BUFFER, CHECKSUM);
    IF .HDR_CRC NEQ .CHECKSUM
    THEN BCB[BCB_STATUS] = BACKUP$_HDRCRC;

    IF (
	(.QUAL[QUAL_CRC] OR (.COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV]))
	AND NOT .BUFFER[BBH$V_NOCRC]
	AND .BCB[BCB_STATUS]
	AND
	    BEGIN
	    CRC (RWSV_AUTODIN, %REF (-1), BCB[BCB_SIZE], .BUFFER, CHECKSUM);
	    .BLOCK_CRC NEQ (NOT .CHECKSUM)
	    END
	)
    THEN BCB[BCB_STATUS] = BACKUP$_BLOCKCRC;

    BUFFER[BBH$L_CRC] = .BLOCK_CRC;
    BUFFER[BBH$W_CHECKSUM] = .HDR_CRC;

    IF NOT .BCB[BCB_STATUS]
    AND .RWSV_IN_ORGERR[0]
    THEN
	BEGIN
	RWSV_IN_ORGERR[0] = .BCB[BCB_STATUS];
	RWSV_IN_ORGERR[1] = 0;
	END;
    END;

! If this block read with an error, count it. If there are too many
! consecutive errors, complain. Medium offline is handled specially, since
! operator help is clearly necessary.
!

IF NOT .BCB[BCB_STATUS]
THEN
    BEGIN
    RWSV_SEQ_ERRORS = .RWSV_SEQ_ERRORS + 1;
    IF .BCB[BCB_IO_STATUS] EQL SS$_MEDOFL
    OR .BCB[BCB_IO_STATUS] EQL SS$_VOLINV
    THEN
	BEGIN
	INSQUE (.BCB, RWSV_HOLD_LIST[0]);

! Other pending reads are also likely to fail with the same error. Clean
! them out.
!

	UNTIL REMQUE (.INPUT_WAIT[0], BCB)
	DO
	    BEGIN
	    WAIT (.BCB);
	    IF  .BCB[BCB_IO_STATUS] NEQ SS$_MEDOFL
	    AND .BCB[BCB_IO_STATUS] NEQ SS$_VOLINV
	    THEN
		BEGIN
		INSQUE (.BCB, INPUT_WAIT[0]);
		BCB[BCB_STATE] = BCB_S_READ;
		EXITLOOP;
		END
	    ELSE
		FREE_BUFFER (.BCB);
	    END;
	FILE_ERROR (BACKUP$_FATALERR, .RWSV_SAVE_FAB,
		    .RWSV_IN_ORGERR[0], .RWSV_IN_ORGERR[1]);
	REMQUE (.RWSV_HOLD_LIST[0], BCB);
	END

    ELSE IF (
	IF .RWSV_SEQ_ERRORS GTRU 100
	THEN TESTBITCS (COM_FLAGS[COM_CONTINUE])
	ELSE FALSE)
    THEN
	BEGIN
	INSQUE (.BCB, RWSV_HOLD_LIST[0]);
	FILE_ERROR (BACKUP$_READERRS, .RWSV_SAVE_FAB,
		    .RWSV_IN_ORGERR[0], .RWSV_IN_ORGERR[1]);
	REMQUE (.RWSV_HOLD_LIST[0], BCB);
	END;
    END

ELSE
    RWSV_SEQ_ERRORS = 0;

.BCB
END;					! End of routine READ_BLOCK

ROUTINE READ_SEQ_BLOCK (READ_AHEAD) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a save set block and applies sequence number
!	checking and rewrite error recovery.
!
! CALLING SEQUENCE:
!	READ_SEQ_BLOCK (READ_AHEAD)
!
! INPUT PARAMETERS:
!	READ_AHEAD: TRUE to enable asynchronous read ahead
!		FALSE to read only one block
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	BCB address of block read
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	REMQUE;

LOCAL
	BCB		: REF BBLOCK,	! BCB of block read
	BUFFER		: REF BBLOCK,	! address of data block read
	BLOCK_COUNT,			! count of blocks read forward
	BK_BLOCK_COUNT,			! count of backup blocks seen
	TM_COUNT;			! count of tape marks crossed

EXTERNAL ROUTINE
	SKIP_RECORD,			! skip tape records
	SKIP_TM,			! skip tape marks
	WAIT,				! wait for I/O completion
	FREE_BUFFER;			! free an I/O buffer

! The outer loop handles re-reading a data block after a forward
! retry has been tried and found unsuccessful.
!

DECR TRY FROM 2 TO 1
DO
    BEGIN

! Loop, reading blocks from the input medium. If an error occurrs,
! leave the loop for forward retry. Keep reading blocks if a sequence
! number inversion occurrs. Note that a block header CRC error is totally
! fatal. Since the header cannot be trusted, the block must be flushed.
! Blocks not written by BACKUP are also flushed at this level.
!

    WHILE TRUE
    DO
	BEGIN
	BCB = READ_BLOCK (.READ_AHEAD, TRUE);
	BUFFER = .BCB[BCB_BUFFER];
	IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
	THEN RETURN .BCB;
	IF .BCB[BCB_STATUS] NEQ BACKUP$_HDRCRC
	AND .BUFFER[BBH$W_SUBSYS] EQL BACKUP$K_BACKUP
	AND .BUFFER[BBH$L_NUMBER] GEQU .RWSV_IN_SEQ
	THEN EXITLOOP;
	FREE_BUFFER (.BCB);
	END;

    IF (.BCB[BCB_IO_STATUS] AND .BUFFER[BBH$L_NUMBER] EQL .RWSV_IN_SEQ)
    OR .TRY
    THEN
	EXITLOOP
    ELSE
	BEGIN
	RWSV_IN_ERRORS = .RWSV_IN_ERRORS + 1;
	IF .QUAL[QUAL_SS_FILE]
	OR NOT .BBLOCK [RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_SQD]
	THEN EXITLOOP;
	END;

! If an error has occurred, search forward, limited by the buffer depth
! of the writer, for a rewrite of the block.
!

    FREE_BUFFER (.BCB);
    BLOCK_COUNT = 0;
    BK_BLOCK_COUNT = 0;
    TM_COUNT = 0;
    IF .RWSV_LOOKAHEAD EQL 0 THEN RWSV_LOOKAHEAD = 10;
    DO
	BEGIN
	BCB = READ_BLOCK (FALSE, TRUE);
	BUFFER = .BCB[BCB_BUFFER];
	IF .BCB[BCB_IO_STATUS]
	AND .BUFFER[BBH$W_SUBSYS] EQL BACKUP$K_BACKUP
	AND .BUFFER[BBH$L_NUMBER] EQL .RWSV_IN_SEQ
	THEN RETURN .BCB;
	FREE_BUFFER (.BCB);
	IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
	THEN
	    BEGIN
	    TM_COUNT = .TM_COUNT + 1;
	    EXITLOOP;
	    END;
	IF .TM_COUNT EQL 0
	THEN BLOCK_COUNT = .BLOCK_COUNT + 1;
	IF .BUFFER[BBH$W_SUBSYS] EQL BACKUP$K_BACKUP
	THEN BK_BLOCK_COUNT = .BK_BLOCK_COUNT + 1;
	END
    UNTIL .BK_BLOCK_COUNT GEQU .RWSV_LOOKAHEAD
    AND .BCB[BCB_STATUS] NEQ BACKUP$_HDRCRC
    AND .BUFFER[BBH$L_NUMBER] - .RWSV_IN_SEQ GEQU .RWSV_LOOKAHEAD;

! Failed to find a rewrite of the block. Flush out the input wait list,
! then backspace the tape to the original block, less one for good measure,
! and retry the read.
!

    UNTIL REMQUE (.INPUT_WAIT[0], BCB)
    DO
	BEGIN
	WAIT (.BCB);
	IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
	THEN TM_COUNT = .TM_COUNT + 1;
	IF .TM_COUNT EQL 0
	THEN BLOCK_COUNT = .BLOCK_COUNT + 1;
	FREE_BUFFER (.BCB);
	END;

    IF .TM_COUNT NEQ 0
    THEN SKIP_TM (-.TM_COUNT);
    IF SKIP_RECORD (-.BLOCK_COUNT - 2) EQL SS$_ENDOFFILE
    THEN SKIP_TM (1);
    END;				! end of outer loop

.BCB
END;					! End of routine READ_SEQ_BLOCK

ROUTINE REPOSITION (BLOCK_NEEDED, ADDRESS, CUR_BCB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine repositions the input save set to the specified
!	sequence number and reads that block.
!
! CALLING SEQUENCE:
!	REPOSITION (BLOCK_NEEDED, ADDRESS, CUR_BCB)
!
! INPUT PARAMETERS:
!	BLOCK_NEEDED: sequence number of desired block
!	ADDRESS: address of RFA or VBN, if file or seq disk, respectively
!	CUR_BCB: BCB of last block read
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	BCB of desired block
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	REMQUE;

MAP
	CUR_BCB		: REF BBLOCK;	! input BCB arg

LOCAL
	STATUS,				! general status value
	BOT,				! flag indicating tape backspaced into BOT
	RAB		: REF BBLOCK,	! RAB for reading input file
	PREV_SEQ,			! sequence number of last block read
	BLOCK_COUNT,			! count of records to backspace
	TM_COUNT,			! count of EOF marks to backspace
	BCB		: REF BBLOCK,	! current BCB
	BUFFER		: REF BBLOCK;	! current I/O buffer

EXTERNAL ROUTINE
	WAIT,				! wait for I/O completion
	FILE_ERROR,			! signal file related error
	FREE_BUFFER,			! free an I/O buffer
	SKIP_RECORD,			! skip tape records
	SKIP_TM;			! skip tape marks

! First wait out pending reads, tracking the tape position.
!

BUFFER = .CUR_BCB[BCB_BUFFER];
PREV_SEQ = .BUFFER[BBH$L_NUMBER];
BLOCK_COUNT = .BUFFER[BBH$L_NUMBER] - .BLOCK_NEEDED + 1;
TM_COUNT = 0;
IF .CUR_BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
THEN TM_COUNT = .TM_COUNT + 1;
IF .CUR_BCB[BCB_STATE] NEQ BCB_S_IDLE
THEN FREE_BUFFER (.CUR_BCB);

UNTIL REMQUE (.INPUT_WAIT[0], BCB)
DO
    BEGIN
    WAIT (.BCB);
    IF .BCB[BCB_STATUS] EQL SS$_ENDOFFILE
    THEN TM_COUNT = .TM_COUNT + 1;
    IF .TM_COUNT NEQ 0
    THEN BLOCK_COUNT = .BLOCK_COUNT + 1;
    FREE_BUFFER (.BCB);
    END;

! Now find the first block of the group by backspacing, reading, and
! checking the sequence number. This may take several tries, since
! we don't know whether there are block rewrites to space over.
!

RWSV_IN_SEQ = 0;
WHILE TRUE
DO
    BEGIN
    IF NOT .QUAL[QUAL_SS_FILE]
    THEN
	BEGIN
	IF .BBLOCK [RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_SQD]
	THEN
	    BEGIN
	    BOT = FALSE;
	    IF .TM_COUNT NEQ 0
	    THEN SKIP_TM (-.TM_COUNT);
	    IF .BLOCK_COUNT GTR 0
	    THEN IF SKIP_RECORD (-.BLOCK_COUNT) EQL SS$_ENDOFFILE
	    THEN
		BEGIN
		SKIP_TM (1);
		BOT = TRUE;
		END;
	    END
	ELSE
	    RWSV_IN_VBN = ..ADDRESS;
	END
    ELSE
	BEGIN
	RAB = RWSV_SAVE_FAB[FC_RAB];
	IF .BBLOCK[RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_NET]
	THEN
	    BEGIN
	    STATUS = $DISCONNECT (RAB = .RAB);
	    IF NOT .STATUS
	    THEN
		BEGIN
		FILE_ERROR (BACKUP$_POSITERR, .RWSV_SAVE_FAB,
			.RAB[RAB$L_STS], .RAB[RAB$L_STV]);
		END;
	    RWSV_SAVE_FAB[FAB$V_SQO] = FALSE;
	    STATUS = $CONNECT (RAB = .RAB);
	    IF NOT .STATUS
	    THEN
		BEGIN
		FILE_ERROR (BACKUP$_POSITERR, .RWSV_SAVE_FAB,
			.RAB[RAB$L_STS], .RAB[RAB$L_STV]);
		END;
	    RAB[RAB$L_BKT] = ..ADDRESS;
	    END
	ELSE
	    BEGIN
	    CH$MOVE (RAB$S_RFA, .ADDRESS, RAB[RAB$W_RFA]);
	    RAB[RAB$B_RAC] = RAB$C_RFA;
	    STATUS = $FIND (RAB = .RAB);
	    IF NOT .STATUS
	    THEN
		BEGIN
		FILE_ERROR (BACKUP$_POSERROR, .RWSV_SAVE_FAB,
			.RAB[RAB$L_STS], .RAB[RAB$L_STV]);
		RETURN (READ_SEQ_BLOCK (FALSE));
		END;
	    RAB[RAB$B_RAC] = RAB$C_SEQ;
	    END;
	END;

    BCB = READ_SEQ_BLOCK (FALSE);
    BUFFER = .BCB[BCB_BUFFER];
    TM_COUNT = 0;
    IF .PREV_SEQ EQL .BUFFER[BBH$L_NUMBER]
    THEN BLOCK_COUNT = .BLOCK_COUNT + 1
    ELSE BLOCK_COUNT = .BUFFER[BBH$L_NUMBER] - .BLOCK_NEEDED - 1;
    PREV_SEQ = .BUFFER[BBH$L_NUMBER];

    IF .BUFFER[BBH$L_NUMBER] LEQU .BLOCK_NEEDED
    OR .QUAL[QUAL_SS_FILE]
    OR NOT .BBLOCK [RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_SQD]
    OR .BOT
    THEN EXITLOOP;
    FREE_BUFFER (.BCB);
    END;

! We may have spaced to before the block needed. If so, read forward
! until we get there. If it is really bad, we could skip the one we want
! and end up farther ahead. C'est la vie.
!

RWSV_IN_SEQ = .BLOCK_NEEDED;
IF .BUFFER[BBH$L_NUMBER] LSSU .BLOCK_NEEDED
THEN
    BEGIN
    FREE_BUFFER (.BCB);
    BCB = READ_SEQ_BLOCK (TRUE);
    END;

.BCB
END;					! End of routine REPOSITION

ROUTINE XORCIZE (BLOCK_NEEDED, CUR_BCB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine applies XOR recovery to recover the indicated
!	lost block. This is done by backspacing to the start of the
!	current group and XORing all blocks (except the one in question)
!	up through the next XOR block.
!
! CALLING SEQUENCE:
!	XORCIZE (BLOCK_NEEDED, CUR_BCB)
!
! INPUT PARAMETERS:
!	BLOCK_NEEDED: sequence number of block to be recovered
!	CUR_BCB: BCB of block just read
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	BCB of recovered block
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	INSQUE;

MAP
	CUR_BCB		: REF BBLOCK;	! input BCB arg

LOCAL
	RAB		: REF BBLOCK,	! RAB for reading input file
	SAVE_ADDR	: BBLOCK [RAB$S_RFA], ! saved file address
	SAVE_ERRORS,			! save soft error count
	P1,				! XOR buffer pointer
	P2,				! XOR buffer pointer
	BCB		: REF BBLOCK,	! BCB of current buffer
	XOR_BCB		: REF BBLOCK,	! BCB of XOR buffer
	BUFFER		: REF BBLOCK;	! current I/O buffer

EXTERNAL ROUTINE
	FREE_BUFFER;			! free an I/O buffer

! Save the current position if the input is a file or seq disk.
!

SAVE_ERRORS = .RWSV_IN_ERRORS;
IF .RWSV_IN_GROUP_SIZE EQL 0 THEN RETURN .CUR_BCB;
SAVE_ADDR = .CUR_BCB[BCB_BLOCKNUM];
IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    RAB = RWSV_SAVE_FAB[FC_RAB];
    CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], SAVE_ADDR);
    END;

! Special case the situation in which the block lost is the first
! of an XOR group, since no special repositioning is necessary.
!

BUFFER = .CUR_BCB[BCB_BUFFER];
IF .BLOCK_NEEDED EQL .RWSV_IN_XOR_SEQ + 1
THEN
    BEGIN
    RWSV_IN_SEQ = .BLOCK_NEEDED + 1;
    IF .BUFFER[BBH$L_NUMBER] EQL .BLOCK_NEEDED
    THEN
	BEGIN
	FREE_BUFFER (.CUR_BCB);
	BCB = READ_SEQ_BLOCK (TRUE);
	END
    ELSE IF .BUFFER[BBH$L_NUMBER] EQL .RWSV_IN_SEQ
    THEN BCB = .CUR_BCB
    ELSE RETURN .CUR_BCB;
    END

ELSE
    BCB = REPOSITION (.RWSV_IN_XOR_SEQ + 1, RWSV_IN_XOR_RFA, .CUR_BCB);
BUFFER = .BCB[BCB_BUFFER];

! Accumulate the blocks in an XOR buffer, skipping the one we are
! after. Note that we allow for a group size one larger than specified,
! to accomodate some boundary conditions on sequential disk.
! Temporarily decrement the buffer count to account for the XOR buffer
! we are sitting on, to prevent the read-ahead from eating too many buffers.
!

COM_BUFF_COUNT = .COM_BUFF_COUNT - 1;
XOR_BCB = 0;
IF (
DECR J FROM MINU (.RWSV_IN_GROUP_SIZE+1, 100) TO 1
DO
    BEGIN
    IF .XOR_BCB NEQ 0
    THEN
	BEGIN
	BCB = READ_SEQ_BLOCK (TRUE);
	BUFFER = .BCB[BCB_BUFFER];
	END;

    IF NOT .BCB[BCB_STATUS]
    OR .BUFFER[BBH$L_NUMBER] GTRU .RWSV_IN_SEQ
    THEN EXITLOOP -1;

    IF .XOR_BCB EQL 0
    THEN
	XOR_BCB = .BCB
    ELSE
	BEGIN
	P1 = .BUFFER + BBH$K_COMMON;
	P2 = .XOR_BCB[BCB_BUFFER] + BBH$K_COMMON;
	DECR J FROM (.BCB[BCB_SIZE]-BBH$K_COMMON)/16 TO 1
	DO
	    BEGIN
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    .P2 = ..P2 XOR ..P1;
	    P1 = .P1 + 4;
	    P2 = .P2 + 4;
	    END;
	END;

    RWSV_IN_SEQ = .BUFFER[BBH$L_NUMBER] + 1;
    IF .RWSV_IN_SEQ EQL .BLOCK_NEEDED
    THEN RWSV_IN_SEQ = .RWSV_IN_SEQ + 1;
    IF .BUFFER[BBH$W_APPLIC] EQL BACKUP$K_XORBLOCK
    THEN EXITLOOP 0;
    IF .BCB NEQ .XOR_BCB THEN FREE_BUFFER (.BCB);
    END
)

! If XOR recovery was not successful, reposition to the desired block
! and return it.
!

THEN
    BEGIN
    IF .XOR_BCB NEQ 0
    THEN FREE_BUFFER (.XOR_BCB);
    BCB =  REPOSITION (.BLOCK_NEEDED, SAVE_ADDR, .BCB);
    RWSV_IN_ERRORS = .SAVE_ERRORS;
    COM_BUFF_COUNT = .COM_BUFF_COUNT + 1;
    .BCB
    END

! If XOR recovery was successful, reposition to the block following
! the one recovered, and link it into the FRONT of the input wait
! list, so it will be read next. Return the recovered block.
!

ELSE
    BEGIN
    IF .BUFFER[BBH$L_NUMBER] NEQ .BLOCK_NEEDED + 1
    THEN BCB = REPOSITION (.BLOCK_NEEDED + 1, SAVE_ADDR, .BCB);
    RWSV_IN_SEQ = .BLOCK_NEEDED;
    IF .BCB NEQ .XOR_BCB
    THEN
	BEGIN
	BCB[BCB_STATE] = BCB_S_READ;
	INSQUE (.BCB, INPUT_WAIT[0]);
	END;
    RWSV_IN_ERRORS = .SAVE_ERRORS - 1;
    RWSV_IN_XORUSE = .RWSV_IN_XORUSE + 1;
    COM_BUFF_COUNT = .COM_BUFF_COUNT + 1;
    BUFFER = .XOR_BCB[BCB_BUFFER];
    BUFFER[BBH$W_APPLIC] = BACKUP$K_DATABLOCK;
    BUFFER[BBH$L_NUMBER] = .BLOCK_NEEDED;
    .XOR_BCB
    END

END;					! End of routine XORCIZE

ROUTINE MATCH_SSNAME (LABEL_BUFFER) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines whether the specified tape header label
!	matches the save set file name in COM_SSNAME.
!
! CALLING SEQUENCE:
!	MATCH_SSNAME (LABEL_BUFFER)
!
! INPUT PARAMETERS:
!	LABEL_BUFFER: buffer containing tape header label
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	TRUE if label matches
!	FALSE if not
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP

LABEL_BUFFER	: REF BBLOCK;		! buffer containing tape label

! The specified file name matches (1) if it is null or (2) if it matches
! exactly or (3) if the specified file name has a trailing dot and the tape
! file name has a null type (with no dot).
!

IF
    .COM_SSNAME[DSC$W_LENGTH] EQL 0
OR
    (.COM_SSNAME[DSC$W_LENGTH] EQL 1
     AND .VECTOR[.COM_SSNAME[DSC$A_POINTER], 0; ,BYTE] EQL '.')
OR
    CH$EQL (.COM_SSNAME[DSC$W_LENGTH],
	    .COM_SSNAME[DSC$A_POINTER],
	    HD1$S_FILEID,
	    LABEL_BUFFER[HD1$T_FILEID],
	    ' '
	    )
OR (
	.VECTOR[.COM_SSNAME[DSC$A_POINTER], .COM_SSNAME[DSC$W_LENGTH]-1; ,BYTE] EQL '.'
    AND
    CH$EQL (.COM_SSNAME[DSC$W_LENGTH]-1,
	    .COM_SSNAME[DSC$A_POINTER],
	    HD1$S_FILEID,
	    LABEL_BUFFER[HD1$T_FILEID],
	    ' '
	    )
    )
THEN TRUE
ELSE FALSE

END;					! End of routine MATCH_SSNAME

ROUTINE INIT_SAVE_DISK (CONTINUE, FILE_ID) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine opens the save set file on an offline save
!	set disk.
!
! CALLING SEQUENCE:
!	INIT_SAVE_DISK (CONTINUE)
!
! INPUT PARAMETERS:
!	CONTINUE: TRUE to open next file segment
!		  FALSE to indicate normal open
!	FILE_ID: address of file ID if CONTINUE is true
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	ROT;

MAP
	FILE_ID		: REF BBLOCK;	! continuation file ID arg

LOCAL
	FAB		: REF BBLOCK,	! pointer to save set FAB
	NAM		: REF BBLOCK,	! pointer to NAM block
	STATUS,				! general status value
	IO_STATUS	: VECTOR [4, WORD], ! I/O status block
	FIB		: BBLOCK [FIB$C_EXTDATA], ! FIB to access file
	FIB_DESC	: VECTOR [2],	! descriptor for above
	RECATTR		: BBLOCK [FAT$C_LENGTH], ! record attributes buffer
	SEG_NUMBER	: WORD,		! file segment number
	ATT_CONTROL	: BBLOCK [20];	! attribute control list

BIND
	ATT_CONTROL0	= ATT_CONTROL+00 : BBLOCK,
	ATT_CONTROL1	= ATT_CONTROL+08 : BBLOCK,
	ATTR_END	= ATT_CONTROL+16;

EXTERNAL ROUTINE
	READY_DISK,			! ready disk for input
	INIT_DIR_SCAN,			! initialize directory scan
	FIND_NEXT,			! find a file
	FREE_DIR_DATA,			! clean up file scan context
	FILE_ERROR;			! signal file related error


! Set up the input disk.
!

FAB = .RWSV_SAVE_FAB;
FAB[FAB$L_STS] = 1;
FAB[FAB$L_STV] = STA_IN_CHAN;
NAM = .FAB[FAB$L_NAM];
IF NOT .CONTINUE
THEN
    BEGIN
    READY_DISK (0);

! Use the file scan logic to find the file.
!

    INIT_DIR_SCAN (
	    STA_IN_CHAN,
	    .NAM,
	    BBLOCK [.QUAL[QUAL_INPU_LIST], QUAL_DEV_DESC],
	    BBLOCK [.QUAL[QUAL_INPU_LIST], QUAL_EXP_DESC],
	    FALSE,
	    .INPUT_MTL[MTL_RVN_BASE],
	    0);
    STATUS = FIND_NEXT ();
    IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE, .FAB, SS$_NOSUCHFILE);
    FREE_DIR_DATA ();

! Set up the FIB and issue the QIO to open the file.
!

    CH$FILL (0, FIB$C_EXTDATA, FIB);
    FIB[FIB$W_FID_NUM] = .NAM[NAM$W_FID_NUM];
    FIB[FIB$W_FID_SEQ] = .NAM[NAM$W_FID_SEQ];
    FIB[FIB$W_FID_RVN] = .NAM[NAM$W_FID_RVN];
    END

! A file continuation is simply opened by file ID.
!

ELSE
    BEGIN
    IF .INPUT_MTL[MTL_SEQ_DISK]
    THEN READY_DISK (0);
    CH$FILL (0, FIB$C_EXTDATA, FIB);
    FIB[FIB$W_FID_NUM] = .FILE_ID[FID$W_NUM];
    FIB[FIB$W_FID_SEQ] = .FILE_ID[FID$W_SEQ];
    FIB[FIB$W_FID_RVN] = .FILE_ID[FID$W_RVN];
    FIB[FIB$L_EXVBN] = .RWSV_IN_VBN;
    END;

FIB_DESC[0] = FIB$C_EXTDATA;
FIB_DESC[1] = FIB;

ATT_CONTROL0[ATR$W_SIZE] = ATR$S_RECATTR;
ATT_CONTROL0[ATR$W_TYPE] = ATR$C_RECATTR;
ATT_CONTROL0[ATR$L_ADDR] = RECATTR;
ATT_CONTROL1[ATR$W_SIZE] = ATR$S_SEGNUM;
ATT_CONTROL1[ATR$W_TYPE] = ATR$C_SEGNUM;
ATT_CONTROL1[ATR$L_ADDR] = SEG_NUMBER;
ATTR_END = 0;

STATUS = S$QIOW (CHAN = STA_IN_CHAN,
		 IOSB = IO_STATUS,
		 FUNC = IO$_ACCESS OR IO$M_ACCESS,
		 P1   = FIB_DESC,
		 P5   = ATT_CONTROL
		 );
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE, .FAB, .STATUS);

! Validate attributes of the save set file.
!

IF .RECATTR[FAT$B_RTYPE] NEQ FAT$C_FIXED
OR .RECATTR[FAT$B_RATTRIB] NEQ 0
OR .(RECATTR[FAT$W_RSIZE])<0,9> NEQ 0
OR .RECATTR[FAT$W_RSIZE] LSSU 2048
THEN FILE_ERROR (BACKUP$_NOTSAVESET, .FAB);

IF NOT .CONTINUE
THEN
    BEGIN
    IF .SEG_NUMBER NEQ 0
    THEN
	IF .QUAL[QUAL_IMAG]
	THEN FILE_ERROR (BACKUP$_NOT1STVOL+STS$K_SEVERE, .FAB)
	ELSE FILE_ERROR (BACKUP$_NOT1STVOL, .FAB);
    QUAL[QUAL_BLOC_VALUE] = .RECATTR[FAT$W_RSIZE];
    RWSV_EOF = ROT (.RECATTR[FAT$L_EFBLK], 16);
    IF .RECATTR[FAT$W_FFBYTE] EQL 0
    THEN RWSV_EOF = .RWSV_EOF - 1;
    RWSV_VOL_NUMBER = .FIB[FIB$B_FID_RVN];
    RWSV_SEG_NUMBER = .SEG_NUMBER;
    END

ELSE
    BEGIN
    IF .SEG_NUMBER NEQ .RWSV_SEG_NUMBER
    THEN FILE_ERROR (BACKUP$_WRONGVOL, .FAB);
    IF .RECATTR[FAT$W_RSIZE] NEQ .QUAL[QUAL_BLOC_VALUE]
    THEN FILE_ERROR (BACKUP$_BADBLKSIZE, .FAB);
    END;

END;					! End of routine INIT_SAVE_DISK

ROUTINE INIT_SAVE_TAPE (VERIFY) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets up the input tape for reading.
!
! CALLING SEQUENCE:
!	INIT_SAVE_TAPE (VERIFY)
!
! INPUT PARAMETERS:
!	VERIFY: TRUE to indicate setup for verify pass
!		FALSE to indicate normal initialization
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	FAB		: REF BBLOCK,	! pointer to input FAB
	STATUS,				! the usual status value
	FILE_SECTION,			! file section number
	TAPE_CHAR	: BBLOCK [4],	! magtape device characteristics
	LABEL_BUFFER	: BBLOCK [80],	! buffer for tape labels
	IO_STATUS	: VECTOR [4,WORD]; ! I/O status block

EXTERNAL ROUTINE
	FILE_ERROR,			! signal file related error
	READY_TAPE,			! prepare tape for I/O
	REWIND,				! rewind tape
	SKIP_TM,			! skip tape marks
	READ_LABEL,			! read and check tape label
	LIB$CVT_DTB	: ADDRESSING_MODE (GENERAL);
					! convert decimal to binary

! Set up the input tape. Rewind it if called for; if we are setting up a
! small save set written /NOREWIND for verify, backspace over it rather
! than rewinding to save time.
!

FAB = .RWSV_SAVE_FAB;
TAPE_CHAR = READY_TAPE (FALSE);
IF .QUAL[QUAL_REWI]
THEN
    BEGIN
    REWIND ();
    TAPE_CHAR[MT$V_BOT] = TRUE;
    END

ELSE IF .VERIFY 
THEN
    BEGIN
    IF .RWSV_OUT_BLOCK_COUNT LSSU 1000
    THEN
	SKIP_TM (-2)

    ELSE
	BEGIN
	REWIND ();
	TAPE_CHAR[MT$V_BOT] = TRUE;
	END;
    END;

! If the tape is at BOT, read and verify the volume header label.
!

IF .TAPE_CHAR[MT$V_BOT]
THEN
    BEGIN
    STATUS = READ_LABEL (LABEL_BUFFER, 'VOL1');
    IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);

    WHILE TRUE
    DO
	BEGIN
	STATUS = READ_LABEL (LABEL_BUFFER);
	IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);
	IF .LABEL_BUFFER[HD1$L_HD1LID] EQL 'HDR1' THEN EXITLOOP;
	END;
    END;

! Search for a HDR1 record that matches the desired save set name.
!

IF NOT .TAPE_CHAR[MT$V_BOT]
OR NOT MATCH_SSNAME (LABEL_BUFFER)
THEN
    BEGIN
    WHILE TRUE
    DO
	BEGIN
	STATUS = SKIP_TM (1);
	IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);

	STATUS = READ_LABEL (LABEL_BUFFER, 'HDR1');
	IF .STATUS
	AND MATCH_SSNAME (LABEL_BUFFER)
	THEN EXITLOOP;

	IF .STATUS EQL SS$_ENDOFVOLUME
	THEN
	    BEGIN
	    SKIP_TM (-2);
	    FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE,
			.FAB, SS$_NOSUCHFILE);
	    END;
	END;
    END;

! Check other HDR1 fields.
!

CH$MOVE (HD1$S_FILESETID, LABEL_BUFFER[HD1$T_FILESETID], RWSV_FILESET_ID);
IF NOT LIB$CVT_DTB (4, LABEL_BUFFER[HD1$T_FILESEQNO], RWSV_FILE_NUMBER)
THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
IF NOT LIB$CVT_DTB (4, LABEL_BUFFER[HD1$T_FILESECNO], FILE_SECTION)
THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
IF .FILE_SECTION NEQ 1
THEN
    BEGIN
    IF .QUAL[QUAL_IMAG]
    THEN FILE_ERROR ((BACKUP$_NOT1STVOL AND NOT $FIELDMASK (STS$V_SEVERITY)) + STS$K_SEVERE, .FAB)
    ELSE FILE_ERROR (BACKUP$_NOT1STVOL, .FAB);
    END;
RWSV_VOL_NUMBER = .FILE_SECTION;

! Read and check HDR2.
!

STATUS = READ_LABEL (LABEL_BUFFER, 'HDR2');
IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);
IF .LABEL_BUFFER[HD2$B_RECFORMAT] NEQ 'F'
OR CH$NEQ (HD2$S_RECLEN, LABEL_BUFFER[HD2$T_RECLEN],
	   HD2$S_BLOCKLEN, LABEL_BUFFER[HD2$T_BLOCKLEN])
THEN FILE_ERROR (BACKUP$_NOTSAVESET, .FAB);
IF NOT LIB$CVT_DTB (HD2$S_RECLEN, LABEL_BUFFER[HD2$T_RECLEN], QUAL[QUAL_BLOC_VALUE])
THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
IF .QUAL[QUAL_BLOC_VALUE] LSSU 2048
OR .QUAL[QUAL_BLOC_VALUE] GEQU 65536
THEN FILE_ERROR (BACKUP$_NOTSAVESET, .FAB);

! Skip to start of the data records.
!

SKIP_TM (1);

END;					! End of routine INIT_SAVE_TAPE

GLOBAL ROUTINE INIT_IN_SAVE (VERIFY) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initializes the input save set.
!
! CALLING SEQUENCE:
!	INIT_IN_SAVE (VERIFY)
!
! INPUT PARAMETERS:
!	VERIFY: TRUE to indicate setup for verify pass
!		FALSE to indicate normal initialization
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	FAB		: REF BBLOCK,	! pointer to input FAB
	RAB		: REF BBLOCK,	! pointer to input RAB
	STATUS;				! the usual status value

EXTERNAL ROUTINE
	FILE_ERROR,			! signal file related error
	INIT_BUFFERS,			! initialize the buffer pool
	EXTRACT_FILENAME;		! extract file name, type, and version

RWSV_IN_ERRORS = 0;
RWSV_IN_XORUSE = 0;
RWSV_IN_SEQ = 1;
RWSV_IN_SEQ_0 = 1;
RWSV_IN_XOR_RFA = 1;
RWSV_IN_VBN = 1;
RWSV_IN_VBN_0 = 1;

IF NOT .VERIFY
THEN
    BEGIN
    RWSV_VOL_NUMBER = 1;
    RWSV_SEG_NUMBER = 0;

! Do a UFO open on the input FAB and save away the channel.
!

    RWSV_SAVE_QUAL = .QUAL[QUAL_INPU_LIST];
    RWSV_SAVE_FAB = FAB = .RWSV_SAVE_QUAL[QUAL_PARA_FC];
    FAB[FAB$V_NAM] = TRUE;
    IF .QUAL[QUAL_SS_FILE]
    THEN
	BEGIN
	IF .BBLOCK[FAB[FAB$L_DEV], DEV$V_NET]
	THEN
	    FAB[FAB$V_BIO] = FAB[FAB$V_SQO] = TRUE;

	FAB[FAB$V_GET] = TRUE;
	END
    ELSE
	FAB[FAB$V_UFO] = TRUE;

    IF .QUAL[QUAL_SS_FILE]
    OR .BBLOCK[FAB[FAB$L_DEV], DEV$V_SQD]
    THEN
	BEGIN
	STATUS = $OPEN (FAB = .FAB);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE, .FAB,
			 .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
	END
    ELSE
	BEGIN
	INIT_SAVE_DISK (0);
	END;

    IF .QUAL[QUAL_SS_FILE]
    THEN
	BEGIN
	RAB = FAB[FC_RAB];
	STATUS = $CONNECT (RAB = .RAB);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE, .FAB,
			 .RAB[RAB$L_STS], .RAB[RAB$L_STV]);
	IF .FAB[FAB$B_RFM] NEQ FAB$C_FIX
	OR .FAB[FAB$B_ORG] NEQ FAB$C_SEQ
	OR .BBLOCK[FAB[FAB$L_DEV], DEV$V_NET] AND .(FAB[FAB$W_MRS])<0,9> NEQ 0
	THEN FILE_ERROR (BACKUP$_NOTSAVESET, .FAB);
	QUAL[QUAL_BLOC_VALUE] = .FAB[FAB$W_MRS];
	CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], RWSV_IN_XOR_RFA);
	END
    ELSE
	RWSV_CHAN = .FAB[FAB$L_STV];

    EXTRACT_FILENAME (.FAB, COM_SSNAME);
    END

! Otherwise do setup for input verification.
!

ELSE
    BEGIN
    FAB = .RWSV_SAVE_FAB;
    RAB = FAB[FC_RAB];
    IF .QUAL[QUAL_SS_FILE]
    THEN
	BEGIN
	STATUS = $REWIND (RAB = .RAB);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE, .FAB,
			 .RAB[RAB$L_STS], .RAB[RAB$L_STV]);
	CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], RWSV_IN_XOR_RFA);
	END;
    END;
ALT_SSNAME[0] = 0;

! Set up the input tape.
!

IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
AND NOT .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    INIT_SAVE_TAPE (.VERIFY);
    END;

! Set up the buffer pool.
!

IF NOT .VERIFY
THEN
    BEGIN
    INIT_BUFFERS (.QUAL[QUAL_BUFF_VALUE], .QUAL[QUAL_BLOC_VALUE]);
    RWSV_IN_GROUP_SIZE = 1^31-1;
    END;

END;					! End of routine INIT_IN_SAVE

GLOBAL ROUTINE READ_BUFFER =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a corrected buffer from the input save
!	set, applying XOR recovery if necessary.
!
! CALLING SEQUENCE:
!	READ_BUFFER ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	BCB address of buffer read
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	K,				! count of blocks missed
	RAB		: REF BBLOCK,	! RAB to read input file
	BCB		: REF BBLOCK,	! BCB of block read
	BUFFER		: REF BBLOCK;	! data buffer read

EXTERNAL ROUTINE
	FILE_ERROR,			! signal file related error
	FREE_BUFFER;			! release buffer to free list

! Loop, reading buffers until we get an acceptable data block. Others
! are treated appropriately.
!

IF .RWSV_XORSIZE NEQ 0 THEN RWSV_IN_GROUP_SIZE = .RWSV_XORSIZE;
WHILE TRUE
DO
    BEGIN
    RWSV_IN_ORGERR[0] = TRUE;
    RWSV_IN_ORGERR[1] = 0;
    BCB = READ_SEQ_BLOCK (TRUE);
    IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
    THEN
	BEGIN
	BCB = NEXT_VOLUME (.BCB);
	IF .BCB EQL 0
	THEN RETURN 0;
	END;

    IF .(RWSV_IN_XOR_RFA)<0,32> EQL 0
    AND .(RWSV_IN_XOR_RFA+4)<0,16> EQL 0
    THEN
	BEGIN
	RAB = RWSV_SAVE_FAB[FC_RAB];
	CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], RWSV_IN_XOR_RFA);
	END;
    BUFFER = .BCB[BCB_BUFFER];

! Check if a block has been skipped. If exactly one has, then apply XOR
! recovery to get it back. If recovery fails, report the error unless the
! missed block was an XOR block. We do not count or report block skip
! errors if we're trying to read the first save set block, and there was
! no I/O error; this is the condition of being handed a continuation
! volume to start with.
!

    IF .BUFFER[BBH$L_NUMBER] - .RWSV_IN_SEQ EQL 1
    AND (.RWSV_IN_SEQ NEQ .RWSV_IN_XOR_SEQ + .RWSV_IN_GROUP_SIZE + 1
	 OR .BUFFER[BBH$W_APPLIC] EQL BACKUP$K_XORBLOCK)
    AND (.RWSV_IN_SEQ NEQ 1 OR NOT .RWSV_IN_ORGERR[0])
    THEN
	BEGIN
	BCB = XORCIZE (.RWSV_IN_SEQ, .BCB);
	BUFFER = .BCB[BCB_BUFFER];
	END;

    K = .BUFFER[BBH$L_NUMBER] - .RWSV_IN_SEQ;
    IF .K NEQ 0
    THEN
	BEGIN
	IF (.RWSV_IN_SEQ NEQ 1 OR NOT .RWSV_IN_ORGERR[0])
	THEN
	    BEGIN
	    IF (.RWSV_IN_SEQ NEQ .RWSV_IN_XOR_SEQ + .RWSV_IN_GROUP_SIZE
		OR .K NEQ 1)
	    THEN
		BEGIN
		FILE_ERROR (BACKUP$_BLOCKLOST, .RWSV_SAVE_FAB,
			    .RWSV_IN_ORGERR[0], .RWSV_IN_ORGERR[1]);
		RWSV_IN_ERRORS = .RWSV_IN_ERRORS - 1;
		END;
	    END
	ELSE
	    RWSV_IN_ERRORS = .RWSV_IN_ERRORS - 1;
	IF .RWSV_IN_GROUP_SIZE NEQ 0
	THEN
	    BEGIN
	    IF .BUFFER[BBH$L_NUMBER] GEQU .RWSV_IN_XOR_SEQ + .RWSV_IN_GROUP_SIZE
	    THEN RWSV_IN_XOR_SEQ = .RWSV_IN_XOR_SEQ
				+ (.BUFFER[BBH$L_NUMBER] - .RWSV_IN_XOR_SEQ)
				/ .RWSV_IN_GROUP_SIZE * .RWSV_IN_GROUP_SIZE;
	    END;
	END;

! Do basic validation checks to make sure we can understand this block.
! Note that this is done even if the block reads with an error, since
! the header data is protected by the header CRC.
!

    IF .BUFFER[BBH$W_SIZE] LSSU BBH$K_LENGTH
    THEN SIGNAL (BACKUP$_INVBLKHDR)

! Process the data block. If there has been a read error, attempt to
! recover it. If the error persists, report it.
!

    ELSE
	BEGIN
	IF .BUFFER[BBH$W_APPLIC] EQL BACKUP$K_DATABLOCK
	THEN
	    BEGIN
	    IF .BUFFER[BBH$W_STRUCLEV] NEQ BBH$K_LEVEL1
	    THEN SIGNAL (BACKUP$_INVSTRUCT)
	    ELSE
		BEGIN
		IF NOT .BCB[BCB_STATUS]
		THEN
		    BEGIN
		    BCB = XORCIZE (.RWSV_IN_SEQ, .BCB);
		    BUFFER = .BCB[BCB_BUFFER];
		    END;

		IF NOT .BCB[BCB_STATUS]
		THEN
		    BEGIN
		    FILE_ERROR (BACKUP$_READERR+STS$K_ERROR,
				.RWSV_SAVE_FAB, .RWSV_IN_ORGERR[0], .RWSV_IN_ORGERR[1]);
		    RWSV_IN_ERRORS = .RWSV_IN_ERRORS - 1;
		    END;

! Check that the save set name in the block header matches the labels.
! A mismatch indicates running off the end of an incomplete tape.
! If we are instructed to continue, use the new save set name.
!

		IF CH$NEQ (.ALT_SSNAME[0]+1, ALT_SSNAME,
			   .(BUFFER[BBH$T_SSNAME])<0,8>+1, BUFFER[BBH$T_SSNAME], 255)
		THEN
		    BEGIN
		    IF .ALT_SSNAME[0] NEQ 0
		    THEN FILE_ERROR (BACKUP$_SSCHANGE, .RWSV_SAVE_FAB);
		    CH$COPY (.(BUFFER[BBH$T_SSNAME])<0,8>+1, BUFFER[BBH$T_SSNAME],
			     0, BBH$S_SSNAME, ALT_SSNAME);
		    END;
	
		IF .BUFFER[BBH$L_BLOCKSIZE] NEQ .BCB[BCB_SIZE]
		THEN SIGNAL (BACKUP$_INVBLKSIZE);
		RWSV_IN_SEQ = .BUFFER[BBH$L_NUMBER] + 1;
		EXITLOOP;
		END;
	    END;

! If the buffer contains an XOR block, note its sequence number.
!

	IF .BUFFER[BBH$W_APPLIC] EQL BACKUP$K_XORBLOCK
	THEN
	    BEGIN
	    RWSV_IN_XOR_SEQ = .BUFFER[BBH$L_NUMBER];
	    RWSV_IN_XOR_RFA = .BCB[BCB_BLOCKNUM];
	    IF .QUAL[QUAL_SS_FILE]
	    THEN
		BEGIN
		RAB = RWSV_SAVE_FAB[FC_RAB];
		CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], RWSV_IN_XOR_RFA);
		END;
	    END;

	END;				! end of major buffer valid condition

    RWSV_IN_SEQ = .BUFFER[BBH$L_NUMBER] + 1;
    FREE_BUFFER (.BCB);
    END;

.BCB
END;					! End of routine READ_BUFFER

GLOBAL ROUTINE FIN_IN_SAVE (CONTINUE) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine completes the reading of the input save set.
!
! CALLING SEQUENCE:
!	FIN_IN_SAVE (CONTINUE)
!
! INPUT PARAMETERS:
!	CONTINUE: TRUE if there is a continuation tape
!		  FALSE if this is the last reel
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	REMQUE;

LOCAL
	STATUS,				! general status value
	TM_COUNT,			! count of tape marks crossed
	BCB		: REF BBLOCK,	! pointer to current BCB
	FAB		: REF BBLOCK;	! input FAB

EXTERNAL ROUTINE
	WAIT,				! wait for I/O completion
	FREE_BUFFER,			! free an I/O buffer
	SKIP_TM,			! skip tape marks
	UNLOAD,				! rewind and unload tape
	STA_DISMOUNT,			! dismount save set disk
	RESTORE_VERIFY_REEL,		! verify input save set volume
	FILE_ERROR;			! signal file related error

! If the input is a file, close it.
!

FAB = .RWSV_SAVE_FAB;
IF .QUAL[QUAL_SS_FILE]
THEN
    BEGIN
    IF NOT .QUAL[QUAL_VERI]
    OR .COM_FLAGS[COM_VERIFYING]
    THEN
	BEGIN
	STATUS = $CLOSE (FAB = .FAB);
	IF NOT .STATUS
	THEN FILE_ERROR (BACKUP$_CLOSEIN+STS$K_ERROR, .FAB,
			 .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
	END;
    END

! For a tape, wait out the pending read aheads, and backspace the tape
! over the trailer label set so that appending won't get lost.
!

ELSE
    BEGIN
    IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
    THEN
	BEGIN
	TM_COUNT = 1;
	UNTIL REMQUE (.INPUT_WAIT[0], BCB)
	DO
	    BEGIN
	    WAIT (.BCB);
	    FREE_BUFFER (.BCB);
	    IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFFILE
	    THEN TM_COUNT = .TM_COUNT + 1;
	    END;

	SKIP_TM (-.TM_COUNT);

	IF NOT .QUAL[QUAL_VERI]
	OR .COM_FLAGS[COM_VERIFYING]
	THEN
	    BEGIN
	    IF .CONTINUE
	    THEN UNLOAD ();

	    $DASSGN (CHAN = .RWSV_CHAN);
	    RWSV_CHAN = 0;
	    END;
	END

! For a save set disk, wait out any pending reads. Then deaccess the file
! and dismount the volume.
!

    ELSE
	BEGIN
	UNTIL REMQUE (.INPUT_WAIT[0], BCB)
	DO
	    BEGIN
	    WAIT (.BCB);
	    FREE_BUFFER (.BCB);
	    END;

	IF NOT .QUAL[QUAL_VERI]
	OR .COM_FLAGS[COM_VERIFYING]
	THEN
	    BEGIN
	    S$QIOW (CHAN = .RWSV_CHAN,
		    FUNC = IO$_DEACCESS
		    );
	    IF .CURRENT_MTL[MTL_SEQ_DISK]
	    THEN
		BEGIN
		STA_DISMOUNT (.RWSV_VOL_NUMBER);
		$QIOW (CHAN = .CURRENT_VCB[VCB_CHAN],
		       FUNC = IO$_UNLOAD
		       );
		END;
	    END;
	END;
    END;

! Inform the user of any input errors that we might have graciously
! recovered.
!

IF .RWSV_IN_ERRORS NEQ 0
THEN FILE_ERROR (BACKUP$_SOFTRERRS, .FAB, .RWSV_IN_ERRORS);
IF .RWSV_IN_XORUSE NEQ 0
THEN FILE_ERROR (BACKUP$_XORERRS, .FAB, .RWSV_IN_XORUSE);


! Run a verify pass if requested (and if this is not already a verify pass).
!

IF NOT .COM_FLAGS[COM_VERIFYING]
THEN
    BEGIN
    IF .QUAL[QUAL_VERI]
    THEN
	BEGIN
	SIGNAL (BACKUP$_STARTVERIFY);
	COM_FLAGS[COM_VERIFYING] = TRUE;
	IF .RWSV_SEG_NUMBER EQL 0
	THEN INIT_IN_SAVE (TRUE)
	ELSE
	    IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
	    THEN READY_NEXT_VOLUME ();
	RWSV_IN_SEQ = .RWSV_IN_SEQ_0;
	RWSV_IN_VBN = .RWSV_IN_VBN_0;
	RWSV_IN_ERRORS = 0;
	RWSV_IN_XORUSE = 0;
	RESTORE_VERIFY_REEL ();
	FIN_IN_SAVE (.CONTINUE);
	COM_FLAGS[COM_VERIFYING] = FALSE;
	END;
    IF .CONTINUE THEN SIGNAL (BACKUP$_RESUME, 1, .RWSV_VOL_NUMBER+1);
    END;

END;					! End of routine FIN_IN_SAVE

ROUTINE NEXTVOL_HANDLER (SIGNAL, MECHANISM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the condition handler for the READY_NEXT_VOLUME
!	routine. It resignals the error with an error status and then
!	returns failure, causing a retry.
!
! CALLING SEQUENCE:
!	NEXTVOL_HANDLER (SIGNAL, MECHANISM)
!
! INPUT PARAMETERS:
!	SIGNAL: signal argument list
!	MECHANISM: mechanism arg list
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	TRUE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

BUILTIN
	CALLG;

MAP
	SIGNAL		: REF BBLOCK,	! signal arg
	MECHANISM	: REF BBLOCK;	! mechanism arg

EXTERNAL ROUTINE
	STA_DISMOUNT,		! dismount volume
	LIB$SIGNAL		: ADDRESSING_MODE (GENERAL);

! Fix up the severity of the error being signalled. Then resignal it
! and unwind.
!

IF .SIGNAL[CHF$L_SIG_NAME] NEQ SS$_UNWIND
AND NOT .SIGNAL[CHF$L_SIG_NAME]
THEN
    BEGIN
    IF NOT .BBLOCK [RWSV_SAVE_FAB[FAB$L_DEV], DEV$V_SQD]
    THEN
	BEGIN
	S$QIOW (CHAN = STA_IN_CHAN,
		FUNC = IO$_DEACCESS
		);
	STA_DISMOUNT (.RWSV_VOL_NUMBER);
	END;
    BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_SEVERITY] = STS$K_ERROR;
    SIGNAL[CHF$L_SIG_ARGS] = .SIGNAL[CHF$L_SIG_ARGS] - 2;
    CALLG (.SIGNAL, LIB$SIGNAL);
    MECHANISM[CHF$L_MCH_SAVR0] = FALSE;
    $UNWIND ();
    END;

SS$_RESIGNAL
END;					! End of routine NEXTVOL_HANDLER

GLOBAL ROUTINE READY_NEXT_VOLUME (FILE_ID) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads and verifies the labels on the candidate
!	continuation volume.
!
! CALLING SEQUENCE:
!	READY_NEXT_VOLUME ()
!
! INPUT PARAMETERS:
!	FILE_ID: address of continuation file ID if disk
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	TRUE if volume is OK
!	FALSE if not; retry requested
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	FILE_ID		: REF BBLOCK;	! file ID arg

LOCAL
	FAB		: REF BBLOCK,	! pointer to input FAB
	STATUS,				! the usual status value
	BUFFER_SIZE,			! size of I/O buffers
	NUMBER,				! output for decimal convert
	LABEL_BUFFER	: BBLOCK [80];	! buffer for tape labels

EXTERNAL ROUTINE
	FILE_ERROR,			! signal file related error
	READY_TAPE,			! prepare tape for I/O
	REWIND,				! rewind tape
	SKIP_TM,			! skip tape marks
	READ_LABEL,			! read and check tape label
	LIB$CVT_DTB	: ADDRESSING_MODE (GENERAL);
					! convert decimal to binary

ENABLE NEXTVOL_HANDLER;
FAB = .RWSV_SAVE_FAB;
RWSV_IN_ERRORS = 0;
RWSV_IN_XORUSE = 0;

! Set up the input tape. Rewind it if called for.
!

IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
THEN
    BEGIN
    READY_TAPE (FALSE);
    REWIND ();

! Read and verify the volume header label. Then scan for HDR1.
!

    STATUS = READ_LABEL (LABEL_BUFFER, 'VOL1');
    IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);

    WHILE TRUE
    DO
	BEGIN
	STATUS = READ_LABEL (LABEL_BUFFER);
	IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);
	IF .LABEL_BUFFER[HD1$L_HD1LID] EQL 'HDR1' THEN EXITLOOP;
	END;

! Check HDR1 for the correct save set name, file set ID, and file
! & section numbers.
!

    IF NOT MATCH_SSNAME (LABEL_BUFFER)

    OR CH$NEQ (HD1$S_FILESETID, LABEL_BUFFER[HD1$T_FILESETID],
	       HD1$S_FILESETID, RWSV_FILESET_ID)

    OR
	BEGIN
	IF NOT LIB$CVT_DTB (4, LABEL_BUFFER[HD1$T_FILESEQNO], NUMBER)
	THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
	.NUMBER NEQ .RWSV_FILE_NUMBER
	END

    OR
	BEGIN
	IF NOT LIB$CVT_DTB (4, LABEL_BUFFER[HD1$T_FILESECNO], NUMBER)
	THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
	.NUMBER NEQ .RWSV_VOL_NUMBER
	END

    THEN FILE_ERROR (BACKUP$_WRONGVOL, .FAB);

! Read and check HDR2.
!

    STATUS = READ_LABEL (LABEL_BUFFER, 'HDR2');
    IF NOT .STATUS THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, .STATUS);
    IF .LABEL_BUFFER[HD2$B_RECFORMAT] NEQ 'F'
    OR CH$NEQ (HD2$S_RECLEN, LABEL_BUFFER[HD2$T_RECLEN],
	       HD2$S_BLOCKLEN, LABEL_BUFFER[HD2$T_BLOCKLEN])
    THEN FILE_ERROR (BACKUP$_NOTSAVESET, .FAB);

    IF NOT LIB$CVT_DTB (HD2$S_RECLEN, LABEL_BUFFER[HD2$T_RECLEN], BUFFER_SIZE)
    THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
    IF .BUFFER_SIZE NEQ .BBLOCK [.FREE_LIST[0], BCB_SIZE]
    THEN FILE_ERROR (BACKUP$_BADBLKSIZE, .FAB);

! Skip to start of the data records.
!

    SKIP_TM (1);
    END

! Sequential disk is all handled by INIT_SAVE_DISK.
!

ELSE
    INIT_SAVE_DISK (1, .FILE_ID);

TRUE
END;					! End of routine READY_NEXT_VOLUME

ROUTINE NEXT_VOLUME (CUR_BCB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is invoked when end of medium is encountered on
!	the input save set. It determines if there is a continuation
!	medium, and if so, readies it for use and returns the first block.
!
! CALLING SEQUENCE:
!	NEXT_VOLUME (CUR_BCB)
!
! INPUT PARAMETERS:
!	CUR_BCB: BCB of last read (containing end of file status)
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	BCB of first block on new volume, or 0 if no more volumes
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	CUR_BCB		: REF BBLOCK;	! BCB input arg

LOCAL
	STATUS,				! the usual status value
	IO_STATUS	: VECTOR [4, WORD], ! I/O status block
	FAB		: REF BBLOCK,	! pointer to input FAB
	BCB		: REF BBLOCK,	! BCB of buffer in use
	BUFFER		: REF BBLOCK,	! current I/O buffer
	NUMBER,				! output for decimal convert
	ATT_CONTROL	: BBLOCK [12],	! attribute control list
	FILE_ID		: BBLOCK [FID$C_LENGTH]; ! extension file ID

EXTERNAL ROUTINE
	FILE_ERROR,			! signal file related error
	UNLOAD,				! rewind and unload tape
	FREE_BUFFER;			! free an I/O buffer


! Discard the BCB that reported the EOF. Return 0 (no continuation) if the
! save set is being handled through the file system.
!

FAB = .RWSV_SAVE_FAB;
RWSV_IN_VBN = .CUR_BCB[BCB_BLOCKNUM];
FREE_BUFFER (.CUR_BCB);

IF .QUAL[QUAL_SS_FILE]
THEN RETURN 0;

! For tape, read the trailer labels and see if a continuation exists.
!

IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
THEN
    BEGIN
    BCB = READ_BLOCK (FALSE, FALSE);
    FREE_BUFFER (.BCB);

    IF NOT .BCB[BCB_IO_STATUS]
    THEN
	BEGIN
	IF .BCB[BCB_IO_STATUS] EQL SS$_ENDOFVOLUME
	THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI)
	ELSE FILE_ERROR (BACKUP$_LABELERR, .FAB, .BCB[BCB_IO_STATUS]);
	END

    ELSE IF .BCB[BCB_IO_BCOUNT] NEQ 80
    THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);

    BUFFER = .BCB[BCB_BUFFER];
    IF .BUFFER[HD1$L_HD1LID] EQL 'EOF1' OR .COM_FLAGS[COM_VERIFYING]
    THEN RETURN 0;
    IF .BUFFER[HD1$L_HD1LID] NEQ 'EOV1'
    THEN FILE_ERROR (BACKUP$_LABELERR, .FAB, BACKUP$_NOTANSI);
    END

! For sequential disk, read the extension file ID and sequence number.
!

ELSE
    BEGIN
    IF .COM_FLAGS[COM_VERIFYING] THEN RETURN 0;
    IF NOT .INPUT_MTL[MTL_SEQ_DISK] THEN RETURN 0;
    ATT_CONTROL[ATR$W_SIZE] = ATR$S_EXTFID;
    ATT_CONTROL[ATR$W_TYPE] = ATR$C_EXTFID;
    ATT_CONTROL[ATR$L_ADDR] = FILE_ID;
    ATT_CONTROL+8 = 0;
    STATUS = S$QIOW (CHAN = .RWSV_CHAN,
		     FUNC = IO$_ACCESS,
		     IOSB = IO_STATUS,
		     P5   = ATT_CONTROL
		     );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS THEN FILE_ERROR (BACKUP$_OPENIN, .FAB, .STATUS);
    IF .FILE_ID[FID$W_NUM] EQL 0
    AND .FILE_ID[FID$W_RVN] EQL 0
    THEN RETURN 0;
    IF .INPUT_MTL[MTL_SEQ_DISK]
    AND .FILE_ID[FID$B_RVN] NEQ .RWSV_VOL_NUMBER + 1
    THEN FILE_ERROR (BACKUP$_INVFILEXT, .FAB);
    END;

! Finish processing of the current volume. Then set up the new input
! volume. Loop until the operator gets it right.
!

FIN_IN_SAVE (TRUE);
RWSV_SEG_NUMBER = .RWSV_SEG_NUMBER + 1;

! Do a UFO open on the input FAB and save away the channel.
!

RWSV_SAVE_QUAL = .RWSV_SAVE_QUAL[QUAL_NEXT];
IF .RWSV_SAVE_QUAL EQL 0 THEN RWSV_SAVE_QUAL = .QUAL[QUAL_INPU_LIST];
RWSV_SAVE_FAB = FAB = .RWSV_SAVE_QUAL[QUAL_PARA_FC];

IF .BBLOCK [FAB[FAB$L_DEV], DEV$V_SQD]
THEN
    BEGIN
    RWSV_VOL_NUMBER = .RWSV_VOL_NUMBER + 1;
    FAB[FAB$V_NAM] = TRUE;
    FAB[FAB$V_UFO] = TRUE;
    STATUS = $OPEN (FAB = .FAB);
    IF NOT .STATUS
    THEN FILE_ERROR (BACKUP$_OPENIN+STS$K_SEVERE, .FAB,
		     .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
    RWSV_CHAN = .FAB[FAB$L_STV];

    UNTIL READY_NEXT_VOLUME ()
    DO UNLOAD ();
    END

ELSE
    BEGIN
    RWSV_VOL_NUMBER = .FILE_ID[FID$B_RVN];
    UNTIL READY_NEXT_VOLUME (FILE_ID)
    DO
	BEGIN
	IF NOT .INPUT_MTL[MTL_SEQ_DISK]
	THEN FILE_ERROR (BACKUP$_READERR+STS$K_SEVERE, .FAB);
	$QIOW (CHAN = .CURRENT_VCB[VCB_CHAN],
	       FUNC = IO$_UNLOAD
	       );
	END;
    END;

! Read the first block from the input volume.
!

RWSV_IN_SEQ_0 = .RWSV_IN_SEQ;
RWSV_IN_VBN_0 = .RWSV_IN_VBN;
READ_SEQ_BLOCK (TRUE)

END;					! End of routine NEXT_VOLUME

END
ELUDOM
