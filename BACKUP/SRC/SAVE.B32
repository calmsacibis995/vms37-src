MODULE SAVE	(%TITLE	'Save Files-11 media'
		IDENT = 'V03-003'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!	This module contains the routines that save Files-11 media on
!	backup media.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 02-Sep-1980
!
! MODIFIED BY:
!
!	V03-003	MLJ45149	Martin L. Jack,	4-Apr-1982  3:02
!		Correct buffer loss in event of input error.
!
!	V03-002	MLJ0083		Martin L. Jack,	22-Mar-1982  13:25
!		Inhibit saving of scanned but not selected directories under
!		/INTERCHANGE, to save space on distribution media.
!
!	V03-001	MLJ0082		Martin L. Jack,	16-Mar-1982  13:26
!		Avoid writing journal records for directory files to save
!		space.  Avoid file selection tests on directories in a save
!		operation to ensure that needed directories are always saved.
!		Add expanded file specification to NOFILES message.  Correct
!		NOFILES testing so that extra directory copying does not
!		inhibit the message.
!
!	V02-013	MLJ0081		Martin L. Jack,	26-Feb-1982  15:37
!		Implement RETAINMIN and RETAINMAX for new home block fields.
!
!	V02-012	MLJ0075		Martin L. Jack,	28-Jan-1982  20:47
!		Use FIB$V_NORECORD.  Add file version limit handling.
!
!	V02-011	MLJ0063		Martin L. Jack,	22-Dec-1981  3:25
!		Correct loop in GET_PLC_INFO.  Modify operation of /RECORD so
!		that backup dates of saved directories are set only if the
!		directory was selected.  Modify operation of /DELETE so that
!		directories are not deleted.
!
!	V02-010	MLJ0062		Martin L. Jack,	3-Dec-1981  12:24
!		Add DIR_STATUS attribute to support /INCREMENTAL.
!
!	V02-009	MLJ0054		Martin L. Jack,	15-Oct-1981  21:35
!		Implement /VOLUME qualifier.  Combine routines
!		ODS1_VOLUME_ATTRIBUTES and ODS2_VOLUME_ATTRIBUTES, and
!		ODS1_FILE_ATTRIBUTES and ODS2_FILE_ATTRIBUTES.  Compute the
!		implicit NOBACKUP mask for every file so that it is effective
!		without /FAST.  Rework placement data generation, move data
!		structure definitions to COMMON.  Implement /DELETE qualifier.
!		Implement network save sets.  Integrate GET_VM and FREE_VM
!		jacket routines.
!
!	V02-008	MLJ0043		Martin L. Jack,	8-Sep-1981  16:58
!		Account for RMS logical device name change.  Install $GETSYI.
!
!	V02-007	MLJ0036		Martin L. Jack,	29-Aug-1981  16:13
!		Extensive rewriting to complete implementation.
!
!	V02-006	MLJ0025		Martin L. Jack,	8-May-1981  14:09
!		Reorganize qualifier database.  Implement latest version
!		selection.  Add action routine to $PUTMSG for standalone.
!		Make /RECORD restartable.
!		
!	V02-005	MLJ0024		Martin L. Jack,	27-Apr-1981  18:02
!		Correct problem with placement attribute length calculation.
!		Remove dynamic LOCAL_SAVE area, since it can now be local.
!
!	V02-004	MLJ0023		Martin L. Jack,	23-Apr-1981  11:40
!		Implement placement attribute.
!
!	V02-003	MLJ0020		Martin L. Jack,	20-Apr-1981  22:00
!		Implement /JOURNAL qualifier.
!
!	V02-002	MLJ0016		Martin L. Jack,	6-Apr-1981  23:31
!		Always use expanded string as related filename since resultant
!		string may contain an incorrect directory.  Correct error
!		message in SAVE_READ.
!
!	V02-001	MLJ0010		Martin L. Jack,	25-Mar-1981  17:18
!		Reorganize global storage.  Changes for standalone operation.
!		Change "slow" file scan to use BACKUP directory scan logic.
!		Implement image restore.  Implement listing concurrent with
!		another operation.  Ensure that QIO service failures are fatal.
!
!**

REQUIRE 'SRC$:COMMON';
LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'LIB$:BACKDEF';


FORWARD ROUTINE
	SAVE_GETBUF:	NOVALUE,	! Get buffer and initialize header
	MAKE_SPACE,			! Allocate space in buffer
	SAVE_WRITE:	NOVALUE,	! Release buffer to output routine
	SAVE_WAIT:	NOVALUE,	! Wait for read
	SAVE_READ:	NOVALUE,	! Start asynchronous read
	SAVE_READAHEAD:	NOVALUE,	! Start read-ahead on half of buffers
	SAVE_BLOCKS_HANDLER,		! Restart after reel change
	SAVE_BLOCKS,			! Driver to save file or volume
	BACKUP_SUMMARY:	NOVALUE,	! Generate backup summary record
	FROM_ODS1_DATE:	NOVALUE,	! Convert ODS-1 date to 64-bit format
	ALLOC_PLC_BLOCK:NOVALUE,	! Allocate placement data block
	ALLOC_VBN_BLOCK:NOVALUE,	! Allocate VBN data block
	FREE_PLC_BLOCKS:NOVALUE,	! Free placement data blocks
	GET_PLC_DATA:	NOVALUE,	! Extract placement data
	DUMP_PLC_DATA:	NOVALUE,	! Dump placement data to record
	FILE_ATTRIBUTES:NOVALUE,	! Generate file attribute record
	VOLUME_ATTRIBUTES:
			NOVALUE,	! Generate volume attribute record
	GEN_FID_RECORD:	NOVALUE,	! Generate file ID record
	PHYSVOL_SUMMARY:NOVALUE,	! Generate physical attribute record
	SAVE_VERIFY_REEL:
			NOVALUE,	! Driver to verify save set
	INIT_ATTR:	NOVALUE,	! Convert header to attributes area
	SELECT_INPUT_FILE,		! Evaluate selection for input file
	POSTPROCESS_FILES:
			NOVALUE,	! Do backup date recording or deletion
	SAVE_FILE_ID:	NOVALUE,	! Save successfully processed file ID
	SAVE_ONE_FILE_HANDLER,		! Recover from BACKUP$_CONTINUE
	SAVE_ONE_FILE:	NOVALUE,	! Driver to save one file
	PHYS_SAVE:	NOVALUE,	! Driver for physical save
	RESTARTABLE_CONDITION,		! Test if condition is restartable
	SAVE_HANDLER,			! Handler for SAVE
	SAVE:		NOVALUE;	! Driver for save


EXTERNAL ROUTINE
	LIB$GET_COMMAND:ADDRESSING_MODE(GENERAL),
					! Get line from SYS$COMMAND
	GET_VM,				! Allocate virtual memory
	FREE_VM:	NOVALUE,	! Free virtual memory
	ASSIGN_INPUT_CHANNEL,		! Assign channel to input device
	CLOSE_RESTORE:	NOVALUE,	! Close output file
	DEBLOCK:	NOVALUE,	! Deblock a save set buffer
	EXTRACT_DIR_FILENAME:
			NOVALUE,	! Extract directory and name
	FAST_FILE_SCAN:	NOVALUE,	! Fast file scanner
	SLOW_FILE_SCAN:	NOVALUE,	! Slow file scanner
	FILE_ERROR:	NOVALUE,	! Signal file-related error
	FIND_BADBLOCK,			! Find an LBN in bad block table
	GET_BADBLOCKS,			! Get bad block data
	INIT_BUFFERS:	NOVALUE,	! Initialize buffer pool
	INIT_RESTORE:	NOVALUE,	! Initialize a restore or compare
	INIT_OUT_SAVE:	NOVALUE,	! Initialize
	REEL_CHECKPOINT:NOVALUE,	! Checkpoint for reel restart
	FIN_OUT_SAVE:	NOVALUE,	! Terminate
	GET_BUFFER,			! Get a buffer
	FREE_BUFFER:	NOVALUE,	! Free a buffer
	WAIT:		NOVALUE,	! Wait for I/O completion
	MATCH,				! Match file specifications
	WRITE_BUFFER:	NOVALUE,	! Write a buffer
	CONCURRENT_LIST:NOVALUE,	! List a buffer
	RESTORE:	NOVALUE,	! Driver for restore module
	RESTORE_ONE_RECORD:
			NOVALUE,	! Restore or compare a buffer
	FIN_RESTORE:	NOVALUE,	! Finish a restore or compare
	WRITE_JOUR_SSNAME:
			NOVALUE WEAK,	! Write journal record for save set
	WRITE_JOUR_VOLUME:
			NOVALUE WEAK,	! Write journal record for volume
	WRITE_JOUR_FILE:NOVALUE WEAK,	! Write journal record for file
	WRITE_JOUR_DIRECTORY:
			NOVALUE WEAK,	! Write final journal record for directory
	PUTMSG_ACTRTN:	WEAK,		! Action routine for standalone $PUTMSG
	GET_RESTART:	NOVALUE;	! Get restart action


EXTERNAL LITERAL
	BACKUP$_FACILITY,
	BACKUP$_OPENIN,
	BACKUP$_OPENOUT,
	BACKUP$_CLOSEIN,
	BACKUP$_ACTIVEBCB,
	BACKUP$_READATTR,
	BACKUP$_READERR,
	BACKUP$_READBLOCK,
	BACKUP$_COPIED,
	BACKUP$_CONTINUE,
	BACKUP$_GETCHN,
	BACKUP$_NOFILES,
	BACKUP$_STARTRECORD,
	BACKUP$_WRITEBACK,
	BACKUP$_STARTDELETE,
	BACKUP$_DELETE,
	BACKUP$_FATALERR,
	BACKUP$_WRITERRS,
	BACKUP$_ACCONFLICT;


G$DEFINE();		! Define global common area


BUILTIN
	TESTBITSC,
	INSQUE,
	REMQUE,
	ROT;

ROUTINE SAVE_GETBUF: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and initializes the file-specific information
!	in a new buffer.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_FAB	- Points to the current input FAB.
!	INPUT_NAM	- Points to the current input NAM block.
!	INPUT_NAMEDESC	- Descriptor for current input file name.
!	INPUT_RECATTR	- Record attributes of current input file.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_BCB	- Points to the new buffer.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	BUFFER:		REF BBLOCK;	! Pointer to buffer


! Get the new buffer.
!
INPUT_BCB = GET_BUFFER();


! Check for end of tape.
!
IF .COM_FLAGS[COM_EOV] AND NOT .INPUT_FLAGS[EOV_IN_PROG]
THEN
    BEGIN
    LOCAL
	TEMP:		REF BBLOCK,	! Temporary pointer to BCB
	FIB:		BBLOCK[10],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


    ! Give back the buffer.  It will be re-acquired later.
    !
    INPUT_FLAGS[EOV_IN_PROG] = TRUE;
    FREE_BUFFER(.INPUT_BCB);
    INPUT_BCB = 0;


    ! Clean out the input wait list.  These reads will be reissued later.  The
    ! first buffer, however, must be written, because it may contain other
    ! information preceding the input buffer.  INPUT_BLOCK will be reset to
    ! point to the first unprocessed block.
    !
    SAVE_WAIT();
    UNTIL REMQUE(.INPUT_WAIT[0], TEMP) DO
	BEGIN
	WAIT(.TEMP);
	INPUT_BLOCK = MINU(.INPUT_BLOCK,
	    .BBLOCK[.TEMP[BCB_RECORD], BRH$L_ADDRESS]);
	FREE_BUFFER(.TEMP);
	END;


    ! Do the physical reel change.
    !
    IF .QUAL[QUAL_JOUR] THEN WRITE_JOUR_VOLUME();
    FIN_OUT_SAVE(TRUE);
    COM_FLAGS[COM_EOV] = FALSE;
    INPUT_FLAGS[EOV_IN_PROG] = FALSE;
    REEL_CHECKPOINT();
    INIT_OUT_SAVE(TRUE);
    IF .QUAL[QUAL_JOUR] THEN WRITE_JOUR_VOLUME();


    ! Write the backup summary record on the new reel.
    !
    BACKUP_SUMMARY();
    SAVE_WRITE();


    ! If there is a reel restart in progress that failed to reposition to
    ! the current file, signal a failure.
    !
    IF TESTBITSC(COM_FLAGS[COM_FAIL_RSTRT])
    THEN
	FILE_ERROR(
	    BACKUP$_CONTINUE,		! See routine SAVE_ONE_FILE_HANDLER
	    .INPUT_FAB,
	    .CHKPT_STATUS);
	

    ! If necessary, re-access the file that was accessed at the end of the
    ! previous reel.
    !
    IF .INPUT_FLAGS[INPUT_OPEN] AND .QUAL[QUAL_VERI]
    THEN
	BEGIN
	FIB[FIB$L_ACCTL] = FIB$M_NOWRITE OR FIB$M_NORECORD;
	IF .INPUT_FLAGS[INPUT_IGNO_INTE] THEN FIB[FIB$L_ACCTL] = FIB$M_NOLOCK OR FIB$M_NORECORD;
	FIB[FIB$W_FID_NUM] = .INPUT_NAM[NAM$W_FID_NUM];
	FIB[FIB$W_FID_SEQ] = .INPUT_NAM[NAM$W_FID_SEQ];
	FIB[FIB$W_FID_RVN] = .INPUT_NAM[NAM$W_FID_RVN];
	FIB_DESC[0] = 10;
	FIB_DESC[1] = FIB;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.INPUT_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_CONTINUE,	! See routine SAVE_ONE_FILE_HANDLER
		.INPUT_FAB,
		.STATUS);
	END;


    IF .INPUT_FLAGS[EOV_SAVING] 
    THEN
	SIGNAL(-1);			! See routine SAVE_BLOCKS_HANDLER


    INPUT_BCB = GET_BUFFER();
    END;


! If a file is currently open, put the file-specific information in the
! buffer header.
!
IF .INPUT_FAB NEQ 0
THEN
    BEGIN
    BUFFER = .INPUT_BCB[BCB_BUFFER];
    BUFFER[BBH$W_FID_NUM] = .INPUT_NAM[NAM$W_FID_NUM];
    BUFFER[BBH$W_FID_SEQ] = .INPUT_NAM[NAM$W_FID_SEQ];
    BUFFER[BBH$W_FID_RVN] = .INPUT_NAM[NAM$W_FID_RVN];
    BUFFER[BBH$W_DID_NUM] = .INPUT_NAM[NAM$W_DID_NUM];
    BUFFER[BBH$W_DID_SEQ] = .INPUT_NAM[NAM$W_DID_SEQ];
    BUFFER[BBH$W_DID_RVN] = .INPUT_NAM[NAM$W_DID_RVN];
    (BUFFER[BBH$T_FILENAME])<0,8> = .INPUT_NAMEDESC[DSC$W_LENGTH];
    CH$MOVE(
	.INPUT_NAMEDESC[DSC$W_LENGTH],
	.INPUT_NAMEDESC[DSC$A_POINTER],
	BUFFER[BBH$T_FILENAME]+1);
    BUFFER[BBH$B_RTYPE] = .INPUT_RECATTR[FAT$B_RTYPE];
    BUFFER[BBH$B_RATTRIB] = .INPUT_RECATTR[FAT$B_RATTRIB];
    BUFFER[BBH$W_RSIZE] = .INPUT_RECATTR[FAT$W_RSIZE];
    BUFFER[BBH$B_BKTSIZE] = .INPUT_RECATTR[FAT$B_BKTSIZE];
    BUFFER[BBH$B_VFCSIZE] = .INPUT_RECATTR[FAT$B_VFCSIZE];
    BUFFER[BBH$W_MAXREC] = .INPUT_RECATTR[FAT$W_MAXREC];
    BUFFER[BBH$L_FILESIZE] = .INPUT_STATBLK[SBK$L_FILESIZE];
    END;
END;

ROUTINE MAKE_SPACE(N)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates space in a save set buffer.
!
! INPUT PARAMETERS:
!	N		- Number of bytes to allocate.
!
! IMPLICIT INPUTS:
!	INPUT_BCB	- Buffer control block for current buffer.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_BCB	- Updated as appropriate.
!
! ROUTINE VALUE:
!	Pointer to the allocated space.
!
! SIDE EFFECTS:
!	If there is insufficient space in the current buffer, it is released to
!	the output procedure and a new buffer allocated.
!
!--

BEGIN
LOCAL
	AREA;			! Pointer to allocated space


IF .INPUT_BCB EQL 0
THEN
    SAVE_GETBUF()
ELSE
    IF
	.INPUT_BCB[BCB_RECORD] + .N GTRU
	.INPUT_BCB[BCB_BUFFER] + .INPUT_BCB[BCB_SIZE]
    THEN
	BEGIN
	!
	! Insufficient space in current buffer.  Write the old buffer, and get
	! another one.
	!
	SAVE_WRITE();
	SAVE_GETBUF();
	END;


! Update the record pointer, and return the address of the record.
!
AREA = .INPUT_BCB[BCB_RECORD];
INPUT_BCB[BCB_RECORD] = .INPUT_BCB[BCB_RECORD] + .N;
.AREA
END;

ROUTINE SAVE_WRITE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine passes the current buffer to the appropriate output
!	procedure.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_BCB	- Pointer to current buffer.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_BCB	- Zeroed to indicate no current buffer.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Buffer passed to output procedure.
!
!--

BEGIN
LOCAL
	BCB:		REF BBLOCK,	! Pointer to BCB
	BUFFER,				! Pointer to buffer
	RECP:		REF BBLOCK;	! Pointer to record


BCB = .INPUT_BCB;
IF .BCB NEQ 0
THEN
    BEGIN

    ! Put in the trailing null record if required.
    !
    BUFFER = .BCB[BCB_BUFFER];
    RECP = .BCB[BCB_RECORD];
    IF .RECP LEQA .BUFFER+.BCB[BCB_SIZE]-BRH$K_LENGTH
    THEN
	BEGIN
	CH$FILL(0, .BUFFER+.BCB[BCB_SIZE]-.RECP, .RECP);
	RECP[BRH$W_RSIZE] = .BUFFER+.BCB[BCB_SIZE]-.RECP-BRH$K_LENGTH;
	RECP[BRH$W_RTYPE] = BRH$K_NULL;
	END;


    ! Indicate no current buffer.
    !
    INPUT_BCB = 0;


    ! Pass the buffer to the output routine.
    !
    IF .QUAL[QUAL_LIST]
	THEN CONCURRENT_LIST(.BCB);
    IF .QUAL[QUAL_OSAV]
	THEN WRITE_BUFFER(.BCB)
	ELSE DEBLOCK(.BCB, RESTORE_ONE_RECORD);
    END;
END;

ROUTINE SAVE_WAIT: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine waits for completion of the first pending read and
!	passes it to the next operation.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	BLOCKS,				! Blocks in current transfer
	TEMP,				! Temporary BCB pointer
	REC:		REF BBLOCK,	! Record header pointer for transfer
	STATUS;				! Status return


UNTIL REMQUE(.INPUT_WAIT[0], INPUT_BCB) DO
    BEGIN
    WAIT(.INPUT_BCB);


    ! Point to the record, and get the number of blocks in the transfer.
    !
    REC = .INPUT_BCB[BCB_RECORD];
    BLOCKS = .REC[BRH$W_RSIZE] / 512;


    IF .INPUT_BCB[BCB_IO_STATUS]
    THEN
	BEGIN
	!
	! Transfer was successful.  Advance the record pointer in the BCB
	! past the transfer.  Unless this is the last transfer, which is
	! the case if it includes the last block to be transferred, the
	! buffer is full and should be passed to the output procedure.  If
	! it is the last transfer, return with the remaining space in the
	! buffer available for further use.
	!
	INPUT_BCB[BCB_RECORD] = .REC + .REC[BRH$W_RSIZE] + BRH$C_LENGTH;
	IF .REC[BRH$L_ADDRESS] + .BLOCKS LEQU .INPUT_MAXBLOCK
	    THEN SAVE_WRITE();
	RETURN;
	END
    ELSE
	BEGIN
	!
	! Transfer was unsuccessful.  Hang onto this buffer, but clear out
	! the remaining entries in the input wait list.  All of these
	! transfers will have to be issued again.
	!
	UNTIL REMQUE(.INPUT_WAIT[0], TEMP) DO
	    BEGIN
	    WAIT(.TEMP);
	    FREE_BUFFER(.TEMP);
	    END;


	! Reset the input block counter to the beginning of the failed
	! transfer.  Redo the transfer one block at a time noting the
	! blocks that fail.
	!
	INPUT_BLOCK = .REC[BRH$L_ADDRESS];
	INCR XBLOCK FROM .INPUT_BLOCK TO .INPUT_BLOCK + .BLOCKS - 1 DO
	    BEGIN
	    REC = MAKE_SPACE(512 + BRH$C_LENGTH);
	    REC[BRH$W_RSIZE] = 512;
	    REC[BRH$W_RTYPE] = .INPUT_RTYPE;
	    REC[BRH$L_FLAGS] = 0;
	    IF .INPUT_FILECHAR[FCH$V_DIRECTORY]
		THEN REC[BRH$V_DIRECTORY] = TRUE;
	    REC[BRH$L_ADDRESS] = .XBLOCK;
	    REC[BRH$L_RESERVED] = 0;
	    STATUS = $QIOW(
		FUNC=.INPUT_FUNC,
		CHAN=.INPUT_CHAN,
		IOSB=INPUT_BCB[BCB_IOSB],
		P1=.REC + BRH$C_LENGTH,
		P2=512,
		P3=.XBLOCK);
	    IF .STATUS THEN STATUS = .INPUT_BCB[BCB_IO_STATUS];
	    IF NOT .STATUS THEN IF NOT FIND_BADBLOCK(.INPUT_BAD, .XBLOCK)
	    THEN
		BEGIN
		FILE_ERROR(
		    BACKUP$_READBLOCK,
		    .INPUT_FAB,
		    .XBLOCK,
		    .STATUS);
		REC[BRH$V_BADDATA] = TRUE;
		END;
	    END;


	! The entire failed transfer has now been redone.  Pass the buffer to
	! the output procedure.
	!
	INPUT_BCB[BCB_RECORD] = .REC + 512 + BRH$C_LENGTH;
	SAVE_WRITE();


	! Advance the input block pointer past this transfer, and restart the
	! readahead.
	!
	INPUT_BLOCK = .INPUT_BLOCK + .BLOCKS;
	IF NOT .INPUT_FLAGS[EOV_IN_PROG] THEN SAVE_READAHEAD();
	END;
    END;
INPUT_BCB = 0;
END;

ROUTINE SAVE_READ: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine gets a buffer if required, formats a data record, and
!	queues it for input.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	BLOCKS,				! Number of blocks to transfer
	REC:		REF BBLOCK,	! Pointer to record
	STATUS;				! Status variable


! Make sure there is something to transfer.  This could fail if, for
! example, read error recovery reissued enough reads to run off the end.
!
IF .INPUT_BLOCK GTRU .INPUT_MAXBLOCK
THEN
    RETURN;


! Find enough space to hold at least one block.  This can fail because there
! is a current input buffer on entry to the routine, but there is not enough
! space in it to hold one block.  If not, release it to the output procedure
! and get another.
!
WHILE TRUE DO
    BEGIN
    IF .INPUT_BCB EQL 0 THEN SAVE_GETBUF();
    BLOCKS = (.INPUT_BCB[BCB_BUFFER] + .INPUT_BCB[BCB_SIZE] -
	      .INPUT_BCB[BCB_RECORD] - BRH$C_LENGTH) / 512;
    IF .BLOCKS GTR 0 THEN EXITLOOP;
    SAVE_WRITE();
    END;


! Limit the transfer size to the number of blocks remaining.
!
IF .BLOCKS GTR .INPUT_MAXBLOCK + 1 - .INPUT_BLOCK
    THEN BLOCKS = .INPUT_MAXBLOCK + 1 - .INPUT_BLOCK;


! Format the record header.
!
REC = .INPUT_BCB[BCB_RECORD];
REC[BRH$W_RSIZE] = .BLOCKS * 512;
REC[BRH$W_RTYPE] = .INPUT_RTYPE;
REC[BRH$L_FLAGS] = 0;
IF .INPUT_FILECHAR[FCH$V_DIRECTORY] THEN REC[BRH$V_DIRECTORY] = TRUE;
REC[BRH$L_ADDRESS] = .INPUT_BLOCK;
REC[BRH$L_RESERVED] = 0;


! Start the read, and make sure it got issued successfully.  Advance the
! input block counter past the transfer.
!
STATUS = $QIO(
    FUNC=.INPUT_FUNC,
    CHAN=.INPUT_CHAN,
    EFN=BCB_S_READ,
    IOSB=INPUT_BCB[BCB_IOSB],
    P1=.REC + BRH$C_LENGTH,
    P2=.BLOCKS * 512,
    P3=.INPUT_BLOCK);
IF NOT .STATUS
THEN
    FILE_ERROR(
	BACKUP$_READERR + STS$K_SEVERE,
	.INPUT_FAB,
	.STATUS);
INPUT_BLOCK = .INPUT_BLOCK + .BLOCKS;


! Set up various fields of the BCB, and queue the buffer to the input wait
! list.  Finally, clear INPUT_BCB to indicate that there is no current buffer.
!
INPUT_BCB[BCB_SUCC_ACT] = 0;
INPUT_BCB[BCB_FAIL_ACT] = 0;
INPUT_BCB[BCB_STATE] = BCB_S_READ;
INSQUE(.INPUT_BCB, .INPUT_WAIT[1]);
INPUT_BCB = 0;
END;

ROUTINE SAVE_READAHEAD: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initiates read-ahead of blocks to be saved.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Start reads on half the buffers or until a read has been
! started on the last block to be transferred.
!
DECR I FROM (.COM_BUFF_COUNT+1)/2 TO 1 DO
    BEGIN
    IF .INPUT_BLOCK GTRU .INPUT_MAXBLOCK THEN EXITLOOP;
    SAVE_READ();
    END;
END;

ROUTINE SAVE_BLOCKS_HANDLER(SIG,MECH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is a handler for routine SAVE_BLOCKS.  It handles getting
!	SAVE_BLOCKS restarted after a reel change.
!
! INPUT PARAMETERS:
!	SIG		- Standard VMS condition handler parameters
!	MECH		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_RESIGNAL
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SIG:		REF BBLOCK,	! Signal parameters
	MECH:		REF BBLOCK;	! Mechanism parameters


IF .SIG[CHF$L_SIG_NAME] EQL -1
THEN
    BEGIN
    MECH[CHF$L_MCH_SAVR0] = FALSE;
    $UNWIND();
    END;
SS$_RESIGNAL
END;

ROUTINE SAVE_BLOCKS=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the driver for saving a file or a volume.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_BCB	- Points to current buffer, if any.
!	INPUT_BLOCK	- Smallest block number to be saved.
!	INPUT_MAXBLOCK	- Largest block number to be saved.
!	INPUT_RTYPE	- BRH$K_VBN or BRH$K_LBN, as appropriate.
!	INPUT_FUNC	- IO$_READVBLK or IO$_READLBLK, as appropriate.
!	INPUT_CHAN	- Channel number on which input is open.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_BCB	- Points to current buffer.
!
! ROUTINE VALUE:
!	TRUE, indicating completion.  If a reel-change unwind occurs, the
!	handler forces the routine value to FALSE.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	FP;


! Establish the handler.
!
.FP = SAVE_BLOCKS_HANDLER;
INPUT_FLAGS[EOV_SAVING] = TRUE;


! Start reads on the available buffers.
!
SAVE_READAHEAD();


! Until all blocks have been transferred, wait on the first read, pass it to
! the output procedure, and start another read.
!
UNTIL .INPUT_BLOCK GTRU .INPUT_MAXBLOCK DO
    BEGIN
    SAVE_WAIT();
    SAVE_READ();
    END;


! Until all pending reads have been processed, wait on them, and pass them to
! the output procedure.
!
UNTIL .INPUT_WAIT[0] EQL INPUT_WAIT[0] DO
    BEGIN
    SAVE_WAIT();
    END;


INPUT_FLAGS[EOV_SAVING] = FALSE;
TRUE
END;

! Macros to help in building attribute records.
!
MACRO

    ! Store "l" bytes from "s".
    !
    STORE_(L,S)=
	%IF L EQL 1 %THEN
	    (.P)<0,8> = S; P = .P + 1 %FI
	%IF L EQL 2 %THEN
	    (.P)<0,16> = S; P = .P + 2 %FI
	%IF L EQL 4 %THEN
	    (.P)<0,32> = S; P = .P + 4 %FI
	%IF L EQL 6 %THEN
	    (.P)<0,32> = .(S)<0,32>; P = .P + 4;
	    (.P)<0,16> = .((S)+4)<0,16>; P = .P + 2 %FI
	%IF L EQL 8 %THEN
	    (.P)<0,32> = .(S)<0,32>; P = .P + 4;
	    (.P)<0,32> = .((S)+4)<0,32>; P = .P + 4 %FI
	%IF L EQL 12 %THEN
	    (.P)<0,32> = .(S)<0,32>; P = .P + 4;
	    (.P)<0,32> = .((S)+4)<0,32>; P = .P + 4;
	    (.P)<0,32> = .((S)+8)<0,32>; P = .P + 4 %FI %,


    ! Store attribute code "n" of length "l" from address "a".
    !
    ATV_(N,L,A)=
	STORE_(2, L);
	STORE_(2, %NAME('BSA$K_', N));
	P = CH$MOVE(L, A, .P) %,


    ! Store device name "n" of length "l" from address "a".
    !
    DVI_(N,L,A)=
	STORE_(2, (L) + 1);
	STORE_(2, %NAME('BSA$K_', N));
	P = CH$MOVE(L, A, .P);
	STORE_(1, %C':') %,


    ! Store attribute code "n" from "s".
    !
    ATT_(N,S)=
	STORE_(4, %NAME('BSA$S_',N) + %NAME('BSA$K_', N)^16);
	STORE_(%NAME('BSA$S_',N), S) %;

ROUTINE BACKUP_SUMMARY: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates the backup summary record.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	L1,
	L2,
	P;
LITERAL
    FIXED_SIZE =
	BRH$C_LENGTH + 		! record header
	2 + 			! structure level
	12*4 + 			! 12 attribute size/type longwords
				!  1. save set name (variable)
				!  2. command line (variable)
	12 +			!  3. user name
	BSA$S_USERUIC +		!  4. UIC of user
	BSA$S_DATE +		!  5. date backup was done
	BSA$S_OPSYS +		!  6. operating system
	BSA$S_SYSVER +		!  7. operating system version
	BSA$S_SIR +		!  8. CPU system ID register
	%CHARCOUNT(BACKUP$VERSION) +
				!  9. version number of BACKUP
	BSA$S_BLOCKSIZE +	! 10. block size of save set
	BSA$S_XORSIZE +		! 11. size of each XOR group
	BSA$S_BUFFERS;		! 12. number of buffers


L1 =
    FIXED_SIZE +
    .COM_SSNAME[DSC$W_LENGTH] +
    .BBLOCK[QUAL[QUAL_CMD_DESC], DSC$W_LENGTH];


IF .QUAL[QUAL_COMM]
THEN
    L1 = .L1 +
	4 +			! 1 attribute size/type longword
	.BBLOCK[QUAL[QUAL_COMM_DESC], DSC$W_LENGTH];


IF .JPI_NODE_DESC[DSC$W_LENGTH] NEQ 0
THEN
    L1 = .L1 +
	4 +
	.JPI_NODE_DESC[DSC$W_LENGTH];


IF .BBLOCK[RWSV_SAVE_QUAL[QUAL_DVI_DESC], DSC$W_LENGTH] NEQ 0
THEN
    L1 = .L1 +
	4 +
	.BBLOCK[RWSV_SAVE_QUAL[QUAL_DVI_DESC], DSC$W_LENGTH] + 1;


IF .QUAL[QUAL_IMAG]
THEN
    L1 = .L1 +
	2*4 + 			! 2 attribute size/type longwords
	BSA$S_VOLSETNAM +	! 16. volume set name
	BSA$S_NVOLS;		! 17. number of volumes in set


IF .COM_FLAGS[COM_STANDALONE]
THEN
    L1 = .L1 + %CHARCOUNT(' (standalone)');


L2 = (.L1 + 15) AND NOT 15;
P = MAKE_SPACE(.L2);


STORE_(2, .L2 - BRH$C_LENGTH);
STORE_(2, BRH$K_SUMMARY);
STORE_(4, 0);
STORE_(4, 0);
STORE_(4, 0);
STORE_(2, BBH$K_LEVEL1);


ATV_('SSNAME',
    .COM_SSNAME[DSC$W_LENGTH],
    .COM_SSNAME[DSC$A_POINTER]);


ATV_('COMMAND',
    .BBLOCK[QUAL[QUAL_CMD_DESC], DSC$W_LENGTH],
    .BBLOCK[QUAL[QUAL_CMD_DESC], DSC$A_POINTER]);


IF .QUAL[QUAL_COMM]
THEN
    BEGIN
    ATV_('COMMENT',
	.BBLOCK[QUAL[QUAL_COMM_DESC], DSC$W_LENGTH],
	.BBLOCK[QUAL[QUAL_COMM_DESC], DSC$A_POINTER]);
    END;


ATV_('USERNAME', 12, JPI_USERNAME);
ATT_('USERUIC',	 .JPI_UIC);
ATT_('DATE',	 JPI_DATE);
ATT_('OPSYS',	 BACKUP$K_OPSYS);
ATT_('SYSVER',	 .SYI_VERSION);


IF .JPI_NODE_DESC[DSC$W_LENGTH] NEQ 0
THEN
    BEGIN
    ATV_('NODENAME',
    .JPI_NODE_DESC[DSC$W_LENGTH],
    .JPI_NODE_DESC[DSC$A_POINTER]);
    END;


ATT_('SIR',	 .SYI_SID);


IF .BBLOCK[RWSV_SAVE_QUAL[QUAL_DVI_DESC], DSC$W_LENGTH] NEQ 0
THEN
    BEGIN
    DVI_('DRIVEID',
	.BBLOCK[RWSV_SAVE_QUAL[QUAL_DVI_DESC], DSC$W_LENGTH],
	.BBLOCK[RWSV_SAVE_QUAL[QUAL_DVI_DESC], DSC$A_POINTER]);
    END;


IF .COM_FLAGS[COM_STANDALONE]
THEN
    BEGIN
    ATV_(
	'BACKVER',
	%CHARCOUNT(BACKUP$VERSION, ' (standalone)'),
	UPLIT BYTE(BACKUP$VERSION, ' (standalone)'));
    END
ELSE
    BEGIN
    ATV_(
	'BACKVER',
	%CHARCOUNT(BACKUP$VERSION),
	UPLIT BYTE(BACKUP$VERSION));
    END;


ATT_('BLOCKSIZE',.QUAL[QUAL_BLOC_VALUE]);
ATT_('XORSIZE',	 .QUAL[QUAL_GROU_VALUE]);
ATT_('BUFFERS',	 .QUAL[QUAL_BUFF_VALUE]);


IF .QUAL[QUAL_IMAG]
THEN
    BEGIN
    ATT_('VOLSETNAM',	COM_I_STRUCNAME);
    ATT_('NVOLS',	.COM_I_SETCOUNT);
    END;


CH$FILL(0, .L2 - .L1, .P);
END;

GLOBAL ROUTINE FROM_ODS1_DATE(ADDRESS,ATT_BUFFER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine converts a date in ODS-1 format to 64-bit format.
!
! INPUT PARAMETERS:
!	ADDRESS		- Pointer to input date string.
!	ATT_BUFFER	- Pointer to output quadword.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	ATT_BUFFER:	REF VECTOR;		! Pointer to output buffer
LITERAL
	DATLEN=		23;
LOCAL
	DATBUF:		VECTOR[DATLEN,BYTE],	! Buffer for $BINTIM
	DATDESC:	VECTOR[2];		! Descriptor for buffer


IF .(.ADDRESS)<0,8> EQL 0
THEN
    BEGIN
    ATT_BUFFER[0] = ATT_BUFFER[1] = 0;
    RETURN;
    END;


(DATBUF+00)<0,16> = .(.ADDRESS);
(DATBUF+02)<0,8>  = '-';
(DATBUF+03)<0,24> = .(.ADDRESS+2);
(DATBUF+06)<0,24> = '-19';
(DATBUF+09)<0,16> = .(.ADDRESS+5);
(DATBUF+11)<0,8>  = ' ';
IF .(.ADDRESS+7)<0,8> NEQ 0
THEN
    BEGIN
    (DATBUF+12)<0,16> = .(.ADDRESS+7);
    (DATBUF+14)<0,8>  = ':';
    (DATBUF+15)<0,16> = .(.ADDRESS+9);
    (DATBUF+17)<0,8>  = ':';
    (DATBUF+18)<0,16> = .(.ADDRESS+11);
    END
ELSE
    BEGIN
    (DATBUF+12)<0,32> = '00:0';
    (DATBUF+16)<0,32> = '0:00';
    END;
(DATBUF+20)<0,24> = '.00';


DATDESC[0] = DATLEN;
DATDESC[1] = DATBUF;
$BINTIM(TIMBUF=DATDESC, TIMADR=.ATT_BUFFER);
END;

ROUTINE ALLOC_PLC_BLOCK(TYPE,SIZE,DATA): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and links in a block of placement data.
!
! INPUT PARAMETERS:
!	TYPE		- Type code for placement block.
!	SIZE		- Size of placement data.
!	DATA		- Pointer to data for placement block.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	New block allocated and linked to listhead.
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK;	! Pointer to allocated space


! Allocate the new block.
!
P = GET_VM(PLC_S_HDR + .SIZE);


! Link new block to tail of list and initialize it.
!
INSQUE(.P, .INPUT_PLACEMENT[1]);
P[PLC_TYPE] = .TYPE;
P[PLC_SIZE] = PLC_S_HDR + .SIZE;
CH$MOVE(.SIZE, .DATA, P[PLC_DATA]);


! Count size of new block.
!
INPUT_PLACE_LEN = .INPUT_PLACE_LEN + .SIZE + 1;
END;

ROUTINE ALLOC_VBN_BLOCK(VBN,COUNT): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and links in a block of VBN data.
!
! INPUT PARAMETERS:
!	VBN		- Starting VBN.
!	COUNT		- Block count.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	New block allocated and linked to listhead.
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK,	! Pointer to allocated space
	HIGH_VBN;			! Highest VBN in range


INPUT_FLAGS[INPUT_ON_RVN] = TRUE;
HIGH_VBN = MINU(.VBN + .COUNT - 1, .INPUT_MAXBLOCK);
IF .HIGH_VBN GEQU .VBN
THEN
    BEGIN

    ! Allocate the new block.
    !
    P = GET_VM(VBN_S_ENTRY);


    ! Link new block to tail of list and initialize it.
    !
    INSQUE(.P, .INPUT_VBN_LIST[1]);
    P[PLC_SIZE] = VBN_S_ENTRY;
    P[VBN_FIRST] = .VBN;
    P[VBN_LAST] = .HIGH_VBN;
    END;
END;

ROUTINE FREE_PLC_BLOCKS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine frees a list of blocks of placement data.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Blocks linked to listhead are freed.
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK;	! Pointer to allocated space


UNTIL REMQUE(.INPUT_PLACEMENT[0], P) DO
    BEGIN
    FREE_VM(.P[PLC_SIZE], .P);
    END;
INPUT_PLACE_LEN = 0;
UNTIL REMQUE(.INPUT_VBN_LIST[0], P) DO
    BEGIN
    FREE_VM(.P[PLC_SIZE], .P);
    END;
END;

ROUTINE GET_PLC_DATA(HEADER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine scans a file header and its extension headers to get
!	the placement data.
!
! INPUT PARAMETERS:
!	HEADER		- Pointer to primary header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_PLACEMENT	- List of placement data blocks.
!	INPUT_PLACE_LEN	- Length of placement data as file attribute.
!	INPUT_VBN_LIST	- For /VOLUME save, list of VBN ranges.
!	INPUT_FLAGS[INPUT_ON_RVN] - True if any blocks were allocated on the
!			  selected RVN (even if past INPUT_MAXBLOCK).
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	LOCAL_HEADER:	BBLOCK[512],	! Buffer to read extension headers
	FILE_ID:	BBLOCK[FID$C_LENGTH],	! Current file ID
	HDR:		REF BBLOCK,	! Pointer to current file header
	THIS_RVN,			! RVN of current header
	THIS_START_VBN,			! Starting VBN of current header
	THIS_COUNT,			! VBNs mapped by current header
	COUNT;				! Count of unplaced blocks


! Initialize.
!
INPUT_PLACEMENT[0] = INPUT_PLACEMENT[1] = INPUT_PLACEMENT[0];
INPUT_VBN_LIST[0] = INPUT_VBN_LIST[1] = INPUT_VBN_LIST[0];
INPUT_PLACE_LEN = 0;
INPUT_FLAGS[INPUT_ON_RVN] = FALSE;
THIS_RVN = .INPUT_NAM[NAM$B_FID_RVN];
THIS_START_VBN = 1;
THIS_COUNT = 0;
FILE_ID[FID$W_NUM] = .INPUT_NAM[NAM$W_FID_NUM];
FILE_ID[FID$W_SEQ] = .INPUT_NAM[NAM$W_FID_SEQ];
FILE_ID[FID$W_RVN] = .INPUT_NAM[NAM$W_FID_RVN];
HDR = .HEADER;
COUNT = 0;


! Loop for all headers.
!
WHILE TRUE DO
    BEGIN
    LOCAL
	MAP_AREA:	REF BBLOCK,	! Pointer to map area
	MAP_POINTER:	REF BBLOCK,	! Pointer to map pointer
	MAP_END,			! Pointer past map area
	FIB:		BBLOCK[10],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	ATR_DESC:	BBLOCK[12],	! ACP attribute list
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD],	! I/O status block
	PEND_PLACE,			! True if placement pointer pending
	DATA:		BBLOCK[10];	! Data for placement block


    ! Initialize pointers to map area.
    !
    MAP_AREA = .HDR + .HDR[FH2$B_MPOFFSET] * 2;
    IF .HDR[FH2$B_STRUCLEV] EQL 1
    THEN
	BEGIN
	MAP_POINTER = .MAP_AREA + FM1$C_POINTERS;
	MAP_END = .MAP_POINTER + .MAP_AREA[FM1$B_INUSE] * 2;


	! Scan the header to extract placement data.
	!
	WHILE .MAP_POINTER LSSA .MAP_END DO
	    BEGIN
	    COUNT = .COUNT + .MAP_POINTER[FM1$B_COUNT] + 1;
	    THIS_COUNT = .THIS_COUNT + .MAP_POINTER[FM1$B_COUNT] + 1;
	    MAP_POINTER = .MAP_POINTER + 4;
	    END;


	! Find the next extension header.
	!
	FILE_ID[FID$W_NUM] = .MAP_AREA[FM1$W_EX_FILNUM];
	FILE_ID[FID$W_SEQ] = .MAP_AREA[FM1$W_EX_FILSEQ];
	END
    ELSE
	BEGIN
	MAP_POINTER = .MAP_AREA;
	MAP_END = .MAP_POINTER + .HDR[FH2$B_MAP_INUSE] * 2;


	! Scan the header to extract placement data.
	!
	PEND_PLACE = FALSE;
	WHILE .MAP_POINTER LSSA .MAP_END DO
	    BEGIN
	    IF .MAP_POINTER[FM2$V_FORMAT] EQL FM2$C_PLACEMENT
	    THEN
		BEGIN

		! Save placement pointer, and note that one is pending.
		!
		DATA[BSA$W_PLC_PTR] = .MAP_POINTER[FM2$W_WORD0];
		PEND_PLACE = TRUE;
		MAP_POINTER = .MAP_POINTER + 2;
		END
	    ELSE
		BEGIN

		! Extract count and LBN of retrieval pointer.
		!
	        CASE .MAP_POINTER[FM2$V_FORMAT] FROM FM2$C_FORMAT1 TO FM2$C_FORMAT3 OF
		    SET

		    [FM2$C_FORMAT1]:
			BEGIN
			DATA[BSA$L_PLC_COUNT] = .MAP_POINTER[FM2$B_COUNT1];
			DATA[BSA$W_PLC_HILBN] = .MAP_POINTER[FM2$V_HIGHLBN];
			DATA[BSA$W_PLC_LOLBN] = .MAP_POINTER[FM2$W_LOWLBN];
			MAP_POINTER = .MAP_POINTER + 4;
			END;

		    [FM2$C_FORMAT2]:
			BEGIN
			DATA[BSA$L_PLC_COUNT] = .MAP_POINTER[FM2$V_COUNT2];
			DATA[BSA$L_PLC_LBN] = .MAP_POINTER[FM2$L_LBN2];
			MAP_POINTER = .MAP_POINTER + 6;
			END;

		    [FM2$C_FORMAT3]:
			BEGIN
			DATA[BSA$L_PLC_COUNT] = ROT(..MAP_POINTER, 16) AND (1^30-1);
			DATA[BSA$L_PLC_LBN] = .MAP_POINTER[FM2$L_LBN3];
			MAP_POINTER = .MAP_POINTER + 8;
			END;

		    TES;
		DATA[BSA$L_PLC_COUNT] = .DATA[BSA$L_PLC_COUNT] + 1;
		THIS_COUNT = .THIS_COUNT + .DATA[BSA$L_PLC_COUNT];


		IF .PEND_PLACE
		THEN
		    BEGIN
		    IF .COUNT NEQ 0
		    THEN
			BEGIN
			ALLOC_PLC_BLOCK(BSA$K_PLC_COUNT, BSA$S_PLC_COUNT, COUNT);
			COUNT = 0;
			END;
		    IF .DATA[FM2$V_LBN]
		    THEN
		        ALLOC_PLC_BLOCK(BSA$K_PLC_PLLBN, BSA$S_PLC_PLLBN, DATA)
		    ELSE
		        ALLOC_PLC_BLOCK(BSA$K_PLC_PLACE, BSA$S_PLC_PLACE, DATA);
		    PEND_PLACE = FALSE;
		    END
		ELSE
		    COUNT = .COUNT + .DATA[BSA$L_PLC_COUNT];
		END;
	    END;


	! Find the next extension header.
	!
	FILE_ID[FID$W_NUM] = .HDR[FH2$W_EX_FIDNUM];
	FILE_ID[FID$B_NMX] = .HDR[FH2$B_EX_FIDNMX];
	FILE_ID[FID$W_SEQ] = .HDR[FH2$W_EX_FIDSEQ];
	IF .HDR[FH2$B_EX_FIDRVN] NEQ 0
	    THEN FILE_ID[FID$B_RVN] = .HDR[FH2$B_EX_FIDRVN];
	END;


    ! If there is no extension header, we are done.
    !
    IF .FILE_ID[FID$W_NUM] EQL 0
    THEN
	EXITLOOP;


    ! Put out a placement data block for the extension file ID.
    !
    IF .COUNT NEQ 0
    THEN
	BEGIN
	ALLOC_PLC_BLOCK(BSA$K_PLC_COUNT, BSA$S_PLC_COUNT, COUNT);
	COUNT = 0;
	END;
    ALLOC_PLC_BLOCK(BSA$K_PLC_FID, BSA$S_PLC_FID, FILE_ID);


    ! If the RVN changes, and if required, put out a VBN block for the
    ! sequence of blocks.
    !
    IF .THIS_RVN NEQ .FILE_ID[FID$B_RVN]
    THEN
	BEGIN
	IF .QUAL[QUAL_VOLU] AND .QUAL[QUAL_VOLU_VALUE] EQL .THIS_RVN
	THEN
	    ALLOC_VBN_BLOCK(.THIS_START_VBN, .THIS_COUNT);
	THIS_START_VBN = .THIS_START_VBN + .THIS_COUNT;
	THIS_COUNT = 0;
	THIS_RVN = .FILE_ID[FID$B_RVN];
	END;


    ! Read the extension header.
    !
    FIB[FIB$L_ACCTL] = 0;
    FIB[FIB$W_FID_NUM] = .FILE_ID[FID$W_NUM];
    FIB[FIB$W_FID_SEQ] = .FILE_ID[FID$W_SEQ];
    FIB[FIB$W_FID_RVN] = .FILE_ID[FID$W_RVN];
    FIB_DESC[0] = 10;
    FIB_DESC[1] = FIB;
    ATR_DESC[0,0,16,0] = ATR$S_HEADER;
    ATR_DESC[2,0,16,0] = ATR$C_HEADER;
    ATR_DESC[4,0,32,0] = LOCAL_HEADER;
    ATR_DESC[8,0,32,0] = 0;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC,
	P5=ATR_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	FILE_ERROR(BACKUP$_READATTR, .INPUT_FAB, .STATUS);
	FREE_PLC_BLOCKS();
	RETURN;
	END;
    HDR = LOCAL_HEADER;
    END;


! If required, put out a VBN block for the last sequence of blocks.
!
IF .QUAL[QUAL_VOLU] AND .QUAL[QUAL_VOLU_VALUE] EQL .THIS_RVN
THEN
    ALLOC_VBN_BLOCK(.THIS_START_VBN, .THIS_COUNT);


! If required, put out a placement data block for unplaced blocks.
!
IF .COUNT NEQ 0 AND .INPUT_PLACEMENT[0] NEQ INPUT_PLACEMENT[0]
THEN
    ALLOC_PLC_BLOCK(BSA$K_PLC_COUNT, BSA$S_PLC_COUNT, COUNT);
END;

ROUTINE DUMP_PLC_DATA(ATT_AREA): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine puts the placement data into the file attribute record.
!
! INPUT PARAMETERS:
!	ATT_AREA	- Pointer to area in file attribute record.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK,	! Pointer to placement data block
	A;				! Pointer to attribute area


A = .ATT_AREA;
P = .INPUT_PLACEMENT[0];
UNTIL .P EQL INPUT_PLACEMENT[0] DO
    BEGIN
    (.A)<0,8> = .P[PLC_TYPE];
    A = .A + 1;   
    A = CH$MOVE(.P[PLC_SIZE] - PLC_S_HDR, P[PLC_DATA], .A);
    P = .P[PLC_FLINK];
    END;
END;

ROUTINE FILE_ATTRIBUTES(INPUT_HDR): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates a file attribute record.
!
! INPUT PARAMETERS:
!	INPUT_HDR	- Pointer to file header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	INPUT_HDR:	REF BBLOCK;	! Pointer to file header
LOCAL
	L1,				! Unrounded length
	L2,				! Rounded length
	P:		REF BBLOCK,	! Pointer to attribute record
	INPUT_IDENT:	REF BBLOCK,	! Pointer to ident area
	IDLEN,				! Length of ident area
	BOOTVBN,			! Boot VBN
	PLACEMENT;			! Generating placement attribute
LITERAL
    FIXED_SIZE =
	BRH$C_LENGTH + 		! record header
	2 + 			! structure level
	8*4 + 			! 8 attribute size/type longwords
				!  1. file name (variable)
	BSA$S_STRUCLEV +	!  2. file structure level
	BSA$S_FID +		!  3. file ID
	BSA$S_FILESIZE +	!  4. file size in blocks
	BSA$S_UIC +		!  5. file owner UIC
	BSA$S_FPRO +		!  6. file protection mask
	BSA$S_UCHAR +		!  7. file characteristics
	BSA$S_RECATTR;		!  8. record attributes area


! Determine the address and length of the ident area.
!
INPUT_IDENT = .INPUT_HDR + .INPUT_HDR[FH2$B_IDOFFSET] * 2;
IDLEN = (.INPUT_HDR[FH2$B_MPOFFSET] - .INPUT_HDR[FH2$B_IDOFFSET]) * 2;


! Determine the length of the attribute record.
!
L1 = FIXED_SIZE + .INPUT_NAMEDESC[DSC$W_LENGTH];
IF .INPUT_HDR[FH2$B_STRUCLEV] EQL 2
THEN
    BEGIN
    L1 = .L1 + 4*4 + BSA$S_BACKLINK + BSA$S_RPRO + BSA$S_ACLEVEL + BSA$S_VERLIMIT;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_CREDATE)
	THEN L1 = .L1 + 4 + BSA$S_REVISION;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_REVDATE)
	THEN L1 = .L1 + 4 + BSA$S_CREDATE;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_EXPDATE)
	THEN L1 = .L1 + 4 + BSA$S_REVDATE;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_BAKDATE)
	THEN L1 = .L1 + 4 + BSA$S_EXPDATE;
    IF .IDLEN GEQU FI2$C_LENGTH
	THEN L1 = .L1 + 4 + BSA$S_BAKDATE;
    END
ELSE
    BEGIN
    L1 = .L1 + 4*4 + BSA$S_REVISION + BSA$S_CREDATE + BSA$S_REVDATE + BSA$S_EXPDATE;


    ! Determine if the file is a directory.  In ODS-1, this is defined as a
    ! file ".DIR;1" with fixed length 16 byte records and no record attributes.
    !
    IF
	CH$FIND_SUB(
	    .INPUT_NAMEDESC[DSC$W_LENGTH], .INPUT_NAMEDESC[DSC$A_POINTER],
	    6, UPLIT BYTE ('.DIR;1')) NEQ 0 AND
	.INPUT_RECATTR[FAT$B_RTYPE] EQL FAT$C_FIXED AND
	.INPUT_RECATTR[FAT$B_RATTRIB] EQL 0 AND
	.INPUT_RECATTR[FAT$W_RSIZE] EQL NMB$C_DIRENTRY
    THEN
	INPUT_FILECHAR[FCH$V_DIRECTORY] = TRUE;
    END;


BOOTVBN = 0;
IF .QUAL[QUAL_IMAG]
THEN
    IF
	.INPUT_STATBLK[SBK$L_STLBN] NEQ 0 AND
	.FAST_BOOT_LBN[.INPUT_NAM[NAM$B_FID_RVN]-1] NEQ -1 AND
	.INPUT_STATBLK[SBK$L_STLBN] LEQU .FAST_BOOT_LBN[.INPUT_NAM[NAM$B_FID_RVN]-1] AND
	.INPUT_STATBLK[SBK$L_STLBN] + .INPUT_STATBLK[SBK$L_FILESIZE] GTRU .FAST_BOOT_LBN[.INPUT_NAM[NAM$B_FID_RVN]-1]
    THEN
	BEGIN
	BOOTVBN = .FAST_BOOT_LBN[.INPUT_NAM[NAM$B_FID_RVN]-1] - .INPUT_STATBLK[SBK$L_STLBN] + 1;
	L1 = .L1 + 4 + BSA$S_BOOTVBN;
	END;


PLACEMENT = FALSE;
IF
    .QUAL[QUAL_IMAG] AND
    .INPUT_PLACE_LEN NEQ 0 AND
    .L1 + .INPUT_PLACE_LEN + 4 LEQU MAX_RECORD
THEN
    BEGIN
    L1 = .L1 + .INPUT_PLACE_LEN + 4;
    PLACEMENT = TRUE;
    END;


IF .INPUT_NAM[NAM$W_DID_NUM] NEQ 0
THEN
    L1 = .L1 + 3*4 + BSA$S_DIR_UIC + BSA$S_DIR_FPRO + BSA$S_DIR_VERLIM;


IF .DIR_STATUS NEQ 0
THEN
    L1 = .L1 + 4 + BSA$S_DIR_STATUS;


! Allocate the attribute record and initialize the record header.
!
L2 = (.L1 + 15) AND NOT 15;
P = MAKE_SPACE(.L2);
P[BRH$W_RSIZE] = .L2 - BRH$C_LENGTH;
P[BRH$W_RTYPE] = BRH$K_FILE;
P[BRH$L_FLAGS] = 0;
IF .INPUT_FILECHAR[FCH$V_DIRECTORY] THEN P[BRH$V_DIRECTORY] = TRUE;
P[BRH$L_ADDRESS] = 0;
P[BRH$L_RESERVED] = 0;
P = .P + BRH$C_LENGTH;
STORE_(2, BBH$K_LEVEL1);


! Store attributes.
!
ATV_('FILENAME',	.INPUT_NAMEDESC[DSC$W_LENGTH], .INPUT_NAMEDESC[DSC$A_POINTER]);
ATT_('STRUCLEV',	.INPUT_HDR[FH2$W_STRUCLEV]);
ATT_('FID',		INPUT_NAM[NAM$W_FID]);
ATT_('FILESIZE',	.INPUT_STATBLK[SBK$L_FILESIZE]);
ATT_('UIC',		 .INPUT_FILEOWNER);
ATV_('RECATTR',		BSA$S_RECATTR, INPUT_RECATTR);
IF .INPUT_HDR[FH2$B_STRUCLEV] EQL 2
THEN
    BEGIN
    ATT_('BACKLINK',	INPUT_HDR[FH2$W_BACKLINK]);
    ATT_('FPRO',	.INPUT_HDR[FH2$W_FILEPROT]);
    ATT_('RPRO',	.INPUT_HDR[FH2$W_RECPROT]);
    ATT_('ACLEVEL',	.INPUT_HDR[FH2$B_ACC_MODE]);
    ATT_('UCHAR',	.INPUT_HDR[FH2$L_FILECHAR]);
    ATT_('VERLIMIT',	.DIR_VERLIMIT);
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_CREDATE)
    THEN
	BEGIN
	ATT_('REVISION',.INPUT_IDENT[FI2$W_REVISION]);
	END;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_REVDATE)
    THEN
	BEGIN
	ATT_('CREDATE',	INPUT_CREDATE);
	END;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_EXPDATE)
    THEN
	BEGIN
	ATT_('REVDATE',	INPUT_REVDATE);
	END;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_BAKDATE)
    THEN
	BEGIN
	ATT_('EXPDATE',	INPUT_EXPDATE);
	END;
    IF .IDLEN GEQU FI2$C_LENGTH
    THEN
	IF .QUAL[QUAL_RECO]
	THEN
	    BEGIN
	    ATT_('BAKDATE', JPI_DATE);
	    END
	ELSE
	    BEGIN
	    ATT_('BAKDATE', INPUT_BAKDATE);
	    END;
    END
ELSE
    BEGIN
    ATT_('FPRO',	 .INPUT_HDR[FH1$W_FILEPROT]);
    ATT_('UCHAR',	 .INPUT_FILECHAR AND NOT FCH$M_DIRECTORY);
    ATT_('REVISION',	.INPUT_IDENT[FI1$W_REVISION]);
    ATT_('CREDATE',	INPUT_CREDATE);
    ATT_('REVDATE',	INPUT_REVDATE);
    ATT_('EXPDATE',	INPUT_EXPDATE);
    END;


IF .BOOTVBN NEQ 0
THEN
    BEGIN
    ATT_('BOOTVBN', .BOOTVBN);
    END;


IF .PLACEMENT
THEN
    BEGIN
    STORE_(2, .INPUT_PLACE_LEN);
    STORE_(2, BSA$K_PLACEMENT);
    DUMP_PLC_DATA(.P);
    P = .P + .INPUT_PLACE_LEN;
    END;


IF .INPUT_NAM[NAM$W_DID_NUM] NEQ 0
THEN
    BEGIN
    ATT_('DIR_UIC', .DIR_SP[D_UIC]);
    ATT_('DIR_FPRO', .DIR_SP[D_FPRO]);
    ATT_('DIR_VERLIM', .DIR_SP[D_VERLIM]);
    END;


IF .DIR_STATUS NEQ 0
THEN
    BEGIN
    ATT_('DIR_STATUS', .DIR_STATUS);
    END;


! Pad the record with zeros.
!
CH$FILL(0, .L2 - .L1, .P);
END;

GLOBAL ROUTINE VOLUME_ATTRIBUTES(INPUT_HOME,INPUT_BOOT,INPUT_SCB,INPUT_MAXFILNUM): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates a volume attribute record.
!
! INPUT PARAMETERS:
!	INPUT_HOME	- Pointer to home block.
!	INPUT_BOOT	- Pointer to boot block.
!	INPUT_SCB	- Pointer to storage control block.
!	INPUT_MAXFILNUM	- Highest file number in use.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	INPUT_HOME:	REF BBLOCK,	! Pointer to home block
	INPUT_BOOT:	REF BBLOCK,	! Pointer to boot block
	INPUT_SCB:	REF BBLOCK;	! Pointer to storage control block
LOCAL
	BOOT_LENGTH,			! Boot block length less trailing zeros
	L1,				! Unrounded length
	L2,				! Rounded length
	P:		REF BBLOCK;	! Pointer to attribute record
LITERAL
    FIXED_SIZE =
	BRH$C_LENGTH + 		! record header
	2 + 			! structure level
	18*4 + 			! 18 attribute size/type longwords
	BSA$S_VOLSTRUCT +	!  1. volume structure level
	BSA$S_VOLNAME +		!  2. volume label
	BSA$S_OWNERNAME +	!  3. volume owner name
	BSA$S_FORMAT +		!  4. volume file format name
	BSA$S_VOLOWNER +	!  5. volume owner UIC
	BSA$S_PROTECT +		!  6. volume protection mask
	BSA$S_FILEPROT +	!  7. volume default file protection
	BSA$S_VOLCHAR +		!  8. volume characteristics bits
	BSA$S_VOLDATE +		!  9. volume creation date
	BSA$S_WINDOW +		! 10. volume default file window size
	BSA$S_LRU_LIM +		! 11. volume default directory LRU limit
	BSA$S_EXTEND +		! 12. volume default file extension size
	BSA$S_CLUSTER +		! 13. volume cluster factor
	BSA$S_VOLSIZE +		! 14. volume size in blocks
	BSA$S_MAXFILES +	! 15. volume maximum number of files
	BSA$S_MAXFILNUM +	! 16. highest file number in use
	BSA$S_SERIALNUM +	! 17. volume serial number
	BSA$S_INDEXLBN;		! 18. index file bitmap starting LBN


! Generate the backup summary record.  Determine the length of the attribute
! record.
!
L1 = FIXED_SIZE;
IF .INPUT_HOME[HM2$B_STRUCLEV] EQL 2
THEN
    BEGIN
    IF
	(IF .QUAL[QUAL_VOLU]
	    THEN .QUAL[QUAL_VOLU_VALUE] EQL .INPUT_HOME[HM2$W_RVN]
	    ELSE .INPUT_HOME[HM2$W_RVN] LEQU 1)
    THEN
	BACKUP_SUMMARY();

    L1 = .L1 + 4*4 + BSA$S_RECPROT + BSA$S_RESFILES + BSA$S_RETAINMIN + BSA$S_RETAINMAX;
    IF .COM_I_SETCOUNT GTRU 1 THEN L1 = .L1 + 4 + BSA$S_RVN;
    END
ELSE
    BACKUP_SUMMARY();


! If the volume is bootable, determine the length of the boot program with
! trailing zero bytes stripped off.
!
IF .INPUT_BOOT[2,0,16,0] EQL 0
THEN
    BEGIN
    BOOT_LENGTH = 0;
    DECR J FROM 511 TO 0 DO
	BEGIN
	IF .INPUT_BOOT[.J,0,8,0] NEQ 0
	THEN
	    BEGIN
	    BOOT_LENGTH = .J + 1;
	    EXITLOOP;
	    END;
	END;
    L1 = .L1 + 4 + .BOOT_LENGTH;
    END;


! Allocate the attribute record and initialize the record header.
!
L2 = (.L1 + 15) AND NOT 15;
P = MAKE_SPACE(.L2);
P[BRH$W_RSIZE] = .L2 - BRH$C_LENGTH;
P[BRH$W_RTYPE] = BRH$K_VOLUME;
P[BRH$L_FLAGS] = 0;
P[BRH$L_ADDRESS] = 0;
P[BRH$L_RESERVED] = 0;
P = .P + BRH$C_LENGTH;
STORE_(2, BBH$K_LEVEL1);


! Store attributes.
!
IF .INPUT_HOME[HM2$B_STRUCLEV] EQL 2
THEN
    BEGIN
    ATT_('VOLSTRUCT',	.INPUT_HOME[HM2$W_STRUCLEV]);
    ATT_('VOLNAME',	INPUT_HOME[HM2$T_VOLNAME]);
    ATT_('OWNERNAME',	INPUT_HOME[HM2$T_OWNERNAME]);
    ATT_('FORMAT',	INPUT_HOME[HM2$T_FORMAT]);
    IF .COM_I_SETCOUNT GTRU 1
    THEN
	BEGIN
	ATT_('RVN',	.INPUT_HOME[HM2$W_RVN]);
	END;
    ATT_('VOLOWNER',	.INPUT_HOME[HM2$L_VOLOWNER]);
    ATT_('PROTECT',	.INPUT_HOME[HM2$W_PROTECT]);
    ATT_('FILEPROT',	.INPUT_HOME[HM2$W_FILEPROT]);
    ATT_('RECPROT',	.INPUT_HOME[HM2$W_RECPROT]);
    ATT_('VOLCHAR',	.INPUT_HOME[HM2$W_VOLCHAR]);
    ATT_('VOLDATE',	INPUT_HOME[HM2$Q_CREDATE]);
    ATT_('WINDOW',	.INPUT_HOME[HM2$B_WINDOW]);
    ATT_('LRU_LIM',	.INPUT_HOME[HM2$B_LRU_LIM]);
    ATT_('EXTEND',	.INPUT_HOME[HM2$W_EXTEND]);
    ATT_('CLUSTER',	.INPUT_HOME[HM2$W_CLUSTER]);
    ATT_('RESFILES',	.INPUT_HOME[HM2$W_RESFILES]);
    ATT_('VOLSIZE',	.INPUT_SCB[SCB$L_VOLSIZE]);
    ATT_('MAXFILES',	.INPUT_HOME[HM2$L_MAXFILES]);
    ATT_('MAXFILNUM',	.INPUT_MAXFILNUM);
    ATT_('SERIALNUM',	.INPUT_HOME[HM2$L_SERIALNUM]);
    ATT_('INDEXLBN',	.INPUT_HOME[HM2$L_IBMAPLBN]);
    ATT_('RETAINMIN',	INPUT_HOME[HM2$Q_RETAINMIN]);
    ATT_('RETAINMAX',	INPUT_HOME[HM2$Q_RETAINMAX]);
    END
ELSE
    BEGIN
    LOCAL
	CREDATE:	VECTOR[2],	! Temp to get creation date
	T;				! Temp to assemble UIC

    ATT_('VOLSTRUCT',	.INPUT_HOME[HM1$W_STRUCLEV]);
    ATT_('VOLNAME',	INPUT_HOME[HM1$T_VOLNAME2]);
    ATT_('OWNERNAME',	INPUT_HOME[HM1$T_OWNERNAME]);
    ATT_('FORMAT',	INPUT_HOME[HM1$T_FORMAT]);
    T< 0,16> = .(INPUT_HOME[HM1$W_VOLOWNER])<0,8>;
    T<16,16> = .(INPUT_HOME[HM1$W_VOLOWNER])<8,8>;
    ATT_('VOLOWNER',	.T);
    ATT_('PROTECT',	.INPUT_HOME[HM1$W_PROTECT]);
    ATT_('FILEPROT',	.INPUT_HOME[HM1$W_FILEPROT]);
    ATT_('VOLCHAR',	.INPUT_HOME[HM2$W_VOLCHAR]);
    FROM_ODS1_DATE(INPUT_HOME[HM1$T_CREDATE], CREDATE);
    ATT_('VOLDATE',	CREDATE);
    ATT_('WINDOW',	.INPUT_HOME[HM1$B_WINDOW]);
    ATT_('LRU_LIM',	.INPUT_HOME[HM1$B_LRU_LIM]);
    ATT_('EXTEND',	.INPUT_HOME[HM1$B_EXTEND]);
    ATT_('CLUSTER',	.INPUT_HOME[HM1$W_CLUSTER]);
    ATT_('VOLSIZE',	ROT(.(.INPUT_SCB + 4 + .INPUT_SCB[3,0,8,0] * 4), 16));
    ATT_('MAXFILES',	.INPUT_HOME[HM1$W_MAXFILES]);
    ATT_('MAXFILNUM',	.INPUT_MAXFILNUM);
    ATT_('SERIALNUM',	.INPUT_HOME[HM1$L_SERIALNUM]);
    ATT_('INDEXLBN',	ROT(.INPUT_HOME[HM1$L_IBMAPLBN], 16));
    END;


IF .INPUT_BOOT[2,0,16,0] EQL 0
THEN
    BEGIN
    ATV_('BOOTBLOCK',	.BOOT_LENGTH, .INPUT_BOOT);
    END;


! Pad the record with zeros.
!
CH$FILL(0, .L2 - .L1, .P);
END;

GLOBAL ROUTINE GEN_FID_RECORD(BUFFER,COUNT,FILE_NUMBER,RVN): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates a file ID record.
!
! INPUT PARAMETERS:
!	BUFFER		- Buffer containing file headers.
!	COUNT		- Count of file headers in buffer.
!	FILE_NUMBER	- File number and RVN of first
!	RVN		-     header in buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	File ID record generated.
!
!--

BEGIN
LOCAL
	L1,				! Unrounded length
	L2,				! Rounded length
	P:		REF BBLOCK,	! Pointer to attribute record
	HDR:		REF BBLOCK;	! Pointer to file header


! Point to the file headers.
!
HDR = .BUFFER;


! Determine the length of the attribute record.
!
L1 = BRH$C_LENGTH + $BYTEOFFSET(BSA$W_FID_SEQ) + 2 * .COUNT;
L2 = (.L1 + 15) AND NOT 15;


! Allocate the attribute record and initialize the record header.
!
P = MAKE_SPACE(.L2);
P[BRH$W_RSIZE] = .L2 - BRH$C_LENGTH;
P[BRH$W_RTYPE] = BRH$K_FID;
P[BRH$L_FLAGS] = 0;
P[BRH$L_ADDRESS] = 0;
P[BRH$L_RESERVED] = 0;
P = .P + BRH$C_LENGTH;
STORE_(2, BBH$K_LEVEL1);
STORE_(2, .FILE_NUMBER<0,16>);
STORE_(1, .RVN);
STORE_(1, .FILE_NUMBER<16,8>);
STORE_(2, .COUNT);
DECR I FROM .COUNT TO 1 DO
    BEGIN
    LOCAL
	SEQ;

    IF .HDR[FH2$B_STRUCLEV] EQL 2
	THEN SEQ = .HDR[FH2$W_FID_SEQ]
	ELSE SEQ = .HDR[FH1$W_FID_SEQ];
    STORE_(2, .SEQ);
    HDR = .HDR + 512;
    END;


! Pad the record with zeros.
!
CH$FILL(0, .L2 - .L1, .P);
END;

ROUTINE PHYSVOL_SUMMARY(INPUT_DEVCHAR): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates the physical volume summary record.
!
! INPUT PARAMETERS:
!	INPUT_DEVCHAR	- Device characteristics.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	INPUT_DEVCHAR:	REF BBLOCK;	! Pointer to device characteristics
LOCAL
	L1,				! Unrounded length
	L2,				! Rounded length
	P;				! Pointer to attribute record
LITERAL
    FIXED_SIZE =
	BRH$C_LENGTH + 		! record header
	2 + 			! structure level
	7*4 +			! 7 attribute size/type longwords
	BSA$S_SECTORS +		!  1. sectors per track
	BSA$S_TRACKS +		!  2. tracks per cylinder
	BSA$S_CYLINDERS +	!  3. cylinders per volume
	BSA$S_MAXBLOCK +	!  4. logical blocks per volume
	BSA$S_DEVTYP +		!  5. device type
	BSA$S_SERIAL;		!  6. serial number
				!  7. device name (variable)
	

L1 =
    FIXED_SIZE +
    .BBLOCK[INPUT_QUAL[QUAL_DVI_DESC], DSC$W_LENGTH] + 1;


IF .INPUT_DEVCHAR[DIB$W_VOLNAMOFF] NEQ 0
THEN
    L1 = .L1 + 4 + .(.INPUT_DEVCHAR + .INPUT_DEVCHAR[DIB$W_VOLNAMOFF])<0,8>;


IF .INPUT_BAD[BAD_NUMDESC] NEQ 0
THEN
    L1 = .L1 + 4 + BSA$S_BADBLOCK * .INPUT_BAD[BAD_NUMDESC];


L2 = (.L1 + 15) AND NOT 15;
P = MAKE_SPACE(.L2);


STORE_(2, .L2 - BRH$C_LENGTH);
STORE_(2, BRH$K_PHYSVOL);
STORE_(4, 0);
STORE_(4, 0);
STORE_(4, 0);
STORE_(2, BBH$K_LEVEL1);


ATT_('SECTORS',	 .INPUT_DEVCHAR[DIB$B_SECTORS]);
ATT_('TRACKS',	 .INPUT_DEVCHAR[DIB$B_TRACKS]);
ATT_('CYLINDERS',.INPUT_DEVCHAR[DIB$W_CYLINDERS]);
ATT_('MAXBLOCK', .INPUT_DEVCHAR[DIB$L_MAXBLOCK]);
ATT_('DEVTYP',	 .INPUT_DEVCHAR[DIB$B_DEVTYPE]);
ATT_('SERIAL',	 .INPUT_BAD[BAD_SERIAL]);


DVI_('DEVNAM',
    .BBLOCK[INPUT_QUAL[QUAL_DVI_DESC], DSC$W_LENGTH],
    .BBLOCK[INPUT_QUAL[QUAL_DVI_DESC], DSC$A_POINTER]);


IF .INPUT_DEVCHAR[DIB$W_VOLNAMOFF] NEQ 0
THEN
    BEGIN
    ATV_('LABEL',
    .(.INPUT_DEVCHAR + .INPUT_DEVCHAR[DIB$W_VOLNAMOFF])<0,8>,
    .INPUT_DEVCHAR + .INPUT_DEVCHAR[DIB$W_VOLNAMOFF] + 1);
    END;


IF .INPUT_BAD[BAD_NUMDESC] NEQ 0
THEN
    BEGIN
    LOCAL
	Q:	REF BBLOCK;

    STORE_(2, BSA$S_BADBLOCK * .INPUT_BAD[BAD_NUMDESC]);
    STORE_(2, BSA$K_BADBLOCK);
    Q = INPUT_BAD[BAD_DESC];
    INCR I FROM 0 TO .INPUT_BAD[BAD_NUMDESC]-1 DO
	BEGIN
	STORE_(4, .Q[BAD_LBN]);
	STORE_(4, .Q[BAD_COUNT]);
	Q = .Q + BAD_S_DESC;
	END;
    END;


CH$FILL(0, .L2 - .L1, .P);
END;

GLOBAL ROUTINE SAVE_VERIFY_REEL: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called at the end of each reel to verify that reel.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD],	! I/O status block
	SAVE_INPUT_BAD,			! Save for INPUT_BAD
	LOCAL_SAVE:	BBLOCK[INPUT_END-INPUT_BEG];	! Save area


! If a file is accessed, deaccess it for the duration of the verify pass to
! avoid having the file open for the entire time.
!
IF .INPUT_FLAGS[INPUT_OPEN]
THEN
    BEGIN
    STATUS = $QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_CLOSEIN + STS$K_ERROR,
	    .INPUT_FAB,
	    .STATUS);
    END;

    
! Save current context.
!
CH$MOVE(INPUT_END-INPUT_BEG, INPUT_BEG, LOCAL_SAVE);


! Deassign the channel.  This is necessary so that if a restart is requested
! during the verify pass, the channel will not be lost.
!
IF .INPUT_CHAN NEQ 0
THEN
    BEGIN
    $DASSGN(CHAN=.INPUT_CHAN);
    INPUT_CHAN = 0;
    END;


! Readjust context.
!
QUAL[QUAL_COMP] = TRUE;
IF .QUAL[QUAL_PHYS] THEN VERIFY_FAB = .INPUT_FAB;
SAVE_INPUT_BAD = .INPUT_BAD;
CH$FILL(0, INPUT_END-INPUT_BEG, INPUT_BEG);
CH$FILL(0, OUTPUT_END-OUTPUT_BEG, OUTPUT_BEG);
OUTPUT_BAD = .SAVE_INPUT_BAD;


! Do the verify by calling the RESTORE module.
!
RESTORE();


! Restore context.
!
QUAL[QUAL_COMP] = FALSE;
CH$MOVE(INPUT_END-INPUT_BEG, LOCAL_SAVE, INPUT_BEG);
OUTPUT_BAD = 0;


! Reassign a channel to the input device if one was originally assigned.
!
IF .INPUT_CHAN NEQ 0
THEN
    BEGIN
    STATUS = ASSIGN_INPUT_CHANNEL(INPUT_QUAL[QUAL_DEV_DESC], INPUT_CHAN, 0, 0);
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_OPENIN + STS$K_SEVERE,
	    .INPUT_FAB,
	    .STATUS);
    END;
END;

GLOBAL ROUTINE INIT_ATTR(INPUT_HDR): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes the structure-independent attributes area.
!
! INPUT PARAMETERS:
!	INPUT_HDR	- Input file header.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INPUT_CREDATE, INPUT_REVDATE, INPUT_EXPDATE, INPUT_BAKDATE,
!	INPUT_FILEOWNER, INPUT_FILECHAR, INPUT_RECATTR
!			- The input attributes.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	INPUT_HDR:	REF BBLOCK;	! Pointer to file header
LOCAL
	INPUT_IDENT:	REF BBLOCK,	! Pointer to ident area
	IDLEN;				! Length of ODS-2 ident area
MACRO
	MOVQ_(A,B)=
	    (B) = .(A);
	    ((B)+4) = .((A)+4) %;


CH$FILL(0, INPUT_HDR_END-INPUT_HDR_BEG, INPUT_HDR_BEG);


IF .INPUT_HDR[FH2$B_STRUCLEV] EQL 1
THEN
    BEGIN

    ! Determine the address of the ident area.
    !
    INPUT_IDENT = .INPUT_HDR + .INPUT_HDR[FH1$B_IDOFFSET] * 2;


    ! Initialize the structure-independent attributes area.
    !
    FROM_ODS1_DATE(INPUT_IDENT[FI1$T_CREDATE], INPUT_CREDATE);
    FROM_ODS1_DATE(INPUT_IDENT[FI1$T_REVDATE], INPUT_REVDATE);
    FROM_ODS1_DATE(INPUT_IDENT[FI1$T_EXPDATE], INPUT_EXPDATE);
    INPUT_FILEOWNER< 0,16> = .INPUT_HDR[FH1$B_UICMEMBER];
    INPUT_FILEOWNER<16,16> = .INPUT_HDR[FH1$B_UICGROUP];
    INPUT_FILECHAR = .INPUT_HDR[FH1$W_FILECHAR];
    CH$MOVE(FAT$C_LENGTH, INPUT_HDR[FH1$W_RECATTR], INPUT_RECATTR);
    END
ELSE
    BEGIN

    ! Determine the address and length of the ident area.
    !
    INPUT_IDENT = .INPUT_HDR + .INPUT_HDR[FH2$B_IDOFFSET] * 2;
    IDLEN = (.INPUT_HDR[FH2$B_MPOFFSET] - .INPUT_HDR[FH2$B_IDOFFSET]) * 2;


    ! Initialize the structure-independent attributes area.
    !
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_REVDATE)
    THEN
	BEGIN
	MOVQ_(INPUT_IDENT[FI2$Q_CREDATE], INPUT_CREDATE);
	END;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_EXPDATE)
    THEN
	BEGIN
	MOVQ_(INPUT_IDENT[FI2$Q_REVDATE], INPUT_REVDATE);
	END;
    IF .IDLEN GEQU $BYTEOFFSET(FI2$Q_BAKDATE)
    THEN
	BEGIN
	MOVQ_(INPUT_IDENT[FI2$Q_EXPDATE], INPUT_EXPDATE);
	END;
    IF .IDLEN GEQU FI2$C_LENGTH
    THEN
	BEGIN
	MOVQ_(INPUT_IDENT[FI2$Q_BAKDATE], INPUT_BAKDATE);
	END;
    INPUT_FILEOWNER = .INPUT_HDR[FH2$L_FILEOWNER];
    INPUT_FILECHAR = .INPUT_HDR[FH2$L_FILECHAR];
    CH$MOVE(FAT$C_LENGTH, INPUT_HDR[FH2$W_RECATTR], INPUT_RECATTR);
    END;
END;

GLOBAL ROUTINE SELECT_INPUT_FILE(TYPE)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine evaluates selection criteria for an input file.
!
! INPUT PARAMETERS:
!	TYPE		- <0,1> to evaluate file header criteria.
!			  <1,1> to evaluate file name criteria.
!			  <2,1> to evaluate /CONFIRM qualifier.
!
! IMPLICIT INPUTS:
!	INPUT_NAM	- pointer to the NAM block.
!	INPUT_CREDATE, INPUT_REVDATE, INPUT_EXPDATE, INPUT_BAKDATE,
!	INPUT_FILEOWNER, INPUT_FILECHAR, INPUT_RECATTR
!			- The input attributes.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if file is selected by the selection qualifiers, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	CMDDATE:	REF VECTOR,	! Pointer to command selection date
	FILDATE:	REF VECTOR;	! Pointer to file selection date


! For a save operation, avoid applying file selection qualifiers to ensure that
! all needed directories are saved.  This test is disabled under /INTERCHANGE
! to save space on distribution media.
!
IF .QUAL[QUAL_OSAV] AND .DIR_STATUS[D_STAT_VALID] AND NOT .QUAL[QUAL_INTE]
THEN
    RETURN TRUE;


IF .TYPE<0,1>
THEN
    BEGIN
    IF .QUAL[QUAL_BEFO] OR .QUAL[QUAL_SINC]
    THEN
	BEGIN
	IF .QUAL[QUAL_BACK] THEN FILDATE = INPUT_BAKDATE ELSE
	IF .QUAL[QUAL_CREA] THEN FILDATE = INPUT_CREDATE ELSE
	IF .QUAL[QUAL_EXPI] THEN FILDATE = INPUT_EXPDATE ELSE
				 FILDATE = INPUT_REVDATE;
	END;


    ! BEFORE
    !
    IF .QUAL[QUAL_BEFO]
    THEN
	BEGIN
	IF .QUAL[QUAL_BEFO_BACK]
	    THEN CMDDATE = INPUT_BAKDATE
	    ELSE CMDDATE = QUAL[QUAL_BEFO_VALUE];
	IF .FILDATE[1] GTRU .CMDDATE[1] THEN RETURN FALSE;
	IF .FILDATE[1] EQLU .CMDDATE[1] AND .FILDATE[0] GEQU .CMDDATE[0] THEN RETURN FALSE;
	END;


    ! OWNER
    !
    IF .QUAL[QUAL_I_OWNE]
    THEN
	IF NOT (
	    (.QUAL[QUAL_I_OWN_WGRP] OR .INPUT_FILEOWNER<16,16> EQL .QUAL[QUAL_I_OWN_GRP]) AND
	    (.QUAL[QUAL_I_OWN_WMEM] OR .INPUT_FILEOWNER< 0,16> EQL .QUAL[QUAL_I_OWN_MEM]))
	THEN
	    RETURN FALSE;


    ! SINCE
    !
    IF .QUAL[QUAL_SINC]
    THEN
	BEGIN
	IF .QUAL[QUAL_SINC_BACK]
	    THEN CMDDATE = INPUT_BAKDATE
	    ELSE CMDDATE = QUAL[QUAL_SINC_VALUE];
	IF .FILDATE[1] LSSU .CMDDATE[1] THEN RETURN FALSE;
	IF .FILDATE[1] EQLU .CMDDATE[1] AND .FILDATE[0] LSSU .CMDDATE[0] THEN RETURN FALSE;
	END;
    END;


IF .TYPE<1,1>
THEN
    BEGIN

    ! EXCLUDE
    !
    IF .QUAL[QUAL_EXCL]
    THEN
	BEGIN
	LOCAL
	    RSA_DESC:	VECTOR[2],
	    EXCL:	REF BBLOCK;

	RSA_DESC[0] = .INPUT_NAM[NAM$B_RSL];
	RSA_DESC[1] = .INPUT_NAM[NAM$L_RSA];
	EXCL = .QUAL[QUAL_EXCL_LIST];
	WHILE .EXCL NEQ 0 DO
	    BEGIN
	    IF MATCH(RSA_DESC, EXCL[QUAL_EXCL_DESC]) THEN RETURN FALSE;
	    EXCL = .EXCL[QUAL_NEXT];
	    END;
	END;
    END;


IF .TYPE<2,1>
THEN
    BEGIN

    ! CONFIRM
    !
    IF .QUAL[QUAL_CONF]
    THEN
	BEGIN
	LOCAL
	    FAO_BUFFER:	VECTOR[256,BYTE],
	    FAO_DESC:	BBLOCK[8],
	    ANS_BUFFER:	VECTOR[8,BYTE],
	    ANS_DESC:	BBLOCK[8];

	FAO_DESC[DSC$W_LENGTH] = 256;
	FAO_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	FAO_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
	FAO_DESC[DSC$A_POINTER] = FAO_BUFFER;
	ANS_DESC[DSC$W_LENGTH] = 8;
	ANS_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ANS_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
	ANS_DESC[DSC$A_POINTER] = ANS_BUFFER;
	$FAO(
	    (IF .QUAL[QUAL_COMP]
	        THEN $DESCRIPTOR('!AD, compare? (Y or N): ')
	        ELSE $DESCRIPTOR('!AD, copy? (Y or N): ')),
	    FAO_DESC,
	    FAO_DESC,
	    .INPUT_NAM[NAM$B_RSL],
	    .INPUT_NAM[NAM$L_RSA]);
	LIB$GET_COMMAND(ANS_DESC, FAO_DESC);
	IF .ANS_BUFFER[0] NEQ %C'Y' AND .ANS_BUFFER[0] NEQ %C'y' THEN RETURN FALSE;
	END;
    END;


! Passes all tests, return true.
!
TRUE
END;

ROUTINE POSTPROCESS_FILES: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine records the backup date (/RECORD) or deletes (/DELETE)
!	each file successfully processed.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_PROC_LIST	- Pointer to head of list.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Backup date recorded or file deleted.
!
!--

BEGIN
LOCAL
	IN_QUAL:	REF BBLOCK,	! Pointer to current input qualifiers
	P:		REF BBLOCK,	! Pointer to file ID block
	Q:		REF BBLOCK,	! Pointer to file ID within block
	FIB:		BBLOCK[FIB$C_LENGTH],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


! Initialize.
!
IN_QUAL = 0;
FIB_DESC[0] = FIB$C_LENGTH;
FIB_DESC[1] = FIB;
IF .QUAL[QUAL_DELE]
    THEN SIGNAL(BACKUP$_STARTDELETE)
    ELSE SIGNAL(BACKUP$_STARTRECORD);


! Loop until file ID block list is empty.
!
WHILE .INPUT_PROC_LIST NEQ 0 DO
    BEGIN

    ! Remove the first file ID block from the list.
    !
    P = .INPUT_PROC_LIST;
    INPUT_PROC_LIST = .P[REC_NEXT];


    ! Reassign the channel if necessary.
    !
    IF .P[REC_QUAL] NEQ .IN_QUAL
    THEN
	BEGIN

	! Point to the current qualifiers block.
	!
	IN_QUAL = .P[REC_QUAL];


	! Assign the channel.
	!
	IF .INPUT_CHAN NEQ 0 THEN $DASSGN(CHAN=.INPUT_CHAN);
	STATUS = ASSIGN_INPUT_CHANNEL(IN_QUAL[QUAL_DEV_DESC], INPUT_CHAN, 0, 0);
	IF NOT .STATUS
	THEN
	    SIGNAL(
		BACKUP$_OPENOUT + STS$K_SEVERE, 1, IN_QUAL[QUAL_DEV_DESC],
		.STATUS);
	END;


    ! Loop over all entries within the block.
    !
    Q = P[REC_FID_BASE];
    DECR I FROM .P[REC_USED] TO 1 DO
	BEGIN
	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$W_FID_NUM] = .BBLOCK[Q[REC_FID], FID$W_NUM];
	FIB[FIB$W_FID_SEQ] = .BBLOCK[Q[REC_FID], FID$W_SEQ];
	FIB[FIB$W_FID_RVN] = .BBLOCK[Q[REC_FID], FID$W_RVN];


	IF .QUAL[QUAL_DELE]
	THEN
	    BEGIN
	    FIB[FIB$W_DID_NUM] = .BBLOCK[Q[REC_DID], FID$W_NUM];
	    FIB[FIB$W_DID_SEQ] = .BBLOCK[Q[REC_DID], FID$W_SEQ];
	    FIB[FIB$W_DID_RVN] = .BBLOCK[Q[REC_DID], FID$W_RVN];
	    FIB[FIB$V_FINDFID] = TRUE;


	    ! Issue the delete QIO to delete the specified file.
	    !
	    STATUS = $QIOW(
		FUNC=IO$_DELETE OR IO$M_DELETE,
		CHAN=.INPUT_CHAN,
		IOSB=IOSB,
		P1=FIB_DESC);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(
		    BACKUP$_DELETE,
		    4,
		    IN_QUAL[QUAL_DEV_DESC],
		    .FIB[FIB$W_FID_NUM] + .FIB[FIB$B_FID_NMX] ^ 16,
		    .FIB[FIB$W_FID_SEQ],
		    .FIB[FIB$B_FID_RVN],
		    .STATUS);
	    END
	ELSE
	    BEGIN

	    ! Issue the modify QIO to write the backup date of the specified
	    ! file.
	    !
	    STATUS = $QIOW(
		FUNC=IO$_MODIFY,
		CHAN=.INPUT_CHAN,
		IOSB=IOSB,
		P1=FIB_DESC,
		P5=UPLIT(
		    WORD(ATR$S_BAKDATE, ATR$C_BAKDATE),
		    LONG(JPI_DATE),
		    LONG(0)));
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		SIGNAL(
		    BACKUP$_WRITEBACK,
		    4,
		    IN_QUAL[QUAL_DEV_DESC],
		    .FIB[FIB$W_FID_NUM] + .FIB[FIB$B_FID_NMX] ^ 16,
		    .FIB[FIB$W_FID_SEQ],
		    .FIB[FIB$B_FID_RVN],
		    .STATUS);
	    END;


	! Advance to next entry.
	!
	Q = .Q + FID$C_LENGTH*2;
	END;


    ! Free the file ID block.
    !
    FREE_VM(REC_S_ENTRY, .P);
    END;


! Deassign the channel.
!
$DASSGN(CHAN=.INPUT_CHAN);
INPUT_CHAN = 0;
END;

ROUTINE SAVE_FILE_ID: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine adds an entry to the file ID list.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_PROC_LIST	- List head of list.
!	INPUT_NAM	- Contains file ID.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	File ID entered in structure.  New block may be allocated.
!
!--

BEGIN
LOCAL
	P:		REF BBLOCK,	! Pointer to block
	Q:		REF BBLOCK;	! Pointer to where FID is stored


P = .INPUT_PROC_LIST;
IF
    BEGIN
    IF .P EQL 0
    THEN
	TRUE
    ELSE
	.P[REC_USED] GEQU REC_MAX_COUNT OR
	.P[REC_QUAL] NEQ .INPUT_QUAL OR
	.P[REC_VOLUME] NEQ .RWSV_VOL_NUMBER
    END
THEN
    BEGIN
    INPUT_PROC_LIST = GET_VM(REC_S_ENTRY);
    INPUT_PROC_LIST[REC_NEXT] = .P;
    INPUT_PROC_LIST[REC_QUAL] = .INPUT_QUAL;
    INPUT_PROC_LIST[REC_USED] = 0;
    INPUT_PROC_LIST[REC_VOLUME] = .RWSV_VOL_NUMBER;
    P = .INPUT_PROC_LIST;
    END;


Q = P[REC_FID_BASE] + FID$C_LENGTH*2 * .P[REC_USED];
BBLOCK[Q[REC_FID], FID$W_NUM] = .INPUT_NAM[NAM$W_FID_NUM];
BBLOCK[Q[REC_FID], FID$W_SEQ] = .INPUT_NAM[NAM$W_FID_SEQ];
BBLOCK[Q[REC_FID], FID$W_RVN] = .INPUT_NAM[NAM$W_FID_RVN];
BBLOCK[Q[REC_DID], FID$W_NUM] = .INPUT_NAM[NAM$W_DID_NUM];
BBLOCK[Q[REC_DID], FID$W_SEQ] = .INPUT_NAM[NAM$W_DID_SEQ];
BBLOCK[Q[REC_DID], FID$W_RVN] = .INPUT_NAM[NAM$W_DID_RVN];
P[REC_USED] = .P[REC_USED] + 1;
END;

ROUTINE SAVE_ONE_FILE_HANDLER(SIG,MECH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is a condition handler for routine SAVE_ONE_FILE.  It
!	takes care of unwinding the stack when a failure to continue a save on
!	a continuation tape occurs.
!
! INPUT PARAMETERS:
!	SIG		- Standard VMS handler parameters
!	MECH		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_RESIGNAL
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SIG:		REF BBLOCK,	! Signal parameters
	MECH:		REF BBLOCK;	! Mechanism parameters


IF .SIG[CHF$L_SIG_NAME] EQL BACKUP$_CONTINUE
THEN
    BEGIN
    INPUT_FLAGS[EOV_SAVING] = FALSE;
    SIG[CHF$L_SIG_ARGS] = .SIG[CHF$L_SIG_ARGS] - 2;
    $PUTMSG(MSGVEC=.SIG, ACTRTN=PUTMSG_ACTRTN);
    $UNWIND();
    END;
SS$_RESIGNAL
END;

GLOBAL ROUTINE SAVE_ONE_FILE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This is the success routine for input file processing.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INPUT_FAB	- Pointer to the FAB.
!	INPUT_NAM	- Pointer to the NAM block.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	FIB:		BBLOCK[10],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	INPUT_HDR:	BBLOCK[512],	! Buffer for file header
	ATR_DESC:	BBLOCK[20],	! ACP attributes list
	STATBLK:	BBLOCK[SBK$C_LENGTH],	! Statistics block
	BLOCKS,				! Blocks of file to be copied
	ALWAYS_NOBACK:	BITVECTOR[32],	! Unconditionally NOBACKUP files
	STATUS,				! Status return
	IOSB:		VECTOR[4,WORD];	! I/O status block
BUILTIN
	FP;


! Establish the handler.
!
.FP = SAVE_ONE_FILE_HANDLER;


! Initialize the filename descriptor and the FIB.
!
EXTRACT_DIR_FILENAME(.INPUT_FAB, INPUT_NAMEDESC);
FIB[FIB$L_ACCTL] = FIB$M_NOWRITE;
INPUT_FLAGS[INPUT_IGNO_INTE] = FALSE;
IF
    .QUAL[QUAL_IGNO_INTE] OR
    (.INPUT_NAMEDESC[DSC$W_LENGTH] EQL %CHARCOUNT('[000000]QUOTA.SYS;1') AND
    CH$EQL(
	%CHARCOUNT('[000000]QUOTA.SYS;1'),
	UPLIT BYTE('[000000]QUOTA.SYS;1'),
	%CHARCOUNT('[000000]QUOTA.SYS;1'),
	.INPUT_NAMEDESC[DSC$A_POINTER]))
THEN
    BEGIN
    INPUT_FLAGS[INPUT_IGNO_INTE] = TRUE;
    FIB[FIB$L_ACCTL] = FIB$M_NOLOCK;
    END;
FIB[FIB$V_NORECORD] = TRUE;
FIB[FIB$W_FID_NUM] = .INPUT_NAM[NAM$W_FID_NUM];
FIB[FIB$W_FID_SEQ] = .INPUT_NAM[NAM$W_FID_SEQ];
FIB[FIB$W_FID_RVN] = .INPUT_NAM[NAM$W_FID_RVN];
FIB_DESC[0] = 10;
FIB_DESC[1] = FIB;


! Initialize the ACP attributes list.
!
ATR_DESC[0,0,16,0] = ATR$S_HEADER;
ATR_DESC[2,0,16,0] = ATR$C_HEADER;
ATR_DESC[4,0,32,0] = INPUT_HDR;
ATR_DESC[8,0,16,0] = SBK$C_LENGTH;
ATR_DESC[10,0,16,0] = ATR$C_STATBLK;
ATR_DESC[12,0,32,0] = STATBLK;
ATR_DESC[16,0,32,0] = 0;


! Access the file and read the file header.
!
STATUS = $QIOW(
    FUNC=IO$_ACCESS OR IO$M_ACCESS,
    CHAN=.INPUT_CHAN,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(
	BACKUP$_OPENIN + STS$K_ERROR,
	.INPUT_FAB,
	.STATUS);
    RETURN;
    END;
INPUT_FLAGS[INPUT_OPEN] = TRUE;


! Check for file opened under interlock.
!
IF .INPUT_FLAGS[INPUT_IGNO_INTE] AND .STATBLK[SBK$W_WCNT] NEQ 0
THEN
    FILE_ERROR(BACKUP$_ACCONFLICT, .INPUT_FAB);


! Put the attributes in normal format.
!
INPUT_STATBLK[SBK$L_STLBN] = ROT(.STATBLK[SBK$L_STLBN], 16);
INPUT_STATBLK[SBK$L_FILESIZE] = ROT(.STATBLK[SBK$L_FILESIZE], 16);


! Initialize the structure-independent attributes area.
!
INIT_ATTR(INPUT_HDR);


! Establish the number of blocks to be copied.  Copy up to the EOF block,
! except for other than sequential organization.
!
INPUT_BLOCK = 1;
INPUT_MAXBLOCK = ROT(.INPUT_RECATTR[FAT$L_EFBLK], 16);
IF .INPUT_RECATTR[FAT$W_FFBYTE] EQL 0
    THEN INPUT_MAXBLOCK = .INPUT_MAXBLOCK - 1;
IF
    .INPUT_MAXBLOCK GTRU .INPUT_STATBLK[SBK$L_FILESIZE] OR
    .INPUT_RECATTR[FAT$V_FILEORG] NEQ FAT$C_SEQUENTIAL
THEN
    INPUT_MAXBLOCK = .INPUT_STATBLK[SBK$L_FILESIZE];


! Get the file placement data.
!
IF .QUAL[QUAL_IMAG] THEN GET_PLC_DATA(INPUT_HDR);


! Evaluate the file selection criteria.
! If they fail, close the file and return.
!
IF 
    BEGIN
    IF .QUAL[QUAL_IMAG]
    THEN
	IF .QUAL[QUAL_VOLU]
	THEN
	    NOT .INPUT_FLAGS[INPUT_ON_RVN]
	ELSE
	    FALSE
    ELSE
	IF .QUAL[QUAL_FAST]
	THEN
	    NOT SELECT_INPUT_FILE(%B'100')
	ELSE
	    IF NOT SELECT_INPUT_FILE(%B'001')
	    THEN
		TRUE
	    ELSE
		NOT SELECT_INPUT_FILE(%B'100')
    END
THEN
    BEGIN
    STATUS = $QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.INPUT_CHAN,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_CLOSEIN + STS$K_ERROR,
	    .INPUT_FAB,
	    .STATUS);
    INPUT_FLAGS[INPUT_OPEN] = FALSE;
    RETURN;
    END;


! Note that a file was found.
! Increment the count of uses of this input filespec.
!
IF
    NOT .DIR_STATUS[D_STAT_VALID] OR
    .DIR_STATUS[D_STAT_DIR_SEL]
THEN
    COM_FLAGS[COM_FILESEEN] = TRUE;

INPUT_QUAL[QUAL_USE_COUNT] = .INPUT_QUAL[QUAL_USE_COUNT] + 1;


! Generate the file attribute record.
!
FILE_ATTRIBUTES(INPUT_HDR);


! Generate the journal record.
!
IF
    .QUAL[QUAL_JOUR] AND
    NOT .INPUT_FILECHAR[FCH$V_DIRECTORY]
THEN
    WRITE_JOUR_FILE();


! A file with the NOBACKUP attribute has its data copied only if the
! IGNORE=NOBACKUP qualifier is in effect.  Certain of the reserved files
! are ALWAYS implicitly NOBACKUP.  If warranted, copy the blocks.
!
ALWAYS_NOBACK = 1 ^ FID$C_INDEXF OR 1 ^ FID$C_BITMAP OR 1 ^ FID$C_BADBLK;
IF .INPUT_HDR[FH2$B_STRUCLEV] EQL 2 THEN ALWAYS_NOBACK[FID$C_BADLOG] = TRUE;
IF
    (NOT .INPUT_FILECHAR[FCH$V_NOBACKUP] OR
    .QUAL[QUAL_IGNO_NOBA])
AND NOT (
    .INPUT_NAM[NAM$W_FID_NUM] LEQU 15 AND
    .INPUT_NAM[NAM$B_FID_NMX] EQL 0 AND
    .ALWAYS_NOBACK[.INPUT_NAM[NAM$W_FID_NUM]])
THEN
    BEGIN
    IF .QUAL[QUAL_VOLU]
    THEN
	BEGIN
	LOCAL
	    VBN:	REF BBLOCK;

	VBN = .INPUT_VBN_LIST[0];
	WHILE .VBN NEQ INPUT_VBN_LIST[0] DO
	    BEGIN
	    INPUT_BLOCK = .VBN[VBN_FIRST];
	    INPUT_MAXBLOCK = .VBN[VBN_LAST];
	    UNTIL SAVE_BLOCKS() DO 0;
	    VBN = .VBN[PLC_FLINK];
	    END;
	END
    ELSE
	UNTIL SAVE_BLOCKS() DO 0;
    END;


! Free the placement data.
!
IF .QUAL[QUAL_IMAG] THEN FREE_PLC_BLOCKS();


! If doing a copy operation, close the output file (and verify it if this
! has been requested.)
!
IF .QUAL[QUAL_OF11]
THEN
    BEGIN
    SAVE_WRITE();
    CLOSE_RESTORE();
    END;


! Deaccess the file.
!
STATUS = $QIOW(
    FUNC=IO$_DEACCESS,
    CHAN=.INPUT_CHAN,
    IOSB=IOSB);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    FILE_ERROR(
	BACKUP$_CLOSEIN + STS$K_ERROR,
	.INPUT_FAB,
	.STATUS);
INPUT_FLAGS[INPUT_OPEN] = FALSE;


! If the LOG qualifier is in effect, log the file.
!
IF .QUAL[QUAL_LOG] AND NOT .QUAL[QUAL_OF11]
THEN
    FILE_ERROR(
	BACKUP$_COPIED,
	.INPUT_FAB);


! Record that the file was successfully processed if appropriate.  Note that
! /RECORD applies to a directory only if it was explicitly selected and that
! /DELETE never applies to a directory.
!
IF
    (.QUAL[QUAL_RECO] AND (.DIR_STATUS EQL 0 OR .DIR_STATUS[D_STAT_DIR_SEL]))
OR
    (.QUAL[QUAL_DELE] AND .DIR_STATUS EQL 0)
THEN
    SAVE_FILE_ID();
END;

ROUTINE PHYS_SAVE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine performs a physical save.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	INPUT_DEVCHAR:	BBLOCK[DIB$K_LENGTH],	! Device characteristics
	DESC:		VECTOR[2],		! Descriptor
	STATUS;					! Status variable


! Get device characteristics for the input device.
!
DESC[0] = DIB$K_LENGTH;
DESC[1] = INPUT_DEVCHAR;
STATUS = $GETCHN(CHAN=.INPUT_CHAN, PRIBUF=DESC);
IF NOT .STATUS
THEN
    FILE_ERROR(
	BACKUP$_GETCHN,
	.INPUT_FAB,
	.STATUS);


! Get the bad block data.
!
INPUT_BAD = GET_BADBLOCKS(.INPUT_FAB, .INPUT_CHAN, INPUT_DEVCHAR);


! Write the physical volume attribute record.
!
PHYSVOL_SUMMARY(INPUT_DEVCHAR);


! Compute how many blocks to copy.  If the disk is large, do not copy the last
! track.  Then, do the copy.
!
INPUT_BLOCK = 0;
INPUT_MAXBLOCK = .INPUT_DEVCHAR[DIB$L_MAXBLOCK] - 1;
IF .INPUT_DEVCHAR[DIB$L_MAXBLOCK] GTRU SMALL_DISK
THEN
    INPUT_MAXBLOCK = .INPUT_MAXBLOCK -
	.INPUT_DEVCHAR[DIB$B_SECTORS] /
	((.INPUT_DEVCHAR[DIB$B_SECTORS] *
	  .INPUT_DEVCHAR[DIB$B_TRACKS] *
	  .INPUT_DEVCHAR[DIB$W_CYLINDERS]) /
	  .INPUT_DEVCHAR[DIB$L_MAXBLOCK]);
UNTIL SAVE_BLOCKS() DO 0;


! If the output is Files-11, release a partially filled buffer to the output
! procedure.  This serves to synchronize input and output.  Then, if /VERIFY
! is in effect, do the verification.
!
IF .QUAL[QUAL_OF11]
THEN
    BEGIN
    SAVE_WRITE();
    CLOSE_RESTORE();
    END;


! Log the copy if requested.
!
IF .QUAL[QUAL_LOG] AND NOT .QUAL[QUAL_OF11]
THEN
    FILE_ERROR(
	BACKUP$_COPIED,
	.INPUT_FAB);
END;

GLOBAL ROUTINE RESTARTABLE_CONDITION(COND)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine evaluates whether the status value is eligible for a
!	restart and whether the last checkpoint was a valid one.
!
! INPUT PARAMETERS:
!	COND		- Condition value
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the condition is eligible for restart.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	COND:		BLOCK;		! Condition value
EXTERNAL LITERAL
	BACKUP$_WAITIDLEBCB,
	BACKUP$_BUFFERSLOST,
	BACKUP$_FREEBADBUFF,
	BACKUP$_ACTIVEBCB,
	BACKUP$_ALLOCMEM,
	BACKUP$_FREEMEM,
	BACKUP$_OPERFAIL,
	BACKUP$_MAXVOLS,
	BACKUP$_PROCINDEX;
BIND
	TABLE = PLIT(
	    BACKUP$_WAITIDLEBCB,
	    BACKUP$_BUFFERSLOST,
	    BACKUP$_FREEBADBUFF,
	    BACKUP$_ACTIVEBCB,
	    BACKUP$_ALLOCMEM,
	    BACKUP$_FREEMEM,
	    BACKUP$_OPERFAIL,
	    BACKUP$_MAXVOLS,
	    BACKUP$_PROCINDEX)
	: VECTOR;


IF
    .COND[STS$V_SEVERITY] EQL STS$K_SEVERE AND
    .COND[STS$V_FAC_NO] EQL BACKUP$_FACILITY AND
    NOT .COM_FLAGS[COM_DSBL_RSTRT] AND
    (DECR X FROM .TABLE[-1]-1 TO 0 DO
	IF .COND EQL .TABLE[.X] THEN EXITLOOP FALSE)
THEN
    TRUE
ELSE
    FALSE
END;

ROUTINE SAVE_HANDLER(SIG,MECH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is established as a handler for routine SAVE.  It
!	determines the recovery from a fatal signal.
!
! INPUT PARAMETERS:
!	SIG		- Standard VMS condition handler parameters.
!	MECH		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	VMS status code (SS$_CONTINUE or SS$_RESIGNAL).
!	However, if REEL_RESTART is called by GET_RESTART,
!	control never returns.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SIG:		REF BBLOCK,	! Signal parameters
	MECH:		REF BBLOCK;	! Mechanism parameters


IF RESTARTABLE_CONDITION(.SIG[CHF$L_SIG_NAME])
THEN
    BEGIN
    IF
	.SIG[CHF$L_SIG_NAME] EQL BACKUP$_WRITERRS OR
	.SIG[CHF$L_SIG_NAME] EQL BACKUP$_FATALERR
    THEN
	IF .RWSV_VOL_NUMBER EQL 1
	THEN
	    GET_RESTART(.SIG, %B'10')
	ELSE
	    GET_RESTART(.SIG, %B'11')
    ELSE
	IF .RWSV_VOL_NUMBER EQL 1
	THEN
	    RETURN SS$_RESIGNAL
	ELSE
	    GET_RESTART(.SIG, %B'01');


    RETURN SS$_CONTINUE;
    END;


SS$_RESIGNAL
END;

GLOBAL ROUTINE SAVE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine saves Files-11 media on backup media.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	FP;


CHKPT_HIGH_SP = .FP;			! Save upper stack region address
IF .QUAL[QUAL_OSAV]
THEN
    BEGIN
    !
    ! Initialize for a save.
    !
    .FP = SAVE_HANDLER;			! Establish handler
    INIT_BUFFERS(
	.QUAL[QUAL_BUFF_VALUE] + (.QUAL[QUAL_GROU_VALUE] NEQ 0),
	.QUAL[QUAL_BLOC_VALUE]);
    INIT_OUT_SAVE(FALSE);
    IF .QUAL[QUAL_JOUR]
    THEN
	BEGIN
	WRITE_JOUR_SSNAME();
	WRITE_JOUR_VOLUME();
	END;
    END
ELSE
    BEGIN
    !
    ! Initialize for a copy or a Files-11 to Files-11 compare.
    !
    INIT_BUFFERS(
	(IF .QUAL[QUAL_COMP] OR .QUAL[QUAL_VERI]
	    THEN COPY_BUFF_COUNT*2
	    ELSE COPY_BUFF_COUNT), 
	COPY_BUFF_SIZE);
    INIT_RESTORE();
    RWSV_SAVE_QUAL = .QUAL[QUAL_OUTP_LIST];
    END;


! Generate the backup summary record.  If this is an image save, it is done by
! ODSn_VOLUME_ATTRIBUTES on the first call, because we need some information
! from the home block.
!
IF NOT .QUAL[QUAL_IMAG] THEN BACKUP_SUMMARY();


! Loop over all input specifications.
!
INPUT_QUAL = .QUAL[QUAL_INPU_LIST];
INPUT_NAM = 0;
WHILE .INPUT_QUAL NEQ 0 DO
    BEGIN
    LOCAL
	STATUS;


    ! Establish pointers to the interesting control blocks.
    ! Strip everything but the device from the expanded string.
    !
    INPUT_FAB = .INPUT_QUAL[QUAL_PARA_FC];
    INPUT_NAM = INPUT_FAB[FC_NAM];
    INPUT_NAM[NAM$B_ESL] = .BBLOCK[INPUT_QUAL[QUAL_DEV_DESC], DSC$W_LENGTH];


    ! Assign a channel to the input device.
    !
    STATUS = ASSIGN_INPUT_CHANNEL(INPUT_QUAL[QUAL_DEV_DESC], INPUT_CHAN, 0, 0);
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_OPENIN + STS$K_SEVERE,
	    .INPUT_FAB,
	    .STATUS);


    IF .QUAL[QUAL_PHYS]
    THEN
	PHYS_SAVE()
    ELSE
	BEGIN
	COM_FLAGS[COM_FILESEEN] = FALSE;
	IF .QUAL[QUAL_FAST]
	    THEN FAST_FILE_SCAN()
	    ELSE SLOW_FILE_SCAN();
	IF NOT .COM_FLAGS[COM_FILESEEN]
	THEN
	    SIGNAL(BACKUP$_NOFILES, 1, INPUT_QUAL[QUAL_EXP_DESC]);
	END;


    ! Deassign the input channel.
    !
    $DASSGN(CHAN=.INPUT_CHAN);
    INPUT_CHAN = 0;


    IF .COM_FLAGS[COM_STANDALONE] THEN EXITLOOP;
    INPUT_QUAL = .INPUT_QUAL[QUAL_NEXT];
    END;


! Finish up.
!
SAVE_WRITE();
IF .QUAL[QUAL_OSAV]
THEN
    BEGIN
    IF .QUAL[QUAL_JOUR]
    THEN
	BEGIN
	WRITE_JOUR_DIRECTORY();
	WRITE_JOUR_VOLUME();
	WRITE_JOUR_SSNAME();
	END;
    FIN_OUT_SAVE(FALSE);
    END
ELSE
    FIN_RESTORE();


! Postprocess successfully processed files if requested.
!
IF .QUAL[QUAL_RECO] OR .QUAL[QUAL_DELE]
THEN
    POSTPROCESS_FILES();
END;

END
ELUDOM
