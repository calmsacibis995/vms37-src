MODULE RESTORE	(%TITLE	'Restore a save set'
		IDENT = 'V03-005'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Backup/Restore
!
! ABSTRACT:
!	This module contains the routines that restore a save set.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 03-Sep-1980
!
! MODIFIED BY:
!
!	V03-005	MLJ0089		Martin L. Jack,	22-Apr-1982  23:27
!		Repair /CONFIRM for copy operation and extra directories.
!
!	V03-004	MLJ43240	Martin L. Jack,	6-Apr-1982  2:46
!		Avoid spurious EOFMISMATCH messages on a restore verify pass.
!
!	V03-003	ACG0277		Andrew C. Goldstein,	30-Mar-1982  16:55
!		Add BACKUP$_SSCHANGE to list of continuable errors
!
!	V03-002	MLJ0084		Martin L. Jack,	28-Mar-1982  1:08
!		Update the backup date of a directory file that was scanned
!		during a /INCREMENTAL restore to record that it represents the
!		most recent version.  Readjust the order of operations so that
!		/OWNER=PARENT with an implicit directory creation works.
!
!	V03-001	MLJ0082		Martin L. Jack,	16-Mar-1982  13:27
!		Correct /OWNER=PARENT problem introduced by V02-018.  Extend
!		NOFILES message to contain save set name string.
!
!	V02-020	MLJ0075		Martin L. Jack,	28-Jan-1982  20:35
!		Use FIB$V_NORECORD.  Implement version limit handling via
!		DIR_VERLIM and VERLIMIT attributes.
!
!	V02-019	MLJ0072		Martin L. Jack,	19-Jan-1982  3:42
!		Extend if existing file opened under /OVERLAY is too small.
!
!	V02-018	MLJ42936	Martin L. Jack,	5-Jan-1982  19:40
!		Create files initially with the correct owner UIC to avoid
!		temporarily consuming (and possibly exceeding) the disk quota
!		of the process executing a restore.
!
!	V02-017	MLJ0062		Martin L. Jack,	2-Dec-1981  13:12
!		Implement /INCREMENTAL.  Avoid spurious VBNMISSING error on
!		tape verify pass.
!
!	V02-016	MLJ0054		Martin L. Jack,	15-Oct-1981  19:54
!		Attempt non-contiguous create if contiguous create fails.
!		Implement /VOLUME.  Implement /IGNORE=INTERLOCK.  Correct
!		V02-014 to include EFBLK.
!
!	V02-015	MLJ0053		Martin L. Jack,	7-Oct-1981  19:27
!		Rework algorithm in CHECK_EOF_BLOCK.
!
!	V02-014	MLJ0048		Martin L. Jack,	28-Sep-1981  13:14
!		Read attributes before IO$_MODIFY since standalone ACP
!		no longer protects HIBLK.
!
!	V02-013	MLJ0040		Martin L. Jack,	3-Sep-1981  19:37
!		Correct message following IO$_CREATE.
!
!	V02-012	MLJ0036		Martin L. Jack,	29-Aug-1981  16:09
!		Extensive rewriting to complete implementation.
!
!	V02-011	MLJ0025		Martin L. Jack,	8-May-1981  14:00
!		Reorganize qualifier database.  Correct problem with explicit
!		directory creation introduced by V02-009.
!
!	V02-010	MLJ0024		Martin L. Jack,	27-Apr-1981  20:25
!		Remove dynamic LOCAL_SAVE area, since it can now be local.
!
!	V02-009	MLJ0022		Martin L. Jack,	21-Apr-1981  13:54
!		Convert directory wildcarding to use RMS.
!
!	V02-008	MLJ0021		Martin L. Jack,	20-Apr-1981  22:04
!		Implement /TRUNCATE qualifier.
!
!	V02-007	MLJ0019		Martin L. Jack,	7-Apr-1981  22:23
!		Correct tests for continuation tape verify pass.
!
!	V02-006	MLJ0018		Martin L. Jack,	7-Apr-1981  21:09
!		Correct signal parameters.
!
!	V02-005	MLJ0014		Martin L. Jack,	6-Apr-1981  23:27
!		Correct and clarify VBN sequence-error messages and
!		avoid spurious EOFMISMATCH messages on tape verify pass.
!
!	V02-004	MLJ0012		Martin L. Jack,	27-Mar-1981  16:14
!		Produce both CREATED and COMPARED messages for copy with verify
!
!	V02-003	MLJ0010		Martin L. Jack,	25-Mar-1981  17:29
!		Reorganize global storage.  Changes for standalone operation.
!		Implement image restore.  Implement listing concurrent with
!		another operation.
!
!	V02-002	MLJ0003		Martin L. Jack,	17-Feb-1981  18:36
!		Correct handling of DNF in compare operation
!
!	V02-001	MLJ0002		Martin L. Jack,	14-Feb-1981  12:23
!		Correct file selection in restore operation verify pass
!
!**

REQUIRE 'SRC$:COMMON';
LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'LIB$:BACKDEF';


FORWARD ROUTINE
	INCREMENTAL_DELETE:
			NOVALUE,	! Conditionally delete file
	INCREMENTAL_SCAN:
			NOVALUE,	! Execute wildcard access on directory
	ASSIGN_VERIFY_CHANNEL:
			NOVALUE,	! Assign channel to input device for verify
	COMPARE_BLOCKS:	NOVALUE,	! Compare two files
	GET_ACP_ATTRIBUTES:
			NOVALUE,	! Convert OUTPUT_ATTBUF for write attributes
	GET_PARENT_UIC,			! Get owner UIC of parent directory
	CLOSE_RESTORE:	NOVALUE,	! Close output file
	FIN_RESTORE:	NOVALUE,	! Finish restore operation
	SELECT_FILE,			! Evaluate output selection criteria
	CHECK_EOF_BLOCK:NOVALUE,	! Check EOF position in a compare
	CREATE_DIRECTORY:
			NOVALUE,	! Create a directory
	IMPLICIT_DIRECTORY,		! Implicitly create a directory (DNF)
	INITIALIZE_AND_SELECT,		! Initialize FAB and select file
	SELECT_INCREMENTAL,		! File selection for /INCREMENTAL mode
	INCREMENTAL_DIRECTORY:
			NOVALUE,	! Directory processing for /INCREMENTAL
	CREATE_OR_OPEN_FILE:
			NOVALUE,	! Open output file
	RESTORE_ERROR:	NOVALUE,	! Handle asynchronous write errors
	RESTORE_ONE_RECORD:
			NOVALUE,	! Process one save set buffer
	RESTORE_VERIFY_REEL:
			NOVALUE,	! Driver for restore verify
	INIT_RESTORE:	NOVALUE,	! Initialize restore module
	RESTORE_HANDLER,		! Handler for RESTORE, LIST, ANALYZE
	RESTORE:	NOVALUE;	! Driver for restore


EXTERNAL ROUTINE
	LIB$CVT_DTB:	ADDRESSING_MODE(GENERAL),
					! Convert text to binary
	LIB$GET_COMMAND:ADDRESSING_MODE(GENERAL),
					! Get line from SYS$COMMAND
	ASSIGN_INPUT_CHANNEL,		! Assign channel to input device
	ASSIGN_OUTPUT_CHANNEL,		! Assign channel to output device
	CREATE_DIR,			! Create a directory
	DEBLOCK:	NOVALUE,	! Deblock save set buffer
	FILE_ERROR:	NOVALUE,	! Signal file-related error
	FIND_BADBLOCK,			! Search for LBN in bad block table
	FREE_BUFFER:	NOVALUE,	! Free buffer
	GET_BADBLOCKS,			! Get bad block information
	GET_BUFFER,			! Get buffer
	GET_SUMMARY_ATTRIBUTES:
			NOVALUE,	! Get backup summary attributes
	GET_VOLUME_ATTRIBUTES:
			NOVALUE,	! Get volume attributes
	GET_FILE_ATTRIBUTES:
			NOVALUE,	! Get file attributes
	GET_PHYSVOL_ATTRIBUTES:
			NOVALUE,	! Get physical volume attributes
	INIT_NAMEBLOCK:	NOVALUE,	! Initialize extended name block fields
	MATCH,				! Match file specifications
	RESTARTABLE_CONDITION,		! Test if condition is restartable
	STA_INIVOL:	NOVALUE,	! Initialize output volume
	STA_INIT_HDRS:	NOVALUE,	! Initialize output file headers
	STA_DISMOUNT_OUTPUT:
			NOVALUE,	! Finish file structure on volume
	STA_WRITEBOOT:	NOVALUE,	! Write boot file LBN into boot block
	WAIT:		NOVALUE,	! Wait for I/O operation in buffer
	WILD_DIRECTORY:	NOVALUE,	! Generate output wildcard directory
	GET_RESTART:	NOVALUE;	! Get restart option


EXTERNAL LITERAL
	BACKUP$_FACILITY,
	BACKUP$_OPENIN,
	BACKUP$_OPENOUT,
	BACKUP$_CLOSEIN,
	BACKUP$_CLOSEOUT,
	BACKUP$_COMPARED,
	BACKUP$_CREATED,
	BACKUP$_CREDIRERR,
	BACKUP$_CREDIR,
	BACKUP$_VBNMISSING,
	BACKUP$_VBNERROR,
	BACKUP$_VBNPASTEOF,
	BACKUP$_FIDERROR,
	BACKUP$_READATTR,
	BACKUP$_GETCHN,
	BACKUP$_WRITEATTR,
	BACKUP$_READBLOCK,
	BACKUP$_WRITEBLOCK,
	BACKUP$_READERR,
	BACKUP$_WRITEERR,
	BACKUP$_FATALERR,
	BACKUP$_VERIFYERR,
	BACKUP$_BADDATA,
	BACKUP$_PHYDEVGEO,
	BACKUP$_BADBLOCK,
	BACKUP$_EOFMISMATCH,
	BACKUP$_CONTINUE,
	BACKUP$_INVATTSTR,
	BACKUP$_NOFILES,
	BACKUP$_STARTVERIFY,
	BACKUP$_NONCONTIG,
	BACKUP$_NOSUCHRVN,
	BACKUP$_INVATTVAL,
	BACKUP$_INCDELETE,
	BACKUP$_INCDELERR,
	BACKUP$_INCENTERR,
	BACKUP$_INCBADDIR;


G$DEFINE();		! Define global common area


BIND
	OUTPUT_FILENAME=	OUTPUT_ATTBUF[FAR_FILENAME]: BBLOCK,
	OUTPUT_RECATTR=		OUTPUT_ATTBUF[FAR_RECATTR]: BBLOCK,
	OUTPUT_FILECHAR=	OUTPUT_ATTBUF[FAR_UCHAR]: BBLOCK,
	OUTPUT_PLACEMENT=	OUTPUT_ATTBUF[FAR_PLACEMENT]: BBLOCK;


OWN
	INCR_FIB:	BBLOCK[FIB$C_LENGTH],		! FIB for wildcarding
	INCR_RSA:	VECTOR[DIR$S_NAME+6,BYTE],	! Resultant string
	INCR_RSS,			! Size of entire resultant string
	INCR_NTS,			! Size of "name.typ" portion
	INCR_VER,			! Binary version number
	INCR_BAKDATE:	VECTOR[2];	! Backup date


BUILTIN
	INSQUE,
	REMQUE,
	ROT;

ROUTINE INCREMENTAL_DELETE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine conditionally deletes a file that is cataloged in a
!	directory involved in a /INCREMENTAL restore.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INCR_FIB, INCR_RSA, INCR_RSS, INCR_BAKDATE.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	If the backup date of the file is nonzero and is earlier than the
!	creation date of the save set, the file is deleted.
!
!--

BEGIN
IF
    (.INCR_BAKDATE[0] OR .INCR_BAKDATE[1]) NEQ 0 AND
    (.INCR_BAKDATE[1] LSSU .COM_O_BSRDATE[1] OR
    (.INCR_BAKDATE[1] EQL .COM_O_BSRDATE[1] AND
	.INCR_BAKDATE[0] LSSU .COM_O_BSRDATE[0]))
THEN
    BEGIN
    LOCAL
	STATUS,					! General status variable
	IOSB:		VECTOR[4,WORD],		! I/O status block
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	FIB:		BBLOCK[FIB$C_LENGTH],	! FIB
	FNA_DESC:	VECTOR[2],		! Descriptor for filename
	RSA_DESC:	VECTOR[2],		! Descriptor for RSA
	RSA:		VECTOR[NAM$C_MAXRSS,BYTE]; ! Resultant string


    ! Construct a "resultant string" by concatenating the device and directory
    ! specification, which is in the name block expanded string, with the
    ! file name string.
    !
    FNA_DESC[0] = .INCR_RSS;
    FNA_DESC[1] = INCR_RSA;
    RSA_DESC[0] = NAM$C_MAXRSS;
    RSA_DESC[1] = RSA;
    $FAO(
	$DESCRIPTOR('!AD!AS'),
	RSA_DESC,
	RSA_DESC,
	.OUTPUT_NAM[NAM$B_ESL], .OUTPUT_NAM[NAM$L_ESA],
	FNA_DESC);


    ! Set up for and delete the file.
    !
    FIB_DESC[0] = FIB$C_LENGTH;
    FIB_DESC[1] = FIB;
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_FID_NUM] = .INCR_FIB[FIB$W_FID_NUM];
    FIB[FIB$W_FID_SEQ] = .INCR_FIB[FIB$W_FID_SEQ];
    FIB[FIB$W_FID_RVN] = .INCR_FIB[FIB$W_FID_RVN];
    FIB[FIB$W_DID_NUM] = .INCR_FIB[FIB$W_DID_NUM];
    FIB[FIB$W_DID_SEQ] = .INCR_FIB[FIB$W_DID_SEQ];
    FIB[FIB$W_DID_RVN] = .INCR_FIB[FIB$W_DID_RVN];
    STATUS = $QIOW(
	FUNC=IO$_DELETE OR IO$M_DELETE,
	CHAN=.OUTPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC,
	P2=FNA_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];


    ! If warranted, report an error or log the deletion if requested.
    !
    IF NOT .STATUS
    THEN
	SIGNAL(BACKUP$_INCDELERR, 1, RSA_DESC, .STATUS)
    ELSE
	IF .QUAL[QUAL_LOG]
	THEN
	    SIGNAL(BACKUP$_INCDELETE, 1, RSA_DESC);
    END;		
END;

ROUTINE INCREMENTAL_SCAN: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes a wildcard IO$_ACCESS on a directory involved
!	in a /INCREMENTAL restore.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	INCR_FIB, INCR_RSA, INCR_RSS.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	INCR_FIB, INCR_RSA, INCR_RSS, INCR_NTS, INCR_VER, INCR_BAKDATE.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	FNA_DESC:	VECTOR[2],		! Descriptor for filename
	FNA:		VECTOR[5,BYTE],		! Filename
	STATUS,					! General status variable
	IOSB:		VECTOR[4,WORD];		! I/O status block


FIB_DESC[0] = FIB$C_LENGTH;
FIB_DESC[1] = INCR_FIB;
FNA_DESC[0] = 5;
FNA_DESC[1] = FNA;
(FNA[0])<0,32> = '*.*;';  FNA[4] = '*';
STATUS = $QIOW(
    FUNC=IO$_ACCESS,
    CHAN=.OUTPUT_CHAN,
    IOSB=IOSB,
    P1=FIB_DESC,
    P2=FNA_DESC,
    P3=INCR_RSS,
    P4=UPLIT(DIR$S_NAME+6, INCR_RSA),
    P5=UPLIT(
	WORD(ATR$S_BAKDATE, ATR$C_BAKDATE),
	INCR_BAKDATE,
	0));
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    INCR_RSS = 0;
    IF .STATUS NEQ SS$_NOMOREFILES AND .STATUS NEQ SS$_NOSUCHFILE
    THEN
	FILE_ERROR(BACKUP$_READATTR, .OUTPUT_FAB, .STATUS);
    END
ELSE
    BEGIN
    LOCAL
	T;

    INCR_VER = 0;
    INCR_NTS = .INCR_RSS;
    T = CH$FIND_CH(.INCR_RSS, INCR_RSA, %C';');
    IF .T NEQ 0
    THEN
	BEGIN
	INCR_NTS = .T - INCR_RSA;
	LIB$CVT_DTB(INCR_RSA + .INCR_RSS - (.T + 1), .T + 1, INCR_VER);
	END;
    END;    
END;

ROUTINE ASSIGN_VERIFY_CHANNEL(NEW_FILE): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine assigns a channel to the input disk during a save set
!	verification pass.
!
! INPUT PARAMETERS:
!	NEW_FILE	- True if a new file is being started, false if this
!			  is the initialization call.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS;				! Status variable


IF .NEW_FILE
THEN
    BEGIN

    ! A file attribute record is being processed.  Determine whether a device
    ! change occurred when this file was saved, and if one did, reassign the
    ! channel.
    !
    IF .QUAL[QUAL_OF11] THEN RETURN;
    VERIFY_USE_COUNT = .VERIFY_USE_COUNT + 1;
    IF .VERIFY_USE_COUNT LEQ .VERIFY_QUAL[QUAL_USE_COUNT] THEN RETURN;

    WHILE .VERIFY_USE_COUNT GTR .VERIFY_QUAL[QUAL_USE_COUNT] DO
	BEGIN
	IF .VERIFY_QUAL[QUAL_NEXT] NEQ 0	! Protection
	    THEN VERIFY_QUAL = .VERIFY_QUAL[QUAL_NEXT];
	VERIFY_USE_COUNT = 1;
	END;
    END
ELSE
    BEGIN

    ! Initialization.  Reassign the channel that was assigned at the conclusion
    ! of the previous verify pass.  If this is the first, assign the channel to
    ! the first input device, but do not count a file, since no file is being
    ! processed.
    !
    IF .VERIFY_QUAL EQL 0
    THEN
	BEGIN
	VERIFY_QUAL = .QUAL[QUAL_INPU_LIST];
	VERIFY_USE_COUNT = 0;
	END;
    END;


! Assign a channel to the device.
!
IF .OUTPUT_CHAN NEQ 0 THEN $DASSGN(CHAN=.OUTPUT_CHAN);
STATUS = ASSIGN_INPUT_CHANNEL(VERIFY_QUAL[QUAL_DEV_DESC], OUTPUT_CHAN, 0, 0);
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(
	BACKUP$_OPENIN + STS$K_SEVERE, 1, VERIFY_QUAL[QUAL_DEV_DESC],
	.STATUS);
    END;
END;

ROUTINE COMPARE_BLOCKS: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine verifies blocks.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STARTED_BLOCK,			! Last block on which a read is started
	FINISHED_BLOCK,			! Last block on which a read is done
	BLOCKS,				! Number of block to compare
	RING_A:		VECTOR[2],	! Buffer queue for file A
	RING_B:		VECTOR[2];	! Buffer queue for file B


! Initialize.
!
STARTED_BLOCK = FINISHED_BLOCK = 1;
IF .QUAL[QUAL_PHYS] THEN STARTED_BLOCK = FINISHED_BLOCK = 0;
BLOCKS = .BBLOCK[.FREE_LIST[0], BCB_SIZE] / 512;


! Form two rings of buffers.  Each ring contains half the buffers.
! Start a read in each buffer.
!
RING_A[0] = RING_A[1] = RING_A;
RING_B[0] = RING_B[1] = RING_B;
DECR I FROM .COM_BUFF_COUNT/2 TO 1 DO
    BEGIN
    LOCAL
	BCB:		REF BBLOCK,	! Pointer to BCB
	N,				! Number of blocks to read this pass
	STATUS;				! Status variable


    IF .STARTED_BLOCK GTRU .INPUT_MAXBLOCK THEN EXITLOOP;


    ! Compute the number of blocks to transfer.
    !
    N = .BLOCKS;
    IF .N GTRU .INPUT_MAXBLOCK + 1 - .STARTED_BLOCK
	THEN N = .INPUT_MAXBLOCK + 1 - .STARTED_BLOCK;


    ! Start a read for file A.
    !
    BCB = GET_BUFFER();
    STATUS = $QIO(
	FUNC=.INPUT_FUNC,
	CHAN=.INPUT_CHAN,
	EFN=BCB_S_READ,
	IOSB=BCB[BCB_IOSB],
	P1=.BCB[BCB_BUFFER],
	P2=.N*512,
	P3=.STARTED_BLOCK);
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_READERR + STS$K_SEVERE,
	    .INPUT_FAB,
	    .STATUS);
    BCB[BCB_SUCC_ACT] = 0;
    BCB[BCB_FAIL_ACT] = 0;
    BCB[BCB_STATE] = BCB_S_READ;
    INSQUE(.BCB, .RING_A[1]);


    ! Start a read for file B.
    !
    BCB = GET_BUFFER();
    STATUS = C$QIO(
	FUNC=.INPUT_FUNC,
	CHAN=.OUTPUT_CHAN,
	EFN=BCB_S_REREAD,
	IOSB=BCB[BCB_IOSB],
	P1=.BCB[BCB_BUFFER],
	P2=.N*512,
	P3=.STARTED_BLOCK);
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_READERR + STS$K_SEVERE,
	    .OUTPUT_FAB,
	    .STATUS);
    BCB[BCB_SUCC_ACT] = 0;
    BCB[BCB_FAIL_ACT] = 0;
    BCB[BCB_STATE] = BCB_S_REREAD;
    INSQUE(.BCB, .RING_B[1]);


    ! Note that these blocks have been started.
    !
    STARTED_BLOCK = .STARTED_BLOCK + .N;
    END;


! Loop to wait on the first read of each ring, compare it, and reissue.
!
UNTIL .FINISHED_BLOCK GTRU .INPUT_MAXBLOCK DO
    BEGIN
    LOCAL
	N,				! Number of blocks read this pass
	STATUS,				! Status variable
	BCB_A:		REF BBLOCK,	! BCB for buffer in ring A
	BCB_B:		REF BBLOCK;	! BCB for buffer in ring B


    ! Compute the number of blocks in this transfer.
    !
    N = .BLOCKS;
    IF .N GTRU .INPUT_MAXBLOCK + 1 - .FINISHED_BLOCK
	THEN N = .INPUT_MAXBLOCK + 1 - .FINISHED_BLOCK;


    ! Wait on the read for file A.  If there is an error, redo the read one
    ! block at a time reporting the errors.
    !
    REMQUE(.RING_A[0], BCB_A);
    WAIT(.BCB_A);
    IF NOT .BCB_A[BCB_IO_STATUS]
    THEN
	BEGIN
	INCR I FROM 0 TO .N-1 DO
	    BEGIN
	    STATUS = $QIOW(
		FUNC=.INPUT_FUNC,
		CHAN=.INPUT_CHAN,
		IOSB=BCB_A[BCB_IOSB],
		P1=.BCB_A[BCB_BUFFER] + .I*512,
		P2=512,
		P3=.FINISHED_BLOCK + .I);
	    IF .STATUS THEN STATUS = .BCB_A[BCB_IO_STATUS];
	    IF NOT .STATUS THEN IF NOT FIND_BADBLOCK(.INPUT_BAD, .FINISHED_BLOCK + .I)
	    THEN
		FILE_ERROR(
		    BACKUP$_READBLOCK,
		    .INPUT_FAB,
		    .FINISHED_BLOCK + .I,
		    .STATUS);
	    END;
	END;


    ! Wait on the read for file B.  If there is an error, redo the read one
    ! block at a time reporting the errors.
    !
    REMQUE(.RING_B[0], BCB_B);
    WAIT(.BCB_B);
    IF NOT .BCB_B[BCB_IO_STATUS]
    THEN
	BEGIN
	INCR I FROM 0 TO .N-1 DO
	    BEGIN
	    STATUS = C$QIOW(
		FUNC=.INPUT_FUNC,
		CHAN=.OUTPUT_CHAN,
		IOSB=BCB_B[BCB_IOSB],
		P1=.BCB_B[BCB_BUFFER] + .I*512,
		P2=512,
		P3=.FINISHED_BLOCK + .I);
	    IF .STATUS THEN STATUS = .BCB_B[BCB_IO_STATUS];
	    IF NOT .STATUS THEN IF NOT FIND_BADBLOCK(.OUTPUT_BAD, .FINISHED_BLOCK + .I)
	    THEN
		FILE_ERROR(
		    BACKUP$_READBLOCK,
		    .OUTPUT_FAB,
		    .FINISHED_BLOCK + .I,
		    .STATUS);
	    END;
	END;

    ! Compare the data.
    !
    INCR I FROM 0 TO .N-1 DO
	BEGIN
	IF CH$NEQ(
	    512, .BCB_A[BCB_BUFFER]+.I*512,
	    512, .BCB_B[BCB_BUFFER]+.I*512)
	THEN
	    IF NOT FIND_BADBLOCK(.INPUT_BAD, .FINISHED_BLOCK + .I)
	    THEN
		FILE_ERROR(
		    BACKUP$_VERIFYERR,
		    .OUTPUT_FAB,
		    .FINISHED_BLOCK + .I);
	END;


    ! Note that these blocks have been finished.
    !
    FINISHED_BLOCK = .FINISHED_BLOCK + .N;


    ! If we are done, free the buffers.
    !
    IF .STARTED_BLOCK GTRU .INPUT_MAXBLOCK
    THEN
	BEGIN
	FREE_BUFFER(.BCB_A);
	FREE_BUFFER(.BCB_B);
	END
    ELSE
	BEGIN

	! Compute number of blocks to transfer in next pass.
	!
	N = .BLOCKS;
	IF .N GTRU .INPUT_MAXBLOCK + 1 - .STARTED_BLOCK
	    THEN N = .INPUT_MAXBLOCK + 1 - .STARTED_BLOCK;


	! Start the next read for file A.
	!
	STATUS = $QIO(
	    FUNC=.INPUT_FUNC,
	    CHAN=.INPUT_CHAN,
	    EFN=BCB_S_READ,
	    IOSB=BCB_A[BCB_IOSB],
	    P1=.BCB_A[BCB_BUFFER],
	    P2=.N*512,
	    P3=.STARTED_BLOCK);
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_READERR + STS$K_SEVERE,
		.INPUT_FAB,
		.STATUS);
	BCB_A[BCB_SUCC_ACT] = 0;
	BCB_A[BCB_FAIL_ACT] = 0;
	BCB_A[BCB_STATE] = BCB_S_READ;
	INSQUE(.BCB_A, .RING_A[1]);


	! Start the next read for file B.
	!
	STATUS = C$QIO(
	    FUNC=.INPUT_FUNC,
	    CHAN=.OUTPUT_CHAN,
	    EFN=BCB_S_REREAD,
	    IOSB=BCB_B[BCB_IOSB],
	    P1=.BCB_B[BCB_BUFFER],
	    P2=.N*512,
	    P3=.STARTED_BLOCK);
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_READERR + STS$K_SEVERE,
		.OUTPUT_FAB,
		.STATUS);
	BCB_B[BCB_SUCC_ACT] = 0;
	BCB_B[BCB_FAIL_ACT] = 0;
	BCB_B[BCB_STATE] = BCB_S_REREAD;
	INSQUE(.BCB_B, .RING_B[1]);


	! Note that these blocks have been started.
	!
	STARTED_BLOCK = .STARTED_BLOCK + .N;
	END;
    END;
END;

ROUTINE GET_ACP_ATTRIBUTES(ATR_LIST): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine generates the ACP attribute list.
!
! INPUT PARAMETERS:
!	ATR_LIST	- Pointer to receiving buffer.
!
! IMPLICIT INPUTS:
!	OUTPUT_ATTBUF	- Attributes for output file.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LITERAL
	ATR$S_ASCDATES = 2; ! Only write 2 bytes of ASCDATES for revision count
MACRO
	GEN_ATTR_LIST[A,B]=
	    .ATR = %NAME('ATR$S_', A) + %NAME('ATR$C_', A)^16;
	    ATR = .ATR + 4;
	    .ATR = B;
	    ATR = .ATR + 4 %;
LOCAL
	ATR;			! Pointer to attribute list


! Build the attribute descriptor list.
!
ATR = .ATR_LIST;
GEN_ATTR_LIST(
    FPRO,	OUTPUT_ATTBUF[FAR_FPRO],
    RPRO,	OUTPUT_ATTBUF[FAR_RPRO],
    ACLEVEL,	OUTPUT_ATTBUF[FAR_ACLEVEL],
    UCHAR,	OUTPUT_ATTBUF[FAR_UCHAR],
    RECATTR,	OUTPUT_ATTBUF[FAR_RECATTR]);
IF .(OUTPUT_ATTBUF[FAR_CREDATE]) NEQ 0
THEN
    BEGIN
    GEN_ATTR_LIST(
	CREDATE,	OUTPUT_ATTBUF[FAR_CREDATE]);
    END;
IF .(OUTPUT_ATTBUF[FAR_REVDATE]) NEQ 0
THEN
    BEGIN
    GEN_ATTR_LIST(
	REVDATE,	OUTPUT_ATTBUF[FAR_REVDATE],
	ASCDATES,	OUTPUT_ATTBUF[FAR_REVISION]);
    END;
IF .(OUTPUT_ATTBUF[FAR_EXPDATE]) NEQ 0
THEN
    BEGIN
    GEN_ATTR_LIST(
	EXPDATE,	OUTPUT_ATTBUF[FAR_EXPDATE]);
    END;
IF .QUAL[QUAL_RECO] OR .QUAL[QUAL_INCR]
THEN
    BEGIN
    GEN_ATTR_LIST(
	BAKDATE,	COM_O_BSRDATE);
    END
ELSE
    IF .(OUTPUT_ATTBUF[FAR_BAKDATE]) NEQ 0
    THEN
	BEGIN
	GEN_ATTR_LIST(
	    BAKDATE,	OUTPUT_ATTBUF[FAR_BAKDATE]);
	END;
GEN_ATTR_LIST(
    UIC,		OUTPUT_ATTBUF[FAR_UIC]);
.ATR = 0;
END;

ROUTINE GET_PARENT_UIC=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine gets the parent UIC.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	The parent's UIC.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	DEV_DESC:	VECTOR[2],	! Device name descriptor
	CHANNEL,			! Channel
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD], ! I/O status block
	FIB:		BBLOCK[10],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	UIC,				! Return location for UIC
	ATR_DESC:	BBLOCK[12];	! ACP attribute list


! Assign a channel to the device.
!
DEV_DESC[0] = .OUTPUT_NAM[NAM$B_DEV];
DEV_DESC[1] = .OUTPUT_NAM[NAM$L_DEV];
STATUS = ASSIGN_OUTPUT_CHANNEL(DEV_DESC, CHANNEL, 0, 0);
IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(
	BACKUP$_READATTR,
	.OUTPUT_FAB,
	.STATUS);
    RETURN .JPI_UIC;
    END;


! Initialize the FIB.
!
FIB[FIB$L_ACCTL] = 0;
FIB[FIB$W_FID_NUM] = .OUTPUT_NAM[NAM$W_DID_NUM];
FIB[FIB$W_FID_SEQ] = .OUTPUT_NAM[NAM$W_DID_SEQ];
FIB[FIB$W_FID_RVN] = .OUTPUT_NAM[NAM$W_DID_RVN];
FIB_DESC[0] = 10;
FIB_DESC[1] = FIB;


! Initialize the ACP attribute list.
!
ATR_DESC[0,0,16,0] = ATR$S_UIC;
ATR_DESC[2,0,16,0] = ATR$C_UIC;
ATR_DESC[4,0,32,0] = UIC;
ATR_DESC[8,0,32,0] = 0;


! Execute the read attributes.
!
STATUS = $QIOW(
    FUNC=IO$_ACCESS,
    CHAN=.CHANNEL,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(
	BACKUP$_READATTR,
	.OUTPUT_FAB,
	.STATUS);
    UIC = .JPI_UIC;
    END;


! Deassign the channel.
!
$DASSGN(CHAN=.CHANNEL);


! Return the UIC.
!
.UIC
END;

GLOBAL ROUTINE CLOSE_RESTORE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finishes an open output file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
IF .OUTPUT_FLAGS[OUTPUT_INCR_DIR]
THEN
    BEGIN
    LOCAL
	FIB:		BBLOCK[FIB$C_LENGTH],	! FIB
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	STATUS,					! Status return
	IOSB:		VECTOR[4,WORD];		! I/O status block


    ! Process files in the directory that appear after the last entry in the
    ! saved copy of the directory.
    !
    WHILE .INCR_RSS NEQ 0 DO
	BEGIN
	INCREMENTAL_DELETE();
	INCREMENTAL_SCAN();
	END;


    ! Update the directory's backup date.
    !
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$L_ACCTL] = FIB$M_WRITE;
    FIB[FIB$W_FID_NUM] = .INCR_FIB[FIB$W_DID_NUM];
    FIB[FIB$W_FID_SEQ] = .INCR_FIB[FIB$W_DID_SEQ];
    FIB[FIB$W_FID_RVN] = .INCR_FIB[FIB$W_DID_RVN];
    FIB_DESC[0] = FIB$C_LENGTH;
    FIB_DESC[1] = FIB;
    STATUS = $QIOW(
	FUNC=IO$_MODIFY,
	CHAN=.OUTPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC,
	P5=UPLIT(
	    WORD(ATR$S_BAKDATE, ATR$C_BAKDATE),
	    COM_O_BSRDATE,
	    0));
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_WRITEATTR,
	    .OUTPUT_FAB,
	    .STATUS);

	    
    OUTPUT_FLAGS[OUTPUT_INCR_DIR] = FALSE;
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    END;


IF .OUTPUT_FLAGS[OUTPUT_OPEN]
THEN
    BEGIN
    LOCAL
	BCB:		REF BBLOCK,	! Pointer to BCB
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


    ! Wait for all pending writes to complete.
    !
    UNTIL REMQUE(.OUTPUT_WAIT[0], BCB) DO
	BEGIN
	WAIT(.BCB);
	FREE_BUFFER(.BCB);
	END;


    ! Make sure we got all the data records we were expecting.  Accept an error
    ! if this is the end of a tape verify pass, since the file may legitimately
    ! be incomplete.  Also, allow a number of blocks greater than what we were
    ! expecting, since a message has already been issued in this case.  Accept
    ! an error if /VOLUME is specified.  If the file was implicitly opened, we
    ! do not know the end-of-file block, so the error must be accepted.
    !
    IF
	NOT .QUAL[QUAL_VOLU] AND
	NOT .OUTPUT_FLAGS[OUTPUT_V_LAST] AND
	NOT .OUTPUT_FLAGS[OUTPUT_IMPLICIT] AND
	.OUTPUT_BLOCK LEQU .OUTPUT_MAXBLOCK AND
	.OUTPUT_BLOCK NEQ 1
    THEN
	FILE_ERROR(
	    BACKUP$_VBNMISSING,
	    .OUTPUT_FAB,
	    .OUTPUT_BLOCK, .OUTPUT_MAXBLOCK);


    ! If verification is enabled on a Files-11 to Files-11 operation, do it.
    !
    IF .QUAL[QUAL_IF11] AND .QUAL[QUAL_OF11] AND .QUAL[QUAL_VERI]
    THEN
	BEGIN

	! Log the file creation.
	!
	IF .QUAL[QUAL_LOG]
	THEN
	    FILE_ERROR(
		BACKUP$_CREATED, .OUTPUT_FAB);


	! Log verify pass.  Only do this for /PHYSICAL; otherwise there would
	! be a completely excessive number.
	!
	IF .QUAL[QUAL_PHYS] THEN SIGNAL(BACKUP$_STARTVERIFY);


	! Do the verification.
	!
	IF NOT .OUTPUT_FILECHAR[FCH$V_NOBACKUP] OR .OUTPUT_BLOCK NEQ 1
	THEN
	    COMPARE_BLOCKS();
	END;


    ! Write the attributes of the new file.
    !
    IF NOT .QUAL[QUAL_PHYS] AND NOT .QUAL[QUAL_COMP] AND NOT .QUAL[QUAL_IMAG]
    THEN
	BEGIN
	LOCAL
	    OLD_RECATTR:	BBLOCK[FAT$C_LENGTH],	! Existing attributes
	    FAT_ATR_LIST:	BBLOCK[12],		! ACP attribute list
	    ATR_LIST:		VECTOR[14*2 + 1];	! New attribute list


	! Build the attribute descriptor list.
	!
	GET_ACP_ATTRIBUTES(ATR_LIST);


	! Read the record attributes.  This is required because HIBLK may be
	! incorrect in the save set record attributes due to cluster factor
	! difference in the old and new media.
	!
	FAT_ATR_LIST[0,0,16,0] = ATR$S_RECATTR;
	FAT_ATR_LIST[2,0,16,0] = ATR$C_RECATTR;
	FAT_ATR_LIST[4,0,32,0] = OLD_RECATTR;
	FAT_ATR_LIST[8,0,32,0] = 0;
	STATUS = $QIOW(
	    FUNC=IO$_ACCESS,
	    CHAN=.OUTPUT_CHAN,
	    IOSB=IOSB,
	    P5=FAT_ATR_LIST);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_READATTR,
		.OUTPUT_FAB,
		.STATUS);


	! Copy HIBLK to the new record attributes.
	!
	OUTPUT_RECATTR[FAT$L_HIBLK] = .OLD_RECATTR[FAT$L_HIBLK];


	! Write the record attributes.
	!
	STATUS = $QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.OUTPUT_CHAN,
	    IOSB=IOSB,
	    P5=ATR_LIST);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_WRITEATTR,
		.OUTPUT_FAB,
		.STATUS);
	END;


    ! Depending on the operation, do nothing, issue a deaccess, or issue a
    ! deassign channel.
    !
    IF .COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV]
    THEN
	BEGIN
	IF .QUAL[QUAL_PHYS]
	THEN
	    STATUS = TRUE
	ELSE
	    BEGIN
	    STATUS = $QIOW(
		FUNC=IO$_DEACCESS,
		CHAN=.OUTPUT_CHAN,
		IOSB=IOSB);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    END
	END
    ELSE IF .QUAL[QUAL_IMAG]
    THEN
	BEGIN
	STATUS = C$QIOW(
	    FUNC=IO$_DEACCESS,
	    CHAN=.OUTPUT_CHAN,
	    IOSB=IOSB);
	IF .STATUS THEN STATUS = .IOSB[0];
	END
    ELSE
	BEGIN
	STATUS = $DASSGN(CHAN=.OUTPUT_CHAN);
	OUTPUT_CHAN = 0;
	END;


    ! If the close failed, issue an appropriate message.  Also log the
    ! operation if requested.
    !
    IF .QUAL[QUAL_COMP]
    THEN
	BEGIN
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_CLOSEIN + STS$K_ERROR,
		.OUTPUT_FAB,
		.STATUS);
	IF .QUAL[QUAL_LOG]
	THEN
	    FILE_ERROR(
		BACKUP$_COMPARED, .OUTPUT_FAB);
	END
    ELSE
	BEGIN
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_CLOSEOUT + STS$K_ERROR,
		.OUTPUT_FAB,
		.STATUS);
	IF .QUAL[QUAL_LOG]
	THEN
	    FILE_ERROR(
		(IF .QUAL[QUAL_IF11] AND .QUAL[QUAL_OF11] AND .QUAL[QUAL_VERI]
		    THEN BACKUP$_COMPARED	! Log the verification
		    ELSE BACKUP$_CREATED),
		.OUTPUT_FAB);
	END;
	

    ! Note that no output file is open.
    !
    OUTPUT_FLAGS[OUTPUT_OPEN] = FALSE;
    OUTPUT_FLAGS[OUTPUT_IMPLICIT] = FALSE;
    END;
END;

GLOBAL ROUTINE FIN_RESTORE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finishes a restore or compare operation.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Close the output file if one is open.
!
CLOSE_RESTORE();


! Free the compare buffer if one was allocated.
!
IF .QUAL[QUAL_COMP]
THEN
    BEGIN
    FREE_BUFFER(.COMPARE_BCB);
    COMPARE_BCB = 0;
    END;


! If this is a save verify pass, deassign the channel.
!
IF .COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV]
THEN
    BEGIN
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    END;


! If this is an image restore, finish the file structure on the output
! volumes.
!
IF .QUAL[QUAL_IMAG] AND NOT .QUAL[QUAL_COMP]
    THEN STA_DISMOUNT_OUTPUT();
END;

ROUTINE SELECT_FILE(OUTPUT_SEL_DESC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine evaluates selection criteria for a file retrieved from
!	an input save set.
!
! INPUT PARAMETERS:
!	OUTPUT_SEL_DESC - Pointer to descriptor that will be initialized with
!			  selection filespec if /SELECT qualifier matches.
!
! IMPLICIT INPUTS:
!	OUTPUT_FAB	- Pointer to the FAB.
!	OUTPUT_NAM	- Pointer to the NAM block.
!	OUTPUT_ATTBUF	- The attributes from the save set.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the file meets the selection criteria, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	OUTPUT_SEL_DESC:REF VECTOR;	! Pointer to descriptor
LOCAL
	CMDDATE:	REF VECTOR,	! Pointer to command selection date
	FILDATE:	REF VECTOR;	! Pointer to file selection date


IF .QUAL[QUAL_BEFO] OR .QUAL[QUAL_SINC]
THEN
    BEGIN
    IF .QUAL[QUAL_BACK] THEN FILDATE = OUTPUT_ATTBUF[FAR_BAKDATE] ELSE
    IF .QUAL[QUAL_CREA] THEN FILDATE = OUTPUT_ATTBUF[FAR_CREDATE] ELSE
    IF .QUAL[QUAL_EXPI] THEN FILDATE = OUTPUT_ATTBUF[FAR_EXPDATE] ELSE
			     FILDATE = OUTPUT_ATTBUF[FAR_REVDATE];
    END;


! BEFORE
!
IF .QUAL[QUAL_BEFO]
THEN
    BEGIN
    IF .QUAL[QUAL_BEFO_BACK]
	THEN CMDDATE = OUTPUT_ATTBUF[FAR_BAKDATE]
	ELSE CMDDATE = QUAL[QUAL_BEFO_VALUE];
    IF .FILDATE[1] GTRU .CMDDATE[1] THEN RETURN FALSE;
    IF .FILDATE[1] EQLU .CMDDATE[1] AND .FILDATE[0] GEQU .CMDDATE[0] THEN RETURN FALSE;
    END;


! EXCLUDE
!
IF .QUAL[QUAL_EXCL]
THEN
    BEGIN
    LOCAL
	EXCL:		REF BBLOCK;

    EXCL = .QUAL[QUAL_EXCL_LIST];
    WHILE .EXCL NEQ 0 DO
	BEGIN
	IF MATCH(OUTPUT_FILENAME, EXCL[QUAL_EXCL_DESC]) THEN RETURN FALSE;
	EXCL = .EXCL[QUAL_NEXT];
	END;
    END;


! SELECT
!
IF .QUAL[QUAL_SELE]
THEN
    BEGIN
    LOCAL
	SELE:		REF BBLOCK;

    SELE = .QUAL[QUAL_SELE_LIST];
    IF
	BEGIN
	WHILE .SELE NEQ 0 DO
	    BEGIN
	    IF MATCH(OUTPUT_FILENAME, SELE[QUAL_SELE_DESC])
	    THEN
		BEGIN
		OUTPUT_SEL_DESC[0] = .BBLOCK[SELE[QUAL_SELE_DESC], DSC$W_LENGTH];
		OUTPUT_SEL_DESC[1] = .BBLOCK[SELE[QUAL_SELE_DESC], DSC$A_POINTER];
		EXITLOOP FALSE;
		END;
	    SELE = .SELE[QUAL_NEXT];
	    END
	END
    THEN
	RETURN FALSE;
    END;


! OWNER
!
IF .QUAL[QUAL_I_OWNE]
THEN
    IF NOT (
	(.QUAL[QUAL_I_OWN_WGRP] OR .OUTPUT_ATTBUF[FAR_UICGROUP]  EQL .QUAL[QUAL_I_OWN_GRP]) AND
	(.QUAL[QUAL_I_OWN_WMEM] OR .OUTPUT_ATTBUF[FAR_UICMEMBER] EQL .QUAL[QUAL_I_OWN_MEM]))
    THEN
	RETURN FALSE;


! SINCE
!
IF .QUAL[QUAL_SINC]
THEN
    BEGIN
    IF .QUAL[QUAL_SINC_BACK]
	THEN CMDDATE = OUTPUT_ATTBUF[FAR_BAKDATE]
	ELSE CMDDATE = QUAL[QUAL_SINC_VALUE];
    IF .FILDATE[1] LSSU .CMDDATE[1] THEN RETURN FALSE;
    IF .FILDATE[1] EQLU .CMDDATE[1] AND .FILDATE[0] LSSU .CMDDATE[0] THEN RETURN FALSE;
    END;


! VOLUME
!


! Passes all tests, return true.
!
TRUE
END;

ROUTINE CHECK_EOF_BLOCK: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called when a file to be compared has been opened to
!	check the EOF position of the file against the EOF position from the
!	save set.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	FAT_BUFFER:	BBLOCK[FAT$C_LENGTH],	! Local buffer for attributes
	SBK_BUFFER:	BBLOCK[8],	! Local buffer for statistics block
	STATUS,				! Status return
	IOSB:		VECTOR[4,WORD],	! I/O status block
	ATR_LIST:	BBLOCK[20];	! Read attributes parameter


! Initialize the read attributes parameter.
!
ATR_LIST[0,0,16,0] = ATR$S_RECATTR;
ATR_LIST[2,0,16,0] = ATR$C_RECATTR;
ATR_LIST[4,0,32,0] = FAT_BUFFER;
ATR_LIST[8,0,16,0] = 8;
ATR_LIST[10,0,16,0] = ATR$C_STATBLK;
ATR_LIST[12,0,32,0] = SBK_BUFFER;
ATR_LIST[16,0,32,0] = 0;


! Read attributes of the file to be compared.
!
STATUS = C$QIOW(
    FUNC=IO$_ACCESS,
    CHAN=.OUTPUT_CHAN,
    IOSB=IOSB,
    P5=ATR_LIST);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(
	BACKUP$_READATTR,
	.OUTPUT_FAB,
	.STATUS);
    RETURN;
    END;


! Check the EOF block against that determined from the file attribute record.
! However, if this is the first record of a continuation tape verify pass, it
! cannot be checked.  In this case, the true EFBLK is not available from the
! file attributes.  Further, if this is a restore verify pass, it cannot be
! checked, because the EFBLK may not yet have been written.
!
IF
    (NOT .OUTPUT_FLAGS[OUTPUT_V_FIRST] OR
    NOT .COM_FLAGS[COM_VERIFYING] OR
    .BBLOCK[.OUTPUT_BCB[BCB_BUFFER], BBH$W_VOLNUM] LEQ 1)
AND
    NOT (.COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OF11])
THEN
    BEGIN
    LOCAL
	INPUT_EOF,			! End of file block from compare file
	SAVE_SET_EOF;			! End of file block from save set


    ! Compute the two EOF block values.
    !
    INPUT_EOF = ROT(.FAT_BUFFER[FAT$L_EFBLK], 16);
    IF .FAT_BUFFER[FAT$W_FFBYTE] EQL 0
	THEN INPUT_EOF = .INPUT_EOF - 1;
    SAVE_SET_EOF = ROT(.OUTPUT_RECATTR[FAT$L_EFBLK], 16);
    IF .OUTPUT_RECATTR[FAT$W_FFBYTE] EQL 0
	THEN SAVE_SET_EOF = .SAVE_SET_EOF - 1;


    IF .INPUT_EOF NEQ .SAVE_SET_EOF
    THEN
	FILE_ERROR(
	    BACKUP$_EOFMISMATCH,
	    .OUTPUT_FAB);
    END;


! Limit the highest block to be compared by the allocated size of the compare
! file.
!
OUTPUT_MAXBLOCK = MINU(.OUTPUT_MAXBLOCK, ROT(.SBK_BUFFER[SBK$L_FILESIZE], 16));
END;

ROUTINE CREATE_DIRECTORY: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine creates a directory in response to a file attribute
!	record describing a directory file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	FILE_ID:	BBLOCK[FID$C_LENGTH],	! File ID of directory
	BAKDATE:	VECTOR[2],		! Backup date of directory
	DESC:		VECTOR[2],		! Descriptor for directory
	OWNER,					! Owner UIC
	STATUS;					! Status variable


! Indicate that a file was seen.
!
COM_FLAGS[COM_FILESEEN] = TRUE;


! Assign a channel to the output volume.
!
DESC[0] = .OUTPUT_NAM[NAM$B_DEV];
DESC[1] = .OUTPUT_NAM[NAM$L_DEV];
STATUS = ASSIGN_OUTPUT_CHANNEL(DESC, OUTPUT_CHAN, 0, 0);
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(BACKUP$_OPENOUT + STS$K_ERROR, 1, DESC, .STATUS);
    RETURN;
    END;


! The expanded string is either of the form dev:[dir1.dir2]dir3.DIR;1, which
! we must transform to dev:[dir1.dir2.dir3] for input to CREATE_DIR, or of the
! form dev:[000000]dir1.DIR;1, which we transform to dev:[dir1].
!
VECTOR[.OUTPUT_NAM[NAM$L_TYPE], 0; ,BYTE] =
    .VECTOR[.OUTPUT_NAM[NAM$L_NAME], -1; ,BYTE];
IF
    .OUTPUT_NAM[NAM$B_DIR] EQL 8 AND
    CH$FIND_NOT_CH(6, .OUTPUT_NAM[NAM$L_DIR]+1, %C'0') EQL 0
THEN
    BEGIN
    CH$MOVE(
	.OUTPUT_NAM[NAM$B_NAME]+1,
	.OUTPUT_NAM[NAM$L_NAME],
	.OUTPUT_NAM[NAM$L_DIR]+1);    
    DESC[0] = .OUTPUT_NAM[NAM$B_DEV] + .OUTPUT_NAM[NAM$B_NAME] + 2;
    END
ELSE
    BEGIN
    VECTOR[.OUTPUT_NAM[NAM$L_NAME], -1; ,BYTE] = %C'.';
    DESC[0] = .OUTPUT_NAM[NAM$L_TYPE] - .OUTPUT_NAM[NAM$L_DEV] + 1;
    END;
OUTPUT_NAM[NAM$B_ESL] = .DESC[0];
DESC[1] = .OUTPUT_NAM[NAM$L_DEV];


! Determine the owner UIC of the created directory according to the output
! qualifiers.
!
OWNER = .JPI_UIC;
IF .QUAL[QUAL_O_OWN_ORIG] THEN OWNER = .OUTPUT_ATTBUF[FAR_UIC];
IF .QUAL[QUAL_O_OWN_PARE] THEN OWNER = 0;
IF .QUAL[QUAL_O_OWN_UIC]  THEN OWNER = .QUAL[QUAL_O_OWN_VALU];


! Create the directory.
!
STATUS = CREATE_DIR(
    DESC,
    .OWNER,
    .OUTPUT_ATTBUF[FAR_FPRO],
    .OUTPUT_RECATTR[FAT$W_VERSIONS],
    FILE_ID,
    BAKDATE);
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(
	BACKUP$_CREDIRERR, 1, DESC,
	.STATUS);
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    RETURN;
    END;


! Log the creation if requested.
!
IF .QUAL[QUAL_LOG] AND .STATUS EQL SS$_CREATED
THEN
    SIGNAL(
	BACKUP$_CREDIR, 1, DESC);


! Check for special /INCREMENTAL processing of saved directory contents that
! takes place if the creation date of the save set is equal to or later than
! the backup date of the directory.
!
IF
    .QUAL[QUAL_INCR] AND
    .OUTPUT_ATTBUF[FAR_STRUCLEVB] EQL 2 AND
    .COM_O_BSRDATE[1] GTRU .BAKDATE[1] OR
	(.COM_O_BSRDATE[1] EQL .BAKDATE[1] AND
	    .COM_O_BSRDATE[0] GEQU .BAKDATE[0])
THEN
    BEGIN
    OUTPUT_FLAGS[OUTPUT_INCR_DIR] = TRUE;
    CH$FILL(0, FIB$C_LENGTH, INCR_FIB);
    INCR_FIB[FIB$W_DID_NUM] = .FILE_ID[FID$W_NUM];
    INCR_FIB[FIB$W_DID_SEQ] = .FILE_ID[FID$W_SEQ];
    INCR_FIB[FIB$W_DID_RVN] = .FILE_ID[FID$W_RVN];
    INCREMENTAL_SCAN();
    END
ELSE
    BEGIN
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    END;
END;

ROUTINE IMPLICIT_DIRECTORY=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine creates a directory when a "directory not found" status
!	is returned from creating a file.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the directory was created, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	BAKDATE:	VECTOR[2],		! Backup date of directory
	STATUS,					! Status variable
	OWNER,					! Owner UIC
	DESC:		VECTOR[2];		! Descriptor for directory


! Assign a channel to the output volume.
!
DESC[0] = .OUTPUT_NAM[NAM$B_DEV];
DESC[1] = .OUTPUT_NAM[NAM$L_DEV];
STATUS = ASSIGN_OUTPUT_CHANNEL(DESC, OUTPUT_CHAN, 0, 0);
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(BACKUP$_OPENOUT + STS$K_ERROR, 1, DESC, .STATUS);
    RETURN FALSE;
    END;


! The expanded string is of the form dev:[dir1.dir2.dir3]name.typ;ver.
! We must strip the components following the directory specification.
!
DESC[0] = .OUTPUT_NAM[NAM$L_NAME] - .OUTPUT_NAM[NAM$L_DEV];
DESC[1] = .OUTPUT_NAM[NAM$L_DEV];


! Determine the owner UIC of the created directory according to the output
! qualifiers.
!
OWNER = .JPI_UIC;

IF .QUAL[QUAL_O_OWN_ORIG]
THEN
    BEGIN
    OWNER = .OUTPUT_ATTBUF[FAR_DIR_UIC];
    IF .OWNER EQL 0 THEN OWNER = .OUTPUT_ATTBUF[FAR_UIC];
    END;

IF .QUAL[QUAL_O_OWN_PARE]
THEN
    OWNER = 0;

IF .QUAL[QUAL_O_OWN_UIC]
THEN
    OWNER = .QUAL[QUAL_O_OWN_VALU];


! Create the directory.  Since this is an implicit creation, we use the
! parent ownership, protection, and default version limit recorded in the
! file attributes.
!
STATUS = CREATE_DIR(
    DESC,
    .OWNER,
    .OUTPUT_ATTBUF[FAR_DIR_FPRO],
    .OUTPUT_ATTBUF[FAR_DIR_VERLIM],
    OUTPUT_NAM[NAM$W_DID],
    BAKDATE);


$DASSGN(CHAN=.OUTPUT_CHAN);
OUTPUT_CHAN = 0;


IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(
	BACKUP$_CREDIRERR, 1, DESC,
	.STATUS);
    RETURN FALSE;
    END;


! Log the creation if requested.
!
IF .QUAL[QUAL_LOG] AND .STATUS EQL SS$_CREATED
THEN
    SIGNAL(
	BACKUP$_CREDIR, 1, DESC);


TRUE
END;

ROUTINE INITIALIZE_AND_SELECT=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes the FAB and executes the file selection for a
!	file open.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the file is selected, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	OUTPUT_SEL_DESC:VECTOR[2];	! Descriptor for selection filespec


! Always select the file during a save verify pass.  Thus all files that were
! saved will be verified.
!
IF .COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV]
THEN
    RETURN TRUE;


! If this is image mode, always select the file, except that for a compare or
! verify operation, the initial files are never selected.  If this is a single-
! volume restore, select the file only if there is a segment on the RVN.
!
IF .QUAL[QUAL_IMAG]
THEN
    BEGIN
    LOCAL
	PLC:		REF BBLOCK,	! Cursor for placement data
	PLC_END;			! Pointer beyond placement data


    IF
	.QUAL[QUAL_COMP] AND
	.OUTPUT_ATTBUF[FAR_FID_NMX] EQL 0 AND
	(.OUTPUT_ATTBUF[FAR_FID_NUM] LEQU FID$C_BADBLK OR
	    (.OUTPUT_ATTBUF[FAR_STRUCLEVB] EQL 2 AND
	    .OUTPUT_ATTBUF[FAR_FID_NUM] EQL FID$C_BADLOG))
    THEN
	RETURN FALSE;


    IF
	NOT .QUAL[QUAL_VOLU] OR
	.OUTPUT_ATTBUF[FAR_FID_RVN] EQL .QUAL[QUAL_VOLU_VALUE]
    THEN
	RETURN TRUE;


    PLC = .OUTPUT_PLACEMENT[DSC$A_POINTER];
    PLC_END = .PLC + .OUTPUT_PLACEMENT[DSC$W_LENGTH];
    WHILE .PLC LSSA .PLC_END DO
	BEGIN
	LOCAL
	    TYPE;

	TYPE = .(.PLC)<0,8>;
	PLC = .PLC + 1;

	CASE .TYPE FROM BSA$K_PLC_FID TO BSA$K_PLC_PLLBN OF
	    SET

	    [BSA$K_PLC_FID]:
		BEGIN
		IF .PLC[FID$B_RVN] EQL .QUAL[QUAL_VOLU_VALUE] THEN RETURN TRUE;
		PLC = .PLC + BSA$S_PLC_FID;
		END;

	    [BSA$K_PLC_COUNT]:
		PLC = .PLC + BSA$S_PLC_COUNT;

	    [BSA$K_PLC_PLACE]:
		PLC = .PLC + BSA$S_PLC_PLACE;

 	    [BSA$K_PLC_PLLBN]:
		PLC = .PLC + BSA$S_PLC_PLLBN;

	    [OUTRANGE]:
		BEGIN
		SIGNAL(BACKUP$_INVATTVAL);
		RETURN FALSE;
		END;

	    TES;
	END;
    RETURN FALSE;
    END;


! This is not a save verify pass, and it is not image mode.
! Never restore or compare reserved files.
!
IF
    .OUTPUT_ATTBUF[FAR_FID_NMX] EQL 0 AND
    .OUTPUT_ATTBUF[FAR_FID_NUM] LEQU
	(IF .OUTPUT_ATTBUF[FAR_STRUCLEVB] EQL 1 THEN 5 ELSE 9)
THEN
    RETURN FALSE;


! Initialize the FAB in preparation for the $PARSE.
!
OUTPUT_FAB[FAB$V_MXV] = OUTPUT_FAB[FAB$V_CIF] = OUTPUT_FAB[FAB$V_SUP] = FALSE;
OUTPUT_NAM[NAM$B_RSL] = 0;
OUTPUT_NAM[NAM$B_ESL] = 0;
OUTPUT_FAB[FAB$V_UFO] = TRUE;
OUTPUT_FAB[FAB$V_OFP] = TRUE;
OUTPUT_FAB[FAB$B_ORG] = 0;
IF .QUAL[QUAL_INCR]
THEN
    BEGIN
    OUTPUT_FAB[FAB$B_DNS] = %CHARCOUNT('[*...];*');
    OUTPUT_FAB[FAB$L_DNA] = UPLIT BYTE('[*...];*');
    OUTPUT_FAB[FAB$V_SUP] = TRUE;
    END
ELSE
    BEGIN
    OUTPUT_FAB[FAB$B_DNS] = %CHARCOUNT(';*');
    OUTPUT_FAB[FAB$L_DNA] = UPLIT BYTE(';*');
    IF .QUAL[QUAL_NEWV] THEN OUTPUT_FAB[FAB$V_MXV] = TRUE;
    IF .QUAL[QUAL_OVER] THEN OUTPUT_FAB[FAB$V_CIF] = TRUE;
    IF .QUAL[QUAL_REPL] THEN OUTPUT_FAB[FAB$V_SUP] = TRUE;
    END;


! Set the allocation size, and select the contiguous and contiguous-best-try
! option according to the saved file characteristics.
!
OUTPUT_FAB[FAB$V_CTG] = OUTPUT_FAB[FAB$V_CBT] = FALSE;
IF .OUTPUT_FILECHAR[FCH$V_CONTIG] THEN OUTPUT_FAB[FAB$V_CTG] = TRUE;
IF .OUTPUT_FILECHAR[FCH$V_CONTIGB] THEN OUTPUT_FAB[FAB$V_CBT] = TRUE;
OUTPUT_FAB[FAB$L_ALQ] = .OUTPUT_ATTBUF[FAR_FILESIZE];


! If this is a restore operation, evaluate the input file selection criteria to
! determine if the file should be restored.  If it is a copy operation, the
! input file selection criteria have already been evaluated.  In any case,
! establish the file specification that selected the file for the use of the
! wildcard directory routine.
!
IF .QUAL[QUAL_ISAV]
THEN
    BEGIN
    OUTPUT_SEL_DESC[0] = %CHARCOUNT('[*]');
    OUTPUT_SEL_DESC[1] = UPLIT BYTE('[*]');
    IF NOT .QUAL[QUAL_INCR] THEN IF NOT SELECT_FILE(OUTPUT_SEL_DESC) THEN RETURN FALSE;
    END
ELSE
    BEGIN
    OUTPUT_SEL_DESC[0] = .BBLOCK[INPUT_QUAL[QUAL_EXP_DESC], DSC$W_LENGTH];
    OUTPUT_SEL_DESC[1] = .BBLOCK[INPUT_QUAL[QUAL_EXP_DESC], DSC$A_POINTER];
    END;


! Initialize the related file name block.
!
BBLOCK[OUTPUT_FAB[FC_RLF], NAM$B_RSL] = .OUTPUT_FILENAME[DSC$W_LENGTH];
BBLOCK[OUTPUT_FAB[FC_RLF], NAM$L_RSA] = .OUTPUT_FILENAME[DSC$A_POINTER];
WILD_DIRECTORY(OUTPUT_SEL_DESC, OUTPUT_FAB[FC_RLF]);


! Execute the $PARSE.
!
IF NOT $PARSE(FAB=.OUTPUT_FAB)
THEN
    IF .OUTPUT_FAB[FAB$L_STS] NEQ RMS$_DNF
    THEN
	BEGIN
	FILE_ERROR(
	    (IF .QUAL[QUAL_COMP]
		THEN BACKUP$_OPENIN + STS$K_ERROR
		ELSE BACKUP$_OPENOUT + STS$K_ERROR),
	    .OUTPUT_FAB,
	    .OUTPUT_FAB[FAB$L_STS], .OUTPUT_FAB[FAB$L_STV]);
	RETURN FALSE;
	END;


! If this is /INCREMENTAL mode, always select the file.
!
IF .QUAL[QUAL_INCR] THEN RETURN TRUE;


! Reject directory files that are in the save set but were not selected when
! they were saved.
!
IF
    .OUTPUT_ATTBUF[FAR_DIR_STATUS] NEQ 0 AND
    NOT .BBLOCK[OUTPUT_ATTBUF[FAR_DIR_STATUS], D_STAT_DIR_SEL]
THEN
    RETURN FALSE;


! Evaluate the /CONFIRM qualifier, now that the expanded string is known.
!
IF .QUAL[QUAL_CONF] AND NOT .QUAL[QUAL_IF11]
THEN
    BEGIN
    LOCAL
	FAO_BUFFER:	VECTOR[256,BYTE],
	FAO_DESC:	BBLOCK[8],
	ANS_BUFFER:	VECTOR[8,BYTE],
	ANS_DESC:	BBLOCK[8];

    FAO_DESC[DSC$W_LENGTH] = 256;
    FAO_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    FAO_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    FAO_DESC[DSC$A_POINTER] = FAO_BUFFER;
    ANS_DESC[DSC$W_LENGTH] = 8;
    ANS_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    ANS_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    ANS_DESC[DSC$A_POINTER] = ANS_BUFFER;
    $FAO(
	(IF .QUAL[QUAL_COMP]
	    THEN $DESCRIPTOR('!AD, compare? (Y or N): ')
	    ELSE $DESCRIPTOR('!AD, copy? (Y or N): ')),
	FAO_DESC,
	FAO_DESC,
	.OUTPUT_NAM[NAM$B_ESL],
	.OUTPUT_NAM[NAM$L_ESA]);
    LIB$GET_COMMAND(ANS_DESC, FAO_DESC);
    IF .ANS_BUFFER[0] NEQ %C'Y' AND .ANS_BUFFER[0] NEQ %C'y' THEN RETURN FALSE;
    END;


! Note that the file is selected.
!
TRUE
END;

ROUTINE SELECT_INCREMENTAL=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine performs file selection for a /INCREMENTAL mode restore.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	OUTPUT_NAM	- Pointer to name block, on which a $PARSE has been
!			  executed.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if and only if the file passes the /INCREMENTAL restore tests.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	FIB:		BBLOCK[FIB$C_LENGTH],	! FIB
	ATR_DESC:	BBLOCK[12],		! Attribute descriptor
	BAKDATE:	VOLATILE VECTOR[2],	! Backup date
	FNA_DESC:	VECTOR[2],		! Filename descriptor
	STATUS,					! General status variable
	IOSB:		VECTOR[4,WORD];		! I/O status block


! If the parent directory does not exist, the file is restored.
!
IF .OUTPUT_NAM[NAM$W_DID_NUM] EQL 0
THEN
    RETURN TRUE;


! Assign a channel to the device.
!
FNA_DESC[0] = .OUTPUT_NAM[NAM$B_DEV];
FNA_DESC[1] = .OUTPUT_NAM[NAM$L_DEV];
STATUS = ASSIGN_OUTPUT_CHANNEL(FNA_DESC, OUTPUT_CHAN, 0, 0);
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL(BACKUP$_OPENOUT + STS$K_ERROR, 1, FNA_DESC, .STATUS);
    RETURN FALSE;
    END;


! Access the parent directory to obtain the backup date.
!
FIB_DESC[0] = FIB$C_LENGTH;
FIB_DESC[1] = FIB;
CH$FILL(0, FIB$C_LENGTH, FIB);
FIB[FIB$W_FID_NUM] = .OUTPUT_NAM[NAM$W_DID_NUM];
FIB[FIB$W_FID_SEQ] = .OUTPUT_NAM[NAM$W_DID_SEQ];
FIB[FIB$W_FID_RVN] = .OUTPUT_NAM[NAM$W_DID_RVN];
ATR_DESC[0,0,16,0] = ATR$S_BAKDATE;
ATR_DESC[2,0,16,0] = ATR$C_BAKDATE;
ATR_DESC[4,0,32,0] = BAKDATE;
ATR_DESC[8,0,32,0] = 0;
STATUS = $QIOW(
    FUNC=IO$_ACCESS,
    CHAN=.OUTPUT_CHAN,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(BACKUP$_READATTR, .OUTPUT_FAB, .STATUS);
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    RETURN FALSE;
    END;


! If the creation date of the save set is later than the backup date of the
! parent directory, the file is restored.
!
IF
    .COM_O_BSRDATE[1] GTRU .BAKDATE[1] OR
    (.COM_O_BSRDATE[1] EQL .BAKDATE[1] AND .COM_O_BSRDATE[0] GTRU .BAKDATE[0])
THEN
    BEGIN
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    RETURN TRUE;
    END;


! The creation date of the save set is equal to or earlier than the backup date
! of the parent directory.  Attempt to look up the file in the directory.
!
CH$FILL(0, FIB$C_LENGTH, FIB);
FIB[FIB$W_DID_NUM] = .OUTPUT_NAM[NAM$W_DID_NUM];
FIB[FIB$W_DID_SEQ] = .OUTPUT_NAM[NAM$W_DID_SEQ];
FIB[FIB$W_DID_RVN] = .OUTPUT_NAM[NAM$W_DID_RVN];
FNA_DESC[0] = .OUTPUT_NAM[NAM$B_NAME] + .OUTPUT_NAM[NAM$B_TYPE] + .OUTPUT_NAM[NAM$B_VER];
FNA_DESC[1] = .OUTPUT_NAM[NAM$L_NAME];
STATUS = $QIOW(
    FUNC=IO$_ACCESS,
    CHAN=.OUTPUT_CHAN,
    IOSB=IOSB,
    P1=FIB_DESC,
    P2=FNA_DESC);
IF .STATUS THEN STATUS = .IOSB[0];


! If no directory entry exists for the file, the file is not restored.
!
IF .STATUS EQL SS$_NOSUCHFILE
THEN
    BEGIN
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    RETURN FALSE;
    END;


IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(BACKUP$_OPENOUT + STS$K_ERROR, .OUTPUT_FAB, .STATUS);
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    RETURN FALSE;
    END;


! If an entry pointing to an all-ones file ID exists, the file is restored.
!
IF
    .FIB[FIB$W_FID_NUM] EQL 65535 AND
    .FIB[FIB$W_FID_SEQ] EQL 65535 AND
    .FIB[FIB$B_FID_NMX] EQL 255
THEN
    BEGIN
    $DASSGN(CHAN=.OUTPUT_CHAN);
    OUTPUT_CHAN = 0;
    RETURN TRUE;
    END;


! Access the file to obtain the backup date.
!
FIB[FIB$W_DID_NUM] = FIB[FIB$W_DID_SEQ] = FIB[FIB$W_DID_RVN] = 0;
STATUS = $QIOW(
    FUNC=IO$_ACCESS,
    CHAN=.OUTPUT_CHAN,
    IOSB=IOSB,
    P1=FIB_DESC,
    P5=ATR_DESC);
IF .STATUS THEN STATUS = .IOSB[0];
$DASSGN(CHAN=.OUTPUT_CHAN);
OUTPUT_CHAN = 0;
IF NOT .STATUS
THEN
    BEGIN
    FILE_ERROR(BACKUP$_READATTR, .OUTPUT_FAB, .STATUS);
    RETURN FALSE;
    END;


! If the file's backup date is non-zero and equal to or earlier than the
! creation date of the save set, the file is restored.  Otherwise, the file
! is not restored.
!
IF
    (.BAKDATE[0] OR .BAKDATE[1]) NEQ 0 AND
    (.BAKDATE[1] LSSU .COM_O_BSRDATE[1] OR
    .BAKDATE[1] EQL .COM_O_BSRDATE[1] AND .BAKDATE[0] LEQU .COM_O_BSRDATE[0])
THEN
    TRUE
ELSE
    FALSE
END;

ROUTINE INCREMENTAL_DIRECTORY(LENGTH,ADDRESS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes the special /INCREMENTAL directory scan.
!
! INPUT PARAMETERS:
!	LENGTH		- Length and address of directory segment.
!	ADDRESS		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	REC:		REF BBLOCK,	! Pointer to directory record
	NEXT_BLOCK;			! Pointer to next directory block


! Initialize for the first block.
!
REC = .ADDRESS;
NEXT_BLOCK = .REC + 512;


! Loop over all blocks.
!
WHILE .REC LSSA .ADDRESS + .LENGTH DO
    BEGIN
    IF .REC[DIR$W_SIZE] EQL 65535
    THEN
	BEGIN
	!
	! End of this block.  Advance to next and resume.
	!
	REC = .NEXT_BLOCK;
	NEXT_BLOCK = .REC + 512;
	END
    ELSE
	BEGIN
	LOCAL
	    NEXT_RECORD,		! Pointer to next record
	    VER:	REF BBLOCK;	! Pointer to version entry


	! Point to where next record should start.  Make some validity tests
	! on the entry we are looking at.
	!
	NEXT_RECORD = .REC[DIR$W_SIZE] + .REC + 2;
	IF
	    BEGIN
	    IF
		.NEXT_RECORD GEQA .NEXT_BLOCK OR			! Entry within block?
		.REC[DIR$W_SIZE] OR					! Length even?
		.REC[DIR$W_SIZE] LSSU DIR$C_LENGTH + DIR$C_VERSION	! Long enough?
	    THEN
		TRUE
	    ELSE
		BEGIN
		VER = (.REC + DIR$C_LENGTH + .REC[DIR$B_NAMECOUNT] + 1) AND NOT 1;
		.REC[DIR$V_TYPE] NEQ DIR$C_FID OR			! Proper type code?
		.VER GEQA .NEXT_BLOCK - DIR$C_VERSION			! Version entry within block?
		END
	    END
	THEN
	    BEGIN
	    !
	    ! Directory format error.  Report it and quit.
	    !
	    FILE_ERROR(BACKUP$_INCBADDIR, .OUTPUT_FAB);
	    RETURN;
	    END;


	! Loop over all version entries.
	!
	WHILE .VER LSSA .NEXT_RECORD DO
	    BEGIN
	    WHILE
		BEGIN
		IF .INCR_RSS EQL 0
		THEN
		    FALSE
		ELSE
		    BEGIN
		    CH$LSS(
			.INCR_NTS, INCR_RSA,
			.REC[DIR$B_NAMECOUNT], REC[DIR$T_NAME]) OR
		    (CH$EQL(
			.INCR_NTS, INCR_RSA,
			.REC[DIR$B_NAMECOUNT], REC[DIR$T_NAME]) AND
		    .INCR_VER GTRU .VER[DIR$W_VERSION])
		    END
		END
	    DO
		BEGIN
		INCREMENTAL_DELETE();
		INCREMENTAL_SCAN();
		END;
	    

	    IF
		CH$EQL(
		    .INCR_NTS, INCR_RSA,
		    .REC[DIR$B_NAMECOUNT], REC[DIR$T_NAME]) AND
		.INCR_VER EQL .VER[DIR$W_VERSION]
	    THEN
		INCREMENTAL_SCAN()
	    ELSE
		BEGIN
		LOCAL
		    FIB_DESC:	VECTOR[2],
		    FIB:	BBLOCK[16],
		    FNA_DESC:	VECTOR[2],
		    FNA:	VECTOR[DIR$S_NAME+6,BYTE],
		    RSA_DESC:	VECTOR[2],
		    RSA:	VECTOR[NAM$C_MAXRSS,BYTE],
		    STATUS,
		    IOSB:	VECTOR[4,WORD];


		! Construct the name, type, and version string from the
		! information in the directory entry.
		!
		FNA_DESC[0] = DIR$S_NAME + 6;
		FNA_DESC[1] = FNA;
		$FAO(
		    $DESCRIPTOR('!AC;!UW'),
		    FNA_DESC,
		    FNA_DESC,
		    REC[DIR$B_NAMECOUNT],
		    .VER[DIR$W_VERSION]);


		! Construct a "resultant string" by concatenating the device
		! and directory specification, which is in the name block
		! expanded string, with the file name string.
		!
		RSA_DESC[0] = NAM$C_MAXRSS;
		RSA_DESC[1] = RSA;
		$FAO(
		    $DESCRIPTOR('!AD!AS'),
		    RSA_DESC,
		    RSA_DESC,
		    .OUTPUT_NAM[NAM$B_ESL], .OUTPUT_NAM[NAM$L_ESA],
		    FNA_DESC);


		! Set up for and enter the directory entry.
		!
		FIB_DESC[0] = 16;
		FIB_DESC[1] = FIB;
		CH$FILL(0, 16, FIB);
		FIB[FIB$W_FID_NUM] = -1;
		FIB[FIB$W_FID_SEQ] = -1;
		FIB[FIB$B_FID_NMX] = -1;
		FIB[FIB$W_DID_NUM] = .INCR_FIB[FIB$W_DID_NUM];
		FIB[FIB$W_DID_SEQ] = .INCR_FIB[FIB$W_DID_SEQ];
		FIB[FIB$W_DID_RVN] = .INCR_FIB[FIB$W_DID_RVN];
		STATUS = $QIOW(
		    FUNC=IO$_CREATE,
		    CHAN=.OUTPUT_CHAN,
		    IOSB=IOSB,
		    P1=FIB_DESC,
		    P2=FNA_DESC);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    SIGNAL(BACKUP$_INCENTERR, 1, RSA_DESC, .STATUS);
		END;


	    ! Advance to next version entry.
	    !
	    VER = .VER + DIR$C_VERSION;
	    END;


	! Advance to next directory record.
	!
	REC = .NEXT_RECORD;
	END;
    END;
END;

ROUTINE CREATE_OR_OPEN_FILE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine creates or opens a file in response to
!	a file attribute record.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
IF .COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV]
THEN
    BEGIN
    LOCAL
	FIB:		BBLOCK[10],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


    ! Construct a "resultant string" from the device name that is present in
    ! the expanded string of the current verification qualifier block and the
    ! filename string from the save set.  
    !
    OUTPUT_NAM[NAM$B_RSL] =
	.BBLOCK[VERIFY_QUAL[QUAL_DEV_DESC], DSC$W_LENGTH] +
	.OUTPUT_FILENAME[DSC$W_LENGTH];
    CH$MOVE(
	.OUTPUT_FILENAME[DSC$W_LENGTH],
	.OUTPUT_FILENAME[DSC$A_POINTER],
	CH$MOVE(
	    .BBLOCK[VERIFY_QUAL[QUAL_DEV_DESC], DSC$W_LENGTH],
	    .BBLOCK[VERIFY_QUAL[QUAL_DEV_DESC], DSC$A_POINTER],
	    .OUTPUT_NAM[NAM$L_RSA]));
    INIT_NAMEBLOCK(.OUTPUT_NAM);


    ! Initialize the FIB with the file ID from the save set,
    ! and access the file.
    !
    FIB[FIB$L_ACCTL] = FIB$M_NOWRITE;
    IF
	.QUAL[QUAL_IGNO_INTE] OR
	(.OUTPUT_FILENAME[DSC$W_LENGTH] EQL %CHARCOUNT('[000000]QUOTA.SYS;1') AND
	CH$EQL(
	    %CHARCOUNT('[000000]QUOTA.SYS;1'),
	    UPLIT BYTE('[000000]QUOTA.SYS;1'),
	    %CHARCOUNT('[000000]QUOTA.SYS;1'),
	    .OUTPUT_FILENAME[DSC$A_POINTER]))
    THEN
	FIB[FIB$L_ACCTL] = FIB$M_NOLOCK;
    FIB[FIB$V_NORECORD] = TRUE;
    FIB[FIB$W_FID_NUM] = .OUTPUT_ATTBUF[FAR_FID_NUM];
    FIB[FIB$W_FID_SEQ] = .OUTPUT_ATTBUF[FAR_FID_SEQ];
    FIB[FIB$W_FID_RVN] = .OUTPUT_ATTBUF[FAR_FID_RVNW];
    FIB_DESC[0] = 10;
    FIB_DESC[1] = FIB;
    STATUS = $QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.OUTPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	FILE_ERROR(
	    BACKUP$_OPENIN + STS$K_ERROR,
	    .OUTPUT_FAB,
	    .STATUS);
	RETURN;
	END;
    END
ELSE IF .QUAL[QUAL_IMAG]
THEN
    BEGIN
    LOCAL
	FIB:		BBLOCK[FIB$C_LENGTH],	! FIB
	FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	STATUS,					! Status variable
	IOSB:		VECTOR[4,WORD];		! I/O status block


    ! Construct a "resultant string" from the device name that is present in
    ! the expanded string of the output qualifier block and the filename
    ! string from the save set.  
    !
    OUTPUT_NAM[NAM$B_RSL] = .OUTPUT_NAM[NAM$B_ESL] + .OUTPUT_FILENAME[DSC$W_LENGTH];
    CH$MOVE(
	.OUTPUT_FILENAME[DSC$W_LENGTH],
	.OUTPUT_FILENAME[DSC$A_POINTER],
	CH$MOVE(
	    .OUTPUT_NAM[NAM$B_ESL],
	    .OUTPUT_NAM[NAM$L_ESA],
	    .OUTPUT_NAM[NAM$L_RSA]));
    INIT_NAMEBLOCK(.OUTPUT_NAM);


    ! Set the file ID into the NAM block.
    !
    OUTPUT_NAM[NAM$W_FID_NUM] = .OUTPUT_ATTBUF[FAR_FID_NUM];
    OUTPUT_NAM[NAM$W_FID_SEQ] = .OUTPUT_ATTBUF[FAR_FID_SEQ];
    OUTPUT_NAM[NAM$W_FID_RVN] = .OUTPUT_ATTBUF[FAR_FID_RVNW];


    ! Initialize the FIB.
    !
    CH$FILL(0, FIB$C_LENGTH, FIB);
    FIB[FIB$W_FID_NUM] = .OUTPUT_ATTBUF[FAR_FID_NUM];
    FIB[FIB$W_FID_SEQ] = .OUTPUT_ATTBUF[FAR_FID_SEQ];
    FIB[FIB$W_FID_RVN] = .OUTPUT_ATTBUF[FAR_FID_RVNW];
    FIB_DESC[0] = FIB$C_LENGTH;
    FIB_DESC[1] = FIB;


    IF .QUAL[QUAL_COMP]
    THEN
	BEGIN

	! Compare operation:  Access the file by its file ID.
	!
	FIB[FIB$L_ACCTL] = FIB$M_NORECORD;
	IF
	    .QUAL[QUAL_IGNO_INTE] OR
	    (.OUTPUT_FILENAME[DSC$W_LENGTH] EQL %CHARCOUNT('[000000]QUOTA.SYS;1') AND
	    CH$EQL(
		%CHARCOUNT('[000000]QUOTA.SYS;1'),
		UPLIT BYTE('[000000]QUOTA.SYS;1'),
		%CHARCOUNT('[000000]QUOTA.SYS;1'),
		.OUTPUT_FILENAME[DSC$A_POINTER]))
	THEN
	    FIB[FIB$L_ACCTL] = FIB$M_NOLOCK;
	FIB[FIB$V_NORECORD] = TRUE;
	STATUS = C$QIOW(
	    FUNC=IO$_ACCESS OR IO$M_ACCESS,
	    CHAN=.OUTPUT_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    BEGIN
	    FILE_ERROR(
		BACKUP$_OPENIN + STS$K_ERROR,
		.OUTPUT_FAB,
		.STATUS);
	    RETURN;
	    END;
	END
    ELSE
	BEGIN
	LOCAL
	    ATR_LIST:	VECTOR[14*2 + 1];	! ACP attributes list


	GET_ACP_ATTRIBUTES(ATR_LIST);
	IF
	    .OUTPUT_ATTBUF[FAR_FID_NMX] EQL 0 AND
	    (.OUTPUT_ATTBUF[FAR_FID_NUM] LEQU FID$C_BADBLK OR
		(.OUTPUT_ATTBUF[FAR_STRUCLEVB] EQL 2 AND
		.OUTPUT_ATTBUF[FAR_FID_NUM] EQL FID$C_BADLOG))
	THEN
	    BEGIN
	    LOCAL
		OLD_RECATTR:	BBLOCK[FAT$C_LENGTH],
		FAT_ATR_LIST:	BBLOCK[12];


	    ! File attribute record for an initial file.  Read the record
	    ! attributes.  This is required because HIBLK and EFBLK are
	    ! incorrect in the save set record attributes.
	    !
	    FAT_ATR_LIST[0,0,16,0] = ATR$S_RECATTR;
	    FAT_ATR_LIST[2,0,16,0] = ATR$C_RECATTR;
	    FAT_ATR_LIST[4,0,32,0] = OLD_RECATTR;
	    FAT_ATR_LIST[8,0,32,0] = 0;
	    STATUS = S$QIOW(
		FUNC=IO$_ACCESS,
		CHAN=.OUTPUT_CHAN,
		IOSB=IOSB,
		P1=FIB_DESC,
		P5=FAT_ATR_LIST);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		FILE_ERROR(
		    BACKUP$_READATTR,
		    .OUTPUT_FAB,
		    .STATUS);


	    ! Copy HIBLK and EFBLK to the new record attributes.
	    !
	    OUTPUT_RECATTR[FAT$L_HIBLK] = .OLD_RECATTR[FAT$L_HIBLK];
	    OUTPUT_RECATTR[FAT$L_EFBLK] = .OLD_RECATTR[FAT$L_EFBLK];


	    ! Write the new record attributes.
	    !
	    STATUS = S$QIOW(
		FUNC=IO$_MODIFY,
		CHAN=.OUTPUT_CHAN,
		IOSB=IOSB,
		P1=FIB_DESC,
		P5=ATR_LIST,
		P6=OUTPUT_ATTBUF);
	    IF .STATUS THEN STATUS = .IOSB[0];
	    IF NOT .STATUS
	    THEN
		FILE_ERROR(
		    BACKUP$_WRITEATTR,
		    .OUTPUT_FAB,
		    .STATUS);
	    RETURN;
	    END
	ELSE
	    BEGIN

	    ! Create the file.
	    !
	    LOCAL
		NAM_DESC:	VECTOR[2];	! Descriptor for P2 parameter


	    ! Get the string that will go into the file header by
	    ! stripping the directory specification.
	    !
	    NAM_DESC[0] = .OUTPUT_NAM[NAM$L_RSA] + .OUTPUT_NAM[NAM$B_RSL] - .OUTPUT_NAM[NAM$L_NAME];
	    NAM_DESC[1] = .OUTPUT_NAM[NAM$L_NAME];


	    ! Initialize FIB fields needed for create.
	    !
	    FIB[FIB$W_DID_NUM] = .OUTPUT_ATTBUF[FAR_DID_NUM];
	    FIB[FIB$W_DID_SEQ] = .OUTPUT_ATTBUF[FAR_DID_SEQ];
	    FIB[FIB$W_DID_RVN] = .OUTPUT_ATTBUF[FAR_DID_RVNW];
	    FIB[FIB$V_EXTEND] = TRUE;
	    IF .OUTPUT_FILECHAR[FCH$V_CONTIG] THEN FIB[FIB$V_ALCON] = TRUE;
	    FIB[FIB$L_EXSZ] = .OUTPUT_ATTBUF[FAR_FILESIZE];


	    ! Pass a create QIO to the standalone ACP.
	    !
	    STATUS = S$QIOW(
		FUNC=IO$_CREATE OR IO$M_CREATE OR IO$M_ACCESS,
		CHAN=.OUTPUT_CHAN,
		IOSB=IOSB,
		P1=FIB_DESC,
		P2=NAM_DESC,
		P5=ATR_LIST,
		P6=OUTPUT_ATTBUF);
	    IF .STATUS THEN STATUS = .IOSB[0];


	    IF .STATUS EQL SS$_DEVICEFULL AND .FIB[FIB$V_ALCON]
	    THEN
		BEGIN

		! If a contiguous create failed, try a non-contiguous one.
		!
		FIB[FIB$V_ALCON] = FALSE;
		STATUS = S$QIOW(
		    FUNC=IO$_CREATE OR IO$M_CREATE OR IO$M_ACCESS,
		    CHAN=.OUTPUT_CHAN,
		    IOSB=IOSB,
		    P1=FIB_DESC,
		    P2=NAM_DESC,
		    P5=ATR_LIST,
		    P6=OUTPUT_ATTBUF);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF .STATUS THEN FILE_ERROR(BACKUP$_NONCONTIG, .OUTPUT_FAB);
		END;


	    IF NOT .STATUS
	    THEN
		BEGIN
		FILE_ERROR(
		    BACKUP$_OPENOUT + STS$K_ERROR,
		    .OUTPUT_FAB,
		    .STATUS);
		RETURN;
		END;


	    ! If this is the boot file, rewrite the boot block with the
	    ! appropriate LBN.
	    !
	    IF .OUTPUT_ATTBUF[FAR_BOOTVBN] NEQ 0
	    THEN
		STA_WRITEBOOT();
	    END;
	END;
    END
ELSE IF .QUAL[QUAL_COMP]
THEN
    BEGIN
    IF NOT $OPEN(FAB=.OUTPUT_FAB)
    THEN
	BEGIN
	FILE_ERROR(
	    BACKUP$_OPENIN + STS$K_ERROR,
	    .OUTPUT_FAB,
	    .OUTPUT_FAB[FAB$L_STS], .OUTPUT_FAB[FAB$L_STV]);
	RETURN;
	END;
    OUTPUT_CHAN = .OUTPUT_FAB[FAB$L_STV];
    END
ELSE
    BEGIN
    LOCAL
	SAVED_ALQ,			! Saved allocation
	SAVED_CTG,			! Saved contiguous attribute
	XABPRO:		$XABPRO_DECL,
	STATUS;


    ! If directory not found during $PARSE, try to create it.
    !
    IF .OUTPUT_FAB[FAB$L_STS] EQL RMS$_DNF
    THEN
	IF NOT IMPLICIT_DIRECTORY()
	THEN
	    RETURN;


    ! Establish ownership of the new file.
    !
    IF NOT .QUAL[QUAL_O_OWN_ORIG]
    THEN
	OUTPUT_ATTBUF[FAR_UIC] = .JPI_UIC;

    IF .QUAL[QUAL_O_OWN_UIC]
    THEN
	OUTPUT_ATTBUF[FAR_UIC] = .QUAL[QUAL_O_OWN_VALU];

    IF .QUAL[QUAL_O_OWN_PARE]
    THEN
	OUTPUT_ATTBUF[FAR_UIC] = GET_PARENT_UIC();


    ! Initialize protection XAB for the file.
    !
    $XABPRO_INIT(XAB=XABPRO);
    XABPRO[XAB$L_UIC] = .OUTPUT_ATTBUF[FAR_UIC];
    OUTPUT_FAB[FAB$L_XAB] = XABPRO;


    ! Attempt to create the file.
    !
    SAVED_ALQ = .OUTPUT_FAB[FAB$L_ALQ];
    SAVED_CTG = .OUTPUT_FAB[FAB$V_CTG];
    STATUS = $CREATE(FAB=.OUTPUT_FAB);


    IF .STATUS EQL RMS$_FUL AND .OUTPUT_FAB[FAB$V_CTG]
    THEN
	BEGIN

	! If a contiguous create failed, try a non-contiguous one.
	!
	OUTPUT_FAB[FAB$V_CTG] = FALSE;
	STATUS = $CREATE(FAB=.OUTPUT_FAB);
	IF .STATUS THEN FILE_ERROR(BACKUP$_NONCONTIG, .OUTPUT_FAB);
	END;


    OUTPUT_FAB[FAB$L_XAB] = 0;


    IF NOT .STATUS
    THEN
	BEGIN
	FILE_ERROR(
	    BACKUP$_OPENOUT + STS$K_ERROR,
	    .OUTPUT_FAB,
	    .OUTPUT_FAB[FAB$L_STS], .OUTPUT_FAB[FAB$L_STV]);
	RETURN;
	END;


    OUTPUT_CHAN = .OUTPUT_FAB[FAB$L_STV];


    ! If the file is being created /OVERLAY and has insufficient space,
    ! it must be extended.
    !
    IF .OUTPUT_FAB[FAB$V_CIF] AND .OUTPUT_FAB[FAB$L_ALQ] LSSU .SAVED_ALQ
    THEN
	BEGIN
	LOCAL
	    FIB:	BBLOCK[FIB$C_LENGTH],	! FIB
	    FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	    STATUS,				! Status variable
	    IOSB:	VECTOR[4,WORD];		! I/O status block


	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$V_EXTEND] = TRUE;
	FIB[FIB$L_EXSZ] = .SAVED_ALQ - .OUTPUT_FAB[FAB$L_ALQ];
	FIB_DESC[0] = FIB$C_LENGTH;
	FIB_DESC[1] = FIB;
	STATUS = $QIOW(
	    FUNC=IO$_MODIFY,
	    CHAN=.OUTPUT_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    BEGIN
	    FILE_ERROR(
		BACKUP$_OPENOUT + STS$K_ERROR,
		.OUTPUT_FAB,
		.STATUS);
	    $DASSGN(CHAN=.OUTPUT_CHAN);
	    RETURN;
	    END;
	IF .SAVED_CTG THEN FILE_ERROR(BACKUP$_NONCONTIG, .OUTPUT_FAB);
	END;


    ! Establish the file version limit.
    !
    IF
	NOT .OUTPUT_NAM[NAM$V_HIGHVER] AND
	NOT .OUTPUT_NAM[NAM$V_LOWVER] AND
	.OUTPUT_ATTBUF[FAR_VERLIMIT] NEQ 0
    THEN
	BEGIN
	LOCAL
	    FIB:	BBLOCK[FIB$C_LENGTH],	! FIB
	    FIB_DESC:	VECTOR[2],		! Descriptor for FIB
	    FNA_DESC:	VECTOR[2],		! Descriptor for n.t;v
	    STATUS,				! Status return
	    IOSB:	VECTOR[4,WORD];		! I/O status block


	! Set up the FIB and filename descriptor to modify the file version
	! limit.
	!
	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$W_DID_NUM] = .OUTPUT_NAM[NAM$W_DID_NUM];
	FIB[FIB$W_DID_SEQ] = .OUTPUT_NAM[NAM$W_DID_SEQ];
	FIB[FIB$W_DID_RVN] = .OUTPUT_NAM[NAM$W_DID_RVN];
	FIB[FIB$W_VERLIMIT] = .OUTPUT_ATTBUF[FAR_VERLIMIT];
	FIB_DESC[0] = FIB$C_LENGTH;
	FIB_DESC[1] = FIB;
	FNA_DESC[0] = .OUTPUT_NAM[NAM$L_RSA] + .OUTPUT_NAM[NAM$B_RSL] - .OUTPUT_NAM[NAM$L_NAME];
	FNA_DESC[1] = .OUTPUT_NAM[NAM$L_NAME];
	STATUS = $QIOW(
	    FUNC=IO$_MODIFY,
	    CHAN=.OUTPUT_CHAN,
	    IOSB=IOSB,
	    P1=FIB_DESC,
	    P2=FNA_DESC);
	IF .STATUS THEN STATUS = .IOSB[0];
	IF NOT .STATUS
	THEN
	    FILE_ERROR(BACKUP$_WRITEATTR, .OUTPUT_FAB, .STATUS);
	END;
    END;


OUTPUT_FLAGS[OUTPUT_OPEN] = TRUE;
COM_FLAGS[COM_FILESEEN] = TRUE;
OUTPUT_BLOCK = 1;
OUTPUT_MAXBLOCK = ROT(.OUTPUT_RECATTR[FAT$L_EFBLK], 16);
IF .OUTPUT_RECATTR[FAT$W_FFBYTE] EQL 0
    THEN OUTPUT_MAXBLOCK = .OUTPUT_MAXBLOCK - 1;
IF
    .OUTPUT_MAXBLOCK GTRU .OUTPUT_ATTBUF[FAR_FILESIZE] OR
    .OUTPUT_RECATTR[FAT$V_FILEORG] NEQ FAT$C_SEQUENTIAL
THEN
    OUTPUT_MAXBLOCK = .OUTPUT_ATTBUF[FAR_FILESIZE];


IF .QUAL[QUAL_COMP]
THEN
    CHECK_EOF_BLOCK();
END;

ROUTINE RESTORE_ERROR(BCB): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This is the error action routine for asynchronous writes.
!
! INPUT PARAMETERS:
!	BCB		- BCB on which the error occurred.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	BCB:		REF BBLOCK;	! Pointer to BCB
LOCAL
	REC:		REF BBLOCK,	! Pointer to record
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD];	! I/O status block


! Point to the record on which the error occurred.
!
REC = .BCB[BCB_RECORD];


! Loop for all blocks in the record reissuing the writes and reporting
! any errors that occur.
!
INCR XBLOCK FROM 0 TO .REC[BRH$W_RSIZE]^-9 - 1 DO
    BEGIN
    STATUS = C$QIOW(
	FUNC=.OUTPUT_FUNC,
	CHAN=.OUTPUT_CHAN,
	IOSB=IOSB,
	P1=.REC + BRH$C_LENGTH + .XBLOCK^9,
	P2=512,
	P3=.REC[BRH$L_ADDRESS] + .XBLOCK);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS THEN IF NOT FIND_BADBLOCK(.OUTPUT_BAD, .REC[BRH$L_ADDRESS] + .XBLOCK)
    THEN
	FILE_ERROR(
	    BACKUP$_WRITEBLOCK,
	    .OUTPUT_FAB,
	    .REC[BRH$L_ADDRESS] + .XBLOCK,
	    .STATUS);
    END;
END;

GLOBAL ROUTINE RESTORE_ONE_RECORD(REC,BCB): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine restores the contents of one save set record.
!
! INPUT PARAMETERS:
!	REC		- Pointer to record.
!	BCB		- Pointer to BCB.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	REC:		REF BBLOCK,	! Pointer to record
	BCB:		REF BBLOCK;	! Pointer to BCB


OUTPUT_BCB = .BCB;


CASE .REC[BRH$W_RTYPE] FROM BRH$K_SUMMARY TO BRH$K_FID OF
    SET


    [OUTRANGE]:
	0;


    [BRH$K_VBN, BRH$K_LBN]:
	BEGIN

	! Test for an unexpected change in file ID.  This indicates that some
	! save set data has been lost.  Close the current output file, if any,
	! and, if selected, create the file from which this data came.
	!
	IF CH$NEQ(
	    FID$C_LENGTH, OUTPUT_ATTBUF[FAR_FID],
	    FID$C_LENGTH, BBLOCK[.BCB[BCB_BUFFER], BBH$W_FID])
	THEN
	    BEGIN
	    LOCAL
		BUFFER:			REF BBLOCK;	! Pointer to buffer


	    ! Warn the user that this has occurred.  However, if this is a
	    ! continuation tape verify pass, it is expected to occur.
	    !
	    IF
		NOT .OUTPUT_FLAGS[OUTPUT_V_FIRST] OR
		NOT .COM_FLAGS[COM_VERIFYING] OR
		.BBLOCK[.BCB[BCB_BUFFER], BBH$W_VOLNUM] LEQ 1
	    THEN
		FILE_ERROR(
		    BACKUP$_FIDERROR,
		    .OUTPUT_FAB);


	    ! Close the current output file, if any.
	    !
	    CLOSE_RESTORE();


	    ! Avoid situations where we should not restore the file.
	    !
	    IF
		(.REC[BRH$V_DIRECTORY] AND NOT .QUAL[QUAL_IMAG]) OR
		.QUAL[QUAL_VOLU] OR
		.QUAL[QUAL_INCR]
	    THEN
		RETURN;


	    ! Synthesize the file attribute buffer from the information in the
	    ! save set block header.
	    !
	    BUFFER = .BCB[BCB_BUFFER];
	    CH$FILL(0, FAR_LENGTH, OUTPUT_ATTBUF);
	    OUTPUT_ATTBUF[FAR_FID_NUM] = .BUFFER[BBH$W_FID_NUM];
	    OUTPUT_ATTBUF[FAR_FID_SEQ] = .BUFFER[BBH$W_FID_SEQ];
	    OUTPUT_ATTBUF[FAR_FID_RVNW] = .BUFFER[BBH$W_FID_RVN];
	    OUTPUT_FILENAME[DSC$W_LENGTH] = .(BUFFER[BBH$T_FILENAME])<0,8>;
	    OUTPUT_FILENAME[DSC$A_POINTER] = BUFFER[BBH$T_FILENAME] + 1;
	    OUTPUT_RECATTR[FAT$B_RTYPE] = .BUFFER[BBH$B_RTYPE];
	    OUTPUT_RECATTR[FAT$B_RATTRIB] = .BUFFER[BBH$B_RATTRIB];
	    OUTPUT_RECATTR[FAT$W_RSIZE] = .BUFFER[BBH$W_RSIZE];
	    OUTPUT_RECATTR[FAT$L_EFBLK] = ROT(.BUFFER[BBH$L_FILESIZE] + 1, 16);
	    OUTPUT_RECATTR[FAT$B_BKTSIZE] = .BUFFER[BBH$B_BKTSIZE];
	    OUTPUT_RECATTR[FAT$B_VFCSIZE] = .BUFFER[BBH$B_VFCSIZE];
	    OUTPUT_RECATTR[FAT$W_MAXREC] = .BUFFER[BBH$W_MAXREC];
	    OUTPUT_ATTBUF[FAR_FILESIZE] = .BUFFER[BBH$L_FILESIZE];


	    ! Determine if the new file is selected, and if it is, create
	    ! or open it.
	    !
	    IF INITIALIZE_AND_SELECT()
	    THEN
		BEGIN
		CREATE_OR_OPEN_FILE();
		IF .OUTPUT_FLAGS[OUTPUT_OPEN]
		    THEN OUTPUT_FLAGS[OUTPUT_IMPLICIT] = TRUE;
		END;
	    END;


	! If special /INCREMENTAL directory processing is enabled, do it.
	!
	IF .OUTPUT_FLAGS[OUTPUT_INCR_DIR]
	THEN
	    INCREMENTAL_DIRECTORY(.REC[BRH$W_RSIZE], .REC + BRH$C_LENGTH);


	! If the file from which this data came is selected, write the
	! data.
	!
	IF .OUTPUT_FLAGS[OUTPUT_OPEN]
	THEN
	    BEGIN
	    LOCAL
		IOSB:		VECTOR[4,WORD],	! I/O status block
		THIS_MINVBN,			! Smallest block number
		THIS_MAXVBN,			! Largest block number
		THIS_BLOCKS,			! Blocks in current record
		STATUS;				! Status variable


	    ! Compute the smallest and largest block numbers in this record.
	    !
	    THIS_MINVBN = .REC[BRH$L_ADDRESS];
	    THIS_BLOCKS = .REC[BRH$W_RSIZE] ^ -9;
	    THIS_MAXVBN = .THIS_MINVBN + .THIS_BLOCKS - 1;


	    ! Make sure that the block number is at least as large as the
	    ! next block number we are expecting.
	    !
	    IF .THIS_MINVBN LSSU .OUTPUT_BLOCK
	    THEN
		BEGIN
		FILE_ERROR(
		    BACKUP$_VBNERROR,
		    .OUTPUT_FAB,
		    .THIS_MINVBN, .OUTPUT_BLOCK-1);
		END;


	    ! Make sure that no blocks were skipped.  However, if this is
	    ! the first data record in a continuation tape verify pass,
	    ! accept the error.  Accept the error if /VOLUME is specified.
	    !
	    IF
		NOT .QUAL[QUAL_VOLU] AND
		.THIS_MINVBN GTRU .OUTPUT_BLOCK AND
		(NOT .OUTPUT_FLAGS[OUTPUT_V_FIRST] OR
		NOT .COM_FLAGS[COM_VERIFYING] OR
		.BBLOCK[.BCB[BCB_BUFFER], BBH$W_VOLNUM] LEQ 1)
	    THEN
		BEGIN
		FILE_ERROR(
		    BACKUP$_VBNMISSING,
		    .OUTPUT_FAB,
		    .OUTPUT_BLOCK, .THIS_MINVBN-1);
		END;


	    ! Make sure that the upper limit does not exceed the boundaries
	    ! of the file that we were expecting.  If it does, do not process
	    ! any blocks beyond the boundary.
	    !
	    IF .THIS_MAXVBN GTRU .OUTPUT_MAXBLOCK
	    THEN
		BEGIN
		FILE_ERROR(
		    BACKUP$_VBNPASTEOF,
		    .OUTPUT_FAB,
		    .OUTPUT_MAXBLOCK+1, .THIS_MAXVBN);
		THIS_BLOCKS = MAX(0, .OUTPUT_MAXBLOCK - .THIS_MINVBN + 1);
		END;


	    ! If the data had an error when it was saved, report the fact.
	    ! Omit the report for a disk-to-disk operation.
	    !
	    IF .REC[BRH$V_BADDATA] AND NOT .QUAL[QUAL_IF11]
	    THEN
		FILE_ERROR(
		    BACKUP$_BADDATA,
		    .OUTPUT_FAB,
		    .THIS_MINVBN);


	    IF .QUAL[QUAL_COMP]
	    THEN
		BEGIN

		! For a compare operation, read the corresponding blocks from
		! the output medium into the compare buffer.  If an error
		! occurs, re-execute the read one block at a time reporting
		! the errors.
		!
		STATUS = C$QIOW(
		    FUNC=.INPUT_FUNC,
		    CHAN=.OUTPUT_CHAN,
		    IOSB=IOSB,
		    P1=.COMPARE_BCB[BCB_BUFFER] + BBH$C_LENGTH,
		    P2=.THIS_BLOCKS ^ 9,
		    P3=.THIS_MINVBN);
		IF .STATUS THEN STATUS = .IOSB[0];
		IF NOT .STATUS
		THEN
		    BEGIN
		    INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
			BEGIN
			STATUS = C$QIOW(
			    FUNC=.INPUT_FUNC,
			    CHAN=.OUTPUT_CHAN,
			    IOSB=IOSB,
			    P1=.COMPARE_BCB[BCB_BUFFER] + BBH$C_LENGTH + .XVBN^9,
			    P2=512,
			    P3=.REC[BRH$L_ADDRESS] + .XVBN);
			IF .STATUS THEN STATUS = .IOSB[0];
			IF NOT .STATUS THEN IF NOT FIND_BADBLOCK(.OUTPUT_BAD, .REC[BRH$L_ADDRESS] + .XVBN)
			THEN
			    FILE_ERROR(
				BACKUP$_READBLOCK,
				.OUTPUT_FAB,
				.REC[BRH$L_ADDRESS] + .XVBN,
				.STATUS);
			END;
		    END;


		! Compare the save set data to the output medium data,
		! reporting discrepancies.
		!
		INCR XVBN FROM 0 TO .THIS_BLOCKS-1 DO
		    BEGIN
		    IF CH$NEQ(
			512, .REC + BRH$C_LENGTH + .XVBN^9,
			512, .COMPARE_BCB[BCB_BUFFER] + BBH$C_LENGTH + .XVBN^9)
		    THEN
			IF NOT FIND_BADBLOCK(.OUTPUT_BAD, .REC[BRH$L_ADDRESS] + .XVBN)
			THEN
			    FILE_ERROR(
				BACKUP$_VERIFYERR,
				.OUTPUT_FAB,
				.REC[BRH$L_ADDRESS] + .XVBN);
		    END;
		END
	    ELSE
		BEGIN

		! Writing to an output file.
		!
		BCB[BCB_RECORD] = .REC;
		IF
		    BEGIN
		    LOCAL
			LIMIT,
			RLIMIT:	REF BBLOCK;

		    LIMIT = .BCB[BCB_BUFFER] + .BCB[BCB_SIZE];
		    RLIMIT = .REC + .REC[BRH$W_RSIZE] + BRH$C_LENGTH;
		    IF .RLIMIT GEQA .LIMIT
		    THEN
			TRUE
		    ELSE
			.RLIMIT[BRH$W_RTYPE] EQL BRH$K_NULL AND
			.RLIMIT + .RLIMIT[BRH$W_RSIZE] + BRH$C_LENGTH GEQA .LIMIT
		    END
		THEN
		    BEGIN

		    ! This is the last record in the current buffer.
		    ! Execute the write asynchronously.
		    !
		    STATUS = C$QIO(
			FUNC=.OUTPUT_FUNC,
			CHAN=.OUTPUT_CHAN,
			EFN=BCB_S_WRITE,
			IOSB=BCB[BCB_IOSB],
			P1=.REC + BRH$C_LENGTH,
			P2=.THIS_BLOCKS ^ 9,
			P3=.THIS_MINVBN);
		    IF NOT .STATUS
		    THEN
			FILE_ERROR(
			    BACKUP$_WRITEERR + STS$K_SEVERE,
			    .OUTPUT_FAB,
			    .STATUS);
		    BCB[BCB_SUCC_ACT] = 0;
		    BCB[BCB_FAIL_ACT] = RESTORE_ERROR;
		    BCB[BCB_STATE] = BCB_S_WRITE;
		    INSQUE(.BCB, .OUTPUT_WAIT[1]);
		    END
		ELSE
		    BEGIN

		    ! This is not the last record in the buffer.  Execute the
		    ! write synchronously.
		    !
		    STATUS = C$QIOW(
			FUNC=.OUTPUT_FUNC,
			CHAN=.OUTPUT_CHAN,
			IOSB=IOSB,
			P1=.REC + BRH$C_LENGTH,
			P2=.THIS_BLOCKS ^ 9,
			P3=.THIS_MINVBN);
		    IF .STATUS THEN STATUS = .IOSB[0];
		    IF NOT .STATUS THEN RESTORE_ERROR(.BCB);
		    END;
		END;


	    ! Update the output block number past this data record.
	    !
	    OUTPUT_BLOCK = .THIS_MAXVBN + 1;
	    END;


	! Indicate no longer the first data record of a verify pass.
	!
	OUTPUT_FLAGS[OUTPUT_V_FIRST] = FALSE;
	END;


    [BRH$K_SUMMARY]:
	BEGIN
	LOCAL
	    SAVE_ATTBUF:	BBLOCK[FAR_LENGTH];


	! Save the contents of the attributes buffer.  This is necessary
	! because the BACKUP summary record on a continuation tape is usually
	! interspersed with file data records.
	!
	CH$MOVE(FAR_LENGTH, OUTPUT_ATTBUF, SAVE_ATTBUF);


	! Get the attributes and save the volume set count, volume set name,
	! and creation date of the save set for later use.
	!
	GET_SUMMARY_ATTRIBUTES(.REC);
	IF .QUAL[QUAL_OF11]
	THEN
	    BEGIN
	    COM_O_SETCOUNT = .OUTPUT_ATTBUF[BSR_NVOLS];
	    COM_O_BSRDATE[0] = .(OUTPUT_ATTBUF[BSR_DATE]);
	    COM_O_BSRDATE[1] = .(OUTPUT_ATTBUF[BSR_DATE]+4);

	    IF
		.QUAL[QUAL_VOLU] AND
		.QUAL[QUAL_VOLU_VALUE] GTRU .COM_O_SETCOUNT
	    THEN
		SIGNAL(
		    BACKUP$_NOSUCHRVN, 2,
		    .QUAL[QUAL_VOLU_VALUE], .COM_O_SETCOUNT);

	    CH$COPY(
		.BBLOCK[OUTPUT_ATTBUF[BSR_VOLSETNAM], DSC$W_LENGTH],
		.BBLOCK[OUTPUT_ATTBUF[BSR_VOLSETNAM], DSC$A_POINTER],
		%C' ',
		HM2$S_STRUCNAME,
		COM_O_STRUCNAME);
	    END;


	! Restore the attribute buffer.
	!
	CH$MOVE(FAR_LENGTH, SAVE_ATTBUF, OUTPUT_ATTBUF);
	END;


    [BRH$K_VOLUME]:
	BEGIN

	! If this is an image restore or image copy, initialize the output
	! volume.
	!
	GET_VOLUME_ATTRIBUTES(.REC);
	IF
	    .QUAL[QUAL_IMAG] AND
	    NOT .QUAL[QUAL_COMP] AND
	    (NOT .QUAL[QUAL_VOLU] OR
	     .QUAL[QUAL_VOLU_VALUE] EQL .OUTPUT_ATTBUF[VSR_RVN] OR
	     .QUAL[QUAL_VOLU_VALUE] EQL 1 AND .OUTPUT_ATTBUF[VSR_RVN] LEQU 1)
	THEN
	    STA_INIVOL();
	END;


    [BRH$K_FID]:
	BEGIN

	! Check the structure level word.  If this is an image restore or
	! image copy, initialize the file headers that are described by
	! this record.
	!
	IF .BBLOCK[REC[BRH$C_LENGTH,0,0,0], BSA$W_STRUCLEV] NEQ BBH$K_LEVEL1
	THEN
	    SIGNAL(BACKUP$_INVATTSTR)
	ELSE
	    IF
		.QUAL[QUAL_IMAG] AND
		NOT .QUAL[QUAL_COMP] AND
		(NOT .QUAL[QUAL_VOLU] OR
		 .QUAL[QUAL_VOLU_VALUE] EQL .OUTPUT_ATTBUF[VSR_RVN] OR
		 .QUAL[QUAL_VOLU_VALUE] EQL 1 AND .OUTPUT_ATTBUF[VSR_RVN] LEQU 1)
	    THEN
		STA_INIT_HDRS(REC[BRH$C_LENGTH,0,0,0]);
	END;


    [BRH$K_PHYSVOL]:
	BEGIN

	! Get the attributes.  However, on a verify pass, do not reprocess
	! the record.
	!
	GET_PHYSVOL_ATTRIBUTES(.REC);
	IF .COM_FLAGS[COM_VERIFYING] THEN RETURN;


	! Make sure the device geometry matches.
	!
	IF
	    .OUTPUT_ATTBUF[PVA_SECTORS] NEQ .OUTPUT_DEVGEOM[DGM_SECTORS] OR
	    .OUTPUT_ATTBUF[PVA_TRACKS] NEQ .OUTPUT_DEVGEOM[DGM_TRACKS] OR
	    .OUTPUT_ATTBUF[PVA_CYLINDERS] NEQ .OUTPUT_DEVGEOM[DGM_CYLINDERS] OR
	    .OUTPUT_ATTBUF[PVA_MAXBLOCK] NEQ .OUTPUT_DEVGEOM[DGM_MAXBLOCK]
	THEN
	    FILE_ERROR(BACKUP$_PHYDEVGEO, .OUTPUT_FAB);


	! Ensure that there are no bad blocks on the output device that were
	! good blocks on the input device.  Do this by matching each bad LBN
	! in the output device data against the attribute record.  If the LBN
	! is not found, it is an error.
	!
	INCR I FROM 0 TO .OUTPUT_BAD[BAD_NUMDESC]-1 DO
	    BEGIN
	    LOCAL Q: REF BBLOCK;
	    Q = OUTPUT_BAD[BAD_DESC];
	    INCRU LBN FROM .Q[BAD_LBN] TO .Q[BAD_LBN]+.Q[BAD_COUNT]-1 DO
		BEGIN
		LOCAL P: REF VECTOR;
		P = .BBLOCK[OUTPUT_ATTBUF[PVA_BADBLOCK], DSC$A_POINTER];
		IF
		    BEGIN
		    WHILE .P LSSA
			.BBLOCK[OUTPUT_ATTBUF[PVA_BADBLOCK], DSC$A_POINTER] +
			.BBLOCK[OUTPUT_ATTBUF[PVA_BADBLOCK], DSC$W_LENGTH]
		    DO
			BEGIN
			IF
			    .LBN GEQU .P[0] AND
			    .LBN LEQU .P[0]+.P[1]-1
			THEN
			    EXITLOOP FALSE;
			P = .P + 8;
			END
		    END
		THEN
		    BEGIN
		    FILE_ERROR(BACKUP$_BADBLOCK, .OUTPUT_FAB);
		    RETURN;
		    END;
		END;
	    Q = .Q + BAD_S_DESC;
	    END;
	END;


    [BRH$K_FILE]:
	BEGIN
	LOCAL
	    BUFFER:		REF BBLOCK;	! Pointer to buffer


	! If a file is currently open, close it.
	!
	CLOSE_RESTORE();


	! Get the attributes from the record.
	!
	GET_FILE_ATTRIBUTES(.REC);
	IF
	    .QUAL[QUAL_TRUN] AND
	    .OUTPUT_RECATTR[FAT$V_FILEORG] EQL FAT$C_SEQUENTIAL
	THEN
	    BEGIN
	    LOCAL
		EOF_SIZE;

	    EOF_SIZE = ROT(.OUTPUT_RECATTR[FAT$L_EFBLK], 16);
	    IF .OUTPUT_RECATTR[FAT$W_FFBYTE] EQL 0
		THEN EOF_SIZE = .EOF_SIZE - 1;
	    OUTPUT_ATTBUF[FAR_FILESIZE] =
		MINU(.EOF_SIZE, .OUTPUT_ATTBUF[FAR_FILESIZE]);
	    END;
	BUFFER = .OUTPUT_BCB[BCB_BUFFER];
	BUFFER[BBH$W_FID_NUM] = .OUTPUT_ATTBUF[FAR_FID_NUM];
	BUFFER[BBH$W_FID_SEQ] = .OUTPUT_ATTBUF[FAR_FID_SEQ];
	BUFFER[BBH$W_FID_RVN] = .OUTPUT_ATTBUF[FAR_FID_RVNW];


	! If this is a save verify pass, reassign the channel to the output
	! volume if required.
	!
	IF .COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV]
	    THEN ASSIGN_VERIFY_CHANNEL(TRUE);


	! Determine if the new file is selected, and if it is, process it in
	! the appropriate manner.
	!
	IF INITIALIZE_AND_SELECT()
	THEN
	    BEGIN
	    IF .REC[BRH$V_DIRECTORY]
	    THEN
		IF .QUAL[QUAL_COMP]
		THEN
		    IF
			(.QUAL[QUAL_ISAV] AND .QUAL[QUAL_IMAG]) OR
			(.COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV])
		    THEN
			CREATE_OR_OPEN_FILE()	! compare directory contents
		    ELSE
			0			! skip directory
		ELSE
		    IF .QUAL[QUAL_IMAG]
		    THEN
			CREATE_OR_OPEN_FILE()	! image restore directory
		    ELSE
			CREATE_DIRECTORY()	! non-image restore directory
	    ELSE
		IF
		    BEGIN
		    IF NOT .QUAL[QUAL_INCR]
			THEN TRUE
			ELSE SELECT_INCREMENTAL()
		    END
		THEN
		    CREATE_OR_OPEN_FILE();	! compare/restore file
	    END;


	! Indicate no longer the first data record of a verify pass.
	!
	OUTPUT_FLAGS[OUTPUT_V_FIRST] = FALSE;
	END;


    TES;
END;

GLOBAL ROUTINE RESTORE_VERIFY_REEL: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is called at the end of each reel to verify that reel.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	STATUS,				! Status variable
	IOSB:		VECTOR[4,WORD],	! I/O status block
	FIB:		BBLOCK[10],	! FIB
	FIB_DESC:	VECTOR[2],	! Descriptor for FIB
	SAVE_OUTPUT_BAD,		! Save for OUTPUT_BAD
	LOCAL_SAVE:	BBLOCK[OUTPUT_END-OUTPUT_BEG];	! Save area


! If a file is accessed, deaccess it for the duration of the verify pass to
! avoid having the file open for the entire time.
!
IF .OUTPUT_FLAGS[OUTPUT_OPEN] AND NOT .QUAL[QUAL_PHYS]
THEN
    BEGIN
    STATUS = C$QIOW(
	FUNC=IO$_DEACCESS,
	CHAN=.OUTPUT_CHAN,
	IOSB=IOSB);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	FILE_ERROR(
	    BACKUP$_CLOSEOUT + STS$K_ERROR,
	    .OUTPUT_FAB,
	    .STATUS);
    END;

    
! Readjust context.
!
QUAL[QUAL_COMP] = TRUE;
IF .QUAL[QUAL_PHYS] THEN VERIFY_FAB = .OUTPUT_FAB;
CH$MOVE(OUTPUT_END-OUTPUT_BEG, OUTPUT_BEG, LOCAL_SAVE);
SAVE_OUTPUT_BAD = .OUTPUT_BAD;
CH$FILL(0, OUTPUT_END-OUTPUT_BEG, OUTPUT_BEG);
OUTPUT_BAD = .SAVE_OUTPUT_BAD;


! Do the verify by calling the RESTORE module.
!
RESTORE();


! Restore context.
!
QUAL[QUAL_COMP] = FALSE;
CH$MOVE(OUTPUT_END-OUTPUT_BEG, LOCAL_SAVE, OUTPUT_BEG);


! If necessary, re-access the file that was accessed at the end of the
! previous reel.
!
IF .OUTPUT_FLAGS[OUTPUT_OPEN] AND NOT .QUAL[QUAL_PHYS]
THEN
    BEGIN
    FIB[FIB$L_ACCTL] = FIB$M_WRITE OR FIB$M_NOWRITE OR FIB$M_NORECORD;
    FIB[FIB$W_FID_NUM] = .OUTPUT_NAM[NAM$W_FID_NUM];
    FIB[FIB$W_FID_SEQ] = .OUTPUT_NAM[NAM$W_FID_SEQ];
    FIB[FIB$W_FID_RVN] = .OUTPUT_NAM[NAM$W_FID_RVN];
    FIB_DESC[0] = 10;
    FIB_DESC[1] = FIB;
    STATUS = C$QIOW(
	FUNC=IO$_ACCESS OR IO$M_ACCESS,
	CHAN=.OUTPUT_CHAN,
	IOSB=IOSB,
	P1=FIB_DESC);
    IF .STATUS THEN STATUS = .IOSB[0];
    IF NOT .STATUS
    THEN
	BEGIN
	FILE_ERROR(
	    BACKUP$_CONTINUE,
	    .OUTPUT_FAB,
	    .STATUS);
	CLOSE_RESTORE();
	END;
    END;
END;

GLOBAL ROUTINE INIT_RESTORE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine initializes the restore module.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	OWN storage initialized.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Find the output qualifiers block.
!
OUTPUT_QUAL = .QUAL[QUAL_OUTP_LIST];


IF .COM_FLAGS[COM_VERIFYING]
THEN
    BEGIN

    ! This is a verify pass.  Use the verification FAB as if it were the output
    ! FAB during the verify pass.
    !
    OUTPUT_FAB = .VERIFY_FAB;
    IF .QUAL[QUAL_OSAV]
    THEN
	ASSIGN_VERIFY_CHANNEL(FALSE)
    ELSE
	BEGIN
	LOCAL
	    FAB:	REF BBLOCK;	! Pointer to real output FAB

	FAB = .OUTPUT_QUAL[QUAL_PARA_FC];
	OUTPUT_FAB[FAB$B_FNS] = .FAB[FAB$B_FNS];
	OUTPUT_FAB[FAB$L_FNA] = .FAB[FAB$L_FNA];
	BBLOCK[OUTPUT_FAB[FC_NAM], NAM$B_ESL] = .BBLOCK[FAB[FC_NAM], NAM$B_ESL];
	BBLOCK[OUTPUT_FAB[FC_NAM], NAM$L_ESA] = .BBLOCK[FAB[FC_NAM], NAM$L_ESA];
	END;
    END
ELSE
    BEGIN
    OUTPUT_FAB = .OUTPUT_QUAL[QUAL_PARA_FC];
    END;


OUTPUT_FLAGS[OUTPUT_V_FIRST] = TRUE;
OUTPUT_NAM = OUTPUT_FAB[FC_NAM];


! If this is a compare or verify operation, get a compare buffer.
!
IF .QUAL[QUAL_COMP] THEN COMPARE_BCB = GET_BUFFER();


IF .QUAL[QUAL_PHYS] OR .QUAL[QUAL_IMAG]
THEN
    BEGIN
    LOCAL
	DESC:		VECTOR[2],		! Descriptor for DEVCHAR
	DEVCHAR:	BBLOCK[DIB$K_LENGTH],	! Device characteristics
	STATUS;					! Status variable


    IF NOT (.COM_FLAGS[COM_VERIFYING] AND .QUAL[QUAL_OSAV])
    THEN
	BEGIN

	! Strip everything but the device from the expanded string.
	!
	OUTPUT_NAM[NAM$B_ESL] = .BBLOCK[OUTPUT_QUAL[QUAL_DEV_DESC], DSC$W_LENGTH];


	! Assign a channel to the output device.
	!
	STATUS = ASSIGN_OUTPUT_CHANNEL(OUTPUT_QUAL[QUAL_DEV_DESC], OUTPUT_CHAN, 0, 0);
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_OPENOUT + STS$K_SEVERE,
		.OUTPUT_FAB,
		.STATUS);
	END;


    IF .QUAL[QUAL_PHYS]
    THEN
	BEGIN

	! Get the device characteristics of the output device.
	!
	DESC[0] = DIB$K_LENGTH;
	DESC[1] = DEVCHAR;
	STATUS = $GETCHN(CHAN=.OUTPUT_CHAN, PRIBUF=DESC);
	IF NOT .STATUS
	THEN
	    FILE_ERROR(
		BACKUP$_GETCHN,
		.OUTPUT_FAB,
		.STATUS);


	! Save the geometry data.
	!
	OUTPUT_DEVGEOM[DGM_SECTORS] = .DEVCHAR[DIB$B_SECTORS];
	OUTPUT_DEVGEOM[DGM_TRACKS] = .DEVCHAR[DIB$B_TRACKS];
	OUTPUT_DEVGEOM[DGM_CYLINDERS] = .DEVCHAR[DIB$W_CYLINDERS];
	OUTPUT_DEVGEOM[DGM_MAXBLOCK] = .DEVCHAR[DIB$L_MAXBLOCK];


	! Get the bad block data.
	!
	IF .OUTPUT_BAD EQL 0
	THEN
	    OUTPUT_BAD = GET_BADBLOCKS(.OUTPUT_FAB, .OUTPUT_CHAN, DEVCHAR);


	! Compute the blocks to be expected.
	!
	OUTPUT_FLAGS[OUTPUT_OPEN] = TRUE;
	OUTPUT_BLOCK = 0;
	OUTPUT_MAXBLOCK = .DEVCHAR[DIB$L_MAXBLOCK] - 1;
	IF .DEVCHAR[DIB$L_MAXBLOCK] GTRU SMALL_DISK
	THEN
	    OUTPUT_MAXBLOCK = .OUTPUT_MAXBLOCK -
		.DEVCHAR[DIB$B_SECTORS] /
		((.DEVCHAR[DIB$B_SECTORS] *
		  .DEVCHAR[DIB$B_TRACKS] *
		  .DEVCHAR[DIB$W_CYLINDERS]) /
		  .DEVCHAR[DIB$L_MAXBLOCK]);
	END;
    END;
END;

GLOBAL ROUTINE RESTORE_HANDLER(SIG,MECH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is established as a handler for routines RESTORE, LIST,
!	and ANALYZE.  It determines the recovery from a fatal signal.
!
! INPUT PARAMETERS:
!	SIG		- Standard VMS condition handler parameters.
!	MECH		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	VMS status code (SS$_CONTINUE or SS$_RESIGNAL).
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SIG:		REF BBLOCK,	! Signal parameters
	MECH:		REF BBLOCK;	! Mechanism parameters
EXTERNAL LITERAL
	BACKUP$_SSCHANGE,
	BACKUP$_READERRS,
	BACKUP$_POSITERR;


IF RESTARTABLE_CONDITION(.SIG[CHF$L_SIG_NAME])
THEN
    IF
	.SIG[CHF$L_SIG_NAME] EQL BACKUP$_SSCHANGE OR
	.SIG[CHF$L_SIG_NAME] EQL BACKUP$_READERRS OR
	.SIG[CHF$L_SIG_NAME] EQL BACKUP$_FATALERR OR
	.SIG[CHF$L_SIG_NAME] EQL BACKUP$_POSITERR
    THEN
	BEGIN
	GET_RESTART(.SIG, %B'10');
	RETURN SS$_CONTINUE;
	END;


SS$_RESIGNAL
END;

GLOBAL ROUTINE RESTORE: NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the driver for restore, compare, and verify operations.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
EXTERNAL ROUTINE
	INIT_IN_SAVE:	NOVALUE,
	READ_BUFFER,
	CONCURRENT_LIST:NOVALUE,
	FIN_IN_SAVE:	NOVALUE;
BUILTIN
	FP;


! If this is not a recursive call to do a verify pass, initialize the input
! save set and establish the handler.
!
IF NOT .COM_FLAGS[COM_VERIFYING]
THEN
    BEGIN
    .FP = RESTORE_HANDLER;
    INIT_IN_SAVE(FALSE);
    END;


! Initialize impure storage for restore.
!
INIT_RESTORE();


! Loop over all buffers in the save set to do the operation.
!
WHILE (OUTPUT_BCB = READ_BUFFER()) NEQ 0 DO
    BEGIN
    IF .QUAL[QUAL_LIST] AND NOT .COM_FLAGS[COM_VERIFYING]
	THEN CONCURRENT_LIST(.OUTPUT_BCB);
    DEBLOCK(.OUTPUT_BCB, RESTORE_ONE_RECORD);
    OUTPUT_BCB = 0;
    END;


! Finish the operation.
!
IF .COM_FLAGS[COM_VERIFYING] THEN OUTPUT_FLAGS[OUTPUT_V_LAST] = TRUE;
FIN_RESTORE();
OUTPUT_FLAGS[OUTPUT_V_LAST] = FALSE;


! If this is not a verify pass, do the termination for the input save set.
! Also, note that nothing was restored if this is the case.
!
IF NOT .COM_FLAGS[COM_VERIFYING]
THEN
    BEGIN
    FIN_IN_SAVE(FALSE);
    IF NOT .QUAL[QUAL_PHYS] AND NOT .COM_FLAGS[COM_FILESEEN]
    THEN
	SIGNAL(
	    BACKUP$_NOFILES, 1, BBLOCK[.QUAL[QUAL_INPU_LIST], QUAL_EXP_DESC]);
    END;
END;

END
ELUDOM
