;
;		MEMORY MANAGEMENT SERVICES TEST #7
;
;
	.TITLE	MMGXQUOTA - TEST MMG SERVICES WITH LOW PGFLQUOTA
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: USER MODE MEMORY MANAGEMENT SERVICES TEST
;
; ABSTRACT: THIS SET OF ROUTINES TESTS THE MEMORY MANAGEMENT SERVICES
;
; ENVIRONMENT: USER MODE DIAGNOSTIC
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 6-JAN-77
;
; MODIFIED BY:
;
;	V02-012	SHZ0008		Stephen Zalewski	20-Aug-1980
;		Added further tests to system services tested in this
;		program.  Also incorporated program into MMG test
;		package.
;
;	V02-012	TSC0007		Tom Clark		25-Jul-1980
;		Added further tests to system services tested in this
;		program.
;

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	.SBTTL	MACROS
;
; MACROS:
;
	.MACRO	LIST
	.LIST	MEB
	.ENDM	LIST

	.MACRO	NLIST
	.NLIST	MEB
	.ENDM	NLIST

	.MACRO	READ SIZ=#1,ADR=(R2),?L1,?L2
	IFNORD	<SIZ>,<ADR>,L1
	BRB	L2
L1:	MOVAL	W^READERR,R1
	BSBW	PROBERR
L2:
	.ENDM	READ

	.MACRO	WRITE SIZ=#1,ADR=(R2),?L1,?L2
	IFNOWRT	<SIZ>,<ADR>,L1
	BRB	L2
L1:	MOVAL	W^WRITERR,R1
	BSBW	PROBERR
L2:
	.ENDM	WRITE

	.MACRO	NOREAD SIZ=#1,ADR=(R2),?L1
	IFNORD	<SIZ>,<ADR>,L1
	MOVAL	W^NOREADERR,R1
	BSBW	PROBERR
L1:
	.ENDM	NOREAD

	.MACRO	NOWRITE SIZ=#1,ADR=(R2),?L1
	IFNOWRT	<SIZ>,<ADR>,L1
	MOVAL	W^NOWRITERR,R1
	BSBW	PROBERR
L1:
	.ENDM	NOWRITE

	.MACRO	ADJWSL	PAGCNT,LIMIT=#0,WSETLM,STATUS=S^#SS$_NORMAL
	LIST
		MOVZWL	STATUS,R3
		MOVL	PAGCNT,R4
		MOVL	LIMIT,R5
		.IF	B,WSETLM
		.IF	DIF,<LIMIT>,<#0>
		MOVAL	W^WRKSETLIM,R6
		.IFF
		CLRL	R6
		.ENDC
		.IFF
		MOVAL	WSETLM,R6
		.ENDC
		BSBW	ADJWSLSUBR
	NLIST
	.ENDM	ADJWSL

	.MACRO	EXPREG	PAGCNT,REGION=#0,STATUS=S^#SS$_NORMAL,-
		RETADR=W^RETRANGE
	LIST
		MOVZWL	STATUS,R3
		MOVL	PAGCNT,R4
		MOVAL	RETADR,R1
		.IF	IDN,<REGION>,<#0>
		CLRL	R5
		.IFF
		MOVL	REGION,R5
		.ENDC
		BSBW	EXPREGSUBR
	NLIST
	.ENDM	EXPREG

	.MACRO	CNTREG	PAGCNT,REGION=#0,STATUS=S^#SS$_NORMAL,-
		RETADR=W^RETRANGE
	LIST
		MOVZWL	STATUS,R3
		MOVL	PAGCNT,R4
		MOVAL	RETADR,R1
		.IF	IDN,<REGION>,<#0>
		CLRL	R5
		.IFF
		MOVL	REGION,R5
		.ENDC
		BSBW	CNTREGSUBR
	NLIST
	.ENDM	CNTREG

	.MACRO	LKWSET STARTVA,ENDVA,STATUS=S^#SS$_WASCLR,-
			INADR=W^INRANGE,RETADR=W^RETRANGE
	LIST
		.IF	NB,STARTVA
		MOVL	STARTVA,W^INRANGE
		.ENDC
		.IF	NB,ENDVA
		MOVL	ENDVA,W^INRANGE+4
		.ENDC
		MOVZWL	STATUS,R3
		MOVAL	INADR,R0
		MOVAL	RETADR,R1
		BSBW	LKWSETSUBR
	NLIST
	.ENDM	LKWSET

	.MACRO	ULWSET STARTVA,ENDVA,STATUS=S^#SS$_WASSET,-
			INADR=W^INRANGE,RETADR=W^RETRANGE
	LIST
		.IF	NB,STARTVA
		MOVL	STARTVA,W^INRANGE
		.ENDC
		.IF	NB,ENDVA
		MOVL	ENDVA,W^INRANGE+4
		.ENDC
		MOVZWL	STATUS,R3
		MOVAL	INADR,R0
		MOVAL	RETADR,R1
		BSBW	ULWSETSUBR
	NLIST
	.ENDM	ULWSET

	.MACRO	CRETVA STARTVA,ENDVA,STATUS=S^#SS$_NORMAL,-
			INADR=W^INRANGE,RETADR=W^RETRANGE
	LIST
		.IF	NB,STARTVA
		MOVL	STARTVA,W^INRANGE
		.ENDC
		.IF	NB,ENDVA
		MOVL	ENDVA,W^INRANGE+4
		.ENDC
		MOVZWL	STATUS,R3
		MOVAL	INADR,R0
		MOVAL	RETADR,R1
		BSBW	CRETVASUBR
	NLIST
	.ENDM	CRETVA

;*****************************************************************************
;	  THIS MACRO DELETES THE CURRENT VA ADDRESSES.  ALSO HIDDEN IN THIS
;	MACRO IS A TEST TO SEE IF A DELETE GLOBAL SECTION MUST ALSO BE
;	INVOKED.  THIS OCCURS DURING THE SECOND AND THIRD RUNS OF THE TEST
;	PROGRAM WHEN GLOBAL SECTION MAPPING AND PFN MAPPING ARE USED.
;*****************************************************************************
;
	.MACRO	DELTVA STARTVA,ENDVA,STATUS=S^#SS$_NORMAL,-
			INADR=W^INRANGE,RETADR=W^RETRANGE,?L1
	LIST
		CMPW	W^WHICHRUN,#RUN1	;IF USING MAPPED SECTIONS FOR TESTS,
		BLEQ	L1			;DELETE SECTION AND THEN DO A DELTVA
		$DGBLSC_S	-
			GSDNAM=<W^GBLSECNAM>
L1:
		.IF	NB,STARTVA
		MOVL	STARTVA,W^INRANGE
		.ENDC
		.IF	NB,ENDVA
		MOVL	ENDVA,W^INRANGE+4
		.ENDC
		MOVZWL	STATUS,R3
		MOVAL	INADR,R0
		MOVAL	RETADR,R1
		BSBW	DELTVASUBR

	NLIST
	.ENDM	DELTVA

;***************************************************************************
;	THIS MACRO USED TO CREATE PERMANENT GLOBAL SECTIONS.  THE FILE NAME
;	AND GBL SECTION DEVICE NAME ARE DECLARED INDEPENDANTLY OF THIS MACRO
;	AND ARE PUSHED ONTO THE STACK MANUALY BEFORE THE $CRMPSC SERVICE IS
;	CALLED.
;	  ALSO NOTE THE TEMPORARY FIX LOCATED AT THE BOTTOM OF THE MACRO.  THE
;	FIX IS NEEDED BECAUSE THE LAST GLOBAL SECTION MAY NOT HAVE BEEN DELETED
;	BY THE TIME THE NEXT MAPPED SECTION IS CREATED.  IN THIS CASE THE 
;	RETURNED ERROR IS TRAPPED AND THE SECTION IS REMAPPED UNTIL THE
;	SUCCESS CODE IS RETURNED.  THIS BUG IS SLATED TO BE FIXED.  WHEN THAT
;	IS ACCOMPLISHED REFER TO THE COMMENTS ABOVE THE FIX TO DETERMINE WHAT
;	LINES SHOULD BE REMOVED TO DELETE THE PATCH.
;*****************************************************************************
;
	.MACRO	CREMAPSEC -
		STARTVA		,-
		ENDVA		,-
		STATUS		,-
		INADR=<W^INRANGE>,-		;INPUT RANGE
		RETADR=<W^RETRANGE>  ,-		;RETURN RANGE
		FLAGS=#0	,-		;SECTION FLAGS
		GSDNAM=<W^GBLSECNAM>,-		;GLOBAL SECTION NAME
		RELPAG=#0	,-		;RELATIVE PAGE
		FILNAM=<W^FILENAME>,-		;FILE NAME
		PAGCNT=#0	,-		;MAX SIZE OF SECTION
		VBN=#0		,-		;STARTING WIRT BLK NO. IN FILE
		?L1
	LIST
		.IF	NB,STARTVA
		MOVL	STARTVA,W^INRANGE
		.ENDC
		.IF	NB,ENDVA
		MOVL	ENDVA,W^INRANGE+4
		.ENDC
		MOVZWL	STATUS,R3
L1:
		PUSHL	VBN
		PUSHL	PAGCNT
		$PUSHADR	FILNAM
		PUSHL	RELPAG
		$PUSHADR	GSDNAM
		PUSHL	FLAGS
		$PUSHADR	RETADR
		$PUSHADR	INADR
		CALLS	#8,LIB$_CREMAPSEC
;*******
;IN ORDER TO DELTE THE PATCH MENTIONED ABOVE SIMPLY REMOVE THE LINES FROM
;HERE TO THE NEXT SET OF ASTERICS.
;
		CMPL	#^X1828A,R0		;IF PREVIOUS GBL SECTION HASN'T
		BEQL	L1			;BEEN DELETED TRY CREMAPSEC AGAIN.
;*******
		MOVAL	W^CRMPSCERR,R1
		BSBW	CHECK1
	NLIST
	.ENDM	CREMAPSEC

;***************************************************************************
;	  THIS MACRO IS USED TO DETERMINE WHETHER THE MAKEVA SHOULD BE 
;	TRANSLATED INTO A $CRETVA, A $CRMPSC USING GLOBLAL SECTIONS,
;	OR A $CRMPSC USING PFN MAPPING.  THE DECISION IS BASED UPON WHICH
;	RUN THE PROGRAM IS CURRENTLY IN.
;	  ALSO NOTE THAT THE FIX THAT WAS APPLIED TO $CRMPSC MACRO LOCATED
;	ABOVE, WAS ALSO APPLIED TO THE $CRMPSC CALL LOCATED IN THE THIRD
;	PART OF THIS MACRO.  UPON THE FIX OF THIS BUG REFER TO THE
;	FIXED AREA TO FIND OUT WHAT MUST BE DELETED IN ORDER TO GET RID 
;	OF THE TEMPORARY PATCH.
;***************************************************************************
;
	.MACRO MAKEVA	STARTVA,ENDVA,STAT=S^#SS$_NORMAL,?L1,?L2,?L10,?L20,-
			?L30,?L40
	LIST
		CASEL W^WHICHRUN,#1,#RUNMAX
L1:	
		.WORD L10-L1			;IF FIRST RUN USE CRETVA.
		.WORD L20-L1			;IF SECOND USE GBL CREMAPSEC
		.WORD L30-L1			;IF THIRD USE PFN MAPPING
L10:
		CRETVA STARTVA,ENDVA,STATUS=STAT
	LIST
		BRW L40
L20:
	CREMAPSEC STARTVA,ENDVA,STATUS=STAT,-
		FLAGS=#<SEC$M_GBL!SEC$M_PERM!SEC$M_DZRO!SEC$M_WRT>,-
		PAGCNT=#25
	LIST
		BRW L40
L30:
		.IF	NB,STARTVA
		MOVL	STARTVA,W^INRANGE
		.ENDC
		.IF	NB,ENDVA
		MOVL	ENDVA,W^INRANGE+4
		.ENDC
		MOVZWL	STAT,R3
L2:
	$CRMPSC_S	-
		INADR=<W^INRANGE>,-
		RETADR=<W^RETRANGE>,-
		GSDNAM=<W^GBLSECNAM>,-
		VBN=#0,-
		FLAGS=#<SEC$M_GBL!SEC$M_PERM!SEC$M_PFNMAP!SEC$M_WRT>,-
		PAGCNT=#25
;*****
;IN ORDER TO REMOVE THE TEMPORARY FIX EXPLAINED ABOVE REMOVE THE LINES 
;STARTING FROM HERE AND EXTENDING THE THE NEXT SET OF ASTERICS.
;
		CMPL	#^X1828A,R0		;IF PREVIOUS GBL SECTION HASN'T
		BEQL	L2			;BEEN DELETED TRY CREMAPSEC AGAIN.
;*****
		MOVAL	W^CRMPSCERR,R1
		BSBW	CHECK1
L40:
	NLIST
	.ENDM	MAKEVA

	.MACRO	RANGECHK ONOROFF
	LIST
	.IF	IDN <ONOROFF>,<OFF>
		BICL	#CTL$M_RNGCHK,W^CTLFLG
	.IFF
		BISL	#CTL$M_RNGCHK,W^CTLFLG
	.ENDC
	NLIST
	.ENDM	RANGECHK

;
; EQUATED SYMBOLS:
;
	$SECDEF
	$SSDEF
	$PRTDEF
	$GBLINI
	$VIELD	CTL,0,<-			;DEFINE CONTROL BITS IN R3
		<MEMLOOP,,MASK>,-		;LOOP IN MEMORY WRITE LOOP
		<TSTLOOP,,MASK>,-		;REDO ENTIRE TEST FROM TOP
		<PIDMSG,,MASK>,-		;PUT PROCESS ID IN EACH TYPEOUT
		<RNGCHK,,MASK>-			;ON IF CHECKING RETURN RANGE
	>
	PRT$C_NONE=1@4
	RUN2=2
	RUN1=1
	RUNMAX=3
;
; OWN STORAGE:
;

	.SBTTL	DATA STORAGE AND MESSAGE STRINGS
	.PSECT	DATA0,PAGE,WRT,NOEXE
INRANGE:
	.BLKL	2
RETRANGE:
	.BLKL	2
CTLFLG:	.LONG	CTL$M_TSTLOOP!CTL$M_PIDMSG
SAVEND:	.BLKL	1
HIGHP0ADR:
	.BLKL	1				;LAST BYTE ADDRESS IN P0 SPACE
PID:	.BLKL	1				;PROCESS ID
MAXPASSCNT:
	.LONG	3				;NUMBER OF PASSES TO RUN
PASSCNT:
	.BLKL	1				;PASS COUNTER
MAXWHICHRUN:
	.LONG	3				;NUMBER OF RUNS
WHICHRUN:
	.BLKL	1				;WHICH RUN COUNTER
WRKSETLIM:
	.BLKL	1				;RETURNED NEW WORKING SET LIMIT
WRKSETDEF:
	.BLKL	6				;DEFAULT, MAX, MIN WORKING SET LIMITS
	WRKSETMAX=WRKSETDEF+8
	WRKSETMIN=WRKSETDEF+16
WRKSETMAXADD:
	.BLKL	1				;WRKSETMAX-WRKSETDEF
PREVPROT:
FAB:	$FAB	FAC=PUT, FNA=OUTNAMADR, FNS=OUTNAMSIZ ;FAB FOR OUTPUT
RAB:	$RAB	FAB=FAB				;RECORD ACCESS BLOCK FOR OUTPUT
MSGLEN:	.BLKL	1				;RETURN LENGTH FROM FAO
MSGBUFD:.LONG	MSGBUFSIZ,MSGBUF		;MESSAGE BUFFER DESCRIPTOR
PIDMSGD:
	.LONG	MSGBUF-PIDMSG,PIDMSG
;
; ***** DO NOT SEPARATE OR REORDER THE FOLLOWING LINES
;
MSGBUFID:
CRLF:	.BYTE	^O15,^O12
	.ASCII	$PROCESS $
PIDMSG:	.ASCII	$    $
MSGBUF:	.BLKB	160				;MESSAGE BUFFER USED BY FAO
	MSGBUFSIZ=.-MSGBUF
;
; ***** DO NOT SEPARATE OR REORDER THE PRECEEDING LINES
;


	.PSECT	CODE,PAGE,NOWRT,EXE

OUTNAMADR:
	.ASCII	/SYS$OUTPUT/
	OUTNAMSIZ=.-OUTNAMADR

CRETVAERRADR:
	.ASCII	$!/CRETVA ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	INADR = !XL - !XL,  RETADR = !XL - !XL!/$
	CRETVAERRSIZ=.-CRETVAERRADR

DELTVAERRADR:
	.ASCII	$!/DELTVA ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	INADR = !XL - !XL,  RETADR = !XL - !XL!/$
	DELTVAERRSIZ=.-DELTVAERRADR

CRMPSCERRADR:
	.ASCII	$!/CRMPSC ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	INADR = !XL - !XL,  RETADR = !XL - !XL!/$
	CRMPSCERRSIZ=.-CRMPSCERRADR

LKWSETERRADR:
	.ASCII	$!/LKWSET ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	INADR = !XL - !XL,  RETADR = !XL - !XL!/$
	LKWSETERRSIZ=.-LKWSETERRADR

ULWSETERRADR:
	.ASCII	$!/ULWSET ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	INADR = !XL - !XL,  RETADR = !XL - !XL!/$
	ULWSETERRSIZ=.-ULWSETERRADR

CNTREGERRADR:
	.ASCII	$!/CNTREG ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	PAGCNT = !UL, REGION = P!UB SPACE, $
	.ASCII	$RETADR = !XL - !XL!/$
	CNTREGERRSIZ=.-CNTREGERRADR

EXPREGERRADR:
	.ASCII	$!/EXPREG ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	PAGCNT = !SL, REGION = P!UB SPACE, $
	.ASCII	$RETADR = !XL - !XL!/$
	EXPREGERRSIZ=.-EXPREGERRADR

ADJWSLERRADR:
	.ASCII	$!/ADJWSL  ERROR - PC = !XL, STATUS WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	PAGCNT = !SL, LIMIT WAS !UW, SHOULD BE !UW!/$
	ADJWSLERRSIZ=.-ADJWSLERRADR

WSETLMCTLADR:
	.ASCII	$!/WORKING SET SIZE/LOCKED LIMITS:  $
	.ASCII	$DEFAULT !UL/!UL, MAX !UL/!UL, MIN !UL/!UL!/$
	WSETLMCTLSIZ=.-WSETLMCTLADR

READERRADR:
	.ASCII	$!/ READ ERROR - LOCATION = !XL !/$
	READERRSIZ=.-READERRADR

NOREADERRADR:
	.ASCII	$!/ NO-READ ERROR - LOCATION = !XL !/$
	NOREADERRSIZ=.-NOREADERRADR

WRITERRADR:
	.ASCII	$!/ WRITE ERROR - LOCATION = !XL !/$
	WRITERRSIZ=.-WRITERRADR

NOWRITERRADR:
	.ASCII	$!/ NO-WRITE ERROR - LOCATION = !XL !/$
	NOWRITERRSIZ=.-NOWRITERRADR

MEMLOOPCTLADR:
	.ASCII	$!/MEMORY LOOP ERROR$
	.ASCII	$!/	FILE BLOCK	WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	MEMORY ADR	WAS !XL, SHOULD BE !XL$
	.ASCII	$!/	PROCESS ID	WAS !XL, SHOULD BE !XL$
	MEMLOOPCTLSIZ=.-MEMLOOPCTLADR

RANGERRADR:
	.ASCII	$!/RETURN RANGE ERROR - LOCATION = !XL$
	.ASCII	$!/	INADR = !XL - !XL, RETADR = !XL - !XL!/$
	RANGERRSIZ=.-RANGERRADR

IDMSGADR:
	.ASCII	$!/MEMORY MANAGEMENT SERVICES TEST #7 (XQUOTA), PASS !UL!/$
	IDMSGSIZ=.-IDMSGADR

RUN1_MSGADR:
	.ASCII	$!/   *****   TEST WILL NOW BE RUN USING REGULAR VA SPACE   *****$
	.ASCII	$!/ $
	RUN1_MSGSIZ=.-RUN1_MSGADR

RUN2_MSGADR:
	.ASCII	$!/   *****   TEST WILL NOW BE RUN USING PERM GBL SECTIONS   *****$
	.ASCII	$!/ $
	RUN2_MSGSIZ=.-RUN2_MSGADR

RUN3_MSGADR:
	.ASCII	$!/   *****   TEST WILL NOW BE RUN USING PFN MAPPING   *****$
	.ASCII	$!/ $
	RUN3_MSGSIZ=.-RUN3_MSGADR

PIDCTLADR:
	.ASCII	$!UL$
	PIDCTLSIZ=.-PIDCTLADR

GBLSECNAMADR:
	.ASCII	$MMGTST$
	GBLSECNAMSIZ=.-GBLSECNAMADR

FILENAMEADR:
	.ASCII	$MMGTST.DAT$
	FILENAMESIZ=.-FILENAMEADR


;
; STRING DESCRIPTORS
;
	.ALIGN	LONG

CRETVAERR:
	.LONG	CRETVAERRSIZ,CRETVAERRADR
DELTVAERR:
	.LONG	DELTVAERRSIZ,DELTVAERRADR
CNTREGERR:
	.LONG	CNTREGERRSIZ,CNTREGERRADR
CRMPSCERR:
	.LONG 	CRMPSCERRSIZ,CRMPSCERRADR
EXPREGERR:
	.LONG	EXPREGERRSIZ,EXPREGERRADR
LKWSETERR:
	.LONG	LKWSETERRSIZ,LKWSETERRADR
ULWSETERR:
	.LONG	ULWSETERRSIZ,ULWSETERRADR
ADJWSLERR:
	.LONG	ADJWSLERRSIZ,ADJWSLERRADR
WSETLMCTL:
	.LONG	WSETLMCTLSIZ,WSETLMCTLADR
READERR:
	.LONG	READERRSIZ,READERRADR
NOREADERR:
	.LONG	NOREADERRSIZ,NOREADERRADR
WRITERR:
	.LONG	WRITERRSIZ,WRITERRADR
NOWRITERR:
	.LONG	NOWRITERRSIZ,NOWRITERRADR
MEMLOOPCTL:
	.LONG	MEMLOOPCTLSIZ,MEMLOOPCTLADR
RANGERR:
	.LONG	RANGERRSIZ,RANGERRADR
IDMSG:
	.LONG	IDMSGSIZ,IDMSGADR
RUN1_MSG:
	.LONG	RUN1_MSGSIZ,RUN1_MSGADR
RUN2_MSG:
	.LONG	RUN2_MSGSIZ,RUN2_MSGADR
RUN3_MSG:
	.LONG	RUN3_MSGSIZ,RUN3_MSGADR
PIDCTL:
	.LONG	PIDCTLSIZ,PIDCTLADR
GBLSECNAM:
	.LONG	GBLSECNAMSIZ,GBLSECNAMADR
FILENAME:
	.LONG	FILENAMESIZ,FILENAMEADR


	.SBTTL	INITIALIZATION
;**************************************************************************
;PROGRAM DESCRIPTION:
;
;	  THIS PROGRAM TESTS THE FOLLOWING SYSTEM SERVICES:
;		$CRETVA, $EXPREG
;
;	  THE SYSTEM SERVICES ARE TESTED IN THE FOLLOWING MANNER. THE PROGRAM
;	IS DESIGNED TO MAKE THREE RUNS.  EACH RUN MAKES THREE PASSES.  ON
;	THE FIRST RUN WHEN A MAKEVA IS ENCOUNTERED IT IS REPLACED WITH A
;	CRETVA. IT THEN MAKES THREE PASSES THROUGH THE PROGRAM DOING
;	ALL THE POSSIBLE TESTS.  ON THE SECOND RUN THE MAKEVA IS ENCOUNTERED
;	AND IS REPLACED WITH A $CRMPSC THAT MAPS A PERMANENT GLOBAL SECTION.
;	FOR THE THIRD RUN, THE MAKVA IS REPLACED WITH A $CRMPSC THAT MAPS
;	A PFN GLOBAL SECTION.  USING THIS APPROACH THE $CRMPSC SYSTEM SERVICE
;	WAS ALSO ABLE TO BE TESTED AS ALL ERROR PATHS FOLLOWED WHEN USING
;	NORMAL VA ARE ALSO APPLICABLE WHEN USING GBL SECTION MAPPING.
;	  FOR EACH OF THESE RUNS A MESSAGE IS SENT TO THE TERMINAL
;	INFORMING THE OPERATOR AS TO WHICH OF THESE SUBTITUTE MAKEVA'S WILL
;	BE USED FOR THAT SET OF PASSES.
;
;	  REFER TO MASD$:[MMGTST.COM]MMGTST.RAP FOR FURTHER INFORMATION
;	REGARDING JUST HOW COMPLETELY THE ABOVE MENTIONED SYSTEM SERVICES
;	ARE TESTED BY THIS PROGRAM.
;
;      *NOTE:
;	  THERE IS A BUG IN $CRMPSC THAT WILL BE FIXED IN THE FUTURE.  UNTIL
;	THIS FIX TAKES PLACE THERE AREA TEMPORARY PATCH'S LOCATED AT THE END
;	OF THE CREMAPSEC MACRO AND MAKVA MACRO WHICH CIRCUMVENT THIS
;	PROBLEM.  UPON CORRECTION OF THIS BUG REFER TO THESE ABOVE MENTIONED
;	MACROS TO FIND OUT HOW TO REMOVE THESE TEMPORARY PATCHES.
;	  ALSO, THE FILE MMGTST.DAT, WHICH IS CREATED BY RUNNING MMGCRTFIL.MAR,
;	IS NECESSARY TO RUN THIS PROGRAM AS IT IS REFERENCED BY CREMAPSEC.
;
;      *PRIVILEGES:
;	  IN ORDER TO RUN THIS PROGRAM YOU MUST HAVE IN YOUR POSSESION
;	THE PRIVILEGES PRMGBL AND PFNMAP.
;****************************************************************************
;
; START HERE
;
START:	.WORD	0				;ENTRY MASK
	$OPEN	W^FAB				;OPEN THE FILE "$OUTPUT"
	BLBC	R0,10$				;BRANCH IF ERROR
	$CONNECT W^RAB				;CONNECT THE RECORD ACCESS BLOCK
	BLBS	R0,20$	
10$:	$EXIT_S	R0				;EXIT WITH STATUS IN R0
20$:	$RESUME_S PID				;SET UP PROCESS ID
	MOVZWL	PID,R0
	$FAO_S	PIDCTL,MSGLEN,PIDMSGD,R0	;INIT THE PROCESS ID STRING
	CLRL	WHICHRUN			;INIT THE RUN COUNT TO ZERO


MAIN_PROGRAM:
;***************************************************************************
;	THIS COUNTER IS USED TO DETERMINE WHICH CRMPSC IS TO BE
;	REFERENCED, OR IF THE CRETVA IS TO BE USED, WHEN A MAKEVA
;	IS ENCOUNTERED.
;***************************************************************************

	MOVL	#1,W^PASSCNT			;INITIALIZE THE PASS COUNT
	AOBLEQ	W^MAXWHICHRUN,W^WHICHRUN,PRESTART

END:
	MOVZBL	#SS$_NORMAL,R0
	$EXIT_S	R0

PRESTART:
	CASEL	W^WHICHRUN,#1,#RUNMAX
L50:
	.WORD	CRETVA_MESSAGE-L50		;FOR EACH RUN PRINT MESSAGE
	.WORD	GBL_SEC_MESSAGE-L50		;DESCRIBING WHICH VA SPACE
	.WORD	PFNMAP_MESSAGE-L50		;IS BEING USED.

CRETVA_MESSAGE:
	$FAO_S	RUN1_MSG,MSGLEN,MSGBUFD
	BSBW	TYPEMSGBUF
	BRB	RSTART

GBL_SEC_MESSAGE:
	BISL	#CTL$M_PIDMSG,W^CTLFLG		;ALLOW PROCESS ID TO PRINT
	$FAO_S	RUN2_MSG,MSGLEN,MSGBUFD
	BSBW	TYPEMSGBUF
	BRB	RSTART

PFNMAP_MESSAGE:
	BISL	#CTL$M_PIDMSG,W^CTLFLG		;ALLOW PROCESS ID TO PRINT
	$FAO_S	RUN3_MSG,MSGLEN,MSGBUFD
	BSBW	TYPEMSGBUF

RSTART:
	RANGECHK ON
	BICL	#CTL$M_PIDMSG,W^CTLFLG		;STOP PROCESS ID FROM PRINTING
	$FAO_S	IDMSG,MSGLEN,MSGBUFD,PASSCNT
	BSBW	TYPEMSGBUF
	EXPREG	#1
	MOVQ	W^RETRANGE,R2
	MOVQ	R2,W^INRANGE
	MOVL	R2,W^SAVEND
	DELTVA



	.SBTTL	FORCE ERRORS IN CRETVA
;
; FORCE ERRORS FROM CRETVA
;
;*************************************************************************
;	  THIS MAKEVA IS NOT AVAILABLE FOR THE SECOND RUN, WHEN PERM
;	GLOBAL SECTIONS ARE USED, AS IN ORDER FOR THE EXPECTED ERROR TO
;	BE RETURNED THE PAGES MUST BE CRF AND SINCE SHARED MEMORY TESTING
;	IS POSSIBLE WITH THIS TEST (AND CRF IS NOT PERMITTED WITH SHARED
;	MEMORY) THIS SECTION WAS BYPASSED FOR THAT REASON.
;************************************************************************
;
	CMPW	W^WHICHRUN,#RUN2
	BNEQ	10$
	BRW	REROUTE
10$:

	MAKEVA	W^SAVEND,#1@30-1,#SS$_EXQUOTA	;EXCEED PAGE FILE QUOTA
	MOVQ	W^RETRANGE,W^INRANGE
	DELTVA					;DELETE WHAT WE CREATED

REROUTE:

	.SBTTL	FORCE ERRORS FROM EXPREG
;
; FORCE ERRORS FROM EXPREG
;	
	EXPREG	#1@21-1,#0,STATUS=#SS$_EXQUOTA	;EXCEED PAGE FILE QUOTA
	MOVQ	W^RETRANGE,W^INRANGE
	DELTVA					;DELETE WHAT WE CREATED

;
;END OF LOOP
;
	AOBLEQ	W^MAXPASSCNT,W^PASSCNT,160$
150$:	BRW	MAIN_PROGRAM

160$:	BRW 	RSTART

	.SBTTL	SUBROUTINES TO CALL THE SERVICES
;
; INPUT:
;
;	R0 = INADR
;	R1 = RETADR
;	R3 = DESIRED STATUS
;
; OUTPUT:
;
;	R2 PRESERVED
;
CRETVASUBR:
	$CRETVA_S (R0),(R1)
	MOVAL	W^CRETVAERR,R1			;ERROR CONTROL STRING
	BRB	CHECK1
;
; INPUT:
;
;	R0 = INADR
;	R1 = RETADR
;	R3 = DESIRED STATUS
;
; OUTPUT:
;
;	R2 PRESERVED
;
DELTVASUBR:
	$DELTVA_S (R0),(R1)
	MOVAL	W^DELTVAERR,R1			;ERROR CONTROL STRING
	BRB	CHECK1
;
; INPUT:
;
;	R0 = INADR
;	R1 = RETADR
;	R3 = DESIRED STATUS
;
; OUTPUT:
;
;	R2 PRESERVED
;
LKWSETSUBR:
	$LKWSET_S (R0),(R1)
	MOVAL	W^LKWSETERR,R1			;ERROR CONTROL STRING
	BRB	CHECK1
;
; INPUT:
;
;	R0 = INADR
;	R1 = RETADR
;	R3 = DESIRED STATUS
;
; OUTPUT:
;
;	R2 PRESERVED
;
ULWSETSUBR:
	$ULWSET_S (R0),(R1)
	MOVAL	W^ULWSETERR,R1			;ERROR CONTROL STRING
CHECK1:
	CMPL	R0,R3				;STATUS AS DESIRED
	BEQL	10$				;BRANCH IF YES
	CMPW	#SS$_VASFULL,R3			;IF EXPECTING VIRTUAL ADDRESS SPACE FULL
	BNEQ	15$
	CMPW	#SS$_EXQUOTA,R0			;THEN EXCEEDS QUOTA MAY ALSO BE RETURNED
	BEQL	10$
15$:
	CMPW	#SS$_NORMAL,R3			;IF EXPECTING NORMAL COMPLETION
	BNEQ	5$				;FOR CRMPSC, THEN GLOBAL SECTION
	CMPW	#SS$_CREATED,R0			;CREATED MAY BE RETURNED
	BEQL	10$

5$:	PUSHL	R4
	MOVL	4(SP),R4			;ADDRESS OF ERROR
	$FAO_S	(R1),MSGLEN,MSGBUFD,R4,R0,R3,-
		INRANGE,INRANGE+4,RETRANGE,RETRANGE+4
	POPR	#^M<R4>
	BSBW	TYPEMSGBUF
	RSB
10$:
	BRW	RANGECHK			;GO CHECK THE RETURN RANGE
;
; INPUT:
;
;	R1 = RETADR
;	R3 = DESIRED STATUS
;	R4 = PAGCNT
;	R5 = REGION
;
; OUTPUT:
;
;	R2 PRESERVED
;
CNTREGSUBR:
	$CNTREG_S R4,(R1),,R5
	MOVAL	W^CNTREGERR,R1			;ERROR CONTROL STRING
	BRB	CHECK2
;
; INPUT:
;
;	R1 = RETADR
;	R3 = DESIRED STATUS
;	R4 = PAGCNT
;	R5 = REGION
;
; OUTPUT:
;
;	R2 PRESERVED
;
EXPREGSUBR:
	$EXPREG_S R4,(R1),,R5
	MOVAL	W^EXPREGERR,R1			;ERROR CONTROL STRING
CHECK2:
	CMPL	R0,R3				;STATUS AS DESIRED?
	BEQL	10$				;BRANCH IF YES
	PUSHL	R6
	MOVL	4(SP),R6			;ADDRESS OF ERROR
	$FAO_S	(R1),MSGLEN,MSGBUFD,R6,R0,R3,R4,R5,-
		RETRANGE,RETRANGE+4
	POPR	#^M<R6>
	BSBW	TYPEMSGBUF
	RSB
10$:	MOVL	W^RETRANGE,W^INRANGE		;MAKE INPUT RANGE LOOK LIKE CRETVA/DELTVA
	DECL	R4
	ASHL	#9,R4,R4
	ADDL3	R4,W^INRANGE,W^INRANGE+4
	BRB	RANGECHK			;AND CHECK THE RETURN RANGE

RANGECHK:
	BBC	#CTL$V_RNGCHK,W^CTLFLG,40$ 	;BRANCH IF RANGE CHECK IS DISABLED
	BLBC	R0,40$				;IF ERROR IN SERVICE, SKIP THE RANGE CHECK
	MOVQ	W^INRANGE,R0			;R0 = STARVA, R1 = ENDVA
	CMPL	R0,R1				;WHICH DIRECTION?
	BGTRU	10$				;BRANCH IF BACKWARDS
	BLSSU	5$				;BRANCH IF FORWARDS
	BBS	#30,R0,10$			;FOR EQUAL, P0 SPACE FORWARDS, P1 BACKWARDS
;
; REQUESTED RANGE IS FORWARDS
;
5$:	BICW	#^X1FF,R0			;FROM BYTE 0 OF STARTVA
	BISW	#^X1FF,R1			;THROUGH LAST BYTE OF ENDVA
	BRB	20$				;
;
; GOING BACKWARDS IN VIRTUAL ADDRESS SPACE
;
10$:	BISW	#^X1FF,R0			;LAST BYTE OF STARTVA
	BICW	#^X1FF,R1			;THROUGH FIRST BYTE OF ENDVA
20$:	CMPL	R0,W^RETRANGE			;IS THIS WHAT WAS RETURNED?
	BNEQ	30$				;BRANCH IF NOT, ERROR
	CMPL	R1,W^RETRANGE+4			;THIS ONE OK TOO?
	BEQL	40$				;BRANCH IF YES, RANGE OK
30$:	PUSHL	R3				;SAVE REGISTER
	MOVL	4(SP),R3			;TO USE FOR ERROR PC
	$FAO_S	<W^RANGERR>,MSGLEN,MSGBUFD,R3,- ;FORMAT THE ERROR MESSAGE
		INRANGE,INRANGE+4,RETRANGE,RETRANGE+4
	POPR	#^M<R3>				;RESTORE SAVE REGISTER
	BSBW	TYPEMSGBUF			;OUTPUT THE ERROR MESSAGE
40$:	RSB					;AND RETURN
;
; INPUT:
;
;	R3 = DESIRED STATUS
;	R4 = PAGCNT
;	R5 = DESIRED LIMIT
;	R6 = ADDRESS TO RETURN NEW WORKING SET LIMIT
;
; OUTPUT:
;
;	R2 PRESERVED
;
ADJWSLSUBR:
	$ADJWSL_S R4,(R6)
	IFNOWRT	#4,(R6),10$			;SKIP WORKING SET LIMIT CHECK
						;IF NEW LIMIT WAS NOT RETURNED
	TSTL	R5				;ALSO SKIP THE CHECK
	BEQL	10$				;IF ZERO WAS SPECIFIED
	CMPW	R5,(R6)				;OTHERWISE CHECK DESIRED WORKING
						;SET LIMIT AGAINST THAT RETURNED
	BNEQ	20$				;BRANCH IF ERROR
10$:
	CMPL	R0,R3				;STATUS AS DESIRED?
	BEQL	30$				;BRANCH IF YES
20$:
	PUSHL	R7
	MOVL	4(SP),R7			;ADDRESS OF ERROR
	$FAO_S	ADJWSLERR,MSGLEN,MSGBUFD,R7,R0,R3,-
		R4,WRKSETLIM,R5
	POPL	R7
	BSBW	TYPEMSGBUF
30$:
	RSB

	.SBTTL	MISCELLANEOUS SUBROUTINES
;
; TYPE A MESSAGE
;	MSGBUF IS THE ADDRESS OF THE BEGINNING OF THE STRING
;	MSGLEN CONTAINS THE SIZE (IN BYTES) OF THE STRING
;
TYPEMSGBUF:
	MOVL	W^MSGLEN,R0			;SIZE TO R0
	MOVAL	W^MSGBUF,R1			;ADDRESS TO R1
	BBC	#CTL$V_PIDMSG,W^CTLFLG,5$ 	;BRANCH IF NO PROCESS ID REQUIRED
	MOVAL	W^MSGBUFID,R1			;ADDRESS INCLUDING PID MSG
	ADDL	S^#<MSGBUF-MSGBUFID>,R0		;INCLUDE EXTRA BYTES IN COUNT
5$:
	MOVL	R1,W^RAB+RAB$L_RBF		;SET BUFFER ADDRESS
	MOVW	R0,W^RAB+RAB$W_RSZ		;AND SIZE
	$PUT	W^RAB				;OUTPUT THE MESSAGE
	BLBC	R0,20$
	RSB
20$:	$EXIT_S	R0				;EXIT WOTH ERROR STATUS
;
; INPUTS:
;
;	0(SP) = ADDRESS OF ERROR
;	R1 = ADDRESS OF FORMAT CONTROL STRING
;
; OUTPUTS:
;
;	R2 PRESERVED
;
PROBERR:
	PUSHL	R5
	MOVL	4(SP),R5
	$FAO_S	(R1),MSGLEN,MSGBUFD,R5
	POPR	#^M<R5>
	BSBW	TYPEMSGBUF
	RSB


;
; INPUT:
;
;	INRANGE CONTAINS INFINITE RANGE OF ADDRESSES PREVIOUSLY CREATED
;	RETRANGE CONTAINS A RANGE OF ADDRESSES
;	R10 CONTAINS ADDRESS TO STORE THE # OF PAGES SPANNED BY RETRANGE
;
; OUTPUT:
;
;	R10 UPDATED TO POINT AT NEXT LONG WORD
;
MAXPAGLOCK:
	LKWSET	STATUS=#SS$_LKWSETFUL		;LOCK AS MANY AS ALLOWED
	SUBL3	W^RETRANGE,W^RETRANGE+4,R0 	;NUMBER OF BYTES IN RANGE
	BEQL	20$				;BRANCH IF NONE LOCKED
	ASHL	#-9,R0,R0			;NUMBER OF PAGES -1
	ADDL3	#1,R0,(R10)+			;STORE NUMBER OF PAGES
	RANGECHK OFF
	ULWSET	INADR=W^RETRANGE		;UNLOCK THE ONES THAT WERE LOCKED
	RANGECHK ON
	RSB
20$:	CLRL	(R10)+				;NO PAGES LOCKED
	RSB


	.END	START
