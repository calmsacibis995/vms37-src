MODULE BAS$$UDF_WL (				! BASIC Write List Directed UDF
		IDENT = '1-070'			! File: BASUDFWL.B32 Edit:PL1070
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  BASIC Support Library - not user callable
!
! ABSTRACT:
!
! ENVIRONMENT:  User access mode; reentrant AST level or not.
!
! AUTHOR:	Donald G. Petersen;	CREATION DATE: 17-Mar-78
!
! MODIFIED BY:
!
! 0-14	- Store error in ISB$B_ERR_NO, don't signal it! JMT 14-Jan-78
!	Donald G. Petersen, 17-Mar-78: Version 1-01
! 1-01	-  original
! 1-02	- Change to JSB linkage.  DGP 14-Nov-78
! 1-004	- Update copyright notice and add device names to REQUIRE
!	   files.  JBS 29-NOV-78
! 1-005 - Change LUB$B_PRINT_SIZ to LUB$B_R_MARGIN.  DGP 05-Dec-78
! 1-006	- Change REQUIRE file names from FOR... to OTS...  JBS 07-DEC-78
! 1-007	- Fix some failures to return values (new BLISS compiler) and
!	   run through PRETTY to improve appearance.  JBS 20-DEC-78
! 1-008 - Add a longword entry point to WL1.  DGP 27-Dec-78
! 1-009 - Change one argument in call to BAS$CNV_OUT_G. DGP 03-Jan-78
! 1-010 - Change references to ISB$A_BUF_BEG, BUF_END, and BUF_PTR to LUB.
!	  DGP 05-Jan-79
! 1-011 - Change some constants to symbolics.  DGP 10-Jan-79
! 1-012 - Convert to CR format for data files.  DGP 11-Jan-79
! 1-013 - Fix a bug in Print string.  DGP 16-Jan-79
! 1-014 - Add a guard bit for AST reentrancy.  DGP 20-Jan-79
! 1-015 - Correct a typo in edit 014.  JBS 20-JAN-1979
! 1-016 - Change DO_WRITE to a Global routine BAS$$DO_WRITE so that it can
!	  be called by another module which does I/O cleanup at the end of a
!	  program.  DGP 22-Jan-79
! 1-017	- Use 32-bit addresses for externals.  JBS 27-JAN-1979
! 1-018 - Change buffer overflow handling in BAS$$UDF_WL1.  DGP 22-Feb-79
! 1-019 - Make change to handling of strings longer than output buffer.  DGP
!	  27-Feb-79
! 1-020 - Make LUB$B_PRINT_POS a longword.  DGP 19-Mar-79
! 1-021 - Fix a few bugs in PRINT.  DGP 19-Mar-79
! 1-022 - Make another attempt to get comma formatting working.  DGP 02-Apr-79
! 1-023 - Semicolon formatting didn't check for overflow of right margin.
!	  DGP 03-Apr-79
! 1-024 - SCAN_TEXT not working properly for non-printing characters.  DGP
!	  10-Apr-79
! 1-025 - Fix an obscure error in SCAN_TEXT.  DGP 12-Apr-79
! 1-026 - Change macro CHK_CURSOR_POS to GTR from GTRU.  DGP 16-Apr-79
! 1-027 - TAB is always at least one space when updating printhead position.
!	  DGP 16-Apr-79
! 1-028 - Don't allow print_pos to go less than 0 for backspace characters.
!	  DGP 16-Apr-79
! 1-029 - Add support for CRLF delimiting a record.  DGP 25-Apr-79
! 1-030 - Remove Global attribute from BAS$$DO_WRITE.  DGP 10-May-79
! 1-031	- Change ISB$V_AST_GUARD to LUB$V_AST_GUARD.  JBS 15-MAY-1979
! 1-032 - Make BAS$$DO_WRITE global again for BASUDFWF.  DGP 15-May-79
! 1-033	- Make the margin 16 bits.  JBS 30-MAY-1979
! 1-034 - BAS$$UDF_WL0 now initializes LUB$V_FORM_CHAR to 0.  DGP 12-Jun-79
! 1-035 - Update LUB$A_BUF_PTR in case where string is too long to fit in
!	  buffer.  DGP 20-Jun-79
! 1-036 - Update LUB$A_BUF_PTR correctly if string is too long.  DGP 26-Jun-79
! 1-037 - Use the new conversion routines.  DGP 28-Jun-79
! 1-038 - Check V_NOMARGIN and allow infinite margin if set.  DGP 11-Jul-79
! 1-039 - Check for buffer overflow as well as right margin.  DGP 15-Jul-79
! 1-040 - Allow Mat Print to jump to REC level from UDF_WL1.  DGP 08-Aug-79
! 1-041 - Remove the BUILTIN ACTUALCOUNT.  DGP 04-Sep-79
! 1-042 - PRINT 10 digits for longword integer.  DGP 07-Sep-79
! 1-043 - Debug CRLF delimiting a record.  DGP 23-Sep-79
! 1-044 - Clear LUB$L_PRINT_POS for Mat Print if no format character.  DGP
!	  02-Oct-79
! 1-045 - Clear ISB$V_MAT_PRINT.  DGP 05-Oct-79
! 1-046 - Make UDF9 dispatch to the REC level.  DGP  12-Oct-79
! 1-047 - Try again to get 'CRLF' to delimit a record.  DGP 15-Oct-79
! 1-048 - Fix bug in printing long strings.  The pointer was not moving through
!	  the string.  Also, leave the cursor where it lies after each little
!	  piece of the long string.  DGP 01-Nov-79
! 1-049 - Pass one arg to BAS$$DO_WRITE to indicate whether to put out
!	  End-of-record.  DGP 06-Nov-79
! 1-050 - Last edit screwed the proper resetting of LUB$L_PRINT_POS in
!	  BAS$$DO_WRITE; fix same.  DGP 08-Nov-79
! 1-051 - Update columns 10-15 in the translation table in SCAN_TEXT.  DGP
!	  09-Nov-79
! 1-052 - Don't update LUB$A_BUF_PTR in CHK_CURSOR_POS macro.  DGP  09-Nov-79
! 1-053 - Pick up the scale factor from the ISB.  DGP 15-Nov-79
! 1-054 - If 'CRLF' is detected to break a record and they are the last two
!	  characters in the record, then don't put out a following null record.
!	  DGP 03-Jan-80
! 1-055 - Set ISB$V_PRINT_INI in WL0 and clear it if WL1 is called.  DGP 04-Jan-80
! 1-056 - Unconditionally initialize LUB$V_OUTBUF_DR to 1 in WL1.  DGP 07-Jan-80
! 1-057 - All Calls to BAS$$DO_WRITE write an entire record.  DGP 14-Jan-80
! 1-058 - Bug fix to PRINT with semicolon formatting that exceeds the left
!	  margin.  DGP 22-Dec-80
! 1-059 - PRINTing a record to the terminal longer than the buffer size inserts
!	  an extra CRLF.  DGP 13-Feb-80
! 1-060 - The macro CHK_CURSOR_POS did not count LF as one character position.
!	  It does now.  DGP 18-Feb-80
! 1-061 - Correction to edit 1-060.  LF should never count as a character
!	  position.  DGP  19-Feb-80
! 1-062 - The macro CHK_CURSOR_POS gets in infinite loop when it is trying
!	  to decide at what point the margin was exceeded.  Correct this.
!	  DGP 27-FEB-80
! 1-063 - Edit 1-062 introduced another problem with the buffer pointer.
!	  Fix this.
! 1-064 - The case of exceeding the right margin for terminal output with the
!	  first element of a Print statement which follows a Print statement that
!	  ended in a semicolon or comma causes the element to be printed twice.
!	  Fixed. DGP 01-Mar-80
! 1-065 - Do not unconditionally reset LUB$V_FORM_CHAR in WL0.  This is a
!	  belated finish to edit 55 to fix a bug.  DGP 07-Mar-80.
! 1-066 - In SCAN_TEXT, when checking for CRLF and last character encountered
!	  in the buffer is a CR, don't look beyond the buffer for the LF. 
!	  REJ 05-May-80
! 1-067 - Put in the fix for checking last print zone properly.
!	  L_ELEM_SIZE is set to zero in MACRO CHK_PRINT_ZONE, and the value
!	  of BAS$K_COND_SUC in BASPAR.MAR is set to 2 in place of 3. FM 19-SEP-80
! 1-068 - Put in the fix for throwing out the next integer or floating number
!	  when the buffer is full.  FM 25-SEP-80
!
! 1-069 - The fix for 1-065A, did not quite fix the problem, so try again.
!	  FM JAN-81.
! 1-070 - Lines with tabs were not split properly if the line exceeded
!	  the margin.  Fix CHK_CURSOR_POS and SCAN_TEXT to count
!	  tab print positions properly, and SCAN_TEXT now updates
!	  the buffer pointer to keep pace with the print position.
!	  PL 30-Jun-81.
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES
!

REQUIRE 'RTLIN:OTSLNK';				! define all linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$$UDF_WL0 : JSB_UDF0 NOVALUE,		! initialization
    BAS$$UDF_WL1 : CALL_CCB NOVALUE,		! format one user I/O list element
    BAS$$UDF_WL9 : JSB_UDF9 NOVALUE,		! end of user I/O list - finish
    SCAN_TEXT : CALL_CCB,			! Scan text string for special characters
    BAS$$DO_WRITE : JSB_DO_WRITE NOVALUE;	! Output routine

BUILTIN
    CVTLD,					! Escape to MARS CVTLD instruction
    MOVTUC;					! Escape to MARS MOVTUC instruction

!
! INCLUDE FILES:
!

REQUIRE 'RTLML:BASPAR';				! Intermodule BASIC parameters and constants

REQUIRE 'RTLML:OTSISB';				! I/O statement block (ISB) offsets

REQUIRE 'RTLML:OTSLUB';				! Only needed to get LUB length!

REQUIRE 'RTLIN:OTSMAC';				! Macros

REQUIRE 'RTLIN:RTLPSECT';			! Define DECLARE_PSECTS macro

LIBRARY 'RTLSTARLE';				! STARLET library for macros and symbols

!
! EQUATED SYMBOLS:
!

LITERAL
    K_FIELD_SIZE = 14;				! print zone size

!
! MACROS:
!

MACRO

    !+
    ! If the format character is a comma, see if a full print zone remains
    ! in the record.  If a full print zone is not available, then return a
    ! zero; else return a one.
    ! Note: this macro is only executed if the conversion or scan routine
    ! returned a success status.
    !-

    CHK_PRINT_ZONE =
	    CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_PTR] + .DSC[DSC$W_LENGTH];
	    IF .FORMAT_CHAR EQL BAS$K_COMMA_FOR
	    THEN
		BEGIN
		CCB[LUB$A_BUF_PTR] = CH$FILL(' ',
		    (IF .CCB[LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR] GTRU K_FIELD_SIZE
			THEN K_FIELD_SIZE - (.CCB [LUB$L_PRINT_POS] MOD K_FIELD_SIZE)
 			ELSE .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR]),
		     .CCB[LUB$A_BUF_PTR]);
		CCB[LUB$L_PRINT_POS] = .CCB[LUB$L_PRINT_POS] + K_FIELD_SIZE - 
			(.CCB[LUB$L_PRINT_POS] MOD K_FIELD_SIZE);
		END;


	    !+
	    ! Check for a format character and that the right margin isn't
	    ! infinite.
	    !-

	    IF .FORMAT_CHAR EQL BAS$K_COMMA_FOR
	     OR .FORMAT_CHAR EQL BAS$K_SEMI_FORM
	    THEN
		BEGIN
		IF ((.CCB[LUB$L_PRINT_POS] LEQU .CCB[LUB$W_R_MARGIN]) OR .CCB [LUB$V_NOMARGIN])
		AND (.CCB[LUB$A_BUF_PTR] LEQU .CCB[LUB$A_BUF_END])
		THEN

		    !+
		    ! If this is a comma format, check to see if there is a full
		    ! print zone left on the line.  If this is a semi-colon, this
		    ! check is redundant, but the code is applicable so what's a
		    ! little redundancy?
		    ! If it does then return success.  If it doesn't, return failure
		    ! without resetting the pointers so that this item will be
		    ! written.
		    !-

		    BEGIN
		    L_ELEM_SIZE = 0;
		    IF ((.CCB [LUB$L_PRINT_POS] +
			(IF .FORMAT_CHAR EQL BAS$K_COMMA_FOR THEN K_FIELD_SIZE
			 				      ELSE 0)
		    LEQU .CCB [LUB$W_R_MARGIN]) OR .CCB [LUB$V_NOMARGIN])
		    THEN
			BAS$K_SUCCESS
		    ELSE
			BAS$K_COND_SUC
		    END

		ELSE

		    !+
		    ! The comma causes this field to overflow the right margin
		    ! Check to see if there is anything else in the buffer. If
		    ! there is, reset the pointers to before this element;  if
		    ! nothing else in the buffer, return a success status
		    ! Or, a semicolon format caused the field to overflow past
		    ! the buffer.  Save this one for the next record.
		    ! Check for the cursor position not being 0 prior to this
		    ! element 'cuz there could have been a series of statements
		    ! ending in comma or semi and if this is a terminal device,
		    ! then the data is PUT at each IO_END and the buffer doesn't
		    ! appear dirty although the print line is.
		    !-

		    IF .CCB[LUB$V_OUTBUF_DR] OR (.SAV_PRINT_POS NEQ 0)
		    THEN
			BEGIN
			DSC[DSC$W_LENGTH] = 0;
			CCB[LUB$A_BUF_PTR] = .A_SAV_PTR;
!+
! If the buffer was overflowed, then leave the cursor where it was; if the margin
! overflowed, then start a new record.
!-
			IF (NOT .CCB [LUB$V_NOMARGIN]) AND (.CCB [LUB$L_PRINT_POS] GTRU .CCB [LUB$W_R_MARGIN])
			THEN
			    BAS$K_MAR_EXC
			ELSE
			    BAS$K_BUF_EXC
			END
		    ELSE
			BEGIN
			CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_BEG] + .DSC[DSC$W_LENGTH];
			FORMAT_CHAR = BAS$K_SEMI_FORM;
			L_ELEM_SIZE = 0;
!+
! If the buffer was overflowed, then leave the cursor where it was; if the margin
! overflowed, then start a new record.
!-
			IF (NOT .CCB [LUB$V_NOMARGIN]) AND (.CCB [LUB$L_PRINT_POS] GTRU .CCB [LUB$W_R_MARGIN])
			THEN
			    BAS$K_MAR_EXC
			ELSE
			    BAS$K_BUF_EXC
			END
		END
	    ELSE
		1
%;						!end of macro

MACRO
    ! check the present cursor position against the desired print size.
    ! Due to the possibility of having carriage control characters in
    ! the output the data stream, the cursor position is used to check
    ! the end of the record rather the number of characters in the record.
    !-

    CHK_CURSOR_POS =
		IF (NOT .CCB [LUB$V_NOMARGIN]) AND (.CCB[LUB$L_PRINT_POS] GTR .CCB[LUB$W_R_MARGIN])
		THEN
		    !+
		    ! The cursor position has exceeded the print size.
		    ! Restore the pointers back to where they were before the
		    ! last MOVTUC. 
		    !-

		    BEGIN
		    RET_VAL = BAS$K_MAR_EXC;

		    !+
		    ! Reset a few pointers (use the fact that the data is al-
		    ! ready in the destination field) and find out the length
		    ! of the string which fits within the right margin.  This
		    ! requires looking at each character individually.
		    !-

		    CCB[LUB$L_PRINT_POS] = .L_SAV_PRINT_POS;
		    CCB[LUB$A_BUF_PTR] = .A_SAVE_BUF_PTR;
		    T_DSC[DSC$W_LENGTH] = .L_SAVE_LENGTH;
		    WHILE .CCB[LUB$L_PRINT_POS] LSS .CCB[LUB$W_R_MARGIN]
		    DO
			BEGIN
			CCB[LUB$L_PRINT_POS] = (SELECTONE .(.CCB[LUB$A_BUF_PTR])<0,8,0> OF
			    SET
			    [K_TAB]: (.CCB[LUB$L_PRINT_POS] OR K_TAB_LIT) + 1;
			    [K_CR]: 0;
			    [K_BKSP]: MAX(0, .CCB[LUB$L_PRINT_POS] - 1);
			    [K_BLANK TO K_TILDE]: .CCB[LUB$L_PRINT_POS] + 1;
			    [OTHERWISE]: .CCB[LUB$L_PRINT_POS] + 0;
			    TES);
			CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_PTR] + 1;
			T_DSC[DSC$W_LENGTH] = .T_DSC[DSC$W_LENGTH] + 1;
			END;		! While loop
!+
! Restore the buffer pointer so that it can be incremented properly by the
! code that does the common output stuff.
!-
		    CCB [LUB$A_BUF_PTR] = .A_SAVE_BUF_PTR;
		    EXITLOOP;
		    END;
%;

!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (BAS);				! declare PSECTs for BAS$ facility
!
! OWN STORAGE:
!
!	None
!
! EXTERNAL REFERENCES:
!
EXTERNAL
!+
! Array of REC9 routines
!-
    BAS$$AA_REC_PR9 : VECTOR;

EXTERNAL ROUTINE
!    The following are general library routines available for any
!    one's use (value is true if fits in field):
    BAS$CVT_OUT_D_G,				! Basic G (E or F) output conversion
    BAS$$REC_WSL0 : JSB_REC0 NOVALUE,		! initialize list directed output
    BAS$$REC_WSL1 : JSB_REC_WSL1 NOVALUE,	! write list directed
    BAS$$REC_WSL9 : JSB_REC9 NOVALUE,		! end list directed output
    BAS$$REC_MPR1 : JSB_REC1 NOVALUE;		! Mat Print REC level


GLOBAL ROUTINE BAS$$UDF_WL0 			! Write list directed UDF initialization
    : JSB_UDF0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize PRINT User data formatter (UDF)
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$V_AST_GUARD		Guard bit for AST reentrancy
!	LUB$A_BUF_PTR		Pointer to next byte in user buffer
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_AST_GUARD		Guard bit for AST reentrancy
!	LUB$A_BUF_BEG		Pointer to first byte of user buffer
!	LUB$A_BUF_PTR		Adr of next byte of output
!				data buffer
!	LUB$A_BUF_END		Adr of end of data buffer
!	ISB$V_PRINT_INI		indicates that a PRINT has been initialized
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! A guard bit is used to ensure AST reentrancy.  The bit is set to 1
    ! at the top of the routine, tested for 1 at the bottom of the routine,
    ! and set to 0 upon exitting.  If the test for 1 fails at the bottom of
    ! the routine, then an AST has gone off and used this routine possibly
    ! changing the buffer pointers. Therefore this routine will loop back and
    ! run itself again in its entirety.
    !-

    DO
	BEGIN

	!+
	! Set the guard bit
	!-

	CCB [LUB$V_AST_GUARD] = 1;

	!+
	! Call record level to get buffer pointers.
	!-

	BAS$$REC_WSL0 ();

	!+
	! set the beginning of the buffer if there is no format character pending
	!-

	IF NOT .CCB [LUB$V_FORM_CHAR] THEN CCB [LUB$A_BUF_BEG] = .CCB [LUB$A_BUF_PTR];

	!+
	! Set the print initialized bit.  The null print line (10	PRINT)
	! does not have an element transmitter (compiler optimization).  So,
	! the bit is set here and then can be cleared by element transmitters
	! if any.
	!-

	CCB [ISB$V_PRINT_INI] = 1;

	!+
	! Check the guard bit.  If it is now 0, then an AST has gone thru this routine
	! Since the data base may have been altered in an unpredictable manner, it
	! is necessary to redo the entire routine.  Note: in worst case processing,
	! the run-time for this routine is essentially unbounded.
	!-

	END
    UNTIL .CCB [LUB$V_AST_GUARD];		! End of AST guard loop

    CCB [LUB$V_AST_GUARD] = 0;
    END;


GLOBAL ROUTINE BAS$$UDF_WL1 (ELEM_TYPE, ELEM_SIZE, ELEM_ADR, FORMAT_CHAR	! format character
    ) : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write list-directed User Data Formatter.
!	Accept an I/O element, format it, and put it in the record buffer.
!	Calls record level processors to perform the actual I/O if the buffer
!	is full or if non-forcible and end-of-record (no format character).
!
! FORMAL PARAMETERS:
!
!	ELEM_TYPE.rlu.v		data type of the element
!	ELEM_SIZE.rlu.v		size of the data element
!	ELEM_ADR.rlu.r		adr of the data element to be written
!				Points to a descriptor for strings
!	FORMAT_CHAR.rlu.v		type of format character which followed the data element
!
! IMPLICIT INPUTS:
!
!	LUB$V_AST_GUARD		guard bit for AST reentrancy
!	LUB$L_PRINT_POS		current cursor position
!	LUB$V_OUTBUF_DR		indicates valid data in the output buffer.
!	LUB$W_R_MARGIN		size of buffer specified in OPEN statement.
!	LUB$V_FORM_CHAR		flag that a format character (',' or ';') was
!				seen on the last element.
!	LUB$A_BUF_BEG		pointer to beginning of user buffer
!	LUB$A_BUF_PTR		pointer to current position in the buffer.
!	LUB$A_BUF_END		pointer to last byte of buffer + 1.
!
! IMPLICIT OUTPUTS:
!
!	ISB$V_PRINT_INI		reset print intialize flag - there is at least one
!				element transmitter
!	LUB$V_AST_GUARD		guard bit for AST reentrancy
!	LUB$V_OUTBUF_DR		indicates valid data in output buffer
!	LUB$V_FORM_CHAR		flag to indicate a format character was seen
!	LUB$L_PRINT_POS		internal cursor position.
!	LUB$A_BUF_PTR		next byte in the user buffer
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	If an AST goes off while we are in this routine and calls this routine,
!	then this routine will be repeated.  It will continue to be repeated
!	until there are no more ASTs using this routine.
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	ELEM_ADR : REF VECTOR;			! element is call-by-reference

    LOCAL
	STR_PTR,				! pointer into string being printed
	L_ELEM_SIZE,				! temp for ELEM_SIZE for strings
						! in case a string is longer than the buffer
	A_SAV_PTR,				! temp for saving LUB$A_BUF_PTR
	P,					! temporary character string pointer
	DIFF,					! number of bytes left in record buffer
	DSC : BLOCK [8, BYTE];			! static string descriptor for output field

    LITERAL
	K_FIELD_SIZE = 14,			! Maximum size to be used by output conversion routine
	K_TEMP_BUF_SIZ = 14;

    !+
    ! This loop is to ensure AST reentrancy.
    !-

    DO
	BEGIN
	CCB [LUB$V_AST_GUARD] = 1;
	STR_PTR = 0;
!+
! Reset the print initialize flag; there is at least one element transmitter.
!-
	CCB [ISB$V_PRINT_INI] = 0;
	L_ELEM_SIZE = .ELEM_SIZE;

	!+
	!  convert or move the field directly into the output buffer with
	! the exception of the numerics using G format.
	!-

	DSC [DSC$B_DTYPE] = 0;
	DSC [DSC$B_CLASS] = 0;
	DSC [DSC$W_LENGTH] = 0;

	!+
	! save the current pointer in the buffer
	! Only needed the first time thru the loop
	!-

	A_SAV_PTR = .CCB [LUB$A_BUF_PTR];

	!+
	! determine the length of each field taking into account the format character.
	! In addition to the length, condition the bit which indicates the
	! presence or absence of a format character.
	!-

	CASE .FORMAT_CHAR FROM BAS$K_SEMI_FORM TO BAS$K_NO_FORM OF
	    SET

	    [BAS$K_SEMI_FORM] :
		CCB [LUB$V_FORM_CHAR] = 1;

	    [BAS$K_COMMA_FOR] :
		CCB [LUB$V_FORM_CHAR] = 1;

	    [BAS$K_NO_FORM] :
		CCB [LUB$V_FORM_CHAR] = 0;
	    TES;

	!+
	! This WHILE loop will repeat as often as necessary to put out the entire
	! field.  If a field will not fit into the buffer currently it is
	! important to note whether there is anything in the buffer to begin with.
	! If there is then the buffer pointer is set to the value it had when
	! this routine was entered.  Then the buffer is dumped.  If there is nothing
	! in the buffer, then the assumption is that this is a string that is too
	! long to fit into the buffer and must be written in sections.  The string
	! is left in the buffer and the buffer is dumped.  The loop is then repeated
	! until the whole string has been dumped.  The key to control is the flag
	! LUB$OUTBUF_DR.
	!-

	WHILE 1 DO
	    BEGIN

	    LOCAL
		WRITE_STATUS,			! status returned from the conversion routines
		SAV_PRINT_POS;			! Temporary to save the current cursor position

	    SAV_PRINT_POS = .CCB [LUB$L_PRINT_POS];
	    DSC [DSC$A_POINTER] = .CCB [LUB$A_BUF_PTR];

	    !+
	    ! Perform the appropriate conversions.
	    !-

	    IF NOT (WRITE_STATUS = (CASE .ELEM_TYPE FROM DSC$K_DTYPE_WU TO DSC$K_DTYPE_T OF
		    SET
!		    [DSC$K_DTYPE_WU, DSC$K_DTYPE_LU] : FOR$CNV_OUT_L (.(.ELEM_ADR)<0, .ELEM_SIZE*%BPUNIT, 0>,
!			DSC);
!		    [DSC$K_DTYPE_B] : FOR$CNV_OUT_I (.(.ELEM_ADR)<0, .ELEM_SIZE*%BPUNIT, 1>, DSC);
		    [DSC$K_DTYPE_W, DSC$K_DTYPE_L] :

			!+
			! Type integer - word or longword.  Print out as integer
			! Always print as F format.
			!-

			BEGIN

			LITERAL
			    K_NUM_DIGITS = 10;
			LOCAL
			    RET_LENGTH,		! length returned by conversion routine
			    D_VALUE : VECTOR [2];	! holds double precision floating value

			DSC [DSC$W_LENGTH] = (IF .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR] GTRU
			    K_FIELD_SIZE

			    !+
			    ! Convert the integer value to a double precision value in
			    ! preparation for calling BAS$CVT_OUT_D_G
			    !-

			THEN K_FIELD_SIZE ELSE .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR]);
			CVTLD (ELEM_ADR [0], D_VALUE [0]);

			IF BAS$CVT_OUT_D_G (D_VALUE, 0, RET_LENGTH, DSC, 0, K_NUM_DIGITS)
			THEN
			    BEGIN
			    L_ELEM_SIZE = 0;
			    DSC [DSC$W_LENGTH] = .RET_LENGTH;
			    CCB [LUB$L_PRINT_POS] = .CCB [LUB$L_PRINT_POS] + .DSC [DSC$W_LENGTH];
			    CHK_PRINT_ZONE
			    END
			ELSE
			    BAS$K_BUF_EXC

			END;
		    [DSC$K_DTYPE_F, DSC$K_DTYPE_D] :
			BEGIN

			LOCAL
			    RET_LENGTH,		! hold the length returned by conversion routine
			    D_VALUE : VECTOR [2];	! holds double precision floating value

			DSC [DSC$W_LENGTH] = (IF .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR] GTRU
			    K_FIELD_SIZE THEN K_FIELD_SIZE ELSE .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR]);
			D_VALUE [0] = .ELEM_ADR [0];
			D_VALUE [1] = (IF .ELEM_SIZE EQL %UPVAL THEN 0 ELSE .ELEM_ADR [1]);

			IF BAS$CVT_OUT_D_G (D_VALUE, 0, RET_LENGTH, DSC,
			    (IF .ELEM_SIZE EQL %UPVAL THEN 0 ELSE .CCB [ISB$B_SCALE_FAC]))
			THEN
			    BEGIN
			    L_ELEM_SIZE = 0;
			    DSC [DSC$W_LENGTH] = .RET_LENGTH;
			    CCB [LUB$L_PRINT_POS] = .CCB [LUB$L_PRINT_POS] + .DSC [DSC$W_LENGTH];
			    CHK_PRINT_ZONE
			    END
			ELSE
			    BAS$K_BUF_EXC

			END;
		    [DSC$K_DTYPE_T] :

			!+
			! text
			!-

			BEGIN
			LOCAL
			    SCAN_STATUS;		! status returned by SCAN_TEXT

			IF SCAN_STATUS = SCAN_TEXT ((.(.ELEM_ADR + 4) + .STR_PTR), .L_ELEM_SIZE,
				.CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR], DSC) THEN

			!+
			! The field fits into the buffer, now adjust for a
			! comma format character and see if the field still
			! fits.
			! \ Will this overflow the buffer and stay within the
			! right margin?\
			!-

			    BEGIN
			    CHK_PRINT_ZONE
			    END
			ELSE
			    BEGIN

			    !+
			    ! If LUB$V_OUTBUF_DR is true then there is other data
			    ! in the buffer.
			    ! If SCAN_STATUS is not BAS$K_CRLF (CRLF detected in record)
			    ! The buffer pointer should be reset
			    ! and the other data should be dumped.  If the bit is
			    ! false, then this is a big string which won't all
			    ! fit in the buffer at once.  Dump what is there and
			    ! come back for more.
			    ! If SCAN_STATUS is BAS$K_CRLF then a CRLF is in the
			    ! string and it will fit with the other data here.
			    ! Pretend it is all one big string.
			    !-

			    IF .CCB [LUB$V_OUTBUF_DR] AND (.SCAN_STATUS NEQ BAS$K_CRLF)
			    THEN
				BEGIN

				!+
				! Set the length back to zero so that the entire
				! field will be scanned again
				!-

				DSC [DSC$W_LENGTH] = 0;
				CCB [LUB$A_BUF_PTR] = .A_SAV_PTR;
				END
			    ELSE

			    !+
			    ! Decrement the length of this string which is
			    ! longer than one record for the next iteration
			    !-

				BEGIN
				STR_PTR = .STR_PTR + .DSC [DSC$W_LENGTH];
				L_ELEM_SIZE = .L_ELEM_SIZE - .DSC [DSC$W_LENGTH];
				CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_PTR] + .DSC [DSC$W_LENGTH]
				    - (IF .SCAN_STATUS EQL BAS$K_CRLF THEN 2 ELSE 0);
				END;

			    .SCAN_STATUS
			    END
			END;
		    [INRANGE, OUTRANGE] : 0	! this can not happen
		    TES))
	    THEN

	    !+
	    ! This element won't fit in its entirety.  PUT the contents of the buffer
	    ! and then loop back and write the remainder.
	    !-

		BEGIN
		BAS$$DO_WRITE (.WRITE_STATUS);

		IF (.WRITE_STATUS EQL BAS$K_COND_SUC OR .WRITE_STATUS EQL BAS$K_CRLF)
		    AND .L_ELEM_SIZE EQL 0
		THEN

		    BEGIN
!+
! This field fit but there was not a full print zone left; the
! format character was a comma.  We want to write this record
! and then start the next element on the next line at the
! left margin.
! Or, a CRLF was found and they are the last two characters in
! the record and we don't want to put out a null record after this
! record.  So, bail out here.
! Turn off the format character flag.  This avoids the situation where this is the
! last element in this I/O list and ends with a semicolon or comma.  Even though
! 'pre' carriage control has been set to 'LF', IO_BEG for the next I/O list will
! set it to null if the format character flag is on.
!-
		    CCB [LUB$V_FORM_CHAR] = 0;
		    EXITLOOP;
		    END;
		END
	    ELSE
		BEGIN
!+
! everything fit this time.  Set the buffer dirty pointer.
!-
		CCB [LUB$V_OUTBUF_DR] = 1;
		EXITLOOP;
		END;

	    END;				! WHILE loop

!+
! Check for MAT PRINT.  If the format character flag is not set, then this
! matrix is being printed one element/line.  Therefore it is necessary to get to
! the REC level and do a PUT.
!-
	IF (.CCB [ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_MPR) AND NOT .CCB[LUB$V_FORM_CHAR]
	THEN
	    BEGIN
	    BAS$$REC_MPR1();
	    CCB [LUB$L_PRINT_POS] = 0;
	    END;
	END
    UNTIL .CCB [LUB$V_AST_GUARD];		! End of AST guard loop

    CCB [LUB$V_AST_GUARD] = 0;
    RETURN;
    END;					! End of BAS$$UDF_WL1


GLOBAL ROUTINE BAS$$UDF_WL9 : JSB_UDF9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Call the record level I/O end of list routine.  Reset the cursor position
!	if a PUT was done
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$V_AST_GUARD		Guard for AST reentrancy
!	LUB$V_FORM_CHAR		last element transmitter ended with a format char
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_AST_GUARD		guard for AST reentrancy
!	LUB$L_PRINT_POS		current cursor position
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine will loop back and reexecute if it detects that it was
!	called by an AST while it was executing.
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! This outer loop is to detect an AST calling this routine while it is
    ! executing.
    !-

    DO
	BEGIN
	CCB [LUB$V_AST_GUARD] = 1;		! Initialize the guard bit
!+
! Clear the bit which indicates an array list for MAT PRINT.
!-
	CCB [ISB$V_MAT_PRINT] = 0;
!+
! Dispatch to the REC level.
!-
	JSB_REC9(BAS$$AA_REC_PR9 + .BAS$$AA_REC_PR9 [.CCB [ISB$B_STTM_TYPE] - ISB$K_BASSTTYLO + 1]);
	! Time to reset the cursor position to zero perhaps

	IF NOT .CCB [LUB$V_FORM_CHAR] THEN CCB [LUB$L_PRINT_POS] = 0;

	END
    UNTIL .CCB [LUB$V_AST_GUARD];		! End of AST guard loop

    CCB [LUB$V_AST_GUARD] = 0;
    END;


ROUTINE SCAN_TEXT (POS, 			! adr of beginning position of source string
	LENGTH, 				! length of the source string
	BUF_LENGTH, 				! length of the buffer remaining
	RET_STR					! adr of where to put the string
    ) : CALL_CCB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine puts a string of ASCII characters into the indicated buffer.
!	All non-printing characters, backspace, K_TAB, and carriage return
!	are identified in the string and their effect is reflected in the
!	internal cursor position.
!
! FORMAL PARAMETERS:
!
!	POS.rlu.r		position of the start of the string to output
!	LENGTH.rlu.v		length of the string to write
!	BUF_LENGTH.rlu.v	length remaining of the output buffer
!	RET_STR.wt.dx		pointer to descriptor for the destination
!
! IMPLICIT INPUTS:
!
!	LUB$L_PRINT_POS		current cursor position
!	LUB$W_R_MARGIN		maximum allowable cursor position
!	LUB$A_BUF_PTR		current position in the buffer
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_PRINT_POS		current cursor position
!
! ROUTINE VALUE:
!
!	BAS$K_MAR_EXC		right margin exceeded
!	BAS$K_CRLF		embedded CRLF in the record
!	BAS$K_SUCCESS		successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	POS : REF VECTOR [, BYTE],
	RET_STR : REF BLOCK [8, BYTE];

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LITERAL
	K_STOP = %X'00',			! stop or escape character for MOVTUC
	K_TILDE = %X'7E',			! tilde character
	K_LF = %X'0A',				! line feed character
	K_BKSP = %X'08',			! backspace character
	K_TAB = %X'09',				! tab character
	K_CR = %X'0D',				! carriage return character
	K_BLANK = %X'20',			! blank character
	K_TAB_LIT = %X'07';

    BIND
	ESC = UPLIT BYTE(K_STOP),

	!+
	! This translation table is used for a MOVTUC instruction.  It trans-
	! lates all normal 7 bit alphanumerics into themselves and stops on
	! characters which affect the cursor position (backspace, tab, and CR).
	!-

	TRANS_TABLE = UPLIT BYTE(%X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X
	    '00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', 	! column 0
	    %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00',
	    %X'00', %X'00', %X'00', %X'00', 	! column 1
	    %X'20', %X'21', %X'22', %X'23', %X'24', %X'25', %X'26', %X'27', %X'28', %X'29', %X'2A', %X'2B',
	    %X'2C', %X'2D', %X'2E', %X'2F', 	! column 2
	    %X'30', %X'31', %X'32', %X'33', %X'34', %X'35', %X'36', %X'37', %X'38', %X'39', %X'3A', %X'3B',
	    %X'3C', %X'3D', %X'3E', %X'3F', 	! column 3
	    %X'40', %X'41', %X'42', %X'43', %X'44', %X'45', %X'46', %X'47', %X'48', %X'49', %X'4A', %X'4B',
	    %X'4C', %X'4D', %X'4E', %X'4F', 	! column 4
	    %X'50', %X'51', %X'52', %X'53', %X'54', %X'55', %X'56', %X'57', %X'58', %X'59', %X'5A', %X'5B',
	    %X'5C', %X'5D', %X'5E', %X'5F', 	! column 5
	    %X'60', %X'61', %X'62', %X'63', %X'64', %X'65', %X'66', %X'67', %X'68', %X'69', %X'6A', %X'6B',
	    %X'6C', %X'6D', %X'6E', %X'6F', 	! column 6
	    %X'70', %X'71', %X'72', %X'73', %X'74', %X'75', %X'76', %X'77', %X'78', %X'79', %X'7A', %X'7B',
	    %X'7C', %X'7D', %X'7E', %X'00', 	! column 7
	    %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00',
	    %X'00', %X'00', %X'00', %X'00', 	! column 8
	    %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00', %X'00',
	    %X'00', %X'00', %X'00', %X'00', 	! column 9
	    %x'A0', %X'A1', %X'A2', %X'A3', %X'A4', %X'A5', %X'A6', %X'A7', %X'A8', %X'A9', %X'AA', %X'AB',
	    %X'AC', %X'AD', %X'AE', %X'AF',	! column 10
	    %X'B0', %X'B1', %X'B2', %X'B3', %X'B4', %X'B5', %X'B6', %X'B7', %X'B8', %X'B9', %X'BA', %X'BB',
	    %X'BC', %X'BD', %X'BE', %X'BF',	! column 11
	    %X'C0', %X'C1', %X'C2', %X'C3', %X'C4', %X'C5', %X'C6', %X'C7', %X'C8', %X'C9', %X'CA', %X'CB',
	    %X'CC', %X'CD', %X'CE', %X'CF',	! column 12
	    %X'D0', %X'D1', %X'D2', %X'D3', %X'D4', %X'D5', %X'D6', %X'D7', %X'D8', %X'D9', %X'DA', %X'DB',
	    %X'DC', %X'DD', %X'DE', %X'DF',	! column 13
	    %X'E0', %X'E1', %X'E2', %X'E3', %X'E4', %X'E5', %X'E6', %X'E7', %X'E8', %X'E9', %X'EA', %X'EB',
	    %X'EC', %X'ED', %X'EE', %X'EF',	! column 14
	    %X'F0', %X'F1', %X'F2', %X'F3', %X'F4', %X'F5', %X'F6', %X'F7', %X'F8', %X'F9', %X'FA', %X'FB',
	    %X'FC', %X'FD', %X'FE', %X'00')	! column 15
	: VECTOR [256, BYTE];

    LOCAL
	L_SAVE_LENGTH,				! save length of string scanned so far
	DEST_LENGTH,				! length of destination buffer
	SRC_LENGTH,				! length of source string
	A_SAVE_BUF_PTR,				! temp to save LUB$A_BUF_PTR
	T_DSC : BLOCK [8, BYTE],		! working desc to hold the fourth argument
	END_POS,				! no. of characters in source string + current
						! address in the buffer
	L_SAV_PRINT_POS,			! temp to save the cursor position
						! in case the right margin is exceeded
	T_POS,					! local to hold readonly arg. POS
	RET_VAL,				! the status value returned to the caller.
	MOV_VAL,				! receives the returned status from MOVTUC
	T_BUF_PTR,				! temp buffer ptr, to agree with print pos
	ORIG_BUF_PTR;				! another buf ptr, unmodified so
						! LUB$A_BUF_PTR can be restored

    !+
    ! Save off a number of pointers.  We will not overflow the buffer because
    ! the MOVTUC which is used to load the buffer has a destination length operand,
    ! however it is possible to exceed the right margin if there are one or more
    ! TAB characters.  If the margin is exceeded, it is detected in the macro
    ! CHK_CURSOR_POS, then the string is backed up and each character is moved
    ! until the right margin is reached.  Normally, if an element does not fit
    ! into the buffer, the buffer is dumped without it.  However, there is the
    ! case where a string is longer than the buffer and must be put out in seg-
    ! ments.  That is not to be decided in this routine.
    !-

    DEST_LENGTH = .BUF_LENGTH;
    SRC_LENGTH = .LENGTH;
    T_POS = .POS;
    T_BUF_PTR = .CCB [LUB$A_BUF_PTR];
    ORIG_BUF_PTR = .CCB [LUB$A_BUF_PTR];
    T_DSC [DSC$W_LENGTH] = 0;
    T_DSC [DSC$A_POINTER] = .RET_STR [DSC$A_POINTER];
    END_POS = MINU (.SRC_LENGTH, .DEST_LENGTH) + .T_POS;
    MOV_VAL = 1;

    !+
    ! This loop will find all of the cursor position affecting characters in
    ! the string.
    !-

    WHILE .MOV_VAL NEQU 0 DO
	BEGIN
	RET_VAL = (IF .DEST_LENGTH GEQ .SRC_LENGTH THEN BAS$K_SUCCESS ELSE BAS$K_BUF_EXC);
	A_SAVE_BUF_PTR = .T_BUF_PTR;
	L_SAV_PRINT_POS = .CCB [LUB$L_PRINT_POS];
	L_SAVE_LENGTH = .T_DSC [DSC$W_LENGTH];
	MOV_VAL = MOVTUC (SRC_LENGTH, .T_POS, ESC, TRANS_TABLE, DEST_LENGTH, .T_DSC [DSC$A_POINTER]);

	!+
	! Set RET_VAL to either 1 (success) or 0 (failure) based on whether
	! there was enough room in the buffer for the entire translated
	! string.  A value of 1 at this point may be changed in the macro
	! CHK_CURSOR_POS.
	!-

	IF .MOV_VAL EQLU 0
	THEN

	!+
	! MOVTUC was able to move the entire source string without encountering
	! an 'escape' character.  Update the cursor position and check to
	! see if it exceeds the right margin.
	!-

	    BEGIN
	    !
	    ! SWITCHES LIST (EXPAND);
	    !
	    T_DSC [DSC$W_LENGTH] = .T_DSC [DSC$W_LENGTH] + (.END_POS - .T_POS);
	    CCB [LUB$L_PRINT_POS] = .CCB [LUB$L_PRINT_POS] + (.END_POS - .T_POS);
	    T_BUF_PTR = .T_BUF_PTR + .SRC_LENGTH;
	    CHK_CURSOR_POS;
	    END
	ELSE
	    BEGIN

	    !+
	    ! an 'escape' character was detected in the source string.
	    ! increment the cursor position for the substring moved plus one
	    ! for the offending character.  the buffer pointer must be moved
	    ! to keep up with the cursor position.
	    !-

	    CCB [LUB$L_PRINT_POS] = .CCB [LUB$L_PRINT_POS] + (.MOV_VAL - .T_POS);
	    T_BUF_PTR = .T_BUF_PTR + (.MOV_VAL - .T_POS) + 1;
	    T_DSC [DSC$W_LENGTH] = .T_DSC [DSC$W_LENGTH] + (.MOV_VAL - .T_POS) + 1;

!+
! Check for an occurrence of a CRLF which will delimit the record and insure that
! the LF is included in the buffer.
!-
!+
! We should do a LSSU instead of LEQU, to fix 1-065D.
!-
	    IF .(.MOV_VAL)<0, 8> EQL K_CR 
		AND .(MOV_VAL) + 1 LSSU .POS + .LENGTH
		AND .(.(MOV_VAL) + 1)<0, 8> EQL K_LF
	    THEN
		BEGIN
!+
! There is a CRLF in this record.  Set the length properly to include the CRLF
! and return the fact that a delimiting CRLF was found.
!-
		T_DSC [DSC$W_LENGTH] = .T_DSC [DSC$W_LENGTH] + 1;
		CHK_CURSOR_POS;
		RET_VAL = BAS$K_CRLF;
		EXITLOOP;
		END

	    !+
	    ! Adjust the cursor position for the 'escape' character if the
	    ! 'escape' character was not CR followed by LF.  We don't want
	    ! to reset PRINT_POS for CRLF because it is a complete record
	    ! and must be evaluated as such for both comma zone formatting and
	    ! exceeding the right margin.
	    !-

	    ELSE
		CCB [LUB$L_PRINT_POS] = (SELECTONE .(.MOV_VAL)<0, 8, 0> OF
		    SET
		    [K_TAB] : ((.CCB [LUB$L_PRINT_POS] OR K_TAB_LIT) + 1);
		    [K_CR] : 0;
		    [K_BKSP] : MAX (0, .CCB [LUB$L_PRINT_POS] - 1);
		    [OTHERWISE] : .CCB [LUB$L_PRINT_POS];
		    TES);
	    SRC_LENGTH = .SRC_LENGTH - (.MOV_VAL - .T_POS) - 1;
	    T_DSC [DSC$A_POINTER] = .T_DSC [DSC$A_POINTER] + (.MOV_VAL - .T_POS);
	    DEST_LENGTH = .DEST_LENGTH - (.MOV_VAL - .T_POS) - 1;
	    T_POS = .MOV_VAL + 1;

	    !+
	    ! move the offending character by hand
	    !-

	    T_DSC [DSC$A_POINTER] = CH$MOVE (1, CH$PTR (.MOV_VAL), CH$PTR (.T_DSC [DSC$A_POINTER]));
	    CHK_CURSOR_POS;
	    END;

	END;					! WHILE loop

    !+
    ! Set the length of the string which was transferred into the indicated
    ! destination.  Restore original buffer pointer so that BAS$UDF_WL1 can
    ! update it properly.
    !-

    CCB [LUB$A_BUF_PTR] = .ORIG_BUF_PTR;
    RET_STR [DSC$W_LENGTH] = .T_DSC [DSC$W_LENGTH];
    RETURN .RET_VAL;
    END;					! End of SCAN_TEXT


GLOBAL ROUTINE BAS$$DO_WRITE(		! Write one record with indicated carriage control
    CARRIAGE_CTRL
 	) : JSB_DO_WRITE NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine centralizes calls to the record level write routine.  A
!	few vlues in the data base are reset.
!
! FORMAL PARAMETERS:
!
!	CARRIAGE_CTRL.rlu.v	indicates whether to insert CRLF or leave the cursor
!
! IMPLICIT INPUTS:
!
!	CCB			address of current control block
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_OUTBUF_DR		indicates valid data in the output buffer
!	LUB$L_PRINT_POS		current cursor position
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    BAS$$REC_WSL1 (.CARRIAGE_CTRL);

    !+
    ! Reset the output buffer dirty bit
    !-
!+
! Reset the cursor position only if a record was written.  Otherwise, the
! cursor was left at the end of the data written and the cursor position
! is still valid
!-

    IF .CCB [LUB$A_BUF_PTR] EQL .CCB [LUB$A_BUF_BEG] THEN CCB [LUB$L_PRINT_POS] = 0;
    CCB [LUB$V_OUTBUF_DR] = 0;
    RETURN;
    END;

END

ELUDOM
