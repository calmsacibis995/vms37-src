MODULE FOR$$UDF_WF (				! FORTRAN Write Formatted UDF
		IDENT = '2-057'			! File: FORUDFWF.B32  Edit: JAW2057
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  FORTRAN Support Library - not user callable
!
! ABSTRACT:
!
!	This module implements FORTRAN Write Formatted I/O
!	statements (sequential access - S, direct access - D,
!	ENCODE - M) at the User data Formatter level of
!	abstraction (UDF level is 2nd level). This module
!	calls the Read/Write independent format
!	interpreter (FOR$$FMT_INTRPx) to decode the compiled format
!	statement. This module calls the appropriate write record
!	routine at the record handling level of abstraction (REC
!	level is 3rd level) to write a record.
!
! ENVIRONMENT:  User access mode; reentrant AST level or not.
!
! AUTHOR:  Thomas N. Hastings;	 CREATION DATE: 20-Feb-77
!
! MODIFIED BY:
!	Thomas N. Hastings, 12-Mar-77: Version 01
! 01	-  original
! 06	- internal F4P review - reduced use of CH$ by introducing MAXP, LSSP macros,
!	reduced size of SELECT, added debuging macros, and MAP ELEM_ADR: REF VECTOR.
! 16	- use SRMDEF for string descriptor symbols
! 17	- use SRMDEF symbols for FORTRAN data types
! 18	- make local variable dsc a byte array. SHA
!
!	Richard Grove, 19-Aug-77: Version 2
! 2-01	- Change logic from SELECT to CASE with an attributes table.
! 2-04	- SIGNAL_STOP FOR$_OUTSTAOVE) on tab - TNH
! 2-05	- Removed parameters to record level routines JMT 17-OCT-77
! 2-06	- Changed RECTOOBIG to OUTSTAOVE
!	  Check if file is direct access and signal on EOF, SLS.  JMT 22-Oct-77
! 2-07	- Use FOR$K_abcmnoxyz as EXTERNAL LITERALs.  TNH 27-Oct-77
! 2-08	- Fixed Fw.d from string variable.  TNH 29-Oct-77
! 2-09	- Use FERR.  TNH 16-Dec-77
! 2-10	- Store error in ISB$B_ERR_NO, don't signal!  JMT 14-Jan-78
! 2-11	- Bug fix for real number and integer format; now, just
!	  fetch as if a longword.  Avoids 64-bit extract.  JMT 16-Jan-78
! 2-12	- Global register CCB.  JMT 8-Apr-78
! 2-13	- Change to STARLET library.  DGP 20-Apr-78
! 2-14	- Change REQUIRE files for VAX system build.  DGP 28-Apr-78
! 2-15	- Change STARLET to RTLSTARLE to avoid conflicts.  DGP 1-May-78
! 2-16	- Use JSB linkages.  TNH 22-May-78
! 2-17	- Call DO_WRITE, if at EOF.  TNH 31-May-78
! 2-20	- Only test 7-bit format code.  TNH 6-June-78
! 2-21	- PIC dispatch tables.  TNH 6-June-78
! 2-22	- Use ADR_VECTOR macro for PIC dispatch table.  TNH 7-June-78
! 2-24	- Fix look ahead if no I/O elements.  TNH 16-Aug-78
! 2-26	- Change file name to FORUDFWF.B32, and change the names of
!	   the REQUIRE files similarly.  JBS 14-NOV-78
! 2-027	- Update the copyright notice.  JBS 16-NOV-78
! 2-028	- Change REQUIRE file names from FOR... to OTS...  JBS 06-DEC-78
! 2-029 - Change references to I/O dispatch tables.  DGP 08-Dec-78
! 2-030 - Change dispatch table references to longwords.  DGP 11-Dec-78
! 2-031 - Change ISB$A_BUF_PTR, BUF_BEG, BUF_HIGH, BUF_END to LUB. DGP 08-Jan-79
! 2-032	- Use 32-bit addresses for externals.  JBS 27-JAN-1979
! 2-033	- Make the PIC tables longwords so they can support 32-bit
!	   addresses as longwords.  JBS 28-JAN-1979
! 2-034 - Add support for G and H (partial) floating, plus FORTRAN-77
!	  new format codes.  SBL 6-Mar-79
! 2-035 - Change updating of BUF_HIGH and blank filling to CHECK_W.
!	  This allows tabs past end of buffer as long as no data
!	  is transmitted from there, as per FORTRAN-77.  SBL 21-Mar-79
! 2-036 - Continue executing non-data-list format items after first
!	  data-list format item is seen.  This clears up the VFE
!	  problem reported in SPR 21588.  SBL 11-Apr-79
! 2-037 - Allow direct access to write more than one record.  SBL 25-Apr-1979
! 2-038 - Always blank fill from BUF_HIGH, not BUF_PTR.  SBL 6-Jun-1979
! 2-039 - Put in call to H conversion routines.  SBL 11-Jun-1979
! 2-040	- Use language-specific dispatch tables.  JBS 26-JUN-1979
! 2-041 - Change OTS$ floating conversion routines to FOR$.  SBL 5-Jul-1979
! 2-042 - Use ISB dispatch offset symbols.  SBL 12-July-1979
! 2-043 - On floating conversion of non-reals, use D floating conversion.
!	  SBL 29-Aug-1979
! 2-044 - Use optimizing lookahead to see if next format item is a
!	  data-transferring one instead of always calling the format
!	  interpreter.  SBL 19-Nov-1979
! 2-045 - FORMAT_ADR is no longer passed to UDF_WF0.  Don't copy D_VALUE
!	  except for F_floating.  SBL 5-Dec-1979
! 2-046 - Speed optimizations.  Call separate functions which contain
!	  MOVC3, MOVC5.  Remove T, TR, TL which are now done by the
!	  format interpreter.  SBL 13-Dec-1979
! 2-047 - Use non-character moves for A formats from 0-8 bytes.  SBL 18-Dec-1979
! 2-048 - Code improvements.  Fix bug where blank filling might be done
!	  past end of buffer.  SBL 4-Jan-1980
! 2-049 - Instead of checking for a zero ELEM_SIZE to determine an
!	  end-of-list call from FOR$$UDF_WF9 use a zero ELEM_TYPE.
!	  This allows a zero-length string to be formatted properly.
!	  SPR 11-30127  SBL 22-May-1980
! 2-050 - Convert FOR$$FMT_INTRP1 to JSB linkage.  29-Jul-1981  JAW
! 2-051 - Use non-character moves when possible to fill buffer to high-
!	  water mark, avoiding a call to BLANK_FILL.  JAW 29-Jul-1981
! 2-052 - Correct error in edit 2-051.  JAW 05-Aug-1981
! 2-053 - Combine handling of Hollerith and alphanumeric, to get the
!	  benefit of non-character moves for Hollerith, and recast CASE
!	  for slightly better code.  JAW 05-Aug-1981
! 2-054 - Add require file FORMSG.B32 in preparation for enhanced error
!	  reporting.  JAW 10-Aug-1981
! 2-055 - Check for zero-length buffer before changing the carriage
!	  control character in DO_WRITE.  JAW 10-Aug-1981
! 2-056 - Set ISB$V_ERR_OFLO for format codes XE and XG.  SPR 11-38351.
!	  JAW 13-Aug-1981
! 2-057 - Ignore $ if carriage control is not FTN.  JAW 28-Aug-1981
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE) ,
    ZIP;					! Optimize for speed

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';				! define all linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    FOR$$UDF_WF0 : JSB_UDF0 NOVALUE,		! initialization
    FOR$$UDF_WF1 : CALL_CCB NOVALUE,		! format one user I/O list element
    FOR$$UDF_WF9 : JSB_UDF9 NOVALUE,		! end of user I/O list - finish
    BLANK_FILL,					! fill string with blanks
    MOVE_CHAR : NOVALUE,			! move characters
    DO_WRITE : JSB_DO_WRITE NOVALUE;		! do per-record formatting and write

!
! INCLUDE FILES:
!

LIBRARY 'RTLSTARLE';				! STARLET library for macros and symbols

REQUIRE 'RTLML:FORERR';				! FORTRAN error number definitions

REQUIRE 'RTLML:FORMSG';				! Fortran 32-bit error codes

REQUIRE 'RTLIN:FORFMT';				! Format statement codes

REQUIRE 'RTLML:OTSISB';				! I/O statement block (ISB) offsets

REQUIRE 'RTLML:OTSLUB';				! Only needed to get LUB length!

REQUIRE 'RTLIN:OTSMAC';				! Macros

REQUIRE 'RTLIN:RTLPSECT';			! Define DECLARE_PSECT macro

REQUIRE 'RTLIN:RTLODBG';			! RTL debugging macros

!
! MACROS:
!

MACRO 						! Field definitions for action table
    WF_EOLST =
 0,7,1,0%,					! Check for end of user i/o list
    WF_CHECKW =
 0,6,1,0%,					! Check there are w postions available in output buffer
    WF_SETDSC =
 0,5,1,0%,					! Set up a string descriptor for output field
    WF_DISPAT =
 0,0,4,0%;					! CASE index for dispatch

MACRO 						! Attributes-packing macro for attributes table
    A (E, W, D, NDX) =
 (E^7 + W^6 +D^5 + NDX)%;

!
! EQUATED SYMBOLS:
!
!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (FOR);				! declare PSECTs for FOR$ facility
!
! OWN STORAGE:
!

BIND
    WF_ACT = 					! Action table for UDF_WF1, UDF_WF9 format codes
	UPLIT BYTE(

!		  E C S
!		  O H E
!		  L E T
!		  S C D
!		  T K S
!		    W C
		A(1,0,0, 0),	! ER	= 0,	! 00	! format syntax error
		A(0,0,0, 0),	! LP	= 1,	! 01	! ( - format reversion point
		A(0,0,0, 0),	! NLP	= 2,	! 02	! n( - left paran of repeat group
		A(0,0,0, 0),	! )	= 3,	! 03	! ) - right paren of repeat group
				! MAINTENANCE NOTE: the above should not be seen by this module, except look ahead in FOR$$UDF_WF9
		A(1,0,0, 1),	! EOF	= 4,	! 04	! ) - End of format
		A(0,0,0, 1),	! SLS	= 5,	! 05	! / - Record separator
		A(0,0,0, 2),	! DLR	= 6,	! 06	! $ - Dollar sign: terminal I/O
		A(1,0,0, 0),	! CLN	= 7,	! 07	! : - Colon: terminate if end of list
		0,0,0,0,	! UNUSED  8:11
		A(0,0,0, 0),	! _P	= 12,	! 0C	! sP - signed scale factor
		A(0,0,0, 0),	! _T	= 13,	! 0D	! Tn - Tab Set
				! The above is seen by lookahead only
		A(0,1,0, 4),	! _X	= 14,	! 0E	! nX - Skip n columns
		A(0,1,0, 7),	! _H	= 15,	! 0F	! nHcccc - Hollerith
				! MAINTENANCE NOTE: This routine assumes that
				! only format codes _A and _H use action 7.
				! See the CASE ... FROM 0 TO 9.
		0,0,		! UNUSED  16:17
		A(0,0,0, 0),	! TL	= 18	! 12	! TLn - Tab left n
		A(0,0,0, 0),	! TR	= 19	! 13	! TRn - Tab right n
				! The above two are seen by lookahead only
		A(1,0,0, 6),	! _Q	= 20,	! 14	! Q
		A(1,1,0, 7),	! _A	= 21,	! 15	! nAw - Alpha numeric
		A(1,1,1, 8),	! _L	= 22,	! 16	! nLw - Logical
		A(1,1,1, 8),	! _O	= 23,	! 17	! nOw - Octal
		A(1,1,1, 8),	! _I	= 24,	! 18	! nIw - Integer
		A(1,1,1, 8),	! _Z	= 25,	! 19	! nZw - Hexadecimal
		A(1,1,1, 8),	! XO	= 26	! 1A	! nOw.m
		A(1,1,1, 8),	! XI	= 27	! 1B	! nIw.m
		A(1,1,1, 8),	! XZ	= 28	! 1C	! nZw.m
		0,		! UNUSED  29
		A(1,1,1, 9),	! _F	= 30,	! 1E	! nFw.d - Fixed format
		A(1,1,1, 9),	! _E	= 31,	! 1F	! nEw.d - Scientific notation format
		A(1,1,1, 9),	! _G	= 32,	! 20	! nGw.d - General format
		A(1,1,1, 9),	! _D	= 33,	! 21	! nDw.d - Double Precision format
		A(1,1,1, 9),	! XE	= 34	! 22	! nEw.dEe
		A(1,1,1, 9),	! XG	= 35	! 23	! nGw.dEe
				! The following codes are used for lookahead only
		0,0,0,0,0,	! UNUSED  36:40
		A(1,0,0, 0),	! _DA	= 41	! 29	! nA - default A
		A(1,0,0, 0),	! _DL	= 42	! 2A	! nL - default L
		A(1,0,0, 0),	! _DO	= 43	! 2B	! nO - default O
		A(1,0,0, 0),	! _DI	= 44	! 2C	! nI - default I
		A(1,0,0, 0),	! _DZ	= 45	! 2D	! nZ - default Z
		0,0,0,0,	! UNUSED  46:49
		A(1,0,0, 0),	! _DF	= 50	! 32	! nF - default F
		A(1,0,0, 0),	! _DE	= 51	! 33	! nE - default E
		A(1,0,0, 0),	! _DG	= 52	! 34	! nG - default G
		A(1,0,0, 0)	! _DD	= 53	! 35	! nD - default D
	) : VECTOR [54, BYTE];

BIND SPACES = UPLIT('    ');

!
! EXTERNAL REFERENCES:
!

EXTERNAL
    FOR$$AA_REC_PR0 : VECTOR,			! PIC array of record processor
    						! procedure-initializations in REC
    						! level of abstraction. Indexed by
    						! I/O statement type (ISB$B_STTM_TYPE)
    FOR$$AA_REC_PR1 : VECTOR,			! PIC array of record processor procedures
    						! Write a record in REC level of
    						! abstraction. Indexed by I/O statement
    						! type (ISB$B_STTM_TYPE)
    FOR$$AA_REC_PR9 : VECTOR;			! PIC array of record processor procedures

						! Write last record in REC level of
						! abstraction. Indexed by I/O
						! statement type (ISB$B_STTM_TYPE)

EXTERNAL ROUTINE
    FOR$$FMT_INTRP0 : JSB_FMT0 NOVALUE,		! initialize format interpreter
    FOR$$FMT_INTRP1 : JSB_FMT1 NOVALUE,		! get next data format code
    ! or input-output format code
    ! error # and SIGNAL
    FOR$$SIGNAL : NOVALUE,			! convert FORTRAN err # to
						! VAX error # and SIGNAL
    FOR$$SIGNAL_STO : NOVALUE,			! convert FORTRAN err # to
						! VAX error # and SIGNAL_STOP
    FOR$CVT_D_TD,				! D to text, D format
    FOR$CVT_D_TE,				! D to text, E format
    FOR$CVT_D_TF,				! D to text, F format
    FOR$CVT_D_TG,				! D to text, G format
    FOR$CVT_G_TD,				! G to text, D format
    FOR$CVT_G_TE,				! G to text, E format
    FOR$CVT_G_TF,				! G to text, F format
    FOR$CVT_G_TG,				! G to text, G format
    FOR$CVT_H_TD,				! H to text, D format
    FOR$CVT_H_TE,				! H to text, E format
    FOR$CVT_H_TF,				! H to text, F format
    FOR$CVT_H_TG,				! H to text, G format
    OTS$CVT_L_TL,				! L to text, L format
    OTS$CVT_L_TO,				! L to text, O format
    OTS$CVT_L_TI,				! L to text, I format
    OTS$CVT_L_TZ;				! L to text, Z format

!+
! Define PIC output conversion tables.
! Order is same as format codes.
! Define as OWN rather than PSECT, because
! BLISS won't allow BIND table = UPLIT (... - table).
!-
DISPATCH_PSECTS (FOR);				! Declare OWN PSECTs to be same as code
						! so can reach with short ofsets.

OWN
    AA_OUT_FIX : VECTOR [4] INITIAL (
	OTS$CVT_L_TL - AA_OUT_FIX, !
	OTS$CVT_L_TO - AA_OUT_FIX, !
	OTS$CVT_L_TI - AA_OUT_FIX, !
	OTS$CVT_L_TZ - AA_OUT_FIX);

OWN
    AA_OUT_FLT : VECTOR [4] INITIAL (
	FOR$CVT_D_TF - AA_OUT_FLT, !
	FOR$CVT_D_TE - AA_OUT_FLT, !
	FOR$CVT_D_TG - AA_OUT_FLT, !
	FOR$CVT_D_TD - AA_OUT_FLT);

OWN
    AA_OUT_FLT_G : VECTOR [4] INITIAL (
	FOR$CVT_G_TF - AA_OUT_FLT_G,  !
	FOR$CVT_G_TE - AA_OUT_FLT_G,  !
	FOR$CVT_G_TG - AA_OUT_FLT_G,  !
	FOR$CVT_G_TD - AA_OUT_FLT_G);

OWN
    AA_OUT_FLT_H : VECTOR [4] INITIAL (
	FOR$CVT_H_TF - AA_OUT_FLT_H,  !
	FOR$CVT_H_TE - AA_OUT_FLT_H,  !
	FOR$CVT_H_TG - AA_OUT_FLT_H,  !
	FOR$CVT_H_TD - AA_OUT_FLT_H);

DECLARE_PSECTS (FOR);				! Now put PSECTs back the way they were.


GLOBAL ROUTINE FOR$$UDF_WF0 			! Write formatted UDF initialization
    : JSB_UDF0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
! Initialize Write Formatted User data formatter (UDF)
!
! CALLING SEQUENCE:
!
!	JSB FOR$$UDF_WF0
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit block
!	ISB$B_STTM_TYPE		I/O statement type code - set by
!				each I/O statement initialization
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_BEG		Adr. of first byte of output data buffer
!	LUB$A_BUF_PTR		Adr. of next byte of output
!				data buffer
!	LUB$A_BUF_HIGH		Adr. of high water byte in output buffer on this
!				I/O statement
!	LUB$A_BUF_END		Adr. +1 of last char position allocated
!				to output buffer
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Initialize Record processing level of abstraction.
    ! Set pointer to current (LUB$A_BUF_PTR)  and last+1
    ! (LUB$A_BUF_END) character position for user data in
    ! output buffer
    !-

    JSB_REC0 (FOR$$AA_REC_PR0 + .FOR$$AA_REC_PR0 [.CCB [ISB$B_STTM_TYPE] - ISB$K_FORSTTYLO + 1]);

    !+
    ! Initialize character pointer to first position for user
    ! data in output buffer - needed only for T AND $ formats
    !-

    CCB [LUB$A_BUF_BEG] = .CCB [LUB$A_BUF_PTR];

    !+
    ! Initialize character pointer to highest position
    ! written in user data buffer for this record - needed for
    ! T format which can position to the left
    !-

    CCB [LUB$A_BUF_HIGH] = .CCB [LUB$A_BUF_PTR];

    !+
    ! Initialize Format interpreter
    !-

    FOR$$FMT_INTRP0 ();

    !+
    ! All other ISB locations and flags have already been
    ! initialized to 0 or a specified value by the I/O statement
    ! initialization for this I/O statement.
    !-

    !+
    ! Print function value, output formals, and implicit outputs, if debugging
    !-

    FUNCTION_VALUE (FOR$$UDF_WF0);
    OUTPUT_FORMALS (FOR$$UDF_WF0);
    IMPLICIT_OUTPUT (FOR$$UDF_WF0, '.CCB[LUB$A_BUF_BEG]', .CCB [LUB$A_BUF_BEG], '.CCB[LUB$A_BUF_PTR]',
	.CCB [LUB$A_BUF_PTR], '.CCB[LUB$A_BUF_HIGH]', .CCB [LUB$A_BUF_HIGH], '.CCB[LUB$A_BUF_END]',
	.CCB [LUB$A_BUF_END]);
    RETURN;
    END;					! End of FOR$$UDF_WF0 routine


GLOBAL ROUTINE FOR$$UDF_WF1 (			! Format one user output element
	ELEM_TYPE, 				! Type code of user I/O list element
	ELEM_SIZE, 				! No. of addressable units in element
	ELEM_ADR)				! Adr. of element
    : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$UDF_WF1 formats a single user I/O list element
!	and places it in the current output buffer, truncating
!	if necessary to fit. It and the format interpreter,
!	(FOR$$FMT_INTRP1) interprets all format codes until the
!	first I/O list element transmitting format code is
!	encountered.  It then continues executing format codes until
!	lookahead shows that the next format code would be a data
!	transmitter or end-of-list type.
!
!	FOR$$UDF_WF1 is also called when the user I/O list
!	had no elements. This is indicated with .ELEM_TYPE=0
!	FOR$$UDF_WF1 and FOR$$FMT_INTRP1 interpret all format
!	codes up to the first data formatting one, :,
!	or end of format.
!
! CALLING SEQUENCE:
!
!	CALL FOR$$UDF_WF1 (elem_type.rlu.v, elem_size.rlu.v, elem_adr.rx.r)
!
! FORMAL PARAMETERS:
!
!	ELEM_TYPE.rlu.v		Type code of user I/O list
!				element. Form: ELEM_TYPE_x
!				x = B,W,L,WU,LU,F,D,FC or T.
!				If zero, this is an end-of-list call.
!	ELEM_SIZE.rlu.v		Size of user I/O list element
!				in addressable machine units
!	ELEM_ADR.rx.r		Adr. of user I/O list element
!				x = b, w, l, wu, lu, f, d, fc,
!				  t, g, h, dc or gc.
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit block
!	ISB$B_STTM_TYPE		I/O statement type code - set by each
!				I/O statement initialization
!
! The following ISB locations are set only by previous calls to
! FOR$$UDF_WF{0,1}, i.e., are effectively OWN.
!
!	LUB$A_BUF_BEG		Pointer to first char. position in
!				user data part of output buffer
!	LUB$A_BUF_PTR		Pointer to next char. position
!				in user data part of output buffer
!	LUB$A_BUF_HIGH		Pointer to highest char. position
!				written so far on any T format code
!	LUB$A_BUF_END		Pointer to last+1 char. position
!				in user data part of output buffer
!	ISB$V_DOLLAR		Dollar sign seen in format for this
!				record, if 1. Change carriage
!				control SP (space) to $, + to Null (0).
!   The following ISB locations are set by the format interpreter
!   (FOR$$FMT_INTRP1) which this module calls:
!
!	ISB$A_FMT_PTR		Pointer to next char. position
!				in user data part of output buffer
!				Used only in H format.
!	ISB$W_FMT_W		Field width (w)
!	ISB$B_FMT_D		No. of fraction digits (d)
!	ISB$B_FMT_E		No. of exponent characters (e)
!	ISB$B_FMT_P		Signed scale factor (p)
!
! IMPLICIT OUTPUTS:
!
!	ISB$A_FMT_PTR		Pointer to next char. position
!				in compiled format character string
!				Changed only for H format.
!
! The following ISB locations are set only by previous calls
! to FOR$$UDF_WF{0,1}, i.e., are effectively OWN.
!
!	LUB$A_BUF_PTR		Pointer to next char. position
!				in user data part of output buffer
!	LUB$A_BUF_HIGH		Pointer to highest char. position
!				written so far on any T format code
!	ISB$V_DOLLAR		Dollar sign seen in format for this
!				record, if 1. Change carriage
!				control SP to $, + to Null.
!
! FUNCTIONAL VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNAL_STOPs FOR$_OUTSTAOVE (66='OUTPUT STATEMENT OVERFLOWED RECORD')
!	if user attampts to write beyond the end of the record buffer.
!	SIGNALS FOR$_OUTCONERR (63='OUTPUT CONVERSION ERROR') -
!	    overflowed field is filled with *'s.
!	SIGNALS FOR$_FORVARMIS (61='FORMAT/VARIABLE-TYPE MISMATCH')
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	ELEM_ADR : REF VECTOR;			! element is call-by-reference

    GLOBAL REGISTER
	EL_SIZE = 10,				! Element size
	DT_SEEN = 9,				! Data transmitter seen
	FMT_CODE = 8 : BLOCK [1, LONG];		! Format code

    LOCAL
	ACT : BLOCK [1, LONG],			! Action table entry for format code
	BUF_PTR,				! Output buffer pointer from ISB
	FMT_W,					! Output field width from ISB
	DSC : BLOCK [8, BYTE];			! Static string desciptor for output field

    BUILTIN
	CVTFD;

    EL_SIZE = .ELEM_SIZE;

    !+
    !  If ELEM_TYPE is zero, then we must be in end-of-list processing.
    !  If so, set DT_SEEN to 1 so that we won't try executing a data
    !  transmitter.  If not, set DT_SEEN to zero.
    !-

    IF .ELEM_TYPE EQL 0 THEN DT_SEEN = 1 ELSE DT_SEEN = 0;

    !+
    ! Perform loop beginning with a call to the format
    ! interpreter and continue processing until we get
    ! a format code for transmitting the user I/O list data
    ! element (i.e., Q,A,L,O,Z,I,F,E,G,D) in which case perform
    ! the output conversion and return to the user program.
    ! For other formats which do output without reference to
    ! the user I/O list, perform output formatting and continue
    ! loop (i.e., EOF, /, $, :, T, X, H)
    !-

    WHILE 1 DO

    !+
    ! Get next format code requiring output interpretation:
    !    1. If repeating an explicit format code, the code
    !       is simply obtained from the B_FMT_CODE field of the ISB.
    !
    !    2. In other cases it is necessary to call FOR$$FMT_INTRP1
    !
    ! Dispatch on format code and select appropriate actions.
    !-

	BEGIN

	IF .CCB [ISB$W_FMT_REP] GTR 1 AND .CCB [ISB$B_FMT_CODE] LSSU _DA
	THEN
	    BEGIN
	    FMT_CODE = .CCB [ISB$B_FMT_CODE];
	    ACT = .WF_ACT [.FMT_CODE];

	    IF .DT_SEEN
	    THEN

		IF .ACT [WF_EOLST] THEN EXITLOOP;

	    CCB [ISB$W_FMT_REP] = .CCB [ISB$W_FMT_REP] - 1;
	    END
	ELSE
	    BEGIN

	    !+
	    ! If DT_SEEN is true, then we only want to know if the next
	    ! format code would transmit a data item.  Rather than have
	    ! the high overhead of calling the format interpreter, we
	    ! can look ahead into the format for this information.  We
	    ! can't make a 100% determination, so if the format is not
	    ! an "EOLST" type, call the format interpreter anyway.
	    ! This is a speed optimization.  If necessary, the code
	    ! between the "!**"s can be removed with no functionality loss.
	    !-

	    !**

	    IF .DT_SEEN
	    THEN
		BEGIN

		LOCAL
		    P;				! Pointer into format

		P = .CCB [ISB$A_FMT_PTR];
		FMT_CODE = CH$RCHAR (.P);	! Get next format code
		FMT_CODE [V_FMT_REPRE] = 0;	! Clear bit for comparison
		ACT = .WF_ACT [.FMT_CODE];

		IF .ACT [WF_EOLST] THEN EXITLOOP;	! End of list type

		END;

	    !**

	    FOR$$FMT_INTRP1 ();		! Call format interpreter.
					! Implicit arguments are EL_SIZE
					! and DT_SEEN.  Implicit result
					! is FMT_CODE.

	    ACT = .WF_ACT [.FMT_CODE];

	    !+
	    ! If DT_SEEN was set, and the next format character was
	    ! an "end of list", the format interpreter returned a format
	    ! code of zero, without evaluating VFE's or advancing the
	    ! pointer.  Therefore, if we have now seen a data transmitter
	    ! and this is an "end of list" format code, we can exit.
	    !-

	    IF .DT_SEEN AND .ACT [WF_EOLST] THEN EXITLOOP;

	    END;

	!+
	! Check for field extending beyond end of output buffer.
	! SIGNAL_STOP FOR$_OUTSTAOVE if the buffer is exceeded.
	! Advance buffer pointer in ISB.
	!-

	BUF_PTR = .CCB [LUB$A_BUF_PTR];
	FMT_W = .CCB [ISB$W_FMT_W];

	IF .ACT [WF_CHECKW]
	THEN
	    BEGIN
	    CCB [LUB$A_BUF_PTR] = .BUF_PTR + .FMT_W;

	    IF (.CCB [LUB$A_BUF_PTR] GTR .CCB [LUB$A_BUF_END])
	    THEN
		BEGIN
		FOR$$SIGNAL_STO (FOR$K_OUTSTAOVE);
		RETURN;
		END;

	    !+
	    ! Fill with blanks between high water mark and here, if
	    ! "here" is higher.
	    !-

	    BEGIN
	    LOCAL T;
	    T = .CCB [LUB$A_BUF_HIGH];
	    IF (.BUF_PTR GTRA .T)
	    THEN
		BEGIN
		CASE (CH$DIFF (.BUF_PTR, .T)) FROM 1 TO 8 OF
		    SET
			[8] :
			    BEGIN
			    T = CH$MOVE (4, SPACES, .T);
			    T = CH$MOVE (4, SPACES, .T);
			    END;

			[4] :
			    BEGIN
			    T = CH$MOVE (4, SPACES, .T);
			    END;

			[7] :
			    BEGIN
			    T = CH$MOVE (4, SPACES, .T);
			    T = CH$MOVE (2, SPACES, .T);
			    T = CH$MOVE (1, SPACES, .T);
			    END;

			[3] :
			    BEGIN
			    T = CH$MOVE (2, SPACES, .T);
			    T = CH$MOVE (1, SPACES, .T);
			    END;

			[6] :
			    BEGIN
			    T = CH$MOVE (4, SPACES, .T);
			    T = CH$MOVE (2, SPACES, .T);
			    END;

			[2] :
			    BEGIN
			    T = CH$MOVE (2, SPACES, .T);
			    END;

			[5] :
			    BEGIN
			    T = CH$MOVE (4, SPACES, .T);
			    T = CH$MOVE (1, SPACES, .T);
			    END;

			[1] :
			    BEGIN
			    T = CH$MOVE (1, SPACES, .T);
			    END;

			[OUTRANGE] :
			    T = BLANK_FILL (CH$DIFF (.BUF_PTR, .T), .T);
		    TES;
		CCB [LUB$A_BUF_HIGH] = .T + .FMT_W;
		END
!
!
	    ELSE

	    !+
	    ! Set new high water mark if any
	    !-

		IF .CCB [LUB$A_BUF_PTR] GTRA .CCB [LUB$A_BUF_HIGH]
		THEN
		    CCB [LUB$A_BUF_HIGH] = .CCB [LUB$A_BUF_PTR];
	    END;

	    !+
	    ! Construct a string descriptor for output field if necessary.
	    !-

	    IF .ACT [WF_SETDSC]
	    THEN
		BEGIN
		DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
		DSC [DSC$W_LENGTH] = .FMT_W;
		DSC [DSC$A_POINTER] = .BUF_PTR;
		END;

	    END;

	!+
	! Dispatch to a format-code-specific action
	!-

	CASE .ACT [WF_DISPAT] FROM 0 TO 9 OF
	    SET

	    [0] :

		!+
		! No action required on format code (e.g. Colon)
		!-

	    ;

	    [1] :

		!+
		! EOF,SLS
		! Write record for end of format or / format codes
		! Do per-record formatting and write record.  Note that
		! we now allow more than one record on direct writes.
		! Initialize all output buffer pointer for next record
		! in this I/O statement, e.g., ISB$A_BUF_{BEG,PTR,END,HIGH}
		! and ISB$V_DOLLAR = 0.
		!-

		DO_WRITE (FOR$$AA_REC_PR1 + .FOR$$AA_REC_PR1 [.CCB [ISB$B_STTM_TYPE] - ISB$K_FORSTTYLO + 1]);

	    [2] :

		!+
		! DLR
		! Dollar sign: set dollar sign encountered in this
		! record flag (ISB$V_DOLLAR). Checked when record
		! written to determine whether to change
		! carriage control for terminal.
		!-

		CCB [ISB$V_DOLLAR] = 1;

	    [3] :

		!+
		! No longer used.
		!-

	    ;

	    [4] :

		!+
		! nX: output n spaces (n in FMT_W)
		!-

		BLANK_FILL (.FMT_W, .BUF_PTR);

	    [5] :

		!+
		! No longer used.
		!-

		;

	    [6] :

		!+
		! Q format - ignore on output but use up I/O list element
		! Just exit loop and return to user program
		!-

		DT_SEEN = 1;

	    [7] :

		!+
		! nA (alphanumeric) and nH (Hollerith):
		!
		! For nA, output right-justified string in field.
		! Insert leading spaces or truncate on right as
		! necessary. Then exit loop and return to user program.
		!
		! For nH, copy n (FMT_W) characters from format to
		! output buffer.  Update format character pointer.
		!-

		BEGIN

		LOCAL
		    ELEM_PTR;

		IF .FMT_CODE EQLU _A		! Alphanumeric
		THEN
		    BEGIN

		    ELEM_PTR = .ELEM_ADR;
		    IF .EL_SIZE LSSU .FMT_W
		    THEN

			!+
			! User I/O list element is smaller than
			! field width w (FMT_W). Fill with
			! leading spaces.
			!-

			BEGIN
			BUF_PTR = BLANK_FILL (.FMT_W - .EL_SIZE, .BUF_PTR);
			FMT_W = .EL_SIZE;
			END;
		    DT_SEEN = 1;
		    END
		ELSE				! Hollerith
		    BEGIN
		    ELEM_PTR = .CCB [ISB$A_FMT_PTR];
		    CCB [ISB$A_FMT_PTR] = .CCB [ISB$A_FMT_PTR] + .FMT_W;
		    END;

		!+
		! Copy the correct number of bytes.  Use non-character
		! moves if reasonable.
		!-

		CASE .FMT_W FROM 1 TO 8 OF
		    SET

		    [8] :
			BEGIN
			COPY_QUAD_A (ELEM_PTR, BUF_PTR);
			END;

		    [4] :
			BEGIN
			COPY_LONG_A (ELEM_PTR, BUF_PTR);
			END;

		    [7] :
			BEGIN
			COPY_LONG_A (ELEM_PTR, BUF_PTR);
			COPY_WORD_A (ELEM_PTR, BUF_PTR);
			COPY_BYTE_A (ELEM_PTR, BUF_PTR);
			END;

		    [3] :
			BEGIN
			COPY_WORD_A (ELEM_PTR, BUF_PTR);
			COPY_BYTE_A (ELEM_PTR, BUF_PTR);
			END;

		    [6] :
			BEGIN
			COPY_LONG_A (ELEM_PTR, BUF_PTR);
			COPY_WORD_A (ELEM_PTR, BUF_PTR);
			END;

		    [2] :
			BEGIN
			COPY_WORD_A (ELEM_PTR, BUF_PTR);
			END;

		    [5] :
			BEGIN
			COPY_LONG_A (ELEM_PTR, BUF_PTR);
			COPY_BYTE_A (ELEM_PTR, BUF_PTR);
			END;

		    [1] :
			BEGIN
			COPY_BYTE_A (ELEM_PTR, BUF_PTR);
			END;

		    [OUTRANGE] :
			MOVE_CHAR (.FMT_W, .ELEM_PTR, .BUF_PTR);
		    TES;

		END;

	    [8] :

		!+
		! All integer formats (L,O,I,Z) output:
		! 1) Check data type. If user I/O list element is not integer (B,W,L,WU,LU),
		! and is not O or Z format,
		! SIGNAL FOR$_FORVARMIS (61='FORMAT VARIABLE-TYPE MISMATCH').
		! Then exit loop and return to user program.
		!-

		BEGIN

		LOCAL
		    S;				! No. of addressable units in user I/O list

		! element.

		!+
		! Compensate for extended format codes.
		!-

		IF .FMT_CODE GEQU XO
		THEN
		    FMT_CODE = .FMT_CODE - (_L + (XO - _O))
		ELSE
		    BEGIN
		    FMT_CODE = .FMT_CODE - _L;
		    CCB [ISB$B_FMT_D] = 1;	! Digits in integer part
		    END;

		IF .ELEM_TYPE GEQU DSC$K_DTYPE_Q AND (.FMT_CODE EQLU (_I - _L) OR .FMT_CODE EQLU (_L - _L))
		THEN
		    BEGIN
		    CCB [ISB$B_ERR_NO] = FOR$K_FORVARMIS;
		    S = %UPVAL;			! treat as if long
		    END
		ELSE
		    S = .EL_SIZE;

		!+
		! Call appropriate conversion routine.  If it doesn't fit,
		! signal FOR$_OUTCONERR.
		!-

		IF NOT (AA_OUT_FIX + .AA_OUT_FIX [.FMT_CODE]) (.ELEM_ADR, DSC, .CCB [ISB$B_FMT_D], .S,
			.CCB [ISB$B_OUT_FLAGS])
		THEN
		    CCB [ISB$B_ERR_NO] = FOR$K_OUTCONERR;

		DT_SEEN = 1;
		END;

	    [9] :

		!+
		! Determine correct conversion routine for datatype.
		! If value is not floating, signal FOR$_FORVARMIS.
		! Set scale factor and number of integer digits
		! appropriately and convert.
		!-

		BEGIN

		LOCAL
		    D_VALUE : VECTOR [2],	! D_floating temporary
		    VAL_ADDR,			! Address of value
		    CVT_ADDR;			! Address of conversion routine

		!+
		! Adjust format code for extended formats and offset
		! to first floating format code.  Also set flag
		! indicating that exponent field width overflow is an
		! error for extended formats.
		!-

		IF .FMT_CODE GEQU XE
		THEN
		    BEGIN
		    FMT_CODE = .FMT_CODE - (3 + _F);
		    CCB [ISB$V_ERR_OFLO] = 1;
		    END
		ELSE
		    BEGIN
		    FMT_CODE = .FMT_CODE - _F;
		    CCB [ISB$V_ERR_OFLO] = 0;
		    END;

		!+
		! Select based on datatype.
		!-

		CASE .ELEM_TYPE FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
		    SET

		    [DSC$K_DTYPE_F] :
			BEGIN

			!+
			! Use D_floating conversion.  Copy to D_floating
			! temporary.
			!-

			CVTFD (.ELEM_ADR, D_VALUE);
			VAL_ADDR = D_VALUE;
			CVT_ADDR = AA_OUT_FLT + .AA_OUT_FLT [.FMT_CODE];
			END;

		    [DSC$K_DTYPE_D] :
			BEGIN
			VAL_ADDR = .ELEM_ADR;
			CVT_ADDR = AA_OUT_FLT + .AA_OUT_FLT [.FMT_CODE];
			END;

		    [OUTRANGE] :

			!+
			! Check for G or H floating
			!-

			CASE .ELEM_TYPE FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
			    SET

			    [DSC$K_DTYPE_G] :
				BEGIN
				VAL_ADDR = .ELEM_ADR;
				CVT_ADDR = AA_OUT_FLT_G + .AA_OUT_FLT_G [.FMT_CODE];
				END;

			    [DSC$K_DTYPE_H] :
				BEGIN
				VAL_ADDR = .ELEM_ADR;
				CVT_ADDR = AA_OUT_FLT_H + .AA_OUT_FLT_H [.FMT_CODE];
				END;

			    [OUTRANGE] :
				BEGIN

				!+
				! Must be non-floating type.  Signal error
				! and convert as if F_floating.
				!-


				CCB [ISB$B_ERR_NO] = FOR$K_FORVARMIS;
				D_VALUE [0] = .ELEM_ADR [0];

				D_VALUE [1] = 0;
				VAL_ADDR = D_VALUE;
				CVT_ADDR = AA_OUT_FLT + .AA_OUT_FLT [.FMT_CODE];
				END;
			    TES			! End of G/H SET
		    TES;			! End of F/D SET

		BEGIN


		!+
		! Now do the conversion.  Set locals for scale factor and
		! number of integer digits based on the format code.
		!-

		LOCAL
		    SCALE,			! True scale factor
		    INT_DIGITS;			! Number of integer digits

		IF .FMT_CODE EQLU (_F - _F)	! _F was subtracted above
		THEN
		    BEGIN
		    SCALE = .CCB [ISB$B_FMT_P];
		    INT_DIGITS = 0;
		    END
		ELSE
		    BEGIN
		    SCALE = 0;
		    INT_DIGITS = .CCB [ISB$B_FMT_P];
		    END;

		IF NOT (.CVT_ADDR) (.VAL_ADDR, DSC, .CCB [ISB$B_FMT_D], .SCALE, .INT_DIGITS,
			.CCB [ISB$B_FMT_E], .CCB [ISB$B_OUT_FLAGS])
		THEN
		    CCB [ISB$B_ERR_NO] = FOR$K_OUTCONERR;

		END;

		!+
		! Exit loop and return to user program
		!-

		DT_SEEN = 1;
		END;				! End of F,E,G,D output
	    TES;				! End of CASE

	END;					! End of processing loop

    !+
    ! Print function value, output formals, and implicit outputs, if debugging.
    !-

    FUNCTION_VALUE (FOR$$UDF_WF1);
    OUTPUT_FORMALS (FOR$$UDF_WF1);
    IMPLICIT_OUTPUT (FOR$$UDF_WF1, '.CCB[ISB$A_FMT_PTR]', .CCB [ISB$A_FMT_PTR], '.CCB[LUB$A_BUF_PTR]',
	.CCB [LUB$A_BUF_PTR], '.CCB[LUB$A_BUF_HIGH]', .CCB [LUB$A_BUF_HIGH], '.CCB[ISB$V_DOLLAR]',
	.CCB [ISB$V_DOLLAR]);
    RETURN;					! Return from FOR$$UDF_WF1 routine
    END;					! End of FOR$$UDF_WF1


ROUTINE DO_WRITE (				! do per-record formatting and write record
	FOR$$REC_xn)				! adr. or record processing routine
    : JSB_DO_WRITE NOVALUE =
!+
!FUNCTIONAL DESCRIPTION:
!
!	DO_WRITE is a local routine which performs any per-record
!	formatting (as distinguished from per I/O list element formatting)
!	and then output the record by calling the appropriate
!	record processing routine depending on the statement type
!	(ISB$BSTTM_TYPE) and formal parameter FOR$$REC_xn which
!	is either (1) FOR$$REC_x1 if this is not the last record
!	of the I/o statement or (2) FOR$$REC_x9 if the is the last
!	record of the I/O statement, i.e., this is the end of I/O list call.
!	Note: DO_WRITE is also called directly from FOR$$UDF_WF9 on end of
!	I/O list if at end of format too.  Therefore, all end of
!	list processing should be kept here in DO_WRITE.
!
! CALLING SEQUENCE:
!
!	JSB DO_WRITE (R0=for$$rec_xn.s.ar)
!
! FORMAL PARAMETERS:
!
!	FOR$$REC_xn.s.ar	Adr. of record processing routine
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit block
!
! The following locations are set only by previous calls to
! FOR$$UDF_WF{0,1}, i.e., are effectively OWN for this module.
!
!	LUB$A_BUF_BEG		Pointer to first char. position in
!				user data part of output buffer
!	LUB$A_BUF_PTR		Pointer to next char. position
!				in user data part of output buffer
!	LUB$A_BUF_HIGH		Pointer to highest char. position
!				written so far on any T format code
!	LUB$A_BUF_END		Pointer to last+1 char. position
!				in user data part of output buffer
!	ISB$V_DOLLAR		Dollar sign seen in format for this
!				record, if 1. Change carriage
!				control SP to $, + to Null.
!
! IMPLICIT OUTPUTS:
!
! The following locations are set only by previous calls
! to FOR$$UDF_WF{0,1}, i.e., are effectively OWN for this module.
!
!	LUB$A_BUF_BEG		Pointer: set to first char. position
!				of next output buffer to be filled.
!	LUB$A_BUF_PTR		Pointer: set to first char. position
!				in user data part of output buffer to be filled
!	LUB$A_BUF_HIGH		Pointer: set to first char. position
!				of user data part of output buffer to be filled
!	ISB$V_DOLLAR		Set to 0
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! 1) IF $ seen in format for current record (ISB$V_DOLLAR=1),
    ! and carriage control is FORTRAN, and buffer contains at least one
    ! character, change carriage control character space to $
    ! or + to Null for terminal dialog no CR's
    ! and/or LF's.
    !-

    IF .CCB [ISB$V_DOLLAR]
    THEN
	IF .CCB [LUB$V_FTN]
	THEN
	    IF .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_BEG] GTR 0
	    THEN
		BEGIN

		IF CH$RCHAR (.CCB [LUB$A_BUF_BEG]) EQL %C' ' THEN CH_WCHAR (.CCB [LUB$A_BUF_BEG]) = %C'$';

		IF CH$RCHAR (.CCB [LUB$A_BUF_BEG]) EQL %C'+' THEN CH_WCHAR (.CCB [LUB$A_BUF_BEG]) = 0;

		END;

    !+

    !+
    ! 2) Set buffer pointer to the high water mark.  The REC level will
    ! then fill with blanks from there to the end of the buffer.
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_HIGH];
    JSB_REC1 (.FOR$$REC_xn);

    !+
    ! 3) Initialize beginning and highest pointer
    ! (T format) and dollar-sign-seen-this-record flag
    !-

    CCB [LUB$A_BUF_BEG] = .CCB [LUB$A_BUF_PTR];
    CCB [LUB$A_BUF_HIGH] = .CCB [LUB$A_BUF_PTR];
    CCB [ISB$V_DOLLAR] = 0;
    RETURN;					! Return from DO_WRITE routine
    END;					! End of DO_WRITE routine


GLOBAL ROUTINE FOR$$UDF_WF9 			! Formatted output - end of I/O list call
    : JSB_UDF9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$UDF_WF9 performs end of I/O list output formatting.
!	All format codes are processed until a data transmitting
!	format code is encountered (or colon) or end of format.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$UDF_WF9 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	See FOR$$UDF_WF1
!
!
! IMPLICIT OUTPUTS:
!
!	See FOR$$UDF_WF1
!
! FUNCTION VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	See FOR$$UDF_WF1
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If there are no items in I/O list, current format code is 0.
    ! Call data transmit entry point with element type of 0 as
    ! a flag. Return as soon as a data transmitting format code,
    ! colon, or End of Format code is encountered.
    !-

    IF .CCB [ISB$B_FMT_CODE] EQL 0 THEN FOR$$UDF_WF1 (0, 0, 0);

    !+
    ! Do the final write
    !-

    DO_WRITE (FOR$$AA_REC_PR9 + .FOR$$AA_REC_PR9 [.CCB [ISB$B_STTM_TYPE] - ISB$K_FORSTTYLO + 1]);
    RETURN;
    END;					! End of FOR$$UDF_WF9 Routine


ROUTINE BLANK_FILL (				! Fill a string with blanks
	LEN, 					! Fill length
	ADDR)					! Buffer address
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BLANK_FILL fills a string with blanks.  It is identical to
!	a CH$FILL with a first argument of %C' '.  A separate called
!	routine is used so that registers R0 through R5 are free in
!	the calling routine.
!
! CALLING SEQUENCE:
!
!	pointer.rlu.v = BLANK_FILL (len.rlu.v, addr.wbu.r)
!
! FORMAL PARAMETERS:
!
!	len		Number of bytes to blank fill.
!	addr		Address of string to fill.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! FUNCTION VALUE:
!
!	The address of the next byte past the blank-filled string.
!
! SIDE EFFECTS:
!
!	NONE
!

!++
    BEGIN
    RETURN CH$FILL (%C' ', .LEN, .ADDR);
    END;

ROUTINE MOVE_CHAR (				! Move characters
	LEN, 					! Fill length
	SOURCE, 				! Source address
	DEST)					! Destination address
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	MOVE_CHAR moves characters from one string to another.  It is
!	identical to CH$MOVE except that it does not return a value.
!	A separate called routine is used so that registers R0 through
!	R5 are free in the calling routine.
!
! CALLING SEQUENCE:
!
!	CALL MOVE_CHAR (len.rwu.v, source.rbu.r, dest.wbu.r)
!
! FORMAL PARAMETERS:
!
!	len		Number of bytes to move.
!	source		Address of string to move from.
!	dest		Address of string to move to.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! FUNCTION VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!

!++
    BEGIN
    CH$MOVE (.LEN, .SOURCE, .DEST);
    END;
END						! End of FOR$$UDF_WF Module

ELUDOM
