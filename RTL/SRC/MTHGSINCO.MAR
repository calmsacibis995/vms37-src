	.TITLE	MTH$GSINCOS 	; Floating Point Sine, Cosine and Sincos
				;    Functions
	.IDENT /2-003/		; File:	MTHGSINCOS.MAR	EDIT: RNH2003
; 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; 
; FACILITY:	MATH LIBRARY
;++
; ABSTRACT:
; 
; MTH$GSIN and MTH$GCOS are functions which return the floating point
; sine or cosine value of their single precision floating point argu-
; ment (radians). The call is standard call-by-reference.
; MTH$GSIN_R7 and MTH$GCOS_R7 are special routines which are the same
; as MTH$GSIN and MTH$GCOS  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
;
; MTH$GSINCOS  is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point radian argument.
; The call is standard call-by-reference.  MTH$GSINCOS_R7 is a special 
; routine  which  is  the  same  as  MTH$GSINCOS, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
; MTH$GSIND and MTH$GCOSD are functions which return the floating point
; sine  or  cosine value of their single precision floating point argu-
; ment (degrees). The call is standard call-by-reference.
; MTH$GSIND_R7 and MTH$GCOSD_R7 are special routines which are the same
; as MTH$GSIND and MTH$GCOSD  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
; 
; MTH$GSINCOSD is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point degree argument.
; The call is standard call-by-reference. MTH$GSINCOSD_R7 is a special 
; routine  which  is  the  same  as MTH$GSINCOSD, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
;--
; 
; VERSION:	1
; 
; HISTORY:
; AUTHOR:
; 	MARY PAYNE & JUD LEONARD, 25-MAY-78:	Version 0
; 
; MODIFIED BY:
; 
; 1-1	Tryggve Fossum, 28-May-78
; 
; 
; VERSION:	2
; 
; HISTORY:
; AUTHOR:
; 	BOB HANEK, 25-MAY-78:	Version 2
; 
; 
; Edit history for Version 2:
;
; 2-001 - Original
; 2-002 - Change MTH$AL_4_OV_PI to MTH$AL_4_OV_PI_V.  RNH 29-Sep-81
; 2-003 - Modified REDUCE_LARGE to correct bug reported in QAR 896.
;         RNH 14-Jan-82

	.SBTTL	DECLARATIONS	-	 Declarative Part of Module

; 
; INCLUDE FILES:	MTH$JACKET.MAR

; EXTERNAL SYMBOLS:
; 
	.DSABL	GBL
	.EXTRN	MTH$AL_4_OV_PI_V
	.EXTRN	MTH$$SIGNAL
	.EXTRN	MTH$K_FLOUNDMAT
	.EXTRN	MTH$$JACKET_TST
; 
; EQUATED SYMBOLS:
   
	X_1_OV_45        = ^XC16C

; 
; MACROS:	

	$SFDEF			; Define SF$ (stack frame) symbols
	$PSLDEF			; Define PSL$ symbols

; PSECT DECLARATIONS:

	.PSECT	_MTH$CODE	PIC,SHR,LONG,EXE,NOWRT
				; program section for math routines
; 
; OWN STORAGE:	none
; 
; CONSTANTS:

G_M1:
	.QUAD	^X000000000000C010	; -1
G_PI_OV_4:
	.QUAD	^X2D18544421FB4009	; 0.7853981633974483E+00
G_9_PI_OV_4:
	.QUAD	^XB2BBBECC463A403C	; 0.7068583470577035E+01
G_3_PI_OV_4:
	.QUAD	^X21D27F33D97C4022	; 0.2356194490192345E+01
G_5_PI_OV_4:
	.QUAD	^X385E29556A7A402F	; 0.3926990816987241E+01
G_7_PI_OV_4:
	.QUAD	^XA775E9BBFDBB4035	; 0.5497787143782138E+01

G_45:
	.QUAD	^X0000000080004066	; 0.4500000000000000E+02
G_M45:
	.QUAD	^X000000008000C066	; -.4500000000000000E+02
G_SMALLD:
	.QUAD	^XC1F81A63A5DC3EBC	; 0.4268868231257969E-06
G_1_OV_45:
	.QUAD	^X6C1716C1C16C3FB6	; 0.2222222222222222E-01
G_CONVERT:
	.QUAD	^XD3912529F46A3F7D	; 0.1828292519943295E-02
G_90_OV_PI:
	.QUAD	^XC1F81A63A5DC405C	; 0.2864788975654116E+02
G_SMALLEST_DEG:
	.QUAD	^XC1F81A63A5DC006C	; 0.3187183529933799-306

H_PI_OV_2:				; 1.57079632679489661923132169163975
	.OCTA	^X01B8C517898C846942D1B544921F4001	
H_PI:					; 3.14159265358979323846264338327950
	.OCTA	^X01B8C517898C846942D1B544921F4002	
H_3_PI_OV_2:				; 4.71238898038468985769396507491925
	.OCTA	^X414A93D12729234F321DC7F32D974003	
H_2_PI:					; 6.28318530717958647692528676655901
	.OCTA	^X01B8C517898C846942D1B544921F4003	
H_2_OV_PI:				; .636619772367581343075535053490057
	.OCTA	^XEA6AAFA3F84E2A539C8806DC45F34000


	.SBTTL	COEFFICIENT TABLES	-	Series Coefficients




;
; Polynomial Coefficient tables for arguments in radians
;

COSTBR1:	; GCOS coefficients for arguments less than 1/2
	.QUAD	^XCD345EF0F6ADBDC8	; C7 = -.1135212320578394E-10
	.QUAD	^XC93D4799EE953E41	; C6 = 0.2087555514567788E-08
	.QUAD	^X19916FE27E4FBEB2	; C5 = -.2755731286569608E-06
	.QUAD	^X767E19AD01A03F1A	; C4 = 0.2480158728289946E-04
	.QUAD	^X362D16C1C16CBF76	; C3 = -.1388888888885896E-02
	.QUAD	^X5533555555553FC5	; C2 = 0.4166666666666643E-01
	.QUAD	^X000000000000C000	; C1 = -.5000000000000000E+00
	.QUAD	^X0000000000004010	; C0 = 0.1000000000000000E+01
COSLENR1 = .-COSTBR1/8

COSTBR2:	; GCOS coefficients for arguments greater than 1/2
	.QUAD	^XCD345EF0F6ADBDC8	; C7 = -.1135212320578394E-10
	.QUAD	^XC93D4799EE953E41	; C6 = 0.2087555514567788E-08
	.QUAD	^X19916FE27E4FBEB2	; C5 = -.2755731286569608E-06
	.QUAD	^X767E19AD01A03F1A	; C4 = 0.2480158728289946E-04
	.QUAD	^X362D16C1C16CBF76	; C3 = -.1388888888885896E-02
	.QUAD	^X5533555555553FC5	; C2 = 0.4166666666666643E-01
	.QUAD	^X5EE62C4080673C80	; C1 = 0.7156417079102195E-17
	.QUAD	^X5D30B344297FBC05	; C0 = -.3584999999999999E-19
COSLENR2 = .-COSTBR2/8

SINTBR:		; GSIN coefficients 
	.QUAD	^XB5E36E13D8403E05	; C6 = 0.1589413523004633E-09
	.QUAD	^X3319B5B3E5E2BE7A	; C5 = -.2505070582636817E-07
	.QUAD	^X5AD851F31DE33EE7	; C4 = 0.2755731329888568E-05
	.QUAD	^X2F3C19B901A0BF4A	; C3 = -.1984126982840175E-03
	.QUAD	^XF30C111011113FA1	; C2 = 0.8333333333320002E-02
	.QUAD	^X554355555555BFE5	; C1 = -.1666666666666662E+00
	.QUAD	^X 33809DB8D82BC6E	; C0 = -.3312537470886997E-17
SINLENR = .-SINTBR/8





;
; Polynomial coefficients for arguments in cycles
;

COSTBC1:	; GCOS coefficients for arguments less than 2/pi
	.QUAD	^X815BB9952586BD7B	; C7 = -.3857762037200000E-12
	.QUAD	^X4DE15D519CC13DFF	; C6 = 0.1150049702426300E-09
	.QUAD	^X8016C3D46D1EBE7A	; C5 = -.2461136382637005E-07
	.QUAD	^X3F2468301F503EEE	; C4 = 0.3590860445885820E-05
	.QUAD	^X8D5C7E3C5D3CBF55	; C3 = -.3259918869266876E-03
	.QUAD	^X5AAA081B3C1F3FB0	; C2 = 0.1585434424381541E-01
	.QUAD	^X45DEC9BEBD3CBFF3	; C1 = -.3084251375340424E+00
	.QUAD	^X5D30B344297FBC05	; C0 = -.3584999999999999E-19
COSLENC1 = .-COSTBC1/8

COSTBC2:	; GCOS coefficients for arguments greater than 2/pi
	.QUAD	^X815BB9952586BD7B	; C7 = -.3857762037200000E-12
	.QUAD	^X4DE15D519CC13DFF	; C6 = 0.1150049702426300E-09
	.QUAD	^X8016C3D46D1EBE7A	; C5 = -.2461136382637005E-07
	.QUAD	^X3F2468301F503EEE	; C4 = 0.3590860445885820E-05
	.QUAD	^X8D5C7E3C5D3CBF55	; C3 = -.3259918869266876E-03
	.QUAD	^X5AAA081B3C1F3FB0	; C2 = 0.1585434424381541E-01
	.QUAD	^X2EF24DF2E9E6BFCD	; C1 = -.5842513753404245E-01
	.QUAD	^X5D30B344297FBC05	; C0 = -.3584999999999999E-19
COSLENC2 = .-COSTBC2/8

SINTBC:		; GSIN coef for arg in cycles
	.QUAD	^XCB82386D3EED3DBE	; C6 = 0.6877100349000000E-11
	.QUAD	^X 141399B3006BE3E	; C5 = -.1757149292755000E-08
	.QUAD	^X1EF8FCA307823EB5	; C4 = 0.3133616216619040E-06
	.QUAD	^X52FACE2D2D2CBF23	; C3 = -.3657620415845570E-04
	.QUAD	^X86FF677566BC3F84	; C2 = 0.2490394570188736E-02
	.QUAD	^XBE41E625ABBCBFD4	; C1 = -.8074551218828054E-01
	.QUAD	^XD18444421FB53FC2	; C0 = 0.3539816339744831E-01
SINLENC = .-SINTBC/8





;
; Polynomial coefficients for arguments in degrees
;

COSDTB2:	; GCOS coefficients for arguments less than 90/pi
	.QUAD	^X20197263613EB8AD	; C7 = -.2762868673216389E-35
	.QUAD	^XADD69711EA1439E0	; C6 = 0.1667886312398853E-29
	.QUAD	^XB183A296F623BB0B	; C5 = -.7227873495985314E-24
	.QUAD	^XD1DD5C0483AB3C2F	; C4 = 0.2135494301985904E-18
	.QUAD	^X78AF5BBC19B8BD46	; C3 = -.3925831985734635E-13
	.QUAD	^XDC736A839B113E50	; C2 = 0.3866323851562971E-08
	.QUAD	^X1FB9DB14F6A1BF43	; C1 = -.1523087098933543E-03
	.QUAD	^X0000000000004010	; C0 = 0.1000000000000000E+01
COSDLN2 = .-COSDTB2/8 - 1

COSDTB1:	; GCOS coefficients for arguments greater than 90/pi
	.QUAD	^X20197263613EB8AD	; C7 = -.2762868673216389E-35
	.QUAD	^XADD69711EA1439E0	; C6 = 0.1667886312398853E-29
	.QUAD	^XB183A296F623BB0B	; C5 = -.7227873495985314E-24
	.QUAD	^XD1DD5C0483AB3C2F	; C4 = 0.2135494301985904E-18
	.QUAD	^X78AF5BBC19B8BD46	; C3 = -.3925831985734635E-13
	.QUAD	^XDC736A839B113E50	; C2 = 0.3866323851562971E-08
	.QUAD	^XFDCCD8A0B50EBF1F	; C1 = -.3023839739335430E-04
	.QUAD	^X5D30B344297FBC05	; C0 = -.3584999999999999E-19
COSDLN1 = .-COSDTB1/8 - 1

SINDTB:		; GSIN coefficients
	.QUAD	^X17E0B73504203947	; C6 = 0.2216372140147286E-32
	.QUAD	^XC8145B97B6BEBA76	; C5 = -.1146755972041862E-26
	.QUAD	^X85EFDBD84A5F3B9F	; C4 = 0.4141266526843263E-21
	.QUAD	^XBA169F5A368DBCBC	; C3 = -.9788384855269454E-16
	.QUAD	^XD93DEAE0AD943DCD	; C2 = 0.1349601623161096E-10
	.QUAD	^X2F5E0D94BB82BECD	; C1 = -.8860961557012952E-06
	.QUAD	^XD3912529F46A3F7D	; C0 = 0.1828292519943296E-02
SINDLN = .-SINDTB/8 - 1


	.SBTTL	MTH$GSINCOS	-	Radian arguments


;
; FUNCTIONAL DESCRIPTION:
;
; The GSIN, GCOS and GSINCOS routines are based on octant reduction.  Given an 
; argument, x, it is written in the form
;
;            x = I1*(2*pi) + I*(pi/4) + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < pi/4.  Since GSIN and 
; GCOS have a period of 2*pi it follows that
;
;            GSIN(x) = GSIN(I*(pi/4) + Y1)) and
;            GCOS(x) = GCOS(I*(pi/4) + Y1)).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then GSIN(x) =                and GCOS(x) =
;       ------            -------------                -------------
;         0                 GSIN(Y1)                      GCOS(Y1)
;         1                 GCOS(pi/4-Y1)                 GSIN(pi/4-Y1)
;         2                 GCOS(Y1)                     -GSIN(Y1)
;         3                 GSIN(pi/4-Y1)                -GCOS(pi/4-Y1)
;         4                -GSIN(Y1)                     -GCOS(Y1)
;         5                -GCOS(pi/4-Y1)                -GSIN(pi/4-Y1)
;         6                -GCOS(Y1)                      GSIN(Y1)
;         7                -GSIN(pi/4-Y1)                 GCOS(pi/4-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = pi/4 - Y1, if I is odd, then
; each entry of the above table is of the for +/-GSIN(Y) or +/-GCOS(Y).  Based 
; on the above remarks, the GSIN, GCOS and GSINCOS routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.

; 
; INPUT PARAMETERS:
; 
	LONG   = 4
	x      = 1*LONG		; x is input angle in radians
	sine   = 2*LONG		; sine is GSIN(x)
	cosine = 3*LONG		; cosine is GCOS(x)




;
; Return sine and cosine of argument
;


	.ENTRY	MTH$GSINCOS, ^M<R2, R3, R4, R5, R6,R7>

	MTH$FLAG_JACKET

	MOVG	@x(AP), R0
	JSB	MTH$GSINCOS_R7
	MOVQ	R0, @sine(AP)
	MOVQ	R2, @cosine(AP)
	RET



	.SBTTL	MTH$GSIN

;
; Return sine of argument
;


	.ENTRY	MTH$GSIN, ^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVG	@x(AP), R0
	JSB	MTH$GSIN_R7
	RET



	.SBTTL	MTH$GCOS

;
; Return cosine of argument
;


	.ENTRY	MTH$GCOS, ^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVG	@x(AP), R0
	JSB	MTH$GCOS_R7
	RET


	.SBTTL	MTH$GSINCOSD	-	Degrees


;
; FUNCTIONAL DESCRIPTION:
;
; The GSIND, GCOSD and GSINCOSD routines are based on octant reduction.  Given 
; an argument, x, it is written in the form
;
;            x = I1*360 + I*45 + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < 45.  Since GSIND and 
; GCOSD have a period of 360 it follows that
;
;            GSIND(x) = GSIND(I*45 + Y1) and
;            GCOSD(x) = GCOSD(I*45 + Y1).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then GSIND(x) =                and GCOSD(x) =
;       ------            -------------                -------------
;         0                 GSIND(Y1)                      GCOSD(Y1)
;         1                 GCOSD(45-Y1)                   GSIND(45-Y1)
;         2                 GCOSD(Y1)                     -GSIND(Y1)
;         3                 GSIND(45-Y1)                  -GCOSD(45-Y1)
;         4                -GSIND(Y1)                     -GCOSD(Y1)
;         5                -GCOSD(45-Y1)                  -GSIND(45-Y1)
;         6                -GCOSD(Y1)                      GSIND(Y1)
;         7                -GSIND(45-Y1)                   GCOS(45-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = 45 - Y1, if I is odd, then
; each entry of the above table is of the for +/-GSIN(Y) or +/-GCOS(Y).  Based 
; on the above remarks, the GSIND, GCOSD and GSINCOSD routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.


	LONG = 4
	sind = 2*LONG
	cosd = 3*LONG


	.ENTRY	MTH$GSINCOSD	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVG	@X(AP), R0
	JSB	MTH$GSINCOSD_R7
	MOVQ	R0, @sind(AP)
	MOVQ	R2, @cosd(AP)
	
	RET



	.ENTRY	MTH$GSIND	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVG	@X(AP), R0
	JSB	MTH$GSIND_R7

	RET



	.ENTRY	MTH$GCOSD	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVG	@X(AP), R0
	JSB	MTH$GCOSD_R7

	RET


	.SBTTL MTH$GSINCOS_R7

; This routine computes the GSIN and GCOS of the G-format value of R0/R1.  The
; computation is performed one of three ways depending on the size of the
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in polynomial approximation
;          of GSIN and GCOS.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute GSIN(X) and GCOS(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute GSIN(X) and GCOS(X).

MTH$GSINCOS_R7::
	MOVG	R0, R6			; R6 = X
	BGEQ	POS_SINCOS		; 
	JSB	SINCOS			; R0/R1 = GSIN(|X|), R2/R3 = GCOS(X)
	MNEGG	R0, R0			; R0/R1 = GSIN(X)
	RSB

SINCOS:
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SINCOS:
	CMPG	G_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SINCOS		; No argument reduction is necessary
	CMPG	G_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BGEQ	1$	
	BRW	LARGE_SINCOS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
1$:	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R4/R7 = Y = reduced argument
					; R2 = octant
	MOVO	R4, -(SP)		; Save reduced argument on stack
	PUSHL	R2			; Save octant bits on stack
	JSB	M_COS			; R0/R1 = GCOS(X)
	MOVL	(SP)+, R2		; R2 = Octant bits
	MOVO	(SP)+, R4		; R4/R7 = reduced argument
	MOVQ	R0, -(SP)		; Save GCOS(X) on stack
	JSB	M_SIN			; R0/R1 = GSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = GCOS(X)
	RSB
;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SINCOS:
	CMPW	#^X4000, R0		; Compare 1/2 with |X|
	BLSS	2$			; Sufficent overghang not available
	CMPW	#^X3E60, R0		; Compare with 2^-27
	BGEQ	1$			; No polynomial evaluation is needed
	MOVQ	R0, R6			; R6/R7 = |X|
	MULG3	R6, R6, R4		; R4/R5 = X*X
	MOVQ	R4, -(SP)		; Put X*X on stack
	POLYG	R4, #COSLENR1-1, COSTBR1; R0/R1 = GCOS(X)
	MOVQ	(SP), R4 		; R4/R5 = X*X
	MOVQ	R0, (SP)		; Save GCOS(X) on stack
	POLYG	R4, #SINLENR-1, SINTBR	; R0/R1 = q(X^2)
	MULG2	R6, R0			; R0/R1 = X*q(X^2)
	ADDG2	R6, R0			; R0/R1 = GSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = GCOS(X)
	RSB

1$:	MOVG	#1.0, R2		; R0/R1 = X, R2/R3 = 1.0 = GCOS(X)
	RSB	


2$:	MOVQ	R0, -(SP)		; Save |x| on stack
	CVTGH	R0, R4			; R4/R7 = |X|
	MULH2	R4, R4			; R4/R7 = X^2
	CVTHG	R4, R2			; R2/R3 = X^2
	MOVQ	R2, -(SP)		; Save X^2 on stack
	MOVQ	R4, -(SP)		; Save high half of X^2 on stack
	POLYG	R2, #COSLENR2-1, COSTBR2; R0/R1 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y^2
	DECW	R4			; R4/R7 = Y^2/2
	SUBH2	#1, R4			; R4/R7 = Y^2/2 - 1
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	SUBH2	R4, R0			; R0/R3 = GCOS(Y)
	CVTHG	R0, R0			; R0/R1 = GCOS(Y)
	MOVQ	(SP), R2		; R2/R3 = X^2
	MOVQ	R0, (SP)		; Save GCOS(X) in R5
	POLYG	R2, #SINLENR-1, SINTBR	; R0/R1 = q(X^2)
	MOVQ	(SP)+, R2		; R2/R3 = GCOS(X)
	MULG2	(SP), R0		; R0/R1 = X*q(X^2)
	ADDG2	(SP)+, R0		; R0/R1 = GSIN(X)
	RSB


LARGE_SINCOS:
	JSB	REDUCE_LARGE		; R4/R7 = reduced argument (in cycles)
					; R2 = octant bits
	PUSHL	R2			; Save octant bits on stack
	MOVO	R4, -(SP)		; Save reduced argument on stack
	JSB	L_COS			; R0/R1 = GCOS(X)
	MOVO	(SP)+, R4		; Reduced argument in R3/R6
	MOVL	(SP)+, R2		; R2 = octant bits
	MOVQ	R0, -(SP)		; R2/R3 = GCOS(X)
	JSB	L_SIN			; R0/R1 = GSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = GCOS(X)
	RSB	

	.SBTTL MTH$GSIN_R7

; This routine computes the GSIN of the G-format value of R0/R1.  The 
; computation is performed one of three ways depending on the size of the 
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in a polynomial approximation
;          of GSIN.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute GSIN(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute GSIN(X).

MTH$GSIN_R7::
	TSTG	R0			; Check the sign of R0
	BGEQ	POS_SIN			;
	JSB	SIN			; R0/R1 = GSIN(|X|)
	MNEGG	R0, R0			; R0/R1 = GSIN(X)
	RSB

SIN:
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SIN:
	CMPG	G_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SIN		; No argument reduction is necessary
	CMPG	G_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BLSS	LARGE_SIN		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R4/R7 = Y = reduced argument
					; R2 = octant
M_SIN:	CASEB	R2, #0, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	P_SIN_R-1$		;    octant bits.
	.WORD	P_COS_R-1$
	.WORD	P_COS_R-1$		
	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SIN:
	CMPW	#^X3E60, R0		; Compare with 2^-27
	BGEQ	1$			; No polynomial evaluation is needed
	MOVQ	R0, R6			; R6/R7 = X
	MULG2	R0,R0			; R0/R1 = X*X
	POLYG	R0, #SINLENR-1, SINTBR	; R0/R1 = q(x^2)
	MULG2	R6, R0			; R0/R1 = X*q(x^2)
	ADDG2	R6, R0			; R0/R1 = GSIN(X)
1$:	RSB


LARGE_SIN:
	JSB	REDUCE_LARGE		; R4/R7 = reduced argument (in cycles)
					; R2 = octant bits
L_SIN:	TSTL	R4			; Check for degenerate case
	BEQL	DEGENERATE_CASE_SIN

	CASEB	R2, #0, #7

1$:	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$


DEGENERATE_CASE_SIN:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	P_ONE-1$
	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$




	.SBTTL MTH$GCOS_R7

; This routine computes the GCOS of the G-format value of R0/R1.  The 
; computation is performed one of three ways depending on the size of the 
; input argument, X.  The processing is the same as described for MTH$GSIN_R4.
;

MTH$GCOS_R7::
	TSTG	R0			; Check for reserved operand
	BICW	#^X8000, R0		; R0/R1 = |X|
	CMPG	G_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_COS		; No argument reduction is necessary
	CMPG	G_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BLSS	LARGE_COS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R4/R7 = Y = reduced argument
					; R2 = octant
M_COS:	CASEB	R2, #0, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	P_COS_R-1$		;    octant bits.
	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_COS_R-1$

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_COS:
	CMPW	#^X4000, R0		; Compare 1/2 with |X|
	BGEQ	1$			; Sufficent overghang is available
	CVTGH	R0, R4			; R4/R7 = |X|
	BRW	NEEDS_DOUBLE		; Use special logic to obtain overhang
1$:	CMPW	#^X3E60, R0		; Compare with 2^-27
	BGEQ	2$			; No polynomial evaluation is needed
	MULG2	R0,R0			; R0/R1 = X*X
	POLYG	R0, #COSLENR1-1, COSTBR1; R0/R1 = GCOS(X)
	RSB

2$:	MOVG	#1.0, R0		; R0/R1 = 1.0 = GCOS(X)
	RSB	


LARGE_COS:
	JSB	REDUCE_LARGE		; R4/R7 = reduced argument (in cycles)
					; R2 = octant bits
L_COS:	TSTL	R4			; Check for degenerate case
	BEQL	DEGENERATE_CASE_COS

	CASEB	R2, #0, #7
1$:	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$
	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$


DEGENERATE_CASE_COS:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$
	.WORD	P_ONE-1$


	.SBTTL	MTH$GSINCOSD_R7

; This routine computes the GSIND and GCOSD of the G-format value of R0/R1.
; The computation is performed one of two ways depending on the size of the 
; input argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of GSIND and GCOSD.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute GSIND(X) and 
;          GCOSD(X).

MTH$GSINCOSD_R7::
	TSTG	R0
	BGEQ	SINCOSD
	BICW	#^X8000, R0		; R0/R1 = |X|
	JSB	SINCOSD			; R0/R1 = GSIND(|X|)
					; R2/R3 = GCOSD(|X|)
	MNEGG	R0, R0			; R2/R3= -GSIND(|X|)
	RSB

SINCOSD:
	CMPG	G_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SINCOSD		; special processing for small arg
	JSB	REDUCE_DEGREES		; R6/R7 = reduced argument
					; R3 = octant
	MOVQ	R6, -(SP)		; Save reduced arg
	PUSHL	R3			; Save octant bits
	JSB	EVAL_COSD		; R0/R1 = GCOSD(Y)
	MOVL	(SP)+, R3		; R3 = octant bits
	MOVQ	(SP), R6		; R6/R7 = reduced argument
	MOVQ	R0, (SP)		; Save GCOSD(Y)
	JSB	EVAL_SIND		; R0/R1 = GSIND(Y)
	MOVQ	(SP)+, R2		; R2/R3 = GCOSD(Y)
	RSB


SMALL_SINCOSD:
	SUBL	#16, SP			; Allocate 4 longwords on stack
	MOVQ	R0, (SP)		; Save argument
	JSB	SMALL_COSD		; R0/R1 = GCOSD(|X|)
	MOVQ	R0, 8(SP)		; Save GCOSD(|X|)
	MOVQ	(SP)+, R0		; R0/R1 = argument
	JSB	SMALL_SIND		; R0/R1 = GSIND(X)
	MOVQ	(SP)+, R2		; R2/R3 = GCOSD(|X|)
	RSB

	.SBTTL	MTH$GSIND_R7

; This routine computes the GSIND of the G-format value of R0/R1.  The 
; computation is performed one of two ways depending on the size of the input 
; argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of GSIND.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute GSIND(X).

MTH$GSIND_R7::
	TSTG	R0			; R0/R1 = X
	BGEQ	POS_SIND		;
	JSB	NEG_SIND		; R0/R1 = GSIND(|X|)
	MNEGG	R0, R0			; R0/R1 = -GSIND(|X|)
	RSB

NEG_SIND:	
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SIND:
	CMPG	G_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SIND		; special processing for small arg
	JSB	REDUCE_DEGREES		; R6/R7 = reduced argument
					; R3 = octant

EVAL_SIND:
	CASEB	R3, #0, #7
1$:	.WORD	P_SIN_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_SIN_D-1$
	.WORD	N_SIN_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_SIN_D-1$


SMALL_SIND:
	CMPG	G_SMALLD, R0		; Compare 180/pi*2^-27 with |x|
	BGTR	1$			; No polynomial evaluation is 
	MOVQ	R0, R6			;   necessary
	BRW	P_SIN_D			;   
1$:	TSTG	R0			; Check for zero
	BEQL	3$			; Return if R0 = 0
	CMPG	G_SMALLEST_DEG, R0	; Check for possible underflow on
	BLEQ	2$			;   conversion to radians
	BRW	UNFL			; Underflow will occur on conversion
2$:	MULG3	G_CONVERT, R0, R2	; R2/R3 = (pi/180 - 2^-6)*|x|
	SUBW	#^X60, R0		; R0/R1 = |X|*2^-6
	ADDG2	R2, R0			; R0/R1 = GSIND(|X|) = (pi/180)|X|
3$:	RSB

	.SBTTL	MTH$GCOSD_R7

; This routine computes the GCOSD of the G-format value of R0.  The computation
; is performed one of two ways depending on the size of the input argument, X:
; Details are given in the discussion on MTH$GCOSD_R4.

MTH$GCOSD_R7::
	TSTG	R0			; Check for reserved operand
	BICW	#^X8000, R0 		; R0/R1 = |X|
	CMPG	G_45, R0		; Compare 45 to |X|
	BGTR	SMALL_COSD		;
	JSB	REDUCE_DEGREES 		; R6/R7 = reduced argument
					; R3 = octant

EVAL_COSD:
	CASEB	R3, #0, #7
1$:	.WORD	P_COS_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	P_COS_D-1$	


SMALL_COSD:
	CMPG	G_SMALLD, R0		; Compare 180/pi*2^-27  with |X|
	BGTR	1$			; Check if polyinomial evaluation is
	MOVQ	R0, R6			;    necessary.
	BRW	P_COS_D			; POLY needed
1$:	MOVG	#1, R0			; R0 = 1. = GCOSD(|X|)
	RSB




	.SBTTL	REDUCE_MEDIUM

;
; This routine assumes that the absolute value of the argument, X,  is in R0/R1
; and that pi/4 =< |X| < 9*pi/4.  It returns an h- format reduced argument, Y, 
; in R4/R7, and the octant bits in R2.
;
; The reduced argument is obtained by locating the octant that X is in through
; a binary search and then subtracting off a suitable multiple of pi/2
;

REDUCE_MEDIUM:
	CMPG	G_5_PI_OV_4, R0	; 
	BLEQ	5$			; |X| >= 5*pi/4
	CMPG	G_3_PI_OV_4, R0	
	BLEQ	3$			; |X| >= 3*pi/4
	CVTGH	R0, R0			
	SUBH3	H_PI_OV_2, R0, R4	; R4/R7 = |X| - pi/2 
	BGEQ	2$			; 
	MOVL	#1, R2			; Octant bits = 001
	RSB

2$:	MOVL	#2, R2			; Octant bits = 010
	RSB

3$:	CVTGH	R0, R0			
	SUBH3	H_PI, R0, R4		; R4/R7 = |X| - pi
	BGEQ	4$			; 
	MOVL	#3, R2			; Octant bits = 011
	RSB

4$:	MOVL	#4, R2			; Octant bits = 100
	RSB

5$:	CMPG	G_7_PI_OV_4, R0	; 
	BLEQ	7$			; |X| >= 7*pi/4
	CVTGH	R0, R0			
	SUBH3	H_3_PI_OV_2, R0, R4	; R4/R7 = |X| - 3*pi/2
	BGEQ	6$			;
	MOVL	#5, R2			; Octant bits = 101
	RSB

6$:	MOVL	#6, R2			; Octant bits = 110
	RSB

7$:	CVTGH	R0, R0			
	SUBH3	H_2_PI, R0, R4		; R4/R7 = |X| - 2*pi
	BGEQ	8$			;
	MOVL	#7, R2			; Octant bits = 111
	RSB

8$:	CLRL	R2			; Octant bits = 000
	RSB






	.SBTTL	REDUCE_LARGE

;
; This routine is used to reduce large arguments (|X| >= 9*pi/4) modulo pi/4.
; It returns the reduced argument, Y, in R4/R5 in units of cycles, and returns
; the octant bits, I, in R2.
;
; The method of reduction is as follows:
;
;     x*(4/pi) = 2^n*f*(4/pi) where n is an integer and 1/2 =< f < 1
;              = 2^(n-53)*(2^53*f)*(4/pi)
;              = (2^53*f)*(2^(n-53)*4/pi)
;              = K*C, where K = 2^53*f is an integer and C = 2*(n-53)*4/pi
;     Let L = K*C modulo 8, where 0 =< L < 8, and let I = the integer(L) and
;     h = fract(L), then if I is even Y = h, otherwise Y = 1-h
;
; CONSTANTS:

	L_INT_WEIGHT  = ^X3D		; weights exponent by 61
	W_TERM_WEIGHT = ^X20		; weights exponent by 32
	W_MAX_WEIGHT  = ^X400		; maximum unbiased exponent
	W_ADJUST      = ^X3B6		; Used to locate binary point in
					;   MTH$AL_4_OV_PI_V table
H_2_TO_32:
	.OCTA	^X4021			; 2^32



REDUCE_LARGE:
;
; The first step is to obtain the location of the binary point in the represen-
; tation of C = 2^(n-53)*(4/pi) in two parts - the number of longwords from
; the start and the number of bits from the most significant bit of the next
; longword. Also K = 2^53*f must be obtained.
;
	ROTL	#-4, R0, R3		; Shift exponext field 4 bits right
	SUBW	#W_ADJUST, R3		; Unbias exp and adjust for leading 
					;   zeroes.  R3 = location of binary
					;   point 
	ROTL	#-3, R3, R4		; Divide R3 by 32 and mull by 4 to get 
	BICL	#^XFFFFFF03, R4		;   R4 = # of longwords (in bytes) to 
					;   binary point.
	
	MOVAL	G^MTH$AL_4_OV_PI_V, R2	; R2 = address of RTL vector entry
	ADDL	G^MTH$AL_4_OV_PI_V, R2	; R2 = address of MTH$AL_4_OV_PI table
	SUBL	R4, R2			; R2 points to 1st quadword of interest
	BICB	#^XE0, R3		; R3(7:0) = # of bits within longword

	BICW	#^X7FF0, R0		; Clear exponent field
	BISW	#^X4150, R0		; R0 = 2^21*f
	CVTGL	R0, R0			; R0 = High 21 bits of K
	ROTL	#16, R1, R1		; R1 = Low 32 bits of K
	BGEQ	1$			; Check for high bit of R1 set
	INCL	R0			; Adjust R0 if R1 is negative

;
; The next step is to generate an approximation to C, call it C'' to be used
; in computing x*4/pi.  C'' will consist of the first three integer bits of
; C and the first 61 fraction bits of C.  These bits will be obtained from a
; constant stored in the interger array MTH$AL_4_OV_PI_V.
;
; NOTE:  The ASHQ, ADDL, and MULL instructions in the follow sections may 
; result in an integer overflow trap.  The overflow incurred is intentional,  
; so that the IV bit must be turned off.  The IV bit is not restored until 
; after all of the necessary fraction bits hav been generated.
;
1$:	MOVPSL	-(SP)			; Put current PSL on stack
	BICL	#^C<PSL$M_IV>, (SP)	; (SP) = current IV bit
	BICPSW	#PSL$M_IV		; Clear integer overflow bit

; The necessary calculation to produce the reduced argument can require up to
; nine longwords of temporary work space.  This work space will be allocated 
; on the stack.  The work space will be accessed though the use of three 
; registers: R4, R5, and SP.  For the purposes of comments the temporary work 
; space will be referred to as locations T0 though T8.  The stack and its 
; pointers will look something like this:
;
;                       |                    |
;                       |--------------------|
;                   T0: |                    |  <---- SP
;                       |--------------------|
;                   T1: |                    |
;                       |--------------------|
;                   T2: |                    |
;                       |--------------------|
;                   T3: |                    |
;                       |--------------------|
;                   T4: |                    |  <---- R4
;                       |--------------------|
;                   T5: |                    |
;                       |--------------------|
;                   T6: |                    |
;                       |--------------------|
;                   T7: |                    |
;                       |--------------------|
;                   T8: |                    |  <---- R5
;                       |--------------------|
;                       |                    |
;
; The following code allocates the storage and sets up the pointers.

	SUBL	#36, SP			; Allocate 9 longwords on the stack
	ADDL3	#16, SP, R4		; R4 points to T4
	ADDL3	#32, SP, R5		; R5 points to T8

;
; Get C'' = C(0):C(1):C(2):C(3) in T5/T8.  C(0) though  C(3) are unsigned 
; integers generated from the binary representation of C.  The high three bits 
; of C(0) are the the first three bits to the left of the binary point of C.  
; The remaining bits C(0) and C(1) though C(3) are the first 125 bits to the 
; right of the binary point of C. Note that the C(i)'s are adjusted to
; compensate for their signed (rather than unsigned) interpretation in the EMUL
; instruction.  Note also that the representation of C has no more than 15 
; consequtive ones, so that no carry is possible from the adjustment.
;

	ADDL3	#12, R4, R7		; Initailize loop counter.  R7 points
					;   to T7
	ASHQ	R3, (R2), (R7)		; Shift the proper quadword so that
					;   T8 has C(0)in it
	SUBL	#4, R7			; R7 points to T6
2$:	SUBL	#4, R2			; R2 points to next quadword in 
					;    MTH$AL_4_OV_PI_V table
	ASHQ	R3, (R2), (R7)		; Shift quadword so that C(n) is in
					;   T(8-n) , n = 0,1,2,3
	BGEQ	3$			; Check for high bit of C(n) set
	INCL	8(R7)			; Bit set.  Adjust C(n-1)
3$:	ACBL	R4, #-4, R7, 2$		; Loop until C(0) though C(3) are in
					;   T5 though T8

;
; Generate the low 128 bits of the product K*C'' = L.  This product is 
; equivalent to multiplying K times C'' modulo 8.  The result of the 
; product is in T4/T7 with bits 31:29 of T4 the octant bits, and the remaining
; 125 bits the faction bits of the product.  The last 53 fraction bits (bits
; 20:0 of T6 and 31:0 of T5) are non-valid fraction bits that will be used 
; later if more fraction bits need to be generated.
;
;
; Multiply the high order bits of K (R0) times C'' and store the result in
; T0/T2.

	EMUL	R0, 4(R4), #0, (SP)	; T0/T1 = KHI*C(3)
	EMUL	R0, 8(R4), 4(SP), 4(SP)	; T0/T2 = KHI*[C(2):C(3)]
	MULL3	R0, 12(R4), (R4)	; T4 = Low 32 bits of KHI*C(1)
	ADDL	(R4), 8(SP)		; T0/T2 = KHI*C'' modulo 8

; Multiply the low order bits of K (R1) times C'' and store the result in
; T4/T8.

	EMUL	R1, 4(R4), #0, (R4)	; T4/T5 = KLO*C(3)
	EMUL	R1, 8(R4), 4(R4), 4(R4)	; T4/T6 = KLO*[C(2):C(3)]
	EMUL	R1, 12(R4), 8(R4), 8(R4); T4/T7 = KLO*[C(1):C(2):C(3)]
	MULL	R1, (R5)		; T8 = KLO*C(0)
	ADDL	(R5), 12(R4)		; T4/T7 = KLO*C'' modulo 8

; Add KHI*C'' to KLO*C'' to get K*C''.  Store the result in T4/T7.

	ADDL	(SP), 4(R4)		;
	ADWC	4(SP), 8(R4)		;
	ADWC	8(SP), 12(R4)		; T4/T7 = K*C'' modulo 8

;
; At this point there may or may not be enough valid bits in R3/R4 to generate
; Y.  If the first 12 fratction bits are all 1's or 0's, there a possibility of 
; loss of significance when computing Y.  Consequently, we must check for loss 
; of significance before converting T4/T7 to Y and I.
;

	ADDL3	#^X8000, -4(R5), (R5)	; If the first 14 fraction bits are 1's
	BITL	#^X3FFF0000, (R5)	;   and the reduced arg = 1-f or the 
	BNEQ	CONVERT			;   first 14 bits are 0 and the reduced
					;   arg = f, then (and only then) bits
					;   29:16 are 0 and significance will
					;   be lost.

;
; More bits need to be generated to cover the loss of significance.  There are 
; not enough registers to hold all the potential entra bits, so that the bits
; already generated must be put on the stack.
;

	JSB	GEN_MORE_BITS		; Generate 85 additional bits and add
					;   them to existing bits.  Results are
					;   stored in T3/T7
	SUBL	#4, R4			; Adjust R4 to reflect the addition of 
					;   another longword of K*C''
	BBS	#29, -4(R5), 4$		; Check if loss of significance is due 
					;   to leading ones or zeros

; Lost significance due to leading zeros

	FFS	#0, #15, 16(R4), (R5)	; If at least one bit is set.  This 
	BNEQ	CONVERT			;   means lost significance was minor.
	CMPL	#^XEFFFFFF, 12(R4)	; If one of the five high bits is set,
	BLEQ	CONVERT			;   lost significance was minor.
	BRW	LEADING_ZEROS

; Lost significance due to leading ones

4$:	FFC	#0, #15, 16(R4), (R5)	; If at least one bit is clear. This 
	BNEQ	CONVERT			;   meanslost significance was minor.
	CMPL	#^XF8000000, 12(R4)	; If one of the five high bits is 
	BGEQU	CONVERT			;   clear, lost significance was minor.
	BRB	LEADING_ONES

;
; Convert bit string to double precion reduced argument.
;

CONVERT:

;    Isolate octant bits and convert low order bits to H-format.

	EXTZV	#29, #3, -4(R5), (R5)	; T8 = octant bits
	BICL	#^XE0000000, -4(R5)	; Clear octant bits
	SUBL3	#12, R5, R4		; R4 points to low order bits of h
	JSB	CVT_LONG_TO_H		; R0/R3 = 2^29*h
	SUBW	#^X1D, R0		; R0/R3 = h
	BLBC	(R5), 1$		; Check for odd or even octant bits

;    Octant bits are odd.  Reduced argument equals 1 - h.

	SUBH3	R0, #1, R4		; R4/R7 = Y = 1 - h
	MOVL	32(SP), R2		; R2 = octant bits
	BRW	RESTORE

;    Octant bits are even.  Reduced argument equals h

1$:	MOVO	R0, R4			; R4/R7 = Y
	MOVL	32(SP), R2		; R2 = octant bits
	BRW	RESTORE



;
; At this point it has been determined that there is a major loss of 
; significance and the processing begins a looping phase.  Each iteration of
; the loop will generate additional extra bits of K*C' until enough significant
; bits to compute Y are available.  During this time the nine longwords
; allocated on the stack will be used as follows:
;
;       T0/T2   Temporary storage used when generating extra bits.
;
;       T3/T7   Contains all significant bits generated so far.
;
;       T8      Contains a counter, W, indicating the appropriate exponent
;                 of the last longword of fraction bits used in converting 
;                 to Y.

LEADING_ONES:

; If processing continues here it is known that the loss of significance is due
; to a string of leading ones.

	MOVL	#L_INT_WEIGHT, (R5)	; T8 = exp bias for last longword
					;    of the product K*C'

LOOP_1:	CMPL	#^XFFFF0000, 12(R4)	; Check for enough significant bits
	BGTRU	CONVERT_1		; Enough bits.  Convert to floating.
	JSB	GEN_MORE_BITS		; T2/T7 contains K*C''
	CMPL	#-1, 12(R4)		; Check for all 1's
	BGTRU	CONVERT_1		; Not all 1's.  Enough precision bits
					;    to compute Y
	MOVO	-4(R4), (R4)		; Compress representation of K*C''
	ACBW	#W_MAX_WEIGHT, #W_TERM_WEIGHT, (R5), LOOP_1
					; Increment weighting factor.  If 
					;   weighting factor is greater than 
					;   1024 then no more bits need to be 
					;   generated.
					
;
; The weighting factor is greater than 1024.  This means that the reduced
; argument is either not distinguishable from 1 or too small to be represented
; in F-format (i.e. underflow.)  Zero is returned in R4 for the reduced
; argument to signal this occurance.  Note that under these conditions the
; correct function value is one of the values 0, +/-1.  The
; correct choice is determined by the calling program based on the octant bits
; returned in R1.
;
	CLRL	R3			; Reduced argument is zero
	EXTZV	#29, #3, 8(SP), R2	; R2 = octant bits
	BRW	RESTORE


CONVERT_1: 
	ADDL	#4, R4			; R4 points to low bits of h
	JSB	CVT_LONG_TO_H		; R0/R3 = 2^W*h
	SUBH3	R0, H_2_TO_32, R4	; R4/R7 = 2^W*(1 - h)
	EXTZV	#29, #3, 28(SP), R2	; R2 = octant bits
	SUBL	32(SP), R4		; R4/R7 = Y = 1 - h
	BRB	RESTORE


LEADING_ZEROS:


; If processing continues here it is known that the loss of significance is due
; to a string of leading zeros.  Note that it is known that the loop for 
; leading zeros will terminate before an underflow condition occurs so that the
; loop does not include a test for underflow.

	MOVL	#L_INT_WEIGHT, (R5)	; T8 = exp bias for last longword
					;    of the product K*C'

LOOP_0: CMPL	#^X0000FFFF, 12(R4)	; Check enough fraction bits
	BLSS	CONVERT_0		; Enough bits.  Convert to floating
	JSB	GEN_MORE_BITS		; T2/R7 contain K*C''
1$:	TSTL	12(R4)			; Check for all 0's
	BNEQ	CONVERT_0		; Not all 0's.  Enough precision bits.
	MOVQ	-4(R4), (R4)		; Compress representation of K*C''
	ADDW	#W_TERM_WEIGHT, (R5)	; Increment weighting factor.  
	BRB	LOOP_0

CONVERT_0:
	ADDL	#4, R4			; R4 points to low bits of h
	JSB	CVT_LONG_TO_H		; R0/R3 = 2^W*h
	MOVO	R0, R4			; R4/R7 = 2^W*h
	EXTZV	#29, #3, 28(SP), R2	; R2 = octant bits
	SUBL	32(SP), R4		; R4/R7 = Y = h
	BRB	RESTORE


RESTORE:
	BISPSW	36(SP)			; Restore IV bit and exit
	ADDL	#40, SP			; Remove mask and temporary storage 
					;   from stack
	RSB

GEN_MORE_BITS:

;
; This subroutine generates 85 extra fraction bits and puts them to the
; existing bits.  NOTE:  This routine is always entered via a JSB instruction.
; Consequently, SP points to the first longword BEFORE T0, rather than T0
; itself.
;

	SUBL	#4, R2			; Adjust pointer to get next quadword
					;   from MTH$AL_4_OV_PI_V
	ASHQ	R3, (R2), R6		; R7 = C(n)
	BGEQ	1$			; Branch if high bit is clear

; Logic to process unsigned values greater than 2^31 - 1

	EMUL	R1, R7, #0, 4(SP)	; 
	ADDL	R1, 8(SP)		; T0/T1 = KLO*C(n)
	EMUL	R0, R7, 8(SP), 8(SP)	;
	ADDL	R0, 12(SP)		; T0/T2 = K*C(n)
	BRB	2$

; Logic to process unsigned values less than 2^31

1$:	EMUL	R1, R7, #0, 4(SP)	; T0/T1 = KLO*C(n)
	EMUL	R0, R7, 8(SP), 8(SP)	; T0/T2 = K*C(n)

; Add new bits to old

2$:	ADDL	8(SP), (R4)		;
	ADWC	12(SP), 4(R4)		;
	BCC	3$			; Check for carry from previous add
	INCL	8(R4)			; Propagate carry
	BCC	3$			; Check for carry from previous add
	INCL	12(R4)			; Propagate carry
3$:	MOVL	4(SP), -4(R4)		; Move new low order bits to end of
					;   of old low order bits
	RSB				;





CVT_LONG_TO_H:

;
; This routine converts an array of three longword pointed to by R4 H format.
; The result is returned in R0/R3.  NOTE:  This routine is always entered via 
; a JSB instruction.  Consequently, SP points to the first longword BEFORE T0,
;  rather than T0 itself.
;
	ADDL3	#4, SP, R6		; R6 points to T0
	CVTLH	(R4)+, R0		; R0/R3 = low 32 bits of h
	BGEQ	1$			; Check for signed conversion error
	INCL	(R4)			;   and adjust  accordingly
	BCC	1$			; If necessary,
	INCL	4(R4)			;    propogate carry
1$:	SUBW	#W_TERM_WEIGHT, R0	; R0/R3 = (low 32 bits of h)/2^32
	CVTLH	(R4)+, (R6)		; T0/T3 = 2nd lowest 32 bits of h
	BGEQ	2$			; Check for signed conversion error
	INCL	(R4)			;   and adjust  accordingly
2$:	ADDH2	(R6), R0		; R0/R3 = (low 64 bits of h)/2^32
	SUBW	#W_TERM_WEIGHT, R0	; R0/R3 = (low 64 bits of h)/2^64
	CVTLH	(R4)+, (R6)		; T0/T3 = 3rd lowest 32 bits of h
	BGEQ	3$			; Check for signed conversion error
	ADDH2	H_2_TO_32, (R6)		;   and adjust  accordingly
3$:	ADDH2	(R6), R0		; R0/R3 = (low 96 bits of h)/2^64
	RSB


	.SBTTL	REDUCE_DEGREES

; This routine assumes that the absolute value of the argument is in R0/R1.
; The reduction process is performed in two stages.  The first stage of 
; the reduction reduces the argument modulo 360 to a value less that 2^53, 
; and the second stage reduces the argument modulo 45 to a value less than 45.

; Constants used in this reduction:
;

POWER_MOD_360_0:	; Powers of 2 modulo 360 for t1 = 0
	.WORD	  1,	  2,	  4,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248

POWER_MOD_360_1:	; Powers of 2 modulo 360 for t1 <> 0
	.WORD	136,	272,	184,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248



REDUCE_DEGREES:
	CMPW	#^X4360, R0		; Compare |x| with 2^53
	BGTR	LAST_STEP		; Branch to special logic for med arg

;
; It is assumed here that the argument is greater than 2^53.
;
; The argument is reduced as follows:
;     Let x = 2^t*f, where t > 53 and 1/2 =< f < 1.  And let J = 2^53*f = 
;     2^30*J1 + J2 and K = 2^(t-53).  Since 2^30 = 64 modulo 360, we have that
;     J = 64*J1 + J2 modulo 360.  Now let t' = t - 53 = 12*t1 + t2.  Note that
;     (2^12)^2 = (2^9)*(2^15) = (2^9)*(2^3) = 2^12 modulo 360.  Hence, if t1 is
;     not zero, K = 2^t' = 2^(12*t1+t2) = (2^12)*(2^t2) = 136*2^t2 modulo 360.
;     For t1 = 0 K = 2^t2.  Consequently, define K' congruent to 2^t2 if t1 = 0
;     and congruent to 136*2^t2 otherwise, where 0 =< K' < 360.  Then x' =
;     K'*(8*J1 + J2) is congruent to s modulo 360 and x' < 2^53.

	MOVL	R0, R2			; R2 = high longword of X
	BICL	#^X7FF0, R0		; Clear exp bits of X
	BISW	#^X4350, R0		; R0/R1 = J
	SUBL	R0, R2			; R2 = t'*2^7

	MOVQ	R0, R3			; R3/R4 = J
	BICL	#^XFFFF3FFF, R1		; R0/R1 = J1*2^30
	SUBG2	R0, R3			; R3/R4 = J2
	SUBW	#^X180, R0		; R0/R1 = 64*J1
	ADDG2	R3, R0			; R0/R1 = 64*J1 + J2 = J modulo 45

	ROTL	#-4, R2, R2		; R2 = t'
	DIVW3	#12, R2, R3		; R3 = t1
	MULW	#12, R3			; R3 = 12*t1
	SUBW	R3, R2			; R2 = t2

	TSTW	R3			; Check for t1 = 0 and choose K'
	BNEQ	1$			;   accordingly
	CVTWG	POWER_MOD_360_0[R2], R2	; R2/R3 = K'
	BRB	2$			;
1$:	CVTWG	POWER_MOD_360_1[R2], R2	; R2/R3 = K'
2$:	MULG2	R2, R0			; R0/R1 = X' (mod 45) 0 =< R0 < 2^53


LAST_STEP:
;
; Argument reduction scheme for arguments with absolute value less than 2^53
;
; The reduced argument Y is computed as follows:
;    Let I = int(X/45)
;       if I is even
;          then Y = X - 45*I
;          else Y = (I+1)*45 - x

	CMPW	#^X4240, R0		; Compare 2^36 with |X|
	BGEQ	NO_OVERFLOW		;
	MULG3	G_1_OV_45, R0, R6	; R6/R7 = |X|/45

;
; Turn off IV to avoid an exception in EMODG
;
	MOVPSL	R2			; Move PSL to R2
	BICL	#^C<PSL$M_IV>, R2	; Save current IV bit
	BICPSW	#PSL$M_IV		; Turn off integer overflow trap

	EMODG	#1, #0, R6, R3, R4	; R3 = low 32 integer bits of |X|/45
					; R4/R5 = fractional part of |X|/45

	BISPSW	R2			; Restore IV bit

	SUBG2	R4, R6			; R6/R7 = Integer part of |X|/45 = I
	BLBC	R3, EVEN		;
	ADDG2	#1, R6			; R6/R7 = I + 1	
	BRB	ODD


NO_OVERFLOW:
	EMODG	G_1_OV_45, #X_1_OV_45, R0, R3, R4
					; R3 = I = integer part of |X|/45
	BLBC	R3, CVT			; Branch if octant bits are even
	ADDL3	#1, R3, R6		; R6 = I + 1
	CVTLG	R6, R6			; R6/R7 = I + 1
ODD:	MULG2	G_45, R6		; R6/R7 = 45*(I+1)
	SUBG2	R0, R6			; R6/R7 = Y
	BICB	#^XF8, R3		; Save only last three octant bits
	RSB

CVT:	CVTLG	R3, R6			; R6/R7 = I
EVEN:	MULG2	G_M45, R6		; R6/R7 = -45*I
	ADDG2	R0, R6			; R6/R7 = Y
	BICB	#^XF8, R3		; Save only last three octant bits
	RSB



	.SBTTL	RADIAN_POLYNOMIALS	; Polynomials for arguments in radians



;
; Polynomial evaluation for GCOS(Y) for Y in radians
;

P_COS_R:
	BICW	#^X8000, R4		; R4/R7 = |Y|
	CMPW	#^X4000, R4		; Compare 1/2 with |Y|
	BGTR	LESS_THAN_HALF			; Sufficent overhang is available
NEEDS_DOUBLE:
	MULH2	R4, R4			; R4/R7 = Y^2
	MOVQ	R4, -(SP)		; Save high half of Y^2
NEEDS_DOUBLE_SINCOS:
	CVTHG	R4, R4			; R4/R5 = Y^2
	POLYG	R4, #COSLENR2-1, COSTBR2; R0/R1 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y^2
	DECW	R4			; R4/R7 = Y^2/2
	SUBH2	#1, R4			; R4/R7 = Y^2/2 - 1
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	SUBH2	R4, R0			; R0/R3 = GCOS(Y)
	CVTHG	R0, R0			; R0/R1 = GCOS(Y)
	RSB
LESS_THAN_HALF: 
	CVTHG	R4, R6			; R6/R7 = |Y|
	MULG2	R6, R6			; R6/R7 = Y^2
	POLYG	R6, #COSLENR1-1, COSTBR1; R0/R1 = GCOS(Y)
	RSB


;
; Polynomial evaluation for -GCOS(Y)
;

N_COS_R:
	BICW	#^X8000, R4		; R4/R7 = |Y|
	CMPW	#^X4000, R4		; Compare 1/2 with |Y|
	BGTR	1$			; Sufficent overhang is available
	MULH2	R4, R4			; R4/R7 = Y^2
	MOVQ	R4, -(SP)		; Save high half of Y^2
	CVTHG	R4, R4			; R4/R5 = Y^2 in G-format
	POLYG	R4, #COSLENR2-1, COSTBR2; R0/R1 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y^2
	DECW	R4			; R4/R7 = Y^2/2
	SUBH2	#1, R4			; R4/R7 = -(1 - Y^2/2)
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	SUBH2	R0, R4			; R4/R7 = -GCOS(Y)
	CVTHG	R4, R0			; R0/R1 = -GCOS(Y)
	RSB

1$:	CVTHG	R4, R6			; R6/R7 = |Y|
	MULG2	R6, R6			; R6/R7 = Y^2
	POLYG	R6, #COSLENR1-1, COSTBR1; R0/R1 = GCOS(Y)
	XORW	#^X8000, R0		; R0/R1 = -GCOS(Y)
	RSB

;
; Polynomial evaluation for -GSIN(Y)
;

N_SIN_R:
	XORW	#^X8000, R4

;
; Polynomial evaluation for GSIN(Y)
;

P_SIN_R:
	MOVQ	R4, -(SP)		; Save high half of Y
	CVTHG	R4, -(SP)		; Save Y in G-format
	MULG3	(SP), (SP), R4		; R4 = Y^2
	POLYG	R4, #SINLENR-1, SINTBR	; R0/R1 = P(Y^2)
	MULG2	(SP)+, R0		; R0/R1 = Y*P(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y
	CVTGH	R0, R0			; R0/R3 = Y*P(Y^2)
	ADDH2	R4, R0			; R0/R3 = GSIN(Y)
	CVTHG	R0, R0			; R0/R1 = GSIN(Y)
	RSB




	.SBTTL	CYCLE_POLYNOMIALS	; Polynomials for arguments in cycles



;
; Polynomial evaluation for GCOS(Y) for Y in cycles
;

P_COS_C:
	CMPH	H_2_OV_PI, R4		; Compare 2/pi with |Y|
	BGEQ	1$			; Sufficent overhang is available
	MULH2	R4, R4			; R4/R7 = Y^2
	MOVQ	R4, -(SP)		; Save high half of Y^2
	CVTHG	R4, R4			; R4/R5 = Y^2
	POLYG	R4, #COSLENC2-1, COSTBC2; R0/R1 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y^2
	SUBW	#2, R4			; R4/R7 = Y^2/4
	SUBH2	#1, R4			; R4/R7 = Y^2/4 - 1
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	SUBH2	R4, R0			; R0/R3 = GCOS(Y)
	CVTHG	R0, R0			; R0/R1 = GCOS(Y)
	RSB

1$:	CVTHG	R4, R6			; R6/R7 = |Y|
	MULG2	R6, R6			; R6/R7 = Y^2
	POLYG	R6, #COSLENC1-1, COSTBC1; R0/R1 = GCOS(Y) - 1
	ADDG2	#1, R0			; R0/R1 = GCOS(Y)
	RSB


;
; Polynomial evaluation for -GCOS(Y)
;

N_COS_C:
	BICW	#^X8000, R4		; R4/R7 = |Y|
	CMPH	H_2_OV_PI, R4		; Compare 2/pi with |Y|
	BGEQ	1$			; Sufficent overhang is available
	MULH2	R4, R4			; R4/R7 = Y^2
	MOVQ	R4, -(SP)		; Save high half of Y^2
	CVTHG	R4, R4			; R4/R5 = Y^2
	POLYG	R4, #COSLENC2-1, COSTBC2; R0/R1 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y^2
	SUBW	#2, R4			; R4/R7 = Y^2/4
	SUBH2	#1, R4			; R4/R7 = -(1 - Y^2/4)
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	SUBH2	R0, R4			; R4/R7 = -GCOS(Y)
	CVTHG	R4, R0			; R0/R1 = -GCOS(Y)
	RSB

1$:	CVTHG	R4, R6			; R6/R7 = |Y|
	MULG2	R6, R6			; R6/R7 = Y^2
	POLYG	R6, #COSLENC1-1, COSTBC1; R0/R1 = GCOS(Y) - 1
	SUBG3	R0, G_M1, R0		; R0/R1 = -GCOS(Y)
	RSB

;
; Polynomial evaluation for -SIN(Y)
;

N_SIN_C:
	XORW	#^X8000, R4		; R4/R7 = - Y

;
; Polynomial evaluation for GSIN(Y)
;

P_SIN_C:
	MOVO	R4, -(SP)		; Save argument in H format
	CVTHG	R4, -(SP)		; Save argument in G format
	MULG3	(SP), (SP), R4		; R4/R5 = Y^2
	POLYG	R4, #SINLENC-1, SINTBC	; R0/R1 = P(Y^2)
	MULG2	(SP)+, R0		; R0/R1 = Y*P(Y^2)
	MOVQ	(SP), R4		; R4/R7 = Y
	SUBW	#2, (SP)		; (SP) = Y/4
	SUBH2	(SP)+, R4		; R4/R7 = 3/4*Y
	CVTGH	R0, R0			; R0/R3 = Y*P(Y^2)
	ADDH2	R4, R0			; R0/R3 = GSIN(Y)
	CVTHG	R0, R0			; R0/R1 = GSIN(Y)
	RSB


	.SBTTL	DEGREE_POLYNOMIALS


P_COS_D:
	CMPG	G_90_OV_PI, R6		; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	CVTGH	R6, R4			; R4/R7 = Y
	MULH2	R4, R4			; R4/R7 = Y^2
	MOVQ	R4, -(SP)		; Save high half of Y^2
	CVTHG	R4, R4			; R4/R5 = Y^2
	POLYG	R4, #COSDLN1, COSDTB1	; R0/R1 = Q(Y^2) 
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4/R7 = Y^2
	SUBW	#13, R4			; R4/R7 = Y^2/2^13
	CMPL	#^X1000, R7		; Check for loss of significanc when
	BGTRU	1$			;    subtracting 1 and adjust
	MOVO	R4, -(SP)		; Save Y^2/2^13 on stack
	BICL	#^XFFFF0000, R7		; R4/R7 = High order bits of Y^2/2^13
	SUBH2	R4, (SP)		; (SP) = Low order bits
	SUBH2	(SP)+, R0		; R0/R3 = Q(Y^2) - low bits of Y^2/2^13
1$:	SUBH2	#1, R4			; R4/R7 = -(1 - Y^2/2^13)
	SUBH2	R4, R0			; R0/R3 = GCOS(Y)
	CVTHG	R0, R0			; R0/R1 = GCOS(Y)
	RSB

2$:	MULG2	R6, R6			; R6/R7 = Y^2
	BEQL	3$			; Check for Y = 0
	POLYG	R6, #COSDLN2, COSDTB2	; R0/R1 = Q(Y^2)
	RSB

3$:	MOVG	#1, R0			; R0/R1 = GCOS(Y)
	RSB


N_COS_D:
	CMPG	G_90_OV_PI, R6		; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	CVTGH	R6, R4			;
	MULH2	R4, R4			; R4/R7 = Y^2
	MOVQ	R4, -(SP)		;
	CVTHG	R4, R4			; R4/R5 = Y^2
	POLYG	R4, #COSDLN1, COSDTB1	; R0/R1 = Q(Y^2)
	CVTGH	R0, R0			; R0/R3 = Q(Y^2)
	MOVQ	(SP)+, R4		; R4
	SUBW	#13, R4			; R4/R7 = Y^2/2^13
	CMPL	#^X1000, R7		; Check for loss of significanc when
	BGTRU	1$			;    subtracting 1 and adjust
	MOVO	R4, -(SP)		; Save Y^2/2^13 on stack
	BICL	#^XFFFF0000, R7		; R4/R7 = High order bits of Y^2/2^13
	SUBH2	R4, (SP)		; (SP) = Low order bits
	SUBH2	(SP)+, R0		; R0/R3 = Q(Y^2) - low bits of Y^2/2^13
1$:	SUBH2	#1, R4			; R4/R7 = -(1 - Y^2/2^13)
	SUBH2	R0, R4			; R4/R7 = -COS(Y)
	CVTHG	R4, R0			; R0/R1 = -GCOS(Y)
	RSB

2$:	MULG2	R6, R6			; R6/R7 = Y^2
	BEQL	3$			; Check for Y = 0
	POLYG	R6, #COSDLN2, COSDTB2	; R0/R1 = GCOSD(Y)
	XORW	#^X8000, R0		; R0/R1 = -GCOSD(Y)
	RSB

3$:	MOVG	G_M1, R0		; R0/R1 = GCOS(Y)
	RSB

N_SIN_D:
	MNEGG	R6, R6			; R6/R7 = -Y
P_SIN_D:
	MULG3	R6, R6, R0		; R0/R1 = Y^2
	BEQL	RETURN
	POLYG	R0, #SINDLN, SINDTB	; R0/R1 = P(Y^2)
	MULG2	R6, R0			; R0/R1 = Y*P(Y^2)
	SUBW	#^X60, R6		; R6/R7 = Y/2^6
	ADDG2	R6, R0			; R0/R1 = GSIN(Y)
RETURN:	RSB




	.SBTTL	DEGENERATE_SOLUTIONS

P_ONE:
	MOVG	#1, R0			; Answer is 1
	RSB


N_ONE:
	MOVG	G_M1, R0		; Answer is -1
	RSB


UNFL:
;
; Underflow; if user has FU set, signal error.  Always return 0.0
;
	MOVPSL	R2			; R2 = user's or jacket routine's PSL
	CALLS	#0, G^MTH$$JACKET_TST	; R0 = TRUE if JSB from jacket routine
	BLBC	R0, 10$			; branch if user did JSB
	MOVZWL	SF$W_SAVE_PSW(FP), R2	; get user PSL saved by CALL
10$:	CLRL	R0			; R0 = result. LIB$SIGNAL will save in
					; CHF$L_MCH_R0/R1 so any handler can 
					;   fixup
	BBC	#6, R2, 20$		; has user enabled floating underflow?
	PUSHL	(SP)			; yes, return PC from special routine
	MOVZBL	#MTH$K_FLOUNDMAT, -(SP)	; trap code for hardware floating 
					;   underflow convert to MTH$_FLOUNDMAT
					;   (32-bit VAX-11 exception code)
	CALLS	#2, G^MTH$$SIGNAL	; signal (condition, PC)
20$:	RSB				; return

	.END
