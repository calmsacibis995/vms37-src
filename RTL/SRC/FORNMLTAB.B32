%TITLE 'FOR$$NML_TABLES - TPARSE state tables for NAMELIST input'
MODULE FOR$$NML_TABLES (			! TPARSE tables for NAMELIST
		IDENT = '1-009'			! File: FORNMLTAB.B32 Edit: SBL1009
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	FORTRAN Language Support
!
! ABSTRACT:
!
!	This module contains the LIB$TPARSE state tables used in
!	implementing FORTRAN NAMELIST input.  It also contains the
!	action routines associated with the state tables.
!
! ENVIRONMENT:	User mode - AST reentrant
!
! AUTHOR: Steven B. Lionel, CREATION DATE: 10-July-1980
!
! MODIFIED BY:
!
! 1-001	- Original.  SBL 10-July-1980
! 1-002 - Disallow superfluous commas.  SBL 18-Nov-1980
! 1-003 - Reflect change in group block spec so that number-of-variables is
!	  a word; second word is reserved.  SBL 5-Dec-1980
! 1-004 - Don't require a delimiter before ending $ or &.  These characters can
!	  no longer be a part of a logical constant.  SBL 17-Dec-1980
! 1-005 - Allow repeated nulls of the form "r*".  Don't consider repeated values
!	  as candidates for being identifiers.  Add comments.  SBL 2-Mar-1981
! 1-006 - Add text describing the NAMELIST descriptor block.  Disallow an array
!	  substring without a subscript.  SBL 15-April-1981
! 1-007 - Change to use new OTS$CVT_T_F routine.  SBL 15-April-1981
! 1-008 - Also use OTS$CVT_T_F in STORE_COMPLEX.  SBL 5-June-1981
! 1-009 - Use new ONE_OF macro where necessary.  SBL 18-Dec-1981
!--


%SBTTL 'Declarations'
!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';			! Linkage definitions


LINKAGE
    JSB_COMPARE_UPCASE = JSB (REGISTER=4, REGISTER=5) :
			 NOPRESERVE (0,1,2,3,4) NOTUSED (6,7,8,9,10,11);

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    NEXT_RECORD,			! Read another record
    LOOKUP_IDENTIFIER,			! Lookup identifier
    SUBSTRING_COLON,			! Process colon in substring
    INIT_SUBS,				! Start a subscript/substring
    STORE_SUBS,				! Store a subscript/substring
    END_SUBSCRIPT,			! End a subscript
    END_SUBSTRING,			! End a substring
    CONVERT_INTEGER,			! Convert a decimal integer
    STORE_LOGICAL,			! Store a logical into CONSBLOCK
    STORE_REAL,				! Store a real value into CONSBLOCK
    STORE_COMPLEX,			! Store a complex value into CONSBLOCK
    STORE_REPEAT,			! Store repeat count
    END_REPEAT,				! End a repeated value
    STORE_CHARACTER,			! Store a character string character
    END_CHARACTER,			! End a character string
    STRING_OK,				! Is a string value ok?
    STORE_VALUE,			! Store a value
    NULL_VALUE,				! Skip an element
    SET_VALUE_IDENT,			! Indicate last value was an identifier
    WAS_VALUE_IDENT,			! Lookup last value token as an identifier
    SYNTAX_ERROR,			! Signal a syntax error
    INVREFVAR_ERROR,			! Signal invalid ref to variable error
    BLANKS_OFF,				! Turn explicit blanks off
    BLANKS_ON,				! Turn explicit blanks on
    COMPUTE_INDEX,			! Compute the subscript index
    COMPARE_UPCASE: JSB_COMPARE_UPCASE;	! Compare strings upcased

!
! INCLUDE FILES:
!

LIBRARY 'RTLSTARLE';				! STARLET.L32 system definitions

LIBRARY 'RTLTPAMAC';				! TPARSE library of macros

REQUIRE 'RTLIN:RTLPSECT';			! Define PSECT declarations macros

REQUIRE 'RTLIN:FORNML';				! NML$ definitions

REQUIRE 'RTLML:OTSLUB';				! LUB$ definitions

!
! MACROS:
!

REQUIRE 'RTLIN:OTSMAC';				! Useful macros

!
! EQUATED SYMBOLS:
!

LITERAL
    SINGLE_QUOTE = 39,				! ASCII value for "'"
    K_NULL = 0,					! Constant type for null value
    K_LOGICAL = 1,				! Constant type for logical
    K_INTEGER = 2,				! Constant type for integer
    K_REAL = 3,					! Constant type for real
    K_COMPLEX = 4,				! Constant type for complex
    K_CHARACTER = 5;				! Constant type for character

!
! FIELDS:
!
!	NONE
!
! PSECTS:
!
DECLARE_PSECTS (FOR);				! Declare PSECTs for FOR$ facility
!
! OWN STORAGE:
!
!	NONE
!
! BUILTIN DECLARATIONS:
!
BUILTIN
    CALLG,
    INDEX;

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    FOR$$CVT_TYPE,			! Convert a value to destination type
    FOR$$REC_RSN0: JSB_REC0,		! Read a record
    FOR$$SIGNAL_STO: NOVALUE,		! Signal fatal error
    OTS$CVT_TI_L,			! Convert decimal to longword
    OTS$CVT_TL_L,			! Convert logical to longword
    OTS$CVT_T_F,			! Convert text to F_floating
    OTS$CVT_T_D,			! Convert text to D_floating
    OTS$CVT_T_G,			! Convert text to G_floating
    OTS$CVT_T_H,			! Convert text to H_floating
    LIB$SIG_TO_RET;			! Convert signal to return value

EXTERNAL LITERAL
    FOR$_INVARGFOR,			! Invalid argument to FORTRAN RTL
    FOR$_INVREFVAR,			! Invalid reference to NAMELIST variable
    FOR$_TOOMANVAL,			! Too many values in NAMELIST input
    FOR$_INPCONERR,			! Input conversion error
    FOR$_SYNERRNAM;			! Syntax error in NAMELIST input

!<BLF/PAGE>

!++
!   Each NAMELIST descriptor block has the following form:
!
!         3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
!         1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
!
!        +---------------------------------------------------------------+
!     0  |            Address of ASCIC name of NAMELIST group            |
!        +---------------------------------------------------------------+
!     1  |           Reserved           |   Count of NAMELIST variables  |
!        +---------------------------------------------------------------+
!     2  |              Address of ASCIC name of variable 1              |
!        +---------------------------------------------------------------+
!     3  |       Address of standard VAX descriptor for variable 1       |
!        +---------------------------------------------------------------+
!     4  |                              ...                              |
!        +---------------------------------------------------------------+
!     5  |              Address of ASCIC name of variable n              |
!        +---------------------------------------------------------------+
!     6  |       Address of standard VAX descriptor for variable n       |
!        +---------------------------------------------------------------+
!
!
!   The NAMELIST group name and the variable names which are pointed to in
!   the  NAMELIST  descriptor  block  are  upper  case  only.  The FORTRAN
!   compiler or other calling program is responsible for  case  conversion
!   of the name strings.  In NAMELIST input data, case is significant only
!   in character literals.  The run-time library is responsible  for  case
!   conversion of NAMELIST input data.
!   
!   The allowable data types in variable descriptors are  BU  (BYTE),  WU,
!   LU,  W,  L,  F,  D, G, H, T, FC, DC, and GC.  The allowable descriptor
!   classes are scalar and array.  For the  array  class  descriptor,  the
!   descriptor  flags  COLUMN,  COEFF,  and BOUNDS must be set, indicating
!   column-major order and the presence of coefficient and bounds  blocks.
!   The number of dimensions must not exceed 7.
!--

!<BLF/PAGE>

%SBTTL 'FOR$$NML_TABLES - TPARSE tables for NAMELIST input'

!++
! FUNCTIONAL DESCRIPTION:
!
!	The following are the state tables used to perform FORTRAN
!	NAMELIST input.
!
!--

$INIT_STATE (FOR$$A_NMLSTATE, FOR$$A_NMLKEYWD);

!+
! Main scanning loop.  Look for assignments.
! If a $ or & is found, terminate the statement.
!-
$STATE (BEGIN_SCAN,
    (TPA$_EOS, BEGIN_SCAN, NEXT_RECORD),
    ('$', TPA$_EXIT),
    ('&', TPA$_EXIT),
    ((ASSIGNMENT), BEGIN_SCAN, BLANKS_OFF),
    (TPA$_LAMBDA, ERROR_STATE)
    );

!+
! An assignment consists of a variable, an equals sign, and a list of values.
!-
$STATE (ASSIGNMENT,
    ((VARIABLE), ASSN_EQL ,BLANKS_OFF),
    (TPA$_LAMBDA, ERROR_STATE)
    );

$STATE (ASSN_EQL,
    (TPA$_EOS, ASSN_EQL, NEXT_RECORD),
    ('=', VALUE_LIST),
    (TPA$_LAMBDA, ERROR_STATE)
    );

!+
! A value list consists of simple values and repeated values, possibly separated
! by commas.  A comma instead of a value indicates an omitted value, where that
! element of the variable should remain unchanged.
!-
$STATE (VALUE_LIST,
    (TPA$_EOS, VALUE_LIST, NEXT_RECORD),
    (',', VALUE_LIST, NULL_VALUE),
    ((REPEATED_VALUE), VALUE_LIST1, BLANKS_ON),
    ((VALUE), VALUE_LIST1, BLANKS_ON),
    (TPA$_LAMBDA, TPA$_EXIT)
    );

!+
! A value has been found.  The next delimiter tells us if that token was really
! a value or was an identifier that looked like a value.
!-
$STATE (VALUE_LIST1,
    (TPA$_EOS, VALUE_LIST2, BLANKS_OFF),
    (TPA$_BLANK, VALUE_LIST2, BLANKS_OFF),
    ((NO_LPAREN), VALUE_LIST2, BLANKS_OFF),	! Succeeds if "(" NOT found
    (TPA$_LAMBDA, TPA$_EXIT, SET_VALUE_IDENT)	! Last token was an identifier
    );

!+
! At this point, the last token was an identifier only if the next significant
! character is an "=".  The other case, a "(", was taken care of in the
! previous state.
!-
$STATE (VALUE_LIST2,
    (TPA$_EOS, VALUE_LIST2, NEXT_RECORD),
    (TPA$_BLANK, VALUE_LIST2),			! Even though explicit blank
						! processing is off, use up
						! blanks in the record to aid
						! error reporting.
    (',', VALUE_LIST, STORE_VALUE),
    ((NO_EQUALS), VALUE_LIST, STORE_VALUE),	! Succeeds if "=" NOT found
    (TPA$_LAMBDA, TPA$_EXIT, SET_VALUE_IDENT)	! Last token was an identifier
    );

!+
! This type of state determines if the next character is "(", without consuming
! the character.  In this case, failure indicates that the desired character
! was found.  This scheme is used in the next, and in other states.
!-
$STATE (NO_LPAREN,
    ('(', TPA$_FAIL),
    (TPA$_LAMBDA, TPA$_EXIT)
    );

$STATE (NO_EQUALS,
    ('=', TPA$_FAIL),
    (TPA$_LAMBDA, TPA$_EXIT)
    );

!+
! A repeated value is of the form n*value, where n is an unsigned integer and
! no delimiters appear on either side of the "*".  A repeated null is of the
! form "n*" where a delimiter follows the "*".
!-

$STATE (REPEATED_VALUE,
    ((DECIMAL_INTEGER), REPEAT2, BLANKS_ON)
    );

$STATE (REPEAT2,
    ('*', REPEAT3, STORE_REPEAT),
    (TPA$_LAMBDA, TPA$_FAIL, BLANKS_OFF)
    );

$STATE (REPEAT3,
    ((VALUE), TPA$_EXIT, END_REPEAT),	! n*c
    ((NOT_DELIM), ERROR_STATE),		! Not n*
    (TPA$_LAMBDA, TPA$_EXIT, BLANKS_OFF)! Is "n*", skipping will be done by STORE_VALUE
    );

!+
! A value can be one of four types.  Integers look like reals, for our purposes.
! This state can fail if the current string isn't matched by any of these patterns.
!-
$STATE (VALUE,
    ((LOGICAL), TPA$_EXIT, STORE_LOGICAL),
    ((REAL), TPA$_EXIT, STORE_REAL),
    ((COMPLEX), TPA$_EXIT),	! Stores are done for each part
    ((CHARACTER), TPA$_EXIT, END_CHARACTER)
    );


!+
! A variable consists of an identifier, followed by an optional subscript,
! followed by an optional substring.  If, while parsing values for the previous
! assignment, it was determined that the last "value" was really an identifier,
! WAS_VALUE_IDENT will retrieve the token from NML$T_TOKEN and call LOOKUP_IDENTIFIER
! itself.  Otherwise, we look for an identifier here.
!-
$STATE (VARIABLE,
    (TPA$_LAMBDA, VARIABLE2, WAS_VALUE_IDENT),	! Fails if last token was not
						! an identifier.  If it succeeds,
						! lookup is done.
    ((IDENTIFIER), VARIABLE2, LOOKUP_IDENTIFIER)
    );

$STATE (VARIABLE2,
    (TPA$_LAMBDA, , BLANKS_ON)
    );

!+
! Look for subscript or substring.
!-
$STATE (SUBSCRIPT_START,
    ('(', SUB_LOOP1, INIT_SUBS),	! Signals error if subscript/substring not ok
    (TPA$_LAMBDA, TPA$_EXIT)
    );

!+
! Get first subscript or first substring.  We can't tell which is which until
! we see the ":".
!-
$STATE (SUB_LOOP1,
    (TPA$_EOS, SUB_LOOP1, NEXT_RECORD),
    (TPA$_BLANK, SUB_LOOP1),
    ((DECIMAL_INTEGER), , STORE_SUBS),
    (':', RIGHT_SUBSTRING, SUBSTRING_COLON),	! Succeeds if substring ok
						! otherwise signals FOR$_INVREFVAR
    (TPA$_LAMBDA, INVREFVAR_STATE)		! Signal FOR$_INVREFVAR
    );

!+
! This state and the next one consist of the loop looking for subscripts.
! if a colon is found, control transfers to the substring processor.
!-
$STATE (SUB_LOOP2,
    (TPA$_EOS, SUB_LOOP2, NEXT_RECORD),
    (TPA$_BLANK, SUB_LOOP2),
    (',', SUB_LOOP3),
    (':', RIGHT_SUBSTRING, SUBSTRING_COLON),	! Succeeds if substring ok
						! otherwise signals FOR$_INVREFVAR
    (')', START_SUBSTRING, END_SUBSCRIPT),
    (TPA$_LAMBDA, ERROR_STATE)
    );

$STATE (SUB_LOOP3,
    (TPA$_EOS, SUB_LOOP3, NEXT_RECORD),
    (TPA$_BLANK, SUB_LOOP3),
    ((DECIMAL_INTEGER), SUB_LOOP2, STORE_SUBS),
    (TPA$_LAMBDA, INVREFVAR_STATE)		! Signal FOR$_INVREFVAR
    );

!+
! This state is reached if we have already processed a subscript.  At this point,
! only a substring is allowed.
!-
$STATE (START_SUBSTRING,
    ('(', , INIT_SUBS),
    (TPA$_LAMBDA, TPA$_EXIT)
    );

$STATE (LEFT_SUBSTRING,
    (TPA$_EOS, LEFT_SUBSTRING, NEXT_RECORD),
    (TPA$_BLANK, LEFT_SUBSTRING),
    ((DECIMAL_INTEGER), SUBSTRING2, STORE_SUBS),
    (':', RIGHT_SUBSTRING, SUBSTRING_COLON),
    (TPA$_LAMBDA, INVREFVAR_STATE)		! Signal FOR$_INVREFVAR
    );

$STATE (SUBSTRING2,
    (TPA$_EOS, SUBSTRING2, NEXT_RECORD),
    (TPA$_BLANK, SUBSTRING2),
    (':', RIGHT_SUBSTRING, SUBSTRING_COLON),
    (TPA$_LAMBDA, ERROR_STATE)
    );

$STATE (RIGHT_SUBSTRING,
    (TPA$_EOS, RIGHT_SUBSTRING, NEXT_RECORD),
    (TPA$_BLANK, RIGHT_SUBSTRING),
    ((DECIMAL_INTEGER), SUBSTRING3, STORE_SUBS),
    (')', TPA$_EXIT, END_SUBSTRING),
    (TPA$_LAMBDA, INVREFVAR_STATE)		! Signal FOR$_INVREFVAR
    );

$STATE (SUBSTRING3,
    (TPA$_EOS, SUBSTRING3, NEXT_RECORD),
    (TPA$_BLANK, SUBSTRING3),
    (')', TPA$_EXIT, END_SUBSTRING),
    (TPA$_LAMBDA, ERROR_STATE)
    );

!+
! An identifier is a letter followed by 0 or more letters, digits, "$" or "_".
!-
$STATE (IDENTIFIER,
    (TPA$_ALPHA, , BLANKS_ON)
    );

$STATE (,
    (TPA$_SYMBOL, TPA$_EXIT, BLANKS_OFF),	! Matches any string whose characters
						! consist of letters, digits,
						! "$" and "_".
    (TPA$_LAMBDA, TPA$_EXIT, BLANKS_OFF),
    );

$STATE (DECIMAL_INTEGER,
    ((INTEGER), TPA$_EXIT, CONVERT_INTEGER)
    );

$STATE (INTEGER,
    ('+', , BLANKS_ON),
    ('-', , BLANKS_ON),
    (TPA$_LAMBDA, , BLANKS_ON)
    );

$STATE (,
    (TPA$_DECIMAL, TPA$_EXIT, BLANKS_OFF),
    (TPA$_LAMBDA, TPA$_FAIL, BLANKS_OFF)
    );

!+
! Pattern for a REAL value.
!-
$STATE (REAL,
    ('+', , BLANKS_ON),
    ('-', , BLANKS_ON),
    (TPA$_LAMBDA, , BLANKS_ON)
    );

$STATE (REAL1,
    (TPA$_DIGIT, REAL1),
    ('.'),
    (TPA$_LAMBDA)
    );

$STATE (REAL2,
    (TPA$_DIGIT, REAL2),
    (TPA$_LAMBDA)
    );

$STATE (EXPONENT,
    ('E'),
    ('e'),
    ('D'),
    ('d'),
    ('Q'),
    ('q'),
    (TPA$_LAMBDA)
    );

$STATE (,
    ('+'),
    ('-'),
    (TPA$_LAMBDA)
    );

$STATE (EXPONENT2,
    (TPA$_DIGIT, EXPONENT2),
    (TPA$_LAMBDA)
    );

$STATE (,			! Fail if next character is not a delimiter
    ((NOT_DELIM), TPA$_FAIL),   ! but don't consume the character.
    (TPA$_LAMBDA, TPA$_EXIT)
    );

$STATE (NOT_DELIM,		! Fails if next character is a delimiter
    (TPA$_EOS, TPA$_FAIL),
    (TPA$_BLANK, TPA$_FAIL),
    (',', TPA$_FAIL),
    ('$', TPA$_FAIL),
    ('&', TPA$_FAIL),
    (')', TPA$_FAIL),		! Can show in complex values
    (TPA$_LAMBDA, TPA$_EXIT)
    );

!+
! Pattern for a logical value.  It is complex because any string can follow
! after the initial T, F, .T or .F up to the next "delimiter".
!-
$STATE (LOGICAL,
    ('.', , BLANKS_ON),
    (TPA$_LAMBDA, , BLANKS_ON)
    );

$STATE (,
    ('T'),
    ('t'),
    ('F'),
    ('f')
    );

!+
! Consume characters up to but not including the next delimiter.
!-
$STATE (LOGICAL1,
    ((LOGICAL2), LOGICAL1),
    (TPA$_LAMBDA, TPA$_EXIT, BLANKS_OFF)
    );

!+
! Indicates by failing if any of the selected characters are found.
!-
$STATE (LOGICAL2,
    (TPA$_EOS, TPA$_FAIL),
    (TPA$_BLANK, TPA$_FAIL),
    (',', TPA$_FAIL),
    ('(', TPA$_FAIL),
    ('=', TPA$_FAIL),
    ('$', TPA$_FAIL),
    ('&', TPA$_FAIL),
    (TPA$_ANY, TPA$_EXIT)
    );

!+
! Parse and store the representation of a complex value.  This is safe because
! a complex value can not possibly be an identifier.
$STATE (COMPLEX,
    ('(', COMPLEX2)
    );

$STATE (COMPLEX2,
    (TPA$_EOS, COMPLEX2, NEXT_RECORD),
    (TPA$_BLANK, COMPLEX2),
    ((REAL), COMPLEX3, STORE_COMPLEX),	! Store real part
    (TPA$_LAMBDA, ERROR_STATE)
    );

$STATE (COMPLEX3,
    (TPA$_EOS, COMPLEX3, NEXT_RECORD),
    (TPA$_BLANK, COMPLEX3),
    (',', COMPLEX4),
    (TPA$_LAMBDA, ERROR_STATE)
    );

$STATE (COMPLEX4,
    (TPA$_EOS, COMPLEX4, NEXT_RECORD),
    (TPA$_BLANK, COMPLEX4),
    ((REAL), COMPLEX5, STORE_COMPLEX),	! Store imaginary part
    (TPA$_LAMBDA, ERROR_STATE)
    );

$STATE (COMPLEX5,
    (TPA$_EOS, COMPLEX5, NEXT_RECORD),
    (TPA$_BLANK, COMPLEX5),
    (')', TPA$_EXIT),
    (TPA$_LAMBDA, ERROR_STATE)
    );

!+
! Pattern for a character string.  Inside the string, two consecutive quotes
! are counted as one.  This value is stored in the user variable as it goes,
! since this can not possibly be an identifier.
!-
$STATE (CHARACTER,
    (SINGLE_QUOTE, CHARACTER1, STRING_OK)	! Fails if not type CHARACTER
    );						! Also turns on TPA$V_BLANKS

$STATE (CHARACTER1,
    (TPA$_EOS, CHARACTER1, NEXT_RECORD),
    (SINGLE_QUOTE, NEXT_QUOTE),
    (TPA$_ANY, CHARACTER1, STORE_CHARACTER)
    );

$STATE (NEXT_QUOTE,
    (TPA$_EOS, NEXT_QUOTE, NEXT_RECORD),
    (SINGLE_QUOTE, CHARACTER1, STORE_CHARACTER),
    (TPA$_LAMBDA, TPA$_EXIT)
    );

!+
! This state is transferred to if a syntax error is detected in the parsing. It
! calls SYNTAX_ERROR with a token which is at or near where the error was.
! SYNTAX_ERROR signals FOR$_SYNERRNAM.
!-
$STATE (ERROR_STATE,
    (TPA$_ANY, TPA$_FAIL, SYNTAX_ERROR),
    (TPA$_LAMBDA, TPA$_FAIL, SYNTAX_ERROR)
    );

!+
! This state is transferred to when there is some invalid reference on a
! variable, i.e. subscripting a scalar, substringing a non-character or using
! non-integers in subscripts/substrings.  It calls INVREFVAR_ERROR which
! signals FOR$_INVREFVAR.
!-
$STATE (INVREFVAR_STATE,
    (TPA$_LAMBDA, TPA$_FAIL, INVREFVAR_ERROR)
    );
!<BLF/PAGE>

%SBTTL 'NEXT_RECORD - Get next record'
ROUTINE NEXT_RECORD =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Reads a new record from the current unit and updates the STRING pointers
!	in PARAM_BLOCK.
!
! CALLING SEQUENCE:
!
!	status = NEXT_RECORD ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [TPA$L_STRINGPTR] is address of new record
!	PARAM_BLOCK [TPA$L_STRINGCNT] is record length
!
! COMPLETION STATUS:
!
!	1 for success; all errors are signalled.
!
! SIDE EFFECTS:
!
!
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    GLOBAL REGISTER
	CCB = 11: REF BLOCK [, BYTE];

    CCB = .AP [NML$A_CCB];	! Fetch CCB address
    WHILE .AP [TPA$L_STRINGCNT] LEQ 0 DO
	BEGIN
	FOR$$REC_RSN0 ();		! Read the next record
	CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_PTR] + 1;	! Start with second byte
	AP [TPA$L_STRINGPTR] = .CCB [LUB$A_BUF_PTR];
	AP [TPA$L_STRINGCNT] = .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR];
	END;
    RETURN 1;

    END;

%SBTTL 'INIT_SUBS - Start a subscript/substring '
ROUTINE INIT_SUBS =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which initiates the evaluation of a subscript
!	or substring.  If the current variable can not have a subscript or
!	a substring, an error routine is called.
!
! CALLING SEQUENCE:
!
!	status = INIT_SUBS ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [NML$L_CURIDX] = 0
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	Can call INVREFVAR_ERROR
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	DESCR: REF BLOCK [, BYTE];

    DESCR = .AP [NML$A_DESCR];	! Get descriptor address

    !+
    ! If this variable is not an array or a string, signal FOR$_INVREFVAR
    !-

    IF ((.DESCR [DSC$B_CLASS] EQL DSC$K_CLASS_A) OR
	    (.DESCR [DSC$B_DTYPE] EQL DSC$K_DTYPE_T))
    THEN
	AP [NML$L_CURIDX] = 0	! Set up for start of subscript/substring
    ELSE
	CALLG (.AP, INVREFVAR_ERROR);

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'SUBSTRING_COLON - Mark presence of colon in substring'
ROUTINE SUBSTRING_COLON =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which is called when a colon is found in
!	a substring.  If no left part has been found, it sets the left part
!	to 1 indicating that the low column was omitted.  If the current
!	variable is not of type CHARACTER, then an error routine is called.
!	If the variable is an array, a subscript must have been previously
!	processed, otherwise an error is given.
!
! CALLING SEQUENCE:
!
!	status = SUBSTRING_COLON ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	If NML$L_CURIDX = 0 then NML$L_CURIDX = 1 and NML$L_SUBSCR[0] = 1
!
! COMPLETION STATUS:
!
!	1 
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	DESCR: REF BLOCK [, BYTE];	! Address of variable descriptor

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF .AP [NML$B_DTYPE] NEQ DSC$K_DTYPE_T
    THEN
	CALLG (.AP, INVREFVAR_ERROR);	! Substring not allowed with non-CHARACTER

    !+
    ! If this variable is an array, then a subscript must have been previously
    ! seen for a substring to be valid.
    !-

    DESCR = .AP [NML$A_DESCR];
    IF .DESCR [DSC$B_CLASS] EQL DSC$K_CLASS_A AND NOT .AP [NML$V_SUBSCRIPT]
    THEN
	CALLG (.AP, INVREFVAR_ERROR);	! Substring not allowed with unsubscripted array

    IF .AP [NML$L_CURIDX] EQL 0	! Substring of the form (:n)?
    THEN
	BEGIN
	AP [NML$L_CURIDX] = 1;	! Left bound is first character
	AP [NML$L_SUBSCR] = 1;
	END;

    AP [NML$V_SUBSTRING] = 1;	! Indicate substring

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_SUBS - Store a subscript or substring'
ROUTINE STORE_SUBS =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which stores the value of a subscript or
!	substring column.  It also checks to see if the allowed number of
!	subscripts have not been exceeded.
!
! CALLING SEQUENCE:
!
!	status = STORE_SUBS ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [NML$L_CURIDX] is incremented by 1
!	The value of the subscript is stored in the current subscript vector
!	location.
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	May call SYNTAX_ERROR
!	May call INVREFVAR_ERROR
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	SUBSCRIPTS: REF VECTOR [, LONG],
	DESCR: REF BLOCK [, BYTE];

    SUBSCRIPTS = AP [NML$L_SUBSCR];	! Address of subscript vector

    IF .AP [NML$V_SUBSTRING]
    THEN
	BEGIN
	IF .AP [NML$L_CURIDX] GTR 1	! Only two substring values allowed!
	THEN
	    CALLG (.AP, SYNTAX_ERROR);
	IF .AP [TPA$L_NUMBER] LEQ 0	! Substring column can't be LEQ 0
	THEN
	    CALLG (.AP, INVREFVAR_ERROR);
	END
    ELSE
	BEGIN
	DESCR = .AP [NML$A_DESCR];	! Get descriptor address
	IF .DESCR [DSC$B_CLASS] EQL DSC$K_CLASS_A
	THEN
	    IF .AP [NML$L_CURIDX] GEQ .DESCR [DSC$B_DIMCT]
	    THEN
		CALLG (.AP, INVREFVAR_ERROR);	! Too many subscripts
	END;

    SUBSCRIPTS [.AP [NML$L_CURIDX]] = .AP [TPA$L_NUMBER];	! Store subscript
    AP [NML$L_CURIDX] = .AP [NML$L_CURIDX] + 1;

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'END_SUBSCRIPT - End an array subscript'
ROUTINE END_SUBSCRIPT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which is called at the end of an array subscript.
!	It calls COMPUTE_INDEX to calculate the starting position in the array.
!
! CALLING SEQUENCE:
!
!	status = END_SUBSCRIPT ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	See COMPUTE_INDEX
!	NML$V_SUBSCRIPT = 1, to indicate subscript processed.
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	Signals FOR$_INVREFVAR if a subscript is out of bounds.
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF NOT (CALLG (.AP, COMPUTE_INDEX))
    THEN
	CALLG (.AP, INVREFVAR_ERROR);

    AP [NML$V_SUBSCRIPT] = 1;	! Allows substring to follow for arrays

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'COMPUTE_INDEX - Compute the array index'
ROUTINE COMPUTE_INDEX =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Routine which computes the starting location for the current
!	variable based on the array subscripts seen.
!
! CALLING SEQUENCE:
!
!	status = COMPUTE_INDEX ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [NML$A_VARCUR] = Starting address
!	PARAM_BLOCK [NML$A_VARSTART] = Starting address
!
! COMPLETION STATUS:
!
!	1 for success
!	SS$_SUBRNG for subscript out of range
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	DESCR: REF BLOCK [, BYTE],	! Variable descriptor
	MULTIPLIERS: REF VECTOR [,LONG],! Multiplier array
	LAST_MULT,			! Previous bounds' multiplier
	BOUNDS: REF VECTOR [,LONG],	! Current bounds
	SUBSCRIPT: REF VECTOR [,LONG],	! Current subscript
	DIMENSION,			! Current dimension
	OFFSET;				! Offset into array
	
    ENABLE
	LIB$SIG_TO_RET;	! Return SS$_SUBRNG as a status

    DESCR = .AP [NML$A_DESCR];		! Get descriptor address
    
    !+
    ! If the descriptor class is not ARRAY, then a subscript is illegal.
    !-

    IF .DESCR [DSC$B_CLASS] NEQ DSC$K_CLASS_A
    THEN
	RETURN 0;

    !+
    ! If the number of subscripts doesn't match the number of dimensions, then
    ! it is an error.
    !-

    IF .DESCR [DSC$B_DIMCT] NEQ .AP [NML$L_CURIDX]
    THEN
	RETURN 0;	! Number of subscripts don't match

    DIMENSION = .AP [NML$L_CURIDX] - 1;
    SUBSCRIPT = AP [NML$L_SUBSCR] + (4 * .DIMENSION);
    MULTIPLIERS = DESCR [DSC$L_M1] + (4 * .DIMENSION) - 4;
    LAST_MULT = .MULTIPLIERS [0];
    BOUNDS = MULTIPLIERS [2] + (8 * .DIMENSION);
    OFFSET = 0;

    !+
    ! For each dimension, from last to first, compute the offset into the
    ! array.  If a subscript is out of bounds, the INDEX instruction will
    ! signal an error.
    !-

    DECR DIM FROM .DIMENSION TO 0 DO
	BEGIN
	IF .DIM EQL 0
	THEN
	    LAST_MULT = 1;
	INDEX (SUBSCRIPT [0], BOUNDS [0], BOUNDS [1], LAST_MULT,
	       OFFSET, OFFSET);
	MULTIPLIERS = MULTIPLIERS [-1];
	LAST_MULT = .MULTIPLIERS [0];
	BOUNDS = BOUNDS [-2];
	SUBSCRIPT = SUBSCRIPT [-1];
	END;

    AP [NML$A_VARCUR] = .DESCR [DSC$A_A0] + (.OFFSET * .AP [NML$W_STRIDE]);
    AP [NML$A_VARSTART] = .AP [NML$A_VARCUR];

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'END_SUBSTRING - End a substring'
ROUTINE END_SUBSTRING =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which evaluates a substring reference.
!
! CALLING SEQUENCE:
!
!	status = END_SUBSTRING ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [NML$A_VARCUR] - Set to starting point
!	PARAM_BLOCK [NML$W_VARSIZE] - Set to string size
!	PARAM_BLOCK [NML$A_VARSTART] - Set to starting point
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	Can call INVREFVAR_ERROR if the substring is out-of-bounds.
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF .AP [NML$L_CURIDX] EQL 1
    THEN
	AP [NML$L_SUBSTRHI] = .AP [NML$W_VARSIZE]
    ELSE IF .AP [NML$L_CURIDX] NEQ 2
    THEN
	CALLG (.AP, SYNTAX_ERROR);

    IF .AP [NML$L_SUBSTRLO] LEQ 0 OR .AP [NML$L_SUBSTRHI] LSS .AP [NML$L_SUBSTRLO] OR
       .AP [NML$L_SUBSTRHI] GTR .AP [NML$W_VARSIZE]
    THEN
	CALLG (.AP, INVREFVAR_ERROR);

    AP [NML$A_VARCUR] = .AP [NML$A_VARCUR] + .AP [NML$L_SUBSTRLO] - 1;
    AP [NML$A_VARSTART] = .AP [NML$A_VARCUR];
    AP [NML$W_VARSIZE] = (.AP [NML$L_SUBSTRHI] - .AP [NML$L_SUBSTRLO]) + 1;

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'CONVERT_INTEGER - Convert a decimal integer'
ROUTINE CONVERT_INTEGER =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which converts the current token to a
!	longword integer which is stored in TPA$L_NUMBER.  If the conversion
!	fails, failure is returned.
!
! CALLING SEQUENCE:
!
!	status = CONVERT_INTEGER ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	TPA$L_NUMBER gets the binary value of the integer token
!
! COMPLETION STATUS:
!
!	OTS$_INPCONERR if the token is not a valid longword integer
!	SS$_NORMAL if success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    RETURN (OTS$CVT_TI_L (AP [TPA$L_TOKENCNT], AP [TPA$L_NUMBER]));

    END;
!<BLF/PAGE>

%SBTTL 'STRING_OK - Is a string value ok?'
ROUTINE STRING_OK =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which returns success if the current variable
!	datatype is CHARACTER.  It also sets TPA$V_BLANKS if successful.
!
! CALLING SEQUENCE:
!
!	status = STRING_OK ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [TPA$V_BLANKS] = 1 if successful
!
! COMPLETION STATUS:
!
!	0 if datatype is not CHARACTER
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF .AP [NML$B_DTYPE] NEQ DSC$K_DTYPE_T
    THEN
	RETURN 0;

    IF .AP [NML$A_VARSTART] GEQA .AP [NML$A_VAREND]
    THEN
	FOR$$SIGNAL_STO (FOR$_TOOMANVAL, .AP [NML$A_VARNAME]);

    AP [TPA$V_BLANKS] = 1;
    AP [NML$B_CONSTYPE] = K_CHARACTER;
    AP [NML$L_CONSBLOCK] = .AP [NML$A_VARSTART];
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_CHARACTER - Store a character in a string'
ROUTINE STORE_CHARACTER =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which stores the character at TPA$B_CHAR
!	at the location referenced by NML$A_VARCUR.  NML$A_VARCUR is then
!	incremented by 1.  If the character would be stored past the end
!	of the string, the procedure returns success without storing anything.
!
! CALLING SEQUENCE:
!
!	status = STORE_CHARACTER ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF .AP [NML$A_VARCUR] - .AP [NML$A_VARSTART] GEQA .AP [NML$W_VARSIZE]
    THEN
	RETURN 1;

    CH$WCHAR_A (.AP [TPA$B_CHAR], AP [NML$A_VARCUR]);
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'END_CHARACTER - End a character string'
ROUTINE END_CHARACTER =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which is called at the end of a character string value.
!	It blank fills the string if necessary and advances NML$A_VARSTART and
!	NML$A_VARCUR.  If the repeat count is greater than 1, multiple copies
!	are stored.
!
! CALLING SEQUENCE:
!
!	status = END_CHARACTER ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NML$A_VARCUR = start of next string
!	NML$A_VARSTART = start of next string
!	User variable is modified.
!	NML$L_REPEATCT <= 1
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	STRINGSIZE;	! Size of string constant

    STRINGSIZE = .AP [NML$A_VARCUR] - .AP [NML$A_VARSTART];
    IF .STRINGSIZE LSSU .AP [NML$W_VARSIZE]
    THEN
	CH$FILL (%C' ', (.AP [NML$W_VARSIZE] - .STRINGSIZE), .AP [NML$A_VARCUR]);

    !+
    ! Update the current position in the variable.
    !-

    IF .AP [NML$W_STRIDE] NEQ 0
    THEN
	AP [NML$A_VARCUR] = .AP [NML$A_VARSTART] + .AP [NML$W_STRIDE]
    ELSE
	AP [NML$A_VARCUR] = .AP [NML$A_VAREND];

    !+
    ! While repeat count is greater than 1, store multiple copies.
    !-

    WHILE .AP [NML$L_REPEATCT] GTR 1 DO
	BEGIN
	IF .AP [NML$A_VARCUR] GEQA .AP [NML$A_VAREND]
	THEN
	    FOR$$SIGNAL_STO (FOR$_TOOMANVAL, .AP [NML$A_VARNAME]);
	CH$MOVE (.AP [NML$W_VARSIZE], .AP [NML$A_VARSTART], .AP [NML$A_VARCUR]);
	AP [NML$A_VARCUR] = .AP [NML$A_VARCUR] + .AP [NML$W_STRIDE];	! Must be array!
	AP [NML$L_REPEATCT] = .AP [NML$L_REPEATCT] - 1;
	END;

    AP [NML$A_VARSTART] = .AP [NML$A_VARCUR];
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_REAL - Store a real constant'
ROUTINE STORE_REAL =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which converts the real constant at
!	TPA$L_TOKENCNT and stores the value in NML$L_CONSBLOCK.
!
! CALLING SEQUENCE:
!
!	status = STORE_REAL ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!	TPA$L_TOKENCNT - Descriptor of token
!
! IMPLICIT OUTPUTS:
!
!	NML$L_CONSBLOCK set to value of token
!	NML$B_CONSTYPE set to K_REAL
!
! COMPLETION STATUS:
!
!	1 for success
!	0 if the token is of zero length.  This is because the pattern matches
!	  the null string.
!
! SIDE EFFECTS:
!
!	May call SYNTAX_ERROR
!	May signal FOR$_INVARGFOR
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    !+
    ! If token is of zero length, then return failure.
    !-

    IF .AP [TPA$L_TOKENCNT] EQL 0
    THEN
	RETURN 0;

    !+
    ! Since the pattern for a real matches a string such as "D123", which
    ! might be an identifier, check for the first character being a letter.
    ! If it is, then store the token, set the value to zero and return.  
    ! If we don't do this, an identifier like D99999999999 would get a 
    ! conversion error immediately.  No other "real" token can possibly
    ! be an identifier.
    !-

    IF CH$RCHAR (.AP [TPA$L_TOKENPTR]) GEQU %C'A' AND
       CH$RCHAR (.AP [TPA$L_TOKENPTR]) LEQU %C'z'
    THEN
	BEGIN
	AP [NML$L_CONSBLOCK] = 0;	! Set value to zero
	AP [NML$B_CONSTYPE] = K_INTEGER;
	IF .AP [TPA$L_TOKENCNT] LEQ 31 
	THEN
	    BEGIN
	    LOCAL
		TOKEN: REF VECTOR [, BYTE];
	    TOKEN = AP [NML$T_TOKEN];
	    TOKEN [0] = .AP [TPA$L_TOKENCNT];
	    CH$MOVE (.AP [TPA$L_TOKENCNT], .AP [TPA$L_TOKENPTR], TOKEN [1]);
	    END
	ELSE
	    AP [NML$T_TOKEN] = 0;
	RETURN 1;
	END
    ELSE
	AP [NML$T_TOKEN] = 0;

    !+
    ! Depending on the destination type, convert the token appropriately.
    !-
    
    IF ONE_OF (.AP [NML$B_DTYPE],
	DSC$K_DTYPE_L, DSC$K_DTYPE_W, DSC$K_DTYPE_B, DSC$K_DTYPE_WU, 
        DSC$K_DTYPE_LU,	DSC$K_DTYPE_D, DSC$K_DTYPE_DC)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_D (AP [TPA$L_TOKENCNT], AP [NML$L_CONSBLOCK])
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_F, DSC$K_DTYPE_FC)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_F (AP [TPA$L_TOKENCNT], AP [NML$L_CONSBLOCK])
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_G, DSC$K_DTYPE_GC)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_G (AP [TPA$L_TOKENCNT], AP [NML$L_CONSBLOCK])
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_H)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_H (AP [TPA$L_TOKENCNT], AP [NML$L_CONSBLOCK])
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_T)
    THEN
	BEGIN
	FOR$$SIGNAL_STO (FOR$_INPCONERR);
        RETURN 0;
	END

    ELSE	! Invalid datatype
	BEGIN
	FOR$$SIGNAL_STO (FOR$_INVARGFOR);
        RETURN 0;
	END;


    AP [NML$B_CONSTYPE] = K_REAL;

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_LOGICAL - Store a logical value'
ROUTINE STORE_LOGICAL =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which converts the logical value at
!	TPA$L_TOKENCNT and stores the value at NML$L_CONSBLOCK.  If the
!	token is possibly an identifier, the token is saved at NML$T_TOKEN.
!
! CALLING SEQUENCE:
!
!	status = STORE_LOGICAL ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!	TPA$L_TOKENCNT is descriptor of token
!
! IMPLICIT OUTPUTS:
!
!	NML$L_CONSBLOCK gets converted value
!	NML$B_CONSTYPE gets K_LOGICAL
!	NML$T_TOKEN gets token if possibly an identifier
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF CH$RCHAR (.AP [TPA$L_TOKENPTR]) NEQ %C'.' AND
       .AP [TPA$L_TOKENCNT] LEQ 31
    THEN
	BEGIN
	LOCAL
	   TOKEN: REF VECTOR [, BYTE];
	TOKEN = AP [NML$T_TOKEN];
	TOKEN [0] = .AP [TPA$L_TOKENCNT];
	CH$MOVE (.AP [TPA$L_TOKENCNT], .AP [TPA$L_TOKENPTR], TOKEN [1]);
	END
    ELSE
	AP [NML$T_TOKEN] = 0;

    OTS$CVT_TL_L (AP [TPA$L_TOKENCNT], AP [NML$L_CONSBLOCK]);
    AP [NML$B_CONSTYPE] = K_LOGICAL;
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_COMPLEX - Store a complex constant'
ROUTINE STORE_COMPLEX =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which converts the current token as a real
!	value and converts it to either the real part or the imaginary part
!	of a complex value.
!
! CALLING SEQUENCE:
!
!	status = STORE_COMPLEX ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!	TPA$L_TOKENCNT - Descriptor of token
!	NML$V_IMAG     - Set if real part already seen
!
! IMPLICIT OUTPUTS:
!
!	NML$L_CONSBLOCK set to value of token
!	NML$B_CONSTYPE set to K_COMPLEX
!	NML$V_IMAG set to 1
!
! COMPLETION STATUS:
!
!	1 for success
!	0 if the token is of zero length.  This is because the pattern matches
!	  the null string.
!
! SIDE EFFECTS:
!
!	May call SYNTAX_ERROR
!	May signal FOR$_INVARGFOR
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	L_DTYPE,			! Local data type
	L_CONSBLOCK: VECTOR [4, LONG];	! Local constant block

    !+
    ! If token is of zero length, then return failure.
    !-

    IF .AP [TPA$L_TOKENCNT] EQL 0
    THEN
	RETURN 0;

    !+
    ! Depending on the destination type, convert the token appropriately.
    !-
    

    IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_F, DSC$K_DTYPE_FC)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_F (AP [TPA$L_TOKENCNT], L_CONSBLOCK)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE],
	DSC$K_DTYPE_L, DSC$K_DTYPE_W, DSC$K_DTYPE_B, DSC$K_DTYPE_LU, 
	DSC$K_DTYPE_WU, DSC$K_DTYPE_D, DSC$K_DTYPE_DC)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_D (AP [TPA$L_TOKENCNT], L_CONSBLOCK)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_G, DSC$K_DTYPE_GC)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_G (AP [TPA$L_TOKENCNT], L_CONSBLOCK)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_H)
    THEN
	BEGIN
	IF NOT OTS$CVT_T_H (AP [TPA$L_TOKENCNT], L_CONSBLOCK)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END

    ELSE IF ONE_OF (.AP [NML$B_DTYPE], DSC$K_DTYPE_T)
    THEN
	BEGIN
	FOR$$SIGNAL_STO (FOR$_INPCONERR);
	RETURN 0;
	END

    ELSE
	BEGIN
	FOR$$SIGNAL_STO (FOR$_INVARGFOR);
	RETURN 0;
	END;


    AP [NML$B_CONSTYPE] = K_COMPLEX;

    !+
    ! Now convert the local constant to the proper complex type and store in
    ! either the real or imaginary part of NML$L_CONSBLOCK.
    !-

    SELECTONE .AP [NML$B_DTYPE] OF
	SET
	[DSC$K_DTYPE_FC]:
	    L_DTYPE = DSC$K_DTYPE_F;
	[DSC$K_DTYPE_DC]:
	    L_DTYPE = DSC$K_DTYPE_D;
	[DSC$K_DTYPE_GC]:
	    L_DTYPE = DSC$K_DTYPE_G;
	[OTHERWISE]:
	    L_DTYPE = .AP [NML$B_DTYPE];
	TES;
    IF NOT .AP [NML$V_IMAG]		! If real part
    THEN
	BEGIN
	IF NOT FOR$$CVT_TYPE (K_REAL, L_CONSBLOCK,
			      .L_DTYPE, AP [NML$L_CONSBLOCK], 0)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	AP [NML$V_IMAG] = 1;
	END
    ELSE
	BEGIN
	IF .L_DTYPE EQL DSC$K_DTYPE_H
	THEN
	    RETURN 1;
	IF NOT FOR$$CVT_TYPE (K_REAL, L_CONSBLOCK,
			      .L_DTYPE, 
			      (IF .L_DTYPE EQL DSC$K_DTYPE_F
			       THEN
				   AP [NML$L_CONSBLOCK] + 4
			       ELSE
				   AP [NML$L_CONSBLOCK] + 8),
			       0)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	END;
	
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_REPEAT - Store a repeat count'
ROUTINE STORE_REPEAT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which stores the repeat count into the
!	parameter block.
!
! CALLING SEQUENCE:
!
!	status = STORE_REPEAT ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NML$L_REPEATCT gets the repeat count
!	NML$B_CONSTYPE = K_NULL
!
! COMPLETION STATUS:
!
!	1 for success
!	0 if repeat count greater than 2**31-1 or is zero
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF .AP [TPA$L_NUMBER] LEQ 0
    THEN
	RETURN 0
    ELSE
	AP [NML$L_REPEATCT] = .AP [TPA$L_NUMBER];

    AP [NML$B_CONSTYPE] = K_NULL;	! Initially treat as null value

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'END_REPEAT - End a repeated value'
ROUTINE END_REPEAT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which marks the end of a repeated value.
!
! CALLING SEQUENCE:
!
!	status = END_REPEAT ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NML$T_TOKEN = 0, meaning that this value can't be an identifier
!	TPA$V_BLANKS = 0, disabling explicit blank processing
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    AP [NML$T_TOKEN] = 0;	! Inhibit use of this token as an identifier
    AP [TPA$V_BLANKS] = 0;	! Turn off explicit blank processing

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'STORE_VALUE - Store a value in a variable'
ROUTINE STORE_VALUE=

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which stores the value just read in the
!	current variable.  If the repeat count is greater than 1, multiple
!	copies are moved.  However, if the value was of type CHARACTER,
!	all copies have been stored and this routine only returns success.
!	If the constant type is NULL, then "repeat-count" values are skipped.
!
! CALLING SEQUENCE:
!
!	status = STORE_VALUE ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	The user variable is modified (if value not NULL)
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	Signals FOR$_SYNERRNAM if an error occurs during conversion.
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    !+
    ! If this was a character string, all values have been stored.
    !-

    IF .AP [NML$B_CONSTYPE] EQL K_CHARACTER
    THEN
	RETURN 1;

    !+
    ! Check to see if we are past the end of the variable or array
    !-

    IF .AP [NML$A_VARSTART] GEQA .AP [NML$A_VAREND]
    THEN
	BEGIN
	FOR$$SIGNAL_STO (FOR$_TOOMANVAL, .AP [NML$A_VARNAME]);
	RETURN 0;
	END;

    !+
    ! If this was a repeated null (n*), then skip over values.
    !-

    IF .AP [NML$B_CONSTYPE] EQL K_NULL
    THEN
	WHILE .AP [NML$L_REPEATCT] GTR 0 DO
	    BEGIN
	    IF .AP [NML$A_VARCUR] GEQA .AP [NML$A_VAREND]
	    THEN
		BEGIN
		FOR$$SIGNAL_STO (FOR$_TOOMANVAL, .AP [NML$A_VARNAME]);
		RETURN 0;
		END;
	    AP [NML$A_VARCUR] = .AP [NML$A_VARCUR] + .AP [NML$W_VARSIZE];
	    AP [NML$L_REPEATCT] = .AP [NML$L_REPEATCT] - 1;
	    END
    ELSE
	BEGIN
    
	!+
	! Call routine to convert value to the appropriate destination type.
	! If conversion fails, signal an error.
	!-
    
	IF NOT FOR$$CVT_TYPE (.AP [NML$B_CONSTYPE], AP [NML$L_CONSBLOCK],
			      .AP [NML$B_DTYPE], .AP [NML$A_VARSTART], 0)
	THEN
	    BEGIN
		    FOR$$SIGNAL_STO (FOR$_INPCONERR);
	    RETURN 0;
	    END;
	AP [NML$A_VARCUR] = .AP [NML$A_VARSTART] + .AP [NML$W_VARSIZE];
    
	!+
	! While repeat count is greater than 1, store copies of the value.
	!-
    
	WHILE .AP [NML$L_REPEATCT] GTR 1 DO
	    BEGIN
	    IF .AP [NML$A_VARCUR] GEQA .AP [NML$A_VAREND]
	    THEN
		BEGIN
		FOR$$SIGNAL_STO (FOR$_TOOMANVAL, .AP [NML$A_VARNAME]);
		RETURN 0;
		END;
	    AP [NML$A_VARCUR] = CH$MOVE (.AP [NML$W_VARSIZE], .AP [NML$A_VARSTART],
					 .AP [NML$A_VARCUR]);
	    AP [NML$L_REPEATCT] = .AP [NML$L_REPEATCT] - 1;
	    END;
	END;

    !+
    ! Update VARSTART with new position
    !-

    AP [NML$A_VARSTART] = .AP [NML$A_VARCUR];
    RETURN 1;
    END;
!<BLF/PAGE>

%SBTTL 'NULL_VALUE - Skip an element'
ROUTINE NULL_VALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which is called when a comma is found in place
!	of a value.  The pointer to the current element is advanced one element
!	with no change being made to the current element.  Note that if the
!	current variable is not an array, an attempt to store a following value
!	will be an error.  If we have already passed the last element, give
!	an error.
!
! CALLING SEQUENCE:
!
!	status = NULL_VALUE ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NML$A_VARSTART is advanced one element.
!	NML$A_VARCUR = NML$A_VARSTART
!
! COMPLETION STATUS:
!
!	1
!
! SIDE EFFECTS:
!
!	FOR$_TOOMANVAL - if this comma implies a skip past the end of the
!	variable.
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    !+
    ! If we are already past the end of the variable, give an error.
    !-

    IF .AP [NML$A_VARSTART] GEQA .AP [NML$A_VAREND]
    THEN
	FOR$$SIGNAL_STO (FOR$_TOOMANVAL, .AP [NML$A_VARNAME]);

    IF .AP [NML$W_STRIDE] NEQ 0
    THEN
	AP [NML$A_VARSTART] = .AP [NML$A_VARSTART] + .AP [NML$W_STRIDE]
    ELSE
	AP [NML$A_VARSTART] = .AP [NML$A_VAREND];

    AP [NML$A_VARCUR] = .AP [NML$A_VARSTART];

    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'SYNTAX_ERROR - Signal syntax error'
ROUTINE SYNTAX_ERROR =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which signals a syntax error.
!
! CALLING SEQUENCE:
!
!	status = SYNTAX_ERROR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals FOR$_SYNERRNAM - Syntax error in NAMELIST
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    IF .AP [TPA$L_TOKENCNT] LSS 6
    THEN
	BEGIN
	LOCAL
	    EXTRA,
	    CCB: REF BLOCK [, BYTE];
	CCB = .AP [NML$A_CCB];

	!+
	! Try to make the string reported include the part of the record
	! where the error was.
	!-

	IF .AP [TPA$L_TOKENPTR] GEQA .CCB [LUB$A_BUF_PTR]
	THEN
	    BEGIN
	    EXTRA = MAX (0, (6 - .AP [TPA$L_TOKENCNT]));
	    IF .AP [TPA$L_TOKENPTR] - .EXTRA LSSA .CCB [LUB$A_BUF_PTR]
	    THEN
		EXTRA = .AP [TPA$L_TOKENPTR] - .CCB [LUB$A_BUF_PTR];
	    AP [TPA$L_TOKENCNT] = .AP [TPA$L_TOKENCNT] + .EXTRA;
	    AP [TPA$L_TOKENPTR] = .AP [TPA$L_TOKENPTR] - .EXTRA;
	    END;
	END;

    FOR$$SIGNAL_STO (FOR$_SYNERRNAM, AP [TPA$L_TOKENCNT]);
    RETURN 0;

    END;
!<BLF/PAGE>

%SBTTL 'INVREFVAR_ERROR - Signal invalid variable reference error'
ROUTINE INVREFVAR_ERROR =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which signals an invalid variable
!	reference  error.
!
! CALLING SEQUENCE:
!
!	status = INVREFVAR_ERROR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals FOR$_INVREFVAR - Invalid reference to variable in NAMELIST
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	DESCR: VECTOR [2, LONG],
	VARNAME: REF VECTOR [, BYTE];

    VARNAME = .AP [NML$A_VARNAME];
    DESCR [0] = .VARNAME [0];
    DESCR [1] = VARNAME [1];
    FOR$$SIGNAL_STO (FOR$_INVREFVAR, DESCR);
    RETURN 0;

    END;
!<BLF/PAGE>

%SBTTL 'BLANKS_OFF - Turn off explicit blanks'
ROUTINE BLANKS_OFF =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Turns off explicit blank processing for LIB$TPARSE.  When off, blanks
!	are implicit separators.
!
! CALLING SEQUENCE:
!
!	status = BLANKS_OFF ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [TPA$V_BLANKS] = 0
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    AP [TPA$V_BLANKS] = 0;	! Turn off blank processing
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'BLANKS_ON - Turn on explicit blanks'
ROUTINE BLANKS_ON =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Turns on explicit blank processing for LIB$TPARSE.  When on, blanks
!	are not implicit separators.
!
! CALLING SEQUENCE:
!
!	status = BLANKS_ON ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [TPA$V_BLANKS] = 0
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    AP [TPA$V_BLANKS] = 1;	! Turn on blank processing
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'LOOKUP_IDENTIFIER - Lookup identifier in NAMELIST group'
ROUTINE LOOKUP_IDENTIFIER =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Searches the NAMELIST group for an identifier which matches the
!	current token.  If found, the descriptor information is entered into
!	the parameter block.  If not found, an error is signalled.
!
! CALLING SEQUENCE:
!
!	status = LOOKUP_IDENTIFIER ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	PARAM_BLOCK [NML$A_VARNAME] = address of variable name counted string
!	PARAM_BLOCK [NML$A_VARSTART] = address of variable low byte
!	PARAM_BLOCK [NML$A_VAREND] = address of next byte past end of variable
!	PARAM_BLOCK [NML$A_VARCUR] = same as VARSTART
!	PARAM_BLOCK [NML$W_VARSIZE] = size of a variable element in bytes
!	PARAM_BLOCK [NML$W_STRIDE] = stride between elements if array, else 0
!	PARAM_BLOCK [NML$B_DTYPE] = descriptor datatype code of variable
!	PARAM_BLOCK [NML$B_CONSTYPE] = 0
!	PARAM_BLOCK [NML$L_REPEATCT] = 1
!	PARAM_BLOCK [NML$V_IMAG] = 0
!	PARAM_BLOCK [NML$V_VALUE_IDENT] = 0
!	PARAM_BLOCK [NML$V_SUBSTRING] = 0;
!	PARAM_BLOCK [NML$V_SUBSCRIPT] = 0;
!
! COMPLETION STATUS:
!
!	1 for success
!
! SIDE EFFECTS:
!
!	Signals FOR$_INVREFVAR - Invalid NAMELIST variable if identifier is not in
!	the current group.
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	NML_LIST: REF VECTOR [, LONG];		! Pointer to list descriptor

    NML_LIST = .AP [NML$A_LISTBLOCK];		! Get list block address
    
    !+
    ! Loop through identifier list looking for a matching identifier.  If none
    ! found, signal an error.  Loop value will be true if no match found.
    !-

    IF (
	DECRU I FROM .(NML_LIST [1])<0,16,0> TO 1 DO	! Count is first word of second longword
	    BEGIN
	    NML_LIST = NML_LIST [2];		! Move to next identifier in list
	    IF COMPARE_UPCASE (.NML_LIST[0], AP [TPA$L_TOKENCNT])
	    THEN
		EXITLOOP 0;	! Loop value false if a match is found
	    END)
    THEN
	BEGIN
	!+
	! If we get here, there is no match.  Signal an error giving the variable
	! name.
	!-
    
	FOR$$SIGNAL_STO (FOR$_INVREFVAR, AP [TPA$L_TOKENCNT]);
    
	RETURN 0;	! Execution should never return here
	END

    ELSE

	BEGIN

	!+
	! A match has been found.  Fill in the parameter block from the
	! descriptor.
	!-

	LOCAL
	    DESC: REF BLOCK [, BYTE];	! Variable descriptor

	AP [NML$A_VARNAME] = .NML_LIST [0];	! Address of name counted string
	DESC = .NML_LIST [1];		! Descriptor address

	!+
	! Validate descriptor class and datatype
	! \\ Note:  The use of the ONE_OF macro here assumes that
	!    neither a datatype code of 0 nor a class code
	!    of 0 is one of the valid ones.  If this
	!    is no longer true, the value must first be tested to
	!    ensure that it is not greater than 127 (unsigned). \\
	!-

	IF NOT ONE_OF (.DESC [DSC$B_DTYPE],
	    DSC$K_DTYPE_BU, DSC$K_DTYPE_B , DSC$K_DTYPE_WU,
	    DSC$K_DTYPE_W , DSC$K_DTYPE_LU, DSC$K_DTYPE_L ,
	    DSC$K_DTYPE_T , DSC$K_DTYPE_F , DSC$K_DTYPE_D ,
	    DSC$K_DTYPE_G , DSC$K_DTYPE_H , DSC$K_DTYPE_FC,
	    DSC$K_DTYPE_DC, DSC$K_DTYPE_GC) OR
	  NOT ONE_OF (.DESC [DSC$B_CLASS],
	    DSC$K_CLASS_S, DSC$K_CLASS_A)
	THEN
	    BEGIN
	    FOR$$SIGNAL_STO (FOR$_INVARGFOR);
	    RETURN 0;
	    END;

	!+
	! Fill in parameter block.
	!-

	AP [NML$A_VARSTART] = .DESC [DSC$A_POINTER];
	AP [NML$A_VARCUR] = .DESC [DSC$A_POINTER];
	AP [NML$W_VARSIZE] = .DESC [DSC$W_LENGTH];
	AP [NML$B_DTYPE] = .DESC [DSC$B_DTYPE];
	AP [NML$A_DESCR] = .DESC;

	IF .DESC [DSC$B_CLASS] EQL DSC$K_CLASS_A
	THEN
	    BEGIN
	    !+
	    ! If the array descriptor doesn't have COLUMN order and 
	    ! coefficient and bounds blocks, or if it has
	    ! more than 7 dimensions, then the descriptor is 
	    ! invalid for us.
	    !-

	    IF NOT (.DESC [DSC$V_FL_COLUMN] AND 
		    .DESC [DSC$V_FL_COEFF] AND 
		    .DESC [DSC$V_FL_BOUNDS] AND
		    (.DESC [DSC$B_DIMCT] LEQU 7))
	    THEN
		BEGIN
		FOR$$SIGNAL_STO (FOR$_INVARGFOR);
		RETURN 0;
		END;

	    AP [NML$A_VAREND] = .AP [NML$A_VARSTART] + .DESC [DSC$L_ARSIZE];
	    AP [NML$W_STRIDE] = .AP [NML$W_VARSIZE];
	    END
	ELSE
	    BEGIN
	    AP [NML$A_VAREND] = .AP [NML$A_VARSTART] + .AP [NML$W_VARSIZE];
	    AP [NML$W_STRIDE] = 0;
	    END;

	AP [NML$B_CONSTYPE] = 0;
	AP [NML$L_REPEATCT] = 1;
	AP [NML$V_IMAG] = 0;
	AP [NML$V_VALUE_IDENT] = 0;
	AP [NML$V_SUBSCRIPT] = 0;
	AP [NML$V_SUBSTRING] = 0;

	!+
	! Since FORTRAN insists on passing us datatype BU for a signed byte,
	! change it here.
	!-

	IF .AP [NML$B_DTYPE] EQL DSC$K_DTYPE_BU
	THEN
	    AP [NML$B_DTYPE] = DSC$K_DTYPE_B;
	END;

    RETURN 1;	! Success

    END;
!<BLF/PAGE>

%SBTTL 'SET_VALUE_IDENT - Mark that last token is supposed to be an identifier'
ROUTINE SET_VALUE_IDENT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which is called when the character following
!	a value token indicates that the last token is supposed to be an 
!	identifier.  It sets a flag in the parameter block which is checked
!	when the next identifier is needed.
!
! CALLING SEQUENCE:
!
!	status = SET_VALUE_IDENT ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!
! IMPLICIT OUTPUTS:
!
!	NML$V_VALUE_IDENT = 1
!
! COMPLETION STATUS:
!
!	1
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    AP [NML$V_VALUE_IDENT] = 1;
    RETURN 1;

    END;
!<BLF/PAGE>

%SBTTL 'WAS_VALUE_IDENT - Lookup last value as an identifier'
ROUTINE WAS_VALUE_IDENT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LIB$TPARSE action routine which is called when an identifier is needed.
!	If NML$V_VALUE_IDENT is 1 then the last value token is supposed to be
!	an identifier. Otherwise, 0 is returned.  The last value token, if it
!	could possibly be an identifier, was stored in NML$T_TOKEN.  We call
!	LOOKUP_IDENTIFIER to see if it is.  If the last token wasn't of type
!	REAL or LOGICAL or if the token length is zero, we fail.
!
! CALLING SEQUENCE:
!
!	status = WAS_VALUE_IDENT ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	AP	Points to PARAM_BLOCK
!	NML$V_VALUE_IDENT
!	NML$T_TOKEN
!
! IMPLICIT OUTPUTS:
!
!	See LOOKUP_IDENTIFIER
!
! COMPLETION STATUS:
!
!	1 if LOOKUP_IDENTIFIER succeeds
!	0 if last token isn't an identifier
!
! SIDE EFFECTS:
!
!	See LOOKUP_IDENTIFIER
!
!--

    BEGIN

    BUILTIN
	AP;		! Argument pointer points to parameter block

    MAP
	AP: REF BLOCK [, BYTE] FIELD (NML$FIELDS);

    LOCAL
	TOKEN: REF VECTOR [, BYTE];

    !+
    ! If NML$V_VALUE_IDENT is 0, then fail.
    !-

    IF NOT .AP [NML$V_VALUE_IDENT]
    THEN
	RETURN 0;

    !+
    ! If last constant type is not REAL or LOGICAL or INTEGER or if token length
    ! is zero, then we have a syntax error.
    !-

    IF NOT ONE_OF (.AP [NML$B_CONSTYPE], K_REAL, K_LOGICAL, K_INTEGER) OR
       .AP [NML$T_TOKEN] EQL 0
    THEN
	BEGIN
	!+
	! We reached this state by matching TPA$_LAMBDA just at the delimiter
	! that caused us to think that the last value token was really an
	! identifier.  TOKENPTR points to that delimiter and TOKENCNT is 0.
	! Increment TOKENCNT so that the delimiter will be in the error
	! message.
	!-

	AP [TPA$L_TOKENCNT] = .AP [TPA$L_TOKENCNT] + 1;
	CALLG (.AP, SYNTAX_ERROR);
	END;
	

    !+
    ! Construct token from NML$T_TOKEN.
    !-

    TOKEN = AP [NML$T_TOKEN];
    AP [TPA$L_TOKENCNT] = .TOKEN [0];
    AP [TPA$L_TOKENPTR] = TOKEN [1];
    RETURN CALLG (.AP, LOOKUP_IDENTIFIER);
    
    END;
!<BLF/PAGE>

%SBTTL 'COMPARE_UPCASE - Compare strings upcased'
ROUTINE COMPARE_UPCASE (
			CSTRING_ADR,
			STRING2_DSC
			) : JSB_COMPARE_UPCASE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Compare two strings: the counted string whose address is CSTRING_ADR
!	and the string described by the descriptor STRING2_DSC.  The
!	STRING2_DSC string is upcased for the comparison; the CSTRING_ADR
!	string is assumed to be already upcased.
!
!	Comparison continues until a non-matching character is found or until
!	one of the strings is empty.  No blank-filling is done.
!
! CALLING SEQUENCE:
!
!	matches = COMPARE_UPCASE (CSTRING_ADR, STRING2_DSC)
!
! FORMAL PARAMETERS:
!
!	CSTRING_ADR	- The address of a counted string whose count is in the
!			  first byte.  Assumed to be uppercase.
!
!	STRING2_DSC	- The address of a string descriptor.  This string will
!			  be forced to upper case during the comparison.  The
!			  string itself is not modified.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! FUNCTION VALUE:
!
!	1 if the strings are equal
!	0 otherwise
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	CSTRING_ADR: REF VECTOR [, BYTE],
	STRING2_DSC: REF BLOCK [, BYTE];

    LOCAL
	STRING2_ADR: REF VECTOR [, BYTE],
	STRING1_LEN: WORD;

    !+
    ! Compare string lengths.  If they don't match, return failure.
    !-

    STRING1_LEN = .CSTRING_ADR [0];
    IF .STRING1_LEN NEQU .STRING2_DSC [DSC$W_LENGTH]
    THEN
	RETURN 0;

    !+
    ! Compare strings for equality.  Lengths must match.
    !-

    STRING2_ADR = .STRING2_DSC [DSC$A_POINTER];
    INCRU I FROM 1 TO .STRING1_LEN DO
	BEGIN
	IF .CSTRING_ADR [.I] NEQU
	    (
	    IF .STRING2_ADR [0] GEQU %C'a' AND .STRING2_ADR [0] LEQU %C'z'
	    THEN
		CH$RCHAR_A (STRING2_ADR) - (%C'a' - %C'A')
	    ELSE
		CH$RCHAR_A (STRING2_ADR)
	    )
	THEN
	    RETURN 0;	! Unequal character found
	END;

    !+
    ! If we get here, then the match is successful.
    !-

    RETURN 1;

    END; 

END						! End of module FOR$$NML_TABLES

ELUDOM
