MODULE BAS$$UDF_RL (			! BASIC list-directed input, UDF level
		IDENT = '1-067'		! File: BASUDFRL.B32 Edit:PLL1067
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	BASIC support library - not user callable
!
! ABSTRACT:
!
!	This module implements BASIC read list-directed I/O statement
!	at the UDF level of abstraction.  This module calls the list-
!	directed record routines at the record level to read a record.
!
! ENVIRONMENT:	User access mode, reentrant AST level or not
!
! AUTHOR: Donald G. Petersen,	CREATION DATE: 23-MAR-78
!
! MODIFIED BY:
!
! 	DGP, 23-MAR-78 : VERSION 0
! 1	- original 
! 1-02	- Change to JSB linkages.  DGP 14-Nov-78
! 1-004	- Update copyright notice and add device names to REQUIRE
!	   files.  JBS 29-NOV-78
! 1-005	- Change REQUIRE file names from FOR... to OTS...  JBS 07-DEC-78
! 1-006 - Change to new statement types for INPUT LINE and LINPUT. DGP
!	  08-Dec-78
! 1-007 - Change UDF_RL1 to use dispatch tables to get to REC level.  DGP
!	  19-Dec-78
! 1-008 - Add the necessary functionality to get INPUT LINE properly.  DGP
!	  19-Dec-78
! 1-009 - Bug fix.  DGP 20-Dec-78
! 1-010 - Add support for longwords.  DGP 28-Dec-78
! 1-011 - Add error signal to UDF_WL1 (BAS$K_ILLNUM).  DGP 28-Dec-78
! 1-012 - Fix bug in Input integer (word).  DGP 02-Jan-79
! 1-013 -  Change ISB$A_BUF_PTR, BUF_BEG, BUF_END to LUB. DGP 05-Jan-79
! 1-014 - Make some "cleanup" edits based on the code review.
!	   JBS for DGP.  09-JAN-1979
! 1-015 - Correct some typos.  JBS 10-JAN-1979
! 1-016 - Expand on some comments.  DGP 15-Jan-79
! 1-017 - Add code to handle ^Z for INPUT LINE properly.  DGP 15-Jan-79
! 1-018 - Fix bug in returning text string from GETFIELD. DGP 16-Jan-79
! 1-019 - Change SIGNAL to STOP for ILLNUM in GETFIELD.  DGP 26-Jan-79
! 1-020 - Use BASIOERR.REQ to define the I/O error codes.  JBS 20-FEB-1979
! 1-021 - Modify GETFIELD to strip off leading and trailing spaces and tabs
!	  from unquoted strings.  DGP 23-Feb-79
! 1-022 - Change update of BUF_PTR for text in GETFIELD.  DGP 06-Mar-79
! 1-023 - Strip all leading spaces and tabs from any text string before check-
!	  ing for delimiting quotes.  DGP 15-Mar-79
! 1-024 - Change PRINT_POS to longword.  DGP 19-Mar-79
! 1-025 - Don't allow semicolon as numeric field separator on Input.  DGP
!	  02-Apr-79
! 1-026 - If this is not a terminal device, then ignore the prompt.  06-Apr-79
!	  DGP
! 1-027 - Change call to BAS$$STOP to BAS$$STOP_IO.  DGP 16-Apr-79
! 1-028 - Change a few error messages.  DGP 07-May-79
! 1-029	- Change OTS$S to STR$.  JBS 23-MAY-1979
! 1-030 - BAS$$UDF_RL1 returns a status.  DGP 06-Jun-79
! 1-031 - Fix up BAS$$UDF_RL1 to support MAT INPUT.  DGP 14-Jun-79
! 1-032	- Use language-specific dispatch tables.  JBS 26-JUN-1979
! 1-033 - Improve the comments.  DGP  28-Jun-79
! 1-034	- Use ISB symbols for dispatch tables.  JBS 12-JUL-1979
! 1-035	- Change calls to STR$COPY.  JBS 16-JUL-1979
! 1-036 - Change from FOR$ input conversion routines to OTS$.  DGP 17-Jul-79
! 1-037	- Remove reference to BAS$$SIGDIS_ERR.  JBS 01-AUG-1979
! 1-038 - Set "don't round" flag for single precision floating when calling
!	  the input conversion routine.  DGP 07-Aug-79
! 1-039 - UDF_RL0 should dispatch to the REC level.  DGP 07-Aug-79
! 1-040 - Set the prompt buffer size to 0 for MAT INPUT if REC level returns
!	  a failure.  DGP 07-Aug-79
! 1-041 - Strip off leading and trailing nulls from input.  DGP 29-Aug-79
! 1-042 - Unconditionally clear the prompt buffer after every GET.  DGP 03-Sep-79
! 1-043 - Switch the order of K_CRLF.  DGP 05-Sep-79
! 1-044 - Increase K_WORK_STR_LEN to 512.  DGP 10-Sep-79
! 1-045 - Fix bug in INPUT longwords with tabs and spaces.  DGP 10-Sep-79
! 1-046 - Only look at low byte of RAB$L_STV for terminator.  DGP 18-Sep-79
! 1-047 - Clear LUB$L_PRINT_POS just before the GET is done.  DGP 18-Sep-79
! 1-048 - Prompting should be using LUB$B_PRINT_POS from LUB$A_BUDDY_PTR so
!	  that CCPOS picks up the right value.  DGP 18-Sep-79
! 1-049 - Check for comma after quoted string.  DGP 09-Oct-79
! 1-050 - Include MAT LINPUT with those statement types which want to
!	  read an entire line.  DGP 12-Oct-79
! 1-051 - Another attempt at handling quoted strings properly.  DGP 18-Oct-79
! 1-052 - Fix bug of input string that is only spaces, tabs, or nulls.
!	  DGP 29-Oct-79
! 1-053 - Pass the scale factor to the conversion routine.  DGP 25-Nov-79
! 1-054 - Set V_EXP_LETTER for OTS$CVT_T_D.  DGP 04-DEC-79
! 1-055 - Correct improper register declaration for scaling.  DGP 18-Dec-79
! 1-056 - Call MTH$DINT_R3 instead of MTH$DFLOOR_R3 for scaling.  DGP 19-Dec-79
! 1-057 - Signal DATA FORMAT ERROR instead of ILLEGAL NUMBER.  DGP  21-Jan-80
! 1-058 - If this is READ or MAT READ then update the data pointer before
!	  doing the conversion so that we are pointing at the next data
!	  element.  DGP 22-Jan-80
! 1-059 - Pick up escape sequences from RMS for INPUT LINE.  DGP 21-Feb-80
! 1-060 - Do not set the cursor position unconditionally to zero.  DGP 04-Mar-80
! 1-061 - If the terminator is an escape (altmode) and the terminating
!	  sequence is of length 1, then transfer the escape character for
!	  INPUT LINE.  RMS does not supply it at the end of the data anymore.
!	  DGP 31-Mar-80
! 1-062 - Fix the problem with inputing (READ,INPUT.....)
!	  "abc"123,"xyz"  this should give an error because of 123.  FM 25-SEP-80
! 1-063 - Enable INPUT and kind to take an input longer than K_STR_LEN bytes. 
!	  Terminal I/O is still restricted to 512 bytes.  FM 25-SEP-80
!	  61A and 61B were put in the same packet.
! 1-064 - Fix problem in above change.  A GTRU should be a GTR.  DGP 03-Feb-1981.
! 1-065 - Change some occurences of CCB[LUB$L_PRINT_POS] TO TEMP_CCB[LUB$L_PRINT_POS].
!	  Also, INPUT should cancel any outstanding PRINT formatcharacter
!	  unless the INPUT was terminated by an escape. PLL 12-Jun-81
! 1-066 - A case statement in GETFIELD modified to always return a value
!	  so that the BLISS compiler does not give an error message.
!	  PLL 1-Jul-81
! 1-067 - 64k bytes of data causes a premature "out of data" message because 
!	  SCANC length is limited to 16 bits.  Make sure the length always looks
!	  = or < 64k to GETFIELD.  PLL 23-Jul-81
!--


!
! SWITCHES:
!
SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);
!
!	LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';		! define all linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

    !
    ! UDF routines
    !
    BAS$$UDF_RL0: JSB_UDF0 NOVALUE,
    BAS$$UDF_RL1: CALL_CCB,
    UDF_RL1_HANDLER,
    BAS$$UDF_RL9: JSB_UDF9 NOVALUE,

    !
    ! routine used by  BAS$$UDF_RL1
    !
    GETFIELD: CALL_CCB;
!
! INCLUDE FILES:
!
REQUIRE 'RTLML:BASPAR';		! BASIC intermodule parameters
REQUIRE 'RTLIN:BASFRAME';	! BASIC frame offsets
REQUIRE 'RTLML:OTSISB';		! I/O statement block
REQUIRE 'RTLML:OTSLUB';		! Logical Unit Block
REQUIRE 'RTLIN:OTSMAC';		! Macros
REQUIRE 'RTLIN:RTLPSECT';	! Define DECLARE_PSECTS macro
REQUIRE 'RTLIN:BASIOERR';	! Define I/O error codes.
LIBRARY 'RTLSTARLE';		! STARLET library for macros and symbols

!
! MACROS:
!
!	NONE
!
!
! EQUATED SYMBOLS:
!

LITERAL

    K_WORK_STR_LEN = 512,		! length of work area for parsing input.
    K_NULL	= 0,			! types of constants which may appear in input record
    K_CR	= %X'0D',		! ASCII <cr>
    K_ESC	= %X'1B',		! ASCII <esc>
    K_SP	= %X'20',		! ASCII <sp>
    K_TAB	= 9;			! ASCII TAB

BUILTIN
    SCANC;

!
! PSECT declarations
!
    DECLARE_PSECTS (BAS);		 ! declare PSECTS for BAS$ facility

!
! OWN STORAGE:
!	NONE

!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
    BAS$K_DATFORERR:UNSIGNED (8),	! Data format error
    BAS$K_ILLNUM:UNSIGNED (8),		! Illegal number
    BAS$K_ENDFILDEV:UNSIGNED (8),	! End of file on device
    BAS$K_MAXMEMEXC:UNSIGNED (8),	! Maximum memory exceeded
    BAS$K_PROLOSSOR:UNSIGNED (8);	! Program lost sorry

EXTERNAL
    BAS$$AA_REC_PR0 : VECTOR,		! Dispatch table for REC init.
    BAS$$AA_REC_PR1 : VECTOR,		! Dispatch table for REC level
    OTS$$A_CUR_LUB: ADDRESSING_MODE (GENERAL); ! address of currently active LUB/ISB/RAB

EXTERNAL ROUTINE
    MTH$DINT,			! Remove fraction after scaling
    BAS$$STOP_IO,		! signal fatal errors
    LIB$CVTDF,			! convert double to floating
    STR$COPY_DX,		! Copy a string by descriptor
    BAS$OUT_T_DX_S:  NOVALUE,	! output a text string
    !
    ! conversion routines
    !
    OTS$CVT_TI_L,		! convert ASCII to internal 32 bit integer
    OTS$CVT_T_D,		! convert ASCII to internal double precision
    !
    ! record level routines for list-directed input
    !
    BAS$$REC_RSL0: JSB_REC0 NOVALUE,	! initialize Input record level
    BAS$$REC_RSL9: JSB_REC9 NOVALUE,	! end of Input record level
    LIB$GET_VM,				! get virtual memory
    LIB$FREE_VM,			! free virtual memory
    LIB$MATCH_COND;			! match the condition value


GLOBAL ROUTINE BAS$$UDF_RL0 (
	FORMAT_ADR
	): JSB_UDF0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform UDF level read list-directed I/O initialization.
!	Initialize module "own" storage in the ISB.
!	Call record level processor to get first input record.
!
! FORMAL PARAMETERS:
!
!	FORMAT_ADR.rl.r		Not used
!
! IMPLICIT INPUTS:
!
!	OTS$$A_CUR_LUB		Pointer to current logical unit block (LUB)
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    EXTERNAL REGISTER
	CCB: REF BLOCK[, BYTE];

    !+
    ! Call record level routine to read the first record.
    ! The buffer pointers are initialized based on whether the device is
    ! a terminal or not
    !-

    JSB_REC0 (BAS$$AA_REC_PR0 + .BAS$$AA_REC_PR0 [.CCB [ISB$B_STTM_TYPE] - ISB$K_BASSTTYLO + 1]);

    END;

GLOBAL ROUTINE BAS$$UDF_RL1 (
	ELEM_TYPE,
	ELEM_SIZE,
	ELEM_ADR,
	FORMAT
	)
	: CALL_CCB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return the next input value to the user I/O list element.
!	The value obtained from the input record is converted to
!	the type of the list element.
!
! FORMAL PARAMETERS:
!
!	ELEM_TYPE.rlu.v		Type code of user I/O list element
!	ELEM_SIZE.rlu.v		Size of the list element
!	ELEM_ADR.rlu.r		Adr of where to store the element
!				Points to a descriptor for a string
!	FORMAT.rlu.v		Format character following a Prompt string
!
! IMPLICIT INPUTS:
!
!	OTS$$A_CUR_LUB		Pointer to current logical unit block (LUB)
!	LUB$L_PRINT_POS		Internal cursor position
!	LUB$V_UNIT_0		flag to indicate terminal on unit 0
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_PRINT_POS		internal cursor position
!	RAB$B_PSZ		size of the Prompt buffer
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALS various errors for input incompatibility and not enough
!	input data.
!	If this is not a terminal device, then ignore any prompts.
!
!	NOTICE : All terminal device files are allocated the static buffer for
!		 parsing, i.e. no VM is allocated for them (because at the
!		 time this routine is called we don't know how large of input
!		 we have!!). This means that the maximum terminal device input
!		 is K_WORK_STR_LEN, anything over this will write over the 
!		 stack.
!--

    !+
    ! Be aware that there are two exit points in this routine.  One is from
    ! the Prompt handling section and the other is from the Input handling section
    !-

    BEGIN
    MAP
	ELEM_ADR: REF VECTOR;
    LOCAL
	WORKSPACE: VECTOR [ K_WORK_STR_LEN , BYTE ],! if input is K_WORK_STR_LEN or less 
					! use this space through CHARCONS.
	CHARCONS: REF VECTOR [ , BYTE ],! The space where the parsing of input takes place.
	D_VALUE: VECTOR[2],		! holds binary equivalent of input char.
					! for numerics
	TEMP_CCB : REF BLOCK [, BYTE],	! temporary CCB
	DSC: BLOCK [8,BYTE],		! Descriptor of parsed element for strings
					! need a local descriptor because if a
					! static desc. was passed, the values in
					! it are not to be changed.
	UNWIND_VM_SIZE : VOLATILE,	! Size of VM allocated.
	UNWIND_VM_ADDR : VOLATILE,	! Address of VM allocated for input buffer
					! This buffer is allocated if input size
					! is greater than 512.
	UNWIND_CCB     : VOLATILE;	! CCB for the handler.

    LITERAL
	K_ESC = %X'1B';		! ASCII for escape

    EXTERNAL REGISTER
	CCB: REF BLOCK[,BYTE];
!+
! Set up a handler for this routine so in case of unwind we can deallocate VM,
! if any was allocated.
!-
    ENABLE UDF_RL1_HANDLER ( UNWIND_VM_SIZE , UNWIND_VM_ADDR , UNWIND_CCB );

!+
! If space needed for parsing is greater than K_WORK_STR_LEN then we use VM, otherwise
! we use the static storage allocated in WORKSPACE.
!-
    IF ( .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR] ) GTR K_WORK_STR_LEN
    THEN
        BEGIN
	UNWIND_VM_SIZE = .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR];
	UNWIND_CCB = .CCB;
	IF NOT LIB$GET_VM ( UNWIND_VM_SIZE , UNWIND_VM_ADDR ) THEN BAS$$STOP_IO (BAS$K_MAXMEMEXC);
	CHARCONS = .UNWIND_VM_ADDR;
	END
    ELSE
	CHARCONS = WORKSPACE;
!+
! Load up TEMP_CCB with a pointer to the complementary data base for PRINT.
!-
    TEMP_CCB = .CCB [LUB$A_BUDDY_PTR];

    IF .FORMAT GTR 0
    THEN
	BEGIN

	!+
	! Check to see if this is a terminal device.  If it is, then process the
	! prompt; otherwise, just return.
	!-

	IF .CCB [LUB$V_TERM_DEV]
	THEN
	    BEGIN

	!+
	! Prompt
	!-

	LOCAL
	    RDSC: BLOCK [8, BYTE];	! Resultant descriptor from Prompt processing
	LITERAL
	    K_PRINT_ZONE_SZ = 14,	! Print zone size
	    K_CRLF = %X'0A0D';		! ASCII codes for carriage return-line feed

	RDSC[DSC$A_POINTER] = .CCB[RAB$L_PBF] + .CCB[RAB$B_PSZ];

	!+
	! adjust the internal cursor position and the resultant string
	! length as determined by the data type and the format character
	!-

	CASE .FORMAT
	FROM BAS$K_SEMI_FORM TO BAS$K_NO_FORM OF
	SET
	[BAS$K_SEMI_FORM]:
	    BEGIN
	    CCB[ISB$V_P_FORM_CH] = BAS$K_SEMI_FORM;
	    RDSC[DSC$W_LENGTH] = .ELEM_SIZE;
	    TEMP_CCB [LUB$L_PRINT_POS] = .ELEM_SIZE + .TEMP_CCB [LUB$L_PRINT_POS];
	    END;
	[BAS$K_COMMA_FOR]:
	    BEGIN
	    CCB[ISB$V_P_FORM_CH] = BAS$K_COMMA_FOR;
	    RDSC[DSC$W_LENGTH] = .ELEM_SIZE + (K_PRINT_ZONE_SZ - ((.TEMP_CCB [LUB$L_PRINT_POS] + .ELEM_SIZE)
		MOD K_PRINT_ZONE_SZ));
	    TEMP_CCB [LUB$L_PRINT_POS] = .TEMP_CCB[LUB$L_PRINT_POS] + .RDSC[DSC$W_LENGTH];
	    END;
	[BAS$K_NO_FORM]:
	    BEGIN

	    !+
	    ! Need to leave room for carriage control
	    !-

	    RDSC[DSC$W_LENGTH] = .ELEM_SIZE + 2;
	    CCB[ISB$V_P_FORM_CH] = BAS$K_NO_FORM;
	    TEMP_CCB[LUB$L_PRINT_POS] = 0;
	    END;
	TES;

	!+
	! Set the address for the destination of the Prompt.  Update the RAB
	! Prompt Buffer Size
	!-

	CCB[RAB$B_PSZ] = .CCB[RAB$B_PSZ] + .RDSC[DSC$W_LENGTH];
	RDSC[DSC$B_CLASS] = DSC$K_CLASS_S;
	CH$COPY (.ELEM_SIZE, .(.ELEM_ADR+4), ' ', .RDSC[DSC$W_LENGTH], .RDSC[DSC$A_POINTER]);
	IF .FORMAT EQLU BAS$K_NO_FORM
	THEN
	    (.RDSC[DSC$A_POINTER] + .ELEM_SIZE)<0, 16> = K_CRLF;
	END;
	RETURN 1;
	END;

    !+
    ! This section is concerned with inputting a value
    ! GETFIELD will attempt to parse another field out of the INPUT stream based
    ! on the data type.  If a data field cannot be found (empty buffer)
    ! then a failure
    ! status is returned.  If a data field is found then a 
    !conversion, for numerics,
    ! is done and if a conversion error occurs, the error number is put into the
    ! LUB.  For a string, the descriptor passed to GETFIELD is updated to point to
    ! the parsed string and the length field is updated.
    !-

    IF NOT (GETFIELD(

		!+
		! Pass the a reference to a quadword for a numeric quantity and
		! a pointer to a descriptor for a string
		!-

		(CASE .ELEM_TYPE
		FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
		SET
		[DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_F, DSC$K_DTYPE_D]:
		    D_VALUE;
		[DSC$K_DTYPE_T]:
		    DSC;
		[INRANGE, OUTRANGE]:
		    !+
		    ! Data types which are not yet supported
		    !-
		    0
		TES
		),
	.ELEM_TYPE, .CHARCONS))
    THEN
	BEGIN
	!+
	! Try to get another record.  Device type checking (forcible or nonforcible) is performed at
	! the REC level before a GET is attempted.
	!-
	IF .CCB[LUB$V_UNIT_0]
	THEN

	    !+
	    ! Insert the BASIC default prompt if on unit 0
	    !-

	    BEGIN
	    LOCAL
		TDSC: VECTOR [2];
	    BIND
	    D_PROMPT = UPLIT ('? ');
	    TDSC[0] = %CHARCOUNT ('? ');
	    TDSC[1] = D_PROMPT;
	    BAS$OUT_T_DX_S(TDSC);
	    END;

	!+
	! Dispatch to the appropriate REC level routine.  If INPUT then get
	! another record.  If READ then signal an error - should not be out
	! of data. If this is a MAT INPUT, try to get another record and pass the status
	! back to the UPI level.  Status is determined by whether the current
	! record ends with a continuation character.  Clear LUB$L_PRINT_POS thru
	! BUDDY_PTR so that this INPUT will not affect later PRINTs or prompting
	! if there is an error on this GET.
	! NOTE:  There is a RETURN here in the middle of the routine.
	!-

	IF (NOT (JSB_REC1 (BAS$$AA_REC_PR1 + .BAS$$AA_REC_PR1[.CCB[ISB$B_STTM_TYPE] - ISB$K_BASSTTYLO + 1])))
	THEN 
!+
! Clear the Prompt buffer which has been loaded in case another GET was going to
! be done.  If it is not cleared, then I/O_END will print it out (10 INPUT 'foo'
! ).  MAT INPUT is different, because the RTL asks for more data if it is avail-
! able.  The other types of Input demand more data.  Therefore, the GET for MAT
! INPUT is only done if the continuation flag is set signifying that the last
! record ended in an '&'.
!-
	    BEGIN
	    CCB [RAB$B_PSZ] = 0;
	    RETURN 0;
	    END;
!+
! Unconditionally clear the prompt buffer so that a RESUME with no line number
! which restarts an INPUT statement will not keep concatenating prompt strings.
!-
	CCB [RAB$B_PSZ] = 0;

	!+
	! Now that another record has been gotten, call GETFIELD again and ignore
	! the return status because it is assumed that failure to return something
	! is impossible.
	!-

	GETFIELD(
		(CASE .ELEM_TYPE
		FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
		SET
		[DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_F, DSC$K_DTYPE_D]:
		    D_VALUE;
		[DSC$K_DTYPE_T]:
		    DSC;
		[INRANGE, OUTRANGE]:
		    !+
		    ! Data types which are not yet supported
		    !-
		    0
		TES
		),
	    .ELEM_TYPE, .CHARCONS)
	END;


    !+
    ! Store the converted Input data into its new home based on the data type
    !-

    CASE .ELEM_TYPE
    FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
    SET
    [INRANGE, OUTRANGE]:
    !+
    ! Data types which are not supported
    !-
    0;
    [DSC$K_DTYPE_W]:
	!+
	! Integer
	!-
	BEGIN
	MAP
	    ELEM_ADR: REF VECTOR[, WORD];
	ELEM_ADR[0] = .D_VALUE;
	END;
    [DSC$K_DTYPE_L, DSC$K_DTYPE_F]:
	!+
	! Longword integer or single precision floating point
	!-
	ELEM_ADR[0] = .D_VALUE;
    [DSC$K_DTYPE_D]:
	!+
	! Double precision floating point
	!-
	BEGIN
	ELEM_ADR[0] = .D_VALUE[0];
	ELEM_ADR[1] = .D_VALUE[1];
	END;
    [DSC$K_DTYPE_T]:
	!+
	! Character string - ELEM_ADR contains the address of the descriptor
	!-
	BEGIN
	DSC[DSC$A_POINTER] = .CHARCONS;
	DSC[DSC$B_CLASS] = DSC$K_CLASS_S;
	DSC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	! ***** Change to LIB$SCOPY to inhibit signalling ******
	STR$COPY_DX (.ELEM_ADR, DSC);
	IF .(.DSC[DSC$A_POINTER])<0,8> EQLU BAS$K_CONTROL_Z
	THEN
	    BEGIN

	    !+
	    ! This ^Z has been deferred until now so that it could get stored into 
	    ! the users buffer for error handling as required by Basic.  Now is
	    ! the proper time to signal the error.
	    !-

	    CCB[RAB$B_PSZ] = 0;
	    BAS$$STOP_IO(BAS$K_ENDFILDEV);
	    END;
	END
    TES;
    CCB[RAB$B_PSZ] = 0;
    IF (.CCB[RAB$W_STV0] NEQ K_ESC) THEN TEMP_CCB[LUB$V_FORM_CHAR] = 0;
!+
! If we have allocated VM for the parsing space then deallocate it here.
!-
    IF ( .CHARCONS NEQA WORKSPACE )
    THEN
	BEGIN
        IF NOT LIB$FREE_VM ( UNWIND_VM_SIZE , UNWIND_VM_ADDR ) 
	THEN
	    BEGIN
	    UNWIND_VM_SIZE = 0;
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	    END;
	END;
    RETURN 1;
    END;


ROUTINE UDF_RL1_HANDLER (			!Handeler for bas$udf_rl1
	SIG					!Signal vector
	,MECH					!Mechanism vector
	,ENBL					!Enable vector
	) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If we are unwinding and we have given the parsing space VM then
!	free this VM.
!
! FORMAL PARAMETERS:
!
!	SIG.rl.ra	A counted vector of parameters from LIB$SIGNAL/STOP
!	MECH.rl.ra	A counted vector of info from chf
!	ENBL.rl.ra	A counted vector of ENABLE argument addresses.
!
! IMPLICIT INPUTS
!
!	NONE
!
! IMPLICIT OUTPUTS
!
!	NONE
!
! COMPLETION CODES
!
!	Always SS$_RESIGNAL, which is ignored when unwinding.
!
! SIDE EFFECTS
!
!	NONE
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,
	MECH: REF VECTOR,
	ENBL: REF VECTOR;

    GLOBAL REGISTER CCB = K_CCB_REG : REF BLOCK [,BYTE];

    CCB = ..ENBL [3];
!+
! If we are unwinding and have allocated VM then free it.
!-
    IF (LIB$MATCH_COND ( SIG [1] , %REF(SS$_UNWIND) ) AND ( ..ENBL [1] GTRU 0 ))
    THEN
	IF NOT LIB$FREE_VM ( .ENBL [1] , .ENBL [2] )
	THEN BAS$$STOP_IO ( BAS$K_PROLOSSOR );
    RETURN (SS$_RESIGNAL);

    END;

GLOBAL ROUTINE BAS$$UDF_RL9
	: JSB_UDF9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	List directed input UDF termination.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    RETURN;
    END;

ROUTINE GETFIELD (
	ELEM,
	ELEM_TYPE,
	WORK_STR
	) :CALL_CCB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse out the next input data field based on the field terminators
!	appropriate for the data type.  Return the field with tabs and spaces
!	stripped out in the area supplied by the calling routine.
!	A one is returned if a field was found.  A zero is returned if an <eol>
!	is encountered before a field is found.
!
! FORMAL PARAMETERS:
!
!	ELEM_TYPE.rlu.v		Type of element from list
!	ELEM.wz.r		Pointer of where to return the value
!				May be a reference to a quadword or a descriptor
!	WORK_STR.wt.rs		Work string for parsing input string and resulting
!				string for type text.
!
! IMPLICIT INPUTS:
!
!	LUB$A_BUF_PTR		current location in the buffer
!	LUB$A_BUF_END		pointer to last byte of buffer + 1
!	RAB$W_RSZ		buffer size
!	RAB$W_STV0		first word of STV field
!	RAB$W_STV2		second word of STV field
!	ISB$B_STTM_TYPE		I/O statement type in ISB
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Pointer to next byte in user buffer
!	ISB$B_ERR_NO		first error found processing an I/O stmt.
!
! ROUTINE VALUE:
!
!	1 = a data field was found
!	0 = a data field was not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    !+
    ! Note: There are 3 exit points from this routine; not the best structure
    ! but that's the way it is.
    !-

    BEGIN

    MAP
	WORK_STR: REF VECTOR [K_WORK_STR_LEN, BYTE],	! work area
	ELEM: REF VECTOR [2];		! default ELEM to numeric

    LOCAL
	DSC: BLOCK [8, BYTE],		! working desc. for parsing the input stream
	MASK,				! mask value for SCANC
	RET_VAL,			! value to return to caller
	LEN,				! length of input record remaining to be scanned
	SCAN_VAL,			! return value from SCANC
	PTRS,				! char pointer for source string
	PTRD;				! char pointer for destination string

    !+
    ! mask values for the SCANC to stop on different characters
    !-

    LITERAL
	K_COMMA = %X'01',
	K_SEMI = %X'02',
	K_SGL_QUOTE = %X'04',
	K_DBL_QUOTE = %X'08',
	K_TAB_SPACE = %X'10',
	K_NULL = %X'20',
	K_CHAR = %X'40',
	K_NONE = %X'00',
!+
! The element size of a longword integer
!-
	K_INT_SIZ = 4,
!+
! The flags for floating and integer input
!-
	K_INT_FLAGS = 5,
	K_FLT_F_FLAGS = 123,
	K_FLT_D_FLAGS = 115;

    BIND
	TABLE = UPLIT BYTE (
      	    %X'20', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'10', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 0
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 1
	    %X'10', %X'40', %X'48', %X'40', %X'40', %X'40', %X'40', %X'44', %X'40',
		%X'40', %X'40', %X'40', %X'41', %X'40', %X'40', %X'40', ! column 2
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'42', %X'40', %X'40', %X'40', %X'40', ! column 3
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 4
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 5
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 6
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 7
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 8
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 9
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 10
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 11
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 12
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 13
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', ! column 14
	    %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40',
		%X'40', %X'40', %X'40', %X'40', %X'40', %X'40', %X'40' ! column 15
	): VECTOR[256, BYTE];

    EXTERNAL REGISTER
	CCB: REF BLOCK [, BYTE];

    !+
    ! Initialize the default null string (zero length)
    !-

    DSC[DSC$W_LENGTH] = 0;

    !+
    ! Check to see if there is any more data in the record.
    ! If there is no more data (BUF_PTR GEQA BUF_END) then return a failure
    ! status.  Otherwise, increment BUF_PTR.
    !-

    IF .CCB[LUB$A_BUF_PTR] GEQA .CCB[LUB$A_BUF_END]
    THEN
	RETURN 0
    ELSE
	CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_PTR] + 1;

    !+
    ! Check for the buffer pointer equal to the end of the buffer (return default).
    ! If the statement type is INPUT LINE, we will do all of the other processing.
    !-

    IF (.CCB[LUB$A_BUF_PTR] EQLA .CCB[LUB$A_BUF_END])
     AND (.CCB [ISB$B_STTM_TYPE] NEQ ISB$K_ST_TY_INL)
    THEN

	!+
	! Return a zero or a null string as a default value
	!-

	BEGIN
	CASE .ELEM_TYPE
	FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
	SET
	[INRANGE, OUTRANGE]:
	    !+
	    ! Data types not yet supported
	    !-
	    ELEM[0] = 0;
	[DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_F]:

	    !+
	    ! Data type integer
	    !-

	    ELEM[0] = 0;
	[DSC$K_DTYPE_D]:

	    !+
	    ! Data type double precision
	    !-

	    BEGIN
	    ELEM[0] = 0;
	    ELEM[1] = 0;
	    END;
	[DSC$K_DTYPE_T]:

	    !+
	    ! Data type text
	    !-
	    BEGIN
	    MAP
		ELEM: REF BLOCK [8, BYTE];
	    ELEM[DSC$W_LENGTH] = 0;
	    END;
	TES;
	RETURN 1;
	END;

    !+
    ! Set up the mask for the scan.  Make any special adjustments to the buffer
    ! pointer that are necessary for type character string.
    !-

    DSC[DSC$A_POINTER] = WORK_STR[0];
    CASE .ELEM_TYPE
    FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
    SET
    [INRANGE, OUTRANGE]:
    !+
    ! Data types which are not supported yet
    !-
    0;
    [DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_F, DSC$K_DTYPE_D]:
	MASK = K_COMMA OR K_TAB_SPACE OR K_NULL;
    [DSC$K_DTYPE_T]:

	!+
	! First check for INPUT LINE, MAT LINPUT, or LINPUT.  They return the whole line regardless
	! of the contents.  Remove all leading tabs and spaces.  Next check for
	! quotes (single or double).  They return
	! everything up to the matched quote.  The quotes themselves are not returned
	! and the first one is stripped off by incrementing the buffer pointer.
	! Otherwise, a field is delimited by a comma or <eol>.
	! Trailing spaces and tabs are stripped off unquoted strings at great
	! pain.
	!-

	IF .CCB[ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_LIN
	 OR .CCB[ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_INL
	 OR .CCB [ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_MLI
	THEN
	    MASK = K_NONE
	ELSE
	    BEGIN

	    !+
	    ! Strip off the leading tabs, nulls, and spaces.  If this results
	    ! in a zero length string then return the null string.
	    !-

	    WHILE (.(.CCB [LUB$A_BUF_PTR])<0,8,0> EQL %C' '
	     OR .(.CCB [LUB$A_BUF_PTR])<0,8,0> EQL %C'	'
	     OR .(.CCB [LUB$A_BUF_PTR])<0,8,0> EQL %X'00')
	     AND .CCB [LUB$A_BUF_PTR] LSS .CCB [LUB$A_BUF_END]
	    DO
		CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_PTR] + 1;
	    IF .CCB[LUB$A_BUF_PTR] GEQ .CCB[LUB$A_BUF_END]
	     OR .(.CCB[LUB$A_BUF_PTR])<0,8,0> EQL %C','
	    THEN
		BEGIN
		MAP
		    ELEM: REF BLOCK [8, BYTE];
		ELEM[DSC$W_LENGTH] = 0;
		RETURN 1;
		END;
	    IF .(.CCB[LUB$A_BUF_PTR])<0, 8> EQL %C''''
	    THEN
		BEGIN
		MASK = K_SGL_QUOTE;
		CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_PTR] + 1;
		END
	    ELSE
		IF .(.CCB[LUB$A_BUF_PTR])<0, 8> EQL %C'"'
		THEN
		    BEGIN
		    MASK = K_DBL_QUOTE;
		    CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_PTR] + 1;
		    END
		ELSE
		    MASK = K_COMMA;
	    END;
    TES;

    !+
    ! Point the character pointer to the start of the field.
    !-

    PTRS = CH$PTR(.CCB[LUB$A_BUF_PTR]);
    PTRD = CH$PTR(.DSC[DSC$A_POINTER]);
    LEN = .CCB[LUB$A_BUF_END] - .CCB[LUB$A_BUF_PTR];

    !+
    ! Based on the data type, scan the input data string for an element
    !-

    WHILE 1 DO
	BEGIN
	LOCAL
	    TEMP_LEN;			!Used to allow > 64kb data
	TEMP_LEN = (IF .LEN GEQU 65536 THEN 65535 ELSE .LEN);
	SCAN_VAL = SCANC(TEMP_LEN, .CCB[LUB$A_BUF_PTR], TABLE, MASK);
	IF .SCAN_VAL NEQ 0
	THEN
	    CASE .ELEM_TYPE
	    FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
	    SET
	    [DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_F, DSC$K_DTYPE_D]:
		BEGIN
		CH$MOVE (.SCAN_VAL-.CCB[LUB$A_BUF_PTR], .PTRS, .PTRD);
		IF (.(.SCAN_VAL)<0, 8> EQL K_TAB) OR (.(.SCAN_VAL)<0, 8> EQL K_SP)
		    OR (.(.SCAN_VAL)<0, 8> EQL %X'00')
		THEN

		    !+
		    ! A tab, null, or a space has been found in a numeric field
		    ! Strip it out.
		    !-

		    BEGIN
		    DSC[DSC$W_LENGTH] = .DSC[DSC$W_LENGTH] + (.SCAN_VAL - .CCB[LUB$A_BUF_PTR]);
		    PTRS = CH$PLUS(.PTRS, .SCAN_VAL-.CCB[LUB$A_BUF_PTR] + 1);
		    PTRD = CH$PLUS(.PTRD, .SCAN_VAL - .CCB[LUB$A_BUF_PTR]);
		    LEN = .LEN - (.SCAN_VAL - .CCB[LUB$A_BUF_PTR]) - 1;
		    CCB[LUB$A_BUF_PTR] = .SCAN_VAL + 1;
		    END
		ELSE
		    BEGIN
		    IF .SCAN_VAL EQLU .CCB[LUB$A_BUF_PTR]
		    THEN

			!+
			! An element separator was encountered as the next character;
			! return the proper default value or the data scanned so far.
			!-
			BEGIN
			RET_VAL = 1;
			EXITLOOP;
			END;
		    DSC[DSC$W_LENGTH] = .DSC[DSC$W_LENGTH] + .SCAN_VAL - .CCB[LUB$A_BUF_PTR];
		    LEN = .LEN - (.SCAN_VAL - .CCB[LUB$A_BUF_PTR]) - 1;
		    CCB[LUB$A_BUF_PTR] = .SCAN_VAL;
		    RET_VAL = 1;
		    EXITLOOP;
		    END;
		END;

	    [DSC$K_DTYPE_T]:
		!+
		! Type text
		! Update the length so far, move the substring found, and 
		! check for a delimiting quote if necessary.
		!-

		BEGIN
		LOCAL
		    A_HIGH_MARK;		! High water mark of SCAN

		!+
		! Strip off trailing spaces, nulls, and tabs if unquoted string
		!-

		A_HIGH_MARK = .SCAN_VAL;
		IF .MASK EQL K_COMMA
		THEN
		    WHILE .(.SCAN_VAL - 1)<0,8,0> EQL %C' '
		     OR .(.SCAN_VAL - 1)<0,8,0> EQL %C'	'
		     OR .(.SCAN_VAL - 1)<0,8,0> EQL %X'00'
		    DO
			SCAN_VAL = .SCAN_VAL - 1;

		DSC[DSC$W_LENGTH] = .SCAN_VAL - .CCB[LUB$A_BUF_PTR];
		CH$MOVE (.SCAN_VAL - .CCB[LUB$A_BUF_PTR], .PTRS, .PTRD);

		!+
		! increment the buffer pointer if a delimiting quote is present
		!-

		CCB[LUB$A_BUF_PTR] = .A_HIGH_MARK;
		IF .(.A_HIGH_MARK)<0, 8> EQL %C'''' OR .(.A_HIGH_MARK)<0, 8> EQL %C'"'
		THEN
		    BEGIN
		    LOCAL
			T_RET_VAL,		! temp return value from SCANC
						! looking for delimiting comma
			REM_LENGTH;		! Length remaining in the buffer
		    CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_PTR] + 1;
!+
! Scan for a comma, another character or the end-of-record following this quoted string.
! Set BUF_PTR to the address that the scan returns.  If there is a comma,
! then it will be pointing at the comma.
! If there is a character other than space, tab or null following qoute, signal.
!-
		    MASK = K_COMMA OR K_CHAR;
		    REM_LENGTH = .LEN - .DSC [DSC$W_LENGTH] - 1;
		    REM_LENGTH = (IF .REM_LENGTH GEQU 65536 THEN 65535 ELSE .REM_LENGTH);
		    T_RET_VAL = SCANC(REM_LENGTH, .CCB [LUB$A_BUF_PTR],
			TABLE, MASK);
		    CCB [LUB$A_BUF_PTR] = (IF .T_RET_VAL EQL 0 THEN .CCB [LUB$A_BUF_END] + 1 ELSE .T_RET_VAL);
		    IF (.T_RET_VAL NEQ 0) AND
		       (.(.T_RET_VAL)< 0 , 8 > NEQ %C',')
		    THEN BAS$$STOP_IO ( BAS$K_DATFORERR );
		    END;
		RET_VAL = 1;
		EXITLOOP;
		END;
	    [INRANGE, OUTRANGE]:
		!+
		! Data types which are not supported
		!-
		0;
	    TES
	ELSE

	    !+
	    ! The whole rest of the buffer was scanned without finding an element separator
	    !-

	    BEGIN
	    LOCAL
		T_BUF_END;			! temp to hold BUF_END for deleting
						! trailing nulls, spaces, and tabs
	    T_BUF_END = .CCB[LUB$A_BUF_END];

	    !+
	    ! Check the mask value and if it indicates that this string is
	    ! bound by quotes, then check to see if LUB$A_BUF_PTR is not
	    ! equal to LUB$A_BUF_END.  The assumption is that if BUF_PTR is
	    ! equal to BUF_END, then a delimiting quote was not found but
	    ! rather the SCANC stopped on end-of-record.
	    !-

	    IF .MASK EQL K_DBL_QUOTE OR .MASK EQL K_SGL_QUOTE
	    THEN
		BAS$$STOP_IO(BAS$K_DATFORERR);

	    !+
	    ! So far everything is OK.  Move the data, then check for INPUT LINE
	    ! If this is an INPUT LINE, then we need to bump the length based on
	    ! the terminator and move the terminator into the buffer.
	    ! If INPUT then strip off the trailing spaces, nulls, and tabs
	    !-

	    IF (.CCB[ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_INP
	     OR .CCB[ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_REA)
	     AND .ELEM_TYPE EQL DSC$K_DTYPE_T
	    THEN
		WHILE .(.T_BUF_END - 1)<0,8,0> EQL %C' '
		 OR .(.T_BUF_END - 1)<0,8,0> EQL %C'	'
		 OR .(.T_BUF_END - 1)<0,8,0> EQL %X'00'
		DO
		    T_BUF_END = .T_BUF_END - 1;

	    DSC[DSC$W_LENGTH] = .DSC[DSC$W_LENGTH] + (.T_BUF_END - .CCB[LUB$A_BUF_PTR]);
	    PTRD = CH$MOVE (.T_BUF_END - .CCB[LUB$A_BUF_PTR], .PTRS, .PTRD);
	    IF .CCB[ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_INL
	    THEN

		!+
		! This is an INPUT LINE.  Bump length and tack on the terminator
		!-

		BEGIN
		LITERAL
		    K_ESCAPE = %X'1B',		! ASCII escape character
		    K_CR = %X'0D',		! ASCII carriage return char.
		    K_CRLF = %X'0A0D';		! ASCII carriage return-line
						! feed char. combination
!+
! Due to an undocumented change to RMS for V2.0, we want to look only at the
! low order byte to find the terminating character.  RMS is now returning the
! length of the terminating sequence in the upper word.
!-
		SELECTONEU .CCB [RAB$W_STV0] OF
		SET
		[K_ESCAPE]:
		    BEGIN
!+
! Check to see if the length is one.  If it is, we have to move the escape
! character by hand; it is not at the end of the buffer.  Otherwise, the escape
! sequence is at the end of the buffer following the data.
!-
		    IF .CCB [RAB$W_STV2] EQLU 1
		    THEN
			BEGIN
			DSC [DSC$W_LENGTH] = .DSC [DSC$W_LENGTH] + 1;
			CH$MOVE(1, UPLIT(K_ESCAPE), .PTRD);
			END
		    ELSE
			BEGIN
			DSC[DSC$W_LENGTH] = .DSC[DSC$W_LENGTH] + .CCB [RAB$W_STV2];
			CH$MOVE (.CCB [RAB$W_STV2], .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ], .PTRD);
		 	END;
		    END;
		[K_CR]:
		    BEGIN
		    DSC[DSC$W_LENGTH] = .DSC[DSC$W_LENGTH] + 2;
		    CH$MOVE (2, UPLIT(K_CRLF), .PTRD);
		    END;
		[OTHERWISE]:
		    ;
		TES;
		END;
	    CCB[LUB$A_BUF_PTR] = .CCB[LUB$A_BUF_END];
	    RET_VAL = 1;
	    EXITLOOP;
	    END;
	END;		! WHILE loop
!+
! Update the data pointer if this is a READ or MAT READ so that we are pointing
! at the next data element in the event of an error.
!-
	IF (.CCB [ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_MRE) OR
	 (.CCB [ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_REA)
	THEN
	    BEGIN
	    LOCAL
		BMF : REF BLOCK [0, BYTE] FIELD (BSF$MAJOR_FRAME);	! BASIC major frame pointer
	    BMF = .CCB [ISB$A_MAJ_F_PTR];
	    BMF [BSF$A_CUR_DTA] = .CCB [LUB$A_BUF_PTR] + 1;
	    END;


	!+
	! Convert the field that was found into internal format
	!-

	IF NOT (CASE .ELEM_TYPE
	    FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
	    SET
	    [INRANGE, OUTRANGE]:
		!+
		! Data types that are not yet supported
		!-
		BEGIN
		0
		END;
	    [DSC$K_DTYPE_W]:
		!+
		! Integer - word
		! Do the conversion of the value input and then range check
		! for overflow.
		!-

		BEGIN
		IF OTS$CVT_TI_L(DSC, ELEM[0], K_INT_SIZ, K_INT_FLAGS)
		THEN

		    !+
		    ! The conversion was successful.  Check the range of the
		    ! value input.  Signal an error or assume a value of success.
		    !-

		    IF .ELEM[0] GTR 32767
		     OR .ELEM[0] LSS -32768
		    THEN
			BAS$$STOP_IO (BAS$K_ILLNUM)
		    ELSE
			1		! signify success
		ELSE

		    !+
		    ! The conversion routine returned failure.  Assume a value of
		    ! failure.
		    !-

		    0
		END;
	    [DSC$K_DTYPE_L]:

		!+
		! Integer - longword.  Upper and lower bounds checking is performed
		! by the conversion routine.
		!-

		BEGIN
		OTS$CVT_TI_L(DSC, ELEM[0], K_INT_SIZ, K_INT_FLAGS)
		END;
	    [DSC$K_DTYPE_F]:
		!+
		! floating single precision
		!-
		BEGIN
		LOCAL
		    T_ELEM: VECTOR[2];	! temp. quadword work area
		IF OTS$CVT_T_D(DSC, T_ELEM, 0, 0, K_FLT_F_FLAGS)
		    THEN LIB$CVTDF(T_ELEM[0], ELEM[0])
		    ELSE 0
		END;
	    [DSC$K_DTYPE_D]:
		!+
		! double precision floating
		!-

		    BEGIN
		    LOCAL
			STATUS;
		    STATUS = OTS$CVT_T_D(DSC, ELEM[0], 0, .CCB [ISB$B_SCALE_FAC], K_FLT_D_FLAGS);
!+
! Truncate any fractional portion remaining if scaling is done.
!-
		    IF .CCB [ISB$B_SCALE_FAC] NEQ 0
		    THEN
			BEGIN
			MTH$DINT(ELEM [0]);
			    BEGIN
			    REGISTER
				R0 = 0,
				R1 = 1;
			    ELEM [0] = .R0;
			    ELEM [1] = .R1;
			    END;
			END;
		    .STATUS
		    END;
	    [DSC$K_DTYPE_T]:
		!+
		! String - no conversion - just return success
		!-
		BEGIN
		MAP
		    ELEM: REF BLOCK [8, BYTE];
		ELEM[DSC$W_LENGTH] = .DSC[DSC$W_LENGTH];
		1
		END;
		TES)
	    THEN
		BAS$$STOP_IO(BAS$K_DATFORERR);
    RETURN .RET_VAL;
    END;
    END
ELUDOM

