
MODULE BAS$OPEN (				! OPEN a BASIC channel
		IDENT = '1-090'			! File: BASOPEN.B32 Edit: PL1090
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  VAX-11 BASIC I/O Processing
!
! ABSTRACT:
!
!	This module contains the BAS$OPEN routine, which opens a file
!	for a VAX-11 BASIC program.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: John Sauter, CREATION DATE: 30-NOV-78
!
! MODIFIED BY:
!
! 1-001	- Original.  JBS 30-NOV-78
! 1-002	- Change REQUIRE file name from FOR... to OTS...  JBS 06-DEC-78
! 1-003	- Change OPEN$K symbols to LUB$K.  JBS 08-DEC-78
! 1-004	- REQUIRE BASOPN to get default record length.  JBS 12-DEC-78
! 1-005	- Call BAS$CB_PUSH and POP instead of FOR$$.  JBS 29-DEC-78
! 1-006	- Update this module to use the new OPEN calling sequence
!	   and semantics decided on in the 12-FEB-1979 meeting.
!	   JBS 14-FEB-1979
! 1-007	- Set LUB$V_USER_RBUF if the record buffer is taken from the
!	   MAP parameter instead of allocated from virtual storage.
!	   JBS 16-FEB-1979
! 1-008	- Clear the LOCATE bit in the RAB if the user provides his own
!	   buffer, so the data will always be placed in it.  JBS 19-FEB-1979
! 1-009	- Use I/O error codes from BASIOERR.REQ.  JBS 20-FEB-1979
! 1-010	- If the device being opened is a terminal, set the right
!	   margin based on the BLS field of the FAB.  JBS 22-FEB-1979
! 1-011	- Support the ALLOW SCRATCH clause; it implies no sharing.
!	   JBS 01-MAR-1979
! 1-012	- Add ORGANIZATION INDEXED.  JBS 08-MAR-1979
! 1-013	- Don't use summary XABs until I can learn how.  JBS 08-MAR-1979
! 1-014	- Set up the key buffer and size fields of the RAB.  JBS 26-MAR-1979
! 1-015	- If the user provides a MAP, null it.  JBS 04-APR-1979
! 1-016	- Accept key data types, if the user provides them.
!	   JBS 06-APR-1979
! 1-017	- Set up LUB$B_ORGAN on a new file.  JBS 06-APR-1979
! 1-018	- Verify keys properly for an existing indexed file.  JBS 06-APR-1979
! 1-019	- If we allocate a prompt buffer, set its current length
!	   to zero.  JBS 09-APR-1979
! 1-020	- OPEN on channel 0 gives an error message, and on any other
!	   open channel closes the channel first.  JBS 12-APR-1979
! 1-021	- The default record format for VIRTUAL files is FIXED.
!	   JBS 19-APR-1979
! 1-022	- Implement STREAM, since it is in the compiler.  Note: the
!	   rest of the RTL does not implement STREAM.  JBS 19-APR-1979
! 1-023	- Add LUB$B_RAT, for the FSP$ function.  JBS 19-APR-1979
! 1-024	- Add STATUS.  JBS 19-APR-1979
! 1-025	- Set LUB$V_TERM_FOR if this is a terminal format file.
!	   JBS 14-MAY-1979
! 1-026	- If RECORDSIZE is specified on a terminal format file, set
!	   the MARGIN and DEFAULT MARGIN to it.  JBS 18-MAY-1979
! 1-027	- Don't allow a recordsize of 0 on an old file.
!	   JBS 22-MAY-1979
! 1-028	- Set MRS to the computed record size, in case it defaulted.
!	   JBS 24-MAY-1979
! 1-029	- Correct an obvious bug in STATUS.  It has not been tested.
!	   JBS 24-MAY-1979
! 1-030	- Set LUB$V_FORCIBLE if the device is a terminal.
!	   JBS 24-MAY-1979
! 1-031	- Set RAB$V_UIF for virtual files.  JBS 25-MAY-1979
! 1-032	- Change from LUB$V_NO_KEYS to LUB$V_KEYED.  JBS 30-MAY-1979
! 1-033	- Change margin to 16 bits.  JBS 30-MAY-1979
! 1-034	- Add BAS$$STATU_INIT.  JBS 04-JUN-1979
! 1-035	- Set the language byte in the LUB, so only BASIC I/O
!	   statements can be used on files opened in BASIC.
!	   This restriction may be relaxed in some future
!	   release.  JBS 30-JUN-1979
! 1-036	- If the device is a terminal, change to PRN format so it
!	   is forcible.  JBS 10-JUL-1979
! 1-037	- Implement STREAM for real (see edit 022).  JBS 12-JUL-1979
! 1-038	- PRN files must be VFC format.  JBS 17-JUL-1979
! 1-039	- Add the unit number as the third argument to USEROPEN.
!	   JBS 25-JUL-1979
! 1-040	- Set up ISB$A_USER_FP.  JBS 25-JUL-1979
! 1-041	- Make LUB$Q_BFA_QUEUE empty.  JBS 30-JUL-1979
! 1-042	- Don't allow ACCESS READ to create a file. JBS 30-JUL-1979
! 1-043	- Make sure the LUB/ISB/RAB gets deallocated if we must
!	   "bail out".  JBS 31-JUL-1979
! 1-044	- Don't fool with LUB$B_RSL and LUB$A_RSN until we are sure
!	   the LUN is not open.  Any error messages should show the
!	   previous file name.  JBS 08-AUG-1979
! 1-045	- Set NOTSEQORG for all but terminal and sequential files,
!	   so BAS$$IO_BEG can use it.  JBS 08-AUG-1979
! 1-046	- If ACCESS READ, assume FOR INPUT.  JBS 08-AUG-1979
! 1-047	- Use the BASIC-specific exit handler.  JBS 17-AUG-1979
! 1-048	- Be sure to RMS close the file if an error is detected after
!	   the RMS OPEN is successful.  JBS 23-AUG-1979
! 1-049	- Rearrange MARGIN and RECORDSIZE defaults for compatability
!	   with the PDP-11.  Now, terminal format files on disk have
!	   margin of 72, whereas terminal format files on terminals
!	   have infinite margin.  JBS 24-AUG-1979
! 1-050	- Correct a typo in the computation of bucket size.  JBS 04-SEP-1979
! 1-051	- Disable locate mode until we get a chance to debug it.
!	   JBS 12-SEP-1979
! 1-052	- Remove STREAM and add record attributes.  JBS 13-SEP-1979
! 1-053	- Re-enable locate mode.  JBS 13-SEP-1979
! 1-054	- Deafult record atrribute for an old virtual file may be NONE or CR.
!	   JBS 15-SEP-1979
! 1-055	- Give an error message for the CONNECT clause until it is implemented.
!	   JBS 19-SEP-1979
! 1-056	- Remove references to LUB$Q_BFA_QUEUE, no longer needed.
!	   JBS 19-SEP-1979
! 1-057	- Implement CONNECT for indexed files.  JBS 30-SEP-1979
! 1-058	- Improve the error message for mismatch of record attributes.
!	   JBS 03-OCT-1979
! 1-059	- Don't demand any particular record format if the organization is
!	   is UNDEFINED.  JBS 12-OCT-1979
! 1-060	- Allow any record format, even UNDEFINED, if the organization is
!	   undefined.  JBS 12-OCT-1979
! 1-061	- If this is a VFC file, make sure the VFC field size is right.
!	   JBS 15-OCT-1979
! 1-062	- If the argument list says FOR OUTPUT, set the FAB$V_SUP bit, so
!	   that an explicit version number in the file name will delete
!	   and recreate an existing file.  QAR N11-02971  JBS 22-OCT-1979
! 1-063	- Round the block size up to a multiple of 4 bytes.  JBS 25-OCT-1979
! 1-064	- Fix an error message.  JBS 07-NOV-1979
! 1-065	- Improve the interface to USEROPEN.  JBS 07-NOV-1979
! 1-066	- Change virtual arrays to automatic record locking.  JBS 09-NOV-1979
! 1-067	- Set up LIB$A_UBF.  JBS 13-NOV-1979
! 1-068	- Make sure the record buffer is at least as large as the user's
!	   declared "buffer size", or the default for the organization,
!	   if none was declared.  JBS 27-NOV-1979
! 1-069 - Don't ever turn on RMS Locate Mode.  DGP 29-Nov-79
! 1-070	- Correct an error in edit 1-068.  JBS 05-DEC-1979
! 1-071	- If the record size test fails on an existing file, give error
!	   BAD RECORDSIZE VALUE ON OPEN rather than FILE ATTRIBUTES NOT
!	   MATCHED.  This error was found by FEATS.  JBS 28-DEC-1979
! 1-072 - Change "Run Time Syntax Error" to "Program Lost Sorry".  DGP 07-Jan-80
! 1-073 - Change OPEN_HANDLER to clean up the I/O data base before signalling
!	  in the event of a severe error.  DGP 08-Jan-80
! 1-074	- Complete edit 1-073.  JBS 09-JAN-1980
! 1-075	- Improve compatability with the PDP-11: round block size up to 20,
!	   don't set FAB$V_RWC and don't check FAB$B_RFM if it is defaulted.
!	   JBS 14-JAN-1980
! 1-076	- Another compatability change: If the ALLOW clause is omitted, let
!	   RMS default the FAB$B_SHR field.  JBS 15-JAN-1980
! 1-077	- The bucket size field is a word, not a byte.  JBS 01-FEB-1980
! 1-078 - Use 1 for default blocksize in Open.  DGP 12-Feb-1980
! 1-079 - Always round recordsize for virtual files to next higher multiple
!	  of 512.  Check file attributes against temp RSZ.  DGP 12-Feb-80
! 1-080	- Complete edit 1-079.  JBS 13-FEB-1980
! 1-081 - A Virtual file must be sequential and have fixed-length records.
!	   The buffer size (record size) must be greater than or equal to
!	   512 bytes.  If it is less, round it up unless the user supplied a
!	   map, in which case we have an error.  Round the record size down
!	   if necessary to make it even.  JBS 12-JUN-1980
! 1-082 - Put FAB$L_ALQ in LUB$L_ALQ and initialize LUB$L_REC_MAX. FM 22-SEP-80
! 1-083 - In order to be able to OPEN a spooled terminal just like any other
!	  terminal, make the $OPEN macro a $CREATE macro after we see that
!	  the file is a terminal and we close and reopen (reCREATE). FM 4-FEB-81
! 1-084 - If organization is UNDEFINED, and recordsize is 0 then signal
!	  BADRECVAL. FM 5-FEB-81
! 1-085 - Set FAC to null before invoking macro $FAB_INIT.  If this is not done
!	  the opener gets read access automatically.  PL 20-AUG-81
! 1-086 - Set FAB$V_MSE unconditionally if organization is indexed, so a 
!	  subsequent CONNECT can work.  Also, if caller is trying to CONNECT
!	  to a child, instead of a parent signal INVFILOPT.  FM 20-AUG-81
! 1-087 - LIB$STOP should be declared EXTERNAL.  PLL 20-Nov-81
! 1-088 - If the user specifies a recordsize less than the file record size,
!	  do not give an error.  PLL 13-Jan-82
! 1-089 - Check the recordsize of a variable length record file only if
!	  MRS is set.  PLL 22-Feb-82
! 1-090 - Check 089 should be made only if the file is opened for write access.
!	  Rather than checking the recordsize of a variable length record file,
!	  just let RMS catch the error.  PLL 9-Mar-1982
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';				! define linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$OPEN : NOVALUE,				! Open a file
    OPEN_HANDLER,				! Condition handler for OPEN
    BAS$STATUS,					! Status of last file opened
    BAS$$STATU_INIT : NOVALUE;			! Initialize status for RUN command

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';			! Macros for defining psects

REQUIRE 'RTLML:OTSLUB';				! Logical Unit Block definitions

REQUIRE 'RTLML:OTSISB';				! ISB definitions

REQUIRE 'RTLIN:BASOPN';				! OPEN literals

REQUIRE 'RTLIN:BASIOERR';			! I/O error codes

LIBRARY 'RTLSTARLE';				! system definitions

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!+
! The following symbols refer to arguments of BAS$OPEN.
!-

LITERAL
    OPN$K_ORG_TERMI = 0,			! no organization specified
    OPN$K_ORG_VIRTU = 1,			! ORGANIZATION VIRTUAL specified
    OPN$K_ORG_SEQUE = 2,			! ORGANIZATION SEQUENTIAL specified
    OPN$K_ORG_RELAT = 3,			! ORGANIZATION RELATIVE specified
    OPN$K_ORG_INDEX = 4,			! ORGANIZATION INDEXED specified
    OPN$K_ORG_UNDEF = 5,			! ORGANIZATION UNDEFINED specified
    OPN$K_ACC_DEFAU = 0,			! no access specified ( = MODIFY)
    OPN$K_ACC_MODIF = 1,			! ACCESS MODIFY specified
    OPN$K_ACC_WRITE = 2,			! ACCESS WRITE specified
    OPN$K_ACC_READ = 3,				! ACCESS READ specified
    OPN$K_ACC_SCRAT = 4,			! ACCESS SCRATCH specified
    OPN$K_ACC_APPEN = 5,			! ACCESS APPEND specified
    OPN$K_RFM_DEFAU = 0,			! record format not specified
    OPN$K_RFM_FIXED = 1,			! FIXED specified
    OPN$K_RFM_VARIA = 2,			! VARIABLE specified
    OPN$K_RFM_VFC = 3,				! VFC specified
    OPN$K_RFM_STREA = 4,			! STREAM specified
    OPN$K_ALL_DEFAU = 0,			! no ALLOW clause
    OPN$K_ALL_MODIF = 1,			! ALLOW MODIFY specified
    OPN$K_ALL_WRITE = 2,			! ALLOW WRITE specified
    OPN$K_ALL_READ = 3,				! ALLOW READ specified
    OPN$K_ALL_SCRAT = 4,			! ALLOW SCRATCH specified
    OPN$K_ALL_NONE = 6,				! ALLOW NONE specified
    OPN$K_RAT_DEFAU = 0,			! no RECORDATTR clause
    OPN$K_RAT_FORTR = 1,			! RECORDATTR FORTRAN specified
    OPN$K_RAT_CRLF = 2,				! RECORDATTR CRLF specified
    OPN$K_RAT_NONE = 3,				! RECORDATTR NONE specified
    OPN$K_RAT_PRINT = 4,			! RECORDATTR PRINT specified
    OPN$K_RAT_ANY = 5;				! RECORDATTR ANY specified

!+
! The following codes specify how OPEN_HANDLER is to act on an UNWIND.
!-

LITERAL
    UNWIND_MIN = 0,				! Minimum UNWIND code
    UNWIND_NOP = 0,				! Do nothing
    UNWIND_POP = 1,				! POP the CCB
    UNWIND_DEALLOC = 2,				! Deallocate (and POP) the CCB
    UNWIND_CLOSE = 3,				! RMS CLOSE the CCB, then deallocate and POP
    UNWIND_MAX = 3;				! Maximum UNWIND code

!
! PSECTS:
!
DECLARE_PSECTS (BAS);				! Declare psects for BAS$ facility
!
! OWN STORAGE:
!

OWN
    L_STATUS : INITIAL (0);			! Status of last file opened.

!
! EXTERNAL REFERENCES:
!

EXTERNAL
    BAS$$L_XIT_LOCK;				! Once-only flag for the exit handler.

EXTERNAL ROUTINE
    LIB$STOP : NOVALUE,				! Signal fatal error
    BAS$$STOP : NOVALUE,			! Signals fatal error
    BAS$$STOP_IO : NOVALUE,			! Signals fatal I/O error
    BAS$$CB_PUSH : JSB_CB_PUSH NOVALUE,		! loads register CCB
    BAS$$CB_POP : JSB_CB_POP NOVALUE,		! completes LUN processing
    LIB$GET_VM,					! get virtual storage
    LIB$FREE_VM,				! free virtual storage
    BAS$$DECL_EXITH : NOVALUE,			! Declare exit handler
    OTS$$TAKE_LUN,				! Sign out a logical unit number
    OTS$$CLOSE_FILE,				! RMS Close a file
    LIB$MATCH_COND;				! Match a condition code

!+
! The following are the error codes used in this module.
!-

EXTERNAL LITERAL
    BAS$K_PROLOSSOR : UNSIGNED (8),		! Program lost, sorry
    BAS$K_ILLILLACC : UNSIGNED (8),		! Illegal or illogical access
    BAS$K_ILLIO_CHA : UNSIGNED (8),		! Illegal I/O channel
    BAS$K_IO_CHAALR : UNSIGNED (8),		! I/O channel already open
    BAS$K_FATSYSIO_ : UNSIGNED (8),		! Fatal system I/O error
    BAS$K_FILATTNOT : UNSIGNED (8),		! File attributes not matched
    BAS$K_RECATTNOT : UNSIGNED (8),		! Record attributes not matched
    BAS$K_MAXMEMEXC : UNSIGNED (8),		! Maximum memory exceeded
    BAS$K_BADRECVAL : UNSIGNED (8),		! Bad recordsize value on OPEN
    BAS$K_NOTIMP : UNSIGNED (8),		! Not implemented
    BAS$K_INVFILOPT : UNSIGNED (8),		! Invalid file option
    BAS$K_IO_CHANOT : UNSIGNED (8);		! I/O Channel not open

!<BLF/PAGE>

!+
! The following FIELD describes the OPEN_ARG_BLK argument of
! BAS$OPEN.
!-

FIELD
    OPN$ARG_BLOCK =
	SET
	OPN$B_CNT = [0, 0, 8, 0],		! number of remaining bytes
	OPN$B_ORG = [1, 0, 8, 1],		! ORGANIZATION clause
	OPN$B_ACCESS = [2, 0, 8, 1],		! ACCESS clause
	OPN$B_RFM = [3, 0, 8, 1],		! record format
	OPN$B_ALLOW = [4, 0, 8, 1],		! ALLOW clause
	OPN$V_NOSPAN = [5, 0, 1, 0],		! NO SPAN specified
	OPN$V_CONTIGUOU = [5, 1, 1, 0],		! CONTIGUOUS specified
	OPN$V_NO_REWIND = [5, 2, 1, 0],		! NO REWIND specified
	OPN$V_TEMPORARY = [5, 3, 1, 0],		! TEMPORARY specified
	OPN$V_FOR_OUTPU = [5, 4, 1, 0],		! FOR OUTPUT specified
	OPN$V_FOR_INPUT = [5, 5, 1, 0],		! FOR INPUT specified
	OPN$V_CHAN_REF = [5, 6, 1, 0],		! OPN$L_CHANNEL points to channel number
	OPN$V_CHAN_WORD = [5, 7, 1, 0],		! Channel is 16 bits (ref only)
	OPN$B_RAT = [6, 0, 8, 1],		! RECORDATTR clause
	OPN$B_FSZ = [7, 0, 8, 0],		! Size of VFC buffer
	OPN$T_FILE_SPEC = [8, 0, %BPADDR, 0],	! descriptor for file name string
	OPN$W_RECORDSIZ = [12, 0, 16, 0],	! size of record buffer in bytes
	OPN$W_BLOCKSIZE = [14, 0, 16, 0],	! size of magtape block in bytes
	OPN$A_MAP = [16, 0, %BPADDR, 0],	! address of user record buffer
	OPN$L_FILESIZE = [20, 0, %BPVAL, 1],	! size of file in blocks
	OPN$W_EXTENDSIZ = [24, 0, 16, 1],	! extend size
	OPN$W_BUCKETSIZ = [26, 0, 16, 1],	! bucket size in records
	OPN$B_WINDOWSIZ = [28, 0, 8, 1],	! number of retrieval pointers
	OPN$W_CONNECT = [30, 0, 16, 1],		! channel (LUN) to connect to
	OPN$B_MULTIBUFF = [32, 0, 8, 1],	! number of I/O buffers
	OPN$T_DEFAULTNA = [36, 0, %BPADDR, 0],	! default name string descriptor
	OPN$A_USEROPEN = [40, 0, %BPADDR, 0],	! address of user open procedure
	OPN$L_CHANNEL = [44, 0, %BPVAL, 0],	! Channel number, or its address
	OPN$A_VFC = [48, 0, %BPADDR, 0]		! Address of VFC buffer
	TES;

!+
! The following two fields describe the header on the KEY_INFO_BLK parameter
! and each key, respectively.
!-

FIELD
    OPN$KEYH_BLOCK =
	SET
	KEYH$B_KEYNUM = [0, 0, 8, 0],		! Number of keys in this block
	KEYH$B_LEN = [1, 0, 8, 0]		! Length of each KEY field
	TES;

LITERAL
    KEYH$K_LENGTH = 4;				! Length of the key header

FIELD
    OPN$KEY_BLOCK =
	SET
	KEY$B_LEN = [0, 0, 8, 0],		! Length of this key
	KEY$B_FLAGS = [1, 0, 8, 0],		! Flags, as follows:
	KEY$V_DUP = [1, 0, 1, 0],		! If set, duplicates are allowed
	KEY$V_CHG = [1, 1, 1, 0],		! If set, changes are allowed
	KEY$W_OFFSET = [2, 0, 16, 0],		! Offset of this key in the record
	KEY$B_DTYPE = [4, 0, 8, 0]		! Data type of key
	TES;


GLOBAL ROUTINE BAS$OPEN (			! Open a file
	OPEN_ARG_BLK, 				! Argument list
	KEY_INFO_BLK				! Keys for ISAM
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Open a file for BASIC.  This will always be an RMS file.
!	Not all combinations of input options are valid.
!
! FORMAL PARAMETERS:
!
!	OPEN_ARG_BLK.mz.r	A long list of OPEN options.
!	KEY_INFO_BLK.rl.ra	The keys, for ISAM opens.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	A lot of fields in the LUB.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Either opens a file, thus permitting use of the channel number
!	by BASIC I/O statements, or calls BAS$$STOP, thus not returning
!	to its caller.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    MAP
	OPEN_ARG_BLK : REF BLOCK [0, BYTE] FIELD (OPN$ARG_BLOCK),
	KEY_INFO_BLK : REF BLOCK [0, BYTE] FIELD (OPN$KEYH_BLOCK);

    LOCAL
	RSZ,					! Computed record size
	BKS,					! Computed bucket size
	BLS,					! Computed blocksize
	OPEN_STATUS,				! RMS status returned by $OPEN
	CONNECT_STATUS,				! RMS status returned by $CONNECT
	CHANNEL,				! The channel number
	FAB_BLOCK : $FAB_DECL,			! local FAB
	FAB : REF $FAB_DECL,			! pointer to FAB
	NAM_BLOCK : $NAM_DECL,			! local NAM block
	XABFHC : $XABFHC_DECL,			! local XABFHC block
	XABSUM : $XABSUM_DECL,			! local XABSUM block
	FILE_NAME_DESC : REF BLOCK [0, BYTE],	! descriptor for file name
	FILE_NAME : BLOCK [NAM$C_MAXRSS, BYTE],	! text for file name
	UNWIND_ACTION : VOLATILE,		! What to do on UNWIND
	UNWIND_CCB : VOLATILE;			! What CCB to do it to

    GLOBAL REGISTER
	CCB = K_CCB_REG : REF BLOCK [0, BYTE];	! points to LUB

!+
! Maintenance note: When detecting an error, the best routine to call is
! BAS$$STOP_IO, since it will print the channel number and file name.
! However, it should not be called until after the file name and channel
! number are stored in the LUB and FAB.  The best time to call BAS$$STOP_IO
! is after the RMS $OPEN, since the file name will then be the resultant or
! expanded name from RMS, which will have defaults merged and logical names
! translated.  Thus, defering recognizing errors until after the RMS $OPEN
! is worth while.  Of course, some errors cannot reasonably be deferred to
! that point, such as a channel number being out of range, and for these
! the BAS$$STOP routine is used to signal errors.
!-
!+
! Set up condition handler for UNWINDs
!-

    ENABLE
	OPEN_HANDLER (UNWIND_ACTION, UNWIND_CCB);

!+
! Initial action is NOP
!-
    UNWIND_ACTION = UNWIND_NOP;
!+
! Fetch the channel number from the user.  Later we may need the
! address.
!-
    CHANNEL = .OPEN_ARG_BLK [OPN$L_CHANNEL];

    IF (.OPEN_ARG_BLK [OPN$V_CHAN_REF])
    THEN

	IF (.OPEN_ARG_BLK [OPN$V_CHAN_WORD])
	THEN
	    CHANNEL = .BLOCK [.CHANNEL, 0, 0, 16, 1]
	ELSE
	    CHANNEL = .BLOCK [.CHANNEL, 0, 0, %BPVAL, 1];

!+
! If the channel number is negative or too large, we have a fatal error.
!-

    IF ((.CHANNEL LSS LUB$K_LUN_MIN) OR (.CHANNEL GTR LUB$K_LUN_MAX)) THEN BAS$$STOP (BAS$K_ILLIO_CHA);

!+
! If the channel number is zero, the OPEN fails.
!-

    IF (.CHANNEL EQL 0) THEN BAS$$STOP (BAS$K_ILLIO_CHA);

!+
! Compute some auxiliary variables which we will need later.
!-
    RSZ = .OPEN_ARG_BLK [OPN$W_RECORDSIZ];

    IF (.RSZ EQL 0)
    THEN
!+
! Provide a reasonable default value for the record size, when we
! can determine one.
!-
	RSZ = (CASE .OPEN_ARG_BLK [OPN$B_ORG] FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	    SET
	    [OPN$K_ORG_TERMI, OPN$K_ORG_SEQUE] : BAS$K_DEF_RECLE;
	    [OPN$K_ORG_VIRTU] : 512;
	    [INRANGE, OUTRANGE] : 0;
	    TES)
    ELSE
!+
! For virtual files, round the record size down if necessary to make
! it even.
!-

	IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_VIRTU)
	THEN
	    BEGIN
	    RSZ = (.RSZ AND -2);
!+
! If there is no map, round the record size up to 512 if it is less.
! We don't want to give an error message here because the file name is
! not yet set up and the error message needs to include the file name,
! so we don't check here for having a map less than
! 512 bytes long; instead a check is made after the RMS $OPEN for the
! record size still being less than 512 bytes.
!-

	    IF (.OPEN_ARG_BLK [OPN$A_MAP] EQLA 0) THEN RSZ = MAX (.RSZ, 512);

	    END;

    BKS = .OPEN_ARG_BLK [OPN$W_BUCKETSIZ];

    IF (.BKS NEQ 0)
    THEN
!+
! Compute the bucket size in RMS terms
!-
	BKS = (511 + (.BKS*(.RSZ +
	BEGIN

	IF (.OPEN_ARG_BLK [OPN$B_RFM] EQL OPN$K_RFM_VARIA) THEN 2 ELSE 0

	END
	+
	BEGIN

	IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX) THEN 7 ELSE 1

	END
	)) +
	BEGIN

	IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX) THEN 15 ELSE 0

	END
	)/512;

!+
! Compute the block size in RMS terms in case this is a new file on mag tape.
! The size is rounded up to the nearest 4 bytes for compatability with the
! PDP-11.
!-
    BLS = MAX ((((MAX (1, .OPEN_ARG_BLK [OPN$W_BLOCKSIZE])*
	BEGIN

	IF (.OPEN_ARG_BLK [OPN$B_RFM] EQL OPN$K_RFM_VARIA) THEN .RSZ + 4 ELSE .RSZ

	END
	) + 3) AND ( NOT 3)), 20);
!+
! Allocate the LUB, ISB and RAB if they have not already been
! allocated for this LUN.  Push down if there is already an I/O
! statement in progress on another unit.  On return, CCB points
! to the current control block.
!-
    BAS$$CB_PUSH (.CHANNEL, LUB$K_LUN_MIN);
!+
! Arrange to POP the CCB if we get an error.
!-
    UNWIND_CCB = .CCB;
    UNWIND_ACTION = UNWIND_POP;
!+
! If the LUN is already open, close it.  The call to BAS$$STOP_IO here
! will print the former file name (that is, the name of the file that
! could not be closed).
!-

    IF (.CCB [LUB$V_OPENED])
    THEN
	BEGIN

	IF ( NOT OTS$$CLOSE_FILE ()) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

!+
! We must drop R11 and pick it back up so that the CLOSE can complete.
! Otherwise the CLOSE will 'hang fire' until the recursive I/O is
! done.
!-
	BAS$$CB_POP ();
	BAS$$CB_PUSH (.CHANNEL, LUB$K_LUN_MIN);
	END;

!+
! If the channel is still open (possibly due to recursive I/O), fail.
! Also fail if there is a FAB associated with the LUB, which means that
! the FORTRAN compatability routines have been called to provide implicit
! inputs to OPEN.  Again, the call to BAS$$STOP_IO will print the former
! file name.
!-

    IF (.CCB [LUB$V_OPENED] OR .CCB [LUB$V_DEALLOC] OR (.CCB [LUB$A_FAB] NEQA 0))
    THEN
	BAS$$STOP_IO (BAS$K_IO_CHAALR);

!+
! Make sure the file name fields are set up, in case of an error.
! From here to the RMS $OPEN, a call to BAS$$STOP_IO will print the name
! of this file, as supplied in the call.
!-
    FILE_NAME_DESC = .OPEN_ARG_BLK [OPN$T_FILE_SPEC];
    CCB [LUB$A_RSN] = .FILE_NAME_DESC [DSC$A_POINTER];
    CCB [LUB$B_RSL] = MIN (.FILE_NAME_DESC [DSC$W_LENGTH], 255);
!+
! Sign out the logical unit number, so an AST won't try to open it.
!-

    IF ( NOT OTS$$TAKE_LUN (CHANNEL)) THEN BAS$$STOP_IO (BAS$K_IO_CHAALR);

!+
! Now that we are sure the CCB is ours, if we get an error, deallocate it.
!-
    UNWIND_ACTION = UNWIND_DEALLOC;
!<BLF/PAGE>

!+
! Set up the FAB.  The fields are set up in alphabetical order.
!-
    FAB = FAB_BLOCK;
    $FAB_INIT (FAB = .FAB, FAC = );
    FAB [FAB$L_ALQ] = .OPEN_ARG_BLK [OPN$L_FILESIZE];	! length of file in blocks

    IF ((.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_RELAT) OR (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX))
    THEN
	FAB [FAB$B_BKS] = MIN (255, .BKS);	! number of blocks in each bucket

    IF ( NOT ((.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_RELAT)	!
	OR (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX)))
    THEN
	FAB [FAB$W_BLS] = .BLS;			! mag tape block size

    FAB [FAB$W_DEQ] = .OPEN_ARG_BLK [OPN$W_EXTENDSIZ];	! blocks to add when extending file
!+
! Store pointer to default file name, as specified by the user.
!-
    FILE_NAME_DESC = .OPEN_ARG_BLK [OPN$T_DEFAULTNA];

    IF (.FILE_NAME_DESC NEQ 0)
    THEN
	BEGIN
	FAB [FAB$L_DNA] = .FILE_NAME_DESC [DSC$A_POINTER];
	FAB [FAB$B_DNS] = MIN (255, .FILE_NAME_DESC [DSC$W_LENGTH]);
	END;

!+
! Set the FAC field.
!-

    SELECT (.OPEN_ARG_BLK [OPN$B_ACCESS]) OF
	SET

	[OPN$K_ACC_DEFAU, OPN$K_ACC_MODIF] :
	    FAB [FAB$V_DEL] = 1;		! allow deletion of records

	[OPN$K_ACC_DEFAU, OPN$K_ACC_READ, OPN$K_ACC_MODIF, OPN$K_ACC_SCRAT] :
	    FAB [FAB$V_GET] = 1;		! allow reading records

	[OPN$K_ACC_DEFAU, OPN$K_ACC_WRITE, OPN$K_ACC_MODIF, OPN$K_ACC_SCRAT, OPN$K_ACC_APPEN] :
	    FAB [FAB$V_PUT] = 1;		! allow writing records

	[OPN$K_ACC_SCRAT] :
	    FAB [FAB$V_TRN] = 1;		! allow truncate (scratch)

	[OPN$K_ACC_DEFAU, OPN$K_ACC_MODIF, OPN$K_ACC_SCRAT] :
	    FAB [FAB$V_UPD] = 1;		! allow updating records

	[OTHERWISE] :
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	TES;

!+
! Store pointer to file name, as specified by the user.
!-
    FILE_NAME_DESC = .OPEN_ARG_BLK [OPN$T_FILE_SPEC];
    FAB [FAB$L_FNA] = .FILE_NAME_DESC [DSC$A_POINTER];
    FAB [FAB$B_FNS] = MIN (255, .FILE_NAME_DESC [DSC$W_LENGTH]);
!+
! Set up the FOP field.
!-
!+
! If the user specified a file size but did not say CONTIGUOUS, do a
! "best effort" attempt to get contiguous space.  This is compatable
! with FORTRAN.
! Note: this code has been disabled pending review.  Because a search
! is made for the requested space, this could cause a performance
! problem.
!-
    %(
    IF ((.OPEN_ARG_BLK [OPN$L_FILESIZE] NEQ 0) AND ( NOT .OPEN_ARG_BLK [OPN$V_CONTIGUOU]))
    THEN
	FAB [FAB$V_CBT] = 1;
    )%
!+
! If the user specified neither FOR INPUT nor FOR OUTPUT, then set
! the CIF bit, so that the $CREATE system service will use an
! existing file if one is present.  (Otherwise it will create a new
! file, as usual.)
!-

    IF ( NOT (.OPEN_ARG_BLK [OPN$V_FOR_INPUT] OR .OPEN_ARG_BLK [OPN$V_FOR_OUTPU])) THEN FAB [FAB$V_CIF] = 1;

!+
! Set the 'contiguous best try' flag if the user said CONTIGUOUS.
!	( Perhaps we should set CTG? )
!-

    IF (.OPEN_ARG_BLK [OPN$V_CONTIGUOU]) THEN FAB [FAB$V_CBT] = 1;

!+
! Set "deferred write" unless the ALLOW option implies sharing which
! does not permit it.
!-

    IF ((.OPEN_ARG_BLK [OPN$B_ALLOW] NEQ OPN$K_ALL_WRITE) AND (.OPEN_ARG_BLK [OPN$B_ALLOW] NEQ
	OPN$K_ALL_MODIF))
    THEN
	FAB [FAB$V_DFW] = 1;

!+
! If the user did not say APPEND, set the NEF flag to prevent
! positioning a mag tape to end-of-file on open.
!-

    IF (.OPEN_ARG_BLK [OPN$B_ACCESS] NEQ OPN$K_ACC_APPEN) THEN FAB [FAB$V_NEF] = 1;

!+
! If NOREWIND is not specified, cause the tape to rewind on open.
!-

    IF ( NOT .OPEN_ARG_BLK [OPN$V_NO_REWIND]) THEN FAB [FAB$V_RWO] = 1;

!+
! In terminal format files, only sequential operations are allowed.
! Tell RMS that we will only be doing sequential operations in case
! it can gain some efficiency by knowing this.
!-

    IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_TERMI) THEN FAB [FAB$V_SQO] = 1;

!+
! If the user said "FOR OUTPUT", set the SUP bit so that the $CREATE will
! supercede any existing file.  Note that this will happen only if a version
! number is specified, since the default for the version number on $CREATE is
! the next higher number.
!-

    IF (.OPEN_ARG_BLK [OPN$V_FOR_OUTPU]) THEN FAB [FAB$V_SUP] = 1;

!+
! If the user said TEMPORARY, mark the file as "temporary, delete when
! closed".
!-

    IF (.OPEN_ARG_BLK [OPN$V_TEMPORARY]) THEN FAB [FAB$V_TMD] = 1;

    FAB [FAB$B_FSZ] = .OPEN_ARG_BLK [OPN$B_FSZ];
    FAB [FAB$W_MRS] = .RSZ;
!+
! Set up ORG field
!-

    CASE (.OPEN_ARG_BLK [OPN$B_ORG]) FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	SET

	[OPN$K_ORG_TERMI] : 			! Terminal format file
	    FAB [FAB$B_ORG] = FAB$C_SEQ;

	[OPN$K_ORG_VIRTU] : 			! Virtual array file
	    FAB [FAB$B_ORG] = FAB$C_SEQ;

	[OPN$K_ORG_SEQUE] : 			! Sequential file
	    FAB [FAB$B_ORG] = FAB$C_SEQ;

	[OPN$K_ORG_RELAT] : 			! Relative file
	    FAB [FAB$B_ORG] = FAB$C_REL;

	[OPN$K_ORG_INDEX] : 			! Indexed file
	    FAB [FAB$B_ORG] = FAB$C_IDX;

	[OPN$K_ORG_UNDEF] : 			! Unspecified organization
	    FAB [FAB$B_ORG] = FAB$C_SEQ;

	[OUTRANGE] :
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	TES;

!+
! Set up RAT field.  PRN will be set after OPEN if this is a terminal device and a
! terminal format file with default record attributes.
!-

    IF (.OPEN_ARG_BLK [OPN$V_NOSPAN]) THEN FAB [FAB$V_BLK] = 1;

    CASE .OPEN_ARG_BLK [OPN$B_RAT] FROM OPN$K_RAT_DEFAU TO OPN$K_RAT_ANY OF
	SET

	[OPN$K_RAT_DEFAU, OPN$K_RAT_ANY] :

	    IF (.OPEN_ARG_BLK [OPN$B_ORG] NEQ OPN$K_ORG_VIRTU) THEN FAB [FAB$V_CR] = 1;

	[OPN$K_RAT_FORTR] :
	    FAB [FAB$V_FTN] = 1;

	[OPN$K_RAT_CRLF] :
	    FAB [FAB$V_CR] = 1;

	[OPN$K_RAT_NONE] :
	    BEGIN
	    0
	    END;

	[OPN$K_RAT_PRINT] :
	    FAB [FAB$V_PRN] = 1;

	[OUTRANGE] :
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	TES;

!+
! Set up the RFM field.
!-

    CASE (.OPEN_ARG_BLK [OPN$B_RFM]) FROM OPN$K_RFM_DEFAU TO OPN$K_RFM_STREA OF
	SET

	[OPN$K_RFM_DEFAU] : 			! Default to variable unless VIRTUAL
	    FAB [FAB$B_RFM] =
	    BEGIN

	    IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_VIRTU) THEN FAB$C_FIX ELSE FAB$C_VAR

	    END;

	[OPN$K_RFM_FIXED] :
	    FAB [FAB$B_RFM] = FAB$C_FIX;	! fixed-length record format

	[OPN$K_RFM_VARIA] :
	    FAB [FAB$B_RFM] = FAB$C_VAR;	! variable-length record format

	[OPN$K_RFM_VFC] :
	    FAB [FAB$B_RFM] = FAB$C_VFC;	! variable-length with fixed control record format

	[OPN$K_RFM_STREA, OUTRANGE] :
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	TES;

    FAB [FAB$B_RTV] = .OPEN_ARG_BLK [OPN$B_WINDOWSIZ];
!+
! Set the SHR field.  Note that no bits are set in the default case, which causes
! RMS to default sharing based on how the file is to be used: read sharing if we
! are only reading the file, no sharing otherwise.
!-

    SELECT (.OPEN_ARG_BLK [OPN$B_ALLOW]) OF
	SET

	[OPN$K_ALL_MODIF] :
	    FAB [FAB$V_SHRDEL] = 1;		! allow sharers to delete

	[OPN$K_ALL_READ, OPN$K_ALL_MODIF] :
	    FAB [FAB$V_SHRGET] = 1;		! allow sharers to read

	[OPN$K_ALL_NONE, OPN$K_ALL_SCRAT] :
	    FAB [FAB$V_NIL] = 1;		! forbid sharing

	[OPN$K_ALL_MODIF, OPN$K_ALL_WRITE] :
	    FAB [FAB$V_SHRPUT] = 1;		! allow sharers to write

	[OPN$K_ALL_MODIF] :
	    FAB [FAB$V_SHRUPD] = 1;		! allow sharers to update

	[OPN$K_ALL_DEFAU] : 			! use RMS defaults: don't set FAB$B_SHR field
	    BEGIN
	    0
	    END;

	[OTHERWISE] :
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	TES;

!+
! If organization is indexed then set FAB$V_MSE unconditionally.
!-
    IF .OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX THEN FAB [FAB$V_MSE] = 1;

!<BLF/PAGE>

!+
! Set up the LUB.
!-
    CCB [LUB$A_FAB] = .FAB;			! store pointer to FAB in LUB
!+
! Store pointer to user-supplied file name in LUB for error processing
!-
    CCB [LUB$A_RSN] = .FAB [FAB$L_FNA];
    CCB [LUB$B_RSL] = .FAB [FAB$B_FNS];
!+
! Set the READ_ONLY, SCRATCH and APPEND bits in the LUB based on the
! access.  If READ_ONLY is set, set OLD_FILE, since there is no point
! in creating a file which can only be read.
!-

    CASE (.OPEN_ARG_BLK [OPN$B_ACCESS]) FROM OPN$K_ACC_DEFAU TO OPN$K_ACC_APPEN OF
	SET

	[OPN$K_ACC_DEFAU, OPN$K_ACC_MODIF, OPN$K_ACC_WRITE] :
	    BEGIN				! set none of the three bits
	    CCB [LUB$V_READ_ONLY] = 0;
	    CCB [LUB$V_SCRATCH] = 0;
	    CCB [LUB$V_APPEND] = 0;
	    END;

	[OPN$K_ACC_READ] :
	    BEGIN				! set READ_ONLY
	    CCB [LUB$V_OLD_FILE] = 1;		! Do not create file
	    CCB [LUB$V_READ_ONLY] = 1;
	    CCB [LUB$V_SCRATCH] = 0;
	    CCB [LUB$V_APPEND] = 0;
	    END;

	[OPN$K_ACC_SCRAT] :
	    BEGIN				! set SCRATCH
	    CCB [LUB$V_READ_ONLY] = 0;
	    CCB [LUB$V_SCRATCH] = 1;
	    CCB [LUB$V_APPEND] = 0;
	    END;

	[OPN$K_ACC_APPEN] :
	    BEGIN				! set APPEND.  It will be cleared if the file is NEW
	    CCB [LUB$V_READ_ONLY] = 0;
	    CCB [LUB$V_SCRATCH] = 0;
	    CCB [LUB$V_APPEND] = 1;
	    END;
	TES;

!+
! Set the "not sequential" flag in the LUB based on the file organization.
!-

    CASE (.OPEN_ARG_BLK [OPN$B_ORG]) FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	SET

	[OPN$K_ORG_TERMI, OPN$K_ORG_SEQUE] :
	    CCB [LUB$V_NOTSEQORG] = 0;

	[OPN$K_ORG_RELAT, OPN$K_ORG_INDEX, OPN$K_ORG_VIRTU, OPN$K_ORG_UNDEF] :
	    CCB [LUB$V_NOTSEQORG] = 1;
	TES;

!+
! Set the 'formatted' and 'unformatted' bits in the LUB.
! These bits are used only by FORTRAN I/O statements.
!-

    CASE (.OPEN_ARG_BLK [OPN$B_ORG]) FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	SET

	[OPN$K_ORG_TERMI, OPN$K_ORG_SEQUE, OPN$K_ORG_RELAT, OPN$K_ORG_INDEX] :
	    CCB [LUB$V_FORMATTED] = 1;

	[OPN$K_ORG_VIRTU, OPN$K_ORG_UNDEF] :
	    CCB [LUB$V_UNFORMAT] = 1;
	TES;

!+
! Set the 'fixed' flag in the LUB.
!-

    IF (.FAB [FAB$B_RFM] EQL FAB$C_FIX) THEN CCB [LUB$V_FIXED] = 1;

!+
! Set the 'old file' flag in the LUB.
! It will also be set after the $OPEN if the file turns out to already
! exist.
!-

    IF (.OPEN_ARG_BLK [OPN$V_FOR_INPUT]) THEN CCB [LUB$V_OLD_FILE] = 1;

!+
! Set the 'direct' flag in the LUB.  This is used only by FORTRAN I/O.
!-

    CASE (.OPEN_ARG_BLK [OPN$B_ORG]) FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	SET

	[OPN$K_ORG_TERMI, OPN$K_ORG_SEQUE, OPN$K_ORG_RELAT, OPN$K_ORG_INDEX] :
	    CCB [LUB$V_DIRECT] = 0;		! not direct access

	[OPN$K_ORG_VIRTU, OPN$K_ORG_UNDEF] :
	    CCB [LUB$V_DIRECT] = 1;		! direct access.  Assigning UNDEF here is arbitrary.
	TES;

!+
! Set up the right margin and default right margin.
!-

    CASE (.OPEN_ARG_BLK [OPN$B_ORG]) FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	SET

	[OPN$K_ORG_TERMI] :
	    BEGIN
!+
! Terminal format file.  We assume that this will be a disk file.  If it turns out
! to be a terminal, the margin will be reset to "infinite" after the OPEN.
!-
	    CCB [LUB$W_D_MARGIN] =
	    BEGIN

	    IF (.OPEN_ARG_BLK [OPN$W_RECORDSIZ] NEQ 0)
	    THEN
		.OPEN_ARG_BLK [OPN$W_RECORDSIZ]
	    ELSE
		LUB$K_D_MARGIN

	    END;
	    CCB [LUB$W_R_MARGIN] = .CCB [LUB$W_D_MARGIN];
	    CCB [LUB$V_NOMARGIN] = 0;
	    END;

	[INRANGE] :
	    BEGIN
!+
! This is not a terminal format file.  The margin is only important for sequential files,
! so we will set up the margin for sequential files.
!-
	    CCB [LUB$W_D_MARGIN] =
	    BEGIN

	    IF (.OPEN_ARG_BLK [OPN$W_RECORDSIZ] NEQ 0)
	    THEN
		.OPEN_ARG_BLK [OPN$W_RECORDSIZ]
	    ELSE
		LUB$K_D_MARGIN

	    END;
	    CCB [LUB$W_R_MARGIN] = 0;
	    CCB [LUB$V_NOMARGIN] = 1;
	    END;

	[OUTRANGE] :
	    BAS$$STOP_IO (BAS$K_PROLOSSOR);
	TES;

!+
! Set a flag in the LUB if this file was opened with  keys.  This
! is important for processing indexed files.
!-
    CCB [LUB$V_KEYED] = (ACTUALCOUNT () GEQ 2);
!+
! Set a flag in the LUB if this is a multi-stream connect.
!-

    IF (.OPEN_ARG_BLK [OPN$W_CONNECT] NEQ 0)
    THEN
	BEGIN

	IF (.OPEN_ARG_BLK [OPN$B_ORG] NEQ OPN$K_ORG_INDEX)
	THEN
	    BAS$$STOP_IO (BAS$K_NOTIMP)
	ELSE
	    CCB [LUB$V_M_STREAM] = 1;

	END
    ELSE
	CCB [LUB$V_M_STREAM] = 0;

!+
! Set the terminal format file bit in the LUB if this is a terminal
! format file.  This is used to bias RECOUNT.
!-

    IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_TERMI) THEN CCB [LUB$V_TERM_FOR] = 1;

!<BLF/PAGE>

!+
! Set up the RAB.
!-
    CCB [RAB$B_BID] = RAB$C_BID;		! this is a RAB
    CCB [RAB$B_BLN] = RAB$C_BLN;		! length of a RAB
    CCB [RAB$L_FAB] = .FAB;			! pointer to File Access Block
!+
! Set up the key buffer and size fields.  If this is a terminal device
! these will be overwritten by the prompt buffer and size fields,
! but this is OK, since you cannot do keyed access to a terminal device.
!-
    CCB [RAB$L_KBF] = CCB [LUB$L_LOG_RECNO];
    CCB [RAB$B_KSZ] = 4;
    CCB [RAB$B_MBF] = .OPEN_ARG_BLK [OPN$B_MULTIBUFF];	! number of buffers

    IF (.OPEN_ARG_BLK [OPN$B_FSZ] NEQ 0) THEN CCB [RAB$L_RHB] = .OPEN_ARG_BLK [OPN$A_VFC];

!+
! Set up the ROP field.
!-
!+
! If we are to append to the file, position to EOF when opening it.
!-

    IF (.OPEN_ARG_BLK [OPN$B_ACCESS] EQL OPN$K_ACC_APPEN) THEN CCB [RAB$V_EOF] = 1;

!+
! Always turn off Locate mode.  This is done because GETs of variable length
! records are to null fill the remainder of the buffer.  This cannot be done
! if the data is in an RMS buffer in system space.
!-
    CCB [RAB$V_LOC] = 0;
!+
! Don't truncate the file on a PUT to its middle; give an error message
! instead.
!-
    CCB [RAB$V_TPT] = 0;
!+
! Don't convert PUT to UPDATE except on VIRTUAL files.  If the user wants
! to do an UPDATE to any other kind of file, he must issue an explicit
! UPDATE statement.
!-
    CCB [RAB$V_UIF] = (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_VIRTU);
!+
! Initialize the local NAM block and point the FAB to it so that
! RMS will return the full name of the file being accessed.  This
! will improve error messages.
!-
    $NAM_INIT (NAM = NAM_BLOCK);
    NAM_BLOCK [NAM$L_RSA] = NAM_BLOCK [NAM$L_ESA] = FILE_NAME;
    NAM_BLOCK [NAM$B_RSS] = NAM_BLOCK [NAM$B_ESS] = NAM$C_MAXRSS;
    FAB [FAB$L_NAM] = NAM_BLOCK;
!+
! Initialize the local FHC XAB and point the FAB to it.  This is
! used to get the size of the longest record in an old file, so
! that the buffer size can be defaulted properly.
!-
    $XABFHC_INIT (XAB = XABFHC);
    XABFHC [XAB$L_NXT] = .FAB [FAB$L_XAB];
    FAB [FAB$L_XAB] = XABFHC;			! link FAB to XAB
!+
! Initialize the KEY XABs if any keys are provided in this call to OPEN.
!-

    IF (ACTUALCOUNT () GEQ 2)
    THEN
	BEGIN

	LOCAL
	    KEY_PTR : REF BLOCK [, BYTE] FIELD (OPN$KEY_BLOCK),
	    XABKEY : REF $XABKEY_DECL;

!+
! The keys are arranged in order by key number.
! They are allocated in reverse order because RMS-32 requires them to
! be chained in forward order.
!-

	DECR KEYNO FROM .KEY_INFO_BLK [KEYH$B_KEYNUM] - 1 TO 0 DO
	    BEGIN
	    KEY_PTR = (.KEYNO*.KEY_INFO_BLK [KEYH$B_LEN]) + KEYH$K_LENGTH + .KEY_INFO_BLK;
	    BEGIN

	    LOCAL
		GET_VM_STATUS;

	    GET_VM_STATUS = LIB$GET_VM (%REF (XAB$C_KEYLEN), XABKEY);

	    IF ( NOT .GET_VM_STATUS) THEN BAS$$STOP_IO (BAS$K_MAXMEMEXC);

	    END;
	    $XABKEY_INIT (XAB = .XABKEY);
!+
! Fill in the key XAB from the parameter.
!-
	    XABKEY [XAB$B_REF] = .KEYNO;	! Key of reference
	    XABKEY [XAB$W_POS0] = .KEY_PTR [KEY$W_OFFSET];	! Position in record
	    XABKEY [XAB$B_SIZ0] = .KEY_PTR [KEY$B_LEN];	! Length
	    XABKEY [XAB$V_CHG] = .KEY_PTR [KEY$V_CHG];	! Key can be changed
	    XABKEY [XAB$V_DUP] = .KEY_PTR [KEY$V_DUP];	! Key can be duplicated
!+
! Fill in the data type field.  The compiler deals in VAX standard
! codes for the data types, so we must translate them to the RMS
! codes.  VAX codes which do not translate are treated as strings.
!-
	    XABKEY [XAB$B_DTP] =
	    BEGIN

	    CASE .KEY_PTR [KEY$B_DTYPE] FROM DSC$K_DTYPE_WU TO DSC$K_DTYPE_P OF
		SET

		[DSC$K_DTYPE_WU] :
		    XAB$C_BN2;

		[DSC$K_DTYPE_LU] :
		    XAB$C_BN4;

		[DSC$K_DTYPE_W] :
		    XAB$C_IN2;

		[DSC$K_DTYPE_L] :
		    XAB$C_IN4;

		[DSC$K_DTYPE_T] :
		    XAB$C_STG;

		[DSC$K_DTYPE_P] :
		    XAB$C_PAC;

		[INRANGE, OUTRANGE] :
		    XAB$C_STG;
		TES

	    END;
!+
! Link this XAB to the FAB.
!-
	    XABKEY [XAB$L_NXT] = .FAB [FAB$L_XAB];
	    FAB [FAB$L_XAB] = .XABKEY;
	    END;

!+
! Initialize the local summary XAB and point the FAB to it.  This is
! used to get the number of keys from an existing indexed file.
! (This code is disabled until I learn how to use summary XABs.)
!-
	%(			! \\\\\\\\\\
	$XABSUM_INIT (XAB = XABSUM);
	XABSUM [XAB$L_NXT] = .FAB [FAB$L_XAB];
	FAB [FAB$L_XAB] = XABSUM;
	)%
	END;

!<BLF/PAGE>

!+
! Set up the FAB from the parent file if this is a multi-stream connect.
! This is needed because we will not be doing an OPEN.
!-

    IF (.CCB [LUB$V_M_STREAM])
    THEN
	BEGIN

	LOCAL
	    PARENT_IFI,
	    PARENT_ORG,
	    PARENT_MRS,
	    PARENT_RAT,
	    PARENT_RFM,
	    PARENT_BKS,
	    PARENT_BLS,
	    CONNECTED,
	    OUR_CCB : REF BLOCK [, BYTE];

	OUR_CCB = .CCB;
	BAS$$CB_PUSH (.OPEN_ARG_BLK [OPN$W_CONNECT], LUB$K_LUN_MIN);
	PARENT_IFI = (IF (.CCB [LUB$V_OPENED]) THEN .CCB [LUB$W_IFI] ELSE 0);
	PARENT_ORG = .CCB [LUB$B_ORGAN];
	PARENT_MRS = .CCB [LUB$W_RBUF_SIZE];
	PARENT_RAT = .CCB [LUB$B_RAT];
	PARENT_RFM = .CCB [LUB$B_RFM];
	PARENT_BKS = .CCB [LUB$B_BKS];
	PARENT_BLS = .CCB [LUB$W_BLS];
!+
! Mark that there may be a connect to this file, for CLOSE.
! If this is already connected; a child instead of a parent; then remember to
! complain later.
!-
	IF .CCB [LUB$V_M_STREAM] EQL 1
	THEN
	    CONNECTED = 1
	ELSE
	    BEGIN
	    CONNECTED = 0;
	    CCB [LUB$V_M_STR_C] = 1;
	    END;

	BAS$$CB_POP ();
	CCB = .OUR_CCB;

	IF (.CONNECTED) THEN BAS$$STOP_IO (BAS$K_INVFILOPT);

	IF (.PARENT_IFI EQL 0) THEN BAS$$STOP_IO (BAS$K_IO_CHANOT);

	IF (.PARENT_ORG NEQ LUB$K_ORG_INDEX) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

	FAB [FAB$W_IFI] = .PARENT_IFI;
	FAB [FAB$W_MRS] = .PARENT_MRS;
	FAB [FAB$B_RAT] = .PARENT_RAT;
	FAB [FAB$B_RFM] = .PARENT_RFM;
	FAB [FAB$B_BKS] = .PARENT_BKS;
	FAB [FAB$W_BLS] = .PARENT_BLS;
	END;

!<BLF/PAGE>

!+
! If the USEROPEN value is non-zero, call the user-supplied procedure
! to do the $OPEN and $CONNECT.  It will return an RMS status code
! as its value.  Otherwise we do the $OPEN and $CONNECT ourselves.
! If we call USEROPEN, set a flag in the LUB to help software support
! if they get an SPR.
!-

    IF (.OPEN_ARG_BLK [OPN$A_USEROPEN] NEQA 0)
    THEN
	BEGIN
	CCB [LUB$V_USEROPEN] = 1;
	OPEN_STATUS = (.OPEN_ARG_BLK [OPN$A_USEROPEN]) (.FAB, .CCB, %REF (.CCB [LUB$W_LUN]));
	CONNECT_STATUS = SS$_NORMAL;

	IF ( NOT .OPEN_STATUS)
	THEN
	    BEGIN
!+
! Try to construct the correct values for OPEN_STATUS and CONNECT_STATUS.
!-

	    IF (.FAB [FAB$L_STS])
	    THEN
		BEGIN
!+
! The $OPEN was OK, how about the $CONNECT.
!-

		IF ( NOT .CCB [RAB$L_STS])
		THEN
		    BEGIN
!+
! The $OPEN succeeded but the $CONNECT failed.
!-
		    OPEN_STATUS = .FAB [FAB$L_STS];
		    CONNECT_STATUS = .CCB [RAB$L_STS];
		    END
		ELSE
!+
! Both the RMS values look ok, just signal the error.
!-
		    LIB$STOP (.OPEN_STATUS);

		END;

	    END;

	END
    ELSE
	BEGIN
!+
! Not USEROPEN.  If an old file is explicitly wanted
! (user said FOR INPUT) do a $OPEN.  Otherwise do a $CREATE.
! However, if this is just a CONNECT, do a $DISPLAY to set up the XABs.
!-

	IF (.CCB [LUB$V_M_STREAM])
	THEN
	    OPEN_STATUS = $DISPLAY (FAB = .FAB)
	ELSE
	    BEGIN

	    IF (.CCB [LUB$V_OLD_FILE])
	    THEN
		OPEN_STATUS = $OPEN (FAB = .FAB)
	    ELSE
		OPEN_STATUS = $CREATE (FAB = .FAB);

!+
! If the OPEN succeeded, check for a terminal format file on a terminal device,
! and change to PRN format if so.  This is so that the terminal is forcible.
!-

	    IF (.OPEN_STATUS)
	    THEN
		BEGIN

		IF (((.FAB [FAB$L_DEV] AND DEV$M_TRM) NEQ 0)	!
		    AND (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_TERMI)	!
		    AND (.OPEN_ARG_BLK [OPN$B_RFM] EQL OPN$K_RFM_DEFAU)	!
		    AND (.OPEN_ARG_BLK [OPN$B_RAT] EQL OPN$K_RAT_DEFAU))
		THEN
		    BEGIN
!+
! Close and re-open the FAB, since we do not have $MODIFY.
!-

		    IF ( NOT $CLOSE (FAB = .FAB)) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

!+
! Turn off CR and turn on PRN.
!-
		    FAB [FAB$V_CR] = 0;
		    FAB [FAB$V_PRN] = 1;
!+
! Change from VAR to VFC, so we can support PRN.
!-
		    FAB [FAB$B_RFM] = FAB$C_VFC;
		    FAB [FAB$B_FSZ] = 2;
!+
! Any VFC field provided by the user is ignored.
!-
		    CCB [RAB$L_RHB] = CCB [LUB$W_BAS_VFC];
!+
! Re-open the user's file.
! Do a $CREATE just in case if this is a spooled teminal.
! If this is a spooled terminal then we are actually CREATEing a disk file.
!-
		    OPEN_STATUS = $CREATE (FAB = .FAB);
		    CCB [LUB$V_FORCIBLE] = 1;
		    END;

		END;

	    END;

	IF (.OPEN_STATUS) THEN CONNECT_STATUS = $CONNECT (RAB = .CCB);

	END;

!+
! If FAB$V_CIF is set, set the 'old file' bit in the LUB based on
! whether or not an existing file was found.  If this is a CONNECT, always
! set 'old file', for error checking.
!-

    IF (.CCB [LUB$V_M_STREAM] OR (.FAB [FAB$V_CIF] AND (.FAB [FAB$L_STS] NEQU RMS$_CREATED)))
    THEN
	CCB [LUB$V_OLD_FILE] = 1;

!+
! Store away the Directory ID in case CLOSE needs to delete the file.
! Also save the IFI.
!-
    CH$MOVE (NAM$S_DID, NAM_BLOCK [NAM$W_DID], CCB [LUB$W_DID]);
    CCB [LUB$W_IFI] = .FAB [FAB$W_IFI];
!+
! If we have an expanded name string or a resultant name string, point
! the LUB to it instead of the user-supplied name, to improve error
! messages.
!-

    IF (.NAM_BLOCK [NAM$B_RSL] NEQA 0)
    THEN
	BEGIN
	CCB [LUB$A_RSN] = .NAM_BLOCK [NAM$L_RSA];
	CCB [LUB$B_RSL] = .NAM_BLOCK [NAM$B_RSL];
	END
    ELSE

	IF (.NAM_BLOCK [NAM$B_ESL] NEQA 0)
	THEN
	    BEGIN
	    CCB [LUB$A_RSN] = .NAM_BLOCK [NAM$L_ESA];
	    CCB [LUB$B_RSL] = .NAM_BLOCK [NAM$B_ESL];
	    END;

!+
! From here to the end of this routine, a call to BAS$$STOP_IO prints the
! expanded or resultant name from RMS, hence any error detection should be
! done after this point, if this is reasonable.
!-
!+
! If OPEN or CREATE got an error, give an appropriate error message.
!-

    IF ( NOT .OPEN_STATUS) THEN BAS$$STOP_IO (BAS$K_IOERR_OPE);

!+
! Since the CCB has been RMS OPENed, CLOSE it if we detect an error hereafter.
! Note that this will actually do a DISCONNECT if LUB$V_M_STREAM is set.
!-
    UNWIND_ACTION = UNWIND_CLOSE;

    IF ( NOT .CONNECT_STATUS) THEN BAS$$STOP_IO (BAS$K_IOERR_CON);

!+
! If the device opened is a terminal, set the TERM_DEV bit in the LUB
! and allocate a prompt buffer.  Also, set the margin to infinite.
! Note that CONNECT is not permitted on terminals (because indexed only).
!-

    IF ( NOT .CCB [LUB$V_M_STREAM])
    THEN
	BEGIN

	IF ((.FAB [FAB$L_DEV] AND DEV$M_TRM) NEQ 0)
	THEN
	    BEGIN

	    LOCAL
		GET_VM_RESULT;

	    CCB [LUB$V_TERM_DEV] = 1;

	    IF ( NOT (GET_VM_RESULT = LIB$GET_VM (%REF (LUB$K_PBUF_SIZ), CCB [RAB$L_PBF])))
	    THEN
		BAS$$STOP_IO (BAS$K_MAXMEMEXC);

	    CCB [RAB$B_PSZ] = 0;
	    CCB [RAB$V_PMT] = 1;

	    IF (.OPEN_ARG_BLK [OPN$W_RECORDSIZ] EQL 0) THEN CCB [LUB$W_D_MARGIN] = .FAB [FAB$W_BLS];

	    CCB [LUB$W_R_MARGIN] = 0;
	    CCB [LUB$V_NOMARGIN] = 1;
	    END;

	END;

!<BLF/PAGE>

!+
! If the file just opened was already in existence, perform
! consistency checks between the file's attributes and the
! open parameters.
!-

    IF (.CCB [LUB$V_OLD_FILE])
    THEN
	BEGIN
!+
! Organization check: If the user did not specify an organization
! with this OPEN, use the attributes from the file.  Otherwise,
! check that the user's specification agrees with the file.
! Store the organization in the LUB if the user did not specify one.
!-

	CASE (.OPEN_ARG_BLK [OPN$B_ORG]) FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	    SET

	    [OPN$K_ORG_TERMI] :
		BEGIN
		CCB [LUB$B_ORGAN] = LUB$K_ORG_TERMI;

		IF (.FAB [FAB$B_ORG] NEQ FAB$C_SEQ) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		END;

	    [OPN$K_ORG_VIRTU] :
		BEGIN
		CCB [LUB$B_ORGAN] = LUB$K_ORG_VIRTU;

		IF (.FAB [FAB$B_ORG] NEQ FAB$C_SEQ) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		END;

	    [OPN$K_ORG_SEQUE] :
		BEGIN
		CCB [LUB$B_ORGAN] = LUB$K_ORG_SEQUE;

		IF (.FAB [FAB$B_ORG] NEQ FAB$C_SEQ) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		END;

	    [OPN$K_ORG_RELAT] :
		BEGIN
		CCB [LUB$B_ORGAN] = LUB$K_ORG_RELAT;

		IF (.FAB [FAB$B_ORG] NEQ FAB$C_REL) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		END;

	    [OPN$K_ORG_INDEX] :
		BEGIN
		CCB [LUB$B_ORGAN] = LUB$K_ORG_INDEX;

		IF (.FAB [FAB$B_ORG] NEQ FAB$C_IDX) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		END;

	    [OPN$K_ORG_UNDEF] :
!+
! If the user does not specify the organization, accept whatever
! is in the file.
!-
		BEGIN

		SELECTONE (.FAB [FAB$B_ORG]) OF
		    SET

		    [FAB$C_SEQ] :
			CCB [LUB$B_ORGAN] = LUB$K_ORG_SEQUE;

		    [FAB$C_REL] :
			CCB [LUB$B_ORGAN] = LUB$K_ORG_RELAT;

		    [FAB$C_IDX] :
			CCB [LUB$B_ORGAN] = LUB$K_ORG_INDEX;

		    [OTHERWISE] :
			BAS$$STOP_IO (BAS$K_FILATTNOT);
		    TES;

		END;
	    TES;

!+
! Verify that the user-declared bucket size agrees with the file.
! If the user specified zero, we accept the file attribute.
!-

	IF ((.OPEN_ARG_BLK [OPN$W_BUCKETSIZ] NEQ 0)	!
	    AND ((.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_RELAT)	!
	    OR (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX)))
	THEN

	    IF (.BKS NEQ .FAB [FAB$B_BKS]) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

!+
! Verify that the user-declared block size agrees with the file.
! If the user specified zero, we accept the file attribute.
!-

	IF ((.OPEN_ARG_BLK [OPN$W_BLOCKSIZE] NEQ 0) AND (.FAB [FAB$B_ORG] EQL FAB$C_SEQ))
	THEN

	    IF (.BLS NEQ .FAB [FAB$W_BLS]) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

!+
! Verify that the user-declared record size agrees with the file.
! If the user specified zero, we accept the file attribute.
!-
	CCB [LUB$W_RBUF_SIZE] = MAXU (.FAB [FAB$W_MRS], .XABFHC [XAB$W_LRL]);
!+
! If the file's purported record size is zero, use a reasonable size.
!-

	IF (.CCB [LUB$W_RBUF_SIZE] EQL 0) THEN CCB [LUB$W_RBUF_SIZE] = .RSZ;

!+
! If the user specifies a record size, make sure that the file has that record size
! (for files with fixed-length records).  For files with variable-length
! records,  the check is only necessary if the MRS is set and the file is opened
! for write access.  No checking is done here for variable length record files
! since RMS will catch the error at write time.
!-

	IF (.OPEN_ARG_BLK [OPN$W_RECORDSIZ] NEQ 0)
	THEN
	    IF (.FAB [FAB$B_RFM] EQL FAB$C_FIX)
	    THEN
		IF (.RSZ NEQ .CCB [LUB$W_RBUF_SIZE]) THEN BAS$$STOP_IO (BAS$K_BADRECVAL);

!+
! The buffer size we actually use must be at least as large as the user
! declared, or the default size, if no declaration.  This guards against
! opening a file with only short records in it (and MRS=0) and being unable
! to write a large record.
!-
	CCB [LUB$W_RBUF_SIZE] = MAXU (.CCB [LUB$W_RBUF_SIZE], .RSZ);
!+
! If the user is using a MAP, the record size must not be longer than the
! space in the map.
!-

	IF ((.OPEN_ARG_BLK [OPN$A_MAP] NEQA 0) AND 	!
	    (.CCB [LUB$W_RBUF_SIZE] GTRU .OPEN_ARG_BLK [OPN$W_RECORDSIZ]))
	THEN
	    BAS$$STOP_IO (BAS$K_BADRECVAL);

!+
! If the organization is virtual, the buffer size must be at least 512 bytes.
!-

	IF ((.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_VIRTU) AND 	!
	    (.CCB [LUB$W_RBUF_SIZE] LSSU 512))
	THEN
	    BAS$$STOP_IO (BAS$K_BADRECVAL);

!+
! Verify that the user-declared record format agrees with the file.
! If the user did not specify a record format, we accept the file
! attribute.
!-

	CASE (.OPEN_ARG_BLK [OPN$B_RFM]) FROM OPN$K_RFM_DEFAU TO OPN$K_RFM_STREA OF
	    SET

	    [OPN$K_RFM_DEFAU] :
!+
! Don't check for virtual and undefined.
!-

		IF ((.OPEN_ARG_BLK [OPN$B_ORG] NEQ OPN$K_ORG_VIRTU) AND (.OPEN_ARG_BLK [OPN$B_ORG] NEQ
		    OPN$K_ORG_UNDEF))
		THEN
!+
! If the device is a terminal, it is opened in PRN format.
!-

		    IF (((.FAB [FAB$L_DEV] AND DEV$M_TRM) NEQ 0)	!
			AND (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_TERMI)	!
			AND (.OPEN_ARG_BLK [OPN$B_RFM] EQL OPN$K_RFM_DEFAU)	!
			AND (.OPEN_ARG_BLK [OPN$B_RAT] EQL OPN$K_RAT_DEFAU))
		    THEN
			BEGIN

			IF (.FAB [FAB$B_RFM] NEQ FAB$C_VFC) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

			IF (.FAB [FAB$B_FSZ] NEQ 2) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

			END;

	    [OPN$K_RFM_FIXED] :

		IF (.FAB [FAB$B_RFM] NEQ FAB$C_FIX) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

	    [OPN$K_RFM_VARIA] :

		IF ((.FAB [FAB$B_RFM] NEQ FAB$C_VAR) AND (.FAB [FAB$B_RFM] NEQ FAB$C_VFC))
		THEN
		    BAS$$STOP_IO (BAS$K_FILATTNOT);

	    [OPN$K_RFM_VFC] :
		BEGIN

		IF (.FAB [FAB$B_RFM] NEQ FAB$C_VFC) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		IF (.FAB [FAB$B_FSZ] NEQ .OPEN_ARG_BLK [OPN$B_FSZ]) THEN BAS$$STOP_IO (BAS$K_FILATTNOT);

		END;

	    [OPN$K_RFM_STREA, OUTRANGE] :
		BAS$$STOP_IO (BAS$K_FILATTNOT);
	    TES;

!+
! Verify that the user-declared record attributes agree with the file.
!-

	CASE (.OPEN_ARG_BLK [OPN$B_RAT]) FROM OPN$K_RAT_DEFAU TO OPN$K_RAT_ANY OF
	    SET

	    [OPN$K_RAT_DEFAU] :
!+
! If the device is a terminal, it is opened in PRN format.
!-

		IF (((.FAB [FAB$L_DEV] AND DEV$M_TRM) NEQ 0)	!
		    AND (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_TERMI)	!
		    AND (.OPEN_ARG_BLK [OPN$B_RFM] EQL OPN$K_RFM_DEFAU)	!
		    AND (.OPEN_ARG_BLK [OPN$B_RAT] EQL OPN$K_RAT_DEFAU))
		THEN
		    BEGIN

		    IF ( NOT .FAB [FAB$V_PRN]) THEN BAS$$STOP_IO (BAS$K_RECATTNOT)

		    END
		ELSE
!+
! If the organization is virtual, it should have RAT NONE or CR.
!-

		    IF (.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_VIRTU)
		    THEN
			BEGIN

			IF (.FAB [FAB$V_FTN] OR .FAB [FAB$V_PRN]) THEN BAS$$STOP_IO (BAS$K_RECATTNOT)

			END
		    ELSE

			IF ( NOT .FAB [FAB$V_CR]) THEN BAS$$STOP_IO (BAS$K_RECATTNOT);

	    [OPN$K_RAT_FORTR] :

		IF ( NOT .FAB [FAB$V_FTN]) THEN BAS$$STOP_IO (BAS$K_RECATTNOT);

	    [OPN$K_RAT_CRLF] :

		IF ( NOT .FAB [FAB$V_CR]) THEN BAS$$STOP_IO (BAS$K_RECATTNOT);

	    [OPN$K_RAT_NONE] :

		IF (.FAB [FAB$V_CR] OR .FAB [FAB$V_FTN] OR .FAB [FAB$V_PRN])
		THEN
		    BAS$$STOP_IO (BAS$K_RECATTNOT);

	    [OPN$K_RAT_PRINT] :

		IF ( NOT .FAB [FAB$V_PRN]) THEN BAS$$STOP_IO (BAS$K_RECATTNOT);

	    [OPN$K_RAT_ANY] :
		BEGIN
		0
		END;

	    [OUTRANGE] :
		BAS$$STOP_IO (BAS$K_RECATTNOT);
	    TES;

!+
! Mark the file as being in PRN format, if it is.
!-

	IF (.FAB [FAB$V_PRN]) THEN CCB [LUB$V_PRN] = 1;

!+
! Check keys for indexed file organization.
!-

	IF ((.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_INDEX) AND (ACTUALCOUNT () GEQ 2))
	THEN
	    BEGIN

	    LOCAL
		XABKEY : REF $XABKEY_DECL,
		KEY_PTR : REF BLOCK [0, BYTE] FIELD (OPN$KEY_BLOCK),
		KEYNO;

!+
! The number of keys in the file, as recorded in the symmary XAB, must match
! the number of keys specified in the argument list.
! (This is disabled until I learn how to use summary XABs.)
!-
	    %(				! \\\\\\\\\\
	    IF (.KEY_INFO_BLK [KEYH$B_KEYNUM] NEQU .XABSUM [XAB$B_NOK])
	    THEN
		BAS$$STOP_IO (BAS$K_FILATTNOT);
            )%
!+
! Each key must match the argument list.  The keys are stored in the XABKEY
! blocks that were set up before the OPEN.  Search through the XABKEY blocks
! matching each with the argument list.
!-
	    XABKEY = .FAB [FAB$L_XAB];

	    WHILE (.XABKEY NEQA 0) DO
		BEGIN

		IF (.XABKEY [XAB$B_COD] EQL XAB$C_KEY)
		THEN
		    BEGIN
		    KEYNO = .XABKEY [XAB$B_REF];
		    KEY_PTR = (.KEY_INFO_BLK [KEYH$B_LEN]*.KEYNO) + KEYH$K_LENGTH + .KEY_INFO_BLK;

		    IF ((.XABKEY [XAB$W_POS0] NEQ .KEY_PTR [KEY$W_OFFSET])	!
			OR (.XABKEY [XAB$B_SIZ0] NEQ .KEY_PTR [KEY$B_LEN])	!
			OR (.XABKEY [XAB$V_CHG] NEQ .KEY_PTR [KEY$V_CHG])	!
			OR (.XABKEY [XAB$V_DUP] NEQ .KEY_PTR [KEY$V_DUP]))
		    THEN
			BAS$$STOP_IO (BAS$K_FILATTNOT);

		    END;

		XABKEY = .XABKEY [XAB$L_NXT];
		END;

	    END;

	END					! end of old file processing
    ELSE
	BEGIN
!+
! This is a new file.  If it is organized relative or index, the user
! must have specified a record size.
!-

	IF (.RSZ EQL 0) THEN BAS$$STOP_IO (BAS$K_BADRECVAL) ELSE CCB [LUB$W_RBUF_SIZE] = .RSZ;

!+
! Make sure the LUB 'append' flag is off so FORTRAN BACKSPACE will work.
!-
	CCB [LUB$V_APPEND] = 0;
!+
! Set LUB$B_ORGAN based on the OPEN argument.  This is legitimate since
! we just created the file, so it must agree with the OPEN argument.
!-

	CASE .OPEN_ARG_BLK [OPN$B_ORG] FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	    SET

	    [OPN$K_ORG_TERMI] :
		CCB [LUB$B_ORGAN] = LUB$K_ORG_TERMI;

	    [OPN$K_ORG_VIRTU] :
		CCB [LUB$B_ORGAN] = LUB$K_ORG_VIRTU;

	    [OPN$K_ORG_SEQUE] :
		CCB [LUB$B_ORGAN] = LUB$K_ORG_SEQUE;

	    [OPN$K_ORG_RELAT] :
		CCB [LUB$B_ORGAN] = LUB$K_ORG_RELAT;

	    [OPN$K_ORG_INDEX] :
		CCB [LUB$B_ORGAN] = LUB$K_ORG_INDEX;

	    [OPN$K_ORG_UNDEF] :
		BAS$$STOP_IO (BAS$K_FILATTNOT);
	    TES;

!+
! Don't allow an open with ACCESS READ to create a file.
!-

	IF (.OPEN_ARG_BLK [OPN$B_ACCESS] EQL OPN$K_ACC_READ) THEN BAS$$STOP_IO (BAS$K_ILLILLACC);

!+
! A virtual file's record size must not be less than 512 bytes.
!-

	IF ((.OPEN_ARG_BLK [OPN$B_ORG] EQL OPN$K_ORG_VIRTU) AND 	!
	    (.RSZ LSS 512))
	THEN
	    BAS$$STOP_IO (BAS$K_BADRECVAL);

	END;					! End of new file processing

!+
! Validate the record format.  It must be one of those the run-time
! library can process.  In particular, we don't permit UNDEFINED unless
! the organization is UNDEFINED.
!-

    IF (.OPEN_ARG_BLK [OPN$B_ORG] NEQ OPN$K_ORG_UNDEF)
    THEN

	SELECTONE (.FAB [FAB$B_RFM]) OF
	    SET

	    [FAB$C_FIX, FAB$C_VAR, FAB$C_VFC] : 	! This is ok.
	    ;

	    [OTHERWISE] :
		BAS$$STOP_IO (BAS$K_FILATTNOT);
	    TES;

!+
! Record the record attribute, record format block size and bucket
! size in the LUB, for the FSP$ function and for connect.
!-
    CCB [LUB$B_RAT] = .FAB [FAB$B_RAT];
    CCB [LUB$B_RFM] = .FAB [FAB$B_RFM];
    CCB [LUB$B_BKS] = .FAB [FAB$B_BKS];
    CCB [LUB$W_BLS] = .FAB [FAB$W_BLS];
    CCB [LUB$L_ALQ] = .FAB [FAB$L_ALQ];
    CCB [LUB$L_REC_MAX] =
    BEGIN

    CASE .OPEN_ARG_BLK [OPN$B_ORG] FROM OPN$K_ORG_TERMI TO OPN$K_ORG_UNDEF OF
	SET

	[OPN$K_ORG_VIRTU] :
	    .FAB [FAB$L_ALQ];

	[OPN$K_ORG_UNDEF] :
	    .FAB [FAB$L_MRN];

	[INRANGE] :
	    0;
	TES

    END;
!+
! Remember the device characteristics, in case the user calls
! STATUS.
!-
    L_STATUS = .FAB [FAB$L_DEV];
!+
! Free the key XABs, since they were allocated from virtual storage.
!-
    BEGIN

    LOCAL
	XABKEY : REF $XABKEY_DECL,
	FREE_VM_STATUS,
	XAB_PTR;

    XAB_PTR = FAB [FAB$L_XAB];

    WHILE (..XAB_PTR NEQA 0) DO
	BEGIN
	XABKEY = ..XAB_PTR;

	IF (.XABKEY [XAB$B_COD] EQL XAB$C_KEY)
	THEN
	    BEGIN
!+
! We have found a key XAB.  Unlink it from the XAB chain and free it.
! We have remembered XAB_PTR as its chain location.
!-
	    .XAB_PTR = .XABKEY [XAB$L_NXT];
	    FREE_VM_STATUS = LIB$FREE_VM (%REF (XAB$C_KEYLEN), XABKEY);

	    IF ( NOT .FREE_VM_STATUS) THEN BAS$$STOP_IO (BAS$K_PROLOSSOR);

	    END
	ELSE
	    XAB_PTR = XABKEY [XAB$L_NXT];

	END;

    END;
!+
! Allocate and clear a record buffer unless the user provided one.
!-

    IF (.OPEN_ARG_BLK [OPN$A_MAP] EQLA 0)
    THEN
	BEGIN

	LOCAL
	    GET_VM_RESULT;

!+
! If recordsize is still 0 then signal an error.
!-

	IF (.CCB [LUB$W_RBUF_SIZE] EQL 0) THEN BAS$$STOP_IO (BAS$K_BADRECVAL);

	GET_VM_RESULT = LIB$GET_VM (%REF (.CCB [LUB$W_RBUF_SIZE]), CCB [LUB$A_RBUF_ADR]);

	IF ( NOT .GET_VM_RESULT) THEN BAS$$STOP_IO (BAS$K_MAXMEMEXC);

!+
! Make sure the buffer is null, in case the user fetches from it before
! the first GET.
!-
	CH$FILL (0, .CCB [LUB$W_RBUF_SIZE], .CCB [LUB$A_RBUF_ADR]);
	END
    ELSE
	BEGIN
	CCB [LUB$A_RBUF_ADR] = .OPEN_ARG_BLK [OPN$A_MAP];
	CCB [LUB$V_USER_RBUF] = 1;
	END;

!+
! Allocate dynamic storage for the file name so that the name can be
! used later for error diagnostics.  Point the LUB to the new location.
! Indicate that the space pointed to must be deallocated when the file
! is closed.
!-
    BEGIN

    LOCAL
	GET_VM_RESULT,
	OLD_ADDRESS;

    OLD_ADDRESS = .CCB [LUB$A_RSN];
    GET_VM_RESULT = LIB$GET_VM (%REF (.CCB [LUB$B_RSL]), CCB [LUB$A_RSN]);

    IF ( NOT .GET_VM_RESULT) THEN BAS$$STOP_IO (BAS$K_MAXMEMEXC);

    CH$MOVE (.CCB [LUB$B_RSL], .OLD_ADDRESS, .CCB [LUB$A_RSN]);
    CCB [LUB$V_VIRT_RSN] = 1;
    END;
!+
! Set those RAB fields that seldom change.
!-
    CCB [RAB$L_UBF] = .CCB [LUB$A_RBUF_ADR];
    CCB [RAB$W_USZ] = .CCB [LUB$W_RBUF_SIZE];
    CCB [LUB$A_UBF] = .CCB [LUB$A_RBUF_ADR];
!+
! Clear LUB$A_FAB to indicate that the FAB is no longer present.
!-
    CCB [LUB$A_FAB] = 0;
    CCB [RAB$L_FAB] = 0;
!+
! Indicate that the file is now open for BASIC.
!-
    CCB [LUB$B_LANGUAGE] = LUB$K_LANG_BAS;
    CCB [LUB$V_OPENED] = 1;
!+
! Make sure that the BASIC exit handler will be called when the image
! exits to purge the file's I/O buffers and close it, if necessary.
! This can happen if the user's last PRINT statement ends with a
! comma or a semicolon.
!-

    IF ( NOT .BAS$$L_XIT_LOCK) THEN BAS$$DECL_EXITH ();

!+
! Pop back previous LUB or indicate that no I/O statement
! is currently active.
!-
    BAS$$CB_POP ();
    RETURN;
    END;					! end of BAS$OPEN


ROUTINE OPEN_HANDLER (				! Handle an UNWIND from OPEN
	SIG, 					! Signal vector
	MECH, 					! Mechanism vector
	ENBL					! Enable vector
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If we are unwinding, do the indicated OPEN cleanup, either nothing, POP
!	the CCB, mark the CCB for deallocation and POP it, or RMS CLOSE the CCB
!	and POP it.
!
! FORMAL PARAMETERS:
!
!	SIG.rl.a	A counted vector of parameters to LIB$SIGNAL/STOP
!	MECH.rl.a	A counted vector of info from CHF
!	ENBL.ra.a	A counted vector of ENABLE argument addresses.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Always SS$_RESIGNAL, which is ignored when unwinding.
!
! SIDE EFFECTS:
!
!	May RMS CLOSE or DISCONNECT the file, and may deallocate the CCB.
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,
	MECH : REF VECTOR,
	ENBL : REF VECTOR;

    LOCAL
	MY_UNWIND_ACT : VOLATILE,
	MY_UNWIND_CCB : VOLATILE;

    GLOBAL REGISTER
	CCB = K_CCB_REG : REF BLOCK [, BYTE];

!+
! Define names for the two items in the ENABLE vector.
!-

    BIND
	UNWIND_ACTION = .ENBL [1],
	UNWIND_CCB = .ENBL [2];

!+
! We are our own handler, in case the CLOSE or DISCONNECT fails.
!-

    ENABLE
	OPEN_HANDLER (MY_UNWIND_ACT, MY_UNWIND_CCB);

!+
! Don't do anything yet.
!-
    MY_UNWIND_ACT = UNWIND_NOP;
!+
! Just resignal if this is an UNWIND or if the error is not severe.  Otherwise
! we clean up the I/O data base prior to signalling the SEVERE error.
!-

    IF (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND)) OR (.BLOCK [SIG [1], STS$V_SEVERITY] NEQ STS$K_SEVERE))
    THEN
	RETURN (SS$_RESIGNAL);

!+
! Depending on the action selected, do things.
!-
    CCB = .UNWIND_CCB;

    CASE .UNWIND_ACTION FROM UNWIND_MIN TO UNWIND_MAX OF
	SET

	[UNWIND_NOP] : 				! Do nothing.
	    BEGIN
	    0
	    END;

	[UNWIND_POP] : 				! POP the specified CCB
	    BAS$$CB_POP ();

	[UNWIND_DEALLOC] : 			! Mark the specified CCB for deallocation, then POP it
	    BEGIN
	    CCB [LUB$V_DEALLOC] = 1;
	    BAS$$CB_POP ();
	    END;
!+
! RMS CLOSE or DISCONNECT the specified CCB (which marks it for deallocation), then POP it
! (which will usually deallocate it).
!-

	[UNWIND_CLOSE] :
	    BEGIN
!+
! If the CLOSE fails, deallocate and POP.
!-
	    MY_UNWIND_CCB = .CCB;
	    MY_UNWIND_ACT = UNWIND_DEALLOC;

	    IF ( NOT OTS$$CLOSE_FILE ()) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

	    BAS$$CB_POP ();
	    END;
	TES;

    RETURN (SS$_RESIGNAL);
    END;					! end of OPEN_HANDLER


GLOBAL ROUTINE BAS$STATUS 			! Status of last file opened
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Get the status of the last file opened.  The necessary bits
!	were saved by OPEN in L_STATUS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	L_STATUS	A copy of FAB$L_DEV from the last OPEN, or 0
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Bits 0 through 4 reflect device characteristics, see below.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
!+
! The following field describes the status bits returned.
!-

    FIELD
	STATUS_BITS =
	    SET
	    STATUS_REC = [0, 0, 1, 0],		! Record-oriented device
	    STATUS_CCL = [0, 1, 1, 0],		! Carriage control device
	    STATUS_TRM = [0, 2, 1, 0],		! Device is a terminal
	    STATUS_DIR = [0, 3, 1, 0],		! Directory device (disk)
	    STATUS_SDI = [0, 4, 1, 0],		! Single-directory device
	    STATUS_SQD = [0, 5, 1, 0]		! Sequential, block-oriented device (magtape)
	    TES;

    LOCAL
	STATUS : BLOCK [2, BYTE] FIELD (STATUS_BITS);

!+
! Clear all of the bits in STATUS, then set the appropriate ones.
!-
    STATUS = 0;

    IF ((.L_STATUS AND DEV$M_REC) NEQ 0) THEN STATUS [STATUS_REC] = 1;

    IF ((.L_STATUS AND DEV$M_CCL) NEQ 0) THEN STATUS [STATUS_CCL] = 1;

    IF ((.L_STATUS AND DEV$M_TRM) NEQ 0) THEN STATUS [STATUS_TRM] = 1;

    IF ((.L_STATUS AND DEV$M_DIR) NEQ 0) THEN STATUS [STATUS_DIR] = 1;

    IF ((.L_STATUS AND DEV$M_SDI) NEQ 0) THEN STATUS [STATUS_SDI] = 1;

    IF ((.L_STATUS AND DEV$M_SQD) NEQ 0) THEN STATUS [STATUS_SQD] = 1;

!+
! Return the bits as our value.
!-
    RETURN (.STATUS);
    END;					! of routine BAS$STATUS


GLOBAL ROUTINE BAS$$STATU_INIT : NOVALUE = 	! Initialize status

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize the STATUS variable.  This is needed by the RUN command in case this
!	is not the first RUN command in this image.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	L_STATUS, always zet to zero.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    L_STATUS = 0;
    END;					! of routine BAS$$STATU_INIT

END						! end of module BAS$OPEN

ELUDOM
