%TITLE 'BAS$$FORMAT_INT - Basic format interpreter'
MODULE BAS$$FOR_INT (				! Basic format interpreter
		IDENT = '2-001'			! File: BASFORINT.B32 EDIT:DJB2001
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!
! Basic support library - not user callable
!
! ABSTRACT:
!
!	This is the format interpreter for Basic PRINT USING and FORMAT$.
!
! ENVIRONMENT:	User access mode, AST reentrant
!
! AUTHOR: Donald G. Petersen, CREATION DATE: 03-May-79
!
! MODIFIED BY:
!
! 	DGP,03-May-79 : VERSION 1
! 1-001	- original
! 1-002	- Get TPAMAC from SYS$LIBRARY.  JBS 22-MAY-1979
! 1-003 - Add PSECT declaration and make BAS$$FORMAT_INT global.  DGP 22-May-79
! 1-004 - Remove comment from switches statement.  DGP 22-May-79
! 1-005 - The TPARSE parameter block is passed by value using a CALLG.  Change
!	  the MAP of the formal in each action routine.  DGP  23-May-79
! 1-006 - The TPARSE argument list for the action routines is not quite right.
!	  AP is needed as a BUILTIN.  DGP 29-May-79
! 1-007 - Change error routine call to BAS$$STOP from BAS$$STOP_IO 'cuz
!	  the format interpreter knows nothing about I/O.  DGP 29-May-79
! 1-008 - Add BAS$$ prefix to PUKEYWDS and PRINT_USING.  DGP 30-May-79
! 1-009	- Change the names of the STR linkages.  JBS 04-JUN-1979
! 1-010 - Change length of K_INTER_STO_LEN to be 28.  Bug fix.  DGP 12-Jul-79
! 1-011	- Make PERCENT be a macro rather than a BIND.  JBS 14-JUL-1979
! 1-012	- Change calls to STR$COPY.  JBS 16-JUL-1979
! 1-013 - Make PERCENT a BIND rather than a macro.  DGP 16-Jul-79
! 1-014 - Work on numerics some.  DGP 16-Jul-79
! 1-015 - Add V_PERIOD.  DGP 20-Jul-79
! 1-016 - Bug fix in double precision floating.  DGP 30-Jul-79
! 1-017 - Yes, E format can have a (negative) number which won't fit.  DGP
!	  30-Jul-79
! 1-018 - Retro fit floating into integer.  DGP  01-Aug-79
! 1-019	- Use REQUIRE rather than LIBRARY to read TPAMAC, so we can try
!	   new BLISS compiler.  JBS 06-SEP-1979
! 1-020	- Go back to using LIBRARY, but use a logical name.  JBS 12-SEP-1979
! 1-021 - Initialize all null string desc. pointers to 0.  DGP 18-Sep-79
! 1-022 - Translate SYS$CURRENCY, SYS$RADIX_POINT, and SYS$DIGIT_SEP.  DGP
!	  30-Oct-79
! 1-023 - Return all temporary strings allocated from HEAP store.  DGP 08-Nov-79
! 1-024 - Receive the scale factor and pass it along to the conversion routines.
!	  DGP 25-Nov-79
! 2-001 - Add routines to use SPANC, SCANC, etc. instructions instead of
!	  LIB$TPARSE for performance optimizations.  Replace use of STR$CONCAT
!	  with STR$APPEND in OUTPUT_ARG where possible.  DJB 08-Jun-1981.
!--

!<BLF/PAGE>

%SBTTL 'Declarations'
!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';			! macros for all linkages except STR$

REQUIRE 'RTLIN:STRLNK';			! macros for STR$ linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$$FORMAT_INT : NOVALUE,		! the Basic format interpreter

!+
! A possible optimization in the future could be to make these internal
! routines JSB entry points.  This should be done after the full range
! of planned format characters is implemented (or allowed for).
!-

    DECODE_PROCESS_FORMAT,		! main driving routine
    SPAN_CONSTANT,			! find start of formatting sequence
    SPAN_SINGLE_QUOTE,			! process single quote format classes
    SPAN_TEXT,				! span various text format classes
    SPAN_BACKSLASH,			! process backslash format class
    SPAN_NUMERIC,			! process numeric format class
    OUTPUT_ARG;				! do all of the formatting

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';		! Declare Psects macros

LIBRARY 'RTLSTARLE';			! STARLET library for macros and symbols

!
! MACROS:
!

MACRO
    RET_STR = 0, 0, 32, 0%,
    PU_MASK = 4, 0, 32, 0%,
    ELEM_TYPE = 8, 0, 32, 0%,
    ELEM = 12, 0, 32, 0%,
    FRACTION_DIGIT = 16, 0, 32, 1%,
    INTEGER_DIGITS = 20, 0, 32, 1%,
    CHARACTER = 24, 0, 32, 1%,
    SCALE_FACTOR = 28, 0, 32, 1%,
    NEXT_CHAR = 32, 0, 32, 0%;

!
! EQUATED SYMBOLS:
!

LITERAL

!+
! These literals define the bits in the PRINT USING mask (PU_MASK)
! NOTE: These are well ordered.  Action routines take advantage of the
! fact that:
! F format is < E_MASK
! E_MASK <= E format < R_JUSTIFY_MASK
! Text is >= R_JUSTIFY_MASK
! Be careful when adding new values
!-

    NUMERIC_MASK = 1,			! numeric format
    MINUS_MASK = 2,			! trailing minus required
    COMMA_MASK = 4,			! digit group separator required
    DOLLAR_MASK = 8,			! floating currency required
    STAR_MASK = 16,			! asterisk fill required

!+
! bit 5 (value = 32) should not be used unless we run out of bits
! The conversion routines use almost the same bits for the same things
! and bit 5 means strip_trailing_spaces.
!-

    PERIOD_MASK = 64,			! a period is in the format
    E_MASK = 128,			! number should be in E format
    R_JUSTIFY_MASK = 256,		! right justify the string
    C_JUSTIFY_MASK = 512,		! center justify the string
    EXTEND_MASK = 1024,			! extend the string as necessary
    L_JUSTIFY_MASK = 2048,		! left justify the string
    K_CVT_FLAGS = 95,			! turn off flags not interesting to
    					! conversion routine
    K_INTER_STO_LEN = 36,		! length of local interpreter store
    					! in bytes
    K_AST_FLAG = 1,			! 0 - do not disable ASTs
					! 1 - disable ASTs

!+
! ASCII character codes.
!-

    CHAR_SPACE = 32 : UNSIGNED (8),
    CHAR_EXCLAMATION = 33 : UNSIGNED (8),
    CHAR_POUND = 35 : UNSIGNED (8),
    CHAR_DOLLAR = 36 : UNSIGNED (8),
    CHAR_SINGLE_QUOTE = 39 : UNSIGNED (8),
    CHAR_STAR = 42 : UNSIGNED (8),
    CHAR_COMMA = 44 : UNSIGNED (8),
    CHAR_MINUS = 45 : UNSIGNED (8),
    CHAR_PERIOD = 46 : UNSIGNED (8),
    CHAR_BACKSLASH = 92 : UNSIGNED (8),
    CHAR_CARAT = 94 : UNSIGNED (8),
    CHAR_C = 67 : UNSIGNED (8),
    CHAR_E = 69 : UNSIGNED (8),
    CHAR_L = 76 : UNSIGNED (8),
    CHAR_R = 82 : UNSIGNED (8),
    CHAR_LOWER_C = 99 : UNSIGNED (8),
    CHAR_LOWER_E = 101 : UNSIGNED (8),
    CHAR_LOWER_L = 108 : UNSIGNED (8),
    CHAR_LOWER_R = 114 : UNSIGNED (8),

!+
! Functions for numeric format evaluation (see SPAN_NUMERIC routine).
!-

    K_SPAN_INTEGER = 1,
    K_SPAN_INTEGER_NO_E = 2,
    K_SPAN_FRACTION = 3,
    K_SPAN_FRACTION_NO_E = 4,

!+
! Classes for SPANC/SCANC table.
!-

    MASK_FORMAT_CHARS = 1 : UNSIGNED (8),
    MASK_L = 2 : UNSIGNED (8),
    MASK_C = 4 : UNSIGNED (8),
    MASK_R = 8 : UNSIGNED (8),
    MASK_E = 16 : UNSIGNED (8);

!
! PSECT DECLARATIONS:
!

DECLARE_PSECTS (BAS);

!
! OWN STORAGE:
!

OWN
    CURRENCY_DESC,			! descriptor for currency symbol
    CU_D,
    DIGIT_SEP_DESC,			! descriptor for digit group separator
    DI_D,
    RADIX_PT_DESC,			! descriptor for radix point
    RA_D;

BIND
    E_FORMAT = UPLIT BYTE (REP 4 OF (CHAR_CARAT)),
    PERCENT = UPLIT (BYTE ('%')),

!+
! Set up the class table for all groups of characters that will be involved
! in uses of the SCANC and SPANC instructions.  This class table is built
! into a PLIT.  An example of OWN storage initialition at run time is
! given below to help clarify the classes set up in the PLIT.
!
! INCR I FROM 0 TO 255 DO
!	SELECTONEU .I OF
!		SET
!		[CHAR_DOLLAR, CHAR_POUND, CHAR_PERIOD, CHAR_SINGLE_QUOTE,
!			CHAR_EXCLAMATION, CHAR_BACKSLASH, CHAR_STAR] :
!					 CLASS_TABLE [.I] = MASK_FORMAT_CHARS;
!		[CHAR_L, CHAR_LOWER_L] : CLASS_TABLE [.I] = MASK_L;
!		[CHAR_C, CHAR_LOWER_C] : CLASS_TABLE [.I] = MASK_C;
!		[CHAR_R, CHAR_LOWER_R] : CLASS_TABLE [.I] = MASK_R;
!		[CHAR_E, CHAR_LOWER_E] : CLASS_TABLE [.I] = MASK_E;
!		[OTHERWISE] :		 CLASS_TABLE [.I] = 0;
!		TES;
!
! Currently 5 formatting classes are used leaving 3 available.
! If more than 8 formatting classes are needed, a second CLASS_TABLE
! will have to be used unless various formatting classes can be grouped
! together (e.g. if MASK_C + MASK_R is passed to the SPANC instruction
! as the mask, all of the four characters CHAR_C, CHAR_LOWER_C, CHAR_R,
! CHAR_LOWER_R would be spanned.
!
! To add a new format character (or group of characters), the SPAN_CONSTANT
! routine should be modified to properly look for the beginning of the
! format sequence.  DECODE_PROCESS_FORMAT should then be modified to scan
! for the end of the formatting sequence setting any appropriate flags.
! Information to be communicated to the output conversion routine
! (OUTPUT_ARG) is passed via PARAM_BLK.  The paramter block could
! be expanded to allow for any new flags.
!-

    CLASS_TABLE = UPLIT BYTE
	(
	REP CHAR_EXCLAMATION  OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_EXCLAMATION
	REP CHAR_POUND - CHAR_EXCLAMATION - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_POUND
	REP CHAR_DOLLAR - CHAR_POUND - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_DOLLAR
	REP CHAR_SINGLE_QUOTE - CHAR_DOLLAR - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_SINGLE_QUOTE
	REP CHAR_STAR - CHAR_SINGLE_QUOTE - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_STAR
	REP CHAR_PERIOD - CHAR_STAR - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_PERIOD
	REP CHAR_C - CHAR_PERIOD - 1 OF (0),
	(MASK_C),			! CHAR_C
	REP CHAR_E - CHAR_C - 1 OF (0),
	(MASK_E), 			! CHAR_E
	REP CHAR_L - CHAR_E - 1 OF (0),
	(MASK_L),			! CHAR_L
	REP CHAR_R - CHAR_L - 1 OF (0),
	(MASK_R),			! CHAR_R
	REP CHAR_BACKSLASH - CHAR_R - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_BACKSLASH
	REP CHAR_LOWER_C - CHAR_BACKSLASH - 1 OF (0),
	(MASK_C),			! CHAR_LOWER_C
	REP CHAR_LOWER_E - CHAR_LOWER_C - 1 OF (0),
	(MASK_E), 			! CHAR_LOWER_E
	REP CHAR_LOWER_L - CHAR_LOWER_E - 1 OF (0),
	(MASK_L),			! CHAR_LOWER_L
	REP CHAR_LOWER_R - CHAR_LOWER_L - 1 OF (0),
	(MASK_R),			! CHAR_LOWER_R
	REP 255 - CHAR_LOWER_R OF (0)
	) : VECTOR [256, BYTE, UNSIGNED];

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$CURRENCY,			! currency symbol
    LIB$RADIX_POINT,			! radix point
    LIB$DIGIT_SEP,			! digit group separator
    BAS$RSET : NOVALUE,			! Basic RSET
    STR$GET1_DX,			! Allocate a string
    STR$FREE1_DX,			! Free a string
    STR$CONCAT,				! Concatenate strings
    STR$APPEND,				! Append strings
    STR$RIGHT,				! Extract right part of a string
    STR$LEN_EXTR,			! Extract a substring
    LIB$STOP,				! Signal internal RTL errors
    STR$COPY_DX_R8 : STR$JSB_COPY_DX,	! Copy to a string
    STR$COPY_R_R8 : STR$JSB_COPY_R,	! Copy to a dynamic string
    BAS$$STOP : NOVALUE,		! Signal errors and stop
    BAS$CVT_OUT_F_E,			! convert float to E format
    BAS$CVT_OUT_D_E,			! convert double to E format
    BAS$CVT_OUT_F_F,			! convert float to F format
    BAS$CVT_OUT_D_F,			! convert double to F format
    BAS$CVT_OUT_D_G;			! PRINT format conversion routine

EXTERNAL LITERAL
    BAS$K_PRIUSIFOR,				! Print Using format error
    OTS$_FATINTERR;				! Fatal internal RTL error

BUILTIN

!+
! In version X3-669 of VAX-11 Bliss-32, output registers will be allowed
! for the SCANC and SPANC instructions (there is a bug in V2.1-667 that
! prevents the use of output registers with SCANC and SPANC or
! any BUILTIN for that matter).  These output
! registers could be used to return information from the instructions
! that currently requires a computation after the BUILTIN has been executed.
!
! In version V3 of VAX-11 Bliss-32, LOCC and SKPC will be allowed as BUILTINs
! so that the use of CH$FIND_NOT_CH could be replaced by the BUILTIN SKPC
! with output registers.
!-

    SCANC,
    SPANC,
    CVTLD;


%SBTTL 'BAS$$FORMAT_INT - external entry point'
GLOBAL ROUTINE BAS$$FORMAT_INT (		! Basic format interpreter

    ELEMENT,		! element to format
    FORMAT_STR,		! string containing the formatting information
    ELEMENT_TYPE,	! data type of the element
    RET_STRING,		! where to return the result
    RET_FORMAT_ADR,	! address of the next char in format string
    BAS_SCALE_FAC	! Scale factor (-6 <= x <= 0)
    ) : NOVALUE =

BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the format interpreter for Basic Print Using and FORMAT$.
!	It will interpret the format string and call the appropriate output
!	conversion routine.
!
!	Note that this routine will be called for each item in the format
!	list.  Thus if there are 10 items in the format list and 1 formatting
!	sequence, this routine will be called once for each item (10 times).
!	If the PRINT USING is in a loop of 1,000 iterations, this routine
!	will be called once for each item-iteration or 10,000 times
!	in the above example.  Thus the format sequence will be decoded
!	10,000 times.  There is obvious room for improvement here by having
!	a separate routine to set up the PRINT USING paramater block with
!	the formatting information.  Note that the paramater block
!	currently used only handles one format sequence at a time.
!	Some higher level caller would have to save however many decoded
!	PRINT USING parameter blocks might be needed.
!
!	The routines in this module would benefit from RTL routines that
!	provide STR$APPEND with multiple source string descriptors and
!	STR$APPEND_R capabilities to append the source string by reference.
!
!	The PRINT USING support implemented here provides for upper
!	and lower case text formatting characters (L,C,R,E and l,c,r,e).
!	PDP-11 BASIC-PLUS-2 only allows upper case - lower case letters
!	(l,c,r,e) are treated as constants.  Thus the capabilities provided
!	here are not strictly a superset of the PDP-11 capabilities.
!
! FORMAL PARAMETERS:
!
!	ELEMENT.rx.r		element to format
!	FORMAT_STR.rt.dx	string containing the formatting information
!				Note that throughout this module, '.dx' is used
!				for FORMAT_STR where in fact it only supports
!				'.dd' and '.ds'.  We need a notation to specify
!				'.dd' and '.ds'.
!	ELEMENT_TYPE.rl.v	data type of the element
!	RET_STRING.wt.dd	where to return the result
!	RET_FORMAT_ADR.wl.r	address of next char in format string
!	BAS_SCALE_FAC.rb.v	Scale factor (-6 <= x <= 0)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Disables ASTs and re-enables them if they are enabled at entry
!	based on whether K_AST_FLAG is set.  This flag is provided
!	for performance testing of the options.
!
!--

!+
! Allocate the parameter block and some local working storage for the
! action routines.
!-

    LOCAL
	AST_STATUS,
	PARAM_BLK : BLOCK [K_INTER_STO_LEN, BYTE];

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	RET_FORMAT_ADR : REF VECTOR,
	FORMAT_STR : REF BLOCK [, BYTE];

!+
! Clear the return string as it may already have data in it.  By copying
! a null string to the return string, we can make it null, avoid using
! a first time flag in the action routines (to do a copy instead of a con-
! catenate to the return string the first time), and always use concatenates.
!-

    STR$COPY_R_R8 (.RET_STRING, 0, %REF (0));

!+
! Do the first time initialization of the currency, radix point, and digit
! separator symbols.  Default to '$', '.', and ',' respectively.
!-

    IF .RA_D EQL 0
    THEN
	BEGIN
	LOCAL
	    DIGIT_SEP_STR : BLOCK [8, BYTE],
	    RADIX_PT_STR : BLOCK [8, BYTE],
	    CURRENCY_STR : BLOCK [8, BYTE];
!+
! Initialize a dynamic string to a null string.  It will be expanded as necess-
! ary.
!-
	DIGIT_SEP_STR [DSC$W_LENGTH] = 0;
	DIGIT_SEP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	DIGIT_SEP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	DIGIT_SEP_STR [DSC$A_POINTER] = 0;
	RADIX_PT_STR [DSC$W_LENGTH] = 0;
	RADIX_PT_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	RADIX_PT_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	RADIX_PT_STR [DSC$A_POINTER] = 0;
	CURRENCY_STR [DSC$W_LENGTH] = 0;
	CURRENCY_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	CURRENCY_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	CURRENCY_STR [DSC$A_POINTER] = 0;

	    BEGIN
	    MAP
		RADIX_PT_STR : VECTOR [2, LONG],
		DIGIT_SEP_STR : VECTOR [2, LONG],
		CURRENCY_STR : VECTOR [2, LONG];
	    LIB$CURRENCY(CURRENCY_STR);

!+
! Disable ASTs to guard against an AST right here which does a PRINT USING or
! a FORMAT$ which allocates another string resulting in its being lost forever.
!
! The disabling of ASTs will be controlled by K_AST_FLAG.
!-

	    IF K_AST_FLAG
	    THEN
		BEGIN
		AST_STATUS = $SETAST(ENBFLG = 0);
		CURRENCY_DESC = .CURRENCY_STR [0];
		CU_D = .CURRENCY_STR [1];

!+
! Re-enable ASTs if they were previously.
!-

		IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST(ENBFLG = 1);
		LIB$RADIX_POINT(RADIX_PT_STR);
		$SETAST(ENBFLG = 0);
		RADIX_PT_DESC = .RADIX_PT_STR [0];
		RA_D = .RADIX_PT_STR [1];
		IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST(ENBFLG = 1);
		LIB$DIGIT_SEP(DIGIT_SEP_STR);
		$SETAST(ENBFLG = 0);
		DIGIT_SEP_DESC = .DIGIT_SEP_STR [0];
		DI_D = .DIGIT_SEP_STR [1];
		IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST(ENBFLG = 1);
		END

	    ELSE
		BEGIN
		CURRENCY_DESC = .CURRENCY_STR [0];
		CU_D = .CURRENCY_STR [1];
		LIB$RADIX_POINT(RADIX_PT_STR);
		RADIX_PT_DESC = .RADIX_PT_STR [0];
		RA_D = .RADIX_PT_STR [1];
		LIB$DIGIT_SEP(DIGIT_SEP_STR);
		DIGIT_SEP_DESC = .DIGIT_SEP_STR [0];
		DI_D = .DIGIT_SEP_STR [1]
		END;

	    END;
	END;

!+
! Initialize the parameter block and the data base that Print Using
! will use.
!-

    PARAM_BLK [INTEGER_DIGITS] = PARAM_BLK [CHARACTER] = PARAM_BLK [FRACTION_DIGIT] =
    PARAM_BLK [PU_MASK] = 0;
    PARAM_BLK [RET_STR] = .RET_STRING;
    PARAM_BLK [ELEM] = .ELEMENT;
    PARAM_BLK [ELEM_TYPE] = .ELEMENT_TYPE;
    PARAM_BLK [SCALE_FACTOR] = .BAS_SCALE_FAC [0];

!+
! The format decoding routine takes over here and calls the output
! conversion routine after setting up PARAM_BLK.
!-

    IF NOT (DECODE_PROCESS_FORMAT (.FORMAT_STR, PARAM_BLK))
    THEN

!+
! Signal a fatal internal error in the RTL.  All errors should be caught
! in the routnes called by DECODE_PROCESS_FORMAT.
!-

	LIB$STOP (OTS$_FATINTERR);

    RET_FORMAT_ADR [0] = .PARAM_BLK [NEXT_CHAR];
    RETURN;
    END;				! End of routine BAS$$FORMAT_INT


%SBTTL 'DECODE_PROCESS_FORMAT - main driving routine'
ROUTINE DECODE_PROCESS_FORMAT (

	P_FORMAT_STR,	! format string
	P_PARAM_BLK) =	! print using parameter block

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	The plan of attack is to locate the start of the formatting sequence.
!	All characters up to the formatting sequence are concatenated onto
!	the return string.  A parameter block is then set up based on the
!	formatting information and OUTPUT_ARG is called to do the
!	actual formatting concatenating the result to the return string.
!	The beginning of the next formatting sequence is then searched for
!	and all characters up to this next formatting sequence are concatenated
!	onto the return string.
!
!	The SPAN_CONSTANT routine will position CHAR_CNT at the last character
!	before the formatting sequence.  CHAR_CNT = 0 implies that no leading
!	constant was found. The constant string up to the formatting sequence
!	is copied onto the return string. If no formatting sequence
!	is found, 0 is returned by SPAN_CONSTANT and a print using format error
!	is signalled; otherwise 1 is returned by SPAN_CONSTANT.
!
!	After the leading constant is located, the proper formatting sequence
!	is located and process.  Then the trailing constant is processed.
!
!	The calling structure of the routines is as follows:
!
!	BAS$$FORMAT_INT
!	  DECODE_PROCESS_FORMAT
!	    SPAN_CONSTANT
!	    SPAN_SINGLE_QUOTE
!	      SPAN_TEXT
!	    SPAN_BACKSLASH
!	    SPAN_NUMERIC
!	    OUTPUT_ARG
!	    SPAN_CONSTANT
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = DECODE_PROCESS_FORMAT (P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!
! IMPLICIT INPUTS:
!
!	CURRENCY_DESC	- descriptor for currency symbol
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!	0		- error
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE];

MAP
	CURRENCY_DESC : BLOCK [, BYTE];

LOCAL
	CHAR_CNT;	! keeps track of offset from beginning
			!  of format string

CHAR_CNT = .FORMAT_STR [DSC$W_LENGTH];
CHAR_CNT = 0;

!+
! SPAN_CONSTANT returns 0 if there is no format sequence or a null format
! string.
!-

IF NOT SPAN_CONSTANT (FORMAT_STR, .PARAM_BLK [RET_STR], CHAR_CNT)
THEN
    BEGIN
    BAS$$STOP (BAS$K_PRIUSIFOR);
    RETURN 1				! return if error
    END

ELSE
    BEGIN

!+
! Decode and process formatting sequence.
!-

    BIND CHAR = (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT) : BYTE;

    SELECTONEU .CHAR OF
	SET

	[CHAR_SINGLE_QUOTE] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		SPAN_SINGLE_QUOTE (FORMAT_STR, PARAM_BLK, CHAR_CNT);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_POUND] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR NUMERIC_MASK;
		PARAM_BLK [INTEGER_DIGITS] = 1;
		SPAN_NUMERIC (K_SPAN_INTEGER, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_DOLLAR] :			! floating currency

!+
! The SPAN_CONSTANT routine will have insured that the intial part of the
! formatting sequence is '$$'.
!-

		BEGIN
		CHAR_CNT = .CHAR_CNT + 2;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR DOLLAR_MASK
			OR NUMERIC_MASK;
		PARAM_BLK [INTEGER_DIGITS] = 1 + .CURRENCY_DESC [DSC$W_LENGTH];
		SPAN_NUMERIC (K_SPAN_INTEGER_NO_E, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_STAR] :			! asterisk fill

!+
! The SPAN_CONSTANT routine will have insured that the intial part of the
! formatting sequence is '**'.
!-

		BEGIN
		CHAR_CNT = .CHAR_CNT + 2;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR STAR_MASK
			OR NUMERIC_MASK;
		PARAM_BLK [INTEGER_DIGITS] = 2;
		SPAN_NUMERIC (K_SPAN_INTEGER_NO_E, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_PERIOD] :
		BEGIN

!+
! The SPAN_CONSTANT routine will have insured that the intial part of the
! formatting sequence is '.#'.
!-

		CHAR_CNT = .CHAR_CNT + 2;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR PERIOD_MASK
			OR NUMERIC_MASK;
		PARAM_BLK [FRACTION_DIGIT] = 1;
		SPAN_NUMERIC (K_SPAN_FRACTION, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK);
		END;

	[CHAR_BACKSLASH] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		IF NOT SPAN_BACKSLASH (FORMAT_STR, PARAM_BLK, CHAR_CNT)
		THEN
			BEGIN
			BAS$$STOP (BAS$K_PRIUSIFOR);
			RETURN 1;	! return if error
			END

		ELSE
			OUTPUT_ARG (PARAM_BLK)

		END;

	[CHAR_EXCLAMATION] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
		PARAM_BLK [CHARACTER] = 1;
		OUTPUT_ARG (PARAM_BLK)
		END;

	[OTHERWISE] :

!+
! This should never happen.
!-

		RETURN 0;		! return if error (this is a fatal
					!  internal error)

	TES
    END;

!+
! At this point, any trailing constant in the format string should be
! concatenated onto the return string.
!
! The return from SPAN_CONSTANT is ignored since we do not care at this
! point whether or not the constant string runs to the end of the format
! string.  In the initial call to SPAN_CONSTANT, we did care because
! a null formatting sequence must be signalled as an error.  If this
! code is executed, a legal formatting sequence has been found and processed.
! SPAN_CONSTANT is taking care to get CHAR_CNT to point just before the
! next formatting sequence (if one exists).
!-

SPAN_CONSTANT (FORMAT_STR, .PARAM_BLK [RET_STR], CHAR_CNT);

!+
! Now that the trailing constant has been handled; this routine
! has completed its work.
!-

PARAM_BLK [NEXT_CHAR] = .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT;

RETURN 1

END;					! End of routine DECODE_PROCESS_FORMAT

%SBTTL 'SPAN_CONSTANT - find start of format sequence'
ROUTINE SPAN_CONSTANT (

	P_FORMAT_STR,	! format string
	P_RETURN_STR,	! return string
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches FORMAT_STR for the start of a valid
!	formatting sequence beginning at the CHAR_CNT + 1st character
!	position in FORMAT_STR.  CHAR_CNT is set to the character position
!	just before the formatting sequence.  Thus CHAR_CNT returned
!	unchanged indicates that no constant string was found, i.e.,
!	CHAR_CNT currently points to the character position just before
!	the start of a format sequence.  The constant string is copied
!	onto the return string. The routine returns 0 if no
!	formatting sequence is located and 1 otherwise.
!
!	This routine will be called initially to determine the end of
!	any leading constant in the format string.  This routine
!	will be called after any formatting has taken place to determine
!	the end of any trailing constant in the format string.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_CONSTANT (P_FORMAT_STR.rt.dx, P_RETURN_STR.mt.dd,
!		P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_RETURN_STR	- address of string descriptor for return string
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is passed
!			   as the position 1 before the starting character
!			   position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully (format sequence
!			   located)
!	0		- no format sequence located
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	COMPLETION CODE
!	----------	-------------	--------------	---------------
!	abc$abc		0		0		0
!	abc$$abc	0		3		1
!	abc$abc**abc	0		7		1
!	abc'cccdef'cc	7		10		1
!	abc'cccdef*	7		7		0
!	abc'cccdef**	7		10		1
!	abc'ccc		7		7		0
!	
!--

BIND
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	RETURN_STR = (.P_RETURN_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

LOCAL
	TMP_STR : BLOCK [8, BYTE],	! temporary string descriptor
	FORMAT_STR_LEN : UNSIGNED WORD,	! temporary for format length in SCANC
	SCAN_MASK : BYTE,		! temporary for mask in SCANC
	START_CNS_CNT,			! initial offset that could possibly
					!  begin a constant in the format
					!  string
	CHAR_PTR;			! pointer to possible start point
					!  for formatting sequence

!+
! START_CNS_CNT should be the initial offset that could possible
! begin a constant string.
!-

START_CNS_CNT = .CHAR_CNT + 1;

!+
! Use SCANC to find the beginning of a formatting sequence.
! SCANC will be used to find the first 'possible' formatting character.
! Since SCANC can only stop on single character sequences, and we only
! want to stop on multiple character sequences in some cases
! ('.#', '**' and '$$),
! SCANC may have to be used repeatedly to skip over false alarms such
! as '.R', '$2' or '*b'.
!-

WHILE 1 DO				! This loop scans until the end
					!  of a leading or trailing constant
					!  is found
	BEGIN

	FORMAT_STR_LEN = .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT;
	SCAN_MASK = MASK_FORMAT_CHARS;
	CHAR_PTR = SCANC (FORMAT_STR_LEN,
		.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT,
		CLASS_TABLE, SCAN_MASK);
	IF .CHAR_PTR EQLU 0
	THEN
		BEGIN

!+
! If CHAR_CNT is not 0, then we are trying to span a trailing constant.
! If no formatting sequence is found, we should treat everything from
! START_CNS_CNT to the end of the string as a trailing constant.
!-

		IF .CHAR_CNT NEQU 0
		THEN

			BEGIN
			IF .FORMAT_STR [DSC$W_LENGTH] - .START_CNS_CNT GEQ 0
			THEN
				BEGIN
				TMP_STR [DSC$W_LENGTH] = 0;
				TMP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
				TMP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
				TMP_STR [DSC$A_POINTER] = 0;
				STR$RIGHT (TMP_STR, FORMAT_STR, START_CNS_CNT);
				STR$APPEND (RETURN_STR, TMP_STR);
				STR$FREE1_DX (TMP_STR);
				CHAR_CNT = .FORMAT_STR [DSC$W_LENGTH];
				END
			END;

		RETURN 0;		! return since end of format string
					!  was found
		END

	ELSE
		BEGIN
		BIND CHARS = (.CHAR_PTR) : VECTOR [, BYTE];
		CHAR_CNT = .CHAR_PTR - .FORMAT_STR [DSC$A_POINTER];

!+
! Check special cases ('.#', '$$' and '**').
!-

		IF .CHARS [0] EQLU CHAR_PERIOD
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 1
			THEN
				BEGIN
				IF .CHARS [1] EQLU CHAR_POUND
				THEN
					EXITLOOP

				ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-
	
					CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc.+"
				END

			ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc."
			END

		ELSE IF .CHARS [0] EQLU CHAR_DOLLAR
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 1
			THEN
				BEGIN
				IF .CHARS [1] EQLU CHAR_DOLLAR
				THEN
					EXITLOOP

				ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

					CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc$+"
				END

			ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc$"
			END

		ELSE IF .CHARS [0] EQLU CHAR_STAR
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 1
			THEN
				BEGIN
				IF .CHARS [1] EQLU CHAR_STAR
				THEN
					EXITLOOP

				ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

					CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc*+"
				END

			ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc*"
			END

		ELSE
			EXITLOOP

		END

	END;				! end of constant finding loop

!+
! If we get here we have moved CHAR_CNT to the character before
! the start of a format string.
!
! Concatentate constant string from FORMAT_STR onto RETURN_STR.
!
! Note that code similar to this is executed at the beginning of
! this module if a trailing constant is detected that extends to the
! end of the format string.
!-

IF .CHAR_CNT - .START_CNS_CNT GEQ 0
THEN
	BEGIN
	LOCAL CNS_LENGTH;
	CNS_LENGTH = .CHAR_CNT - .START_CNS_CNT + 1;
	TMP_STR [DSC$W_LENGTH] = 0;
	TMP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	TMP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	TMP_STR [DSC$A_POINTER] = 0;
	STR$LEN_EXTR (TMP_STR, FORMAT_STR, START_CNS_CNT, CNS_LENGTH);
	STR$APPEND (RETURN_STR, TMP_STR);
	STR$FREE1_DX (TMP_STR)
	END;

RETURN 1

END;					! End of routine SPAN_CONSTANT

%SBTTL 'SPAN_SINGLE_QUOTE - process single quote formatting classes'
ROUTINE SPAN_SINGLE_QUOTE (

	P_FORMAT_STR,	! format string
	P_PARAM_BLK,	! print using parameter block
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches FORMAT_STR for the start of something other
!	than one of the valid single quote format classes
!	(left-justify, center-justify, right-justify, extended)
!	beginning at the CHAR_CNT + 1st character
!	position in FORMAT_STR.  CHAR_CNT is then set to the last
!	character position in the formatting sequence.
!	Thus CHAR_CNT returned
!	unchanged indicates that no further formatting string was found.
!	The routine returns 0 if an illegal formatting character
!	formatting sequence is located and 1 otherwise.
!
!	This routine will be called initially to determine the end of
!	any leading constant in the format string.  This routine
!	will be called after any formatting has taken place to determine
!	the end of any trailing constant in the format string.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_SINGLE_QUOTE (P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r, P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is returned
!			   as the last position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)
!	----------	-------------	--------------
!	abc'cccdef'cc	4		7
!	abc'llldef'cc	4		7
!	abc'rrrdef'cc	4		7
!	abc'cccdef*	4		7
!	ab'lab		3		4
!	ab'		3		3
!	ab'z		3		3
!	
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT),
	CHAR = (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT) : BYTE;

LOCAL
	CHAR_PTR;			! pointer to possible start point
					!  for formatting sequence

IF .CHAR_CNT EQLU .FORMAT_STR [DSC$W_LENGTH]
THEN					! This is the case of a format string
					!  with just a single quote
	BEGIN
	PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
	PARAM_BLK [CHARACTER] = 1;
	RETURN 1
	END;

SELECTONEU .CHAR OF
	SET

	[CHAR_L, CHAR_LOWER_L] :
		BEGIN

!+
! Span L and l.
!-

		SPAN_TEXT (MASK_L, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK
		END;

	[CHAR_C, CHAR_LOWER_C] :
		BEGIN

!+
! Span C and c.
!-

		SPAN_TEXT (MASK_C, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR C_JUSTIFY_MASK
		END;

	[CHAR_R, CHAR_LOWER_R] :
		BEGIN

!+
! Span R and r.
!-

		SPAN_TEXT (MASK_R, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR R_JUSTIFY_MASK
		END;

	[CHAR_E, CHAR_LOWER_E] :
		BEGIN

!+
! Span E and e.
!-

		SPAN_TEXT (MASK_E, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR EXTEND_MASK
		END;

	[OTHERWISE] :
		BEGIN

!+
! Just a single quote followed by a constant string.
!-

		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
		PARAM_BLK [CHARACTER] = 1
		END;

		TES;

RETURN 1				! return on success

END;					! End of routine SPAN_SINGLE_QUOTE

%SBTTL 'SPAN_TEXT - span various text formatting classes'
ROUTINE SPAN_TEXT (

	P_SPAN_MASK,		! mask for SPANC instruction
	P_FORMAT_STR,		! format string
	P_CHAR_CNT,		! position withing format string
	P_FORMAT_LENGTH) =	! length of format sequence

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine spans a particular class of text formatting characters
!	based on SPAN_MASK.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_TEXT (P_SPAN_MASK, P_FORMAT_STR.rt.dx,
!		P_CHAR_CNT.ml.r, P_FORMAT_LENGTH.wl.r)
!
! FORMAL PARAMETERS:
!
!	P_SPAN_MASK	- address of a byte with the mask for the spanc
!			   instruction
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 2 before the point at which the format
!			   sequence scanc should start;
!			   this parameter is returned
!			   as the last position of the format sequence
!	P_FORMAT_LENGTH	- address of longword for format length
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	FORMAT_LENGTH
!	----------	-------------	--------------	-------------
!	abc'cccdef'cc	4		7		4
!	abc'llldef'cc	4		7		4
!	abc'rrrdef'cc	4		7		4
!	abc'eeedef'cc	4		7		4
!	abc'cccdef*	4		7		4
!	ab'lab		3		4		2
!	abc'lll		4		7		4
!	abc'r		4		5		2
!	
!--

BIND
	SPAN_MASK = (P_SPAN_MASK) : BYTE,
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT),
	FORMAT_LENGTH = (.P_FORMAT_LENGTH);

LOCAL
	FORMAT_STR_LEN : UNSIGNED WORD,	! temporary for format length in SCANC
	CHAR_PTR;			! pointer for SPANC routine return

FORMAT_STR_LEN = .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT - 1;
CHAR_PTR = SPANC (FORMAT_STR_LEN, .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT + 1,
	CLASS_TABLE, SPAN_MASK);

IF .CHAR_PTR NEQU 0
THEN
	FORMAT_LENGTH = .CHAR_PTR - (.FORMAT_STR [DSC$A_POINTER]
		+ .CHAR_CNT - 1)	! this gets the case abc'cccdef*

ELSE IF .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT + 1 GTRU 2
THEN
	FORMAT_LENGTH = .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT + 1
					! this gets the case abc'lll

ELSE
	FORMAT_LENGTH = 2;		! this gets the case abc'r

CHAR_CNT = .CHAR_CNT + .FORMAT_LENGTH - 1;

RETURN 1				! return when done

END;					! End of routine SPAN_TEXT

%SBTTL 'SPAN_BACKSLASH - process backslash formatting class'
ROUTINE SPAN_BACKSLASH (

	P_FORMAT_STR,	! format string
	P_PARAM_BLK,	! print using parameter block
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine finds the end of a backslash formatting sequence
!	which consists of a backslash followed by some number of blanks (>= 0)
!	followed by a backslash.  The initial backslash has been located
!	when this routine is called.  An error is returned if something
!	other than a proper backslash formatting sequence is located.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_BACKSLASH (P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r, P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is returned
!			   as the last position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully (format sequence
!			   for backslash located)
!	0		- no backslash format sequence located
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	return value
!	----------	-------------	--------------	------------
!	abc\\def	4		5		1
!	abc\   \def	4		8		1
!	abc\def		4		4		0
!	abc\   def	4		4		0
!	abc\   <eos>	4		4		0
!	
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

LOCAL
	CHAR_PTR;			! pointer to possible start point
					!  for formatting sequence

PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;

!+
! Span blanks; next character should then be another backslash.
!-

CHAR_PTR = CH$FIND_NOT_CH (.FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT,
	.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT, CHAR_SPACE);

!+
! CHAR_PTR should point to one past the last blank if a blank terminator
! was found; otherwise CHAR_PTR is the null pointer.
!
! In VAX-11 Bliss-32 V3, SKPC should be a BUILTIN allowing output registers
! which could make the computation of the number of charaters in the
! formatting sequence more efficient.
!-

IF CH$FAIL (.CHAR_PTR)
THEN
	RETURN 0			! this return gets the case
					!  abc\   <eos>
					!  which is a print using format error

ELSE
	BEGIN
	BIND CHARS = (.CHAR_PTR) : VECTOR [, BYTE];

!+
! Make sure that the first character past the blanks is a backslash.
!-

	IF .CHARS [0] EQLU CHAR_BACKSLASH
	THEN
		BEGIN
		PARAM_BLK [CHARACTER] = .CHAR_PTR -
			(.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT) + 2;
		CHAR_CNT = .CHAR_CNT + .PARAM_BLK [CHARACTER] - 1;
		RETURN 1;		! this return gets the case abc\   \def
					!  or the case abc\\def
		END

	ELSE
		RETURN 0;		! this return gets the case abc\   def

	END

END;					! End of routine SPAN_BACKSLASH

%SBTTL 'SPAN_NUMERIC - processing numeric format class'
ROUTINE SPAN_NUMERIC (

	P_SPAN_MODE,	! numeric formatting mode
	P_FORMAT_STR,	! format string
	P_CHAR_CNT,	! position withing format string
	P_PARAM_BLK) =	! print using parameter block

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles various portions of a numeric formatting
!	sequence based on SPAN_MODE.  CHAR_CNT will be returned as the last
!	character of the particular portion of the numeric formatting
!	sequence under consideration.  This routine will call itself
!	recursively.  NUMERIC_MASK should be set in the main driving
!	routine before a call to this routine.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_NUMERIC (P_SPAN_MODE.rl.r, P_FORMAT_STR.rt.dx,
!		P_CHAR_CNT.ml.r, P_PARAM_BLK.mr.r)
!
! FORMAL PARAMETERS:
!
!	P_SPAN_MODE	- address of longword for type of numeric span
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is passed
!			   as the position 1 before the starting character
!			   position of the format sequence
!	P_PARAM_BLK	- address of print using parameter block
!
! IMPLICIT INPUTS:
!
!	DIGIT_SEP_DESC	- descriptor for digit group separator
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!
! SIDE EFFECTS:
!
!	NONE
!	
!--

BIND
	SPAN_MODE = (P_SPAN_MODE),
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

MAP
	DIGIT_SEP_DESC : BLOCK [, BYTE];

LOCAL
	E_FLAG,		! 1 if E formatting is allowed; 0 otherwise
	PERIOD_MODE,	! fraction mode (either _E or _NO_E)
	INTEGER_MODE,	! 1 if integer mode; 0 otherwise (fraction mode)
	TMP_LEN,	! temporary length for format sequence
	CHAR_PTR;	! pointer to character in format string

CASE .SPAN_MODE FROM K_SPAN_INTEGER TO K_SPAN_FRACTION_NO_E OF
	SET

	[K_SPAN_INTEGER] :
		BEGIN
		E_FLAG = 1;
		PERIOD_MODE = K_SPAN_FRACTION;
		INTEGER_MODE = 1
		END;

	[K_SPAN_INTEGER_NO_E] :
		BEGIN
		E_FLAG = 0;
		PERIOD_MODE = K_SPAN_FRACTION_NO_E;
		INTEGER_MODE = 1
		END;

	[K_SPAN_FRACTION] :
		BEGIN
		E_FLAG = 1;
		INTEGER_MODE = 0
		END;

	[K_SPAN_FRACTION_NO_E] :
		BEGIN
		E_FLAG = 0;
		INTEGER_MODE = 0
		END;

	[OUTRANGE] :

!+
! This should never happen.
!-

		RETURN 0		! return here is an internal error

	TES;

!+
! Span pound signs.
!
! In VAX-11 Bliss-32 V3, SKPC should be a BUILTIN allowing output registers
! which could make the computation of the number of charaters in the
! formatting sequence more efficient.
!-

CHAR_PTR = CH$FIND_NOT_CH (.FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT,
	.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT, CHAR_POUND);

IF CH$FAIL (.CHAR_PTR)
THEN
	BEGIN
	IF .INTEGER_MODE
	THEN
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS]
			+ .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT

	ELSE
		PARAM_BLK [FRACTION_DIGIT] = .PARAM_BLK [FRACTION_DIGIT]
			+ .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT;
					! remember that there is already
					!  one fraction digit in the '.#' case

	CHAR_CNT = .FORMAT_STR [DSC$W_LENGTH];
	END

ELSE
	BEGIN
	BIND CHARS = (.CHAR_PTR) : VECTOR [, BYTE];
	TMP_LEN = .CHAR_PTR - (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT);
	IF .INTEGER_MODE
	THEN
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS]
			+ .TMP_LEN

	ELSE
		PARAM_BLK [FRACTION_DIGIT] = .PARAM_BLK [FRACTION_DIGIT]
			+ .TMP_LEN;
					! remember that there is already
					!  one fraction digit in the '.#' case

	CHAR_CNT = .CHAR_CNT + .TMP_LEN;

	SELECTONEU .CHARS [0] OF
	    SET

	    [CHAR_COMMA] :

!+
! Commas should not occur in the fractional part.
!-

		IF .INTEGER_MODE
		THEN
			BEGIN

!+
! Each comma is picked up separately rather than doing a spanc instruction
! with pound signs and commas since the digit separator on output can
! have a length other than 1.
!-

			PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK]
				OR COMMA_MASK;
			PARAM_BLK [INTEGER_DIGITS] =
				.PARAM_BLK [INTEGER_DIGITS]
				+ .DIGIT_SEP_DESC [DSC$W_LENGTH];
			CHAR_CNT = .CHAR_CNT + 1;
			SPAN_NUMERIC (K_SPAN_INTEGER_NO_E,
				FORMAT_STR, CHAR_CNT, PARAM_BLK)
			END;

	    [CHAR_PERIOD] :

!+
! Periods should not occur in the fractional part.
!-

		IF .INTEGER_MODE
		THEN
			BEGIN
			PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK]
				OR PERIOD_MASK;
			CHAR_CNT = .CHAR_CNT + 1;
			SPAN_NUMERIC (.PERIOD_MODE, FORMAT_STR, CHAR_CNT,
				PARAM_BLK)
			END;

	    [CHAR_MINUS] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR MINUS_MASK
		END;

	    [CHAR_CARAT] :
		IF .E_FLAG
		THEN
			BEGIN

!+
! If the next three characters are carats, we should indicate that E format
! is desired and move CHAR_CNT to last carat.
!
! For efficiency, we make sure that we have four carats beginning with
! the character pointed to by CHAR_PTR which we know is a carat.
!-

			IF .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT GTRU 3
				AND ..CHAR_PTR EQLU .E_FORMAT
					! Note that we want .. here since
					!  CHAR_PTR is an address
					!  and we want the actual value
					!  pointed to by that address
			THEN
				BEGIN
				PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK]
					OR E_MASK;
				CHAR_CNT = .CHAR_CNT + 4;
				END

			END;

	    TES

	END;

RETURN 1

END;					! End of routine SPAN_NUMERIC

%SBTTL 'OUTPUT_ARG - convert and format'
ROUTINE OUTPUT_ARG (			! convert and format the argument

	P_PARAM_BLK) =	! print using paramter block

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This action routine is the heart of the whole thing.
!	All of the formatting and most of the error checking will be done here.
!
! FORMAL PARAMETERS:
!
!	P_PARAM_BLK.mr.r	- parameter block
!
! IMPLICIT INPUTS:
!
!	CURRENCY_DESC		- descriptor for currency symbol
!	DIGIT_SEP_DESC		- descriptor for digit group separator
!	RADIX_PT_DESC		- descriptor for radix point
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    LOCAL
	DSC : BLOCK [8, BYTE],			! temp for converting and concatenating
	OUT_STR_LEN;				! length returned by conversion routine

    BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE];

    !+
    ! Do error checking for the format field.
    !-

    !+
    ! Set up a temp dynamic string descriptor to use for numeric and text conversions and
    ! string concatenates.
    !-

    DSC [DSC$W_LENGTH] = 0;
    DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
    DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DSC [DSC$A_POINTER] = 0;

    !+
    ! This is where the action is.  A case is done on the data type to determine
    ! the proper syntaxing and the conversions which are necessary.  The conversion
    ! routines do most of the formatting.
    !-

    CASE .PARAM_BLK [ELEM_TYPE] FROM DSC$K_DTYPE_WU TO DSC$K_DTYPE_T OF
	SET

	[DSC$K_DTYPE_W, DSC$K_DTYPE_L] :
	    BEGIN

	    !+
	    ! Integers.
	    ! Do the necessary syntax checking.
	    ! Convert the value to double precision and call the appropriate
	    ! conversion.
	    !-

	    LOCAL
		D_VALUE : VECTOR [2];		! hold double precision floating value

	    CVTLD (.PARAM_BLK [ELEM], D_VALUE [0]);

	    SELECTONEU .PARAM_BLK [PU_MASK] OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_D_F (D_VALUE, .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, DSC, 0,	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (D_VALUE, 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_D_E (D_VALUE, .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR], 0,	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (D_VALUE, 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :
!+
! Text formats
!-
		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_F] :

	    !+
	    ! Floating - single precision
	    !-

	    BEGIN

	    SELECTONEU .PARAM_BLK [PU_MASK] OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_F_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, DSC,
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_F_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR],
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
!+
! E format will only not fit when a negative number is expected to fit in a
! field of width 1.
!-
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_D] :

	    !+
	    ! Floating - double precision
	    !-

	    BEGIN

	    SELECTONEU .PARAM_BLK [PU_MASK] OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_D_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, DSC, .PARAM_BLK [SCALE_FACTOR],	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, .PARAM_BLK [SCALE_FACTOR]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_D_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR], .PARAM_BLK [SCALE_FACTOR],	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, .PARAM_BLK [SCALE_FACTOR]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_T] :

	    !+
	    ! Text
	    !-

	    BEGIN

	    !+
	    ! Allocate a temporary and make it a fixed length string so that
	    ! truncating and padding occur properly.
	    !-

	    STR$GET1_DX (PARAM_BLK [CHARACTER], DSC);
	    DSC [DSC$B_CLASS] = DSC$K_CLASS_S;

	    !+
	    ! Based on the bits in PU_MASK, go do the right type of justification
	    !-

	    SELECTONEU .PARAM_BLK [PU_MASK] OF
		SET

		[L_JUSTIFY_MASK] :
		    BEGIN

		    !+
		    ! Left justify the string in the return string
		    ! This should just amount in a copy.  Truncate on the right if necessary.
		    !-

		    STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
		    STR$APPEND (.PARAM_BLK [RET_STR], DSC);
		    END;

		[R_JUSTIFY_MASK] :

		    !+
		    ! Right justify the string.
		    ! Use concatenate to prefix the right number of spaces to the
		    ! front.  If overflow occurs, then left justify the string
		    ! and truncate on the right.
		    !-

		    BEGIN

		    LOCAL
			LENGTH;			! Length of the element to format

		    LENGTH = .(.PARAM_BLK [ELEM])<0, 16>;

		    IF .LENGTH GEQ .PARAM_BLK [CHARACTER]
		    THEN
			BEGIN

			!+
			! String overflow
			!-

			STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);
			END
		    ELSE
			BEGIN

			!+
			! The string will fit; do an RSET.
			!-

			BAS$RSET (DSC, .PARAM_BLK [ELEM]);
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);
			END;

		    END;

		[C_JUSTIFY_MASK] :
		    BEGIN

		    !+
		    ! This is a combination of concatenating spaces on the front and
		    ! the end if necessary.
		    ! If overflow occurs, left justify the string and truncate on the
		    ! right.
		    !-

		    LOCAL
			LENGTH;			! Length of the element to format

		    LENGTH = .(.PARAM_BLK [ELEM])<0, 16>;

		    IF .LENGTH GEQ .PARAM_BLK [CHARACTER]
		    THEN
			BEGIN

			!+
			! String overflow
			!-

			STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);
			END
		    ELSE
			BEGIN

			!+
			! The string will fit; do an RSET into the left part followed by a copy
			! into the rest of the string
			!-

			LOCAL
			    T_LENGTH,		! Temp length for STR$GET1
			    T_DSC : BLOCK [8, BYTE];	! Temp descriptor

			T_LENGTH = .PARAM_BLK [CHARACTER] - ((.PARAM_BLK [CHARACTER] + 1) - .LENGTH)/2;
			T_DSC [DSC$W_LENGTH] = 0;
			T_DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
			T_DSC [DSC$A_POINTER] = 0;
			STR$GET1_DX (T_LENGTH, T_DSC);
			T_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
			BAS$RSET (T_DSC, .PARAM_BLK [ELEM]);
			STR$COPY_DX_R8 (DSC, T_DSC);
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);
			T_DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
			STR$FREE1_DX (T_DSC);
			END;

		    END;

		[EXTEND_MASK] :
		    BEGIN

		    !+
		    ! Extended string
		    ! Copy the text into the destination string and pad with spaces if
		    ! there is still room at the end.
		    !-

		    LOCAL
			LENGTH;			! Length of the element to format

		    LENGTH = .(.PARAM_BLK [ELEM])<0, 16>;

		    IF .LENGTH GEQ .PARAM_BLK [CHARACTER]
		    THEN

		    !+
		    ! String overflow
		    !-

			STR$APPEND (.PARAM_BLK [RET_STR], .PARAM_BLK [ELEM])
		    ELSE
			BEGIN

			!+
			! The string will fit; do a copy.
			!-

			STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
			STR$APPEND (.PARAM_BLK [RET_STR], DSC);
			END;

		    END;

		[OTHERWISE] :

		    !+
		    ! Error - format is for numeric element
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    END;

	[INRANGE, OUTRANGE] :

	    !+
	    ! Unsupported data types
	    !-

	    LIB$STOP (OTS$_FATINTERR);
	TES;

!+
! Return the temporary string allocated.
!-
    STR$FREE1_DX (DSC);
    RETURN 1;
    END;				! End of routine OUTPUT_ARG

%SBTTL 'End of module'
END					! End of module BASFORINT.B32
ELUDOM
