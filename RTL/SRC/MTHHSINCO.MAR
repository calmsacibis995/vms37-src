	.TITLE	MTH$HSINCOS 	; Floating Point Sine, Cosine and Sincos
				;    Functions
	.IDENT /2-006/		; File:	MTHHSINCOS.MAR	EDIT: RNH2006
; 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; 
; FACILITY:	MATH LIBRARY
;++
; ABSTRACT:
; 
; MTH$HSIN and MTH$HCOS are functions which return the floating point
; sine or cosine value of their single precision floating point argu-
; ment (radians). The call is standard call-by-reference.
; MTH$HSIN_R5 and MTH$HCOS_R5 are special routines which are the same
; as MTH$HSIN and MTH$HCOS  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
;
; MTH$HSINCOS  is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point radian argument.
; The call is standard call-by-reference.  MTH$HSINCOS_R5 is a special 
; routine  which  is  the  same  as  MTH$HSINCOS, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
; MTH$HSIND and MTH$HCOSD are functions which return the floating point
; sine  or  cosine value of their single precision floating point argu-
; ment (degrees). The call is standard call-by-reference.
; MTH$HSIND_R5 and MTH$HCOSD_R5 are special routines which are the same
; as MTH$HSIND and MTH$HCOSD  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
; 
; MTH$HSINCOSD is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point degree argument.
; The call is standard call-by-reference. MTH$HSINCOSD_R5 is a special 
; routine  which  is  the  same  as MTH$HSINCOSD, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
;--
; 
;--
;
; VERSION: 1
;
; HISTORY:
; AUTHOR:
;	John A. Wheeler, 21-Aug-1979: Version 1
;
; MODIFIED BY:
;
;
;
;
; VERSION: 2
;
; HISTORY:
; AUTHOR:
;	Bob Hanek, 28-Aug-1981: Version 2
;
; MODIFIED BY:
;
;
;

	.SBTTL	HISTORY	; Detailed Current Edit History

;
; Edit History for Version 1 of MTH$HSINCOS 
;
; 1-001 - Adapted from MTH$GSINCOS version 1-001.  JAW 21-Aug-1979
; 1-002 - Improve argument reduction scheme for greater accuracy.  Also
;	  change MOVH to MOVO in MTH$HCOS.  JAW 28-Jan-1980
;
;
; Edit History for Version 2 of MTH$HSINCOS 
;
; 2-001 - Changed W^ modifiers to G^ on external references RNH 09-Sep-81
; 2-002 - Changed MTH$AL_4_OV_PI to MTH$AL_4_OV_PI_V  RNH 29-Sep-81
; 2-003 - Included check for A2=0 before decrementing exponent.  RNH 02-Oct-81
; 2-004 - Included G^ modifiers on references to MTH$AL_4_OV_PI_V.
;	  RNH 15-Oct-81
; 2-005 - Modified logic for converting reduced argument from integer to
;	  floating point format to avoid modifying exponent of a floating
;	  point zero.  RNH 21-Oct-81
; 2-006 - Modified REDUCE_LARGE logic to eliminate bug reported in QAR 896.
;         RNH 14-Jan-82

	.SBTTL	DECLARATIONS	-	 Declarative Part of Module

; 
; INCLUDE FILES:	MTHJACKET.MAR

; EXTERNAL SYMBOLS:
; 
	.DSABL	GBL
	.EXTRN	MTH$AL_4_OV_PI_V
	.EXTRN	MTH$$SIGNAL
	.EXTRN	MTH$K_FLOUNDMAT
	.EXTRN	MTH$$JACKET_TST
; 
; EQUATED SYMBOLS:
   
	X_1_OV_45        = ^XC16C

; 
; MACROS:	

	$SFDEF			; Define SF$ (stack frame) symbols
	$PSLDEF			; Define PSL$ symbols

; PSECT DECLARATIONS:

	.PSECT	_MTH$CODE	PIC,SHR,LONG,EXE,NOWRT
				; program section for math routines
; 
; OWN STORAGE:	none
; 
; CONSTANTS:

H_PI_OV_4:
	.OCTA	^X01B8C517898C846942D1B544921F4000	; .785398163397448309615660845819876E+000
H_9_PI_OV_4:
	.OCTA	^XE1EF5DB9BABEB4F6CB2BABECC4634003	; .706858347057703478654094761237888E+001
H_3_PI_OV_4:
	.OCTA	^X414A93D12729234F321DC7F32D974002	; .235619449019234492884698253745963E+001
H_5_PI_OV_4:
	.OCTA	^XC226F65CEBEFE5835385A295F6A74002	; .392699081698724154807830422909938E+001
H_7_PI_OV_4:
	.OCTA	^X21812C74585B53DCBA77BE9B5FDB4003	; .549778714378213816730962592073913E+001
H_2_OV_PI:
	.OCTA	^XEA6AAFA3F84E2A539C8806DC45F34000	; .636619772367581343075535053490057E+000




H_M1:
	.OCTA	^X0000000000000000000000000000C001	; -1
H_45:
	.OCTA	^X00000000000000000000000068004006	; .450000000000000000000000000000000E+002
H_M45:
	.OCTA	^X0000000000000000000000006800C006	;-.450000000000000000000000000000000E+002
H_SMALLD:
	.OCTA	^X81A5A6FE152E7B863C1FC1A6CA5D3FCD	; .397569335182939582162818212372099E-015
H_1_OV_45:
	.OCTA	^X6C1616C1C16C6C1616C1C16C6C163FFB	; .222222222222222222222222222222222E-001
H_CONVERT:
	.OCTA	^X90B9CDD2D8BE15C19D39A252DF463FF7	; .182829251994329576923690768488613E-002
H_90_OV_PI:
	.OCTA	^X81A5A6FE152E7B863C1FC1A6CA5D4005	; .286478897565411604383990774070526E+002
H_SMALLEST_DEG:
	.OCTA	^X81A5A6FE152E7B863C1FC1A6CA5D0006	; .481585800969978913643230731487614-4930


PI_OV_2:	; Multiples of pi/2 in three pieces - High, medium, and low
; pi/2
	.OCTA	^X01B8C517898C846942D1B544921F4001	; .157079632679489661923132169163975E+001
	.OCTA	^X000820BAC740A67CE0889024CD123F8E	; .433590506506189051239852201296347E-034
	.OCTA	^X0001263311A60B46D511487E00063F13	; .226413682029618087497148980272311E-071
; pi
	.OCTA	^X01B8C517898C846942D1B544921F4002	; .314159265358979323846264338327950E+001
	.OCTA	^X000420BBC740A67CE0889024CD123F8F	; .867181013012378102479704402598771E-034
	.OCTA	^X00014C66234C168CAA2290FD000C3F13	; .226435387088568365806569978272427E-071
; 3*pi/2
	.OCTA	^X414A93D12729234F321DC7F32D974003	; .471238898038468985769396507491925E+001
	.OCTA	^X8002188C95707CDDA866EC1B59CD3F90	; .130077151951856715371955660390120E-033
	.OCTA	^X0001729934F221D27F33D97C00123F13	; .226457092147518644115990976272543E-071
; 2*pi
	.OCTA	^X01B8C517898C846942D1B544921F4003	; .628318530717958647692528676655901E+001
	.OCTA	^X800220BBC740A67CE0889024CD123F90	; .173436202602475620495940880520362E-033
	.OCTA	^X400198CC46982D18544421FB00193F13	; .226478797206468922425411974273373E-071



	.SBTTL	COEFFICIENT TABLES	-	Series Coefficients




;
; Polynomial Coefficient tables for arguments in radians
;

COSTBR1:	; HCOS coefficients for arguments less than 1/2
	.OCTA	^X4D97F522D14447A3118726F0F1903FB1	; C12 = 0.160771306639506109108089403716712E-23
	.OCTA	^X3AE008A9EF97457B15E55D960CE3BFBB	; C11 = -.889676247791254258869706423600327E-21
	.OCTA	^X8E83A5FFB3DD840A29E1BA28E5423FC3	; C10 = 0.411031761121448368679142501935396E-18
	.OCTA	^X72DFE0F41183CAA5949D863B6827BFCC	; C 9 = -.156192069685535803957147887022910E-15
	.OCTA	^X36AAD1F8435B5A5F3B813E73AE7F3FD4	; C 8 = 0.477947733238737935166697107897973E-13
	.OCTA	^X70AB98F3D66FD1F807C94A8C9397BFDC	; C 7 = -.114707455977297247064199094253574E-10
	.OCTA	^XC95102CD4C0D7B548D898EFF1EED3FE4	; C 6 = 0.208767569878680989792037344591678E-08
	.OCTA	^X3F03A4A6F016C72E89F5FB7727E4BFEB	; C 5 = -.275573192239858906525573155827282E-06
	.OCTA	^XACB719FA01A0A01A1A0101A0A01A3FF1	; C 4 = 0.248015873015873015873015873002486E-04
	.OCTA	^X6B7B16C1C16C6C1616C1C16C6C16BFF7	; C 3 = -.138888888888888888888888888888886E-02
	.OCTA	^X55555555555555555555555555553FFC	; C 2 = 0.416666666666666666666666666666667E-01
	.OCTA	^X0000000000000000000000000000C000	; C 1 = -.500000000000000000000000000000000E+00
	.OCTA	^X00000000000000000000000000004001	; C 0 = 0.100000000000000000000000000000000E+01
COSLENR1 = .-COSTBR1/16

COSTBR2:	; HCOS coefficients for arguments greater than 1/2
	.OCTA	^XCB3CA11FD05904F0F958753F86ABBFA8	; C13 = -.246547279050635021532298267328175E-26
	.OCTA	^XE58A4292A30E00FA924CD9E7F2CC3FB1	; C12 = 0.161171037087677335393034991279632E-23
	.OCTA	^XBB0457F2D240DFF7074A963F0CE3BFBB	; C11 = -.889679108386861988666629662157980E-21
	.OCTA	^X7F2016A39B91DB57AC0ABA3FE5423FC3	; C10 = 0.411031762308321448545359420888210E-18
	.OCTA	^X36067A4A2E4AE50597BB863B6827BFCC	; C 9 = -.156192069685850600096129412574883E-15
	.OCTA	^X59F70DCB67DBE68B3B813E73AE7F3FD4	; C 8 = 0.477947733238738488049454686714854E-13
	.OCTA	^XF302B98F04ACD20907C94A8C9397BFDC	; C 7 = -.114707455977297247128020387861641E-10
	.OCTA	^XB50C08874D327B548D898EFF1EED3FE4	; C 6 = 0.208767569878680989792082491835938E-08
	.OCTA	^XA0BDB777F016C72E89F5FB7727E4BFEB	; C 5 = -.275573192239858906525573170324063E-06
	.OCTA	^XDA0619F801A0A01A1A0101A0A01A3FF1	; C 4 = 0.248015873015873015873015872998975E-04
	.OCTA	^X6A7816C1C16C6C1616C1C16C6C16BFF7	; C 3 = -.138888888888888888888888888888881E-02
	.OCTA	^X55555555555555555555555555553FFC	; C 2 = 0.416666666666666666666666666666667E-01
	.OCTA	^X37B226053F4BD4612E3E31A184923F83	; C 1 = 0.178423084933010669402836294836620E-37
	.OCTA	^X3CFD079248FB25CD73ED76B9390EBF7A	; C 0 = -.280758778510761953917854137379023E-40
COSLENR2 = .-COSTBR2/16

SINTBR:		; HSIN coefficients 
	.OCTA	^XD4C61000449213EBC8964962CF1CBFA3	; C13 = -.913324410322884674954498158136924E-28
	.OCTA	^X2221203809AF2C0DD7E285EA3F3B3FAD	; C12 = 0.644684924220922497101113258467788E-25
	.OCTA	^X84EC93C5A89E2964FD21406E761BBFB6	; C11 = -.386817005082248997409247626109339E-22
	.OCTA	^X9E96DF7A78D985AA8383EF6D71B83FBF	; C10 = 0.195729410624566279144186414368425E-19
	.OCTA	^XFB50B6718EB1FC961400B4682F49BFC8	; C 9 = -.822063524662382534371099856996409E-17
	.OCTA	^X80BD7980E3009EE00AD47703952C3FD0	; C 8 = 0.281145725434552057046251568225060E-14
	.OCTA	^XFC1BDC77653BF11B3B813E73AE7FBFD8	; C 7 = -.764716373181981647537621515294725E-12
	.OCTA	^X876C0B4837CA97CA86D0613A61243FE0	; C 6 = 0.160590438368216145993913653852631E-09
	.OCTA	^X12472F6E747E38FE544E567FAE64BFE7	; C 5 = -.250521083854417187750521070332621E-07
	.OCTA	^XFC6588DFAC1C38FA6C733A5571DE3FEE	; C 4 = 0.275573192239858906525573192227787E-05
	.OCTA	^X9EFA1A0101A0A01A1A0101A0A01ABFF4	; C 3 = -.198412698412698412698412698412692E-03
	.OCTA	^X11111111111111111111111111113FFA	; C 2 = 0.833333333333333333333333333333333E-02
	.OCTA	^X5555555555555555555555555555BFFE	; C 1 = -.166666666666666666666666666666667E+00
	.OCTA	^X00000000000000000000000000000000	; C 0 = 0.000000000000000000000000000000000E+00
SINLENR = .-SINTBR/16





;
; Polynomial coefficients for arguments in cycles
;

COSTBC1:	; HCOS coefficients for arguments less than 2/pi
	.OCTA	^X6991E00DFF0BDBB5E54BD2D782953FA9	; C12 = 0.487939182477553571356117394297587E-26
	.OCTA	^XE3B856AF4559F70A207AF8FE52ADBFB3	; C11 = -.437733098313663244695263584987100E-23
	.OCTA	^XD774953A9DD7AA9BF64C3074EF6E3FBC	; C10 = 0.327848355196045923822748382008492E-20
	.OCTA	^XEC7C80840F585191F584591A2A0CBFC6	; C 9 = -.201965339688246071371326879926348E-17
	.OCTA	^XA5A51331FFA8E5782D7E2C2F20C63FCF	; C 8 = 0.100188646163627078155706015713197E-14
	.OCTA	^XC5EECE274671F2C7B1284F44B6E2BFD7	; C 7 = -.389807317125967543759281489931826E-12
	.OCTA	^XADA7957077F628DD63CC8A37F9D33FDF	; C 6 = 0.115011591279740515226290113386273E-09
	.OCTA	^XEC9932997B73BA9A04A8F2A2A6D1BFE7	; C 5 = -.246113695049419975400908382825204E-07
	.OCTA	^XA796B5174E85AF461BAB0689E1F53FEE	; C 4 = 0.359086044859151007906920399113103E-05
	.OCTA	^X1324BED94FAD9FC5CBFFC7E355D3BFF5	; C 3 = -.325991886927390013641431831750624E-03
	.OCTA	^XAEDAE00F33013B35B5ACF08103C13FFB	; C 2 = 0.158543442438155008522852103985523E-01
	.OCTA	^X0118D9B3ADC4E5A4E45DCC9B3BD3BFFF	; C 1 = -.308425137534042456838577843746130E+00
	.OCTA	^X00000000000000000000000000004001	; C 0 = 0.100000000000000000000000000000000E+01
COSLENC1 = .-COSTBC1/16

COSTBC2:	; HCOS coefficients for arguments greater than 2/pi
	.OCTA	^XB4D349EB38B2ABF923FD3D877678BF9F	; C13 = -.461569527682893815442487053139510E-29
	.OCTA	^XC0BA99A4EA1CD7F634CBE2A0838B3FA9	; C12 = 0.489152360078513159040691202371979E-26
	.OCTA	^X83E4A858C1364D73E8D6405B52AEBFB3	; C11 = -.437734505766522082644418686751413E-23
	.OCTA	^X4A09FFED7A9AEC82F695308CEF6E3FBC	; C10 = 0.327848356142723100299220397526843E-20
	.OCTA	^XE4EE0516EF67CB53F818591A2A0CBFC6	; C 9 = -.201965339688653120905083328849526E-17
	.OCTA	^XA4E830BBCE4A437F2D7F2C2F20C63FCF	; C 8 = 0.100188646163627194052426758953019E-14
	.OCTA	^XB2207548DEE9F2D8B1284F44B6E2BFD7	; C 7 = -.389807317125967543976163705868975E-12
	.OCTA	^XBA8A276779FB28DD63CC8A37F9D33FDF	; C 6 = 0.115011591279740515226314985335528E-09
	.OCTA	^XBFF34D7D7B73BA9A04A8F2A2A6D1BFE7	; C 5 = -.246113695049419975400908395772241E-07
	.OCTA	^X8B09B5154E85AF461BAB0689E1F53FEE	; C 4 = 0.359086044859151007906920399108020E-05
	.OCTA	^X1230BED94FAD9FC5CBFFC7E355D3BFF5	; C 3 = -.325991886927390013641431831750612E-03
	.OCTA	^XAEDAE00F33013B35B5ACF08103C13FFB	; C 2 = 0.158543442438155008522852103985523E-01
	.OCTA	^X08C2CD986E262D2522EF64DFDE9EBFFC	; C 1 = -.584251375340424568385778437461297E-01
	.OCTA	^X3CFD079248FB25CD73ED76B9390EBF7A	; C 0 = -.280758778510761953917854137379023E-40
COSLENC2 = .-COSTBC2/16

SINTBC:		; HSIN coef for arg in cycles
	.OCTA	^X50D605FA71773F061C71B2505CA4BF9A	; C13 = -.134292531932709184738903357273452E-30
	.OCTA	^XF52F0A0E2014A9C6A852C91C859A3FA4	; C12 = 0.153671931033116475618527691201462E-27
	.OCTA	^XF4D03ACBBC84F8E29226F7B97215BFAE	; C11 = -.149476468765572889126195698007448E-24
	.OCTA	^XCFFC580F400FA5321601020D28773FB8	; C10 = 0.122614998471149687223464200787446E-21
	.OCTA	^X0B4E3504E93BD7BBF93942118A40BFC1	; C 9 = -.834858983481116051554128247160153E-19
	.OCTA	^X63388C8BDDA68A62933532AFAAEC3FCA	; C 8 = 0.462870462883468265624175129772022E-16
	.OCTA	^XCEB7ADED487E39135574B9F16FADBFD3	; C 7 = -.204102633966414405274021790692211E-13
	.OCTA	^X1E02D09ECFC4332818D634D0E8F43FDB	; C 6 = 0.694845327388662940890490316603094E-11
	.OCTA	^X1F1FCCA4BC80F62388714FDEE307BFE3	; C 5 = -.175724767344340104514577139841893E-08
	.OCTA	^X1DC845DA7AC61B90EE78348750783FEB	; C 4 = 0.313361689037812152095040762024307E-06
	.OCTA	^X64ED7F645EE15BE62BD8CCE632D2BFF2	; C 3 = -.365762041821772507866051869840100E-04
	.OCTA	^X07A3449E7E681D245AAEC677466B3FF8	; C 2 = 0.249039457019272016001579842157744E-02
	.OCTA	^X55E55EE2BB8E2BEA5BE5CE624ABBBFFD	; C 1 = -.807455121882807817069695704872432E-01
	.OCTA	^X1B84517098CC46982D18544421FB3FFC	; C 0 = 0.353981633974483096156608458198757E-01
SINLENC = .-SINTBC/16





;
; Polynomial coefficients for arguments in degrees
;

COSDTB2:	; HCOS coefficients for arguments less than 90/pi
	.OCTA	^XEDD1ED9A0B7862E55BDEDB5CBAB13F25	; C12 = 0.102627881393684166078725179428033E-65
	.OCTA	^X089A882B2A049560B79DFC4B7F7ABF3A	; C11 = -.186437848754295358863451372237275E-59
	.OCTA	^XA905399E6504B8172CD74F4A15553F4F	; C10 = 0.282763099589940208927813629385820E-53
	.OCTA	^X4F2A6144EDA61DFA4D10D80849EFBF63	; C 9 = -.352737470612942690574901649797755E-47
	.OCTA	^X89E59A6854663D0EDBD3994E3C143F77	; C 8 = 0.354338455375806404995007340276562E-41
	.OCTA	^XEFD48542F017D43AB92D60A8DAFDBF8A	; C 7 = -.279173887526652390507321555113213E-35
	.OCTA	^X15E4C0D3D1683339ED7D46880EA53F9E	; C 6 = 0.166798233552852505829157950176968E-29
	.OCTA	^XD0FF07DEE83BD1B03DC840EDBF62BFB0	; C 5 = -.722787516367020866486118549126230E-24
	.OCTA	^XF165B451C90A4160ACEBB5C6F83A3FC2	; C 4 = 0.213549430359498596941150574913603E-18
	.OCTA	^XD4B76062E75EBF27CAD085BB619BBFD4	; C 3 = -.392583198574309488222618074857603E-13
	.OCTA	^XFB521CA93606DF8A3DC816A809B13FE5	; C 2 = 0.386632385156299365396377635081293E-08
	.OCTA	^XCF6DA0A083BF98FC41FB1DB13F6ABFF4	; C 1 = -.152308709893354299673371774689447E-03
	.OCTA	^X00000000000000000000000000004001	; C 0 = 0.100000000000000000000000000000000E+01
COSDLN2 = .-COSDTB2/16 - 1

COSDTB1:	; HCOS coefficients for arguments greater than 90/pi
	.OCTA	^X9C90D30382A128992C21F7D3B1B0BF10	; C13 = -.479415169020911476142562853569725E-72
	.OCTA	^XBA25F909C348C90008DCA1DBBBCB3F25	; C12 = 0.102883048126367050066419955375617E-65
	.OCTA	^X476BE1A747C7AC093E244D1A7F7BBF3A	; C11 = -.186438448212011112407699630761399E-59
	.OCTA	^X90F92FB195FC562C9C4E4F5715553F4F	; C10 = 0.282763100406431640069721424106627E-53
	.OCTA	^X42BC7FB3861342114FEBD80849EFBF63	; C 9 = -.352737470613653612672589600525673E-47
	.OCTA	^XF05D81E44302A3F9DBD3994E3C143F77	; C 8 = 0.354338455375806814888409275373283E-41
	.OCTA	^XAD8A0182FB21D44DB92D60A8DAFDBF8A	; C 7 = -.279173887526652390662649196997890E-35
	.OCTA	^X8CA225BBD27D3339ED7D46880EA53F9E	; C 6 = 0.166798233552852505829194021299493E-29
	.OCTA	^X8EA32452E83BD1B03DC840EDBF62BFB0	; C 5 = -.722787516367020866486118587149131E-24
	.OCTA	^XBBDCB44FC90A4160ACEBB5C6F83A3FC2	; C 4 = 0.213549430359498596941150574910579E-18
	.OCTA	^XD3BB6062E75EBF27CAD085BB619BBFD4	; C 3 = -.392583198574309488222618074857589E-13
	.OCTA	^XFB521CA93606DF8A3DC816A809B13FE5	; C 2 = 0.386632385156299365396377635081293E-08
	.OCTA	^X7B6405061DFDC7E40FDCED8AFB50BFF1	; C 1 = -.302383973933542996733717746894468E-04
	.OCTA	^X3CFD079248FB25CD73ED76B9390EBF7A	; C 0 = -.280758778510761953917854137379023E-40
COSDLN1 = .-COSDTB1/16 - 1

SINDTB:		; HSIN coefficients
	.OCTA	^X33D8819F3CDAD3D6569501D31F22BF06	; C13 = -.309965950876671388345819240259692E-75
	.OCTA	^XD3264A07C997C22099208F9B3D433F1B	; C12 = 0.718260038134094372560016074608403E-69
	.OCTA	^X238953E7964E4DB012621A1029FCBF30	; C11 = -.141476729812460641535935409212179E-62
	.OCTA	^XD1DB62C7A21FDA17F4B457D1D80D3F44	; C10 = 0.235007005013275394329124189662605E-56
	.OCTA	^X 8A210FA884231C385001F14365ABF59	; C 9 = -.324022645124477933806840414846238E-50
	.OCTA	^X2088C2FEE298DBCF7C39F5FD4C4B3F6D	; C 8 = 0.363786630161107676309027475221862E-44
	.OCTA	^XF957003169E80E77C70D4E6D1AF8BF81	; C 7 = -.324833568195494208677506950697159E-38
	.OCTA	^XD058E52837D6697440432DDF74143F94	; C 6 = 0.223936797077519653778903432061087E-32
	.OCTA	^X9E29EAE3EEA8F0D275261B386B71BFA7	; C 5 = -.114682017753790161396412132985919E-26
	.OCTA	^X6544545DB530549081C804CBF4A63FB9	; C 4 = 0.414126741725732068529449587671252E-21
	.OCTA	^X89CA7792230610519509D9FAC368BFCB	; C 3 = -.978838486161772760953596800220381E-16
	.OCTA	^XD906A253E512077810D74EAEDAD93FDC	; C 2 = 0.134960162316325501059299140528168E-10
	.OCTA	^X5226E950660F878742F720D9DBB8BFEC	; C 1 = -.886096155701298015988692131547251E-06
	.OCTA	^X90B9CDD2D8BE15C19D39A252DF463FF7	; C 0 = 0.182829251994329576923690768488613E-02
SINDLN = .-SINDTB/16 - 1


	.SBTTL	MTH$HSINCOS	-	Radian arguments


;
; FUNCTIONAL DESCRIPTION:
;
; The HSIN, HCOS and HSINCOS routines are based on octant reduction.  Given an 
; argument, x, it is written in the form
;
;            x = I1*(2*pi) + I*(pi/4) + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < pi/4.  Since HSIN and 
; HCOS have a period of 2*pi it follows that
;
;            HSIN(x) = HSIN(I*(pi/4) + Y1)) and
;            HCOS(x) = HCOS(I*(pi/4) + Y1)).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then HSIN(x) =                and HCOS(x) =
;       ------            -------------                -------------
;         0                 HSIN(Y1)                      HCOS(Y1)
;         1                 HCOS(pi/4-Y1)                 HSIN(pi/4-Y1)
;         2                 HCOS(Y1)                     -HSIN(Y1)
;         3                 HSIN(pi/4-Y1)                -HCOS(pi/4-Y1)
;         4                -HSIN(Y1)                     -HCOS(Y1)
;         5                -HCOS(pi/4-Y1)                -HSIN(pi/4-Y1)
;         6                -HCOS(Y1)                      HSIN(Y1)
;         7                -HSIN(pi/4-Y1)                 HCOS(pi/4-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = pi/4 - Y1, if I is odd, then
; each entry of the above table is of the for +/-HSIN(Y) or +/-HCOS(Y).  Based 
; on the above remarks, the HSIN, HCOS and HSINCOS routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.


; 
; INPUT PARAMETERS:
; 
	LONG   = 4

	x      = 1*LONG		; x is input angle in radians
	sine   = 2*LONG		; sine is HSIN(x)
	cosine = 3*LONG		; cosine is HCOS(x)


;
; Return sine and cosine of argument
;


	.ENTRY	MTH$HSINCOS, ^M<R2, R3, R4, R5, R6,R7>

	MTH$FLAG_JACKET

	MOVH	@x(AP), R0
	JSB	MTH$HSINCOS_R7
	MOVO	R0, @sine(AP)
	MOVO	R4, @cosine(AP)
	RET

; 
; INPUT PARAMETERS:
; 
	LONG   = 4

	arg    = 2*LONG		; x is input angle in radians
	answer = 1*LONG

	.SBTTL	MTH$HSIN

;
; Return sine of argument
;


	.ENTRY	MTH$HSIN, ^M<R2, R3, R4, R5>

	MTH$FLAG_JACKET

	MOVH	@arg(AP), R0
	JSB	MTH$HSIN_R5
	MOVO	R0, @answer(AP)
	RET



	.SBTTL	MTH$HCOS

;
; Return cosine of argument
;


	.ENTRY	MTH$HCOS, ^M<R2, R3, R4, R5>

	MTH$FLAG_JACKET

	MOVH	@arg(AP), R0
	JSB	MTH$HCOS_R5
	MOVO	R0, @answer(AP)
	RET


	.SBTTL	MTH$HSINCOSD	-	Degrees


;
; FUNCTIONAL DESCRIPTION:
;
; The HSIND, HCOSD and HSINCOSD routines are based on octant reduction.  Given 
; an argument, x, it is written in the form
;
;            x = I1*360 + I*45 + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < 45.  Since HSIND and 
; HCOSD have a period of 360 it follows that
;
;            HSIND(x) = HSIND(I*45 + Y1) and
;            HCOSD(x) = HCOSD(I*45 + Y1).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then HSIND(x) =                and HCOSD(x) =
;       ------            -------------                -------------
;         0                 HSIND(Y1)                      HCOSD(Y1)
;         1                 HCOSD(45-Y1)                   HSIND(45-Y1)
;         2                 HCOSD(Y1)                     -HSIND(Y1)
;         3                 HSIND(45-Y1)                  -HCOSD(45-Y1)
;         4                -HSIND(Y1)                     -HCOSD(Y1)
;         5                -HCOSD(45-Y1)                  -HSIND(45-Y1)
;         6                -HCOSD(Y1)                      HSIND(Y1)
;         7                -HSIND(45-Y1)                   HCOS(45-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = 45 - Y1, if I is odd, then
; each entry of the above table is of the for +/-HSIN(Y) or +/-HCOS(Y).  Based 
; on the above remarks, the HSIND, HCOSD and HSINCOSD routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.



	sind = 2*LONG
	cosd = 3*LONG

	.ENTRY	MTH$HSINCOSD	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVH	@X(AP), R0
	JSB	MTH$HSINCOSD_R7
	MOVO	R0, @sind(AP)
	MOVO	R4, @cosd(AP)
	
	RET



	.ENTRY	MTH$HSIND	^M<R2, R3, R4, R5>

	MTH$FLAG_JACKET

	MOVH	@arg(AP), R0
	JSB	MTH$HSIND_R5
	MOVO	R0, @answer(AP)

	RET



	.ENTRY	MTH$HCOSD	^M<R2, R3, R4, R5>

	MTH$FLAG_JACKET

	MOVH	@arg(AP), R0
	JSB	MTH$HCOSD_R5
	MOVO	R0, @answer(AP)

	RET


	.SBTTL MTH$HSINCOS_R7

; This routine computes the HSIN and HCOS of the G-format value of R0/R1.  The
; computation is performed one of three ways depending on the size of the
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in polynomial approximation
;          of HSIN and HCOS.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute HSIN(X) and HCOS(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute HSIN(X) and HCOS(X).

MTH$HSINCOS_R7::
	TSTH	R0			; Check sign of x
	BGEQ	POS_SINCOS		; 
	JSB	SINCOS			; R0/R1 = HSIN(|X|), R2/R3 = HCOS(X)
	MNEGH	R0, R0			; R0/R1 = HSIN(X)
	RSB

SINCOS:
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SINCOS:
	CMPH	H_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SINCOS		; No argument reduction is necessary
	CMPH	H_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BGEQ	1$	
	BRW	LARGE_SINCOS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
1$:	SUBL	#48, SP			; Allocate 12 longword on the stack
					;   for the reduced argument
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; Y = reduced argument on the stack,
					;   R2 = octant, R5 points to YHI, and
					;   R4 points to YLO
	MOVO	(R4), -(SP)		; Save YLO
	MOVO	(R5), -(SP)		; Save YHI
	PUSHR	#^M<R2, R4, R5>		; Save R2, R4, R5
	JSB	M_COS			; R0/R3 = HCOS(X)
	MOVO	R0, 76(SP)		; Save HCOS(X) on stack
	POPR	#^M<R2, R4, R5>		; Restore R2, R4, R5
	MOVO	(SP)+, (R5)		; Restore YHI
	MOVO	(SP)+, (R4)		; Restore YLO
	JSB	M_SIN			; R0/R3 = HSIN(X)
	MOVO	32(SP), R4		; R4/R7 = HCOS(X)
	ADDL	#48, SP			; Pop 12 longwords off the stack
	RSB
;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SINCOS:
	MOVO	R0, -(SP)		; (SP) = |X|
	CMPW	R0, #^X4000		; Compare 1/2 with |X|
	BGEQ	2$			; Sufficent overghang not available
	CMPW	#^X3FC7, R0		; Compare with 2^-57
	BGEQ	1$			; No polynomial evaluation is needed
	MULH3	(SP), (SP), R0		; R0/R3 = X*X
	MOVO	R0, -(SP)		; Put X*X on stack
	POLYH	R0, #COSLENR1-1, COSTBR1; R0/R3 = HCOS(X)
	MOVO	(SP), R4 		; R4/R7 = X*X
	MOVO	R0, (SP)		; Save HCOS(X) on stack
	POLYH	R4, #SINLENR-1, SINTBR	; R0/R3 = q(X^2)
	MOVO	(SP)+, R4		; R4/R7 = HCOS(X)
	MULH2	(SP), R0		; R0/R3 = X*q(X^2)
	ADDH2	(SP)+, R0		; R0/R3 = HSIN(X)
	RSB

1$:	ADDL	#16, SP			; Clear stack
	MOVH	#1.0, R4		; R0/R3 = X, R4/R7 = 1.0 = HCOS(X)
	RSB	


2$:	MULH3	(SP), (SP), R4		; R4/R7 = X^2
	MOVO	R4, -(SP)		; Save X^2
	POLYH	R4, #COSLENR2-1, COSTBR2; R0/R3 = Q(X^2)
	MOVO	(SP), R4		; R4/R7 = X^2
	MOVO	R0, (SP)		; Save Q(X^2) on stack
	POLYH	R4, #SINLENR-1, SINTBR	; R0/R3 = Q(X^2)
	MOVO	(SP)+, R4		; R4/R7 = P(X^2)
	MULH2	(SP), R0		; R0/R3 = X*P(X^2)
	ADDH2	(SP), R0		; R0/R3 = HSIN(X)
	MOVO	(SP), -(SP)		; Save another copy of |X|
	BICL	#^XFFFF01FF, 24(SP)	;
	CLRL	28(SP)			; 16(SP) = XHI
	SUBH3	16(SP) ,(SP), -(SP)	; (SP) = XLO
	ADDH2	32(SP), 16(SP)		; 16(SP) = X + XHI
	MULH2	(SP)+, (SP)		; (SP) = XLO*(X + XHI) = A2
	BEQL	3$			; Check for A2 = 0
	DECW	(SP)			; (SP) = A2/2
3$:	SUBH2	(SP)+, R4		; R4/R7 = Q(Y^2) - A2/2
	MULH2	(SP), (SP)		; (SP) = XHI^2
	DECW	(SP)			; (SP) = XHI^2/2
	SUBH2	#1, (SP)		; (SP) = XHI^2/2 - 1
	SUBH2	(SP)+, R4		; R4/R7 = HCOS(X)
	RSB


LARGE_SINCOS:
	SUBL	#32, SP			; Allocate 16 longwords on the stack
	MOVL	SP, R5			;   pointed to by R5
	JSB	REDUCE_LARGE		; (R5) = YLO 
					; (R4) = YHI (in cycles)
					; R2 = octant bits
	SUBL	#16, SP			; Save space for HCOS(X)
	MOVO	(R5), -(SP)		; Save reduced 
	MOVO	16(R5), -(SP)		;     argument on stack
	PUSHR	#^M<R2, R4, R5>		; Save R2, R4 and R5
	JSB	L_COS			; R0/R1 = HCOS(X)
	MOVO	R0, 44(SP)		; (SP) = HCOS(X)
	POPR	#^M<R2, R4, R5>		; Restore R2, R4 and R5
	MOVO	(SP)+, 16(R5)		; Reduced argument on stack
	MOVO	(SP)+, (R5)		;      pointed to by R4 and R5
	JSB	L_SIN			; R0/R3 = HSIN(X)
	MOVO	(SP)+, R4		; R4/R7 = HCOS(X)
	ADDL	#32, SP			; Pop 8 longwords off the stack
	RSB	

	.SBTTL MTH$HSIN_R5

; This routine computes the HSIN of the G-format value of R0/R1.  The 
; computation is performed one of three ways depending on the size of the 
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in a polynomial approximation
;          of HSIN.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute HSIN(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute HSIN(X).

MTH$HSIN_R5::
	TSTH	R0			; Check the sign of R0
	BGEQ	POS_SIN			;
	JSB	SIN			; R0/R1 = HSIN(|X|)
	MNEGH	R0, R0			; R0/R1 = HSIN(X)
	RSB

SIN:
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SIN:
	CMPH	H_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SIN		; No argument reduction is necessary
	CMPH	H_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BLSS	LARGE_SIN		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	SUBL	#32, SP			; Allocate 32 longwords on the stack
					;   for the reduced
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; Y = reduced argument on the stack, 
					;   R2 = octant, R5 points to YHI and
					;   R4 points to YLO
M_SIN:	CASEB	R2, #1, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	P_COS_R-1$
	.WORD	P_COS_R-1$		
	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_SIN_R-1$		;    octant bits.

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SIN:
	CMPW	#^X3FC7, R0		; Compare with 2^-57
	BGEQ	1$			; No polynomial evaluation is needed
	MOVO	R0, -(SP)		; (SP) = X
	MULH2	R0, R0 			; R0/R3 = X*X
	POLYH	R0, #SINLENR-1, SINTBR	; R0/R3 = q(x^2)
	MULH2	(SP), R0		; R0/R3 = X*q(x^2)
	ADDH2	(SP)+, R0		; R0/R3 = HSIN(X)
1$:	RSB


LARGE_SIN:
	SUBL	#32, SP			; Allocate 8 longwords on the stack
	MOVL	SP, R5			;   pointed to by R5
	JSB	REDUCE_LARGE		; (R5) = YLO, (R4) = YHI
					; R2 = octant bits
L_SIN:	TSTL	R4			; Check for degenerate case
	BEQL	DEGENERATE_CASE_SIN

	CASEB	R2, #0, #7

1$:	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$


DEGENERATE_CASE_SIN:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	P_ONE-1$
	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$




	.SBTTL MTH$HCOS_R5

; This routine computes the HCOS of the G-format value of R0/R1.  The 
; computation is performed one of three ways depending on the size of the 
; input argument, X.  The processing is the same as described for MTH$HSIN_R4.
;

MTH$HCOS_R5::
	TSTH	R0			; Check for reserved operand
	BICW	#^X8000, R0		; R0/R1 = |X|
	CMPH	H_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_COS		; No argument reduction is necessary
	CMPH	H_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BLSS	LARGE_COS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	SUBL	#32, SP			; Allocate 8 longwords on the stack
					;   for the reduced argument
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; Y = reduced argument on the stack,
					;    R2 = octant, R5 points to YHI
					;    and R4 points to YLO
M_COS:	CASEB	R2, #1, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_COS_R-1$
	.WORD	P_COS_R-1$		;    octant bits.

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_COS:
	CMPW	#^X4000, R0		; Compare 1/2 with |X|
	BGTR	1$			; Sufficent overghang is available
	MOVO	R0, -(SP)		; (SP) = X
	BICL	#^XFFFF01FF, 8(SP)	; 
	CLRL	12(SP)			; (SP) = XHI
	SUBH3	(SP), R0, -(SP)		; (SP) = XLO
	MOVL	SP, R4			; R4 = pointer to XLO
	ADDL3	#16, R4, R5		; R5 = pointer to XHI
	BRW	NEEDS_DOUBLE		; Use special logic to obtain overhang
1$:	CMPW	#^X3FC7, R0		; Compare with 2^-57
	BGEQ	2$			; No polynomial evaluation is needed
	MULH2	R0,R0			; R0/R1 = X*X
	POLYH	R0, #COSLENR1-1, COSTBR1; R0/R1 = HCOS(X)
	RSB

2$:	MOVH	#1.0, R0		; R0/R1 = 1.0 = HCOS(X)
	RSB	


LARGE_COS:
	SUBL	#32, SP			; Allocate 8 longwords on the stack
	MOVL	SP, R5			;   pointed to by R5
	JSB	REDUCE_LARGE		; (R5) = YLO, (R4) = YHI
					; R2 = octant bits
L_COS:	TSTL	R4			; Check for degenerate case
	BEQL	DEGENERATE_CASE_COS

	CASEB	R2, #0, #7
1$:	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$
	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$


DEGENERATE_CASE_COS:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$
	.WORD	P_ONE-1$


	.SBTTL	MTH$HSINCOSD_R5

; This routine computes the HSIND and HCOSD of the H-format value of R0/R3.
; The computation is performed one of two ways depending on the size of the 
; input argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of HSIND and HCOSD.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute HSIND(X) and 
;          HCOSD(X).

MTH$HSINCOSD_R7::
	TSTH	R0
	BGEQ	SINCOSD
	BICW	#^X8000, R0		; R0/R3 = |X|
	JSB	SINCOSD			; R0/R3 = HSIND(|X|)
					; R4/R7 = HCOSD(|X|)
	MNEGH	R0, R0			; R0/R4 = -HSIND(|X|)
	RSB

SINCOSD:
	CMPH	H_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SINCOSD		; special processing for small arg
	SUBL	#16, SP			; Allocate 4 longwords on stack
	MOVL	SP, R5			; R5 points to octaword on stack
	JSB	REDUCE_DEGREES		; (R5) = reduced argument
					; R4 = octant
	MOVO	(R5), -(SP)		; Save reduced arg
	PUSHR	#^M<R4, R5>		; Save octant bits and pointer
	JSB	EVAL_COSD		; R0/R3 = HCOSD(Y)
	POPR	#^M<R4, R5>		; R4/R5 = octant bits/pointer 
	MOVO	(SP), (R5)		; (R5) = octant/reduced argument
	MOVO	R0, (SP)		; Save HCOSD(Y)
	JSB	EVAL_SIND		; R0/R3 = HSIND(Y)
	MOVO	(SP)+, R4		; R4/R7 = HCOSD(Y)
	ADDL	#16, SP			; Pop 4 longwords
	RSB


SMALL_SINCOSD:
	SUBL	#32, SP			; Allocate 8 longwords on stack
	MOVO	R0, (SP)		; Save argument
	JSB	SMALL_COSD		; R0/R3 = HCOSD(|X|)
	MOVO	R0, 16(SP)		; Save HCOSD(|X|)
	MOVO	(SP)+, R0		; R0/R3 = argument
	JSB	SMALL_SIND		; R0/R3 = HSIND(X)
	MOVO	(SP)+, R4		; R4/R7 = HCOSD(|X|)
	RSB

	.SBTTL	MTH$HSIND_R5

; This routine computes the HSIND of the H-format value of R0/R3.  The 
; computation is performed one of two ways depending on the size of the input 
; argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of HSIND.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute HSIND(X).

MTH$HSIND_R5::
	TSTH	R0			; R0/R3 = X
	BGEQ	POS_SIND		;
	JSB	NEG_SIND		; R0/R3 = HSIND(|X|)
	MNEGH	R0, R0			; R0/R3 = -HSIND(|X|)
	RSB

NEG_SIND:	
	BICW	#^X8000, R0		; R0/R3 = |X|
POS_SIND:
	CMPH	H_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SIND		; special processing for small arg
	SUBL	#16, SP			; Allocate 4 longwords on stack
	MOVL	SP, R5			; R5 points to octaword on stack
	JSB	REDUCE_DEGREES		; (R5) = reduced argument
					; R4 = octant

EVAL_SIND:
	CASEB	R4, #0, #7
1$:	.WORD	P_SIN_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_SIN_D-1$
	.WORD	N_SIN_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_SIN_D-1$


SMALL_SIND:
	CMPH	H_SMALLD, R0		; Compare 180/pi*2^-57 with |x|
	BGTR	1$			; No polynomial evaluation is 
	MOVO	R0, -(SP)		;   necessary
	MOVL	SP, R5			; R5 points to argument
	BRW	P_SIN_D			;   
1$:	TSTH	R0			; Check for zero
	BEQL	3$			; Return if R0 = 0
	CMPH	H_SMALLEST_DEG, R0	; Check for possible underflow on
	BLEQ	2$			;   conversion to radians
	BRW	UNFL			; Underflow will occur on conversion
2$:	MOVO	R0, -(SP)		; (SP) = X
	MULH2	H_CONVERT, R0		; R0/R3 = (pi/180 - 2^-6)*|x|
	SUBW	#^X6, (SP)		; R0/R3 = |X|*2^-6
	ADDH2	(SP)+, R0		; R0/R3 = HSIND(|X|) = (pi/180)|X|
3$:	RSB

	.SBTTL	MTH$HCOSD_R5

; This routine computes the HCOSD of the H-format value of R0.  The computation
; is performed one of two ways depending on the size of the input argument, X:
; Details are given in the discussion on MTH$HCOSD_R4.

MTH$HCOSD_R5::
	TSTH	R0			; Check for reserved operand
	BICW	#^X8000, R0 		; R0/R3 = |X|
	CMPH	H_45, R0		; Compare 45 to |X|
	BGTR	SMALL_COSD		;
	SUBL	#16, SP			; Allocate 4 longwords on stack
	MOVL	SP, R5			; R5 points to octaword on stack
	JSB	REDUCE_DEGREES		; (R5) = reduced argument
					; R4 = octant

EVAL_COSD:
	CASEB	R4, #0, #7
1$:	.WORD	P_COS_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	P_COS_D-1$	


SMALL_COSD:
	CMPH	H_SMALLD, R0		; Compare 180/pi*2^-57  with |X|
	BGTR	1$			; Check if polyinomial evaluation is
	MOVO	R0, -(SP)		;    necessary.
	MOVL	SP, R5			; R5 points to argument
	BRW	P_COS_D			; POLY needed
1$:	MOVH	#1, R0			; R0 = 1. = HCOSD(|X|)
	RSB





	.SBTTL	REDUCE_MEDIUM

;
; This routine assumes that the absolute value of the argument, X,  is in R0/R3
; and that pi/4 =< |X| < 9*pi/4.  It returns a pair of H-format values for the
; reduced argument in eight longwords on the stack previously allocate by the
; the calling routine.  These longwords will be denoted by T0 (4 off the stack
; pointer) through T7 (32 off the stack pointer).  YHI is in T4/T7, and YLO is
; in T0/T3.  The octant bits in are returned in R2.
;
; The reduced argument is obtained by locating the octant that X is in through
; a binary search and then subtracting off a suitable multiple of pi/2
;

REDUCE_MEDIUM:
	ADDL3	#20, SP, R5		; R5 points to T4
	MOVO	R0, (R5)		; T4/T7 = X
	CMPH	H_5_PI_OV_4, R0		; 
	BLEQ	5$			; |X| >= 5*pi/4
	CMPH	H_3_PI_OV_4, R0	
	BLEQ	3$			; |X| >= 3*pi/4
	MOVL	#1, R2			; First quadrant
	BRB	SUBTRACT

3$:	MOVL	#3, R2			; Second quadrant
	BRB	SUBTRACT

5$:	CMPH	H_7_PI_OV_4, R0	; 
	BLEQ	7$			; |X| >= 7*pi/4
	MOVL	#5, R2			; Third quadrant
	BRB	SUBTRACT

7$:	MOVL	#7, R2			; Fourth quadrant
	BRB	SUBTRACT


SUBTRACT:
	ADDL3	#4, SP, R4		; R4 = points to T0
	MOVAW	-3(R2)[R2], R3		; R3 = index into PI_OV_2 table
	MOVAQ	PI_OV_2[R3], R3		; R3 = pointer into PI_OV_2 table
	SUBH2	(R3)+, (R5)		; T4/T7 = 1st approximation to YHI
	BLEQ	1$			;       = YHI'
	INCL	R2			; Adjust octant bits
1$:	BICW3	#^X8000, (R5), R1	; R1 = exponents bits of |YHI'|
	CMPW	#^X3F95, R1		; Check for at least 6 significant bits
	BGTR	NOT_ENOUGH_BITS		;    in YHI'

	MOVO	(R5), (R4)		; T0/T3 = YHI'
	BICL	#^XFFFF01FF, 8(R5)	;
	CLRL	12(R5)			; T4/T7 = high 56 bits of YHI' = YHI
	SUBH2	(R5), (R4)		; T0/T3 = low bits of YHI'
	SUBH2	(R3), (R4)		; R4/R5 = YLO
	RSB

NOT_ENOUGH_BITS:			; Add an additional 49 significant bits
					;   to YHI' to get YHI
	MOVO	(R3), -(SP)		; (SP) = 113 additional bits (H-format)
	CLRQ	8(SP)			; (SP) = 49 additional bits (H-format)
	SUBH2	(SP), (R5)		; T4/T7 = YHI
	SUBH3	(SP)+, (R3)+, (R4)	; T0/T3 = 1st 64 bits of YLO
	ADDH2	(R3), (R4)		; T0/T3 = -YLO
	XORW	#^X8000, (R4)		; T0/T3 = YLO
	RSB
	


	.SBTTL	REDUCE_LARGE

;
; This routine is used to reduce large arguments (|X| >= 9*pi/4) modulo pi/4.
; It returns the reduced argument, Y, in R4/R5 in units of cycles, and returns
; the octant bits, I, in R2.
;
; The method of reduction is as follows:
;
;     x*(4/pi) = 2^n*f*(4/pi) where n is an integer and 1/2 =< f < 1
;              = 2^(n-113)*(2^113*f)*(4/pi)
;              = (2^113*f)*(2^(n-113)*4/pi)
;              = K*C, where K = 2^113*f is an integer and C = 2*(n-113)*4/pi
;     Let L = K*C modulo 8, where 0 =< L < 8, and let I = the integer(L) and
;     h = fract(L), then if I is even Y = h, otherwise Y = 1-h
;
; CONSTANTS:

	L_INT_WEIGHT  = ^X3D		; weights exponent by 61
	W_TERM_WEIGHT = ^X20		; weights exponent by 32
	W_MAX_WEIGHT  = ^X4000		; maximum unbiased exponent
	W_YLO_WEIGHT  = ^X40		; weights exponest by 64
	W_ADJUST      = ^X3FF2		; Used to locate binary point in
					;   MTH$AL_4_OV_PI_V table
H_2_TO_32:
	.OCTA	^X4011			; 2^32



REDUCE_LARGE:
;
; The first step is to obtain the location of the binary point in the represen-
; tation of C = 2^(n-113)*(4/pi) in two parts - the number of longwords from
; the start and the number of bits from the most significant bit of the next
; longword. Also K = 2^113*f must be obtained.  
;

	BICL3	#^XFFFF, R0, R4		; R4 = 1st 16 fraction bits of X
	BISB	#1, R4			; Restore hidden bit
	ROTL	#16, R4, 12(R5)		; 12(R5) = High 17 bits of K
	ROTL	#16, R1, 8(R5)		; 8(R5) = Next 32 bits of K
	BGEQ	1$			; Check for high bit set and 
	INCL	12(R5)			;   adjust if necessary
1$:	ROTL	#16, R2, 4(R5)		; 4(R5) = Next 32 bits of K
	BGEQ	2$			; Check for high bit set and 
	INCL	8(R5)			;   adjust if necessary
2$:	ROTL	#16, R3, (R5)		; (R5) = Next 32 bits of K
	BGEQ	3$			; Check for high bit set and 
	INCL	4(R5)			;   adjust if necessary


3$:	SUBW	#W_ADJUST, R0		; Unbias exp and adjust for leading 
					;   zeroes.  R0 = location of binary
					;   point 
	ROTL	#-3, R0, R3		; Divide R0 by 32 and mull by 4 to get 
	BICL	#^XFFFFF003, R3		;   R3 = # of longwords (in bytes) to 
					;   binary point.
	MOVAL	G^MTH$AL_4_OV_PI_V, R1	; R1 = address of RTL vector entry
	ADDL	G^MTH$AL_4_OV_PI_V, R1	; R1 = address of MTH$AL_4_OV_PI table
	SUBL	R3, R1			; R1 points to 1st quadword of interest
	BICB	#^XE0, R0		; R0(7:0) = # of bits within longword


;
; The next step is to generate an approximation to C, call it C'' to be used
; in computing x*4/pi.  C'' will consist of the first three integer bits of
; C and the first 61 fraction bits of C.  These bits will be obtained from a
; constant stored in the interger array MTH$AL_4_OV_PI_V.
;
; NOTE:  The ASHQ, ADDL, and MULL instructions in the follow sections may 
; result in an integer overflow trap.  The overflow incurred is intentional,  
; so that the IV bit must be turned off.  The IV bit is not restored until 
; after all of the necessary fraction bits hav been generated.
;
	MOVPSL	-(SP)			; Put current PSL on stack
	BICL	#^C<PSL$M_IV>, (SP)	; (SP) = current IV bit
	BICPSW	#PSL$M_IV		; Clear integer overflow bit

; The necessary calculation to produce the reduced argument can requires up to
; 26 longwords of temporary work space.  This work space will be allocated 
; on the stack.  Of the 26 longwords allocated, only 16 are needed for the
; duration of the reduction scheme.  For the purposes of comments these 16 
; locations will be refered to as T0 through TE and will be accessed by
; pointers in R2, R3, R4, and SP.  The stack will be allocated (after initial-
; ization) as follows:
;
;                                   |                    |
;                                   |--------------------|
;                            |  T0: |                    |  
;                            |      |--------------------|
;  Temporary storage for use |  T1: |                    |
;  during the generation of  |      |--------------------|
;  addition bits of the pro- |  T2: |                    |
;  duct K*C'                 |      |--------------------|
;                            |  T3: |                    |
;                            |      |--------------------|
;                            |  T4: |                    |  
;                                   |--------------------|
;  Additional bits of C'     |  T5: |                    |
;                                   |--------------------|
;                            |  T6: |                    |
;                            |      |--------------------|
;                            |  T7: |                    |
;                            |      |--------------------|
;                            |  T8: |                    |
;  Contains all of the       .      .         .          .
;  significant bits          .      .         .          .
;  generated through         .      .         .          .
;  current iteration         |
;                            |  TD: |                    |  
;                            |      |--------------------|
;                            |  TE: |                    |
;                                   |--------------------|
;  Weighting factor          |  TF: |                    |
;                                   |--------------------|
;                                   |                    |
;


;
; Get C'' = C(0):C(1):...:C(7) on stack.  C(0) though  C(7) are unsigned 
; integers generated from the binary representation of C.  The high three bits 
; of C(0) are the the first three bits to the left of the binary point of C.  
; The remaining bits C(0) and C(1) though C(7) are the first 253 bits to the 
; right of the binary point of C. Note that the C(i)'s are adjusted to
; compensate for their signed (rather than unsigned) interpretation in the EMUL
; instruction.  Note also that the representation of C has no more than 15 
; consequtive ones, so that no carry is possible from the adjustment.
;

	SUBL	#104, SP		; Allocate 26 longwords on the stack
	ADDL3	#32, SP, R2		; R2 points to longword before C(7)
	ADDL3	#28, R2, R3		; Initailize loop counter.  R3 points
					;   to longword before C(0)
	ASHQ	R0, (R1), (R3)		; Shift the proper quadword so that
					;    4(R3) has C(0)in it
	SUBL	#4, R3			; R3 points to longword before C(6)
4$:	SUBL	#4, R1			; R2 points to next quadword in 
					;    MTH$AL_4_OV_PI_V table
	ASHQ	R0, (R1), (R3)		; Shift quadword so that C(n) is in
					;   the appropriate longowrd
	BGEQ	5$			; Check for high bit of C(n) set
	INCL	8(R3)			; Bit set.  Adjust C(n-1)
5$:	ACBL	R2, #-4, R3, 4$		; Loop until C(0) though C(7) are on
					;   the stack

;
; Generate the low 256 bits of the product K*C'' = L.  This product is 
; equivalent to multiplying K times C'' modulo 8.  The result of the 
; product is in T7/TE with bits 31:29 of TE the octant bits, and the remaining
; 252 bits the faction bits of the product.  The last 113 fraction bits (bits
; are non-valid fraction bits that will be used later if more fraction bits 
; need to be generated.
;

	MOVQ	R0, (SP)		; Save R0/R1

; Set up pointers for multiplying

	ADDL3	#36, SP, R1		; R1 points to 1st longword of C''
	ADDL3	#32, R1, R2		; R2 points to T7
	ADDL3	#24, R2, R4		; R4 points to TD

	CLRL	(R2)			; This code generates the product
6$:	EMUL	(R5), (R1)+, (R2), (R2)	;   of the low order 32 bits of K
	ACBL	R4, #4, R2, 6$		;   and C'' and stores them in 
	MULL3	(R5), (R1), 4(R2)	;   location T7/TE
	ADDL	4(R2), (R2)		;


	CLRL	R3			; R3 is the loop counter

7$:	MOVAL	8(SP)[R3], R0		; R0 and R4 point to 1st and last
	ADDL3	#28, SP, R4		;   longword of temporary storage
					;   for computing the product of the
					;   next 32 bits of K and C''
	ADDL	#4, R5			; R5 points to next 32 bits of K
	ADDL3	#36, SP, R1		; R1 points to 1st longwork of C''

	CLRL	(R0)			; This loop generates the product of
8$:	EMUL	(R5), (R1)+, (R0), (R0)	;   the next 32 bits of K and C''.
	ACBL	R4, #4, R0, 8$		;   The result is stored n+2 longwords
	MULL3	(R5), (R1), 100(SP)	;   off SP, where n is stored in R3
	ADDL	100(SP), (R0)		;

	MOVAL	8(SP)[R3], R0		; R0 points n+2 longwors off SP
	MOVAL	72(SP)[R3], R2		; R2 points to T7 + n longwords
	ADDL	#4, R4			;

	ADDL	(R0)+, (R2)+		; This loop adds the product bits of
9$:	ADWC	(R0)+, (R2)+		;   the previous loop to the bits
					;   already generated.  The results
	ACBL	R4, #0, R0, 9$		; This curious construction is used to
					;   avoid effecting the carry bit

	ACBL	#2, #1, R3, 7$		; Increment loop counter and branch

	MOVQ	(SP), R0		; Restore R0/R1
	SUBL	#12, R5			; R5 points to K	
	ADDL	#40, SP			; Pop 10 longwords off stack

;
; At this point there may or may not be enough valid bits in R3/R4 to generate
; Y.  If the first 12 fratction bits are all 1's or 0's, there a possibility of 
; loss of significance when computing Y.  Consequently, we must check for loss 
; of significance before converting T4/T7 to Y and I.
;

; Set up pointers

	ADDL3	#28, SP, R3		; R3 points to T7
	ADDL3	#60, SP, R4		; R4 points to TF

	ADDL3	#^X80, -4(R4), (R4)	; If the first 22 fraction bits are 1's
	BITL	#^X3FFFFF00, (R4)	;   and the reduced arg = 1-f or the 
	BNEQ	CONVERT			;   first 22 bit are 0 and the reduced
					;   arg = f, then (and only then) bits
					;   29:8 are 0 and significance will
					;   be lost.

;
; More bits need to be generated to cover the loss of significance.
;

	JSB	GEN_MORE_BITS		; Generate 85 additional bits and add
					;   them to existing bits.  Results are
					;   stored in T6/TE
	SUBL	#4, R3			; Adjust R3 to reflect the addition of 
					;   another longword of K*C''
	BBS	#29, -4(R4), 10$		; Check if loss of significance is due 
					;   to leading ones or zeros

; Lost significance due to leading zeros

	FFS	#0, #8, -4(R4), (R4)	; If at least one bit is set.  This 
	BNEQ	CONVERT			;   means lost significance was minor.
	CMPL	#^X1FFFF, -8(R4)	; If one of the high 15 bits is set,
	BLEQ	CONVERT			;   lost significance was minor.
	BRW	LEADING_ZEROS

; Lost significance due to leading ones

10$:	FFC	#0, #8, -4(R4), (R4)	; If at least one bit is clear. This 
	BNEQ	CONVERT			;   meanslost significance was minor.
	CMPL	#^XFFFE0000, -8(R4)	; If one of the three high bits is 
	BGEQU	CONVERT			;   clear, lost significance was minor.
	BRB	LEADING_ONES


CONVERT:

;    Isolate octant bits and convert fraction bits to a pair of D-format
;    quantities YHI and YLO

	EXTZV	#29, #3, -4(R4), (R4)	; TF = octant bits
	BICL	#^XE0000000, -4(R4)	; Clear octant bits
	SUBL3	#20, R4, R3		; R3 points to low order bits of h
	JSB	CVT_TO_H		; (R5) = 2^29*h_lo
					; 16(R5) = 2^29*h_hi
	SUBW	#^X1D, 16(R5)		; 16(R5) = h_hi
	SUBW	#^X1D, (R5)		; (R5) = h_lo
	TSTW	(R5)			; Check for h_lo = 0
	BEQL	1$
1$:	BLBC	(R4), 2$		; Check for odd or even octant bits

;    Octant bits are odd.  Reduced argument equals 1 - h.

	SUBH3	16(R5), #1, 16(R5)	; 16(R5) = YHI = 1 - h_hi
	MNEGH	(R5), (R5)		; (R5) = YLO = -h_lo

;    Get octant bits

2$:	MOVL	(R4), R2		; R2 = octant bits
	BRW	GET_YHI_YLO


;
; At this point it has been determined that there is a major loss of 
; significance and the processing begins a looping phase.  Each iteration of
; the loop will generate additional extra bits of K*C' until enough significant
; bits to compute Y are available.  During this time the nine longwords
; allocated on the stack will be used as follows:
;
;       T0/T4   Temporary storage used when generating extra bits.
;
;       T6/TE   Contains all significant bits generated so far.
;
;       TF      Contains a counter, W, indicating the appropriate exponent
;                 of the last longword of fraction bits used in converting 
;                 to Y.

LEADING_ONES:

; If processing continues here it is known that the loss of significance is due
; to a string of leading ones.

	MOVL	#L_INT_WEIGHT, (R4)	; TE = exp bias for last longword
					;    of the product K*C'

LOOP_1:	CMPL	#^XFFFF8000, -8(R4)	; Check for enough significant bits
	BGTRU	CONVERT_1		; Enough bits.  Convert to floating.
	JSB	GEN_MORE_BITS		; T5/TE contains K*C''
	CMPL	#-1, -8(R4)		; Check for all 1's
	BGTRU	CONVERT_1		; Not all 1's.  Enough precision bits
					;    to compute Y
	MOVO	-24(R4), -20(R4)	; Compress representation 
	MOVO	-40(R4), -36(R4)	;    of K*C''
	ACBW	#W_MAX_WEIGHT, #W_TERM_WEIGHT, (R4), LOOP_1
					; Increment weighting factor.  If 
					;   weighting factor is greater than 
					;   1024 then no more bits need to be 
					;   generated.
					
;
; The weighting factor is greater than 16384.  This means that the reduced
; argument is either not distinguishable from 1 or too small to be represented
; in F-format (i.e. underflow.)  Zero is returned in R4 for the reduced
; argument to signal this occurance.  Note that under these conditions the
; correct function value is one of the values 0, +/-1.  The
; correct choice is determined by the calling program based on the octant bits
; returned in R1.
;
	CLRL	(R5)			; Reduced argument is zero
	EXTZV	#29, #3, -4(R4), R2	; R2 = octant bits
	BRW	RESTORE


CONVERT_1: 
	SUBL3	#24, R4, R3		; R3 points to low bits of h
	JSB	CVT_TO_H		; (R5)= 2^W*h_lo
					; 16(R5) = 2^W*h_hi
	SUBH3	16(R5), H_2_TO_32, 16(R5)
					; 16(R5) = 2^W*(1 - h_hi)
	SUBL	(R4), 16(R5)		; 16(R5) = 1 - h_hi
	MNEGH	(R5), (R5)		; (R5) = -2^W*h_lo
	BEQL	1$			; Check for h_lo = 0
	SUBL	(R4), (R5)		; (R5) = - h_lo
1$:	EXTZV	#29, #3, -4(R4), R2	; R2 = octant bits
	BRB	GET_YHI_YLO


LEADING_ZEROS:

; If processing continues here it is known that the loss of significance is due
; to a string of leading zeros.  Note that it is known that the loop for 
; leading zeros will terminate before an underflow condition occurs so that the
; loop does not include a test for underflow.

	MOVL	#L_INT_WEIGHT, (R4)	; TE = exp bias for last longword
					;    of the product K*C'

LOOP_0: CMPL	#^X00001FFF, -8(R4)	; Check enough fraction bits
	BLSS	CONVERT_0		; Enough bits.  Convert to floating
	JSB	GEN_MORE_BITS		; T2/R7 contain K*C''
1$:	TSTL	-8(R4)			; Check for all 0's
	BNEQ	CONVERT_0		; Not all 0's.  Enough precision bits.
	MOVO	-24(R4), -20(R4)	; Compress representation 
	MOVO	-40(R4), -36(R4)	;    of K*C''
	ADDW	#W_TERM_WEIGHT, (R4)	; Increment weighting factor.  
	BRB	LOOP_0

CONVERT_0:
	SUBL3	#24, R4, R3		; R3 points to low bits of h
	JSB	CVT_TO_H		; (R5) = 2^W*h_lo
					; 16(R5) = 2^W*h_hi
	EXTZV	#29, #3, -4(R4), R2	; R2 = octant bits
	SUBL	(R4), 16(R5)		; 16(R5) = h_hi
	TSTW	(R5)			; Check for h_lo = 0
	BEQL	GET_YHI_YLO		;
	SUBL	(R4), (R5)		; (R5) = h_lo

GET_YHI_YLO:
	ADDL3	#16, R5, R4		; R4 points to YHI
	MOVO	(R4), -(SP)		; (SP) = high bits of Y
	CLRQ	8(R4)			; (R5) = 49 high bits of Y = YHI
	SUBH2	(R4), (SP)		;
	ADDH2	(SP)+, (R5)		; (R4) = YLO
RESTORE:
	BISPSW	64(SP)			; Restore IV bit and exit
	ADDL	#68, SP			; Remove mask and temporary storage 
	RSB


GEN_MORE_BITS:

;
; This subroutine generates 145 extra fraction bits and adds them to the
; existing bits.  NOTE:  This routine is always entered via a JSB instruction.
; Consequently, SP points to the first longword BEFORE T0, rather than T0
; itself.  R3 points to the last longword of previously generated bits.
;
	ADDL3	#24, SP, R2		; R2 points to storage for C(n)

	SUBL	#4, R1			; Adjust pointer to get next quadword
					;   from MTH$AL_4_OV_PI_V
	ASHQ	R0, (R1), -4(R2)	; T5 = C(n)
	BGEQ	1$			; Branch if high bit is clear

; Logic to process unsigned values greater than 2^31 - 1

	EMUL	(R5), (R2), #0, 4(SP)	 
	ADDL	(R5), 8(SP)		
	EMUL	4(R5), (R2), 8(SP), 8(SP) 
	ADDL	4(R5), 12(SP)		
	EMUL	8(R5), (R2), 12(SP), 12(SP) 
	ADDL	8(R5), 16(SP)		
	EMUL	12(R5), (R2), 16(SP), 16(SP) 
	ADDL	12(R5), 20(SP)		
	BRB	2$

; Logic to process unsigned values less than 2^31

1$:	EMUL	(R5), (R2), #0, 4(SP)	 
	EMUL	4(R5), (R2), 8(SP), 8(SP) 
	EMUL	8(R5), (R2), 12(SP), 12(SP) 
	EMUL	12(R5), (R2), 16(SP), 16(SP) 


; Add new bits to old

2$:	ADDL3	#4, SP, R2		; R2 points to low order longword of
					;    of new bits
	MOVL	(R2)+, -4(R3)		; Move low order bits to end of list
	ADDL	(R2)+, (R3)		; Add in new bits
	ADWC	(R2)+, 4(R3)		;
	ADWC	(R2)+, 8(R3)		;
	ADWC	(R2)+, 12(R3)		;
3$:	BCC	4$			; Check for carry from previous add
	INCL	(R2)+			; Propagate carry
	BRB	3$			; 
4$:	RSB				;




CVT_TO_H:

;
; This routine converts an array of five longword pointed to by R3 to a pair
; of H-format values.  The results are returned on the stack and are pointed
; to by R5



	ADDL3	#12, R3, R2		; R2 point to second most significant
					;    longword of h
	ADDL3	#4, SP, R0		; R0 points to T0

1$:	TSTL	(R2)			; Adjust for signed
	BGEQ	2$			;   rather than unsigned
	INCL	4(R2)			;     conversion
2$:	ACBL	R3, #-4, R2, 1$		;

	CVTLH	(R3)+, (R0)		;
	BEQL	3$			;
	SUBW	#W_TERM_WEIGHT, (R0)	; Convert low order
3$:	CVTLH	(R3)+, -(SP)		;   three longword to 
	ADDH2	(SP), (R0)		;     H-format and store
	BEQL	4$			;       on stack pointed to
	SUBW	#W_TERM_WEIGHT, (R0)	;          by R5
4$:	CVTLH	(R3)+, (SP)		;
	ADDH3	(SP), (R0), (R5)	;
	BEQL	5$			;
	SUBW	#W_YLO_WEIGHT, (R5)	;

5$:	CVTLH	(R3)+, (R0)		;
	BEQL	6$			;
	SUBW	#W_TERM_WEIGHT, (R0)	; Convert high order
6$:	CVTLH	(R3)+, (SP)		;   two longwords to
	BGEQ	7$			;     H-format and store
	ADDH2	H_2_TO_32, (SP)		;       16 off R5 on the
7$:	ADDH3	(SP)+, (R0), 16(R5)	;          stack
	RSB


	.SBTTL	REDUCE_DEGREES

; This routine assumes that the absolute value of the argument is in R0/R3.
; The reduction process is performed in two stages.  The first stage of 
; the reduction reduces the argument modulo 360 to a value less that 2^112, 
; and the second stage reduces the argument modulo 45 to a value less than 45.
; The reduced argument is returned in four longwords previously allocated by
; the calling program and pointed to by R5.  The octant bits are returned in
; R4.

; Constants used in this reduction:
;

POWER_MOD_360_0:	; Powers of 2 modulo 360 for t1 = 0
	.WORD	  1,	  2,	  4,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248

POWER_MOD_360_1:	; Powers of 2 modulo 360 for t1 <> 0
	.WORD	136,	272,	184,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248



REDUCE_DEGREES:
	CMPW	#^X4071, R0		; Compare |x| with 2^112
	BGTR	LAST_STEP		; Branch to special logic for med arg

;
; It is assumed here that the argument is greater than 2^113.
;
; The argument is reduced as follows:
;     Let x = 2^t*f, where t > 113 and 1/2 =< f < 1.  And let J = 2^113*f = 
;     2^60*J1 + J2 and K = 2^(t-113).  Since 2^60 = 2^12 modulo 360, we have 
;     J = 2^12*J1 + J2 modulo 360.  Now let t' = t - 113 = 12*t1 + t2.  Note 
;     that (2^12)^2 = (2^9)*(2^15) = (2^9)*(2^3) = 2^12 modulo 360.  Hence, if
;     t1 is not zero, K = 2^t' = 2^(12*t1+t2) = (2^12)*(2^t2) = 136*2^t2 modulo
;     360.  For t1 = 0 K = 2^t2.  Consequently, define K' congruent to 2^t2 if
;     t1 = 0 and congruent to 136*2^t2 otherwise, where 0 =< K' < 360.  Then x'
;     = K'*(2^12*J1 + J2) is congruent to s modulo 360 and x' < 2^113.

	MOVL	R0, R4			; R4 = exponent bits of X
	BICW	#^X7FFF, R0		; Clear exp bits of X
	BISW	#^X4071, R0		; R0/R3 = J
	SUBL	R0, R4			; R4 = t'

	MOVO	R0, (R5)		; (R5) = J
	BICL	#^XFFFF0FFF, R2		;
	CLRL	R3			; R0/R3 = J1*2^60
	SUBH2	R0, (R5)		; (R5) = J2
	SUBW	#^X30, R0		; R0/R3 = 2^12*J1
	ADDH2	(R5), R0		; R0/R3 = 2^12*J1 + J2 = J modulo 45

	DIVW3	#12, R4, (R5)		; (R5) = t1
	BEQL	1$
	MULW	#12, (R5)		; (R5) = 12*t1
	SUBW	(R5), R4		; R4 = t2
	CVTWH	POWER_MOD_360_1[R4], (R5)
	BRB	2$			; (R5) = K'

1$:	CVTWH	POWER_MOD_360_0[R4], (R5)
					; (R5) = K'
2$:	MULH2	(R5), R0		; R0/R3 = X' (mod 45) 0 =< R0 < 2^53


LAST_STEP:
;
; Argument reduction scheme for arguments with absolute value less than 2^112
;
; The reduced argument Y is computed as follows:
;    Let I = int(X/45)
;       if I is even
;          then Y = X - 45*I
;          else Y = (I+1)*45 - x


	CMPW	#^X4024, R0		; Compare 2^36 with |X|
	BGEQ	NO_OVERFLOW		;
	MULH3	H_1_OV_45, R0, (R5)	; (R5) = |X|/45

;
; Turn off IV to avoid an exception in EMODH
;
	MOVPSL	R4			; R4 = PSL 
	BICW3	#^C<PSL$M_IV>, R4, -(SP); Save current IV bit on stack
	BICPSW	#PSL$M_IV		; Turn off integer overflow trap

	EMODH	#1, #0, (R5), R4, -(SP)	; R4 = low 32 integer bits of |X|/45
					; (SP) = fractional part of |X|/45
	SUBH2	(SP)+, (R5)		; (R5) = Integer part of |X|/45 = I

	BISPSW	(SP)+			; Restore IV bit

	BLBC	R4, EVEN		;
	ADDH2	#1, (R5)		; (R5) = I + 1	
	BRB	ODD


NO_OVERFLOW:
	EMODH	H_1_OV_45, #X_1_OV_45, R0, R4, (R5)
					; R4 = I = integer part of |X|/45
	BLBC	R4, CVT			; Branch if octant bits are even
	ADDL3	#1, R4, (R5)		; (R5) = I + 1
	CVTLH	(R5), (R5)		; (R5) = I + 1
ODD:	MULH2	H_45, (R5)		; (R5) = 45*(I+1)
	SUBH2	R0, (R5)		; (R5) = Y
	BICB	#^XF8, R4		; Save only last three octant bits
	RSB

CVT:	CVTLH	R4, (R5)		; (R5) = I
EVEN:	MULH2	H_M45, (R5)		; (R5) = -45*I
	ADDH2	R0, (R5)		; (R5) = Y
	BICB	#^XF8, R4		; Save only last three octant bits
	RSB




	.SBTTL	RADIAN_POLYNOMIALS	; Polynomials for arguments in radians



;
; Polynomial evaluation for HCOS(Y) for Y in radians - These routines assumes
; that the reduced argument is on the stack.  YLO is pointed to by R4, YHI is
; pointed to by R5, and R5 = R4 + 16
;

P_COS_R:
	BICW3	#^X8000, (R5), R3	; R3 = exponent bits of |Y|
	CMPW	#^X4000, R3		; Compare 1/2 with |Y|
	BGTR	LESS_THAN_HALF		; Sufficent overhang is available
NEEDS_DOUBLE:
	ADDH3	(R5), (R4), -(SP)	; Save Y
	ADDH3	(SP), (R5), -(SP)	; (SP) = Y + YHI
	MULH2	(SP)+, (R4)		; (R4) = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	DECW	(R4)			; (R4) = A2/2
1$:	MULH2	(R5), (R5)		; (R5) = YHI^2
	DECW	(R5)			; (R5) = YHI^2/2
	SUBH2	#1, (R5)		; (R5) = -(1 - YHI^2/2) = A1
	MULH3	(SP), (SP)+, R0		; R0/R3 = Y^2
	PUSHL	R4			; Save pointer to A2
	POLYH	R0, #COSLENR2-1, COSTBR2; R0/R3 = Q(Y^2)
	MOVL	(SP)+, R5		; R5 = pointer to A2
	SUBH2	(R5), R0		; R0/R3 = Q(Y^2) - A2/2
	SUBH2	16(R5), R0		; R0/R3 = HCOS(Y)
	BRW	CHECK

LESS_THAN_HALF:
	ADDH2	(R4), (R5)		; (R5) = Y
	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	PUSHL	R4			; Save pointer to YLO
	POLYH	R0, #COSLENR1-1, COSTBR1; R0/R3 = HCOS(Y)
	MOVL	(SP)+, R5		; R5 = pointer to YLO
	BRW	CHECK


;
; Polynomial evaluation for -HCOS(Y)
;

N_COS_R:
	BICW3	#^X8000, (R5), R3	; R3 = exponent bits of |Y|
	CMPW	#^X4000, R3		; Compare 1/2 with |Y|
	BGTR	2$			; Sufficent overhang is available
	ADDH3	(R5), (R4), -(SP)	; Save Y
	ADDH3	(SP), (R5), -(SP)	; (SP) = Y + YHI
	MULH2	(SP)+, (R4)		; (R4) = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	DECW	(R4)			; (R4) = A2/2
1$:	MULH2	(R5), (R5)		; (R5) = YHI^2
	DECW	(R5)			; (R5) = YHI^2/2
	SUBH2	#1, (R5)		; (R5) = -(1 - YHI^2/2) = A1
	MULH3	(SP), (SP)+, R0		; R0/R3 = Y^2
	PUSHL	R4			; Save pointer to A2
	POLYH	R0, #COSLENR2-1, COSTBR2; R0/R3 = Q(Y^2)
	MOVL	(SP)+, R5		; R5 = pointer to A2
	SUBH2	(R5), R0		; R0/R3 = Q(Y^2) - A2/2
	SUBH3	R0, 16(R5), R0		; R0/R3 = HCOS(Y)
	BRW	CHECK

2$:	ADDH2	(R4), (R5)		; (R5) = Y
	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	PUSHL	R4			; Save pointer to YLO
	POLYH	R0, #COSLENR1-1, COSTBR1; R0/R3 = HCOS(Y)
	MOVL	(SP)+, R5		; R5 = pointer to YLO
	XORW	#^X8000, R0		; R0/R3 = -HCOS(Y)
	BRW	CHECK


;
; Polynomial evaluation for -HSIN(Y)
;

N_SIN_R:
	XORW	#^X8000, (R4)		; (R4) = -YLO
	XORW	#^X8000, (R5)		; (R5) = -YHI

;
; Polynomial evaluation for HSIN(Y)
;

P_SIN_R:
	ADDH3	(R4), (R5), -(SP)	; Save Y
	MULH3	(SP), (SP), R0		; R0/R3 = Y^2
	PUSHL	R4			; Save pointer to YLO
	POLYH	R0, #SINLENR-1, SINTBR	; R0/R3 = P(Y^2)
	MOVL	(SP)+, R5		; R5 = pointer to YLO
	MULH2	(SP)+, R0		; R0/R3 = Y*P(Y^2)
	ADDH2	(R5), R0		; R0/R3 = YLO + Y*P(Y^2)
	ADDH2	16(R5), R0		; R0/R3 = Y + Y*P(Y^2) = HSIN(Y)
	BRW 	CHECK







	.SBTTL	CYCLE_POLYNOMIALS	; Polynomials for arguments in cycles



;
; Polynomial evaluation for HCOS(Y) for Y in cycles - These routines assume
; that the reduced argument is on the stack.  YLO is pointed to by R5, YHI is
; pointed to by R4, and R4 = R5 + 16
;

P_COS_C:
	BICW3	#^X8000, (R4), R3	; R3 = exponent bits of |Y|
	CMPW	#^X4000, R3		; Compare 1/2 with |Y|
	BGTR	2$			; Sufficent overhang is available
	ADDH3	(R5), (R4), -(SP)	; Save Y
	ADDH3	(SP), (R4), -(SP)	; (SP) = Y + YHI
	MULH2	(SP)+, (R5)		; (R5) = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#2, (R5)		; (R5) = A2/4
1$:	MULH2	(R4), (R4)		; (R4) = YHI^2
	SUBW	#2, (R4)		; (R4) = YHI^2/4
	SUBH2	#1, (R4)		; (R4) = -(1 - YHI^2/4) = A1
	MULH3	(SP), (SP)+, R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer to A2
	POLYH	R0, #COSLENC2-1, COSTBC2; R0/R3 = Q(Y^2)
	MOVL	(SP)+, R5		; R5 = pointer to A2
	SUBH2	(R5), R0		; R0/R3 = Q(Y^2) - A2/4
	SUBH2	16(R5), R0		; R0/R3 = HCOS(Y)
	BRW	CHECK

2$:	ADDH2	(R5), (R4)		; (R4) = Y
	MULH3	(R4), (R4), R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer to YLO
	POLYH	R0, #COSLENC1-1, COSTBC1; R0/R3 = HCOS(Y)
	MOVL	(SP)+, R5		; R5 = pointer to YLO
	BRW	CHECK


;
; Polynomial evaluation for -HCOS(Y)
;

N_COS_C:
	BICW3	#^X8000, (R4), R3	; R3 = exponent bits of |Y|
	CMPW	#^X4000, R3		; Compare 1/2 with |Y|
	BGTR	2$			; Sufficent overhang is available
	ADDH3	(R5), (R4), -(SP)	; Save Y
	ADDH3	(SP), (R4), -(SP)	; (SP) = Y + YHI
	MULH2	(SP)+, (R5)		; (R5) = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#2, (R5)		; (R5) = A2/4
1$:	MULH2	(R4), (R4)		; (R4) = YHI^2
	SUBW	#2, (R4)		; (R4) = YHI^2/4
	SUBH2	#1, (R4)		; (R4) = -(1 - YHI^2/4) = A1
	MULH3	(SP), (SP)+, R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer to A2
	POLYH	R0, #COSLENC2-1, COSTBC2; R0/R3 = Q(Y^2)
	MOVL	(SP)+, R5		; R5 = pointer to A2
	SUBH2	(R5), R0		; R0/R3 = Q(Y^2) - A2/4
	SUBH3	R0, 16(R5), R0		; R0/R3 = HCOS(Y)
	BRW	CHECK

2$:	ADDH2	(R5), (R4)		; (R4) = Y
	MULH3	(R4), (R4), R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer to YLO
	POLYH	R0, #COSLENC1-1, COSTBC1; R0/R3 = HCOS(Y)
	MOVL	(SP)+, R5		; R5 = pointer to YLO
	XORW	#^X8000, R0		; R0/R3 = -HCOS(Y)
	BRW	CHECK


;
; Polynomial evaluation for -HSIN(Y)
;

N_SIN_C:
	MNEGH	(R5), (R5)		; (R5) = -YLO
	XORW	#^X8000, (R4)		; (R4) = -YHI

;
; Polynomial evaluation for HSIN(Y)
;

P_SIN_C:
	ADDH3	(R4), (R5), -(SP)	; Save Y
	MULH3	(SP), (SP), R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer to YLO
	POLYH	R0, #SINLENC-1, SINTBC	; R0/R3 = P(Y^2)
	MOVL	(SP)+, R5		; R5 = pointer to YLO
	MULH2	(SP), R0		; R0/R3 = Y*P(Y^2)
	MOVO	(R5), (SP)		; (SP) = YLO
	BEQL	1$			; Check for YLO = 0
	SUBW	#2, (R5)		; (R5) = YLO/4
	SUBH2	(R5), (SP)		; (SP) = 3/4*YLO
	ADDH2	(SP), R0		; R0/R3 = 3/4*YLO + Y*P(Y^2)
1$:	MOVO	16(R5), (SP)		; (SP) = YHI
	SUBW	#2, 16(R5)		; 16(R5) = YHI/4
	SUBH2	16(R5), (SP)		; (SP) = 3/4*YHI
	ADDH2	(SP)+, R0		; R0/R3 = HSIN(Y)
	BRB	CHECK


CHECK:
	CMPL	R5, SP			; If R5 and SP are equal than the
	BNEQ	1$			;   the polynomial was invoked via
	ADDL	#32, SP			;   a branch instruction an the
1$:	RSB				;   stack should be cleared





	.SBTTL	DEGREE_POLYNOMIALS


P_COS_D:
	CMPH	H_90_OV_PI, (R5)		; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer
	POLYH	R0, #COSDLN1, COSDTB1	; R0/R3 = Q(Y^2) 
	MOVL	(SP)+, R5		; Restore pointer
	MOVO	(R5), -(SP)		; (SP) = Y
	CLRQ	8(R5)			; (R5) = YHI
	SUBH3	(R5), (SP), -(SP)	; (SP) = YLO
	ADDH2	(R5), 16(SP)		; 16(SP) = Y + YHI
	MULH2	(SP)+, (SP)		; (SP) = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#13, (SP)		; (SP) = A2/2^13
1$:	SUBH2	(SP)+, R0		; R0/R3 = Q(Y^2) - A2/2^13
	MULH2	(R5), (R5)		; (R5) = YHI^2
	SUBW	#13, (R5)		; (R5) = YHI^2/2^13
	SUBH2	#1, (R5)		; (R5) = -(1 - YHI^2/2^13)
	SUBH2	(R5), R0		; R0/R3 = HCOS(Y)
	BRW	CHECK_DEG

2$:	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	BEQL	3$			; Check for Y = 0
	PUSHL	R5			; Save pointer
	POLYH	R0, #COSDLN2, COSDTB2	; R0/R3 = HCOS(Y)
	MOVL	(SP)+, R5		; Restore pointer
	BRW	CHECK_DEG

3$:	MOVH	#1, R0			; R0/R3 = HCOS(Y)
	BRW	CHECK_DEG


N_COS_D:
	CMPH	H_90_OV_PI, (R5)		; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	PUSHL	R5			; Save pointer
	POLYH	R0, #COSDLN1, COSDTB1	; R0/R3 = Q(Y^2) 
	MOVL	(SP)+, R5		; Restore pointer
	MOVO	(R5), -(SP)		; (SP) = Y
	CLRQ	8(R5)			; (R5) = YHI
	SUBH3	(R5), (SP), -(SP)	; (SP) = YLO
	ADDH2	(R5), 16(SP)		; 16(SP) = Y + YHI
	MULH2	(SP)+, (SP)		; (SP) = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#13, (SP)		; (SP) = A2/2^13
1$:	SUBH2	(SP)+, R0		; R0/R3 = Q(Y^2) - A2/2^13
	MULH2	(R5), (R5)		; (R5) = YHI^2
	SUBW	#13, (R5)		; (R5) = YHI^2/2^13
	SUBH2	#1, (R5)		; (R5) = -(1 - YHI^2/2^13)
	SUBH3	R0, (R5), R0		; R0/R3 = -HCOS(Y)
	BRW	CHECK_DEG

2$:	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	BEQL	3$			; Check for Y = 0
	PUSHL	R5			; Save pointer
	POLYH	R0, #COSDLN2, COSDTB2	; R0/R3 = HCOS(Y)
	XORW	#^X8000, R0		; R0/R3 = -HCOS(Y)
	MOVL	(SP)+, R5		; Restore pointer
	BRW	CHECK_DEG

3$:	MOVH	H_M1, R0		; R0/R3 = HCOS(Y)
	BRW	CHECK_DEG

N_SIN_D:
	MNEGH	(R5), (R5)		; (R5) = -Y
P_SIN_D:
	MULH3	(R5), (R5), R0		; R0/R3 = Y^2
	BEQL	CHECK_DEG
	PUSHL	R5			; Save pointer
	POLYH	R0, #SINDLN, SINDTB	; R0/R3 = P(Y^2)
	MOVL	(SP)+, R5		; Restore pointer
	MULH2	(R5), R0		; R0/R3 = Y*P(Y^2)
	SUBW	#6, (R5)		; (R5) = Y/2^6
	ADDH2	(R5), R0		; R0/R3 = HSIN(Y)


CHECK_DEG:
	CMPL	R5, SP			; If R5 and SP are equal than the
	BNEQ	1$			;   the polynomial was invoked via
	ADDL	#16, SP			;   a branch instruction an the
1$:	RSB				;   stack should be cleared





	.SBTTL	DEGENERATE_SOLUTIONS

P_ONE:
	MOVH	#1, R0			; Answer is 1
	RSB


N_ONE:
	MOVH	H_M1, R0		; Answer is -1
	RSB


UNFL:
;
; Underflow; if user has FU set, signal error.  Always return 0.0
;
	MOVPSL	R2			; R2 = user's or jacket routine's PSL
	CALLS	#0, G^MTH$$JACKET_TST	; R0 = TRUE if JSB from jacket routine
	BLBC	R0, 10$			; branch if user did JSB
	MOVZWL	SF$W_SAVE_PSW(FP), R2	; get user PSL saved by CALL
10$:	CLRL	R0			; R0 = result. LIB$SIGNAL will save in
					; CHF$L_MCH_R0/R1 so any handler can 
					;   fixup
	BBC	#6, R2, 20$		; has user enabled floating underflow?
	PUSHL	(SP)			; yes, return PC from special routine
	MOVZBL	#MTH$K_FLOUNDMAT, -(SP)	; trap code for hardware floating 
					;   underflow convert to MTH$_FLOUNDMAT
					;   (32-bit VAX-11 exception code)
	CALLS	#2, G^MTH$$SIGNAL	; signal (condition, PC)
20$:	RSB				; return

	.END
