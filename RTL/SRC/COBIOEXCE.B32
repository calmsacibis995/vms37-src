MODULE COB$IOEXCEPTION(
		IDENT = '1-036'		! file:COBIOEXCE.B32  EDIT:LB1036
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY:	COBOL SUPPORT
!
! ABSTRACT:
!
!	This procedure is called to process a wide variety of I/O
! exceptions.  Depending on the nature of the exception, it sets the
! file status variable, causes USE procedures to be invoked and
! signals errors.
!
!
! ENVIRONMENT:	Vax-11 User Mode
!
! AUTHOR: MLJ , CREATION DATE: 02-MAY-1979
!
! MODIFIED BY:
!
! 1-001 - Original. MLJ  02-MAY-1979
! 1-002 - Added boilerplate and comments. RKR 22-AUG-1979
! 1-003 - Redesigned control tables to allow additional checking on
!	  status of state variables -- option file errors and repeated
!	  EOF error mechanisms.  RKR 10-SEPT-1979
! 1-004 - Added additional statuses (RMS$_FAB and RMS$_RAB) to control
!	  tables and delete explicit checks for "FNO" flag.
!	  RKR 12-SEPT-79
! 1-005 - Complete revamp of action codes in control table RKR 13-SEPT-79
! 1-006 - Added FAC error codes to READ S S and READ R S control tables
!	  RKR 18-SEPT-79
! 1-007 - Fetch COBDEF from RTLIN rather than LIB$.  RKR 18-SEPT-79
! 1-008 - Add COB$K_EXC_CLORS to SET.  RKR 18-SEP-79
! 1-009 - Fix endcoding and decoding of error messages. RKR 19-SEPT-79
!
! 1-010 - Add logic to discriminate between COB$_REASMMIN, COB$_WRISMAMIN, and COB$_REWSMAMIN.
!	  RKR 25-SEPT-79
! 1-011 - Added diagnostic for unexpected situation in which a RMS
!	  success code is encountered.  RKR 26-SEPT-79
! 1-012 - Change symbolic name of LIBRARY file. RKR 1-OCT-79
! 1-013 - Make it use COB$$INVOKE_USE instead of COB$INVOKE_USE
!	  RKR 1-OCT-79
! 1-014 - Stop outputting the COB$_NO_USEPRO error message since it
!	  contains no information which is not also contained in
!	  the subsequent more specific message.
!	  Add entry to CLOSE_T to try to catch a CLOSE REEL operation
!	  to an inappropriate device.  If operation is close and error
!	  status is RMS$_IOP, SUCCEED with FILESTAT of '00'.
!	  RKR 1-OCT-79
! 1-015 - Add special case for COB$K_EXC_ORG.  RKR 04-OCT-79
! 1-016 - Use max and mins from REQUIRE file, add new table and new
!	  state for CLOSE REEL, cosmetic changes, bugchecks at
!	  empty [INRANGE] statements.
!	  RKR 20-OCT-79
! 1-017 - Cosmetic changes.  21-OCT-79
! 1-018 - Rearrange statuses for tables CLOSE_T and CLOSEREEL_S_S_T.
!	  RKR 29-OCT-79
! 1-019 - Add comments.  RKR 05-NOV-79
! 1-020 - Change resulting file status and action codes for
!	  RMS$_OK_RLK for read actions.  RKR 08-NOV-79
! 1-021 - Change some table entries dealing with creating of 
!	  duplicate keys.  RKR 11-NOV-79
! 1-022 - Added comments and made cosmetic changes.  LB 3-MAR-81
! 1-023 - Changed code that checked the value of FP; if zero, a call
! 	  is now made to SIGNAL_STOP indicating a fatal internal error.
!	  Also, code was taken out that checked if the current handler
!	  was COB$HANDLER; this is not a catch-all check since a user
!	  can establish his/her own error handler.  Also, added more
!	  comments.  LB  05-MAR-81
! 1-024 - Replaced arbitrary signalling values for USE procedure code
!	  with appropriate symbol names now defined in COBMSGDEF.
!	  Added corresponding entries in the EXTERNAL LITERAL
!	  declarations for this module.  LB  24-MAR-81
! 1-025 - Changed external literal for no use procedure on open mode entry
!	  and added an external literal for lost handler for file specific
!	  entry to correspond with changes made to COBMSG.MDL.  Changed
!	  calls to LIB$SIGNAL to use SIGNAL for consistency reasons.
!	  Optimized code by encasing calls to SIGNAL_STOP in BEGIN-END
!	  blocks.  Changed the calls to SIGNAL to now take an FAO
!	  parameter (as is syntactically correct) even though the
!	  parameter that is getting passed to the handler is not an
!	  FAO parameter (note that the !+ directive in the error message
!	  text will ignore it).  LB  16-APR-81
! 1-026 - Deleted the external literals COB$_LSTHNDLOP and COB$_LSTHNDLFL
!	  and added COB$_LSTHNDUSE.  This was done as a result of a change
!	  made in COBOL regarding the scoping rules for USE procedures.
!	  Changed code in the area of loading up the resultant string 
!	  descriptor to facilitate the added functionality of RMS special
!	  registers within COBOL.  The code now loads the actual string from
!	  the FAB into the resultant string area within the NAM block in the
!	  case where the name block string length and extended string length
!	  equal zero.  Changed code that searched for USE procedures.  A
!	  single condition is now signalled in the case where there are
!	  applicable USE procedures (but cannot be seen within this level of
!	  code) and an additional parameter is included in the signal (it now
!	  takes the entry point of a file specific USE procedure or 0 if none
!	  as well as the entry point of an open mode specific USE procedure
!	  or 0 if none).  Also, the final action code was removed from each of
!	  the separate blocks of search code for USE procedures and moved to a
!	  single place outside of those blocks of code.  LB  21-APR-81.
! 1-027 - Added code in success status checkout code for reads, which will
!	  take care of an unreported bug that exists in both the V1.0 and
!	  V2.0 versions of the COBOL compiler.  The code now further checks
!	  if the RMS_STS code indicates a file that (soft) record locked.
!	  If so, it sets the FILESTAT to 90 (instead of 0) and sets the
!	  ACTION to CONTINUE (instead of SUCCEED).  Also caused the read
!	  entries in THE table for RMS$_OK_RLK to be removed.  LB  30-APR-81.
! 1-028 - Added code following the call to COB$$INVOKE_USE to check the
!	  ACTION code.  This code was added as a result of the current code
!	  falling through into code that would signal an error.  LB  14-MAY-81
! 1-029	- Added a check before calling SIGNAL for ensuring that OPEN_MD_ADDR
!	  and FILE_ADDR are not equal to zero (making sure that USE procedures
!	  do indeed exist before signalling).  LB  29-JUN-81.
! 1-030	- Added COB$_KEYNOTMAT.  Also, moved setting of ERR_MSG_NUM slightly to
!	  allow BLISS to do more omega motion.  Use PLIT_TABLE, and remove case
!	  statement to access correct action table.  Rename PLITs consistently.
!	  Use common action tables.  PDG 24-JUL-81
! 1-031 - Added support for manual record locking.
!    		  Error messages: COB$K_RECNOTLOC and COB$K_UNLUNOFIL
!		  UNL_T table AND modification to PLIT_TABLE bh 28-jul-81
! 1-032	- Added code to move the COBOL condition value to RAB[RMS$_STS/STV]
!	  if the error is a non-RMS error (alternately, an error that is
!	  detected by compiled code).  This allows the RMS-STS/STV values
!	  to be meaningful within a USE procedure.  PDG  7-AUG-81.
! 1-033	- Corrected the action code associated with RECNOTLOC to be SUCCEED,
!	  and changed the file status to "00".
!	  PDG 18-Aug-1981.
! 1-034 - Added support for UNLOCK in non-automatic record locking mode.
!	  BH 29-Oct-1981.
! 1-035 - Added LIB$STOP as external routine.  LB 30-NOV-81
! 1-036 - Changed UNL_T table entries for the RMS ISI and RAB codes from
!	  GOTO to ABORT.  LB 1-DEC-81
!--

!<BLF/PAGE>

!+
! SWITCHES
!-

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!+
! LINKAGES
!	NONE
!-

!++
! TABLE OF CONTENTS:
!-

FORWARD ROUTINE
	COB$IOEXCEPTION ;

!+
! INCLUDE FILES
!-

REQUIRE 'RTLIN:COBDEF';			! COBOL specific RTL macros and literals
REQUIRE 'RTLIN:RTLPSECT' ;		! Macros for defining psects
LIBRARY 'RTLSTARLE';			! RTL routines

!+
! MACROS
!-

MACRO

	!+
	! Field definitions for table.
	!-

	TAB_STATUS=	0,0,32,0 %,	! RMS status code (or 0)
	TAB_FILESTAT=	4,0,16,0 %,	! COBOL file status
	TAB_ACTION=	6,0,8,0 %,	! Type of recovery action
	TAB_ERR_NO=	7,0,8,0 %,	! COB$ facility error number
	TAB_TST_STATE=	8,0,8,0 %,	! Optional state to test
	TAB_SET_STATE=	9,0,8,0 %,	! Optional state to set

	!+
	! Macro to make table entries.
	!-

	Z[A,B,C,D,E,F]=
	 LONG(A), WORD(B), BYTE(C), BYTE((D-COB$_NO_USEPRO)^-3), BYTE(E), BYTE(F) %;

!+
! EQUATED SYMBOLS
!-

LITERAL

	MIN_STATE = 0,			! Minimum state variable

	NULL = 0 ,			! No special action
	OPTF = 1 ,			! Optional file
	OFNP = 2 ,			! Optional file not present (OPEN couldn't find)
	NNVR = 3 ,			! No next valid record (already seen EOF)

	MAX_STATE = 3,			! Maximum state variable


	!+
	! Size of table entry.
	!-

	TAB_S_ENTRY=	10,

	!+
	! Values of ACTION.		Resulting behavior
	!-

	ABORT=	        0,

			!+
			! If an applicable USE procedure is present,
			! then invoke the USE procedure followed by
			! continuing at the "next statement" (i.e.
			! RETURN 0;
			! Otherwise, LIBSTOP with appropriate error
			! signal.
			!
	GOTO=		1,

			! If an exception label is present, goto
			! exception label;
			! Otherwise handle like class ABORT.
			!
	CONTINUE=	2,

			! If an applicable USE procedure is present,
			! then invoke USE procedure followed by
			! continuing "immediately" (i.e. RETURN 1);
			! Otherwise, continue "immediately"
			! (i.e. RETURN 1)
			!
	SUCCEED=	3;

			! The COBOL I/O statement is successful in
			! every respect.  Therefore, continue
			! "immediately" (i.e. RETURN 1) after updating
			! file status variable (if present).
			!-

!+
! PSECT DECLARATIONS:
!-

DECLARE_PSECTS (COB) ;				! Declare psects for COB$ facility

!+
! EXTERNAL REFERENCES
!-

EXTERNAL ROUTINE
	LIB$STOP:NOVALUE,			! Signal fatal error
	COB$HANDLER:	,			! COBOL exception handler
	COB$$INVOKE_USE: NOVALUE;		! Invoke USE procedure

EXTERNAL LITERAL
    COB$_NO_USEPRO,   ! No USE procedure available for error on file !AS
    COB$_ERRON_FIL,   ! Error on file !AS
    COB$_OPTMISOPE,   ! Optional file !AS missing on OPEN
    COB$_FILALRLOC,   ! File !AS is already locked
    COB$_FILALROPE,   ! File !AS is already open
    COB$_FILCLOLOC,   ! File !AS is closed with LOCK
    COB$_NO_SPACE,    ! No filespace on device for file !AS
    COB$_FILNOTFOU,   ! File !AS not found on OPEN
    COB$_OPTMISCLO,   ! Optional file !AS missing on CLOSE
    COB$_FILALRCLO,   ! File !AS already closed
    COB$_NO_NEXLOG,   ! No next logical record on file !AS
    COB$_OPTMISREA,   ! Optional file !AS missing on READ
    COB$_NO_NEXVAL,   ! No next valid record on file !AS
    COB$_RECLOCREA,   ! Record on file !AS is already locked (READ attempt)
    COB$_RECLOC_OK,   ! Record on file !AS already locked, but ok
    COB$_REAUNOFIL,   ! Attempting READ on unopened file !AS
    COB$_REAINCOPE,   ! READ on file !AS incompatible with OPEN mode
    COB$_WRIBEYBOU,   ! Attempting WRITE beyond boundaries of file !AS
    COB$_WRIUNOFIL,   ! Attempting WRITE on unopened file !AS
    COB$_WRIINCOPE,   ! WRITE on file !AS incompatible with OPEN mode
    COB$_REWNO_R_S,   ! Attempting REWRITE on file !AS with no previous READ or START
    COB$_REWUNOFIL,   ! Attempting REWRITE on unopened file !AS
    COB$_REWINCOPE,   ! REWRITE on file !AS incompatible with OPEN mode
    COB$_RECNOTEXI,   ! Record does not exist on file !AS
    COB$_OPTMISSTA,   ! Optional file !AS missing on START
    COB$_RECLOCSTA,   ! Record on file !AS is already locked (START attempt)
    COB$_STAUNOFIL,   ! Attempting START on unopened file !AS
    COB$_STAINCOPE,   ! START on file !AS incompatible with OPEN mode
    COB$_RECLOCWRI,   ! Record on file !AS is already locked (WRITE attempt)
    COB$_RECLOCDEL,   ! Record on file !AS is already locked (DELETE attempt)
    COB$_DELNO_R_S,   ! Attempting DELETE on file !AS without previous READ or START
    COB$_DELUNOFIL,   ! Attempting DELETE on unopened file !AS
    COB$_DELINCOPE,   ! DELETE on file !AS incompatible with OPEN mode
    COB$_RECLOCREW,   ! Record on file !AS is already locked (REWRITE attempt)
    COB$_WRIDUPKEY,   ! Attempting WRITE of duplicate key in file !AS
    COB$_WRICREDUP,   ! WRITE created an allowed duplicate alternate key on file !AS
    COB$_WRINOTASC,   ! Attempting to WRITE non-ascending ISAM key on file !AS
    COB$_WRIDUPALT,   ! Attempting to WRITE duplicate alternate key on file !AS
    COB$_REWCREDUP,   ! REWRITE created an allowed duplicate alternate key on file !AS
    COB$_PRIKEYCHA,   ! Primary record key on file !AS changed between READ and REWRITE
    COB$_REWDISDUP,   ! Attempting to REWRITE disallowed duplicate key on file !AS
    COB$_WRIDISDUP,   ! Attempting to WRITE disallowed duplicate key on file !AS
    COB$_REASMAMIN,   ! Attempting READ of variable length smaller than minimum allowed from file !AS
    COB$_WRISMAMIN,   ! Attempting WRITE of variable length smaller than minimum allowed to file !AS
    COB$_REWSMAMIN,   ! Attempting REWRITE of variable length smaller than minimum allowed to file !AS
    COB$_ORGNOTMAT,   ! Attempting to open file whose organization does
		      ! not match access mode
    COB$_INVARG,      ! Invalid arguments
    COB$_LSTHNDUSE,   ! Lost handler for a USE procedure - environment corrupted !2(+)
    COB$_KEYNOTMAT,   ! Attempting to open indexed file with keys whose description
		      ! does not match those expected
    COB$_RECNOTLOC,   ! Record not ocked in file !AS (UNLOCK attempt)
    COB$_UNLUNOFIL,   ! Attempting UNLOCK on unopened file !AS
    COB$_UNLNO_CUR,   ! Attempting UNLOCK on file !AS with no current record
    OTS$_FATINTERR;   ! Condition value



!+
! The following table contains the logic which drives a large portion
! of this program.  During a table look-up, a match is found first on
! the RMS status code and on the State-to-test field.  When a match is
! found, the State-to-set is set if non-zero, the file status becomes
! the file status returned to the users file status variable, Action
! code controls the flow through the code and the error message is 
! the one signalled if the user has not provided a USE procedure to
! deal with the problem.
!
! Each table must end with an entry that has a 0 for the RMS status
! code.  This forms a default termination for the table lookup.
!
! If the action code is SUCCEED, the Associated Error Message in the
! table is academic since it is never signaled.
!
! The following tables contain information as follows:
!
!	RMS status	File	ACTION	 Associated    State   State
!	code		Status  code	 Error msg    to test  to set
!	-----------	------	-------	 ----------   -------  ------
!
!-


BIND
	BASE = UPLIT(REP 0 OF (0)),
	OPE_T = UPLIT BYTE(Z(
	    RMS$_FUL,   '95',   ABORT,   COB$_NO_SPACE,  0,    0,
	    RMS$_FNF,   '05',   CONTINUE,COB$_OPTMISOPE, OPTF, OFNP,
	    RMS$_FNF,   '97',   ABORT,   COB$_FILNOTFOU, 0,    0,
	    RMS$_FLK,   '91',   ABORT,   COB$_FILALRLOC, 0,    0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL, 0,    0)),

	CLO_T = UPLIT BYTE(Z(
	    RMS$_IFI,   '00',   SUCCEED, COB$_OPTMISCLO,  OFNP, 0,
	    RMS$_IFI,   '94',   ABORT,   COB$_FILALRCLO,  0,    0,
	    RMS$_FAB,   '94',   ABORT,   COB$_FILALRCLO,  0,    0,
	    0,          '98',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	CLR_S_S_T = UPLIT BYTE(Z(
	    RMS$_ISI,   '00',   SUCCEED, COB$_OPTMISCLO,  OFNP, 0,
	    RMS$_ISI,   '94',   ABORT,   COB$_FILALRCLO,  0,    0,
	    RMS$_RAB,   '94',   ABORT,   COB$_FILALRCLO,  0,    0,
	    RMS$_IOP,   '00',   SUCCEED, COB$_NO_USEPRO,  0,    0,
	    RMS$_EOF,   '00',   SUCCEED, COB$_NO_USEPRO,  0,    0,
	    0,          '98',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	REA_S_S_T = UPLIT BYTE(Z(
	    RMS$_EOF,   '16',   GOTO,    COB$_NO_NEXVAL,  NNVR, 0,
	    RMS$_EOF,   '13',   GOTO,    COB$_NO_NEXLOG,  0,    NNVR,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREA,  0,    0,
	    RMS$_ISI,   '15',   GOTO,    COB$_OPTMISREA,  OFNP, 0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REAINCOPE,  0,    0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	REA_R_S_T = REA_S_S_T,
!	REA_R_S_T = UPLIT BYTE(Z(
!	    RMS$_EOF,   '16',   GOTO,    COB$_NO_NEXVAL,  NNVR, 0,
!	    RMS$_EOF,   '13',   GOTO,    COB$_NO_NEXLOG,  0,    NNVR,
!	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREA,  0,    0,
!	    RMS$_ISI,   '15',   GOTO,    COB$_OPTMISREA,  OFNP, 0,
!	    RMS$_ISI,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
!	    RMS$_RAB,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
!	    RMS$_FAC,   '94',   ABORT,   COB$_REAINCOPE,  0,    0,
!	    0,          '30',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	REA_R_R_T = UPLIT BYTE(Z(
	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,  0,    0,
	    RMS$_KEY,   '23',   GOTO,    COB$_RECNOTEXI,  0,    0,
	    RMS$_KBF,   '23',   GOTO,    COB$_ERRON_FIL,  0,    0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREA,  0,    0,
	    RMS$_ISI,   '25',   GOTO,    COB$_OPTMISREA,  OFNP, 0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REAINCOPE,  0,    0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	REA_I_S_T = REA_S_S_T,
!	REA_I_S_T = UPLIT BYTE(Z(
!	    RMS$_EOF,   '16',   GOTO,    COB$_NO_NEXVAL,  NNVR, 0,
!	    RMS$_EOF,   '13',   GOTO,    COB$_NO_NEXLOG,  0,    NNVR,
!	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREA,  0,    0,
!	    RMS$_ISI,   '15',   GOTO,    COB$_OPTMISREA,  OFNP, 0,
!	    RMS$_ISI,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
!	    RMS$_RAB,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
!	    RMS$_FAC,   '94',   ABORT,   COB$_REAINCOPE,  0,    0,
!	    0,          '30',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	REA_I_R_T = UPLIT BYTE(Z(
	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,  0,    0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREA,  0,    0,
	    RMS$_ISI,   '25',   GOTO,    COB$_OPTMISREA,  OFNP, 0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REAUNOFIL,  0,    0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REAINCOPE,  0,    0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,  0,    0)),

	WRI_S_S_T = UPLIT BYTE(Z(
	    RMS$_FUL,   '34',   ABORT,   COB$_WRIBEYBOU,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_WRIINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	WRI_R_S_T = UPLIT BYTE(Z(
	    RMS$_FUL,   '24',   GOTO,    COB$_WRIBEYBOU,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCWRI,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_WRIINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	WRI_R_R_T = UPLIT BYTE(Z(
	    RMS$_REX,   '22',   GOTO,    COB$_WRIDUPKEY,   0,   0,
	    RMS$_FUL,   '24',   GOTO,    COB$_WRIBEYBOU,   0,   0,
	    RMS$_KEY,   '24',   GOTO,    COB$_WRIBEYBOU,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCWRI,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_WRIINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	WRI_I_S_T = UPLIT BYTE(Z(
	    RMS$_OK_DUP,'02',   CONTINUE,COB$_WRICREDUP,   0,   0,
	    RMS$_SEQ,   '21',   GOTO,    COB$_WRINOTASC,   0,   0,
	    RMS$_DUP,   '22',   GOTO,    COB$_WRIDISDUP,   0,   0,
	    RMS$_FUL,   '24',   GOTO,    COB$_WRIBEYBOU,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCWRI,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_WRIINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	WRI_I_R_T = UPLIT BYTE(Z(
	    RMS$_OK_DUP,'02',   CONTINUE,COB$_WRICREDUP,   0,   0,
	    RMS$_DUP,   '22',   GOTO,    COB$_WRIDISDUP,   0,   0,
	    RMS$_REX,   '22',   GOTO,    COB$_WRIDISDUP,   0,   0,
	    RMS$_FUL,   '24',   GOTO,    COB$_WRIBEYBOU,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCWRI,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_WRIUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_WRIINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	DEL_R_S_T = UPLIT BYTE(Z(
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCDEL,   0,   0,
	    RMS$_CUR,   '93',   ABORT,   COB$_DELNO_R_S,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_DELINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	DEL_R_R_T = UPLIT BYTE(Z(
	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCDEL,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_DELINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	DEL_I_S_T = DEL_R_S_T,
!	DEL_I_S_T = UPLIT BYTE(Z(
!	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCDEL,   0,   0,
!	    RMS$_CUR,   '93',   ABORT,   COB$_DELNO_R_S,   0,   0,
!	    RMS$_ISI,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
!	    RMS$_RAB,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
!	    RMS$_FAC,   '94',   ABORT,   COB$_DELINCOPE,   0,   0,
!	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	DEL_I_R_T = DEL_R_R_T,
!	DEL_I_R_T = UPLIT BYTE(Z(
!	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,   0,   0,
!	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCDEL,   0,   0,
!	    RMS$_ISI,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
!	    RMS$_RAB,   '94',   ABORT,   COB$_DELUNOFIL,   0,   0,
!	    RMS$_FAC,   '94',   ABORT,   COB$_DELINCOPE,   0,   0,
!	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	REW_S_S_T = UPLIT BYTE(Z(
	    RMS$_CUR,   '93',   ABORT,   COB$_REWNO_R_S,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REWINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	REW_R_S_T = UPLIT BYTE(Z(
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREW,   0,   0,
	    RMS$_CUR,   '93',   ABORT,   COB$_REWNO_R_S,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REWINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	REW_R_R_T = UPLIT BYTE(Z(
	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREW,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REWINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	REW_I_S_T = UPLIT BYTE(Z(
	    RMS$_OK_DUP,'02',   CONTINUE,COB$_REWCREDUP,   0,   0,
	    RMS$_CHG,   '21',   GOTO,    COB$_PRIKEYCHA,   0,   0,
	    RMS$_DUP,   '22',   GOTO,    COB$_REWDISDUP,   0,   0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREW,   0,   0,
	    RMS$_CUR,   '93',   ABORT,   COB$_REWNO_R_S,   0,   0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REWUNOFIL,   0,   0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REWINCOPE,   0,   0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,   0)),

	REW_I_R_T = UPLIT BYTE(Z(
	    RMS$_OK_DUP,'02',   CONTINUE,COB$_REWCREDUP,   0,    0,
	    RMS$_DUP,   '22',   GOTO,    COB$_REWDISDUP,   0,    0,
	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,   0,    0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCREW,   0,    0,
	    RMS$_ISI,   '94',   ABORT,   COB$_REWUNOFIL,   0,    0,
	    RMS$_RAB,   '94',   ABORT,   COB$_REWUNOFIL,   0,    0,
	    RMS$_FAC,   '94',   ABORT,   COB$_REWINCOPE,   0,    0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,    0)),

	STA_R_S_T = UPLIT BYTE(Z(
	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,   0,    NNVR,
	    RMS$_ISI,   '25',   GOTO,    COB$_OPTMISSTA,   OFNP, 0,
	    RMS$_ISI,   '94',   ABORT,   COB$_STAUNOFIL,   0,    0,
	    RMS$_RAB,   '94',   ABORT,   COB$_STAUNOFIL,   0,    0,
	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCSTA,   0,    0,
	    RMS$_FAC,   '94',   ABORT,   COB$_STAINCOPE,   0,    0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,    0)),

	STA_I_S_T = STA_R_S_T,
!	STA_I_S_T = UPLIT BYTE(Z(
!	    RMS$_RNF,   '23',   GOTO,    COB$_RECNOTEXI,   0,    NNVR,
!	    RMS$_ISI,   '25',   GOTO,    COB$_OPTMISSTA,   OFNP, 0,
!	    RMS$_ISI,   '94',   ABORT,   COB$_STAUNOFIL,   0,    0,
!	    RMS$_RAB,   '94',   ABORT,   COB$_STAUNOFIL,   0,    0,
!	    RMS$_RLK,   '92',   ABORT,   COB$_RECLOCSTA,   0,    0,
!	    RMS$_FAC,   '94',   ABORT,   COB$_STAINCOPE,   0,    0,
!	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,    0));

	UNL_T = UPLIT BYTE(Z(
	    RMS$_RNL,   '00',   SUCCEED, COB$_RECNOTLOC,   0,    0,
	    RMS$_ISI,   '94',   ABORT,   COB$_UNLUNOFIL,   0,	 0,
	    RMS$_RAB,   '94',   ABORT,   COB$_UNLUNOFIL,   0,    0,
	    RMS$_CUR,	'93',	ABORT,	 COB$_UNLNO_CUR,   0,	 0,
	    0,          '30',   ABORT,   COB$_ERRON_FIL,   0,    0));

!+
! The following table is indexed by an I/O statement type to yield the address
! (relative to BASE) of the appropriate action table.  Negative values are used
! to indicate an error condition (COB$_INVARG).
!-
BIND
    PLIT_TABLE = UPLIT WORD(
	OPE_T - BASE,		! COB$K_EXC_OPESS= 1,
	-1,			! 2
	OPE_T - BASE,		! COB$K_EXC_OPERS= 3,
	OPE_T - BASE,		! COB$K_EXC_OPERR= 4,
	OPE_T - BASE,		! COB$K_EXC_OPEIS= 5,
	OPE_T - BASE,		! COB$K_EXC_OPEIR= 6,
	CLO_T - BASE,		! COB$K_EXC_CLOSS= 7,
	-1,			! 8
	CLO_T - BASE,		! COB$K_EXC_CLORS= 9,
	CLO_T - BASE,		! COB$K_EXC_CLORR=10,
	CLO_T - BASE,		! COB$K_EXC_CLOIS=11,
	CLO_T - BASE,		! COB$K_EXC_CLOIR=12,
	REA_S_S_T - BASE,	! COB$K_EXC_REASS=13,
	-1,			! 14
	REA_R_S_T - BASE,	! COB$K_EXC_REARS=15,
	REA_R_R_T - BASE,	! COB$K_EXC_REARR=16,
	REA_I_S_T - BASE,	! COB$K_EXC_REAIS=17,
	REA_I_R_T - BASE,	! COB$K_EXC_REAIR=18,
	WRI_S_S_T - BASE,	! COB$K_EXC_WRISS=19,
	-1,			! 20
	WRI_R_S_T - BASE,	! COB$K_EXC_WRIRS=21,
	WRI_R_R_T - BASE,	! COB$K_EXC_WRIRR=22,
	WRI_I_S_T - BASE,	! COB$K_EXC_WRIIS=23,
	WRI_I_R_T - BASE,	! COB$K_EXC_WRIIR=24,
	REW_S_S_T - BASE,	! COB$K_EXC_REWSS=25,
	-1,			! 26
	REW_R_S_T - BASE,	! COB$K_EXC_REWRS=27,
	REW_R_R_T - BASE,	! COB$K_EXC_REWRR=28,
	REW_I_S_T - BASE,	! COB$K_EXC_REWIS=29,
	REW_I_R_T - BASE,	! COB$K_EXC_REWIR=30,
	-1,			! COB$K_EXC_DELSS=31,	!???  Is this used?
	-1,			! 32
	DEL_R_S_T - BASE,	! COB$K_EXC_DELRS=33,
	DEL_R_R_T - BASE,	! COB$K_EXC_DELRR=34,
	DEL_I_S_T - BASE,	! COB$K_EXC_DELIS=35,
	DEL_I_R_T - BASE,	! COB$K_EXC_DELIR=36,
	-1,			! 37
	-1,			! 38
	STA_R_S_T - BASE,	! COB$K_EXC_STARS=39,
	-1,			! 40
	STA_I_S_T - BASE,	! COB$K_EXC_STAIS=41,
	-1,			! 42
	CLR_S_S_T- BASE,	! COB$K_EXC_CLRSS=43,
    	UNL_T    - BASE		! COB$K_EXC_UNLCK=44,
	) - 2: VECTOR[,WORD];

GLOBAL ROUTINE COB$IOEXCEPTION (

	FLAGS,		! Type of I/O statement and type of exception
	RAB,		! Address of associated RAB
	EXCLAB,		! Exception transfer label (optional)
	STATUS		! Address of file status variable (optional)

				) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This procedure is called to process a wide variety of I/O
! exceptions.  Depending on the nature of the exception, it sets the
! file status variable, causes USE procedures to be invoked and
! signals errors.
!
! FORMAL PARAMETERS:
!
!	FLAGS.rl.v	- Type of I/O statement and type of exception
!	RAB.ra.v	- Address of RAB
!	EXCLAB.jzi.v	- Exception transfer label (optional)
!	STATUS.ra.r	- Address of file status variable (optional)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Value TRUE if SUCCEED, FALSE if other.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

!+
!
! The USE list structure appears as follows:
!
!
!	 -----------------------------------------------------
!	0|		COB$A_USE_PNC			     |
!      	 |---------------------------------------------------|
!       1|		COB$A_USE_MODES			     |BASE OF OPEN MODE
!	 |---------------------------------------------------|
!	2|		      .				     |
!	 |		      .				     |
!	 |		      .	 MODE SPECIFIC		     |
!	 |		      .  USE ENTRIES		     |
!	 |		      .				     |
!	 |		      .				     |
!        |---------------------------------------------------|
!      36|		      |COB$B_GUSE_CNT |COB$B_USE_CNT |
!	 |---------------------------------------------------|
!      37|		COB$A_USE_FILES			     |BASE OF 1ST FILE ENTRY
!	 |---------------------------------------------------|
!	 |		      .				     |
!	 |		      .  FILE SPECIFIC GLOBAL USE    |
!	 |		      .  PROCEDURES IN LOCAL PRGM    |
!	 |		      .			  	     |
!	 |		      .  FILE SPECIFIC LOCAL USE     |
!	 |		      .  PROCEDURES IN LOCAL PRGM    |
!	 |		      .				     |
!	 |		      .  FILE SPECIFIC GLOBAL USE    |
!	 |		      .  USE ENTRIES DEFINED IN	     |
!	 |		      .  CONTAINING PROGRAM	     |
!	 |		      .				     |
!	 |---------------------------------------------------|
!
!
!  where
!	COB$A_USE_PNC 	- address of perform nest counter for the declaring
!			  program.
!	COB$A_USE_MODES	- Base of the OPEN MODE entries.
!	COB$B_USE_COUNT	- Number of file specific USE procedure defined for
!			  this program.  This includes both local and global
!			  file specific procedures defined both in this program
!			  and in containing programs.
!	COB$B_GUSE_COUNT- Number of file specific global USE procedures defined
!			  in the local program.
!	COB$A_USE_FILES	- Base of first file entry.
!-

!+
! The structure of the USE entries appears as follows:
!
!
!
!	  ------------------------------------------------------
!	0|		COB$A_USE_PROC				|
!	 |------------------------------------------------------|
!	1|		COB$A_USE_EOPR				|
!	 |------------------------------------------------------|
!	2|		COB$A_USE_RAB				|
!	 |______________________________________________________|
!
!  where
!	COB$A_USE_PROC	-  Address of the USE procedure.
!	COB$A_USE_EOPR	-  Address of end of perform range block.
!			   It is a pointer to the end of perform 
!			   range block for the USE procedure if
!			   the entry was defined in this program
!			   or 0 if it was defined in a containing
!			   program.
!	COB$A_USE_RAB	-  Address of RAB (only in file entries).
!-

    BEGIN
    MAP
	FLAGS:		BLOCK[,BYTE],		! I/O statement and error type
	RAB:		REF BLOCK[,BYTE];	! Address of RAB


    LOCAL
	FAB:		REF BLOCK[,BYTE],	! Address of FAB
	NAM:		REF BLOCK[,BYTE],	! Address of NAM block-used to
						! communicate optional filename
						! related information.
	TABLE:		REF BLOCK[,BYTE],	! Pointer to status decode table entry
	RMS_STS,				! STS value from FAB or RAB
	RMS_STV,				! STV value from FAB or RAB
	FILESTAT,				! COBOL file status
	ACTION,					! Recovery action
	SFP:		REF BLOCK[,BYTE],	! Saved FP
	USE:		REF BLOCK[,BYTE],	! Pointer to USE list
	USEENT:		REF BLOCK[,BYTE],	! Pointer to USE list entry
	ERR_MSG_NUM,				! Longword COB$ error number
	FILE_ADDR,				! Stored entry point to file specific USE procedure
	OPEN_MD_ADDR,				! Stored entry point to open mode specific USE procedure
	RSADESC:	VECTOR[2];		! Descriptor for RSA (resultant string area)

    BUILTIN
	ACTUALCOUNT,
	FP;

    MAP
	FP:	REF BLOCK[,BYTE];




    !+
    ! Ensure that the FLAGS and RAB arguments are present.
    !-

    IF ACTUALCOUNT() LSS 2 				!\Error if FLAGS and RAB
      THEN 						!/arguments are missing
	BEGIN
	SIGNAL_STOP(OTS$_FATINTERR);
	RETURN 0;
	END;
    IF .RAB EQL 0 
      THEN 
	BEGIN
	SIGNAL_STOP(OTS$_FATINTERR);			! Error if RAB addr = 0
	RETURN 0;
	END;
    FAB = .RAB[RAB$L_FAB];				! Fetch FAB address
    IF .FAB EQL 0 
      THEN 
	BEGIN
	SIGNAL_STOP(OTS$_FATINTERR);			! Error if FAB addr = 0
	RETURN 0;
	END;
    NAM = .FAB[FAB$L_NAM];				! Fetch addr of NAM block
    IF .NAM EQL 0 
      THEN 
	BEGIN
	SIGNAL_STOP(OTS$_FATINTERR);			! Error if addr of NAM block = 0
	RETURN 0;
	END;

!+
! Initialize the temporary storage to be used later
! when searching for a USE procedure.
!-

	FILE_ADDR = 0;
	OPEN_MD_ADDR = 0;

!+
! Fetch the address and length of the resultant string area
! as defined in the NAM block.  If the length field is zero,
! then fetch the extended string length field.  If that too
! is a zero length, then just use the FAB file name string
! name and string length.
!-- 

    RSADESC[1] = .NAM[NAM$L_RSA];			! Fetch addr of resultant string area
    RSADESC[0] = .NAM[NAM$B_RSL];			! Fetch resultant string size
    IF .RSADESC[0] EQL 0 
      THEN 
	RSADESC[0] = .NAM[NAM$B_ESL];			! Fetch extended string length
    IF .RSADESC[0] EQL 0
      THEN
	BEGIN
	RSADESC[0] = .FAB[FAB$B_FNS];			! Fetch file name string size

      !+
      ! Copy the string found in the FAB into the resultant
      ! string area.  By doing this, COBOL will just map a special
      ! register to this area for obtaining the resultant name
      ! string.
      !-

	CH$MOVE (.FAB[FAB$B_FNS],.FAB[FAB$L_FNA],.NAM[NAM$L_RSA]);
	END;


    !+
    ! Case on the error type.  Note that COB$K_EXC_MINM
    ! and COB$K_EXC_MAXM are the minimum (0) and maximum (6)
    ! values to be used for case statements involving error
    ! types.
    !-

    CASE .FLAGS[COB$W_EXC_ERROR] FROM COB$K_EXC_MINM TO COB$K_EXC_MAXM OF
      SET

	[OUTRANGE]:					! Invalid value
	    BEGIN
	    SIGNAL_STOP(COB$_INVARG);
	    RETURN 0;
	    END;

	[COB$K_EXC_RAB, COB$K_EXC_FAB]:			! RMS RAB/FAB error
	    BEGIN

	    !+
	    ! RMS error.  Pick up the appropriate STS and STV.
	    !-

	    IF .FLAGS[COB$W_EXC_ERROR] EQL COB$K_EXC_RAB ! Check specifically for RAB error
	      THEN
		BEGIN
		IF .RAB[RAB$L_STS] EQL 0		!\If status of RAB = 0 
		  THEN 					! then signal as a
		    BEGIN				!/fatal internal error.
		    SIGNAL_STOP(OTS$_FATINTERR);
		    RETURN 0;
		    END;
		RMS_STS = .RAB[RAB$L_STS];		! Load status code from RAB
		RMS_STV = .RAB[RAB$L_STV];		! Load status value from RAB
		END

	!+
	! Here we know that we have a FAB error.
	!-

	    ELSE
		BEGIN
		IF .FAB[FAB$L_STS] EQL 0 		!\If status of FAB = 0,
		  THEN 					! then signal a
		    BEGIN				!/fatal internal error.
		    SIGNAL_STOP(OTS$_FATINTERR);
		    RETURN 0;
		    END;
		RMS_STS = .FAB[FAB$L_STS];		! Load status code from FAB
		RMS_STV = .FAB[FAB$L_STV];		! Load status value from FAB
		END;


	    !+
	    ! Map the STS value into the appropriate COBOL file status.
	    !
	    ! First, determine the lookup table to be used from the statement
	    ! type parameter.  Note that this must not be done by indexing a
	    ! table of addresses because of the need for this routine to be
	    ! position-independent.
	    !-

	    IF .RMS_STS
	      THEN
		BEGIN					! Success cases -- are not 
							! found by table look-up.

	!+
	! Perform a CASE on the I/O stmt type.  Note that
	! COB$K_EXC_MINS and COB$K_EXC_MAXS indicate the
	! minimum (1) and maximum (44) values for CASE
	! values for I/O statement types.
	!-

		CASE .FLAGS[COB$W_EXC_STMT]		
		  FROM COB$K_EXC_MINS TO COB$K_EXC_MAXS OF
		    SET
		    [COB$K_EXC_REASS,
		     COB$K_EXC_REARS,
		     COB$K_EXC_REARR,
		     COB$K_EXC_REAIS,
		     COB$K_EXC_REAIR]:
			BEGIN

			!+
			! Successful read, reset NNVR (no next valid
			! record) - meaning EOF has been detected.
			!-

			RAB[COB$V_CTX_NNVR] = 0;
			
			!+
			! If the RMS_STS is for a soft record lock,
			! then the FILESTAT should be set to 90 with
			! an ACTION code of CONTINUE.
			!-

			IF .RMS_STS EQL RMS$_OK_RLK OR .RMS_STS EQL RMS$_OK_RRL
			  THEN
			    BEGIN
			    FILESTAT = '90';
			    ACTION = CONTINUE;
			    END
			  ELSE
			    BEGIN
			    FILESTAT = '00' ;
			    ACTION = SUCCEED ;
			    END;
			END ;  
		    [COB$K_EXC_WRIIS,
		     COB$K_EXC_WRIIR,
		     COB$K_EXC_REWIS,
		     COB$K_EXC_REWIR]:
			BEGIN

			!+
			! Successful write or rewrite on indexed
			! sequential file.
			!-

			IF .RMS_STS EQL RMS$_OK_DUP
			THEN
			    BEGIN
			    FILESTAT = '02' ;
			    ACTION = CONTINUE ;
			    END
			ELSE
			    BEGIN
			    FILESTAT = '00' ;
			    ACTION = SUCCEED ;
			    END
			END ;  
		    [INRANGE, OUTRANGE]:		! Unexpected success code
			BEGIN 
			SIGNAL_STOP (COB$_INVARG) ;	!\Signal an error due to
			RETURN 0;			!/invalid success code
			END;
		    TES ;
		END  		

	!+
	! This section of code deals with the error cases for RMS
	! RAB/FAB errors, where we know that the LSB of RMS_STS 
	! (status code) is zero.
	!-

	    ELSE
		BEGIN		

		!+
		! Perform a CASE on I/O statement type.  Note that
		! COB$K_EXC_MINS and COB$K_EXC_MAXS refers to the
		! minimum (1) and maximum (44) CASE values that
		! pertain to I/O statement types.
		!-
		IF  BEGIN
		    IF (.FLAGS[COB$W_EXC_STMT] LSS COB$K_EXC_MINS OR
			.FLAGS[COB$W_EXC_STMT] GTR COB$K_EXC_MAXS)
		    THEN
			1
		    ELSE
			(TABLE = .PLIT_TABLE[.FLAGS[COB$W_EXC_STMT]]) LSS 0
		    END
		THEN
		    BEGIN				! Invalid error code
		    SIGNAL_STOP(COB$_INVARG);
		    RETURN 0;
		    END;

		!+
		! Depending on the type of error that was found,
		! load the appropriate table addresses into "TABLE"
		! which is the pointer to the status decode table
		! entry.
		!-
		TABLE = BASE + .TABLE;

		!+
		! Find the appropriate entry.  Since every table ends with a 0
		! there must be one.  Note that [TAB_STATUS] will contain a
		! RMS status code or a zero.
		!-

		UNTIL
		    (.TABLE[TAB_STATUS] EQL 0 OR .TABLE[TAB_STATUS] EQL .RMS_STS)
		AND

		    !+
		    ! If the test-state field of this entry is non-zero,
		    ! we must perform a further check to determine if the
		    ! entry we have selected is the one we want.  If the
		    ! variable indicated by the test-state setting is not
		    ! set, we advance the table pointer to the next entry.
		    !-

		    (CASE .TABLE[TAB_TST_STATE] FROM MIN_STATE TO MAX_STATE OF
		      SET
			[NULL]:				! No special action
			  1;
			[OPTF]:				! If set, then an optional file 
			  .RAB[COB$V_CTX_OPT];
			[OFNP]:				!\If set, then optional 
			  .RAB[COB$V_CTX_OFNF];		!/file not present
			[NNVR]:				!\If set, then no next 
			  .RAB[COB$V_CTX_NNVR];		!/valid record (EOF detected)
		      TES)
		DO

		!+
		! Incr the address of the table to point to the
		! next table entry if the TAB_TST_STATE field of
		! the entry was not set.
		!-

		    BEGIN
		    TABLE = .TABLE + TAB_S_ENTRY;
		    END;

		!+
		! Extract the file status code, action code and
		! error message number for this error situation.
		!-

		FILESTAT = .TABLE[TAB_FILESTAT];	! Load COBOL file status	
		ACTION = .TABLE[TAB_ACTION];	    	! Load type of recovery action
		ERR_MSG_NUM = (.TABLE[TAB_ERR_NO]^3) + COB$_NO_USEPRO;


		!+
		! Check to see if we need to set some state bit in
		! conjunction with this error situation -- signaled
		! by a non-zero entry in .TABLE[TAB_SET_STATE]
		!-

		CASE .TABLE[TAB_SET_STATE] FROM MIN_STATE TO MAX_STATE OF
		    SET
		    [NULL]:				! Null clause	
			0;
		    [OPTF]:				! Null clause	
			0;
		    [OFNP]:				!\Set state in COBOL file
			RAB[COB$V_CTX_OFNF] = 1 ;	! context area indicating
							!/optional file not present
		    [NNVR]:				!\Set state in COBOL file	
			RAB[COB$V_CTX_NNVR] = 1 ;	! context area indicating
							!/NNVR (EOF detected).
		    TES;
		END;	

	    END;	

	!+
	! Additional error types.
	!-

	[COB$K_EXC_FLK]:
	    BEGIN

	    !+
	    ! Compiled code detected an OPEN directed to a file closed
	    ! WITH LOCK.
	    !-

	    ERR_MSG_NUM = COB$_FILCLOLOC ;
	    RMS_STS = 0;				!\Init RMS status code and
	    RMS_STV = 0;				!/status value from FAB/RAB to zero
	    FILESTAT = '94';
	    ACTION = ABORT;
	    RAB[RAB$L_STS] = .ERR_MSG_NUM;
	    RAB[RAB$L_STV] = 0;
	    END;


	[COB$K_EXC_OPN]:
	    BEGIN

	    !+
	    ! Compiled code detected an OPEN directed to a file
	    ! already open.
	    !-

	    ERR_MSG_NUM = COB$_FILALROPE ;
	    RMS_STS = 0;				!\Set RMS status code and
	    RMS_STV = 0;				!/status value from FAB/RAB to zero
	    FILESTAT = '94';
	    ACTION = ABORT;
	    RAB[RAB$L_STS] = .ERR_MSG_NUM;
	    RAB[RAB$L_STV] = 0;
	    END;

	[COB$K_EXC_ORG]:
	    BEGIN

	    !+
	    ! Compiled code detected an OPEN to a file whose organization
	    ! does not match the access mode specified in OPEN
	    !-

	    ERR_MSG_NUM = COB$_ORGNOTMAT ;
	    RMS_STS = 0;				!\Set RMS status code and
	    RMS_STV = 0;				!/status value from FAB/RAB to zero
	    FILESTAT = '94';
	    ACTION = ABORT;
	    RAB[RAB$L_STS] = .ERR_MSG_NUM;
	    RAB[RAB$L_STV] = 0;
	    END;


	[COB$K_EXC_MIN]:
	    BEGIN

	    !+
	    ! Compiled code detected an operation on a variable length record that
	    ! is smaller than the minimum allowed.
	    !-

	    !+
	    ! Determine the I/O statement type that failed and select
	    ! the appropriate message.  Note that COB$K_EXC_MINS and
	    ! COB$K_EXC_MAXS refer to the minimum (1) and maximum (44)
	    ! CASE values for I/O statement types.
	    !-

	    CASE .FLAGS[COB$W_EXC_STMT]
		FROM COB$K_EXC_MINS TO COB$K_EXC_MAXS OF
		SET

		!+
		! Class of read errors, varying in file organization
		! and access type.  For this type of I/O error, return
		! an error message signifying attempting a read of 
		! variable length smaller than the minimum allowed.
		!-

		[COB$K_EXC_REASS,
		 COB$K_EXC_REARS,
		 COB$K_EXC_REARR,
		 COB$K_EXC_REAIS,
		 COB$K_EXC_REAIR]:
		    ERR_MSG_NUM = COB$_REASMAMIN ;

		!+
		! Class of write errors, varying in file organization
		! and access type.  For this type of I/O error, return
		! an error message signifying attempting a write of
		! variable length smaller than the minimum allowed.
		!-

		[COB$K_EXC_WRISS,
		 COB$K_EXC_WRIRS,
		 COB$K_EXC_WRIRR,
		 COB$K_EXC_WRIIS,
		 COB$K_EXC_WRIIR]:
		    ERR_MSG_NUM = COB$_WRISMAMIN ;

		!+
		! Class of re-write errors, varying in file organization
		! and access type.  For this type of I/O error, return
		! an error message signifying attempting a re-write of
		! variable length smaller than the minimum allowed.
		!-

		[COB$K_EXC_REWSS,
		 COB$K_EXC_REWRS,
		 COB$K_EXC_REWRR,
		 COB$K_EXC_REWIS,
		 COB$K_EXC_REWIR]:
		    ERR_MSG_NUM = COB$_REWSMAMIN ;

		[INRANGE]:			! Invalid error statement
		    BEGIN
		    SIGNAL_STOP (COB$_INVARG) ;
		    RETURN 0;
		    END;
		TES;

	    RMS_STS = 0;				!\Set RMS status code and
	    RMS_STV = 0;				!/status value from FAB/RAB to zero
	    FILESTAT = '94';
	    ACTION = ABORT;
	    RAB[RAB$L_STS] = .ERR_MSG_NUM;
	    RAB[RAB$L_STV] = 0;
	    END;


	[COB$K_EXC_KEY]:
	    BEGIN

	    !+
	    ! Compiled code detected an OPEN of an indexed file with keys
	    ! that do not match those described by the program.
	    !-

	    ERR_MSG_NUM = COB$_KEYNOTMAT ;
	    RMS_STS = 0;				!\Set RMS status code and
	    RMS_STV = 0;				!/status value from FAB/RAB to zero
	    FILESTAT = '94';
	    ACTION = ABORT;
	    RAB[RAB$L_STS] = .ERR_MSG_NUM;
	    RAB[RAB$L_STV] = 0;
	    END;


	TES;    					! End of case on error type


!+
!	At this point in the code, the following have been
!	computed:
!
!		RMS_STS		-- RMS status extracted from FAB/RAB
!
!		RMS_STV		-- Extended RMS status extracted from
!				   FAB/RAB
!
!		FILESTAT	-- COBOL file status to be returned to
!				   caller via optional argument.
!
!		ACTION		-- Subsequent action
!				   Possible settings are:
!					ABORT
!					GOTO
!					CONTINUE
!					SUCCEED
!				   (See definitions in LITERAL
!				    declarations)
!
!		ERR_MSG_NUM	-- COB$ facility error condition code
!				   to be signalled if there is no USE
!				   procedure available.
!-


    !+
    ! Store the COBOL file status if appropriate.
    ! Note that "STATUS" is an optional input parameter
    ! that is used to return the COBOL file status to
    ! the caller.
    !-

    IF ACTUALCOUNT() GEQ 4 THEN IF .STATUS NEQ 0
      THEN
	(.STATUS)<0,16> = .FILESTAT;


    !+
    ! If the error is one that requires transfer to the exception label and
    ! it is present, go there by replacing the return PC in the stack
    ! frame with the exception PC and executing a return.
    !-

    IF .ACTION EQL GOTO THEN IF ACTUALCOUNT() GEQ 3 THEN IF .EXCLAB NEQ 0
      THEN
	BEGIN
	FP[SF$L_SAVE_PC] = .EXCLAB;
	RETURN 0;
	END;

    !+
    ! If the action is SUCCEED, return to the I/O statement.
    !-

    IF .ACTION EQL SUCCEED
      THEN
	RETURN 1;

    !+
    ! Search for an appropriate USE procedure.
    !-

    SFP = .FP[SF$L_SAVE_FP];				! Get saved FP
    IF .SFP EQL 0					!\If frame pointer is
      THEN						! zero, then we have
	BEGIN						!/serious problems		
	SIGNAL_STOP (OTS$_FATINTERR);	
	RETURN 0;
	END
      ELSE
	    BEGIN
	    USE = .SFP[COB$A_SF_USE];			! Get USE list
	    IF .USE NEQ 0				! If any DECLARATIVES
	      THEN
		BEGIN

		!+
		! Search for a USE procedure declared for the specific file
		! on which the exception occurred.  It is identified by the
		! RAB address.
		!-

		USEENT = USE[COB$A_USE_FILES];		! Point to first
		DECR I FROM .USE[COB$B_USE_COUNT]-1 TO 0 DO ! Count of file entries
		    BEGIN				! Loop over files
		    IF .USEENT[COB$A_USE_RAB] EQLA .RAB	! Right file? (find matching RAB addrs)
		      THEN
			BEGIN

		!+
		! The EOPR value will be non-zero if the perform
		! range is in the current level of the code.  If
		! the EOPR is zero, then the USE procedure can't
		! be seen in the contained program environment, and
		! therefore, an error must be signalled.  Note that
		! the USE procedure may be found, since it is possible
		! that the USE procedure was in a different level of
		! code (an up-level reference).  If this were the case,
		! then this would be resolved in COB$HANDLER (or a
		! user-defined handler).
		!-

    			IF .USEENT[COB$A_USE_EOPR] NEQ 0 !Check addr of end of 
							 !perform range block
    			  THEN
			    BEGIN
			    COB$$INVOKE_USE(		!\Invoke USE procedure;
							!/USE proc is at current level
				.USEENT[COB$A_USE_PROC],! Addr of USE procedure
				.USE,
				.FP[SF$L_SAVE_AP],
				.USEENT[COB$A_USE_EOPR],
				.USE[COB$A_USE_PNC]);
			    IF .ACTION EQL CONTINUE
			      THEN
				RETURN 1
			      ELSE
				RETURN 0;
			    END
    			  ELSE

			!+
			! Save the address of the file specific USE
			! procedure for later call to SIGNAL.
			!-
				
			    FILE_ADDR = .USEENT[COB$A_USE_PROC];
			END;
		    USEENT = .USEENT + COB$S_USE_FILES;	! Step to next entry
		    END;


		!+
		! Fall into this section of code since no entry for the
		! specific file was found.  See if a USE procedure has been
		! declared for the open mode.  Note that the open mode
		! entries are INPUT, OUTPUT, I-O and EXTEND with corresponding
		! values of 0,1,2,3.  Also note that the field reference of
		! [COB$B_CTX_MODE] refers to the open mode entry field.
		!-

		IF .RAB[COB$B_CTX_MODE] GTRU COB$K_CTX_MAX 
		  THEN 
		    BEGIN
		    SIGNAL_STOP(COB$_INVARG);
		    RETURN 0;
		    END;
		USEENT = USE[COB$A_USE_MODES] + COB$S_USE_MODES*.RAB[COB$B_CTX_MODE];
		IF .USEENT[COB$A_USE_PROC] NEQA 0	! USE declared?
		  THEN
		    BEGIN

		!+
		! Check address of the End of Perform Range Block -
		! if non-zero, then invoke the USE procedure.  Note
		! that EOPR if non-zero, indicates that the USE procedure
		! can be invoked immediately since it is in the current
		! level of code.  Otherwise, an EOPR of zero indicates
		! that the USE procedure can't be found, which causes
		! an error to be signalled.  Note that the USE procedure
		! may be found, since it is possible that the USE procedure
		! was in a different level (an up-level reference).  This
		! would get resolved in COB$HANDLER (or a user-defined
		! handler).
		!-

    			IF .USEENT[COB$A_USE_EOPR] NEQ 0
    			  THEN
			    BEGIN
			    COB$$INVOKE_USE(			! Invoke USE
				.USEENT[COB$A_USE_PROC],	! Addr of USE procedure
				.USE,
				.FP[SF$L_SAVE_AP],
				.USEENT[COB$A_USE_EOPR],
				.USE[COB$A_USE_PNC]);
			    IF .ACTION EQL CONTINUE
			      THEN
				RETURN 1
			      ELSE
				RETURN 0;
			    END
    			  ELSE

			!+
			! Save the address of the open mode USE
			! procedure for later call to SIGNAL.
			!-
					
			    OPEN_MD_ADDR = .USEENT[COB$A_USE_PROC];
		    END;

		!+
		! Note that the error that is signalled is
		! "Lost handler for USE procedure - environment
		! corrupted" so that if a USE procedure isn't found, 
		! then this message would appear at the user
		! level.
		!-

		IF .FILE_ADDR NEQ 0 OR .OPEN_MD_ADDR NEQ 0
		  THEN
		    BEGIN
		    SIGNAL (COB$_LSTHNDUSE,2,.FILE_ADDR,.OPEN_MD_ADDR);
		    IF .ACTION EQL CONTINUE 
		      THEN 
		        RETURN 1
  		      ELSE 
		        RETURN 0 ; 				! All done; assume ABORT case
		    END;
		END;
	    END;

    !+
    ! Return a 1 for CONTINUE action if a USE procedure
    ! has not been found.
    !-

    IF .ACTION EQL CONTINUE 					
      THEN 
	RETURN 1; 			

    !+
    ! Signal the error, since no USE procedure was applicable.
    ! (GOTO with no exception label and ABORT cases)
    !-

    SIGNAL_STOP(
		    .ERR_MSG_NUM, 1, RSADESC,
		    .RMS_STS,
		    .RMS_STV);

    RETURN 0   							! Never gets here...
    END;

END ELUDOM
