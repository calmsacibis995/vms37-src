	.TITLE	LIB$SIM_TRAP - Simulate floating trap
	.IDENT	/1-003/			; File: LIBSIMTRA.MAR  Edit: SBL1003

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: General Utility Library
;
; ABSTRACT:
;
;	LIB$SIM_TRAP is a routine which converts floating faults
;	to floating traps.  It is designed to be enabled as a
;	condition handler or to be called by one.
;
; ENVIRONMENT: User Mode, AST Reentrant
;
;--
; AUTHOR: Derek Zave, CREATION DATE: 6-Dec-1979
;

	.SBTTL	Edit History

; 1-001 - Original.  6-Dec-1979
; 1-002 - Remove restriction that stack frames must be in P1 space.
;	  SBL 22-May-1980
; 1-003 - Change to using SYS$SRCHANDLER mechanism to look for handlers.
;	  SBL 19-August-1981

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; EXTERNAL DECLARATIONS:
;
	.DSABL	GBL				; Prevent undeclared
						; symbols from being
						; automatically global.
	.EXTRN	SYS$CALL_HANDL		; System routine that calls handlers
	.EXTRN	SYS$SRCHANDLER		; System routine that looks for handlers
	.EXTRN	SYS$UNWIND		; $UNWIND system service

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

;
; PSECT DECLARATIONS:
;
	.PSECT _LIB$CODE PIC, USR, CON, REL, LCL, SHR, -
			EXE, RD, NOWRT, LONG


	.SBTTL	LIB$SIM_TRAP - Convert Floating Faults to Traps
;++
; FUNCTIONAL DESCRIPTION:
;
;	    This routine functions as a condition handler which intercepts
;	floating overflow, floating underflow, and floating divide by zero
;	faults. When these conditions are detected, the routine simulates the
;	instruction causing the condition up to the point where a trap should
;	be signaled and signals the corresponding floating trap.
;
;
;	Introduction
;	------------
;
;	    With Revision 5 of the VAX System Reference Manual, incompatible
;	changes were made to the VAX architecture in regard to the exceptions
;	that may occur in connection with floating arithmetic operations.
;	The exceptions generated by floating underflow, floating overflow,
;	and floating divide by zero were changed from traps to faults and new
;	hardware vectors were defined for the new faults. In VMS new condition
;	codes were defined which correspond to the new hardware-defined
;	conditions. Since fault exceptions always leave the enviroment in such
;	a state that the faulted instruction can be restarted, it is possible,
;	in principle, to "convert" one of the new exceptions to the exception
;	it corresponds to under the earlier VAX architecture.
;
;	    The routine LIB$SIM_TRAP has been developed to provide a generally
;	usable facility for converting the new floating faults to the earlier
;	floating traps so that existing code for handling floating exceptions
;	will still work. The routine may be used as a condition handler or it
;	may be called by a condition handler (perhaps with intermediate
;	procedure calls) to examine a signaled condition. When one of the new
;	floating faults occurs, the routine "shuts down" the current condition
;	handling operation, performs any necessary changes to the enviroment,
;	and signals the trap condition.
;
;	    No effort has been spared to make the traps look exactly like
;	those generated by the hardware and intercepted by the operating
;	system. Particular attention has been paid to the problems of
;	dealing with floating underflow exceptions for the POLYx instructions
;	which require resuming the instruction.
;
;
;	Operation of the Fault to Trap Conversion
;	-----------------------------------------
;
;	    LIB$SIM_TRAP is concerned with instructions which can cause any
;	of the following three exceptions under the revised VAX architecture:
;
;		SS$_FLTUND_F	floating underflow fault
;		SS$_FLTDIV_F	floating divide by zero fault
;		SS$_FLTOVF_F	floating overflow fault
;
;	When detected these faults will be converted to the following
;	corresponding traps:
;
;		SS$_FLTUND	floating underflow trap
;		SS$_FLTDIV	floating/decimal divide by zero trap
;		SS$_FLTOVF	floating overflow trap
;
;	In the course of performing the conversion other exceptions may be
;	detected and signaled instead. The possible exceptions are
;
;		SS$_ACCVIO	access violation fault
;		SS$_ROPRAND	reserved operand fault
;
;	in addition to the above three traps.
;
;	    The instructions which can cause the three faults which are
;	recognize are listed below.
;
;
;		ACBD	add compare and branch D_floating
;		ACBF	add compare and branch F_floating
;		ACBG	add compare and branch G_floating
;		ACBH	add compare and branch H_floating
;		ADDD2	add D_floating (two operands)
;		ADDD3	add D_floating (three operands)
;		ADDF2	add F_floating (two operands)
;		ADDF3	add D_floating (three operands)
;		ADDG2	add G_floating (two operands)
;		ADDG3	add G_floating (three operands)
;		ADDH2	add H_floating (two operands)
;		ADDH3	add H_floating (three operands)
;		CVTDF	convert D_floating to F_floating
;		CVTGF	convert G_floating to F_floating
;		CVTHD	convert H_floating to D_floating
;		CVTHF	convert H_floating to F_floating
;		CVTHG	convert H_floating to G_floating
;		DIVD2	divide D_floating (two operands)
;		DIVD3	divide D_floating (three operands)
;		DIVF2	divide F_floating (two operands)
;		DIVF3	divide F_floating (three operands)
;		DIVG2	divide G_floating (two operands)
;		DIVG3	divide G_floating (three operands)
;		DIVH2	divide H_floating (two operands)
;		DIVH3	divide H_floating (three operands)
;		EMODD	extended modulus D_floating
;		EMODF	extended modulus F_floating
;		EMODG	extended modulus G_floating
;		EMODH	extended modulus H_floating
;		MULD2	multiply D_floating (two operands)
;		MULD3	multiply D_floating (three operands)
;		MULF2	multiply F_floating (two operands)
;		MULF3	multiply F_floating (three operands)
;		MULG2	multiply G_floating (two operands)
;		MULG3	multiply G_floating (three operands)
;		MULH2	multiply H_floating (two operands)
;		MULH3	multiply H_floating (three operands)
;		POLYD	evaluate polynomial D_floating
;		POLYF	evaluate polynomial F_floating
;		POLYG	evaluate polynomial G_floating
;		POLYH	evaluate polynomial H_floating
;		SUBD2	subtract D_floating (two operands)
;		SUBD3	subtract D_floating (three operands)
;		SUBF2	subtract F_floating (two operands)
;		SUBF3	subtract F_floating (three operands)
;		SUBG2	subtract G_floating (two operands)
;		SUBG3	subtract G_floating (three operands)
;		SUBH2	subtract H_floating (two operands)
;		SUBH3	subtract H_floating (three operands)
;
;
;	    The conversion of faults to traps is performed as follows: First
;	the instruction operands are scanned and any increments or decrements
;	of the registers required by the operand specifiers is performed.
;	Also, the operands or operand locations are determined during this
;	scan. For all of the faults, a value of zero is stored for written
;	integer operands. For floating underflow, a zero value is also stored
;	for each written floating operand. For floating overflow and floating
;	divide by zero, a reserved floating value which is zero except for a
;	sign bit of one is stored for each floating written operand. The
;	condition codes are set to describe the last result stored. Finally,
;	the trap condition corresponding to the fault is signaled.
;
;	    There are some minor exceptions to the above outline. For the
;	ACBx instructions, the carry bit in the condition code is preserved
;	and the routine determines whether or not the branch should be taken.
;	For the POLYx instructions, things are a bit more complicated. For
;	a floating overflow a reserved operand is stored in the register or
;	registers intended to hold the result, the condition codes are set
;	to describe it, and the trap is signaled. For floating underflow,
;	however, the result so far is cleared and the instruction is resumed
;	and run to completion if possible. If the instruction is completed,
;	then the underflow trap is signaled. However, an overflow, access
;	violation, or a reserved operand fault, may occur (the last two
;	originating from problems with the table of coefficients). If an
;	overflow occurs, the condition will be treated as if the underflow
;	had never occured. If an access violation or a reserved operand fault
;	occurs, then the fault will be signaled exactly as described by the
;	architecture with the FPD bit set in the PSL so the instruction can
;	be resumed.
;
;	    Since the routine LIB$SIM_TRAP "dissolves" the condition handling
;	for the original fault condition, the final condition signaled by the
;	routine will be from the context of the instruction itself rather than
;	from that of the condition handler so the signaling path will be
;	identical to that for a hardware generated trap. The signal array will
;	be correctly placed so that the end of this table will be the user's
;	stack pointer at the completion of the instruction (for traps) or
;	at the beginning of the instruction (for faults).
;
;
;	Differences from the Hardware
;	-----------------------------
;
;	    Below is what is believed to be a complete list of differences
;	between LIB$SIM_TRAP and the hardware that are in any way detectable
;	by the user. We have not included differences which are related to
;	whether or not the converter is being used rather than to the 
;	operation of the converter itself.
;
;	     1. The simulation of the instruction from the fault up to the
;		point where the trap is signaled takes much longer than the
;		hardware.
;
;	     2. The simulation of the instruction from the fault up to the
;		point where the trap is signaled is performed by software so
;		it is interruptable. Because of this an AST which becomes
;		active while the simulation is taking place may find the
;		actions of the instruction only partially completed.
;
;	     3. When fault to trap conversion takes place, the converter
;		garbages the area below the user's stack pointer. This area
;		is used to simulate a portion of the user's stack as well as
;		for local storage for the converter itself. The converter
;		protects itself from stores into its working storage in such
;		a way that it appears that the results of the stores were
;		garbaged after the store.
;
;	     4. When the converter is active, there is an extra procedure
;		frame on the stack. This might come as an unexpected suprise
;		to an AST that becomes active while the converter is running.
;
;	     5. When the converter signals faults and traps there may be some
;		differences in the undocumented aspects of the blocks that are
;		pushed onto the stack for signaling.		
;
;
;	Notes on this Version of LIB$SIM_TRAP
;	------------------------------------
;
;	     The following notes apply to this version of LIB$SIM_TRAP and may
;	change in subsequent versions.
;
;	     1. This version was completed in a hurry and is not fully tested.
;		All of the mechanisms and paths have been tested but not 
;		enough examples have been tried to expose interaction bugs.
;
;	     2. In order to implement the converter with only a modest amount
;		of effort the following assumptions were made about the
;		architecture. These assumptions are not clearly justified by
;		Revision 5 of the SRM but Dileep Bhandarkar tells me that 
;		these points will be clarified in future version of the SRM.
;		Curiously both of these points involve the POLYx instructions.
;
;		     A. It is assumed that when a POLYx instruction causes
;			and underflow or overflow fault, that the instruction
;			will be suspended with the FPD bit set in the PSL.
;			The SRM accurately describes the suspended state but
;			makes no guarantees as to when the state is ever 
;			reached.
;
;		     B. It is assumed that when a POLYx instruction has been
;			suspended that the user has unlimited lisence to 
;			change the result so far, the argument, the number
;			of remaining coefficients, and the location of the
;			next coefficient, but not the implementation specific
;			information. The number of remaining coefficients can
;			not be changed to a reserved value or zero. These 
;			assumptions imply that the implementation specific
;			information does not depend on these quantities.
;
;	     3. There is no version of the architecture which specifies that
;		traps occur for floating arithmetic exceptions generated by
;		the G-format and H-format instructions. Nevertheless, the
;		converter performs such a conversion since it that the primary
;		reason for this converter is to allow user's to continue to
;		use their old exception handling routines.
;
;	     4. The converter does not check for a stack overflow while it is
;		running. Because of the automatic stack expansion feature in
;		Release 2 VMS this should not be a problem. If the user nails
;		his own stack pointer during the simulation (the only values
;		that can be stored into it are zero and 2^15), then a reserved
;		operand exception will occur when the converter tries to
;		return.
;
;	     5. The converter interacts smoothly with the Debugger.
;
;	     6. The converter is read-only and PIC so there should be no
;		difficulty in incorporating it into any program.
;
;
;	How to Install Floating Trap Simulation
;	---------------------------------------
;
;	    In order to insure that the new floating faults are converted to
;	the old traps, the routine LIB$SIM_TRAP must be used as a condition
;	handler or must be called from a condition handler. If it is used as
;	a condition handler it must be positioned so that is will be notified
;	about conditions generated by the code in question. This will be the
;	case if it is the primary, secondary, or last chance condition
;	handler. If it is installed as the condition handler for some routine,
;	then that routine must be one which executes the instructions which
;	will cause the condition either directly or through a chain of
;	intermediate procedure calls. If the routine LIB$SIM_TRAP is to be
;	called by a condition handler, then that condition handler must have
;	the properties described above. Condition handlers which "cover" the
;	entire program may be set up using the LIB$INITIALIZE facility
;	described in Appendix E of the Common RTL Reference Manual.
;
;	    When LIB$SIM_TRAP is called from a condition handler the call
;	should have the following form:
;
;			CALL LIB$SIM_TRAP (signal_args_adr,mech_args_adr)
;
;	    However it is called, the routine examines the condition to
;	determine if it is one of the faults that are converted to traps.
;	If it is not then the routine returns with R0 containing the condition
;	code SS$_RESIGNAL. A condition handler which calls LIB$SIM_TRAP should
;	be coded so that it will not leave any loose ends dangling if the call
;	to LIB$SIM_TRAP does not return.
;
;	    If the routine chooses to handle the condition, all of the
;	procedure frames up to and including the handler frame are removed
;	from the stack and the registers are restored in order to recreate the
;	stack and register values at the time of the exception. The conversion
;	is then performed and the resulting condition is signaled. For this
;	reason the resulting condition will be signaled as a new condition and
;	not as a continuation of the original fault condition.
;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*			Assorted Definitions		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Definition Macro Invocations
	;
	$SSDEF				; System Status Codes
	$JPIDEF 			; Job/Process Information Codes
	;
	;	Parameters
	;
CALL_ARGS =	40			; flexible stack space (longwords)
	;
	;	Bits in the Processor Status Longword (PSL)
	;
PSL_C	=	0			; carry indicator
PSL_V	=	1			; overflow indicator
PSL_Z	=	2			; zero indicator
PSL_N	=	3			; negative indicator
PSL_T	=	4			; trace enable indicator
PSL_FU	=	6			; floating underflow fault enable
PSL_CAM =	24			; current access mode
PSL_FPD =	27			; instruction first part done
PSL_TP	=	30			; trace pending indicator
	;
	;	Masks for the Processor Status Longword
	;
PSLM_C	=	1@PSL_C 		; carry indicator
PSLM_V	=	1@PSL_V 		; overflow indicator
PSLM_Z	=	1@PSL_Z 		; zero indicator
PSLM_N	=	1@PSL_N 		; negative indicator
PSLM_NZ =	PSLM_N+PSLM_Z		; reserved floating value condition
PSLM_ZVC =	PSLM_Z+PSLM_V+PSLM_C	; condition bits except for sign
PSLM_NZVC =	PSLM_N+PSLM_ZVC 	; condition bits
	;
	;	Call Frame Layout
	;
HANDLER =	0			; condition handler location
SAVE_PSW =	4			; save processor status word
SAVE_MASK =	6			; register save mask
MASK_ALIGN =	14			; bit position of alignment bits
SAVE_AP =	8			; user's argument pointer
SAVE_FP =	12			; user's frame pointer
SAVE_PC =	16			; return point
REG_R0	=	20			; user's R0
REG_R1	=	24			; user's R1
REG_R2	=	28			; user's R2
REG_R3	=	32			; user's R3
REG_R4	=	36			; user's R4
REG_R5	=	40			; user's R5
REG_R6	=	44			; user's R6
REG_R7	=	48			; user's R7
REG_R8	=	52			; user's R8
REG_R9	=	56			; user's R9
REG_R10 =	60			; user's R10
REG_R11 =	64			; user's R11
FRAME_END =	68			; end of call frame
	;
	;	Call Frame Extension Layout
	;
REG_AP	=	68			; user's AP
REG_FP	=	72			; user's FP
REG_SP	=	76			; user's SP
REG_PC	=	80			; user's PC
PSL	=	84			; user's PSL
LOCAL_END =	88			; end of local storage
	;
	;	Local Storage Layout
	;
SAVE_ALIGN =	HANDLER-1		; safe copy of alignment bits
CARRY_BIT =	SAVE_ALIGN-1		; original setting of carry bit
FAULT_TYPE =	CARRY_BIT-1		; internal code for type of fault
ACTION_COUNT =	FAULT_TYPE-1		; number of action bytes remaining
ACCVIO_REASON = ACTION_COUNT-1		; reason mask for access violation
UNUSED_BYTE_1 = ACCVIO_REASON-1 	; unused byte
UNUSED_BYTE_2 = UNUSED_BYTE_1-1 	; unused byte
UNUSED_BYTE_3 = UNUSED_BYTE_2-1 	; unused byte
ACTION_PTR =	UNUSED_BYTE_3-4 	; pointer to current action byte
INST_ADDRESS  = ACTION_PTR-4		; instruction location
BRANCH_ADDRESS = INST_ADDRESS-4 	; branch destination address
ACCVIO_ADDRESS = BRANCH_ADDRESS-4	; access violation referenced address
READ_AREA =	ACCVIO_ADDRESS-36	; area for input operand values
WRITE_AREA =	READ_AREA-36		; area for output operand values
LOCAL_START =	WRITE_AREA		; start of local storage
	;
	;	Interpretive Action Codes
	;
READ_ACCESS =	1			; read only access operand
WRITE_ACCESS =	2			; write only access operand
MODIFY_ACCESS = 3			; modify access operand
ADDRESS_ACCESS = 4			; address access operand
BRANCH_WORD =	5			; branch destination operand
POLY_CHECK =	6			; POLYx post instruction checking
ACB_CHECK =	7			; ACBx post instruction checking
	;
	;	Data Type Codes
	;
FLOAT_TYPE =	1			; single floating
DOUBLE_TYPE =	2			; double floating
GRAND_TYPE =	3			; grand floating
HUGE_TYPE =	4			; huge floating
BYTE_TYPE =	5			; byte
WORD_TYPE =	6			; word
LONG_TYPE =	7			; longword
	;
	;	Derived Codes
	;
READ_FLOAT =	<FLOAT_TYPE@4>+READ_ACCESS
READ_DOUBLE =	<DOUBLE_TYPE@4>+READ_ACCESS
READ_GRAND =	<GRAND_TYPE@4>+READ_ACCESS
READ_HUGE =	<HUGE_TYPE@4>+READ_ACCESS
READ_BYTE =	<BYTE_TYPE@4>+READ_ACCESS
READ_WORD =	<WORD_TYPE@4>+READ_ACCESS
WRITE_FLOAT =	<FLOAT_TYPE@4>+WRITE_ACCESS
WRITE_DOUBLE =	<DOUBLE_TYPE@4>+WRITE_ACCESS
WRITE_GRAND =	<GRAND_TYPE@4>+WRITE_ACCESS
WRITE_HUGE =	<HUGE_TYPE@4>+WRITE_ACCESS
WRITE_LONG =	<LONG_TYPE@4>+WRITE_ACCESS
MODIFY_FLOAT =	<FLOAT_TYPE@4>+MODIFY_ACCESS
MODIFY_DOUBLE = <DOUBLE_TYPE@4>+MODIFY_ACCESS
MODIFY_GRAND =	<GRAND_TYPE@4>+MODIFY_ACCESS
MODIFY_HUGE =	<HUGE_TYPE@4>+MODIFY_ACCESS
ADDRESS_BYTE =	<BYTE_TYPE@4>+ADDRESS_ACCESS
POLY_FLOAT =	<FLOAT_TYPE@4>+POLY_CHECK
POLY_DOUBLE =	<DOUBLE_TYPE@4>+POLY_CHECK
POLY_GRAND =	<GRAND_TYPE@4>+POLY_CHECK
POLY_HUGE =	<HUGE_TYPE@4>+POLY_CHECK
ACB_FLOAT =	<FLOAT_TYPE@4>+ACB_CHECK
ACB_DOUBLE =	<DOUBLE_TYPE@4>+ACB_CHECK
ACB_GRAND =	<GRAND_TYPE@4>+ACB_CHECK
ACB_HUGE =	<HUGE_TYPE@4>+ACB_CHECK
	;

	;
	;	LIB$SIM_TRAP - Conversion Condition Handler
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;
	;	    This routine is designed to function as a condition
	;	handler or it may be called from a condition handler
	;	(possibly with a chain of intermediate procedure calls)
	;	with the locations of the signal and mechanism array for
	;	the condition supplied as parameters.
	;
	;	    When this routine is called it examines the signal
	;	array to see if the condition was a floating overflow fault,
	;	floating underflow fault, or a floating divide by zero fault.
	;	If the condition is none of these faults, then the routine
	;	returns with the value SS$_RESIGNAL to indicate that it did
	;	not handle the condition.
	;
	;	    If the condition is one of those checked for above, then
	;	the routine examines the procedure frames on the stack up to
	;	the condition handler frame and determines the values of the
	;	registers at the time of the exception. The registers are then
	;	restored and the stack pointer is positioned to the condition
	;	code in the signal array (which is immediatly before the PC,
	;	PSL pair for the detected conditions). The routine then
	;	branches to FAULT_TO_TRAP to initiate the conversion.
	;
	;	Note:	1. The method of removing the procedure frames above
	;		   the condition handler frame is similar to an
	;		   unwind but differs in that the condition handlers
	;		   in the frames are not activated with the SS$_UNWIND
	;		   status. This was done since it appears to be
	;		   impossible to make the handler call look like it
	;		   was made by SYS$UNWIND so that overlaping unwinds
	;		   can be detected.
	;
	.ENTRY	LIB$SIM_TRAP,-		; entrance
		^M<R2,R3>		; entry mask
	MOVL	4(AP),R0		; R0 = signal array location
	MOVL	4(R0),R1		; R1 = condition code
	CMPL	#SS$_FLTUND_F,R1	; floating underflow fault ?
	BEQL	1$			; yes - bypass
	CMPL	#SS$_FLTDIV_F,R1	; floating divide by zero fault ?
	BEQL	1$			; yes - bypass
	CMPL	#SS$_FLTOVF_F,R1	; floating overflow fault ?
	BEQL	1$			; yes - bypass
	MOVZWL	#SS$_RESIGNAL,R0	; R0 = resignal condition code
	RET				; return
1$:	MOVAB	-12(FP),SP		; allocate space for AP, FP, SP
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11> ; save registers R4-R11
	SUBL2	#16,SP			; allocate space for R0, R1, R2, R3
	MOVL	FP,R0			; R0 = current frame pointer
2$:	EXTZV	#0,#12,SAVE_MASK(R0),R1 ; R1 = register save mask
	MOVAB	REG_R0(R0),R2		; R2 = start of registers in R0 frame
	CLRL	R3			; clear the register index
3$:	FFS	R3,#12,R1,R3		; find the next saved register
	BEQL	4$			; no more saved registers - bypass
	MOVL	(R2)+,(SP)[R3]		; get the register value
	INCL	R3			; increment the register number
	BRB	3$			; look some more
4$:	MOVQ	SAVE_AP(R0),48(SP)	; get the values of AP and SP
	CMPL	#SYS$CALL_HANDL+4,SAVE_PC(R0) ; is this the handler frame ?
	BEQL	5$			; yes - bypass
	MOVL	52(SP),R0		; R0 = location of next call frame
	BRB	2$			; unwind the frame
5$:	ADDL3	#4,4(AP),56(SP) 	; point saved SP to condition name
	MOVL	8(AP),R0		; R0 = mechanism array location
	MOVQ	12(R0),(SP)		; get R0 and R1
	POPR	#^M<R0,R1,R2,R3,R4,R5,- ; restore registers R0-SP
		R6,R7,R8,R9,R10,R11,AP,FP,SP> ; with SP pointing to condition
      ; BRB	FAULT_TO_TRAP		; enter the conversion routine
	;

	;
	;	FAULT_TO_TRAP - Perform Fault to Trap Conversion
	;
	;		entered by branching
	;
	;		parameters:	(SP) = Fault Condition Code
	;				4(SP) = Instruction Location
	;				8(SP) = PSL Value
	;
	;	Discussion
	;
	;	    This routine sets up the frame for the fault to trap
	;	conversion routine and initializes everything. The specified
	;	parameters describe the condition that occured and 12(SP) is
	;	assumed to be the user's stack pointer at the time of the
	;	fault. All of the other registers are assumed to be the user's
	;	registers.
	;
	;	    First the stack is extended to CALL_ARGS-3 longwords to
	;	provide the area for simulating the top of the user's stack.
	;	A CALLS instruction is then executed which specifies all of
	;	the CALL_ARGS longwords below the user's stack pointer as
	;	the parameter list. The local storage for the frame is then
	;	allocated and the alignment bits for the frame are saved in
	;	a local storage cell. The condition handler for the routine
	;	is then set up. The CALLS instruction also saves the user's
	;	registers R0,...,R11 in order and saves AP and FP elsewhere
	;	in the frame. The routine then the saved registers by saving
	;	the user's AP, FP, SP, PC, and PSL after the saved registers.
	;	AP and FP are taken from the frame, SP is computed, and PC and
	;	PSL are taken from the parameter list.
	;
	;	    The condition code for the fault is converted to a short
	;	internal code for use in branching and the carry bit in the
	;	user's PSL is saved. The instruction location is stored in the
	;	return PC for the frame so it will be discovered by the
	;	traceback handler if the routine blows up. If the T bit is set
	;	in the user's PSL then the TP bit is also set to insure that
	;	instructions are not lost if the debugger is running.
	;
	;	    The opcode of the instruction is the analyzed and the
	;	location of the action bytes for the instruction is computed.
	;	(The details of this computation are given in the table
	;	descriptions below.) The action pointer and action count are
	;	set up for processing the instruction, the pointers to the
	;	read area and the write area are initialized, and control
	;	enters the action loop to process the instruction.
	;
	;	Note:	1. From the description of the way that the simulated
	;		   register area is constructed, it is clear that
	;		   the length longword of the parameter list is
	;		   overwritten. All of the methods of leaving
	;		   the fault to trap converter put this longword
	;		   back together. The internal condition handler
	;		   does this if it detects an unwind.
	;
FAULT_TO_TRAP:				; entrance
	MOVAB	-4*<CALL_ARGS-3>(SP),SP ; allocate the flexible stack space
	CALLS	#CALL_ARGS,1$		; build the procedure frame
	HALT				; the call will never return here
1$:	.WORD	^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; entry mask
	MOVAB	LOCAL_START(FP),SP	; allocate the local storage
	EXTZV	#MASK_ALIGN,#2,SAVE_MASK(FP),R0 ; R0 = alignment bits
	MOVB	R0,SAVE_ALIGN(FP)	; save them in the frame
	MOVAB	W^CONVERT_HANDLER,HANDLER(FP) ; set up the condition handler
	MOVQ	SAVE_AP(FP),REG_AP(FP)	; move user's AP and FP into place
	MOVAB	4*<CALL_ARGS+1>(AP),REG_SP(FP) ; move user's SP into place
	MOVQ	4*<CALL_ARGS-1>(AP),REG_PC(FP) ; move PC and PSL into place
	MOVL	4*<CALL_ARGS-2>(AP),R0	; R0 = condition name
	CMPW	#SS$_FLTUND_F,R0	; floating underflow fault ?
	BNEQ	2$			; no - bypass
	MOVL	#1,R0			; R0 = internal code
	BRB	5$			; bypass
2$:	CMPW	#SS$_FLTOVF_F,R0	; floating overflow fault ?
	BNEQ	3$			; no - bypass
	MOVL	#2,R0			; R0 = internal code
	BRB	5$			; bypass
3$:	CMPW	#SS$_FLTDIV_F,R0	; floating divide by zero fault ?
	BEQL	4$			; yes - skip
	HALT				; something went wrong !
4$:	MOVL	#3,R0			; R0 = internal code
5$:	MOVB	R0,FAULT_TYPE(FP)	; save the fault code
	CLRB	CARRY_BIT(FP)		; clear the carry bit flag
	BBC	#PSL_C,PSL(FP),6$	; is the carry bit set ?
	INCB	CARRY_BIT(FP)		; yes - make a note
6$:	BBC	#PSL_T,PSL(FP),7$	; the trace enable bit is clear - skip
	BBSS	#PSL_TP,PSL(FP),7$	; set the trace pending bit
7$:	MOVL	REG_PC(FP),SAVE_PC(FP)	; store traceback instruction location
	MOVL	REG_PC(FP),INST_ADDRESS(FP) ; save the instruction address
	MOVZBL	@REG_PC(FP),R2		; R2 = first byte of instruction
	INCL	REG_PC(FP)		; increment the PC
	CMPB	#^XFD,R2		; is the byte FD ?
	BEQL	8$			; yes - bypass
	EXTZV	#0,#4,R2,R3		; R3 = low-order nibble
	BICL2	#15,R2			; clear low-order nibble in R2
	BRB	9$			; bypass
8$:	MOVZBL	@REG_PC(FP),R2		; R2 = second byte of instruction
	INCL	REG_PC(FP)		; increment the PC
	EXTZV	#0,#4,R2,R3		; R3 = low-order nibble
	INSV	#1,#0,#4,R2		; store one in the low-order nibble
9$:	MOVAW	W^CLASS_TAB[R3],R3	; R3 = location of word for class
	CVTBL	1(R3),R4		; R4 = size of the class
	CVTBL	(R3),R3 		; R3 = relative position of class
	MOVAB	W^CLASS_TAB[R3],R3	; R3 = location of class table
	LOCC	R2,R4,(R3)		; look for the instruction
	BNEQ	10$			; we found it - skip
	HALT				; we didn't find it - internal error
10$:	MOVZBL	(R1)[R4],R1		; R1 = relative position of pattern
	MOVAB	W^PATTERNS[R1],R0	; R0 = location of pattern string
	MOVB	(R0),ACTION_COUNT(FP)	; store the action counter
	MOVL	R0,ACTION_PTR(FP)	; store the action pointer
	MOVAB	READ_AREA(FP),R10	; R10 = location of read operand area
	MOVAB	WRITE_AREA(FP),R11	; R11 = location of write operand area
	BRW	ACTION_LOOP		; enter the action loop
	;

	;
	;	Normal End of Fault to Trap Conversion
	;
	;		entered by branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine is entered at the end of instruction 
	;	processing. First it writes all of the output operands.
	;	The values of these operands is in the write area in the
	;	frame. When this operation is complete, the routine branches
	;	to the routine which signals the appropriate arithmetic trap.
	;
	;	Note:	1. Each entry of the write area consists of a longword
	;		   containing the operand location, followed by a 
	;		   longword containing the number of bytes of the 
	;		   operand, followed by that many bytes containing
	;		   the value to be output. For register operands, the
	;		   address of the simulated register is used. The 
	;		   location of the next byte in the write area is 
	;		   always contained in R11.
	;
FINISH: 				; entrance
	MOVAB	WRITE_AREA(FP),R6	; R6 = location of output value area
1$:	CMPL	R6,R11			; have we reached the end ?
	BEQL	2$			; yes - bypass
	MOVQ	(R6)+,R7		; R7 = address, R8 = length
	MOVC3	R8,(R6),(R7)		; output the value
	ADDL2	R8,R6			; position past the value
	BRB	1$			; loop
2$:	CASEB	FAULT_TYPE(FP),#1,#2	; branch on the fault type
3$:	.WORD	UNDERFLOW_TRAP-3$	; 1 - floating underflow
	.WORD	OVERFLOW_TRAP-3$	; 2 - floating overflow
	.WORD	DIVIDE_TRAP-3$		; 3 - floating divide by zero
	;

	;
	;	CONVERT_HANDLER - Internal Condition Handler
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;
	;	    This routine is the internal condition handler for the
	;	fault to trap converter. Since the converter does not make
	;	constructive use of exceptions except in special procedures,
	;	this routine requests of all conditions it intercepts.
	;
	;	    If the condition is SS$_UNWIND which indicates that an
	;	unwind is about to take place, then it restores the argument
	;	count longword in the parameter list for the procedure so the
	;	unwind will work properly.
	;
CONVERT_HANDLER:			; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0,R1 = condition array locations
	CMPL	#SS$_UNWIND,4(R0)	; is this an unwind ?
	BNEQ	1$			; no - bypass
	MOVL	4(R1),R0		; R0 = frame location
	MOVB	SAVE_ALIGN(R0),R1	; R1 = safe copy of alignment bits
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(R0) ; store align bits in frame
	ADDL2	R1,R0			; add to the frame location
	MOVL	#CALL_ARGS,FRAME_END(R0) ; store the argument count
1$:	MOVZWL	#SS$_RESIGNAL,R0	; resignal the condition
	RET				; return
	;

	;
	;	Instruction Lookup and Action Tables
	;	------------------------------------
	;
	;	Discussion
	;
	;	    The following tables are used for identifying the 
	;	instructions which the fault to trap converter is supposed to
	;	process and for determining what actions are necessary to
	;	process these instructions. Three sets of tables are involved.
	;	First there is the class lookup table which is used to locate
	;	the class table for a particular instruction class. Next there
	;	is the class table which is used to search for a particular
	;	instruction and then to determine its action pattern table.
	;	Finally there is the action pattern table which specifies the
	;	various actions taken for the instruction.
	;
	;	    For a one byte opcode, the class of the instruction is the
	;	low order nibble of the opcode and the key of the instruction
	;	is the opcode with the low order nibble cleared. For a two
	;	byte opcode (where the first byte is FD), the class of the
	;	instruction is the low order nibble of the second byte and 
	;	the key of the instruction is the second byte of the opcode
	;	with the low order nibble set to one.
	;
	;	    The class lookup table CLASS_TAB is a table of words which
	;	is indexed by the class number. The first byte of the indexed
	;	entry is the position (relative to CLASS_TAB) of the class
	;	table for the class and the second byte of the indexed entry
	;	is the number of entries in the class table.
	;	
	;	    The class table for a particular class consists of two
	;	byte strings of equal size. The first byte string (the
	;	instruction lookup table) contains the keys for the
	;	instructions in the class and the corresponding bytes in the
	;	second string (the action table) consist of the positions
	;	(relative to PATTERNS) of the action pattern table for the
	;	instruction.
	;
	;	    An action pattern table is a byte string in which the
	;	first byte contains the number of actions and the remaining
	;	bytes contain the codes for the individual actions. The code
	;	for an action contains the action type in the low order nibble
	;	and a qualifying data type in the high-order nibble. All of 
	;	action codes used have been given identifiers which are 
	;	defined in the definition section of this module.
	;
	;	    A short table which maps data type codes into their 
	;	lengths in bytes has also been included.
	;
	;
	;	Class Lookup Table
	;	------------------
	;
CLASS_TAB:
	.BYTE	CLASS_0-CLASS_TAB,ACTION_0-CLASS_0
	.BYTE	CLASS_1-CLASS_TAB,ACTION_1-CLASS_1
	.BYTE	CLASS_2-CLASS_TAB,ACTION_2-CLASS_2
	.BYTE	CLASS_3-CLASS_TAB,ACTION_3-CLASS_3
	.BYTE	CLASS_4-CLASS_TAB,ACTION_4-CLASS_4
	.BYTE	CLASS_5-CLASS_TAB,ACTION_5-CLASS_5
	.BYTE	CLASS_6-CLASS_TAB,ACTION_6-CLASS_6
	.BYTE	CLASS_7-CLASS_TAB,ACTION_7-CLASS_7
	.BYTE	0,0
	.BYTE	0,0
	.BYTE	0,0
	.BYTE	0,0
	.BYTE	0,0
	.BYTE	0,0
	.BYTE	0,0
	.BYTE	CLASS_F-CLASS_TAB,ACTION_F-CLASS_F
	;
	;
	;	Class Tables
	;	------------
	;
	;	Class 0 Instruction Lookup Table
	;
CLASS_0:
	.BYTE	^X 40			; 40	ADDF2
	.BYTE	^X 60			; 60	ADDD2
	.BYTE	^X 41			; 40FD	ADDG2
	.BYTE	^X 61			; 60FD	ADDH2
	;
	;	Class 0 Action Table
	;
ACTION_0:
	.BYTE	PATTERN_ADDF2-PATTERNS	; 40	ADDF2
	.BYTE	PATTERN_ADDD2-PATTERNS	; 60	ADDD2
	.BYTE	PATTERN_ADDG2-PATTERNS	; 40FD	ADDG2
	.BYTE	PATTERN_ADDH2-PATTERNS	; 60FD	ADDH2
	;
	;	Class 1 Instruction Lookup Table
	;
CLASS_1:
	.BYTE	^X 40			; 41	ADDF3
	.BYTE	^X 60			; 61	ADDD3
	.BYTE	^X 41			; 41FD	ADDG3
	.BYTE	^X 61			; 61FD	ADDH3
	;
	;	Class 1 Action Table
	;
ACTION_1:
	.BYTE	PATTERN_ADDF3-PATTERNS	; 41	ADDF3
	.BYTE	PATTERN_ADDD3-PATTERNS	; 61	ADDD3
	.BYTE	PATTERN_ADDG3-PATTERNS	; 41FD	ADDG3
	.BYTE	PATTERN_ADDH3-PATTERNS	; 61FD	ADDH3
	;
	;	Class 2 Instruction Lookup Table
	;
CLASS_2:
	.BYTE	^X 40			; 42	SUBF2
	.BYTE	^X 60			; 62	SUBD2
	.BYTE	^X 41			; 42FD	SUBG2
	.BYTE	^X 61			; 62FD	SUBH2
	;
	;	Class 2 Action Table
	;
ACTION_2:
	.BYTE	PATTERN_SUBF2-PATTERNS	; 42	SUBF2
	.BYTE	PATTERN_SUBD2-PATTERNS	; 62	SUBD2
	.BYTE	PATTERN_SUBG2-PATTERNS	; 42FD	SUBG2
	.BYTE	PATTERN_SUBH2-PATTERNS	; 62FD	SUBH2
	;
	;	Class 3 Instruction Lookup Table
	;
CLASS_3:
	.BYTE	^X 40			; 43	SUBF3
	.BYTE	^X 60			; 63	SUBD3
	.BYTE	^X 31			; 33FD	CVTGF
	.BYTE	^X 41			; 43FD	SUBG3
	.BYTE	^X 61			; 63FD	SUBH3
	;
	;	Class 3 Action Table
	;
ACTION_3:
	.BYTE	PATTERN_SUBF3-PATTERNS	; 43	SUBF3
	.BYTE	PATTERN_SUBD3-PATTERNS	; 63	SUBD3
	.BYTE	PATTERN_CVTGF-PATTERNS	; 33FD	CVTGF
	.BYTE	PATTERN_SUBG3-PATTERNS	; 43FD	SUBG3
	.BYTE	PATTERN_SUBH3-PATTERNS	; 63FD	SUBH3
	;
	;	Class 4 Instruction Lookup Table
	;
CLASS_4:
	.BYTE	^X 40			; 44	MULF2
	.BYTE	^X 50			; 54	EMODF
	.BYTE	^X 60			; 64	MULD2
	.BYTE	^X 70			; 74	EMODD
	.BYTE	^X 41			; 44FD	MULG2
	.BYTE	^X 51			; 54FD	EMODG
	.BYTE	^X 61			; 64FD	MULH2
	.BYTE	^X 71			; 74FD	EMODH
	;
	;	Class 4 Action Table
	;
ACTION_4:
	.BYTE	PATTERN_MULF2-PATTERNS	; 44	MULF2
	.BYTE	PATTERN_EMODF-PATTERNS	; 54	EMODF
	.BYTE	PATTERN_MULD2-PATTERNS	; 64	MULD2
	.BYTE	PATTERN_EMODD-PATTERNS	; 74	EMODD
	.BYTE	PATTERN_MULG2-PATTERNS	; 44FD	MULG2
	.BYTE	PATTERN_EMODG-PATTERNS	; 54FD	EMODG
	.BYTE	PATTERN_MULH2-PATTERNS	; 64FD	MULH2
	.BYTE	PATTERN_EMODH-PATTERNS	; 74FD	EMODH
	;
	;	Class 5 Instruction Lookup Table
	;
CLASS_5:
	.BYTE	^X 40			; 45	MULF3
	.BYTE	^X 50			; 55	POLYF
	.BYTE	^X 60			; 65	MULD3
	.BYTE	^X 70			; 75	POLYD
	.BYTE	^X 41			; 45FD	MULG3
	.BYTE	^X 51			; 55FD	POLYG
	.BYTE	^X 61			; 65FD	MULH3
	.BYTE	^X 71			; 75FD	POLYH
	;
	;	Class 5 Action Table
	;
ACTION_5:
	.BYTE	PATTERN_MULF3-PATTERNS	; 45	MULF3
	.BYTE	PATTERN_POLYF-PATTERNS	; 55	POLYF
	.BYTE	PATTERN_MULD3-PATTERNS	; 65	MULD3
	.BYTE	PATTERN_POLYD-PATTERNS	; 75	POLYD
	.BYTE	PATTERN_MULG3-PATTERNS	; 45FD	MULG3
	.BYTE	PATTERN_POLYG-PATTERNS	; 55FD	POLYG
	.BYTE	PATTERN_MULH3-PATTERNS	; 65FD	MULH3
	.BYTE	PATTERN_POLYH-PATTERNS	; 75FD	POLYH
	;
	;	Class 6 Instruction Lookup Table
	;
CLASS_6:
	.BYTE	^X 40			; 46	DIVF2
	.BYTE	^X 60			; 66	DIVD2
	.BYTE	^X 70			; 76	CVTDF
	.BYTE	^X 41			; 46FD	DIVG2
	.BYTE	^X 61			; 66FD	DIVH2
	.BYTE	^X 71			; 76FD	CVTHD
	.BYTE	^X F1			; F6FD	CVTHF
	;
	;	Class 6 Action Table
	;
ACTION_6:
	.BYTE	PATTERN_DIVF2-PATTERNS	; 46	DIVF2
	.BYTE	PATTERN_DIVD2-PATTERNS	; 66	DIVD2
	.BYTE	PATTERN_CVTDF-PATTERNS	; 76	CVTDF
	.BYTE	PATTERN_DIVG2-PATTERNS	; 46FD	DIVG2
	.BYTE	PATTERN_DIVH2-PATTERNS	; 66FD	DIVH2
	.BYTE	PATTERN_CVTHG-PATTERNS	; 76FD	CVTHG
	.BYTE	PATTERN_CVTHF-PATTERNS	; F6FD	CVTHF
	;
	;	Class 7 Instruction Lookup Table
	;
CLASS_7:
	.BYTE	^X 40			; 47	DIVF3
	.BYTE	^X 60			; 67	DIVD3
	.BYTE	^X 41			; 47FD	DIVG3
	.BYTE	^X 61			; 67FD	DIVH3
	.BYTE	^X F1			; F7FD	CVTHD
	;
	;	Class 7 Action Table
	;
ACTION_7:
	.BYTE	PATTERN_DIVF3-PATTERNS	; 47	DIVF3
	.BYTE	PATTERN_DIVD3-PATTERNS	; 67	DIVD3
	.BYTE	PATTERN_DIVG3-PATTERNS	; 47FD	DIVG3
	.BYTE	PATTERN_DIVH3-PATTERNS	; 67FD	DIVH3
	.BYTE	PATTERN_CVTHD-PATTERNS	; F7	CVTHD
	;
	;	Class F Instruction Lookup Table
	;
CLASS_F:
	.BYTE	^X 40			; 4F	ACBF
	.BYTE	^X 60			; 6F	ACBD
	.BYTE	^X 41			; 4FFD	ACBG
	.BYTE	^X 61			; 6FFD	ACBH
	;
	;	Class F Action Table
	;
ACTION_F:
	.BYTE	PATTERN_ACBF-PATTERNS	; 4F	ACBF
	.BYTE	PATTERN_ACBD-PATTERNS	; 6F	ACBD
	.BYTE	PATTERN_ACBG-PATTERNS	; 4FFD	ACBG
	.BYTE	PATTERN_ACBH-PATTERNS	; 6FFD	ACBH
	;
	;
	;	Pattern Action Tables
	;	---------------------
	;
PATTERNS:				; origin for pattern action tables
	;
	;	Pattern for ADDF2, DIVF2, MULF2, and SUBF2
	;
PATTERN_ADDF2:
PATTERN_DIVF2:
PATTERN_MULF2:
PATTERN_SUBF2:
	.BYTE	2
	.BYTE	READ_FLOAT
	.BYTE	MODIFY_FLOAT
	;
	;	Pattern for ADDD2, DIVD2, MULD2, and SUBD2
	;
PATTERN_ADDD2:
PATTERN_DIVD2:
PATTERN_MULD2:
PATTERN_SUBD2:
	.BYTE	2
	.BYTE	READ_DOUBLE
	.BYTE	MODIFY_DOUBLE
	;
	;	Pattern for ADDG2, DIVG2, MULG2, and SUBG2
	;
PATTERN_ADDG2:
PATTERN_DIVG2:
PATTERN_MULG2:
PATTERN_SUBG2:
	.BYTE	2
	.BYTE	READ_GRAND
	.BYTE	MODIFY_GRAND
	;
	;	Pattern for ADDH2, DIVH2, MULH2, and SUBH2
	;
PATTERN_ADDH2:
PATTERN_DIVH2:
PATTERN_MULH2:
PATTERN_SUBH2:
	.BYTE	2
	.BYTE	READ_HUGE
	.BYTE	MODIFY_HUGE
	;
	;	Pattern for ADDF3, DIVF3, MULF3, and SUBF3
	;
PATTERN_ADDF3:
PATTERN_DIVF3:
PATTERN_MULF3:
PATTERN_SUBF3:
	.BYTE	3
	.BYTE	READ_FLOAT
	.BYTE	READ_FLOAT
	.BYTE	WRITE_FLOAT
	;
	;	Pattern for ADDD3, DIVD3, MULD3, and SUBD3
	;
PATTERN_ADDD3:
PATTERN_DIVD3:
PATTERN_MULD3:
PATTERN_SUBD3:
	.BYTE	3
	.BYTE	READ_DOUBLE
	.BYTE	READ_DOUBLE
	.BYTE	WRITE_DOUBLE
	;
	;	Pattern for ADDG3, DIVG3, MULG3 and SUBG3
	;
PATTERN_ADDG3:
PATTERN_DIVG3:
PATTERN_MULG3:
PATTERN_SUBG3:
	.BYTE	3
	.BYTE	READ_GRAND
	.BYTE	READ_GRAND
	.BYTE	WRITE_GRAND
	;
	;	Pattern for ADDH3, DIVH3, MULG3, and SUBH3
	;
PATTERN_ADDH3:
PATTERN_DIVH3:
PATTERN_MULH3:
PATTERN_SUBH3:
	.BYTE	3
	.BYTE	READ_HUGE
	.BYTE	READ_HUGE
	.BYTE	WRITE_HUGE
	;
	;	Pattern for CVTDF
	;
PATTERN_CVTDF:
	.BYTE	2
	.BYTE	READ_DOUBLE
	.BYTE	WRITE_FLOAT
	;
	;	Pattern for CVTGF
	;
PATTERN_CVTGF:
	.BYTE	2
	.BYTE	READ_GRAND
	.BYTE	WRITE_FLOAT
	;
	;	Pattern for CVTHF
	;
PATTERN_CVTHF:
	.BYTE	2
	.BYTE	READ_HUGE
	.BYTE	WRITE_FLOAT
	;
	;	Pattern for CVTHD
	;
PATTERN_CVTHD:
	.BYTE	2
	.BYTE	READ_HUGE
	.BYTE	WRITE_DOUBLE
	;
	;	Pattern for CVTHG
	;
PATTERN_CVTHG:
	.BYTE	2
	.BYTE	READ_HUGE
	.BYTE	WRITE_GRAND
	;
	;	Pattern for EMODF
	;
PATTERN_EMODF:
	.BYTE	5
	.BYTE	READ_FLOAT
	.BYTE	READ_BYTE
	.BYTE	READ_FLOAT
	.BYTE	WRITE_LONG
	.BYTE	WRITE_FLOAT
	;
	;	Pattern for EMODD
	;
PATTERN_EMODD:
	.BYTE	5
	.BYTE	READ_DOUBLE
	.BYTE	READ_BYTE
	.BYTE	READ_DOUBLE
	.BYTE	WRITE_LONG
	.BYTE	WRITE_DOUBLE
	;
	;	Pattern for EMODG
	;
PATTERN_EMODG:
	.BYTE	5
	.BYTE	READ_GRAND
	.BYTE	READ_WORD
	.BYTE	READ_GRAND
	.BYTE	WRITE_LONG
	.BYTE	WRITE_GRAND
	;
	;	Pattern for EMODH
	;
PATTERN_EMODH:
	.BYTE	5
	.BYTE	READ_HUGE
	.BYTE	READ_WORD
	.BYTE	READ_HUGE
	.BYTE	WRITE_LONG
	.BYTE	WRITE_HUGE
	;
	;	Pattern for POLYF
	;
PATTERN_POLYF:
	.BYTE	4
	.BYTE	READ_FLOAT
	.BYTE	READ_WORD
	.BYTE	ADDRESS_BYTE
	.BYTE	POLY_FLOAT
	;
	;	Pattern for POLYD
	;
PATTERN_POLYD:
	.BYTE	4
	.BYTE	READ_DOUBLE
	.BYTE	READ_WORD
	.BYTE	ADDRESS_BYTE
	.BYTE	POLY_DOUBLE
	;
	;	Pattern for POLYG
	;
PATTERN_POLYG:
	.BYTE	4
	.BYTE	READ_GRAND
	.BYTE	READ_WORD
	.BYTE	ADDRESS_BYTE
	.BYTE	POLY_GRAND
	;
	;	Pattern for POLYH
	;
PATTERN_POLYH:
	.BYTE	4
	.BYTE	READ_HUGE
	.BYTE	READ_WORD
	.BYTE	ADDRESS_BYTE
	.BYTE	POLY_HUGE
	;
	;	Pattern for ACBF
	;
PATTERN_ACBF:
	.BYTE	5
	.BYTE	READ_FLOAT
	.BYTE	READ_FLOAT
	.BYTE	MODIFY_FLOAT
	.BYTE	BRANCH_WORD
	.BYTE	ACB_FLOAT
	;
	;	Pattern for ACBD
	;
PATTERN_ACBD:
	.BYTE	5
	.BYTE	READ_DOUBLE
	.BYTE	READ_DOUBLE
	.BYTE	MODIFY_DOUBLE
	.BYTE	BRANCH_WORD
	.BYTE	ACB_DOUBLE
	;
	;	Pattern for ACBG
	;
PATTERN_ACBG:
	.BYTE	5
	.BYTE	READ_GRAND
	.BYTE	READ_GRAND
	.BYTE	MODIFY_GRAND
	.BYTE	BRANCH_WORD
	.BYTE	ACB_GRAND
	;
	;	Pattern for ACBH
	;
PATTERN_ACBH:
	.BYTE	5
	.BYTE	READ_HUGE
	.BYTE	READ_HUGE
	.BYTE	MODIFY_HUGE
	.BYTE	BRANCH_WORD
	.BYTE	ACB_HUGE
	;
	;	Table of Data Type Lengths
	;
DATA_LENGTHS:				; table origin
	.BYTE	4			; 1 - floating
	.BYTE	8			; 2 - double floating
	.BYTE	8			; 3 - grand floating
	.BYTE	16			; 4 - huge floating
	.BYTE	1			; 5 - byte
	.BYTE	2			; 6 - word
	.BYTE	4			; 7 - longword
	;

	;
	;	ACTION_LOOP - Action Dispatching Routine
	;
	;		entered by branching
	;
	;		no parameters
	;
	;	Discussion
	;	
	;	    This routine passes control to the routine for the next
	;	action required to process the current instruction. The 
	;	pointer to the current action code is contained in the local
	;	cell ACTION_PTR and the number of actions not yet processed is
	;	contained in the local cell ACTION_COUNT. When all of the 
	;	actions for the instruction have been performed, control 
	;	passes to FINISH. When an action is complete, the routine 
	;	exits by branching to ACTION_LOOP.
	;
	;	Note:	1. When an action routine is entered, the following
	;		   values are available in the registers:
	;
	;			R6 = type of action
	;			R7 = data type for action
	;			R8 = data type length for action
	;
ACTION_LOOP:				; entrance
	DECB	ACTION_COUNT(FP)	; decrement the counter
	BGEQ	1$			; it's not negative - skip
	BRW	FINISH			; finish up
1$:	INCL	ACTION_PTR(FP)		; increment the action pointer
	MOVZBL	@ACTION_PTR(FP),R0	; R0 = next action byte
	EXTZV	#0,#4,R0,R6		; R6 = type of action
	EXTZV	#4,#4,R0,R7		; R7 = data type
	CVTBL	DATA_LENGTHS-1[R7],R8	; R8 = data length
	CASEL	R6,#1,#6		; branch on the action type
2$:	.WORD	OPERAND-2$		; 1 - operand with read access
	.WORD	OPERAND-2$		; 2 - operand with write access
	.WORD	OPERAND-2$		; 3 - operand with modify access
	.WORD	OPERAND-2$		; 4 - operand with address access
	.WORD	WORD_BRANCH-2$		; 5 - word branch displacement
	.WORD	CHECK_POLY-2$		; 6 - post checking for POLYx
	.WORD	CHECK_ACB-2$		; 7 - post checking for ACBx
	;

	;
	;	Instruction Operand Processing Routines
	;	---------------------------------------
	;
	;	General Discussion
	;
	;	    The following routines perform those actions which 
	;	specify instruction operand processing. The action code
	;	contains the access type and the data type for the operand
	;	and these values along with the data type are available in
	;	the registers R6, R7, and R8. The routine operand decodes
	;	the operand specifier and branches to the routine for handling
	;	the particular operand type. When this routine is entered, the
	;	operand specifier byte, the low order nibble, and the high
	;	order nibble, are available in R0, R1, and R2.
	;
	;	    During operand processing all of the side effects which
	;	change register values unless FPD is set in the PSL in which
	;	case only side effects for PC are performed. This is because
	;	operand scanning is only used to determine the instruction
	;	length when FPD is set since the operands are in the user's
	;	registers or on his stack.
	;
	;	    Except for literal mode operands and index mode operands
	;	the operand scanning routines simply determine the location
	;	of the operand and enter ACCESS_OPERAND with this location in
	;	R9. For literal mode operands, the operand value is computed
	;	and stored in the read area. For index mode operands, the
	;	index modification is computed into R3 and then the routine
	;	process the next byte as an operand specifier and branches to
	;	the appropriate operand processing routine.
	;
	;	    The routine ACCESS_OPERAND performs one of several actions
	;	for the operand based on the operand access and data types and
	;	on the type of exception being processed. If the operand is 
	;	read or address, then the operand value or address is copied
	;	into the read area. If the operand is write or modify then a
	;	value for it is placed in the write area depending on the data
	;	type and exception type. For integer data types and for 
	;	underflow exceptions, this value is always zero. For overflow
	;	and divide exceptions and floating operands the value is a 
	;	reserved floating value. When ACCESS_OPERAND is done control
	;	passes back to ACTION_LOOP.
	;
	;	    The read area is used to hold the values of all of the 
	;	read only and address only operands of the instruction in
	;	contiguous bytes. The register R10 contains the location of
	;	next available byte in the read area. The read area is used
	;	by the postprocessing routine for the ACBx instructions in
	;	order to determine if the branch should be taken. 
	;
	;	    The write area is a list of all of the values to be
	;	output by FINISH when instruction processing is complete.
	;	The values are not output as the operands are processed since
	;	the architecture requires that all operands be processed
	;	before any values are output. The format of this area is
	;	given in the description of FINISH.
	;
	;
	;	OPERAND - Process the Next Operand Specifier
	;
	;		entered by branching
	;
	;		parameters:	( See the discussion of ACTION_LOOP. )
	;
OPERAND:				; entrance
	MOVZBL	@REG_PC(FP),R0		; R0 = operand specifier byte
	INCL	REG_PC(FP)		; increment the PC
	EXTZV	#0,#4,R0,R1		; R1 = low order nibble of specifier
	EXTZV	#4,#4,R0,R2		; R2 = high order nibble of specifier
	CLRL	R3			; clear the index modification
	CASEL	R2,#0,#15		; branch on the high order nibble
1$:	.WORD	LITERAL_MODE-1$ 	; 0 - literal mode
	.WORD	LITERAL_MODE-1$ 	; 1 - literal mode
	.WORD	LITERAL_MODE-1$ 	; 2 - literal mode
	.WORD	LITERAL_MODE-1$ 	; 3 - literal mode
	.WORD	INDEX_MODE-1$		; 4 - index mode
	.WORD	REGISTER_MODE-1$	; 5 - register mode
	.WORD	REG_DEF_MODE-1$ 	; 6 - register deferred mode
	.WORD	DECR_MODE-1$		; 7 - autodecrement mode
	.WORD	INCR_MODE-1$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-1$	; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-1$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-1$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-1$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-1$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-1$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-1$	; F - long displacement deferred mode
	;
	;	Process a Literal Mode Operand Specifier
	;
LITERAL_MODE:				; entrance
	CASEL	R7,#1,#6		; branch on the data type
1$:	.WORD	2$-1$			; 1 - float
	.WORD	3$-1$			; 2 - double
	.WORD	4$-1$			; 3 - grand
	.WORD	6$-1$			; 4 - huge
	.WORD	7$-1$			; 5 - byte
	.WORD	8$-1$			; 6 - word
	.WORD	9$-1$			; 7 - long
2$:	ASHL	#4,R0,R0		; position the literal bits
	MOVAB	1@14(R0),(R10)+ 	; save the value
	BRB	10$			; bypass
3$:	ASHL	#4,R0,R0		; position the literal bits
	BRB	5$			; skip
4$:	ASHL	#1,R0,R0		; position the literal bits
5$:	MOVAB	1@14(R0),(R10)+ 	; save the first longword
	CLRL	(R10)+			; clear the second longword
	BRB	10$			; bypass
6$:	ROTL	#29,R0,R0		; position the literal bits
	MOVAB	1@14(R0),(R10)+ 	; save the first longword
	CLRL	(R10)+			; clear the second longword
	CLRQ	(R10)+			; clear the second quadword
7$:	MOVB	R0,(R10)+		; save the byte value
	BRB	10$			; bypass
8$:	MOVW	R0,(R10)+		; save the word value
	BRB	10$			; skip
9$:	MOVL	R0,(R10)+		; save the longword value
10$:	BRW	ACTION_LOOP		; end of operand processing
	;
	;	Process an Index Mode Operand Specifier
	;
INDEX_MODE:				; entrance
	MULL3	R8,REG_R0(FP)[R1],R3	; R3 = index modification
	MOVZBL	@REG_PC(FP),R0		; R0 = next operand specifier byte
	INCL	REG_PC(FP)		; increment the PC
	EXTZV	#0,#4,R0,R1		; R1 = low order nibble of specifier
	EXTZV	#4,#4,R0,R2		; R1 = high order nibble of specifier
	CASEL	R2,#0,#15		; branch on the high order nibble
1$:	.WORD	0			; 0 - literal mode
	.WORD	0			; 1 - literal mode
	.WORD	0			; 2 - literal mode
	.WORD	0			; 3 - literal mode
	.WORD	0			; 4 - index mode
	.WORD	0			; 5 - register mode
	.WORD	REG_DEF_MODE-1$ 	; 6 - register deferred mode
	.WORD	DECR_MODE-1$		; 7 - autodecrement mode
	.WORD	INCR_MODE-1$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-1$	; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-1$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-1$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-1$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-1$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-1$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-1$	; F - long displacement deferred mode
	;
	;	Process a Register Mode Operand Specifier
	;
REGISTER_MODE:				; entrance
	MOVAL	REG_R0(FP)[R1],R9	; R9 = location of the operand
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Process a Register Deferred Mode Operand Specifier
	;
REG_DEF_MODE:				; entrance
	ADDL3	R3,REG_R0(FP)[R1],R9	; R9 = location of the operand
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Process an Autodecrement Mode Operand Specifier
	;
DECR_MODE:				; entrance
	BBC	#PSL_FPD,PSL(FP),1$	; side effects are allowed - skip
	BRW	ACTION_LOOP		; end of operand processing
1$:	SUBL2	R8,REG_R0(FP)[R1]	; subtract data size from the register
	ADDL3	R3,REG_R0(FP)[R1],R9	; R9 = location of the operand
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Process an Autoincrement Mode Operand Specifier
	;
INCR_MODE:				; entrance
	CMPL	#15,R1			; is the register PC ?
	BEQL	1$			; yes - side effects are required
	BBC	#PSL_FPD,PSL(FP),1$	; side effects are allowed - skip
	BRW	ACTION_LOOP		; end of operand processing
1$:	ADDL3	R3,REG_R0(FP)[R1],R9	; R9 = operand address
	ADDL2	R8,REG_R0(FP)[R1]	; increment the register
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Process an Autoincrement Deferred Mode Operand Specifier
	;
INCR_DEF_MODE:				; entrance
	CMPL	#15,R1			; is the register PC ?
	BEQL	1$			; yes - side effects are required
	BBC	#PSL_FPD,PSL(FP),1$	; side effects are allowed - skip
	BRW	ACTION_LOOP		; end of operand processing
1$:	MOVL	REG_R0(FP)[R1],R9	; R9 = location of address longword
	ADDL3	R3,(R9),R9		; R9 = operand address
	ADDL2	#4,REG_R0(FP)[R1]	; increment the register
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Process a Byte Displacement Mode Operand Specifier
	;
BYTE_DISP_MODE: 			; entrance
	CVTBL	@REG_PC(FP),R9		; R9 = the byte displacement
	INCL	REG_PC(FP)		; increment the PC
	BRB	DISP_MODE		; finish processing the specifier
	;
	;	Process a Byte Displacement Deferred Mode Operand Specifier
	;
BYTE_DEF_MODE:				; entrance
	CVTBL	@REG_PC(FP),R9		; R9 = the byte displacement
	INCL	REG_PC(FP)		; increment the PC
	BRB	DISP_DEF_MODE		; finish processing the specifier
	;
	;	Process a Word Displacement Mode Operand Specifier
	;
WORD_DISP_MODE: 			; entrance
	CVTWL	@REG_PC(FP),R9		; R9 = the word displacement
	ADDL2	#2,REG_PC(FP)		; increment the PC
	BRB	DISP_MODE		; finish processing the specifier
	;
	;	Process a Word Displacement Deferred Mode Operand Specifier
	;
WORD_DEF_MODE:				; entrance
	CVTWL	@REG_PC(FP),R9		; R9 = the word displacement
	ADDL2	#2,REG_PC(FP)		; increment the PC
	BRB	DISP_DEF_MODE		; finish processing the specifier
	;
	;	Process a Long Displacement Mode Operand Specifier
	;
LONG_DISP_MODE: 			; entrance
	MOVL	@REG_PC(FP),R9		; R9 = the longword displacement
	ADDL2	#4,REG_PC(FP)		; increment the PC
	BRB	DISP_MODE		; finish processing the specifier
	;
	;	Process a Long Displacement Deferred Mode Operand Specifier
	;
LONG_DEF_MODE:				; entrance
	MOVL	@REG_PC(FP),R9		; R9 = the word displacement
	ADDL2	#4,REG_PC(FP)		; increment the PC
	BRB	DISP_DEF_MODE		; finish processing the specifier
	;
	;	Complete Processing Displacement Mode Specifier
	;
DISP_MODE:				; entrance
	ADDL2	REG_R0(FP)[R1],R9	; add the register value
	ADDL2	R3,R9			; add the index modification
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Complete Processing Displacement Deferred Mode Specifier
	;
DISP_DEF_MODE:				; entrance
	BBC	#PSL_FPD,PSL(FP),1$	; side effects are allowed - skip
	BRW	ACTION_LOOP		; end of operand processing
1$:	ADDL2	REG_R0(FP)[R1],R9	; add the register value
	ADDL3	R3,(R9),R9		; R9 = the operand location
	BRW	ACCESS_OPERAND		; access the operand
	;
	;	Perform Operand Accessing Functions
	;
ACCESS_OPERAND: 			; entrance
	BBC	#PSL_FPD,PSL(FP),1$	; is the FPD bit set ?
	BRW	ACTION_LOOP		; yes - don't do anything
1$:	CASEL	R6,#1,#3		; branch on the operand access
2$:	.WORD	3$-2$			; 1 - operand with read access
	.WORD	4$-2$			; 2 - operand with write access
	.WORD	4$-2$			; 3 - operand with modify access
	.WORD	9$-2$			; 4 - operand with address access
3$:	MOVC3	R8,(R9),(R10)		; make a copy of the operand value
	ADDL2	R8,R10			; update the copy index
	BRW	ACTION_LOOP		; end of operand processing
4$:	CMPL	R2,#5			; register mode operand ?
	BEQL 	5$			; yes - bypass
	MOVAB	(R9)[R8],R0		; R0 = address following operand
	CMPL	R0,SP			; is operand below the frame ?
	BLEQU	5$			; yes - bypass
	MOVAB	LOCAL_END(FP),R0	; R0 = end of local storage
	CMPL	R0,R9			; does the operand follow the frame ?
	BLEQU	5$			; yes - skip
	MOVL	R0,R9			; change the operand address
5$:	MOVL	R9,(R11)+		; store the store address
	MOVL	R8,(R11)+		; store the store length
	MOVC5	#0,(SP),#0,R8,(R11)	; clear the stored value
	INSV	#PSLM_Z,#0,#4,PSL(FP)	; describe a zero value
	CASEB	FAULT_TYPE(FP),#1,#2	; branch on the fault type
6$:	.WORD	8$-6$			; 1 - floating underflow
	.WORD	7$-6$			; 2 - floating overflow
	.WORD	7$-6$			; 3 - floating divide by zero
7$:	BISL2	#PSLM_N,PSL(FP) 	; set the N bit in the PSL
	BBSS	#15,(R11),8$		; make the value a reserved value
8$:	ADDL2	R8,R11			; increment the store index
	BRW	ACTION_LOOP		; end of operand processing
9$:	MOVL	(R9),(R10)+		; copy the operand address
	BRW	ACTION_LOOP		; end of operand processing
	;

	;
	;	Process a Word Branch Displacement Operand
	;
	;		entered by branching
	;	
	;		parameters:	( See the discussion of ACTION_LOOP. )
	;
	;	Discussion
	;	
	;	    This routine process a word branch displacement operand
	;	and stores the branch address in BRANCH_ADDRESS.
	;
WORD_BRANCH:				; entrance
	CVTWL	@REG_PC(FP),R0		; R0 = branch displacement
	ADDL2	#2,REG_PC(FP)		; increment the PC
	ADDL3	R0,REG_PC(FP),BRANCH_ADDRESS(FP) ; save the branch location
	BRW	ACTION_LOOP		; end of operand processing
	;

	;
	;	CHECK_ACB - Perform Post Instruction Checking for ACBx 
	;
	;		entered by branching
	;
	;		parameters:	( See the discussion of ACTION_LOOP. )
	;
	;	Discussion
	;
	;	    This routine performs the post instruction checking 
	;	required to simulate floating arithmetic traps for the ACBx
	;	instructions. First the carry bit is set equal to the value
	;	of that bit when the instruction was started. If the exception
	;	was an overflow, then the checking is complete. If the 
	;	exception was an underflow, then the step and limit in the
	;	read area are tested to see whether the jump should be taken
	;	under the assumption that the index is zero. If the jump
	;	should be taken, then the the branch destination address is
	;	stored into the simulated PC.
	;
CHECK_ACB:				; entrance
	BICL2	#PSLM_C,PSL(FP) 	; clear the C bit in the PSL
	BLBC	CARRY_BIT(FP),1$	; was the carry bit originally set ?
	BISL2	#PSLM_C,PSL(FP) 	; yes - make sure it's set in the PSL
1$:	CMPB	#1,FAULT_TYPE(FP)	; floating underflow ?
	BEQL	1$			; yes - skip
	BRW	ACTION_LOOP		; no - finish up
2$:	MOVAB	READ_AREA(FP)[R8],R0	; R0 = location of second operand
	BSBB	ACB_TEST		; test the addend
	BLSS	3$			; it's negative - bypass
	SUBL2	R8,R0			; R0 = location of first operand
	BSBB	ACB_TEST		; test the limit
	BGTR	4$			; it's positive - bypass
	BRW	ACTION_LOOP		; finish up
3$:	SUBL2	R8,R0			; R0 = location of first operand
	BSBB	ACB_TEST		; test the limit
	BLSS	4$			; it's negative - skip
	BRW	ACTION_LOOP		; finish up
4$:	MOVL	BRANCH_ADDRESS(FP),REG_PC(FP) ; set up the branch
	BRW	ACTION_LOOP		; finish up
	;

	;
	;	ACB_TEST - Perform Value Testing for CHECK_ACB
	;
	;		entered by subroutine branching
	;
	;		parameters:	R0 = Location of Value to be Tested
	;				R7 = Data Type Code
	;
	;		returns with 	Condition Codes = Result of Test
	;
	;	Discussion
	;
	;	   This routine tests the value addressed by R0 whose data
	;	type code is given in R7. The condition codes in the PSL
	;	when the routine returns reflect the outcome of the test.
	;
ACB_TEST:				; entrance
	CASEL	R7,#1,#3		; branch on the data type
1$:	.WORD	2$-1$			; 1 - floating
	.WORD	3$-1$			; 2 - double floating
	.WORD	4$-1$			; 3 - grand floating
	.WORD	5$-1$			; 4 - huge floating
2$:	TSTF	(R0)			; test the floating value
	RSB				; return with the condition codes
3$:	TSTD	(R0)			; test the double floating value
	RSB				; return with the condition codes
4$:	TSTG	(R0)			; test the grand floating value
	RSB				; return with the condition codes
5$:	TSTH	(R0)			; test the huge floating value
	RSB				; return with the condition codes
	;

	;
	;	CHECK_POLY - Perform Post Instruction Checking for POLYx
	;
	;		entered by branching
	;
	;		parameters:	( See the discussion of ACTION_LOOP. )
	;
	;	Discussion
	;
	;	    This routine performs the post instruction checking that
	;	is necessary to simulate the traps properly for the POLYx
	;	instructions. According to the architecture, the overflow
	;	and underflow faults always cause these instructions to be
	;	suspended so the operands are only scanned to determine the 
	;	instruction length.
	;
	;	    For an overflow exception, the result area is set to a
	;	reserved value and the condition codes are set to describe
	;	a reserved value. If the instruction is POLYH, then the 
	;	argument is unstacked. A floating overflow trap is then
	;	signaled.
	;
	;	    For an underflow exception, things are quite a bit more
	;	complicated since the architecture requires that the 
	;	instruction be run to completion before the trap is signaled.
	;	We perform this operation by creating our own arithmetic fault
	;	in a POLYx instruction and then move the state of the user
	;	instruction to our registers (leaving the implementation
	;	dependant information alone) and resume the operation of
	;	our instruction. Our instruction is run in a context with
	;	FU cleared so new underflow faults will not occur. If the
	;	instruction runs to completion, then the final state is moved
	;	back to the user registers and the implementation dependant
	;	information is cleared. If an overflow occurs then the action
	;	described above for an overflow fault is performed after the
	;	state is moved back to the user registers. If LIB$SIM_TRAP is
	;	or is called from the primary or secondary exception vectors,
	;	then an overflow trap is also possible in which case the user
	;	registers are put back and the trap is signaled. Two other 
	;	exceptions are also possible, a reserved operand exception
	;	and an access violation exception. When either of these occur,
	;	the user registers are put back and the fault is signaled.
	;
CHECK_POLY:				; entrance
	BBS	#PSL_FPD,PSL(FP),1$	; FPD is set in the PSL - skip
	HALT				; it's not set - something went wrong
1$:	CASEB	FAULT_TYPE(FP),#1,#1	; branch on the type of fault
2$:	.WORD	5$-2$			; 1 - floating underflow
	.WORD	3$-2$			; 2 - floating overflow
3$:	CMPL	#HUGE_TYPE,R7		; is the data type huge ?
	BNEQ	4$			; no - bypass
	CLRQ	REG_R2(FP)		; clear the user's R2 and R3
	ADDL2	#16,REG_SP(FP)		; unstack the argument
4$:	MOVZWL	#1@15,REG_R0(FP)	; store a reserved operand
	CLRL	REG_R1(FP)		; clear the user's R1
	INSV	#PSLM_NZ,#0,#4,PSL(FP)	; describe a reserved operand
	BRW	OVERFLOW_TRAP		; generate the trap
5$:	MOVL	FP,R6			; R6 = copy of frame pointer
	CLRL	R8			; condition XQT_POLY to generate fault
	CALLS	#0,W^XQT_POLY		; generate the fault
	CLRL	R8			; clear the exception code area
	MOVL	#PSLM_Z,R9		; R9 = condition code for zero
	CASEL	R7,#1,#3		; branch on the data type
6$:	.WORD	7$-6$			; 1 - floating
	.WORD	8$-6$			; 2 - double floating
	.WORD	8$-6$			; 3 - grand floating
	.WORD	9$-6$			; 4 - huge floating
7$:	CLRL	R0			; clear the result so far
	CLRL	R1			; clear the argument
	ADDL3	#4,REG_R3(FP),R3	; R3 = location of coefficients
	SUBB3	#1,REG_R2(FP),R2	; insert remaining coefficients in R2
	BEQL	11$			; the count is zero - bypass
	MOVL	REG_R1(FP),R1		; R1 = the argument
	BRB	10$			; bypass
8$:	CLRQ	R0			; clear the result so far
	CLRQ	R4			; clear the argument
	ADDL3	#8,REG_R3(FP),R3	; R3 = location of coefficients
	SUBB3	#1,REG_R2(FP),R2	; insert remaining coefficients in R2
	BEQL	11$			; the count is zero - bypass
	MOVQ	REG_R4(FP),R4		; R4,R5 = the argument
	BRB	10$			; bypass
9$:	CLRQ	R0			; clear first part of result so far
	CLRQ	R1			; clear second part of result so far
	ADDL3	#16,REG_R5(FP),R5	; R5 = location of coefficients
	SUBB3	#1,REG_R4(FP),R4	; insert remaining coefficients in R4
	BEQL	11$			; the count is zero - bypass
10$:	MOVL	#1,R8			; request the FPD bit this time
	CALLS	#0,W^XQT_POLY		; execute appropriate POLY instruction
11$:	CASEL	R7,#1,#3		; branch on the data type
12$:	.WORD	13$-12$ 		; 1 - floating
	.WORD	14$-12$ 		; 2 - double floating
	.WORD	14$-12$ 		; 3 - grand floating
	.WORD	15$-12$ 		; 4 - huge floating
13$:	MOVQ	R0,REG_R0(FP)		; store the result so and argument
	MOVB	R2,REG_R2(FP)		; store the remaining coefficients
	MOVL	R3,REG_R3(FP)		; store location of coefficients
	BRB	16$			; bypass
14$:	MOVQ	R0,REG_R0(FP)		; store the result so far
	MOVB	R2,REG_R2(FP)		; store the remaining coefficients
	MOVL	R3,REG_R3(FP)		; store location of coefficients
	MOVQ	R4,REG_R4(FP)		; store the argument
	BRB	16$			; bypass
15$:	MOVQ	R0,REG_R0(FP)		; store first part of result so far
	MOVQ	R2,REG_R2(FP)		; store second part of result so far
	MOVB	R4,REG_R4(FP)		; store the remaining coefficients
	MOVL	R5,REG_R5(FP)		; store location of coefficients
16$:	CMPL	#SS$_ACCVIO,R8		; was there an access violation ?
	BNEQ	17$			; no - skip
	BRW	ACCESS_FAULT		; process the access violation fault
17$:	CMPL	#SS$_ROPRAND,R8 	; was there a reserved operand ?
	BNEQ	18$			; no - skip
	BRW	OPERAND_FAULT		; process the reserved operand fault
18$:	CMPL	#SS$_FLTOVF,R8		; was there a overflow trap ?
	BNEQ	20$			; no - skip
	INSV	#PSLM_NZ,#0,#4,PSL(FP)	; describe a reserved operand
	CMPL	#HUGE_TYPE,R7		; is the data type huge ?
	BNEQ	19$			; no - skip
	ADDL2	#16,REG_SP(FP)		; unstack the argument
19$:	BRW	OVERFLOW_TRAP		; process the overflow trap
20$:	CMPL	#SS$_FLTOVF_F,R8	; was there a overflow fault ?
	BNEQ	21$			; no - skip
	BRW	3$			; process the overflow fault
21$:	INSV	R9,#0,#4,PSL(FP)	; set the condition codes
	CASEL	R7,#1,#3		; branch on the data type
22$:	.WORD	23$-22$ 		; 1 - floating
	.WORD	23$-22$ 		; 2 - double floating
	.WORD	23$-22$ 		; 3 - grand floating
	.WORD	24$-22$ 		; 4 - huge floating
23$:	INSV	#0,#8,#24,REG_R2(FP)	; perform remaining clear
	BRW	UNDERFLOW_TRAP		; process the floating underflow
24$:	INSV	#0,#8,#24,REG_R4(FP)	; perform remaining clear
	ADDL2	#16,REG_SP(FP)		; unstack the argument
	BRW	UNDERFLOW_TRAP		; process the floating underflow
	;

	;
	;	XQT_POLY - Execute a POLYx Instruction
	;
	;		parameter:	R8 = Set FPD in the PSL Indicator
	;
	;		returns with	R8 = Way Instruction Ended
	;
	;	Discussion
	;
	;	    This instruction executes one of POLYx instructions
	;	chosen to be the same as the instruction which the converter
	;	is processing. If the parameter R8 is zero, then the FPD bit
	;	in the PSL is clear when the instruction is entered and so
	;	an overflow fault occurs because of the choice of the argument
	;	and coefficients. The routine returns with all of the 
	;	registers for the fault intact. If R8 is one, then the FPD bit
	;	is set in the PSL for the instruction so the instruction 
	;	resumes starting from the state in the registers. If any 
	;	exception occurs, then R8 contains the code for the exception.
	;	If an access violation occurs, then the condition handler 
	;	saves additional information.
	;
XQT_POLY:				; entrance
	.WORD	0			; entry mask
	MOVAB	W^POLY_HANDLER,(FP)	; set up the condition handler
	MOVPSL	R9			; R9 = the PSL
	BBCC	#PSL_FU,R9,1$		; clear the FU bit in the PSL
1$:	BLBC	R8,2$			; don't set FPD in the PSL
	BBSS	#PSL_FPD,R9,2$		; set FPD in the PSL
2$:	CASEL	R7,#1,#3		; branch on the data type
3$:	.WORD	4$-3$			; 1 - floating
	.WORD	5$-3$			; 2 - double floating
	.WORD	6$-3$			; 3 - grand floating
	.WORD	7$-3$			; 4 - huge floating
4$:	PUSHL	R9			; push the PSL
	PUSHAB	B^10$			; push the POLYF instruction location
	BRB	9$			; bypass
5$:	PUSHL	R9			; push the PSL
	PUSHAB	B^11$			; push the POLYD instruction location
	BRB	9$			; bypass
6$:	PUSHL	R9			; push the PSL
	PUSHAB	B^12$			; push the POLYG instruction location
	BRB	9$			; bypass
7$:	BLBC	R8,8$			; FPD not requested in PSL - bypass
	MOVL	REG_SP(R6),R10		; R10 = location of stacked argument
	MOVQ	8(R10),-(SP)		; push the last part of the argument
	MOVQ	(R10),-(SP)		; push the first part of the argument
8$:	PUSHL	R9			; push the PSL
	PUSHAB	B^13$			; push the POLYH instruction location
9$:	CLRL	R8			; clear the instruction outcome
	REI				; execute the POLYx instruction
10$:	POLYF	#1.0,#1,B^FLOAT_TABLE	; execute the POLYF instruction
	MOVPSL	R9			; R9 = resulting PSL value
	RET				; return
11$:	POLYD	#1.0,#1,B^DOUBLE_TABLE	; execute the POLYD instruction
	MOVPSL	R9			; R9 = resulting PSL value
	RET				; return
12$:	POLYG	#1.0,#1,B^GRAND_TABLE	; execute the POLYG instruction
	MOVPSL	R9			; R9 = resulting PSL value
	RET				; return
13$:	POLYH	#1.0,#1,B^HUGE_TABLE	; execute the POLYH instruction
	MOVPSL	R9			; R9 = resulting PSL value
	RET				; return
	;
	;	Coefficients for POLYF Instruction
	;
FLOAT_TABLE:
	.LONG	^X FFFF7FFF		; largest floating value
	.LONG	^X FFFF7FFF		; largest floating value
	;
	;	Coefficients for POLYD and POLYG Instructions
	;
DOUBLE_TABLE:
GRAND_TABLE:
	.LONG	^X FFFF7FFF		; largest double or grand value
	.LONG	^X FFFFFFFF
	.LONG	^X FFFF7FFF		; largest double or grand value
	.LONG	^X FFFFFFFF
	;
	;	Coefficients for POLYH Instruction
	;
HUGE_TABLE:
	.LONG	^X FFFF7FFF		; largest huge floating value
	.LONG	^X FFFFFFFF
	.LONG	^X FFFFFFFF
	.LONG	^X FFFFFFFF
	.LONG	^X FFFF7FFF		; largest huge floating value
	.LONG	^X FFFFFFFF
	.LONG	^X FFFFFFFF
	.LONG	^X FFFFFFFF
	;

	;
	;	POLY_HANDLER - Condition Handler for POLYx Execution
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;
	;	    This routine is the condition handler for XQT_POLY which
	;	executes one of the POLYx instructions. When exceptions (other
	;	than opcode reserved to DEC which is resignaled) the type of
	;	exception is saved in R8 and the XQT_POLY frame is unwound
	;	with all of the registers intact. If the exception is an
	;	access violation, then the reason mask and the accessed 
	;	address are saved in designated areas in the frame. If the
	;	condition does not originate within the routine, then it is
	;	resignaled.
	;
POLY_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0 and R1 = locations of arrays
	TSTL	8(R1)			; condition from establisher frame ?
	BNEQ	2$			; no - bypass
	MOVL	4(R0),R8		; R8 = condition code
	CMPL	#SS$_OPCDEC,R8		; opcode reserved to DEC ?
	BRB	2$			; yes - it's for the Emulator
	CMPL	#SS$_ACCVIO,R8		; access violation ?
	BNEQ	1$			; no - bypass
	MOVB	8(R0),ACCVIO_REASON(R6) ; save the reason mask
	MOVL	12(R0),ACCVIO_ADDRESS(R6) ; save the accessed address
	CLRQ	-(SP)			; default PC and level for unwind
1$:	CALLS	#2,G^SYS$UNWIND 	; unwind the frame for XQT_POLY
2$:	CVTWL	#SS$_RESIGNAL,R0	; specify condition not handled
	RET
	;

	;
	;	Condition Signaling Routines
	;	----------------------------
	;
	;	General Discussion
	;
	;	    The following routines signal the various types of 
	;	conditions that that the input fault types can be converted
	;	into. This is done by pushing an abbreviated form of the
	;	signal vector (with the PC, PSL pair missing) and branching
	;	to SIGNAL_START. If the signaled condition is a trap then
	;	the FPD bit is cleared in the PSL. If the signaled condition
	;	is a fault, then the TP bit is cleared in the PSL and the 
	;	simulated PC is changed to the instruction location. For 
	;	access violations, the reason mask and the accessed address
	;	are taken from the designated cells in the frame.
	;
	;
	;	Signal an Access Violation
	;
ACCESS_FAULT:				; entrance
	PUSHL	ACCVIO_ADDRESS(FP)	; push the accessed address
	PUSHL	ACCVIO_REASON(FP)	; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of parameters
	MOVL	INST_ADDRESS(FP),REG_PC(FP) ; restore the instruction address
	BBCC	#PSL_TP,PSL(FP),1$	; clear the trace pending bit
1$:	BRB	SIGNAL_START		; signal the condition
	;
	;	Signal a Reserved Operand Fault
	;
OPERAND_FAULT:				; entrance
	CVTWL	#SS$_ROPRAND,-(SP)	; push the condition code
	PUSHL	#1			; push the number of parameters
	MOVL	INST_ADDRESS(FP),REG_PC(FP) ; restore the instruction address
	BBCC	#PSL_TP,PSL(FP),1$	; clear the trace pending bit
1$:	BRB	SIGNAL_START		; signal the condition
	;
	;	Signal a Floating Underflow Trap
	;
UNDERFLOW_TRAP: 			; entrance
	BBCC	#PSL_FPD,PSL(FP),1$	; clear FPD in the PSL
1$:	CVTWL	#SS$_FLTUND,-(SP)	; push the condition code
	PUSHL	#1			; push the number of parameters
	BRB	SIGNAL_START		; signal the condition
	;
	;	Signal a Floating Overflow Trap
	;
OVERFLOW_TRAP:				; entrance
	BBCC	#PSL_FPD,PSL(FP),1$	; clear FPD in the PSL
1$:	CVTWL	#SS$_FLTOVF,-(SP)	; push the condition code
	PUSHL	#1			; push the number of parameters
	BRB	SIGNAL_START		; signal the condition
	;
	;	Signal a Floating/Decimal Divide by Zero Trap
	;
DIVIDE_TRAP:				; entrance
	CVTWL	#SS$_FLTDIV,-(SP)	; push the condition code
	PUSHL	#1			; push the number of parameters
	BRB	SIGNAL_START		; signal the condition
	;

	;
	;	SIGNAL_START - Build the Parameter Blocks for SIGNAL
	;
	;		entered by branching
	;
	;		parameters:	(SP) = Truncated Signal Array Size (M)
	;				4(SP) = Condition Code
	;				8(SP) = First Signal Argument
	;				  .
	;				  .
	;				  .
	;				4*<M-1>(SP) = Last Signal Argument
	;
	;	Discussion
	;
	;	    This routine builds the signal and mechanism arrays
	;	for a condition generated by the converter. It is entered
	;	with the signal array for the condition except for the
	;	PC and PSL pair pushed onto the converter's stack (with the
	;	pushed array length correspondingly shortened). The signal
	;	array, mechanism array, and the handler parameter block
	;	are then constructed on the user's emulated stack. The routine
	;	then removes the converter frame from the stack and enters
	;	the signal dispatching loop at SIGNAL.
	;
	;	Notes:	1. The precise format of the information pushed onto
	;		   the user's stack is given in the description of
	;		   SIGNAL below.
	;
	;		2. The method of getting out of the converter consists
	;		   of adjusting the alignment bits and the parameter
	;		   count for the converter's frame so that the stack
	;		   pointer upon return is just where we want it to be.
	;		   Before returning, the return PC in the frame is 
	;		   changed to the place we want to branch to.
	;
SIGNAL_START:				; entrance
	MOVL	REG_SP(FP),R6		; R6 = user's SP
	MOVQ	REG_PC(FP),-(R6)	; push the user's PC and PSL
	MOVL	(SP)+,R7		; R7 = number of signal parameters
	ASHL	#2,R7,R8		; R8 = number of bytes to move
	SUBL2	R8,R6			; extend the user stack
	MOVC3	R8,(SP),(R6)		; move the parameters
	ADDL3	#2,R7,-(R6)		; push the signal array length
	MOVL	#1,-(R6)		; push code for SIGNAL (vs. STOP)
	MOVQ	REG_R0(FP),-(R6)	; push the user's R0 and R1
	MNEGL	#3,-(R6)		; push -3 (depth number)
	MOVL	REG_FP(FP),-(R6)	; push the user's FP
	MOVL	#4,-(R6)		; push the mechanism array length
	MOVL	R6,-(R6)		; push the mechanism array location
	MOVAB	28(R6),-(R6)		; push the signal array location
	MOVL	#2,-(R6)		; push the handler parameter count
	MOVAB	FRAME_END+4(FP),R0	; R0 = end of call frame + 4
	SUBL2	R0,R6			; R6 = distance to user's SP
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put AP and FP back into place
	MOVAB	B^SIGNAL,SAVE_PC(FP)	; store the return PC
	EXTZV	#0,#2,R6,R1		; R1 = stack alignment bits
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store them
	ADDL2	R1,R0			; compute the argument count location
	ASHL	#-2,R6,-4(R0)		; store the argument count
	RET				; return (to SIGNAL)
	;

	;
	;	SIGNAL - Signal the Condition
	;
	;		entered by branching
	;
	;		parameters:	( Described in Note 3 )
	;
	;	Discussion
	;
	;		   Following is a description of the information which
	;		   is assumed to be pushed onto the stack when the
	;		   routine SIGNAL is entered. The values are all
	;		   longwords.
	;
	;		   Handler Parameter Block:
	;
	;			(SP)	2 (handler parameter block length)
	;			4(SP)	signal array location
	;			8(SP)	mechanism array location
	;
	;		   Mechanism Array:
	;
	;			12(SP)	4 (mechanism array length)
	;			16(SP)	user's FP (establisher frame)
	;			20(SP)	-3 (establisher depth)
	;			24(SP)	user's R0
	;			28(SP)	user's R1
	;
	;		   Information Not Part of any Array:
	;
	;			32(SP)	1 (code for SIGNAL)
	;
	;		   Signal Array:
	;
	;			36(SP)	signal array length M
	;			40(SP)	condition code
	;			44(SP)	first signal argument
	;			  .
	;			  .
	;			  .
	;			<4*M>+28(SP) last signal argument
	;			<4*M>+32(SP) user's PC
	;			<4*M>+36(SP) user's PSL
	;
	;		   The user's stack pointer should coincide with the
	;		   address <4*M>+40(SP).
	;
	;	Jump to the VMS routine which looks for handlers to call.
	;	Execution will not return to us.
	;-

SIGNAL: 				; entrance
	JMP	G^SYS$SRCHANDLER


;	************************************************************************
;	*								       *
;	*								       *
;	*		End of VAX/VMS Common RTL File LIBSIMTRA.MAR	       *
;	*								       *
;	*								       *
;	************************************************************************

	.END
