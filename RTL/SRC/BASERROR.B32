MODULE BAS$ERROR (				! Error processing
		IDENT = '1-066'		! File: BASERROR.B32 Edit: PL1066
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!

!++
! FACILITY:  VAX-11 BASIC Error Handling
!
! ABSTRACT:
!
!	This module contains the VAX-11 BASIC error handling logic.
!	The error data base is OWN to this module.
!
! ENVIRONMENT:  VAX-11 user mode
!
! AUTHOR: John Sauter, CREATION DATE: 17-Oct-78
!
! MODIFIED BY:
!
! 1-001	- Original.  JBS 27-NOV-78
! 1-002	- Remove BAS$$SIGNAL_IO and BAS$$STOP_IO.  They now live in
!	   their own module.  JBS 08-DEC-78
! 1-003	- Add global definitions of BAS$_abcmnoxyz symbols.  JBS 11-DEC-78
! 1-004	- Include severity in those definitions.  JBS 19-DEC-78
! 1-005	- If the compiled code does not do any error processing,
!	   either continue, restart the line or exit.  JBS 28-DEC-78
! 1-006	- Call BAS$$CB_CLEANUP to flush active I/O when unwinding.
!	   JBS 29-DEC-78
! 1-007	- Change BAS$$CB_CLEANUP to OTS$CLEANUP_IO.  JBS 09-JAN-1979
! 1-008	- When restarting an I/O statement, do an UNWIND to the
!	   beginning of the I/O statement.  JBS 26-JAN-1979
! 1-009	- Remove OTS$CLEANUP_IO, since we will do I/O cleanup using
!	   a stack frame.  JBS 26-JAN-1979
! 1-010	- When searching for a line number corresponding to a PC,
!	   look in the right place in the table.  JBS 30-JAN-1979
! 1-011	- When getting storage for the SIGNAL argument list, get enough
!	   for the argument count and the two trailing longwords, even
!	   though this may sometimes be a little more than is needed.
!	   JBS 31-JAN-1979
! 1-012	- Purge the terminal output buffer before printing an error
!	   message.  JBS 02-FEB-1979
! 1-013	- Add support for I/O lists and change the name of the prefix
!	   for stack frames from BAS$ to BSF$.  JBS 08-FEB-1979
! 1-014	- Because control C puts some non-BASIC frames on the stack,
!	   be cleverer about searching through stack frames for a
!	   non-GOSUB frame.  JBS 20-FEB-1979
! 1-015	- In BAS$$SIGNAL, don't force the severity to SEVERE ERROR
!	   by calling LIB$STOP.  JBS 20-FEB-1979
! 1-016	- Search the PC table from back to front so that the line numbers
!	   from statements which generate no code, such as DATA statements,
!	   will not appear.  JBS 22-FEB-1979
! 1-017	- Use OTS$$PUR_IO_ERR to purge I/O buffers, thus avoiding having
!	   to REQUIRE all of the I/O data structures.  JBS 07-MAR-1979
! 1-018	- Concatenate a ?, % or space on the front of error messages
!	   in BAS$ERT based on the severity of the error.  JBS 12-MAR-1979
! 1-019 - In BAS$ERT, don't clobber the length field of a dynamic
!	   string.  JBS 22-MAR-1979
! 1-020	- Change name of ILLEGAL RESUME.  JBS 02-APR-1979
! 1-021	- Make BAS$$COND_VAL global, so BAS$$SIGNAL_IO can use it.
!	   JBS 06-APR-1979
! 1-022	- Only restart statements after restartable I/O failures if
!	   the I/O was to a terminal.  JBS 06-APR-1979
! 1-023	- RESUME with no line number will resume into another module.
!	   JBS 12-APR-1979
! 1-024	- The compiled code can get SS$_SUBRNG.  JBS 15-APR-1979
! 1-025	- Correct an error in edit 022.  JBS 16-APR-1979
! 1-026	- Correct an error in unwinding from a RESUME with no
!	   line number.  JBS 30-APR-1979
! 1-027	- If the line number is not found, take the line number
!	   corresponding to the next earlier PC.  This is needed
!	   because (contrary to the specification) the compiler
!	   does not put its "fake line numbers" in the line number
!	   table.  JBS 04-MAY-1979
! 1-028	- If we are restarting an I/O statement, call BAS$$RESTART_IO
!	   to reinitialize the I/O data base.  JBS 07-MAY-1979
! 1-029	- If we are doing system handling on an INFO message, don't
!	   promote it to a warning.  JBS 10-MAY-1979
! 1-030	- If we convert a system message to a BASIC message, be sure
!	   the PC and PSL of the failure are reported.  JBS 11-MAY-1979
! 1-031	- Publish the PC and PSL for any converted message.
!	   JBS 13-MAY-1979
! 1-032 - Include certain string error codes in the list of messages
!	   which are converted to BASIC-specific errors.  JBS 16-MAY-1979
! 1-033	- Convert LIB$S and OTS$S to STR$.  JBS 21-MAY-1979
! 1-034	- Correct an error in BAS$$USER_HAND which prevented intercepting
!	   an error that had once been through ON ERROR GO BACK.
!	   JBS 29-MAY-1979
! 1-035	- Add BAS$$ERR_INIT.  JBS 04-JUN-1979
! 1-036	- Call BAS$$UNWIND when cutting back a frame.  JBS 06-JUN-1979
! 1-037	- Defer calling SYS$UNWIND to the top level handler.
!	   JBS 06-JUN-1979
! 1-038	- BAS$$ERR_INIT must clear SYSTEM_ERROR and GONE_BACK.
!	   JBS 07-JUN-1979
! 1-039	- RESUME to a line number must accumulate the number of frames
!	   to unwind.  JBS 10-JUL-1979
! 1-040	- Change call to STR$COPY.  JBS 16-JUL-1979
! 1-041	- Fix a bug which caused GONE_BACK to remain set after an UNWIND.
!	   JBS 23-JUL-1979
! 1-042	- When unwinding to a frame, POP its I/O.  JBS 24-JUL-1979
! 1-043	- Change call to OTS$$TERM_IO.  JBS 26-JUL-1979
! 1-044	- Remove edit 023: don't allow RESUME into another module.
!	   JBS 26-JUL-1979
! 1-045	- Give error 31 (illegal byte count for I/O) in response to
!	   an attempt to do I/O to a closed file.  JBS 01-AUG-1979
! 1-046	- Don't try to build an argument list for LIB$SIGNAL longer
!	   than 255.  JBS 08-AUG-1979
! 1-047	- Correct a typo in edit 044.  JBS 20-AUG-1979
! 1-048	- Call BAS$$PUR_IO_ERR.  JBS 20-AUG-1979
! 1-049	- Translate MTH$_FLOOVEMAT into floating overflow, since it
!	   is produced by both the EXP and TAN functions.  JBS 20-AUG-1979
! 1-050	- Change BAS$HANDLER to BAS$$HANDLER for the sharable library.
!	   JBS 20-AUG-1979
! 1-051	- Move the definitions of the error codes to BAS$MSGDEF, for
!	   the sake of the shared library.  JBS 21-AUG-1979
! 1-052	- Remove the redundent RETURN statement, the BLISS compiler no
!	   longer needs it.  JBS 06-SEP-1979
! 1-053	- Add BAS$PUSH_ERR and BAS$POP_ERR.  JBS 10-SEP-1979
! 1-054	- Change IOL from I/O list to Immediate On-Line.  JBS 10-SEP-1979
! 1-055	- If a BASIC condition is signalled as INFO, don't promote
!	   it to a more severe condition.  This is needed for the
!	   two kinds of control C signals for the RUN command.
!	   JBS 14-SEP-1979
! 1-056	- Change MTH$_SINCOSSIG to MTH$_SIGLOSMAT.  JBS 19-SEP-1979
! 1-057	- Add STR$_STRTOOLON.  JBS 31-OCT-1979
! 1-058	- Make ERR, ERL and ERN$ retain their values after RESUME.
!	   JBS 07-NOV-1979
! 1-059	- Fix restarting an I/O statement to clear the error flag.
!	   JBS 08-NOV-1979
! 1-060	- Make sure that a user error handler doesn't try to handle
!	   INFO conditions.  This is a part of edit 055.  JBS 15-NOV-1979
! 1-061	- Handle correctly a main program with ON ERROR GO BACK getting
!	   a restartable error.  JBS 09-JAN-1980
! 1-062	- Handle delta PC values greater than 2^15.  JBS 12-FEB-1980
! 1-063	- Handle error trapping in a module without line numbers, except for
!	   RESUME with no line number.  JBS 07-MAR-1980
! 1-064 - Treat floating faults the same as traps IN BAS$$HANDLER.  SBL 10-Jun-1980
! 1-065 - Distiguish between a major and a minor frame in BAS$$USER_HAND, so
!	  when an error is ON ERROR GO BACK|TO 0 in a minor frame the major
!	  frame can handle the error. FM 13-FEB-81.
! 1-066 - Comments referring to SYSMSG.MPF are using an obsolete name; the name
!	  should be SYS$MESSAGE:SYSMSG.EXE. PL 26-Aug-81
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

LINKAGE
    RESTART_LINK = JSB : NOTUSED (11, 10, 9)
    NOPRESERVE (8, 7, 6, 5, 4, 3, 2);

REQUIRE 'RTLIN:OTSLNK';				! Define common linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$$SIGNAL : NOVALUE,			! signal an error
    BAS$$STOP : NOVALUE,			! signal an error
    BAS$$COND_VAL,				! compute VAX/VMS cond value
    PC_TO_LINE_NO,				! convert PC to line number
    BAS$$LINE,					! get the number of the current line
    BAS$$FUNCTION,				! get the name of the current function
    BAS$$MODULE,				! get the name of the current module
    HANDLER_HANDLER,				! handler for BAS$HANDLER
    RESTART : RESTART_LINK NOVALUE,		! unwind target
    RESTART_IO : RESTART_LINK NOVALUE,		! unwind target for I/O
    BAS$$USER_HAND,				! try to let user handle error
    BAS$RESUME,					! resume from a condition handler
    BAS$RESUME_Z,				! likewise, but no line number
    BAS$ON_ERR_Z,				! ON ERROR GOTO 0
    BAS$ON_ERR_BK,				! ON ERROR GO BACK
    BAS$$HANDLER,				! handle a BASIC-PLUS-2 error
    BAS$ERL,					! return error line number
    BAS$ERR,					! return current error number
    BAS$ERN,					! return module name of error
    BAS$ERT,					! return text of error number
    BAS$ERROR : NOVALUE,			! signal an error from compiled code
    BAS$$ERR_INIT : NOVALUE,			! Initialize for the RUN command
    BAS$PUSH_ERR,				! Save error info
    BAS$POP_ERR;				! Restore error info

!
! INCLUDE FILES:
!

LIBRARY 'RTLSTARLE';				! system symbols

REQUIRE 'RTLIN:RTLPSECT';			! macros to declare psects

REQUIRE 'RTLIN:BASFRAME';			! define frame structure

REQUIRE 'RTLIN:BASERRMSG';			! Define ERROR_LIST macro.

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!+
! Define the special error codes used for I/O errors and traceback.
!-

LITERAL
    ERR_TRACE_MAIN = 4089,			! main program
    ERR_TRACE_SUB = 4090,			! external subroutine
    ERR_TRACE_EXTF = 4091,			! external function
    ERR_TRACE_DEF = 4092,			! DEF procedure
    ERR_TRACE_DEFS = 4093,			! DEF* procedure
    ERR_TRACE_GOSB = 4094,			! GOSUB
    ERR_TRACE_ONER = 4095,			! condition handler
    ERR_TRACE_IOLST = 4087,			! Immediate mode code
    ERR_TRACE_PCPSL = 4086;			! user PC=!XL, PSL=!XL

!+
! Define the return values from BAS$$USER_HAND.
!-

LITERAL
    USER_HAND_CONT = 0,				! Continue from point of error (or of unwind)
    USER_HAND_BACK = 1,				! Try caller's handler
    USER_HAND_FAIL = 2;				! Force system error processing

!+
! Define the return values from the user's error handler.
! None of those below implies RESUME with a line number.
!-

LITERAL
    USER_ERR_RSUMZ = 0,				! RESUME with no line number
    USER_ERR_GOBK = 1,				! ON ERROR GO BACK
    USER_ERR_OEGZ = 2;				! ON ERROR GOTO 0

!+
! Define the coded values for system error handling.
!-

LITERAL
    K_SYS_CONT = 1,				! Continue in line
    K_SYS_EXIT = 2,				! Exit the image (LIB$STOP)
    K_SYS_RESTART = 3;				! Restart the line which had the error

!
! PSECTS:
!
DECLARE_PSECTS (BAS);
!
! OWN STORAGE:
!

OWN
    BAS$L_ERRFLG : INITIAL (0),			! 1 = error in progress
    BAS$T_ERN : BLOCK [8, BYTE] INITIAL (BYTE ( REP 8 OF (0))),	! descriptor for module name
    BAS$L_ERR : INITIAL (0),			! current error code
    BAS$L_ERL : INITIAL (0),			! line number of error
    HIGHEST_LEVEL : INITIAL (0),		! Level to unwind to on RESUME
    HIGHEST_FMP : INITIAL (0),			! Frame to unwind to on RESUME
    ACCUM_LEVEL : INITIAL (0),			! Level to unwind to on RESUME with a line number
    UNWIND_COUNT : INITIAL (0),			! Level for top handler to unwind
    SYSTEM_ERROR : INITIAL (0),			! Set for "fatal fatal" error
    GONE_BACK : INITIAL (0),			! Set for ON ERROR GO BACK
    ERROR_STACK : VOLATILE VECTOR [2] INITIAL (0, 0),	! Error stack
    ERROR_STACK_INI : VOLATILE INITIAL (0);	! Init flag for ERROR_STACK

!+
! Some OWN storage is needed so that communication can take place
! between levels of BAS$$USER_HAND and to RESTART.
!-

OWN
    BAS$A_CH_CUR_LN : INITIAL (0),		! restart PC
    BAS$L_GOING_BACK : INITIAL (0),		! 1 when "going back"
    BAS$A_RESTART : INITIAL (0);		! restart PC

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$MATCH_COND,				! match condition codes
    LIB$SIGNAL : NOVALUE,			! system error signaller
    LIB$STOP : NOVALUE,				! system fatal error signaller
    SYS$UNWIND,					! unwind the stack
    LIB$FIXUP_FLT,				! fix up reserved operands
    LIB$GET_VM,					! get storage
    LIB$FREE_VM,				! free storage
    STR$CONCAT,					! Concatenate two strings
    STR$COPY_R,					! Copy a string by ref
    STR$COPY_DX,				! Copy a string by desc
    SYS$GETMSG,					! get the message text for a signal condition
    BAS$INIT_ONERR,				! run a condition handler
    BAS$$RESTART_IO,				! Restart an I/O statement
    BAS$$PUR_IO_ERR : NOVALUE,			! Purge I/O on an error
    OTS$$TERM_IO,				! Test for terminal I/O
    BAS$$UNWIND : NOVALUE,			! Purge a frame
    BAS$$UNWIND_IO : NOVALUE,			! Purge a frame's I/O
    BAS$HANDLER;				! Header for condition handler

!+
! The following symbols are defined in module BAS$MSGDEF
!-

EXTERNAL LITERAL
    BAS$K_FAC_NO : UNSIGNED (12),		! Facility code
    BAS$K_RESNO_ERR : UNSIGNED (8),		! RESUME with no error
    BAS$K_ILLRESSUB : UNSIGNED (8),		! Illegal RESUME to subroutine
    BAS$K_DIVBY_ZER : UNSIGNED (8),		! Divide by zero
    BAS$K_IMASQUROO : UNSIGNED (8),		! Imaginary square root
    BAS$K_ILLARGLOG : UNSIGNED (8),		! Illegal argument to LOG
    BAS$K_INTERR : UNSIGNED (8),		! Integer error
    BAS$K_MEMMANVIO : UNSIGNED (8),		! Memory management violation
    BAS$K_FLOPOIERR : UNSIGNED (8),		! Floating point error
    BAS$K_SUBOUTRAN : UNSIGNED (8),		! Subscript out of rnage
    BAS$K_MAXMEMEXC : UNSIGNED (8),		! Maximum memory exceeded
    BAS$K_ILLBYTCOU : UNSIGNED (8),		! Illegal byte count for I/O
    BAS$_ON_CHAFIL,				! " on channel n, file a"
    BAS$K_PROLOSSOR : UNSIGNED (8),		! Program lost, sorry.
    BAS$K_STRTOOLON : UNSIGNED (8);		! String too long

!+
! The following VAX/VMS condition codes are used in this module
!-

EXTERNAL LITERAL
!+
! Attempt to compute the square root of a negative number.
! The result will be the reserved operand.
!-
    MTH$_SQUROONEG,
!+
! Attempt to compute the logarithm of 0, or of a negative number.
! The result will be the reserved operand.
!-
    MTH$_LOGZERNEG,
!+
! Attempt to raise E to a power so large that the result cannot
! be represented by the computer.  That power is about 88.  The
! result will be the reserved operand.
!-
    MTH$_FLOOVEMAT,
!+
! Attempt to raise a base, B, to a power, P, where this is undefined.
! For example, 0 raised to the 0 power is undefined.  The result
! will be the reserved operand.
!-
    MTH$_UNDEXP,
!+
! Attempt to take the SINE or COSINE of a number so large that,
! after taking the number modulo 2 PI, there is no information
! left.  This is caused by the fact that the computer keeps
! only the highest-order significant bits of a number.  The
! result will be the reserved operand.  Other functions in the
! math library may also signal this under similar conditions.
!-
    MTH$_SIGLOSMAT,
!+
! Attempt to allocate a dynamic string when there is
! not enough virtual memory left to hold it along with
! all of the other strings allocated.
!-
    STR$_INSVIRMEM,
!+
! Divide by zero in string arithmetic.
!-
    STR$_DIVBY_ZER,
!+
! Attempt to create a string longer than 65535 characters,
! the maximum length allowed by the VAX-11 string architecture.
! This can be the result of, for example, the concatenation of
! two 50,000 character strings.
!-
    STR$_STRTOOLON,
!+
! Attempt to continue to do I/O to a closed file.
! (That is, the file was closed between element
! transmitters, and another element transmission
! was attempted.)
!-
    OTS$_IO_CONCLO;

!+
! Attempt to divide a real number by 0.
!
!   SS$_FLTDIV			! (defined in RTLSTARLE)
!   SS$_FLTDIV_F (fault)	! (defined in RTLSTARLE)
!
! Attempt to divide an integer by 0.
!
!   SS$_INTDIV			! (defined in RTLSTARLE)
!
! Attempt to compute a floating point result which the computer
! cannot represent.
!
!   SS$_FLTOVF			! (defined in RTLSTARLE)
!   SS$_FLTOVF_F (fault)	! (defined in RTLSTARLE)
!
! Attempt to compute an integer result which the computer cannot
! represent.
!
!   SS$_INTOVF			! (defined in RTLSTARLE)
!
! Reserved operand fault.  In the context of BASIC, this is usually
! caused by an attempt to refer to a reserved floating operand, but
! it can be caused by other errors.  Only the floating reserved
! operand case is handled by BASIC.
!
!   SS$_ROPRAND			! (define in RTLSTARLE)
!
! Attempt to refer to an invalid address.  This can happen if
! range checking on array indicies is defeated.
!
!   SS$_ACCVIO			! (defined in RTLSTARLE)
!
! Attempt to use an index outside its proper range.  This can happen
! when the compiler generates in-line array indexing.
!
!   SS$_SUBRNG			! (defined in RTLSTARLE)
!
!<BLF/PAGE>

!
! Define the severity code for each possible error.
!

MACRO
    ERR (NUMBER, CODE, TEXT, SEVERITY, SYSTEM_HANDLING) =
	(%IF (%IDENTICAL (SEVERITY, WARNING)) %THEN STS$K_WARNING %ELSE
	%IF (%IDENTICAL (SEVERITY, SUCCESS)) %THEN STS$K_SUCCESS %ELSE
	%IF (%IDENTICAL (SEVERITY, ERROR)) %THEN STS$K_ERROR %ELSE
	%IF (%IDENTICAL (SEVERITY, INFO)) %THEN STS$K_INFO %ELSE
	%IF (%IDENTICAL (SEVERITY, SEVERE)) %THEN STS$K_SEVERE %ELSE
	257 %FI %FI %FI %FI %FI) 
    %;

BIND
    ERR_SEVERITY = UPLIT BYTE(ERROR_LIST) : VECTOR [256, BYTE];

UNDECLARE %QUOTE
    ERR;

!
! Define the system handling option for each error.
!

MACRO
    ERR (NUMBER, CODE, TEXT, SEVERITY, SYSTEM_HANDLING) =
	(%IF (%IDENTICAL (SYSTEM_HANDLING, CONT)) %THEN K_SYS_CONT %ELSE
	%IF (%IDENTICAL (SYSTEM_HANDLING, EXIT)) %THEN K_SYS_EXIT %ELSE
	%IF (%IDENTICAL (SYSTEM_HANDLING, RESTART)) %THEN K_SYS_RESTART %ELSE
	257 %FI %FI %FI)
    %;

BIND
    ERR_SYSTEM = UPLIT BYTE(ERROR_LIST) : VECTOR [256, BYTE];

UNDECLARE %QUOTE
    ERR;

!<BLF/PAGE>

!+
! The following field set represents an item pushed onto the
! error stack.  It contains the entire state of the error system.
! It is used when it is necessary to save the error state to run
! the compiler to compile an immediate mode statement.
!-

FIELD
    PUSH_ITEM =
	SET
	PUSH$A_NEXT = [0, 0, %BPVAL, 0],	! Next item
	PUSH$A_PREV = [4, 0, %BPVAL, 0],	! Previous item
	PUSH$L_ERRFLG = [8, 0, %BPVAL, 0],	! 1 = error in progress
	PUSH$T_ERN = [12, 0, 0, 0],		! Module name of error
	PUSH$L_ERR = [20, 0, %BPVAL, 0],	! Error number
	PUSH$L_ERL = [24, 0, %BPVAL, 0],	! Line number of error
	PUSH$L_HGH_LVL = [28, 0, %BPVAL, 0],	! Level for RESUME
	PUSH$A_HGH_FMP = [32, 0, %BPADDR, 0],	! Frame for RESUME
	PUSH$L_ACC_LVL = [36, 0, %BPVAL, 0],	! Level for RESUME-line
	PUSH$L_UNW_CNT = [40, 0, %BPVAL, 0],	! Amount to unwind at top
	PUSH$L_SYS_ERR = [44, 0, %BPVAL, 0],	! 1 = "fatal fatal" error
	PUSH$L_GONE_BAK = [48, 0, %BPVAL, 0],	! 1 = ON ERROR GO BACK
	PUSH$A_CUR_LIN = [52, 0, %BPADDR, 0],	! Restart PC
	PUSH$L_GOING_BACK = [56, 0, %BPVAL, 0],	! Restart flag
	PUSH$A_RESTART = [60, 0, %BPADDR, 0]	! Real restart PC
	TES;

LITERAL
    PUSH$K_LENGTH = 64;				! Number of bytes to allocate


GLOBAL ROUTINE BAS$$SIGNAL (			! signal an error
	ERR_CODE				! the BASIC error code
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Signal an error for BASIC-PLUS-2/VAX.  The argument is the
!	BASIC-PLUS-2 error code.
!
! FORMAL PARAMETERS:
!
!	ERR_CODE.rl.v	The BASIC-PLUS-2 error code.  The codes and
!			their meanings are listed in file BASERRMSG.REQ.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May never return to the caller.
!
!--

    BEGIN

    LOCAL
	VAX_11_COND_VAL : BLOCK [4, BYTE];	! 32-bit VAX/VMS condition value

    VAX_11_COND_VAL = BAS$$COND_VAL (.ERR_CODE);
!+
! The line number, module name and function name are added in
! BAS$HANDLER for each level that this signal goes through.
!-
    LIB$SIGNAL (.VAX_11_COND_VAL);
    END;					! of BAS$$SIGNAL


GLOBAL ROUTINE BAS$$STOP (			! signal an error
	ERR_CODE				! the BASIC error code
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Signal an error for BASIC-PLUS-2/VAX.  The argument is the
!	BASIC-PLUS-2 error code.
!
! FORMAL PARAMETERS:
!
!	ERR_CODE.rl.v	The BASIC-PLUS-2 error code.  The codes and
!			their meanings are listed in file BASERRMSG.REQ.
!			The severity must be ERROR or SEVERE ERROR.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Never returns to the caller.
!
!--

    BEGIN

    LOCAL
	VAX_11_COND_VAL : BLOCK [4, BYTE];	! 32-bit VAX/VMS condition value

    VAX_11_COND_VAL = BAS$$COND_VAL (.ERR_CODE);
!+
! The line number, module name and function name are added in
! BAS$HANDLER for each level that this signal goes through.
!-
    LIB$STOP (.VAX_11_COND_VAL);
    END;					! of BAS$$STOP


GLOBAL ROUTINE BAS$$COND_VAL (			! Compute condition value
	ERR_CODE				! BASIC error code
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert a BASIC error code to its 32-bit VAX/VMS error code.
!	Conversion is done by copying the BASIC error number to the
!	code field, setting the severity field based on the entry in
!	the severity table for the code, and setting the facility
!	to BAS$K_FAC_NO.  The facility specific bit is also set.
!
! FORMAL PARAMETERS:
!
!	ERR_CODE.rl.v	The BASIC-PLUS-2 error code.  The codes and
!			their meanings are listed in file BASERRMSG.REQ.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The 32-bit VAX/VMS error code.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	RESULT : BLOCK [4, BYTE];		! 32-bit VAX/VMS condition value

    RESULT = 0;
    RESULT [STS$V_SEVERITY] = (IF (.ERR_CODE GTRU 255) THEN STS$K_INFO ELSE .ERR_SEVERITY [.ERR_CODE]);
    RESULT [STS$V_CODE] = .ERR_CODE;
    RESULT [STS$V_FAC_SP] = 1;
    RESULT [STS$V_FAC_NO] = BAS$K_FAC_NO;
    RETURN (.RESULT);
    END;					! of BAS$$COND_VAL


ROUTINE PC_TO_LINE_NO (				! Convert PC to line number
	FMP, 					! Frame containing line
	PC					! PC to be converted
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Compute the BASIC line number corresponding to a PC value.
!
! FORMAL PARAMETERS:
!
!	FMP.ra.v	Address of the frame from which we want the
!			line number.
!	PC.rlu.v	The program counter corresponding to the
!			line number.  If no exact match is found, use
!			the next lower PC value.
!
! IMPLICIT INPUTS:
!
!	The (delta PC, line number) table, pointed to by the FCD
!	for the main procedure.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The line number, as a 32-bit binary value.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    LOCAL
	BSF$A_MAJOR_STG : REF BLOCK [0, BYTE] FIELD (BSF$MAJOR_FRAME),
	PC_DELTA_TABLE : REF VECTOR,
	SEARCH_ARG;

!+
! If the PC is zero, the cell that held it must not have been
! set up.  This means that we are trying to find the PC for
! a routine in which the first statement has not yet started
! execution.  Return a zero to indicate this.
!-

    IF (.PC EQLA 0) THEN RETURN (0);

!+
! Load the pointer to the major procedure's frame.
!-
    BSF$A_MAJOR_STG = .FMP [BSF$A_BASE_R11];
!+
! Get a pointer to the (PC delta, line number) table.
! This requires skipping over the text of the module name.
!-
    PC_DELTA_TABLE = .BSF$A_MAJOR_STG [BSF$A_PROC_INFO] + 	!
    ((.(.BSF$A_MAJOR_STG [BSF$A_PROC_INFO])) AND 255) + 1;
!+
! Compute the PC relative to the beginning of the code.
!-
    SEARCH_ARG = .PC - .BSF$A_MAJOR_STG [BSF$A_CODE_BEG];
!+
! Search the table.  If an exact match cannot be found, use the
! line number just before the PC.
!-

    DECR TABLE_INDEX FROM .PC_DELTA_TABLE [0] TO 1 DO
	BEGIN

	IF ((((.PC_DELTA_TABLE [.TABLE_INDEX])^-16) AND 65535) LEQU .SEARCH_ARG)
	THEN
	    RETURN ((.(PC_DELTA_TABLE [.TABLE_INDEX])) AND 65535);

	END;

!+
! We get here only if the number cannot be found in the table.  This
! means that the PC was stored by a fake line number before the first
! real line number.  This is so unreasonable that it is more likely
! due to a bug in either the compiler or the RTL.  To make the problem
! more visible, return a -1.
!-
    RETURN (-1);
    END;					! of PC_TO_LINE_NO

ROUTINE BAS$$LINE (				! Get current line number
	FMP					! Current frame
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Compute the number of the line now in execution.  At the
!	beginning of each line, the BASIC compiler issues
!
!		MOVAB	-3(PC),BSF$A_MARK(FP)
!
!	which stores the PC of the MOVAB.  This routine then
!	scans the PC delta table (also produced by the compiler)
!	to find the correct line number.
!
! FORMAL PARAMETERS:
!
!	FMP.ra.v	Address of the frame from which we want the
!			line number.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The line number, as a 32-bit binary value.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    RETURN (PC_TO_LINE_NO (.FMP, .FMP [BSF$A_MARK]));
    END;					! of BAS$$LINE

ROUTINE BAS$$FUNCTION (				! Get current function name
	FMP					! Current frame
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Get the name of the function now in execution.  It is
!	obtained from the BSF$A_PROC_ID field of the frame.
!	The format depends on the frame type.  For the types
!	which have no name, the "name" is returned as a line
!	number, and the caller expects this.  In other cases,
!	the name is returned as a pointer to a counted string.
!
! FORMAL PARAMETERS:
!
!	FMP.ra.v	Address of the frame from which we want the
!			function name.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The function name, as a pointer to a counted string for
!	main procedures, subprograms, external functions, DEFs
!	and DEF*s.  The name is returned as a 32-bit line number
!	for GOSUBs and condition handlers.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    RETURN (CASE .FMP [BSF$B_PROC_CODE] FROM BSF$K_PROC_MAIN TO BSF$K_PROC_IOL OF
	    SET
	    [BSF$K_PROC_MAIN, BSF$K_PROC_SUB, BSF$K_PROC_EXTF, BSF$K_PROC_DEF, BSF$K_PROC_DEFS] : 	!
		.FMP [BSF$A_PROC_ID];
	    [BSF$K_PROC_GOSB, BSF$K_PROC_ONER, BSF$K_PROC_IOL] : 	!
		PC_TO_LINE_NO (.FMP, .FMP [BSF$A_PROC_ID]);
	    [OUTRANGE] : 0;
	    TES);
    END;					! of BAS$$FUNCTION

ROUTINE BAS$$MODULE (				! Get current module name
	FMP					! Current frame
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Get the name of the module now in execution.  It is
!	obtained from the BSF$A_PROC_ID field of the frame.
!	It is returned as a pointer to a counted string.
!
! FORMAL PARAMETERS:
!
!	FMP.ra.v	Address of the frame from which we want the
!			module name.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The module name, as a pointer to a counted string.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    LOCAL
	BSF$A_MAJOR_STG : REF BLOCK [0, BYTE] FIELD (BSF$MAJOR_FRAME);

!+
! Load the pointer to the major procedure's frame.
!-
    BSF$A_MAJOR_STG = .FMP [BSF$A_BASE_R11];
!+
! Its procedure information starts with the name of the module.
!-
    RETURN (.BSF$A_MAJOR_STG [BSF$A_PROC_INFO]);
    END;					! of BAS$$MODULE

ROUTINE HANDLER_HANDLER (			! Handle unwind for BAS$HANDLER
	SIG, 					! signal args
	MECH, 					! mechanism args
	ENBL					!variables passed from BAS$HANDLER
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Handle the unwind which is likely to be done to BAS$HANDLER
!	by freeing its heap storage.  The length and address of the
!	heap storage are passed in the third argument to this routine.
!
! FORMAL PARAMETERS:
!
!	SIG.rl.a	Address of the signal vector.  This contains
!			the condition.
!	MECH.rl.a	Address of the mechanism vector.  This contains
!			the status of the frame that signalled.
!	ENBL.rl.a	Address of the enable vector.  This contains
!			pointers to the variables used to free the
!			heap storage for BAS$HANDLER.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	Always SS$_RESIGNAL, but this is ingored when we are
!	unwinding.
!
! SIDE EFFECTS:
!
!	May call LIB$FREE_VM to return storage to the free pool.
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,			! signal vector
	MECH : REF VECTOR,			! mechanism vector
	ENBL : REF VECTOR;			! enable vector

!+
! First check for the unwinding condition.  If it is not, resignal.
!-

    IF ( NOT (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND)))) THEN RETURN (SS$_RESIGNAL);

!+
! We are unwinding.  If any heap storage has been allocated, free it.
!-

    IF (.(.ENBL [2]) NEQA 0) THEN LIB$FREE_VM (%REF (.(.ENBL [1])*%UPVAL), .ENBL [2]);

!+
! All done.
!-
    RETURN (SS$_RESIGNAL);
    END;					! of HANDLER_HANDLER

ROUTINE RESTART : RESTART_LINK NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is a short routine which restores SP and branches to the
!	user's code.  It has to be a routine so its address can be
!	passed to SYS$UNWIND.
!	Before branching to the user's code it POPs any I/O that may
!	be in progress.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	BAS$A_RESTART.ra	The PC to branch to, which will be the
!				the first instruction of a line.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Never returns to its 'caller'
!
!--

    BEGIN

    REGISTER
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    BUILTIN
	FP,
	SP;

    FMP = .FP;
    BAS$$UNWIND_IO (.FMP);			! POP this frame's I/O
    SP = .FMP [BSF$A_BASE_SP];			! Restore SP
    SP = .SP - %UPVAL;
    .SP = .BAS$A_RESTART;			! Specify place to go
    RETURN;					! Go there, in effect.
    END;					! end of RESTART

ROUTINE RESTART_IO : RESTART_LINK NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is a short routine to call BAS$$RESTART_IO when unwinding
!	to the beginning of an I/O list.  No I/O popping is done.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	Gets the PC to branch to from BAS$$RESTART_IO.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Never returns to its 'caller'
!
!--

    BEGIN

    REGISTER
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    BUILTIN
	FP,
	SP;

    FMP = .FP;
    SP = .FMP [BSF$A_BASE_SP];			! Restore SP
    SP = .SP - %UPVAL;
    .SP = BAS$$RESTART_IO ();			! Get place to go
    RETURN;					! Go there, in effect.
    END;					! end of RESTART_IO

ROUTINE BAS$$USER_HAND (			! interface to user's condition handler
	ERR_CODE, 				! BASIC error code
	FMP, 					! user's frame
	LEVEL					! level to unwind
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Try to pass a SIGNALed condition to the BASIC user's program
!	for processing.
!
! FORMAL PARAMETERS:
!
!	ERR_CODE.rl.v	The BASIC error code that is being signaled.
!	FMP.rl.v	Pointer to the frame of the BASIC program
!	LEVEL.rl.v	Number of levels to unwind to get to the
!			current frame of the BASIC program.
!
! IMPLICIT INPUTS:
!
!	BAS$L_ERRFLG	0 if no error in progress, 1 if an error is
!			in progress.
!
! IMPLICIT OUTPUTS:
!
!	BAS$L_ERRFLG	Set to 1 while we are doing error processing.
!	BAS$L_ERL	The line number being executed when the error
!			occurred.
!	BAS$T_ERN	The name of the module in which the error
!			occurred.
!	BAS$L_ERR	The BASIC error number now being processed.
!	HIGHEST_LEVEL	If ON ERROR GO BACK, the level to UNWIND to
!			 if a lower level does a RESUME with no line
!			 number.
!	HIGHEST_FMP	If ON ERROR GO BACK, the frame to UNWIND to
!			 if a lower level does a RESUME with no line
!			 number.
!	ACCUM_LEVEL	If ON ERROR GO BACK, the number of levels above
!			 which must be unwound through if a lower
!			 level does a RESUME with a line number.
!	UNWIND_COUNT	If non-zero, the number of levels to UNWIND
!			 when we get back to the top level call of
!			 BAS$HANDLER.
!
! ROUTINE VALUE:
!
!	USER_HAND_CONT (=0) => The user has processed the error condition,
!	continue from the point of error (or from an unwind).  If an
!	unwind is needed, UNWIND_COUNT is set for the highest level
!	handler.
!
!	USER_HAND_BACK (=1) => The user is not prepared to handle
!	the error at this level, but he may be able to handle it at a
!	deeper level.  Revert.
!
!	USER_HAND_FAIL (=2) => The user demands system processing of
!	this error; do not test deeper levels.  Revert and do not call
!	BAS$$USER_HAND again for this error.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May call user code.
!
!--

    BEGIN

    LITERAL
	K_MAJOR = 1,				!A major frame
	K_MINOR = 0;				!A minor frame

    MAP
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

    LOCAL
	MOD_NAME_ADDR,
	NON_GOSUB_FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD),
	USER_HAND_VAL,
	ONER_RESULT,
	BSF$A_MAJOR_STG : REF BLOCK [0, BYTE] FIELD (BSF$MAJOR_FRAME),
	BSF$A_MINOR_STG : REF BLOCK [0, BYTE] FIELD (BSF$MINOR_FRAME),
	NEXT_FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD),
	THIS_FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD),
	MAJOR_OR_MINOR,
	SEARCH_DONE;

    BUILTIN
	FP;

!+
! If the severity is "error" or "warning", let the compiled code
!  intercept the error, if it has requested to do so.  Note that
!  we must check the severity table rather than the condition value
!  since LIB$STOP forces the severity to "severe error".
!-

    IF ((.ERR_SEVERITY [.ERR_CODE] NEQ STS$K_ERROR)	!
	AND (.ERR_SEVERITY [.ERR_CODE] NEQ STS$K_WARNING))
    THEN
	RETURN (USER_HAND_FAIL);

    IF (.BAS$L_ERRFLG NEQ 0)
    THEN
!+
! The user has committed an error or said ON ERROR GOTO 0 durring
!  error processing.  Demand system processing.
!-
	RETURN (USER_HAND_FAIL);

    IF (.BAS$L_GOING_BACK NEQ 0)
    THEN
!+
! We are one BASIC level deeper in ON ERROR GO BACK processing
!-
	BEGIN
	BAS$L_ERRFLG = 1;
	ACCUM_LEVEL = .ACCUM_LEVEL + .LEVEL;
	END
    ELSE
!+
! This is the first time we have seen this error.  Set things up.
!-
	BEGIN
	BAS$L_ERRFLG = 1;			! error in progress
	BAS$A_CH_CUR_LN = .FMP [BSF$A_MARK];	! remember default restart PC
	BAS$L_GOING_BACK = 1;			! flag in case we do a "go back"
	BAS$L_ERL = BAS$$LINE (.FMP);		! compute default restart line number
	MOD_NAME_ADDR = BAS$$MODULE (.FMP);
	BAS$T_ERN [DSC$A_POINTER] = .MOD_NAME_ADDR + 1;
	BAS$T_ERN [DSC$W_LENGTH] = .BLOCK [.MOD_NAME_ADDR, 0, 0, 8, 0; 1, BYTE];
	BAS$T_ERN [DSC$B_CLASS] = DSC$K_CLASS_S;
	BAS$T_ERN [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	BAS$L_ERR = .ERR_CODE;
	HIGHEST_LEVEL = .LEVEL;
	HIGHEST_FMP = .FMP;
	ACCUM_LEVEL = .LEVEL;
	END;

!+
! Fetch the current value of BSF$A_USER_HAND.
! We must first dig back to the first non-GOSUB frame.
!-
    NON_GOSUB_FMP = .FMP;
    SEARCH_DONE = 0;

    DO
	BEGIN

	IF (.NON_GOSUB_FMP [BSF$A_HANDLER] EQLA BAS$HANDLER)
	THEN

	    IF (.NON_GOSUB_FMP [BSF$B_PROC_CODE] NEQ BSF$K_PROC_GOSB) THEN SEARCH_DONE = 1;

	IF ( NOT .SEARCH_DONE)
	THEN
	    BEGIN
	    NON_GOSUB_FMP = .NON_GOSUB_FMP [BSF$A_SAVED_FP];

	    IF (.NON_GOSUB_FMP EQLA 0)
	    THEN
!+
! We have been unable to find a non-GOSUB frame.  This is quite
! unreasonable.  Force system handling on this error.
!-
		RETURN (USER_HAND_FAIL);

	    END;

	END
    UNTIL (.SEARCH_DONE);

    CASE .NON_GOSUB_FMP [BSF$B_PROC_CODE] FROM BSF$K_PROC_MAIN TO BSF$K_PROC_IOL OF
	SET

	[BSF$K_PROC_MAIN, BSF$K_PROC_SUB, BSF$K_PROC_EXTF, BSF$K_PROC_DEFS] :
	    BEGIN
	    BSF$A_MAJOR_STG = .NON_GOSUB_FMP [BSF$A_BASE_R11];
	    USER_HAND_VAL = .BSF$A_MAJOR_STG [BSF$A_USER_HAND];
	    MAJOR_OR_MINOR = K_MAJOR;
	    END;

	[BSF$K_PROC_DEF] :
	    BEGIN
	    BSF$A_MINOR_STG = .NON_GOSUB_FMP [BSF$A_BASE_R10];
	    USER_HAND_VAL = .BSF$A_MINOR_STG [BSF$A_USER_HAND];
	    MAJOR_OR_MINOR = K_MINOR;
	    END;

	[BSF$K_PROC_IOL] :
	    BEGIN				! Don't let error handling go beyond the immediate code
	    USER_HAND_VAL = 0;
	    END;

	[BSF$K_PROC_GOSB, BSF$K_PROC_ONER, OUTRANGE] :
	    USER_HAND_VAL = 0;			! this should never happen
	TES;

    IF (.USER_HAND_VAL EQL 0)
    THEN
!+
! The user has specified (or defaulted to) system error handling
!  for any errors.  Revert and don't call BAS$$USER_HAND again.
!-
	RETURN (USER_HAND_FAIL);

    IF (.USER_HAND_VAL EQL 1)
    THEN
	BEGIN
!+
! The user has specified ON ERROR GO BACK.  Revert but do call
!  BAS$$USER_HAND again.  Note that GOSUBs get unwound one at a
!  time by this mechanism, but we will make the same decision
!  each time because the frame is marked for an immediate
!  ON ERROR GO BACK.
!-
	BAS$L_ERRFLG = 0;
	RETURN (USER_HAND_BACK);
	END;

!+
! The user has specified an entry point in this frame for error
! processing.  We call his code as a modified GOSUB.
! Further system processing depends on how the user's code terminates.
!-
    ONER_RESULT = BAS$INIT_ONERR (.NON_GOSUB_FMP, .USER_HAND_VAL);

    SELECTONEU (.ONER_RESULT) OF
	SET

	[USER_ERR_RSUMZ] :
!+
! The condition handler ended with a RESUME with no line number.
! Unwind to the frame in which the signal happened and restart
! the statement.
!-
	    BEGIN
	    BAS$L_ERRFLG = 0;
	    BAS$A_RESTART = .BAS$A_CH_CUR_LN;
	    BAS$A_CH_CUR_LN = 0;
	    BAS$L_GOING_BACK = 0;
	    UNWIND_COUNT = .HIGHEST_LEVEL;
!+
! The compiler should not permit a module to exist with RESUME with no
! line number and /NOLINE, but check for that case here and give an
! error message.
!-

	    IF (.BAS$A_RESTART EQLA 0) THEN BAS$$STOP (BAS$K_PROLOSSOR);

	    IF (.HIGHEST_LEVEL EQL 0)
	    THEN
		BEGIN
!+
! Rather than doing an UNWIND to 0, search back through the frames
! and patch the return PC of the frame that will return to the
! compiled code.
!-
		THIS_FMP = .FP;

		DO
		    BEGIN
		    NEXT_FMP = .THIS_FMP;
		    THIS_FMP = .THIS_FMP [BSF$A_SAVED_FP];
		    END
		UNTIL (.THIS_FMP EQLA .HIGHEST_FMP);

		NEXT_FMP [BSF$A_SAVED_PC] = RESTART;
		END;

	    RETURN (USER_HAND_CONT);
	    END;

	[USER_ERR_GOBK] :
!+
! The condition handler ended with ON ERROR GO BACK.  Revert but
! continue to call BAS$$USER_HAND.  However, this frame is marked for
! an immediate ON ERROR GO BACK in case we are in a GOSUB: we don't
! want to call the user's error handler again.
!-
	    BEGIN
	    BAS$L_ERRFLG = 0;

	    CASE .MAJOR_OR_MINOR FROM K_MINOR TO K_MAJOR OF
		SET

		[K_MINOR] :
		    BSF$A_MINOR_STG [BSF$A_USER_HAND] = 1;

		[K_MAJOR] :
		    BSF$A_MAJOR_STG [BSF$A_USER_HAND] = 1;
		TES;

	    RETURN (USER_HAND_BACK);
	    END;

	[USER_ERR_OEGZ] :
!+
! The condition handler ended with ON ERROR GOTO 0.  Revert but
! force system handling for this error.
!-
	    BEGIN

	    CASE .MAJOR_OR_MINOR FROM K_MINOR TO K_MAJOR OF
		SET

		[K_MINOR] :
		    BSF$A_MINOR_STG [BSF$A_USER_HAND] = 0;

		[K_MAJOR] :
		    BSF$A_MAJOR_STG [BSF$A_USER_HAND] = 0;
		TES;

	    RETURN (USER_HAND_FAIL);
	    END;

	[OTHERWISE] :
!+
! The condition handler ended with a RESUME with a line number.
! Unwind to the current frame and restart at the indicated PC.
!-
	    BEGIN
	    BAS$L_ERRFLG = 0;
	    BAS$A_RESTART = .ONER_RESULT;
	    BAS$A_CH_CUR_LN = 0;
	    BAS$L_GOING_BACK = 0;
	    UNWIND_COUNT = .ACCUM_LEVEL;

	    IF (.LEVEL EQL 0)
	    THEN
		BEGIN
!+
! Rather than doing an UNWIND to 0, search back through the frames
! and patch the return PC of the frame that will return to the
! compiled code.
!-
		THIS_FMP = .FP;

		DO
		    BEGIN
		    NEXT_FMP = .THIS_FMP;
		    THIS_FMP = .THIS_FMP [BSF$A_SAVED_FP];
		    END
		UNTIL (.THIS_FMP EQLA .FMP);

		NEXT_FMP [BSF$A_SAVED_PC] = RESTART;
		END;

	    RETURN (USER_HAND_CONT);
	    END
	TES;

    END;					! of BAS$$USER_HAND


GLOBAL ROUTINE BAS$RESUME (			! end of error handler
	NEW_PC					! where to restart
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Resume execution from an error handler.  The compiled code
!	calls RESUME passing the address of the location at which
!	to continue execution.  We must be in an error handler.
!	The stack is cut back to the call to BAS$INIT_ONER which
!	is in BAS$$USER_HAND and the RET at the end of this routine
!	actually returns from BAS$INIT_ONER.  This is similar to
!	GOSUB processing.  To simplify the restoring of registers
!	BAS$INIT_ONER saves them all, so the return to BAS$$USER_HAND
!	restores them.
!
!	If necessary, GOSUB frames are removed looking for the
!	condition handling frame, but if another type of frame
!	is encountered we have an error.  If there is no error
!	pending then the RESUME is turned into a GOTO, for
!	compatability with BASIC-PLUS.
!
! FORMAL PARAMETERS:
!
!	NEW_PC.ra.v	The location at which to continue execution.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The resume PC.  This is returned to the caller of BAS$INIT_ONER,
!	which is presumed to be BAS$$USER_HAND.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May cut back the stack, thus not returning to the caller.
!	If it does return, it is not to the call site but to the
!	location specified in the parameter.
!
!--

    BEGIN

    BUILTIN
	FP;

    LOCAL
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

!+
! If there is no error being processed, stuff the parameter into the
! return address and return, thus turning the RESUME statement into
! a GOTO.
!-

    IF (.BAS$L_ERRFLG EQL 0)
    THEN
	BEGIN
	FMP = .FP;
	FMP [BSF$A_SAVED_PC] = .NEW_PC;
	RETURN (0);				! the value will be ignored
	END;

!+
! Dig back through GOSUB frames to find the condition handling frame.
!-
    FMP = .FP;
    FMP = .FMP [BSF$A_SAVED_FP];

    WHILE (.FMP [BSF$B_PROC_CODE] EQL BSF$K_PROC_GOSB) DO
	BEGIN
	FMP = .FMP [BSF$A_SAVED_FP];

	IF (.FMP [BSF$A_HANDLER] NEQA BAS$HANDLER)
	THEN
!+
! The previous frame is not a BASIC frame.  This means that the user
! began processing an error, called a non-BASIC routine which called
! a BASIC routine which tried to dismiss the error.  Disallow this
! kind of poorly-structured code.
!-
	    BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! Deallocate any heap storage that may be held by this frame.
!-
	BAS$$UNWIND (.FMP);
	END;

!+
! We have finished cutting back the GOSUB frames.  Now be sure we are
! in the condition handler.
!-

    IF (.FMP [BSF$B_PROC_CODE] NEQ BSF$K_PROC_ONER)
    THEN
!+
! We are not.  This can happen if the user begins processing an error,
! then calls another routine which tries to dismiss the error.
! Disallow this, also.
!-
	BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! We have reached the condition handling frame.  By stuffing the
! pointer to this frame into FP we effectively cut back the stack,
! since this routine's RET will then return from the condition
! handler.  Note that we are not restoring any registers; we depend
! on the fact that BAS$INIT_ONER saves them all, so the RET we are
! about to do will restore registers for BAS$$USER_HAND.
!-
    BAS$$UNWIND (.FMP);
    FP = .FMP;
!+
! By returning a number whose unsigned value is greater than 2
! we indicate to BAS$$USER_HAND that the user has written RESUME
! with a line number.
!-
    RETURN (.NEW_PC);
    END;					! of BAS$RESUME


GLOBAL ROUTINE BAS$RESUME_Z = 			! Resume with no line number

!++
! FUNCTIONAL DESCRIPTION:
!
!	Resume execution from an error handler.  The compiled code
!	calls RESUME_Z to indicate that the statement in which the
!	error occurred is to be restarted or continued.  (Which
!	depends on which error is in progress.)
!	The stack is cut back to the call to BAS$INIT_ONER which
!	is in BAS$$USER_HAND and the RET at the end of this routine
!	actually returns from BAS$INIT_ONER.  This is similar to
!	GOSUB processing.  To simplify the restoring of registers
!	BAS$INIT_ONER saves them all, so the return to BAS$$USER_HAND
!	restores them.
!
!	If necessary, GOSUB frames are removed looking for the
!	condition handling frame, but if another type of frame
!	is encountered we have an error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	USER_ERR_RSUMZ, to indicate to BAS$$USER_HAND that the user did
!	a RESUME with no line number.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Cuts back the stack, thus not returning to the caller.
!
!--

    BEGIN

    BUILTIN
	FP;

    LOCAL
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

!+
! If there is no error being processed, the RESUME statement without
! a line number is invalid.
!-

    IF (.BAS$L_ERRFLG EQL 0) THEN BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! If we are not in the same program unit as the source of the error,
! we have an error.  This is done for compatability with the PDP-11.
!-
    FMP = .FP;
    FMP = .FMP [BSF$A_SAVED_FP];

    IF ((BAS$$MODULE (.FMP) + 1) NEQA .BAS$T_ERN [DSC$A_POINTER]) THEN BAS$$STOP (BAS$K_ILLRESSUB);

!+
! Dig back through GOSUB frames to find the condition handling frame.
!-

    WHILE (.FMP [BSF$B_PROC_CODE] EQL BSF$K_PROC_GOSB) DO
	BEGIN
	FMP = .FMP [BSF$A_SAVED_FP];

	IF (.FMP [BSF$A_HANDLER] NEQA BAS$HANDLER)
	THEN
!+
! The previous frame is not a BASIC frame.  This means that the user
! began processing an error, called a non-BASIC routine which called
! a BASIC routine which tried to dismiss the error.  Disallow this
! kind of poorly-structured code.
!-
	    BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! Deallocate any heap storage that may be held by this frame.
!-
	BAS$$UNWIND (.FMP);
	END;

!+
! We have finished cutting back the GOSUB frames.  Now be sure we are
! in the condition handler.
!-

    IF (.FMP [BSF$B_PROC_CODE] NEQ BSF$K_PROC_ONER)
    THEN
!+
! We are not.  This can happen if the user begins processing an error,
! then calls another routine which tries to dismiss the error.
! Disallow this, also.
!-
	BAS$$SIGNAL (BAS$K_ILLRESSUB);

!+
! We have reached the condition handling frame.  By stuffing the
! pointer to this frame into FP we effectively cut back the stack,
! since this routine's RET will then return from the condition
! handler.  Note that we are not restoring any registers; we depend
! on the fact that BAS$INIT_ONER saves them all, so the RET we are
! about to do will restore registers for BAS$$USER_HAND.
!-
    BAS$$UNWIND (.FMP);
    FP = .FMP;
!+
! Indicate to BAS$$USER_HAND that the user has written a RESUME
! with no line number.
!-
    RETURN (USER_ERR_RSUMZ);
    END;					! of BAS$RESUME_Z


GLOBAL ROUTINE BAS$ON_ERR_Z = 			! ON ERROR GOTO 0

!++
! FUNCTIONAL DESCRIPTION:
!
!	The BASIC statement ON ERROR GOTO 0 is compiled as
!
!		CALLS	#0,BAS$ON_ERR_Z
!		CLRL	BAS$A_USER_HAND(Rn)
!
!	Thus, the job of BAS$ON_ERR_Z is to return if there is no
!	error in progress, and to provide system error processing
!	if there is an error in progress.  This latter function is
!	done by cutting back the stack (like RESUME) and returning
!	to BAS$$USER_HAND indicating that system error handling
!	is required.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	BAS$L_ERRFLG
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Either no value, or USER_ERR_OEGZ, to indicate to BAS$$USER_HAND
!	that the user did an ON ERROR GOTO 0 in his error handler.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May cut back the stack, thus not returning to the caller.
!
!--

    BEGIN

    BUILTIN
	FP;

    LOCAL
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

!+
! If there is no error being processed, just return.  The value will
! be ignored.
!-

    IF (.BAS$L_ERRFLG EQL 0) THEN RETURN (0);

!+
! Dig back through GOSUB frames to find the condition handling frame.
!-
    FMP = .FP;
    FMP = .FMP [BSF$A_SAVED_FP];

    WHILE (.FMP [BSF$B_PROC_CODE] EQL BSF$K_PROC_GOSB) DO
	BEGIN
	FMP = .FMP [BSF$A_SAVED_FP];

	IF (.FMP [BSF$A_HANDLER] NEQA BAS$HANDLER)
	THEN
!+
! The previous frame is not a BASIC frame.  This means that the user
! began processing an error, called a non-BASIC routine which called
! a BASIC routine which tried to specify system error handling.
! Disallow this kind of poorly-structured code.
!-
	    BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! Deallocate any heap storage that may be held by this frame.
!-
	BAS$$UNWIND (.FMP);
	END;

!+
! We have finished cutting back the GOSUB frames.  Now be sure we are
! in the condition handler.
!-

    IF (.FMP [BSF$B_PROC_CODE] NEQ BSF$K_PROC_ONER)
    THEN
!+
! We are not. This can happen if the user begins processing an error,
! then calls another routine which tries to specify system error
! handling.  Disallow this, also.
!-
	BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! We have reached the condition handling frame.  By stuffing the
! pointer to this frame into FP we effectively cut back the stack,
! since this routine's RET will then return from the condition
! handler.  Note that we are not restoring any registers; we depend
! on the fact that BAS$INIT_ONER saves them all, so the RET we are
! about to do will restore registers for BAS$$USER_HAND.
!-
    BAS$$UNWIND (.FMP);
    FP = .FMP;
!+
! Indicate to BAS$$USER_HAND that the user has written ON ERROR GOTO 0.
!-
    RETURN (USER_ERR_OEGZ);
    END;					! of BAS$ON_ERR_Z


GLOBAL ROUTINE BAS$ON_ERR_BK = 			! ON ERROR GO BACK

!++
! FUNCTIONAL DESCRIPTION:
!
!	The BASIC statement ON ERROR GO BACK is compiled as
!
!		CALLS	#0,BAS$ON_ERR_BK
!		MOVZBL	#1,BAS$A_USER_HAND(Rn)
!
!	Thus, the job of BAS$ON_ERR_BK is to return if there is no
!	error in progress, and to permit the caller of the BASIC
!	procedure to try to process the error if there is an error
!	in progress.  This latter function is done by cutting back
!	the stack (like RESUME) and returning to BAS$$USER_HAND with
!	a USER_ERR_GOBK, indicating that it is to revert.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	BAS$L_ERRFLG
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Either no value, or USER_ERR_GOBK.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May cut back the stack, thus not returning to the caller.
!
!--

    BEGIN

    BUILTIN
	FP;

    LOCAL
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD);

!+
! If there is no error being processed, just return.  The value will
!  be ignored.
!-

    IF (.BAS$L_ERRFLG EQL 0) THEN RETURN (0);

!+
! Dig back through GOSUB frames to find the condition handling frame.
!-
    FMP = .FP;
    FMP = .FMP [BSF$A_SAVED_FP];

    WHILE (.FMP [BSF$B_PROC_CODE] EQL BSF$K_PROC_GOSB) DO
	BEGIN
	FMP = .FMP [BSF$A_SAVED_FP];

	IF (.FMP [BSF$A_HANDLER] NEQA BAS$HANDLER)
	THEN
!+
! The previous frame is not a BASIC frame.  This means that the user
! began processing an error, called a non-BASIC routine which called
! a BASIC routine which tried to allow the caller of the routine that
! got the error to handle the error.  Disallow this kind of
! poorly-structured code.
!-
	    BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! Deallocate any heap storage that may be held by this frame.
!-
	BAS$$UNWIND (.FMP);
	END;

!+
! We have finished cutting back the GOSUB frames.  Now be sure we are
! in the condition handler.
!-

    IF (.FMP [BSF$B_PROC_CODE] NEQ BSF$K_PROC_ONER)
    THEN
!+
! We are not.  This can happen if the user begins processing an error,
! then calls another routine which tries to specify system error
! handling.  Disallow this, also.
!-
	BAS$$SIGNAL (BAS$K_RESNO_ERR);

!+
! We have reached the condition handling frame.  By stuffing the
! pointer to this frame into FP we effectively cut back the stack,
! since this routine's RET will then return from the condition
! handler.  Note that we are not restoring any registers; we depend
! on the fact that BAS$INIT_ONER saves them all, so the RET we are
! about to do will restore registers for BAS$$USER_HAND.
!-
    BAS$$UNWIND (.FMP);
    FP = .FMP;
!+
! Indicate to BAS$$USER_HAND that the user has written ON ERROR GO BACK.
!-
    RETURN (USER_ERR_GOBK);
    END;					! of BAS$ON_ERR_BK


GLOBAL ROUTINE BAS$$HANDLER (			! handler for BASIC compiled code
	SIGNAL_ARGS, 				! VAX/VMS signal arguments
	MECHANISM_ARGS				! VAX/VMS mechanism arguments
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Handle an exception from within a BASIC-PLUS-2 routine.
!	Note that the real entry point, BAS$HANDLER, is a location in
!	the sharable library's vector (or in a small module if this code
!	is not shared) so that a frame can be tested for being a BASIC
!	frame by testing for BAS$HANDLER in 0(FP).
!
! FORMAL PARAMETERS:
!
!	SIGNAL_ARGS	A vector of longwords which indicate the nature
!			of the condition.
!	MECHANISM_ARGS	A vector of longwords that indicate the state
!			of the process at the time of the signal.
!
! IMPLICIT INPUTS:
!
!	The information in the frames of the BASIC-PLUS-2 routines
!	in and before the one which encountered the error.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An indication to the VAX/VMS CHF of whether or not to revert.
!
! COMPLETION CODES:
!
!	SS$_RESIGNAL
!	SS$_CONTINUE
!
! SIDE EFFECTS:
!
!	May do an UNWIND to let the BASIC-PLUS-2 code process the error.
!	On an UNWIND, will deallocate any heap storage held by its frame.
!
!--

    BEGIN

    MAP
	SIGNAL_ARGS : REF BLOCK [0, BYTE],
	MECHANISM_ARGS : REF BLOCK [0, BYTE];

    BUILTIN
	CALLG;					! call with hand-built argument list

    LOCAL
	COND_VAL : BLOCK [4, BYTE],		! condition value being signaled
	TEMP_COND_VAL : BLOCK [4, BYTE],	! temp, for copying
	NUM_FAO_ARGS,				! number of FAO arguments while copying
	SCAN_DONE,				! used to control copying loop
	COPY_LIMIT,				! likewise
	FMP : REF BLOCK [0, BYTE] FIELD (BSF$FCD),	! frame pointer
	LEN_VECTOR : VOLATILE,			! length of new vector
	NEW_VECTOR : REF BLOCK [0, BYTE] VOLATILE,	! the new vector to be signaled
	PUTTER,					! used to store in new vector
	GETTER,					! used to fetch from old vector
	GET_VM_RESULT,				! condition value from calling LIB$GET_VM
	USER_RESULT,				! condition value from calling BAS$$USER_HAND
	TOP_LEVEL,				! true if we have original jurisdiction
	COND_VAL_CHANGE,			! true if we translated cond
	RESTART_IO_FLAG;			! This is a restartable I/O statement

!+
! The SYSTEM_ERROR cell is 1 if the user specified that system
! error handling is to take place.  It is set based on a call to
! BAS$$USER_HAND, and, if set, BAS$$USER_HAND will not be called
! again for this error.
! The GONE_BACK cell is 0 if this is the first instance of the
! BASIC handler to see this error, and 1 if we have gone through
! a reversion (if only to get traceback).
!-
!+
! Declare a handler to clean up heap storage.
!-

    ENABLE
	HANDLER_HANDLER (LEN_VECTOR, NEW_VECTOR);

!+
! Set up a pointer to our frame.
!-
    FMP = .MECHANISM_ARGS [CHF$L_MCH_FRAME];
!+
! Remember whether we are the first handler to process this error,
! and tell deeper handlers that they are not.
!-
    TOP_LEVEL = (IF (.GONE_BACK) THEN 0 ELSE 1);
    GONE_BACK = 1;
!+
! Check for certain non-BASIC errors.  Many of these are
! converted to their equivalent BASIC error.
!-
    COND_VAL = .SIGNAL_ARGS [CHF$L_SIG_NAME];

    IF (.COND_VAL [STS$V_FAC_NO] EQL BAS$K_FAC_NO)
    THEN
	COND_VAL_CHANGE = 0
    ELSE
	BEGIN

	CASE LIB$MATCH_COND (COND_VAL, 		!
		%REF (MTH$_SQUROONEG), 		! 1 = negative square root
		%REF (MTH$_LOGZERNEG), 		! 2 = negative or zero log
		%REF (MTH$_FLOOVEMAT), 		! 3 = floating overflow (EXP or TAN)
		%REF (SS$_FLTDIV), 		! 4 = floating divide by zero
		%REF (SS$_INTDIV), 		! 5 = integer divide by zero
		%REF (SS$_FLTOVF), 		! 6 = floating overflow
		%REF (SS$_INTOVF), 		! 7 = integer overflow
		%REF (MTH$_SIGLOSMAT), 		! 8 = significance lost in math library
		%REF (MTH$_UNDEXP), 		! 9 = undefined ** operation
		%REF (SS$_ACCVIO), 		! 10 = access violation
		%REF (SS$_ROPRAND), 		! 11 = reserved (floating) operand
		%REF (SS$_SUBRNG), 		! 12 = subscript out of range
		%REF (STR$_INSVIRMEM), 		! 13 = insufficient virtual memory (strings)
		%REF (STR$_DIVBY_ZER), 		! 14 = String divide by zero
		%REF (OTS$_IO_CONCLO), 		! 15 = I/O continued to closed file
		%REF (SS$_UNWIND), 		! 16 = unwinding through this frame
		%REF (STR$_STRTOOLON), 		! 17 = String too long (greater than 65535)
		%REF (SS$_FLTDIV_F), 		! 18 = floating divide by zero fault
		%REF (SS$_FLTOVF_F))		! 19 = floating overflow fault
	FROM 0 TO 19 OF
	    SET

	    [0] :
		COND_VAL_CHANGE = 0;		! none of the above, don't translate

	    [1] :
		BEGIN				! SQRT(N), N LSS 0
		COND_VAL = BAS$$COND_VAL (BAS$K_IMASQUROO);
		COND_VAL_CHANGE = 1;
		END;

	    [2] :
		BEGIN				! LOG(N), N LEQ 0
		COND_VAL = BAS$$COND_VAL (BAS$K_ILLARGLOG);
		COND_VAL_CHANGE = 1;
		END;

	    [4, 5, 14, 18] :
		BEGIN				! N/0, N%/0 and $QUO(N$,'0',P%)
		COND_VAL = BAS$$COND_VAL (BAS$K_DIVBY_ZER);
		COND_VAL_CHANGE = 1;
		END;

	    [7] :
		BEGIN				! integer overflow
		COND_VAL = BAS$$COND_VAL (BAS$K_INTERR);
		COND_VAL_CHANGE = 1;
		END;

	    [10] :
		BEGIN				! invalid address
		COND_VAL = BAS$$COND_VAL (BAS$K_MEMMANVIO);
		COND_VAL_CHANGE = 1;
		END;

	    [11] :
		BEGIN				! reserved operand--fixup to zero

		LOCAL
		    FIXUP_RESULT;

		FIXUP_RESULT = LIB$FIXUP_FLT (.SIGNAL_ARGS, .MECHANISM_ARGS);
!+
! If the fixup attempt fails, then this handler fails.
!-

		IF ( NOT .FIXUP_RESULT)
		THEN
		    BEGIN
		    GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);
		    RETURN (.FIXUP_RESULT);
		    END;

!+
! Convert the signal to the catch-all floating point warning for BASIC.
!-
		COND_VAL = BAS$$COND_VAL (BAS$K_FLOPOIERR);
		COND_VAL_CHANGE = 1;
		END;

	    [3, 6, 8, 9, 19] :
		BEGIN				! all other math errors
		COND_VAL = BAS$$COND_VAL (BAS$K_FLOPOIERR);
		COND_VAL_CHANGE = 1;
		END;

	    [12] :
		BEGIN				! subscript out of range
		COND_VAL = BAS$$COND_VAL (BAS$K_SUBOUTRAN);
		COND_VAL_CHANGE = 1;
		END;

	    [13] :
		BEGIN				! String package ran out of memory
		COND_VAL = BAS$$COND_VAL (BAS$K_MAXMEMEXC);
		COND_VAL_CHANGE = 1;
		END;

	    [15] :
		BEGIN
!+
! I/O continued to closed file.  This happens when a function is called in
! an I/O list (for example, to evaluate a subscript) and the function
! closes the I/O channel that the I/O list is operating on.  For compatability
! with BASIC-PLUS, give the error message ILLEGAL BYTE COUNT FOR I/O.
!-
		COND_VAL = BAS$$COND_VAL (BAS$K_ILLBYTCOU);
		COND_VAL_CHANGE = 1;
		END;

	    [16] :
		BEGIN				! Unwinding through this frame
!+
! We are unwinding through this frame.  This may be due to a RESUME
! statement cutting back this frame, to the RUN command recovering
! from an error, or to a non-BASIC part of the user's program doing
! error recovery.  Deallocate any heap storage held by this frame.
!-
		BAS$$UNWIND (.FMP);
		END;

	    [17] :
		BEGIN				! String created longer than 65535 characters
		COND_VAL = BAS$$COND_VAL (BAS$K_STRTOOLON);
		COND_VAL_CHANGE = 1;
		END;
	    TES;

!+
! If the translated signal condition is not a BASIC condition,
! we can't process it.  Return to CHF and indicate that the next
! higher frame should be given a chance at it.
!-

	IF (.COND_VAL [STS$V_FAC_NO] NEQ BAS$K_FAC_NO)
	THEN
	    BEGIN
	    GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);
	    RETURN (SS$_RESIGNAL);
	    END;

	END;

!+
! Give the user's BASIC program a chance to process the error.
! If it succeeds, give a success return, otherwise do a special
! resignal by extending the signal argument list and signaling again.
!-

    IF (( NOT .SYSTEM_ERROR) AND (.COND_VAL [STS$V_SEVERITY] NEQU STS$K_INFO))
    THEN
	USER_RESULT = BAS$$USER_HAND (.COND_VAL [STS$V_CODE], .FMP, .MECHANISM_ARGS [CHF$L_MCH_DEPTH])
    ELSE
	USER_RESULT = USER_HAND_FAIL;

!+
! If the user processes the error to his own satisfaction, skip
! most of the remainder of this handler.
!-

    IF (.USER_RESULT NEQ USER_HAND_CONT)
    THEN
	BEGIN
!+
! If the user specified system handling, set the flag so that the
! deeper levels of BAS$HANDLER won't call BAS$$USER_HAND.
!-

	IF (.USER_RESULT EQL USER_HAND_FAIL) THEN SYSTEM_ERROR = 1;

!+
! If we are at the top level purge the terminal's output buffer so
! that, if a message is printed, it will print after the program's
! output.
!-

	IF (.TOP_LEVEL) THEN BAS$$PUR_IO_ERR ();

!<BLF/PAGE>

!+
! Append a message about the current frame to the signal argument
! list.  This requires recopying the list.  If we have translated
! the signal condition, append the new condition rather than
! overwrite the old one, so that a message like 'floating point error'
! can have with it a clue as to why it happened.
!
! Compute the length of the new signal argument list.
!-
	LEN_VECTOR = (.SIGNAL_ARGS [CHF$L_SIG_ARGS] + 3);

	CASE .FMP [BSF$B_PROC_CODE] FROM BSF$K_PROC_MAIN TO BSF$K_PROC_IOL OF
	    SET

	    [BSF$K_PROC_MAIN, BSF$K_PROC_SUB, BSF$K_PROC_EXTF] :
!+
! These frames only have two variables in the FAO list
!-
		LEN_VECTOR = .LEN_VECTOR + 2;

	    [BSF$K_PROC_DEF, BSF$K_PROC_DEFS, BSF$K_PROC_GOSB, BSF$K_PROC_ONER] :
!+
! These frames have three variables in the FAO list
!-
		LEN_VECTOR = .LEN_VECTOR + 3;

	    [BSF$K_PROC_IOL] :
!+
! This frame has only one variable in the FAO list
!-
		LEN_VECTOR = .LEN_VECTOR + 1;

	    [OUTRANGE] :
!+
! If the BSF$B_PROC_CODE byte is out of range then the frame
! has been garbaged.  There is no point in attempting to continue,
! so we mearly return to CHF.  It is likely that some error message
! will be printed.
!-
		BEGIN
		GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);
		RETURN (SS$_RESIGNAL);
		END;
	    TES;

!+
! Take into account translation of a math error and adding a FAO count
!  to a short list.
!-

	IF (.COND_VAL_CHANGE)
	THEN
	    BEGIN
	    LEN_VECTOR = .LEN_VECTOR + 6;
	    END
	ELSE

	    IF (.SIGNAL_ARGS [CHF$L_SIG_ARGS] EQL 3) THEN LEN_VECTOR = .LEN_VECTOR + 1;

!+
! If the argument list is too long, quit.  This should only happen if
! there is a tall stack of subroutines.
!-

	IF (.LEN_VECTOR GTR 250)
	THEN
	    BEGIN
	    GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);
	    RETURN (SS$_RESIGNAL);
	    END;

!+
! Get space to hold the new signal argument list.
!-

	IF ( NOT (GET_VM_RESULT = LIB$GET_VM (%REF (.LEN_VECTOR*%UPVAL), NEW_VECTOR)))
	THEN
!+
! If we are out of space just quit.  This should happen only for
! very unreasonable BASIC programs.  The BASIC program is given
! no chance to recover.
!-
	    BEGIN
	    LIB$STOP (.GET_VM_RESULT);
	    GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);
	    RETURN (SS$_RESIGNAL);
	    END;

!+
! Now copy data into the new vector.  If we have not translated
! the signal condition then our new data goes between the last
! of the BASIC data and the first non-BASIC data.  If we have
! translated the signal condition then our data goes first.
!
! First set the length.  Don't count the count longword or the two
! trailing longwords.
!-
	NEW_VECTOR [0, 0, %BPVAL, 1] = .LEN_VECTOR - 3;
	PUTTER = 1;
	GETTER = 1;
!+
! If we translated the signal code, store it and a 0 for its FAO count.
! Also, store a special message which prints the original PC and PSL.
!-

	IF (.COND_VAL_CHANGE)
	THEN
	    BEGIN
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = .COND_VAL;
	    PUTTER = .PUTTER + 1;
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 0;
	    PUTTER = .PUTTER + 1;
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_PCPSL);
						! user PC=!XL, PSL=!XL
	    PUTTER = .PUTTER + 1;
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 2;	! FAO count
	    PUTTER = .PUTTER + 1;
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 	!
	    .SIGNAL_ARGS [(.SIGNAL_ARGS [CHF$L_SIG_ARGS] - 1)*%UPVAL, 0, %BPVAL, 0];	! PC
	    PUTTER = .PUTTER + 1;
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 	!
	    .SIGNAL_ARGS [(.SIGNAL_ARGS [CHF$L_SIG_ARGS])*%UPVAL, 0, %BPVAL, 0];	! PSL
	    PUTTER = .PUTTER + 1;
	    END
	ELSE
	    BEGIN
!+
! Otherwise copy all the BASIC data.
!-
	    SCAN_DONE = 0;

	    UNTIL (.SCAN_DONE) DO
		BEGIN
		TEMP_COND_VAL = .SIGNAL_ARGS [.GETTER*%UPVAL, 0, %BPVAL, 0];

		IF (.TEMP_COND_VAL [STS$V_FAC_NO] NEQ BAS$K_FAC_NO)
		THEN
		    SCAN_DONE = 1
		ELSE
		    BEGIN
		    GETTER = .GETTER + 1;
		    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = .TEMP_COND_VAL;
		    PUTTER = .PUTTER + 1;
!+
! Copy the FAO arguments, unless we have reached the end of the list
!-

		    IF (.GETTER NEQU (.SIGNAL_ARGS [CHF$L_SIG_ARGS] - 1))
		    THEN
			BEGIN
			NUM_FAO_ARGS = .SIGNAL_ARGS [.GETTER*%UPVAL, 0, %BPVAL, 0];
			GETTER = .GETTER + 1;
			NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = .NUM_FAO_ARGS;
			PUTTER = .PUTTER + 1;

			INCR COUNTER FROM 1 TO .NUM_FAO_ARGS DO
			    BEGIN
			    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 	!
			    .SIGNAL_ARGS [.GETTER*%UPVAL, 0, %BPVAL, 0];
			    GETTER = .GETTER + 1;
			    PUTTER = .PUTTER + 1;
			    END;

			END
		    ELSE
			BEGIN
!+
! We have reached the end of the list, finding a BASIC condition there.
! Insert a zero FAO argument count since we will be adding more
! condition values.
!-
			NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 0;
			PUTTER = .PUTTER + 1;
			END;

!+
! Check for the end of the signal arguments.
!-

		    IF (.GETTER EQLU (.SIGNAL_ARGS [CHF$L_SIG_ARGS] - 1)) THEN SCAN_DONE = 1;

		    END;

		END;

	    END;

!+
! Now put our data in the parameter list we are building.
! This data varies depending on the frame type.
!-

	CASE .FMP [BSF$B_PROC_CODE] FROM BSF$K_PROC_MAIN TO BSF$K_PROC_IOL OF
	    SET

	    [BSF$K_PROC_MAIN] : 		! main program
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_MAIN);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 2;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_SUB] : 			! external subroutine
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_SUB);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 2;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_EXTF] : 		! external function
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_EXTF);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 2;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_DEF] : 			! DEF procedure
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_DEF);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 3;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$FUNCTION (.FMP);	! function name
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_DEFS] : 		! DEF* procedure
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_DEFS);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 3;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$FUNCTION (.FMP);	! function name
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_GOSB] : 		! GOSUB
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_GOSB);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 3;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$FUNCTION (.FMP);	! function number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_ONER] : 		! ON ERROR GOTO
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_ONER);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 3;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$LINE (.FMP);	! current line number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$FUNCTION (.FMP);	! function number
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [BSF$K_PROC_IOL] : 			! Immediate mode code
		BEGIN
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$COND_VAL (ERR_TRACE_IOLST);
						! message code
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = 1;	! number of FAO arguments
		PUTTER = .PUTTER + 1;
		NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = BAS$$MODULE (.FMP);	! module name
		PUTTER = .PUTTER + 1;
		END;

	    [OUTRANGE] :
!+
! If the BSF$B_PROC_CODE byte is out of range then the frame
! has been garbaged.  There is no point in attempting to continue,
! so we mearly return to CHF.  It is likely that some error message
! will be printed.
!-
		BEGIN
		GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);
		RETURN (SS$_RESIGNAL);
		END;
	    TES;

!+
! Copy the remainder of the signal argument list, omitting the
! PC and PSL unless we converted the signal condition.
!-
	COPY_LIMIT = .SIGNAL_ARGS [CHF$L_SIG_ARGS];

	IF ( NOT .COND_VAL_CHANGE) THEN COPY_LIMIT = .COPY_LIMIT - 2;

	WHILE (.GETTER LEQ .COPY_LIMIT) DO
	    BEGIN
	    NEW_VECTOR [.PUTTER*%UPVAL, 0, %BPVAL, 0] = .SIGNAL_ARGS [.GETTER*%UPVAL, 0, %BPVAL, 0];
	    GETTER = .GETTER + 1;
	    PUTTER = .PUTTER + 1;
	    END;

!+
! Set the severity code of the condition which we will signal depending
! on the system handling of that signal.  However, if this is not an
! I/O error from a terminal, don't restart.
!-
	RESTART_IO_FLAG = 0;

	CASE (.ERR_SYSTEM [.COND_VAL [STS$V_CODE]]) FROM K_SYS_CONT TO K_SYS_RESTART OF
	    SET

	    [K_SYS_CONT] :
		BEGIN
!+
! If the severity is INFO, don't promote it to WARNING.
!-

		IF (.COND_VAL [STS$V_SEVERITY] NEQ STS$K_INFO)	!
		THEN
		    COND_VAL [STS$V_SEVERITY] = STS$K_WARNING;

		END;

	    [K_SYS_EXIT] :
		BEGIN
!+
! If the severity is INFO, don't promote it to SEVERE.
!-

		IF (.COND_VAL [STS$V_SEVERITY] NEQ STS$K_INFO)	!
		THEN
		    COND_VAL [STS$V_SEVERITY] = STS$K_SEVERE;

		END;

	    [K_SYS_RESTART] :
		BEGIN

		IF (LIB$MATCH_COND ((SIGNAL_ARGS [CHF$L_SIG_NAME] + (2*%UPVAL)), %REF (BAS$_ON_CHAFIL)))
		THEN
		    BEGIN
!+
! Because the error code is followed by BAS$_ON_CHAFIL the signal must
! have been from BAS$$SIGNAL_IO, so this must be an I/O error.
! If the I/O is to a terminal, the I/O statement can be restarted.
!-

		    IF (OTS$$TERM_IO ()) THEN RESTART_IO_FLAG = 1;

		    END;

		IF (.RESTART_IO_FLAG)
		THEN
		    COND_VAL [STS$V_SEVERITY] = STS$K_WARNING
		ELSE
		    COND_VAL [STS$V_SEVERITY] = STS$K_SEVERE;

		END;
	    TES;

	NEW_VECTOR [1*%UPVAL, 0, %BPVAL, 0] = .COND_VAL;
!<BLF/PAGE>

!+
! Now call LIB$SIGNAL with the argument list we have built.  It will
! invoke this routine recursively for each active frame in the
! user's BASIC program.  Intermediate levels in other languages will
! be skipped over (provided that the other handlers do not intercept
! BASIC error codes--if they do, they presumably know what they are
! doing).  The signal argument list includes a traceback in the user's
! terms.
!-

	IF ((.ERR_SYSTEM [.COND_VAL [STS$V_CODE]] EQL K_SYS_EXIT)	!
	    AND (.SYSTEM_ERROR)			!
	    AND (.COND_VAL [STS$V_SEVERITY] NEQ STS$K_INFO))
	THEN
	    CALLG (.NEW_VECTOR, LIB$STOP)
	ELSE
	    CALLG (.NEW_VECTOR, LIB$SIGNAL);

!+
! If we get here the condition is being continued.
! Either system handling is not being called for, or the system handling
! is not "EXIT".
!-
	LIB$FREE_VM (%REF (.LEN_VECTOR*%UPVAL), NEW_VECTOR);
	LEN_VECTOR = 0;
!+
! If this error is restartable (as determined above) and we are at the
! top level (that is, the level at which the I/O statement was executed)
! and no unwind is called for (that is, the user has not executed an
! error handler, since all error handlers end with a RESUME, which
! causes an unwind) then restart the I/O statement.
!-

	IF (.TOP_LEVEL)
	THEN
	    BEGIN

	    IF ((.RESTART_IO_FLAG) AND (.UNWIND_COUNT EQL 0))
	    THEN
		BEGIN
!+
! Unwind back to the beginning of the caller's I/O statement.
! This cannot be done directly, because we don't know where the
! beginning of the I/O statement is, so we call BAS$$RESTART_IO
! which puts the I/O system back to the way it was when the I/O
! list started, and then restarts the I/O list.  The call is done
! through RESTART_IO to get SP restored properly.
!-
		SYS$UNWIND (MECHANISM_ARGS [CHF$L_MCH_DEPTH], RESTART_IO);
!+
! Since we have taken care of this error, clear the error flag.
!-
		BAS$L_ERRFLG = 0;
		END

	    END;

	END;					! of user does not handle the error

!+
! If either this level or a deeper level has requested that the top level
! do an unwind, and if this is the top level, do the unwind.
!-

    IF (.TOP_LEVEL AND (.UNWIND_COUNT NEQ 0))
    THEN
	BEGIN
	SYS$UNWIND (UNWIND_COUNT, RESTART);
	UNWIND_COUNT = 0;
	END;

!+
! Set GONE_BACK and SYSTEM_ERROR (own cells) for the previous level
! of BAS$HANDLER.
!-
    GONE_BACK = (IF (.TOP_LEVEL) THEN 0 ELSE 1);

    IF (.TOP_LEVEL) THEN SYSTEM_ERROR = 0;

    RETURN (SS$_CONTINUE);
    END;					! of BAS$$HANDLER


GLOBAL ROUTINE BAS$ERL = 			! error line number

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return the line number on which the current error happened.
!	If there is no error in progress, return the line number of
!	the last error, or 0.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	BAS$L_ERL
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The line number, as a 32-bit binary value.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    RETURN (.BAS$L_ERL);
    END;					! of BAS$ERL


GLOBAL ROUTINE BAS$ERR = 			! error number

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return the number of the current error.
!	If there is no error in progress, return the number
!	of the last error, or 0.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	BAS$L_ERR
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The error number, as a 32-bit binary value.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    RETURN (.BAS$L_ERR);
    END;					! of BAS$ERR


GLOBAL ROUTINE BAS$ERN (			! error module name
	DESCRIP					! where to write the name
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return the name of the module in which the current error
!	happened.  If there is no error in progress, return
!	the module name for the last error, or a zero-length string.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.wt.dx	A descriptor into which to write the name of
!			the module.
!
! IMPLICIT INPUTS:
!
!	BAS$T_ERN
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Same as for STR$COPY
!
! SIDE EFFECTS:
!
!	Calls STR$COPY; if it fails, this routine never returns.
!
!--

    BEGIN

    LOCAL
	COPY_STATUS;

    COPY_STATUS = STR$COPY_DX (.DESCRIP, BAS$T_ERN);
    RETURN (COPY_STATUS);
    END;					! of BAS$ERN


GLOBAL ROUTINE BAS$ERT (			! error text
	DESCRIP, 				! where to put text
	ERRNO					! error number
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Return the text of an error message.  If the error number is
!	unreasonable, the result is undefined.  The first character of
!	the message indicates the severity: "?" is a fatal error,
!	"%" is a warning, and all other messages start with a space.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.wt.d	A descriptor into which to write the text of
!			the message.
!	ERRNO.rl.v	The error number for which we want the text.
!
! IMPLICIT INPUTS:
!
!	The system error message file, SYS$MESSAGE:SYSMSG.EXE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Same as STR$CONCAT
!
! SIDE EFFECTS:
!
!	Calls several system functions.  If any fail, this routine
!	never returns.
!
!--

    BEGIN

    LOCAL
	CONCAT_RESULT,				! Status from STR$CONCAT
	GETMSG_RESULT,				! remembers status of SYS$GETMSG
	LOCAL_DESCRIP : BLOCK [8, BYTE],	! message descriptor
	Q_DESC : BLOCK [8, BYTE],		! Points to ?, % or space
	Q_BUF : VECTOR [1, BYTE],		! Holds the ?, % or space
	LOCAL_BUF : VECTOR [256, BYTE],		! Buffer got SYS$GETMSG
	DUMMY;					! used to discard last value from SYS$GETMSG

!+
! Set up the local descriptor.
!-
    LOCAL_DESCRIP [DSC$W_LENGTH] = 256;
    LOCAL_DESCRIP [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LOCAL_DESCRIP [DSC$B_CLASS] = DSC$K_CLASS_S;
    LOCAL_DESCRIP [DSC$A_POINTER] = LOCAL_BUF;
!+
! Get the message text from SYS$MESSAGE:SYSMSG.EXE
!-
    GETMSG_RESULT = SYS$GETMSG (BAS$$COND_VAL (.ERRNO), LOCAL_DESCRIP, LOCAL_DESCRIP, 1, DUMMY);

    IF ( NOT .GETMSG_RESULT) THEN LIB$STOP (.GETMSG_RESULT);

!+
! Copy the message text to the user's string, concatenating a ?, % or
! space onto its front to indicate the severity of the error.
!-
    Q_DESC [DSC$W_LENGTH] = 1;
    Q_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    Q_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    Q_DESC [DSC$A_POINTER] = Q_BUF [0];
    Q_BUF [0] =
    BEGIN

    CASE .ERR_SEVERITY [.ERRNO] FROM STS$K_WARNING TO STS$K_SEVERE OF
	SET

	[STS$K_WARNING] :
	    %C'%';

	[STS$K_SEVERE, STS$K_ERROR] :
	    %C'?';

	[INRANGE, OUTRANGE] :
	    %C' ';
	TES

    END;
    CONCAT_RESULT = STR$CONCAT (.DESCRIP, Q_DESC, LOCAL_DESCRIP);
    RETURN (.CONCAT_RESULT);
    END;					! of BAS$ERT


GLOBAL ROUTINE BAS$ERROR (			! signal an error
	ERRNO					! error number
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Signals an error.  This is called from the compiled code when
!	an error condition is detected in line.  It can also be called
!	by user code directly.
!
! FORMAL PARAMETERS:
!
!	ERRNO.rl.v	The error number which we want to signal.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May never return to its caller.
!
!--

    BEGIN
!+
! Don't allow error numbers above 255, since we keep some internal
! messages up there.
!-

    IF (.ERRNO LEQU 255) THEN BAS$$SIGNAL (.ERRNO) ELSE BAS$$STOP (BAS$K_PROLOSSOR);

    END;					! of BAS$ERROR


GLOBAL ROUTINE BAS$$ERR_INIT : NOVALUE = 	! Initialize error flag

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize the error status.  This is used by the RUN command in case the user
!	does a RUN following an error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	All of the error cells that the user can see.
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	After this routine has been called, we are not in an error handler.
!	Also, the error stack is empty.
!
!--

    BEGIN
!+
! First, empty the error stack.
!-

    WHILE (.ERROR_STACK [0] NEQA .ERROR_STACK [1]) DO
	BAS$POP_ERR ();

!+
! Then make sure we are not in an error routine.
!-
    BAS$L_ERRFLG = 0;
!+
! See to it that all user-visible cells are in their initial states.
!-
    BAS$A_CH_CUR_LN = 0;
    BAS$L_GOING_BACK = 0;
    SYSTEM_ERROR = 0;
    GONE_BACK = 0;
    BAS$L_ERL = 0;
    BAS$L_ERR = 0;
    BAS$T_ERN [DSC$W_LENGTH] = 0;
    END;					! of BAS$$ERR_INIT


GLOBAL ROUTINE BAS$PUSH_ERR = 			! Push error status

!++
! FUNCTIONAL DESCRIPTION:
!
!	Save the error state on the error stack, so a BASIC program can
!	be run independent of the error flag.
!
! CALLING SEQUENCE:
!
!	CALL BAS$PUSH_ERR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	The OWN cells which represent the error status.
!
! IMPLICIT OUTPUTS:
!
!	The error stack
!
! SIDE EFFECTS:
!
!	Calls LIB$GET_VM to get virtual memory.
!--

    BEGIN

    BUILTIN
	INSQUE;

    LOCAL
!+
! Declare the pointer to the block to push.
!-
	PUSH : REF BLOCK [PUSH$K_LENGTH, BYTE] FIELD (PUSH_ITEM);

!+
! If this is the first PUSH, initialize the queue.
!-

    IF ( NOT .ERROR_STACK_INI)
    THEN
	BEGIN

	LOCAL
	    AST_STATUS;

	AST_STATUS = $SETAST (ENBFLG = 0);

	IF ( NOT .ERROR_STACK_INI)
	THEN
	    BEGIN
	    ERROR_STACK [0] = ERROR_STACK [1] = ERROR_STACK [0];
	    ERROR_STACK_INI = 1;
	    END;

	IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST (ENBFLG = 1);

	END;

!+
! Get virtual memory to hold the error state.
!-
    BEGIN

    LOCAL
	GET_VM_RESULT;

    GET_VM_RESULT = LIB$GET_VM (%REF (PUSH$K_LENGTH), PUSH);

    IF ( NOT .GET_VM_RESULT) THEN BAS$$STOP (BAS$K_MAXMEMEXC);

    END;
!+
! Fill in.
!-
    PUSH [PUSH$L_ERRFLG] = .BAS$L_ERRFLG;
    CH$MOVE (8, BAS$T_ERN, PUSH [PUSH$T_ERN]);
    PUSH [PUSH$L_ERR] = .BAS$L_ERR;
    PUSH [PUSH$L_ERL] = .BAS$L_ERL;
    PUSH [PUSH$L_HGH_LVL] = .HIGHEST_LEVEL;
    PUSH [PUSH$A_HGH_FMP] = .HIGHEST_FMP;
    PUSH [PUSH$L_ACC_LVL] = .ACCUM_LEVEL;
    PUSH [PUSH$L_UNW_CNT] = .UNWIND_COUNT;
    PUSH [PUSH$L_SYS_ERR] = .SYSTEM_ERROR;
    PUSH [PUSH$L_GONE_BAK] = .GONE_BACK;
    PUSH [PUSH$A_CUR_LIN] = .BAS$A_CH_CUR_LN;
    PUSH [PUSH$L_GOING_BACK] = .BAS$L_GOING_BACK;
    PUSH [PUSH$A_RESTART] = .BAS$A_RESTART;
!+
! Put this item on the error stack.
!-
    INSQUE (.PUSH, ERROR_STACK);
!+
! Make sure there is no error outstanding.
!-
    BAS$L_ERRFLG = 0;
    BAS$A_CH_CUR_LN = 0;
    BAS$L_GOING_BACK = 0;
    SYSTEM_ERROR = 0;
    GONE_BACK = 0;
!+
! Successful completion.
!-
    RETURN (SS$_NORMAL);
    END;					! of routine BAS$PUSH_ERR


GLOBAL ROUTINE BAS$POP_ERR = 			! Pop error status

!++
! FUNCTIONAL DESCRIPTION:
!
!	Restore the error state from the error stack.
!
! CALLING SEQUENCE:
!
!	CALL BAS$POP_ERR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	The error stack.
!
! IMPLICIT OUTPUTS:
!
!	The OWN storage which represents the error state.
!
! SIDE EFFECTS:
!
!	Calls LIB$FREE_VM to free virtual memory.
!--

    BEGIN

    BUILTIN
	REMQUE;

    LOCAL
	PUSH : REF BLOCK [PUSH$K_LENGTH, BYTE] FIELD (PUSH_ITEM);

!+
! Get an item off the error stack.  It had better be there.
!-

    IF (REMQUE (.ERROR_STACK [0], PUSH)) THEN BAS$$STOP (BAS$K_PROLOSSOR);

!+
! Copy the data from the stack into the OWN cells, thus reestablishing
! the error environment at the time of the PUSH.
!-
    BAS$L_ERRFLG = .PUSH [PUSH$L_ERRFLG];
    CH$MOVE (8, PUSH [PUSH$T_ERN], BAS$T_ERN);
    BAS$L_ERR = .PUSH [PUSH$L_ERR];
    BAS$L_ERL = .PUSH [PUSH$L_ERL];
    HIGHEST_LEVEL = .PUSH [PUSH$L_HGH_LVL];
    HIGHEST_FMP = .PUSH [PUSH$A_HGH_FMP];
    ACCUM_LEVEL = .PUSH [PUSH$L_ACC_LVL];
    UNWIND_COUNT = .PUSH [PUSH$L_UNW_CNT];
    SYSTEM_ERROR = .PUSH [PUSH$L_SYS_ERR];
    GONE_BACK = .PUSH [PUSH$L_GONE_BAK];
    BAS$A_CH_CUR_LN = .PUSH [PUSH$A_CUR_LIN];
    BAS$L_GOING_BACK = .PUSH [PUSH$L_GOING_BACK];
    BAS$A_RESTART = .PUSH [PUSH$A_RESTART];
!+
! We are done with the item from error stack, free it.
!-
    BEGIN

    LOCAL
	FREE_VM_RESULT;

    FREE_VM_RESULT = LIB$FREE_VM (%REF (PUSH$K_LENGTH), PUSH);

    IF ( NOT .FREE_VM_RESULT) THEN BAS$$STOP (BAS$K_PROLOSSOR);

    END;
    RETURN (SS$_NORMAL);
    END;					! of routine BAS$POP_ERR

END

ELUDOM
