MODULE BAS$$REC_PROC (				! Record processing level of abstraction
		IDENT = '1-085'			! File: BASRECPRO.B32 Edit:PL1085
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: BASIC Support Library - not user callable
!
! ABSTRACT:
!
!	This module implements the record processing level of
!	abstraction which is the 3rd level and is called only from
!	the user data formatter level (2nd level) when the user
!	portion of a record buffer is full (WRITE) or empty
!	(READ). This module adds any per record formatting (as
!	distinguished from per I/O statement or per I/O list element
!	formatting) and then calls RMS ($PUT or $GET). RMS errors
!	are converted to BASIC errors and are signaled.
!
! ENVIRONMENT:	User access mode; AST level or not.
!
! AUTHOR:	Donald G. Petersen;	CREATION DATE: 16-Mar-78
!
! MODIFIED BY:
!
! 0-61	- Add ATTEMPT TO READ NON-EXISTANT RECORD error to seq. reads.
!	  JMT 02-Jan-78
! 	Donald G. Petersen, 16-Mar-78 : VERSION 1-01
! 1-01	- original DGP
! 1-02	- Change to JSB linkages.  DGP 14-Nov-78
! 1-004	- Update copyright notice and add device names to REQUIRE
!	   files.  JBS 29-NOV-78
! 1-005	- Add BAS$RECOUN to support the Basic RECOUNT function. DGP
!	  03-Dec-78
! 1-006 - Dot problem in BAS$RECOUNT.  DGP 04-Dec-78
! 1-007 - Add fudge factor to RECOUNT for the line terminator if input is
!	  from a terminal.  DGP 04-Dec-78
! 1-008	- Change REQUIRE file names from FOR... to OTS...  JBS 07-DEC-78
! 1-009	- Call BAS$$SIGNAL_IO for RMS errors.  JBS 18-DEC-78
! 1-010 - Add new routines for READ.  DGP 19-Dec-78
! 1-011 - Change references to ISB$A_BUF_PTR, BUF_BEG, BUF_END to LUB.
!	  DGP 05-Jan-78
! 1-012 - Change to CR format for terminal data files.  DGP 11-Jan-79
! 1-013 - Make a few changes for recursive I/O.  DGP 15-Jan-79
! 1-014 - Remove signalling for ^Z.  Moved to UDF level for INPUT LINE hand-
!	  ling.  DGP 15-Jan-79
! 1-015	- Change stack frame prefix to BSF$.  JBS 08-FEB-1979
! 1-016 - Add BAS$$REC_GSE (Basic GET sequential).  DGP 19-Feb-79
! 1-017 - Add BAS$$REC_PSE (Basic PUT sequential).  DGP 20-Feb-79
! 1-018 - set RAB$L_RBF in BAS$$REC_PSE.  DGP 20-Feb-79
! 1-019 - Set RAB$L_RBF in BAS$GSE.  DGP 21-Feb-79
! 1-020 - Null fill buffer for GET.  DGP 27-Feb-79
! 1-021 - Add REC routines for FIND, DELETE, UPDATE, RESTORE, SCRATCH.  DGP
!	  27-Feb-79
! 1-022 - Add BASIOERR.REQ for error handling.  DGP 28-Feb-79
! 1-023 - Add BASUNLOCK and BASFREE.  DGP 28-Feb-79
! 1-024 - Set RAB$L_RBF in BAS$$REC_UPD.  DGP 01-Mar-79
! 1-025 - Add REC_PRE, REC_GRE, REC_FRE.  DGP 02-Mar-79
! 1-026 - More work on relative I/O.  DGP 05-Mar-79
! 1-027 - Update pointer for READ in Basic Major Frame in RMF9.  DGP 06-Mar-79
! 1-028 - Add support for Basic "foreign buffers".  DGP 27-Mar-79
! 1-029 - Point all GETs and PUTs off to GET_ERROR or PUT_ERROR. DGP 02-Apr-79
! 1-030 - Add more routines to support ISAM.  DGP 03-Apr-79
! 1-031 - Fix PUT sequential to support ISAM.  DGP 04-Apr-79
! 1-032 - Put in indexed I/O stuff. 06-Apr-79
! 1-033 - Bug fixes in indexed.  10-Apr-79  DGP
! 1-034	- Implement the WAIT statement, using LUB$L_WAIT_TIME.
!	   JBS 10-APR-1979
! 1-035	- Implement the ECHO and NOECHO functions, using LUB$V_NOECHO.
!	   JBS 17-APR-1979
! 1-036	- Add code to handle single-character input from GET
!	   SEQUENTIAL.  JBS 17-APR-1979
! 1-037	- Implement the CTRLO and RCTRLO functions, using LUB$V_CCO.
!	   JBS 19-APR-1979
! 1-038	- Implement the Cancel Typeahead function, using LUB$V_PTA.
!	   JBS 01-MAY-1979
! 1-039 - Add Basic PRINT USING support.  DGP 15-May-79
! 1-040	- Change BIND to GLOBAL BIND ROUTINE in PRINT USING support.
!	   JBS 16-MAY-1979
! 1-041	- Add BAS$RECOU_INIT.  JBS 04-JUN-1979
! 1-042 - Add REC level for MAT INPUT.  DGP 05-Jun-79
! 1-043 - Clean up a lot and put real code into Matrix Input routines.  DGP
!	  14-Jun-79
! 1-044 - Make REC_MIN1 look for continuation character.  DGP 20-Jun-79
! 1-045 - Terminal devices use PRN format for output.  DGP 10-Jul-79
! 1-046 - Add BAS$$NUM_INIT, BAS$$NUM2_INIT, BAS$MAT_LINPUT, BAS$MAT_READ,
!	  BAS$NUM, BAS$NUM.  DGP 13-Jul-79
! 1-047	- Change ISB$L_MAJ_F_PTR to ISB$A_MAJ_F_PTR.  JBS 24-JUL-1979
! 1-048 - Signal if READ with no DATA.  DGP 07-Aug-79
! 1-049 - Debug MAT I/O.  DGP 07-Aug-79
! 1-050 - STOP a few errors that are being SIGNALled.  DGP 05-Sep-79
! 1-051 - FREE and UNLOCK are noops if no record locked.  DGP 06-Sep-79
! 1-052 - Move NUM_INIT and NUM2_INIT to BAS$MAT_IO, and move BAS$$BLNK_LINE
!	  from BAS$MAT_IO to here.  DGP  06-Sep-79
! 1-053 - Load LUB$A_RBUF_ADR for GET and PUT for Locate mode (RMS).  DGP
!	  13-Sep-79
! 1-054 - Clear the prompt buffer in GET_ERROR.  DGP 17-Sep-79
! 1-055 - Fix BAS$$BLNK_LINE.  DGP 04-Oct-79
! 1-056 - Add MAT READ.  DGP 11-Oct-79
! 1-057 - Add a REC9 routine for MAT PRINT.  DGP 12-Oct-79
! 1-058 - Add BAS$$REC_MLI1.  DGP 12-Oct-79
! 1-059 - Fix BAS$$REC_WSL1 to leave the cursor alone.  DGP 02-Nov-79
! 1-060 - Allow BAS$$REC_WSL1 to accept an argument.  DGP 06-Nov-79
! 1-061 - GET will only null fill the buffer, if necessary, after a GET.  DGP
!	  12-Nov-79
! 1-062 - BAS$$REC_MPR1 needs an LF if no format char.  DGP 13-Nov-79
! 1-063	- Use LUB$A_UBF to simplify foreign buffer code.  JBS 13-NOV-1979
! 1-064 - BAS$$REC_MIN1 should not differentiate between terminal & non-
!	  terminal devices.  DGP 14-Nov-79
! 1-065 - GET relative not null filling the buffer properly.  DGP 29-Nov-79
! 1-066 - Null fill the buffer before restoring foreign buffer pointers for
!	  GET.  DGP 18-Dec-79
! 1-067 - RMS does not return a terminator in the STV field for files.  DGP
!	  03-Jan-80
! 1-068 - REC_WSL9 should only write a record if the output buffer has some-
!	  thing in it to write.  DGP 03-Jan-80
! 1-069 - Addition to 1-068.  Should also write a record if there was no element
!	  transmitter.  DGP 04-Jan-80
! 1-070 - Unconditionally write a CR in WSL1.  DGP 14-Jan-80
! 1-071 - Restore "foreign buffers" properly and set RECOUNT in GET Indexed
!	  and Relative.  DGP 12-Feb-80
! 1-072 - Adjust the Global RECOUNT to include the length of an escape sequence.
!	  DGP 22-Feb-80
! 1-073 - A previous edit to fix a problem with foreign buffers reintroduced
!	  a problem with only null padding the buffer after a successful GET.
!	  DGP 26-Feb-80
! 1-074 - REC_WSL9 should set VFC2 to BAS$K_NULL (no carriage control) if there
!	  is a format character. DGP 26-Feb-80
! 1-075 - Update the cursor position for INPUT if terminated by an escape.
!	  DGP 27-Feb-80
! 1-076 - When calculting CCPOS (current cursor position) following an INPUT
!	  statement, take the prompt string into account.
! 1-077 - REC_RSL1 is not updating the cursor position correctly.  DGP 04-Mar-80
! 1-078 - REC_WSL9 should set the 'pre' carriage control for the next record
!	  to LF if there is no format charcter 'cuz of recursive I/O.  DGP
!	  07-Mar-80
! 1-079	- Rationalize the CCO and PTA bits.  CCO is now copied from LUB to RAB
!	   when initializing for output, and PTA when initializing for input.
!	   JBS 31-MAR-1980
! 1-080 - Clear the dirty bit CCB [LUB$V_OUTBUF_DR] in PUT_ERROR so BAS$CLOSE
!	  when invoked by the unwind won't get confused and do a PUT.
!	  FM 11-SEP-80
! 1-081 - Tack on the terminator(s) to the buffer when a GET is done on a 
!	  terminal device file in BAS$$REC_GSE.
! 1-082- Add/transfer BAS$WAIT to this module, now wait routines are part of
!	  the sharable image.  The routines added are BAS$WAIT, 
!	  BAS$$READ_WAIT.  We had to make WAIT routines part of the sharable 
!	  image because WAIT was requested to become a GLOBAL, and routines in
!	  this module had to read it.
! 1-083- Only if LUB$B_RAT indicates CR format tack on the CRLF. FM 9-feb-81
! 1-084-  Cursor position not updated correctly if INPUT was
!         terminated by an escape - code should check if previous
!	  PRINT was terminated by a semicolon or comma.  PLL 5-7-81
! 1-085- The purge typeahead function is no longer setting the PTA bit in
!	 the LUB, so BAS$$REC_RSL0, BAS$$REC_MIN0, and BAS$$REC_GSE don't need
!	 to check it anymore.  PLL 6-Aug-81
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
!	LINKAGES
!

REQUIRE 'RTLIN:OTSLNK';				! define all linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$WAIT : NOVALUE,				! Writes into module level OWN WAIT
    BAS$$READ_WAIT,				! Reads the module level OWN WAIT
    BAS$RECOUNT,				! Support Basic RECOUNT function
    BAS$$RECOU_INIT : NOVALUE,			! Initialize RECOUNT
    BAS$$BLNK_LINE : CALL_CCB NOVALUE,		! print a blank line
    ! write sequential list-directed
    BAS$$REC_WSL0 : JSB_REC0 NOVALUE,		! initialize output buffer
    BAS$$REC_WSL1 : JSB_REC_WSL1 NOVALUE,	! write all but last record
    BAS$$REC_WSL9 : JSB_REC9 NOVALUE,		! write last record
    ! Mat Linput
    BAS$$REC_MLI1 : JSB_REC1,			! always read another record
    ! Mat Read
    BAS$$REC_MRE1 : JSB_REC1,			! return a failure
    ! Mat Print
    BAS$$REC_MPR1 : JSB_REC1 NOVALUE,		! write one buffer
    BAS$$REC_MPR9 : JSB_REC9 NOVALUE,		! terminate Mat Print
    ! read sequential list-directed
    BAS$$REC_RSL0 : JSB_REC0 NOVALUE,		! read first
    BAS$$REC_RSL1 : JSB_REC1,			! read next
    BAS$$REC_RSL9 : JSB_REC9 NOVALUE,		! no-op
    ! MAT INPUT
    BAS$$REC_MIN0 : JSB_REC0 NOVALUE,		! initialize MAT INPUT
    BAS$$REC_MIN1 : JSB_REC1,			! record handler
    BAS$$REC_MIN9 : JSB_REC9 NOVALUE,		! terminate MAT INPUT
    ! read memory list-directed
    BAS$$REC_RMF0 : JSB_REC0 NOVALUE,		! initialize read memory
    BAS$$REC_RMF1 : JSB_REC1 NOVALUE,		! signal insufficient data
    BAS$$REC_RMF9 : JSB_REC9 NOVALUE;		! no-op

GLOBAL BIND
    ROUTINE
    ! write formatted
    BAS$$REC_WF0 = BAS$$REC_WSL0,
    BAS$$REC_WF1 = BAS$$REC_WSL1,
    BAS$$REC_WF9 = BAS$$REC_WSL9;

FORWARD ROUTINE
    ! record operations
    BAS$$REC_GSE : JSB_DO_READ NOVALUE,		! GET sequential
    BAS$$REC_PSE : JSB_PUT NOVALUE,		! PUT sequential
    BAS$$REC_FSE : JSB_REC0 NOVALUE,		! FIND sequential
    BAS$$REC_DSE : JSB_REC0 NOVALUE,		! DELETE sequential
    BAS$$REC_UPD : JSB_DO_WRITE NOVALUE,	! UPDATE
    BAS$$REC_RSE : JSB_REC0 NOVALUE,		! RESTORE sequential
    BAS$$REC_SSE : JSB_REC0 NOVALUE,		! SCRATCH
    BAS$$REC_PRE : JSB_PUT NOVALUE,		! PUT relative with count
    BAS$$REC_GRE : JSB_DO_READ NOVALUE,		! GET relative
    BAS$$REC_FRE : JSB_REC0 NOVALUE,		! FREE relative
    BAS$$REC_UNL : JSB_REC0 NOVALUE,		! UNLOCK
    BAS$$REC_FEE : JSB_REC0 NOVALUE,		! FREE
    BAS$$REC_GIN : JSB_REC_IND NOVALUE,		! GET indexed
    BAS$$REC_FIN : JSB_REC_IND NOVALUE,		! FIND indexed
    BAS$$REC_RIN : JSB_REC_IND NOVALUE,		! RESTORE indexed
    PUT_ERROR : CALL_CCB NOVALUE,		! error in $PUT
    GET_ERROR : CALL_CCB NOVALUE;		! error in $GET

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:BASIOERR';			! I/O error codes

REQUIRE 'RTLIN:BASFRAME';			! Basic frame offsets

REQUIRE 'RTLML:OTSISB';				! I/O statement block (ISB) offsets

REQUIRE 'RTLML:OTSLUB';				! Logical unit block (LUB) offsets

REQUIRE 'RTLIN:OTSMAC';				! Macros

REQUIRE 'RTLIN:RTLPSECT';			! Define DECLARE_PSECTS macro

REQUIRE 'RTLML:BASPAR';				! BASIC inter-module parameters

LIBRARY 'RTLSTARLE';				! STARLET library for macros and symbols

!
!  MACROS:
!
! 	NONE
!
!  EQUATED SYMBOLS:
!

LITERAL
    K_MAT_CONT_CHAR = %X'26',			! '&' - Mat Input continuation
    						! character
    K_STOP = 0,					! stop after signalling this error
    K_SIGNAL = 1;				! signal and allow restart

!
!  PSECT DECLARATIONS:
!
DECLARE_PSECTS (BAS);				! declare PSECTs for BAS$ facility
!
!  OWN STORAGE:

OWN
    RECOUNT : INITIAL (0),
    WAIT    : WORD INITIAL (0);

!
!  EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BAS$$SIGNAL : NOVALUE,			! Signal a BASIC error
    BAS$$STOP_IO : NOVALUE,			! Signal fatal Basic error
    BAS$$SIGNAL_IO : NOVALUE;			! Signal a BASIC I/O error

!

EXTERNAL LITERAL
    BAS$K_OUTOF_DAT : UNSIGNED (8),		! out of data (READ)
    BAS$K_ENDFILDEV : UNSIGNED (8),		! end of file on device
    BAS$K_NOTENODAT : UNSIGNED (8),		! not enough data
    BAS$K_RECFILTOO : UNSIGNED (8);		! record in file too long

!


GLOBAL ROUTINE BAS$WAIT (			!Limit input wait time
	TIME					!Seconds to limit time
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Limits the time any input I/O statement ( INPUT, INPUT LINE, LINPUT,
!	MAT 'all above', GET ) to any terminal will wait. If the user does not
!	reply before the indicated number of seconds an error trap ( which the
!	user can intercept ) will be taken.  WAIT is a module level OWN in this
!	module.
!
!
! FORMAL PARAMETERS:
!
!	TIME.rl.v	Number of seconds to wait, max.
!
! IMPLICIT INPUTS:
!
!	The module level OWN WAIT
!
! IMPLICIT OUTPUTS:
!
!	Writes to the module level OWN WAIT the number of seconds given
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN
!+
! If the WAIT time is unreasonable then force it to the acceptable range.
! This is until the correct error message is cooked up for this error.
! WAIT is a module level OWN.
!-
    WAIT = MIN ( ABS(.TIME) , 255 );
    RETURN;
    END;				!End of BAS$WAIT


ROUTINE BAS$$READ_WAIT			!Read the module level OWN WAIT
    : =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read the module level OWN WAIT and return it.  The value of this
!	function is the current contents of wait.  All routines that need
!	this value must call this routine.
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	Reads the module level OWN WAIT
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	The contents of module level OWN WAIT
!
! SIDE EFFECTS:
!
!	None
!--

    BEGIN
!+
! Just return the value of the module level OWN WAIT
!-
    RETURN .WAIT;
    END;				!End of BAS$$READ_WAIT


GLOBAL ROUTINE BAS$RECOUNT 			! RECOUNT
    : =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine supports the Basic RECOUNT function.  It returns the number
!	of bytes read on the last Get.  It utilizes a piece of OWN storage which
!	is written to by the record processing levels which do Gets.  In order
!	to keep the OWN storage from having to be global, this routine is included
!	in this module.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	RECOUNT.rl		The number of bytes read on the last GET
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NUM_OF_BYTES.wl.v	number of bytes read on last Get
!
! SIDE EFFECTS:
!
!--

    BEGIN
    RETURN .RECOUNT
    END;					! End of BAS$RECOUNT


GLOBAL ROUTINE BAS$$RECOU_INIT : NOVALUE = 	! Initialize RECOUNT

!++
! FUNCTIONAL DESCRIPTION:
!
!
!	This routine initializes the RECOUNT variable.  It is used before a RUN
!	compiler command in case the previous run of the user's program left
!	something in RECOUNT.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RECOUNT.wl	Always set to zero.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN
    RECOUNT = 0;
    END;					! End of BAS$$RECOU_INIT


GLOBAL ROUTINE BAS$$BLNK_LINE (			! write a blank line
	FORMAT_CHAR) : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Print out a blank line.  This is needed between arrays.
!
! FORMAL PARAMETERS:
!
!	FORMAT_CHAR.rlu.v		the format character last used
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

!+
! Actually put out the blank line here.
!-
    CCB [RAB$W_RSZ] = 0;
    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_BEG];
    CCB [LUB$B_BAS_VFC1] = BAS$K_LF;
    CCB [LUB$B_BAS_VFC2] = BAS$K_CR;

    IF NOT $PUT (RAB = .CCB) THEN PUT_ERROR (K_STOP);

    RETURN;
    END;					!End of BAS$$BLNK_LINE


GLOBAL ROUTINE BAS$$REC_MPR1 			! Write Mat Print record
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one sequential formatted record and initialize for the next
!	BAS$$REC_MPR1 writes one record for 10 MAT PRINT A() and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!	FLR records are space padded.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$V_FORM_CHAR		=1, comma or semicolon format character
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!	LUB$A_BUF_END		points to last char inserted into buffer
!				by UDF level I/O.
!	LUB$V_FORCIBLE		Indicates a forcible device
!	LUB$V_OUTBUF_DR		Indicates that there is valid data in the output
!				buffer
!	RAB$W_RSZ		Record size
!
! IMPLICIT OUTPUTS:
!
!	LUB$B_BAS_VFC2		'Post' carriage control for terminal devices
!	LUB$A_BUF_PTR		Address of next char in user part
!				of record buffer
!	LUB$A_BUF_END		Address of last+1 char in user part
!				of record buffer
!	LUB$V_OUTBUF_DR		indicates valid data in the output buffer
!	LUB$A_BUF_BEG		Beginning of the user buffer
!	RAB$L_RBF		Pointer to the user record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If there is no format character, then set the 'pre' and 'post'
    ! carriage control to delimit a record.
    !-

    IF NOT .CCB [LUB$V_FORM_CHAR]
    THEN
	BEGIN
	CCB [LUB$B_BAS_VFC1] = BAS$K_LF;
	CCB [LUB$B_BAS_VFC2] = BAS$K_CR;
	END;

    !+
    ! Set recordsize to actual length of record
    !-

    CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_BUF_BEG];

    !+
    ! Output buffer to RMS and check for errors
    ! If errors, SIGNAL BAS$_FATSYSIO (12='FATAL SYSTEM I/O FAILURE')
    !-

    CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$V_OUTBUF_DR] = 0;

    IF NOT $PUT (RAB = .CCB)
    THEN

    !+
    ! Not OPEN or CONNECT - RMS record operation
    !-

	PUT_ERROR (K_STOP);

    !+
    ! Return next output buffer start and end addresses
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! End of routine - BAS$$REC_MPR1


GLOBAL ROUTINE BAS$$REC_MPR9 			! Mat Write sequential
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine does not write a record.  Presumably the MAT PRINT element
!	transmitter took care of all of that.  Since we do not want a blank line
!	after the array, there is no need to write anything here.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Address of next char in user part
!				of record buffer
!	LUB$A_BUF_END		Address of last+1 char in user part
!				of record buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Return next output buffer start and end addresses
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! END BAS$$REC_MPRI9


GLOBAL ROUTINE BAS$$REC_WSL9 			! Write sequential formatted
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one sequential formatted record and initialize for the next
!	BAS$$REC_WSF1 (and BAS$$REC_WSL9) writes one output buffer and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!	FLR records are space padded.
!	/logical record number is incremented/.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ISB$V_PRINT_INI		flag to indicate whether there was an element
!				transmitter
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!	LUB$A_BUF_END		points to last char inserted into buffer
!				by UDF level I/O.
!	LUB$V_FORM_CHAR		The last element transmitter ended in a comma
!				or semicolon format char.
!	LUB$V_FORCIBLE		Indicates a forcible device
!	LUB$V_OUTBUF_DR		Indicates that there is valid data in the output
!				buffer
!	RAB$W_RSZ		Record size
!
! IMPLICIT OUTPUTS:
!
!	ISB$V_PRINT_INI		reset flag
!	LUB$B_BAS_VFC2		'Post' carriage control for terminal devices
!	LUB$A_BUF_PTR		Address of next char in user part
!				of record buffer
!	LUB$A_BUF_END		Address of last+1 char in user part
!				of record buffer
!	LUB$V_OUTBUF_DR		indicates valid data in the output buffer
!	LUB$A_BUF_BEG		Beginning of the user buffer
!	RAB$L_RBF		Pointer to the user record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If last element ended with a format character and not a terminal device
    ! then return to caller without writing anything.  With CR format, we must
    ! PUT a whole record.
    !-

    IF .CCB [LUB$V_FORM_CHAR] AND NOT .CCB [LUB$V_FORCIBLE] THEN RETURN;

    !+
    ! Set the 'post' carriage control to carriage return
    ! if the last element transmitter had no format character following.
    !-

    IF NOT .CCB [LUB$V_FORM_CHAR] THEN CCB [LUB$B_BAS_VFC2] = BAS$K_CR;

    !+
    ! Set recordsize to actual length of record
    !-

    CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_BUF_BEG];

    !+
    ! Output buffer to RMS and check for errors
    ! If errors, SIGNAL BAS$_FATSYSIO (12='FATAL SYSTEM I/O FAILURE')
    !-

    CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];
!+
! Write something if there is something in the buffer or if there was no
! element transmitter.
!-

    IF .CCB [LUB$V_OUTBUF_DR] OR .CCB [ISB$V_PRINT_INI]
    THEN

	IF NOT $PUT (RAB = .CCB)
	THEN
!+
! Go to central PUT error handler.
!-
	    PUT_ERROR (K_STOP);

    CCB [LUB$V_OUTBUF_DR] = 0;
    CCB [ISB$V_PRINT_INI] = 0;
!+
! If there is no format character then set the 'pre' carriage control to LF
! for the next record.  This is recursive I/O and the rest of the list when
! we return should be written on the next line.
!-

    IF NOT .CCB [LUB$V_FORM_CHAR] THEN CCB [LUB$B_BAS_VFC1] = BAS$K_LF;

    !+
    ! Return next output buffer start and end addresses
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE BAS$$REC_RSL0 			! Read initialization
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_RSF0 (and BAS$$REC_RSF1) reads one record if this is not a terminal.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!	LUB$V_TERM_DEV		flag in LUB which indicates a terminal device.
!	RAB$W_RSZ		word in the RAB which contains the buffer size.
!	RAB$L_RBF		longword in RAB which points to the buffer.
!	LUB$L_WAIT_TIME		Max time to wait for input, in seconds.
!	WAIT			The module level OWN WAIT
!
! IMPLICIT OUTPUTS:
!
!	RECOUNT			Global storage to hold number of bytes read from
!				last Input.
!	LUB$L_LOG_RECNO		Increment logical record number
!				of next record to be read.
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	Throws away things that are pending in the Print buffer for non-terminal
!	devices.
!	SIGNALs RMS errors directly.
!	SIGNALs BAS$K_TIMLIMEXC if a wait time was specified and we
!				exceed it.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LITERAL
	K_ESCAPE = %X'1B',
	K_CR = %X'0D';

    LOCAL
	WAIT_TIME;			! Current wait time
!+
! If a timeout has been specified, store information in the RAB to tell
! RMS about it.  If no timeout has been specified, clear the TMO bit
! in case there was an earlier timeout specified.
!-

!+
! If WAIT is zero then use the LUB's wait. This is to provide upward compatibility
! , i.e. existing EXE's can run with the LUB wait value in V2.2.
!-
    WAIT_TIME = ( IF ( .WAIT EQL 0 ) THEN .CCB [ LUB$L_WAIT_TIME ] ELSE .WAIT );

    IF ( .WAIT_TIME EQL 0)
    THEN
	CCB [RAB$V_TMO] = 0
    ELSE
	BEGIN
	CCB [RAB$B_TMO] = .WAIT_TIME;
	CCB [RAB$V_TMO] = 1;
	END;


!+
! Set the Read-no-echo RMS bit based on the user's last call to
! ECHO or NOECHO.
!-
    CCB [RAB$V_RNE] = .CCB [LUB$V_NOECHO];

    !+
    ! Check to see if this is a terminal device.  If this is NOT
    ! a terminal then do a GET.  GETs for terminals are done each time more
    ! data are needed.
    ! Read record into buffer using RMS and check for errors
    !-

    IF ( NOT .CCB [LUB$V_TERM_DEV])
    THEN
	BEGIN

	!+
	! If there is something pending in the Print buffer then throw it
	! away.  The pending Print data does not need to become a prompt
	! because prompts to disk files are thrown away by RMS.  Also, the
	! Print data can't just be ignored because eventually it may overflow
	! the Print buffer forcing a PUT which will result in an error.
	!-

	LOCAL
	    TEMP_CCB : REF BLOCK [, BYTE];	! Temporary CCB

	TEMP_CCB = .CCB [LUB$A_BUDDY_PTR];
	TEMP_CCB [LUB$A_BUF_PTR] = .TEMP_CCB [LUB$A_BUF_BEG];

	IF NOT $GET (RAB = .CCB) THEN GET_ERROR (K_STOP);

	!+
	! Set RECOUNT to the number of bytes read
	! If the file is a terminal format file, then RECOUNT has to be
	! adjusted for the carriage control terminator.  Because RMS does not return
	! a terminator for a file, we unconditionally put a CRLF on the end and
	! bump RECOUNT by 2.
	!-

	RECOUNT = .CCB [RAB$W_RSZ] + (IF (.CCB [LUB$V_TERM_FOR]) AND ((.CCB [LUB$B_RAT] AND FAB$M_CR) NEQU 0)
	THEN 2 ELSE 0);
!+
! Put the CR into the STV field since RMS doesn't
! We should only do this if the record attributes indicate a CR format.
!-

	IF (.CCB [LUB$B_RAT] AND FAB$M_CR) NEQU 0 THEN CCB [RAB$L_STV] = 13;

	!+
	! Return start-1 and end+1 address of record just read
	!-

	CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF] - 1;
	CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];
	END
    ELSE

    !+
    ! This is a terminal.  Force a no data in the buffer condition
    ! so the first GET is done on the element transmitter after the
    ! Prompt (if any) is known.
    !-

	BEGIN
	CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF];
	CCB [LUB$A_BUF_END] = .CCB [LUB$A_BUF_PTR];
	END;

    RETURN;
    END;					! End of BAS$$REC_RSL0


GLOBAL ROUTINE BAS$$REC_MIN0 			! MAT Input initialization
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_RSF0 (and BAS$$REC_RSF1) reads one record if this is not a terminal.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!	LUB$V_TERM_DEV		flag in LUB which indicates a terminal device.
!	RAB$W_RSZ		word in the RAB which contains the buffer size.
!	RAB$L_RBF		longword in RAB which points to the buffer.
!	LUB$L_WAIT_TIME		Max time to wait for input, in seconds.
!	WAIT			Module level OWN WAIT
!
! IMPLICIT OUTPUTS:
!
!	RECOUNT			Global storage to hold number of bytes read from
!				last Input.
!	LUB$L_LOG_RECNO		Increment logical record number
!				of next record to be read.
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	Throws away things that are pending in the Print buffer for non-terminal
!	devices.
!	SIGNALs BAS$K_FATSYSIO (12='FATAL SYSTEM I/O FAILURE')
!	SIGNALs BAS$K_ENDFILDEV (11='END-OF-FILE ON DEVICE')
!	SIGNALs BAS$K_RECFILTOO if record too big
!	SIGNALs BAS$K_TIMLIMEXC if a wait time was specified and we
!				exceed it.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LITERAL
	K_ESCAPE = %X'1B',
	K_CR = %X'0D';

    LOCAL
	WAIT_TIME;			!Current wait time
!+
! If a timeout has been specified, store information in the RAB to tell
! RMS about it.  If no timeout has been specified, clear the TMO bit
! in case there was an earlier timeout specified.
!-


!+
! If WAIT is zero then use the LUB's wait. This is to provide upward compatibility
! , i.e. existing EXE's can run with the LUB wait value in V2.2.
!-
    WAIT_TIME = ( IF ( .WAIT EQL 0 ) THEN .CCB [ LUB$L_WAIT_TIME ] ELSE .WAIT );

    IF (.WAIT_TIME EQL 0)
    THEN
	CCB [RAB$V_TMO] = 0
    ELSE
	BEGIN
	CCB [RAB$B_TMO] = .WAIT_TIME;
	CCB [RAB$V_TMO] = 1;
	END;


!+
! Set the Read-no-echo RMS bit based on the user's last call to
! ECHO or NOECHO.
!-
    CCB [RAB$V_RNE] = .CCB [LUB$V_NOECHO];

    !+
    ! Check to see if this is a terminal device.  If this is NOT
    ! a terminal then do a GET.  GETs for terminals are done each time more
    ! data are needed.
    ! Read record into buffer using RMS and check for errors
    ! If end-of-file, SIGNAL BAS$K_ENDFILDEV (11='END-OF-FILE ON DEVICE')
    ! If record too big for record buffer, SIGNAL BAS$K_RECFILTOO.
    ! If errors, SIGNAL BAS$K_FATSYSIO (12='FATAL SYSTEM I/O ERROR')
    !-

    IF ( NOT .CCB [LUB$V_TERM_DEV])
    THEN
	BEGIN

	!+
	! If there is something pending in the Print buffer then throw it
	! away.  The pending Print data does not need to become a prompt
	! because prompts to disk files are thrown away by RMS.  Also, the
	! Print data can't just be ignored because eventually it may overflow
	! the Print buffer forcing a PUT which will result in an error.
	!-

	LOCAL
	    TEMP_CCB : REF BLOCK [, BYTE];	! Temporary CCB

	TEMP_CCB = .CCB [LUB$A_BUDDY_PTR];
	TEMP_CCB [LUB$A_BUF_PTR] = .TEMP_CCB [LUB$A_BUF_BEG];

	IF NOT $GET (RAB = .CCB) THEN GET_ERROR (K_STOP);

	!+
	! Set RECOUNT to the number of bytes read
	! If the file is a terminal format file, then RECOUNT has to be
	! adjusted for the carriage control terminator.
	!-

	RECOUNT = .CCB [RAB$W_RSZ] + (IF .CCB [LUB$V_TERM_FOR] THEN SELECTONEU .CCB [RAB$W_STV0] OF
		SET
		[K_ESCAPE] : .CCB [RAB$W_STV2];
		[K_CR] : 2;
		[OTHERWISE] : 0;
		TES ELSE 0);

	!+
	! Return start-1 and end+1 address of record just read
	!-

	CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF] - 1;
	CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];

	!+
	! Check for an '&' as the last character of the record.  If it is there,
	! it is a continuation character and signifies that there is more data to
	! come in the next record.
	!-

	IF .(.CCB [LUB$A_BUF_END] - 1)<0, 8> EQLU K_MAT_CONT_CHAR
	THEN
	    BEGIN
	    CCB [LUB$A_BUF_END] = .CCB [LUB$A_BUF_END] - 1;
	    CCB [ISB$V_MAT_CONT] = 1;
	    END
	ELSE
	    CCB [ISB$V_MAT_CONT] = 0;

	END
    ELSE

    !+
    ! This is a terminal.  Force a no data in the buffer condition
    ! so the first GET is done on the element transmitter after the
    ! Prompt (if any) is known.  Set the MAT Input continuation flag so that the element
    ! transmitter (REC1) can read the first record.
    !-

	BEGIN
	CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF];
	CCB [LUB$A_BUF_END] = .CCB [LUB$A_BUF_PTR];
	CCB [ISB$V_MAT_CONT] = 1;
	END;

    RETURN;
    END;					! End of BAS$$REC_MIN0


GLOBAL ROUTINE BAS$$REC_RSL1 			! Read element transmitter
    : JSB_REC1 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_RSL1 reads one record if this is a terminal device.
!	Otherwise an error is signalled.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!	LUB$V_TERM_DEV		flag indicating a terminal device.
!	RAB$L_RBF		Pointer to buffer
!	RAB$W_RSZ		buffer size
!
! IMPLICIT OUTPUTS:
!
!	RECOUNT			Own storage for RECOUNT function.
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNALs Insufficient data or any resultant RMS errors.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	T_CCB : REF BLOCK [, BYTE];

    LITERAL
	K_ESCAPE = %X'1B',
	K_CR = %X'0D';

    !+
    ! Check to see if this is a terminal device.  If this is
    ! a terminal then do a GET.  GETs for terminals are done each time more
    ! data are needed.  If this is not a terminal device then error.
    ! Read record into buffer using RMS and check for errors
    !-

    IF .CCB [LUB$V_TERM_DEV]
    THEN
	BEGIN

	IF NOT $GET (RAB = .CCB) THEN GET_ERROR (K_STOP);

	!+
	! Return start-1 and end+1 address of record just read
	! LUB$A_BUF_PTR is set to the beginning-1 of the buffer only for BASIC
	! Input.  This is seen as a solution to the problem of the user entering
	! <return> as the response to a prompt (null input record) and an empty
	! or depleted buffer which requires another Get.
	! The algorithm:
	! 1)	Does LUB$A_BUF_PTR = LUB$A_BUF_END?
	!	T: The buffer is depleted - another Get is required.
	! 2)	Add one to LUB$A_BUF_PTR
	! 3)	Does LUB$A_BUF_PTR = LUB$A_BUF_END?
	!	T: Return the default value.
	! 4)	Scan for the next field.
	!
	!-

	CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF] - 1;
	CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];
	END
    ELSE

    !+
    ! This is not a terminal device
    ! Signal insufficient data
    !-

	BAS$$SIGNAL (BAS$K_NOTENODAT);

!+
! Update the cursor position if this input was terminated by an escape.
! Save cursor position if last PRINT terminator was a semi or comma.
! Use BUDDY_PTR 'cuz we want to use the PRINT data base for channel 0
!-
    T_CCB = .CCB [LUB$A_BUDDY_PTR];
   T_CCB [LUB$L_PRINT_POS] = (IF .CCB [RAB$W_STV0] EQL K_ESCAPE AND .T_CCB [LUB$V_FORM_CHAR] EQLU 1
				THEN .CCB [RAB$W_RSZ] + .T_CCB [LUB$L_PRINT_POS] + 1
				ELSE 0);

    !+
    ! Set RECOUNT to the number of bytes read
    ! If the file is a terminal format file, then RECOUNT has to be
    ! adjusted for the carriage control terminator.
    !-

    RECOUNT = .CCB [RAB$W_RSZ] + (IF .CCB [LUB$V_TERM_FOR] THEN SELECTONEU .CCB [RAB$W_STV0] OF
	    SET
	    [K_ESCAPE] : .CCB [RAB$W_STV2];
	    [K_CR] : 2;
	    [OTHERWISE] : 0;
	    TES ELSE 0);
    RETURN 1;
    END;					! End of BAS$$REC_RSL1


GLOBAL ROUTINE BAS$$REC_MIN1 			!  MAT Input element transmitter
    : JSB_REC1 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_MIN1 reads one record and checks for a continuation character.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!	LUB$V_TERM_DEV		flag indicating a terminal device.
!	RAB$L_RBF		Pointer to buffer
!	RAB$W_RSZ		buffer size
!
! IMPLICIT OUTPUTS:
!
!	RECOUNT			Own storage for RECOUNT function.
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNALs any resultant RMS errors.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LITERAL
	K_ESCAPE = %X'1B',
	K_CR = %X'0D';

    LOCAL
	T_CCB : REF BLOCK [, BYTE],
	STATUS;					! Return status to UDF of whether

    						! to keep reading

    !+
    ! Read record into buffer using RMS and check for errors and a continuation character
    ! Signal any RMS errors directly.
    !-

    IF .CCB [ISB$V_MAT_CONT]
    THEN
	BEGIN

	IF NOT $GET (RAB = .CCB) THEN GET_ERROR (K_STOP);

	!+
	! Return start-1 and end+1 address of record just read
	! LUB$A_BUF_PTR is set to the beginning-1 of the buffer only for BASIC
	! Input.  This is seen as a solution to the problem of the user entering
	! <return> as the response to a prompt (null input record) and an empty
	! or depleted buffer which requires another Get.
	! The algorithm:
	! 1)	Does LUB$A_BUF_PTR = LUB$A_BUF_END?
	!	T: The buffer is depleted - another Get is required.
	! 2)	Add one to LUB$A_BUF_PTR
	! 3)	Does LUB$A_BUF_PTR = LUB$A_BUF_END?
	!	T: Return the default value.
	! 4)	Scan for the next field.
	!
	!-

	CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF] - 1;
	CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];

	!+
	! Check for an '&' as the last character of the record.  If it is there,
	! it is a continuation character and signifies that there is more data to
	! come in the next record.
	!-

	IF .(.CCB [LUB$A_BUF_END] - 1)<0, 8> EQLU K_MAT_CONT_CHAR
	THEN
	    BEGIN
	    CCB [LUB$A_BUF_END] = .CCB [LUB$A_BUF_END] - 1;
	    CCB [ISB$V_MAT_CONT] = 1;
	    END
	ELSE
	    CCB [ISB$V_MAT_CONT] = 0;

!+
! Update the cursor position if this input was terminated by an escape.
! Save the cursor position if last PRINT terminator was a semi or comma.
! Use BUDDY_PTR 'cuz we want to use the PRINT data base for channel 0
!-
	T_CCB = .CCB [LUB$A_BUDDY_PTR];
        T_CCB [LUB$L_PRINT_POS] = (IF .CCB [RAB$W_STV0] EQL K_ESCAPE AND .T_CCB [LUB$V_FORM_CHAR] EQLU 1
					THEN .CCB [RAB$W_RSZ] + .T_CCB [LUB$L_PRINT_POS] + 1
					ELSE 0);

	!+
	! Set RECOUNT to the number of bytes read
	! If the file is a terminal format file, then RECOUNT has to be
	! adjusted for the carriage control terminator.
	!-

	RECOUNT = .CCB [RAB$W_RSZ] + (IF .CCB [LUB$V_TERM_FOR] THEN SELECTONEU .CCB [RAB$W_STV0] OF
		SET
		[K_ESCAPE] : .CCB [RAB$W_STV2];
		[K_CR] : 2;
		[OTHERWISE] : 0;
		TES ELSE 0);
	STATUS = 1;
	END
    ELSE
	STATUS = 0;

    RETURN .STATUS;
    END;					! End of BAS$$REC_MIN1


GLOBAL ROUTINE BAS$$REC_RSL9 			! Read IO_END
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_RSL9 is a no-op!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN
    RETURN;
    END;					! End of BAS$$_REC_RSL9


GLOBAL ROUTINE BAS$$REC_MIN9 			! MAT Input IO_END
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_RSL9 is a no-op!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN
    RETURN;
    END;					! End of BAS$$REC_MIN9


GLOBAL ROUTINE BAS$$REC_MLI1 			!  MAT Linput element transmitter
    : JSB_REC1 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_MLI1 unconditionally reads one record.  There is no
!	continuation character for MAT LINPUT.
!	Otherwise an error is signalled.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!	RAB$L_RBF		Pointer to buffer
!	RAB$W_RSZ		buffer size
!
! IMPLICIT OUTPUTS:
!
!	RECOUNT			Own storage for RECOUNT function.
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNALs any resultant RMS errors.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	T_CCB : REF BLOCK [, BYTE];

    LITERAL
	K_ESCAPE = %X'1B',
	K_CR = %X'0D';

    !+
    ! Read record into buffer using RMS and check for errors
    ! Signal any RMS errors directly.
    !-

    IF NOT $GET (RAB = .CCB) THEN GET_ERROR (K_STOP);

!+
! Return start-1 and end+1 address of record just read
! LUB$A_BUF_PTR is set to the beginning-1 of the buffer only for BASIC
! Input.  This is seen as a solution to the problem of the user entering
! <return> as the response to a prompt (null input record) and an empty
! or depleted buffer which requires another Get.
! The algorithm:
! 1)	Does LUB$A_BUF_PTR = LUB$A_BUF_END?
!	T: The buffer is depleted - another Get is required.
! 2)	Add one to LUB$A_BUF_PTR
! 3)	Does LUB$A_BUF_PTR = LUB$A_BUF_END?
!	T: Return the default value.
! 4)	Scan for the next field.
!
!-
    CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF] - 1;
    CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];
!+
! Update the cursor position if this input was terminated by an escape.
! Save the cursor position if last PRINT terminator was a semi or comma.
! Use BUDDY_PTR 'cuz we want to use the PRINT data base for channel 0
!-
    T_CCB = .CCB [LUB$A_BUDDY_PTR];
    T_CCB [LUB$L_PRINT_POS] = (IF .CCB [RAB$W_STV0] EQL K_ESCAPE AND .T_CCB [LUB$V_FORM_CHAR] EQLU 1
				THEN .CCB [RAB$W_RSZ] + .T_CCB [LUB$L_PRINT_POS] + 1
				ELSE 0);
!+
! Set RECOUNT to the number of bytes read
! If the file is a terminal format file, then RECOUNT has to be
! adjusted for the carriage control terminator.
!-
    RECOUNT = .CCB [RAB$W_RSZ] + (IF .CCB [LUB$V_TERM_FOR] THEN SELECTONEU .CCB [RAB$W_STV0] OF
	    SET
	    [K_ESCAPE] : .CCB [RAB$W_STV2];
	    [K_CR] : 2;
	    [OTHERWISE] : 0;
	    TES ELSE 0);
    RETURN 1
    END;					! End of BAS$$REC_MLI1


GLOBAL ROUTINE BAS$$REC_WSL0 			! Write list-directed
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_WSL0 prepares a record for list-directed output.
!	Then return start and end+1 of user
!	part of record to be processed.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$V_FIXED		 1 if fixed-length records
!	LUB$V_FORM_CHAR		Indicates that the last element transmitter ended
!				in a comma or semicolon format char.
!	LUB$V_FORCIBLE		Indicates a forcible device
!	LUB$V_CCO		Cancel control O
!
! IMPLICIT OUTPUTS:
!
!	LUB$B_BAS_VFC1		'Pre' carriage control
!	LUB$B_BAS_VFC2		'Post' carriage control
!	LUB$A_BUF_PTR		pointer to next byte of buffer
!	LUB$A_BUF_END		pointer to byte following the buffer
!	RAB$V_CCO		Cancel control O
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

!+
! If the user has called RCTRLO (and not called CTRLO since)
! then tell RMS to cancel control O.
!-

    IF (.CCB [LUB$V_CCO])
    THEN
	BEGIN
	CCB [LUB$V_CCO] = 0;
	CCB [RAB$V_CCO] = 1;
	END;

    !+
    ! If there is a format character pending and this is not a forcible
    ! device, then don't change the buffer pointers.  The PUT will be done when
    ! there is no format character pending.
    !-

    IF .CCB [LUB$V_FORM_CHAR] AND NOT .CCB [LUB$V_FORCIBLE] THEN RETURN;

    !+
    ! If the last statement did not end with a format character,
    ! then put a line feed into the 'pre' carriage control
    ! Unconditionally set the 'post' carriage control to null
    !-

    CCB [LUB$B_BAS_VFC1] = (IF .CCB [LUB$V_FORM_CHAR] THEN BAS$K_NULL ELSE BAS$K_LF);
    CCB [LUB$B_BAS_VFC2] = BAS$K_NULL;

    !+
    ! If the buffer is dirty, then this is recursive I/O and we want to
    ! concatenate this record.  So leave the buffer pointers alone. Otherwise
    ! return the buffer pointers initialized for another statement
    !-

    IF NOT .CCB [LUB$V_OUTBUF_DR]
    THEN
	BEGIN
	CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
	CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
	END;

    RETURN;
    END;					! END OF BAS$$REC_WSL0


GLOBAL ROUTINE BAS$$REC_WSL1 (			! Write list-directed
	CARRIAGE_CTRL) : JSB_REC_WSL1 NOVALUE = 	! Called from BAS$$DO_WRITE

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one list-directed record and initialize for the next
!	BAS$$REC_WSL1 writes one output buffer and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!	If this routine is called because the buffer overflowed then the 'post'
!	carriage control should be null.  If this routine is called because the
!	margin overflowed, then the 'post' carriage control should be 'CR'.
!
! FORMAL PARAMETERS:
!
!	CARRIAGE_CTRL.rlu.v	carriage control for the record
!
! IMPLICIT INPUTS:
!
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$A_BUF_PTR		Pointer to next byte in user buffer.
!	RAB$L_RBF		Pointer to user buffer
!
! IMPLICIT OUTPUTS:
!
!	LUB$B_BAS_VFC1		'Pre' carriage control
!	LUB$B_BAS_VFC2		'Post' carriage control
!	LUB$A_BUF_PTR		Pointer to start of user part of record buffer
!	LUB$A_BUF_END		Pointer to end+1 of user part of record buffer
!	LUB$V_OUTBUF_DR		Indicates valid data in the output buffer
!	RAB$W_RSZ		Size of user buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Writes one RMS sequential record.
!	SIGNALs BAS$K_FATSYSIO on PUT error.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB = 11 : REF BLOCK [, BYTE];

    LITERAL
	K_NO_CR = 2;

!+
! Set 'post' carriage control to CR or NULL depending on whether the margin
! overflowed or the buffer overflowed.
! If this is a file, the carriage control is ignored and a record is PUT.
!-
    CCB [LUB$B_BAS_VFC2] = (IF .CARRIAGE_CTRL EQL BAS$K_BUF_EXC THEN BAS$K_NULL ELSE BAS$K_CR);

    !+
    ! perform the record write.
    ! Set recordsize to actual length of record
    !-

    CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_RBUF_ADR];

    !+
    ! Output buffer to RMS and check for errors
    ! If errors, SIGNAL_STO
    !-

    CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$V_OUTBUF_DR] = 0;

    IF NOT $PUT (RAB = .CCB) THEN PUT_ERROR (K_STOP);

    !+
    ! Set the 'pre' carriage control to LF if CARRIAGE_CTRL warrants it.
    ! Set the 'post' carriage control to null.
    !-

    CCB [LUB$B_BAS_VFC1] = (IF .CARRIAGE_CTRL EQL BAS$K_BUF_EXC THEN BAS$K_NULL ELSE BAS$K_LF);
    CCB [LUB$B_BAS_VFC2] = BAS$K_NULL;

    !+
    ! Initialize record buffer for another list-directed write
    ! return record buffer pointers to caller
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! End of routine - BAS$$UDF_WSL1


GLOBAL ROUTINE BAS$$REC_RMF0 			! Initialize read memory formatted
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Pick up pointer to last major frame from ISB and initialize BUF_BEG,
!	BUF_PTR, and BUF_END to the values for the data area found in the
!	frame.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ISB$A_MAJ_F_PTR			pointer to last Basic major frame
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB = K_CCB_REG : REF BLOCK [, BYTE];

    LOCAL
	BMF : REF BLOCK [0, BYTE] FIELD (BSF$MAJOR_FRAME);

    !+
    ! Reach back into the last major frame by picking up the value of R11 stored
    ! in the ISB.  Initialize BUF_PTR, BUF_END, BUF_BEG so that this will look
    ! like a vanilla INPUT.
    !-

    BMF = .CCB [ISB$A_MAJ_F_PTR];
!+
! If this cell is zero, then there was no DATA statement and an error should be
! signalled.
!-

    IF .BMF [BSF$A_CUR_DTA] EQLA 0 THEN BAS$$STOP_IO (BAS$K_OUTOF_DAT);

    CCB [LUB$A_BUF_BEG] = .BMF [BSF$A_CUR_DTA];
    CCB [LUB$A_BUF_END] = .BMF [BSF$A_END_DTA];

    !+
    ! Subtract one from CUR_DATA for INPUT element transmitter compatibility.
    !-

    CCB [LUB$A_BUF_PTR] = .BMF [BSF$A_CUR_DTA] - 1;
    RETURN;
    END;


GLOBAL ROUTINE BAS$$REC_MRE1 			! Mat Read element transmitter
    : JSB_REC1 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Since MAT READ just takes as much input data as it can get, it will just
!	return a failure here because there is no more data.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Returns failure - out of data.
!
! SIDE EFFECTS:
!
!	As a result of the failure being returned, the MAT READ will stop
!	filling the matrix.
!
!--

    BEGIN
    RETURN 0
    END;					! end of BAS$$REC_MRE1


GLOBAL ROUTINE BAS$$REC_RMF1 			! Read element transmitter
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	BAS$$REC_RMF1 should not be called in normal processing and will signal
!	an error (BAS$K_OUTOF_DAT) if it is called.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signal - BAS$K_OUTOF_DAT - Out of Data
!
!--

    BEGIN
    BAS$$SIGNAL (BAS$K_OUTOF_DAT);
    RETURN;
    END;					! end of BAS$$REC_RMF1


GLOBAL ROUTINE BAS$$REC_RMF9 			! Read IO_END
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Update the current data pointer in the last Basic major frame
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB = K_CCB_REG : REF BLOCK [0, BYTE];

    LOCAL
	BMF : REF BLOCK [0, BYTE] FIELD (BSF$MAJOR_FRAME);

    !+
    ! Set the current data pointer in the frame to BUF_PTR + 1.
    ! The one is added because Input initialize will subtract one from BUF_PTR.
    ! This whole matter is explained in IO_BEG.
    !-

    BMF = .CCB [ISB$A_MAJ_F_PTR];
    BMF [BSF$A_CUR_DTA] = .CCB [LUB$A_BUF_PTR] + 1;
    RETURN;
    END;					! End of routine BAS$$REC_RMF9


GLOBAL ROUTINE BAS$$REC_GSE (			! GET (sequential) a record
	FOREIGN_BUFFER				!
    ) : JSB_DO_READ NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read one record.  Update RECOUNT if successful.
!	If a foreign buffer is specified, then change RAB$L_RBF to point to the
!	"foreign buffer".  Otherwise, signal a fatal error.
!
! FORMAL PARAMETERS:
!
!	FOREIGN_BUFFER.rl.v		points to CB of foreign buffer or 0
!
! IMPLICIT INPUTS:
!
!	RAB$W_USZ		User buffer size of foreign buffer
!	RAB$L_UBF		Pointer to user buffer for foreign buffer
!	LUB$L_WAIT_TIME		Wait time for next input
!	WAIT			The module level OWN WAIT
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		Record access field
!	RECOUNT			Own storage for RECOUNT function.
!	RAB$L_RBF		Record pointer in RAB.
!	RAB$W_RSZ		Number of bytes read (stored in RECOUNT)
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	RAB$W_USZ and RAB$W_UBF are altered while this routine is running,
!	but are restored before exit.
!	Reads next record from file on this logical unit.
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	FOREIGN_BUFFER : REF BLOCK [, BYTE];

    LOCAL
	SAVE_USZ,				! Save the USZ
	ACTUAL_RSZ,				! Actual record size
	WAIT_TIME;				! Current wait time
!+
! Save USZ in case it is modified.  It is faster to always
! save and restore it, since that eliminates the test for foreign
! buffers and single-character mode at the end of this routine.
!-
    SAVE_USZ = .CCB [RAB$W_USZ];
!+
! If a timeout has been specified, store information in the RAB to tell
! RMS about it.  If no timeout has been specified, clear the TMO bit
! in case there was an earlier timeout specified.
!-

!+
! If WAIT is zero then use the LUB's wait. This is to provide upward compatibility
! , i.e. existing EXE's can run with the LUB wait value in V2.2.
!-
    WAIT_TIME = ( IF ( .WAIT EQL 0 ) THEN .CCB [ LUB$L_WAIT_TIME ] ELSE .WAIT );

    IF (.WAIT_TIME EQL 0)
    THEN
	CCB [RAB$V_TMO] = 0
    ELSE
	BEGIN
	CCB [RAB$B_TMO] = .WAIT_TIME;
	CCB [RAB$V_TMO] = 1;
	END;


!+
! Set the Read-no-echo RMS bit based on the user's last call to
! ECHO or NOECHO.
!-
    CCB [RAB$V_RNE] = .CCB [LUB$V_NOECHO];
!+
! Set the record pointer field in the RAB to the user buffer.  This is
! done on each element transmission and not just at OPEN because of RMS
! Locate mode.
! Fill the input buffer with Nulls.  Basic semantics require null fill if
! the record read is shorter than the buffer.
! Set the record access field in the RAB to sequential.  Perform the GET.
! If RMS returns a failure status, signal the error.  If the GET is
! successful, then update recount.
!-

    IF (.FOREIGN_BUFFER NEQA 0)
    THEN
	BEGIN
!+
! A foreign buffer was specified.  Save off RAB$L_usz of the "file" channel
! and then substitute the appropriate values from the foreign channel into
! the file channel to make the record go directly into the foreign buffer.
!-
	CCB [RAB$W_USZ] = .FOREIGN_BUFFER [RAB$W_USZ];
	END;

!+
! If the user has called ONECHR, shrink the effective size of the
! buffer to one character, so he will get characters one at a time.
! The user must call ONECHR before each GET, so we clear the ONECHR
! flag here.
!-

    IF (.CCB [LUB$V_ONECHR])
    THEN
	BEGIN
	CCB [LUB$V_ONECHR] = 0;
	CCB [RAB$W_USZ] = 1;
	END;

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $GET (RAB = .CCB)
    THEN
	BEGIN
!+
! We cannot call GET_ERROR because we must restore UBF and USZ.
!-

	WHILE (.CCB [RAB$L_STS] EQL RMS$_RSA) DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $GET (RAB = .CCB);
	    END;

	END;

!+
! This actual record size may or may not change below.  If the file is a
! terminal device then it will get terminators tacked on to the record read.
!-
    ACTUAL_RSZ = .CCB [RAB$W_RSZ];


!+
! Tack on the terminators when a terminal device file, just like INPUT LINE 
!-
    IF .CCB[LUB$V_TERM_DEV]
    THEN
	BEGIN
	LITERAL K_ESCAPE = %X'1B',
		K_CR     = %X'0D',
		K_CRLF   = %X'0A0D';

!+
! STV0 is the escape character, STV2 is the number of terminating characters.
!-
	SELECTONEU .CCB [RAB$W_STV0] OF
	 SET
	 [K_ESCAPE] :
		BEGIN
!+
! If the length is one then escape is not at the end of the buffer and it
! must be moved there, otherwise the escape sequence is at the end of the 
! buffer following the data.

		IF .CCB [RAB$W_STV2] EQLU 1
		THEN
		   BEGIN
		   IF .CCB [RAB$W_RSZ] GEQU .CCB [RAB$W_USZ]
		   THEN BAS$$STOP_IO (BAS$K_RECFILTOO);
		   CH$MOVE (1,UPLIT(K_ESCAPE),.CCB [RAB$L_UBF] + .CCB [RAB$W_RSZ]);
		   ACTUAL_RSZ = .ACTUAL_RSZ + 1;
		   END
		ELSE
		   ACTUAL_RSZ = .ACTUAL_RSZ + .CCB [RAB$W_STV2];
		END;
	 [K_CR] :
		BEGIN
		IF .CCB [RAB$W_RSZ] + 2 GTRU .CCB [RAB$W_USZ]
		THEN BAS$$STOP_IO (BAS$K_RECFILTOO);
		CH$MOVE (2,UPLIT(K_CRLF),.CCB [RAB$L_UBF] + .CCB [RAB$W_RSZ]);
		ACTUAL_RSZ = .ACTUAL_RSZ + 2 ;
		END;
	 [OTHERWISE] :
		;
	 TES;
	END;

!+
! If there are no errors, null pad the buffer.
!-

    IF (.CCB [RAB$W_USZ] GTR .ACTUAL_RSZ)AND .CCB [RAB$L_STS]
    THEN
	CH$FILL (%X'00',
	    .CCB [RAB$W_USZ] - .ACTUAL_RSZ, .CCB [RAB$L_UBF] + .ACTUAL_RSZ);

!+
! Before checking for errors, restore UBF and USZ, and set RECOUNT.
!-
    CCB [RAB$L_UBF] = .CCB [LUB$A_UBF];
    CCB [RAB$W_USZ] = .SAVE_USZ;
    RECOUNT = .ACTUAL_RSZ;
!+
! Any error remaining (which will be an error other than Record Stream
! Active, RSA) is fatal.
!-

    IF ( NOT .CCB [RAB$L_STS]) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    CCB [LUB$A_RBUF_ADR] = .CCB [RAB$L_RBF];
    RETURN;
    END;					! End of BAS$$REC_GSE


GLOBAL ROUTINE BAS$$REC_GIN (			! GET (indexed) a record
	KEY_NO, REL_OP, KEY, FOREIGN_BUFFER) : JSB_REC_IND NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read one record.  Update RECOUNT if successful.
!	If a foreign buffer is specified, then change RAB$L_RBF to point to the
!	"foreign buffer".  Otherwise, signal a fatal error.
!
! FORMAL PARAMETERS:
!
!	KEY_NO.rl.v		key of reference number
!	REL_OP.rl.v		relative relationship of the key
!	KEY.rt.dx		key to search for
!	FOREIGN_BUFFER.rl.v		points to CB of foreign buffer or 0
!
! IMPLICIT INPUTS:
!
!	RAB$W_USZ		User buffer size of foreign buffer
!	RAB$L_UBF		Pointer to user buffer for foreign buffer
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		Record access field
!	RECOUNT			Own storage for RECOUNT function.
!	RAB$L_RBF		Record pointer in RAB.
!	RAB$W_USZ		User buffer size for "file" buffer
!	RAB$L_UBF		Pointer to user buffer for "file" buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	KEY : REF BLOCK [8, BYTE],		! descriptor of the key
	FOREIGN_BUFFER : REF BLOCK [, BYTE];

    LITERAL
	K_EQUAL = 0,				! keys should be equal
	K_GREATER_EQUAL = 1,			! key should be greater than or equal
	K_GREATER_THAN = 2;			! key should be greater than

    LOCAL
	SAVE_USZ;				! Save the USZ

!+
! Save USZ in case it is modified.  It is faster to always
! save and restore it, since that eliminates the test for foreign
! buffers and single-character mode at the end of this routine.
!-
    SAVE_USZ = .CCB [RAB$W_USZ];

    !+
    ! Set the record pointer field in the RAB to the user buffer.  This is
    ! done on each element transmission and not just at OPEN because of RMS
    ! Locate mode.
    ! Fill the input buffer with Nulls.  Basic semantics require null fill if
    ! the record read is shorter than the buffer.
    ! Set the record access field in the RAB to sequential.  Perform the GET.
    ! If RMS returns a failure status, signal the error.  If the GET is
    ! successful, then update recount.
    !-

    IF .FOREIGN_BUFFER NEQ 0
    THEN
	BEGIN
!+
! A foreign buffer was specified.  Substitute the appropriate values from the foreign channel into
! the file channel to make the record go directly into the foreign buffer.
!-
	CCB [RAB$L_UBF] = .FOREIGN_BUFFER [RAB$L_UBF];
	CCB [RAB$W_USZ] = .FOREIGN_BUFFER [RAB$W_USZ];
	END;

    !+
    ! Set the record access field to key.  Set KBF to the key.  Set KSZ to the
    ! the size of the key passed.  Set the key of reference to the desired key.
    ! Use a case statement to toggle KGT and KGE in the ROP.
    !-

    CCB [RAB$B_RAC] = RAB$C_KEY;
    CCB [RAB$L_KBF] = .KEY [DSC$A_POINTER];
    CCB [RAB$B_KRF] = .KEY_NO;
    CCB [RAB$B_KSZ] = .KEY [DSC$W_LENGTH];

    CASE .REL_OP FROM K_EQUAL TO K_GREATER_THAN OF
	SET

	[K_EQUAL] :
	    CCB [RAB$V_KGE] = CCB [RAB$V_KGT] = 0;

	[K_GREATER_EQUAL] :
	    BEGIN
	    CCB [RAB$V_KGE] = 1;
	    CCB [RAB$V_KGT] = 0;
	    END;

	[K_GREATER_THAN] :
	    BEGIN
	    CCB [RAB$V_KGT] = 1;
	    CCB [RAB$V_KGE] = 0;
	    END;
	TES;

    IF NOT $GET (RAB = .CCB)
    THEN
	BEGIN
!+
! We cannot call GET_ERROR because we must restore UBF and USZ.
!-

	WHILE (.CCB [RAB$L_STS] EQL RMS$_RSA) DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $GET (RAB = .CCB);
	    END;

	END;

!+
! If there are no errors, null pad the buffer.
!-

    IF (.CCB [RAB$W_USZ] GTR .CCB [RAB$W_RSZ]) AND .CCB [RAB$L_STS]
    THEN
	CH$FILL (%X'00',
	    .CCB [RAB$W_USZ] - .CCB [RAB$W_RSZ], .CCB [RAB$L_UBF] + .CCB [RAB$W_RSZ]);

!+
! Before checking for errors, restore UBF and USZ, and set RECOUNT.
!-
    CCB [RAB$L_UBF] = .CCB [LUB$A_UBF];
    CCB [RAB$W_USZ] = .SAVE_USZ;
    RECOUNT = .CCB [RAB$W_RSZ];
!+
! Any error remaining (which will be an error other than Record Stream
! Active, RSA) is fatal.
!-

    IF ( NOT .CCB [RAB$L_STS]) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

!+
! This is frosting on the cake.  LUB$A_RBUF_ADR points to the record buffer for
! MOVE.  The buffer may change due to RMS Locate Mode.  Currently, Locate Mode
! is not performed on files which UPDATE or PUT.  However, in anticipation that
! RMS may add such a capability, we point RBUF_ADR off to the buffer used by PUT.
!-
    CCB [LUB$A_RBUF_ADR] = .CCB [RAB$L_RBF];
    RETURN;
    END;					! End of BAS$$REC_GIN


GLOBAL ROUTINE BAS$$REC_GRE (			! GET (relative) a record
	FOREIGN_BUFFER) : JSB_DO_READ NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Read one record from a relative file.  Modify the RAB if necessary for
!	foreign buffers.  Update RECOUNT if successful.  Otherwise, signal a fatal error.
!
! FORMAL PARAMETERS:
!
!	FOREIGN_BUFFER.rl.v		The address of the CB of a foreign
!					buffer or 0
!
! IMPLICIT INPUTS:
!
!	RAB$W_RSZ			record size for foreign buffer
!	RAB$L_UBF			buffer address for foreign buffer
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		Record access field
!	RECOUNT			Own storage for RECOUNT function.
!	RAB$L_RBF		Record pointer in RAB.
!	RAB$W_USZ		record size of file buffer
!	RAB$L_UBF		address of buffer for file buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	FOREIGN_BUFFER : REF BLOCK [, BYTE];

    LOCAL
	SAVE_USZ;				! Save the USZ

!+
! Save USZ in case it is modified.  It is faster to always
! save and restore it, since that eliminates the test for foreign
! buffers and single-character mode at the end of this routine.
!-
    SAVE_USZ = .CCB [RAB$W_USZ];

    !+
    ! Set the record pointer field in the RAB to the user buffer.  This is
    ! done on each element transmission and not just at OPEN because of RMS
    ! Locate mode.
    ! Fill the input buffer with Nulls.  Basic semantics require null fill if
    ! the record read is shorter than the buffer.
    ! Set the record access field in the RAB to sequential.  Perform the GET.
    ! If RMS returns a failure status, signal the error.  If the GET is
    ! successful, then update recount.
    !-

    IF .FOREIGN_BUFFER NEQ 0
    THEN
	BEGIN
!+
! There is a foreign buffer.  Modify the file buffer to point to the
! buffer associated with the foreign buffer's channel.
!-
	CCB [RAB$L_RBF] = CCB [RAB$L_UBF] = .FOREIGN_BUFFER [RAB$L_UBF];
	CCB [RAB$W_RSZ] = CCB [RAB$W_USZ] = .FOREIGN_BUFFER [RAB$W_USZ];
	END
    ELSE
	CCB [RAB$L_RBF] = .CCB [RAB$L_UBF];

    CCB [RAB$B_RAC] = RAB$C_KEY;

    IF NOT $GET (RAB = .CCB)
    THEN
	BEGIN
!+
! We cannot call GET_ERROR because we must restore UBF and USZ.
!-

	WHILE (.CCB [RAB$L_STS] EQL RMS$_RSA) DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $GET (RAB = .CCB);
	    END;

	END;

!+
! If there are no errors, null pad the buffer.
!-

    IF (.CCB [RAB$W_USZ] GTR .CCB [RAB$W_RSZ]) AND .CCB [RAB$L_STS]
    THEN
	CH$FILL (%X'00',
	    .CCB [RAB$W_USZ] - .CCB [RAB$W_RSZ], .CCB [RAB$L_UBF] + .CCB [RAB$W_RSZ]);

!+
! Before checking for errors, restore UBF and USZ, and set RECOUNT.
!-
    CCB [RAB$L_UBF] = .CCB [LUB$A_UBF];
    CCB [RAB$W_USZ] = .SAVE_USZ;
    RECOUNT = .CCB [RAB$W_RSZ];
!+
! Any error remaining (which will be an error other than Record Stream
! Active, RSA) is fatal.
!-

    IF ( NOT .CCB [RAB$L_STS]) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

!+
! Set LUB$A_RBUF_ADR to point to the buffer used by RMS.  It may move around
! due to Locate Mode.
!-
    CCB [LUB$A_RBUF_ADR] = .CCB [RAB$L_RBF];
    RETURN;
    END;					! End of BAS$$REC_GRE


GLOBAL ROUTINE BAS$$REC_PSE (			! PUT (sequential) a record
	COUNT, 					! No. of bytes to write
	FOREIGN_BUFFER				! pointer to foreign buffer CB or 0
    ) : JSB_PUT NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Check for "foreign buffers" and point RAB$L_RSZ to foreign USZ if there.
!	Write one record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	COUNT.rl.v		No. of bytes to write
!	FOREIGN_BUFFER.rl.v	pointer to foreign buffer CB or 0
!
! IMPLICIT INPUTS:
!
!	RAB$W_RSZ		of foreign buffer
!	RAB$L_RBF		of foreign buffer
!	LUB$V_CCO		Cancel control O
!
! IMPLICIT OUTPUTS:
!
!	RAB$L_RBF		for "file" buffer
!	RAB$W_RSZ		length of record to write
!	LUB$L_LOG_RECNO		logical record number
!	RAB$B_RAC		record access field
!	RAB$V_CCO		Cancel control O
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	FOREIGN_BUFFER : REF BLOCK [, BYTE];

!+
! If the user has called RCTRLO (and not called CTRLO since),
! tell RMS to cancel control O.
!-

    IF (.CCB [LUB$V_CCO])
    THEN
	BEGIN
	CCB [LUB$V_CCO] = 0;
	CCB [RAB$V_CCO] = 1;
	END;

    !+
    ! Set the recordsize field in the RAB based on COUNT.
    ! Set the record address field in the RAB to the user buffer.
    ! Perform the PUT.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$W_RSZ] = .COUNT;
    CCB [RAB$B_RAC] = (IF .CCB [LUB$B_ORGAN] EQL LUB$K_ORG_INDEX THEN RAB$C_KEY ELSE RAB$C_SEQ);

    IF .FOREIGN_BUFFER NEQA 0
    THEN
!+
! There is a foreign buffer.  Point RAB$L_UBF to it.
!-
	CCB [RAB$L_RBF] = CCB [RAB$L_UBF] = .FOREIGN_BUFFER [RAB$L_UBF]
    ELSE
	CCB [RAB$L_RBF] = .CCB [RAB$L_UBF];

    IF NOT $PUT (RAB = .CCB)
    THEN
	BEGIN
!+
! We cannot call PUT_ERROR because we must restore UBF and USZ.
!-

	WHILE (.CCB [RAB$L_STS] EQL RMS$_RSA) DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $PUT (RAB = .CCB);
	    END;

	END;

!+
! Restore RAB$L_UBF in case there was a foreign buffer.
!-
    CCB [RAB$L_UBF] = .CCB [LUB$A_UBF];
!+
! Point LUB$A_RBUF_PTR off to the buffer used by RMS.
!-
    CCB [LUB$A_RBUF_ADR] = .CCB [RAB$L_UBF];
!+
! Any error remaining (which will be an error other than Record Stream
! Active, RSA) is fatal.
!-

    IF ( NOT .CCB [RAB$L_STS]) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_PSE


GLOBAL ROUTINE BAS$$REC_PRE (			! PUT (relative) a record
	COUNT, 					! No. of bytes to write
	FOREIGN_BUFFER				! pointer to foreign CB or 0
    ) : JSB_PUT NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Check for a foreign buffer and point to it if necessary.
!	Write one record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	COUNT.rl.v		No. of bytes to write
!	FOREIGN_BUFFER.rl.v	pointer to foreign CB or 0
!
! IMPLICIT INPUTS:
!
!	RAB$L_UBF		for the foreign buffer (buffer pointer)
!	RAB$W_USZ		for the foreign buffer (buffer size)
!
! IMPLICIT OUTPUTS:
!
!	RAB$W_RSZ		length of record to write (file buffer)
!	RAB$L_RBF		pointer to file CB
!	LUB$L_LOG_RECNO		logical record number
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	FOREIGN_BUFFER : REF BLOCK [, BYTE];

    !+
    ! Set the recordsize field in the RAB based on COUNT.
    ! Set the record address field in the RAB to the user buffer.
    ! Set the record access field in the RAB to relative.  Perform the PUT.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$W_RSZ] = .COUNT;
    CCB [RAB$B_RAC] = RAB$C_KEY;

    IF .FOREIGN_BUFFER NEQA 0
    THEN
!+
! There is a foreign buffer.  Point off to the buffer but don't do the
! size.  A PUT with count would not work right, so the size is passed in.
!-
	CCB [RAB$L_UBF] = CCB [RAB$L_RBF] = .FOREIGN_BUFFER [RAB$L_UBF]
    ELSE
	CCB [RAB$L_RBF] = .CCB [RAB$L_UBF];

    IF NOT $PUT (RAB = .CCB)
    THEN
	BEGIN
!+
! We cannot call GET_ERROR because we must restore UBF and USZ.
!-

	WHILE (.CCB [RAB$L_STS] EQL RMS$_RSA) DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $PUT (RAB = .CCB);
	    END;

	END;

!+
! Restore RAB$L_UBF in case there was a foreign buffer.
!-
    CCB [RAB$L_UBF] = .CCB [LUB$A_UBF];
!+
! Point LUB$A_BUF_PTR off to the buffer used by RMS.
!-
    CCB [LUB$A_RBUF_ADR] = .CCB [RAB$L_UBF];
!+
! Any error remaining (which will be an error other than Record Stream
! Active, RSA) is fatal.
!-

    IF ( NOT .CCB [RAB$L_STS]) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_PRE


GLOBAL ROUTINE BAS$$REC_FSE 			! FIND (sequential) a record
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Find next record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Finds next record in file on this logical unit.
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the FIND.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $FIND (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_FSE


GLOBAL ROUTINE BAS$$REC_FRE 			! FIND (relative) a record
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Find next record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the FIND.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_KEY;

    IF NOT $FIND (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_FRE


GLOBAL ROUTINE BAS$$REC_FIN (			! FIND (indexed) a record
	KEY_NO, REL_OP, KEY) : JSB_REC_IND NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Find indicated record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	KEY_NO.rl.v			key of reference
!	REL_OP.rl.v			relational operator for key
!	KEY.rt.dx			key to search for
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$L_KBF		pointer to the desired key value
!	RAB$B_KSZ		size of desired key value
!	RAB$M_KGE		relational in RAB$L_ROP indicating greater than
!				or equal
!	RAB$M_KGT		relational in RAB$L_ROP indicating greater than
!	RAB$B_KRF		indicates key of reference
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	See RMS Reference manual for discussion on whether match will be exact,
!	generic, approximate, or generic-approximate.
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	KEY : REF BLOCK [8, BYTE];

    LITERAL
	K_EQUAL = 0,				! search for key equal
	K_GREATER_EQUAL = 1,			! search for key GEQ
	K_GREATER_THAN = 2;			! search for key GTR

    !+
    ! Set the key buffer field, the key size field, the key of reference,
    ! and the relational bits in the ROP.
    ! Set the record access field in the RAB to key.  Perform the FIND.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_KEY;
    CCB [RAB$L_KBF] = .KEY [DSC$A_POINTER];
    CCB [RAB$B_KRF] = .KEY_NO;
    CCB [RAB$B_KSZ] = .KEY [DSC$W_LENGTH];

    CASE .REL_OP FROM K_EQUAL TO K_GREATER_THAN OF
	SET

	[K_EQUAL] :
	    CCB [RAB$V_KGE] = CCB [RAB$V_KGT] = 0;

	[K_GREATER_EQUAL] :
	    BEGIN
	    CCB [RAB$V_KGE] = 1;
	    CCB [RAB$V_KGT] = 0;
	    END;

	[K_GREATER_THAN] :
	    BEGIN
	    CCB [RAB$V_KGT] = 1;
	    CCB [RAB$V_KGE] = 0;
	    END;
	TES;

    IF NOT $FIND (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_FIN


GLOBAL ROUTINE BAS$$REC_DSE 			! DELETE (sequential) a record
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Delete current record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the DELETE.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $DELETE (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_DSE


GLOBAL ROUTINE BAS$$REC_UNL 			! UNLOCK a record
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Unlock the current record.  If successful or no records locked,
!	then return; otherwise, signal a fatal error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the UNLOCK.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $RELEASE (RAB = .CCB)
    THEN

	IF .CCB [RAB$L_STS] NEQ RMS$_RNL
	THEN
!+
! An error was returned, check for 'record not locked'.
!-
	    BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_UNL


GLOBAL ROUTINE BAS$$REC_FEE 			! FREE all locked records
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Free all locked records.  If successful or no records locked,
!	then return; otherwise, signal a fatal error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the FREE.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $FREE (RAB = .CCB)
    THEN

	IF .CCB [RAB$L_STS] NEQ RMS$_RNL
	THEN
!+
! An error was returned, check for "record not locked".
!-
	    BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_FEE


GLOBAL ROUTINE BAS$$REC_UPD (			! UPDATE a record
	COUNT					! No. of bytes in the record
    ) : JSB_DO_WRITE NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Update current record.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	COUNT.rl.v		No. of bytes in record to update
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!	RAB$W_RSZ		record size
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Update current record in file on this logical unit.
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

!+
! Point RBF to the user buffer.
! Set the record access field in the RAB to sequential.  Perform the UPDATE.
! If RMS returns a failure status, signal the error.
!-
    CCB [RAB$L_RBF] = .CCB [RAB$L_UBF];
    CCB [RAB$W_RSZ] = .COUNT;
    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $UPDATE (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

!+
! Point LUB$A_RBUF_ADR to the buffer used by RMS for MOVE.
!-
    CCB [LUB$A_RBUF_ADR] = .CCB [RAB$L_UBF];
    RETURN;
    END;					! End of BAS$$REC_UPD


GLOBAL ROUTINE BAS$$REC_RSE 			! RESTORE (sequential) to beginning of file
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Rewind the file.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the REWIND.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $REWIND (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_RSE


GLOBAL ROUTINE BAS$$REC_RIN (			! RESTORE (indexed) to beginning of file
	KEY_NO) : JSB_REC_IND NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Rewind the file.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	KEY_NO.rl.v			key of reference
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_KRF		key of reference
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the key of reference .
    ! Set the record access field in the RAB to key.  Perform the REWIND.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_KRF] = .KEY_NO;
    CCB [RAB$B_RAC] = RAB$C_KEY;

    IF NOT $REWIND (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_RIN


GLOBAL ROUTINE BAS$$REC_SSE 			! SCRATCH (sequential) a record
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Truncate this file.  If successful then return; otherwise, signal a fatal
!	error.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RAB$B_RAC		record access field
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALs any RMS errors
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Set the record access field in the RAB to sequential.  Perform the TRUNCATE.
    ! If RMS returns a failure status, signal the error.
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $TRUNCATE (RAB = .CCB) THEN BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of BAS$$REC_SSE


ROUTINE PUT_ERROR (				! Here on error in $PUT
	SIGNAL_OR_STOP				! specifies whether to signal or stop
    ) : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Here on $PUT errors, check for Record stream active error (RMS$_RSA)
!	If this error, WAIT until not active and try $PUT again.
!	This recovers from AST I/O which can occur out of the middle
!	of synchronous I/O at non-AST level.
!
! CALLING SEQUENCE:
!
!	PUT_ERROR (signal_or_stop)
!
! FORMAL PARAMETERS:
!
!	SIGNAL_OR_STOP.rl.v		whether to signal or stop
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_OUTBUF_DR		Cleared to indicate clean buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	$WAITs and then tries $PUT again, until success or any error
!	except record streanm active.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    WHILE .CCB [RAB$L_STS] EQL RMS$_RSA DO
	BEGIN
	$WAIT (RAB = .CCB);
	$PUT (RAB = .CCB)
	END;

    IF NOT .CCB [RAB$L_STS]
    THEN
	BEGIN
!+
! Clear the buffer dirty bit so if there is anything there BAS$CLOSE won't
! get confused, and try to do another PUT.
!-
        CCB [LUB$V_OUTBUF_DR] = 0;

	IF .SIGNAL_OR_STOP EQL K_SIGNAL
	THEN
	    BAS$$SIGNAL_IO (BAS$K_IOERR_REC)
	ELSE
	    BAS$$STOP_IO (BAS$K_IOERR_REC);

	END;
    RETURN;
    END;					! End of PUT_ERROR

ROUTINE GET_ERROR (				! Here on error on $GET
	SIGNAL_OR_STOP				! parameter to signal(continue) or stop
    ) : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Here on $GET errors, check for Record stream active error (RMS$_RSA)
!	If this error, WAIT until not active and try $GET again.
!	This recovers from AST I/O which can occur out of the middle
!	of synchronous I/O at non-AST level.
!
! CALLING SEQUENCE:
!
!	JSB GET_ERROR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	If this is an INPUT LINE and a ^Z error, then just return and it will
!	be handled above.
!	$WAITs and then tries $GET again, until success or any error
!	except record streanm active.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

!+
! Set the prompt buffer length to zero so that error followed by RESUME will not
! keep concatenating the prompt buffer.
!-
    CCB [RAB$B_PSZ] = 0;
!+
! Is this INPUT LINE and only a ^Z in the record?
!-

    IF .CCB [ISB$B_STTM_TYPE] EQL ISB$K_ST_TY_INL AND .CCB [RAB$W_RSZ] EQLU 1 AND .(.CCB [RAB$L_RBF])<0, 8>
	EQLU BAS$K_CONTROL_Z
    THEN
	RETURN;

    WHILE .CCB [RAB$L_STS] EQL RMS$_RSA DO
	BEGIN
	$WAIT (RAB = .CCB);
	$GET (RAB = .CCB)
	END;

    IF NOT .CCB [RAB$L_STS]
    THEN

    !+
    ! Check the input parameter to see if we should signal or stop.
    !-

	IF .SIGNAL_OR_STOP EQL K_SIGNAL
	THEN
	    BAS$$SIGNAL_IO (BAS$K_IOERR_REC)
	ELSE
	    BAS$$STOP_IO (BAS$K_IOERR_REC);

    RETURN;
    END;					! End of GET_ERROR
END

ELUDOM
