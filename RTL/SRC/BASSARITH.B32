MODULE BAS$SARITH (				! BASIC String Arithmetic
		IDENT = '1-021'		! File: BASSARITH.B32 Edit: LEB1021
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  BASIC String Arithmetic
!
! ABSTRACT:
!
!	This module contains the BASIC string arithmetic functions.
!	They operate by calling the STR$ string arithmetic entry
!	points.  These routines are coded for reliability and
!	maintainability, not for speed.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: John Sauter, CREATION DATE: 02-MAR-1979
!
! MODIFIED BY:
!
! 1-001	- Original.  JBS 05-MAR-1979
! 1-002	- Don't produce a leading zero if the result is between 0
!	   and 1.  JBS 07-MAR-1979
! 1-003	- Ask STR$RECIP to work to enough accuracy to be sure that the
!	   result of the divide will be sufficiently accurate.
!	   JBS 07-MAR-1979
! 1-004	- Correct the space allocation in PARSE_OUT, so we have enough
!	   to hold the entire number.  JBS 22-MAR-1979
! 1-005	- Correct the sign of the result of COMP%.  JBS 22-MAR-1979
! 1-006	- Improve comments based on the code review.  JBS 26-MAR-1979
! 1-007	- Correct a typo introduced in edit 006.  JBS 28-MAR-1979
! 1-008	- If we get an error, free local strings.  JBS 07-MAY-1979
! 1-009	- Call the STR$ facility with input scalars by reference.
!	   JBS 15-MAY-1979
! 1-010	- Change OTS$S and LIB$S to STR$.  JBS 21-MAY-1979
! 1-011	- Change call to STR$COPY.  JBS 16-JUL-1979
! 1-012	- In BAS$QUO, search for an exact quotient.  JBS 23-JUL-1979
! 1-013	- When freeing local strings, watch out for descriptors
!	   which have not yet been initialized.  JBS 31-JUL-1979
! 1-014	- When scanning the input string, allocate at least 8 bytes of
!	   space.  QAR N11-02925.  JBS 17-OCT-1979
! 1-015 - Try to speed up BAS$QUO by shortening the quotient search.
!	   Leave in monitoring code under conditional compilation in case
!	   it is needed again.  JBS 22-MAY-1980
! 1-016 - 3.75/3 to one decimal place gives 1.2 instead of 1.3.  To fix this,
!	   round before hill climbing.  JBS 13-JUN-1980
! 1-017 - Added code to routines BAS$PLACE and BAS$PROD to take care of
!	  the incompatibilities between VAX and the PDP-11 in handling of
!	  certain ROUND/TRUNCATION parameters (specifically rounding values
!	  in the range of -1 to -4 and truncation values in the range of
!	  9996 to 9999).  LEB  24-AUG-81
! 1-018 - Changed routine BAS$QUO to now call routine STR$DIVIDE instead of
!	  the calls to STR$MUL, STR$RECIP, and STR$ROUND.  LEB  8-OCT-81
! 1-019 - Added code to BAS$QUO to handle compatibility problems with
!	  regard to getting rid of unnecessary leading or trailing
!	  zeroes.  LEB 23-DEC-81.
! 1-020 - Changed code in BAS$PLACE and BAS$PROD to handle the ROUND
!	  TRUNCATION parameters - they now correctly handle values
!	  in the range of -4999 to -1 and in the range of 5001 to 9999.
!	  LEB 4-FEB-82.
! 1-021 - Added line to BAS$QUO to store updated length field into the
!	  descriptor.  LEB 2-MAR-82.
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!
!	NONE
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$COMP,					! Compare strings
    BAS$DIF : NOVALUE,				! Difference between strings
    BAS$PLACE : NOVALUE,			! Shorten a string
    BAS$PROD : NOVALUE,				! Multiply two strings
    BAS$QUO : NOVALUE,				! Divide two strings
    BAS$SUM : NOVALUE,				! Sum of two strings
    PARSE_IN : NOVALUE,				! Convert to internal form
    PARSE_OUT : NOVALUE,			! Convert to external form
    FREE_STRINGS;				! Handler to free strings

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';			! Macros for defining psects

LIBRARY 'RTLSTARLE';				! System definitions

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!

LITERAL
!+
! Several of the string arithmetic routines encode the precision and
! a truncation flag in a single parameter.  This is done as follows:
! (P% is the precision parameter)
!
!    1. If P% is less than or equal to 5000, rounding occurs; if
!	more, truncation.
!
!    2. If P% is less than or equal to zero, rounding occurs on the
!	left side of the decimal point.
!
!    3. If P% is between 0 and 5000, rounding occurs on the right
!	side of the decimal point.
!
!    4. If P% is between 5000 and 10,000, truncation occurs on the
!	left side of the decimal point.
!
!    5.	If P% is greater than 10,000, truncation occurs on the right
!	side of the decimal point.
!
! To help the reader recognize where these semantics are implemented, the
! following symbol is used for 5000 (and 2* the symbol for 10,000) in the
! above contexts.
!-
    BAS$K_PREC_VAL = 5000,
!+
! There is a limit imposed by the PDP-11 implementation of BASIC-PLUS-2
! on the number of digits which can be processed.  This limit appears
! in two places: the precision of QUO$ is limited to 1E-55 (or 1E-56 if
! truncating) and number of digits which can be input is limited to 60.
! To help the reader recognize where these limits are implemented, the
! following constants are defined:
!-
    BAS$K_PREC_LIM1 = 55,			! Max digits in QUO$ when rounding
    BAS$K_PREC_LIM2 = 56,			! Max digits in QUO$ when truncating
    BAS$K_PREC_LIM3 = 60;			! Max digits when scanning input

!
!
! PSECTS:
!
DECLARE_PSECTS (BAS);				! Declare psects for BAS$ facility
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BAS$$STOP : NOVALUE,			! Signals a fatal BASIC error
    BAS$$SIGNAL : NOVALUE,			! Signals a BASIC error
    STR$GET1_DX,				! Allocate a string
    STR$FREE1_DX,				! Deallocate a string
    STR$COPY_R,					! Copy a string by ref
    LIB$MATCH_COND,				! Match condition codes
    STR$ADD : NOVALUE,				! Add two strings
    STR$MUL : NOVALUE,				! Multiply two strings
    STR$RECIP : NOVALUE,			! Take the reciprocal of a string
    STR$ROUND : NOVALUE,			! Rounds a string
    STR$DIVIDE: NOVALUE;			! Divide two strings

!+
! The following are the error codes used in this module:
!-

EXTERNAL LITERAL
    BAS$K_DATFORERR : UNSIGNED (8),		! Data format error
    BAS$K_ILLNUM : UNSIGNED (8),		! Illegal number
    BAS$K_FLOPOIERR : UNSIGNED (8),		! Floating point error
    BAS$K_DIVBY_ZER : UNSIGNED (8);		! Division by zero

BIND
    TABLE_Z = UPLIT BYTE (REP 49 OF (%X'00'),REP 9 OF (%X'01'),REP 198 OF (%X'00')),
    TABLE_NZ = UPLIT BYTE (REP 49 OF (%X'01'),REP 207 OF (%X'00')),
    MASK = UPLIT BYTE (%X'01');

BUILTIN
    SPANC;					!\Skip over a specified set of
						!/characters in a string

GLOBAL ROUTINE BAS$COMP (			! Compare strings
	ARG1, 					! First operand
	ARG2					! Second operand
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Compare two strings.  This is done by subtracting them and
!	testing the result for zero.
!
! FORMAL PARAMETERS:
!
!	ARG1.rt.dx	First number to compare, as +nnn.nnn
!	ARG2.rt.dx	Number to compare against, as +nnn.nnn
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	0 = ARGs are equal,
!	-1 = ARG1 less than ARG2,
!	1 = ARG1 greater than ARG2.
!
! SIDE EFFECTS:
!
!	Signals PROLOSSOR (for "impossible" conditions) and the
!	signals from PARSE_IN.
!
!--

    BEGIN

    MAP
	ARG1 : REF BLOCK [8, BYTE],
	ARG2 : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of ARG1
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_SIGN,
	A_EXP,
!+
! Internal form of ARG2
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	B_SIGN,
	B_EXP,
!+
! Temp to hold A-B.
!-
	C_DESC : BLOCK [8, BYTE] VOLATILE,
	C_SIGN,
	C_EXP,
!+
! Temp to hold result of comparison.
!-
	RESULT;

!+
! Enable a handler which will free the strings
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, C_DESC);

!+
! Convert the two arguments from external form to internal form.
! This is done by removing the non-digits from the string and
! returning the sign and exponent as separate values.
! Errors are signaled.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.ARG1, A_DESC, A_SIGN, A_EXP);
    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.ARG2, B_DESC, B_SIGN, B_EXP);
!+
! If the signs differ we can compute the result based on them.
! Otherwise we must subtract the inputs.
!-
    C_DESC [DSC$W_LENGTH] = 0;
    C_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    C_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    C_DESC [DSC$A_POINTER] = 0;

    IF (.A_SIGN NEQ .B_SIGN)
    THEN
	C_SIGN = .B_SIGN
    ELSE
	BEGIN
	A_SIGN = 1 - .A_SIGN;			! Change the sign of A
	STR$ADD (A_SIGN, A_EXP, A_DESC, B_SIGN, B_EXP, B_DESC, C_SIGN, C_EXP, C_DESC);
	END;

!+
! We are done with A and B, so free them.
!-
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
!+
! Set RESULT based on the sign of the difference between A and B.
!-
    RESULT = (IF (.C_SIGN) THEN 1 ELSE -1);
!+
! If the result is a one-character string whose digit is zero,
! the arguments were equal.  Otherwise they were not.
!-

    IF (.C_DESC [DSC$W_LENGTH] EQLU 1)
    THEN

	IF (CH$RCHAR (.C_DESC [DSC$A_POINTER]) EQL %C'0') THEN RESULT = 0;

!+
! We can now free C
!-
    STR$FREE1_DX (C_DESC);
    RETURN (.RESULT);
    END;					! end of BAS$COMP


GLOBAL ROUTINE BAS$DIF (			! Subtract strings
	DIF_DESC, 				! Difference
	OP1_DESC, 				! First input
	OP2_DESC				! Second input
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Subtract two strings.  DIF := OP1 - OP2
!
! FORMAL PARAMETERS:
!
!	DIF_DESC.wt.dx	The difference, OP1 - OP2
!	OP1_DESC.rt.dx	Operand OP1
!	OP2_DESC.rt.dx	Operand OP2
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals PROLOSSOR for certain "impossible" errors, and the signals
!	from PARSE_IN and PARSE_OUT.
!
!--

    BEGIN

    MAP
	OP1_DESC : REF BLOCK [8, BYTE],
	OP2_DESC : REF BLOCK [8, BYTE],
	DIF_DESC : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of OP1.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_SIGN,
	A_EXP,
!+
! Internal form of OP2.
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	B_SIGN,
	B_EXP,
!+
! Internal form of the difference, OP1 - OP2.
!-
	C_DESC : BLOCK [8, BYTE] VOLATILE,
	C_SIGN,
	C_EXP;

!+
! Enable a handler to free the strings.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, C_DESC);

!+
! Convert the two input arguments from external form to internal form.
! This is done by removing the non-digits from the string and
! returning the sign and exponent as separate values.
! Signal any errors.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP1_DESC, A_DESC, A_SIGN, A_EXP);
    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP2_DESC, B_DESC, B_SIGN, B_EXP);
!+
! Subtract the numbers using the large-precision string arithmetic
! package.
!-
    C_DESC [DSC$W_LENGTH] = 0;
    C_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    C_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    C_DESC [DSC$A_POINTER] = 0;
    B_SIGN = 1 - .B_SIGN;			! Change the sign of B.
    STR$ADD (A_SIGN, A_EXP, A_DESC, B_SIGN, B_EXP, B_DESC, C_SIGN, C_EXP, C_DESC);
!+
! We are done with A and B, so free them.
!-
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
!+
! Convert the difference to external form for the caller.
!-
    PARSE_OUT (C_DESC, .C_SIGN, .C_EXP, .DIF_DESC);
!+
! We can now free C
!-
    STR$FREE1_DX (C_DESC);
    RETURN;
    END;					! end of BAS$DIF


GLOBAL ROUTINE BAS$PLACE (			! Round or truncate a string
	RESULT_DESC, 				! Result
	OP1_DESC, 				! Number to be rounded/truncated
	PRECISION				! Digits of result
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Round or truncate a string to a particular position after
!	(or before) the decimal point.  RESULT = round (OP1)
!
! FORMAL PARAMETERS:
!
!	RESULT_DESC.wt.dx The result of rounding/truncating OP1
!	OP1_DESC.rt.dx	Operand OP1
!	PRECISION.rl.v	Number of digits to retain and, encoded,
!			the round/truncate flag.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals PROLOSSOR for certain "impossible" errors, and the signals
!	from PARSE_IN and PARSE_OUT.
!
!--

    BEGIN

    MAP
	OP1_DESC : REF BLOCK [8, BYTE],
	RESULT_DESC : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of OP1.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_SIGN,
	A_EXP,
	TRUNC_FLAG,				! 1 = truncate (rather than round)
	ROUND_POS,				! Where to round
!+
! The following is a descriptor for the constant 1.  It is multiplied by
! a power of 10 for rounding or truncating.
!-
	ONE_DESC : BLOCK [8, BYTE],
	ONE_BUF : VECTOR [1, BYTE];

!+
! Enable a handler to free A_DESC in case of error.
!-

    ENABLE
	FREE_STRINGS (A_DESC);

!+
! Convert the input argument from external form to internal form.
! This is done by removing the non-digits from the string and
! returning the sign and exponent as separate values.
! Errors are signaled.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP1_DESC, A_DESC, A_SIGN, A_EXP);
!+
! Round or truncate the result to a specified decimal place.
!-

    IF (.PRECISION LEQ BAS$K_PREC_VAL)
    THEN
	BEGIN
	TRUNC_FLAG = 0;
	ROUND_POS = -.PRECISION;
	END
    ELSE
	BEGIN
	TRUNC_FLAG = 1;
	ROUND_POS = -(.PRECISION - (BAS$K_PREC_VAL*2));
	END;

!+
! In order to do the BASIC rounding/truncation based on decimal place
! using the string package's rounding/truncation based on number of
! significant digits, we must be sure that the position we are rounding
! to is part of the significance.  Therefore we add 1E<ROUND_POS>,
! round or truncate to discard all lower digits, and then subtract
! 1E<ROUND_POS> to get back to where we belong.
!-
    ONE_DESC [DSC$W_LENGTH] = 1;
    ONE_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    ONE_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    ONE_DESC [DSC$A_POINTER] = ONE_BUF [0];
    ONE_BUF [0] = %C'1';
    STR$ADD (A_SIGN, A_EXP, A_DESC, 		!
	A_SIGN, ROUND_POS, ONE_DESC, 		!
	A_SIGN, A_EXP, A_DESC);
    STR$ROUND (%REF (.A_EXP + .A_DESC [DSC$W_LENGTH] - .ROUND_POS), TRUNC_FLAG, 	!
	A_SIGN, A_EXP, A_DESC, 			!
	A_SIGN, A_EXP, A_DESC);
    STR$ADD (A_SIGN, A_EXP, A_DESC, 		!
	%REF ((IF (.A_SIGN) THEN 0 ELSE 1)), ROUND_POS, ONE_DESC, 	!
	A_SIGN, A_EXP, A_DESC);

!+
! Check if the precision value is in the range of -1 to -4 (indicating
! rounding) or if the value is in the range of 9996 to 9999 (indicating
! truncation).  In either case, there is an incompatibility to be fixed
! here, so that VAX BASIC returns the same value as BASIC+2.
!-

    SELECTONE .PRECISION OF
      SET
	[-4999 TO -1]:				! Rounding parameter
	  BEGIN
	  IF .A_EXP NEQ 0
	    THEN
	      A_EXP = .A_EXP - ABS(.PRECISION);
	  END;
	[5001 TO 9999]:				! Truncation parameter
	  BEGIN
	    LOCAL
	      TEMP;
	  TEMP = 10000 - .PRECISION;
	  IF .A_EXP NEQ 0
	    THEN
	      A_EXP = .A_EXP - ABS(.TEMP);
	  END;
      TES;

!+
! Convert the product to external form for the caller.
!-
    PARSE_OUT (A_DESC, .A_SIGN, .A_EXP, .RESULT_DESC);
!+
! We can now free A
!-
    STR$FREE1_DX (A_DESC);
    RETURN;
    END;					! end of BAS$PLACES


GLOBAL ROUTINE BAS$PROD (			! Multiply strings
	PROD_DESC, 				! Product
	OP1_DESC, 				! First input
	OP2_DESC, 				! Second input
	PRECISION				! Digits of result
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Multiply two strings.  PROD := OP1 * OP2
!
! FORMAL PARAMETERS:
!
!	PROD_DESC.wt.dx	The product of OP1 and OP2
!	OP1_DESC.rt.dx	Operand OP1
!	OP2_DESC.rt.dx	Operand OP2
!	PRECISION.rl.v	Number of digits to retain and, encoded,
!			the round/truncate flag.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals PROLOSSOR for certain "impossible" errors, and the signals
!	from PARSE_IN and PARSE_OUT.
!
!--

    BEGIN

    MAP
	OP1_DESC : REF BLOCK [8, BYTE],
	OP2_DESC : REF BLOCK [8, BYTE],
	PROD_DESC : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of OP1.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_SIGN,
	A_EXP,
!+
! Internal form of OP2.
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	B_SIGN,
	B_EXP,
!+
! Internal form of the product, A*B.
!-
	C_DESC : BLOCK [8, BYTE] VOLATILE,
	C_SIGN,
	C_EXP,
	TRUNC_FLAG,				! 1 = truncate, 0 = round.
	ROUND_POS,				! Where to round the product
!+
! This is the constant 1, which is muliplied by a power of 10 for rounding
! purposes.
!-
	ONE_DESC : BLOCK [8, BYTE],
	ONE_BUF : VECTOR [1, BYTE];

!+
! Enable a handler to free the local strings.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, C_DESC);

!+
! Convert the two input arguments from external form to internal form.
! This is done by removing the non-digits from the string and
! returning the sign and exponent as separate values.
! Errors are signaled.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP1_DESC, A_DESC, A_SIGN, A_EXP);
    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP2_DESC, B_DESC, B_SIGN, B_EXP);
!+
! Multiply the numbers using the large-precision string arithmetic
! package.
!-
    C_DESC [DSC$W_LENGTH] = 0;
    C_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    C_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    C_DESC [DSC$A_POINTER] = 0;
    STR$MUL (A_SIGN, A_EXP, A_DESC, B_SIGN, B_EXP, B_DESC, C_SIGN, C_EXP, C_DESC);
!+
! We are done with A and B, so free them.
!-
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
!+
! Round or truncate the result to a specified decimal place.
!-

    IF (.PRECISION LEQ BAS$K_PREC_VAL)
    THEN
	BEGIN
	TRUNC_FLAG = 0;
	ROUND_POS = -.PRECISION;
	END
    ELSE
	BEGIN
	TRUNC_FLAG = 1;
	ROUND_POS = -(.PRECISION - (2*BAS$K_PREC_VAL));
	END;

!+
! In order to do the BASIC rounding/truncation based on decimal place
! using the string package's rounding/truncation based on number of
! significant digits, we must be sure that the position we are rounding
! to is part of the significance.  Therefore we add 1E<ROUND_POS>,
! round or truncate to discard all lower digits, and then subtract
! 1E<ROUND_POS> to get back to where we belong.
!-
    ONE_DESC [DSC$W_LENGTH] = 1;
    ONE_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    ONE_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    ONE_DESC [DSC$A_POINTER] = ONE_BUF [0];
    ONE_BUF [0] = %C'1';
    STR$ADD (C_SIGN, C_EXP, C_DESC, 		!
	C_SIGN, ROUND_POS, ONE_DESC, 		!
	C_SIGN, C_EXP, C_DESC);
    STR$ROUND (%REF (.C_EXP + .C_DESC [DSC$W_LENGTH] - .ROUND_POS), TRUNC_FLAG, 	!
	C_SIGN, C_EXP, C_DESC, 			!
	C_SIGN, C_EXP, C_DESC);
    STR$ADD (C_SIGN, C_EXP, C_DESC, 		!
	%REF ((IF (.C_SIGN) THEN 0 ELSE 1)), ROUND_POS, ONE_DESC, 	!
	C_SIGN, C_EXP, C_DESC);

!+
! Check if the precision value is in the range of -1 to -4 (indicating
! rounding) or if the value is in the range of 9996 to 9999 (indicating
! truncation).  In either case, there is an incompatibility to be fixed
! here, so that VAX BASIC returns the same value as BASIC+2.
!-

    SELECTONE .PRECISION OF
      SET
	[-4999 TO -1]:				! Rounding parameter
	  BEGIN
	  IF .C_EXP NEQ 0
	    THEN
	      C_EXP = .C_EXP - ABS(.PRECISION);
	  END;
	[5001 TO 9999]:				! Truncation parameter
	  BEGIN
	    LOCAL
	      TEMP;
	  TEMP = 10000 - .PRECISION;
	  IF .C_EXP NEQ 0
	    THEN
	      C_EXP = .C_EXP - ABS(.TEMP);
	  END;
      TES;

!+
! Convert the product to external form for the caller.
!-
    PARSE_OUT (C_DESC, .C_SIGN, .C_EXP, .PROD_DESC);
!+
! We can now free C
!-
    STR$FREE1_DX (C_DESC);
    RETURN;
    END;					! end of BAS$PROD


GLOBAL ROUTINE BAS$QUO (			! Divide strings
	QUO_DESC, 				! Quotient
	OP1_DESC, 				! First input
	OP2_DESC, 				! Second input
	PRECISION				! Digits of result
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Divide two strings.  QUO := OP1 / OP2
!	No more than 55 digits of precision are permitted.
!	(56 if truncating.)
!
! FORMAL PARAMETERS:
!
!	QUO_DESC.wt.dx	The quotient of OP1 and OP2
!	OP1_DESC.rt.dx	Operand OP1
!	OP2_DESC.rt.dx	Operand OP2
!	PRECISION.rl.v	Number of digits to retain and, encoded,
!			the round/truncate flag.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals BAS$_FLOPOIERR if the number of places is greater than
!	55 or 56.  Signals BAS$_DIVBY_ZER if the divisor is zero.
!	Also, PARSE_IN and PARSE_OUT signal.
!--

    BEGIN

    MAP
	OP1_DESC : REF BLOCK [8, BYTE],
	OP2_DESC : REF BLOCK [8, BYTE],
	QUO_DESC : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of OP1.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_SIGN,
	A_EXP,
!+
! Internal form of OP2.
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	B_SIGN,
	B_EXP,
!+
! Internal form of quotient.
!-
	C_DESC : BLOCK [8, BYTE] VOLATILE,
	C_SIGN,
	C_EXP,

	RND_TRUNC,				! 0 = truncate, 1 = round
	PREC,					! Number of digits to the
						!   right of the decimal point
	END_ADDR,				! End of string address
	NEW_ADDR,				!\Used to store resultant
						!/address from SPANC
	BUF,					! Pointer to string of digits
	SAV_ADDR,				! Temporary storage address
	LENGTH,					! Used in SPANC
  	C_LENGTH,				! Used to store length of string
	SAV_BUF,				! Storage for buffer address
	SAV_EXP,				! Storage for exp value
	SAV_LENGTH,				! Storage for length value
	DIFF;					! Used in SPANC to calc offsets
!+
! The following FORTRAN subroutines can be used to print the progress of
! this routine, if the calls to them are enabled.
!-
    %(
	SUBROUTINE MONITOR_I (ICODE, IVAL)
	IMPLICIT INTEGER (A-Z)
	TYPE 900, ICODE, IVAL
900	FORMAT (I3,I6)
	RETURN
	END
	SUBROUTINE MONITOR_T (ICODE, IVAL)
	IMPLICIT INTEGER (A-Z)
	CHARACTER*(*) IVAL
	TYPE 901, ICODE, IVAL
901	FORMAT (I3, 3X, A)
	RETURN
	END
)%
!+
! In the printout from the above code,
!
!	1 = eps_exp
!	2 = delta_exp
!	3 = round_pos
!	4 = c_exp
!	5 = trial_exp
!	6 = trial digits
!	7 = c digits
!-

    COMPILETIME
	PERFORM_MONITORING = 0;			! Set =1 to get calls to monitors

%IF PERFORM_MONITORING
%THEN

    EXTERNAL ROUTINE
	MONITOR_I,				! Print an integer
	MONITOR_T;				! Print text

%FI

!+
! Enable a handler to free the local strings in case of error.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, C_DESC);

!+
! Convert the two input arguments from external form to internal form.
! This is done by removing the non-digits from the string and
! returning the sign and exponent as separate values.
! Errors are signaled.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP1_DESC, A_DESC, A_SIGN, A_EXP);

    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP2_DESC, B_DESC, B_SIGN, B_EXP);

!+
! Set up descriptor for internal form of C
!-

    C_DESC [DSC$W_LENGTH] = 0;
    C_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    C_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    C_DESC [DSC$A_POINTER] = 0;

!+
! Set up parameters for call to STR$DIVIDE
!-

    IF (.PRECISION LEQ BAS$K_PREC_VAL)
    THEN
	BEGIN
	RND_TRUNC = 1;
	PREC = .PRECISION;
	END
    ELSE
	BEGIN
	RND_TRUNC = 0;
	PREC = .PRECISION - 2*BAS$K_PREC_VAL;
	END;

!+
! For compatability with the PDP-11, don't allow more than
! 55 or 56 digits to the right of the decimal point.
!-

    IF .C_DESC[DSC$W_LENGTH] GTR (BAS$K_PREC_LIM2 - .RND_TRUNC)
    THEN
	BAS$$SIGNAL (BAS$K_FLOPOIERR);


!+
! The next section of code is to interface with the new routine STR$DIVIDE.
!-

    STR$DIVIDE (A_SIGN,A_EXP,A_DESC,
		B_SIGN,B_EXP,B_DESC,
		PREC,RND_TRUNC,
		C_SIGN,C_EXP,C_DESC);		! Invoke STR$DIVIDE
%IF PERFORM_MONITORING
%THEN
    MONITOR_I (%REF (3), %REF (.ROUND_POS));
%FI

!+
! The following code is to ensure compatibility with the PDP-11.
! Need to strip off any leading zeroes or any trailing zeroes.
!-

!+
! Initial set-up.  Set-up pointers to various sections within
! the resultant string.
!-

    BUF = .C_DESC[DSC$A_POINTER];			! Fetch addr of buffer
    C_LENGTH = .C_DESC[DSC$W_LENGTH];			! Fetch length of string
    END_ADDR = .BUF + .C_LENGTH;			! Ptr to end of buffer
    SAV_EXP = .C_EXP;					! Save the exp value
    SAV_LENGTH = .C_LENGTH;				! Save the length of C
    SAV_BUF = .BUF;					! Save ptr to beg of buffer

!+
! First check if the exponent value if less than the length of
! the string.  If it is, then we know that we have digits to the
! left of the decimal point.
!-

IF (.C_EXP) LSS 0
  THEN
    BEGIN
    IF ABS(.C_EXP) LSS .C_LENGTH
      THEN
	BEGIN
	LENGTH = ABS (.C_EXP);
	BUF = .BUF + (.C_LENGTH + .C_EXP);
	END
      ELSE
	LENGTH = .C_LENGTH;

!+
! Check for first non-zero digit to right of decimal point.
!-

    NEW_ADDR = SPANC (LENGTH,.BUF,TABLE_NZ,MASK);
    IF .NEW_ADDR EQL 0				!\Indicates all zeroes to 
						!/right of decimal point
      THEN
	BEGIN
	IF ABS(.C_EXP) GEQ .C_LENGTH	
	  THEN
	    BEGIN				! Here, length = exponent value
	    C_LENGTH = 1;			! Just set length to one
	    C_EXP = 0;				! Set exp of result to zero
	    END
	  ELSE
	    BEGIN				! Here, exponent < length
	    C_LENGTH = .C_LENGTH - ABS(.C_EXP);	! Decr C_LENGTH by the exp value
	    C_EXP = 0;				! Set exp of result to zero
	    END;
	C_DESC[DSC$W_LENGTH] = .C_LENGTH;	! Store updated length
	END
      ELSE
	!+
	! At this point, we have the address of the first non-zero
	! position within the resultant string.  Now we need to search
	! for a zero digit.  If none, then we know that all the digits
	! to the right of the decimal point are non-zero, and we can
	! leave the exponent value and length value as is.
	!-
	BEGIN
	!+
	! Start searching for a zero digit, starting at the address
	! returned from the previous SPANC.
	!-
	
	IF .NEW_ADDR NEQ .END_ADDR			! If not at end of string
	  THEN
	    BEGIN
	    WHILE 1 DO
	      BEGIN
	      SAV_ADDR = .NEW_ADDR;			! Save the current addr
	      LENGTH = .END_ADDR - .NEW_ADDR;		! Calculate new length
	      NEW_ADDR = SPANC (LENGTH,.NEW_ADDR,TABLE_Z,MASK);
	      IF .NEW_ADDR NEQ 0			!\Indicates a zero
							!/digit has been found
		THEN
		  BEGIN
		  !+
		  ! Now search for a non-zero digit.
		  !-
		  SAV_ADDR = .NEW_ADDR;			! Save current address
		  LENGTH = .END_ADDR - .NEW_ADDR;	! Calculate length of string to be search
		  NEW_ADDR = SPANC (LENGTH,.NEW_ADDR,TABLE_NZ,MASK);
		  IF .NEW_ADDR EQL 0			! No match found
		    THEN
		      BEGIN
		      DIFF = .END_ADDR - .SAV_ADDR;	!\Calculate length of
							!/string that is zero
	 	      C_LENGTH = .C_LENGTH - .DIFF;	! Decr length by that amount
		      C_EXP = - (ABS(.C_EXP) - .DIFF);	! Decr exponent value by that amount
		      C_DESC[DSC$W_LENGTH] = .C_LENGTH;	! Store updated length
		      EXITLOOP				! Escape from loop
		      END;
		    END
		  ELSE
		    EXITLOOP
		END;
	    END;
	  END;
	END;
       IF (.SAV_EXP LEQ 0) AND (ABS(.SAV_EXP) LSS .SAV_LENGTH)
	THEN
	  BEGIN
	    LOCAL
	      LEFT_DIGITS;

	  !+
	  ! Here we know that C_EXP is less than C_LENGTH.
	  ! Now we are ready to strip off leading zeroes that
	  ! may exist to the left side of the decimal point.
	  !-

	  LEFT_DIGITS = .C_LENGTH - ABS(.C_EXP);	!\Calc # of digits to
							!/left of decimal point
	  NEW_ADDR = SPANC (LEFT_DIGITS,.SAV_BUF,TABLE_NZ,MASK); !\Search for 
								 !/non-zero
	  IF .NEW_ADDR EQL 0				! All zeroes to left of D.P.
	    THEN
	      BEGIN		
	      C_LENGTH = .C_LENGTH - .LEFT_DIGITS;	! Decr C_LENGTH
	      IF .C_LENGTH EQL 0
	  	THEN
		  C_LENGTH = 1				! Ensure length of 1
		ELSE
	          C_DESC[DSC$A_POINTER] = .SAV_BUF + .LEFT_DIGITS; !Update buffer address
	      END
	    ELSE
	      BEGIN
	      DIFF = .NEW_ADDR - .SAV_BUF;		! Calculate offset
	      C_LENGTH = .C_LENGTH - .DIFF;		! Update length
	      C_DESC[DSC$A_POINTER] = .SAV_BUF + .DIFF;! Update buffer address
	      END;
	  C_DESC[DSC$W_LENGTH] = .C_LENGTH;
	  END
	ELSE
	  IF .SAV_EXP GTR 0
	    THEN
	!+
	! Here we know that the exponent value is positive.
	!-
	  BEGIN
	  NEW_ADDR = SPANC (C_LENGTH,.SAV_BUF,TABLE_NZ,MASK);
	  IF .NEW_ADDR EQL 0				!\Indicates all zeroes
							!/to left of decimal pt
	    THEN
	      BEGIN
	      C_LENGTH = 1;				! C_LENGTH = 1
	      C_EXP = 0;				! Set exponent to zero
	      END
	    ELSE
	      BEGIN
	      DIFF = .NEW_ADDR - .SAV_BUF;
	      C_LENGTH = .C_LENGTH - .DIFF;
	      C_DESC[DSC$A_POINTER] = .SAV_BUF + .DIFF;
	      END;
	  C_DESC[DSC$W_LENGTH] = .C_LENGTH;
	  END;


!+
! Convert the quotient to external form for the caller.
!-
    PARSE_OUT (C_DESC, .C_SIGN, .C_EXP, .QUO_DESC);
!+
! We can now free A, B and C
!-
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
    STR$FREE1_DX (C_DESC);
    RETURN;
    END;					! end of BAS$QUO


GLOBAL ROUTINE BAS$SUM (			! Add strings
	SUM_DESC, 				! Sum
	OP1_DESC, 				! First input
	OP2_DESC				! Second input
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Add two strings.  SUM := OP1 + OP2
!
! FORMAL PARAMETERS:
!
!	SUM_DESC.wt.dx	The sum of OP1 and OP2
!	OP1_DESC.rt.dx	Operand OP1
!	OP2_DESC.rt.dx	Operand OP2
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals PROSOSSOR for certain "impossible" errors, and the
!	signals from PARSE_IN and PARSE_OUT.
!
!--

    BEGIN

    MAP
	OP1_DESC : REF BLOCK [8, BYTE],
	OP2_DESC : REF BLOCK [8, BYTE],
	SUM_DESC : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of OP1.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_SIGN,
	A_EXP,
!+
! Internal form of OP2.
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	B_SIGN,
	B_EXP,
!+
! Internal form of the sum, OP1 + OP2.
!-
	C_DESC : BLOCK [8, BYTE] VOLATILE,
	C_SIGN,
	C_EXP;

!+
! Enable a handler to free the local strings in case of error.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, C_DESC);

!+
! Convert the two input arguments from external form to internal form.
! This is done by removing the non-digits from the string and
! returning the sign and exponent as separate values.
! Errors are signaled.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP1_DESC, A_DESC, A_SIGN, A_EXP);
    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
    PARSE_IN (.OP2_DESC, B_DESC, B_SIGN, B_EXP);
!+
! Add the numbers using the large-precision string arithmetic package.
!-
    C_DESC [DSC$W_LENGTH] = 0;
    C_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    C_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    C_DESC [DSC$A_POINTER] = 0;
    STR$ADD (A_SIGN, A_EXP, A_DESC, B_SIGN, B_EXP, B_DESC, C_SIGN, C_EXP, C_DESC);
!+
! We are done with A and B, so free them.
!-
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
!+
! Convert the sum to external form for the caller.
!-
    PARSE_OUT (C_DESC, .C_SIGN, .C_EXP, .SUM_DESC);
!+
! We can now free C
!-
    STR$FREE1_DX (C_DESC);
    RETURN;
    END;					! end of BAS$SUM


ROUTINE PARSE_IN (				! Scan a number and divide it up
	ARG_DESC, 				! The number to scan
	DIGITS, 				! Where to put the digits
	SIGN, 					! Where to put the sign
	EXPONENT				! Where to put the power of ten
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert a numeric string of the form +nnn.nnn into a digit
!	string and a separate sign and decimal exponent.  Don't allow
!	more than 60 digits, for compatability with the PDP-11.
!
! FORMAL PARAMETERS:
!
!	ARG_DESC.rt.dx	The number to parse
!	DIGITS.wnu.dx	Where to put the digits found
!	SIGN.wl.r	0 = positive, 1 = negative
!	EXPONENT.wl.r	Decimal exponent
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals BAS$_ILLNUM if there are more than 60 digit,
!	BAS$_DATFORERR if the syntax of the number is wrong,
!	and also signals if storage is exhausted.
!
!--

    BEGIN

    MAP
	ARG_DESC : REF BLOCK [8, BYTE],
	DIGITS : REF BLOCK [8, BYTE];

    LOCAL
!+
! The following three locals hold the internal form of the number.
!-
	SIGN_VAL,
	BUF_DESC : BLOCK [8, BYTE] VOLATILE,
	EXPON,
	SIGN_SEEN,				! 1 = we have scanned a + or -
	DIGIT_SEEN,				! 1 = we have seen at least one digit
	DOT_SEEN,				! 1 = we have seen a decimal point
	BLANKS_SEEN,				! 1 = we have seen trailing blanks
	PUTTER,					! Counts position in the output buffer
	BUF : REF VECTOR [65535, BYTE],		! Addresses result
	ARG : REF VECTOR [65535, BYTE],		! Addresses source
	ARG_LEN;				! Length of the source

!+
! Enable a handler to free the local string in case of an error.
!-

    ENABLE
	FREE_STRINGS (BUF_DESC);

!+
! Allocate enough space to hold the digits.  It is convenient to
! allocate before scanning, so we may allocate a little too much,
! but the space will be freed before we return.
! Note that we must fetch the length field of the descriptor only
! once, so that we will not attempt to overrun our local string if
! the source is reallocated longer by an AST.
!-
    BUF_DESC [DSC$W_LENGTH] = 0;
    BUF_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    BUF_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    BUF_DESC [DSC$A_POINTER] = 0;
    ARG_LEN = .ARG_DESC [DSC$W_LENGTH];
    STR$GET1_DX (%REF (.ARG_LEN + 8), BUF_DESC);
!+
! Now scan the incoming number.
!-
    PUTTER = 0;
    BUF = .BUF_DESC [DSC$A_POINTER];
    ARG = .ARG_DESC [DSC$A_POINTER];
    SIGN_SEEN = 0;
    SIGN_VAL = 0;
    DIGIT_SEEN = 0;
    DOT_SEEN = 0;
    BLANKS_SEEN = 0;
    EXPON = 0;

    INCR GETTER FROM 0 TO (.ARG_LEN - 1) DO

	SELECTONE .ARG [.GETTER] OF
	    SET

	    [%C'+'] :
		BEGIN				! Plus sign

		IF (.SIGN_SEEN OR .DIGIT_SEEN OR .DOT_SEEN OR .BLANKS_SEEN) THEN BAS$$STOP (BAS$K_DATFORERR);

		SIGN_SEEN = 1;
		SIGN_VAL = 0;
		END;

	    [%C'-'] :
		BEGIN				! Minus sign

		IF (.SIGN_SEEN OR .DIGIT_SEEN OR .DOT_SEEN OR .BLANKS_SEEN) THEN BAS$$STOP (BAS$K_DATFORERR);

		SIGN_SEEN = 1;
		SIGN_VAL = 1;
		END;

	    [%C'.'] :
		BEGIN				! Decimal point

		IF (.DOT_SEEN OR .BLANKS_SEEN) THEN BAS$$STOP (BAS$K_DATFORERR);

		DOT_SEEN = 1;
		END;

	    [%C' '] :
		BEGIN				! Blank, better be leading or trailing.

		IF (.SIGN_SEEN OR .DIGIT_SEEN OR .DOT_SEEN) THEN BLANKS_SEEN = 1;

		END;

	    [%C'0' TO %C'9'] :
		BEGIN				! Decimal digit

		IF (.BLANKS_SEEN) THEN BAS$$STOP (BAS$K_DATFORERR);

		IF (.DIGIT_SEEN OR .DOT_SEEN OR (.ARG [.GETTER] NEQ %C'0'))
		THEN
		    BEGIN
!+
! This is not a leading zero
!-
		    DIGIT_SEEN = 1;
		    BUF [.PUTTER] = .ARG [.GETTER];
		    PUTTER = .PUTTER + 1;

		    IF (.DOT_SEEN) THEN EXPON = .EXPON - 1;

		    END;

		END;

	    [OTHERWISE] :
		BAS$$STOP (BAS$K_DATFORERR);
	    TES;

!+
! This is the end of the INCR loop.
!-

    IF ( NOT .DIGIT_SEEN)
    THEN
	BEGIN
!+
! If there are no digits, or only leading zeros, take the number to
! be zero.  Don't be too gullible, however.
!-

	IF (.SIGN_SEEN OR .DOT_SEEN OR .BLANKS_SEEN) THEN BAS$$STOP (BAS$K_DATFORERR);

	BUF [.PUTTER] = %C'0';
	PUTTER = .PUTTER + 1;
	END;

!+
! If there are more than 60 digits in the number, reject it for compatabliity
! with the PDP-11.
!-

    IF (.PUTTER GTR BAS$K_PREC_LIM3) THEN BAS$$STOP (BAS$K_ILLNUM);

!+
! If we make it to here the number is in proper form.
! Return it to the caller.
!-
    .SIGN = .SIGN_VAL;
    .EXPONENT = .EXPON;
    STR$COPY_R (.DIGITS, PUTTER, .BUF);
!+
! Free our local string
!-
    STR$FREE1_DX (BUF_DESC);
    END;					! end of PARSE_IN

ROUTINE PARSE_OUT (				! Put together a number
	DIGITS, 				! Where to find the digits
	SIGN, 					! Where to find the sign
	EXPONENT, 				! Where to find the power of ten
	ARG_DESC				! Where to put the result
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert an internal number, which has separate sign, exponent
!	and digit string, into an external number, which combines them
!	in the form +nnn.nnn.
!
! FORMAL PARAMETERS:
!
!	DIGITS.rnu.dx	Where to find the digits
!	SIGN.rl.r	0 = positive, 1 = negative
!	EXPONENT.wl.r	Decimal exponent
!	ARG_DESC.wt.dx	Where to put the composite number
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Signals PROLOSSOR for certain "impossible" errors, and MAXMEMEXC
!	if string memory is exhausted.
!
! SIDE EFFECTS:
!
!	Signals BAS$_ILLNUM if there are more than 65,535 digits,
!	BAS$_MAXMEMEXC if space for the string is unobtainable,
!	and BAS$_PROLOSSOR if we are unable to free the string.
!
!--

    BEGIN

    MAP
	ARG_DESC : REF BLOCK [8, BYTE],
	DIGITS : REF BLOCK [8, BYTE];

    LOCAL
	BUF_DESC : BLOCK [8, BYTE] VOLATILE,	! Describes result
	PUTTER,					! Counts positions in BUF (below)
	BUF : REF VECTOR [65535, BYTE],		! Addresses result string
	DIGIT_LEN,				! Length of input string
	DIGIT_BUF : REF VECTOR [65535, BYTE],	! Addresses input string
	HIGH_POS,				! Max power of ten in result
	LOW_POS;				! Min power of ten in result

!+
! Enable a handler to free the local string in case of error.
!-

    ENABLE
	FREE_STRINGS (BUF_DESC);

!+
! Allocate enough space to hold the digits, a leading sign, and an
! imbedded (or trailing) decimal point.  We must allocate enough
! space to reach the units position in order to be able to place
! the decimal point.
!-
    DIGIT_LEN = .DIGITS [DSC$W_LENGTH];
    DIGIT_BUF = .DIGITS [DSC$A_POINTER];
    HIGH_POS = MAX (.DIGIT_LEN + .EXPONENT - 1, -1);
    LOW_POS = MIN (.EXPONENT, 0);
    BUF_DESC [DSC$W_LENGTH] = 0;
    BUF_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    BUF_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    BUF_DESC [DSC$A_POINTER] = 0;
!+
! If the resultant number has too many digits to be represented on
! VAX, give an error message.
!-

    IF ((.HIGH_POS - .LOW_POS + 3) GTR 65535) THEN BAS$$STOP (BAS$K_ILLNUM);

    STR$GET1_DX (%REF (.HIGH_POS - .LOW_POS + 3), BUF_DESC);
    BUF = .BUF_DESC [DSC$A_POINTER];
    PUTTER = 0;

    IF (.SIGN)
    THEN
	BEGIN
	BUF [.PUTTER] = %C'-';
	PUTTER = .PUTTER + 1;
	END;

    DECR POS FROM .HIGH_POS TO .LOW_POS DO
	BEGIN

	IF (.POS EQL -1)
	THEN
	    BEGIN
	    BUF [.PUTTER] = %C'.';
	    PUTTER = .PUTTER + 1;
	    END;

	IF ((.POS GTR (.EXPONENT + .DIGIT_LEN - 1)) OR (.POS LSS .EXPONENT))
	THEN
	    BUF [.PUTTER] = %C'0'
	ELSE
	    BUF [.PUTTER] = .DIGIT_BUF [(.EXPONENT + .DIGIT_LEN - 1) - .POS];

	PUTTER = .PUTTER + 1;
	END;

!+
! Now copy the string back to the caller.
!-
    STR$COPY_R (.ARG_DESC, PUTTER, .BUF);
!+
! Free our local string
!-
    STR$FREE1_DX (BUF_DESC);
    RETURN;
    END;					! end of PARSE_OUT

ROUTINE FREE_STRINGS (				! Free local strings
	SIG, 					! Signal vector
	MECH, 					! Mechanism vector
	ENBL					! Enable vector
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If we are unwinding, free the local strings.  They are passed
!	in the enable vector.
!
! FORMAL PARAMETERS:
!
!	SIG.rl.a	A counted vector of parameters to LIB$SIGNAL/STOP
!	MECH.rl.a	A counted vector of info from CHF
!	ENBL.ra.a	A counted vector of ENABLE argument addresses.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Always SS$_RESIGNAL, which is ignored when unwinding.
!
! SIDE EFFECTS:
!
!	Frees all of the strings passed as enable arguments.
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,
	MECH : REF VECTOR,
	ENBL : REF VECTOR;

!+
! Only free the strings if this is the UNWIND condition.
!-

    IF ( NOT (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND)))) THEN RETURN (SS$_RESIGNAL);

!+
! Go through the enable arguments, freeing them.
!-

    INCR ARG_NO FROM 1 TO .ENBL [0] DO

	IF (..ENBL [.ARG_NO] NEQ 0) THEN STR$FREE1_DX (.ENBL [.ARG_NO]);

    RETURN (SS$_RESIGNAL);
    END;					! end of FREE_STRINGS
END						! end of module BAS$SARITH

ELUDOM

