%TITLE 'LIB$CVT_DX_DX  any to any data type conversion'
MODULE LIB$CVTDXDX (				! General data type conversion.
		IDENT = '1-008'			! File:LIBCVTDX.B32 Edit: FM1008
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	General Utility Library
!
! ABSTRACT:
!
!		This is the general data type conversion facility.
!		Given two parameters, one the source descriptor,
!		second the destination descriptor this routine
!		will convert the source to destination.
!		The permitted set of class, data type and combination
!		of the two is a subset of the ones allowed in the
!		calling standard.
!
!	The following is a general description of LIB$CVT_DX_DX.
!
!       This module is divided into two routines on the bases of functional
!	modularity.  The front-end (LIB$$FIND_CVT_PATH), and back-end (LIB$CVT_DX_DX).
!	The front-end frees the back-end of any error checking of invalid
!	class or data type or combination of the two, or decisions that requires
!	knowledge of which class or data type is being converted.  The only
!	information that the back-end knows about is what the conversion path
!	is, and where the intermediate data is.  The back-end then scales the
!	intermediate data if necessary and converts it to the destination
!	data type.  Note that even though a scale may not be necessary, the
!	intermediate data is still converted to a second intermediate data type
!	just to be consistent.
!
!     1.  Upon entry to LIB$CVT_DX_DX, LIB$$FIND_CVT_PATH routine is called.
!	  LIB$$FIND_CVT_PATH has 4 functions, they are :
!		a. Find any errors concerning the class, and data type of
!		   source and destination descriptor.  These errors can be
!		   invalid class, invalid data type, or invalid combination
!		   of a class and data type.  It can also tell which descriptors
!		   are supported by the VAX-11 calling standard and which are
!		   supported by this routine.
!
!		b. Figure out what the conversion path is, i.e. class,dtype --> class,dtype.
!		   these paths are given names such as K_SMLINT_DEC, which reads
!		   "from small integer to decimal" (categories are defined later).
!
!		c. Convert the source data to an intermediate data.  The strategy
!		   used to select the appropriate intermediate data is explained later.
!
!		d. Put whatever information needed about the source and destination
!		   descriptor in two structures passed by LIB$CVT_DX_DX.
!		   These two structures SRC_INFO, and DST_INFO, contain the kind
!		   of information that can only be visible when the class, and
!		   data type of the source and destination descriptors are being
!		   manipulated. These two structures can be expanded to contain
!		   more information as new class, and data types may require it.
!
!
!     2.  The following is an overview of the design of FIND_CVT_PATH :
!	  The problem to be solved is to recognize "valid" descriptors.
!	  A descriptor is valid if CLASS and DATA TYPE fields of the descriptor
!	  satisfy certain conditions.
!	  With this problem in mind we shall use some formal language theory
!	  and applications to solve it.
!	  Let us take a hypothetical problem that is very close but smaller in
!	  magnitude of the original problem and solve it.
!	  Suppose that the set of classes that we are interested about are
!	  CLASS = { c1, c2, c3 }, and the set of data types are
!	  DTYPE = { d1, d2, d3, d4 }.  Then suppose that only a certain combinations
!	  of CLASS and DTYPE are valid, and they are c1d3, c2d1, c3d2, c3d4.
!	  Hence language L(G) is consisted of sentences { c1d3, c2d1, c3d2, c3d4 }.
!	  First we need to come up with a grammar for the language L(G).
!	  Grammar for L(G) :
!		Z  -->  <S1>d3 | <S2>d1 | <S3>d2 | <S3>d4
!		S1 -->  c1
!		S2 -->  c2
!		S3 -->  c3
!		S4 -->  c4
!	  A close look shows that this is a Chomsky type 3 regular grammar,
!	  because productions are all
!		NON-TERMINAL --> terminal
!			or
!		NON_TERMINAL --> <NON-TERMINAL>terminal
!	  This type of grammar has the nice feature that its sentential forms
!	  can be "accepted" by a finite state machine.
!	  The sentential forms of this grammar can also be accepted by a
!	  deterministic finite automaton because each right hand side has a
!	  unique left hand side.
!	  A DFA can be written to recognize sentences of this grammar and to
!	  reject sentences that are not in the language.
!	  The original problem is very similar to this hypothetical one, the
!	  only difference is that the set CLASS and DTYPE is larger.
!	  LIB$$FIND_CVT_PATH is just a DFA that accepts sentences of language L(V)
!	  when L(V) is pairs of VAX-11 DSC$K_CLASS_x DSC$K_DTYPE_y.  The grammar
!	  for L(V) is very similar to the grammar for L(G) above.
!
!     3.  In order to achieve the conflicting goals : fast,  not  large
!         in  size,  expandable, no loss of precision as a result of intermediate
!         values, there is a need for  a  compromise.  The strategy for categorizing
!	  the data types is based on three goals:  precision should not be lost
!	  as a result of converting to intermediate data types, data types of
!	  the same category should share similar internal representations, so
!	  they can be converted to and from each other easily, and seperate data
!	  types that the machine architecture has not yet provided machine
!	  instructions for.  The third goal provides easy and fast conversions for
!	  data types that there exists machine instructions for their conversions.
!	  The current categories where formulated by the following strategy:
!	  Divide  the  integers into two groups, small and large integers.
!	  Divide the floating numbers into two categories small and large
!	  floating. The small category will be the data types
!	  that machine instructions are available for their conversions.
!	  The large category consist of data types that there are no machine instructions for
!	  their conversions or the instructions must be emulated (LIB$EMULATE)
!	  for some VAX machines.
!	  This categorization will provide the callers that are attempting a 'simple' conversion
!	  a fast and smooth way.
!	  As a result we have the following :
!	  INTEGER	--> SMALL_INTEGER | LARGE_INTEGER
!	  FLOAT		--> SMALL_FLOAT | LARGE_FLOAT
!	  SMALL_INTEGER	--> bu | wu | b | w | l		!Intermediate L
!	  LARGE_INTEGER	--> lu | q			!Intermediate OU
!	  SMALL_FLOAT	--> f | d			!Intermediate D
!	  LARGE_FLOAT	--> g | h			!Intermediate H
!	  DEC		--> nu | nl | nlo | nr | nro | nz !Intermediate P
!	  NBDS          --> nbds			!Intermediate T
!
!     4.  Upon return from LIB$$FIND_CVT_PATH, the main routine then enters a
!	  CASE statement that selects the desired conversion.  This CASE
!	  is explained in detail in the first paragraph of the statement.
!
!
! ENVIRONMENT:	User mode - AST reentrant
!
! AUTHOR:	Farokh Morshed		01-09-1981
!
! MODIFIED BY:
!
! 1-001	- Original.  FM1001	01-09-1981
! 1-002 - Fix the problem with (SMLINT, LRGINT, DEC) to NBDS having an explicit
!	  sign when plus should be implied.  Also [DEC_NBDS] scaled twice, 
!	  changed it to scale only once.  FM 5-NOV-81.
! 1-003 - Fix the problem with [K_DEC_NBDS].  The length of CLASS_S_DESC was
!	  not being reset. FM
! 1-004 - Put in a new data type, DSC$K_DTYPE_VT.  Cleaned up data type B
!	  out of NBDS.  FM 1-DEC-81.
! 1-005 - Fix the bug where destination length is not picked up from DST_INFO.
!	  FM 2-DEC-81.
! 1-006 - Constants which are addressed by things like PACK_ZERO should be
!	  all longwords.
! 1-007 - LIB$_ROPRAND was left out of the exception handler.  FM 8-FEB-82.
! 1-008 - A couple of missing dots fixed -Q -> G and H.
!--


%SBTTL 'Declarations'
!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!
!The reason for using PRESERVE is that it is of no cost, and the benefits may
!be of value.  It can be taken out.
!

LINKAGE
    JSB_R0 = JSB (REGISTER = 0) : PRESERVE (0, 1),
    JSB_R1 = JSB (REGISTER = 0, REGISTER = 1) : PRESERVE (0, 1),
    JSB_RETR0_R1 = JSB (REGISTER = 0, REGISTER = 1) : PRESERVE (1),
    JSB_R2 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2) : PRESERVE (0, 1),
    JSB_R3 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3) : PRESERVE (0, 1),
    JSB_R6 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2, REGISTER = 3, REGISTER = 4, REGISTER = 5) :
    PRESERVE (0, 1),
    SCOPYR_JSB_R6 = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 2) : NOPRESERVE (2),
    SCOPY_JSB_R6 = JSB (REGISTER = 0, REGISTER = 1);

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    LIB$CVT_DX_DX,				! The conversion routine.
    CVT_HANDLER;				! Error handler.

						! being done and report any
						! unsupported fields in the descriptors.
!
! INCLUDE FILES:
!

LIBRARY 'RTLSTARLE';				! System symbols, from SYS$LIBRARY:STARLET.L32

REQUIRE 'RTLIN:RTLPSECT';			! Define PSECT declarations macros

!+
! EXTERNAL LITERAL
!-

EXTERNAL LITERAL
!+
! These are condition value.
!-
    LIB$_INTOVF,				! Integer overflow.
    LIB$_FLTOVF,				! Floating overflow.
    LIB$_DECOVF,				! Decimal overflow.
    LIB$_FLTUND,				! Floating underflow.
    LIB$_ROPRAND,				! Reserved operand.
    LIB$_INVCVT,				! Invalid conversion.
    LIB$_INVDTYDSC,				! Invalid dtype in descriptor.
    LIB$_INVCLADSC,				! Invalid class in descriptor.
    LIB$_INVCLADTY,				! Invalid class dtype combination.
    LIB$_INVNBDS,				! Invalid numeric byte data string.
    LIB$_DESSTROVF,				! Destination string overflow.
    LIB$_OUTSTRTRU,				! Output string truncated (warning).
    LIB$_FATERRLIB,				! Fatal error in library.
    LIB$_STRTRU;				! String truncated.

!
! MACROS:
!
!<BLF/MACRO>
!+
! These MACROs have been put in the module declartion part to make the routine cleaner,
! and easier to read.
!-

MACRO
!+
! These MACROs are defined for the purpose of clarity, less typing, and anticipation
! of future support of BUILTINs.
!-
    CVTROUD =
	LIB$$CVT_CVTROUD_R1 %,
    CVTROUH =
	LIB$$CVT_CVTROUH_R1 %,
    CVTRDQ =
	LIB$$CVT_CVTRDQ_R1 %,
    CVTDH =
	LIB$$CVT_CVTDH_R1 %,
    CVTLH =
	LIB$$CVT_CVTLH_R1 %,
    CVTRHL =
	LIB$$CVT_CVTRHL_R1 %,
    CVTRHO =
	LIB$$CVT_CVTRHO_R1 %,
    CVTRHQ =
	LIB$$CVT_CVTRHQ_R1 %,
    CVTHF =
	LIB$$CVT_CVTHF_R1 %,
    CVTHD =
	LIB$$CVT_CVTHD_R1 %,
    CVTHG =
	LIB$$CVT_CVTHG_R1 %,
    CVTGH =
	LIB$$CVT_CVTGH_R1 %,
    CVTLB =
	LIB$$CVT_CVTLB_R1 %,
    CVTLW =
	LIB$$CVT_CVTLW_R1 %,
    MULH2 =
	LIB$$CVT_MULH2_R1 %,
    DIVH2 =
	LIB$$CVT_DIVH2_R1 %,
    MULD2 =
	LIB$$CVT_MULD2_R1 %,
    DIVD2 =
	LIB$$CVT_DIVD2_R1 %,
    CMPH =
	LIB$$CVT_CMPH_R1 %,
    ASHP =
	LIB$$CVT_ASHP_R1 %,
!+
! These MACROs define parts of the intermediate data buffer.
!-
    LONG_1 =
	0, 0, 32, 0 %,
    LONG_2 =
	4, 0, 32, 0 %,
    LONG_3 =
	8, 0, 32, 0 %,
    LONG_4 =
	12, 0, 32, 0 %,
    LONG_5 =
	16, 0, 32, 0 %,
    LONG_6 =
	20, 0, 32, 0 %,
    LONG_7 =
	24, 0, 32, 0 %,
    LONG_8 =
	28, 0, 32, 0 %,
    S_LONG_1 =
	0, 0, 32, 1 %,
    S_LONG_2 =
	4, 0, 32, 1 %,
    S_BYTE_1 =
	0, 0, 8, 1 %,
    BYTE_1 =
	0, 0, 8, 0 %,
    BYTE_2 =
	1, 0, 8, 0 %,
    S_WORD_1 =
	0, 0, 16, 1 %,
    WORD_1 =
	0, 0, 16, 0 %,
    WORD_2 =
	2, 0, 16, 0 %,
    NIBBLE_1 =
	0, 0, 4, 0 %,
!+
! These MACROs scale the longword in INTMED_DATA buffer.
!-
    M_SCALE_L_L =

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    INTMED_DATA [LONG_1] = .INTMED_DATA [S_LONG_1]*10;
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    INTMED_DATA [LONG_1] = .INTMED_DATA [S_LONG_1]/10;
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert L to OU and scale it.  INTMED_DATA is used for L and OU
!-
    M_SCALE_L_OU =

	IF .INTMED_DATA [S_LONG_1] LSS 0
	THEN
	    BEGIN
	    INTMED_DATA [LONG_1] = ABS (.INTMED_DATA [S_LONG_1]);
	    SRC_INFO [S_SIGN] = 1;
	    END;

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_UP_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert L to D, and scale it.  INTMED_DATA buffer is used for L and D.
!-
    M_SCALE_L_D =
	CVTLD (INTMED_DATA, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert L to P, and scale it.  INTMED_DATA is the buffer for L and P.
!-
    M_SCALE_L_P =

	IF .INTMED_DATA [S_LONG_1] LSS 0 THEN SRC_INFO [S_SIGN] = 1;

	NO_DIGITS = 31;
	CVTLP (INTMED_DATA, NO_DIGITS, INTMED_DATA);

	IF .SCALE NEQ 0
	THEN
	    BEGIN
	    MOVP (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
	    ASHP (SCALE, NO_DIGITS, TEMP_BUF1, %REF (5), NO_DIGITS, INTMED_DATA);
	    END

    %,
!+
! Scale the OU in INTMED_DATA buffer.
!-
    M_SCALE_OU_OU =

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_UP_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert OU to D, and scale it.  INTMED_DATA is used for OU and D.
!-
    M_SCALE_OU_D =
	CVTROUD (INTMED_DATA, TEMP_BUF1);
	CH$MOVE (8, TEMP_BUF1, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert OU to H, and scale it.  INTMED_DATA is used for OU and H.
!-
    M_SCALE_OU_H =
	CVTROUH (INTMED_DATA, TEMP_BUF1);
	CH$MOVE (8, TEMP_BUF1, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert L to H, and scale it.  INTMED_DATA is used for L and H.
!-
    M_SCALE_L_H =
	CVTLH (INTMED_DATA, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Scale D in INTMED_DATA.
!-
    M_SCALE_D_D =

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVD2 (UPLIT (%D'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert D to H, and scale it.  INTMED_DATA is used for D and H.
!-
    M_SCALE_D_H =
	CVTDH (INTMED_DATA, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Scale H in INTMED_DATA.
!-
    M_SCALE_H_H =

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    MULH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    DIVH2 (UPLIT (%H'10'), INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Scale P in INTMED_DATA
!-
    M_SCALE_P_P =
	NO_DIGITS = .SRC_INFO [S_LEN];

	IF (CMPP (NO_DIGITS, INTMED_DATA, %REF (1), .PACK_ZERO) LSS 0) THEN SRC_INFO [S_SIGN] = 1;

	IF .SCALE NEQ 0
	THEN
	    BEGIN
	    MOVP (NO_DIGITS, INTMED_DATA, TEMP_BUF1);
	    ASHP (SCALE, NO_DIGITS, TEMP_BUF1, %REF (5), NO_DIGITS, INTMED_DATA);
	    END

    %,
!+
! Convert P to OU, and scale it.  INTMED_DATA is used for P and OU.
!-
    M_SCALE_P_OU =
	NO_DIGITS = .SRC_INFO [S_LEN];
	CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
	CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
	CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF1;
	OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF2);

	IF .TEMP_BUF2 [0, 15, 1, 0]
	THEN
	    BEGIN
	    TEMP_BUF2 [0, 15, 1, 0] = 0;
	    SRC_INFO [S_SIGN] = 1;
	    END;

	CVTRHO (TEMP_BUF2, INTMED_DATA);

	WHILE .SCALE GTR 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_UP_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE - 1;
	    END;

	WHILE .SCALE LSS 0 DO
	    BEGIN
	    LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 (INTMED_DATA);
	    SCALE = .SCALE + 1;
	    END

    %,
!+
! Convert P to D, and scale it.  INTMED_DATA is used for P and D.
!-
    M_SCALE_P_D =
	NO_DIGITS = .SRC_INFO [S_LEN];
	CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
	CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
	CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF1;
	STATUS = OTS$CVT_T_D (CLASS_S_DESC, INTMED_DATA, 0, .SCALE, (K_ENB_UNDERFLOW OR K_ENB_SCALE));

	IF NOT .STATUS
	THEN
	    RETURN (
		BEGIN

		IF .SCALE LSS 0 THEN LIB$_FLTUND ELSE LIB$_FLTOVF

		END
		) %,

!+
! Convert P to H, and scale it.  INTMED_DATA is used for P and H.
!-
    M_SCALE_P_H =
	NO_DIGITS = .SRC_INFO [S_LEN];
	CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF1);
	CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
	CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF1;
	STATUS = OTS$CVT_T_H (CLASS_S_DESC, INTMED_DATA, 0, .SCALE, (K_ENB_UNDERFLOW OR K_ENB_SCALE));

	IF NOT .STATUS
	THEN
	    RETURN (
		BEGIN

		IF .SCALE LSS 0 THEN LIB$_FLTUND ELSE LIB$_FLTOVF

		END
		) %;

!+
! PSECTS
!-
DECLARE_PSECTS (LIB);				! Declare PSECTs for LIB$ facility
!+
! OWN STORAGE:
!
!	NONE
!-

%SBTTL 'The conversion routine, UPI level'

GLOBAL ROUTINE LIB$CVT_DX_DX (			! The UPI level of the conversion routine.
	SOURCE, 				! Source descriptor.
	DESTINATION, 				! Destination descriptor.
	OUTLEN)					! An output optional parameter.
    =
    BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	Upon entry FIND_CVT_PATH is called to identify which conversion is to be
!	done, i.e. from which CLASS, DTYPE combination to which CLASS, DTYPE
!	combination the conversion is being done.
!	Also, FIND_CVT_PATH will do all the work of identifying the errors such
!	as unsupported class, data type, or combinations.
!	This routine is just a tree of CASE statements that the first
!	level CASE statement labels have been identified by the FIND_CVT_PATH
!	routine.
!
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$CVT_DX_DX ( SOURCE.rx.dx, DESTINATION.wx.dx
!					   <OUTLEN.wwu.r> )
!
! FORMAL PARAMETERS:
!
!	SOURCE			Address of source descriptor.
!	DESTINATION		Address of destination descriptor.
!	OUTLEN			Output length.  Optional parameter for this
!				routine to put the length of actual data (without padding) in.
!				This is used only when destination is of data
!				type T.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS: (or ROUTINE VALUE:)
!
!	SS$_NORMAL	Normal successful completion
!	LIB$_INVCVT	Invalid conversion
!	LIB$_INTOVF	Integer overflow error
!	LIB$_FLTOVF	Floating overflow
!	LIB$_DECOVF	Packed decimal overflow
!	LIB$_FLTUND	Floating underflow
!	LIB$_ROPRAND	Reserved operand
!	LIB$_INVNBDS	Invalid Numeric Byte Data String
!	LIB$_INVCLADSC  Invalid class in descriptor
!	LIB$_INVDTYDSC  Invalid data type in descriptor
!	LIB$_INVCLADTY  Invalid class data type combination in descriptor
!	LIB$_DESSTROVF	Output conversion error
!	LIB$_OUTSTRTRU	Output string truncated
!
! SIDE EFFECTS
!	Every routine in this module turns on every arithmetic trap in PSW.
!	Caller must have LIB$EMULATE as handler
!	if any G, or H conversions are asked for.
!
!+
! LITERAL
!-

    LITERAL
!+
!Status returned by FIND_CVT_PATH.
!-
	K_UNSCLAROU = -1,			! Unsupported CLASS by routine.
	K_UNSDTYROU = -2,			! Unsupported DATA TYPE by routine.
	K_UNSDESROU = -3,			! Unsupported descriptor by routine.
	K_UNSDESSTA = -4,			! Unsupported descriptor by standard.
	K_UNSCLASTA = -5,			! Unsupported CLASS by standard.
	K_UNSDTYSTA = -6,			! Unsupported DTYPE by standard
	K_INVNBDS = -7,				! Invalid NBDS
						! because either array size is larger
						! than a WU or it is not a one
						! dimensional array.
	K_SUPPORTED = 1,			! This descriptor is supported, and valid.
!+
!Literals used by all routines of this module.
!-
	K_INTMED_DATA_LENGTH = 32,		! Intermediate data buffer length
	K_LRGST_WU = 65535,
	K_LRGST_LU = 4294967295,		! Largest unsigned longword.
	K_LRGST_NEG_L = -2147483648,		! Largest negative longword.
!+
! These are the values for the index to the main CASE statement.
!-
	K_SMLINT_SMLINT = 1,
	K_SMLINT_LRGINT = 2,
	K_SMLINT_SMLFLT = 3,
	K_SMLINT_LRGFLT = 4,
	K_SMLINT_DEC = 5,
	K_SMLINT_NBDS = 6,
	K_LRGINT_SMLINT = 7,
	K_LRGINT_LRGINT = 8,
	K_LRGINT_SMLFLT = 9,
	K_LRGINT_LRGFLT = 10,
	K_LRGINT_DEC = 11,
	K_LRGINT_NBDS = 12,
	K_SMLFLT_SMLINT = 13,
	K_SMLFLT_LRGINT = 14,
	K_SMLFLT_SMLFLT = 15,
	K_SMLFLT_LRGFLT = 16,
	K_SMLFLT_DEC = 17,
	K_SMLFLT_NBDS = 18,
	K_LRGFLT_SMLINT = 19,
	K_LRGFLT_LRGINT = 20,
	K_LRGFLT_SMLFLT = 21,
	K_LRGFLT_LRGFLT = 22,
	K_LRGFLT_DEC = 23,
	K_LRGFLT_NBDS = 24,
	K_DEC_SMLINT = 25,
	K_DEC_LRGINT = 26,
	K_DEC_SMLFLT = 27,
	K_DEC_LRGFLT = 28,
	K_DEC_DEC = 29,
	K_DEC_NBDS = 30,
	K_NBDS_SMLINT = 31,
	K_NBDS_LRGINT = 32,
	K_NBDS_SMLFLT = 33,
	K_NBDS_LRGFLT = 34,
	K_NBDS_DEC = 35,
	K_NBDS_NBDS = 36,
!+
! Length of these records in bytes.
!-
	K_SRC_INFO_LENGTH = 8,
	K_DST_INFO_LENGTH = 8,
	K_TEMP_BUF_LENGTH = 50,
!+
! Limits of numbers.
!-
	K_LRGST_NEG_B = -128,
	K_LRGST_NEG_W = -32768,
	K_LRGST_B = 127,
	K_LRGST_W = 32767,
	K_LRGST_BU = 255,
	K_LRGST_L = 2147483647,
	K_PACK_LU_LEN = 10,
!+
! Define bit patterns for calling OTS conversion routines.
!-
	K_IGN_BLKS = 1,
	K_ENB_UNDERFLOW = 4,
	K_IGN_TABS = 16,
	K_ENB_SCALE = 64,
!+
! Bit map to use to set all arithmetic traps
!-
	K_SET_ARITHMETIC_TRAP = 32 + 64 + 128;

!
! BUILTIN
!

    BUILTIN
	CVTTP,
	CVTSP,
	CVTLF,
	CVTLD,
	CVTPT,
	CVTPS,
	CMPP,
	CMPD,
	CVTRDL,
	CVTRFL,
	CVTDF,
	CVTPL,
	CVTLP,
	BICPSW,
	BISPSW,
	TESTBITSC,
	MOVP,
	ACTUALCOUNT,
	ACTUALPARAMETER;

!+
! EXTERNAL REFERENCES:
!-

    EXTERNAL ROUTINE
	LIB$$FIND_CVT_PATH,
	LIB$STOP : NOVALUE,
	OTS$CVT_L_TI,
	OTS$CVT_T_D,
	OTS$CVT_T_G,
	OTS$CVT_T_H,
	FOR$CVT_D_TE,
	FOR$CVT_D_TF,
	FOR$CVT_H_TE,
	FOR$CVT_H_TF,
	LIB$SCOPY_R_DX6 : SCOPYR_JSB_R6,
	LIB$SCOPY_DXDX6 : SCOPY_JSB_R6,
	MTH$CVT_D_G : NOVALUE,
	CVTLB : JSB_R1 NOVALUE,
	CVTLW : JSB_R1 NOVALUE,
	CVTLH : JSB_R1 NOVALUE,
	CVTRHO : JSB_R1 NOVALUE,
	MULH2 : JSB_R1 NOVALUE,
	DIVH2 : JSB_R1 NOVALUE,
	CVTROUD : JSB_R1 NOVALUE,
	CVTROUH : JSB_R1 NOVALUE,
	CVTRDQ : JSB_R1 NOVALUE,
	CVTDH : JSB_R1 NOVALUE,
	CVTRHL : JSB_R1 NOVALUE,
	CVTRHQ : JSB_R1 NOVALUE,
	CVTHF : JSB_R1 NOVALUE,
	CVTHD : JSB_R1 NOVALUE,
	CVTHG : JSB_R1 NOVALUE,
	CVTGH : JSB_R1 NOVALUE,
	CMPH : JSB_RETR0_R1,
	LIB$$CVT_SCALE_OU_UP_BY_10_R1 : JSB_R0 NOVALUE,
	LIB$$CVT_SCALE_OU_DOWN_BY_10_R1 : JSB_R0 NOVALUE,
	MULD2 : JSB_R1 NOVALUE,
	DIVD2 : JSB_R1 NOVALUE,
	ASHP : JSB_R6 NOVALUE;

!+
! These are the translation tables used when translating from or to packed decimal.
!-

    EXTERNAL
	LIB$AB_CVTTP_U,
	LIB$AB_CVT_O_U,
	LIB$AB_CVTTP_O,
	LIB$AB_CVT_U_O,
	LIB$AB_CVTPT_U,
	LIB$AB_CVTPT_O,
	LIB$AB_CVTPT_Z,
	LIB$AB_CVTTP_Z;

!+
! FIELD DECLARATIONS
!-

    FIELD
	SRC_INFO_FIELDS =
	    SET
	    S_SCALE = [0, 0, 8, 1],
	    S_POINTER = [1, 0, 32, 0],
	    S_LEN = [5, 0, 16, 0],
	    S_SIGN = [7, 0, 1, 0]
	    TES;

    FIELD
	DST_INFO_FIELDS =
	    SET
	    D_SCALE = [0, 0, 8, 1],
	    D_LEN = [5, 0, 16, 0]
	    TES;

    LOCAL
!+
!Source information.  LIB$$FIND_CVT_PATH puts source information in this structure.
!-
	SRC_INFO : BLOCK [K_SRC_INFO_LENGTH, BYTE] FIELD (SRC_INFO_FIELDS),
!+
!Destination information.  LIB$$FIND_CVT_PATH puts destination information in this structure.
!-
	DST_INFO : BLOCK [K_DST_INFO_LENGTH, BYTE] FIELD (DST_INFO_FIELDS),
!+
!Intermediate data.  LIB$$FIND_CVT_PATH puts the intermediate data in this buffer.
!-
	INTMED_DATA : BLOCK [K_INTMED_DATA_LENGTH, BYTE],
!+
!Temporary buffer 1.  Used by LIB$CVT_DX_DX to keep temporary data.
!-
	TEMP_BUF1 : BLOCK [K_TEMP_BUF_LENGTH, BYTE],
!+
!Temporary buffer 2.  Used by LIB$CVT_DX_DX to keep temporary data.
!-
	TEMP_BUF2 : BLOCK [K_TEMP_BUF_LENGTH, BYTE],
!+
!Class S descriptor.  A class S descriptor for any use.
!-
	CLASS_S_DESC : BLOCK [8, BYTE],
!+
!Final length.  Length of actual data in TEMP_BUF2.
!-
	FINAL_LEN,
!+
!Convert path.  The convert path calculated by LIB$$FIND_CVT_PATH.
!-
	CVT_PATH,
!+
!Number of digits.  Number of digits of a decimal number.
!-
	NO_DIGITS,
!+
!Digits in fraction.  Used for calling OTS$CVT_x_TE.
!-
	DIGITS_IN_FRACT,
!+
!Various status returned by routines.
!-
	STATUS,
!+
!largest LU in a packed decimal.
!-
	LRGST_P_LU,
!+
!Largest LU in a double floating.
!-
	LRGST_D_LU,
!+
!A zero in a packed decimal.
!-
	PACK_ZERO,
!+
!Largest LU in a H floating.
!-
	LRGST_H_LU,
!+
!This is an offset to the actual data in TEMP_BUF{1 | 2}.
!-
	BUF_OFFSET,
!+
!For simplicity purposes we will set this to be the address of destination data
!-
	OUTPUT,
!+
!Output string length.  The optional parameter to indicate length of actual
!string that has been written to destination.
!-
	OUTPUT_STR_LEN,
!+
!The effective scale.  source scale minus destination scale.
!-
	SCALE;

    MAP
	OUTPUT : REF BLOCK [, BYTE],
	SOURCE : REF BLOCK [, BYTE],
	DESTINATION : REF BLOCK [, BYTE];

!+
! Establish CVT_HANDLER as handler.
!-

    ENABLE
	CVT_HANDLER;

!+
! OUTPUT is used through out the main case statement to indicate the destination
! of the converted data.
!-
    OUTPUT = .DESTINATION [DSC$A_POINTER];
!+
! Zero out these records for LIB$$FIND_CVT_PATH.
!-
    CH$FILL (0, K_SRC_INFO_LENGTH, SRC_INFO);
    CH$FILL (0, K_DST_INFO_LENGTH, DST_INFO);
    CH$FILL (0, K_INTMED_DATA_LENGTH, INTMED_DATA);
    CH$FILL (%C' ', K_TEMP_BUF_LENGTH, TEMP_BUF1);
    CH$FILL (%C' ', K_TEMP_BUF_LENGTH, TEMP_BUF2);
    OUTPUT_STR_LEN = 0;
!+
! This descriptor is always class S, dtype T.
! It is used on various occasions to call routines that require descriptors for
! their parameters.
!-
    CLASS_S_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    CLASS_S_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
!+
! Initialize some constants
!-
    LRGST_P_LU = UPLIT (%P'+4294967295');
    LRGST_D_LU = UPLIT (%D'+4294967295');
    LRGST_H_LU = UPLIT (%H'+4294967295');
    PACK_ZERO = UPLIT (%P'+0');
!+
! SRC_INFO structure will contain the information about the source data, but in
! most cases it points to the INTMED_DATA buffer because the source data is
! usually converted to an intermidiate data, so before calling LIB$$FIND_CVT_PATH we
! will set up the pointer and length fields of SRC_INFO to be INTMED_DATA.
!-
    SRC_INFO [S_POINTER] = INTMED_DATA;
    SRC_INFO [S_LEN] = K_INTMED_DATA_LENGTH;
!+
! This MACRO is used to test out the LIB$$FIND_CVT_PATH routine, so in a working
! module this macro is commented out.
!-
!   M_TEST_LIB$$FIND_CVT_PATH
!+
! Lets call LIB$$FIND_CVT_PATH to get SRC_INFO, and DST_INFO all filled out with information
! about SOURCE and DESTINATION.
! The output parameter CVT_PATH will contain the conversion path when we return.
!-
    STATUS = LIB$$FIND_CVT_PATH (.SOURCE, .DESTINATION, SRC_INFO, DST_INFO, CVT_PATH);
!+
! If we got an error returned to us by LIB$$FIND_CVT_PATH, it means that one of the
! descriptors SOURCE, or DESTINATION was invalid to this routine.
! All errors are negative values.  They are listed in the completion status
! section of LIB$$FIND_CVT_PATH.  Although we get a variety of errors; from -1 to -7
! we will do some overlaping of errors.
!-

    IF .STATUS LSS 0
    THEN
	BEGIN

	CASE .STATUS FROM K_INVNBDS TO K_UNSCLAROU OF
	    SET

	    [K_UNSDTYSTA, K_UNSDTYROU] :
		RETURN (LIB$_INVDTYDSC);

	    [K_UNSCLASTA, K_UNSCLAROU] :
		RETURN (LIB$_INVCLADSC);

	    [K_UNSDESSTA, K_UNSDESROU] :
		RETURN (LIB$_INVCLADTY);

	    [K_INVNBDS] :
		RETURN (LIB$_INVNBDS);
	    TES;

	END;

!+
! Enable all arithmetic traps, and figure out the scale fator to be used by
! the main CASE statement below.
!-
    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
    SCALE = .SRC_INFO [S_SCALE] - .DST_INFO [D_SCALE];
!<BLF/PAGE>

!+
! Now that we have SRC_INFO, and DST_INFO structures, and CVT_PATH available,
! and source data has been converted to an intermediate data, we will
! go from intermediate data that LIB$$FIND_CVT_PATH provided to
! a scale intermediate data type, to the actual data type that our caller desired.
!
! The following explains the objective of the conversions :
!
!	The objective is to convert from intermediate data type provided by
!	LIB$$FIND_CVT_PATH routine to the data type that the user has requested in
!	the destination descriptor.
!
!	The intermediate data is in INTMED_DATA, except for when source is
!	of data type T.  LIB$$FIND_CVT_PATH did not convert or transferred the T
!	data types, so the intermediate data for this data type is described
!	by the SOURCE descriptor itself.
!
!	The first step is to scale the intermediate data.  This scale is
!	calculated as :    SCALE = (source scale) - (destination scale).
!	Scaling cannot always be done on the intermediate data, because
!	it may under/over flow it, so scaling is done on either the intermediate
!	or the higest data type of the category that the destination data type
!	falls in.  The data type with greater range is always selected.
!	Caution is taken not to select a scaling intermediate
!	data type that requires G, H, or O instructions, unless source or
!	destination is of these types.
!	At the beginning of each sub_case statement a macro is placed to go
!	from intermediate data type to scaling intermediate data type.
!	Regardless of whether there is scaling involved or not the intermediate
!	data type is converted to scaling intermediate data type.
!	The scaled intermediate data will again end up in INTMED_DATA buffer.
!
!	Macros that do this scaling are called M_SCALE_x_y which means convert
!	x to y and the result value in y is scaled according to the scale specified
!	in source and destination descriptors.
!
!	The next step is to convert the scaled intermediate data to destination
!	data type and move it to the destination as specified by descriptor.
!	This is done as close to a 'interrupt proof' manner as possible.
!	Since only NBDS can be of semantics other than fixed, only in case of
!	NBDS (or just text) destination is copied to via LIB$SCOPY_x.
!
!	PSW is masked such that IV, FU, DV bits are set.
!
!-

    CASE .CVT_PATH FROM K_SMLINT_SMLINT TO K_NBDS_NBDS OF
	SET
!<BLF/PAGE>


	[K_SMLINT_SMLINT] :
	    BEGIN
	    M_SCALE_L_L;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_BU TO DSC$K_DTYPE_L OF
		SET

		[DSC$K_DTYPE_BU] :
		    BEGIN

		    IF .INTMED_DATA [S_LONG_1] LSS 0 THEN RETURN (LIB$_INVCVT);

		    IF (OUTPUT [BYTE_1] = .INTMED_DATA [LONG_1]) GTRU K_LRGST_BU THEN RETURN (LIB$_INTOVF);

		    END;

		[DSC$K_DTYPE_WU] :
		    BEGIN

		    IF .INTMED_DATA [LONG_1] LSS 0 THEN RETURN (LIB$_INVCVT);

		    IF (OUTPUT [WORD_1] = .INTMED_DATA [S_LONG_1]) GTRU K_LRGST_WU THEN RETURN (LIB$_INTOVF);

		    END;

		[DSC$K_DTYPE_B] :
		    CVTLB (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_W] :
		    CVTLW (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_L] :
		    OUTPUT [LONG_1] = .INTMED_DATA [S_LONG_1];

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLINT_SMLINT

	    END;
!<BLF/PAGE>


	[K_SMLINT_LRGINT, K_LRGINT_LRGINT] :
	    BEGIN

	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_LRGINT] :
		    BEGIN
		    M_SCALE_L_OU;
		    END;

		[K_LRGINT_LRGINT] :
		    BEGIN
		    M_SCALE_OU_OU;
		    END;
		TES;

	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_LU] :
		    BEGIN

		    IF .SRC_INFO [S_SIGN] THEN RETURN (LIB$_INVCVT);

		    IF (.INTMED_DATA [LONG_2] OR .INTMED_DATA [LONG_3] OR .INTMED_DATA [LONG_4]) NEQ 0
		    THEN
			RETURN (LIB$_INTOVF);

		    OUTPUT [LONG_1] = .INTMED_DATA [LONG_1];
		    END;

		[DSC$K_DTYPE_Q] :
		    BEGIN

		    IF (.INTMED_DATA [LONG_3] OR .INTMED_DATA [LONG_4] OR .INTMED_DATA [4, 31, 1, 0]) NEQ 0
		    THEN
			RETURN (LIB$_INTOVF);

		    IF .SRC_INFO [S_SIGN]
		    THEN
			BEGIN
			INTMED_DATA [LONG_1] = .INTMED_DATA [LONG_1] XOR %X'FFFFFFFF';
			INTMED_DATA [LONG_2] = .INTMED_DATA [LONG_2] XOR %X'FFFFFFFF';

			IF .INTMED_DATA [LONG_1] EQLU %X'FFFFFFFF'
			THEN
			    BEGIN
			    INTMED_DATA [LONG_1] = 0;
			    INTMED_DATA [LONG_2] = .INTMED_DATA [LONG_2] + 1;
			    END
			ELSE
			    INTMED_DATA [LONG_1] = .INTMED_DATA [LONG_1] + 1;

			END;

		    OUTPUT [LONG_1] = .INTMED_DATA [LONG_1];
		    OUTPUT [LONG_2] = .INTMED_DATA [LONG_2];
		    END;

		[OTHERWISE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLINT_LRGINT, LRGINT_LRGINT.

	    END;
!<BLF/PAGE>


	[K_SMLINT_SMLFLT, K_LRGINT_SMLFLT, K_SMLFLT_SMLFLT, K_DEC_SMLFLT, K_NBDS_SMLFLT] :
	    BEGIN

	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_SMLFLT] :
		    BEGIN
		    M_SCALE_L_D;
		    END;

		[K_LRGINT_SMLFLT] :
		    BEGIN
		    M_SCALE_OU_D;
		    END;

		[K_SMLFLT_SMLFLT] :
		    BEGIN
		    M_SCALE_D_D;
		    END;

		[K_DEC_SMLFLT] :
		    BEGIN
		    M_SCALE_P_D;
		    END;

		[K_NBDS_SMLFLT] :
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_D (CLASS_S_DESC, INTMED_DATA, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

		    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

		    END;
		TES;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
		SET

		[DSC$K_DTYPE_F] :
		    BEGIN
		    CVTDF (INTMED_DATA, .OUTPUT);

		    IF .SRC_INFO [S_SIGN] THEN OUTPUT [0, 15, 1, 0] = 1;

		    END;

		[DSC$K_DTYPE_D] :
		    BEGIN
		    OUTPUT [LONG_1] = .INTMED_DATA [LONG_1];
		    OUTPUT [LONG_2] = .INTMED_DATA [LONG_2];

		    IF .SRC_INFO [S_SIGN] THEN OUTPUT [0, 15, 1, 0] = 1;

		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;		!For SMLINT_SMLFLT, LRGINT_SMLFLT, SMLFLT_SMLFLT, DEC_SMLFLT, NBDS_SMLFLT.

	    END;
!<BLF/PAGE>


	[K_SMLINT_LRGFLT, K_LRGINT_LRGFLT, K_SMLFLT_LRGFLT, K_LRGFLT_LRGFLT, K_DEC_LRGFLT] :
	    BEGIN

	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_LRGFLT] :
		    BEGIN
		    M_SCALE_L_H;
		    END;

		[K_LRGINT_LRGFLT] :
		    BEGIN
		    M_SCALE_OU_H;
		    END;

		[K_SMLFLT_LRGFLT] :
		    BEGIN
		    M_SCALE_D_H;
		    END;

		[K_LRGFLT_LRGFLT] :
		    BEGIN
		    M_SCALE_H_H;
		    END;

		[K_DEC_LRGFLT] :
		    BEGIN
		    M_SCALE_P_H;
		    END;
		TES;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
		SET

		[DSC$K_DTYPE_G] :
		    BEGIN
		    CVTHG (INTMED_DATA, .OUTPUT);

		    IF .SRC_INFO [S_SIGN] THEN OUTPUT [0, 15, 1, 0] = 1;

		    END;

		[DSC$K_DTYPE_H] :
		    BEGIN
		    CH$MOVE (16, INTMED_DATA, .OUTPUT);

		    IF .SRC_INFO [S_SIGN] THEN OUTPUT [0, 15, 1, 0] = 1;

		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;		!For SMLINT_LRGFLT, LRGINT_LRGFLT, SMLFLT_LRGFLT, LRGFLT_LRGFLT, DEC_LRGFLT.

	    END;
!<BLF/PAGE>


	[K_SMLINT_DEC, K_DEC_DEC] :
	    BEGIN

	    SELECTONE .CVT_PATH OF
		SET

		[K_SMLINT_DEC] :
		    BEGIN
		    M_SCALE_L_P;
		    END;

		[K_DEC_DEC] :
		    BEGIN
		    M_SCALE_P_P;
		    END;
		TES;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_NU TO DSC$K_DTYPE_P OF
		SET

		[DSC$K_DTYPE_NU] :
		    BEGIN

		    IF .SRC_INFO [S_SIGN] THEN RETURN (LIB$_INVCVT);

		    CVTPT (NO_DIGITS, INTMED_DATA, LIB$AB_CVTPT_U, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[DSC$K_DTYPE_NL] :
		    CVTPS (NO_DIGITS, INTMED_DATA,
			%REF (

			    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1)

		    , .OUTPUT);

		[DSC$K_DTYPE_NLO] :
		    BEGIN
		    CVTPT (NO_DIGITS, INTMED_DATA, LIB$AB_CVTPT_U, DESTINATION [DSC$W_LENGTH], TEMP_BUF1);
		    TEMP_BUF1 [BYTE_1] = (IF .SRC_INFO [S_SIGN] THEN .(.TEMP_BUF1 [BYTE_1] + LIB$AB_CVT_U_O -
			48 + 10) ELSE .(.TEMP_BUF1 [BYTE_1] + LIB$AB_CVT_U_O - 48));
		    CH$MOVE (.DESTINATION [DSC$W_LENGTH], TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NR] :
		    BEGIN

		    LOCAL
			DES_LEN;

		    DES_LEN =
		    BEGIN

		    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1

		    END;
		    CVTPS (NO_DIGITS, INTMED_DATA, DES_LEN, TEMP_BUF1);
		    BLOCK [INTMED_DATA + .DES_LEN, 0, 0, 8, 0;, BYTE] = .TEMP_BUF1 [BYTE_1];
		    CH$MOVE (.DES_LEN, TEMP_BUF1 + 1, INTMED_DATA);
		    CH$MOVE (.DES_LEN + 1, INTMED_DATA, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NRO, DSC$K_DTYPE_NZ] :
		    CVTPT (NO_DIGITS, INTMED_DATA,
			(IF .DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_NRO THEN LIB$AB_CVTPT_O ELSE
			    LIB$AB_CVTPT_Z), DESTINATION [DSC$W_LENGTH], .OUTPUT);

		[DSC$K_DTYPE_P] :
		    BEGIN
		    CVTPS (NO_DIGITS, INTMED_DATA, DESTINATION [DSC$W_LENGTH], TEMP_BUF1);
		    CVTSP (DESTINATION [DSC$W_LENGTH], TEMP_BUF1, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLINT_DEC, DEC_DEC

	    END;
!<BLF/PAGE>


	[K_LRGINT_SMLINT] :
	    BEGIN
	    M_SCALE_OU_OU;

	    IF (.INTMED_DATA [LONG_2] OR .INTMED_DATA [LONG_3] OR .INTMED_DATA [LONG_4]) NEQ 0
	    THEN
		RETURN (LIB$_INTOVF);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_BU TO DSC$K_DTYPE_L OF
		SET

		[DSC$K_DTYPE_BU] :
		    BEGIN

		    IF .SRC_INFO [S_SIGN] THEN RETURN (LIB$_INVCVT);

		    IF .INTMED_DATA [BYTE_2] OR .INTMED_DATA [WORD_2] NEQ 0 THEN RETURN (LIB$_INTOVF);

		    OUTPUT [BYTE_1] = .INTMED_DATA [LONG_1];
		    END;

		[DSC$K_DTYPE_WU] :
		    BEGIN

		    IF .SRC_INFO [S_SIGN] THEN RETURN (LIB$_INVCVT);

		    IF .INTMED_DATA [WORD_2] NEQ 0 THEN RETURN (LIB$_INTOVF);

		    OUTPUT [WORD_1] = .INTMED_DATA [LONG_1];
		    END;

		[DSC$K_DTYPE_B] :
		    BEGIN

		    IF .INTMED_DATA [S_LONG_1] LSS 0 THEN RETURN (LIB$_INTOVF);

		    IF .SRC_INFO [S_SIGN] THEN INTMED_DATA [LONG_1] = -.INTMED_DATA [S_LONG_1];

		    CVTLB (INTMED_DATA, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W] :
		    BEGIN

		    IF .INTMED_DATA [S_LONG_1] LSS 0 THEN RETURN (LIB$_INTOVF);

		    IF .SRC_INFO [S_SIGN] THEN INTMED_DATA [LONG_1] = -.INTMED_DATA [S_LONG_1];

		    CVTLW (INTMED_DATA, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L] :
		    BEGIN

		    IF .INTMED_DATA [S_LONG_1] EQL K_LRGST_NEG_L AND .SRC_INFO [S_SIGN] EQL 1
		    THEN
			OUTPUT [LONG_1] = .INTMED_DATA [S_LONG_1]
		    ELSE
			BEGIN

			IF .INTMED_DATA [S_LONG_1] LSS 0 THEN RETURN (LIB$_INTOVF);

			IF .SRC_INFO [S_SIGN] THEN INTMED_DATA [LONG_1] = -.INTMED_DATA [S_LONG_1];

			OUTPUT [LONG_1] = .INTMED_DATA [S_LONG_1];
			END;

		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For LRGINT_SMLINT

	    END;
!<BLF/PAGE>


	[K_LRGINT_DEC, K_SMLFLT_DEC, K_LRGFLT_DEC, K_NBDS_DEC] :
	    BEGIN
	    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
	    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;

	    SELECTONE .CVT_PATH OF
		SET

		[K_LRGINT_DEC] :
		    BEGIN
		    CVTROUH (INTMED_DATA, TEMP_BUF1);

		    IF .SRC_INFO [S_SIGN] THEN TEMP_BUF1<15, 1, 0> = 1;

		    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, 0, .SCALE, 0, 0, 1);
		    END;

		[K_SMLFLT_DEC] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN SRC_INFO [S_SIGN] = 1;

		    STATUS = FOR$CVT_D_TF (INTMED_DATA, CLASS_S_DESC, 0, .SCALE, 0, 0, 1);
		    END;

		[K_LRGFLT_DEC] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN SRC_INFO [S_SIGN] = 1;

		    STATUS = FOR$CVT_H_TF (INTMED_DATA, CLASS_S_DESC, 0, .SCALE, 0, 0, 1);
		    END;

		[K_NBDS_DEC] :
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

		    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

		    IF .TEMP_BUF1<15, 1, 0> THEN SRC_INFO [S_SIGN] = 1;

		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, 0, 0, 0, 0, 1);
		    END;
		TES;

	    IF NOT .STATUS THEN RETURN (LIB$_DECOVF);

	    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
	    NO_DIGITS = K_TEMP_BUF_LENGTH - .BUF_OFFSET - 2;

	    IF .NO_DIGITS GTR 31 THEN RETURN (LIB$_ROPRAND);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_NU TO DSC$K_DTYPE_P OF
		SET

		[DSC$K_DTYPE_NU] :
		    BEGIN

		    IF .SRC_INFO [S_SIGN] THEN RETURN (LIB$_INVCVT);

		    IF .NO_DIGITS GTR .DESTINATION [DSC$W_LENGTH] THEN RETURN (LIB$_DECOVF);

		    CH$FILL (%X'30', .DESTINATION [DSC$W_LENGTH] - .NO_DIGITS, TEMP_BUF1);
		    CH$MOVE (.NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET + 1,
			TEMP_BUF1 + .DESTINATION [DSC$W_LENGTH] - .NO_DIGITS);
		    CH$MOVE (.DESTINATION [DSC$W_LENGTH], TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NL] :
		    BEGIN

		    LOCAL
			DES_LEN;

		    DES_LEN =
		    BEGIN

		    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1

		    END;

		    IF .DES_LEN LSS .NO_DIGITS THEN RETURN (LIB$_DECOVF);

		    CVTSP (NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET, DES_LEN, TEMP_BUF1);
		    CVTPS (DES_LEN, TEMP_BUF1, DES_LEN, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NLO] :
		    BEGIN
		    CH$FILL (%X'30', .BUF_OFFSET + 1, TEMP_BUF2);

		    IF .NO_DIGITS GTR .DESTINATION [DSC$W_LENGTH] THEN RETURN (LIB$_DECOVF);

		    BUF_OFFSET = K_TEMP_BUF_LENGTH - .DESTINATION [DSC$W_LENGTH] - 1;
		    BLOCK [TEMP_BUF2 + .BUF_OFFSET, 0, 0, 8, 0;, BYTE] = (IF .SRC_INFO [S_SIGN] THEN .(.BLOCK
			[TEMP_BUF2 + .BUF_OFFSET, 0, 0, 8, 0;, BYTE] + LIB$AB_CVT_U_O - 48 + 10) ELSE .(
			.BLOCK [TEMP_BUF2 + .BUF_OFFSET, 0, 0, 8, 0;, BYTE] + LIB$AB_CVT_U_O - 48));
		    CH$MOVE (.DESTINATION [DSC$W_LENGTH], TEMP_BUF2 + .BUF_OFFSET, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NR] :
		    BEGIN

		    LOCAL
			DES_LEN;

		    DES_LEN =
		    BEGIN

		    IF .DESTINATION [DSC$W_LENGTH] EQL 0 THEN 0 ELSE .DESTINATION [DSC$W_LENGTH] - 1

		    END;

		    IF .NO_DIGITS GTR .DES_LEN THEN RETURN (LIB$_DECOVF);

		    CH$FILL (%X'30', .DES_LEN - .NO_DIGITS + 1, TEMP_BUF1);
		    CH$MOVE (.NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET + 1, TEMP_BUF1 + .DES_LEN - .NO_DIGITS);
		    BLOCK [TEMP_BUF1 + .DES_LEN, 0, 0, 8, 0;, BYTE] = .BLOCK [TEMP_BUF2 + .BUF_OFFSET, 0,
			0, 8, 0;, BYTE];
		    CH$MOVE (.DES_LEN + 1, TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_NRO, DSC$K_DTYPE_NZ] :
		    BEGIN

		    IF .NO_DIGITS GTR .DESTINATION [DSC$W_LENGTH] THEN RETURN (LIB$_DECOVF);

		    CVTSP (NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET, DESTINATION [DSC$W_LENGTH], TEMP_BUF1);
		    CVTPT (DESTINATION [DSC$W_LENGTH], TEMP_BUF1,
			(IF .DESTINATION [DSC$B_DTYPE] EQL DSC$K_DTYPE_NRO THEN LIB$AB_CVTPT_O ELSE
			    LIB$AB_CVTPT_Z), DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[DSC$K_DTYPE_P] :
		    BEGIN

		    IF .NO_DIGITS GTR 31 THEN RETURN (LIB$_DECOVF);

		    CVTSP (NO_DIGITS, TEMP_BUF2 + .BUF_OFFSET, DESTINATION [DSC$W_LENGTH], .OUTPUT);
		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For LRGINT_DEC, SMLFLT_DEC, LRGFLT_DEC, NBDS_DEC.

	    END;
!<BLF/PAGE>


	[K_SMLINT_NBDS, K_LRGINT_NBDS, K_DEC_NBDS] :

	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT] :
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;

		    IF .SCALE GEQ 0 THEN DIGITS_IN_FRACT = 0 ELSE DIGITS_IN_FRACT = -.SCALE;

		    SELECTONE .CVT_PATH OF
			SET

			[K_SMLINT_NBDS] :
			    BEGIN
			    CVTLD (INTMED_DATA, TEMP_BUF1);
			    STATUS = FOR$CVT_D_TF (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE);
			    END;

			[K_LRGINT_NBDS] :
			    BEGIN
			    CVTROUH (INTMED_DATA, TEMP_BUF1);

			    IF .SRC_INFO [S_SIGN] THEN TEMP_BUF1<15, 1, 0> = 1;

			    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE);
			    END;

			[K_DEC_NBDS] :
			    BEGIN
			    NO_DIGITS = .SRC_INFO [S_LEN];
			    CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF2);
			    CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
			    OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, 0,
				(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS ));
			    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
			    STATUS = FOR$CVT_H_TF (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE);
			    END;
			TES;

		    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
		    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET -
		    BEGIN

		    IF .DIGITS_IN_FRACT EQL 0 THEN 1 ELSE 0

		    END;

		    IF NOT .STATUS
		    THEN
			BEGIN

			IF .DST_INFO [D_LEN] - 9 LEQ 0
			THEN
			    DIGITS_IN_FRACT = 33
			ELSE
			    DIGITS_IN_FRACT = MIN (33, .DST_INFO [D_LEN] - 9);

			STATUS = FOR$CVT_H_TE (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0);

			IF NOT .STATUS THEN RETURN (LIB$_FATERRLIB);

			BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
			FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
			END;

		    OUTPUT_STR_LEN = .FINAL_LEN;
		    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);

		    IF .STATUS EQL LIB$_STRTRU THEN RETURN (LIB$_DESSTROVF);

		    IF NOT .STATUS THEN RETURN (.STATUS);

		    END;

		[OTHERWISE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLINT_NBDS, LRGINT_NBDS, DEC_NBDS

!<BLF/PAGE>


	[K_SMLFLT_SMLINT] :
	    BEGIN
	    M_SCALE_D_D;
	    CVTRDL (INTMED_DATA, TEMP_BUF1);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_BU TO DSC$K_DTYPE_L OF
		SET

		[DSC$K_DTYPE_BU] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_BU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [BYTE_1] = .TEMP_BUF1 [BYTE_1];
		    END;

		[DSC$K_DTYPE_WU] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_WU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [WORD_1] = .TEMP_BUF1 [WORD_1];
		    END;

		[DSC$K_DTYPE_B] :
		    BEGIN
		    CVTLB (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W] :
		    BEGIN
		    CVTLW (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L] :
		    OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1];

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLFLT_SMLINT

	    END;
!<BLF/PAGE>


	[K_SMLFLT_LRGINT] :
	    BEGIN
	    M_SCALE_D_D;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_Q OF
		SET

		[DSC$K_DTYPE_LU] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF CMPD (INTMED_DATA, .LRGST_D_LU) GTR 0 THEN RETURN (LIB$_INTOVF);

		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    CVTRDL (INTMED_DATA, .OUTPUT);
		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q] :
		    CVTRDQ (INTMED_DATA, .OUTPUT);

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLFLT_LRGINT

	    END;
!<BLF/PAGE>


	[K_SMLFLT_NBDS] :

	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT] :
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    DIGITS_IN_FRACT =
		    BEGIN

		    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
			SET

			[DSC$K_DTYPE_F] :
			    7;

			[DSC$K_DTYPE_D] :
			    16;
			TES

		    END;

		    IF .DST_INFO [D_LEN] - 7 GTR 0
		    THEN
			DIGITS_IN_FRACT = MIN (.DIGITS_IN_FRACT,
			    .DST_INFO [D_LEN] - 7);

		    STATUS = FOR$CVT_D_TE (INTMED_DATA, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0);

		    IF NOT .STATUS THEN RETURN (LIB$_FATERRLIB);

		    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
		    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
		    OUTPUT_STR_LEN = .FINAL_LEN;
		    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);

		    IF .STATUS EQL LIB$_STRTRU THEN RETURN (LIB$_DESSTROVF);

		    IF NOT .STATUS THEN RETURN (.STATUS);

		    END;

		[OTHERWISE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For SMLFLT_NBDS

!<BLF/PAGE>


	[K_LRGFLT_SMLINT] :
	    BEGIN
	    M_SCALE_H_H;
	    CVTRHL (INTMED_DATA, TEMP_BUF1);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_BU TO DSC$K_DTYPE_L OF
		SET

		[DSC$K_DTYPE_BU] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_BU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [BYTE_1] = .TEMP_BUF1 [BYTE_1];
		    END;

		[DSC$K_DTYPE_WU] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_WU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [WORD_1] = .TEMP_BUF1 [WORD_1];
		    END;

		[DSC$K_DTYPE_B] :
		    BEGIN
		    CVTLB (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W] :
		    BEGIN
		    CVTLW (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L] :
		    OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1];

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For LRGFLT_SMLINT

	    END;
!<BLF/PAGE>


	[K_LRGFLT_LRGINT] :
	    BEGIN
	    M_SCALE_H_H;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_Q OF
		SET

		[DSC$K_DTYPE_LU] :
		    BEGIN

		    IF .INTMED_DATA<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF CMPH (INTMED_DATA, .LRGST_H_LU) GTR 0 THEN RETURN (LIB$_INTOVF);

		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    CVTRHL (INTMED_DATA, .OUTPUT);
		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q] :
		    CVTRHQ (INTMED_DATA, .OUTPUT);

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For LRGFLT_LRGINT

	    END;
!<BLF/PAGE>


	[K_LRGFLT_SMLFLT] :
	    BEGIN
	    M_SCALE_H_H;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
		SET

		[DSC$K_DTYPE_F] :
		    CVTHF (INTMED_DATA, .OUTPUT);

		[DSC$K_DTYPE_D] :
		    CVTHD (INTMED_DATA, .OUTPUT);

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For LRGFLT_SMLFLT

	    END;
!<BLF/PAGE>


	[K_LRGFLT_NBDS] :

	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT] :
		    BEGIN

		    LOCAL
			NOT_DIGITS_IN_FRACT;

		    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    DIGITS_IN_FRACT =
		    BEGIN

		    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
			SET

			[DSC$K_DTYPE_G] :
			    15;

			[DSC$K_DTYPE_H] :
			    33;
			TES

		    END;
		    NOT_DIGITS_IN_FRACT =
		    BEGIN

		    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
			SET

			[DSC$K_DTYPE_G] :
			    7;

			[DSC$K_DTYPE_H] :
			    8;
			TES

		    END;

		    IF .DST_INFO [D_LEN] - .NOT_DIGITS_IN_FRACT GTR 0
		    THEN
			DIGITS_IN_FRACT = MIN (.DIGITS_IN_FRACT,
			    .DST_INFO [D_LEN] - .NOT_DIGITS_IN_FRACT);

		    STATUS = FOR$CVT_H_TE (INTMED_DATA, CLASS_S_DESC, .DIGITS_IN_FRACT, .SCALE, 0);

		    IF NOT .STATUS THEN RETURN (LIB$_FATERRLIB);

		    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
		    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
		    OUTPUT_STR_LEN = .FINAL_LEN;
		    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);

		    IF .STATUS EQL LIB$_STRTRU THEN RETURN (LIB$_DESSTROVF);

		    IF NOT .STATUS THEN RETURN (.STATUS);

		    END;

		[OTHERWISE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For LRGFLT_NBDS

!<BLF/PAGE>


	[K_DEC_SMLINT] :
	    BEGIN
	    M_SCALE_P_P;
	    CVTPL (NO_DIGITS, INTMED_DATA, TEMP_BUF1);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_BU TO DSC$K_DTYPE_L OF
		SET

		[DSC$K_DTYPE_BU] :
		    BEGIN

		    IF .TEMP_BUF1 [S_LONG_1] LSS 0 THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_BU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [BYTE_1] = .TEMP_BUF1 [BYTE_1]
		    END;

		[DSC$K_DTYPE_WU] :
		    BEGIN

		    IF .TEMP_BUF1 [S_LONG_1] LSS 0 THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF1 [LONG_1] GTRU K_LRGST_WU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [WORD_1] = .TEMP_BUF1 [WORD_1]
		    END;

		[DSC$K_DTYPE_B] :
		    BEGIN
		    CVTLB (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W] :
		    BEGIN
		    CVTLW (TEMP_BUF1, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L] :
		    OUTPUT [LONG_1] = .TEMP_BUF1 [S_LONG_1];

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For DEC_SMLINT

	    END;
!<BLF/PAGE>


	[K_DEC_LRGINT] :
	    BEGIN
	    M_SCALE_P_P;

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_Q OF
		SET

		[DSC$K_DTYPE_LU] :
		    BEGIN

		    IF .SRC_INFO [S_SIGN] THEN RETURN (LIB$_INVCVT);

		    IF (CMPP (NO_DIGITS, INTMED_DATA, %REF (K_PACK_LU_LEN), .LRGST_P_LU) GEQ 0)
		    THEN
			RETURN (LIB$_INTOVF);

		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    CVTPL (NO_DIGITS, INTMED_DATA, .OUTPUT);
		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q] :
		    BEGIN
		    CVTPS (NO_DIGITS, INTMED_DATA, NO_DIGITS, TEMP_BUF2);
		    CLASS_S_DESC [DSC$W_LENGTH] = .NO_DIGITS + 1;
		    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;
		    OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1);
		    CVTRHQ (TEMP_BUF1, .OUTPUT);
		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For DEC_LRGINT

	    END;
!<BLF/PAGE>


	[K_NBDS_SMLINT] :
	    BEGIN
	    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
	    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
	    STATUS = OTS$CVT_T_D (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
		(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

	    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

	    CVTRDL (TEMP_BUF1, TEMP_BUF2);

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_BU TO DSC$K_DTYPE_L OF
		SET

		[DSC$K_DTYPE_BU] :
		    BEGIN

		    IF .TEMP_BUF2 [S_LONG_1] LSS 0 THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF2 [LONG_1] GTRU K_LRGST_BU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [BYTE_1] = .TEMP_BUF2 [BYTE_1];
		    END;

		[DSC$K_DTYPE_WU] :
		    BEGIN

		    IF .TEMP_BUF2 [S_LONG_1] LSS 0 THEN RETURN (LIB$_INVCVT);

		    IF .TEMP_BUF2 [LONG_1] GTRU K_LRGST_WU THEN RETURN (LIB$_INTOVF);

		    OUTPUT [WORD_1] = .TEMP_BUF2 [WORD_1];
		    END;

		[DSC$K_DTYPE_B] :
		    BEGIN
		    CVTLB (TEMP_BUF2, .OUTPUT);
		    END;

		[DSC$K_DTYPE_W] :
		    BEGIN
		    CVTLW (TEMP_BUF2, .OUTPUT);
		    END;

		[DSC$K_DTYPE_L] :
		    BEGIN
		    OUTPUT [LONG_1] = .TEMP_BUF2 [S_LONG_1];
		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For NBDS_SMLINT

	    END;
!<BLF/PAGE>


	[K_NBDS_LRGINT] :

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_LU TO DSC$K_DTYPE_Q OF
		SET

		[DSC$K_DTYPE_LU] :
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_D (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

		    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

		    IF .TEMP_BUF1<15, 1, 0> THEN RETURN (LIB$_INVCVT);

		    IF CMPD (TEMP_BUF1, .LRGST_D_LU) GTR 0 THEN RETURN (LIB$_INTOVF);

		    BICPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    CVTRDL (TEMP_BUF1, .OUTPUT);
		    BISPSW (%REF (K_SET_ARITHMETIC_TRAP));
		    END;

		[DSC$K_DTYPE_Q] :
		    BEGIN
		    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
		    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
		    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

		    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

		    CVTRHQ (TEMP_BUF1, .OUTPUT);
		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For NBDS_LRGINT

!<BLF/PAGE>


	[K_NBDS_LRGFLT] :
	    BEGIN
	    CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
	    CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];

	    CASE .DESTINATION [DSC$B_DTYPE] FROM DSC$K_DTYPE_G TO DSC$K_DTYPE_H OF
		SET

		[DSC$K_DTYPE_G] :
		    BEGIN
		    STATUS = OTS$CVT_T_G (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

		    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

		    OUTPUT [LONG_1] = .TEMP_BUF1 [LONG_1];
		    OUTPUT [LONG_2] = .TEMP_BUF1 [LONG_2];
		    END;

		[DSC$K_DTYPE_H] :
		    BEGIN
		    STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			(K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

		    IF NOT .STATUS THEN RETURN (LIB$_INVNBDS);

		    CH$MOVE (16, TEMP_BUF1, .OUTPUT);
		    END;

		[INRANGE, OUTRANGE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For NBDS_LRGFLT

	    END;
!<BLF/PAGE>


	[K_NBDS_NBDS] :

	    SELECTONE .DESTINATION [DSC$B_DTYPE] OF
		SET

		[DSC$K_DTYPE_BU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT] :
		    BEGIN

		    IF .SCALE NEQ 0
		    THEN
			BEGIN
			CLASS_S_DESC [DSC$W_LENGTH] = .SRC_INFO [S_LEN];
			CLASS_S_DESC [DSC$A_POINTER] = .SRC_INFO [S_POINTER];
			STATUS = OTS$CVT_T_H (CLASS_S_DESC, TEMP_BUF1, 0, -.SCALE,
			    (K_IGN_BLKS OR K_ENB_UNDERFLOW OR K_IGN_TABS OR K_ENB_SCALE));

			IF .STATUS
			THEN
			    BEGIN
			    CLASS_S_DESC [DSC$W_LENGTH] = K_TEMP_BUF_LENGTH;
			    CLASS_S_DESC [DSC$A_POINTER] = TEMP_BUF2;

			    IF .DST_INFO [D_LEN] - 9 LEQ 0
			    THEN
				DIGITS_IN_FRACT = 33
			    ELSE
				DIGITS_IN_FRACT = MIN (33, .DST_INFO [D_LEN] - 9);

			    STATUS = FOR$CVT_H_TE (TEMP_BUF1, CLASS_S_DESC, .DIGITS_IN_FRACT);

			    IF NOT .STATUS THEN RETURN (LIB$_FATERRLIB);

			    BUF_OFFSET = CH$FIND_NOT_CH (K_TEMP_BUF_LENGTH, TEMP_BUF2, %C' ') - TEMP_BUF2;
			    FINAL_LEN = K_TEMP_BUF_LENGTH - .BUF_OFFSET;
			    OUTPUT_STR_LEN = .FINAL_LEN;
			    STATUS = LIB$SCOPY_R_DX6 (.FINAL_LEN, TEMP_BUF2 + .BUF_OFFSET, .DESTINATION);

			    IF .STATUS EQL LIB$_STRTRU THEN RETURN (LIB$_OUTSTRTRU);

			    IF NOT .STATUS THEN RETURN (.STATUS);

			    END
			ELSE
			    RETURN (LIB$_INVNBDS);

			END
		    ELSE
			BEGIN
			OUTPUT_STR_LEN = .SOURCE [DSC$W_LENGTH];
			STATUS = LIB$SCOPY_DXDX6 (.SOURCE, .DESTINATION);

			IF .STATUS EQL LIB$_STRTRU THEN RETURN (LIB$_OUTSTRTRU);

			IF NOT .STATUS THEN RETURN (.STATUS);

			END;

		    END;

		[OTHERWISE] :
		    RETURN (LIB$_FATERRLIB);
		TES;				!For NBDS_NBDS

	TES;					!End of the main CASE statement.

!+
! If output string length is requested then supply it.
!-

    IF ACTUALCOUNT () GTR 2 THEN (.OUTLEN)<0, 16, 0> = .OUTPUT_STR_LEN;

!<BLF/PAGE>

    RETURN (SS$_NORMAL);
    END;					! End of routine LIB$CVT_DX_DX.

!<BLF/PAGE>


%SBTTL 'The error handler for conversion routine'
ROUTINE CVT_HANDLER (				! Conversion routine's handler
	SIG					! Signal arguments.
    , MECH					! Mechanism arguments.
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This handler will resignal opcode reserved to digital and call
!	LIB$SIG_TO_RET for every other case.
!
! FORMAL PARAMETERS:
!
!	SIG_rr.r	A counted vector of parameters describing the condition.
!	MECH.rr.r	A counted vector of parameters from CHF.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS: (or ROUTINE VALUE:)
!
!	SS$_RESIGNAL when opcode reserved to digital exception, any other case
!	will result in an unwind to the caller of establisher with R0 containing
!	the condition value.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    EXTERNAL ROUTINE
	LIB$SIG_TO_RET : NOVALUE,
	LIB$MATCH_COND;

    MAP
	SIG : REF VECTOR,
	MECH : REF VECTOR;

!+
!Call LIB$SIG_TO_RET if this is not an UNWIND, or opcode reserved to digital.
!Otherwise resignal.  If caller of LIB$CVT_DX_DX has LIB$EMULATE then it will
!be given the chance to handle the fault.  In case of UNWIND the SS$_RESIGNAL
!is of course ignored.
!-

    IF (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND), %REF (SS$_OPCDEC))) GTR 0 THEN RETURN (SS$_RESIGNAL);

!+
!Translate all numeric exceptions to this facility's code.
!Also, translate SS$_ROPRAND to LIB$_ROPRAND.
!-
    SIG [1] = (SELECTONE .SIG [1] OF
	SET
	[SS$_INTOVF] : LIB$_INTOVF;
	[SS$_DECOVF] : LIB$_DECOVF;
	[SS$_FLTOVF, SS$_FLTOVF_F] : LIB$_FLTOVF;
	[SS$_FLTUND, SS$_FLTUND_F] : LIB$_FLTUND;
	[SS$_ROPRAND] : LIB$_ROPRAND;
	[OTHERWISE] : .SIG [1];
	TES);
    LIB$SIG_TO_RET (.SIG, .MECH);
    RETURN 1;					! Never gets here.
    END;					! End of CVT_HANDLER
END						! End of module LIB$CVTDXDX.

ELUDOM
