MODULE FOR$$REC_PROC (				! Record processing level of abstraction
		IDENT = '1-029'			! file: FORRECPRO.B32  Edit: JAW1029
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: FORTRAN Support Library - not user callable
!
! ABSTRACT:
!
!	This module implements the record processing level of
!	abstraction which is the 3rd level and is called only from
!	the user data formatter level (2nd level) when the user
!	portion of a record buffer is full (WRITE) or empty
!	(READ). This module adds any per record formatting (as
!	distinguished from per I/O statement or per I/O list element
!	formatting) and then calls RMS ($PUT or $GET). RMS errors
!	are converted to FORTRAN errors and are signaled.
!
! ENVIRONMENT:	User access mode; AST level or not.
!
! AUTHOR:	Thomas N. Hastings;	CREATION DATE: 16-Mar-77
!
! MODIFIED BY:
!
!         Previous edit history deleted.  SBL 18-July-1980
! 1-001	- Update version number and copyright notice.  JBS 16-NOV-78
! 1-002	- Change REQUIRE file names from FOR... to OTS...  JBS 06-DEC-78
! 1-003 - Change ISB$A_BUF_PTR, BUF_BEG, BUF_END, BUF_HIGH to LUB. DGP 08-Jan-79
! 1-004 - Always set RAB$W_RSZ before $PUT.  SPR 22044 SBL 31-Jan-79
! 1-005 - For sequential read, set access mode to SEQ.  For sequential
!	  write, set to KEY if ACCESS='KEYED', SEQ otherwise.  SBL 10-Apr-79
! 1-006 - Change dispatch table so that direct "1" level is the same as
!	  "0" level.  This is because we now allow more than one record
!	  on direct I/O.  SBL 25-Apr-1979
! 1-007 - Clear RAB$V_UIF if sequential or keyed write.  SBL 2-May-1979
! 1-008 - Add REC level definitions for keyed read.  SBL 2-May-1979
! 1-009 - Change FOR$K_TARRECLOC to FOR$K_SPERECLOC.  SBL 8-May-1979
! 1-010 - Add REWRITE.  SBL 14-May-1979
! 1-011 - Clear LUB$V_FIND_LAST on direct access.  SBL 15-May-1979
! 1-012 - Add internal file entry points.
! 1-013 - Remove initial space from REC_WSL, transferred to UDF level.
!	  Make list directed record length 80 instead of 72.  SBL 26-Jun-1979
! 1-014 - Check for ISB$V_LAST_REC set in FOR$$REC_RSU1 to catch reading
!	  too much data.  SPR 22-25598  SBL 17-Aug-1979
! 1-015 - Change FOR$K_MORONEREC to FOR$K_TOOMANREC.  SBL 21-Sept-1979
! 1-016	- Change FOR$K_ATTREANON to FOR$K_ATTACCNON.  JBS 24-SEP-1979
! 1-017 - Use LUB$W_R_MARGIN for list directed output width.  SBL 4-Oct-1979
! 1-018 - Give FOR$_SPERECLOC on read errors.  SBL 12-Oct-1979
! 1-019 - Use LUB$W_R_MARGIN as list directed output record length.  SBL 1-Nov-1979
! ***** - VAX/VMS V2.0
! 1-020 - Add support for NAMELIST.  SBL 18-July-1980
! 1-021 - If fixed length records, blank fill list directed output records.
!	  SBL 27-August-1980
! 1-022 - Create separate routines FOR$$REC_WSN0 and FOR$$REC_WSN1 for
!	  NAMELIST.  They require unique code not found in WSFx.  SBL 4-September-1980
! 1-023 - Only check for ENDFILE record on segmented or formatted sequential
!	  organization/access files.  SBL 29-Sept-1980
! 1-024 - Don't write leading space in FOR$$REC_WSN0.  The UDF routine will do it.  SBL 21-Oct-1980
! 1-025 - Define FOR$$REC_WSL9 as FOR$$REC_WSL1 rather than FOR$$REC_WSF1.  This
!	  is so that edit 1-021 works for end-of-statement.  SBL 5-Nov-1980
! 1-026 - Make sure ENDFILE record gets counted before signaling FOR$K_ENDDURREA
!	  in FOR$$REC_RSF0, so backspace will work correctly.  JAW 24-Feb-1981
! 1-027 - Implement unbuffered transfers for single-element I/O lists:
!	  If ISB$V_SNGL_ELEM is set, do not change RAB$L_RBF and
!	  RAB$W_RSZ, which have been set at UDF level.  JAW 06-May-1981
! 1-028 - Continuation of 1-027.  Support recordtype=variable.  JAW
!	  02-Jun-1981
! 1-029 - Check for fixed-length records in FOR$$REC_WD9 before padding
!	  them.  Also, be sure first byte, or first two bytes, of record
!	  read in FOR$$REC_RSF0 and FOR$$REC_RSU0 exist before testing
!	  their contents.  JAW 06-Jun-1981
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';				! define all linkages

!
! TABLE OF CONTENTS:
!
! write sequential formatted:

FORWARD ROUTINE
    FOR$$REC_WSF0 : JSB_REC0 NOVALUE,		! initialize output buffer
    FOR$$REC_WSF1 : JSB_REC1 NOVALUE;		! write all but last record

GLOBAL BIND
    ROUTINE
    FOR$$REC_WSF9 = FOR$$REC_WSF1;		! Write next = write last

! read sequential formatted:

FORWARD ROUTINE
    FOR$$REC_RSF0 : JSB_REC0 NOVALUE;		! read first record

GLOBAL BIND
    ROUTINE
    FOR$$REC_RSF1 = FOR$$REC_RSF0;		! Read first = read next

FORWARD ROUTINE
    FOR$$REC_RSF9 : JSB_REC9 NOVALUE,		! no-op
    ! read sequential unformatted record
    FOR$$REC_RSU0 : JSB_REC0 NOVALUE,		! read first record
    FOR$$REC_RSU1 : JSB_REC1 NOVALUE,		! read all subsequent records
    FOR$$REC_RSU9 : JSB_REC9 NOVALUE,		! terminate read
    ! write sequential unformatted record:
    FOR$$REC_WSU0 : JSB_REC0 NOVALUE,		! initialize output buffer
    FOR$$REC_WSU1 : JSB_REC1 NOVALUE,		! write all but last record
    FOR$$REC_WSU9 : JSB_REC9 NOVALUE,		! write last record
    ! write direct (formatted and unformatted):
    FOR$$REC_WD0 : JSB_REC0 NOVALUE,		! initialize output buffer
    FOR$$REC_WD1 : JSB_REC1 NOVALUE,		! write next record
    FOR$$REC_WD9 : JSB_REC9 NOVALUE,		! write last record
    ! read direct (formatted and unformatted):
    FOR$$REC_RD0 : JSB_REC0 NOVALUE;		! read first record

GLOBAL BIND
    ROUTINE
    FOR$$REC_RD1 = FOR$$REC_RD0,		! next record = first record
    FOR$$REC_RD9 = FOR$$REC_RSF9;		! no-op

! write sequential list-directed

FORWARD ROUTINE
    FOR$$REC_WSL0 : JSB_REC0 NOVALUE,		! initialize output buffer
    FOR$$REC_WSL1 : JSB_REC1 NOVALUE;		! write all but last record

GLOBAL BIND
    ROUTINE
    FOR$$REC_WSL9 = FOR$$REC_WSF1,		! write last = write last formatted sequential
    ! read sequential list-directed
    FOR$$REC_RSL0 = FOR$$REC_RSF0,		! read first = read first sequential formatted
    FOR$$REC_RSL1 = FOR$$REC_RSF1,		! read next = read next sequential formatted
    FOR$$REC_RSL9 = FOR$$REC_RSF9,		! no-op
    ! read memory formatted (DECODE)
    FOR$$REC_RMF0 = FOR$$REC_RSF9;		! no-op

FORWARD ROUTINE
    FOR$$REC_RMF1 : JSB_REC1 NOVALUE;		! illegal: FOR$_TOOMANREC

GLOBAL BIND
    ROUTINE
    FOR$$REC_RMF9 = FOR$$REC_RSF9,		! no-op
    ! write memory formatted (ENCODE)
    FOR$$REC_WMF0 = FOR$$REC_RSF9,		! no-op
    FOR$$REC_WMF1 = FOR$$REC_RMF1;		! illegal: FOR$_TOOMANREC

FORWARD ROUTINE
    FOR$$REC_WMF9 : JSB_REC9 NOVALUE,		! terminate write (blank pad)
    FOR$$REC_WIF0 : JSB_REC0 NOVALUE,		! Internal file write
    FOR$$REC_WIF1 : JSB_REC1 NOVALUE;		!

GLOBAL BIND
    ROUTINE
    FOR$$REC_WIF9 = FOR$$REC_WMF9,		! Terminate internal write
    FOR$$REC_RIF0 = FOR$$REC_WIF0,		! Internal file read
    FOR$$REC_RIF1 = FOR$$REC_WIF1,		!
    FOR$$REC_RIF9 = FOR$$REC_RSF9;		! No-op

FORWARD ROUTINE
    FOR$$REC_RKF0 : JSB_REC0 NOVALUE;		! keyed read

GLOBAL BIND
    ROUTINE
    FOR$$REC_RKF1 = FOR$$REC_RSF0,		! 2nd and after like sequential
    FOR$$REC_RKF9 = FOR$$REC_RSF9,		! No-op
    FOR$$REC_RKU0 = FOR$$REC_RKF0,		! Keyed unformatted read
    FOR$$REC_RKU1 = FOR$$REC_RSU1,		! Will be an error
    FOR$$REC_RKU9 = FOR$$REC_RSF9,		! No-op
    FOR$$REC_WXF0 = FOR$$REC_WSF0,		! Indexed rewrite
    FOR$$REC_WXF1 = FOR$$REC_RMF1;		! Error

FORWARD ROUTINE
    FOR$$REC_WXF9 : JSB_REC9 NOVALUE;		! Rewrite the record

GLOBAL BIND
    ROUTINE
    FOR$$REC_WXU0 = FOR$$REC_WSU0,		! Rewrite indexed unformatted
    FOR$$REC_WXU1 = FOR$$REC_RMF1,		! Error
    FOR$$REC_WXU9 = FOR$$REC_WXF9;		!

FORWARD ROUTINE
    FOR$$REC_WSN0 : JSB_REC0 NOVALUE,		! Write sequential NAMELIST
    FOR$$REC_WSN1 : JSB_REC1 NOVALUE;

GLOBAL BIND
    FOR$$REC_RSN0 = FOR$$REC_RSF0,		! Read sequential NAMELIST
    FOR$$REC_RSN1 = FOR$$REC_RSF1;

FORWARD ROUTINE
    FILL_BUF : CALL_CCB NOVALUE,		! fill remainder of buffer with arg
    PUT_ERROR : CALL_CCB NOVALUE,		! error in $PUT
    GET_ERROR : CALL_CCB NOVALUE;		! error in $GET

!
! INCLUDE FILES:
!

REQUIRE 'RTLML:FORERR';				! FORTRAN error number definitions

REQUIRE 'RTLML:OTSISB';				! I/O statement block (ISB) offsets

REQUIRE 'RTLML:OTSLUB';				! Logical unit block (LUB) offsets

REQUIRE 'RTLIN:OTSMAC';				! Macros

REQUIRE 'RTLIN:RTLPSECT';			! Define DELCARE_PSECTS macro

REQUIRE 'RTLML:FORPAR';				! FORTRAN inter-module parameters

LIBRARY 'RTLSTARLE';				! STARLET library for macros and symbols

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (FOR);				! declare PSECTs for FOR$ facility
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    FOR$$SIGNAL_STO : NOVALUE,			! Convert FORTRAN err # to VAX
    						! err # and call LIB$STOP.
    FOR$$ASSOC : CALL_CCB NOVALUE;		! store rec# in ass. var.


GLOBAL ROUTINE FOR$$REC_WSF0 			! Write sequential formatted
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize call for write sequential formatted.  FOR$$REC_WSF0
!	initializes the output buffer and returns start and end+1 of user
! 	part of record buffer to be filled by caller.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSF0 ()
!
! FORMAL PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		points to first char in user part of record
!				buffer
!	LUB$A_BUF_END		points to last char+1 in user part
!				of record buffer
!
!	RAB$B_RAC		Set to correct access mode.
!	RAB$V_UIF		Cleared if keyed access.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Return start address and end+1 address of output buffer.
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];

    !+
    ! If user opened with ACCESS='KEYED', then set access mode
    ! to KEYED and clear RAB$V_UIF else set access to sequential.
    !-

    IF .CCB [LUB$V_KEYED]
    THEN
	BEGIN
	CCB [RAB$B_RAC] = RAB$C_KEY;
	CCB [RAB$V_UIF] = 0;
	END
    ELSE
	CCB [RAB$B_RAC] = RAB$C_SEQ;

    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE FOR$$REC_WSF1 			! Write sequential formatted
    ! (also FOR$$REC_WSF9 and FOR$$REC_WSL9)
    ! Called from FOR$$REC_WSU9
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one sequential formatted record and initialize for the next
!	FOR$$REC_WSF1 (and FOR$$REC_WSF9) writes one output buffer and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!	FLR records are space or null padded.
!	Logical record number is incremented.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSF1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!	LUB$A_BUF_END		points to last char inserted into buffer
!				by UDF level I/O.
!	ISB$V_SNGL_ELEM		Flag indicating that RAB$W_RSZ and
!				RAB$L_RBF have been set up at UDF level
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_LOG_RECNO		Incremented logical record number
!	LUB$A_BUF_PTR		Address of first char in user part
!				of record buffer
!	LUB$A_BUF_END		Address of last+1 char in user part
!				of record buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If this is a buffered transfer (ISB$V_SNGL_ELEM = 0), then set up
    ! RAB$W_RSZ and RAB$L_RBF to point to the record buffer.  Otherwise
    ! they have already been set up at UDF level to point to an element.
    !-

    IF NOT .CCB [ISB$V_SNGL_ELEM]
    THEN
	BEGIN

	!+
	! If fixed length records (FLR), pad with trailing spaces or
	! nulls, depending on whether formatted or unformatted.  Set
	! recordsize to actual length of record.
	!-

	IF .CCB [LUB$V_FIXED]
	THEN
	    BEGIN
	    CCB [RAB$W_RSZ] = .CCB [LUB$W_RBUF_SIZE];	! Always set RSZ

	    IF .CCB [LUB$A_BUF_PTR] LSSA .CCB [LUB$A_BUF_END]
	    THEN
		FILL_BUF (

		    IF .CCB [LUB$V_UNFORMAT] THEN 0 ELSE %C' ')

	    END
	ELSE
	    CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_RBUF_ADR];
	CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];
	END;

    !+
    ! Output buffer to RMS and check for errors
    ! If errors, SIGNAL_STO FOR$_ERRDURWRI (38='ERROR DURING WRITE')
    !-

    IF NOT $PUT (RAB = .CCB) THEN PUT_ERROR ();

    !+
    ! increment logical record number (for backspace) after
    ! successfully writing current record number.
    !-

    IF NOT .CCB [LUB$V_KEYED] THEN CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] + 1;

    !+
    ! Return next output buffer start and end addresses
    ! If fixed length, use just record size, else buffer size.
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE FOR$$REC_RSF0 			! Read sequential formatted
    ! (also FOR$$REC_RSF1, FOR$$REC_RSL0 and FOR$$REC_RSL1)
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_RSF0 (and FOR$$REC_RSF1) reads one formatted sequential record.
!	Increments logical record number after successful read.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RSF0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_LOG_RECNO		Increment logical record number
!				of next record to be read.
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!	RAB$W_RSZ		set to read record length, or ZERO
!				if error.
!
!	RAB$B_RAC		set to sequential access mode
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNAL_STOPs FOR$_ERRDURREA (39='ERROR DURING READ')
!	SIGNAL_STOPs FOR$_ENDDURREA (24='END-OF-FILE DURING READ')
!	SIGNAL_STOPs FOR$_INPRECTOO if record too big
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Read record into buffer using RMS and check for erros
    ! If end-of-file, SIGNAL_STOP FOR$_ENDDURREA (24='END-OF-FILE DURING READ')
    ! If record too big for record buffer, SIGNAL_STOP FOR$_INPRECTOO.
    ! If errors, SIGNAL_STO FOR$_ERRDURREA (39='ERROR DURING READ')
    !-

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    IF NOT $GET (RAB = .CCB) THEN GET_ERROR ();

    !+
    ! Increment logical record number (for backspace)
    ! so it is the number of the next record to be read.
    !-

    IF NOT .CCB [LUB$V_KEYED] THEN CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] + 1;

    !+
    ! Check for End-of-file record in sequential organization files.
    ! Length = 1 byte and byte is a control Z.
    ! SIGNAL_STOP FOR$_ENDDURREA if so.
    !-

    IF NOT .CCB [LUB$V_NOTSEQORG]
    THEN
	IF .CCB [RAB$W_RSZ] EQLU 1
	THEN
	    IF .(.CCB [RAB$L_RBF])<0, 8> EQLU FOR$K_CONTROL_Z
	    THEN
		FOR$$SIGNAL_STO (FOR$K_ENDDURREA);

    !+
    ! Return start and end+1 address of record just read
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF];
    CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];
    RETURN;
    END;					! End of FOR$$REC_RSF0 and FOR$$REC_RSF1


GLOBAL ROUTINE FOR$$REC_RSF9 			! Read sequential formatted
    ! (also RSL9, RMF0, RMF9, WMF0, RD9)
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_RSF9 is a no-op!
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RSF9 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    RETURN;


GLOBAL ROUTINE FOR$$REC_WSU0 			! Write sequential unformatted
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize call for write sequential unformatted.  FOR$$REC_WSU0
!	initializes the output buffer and returns start and end+1 of user
! 	part of record buffer to be filled by caller.
!	Handles segmented and unsegmented records.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSU0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Points to start of user part of record buffer
!	LUB$A_BUF_END		Points to end+1 of user part of record buffer
!
!	RAB$B_RAC		Set to correct access mode.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Setup first output buffer.  If segmented record control
    ! then set first word to 1 as a flag that this is first record
    ! in segmented logical record record.  Set first user address
    ! to third byte in output buffer.
    ! Else (unsegmented) set first user address to first byte in output buffer.
    !-

    CCB [LUB$A_BUF_PTR] = (IF .CCB [LUB$V_SEGMENTED] THEN
	BEGIN
	(.CCB [LUB$A_RBUF_ADR])<0, 16> = 1;
	.CCB [LUB$A_RBUF_ADR] + 2
	END
    ELSE .CCB [LUB$A_RBUF_ADR]);
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];

    !+
    ! If user opened with ACCESS='KEYED', set access mode to
    ! KEYED, else SEQUENTIAL.
    !-

    IF .CCB [LUB$V_KEYED] THEN CCB [RAB$B_RAC] = RAB$C_KEY ELSE CCB [RAB$B_RAC] = RAB$C_SEQ;

    RETURN;
    END;					! End of FOR$$REC_WSU0 routine.


GLOBAL ROUTINE FOR$$REC_WSU1 			! Write sequential unformatted
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one sequential unformatted record and initialize for the next
!	FOR$$REC_WSU1 writes one output buffer and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!	FLR records are null padded.
!	If unsegmented, signal error since only one record allowed per
!	I/O statement.
!	Do not increment logical record number since this is only
!	part of logical record (FOR$$REC_WFU9 will increment).
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSU1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!	LUB$A_BUF_PTR		Pointer to end+1 of data in uer buffer
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Points to first char in user part of
!				record buffer.
!	LUB$A_BUF_END		Points to last+1 char in user part of
!				record buffer.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNAL_STOPs FOR$_OUTSTAOVE if unsegmented record
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If unsegmented, SIGNAL_STOP FOR$_OUTSTAOVE (66 = 'OUTPUT STATEMENT OVERFLOWED RECORD')
    ! since can't go on to next record without segment control.
    !-

    IF .CCB [LUB$V_SEGMENTED] EQL 0 THEN FOR$$SIGNAL_STO (FOR$K_OUTSTAOVE);

    !+
    ! If fixed length records (FLR), pad with trailing nulls.
    ! Set recordsize to actual length of record.
    !-

    IF .CCB [LUB$V_FIXED]
    THEN
	BEGIN
	CCB [RAB$W_RSZ] = .CCB [LUB$W_RBUF_SIZE];	! Always set RSZ

	IF .CCB [LUB$A_BUF_PTR] LSSA .CCB [LUB$A_BUF_END] THEN FILL_BUF (0)

	END
    ELSE
	CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_RBUF_ADR];

    !+
    ! Output buffer to RMS and check for errors
    ! If errors, SIGNAL_STO FOR$_ERRDURWRI (38='ERROR DURING WRITE')
    !-

    CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];

    IF NOT $PUT (RAB = .CCB) THEN PUT_ERROR ();

    !+
    ! Setup a subsequent output buffer.  If segmented record control
    ! then set first word to 0 as a flag that this is a subsquent record
    ! in segmented logical record (FOR$$REC_WSU9 will set bit 1 to 1 on last record);
    ! then set first user address to third byte in output buffer.
    ! Else (unsegmented) set first user address to first byte in output buffer.
    !-

    CCB [LUB$A_BUF_PTR] = (IF .CCB [LUB$V_SEGMENTED] THEN
	BEGIN
	(.CCB [LUB$A_RBUF_ADR])<0, 16> = 0;
	.CCB [LUB$A_RBUF_ADR] + 2
	END
    ELSE .CCB [LUB$A_RBUF_ADR]);
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! End of FOR$$REC_WSU1


GLOBAL ROUTINE FOR$$REC_WSU9 			! Write sequential unformatted
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write last sequential unformatted record.
!	FOR$$REC_WSU9 writes the output buffer
!	If segmented, the first control word is set to 1 as a flag
!	that record is last record of logical segmented record.
!	Otherwise an ordinary write sequential write last record is done.
!	The logical record number is incremented once for entire segmented
!	logical record.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSU9 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_LOG_RECNO		Logical record number is incremented
!				after write is done to be next record.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If unsegmented, write this one record as a sequential record.
    ! (Fill with trailing nulls if short FLR record).
    !-

    IF .CCB [LUB$V_SEGMENTED] EQL 0
    THEN
	JSB_REC9 (FOR$$REC_WSF9)		! Force JSB linkage on BIND symbol
    ELSE

    !+
    ! Else (segmented control), set bit 1 of first word in buffer as
    ! a mark that this is the last record of segmented record.
    ! Note: bit 0 says whether this record is first or subsequent record.
    !-

	BEGIN
	(.CCB [LUB$A_RBUF_ADR])<1, 1> = 1;

	!+
	! Write record, check for errors (do not increment logical record number)
	!-

	FOR$$REC_WSU1 ();

	!+
	! Update logical record number (after error check)
	! once for entire logical segmented record.
	!-

	CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] + 1;
	END;

    RETURN;
    END;					! End of FOR$$REC_WSU9


GLOBAL ROUTINE FOR$$REC_RSU0 			! Read sequential unformatted
    ! Called from FOR$$REC_RSU1 if segmented.
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_RSU0 reads one unformatted sequential record.
!	Then return start and end+1 of user
!	part of record to be processed as input.
!	Check for end of file.  If segmented, check for ENDFILE record.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RSU0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$A_RBUF_ADR		Address of record buffer set up on OPEN
!	ISB$V_SNGL_ELEM		Flag indicating whether this is a
!				single-element transfer
!
! IMPLICIT OUTPUTS:
!
!	ISB$V_LAST_REC		Set to 1 if last record of segmented record read.
!				Do not increment logical record number
!				since segmented is one record.
!	LUB$A_BUF_PTR		Pointer to start of user data in buffer
!				(This routine may bump the pointer over
!				segmented record control info).
!	RAB$W_RSZ		set to read record length or ZERO
!				if an error occurs.
!
!	RAB$B_RAC		set to sequential access mode
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNAL_STOPs FOR$_ERRDURREA (39='ERROR DRUING READ')
!	SIGNAL_STOPs FOR$_ENDDURREA (24='END-OF-FILE DURING READ')
!	SIGNAL_STOPs FOR$_INPRECTOO (22) if RMS record too big
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    CCB [RAB$B_RAC] = RAB$C_SEQ;

    !+
    ! Read record into buffer using RMS and check for erros
    ! If end-of-file, SIGNAL_STOP FOR$_ENDDURREA (24='END-OF-FILE DURING READ')
    ! If record too big for record buffer, SIGNAL_STOP FOR$_INPRECTOO.
    ! If errors, SIGNAL_STO FOR$_ERRDURREA (39='ERROR DURING READ')
    !
    ! RMS$_RTB is not an error unless the record is too big for the
    ! record buffer; if it is merely too big for the user element in a
    ! single-element transfer, no error has occurred.
    !-

    IF NOT $GET (RAB = .CCB) THEN
	IF NOT (.CCB [RAB$L_STS] EQL RMS$_RTB
		AND .CCB [RAB$W_RSZ] LEQU .CCB [LUB$W_RBUF_SIZE])
	    THEN GET_ERROR ();

    !+
    ! Increment logical record number (for backspace)
    ! so it is the number of the next record to be read.
    ! Do this only after the record has been successfully read.
    !-

    IF NOT .CCB [LUB$V_KEYED] THEN CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] + 1;

    !+
    ! Return start and end+1 address of record just read
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF];
    CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];

    !+
    ! If segmented record, check record format
    !-

    IF .CCB [LUB$V_SEGMENTED]
    THEN

    !+
    ! If (segmented) record is an ENDFILE record (one byte long and control Z)
    ! SIGNAL_STOP (FOR$_ENDDURREA (24='END-FO-FILE DURING READ').
    !-

	BEGIN

	IF .CCB [RAB$W_RSZ] EQL 1
	THEN
	    IF .(.CCB [RAB$L_RBF])<0, 8> EQLU FOR$K_CONTROL_Z
	    THEN
		FOR$$SIGNAL_STO (FOR$K_ENDDURREA);

	!+
	! Check format of segmented record.
	! If record is less than 2 bytes long or bits 15:2 are not zero,
	! SIGNAL_STOPs FOR$_SEGRECFOR (35='SEGMENTED RECORD FORMAT ERROR')
	!-

	IF .CCB [RAB$W_RSZ] LSSU 2 OR
	    (.CCB [RAB$W_RSZ] GEQU 2 AND .(.CCB [RAB$L_RBF])<2, 14> NEQU 0)
	THEN
	    FOR$$SIGNAL_STO (FOR$K_SEGRECFOR);

	!+
	! Set buffer pointer beyond end of control word.
	! Check for last record control word (bit 1=1).
	! If last record, set last record of segmented record flag (ISB$V_LAST_REC)
	! and leave logical record number incremented.
	! If not last record, decrement logical record number so not advanced
	! since a segmented logical record is a single record (for backspace).
	!-

	CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_PTR] + 2;

	IF .(.CCB [RAB$L_RBF])<1, 1>
	THEN
	    CCB [ISB$V_LAST_REC] = 1
	ELSE
	    CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] - 1;

	END;					! End of segmented processing

    RETURN;
    END;					! End of FOR$$REC_RSU0


GLOBAL ROUTINE FOR$$REC_RSU1 			! Read sequential unformatted
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_RSU1 reads one unformatted sequential record.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!	If no segmented record, then error since only one record allowed.
!	per I/O statement.
!	If last segmented record already read it is also an error.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RSU1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_LOG_RECNO		Increment logical record number
!				of next record to be read.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads next record from file on this logical unit.
!	SIGNAL_STOs FOR$_ERRDURREA (39='ERROR DURING READ')
!	SIGNAL_STOPs FOR$_ENDDURREA (24='END-OF-FILE DURING READ')
!	SIGNAL_STOPs FOR$_SEGRECFOR (35='SEGMENTED RECORD FORMAT ERROR').
!	SIGNAL_STOPs FOR$_INPSTAREQ (67='INPUT STATEMENT REQUIRED TOO MUCH DATA')
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If no segmented records, SIGNAL_STOP FOR$_INPSTAREQ (67 ='INPUT STATEMENT REQUIRED TOO MUCH DATA')
    ! since cannot on to next record without segmented control.
    ! If segmented record, go read next record unless already last record.
    !-

    IF .CCB [LUB$V_SEGMENTED] EQL 0 OR .CCB [ISB$V_LAST_REC] THEN FOR$$SIGNAL_STO (FOR$K_INPSTAREQ);

    FOR$$REC_RSU0 ();
    RETURN;
    END;					! End of FOR$$REC_RSU1


GLOBAL ROUTINE FOR$$REC_RSU9 			! Read sequential unformatted
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_RSU9 performs termination after last
!	sequential unformmatted record has been read.
!	If segmented record and not at last record of segmented record,
!	keep reading until read last record of segmented record.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RSU9 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$V_SEGMENTED		1 = segmented record info is present
!	ISB$V_LAST_REC		Set to 1 when last record of
!				segmented record has been read.
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If segmented record and if not already read last record of segmented record
    ! (ISB$V_LAST_REC = 0) then keep reading records until find last record
    ! (and increment logical record number once).
    !-

    IF .CCB [LUB$V_SEGMENTED]
    THEN

	UNTIL .CCB [ISB$V_LAST_REC] DO
	    FOR$$REC_RSU1 ();

    RETURN;
    END;					! End of FOR$$REC_RSU9


GLOBAL ROUTINE FOR$$REC_WD0 			! Write direct (formatted and unformatted)
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize for FORTRAN direct access (RMS sequential by rec. #) I/O.
!	Both formatted and unformatted.  Return buffer pointers.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WD0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Pointer to start of user part of record
!				buffer
!	LUB$A_BUF_END		Pointer to END+! of user part of record
!				buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Return pointers to the record buffer
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;					! end of routine


GLOBAL ROUTINE FOR$$REC_WD1 			! Write direct (formatted and unformatted)
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write current record and reset buffer pointers.  We used to
!	not allow more than one direct record.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WD1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Write a record, then reset pointers.
    !-

    FOR$$REC_WD9 ();				! Write the record
    FOR$$REC_WD0 ();				! Reset pointers
    RETURN;
    END;


GLOBAL ROUTINE FOR$$REC_WD9 			! Write direct (formatted and unformatted)
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write a FORTRAN direct access record (RMS sequential by rec. #).
!	Formatted and unformatted.  Pad out buffer with spaces or nulls
!	depending on whether formatted or unformatted.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WD9 ()
!
! FORMAl PARAMETERS:
!
!	NONE
!
!	CCB			Pointer to current logical unit
!	LUB$V_UNFORMAT		1 if unformatted, 0 if formatted.
!	LUB$L_LOG_RECNO		Record number to write
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$A_BUF_PTR		Pointer to end+1 of user data in record buffer
!	ISB$V_SNGL_ELEM		Flag indicating that RAB$W_RSZ and
!				RAB$L_RBF have been set up at UDF level
!
! IMPLICIT OUTPUTS:
!
!	LUB$L_LOG_RECNO		Updated record number
!	Ass. Var.		Updated associated variable if present
!	LUB$V_FIND_LAST		Cleared
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALSTOPs FOR$_ERRDURWRI if RMS write error.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If this is a buffered transfer (ISB$V_SNGL_ELEM = 0), then set up
    ! RAB$W_RSZ and RAB$L_RBF to point to the record buffer.  Otherwise
    ! they have already been set up at UDF level to point to an element.
    !-

    IF NOT .CCB [ISB$V_SNGL_ELEM]
    THEN
	BEGIN
	IF .CCB [LUB$V_FIXED]
	THEN
	    BEGIN

	    !+
	    ! Set RAB$W_RSZ to record size.
	    !-

	    CCB [RAB$W_RSZ] = .CCB [LUB$W_RBUF_SIZE];

	    !+
	    ! Pad buffer with blanks or nulls to bring record length up to
	    ! LUB$W_RBUF_SIZE if not already.
	    !-

	    IF .CCB [LUB$A_BUF_PTR] LSSA .CCB [LUB$A_BUF_END]
	    THEN
		FILL_BUF (

		    IF .CCB [LUB$V_UNFORMAT] THEN 0 ELSE %C' ');

	    END
	ELSE
	    CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_RBUF_ADR];

	!+
	! Set RAB record pointer to the record.
	!-

	CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];
	END;

    !+
    ! Clear LUB$V_FIND_LAST.
    !-

    CCB [LUB$V_FIND_LAST] = 0;

    !+
    ! Call RMS to perform the record PUT.
    ! SIGNAL any errors.
    !-

    IF NOT $PUT (RAB = .CCB) THEN PUT_ERROR ();

    !+
    ! Increment the record number in the LUB and store
    ! into the associated variable.
    !-

    CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] + 1;
    FOR$$ASSOC ();
    RETURN;
    END;					! end of routine


GLOBAL ROUTINE FOR$$REC_RD0 			! Read direct (formatted and unformatted)
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform a FORTRAN direct access READ (RMS sequential by rec. #).
!	Formatted and unformatted.  Read record and store
!	ASSOCIATED variable if any.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RD0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$W_RBUF_SIZE		Size of record buffer allocated at OPEN
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Pointer to user data in record buffer
!	LUB$A_BUF_END		Pointer to end+1 of user data in record buffer
!	LUB$V_FIND_LAST		Cleared.
!	LUB$L_LOG_RECNO		updated record number
!	ass. var.		updated associated variable (if any)
!	RAB$W_RSZ		set to read record length or ZERO
!				if error occurs.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNALSTOPs FOR$_ERRDUREA if RMS read error
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Clear LUB$V_FIND_LAST.
    !-

    CCB [LUB$V_FIND_LAST] = 0;

    !+
    ! Call RMS to do the record GET.
    ! SIGNAL_STOP EOF and RNF errors as ATTEMPT TO ACCESS NON-EXISTANT RECORD.
    !
    ! RMS$_RTB is not an error unless the record is too big for the
    ! record buffer; if it is merely too big for the user element in an
    ! unbuffered transfer, no error has occurred.
    !-

    IF NOT $GET (RAB = .CCB)
    THEN
	IF NOT (.CCB [RAB$L_STS] EQL RMS$_RTB
		AND .CCB [RAB$W_RSZ] LEQU .CCB [LUB$W_RBUF_SIZE])
	THEN
	BEGIN
	!+
	! Can't use GET_ERROR here because EOF means ATTACCNON.
	!-

	WHILE .CCB [RAB$L_STS] EQL RMS$_RSA DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $GET (RAB = .CCB)
	    END;

	IF NOT .CCB [RAB$L_STS]
	THEN
	    FOR$$SIGNAL_STO (

		SELECTONEU .CCB [RAB$L_STS] OF
		    SET

		    [RMS$_EOF, RMS$_RNF] :
			FOR$K_ATTACCNON;

		    [RMS$_RLK] :
			FOR$K_SPERECLOC;

		    [RMS$_RTB] :
			FOR$K_INPRECTOO;

		    [OTHERWISE] :
			FOR$K_ERRDURREA;
		    TES);

	END;

    !+
    ! Return pointers to the record just read.
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF];
    CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];

    !+
    ! Increment the record number in the LUB and
    ! store it in the associated variable.
    !-

    CCB [LUB$L_LOG_RECNO] = .CCB [LUB$L_LOG_RECNO] + 1;
    FOR$$ASSOC ();
    RETURN;
    END;					! end of routine


GLOBAL ROUTINE FOR$$REC_WSL0 			! Write list-directed
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_WSL0 prepares a record for list-directed output.
!	Then return start and end+1 of user
!	part of record to be processed.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSL0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!	LUB$W_R_MARGIN		Line width set at OPEN time.
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! return start and end+1 pointers to caller
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_R_MARGIN];
    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE FOR$$REC_WSL1 			! Write list-directed
    ! (Also FOR$$REC_WSL9)
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one list-directed record and initialize for the next
!	FOR$$REC_WSL1 writes one output buffer and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSL1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_R_MARGIN		Line width set at OPEN time.
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$W_RBUF_SIZE		Buffer size
!	LUB$V_FIXED		If fixed length records
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Pointer to start of user part of record buffer
!	LUB$A_BUF_END		Pointer to end+1 of user part of record buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Writes one RMS sequential record.
!	SIGNAL_STOs FOR$_ERRDURWRI on PUT error.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If fixed length records, set LUB$A_BUF_END to the actual buffer end
    ! so that blank padding will be done.
    !-

    IF .CCB [LUB$V_FIXED]
    THEN
	CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE];

    !+
    ! Call FOR$$REC_WSF1 to perform the record write.
    !-

    FOR$$REC_WSF1 ();

    !+
    ! return record buffer pointers to caller
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_R_MARGIN];
    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE FOR$$REC_WSN0 			! Write NAMELIST
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_WSN0 prepares a record for NAMELIST output.
!	Then return start and end+1 of user
!	part of record to be processed.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSN0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!	LUB$W_R_MARGIN		Line width set at OPEN time.
!	LUB$W_RBUF_SIZE		Size of buffer
!	LUB$A_RBUF_ADR		Address of record buffer allocated at OPEN
!	LUB$V_FIXED		If fixed length records
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals FOR$_OUTSTAOVE if recordsize is zero
!
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If recordsize is zero, signal FOR$_OUTSTAOVE.
    !-

    IF .CCB [LUB$W_RBUF_SIZE] EQL 0
    THEN
	FOR$$SIGNAL_STO (FOR$K_OUTSTAOVE);

    !+
    ! return start and end+1 pointers to caller
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_RBUF_ADR];
    IF .CCB [LUB$V_FIXED]
    THEN
	CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_RBUF_SIZE]
    ELSE
	CCB [LUB$A_BUF_END] = .CCB [LUB$A_RBUF_ADR] + .CCB [LUB$W_R_MARGIN];
    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE FOR$$REC_WSN1 			! Write NAMELIST
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write one NAMELIST record and initialize for the next.
!	FOR$$REC_WSN1 writes one output buffer and then
!	initializes the output buffer and returns start and end+1 of user
!	part of record buffer to be filled by caller.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WSN1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$A_RBUF_ADR		Address of buffer
!	LUB$W_RBUF_SIZE		Size of buffer
!	LUB$W_R_MARGIN		Variable record line width
!	LUB$V_FIXED		If fixed length records
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Pointer to start of user part of record buffer
!	LUB$A_BUF_END		Pointer to end+1 of user part of record buffer
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Writes one RMS sequential record.
!	SIGNAL_STOs FOR$_ERRDURWRI on PUT error.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];


    !+
    ! Call FOR$$REC_WSF1 to perform the record write.
    !-

    FOR$$REC_WSF1 ();

    !+
    ! Call FOR$$REC_WSN0 to set up for next record
    !-

    FOR$$REC_WSN0 ();

    RETURN;
    END;					! END OF ROUTINE


GLOBAL ROUTINE FOR$$REC_RMF1 			! DECODE entry point for next record
    ! also called as FOR$$REC_WMF1
    : JSB_REC1 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Since only one "record" is allowed per ENCODE or DECODE statement,
!	any request for "get next record" is an error.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RMF1 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNAL_STOPs FOR$_TOOMANREC always.
!--

    FOR$$SIGNAL_STO (FOR$K_TOOMANREC);


GLOBAL ROUTINE FOR$$REC_WMF9 			! ENCODE wrap-up
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Termination call for ENCODE.
!	Blank pad the end of the users buffer.
!
! FORMAL PARAMETERS:
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WMF9 ()
!
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!	LUB$A_BUF_PTR		Pointer to end+1 of user data in buffer
!	LUB$A_BUF_END		Pointer to end+1 of buffer
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Fill rest of buffer supplied by user if necessary (with spaces).
    !-

    IF .CCB [LUB$A_BUF_PTR] LSSA .CCB [LUB$A_BUF_END] THEN FILL_BUF (%C' ');

    RETURN;
    END;


GLOBAL ROUTINE FOR$$REC_WIF0 			! Write Internal File Formatted - Initialize
    : JSB_REC0 NOVALUE = 			! (Also FOR$$REC_RIF0)

!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize the LUB for an internal file read or write.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WIF0 ()
!
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!	LUB$A_BUF_PTR		Address of the descriptor of the internal
!				file, put there by FOR$$IO_BEG.  The only
!				allowed descriptor types are DSC$K_DTYPE_T
!				and either DSC$K_CLASS_S or DSC$K_CLASS_A.
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Pointer to the first character in the
!				internal file.
!	LUB$A_BUF_END		Pointer to the last+1 character in the
!				current internal file record.
!	LUB$W_RBUF_SIZE		Length of one internal file "record".
!	ISB$A_INTFILEND		Pointer to the last+1 character of the
!				internal file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	FOR$_INVARGFOR if descriptor is not a character scalar or array.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	DSC : REF BLOCK [, BYTE];		! Internal file descriptor

    !+
    ! Fetch the descriptor and verify that it is of the proper class
    ! and datatype.
    !-

    DSC = .CCB [LUB$A_BUF_PTR];

    IF (.DSC [DSC$B_DTYPE] NEQU DSC$K_DTYPE_T OR 	!
	((.DSC [DSC$B_CLASS] NEQU DSC$K_CLASS_S) AND (.DSC [DSC$B_CLASS] NEQU DSC$K_CLASS_A)))
    THEN
	FOR$$SIGNAL_STO (FOR$K_INVARGFOR);

    !+
    ! Set up the addresses in the LUB.
    !-

    CCB [LUB$A_BUF_PTR] = .DSC [DSC$A_POINTER];
    CCB [LUB$W_RBUF_SIZE] = .DSC [DSC$W_LENGTH];
    CCB [LUB$A_BUF_END] = .DSC [DSC$A_POINTER] + .DSC [DSC$W_LENGTH];

    !+
    ! Calculate the end of the internal file.  If the descriptor is a
    ! scalar, then it is the same as LUB$A_BUF_END.  Otherwise, it
    ! is the end of the array.
    !-

    IF .DSC [DSC$B_CLASS] EQL DSC$K_CLASS_S
    THEN
	CCB [ISB$A_INTFILEND] = .CCB [LUB$A_BUF_END]
    ELSE
	CCB [ISB$A_INTFILEND] = .DSC [DSC$A_POINTER] + .DSC [DSC$L_ARSIZE];

    RETURN;
    END;


GLOBAL ROUTINE FOR$$REC_WIF1 			! Write Internal File Formatted - Next record
    : JSB_REC1 NOVALUE = 			! (Also FOR$$REC_RIF1)

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fill remainder of record with blanks if WRITE.
!	Advance the LUB pointers to the next internal file "record".
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WIF1 ()
!
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!	LUB$A_BUF_PTR		Pointer to current character in the
!				current record.
!	LUB$A_BUF_END		Pointer to the last+1 character in the
!				current record.
!	LUB$W_RBUF_SIZE		Size of one record.
!	ISB$A_INTFILEND		Pointer to last+1 character of the
!				internal file.
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		Set to first character in the next record.
!	LUB$A_BUF_END		Set to the last+1 character of the next
!				record.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	FOR$_ENDDURREA if the "next" record is past the end of the internal
!	file on a READ.
!	FOR$_TOOMANREC if the "next" record is past the end of the internal
!	file on a WRITE.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If WRITE, fill remainder of current record with blanks.
    !-

    IF .CCB [ISB$B_STTM_TYPE]			! True if WRITE
    THEN

	IF .CCB [LUB$A_BUF_PTR] LSSA .CCB [LUB$A_BUF_END] THEN FILL_BUF (%C' ');

    !+
    ! Check for the next record being outside the internal file.
    !-

    IF .CCB [LUB$A_BUF_END] GEQA .CCB [ISB$A_INTFILEND]
    THEN

	IF .CCB [ISB$B_STTM_TYPE]		! True if WRITE
	THEN
	    FOR$$SIGNAL_STO (FOR$K_TOOMANREC)
	ELSE
	    FOR$$SIGNAL_STO (FOR$K_ENDDURREA);

    !+
    ! Update pointers.
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [LUB$A_BUF_END];
    CCB [LUB$A_BUF_BEG] = .CCB [LUB$A_BUF_END];
    CCB [LUB$A_BUF_END] = .CCB [LUB$A_BUF_END] + .CCB [LUB$W_RBUF_SIZE];
    RETURN;
    END;


GLOBAL ROUTINE FOR$$REC_RKF0 			! Read keyed formatted
    : JSB_REC0 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	FOR$$REC_RKF0 reads the first record on a
!	keyed read.
!	Then return start and end+1 of user
! 	part of record to be processed as input.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_RKF0 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size of record buffer allocated in OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN.
!
! IMPLICIT OUTPUTS:
!
!	LUB$A_BUF_PTR		points to first char of user part of
!				record buffer.
!	LUB$A_BUF_END		points to end+1 of user part of
!				record buffer.
!	RAB$W_RSZ		set to read record length, or ZERO
!				if error.
!
!	RAB$B_RAC		set to keyed access mode
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Reads specified record from file on this logical unit.
!	SIGNAL_STOPs FOR$_ERRDURREA (39='ERROR DURING READ')
!	SIGNAL_STOPs FOR$_INPRECTOO if record too big
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! Read record into buffer using RMS and check for erros
    ! If end-of-file, SIGNAL_STOP FOR$_ENDDURREA (24='END-OF-FILE DURING READ')
    ! If record too big for record buffer, SIGNAL_STOP FOR$_INPRECTOO.
    ! If errors, SIGNAL_STO FOR$_ERRDURREA (39='ERROR DURING READ')
    !-

    CCB [RAB$B_RAC] = RAB$C_KEY;

    IF NOT $GET (RAB = .CCB) THEN GET_ERROR ();

    !+
    ! Return start and end+1 address of record just read
    !-

    CCB [LUB$A_BUF_PTR] = .CCB [RAB$L_RBF];
    CCB [LUB$A_BUF_END] = .CCB [RAB$L_RBF] + .CCB [RAB$W_RSZ];
    RETURN;
    END;					! End of FOR$$REC_RKF0.


GLOBAL ROUTINE FOR$$REC_WXF9 			! Rewrite indexed formatted and unformatted
    ! (also FOR$$REC_WXU9)
    : JSB_REC9 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Rewrite the current record on an indexed file.
!
! CALLING SEQUENCE:
!
!	JSB FOR$$REC_WXF9 ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Pointer to current logical unit
!	LUB$W_RBUF_SIZE		Size (bytes) allocated for record buffer at OPEN.
!	LUB$A_RBUF_ADR		Address of record buffer from OPEN
!	LUB$A_BUF_END		points to last char inserted into buffer
!				by UDF level I/O.
!	ISB$V_SNGL_ELEM		Flag indicating that RAB$W_RSZ and
!				RAB$L_RBF have been set up at UDF level
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    !+
    ! If this is a buffered transfer (ISB$V_SNGL_ELEM = 0), then set up
    ! RAB$W_RSZ and RAB$L_RBF to point to the record buffer.  Otherwise
    ! they have already been set up at UDF level to point to an element.
    !-

    IF NOT .CCB [ISB$V_SNGL_ELEM]
    THEN
	BEGIN

	!+
	! If fixed length records (FLR), pad with trailing spaces or
	! nulls, depending on whether formatted or unformatted.  Set
	! recordsize to actual length of record.
	!-

	IF .CCB [LUB$V_FIXED]
	THEN
	    BEGIN
	    CCB [RAB$W_RSZ] = .CCB [LUB$W_RBUF_SIZE];	! Always set RSZ

	    IF .CCB [LUB$A_BUF_PTR] LSSA .CCB [LUB$A_BUF_END]
	    THEN
		FILL_BUF (

		    IF .CCB [LUB$V_UNFORMAT] THEN 0 ELSE %C' ')

	    END
	ELSE
	    CCB [RAB$W_RSZ] = .CCB [LUB$A_BUF_PTR] - .CCB [LUB$A_RBUF_ADR];
	CCB [RAB$L_RBF] = .CCB [LUB$A_RBUF_ADR];
	END;

    !+
    ! Output buffer to RMS and check for errors
    ! If errors, signal them
    !-

    IF NOT $UPDATE (RAB = .CCB)
    THEN
	BEGIN

	WHILE .CCB [RAB$L_STS] EQL RMS$_RSA DO
	    BEGIN
	    $WAIT (RAB = .CCB);
	    $UPDATE (RAB = .CCB);
	    END;

	IF NOT .CCB [RAB$L_STS]
	THEN
	    FOR$$SIGNAL_STO (

		SELECTONEU .CCB [RAB$L_STS] OF
		    SET

		    [RMS$_RNL, RMS$_CUR] :
			FOR$K_NO_CURREC;

		    [RMS$_CHG, RMS$_DUP] :
			FOR$K_INCKEYCHG;

		    [OTHERWISE] :
			FOR$K_REWRITERR;
		    TES);

	END;

    RETURN;
    END;					! END OF ROUTINE


ROUTINE FILL_BUF (				! Fill rest of buffer with arg
	FILL_CHAR)				! Fill character [by-value]
    : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fill rest of buffer with argument (space or null).
!	This CALL entry point is provided for JSB routines
!	to conditionally CALL which are not using R2:R5.
!
! CALLING SEQUENCE:
!
!	CALL FILL_BUF (fill_char.rbu.v)
!
! FORMAL PARAMETERS:
!
!	fill_char.rbu.v		Fill character
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!	LUB$A_BUF_PTR		Pointer to end+1 of user data in buffer
!	LUB$A_BUF_END		Pointer to end+1 of buffer
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    CH$FILL (.FILL_CHAR, .CCB [LUB$A_BUF_END] - .CCB [LUB$A_BUF_PTR], .CCB [LUB$A_BUF_PTR]);
    RETURN;
    END;					! End of FILL_BUF

ROUTINE PUT_ERROR 				! Here on error in $PUT
    : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Here on $PUT errors, check for Record stream active error (RMS$_RSA)
!	If this error, WAIT until not active and try $PUT again.
!	This recovers from AST I/O which can occur out of the middle
!	of synchronous I/O at non-AST level.
!	Signal FORTRAN specific errors if any.
!	If any other type of error, SIGNAL_STOP (FOR$_ERRDURWRI).
!
! CALLING SEQUENCE:
!
!	JSB PUT_ERROR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	$WAITs and then tries $PUT again, until success or any error
!	except record streanm active.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    WHILE .CCB [RAB$L_STS] EQL RMS$_RSA DO
	BEGIN
	$WAIT (RAB = .CCB);
	$PUT (RAB = .CCB)
	END;

    IF NOT .CCB [RAB$L_STS]
    THEN
	FOR$$SIGNAL_STO (

	    SELECTONEU .CCB [RAB$L_STS] OF
		SET

		[RMS$_CHG, RMS$_DUP] :
		    FOR$K_INCKEYCHG;

		[RMS$_RLK] :
		    FOR$K_SPERECLOC;

		[OTHERWISE] :
		    FOR$K_ERRDURWRI;
		TES);

    RETURN;
    END;					! End of PUT_ERROR

ROUTINE GET_ERROR 				! Here on error on $GET
    : CALL_CCB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Here on $GET errors, check for Record stream active error (RMS$_RSA)
!	If this error, WAIT until not active and try $GET again.
!	This recovers from AST I/O which can occur out of the middle
!	of synchronous I/O at non-AST level.
!	If any other type of error, SIGNAL_STOP (FOR$_ERRDURRED, FOR$_ENDDURREA,
!	or FOR$_INPRECTOO) depending on RMS error codes.
!
! CALLING SEQUENCE:
!
!	JSB GET_ERROR ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB			Adr. of current LUB/ISB/RAB
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	$WAITs and then tries $GET again, until success or any error
!	except record streanm active.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    WHILE .CCB [RAB$L_STS] EQL RMS$_RSA DO
	BEGIN
	$WAIT (RAB = .CCB);
	$GET (RAB = .CCB)
	END;

    IF NOT .CCB [RAB$L_STS]
    THEN
	FOR$$SIGNAL_STO (

	    SELECTONEU .CCB [RAB$L_STS] OF
		SET

		[RMS$_EOF] :
		    FOR$K_ENDDURREA;

		[RMS$_RTB] :
		    FOR$K_INPRECTOO;

		[RMS$_KEY, RMS$_KRF, RMS$_KSZ] :
		    FOR$K_INVKEYSPE;

		[RMS$_RNF] :
		    FOR$K_ATTACCNON;

		[RMS$_RLK] :
		    FOR$K_SPERECLOC;

		[OTHERWISE] :
		    FOR$K_ERRDURREA;
		TES);

    RETURN;
    END;					! End of GET_ERROR
END

ELUDOM
