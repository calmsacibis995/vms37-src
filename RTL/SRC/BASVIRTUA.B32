MODULE BAS$VIRTUAL_ARR (			! Virtual Array interface
		IDENT = '1-022'			! File: BASVIRTUA.B32 Edit: JBS1022
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  VAX-11 BASIC Virtual Array Support
!
! ABSTRACT:
!
!	This module contains the support for VAX-11 BASIC virtual
!	arrays.  This consists of the various FETCH and STORE routines
!	called by compiled code and the interface to the I/O system.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: John Sauter, CREATION DATE: 02-FEB-1979
!
! MODIFIED BY:
!
! 1-001	- Original.  This version handles only non-virtual arrays.
!	   JBS 02-FEB-1979
! 1-002	- Make the JSB entry points take arguments in registers.
!	   JBS 26-FEB-1979
! 1-003	- Take linkage definitions from BASVIRTUA.REQ.  JBS 20-FEB-1979
! 1-004	- Based on a review of the virtual array concept with part
!	   of the VAX ECO board, virtual arrays are a BASIC-only
!	   feature.  Therefore, change OTS$ to BAS$ in the entry
!	   points.  Also, only longwords need be passed as indexes.
!	   JBS 03-APR-1979
! 1-005	- Since virtual array descriptors will have their indicies
!	   computed in the same way as ordinary arrays, rearrange
!	   the code to compute the location in the array of the value
!	   before checking the class of the descriptor.  This also
!	   helps support arrays of dynamic strings.  JBS 03-APR-1979
! 1-006	- Add calls to internal virtual array subroutines.  These are
!	   just stubs for now.  JBS 04-APR-1979
! 1-007	- Call temporary I/O routines so we can check out the indexing
!	   subroutines.  JBS 04-APR-1979
! 1-008	- Make those temporary I/O routines permanent, and handle
!	   trailing NULs properly when fetching and storing strings.
!	   JBS 18-MAY-1979
! 1-009	- Change OTS$S to STR$ facility.  JBS 18-MAY-1979
! 1-010	- Change STR$COPY_R_DX to STR$COPY_R  JBS 20-MAY-1979
! 1-011	- Correct a typo which caused normal array fetches to fail.
!	   JBS 31-MAY-1979
! 1-012	- Correct the local definition of DSC$K_DTYPE_DSC.  We must
!	   remember to remove this when the definition goes into
!	   RTLSTARLE.  JBS 01-JUN-1979
! 1-013	- Make the index parameters to BAS$FETCH_VA and BAS$STORE_VA
!	   be by value.  JBS 01-JUN-1979
! 1-014	- Correct an error in storing a string.  JBS 05-JUN-1979
! 1-015	- Debug string virtual arrays.  JBS 11-JUN-1979
! 1-016	- Remove local definitions of DSC$ symbols.  JBS 19-JUN-1979
! 1-017	- Use BASLNK.  JBS 26-JUN-1979
! 1-018	- Add BAS$STO_FA_RDX.  JBS 13-JUL-1979
! 1-019	- Change calls to STR$COPY.  JBS 19-JUL-1979
! 1-020	- Change BAS$$COPY_D and BAS$$COPY_F to end in _R1.  JBS 23-AUG-1979
! 1-021	- Allow the INDEX2 argument of BAS$STO_FA_RDX to be zero.
!	   JBS 06-NOV-1979
! 1-022	- Speed up storing into a string virtual array by creating the
!	   nulls with a single call to STR$DUPL_CHAR instead of with
!	   multiple calls to STR$CONCAT.  JBS 19-MAY-1980
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

LINKAGE
    COPY_JSB = JSB (REGISTER = 0, REGISTER = 1)	!
    : NOTUSED (2, 3, 4, 5, 6, 7, 8, 9, 10, 11);

REQUIRE 'RTLIN:BASLNK';				! Define linkage VA_JSB

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$FETCH_BFA : NOVALUE,			! Fetch a value by descriptor
    BAS$STORE_BFA : NOVALUE,			! Store a value by descriptor
    BAS$STO_FA_RDX : NOVALUE,			! Store a string by reference
    BAS$FET_FA_W_R8 : VA_JSB,			! Fetch a word
    BAS$STO_FA_W_R8 : VA_JSB NOVALUE,		! Store a word
    BAS$FET_FA_L_R8 : VA_JSB,			! Fetch a longword
    BAS$STO_FA_L_R8 : VA_JSB NOVALUE,		! Store a longword
    BAS$FET_FA_F_R8 : VA_JSB,			! Fetch a floating value
    BAS$STO_FA_F_R8 : VA_JSB NOVALUE,		! Store a floating value
    BAS$FET_FA_D_R8 : VA_JSB NOVALUE,		! Fetch a double-floating value
    BAS$STO_FA_D_R8 : VA_JSB NOVALUE;		! Store a double-floating value

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';			! Macros for defining psects

LIBRARY 'RTLSTARLE';				! System symbols

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! PSECTS:
!
DECLARE_PSECTS (BAS);				! Declare psects for BAS$ facility
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    BAS$$STOP : NOVALUE,			! signals fatal error
    BAS$$COPY_F_R1 : COPY_JSB NOVALUE,		! Copy a floating number
    BAS$$COPY_D_R1 : COPY_JSB NOVALUE,		! Copy a double number
    BAS$$VA_FETCH : NOVALUE,			! Fetch from virt. array
    BAS$$VA_STORE : NOVALUE,			! Store in virt. array
    STR$GET1_DX,				! Allocate a string
    STR$FREE1_DX,				! Deallocate a string
    STR$COPY_DX,				! Copy by descriptor
    STR$COPY_R,					! Copy by reference
    STR$CONCAT,					! Concatenate two strings
    STR$DUPL_CHAR;				! Make lots of a character

!+
! The following are the error codes used in this module.
!-

EXTERNAL LITERAL
    BAS$K_MATARRTOO : UNSIGNED (8),		! Matrix or array too large
    BAS$K_VIRARROPE : UNSIGNED (8),
    BAS$K_VIRARRDIS : UNSIGNED (8),
    BAS$K_SUBOUTRAN : UNSIGNED (8),
    BAS$K_FATSYSIO_ : UNSIGNED (8),
    BAS$K_DATTYPERR : UNSIGNED (8),
    BAS$K_TOOFEWARG : UNSIGNED (8),
    BAS$K_TOOMANARG : UNSIGNED (8),
    BAS$K_ARGDONMAT : UNSIGNED (8),
    BAS$K_FLOPOIERR : UNSIGNED (8),
    BAS$K_RECBUCLOC : UNSIGNED (8),
    BAS$K_ONEOR_TWO : UNSIGNED (8),
    BAS$K_NOTIMP : UNSIGNED (8);


GLOBAL ROUTINE BAS$FETCH_BFA (			! Fetch a value by descriptor
	DESCRIP, 				! The descriptor
	VALUE, 					! Where to put it
	INDEX1					! First index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a value from an array or virtual array.  The location in
!	which to place the value is passed by descriptor.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	VALUE.wx.dx	The place to put the value fetched
!	INDEX1.rl.v	The first index into the array.  More indicies
!			may follow this one in the calling sequence.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;

    LOCAL
	INDEX_VALUE,
	VALUE_LOCATION,
	MULTIPLIERS : REF VECTOR,
	BOUNDS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	INDEX_NUMBER,
	VALUE_DESCR : BLOCK [8, BYTE],
	VALUE_DESC_ADDR;

    MAP
	DESCRIP : REF BLOCK [8, BYTE],
	VALUE : REF BLOCK [8, BYTE];

!+
! Be sure the number of array subscripts matches the number of
! indicies given to us.
!-

    IF ((ACTUALCOUNT () - 2) NEQU .DESCRIP [DSC$B_DIMCT])
    THEN
	BEGIN

	IF ((ACTUALCOUNT () - 2) LSSU .DESCRIP [DSC$B_DIMCT])
	THEN
	    BAS$$STOP (BAS$K_TOOFEWARG)
	ELSE
	    BAS$$STOP (BAS$K_TOOMANARG);

	END;

!+
! The coefficients and bounds must be present.
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = ACTUALPARAMETER (.INDEX_NUMBER + 2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Build a descriptor pointing to the value cell in the array.  If this
! is an array of descriptors, the descriptor is copied, otherwise it
! is constructed.
!-

    IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
    THEN
	BEGIN

	MAP
	    VALUE_LOCATION : REF BLOCK [8, BYTE];

	VALUE_DESCR [DSC$W_LENGTH] = .VALUE_LOCATION [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .VALUE_LOCATION [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = (IF (.VALUE_LOCATION [DSC$B_CLASS] EQLU DSC$K_CLASS_D) THEN DSC$K_CLASS_S
	    ELSE .VALUE_LOCATION [DSC$B_CLASS]);
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION [DSC$A_POINTER];
	VALUE_DESC_ADDR = .VALUE_LOCATION;
	END
    ELSE
	BEGIN
	VALUE_DESCR [DSC$W_LENGTH] = .DESCRIP [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .DESCRIP [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = DSC$K_CLASS_S;
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION;
	VALUE_DESC_ADDR = VALUE_DESCR;
	END;

!+
! Make sure that the data type of the array element agrees with
! that of the result descriptor.
!-

    IF (.VALUE_DESCR [DSC$B_DTYPE] NEQU .VALUE [DSC$B_DTYPE]) THEN BAS$$STOP (BAS$K_DATTYPERR);

!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! If this is a string, remove trailing NULs when fetching it.
!-

	IF (.DESCRIP [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)
	THEN
	    BEGIN

	    LOCAL
		TEMP_DESC : BLOCK [8, BYTE],
		DATA_BUF : REF VECTOR [65535, BYTE],
		LEN;

	    TEMP_DESC [DSC$W_LENGTH] = 0;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    TEMP_DESC [DSC$A_POINTER] = 0;
	    STR$GET1_DX (DESCRIP [DSC$W_LENGTH], TEMP_DESC);
	    BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, .TEMP_DESC [DSC$A_POINTER]);
!+
! Now that we have it in temporary storage, remove its trailing NULs
!-
	    LEN = .TEMP_DESC [DSC$W_LENGTH];
	    DATA_BUF = .TEMP_DESC [DSC$A_POINTER];

	    WHILE ((.LEN GTR 0) AND (.DATA_BUF [.LEN - 1] EQL 0)) DO
		LEN = .LEN - 1;

!+
! Send the shortened string to the user.
!-
	    STR$COPY_R (.VALUE, LEN, .DATA_BUF);
!+
! Deallocate our temporary string.
!-
	    STR$FREE1_DX (TEMP_DESC);
	    END
	ELSE
	    BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, .VALUE [DSC$A_POINTER]);

	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Copy the array element to the value cell.  The form of the copy is
! based on the type of data.
!-

	CASE .VALUE [DSC$B_DTYPE] FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
	    SET

	    [DSC$K_DTYPE_W] : 			! 16-bit word
		BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL/2, 1]	!
		= .BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL/2, 1];

	    [DSC$K_DTYPE_L] : 			! 32-bit longword
		BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL, 1]	!
		= .BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL, 1];

	    [DSC$K_DTYPE_F] : 			! 32-bit floating point
		BAS$$COPY_F_R1 (.VALUE_DESCR [DSC$A_POINTER], .VALUE [DSC$A_POINTER]);

	    [DSC$K_DTYPE_D] : 			! 64-bit double floating
		BAS$$COPY_D_R1 (.VALUE_DESCR [DSC$A_POINTER], .VALUE [DSC$A_POINTER]);

	    [DSC$K_DTYPE_T] : 			! Text string
		STR$COPY_DX (.VALUE, .VALUE_DESC_ADDR);

	    [INRANGE, OUTRANGE] :
		BAS$$STOP (BAS$K_DATTYPERR);
	    TES;

	END;

    END;					! end of BAS$FETCH_BFA


GLOBAL ROUTINE BAS$STORE_BFA (			! Store a value by descriptor
	VALUE, 					! Where to find the value
	DESCRIP, 				! The descriptor to store it
	INDEX1					! First index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a value in an array or virtual array.  The location from
!	which to fetch the value is passed by descriptor.
!
! FORMAL PARAMETERS:
!
!	VALUE.rx.dx	The place from which to get the value stored
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array.  More indicies
!			may follow this one in the calling sequence.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;

    LOCAL
	INDEX_VALUE,
	VALUE_LOCATION,
	MULTIPLIERS : REF VECTOR,
	BOUNDS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	INDEX_NUMBER,
	VALUE_DESCR : BLOCK [8, BYTE],
	VALUE_DESC_ADDR;

    MAP
	DESCRIP : REF BLOCK [8, BYTE],
	VALUE : REF BLOCK [8, BYTE];

!+
! Be sure the number of array subscripts matches the number of
! indicies given to us.
!-

    IF ((ACTUALCOUNT () - 2) NEQU .DESCRIP [DSC$B_DIMCT])
    THEN
	BEGIN

	IF ((ACTUALCOUNT () - 2) LSSU .DESCRIP [DSC$B_DIMCT])
	THEN
	    BAS$$STOP (BAS$K_TOOFEWARG)
	ELSE
	    BAS$$STOP (BAS$K_TOOMANARG);

	END;

!+
! The coefficients and bounds must be present.
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = ACTUALPARAMETER (.INDEX_NUMBER + 2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Build a descriptor pointing to the value cell in the array.  If this
! is an array of descriptors, the descriptor is copied, otherwise it
! is constructed.
!-

    IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC)
    THEN
	BEGIN

	MAP
	    VALUE_LOCATION : REF BLOCK [8, BYTE];

	VALUE_DESCR [DSC$W_LENGTH] = .VALUE_LOCATION [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .VALUE_LOCATION [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = (IF (.VALUE_LOCATION [DSC$B_CLASS] EQLU DSC$K_CLASS_D) THEN DSC$K_CLASS_S
	    ELSE .VALUE_LOCATION [DSC$B_CLASS]);
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION [DSC$A_POINTER];
	VALUE_DESC_ADDR = .VALUE_LOCATION;
	END
    ELSE
	BEGIN
	VALUE_DESCR [DSC$W_LENGTH] = .DESCRIP [DSC$W_LENGTH];
	VALUE_DESCR [DSC$B_DTYPE] = .DESCRIP [DSC$B_DTYPE];
	VALUE_DESCR [DSC$B_CLASS] = DSC$K_CLASS_S;
	VALUE_DESCR [DSC$A_POINTER] = .VALUE_LOCATION;
	VALUE_DESC_ADDR = VALUE_DESCR;
	END;

!+
! Make sure that the data type of the array element agrees with
! that of the source descriptor.
!-

    IF (.VALUE_DESCR [DSC$B_DTYPE] NEQU .VALUE [DSC$B_DTYPE]) THEN BAS$$STOP (BAS$K_DATTYPERR);

!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	IF (.DESCRIP [DSC$B_DTYPE] EQLU DSC$K_DTYPE_DSC) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! If this is a string, we must pad it with NULs.  To do this, we need
! a temporary string.
!-

	IF (.DESCRIP [DSC$B_DTYPE] EQL DSC$K_DTYPE_T)
	THEN
	    BEGIN

	    LOCAL
		NULLS_COUNT,
		TEMP_DESC : BLOCK [8, BYTE];

!+
! Copy the caller's string to our temporary.
!-
	    TEMP_DESC [DSC$W_LENGTH] = 0;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    TEMP_DESC [DSC$A_POINTER] = 0;
	    STR$COPY_DX (TEMP_DESC, .VALUE);
!+
! Concatenate enough NULs onto the string to make it the right length.
!-
	    NULLS_COUNT = .DESCRIP [DSC$W_LENGTH] - .TEMP_DESC [DSC$W_LENGTH];

	    IF (.NULLS_COUNT GTR 0)
	    THEN
		BEGIN

		LOCAL
		    NULLS_DESC : BLOCK [8, BYTE];

		NULLS_DESC [DSC$W_LENGTH] = 1;
		NULLS_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		NULLS_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
		NULLS_DESC [DSC$A_POINTER] = 0;
		STR$DUPL_CHAR (NULLS_DESC, %REF (.NULLS_COUNT), %REF (0));
		STR$CONCAT (TEMP_DESC, TEMP_DESC, NULLS_DESC);
		STR$FREE1_DX (NULLS_DESC);
		END;

!+
! Now store the (possibly lengthened) string in the file.
!-
	    BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .TEMP_DESC [DSC$A_POINTER]);
!+
! Free our temporary string.
!-
	    STR$FREE1_DX (TEMP_DESC);
	    END
	ELSE
	    BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, .VALUE [DSC$A_POINTER]);

	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Copy the value cell to the array element.  The form of the copy is
! based on the type of data.
!-

	CASE .VALUE [DSC$B_DTYPE] FROM DSC$K_DTYPE_W TO DSC$K_DTYPE_T OF
	    SET

	    [DSC$K_DTYPE_W] : 			! 16-bit word
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL/2, 1]	!
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL/2, 1];

	    [DSC$K_DTYPE_L] : 			! 32-bit longword
		BLOCK [.VALUE_DESCR [DSC$A_POINTER], 0, 0, %BPVAL, 1]	!
		= .BLOCK [.VALUE [DSC$A_POINTER], 0, 0, %BPVAL, 1];

	    [DSC$K_DTYPE_F] : 			! 32-bit floating point
		BAS$$COPY_F_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_D] : 			! 64-bit double floating
		BAS$$COPY_D_R1 (.VALUE [DSC$A_POINTER], .VALUE_DESCR [DSC$A_POINTER]);

	    [DSC$K_DTYPE_T] : 			! Text string
		STR$COPY_DX (.VALUE_DESC_ADDR, .VALUE);

	    [INRANGE, OUTRANGE] :
		BAS$$STOP (BAS$K_DATTYPERR);
	    TES;

	END;

    END;					! end of BAS$STORE_BFA


GLOBAL ROUTINE BAS$STO_FA_RDX (			! Store a string by reference
	VALUE_LEN, 				! Length of value
	VALUE_ADDR, 				! Address of value
	DESCRIP, 				! The descriptor to store it
	INDEX1, 				! First index
	INDEX2					! Optional second index
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a string in an array or virtual array.  The string is
!	passed by reference.  The compiler uses this entry point
!	to avoid creating a descriptor for a string constant.
!
! FORMAL PARAMETERS:
!
!	VALUE_LEN.rl.v	The length of the string to be stored
!	VALUE_ADDR.rt.r	The address of the string to be stored
!	DESCRIP.rx.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array.
!	INDEX2.rl.v	The second index.  This is optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	VALUE : BLOCK [8, BYTE];		! Build descriptor here

    VALUE [DSC$W_LENGTH] = .VALUE_LEN;
    VALUE [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    VALUE [DSC$B_CLASS] = DSC$K_CLASS_S;
    VALUE [DSC$A_POINTER] = .VALUE_ADDR;

    IF (ACTUALCOUNT () LSS 5)
    THEN
	BAS$STORE_BFA (VALUE, .DESCRIP, .INDEX1)
    ELSE
	BAS$STORE_BFA (VALUE,
	    .DESCRIP, .INDEX1, .INDEX2);

    END;					! end of BAS$STO_FA_RDX


GLOBAL ROUTINE BAS$FET_FA_W_R8 (		! Fetch a word
	DESCRIP, 				! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a 16-bit word from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rw.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The word from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds words.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_W) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND .DESCRIP [DSC$V_FL_BOUNDS])) THEN BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling if this is a virtual array.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	VALUE = 0;
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    RETURN (.BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL/2, 1]);
    END;					! end of BAS$FET_FA_W_R8


GLOBAL ROUTINE BAS$STO_FA_W_R8 (		! Store a word
	VALUE, 					! The value to store
	DESCRIP, 				! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 16-bit word in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rw.v	The value to store
!	DESCRIP.rw.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds words.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_W) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL/2, 1] = .VALUE;
	END;

    END;					! end of BAS$STO_FA_W_R8


GLOBAL ROUTINE BAS$FET_FA_L_R8 (		! Fetch a longword
	DESCRIP, 				! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a 32-bit longword from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rl.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The longword from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds longwords.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_L) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    RETURN (.BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL, 1]);
    END;					! end of BAS$FET_FA_L_R8


GLOBAL ROUTINE BAS$STO_FA_L_R8 (		! Store a longword
	VALUE, 					! The value to store
	DESCRIP, 				! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 32-bit longword in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rl.v	The value to store
!	DESCRIP.rl.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds longwords.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_L) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BLOCK [.VALUE_LOCATION, 0, 0, %BPVAL, 1] = .VALUE;
	END;

    END;					! end of BAS$STO_FA_L_R8


GLOBAL ROUTINE BAS$FET_FA_F_R8 (		! Fetch a floating number
	DESCRIP, 				! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a single precision floating number from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rf.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The number from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_F) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN

	LOCAL
	    VALUE;

	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	RETURN (.VALUE);
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Fetch the value using the MOVF instruction to be sure that it is not
! a floating reserved operand.
!-
    BAS$$COPY_F_R1 (.VALUE_LOCATION, VALUE);
!+
! Return the array element as our value.
!-
    RETURN (.VALUE);
    END;					! end of BAS$FET_FA_F_R8


GLOBAL ROUTINE BAS$STO_FA_F_R8 (		! Store a floating value
	VALUE, 					! The value to store
	DESCRIP, 				! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a single-precision value in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rf.v	The value to store
!	DESCRIP.rf.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER;

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_F) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BAS$$COPY_F_R1 (VALUE, .VALUE_LOCATION);
	END;

    END;					! end of BAS$STO_FA_F_R8


GLOBAL ROUTINE BAS$FET_FA_D_R8 (		! Fetch a double-floating
	DESCRIP, 				! The descriptor to fetch from
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Fetch a double-floating number from an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	The double floating number from the array or virtual array
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [2];

!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds double-floating numbers.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_D) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_FETCH (.DESCRIP, .VALUE_LOCATION, VALUE);
	BEGIN

	REGISTER
	    R0 = 0,
	    R1 = 1;

	R0 = .VALUE [0];
	R1 = .VALUE [1];
	RETURN;
	END;
	END;

    IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Return the array element as our value.
!-
    BEGIN

    REGISTER
	R0 = 0,
	R1 = 1;

    BAS$$COPY_D_R1 (.VALUE_LOCATION, VALUE);
    R0 = .VALUE [0];
    R1 = .VALUE [1];
    RETURN;
    END;
    END;					! end of BAS$FET_FA_D_R8


GLOBAL ROUTINE BAS$STO_FA_D_R8 (		! Store a double-floating value
	VALUE0, 				! The value to store
	VALUE1, DESCRIP, 			! The descriptor to store into
	INDEX1, 				! First index
	INDEX2					! Second index
    ) : VA_JSB NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Store a 64-bit double floating value in an array or virtual array.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.v	The value to store
!			(Passed as two longwords: VALUE0 and VALUE1)
!	DESCRIP.rd.da	The descriptor of the array or virtual array
!	INDEX1.rl.v	The first index into the array
!	INDEX2.rl.v	The second index into the array
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Signals if an error is encountered.
!
!--

    BEGIN

    MAP
	DESCRIP : REF BLOCK [8, BYTE];

    LOCAL
	BOUNDS : REF VECTOR,
	MULTIPLIERS : REF VECTOR,
	LOW_INDEX,
	HIGH_INDEX,
	INDEX_INCR,
	VALUE_LOCATION,
	INDEX_VALUE,
	INDEX_NUMBER,
	VALUE : VECTOR [2];

!+
! Put the double-precision input value into a local where it will be
! safe.
!-
    VALUE [0] = .VALUE0;
    VALUE [1] = .VALUE1;
!+
! Be sure the array has at least one but no more than two dimensions.
!-

    IF ((.DESCRIP [DSC$B_DIMCT] LSSU 1) OR (.DESCRIP [DSC$B_DIMCT] GTRU 2)) THEN BAS$$STOP (BAS$K_ONEOR_TWO);

!+
! Be sure this array or virtual array holds double-floating values.
!-

    IF (.DESCRIP [DSC$B_DTYPE] NEQU DSC$K_DTYPE_D) THEN BAS$$STOP (BAS$K_ARGDONMAT);

!+
! The coefficients and bounds must be present
!-

    IF ( NOT (.DESCRIP [DSC$V_FL_COEFF] AND 	!
	.DESCRIP [DSC$V_FL_BOUNDS]))
    THEN
	BAS$$STOP (BAS$K_ARGDONMAT);

    MULTIPLIERS = DESCRIP [DSC$L_M1];
    BOUNDS = DESCRIP [DSC$L_M1] + (%UPVAL*.DESCRIP [DSC$B_DIMCT]);
!+
! Compute the lower and upper index numbers based on how the array
! is stored.
!-

    IF (.DESCRIP [DSC$V_FL_COLUMN])
    THEN
	BEGIN
	LOW_INDEX = .DESCRIP [DSC$B_DIMCT];
	HIGH_INDEX = 1;
	INDEX_INCR = -1;
	END
    ELSE
	BEGIN
	LOW_INDEX = 1;
	HIGH_INDEX = .DESCRIP [DSC$B_DIMCT];
	INDEX_INCR = 1;
	END;

    INDEX_NUMBER = .LOW_INDEX - .INDEX_INCR;
!+
! Compute the linear index from the indices provided.
!-
    VALUE_LOCATION = 0;

    WHILE ((INDEX_NUMBER = .INDEX_NUMBER + .INDEX_INCR) NEQ (.HIGH_INDEX + .INDEX_INCR)) DO
	BEGIN
	INDEX_VALUE = (IF (.INDEX_NUMBER EQL 1) THEN .INDEX1 ELSE .INDEX2);

	IF ((.INDEX_VALUE LSS .BOUNDS [(.INDEX_NUMBER - 1)*2])	!
	    OR (.INDEX_VALUE GTR .BOUNDS [((.INDEX_NUMBER - 1)*2) + 1]))
	THEN
	    BAS$$STOP (BAS$K_SUBOUTRAN);

	VALUE_LOCATION = (.VALUE_LOCATION*.MULTIPLIERS [.INDEX_NUMBER - 1]) + .INDEX_VALUE;
	END;

    VALUE_LOCATION = (.VALUE_LOCATION*.DESCRIP [DSC$W_LENGTH]) + .DESCRIP [DSC$A_A0];
!+
! Special handling for virtual arrays.
!-

    IF (.DESCRIP [DSC$B_CLASS] EQLU DSC$K_CLASS_BFA)
    THEN
	BEGIN
	BAS$$VA_STORE (.DESCRIP, .VALUE_LOCATION, VALUE);
	END
    ELSE
	BEGIN

	IF (.DESCRIP [DSC$B_CLASS] NEQU DSC$K_CLASS_A) THEN BAS$$STOP (BAS$K_NOTIMP);

!+
! Store the value provided into the array
!-
	BAS$$COPY_D_R1 (VALUE [0], .VALUE_LOCATION);
	END;

    END;					! end of BAS$STO_FA_D_R8

END						! end of module BAS$VIRTUAL_ARR

ELUDOM
