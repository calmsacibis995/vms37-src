	.TITLE COB$INTARI	COBOL intermediate arithmetic
	.IDENT /1-019/		; File: COBINTARI.MAR Edit:SBL1019
;
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
;
;
;	HISTORY:
;
;	AUTHOR:
;		Marty Jack, 15-Apr-1979
;
;	MODIFIED BY:
;
;

	.SBTTL HISTORY		; Detailed current edit history

; Edit history for Version 1 of COBINTARI.MAR
;
; 1-001 - original, with input and output multiplexors and CMPI.
;	  MLJ 15-Apr-1979
; 1-002	- include code for COB$ADDI.
; 1-003	- include code for COB$SUBI.
;	  Wm P Storey,  07-Jun-1979
; 1-004	- include code for COB$DIVI.
; 1-005	- include code for COB$MULI.
; 1-006	- fixed post-normaliztion bug in COB$ADDI.
;	  P D Gilbert,  21-Jun-1979
; 1-007 - update codes for data type (including COBOL Intermediate)
;	  R. Reichert, 11-Sept-1979
; 1-008 - Code to return value from all routines.  MLJ 11-Sep-1979
; 1-009 - Re-write of COB$MULI due to MULP bugs with overflow.
;	  PDG 11-Sep-1979
; 1-010 - Delete SIGNAL from DIVI.  MLJ 14-Sep-79
; 1-011 - Delete COBEXPI CODE -- now in separate module COBEXPI.MAR
;	  RKR 19-Sept-79.
; 1-012 - Add missing .EXTRN COB$_INTDIVZER.  MLJ 05-Oct-79
; 1-013 - Replace ADDP4 #0,  with CMPP4 #0, now that ECO fixes micro-code
;	  problem with CMPP4.	WPS 16-Oct-1979
; 1-014 - Change LIB$SIGNAL references to LIB$STOP. 
;	  Cosmetic changes.  RKR 21-OCT-79
; 1-015 - Add checks for out-of-range CIT in CONVERT and FINISH.
;	  RKR 30-OCT-79
; 1-016 - Fix loss of least significant digit when borrow from MSD of 1.
;	  WPS 6-Nov-1979
; 1-017 - Fix detection of exponent overflow and underflow generated by
;	  the operation of COB$ADDI and COB$SUBI.  Correct addressing
;	  problem.
;	  Make a special case of detecting the generation of a fraction
;	  of all zeroes by COB$ADDI and COB$SUBI.  In this case we
;	  force an exponent of zero and bypass normalization of fraction.
;	  RKR 23-APR-80
; 1-018 - Changed branch to 'FINISH' in routine COB$DIVI at label 21$: to
;	  a RET instruction since 'FINISH' expects the input argument to
;	  be in the proper format, where in this case the argument is in
;	  error and therefore was never put in the format expected by
;	  'FINISH'.  LB  15-APR-81
; 1-019 - Use general mode addressing.  SBL 30-Nov-1981
;


	.SBTTL DECLARATIONS

	.DSABL	GBL

;
; INCLUDE FILES:
;
	$DSCDEF
	$INTDEF

;
; EXTERNAL SYMBOLS:
;
	.EXTRN	COB$CVTWI_R8		; Word to intermediate
	.EXTRN	COB$CVTLI_R8		; Longword to intermediate
	.EXTRN	COB$CVTQI_R8		; Quadword to intermediate
	.EXTRN	COB$CVTFI_R7		; Floating to intermediate
	.EXTRN	COB$CVTDI_R7		; Double to intermediate
	.EXTRN	COB$CVTPI_R9		; Packed to intermediate
	.EXTRN	COB$CVTIW_R8		; Intermediate to word
	.EXTRN	COB$CVTIL_R8		; Intermediate to longword
	.EXTRN	COB$CVTIQ_R8		; Intermediate to quadword
	.EXTRN	COB$CVTIF_R7		; Intermediate to floating
	.EXTRN	COB$CVTID_R7		; Intermediate to double
	.EXTRN	COB$CVTIP_R9		; Intermediate to packed
	.EXTRN	COB$_INVARG		; Invalid argument
	.EXTRN	COB$_INTRESOPE
	.EXTRN	COB$_INTDIVZER
	.EXTRN	COB$_INTEXPUND		; Intermediate underflow
	.EXTRN	COB$_INTEXPOVE		; Intermediate underflow
	.EXTRN	LIB$STOP

;
; MACROS:
;

;
; PSECT DECLARATIONS
;
	.PSECT	_COB$CODE	PIC, SHR, LONG, EXE, NOWRT

;
; EQUATED SYMBOLS:
;
INT$P_I_FRACT=	2		; Temporary until Packed supported in MDL
				; Fraction field offset


; OWN STORAGE:
;
;+
; The following is a packed zero.  Usage of this constant should be replaced
; by immediate operands when the assembler is corrected to allow them.
;-
P0:	.PACKED	0
P1:	.PACKED 1

	.SBTTL	CONVERT		Internal routine to convert to intermediate

;+
;	Call by JSB
;	R0 points to descriptor (class = S or SD)
;	R1 points to output area (12 bytes)
;	Returns intermediate that has prefered sign in packed decimal mantissa.
;-

CONVERT:
	CASEB	DSC$B_DTYPE(R0),#0,#31	; Go to proper conversion code
10$:	.WORD	BAD_DT-10$	;  0 Z
	.WORD	BAD_DT-10$	;  1 V
	.WORD	BAD_DT-10$	;  2 BU
	.WORD	BAD_DT-10$	;  3 WU
	.WORD	BAD_DT-10$	;  4 LU
	.WORD	BAD_DT-10$	;  5 QU
	.WORD	BAD_DT-10$	;  6 B
	.WORD	20$-10$		;  7 W
	.WORD	30$-10$		;  8 L
	.WORD	40$-10$		;  9 Q
	.WORD	50$-10$		; 10 F
	.WORD	60$-10$		; 11 D
	.WORD	BAD_DT-10$	; 12 FC
	.WORD	BAD_DT-10$	; 13 DC
	.WORD	BAD_DT-10$	; 14 T
	.WORD	BAD_DT-10$	; 15 NU
	.WORD	BAD_DT-10$	; 16 NL
	.WORD	BAD_DT-10$	; 17 NLO
	.WORD	BAD_DT-10$	; 18 NR
	.WORD	BAD_DT-10$	; 19 NRO
	.WORD	BAD_DT-10$	; 20 NZ
	.WORD	70$-10$		; 21 P
	.WORD	BAD_DT-10$	; 22 ZI
	.WORD	BAD_DT-10$	; 23 ZEM
	.WORD	BAD_DT-10$	; 24 DSC
	.WORD	BAD_DT-10$	; 25 OU
	.WORD 	BAD_DT-10$	; 26 O
	.WORD	BAD_DT-10$	; 27 G
	.WORD	BAD_DT-10$	; 28 H
	.WORD	BAD_DT-10$	; 29 GC
	.WORD	BAD_DT-10$	; 30 HC
	.WORD	80$-10$		; 31 COBOL intermediate data type
	BRW	BAD_DT

;+
; Source is W
;-
20$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	21$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get scale factor
21$:	MOVL	DSC$A_POINTER(R0),R7	; Get source address
	MOVL	R1,R8			; Get destination address
	JMP	G^COB$CVTWI_R8		; Go to conversion routine

;+
; Source is L
;-
30$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	31$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get scale factor
31$:	MOVL	DSC$A_POINTER(R0),R7	; Get source address
	MOVL	R1,R8			; Get destination address
	JMP	G^COB$CVTLI_R8		; Go to conversion routine

;+
; Source is Q
;-
40$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	41$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get scale factor
41$:	MOVL	DSC$A_POINTER(R0),R7	; Get source address
	MOVL	R1,R8			; Get destination address
	JMP	G^COB$CVTQI_R8		; Go to conversion routine

;+
; Source is F
;-
50$:	MOVL	DSC$A_POINTER(R0),R6	; Get source address
	MOVL	R1,R7			; Get destination address
	JMP	G^COB$CVTFI_R7		; Go to conversion routine

;+
; Source is D
;-
60$:	MOVL	DSC$A_POINTER(R0),R6	; Get source address
	MOVL	R1,R7			; Get destination address
	JMP	G^COB$CVTDI_R7		; Go to conversion routine

;+
; Source is P
;-
70$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	71$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get scale factor
71$:	MOVZWL	DSC$W_LENGTH(R0),R7	; Get source length
	MOVL	DSC$A_POINTER(R0),R8	; Get source address
	MOVL	R1,R9			; Get destination address
	JMP	G^COB$CVTPI_R9		; Go to conversion routine

;+
; Source is intermediate
;-
80$:	MOVL	DSC$A_POINTER(R0),R0	; Get source address
	CMPW	INT$W_I_EXP(R0), #INT$K_I_EXP_HI ; Bigger than max ?
	BGTR	81$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R0), #INT$K_I_EXP_LO ; Less than min ?
	BLSS	81$				 ; Yes, underflow
	MOVQ	(R0)+,(R1)+		; Copy 8 bytes
	MOVL	(R0),(R1)		; Copy 4 more bytes
	RSB				; Done
81$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$STOP		; Signal the error

;+
; Here if not a supported data type.
;-
BAD_DT:	PUSHL	#COB$_INVARG		; "Invalid argument list"
	CALLS	#1,G^LIB$STOP

	.ENABL	LSB
	.SBTTL	COB$SUBI	Subtract intermediate temporary

;++
; FUNCTIONAL DESCRIPTION:
;
;	Accept any two supported data types as input, convert them to
;	Intermediate, subtract them, convert the Intermediate result to the
;	data type of the output argument, and return.
;
; CALLING SEQUENCE:
;
;	COB$SUBI (SUBTRAHEND.rx.dx, MINUEND.rx.dx, DIFFERENCE.wx.dx)
;
; INPUT PARAMETERS:
;	
;	SUBTRAHEND.rx.dx	The operand to the right of the operator
;	MINUEND.rx.dx		The operand to the left of the operator
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	DIFFERENCE.wx.dx	The difference of MINUEND - SUBTRAHEND
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE	
;--

	.ENTRY	COB$SUBI,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9>
 
	SUBL2	#<3*INT$K_I_LEN>,SP	; Allocate space for 3 intermediates.
 
	MOVL	4(AP),R0		; R0 now points to SUBTRAHEND.
	MOVAB	<2*INT$K_I_LEN>(SP),R1	; R1 now points to stack temp SUBTRAHEND.
	BSBW	CONVERT			; Convert operand1.
 
	XORB2	#1,		-	; Change sign of SUBTRAHEND.
	<INT$K_I_FRACT_L-1>	-	;
	+INT$P_I_FRACT		-	;
	+<2*INT$K_I_LEN>(SP)		;
	BRB	10$			; Join COB$ADDI code.

	.SBTTL	COB$ADDI	Add intermediate temporary

;++
; FUNCTIONAL DESCRIPTION:
;
;	Accept any two supported data types as input, convert them to
;	Intermediate, add them, convert the Intermediate result to the data
;	type of the output argument, and return.
;
; CALLING SEQUENCE:
;
;	COB$ADDI (ADDEND2.rx.dx, ADDEND1.rx.dx, SUM.wx.dx)
;
; INPUT PARAMETERS:
;	
;	ADDEND2.rx.dx		The operand to the right of the operator
;	ADDEND1.rx.dx		The operand to the left of the operator
;
; IMPLICIT INPUTS:
;
;	INT$K_I_FRACT_D  must be even.
;
; OUTPUT PARAMETERS:
;
;	SUM.wx.dx		The sum of ADDEND1 + ADDEND2
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE	
;--

	.IF	NE,<INT$K_I_FRACT_D -<2 * <INT$K_I_FRACT_D / 2>>>
	.ERROR		; INT$K_I_FRACT_D must be even.
	.ENDC

	.ENTRY	COB$ADDI,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9>
	SUBL2	#<3*INT$K_I_LEN>,SP	; Allocate space for 3 intermediates.
 
	MOVL	4(AP),R0		; R0 now points to ADDEND2.
	MOVAB	<2*INT$K_I_LEN>(SP),R1	; R1 now points to stack temp ADDEND2.
	BSBW	CONVERT			; Convert operand1.
10$:					; Subtract code joins here. 
	MOVL	8(AP),R0		; R0 now points to ADDEND1.
	MOVAB	INT$K_I_LEN(SP),R1	; R1 now points to stack temp ADDEND1.
	BSBW	CONVERT			; Convert operand2.
 
 
;
;   If the value of one intermediate is zero, the result of the add is the
;   other operand.
;
;   If the fraction contains a zero, the value of the intermediate temporary
;   datum is zero, regardless of the magnitude of the exponent.  It is only
;   convention (and hence can not be guaranteed) that if the fraction is 0
;   the exponent is 0.  Since the fraction part is normalized, the only
;   time that the low address byte of the fraction part is zero
;   is when the fraction part is zero.
;
;
	TSTB	<2*INT$K_I_LEN>	-	; Is ADDEND2 zero?
		+INT$P_I_FRACT(SP)	;
	BNEQ	20$			; If NEQ, ADDEND2 is non-zero.
	ADDL2	#1*INT$K_I_LEN,SP	; SP now points to other operand.
	BRB	30$			; Join common code for word branch.
 
20$:					;
	TSTB	<1*INT$K_I_LEN>	-	; Is ADDEND1 zero?
		+INT$P_I_FRACT(SP)	;
	BNEQ	40$			; If NEQ, ADDEND1 is non-zero.
	ADDL2	#2*INT$K_I_LEN,SP	; SP now points to non-zero operand.
30$:					;
	MOVL	#1,R0			; Indicate success
	BRW	FINISH			; Convert (SP) to destination and return
 
40$:					;

;   As the fractional part of the intermediate temp is normalized, decimal
;   point alignment must be done before the actual add can be performed.

;
;   Calculate difference between exponent of ADDEND1 and exponent of ADDEND2.
;
	SUBW3	INT$W_I_EXP+<2*INT$K_I_LEN>(SP),-
		INT$W_I_EXP+<1*INT$K_I_LEN>(SP),-
		R6			; R6 = e1 - e2
 
	BLSS	80$			; If LSS, e1 < e2
	BNEQ	70$			; If NEQ, e1 > e2

;
;   At this point, exponents are equal.  According to Knuth Vol 2, p 218,
;   this has a frequency of occurrence of .47 for a radix of 10.
;
	MOVAL	<2*INT$K_I_LEN>(SP),R7	; R7 points to ADDEND2
	ADDL2	#INT$K_I_LEN,SP		; SP points to ADDEND1
	BRW	120$			; Go do ADD.

;
;   The SUBTRACT has established which number is larger;
;   that is,  which number has the larger exponent.
;   Set up R7 and R8 accordingly.
;
70$:					; e1 > e2
	MNEGW	R6,R6			; Make shift count negative.
	MOVAB	<1*INT$K_I_LEN>(SP),R7	; R7 is intermediate with larger exp.
	MOVAB	<2*INT$K_I_LEN>(SP),R8	; R8 is intermediate with smaller exp.
	BRB	90$			; Go do scaling.
 
80$:					; e1 < e2
	MOVAB	<2*INT$K_I_LEN>(SP),R7	; R7 is intermediate with larger exp.
	MOVAB	<1*INT$K_I_LEN>(SP),R8	; R8 is intermediate with smaller exp.
90$:					;
 
;
;   Ensure that the absolute value of the difference between exponents
;   is less than or equal to INT$K_I_FRACT_D;  
;
	CMPW	R6,#-<INT$K_I_FRACT_D>	;
	BGEQ	95$			; If GEQ, difference in range.
	MNEGL	#INT$K_I_FRACT_D+1,R6	; Set diff to max negative.
95$:					;

;
;   Scale the number with the smaller exponent
;   into the stack temporary for the sum.
;
	MOVW	INT$W_I_EXP(R7),       -; Larger exponent becomes exponent
		INT$W_I_EXP(SP)		;	of stack temp SUM.

	ASHP	R6,	-		; Scale by the difference of exponents
		#INT$K_I_FRACT_D,      -;	the intermediate with 
		INT$P_I_FRACT(R8),     -;	the smaller exponent
		#0,	-		;	with no rounding
		#INT$K_I_FRACT_D,      -;	and with standard length
		INT$P_I_FRACT(SP)	;	into the stack temp SUM.
;
;   Since this operation is taking place with infinite precision (only
;   to be truncated to 18-digits), the digits that were just shifted off
;   must be considered.  The effect of these digits is to contribute
;   a one in the low order position only if
;	a.)  the signs of the numbers being added are different
;   and
;	b.)  any of the digits just shifted out were non-zero.
;

	XORB3	<INT$K_I_FRACT_L-1>+INT$P_I_FRACT(R8),-	; Are signs different
		<INT$K_I_FRACT_L-1>+INT$P_I_FRACT(R7),-	;	or same?
		R9
	BLBC	R9,120$			; If LBC, sign same.

;
;   As the signs are different, we have to be concerned about borrowing.
;   Borrowing will only be a problem if the most significant digit of the 
;   number with the larger exponent is a 1 (this occurs 30% of the time).
;   In that case, we need a guard digit to insure INT$K_I_FRACT_D digits
;   of accuracy.  We will make use of the fact that INT$K_I_FRACT_D is even,
;   and that therefore we have an extra digit available at INT$K_I_FRACT_D + 1.
;   Note that we have to scale BOTH numbers.
;


	CMPB	#^X01,INT$P_I_FRACT(R7)	; R7 is number with larger exponent.
	BNEQ	99$			; If NEQ, most significant digit not 1.

	ASHP	#1,-			; Effectively multiply by 10
		#INT$K_I_FRACT_D,-	; the appropriate number of digits
		INT$P_I_FRACT(R7),-	; the number with the larger exponent
		#0,-			; with no rounding
		#INT$K_I_FRACT_D+1,-	; with the extra digit
		INT$P_I_FRACT(SP)	; into the stack result.

	SUBW3	#1,INT$W_I_EXP(R7),-	; Larger exponenet becomes exponent
		INT$W_I_EXP(SP)		;	of stack result.

	INCW	R6			; Shift smaller 1 less.
	ASHP	R6,-			; Shift down
		#INT$K_I_FRACT_D,-	; the appropriate number of digits
		INT$P_I_FRACT(R8),-	; the number with the smaller exponent
		#0,-			; with no rounding
		#INT$K_I_FRACT_D+1,-	; with the extra digit
		INT$P_I_FRACT(R7)	; into the available other.


99$: 
;
;   Non-zero digits that were shifted out contribute either 
;   +1 or -1 depending on the sign of the number.
;
	DIVW3	#2,R6,R9		; Convert from digits to bytes.
	CVTWL	R9,R9			; Make number of bytes a longword.
	MNEGW	R6,R5			; R5 is number of digits shifted out.
	BLBS	R6,100$			; If LBS, number of digits odd.
	BICB	#^XF0,		-	; Make high nibble zero.
		<INT$K_I_FRACT_L-1>+INT$P_I_FRACT(R8)[R9]
100$:					;
	CMPP4	#1,P0,R5,	       -; Were any of the digits shifted out
		<INT$K_I_FRACT_L-1>+INT$P_I_FRACT(R8)[R9] ;	non-zero?
	BEQL	120$			; If EQL, all shifted out digits zero.

;
;   Increase its absolute value by one.
;
	BLBC	<INT$K_I_FRACT_L-1>-	; If LBC, sign positive.
		+INT$P_I_FRACT(R8),110$	;
	SUBP4	#1,P1,#INT$K_I_FRACT_D+1,-; Contribute by negative 1.
		INT$P_I_FRACT(SP)	;
	BRB	120$			; Join common code.
 
110$:					;
	ADDP4	#1,P1,#INT$K_I_FRACT_D+1,-; Contribute by positive 1.
		INT$P_I_FRACT(SP)	;
120$:					;

;
;   At this point, all scaling and adjustments have been made.
;   The stack temp contains a number and approximate exponent.
;   R7 points to the other number.
;
;   Note that INT$K_I_FRACT_D+1 digit serves as a guard digit
;   for both carry and borrow.
;
	ADDP4	#INT$K_I_FRACT_D+1,    -; Finally, the actual add is done.
		INT$P_I_FRACT(SP),     -;
		#INT$K_I_FRACT_D+1,    -;
		INT$P_I_FRACT(R7)	;

		BNEQ	129$		; if nonzero, normalize
		CLRW	INT$W_I_EXP(SP)	; set exponent to zero
		CVTLP	#0, #INT$K_I_FRACT_D,-    ; set ans at (SP) to 0
			    INT$P_I_FRACT(SP)     ;
		BRB	131$		; bypass normalization

;
;   Post-normalization.
;   The most significant digit may be anywhere, due to a carry into the
;   nineteenth digit position, or a loss of significance (ex:12346-12345).
;   First we must find the first non-zero digit.
;
129$:
	SKPC	#0,#INT$K_I_FRACT_L,(R3); Find first non-zero byte
	BITB	#^XF0,(R1)		; Is high digit of byte zero?
	BEQL	130$			; Branch if so
	DECL	R2			; Otherwise, shift one less
130$:	SUBL	R3,R1			; Compute byte offset of non-zero byte
	MOVAW	(R2)[R1],R0		; Compute the shift amount
	SUBW	R0,INT$W_I_EXP(SP)	; Twiddle the exponent

	ASHP	R0,#INT$K_I_FRACT_D+1,-	; Normalize the  fraction
		(R3),#0,-		;
		#INT$K_I_FRACT_D,-	;
		INT$P_I_FRACT(SP)	;
131$:
	MOVL	#1,R0			; Indicate success
	BRW	FINISH			; Convert to destination and return
	.DSABL	LSB

	.SBTTL	COB$MULI	Multiply intermediate temporary
	.ENABL	LSB
;++
; FUNCTIONAL DESCRIPTION:
;
;	Accept any two supported data types as input, convert them to
;	Intermediate, multiply them, convert the Intermediate result to the
;	data type of the output argument, and return.
;
; CALLING SEQUENCE:
;
;	COB$MULI (MULTIPLIER.rx.dx, MULTIPLICAND.rx.dx, PRODUCT.wx.dx)
;
; INPUT PARAMETERS:
;	
;	MULTIPLIER.rx.dx	The operand to the right of the operator
;	MULTIPLICAND.rx.dx	The operand to the left of the operator
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	PRODUCT.wx.dx		The product MULTIPLICAND * MULTIPLIER
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE	
;--

; LOCAL SYMBOLS:	(To make this more readable)
;	(Note: we use the fact that INT$K_I_FRACT_D is even)
;
D1	=	31-INT$K_I_FRACT_D	; # of digs for first multiply
D2	=	INT$K_I_FRACT_D+1 - D1	; # of digs for second multiply
O1	=	D2/2			; Offset from fract of first multiply
;
;   Offsets from SP
;
MR	=	0		; Offset for M'plier & Product int temps
MD	=	MR+INT$K_I_LEN	; Offset for M'cand intermediate temp
Pr1	=	MD+INT$K_I_LEN	; Offset for low product
Pr2	=	Pr1+<INT$K_I_FRACT_D/2+1>	; Offset for high product
SP_DECR	=	Pr2+<<INT$K_I_FRACT_D+D2>/2+1>	; Total to subtract from SP


	.ENTRY	COB$MULI,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9>
	SUBL2	#SP_DECR,SP		; Two inter temps and a few extras
	MOVL	4(AP),R0		; Convert operand 1
	MOVAB	MR(SP),R1
	BSBW	CONVERT
	MOVL	8(AP),R0		; Convert operand 2
	MOVAB	MD(SP),R1
	BSBW	CONVERT

	MULP	-			; Calculate lower product
		#D1,O1+INT$P_I_FRACT+MD(SP),-
		#INT$K_I_FRACT_D,INT$P_I_FRACT+MR(SP),-
		#INT$K_I_FRACT_D+D1,Pr1(SP)
	BICB3	#^XF0,-			; Put correct sign in middle of M'cand
		INT$K_I_FRACT_D/2+INT$P_I_FRACT+MD(SP),-
		(R1)
	MULP	-			; Calculate higher product (right sign)
		#D2,INT$P_I_FRACT+MD(SP),-
		#INT$K_I_FRACT_D,INT$P_I_FRACT+MR(SP),-
		#INT$K_I_FRACT_D+D2,Pr2(SP)
	MOVB	-			; Shorten lower product
		<INT$K_I_FRACT_D+D2>/2(R5),-
		<INT$K_I_FRACT_D/2>+Pr1(SP)
	ADDP4	-			; Add the two products
		#INT$K_I_FRACT_D+1,Pr1(SP),-
		#INT$K_I_FRACT_D+D2,(R5)

	DECL	R0			; Calculate amount to fiddle exponent
	EXTV	#0,(R5),R0,R0
	INCL	R0			; Amount to fiddle exponent
	ADDW2	INT$W_I_EXP+MD(SP),INT$W_I_EXP+MR(SP)
	SUBW2	R0,INT$W_I_EXP+MR(SP)
	SUBB2	#D2,R0			; Calculate shift amount

	ASHP	R0,-			; Shift into result
		#INT$K_I_FRACT_D+D2,(R5),-
		#0,-			; No rounding
		#INT$K_I_FRACT_D,INT$P_I_FRACT+MR(SP)

	MOVL	#1,R0			; Indicate success
	BRW	FINISH			; Convert to destination and return

	.DSABL	LSB

	.SBTTL	COB$DIVI	Divide intermediate temporary

;++
; FUNCTIONAL DESCRIPTION:
;
;	Accept any two supported data types as input, convert them to
;	Intermediate, divide them, convert the Intermediate result to the data
;	type of the output argument, and return.
;
; CALLING SEQUENCE:
;
;	COB$DIVI	(DIVISOR.rx.dx, DIVIDEND.rx.dx, QUOTIENT.wx.dx)
;	COB$DIVI_OSE	(DIVISOR.rx.dx, DIVIDEND.rx.dx, QUOTIENT.wx.dx)
;
; INPUT PARAMETERS:
;	
;	DIVISOR.rx.dx		The operand to the right of the operator
;	DIVIDEND.rx.dx		The operand to the left of the operator
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	QUOTIENT.wx.dx		The quotient of DIVIDEND / DIVISOR
;
; IMPLICIT OUTPUTS:
;
;	If the entry is COB$DIVI, then signal COB$_INTDIVZER.
;
; FUNCTION VALUE:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE	
;--

;
; EQUATED SYMBOLS:
;
t1	= 0				; Offset from SP
t2	= 21
t3	= 28
t4	= t1+6
dr	= 44				; Divisor
dd	= dr+INT$K_I_LEN		; Dividend
ose	= dd+INT$K_I_LEN
sp_amt	= ose+1

;
; Layout of temp storage as indexed from SP:
; (Divisor and Dividend temps are after these 44 bytes)
;
;01234567890123456789012345678901234567890123|
;t     t              t      t               |
;1     4              2      3               |
;dDDDDDDDDd00000s                            |	ASHP	dd,12,t1
;,,,,,,,,,,,,,,,,     DDDDDDS                |	DIVP	dr,t1,t2
;................     ......s                |	BICB	t2+6
;................     ......,                |	MOVB	t2+6,R6
;................     ,,,,,,,dDDDDDDDDDDDDDDs|	MULP	t2,dd,t3
;ooooooDDDDDDDDDs     ...... ,,,,,,,,,,,,,,,,|	SUBP4	t3,t1
;      .........,,ooos......                 |	ASHL	#24,t4+9,t4+11
;      .........oo..........                 |	CLRW	t4+9
;      ,,,,,,,,,,,,,,,......DDDDDS           |	DIVP	dr,t4,t2+6
;                     ...........S           |	BISB	R6,t2+11
;          ee         ............           |	...
;dDDDDDDDDS..         ,,,,,,,,,,,,           |	ASHP	t2,(SP)
;
; D =	2 digits in a byte
; d =	1 digit in byte (other digit is zero)
; S =	1 digit and a sign in byte
; s =	Sign in a byte (digit is zero)
; o =	Zero in byte
; . =	Useful information
; , =	Information used in this operation
;

	.ENTRY	COB$DIVI_OSE,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9>
	CVTBL	#1,R0
	BRB	DIV_J
	.ENTRY	COB$DIVI,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9>
	CLRL	R0
DIV_J:	SUBL2	#sp_amt,SP		; Get space for temp storage
	MOVB	R0,ose(SP)		; Remember which entry point
	MOVL	4(AP),R0		; Convert operand 1 (Divisor)
	MOVAB	dr(SP),R1		;
	BSBW	CONVERT			;
	TSTB	dr+INT$P_I_FRACT(SP)	; Is divisor equal to zero?
	BEQL	20$
	MOVL	8(AP),R0		; Convert operand 2 (Dividend)
	MOVAB	dd(SP),R1		;
	BSBW	CONVERT			;

	ASHP	#12,#INT$K_I_FRACT_D,-	; Multiply Dividend by 10**12
		dd+INT$P_I_FRACT(SP),-	; (dd)
		#0,-
		#<12+INT$K_I_FRACT_D>,-
		(SP)			; (t1)
	DIVP	#INT$K_I_FRACT_D,-	; And divide by Divisor
		dr+INT$P_I_FRACT(SP),-	; (dr)
		#<12+INT$K_I_FRACT_D>,-
		(SP),-			; (t1)
		#<12+1>,t2(SP)		; (t2)
	BICB	#^XF0,<<12+1>/2+t2>(SP)	; Zap the least significant digit(!!!)
	MOVB	<<12+1>/2+t2>(SP),R6	; Save the true sign
	MULP	#<12+1>,-		; Multiply back (by Divisor)
		(R5),-			; (t2)
		#INT$K_I_FRACT_D,-
		(R1),-			; (dr)
		#<12+INT$K_I_FRACT_D>,-
		t3(SP)			; (t3)
	SUBP4	#<12+INT$K_I_FRACT_D>,-	; And subtract from Dividend*10**12...
		(R5),-			; (t3)
		#<12+INT$K_I_FRACT_D>,-	;	... giving a 'remainder'
		(SP)			; (t1)
					; Low INT$K_I_FRACT_D+1 digits are t4
	ASHL	#<3*8>,-		; Multiply t4 by 10**10
		<<INT$K_I_FRACT_D+1>/2+t4>(SP),-
		<<INT$K_I_FRACT_D+1+10>/2+t4-3>(SP)
					;	(by moving the sign right...)
					;	(...and zapping the old sign)
	CLRW	<<INT$K_I_FRACT_D+1>/2+t4>(SP)
	DIVP	#INT$K_I_FRACT_D,-	; Divide 'remainder' by Divisor
		dr+INT$P_I_FRACT(SP),-	; (dr)
		#<INT$K_I_FRACT_D+1+10>,-
		t4(SP),-		; (t4)
		#<1+10>,-
		<<12+1>/2+t2>(SP)	; Putting it at low end of first DIVP
	BISB	R6,<<12+1+10>/2+t2>(SP)	; Put back true sign (if the 2nd DIVP
					;	gave 0, the sign may be wrong)
;
;   Temp-2 is now a 23-digit (12+1+10) packed item equal to:
;	Z + [ ( Dividend x 10**12 - Divisor x Z ) / Divisor ],
;    where [...] indicates integer truncation, and
;	Z = ( [ [ Dividend x 10**12 / Divisor ] / 10 ] * 10 ) * 10**10
;
	MNEGB	#4,R0			; Shift amount (19-23)
	SUBW3	INT$W_I_EXP+dr(SP), -	; Calculate exponent
		INT$W_I_EXP+dd(SP), -
		INT$W_I_EXP(SP)
	BITB	#^XF0,t2(SP)		; Re-normalization needed?
	BEQL	10$			; No
	INCW	INT$W_I_EXP(SP)		; Yes. Increase the exponent
	DECB	R0			; Move right a little more
10$:	ASHP	R0,#<12+1+10>,t2(SP),-	; Shift into Quotient
		#0,#INT$K_I_FRACT_D,-
		INT$P_I_FRACT(SP)
	MOVL	#1,R0			; Indicate success
	BRW	FINISH			; Gee, that was easy

;
;	The Divisor is zero
;
20$:	BLBS	ose(SP),21$		; Branch if entry is COB$DIVI_OSE
	PUSHL	#COB$_INTDIVZER
	CALLS	#1,G^LIB$STOP
21$:	MOVAB	dd(SP),SP		; Return dividend
	CLRL	R0			; Indicate failure
	RET

	.SBTTL	COB$CMPI	Compare intermediate temporary

;++
; FUNCTIONAL DESCRIPTION:
;
;	Accept any two supported data types as input, convert them to
;	Intermediate, compare them, and return the result of comparison
;	as value.
;
; CALLING SEQUENCE:
;
;	VALUE.wl.v = COB$CMPI (SRC1.rx.dx, SRC2.rx.dx)
;
; INPUT PARAMETERS:
;	
;	SRC1.rx.dx		The operand to the left of the operator
;	SRC2.rx.dx		The operand to the right of the operator
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	VALUE.wl.v		-1 if SRC1 LSS SRC2
;				 0 if SRC1 EQL SRC2
;				+1 if SRC1 GTR SRC2
;
; SIDE EFFECTS:
;
;	NONE	
;--

	.ENTRY	COB$CMPI,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9>
	SUBL2	#<2*INT$K_I_LEN>,SP	; Space for 2 intermediate temps
	MOVL	4(AP),R0		; Convert operand 1
	MOVAB	INT$K_I_LEN(SP),R1	;
	BSBW	CONVERT			;
	MOVL	8(AP),R0		; Convert operand 2
	MOVL	SP,R1			;
	BSBW	CONVERT			;
;
; Case on the sign of the left operand.
;
	CMPP4	#INT$K_I_FRACT_D,INT$P_I_FRACT+INT$K_I_LEN(SP),#1,P0
	BGTR	10$			; Br if left GTR 0
	BLSS	20$			; Br if left LSS 0
;
; Here if the left operand is zero.  Case on the sign of the right operand.
;
	CMPP4	#INT$K_I_FRACT_D,INT$P_I_FRACT(SP),#1,P0
	BGTR	30$			; Br if left EQL 0 and right GTR 0
	BLSS	40$			; Br if left EQL 0 and right LSS 0
	CLRL	R0			; Set "left EQL right"
	RET				; Return
;
; Here if the left operand is positive.  If the right operand is nonpositive,
; it must be smaller.  Otherwise, compare the exponents and then the fractions
; if the exponents are equal.  Since both numbers are positive, the larger
; magnitudes correspond to larger numbers.
;
10$:	CMPP4	#INT$K_I_FRACT_D,INT$P_I_FRACT(SP),#1,P0
	BLEQ	40$			; Br if left GTR 0 and right LEQ 0
	CMPW	INT$W_I_EXP+INT$K_I_LEN(SP),INT$W_I_EXP(SP)
	BGTR	40$			; Br if left exp GTR right exp
	BLSS	30$			; Br if left exp LSS right exp
	CMPP3	#INT$K_I_FRACT_D,INT$P_I_FRACT+INT$K_I_LEN(SP),INT$P_I_FRACT(SP)
	BGTR	40$			; Br if left frac GTR right frac
	BLSS	30$			; Br if left frac LSS right frac
	CLRL	R0			; Set "left EQL right"
	RET
;
; Here if the left operand is negative.  If the right operand is nonnegative,
; it must be larger.  Otherwise, compare the exponents and then the fractions
; if the exponents are equal.  Since both numbers are negative, the larger
; magnitudes correspond to smaller numbers.
;
20$:	CMPP4	#INT$K_I_FRACT_D,INT$P_I_FRACT(SP),#1,P0
	BGEQ	30$			; Br if left LSS 0 and right GEQ 0
	CMPW	INT$W_I_EXP+INT$K_I_LEN(SP),INT$W_I_EXP(SP)
	BLSS	40$			; Br if left exp LSS right exp
	BGTR	30$			; Br if left exp GTR right exp
	CMPP3	#INT$K_I_FRACT_D,INT$P_I_FRACT+INT$K_I_LEN(SP),INT$P_I_FRACT(SP)
	BGTR	40$			; Br if left frac GTR right frac
	BLSS	30$			; Br if left frac LSS right frac
	CLRL	R0			; Set "left EQL right"
	RET				; Return
;
; Here to return +1 and -1 values.
;
30$:	MNEGL	#1,R0			; Set "left LSS right"
	RET				; Return
40$:	MOVL	#1,R0			; Set "left GTR right"
	RET				; Return

	.SBTTL	FINISH		Convert to destination type and return

;+
;	Enter by branch with (SP) containing the intermediate result
;	and 12(AP) pointing to the descriptor for the destination.
;	R0 contains routine status.
;-

FINISH:
	TSTB	INT$P_I_FRACT(SP)	; is fraction zero ?
	BNEQ	8$			; no
	CLRW	INT$W_I_EXP(SP)		; force exponent to zero
	BRB	9$			; bypass overflow and underflow
					; checks
;+
; Check for out-of-range conditions first
; We do the check here for all destination type so that we can report
; overflow and underflow distinctly.  If we allow the flow to go
; directly to various COB$CVTI_x routines, what will be reported
; is COB$_INTRESOPE (which is not correct -- we just created the
; exception and did not access it -- creating an exception should
; distinguish between over_ and under_flow)
;-

8$:
	CMPW	INT$W_I_EXP(SP), #INT$K_I_EXP_HI ; Bigger than max ?
	BGTR	3$			         ; Yes, overflow
	CMPW	INT$W_I_EXP(SP), #INT$K_I_EXP_LO ; Less than min ?
	BLSS	5$				 ; Yes, underflow
9$:
	PUSHL	R0			; Save success status
					; Result now at 4(SP)

	MOVL	12(AP),R0		; pick up the descriptor addr.
	CASEB	DSC$B_DTYPE(R0),#0,#31
10$:	.WORD	BAD_DT-10$	;  0 Z
	.WORD	BAD_DT-10$	;  1 V
	.WORD	BAD_DT-10$	;  2 BU
	.WORD	BAD_DT-10$	;  3 WU
	.WORD	BAD_DT-10$	;  4 LU
	.WORD	BAD_DT-10$	;  5 QU
	.WORD	BAD_DT-10$	;  6 B
	.WORD	20$-10$		;  7 W
	.WORD	30$-10$		;  8 L
	.WORD	40$-10$		;  9 Q
	.WORD	50$-10$		; 10 F
	.WORD	60$-10$		; 11 D
	.WORD	BAD_DT-10$	; 12 FC
	.WORD	BAD_DT-10$	; 13 DC
	.WORD	BAD_DT-10$	; 14 T
	.WORD	BAD_DT-10$	; 15 NU
	.WORD	BAD_DT-10$	; 16 NL
	.WORD	BAD_DT-10$	; 17 NLO
	.WORD	BAD_DT-10$	; 18 NR
	.WORD	BAD_DT-10$	; 19 NRO
	.WORD	BAD_DT-10$	; 20 NZ
	.WORD	70$-10$		; 21 P
	.WORD	BAD_DT-10$	; 22 ZI
	.WORD	BAD_DT-10$	; 23 ZEM
	.WORD	BAD_DT-10$	; 24 DSC
	.WORD	BAD_DT-10$	; 25 OU
	.WORD 	BAD_DT-10$	; 26 O
	.WORD	BAD_DT-10$	; 27 G
	.WORD	BAD_DT-10$	; 28 H
	.WORD	BAD_DT-10$	; 29 GC
	.WORD	BAD_DT-10$	; 30 HC
	.WORD	80$-10$		; 31 COBOL intermediate data type
	BRW	BAD_DT


;+
; CIT overflowed.
;-
3$:
	PUSHL	#COB$_INTEXPOVE		; Overflow signal
	BRB	6$			; go signal

;+
; CIT underflow
;-
5$:
	PUSHL	#COB$_INTEXPUND		; Underflow signal
6$:	CALLS	#1,G^LIB$STOP		; Signal and stop.

;+
; Destination is W
;-
20$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	21$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get scale factor
	MNEGL	R6,R6			; Negate scale factor
21$:	MOVAB	4(SP),R7		; Get source address
	MOVL	DSC$A_POINTER(R0),R8	; Get destination address
	JSB	G^COB$CVTIW_R8		; Go to conversion routine
	MOVL	(SP)+,R0		; Restore status
	RET				; Return

;+
; Destination is L
;-
30$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	31$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get scale factor
	MNEGL	R6,R6			; Negate scale factor
31$:	MOVAB	4(SP),R7		; Get source address
	MOVL	DSC$A_POINTER(R0),R8	; Get destination address
	JSB	G^COB$CVTIL_R8		; Go to conversion routine
	MOVL	(SP)+,R0		; Restore status
	RET				; Return

;+
; Destination is Q
;-
40$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	41$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get negative of scale factor
	MNEGL	R6,R6			; 
41$:	MOVAB	4(SP),R7		; Get source address
	MOVL	DSC$A_POINTER(R0),R8	; Get destination address
	JSB	G^COB$CVTIQ_R8		; Go to conversion routine
	MOVL	(SP)+,R0		; Restore status
	RET				; Return

;+
; Destination is F
;-
50$:	MOVAB	4(SP),R6		; Get source address
	MOVL	DSC$A_POINTER(R0),R7	; Get destination address
	JSB	G^COB$CVTIF_R7		; Go to conversion routine
	MOVL	(SP)+,R0		; Restore status
	RET				; Return

;+
; Destination is D
;-
60$:	MOVAB	4(SP),R6		; Get source address
	MOVL	DSC$A_POINTER(R0),R7	; Get destination address
	JSB	G^COB$CVTID_R7		; Go to conversion routine
	MOVL	(SP)+,R0		; Restore status
	RET				; Return

;+
; Destination is P
;-
70$:	CLRL	R6			; Assume class S
	CMPB	DSC$B_CLASS(R0),#DSC$K_CLASS_SD
	BNEQ	71$			; Branch if not class SD
	CVTBL	DSC$B_SCALE(R0),R6	; Get negative of scale factor
	MNEGL	R6,R6			;
71$:	MOVAB	4(SP),R7		; Get source address
	MOVZWL	DSC$W_LENGTH(R0),R8	; Get destination length
	MOVL	DSC$A_POINTER(R0),R9	; Get destination address
	JSB	G^COB$CVTIP_R9		; Go to conversion routine
	MOVL	(SP)+,R0		; Restore status
	RET				; Return

;+
; Destination is intermediate
;-
80$:	MOVL	DSC$A_POINTER(R0),R0	; Get destination address
	MOVQ	4(SP),(R0)+		; Move 8 bytes
	MOVL	12(SP),(R0)		; Move 4 more bytes
	MOVL	(SP)+,R0		; Restore status
	RET				; Return
;
	.END
