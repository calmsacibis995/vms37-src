MODULE BAS$CVT_OUT (				! Convert single or double float to Basic E, F, or G
		IDENT = '1-019'			! File:BASCVTOUT.B32 Edit: PLL1019
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY: VAX-11 BASIC support
!
! ABSTRACT:
!
!	Convert a double or single precision floating point number to E, F, or
!	G format for VAX-11 BASIC.  These routines will support PRINT, PRINT USING,
!	NUM$, NUM1$, STR$, and FORMAT$.  For E and F format, if the input value
!	is single precision, a maximum of 6 significant digits are returned; for
!	a double precision value, a maximum of 16 significant digits are returned.
!
! ENVIRONMENT: User mode - AST reentrant.
!
! AUTHOR: Donald Petersen, CREATION DATE: 26-Jun-79
!
! MODIFIED BY:
!
!	DGP, 26-Jun-79 : VERSION 1
! 1-001	- original
! 1-003 - Change algorithm for determinig the number of significant digits
!	  we ask the kernel routine for.  DGP 16-Jul-79
! 1-004 - More work on Print Using.  DGP  23-Jul-79
! 1-005 - Add E formatting for Print Using.  DGP 27-Jul-79
! 1-006 - Change the conversion macros to JSB routines to save space. DGP 30-Jul-79
! 1-007 - Continuing development of E format.  DGP 31-Jul-79
! 1-008 - Add optional arg. to BAS$CVT_OUT_D_T for number of digits in F format
!	  before swiching to E.  DGP 07-Sep-79
! 1-009 - BAS$CVT_OUT_F_F does not set RT_RND when calling kernel conversion
!	  routine if V_FLT_DEC_PT is set in input flags.  DGP 10-Sep-79
! 1-010 - Load KERNEL_BLOCK [STRING_PTR] before checking for zero.  DGP
!	  21-Sep-79
! 1-011 - Accept currency, radix point, and digit separator symbols as
!	  parameters in order to allow the BASIC user to change them.  Can't
!	  do the translation here because the format interpreter needs the
!	  lengths of some of the symbols.  DGP 30-Oct-79
! 1-012 - Scale factor is only a byte.  DGP 25-Nov-79
! 1-013 - Fix bug in scaling in BAS$CVT_OUT_D_F.  DGP 06-Dec-79
! 1-014 - When calling the kernal conversion routine, bias 'right round' by
!	  the scale factor in BAS$CVT_OUT_D_F.  DGP 03-Mar-80
! 1-015 - Put the BUILTIN ACTUALCOUNT into the routines that need it, rather
!	  than at the module level, in anticipation of the next BLISS compiler,
!	  which will require it there.  While we are here, make some
!	  improvements in the source text.  Note that this edit changes
!	  no code.  JBS 27-Aug-1980
! 1-016 - FIX BAS$CVT_OUT_D_G, PLAIN_E_FORM_11 and PLAIN_F_FORM_11 to return status.  FM 1-OCT-80
! 1-017 - Fix the PRINT USING, '$$##.##', .01   REJ & FM 1-OCT-80
! 1-018 - Fix bug of some fraction numbers printing out as zero and correct
!	  error checking for E format with negative numbers. Corresponds
!	  to bug version 14C, 14D, and 14E.  DGP 23-Feb-81
! 1-019 - Add nooptimize to list of switches.  This is temporary - the Bliss
!	  compiler used for VMS 3.0 optimizes away a line of code.  PLL 22-Feb-82
!--

!<BLF/PAGE>

!
! SWITCHES
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);
SWITCHES NOOPTIMIZE;

!
! LINKAGES
!

REQUIRE 'RTLIN:OTSLNK';

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$CVT_OUT_F_E,				! Convert float to E format
    BAS$CVT_OUT_D_E,				! Convert double to E format
    BAS$CVT_OUT_F_F,				! Convert float to F format
    BAS$CVT_OUT_D_F,				! Convert double to F format
    BAS$CVT_OUT_D_G,				! Convert double to G format
    FANCY_F_FORM_11 : JSB_FORMAT_A10 NOVALUE,	! F format for PRINT USING
    FANCY_E_FORM_11 : JSB_FORMAT_A10 NOVALUE,	! E format for PRINT USING
    PLAIN_E_FORM_11 : JSB_FORMAT_A5,		! E format for STR$, NUM$, and PRINT
    PLAIN_F_FORM_11 : JSB_FORMAT_A5;		! F format for STR$, NUM$, NUM1$, and PRINT

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';

LIBRARY 'RTLSTARLE';

!
! MACROS:
!

MACRO
    RT_RND =
 0, 0, 32, 0%,					! Value for right round
    OFFSET =
 4, 0, 32, 0%,					! Offset to first non-zero digit
    						! in string returned
    DEC_EXP =
 8, 0, 32, 1%,					! Decimal exponent
    SIGN =
 12, 0, 32, 1%,					! Sign of returned value
    STRING_ADDR =
 16, 0 , 32, 0%,				! String address
    SIG_DIGITS =
 20, 0 , 32, 0%,				! No. of significant digits
    CONV_FLAGS =
 24, 0, 32, 0%,					! Flags
    KERNEL_PTR =
 36, 0, 0, 0%;					! Addr of block for kernel routine

!<BLF/MACRO>

MACRO
    PUT_OUT_ZERO =
	BEGIN
	KERNEL_BLOCK [OFFSET] = 0;
	KERNEL_BLOCK [DEC_EXP] = 1;
	KERNEL_BLOCK [SIGN] = 0;
	KERNEL_BLOCK [SIG_DIGITS] = 1;
	NO_DIGITS = 1;
	(.KERNEL_BLOCK [STRING_ADDR])<0, 8> = %C'0';
	END
    %;

!<BLF/PAGE>


MACRO
    INITIALIZE_DESC =

	BIND
	    DOT = UPLIT (BYTE ('.')),
	    STAR = UPLIT ( REP K_RANGE OF BYTE ('*')),
	    MINUS = UPLIT (BYTE ('-')),
	    BLANK = UPLIT (BYTE (' ')),
	    E = UPLIT (BYTE ('E')),
	    BLANKS = UPLIT ( REP K_RANGE OF BYTE (' ')),
	    ZEROES = UPLIT ( REP K_RANGE OF BYTE ('0'));

	IF .E_D EQL 0
	THEN
	    BEGIN
	    M_D = MINUS;
	    D_D = DOT;
	    B_D = BLANK;
	    E_D = E;
	    END

    %;

!<BLF/NOMACRO>

BUILTIN
    CVTLP,					! Convert long to packed
    CVTPS;					! Convert packed to leading sign

!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (BAS);
!
! EQUATED SYMBOLS:
!

LITERAL
    V_RT_RND = 1^25,				! right round bit for kernel routine
    K_TMP_STR_LEN_D = 25,			! len. of double string for kernel output
    K_TMP_STR_LEN_F = 17,			! len. of float string for kernel output
    K_RANGE = 38,				! the exponent of the largest floating pt.
    						! number
    V_STRIP_SPACES = 1,				! bit flag - strip leading and trailing spaces
    V_TRAILING_SIGN = 2,			! bit flag - trailing sign
    V_COMMA = 4,				! bit flag - insert commas after every 3 digits
    V_CURRENCY = 8,				! bit flag - float the currency symbol
    V_STAR = 16,				! bit flag - asterisk fill to the left
    V_FLT_DEC_PT = 32,				! bit flag - float the decimal pt. in F format
    V_PERIOD = 64,				! bit flag - insert a period
    K_NUM_F_SIG_DIG = 6,			! number of significant digits returned
    						! from a single precision conversion
    K_NUM_D_SIG_DIG = 16,			! number of significant digits returned
    						! from a double precision conversion
    K_KERNEL_BLK_SZ = 36;			! size in bytes of kernel routine parameter block

!
! OWN STORAGE:
!

OWN
    DOT_DESC : INITIAL (%X'010E0001'),
    D_D : INITIAL (0),
    MINUS_DESC : INITIAL (%X'010E0001'),
    M_D : INITIAL (0),
    NULL_DESC : INITIAL (%X'010E0000'),
    N_D,
    BLANK_DESC : INITIAL (%X'010E0001'),
    B_D : INITIAL (0),
    E_DESC : INITIAL (%X'010E0001'),
    E_D : INITIAL (0);

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$STOP : NOVALUE,				! signal general errors
    BAS$$STOP : NOVALUE,			! signal errors and stop
    STR$CONCAT,					! String concatenate
    OTS$$CVT_D_T_R8 : JSB_CVT_KERNEL;		! OTS kernel conversion routine

EXTERNAL LITERAL
    BAS$K_PRIUSIFOR : UNSIGNED (8),		! Print Using Format error
    OTS$_FATINTERR;				! Fatal internal RTL error


GLOBAL ROUTINE BAS$CVT_OUT_F_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a single precision number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 6 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rf.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LITERAL
	K_ARG_COUNT = 9;

    BUILTIN
	ACTUALCOUNT;

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LOCAL
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_F, BYTE],	! temp string for kernel conversion result
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into temp string
	NO_DIGITS,				! no. of actual significant digits returned
						! by the kernel conversion routine
	STATUS,					! return status
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE];

    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;

    IF (.VALUE [0] EQL 0)
    THEN
	BEGIN
	PUT_OUT_ZERO;
	END
    ELSE
	BEGIN
!+
! Figure out the number of significant digits to ask for.  It is the minimum of
! the maximum that single precision can accurately hold or the total number of
! digits asked for subtracting one if the value is negative.
!-
	KERNEL_BLOCK [SIG_DIGITS] = MIN (K_NUM_F_SIG_DIG,
	    .NO_INT_DIGITS + .NO_FRAC_DIGITS - (IF (.(VALUE [0])<15, 1> EQL 1) THEN 1 ELSE 0));
	KERNEL_BLOCK [CONV_FLAGS] = KERNEL_BLOCK [RT_RND] = 0;
	OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
!+
! Do some error checking.  Are there enough digits to return this number?
!-

	IF (.KERNEL_BLOCK [SIGN] LSS 0)
	THEN

	    IF (.NO_INT_DIGITS LSS 1) OR ((.NO_INT_DIGITS EQL 1) AND (.NO_FRAC_DIGITS LSS 1)) THEN RETURN 0;

!+
! Check for the actual number of significant digits returned.
!-
	TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] + .KERNEL_BLOCK [SIG_DIGITS] - 1;

	WHILE .TEMP_PTR [0] EQL %C'0' DO
	    TEMP_PTR = .TEMP_PTR - 1;

	NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
	END;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    FANCY_E_FORM_11 (.NO_INT_DIGITS, .NO_FRAC_DIGITS, .NO_DIGITS, .FLAGS, KERNEL_BLOCK, .CURRENCY,
	.DIGIT_SEP, .RADIX_PT, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0]);
    RETURN 1;
    END;					!End of BAS$CVT_OUT_F_E


GLOBAL ROUTINE BAS$CVT_OUT_D_E (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Write out a double precision number in explicit point scaled notation
!	(E format).  This routine is called by the PRINT USING support of the
!	Basic language.  It will return up to 16 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to be converted
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	FLAGS.rlu.v		no flags are applicable
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!	[BAS_SCALE_FAC.rb.v]	Basic scale factor in a range of 0 to -6
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_POINT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_ARG_COUNT = 10,
	K_SCALE = 7;				! position of scale arg.

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_D, BYTE],	! temp string for kernel conversion result
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into temp string
	NO_DIGITS,				! no. of actual significant digits returned
						! by the kernel conversion routine
	STATUS,					! return status
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE];

    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;

    IF (.VALUE [0] EQL 0)
    THEN
	BEGIN
	PUT_OUT_ZERO;
	END
    ELSE
	BEGIN
!+
! Figure out the number of significant digits to ask for.  It is the minimum of
! the maximum that double precision can accurately hold or the total number of
! digits asked for subtracting one if the value is negative.
!-
	KERNEL_BLOCK [SIG_DIGITS] = MIN (K_NUM_D_SIG_DIG,
	    .NO_INT_DIGITS + .NO_FRAC_DIGITS - (IF (.(VALUE [0])<15, 1> EQL 1) THEN 1 ELSE 0));
	KERNEL_BLOCK [CONV_FLAGS] = KERNEL_BLOCK [RT_RND] = 0;
	OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
!+
! Do some error checking.  Are there enough digits to return this number?
!-

	IF (.KERNEL_BLOCK [SIGN] LSS 0)
	THEN

	    IF (.NO_INT_DIGITS LSS 1) OR ((.NO_INT_DIGITS EQL 1) AND (.NO_FRAC_DIGITS LSS 1)) THEN RETURN 0;

!+
! Adjust for the scale factor
!-
	KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] + 	!
	(IF ACTUALCOUNT () GEQ K_SCALE THEN .BAS_SCALE_FAC [0] ELSE 0);
!+
! Check for the actual number of significant digits returned.
!-
	TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] + .KERNEL_BLOCK [SIG_DIGITS] - 1;

	WHILE .TEMP_PTR [0] EQL %C'0' DO
	    TEMP_PTR = .TEMP_PTR - 1;

	NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
	END;

    IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

    FANCY_E_FORM_11 (.NO_INT_DIGITS, .NO_FRAC_DIGITS, .NO_DIGITS, .FLAGS, KERNEL_BLOCK, .CURRENCY,
	.DIGIT_SEP, .RADIX_PT, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0]);
    RETURN 1;
    END;					!End of BAS$CVT_OUT_D_E


GLOBAL ROUTINE BAS$CVT_OUT_F_F (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a single precision number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 6 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rf.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		The value did not fit in the field described
!			the return string was truncated
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_ARG_COUNT = 9;			! No. of args for internal consistency check

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_F, BYTE],	! string for kernel conversion to
						! return the result in
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into TEMP_STR
	NO_DIGITS,				! no. of actual, useful digits returned
	STATUS,					! return status
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE];

!+
! Convert this number and then check it to see if it is effectively
! zero after rounding to the number of places required.
!-
    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;
!+
! Set the number of significant digits to the minimum of the number of total
! digits requested and the number of accurate significant digits that single
! precision can return.  This is done so that the kernel routine can do the
! rounding.
!-

    IF (.VALUE [0] EQL 0)
    THEN
!+
! Special case 0
!-
	BEGIN
	PUT_OUT_ZERO;
	END
    ELSE
	BEGIN
	KERNEL_BLOCK [SIG_DIGITS] = (IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0) THEN MIN (.NO_INT_DIGITS +
		.NO_FRAC_DIGITS -
		BEGIN

		IF (.(VALUE [0])<15, 1> EQL 1) AND ((.FLAGS AND V_TRAILING_SIGN) EQL 0) THEN 1 ELSE 0

		END
	    , K_NUM_F_SIG_DIG) ELSE K_NUM_F_SIG_DIG);
!+
! Do not set the right round flag if this is a floating decimal point number.
!-
	KERNEL_BLOCK [CONV_FLAGS] = (IF (.FLAGS AND V_FLT_DEC_PT) EQL 0 THEN V_RT_RND ELSE 0);
	KERNEL_BLOCK [RT_RND] = .NO_FRAC_DIGITS;
	OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
!+
! Check to see that this number is effectively zero and that this is Print Using
!-

	IF (((.KERNEL_BLOCK [DEC_EXP] LSS 0) AND (ABS (.KERNEL_BLOCK [DEC_EXP]) GEQ .NO_FRAC_DIGITS))	!
	    OR ((.KERNEL_BLOCK [DEC_EXP] EQL 0) AND (.NO_FRAC_DIGITS EQL 0)))	!
	    AND ((.FLAGS AND V_FLT_DEC_PT) EQL 0)	!
	    AND (.NO_INT_DIGITS GTR 0)
	THEN
	    BEGIN
	    PUT_OUT_ZERO
	    END
	ELSE
	    BEGIN
!+
! PRINT USING specific error checking.  Not performed for floating dec. pt.
! Error checking.  If this is a negative number with '**' or '$$' then it must
! also have trailing minus.
!-

	    IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0)
	    THEN

		IF ((.KERNEL_BLOCK [SIGN] LSS 0) AND 	!
		    (((.FLAGS AND V_STAR) NEQ 0) OR 	!
		    ((.FLAGS AND V_CURRENCY) NEQ 0)) AND 	!
		    ((.FLAGS AND V_TRAILING_SIGN) EQL 0))
		THEN
		    BAS$$STOP (BAS$K_PRIUSIFOR);

!+
! Find the last non-zero byte
!-
	    TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] + (IF (.FLAGS AND V_FLT_DEC_PT)
		EQL 0 THEN MIN (K_NUM_F_SIG_DIG, .KERNEL_BLOCK [DEC_EXP] + .NO_FRAC_DIGITS) ELSE
		K_NUM_F_SIG_DIG) - 1;

	    IF .TEMP_PTR GTRA (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET])
	    THEN

		WHILE .TEMP_PTR [0] EQL %C'0' DO
		    TEMP_PTR = .TEMP_PTR - 1;

	    NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
	    END;

	END;

!+
! Check to see if this is the floating decimal point situation.  The only other
! valid flag bit is V_STRIP_SPACES.  All other bits are ignored.
!-

    IF ((.FLAGS AND V_FLT_DEC_PT) NEQ 0)
    THEN
	PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK,
	    BAS_OUT_STR [0], BAS_OUT_STR_LEN [0])
    ELSE
	BEGIN
!+
! This is a more conventional F format.  Try formatting the number as
! requested.
! Do some error checking to see if the number will fit into the field width
! provided.
! 1.) Are there enough integer digits
!	a.) Need 1 if negative number and no trailing sign
!	b.) Need length of currency if floating currency symbol
!	c.) enough for the digit separators if required
!	d.) enough for the digits based on the exponent
!	e.) Need 1 for a zero if magnitude of number is less than 1.
! 2.) Are there enough fractional digits
!-

	LOCAL
	    INT_DIGITS_NEED;

!+
! Internal consistency check.  Although CURRENCY and friends are optional, if
! we are taking this code path, they are required.  Rather than taking a chance
! with garbage on the stack giving us a memory management violation, we do a
! check for the arguments.
!-

	IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

	INT_DIGITS_NEED =
	BEGIN

	IF ((.KERNEL_BLOCK [SIGN] LSS 0) AND (.FLAGS AND V_TRAILING_SIGN) EQL 0)
						! Negative numbers and trailing sign
	THEN
	    1
	ELSE
	    0

	END
	+
	BEGIN

	IF (.KERNEL_BLOCK [DEC_EXP] GTR 0)	! positive or negative exponent
	THEN
	    .KERNEL_BLOCK [DEC_EXP]
	ELSE
	    0

	END
	+
	BEGIN

	IF ((.FLAGS AND V_CURRENCY) NEQ 0)	! floating currency
	THEN
	    .CURRENCY [DSC$W_LENGTH]
	ELSE
	    0

	END
	+
	BEGIN

	IF (((.FLAGS AND V_COMMA) NEQ 0) AND (.KERNEL_BLOCK [DEC_EXP] GTR 0))
	    ! number of commas needed
	THEN
	    (.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	ELSE
	    0

	END;

	IF (.INT_DIGITS_NEED GTR .NO_INT_DIGITS) OR ((.KERNEL_BLOCK [DEC_EXP] LSS 0) AND (ABS (.KERNEL_BLOCK
		[DEC_EXP]) GEQ .NO_FRAC_DIGITS))
	THEN
	    RETURN 0;

	FANCY_F_FORM_11 (.NO_INT_DIGITS, .NO_FRAC_DIGITS, .NO_DIGITS, .FLAGS, KERNEL_BLOCK, .CURRENCY,
	    .DIGIT_SEP, .RADIX_PT, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0]);
	END;

    RETURN 1;
    END;					!End of BAS$CVT_OUT_F_F


GLOBAL ROUTINE BAS$CVT_OUT_D_F (		!
	VALUE, 					!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a double precision number to explicit point un-
!	scaled notation (F format) right justified.  This routine supports PRINT
!	USING and NUM1$.  It will return up to 16 significant digits.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		value to convert
!	NO_INT_DIGITS.rlu.v	number of integer digits
!	NO_FRAC_DIGITS.rlu.v	number of fraction digits
!	FLAGS.rlu.v		= 1, no leading or trailing space
!				= 2, trailing sign
!				= 4, insert commas
!				= 8, float currency symbol
!				= 16, * fill to left of most significant digit
!				= 32, floating decimal point.  Disregard
!				      NO_INT_DIGITS and NO_FRAC_DIGITS.
!				= 64, a decimal point is required
!	BAS_OUT_STR_LEN.wlu.r	length of return string
!	BAS_OUT_STR.wt.dx	the return string
!	[BAS_SCALE_FAC.rb.v]	Basic scale factor from 0 to -6
!	[CURRENCY.rt.dx]	currency symbol
!	[DIGIT_SEP.rt.dx]	digit group separator
!	[RADIX_PT.rt.dx]	radix point
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_ARG_COUNT = 10,			! no. of args if all there
	K_SCALE = 7;				! position of scale arg.

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_D, BYTE],	! string for kernel conversion to
						! return the result in
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into TEMP_STR
	NO_DIGITS,				! no. of actual, useful digits returned
	STATUS,					! return status
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE];

!+
! Convert this number and then check it to see if it is effectively
! zero after rounding to the number of places required.
!-
    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;
!+
! Set the number of significant digits to the minimum of the number of total
! digits requested (minus one if negative) and the number of accurate significant digits that double
! precision can return.  This is done so that the kernel routine can do the
! rounding.
!-

    IF (.VALUE [0] EQL 0)
    THEN
!+
! Special case 0
!-
	BEGIN
	PUT_OUT_ZERO;
	END
    ELSE
	BEGIN
	KERNEL_BLOCK [SIG_DIGITS] =
	(IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0) THEN MIN (.NO_INT_DIGITS + .NO_FRAC_DIGITS -
		BEGIN

		IF ((.(VALUE [0])<15, 1> EQL 1) AND ((.FLAGS AND V_TRAILING_SIGN) EQL 0)) THEN 1 ELSE 0

		END
	    , K_NUM_D_SIG_DIG) ELSE K_NUM_D_SIG_DIG);
!+
! Do not set the right round flag if this is a floating decimal point number.
!-
	KERNEL_BLOCK [CONV_FLAGS] = (IF (.FLAGS AND V_FLT_DEC_PT) EQL 0 THEN V_RT_RND ELSE 0);
	KERNEL_BLOCK [RT_RND] =
	BEGIN

	IF ACTUALCOUNT () GEQ K_SCALE THEN .BAS_SCALE_FAC [0] ELSE 0

	END
	+ .NO_FRAC_DIGITS;
	OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
!+
! Adjust for the scale factor
!-
	KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] +
	BEGIN

	IF ACTUALCOUNT () GEQ K_SCALE THEN .BAS_SCALE_FAC [0] ELSE 0

	END;
!+
! Check to see if this number is effectively zero
!-

	IF (((.KERNEL_BLOCK [DEC_EXP] LSS 0) AND (ABS (.KERNEL_BLOCK [DEC_EXP]) GEQ .NO_FRAC_DIGITS))	!
	    OR ((.KERNEL_BLOCK [DEC_EXP] EQL 0) AND (.NO_FRAC_DIGITS EQL 0)))	!
	    AND ((.FLAGS AND V_FLT_DEC_PT) EQL 0)	!
	    AND (.NO_INT_DIGITS GTR 0)
	THEN
	    BEGIN
	    PUT_OUT_ZERO
	    END
	ELSE
	    BEGIN
!+
! PRINT USING specific error checking.  Not performed for floating dec. pt.
! Error checking.  If this is a negative number with '**' or '$$' then it must
! also have trailing minus.
!-

	    IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0)
	    THEN

		IF ((.KERNEL_BLOCK [SIGN] LSS 0) AND 	!
		    (((.FLAGS AND V_STAR) NEQ 0) OR 	!
		    ((.FLAGS AND V_CURRENCY) NEQ 0)) AND 	!
		    ((.FLAGS AND V_TRAILING_SIGN) EQL 0))
		THEN
		    BAS$$STOP (BAS$K_PRIUSIFOR);

!+
! Find the last non-zero byte
!-
	    TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] +
	    BEGIN

	    IF ((.FLAGS AND V_FLT_DEC_PT) EQL 0)
	    THEN
		MIN (K_NUM_D_SIG_DIG,
		    .KERNEL_BLOCK [DEC_EXP] + .NO_FRAC_DIGITS)
	    ELSE
		K_NUM_D_SIG_DIG

	    END
	    - 1;

	    IF (.TEMP_PTR GTRA (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]))
	    THEN

		WHILE .TEMP_PTR [0] EQL %C'0' DO
		    TEMP_PTR = .TEMP_PTR - 1;

	    NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
	    END;

	END;

!+
! Check to see if this is the floating decimal point situation.  The only other
! valid flag bit is V_STRIP_SPACES.  All other bits are ignored.
!-

    IF ((.FLAGS AND V_FLT_DEC_PT) NEQ 0)
    THEN
	PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK,
	    BAS_OUT_STR [0], BAS_OUT_STR_LEN [0])
    ELSE
	BEGIN
!+
! This is a more conventional F format.  Try formatting the number as
! requested.
! Do some error checking to see if the number will fit into the field width
! provided.
! 1.) Are there enough integer digits
!	a.) Need 1 if negative number and no trailing sign
!	b.) Need length of currency symbol if floating currency symbol
!	c.) enough for the commas if required
!	d.) enough for the digits based on the exponent
!	e.) Need 1 for a zero if magnitude of number is less than 1.
! 2.) Are there enough fractional digits
!-

	LOCAL
	    INT_DIGITS_NEED;

	IF ACTUALCOUNT () LSS K_ARG_COUNT THEN LIB$STOP (OTS$_FATINTERR);

	INT_DIGITS_NEED =
	BEGIN

	IF ((.KERNEL_BLOCK [SIGN] LSS 0) AND (.FLAGS AND V_TRAILING_SIGN) EQL 0)
						! Negative numbers and trailing sign
	THEN
	    1
	ELSE
	    0

	END
	+
	BEGIN

	IF (.KERNEL_BLOCK [DEC_EXP] GTR 0)	! positive or negative exponent
	THEN
	    .KERNEL_BLOCK [DEC_EXP]
	ELSE
	    0

	END
	+
	BEGIN

	IF ((.FLAGS AND V_CURRENCY) NEQ 0)	! floating currency
	THEN
	    .CURRENCY [DSC$W_LENGTH]
	ELSE
	    0

	END
	+
	BEGIN

	IF (((.FLAGS AND V_COMMA) NEQ 0) AND (.KERNEL_BLOCK [DEC_EXP] GTR 0))	! number of commas needed
	THEN
	    (.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	ELSE
	    0

	END;
!+
! Check to see if enough integer and fraction digits have been reserved
!-

	IF (.INT_DIGITS_NEED GTR .NO_INT_DIGITS) OR ((.KERNEL_BLOCK [DEC_EXP] LSS 0) AND (ABS (.KERNEL_BLOCK
		[DEC_EXP]) GEQ .NO_FRAC_DIGITS))
	THEN
	    RETURN 0;

	FANCY_F_FORM_11 (.NO_INT_DIGITS, .NO_FRAC_DIGITS, .NO_DIGITS, .FLAGS, KERNEL_BLOCK, .CURRENCY,
	    .DIGIT_SEP, .RADIX_PT, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0]);
	END;

    RETURN 1;
    END;					!End of BAS$CVT_OUT_D_F


GLOBAL ROUTINE BAS$CVT_OUT_D_G (		!
	VALUE, 					!
	FLAGS, 					!
	BAS_OUT_STR_LEN, 			!
	BAS_OUT_STR, 				!
	BAS_SCALE_FAC, 				!
	NUM_DIGITS				!
    ) = 					!

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine converts a double precision number to either E or F format
!	depending on its value.  This routine supports PRINT, PRINT USING, NUM$,
!	and STR$.  If a number can be represented in six digits without any loss
!	of accuracy then it is returned in F format.  Otherwise, it is returned
!	in E format.  If the optional argument NUM_DIGITS is included, then the
!	number is returned in F format if it can be represented no less accur-
!	ately in NUM_DIGITS.
!
! FORMAL PARAMETERS:
!
!	VALUE.rd.r		the value to convert
!	FLAGS.rlu.v		= 1, strip leading and trailing space
!	BAS_OUT_STR_LEN.ww.r	length of the string returned.  Useful if return
!				string is static.
!	BAS_OUT_STR.wt.dx	return string
!	[BAS_SCALE_FAC.rb.v]	the scale factor for double precision values.
!	[NUM_DIGITS.rl.v]	number of digits in F format.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	success		the value could be converted as required
!	failure		the value did not fit in the field described
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	BAS_OUT_STR_LEN : REF VECTOR,
	VALUE : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG];

    LITERAL
	K_NUM_DIGITS = 6,			! Arg. position of number of digits
	K_SCALE = 5;				! Arg. position of scale factor

    BUILTIN
	ACTUALCOUNT;

    LOCAL
	RANGE,					! maximum number of digits for F format
	TEMP_STRING : VECTOR [K_TMP_STR_LEN_D, BYTE],	! temp string to pass to the kernel
						! conversion routine
	TEMP_PTR : REF VECTOR [, BYTE],		! pointer into string returned by
						! kernel conversion routine
	NO_DIGITS,				! actual length of string returned
						! by the kernel routine
	STATUS,					! return status
	KERNEL_BLOCK : BLOCK [K_KERNEL_BLK_SZ, BYTE];

    !+
    ! Special case 0
    !-

    IF (.VALUE [0] EQL 0)
    THEN
	BEGIN

	BIND
	    BLANK = UPLIT (BYTE (' ')),
	    ZERO = UPLIT (BYTE ('0'));

	LOCAL
	    ZERO_STR_DESC : BLOCK [8, BYTE];

!+
! Initialize the BLANK desc in case this is the very first PRINT.
!-
	B_D = BLANK;
	ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZERO_STR_DESC [DSC$W_LENGTH] = 1;
	ZERO_STR_DESC [DSC$A_POINTER] = ZERO;
	STATUS = STR$CONCAT (BAS_OUT_STR [0],
	    (IF .FLAGS AND V_STRIP_SPACES THEN NULL_DESC ELSE BLANK_DESC), ZERO_STR_DESC,
	    (IF .FLAGS AND V_STRIP_SPACES THEN NULL_DESC ELSE BLANK_DESC));
	BAS_OUT_STR_LEN [0] = (IF .FLAGS AND V_STRIP_SPACES THEN 1 ELSE 3);
	RETURN .STATUS;
	END;

!+
! Check for the optional argument NUM_DIGITS and set RANGE so that it can be used
! in several places.
!-
    RANGE = (IF ACTUALCOUNT () EQL K_NUM_DIGITS THEN .NUM_DIGITS ELSE K_NUM_F_SIG_DIG);
!+
! Load up the parameter block, stick the value in R0 and call the kernel
! conversion routine.
!-
    KERNEL_BLOCK [STRING_ADDR] = TEMP_STRING;
    KERNEL_BLOCK [SIG_DIGITS] = .RANGE;
    KERNEL_BLOCK [CONV_FLAGS] = KERNEL_BLOCK [RT_RND] = 0;
    OTS$$CVT_D_T_R8 (.VALUE, KERNEL_BLOCK [KERNEL_PTR]);
!+
! Adjust for the scale factor, if any
!-
    KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] +
    BEGIN

    IF ACTUALCOUNT () GEQ K_SCALE THEN .BAS_SCALE_FAC [0] ELSE 0

    END;
!+
! Find the last non-zero digit in order to know the actual length of the number
!-
    TEMP_PTR = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET] + .RANGE - 1;

    WHILE .TEMP_PTR [0] EQL %C'0' DO
	TEMP_PTR = .TEMP_PTR - 1;

    NO_DIGITS = .TEMP_PTR - (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]) + 1;
!+
! Now determine whether to do E format or F format.  Note 0 has been special
! cased.  Some rough decisions can be made based on the exponent of the value
! returned by the kernel conversion routine.  If the exponent is > 6 or < -6
! the number should be output in E format.  If the exponent is < 6 and > 0,
! then the number is output as F format.  For numbers where the exponent is
! > -6 and < 0, the actual value comes into play.  If the number can be represented
! no less accurately in 6 digits, then it is output in F format.  Otherwise,
! the number is output in E format with 6 significant digits.
! If NUM_DIGITS is specified, then substitute its value for 6 in the above
! discussion.
!-

    SELECTONE .KERNEL_BLOCK [DEC_EXP] OF
	SET

	[0 TO .RANGE] :
!+
! Unconditionally F format
!-
	    STATUS = PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0])
	;

	[-(.RANGE - 1) TO -1] :
!+
! May be either E or F format.  Have to check and see if any accuracy will
! be lost by displaying 6 digits in F format.  If accuracy will be lost,
! then use E format.
!-

	    IF ((.NO_DIGITS - .KERNEL_BLOCK [DEC_EXP]) LEQ .RANGE)
	    THEN
!+
! F format
!-
		STATUS = PLAIN_F_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, BAS_OUT_STR [0],
		    BAS_OUT_STR_LEN [0])
	    ELSE
!+
! E format
!-
		STATUS = PLAIN_E_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, BAS_OUT_STR [0],
		    BAS_OUT_STR_LEN [0]);

	[OTHERWISE] :
!+
! Unconditionally E format
!-
	    STATUS = PLAIN_E_FORM_11 (.NO_DIGITS, .FLAGS, KERNEL_BLOCK, BAS_OUT_STR [0], BAS_OUT_STR_LEN [0])
	;
	TES;

    RETURN .STATUS;
    END;					!End of BAS$CVT_OUT_D_G


ROUTINE PLAIN_F_FORM_11 (			! Plain old F formatting
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN				!
    ) : JSB_FORMAT_A5 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do plain old explicit point unscaled formatting.  Strip leading and
!	trailing spaces if necessary.
!
! FORMAL PARAMETERS:
!
!	NO_DIGITS.rlu.v		number of actual significant digits in value to
!				be formatted
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	block returned by kernel conversion routine
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Returns STR$_TRU
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	STATUS;

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    INITIALIZE_DESC;

    IF (.KERNEL_BLOCK [DEC_EXP] GEQ 0)
    THEN
!+
! The number is greater than or equal to 1
!-

	IF (.KERNEL_BLOCK [DEC_EXP] GEQ .NO_DIGITS)
	THEN
	    BEGIN
!+
! This entire number consists only of integer part.  Put the number
! returned by the conversion routine and optionally some trailing
! zeroes into the return string.
!-

	    LOCAL
		ZERO_STR_DESC : BLOCK [8, BYTE],	! desc. for trailing zeroes
		INT_STR_DESC : BLOCK [8, BYTE];	! desc. for integer portion of number

	    INT_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	    ZERO_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS;
	    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
	    STATUS = STR$CONCAT (BAS_OUT_STR [0],
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0)
		THEN
		    MINUS_DESC
		ELSE

		    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    , INT_STR_DESC, ZERO_STR_DESC,
		BEGIN

		IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    );
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES)
	    THEN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    ELSE
		2

	    END
	    + .KERNEL_BLOCK [DEC_EXP];
	    END
	ELSE
	    BEGIN
!+
! This number has both integer and fractional portions.
!-

	    LOCAL
		INT_STR_DESC : BLOCK [8, BYTE],
		FRAC_STR_DESC : BLOCK [8, BYTE];

	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP];
	    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS - .KERNEL_BLOCK [DEC_EXP];
	    FRAC_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .KERNEL_BLOCK [DEC_EXP];
	    STATUS = STR$CONCAT (BAS_OUT_STR [0],
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0)
		THEN
		    MINUS_DESC
		ELSE

		    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    , INT_STR_DESC, DOT_DESC, FRAC_STR_DESC,
		BEGIN

		IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

		END
	    );
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES)
	    THEN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    ELSE
		2

	    END
	    + .NO_DIGITS + 1;
	    END

    ELSE
	BEGIN
!+
! This is a purely fractional number which should be put out in F format
!-

	LOCAL
	    ZERO_STR_DESC : BLOCK [8, BYTE],	! desc. for leading zeroes
	    FRAC_STR_DESC : BLOCK [8, BYTE];	! desc. for fraction

	ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZERO_STR_DESC [DSC$W_LENGTH] = -.KERNEL_BLOCK [DEC_EXP];
	ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
	FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	STATUS = STR$CONCAT (BAS_OUT_STR [0],
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0)
	    THEN
		MINUS_DESC
	    ELSE

		IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
	, DOT_DESC, ZERO_STR_DESC, FRAC_STR_DESC,
	    BEGIN

	    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	    END
	);
	BAS_OUT_STR_LEN [0] =
	BEGIN

	IF (.FLAGS AND V_STRIP_SPACES)
	THEN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	ELSE
	    2

	END
	! The exponent is subtracted 'cuz it is negative
	+ .NO_DIGITS - .KERNEL_BLOCK [DEC_EXP] + 1;
	END;

    RETURN .STATUS;
    END;					! PLAIN_F_FORMAT

ROUTINE PLAIN_E_FORM_11 (			!
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN				!
    ) : JSB_FORMAT_A5 =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do plain old E formatting where the value returned is in the range from
!	0 to 1.
!
! FORMAL PARAMETERS:
!
!	NO_DIGITS.rlu.v		number of significant digits in value
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	parameter block for kernel conversion routine
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	Returns STR$_TRU
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    LOCAL
	EXP_STR : VECTOR [3, BYTE],		! string for exponent
	EXP_STR_DESC : BLOCK [8, BYTE],		! Exponent
	FRAC_STR_DESC : BLOCK [8, BYTE],	! Fraction
	STATUS;					! Status returned

    INITIALIZE_DESC;
    EXP_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    EXP_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    EXP_STR_DESC [DSC$W_LENGTH] = 3;
    EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
    FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
    CVTLP (KERNEL_BLOCK [DEC_EXP], %REF (6), KERNEL_BLOCK [DEC_EXP]);
    CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (2), EXP_STR);
    STATUS = STR$CONCAT (BAS_OUT_STR [0],
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0)
	THEN
	    MINUS_DESC
	ELSE

	    IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	END
    , DOT_DESC, FRAC_STR_DESC, E_DESC, EXP_STR_DESC,
	BEGIN

	IF (.FLAGS AND V_STRIP_SPACES) THEN NULL_DESC ELSE BLANK_DESC

	END
    );
    BAS_OUT_STR_LEN [0] =
    BEGIN

    IF (.FLAGS AND V_STRIP_SPACES)
    THEN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

    ELSE
	2

    END
    + .NO_DIGITS + 5;
    RETURN .STATUS;
    END;					! Routine PLAIN_E_FORMAT

ROUTINE FANCY_F_FORM_11 (			!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN				!
    ) : JSB_FORMAT_A10 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do all of the Print Using formatting for F format.
!
! FORMAL PARAMETERS:
!
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	NO_DIGITS.rlu.v		number of significant digits in value
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	parameter block from kernel routine
!	CURRENCY.rt.dx		currency symbol
!	DIGIT_SEP.rt.dx		digit group separator
!	RADIX_PT.rt.dx		radix point
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
	CURRENCY : REF BLOCK [, BYTE],
	DIGIT_SEP : REF BLOCK [, BYTE],
	RADIX_PT : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    LOCAL
	STAR_STR_DESC : BLOCK [8, BYTE],	! desc. for asterisks
	BLANKS_STR_DESC : BLOCK [8, BYTE],	! desc. for leading spaces
	ZERO_STR_DESC : BLOCK [8, BYTE],	! desc. for trailing zeroes
	INT_STR_DESC : BLOCK [8, BYTE];		! desc. for integer portion of number

    INITIALIZE_DESC;

    IF (.KERNEL_BLOCK [DEC_EXP] GTR 0)
    THEN
!+
! The number is greater than or equal to 1
!-

	IF (.KERNEL_BLOCK [DEC_EXP] GEQ .NO_DIGITS)
	THEN
	    BEGIN
!+
! This entire number consists only of integer part.  Put the number
! returned by the conversion routine and optionally some trailing
! zeroes into the return string.
!-
	    INT_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	    ZERO_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS;
	    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
!+
! Take advantage of the fact that negative numbers have to have trailing sign if
! the currency symbol is expected to float.
!-
	    BLANKS_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_CURRENCY) NEQ 0) THEN .CURRENCY [DSC$W_LENGTH] ELSE 0

	    END
	    - 					! currency symbol
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	    ELSE
		0

	    END;				! commas
	    BLANKS_STR_DESC [DSC$A_POINTER] = BLANKS;
	    STAR_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    STAR_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    STAR_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0) THEN (.KERNEL_BLOCK [DEC_EXP] - 1)/3 ELSE 0

	    END;				! commas
	    STAR_STR_DESC [DSC$A_POINTER] = STAR;

	    IF ((.FLAGS AND V_COMMA) EQL 0)
	    THEN
!+
! There are no commas in this number
!-
		STR$CONCAT (BAS_OUT_STR [0],
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN NULL_DESC ELSE BLANKS_STR_DESC),
		    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE IF .KERNEL_BLOCK [SIGN] LSS 0
			THEN MINUS_DESC ELSE NULL_DESC), INT_STR_DESC, ZERO_STR_DESC)
	    ELSE
!+
! There are commas in this number and we need to do some looping on the call to
! concatenate.  The processing got too complex to express in a single call.
!-
		BEGIN

		LOCAL
		    COUNTER,
		    FIRST_GROUP;

		FIRST_GROUP = ((.KERNEL_BLOCK [DEC_EXP] - 1) MOD 3) + 1;
		STR$CONCAT (BAS_OUT_STR [0],
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE NULL_DESC),
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN NULL_DESC ELSE BLANKS_STR_DESC),
		    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE IF .KERNEL_BLOCK [SIGN] LSS 0
			THEN MINUS_DESC ELSE NULL_DESC),
		    (INT_STR_DESC [DSC$W_LENGTH] = MIN (.FIRST_GROUP,
			.NO_DIGITS); INT_STR_DESC));
		COUNTER = .NO_DIGITS - .INT_STR_DESC [DSC$W_LENGTH];
		INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [DSC$W_LENGTH];

		WHILE .COUNTER GTR 0 DO
		    BEGIN
		    INT_STR_DESC [DSC$W_LENGTH] = MIN (.COUNTER, 3);
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .DIGIT_SEP, INT_STR_DESC);
		    INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [
			DSC$W_LENGTH];
		    COUNTER = .COUNTER - .INT_STR_DESC [DSC$W_LENGTH];
		    END;			! WHILE loop

		ZERO_STR_DESC [DSC$W_LENGTH] = (.KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS) MOD 3;

		IF (.ZERO_STR_DESC [DSC$W_LENGTH] NEQ 0)
		THEN
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
			ZERO_STR_DESC);

		ZERO_STR_DESC [DSC$W_LENGTH] = 3;
		COUNTER = (.KERNEL_BLOCK [DEC_EXP] - .NO_DIGITS)/3;

		WHILE (.COUNTER GTR 0) DO
		    BEGIN
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .DIGIT_SEP, ZERO_STR_DESC);
		    COUNTER = .COUNTER - 1;
		    END;			! WHILE loop

		END;

	    ZERO_STR_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS;
	    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
		(IF (.FLAGS AND V_PERIOD) NEQ 0 THEN .RADIX_PT ELSE NULL_DESC), ZERO_STR_DESC,
		(IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN IF .KERNEL_BLOCK [SIGN] LSS 0 THEN MINUS_DESC
		    ELSE BLANK_DESC ELSE NULL_DESC));
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		1
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

		END

	    END
	    + .KERNEL_BLOCK [DEC_EXP] +
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]	! adjust for commas
	    ELSE
		0

	    END
	    +
	    BEGIN

	    IF ((.FLAGS AND V_PERIOD) NEQ 0) THEN .RADIX_PT [DSC$W_LENGTH] ELSE 0

	    END
	    + ZERO_STR_DESC [DSC$W_LENGTH];
	    END
	ELSE
	    BEGIN
!+
! This number has both integer and fractional portions.
!-

	    LOCAL
		FRAC_STR_DESC : BLOCK [8, BYTE];

	    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    INT_STR_DESC [DSC$W_LENGTH] = .KERNEL_BLOCK [DEC_EXP];
	    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS - .KERNEL_BLOCK [DEC_EXP];
	    FRAC_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .KERNEL_BLOCK [DEC_EXP];
	    ZERO_STR_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS - .FRAC_STR_DESC [DSC$W_LENGTH];
	    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
	    BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
!+
! Take advantage of the fact that negative numbers have to have trailing sign if
! the currency symbol is expected to float.
!-
	    BLANKS_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_CURRENCY) NEQ 0) THEN .CURRENCY [DSC$W_LENGTH] ELSE 0

	    END
	    - 					! currency symbol
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	    ELSE
		0

	    END;				! commas
	    BLANKS_STR_DESC [DSC$A_POINTER] = BLANKS;
	    STAR_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    STAR_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    STAR_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .KERNEL_BLOCK [DEC_EXP] -
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		0				! trailing sign
	    ELSE
		BEGIN

		IF .KERNEL_BLOCK [SIGN] LSS 0 THEN 1 ELSE 0

		END

	    END
	    - 					! negative number - leading sign
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]
	    ELSE
		0

	    END;				! commas
	    STAR_STR_DESC [DSC$A_POINTER] = STAR;

	    IF ((.FLAGS AND V_COMMA) EQL 0)
	    THEN
!+
! There are no commas required.
!-
		STR$CONCAT (BAS_OUT_STR [0],
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE BLANKS_STR_DESC),
		    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0
			    THEN MINUS_DESC ELSE NULL_DESC)), INT_STR_DESC)
	    ELSE
!+
! This number should have commas in it.  Do all of the fancy figuring and looping.
!-
		BEGIN

		LOCAL
		    COUNTER,
		    FIRST_GROUP;

		FIRST_GROUP = ((.KERNEL_BLOCK [DEC_EXP] - 1) MOD 3) + 1;
		STR$CONCAT (BAS_OUT_STR [0],
		    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE BLANKS_STR_DESC),
		    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
		    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE IF .KERNEL_BLOCK [SIGN] LSS 0
			THEN MINUS_DESC ELSE NULL_DESC),
		    (INT_STR_DESC [DSC$W_LENGTH] = MIN (.FIRST_GROUP,
			.NO_DIGITS); INT_STR_DESC));
		COUNTER = .KERNEL_BLOCK [DEC_EXP] - .INT_STR_DESC [DSC$W_LENGTH];
		INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [DSC$W_LENGTH];

		WHILE .COUNTER GTR 0 DO
		    BEGIN
		    INT_STR_DESC [DSC$W_LENGTH] = MIN (.COUNTER, 3);
		    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .DIGIT_SEP, INT_STR_DESC);
		    INT_STR_DESC [DSC$A_POINTER] = .INT_STR_DESC [DSC$A_POINTER] + .INT_STR_DESC [
			DSC$W_LENGTH];
		    COUNTER = .COUNTER - .INT_STR_DESC [DSC$W_LENGTH];
		    END;			! WHILE loop

		END;

!+
! And now for a common ending for both parts (comma and non-comma).
!-
	    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0], .RADIX_PT, FRAC_STR_DESC, ZERO_STR_DESC,
		BEGIN

		IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
		THEN
		    BEGIN

		    IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN MINUS_DESC ELSE BLANK_DESC

		    END
		ELSE
		    NULL_DESC

		END
	    );
	    BAS_OUT_STR_LEN [0] =
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		1				! trailing sign
	    ELSE
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

		END

	    END
	    + .NO_INT_DIGITS + .NO_FRAC_DIGITS +
	    BEGIN

	    IF ((.FLAGS AND V_COMMA) NEQ 0)
	    THEN
		(.KERNEL_BLOCK [DEC_EXP] - 1)/3*.DIGIT_SEP [DSC$W_LENGTH]	! adjust for commas
	    ELSE
		0

	    END
	    + .RADIX_PT [DSC$W_LENGTH];		! decimal point
	    END

    ELSE
	BEGIN
!+
! This is a purely fractional number which should be put out in F format
!-

	LOCAL
	    FRAC_STR_DESC : BLOCK [8, BYTE];	! desc. for fraction

!+
! This is the number of zeroes to the right of the decimal point and to the left
! of the first non-zero digit.
!-
	ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ZERO_STR_DESC [DSC$W_LENGTH] = -.KERNEL_BLOCK [DEC_EXP];
	ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
!+
! Put at most one zero to the left of the decimal point
!-
	INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	INT_STR_DESC [DSC$W_LENGTH] = MIN (1,
	    .NO_INT_DIGITS - (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 0	! trailing sign
	    ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 THEN 1 ELSE 0)));
	INT_STR_DESC [DSC$A_POINTER] = ZEROES;
	STAR_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	STAR_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	STAR_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .INT_STR_DESC [DSC$W_LENGTH] -
	BEGIN

	IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	THEN
	    0
	ELSE
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    END

	END;
	STAR_STR_DESC [DSC$A_POINTER] = STAR;
	BLANKS_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	BLANKS_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	BLANKS_STR_DESC [DSC$W_LENGTH] = .NO_INT_DIGITS - .INT_STR_DESC [DSC$W_LENGTH] - (IF (.FLAGS AND
	    V_TRAILING_SIGN) NEQ 0 THEN 0 ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 THEN 1 ELSE 0)) - (IF (.FLAGS
	    AND V_CURRENCY) NEQ 0 THEN 1 ELSE 0);
	BLANKS_STR_DESC [DSC$A_POINTER] = BLANKS;
	FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	FRAC_STR_DESC [DSC$W_LENGTH] = .NO_DIGITS;
	FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
	STR$CONCAT (BAS_OUT_STR [0],
	    (IF (.FLAGS AND V_STAR) NEQ 0 THEN STAR_STR_DESC ELSE BLANKS_STR_DESC),
	    (IF (.FLAGS AND V_CURRENCY) NEQ 0 THEN .CURRENCY ELSE NULL_DESC),
	    (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN NULL_DESC ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 THEN
		    MINUS_DESC ELSE NULL_DESC)), INT_STR_DESC, .RADIX_PT, ZERO_STR_DESC, FRAC_STR_DESC,
	    BEGIN

	    LOCAL
		TEMP_ZERO_DESC : BLOCK [8, BYTE];

	    TEMP_ZERO_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    TEMP_ZERO_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_ZERO_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS - .NO_DIGITS - .ZERO_STR_DESC [DSC$W_LENGTH];
	    TEMP_ZERO_DESC [DSC$A_POINTER] = ZEROES;
	    TEMP_ZERO_DESC
	    END
	,
	    BEGIN

	    IF ((.FLAGS AND V_TRAILING_SIGN) NEQ 0)
	    THEN
		BEGIN

		IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN MINUS_DESC ELSE BLANK_DESC

		END
	    ELSE
		NULL_DESC

	    END
	);
	BAS_OUT_STR_LEN [0] = (IF (.FLAGS AND V_TRAILING_SIGN) NEQ 0 THEN 1	! trailing sign
	ELSE (IF .KERNEL_BLOCK [SIGN] LSS 0 THEN 1 ELSE 0)) + .NO_INT_DIGITS + .NO_FRAC_DIGITS + .RADIX_PT [
	    DSC$W_LENGTH];
	END;

    END;					! Routine FANCY_F_FORMAT

ROUTINE FANCY_E_FORM_11 (			!
	NO_INT_DIGITS, 				!
	NO_FRAC_DIGITS, 			!
	NO_DIGITS, 				!
	FLAGS, 					!
	KERNEL_BLOCK, 				!
	CURRENCY, 				!
	DIGIT_SEP, 				!
	RADIX_PT, 				!
	BAS_OUT_STR, 				!
	BAS_OUT_STR_LEN				!
    ) : JSB_FORMAT_A10 NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Do all of the formatting for Basic Print Using E format.
!
! FORMAL PARAMETERS:
!
!	NO_INT_DIGITS.rlu.r	number of integer digits in output string
!	NO_FRAC_DIGITS.rlu.r	number of fraction digits in output string
!	NO_DIGITS.rlu.v		number of significant digits
!	FLAGS.rlu.v		no flags are applicable
!	KERNEL_BLOCK.mz.r	parameter block for kernel routine
!	CURRENCY.rt.dx		currency symbol - currently unused
!	DIGIT_SEP.rt.dx		digit group separator - currently unused
!	RADIX_PT.rt.dx		radix point
!	BAS_OUT_STR_LEN.wlu.v	length of output string (handy for fixed length
!				output strings
!	BAS_OUT_STR.wt.dx	the output string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	BLANK_STR_DESC : BLOCK [8, BYTE],	! leading blanks for zero
	INT_STR_DESC : BLOCK [8, BYTE],		! integer portion of number
	ZERO_STR_DESC : BLOCK [8, BYTE],	! trailing zeroes
	FRAC_STR_DESC : BLOCK [8, BYTE],	! fractional portion of number
	EXP_STR : VECTOR [3, BYTE],		! string for exponent
	EXP_STR_DESC : BLOCK [8, BYTE];		! Exponent

    MAP
	RADIX_PT : REF BLOCK [, BYTE],
	BAS_OUT_STR_LEN : REF VECTOR,
	BAS_OUT_STR : REF VECTOR [2, LONG],
	KERNEL_BLOCK : REF BLOCK [K_KERNEL_BLK_SZ, BYTE];

    BIND
	ZERO = UPLIT (BYTE ('0'));

    INITIALIZE_DESC;

    IF CH$EQL (1, (.KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET]), 1, ZERO)
    THEN
!+
! Set up for zero.  A few parameters need to be tweaked and then the general al-
! gorithm should work fine.
!-
	BEGIN
	BLANK_STR_DESC [DSC$W_LENGTH] = MAX (.NO_INT_DIGITS - 1, 0);
	ZERO_STR_DESC [DSC$W_LENGTH] = 0;
	EXP_STR = %ASCII'+00';
	END
    ELSE
	BEGIN
	BLANK_STR_DESC [DSC$W_LENGTH] = 0;
	ZERO_STR_DESC [DSC$W_LENGTH] = MAX (.NO_INT_DIGITS - .NO_DIGITS -
	    BEGIN

	    IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	    END
	, 0);
	KERNEL_BLOCK [DEC_EXP] = .KERNEL_BLOCK [DEC_EXP] - .NO_INT_DIGITS +
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	END;					! Add 1 for minus sign
	CVTLP (KERNEL_BLOCK [DEC_EXP], %REF (6), KERNEL_BLOCK [DEC_EXP]);
	CVTPS (%REF (6), KERNEL_BLOCK [DEC_EXP], %REF (2), EXP_STR);
	END;

    BLANK_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    BLANK_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    BLANK_STR_DESC [DSC$A_POINTER] = BLANKS;
    EXP_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    EXP_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    EXP_STR_DESC [DSC$W_LENGTH] = 3;
    EXP_STR_DESC [DSC$A_POINTER] = EXP_STR;
    INT_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    INT_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    INT_STR_DESC [DSC$W_LENGTH] = MIN (.NO_INT_DIGITS -
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	END
    , .NO_DIGITS);
    INT_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + .KERNEL_BLOCK [OFFSET];
    ZERO_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    ZERO_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    ZERO_STR_DESC [DSC$A_POINTER] = ZEROES;
    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN MINUS_DESC ELSE NULL_DESC

	END
    , BLANK_STR_DESC, INT_STR_DESC, ZERO_STR_DESC);
    FRAC_STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    FRAC_STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    FRAC_STR_DESC [DSC$W_LENGTH] = MAX (.NO_DIGITS - .NO_INT_DIGITS +
	BEGIN

	IF (.KERNEL_BLOCK [SIGN] LSS 0) THEN 1 ELSE 0

	END
    , 0);
    FRAC_STR_DESC [DSC$A_POINTER] = .KERNEL_BLOCK [STRING_ADDR] + 	!
    .KERNEL_BLOCK [OFFSET] + .INT_STR_DESC [DSC$W_LENGTH];
    ZERO_STR_DESC [DSC$W_LENGTH] = .NO_FRAC_DIGITS - .FRAC_STR_DESC [DSC$W_LENGTH];
    STR$CONCAT (BAS_OUT_STR [0], BAS_OUT_STR [0],
	BEGIN

	IF ((.FLAGS AND V_PERIOD) NEQ 0) THEN .RADIX_PT ELSE NULL_DESC

	END
    , FRAC_STR_DESC, ZERO_STR_DESC, E_DESC, EXP_STR_DESC);
    BAS_OUT_STR_LEN [0] = .NO_INT_DIGITS + .NO_FRAC_DIGITS +
    BEGIN

    IF (.FLAGS AND V_PERIOD) THEN .RADIX_PT [DSC$W_LENGTH] ELSE 0

    END
    + 4;					! 4 for the exponent
    END;					! Routine FANCY_E_FORM_11
END						!End of module BAS$CVT_OUT

ELUDOM
