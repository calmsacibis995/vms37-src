MODULE STR$ARITH (			!
		IDENT = '1-016'		! File: STRARITH.B32 EDIT:LB1016
		) =
BEGIN
!
!			  COPYRIGHT (c) 1979,1981,1982 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:  STRING Arithmetic
!
! ABSTRACT:
!
!	This module is a large-precision arithmetic package based on
!	decimal strings.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: John Sauter, CREATION DATE: 01-MAR-1979
!
! MODIFIED BY:
!
! 1-001	- Original.  JBS 05-MAR-1979
! 1-002	- Fix reciprocal of numbers between 0 and 1.  JBS 07-MAR-1979
! 1-003	- Treat minus 0 as zero.  JBS 22-MAR-1979
! 1-004	- Improve comments based on the code review.  JBS 26-MAR-1979
! 1-005	- Free local strings in case of an error.  JBS 07-MAY-1979
! 1-006	- Make the entry points take scalars by reference, in honor
!	   of the recognition of STR as a facility.  JBS 15-MAY-1979
! 1-007	- Change OTS$S and LIB$S to STR$.  JBS 21-MAY-1979
! 1-008	- Restore some code deleted by mistake in edit 007.
!	   JBS 22-MAY-1979
! 1-009	- Change calls to STR$COPY.  JBS 16-JUL-1979
! 1-010	- Correct a typo in a comment.  JBS 30-JUL-1979
! 1-011	- When freeing strings after an error, watch out for
!	   descriptors not yet initialized.  JBS 31-JUL-1979
! 1-012 - Added a new entry point - STR$DIVIDE.  Also added related
!	  routines UPDATE_COUNTS,CVT_STR_PACKED and CVT_PACKED_STR.
!	  Also changed the existing string arithmetic routines, so
!	  that they all call LIB$ANALYZE_SDESC, to verify that the
!	  input descriptors are valid.  LB 25-AUG-1981
! 1-013 - Added updated code for STR$DIVIDE as well as ancillary
!	  routines UPDATE_COUNTS,CVT_STR_PACKED, and CVT_PACKED_STR.
!	  LB 16-NOV-81
! 1-014 - Moved code to do the conversions to and from packed decimal
!	  into module LIBPKARIT.  Changed code in STR$DIVIDE to use
!	  left justification of the input strings instead of right
!	  justification.  RNH  11-DEC-81.
! 1-015 - Added code in all string arithmetic routines so that they correctly
!	  handle all string classes.  This required the addition of a new
!	  internal entry point CHK_STR_TYPE.   LB 15-DEC-81.
! 1-016 - Added code in STR$DIVIDE to zeroize a section of 8 bytes to avoid
!	  random data being picked up by the associated packed arithmetic
!	  routines that it calls.  LB 1-APR-82.
!
!--

!<BLF/PAGE>

!+
! SWITCHES:
!-

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!+
! LINKAGES:
!-

LINKAGE
	JSB1 = JSB (REGISTER=6, REGISTER=7) : NOPRESERVE (2,3,4,5),
	JSB2 = JSB (REGISTER=6, REGISTER=7, REGISTER=8) : NOPRESERVE (2,3,4,5),
	JSB3 = JSB (REGISTER=6, REGISTER=7, REGISTER=8, REGISTER=9)
		   : NOPRESERVE (2,3,4,5),
	JSB4 = JSB (REGISTER=6, REGISTER=7, REGISTER=8, REGISTER=9, REGISTER=10)
		   : NOPRESERVE (2,3,4,5);


!+
! TABLE OF CONTENTS:
!-

FORWARD ROUTINE
    STR$ADD : NOVALUE,				! Add two strings
    STR$MUL : NOVALUE,				! Multiply two strings
    STR$RECIP : NOVALUE,			! Take the reciprocal of a string
    STR$ROUND : NOVALUE,			! Round a string
    STR$DIVIDE: NOVALUE,			! Divide two strings
    CHK_STR_TYPE:NOVALUE,			! Check the string type
    FREE_STRINGS;				! Free local strings

!+
! INCLUDE FILES:
!-

REQUIRE 'RTLIN:RTLPSECT';			! Macros for defining psects
LIBRARY 'RTLSTARLE';				! System definitions

!+
! MACROS:
!
!	NONE
!-

!+
! PSECTS:
!-

DECLARE_PSECTS (STR);				! Declare psects for STR$ facility

!+
! OWN STORAGE:
!
!	NONE
!-

!+
! EXTERNAL REFERENCES:
!-

EXTERNAL ROUTINE
	LIB$STOP,			! Signal fatal error
	STR$GET1_DX,			! Allocate a string
	STR$FREE1_DX,			! Deallocate a string
	STR$COPY_R,			! Copy a string by reference
	STR$COPY_DX,			! Copy a string by descriptor
	LIB$GET_VM:,			! Allocate virtual memory
	LIB$FREE_VM:,			! Deallocate virtual memory
	LIB$SCOPY_R_DX,			! Copy a string by reference
	LIB$$ROUND_R7:JSB1 NOVALUE,	! Rounds quotient to correct length
	LIB$$CALC_D_R7:JSB1,		! Calculates normalization factor
	LIB$$CALC_Q_R9:JSB3,		! Calculates one quotient digit
	LIB$$SUB_PACK_R8:JSB2,		! Subtracts two decimal arrays
	LIB$$MUL_PACK_R10:JSB4 NOVALUE,	! Multiplies a packed array by a single
					!    entry
	LIB$$ADJUST_Q_R9:JSB3 NOVALUE,	! Adjusts intermediate results of divi-
					!    sion algorithm if initial quess at
					!    a quotient digit is wrong
	LIB$$CVT_STR_PACK_R9:JSB3 NOVALUE,
					! Converts a string of decimal digits 
					!    to an array of packed decimal 
					!    values
	LIB$$CVT_PACK_STR_R8:JSB2 NOVALUE,	
					! Converts an array of packed decimal
					!    values to a string
	LIB$ANALYZE_SDESC,		! Extract length and addr of a given 
					!    descriptor and validate inputs
        LIB$MATCH_COND,			! Match condition codes
	STR$DUPL_CHAR;			! Used to pad result with leading zeroes

BIND
	ZERO = UPLIT BYTE (REP 7 OF (%X'00'),%X'0C'), ! Packed zero
	SPANC_TABLE = UPLIT BYTE (REP 48 OF (%X'00'), REP 10 OF (%X'01'),
                                 REP 198 OF (%X'00')),
	MASK = UPLIT BYTE (REP 1 OF (%X'01'));

BUILTIN
	CMPP,				! Compare packed decimal data
	MOVP,				! Move packed decimal data
	SPANC;				! Skip over a set of characters in a character string

!+
! The following are the error codes produced by this module.
!-

EXTERNAL LITERAL
    LIB$_INVARG,				! Invalid argument
    STR$_DIVBY_ZER,				! Divide by zero.
    STR$_WRONUMARG;				! Wrong number of arguments



GLOBAL ROUTINE STR$ADD (			! Add two strings
	ASIGN, 					! Sign of operand A
	AEXP, 					! Decimal exponent of operand A
	ADIGITS, 				! Digits of operand A
	BSIGN, 					! Sign of operand B
	BEXP, 					! Decimal exponent of operand B
	BDIGITS, 				! Digits of operand B
	CSIGN, 					! Sign of operand C
	CEXP, 					! Decimal exponent of operand C
	CDIGITS					! Digits of operand C
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Add two decimal numbers.  C := A + B
!
! FORMAL PARAMETERS:
!
!	ASIGN.rv.r	0 = operand A is positive, 1 = negative
!	AEXP.rl.r	Power of 10 by which to multiply the operand A
!			digits to get the absolute value of operand A.
!			E.g., AEXP = 1, ADIGITS = 123 gives 1230.
!	ADIGITS.rnu.d	Descriptor for the digits of operand A
!	BSIGN.rv.r	0 = operand B is positive, 1 = negative
!	BEXP.rl.r	Power of 10 by which to multiply the operand B
!			digits to get the absolute value of operand B.
!			E.g., BEXP = -1, BDIGITS = 123 gives 12.3.
!	BDIGITS.rnu.d	Descriptor for the digits of operand B
!	CSIGN.wl.r	0 = operand C is positive, 1 = negative
!	CEXP.wl.r	Power of 10 by which to multiply the operand C
!			digits to get the absolute value of operand C.
!			E.g., CEXP = 0, CDIGITS = 123 gives 123.
!	CDIGITS.wnu.d	Descriptor for the digits of operand C
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May allocate space for the CDIGITS string.
!	Signals if storage is exceeded.
!--

    BEGIN

    MAP
	ADIGITS : REF BLOCK [8, BYTE],
	BDIGITS : REF BLOCK [8, BYTE],
	CDIGITS : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of A
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	ABUF : REF VECTOR [65535, BYTE],
	A_LEN,
	A_SIGN,
!+
! Internal form of B
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	BBUF : REF VECTOR [65535, BYTE],
	B_LEN,
	B_SIGN,
!+
! Local copy of result.
!-
	RSIGN,
	REXP,
	R_DESC : BLOCK [8, BYTE] VOLATILE,
	RBUF : REF VECTOR [65535, BYTE],	! Addresses result
	R_LEN,					! Length of result
	RESULT_DIGITS,				! Number of digits in result

!+
! The following locals are needed for calls to LIB$ANALYZE_SDESC.
!-
	CBUF,
	C_LEN,
	STATUS;


    BUILTIN
	ACTUALCOUNT;

!+
! Enable a handler to free the local strings in case of an error.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, R_DESC);

!+
! Check for the proper number of arguments.
!-

    IF (ACTUALCOUNT () LSS 9)
    THEN
	BEGIN

	LOCAL
	    ROUT_NAME_DESC : BLOCK [8, BYTE];

	ROUT_NAME_DESC [DSC$W_LENGTH] = 7;
	ROUT_NAME_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ROUT_NAME_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ROUT_NAME_DESC [DSC$A_POINTER] = UPLIT (%ASCII'STR$ADD');
	LIB$STOP (STR$_WRONUMARG, 2, ACTUALCOUNT (), ROUT_NAME_DESC);
	END;

!+
! Copy the A and B operands, taking the tens complement of the negative
! ones.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand A.  Only the leading digits count.
! (Somday use SCAN or SPAN for this.)
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then ABUF will contain the address of the
! first byte of the string, and A_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.ADIGITS,A_LEN,ABUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

!+
! Check here for the CDIGITS descriptor before getting too involved
! in the routine.
!-

    STATUS = LIB$ANALYZE_SDESC (.CDIGITS,C_LEN,CBUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);
    A_LEN = 0;
    A_SIGN = ..ASIGN;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.A_LEN EQLU .ADIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.ABUF [.A_LEN] GEQ %C'0') AND (.ABUF [.A_LEN] LEQ %C'9'))
	    THEN
		A_LEN = .A_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    A_LEN = .A_LEN + 1;				! Extra digit for sign
    STR$GET1_DX (A_LEN, A_DESC);
    ABUF = .A_DESC [DSC$A_POINTER];
    ABUF [0] = %C'0';
    CH$MOVE (.A_LEN - 1, .ADIGITS [DSC$A_POINTER], ABUF [1]);

    IF (.A_SIGN)
    THEN
	BEGIN
!+
! Take the tens complement of the A operand.  This is done by
! subtracting each digit from 9, and adding 1 to the result.  The final
! add can cause carries.
!-

	DECR COUNTER FROM .A_LEN - 1 TO 0 DO
	    ABUF [.COUNTER] = (9 - (.ABUF [.COUNTER] - %C'0')) + %C'0';

	BEGIN

	LOCAL
	    CARRY_DONE,
	    CARRY_COUNTER;

	CARRY_DONE = 0;
	CARRY_COUNTER = .A_LEN - 1;

	IF (.CARRY_COUNTER GEQ 0)
	THEN

	    DO
		BEGIN
		ABUF [.CARRY_COUNTER] = .ABUF [.CARRY_COUNTER] + 1;

		IF (.ABUF [.CARRY_COUNTER] LEQ %C'9')
		THEN
		    CARRY_DONE = 1
		ELSE
		    BEGIN
		    ABUF [.CARRY_COUNTER] = .ABUF [.CARRY_COUNTER] - 10;
		    CARRY_COUNTER = .CARRY_COUNTER - 1;
		    END;

		END
	    UNTIL ((.CARRY_DONE) OR (.CARRY_COUNTER LSS 0));

	IF ( NOT .CARRY_DONE) THEN A_SIGN = 0;

	END;
	END;

    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand B.  Only the leading digits count.
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then BBUF will contain the address of the
! first byte of the string, and B_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.BDIGITS,B_LEN,BBUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);
    B_LEN = 0;
    B_SIGN = ..BSIGN;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.B_LEN EQLU .BDIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.BBUF [.B_LEN] GEQ %C'0') AND (.BBUF [.B_LEN] LEQ %C'9'))
	    THEN
		B_LEN = .B_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    B_LEN = .B_LEN + 1;				! Extra digit for sign
    STR$GET1_DX (B_LEN, B_DESC);
    BBUF = .B_DESC [DSC$A_POINTER];
    BBUF [0] = %C'0';
    CH$MOVE (.B_LEN - 1, .BDIGITS [DSC$A_POINTER], BBUF [1]);

    IF (.B_SIGN)
    THEN
	BEGIN
!+
! Take the tens complement of the B operand.  This is done by
! subtracting each digit from 9, and adding 1 to the result.  The final
! add can cause carries.
!-

	DECR COUNTER FROM .B_LEN - 1 TO 0 DO
	    BBUF [.COUNTER] = (9 - (.BBUF [.COUNTER] - %C'0')) + %C'0';

	BEGIN

	LOCAL
	    CARRY_DONE,
	    CARRY_COUNTER;

	CARRY_DONE = 0;
	CARRY_COUNTER = .B_LEN - 1;

	IF (.CARRY_COUNTER GEQ 0)
	THEN

	    DO
		BEGIN
		BBUF [.CARRY_COUNTER] = .BBUF [.CARRY_COUNTER] + 1;

		IF (.BBUF [.CARRY_COUNTER] LEQ %C'9')
		THEN
		    CARRY_DONE = 1
		ELSE
		    BEGIN
		    BBUF [.CARRY_COUNTER] = .BBUF [.CARRY_COUNTER] - 10;
		    CARRY_COUNTER = .CARRY_COUNTER - 1;
		    END;

		END
	    UNTIL ((.CARRY_DONE) OR (.CARRY_COUNTER LSS 0));

	IF ( NOT .CARRY_DONE) THEN B_SIGN = 0;

	END;
	END;

!+
! Compute a tenative result exponent based on the smallest exponent
! in either A or B.
!-
    REXP = MIN (..AEXP, ..BEXP);
!+
! Allocate enough space to hold the maximum possible number of result
! digits.  This is done by spanning the powers of ten involved in the
! two input operands, and adding 1 for carry.
!-
    RESULT_DIGITS = (MAX (..AEXP + .A_LEN, ..BEXP + .B_LEN)) + 1 - .REXP;
    R_DESC [DSC$W_LENGTH] = 0;
    R_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    R_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    R_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (RESULT_DIGITS, R_DESC);
    RBUF = .R_DESC [DSC$A_POINTER];
    R_LEN = .R_DESC [DSC$W_LENGTH];
!+
! Copy the A operand into the result string, offsetting it properly
! based on the exponents.
!-
    CH$FILL (%C'0', .R_LEN, .R_DESC [DSC$A_POINTER]);
    CH$MOVE (.A_LEN, .A_DESC [DSC$A_POINTER], 	!
	.R_DESC [DSC$A_POINTER] + .R_LEN - (..AEXP - .REXP) - .A_LEN);
!+
! If the A operand was negative we owe high-order nines.
!-

    IF (.A_SIGN) THEN CH$FILL (%C'9', (.R_LEN - .A_LEN) - (..AEXP - .REXP), .R_DESC [DSC$A_POINTER]);

!+
! Now add in the B operand.
!-

    DECR COUNTER FROM (.R_LEN - 1 - (..BEXP - .REXP)) TO (.R_LEN - 1 - (..BEXP - .REXP) - (.B_LEN - 1)) DO
	BEGIN

	LOCAL
	    B_INDEX,
	    SUM;

	B_INDEX = .COUNTER - (.R_LEN - 1 - (..BEXP - .REXP) - (.B_LEN - 1));
	SUM = .RBUF [.COUNTER] + .BBUF [.B_INDEX] - %C'0';

	IF (.SUM GTR %C'9')
	THEN
	    BEGIN
!+
! We must propagate a carry to the higher digits of RBUF
!-

	    LOCAL
		CARRY_DONE,
		CARRY_COUNTER;

	    RBUF [.COUNTER] = .SUM - 10;
	    CARRY_DONE = 0;
	    CARRY_COUNTER = .COUNTER - 1;

	    IF (.CARRY_COUNTER GEQ 0)
	    THEN

		DO
		    BEGIN
		    RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] + 1;

		    IF (.RBUF [.CARRY_COUNTER] LEQ %C'9')
		    THEN
			CARRY_DONE = 1
		    ELSE
			BEGIN
			RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] - 10;
			CARRY_COUNTER = .CARRY_COUNTER - 1;
			END;

		    END
		UNTIL ((.CARRY_DONE) OR (.CARRY_COUNTER LSS 0));

	    END
	ELSE
	    RBUF [.COUNTER] = .SUM;

	END;

!+
! End of the DECR loop.
!-
!+
! If the B operand is negative, we owe high-order nines.
!-

    IF (.B_SIGN)
    THEN
	BEGIN

	DECR COUNTER FROM ((.R_LEN - 1 - (..BEXP - .REXP) - (.B_LEN - 1)) - 1) TO 0 DO
	    BEGIN

	    LOCAL
		SUM;

	    SUM = .RBUF [.COUNTER] + 9;

	    IF (.SUM GTR %C'9')
	    THEN
		BEGIN
!+
! We must propagate a carry to the higher digits of RBUF
!-

		LOCAL
		    CARRY_DONE,
		    CARRY_COUNTER;

		RBUF [.COUNTER] = .SUM - 10;
		CARRY_DONE = 0;
		CARRY_COUNTER = .COUNTER - 1;

		IF (.CARRY_COUNTER GEQ 0)
		THEN

		    DO
			BEGIN
			RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] + 1;

			IF (.RBUF [.CARRY_COUNTER] LEQ %C'9')
			THEN
			    CARRY_DONE = 1
			ELSE
			    BEGIN
			    RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] - 10;
			    CARRY_COUNTER = .CARRY_COUNTER - 1;
			    END;

			END
		    UNTIL ((.CARRY_DONE) OR (.CARRY_COUNTER LSS 0));

		END
	    ELSE
		RBUF [.COUNTER] = .SUM;

	    END;

	END;

!+
! Compute the sign of the result and recomplement it if negative.
!-

    IF (.RBUF [0] GEQ %C'5')
    THEN
	BEGIN
	RSIGN = 1;

	DECR COUNTER FROM .R_LEN - 1 TO 0 DO
	    RBUF [.COUNTER] = (9 - (.RBUF [.COUNTER] - %C'0')) + %C'0';

	BEGIN

	LOCAL
	    CARRY_DONE,
	    CARRY_COUNTER;

	CARRY_DONE = 0;
	CARRY_COUNTER = .R_LEN - 1;

	IF (.CARRY_COUNTER GEQ 0)
	THEN

	    DO
		BEGIN
		RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] + 1;

		IF (.RBUF [.CARRY_COUNTER] LEQ %C'9')
		THEN
		    CARRY_DONE = 1
		ELSE
		    BEGIN
		    RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] - 10;
		    CARRY_COUNTER = .CARRY_COUNTER - 1;
		    END;

		END
	    UNTIL ((.CARRY_DONE) OR (.CARRY_COUNTER LSS 0));

	END;
	END
    ELSE
	RSIGN = 0;

!+
! Discard low-order zeros, adjusting the exponent.
!-
    BEGIN

    LOCAL
	SCAN_DONE,
	SCAN_COUNTER;

    SCAN_DONE = 0;
    SCAN_COUNTER = .RESULT_DIGITS - 1;

    DO
	BEGIN

	IF (.SCAN_COUNTER LSS 0)
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF (.RBUF [.SCAN_COUNTER] EQL %C'0') THEN SCAN_COUNTER = .SCAN_COUNTER - 1 ELSE SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    REXP = .REXP + ((.RESULT_DIGITS - 1) - .SCAN_COUNTER);
    RESULT_DIGITS = .SCAN_COUNTER + 1;
    END;
!+
! Remove high-order zeros.
!-
    BEGIN

    LOCAL
	SCAN_DONE,
	SCAN_COUNTER;

    SCAN_COUNTER = 0;
    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.SCAN_COUNTER GEQ .RESULT_DIGITS)
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF (.RBUF [.SCAN_COUNTER] EQL %C'0') THEN SCAN_COUNTER = .SCAN_COUNTER + 1 ELSE SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    IF (.SCAN_COUNTER GTR 0)
    THEN

	INCR COUNTER FROM 0 TO .RESULT_DIGITS - .SCAN_COUNTER - 1 DO
	    RBUF [.COUNTER] = .RBUF [.COUNTER + .SCAN_COUNTER];

    RESULT_DIGITS = .RESULT_DIGITS - .SCAN_COUNTER;
    END;
!+
! Return the results to the caller in the C operand.
! If there are no digits left, return a single zero digit.
!-

    IF (.RESULT_DIGITS EQL 0)
    THEN
	BEGIN
	.CSIGN = 0;
	.CEXP = 0;
	STR$COPY_R (.CDIGITS, %REF (1), %REF (%ASCII'0'));
	CHK_STR_TYPE (.CDIGITS[DSC$A_POINTER],%REF (1),.CDIGITS);
	END

!+
! Call CHK_STR_TYPE to determine if we need to pad the number with
! leading zeroes depending on the string type.
!-

    ELSE
	BEGIN
	.CSIGN = .RSIGN;
	.CEXP = .REXP;
	CHK_STR_TYPE (.R_DESC[DSC$A_POINTER],RESULT_DIGITS,.CDIGITS);
	END;

!    ELSE
!	BEGIN
!	.CSIGN = .RSIGN;
!	.CEXP = .REXP;
!	STR$COPY_R (.CDIGITS, RESULT_DIGITS, .R_DESC [DSC$A_POINTER]);
!	END;


!+
! Free our strings.
!-
    STR$FREE1_DX (R_DESC);
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
    END;					! end of STR$ADD


GLOBAL ROUTINE STR$MUL (			! Multiply two strings
	ASIGN, 					! Sign of operand A
	AEXP, 					! Decimal exponent of operand A
	ADIGITS, 				! Digits of operand A
	BSIGN, 					! Sign of operand B
	BEXP, 					! Decimal exponent of operand B
	BDIGITS, 				! Digits of operand B
	CSIGN, 					! Sign of operand C
	CEXP, 					! Decimal exponent of operand C
	CDIGITS					! Digits of operand C
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Multiply two decimal numbers.  C := A * B
!
! FORMAL PARAMETERS:
!
!	ASIGN.rv.r	0 = operand A is positive, 1 = negative
!	AEXP.rl.r	Power of 10 by which to multiply the operand A
!			digits to get the absolute value of operand A.
!			E.g., AEXP = 1, ADIGITS = 123 gives 1230.
!	ADIGITS.rnu.d	Descriptor for the digits of operand A
!	BSIGN.rv.r	0 = operand B is positive, 1 = negative
!	BEXP.rl.r	Power of 10 by which to multiply the operand B
!			digits to get the absolute value of operand B.
!			E.g., BEXP = -1, BDIGITS = 123 gives 12.3.
!	BDIGITS.rnu.d	Descriptor for the digits of operand B
!	CSIGN.wl.r	0 = operand C is positive, 1 = negative
!	CEXP.wl.r	Power of 10 by which to multiply the operand C
!			digits to get the absolute value of operand C.
!			E.g., CEXP = 0, CDIGITS = 123 gives 123.
!	CDIGITS.wnu.d	Descriptor for the digits of operand C
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May allocate space for the CDIGITS string.
!	Signals if storage is exhausted.
!--

    BEGIN

    MAP
	ADIGITS : REF BLOCK [8, BYTE],
	BDIGITS : REF BLOCK [8, BYTE],
	CDIGITS : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of A.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	ABUF : REF VECTOR [65535, BYTE],
	A_LEN,
	A_SIGN,
!+
! Internal form of B.
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	BBUF : REF VECTOR [65535, BYTE],
	B_LEN,
	B_SIGN,
!+
! Local copy of result.
!-
	RSIGN,
	REXP,
	R_DESC : BLOCK [8, BYTE] VOLATILE,
	RBUF : REF VECTOR [65535, BYTE],
	R_LEN,

!+
! The following are locals for the call to LIB$ANALYZE_SDESC.
!-
	CBUF,
	C_LEN,
	STATUS;

    BUILTIN
	ACTUALCOUNT;

!+
! Enable a handler to free the local strings in case of an error.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, R_DESC);

!+
! Check the number of arguments.
!-

    IF (ACTUALCOUNT () LSS 9)
    THEN
	BEGIN

	LOCAL
	    ROUT_NAME_DESC : BLOCK [8, BYTE];

	ROUT_NAME_DESC [DSC$W_LENGTH] = 7;
	ROUT_NAME_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ROUT_NAME_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ROUT_NAME_DESC [DSC$A_POINTER] = UPLIT (%ASCII'STR$MUL');
	LIB$STOP (STR$_WRONUMARG, 2, ACTUALCOUNT (), ROUT_NAME_DESC);
	END;

!+
! Copy the A and B operands.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand A.  Only the leading digits count.
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then ABUF will contain the address of the
! first byte of the string, and A_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.ADIGITS,A_LEN,ABUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

!+
! Check here also for the CDIGITS descriptor before we get too
! involved in the routine.
!-

    STATUS = LIB$ANALYZE_SDESC (.CDIGITS,C_LEN,CBUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

    A_LEN = 0;
    A_SIGN = ..ASIGN;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.A_LEN EQLU .ADIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.ABUF [.A_LEN] GEQ %C'0') AND (.ABUF [.A_LEN] LEQ %C'9'))
	    THEN
		A_LEN = .A_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    STR$GET1_DX (A_LEN, A_DESC);
    ABUF = .A_DESC [DSC$A_POINTER];
    CH$MOVE (.A_LEN, .ADIGITS [DSC$A_POINTER], ABUF [0]);
    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand B.  Only the leading digits count.
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then BBUF will contain the address of the
! first byte of the string, and B_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.BDIGITS,B_LEN,BBUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);
    B_LEN = 0;
    B_SIGN = ..BSIGN;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.B_LEN EQLU .BDIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.BBUF [.B_LEN] GEQ %C'0') AND (.BBUF [.B_LEN] LEQ %C'9'))
	    THEN
		B_LEN = .B_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    STR$GET1_DX (B_LEN, B_DESC);
    BBUF = .B_DESC [DSC$A_POINTER];
    CH$MOVE (.B_LEN, .BDIGITS [DSC$A_POINTER], BBUF [0]);
!+
! Set the accumulator to zero.
!-
    R_DESC [DSC$W_LENGTH] = 0;
    R_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    R_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    R_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (%REF (1), R_DESC);
    RBUF = .R_DESC [DSC$A_POINTER];
    R_LEN = .R_DESC [DSC$W_LENGTH];
    RBUF [0] = %C'0';
    RSIGN = 0;
    REXP = 0;
!+
! Go through each digit of B, adding appropriately shifted A to
! R the indicated number of times.  This is like the old mechanical
! adding machines.
!-

    INCR POS FROM 0 TO .B_LEN - 1 DO
	BEGIN

	LOCAL
	    DIGIT;

	DIGIT = .BBUF [(.B_LEN - 1) - .POS];

	DECR COUNTER FROM .DIGIT TO %C'1' DO
	    STR$ADD (%REF (0), POS, A_DESC, RSIGN, REXP, R_DESC, RSIGN, REXP, R_DESC);

	END;

!+
! Compute the exponent and sign of the result.
!-
    REXP = .REXP + (..AEXP + ..BEXP);
    RSIGN = (IF (.A_SIGN EQL .B_SIGN) THEN 0 ELSE 1);
!+
! Return the result to the caller.  Because it is the output of STR$ADD
! it is already in normal form.
!-
    .CSIGN = .RSIGN;
    .CEXP = .REXP;

!+
! Call CHK_STR_TYPE to determine if we need to pad the number with
! leading zeroes depending on the string type.
!-

    R_LEN = .R_DESC[DSC$W_LENGTH];
    CHK_STR_TYPE (.R_DESC[DSC$A_POINTER],R_LEN,.CDIGITS);


!   STR$COPY_DX (.CDIGITS, R_DESC);
!+
! Free our strings.
!-
    STR$FREE1_DX (R_DESC);
    STR$FREE1_DX (A_DESC);
    STR$FREE1_DX (B_DESC);
    END;					! end of STR$MUL


GLOBAL ROUTINE STR$RECIP (			! Take the reciprocal of a string
	ASIGN, 					! Sign of operand A
	AEXP, 					! Decimal exponent of operand A
	ADIGITS, 				! Digits of operand A
	BSIGN, 					! Sign of operand B
	BEXP, 					! Decimal exponent of operand B
	BDIGITS, 				! Digits of operand B
	CSIGN, 					! Sign of operand C
	CEXP, 					! Decimal exponent of operand C
	CDIGITS					! Digits of operand C
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Take the reciprocal of A, to precision B.  C := 1 / A
!
! FORMAL PARAMETERS:
!
!	ASIGN.rv.l	0 = operand A is positive, 1 = negative
!	AEXP.rl.l	Power of 10 by which to multiply the operand A
!			digits to get the absolute value of operand A.
!			E.g., AEXP = 1, ADIGITS = 123 gives 1230.
!	ADIGITS.rnu.d	Descriptor for the digits of operand A
!	BSIGN.rv.l	0 = operand B is positive, 1 = negative
!	BEXP.rl.r	Power of 10 by which to multiply the operand B
!			digits to get the absolute value of operand B.
!			E.g., BEXP = -1, BDIGITS = 123 gives 12.3.
!	BDIGITS.rnu.d	Descriptor for the digits of operand B
!	CSIGN.wl.r	0 = operand C is positive, 1 = negative
!	CEXP.wl.r	Power of 10 by which to multiply the operand C
!			digits to get the absolute value of operand C.
!			E.g., CEXP = 0, CDIGITS = 123 gives 123.
!	CDIGITS.wnu.d	Descriptor for the digits of operand C
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May allocate space for the CDIGITS string.
!	Signals if memory is exausted.
!	Signals Division by zero if operand A is zero.
!
!--

    BEGIN

    MAP
	ADIGITS : REF BLOCK [8, BYTE],
	BDIGITS : REF BLOCK [8, BYTE],
	CDIGITS : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of A.
!-
	A_DESC : BLOCK [8, BYTE] VOLATILE,
	A_BUF : REF VECTOR [65535, BYTE],
	A_LEN,
	A_SIGN,
!+
! Internal form of B.
!-
	B_DESC : BLOCK [8, BYTE] VOLATILE,
	B_BUF : REF VECTOR [65535, BYTE],
	B_LEN,
	B_SIGN,
!+
! The following are various auxiliary variables required to do the division
! and check for its completion.
!-
	X_SIGN,
	X_EXP,
	X_DESC : BLOCK [8, BYTE] VOLATILE,
	X_BUF : REF VECTOR [65535, BYTE],
	X2_SIGN,
	X2_EXP,
	X2_DESC : BLOCK [8, BYTE] VOLATILE,
	X2_BUF : REF VECTOR [65535, BYTE],
	Q_SIGN,
	Q_EXP,
	Q_DESC : BLOCK [8, BYTE] VOLATILE,
	Q_BUF : REF VECTOR [65535, BYTE],
	QLEN,				      ! Added for call to CHK_STR_TYPE
	XA_SIGN,
	XA_EXP,
	XA_DESC : BLOCK [8, BYTE] VOLATILE,
	XA_BUF : REF VECTOR [65535, BYTE],
	DELTA_SIGN,
	DELTA_EXP,
	DELTA_DESC : BLOCK [8, BYTE] VOLATILE,
	DELTA_BUF : REF VECTOR [65535, BYTE],
	ONE_DESC : BLOCK [8, BYTE],
	ONE_BUF : VECTOR [1, BYTE],
	ITER_DONE,				! 1 = the division process is done, exit its loop
	POS,					! Power of ten by which we are dividing (shifting right)

!+
! The following are locals needed for calls to LIB$ANALYZE_SDESC.
!-
	CBUF,
	C_LEN,
	STATUS;

    BUILTIN
	ACTUALCOUNT;

!+
! Enable a handler to free the local strings in case of an error.
!-

    ENABLE
	FREE_STRINGS (A_DESC, B_DESC, X_DESC, X2_DESC, Q_DESC, XA_DESC, DELTA_DESC);

!+
! Check for the proper number of arguments.
!-

    IF (ACTUALCOUNT () LSS 9)
    THEN
	BEGIN

	LOCAL
	    ROUT_NAME_DESC : BLOCK [8, BYTE];

	ROUT_NAME_DESC [DSC$W_LENGTH] = 9;
	ROUT_NAME_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ROUT_NAME_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ROUT_NAME_DESC [DSC$A_POINTER] = UPLIT (%ASCII'STR$RECIP');
	LIB$STOP (STR$_WRONUMARG, 2, ACTUALCOUNT (), ROUT_NAME_DESC);
	END;

!+
! Copy the A and B operands.
!-
    A_DESC [DSC$W_LENGTH] = 0;
    A_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    A_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    A_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand A.  Only the leading digits count.
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then A_BUF will contain the address of the
! first byte of the string, and A_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.ADIGITS,A_LEN,A_BUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

!+
! Also check here for the CDIGITS descriptor before getting too
! involved in the routine.
!-

    STATUS = LIB$ANALYZE_SDESC (.CDIGITS,C_LEN,CBUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

    A_LEN = 0;
    A_SIGN = ..ASIGN;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.A_LEN EQLU .ADIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.A_BUF [.A_LEN] GEQ %C'0') AND (.A_BUF [.A_LEN] LEQ %C'9'))
	    THEN
		A_LEN = .A_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    STR$GET1_DX (A_LEN, A_DESC);
    A_BUF = .A_DESC [DSC$A_POINTER];
    CH$MOVE (.A_LEN, .ADIGITS [DSC$A_POINTER], A_BUF [0]);
!+
! If operand A is zero, fail.
!-

    IF CH$EQL (1, CH$PTR (UPLIT ('0')), .A_LEN, A_BUF [0], %C'0') THEN LIB$STOP (STR$_DIVBY_ZER);

    B_DESC [DSC$W_LENGTH] = 0;
    B_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    B_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    B_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand B.  Only the leading digits count.
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then B_BUF will contain the address of the
! first byte of the string, and B_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.BDIGITS,B_LEN,B_BUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);
    B_LEN = 0;
    B_SIGN = ..BSIGN;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.B_LEN EQLU .BDIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.B_BUF [.B_LEN] GEQ %C'0') AND (.B_BUF [.B_LEN] LEQ %C'9'))
	    THEN
		B_LEN = .B_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    STR$GET1_DX (B_LEN, B_DESC);
    B_BUF = .B_DESC [DSC$A_POINTER];
    CH$MOVE (.B_LEN, .BDIGITS [DSC$A_POINTER], B_BUF [0]);
!+
! Initialize the auxiliary variables.
!-
    X_DESC [DSC$W_LENGTH] = 0;
    X_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    X_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    X_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (%REF (1), X_DESC);
    X_BUF = .X_DESC [DSC$A_POINTER];
    X_BUF [0] = %C'1';
    X_SIGN = 0;
    X_EXP = 0;
!
    X2_DESC [DSC$W_LENGTH] = 0;
    X2_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    X2_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    X2_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (%REF (1), X2_DESC);
    X2_BUF = .X2_DESC [DSC$A_POINTER];
    X2_BUF [0] = %C'0';
    X2_SIGN = 0;
    X2_EXP = 0;
!
    Q_DESC [DSC$W_LENGTH] = 0;
    Q_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    Q_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    Q_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (%REF (1), Q_DESC);
    Q_BUF = .Q_DESC [DSC$A_POINTER];
    Q_BUF [0] = %C'0';
    Q_SIGN = 0;
    Q_EXP = 0;
!
    XA_DESC [DSC$W_LENGTH] = 0;
    XA_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    XA_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    XA_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (%REF (1), XA_DESC);
    XA_BUF = .XA_DESC [DSC$A_POINTER];
    XA_BUF [0] = %C'0';
    XA_SIGN = 0;
    XA_EXP = 0;
!
    DELTA_DESC [DSC$W_LENGTH] = 0;
    DELTA_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    DELTA_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    DELTA_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (%REF (1), DELTA_DESC);
    DELTA_BUF = .DELTA_DESC [DSC$A_POINTER];
    DELTA_BUF [0] = %C'0';
    DELTA_SIGN = 0;
    DELTA_EXP = 0;
!
    ONE_DESC [DSC$W_LENGTH] = 1;
    ONE_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    ONE_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    ONE_DESC [DSC$A_POINTER] = ONE_BUF;
    ONE_BUF [0] = %C'1';
!+
! Decide on the best position to start forming the quotient.  Unless
! the divisor is 1, the first subtract will cause X to go negative
! and force us to back off.
!-
    POS = -.X_EXP;
!+
! Iterate until we are close to the quotient.
! If B = 0, this will take a long time.
!-
    ITER_DONE = 0;

    DO
	BEGIN
	STR$ADD (X_SIGN, X_EXP, X_DESC, 	!
	    %REF (1), %REF (..AEXP + .POS), A_DESC, 	!
	    X_SIGN, X_EXP, X_DESC);
!+
! If we have gone negative, back off.  Otherwise increase the quotient.
!-

	IF (.X_SIGN)
	THEN
	    BEGIN
	    STR$ADD (X_SIGN, X_EXP, X_DESC, 	!
		%REF (0), %REF (..AEXP + .POS), A_DESC, 	!
		X_SIGN, X_EXP, X_DESC);
!+
! Go down to the next lower digit
!-
	    POS = .POS - 1;
!+
! Now see if we are close enough to the reciprocal.
!-
	    STR$MUL (Q_SIGN, Q_EXP, Q_DESC, 	!
		%REF (0), .AEXP, A_DESC, 	!
		XA_SIGN, XA_EXP, XA_DESC);
	    STR$ADD (XA_SIGN, XA_EXP, XA_DESC, 	!
		%REF (1), %REF (0), ONE_DESC, 	!
		DELTA_SIGN, DELTA_EXP, DELTA_DESC);
	    DELTA_SIGN = 0;
	    STR$ADD (DELTA_SIGN, DELTA_EXP, DELTA_DESC, 	!
		%REF (1), .BEXP, B_DESC, 	!
		X2_SIGN, X2_EXP, X2_DESC);

	    IF (.X2_SIGN)
	    THEN
		ITER_DONE = 1
	    ELSE

		IF (.DELTA_DESC [DSC$W_LENGTH] EQLU 1)
		THEN
		    BEGIN

		    LOCAL
			DELTA_BUF : REF VECTOR [65535, BYTE];

		    DELTA_BUF = .DELTA_DESC [DSC$A_POINTER];

		    IF (.DELTA_BUF [0] EQL %C'0') THEN ITER_DONE = 1;

		    END;

	    END
	ELSE
	    BEGIN
	    STR$ADD (Q_SIGN, Q_EXP, Q_DESC, 	!
		%REF (0), POS, ONE_DESC, 	!
		Q_SIGN, Q_EXP, Q_DESC);
	    END;

	END
    UNTIL (.ITER_DONE);

!+
! The reciprocal now lives in Q.  Return it to the caller with the
! original sign of A, which was not used above.
!-
    .CSIGN = .A_SIGN;
    .CEXP = .Q_EXP;

!+
! Call CHK_STR_TYPE to determine if we need to pad the number with
! leading zeroes depending on the string type.
!-

    QLEN = .Q_DESC[DSC$W_LENGTH];
    CHK_STR_TYPE (.Q_DESC[DSC$A_POINTER],QLEN,.CDIGITS);


!   STR$COPY_DX (.CDIGITS, Q_DESC);
!+
! Free our strings.
!-
    STR$FREE1_DX (X_DESC);
    STR$FREE1_DX (X2_DESC);
    STR$FREE1_DX (Q_DESC);
    STR$FREE1_DX (XA_DESC);
    STR$FREE1_DX (DELTA_DESC);
    END;					! end of STR$RECIP


GLOBAL ROUTINE STR$ROUND (			! Round a number
	PLACES, 				! Max decimal places in the result
	TRUNC, 					! Truncate to that many places
	ASIGN, 					! Sign of operand A
	AEXP, 					! Decimal exponent of operand A
	ADIGITS, 				! Digits of operand A
	BSIGN, 					! Sign of operand B
	BEXP, 					! Decimal exponent of operand B
	BDIGITS					! Digits of operand B
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Round or truncate a number to a specified number of significant
!	digits.  B := ROUND (A)
!
! FORMAL PARAMETERS:
!
!	PLACES.rl.r	Max decimal digits to retain in the result
!	TRUNC.rv.r	0 = round, 1 = truncate to that many places
!	ASIGN.rv.r	0 = operand A is positive, 1 = negative
!	AEXP.rl.r	Power of 10 by which to multiply the operand A
!			digits to get the absolute value of operand A.
!			E.g., AEXP = 1, ADIGITS = 123 gives 1230.
!	ADIGITS.rnu.d	Descriptor for the digits of operand A
!	BSIGN.wl.r	0 = operand B is positive, 1 = negative
!	BEXP.wl.r	Power of 10 by which to multiply the operand B
!			digits to get the absolute value of operand B.
!			E.g., BEXP = -1, BDIGITS = 123 gives 12.3.
!	BDIGITS.wnu.d	Descriptor for the digits of operand B
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	May allocate space for the BDIGITS string.
!	Signals if memory is exhausted.
!
!--

    BEGIN

    MAP
	ADIGITS : REF BLOCK [8, BYTE],
	BDIGITS : REF BLOCK [8, BYTE];

    LOCAL
!+
! Internal form of A.
!-
	ABUF : REF VECTOR [65535, BYTE],
	A_SIGN,
!+
! Internal form of B.
!-
	REXP,
	R_DESC : BLOCK [8, BYTE] VOLATILE,
	RBUF : REF VECTOR [65535, BYTE],
	R_LEN,					! Length of the result
	RESULT_DIGITS,				! Number of digits in the result

!+
! The following locals are needed for calls to LIB$ANALYZE_SDESC.
!-
	A_LEN,
	B_LEN,
	BBUF,
	STATUS;

    BUILTIN
	ACTUALCOUNT;

!+
! Enable a handler to free the local string in case of an error.
!-

    ENABLE
	FREE_STRINGS (R_DESC);

!+
! Check for the proper number of arguments.
!-

    IF (ACTUALCOUNT () LSS 8)
    THEN
	BEGIN

	LOCAL
	    ROUT_NAME_DESC : BLOCK [8, BYTE];

	ROUT_NAME_DESC [DSC$W_LENGTH] = 9;
	ROUT_NAME_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	ROUT_NAME_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	ROUT_NAME_DESC [DSC$A_POINTER] = UPLIT (%ASCII'STR$ROUND');
	LIB$STOP (STR$_WRONUMARG, 2, ACTUALCOUNT (), ROUT_NAME_DESC);
	END;

!+
! Copy the given number to local storage before we begin work on it.
!-
    A_SIGN = ..ASIGN;
    REXP = ..AEXP;
    R_DESC [DSC$W_LENGTH] = 0;
    R_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    R_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    R_DESC [DSC$A_POINTER] = 0;
!+
! Compute the length of operand A.  Only the leading digits count.
! First call LIB$ANALYZE_SDESC to ensure that the input descriptor
! is valid.  If it is, then ABUF will contain the address of the
! first byte of the string, and A_LEN will contain its length.
!-

    STATUS = LIB$ANALYZE_SDESC (.ADIGITS,A_LEN,ABUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

!+
! Also check the BDIGITS descriptor before getting too involved
! in this routine.
!-

    STATUS = LIB$ANALYZE_SDESC (.BDIGITS,B_LEN,BBUF);
    IF .STATUS NEQ SS$_NORMAL
      THEN
	LIB$STOP (LIB$_INVARG);

    R_LEN = 0;
    BEGIN

    LOCAL
	SCAN_DONE;

    SCAN_DONE = 0;

    DO
	BEGIN

	IF (.R_LEN EQLU .ADIGITS [DSC$W_LENGTH])
	THEN
	    SCAN_DONE = 1
	ELSE

	    IF ((.ABUF [.R_LEN] GEQ %C'0') AND (.ABUF [.R_LEN] LEQ %C'9'))
	    THEN
		R_LEN = .R_LEN + 1
	    ELSE
		SCAN_DONE = 1;

	END
    UNTIL (.SCAN_DONE);

    END;
    STR$GET1_DX (R_LEN, R_DESC);
    RBUF = .R_DESC [DSC$A_POINTER];
    CH$MOVE (.R_LEN, .ADIGITS [DSC$A_POINTER], RBUF [0]);
!+
! Round or truncate the number if it has more than the desired number
! of significant digits.
!-
    RESULT_DIGITS = .R_LEN;

    IF (.RESULT_DIGITS GTR ..PLACES)
    THEN
	BEGIN

	IF ( NOT ..TRUNC)
	THEN
	    BEGIN
!+
! Check the highest-order digit we will discard.  If it is five or
! larger, round up.  Note that the number is in sign-magnitude form
! at this point, so rounding "up" is always away from zero.
!-

	    IF (.RBUF [..PLACES] GEQ %C'5')
	    THEN
		BEGIN

		LOCAL
		    CARRY_COUNTER,
		    CARRY_DONE;

		CARRY_DONE = 0;
		CARRY_COUNTER = ..PLACES - 1;

		IF (.CARRY_COUNTER GEQ 0)
		THEN

		    DO
			BEGIN
			RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] + 1;

			IF (.RBUF [.CARRY_COUNTER] LEQ %C'9')
			THEN
			    CARRY_DONE = 1
			ELSE
			    BEGIN
			    RBUF [.CARRY_COUNTER] = .RBUF [.CARRY_COUNTER] - 10;
			    CARRY_COUNTER = .CARRY_COUNTER - 1;
			    END;

			END
		    UNTIL ((.CARRY_DONE) OR (.CARRY_COUNTER LSS 0));

		IF ( NOT .CARRY_DONE)
		THEN
		    BEGIN
!+
! The carry has forced a right shift (all 9's rounded up).
! We are guaranteed enough space since we must be dropping at least
! one digit.  Because of this shift we must now be dropping at least
! two digits.
!-

		    INCR COUNTER FROM 0 TO ..PLACES - 2 DO
			RBUF [.COUNTER + 1] = .RBUF [.COUNTER];

		    RBUF [0] = %C'1';
		    REXP = .REXP + 1;
		    END;

		END;

	    END;

	REXP = .REXP + (.RESULT_DIGITS - ..PLACES);
	RESULT_DIGITS = ..PLACES;
	END;

!+
! Return the results to the caller in the B operand.
! If there are no digits left, return a single zero digit.
!-

    IF (.RESULT_DIGITS EQL 0)
    THEN
	BEGIN
	.BSIGN = 0;
	.BEXP = 0;
	STR$COPY_R (.BDIGITS, %REF (1), %REF (%ASCII'0'));
	CHK_STR_TYPE (.BDIGITS[DSC$A_POINTER],%REF (1),.BDIGITS);
	END

    ELSE

!+
! Call CHK_STR_TYPE to determine if we need to pad the number with
! leading zeroes depending on the string type.
!-

      BEGIN
      .BSIGN = .A_SIGN;
      .BEXP = .REXP;
      CHK_STR_TYPE (.R_DESC[DSC$A_POINTER],RESULT_DIGITS,.BDIGITS);
      END;

!	BEGIN
!	.BSIGN = .A_SIGN;
!	.BEXP = .REXP;
!	STR$COPY_R (.BDIGITS, RESULT_DIGITS, .R_DESC [DSC$A_POINTER]);
!	END;

!+
! Free our string.
!-
    STR$FREE1_DX (R_DESC);
    RETURN;
    END;					! end of STR$ROUND


GLOBAL ROUTINE STR$DIVIDE (
		ASIGN,			! Sign of operand A
		AEXP,			! Decimal exponent of operand A
		ADIGITS,		! Digits of operand A
		BSIGN,			! Sign of operand B
		BEXP,			! Decimal exponent of operand B
		BDIGITS,		! Digits of operand B
		TOT_DIGITS,		!\Number of digits to the right of the
					!/decimal point to carry out the divide
		RND_TRUNC,		! Round/Truncate parameter 
		CSIGN,			! To contain sign of operand C
		CEXP,			! To contain decimal exponent of operand C
		CDIGITS	):NOVALUE =	! To contain digits of operand C

!++
!
! FUNCTIONAL DESCRIPTION:
!
!  This routine finds the quotient of two decimal strings i.e. C = A / B.
!  The algorithm implemented here has been provided by KNUTH.  It is
!  his famous Algorithm D (division of non-negative integers (which has
!  been modified to handle negative integers)) found in Volume 2 of
!  that extraordinary series (Vol. 2 is entitled Seminumerical Algorithms). 
!  An explanation of the algorithm appears further on in the program.
!
! CALLING SEQUENCE:
!
!	STR$DIVIDE (ASIGN.rv.r,AEXP.rl.r,ADIGITS.rnu.dx,
!		    BSIGN.rv.r,BEXP.rl.r,BDIGITS.rnu.dx,
!		    TOT_DIGITS.rl.r,RND_TRUNC.rv.r,
!		    CSIGN.wv.r,CEXP.wl.r,CDIGITS.wnu.dx)
!
! FORMAL PARAMETERS:
!
!	ASIGN.rv.r	Sign of operand A (0=positive, 1=negative)
!	AEXP.rl.r	Power of 10 by which to multiply the operand A digits
!			to get the absolute value of operand A.
!			Ex:  AEXP=1,ADIGITS=123 gives 1230.
!	ADIGITS.rnu.dx	Descriptor for the digits of operand A.
!	BSIGN.rv.r	Sign of operand B (0=positive, 1=negative)
!	BEXP.rl.r	Power of 10 by which to multiply the operand B digits
!			to get the absolute value of operand B.
!			Ex:  BEXP=-1,BDIGITS=123 gives 12.3
!	BDIGITS.rnu.dx	Descriptor for the digits of operand B.
!	TOT_DIGITS.rl.r	Number of digits to the right of the decimal point
!			to carry out the division
!	RND_TRUNC.rv.r	Round/Truncate parameter (0 = truncate, 1 = round)
!	CSIGN.wv.r	Sign of operand C (0=positive, 1=negative)
!	CEXP.wl.r	Power of 10 by which to multiply the operand C digits
!			to get the absolute value of operand C.
!			Ex:  CEXP=0,CDIGITS=123 gives 123.
!	CDIGITS.wnu.dx	Descriptor for the digits of operand C.
!
! IMPLICIT INPUTS:
!
!	-NONE
!
! IMPLICIT OUTPUTS:
!
!	-CSIGN
!	-CEXP
!	-CDIGITS
!
! ROUTINE VALUE:
!
!	-NONE
!
! COMPLETION CODES
!
!	-NONE
!
! MACROS:
!
!	-NONE
!  
! SIDE EFFECTS:
!
!	Signals if storage is exceeded.
!
!-

BEGIN

    MAP
	ADIGITS:REF BLOCK [8,BYTE],
	BDIGITS:REF BLOCK [8,BYTE],
	CDIGITS:REF BLOCK [8,BYTE];

    STACKLOCAL

	A_LENGTH:WORD,		! Number of digits in A string
	A_ADDR,			! Address of A string
	B_LENGTH:WORD,		! Number of digits in B string
	B_ADDR,			! Address of B string
	C_LENGTH:WORD,		! Number of digits in result string
	START_BUF,		! Pointer to 1st byte of allocated memory
	A_LEN,			! Number of digits needed in A to compute result
	A_CHUNKS,		! Number of 15 digit chunks needed in A
	ABUF,			! Pointer to packed decimal chunks of A
	B_CHUNKS,		! Number of 15 digit chunks in B
	BBUF,			! Pointer to packed decimal chunks of B
	DRBUF,			! Pointer to D / pointer to rounding chunk
	Q_LENGTH,		! Number of digit required in the quotient
	Q_CHUNKS,		! Number of 15 digit chunks required in quotient
	QBUF,			! Pointer to 15 digit chunks of the quotient
	QSTRBUF,		! Pointer to string of quotient digits
	QBBUF,			! Pointer to buffer containing q*B
	STATUS,			! Longword for returning status
	FLAG,			! B_CHUNKS = 1 ==> FLAG = 1, FLAG = 0 otherwise
	TEMP,			! Longword to hold intermediate results
	LEADING_ZEROS,		! Number of leading zeros in the quotient string
	STORAGE:VECTOR[10,BYTE],! Dummy storage area
	BYTES_VM;		! Total bytes of storage allocated

!************************************************************************
!									*
!			THE ALGORITHM					*
!									*
! GIVENS:  n = length of the divisor					*
!	   m = length of dividend - n					*
!	   radix = 10 (decimal)						*
!									*
! STEP 1.  Normalize.  Set D = FLOOR (radix/(v1+1)) where v1 is  the	*
!	   first digit of the divisor which must not be zero.  Where	*
!	   U0 U1...Um+n represent the chunks of  15  digits  of  the 	*
!          dividend and V1 V2...Vn represent the chunks of 15 digits 	*
!          of the divisor.						*
!	   Multiply  A  by  D  thus  giving the sequence of 15 digit 	*
!	   chunks U0 U1 U2...Um+n. (Note the introduction of the new	*
!	   chunk.)  Multiply B by d to obtain a sequence  of  chunks	*
!	   V1 V2...Vn. (Note no new chunk occurs			*
!									*
! STEP 2.  Set J = 0.  This is the value we will loop on.  For this	*
!	   routine we will loop "LOOP" number of times.  Steps  2-7 	*
!	   will provide the basis for the division of Uj Uj+1...Uj+n	*
!	   by V1 V2...Vn, to get a single quotient digit - Qj.		*
!									*
! STEP 3.  Calculate the first digit of the quotient:			*
!	   If Uj = V1 then set q = radix-1.  Otherwise, set q = 	*
!          FLOOR(Uj*radix + Uj+1)/V1).  Now test if V2*q > 		*
!	   (((Uj*radix + Uj+1 - q*V1)*radix)+Uj+2).  If so, then 	*
!	   decrease q by 1 and repeat this test.  When finish q is	*
!	   either equal to the qoutient digit or one greater.		*
!									*
! STEP 4.  Multiply and subtract.  Replace Uj Uj+1...Uj+n by		*
!	   Uj Uj+1...Uj+n - (q * V1 V2...Vn).				*
!	   This step consists of a simple multiplication by a one-place	*
!	   number, combined with a subtraction.  The digits 		*
!	   Uj Uj+1...Uj+n should be kept positive; if the result of this*
!	   step is negative, Uj Uj+1...Uj+n should be left as the true	*
!	   value plus radix raised to the n+1, i.e. as the radix'	*
!	   complement of the true value, and a "borrow" to the left	*
!	   should be remembered.					*
!									*
! STEP 5.  Set Q[.J] = q.  This is a digit of the quotient.  If the	*
!	   result of STEP 4 was negative, go to STEP 6; otherwise go to	*
!	   STEP 7.							*
!									*
! STEP 6.  Decrease Q[.J] by 1. Add 0V1 V2...Vn to Uj Uj+1...Uj+n.	*
!									*
! STEP 7.  Loop on J.  If J <= "LOOP" then go back to STEP 3.		*
!									*
!************************************************************************ 

!+
! Validate input descriptors.
!-
	STATUS = LIB$ANALYZE_SDESC (.ADIGITS, A_LENGTH, A_ADDR);
	IF .STATUS NEQ SS$_NORMAL
	  THEN
	    LIB$STOP (LIB$_INVARG);		! Unsuccessful status

	STATUS = LIB$ANALYZE_SDESC (.BDIGITS, B_LENGTH, B_ADDR);
	IF .STATUS NEQ SS$_NORMAL
	  THEN
	    LIB$STOP (LIB$_INVARG);		! Unsuccessful status

	STATUS = LIB$ANALYZE_SDESC (.CDIGITS, C_LENGTH, TEMP);
	IF .STATUS NEQ SS$_NORMAL
	  THEN
	    LIB$STOP (LIB$_INVARG);
!+
! Validate input strings - If SPANC returns a zero value all characters are
! digits.  If it returns a non-zero value, then TEMP is the address of the 
! first non-digit.
!-
	TEMP = SPANC (A_LENGTH, .A_ADDR, SPANC_TABLE, MASK);
	IF .TEMP NEQ 0				! No match found
	  THEN
	    A_LENGTH = .TEMP - .A_ADDR;

	TEMP = SPANC (B_LENGTH, .B_ADDR, SPANC_TABLE, MASK);
	IF .TEMP NEQ 0				! No match found
	  THEN
	    B_LENGTH = .TEMP - .B_ADDR;

!+
!             ***   BEGIN THE DIVISION ALGORITHM   ***
!-

!+
! Calculate the resultant sign and exponent.
!-
	.CSIGN = ..ASIGN XOR ..BSIGN;
	.CEXP = -..TOT_DIGITS;
!+
! Strip off leading zeros for A and B and compute their length.
! CH$FIND_NOT_CH returns a null pointer if the desired match on character
! is not found.  To determine if the pointer is null or not,
! one must invoke CH$FAIL which returns a value of one if the pointer
! is null, and a zero if it is not null.
!-
	TEMP = CH$FIND_NOT_CH (.A_LENGTH, .A_ADDR, %C'0');
	STATUS = CH$FAIL (.TEMP);
	IF .STATUS EQL 0
	  THEN
	    BEGIN
	    A_LENGTH = .A_LENGTH - (.TEMP - .A_ADDR);
	    A_ADDR = .TEMP;
	    END;

	TEMP = CH$FIND_NOT_CH (.B_LENGTH, .B_ADDR, %C'0');
	STATUS = CH$FAIL (.TEMP);
	IF .STATUS EQL 1
	  THEN
	    LIB$STOP (STR$_DIVBY_ZER);
	B_LENGTH = .B_LENGTH - (.TEMP - .B_ADDR);
	B_ADDR = .TEMP;
!+
! Calculate maximum number of result digits required
!+
	Q_LENGTH = (.A_LENGTH + ..AEXP) - (.B_LENGTH + ..BEXP) 
                   + ..TOT_DIGITS + ..RND_TRUNC;
	IF .Q_LENGTH LSS 0
	  THEN
!+
! Special case for zero quotient
!-
	    BEGIN
	    LEADING_ZEROS = 0;
	    BYTES_VM = MAXU(.C_LENGTH, 1);
	    STATUS = LIB$GET_VM (BYTES_VM, START_BUF);
	    QSTRBUF = .STORAGE;
	    END	    
	  ELSE
	    BEGIN
!+
! Determine the number of digits required in A to obtain the proper number
! of digits in the result
!-
	    A_LEN = .B_LENGTH + .Q_LENGTH;
!+
! Determine the number of 15 digit CHUNKS needed to hold B, the required
! digits of A and the result digits
!-
	    A_CHUNKS = (.A_LEN + 14)/15;
	    B_CHUNKS = (.B_LENGTH + 14)/15;
	    Q_CHUNKS = (.Q_LENGTH + 29)/15;
!+
! For the algorithm we must have A_CHUNKS >= B_CHUNKS + Q_CHUNKS.  
!-
	    A_CHUNKS = MAXU(.A_CHUNKS, .B_CHUNKS + .Q_CHUNKS);
!+
! Determine total storage needed as the maximum of {the storage needed for 
! the computation of the quotient in packed decimal, the storage needed to
! convert the quotient to a string, the lenght of the result string}
!-
	    BYTES_VM = 8*(.B_CHUNKS*2 + .A_CHUNKS + 3); ! # of bytes to perform
						        !   division algorithm in
						        !   packed decimal.
	    TEMP = .Q_CHUNKS*15;			    ! # of bytes needed to hold
						        !   quotient string
	    BYTES_VM = MAXU (.BYTES_VM, .TEMP, .C_LENGTH);
!+
! Allocate working storage and set up pointers into it.
!-
	    STATUS = LIB$GET_VM (BYTES_VM, START_BUF);
	    DRBUF = .START_BUF;
	    QBUF = .DRBUF;
	    ABUF = .QBUF + 8;
	    BBUF = .ABUF + (.A_CHUNKS + 1)*8;
	    QBBUF = .BBUF + .B_CHUNKS*8;
	    QSTRBUF = .START_BUF + .BYTES_VM - .Q_CHUNKS*15;
!+
! Convert A and B strings to packed decimal.
!-
	    LIB$$CVT_STR_PACK_R9 (.A_ADDR, .A_LENGTH, .A_CHUNKS, .ABUF + 8);
	    MOVP (%REF(15),ZERO,.ABUF);
	    LIB$$CVT_STR_PACK_R9 (.B_ADDR, .B_LENGTH, .B_CHUNKS, .BBUF);

!+
! Step 1 - Normalize A and B.  NOTE: If B_CHUNKS = 1 this step is not necessary
! and the computation of q can be simplified.  A flag is used to indicate the 
! proper method of evaluating q.  FLAG = 1 if .B_CHUNKS = 1 and 0 otherwise.
!-
	    IF .B_CHUNKS NEQ 1
	      THEN
	        BEGIN
	        FLAG = 0;
	        STATUS = LIB$$CALC_D_R7 (.BBUF, .DRBUF);
	        IF .STATUS NEQ 1		! STATUS = 1 <==> D = 1
	          THEN
	            BEGIN
	            LIB$$MUL_PACK_R10 (.DRBUF, .ABUF + 8, .A_CHUNKS, 
                                       .A_CHUNKS + 1, .ABUF + 8);
	            LIB$$MUL_PACK_R10 (.DRBUF, .BBUF, .B_CHUNKS,  
					.B_CHUNKS, .BBUF);
	 	    END
	          ELSE
	            MOVP (%REF(15), ZERO, .ABUF);
	          END
	      ELSE
	        FLAG = 1;

!+
! Ready to start the actual divide algorithm.
!-
	    INCR J FROM 0 TO (.Q_CHUNKS*8 - 8) BY 8 DO
	      BEGIN
!+
! Step 3 - Calculate digit of quotient.  
!-
	      STATUS = LIB$$CALC_Q_R9 (.BBUF, .ABUF + .J, .FLAG, .QBUF + .J);
	      IF .STATUS NEQ 1
		THEN
		  LIB$STOP (LIB$_INVARG);
!+
! Step 4 - Multiply and subtract.  Replace the digits of ABUF by ABUF - Q*BBUF 
!-
	      LIB$$MUL_PACK_R10 (.QBUF + .J, .BBUF, .B_CHUNKS,  
                             .B_CHUNKS+1, .QBBUF +8);
	      STATUS = LIB$$SUB_PACK_R8 (.B_CHUNKS, .ABUF + .J, .QBBUF);
!+
! Step 6 - Adjust q if the result of step 4 was negative
!-
	      IF .STATUS EQL 1			! If remainder is negative
	        THEN
	          LIB$$ADJUST_Q_R9 (.B_CHUNKS, .ABUF + .J + 8, .BBUF, .QBUF + .J);
	    END;
!+
! Check if rounding is required and round result if necessary
!-
	    IF ..RND_TRUNC EQL 1
	      THEN
	        BEGIN
	        TEMP = (.Q_CHUNKS-1)*15 - .Q_LENGTH;
	        Q_LENGTH = .Q_LENGTH - 1;
	        DRBUF = .QBUF + (.Q_CHUNKS - 1)*8;
	        LIB$$ROUND_R7 (.DRBUF, .TEMP);
	        END;
!+
! Check if 1st chunk of the quotient is zero.  If it is, A < B, the number of
! leading zeros is 15.  Otherwise, A >= B, and the number of leading zeros is 
! 14 and the number of digits in the quotient should be increased by 1.  
!-
	    STATUS = CMPP (%REF(15), .QBUF, %REF(15), ZERO);
	    IF .STATUS EQL 0
	      THEN
	        LEADING_ZEROS = 15
	      ELSE
	        BEGIN
	        Q_LENGTH = .Q_LENGTH + 1;
	        LEADING_ZEROS = 14;
	        END;
!+
! Convert the packed number back into its original numeric form.
!-
	    LIB$$CVT_PACK_STR_R8 (.QBUF, .Q_CHUNKS, .QSTRBUF);
	END;
!+
! Check descriptor class to see if the string needs to be padded with leading
! zeros before copying the quotient string to the result string.
!-
	IF (.CDIGITS[DSC$B_CLASS] NEQ DSC$K_CLASS_D) AND
	   (.CDIGITS[DSC$B_CLASS] NEQ DSC$K_CLASS_VS) AND
	   (.C_LENGTH GTR .Q_LENGTH)
	  THEN
	    BEGIN
	      TEMP = .C_LENGTH - .Q_LENGTH - .LEADING_ZEROS;
	      Q_LENGTH = .C_LENGTH;
	      QSTRBUF = .QSTRBUF - .TEMP;
	      IF .TEMP GEQ 0
		THEN
		  CH$FILL (%C'0', .TEMP, .QSTRBUF);
	      END
	  ELSE
	    QSTRBUF = .QSTRBUF + .LEADING_ZEROS;

!+
! Check the type of descriptor our resultant descriptor is.
!-

!	QSTRBUF = .QSTRBUF + .LEADING_ZEROS;
!	CHK_STR_TYPE (QSTRBUF,Q_LENGTH,.CDIGITS);

!+
! Copy quotient string to result string and deallocate virtual memory
!-

	IF .Q_LENGTH LEQ 0
	  THEN
	    STATUS = LIB$SCOPY_R_DX (%REF(1),%REF (%ASCII'0'),.CDIGITS)
	  ELSE
	    STATUS = LIB$SCOPY_R_DX (Q_LENGTH, .QSTRBUF, .CDIGITS);
	STATUS = LIB$FREE_VM (BYTES_VM, .START_BUF);
END;
ROUTINE CHK_STR_TYPE (SRC_BUF,SRC_LEN,DST_DESC): NOVALUE =


!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks the destination string type and copies
!	the appropriate number of digits from the source buffer
!	into it as dictated by the rules of the destination string.
!
! CALLING SEQUENCE:
!
!	CHK_STR_TYPE (src_buf.rnu.r,src_len.rl.r,dst_desc.wnu.dx)
!
! FORMAL PARAMETERS:
!	SRC_BUF.rnu.r		Addr of the source buffer which contains
!				the digits of the result.
!	SRC_LEN.rl.r		Length of the source string
!	DST_DESC.wnu.dx		Addr of the destination string (where to store
!				the resultant string).  
!
! IMPLICIT INPUTS:
!
!	-NONE
!
! IMPLICIT OUTPUTS:
!
!	DST_DESC		Store the resultant string in DST_DESC
!
! ROUTINE VALUE:
!
!	-NONE
!
! COMPLETION CODES:
!
!	-NONE
!
! MACROS:
!
!	-NONE
!  
! SIDE EFFECTS:
!
!	-NONE
!-

BEGIN

    MAP
      DST_DESC:REF BLOCK [8,BYTE];

    LOCAL
      TMP_BUF:REF VECTOR[65535,BYTE],
      RESULT_DIGITS,
      RLEN;

	TMP_BUF = .SRC_BUF;
	RESULT_DIGITS = ..SRC_LEN;
!+
! Check the class of strings we are dealing with.  For
! dynamic and varying strings, return the calculated length;
! for all other classes of strings, return the number of
! characters specified in the destination descriptor.
!-

	IF (.DST_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_D) OR
	   (.DST_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_VS)
	  THEN
	    BEGIN
	    IF .DST_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_VS ! Varying string only
	      THEN
		BEGIN
		RLEN = .DST_DESC[DSC$W_MAXSTRLEN];	! Fetch max string size
		IF .RLEN LSS .RESULT_DIGITS		!\If max < actual then
		  THEN					!/return max # of chars
!		    BEGIN
!		    CH$MOVE (.RLEN,TMP_BUF,.DST_DESC[DSC$A_POINTER] + 2);
!		    (.DST_DESC[DSC$A_POINTER])<0,16> = .RLEN;
!		    END

		    (.DST_DESC[DSC$A_POINTER])<0,16> = .RLEN
		  ELSE
!		    BEGIN				!\Just retn # of
!							!/calculated characters
!		    CH$MOVE (.RESULT_DIGITS,TMP_BUF,.DST_DESC[DSC$A_POINTER] + 2);
!		    (.DST_DESC[DSC$A_POINTER])<0,16> = .RESULT_DIGITS;
!		    END;

		    (.DST_DESC[DSC$A_POINTER])<0,16> = .RESULT_DIGITS;
		STR$COPY_R (.DST_DESC,RLEN,.TMP_BUF);
		END
	      ELSE

	      !+
	      ! Here we know the string is dynamic.
	      ! Return actual number of characters as calculated in algorithm.
	      !-

		STR$COPY_R (.DST_DESC,RESULT_DIGITS,.TMP_BUF);
	      END

	    !+
	    ! Here we know we are dealing with static strings.
	    !-

	    ELSE
	      BEGIN
	      RLEN = .DST_DESC[DSC$W_LENGTH];		!\Fetch length passed
							!/in output descriptor
	      IF .RLEN GTR .RESULT_DIGITS		! Given length>actual?
		THEN
		  BEGIN					! Yes.
		  !+
		  ! Duplicate the zero character for the length
		  ! of the string.  Then copy the calculated
		  ! numeric string into the appropriate offset into
		  ! the destination descriptor.
		  !-
		  STR$DUPL_CHAR (.DST_DESC,RLEN,%REF(%ASCII'0'));
	 	  CH$MOVE (.RESULT_DIGITS,.TMP_BUF,.DST_DESC[DSC$A_POINTER] +
			   .RLEN - .RESULT_DIGITS);
		  END
		!+
		! Still dealing with static strings here.
		!-
		ELSE
		  BEGIN

		  !+
		  ! For case where RLEN is less than or equal to the 
		  ! actual length of the result, just copy RLEN digits 
		  ! into the output descriptor.
		  !-

		  STR$COPY_R (.DST_DESC,RLEN,.TMP_BUF);
		  END;
	      END;
END;

ROUTINE FREE_STRINGS (				! Free local strings
	SIG, 					! Signal vector
	MECH, 					! Mechanism vector
	ENBL					! Enable vector
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If we are unwinding, free the local strings.  They are passed
!	in the enable vector.
!
! FORMAL PARAMETERS:
!
!	SIG.rl.a	A counted vector of parameters to LIB$SIGNAL/STOP
!	MECH.rl.a	A counted vector of info from CHF
!	ENBL.ra.a	A counted vector of ENABLE argument addresses.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Always SS$_RESIGNAL, which is ignored when unwinding.
!
! SIDE EFFECTS:
!
!	Frees all of the strings passed as enable arguments.
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,
	MECH : REF VECTOR,
	ENBL : REF VECTOR;

!+
! Only free strings if this is the UNWIND condition.
!-

    IF ( NOT (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND)))) THEN RETURN (SS$_RESIGNAL);

!+
! Go through the enable arguments, freeing them.
!-

    INCR ARG_NO FROM 1 TO .ENBL [0] DO

	IF (..ENBL [.ARG_NO] NEQ 0) THEN STR$FREE1_DX (.ENBL [.ARG_NO]);

    RETURN (SS$_RESIGNAL);
    END;					! end of FREE_STRINGS
END						! end of module STR$ARITH

ELUDOM
