 	.TITLE	BAS$MAT_REDIM		; Redimension a BASIC-PLUS-2 array
	.IDENT	/1-002/		; File: BASMATRED.MAR Edit:RNH1002

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: BASIC code support
;
; ABSTRACT:
;
;	This module is the routine to redimension BASIC arrays.  It is 
;	called from both the RTL and code generated by the compiler.
;
; ENVIRONMENT: User Mode, AST Reentrant
;
;--
; AUTHOR: R. WILL, CREATION DATE: 17-Apr-79
;
; MODIFIED BY:
;
;	, : VERSION 00
; 0-001	- Original 
; 1-002 - Changed shared external references to G^ RNH 25-Sep-81

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$DSCDEF					; Define descriptor offsets

;
; EXTERNAL DECLARATIONS:
;
	.DSABL	GBL				; Prevent undeclared
						; symbols from being
						; automatically global.

	.EXTRN	BAS$$STOP			; Routine to signal errors

;
;	The following are error messages that may be signalled
;
	.EXTRN	BAS$K_CANCHAARR		; Cannot Change Array Dimensions
					; DSC$V_FL_REDIM is not set or
					; DSC$V_FL_BOUNDS is not set
	.EXTRN	BAS$K_MATDIMERR		; Matrix Dimension Error
					; Number of input parameters differs
					;  from number of dimensions in array
	.EXTRN	BAS$K_REDARR		; Redimensioned Array
					; Not enough space allocated for input
					;  dimension parameters
	.EXTRN	BAS$K_SUBOUTRAN		; Subscript Out Of Range
					; One of the new bounds specified was
					;  negative or zero

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

;
; PSECT DECLARATIONS:
;
	.PSECT _BAS$CODE PIC, USR, CON, REL, LCL, SHR, -
			EXE, RD, NOWRT, LONG


	.SBTTL	BAS$MAT_REDIM  - Redimension a BASIC array
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine redimensions arrays for BASIC-PLUS-2.  It first checks to
;	see if the array is currently the size that the call is requesting
;	redimensioning to.  If so, the routine will return (so that if
;	DSC$V_FL_REDIM is not set an error will not be signalled).  Otherwise
;	it will signal an error if DSC$V_FL_REDIM is not set, or if
;	2 dimensions are input and the matrix currently only has 1 dimension
;	or only 1 dimension is input and the matrix currently has 2 dimensions
;	or if the input dimensions require more space than originally
;	allocated to the array (DSC$L_ARSIZE).  If there are no errors, then
;	the routine will write either 1 or 2 upper bounds and the same
;	number of multipliers, and set to 0 the same number of lower bounds.
;	DSC$A_A0 will be set to DSC$A_POINTER.  Also
;	note that total array size will always remain the initial allocated
;	length.  Integer overflow is disabled so that a BASIC-PLUS-2 error
;	can be signalled if the space needed is too large instead of getting
;	a hardware error.
;
; CALLING SEQUENCE:
;
;	CALL BAS$MAT_REDIM (matrix.wx.da, rows.rl.v [, cols.rl.v])
;
; INPUT PARAMETERS:
;
	row_upr_bnd = 8
	col_upr_bnd = 12
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
	matrix = 4
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	Errors list under externals may be signalled.  The matrix parameter
;	may have different dimensions after routine execution.
;
;--

	.ENTRY BAS$MAT_REDIM , ^M<R2,R3,R4>
						; Routine to redimension array
						; according to BASIC-PLUS-2
						; syntax

;+
; Register usage
; 	R0, R1	computation temps
;	R2	pointer to output matrix descriptor
;	R3	upper bound for subscript 1 (rows)
;	R4	upper bound for subscript 2 (columns)
;-

	MOVL	matrix(AP), R2			; pointer to array descriptor

;+
; First check to see if the bounds are set in the array descriptor
; if they are not, we cannot change them.  \is this really an error\
;-

	BBS	#DSC$V_FL_BOUNDS, DSC$B_AFLAGS(R2), 1$	; If bounds are
						; present, go check them
	MOVZBL	#BAS$K_CANCHAARR, -(SP)		; Bounds are not present
	CALLS	#1, G^BAS$$STOP			; signal redimension error

;+
; Bounds are present.  Take execution path depending on number
; of dimensions.
;-

1$:	CMPB	(AP), #2			; find # of bounds input
	BLSSU	RETURN				; no bounds input, so exit
						; \should that be an error\
						; \should I even check for it\
	BGTRU	TWO_DIMS			; go do more than 1 bound

	.PAGE
;+
; One dimension was input.
;-

;+
; Put new bound into R3.  If it is negative or zero signal an error
;-

	MOVL	row_upr_bnd(AP), R3		; get the new bound
	BLEQ	ERR4				; error

;+
; Check to see if array is one dimensional.  If not signal an error.
;-

	CMPB	DSC$B_DIMCT(R2), #1		; One dimensional array?
	BNEQU	ERR1				; No, go signal error

;+
; Check to see if the new bound is the same as the old bound.
; If so return.
;-

	CMPL	DSC$L_M1+8(R2), row_upr_bnd(AP)	; Yes, compare bounds
	BEQL	RETURN				; Array is already desired
						; size, so return

;+
; See if array is redimensionable.  If not, signal an error.  Note that
; we must check for correct size before redimensionability so that we
; won't give the 'can't redimension' error when array is correct size.  
;-

	BBC	#DSC$V_FL_REDIM, DSC$B_AFLAGS(R2), ERR3	; if can't redimension
						; array, go signal an error

;+
; Compute array size needed for new bounds.  If more space is needed
; than is currently allocated to the array signal an error.
;-

	MOVZWL	DSC$W_LENGTH(R2), R0		; make item length a longword
	ADDL3	row_upr_bnd(AP), #1, R1		; Add 1 to upper bound since
						; BASIC-PLUS-2 ARRAYS have 0
						; for a lower bound
	MULL2	R0, R1				; find space need w/ new bound
	BVS	ERR2				; not enuf space, go signal
	CMPL	R1, DSC$L_ARSIZE(R2)		; see if too much space needed
	BGTR	ERR2				; too much space, go signal
;\what is supposed to to unsigned and what is not?\

;+
; All errors have been caught.  Now redimension array.
;-

	MOVL	row_upr_bnd(AP), DSC$L_M1+8(R2)	; write new upper bound
	CLRL	DSC$L_M1+4(R2)			; set lower bound to 0 since
						; B+2 arrays have 0 lower bnd
	ADDL3	row_upr_bnd(AP), #1, DSC$L_M1(R2) ; compute and write new
						; multiplier, assuming that
						; all B+2 arrays have 0 for L1
	BRB	RETURN				; and exit


	.PAGE
;+
; Signal errors
;-

ERR1:	MOVZBL	#BAS$K_MATDIMERR, -(SP)		; Matrix Dimension Error
	CALLS	#1, G^BAS$$STOP			; Signal the error

ERR2:	MOVZBL	#BAS$K_REDARR, -(SP)		; Redimensioned Array
	CALLS	#1, G^BAS$$STOP			; Signal the error

ERR3:	MOVZBL	#BAS$K_CANCHAARR, -(SP)		; Can't Change Array Dimension
	CALLS	#1, G^BAS$$STOP

ERR4:	MOVZBL	#BAS$K_SUBOUTRAN, -(SP)		; Subscript out of range
	CALLS	#1, G^BAS$$STOP

RETURN:	RET					; and exit

	.PAGE
;+
; Two dimensions were input.
;-

;+
; Put the 2 new upper bounds into registers.  If either is negative or 0,
; signal an error.
;-

	MOVL	row_upr_bnd(AP), R3		; new upper bound
	BLEQ	ERR4				; error
	MOVL	col_upr_bnd(AP), R4		; new upper bound
	BLEQ	ERR4				; error

;+
; Check to see if array is two dimensional.  If not signal an error.
;-

TWO_DIMS:
	CMPB	DSC$B_DIMCT(R2), #2		; Two dimensional array?
	BNEQU	ERR1				; No, go signal error

;+
; Check to see if the new bounds are the same as the old bounds.
; If so return.
;-

	CMPL	DSC$L_M2+8(R2), row_upr_bnd(AP)	; Yes, compare number of rows
	BNEQ	25$				; Not =, continue redimension
	CMPL	DSC$L_M2+16(R2), col_upr_bnd(AP) ; compare number of columns
	BEQL	RETURN				; Array is already desired
						; size, so return

;+
; See if array is redimensionable.  If not, signal an error.  Note that
; we must check for correct size before redimensionability so that we
; won't give the 'can't redimension' error when array is correct size.  
;-

25$:	BBC	#DSC$V_FL_REDIM, DSC$B_AFLAGS(R2), ERR3	; if can't redimension
						; array, go signal an error

;+
; Compute array size needed for new bounds.  If more space is needed
; than is currently allocated to the array signal an error.
;-

	MOVZWL	DSC$W_LENGTH(R2), R0		; make item length a longword
	ADDL3	row_upr_bnd(AP), #1, R1		; Add 1 to upper bound since
						; BASIC-PLUS-2 arrays have 0
						; for a lower bound for rows
	BVS	ERR2				; not enuf space, go signal
	MULL2	R0, R1				; find space need for a column
	BVS	ERR2				; not enuf space, go signal
	ADDL3	col_upr_bnd(AP), #1, R0		; Add 1 to upper bound since
						; BASIC-PLUS-2 arrays have 0
						; for a lower bound for column
	BVS	ERR2				; not enuf space, go signal
	MULL2	R0, R1				; find total space needed
	BVS	ERR2				; not enuf space, go signal
	CMPL	R1, DSC$L_ARSIZE(R2)		; see if too much space needed
	BGTR	ERR2				; too much space, go signal
;\what is supposed to to unsigned and what is not?\

;+
; All errors have been caught.  Now redimension array.
;-

	CLRL	DSC$L_M2+4(R2)			; set lower bound to 0
	MOVL	row_upr_bnd(AP), DSC$L_M2+8(R2)	; write new upper bnd for rows
	ADDL3	row_upr_bnd(AP), #1, DSC$L_M1(R2) ; compute and write new row
						; multiplier, assuming that
						; all B+2 arrays have 0 for L1
	CLRL	DSC$L_M2+12(R2)			; set lower bound to 0
	MOVL	col_upr_bnd(AP), DSC$L_M2+16(R2) ; write new upper bnd for col
	ADDL3	col_upr_bnd(AP), #1, DSC$L_M2(R2) ; compute and write new col
						; multiplier, assuming that
						; all B+2 arrays have 0 for L2

	BRB	RETURN				; and exit

	.END					; End of BAS$MAT_REDIM
;\do I need to check to see if input descriptor is an array?  or if there
;\are more than 2 bounds input.  I think not since this is code support.\
;\do I need to make sure that length is in bytes, B+2 doesn't support packed\
