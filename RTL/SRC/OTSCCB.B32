MODULE OTS$$CCB (				! Push, Pop, Allocate, and deallocate LUB/ISB/RAB
		IDENT = '1-057'			! File: OTSCCB.B32 Edit: FM1057
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: language support library
!
! ABSTRACT:
!
!	This module supports pushing and popping of the CCB, the
!	common control block for the I/O part of the RTL.  Currently,
!	only BASIC uses this module, since FORTRAN does its own
!	manipulations.
!
! ENVIRONMENT: User mode, AST level or not or mixed
!
! AUTHOR:  Thomas N. Hastings, CREATION DATE: 01-June-77
!
! MODIFIED BY:
!
! 	Thomas N. Hastings, 01-June-77: VERSION 01
! 01	-  original
! 0-26	- Set RMS RAB$V_UIF bit TNH 19-SEP-77
! 0-27	- Set RMS RAB$V_TPT bit (truncate on sequential $PUT not at EOF TNH 24-SEP-77
! 0-28	- Use FOR$$SIG_NO_LUB since no LUB.  TNH 24-SEP-77
! 0-30	- Set RAB bits for read-ahead, write-behind, locate mode JMT 21-OCT-77
! 0-31	- Use FOR$K_abcmnoxyz as EXTERNAL LITERALs.  TNH 27-Oct-77
! 0-32	- Made second arg optional.  TNH 9-Nov-77
! 0-33	- Use OTS$_FATINTERR.  TNH 01-Dec-77
! 0-34	- Clear FAB after call to LIB$GET_VM.  TNH 9-Dec-77
! 0-35	- Call FOR$SIG_FATINT.  TNH 30-Dec-77
! 0-36	- Have CB_POP signal FATINT if LUB not active;
!	  Add routine CB_CND_POP to conditionally pop if LUB active,
!	  otherwise NO-OP (OTS exit handler calls this).  JMT 10-Jan-78
! 0-37	- Remove CB_CND_POP; I didn't really want it, anyway...  JMT 11-Jan-78
! 0-37	- Global register CCB.  JMT 8-Apr-78
! 0-39	- Change to STARLET library.  DGP 20-Apr-78
! 0-40	- Change REQUIRE files for VAX system build.  DGP 28-Apr-78
! 0-41	- Change STARLET to RTLSTARLE to avoid conflicts.  DGP 1-May-78
! 0-42	- Make JSB linkage.  TNH 19-May-78
! 0-46	- Use FOR$$GET_VM with new optional 2nd arg.  TNH 21-May-78
! 0-47	- Remove setting ISB to -1.  TNH 30-May-78.
! 0-48	- Add sanity check of data base.  TNH 10-June-78
! 0-49	- Add call to FOR$$SIG_DATCOR.  TNH 10-June-78
! 0-50	- Add FOR$$CB_GET entry for non-shared access to OTS$$A_CUR_LUB. TNH 2-Aug-78
! 0-52	- Fix AST re-entrant timing hole.  TNH 9-Aug-78
! 0-53	- Change file name to FORCB.B32, and change the names of the
!	   REQUIRE files similarly.  JBS 14-NOV-78
! 1-001	- Update version number and copyright notice.  JBS 16-NOV-78
! 1-002	- Change LUB$B_LUN to LUB$W_LUN.  JBS 05-DEC-78
! 1-003	- Change REQUIRE file names from FOR... to OTS...  JBS 07-DEC-78
! 1-004	- Include TNH's version, which uses a bit table to provide
!	   AST re-entrancy.  JBS 11-DEC-78
! 1-005	- Remove REQUIRE of OTSMAC; not needed.  JBS 11-DEC-78
! 1-006	- Add FOR$$CB_NEXT, which gets the next LUN for the CLOSE loop
!	   in FOROPEN.B32.  JBS 11-DEC-78
! 1-007	- Fix coding errors in FOR$$CB_NEXT and make OTS$$AA_LUB_TAB
!	   OWN.  JBS 18-DEC-78
! 1-008	- Change file and module name to OTSCB and add specialized
!	   BASIC entry points.  This is in preparation for recursive
!	   I/O.  JBS 29-DEC-78
! 1-009	- Add BAS$$CB_CLEANUP.  JBS 29-DEC-78
! 1-010 - Add recursive I/O for BASIC.  JBS 08-JAN-1979
! 1-011 - Divide into three modules: OTSCCB, FORCB and BASCB.  This
!	   module, OTSCCB, contains the language-independent code.
!	   JBS 09-JAN-1979
! 1-012 - Restore OTS$$A_CUR_LUB and set I/O Active when popping.
!	   JBS 15-JAN-1979
! 1-013 - Fix up some complex cases of popping recursive I/O.
!	   JBS 15-JAN-1979
! 1-014 - Fix an error in calling LIB$STOP.  JBS 16-JAN-1979
! 1-015 - Push and Pop the RMS timeout field in the RAB.  JBS 16-JAN-1979
! 1-016	- Use the DEALLOC bit in the LUB to interlock deallocation of
!	   the LUB/ISB/RAB rather than disabling interrupts, and be
!	   cleverer in other places so that interrupts need never be
!	   disabled.  JBS 23-JAN-1979
! 1-017	- Don't clear OTS$$V_IOINPROG if the LUN we just popped is the same
!	   unit we just finished using.  (This is the most common case
!	   of recursive I/O.)  JBS 24-JAN-1979
! 1-018	- But if there is no popped unit, do clear OTS$$V_IOINPROG.  (This is
!	   the most common case of non-recursive I/O!).  JBS 24-JAN-1979
! 1-019	- Divide into more internal subroutines in an attempt to speed
!	   up the common pushing and popping cases by avoiding the
!	   saving of unnecessary registers.  JBS 25-JAN-1979
! 1-020	- Change linkage for OTS$PUSH_CCB to JSB_CB_PUSH and for
!	   OTS$POP_CCB to JSB_CB_POP.  JBS 25-JAN-1979
! 1-021	- Clear length of prompt buffer when pushing.  JBS 26-JAN-1979
! 1-022	- Remove OTS$CLEANUP_IO, we will clean I/O using a stack
!	   frame instead.  JBS 26-JAN-1979
! 1-023	- Change to double dollar signs since these entry points are
!	   not for use by users.  JBS 26-JAN-1979
! 1-024	- Deallocate the LUN after the LUB/ISB/RAB has been deallocated.
!	   Note that OPEN allocates it.  JBS 26-JAN-1979
! 1-025	- Make the table storage PIC, even though it is used by INSQUE
!	   and REMQUE instructions, by initializing it at run time.
!	   This requires disabling ASTs during initialization, but it is
!	   done only once per image activation.  JBS 28-JAN-1979
! 1-026	- Rearrange the order of some of the manipulations to make
!	   PUSH and POP really AST re-entrant.  JBS 29-JAN-1979
! 1-027	- Make these routines AST reentrant
!	   in the face of deallocation at AST level.  JBS 31-JAN-1979
! 1-028	- If LUB$V_USER_RBUF is set, don't deallocate the record
!	   buffer, it belongs to the user!  JBS 16-FEB-1979
! 1-029	- Clear the buddy's buddy pointer, which points to us, when
!	   deallocating.  JBS 16-FEB-1979
! 1-030	- Print an error message if the ISB overlaps the LUB.  This can
!	   happen if the LUB is extended but the ISB is not edited to
!	   reflect it.  JBS 21-MAR-1979
! 1-031	- Initialize LUB$Q_BFA_QUEUE.  JBS 05-APR-1979
! 1-032	- Don't free the file name string unless it has been allocated
!	   in virtual memory.  JBS 10-APR-1979
! 1-033	- Don't free the record buffer unless it has been allocated.
!	   JBS 10-APR-1979
! 1-034 - Free the compiled format, if allocated.  SBL 27-Apr-1979
! 1-035 SBL1035 - Set ISB$W_FMT_LEN to zero on allocation.  SBL 4-May-79
! 1-036 - Change CASE off result of REMQUE to match what is
!	  actually given by that function.  SBL 9-May-1979
! 1-037 - Change require file name to OTSCCBREQ so as not to conflict
!	  with this module at system build time.  SBL 10-May-1979
! 1-038 - Move clearing of ISB$W_FMT_LEN to allocation stage.  SBL 14-May-1979
! 1-039 - Fix bug in compiled format deallocation.  SBL 15-May-1979
! 1-040 - Fix another one.  Length must be passed as address of a word!
! 1-041 - We overlooked the REMQUE in DEALLOCATE.  SBL 17-May-1979
!	  So, we have to construct a temp.  SBL 17-May-1979
! 1-042	- Clear ISB$W_FMT_LEN during PUSH, so that POP won't try
!	   to deallocate the format prematurely.  JBS 29-MAY-1979
! 1-043	- Set up LUB$A_BUDDY_PTR during allocate.  JBS 30-MAY-1979
! 1-044	- Make much of the data structure global so it can be
!	   referenced directly by FOR$$CB.  JBS 28-JUN-1979
! 1-045	- Do an RMS $WAIT if there is I/O active on the unit we
!	   are starting.  JBS 25-JUL-1979
! 1-046	- Don't make OTS$Q_IO_ACTIVE global.  JBS 26-JUL-1979
! 1-047	- Save the prompt buffer only if it really is a prompt buffer.
!	   If it is a key buffer, the key may be in read-only storage.
!	   JBS 09-AUG-1979
! 1-048	- Move the global parts of the data base to OTS$$CCB_DATA
!	   so this module need not be loaded if only FORTRAN programs
!	   are in the image.  JBS 16-AUG-1979
! 1-049	- Return CCB as 0 from POP to indicate deallocation.  JBS 17-AUG-1979
! 1-050	- Correct an error in a comment.  JBS 10-SEP-1979
! 1-051	- When deallocating, LUB$A_BUF_BEG points to the buffer; in locate
!	   mode, LUB$A_RBUF_ADR may point to RMS space.  JBS 13-SEP-1979
! 1-052	- Remove the references to ISB$W_FMT_LEN; now done in FORCB.
!	   JBS 18-SEP-1979
! 1-053	- Remove references to LUB$Q_BFA_QUEUE; no longer used.
!	   JBS 18-SEP-1979
! 1-054	- Correct a minor typo.  JBS 24-OCT-1979
! 1-055	- Use the new UBF cell in the LUB.  JBS 13-NOV-1979
! 1-056	- Don't initialize LUB table entries in use by FORTRAN.  JBS 14-JAN-1980
! 1-057 - Take out clearing of RAB$B_PSZ (put it in BAS$$IO_BEG)
!	  to make locality consistent. FM 4-SEP-1980
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';				! Define LINKAGEs

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    INITIALIZE : NOVALUE,			! Set up the LUB table and the active queue
    PUSH_FAKE : CALL_CCB,			! Push fake record
    PUSH_ACTIVE : CALL_CCB,			! Push active LUB
    ALLOCATE : CALL_CCB,			! Allocate LUB/ISB/RAB
    OTS$$PUSH_CCB : JSB_CB_PUSH,		! Get the CCB, push old use of it
    DEALLOCATE : CALL_CCB NOVALUE,		! Deallocate LUB/ISB/RAB
    POP_ACTIVE : CALL_CCB NOVALUE,		! Pop active LUN
    OTS$$POP_CCB : JSB_CB_POP NOVALUE;		! Restore old use of CCB

!
! INCLUDE FILES:
!

REQUIRE 'RTLML:OTSISB';				! get length of ISB

REQUIRE 'RTLML:OTSLUB';				! get length of LUB

REQUIRE 'RTLIN:RTLPSECT';			! Define DECLARE_PSECTs macro

REQUIRE 'RTLIN:OTSCCBREQ';			! Define interface to  OTS$PUSH_CCB

LIBRARY 'RTLSTARLE';				! STARLET library for macros and symbols

!
! MACROS:
!

MACRO
    TEST_LUB_ISB =
!+
! Give an error message if the ISB and the LUB overlap.  Try to make the
! message explicit enough to tell the maintainer exactly what to do, since
! it will print only when the RTL is being modified by someone who does not
! know about the LUB-ISB dependency, and therefore may need a lot of hand-
! holding.
!-

%IF (LUB$K_NEG_BLN NEQ ISB$K_NEG_LUB)
%THEN

COMPILETIME
    VAL1 = -ISB$K_NEG_LUB,
    VAL2 = -LUB$K_NEG_BLN;

%ERROR (' LUB$K_NEG_BLN is not equal to ISB$K_NEG_LUB.',
    '  This probably means that the LUB has been extended',
    ' without editing the ISB to allow for it.  Please edit file OTSISB.MDL, making the -F,B,',
    %NUMBER (VAL1), ' be -F,B,', %NUMBER (VAL2))
%FI

%;

!
! EQUATED SYMBOLS:
!

LITERAL
    K_TOTAL_CCB_LEN = LUB$K_LUB_LEN + ISB$K_ISB_LEN + RAB$C_BLN;	! length of LUB+ISB+RAB

!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (OTS);				! declare PSECTs for OTS$ facility
!
! OWN STORAGE:
!
!+
! The following quadword is the header of the I/O active queue.  Items
! are manipulated on this queue using the INSQUE and REMQUE instructions.
!-

OWN
    OTS$Q_IO_ACTIVE : VECTOR [2];

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$GET_VM,					! Allocate virtual memory
    LIB$FREE_VM,				! Deallocate virtual memory
    LIB$STOP : NOVALUE,				! Signal a fatal error
    OTS$$FREE_LUN;				! Deallocate a LUN

EXTERNAL LITERAL
    OTS$_FATINTERR : UNSIGNED (%BPVAL);		! condition value for FATAL INTERNAL ERROR

						! IN RUN-TIME LIBRARY error.
!+
! The following externals represent the global part of the CCB
! data base.
!-

EXTERNAL
    OTS$$V_CCB_INIT : VOLATILE,			! True if INIT done
    OTS$$AA_LUB_TAB : VOLATILE OTS$$LUB_TAB_ST 	!
	[-LUB$K_ILUN_MIN + LUB$K_LUN_MAX + 1, LUB$K_ILUN_MIN],	! Pointers to CCBs
    OTS$$V_IOINPROG : VOLATILE BITVECTOR,	! True if LUN has I/O active
    OTS$$A_CUR_LUB,				! The current LUB
    OTS$$L_CUR_LUN,				! The current logical unit
    OTS$$L_LVL_CTR;				! -1 = ILDE, 0 = 1 I/O in progress.

BUILTIN
    INSQUE,					! Insert an item in a queue
    REMQUE,					! Remove an item from a queue
    TESTBITSS,					! Test bit, set it, return true if it was set.
    TESTBITCC;					! Test bit, clear it, return true if it was clear.

!<BLF/PAGE>

!+
! The following field set represents an item pushed onto the
! I/O Active list.  It contains the ISB, the prompt buffer, the
! current size of the prompt buffer, and the timeout value from
! the RAB.
!-

FIELD
    PUSH_ITEM =
	SET
	PUSH$A_NEXT = [0, 0, %BPVAL, 0],	! Next item
	PUSH$A_PREV = [4, 0, %BPVAL, 0],	! Previous item
	PUSH$L_STS = [8, 0, %BPVAL, 0],		! RMS status
	PUSH$L_STV = [12, 0, %BPVAL, 0],	! RMS extra status
	PUSH$W_LUN = [16, 0, 16, 1],		! Logical unit number
	PUSH$B_PSZ = [18, 0, 8, 0],		! Prompt buffer size
	PUSH$B_TMO = [19, 0, 8, 0],		! The RMS timeout value
	PUSH$V_IO_ACT = [20, 0, 1, 0],		! The I/O Active flag
	PUSH$V_FAKE = [20, 1, 1, 0],		! The "fake" flag
	PUSH$V_PMT = [20, 2, 1, 0],		! Set if there is a prompt buffer.
	PUSH$T_PROMPT = [21, 0, 0, 0],		! The prompt buffer
	PUSH$X_ISB = [LUB$K_PBUF_SIZ + 21, 0, 0, 0]	! The ISB
	TES;

LITERAL
    PUSH$K_LENGTH = 21 + LUB$K_PBUF_SIZ + ISB$K_ISB_LEN;	! Number of bytes to allocate


ROUTINE INITIALIZE : NOVALUE = 			! Set up OWN storage

!++
! FUNCTIONAL DESCRIPTION:
!
!	Set up the LUB table, I/O Active queue and OTS$$L_CUR_LUN.
!	The LUB table and I/O active queue must be set up at run time
!	because they must be initialized with addresses, and this
!	cannot be done at link time or they will cease to be position
!	independent.  They must be initialized with addresses because
!	they are used by INSQUE and REMQUE to avoid disabling ASTs.
!
! CALLING SEQUENCE:
!
!	IF (NOT .OTS$$V_CCB_INIT) THEN INITIALIZE ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	OTS$$AA_LUB_TAB
!	OTS$$Q_IO_ACTIVE
!	OTS$$V_IOINPROG
!	OTS$$L_CUR_LUN
!
! IMPLICIT OUTPUTS:
!
!	OTS$$AA_LUB_TAB
!	OTS$$Q_IO_ACTIVE
!	OTS$$V_IOINPROG
!	OTS$$L_CUR_LUN
!	OTS$$V_CCB_INIT
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
!+
! The following cell keeps track of whether or not ASTs were disabled
! when we were called.
!-
	AST_STATUS;

!+
! First disable ASTs.  Then, if the initialization has not yet been
! done, do it.  The initialization will have been done if an AST went
! off between the test of OTS$$V_CCB_INIT and this point.
!-
    AST_STATUS = $SETAST (ENBFLG = 0);

    IF ( NOT .OTS$$V_CCB_INIT)
    THEN
	BEGIN
!+
! We must do the initialization.  First set the LUB table to be empty.
! Note that LUBs in use by FORTRAN are not touched.  FORTRAN leaves the
! first longword non-zero for entries it is using.
!-

	INCR LUN FROM LUB$K_ILUN_MIN TO LUB$K_LUN_MAX DO
	    IF (.OTS$$AA_LUB_TAB [.LUN, 0] EQL 0) THEN
	    OTS$$AA_LUB_TAB [.LUN, 0] = OTS$$AA_LUB_TAB [.LUN, 1] = OTS$$AA_LUB_TAB [.LUN, 0];

!+
! Now make the I/O active queue empty.
!-
	OTS$Q_IO_ACTIVE [0] = OTS$Q_IO_ACTIVE [1] = OTS$Q_IO_ACTIVE [0];
!+
! Mark that the initialization has been done, so it won't be done again.
!-
	OTS$$V_CCB_INIT = 1;
	END;

!+
! If ASTs were enabled at entry, re-enable them.
!-

    IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST (ENBFLG = 1);

    RETURN;
    END;					! of routine INITIALIZE

ROUTINE PUSH_FAKE : CALL_CCB = 			! Push a "fake" active record

!++
! FUNCTIONAL DESCRIPTION:
!
!	Push onto the I/O Active queue a place holder.  This is to
!	satisfy POP_ACTIVE when we can't actually push the CCB.
!
! CALLING SEQUENCE:
!
!	CALL PUSH_FAKE ();
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	OTS$$Q_IO_ACTIVE
!	OTS$$L_CUR_LUN
!
! IMPLICIT OUTPUTS:
!
!	OTS$$Q_IO_ACTIVE	Holds previous I/O on this LUN
!
! SIDE EFFECTS:
!
!	Calls LIB$GET_VM to get virtual memory.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
!+
! Declare the pointer to the block to push.
!-
	PUSH : REF BLOCK [PUSH$K_LENGTH, BYTE] FIELD (PUSH_ITEM),
	LUN;

    LUN = .OTS$$L_CUR_LUN;
!+
! Get virtual memory to hold the fake activation record.
!-
    BEGIN

    LOCAL
	GET_VM_RESULT;

    GET_VM_RESULT = LIB$GET_VM (%REF (PUSH$K_LENGTH), PUSH);

    IF ( NOT .GET_VM_RESULT) THEN RETURN (OTS$K_PUSH_FAIL);

    END;
!+
! Copy the old LUN into the fake record, and mark it as fake.
!-
    PUSH [PUSH$W_LUN] = .LUN;
    PUSH [PUSH$V_FAKE] = 1;
!+
! Put this item on the I/O Active list.
!-
    INSQUE (.PUSH, OTS$Q_IO_ACTIVE);
!+
! We also set OTS$$L_CUR_LUN to LUB$K_LUN_MAX+1 to prevent an
! AST from pushing that LUB again.  An extra push before this point
! does not cause any harm (only wastes a little time).
!-
    OTS$$L_CUR_LUN = LUB$K_LUN_MAX + 1;
    RETURN (OTS$K_PUSH_OK);
    END;					! of routine PUSH_FAKE

ROUTINE PUSH_ACTIVE (LOGICAL_UNIT, 		! The new LUN
	RECURSIVE_IO				! True if really recursive I/O
    ) : CALL_CCB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Place the ISB, etc. of the currently active logical unit on the
!	I/O Active queue so that another I/O statement may be started.
!	The I/O statement to be started may be on the same or another
!	logical unit as the one being interrupted.  When the new I/O
!	statement is complete the old one will be continued, so the I/O
!	active queue has a first-in-first-out discipline.
!
! CALLING SEQUENCE:
!
!	RESULT = CALL PUSH_ACTIVE (LUN, RECURSIVE_IO);
!
! FORMAL PARAMETERS:
!
!	LOGICAL_UNIT.rl.v	The new LUN
!	RECURSIVE_IO.rl.v	True if this LUN was already active
!
! IMPLICIT INPUTS:
!
!	OTS$$AA_LUB_TAB
!	OTS$$Q_IO_ACTIVE
!	OTS$$L_CUR_LUN
!
! IMPLICIT OUTPUTS:
!
!	OTS$$Q_IO_ACTIVE	Holds previous I/O on this LUN
!
! SIDE EFFECTS:
!
!	Calls LIB$GET_VM to get virtual memory.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
!+
! Declare the pointer to the block to push.
!-
	PUSH : REF BLOCK [PUSH$K_LENGTH, BYTE] FIELD (PUSH_ITEM);

!+
! If there is no need to push anything, push a fake activation
! record to satisfy POP_ACTIVE.
!-

    IF (.OTS$$L_CUR_LUN GTR LUB$K_LUN_MAX) THEN RETURN (PUSH_FAKE ());

!+
! Check for this being an AST between the clearing of OTS$$V_IOINPROG
! and the setting of OTS$$L_CUR_LUN to LUB$K_LUN_MAX + 1.  If it
! is we cannot push the CCB, since, with RECURSIVE_IO clear,
! OTS$$V_IOINPROG will be cleared before the call to POP_ACTIVE,
! and we might try to pop into a deallocated CCB.
!-

    IF ((.OTS$$L_CUR_LUN EQL .LOGICAL_UNIT) AND ( NOT .RECURSIVE_IO)) THEN RETURN (PUSH_FAKE ());

    CCB = .OTS$$AA_LUB_TAB [.OTS$$L_CUR_LUN, 0];
!+
! If the queue is empty then the deallocation code has removed the LUB
! from the LUB table but has not yet popped OTS$$L_CUR_LUN.  Since
! the deallocation code will finish its deallocation no matter what
! we do here we need not push anything.  If any I/O is tried to this
! LUN it will create a new LUB.  The recursive flag may be set
! needlessly,  but that will only cause a problem in languages which
! do not support recursive I/O, and, actually, the higher I/O has not
! quite finished yet, so that is OK.
!-

    IF (.CCB EQLA OTS$$AA_LUB_TAB [.OTS$$L_CUR_LUN, 0]) THEN RETURN (PUSH_FAKE ());

!+
! The LUB is still allocated, do some consistency checks.
! We cannot check OTS$$AA_CUR_LUB since we may be in an AST that
! occurred after the update of OTS$$AA_CUR_LUB but before OTS$$L_CUR_LUN.
!-
    CCB = .CCB + (.CCB - CCB [LUB$Q_QUEUE]);

    IF (.CCB [LUB$W_LUN] NEQ .OTS$$L_CUR_LUN) THEN LIB$STOP (OTS$_FATINTERR);

!+
! Get virtual memory to hold the old ISB, etc.
!-
    BEGIN

    LOCAL
	GET_VM_RESULT;

    GET_VM_RESULT = LIB$GET_VM (%REF (PUSH$K_LENGTH), PUSH);

    IF ( NOT .GET_VM_RESULT) THEN RETURN (OTS$K_PUSH_FAIL);

    END;
!+
! Make sure there is no RMS I/O active on the RAB.
!-

    IF (.RECURSIVE_IO) THEN $WAIT (RAB = .CCB);

!+
! Copy the ISB and a few other things that need to be preserved
! over recursive I/O into the block we just allocated.
!-
    CH$MOVE (ISB$K_ISB_LEN, .CCB - ISB$K_ISB_LEN - LUB$K_LUB_LEN, PUSH [PUSH$X_ISB]);
    PUSH [PUSH$V_PMT] = .CCB [RAB$V_PMT];

    IF (.PUSH [PUSH$V_PMT])
    THEN
	BEGIN
	CH$MOVE (.CCB [RAB$B_PSZ], .CCB [RAB$L_PBF], PUSH [PUSH$T_PROMPT]);
	PUSH [PUSH$B_PSZ] = .CCB [RAB$B_PSZ];
	END;

    PUSH [PUSH$B_TMO] = .CCB [RAB$B_TMO];
    PUSH [PUSH$L_STS] = .CCB [RAB$L_STS];
    PUSH [PUSH$L_STV] = .CCB [RAB$L_STV];
    PUSH [PUSH$V_IO_ACT] = .CCB [LUB$V_IO_ACTIVE];
    PUSH [PUSH$V_FAKE] = 0;
!+
! Record the logical unit number so that POP_ACTIVE knows where to
! restore this item when it is popped.
!-
    PUSH [PUSH$W_LUN] = .CCB [LUB$W_LUN];
!+
! Put this item on the I/O Active list.
!-
    INSQUE (.PUSH, OTS$Q_IO_ACTIVE);
!+
! That LUB is no longer the active one, mark it so.
!-
    CCB [LUB$V_IO_ACTIVE] = 0;
!+
! We also set OTS$$L_CUR_LUN to LUB$K_LUN_MAX+1 to prevent an
! AST from pushing that LUB again.  An extra push before this point
! does not cause any harm (only wastes a little time).
!-
    OTS$$L_CUR_LUN = LUB$K_LUN_MAX + 1;
    RETURN (OTS$K_PUSH_OK);
    END;					! of routine PUSH_ACTIVE

ROUTINE ALLOCATE (LOGICAL_UNIT) : CALL_CCB = 	! Allocate LUB/ISB/RAB

!++
! FUNCTIONAL DESCRIPTION:
!
!	Allocate the LUB/ISB/RAB for this logical unit, watching out for
!	ASTs which may do the allocation as we are running.
!
! CALLING SEQUENCE:
!
!	CALL ALLOCATE (.LOGICAL_UNIT)
!
! FORMAL PARAMETERS:
!
!	LOGICAL_UNIT.rl.v	The logical unit number for this CCB
!
! IMPLICIT INPUTS:
!
!	OTS$$AA_LUB_TAB
!
! IMPLICIT OUTPUTS:
!
!	OTS$$AA_LUB_TAB
!	CCB
!
! SIDE EFFECTS:
!
!	Calls LIB$GET_VM to get virtual memory.
!	May call LIB$FREE_VM to free that same virtual memory.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	INSQUE_ADDR,				! Address for INSQUE instruction
	REMQUE_ADDR,				! Address for REMQUE instruction
	CCB_ADDR;				! Address of the allocated CCB

!+
! Test the definitions of the LUB and ISB for consistency.  This is
! purely a compile-time test; it generates no code.
!-
    TEST_LUB_ISB;
!+
! We must allocate.  This case is a little complex since an AST may
! allocate the LUB.  We handle this by preparing the LUB and then
! checking to see if an AST allocated one.  If so, we deallocate ours.
!-
    BEGIN

    LOCAL
	GET_VM_RESULT;

    GET_VM_RESULT = LIB$GET_VM (%REF (K_TOTAL_CCB_LEN), CCB_ADDR);

    IF ( NOT .GET_VM_RESULT) THEN RETURN (OTS$K_PUSH_FAIL);

    END;
!+
! Clear the newly allocated LUN and RAB (but not ISB).  Adjust the
! contents of the control block pointer (CCB) so that it points to
! the beginning of the RAB.  (The ISB and LUB preceed the RAB using
! negative offsets with respect to register CCB.)
! Set the unit number in the newly allocated LUB.
!-
    CCB = .CCB_ADDR;
    CH$FILL (0, LUB$K_LUB_LEN + RAB$C_BLN, .CCB + ISB$K_ISB_LEN);
    CCB = .CCB + ISB$K_ISB_LEN + LUB$K_LUB_LEN;
    CCB [LUB$W_LUN] = .LOGICAL_UNIT;
!+
! Initialize RAB to constants which never change.
! Block ID, block length, and bit to make $PUT do $UPDATE if
! record exists.  Also truncate on sequential $PUT not at EOF.
! Note: TPT bit depends on FOP TRN bit being set in order to take effect.
! Set read-ahead, write-behind and locate mode for GETs.
!-
    CCB [RAB$B_BID] = RAB$C_BID;
    CCB [RAB$B_BLN] = RAB$C_BLN;
    CCB [RAB$V_UIF] = 1;
    CCB [RAB$V_TPT] = 1;
    CCB [RAB$V_RAH] = 1;
    CCB [RAB$V_WBH] = 1;
    CCB [RAB$V_LOC] = 1;
!+
! Set up LUB$A_BUDDY_PTR.   If this CCB is not its own buddy, this
! field will be changed during open.
!-
    CCB [LUB$A_BUDDY_PTR] = .CCB;
!+
! See if an AST has allocated this LUB/RAB/ISB while we were preparing
! ours above.  If so, we use the allocated one.  If the LUB was
! allocated by an AST it cannot have I/O active, since the AST must
! complete any I/O it starts.  In spite of this, it cannot be
! deallocated because we have OTS$$V_IOINPROG set for the LUN.
!-
    INSQUE_ADDR = OTS$$AA_LUB_TAB [.LOGICAL_UNIT, 1];

    IF ( NOT INSQUE (CCB [LUB$Q_QUEUE], ..INSQUE_ADDR))
    THEN
	BEGIN
!+
! This CCB is not the first in the queue, which means that an AST
! has allocated one and put it in the queue before us.  Remove ours
! and deallocate it.  We will use the LUB previously on the queue.
!-
	REMQUE_ADDR = OTS$$AA_LUB_TAB [.LOGICAL_UNIT, 1];

	CASE (REMQUE (..REMQUE_ADDR, CCB)) FROM 0 TO 3 OF
	    SET

	    [2] :
!+
! Somebody removed the other entry.  This should never happen.
!-
		LIB$STOP (OTS$_FATINTERR);

	    [3] :
!+
! The queue was empty.  This is unreasonable because OTS$$V_IOINPROG is set.
!-
		LIB$STOP (OTS$_FATINTERR);

	    [0] :
!+
! All is well.  We can now free the CCB we just removed.
! It had better be the one we allocated.
!-

		IF ((.CCB + (.CCB - CCB [LUB$Q_QUEUE])) NEQA (.CCB_ADDR + ISB$K_ISB_LEN + LUB$K_LUB_LEN))
		THEN
		    LIB$STOP (OTS$_FATINTERR);

	    [INRANGE, OUTRANGE] :
!+
! This should never happen;  the only possible values from the REMQUE
! function are 0, 2 and 3.
!-
		LIB$STOP (OTS$_FATINTERR);
	    TES;

!+
! Now free the LUB we allocated.
!-
	BEGIN

	LOCAL
	    FREE_VM_STATUS;

	FREE_VM_STATUS = LIB$FREE_VM (%REF (K_TOTAL_CCB_LEN), CCB_ADDR);

	IF ( NOT .FREE_VM_STATUS) THEN LIB$STOP (OTS$_FATINTERR);

	END;
!+
! Now fetch the CCB address.  It must still be there because of
! OTS$$V_IOINPROG.
!-
	CCB = .OTS$$AA_LUB_TAB [.LOGICAL_UNIT, 0];
	CCB = .CCB + (.CCB - CCB [LUB$Q_QUEUE]);
	END;

    RETURN (OTS$K_PUSH_OK);
    END;					! of routine ALLOCATE


GLOBAL ROUTINE OTS$$PUSH_CCB (			! Get a CCB, pushing old
	LOGICAL_UNIT				! Logical unit for this CCB
)    : JSB_CB_PUSH =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Load register CCB with a pointer to the LUB/ISB/RAB for this
!	logical unit.  If no LUB has been allocated, allocate one.
!	If there is already I/O active push down the old ISB, etc.
!	POP_ACTIVE will restore it.  We already know that this LUN is
!	not in use by FORTRAN.
!
! CALLING SEQUENCE:
!
!	CALL OTS$$PUSH_CCB (logical_unit.rl.v)
!
! FORMAL PARAMETERS:
!
!	logical_unit.rl.v	Logical unit  - identifies CCB
!
! IMPLICIT INPUTS:
!
!	OTS$$V_CCB_INIT
!	OTS$$AA_LUB_TAB
!	OTS$$Q_IO_ACTIVE
!
! IMPLICIT OUTPUTS:
!
!	CCB			Set to adr. of allocated LUB/ISB/RAB
!	OTS$$Q_IO_ACTIVE	Holds previous I/O on this LUN
!	OTS$AA_LUB_TAB		Set of adr. of allocated LUB/ISB/RAB
!				for logical_unit
!	LUB$W_LUN		Set to logical_unit
!	LUB$V_IO_ACTIVE		Set to indicate active I/O
!	OTS$$V_CCB_INIT		Always set to 1.
!
! SIDE EFFECTS:
!
!	May call LIB$GET_VM to get virtual memory.
!	In unusual cases, may call LIB$FREE_VM to free virtual memory.
!	The first time entered, calls INITIALIZE, which disables ASTs.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	RECURSIVE_IO;				! =1 if we are doing recursive I/O

!+
! If this is the first entry, call INITIALIZE to set up OWN storage.
! Note that PUSH_CCB must be entered before POP_CCB, so this is the
! first reference to this data base, except for FORTRAN, which is checked
! for in INITIALIZE.
!-

    IF ( NOT .OTS$$V_CCB_INIT) THEN INITIALIZE ();

!+
! Count the level counter.  This must be done before the OTS$$V_IOINPROG
! bit is set, otherwise an AST could find the OTS$$V_IOINPROG bit set but
! level counter -1, which would mean that the PUSH and POP routines
! would not be called and OTS$$V_IOINPROG would get cleared by the AST.
!-
    OTS$$L_LVL_CTR = .OTS$$L_LVL_CTR + 1;
!+
! Mark that this LUN has I/O active so that its LUB (if it has one yet)
! will not be deallocated.  If it was already active, remember that.
!-
    RECURSIVE_IO = (TESTBITSS (OTS$$V_IOINPROG [.LOGICAL_UNIT - LUB$K_ILUN_MIN]));
!+
! If I/O is currently active, push the presently active unit.
!-

    IF (.OTS$$L_LVL_CTR NEQ 0)
    THEN
	BEGIN

	LOCAL
	    PUSH_RESULT;

	PUSH_RESULT = PUSH_ACTIVE (.LOGICAL_UNIT, .RECURSIVE_IO);

	IF (.PUSH_RESULT NEQ OTS$K_PUSH_OK) THEN RETURN (.PUSH_RESULT);

	END;

!+
! Allocate the LUB/ISB/RAB if necessary.  If an AST allocates it we
! must release ours.  Note that, because OTS$$V_IOINPROG is set, if an
! AST allocates the LUB it will not be deallocated.
!-
    CCB = .OTS$$AA_LUB_TAB [.LOGICAL_UNIT, 0];

    IF (.CCB NEQA OTS$$AA_LUB_TAB [.LOGICAL_UNIT, 0])
    THEN
	BEGIN
!+
! The CCB is already allocated.  Adjust register CCB to point to it.
!-
	CCB = .CCB + (.CCB - CCB [LUB$Q_QUEUE]);
	END
    ELSE
	BEGIN

	LOCAL
	    ALLOCATE_RESULT;

	ALLOCATE_RESULT = ALLOCATE (.LOGICAL_UNIT);

	IF (.ALLOCATE_RESULT NEQ OTS$K_PUSH_OK) THEN RETURN (.ALLOCATE_RESULT);

	END;

!+
! Set OTS$$L_CUR_LUN to be the current logical unit number.  This is
! the cell that controls pushing.
!-
    OTS$$L_CUR_LUN = .LOGICAL_UNIT;
!+
! Mark this LUB as being the active one, and, if it is participating
! in recursive I/O, mark that, too.
!-
    CCB [LUB$V_IO_ACTIVE] = 1;
    CCB [ISB$V_RECURSIVE] = .RECURSIVE_IO;
!+
! Set OTS$$A_CUR_LUB to point to the new current LUB.
!-
    OTS$$A_CUR_LUB = .CCB;
!+
! Initialize the STTM_STAT field of the ISB.  We clear these bits so
! that the initialization routines at UDF and REC levels can set them
! if necessary (unusual) or do nothing to have them cleared.
!-
    CCB [ISB$V_P_FORM_CH] = 0;
    CCB [ISB$V_DOLLAR] = 0;
    CCB [ISB$V_USER_ELEM] = 0;
    CCB [ISB$V_SLASH] = 0;
    CCB [ISB$V_LAST_REC] = 0;
    CCB [ISB$V_DE_ENCODE] = 0;
    CCB [ISB$V_LIS_HEAP] = 0;
!+
! When we set OTS$$V_IOINPROG we tested it to see if I/O was already active
! on this LUN.  If it was we must return this information to our
! caller because some languages do not permit recursive I/O.
!-

    IF (.RECURSIVE_IO) THEN RETURN (OTS$K_PUSH_ACT);

    RETURN (OTS$K_PUSH_OK);
    END;					! End of routine OTS$$PUSH_CCB


ROUTINE DEALLOCATE : CALL_CCB NOVALUE = 	! Deallocate LUB/ISB/RAB

!++
! FUNCTIONAL DESCRIPTION:
!
!	Deallocate the LUB/ISB/RAB for this logical unit, including
!	the allocated structures attached to it.  Also, deallocate the
!	LUN.
!
! CALLING SEQUENCE:
!
!	CALL DEALLOCATE ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	OTS$$AA_LUB_TAB
!	CCB
!
! IMPLICIT OUTPUTS:
!
!	OTS$$AA_LUB_TAB
!	CCB
!
! SIDE EFFECTS:
!
!	Calls LIB$FREE_VM to free virtual memory.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	REMQUE_ADDR,				! Address for REMQUE instruction
	CCB_ADDR : REF BLOCK [0, BYTE],
	BUDDY_CCB : REF BLOCK [0, BYTE],
	LUN;

!+
! We now deallocate the LUB/ISB/RAB.  An AST will not deallocate under
! us because it will find OTS$$V_IOINPROG set at PUSH time, and will
! therefore set ISB$V_RECURSIVE so as not to clear OTS$$V_IOINPROG at POP
! time or deallocate the LUB.
!-
    REMQUE_ADDR = OTS$$AA_LUB_TAB [.CCB [LUB$W_LUN], 0];

    CASE (REMQUE (..REMQUE_ADDR, CCB_ADDR)) FROM 0 TO 3 OF
	SET

	[0, 3] :
!+
! Zero means that there was more than one entry in the queue.
! This implies that we have done a CLOSE in an AST which went off after
! the INSQUE but before the compensating REMQUE in PUSH_CCB.
! This should never happen because ISB$V_RECURSIVE
! will be set in this case.
!
! Three implies that there is nothing in the queue.
! This means that an AST deallocated the LUB, which should not happen
! because of the ISB$V_RECURSIVE test.
!-
	    LIB$STOP (OTS$_FATINTERR);

	[2] :
!+
! The queue is now empty.  This is correct.  We can now free the LUB.
! Note that PUSH_CCB will allocate a new LUB if an AST goes off to it
! here, and will carefully not push the LUB we are deallocating.
! First perform a consistency check.
!-

	    IF (.CCB_ADDR + (.CCB_ADDR - CCB_ADDR [LUB$Q_QUEUE]) NEQA .CCB) THEN LIB$STOP (OTS$_FATINTERR);

	[INRANGE, OUTRANGE] :
!+
! This should never happen. The only possible values of REMQUE are
! 0, 2 and 3.
!-
	    LIB$STOP (OTS$_FATINTERR);
	TES;

!+
! Since the LUB/ISB/RAB can no longer be used, clear its OTS$$V_IOINPROG
! bit.  An AST after this point will not indicate recursive I/O.
!-

    IF (TESTBITCC (OTS$$V_IOINPROG [.CCB [LUB$W_LUN] - LUB$K_ILUN_MIN])) THEN LIB$STOP (OTS$_FATINTERR);

!+
! Clear this LUN's buddy's buddy pointer, which points to us.
!-
    BUDDY_CCB = .CCB [LUB$A_BUDDY_PTR];

    IF (.BUDDY_CCB NEQA 0) THEN BUDDY_CCB [LUB$A_BUDDY_PTR] = 0;

!+
! Free the record buffer if we allocated it.
!-

    IF (( NOT .CCB [LUB$V_USER_RBUF]) AND (.CCB [LUB$A_UBF] NEQA 0))
    THEN
	BEGIN

	LOCAL
	    FREE_VM_STATUS;

	FREE_VM_STATUS = LIB$FREE_VM (%REF (.CCB [LUB$W_RBUF_SIZE]), CCB [LUB$A_UBF]);

	IF ( NOT .FREE_VM_STATUS) THEN LIB$STOP (OTS$_FATINTERR);

	END;

!+
! Free the file name string, if it is allocated.
!-

    IF (.CCB [LUB$V_VIRT_RSN])
    THEN
	BEGIN

	LOCAL
	    FREE_VM_STATUS;

	FREE_VM_STATUS = LIB$FREE_VM (%REF (.CCB [LUB$B_RSL]), CCB [LUB$A_RSN]);

	IF ( NOT .FREE_VM_STATUS) THEN LIB$STOP (OTS$_FATINTERR);

	CCB [LUB$V_VIRT_RSN] = 0;
	END;

!+
! Free the prompt buffer, if there is one.
!-
    BEGIN

    LOCAL
	FREE_VM_STATUS;

    IF ((.CCB [RAB$L_PBF] NEQA 0) AND (.CCB [RAB$V_PMT]))
    THEN
	BEGIN
	FREE_VM_STATUS = LIB$FREE_VM (%REF (LUB$K_PBUF_SIZ), CCB [RAB$L_PBF]);

	IF ( NOT .FREE_VM_STATUS) THEN LIB$STOP (OTS$_FATINTERR);

	END;

    END;
!+
! Remember the logical unit number, since we will need it in a minute.
!-
    LUN = .CCB [LUB$W_LUN];
!+
! Now, at last, we can free the CCB itself.
!-
    BEGIN

    LOCAL
	FREE_VM_STATUS;

    FREE_VM_STATUS = LIB$FREE_VM (%REF (K_TOTAL_CCB_LEN), %REF (.CCB - ISB$K_ISB_LEN - LUB$K_LUB_LEN));

    IF ( NOT .FREE_VM_STATUS) THEN LIB$STOP (OTS$_FATINTERR);

    END;
!+
! Since the CCB points to deallocated storage, clear register CCB so
! that, if anybody refers to it, we will get an access violation.
!-
    CCB = 0;
!+
! If the user's program is still running (i.e., if we are not in the
! exit handler) then the user must have done an explicit CLOSE to cause
! this LUB to be deallocated.  In that case we must clear the LUN
! allocation so he can do another OPEN on this same logical unit.
! Note that LUNs less than zero do not have allocation bits since they
! cannot be opened explicitly by the user.
!-

    IF (.LUN GEQ 0)
    THEN

	IF ( NOT OTS$$FREE_LUN (LUN)) THEN LIB$STOP (OTS$_FATINTERR);

    RETURN;
    END;					! of routine DEALLOCATE

ROUTINE POP_ACTIVE : CALL_CCB NOVALUE = 	! Pop old active unit

!++
! FUNCTIONAL DESCRIPTION:
!
!	Restore the status of an interrupted I/O statement using the
!	information saved when the statement was interrupted.  All of
!	the ISB is restored, and a few other things.  In some unusual
!	cases there is no CCB to restore to, so only OTS$$L_CUR_LUN is
!	restored.
!
! CALLING SEQUENCE:
!
!	CALL POP_ACTIVE ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	The DEALLOC bit in the LUB
!
! IMPLICIT OUTPUTS:
!
!	The ISB, and some other fields of the CCB
!	CCB		The restored CCB
!
! SIDE EFFECTS:
!
!	Calls LIB$FREE_VM to free virtual memory.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	PUSH : REF BLOCK [PUSH$K_LENGTH, BYTE] FIELD (PUSH_ITEM),
	LUN;					! Logical unit number being restored

!+
! Get an activation record off the I/O Active queue.  It had better
! be there.
!-

    IF (REMQUE (.OTS$Q_IO_ACTIVE [0], PUSH)) THEN LIB$STOP (OTS$_FATINTERR);

!+
! Fetch the logical unit number associated with this record.
!-
    LUN = .PUSH [PUSH$W_LUN];
!+
! If this is a fake activation record, just store the LUN.
!-

    IF (.PUSH [PUSH$V_FAKE])
    THEN
	OTS$$L_CUR_LUN = .LUN
    ELSE
	BEGIN
!+
! If this LUN does not have I/O in progress then something is very
! wrong.
!-

	IF ( NOT .OTS$$V_IOINPROG [.LUN - LUB$K_ILUN_MIN]) THEN LIB$STOP (OTS$_FATINTERR);

!+
! There was previous I/O.  Restore the ISB, etc of the pushed unit.
! Because of ASTs, we must store OTS$$L_CUR_LUN before copying
! data from the I/O Active entry because only the LUN indicated by
! OTS$$L_CUR_LUN will get pushed.
!-
	OTS$$L_CUR_LUN = .LUN;
	CCB = .OTS$$AA_LUB_TAB [.LUN, 0];
	CCB = .CCB + (CCB [0, 0, 0, 0] - CCB [LUB$Q_QUEUE]);
	OTS$$A_CUR_LUB = .CCB;
	CCB [LUB$V_IO_ACTIVE] = .PUSH [PUSH$V_IO_ACT];
	CCB [RAB$L_STS] = .PUSH [PUSH$L_STS];
	CCB [RAB$L_STV] = .PUSH [PUSH$L_STV];
	CCB [RAB$B_TMO] = .PUSH [PUSH$B_TMO];

	IF (.PUSH [PUSH$V_PMT])
	THEN
	    BEGIN
	    CCB [RAB$B_PSZ] = .PUSH [PUSH$B_PSZ];
	    CH$MOVE (.CCB [RAB$B_PSZ], PUSH [PUSH$T_PROMPT], .CCB [RAB$L_PBF]);
	    END;

	CH$MOVE (ISB$K_ISB_LEN, PUSH [PUSH$X_ISB], .CCB - ISB$K_ISB_LEN - LUB$K_LUB_LEN);
!+
! If the LUN has been marked for deallocation (which means that it
! has been closed but not deallocated yet because it has I/O in
! progress) then clear the statement type field so that all
! continued I/O will fail.  The statement type must be set so that
! the owning language will get an error when I/O continues.
!-

	IF (.CCB [LUB$V_DEALLOC])
	THEN

	    CASE .CCB [LUB$B_LANGUAGE] FROM LUB$K_LANG_MIN TO LUB$K_LANG_MAX OF
		SET

		[LUB$K_LANG_FOR] :
		    CCB [ISB$B_STTM_TYPE] = ISB$K_FORSTTYLO - 1;

		[LUB$K_LANG_BAS] :
		    CCB [ISB$B_STTM_TYPE] = ISB$K_BASSTTYLO - 1;

		[LUB$K_LANG_NONE] :
		    CCB [ISB$B_STTM_TYPE] = 0;

		[OUTRANGE] :
		    LIB$STOP (OTS$_FATINTERR);
		TES;

	END;

!+
! We are done with the item from the I/O Active List, free it.
!-
    BEGIN

    LOCAL
	FREE_VM_RESULT;

    FREE_VM_RESULT = LIB$FREE_VM (%REF (PUSH$K_LENGTH), PUSH);

    IF ( NOT .FREE_VM_RESULT) THEN LIB$STOP (OTS$_FATINTERR);

    END;
    RETURN;
    END;					! of routine POP_ACTIVE


GLOBAL ROUTINE OTS$$POP_CCB 			! Restore old CCB
    : JSB_CB_POP NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Restore the I/O system to its state before the call to
!	PUSH_CCB.  Clear LUB$V_IO_ACTIVE.  If the I/O active list
!	is empty, clear OTS$$A_CUR_LUB, otherwise set it to
!	its previous value and restore its ISB, etc.
!
!	If virtual memory for a compiled format is allocated for this
!	ISB, it is freed.
!
! CALLING SEQUENCE:
!
!	CALL OTS$$POP_CCB ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	CCB
!	OTS$$AA_LUB_TAB
!	OTS$$Q_IO_ACTIVE
!
! IMPLICIT OUTPUTS:
!
!	CCB			Set to previous LUB/ISB/RAB
!	OTS$$Q_IO_ACTIVE	Holds one fewer item
!	LUB$V_IO_ACTIVE		Cleared to indicate I/O no longer active,
!				but may be set by the pop from the
!				I/O Active list.
!
! SIDE EFFECTS:
!
!	May call LIB$FREE_VM to free virtual memory.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

!+
! If the LUB has been marked for deallocation (by CLOSE) and there is
! no I/O active, deallocate it.  If there is I/O Active, the
! deallocation must be defered until after all of the I/O has completed
! to insure that the continued I/O will get the "I/O continued to closed
! file" error.
!-

    IF (.CCB [LUB$V_DEALLOC] AND ( NOT .CCB [ISB$V_RECURSIVE]))
    THEN
	DEALLOCATE ()
    ELSE
	BEGIN
!+
! This is no longer the unit with I/O active.
!-
	CCB [LUB$V_IO_ACTIVE] = 0;
!+
! See if I/O will continue on this unit.  It will continue if
! ISB$V_RECURSIVE is set, which means that PUSH_CCB was called
! with I/O in progress on this LUN.  We make this test before
! restoring the ISB because we may be restoring to the same
! LUN, and the former I/O may be the top level of I/O for this
! LUN, and if so it will have ISB$V_RECURSIVE clear.
!-

	IF ((.OTS$$L_LVL_CTR EQL 0) AND (.CCB [ISB$V_RECURSIVE])) THEN LIB$STOP (OTS$_FATINTERR);

	IF ( NOT .CCB [ISB$V_RECURSIVE])
	THEN

	    IF (TESTBITCC (OTS$$V_IOINPROG [.CCB [LUB$W_LUN] - LUB$K_ILUN_MIN]))
	    THEN
		LIB$STOP (OTS$_FATINTERR);

	END;

!+
! Since OTS$$V_IOINPROG may now be clear, our CCB may be deallocated, so
! we cannot touch it again.  For that matter, we may have deallocated
! it ourselves above.
!
! If there was previous I/O, restore it.  Otherwise return to the idle
! state.
!-

    IF (.OTS$$L_LVL_CTR NEQ 0)
    THEN
	POP_ACTIVE ()
    ELSE
	BEGIN
	OTS$$A_CUR_LUB = 0;
	OTS$$L_CUR_LUN = LUB$K_LUN_MAX + 1;
	END;

!+
! Decrement the level counter.  If we are at the top level the level
! counter will go from 0 to -1.
!-
    OTS$$L_LVL_CTR = .OTS$$L_LVL_CTR - 1;
    RETURN;
    END;					! of routine OTS$$POP_CCB

END						!End of module OTS$$CCB

ELUDOM
