	.TITLE	MTH$SINCOS 	; Floating Point Sine, Cosine and Sincos
				;    Functions
	.IDENT /2-002/		; File:	MTHSINCOS.MAR	EDIT: RNH2002
; 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; 
; FACILITY:	MATH LIBRARY
;++
; ABSTRACT:
; 
; MTH$SIN  and  MTH$COS are functions which return the floating point
; sine or cosine value of their single precision floating point argu-
; ment (radians). The call is standard call-by-reference.
; MTH$SIN_R4  and  MTH$COS_R4 are special routines which are the same
; as MTH$SIN  and  MTH$COS  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
;
; MTH$SINCOS  is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point radian argument.
; The call is standard call-by-reference.  MTH$SINCOS_R5 is a special 
; routine  which  is  the  same  as  MTH$SINCOS, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
; MTH$SIND and MTH$COSD are functions which return the floating point
; sine or cosine value of their single precision floating point argu-
; ment (degrees). The call is standard call-by-reference.
; MTH$SIND_R4 and MTH$COSD_R4 are special routines which are the same
; as MTH$SIND and MTH$COSD  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
; 
; MTH$SINCOSD is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point degree argument.
; The call is standard call-by-reference. MTH$SINCOSD_R5 is a special 
; routine  which  is  the  same  as MTH$SINCOSD, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
;--
; 
; VERSION:	1
; 
; HISTORY:
; AUTHOR:
; 	MARY PAYNE & JUD LEONARD, 25-MAY-78:	Version 0
; 
; MODIFIED BY:
; 
; 1-1	Tryggve Fossum, 28-May-78
; 
; 
; VERSION:	2
; 
; HISTORY:
; AUTHOR:
; 	BOB HANEK, 25-MAY-78:	Version 2
;
; 

	.SBTTL	HISTORY	; Detailed Current Edit History


; ALGORITHMIC DIFFERENCES FROM FP-11C ROUTINE:
; 	1. Uses POLYF, so more accuracy.
; 	2. Checks for 1-2**-14 before polynomial instead of checking for
; 		greater than 1.0 afterwards.
; 	3. Signals complete loss of significance.
; 
; Edit History for Version 1 of MTH$SINCOS 
; 
; 
; 1-2  Add JSB entry points, MTH$COS_R4 and MTH$SIN_R4. Tryggve, JUN-12-78
; 1-3  Change routines so as not to use R5 and R6. Tryggve, Jun-15-78
; 1-4  Use EMODD if |x| > 8.  Tryggve, June-26-78
; 1-5  Do CVTDF after EMODD.  TNH June-26-78
; 1-6  Check argument range after EMODF.  Tryggve June-27-78
; 1-7  Do CVTFD before EMODD at CBIG.  TNH 25-July-78
; 1-8  Fix overflow SIN(2**25*PI), too large answers SIN(2**I*PI)
; 	I=21:24.  TNH 26-July-78
; 1-9  Same fix for negative arg as in 1-8.  TNH 26-July-78
; 1-10 Pickup arg with MOVF so reserved op check.  TNH 16-Aug-78
; 1-011	- Put version number in standard format: three digits in
; 	   edit number field.  JBS 16-NOV-78
; 1-012	- Change MTH__SINSIGLOS to MTH$K_SINCOSSIG.  JBS 07-DEC-78
; 1-013	- Add "_" to the PSECT directive.  JBS 22-DEC-78
; 1-014 - Add RSB after call to MTH$$SIGNAL so that TAN doesn't
; 	  go into infinite loop.  SBL 02-Feb-79
; 1-015 - Declare externals.  SBL 17-May-1979
; 1-016	- Change MTH$K_SINCOSSIG to MTH$K_SIGLOSMAT.  JBS 19-SEP-1979
; 1-017 - Change argument limit to 2**31 so as to be compatible with
; 	  higher precision routines.  SBL 31-Oct-1979
; 1-018 - Reduce limit to 2**30 because this routine can't handle 2**31.
; 	  SBL 2-Nov-1979
; 1-019 - Add MTH$FLAG_JACKET, somehow left out!  SBL 2-Nov-1979
; 1-019A - Changed BLSS to BLSSU after unbiasing the exponent to exercise 
;	   small argument logic.  This logic was never reached prior to this
;	   change.
;      	 - Modified logic for processing reduced arguments close to pi (sin)
;	   and pi/2 (cos) to perform the operation 1 - RARG in double
;	   precision.  Performing the operation in single precision results
;	   in losing as much as the last 6 bits.  This modification was made
;	   only for input argument with magnitude less than 2**22.
;	 - Modified the first word of the LOW OF C0 entry of the CSTB2 table
;          from octa O22174 to octal 32174.  This eliminated a negative 1 lsb 
;	   biasing of the values returned by COS for small arguments.
;	 - RNH 12-FEB-1981
; 1-20	 - Added degree entry points.  RNH 1-MAR-1981
;
; 
; Edit History for Version 2 of MTH$SINCOS 
; 
; Algorithmic differences form Version 1
;    1) Introduction of SINCOS entry point
;    2) Elimination of the size restriction on the argument
;    3) Elinination of the MTH$K_SIGLOSMAT error
;    4) Introduction of a possible underflow error for radian arguments
;
; 2-001 - Original
; 2-002 - Modified REDUCE_LARGE to eliminate potential bug (similar to the
;         bugs mentioned in QAR 896.)  RNH 14-Jan-82
; --

	.SBTTL	DECLARATIONS	-	 Declarative Part of Module

; 
; INCLUDE FILES:	MTH$JACKET.MAR

; EXTERNAL SYMBOLS:
; 
	.DSABL	GBL
	.EXTRN	MTH$AL_4_OV_PI
	.EXTRN	MTH$$SIGNAL
	.EXTRN	MTH$K_FLOUNDMAT
	.EXTRN	MTH$$JACKET_TST
; 
; EQUATED SYMBOLS:
   
	LF_PI_OV_4     = ^X0FDB4049	; 0.78539819
	LF_9_PI_OV_4   = ^X31D641E2	; 7.06858349
	LF_2_OV_PI     = ^XF9834022	; .636619772
	LF_3_PI_OV_4   = ^XCBE44116	; 2.35619450
	LF_5_PI_OV_4   = ^X53D1417B	; 3.92699075
	LF_7_PI_OV_4   = ^XEDDF41AF	; 5.49778700

	W_45             = ^X4334	; First word of 45 in F-format
	LF_45            = ^X00004334
	LF_M45           = ^X0000C334
	LF_SMALLD        = ^X2EE13D65   ; 180/PI*2^-12
	X_1_OV_45        = ^XB6
	LF_1_OV_45       = ^X0B603DB6
	LF_CONVERT       = ^XA3513BEF	; pi/180 - 2^-6
	LF_90_OV_PI      = ^X2EE142E5   ; 28.64789009
	LF_SMALLEST_DEG	 = ^X2EE10365	; 2^-128*180/PI
; 
; MACROS:	

	$SFDEF			; Define SF$ (stack frame) symbols
	$PSLDEF			; Define PSL (Processor Status Longword)
				;   symbols

; PSECT DECLARATIONS:

	.PSECT	_MTH$CODE	PIC,SHR,LONG,EXE,NOWRT
				; program section for math routines
; 
; OWN STORAGE:	none
; 
; CONSTANTS:

D_PI_OV_2:
	.QUAD	^X68C2A2210FDA40C9	; 1.5707963267948966
D_PI:
	.QUAD	^X68C2A2210FDA4149	; 3.1415926535897932
D_3_PI_OV_2:
	.QUAD	^X0E92F999CBE34196	; 4.7123889803846899
D_2_PI:
	.QUAD	^X68C2A2210FDA41C9	; 6.2831853071795865



	.SBTTL	COEFFICIENT TABLES	-	Series Coefficients




;
; Polynomial Coefficient tables for arguments in radians
;

COSTBR1:	; COS coefficients for arguments less than 1/2
	.LONG	^X6CE6BBB4	; C3 = -.13765364E-02
	.LONG	^XA8A53E2A	; C2 =  .41664738E-01
	.LONG	^XFFFDBFFF	; C1 = -.49999991E+00
	.LONG	^X00004080	; C0 =  .10000000E+01
COSLENR1 = .-COSTBR1/4

COSTBR2:	; COS coefficients for arguments greater than 1/2
	.LONG	^X836538CC	; C4 =  .24379880E-04
	.LONG	^X03C3BBB6	; C3 = -.13886619E-02
	.LONG	^XAA9D3E2A	; C2 =  .41666616E-01
	.LONG	^X3C263284	; C1 =  .38485437E-08
	.LONG	^X00000000	; C0 =  .00000000E+00
COSLENR2 = .-COSTBR2/4

SINTBR:		; SIN coefficients 
	.LONG	^X8AE4BA4C	; C3 = -.195066968E-03
	.LONG	^X83023D08	; C2 =  .833201595E-02
	.LONG	^XAAA0BF2A	; C1 = -.166666508E+00
	.LONG	^X8ADEB25E	; C0 = -.323841887E-08
SINLENR = .-SINTBR/4





;
; Polynomial coefficients for arguments in cycles
;

COSTBC1:	; COS coefficients for arguments less than 2/pi
	.LONG	^X1AEDBAA7	; C3 = -.31872783E-03
	.LONG	^XD7323D81	; C2 = 0.15849683E-01
	.LONG	^XE9C6BF9D	; C1 = -.30842417E+00
	.LONG	^X1A12B40C	; C0 = -.32620001E-07
COSLENC1 = .-COSTBC1/4

COSTBC2:	; COS coefficients for arguments greater than 2/pi
	.LONG	^XCFAA376C	; C4 = 0.35287617E-05
	.LONG	^XE275BAAA	; C3 = -.32593650E-03
	.LONG	^XE0ED3D81	; C2 = 0.15854323E-01
	.LONG	^X4F32BE6F	; C1 = -.58425136E-01
	.LONG	^X00000000	; C0 = 0.00000000E+00
COSLENC2 = .-COSTBC2/4

SINTBC:				; SIN coef for arg in cycles
	.LONG	^XC97DB916	; C3 = -.35950437E-04
	.LONG	^X2F493C23	; C2 = 0.24900010E-02
	.LONG	^X5DDCBEA5	; C1 = -.80745429E-01
	.LONG	^XFDA93E10	; C0 = 0.35398159E-01
SINLENC = .-SINTBC/4





;
; Polynomial coefficients for arguments in degrees
;

COSDTB1:	; COS coefficients for arguments less than 90/pi
	.LONG	^XE231AA2D	; C3 = -0.386099064E-13
	.LONG	^XD3133284	; C2 =  0.386570198E-08
	.LONG	^XB502BA1F	; C1 = -0.152308523E-03
	.LONG	^X00004080	; C0 =  0.100000000E+01
COSDLN1 = .-COSDTB1/4 - 1

COSDTB2:	; COS coefficients for arguments greater than 90/pi
	.LONG	^XC1342177	; C4 =  0.209856393E-18
	.LONG	^XC612AA30	; C3 = -0.392516491E-13
	.LONG	^XD8803284	; C2 =  0.386631882E-08
	.LONG	^XA876B8FD	; C1 = -0.302383960E-04
	.LONG	^X9935AF76	; C0 = -0.560699993E-10
COSDLN2 = .-COSDTB2/4 - 1

SINDTB:		; SIN coefficients
	.LONG	^XD7E3A5DD	; C3 = -0.962091984E-16
	.LONG	^X630C2E6D	; C2 =  0.134938831E-10
	.LONG	^XDC01B66D	; C1 = -0.886095279E-06
	.LONG	^XA3513BEF	; C0 =  0.182829250E-02
SINDLN = .-SINDTB/4 - 1


	.SBTTL	MTH$SINCOS	-	Radian arguments


;
; FUNCTIONAL DESCRIPTION:
;
; The SIN, COS and SINCOS routines are based on octant reduction.  Given an 
; argument, x, it is written in the form
;
;            x = I1*(2*pi) + I*(pi/4) + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < pi/4.  Since SIN and 
; COS have a period of 2*pi it follows that
;
;            SIN(x) = SIN(I*(pi/4) + Y1)) and
;            COS(x) = COS(I*(pi/4) + Y1)).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then SIN(x) =                and COS(x) =
;       ------            -------------                -------------
;         0                 SIN(Y1)                      COS(Y1)
;         1                 COS(pi/4-Y1)                 SIN(pi/4-Y1)
;         2                 COS(Y1)                     -SIN(Y1)
;         3                 SIN(pi/4-Y1)                -COS(pi/4-Y1)
;         4                -SIN(Y1)                     -COS(Y1)
;         5                -COS(pi/4-Y1)                -SIN(pi/4-Y1)
;         6                -COS(Y1)                      SIN(Y1)
;         7                -SIN(pi/4-Y1)                 COS(pi/4-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = pi/4 - Y1, if I is odd, then
; each entry of the above table is of the for +/-SIN(Y) or +/-COS(Y).  Based 
; on the above remarks, the SIN, COS and SINCOS routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.

; 
; INPUT PARAMETERS:
; 
	LONG   = 4
	x      = 1*LONG		; x is input angle in radians
	sine   = 2*LONG		; sine is SIN(x)
	cosine = 3*LONG		; cosine is COS(x)




;
; Return sine and cosine of argument
;


	.ENTRY	MTH$SINCOS, ^M<R2, R3, R4, R5>

	MTH$FLAG_JACKET

	MOVF	@x(AP), R0
	JSB	MTH$SINCOS_R5
	MOVL	R0, @sine(AP)
	MOVL	R1, @cosine(AP)
	RET



	.SBTTL	MTH$SIN

;
; Return sine of argument
;


	.ENTRY	MTH$SIN, ^M<R2, R3, R4>

	MTH$FLAG_JACKET

	MOVF	@x(AP), R0
	JSB	MTH$SIN_R4
	RET



	.SBTTL	MTH$COS

;
; Return cosine of argument
;


	.ENTRY	MTH$COS, ^M<R2, R3, R4>

	MTH$FLAG_JACKET

	MOVF	@x(AP), R0
	JSB	MTH$COS_R4
	RET


	.SBTTL	MTH$SINCOSD	-	Degrees


;
; FUNCTIONAL DESCRIPTION:
;
; The SIND, COSD and SINCOSD routines are based on octant reduction.  Given an 
; argument, x, it is written in the form
;
;            x = I1*360 + I*45 + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < 45.  Since SIND and 
; COSD have a period of 360 it follows that
;
;            SIND(x) = SIND(I*45 + Y1) and
;            COSD(x) = COSD(I*45 + Y1).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then SIND(x) =                and COSD(x) =
;       ------            -------------                -------------
;         0                 SIND(Y1)                      COSD(Y1)
;         1                 COSD(45-Y1)                   SIND(45-Y1)
;         2                 COSD(Y1)                     -SIND(Y1)
;         3                 SIND(45-Y1)                  -COSD(45-Y1)
;         4                -SIND(Y1)                     -COSD(Y1)
;         5                -COSD(45-Y1)                  -SIND(45-Y1)
;         6                -COSD(Y1)                      SIND(Y1)
;         7                -SIND(45-Y1)                   COS(45-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = 45 - Y1, if I is odd, then
; each entry of the above table is of the for +/-SIN(Y) or +/-COS(Y).  Based 
; on the above remarks, the SIND, COSD and SINCOSD routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.


	LONG = 4
	sind = 2*LONG
	cosd = 3*LONG


	.ENTRY	MTH$SINCOSD	^M<R2, R3, R4, R5>

	MTH$FLAG_JACKET

	MOVF	@X(AP), R0
	JSB	MTH$SINCOSD_R5
	MOVL	R0, @sind(AP)
	MOVL	R1, @cosd(AP)
	
	RET



	.ENTRY	MTH$SIND	^M<R2, R3, R4>

	MTH$FLAG_JACKET

	MOVF	@X(AP), R0
	JSB	MTH$SIND_R4

	RET



	.ENTRY	MTH$COSD	^M<R2, R3, R4>

	MTH$FLAG_JACKET

	MOVF	@X(AP), R0
	JSB	MTH$COSD_R4

	RET


	.SBTTL MTH$SINCOS_R5

; This routine computes the SIN and COS of the F-format value of R0.  The
; computation is performed one of three ways depending on the size of the
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in polynomial approximation
;          of SIN and COS.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute SIN(X) and COS(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute SIN(X) and COS(X).

MTH$SINCOS_R5::
	MOVF	R0, R4			; R4 = X
	BGEQ	POS_SINCOS		; 
	JSB	SINCOS			; R0 = SIN(|X|), R1 = COS(X)
	MNEGF	R0, R0			; R0 = SIN(X)
	RSB

SINCOS:
	BICW	#^X8000, R0		; R0 = |X|
POS_SINCOS:
	CMPF	#LF_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SINCOS		; No argument reduction is necessary
	CMPF	#LF_9_PI_OV_4, R0	; Compare 9*pi/4 with |X|
	BGEQ	1$	
	BRW	LARGE_SINCOS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
1$:	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R3/R4 = Y = reduced argument
					; R2 = octant
	MOVQ	R3, -(SP)		; Save reduced argument on stack
	PUSHL	R2			; Save octant bits on stack
	JSB	M_COS			; R0 = COS(X)
	MOVL	(SP)+, R2		; R2 = Octant bits
	MOVQ	(SP)+, R3		; R3/R4 = reduced argument
	PUSHL	R0			; Save COS(X) on stack
	JSB	M_SIN			; R0 = SIN(X)
	MOVL	(SP)+, R1		; R1 = COS(X)
	RSB
;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SINCOS:
	CMPW	#^X4000, R0		; Compare 1/2 with |X|
	BLSS	2$			; Sufficent overghang not available
	CMPW	#^X3A80, R0		; Compare with 2^-12
	BGEQ	1$			; No polynomial evaluation is needed
	MOVL	R0, R4			; R4 = |X|
	MULF3	R4, R4, R5		; R5 = X*X
	POLYF	R5, #COSLENR1-1, COSTBR1; R0 = COS(X)
	PUSHL	R0			; Save COS(X) on stack
	POLYF	R5, #SINLENR-1, SINTBR	; R0 = q(X^2)
	MULF	R4, R0			; R0 = X*q(X^2)
	ADDF	R4, R0			; R0 = SIN(X)
	MOVL	(SP)+, R1		; R1 = COS(X)
	RSB

1$:	MOVF	#1.0, R1		; R0 = X, R1 = 1.0 = COS(X)
	RSB	


2$:	PUSHL	R0			; Save |x| on stack
	CVTFD	R0, R3			; R3/R4 = |X|
	MULD	R3, R3			; R3/R4 = X^2
	PUSHL	R3			; Save x^2 on stack
	JSB	NEEDS_DOUBLE_SINCOS	; Use special logic to obtain overhang
	MOVL	R0, R5			; Save COS(X) in R5
	MOVL	(SP)+, R0		; R0 = X^2
	POLYF	R0, #SINLENR-1, SINTBR	; R0 = q(X^2)
	MULF	(SP), R0		; R0 = X*q(X^2)
	ADDF	(SP)+, R0		; R0 = SIN(X)
	MOVL	R5, R1			; R1 = COS(X)
	RSB


LARGE_SINCOS:
	JSB	REDUCE_LARGE		; R3/R4 = reduced argument (in cycles)
					; R2 = octant bits
	PUSHL	R2			; Save octant bits on stack
	MOVQ	R3, -(SP)		; Save reduced argument on stack
	JSB	L_COS			; R0 = COS(X)
	MOVQ	(SP)+, R3		; Reduced argument in R3/R4
	MOVL	(SP), R2		; R2 = octant bits
	MOVL	R0, (SP)		; R1 = COS(X)
	JSB	L_SIN			; R0 = SIN(X)
	MOVL	(SP)+, R1		; R1 = COS(X)
	RSB	

	.SBTTL MTH$SIN_R4

; This routine computes the SIN of the F-format value of R0.  The computation 
; is performed one of three ways depending on the size of the input argument, 
; X:
;
;       1) If |X| < pi/4, then X is used directly in a polynomial approximation
;          of SIN.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute SIN(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute SIN(X).

MTH$SIN_R4::
	TSTF	R0			; Check the sign of R0
	BGEQ	POS_SIN			;
	JSB	SIN			; R0 = SIN(|X|)
	MNEGF	R0, R0			; R0 = SIN(X)
	RSB

SIN:
	BICW	#^X8000, R0		; R0 = |X|
POS_SIN:
	CMPF	#LF_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SIN		; No argument reduction is necessary
	CMPF	#LF_9_PI_OV_4, R0	; Compare 9*pi/4 with |X|
	BLSS	LARGE_SIN		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R3/R4 = Y = reduced argument
					; R2 = octant
M_SIN:	CASEB	R2, #0, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	P_SIN_R-1$		;    octant bits.
	.WORD	P_COS_R-1$
	.WORD	P_COS_R-1$		
	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SIN:
	CMPW	#^X3A80, R0		; Compare with 2^-12
	BGEQ	1$			; No polynomial evaluation is needed
	MOVL	R0, R4			; R4 = X
	MULF	R0,R0			; R0 = X*X
	POLYF	R0, #SINLENR-1, SINTBR	; R0 = q(x^2)
	MULF	R4, R0			;
	ADDF	R4, R0			; R0 = SIN(X)
1$:	RSB


LARGE_SIN:
	JSB	REDUCE_LARGE		; R3/R4 = reduced argument (in cycles)
					; R2 = octant bits
L_SIN:	TSTL	R3			; Check for degenerate case
	BEQL	DEGENERATE_CASE_SIN

	CASEB	R2, #0, #7

1$:	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$


DEGENERATE_CASE_SIN:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	P_ONE-1$
	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$




	.SBTTL MTH$COS_R4

; This routine computes the COS of the F-format value of R0.  The computation
; is performed one of three ways depending on the size of the input argument, 
; X.  The processing is the same as described for MTH$SIN_R4.
;

MTH$COS_R4::
	TSTF	R0			; Check for reseved operand
	BICW	#^X8000, R0		; R0 = |X|
	CMPF	#LF_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_COS		; No argument reduction is necessary
	CMPF	#LF_9_PI_OV_4, R0	; Compare 9*pi/4 with |X|
	BLSS	LARGE_COS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R3/R4 = Y = reduced argument
					; R2 = octant
M_COS:	CASEB	R2, #0, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	P_COS_R-1$		;    octant bits.
	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_COS_R-1$

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_COS:
	CMPW	#^X4000, R0		; Compare 1/2 with |X|
	BGEQ	1$			; Sufficent overghang is available
	CVTFD	R0, R3			; R3/R4 = |X|
	BRW	NEEDS_DOUBLE		; Use special logic to obtain overhang
1$:	CMPW	#^X3A80, R0		; Compare with 2^-12
	BGEQ	2$			; No polynomial evaluation is needed
	MULF	R0,R0			; R0 = X*X
	POLYF	R0, #COSLENR1-1, COSTBR1; R0 = COS(X)
	RSB

2$:	MOVF	#1.0, R0		; R0 = 1.0 = COS(X)
	RSB	


LARGE_COS:
	JSB	REDUCE_LARGE		; R3/R4 = reduced argument (in cycles)
					; R2 = octant bits
L_COS:	TSTL	R3			; Check for degenerate case
	BEQL	DEGENERATE_CASE_COS

	CASEB	R2, #0, #7
1$:	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$
	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$


DEGENERATE_CASE_COS:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$
	.WORD	P_ONE-1$


	.SBTTL	MTH$SINCOSD_R5

; This routine computes the SIND and COSD of the F-format value of R0.  The 
; computation is performed one of two ways depending on the size of the input 
; argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of SIND and COSD.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute SIND(X) and 
;          COSD(X).

MTH$SINCOSD_R5::
	TSTF	R0			; 
	BGEQ	SINCOSD			;
	BICW	#^X8000, R0		; R0 = |X|
	JSB	SINCOSD			; R0/R1 = SIND(|X|)/COSD(|X|)
	MNEGF	R0, R0			; R0 = -SIND(|X|)
	RSB

SINCOSD:
	CMPW	#W_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SINCOSD		; special processing for small arg
	JSB	REDUCE_DEGREES		; R3/R4 = octant/reduced argument
	MOVQ	R3, -(SP)		; Save octant bits and reduced arg
	JSB	EVAL_COSD		; R0 = COSD(Y)
	MOVQ	(SP)+, R3		; R3/R4 = octant/reduced argument
	PUSHL	R0			; Save COSD(Y)
	JSB	EVAL_SIND		; R0 = SIND(Y)
	MOVL	(SP)+, R1		; R1 = COSD(Y)
	RSB


SMALL_SINCOSD:
	PUSHL	R0			; Save argument
	JSB	SMALL_COSD		; R0 = COSD(|X|)
	MOVL	R0, R5			; R5 = COSD(|X|)
	MOVL	(SP)+, R0		; R0 = argument
	JSB	SMALL_SIND		; R0 = SIND(X)
	MOVL	R5, R1			; R1 = COSD(|X|)
	RSB

	.SBTTL	MTH$SIND_R4

; This routine computes the SIND of the F-format value of R0.  The computation
; is performed one of two ways depending on the size of the input argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of SIND.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute SIND(X).

MTH$SIND_R4::
	TSTF	R0			; R0 = X
	BGEQ	POS_SIND		;
	JSB	NEG_SIND		; R0 = SIND(|X|)
	MNEGF	R0, R0			; R0 = -SIND(|X|)
	RSB

NEG_SIND:	
	BICW	#^X8000, R0		; R0 = |X|
POS_SIND:
	CMPW	#W_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SIND		; special processing for small arg
	JSB	REDUCE_DEGREES		; R3/R4 = octant/reduced argument

EVAL_SIND:
	CASEB	R3, #0, #7
1$:	.WORD	P_SIN_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_SIN_D-1$
	.WORD	N_SIN_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_SIN_D-1$


SMALL_SIND:
	CMPF	#LF_SMALLD, R0		; Compare 180/pi*2^-12 with |x|
	BGTR	1$			; No polynomial evaluation is 
	MOVL	R0, R4			;   necessary
	BRW	P_SIN_D			;   
1$:	TSTF	R0			; Check for zero
	BEQL	3$			; Return if R0 = 0
	CMPF	#LF_SMALLEST_DEG, R0	; Check for possible underflow on
	BLEQ	2$			;   conversion to radians
	BRW	UNFL			; Underflow will occur on conversion
2$:	MULF3	#LF_CONVERT, R0, R1	; R1 = (pi/180 - 2^-6)*|x|
	SUBW	#^X300, R0		; R0 = |X|*2^-6
	ADDF	R1, R0			; R0 = SIND(|X|) = (pi/180)|X|
3$:	RSB

	.SBTTL	MTH$COSD_R4

; This routine computes the COSD of the F-format value of R0.  The computation
; is performed one of two ways depending on the size of the input argument, X:
; Details are given in the discussion on MTH$COSD_R4.

MTH$COSD_R4::
	TSTF	R0			; Check for reserved operand
	BICW	#^X8000, R0 		; R0 = |X|
	CMPW	#W_45, R0		; Compare 45 to |X|
	BGTR	SMALL_COSD		;
	JSB	REDUCE_DEGREES 		; R3/R4 = octant/reduced argument

EVAL_COSD:
	CASEB	R3, #0, #7
1$:	.WORD	P_COS_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	P_COS_D-1$	


SMALL_COSD:
	CMPF	#LF_SMALLD, R0		; Compare 180/pi*2^-12  with |X|
	BGTR	1$			; Check if polyinomial evaluation is
	MOVL	R0, R4			;    necessary.
	BRW	P_COS_D			; POLY needed
1$:	MOVF	#1, R0			; R0 = 1. = COSD(|X|)
	RSB




	.SBTTL	REDUCE_MEDIUM

;
; This routine assumes that the absolute value of the argument, X,  is in R0 
; and that pi/4 =< |X| < 9*pi/4.  It returns a double precision reduced 
; argument, Y, in R3/R4, and the octant bits in R2.
;
; The reduced argument is obtained by locating the octant that X is in through
; a binary search and then subtracting off a suitable multiple of pi/2
;

REDUCE_MEDIUM:
	CLRL	R1			; R0/R1 = |X|
	CMPF	#LF_5_PI_OV_4, R0	; 
	BLEQ	5$			; |X| >= 5*pi/4
	CMPF	#LF_3_PI_OV_4, R0	
	BLEQ	3$			; |X| >= 3*pi/4
	SUBD3	D_PI_OV_2, R0, R3	; R3/R4 = |X| - pi/2 
	BGEQ	2$			; 
	MOVL	#1, R2			; Octant bits = 001
	RSB

2$:	MOVL	#2, R2			; Octant bits = 010
	RSB

3$:	SUBD3	D_PI, R0, R3		; R3/R4 = |X| - pi
	BGEQ	4$			; 
	MOVL	#3, R2			; Octant bits = 011
	RSB

4$:	MOVL	#4, R2			; Octant bits = 100
	RSB

5$:	CMPF	#LF_7_PI_OV_4, R0	; 
	BLEQ	7$			; |X| >= 7*pi/4
	SUBD3	D_3_PI_OV_2, R0, R3	; R3/R4 = |X| - 3*pi/2
	BGEQ	6$			;
	MOVL	#5, R2			; Octant bits = 101
	RSB

6$:	MOVL	#6, R2			; Octant bits = 110
	RSB

7$:	SUBD3	D_2_PI, R0, R3		; R3/R4 = |X| - 2*pi
	BGEQ	8$			;
	MOVL	#7, R2			; Octant bits = 111
	RSB

8$:	CLRL	R2			; Octant bits = 000
	RSB






	.SBTTL	REDUCE_LARGE

;
; This routine is used to reduce large arguments (|X| >= 9*pi/4) modulo pi/4.
; It returns the reduced argument, Y, in R3/R4 in units of cycles, and returns
; the octant bits, I, in R2.
;
; The method of reduction is as follows:
;
;     x*(4/pi) = 2^n*f*(4/pi) where n is an integer and 1/2 =< f < 1
;              = 2^(n-24)*(2^24*f)*(4/pi)
;              = (2^24*f)*(2^(n-24)*4/pi)
;              = K*C, where K = 2^24*f is an integer and C = 2*(n-24)*4/pi
;     Let L = K*C modulo 8, where 0 =< L < 8, and let I = the integer(L) and
;     h = fract(L), then if I is even Y = h, otherwise Y = 1-h
;
; CONSTANTS:

	L_INT_WEIGHT  = ^X1E80		; weights exponent by 61
	W_TERM_WEIGHT = ^X1000		; weights exponent by 32
	W_MAX_WEIGHT  = ^X4000		; maximum unbiased exponent
	W_ADJUST      = ^X19		; Used to locate binary point in
					;   MTH$AL_4_OV_PI table
D_2_TO_64:
	.QUAD	^X0000000000006080	; 2^64



REDUCE_LARGE:
;
; The first step is to obtain the location of the binary point in the represen-
; tation of C = 2^(n-p)*(4/pi) in two parts - the number of longwords from
; the start and the number of bits from the most significant bit of the next
; longword. Also K = 2^24*f must be obtained.
;
	ROTL	#-7, R0, R2		; Get exp field in first byte of R2
	SUBW	#W_ADJUST, R2		; Unbias exp and adjust for leading 
					;   zeroes.  R2 = location of binary
					;   point 
	ROTL	#-3, R2, R3		; Divide R2 by 32 and mull by 4 to get 
	BICL	#^XFFFFFFE3, R3		;   R3 = # of longwords (in bytes) to 
					;   binary point.
	MOVAL	MTH$AL_4_OV_PI, R1	; Get base address of MTH$AL_4_OV_PI 
					;   table
	SUBL	R3, R1			; R1 points to 1st quadword of interest
	BICB	#^XE0, R2		; R2(7:0) = # of bits within longword

	BICW	#^X7F80, R0		; Clear exponent field
	BISW	#^X4C00, R0		; R0 = 2^24*f
	CVTFL	R0, R0			; R0 = K

;
; The next step is to generate an approximation to C, call it C'' to be used
; in computing x*4/pi.  C'' will consist of the first three integer bits of
; C and the first 61 fraction bits of C.  These bits will be obtained from a
; constant stored in the interger array MTH$AL_4_OV_PI.
;
; NOTE:  The ASHQ, ADDL, and MULL instructions in the follow sections may 
; result in an integer overflow trap.  The overflow incurred is intentional,  
; so that the IV bit must be turned off.  The IV bit is not restored until 
; after all of the necessary fraction bits hav been generated.
;
	MOVPSL	-(SP)			; Put current PSL on stack
	BICL	#^C<PSL$M_IV>, (SP)	; (SP) = current IV bit
	BICPSW	#PSL$M_IV		; Clear integer overflow bit

;
; Get C'' = C(0):C(1) in R3/R4.  C(0) and C(1) are unsigned integers generated 
; from the binary representation of C.  The high three bits of C(0)
; are the the first three bits to the left of the binary point of C.  Bits 28:0
; of C(0) and bits 31:0 are the first 61 bits to the right of the binary point 
; of C.
;

	ASHQ	R2, (R1), -(SP)		; Shift the proper quadword so that
					;   (SP)+4 has C(0)in it
	SUBL	#4, R1			; R1 points to next quadword in 
					;    MTH$AL_4_OV_PI table
	ASHQ	R2, (R1), R3		; Shift quadword to R3 so that R4 has
					;   C(1) in it

;
; Generate the low 64 bits of the product K*C'' = L.  This product is 
; equivalent to multiplying K times C'' modulo 8.  The result of the 
; product is in R3:R4 with bits 63:61 the octant bits, 60:24 the valid faction 
; bits of the product and 23:0 non-valid fraction bits that will be used later 
; if more fraction bits need to be generated.
;

	EMUL	R0, R4, #0, R3		; R3/R4 = K*C(1)
	BGEQ	1$			; Check if R4 was negative
	ADDL	R0, R4			; Adjust for signed mult. error
1$:	MULL3	4(SP), R0, (SP)		; (SP) = Low 32 bits of K*C(0)
	ADDL	(SP), R4		; R3/R4 = L = low order bits of K*C''

;
; At this point there may or may not be enough valid bits in R3/R4 to generate
; Y.  If the first 7 fratction bits are all 1's or 0's, there a possibility of 
; loss of significance when computing Y.  Consequently, we must check for loss 
; of significance before converting R3/R4 to Y and I.
;

	ADDL3	#^X200000, R4, (SP)	; If the first 8 fraction bits are 1's
	BITL	#^X3FC00000, (SP)	;   and the reduced arg = 1-f or the 
	BNEQ	CONVERT			;   first 8 bit are 0 and the reduced
					;   arg = f, then (and only then) bits
					;   29:22 are 0 and significance will
					;   be lost.

;
; More bits need to be generated to cover the loss of significance.  There are 
; not enough registers to hold all the potential entra bits, so that the bits
; already generated must be put on the stack.
;

	SUBL	#4, SP			; Allocate an extra longwords on stack 
					;   for later use)
	MOVQ	R3, (SP)		; Put L onto stack

	JSB	GEN_MORE_BITS		; R3/R4 contain 56 additional bits

	ADDL	R4, (SP)		; Add new high order bits to old low
	 				;   order bits
	BCC	2$			; Check for possible carry and adjust
	INCL	4(SP)			;   high order bits accordingly
	BRB	4$			; A carry indicates a minor loss of 
					;   significance has occured
2$:	BBS	#29, 4(SP), 3$		; Check for leading ones or zeros

; Lost significance due to leading zeros

	FFS	#0, #20, 4(SP), R4	; If at least one bit is set.  This 
	BNEQ	4$			;   means lost significance was minor.
	CMPL	#^X1FFFFFFF, (SP)	; One of the three high bits is set.
	BLEQ	4$			;   lost significance was minor.
	BRW	LEADING_ZEROS

; Lost significance due to leading ones

3$:	FFC	#0, #20, 4(SP), R4	; If at least one bit is clear. This 
	BNEQ	4$			;   meanslost significance was minor.
	CMPL	#^XE0000000, (SP)	; One of the three high bits is clear.
	BGEQU	4$			;   lost significance was minor.
	BRB	LEADING_ONES

4$:	MOVQ	(SP), R3		; Move bits to registers
	TSTL	(SP)+			; Remove extra longword from stack


CONVERT:
	ADDL	#8, SP			; Clear stack
;
; Convert bit string to double precion reduced argument.
;

;    Isolate octant bits and convert low order bits to double precision.

	EXTZV	#29, #3, R4, R2		; R2 = octant bits
	CVTLD	R3, R0			; R0/R1 = 2^61*FLO
	BGEQ	1$			; Check for signed conversion error
	INCL	R4			;   and adjust R5 accordingly
1$:	BLBC	R2, 2$			; Check for odd or even octant bits

;    Octant bits are odd.  Reduced argument equals 1 - f.

	BISL	#^XE0000000, R4		; Set octant bits
	CVTLD	R4, R3			; R3/R4 = -2^29*(1 - FHI)
	ADDW	#W_TERM_WEIGHT, R3	; R3/R4 = -2^61*(1 - FHI)
	ADDD	R0, R3			; R3/R4 = -2^61*(1 - FHI - FLO)
	SUBW	#^X9E80, R3		; R3/R4 = 1 - F
	BRW	RESTORE

;    Octant bits are even.  Reduced argument equals f

2$:	BICL	#^XE0000000, R4		; Clear octant bits
	CVTLD	R4, R3			; R3/R4 = 2^29*FHI
	ADDW	#W_TERM_WEIGHT, R3	; R3/R4 = 2^61*FHI
	ADDD	R0, R3			; R3/R4 = 2^61*(FHI + FLO)
	SUBW	#^X1E80, R3		; R3/R4 = F = FHI + FLO
	BRW	RESTORE



;
; At this point it has been determined that there is a major loss of 
; significance and the processing begins a looping phase.  Each iteration of
; the loop will generate additional extra bits of K*C' until enough significant
; bits to compute Y are available.  During this time the stack will contain 
; four longwords allocated as follows:
;
;                  SP ---->  L2   : L1 and L2 are the last 2 longwords worth of
;                            L1   :    significant bits generated
;                            L0   : 1st three bits of L0 are the octant bits
;                            W    : Weighting factor - keeps track of the
;                                     number of iterations that have failed
;                                     to produce enough significant bits.


LEADING_ONES:

; If processing continues here it is known that the loss of significance is due
; to a string of leading ones.

	MOVL	R3, -(SP)		; Put L2 onto stack
	MOVL	#L_INT_WEIGHT, 12(SP)	; W = exp bias for last longword
					;    of the product K*C'

LOOP_1:	CMPL	#^XFFE00000, 4(SP)	; Check L2 for enough significant bits
	BGTRU	CONVERT_1B		; Enough bits.  Convert to floating.
	JSB	GEN_MORE_BITS		; R3/R4 contains an 56 addtional 56 
					;   bits of K*C'.  
	ADDL	(SP), R4		; Add low order bits of existing 
					;   product, L2, to high order bits of 
					;   new product, R4.
	BCC	1$			; Check for carry on previous ADDL
	INCL	4(SP)			; Add carry into L1
	BCC	1$			; Check for carry on previous ADDL
	INCL	8(SP)			; Add carry into L0.  If carry 
	BRW	CONVERT_0A		;   propagates to L0 enough fraction
					;   bits are available to produce
					;   equivalent argument
					
1$:	CMPL	#-1, 4(SP)		; Check for L1 all 1's
	BGTRU	CONVERT_1A		; Not all 1's.  Enough precision bits
					;    to compute Y
	MOVQ	R3, (SP)		; Compress representation of L
	ACBW	#W_MAX_WEIGHT, #W_TERM_WEIGHT, 12(SP), LOOP_1
					; Increment weighting factor.  If 
					;   weighting factor is greater than 
					;   128 then no more bits need to be 
					;   generated.
					
;
; The weighting factor is greater than 128.  This means that the reduced
; argument is either not distinguishable from 1 or too small to be represented
; in F-format (i.e. underflow.)  Zero is returned in R3 for the reduced
; argument to signal this occurance.  Note that under these conditions the
; correct function value is one of the values 0, +/-1.  The
; correct choice is determined by the calling program based on the octant bits
; returned in R1.
;
	CLRL	R3			; Reduced argument is zero
	EXTZV	#29, #3, 8(SP), R2	; R2 = octant bits
	ADDL	#16, SP			; Clear stack
	BRW	RESTORE

CONVERT_1A:
	MOVL	R3, (SP)		; Put L2 onto stack
CONVERT_1B:
	CVTLD	(SP)+, R0		; R0/R1 = 2^W*L2
	BGEQ	1$			; Check for signed conversion error
	INCL	(SP)			;   and adjust L1 accordingly.
1$:	CVTLD	(SP), R3		; Convert L1 to double and check for
	BGEQ	2$			;   signed conversion error.
	ADDW	#^X9000, R3		; R3/R4 = 2^W*(2^64 - L1)
	BRB	3$

2$:	ADDW	#1000, R3		; R3/R4 = 2^W*L1
	SUBD3	R3, D_2_TO_64, R3	; R3/R4 = 2^W*(2^64 - L1)

3$:	SUBD	R0, R3			; R3/R4 = 2^W*(2^64 - L1 - L2)
	EXTZV	#29, #3, (SP)+, R2	; R2 = octant bits
	SUBL	(SP)+, R3		; R3/R4 = Y
	BRW	RESTORE


LEADING_ZEROS:


; If processing continues here it is known that the loss of significance is due
; to a string of leading zeros.  Note that it is known that the loop for 
; leading zeros will terminate before an underflow condition occurs so that the
; loop does not include a test for underflow.

	MOVL	R3, -(SP)		; Put L2 onto stack
	MOVL	#L_INT_WEIGHT, 12(SP)	; W = exp bias for last longword
					;    of the product K*C'

LOOP_0: CMPL	#^X001FFFFF, 4(SP)	; Check L2 for enough fraction bits
	BLSS	CONVERT_0B		; Enough bits.  Convert to floating
	JSB	GEN_MORE_BITS		; R3/R4 contain an addtional 56 bits 
					;   of K*C'.  
	ADDL	(SP), R4		; Add low order bits of existing 
					;   product, (SP), to high order bits 
					;   of new product, R4.
	BCC	1$			; Check for carry on previous ADDL
	INCL	4(SP)			; Add in carry.  Note: High bits of R4
					;   are 0 so no carry possible on INCL
1$:	TSTL	R4			; Check for all 0's
	BNEQ	CONVERT_0A		; Not all 0's.  Enough precision bits.
	MOVQ	R3, (SP)		; Compress representation of L
	ADDW	#W_TERM_WEIGHT, 12(SP)	; Increment weighting factor.  
	BRB	LOOP_0

CONVERT_0A:
	MOVL	R4, (SP)		; Put L2 onto stack
CONVERT_0B:
	CVTLD	(SP), R0		; R0/R1 = 2^W*L2
	BGEQ	1$			; If L2 is negative, adjust L1 to
	INCL	(SP)			;   to reflect signed rather than
					;   unsigned conversion
1$:	CVTLD	(SP), R3		; Convert L1 to double
	ADDW	#W_TERM_WEIGHT, R3	; R3/R4 = 2^W*L1
	ADDD	R0, R3			; R3/R4 = 2^W*(L1 + L2)
	EXTZV	#29, #3, (SP)+, R2	; R2 = octant bits
	SUBL	(SP)+, R3		; R3/R4 = Y


RESTORE:
	BISPSW	(SP)			; Restore IV bit and exit
	ADDL	#4, SP			; Remove mask from stack
	RSB

GEN_MORE_BITS:

;
; This subroutine generates 56 extra fraction bits and stores them in R3/R4
;

	SUBL	#4, R1			; Adjust pointer to next quadword
	ASHQ	R2, (R1), R3		; Put next coefficient in R4
	EMUL	R0, R4, #0, R3		; Generate the fraction bits in R3/R4
	BGEQ	1$			; Check for signed arithmentic error
	ADDL	R0, R4			; Negative factor, adjust R4
1$:	RSB





	.SBTTL	REDUCE_DEGREES

; This routine assumes that the absolute value of the argument is in R0.
; The reduction process is performed in two stages.  The first stage of 
; the reduction reduces the argument modulo 360 to a value less that 2^24,
;  and the second stage reduces the argument to less than 45.

; Constants used in this reduction:
;

POWER_MOD_360_0:	; Powers of 2 modulo 360 for t1 = 0
	.WORD	  1,	  2,	  4,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248

POWER_MOD_360_1:	; Powers of 2 modulo 360 for t1 <> 0
	.WORD	136,	272,	184,	8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248

REDUCE_DEGREES:
	CMPW	#^X4C80, R0		; Compare |x| with 2^24
	BGTR	LAST_STEP		; Branch to special logic for med arg

;
; It is assumed here that the argument is greater than 2^24.
;
; The argument is reduced as follows:
;     Let x = 2^t*f, where t > 24 and 1/2 =< f < 1.  And let J = 2^24*f = 
;     2^15*J1 + J2 and K = 2^(t-24).  Since 2^15 = 8 modulo 360, we have that
;     J = 8*J1 + J2 modulo 360.  Now let t' = t - 24 = 12*t1 + t2.  Note that
;     (2^12)^2 = 2^24 = (2^9)*(2^15) = (2^9)*(2^3) = 2^12 modulo 360.  Hence,
;     if t1 is not zero, K = 2^t' = 2^(12*t1+t2) = [2^(12*t1)]*[2^t2] = 
;     [2^12]*[2^t2] = 136*2^t2 modulo 360.  For t1 = 0, K = 2^t2.  Consequently
;     define K' congruent to 2^t2 if t1=0 and congruent to 136*2^t2 otherwise,
;     where 0=< K' < 360.  Then x' = K'*(8*J1 + J2) is congruent to x modulo 
;     360 and x' < 2^24


	BICL3	#^X7F80, R0, R1		;
	BISW	#^X4C00, R1		; R1 = J
	SUBL	R1, R0			; R0 = t'*2^7

	BICL3	#^X7FFF0000, R1, R2	; R2 = J1*2^15
	SUBF	R2, R1			; R1 = J2
	SUBW	#^X600, R2		; R2 = J1
	ADDF	R2, R1			; R1 = 8*J1 + J2 = J modulo 360

	ROTL	#-7, R0, R0		; R0 = t'
	DIVB3	#12, R0, R2		; R2 = t1
	MULB	#12, R2			; R2 = 12*t1
	SUBB	R2, R0			; R0 = t2

	TSTB	R2			; Check for t1 = 0 and choose K'
	BNEQ	1$			;   accordingly
	CVTWF	POWER_MOD_360_0[R0], R0	; R0 = K'
	BRB	2$
1$:	CVTWF	POWER_MOD_360_1[R0], R0 ; R0 = K'
2$:	MULF	R1, R0			; R0 = X' (mod 45) 0 =< R0 < 2^24


LAST_STEP:
;
; Argument reduction scheme for arguments with absolute value less than 2^24
;
; The reduced argument Y is computed as follows:
;    Let I = int(X/45)
;       if I is even
;          then Y = X - 45*I
;          else Y = (I+1)*45 - x

	EMODF	#LF_1_OV_45, #X_1_OV_45, R0, R3, R4
					; R3 = I = integer part of |x|/45
	BLBC	R3, EVEN		; Branch if octant bits are even
	ADDL3	#1, R3, R4		; R4 = I + 1
	CVTLF	R4, R4			; 
	MULF	#LF_45, R4		; R4 = 45*(I+1)
	SUBF	R0, R4			; R4 = Y
	BICB	#^XF8, R3		; Save only last three octant bits
	RSB

EVEN:	CVTLF	R3, R4			; R4 = I
	MULF	#LF_M45, R4		; R4 = -45*I
	ADDF	R0, R4			; R4 = Y
	BICB	#^XF8, R3		; Save only last three octant bits
	RSB



	.SBTTL	RADIAN_POLYNOMIALS	; Polynomials for arguments in radians



;
; Polynomial evaluation for COS(Y) for Y in radians
;

P_COS_R:
	BICW	#^X8000, R3		; R3/R4 = |Y|
	CMPW	#^X4000, R3		; Compare 1/2 with |Y|
	BGEQ	LEQL_HALF		; Sufficent overhang is available
NEEDS_DOUBLE:
	MULD	R3, R3			; R3/R4 = Y*Y
NEEDS_DOUBLE_SINCOS:
	PUSHL	R3			; Save high half of Y*Y
	POLYF	R3, #COSLENR2-1, COSTBR2; R0 = Y^4*Q(Y*Y)
	SUBL3	#^X80, (SP)+, R3	; R3/R4 = Y*Y/2
	SUBD	#1, R3			; R3/R4 = Y^2/2 - 1
	SUBD	R3, R0			; R0/R1 = COS(Y)
	CVTDF	R0, R0			; R0 = COS(Y)
	RSB
LEQL_HALF:
	CVTDF	R3, R4			; R4 = |Y|
	MULF	R4, R4			; R4 = Y*Y
	POLYF	R4, #COSLENR1-1, COSTBR1; R0 = COS(Y)
	RSB


;
; Polynomial evaluation for -COS(Y)
;

N_COS_R:
	BICW	#^X8000, R3		; R3/R4 = |Y|
	CMPW	#^X4000, R3		; Compare 1/2 with |Y|
	BGEQ	1$			; Sufficent overhang is available
	MULD	R3, R3			; R3/R4 = Y*Y
	PUSHL	R3			; Save high half of Y*Y
	POLYF	R3, #COSLENR2-1, COSTBR2; R0 = Y^4*Q(Y*Y)
	SUBL3	#^X80, (SP)+, R3	; R3/R4 = Y*Y/2
	SUBD	#1, R3			; R3/R4 = -(1 - Y^2/2)
	SUBD	R0, R3			; R3/R4 = -COS(Y)
	CVTDF	R3, R0			; R0 = -COS(Y)
	RSB

1$:	CVTDF	R3, R4			; R4 = |Y|
	MULF	R4, R4			; R4 = Y*Y
	POLYF	R4, #COSLENR1-1, COSTBR1; R0 = COS(Y)
	XORW	#^X8000, R0		; R0 = -COS(Y)
	RSB

;
; Polynomial evaluation for -SIN(Y)
;

N_SIN_R:
	XORW	#^X8000, R3

;
; Polynomial evaluation for SIN(Y)
;

P_SIN_R:
	PUSHL	R3			; Save high half of Y
	MULF	R3, R3			; R3 = Y*Y
	POLYF	R3, #SINLENR-1, SINTBR	; R0 = P(Y*Y)
	MOVL	(SP)+, R3		; R3/R4 = Y
	MULF	R3, R0			; R0 = Y*P(Y*Y)
	ADDD	R3, R0			; R0/R1 = SIN(Y)
	CVTDF	R0, R0			; R0 = SIN(Y)
	RSB




	.SBTTL	CYCLE_POLYNOMIALS	; Polynomials for arguments in cycles



;
; Polynomial evaluation for COS(Y) for Y in cycles
;

P_COS_C:
	CMPF	#LF_2_OV_PI, R3		; Compare 2/pi with |Y|
	BGEQ	LEQL_2_OV_PI		; Sufficent overhang is available
	MULD	R3, R3			; R3/R4 = Y*Y
	PUSHL	R3			; Save high half of Y*Y
	POLYF	R3, #COSLENC2-1, COSTBC2; R0 = Y^4*Q(Y*Y)
	SUBL3	#^X100, (SP)+, R3	; R3/R4 = Y*Y/4
	SUBD	#1, R3			; R3/R4 = Y^2/4 - 1
	SUBD	R3, R0			; R0/R1 = COS(Y)
	CVTDF	R0, R0			; R0 = COS(Y)
	RSB
LEQL_2_OV_PI:
	CVTDF	R3, R4			; R4 = |Y|
	MULF	R4, R4			; R4 = Y*Y
	POLYF	R4, #COSLENC1-1, COSTBC1; R0 = COS(Y) - 1
	ADDF	#1, R0			; R0 = COS(Y)
	RSB


;
; Polynomial evaluation for -COS(Y)
;

N_COS_C:
	CMPF	#LF_2_OV_PI, R3		; Compare 2/pi with |Y|
	BGEQ	1$			; Sufficent overhang is available
	MULD	R3, R3			; R3/R4 = Y*Y
	PUSHL	R3			; Save high half of Y*Y
	POLYF	R3, #COSLENC2-1, COSTBC2; R0 = Y^4*Q(Y*Y)
	SUBL3	#^X100, (SP)+, R3	; R3/R4 = Y*Y/4
	SUBD	#1, R3			; R3/R4 = -(1 - Y^2/4)
	SUBD	R0, R3			; R3/R4 = -COS(Y)
	CVTDF	R3, R0			; R0 = -COS(Y)
	RSB

1$:	CVTDF	R3, R4			; R4 = |Y|
	MULF	R4, R4			; R4 = Y*Y
	POLYF	R4, #COSLENC1-1, COSTBC1; R0 = COS(Y) - 1
	SUBF3	R0, #-1, R0		; R0 = -COS(Y)
	RSB

;
; Polynomial evaluation for -SIN(Y)
;

N_SIN_C:
	XORW	#^X8000, R3		; R3/R4 = - Y

;
; Polynomial evaluation for SIN(Y)
;

P_SIN_C:
	MOVQ	R3, -(SP)		; Save argument
	MULF	R3, R3			; R3 = Y*Y
	POLYF	R3, #SINLENC-1, SINTBC	; R0 = P(Y*Y)
	MULF	(SP), R0		; R0 = Y*P(Y*Y)
	SUBL3	#^X100, (SP), R3	;
	MOVL	4(SP), R4		; R3/R4 = Y/4
	SUBD	(SP)+, R3		; R3/R4 = 3/4*Y
	SUBD	R3, R0			; R0/R1 = SIN(Y)
	CVTDF	R0, R0			; R0 = SIN(Y)
	RSB


	.SBTTL	DEGREE_POLYNOMIALS


P_COS_D:
	CMPF	#LF_90_OV_PI, R4	; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	CVTFD	R4, R3			; R3/R4 = Y
	MULD	R3, R3			; R3/R4 = Y*Y
	PUSHL	R3			; Save high half Y*Y
	POLYF	R3, #COSDLN2, COSDTB2	; R0 = r(Y*Y) - NOTE: POLYF leaves R1=0
	SUBL3	#^X680, (SP)+, R3	; R3/R4 = Y*Y/2^13
	CMPL	#^X1000, R4		; Check for loss of significance when
	BGTRU	1$			;   subtracting 1 and adjust
	MOVQ	R3, -(SP)		; (SP) = Y^2/2^13
	BICL	#^XFFFF0000, R4		; R3/R4 = high bits of Y^2/2^13
	SUBD	R3, (SP)		; (SP) = Low bits of Y^2/2^13
	ADDD	(SP)+, R0		; R0/R1 = r(Y^2) + low bits of Y^2/2^13
1$:	SUBD	#1, R3			; R3/R4 = -(1 - Y*Y/2^13)
	SUBD	R3, R0			; R0/R1 = COS(Y)
	CVTDF	R0, R0			; R0 = COS(Y)
	RSB

2$:	MULF	R4, R4			; R4 = Y*Y
	POLYF	R4, #COSDLN1, COSDTB1	; R0 = COS(Y)
	RSB


N_COS_D:
	CMPF	#LF_90_OV_PI, R4	; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	CVTFD	R4, R3			; R3/R4 = Y
	MULD	R3, R3			; R3/R4 = Y*Y
	PUSHL	R3			; Save high half of Y*Y
	POLYF	R3, #COSDLN2, COSDTB2	; R0 = r(Y*Y)
	SUBL3	#^X680, (SP)+, R3	; R3/R4 = Y*Y/2^13
	CMPL	#^X1000, R4		; Check for loss of significance when
	BGTRU	1$			;   subtracting 1 and adjust
	MOVQ	R3, -(SP)		; (SP) = Y^2/2^13
	BICL	#^XFFFF0000, R4		; R3/R4 = high bits of Y^2/2^13
	SUBD	R3, (SP)		; (SP) = Low bits of Y^2/2^13
	ADDD	(SP)+, R0		; R0/R1 = r(Y^2) + low bits of Y^2/2^13
1$:	SUBD	#1, R3			; R3/R4 = -(1 - Y*Y/2^13)
	SUBD	R0, R3			; R3/R4 = -COS(Y)
	CVTDF	R3, R0			; R0 = -COS(Y)
	RSB

2$:	MULF	R4, R4			; R4 = Y*Y
	POLYF	R4, #COSDLN1, COSDTB1	; R0 = COS(Y)
	XORW	#^X8000, R0		; R0 = -COS(Y)
	RSB


N_SIN_D:
	MNEGF	R4, R4			; R4 = -Y
P_SIN_D:
	MULF3	R4, R4, R0		; R0 = Y*Y
	BEQL	RETURN
	POLYF	R0, #SINDLN, SINDTB	; R0 = P(Y*Y)
	MULF	R4, R0			; R0 = Y*P(Y*Y)
	SUBW	#^X300, R4		; R4 = Y*2^-6
	ADDF	R4, R0			; R0 = SIN(Y)
RETURN:	RSB




	.SBTTL	DEGENERATE_SOLUTIONS

P_ONE:
	MOVF	#1, R0			; Answer is 1
	RSB


N_ONE:
	MOVF	#-1, R0			; Answer is -1
	RSB


UNFL:
;
; Underflow; if user has FU set, signal error.  Always return 0.0
;
	MOVPSL	R2			; R2 = user's or jacket routine's PSL
	CALLS	#0, G^MTH$$JACKET_TST	; R0 = TRUE if JSB from jacket routine
	BLBC	R0, 10$			; branch if user did JSB
	MOVZWL	SF$W_SAVE_PSW(FP), R2	; get user PSL saved by CALL
10$:	CLRL	R0			; R0 = result. LIB$SIGNAL will save in
					; CHF$L_MCH_R0/R1 so any handler can 
					;   fixup
	BBC	#6, R2, 20$		; has user enabled floating underflow?
	PUSHL	(SP)			; yes, return PC from special routine
	MOVZBL	#MTH$K_FLOUNDMAT, -(SP)	; trap code for hardware floating 
					;   underflow convert to MTH$_FLOUNDMAT
					;   (32-bit VAX-11 exception code)
	CALLS	#2, G^MTH$$SIGNAL	; signal (condition, PC)
20$:	RSB				; return

	.END
