	.TITLE	MTH$DSINCOS 	; Floating Point Sine, Cosine and Sincos
				;    Functions
	.IDENT /2-006/		; File:	MTHDSINCOS.MAR	EDIT: RNH2006
; 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; 
; FACILITY:	MATH LIBRARY
;++
; ABSTRACT:
; 
; MTH$DSIN and MTH$DCOS are functions which return the floating point
; sine or cosine value of their single precision floating point argu-
; ment (radians). The call is standard call-by-reference.
; MTH$DSIN_R7 and MTH$DCOS_R7 are special routines which are the same
; as MTH$DSIN and MTH$DCOS  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
;
; MTH$DSINCOS  is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point radian argument.
; The call is standard call-by-reference.  MTH$DSINCOS_R7 is a special 
; routine  which  is  the  same  as  MTH$DSINCOS, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
; MTH$DSIND and MTH$DCOSD are functions which return the floating point
; sine  or  cosine value of their single precision floating point argu-
; ment (degrees). The call is standard call-by-reference.
; MTH$DSIND_R7 and MTH$DCOSD_R7 are special routines which are the same
; as MTH$DSIND and MTH$DCOSD  except  a faster non-standard JSB call is
; used with the argument in R0 and no registers are saved.
; 
; MTH$DSINCOSD is  a routine which returns the floating point sine and 
; cosine value of its single precision floating point degree argument.
; The call is standard call-by-reference. MTH$DSINCOSD_R7 is a special 
; routine  which  is  the  same  as MTH$DSINCOSD, except a faster non-
; standard JSB call is used with the argument in R0 and no  registers
; are saved.
;
;--
; 
; VERSION:	1
; 
; HISTORY:
; AUTHOR:
; 	MARY PAYNE & JUD LEONARD, 25-MAY-78:	Version 0
; 
; MODIFIED BY:
; 
; 1-1	Tryggve Fossum, 28-May-78
; 
; 
; VERSION:	2
; 
; HISTORY:
; AUTHOR:
; 	BOB HANEK, 25-MAY-78:	Version 2
; 
; 
; Edit history for Version 2
;
; 2-001 - Fixed overflow problem for large radian arguments. RNH 09-Sept-81
; 2-002 - Included check for A2 = 0 in DSINCOS for small arguments. RNH
;         22-Sept-81
; 2-003 - Change DSINCOS so that R6/R7 = |X| instead of X.  RNH 29-Sep-81
; 2-004 - Modified logic for converting reduced argument from integer to
;	  to floating format to avoid modifying the exponent of a floating
;	  point zero.  RNH 21-Oct-81
; 2-005 - Modified cosine evaluation logic to check the magnitude of YHI 
;         instead of YLO.  RNH 01-Nov-81
; 2-006 - Modified negative argument logic for DSINCOSD to eliminate bug
;         uncovered by FORTRAN QA.
;       - Modified REDUCE_LARGE logic to fix bug detected in QAR 896.
;         RNH 14-Jan-82

	.SBTTL	DECLARATIONS	-	 Declarative Part of Module

; 
; INCLUDE FILES:	MTHJACKET.MAR

; EXTERNAL SYMBOLS:
; 
	.DSABL	GBL
	.EXTRN	MTH$AL_4_OV_PI
	.EXTRN	MTH$$SIGNAL
	.EXTRN	MTH$K_FLOUNDMAT
	.EXTRN	MTH$$JACKET_TST
; 
; EQUATED SYMBOLS:
   
	X_1_OV_45        = ^X0B

; 
; MACROS:	

	$SFDEF			; Define SF$ (stack frame) symbols
	$PSLDEF			; Define PSL$ symbols

; PSECT DECLARATIONS:

	.PSECT	_MTH$CODE	PIC,SHR,LONG,EXE,NOWRT
				; program section for math routines
; 
; OWN STORAGE:	none
; 
; CONSTANTS:

D_PI_OV_4:
	.QUAD	^X68C2A2210FDA4049	; 0.7853981633974483E+00
D_9_PI_OV_4:
	.QUAD	^X95DAF66531D541E2	; 0.7068583470577035E+01
D_3_PI_OV_4:
	.QUAD	^X0E92F999CBE34116	; 0.2356194490192345E+01
D_5_PI_OV_4:
	.QUAD	^XC2F34AA953D1417B	; 0.3926990816987242E+01
D_7_PI_OV_4:
	.QUAD	^X3BAA4DDDEDDF41AF	; 0.5497787143782138E+01
D_2_OV_PI:
	.QUAD	^X44156E4EF9834022	; 0.6366197723675813E+00

D_45:
	.QUAD	^X0000000000004334	; 0.4500000000000000E+02
D_M45:
	.QUAD	^X000000000000C334	; -.4500000000000000E+02
D_SMALLD:
	.QUAD	^X0FBED31E2EE035E5	; 0.4268868231257969E-06
D_1_OV_45:
	.QUAD	^X60B6B60B0B603DB6	; 0.2222222222222222E-01
D_CONVERT:
	.QUAD	^X9C8B294EA3513BEF	; 0.1828292519943295E-02
D_90_OV_PI:
	.QUAD	^X0FBED31E2EE042E5	; 0.2864788975654116E+02
D_SMALLEST_DEG:
	.QUAD	^X0FBED31E2EE00365	; 0.1683771628589691E-36


PI_OV_2:
; pi/2
	.QUAD	^X68C2A2210FDA40C9	; 0.1570796326794897E+01
	.QUAD	^X03708A2E131923D3	; 0.5721188726109832E-17
	.QUAD	^X4453127089480766	; 0.4335905065061890E-34
; pi
	.QUAD	^X68C2A2210FDA4149	; 0.3141592653589793E+01
	.QUAD	^X03708A2E13192453	; 0.1144237745221966E-16
	.QUAD	^X44531270894807E6	; 0.8671810130123781E-34
; 3*pi/2
	.QUAD	^X0E92F999CBE34196	; 0.4712388980384690E+01
	.QUAD	^XBEB66C2ED8D6A530	; -.3834758505292833E-16
	.QUAD	^X333E0DD4E6F6082C	; 0.1300771519518567E-33
;2*pi
	.QUAD	^X68C2A2210FDA41C9	; 0.6283185307179586E+01
	.QUAD	^X03708A2E131924D3	; 0.2288475490443933E-16
	.QUAD	^X4453127089480866	; 0.1734362026024756E-33



	.SBTTL	COEFFICIENT TABLES	-	Series Coefficients




;
; Polynomial Coefficient tables for arguments in radians
;

COSTBR1:	; DCOS coefficients for arguments less than 1/2
	.QUAD	^X699DF786B56AAE47	; C7 = -.1135212320578394E-10
	.QUAD	^X49E73CCE74AA320F	; C6 = 0.2087555514567788E-08
	.QUAD	^XCC8A7F10F27BB593	; C5 = -.2755731286569608E-06
	.QUAD	^XB3EDCD6B0D0038D0	; C4 = 0.2480158728289946E-04
	.QUAD	^XB166B6090B60BBB6	; C3 = -.1388888888885896E-02
	.QUAD	^XA99AAAAAAAAA3E2A	; C2 = 0.4166666666666643E-01
	.QUAD	^XFFFFFFFFFFFFBFFF	; C1 = -.5000000000000000E+00
	.QUAD	^X0000000000004080	; C0 = 0.1000000000000000E+01
COSLENR1 = .-COSTBR1/8

COSTBR2:	; DCOS coefficients for arguments greater than 1/2
	.QUAD	^X699DF786B56AAE47	; C7 = -.1135212320578394E-10
	.QUAD	^X49E73CCE74AA320F	; C6 = 0.2087555514567788E-08
	.QUAD	^XCC8A7F10F27BB593	; C5 = -.2755731286569608E-06
	.QUAD	^XB3EDCD6B0D0038D0	; C4 = 0.2480158728289946E-04
	.QUAD	^XB166B6090B60BBB6	; C3 = -.1388888888885896E-02
	.QUAD	^XA99AAAAAAAAA3E2A	; C2 = 0.4166666666666643E-01
	.QUAD	^XF732620203392404	; C1 = 0.7156417079102195E-17
	.QUAD	^XE9809A224BFDA029	; C0 = -.3584999999999999E-19
COSLENR2 = .-COSTBR2/8

SINTBR:		; DSIN coefficients 
	.QUAD	^X24F1F2B54C4AAC55	; C7 = -.7577867884012712E-12
	.QUAD	^XDA66F085903A3030	; C6 = 0.1605834762322461E-09
	.QUAD	^X2AF0320D3229B3D7	; C5 = -.2505210473826733E-07
	.QUAD	^XD2FC2984EF1D3738	; C4 = 0.2755731921339017E-05
	.QUAD	^X3FDED00C0D00BA50	; C3 = -.1984126984125311E-03
	.QUAD	^X884D888888883D08	; C2 = 0.8333333333333320E-02
	.QUAD	^XAAABAAAAAAAABF2A	; C1 = -.1666666666666667E+00
	.QUAD	^X4800F1E9077E9E0E	; C0 = -.1879741879570161E-20
SINLENR = .-SINTBR/8





;
; Polynomial coefficients for arguments in cycles
;

COSTBC1:	; DCOS coefficients for arguments less than 2/pi
	.QUAD	^X0AD5CCAC2C35ABD9	; C7 = -.3857762037200000E-12
	.QUAD	^X6F06EA8AE60A2FFC	; C6 = 0.1150049702426300E-09
	.QUAD	^X00B11EA468F6B3D3	; C5 = -.2461136382637005E-07
	.QUAD	^XF91E4181FA833770	; C4 = 0.3590860445885820E-05
	.QUAD	^X6ADFF1E4E9E3BAAA	; C3 = -.3259918869266876E-03
	.QUAD	^XD54E40DAE0F83D81	; C2 = 0.1585434424381541E-01
	.QUAD	^X2EF24DF2E9E6BF9D	; C1 = -.3084251375340425E+00
	.QUAD	^XE9809A224BFDA029	; C0 = -.3584999999999999E-19
COSLENC1 = .-COSTBC1/8

COSTBC2:	; DCOS coefficients for arguments greater than 2/pi
	.QUAD	^X0AD5CCAC2C35ABD9	; C7 = -.3857762037200000E-12
	.QUAD	^X6F06EA8AE60A2FFC	; C6 = 0.1150049702426300E-09
	.QUAD	^X00B11EA468F6B3D3	; C5 = -.2461136382637005E-07
	.QUAD	^XF91E4181FA833770	; C4 = 0.3590860445885820E-05
	.QUAD	^X6ADFF1E4E9E3BAAA	; C3 = -.3259918869266876E-03
	.QUAD	^XD54E40DAE0F83D81	; C2 = 0.1585434424381541E-01
	.QUAD	^X77916F914F32BE6F	; C1 = -.5842513753404245E-01
	.QUAD	^XE9809A224BFDA029	; C0 = -.3584999999999999E-19
COSLENC2 = .-COSTBC2/8

SINTBC:		; DSIN coef for arg in cycles
	.QUAD	^X86037C402C65A9B6	; C7 = -.2022531292930000E-13
	.QUAD	^XD11BCC0677632DF4	; C6 = 0.6948152035052200E-11
	.QUAD	^X0477A15F83A5B1F1	; C5 = -.1757247417617081E-08
	.QUAD	^X693342E13C1A35A8	; C4 = 0.3133616889173253E-06
	.QUAD	^X5DE873156966B919	; C3 = -.3657620418214640E-04
	.QUAD	^X56C73BAD35E33C23	; C2 = 0.2490394570192716E-02
	.QUAD	^XF296312D5DE7BEA5	; C1 = -.8074551218828078E-01
	.QUAD	^X8C232216FDAA3E10	; C0 = 0.3539816339744831E-01
SINLENC = .-SINTBC/8





;
; Polynomial coefficients for arguments in degrees
;

COSDTB2:	; DCOS coefficients for arguments less than 90/pi
	.QUAD	^X00C6931909F3856B	; C7 = -.2762868673216389E-35
	.QUAD	^X6EB1B88D50A40F07	; C6 = 0.1667886312398853E-29
	.QUAD	^X8C1C14B5B11D985F	; C5 = -.7227873495985315E-24
	.QUAD	^X8EECE0261D5A217C	; C4 = 0.2135494301985905E-18
	.QUAD	^XC57ADDE3CDC2AA30	; C3 = -.3925831985734635E-13
	.QUAD	^XE39C541ED88B3284	; C2 = 0.3866323851562972E-08
	.QUAD	^XFDCCD8A0B50EBA1F	; C1 = -.1523087098933543E-03
	.QUAD	^X0000000000004080	; C0 = 0.1000000000000000E+01
COSDLN2 = .-COSDTB2/8 - 1

COSDTB1:	; DCOS coefficients for arguments greater than 90/pi
	.QUAD	^X00C6931909F3856B	; C7 = -.2762868673216389E-35
	.QUAD	^X6EB1B88D50A40F07	; C6 = 0.1667886312398853E-29
	.QUAD	^X8C1C14B5B11D985F	; C5 = -.7227873495985315E-24
	.QUAD	^X8EECE0261D5A217C	; C4 = 0.2135494301985905E-18
	.QUAD	^XC57ADDE3CDC2AA30	; C3 = -.3925831985734635E-13
	.QUAD	^XE39C541ED88B3284	; C2 = 0.3866323851562972E-08
	.QUAD	^XEE5FC507A876B8FD	; C1 = -.3023839739335430E-04
	.QUAD	^XE9809A224BFDA029	; C0 = -.3584999999999999E-19
COSDLN1 = .-COSDTB1/8 - 1

SINDTB:		; DSIN coefficients
	.QUAD	^XBDA56DF733F0808C	; C7 = -.3218900432111067E-38
	.QUAD	^X19375C1608060A3A	; C6 = 0.2239270886637075E-32
	.QUAD	^XC2AEE060B88B93B5	; C5 = -.1146820010579771E-26
	.QUAD	^X8133642353021CFA	; C4 = 0.4141267415665013E-21
	.QUAD	^XB337FD49B46CA5E1	; C3 = -.9788384861609472E-16
	.QUAD	^X6B1B57086CA72E6D	; C2 = 0.1349601623163253E-10
	.QUAD	^X7BC46CA1DC10B66D	; C1 = -.8860961557012980E-06
	.QUAD	^X9C8B294EA3513BEF	; C0 = 0.1828292519943296E-02
SINDLN = .-SINDTB/8 - 1


	.SBTTL	MTH$DSINCOS	-	Radian arguments


;
; FUNCTIONAL DESCRIPTION:
;
; The DSIN, DCOS and DSINCOS routines are based on octant reduction.  Given an 
; argument, x, it is written in the form
;
;            x = I1*(2*pi) + I*(pi/4) + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < pi/4.  Since DSIN and 
; DCOS have a period of 2*pi it follows that
;
;            DSIN(x) = DSIN(I*(pi/4) + Y1)) and
;            DCOS(x) = DCOS(I*(pi/4) + Y1)).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then DSIN(x) =                and DCOS(x) =
;       ------            -------------                -------------
;         0                 DSIN(Y1)                      DCOS(Y1)
;         1                 DCOS(pi/4-Y1)                 DSIN(pi/4-Y1)
;         2                 DCOS(Y1)                     -DSIN(Y1)
;         3                 DSIN(pi/4-Y1)                -DCOS(pi/4-Y1)
;         4                -DSIN(Y1)                     -DCOS(Y1)
;         5                -DCOS(pi/4-Y1)                -DSIN(pi/4-Y1)
;         6                -DCOS(Y1)                      DSIN(Y1)
;         7                -DSIN(pi/4-Y1)                 DCOS(pi/4-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = pi/4 - Y1, if I is odd, then
; each entry of the above table is of the for +/-DSIN(Y) or +/-DCOS(Y).  Based 
; on the above remarks, the DSIN, DCOS and DSINCOS routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.

; 
; INPUT PARAMETERS:
; 
	LONG   = 4
	x      = 1*LONG		; x is input angle in radians
	sine   = 2*LONG		; sine is DSIN(x)
	cosine = 3*LONG		; cosine is DCOS(x)




;
; Return sine and cosine of argument
;


	.ENTRY	MTH$DSINCOS, ^M<R2, R3, R4, R5, R6,R7>

	MTH$FLAG_JACKET

	MOVD	@x(AP), R0
	JSB	MTH$DSINCOS_R7
	MOVQ	R0, @sine(AP)
	MOVQ	R2, @cosine(AP)
	RET



	.SBTTL	MTH$DSIN

;
; Return sine of argument
;


	.ENTRY	MTH$DSIN, ^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVD	@x(AP), R0
	JSB	MTH$DSIN_R7
	RET



	.SBTTL	MTH$DCOS

;
; Return cosine of argument
;


	.ENTRY	MTH$DCOS, ^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVD	@x(AP), R0
	JSB	MTH$DCOS_R7
	RET


	.SBTTL	MTH$DSINCOSD	-	Degrees


;
; FUNCTIONAL DESCRIPTION:
;
; The DSIND, DCOSD and DSINCOSD routines are based on octant reduction.  Given 
; an argument, x, it is written in the form
;
;            x = I1*360 + I*45 + Y1, 
;
; where I1 and I are integers, 0 =< I < 8 and 0 =< Y1 < 45.  Since DSIND and 
; DCOSD have a period of 360 it follows that
;
;            DSIND(x) = DSIND(I*45 + Y1) and
;            DCOSD(x) = DCOSD(I*45 + Y1).
;
; Using the trigonometric identities for the sum and difference of two angles,
; the following table can be generated:
;
;       If I =            then DSIND(x) =                and DCOSD(x) =
;       ------            -------------                -------------
;         0                 DSIND(Y1)                      DCOSD(Y1)
;         1                 DCOSD(45-Y1)                   DSIND(45-Y1)
;         2                 DCOSD(Y1)                     -DSIND(Y1)
;         3                 DSIND(45-Y1)                  -DCOSD(45-Y1)
;         4                -DSIND(Y1)                     -DCOSD(Y1)
;         5                -DCOSD(45-Y1)                  -DSIND(45-Y1)
;         6                -DCOSD(Y1)                      DSIND(Y1)
;         7                -DSIND(45-Y1)                   DCOS(45-Y1)
;
; Let Y be defined as Y = Y1 if I is even and Y = 45 - Y1, if I is odd, then
; each entry of the above table is of the for +/-DSIN(Y) or +/-DCOS(Y).  Based 
; on the above remarks, the DSIND, DCOSD and DSINCOSD routines process the input
; argument x, to obtain I and Y, and based on I selects a suitable polynomial
; approximation, p(Y), to evaluate the desired fuction.


	LONG = 4
	sind = 2*LONG
	cosd = 3*LONG


	.ENTRY	MTH$DSINCOSD	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVD	@X(AP), R0
	JSB	MTH$DSINCOSD_R7
	MOVQ	R0, @sind(AP)
	MOVQ	R2, @cosd(AP)
	
	RET



	.ENTRY	MTH$DSIND	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVD	@X(AP), R0
	JSB	MTH$DSIND_R7

	RET



	.ENTRY	MTH$DCOSD	^M<R2, R3, R4, R5, R6, R7>

	MTH$FLAG_JACKET

	MOVD	@X(AP), R0
	JSB	MTH$DCOSD_R7

	RET


	.SBTTL MTH$DSINCOS_R7

; This routine computes the DSIN and DCOS of the G-format value of R0/R1.  The
; computation is performed one of three ways depending on the size of the
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in polynomial approximation
;          of DSIN and DCOS.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute DSIN(X) and DCOS(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute DSIN(X) and DCOS(X).

MTH$DSINCOS_R7::
	MOVD	R0, R6			; R6 = X
	BGEQ	POS_SINCOS		; 
	JSB	SINCOS			; R0/R1 = DSIN(|X|), R2/R3 = DCOS(X)
	MNEGD	R0, R0			; R0/R1 = DSIN(X)
	RSB

SINCOS:
	BICW	#^X8000, R6		; R6/R7 = |X|
POS_SINCOS:
	CMPD	D_PI_OV_4, R6		; Compare pi/4 with |X|
	BGTR	SMALL_SINCOS		; No argument reduction is necessary
	CMPD	D_9_PI_OV_4, R6		; Compare 9*pi/4 with |X|
	BGEQ	1$	
	BRW	LARGE_SINCOS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
1$:	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R4/R7 = Y = reduced argument
					; R2 = octant
	MOVQ	R4, -(SP)		; Save reduced argument on stack
	MOVQ	R6, -(SP)		;
	PUSHL	R2			; Save octant bits on stack
	JSB	M_COS			; R0/R1 = DCOS(X)
	MOVL	(SP)+, R2		; R2 = Octant bits
	MOVQ	(SP)+, R6		; 
	MOVQ	(SP)+, R4		; R4/R7 = reduced argument
	MOVQ	R0, -(SP)		; Save DCOS(X) on stack
	JSB	M_SIN			; R0/R1 = DSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = DCOS(X)
	RSB
;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SINCOS:
	CMPW	#^X4000, R6		; Compare 1/2 with |X|
	BLEQ	2$			; Sufficent overghang not available
	CMPW	#^X3280, R6		; Compare with 2^-28
	BGEQ	1$			; No polynomial evaluation is needed
	MULD3	R6, R6, R4		; R4/R5 = X*X
	MOVQ	R4, -(SP)		; Put X*X on stack
	POLYD	R4, #COSLENR1-1, COSTBR1; R0/R1 = DCOS(X)
	MOVQ	(SP), R4 		; R4/R5 = X*X
	MOVQ	R0, (SP)		; Save DCOS(X) on stack
	POLYD	R4, #SINLENR-1, SINTBR	; R0/R1 = q(X^2)
	MULD	R6, R0			; R0/R1 = X*q(X^2)
	ADDD	R6, R0			; R0/R1 = DSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = DCOS(X)
	RSB

1$:	MOVD	#1.0, R2		; R2/R3 = 1.0 = DCOS(X)
	BICW	#^X8000, R0		; R0/R1 = |X|
	RSB	


2$:	MULD3	R6, R6, R4		; R4/R5 = X^2
	MOVQ	R4, -(SP)		; Save X^2
	POLYD	R4, #COSLENR2-1, COSTBR2; R0/R1 = Q(Y^2)
	MOVQ	R6, R4			; R4/R5 = X
	BICL	#^XFFFF1FFF, R5		; R4/R5 = XHI
	SUBD3	R4, R6, -(SP)		; (SP) = XLO
	ADDD3	R6, R4, R2		; R2/R3 = X + XHI
	MULD	(SP)+, R2		; R2/R3 = XLO*(X + XHI) = A2
	BEQL	3$			; Check for A2 = 0
	SUBW	#^X80, R2		; R2/R3 = A2/2
	SUBD	R2, R0			; R0/R1 = Q(Y^2) - A2/2
3$:	MULD	R4, R4			; R4/R5 = XHI^2
	SUBW	#^X80, R4		; R4/R5 = XHI^2/2
	SUBD	#1, R4			; R4/R5 = XHI^2/2 - 1
	SUBD	R4, R0			; R0/R1 = DCOS(X)
	MOVQ	(SP), R2		; R2/R3 = X^2
	MOVQ	R0, (SP)		; Save DCOS(X) 
	POLYD	R2, #SINLENR-1, SINTBR	; R0/R1 = Q(X^2)
	MULD	R6, R0			; R0/R1 = X*Q(X^2)
	ADDD	R6, R0			; R0/R1 = DSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = DCOS(X)
	RSB


LARGE_SINCOS:
	JSB	REDUCE_LARGE		; R4/R7 = reduced argument (in cycles)
					; R2 = octant bits
	PUSHL	R2			; Save octant bits on stack
	MOVQ	R6, -(SP)		; Save reduced 
	MOVQ	R4, -(SP)		;     argument on stack
	JSB	L_COS			; R0/R1 = DCOS(X)
	MOVQ	(SP)+, R4		; Reduced argument 
	MOVQ	(SP)+, R6		;      in R4/R7
	MOVL	(SP)+, R2		; R2 = octant bits
	MOVQ	R0, -(SP)		; R2/R3 = DCOS(X)
	JSB	L_SIN			; R0/R1 = DSIN(X)
	MOVQ	(SP)+, R2		; R2/R3 = DCOS(X)
	RSB	

	.SBTTL MTH$DSIN_R7

; This routine computes the DSIN of the G-format value of R0/R1.  The 
; computation is performed one of three ways depending on the size of the 
; input argument, X:
;
;       1) If |X| < pi/4, then X is used directly in a polynomial approximation
;          of DSIN.
;       2) If pi/4 =< |x| < 9*pi/4, then the subroutine REDUCE_MEDIUM is called
;          to reduce the argument to an equivalent argument in radians, Y, and 
;          the octant, I, containing the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute DSIN(X).
;       3) If 9*pi/4 =< |X|, then the subroutine REDUCE_LARGE is called to
;          reduce the argument to an equivalent argument in cycles, Y, and the
;          octant, I, contanining the argument.  Y is then evaluated in a
;          polynomial chosen as a function of I to compute DSIN(X).

MTH$DSIN_R7::
	TSTD	R0			; Check the sign of R0
	BGEQ	POS_SIN			;
	JSB	SIN			; R0/R1 = DSIN(|X|)
	MNEGD	R0, R0			; R0/R1 = DSIN(X)
	RSB

SIN:
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SIN:
	CMPD	D_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_SIN		; No argument reduction is necessary
	CMPD	D_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BLSS	LARGE_SIN		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R4/R7 = Y = reduced argument
					; R2 = octant
M_SIN:	CASEB	R2, #1, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	P_COS_R-1$
	.WORD	P_COS_R-1$		
	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_SIN_R-1$		;    octant bits.

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_SIN:
	CMPW	#^X3280, R0		; Compare with 2^-28
	BGEQ	1$			; No polynomial evaluation is needed
	MOVQ	R0, R6			; R6/R7 = X
	MULD	R0,R0			; R0/R1 = X*X
	POLYD	R0, #SINLENR-1, SINTBR	; R0/R1 = q(x^2)
	MULD	R6, R0			; R0/R1 = X*q(x^2)
	ADDD	R6, R0			; R0/R1 = DSIN(X)
1$:	RSB


LARGE_SIN:
	JSB	REDUCE_LARGE		; R4/R7 = reduced argument (in cycles)
					; R2 = octant bits
L_SIN:	TSTL	R4			; Check for degenerate case
	BEQL	DEGENERATE_CASE_SIN

	CASEB	R2, #0, #7

1$:	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$


DEGENERATE_CASE_SIN:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	P_ONE-1$
	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$




	.SBTTL MTH$DCOS_R7

; This routine computes the DCOS of the G-format value of R0/R1.  The 
; computation is performed one of three ways depending on the size of the 
; input argument, X.  The processing is the same as described for MTH$DSIN_R4.
;

MTH$DCOS_R7::
	TSTD	R0			; Check for reserved operand
	BICW	#^X8000, R0		; R0/R1 = |X|
	CMPD	D_PI_OV_4, R0		; Compare pi/4 with |X|
	BGTR	SMALL_COS		; No argument reduction is necessary
	CMPD	D_9_PI_OV_4, R0		; Compare 9*pi/4 with |X|
	BLSS	LARGE_COS		; Use special logic for |X| > 9*pi/4

;
;  pi/4 =< |X| < 9*pi/4
;
	JSB	REDUCE_MEDIUM		; Medium argument reduction routine
					; R4/R7 = Y = reduced argument
					; R2 = octant
M_COS:	CASEB	R2, #1, #7		; Branch to one of four polynomial
					;    evaluations depending on the 
1$:	.WORD	N_SIN_R-1$
	.WORD	N_SIN_R-1$
	.WORD	N_COS_R-1$
	.WORD	N_COS_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_SIN_R-1$
	.WORD	P_COS_R-1$
	.WORD	P_COS_R-1$		;    octant bits.

;
; Logic for small arguments.  |X| < pi/4.
;

SMALL_COS:
	CMPW	#^X4000, R0		; Compare 1/2 with |X|
	BGTR	1$			; Sufficent overghang is available
	MOVQ	R0, R6			; R6/R7 = X
	BICL	#^XFFFF1FFF, R7		; R6/R7 = XHI
	SUBD3	R6, R0, R4		; R4/R5 = XLO
	BRW	NEEDS_DOUBLE		; Use special logic to obtain overhang
1$:	CMPW	#^X3280, R0		; Compare with 2^-28
	BGEQ	2$			; No polynomial evaluation is needed
	MULD	R0,R0			; R0/R1 = X*X
	POLYD	R0, #COSLENR1-1, COSTBR1; R0/R1 = DCOS(X)
	RSB

2$:	MOVD	#1.0, R0		; R0/R1 = 1.0 = DCOS(X)
	RSB	


LARGE_COS:
	JSB	REDUCE_LARGE		; R4/R7 = reduced argument (in cycles)
					; R2 = octant bits
L_COS:	TSTL	R4			; Check for degenerate case
	BEQL	DEGENERATE_CASE_COS

	CASEB	R2, #0, #7
1$:	.WORD	P_COS_C-1$
	.WORD	P_SIN_C-1$
	.WORD	N_SIN_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_COS_C-1$
	.WORD	N_SIN_C-1$
	.WORD	P_SIN_C-1$
	.WORD	P_COS_C-1$


DEGENERATE_CASE_COS:

	BICB	#1, R2			; Compute index as (R2 - 1)/2
	ROTL	#-1, R2, R2
	CASEB	R2, #0, #3

1$:	.WORD	UNFL -1$
	.WORD	N_ONE-1$
	.WORD	UNFL -1$
	.WORD	P_ONE-1$


	.SBTTL	MTH$DSINCOSD_R7

; This routine computes the DSIND and DCOSD of the D-format value of R0/R1.
; The computation is performed one of two ways depending on the size of the 
; input argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of DSIND and DCOSD.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute DSIND(X) and 
;          DCOSD(X).

MTH$DSINCOSD_R7::
	TSTD	R0
	BGEQ	SINCOSD
	BICW	#^X8000, R0		; R0/R1 = |X|
	JSB	SINCOSD			; R0/R1 = DSIND(|X|)
					; R2/R3 = DCOSD(|X|)
	MNEGD	R0, R0			; R0/R1= -DSIND(|X|)
	RSB

SINCOSD:
	CMPD	D_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SINCOSD		; special processing for small arg
	JSB	REDUCE_DEGREES		; R6/R7 = reduced argument
					; R3 = octant
	MOVQ	R6, -(SP)		; Save reduced arg
	PUSHL	R3			; Save octant bits
	JSB	EVAL_COSD		; R0/R1 = DCOSD(Y)
	MOVL	(SP)+, R3		; R3 = octant bits
	MOVQ	(SP), R6		; R6/R7 = reduced argument
	MOVQ	R0, (SP)		; Save DCOSD(Y)
	JSB	EVAL_SIND		; R0/R1 = DSIND(Y)
	MOVQ	(SP)+, R2		; R2/R3 = DCOSD(Y)
	RSB


SMALL_SINCOSD:
	SUBL	#16, SP			; Allocate 4 longwords on stack
	MOVQ	R0, (SP)		; Save argument
	JSB	SMALL_COSD		; R0/R1 = DCOSD(|X|)
	MOVQ	R0, 8(SP)		; Save DCOSD(|X|)
	MOVQ	(SP)+, R0		; R0/R1 = argument
	JSB	SMALL_SIND		; R0/R1 = DSIND(X)
	MOVQ	(SP)+, R2		; R2/R3 = DCOSD(|X|)
	RSB

	.SBTTL	MTH$DSIND_R7

; This routine computes the DSIND of the D-format value of R0/R1.  The 
; computation is performed one of two ways depending on the size of the input 
; argument, X:
;
;       1) If |X| < 45, then X is used directly in polynomial approximation
;          of DSIND.
;       2) If 45 =< |x|, then the subroutine REDUCE_DEGREES is called to reduce
;          the argument to an equivalent argument in degrees, Y, and the 
;          octant, I, containing the argument.  Y is then evaluated in two 
;          polynomials chosen as a function of I, to compute DSIND(X).

MTH$DSIND_R7::
	TSTD	R0			; R0/R1 = X
	BGEQ	POS_SIND		;
	JSB	NEG_SIND		; R0/R1 = DSIND(|X|)
	MNEGD	R0, R0			; R0/R1 = -DSIND(|X|)
	RSB

NEG_SIND:	
	BICW	#^X8000, R0		; R0/R1 = |X|
POS_SIND:
	CMPD	D_45, R0		; Compare 45 to |X|
	BGTR	SMALL_SIND		; special processing for small arg
	JSB	REDUCE_DEGREES		; R6/R7 = reduced argument
					; R3 = octant

EVAL_SIND:
	CASEB	R3, #0, #7
1$:	.WORD	P_SIN_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_COS_D-1$
	.WORD	P_SIN_D-1$
	.WORD	N_SIN_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_COS_D-1$
	.WORD	N_SIN_D-1$


SMALL_SIND:
	CMPD	D_SMALLD, R0		; Compare 180/pi*2^-27 with |x|
	BGTR	1$			; No polynomial evaluation is 
	MOVQ	R0, R6			;   necessary
	BRW	P_SIN_D			;   
1$:	TSTD	R0			; Check for zero
	BEQL	3$			; Return if R0 = 0
	CMPD	D_SMALLEST_DEG, R0	; Check for possible underflow on
	BLEQ	2$			;   conversion to radians
	BRW	UNFL			; Underflow will occur on conversion
2$:	MULD3	D_CONVERT, R0, R2	; R2/R3 = (pi/180 - 2^-6)*|x|
	SUBW	#^X300, R0		; R0/R1 = |X|*2^-6
	ADDD	R2, R0			; R0/R1 = DSIND(|X|) = (pi/180)|X|
3$:	RSB

	.SBTTL	MTH$DCOSD_R7

; This routine computes the DCOSD of the D-format value of R0.  The computation
; is performed one of two ways depending on the size of the input argument, X:
; Details are given in the discussion on MTH$DCOSD_R4.

MTH$DCOSD_R7::
	TSTD	R0			; Check for reserved operand
	BICW	#^X8000, R0 		; R0/R1 = |X|
	CMPD	D_45, R0		; Compare 45 to |X|
	BGTR	SMALL_COSD		;
	JSB	REDUCE_DEGREES 		; R6/R7 = reduced argument
					; R3 = octant

EVAL_COSD:
	CASEB	R3, #0, #7
1$:	.WORD	P_COS_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_COS_D-1$	
	.WORD	N_SIN_D-1$	
	.WORD	P_SIN_D-1$	
	.WORD	P_COS_D-1$	


SMALL_COSD:
	CMPD	D_SMALLD, R0		; Compare 180/pi*2^-27  with |X|
	BGTR	1$			; Check if polyinomial evaluation is
	MOVQ	R0, R6			;    necessary.
	BRW	P_COS_D			; POLY needed
1$:	MOVD	#1, R0			; R0 = 1. = DCOSD(|X|)
	RSB




	.SBTTL	REDUCE_MEDIUM

;
; This routine assumes that the absolute value of the argument, X,  is in R0/R1
; and that pi/4 =< |X| < 9*pi/4.  It returns a pair of d-format values for the
; reduced argument:  YHI in R6/R7, and YLO in R4/R5.  The octant bits in are
;  returned in R2.
;
; The reduced argument is obtained by locating the octant that X is in through
; a binary search and then subtracting off a suitable multiple of pi/2
;

REDUCE_MEDIUM:
	BICW	#^X8000, R0		; R0/R1 = |X|
	CMPD	D_5_PI_OV_4, R0		; 
	BLEQ	5$			; |X| >= 5*pi/4
	CMPD	D_3_PI_OV_4, R0	
	BLEQ	3$			; |X| >= 3*pi/4
	MOVL	#1, R2			; First quadrant
	BRB	SUBTRACT

3$:	MOVL	#3, R2			; Second quadrant
	BRB	SUBTRACT

5$:	CMPD	D_7_PI_OV_4, R0	; 
	BLEQ	7$			; |X| >= 7*pi/4
	MOVL	#5, R2			; Third quadrant
	BRB	SUBTRACT

7$:	MOVL	#7, R2			; Fourth quadrant
	BRB	SUBTRACT


SUBTRACT:
	MOVAW	-3(R2)[R2], R3		; R3 = index into PI_OV_2 table
	MOVAL	PI_OV_2[R3], R3		; R3 = pointer into PI_OV_2 table
	SUBD3	(R3)+, R0, R6		; R6/R7 = 1st approximation to YHI
	BLEQ	1$			;       = YHI'
	INCL	R2			; Adjust octant bits
1$:	BICW3	#^X8000, R6, R4		; R4 = high 16 bits of |YHI'|
	CMPW	#^X2700, R4		; Check for at least 6 significant bits
	BGTR	NOT_ENOUGH_BITS		;

	MOVQ	R6, R4			; R4/R5 = YHI'
	CLRL	R7			; R6/R7 = high 24 bits of YHI' = YHI
	SUBD	R6, R4			; R4/R5 = low bits of YHI'
	SUBD	(R3), R4		; R4/R5 = YLO
	RSB

NOT_ENOUGH_BITS:
	MOVQ	(R3), R0		; 
	BICL	#^X003F0000, R0		;
	CLRL	R1			;
	SUBD3	R0, (R3)+, R4		;
	SUBD	R0, R6			; R6/R7 = YHI
	ADDD	(R3), R4		; R4/R5 = -YLO
	XORW	#^X8000, R4		; R4/R5 = YLO
	RSB
	


	.SBTTL	REDUCE_LARGE

;
; This routine is used to reduce large arguments (|X| >= 9*pi/4) modulo pi/4.
; It returns the reduced argument, Y, in R4/R7 in units of cycles, and returns
; the octant bits, I, in R2.
;
; The method of reduction is as follows:
;
;     x*(4/pi) = 2^n*f*(4/pi) where n is an integer and 1/2 =< f < 1
;              = 2^(n-56)*(2^56*f)*(4/pi)
;              = (2^56*f)*(2^(n-56)*4/pi)
;              = K*C, where K = 2^56*f is an integer and C = 2*(n-56)*4/pi
;     Let L = K*C modulo 8, where 0 =< L < 8, and let I = the integer(L) and
;     h = fract(L), then if I is even Y = h, otherwise Y = 1-h
;
; CONSTANTS:

	L_INT_WEIGHT  = ^X1E80		; weights exponent by 61
	W_TERM_WEIGHT = ^X1000		; weights exponent by 32
	W_MAX_WEIGHT  = ^X4000		; maximum unbiased exponent
	W_ADJUST      = ^X39		; Used to locate binary point in
					;   MTH$AL_4_OV_PI table
D_2_TO_32:
	.QUAD	^X5080			; 2^32



REDUCE_LARGE:
;
; The first step is to obtain the location of the binary point in the represen-
; tation of C = 2^(n-56)*(4/pi) in two parts - the number of longwords from
; the start and the number of bits from the most significant bit of the next
; longword. Also K = 2^56*f must be obtained.
;
	BICW	#^X8000, R0		; R0/R1 = |X|
	ROTL	#-7, R0, R3		; Shift exponext field 4 bits right
	SUBW	#W_ADJUST, R3		; Unbias exp and adjust for leading 
					;   zeroes.  R3 = location of binary
					;   point 
	ROTL	#-3, R3, R4		; Divide R3 by 32 and mull by 4 to get 
	BICL	#^XFFFFFFE3, R4		;   R4 = # of longwords (in bytes) to 
					;   binary point.
	MOVAL	MTH$AL_4_OV_PI, R2	; Get base address of MTH$AL_4_OV_PI 
					;   table
	SUBL	R4, R2			; R2 points to 1st quadword of interest
	BICB	#^XE0, R3		; R3(7:0) = # of bits within longword

	BICW	#^X7F80, R0		; Clear exponent field
	BISW	#^X4C00, R0		; R0 = 2^24*f
	CVTDL	R0, R0			; R0 = High 24 bits of K
	ROTL	#16, R1, R1		; R1 = Low 32 bits of K
	BGEQ	1$			; Check for high bit of R1 set
	INCL	R0			; Adjust R0 if R1 is negative

;
; The next step is to generate an approximation to C, call it C'' to be used
; in computing x*4/pi.  C'' will consist of the first three integer bits of
; C and the first 61 fraction bits of C.  These bits will be obtained from a
; constant stored in the interger array MTH$AL_4_OV_PI.
;
; NOTE:  The ASHQ, ADDL, and MULL instructions in the follow sections may 
; result in an integer overflow trap.  The overflow incurred is intentional,  
; so that the IV bit must be turned off.  The IV bit is not restored until 
; after all of the necessary fraction bits hav been generated.
;
1$:	MOVPSL	-(SP)			; Put current PSL on stack
	BICL	#^C<PSL$M_IV>, (SP)	; (SP) = current IV bit
	BICPSW	#PSL$M_IV		; Clear integer overflow bit

; The necessary calculation to produce the reduced argument can require up to
; nine longwords of temporary work space.  This work space will be allocated 
; on the stack.  The work space will be accessed though the use of three 
; registers: R4, R5, and SP.  For the purposes of comments the temporary work 
; space will be referred to as locations T0 though T8.  The stack and its 
; pointers will look something like this:
;
;                       |                    |
;                       |--------------------|
;                   T0: |                    |  <---- SP
;                       |--------------------|
;                   T1: |                    |
;                       |--------------------|
;                   T2: |                    |
;                       |--------------------|
;                   T3: |                    |
;                       |--------------------|
;                   T4: |                    |  <---- R4
;                       |--------------------|
;                   T5: |                    |
;                       |--------------------|
;                   T6: |                    |
;                       |--------------------|
;                   T7: |                    |
;                       |--------------------|
;                   T8: |                    |  <---- R5
;                       |--------------------|
;                       |                    |
;
; The following code allocates the storage and sets up the pointers.

	SUBL	#36, SP			; Allocate 9 longwords on the stack
	ADDL3	#16, SP, R4		; R4 points to T4
	ADDL3	#32, SP, R5		; R5 points to T8

;
; Get C'' = C(0):C(1):C(2):C(3) in T5/T8.  C(0) though  C(3) are unsigned 
; integers generated from the binary representation of C.  The high three bits 
; of C(0) are the the first three bits to the left of the binary point of C.  
; The remaining bits C(0) and C(1) though C(3) are the first 125 bits to the 
; right of the binary point of C. Note that the C(i)'s are adjusted to
; compensate for their signed (rather than unsigned) interpretation in the EMUL
; instruction.  Note also that the representation of C has no more than 15 
; consequtive ones, so that no carry is possible from the adjustment.
;

	ADDL3	#12, R4, R7		; Initailize loop counter.  R7 points
					;   to T7
	ASHQ	R3, (R2), (R7)		; Shift the proper quadword so that
					;   T8 has C(0)in it
	SUBL	#4, R7			; R7 points to T6
2$:	SUBL	#4, R2			; R2 points to next quadword in 
					;    MTH$AL_4_OV_PI table
	ASHQ	R3, (R2), (R7)		; Shift quadword so that C(n) is in
					;   T(8-n) , n = 0,1,2,3
	BGEQ	3$			; Check for high bit of C(n) set
	INCL	8(R7)			; Bit set.  Adjust C(n-1)
3$:	ACBL	R4, #-4, R7, 2$		; Loop until C(0) though C(3) are in
					;   T5 though T8

;
; Generate the low 128 bits of the product K*C'' = L.  This product is 
; equivalent to multiplying K times C'' modulo 8.  The result of the 
; product is in T4/T7 with bits 31:29 of T4 the octant bits, and the remaining
; 125 bits the faction bits of the product.  The last 53 fraction bits (bits
; 20:0 of T6 and 31:0 of T5) are non-valid fraction bits that will be used 
; later if more fraction bits need to be generated.
;
;
; Multiply the high order bits of K (R0) times C'' and store the result in
; T0/T2.

	EMUL	R0, 4(R4), #0, (SP)	; T0/T1 = KHI*C(3)
	EMUL	R0, 8(R4), 4(SP), 4(SP)	; T0/T2 = KHI*[C(2):C(3)]
	MULL3	R0, 12(R4), (R4)	; T4 = Low 32 bits of KHI*C(1)
	ADDL	(R4), 8(SP)		; T0/T2 = KHI*C'' modulo 8

; Multiply the low order bits of K (R1) times C'' and store the result in
; T4/T8.

	EMUL	R1, 4(R4), #0, (R4)	; T4/T5 = KLO*C(3)
	EMUL	R1, 8(R4), 4(R4), 4(R4)	; T4/T6 = KLO*[C(2):C(3)]
	EMUL	R1, 12(R4), 8(R4), 8(R4); T4/T7 = KLO*[C(1):C(2):C(3)]
	MULL	R1, (R5)		; T8 = KLO*C(0)
	ADDL	(R5), 12(R4)		; T4/T7 = KLO*C'' modulo 8

; Add KHI*C'' to KLO*C'' to get K*C''.  Store the result in T4/T7.

	ADDL	(SP), 4(R4)		;
	ADWC	4(SP), 8(R4)		;
	ADWC	8(SP), 12(R4)		; T4/T7 = K*C'' modulo 8

;
; At this point there may or may not be enough valid bits in R3/R4 to generate
; Y.  If the first 12 fratction bits are all 1's or 0's, there a possibility of 
; loss of significance when computing Y.  Consequently, we must check for loss 
; of significance before converting T4/T7 to Y and I.
;

	ADDL3	#^X200000, -4(R5), (R5)	; If the first 12 fraction bits are 1's
	BITL	#^X3FC00000, (R5)	;   and the reduced arg = 1-f or the 
	BNEQ	CONVERT			;   first 7 bit are 0 and the reduced
					;   arg = f, then (and only then) bits
					;   29:22 are 0 and significance will
					;   be lost.

;
; More bits need to be generated to cover the loss of significance.  There are 
; not enough registers to hold all the potential entra bits, so that the bits
; already generated must be put on the stack.
;

	JSB	GEN_MORE_BITS		; Generate 85 additional bits and add
					;   them to existing bits.  Results are
					;   stored in T3/T7
	SUBL	#4, R4			; Adjust R4 to reflect the addition of 
					;   another longword of K*C''
	BBS	#29, -4(R5), 4$		; Check if loss of significance is due 
					;   to leading ones or zeros

; Lost significance due to leading zeros

	FFS	#0, #20, 16(R4), (R5)	; If at least one bit is set.  This 
	BNEQ	CONVERT			;   means lost significance was minor.
	CMPL	#^X1FFFFFFF, 12(R4)	; If one of the three high bits is set,
	BLEQ	CONVERT			;   lost significance was minor.
	BRW	LEADING_ZEROS

; Lost significance due to leading ones

4$:	FFC	#0, #20, 16(R4), (R5)	; If at least one bit is clear. This 
	BNEQ	CONVERT			;   meanslost significance was minor.
	CMPL	#^XE0000000, 12(R4)	; If one of the three high bits is 
	BGEQU	CONVERT			;   clear, lost significance was minor.
	BRB	LEADING_ONES


CONVERT:

;    Isolate octant bits and convert fraction bits to a pair of D-format
;    quantities YHI and YLO

	EXTZV	#29, #3, -4(R5), (R5)	; T8 = octant bits
	BICL	#^XE0000000, -4(R5)	; Clear octant bits
	SUBL3	#12, R5, R4		; R4 points to low order bits of h
	JSB	CVT_TO_DOUBLE		; R0/R1 = 2^29*h_lo
					; R6/r7 = 2^29*h_hi
	SUBW	#^XE80, R6		; R6/R7 = h_hi
	BGTR	3$			; Check for h_hi = 0
	CLRL	R6			; Restore h_hi to 0
3$:	TSTW	R0			; Check for h_lo = 0
	BEQL	1$
	SUBW	#^XE80, R0		; R0/R1 = h_lo
1$:	BLBC	(R5), 2$		; Check for odd or even octant bits

;    Octant bits are odd.  Reduced argument equals 1 - h.

	SUBD3	R6, #1, R6		; R6/R7 = Y = 1 - h_hi
	MNEGD	R0, R0			; R0/R1 = -h_lo

;    Get octant bits

2$:	MOVL	32(SP), R2		; R2 = octant bits
	BRW	GET_YHI_YLO


;
; At this point it has been determined that there is a major loss of 
; significance and the processing begins a looping phase.  Each iteration of
; the loop will generate additional extra bits of K*C' until enough significant
; bits to compute Y are available.  During this time the nine longwords
; allocated on the stack will be used as follows:
;
;       T0/T2   Temporary storage used when generating extra bits.
;
;       T3/T7   Contains all significant bits generated so far.
;
;       T8      Contains a counter, W, indicating the appropriate exponent
;                 of the last longword of fraction bits used in converting 
;                 to Y.

LEADING_ONES:

; If processing continues here it is known that the loss of significance is due
; to a string of leading ones.

	MOVL	#L_INT_WEIGHT, (R5)	; T8 = exp bias for last longword
					;    of the product K*C'

LOOP_1:	CMPL	#^XFFE00000, 12(R4)	; Check for enough significant bits
	BGTRU	CONVERT_1		; Enough bits.  Convert to floating.
	JSB	GEN_MORE_BITS		; T2/T7 contains K*C''
	CMPL	#-1, 12(R4)		; Check for all 1's
	BGTRU	CONVERT_1		; Not all 1's.  Enough precision bits
					;    to compute Y
	MOVQ	4(R4), 8(R4)		; Compress representation 
	MOVQ	-4(R4), (R4)		;    of K*C''
	ACBW	#W_MAX_WEIGHT, #W_TERM_WEIGHT, (R5), LOOP_1
					; Increment weighting factor.  If 
					;   weighting factor is greater than 
					;   1024 then no more bits need to be 
					;   generated.
					
;
; The weighting factor is greater than 1024.  This means that the reduced
; argument is either not distinguishable from 1 or too small to be represented
; in F-format (i.e. underflow.)  Zero is returned in R4 for the reduced
; argument to signal this occurance.  Note that under these conditions the
; correct function value is one of the values 0, +/-1.  The
; correct choice is determined by the calling program based on the octant bits
; returned in R1.
;
	CLRL	R3			; Reduced argument is zero
	EXTZV	#29, #3, 8(SP), R2	; R2 = octant bits
	BRW	RESTORE


CONVERT_1: 
	ADDL	#4, R4			; R4 points to low bits of h
	JSB	CVT_TO_DOUBLE		; R0/R1 = 2^W*h_lo
					; R6/R7 = 2^W*h_hi
	SUBD3	R6, D_2_TO_32, R6	; R6/R7 = 2^W*(1 - h_hi)
	MNEGD	R0, R0			; R0/R1 = -2^W*h_lo
	EXTZV	#29, #3, -4(R5), R2	; R2 = octant bits
	SUBL	(R5), R6		; R6/R7 = 1 - h_hi
	TSTW	R0			; Check for h_lo = 0
	BEQL	GET_YHI_YLO		; 
	SUBL	(R5), R0		; R0/R1 = - h_lo
	BRB	GET_YHI_YLO


LEADING_ZEROS:

; If processing continues here it is known that the loss of significance is due
; to a string of leading zeros.  Note that it is known that the loop for 
; leading zeros will terminate before an underflow condition occurs so that the
; loop does not include a test for underflow.

	MOVL	#L_INT_WEIGHT, (R5)	; T8 = exp bias for last longword
					;    of the product K*C'

LOOP_0: CMPL	#^X001FFFFF, 12(R4)	; Check enough fraction bits
	BLSS	CONVERT_0		; Enough bits.  Convert to floating
	JSB	GEN_MORE_BITS		; T2/R7 contain K*C''
1$:	TSTL	12(R4)			; Check for all 0's
	BNEQ	CONVERT_0		; Not all 0's.  Enough precision bits.
	MOVQ	4(R4), 8(R4)		; Compress representation 
	MOVQ	-4(R4), (R4)		;    of K*C''
	ADDW	#W_TERM_WEIGHT, (R5)	; Increment weighting factor.  
	BRB	LOOP_0

CONVERT_0:
	ADDL	#4, R4			; R4 points to low bits of h
	JSB	CVT_TO_DOUBLE		; R0/R1 = 2^W*h_lo
					; R6/R7 = 2^W*h_hi
	EXTZV	#29, #3, -4(R5), R2	; R2 = octant bits
	SUBL	(R5), R6		; R6/R7 = h_hi
	TSTW	R0			; Check for h_lo = 0
	BEQL	GET_YHI_YLO		;
	SUBL	(R5), R0		; R0/R1 = h_lo

GET_YHI_YLO:
	MOVQ	R6, R4			; R4/R5 = high bits of Y
	CLRL	R7			; R6/R7 = high 24 bits Y = YHI
	SUBD	R6, R4			;
	ADDD	R0, R4			; R4/R5 = YLO
RESTORE:
	BISPSW	36(SP)			; Restore IV bit and exit
	ADDL	#40, SP			; Remove mask and temporary storage 
	RSB


GEN_MORE_BITS:

;
; This subroutine generates 85 extra fraction bits and puts them to the
; existing bits.  NOTE:  This routine is always entered via a JSB instruction.
; Consequently, SP points to the first longword BEFORE T0, rather than T0
; itself.
;

	SUBL	#4, R2			; Adjust pointer to get next quadword
					;   from MTH$AL_4_OV_PI
	ASHQ	R3, (R2), R6		; R7 = C(n)
	BGEQ	1$			; Branch if high bit is clear

; Logic to process unsigned values greater than 2^31 - 1

	EMUL	R1, R7, #0, 4(SP)	; 
	ADDL	R1, 8(SP)		; T0/T1 = KLO*C(n)
	EMUL	R0, R7, 8(SP), 8(SP)	;
	ADDL	R0, 12(SP)		; T0/T2 = K*C(n)
	BRB	2$

; Logic to process unsigned values less than 2^31

1$:	EMUL	R1, R7, #0, 4(SP)	; T0/T1 = KLO*C(n)
	EMUL	R0, R7, 8(SP), 8(SP)	; T0/T2 = K*C(n)

; Add new bits to old

2$:	ADDL	8(SP), (R4)		;
	ADWC	12(SP), 4(R4)		;
	BCC	3$			; Check for carry from previous add
	INCL	8(R4)			; Propagate carry
	BCC	3$			; Check for carry from previous add
	INCL	12(R4)			; Propagate carry
3$:	MOVL	4(SP), -4(R4)		; Move new low order bits to end of
					;   of old low order bits
	RSB				;





CVT_TO_DOUBLE:

;
; This routine converts an array of three longword pointed to by R4 to a pair
; of D-format values.  The results are returned in R0/R1 (low 48 bits) and
; R6/R7 (high 48 bits).  ;

	CVTLD	(R4)+, R0		; R0/R1 = Low 32 bits of h
	BEQL	2$			;
	BGTR	1$			; Adjust for signed 
	INCL	(R4)			;   conversion error
	BCC	1$			; If necessary,
	INCL	4(R4)			;   propagate carry
1$:	SUBW	#W_TERM_WEIGHT, R0	; R0/R1 = (low 32 bits of h)/2^32
2$:	BICL3	#^XFFFF0000, (R4), -4(R4)
	SUBL	-4(R4), (R4)		;
	CVTLD	-4(R4), R2		;
	ADDD	R2, R0			; R0/R1 = (low 48 bits of h)/2^32
	BEQL	3$			;
	SUBW	#W_TERM_WEIGHT, R0	; R0/R1 = (low 48 bits of h)/2^64
3$:	CVTLD	(R4)+, R2		; R2/R3 = next 16 bits of h
	BEQL	5$			;
	BGTR	4$			; Adjust for signed conversion error.
	INCL	(R4)			;   Note that no carry is possible
4$:	SUBW	#W_TERM_WEIGHT, R2	; R2/R3 = (next 16 bits of h)/2^32
5$:	CVTLD	(R4), R6		; R6/R7 = high 32 bits of h
	BGEQ	6$			; Adjust for signed conversion
	ADDD	D_2_TO_32, R6		;   error
6$:	ADDD	R2, R6			; R6/R7 = (high 48 bits of h)/2^32
	RSB


	.SBTTL	REDUCE_DEGREES

; This routine assumes that the absolute value of the argument is in R0/R1.
; The reduction process is performed in two stages.  The first stage of 
; the reduction reduces the argument modulo 360 to a value less that 2^55, 
; and the second stage reduces the argument modulo 45 to a value less than 45.

; Constants used in this reduction:
;

POWER_MOD_360_0:	; Powers of 2 modulo 360 for t1 = 0
	.WORD	  1,	  2,	  4,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248

POWER_MOD_360_1:	; Powers of 2 modulo 360 for t1 <> 0
	.WORD	136,	272,	184,	  8
	.WORD	 16,	 32,	 64,	128
	.WORD	256,	152,	304,	248



REDUCE_DEGREES:
	CMPW	#^X5C00, R0		; Compare |x| with 2^55
	BGTR	LAST_STEP		; Branch to special logic for med arg

;
; It is assumed here that the argument is greater than 2^55.
;
; The argument is reduced as follows:
;     Let x = 2^t*f, where t > 56 and 1/2 =< f < 1.  And let J = 2^56*f = 
;     2^30*J1 + J2 and K = 2^(t-56).  Since 2^30 = 64 modulo 360, we have that
;     J = 64*J1 + J2 modulo 360.  Now let t' = t - 56 = 12*t1 + t2.  Note that
;     (2^12)^2 = (2^9)*(2^15) = (2^9)*(2^3) = 2^12 modulo 360.  Hence, if t1 is
;     not zero, K = 2^t' = 2^(12*t1+t2) = (2^12)*(2^t2) = 136*2^t2 modulo 360.
;     For t1 = 0 K = 2^t2.  Consequently, define K' congruent to 2^t2 if t1 = 0
;     and congruent to 136*2^t2 otherwise, where 0 =< K' < 360.  Then x' =
;     K'*(64*J1 + J2) is congruent to s modulo 360 and x' < 2^56.

	MOVL	R0, R2			; R2 = high longword of X
	BICL	#^X7F80, R0		; Clear exp bits of X
	BISW	#^X5C00, R0		; R0/R1 = J
	SUBL	R0, R2			; R2 = t'*2^7

	MOVQ	R0, R3			; R3/R4 = J
	BICL	#^XFFFF3FFF, R1		; R0/R1 = J1*2^30
	SUBD	R0, R3			; R3/R4 = J2
	SUBW	#^XC00, R0		; R0/R1 = 64*J1
	ADDD	R3, R0			; R0/R1 = 64*J1 + J2 = J modulo 45

	ROTL	#-7, R2, R2		; R2 = t'
	DIVW3	#12, R2, R3		; R3 = t1
	MULW	#12, R3			; R3 = 12*t1
	SUBW	R3, R2			; R2 = t2

	TSTW	R3			; Check for t1 = 0 and choose K'
	BNEQ	1$			;   accordingly
	CVTWD	POWER_MOD_360_0[R2], R2	; R2/R3 = K'
	BRB	2$			;
1$:	CVTWD	POWER_MOD_360_1[R2], R2	; R2/R3 = K'
2$:	MULD	R2, R0			; R0/R1 = X' (mod 45) 0 =< R0 < 2^55


LAST_STEP:
;
; Argument reduction scheme for arguments with absolute value less than 2^55
;
; The reduced argument Y is computed as follows:
;    Let I = int(X/45)
;       if I is even
;          then Y = X - 45*I
;          else Y = (I+1)*45 - x


	CMPW	#^X5200, R0		; Compare 2^36 with |X|
	BGEQ	NO_OVERFLOW		;
	MULD3	D_1_OV_45, R0, R6	; R6/R7 = |X|/45

;
; Turn off IV to avoid an exception in EMODD
;
	MOVPSL	R2			; Move PSL to R2
	BICL	#^C<PSL$M_IV>, R2	; Save current IV bit
	BICPSW	#PSL$M_IV		; Turn off integer overflow trap

	EMODD	#1, #0, R6, R3, R4	; R3 = low 32 integer bits of |X|/45
					; R4/R5 = fractional part of |X|/45

	BISPSW	R2			; Restore IV bit

	SUBD2	R4, R6			; R6/R7 = Integer part of |X|/45 = I
	BLBC	R3, EVEN		;
	ADDD2	#1, R6			; R6/R7 = I + 1	
	BRB	ODD


NO_OVERFLOW:
	EMODD	D_1_OV_45, #X_1_OV_45, R0, R3, R4
					; R3 = I = integer part of |X|/45
	BLBC	R3, CVT			; Branch if octant bits are even
	ADDL3	#1, R3, R6		; R6 = I + 1
	CVTLD	R6, R6			; R6/R7 = I + 1
ODD:	MULD2	D_45, R6		; R6/R7 = 45*(I+1)
	SUBD2	R0, R6			; R6/R7 = Y
	BICB	#^XF8, R3		; Save only last three octant bits
	RSB

CVT:	CVTLD	R3, R6			; R6/R7 = I
EVEN:	MULD2	D_M45, R6		; R6/R7 = -45*I
	ADDD2	R0, R6			; R6/R7 = Y
	BICB	#^XF8, R3		; Save only last three octant bits
	RSB




	.SBTTL	RADIAN_POLYNOMIALS	; Polynomials for arguments in radians



;
; Polynomial evaluation for DCOS(Y) for Y in radians
;

P_COS_R:
	BICW3	#^X8000, R6, R3		; 
	CMPW	#^X4000, R3		; Compare 1/2 with |YHI|
	BGTR	LEQL_HALF		; Sufficent overhang is available
NEEDS_DOUBLE:
	MOVQ	R4, -(SP)		; Save YLO
	ADDD3	R6, R4, -(SP)		; Save Y
	MULD3	(SP), (SP), R0		; R0/R1 = Y^2
	POLYD	R0, #COSLENR2-1, COSTBR2; R0/R1 = Q(Y^2)
	ADDD3	(SP)+, R6, R4		; R4/R5 = Y + YHI
	MULD	(SP)+, R4		; R4/R5 = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#^X80, R4		; R4/R5 = A2/2
1$:	SUBD	R4, R0			; R0/R1 = Q(Y^2) - A2/2
	MULD	R6, R6			; R6/R7 = YHI^2
	SUBW	#^X80, R6		; R6/R7 = YHI^2/2
	SUBD	#1, R6			; R6/R7 = -(1 - YHI^2/2)
	SUBD	R6, R0			; R0/R1 = DCOS(Y)
	RSB

LEQL_HALF:
	ADDD	R4, R6			; R6/R7 = Y
	MULD	R6, R6			; R6/R7 = Y^2
	POLYD	R6, #COSLENR1-1, COSTBR1; R0/R1 = DCOS(Y)
	RSB


;
; Polynomial evaluation for -DCOS(Y)
;

N_COS_R:
	BICW3	#^X8000, R6, R3		; 
	CMPW	#^X4000, R3		; Compare 1/2 with |YHI|
	BGTR	2$			; Sufficent overhang is available
	MOVQ	R4, -(SP)		; Save YLO
	ADDD3	R6, R4, -(SP)		; Save Y
	MULD3	(SP), (SP), R0		; R0/R1 = Y^2
	POLYD	R0, #COSLENR2-1, COSTBR2; R0/R1 = Q(Y^2)
	ADDD3	(SP)+, R6, R4		; R4/R5 = Y + YHI
	MULD	(SP)+, R4		; R4/R5 = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#^X80, R4		; R4/R5 = A2/2
1$:	SUBD	R4, R0			; R0/R1 = Q(Y^2) - A2/2
	MULD	R6, R6			; R6/R7 = YHI^2
	SUBW	#^X80, R6		; R6/R7 = YHI^2/2
	SUBD	#1, R6			; R6/R7 = -(1 - YHI^2/2)
	SUBD3	R0, R6, R0		; R0/R1 = -DCOS(Y)
	RSB

2$:	ADDD	R4, R6			; R6/R7 = Y
	MULD	R6, R6			; R6/R7 = Y^2
	POLYD	R6, #COSLENR1-1, COSTBR1; R0/R1 = DCOS(Y)
	XORW	#^X8000, R0		; R0/R1 = -DCOS(Y)
	RSB

;
; Polynomial evaluation for -DSIN(Y)
;

N_SIN_R:
	XORW	#^X8000, R4		;
	XORW	#^X8000, R6		; R4/R7 = -Y

;
; Polynomial evaluation for DSIN(Y)
;

P_SIN_R:
	MOVQ	R4, -(SP)		; Save YLO
	ADDD3	R4, R6, -(SP)		; Save Y
	MULD3	(SP), (SP), R4		; R4 = Y^2
	POLYD	R4, #SINLENR-1, SINTBR	; R0/R1 = P(Y^2)
	MULD	(SP)+, R0		; R0/R1 = Y*P(Y^2)
	ADDD	(SP)+, R0		; R0/R1 = YLO + Y*P(Y^2)
	ADDD	R6, R0			; R0/R1 = Y + Y*P(Y^2) = DSIN(Y)
	RSB




	.SBTTL	CYCLE_POLYNOMIALS	; Polynomials for arguments in cycles



;
; Polynomial evaluation for DCOS(Y) for Y in cycles
;

P_COS_C:
	CMPD	D_2_OV_PI, R6		; Compare 2/pi with |YHI|
	BGEQ	2$			; Sufficent overhang is available
	MOVQ	R4, -(SP)		; Save YLO
	ADDD3	R6, R4, -(SP)		; Save Y
	MULD3	(SP), (SP), R0		; R0/R1 = Y^2
	POLYD	R0, #COSLENC2-1, COSTBC2; R0/R1 = Q(Y^2)
	ADDD3	(SP)+, R6, R4		; R4/R5 = Y + YHI
	MULD	(SP)+, R4		; R4/R5 = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#^X100, R4		; R4/R5 = A2/4
1$:	SUBD	R4, R0			; R0/R1 = Q(Y^2) - A2/4
	MULD	R6, R6			; R6/R7 = YHI^2
	SUBW	#^X100, R6		; R6/R7 = YHI^2/4
	SUBD	#1, R6			; R6/R7 = -(1 - YHI^2/4)
	SUBD	R6, R0			; R0/R1 = DCOS(Y)
	RSB

2$:	ADDD	R4, R6			; R6/R7 = Y
	MULD	R6, R6			; R6/R7 = Y^2
	POLYD	R6, #COSLENC1-1, COSTBC1; R0/R1 = DCOS(Y) - 1
	ADDD	#1, R0			; R0/R1 = DCOS(Y)
	RSB


;
; Polynomial evaluation for -DCOS(Y)
;

N_COS_C:
	CMPD	D_2_OV_PI, R6		; Compare 2/pi with |YHI|
	BGEQ	2$			; Sufficent overhang is available
	MOVQ	R4, -(SP)		; Save YLO
	ADDD3	R6, R4, -(SP)		; Save Y
	MULD3	(SP), (SP), R0		; R0/R1 = Y^2
	POLYD	R0, #COSLENC2-1, COSTBC2; R0/R1 = Q(Y^2)
	ADDD3	(SP)+, R6, R4		; R4/R5 = Y + YHI
	MULD	(SP)+, R4		; R4/R5 = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#^X100, R4		; R4/R5 = A2/4
1$:	SUBD	R4, R0			; R0/R1 = Q(Y^2) - A2/4
	MULD	R6, R6			; R6/R7 = YHI^2
	SUBW	#^X100, R6		; R6/R7 = YHI^2/4
	SUBD	#1, R6			; R6/R7 = -(1 - YHI^2/4)
	SUBD3	R0, R6, R0		; R0/R1 = -DCOS(Y)
	RSB

2$:	ADDD	R4, R6			; R6/R7 = Y
	MULD	R6, R6			; R6/R7 = Y^2
	POLYD	R6, #COSLENC1-1, COSTBC1; R0/R1 = DCOS(Y) - 1
	SUBD3	R0, #-1, R0		; R0/R1 = -DCOS(Y)
	RSB

;
; Polynomial evaluation for -SIN(Y)
;

N_SIN_C:
	XORW	#^X8000, R4		; 
	XORW	#^X8000, R6		; R4/R7 = - Y

;
; Polynomial evaluation for DSIN(Y)
;

P_SIN_C:
	MOVQ	R4, -(SP)		; Save YLO
	ADDD3	R4, R6, -(SP)		; Save Y
	MULD3	(SP), (SP), R4		; R4 = Y^2
	POLYD	R4, #SINLENC-1, SINTBC	; R0/R1 = P(Y^2)
	MULD	(SP)+, R0		; R0/R1 = Y*P(Y^2)
	ADDD	(SP), R0		; R0/R1 = Y*P(Y^2) + YLO
	SUBW	#^X100, (SP)		; (SP) = YLO/4
	SUBD	(SP)+, R0		; R0/R1 = Y*P(Y^2) + 3/4*YLO
	MOVQ	R6, R4			; R4/R5 = YHI
	SUBW	#^X100, R4		; R4/R5 = YHI/4
	SUBD	R4, R6			; R6/R7 = 3/4*YHI
	ADDD	R6, R0			; R0/R1 = DSIN(Y)
	RSB


	.SBTTL	DEGREE_POLYNOMIALS


P_COS_D:
	CMPD	D_90_OV_PI, R6		; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	MULD3	R6, R6, R4		; R0/R1 = Y^2
	POLYD	R4, #COSDLN1, COSDTB1	; R0/R1 = Q(Y^2) 
	BICL3	#^X70000, R6, R4	;
	CLRL	R5			; R4/R5 = YHI
	SUBD3	R4, R6, R2		; R2 = YLO
	ADDD	R4, R6			; R6/R7 = Y + YHI
	MULD	R2, R6			; R6/R7 = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#^X680, R6		; R6/R7 = A2/2^13
1$:	SUBD	R6, R0			; R0/R1 = Q(Y^2) - A2/2^13
	MULD	R4, R4			; R4/R5 = YHI^2
	SUBW	#^X680, R4		; R4/R5 = YHI^2/2^13
	SUBD	#1, R4			; R4/R5 = -(1 - YHI^2/2^13)
	SUBD	R4, R0			; R0/R1 = DCOS(Y)
	RSB

2$:	MULD	R6, R6			; R6/R7 = Y^2
	BEQL	3$			; Check for Y = 0
	POLYD	R6, #COSDLN2, COSDTB2	; R0/R1 = Q(Y^2)
	RSB

3$:	MOVD	#1, R0			; R0/R1 = DCOS(Y)
	RSB


N_COS_D:
	CMPD	D_90_OV_PI, R6		; Compare 90/pi with Y
	BGEQ	2$			; Double precision isn't needed
	MULD3	R6, R6, R4		; R0/R1 = Y^2
	POLYD	R4, #COSDLN1, COSDTB1	; R0/R1 = Q(Y^2) 
	BICL3	#^X70000, R6, R4	;
	CLRL	R5			; R4/R5 = YHI
	SUBD3	R4, R6, R2		; R2 = YLO
	ADDD	R4, R6			; R6/R7 = Y + YHI
	MULD	R2, R6			; R6/R7 = YLO*(Y + YHI) = A2
	BEQL	1$			; Check for A2 = 0
	SUBW	#^X680, R6		; R6/R7 = A2/2^13
1$:	SUBD	R6, R0			; R0/R1 = Q(Y^2) - A2/2^13
	MULD	R4, R4			; R4/R5 = YHI^2
	SUBW	#^X680, R4		; R4/R5 = YHI^2/2^13
	SUBD	#1, R4			; R4/R5 = -(1 - YHI^2/2^13)
	SUBD3	R0, R4, R0		; R0/R1 = -DCOS(Y)
	RSB

2$:	MULD	R6, R6			; R6/R7 = Y^2
	BEQL	3$			; Check for Y = 0
	POLYD	R6, #COSDLN2, COSDTB2	; R0/R1 = DCOSD(Y)
	XORW	#^X8000, R0		; R0/R1 = -DCOSD(Y)
	RSB

3$:	MOVD	#-1, R0			; R0/R1 = DCOS(Y)
	RSB

N_SIN_D:
	MNEGD	R6, R6			; R6/R7 = -Y
P_SIN_D:
	MULD3	R6, R6, R0		; R0/R1 = Y^2
	BEQL	RETURN
	POLYD	R0, #SINDLN, SINDTB	; R0/R1 = P(Y^2)
	MULD	R6, R0			; R0/R1 = Y*P(Y^2)
	SUBW	#^X300, R6		; R6/R7 = Y/2^6
	ADDD	R6, R0			; R0/R1 = DSIN(Y)
RETURN:	RSB




	.SBTTL	DEGENERATE_SOLUTIONS

P_ONE:
	MOVD	#1, R0			; Answer is 1
	RSB


N_ONE:
	MOVD	#-1, R0			; Answer is -1
	RSB


UNFL:
;
; Underflow; if user has FU set, signal error.  Always return 0.0
;
	MOVPSL	R2			; R2 = user's or jacket routine's PSL
	CALLS	#0, G^MTH$$JACKET_TST	; R0 = TRUE if JSB from jacket routine
	BLBC	R0, 10$			; branch if user did JSB
	MOVZWL	SF$W_SAVE_PSW(FP), R2	; get user PSL saved by CALL
10$:	CLRL	R0			; R0 = result. LIB$SIGNAL will save in
					; CHF$L_MCH_R0/R1 so any handler can 
					;   fixup
	BBC	#6, R2, 20$		; has user enabled floating underflow?
	PUSHL	(SP)			; yes, return PC from special routine
	MOVZBL	#MTH$K_FLOUNDMAT, -(SP)	; trap code for hardware floating 
					;   underflow convert to MTH$_FLOUNDMAT
					;   (32-bit VAX-11 exception code)
	CALLS	#2, G^MTH$$SIGNAL	; signal (condition, PC)
20$:	RSB				; return

	.END
