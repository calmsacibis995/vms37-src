	.TITLE	LIB$EMULATE - Emulate VAX-11 Instructions
	.IDENT	/1-012/			; File: LIBEMULAT.MAR Edit: SBL1012

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: General Utility Library
;
; ABSTRACT:
;
;	LIB$EMULATE is a condition handler which emulates execution
;	of VAX-11 instructions which are not implemented on the host
;	processor.
;
; ENVIRONMENT: Runs at any access mode, AST Reentrant
;
; AUTHOR: Derek Zave, CREATION DATE 16-JAN-1980
;
; MODIFIED BY:
;	Steven B. Lionel, convert to RTL module format.
;
; 1-001 - Convert module to RTL standard format.  SBL 16-Jan-1980
; 1-002 - Remove non-useful commentary.  SBL 22-Jan-1980
; 1-003 - Correct some commentary.  SBL 1-Feb-1980
; 1-004 - Correct negative step problem for ACBG and ACBH. DAZ 14-Feb-1980
; 1-005 - Correct test for modified indexed addressing mode error.  SBL 22-May-1980
; 1-006 - Remove restriction that stack frames must be in P1 space.  SBL 22-May-1980
; 1-007 - Correct logic error when rounding to an integer.  SBL 9-Jun-1980
; 1-008 - Add speedup: at end of instruction emulation, look ahead to next
;	  instruction to see if it also is an emulateable one.  SBL 28-July-1980
; 1-009 - Correct typo in previous edit where PROBER was done with access mode
;	  in the wrong register.  SBL 26-Jan-1981
; 1-010 - Correct typo in ROUND_REAL which caused a branch to the wrong
;	  instruction.  SBL 7-Apr-1981
; 1-011 - Use new SYS$SRCHANDLER interface to condition handling mechanism.
;	  SBL 19-AUG-1981
; 1-012 - Use LIB$GET_OPCODE if a BPT is seen.  SBL 4-Dec-1981
;--

	.SBTTL	DECLARATIONS
;
; LIBRARY MACRO CALLS:
;
	$SSDEF			; System Status Codes
;
; EXTERNAL DECLARATIONS:
;
	.DSABL	GBL		; Force all external symbols to be declared
	.EXTRN	LIB$GET_OPCODE	; Get opcode from debugger
	.EXTRN	SYS$CALL_HANDL	; System routine that calls handlers
	.EXTRN	SYS$SRCHANDLER	; System routine that looks for handlers
	.EXTRN	SYS$UNWIND	; Unwind exception
;
; MACROS:
;

;	Macro for Comparing Condition Codes
	.MACRO	CMPCOND	COND,LOC
	CMPZV	#3,#26,LOC,#COND@-3
	.ENDM

;
; EQUATED SYMBOLS:
;
;	See body of routine
;
; OWN STORAGE:
;
;	.PSECT _LIB$DATA PIC, USR, CON, REL, LCL, NOSHR, -
;			NOEXE, RD, WRT, LONG
;
;	NONE
;
; PSECT DECLARATIONS:
;
	.PSECT _LIB$CODE PIC, USR, CON, REL, LCL, SHR, -
			EXE, RD, NOWRT, LONG


	.SBTTL	LIB$EMULATE - Emulate VAX-11 Instructions
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine emulates VAX-11 instructions that are not implemented
;	on the host processor.  It is designed to be a condition
;	handler or to be called by one.  See the body of the routine
;	for more comments.
;
; CALLING SEQUENCE:
;
;	continue.wlc.v = LIB$EMULATE (sigargs.ma.r, mechargs.ma.r)
;
; FORMAL PARAMETERS:
;
;	sigargs		Signal argument list
;	mechargs	Mechanism argument list
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION STATUS: (or ROUTINE VALUE:)
;
;	SS$_NORMAL	Normal successful completion
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;	************************************************************************
;	*								       *
;	*								       *
;	*			How to Use the Emulator			       *
;	*								       *
;	*								       *
;	************************************************************************
;
;
;	Abstract
;	--------
;
;	    This routine simulates the new octaword, G-format floating, and
;	H-format floating, instructions of the VAX architecture on VAXes which
;	do not have the instructions. 
;
;
;	Introduction
;	------------
;
;	    The Emulator provides an emulation of the new instructions of the
;	VAX architecture for manipulating octawords and the G-format and
;	H-format floating types (described in Revision 5 of the VAX-11 System
;	Reference Manual). In the sequel the G-format and H-format floating
;	types will be referred to as "grand" and "huge". The Emulator has been
;	written so that the development of software for supporting these types
;	may be started as soon as possible and so that certain applications
;	which may need to manipulate these types (such as constant expression
;	folding in compilers) may be implemented without avoiding the new
;	instructions. Ultimately it is hoped that the Emulator will satisfy
;	the requirements for software simulation of the instructions described
;	on page E-4 of the VAX SRM.
;
;	    It has been the intention in developing the Emulator to simulate
;	the architecture as closely as possible including the operation of
;	the various faults and traps that may occur. In order do this from an
;	emulator that runs at the same access mode as the user, it has been
;	necessary to step outside of the rules for modulor programming on VAX.
;	Also, some undocumented properties of the condition handling mechanism
;	have been used. These transgressions will be pointed out in the
;	documentation of the module.
;
;	    The algorithms chosen for the arithmetic operations as well as
;	the overall design of the Emulator have been chosen with emphasis on
;	clarity and demonstrable correctioness at some expense of running
;	speed and program size. It is hoped that these choices will make it
;	comparitively simple to verify that the appropriate parts of the
;	VAX architecture have been faithfully implemented in the Emulator.
;
;
;	Operation of the Emulator
;	-------------------------
;
;	    The Emulator emulates the following VAX instructions:
;
;		ACBG	add compare and branch grand
;		ACBH	add compare and branch huge
;		ADDG2	add grand (two operands)
;		ADDG3	add grand (three operands)
;		ADDH2	add huge (two operands)
;		ADDH3	add huge (three operands)
;		CLRO	clear octaword
;		CLRH	clear huge
;		CMPG	compare grand
;		CMPH	compare huge
;		CVTBG	convert byte to grand
;		CVTBH	convert byte to huge
;		CVTDH	convert double to huge
;		CVTFG	convert floating to grand
;		CVTFH	convert floating to huge
;		CVTGB	convert grand to byte
;		CVTGF	convert grand to floating
;		CVTGH	convert grand to huge
;		CVTGL	convert grand to long
;		CVTGW	convert grand to word
;		CVTHB	convert huge to byte
;		CVTHD	convert huge to double
;		CVTHF	convert huge to floating
;		CVTHG	convert huge to grand
;		CVTHL	convert huge to long
;		CVTHW	convert huge to word
;		CVTLG	convert long to grand
;		CVTLH	convert long to huge
;		CVTRGL	convert rounded grand to long
;		CVTRHL	convert rounded huge to long
;		CVTWG	convert word to grand
;		CVTWH	convert word to huge
;		DIVG2	divide grand (two operands)
;		DIVG3	divide grand (three operands)
;		DIVH2	divide huge (two operands)
;		DIVH3	divide huge (three operands)
;		EMODG	extended modulus grand
;		EMODH	extended modulus huge
;		MNEGG	move negated grand
;		MNEGH	move negated huge
;		MOVAH	move address of huge
;		MOVAO	move address of octaword
;		MOVG	move grand
;		MOVH	move huge
;		MOVO	move octaword
;		MULG2	multiply grand (two operands)
;		MULG3	multiply grand (three operands)
;		MULH2	multiply huge (two operands)
;		MULH3	multiply huge (three operands)
;		POLYG	evaluate polynomial grand
;		POLYH	evaluate polynomial huge
;		PUSHAH	push address of huge
;		PUSHAO	push address of octaword
;		SUBG2	subtract grand (two operands)
;		SUBG3	subtract grand (three operands)
;		SUBH2	subtract huge (two operands)
;		SUBH3	subtract huge (three operands)
;		TSTG	test grand
;		TSTH	test huge
;
;	    The emulation includes processing the instruction operands
;	and accessing the operands together with any necessary error checking.
;	All kinds of operand addressing are supported. However, those
;	addressing modes which are specified by the architecture to be illegal
;	or unpredictable are considered to be reserved addressing modes.
;
;	    All addresses which are accessed during instruction emulation
;	including addresses in the instruction are probed for the appropriate
;	kind of access. The area below the user's stack pointer is used as
;	working storage so the user should assume that this area is being
;	continually garbaged.
;
;	    When exceptions occur the Emulator signals the condition as though
;	the condition were a hardware generated exception intercepted by the
;	operating system. The following conditions are checked for and
;	signaled:
;
;		SS$_OPCDEC	opcode reserved to Digital fault
;		SS$_ACCVIO	access violation fault
;		SS$_RADRMOD	reserved addressing mode fault
;		SS$_ROPRAND	reserved operand fault
;		SS$_FLTUND_F	floating underflow fault
;		SS$_FLTDIV_F	floating divide by zero fault
;		SS$_FLTOVF_F	floating overflow fault
;		SS$_INTOVF	integer overflow trap
;
;	When these exceptions occur, the registers, PC and PSL are left in
;	the state specified by the architecture. In particular some faults
;	which may occur in the POLYG and POLYH instructions will occur with
;	FPD set in the PSL. The Emulator is designed to resume rather than
;	restart these instructions if FPD is set in the PSL supplied to the
;	Emulator. In all respects the Emulator spares no expense in making
;	exceptions look like a hardware exceptions. This includes insuring
;	that the end of the signal array is the position of the user's stack
;	pointer at the time of the exception.
;
;
;	Differences from the Hardware Implementation
;	--------------------------------------------
;
;	    Below is what is believed to be a complete list of the differences
;	between the Emulator and the hardware that are in any way detectable
;	by the user. We have not included differences which are related to 
;	whether or not the Emulator is being used rather than to the operation
;	of the Emulator itself.
;
;	     1. Emulated instructions take longer. Measured instruction
;		timings indicate ranges of from 300 microseconds (CLRH) to
;		2000 microseconds (DIVH) for the Emulator. Timings for the
;		hardware are not available yet but I think it may be safely
;		assumed that they will be much smaller.
;
;	     2. Emulated instructions are interruptable. This is because the
;		Emulator does not block ASTs while it is running. Therefore
;		an AST which becomes active while the Emulator is running
;		may find the actions for an instruction only partially
;		completed.
;
;	     3. The Emulator garbages the area below the user's stack pointer.
;		The Emulator uses about 350 bytes immediatly below the user's
;		stack pointer as working storage. The Emulator protects itself
;		against instructions that store into its working storage in 
;		such a way that the user may assume that the stored result was
;		garbaged afterwards. 
;
;	     4. While the Emulator is active there is an extra procedure frame
;		on the stack. This may detected by an AST becoming active
;		while the Emulator is executing. Tricky condition handling
;		schemes which depend on detailed knowlege of the frames on the
;		stack may be confused by the extra frame.
;
;	     5. In the architecture certain values and states are specified
;		as implementation defined, undefined, or unpredictable. Under
;		the Emulator, these values and states may turn out to be 
;		different from those given by the hardware. However, when the
;		value or state is specified by the architecture to have some 
;		property, then the resulting value or state given by the 
;		Emulator will still have the property although it may not
;		be the same as that given by the hardware. 
;
;	     6. When faults and traps are signaled by the Emulator, the
;		distances between the signal array, the mechanism array, and
;		the parameter list supplied to a condition handler may be
;		different. This in no way implies any difference in the 
;		contents of these data structures except possibly in pointers
;		to and between these structures.
;
;	    The reader may conclude from the above list that it is very
;	difficult to tell whether or not the Emulator is being used without
;	resorting to unacceptable programing practices or employing special
;	knowledge of the implementation defined aspects of the architecture.
;
;
;
;	Using the Emulator
;	------------------
;
;	    On a VAX processor which does not implement the full architecture
;	an attempt to execute one of the new instruction results in an "opcode
;	reserved to DEC" fault. By capturing control at this fault with a
;	condition handler it is possible to emulate each of the new
;	instructions as it is encountered in the normal sequence of execution.
;
;	    The Emulator does this by providing a condition handling routine
;	LIB$EMULATE which may be used as a condition handler or may be
;	called from a condition handler. When the routine LIB$EMULATE is
;	called it checks the condition code for an instruction code reserved
;	to DEC and the offending instruction for one of the emulated
;	instructions.
;
;	    If either of these tests fails, the routine returns with the code
;	SS$_RESIGNAL to indicate that it can not handle the condition. If
;	both tests succeed, then the routine unwinds call frames on the stack
;	up to and including the frame for the condition handler in order to
;	clean off the stack up to the stack pointer of the instruction and
;	then proceeds to emulate the instruction. When the emulation is
;	complete, control returns following the instruction or at its
;	appointed branch destination.
;
;	    If the program is moved to another VAX processor in which the
;	instruction is implemented then the reserved instruction code fault
;	will never take place so the Emulator will never be activated. Thus,
;	there will be no problems if the Emulator is left in a program that
;	will run on a VAX with the full architecture except for a slight
;	increase in condition handling costs.
;
;	    It should be emphasised that when LIB$EMULATE chooses to
;	emulate an instruction, it unwinds the condition handler frames
;	without activating their condition handlers with an SS$_UNWIND
;	condition code.
;
;	    All that is necessary to enable the Emulator in a program
;	is to insure that LIB$EMULATE is in on the condition handling
;	for the program. If the program does not have any other condition
;	handling, then the instruction
;
;			MOVAB	LIB$EMULATE,(FP)
;
;	executed shortly after the program or routine is started will
;	enable the condition handling. If the program already has condition
;	handling then the following sequence should appear in the condition
;	handler:
;
;			PUSHAB	<mechanism array location>
;			PUSHAB	<signal array location>
;			CALLS	#2,LIB$EMULATE
;
;	Often this can be simplified to
;
;			CALLG	(AP),LIB$EMULATE
;
;	If either of these sequences returns, then it may be assumed
;	that R0 contains the condition code SS$_RESIGNAL. The call will
;	not return and the condition handler frames will be forcibly
;	unwound if the Emulator chooses to handle the condition.
;
;
;
;	Fast Emulator Entrance LIB$EMULATE_JSB
;	--------------------------------------
;
;	    There is a special entrance to the Emulator which is ultimately
;	intended for fast entrance to the Emulator from VMS once DEC's 
;	policy on the Emulator is determined. This entrance can also be 
;	used to enter the Emulator on machines which actually have the
;	hardware since it bypasses the reserved opcode exception mechanism.
;
;	    To enter the Emulator through the special fast entrance, the
;	following steps should be performed.
;
;	     1. Push the PSL for the emulated instruction onto the stack
;		for the access mode under which the instruction is to be
;		executed.
;
;	     2. Push the location of the instruction onto the stack for the
;		access mode under which the instruction is to be executed.
;
;	     3. Switch the current PSL to the same PSL as pushed in 1 above
;		except with the FPD bit, and perhaps the the T and TP bits,
;		cleared.
;
;	     4. Branch to the location EMULATE$ in the Emulator.
;
;	The Emulator will then emulate the instruction after verifying that
;	the instruction is valid. If the instruction is not valid, then an
;	"opcode reserved to DEC" condition will be signaled. If either of the
;	first two bytes of the instruction can not be read, then an access
;	violation will be signaled instead.
;
;	For this release, the entry EMULATE$ is not available as
;	a global symbol.
;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*			Assorted Definitions		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;
	;	Parameters
	;
CALL_ARGS =	40			; flexible stack space (longwords)
	;
	;	Operand Area Layout
	;
ZERO	=	0			; zero indicator (byte)
SIGN	=	1			; sign indicator (byte)
POWER	=	4			; exponent (longword)
FRACTION =	8			; fraction area (octaword)
OPERAND_SIZE =	24			; operand area size (bytes)
	;
	;	Bits in the Processor Status Longword (PSL)
	;
PSL_C	=	0			; carry indicator
PSL_V	=	1			; overflow indicator
PSL_Z	=	2			; zero indicator
PSL_N	=	3			; negative indicator
PSL_T	=	4			; trace enable indicator
PSL_IV	=	5			; integer overflow trap enable
PSL_FU	=	6			; floating underflow fault enable
PSL_CAM =	24			; low bit of current access mode
PSL_FPD =	27			; instruction first part done
PSL_TP	=	30			; trace pending indicator
	;
	;	Masks for the Processor Status Longword
	;
PSLM_C	=	1@PSL_C 		; carry indicator
PSLM_V	=	1@PSL_V 		; overflow indicator
PSLM_Z	=	1@PSL_Z 		; zero indicator
PSLM_N	=	1@PSL_N 		; negative indicator
PSLM_VC =	PSLM_V+PSLM_C		; overflow and carry indicators
PSLM_NZVC =	PSLM_VC+PSLM_N+PSLM_Z	; condition code
PSLM_NZ =	PSLM_N+PSLM_Z		; comparison codes
PSLM_NZV =	PSLM_NZ+PSLM_V		; bits other than carry
PSLM_LSS =	PSLM_N			; less than condition code
PSLM_EQL =	PSLM_Z			; equals condition code
PSLM_GTR =	0			; greater than condition code
	;
	;	Call Frame Layout
	;
HANDLER =	0			; condition handler location
SAVE_PSW =	4			; saved processor status word
SAVE_MASK =	6			; register save mask
MASK_ALIGN =	14			; bit position of alignment bits
SAVE_AP =	8			; user's argument pointer
SAVE_FP =	12			; user's frame pointer
SAVE_PC =	16			; return point
REG_R0	=	20			; user's R0
REG_R1	=	24			; user's R1
REG_R2	=	28			; user's R2
REG_R3	=	32			; user's R3
REG_R4	=	36			; user's R4
REG_R5	=	40			; user's R5
REG_R6	=	44			; user's R6
REG_R7	=	48			; user's R7
REG_R8	=	52			; user's R8
REG_R9	=	56			; user's R9
REG_R10 =	60			; user's R10
REG_R11 =	64			; user's R11
FRAME_END =	68			; end of call frame
	;
	;	Call Frame Extension Layout
	;
REG_AP	=	68			; user's AP
REG_FP	=	72			; user's FP
REG_SP	=	76			; user's SP
REG_PC	=	80			; user's PC
PSL	=	84			; user's PSL
LOCAL_END =	88			; end of Emulator local storage
TEMP	=	88			; temporary area for arithmetic
	;
	;	Local Storage Layout
	;
SAVE_ALIGN = 	HANDLER-1		; saved copy of alignment bits
SAVE_PARCNT =	SAVE_ALIGN-1		; saved copy of parameter count
MODE	=	SAVE_PARCNT-1		; access mode for probes
FLAGS	=	MODE-1			; indicator flag bits
SHORT_LOCAL =	FLAGS-1			; start of short local storage
REGMOD_PC =	SHORT_LOCAL-1		; changes to user's PC
REGMOD_SP =	REGMOD_PC-1		; changes to user's SP
REGMOD_FP =	REGMOD_SP-1		; changes to user's FP
REGMOD_AP =	REGMOD_FP-1		; changes to user's AP
REGMOD_R11 =	REGMOD_AP-1		; changes to user's R11
REGMOD_R10 =	REGMOD_R11-1		; changes to user's R10
REGMOD_R9 =	REGMOD_R10-1		; changes to user's R9
REGMOD_R8 =	REGMOD_R9-1		; changes to user's R8
REGMOD_R7 =	REGMOD_R8-1		; changes to user's R7
REGMOD_R6 =	REGMOD_R7-1		; changes to user's R6
REGMOD_R5 =	REGMOD_R6-1		; changes to user's R5
REGMOD_R4 =	REGMOD_R5-1		; changes to user's R4
REGMOD_R3 =	REGMOD_R4-1		; changes to user's R3
REGMOD_R2 =	REGMOD_R3-1		; changes to user's R2
REGMOD_R1 =	REGMOD_R2-1		; changes to user's R1
REGMOD_R0 =	REGMOD_R1-1		; changes to user's R0
ADDRESS1 =	REGMOD_R0-4		; temporary address area #1
ADDRESS2 =	ADDRESS1-4		; temporary address area #2
ADDRESS3 =	ADDRESS2-4		; temporary address area #3
OPERAND1 =	ADDRESS3-OPERAND_SIZE	; temporary operand area #1
OPERAND2 =	OPERAND1-OPERAND_SIZE	; temporary operand area #2
OPERAND3 =	OPERAND2-OPERAND_SIZE	; temporary operand area #3
LOCAL_START =	OPERAND3		; start of Emulator local storage
	;
	;	Indicator Bit Numbers
	;	
FLAG0	=	0			; inhibit local store check
FLAG1	=	1			; register mode operand
FLAG2	=	2			; (not assigned)
FLAG3	=	3			; (not assigned)
FLAG4	=	4			; (not assigned)
FLAG5	=	5			; (not assigned)
FLAG6	=	6			; (not assigned)
FLAG7	=	7			; temporary use
	;
	;	Indicator Bit Masks
	;
FLAG0M	=	1@0			; inhibit local store check
FLAG1M	=	1@1			; register mode operand
FLAG2M	=	1@2			; (not assigned)
FLAG3M	=	1@3			; (not assigned)
FLAG4M	=	1@4			; (not assigned)
FLAG5M	=	1@5			; (not assigned)
FLAG6M	=	1@6			; (not assigned)
FLAG7M	=	1@7			; temporary use
	;
	;	Fields in the Operand Areas
	;
ZERO1	=	OPERAND1+ZERO		; zero flag of OPERAND1
ZERO2	=	OPERAND2+ZERO		; zero flag of OPERAND2
ZERO3	=	OPERAND3+ZERO		; zero flag of OPERAND3
SIGN1	=	OPERAND1+SIGN		; sign of OPERAND1
SIGN2	=	OPERAND2+SIGN		; sign of OPERAND2
SIGN3	=	OPERAND3+SIGN		; sign of OPERAND3
POWER1	=	OPERAND1+POWER		; exponent of OPERAND1
POWER2	=	OPERAND2+POWER		; exponent of OPERAND2
POWER3	=	OPERAND3+POWER		; exponent of OPERAND3
FRACTION1 =	OPERAND1+FRACTION	; fraction of OPERAND1
FRACTION2 =	OPERAND2+FRACTION	; fraction of OPERAND2
FRACTION3 =	OPERAND3+FRACTION	; fraction of OPERAND3
	;
	;	Access Type Code Definitions
	;
TYPE_READ =	1			; read only access
TYPE_WRITE =	2			; write only access
TYPE_MODIFY =	3			; modify access
TYPE_ADDRESS =	4			; address access
	;
	;	Data Type Code Definitions
	;
TYPE_BYTE =	1			; byte
TYPE_WORD =	2			; word
TYPE_LONG =	3			; longword
TYPE_QUAD =	4			; quadword
TYPE_OCTA =	5			; octaword
TYPE_FLOAT =	6			; floating
TYPE_DOUBLE =	7			; double
TYPE_GRAND =	8			; grand
TYPE_HUGE =	9			; huge

	;
	;	LIB$EMULATE - Emulator Condition Handler Routine
	;
	;		parameters:	P1 = Location of Signal Array
	;				P2 = Location of Mechanism Array
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;
	;	    This routine is designed to function as a condition 
	;	handler or it may be called from a condition handler (possibly
	;	with a chain of intermediate procedure calls) with the 
	;	locations of the signal and mechanism arrays supplied as 
	;	parameters.
	;
	;	    Once called, the routine examines the signal array to
	;	determine if the condition was SS$_OPCDEC (opcode reserved
	;	to DEC) and if the two bytes at the PC saved in the signal
	;	array correspond to one of the emulated instructions or if
	;	the first byte is FD and the second can not be read at the 
	;	current access mode. If the tests fail then the routine
	;	returns with the status SS$_RESIGNAL.
	;
	;	    If the tests are successful, then the routine examines
	;	the procedure frames on the stack up to the condition handler
	;	frame and determines the values of the registers at the time
	;	of the exception. The registers are then restored and the
	;	stack pointer is positioned to the PC, PSL pair in the signal
	;	array. The routine then branches to EMULATE$ to perform the
	;	instruction emulation.
	;
	;	Note:	1. The method of removing the procedure frames above
	;		   the condition handler frame is similar to an 
	;		   unwind but differs in that the condition handlers
	;		   in the frames are not activated with a SS$_UNWIND
	;		   status. This was not done since it appears 
	;		   impossible to make the handler call look like it
	;		   was made by SYS$UNWIND so that overlaping unwinds
	;		   can be detected.
	;
	.ENTRY	LIB$EMULATE,-		; entrance
		^M<R2,R3>		; entry mask
	MOVL	4(AP),R0		; R0 = signal array location
	CMPCOND	SS$_OPCDEC,4(R0)	; op code reserved to DEC ?
	BNEQ	1$			; no - bypass
	MOVQ	8(R0),R0		; R0 = fault PC value, R1 = fault PSL
	CMPB	#^XFD,(R0)		; is the opcode FD ?
	BEQL	10$			; yes, ok
	CMPB	#^X03,(R0)		; BPT?
	BNEQ	1$			; no, resignal
	MOVQ	R0,R2			; Save PC/PSL temporarily
	PUSHL	R0			; Push instruction PC
	CALLS	#1,G^LIB$GET_OPCODE	; See if debugger changed it
	CMPB	#^XFD,R0		; Was it FD before?
	BNEQ	1$			; No, resignal
	MOVQ	R2,R0			; Restore PC/PSL
10$:	EXTZV	#PSL_CAM,#2,R1,R1	; R1 = current access mode
	PROBER	R1,#1,1(R0)		; can we read the next byte ?
	BEQL	2$			; no - use Emulator to report error
	MOVZBL	1(R0),R0		; R0 = second byte of op code
	TSTW	W^VECTOR[R0]		; do we handle the instruction ?
	BNEQ	2$			; yes - bypass
1$:	MOVZWL	#SS$_RESIGNAL,R0	; R0 = resignal condition code
	RET				; return
2$:	MOVAB	-12(FP),SP		; allocate stack space AP, FP, SP
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11> ; save registers R4-R11
	SUBL2	#16,SP			; allocate space for R0,R1,R2,R3
	MOVL	FP,R0			; R0 = current frame pointer
3$:	EXTZV	#0,#12,SAVE_MASK(R0),R1	; R1 = register save mask
	MOVAB	REG_R0(R0),R2		; R2 = start of registers in R0 frame
	CLRL	R3			; clear the register index
4$:	FFS	R3,#12,R1,R3		; find the next saved register
	BEQL	5$			; no more saved registers - bypass
	MOVL	(R2)+,(SP)[R3]		; get the register value
	INCL	R3			; increment the register number
	BRB	4$			; look some more
5$:	MOVQ	SAVE_AP(R0),48(SP)	; get the values of AP and FP
	CMPL	#SYS$CALL_HANDL+4,16(R0); is this the condition handler ?
	BEQL	6$			; yes - bypass
	MOVL	52(SP),R0		; R0 = location of next call frame
	BRB	3$			; unwind the frame
6$:	ADDL3	#8,4(AP),56(SP) 	; point SP to pushed PC and PSL
	MOVL	8(AP),R0		; R0 = mechanism array location
	MOVQ	12(R0),(SP)		; get R0 and R1
	POPR	#^M<R0,R1,R2,R3,R4,R5,- ; restore registers R0-SP
		R6,R7,R8,R9,R10,R11,AP,FP,SP> ; with SP pointing to PC, PSL
      ; BRB	EMULATE$		; enter the Emulator
	;

	;
	;	EMULATE$ - Fast Emulator Entrance
	;
	;		entered by branching
	;
	;		parameters:	(SP) = Instruction Location
	;				4(SP) = PSL Value for Emulation
	;
	;	Discussion
	;
	;	    This routine provides a simple method of activating the
	;	Emulator. The PC and PSL for the instruction being emulated
	;	are pushed onto the stack and the routine is entered. The 
	;	routine simply allocates the simulated user stack space for
	;	the Emulator and calls the emulation procedure.
	;
	;	Notes:	1. The FPD bit may be set in the pushed PSL. This
	;		   bit will only be interpreted during the emulation
	;		   of the POLYG and POLYH instructions where it is
	;		   interpreted as described in the VAX System 
	;		   Reference Manual.
	;
	;		2. If the Emulator does not recognize the instruction
	;		   referenced by the pushed PC as being one it handles
	;		   then it signals an SS$_OPCDEC condition. This may
	;		   cause a spurious condition if the instruction is
	;		   otherwise legal. However, there is no danger of
	;		   a signaling loop through LIB$EMULATE since that
	;		   routine performs the same checks and resignals if
	;		   they fail.
	;
EMULATE$:				; entrance
	MOVAB	-4*<CALL_ARGS-2>(SP),SP ; allocate the parameter block
	CALLS	#CALL_ARGS,B^EMULATOR	; call the Emulator
	HALT				; the Emulator will never return here
	;

	;
	;	EMULATOR - Start Instruction Emulation
	;
	;		parameters:	( Described Below )
	;
	;	Discussion
	;
	;	    This routine initializes the Emulator, processes the
	;	instruction code, and passes control to the appropriate 
	;	instruction emulation routine. The parameter list consists of
	;	CALL_ARGS longwords of which only the last two have any 
	;	meaning. These parameters are the PC and PSL for the
	;	emulation. The position following the parameter list is the
	;	user's stack pointer. The area covered by the parameter list
	;	is used to emulate the top of the user's stack.
	;
	;	    When the routine is entered the CALLS instruction saves
	;	the user's registers R0 to R11 in order and saves AP and FP
	;	elsewhere in the frame. The routine extends the saved
	;	registers by saving the user's AP, FP, SP, PC, and PSL after
	;	the saved register area (the last two are taken from the
	;	parameter list).
	;
	;	    The local storage is allocated by extending the stack and
	;	the register modification bytes are cleared (these bytes
	;	record small changes to the register values). The cell MODE
	;	is set equal to the current access mode for use in probing
	;	memory references. The alignment bits in the call frame and 
	;	the call parameter count are also saved so there is a safe
	;	copies to use when processing unwinds.
	;
	;	    Next the instruction starting at PC is examined. If the
	;	first byte can not be read or if the first byte is FD and the
	;	second byte can not be read, then an access violation is
	;	signaled. Otherwise, if the first byte is not FD or if the
	;	first byte is FD and the entry in the table VECTOR indexed
	;	by the second byte is zero then an "opcode reserved to DEC"
	;	condition is signaled. During the scanning of the opcode,
	;	the simulated PC and the change byte for the PC are both
	;	incremented as bytes are examined.
	;
	;	    If we make it through all of the above tests then the
	;	instruction is one we handle and the entry in the table VECTOR
	;	mentioned above is the relative address of the routine for
	;	emulating the instruction. The V bit in the emulated PSL is
	;	cleared to avoid spurious traps and the instruction emulation
	;	routine is entered. Finally, if the trace enable bit is set in
	;	the PSL then the trace pending bit is set so trace interrupts
	;	will not be lost.
	;
	;	Notes:	1. From the description of the way the simulated
	;		   register area is constructed, it is clear that
	;		   the length longword of the parameter list is
	;		   overwritten. All of the methods of leaving the
	;		   Emulator put this longword back together. The
	;		   internal condition handler does this if it 
	;		   detects an unwind.
	;
	;		2. Here are some more details on the register change
	;		   bytes: Until the very end of instruction processing
	;		   when the results are output, all of the changes
	;		   which occur to the registers are caused by adding
	;		   or subtracting small values to or from a register.
	;		   These changes are also recorded in a corresponding 
	;		   register change byte so the register may be 
	;		   restored to its original value if a fault occurs.
	;		   Those instructions that save results in the
	;		   registers in order to be interruptable, use the FPD
	;		   bit in the PSL to indicate that this has been done
	;		   so different logic should be used for restarting
	;		   the instruction after a fault. In this case the 
	;		   change bytes should be cleared when FPD is set
	;		   except for the one for PC.
	;
	;		3. The location of the instruction being emulated is
	;		   stored in the return PC for the Emulator's frame
	;		   so it may be easily located from the traceback
	;		   report if the Emulator blows up.
	;
EMULATOR:				; entrance
	.WORD	^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; entry mask
	MOVAB	LOCAL_START(FP),SP	; allocate the local storage
	EXTZV	#MASK_ALIGN,#2,SAVE_MASK(FP),R0 ; R0 = alignment bits
	MOVB	R0,SAVE_ALIGN(FP)	; save them
	MOVB	#CALL_ARGS,SAVE_PARCNT(FP) ; save the parameter count
	CLRB	FLAGS(FP)		; clear the flag bits
	MOVAB	W^COND_HANDLER,HANDLER(FP) ; set up the condition handler
	CLRQ	REGMOD_R0(FP)		; clear register modification bytes
	CLRQ	REGMOD_R8(FP)		; clear register modification bytes
	MOVQ	SAVE_AP(FP),REG_AP(FP)	; move user's AP and FP into place
	MOVAB	4*<CALL_ARGS+1>(AP),REG_SP(FP) ; move user's SP into place
	MOVQ	4*<CALL_ARGS-1>(AP),REG_PC(FP) ; move PC and PSL into place
	EXTZV	#PSL_CAM,#2,PSL(FP),R0	; R0 = user's access mode
	MOVB	R0,MODE(FP)		; save it for probes
	MOVL	REG_PC(FP),R11		; R11 = location of instruction
	MOVL	R11,SAVE_PC(FP)		; save it in the return PC
	PROBER	MODE(FP),#1,(R11)	; can we read the first byte ?
	BNEQ	1$			; yes - bypass
	MOVL	#1,R10			; R10 = size of the probe
	BSBW	READ_FAULT		; process the access violation
1$:;	CMPB	#^XFD,(R11)		; is the first byte FD ?
;	BNEQ	4$			; no - bypass
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the incrementation
	INCL	R11			; R11 = location of next byte
	PROBER	MODE(FP),#1,(R11)	; can we read the byte ?
	BNEQ	2$			; yes - bypass
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	MOVZBL	(R11),R0		; R0 = second instruction byte
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the incrementation
	CVTWL	W^VECTOR[R0],R0 	; R0 = instruction routine postion
	BEQL	4$			; the value is zero - bypass
	BICL2	#PSLM_V,PSL(FP) 	; clear the V bit in the PSL
	BBC	#PSL_T,PSL(FP),3$	; the trace enable bit is clear - skip
	BBSS	#PSL_TP,PSL(FP),3$	; set the trace enable bit
3$:	JMP	W^VECTOR[R0]		; enter the routine
4$:	BRW	OPCODE_FAULT		; process the reserved opcode
	;

	;
	;	NORMAL_EXIT - Normal End of Instruction Emulation
	;
	;		entered by branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine restores control to the user program whenever
	;	the emulation ends without causing an exception. First the V
	;	and IV bits in the user's PSL are checked. If they are both 
	;	set then an integer overflow trap is signaled. When the
	;	Emulator returns, all of the registers, PC, and the PSL are
	;	set to the emulated values.
	;
	;	    The method of leaving the Emulator consists of pushing the
	;	user's PC and PSL onto the user's stack putting the saved AP
	;	and FP back in their proper places in the frame and performing
	;	the indicated adjustment so that when a RET instruction is
	;	executed all of the registers up to FP will be restored and
	;	the stack pointer will be positioned to the PC, PSL pair.
	;
	;	    At this point, a speed optimization is performed.  If the
	;	next instruction is also one we emulate, then we can bypass the
	;	overhead for the reserved opcode fault and exception 
	;	dispatching by merely looping back to the beginning of the
	;	emulator.  After the RET restores all registers, the stack
	;	contains the PC/PSL pair for the next instruction.  The PSL is
	;	examined to see if the T-bit is set.  If so, we can't do the
	;	optimization.  If T is clear, we then examine the next opcode.
	;	If it is one which we emulate, a branch is made to EMULATE$
	;	to begin emulation of the next instruction.  Note that the
	;	"arguments" to EMULATE$, a PC/PSL pair, are already in place!
	;
	;	If the optimization can not be performed, an REI is executed
	;	which restores the PC and PSL for the next instruction.
	;
NORMAL_EXIT:				; entrance
	BBC	#PSL_V,PSL(FP),1$	; no integer overflow - bypass
	BBC	#PSL_IV,PSL(FP),1$	; no integer overflow trap - skip
	BRW	INT_OVERFLOW		; process the integer overflow trap
1$:	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVL	#8,R0			; R0 = size of PC, PSL pair
	BSBB	TEST_FRAME		; make sure we have room to push it
	SUBL2	#8,REG_SP(FP)		; allocate room on the user's stack
	MOVQ	REG_PC(FP),@REG_SP(FP)	; push the PC, PSL pair
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put the user's PC, PSL pair back
	MOVAB	B^2$,SAVE_PC(FP)	; store our return point
	MOVAB	FRAME_END+4(FP),R0	; R0 = location of end of frame
	SUBL3	R0,REG_SP(FP),R1	; R1 = distance of user SP from it
	EXTZV	#0,#2,R1,R2		; R2 = stack alignment
	INSV	R2,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store it into the frame
	ADDL2	R2,R0			; compute the parameter area location
	ASHL	#-2,R1,-4(R0)		; store the parameter count
	RET				; return (to next instruction)

;+
; Perform instruction lookahead for speed optimization.
; At this point, 0(SP) contains the PC of the next user instruction, 4(SP)
; has the user PSL.
;-

2$:	BBS	#PSL_T, 4(SP), 4$	; If T-bit set, don't do lookahead
	PUSHL	R0			; Save R0 temporarily
	EXTZV	#PSL_CAM, #2, 8(SP), R0	; Get current access mode in R0
	PROBER	R0, #2, @4(SP)		; Can we read the next TWO bytes?
	BEQL	3$			; If not, just return
	CMPB	@4(SP), #^XFD		; Is the first byte FD?
	BNEQ	3$			; If not, return
	MOVL	4(SP), R0		; Get instruction address
	MOVZBL	1(R0), R0		; Get second instruction byte
	TSTW	W^VECTOR[R0]		; Do we handle this instruction?
	BEQL	3$			; If not, return
	MOVL	(SP)+, R0		; Restore saved R0
	BRW	EMULATE$		; Take the shortcut
3$:	MOVL	(SP)+, R0		; Restore saved R0
4$:	REI				; Return to the next user instruction
	;

	;
	;	TEST_FRAME - Test Frame Location and Move If Necessary
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = Size of Information to be Pushed
	;
	;		returns with	R0 = Distance Frame was Moved
	;
	;	Discussion
	;
	;	    This routine determines whether or not the address given
	;	by subtracting R0 from the user's stack pointer can be made
	;	the location following a parameter list without the location
	;	being within the local storage. If this cannot be done then
	;	the entire procedure frame is moved so the condition can be
	;	satisfied. The distance that the procedure frame was moved
	;	is returned in R0. The value is zero if the frame is not 
	;	moved.
	;
	;	Note:	1. The switch from one frame location to another is
	;		   performed by a single indivisible POPR instruction
	;		   so the Emulator is never in an anomalous state.
	;
	;		2. If the frame is moved to a higher address, then
	;		   the saved AP and FP are changed to the values of
	;		   the emulated registers. The reason for this is
	;		   that the move may overlay a valid frame so it is
	;		   assumed that the user's AP and FP have been changed
	;		   by the instruction to information about a new valid
	;		   frame. The implementor thinks that all of this is
	;		   pretty strange but if the program will work with
	;		   the hardware it will still work with the Emulator.
	;
TEST_FRAME:				; entrance
	PUSHL	#0			; push a zero
	SUBL3	R0,REG_SP(FP),R0	; compute pushed information address
	BICL2	#3,R0			; align the value
	MOVAB	LOCAL_END(FP),R1	; R1 = end of local storage
	CMPL	R0,R1			; does push extend below the frame ?
	BGEQU	2$			; no - bypass
	BICL3	#3,SP,R3		; R3 = aligned stack pointer
	SUBL2	#24,R3			; adjust for additional pushes
	MOVL	R0,R2			; R2 = address following moved frame
	CMPL	R2,R3			; does it extend into the frame ?
	BLEQU	3$			; no - bypass
	MOVL	R3,R2			; yes - use address below the frame
	BRB	3$			; bypass
2$:	MOVAB	FRAME_END+1027(FP),R2	; R2 = last possible parameter end
	CMPL	R0,R2			; does the push end above it ?
	BLEQU	5$			; no - bypass
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; change the saved AP and FP
	BICL3	#3,R0,R2		; R2 = aligned user stack pointer
3$:	SUBL2	R1,R2			; R2 = distance of the move
	PUSHL	R2			; push the quantity
	PUSHAB	(SP)[R2]		; push the modified SP
	PUSHAB	(FP)[R2]		; push the modified FP
	PUSHAB	(AP)[R2]		; push the modified AP
	PUSHAB	SAVE_ALIGN(FP)[R2]	; push the new alignment bits location
	PUSHAB	SAVE_PARCNT(FP)[R2]	; push the new parameter count address
	MOVAB	FRAME_END+4(FP)[R2],R3	; R3 = new frame end + 4 location
	SUBL3	R3,R0,R3		; R3 = distance to user's SP
	ASHL	#-2,R3,-(SP)		; push the new parameter count
	SUBL3	SP,R1,R0		; R0 = number of bytes to move
	MOVL	SP,R1			; R1 = location of bytes to move
	TSTL	R2			; will we extend the stack ?
	BGEQ	4$			; no - skip
	ADDL2	R2,SP			; yes - extend the stack pointer
4$:	MOVC3	R0,(R1),(R1)[R2]	; move the frame
	CVTLB	(SP)+,@(SP)+		; store the new parameter count
	CLRB	@(SP)+			; clear the new alignment bits
	POPR	#^M<AP,FP,SP>		; switch to the new frame
5$:	POPR	#^M<R0>			; R0 = distance frame was moved
	RSB				; return
	;

	;
	;	COND_HANDLER - Internal Condition Handler
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;	
	;	    This routine is the internal condition handler for the
	;	Emulator. Since the Emulator does not make constructive use
	;	of exceptions in its main procedure, this routine requests 
	;	resignaling of all conditions it intercepts.
	;
	;	    If the condition is SS$_UNWIND which indicates that an
	;	unwind is about to take place, then it restores the argument
	;	count longword in the parameter list for the procedure so the
	;	unwind will work properly.
	;
COND_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0,R1 = condition array locations
	CMPCOND	SS$_UNWIND,4(R0)	; is this an unwind ?
	BNEQ	1$			; no - bypass
	MOVL	4(R1),R0		; R0 = frame location
	MOVB	SAVE_ALIGN(R0),R1	; R1 = safe copy of alignment bits
	MOVZBL	SAVE_PARCNT(FP),-(SP)	; push the argument count
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(R0) ; store align bits in frame
	ADDL2	R1,R0			; add to the frame location
	MOVL	(SP)+,FRAME_END(R0)	; store the argument count
1$:	MOVZWL	#SS$_RESIGNAL,R0	; resignal the condition
	RET				; return
	;

	;
	;	VECTOR - Instruction Handling Routine Vector
	;
	;	Discussion
	;
	;	    The following table contains the relative addresses of
	;	the routines which process the emulated instructions. The 
	;	table is indexed by the second byte of the opcode (the first
	;	byte being assumed to be FD). The address is relative to the
	;	start of the table at VECTOR. An entry is zero if the it
	;	corresponds to an nonexistant instruction or an instruction
	;	that is not emulated. This table is only used in the routines
	;	EMULATE$HANDLER and EMULATOR. In both routines it is used to
	;	check the validity of opcodes and in the second routine it is
	;	used for performing the branch to the emulation routine.
	;
VECTOR: .WORD	0			; 00FD
	.WORD	0			; 01FD
	.WORD	0			; 02FD
	.WORD	0			; 03FD
	.WORD	0			; 04FD
	.WORD	0			; 05FD
	.WORD	0			; 06FD
	.WORD	0			; 07FD
	.WORD	0			; 08FD
	.WORD	0			; 09FD
	.WORD	0			; 0AFD
	.WORD	0			; 0BFD
	.WORD	0			; 0CFD
	.WORD	0			; 0DFD
	.WORD	0			; 0EFD
	.WORD	0			; 0FFD
	.WORD	0			; 10FD
	.WORD	0			; 11FD
	.WORD	0			; 12FD
	.WORD	0			; 13FD
	.WORD	0			; 14FD
	.WORD	0			; 15FD
	.WORD	0			; 16FD
	.WORD	0			; 17FD
	.WORD	0			; 18FD
	.WORD	0			; 19FD
	.WORD	0			; 1AFD
	.WORD	0			; 1BFD
	.WORD	0			; 1CFD
	.WORD	0			; 1DFD
	.WORD	0			; 1EFD
	.WORD	0			; 1FFD
	.WORD	0			; 20FD
	.WORD	0			; 21FD
	.WORD	0			; 22FD
	.WORD	0			; 23FD
	.WORD	0			; 24FD
	.WORD	0			; 25FD
	.WORD	0			; 26FD
	.WORD	0			; 27FD
	.WORD	0			; 28FD
	.WORD	0			; 29FD
	.WORD	0			; 2AFD
	.WORD	0			; 2BFD
	.WORD	0			; 2CFD
	.WORD	0			; 2DFD
	.WORD	0			; 2EFD
	.WORD	0			; 2FFD
	.WORD	0			; 30FD
	.WORD	0			; 31FD
	.WORD	INST_CVTDH-VECTOR	; 32FD CVTDH
	.WORD	INST_CVTGF-VECTOR	; 33FD CVTGF
	.WORD	0			; 34FD
	.WORD	0			; 35FD
	.WORD	0			; 36FD
	.WORD	0			; 37FD
	.WORD	0			; 38FD
	.WORD	0			; 39FD
	.WORD	0			; 3AFD
	.WORD	0			; 3BFD
	.WORD	0			; 3CFD
	.WORD	0			; 3DFD
	.WORD	0			; 3EFD
	.WORD	0			; 3FFD
	.WORD	INST_ADDG2-VECTOR	; 40FD ADDG2
	.WORD	INST_ADDG3-VECTOR	; 41FD ADDG3
	.WORD	INST_SUBG2-VECTOR	; 42FD SUBG2
	.WORD	INST_SUBG3-VECTOR	; 43FD SUBG3
	.WORD	INST_MULG2-VECTOR	; 44FD MULG2
	.WORD	INST_MULG3-VECTOR	; 45FD MULG3
	.WORD	INST_DIVG2-VECTOR	; 46FD DIVG2
	.WORD	INST_DIVG3-VECTOR	; 47FD DIVG3
	.WORD	INST_CVTGB-VECTOR	; 48FD CVTGB
	.WORD	INST_CVTGW-VECTOR	; 49FD CVTGW
	.WORD	INST_CVTGL-VECTOR	; 4AFD CVTGL
	.WORD	INST_CVTRGL-VECTOR	; 4BFD CVTRGL
	.WORD	INST_CVTBG-VECTOR	; 4CFD CVTBG
	.WORD	INST_CVTWG-VECTOR	; 4DFD CVTWG
	.WORD	INST_CVTLG-VECTOR	; 4EFD CVTLG
	.WORD	INST_ACBG-VECTOR	; 4FFD ACBG
	.WORD	INST_MOVG-VECTOR	; 50FD MOVG
	.WORD	INST_CMPG-VECTOR	; 51FD CMPG
	.WORD	INST_MNEGG-VECTOR	; 52FD MNEGG
	.WORD	INST_TSTG-VECTOR	; 53FD TSTG
	.WORD	INST_EMODG-VECTOR	; 54FD EMODG
	.WORD	INST_POLYG-VECTOR	; 55FD POLYG
	.WORD	INST_CVTGH-VECTOR	; 56FD CVTGH
	.WORD	0			; 57FD
	.WORD	0			; 58FD
	.WORD	0			; 59FD
	.WORD	0			; 5AFD
	.WORD	0			; 5BFD
	.WORD	0			; 5CFD
	.WORD	0			; 5DFD
	.WORD	0			; 5EFD
	.WORD	0			; 5FFD
	.WORD	INST_ADDH2-VECTOR	; 60FD ADDH2
	.WORD	INST_ADDH3-VECTOR	; 61FD ADDH3
	.WORD	INST_SUBH2-VECTOR	; 62FD SUBH2
	.WORD	INST_SUBH3-VECTOR	; 63FD SUBH3
	.WORD	INST_MULH2-VECTOR	; 64FD MULH2
	.WORD	INST_MULH3-VECTOR	; 65FD MULH3
	.WORD	INST_DIVH2-VECTOR	; 66FD DIVH2
	.WORD	INST_DIVH3-VECTOR	; 67FD DIVH3
	.WORD	INST_CVTHB-VECTOR	; 68FD CVTHB
	.WORD	INST_CVTHW-VECTOR	; 69FD CVTHW
	.WORD	INST_CVTHL-VECTOR	; 6AFD CVTHL
	.WORD	INST_CVTRHL-VECTOR	; 6BFD CVTRHL
	.WORD	INST_CVTBH-VECTOR	; 6CFD CVTBH
	.WORD	INST_CVTWH-VECTOR	; 6DFD CVTWH
	.WORD	INST_CVTLH-VECTOR	; 6EFD CVTLH
	.WORD	INST_ACBH-VECTOR	; 6FFD ACBH
	.WORD	INST_MOVH-VECTOR	; 70FD MOVH
	.WORD	INST_CMPH-VECTOR	; 71FD CMPH
	.WORD	INST_MNEGH-VECTOR	; 72FD MNEGH
	.WORD	INST_TSTH-VECTOR	; 73FD TSTH
	.WORD	INST_EMODH-VECTOR	; 74FD EMODH
	.WORD	INST_POLYH-VECTOR	; 75FD POLYH
	.WORD	INST_CVTHG-VECTOR	; 76FD CVTHG
	.WORD	0			; 77FD
	.WORD	0			; 78FD
	.WORD	0			; 79FD
	.WORD	0			; 7AFD
	.WORD	0			; 7BFD
	.WORD	INST_CLRO-VECTOR	; 7CFD CLRO or CLRH
	.WORD	INST_MOVO-VECTOR	; 7DFD MOVO
	.WORD	INST_MOVAO-VECTOR	; 7EFD MOVAO or MOVAH
	.WORD	INST_PUSHAO-VECTOR	; 7FFD PUSHAO or PUSHAH
	.WORD	0			; 80FD
	.WORD	0			; 81FD
	.WORD	0			; 82FD
	.WORD	0			; 83FD
	.WORD	0			; 84FD
	.WORD	0			; 85FD
	.WORD	0			; 86FD
	.WORD	0			; 87FD
	.WORD	0			; 88FD
	.WORD	0			; 89FD
	.WORD	0			; 8AFD
	.WORD	0			; 8BFD
	.WORD	0			; 8CFD
	.WORD	0			; 8DFD
	.WORD	0			; 8EFD
	.WORD	0			; 8FFD
	.WORD	0			; 90FD
	.WORD	0			; 91FD
	.WORD	0			; 92FD
	.WORD	0			; 93FD
	.WORD	0			; 94FD
	.WORD	0			; 95FD
	.WORD	0			; 96FD
	.WORD	0			; 97FD
	.WORD	INST_CVTFH-VECTOR	; 98FD CVTFH
	.WORD	INST_CVTFG-VECTOR	; 99FD CVTFG
	.WORD	0			; 9AFD
	.WORD	0			; 9BFD
	.WORD	0			; 9CFD
	.WORD	0			; 9DFD
	.WORD	0			; 9EFD
	.WORD	0			; 9FFD
	.WORD	0			; A0FD
	.WORD	0			; A1FD
	.WORD	0			; A2FD
	.WORD	0			; A3FD
	.WORD	0			; A4FD
	.WORD	0			; A5FD
	.WORD	0			; A6FD
	.WORD	0			; A7FD
	.WORD	0			; A8FD
	.WORD	0			; A9FD
	.WORD	0			; AAFD
	.WORD	0			; ABFD
	.WORD	0			; ACFD
	.WORD	0			; ADFD
	.WORD	0			; AEFD
	.WORD	0			; AFFD
	.WORD	0			; B0FD
	.WORD	0			; B1FD
	.WORD	0			; B2FD
	.WORD	0			; B3FD
	.WORD	0			; B4FD
	.WORD	0			; B5FD
	.WORD	0			; B6FD
	.WORD	0			; B7FD
	.WORD	0			; B8FD
	.WORD	0			; B9FD
	.WORD	0			; BAFD
	.WORD	0			; BBFD
	.WORD	0			; BCFD
	.WORD	0			; BDFD
	.WORD	0			; BEFD
	.WORD	0			; BFFD
	.WORD	0			; C0FD
	.WORD	0			; C1FD
	.WORD	0			; C2FD
	.WORD	0			; C3FD
	.WORD	0			; C4FD
	.WORD	0			; C5FD
	.WORD	0			; C6FD
	.WORD	0			; C7FD
	.WORD	0			; C8FD
	.WORD	0			; C9FD
	.WORD	0			; CAFD
	.WORD	0			; CBFD
	.WORD	0			; CCFD
	.WORD	0			; CDFD
	.WORD	0			; CEFD
	.WORD	0			; CFFD
	.WORD	0			; D0FD
	.WORD	0			; D1FD
	.WORD	0			; D2FD
	.WORD	0			; D3FD
	.WORD	0			; D4FD
	.WORD	0			; D5FD
	.WORD	0			; D6FD
	.WORD	0			; D7FD
	.WORD	0			; D8FD
	.WORD	0			; D9FD
	.WORD	0			; DAFD
	.WORD	0			; DBFD
	.WORD	0			; DCFD
	.WORD	0			; DDFD
	.WORD	0			; DEFD
	.WORD	0			; DFFD
	.WORD	0			; E0FD
	.WORD	0			; E1FD
	.WORD	0			; E2FD
	.WORD	0			; E3FD
	.WORD	0			; E4FD
	.WORD	0			; E5FD
	.WORD	0			; E6FD
	.WORD	0			; E7FD
	.WORD	0			; E8FD
	.WORD	0			; E9FD
	.WORD	0			; EAFD
	.WORD	0			; EBFD
	.WORD	0			; ECFD
	.WORD	0			; EDFD
	.WORD	0			; EEFD
	.WORD	0			; EFFD
	.WORD	0			; F0FD
	.WORD	0			; F1FD
	.WORD	0			; F2FD
	.WORD	0			; F3FD
	.WORD	0			; F4FD
	.WORD	0			; F5FD
	.WORD	INST_CVTHF-VECTOR	; F6FD CVTHF
	.WORD	INST_CVTHD-VECTOR	; F7FD CVTHD
	.WORD	0			; F8FD
	.WORD	0			; F9FD
	.WORD	0			; FAFD
	.WORD	0			; FBFD
	.WORD	0			; FCFD
	.WORD	0			; FDFD
	.WORD	0			; FEFD
	.WORD	0			; FFFD
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		Instruction Emulation Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    Following are the routines for emulating the individual 
	;	new instructions. There is one routine for each instruction
	;	but the structure of most of these routines is extremely
	;	simple so we have included all of the descriptive information
	;	here rather than duplicating it for each routine. Special
	;	discussions are given for those instructions or families of
	;	instructions which do not quite fit into the general patterns.
	;
	;	    The routines themselves have been written so that they
	;	will be easy to follow. Because of this the temptation to
	;	remove a considerable amount of duplicated code has been
	;	staunchly resisted.
	;
	;	    The emulation routines have names which are of the form
	;	"INST_mnemonic", are entered by branching from the routine
	;	EMULATOR, and when instruction is complete the routines branch
	;	to NORMAL_EXIT. When exceptions occur, then flow of control is
	;	somewhat more complicated and is described below.
	;
	;
	;	Operand Processing
	;	------------------
	;
	;	    The first step for each of the instructions is to process
	;	the instruction operands (this process is inhibited only for
	;	POLYG and POLYH when FPD is set in the PSL). This is done by
	;	calling the operand scanning routines for each operand and by
	;	saving the operands values (for read and modify access
	;	operands) and operand addresses (for write, modify, and 
	;	address, access operands) in the special areas of the frame
	;	allocated for that purpose. Floating values of all types that
	;	are input are converted to our internal floating format by the
	;	UNPACK routines which are described below.
	;
	;
	;	Instruction Emulation
	;	---------------------
	;
	;	    After all of the operands have been processed, the action
	;	of the instruction is performed usually by calling one of the
	;	arithmetic routines. For many of the move and convert 
	;	instructions no special emulation action is necessary since
	;	everything is done by the PACK and UNPACK routines. All of the
	;	floating arithmetic is performed using our internal floating
	;	representation.
	;
	;
	;	Storing the Results
	;	-------------------
	;
	;	    The last step of instruction emulation is storing the
	;	resulting values and updating the condition codes. The values
	;	are stored in the order in which their corresponding operands
	;	occur so the instruction is emulated properly when the write
	;	or modify access operands overlap. Floating values are 
	;	converted from the internal floating representation to the
	;	target representation by one of the PACK routines described
	;	below. After the results are output, the condition codes in
	;	the emulated PSL are updated. This order of operation is 
	;	important since the PACK routines may convert very small
	;	nonzero values to zero values if an underflow occurs and FU is
	;	clear in the PSL. When the instruction emulation is complete
	;	the routine branches to NORMAL_EXIT.
	;
	;
	;	Exceptions
	;	----------
	;
	;	    Except for the integer overflow trap, all of the 
	;	exceptions that the Emulator checks for are faults. When
	;	faults occur the Emulator restores everything to a state in
	;	which the instruction can be restarted and signals the fault.
	;	For the integer overflow trap, the instruction is run to
	;	completion, possibly outputing a truncated result, and the
	;	trap is signaled. Here we describe how instruction emulation
	;	is organized so this can be accomplished. Further information
	;	can be found in the essay on exception processing which 
	;	appears below.
	;
	;
	;	Faults
	;
	;	    Until the results of an instruction are output, all of the
	;	changes which take place to any register are additions and 
	;	subtractions of small integers. These changes are also 
	;	recorded in the change bytes corresponding to the registers.
	;	Therefore the only requirement necessary for correct fault
	;	processing is to insure that all fault detection takes place
	;	before any of the instruction results are output (actually,
	;	things are a little more complicated for POLYG and POLYH).
	;	This is done by making the result outputing steps the last
	;	part of instruction emulation. In this way fault detection
	;	can be placed anywhere in the Emulator it is convenient rather
	;	than requiring close synchronization with the instruction
	;	emulation logic. For this reason direct processing of faults
	;	(rather than, say, returning status codes) appears throughout
	;	the common Emulator subroutines.
	;
	;	    The architecture makes no special requirements on the
	;	the condition codes generated by a fault except that they
	;	be sufficient for correctly restarting the instruction. In
	;	general, the V bit is cleared by EMULATOR on entry to an
	;	instruction emulation routine since the bit is used for
	;	detecting integer overflow traps (see below). None of the
	;	other condition bits is altered until the results are output
	;	at the end of instruction emulation. Consequently all of the
	;	other condition bits are preserved into faults. (With the
	;	present set of emulated instructions the only preservation
	;	requirement is that the C bit be preserved on faults by the
	;	ACBG and ACBH instructions.)
	;
	;
	;	Integer Overflow Traps
	;
	;	    When a integer overflow is detected (either in a common
	;	subroutine or in the instruction emulation routine) the V
	;	bit is set in the emulated condition codes and the value is
	;	truncated. Everything proceeds normally until control reaches
	;	NORMAL_EXIT where the V and IV bits in the emulated PSL are
	;	checked. If both are set then an integer overflow trap is
	;	signaled.
	;
	;
	;	Access Modes and Access Violations
	;
	;	    This version of the Emulator has been designed to operate
	;	at the same access mode as the instruction being emulated.
	;	However most of the instruction emulation logic has been 
	;	designed to operate at any access mode that is not less 
	;	privleged than that of the instruction (exceptions: the logic
	;	for getting in, the logic for getting out, and the exception
	;	signaling logic). All attempts to access memory on behalf of
	;	the instruction are probed using the access mode contained in
	;	the local cell MODE. This is normally set to the current 
	;	access mode but may be set to some less privleged access mode.
	;	Because this version of the Emulator operates on the user
	;	stack it is not necessary to probe stack operations, however,
	;	these probes are still done to insure that the code will 
	;	remain usable for different access modes.
	;
	;
	;	Notes on the ACBG and ACBH Instructions
	;	---------------------------------------
	;
	;	    For these instructions the operands are processed, the
	;	step is added to the index, and the sum is packed and output.
	;	Afterwards the sum is unpacked again and compared with the
	;	limit, the type of comparison depending on the sign of the
	;	step. The packing and unpacking is necessary to truncate the
	;	sum to the correct number of bits, to perform any rounding,
	;	and to check for underflow or overflow exceptions. If the
	;	branch is to be taken, the branch destination is moved into
	;	the emulated PC.
	;
	;
	;	Notes on the EMODG and EMODH Instructions
	;	-----------------------------------------
	;
	;	    For these instructions the first two operands are a 
	;	floating value of the appropriate type and a word containing
	;	some extension bits. When the extension bits are picked up
	;	they are stored in the correct position of the unpacked first
	;	operand. The remaining operands are scanned and flag bits 1
	;	and 7 are used to remember which output operands are in the
	;	registers. The multiply is then performed using the proper
	;	arithmetic routine and the product is truncated to the correct
	;	number of bits. Next the integer part is extracted and saved
	;	in an internal cell while the fraction part is extracted and
	;	packed. Next any register output operands are output and
	;	the routine TEST_FRAME is called to insure that the user's 
	;	stack pointer is within the parameter area. Next any output
	;	operands in memory are output with stores into the Emulator's
	;	working storage disabled .If both output operands are in the
	;	same type of storage, then the integer part is output before
	;	the fraction part. This complicated method of outputing the
	;	results is necessary because one of the register operands may
	;	contain SP and extend the user's stack into the Emulator's
	;	working storage. The call to TEST_FRAME will move the frame
	;	if this occurs so if the other operand will be stored into
	;	memory properly if it is not below the user's stack pointer.
	;
	;
	;	Notes on the POLYG and POLYH Instructions
	;	-----------------------------------------
	;
	;	    These instructions have especially complicated emulation
	;	routines because they do a lot, have a large number of 
	;	implicit inputs and outputs, and are intended to be resumed
	;	instead of restarted when faults occur. For this reason we
	;	describe the action of the instruction emulation routines in
	;	some detail.
	;
	;	    These instructions can be thought as having two states.
	;	In the first of these states no unreversable changes have 
	;	been made to the registers so if a fault occurs the 
	;	instruction can be restarted. The instruction remains in this
	;	state until all of the operands have been processed and the
	;	first coefficient has been validated. After this point the
	;	instruction saves various things in the registers R0-R6 (and
	;	on the stack for POLYH) so the instruction can no longer be
	;	restarted but the information saved is sufficient for resuming
	;	the instruction after a fault. When this second state is
	;	reached the FPD bit is set in the PSL so the when the 
	;	instruction emulation routine is entered for resuming the 
	;	instruction it will know enough to do so.
	;
	;	    Following is an outline of the steps in the emulation of
	;	the two instructions. The text generally describes POLYG and
	;	the differences for POLYH are noted in parentheses.
	;
	;
	;	     1. This is the first step for the instruction emulation.
	;		If the FPD bit is clear in the PSL then control passes
	;		to Step 2. Otherwise the following actions which are
	;		concerned with restarting the instruction take place:
	;
	;		The length of the instruction operands is retrieved 
	;		from the high order three bytes of the user's R2 (R4
	;		for POLYH) and added to the current PC and to the 
	;		change byte for the PC. If the instruction terminates
	;		the PC will be positioned following the instruction
	;		and if the instruction faults it will be reset to the
	;		location of the instruction.
	;
	;		The result so far is unpacked from R0-R1 (R0-R3 for
	;		POLYH) and the unpacked value is stored in OPERAND2.
	;		The condition codes are set to describe this value.
	;
	;		The argument is unpacked from R4-R5 (from a stacked
	;		octaword for POLYH, which is probed) and the unpacked
	;		value is stored in OPERAND3.
	;
	;		The remaining coefficient count in the low order byte
	;		of R2 (R4 for POLYH) is checked for validity.
	;
	;		Finally control passes to Step 3.
	;
	;
	;	     2. This step performs all of the processing for initial
	;		entry to the instruction.
	;
	;		The first operand is processed and the unpacked
	;		argument is saved in OPERAND3.
	;
	;		The second operand is processed and the degree is 
	;		checked for validity and the value is saved 
	;		temporarily in ADDRESS1.
	;
	;		The third operand is processed and the address of the
	;		coefficient table is saved. The first coefficient is
	;		probed, unpacked, and saved in OPERAND2.
	;
	;		If the instruction is POLYH then the user's SP is 
	;		decremented by 16 (and so is the change byte) and
	;		the argument value in OPERAND3 is packed and output
	;		to the allocated stack area. (If a fault occurs before
	;		FPD is set then SP will be reinitilized properly.)
	;
	;		The coefficient in OPERAND2 is packed and stored in
	;		the user's registers R0-R1 (R0-R4 for POLYH), the
	;		address of the remaining coefficients is stored in the
	;		user's R4 (R6 for POLYH), the degree is stored in the
	;		low order byte of the user's R2 (R4 for POLYH), and
	;		the length of the instruction operands (the PC change
	;		byte minus two) is saved in the upper three bytes of
	;		that register. The condition codes are set based on
	;		the value in OPERAND2.
	;
	;		All of the change bytes except that for PC are cleared
	;		and the bit FPD is set in the emulated PSL.
	;
	;		If the instruction is POLYG then the argument in
	;		OPERAND3 is packed and saved in the user's R4-R5.
	;
	;		Control Passes to Step 3.
	;
	;
	;	     3. This step performs the basic polynomial evaluation 
	;		iteration.
	;
	;		If the remaining coefficient count in the low order
	;		byte of the user's R2 (R4 for POLYH) is zero then 
	;		control passes to Step 4.
	;	
	;		The value so far in OPERAND2 and the argument in
	;		OPERAND3 are multiplied and the unnormalized product
	;		is truncated to 63 (127 for POLYH) bits and stored
	;		in OPERAND1. The truncation is performed by clearing
	;		the low order bit of the 64 (128 for POLYH) bit
	;		product returned by the multiply routine.
	;
	;		The coefficient addressed by the user's R3 (R5 for 
	;		POLYH) is probed and unpacked to OPERAND2. The result
	;		is then added to OPERAND1.
	;
	;		The new value so far in OPERAND1 is packed and stored
	;		in the user's R0-R1 (R0-R3 for POLYH). The condition
	;		codes are set based on this value. The value is then
	;		unpacked and stored in OPERAND2.
	;
	;		The remaining coefficient count in the low order byte
	;		of R2 (R4 for POLYH) is decremented and the pointer to
	;		the next coeffiecient in R3 (R5 for POLYH) is
	;		incremented to point to the next coefficient.
	;
	;		Control then passes to the beginning of this step.
	;
	;
	;	     4. This step performs the termination of the instruction.
	;
	;		The register R2 (R4 for POLYH) which contains the
	;		instruction length and the coefficient count is
	;		cleared.
	;
	;		If the instruction was POLYG then the registers R4-R5
	;		which contained the argument value are cleared.
	;
	;		If the instruction was POLYH then the user's SP is
	;		incremented by 16 to unstack the argument.
	;
	;		The FPD bit in the PSL is cleared.
	;
	;		Instruction emulation is now complete.
	;
	;
	;	    Careful reading of the above outline will show that the
	;	POLYG and POLYH instructions are correctly emulated even down
	;	to the handling of faults. Faults may be detected at any of
	;	the probes and at some of the pack and unpack operations. When
	;	faults are detected control immediatly leaves the outline so
	;	it is important that everything be correct at the time the 
	;	check is made. The reader may notice that some results are
	;	packed and then immediatly unpacked. This is done to check for
	;	overflow and underflow and to perform any rounding specified
	;	by the architecture. This technique also converts nonstandard
	;	floating zero representations to standard ones.
	;

	;
	;	4FFD ACBG - Add Compare and Branch Grand
	;
INST_ACBG:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND3		; unpack and save the value
	BSBW	READ_GRAND		; second operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	MODIFY_GRAND		; third operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the operand address
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	BRANCH_WORD		; fourth operand is displacement
	MOVL	R11,ADDRESS2(FP)	; save the branch destination
	BSBW	ADD_REAL		; add the step and index
	BSBW	PACK_GRAND1		; pack the index value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	UNPACK_GRAND1		; put the value back
	MOVAB	OPERAND1(FP),R1 	; R1 = location of index value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICB2	#PSLM_V,PSL(FP) 	; clear V in the PSL
	MOVAB	OPERAND2(FP),R1 	; R1 = address of step value
	BSBW	TEST_REAL		; test the value
	BLSS	2$			; it's negative - bypass
	MOVAB	OPERAND1(FP),R1 	; R1 = address of index value
	MOVAB	OPERAND3(FP),R2 	; R2 = address of limit value
	BSBW	COMPARE_REAL		; have we passed the limit ?
	BGTR	3$			; yes - bypass
1$:	MOVL	ADDRESS2(FP),REG_PC(FP) ; perform the branch
	BRB	3$			; bypass
2$:	MOVAB	OPERAND1(FP),R1 	; R1 = address of index value
	MOVAB	OPERAND3(FP),R2 	; R2 = address of limit value
	BSBW	COMPARE_REAL		; have we passed the limit ?
	BGEQ	1$			; no - perform the branch
3$:	BRW	NORMAL_EXIT		; done
	;
	;	6FFD ACBH - Add Compare and Branch Huge
	;
INST_ACBH:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE3		; unpack and save the value
	BSBW	READ_HUGE		; second operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	MODIFY_HUGE		; third operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the operand address
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	BRANCH_WORD		; fourth operand is branch destination
	MOVL	R11,ADDRESS2(FP)	; save the branch destination
	BSBW	ADD_REAL		; add the step and index
	BSBW	PACK_HUGE1		; pack the index value
	MOVL	ADDRESS1(FP),R11	; R11 = destination address
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	UNPACK_HUGE1		; put the value back
	MOVAB	OPERAND1(FP),R1 	; R1 = location of index value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICB2	#PSLM_V,PSL(FP) 	; clear V in the PSL
	MOVAB	OPERAND2(FP),R1 	; R1 = address of step value
	BSBW	TEST_REAL		; test the value
	BLSS	2$			; it's negative - bypass
	MOVAB	OPERAND1(FP),R1 	; R1 = address of index value
	MOVAB	OPERAND3(FP),R2 	; R2 = address of limit value
	BSBW	COMPARE_REAL		; have we passed the limit ?
	BGTR	3$			; yes - bypass
1$:	MOVL	ADDRESS2(FP),REG_PC(FP) ; perform the branch
	BRB	3$			; bypass
2$:	MOVAB	OPERAND1(FP),R1 	; R1 = address of index value
	MOVAB	OPERAND3(FP),R2 	; R2 = address of limit value
	BSBW	COMPARE_REAL		; have we passed the limit ?
	BGEQ	1$			; no - perform the branch
3$:	BRW	NORMAL_EXIT		; done
	;
	;	40FD ADDG2 - Add Grand (Two Operands)
	;
INST_ADDG2:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	MODIFY_GRAND		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_GRAND1		; pack the sum
	MOVQ	R0,@ADDRESS1(FP)	; output the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	41FD ADDG3 - Add Grand (Three Operands)
	;
INST_ADDG3:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	READ_GRAND		; second operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	WRITE_GRAND		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination address
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_GRAND1		; pack the sum
	MOVQ	R0,@ADDRESS1(FP)	; output the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	60FD ADDH2 - Add Huge (Two Operands)
	;
INST_ADDH2:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	MODIFY_HUGE		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_HUGE1		; pack the sum
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	61FD ADDH3 - Add Huge (Three Operands)
	;
INST_ADDH3:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	READ_HUGE		; second operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	WRITE_HUGE		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination address
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_HUGE1		; pack the sum
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	7CFD CLRO - Clear Octaword
	;
	;	7CFD CLRH - Clear Huge
	;
INST_CLRO:				; entrance
	BSBW	WRITE_OCTA		; first operand is write only
	CLRQ	(R11)+			; clear the first part of the value
	CLRQ	(R11)			; clear the second part of the value
	BICL2	#PSLM_NZV,PSL(FP)	; clear the condition codes except C
	BISL2	#PSLM_Z,PSL(FP) 	; set the Z bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	51FD CMPG - Compare Grand
	;
INST_CMPG:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	READ_GRAND		; second operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the value
	MOVAB	OPERAND1(FP),R1 	; R1 = location of first value
	MOVAB	OPERAND2(FP),R2 	; R2 = location of second value
	BSBW	COMPARE_REAL		; compare the values
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	71FD CMPH - Compare Huge
	;
INST_CMPH:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	READ_HUGE		; second operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the value
	MOVAB	OPERAND1(FP),R1 	; R1 = location of first value
	MOVAB	OPERAND2(FP),R2 	; R2 = location of second value
	BSBW	COMPARE_REAL		; compare the values
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	4CFD CVTBG - Convert Byte to Grand
	;
INST_CVTBG:				; entrance
	BSBW	READ_BYTE		; first operand is read only
	BSBW	FLOAT_LONG		; convert to floating and save value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination address
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	6CFD CVTBH - Convert Byte to Huge
	;
INST_CVTBH:				; entrance
	BSBW	READ_BYTE		; first operand is read only
	BSBW	FLOAT_LONG		; convert to floating and save value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination address
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	32FD CVTDH - Convert Double to Huge
	;
INST_CVTDH:				; entrance
	BSBW	READ_DOUBLE		; first operand is read only
	BSBW	UNPACK_DOUBLE		; unpack the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	99FD CVTFG - Convert Floating to Grand
	;
INST_CVTFG:				; entrance
	BSBW	READ_FLOAT		; first operand is read only
	BSBW	UNPACK_FLOAT		; unpack and save the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	98FD CVTFH - Convert Floating to Huge
	;
INST_CVTFH:				; entrance
	BSBW	READ_FLOAT		; first operand is read only
	BSBW	UNPACK_FLOAT		; unpack and save the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	48FD CVTGB - Convert Grand to Byte
	;
INST_CVTGB:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	WRITE_BYTE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	CVTLB	R0,R0			; convert long to byte
	BVC	1$			; no overflow - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate integer overflow
1$:	MOVB	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	33FD CVTGF - Convert Grand to Floating
	;
INST_CVTGF:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	WRITE_FLOAT		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_FLOAT		; pack the value
	MOVL	R0,@ADDRESS1(FP)	; output the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	56FD CVTGH - Convert Grand to Huge
	;
INST_CVTGH:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	4AFD CVTGL - Convert Grand to Long
	;
INST_CVTGL:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack the value
	BSBW	WRITE_LONG		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	MOVL	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	49FD CVTGW - Convert Grand to Word
	;
INST_CVTGW:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack the value
	BSBW	WRITE_WORD		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	CVTLW	R0,R0			; convert the value to a word
	BVC	1$			; no integer overflow - skip
	BISL2	#PSLM_V,PSL(FP) 	; set the V bit in the PSL
1$:	MOVW	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	68FD CVTHB - Convert Huge to Byte
	;
INST_CVTHB:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack the value
	BSBW	WRITE_BYTE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	CVTLB	R0,R0			; convert the value to a byte
	BVC	1$			; no integer overflow - skip
	BISL2	#PSLM_V,PSL(FP) 	; set the V bit in the PSL
1$:	MOVB	R0,@ADDRESS1(FP)	; output the result
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	F7FD CVTHD - Convert Huge to Double
	;
INST_CVTHD:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	WRITE_DOUBLE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_DOUBLE		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	F6FD CVTHF - Convert Huge to Floating
	;
INST_CVTHF:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	WRITE_FLOAT		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_FLOAT		; pack the value
	MOVL	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	76FD CVTHG - Convert Huge to Grand
	;
INST_CVTHG:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	6AFD CVTHL - Convert Huge to Long
	;
INST_CVTHL:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack the value
	BSBW	WRITE_LONG		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	MOVL	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	69FD CVTHW - Convert Huge to Word
	;
INST_CVTHW:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack the operand
	BSBW	WRITE_WORD		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the value
	CVTLW	R0,R0			; convert the value to a word
	BVC	1$			; no integer overflow - skip
	BISL2	#PSLM_V,PSL(FP) 	; set the V bit in the PSL
1$:	MOVW	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	4EFD CVTLG - Convert Long to Grand
	;
INST_CVTLG:				; entrance
	BSBW	READ_LONG		; first operand is read only
	BSBW	FLOAT_LONG		; convert to real and save the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	6EFD CVTLH - Convert Long to Huge
	;
INST_CVTLH:				; entrance
	BSBW	READ_LONG		; first operand is read only
	BSBW	FLOAT_LONG		; convert to real and save the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	4BFD CVTRGL - Convert Rounded Grand to Long
	;
INST_CVTRGL:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack the value
	BSBW	WRITE_LONG		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	ROUND_REAL		; round the value
	MOVL	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	6BFD CVTRHL - Convert Rounded Huge to Long
	;
INST_CVTRHL:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack the value
	BSBW	WRITE_LONG		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	ROUND_REAL		; round the value
	MOVL	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	4DFD CVTWG - Convert Word to Grand
	;
INST_CVTWG:				; entrance
	BSBW	READ_WORD		; first operand is read only
	BSBW	FLOAT_LONG		; float the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	6DFD CVTWH - Convert Word to Huge
	;
INST_CVTWH:				; entrance
	BSBW	READ_WORD		; first operand is read only
	BSBW	FLOAT_LONG		; float the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the result
	MOVQ	R2,(R11)		; output the second part of the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	46FD DIVG2 - Divide Grand (Two Operands)
	;
INST_DIVG2:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND3		; unpack and save the value
	BSBW	MODIFY_GRAND		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	DIVIDE_GRAND		; compute the quotient
	BSBW	PACK_GRAND1		; pack the result
	MOVQ	R0,@ADDRESS1(FP)	; output the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	47FD DIVG3 - Divide Grand (Three Operands)
	;
INST_DIVG3:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND3		; unpack and save the value
	BSBW	READ_GRAND		; second operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	DIVIDE_GRAND		; compute the quotient
	BSBW	PACK_GRAND1		; pack the result
	MOVQ	R0,@ADDRESS1(FP)	; output the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	66FD DIVH2 - Divide Huge (Two Operands)
	;
INST_DIVH2:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE3		; unpack and save the value
	BSBW	MODIFY_HUGE		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	DIVIDE_HUGE		; compute the quotient
	BSBW	PACK_HUGE1		; pack the result
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the result
	MOVQ	R2,(R11)		; output the second part of the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	67FD DIVH3 - Divide Huge (Three Operands)
	;
INST_DIVH3:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE3		; unpack and save the value
	BSBW	READ_HUGE		; second operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	DIVIDE_HUGE		; compute the quotient
	BSBW	PACK_HUGE1		; pack the result
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the result
	MOVQ	R2,(R11)		; output the second part of the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	54FD EMODG - Extended Modulus Grand
	;
INST_EMODG:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the operand
	BSBW	READ_WORD		; second operand is read only
	ROTL	#27,R0,R0		; position the high-order 11 bits
	INSV	R0,#0,#11,FRACTION2+8(FP) ; insert bits 0-10 of the fraction
	BSBW	READ_GRAND		; third operand is read only
	BSBW	UNPACK_GRAND3		; unpack and save the value
	MOVB	#FLAG0M,FLAGS(FP)	; inhibit checking for local store
	BSBW	WRITE_LONG		; fourth operand is write only
	BBCC	#FLAG1,FLAGS(FP),1$	; not register mode - skip
	BBCS	#FLAG7,FLAGS(FP),1$	; make a note
1$:	MOVL	R11,ADDRESS1(FP)	; save the first destination address
	BSBW	WRITE_GRAND		; fifth operand is write only
	MOVL	R11,ADDRESS2(FP)	; save the second destination address
	BSBW	MULTIPLY_GRAND		; compute the product
	INSV	#0,#0,R0,FRACTION1+8(FP); truncate the product if necessary
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the product
	MOVL	R0,ADDRESS3(FP)		; save the integer part
	BSBW	FRACTION_REAL		; form the fractional part
	BSBW	PACK_GRAND1		; pack the fraction value
	PUSHR	#^M<R0,R1>		; push the fraction
	BBC	#FLAG7,FLAGS(FP),2$	; fourth operand not register - skip
	MOVL	ADDRESS3(FP),@ADDRESS1(FP) ; output the integer part
2$:	BBC	#FLAG1,FLAGS(FP),3$	; fifth operand not register - skip
	MOVQ	(SP)+,@ADDRESS2(FP)	; output the fraction
3$:	MOVL	#8,R0			; allow room for dummy store
	BSBW	TEST_FRAME		; move the frame if necessary
	BBS	#FLAG7,FLAGS(FP),4$	; fourth operand is register - bypass
	MOVL	#4,R10			; R10 = size of integer part
	MOVL	ADDRESS1(FP),R11	; R11 = location of fourth operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVL	ADDRESS3(FP),(R11)	; output the integer part
4$:	BBS	#FLAG1,FLAGS(FP),5$	; fifth operand is register - bypass
	MOVL	#8,R10			; R10 = size of the fraction
	MOVL	ADDRESS2(FP),R11	; R11 = location of second operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVQ	(SP)+,(R11)		; output the fraction
5$:	MOVAB	OPERAND1(FP),R1 	; R1 = location of the fraction
	BSBW	TEST_REAL		; test the fraction
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	74FD EMODH - Extended Modulus Huge
	;
INST_EMODH:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the operand
	BSBW	READ_WORD		; second operand is read only
	ROTL	#31,R0,R0		; position the high-order 15 bits
	INSV	R0,#0,#15,FRACTION2(FP) ; insert bits 0-14 of the fraction
	BSBW	READ_HUGE		; third operand is read only
	BSBW	UNPACK_HUGE3		; unpack and save the value
	MOVB	#FLAG0M,FLAGS(FP)	; inhibit checking for local store
	BSBW	WRITE_LONG		; fourth operand is write only
	BBCC	#FLAG1,FLAGS(FP),1$	; not register mode - skip
	BBCS	#FLAG7,FLAGS(FP),1$	; make a note
1$:	MOVL	R11,ADDRESS1(FP)	; save the first destination address
	BSBW	WRITE_HUGE		; fifth operand is write only
	MOVL	R11,ADDRESS2(FP)	; save the second destination address
	BSBW	MULTIPLY_HUGE		; compute the product
	INSV	#0,#0,R0,FRACTION1(FP)	; truncate the product if necessary
	BICL2	#PSLM_NZVC,PSL(FP)	; clear the condition codes
	BSBW	FIX_REAL		; fix the product
	MOVL	R0,ADDRESS3(FP)		; save the integer part
	BSBW	FRACTION_REAL		; form the fractional part
	BSBW	PACK_HUGE1		; pack the fraction value
	PUSHR	#^M<R0,R1,R2,R3>	; push the fraction
	BBC	#FLAG7,FLAGS(FP),2$	; fourth operand not register - skip
	MOVL	ADDRESS3(FP),@ADDRESS1(FP) ; output the integer part
2$:	BBC	#FLAG1,FLAGS(FP),3$	; fifth operand not register - bypass
	MOVL	ADDRESS2(FP),R11	; R11 = location of the register
	MOVQ	(SP)+,(R11)+		; output first part of the fraction
	MOVQ	(SP)+,(R11)		; output second part of the fraction
3$:	MOVL	#16,R0			; allow room for dummy store
	BSBW	TEST_FRAME		; move the frame if necessary
	BBS	#FLAG7,FLAGS(FP),4$	; fourth operand is register - bypass
	MOVL	#4,R10			; R10 = size of integer part
	MOVL	ADDRESS1(FP),R11	; R11 = location of fourth operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVL	ADDRESS3(FP),(R11)	; output the integer part
4$:	BBS	#FLAG1,FLAGS(FP),5$	; fifth operand is register - bypass
	MOVL	#16,R10			; R10 = size of the fraction
	MOVL	ADDRESS2(FP),R11	; R11 = location of second operand
	BSBW	LOCAL_TEST		; check for a store into local storage
	MOVQ	(SP)+,(R11)+		; output first part of the fraction
	MOVQ	(SP)+,(R11)		; output second part of the fraction
5$:	MOVAB	OPERAND1(FP),R1 	; R1 = location of the fraction
	BSBW	TEST_REAL		; test the fraction
	BSBW	SET_CONDITION		; set the condition codes
	BRW	NORMAL_EXIT		; done
	;
	;	52FD MNEGG - Move Negated Grand
	;
INST_MNEGG:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	72FD MNEGH - Move Negated Huge
	;
INST_MNEGH:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done

	;
	;	7EFD MOVAO - Move Address of Octaword
	;
	;	7EFD MOVAH - Move Address of Huge
	;
INST_MOVAO:				; entrance
	BSBW	ADDRESS_OCTA		; first operand is address only
	MOVL	R11,ADDRESS1(FP)	; save the operand address
	BSBW	WRITE_LONG		; second operand is write only
	MOVL	ADDRESS1(FP),(R11)	; output the operand address
	BSBW	SET_CONDITION		; capture the condition code
	BICL2	#PSLM_V,PSL(FP) 	; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	50FD MOVG - Move Grand
	;
INST_MOVG:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	WRITE_GRAND		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the result
	MOVAB	OPERAND1(FP),R1		; R1 = location of the value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_V,PSL(FP)		; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	70FD MOVH - Move Huge
	;
INST_MOVH:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	WRITE_HUGE		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	MOVAB	OPERAND1(FP),R1		; R1 = location of the value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_V,PSL(FP)		; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	7DFD MOVO - Move Octaword
	;
INST_MOVO:				; entrance
	BSBW	READ_OCTA		; first operand is read only
	MOVQ	R0,OPERAND1(FP) 	; save the first part of the value
	MOVQ	R2,OPERAND1+8(FP)	; save the second part of the value
	BSBW	WRITE_OCTA		; second operand is write only
	MOVL	R11,ADDRESS1(FP)	; save destination location
	BSBW	TEST_OCTA		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_V,PSL(FP)		; clear the V bit in the PSL
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	OPERAND1(FP),(R11)+	; output the first part of the result
	MOVQ	OPERAND1+8(FP),(R11)	; output the second part of the result
	BRW	NORMAL_EXIT		; done
	;
	;	44FD MULG2 - Multiply Grand (Two Operands)
	;
INST_MULG2:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the first operand
	BSBW	MODIFY_GRAND		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_GRAND3		; unpack and save the second operand
	BSBW	MULTIPLY_GRAND		; compute the product
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	45FD MULG3 - Multiply Grand (Three Operands)
	;
INST_MULG3:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	READ_GRAND		; second operand is read only
	BSBW	UNPACK_GRAND3		; unpack and save the value
	BSBW	WRITE_GRAND		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	MULTIPLY_GRAND		; compute the product
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	64FD MULH2 - Multiply Huge (Two Operands)
	;
INST_MULH2:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the first operand
	BSBW	MODIFY_HUGE		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_HUGE3		; unpack and save the second operand
	BSBW	MULTIPLY_HUGE		; compute the product
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	65FD MULH3 - Multiply Huge (Three Operands)
	;
INST_MULH3:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	READ_HUGE		; second operand is read only
	BSBW	UNPACK_HUGE3		; unpack and save the value
	BSBW	WRITE_HUGE		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	MULTIPLY_HUGE		; compute the product
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the result
	MOVQ	R2,(R11)		; output the second part of the result
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	55FD POLYG - Evaluate Polynomial Grand
	;
INST_POLYG:				; entrance
	BBC	#PSL_FPD,PSL(FP),1$	; not instruction resumption - bypass
	EXTZV	#8,#24,REG_R2(FP),R0	; R0 = saved instruction length
	ADDL2	R0,REG_PC(FP)		; position PC to end of instruction
	ADDB2	R0,REGMOD_PC(FP)	; increment the PC modification count
	MOVQ	REG_R0(FP),R0		; R0,R1 = result so far
	BSBW	UNPACK_GRAND2		; unpack and save the value
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	MOVQ	REG_R4(FP),R0		; R0,R1 = argument value
	BSBW	UNPACK_GRAND3		; unpack and save the value
	CMPB	#31,REG_R2(FP)		; is the iteration count too large ?
	BGEQU	4$			; no - resume the instruction
	BRW	OPERAND_FAULT		; process the reserved operand
1$:	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND3		; unpack and save the value
	BSBW	READ_WORD		; second operand is read only
	CMPL	#31,R0			; is the value reserved ?
	BGEQU	2$			; no - skip
	BRW	OPERAND_FAULT		; process the reserved operand
2$:	MOVL	R0,ADDRESS1(FP) 	; save the operand value
	BSBW	ADDRESS_BYTE		; third operand is address only
	PROBER	MODE(FP),#8,(R11)	; can we read the first quadword ?
	BNEQ	3$			; yes - skip
	MOVL	#8,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
3$:	MOVQ	(R11)+,R0		; R0,R1 = the first table entry
	MOVL	R11,ADDRESS2(FP)	; save the following address
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	PACK_GRAND2		; pack the value
	MOVQ	R0,REG_R0(FP)		; save the value in user's R0-R1
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	MOVL	ADDRESS2(FP),REG_R3(FP)	; store next location in user's R3
	MOVL	ADDRESS1(FP),REG_R2(FP) ; save the remaining iteration count
	CVTBL	REGMOD_PC(FP),R0	; R0 = PC register modifications
	CLRQ	REGMOD_R0(FP)		; clear modifications for R0 to R7
	CLRQ	REGMOD_R8(FP)		; clear modifications for R8 to PC
	MOVB	R0,REGMOD_PC(FP)	; put the PC modifications back
	SUBL2	#2,R0			; subtract the operation code length
	INSV	R0,#8,#24,REG_R2(FP)	; save the value for resumption
	BSBW	PACK_GRAND3		; pack the argument value
	MOVQ	R0,REG_R4(FP)		; save it for resumption
	BBSS	#PSL_FPD,PSL(FP),4$	; indicate first part done in PSL
4$:	TSTB	REG_R2(FP)		; more iterations to perform ?
	BEQL	6$			; no - finish up
	BSBW	MULTIPLY_GRAND		; multiply the result and argument
	INCL	R0			; increment the shift count
	INSV	#0,#0,R0,FRACTION1+8(FP); truncate the product
	MOVL	REG_R3(FP),R11		; R11 = location of next table entry
	PROBER	MODE(FP),#8,(R11)	; can we read the next coefficient ?
	BNEQ	5$			; yes - skip
	MOVL	#8,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
5$:	MOVQ	@REG_R3(FP),R0		; R0 = next coefficient
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	ADD_REAL		; add the coefficient to the product
	BSBW	PACK_GRAND1		; pack the result so far
	MOVQ	R0,REG_R0(FP)		; save the value
	BSBW	UNPACK_GRAND2		; unpack the result for next iteration
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	ADDL2	#8,REG_R3(FP)		; update the table pointer
	DECB	REG_R2(FP)		; decrement the iteration counter
	BRB	4$			; start the next iteration
6$:	CLRL	REG_R2(FP)		; clear the user's R2
	CLRQ	REG_R4(FP)		; clear the user's R4 and R5
	BBCC	#PSL_FPD,PSL(FP),7$	; indicate instruction complete
7$:	BRW	NORMAL_EXIT		; done
	;
	;	75FD POLYH - Evaluate Polynomial Huge
	;
INST_POLYH:				; entrance
	BBC	#PSL_FPD,PSL(FP),3$	; not instruction resumption - bypass
	EXTZV	#8,#24,REG_R4(FP),R0	; R0 = saved instruction length
	ADDL2	R0,REG_PC(FP)		; position PC to end of instruction
	ADDB2	R0,REGMOD_PC(FP)	; increment the PC modification count
	MOVQ	REG_R0(FP),R0		; R0,R1 = first part of result so far
	MOVQ	REG_R2(FP),R2		; R2,R3 = second part of result so far
	BSBW	UNPACK_HUGE2		; unpack and save the value
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	MOVL	REG_SP(FP),R11		; R11 = user's stack pointer
	PROBER	MODE(FP),#16,(R11)	; can we read a stacked octaword ?
	BNEQ	1$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVQ	(R11)+,R0		; R0,R1 = first part of argument
	MOVQ	(R11),R2		; R2,R3 = second part of argument
	BSBW	UNPACK_HUGE3		; unpack and save the value
	CMPB	#31,R4			; is the iteration count too large ?
	BLSSU	2$			; no - skip
	BRW	OPERAND_FAULT		; processed the reserved operand
2$:	BRW	7$			; resume the instruction
3$:	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE3		; unpack and save the value
	BSBW	READ_WORD		; second operand is read only
	CMPL	#31,R0			; is the value reserved ?
	BGEQU	4$			; no - skip
	BRW	OPERAND_FAULT		; process the reserved operand
4$:	MOVL	R0,ADDRESS1(FP) 	; save the operand value
	BSBW	ADDRESS_BYTE		; third operand is address only
	MOVL	R11,ADDRESS2(FP)	; save the table address
	BSBW	PACK_HUGE3		; pack the argument value
	SUBL2	#16,REG_SP(FP)		; decrement the user SP
	SUBB2	#16,REGMOD_SP(FP)	; remember the decrement
	MOVL	REG_SP(FP),R11		; R11 = user's stack pointer
	PROBEW	MODE(FP),#16,(R11)	; can we stack the argument ?
	BNEQ	5$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	WRITE_FAULT		; process the access violation
5$:	MOVQ	R0,(R11)+		; save first part of argument
	MOVQ	R2,(R11)		; save second part of argument
	MOVL	ADDRESS2(FP),R11	; R11 = coefficient table address
	PROBER	MODE(FP),#16,(R11)	; can we read the first octaword ?
	BNEQ	6$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
6$:	MOVQ	(R11)+,R0		; R0,R1 = first part of coefficient
	MOVQ	(R11)+,R2		; R2,R3 = second part of coefficient
	MOVL	R11,ADDRESS2(FP)	; save the following address
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	PACK_HUGE2		; pack the value again
	MOVQ	R0,REG_R0(FP)		; save first part of value so far
	MOVQ	R2,REG_R2(FP)		; save second part of value so far
	MOVAB	OPERAND2(FP),R1		; R1 = location of OPERAND2
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	MOVL	ADDRESS1(FP),REG_R4(FP) ; save the remaining iteration count
	MOVL	ADDRESS2(FP),REG_R5(FP)	; save the next coefficient address
	CVTBL	REGMOD_PC(FP),R0	; R0 = PC register modifications
	CLRQ	REGMOD_R0(FP)		; clear modifications for R0 to R7
	CLRQ	REGMOD_R8(FP)		; clear modifications for R8 to PC
	MOVB	R0,REGMOD_PC(FP)	; put the PC modifications back
	SUBL2	#2,R0			; subtract the operation code length
	INSV	R0,#8,#24,REG_R4(FP)	; save the value for resumption
	BBSS	#PSL_FPD,PSL(FP),7$	; indicate first part done in PSL
7$:	TSTB	REG_R4(FP)		; more iterations to perform ?
	BEQL	9$			; no - finish up
	BSBW	MULTIPLY_HUGE		; multiply the result and argument
	INCL	R0			; increment the shift count
	INSV	#0,#0,R0,FRACTION1(FP)	; truncate the product
	MOVL	REG_R5(FP),R11		; R11 = location of next table entry
	PROBER	MODE(FP),#16,(R11)	; can we read the next coefficient ?
	BNEQ	8$			; yes - skip
	MOVL	#16,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
8$:	MOVL	REG_R5(FP),R11		; R11 = location of next table entry
	MOVQ	(R11)+,R0		; R0,R1 = first part of next entry
	MOVQ	(R11),R2		; R2,R3 = second part of next entry
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	ADD_REAL		; add the coefficient to the product
	BSBW	PACK_HUGE1		; pack the result so far
	MOVQ	R0,REG_R0(FP)		; save the first part of the value
	MOVQ	R2,REG_R2(FP)		; save the second part of the value
	BSBW	UNPACK_HUGE2		; unpack the result for next iteration
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	ADDL2	#16,REG_R5(FP)		; update the table pointer
	DECB	REG_R4(FP)		; decrement the iteration counter
	BRB	7$			; start the next iteration
9$:	CLRL	REG_R4(FP)		; clear the user's R4
	ADDL2	#16,REG_SP(FP)		; unstack the argument value
	BBCC	#PSL_FPD,PSL(FP),10$	; indicate instruction complete
10$:	BRW	NORMAL_EXIT		; done
	;
	;	7FFD PUSHAO - Push Address of Octaword
	;
	;	7FFD PUSHAH - Push Address of Huge
	;
INST_PUSHAO:				; entrance
	BSBW	ADDRESS_OCTA		; first operand is address only
	SUBL2	#4,REG_SP(FP)		; decrement the user SP
	SUBB2	#4,REGMOD_SP(FP)	; remember the decrement
	MOVL	R11,R0			; R0 = the operand address
	MOVL	REG_SP(FP),R11		; R11 = user's stack pointer
	PROBEW	MODE(FP),#4,(R11)	; can we write the operand address ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	WRITE_FAULT		; process the access violation
1$:	MOVL	R0,@REG_SP(FP)		; stack the operand address
	TSTL	R0			; test the operand address
	BSBW	SET_CONDITION		; capture the condition code
	BICL2	#PSLM_V,PSL(FP) 	; clear the V bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	42FD SUBG2 - Subtract Grand (Two Operands)
	;
INST_SUBG2:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	MODIFY_GRAND		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	43FD SUBG3 - Subtract Grand (Three Operands)
	;
INST_SUBG3:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	READ_GRAND		; second operand is read only
	BSBW	UNPACK_GRAND2		; unpack and save the value
	BSBW	WRITE_GRAND		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_GRAND1		; pack the value
	MOVQ	R0,@ADDRESS1(FP)	; output the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	62FD SUBH2 - Subtract Huge (Two Operands)
	;
INST_SUBH2:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	MODIFY_HUGE		; second operand is modified
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	63FD SUBH3 - Subtract Huge (Three Operands)
	;
INST_SUBH3:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	BSBW	NEGATE_REAL		; negate the value
	BSBW	READ_HUGE		; second operand is read only
	BSBW	UNPACK_HUGE2		; unpack and save the value
	BSBW	WRITE_HUGE		; third operand is write only
	MOVL	R11,ADDRESS1(FP)	; save the destination location
	BSBW	ADD_REAL		; compute the sum
	BSBW	PACK_HUGE1		; pack the value
	MOVL	ADDRESS1(FP),R11	; R11 = destination location
	MOVQ	R0,(R11)+		; output the first part of the value
	MOVQ	R2,(R11)		; output the second part of the value
	BSBW	SET_CONDITION1		; set the condition codes in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	53FD TSTG - Test Grand
	;
INST_TSTG:				; entrance
	BSBW	READ_GRAND		; first operand is read only
	BSBW	UNPACK_GRAND1		; unpack and save the value
	MOVAB	OPERAND1(FP),R1 	; R1 = location of the value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	BRW	NORMAL_EXIT		; done
	;
	;	73FD TSTH - Test Huge
	;
INST_TSTH:				; entrance
	BSBW	READ_HUGE		; first operand is read only
	BSBW	UNPACK_HUGE1		; unpack and save the value
	MOVAB	OPERAND1(FP),R1 	; R1 = location of the value
	BSBW	TEST_REAL		; test the value
	BSBW	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	BRW	NORMAL_EXIT		; done
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*	    Routines for Scanning Instruction Operands	       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The following section contains a complex of routines for
	;	scanning the operands of an instruction and determining the
	;	values and locations of operands. The code contains full error
	;	checking and also checks for the situations that the
	;	architecture considers to be unpredictable. In order to make
	;	the operand scanning in the instruction emulation routines 
	;	clear, separate entrys appear for each possible kind of
	;	operand.
	;
	;
	;	Operand Scanning Routines
	;	-------------------------
	;
	;	    The operand scanning routines are entered by subroutine
	;	branching and have entry names of the form
	;
	;		<access type>_<data type>
	;
	;	in which <access type> is any one of the following
	;
	;		READ		operand is read only
	;		WRITE		operand is write only
	;		MODIFY		operand is both read and write
	;		ADDRESS		only the operand address is required
	;		BRANCH		relative branch destintion
	;
	;	and in which <data type> is any one of the following
	;
	;		BYTE		byte
	;		WORD		word
	;		LONG		longword
	;		QUAD		quadword
	;		OCTA		octaword
	;		FLOAT		F-format floating
	;		DOUBLE		D-format floating
	;		GRAND		G-format floating
	;		HUGE		H-format floating
	;
	;	For an access type of BRANCH the data type refers to the
	;	size of the relative address rather than the properties of
	;	any addressed information.
	;
	;	    Entrys only exist for those types of operands which appear
	;	in the emulated instructions. If additional entrys are 
	;	required they can be added easily enough.
	;
	;	    When the routines are entered they scan the next 
	;	instruction operand starting at the value of the user's PC
	;	and check the operand for validity. If any exceptions are
	;	detected during operand scanning they are processed immediatly
	;	and the routines do not return. Any changes that are made to
	;	any of the registers (including PC) are recorded in the change
	;	bytes so faults will be handled properly.
	;
	;	    When the routines return the following rules describe the
	;	contents of the registers:
	;
	;	     o	If the access type is READ or MODIFY and the data type
	;		is BYTE, WORD, LONG, or FLOAT, then R0 is the value
	;		of the operand. If the data type is BYTE or WORD then
	;		the value is sign extended to a longword.
	;
	;	     o	If the access type is READ or MODIFY and the data type
	;		is QUAD, DOUBLE, or GRAND, then R0-R1 contains the
	;		value of the operand.
	;
	;	     o	If the access type is READ or MODIFY and the data type
	;		is OCTA or HUGE then R0-R3 contains the value of the
	;		operand.
	;
	;	     o	If the access type is WRITE, MODIFY, ADDRESS, or
	;		BRANCH, then R11 is the address of the operand or the
	;		branch destination.
	;
	;	If the instruction operand specifies register mode, then the
	;	address associated with the operand is the location of the
	;	emulated register. If an instruction operand with WRITE or
	;	MODIFY access addresses the Emulator's local storage then it
	;	is changed to an address that won't do any harm. This is 
	;	consistant with the notion that the area below the user's
	;	stack pointer is being continually garbaged. This check is not
	;	performed if flag bit 0 is set. The routines set flag bit 1 if
	;	the operand is a register mode operand.
	;
	;	    The subroutine LOCAL_TEST is available for checking for 
	;	stores into the Emulator's local storage in places where this
	;	is not done automatically.
	;
	;
	;	Exceptions
	;	----------
	;
	;	    The instruction operand scanning routines perform complete
	;	error checking and immediatly signal any exceptions detected.
	;	All of these exceptions are faults. The change bytes are
	;	constantly kept up to date so the instruction will be left in
	;	a consistant state for restarting if a fault occurs.
	;
	;	    All fetches from memory done in scanning the instruction
	;	operand or in fetching the operand or operand address are 
	;	probed and access violations are signaled if the probes fail.
	;	All of the addressing modes specified by the architecture to
	;	be reserved addressing modes or unpredictable are checked for
	;	and are signaled as reserved addressing modes if they are
	;	detected.
	;
	;
	;	Routine Organization
	;	--------------------
	;
	;	    Except for BRANCH access mode for which there are only
	;	isolated routines, the code at the individual routine 
	;	entrances simply loads the data type code into R9 and branches
	;	to a routine for the access type. This routine in turn loads
	;	the access type code into R8 and branches to the routine 
	;	GET_SPECIFIER which process the operand specifier byte.
	;
	;	    GET_SPECIFIER loads the length of the data type into R10
	;	and the operand specifier byte into R0. The high and low 
	;	order nibbles of this byte are stored in R1 and R2. The 
	;	register R7 which is reserved for the index modification is 
	;	cleared. The routine now branches on the high order nibble
	;	to a routine which will handle the specific kind of operand.
	;
	;	    For literals the values are expanded immediatly and the
	;	routine returns.
	;
	;	    For index mode operand specifiers, the index modification
	;	is computed and the next operand specifier byte is loaded into
	;	R0 and decomposed as before. Again we branch on the high order
	;	nibble but this time certain addressing modes which are 
	;	illegal with indexing are checked for. Also for those 
	;	addressing modes which change register values a check is made
	;	that the register is not the same as the index register.
	;
	;	    For register mode operands the address of the emulated
	;	register is loaded into R11. A check is made that the operand
	;	does not contain PC. Then flag bit 1 is set and control passes
	;	to the operand reading routine if the access type is READ or
	;	MODIFY and the routine returns otherwise.
	;
	;	    For the remaining addressing modes the operand addresses
	;	are computed in a straightforward manner and loaded into R11.
	;	for some of these addressing modes the values of registers may
	;	be changed. These changes are reflected in the change bytes.
	;	When the operand address is computed control passes to the 
	;	operand accessing routine.
	;	
	;	    For ADDRESS access mode operands the operand accessing
	;	routine returns but for all others it probes the operand 
	;	address and also checks for writes into the Emulator's local
	;	storage unless flag bit 0 is set. If the operand is READ or
	;	MODIFY access control passes to the operand reading routine.
	;
	;	    The operand reading routine simply reads the operand 
	;	value into the registers starting at R0 and then returns.
	;	Bytes and Words are sign extended into longwords. However
	;	this routine does not check for reserved floating values
	;	since this is done by the unpack routines.
	;

	;
	;	Process a Read Only Byte Operand
	;
READ_BYTE:				; entrance
	MOVL	#TYPE_BYTE,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Byte Operand
	;
WRITE_BYTE:				; entrance
	MOVL	#TYPE_BYTE,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process an Addressed Byte Operand
	;
ADDRESS_BYTE:				; entrance
	MOVL	#TYPE_BYTE,R9		; R9 = data type
	BRB	ADDRESS_ACCESS		; process the access type
	;
	;	Process a Read Only Word Operand
	;
READ_WORD:				; entrance
	MOVL	#TYPE_WORD,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Word Operand
	;
WRITE_WORD:				; entrance
	MOVL	#TYPE_WORD,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process a Read Only Longword Operand
	;
READ_LONG:				; entrance
	MOVL	#TYPE_LONG,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Longword Operand
	;
WRITE_LONG:				; entrance
	MOVL	#TYPE_LONG,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process a Read Only Octaword Operand
	;
READ_OCTA:				; entrance
	MOVL	#TYPE_OCTA,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Octaword Operand
	;
WRITE_OCTA:				; entrance
	MOVL	#TYPE_OCTA,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process an Addressed Octaword Operand
	;
ADDRESS_OCTA:				; entrance
	MOVL	#TYPE_OCTA,R9		; R9 = data type
	BRB	ADDRESS_ACCESS		; process the access type
	;
	;	Process a Read Only Floating Operand
	;
READ_FLOAT:				; entrance
	MOVL	#TYPE_FLOAT,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Floating Operand
	;
WRITE_FLOAT:				; entrance
	MOVL	#TYPE_FLOAT,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process a Read Only Double Operand
	;
READ_DOUBLE:				; entrance
	MOVL	#TYPE_DOUBLE,R9 	; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Double Operand
	;
WRITE_DOUBLE:				; entrance
	MOVL	#TYPE_DOUBLE,R9 	; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process a Read Only Grand Operand
	;
READ_GRAND:				; entrance
	MOVL	#TYPE_GRAND,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Grand Operand
	;
WRITE_GRAND:				; entrance
	MOVL	#TYPE_GRAND,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process a Modified Grand Operand
	;
MODIFY_GRAND:				; entrance
	MOVL	#TYPE_GRAND,R9		; R9 = data type
	BRB	MODIFY_ACCESS		; process the access type
	;
	;	Process a Read Only Huge Operand
	;
READ_HUGE:				; entrance
	MOVL	#TYPE_HUGE,R9		; R9 = data type
	BRB	READ_ACCESS		; process the access type
	;
	;	Process a Write Only Huge Operand
	;
WRITE_HUGE:				; entrance
	MOVL	#TYPE_HUGE,R9		; R9 = data type
	BRB	WRITE_ACCESS		; process the access type
	;
	;	Process a Modified Huge Operand
	;
MODIFY_HUGE:				; entrance
	MOVL	#TYPE_HUGE,R9		; R9 = data type
	BRB	MODIFY_ACCESS		; process the access type
	;
	;	Process a Read Only Operand
	;
READ_ACCESS:				; entrance
	MOVL	#TYPE_READ,R8		; R8 = access type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Process a Write Only Operand
	;
WRITE_ACCESS:				; entrance
	MOVL	#TYPE_WRITE,R8		; R8 = access type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Process a Modified Operand
	;
MODIFY_ACCESS:				; entrance
	MOVL	#TYPE_MODIFY,R8 	; R8 = access type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Process an Addressed Operand
	;
ADDRESS_ACCESS: 			; entrance
	MOVL	#TYPE_ADDRESS,R8	; R8 = access type
	BRB	GET_SPECIFIER		; scan the operand
	;
	;	Table of Data Type Lengths
	;
LENGTHS:				; table origin
	.BYTE	1			; 1 - byte
	.BYTE	2			; 2 - word
	.BYTE	4			; 3 - longword
	.BYTE	8			; 4 - quadword
	.BYTE	16			; 5 - octaword
	.BYTE	4			; 6 - float
	.BYTE	8			; 7 - double
	.BYTE	8			; 8 - grand
	.BYTE	16			; 9 - huge
	;
	;	Process the Next Operand Specifier
	;
GET_SPECIFIER:				; entrance
	MOVZBL	LENGTHS-1[R9],R10	; R10 = data type length
	CLRL	R7			; clear the index value
	MOVL	REG_PC(FP),R11		; R11 = specifier byte location
	PROBER	MODE(FP),#1,(R11)	; can we read the specifier byte ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process an access violation
1$:	MOVZBL	@REG_PC(FP),R0		; R0 = specifier byte
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the incrementation
	EXTZV	#4,#4,R0,R1		; R1 = high order nibble of specifier
	EXTZV	#0,#4,R0,R2		; R2 = low order nibble of specifier
	CASEL	R1,#0,#15		; branch on the high order nibble
2$:	.WORD	LITERAL_MODE-2$ 	; 0 - literal mode
	.WORD	LITERAL_MODE-2$ 	; 1 - literal mode
	.WORD	LITERAL_MODE-2$ 	; 2 - literal mode
	.WORD	LITERAL_MODE-2$ 	; 3 - literal mode
	.WORD	INDEX_MODE-2$		; 4 - index mode
	.WORD	REGISTER_MODE-2$	; 5 - register mode
	.WORD	REG_DEF_MODE-2$ 	; 6 - register deferred mode
	.WORD	DECR_MODE-2$		; 7 - autodecrement mode
	.WORD	INCR_MODE-2$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-2$	; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-2$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-2$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-2$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-2$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-2$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-2$	; F - long displacement deferred mode
	;
	;	Process a Literal Mode Operand Specifier
	;
LITERAL_MODE:				; entrance
	CASEL	R8,#1,#3		; branch on the access type
1$:	.WORD	2$-1$			; 1 - read only access
	.WORD	ADDRESS_FAULT-1$	; 2 - write only access
	.WORD	ADDRESS_FAULT-1$	; 3 - modify access
	.WORD	ADDRESS_FAULT-1$	; 4 - address access
2$:	CASEL	R9,#1,#8		; branch on the data type
3$:	.WORD	6$-3$			; 1 - byte
	.WORD	6$-3$			; 2 - word
	.WORD	6$-3$			; 3 - longword
	.WORD	5$-3$			; 4 - quadword
	.WORD	4$-3$			; 5 - octaword
	.WORD	8$-3$			; 6 - floating
	.WORD	7$-3$			; 7 - double
	.WORD	9$-3$			; 8 - grand
	.WORD	10$-3$			; 9 - huge
4$:	CLRQ	R2			; clear second quadword of value
5$:	CLRL	R1			; clear second longword of value
6$:	RSB				; return with the literal value
7$:	CLRL	R1			; clear second longword of value
8$:	ASHL	#4,R0,R0		; position the literal bits
	BBCS	#14,R0,6$		; include exponent bias and return
9$:	ASHL	#1,R0,R0		; position the literal bits
	BBCS	#14,R0,5$		; include exponent bias and finish up
10$:	ROTL	#29,R0,R0		; position the literal bits
	BBCS	#14,R0,4$		; include exponent bias and finish up
	;
	;	Process an Index Mode Operand Specifier
	;
INDEX_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BNEQ	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	MULL3	R10,REG_R0(FP)[R2],R7	; R7 = index address modification
	MOVL	R2,R3			; save the register number
	MOVL	REG_PC(FP),R11		; R11 = location of next byte
	PROBER	MODE(FP),#1,(R11)	; can we read the next byte ?
	BNEQ	2$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	MOVZBL	@REG_PC(FP),R0		; R0 = next operand specifier
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the incrementation
	EXTZV	#4,#4,R0,R1		; R1 = high order nibble of specifier
	EXTZV	#0,#4,R0,R2		; R2 = low order nibble of specifier
	CASEL	R1,#0,#15		; branch on the low order nibble
3$:	.WORD	ADDRESS_FAULT-3$	; 0 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 1 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 2 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 3 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 4 - index mode
	.WORD	ADDRESS_FAULT-3$	; 5 - register mode
	.WORD	REG_DEF_MODE-3$ 	; 6 - register deferred mode
	.WORD	4$-3$			; 7 - autodecrement mode
	.WORD	4$-3$			; 8 - autoincrement mode
	.WORD	4$-3$			; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-3$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-3$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-3$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-3$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-3$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-3$	; F - long displacement deferred mode
4$:	CMPL	R2,R3			; is register the same as index ?
	BNEQ	5$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
5$:	CASEL	R1,#7,#2		; branch on the high order nibble
6$:	.WORD	DECR_MODE-6$		; 7 - autodecrement mode
	.WORD	INCR_MODE-6$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-6$	; 9 - autoincrement deferred mode
	;
	;	Process a Register Mode Operand Specifier
	;
REGISTER_MODE:				; entrance
	BISB2	#FLAG1M,FLAGS(FP)	; indicate a register mode operand
	MOVAL	(R10)[R2],R3		; byte position following operand
	CMPL	#60,R3			; does the operand overlap PC ?
	BGEQ	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	MOVAL	REG_R0(FP)[R2],R11	; R11 = location of user register
	CASEL	R8,#1,#3		; branch on the access type
2$:	.WORD	READ_VALUE-2$		; 1 - read only access
	.WORD	3$-2$			; 2 - write access
	.WORD	READ_VALUE-2$		; 3 - modify access
	.WORD	ADDRESS_FAULT-2$	; 4 - address access
3$:	RSB				; return with the register address
	;
	;	Process a Register Deferred Mode Operand Specifier
	;
REG_DEF_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	1$			; no - skip
	BRW	ADDRESS_FAULT 		; process the reserved addressing mode
1$:	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process an Autodecrement Mode Operand Specifier
	;
DECR_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	SUBL2	R10,REG_R0(FP)[R2]	; subtract data size from register
	SUBB2	R10,REGMOD_R0(FP)[R2]	; remember the subtraction
	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process an Autoincrement Mode Operand Specifier
	;
INCR_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	2$			; no - bypass
	CASEL	R8,#1,#3		; branch on the access type
1$:	.WORD	2$-1$			; 1 - read only access
	.WORD	ADDRESS_FAULT-1$	; 2 - write only access
	.WORD	ADDRESS_FAULT-1$	; 3 - modify access
	.WORD	2$-1$			; 4 - address access
2$:	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	ADDL2	R10,REG_R0(FP)[R2]	; add the data size to the register
	ADDB2	R10,REGMOD_R0(FP)[R2]	; remember the addition
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process an Autoincrement Deferred Mode Operand Specifier
	;
INCR_DEF_MODE:				; entrance
	MOVL	REG_R0(FP)[R2],R11	; R11 = register value
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL3	R7,(R11),R11		; form the operand address
	ADDL2	#4,REG_R0(FP)[R2]	; add longword size to the register
	ADDB2	#4,REGMOD_R0(FP)[R2]	; remember the incrementation
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Byte Displacement Mode Operand Specifier
	;
BYTE_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTBL	(R11),R11		; R11 = displacement value
	INCL	REG_PC(FP)		; increment PC
	INCL	REGMOD_PC(FP)		; remember the increment
	ADDL2	R7,R11			; add the displacement to the index
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the result
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Byte Displacement Deferred Mode Operand Specifier
	;
BYTE_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTBL	(R11),R11		; R11 = displacement value
	INCL	REG_PC(FP)		; increment PC
	INCB	REGMOD_PC(FP)		; remember the increment
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access fault
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Word Displacement Mode Operand Specifier
	;
WORD_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = displacement value
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDB2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	R7,R11			; add the index to the displacement
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the result
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Word Displacement Deferred Mode Operand Specifier
	;
WORD_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = displacement value
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDB2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Long Displacement Mode Operand Specifier
	;
LONG_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVL	(R11),R11		; R11 = displacement value
	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDB2	#4,REGMOD_PC(FP)	; remember the increment
	ADDL2	R7,R11			; add the index to the displacement
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Process a Long Displacement Deferred Mode Operand Specifier
	;
LONG_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVL	(R11),R11		; R11 = displacement value
	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDB2	#4,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
	;
	;	Set Up the Type of Access Requested
	;
ACCESS_VALUE:				; entrance
	CASEL	R8,#1,#3		; branch on the access type
1$:	.WORD	READ_CHECK-1$		; 1 - read only access
	.WORD	WRITE_CHECK-1$		; 2 - write only access
	.WORD	MODIFY_CHECK-1$ 	; 3 - modify access
	.WORD	2$-1$			; 4 - address access
2$:	RSB				; return with the operand address
	;
	;	Perform Error Checking for Modify Access Operands
	;
MODIFY_CHECK:				; entrance
	BSBB	WRITE_CHECK		; check write (and read) access
	BRB	READ_VALUE		; load the value
	;
	;	Perform Error Checking for Read Only Access Operands
	;
READ_CHECK:				; entrance
	PROBER	MODE(FP),R10,(R11)	; can we read the operand ?
	BNEQ	1$			; yes - load the value
	BSBW	READ_FAULT		; process the access violation
1$:	BRB	READ_VALUE		; load the value
	;
	;	Perform Error Checking for Write Only Access Operands
	;
WRITE_CHECK:				; entrance
	PROBEW	MODE(FP),R10,(R11)	; can we write the operand ?
	BNEQ	1$			; yes - bypass
	BSBW	WRITE_FAULT		; process the access violation
	BBS	#FLAG0,FLAGS(FP),1$	; no local store checking - skip
	BSBW	LOCAL_TEST		; test for a write into local storage
1$:	RSB				; return
	;
	;	Load a Read Operand into the Registers
	;
READ_VALUE:				; entrance
	CASEL	R9,#1,#8		; branch on the data type
1$:	.WORD	2$-1$			; 1 - byte
	.WORD	3$-1$			; 2 - word
	.WORD	4$-1$			; 3 - longword
	.WORD	6$-1$			; 4 - quadword
	.WORD	5$-1$			; 5 - octaword
	.WORD	4$-1$			; 6 - floating
	.WORD	6$-1$			; 7 - double
	.WORD	6$-1$			; 8 - grand
	.WORD	5$-1$			; 9 - huge
2$:	CVTBL	(R11),R0		; R0 = operand value
	RSB				; return
3$:	CVTWL	(R11),R0		; R0 = operand value
	RSB				; return
4$:	MOVL	(R11),R0		; R0 = operand value
	RSB				; return
5$:	MOVQ	8(R11),R2		; R2,R3 = high order quadword of value
6$:	MOVQ	(R11),R0		; R0,R1 = low order quadword of value
	RSB				; return
	;
	;	Process a Word Branch Displacement Operand
	;
BRANCH_WORD:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = branch displacement
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDB2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_PC(FP),R11		; compute the branch destination
	RSB				; return
	;
	;	Test for a Write into Local Storage
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Number of Bytes to be Written
	;				R11 = Distination Address
	;
	;		returns with	R11 = Corrected Destination Address
	;
	;	Discussion
	;	
	;	    This routine checks the write operation described by
	;	the parameters in R10 and R11 for a write into the Emulator's
	;	working storage. If such a write is about to take place, R11
	;	is changed to an address where the write will not do any harm.
	;
LOCAL_TEST:				; entrance
	MOVAB	LOCAL_END(FP),R3	; R3 = byte following local storage
	CMPL	R11,R3			; is the write above the frame ?
	BGEQU	1$			; yes - bypass
	ADDL3	R10,R11,R3		; R3 = byte following operand
	CMPL	R3,SP			; is it above the stack pointer ?
	BLEQU	1$			; no - operand is not in local storage
	MOVAB	TEMP(FP),R11		; redirect the write to TEMP
1$:	RSB				; return with the operand address
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*       Routines for Unpacking and Packing Floating Values     *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The following routines perform all of the conversions
	;	between the VAX floating representations and the internal 
	;	representation used by the Emulator. The unpack routines
	;	convert from the VAX representation to the internal 
	;	representation and the pack routines perform the opposite
	;	conversion. These routines perform all of the necessary
	;	rounding and check for reserved values, underflow, and 
	;	overflow.
	;
	;
	;	The Unpack Routines
	;	-------------------
	;
	;	    The unpack routines convert a value in one of the VAX
	;	floating representations to our internal representation.
	;	The value to be converted is assumed to be contained in
	;	the registers starting at R0. For floating and double 
	;	floating values the available unpack routines only place
	;	the converted value in OPERAND1. For grand and huge routines
	;	are available which place the result in all of the operand
	;	areas.
	;
	;	    The unpack routines all check for a reserved floating
	;	value (sign bit set and biased exponent equal to zero) and
	;	signal a reserved operand exception if one is found.
	;
	;
	;	The Pack Routines
	;	-----------------
	;
	;	    The pack routines convert a value in the internal 
	;	representation to one of the VAX floating representations.
	;	The value to be converted is assumed to be in one of the
	;	operand areas and the value must be in OPERAND1 if the value
	;	is to be converted to floating or double floating. For grand
	;	and huge routines are available to convert from each of the
	;	operand areas. The routines always leave the result in the
	;	registers starting at R0.
	;
	;	    Before the value is converted the rounding bit (the first
	;	bit of the fraction which will not appear in the converted
	;	result) is tested and if it is set the value is rounded by
	;	adding one to the next higher bit (the lowest one that will
	;	appear in the converted result) and processing any carries
	;	that occur. When the conversion is performed the biased
	;	exponent is checked for possible overflow or underflow. If an 
	;	overflow condition is detected, then the condition is
	;	signaled. If an underflow condition is detected, then the
	;	condition is signaled only if the FU bit is set in the user's
	;	PSL. If the bit is not set then a value of zero is returned.
	;	If a nonzero value is converted to zero because of underflow,
	;	the source value in operand area will be marked as zero so
	;	condition code determination will still work properly.
	;

	;
	;	UNPACK_FLOAT - Unpack a Floating Value to OPERAND1
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = Input Floating Value
	;
	;		returns with	OPERAND1 = Converted Value
	;
UNPACK_FLOAT:				; entrance
	CLRL	OPERAND1(FP)		; clear the zero and sign flags
	EXTZV	#7,#8,R0,R1		; R1 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; floating value is reserved
1$:	INCB	ZERO1(FP)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN1(FP)		; indicate a negative value
3$:	MOVAB	-128(R1),POWER1(FP)	; store the unbiased exponent
	ROTL	#16,R0,R0		; unscramble the fraction
	BBSS	#23,R0,4$		; set the hidden bit
4$:	INSV	R0,#8,#24,FRACTION1+12(FP); store bits 8-31 of the fraction
	CLRB	FRACTION1+12(FP)	; clear bits 0-7 of the fraction
	CLRL	FRACTION1+8(FP) 	; extend the value to 64 bits
	CLRQ	FRACTION1(FP)		; extend the value to 128 bits
	RSB				; return
	;

	;
	;	UNPACK_DOUBLE - Unpack a Double Floating Value to OPERAND1
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0,R1 = Input Double Floating Value
	;
	;		returns with	OPERAND1 = Converted Value
	;
UNPACK_DOUBLE:				; entrance
	CLRL	OPERAND1(FP)		; clear the zero and sign flags
	EXTZV	#7,#8,R0,R2		; R2 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; double floating value is reserved
1$:	INCB	ZERO1(FP)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN1(FP)		; indicate a negative value
3$:	MOVAB	-128(R2),POWER1(FP)	; store the unbiased exponent
	ROTL	#16,R0,R0		; R0 = leading bits of the fraction
	BBSS	#23,R0,4$		; set the hidden bit
4$:	INSV	R0,#8,#24,FRACTION1+12(FP); store bits 40-63 of the fraction
	ROTL	#16,R1,R1		; R1 = trailing bits of the fraction
	MOVL	R1,FRACTION1+9(FP)	; store bits 8-39 of the fraction
	CLRB	FRACTION1+8(FP) 	; clear bits 0-7 of the fraction
	CLRQ	FRACTION1(FP)		; extend the fraction to 128 bits
	RSB				; return
	;

	;
	;	UNPACK_GRAND1 - Unpack a Grand Floating Value to OPERAND1
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0,R1 = Input Grand Floating Value
	;
	;		returns with 	OPERAND1 = Converted Value
	;
UNPACK_GRAND1:				; entrance
	MOVAB	OPERAND1(FP),R2 	; R2 = operand area location
	BRB	UNPACK_GRAND		; enter the main routine
	;
	;	UNPACK_GRAND2 - Unpack a Grand Floating Value to OPERAND2
	;
	;		entered by sobroutine branching
	;
	;		parameter:	R0,R1 = Input Grand Floating Value
	;
	;		returns with	OPERAND2 = Converted Value
	;
UNPACK_GRAND2:				; entrance
	MOVAB	OPERAND2(FP),R2 	; R2 = operand area location
	BRB	UNPACK_GRAND		; enter the main routine
	;
	;	UNPACK_GRAND3 - Unpack a Grand Floating Value to OPERAND3
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0,R1 = Input Grand Floating Value
	;
	;		returns with	OPERAND3 = Converted Value
	;
UNPACK_GRAND3:				; entrance
	MOVAB	OPERAND3(FP),R2 	; R2 = operand area location
      ; BRB	UNPACK_GRAND		; enter the main routine
	;
	;	UNPACK_GRAND - Unpack a Grand Floating Value
	;
	;		entered by subroutine branching
	;	
	;		parameters:	R0,R1 = Input Grand Floating Value
	;				R2 = Location of Destination Area
	;
UNPACK_GRAND:				; entrance
	CLRL	(R2)			; clear the zero and sign flags
	EXTZV	#4,#11,R0,R3		; R3 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; grand floating value is reserved
1$:	INCB	ZERO(R2)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN(R2)		; indicate a negative value
3$:	MOVAB	-1024(R3),POWER(R2)	; store the unbiased exponent
	ROTL	#16,R0,R0		; R0 = leading bits of the fraction
	BBSS	#20,R0,4$		; set the hidden bit
4$:	INSV	R0,#11,#21,FRACTION+12(R2); store bits 43-63 of the fraction
	ROTL	#16,R1,R1		; R1 = trailing bits of the fraction
	INSV	R1,#11,#32,FRACTION+8(R2); store bits 11-42 of the fraction
	INSV	#0,#0,#11,FRACTION+8(R2); clear bits 0-10 of the fraction
	CLRQ	FRACTION(R2)		; extend the fraction to 128 bits
	RSB				; return
	;

	;
	;	UNPACK_HUGE1 - Unpack a Huge Floating Value to OPERAND1
	;
	;		entered by subroutine branching
	;	
	;		parameter:	R0,R1,R2,R3 = Input Huge Value
	;
	;		returns with	OPERAND1 = Converted Value
	;
UNPACK_HUGE1:				; entrance
	MOVAB	OPERAND1(FP),R4 	; R4 = operand area location
	BRB	UNPACK_HUGE		; enter the main routine
	;
	;	UNPACK_HUGE2 - Unpack a Huge Floating Value to OPERAND2
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0,R1,R2,R3 = Input Huge Value
	;
	;		returns with 	OPERAND2 = Converted Value
	;
UNPACK_HUGE2:				; entrance
	MOVAB	OPERAND2(FP),R4 	; R4 = operand area location
	BRB	UNPACK_HUGE		; enter the main routine
	;
	;	UNPACK_HUGE3 - Unpack a Huge Floating Value to OPERAND3
	;
	;		entered by subroutine branching
	;	
	;		parameter:	R0,R1,R2,R3 = Input Huge Value
	;
	;		returns with 	OPERAND3 = Converted Value
	;
UNPACK_HUGE3:				; entrance
	MOVAB	OPERAND3(FP),R4 	; R4 = operand area location
      ; BRB	UNPACK_HUGE		; enter the main routine
	;
	;	UNPACK_HUGE - Unpack a Huge Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameters:	R0,R1,R2,R3 = Input Huge Value
	;				R4 = Destination Area Location
	;
UNPACK_HUGE:				; entrance
	CLRL	(R4)			; clear the zero and sign flags
	EXTZV	#0,#15,R0,R5		; R5 = biased exponent
	BNEQ	2$			; it's not zero - bypass
	BBC	#15,R0,1$		; no sign bit - skip
	BRW	OPERAND_FAULT		; huge floating value is reserved
1$:	INCB	ZERO(R4)		; indicate a zero value
	RSB				; return
2$:	BBC	#15,R0,3$		; no sign bit - skip
	INCB	SIGN(R4)		; indicate a negative value
3$:	MOVAB	-16384(R5),POWER(R4)	; store the unbiased exponent
	ROTL	#16,R0,R0		; R0 = leading bits of the fraction
	BBSS	#16,R0,4$		; set the hidden bit
4$:	INSV	R0,#15,#17,FRACTION+12(R4); store bits 111-127 of the fraction
	ROTL	#16,R1,R1		; R1 = next bits of the fraction
	INSV	R1,#15,#32,FRACTION+8(R4); store bits 79-110 of the fraction
	ROTL	#16,R2,R2		; R2 = next bits of the fraction
	INSV	R2,#15,#32,FRACTION+4(R4); store bits 47-78 of the fraction
	ROTL	#16,R3,R3		; R3 = next bits of the fraction
	INSV	R3,#15,#32,FRACTION(R4) ; store bits 15-46 of the fraction
	INSV	#0,#0,#15,FRACTION(R4)	; clear bits 0-14 of the fraction
	RSB				; return
	;

	;
	;	PACK_FLOAT - Pack a Floating Value from OPERAND1
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = Source Value
	;
	;		returns with	R0 = Converted Floating Value
	;
PACK_FLOAT:				; entrance
	BLBC	ZERO1(FP),2$		; value is not zero - bypass
1$:	CLRL	R0			; clear the value
	RSB				; return
2$:	BBC	#7,FRACTION1+12(FP),3$	; rounding bit is zero - bypass
	ADDL2	#1@8,FRACTION1+12(FP)	; round the value
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER1(FP)		; increment the exponent
	CLRL	R0			; clear the fraction bits
	BRB	4$			; bypass
3$:	ROTL	#8,FRACTION1+12(FP),R0	; load the fraction
4$:	ADDL3	#128,POWER1(FP),R1	; R1 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,OPERAND1(FP) 	; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#255,R1 		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	INSV	R1,#7,#9,R0		; insert exponent and clear sign
	BLBC	SIGN1(FP),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;
	;	PACK_DOUBLE - Pack a Double Floating Value from OPERAND1
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = Source Value
	;
	;		returns with	R0,R1 = Converted Double Value
	;
PACK_DOUBLE:				; entrance
	BLBC	ZERO1(FP),2$		; value is not zero - bypass
1$:	CLRQ	R0			; clear the value
	RSB				; return
2$:	BBC	#7,FRACTION1+8(FP),3$	; rounding bit is zero - bypass
	ADDL2	#1@8,FRACTION1+8(FP)	; round the value
	ADWC	#0,FRACTION1+12(FP)	; propagate any carry
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER1(FP)		; increment the exponent
	CLRQ	R0			; clear the fraction bits
	BRB	4$			; bypass
3$:	ROTL	#8,FRACTION1+12(FP),R0	; load the first part of the fraction
	ROTL	#16,FRACTION1+9(FP),R1	; load the second part of the fraction
4$:	ADDL3	#128,POWER1(FP),R2	; R2 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,OPERAND1(FP) 	; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#255,R2 		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	INSV	R2,#7,#9,R0		; insert exponent and clear sign
	BLBC	SIGN1(FP),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;
	;	PACK_GRAND1 - Pack a Grand Floating Value from OPERAND1
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = Source Value
	;
	;		returns with 	R0,R1 = Converted Grand Value
	;
PACK_GRAND1:				; entrance
	MOVAB	OPERAND1(FP),R2 	; R2 = location of operand area
	BRB	PACK_GRAND		; enter the main routine
	;
	;	PACK_GRAND2 - Pack a Grand Floating Value from OPERAND2
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND2 = Source Value
	;
	;		returns with	R0,R1 = Converted Grand Value
	;
PACK_GRAND2:				; entrance
	MOVAB	OPERAND2(FP),R2 	; R2 = location of operand area
	BRB	PACK_GRAND		; enter the main routine
	;
	;	PACK_GRAND3 - Pack a Grand Floating Value from OPERAND3
	;
	;		entered by subroutine branching
	;
	;		parameter;	OPERAND3 = Source Value
	;
	;		returns with	R0,R1 = Converted Grand Value
	;
PACK_GRAND3:				; entrance
	MOVAB	OPERAND3(FP),R2 	; R2 = location of operand area
      ; BRB	PACK_GRAND		; enter the main routine
	;
	;	PACK_GRAND - Pack a Grand Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	R2 = Location of Source Value
	;
	;		returns with 	R0,R1 = Converted Grand Value
	;
PACK_GRAND:				; entrance
	BLBC	ZERO(R2),2$		; value is not zero - bypass
1$:	CLRQ	R0			; clear the value
	RSB				; return
2$:	BBC	#10,FRACTION+8(R2),3$	; rounding bit is zero - bypass
	ADDL2	#1@11,FRACTION+8(R2)	; round the value
	ADWC	#0,FRACTION+12(R2)	; propagate any carry
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER(R2)		; increment the exponent
	CLRQ	R0			; clear the fraction bits
	BRB	4$			; bypass
3$:	ROTL	#5,FRACTION+12(R2),R0	; load the first part of the fraction
	EXTV	#11,#32,FRACTION+8(R2),R1 ; load second part of the fraction
	ROTL	#16,R1,R1		; unscramble the bits
4$:	ADDL3	#1024,POWER(R2),R3	; R3 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,(R2) 		; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#2047,R3		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	INSV	R3,#4,#12,R0		; insert exponent and clear sign
	BLBC	SIGN(R2),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;
	;	PACK_HUGE1 - Pack a Huge Floating Value from OPERAND1
	;
	;		entered by subroutine branching
	;	
	;		parameter:	OPERAND1 = Source Value
	;
	;		returns with	R0,R1,R2,R3 = Converted Huge Value
	;
PACK_HUGE1:				; entrance
	MOVAB	OPERAND1(FP),R4 	; R4 = operand area location
	BRB	PACK_HUGE		; enter the main routine
	;
	;	PACK_HUGE2 - Pack a Huge Floating Value from OPERAND2
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND2 = Source Value
	;
	;		returns with	R0,R1,R2,R3 = Converted Huge Value
	;
PACK_HUGE2:				; entrance
	MOVAB	OPERAND2(FP),R4 	; R4 = operand area location
	BRB	PACK_HUGE		; enter the main routine
	;
	;	PACK_HUGE3 - Pack a Huge Floating Value from OPERAND3
	;
	;		entered by subroutine branching
	;	
	;		parameter:	OPERAND3 = Source Value
	;
	;		returns with	R0,R1,R2,R3 = Converted Huge Value
	;
PACK_HUGE3:				; entrance
	MOVAB	OPERAND3(FP),R4 	; R4 = operand area location
      ; BRB	PACK_HUGE		; enter the main routine
	;
	;	PACK_HUGE - Pack a Huge Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	R4 = Location of Source Value
	;
	;		returns with	R0,R1,R2,R3 = Converted Huge Value
	;
PACK_HUGE:				; entrance
	BLBC	ZERO(R4),2$		; value is not zero - bypass
1$:	CLRQ	R0			; clear the first part of the value
	CLRQ	R2			; clear the second part of the value
	RSB				; return
2$:	BBC	#14,FRACTION(R4),3$	; rounding bit is zero - bypass
	ADDL2	#1@15,FRACTION(R4)	; round the value
	ADWC	#0,FRACTION+4(R4)	; propagate carry into third part
	ADWC	#0,FRACTION+8(R4)	; propagate carry into second part
	ADWC	#0,FRACTION+12(R4)	; propagate carry into first part
	BCC	3$			; no carry out of fraction - bypass
	INCL	POWER(R4)		; increment the exponent
	CLRQ	R0			; clear first part of the fraction
	CLRQ	R2			; clear second part of the fraction
	BRB	4$			; bypass
3$:	ASHL	#1,FRACTION+12(R4),R0	; load first part of the fraction
	EXTV	#15,#32,FRACTION+8(R4),R1 ; load second part of the fraction
	ROTL	#16,R1,R1		; reverse the words
	EXTV	#15,#32,FRACTION+4(R4),R2 ; load third part of the fraction
	ROTL	#16,R2,R2		; reverse the words
	EXTV	#15,#32,FRACTION(R4),R3 ; load	third part of the fraction
	ROTL	#16,R3,R3		; reverse the words
4$:	ADDL3	#16384,POWER(R4),R5	; R5 = biased exponent
	BGTR	5$			; it's greater than zero - bypass
	MOVL	#1,(R4) 		; mark the original value as zero
	BBC	#PSL_FU,PSL(FP),1$	; no fault enabled - return zero
	BRW	UNDERFLOW		; process the floating underflow
5$:	CMPL	#32767,R5		; is the exponent too large ?
	BGEQ	6$			; no - skip
	BRW	OVERFLOW		; process the floating overflow
6$:	MOVW	R5,R0			; insert exponent and clear sign
	BLBC	SIGN(R4),7$		; is the value negative ?
	BBSS	#15,R0,7$		; yes - set the sign bit
7$:	RSB				; return
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		      Arithmetic Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The routines which follow perform the actual floating
	;	arithmetic operations of the Emulator. These routines all
	;	work with the internal floating representation so only one
	;	routine is needed for each type of operation. However, since
	;	multiplication and division are comparatively slow operations
	;	separate routines have been included for the grand and huge
	;	versions of these operations so the grand operation will not
	;	be slowed to the speed of the huge operation.
	;
	;	    The algorithms for the individual routines will be
	;	described in the routines themselves. The following discussion
	;	will be limited to a description of our internal floating 
	;	format.
	;
	;
	;	Internal Floating Representation
	;	--------------------------------
	;
	;	    All of the floating arithmetic operations used by the 
	;	Emulator are performed using an internal floating format
	;	which is much easier to work with than any of the hardware
	;	floating representations and which is sufficiently accurate
	;	to represent all of the hardware representations. The format
	;	is also used as an intermediate representation for emulating
	;	the conversion instructions.
	;
	;	    The internal representation has the following four fields:
	;
	;
	;		ZERO		is a one byte field whose low order
	;				bit indicates that the represented
	;				value is nonzero.
	;
	;		SIGN		is a one byte field whose low order
	;				bit indicates that the represented
	;				value is negative. If the low order
	;				bit of ZERO is set then this field
	;				must be zero.
	;
	;		POWER		is a longword field which contains the
	;				exponent of the power of two which
	;				is used to scale the fraction
	;
	;		FRACTION	is a 128 bit field (four longwords)
	;				which hold the fraction as a single
	;				128 bit value. The decimal point is
	;				assumed to be at the end of the 
	;				fraction next to the high order bit.
	;				The fraction is considered to be a
	;				a positive value and is normalized
	;				if the high order bit is one.
	;
	;
	;	Three areas OPERAND1, OPERAND2, OPERAND3 are available for
	;	holding values in the internal representation. The name of
	;	of a field of one of these areas is found by appending the
	;	trailing digit of the area name to the field name. Thus
	;	POWER2 is the POWER field of OPERAND2.
	;

	;
	;	NEGATE_REAL - Negate a Real Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with 	OPERAND1 = The Negated Result
	;
	;	Discussion
	;	
	;	    If the value is nonzero, then the sign of the value
	;	is complemented.
	;
NEGATE_REAL:				; entrance
	BLBS	ZERO1(FP),1$		; don't negate zero
	XORB2	#1,SIGN1(FP)		; complement the sign
1$:	RSB				; return
	;
	;	FLOAT_LONG - Convert a Longword to a Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = The Longword Value
	;
	;		returns with	OPERAND1 = The Converted Value
	;
	;	Discussion
	;
	;	    The longword is converted to double floating using the
	;	hardware and then to the internal representation by one of
	;	the unpack routines.
	;
FLOAT_LONG:				; entrance
	CVTLD	R0,R0			; convert the value to double floating
	BSBW	UNPACK_DOUBLE		; unpack the value
	RSB				; return
	;

	;
	;	FIX_REAL - Convert a Floating Value to a Longword (Truncated)
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with	R0 = Longword Result
	;
	;	Discussion
	;
	;	    The exponent is used to determine where in the fraction
	;	the decimal point lies and any part of the integer part that
	;	exists within the signed fraction is extracted. If the
	;	fraction contains bits of higher order than those extracted,
	;	then the V bit is set in the user's PSL to indicate an integer
	;	overflow.
	;
FIX_REAL:				; entrance
	CLRL	R0			; clear the returned value
	BLBS	ZERO1(FP),2$		; the value is zero - return
	MNEGL	POWER1(FP),R1		; R1 = negated exponent
	BGEQ	2$			; value is less than one - return
	CMPL	#32,POWER1(FP)		; is the decimal point deep inside ?
	BLSS	3$			; yes - bypass
	EXTZV	R1,POWER1(FP),FRACTION1+16(FP),R0 ; extract leading bits
	BLBC	SIGN1(FP),1$		; the value is positive - skip
	MNEGL	R0,R0			; negate the value
1$:	ROTL	#1,R0,R1		; position the sign bit
	XORB2	SIGN1(FP),R1		; complement it if negative value
	BLBC	R1,2$			; the sign is correct - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
2$:	RSB				; return
3$:	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
	MOVAB	160(R1),R1		; switch origin to previous longword
	BLEQ	2$			; no nonzero bits - return
	EXTZV	R1,#32,FRACTION1-4(FP),R0 ; extract 32 bits from the fraction
	SUBL3	R1,#32,R1		; compute the bits to clear
	BLEQ	4$			; no bits to clear - bypass
	INSV	#0,#0,R1,R0		; clear some low order bits
4$:	BLBC	SIGN1(FP),2$		; the value is positive - return
	MNEGL	R0,R0			; complement the extracted bits
	RSB				; return
	;

	;
	;	ROUND_REAL - Convert a Floating Value to a Longword (Rounded)
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with	R0 = The Longword Result
	;
	;	Discussion
	;
	;	    The exponent of the floating value is used to determine
	;	where the decimal point goes within the signed fraction and
	;	whatever part of the integer part exists within the fraction
	;	is extracted. If the bit immediatly below the decimal point is
	;	nonzero, then the integer part is rounded by adding a value
	;	of one with the same sign as the floating value. If the value
	;	contains significant bits of higher order than those in the
	;	fraction or if overflow occured during the rounding operation
	;	then the V bit is set in the user's PSL to indicate an integer
	;	overflow.
	;
ROUND_REAL:				; entrance
	CLRL	R0			; clear the returned value
	BLBS	ZERO1(FP),3$		; the value is zero - return
	MNEGL	POWER1(FP),R1		; R1 = negated exponent
	BGTR	3$			; the value is less than 0.5 - return
	CMPL	#32,POWER1(FP)		; is the decimal point deep inside ?
	BLSS	4$			; yes - bypass
	EXTZV	R1,POWER1(FP),FRACTION1+16(FP),R0 ; extract some leading bits
	ADDL2	#63,R1			; *** equivalent sequence to ***
	BBC	R1,FRACTION1+8(FP),1$	; *** get around hardware problem ***
;	DECL	R1			; compute the rounding position
;	BBC	R1,FRACTION1+16(FP),1$	; rounding bit is clear - skip
	INCL	R0			; round the extracted bits
	BCC	1$			; no carry - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
1$:	BLBC	SIGN1(FP),2$		; is the floating value negative
	MNEGL	R0,R0			; yes - complement the value
2$:	ROTL	#1,R0,R1		; position the sign bit
	XORB2	SIGN1(FP),R1		; complment it if negative value
	BLBC	R1,3$			; the sign is correct - skip
	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
3$:	RSB				; return
4$:	BISL2	#PSLM_V,PSL(FP) 	; indicate an integer overflow
	MOVAB	160(R1),R1		; switch origin to previous longword
	BLEQ	3$			; no nonzero bits - return
	EXTZV	R1,#32,FRACTION1-4(FP),R0 ; extract 32 bits from the fraction
	SUBL3	R1,#32,R2		; compute the bits to clear
	BLSS	5$			; possible rounding - skip
	INSV	#0,#0,R2,R0		; clear some low order bits
	BRB	6$			; bypass
5$:	DECL	R1			; compute the rounding bit
	BBC	R1,FRACTION1-4(FP),6$	; the rounding bit is clear - skip
	INCL	R0			; round the extracted bits
6$:	BLBC	SIGN1(FP),3$		; the value is positive - return
	MNEGL	R0,R0			; negate the value
	RSB				; return
	;

	;
	;	FRACTION_REAL - Isolate the Fraction Part of a Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Floating Value
	;
	;		returns with	OPERAND1 = The Fractional Part
	;
	;	Discussion
	;
	;	    The exponent is used to determine the position of the
	;	decimal point within the fraction and all of the bits of
	;	the fraction above the decimal point are cleared. The result
	;	is then normalized.
	;
FRACTION_REAL:				; entrance
	BLBS	ZERO1(FP),1$		; the value is zero - return
	MOVL	POWER1(FP),R0		; R0 = the exponent
	BLEQ	1$			; the value is all fraction - return
	EXTZV	#0,#5,R0,R1		; R1 = bits to clear in last longword
	ASHL	#-5,R0,R0		; R0 = number of longwords to clear
	CMPL	#4,R0			; will we clear the whole value ?
	BGTR	2$			; no - bypass
	MOVL	#1,OPERAND1(FP) 	; mark the value as zero
1$:	RSB				; return
2$:	SUBL3	R1,#32,R2		; compute the last clear position
	MOVAL	FRACTION1+16(FP),R3	; R3 = clear index
	BRB	4$			; enter the clear loop
3$:	CLRL	-(R3)			; clear a longword of the fraction
4$:	SOBGEQ	R0,3$			; more longwords to clear - loop
	INSV	#0,R2,R1,-4(R3) 	; perform the last clear
	BSBW	NORMALIZE		; normalize the result
	RSB				; return
	;

	;
	;	ADD_REAL - Add Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND1 = First Floating Operand
	;				OPERAND2 = Second Floating Operand
	;
	;		returns with	OPERAND1 = The Floating Result
	;
	;	Discussion
	;
	;	    This routine performs the addition of floating values
	;	in the internal representation in such a way that the sum is
	;	the exact sum truncated to 127 or 128 significant bits. This
	;	precision is sufficient for performing grand and huge addition
	;	since these operations are based on truncating the exact sum
	;	to smaller numbers of significant digits.
	;
	;	    After preliminary checks for zero operands, the general
	;	addition is performed by first identifying a primary and a
	;	secondary operand with the primary operand being sufficiently
	;	large that it will not need to be shifted to align the values.
	;	This choice is made by examining the exponents. If the 
	;	operands have opposite signs, the fractions are further 
	;	compared so the magnitude of the primary operand is larger 
	;	than the magnitude of the secondary operand. The primary and
	;	secondary operand fractions are loaded into groups of 
	;	registers and the primary operand is shifted to the right one
	;	bit to allow for overflows. The secondary operand fraction is
	;	shifted to line it up with the primary operand fraction. If
	;	the signs of the operands are not the same then a record is 
	;	made if any significant bits are lost during the alignment of
	;	the secondary operand fraction. The resulting fractions are
	;	added or subtracted and an additional one is subtracted if
	;	lost bits were detected in the test made above. The result
	;	is then normalized.
	;
ADD_REAL:				; entrance
	MOVAB	OPERAND1(FP),R0 	; R0 = location of first operand
	MOVAB	OPERAND2(FP),R1 	; R1 = location of second operand
	BLBS	ZERO(R1),3$		; second operand is zero - bypass
	BLBC	ZERO(R0),1$		; first operand is not zero - bypass
	MOVL	OPERAND2(FP),OPERAND1(FP) ; copy the sign and zero flags
	MOVL	POWER2(FP),POWER1(FP)	; copy the exponent
	MOVQ	FRACTION2(FP),FRACTION1(FP) ; copy second half of fraction
	MOVQ	FRACTION2+8(FP),FRACTION1+8(FP) ; copy first half of fraction
	RSB				; done
1$:	CMPL	POWER(R0),POWER(R1)	; compare the exponents
	BGTR	5$			; first is greater - bypass
	BLSS	4$			; second is greater - bypass
	CMPB	SIGN(R0),SIGN(R1)	; compare the signs
	BEQL	5$			; they're equal - bypass
	MOVAB	FRACTION+16(R0),R2	; R2 = position past first fraction
	MOVAB	FRACTION+16(R1),R3	; R3 = position past second fraction
	MOVL	#4,R4			; R4 = loop counter
2$:	CMPL	-(R2),-(R3)		; compare two fraction longwords
	BGTRU	5$			; first is greater - bypass
	BLSSU	4$			; second is greater - bypass
	SOBGTR	R4,2$			; more longwords to compare - loop
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
3$:	RSB				; return
4$:	MOVL	R0,R1			; R1 = secondary operand location
	MOVAB	OPERAND2(FP),R0 	; R0 = primary operand location
5$:	SUBL3	POWER(R1),POWER(R0),R2	; R2 = exponent difference
	ADDL3	#1,POWER(R0),POWER1(FP) ; store the result exponent
	XORB3	SIGN(R0),SIGN(R1),R3	; R3 = subtraction flag
	MOVL	(R0),OPERAND1(FP)	; store the result sign and zero flag
	ASHQ	#-1,FRACTION(R1),R4	; R4 = last shifted secondary longword
	ASHQ	#-1,FRACTION+4(R1),R5	; R5 = previous shifted longword
	ASHQ	#-1,FRACTION+8(R1),R6	; R6,R7 = first two shifted longwords
	BBCC	#31,R7,6$		; clear the high order bit
6$:	ASHQ	#-1,FRACTION(R0),FRACTION1(FP) ; shift fourth result longword
	ASHL	#1,FRACTION1+4(FP),FRACTION1+4(FP) ; position third longword
	ASHQ	#-1,FRACTION+4(R0),FRACTION1+4(FP) ; shift third longword
	ASHL	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; position second longword
	ASHQ	#-1,FRACTION+8(R0),FRACTION1+8(FP) ; shift first two longwords
	BBCC	#31,FRACTION1+12(FP),7$ ; clear the high order bit
7$:	MOVL	#1,R8			; R8 = negation adjustment
	CMPL	#127,R2 		; is the shift count large ?
	BGEQ	8$			; no - skip
	MOVZBL	#127,R2 		; yes - use a smaller one
8$:	TSTL	R2			; is the shift count zero ?
	BEQL	12$			; yes - bypass
	CMPL	#32,R2			; is the shift more than a longword ?
	BGEQ	10$			; no - bypass
	TSTL	R4			; is the last longword zero ?
	BEQL	9$			; no - skip
	CLRL	R8			; clear the negation adjustment
9$:	SUBL2	#32,R2			; decrement the shift count
	MOVQ	R5,R4			; shift the last two longwords
	MOVL	R7,R6			; shift the previous longword
	CLRL	R7			; clear the leading longword
	BRB	8$			; try again
10$:	MNEGL	R2,R9			; R9 = - shift count
	CMPZV	#0,R2,R4,#0		; are the low order bits zero ?
	BEQL	11$			; yes - skip
	CLRL	R8			; clear the negation adjustment
11$:	ASHQ	R9,R4,R4		; shift the last longword
	ASHL	R2,R5,R5		; position the previous longword
	ASHQ	R9,R5,R5		; shift the previous longword
	ASHL	R2,R6,R6		; position the previous longword
	ASHQ	R9,R6,R6		; shift the first two longwords
12$:	BLBC	R3,13$			; not subtraction - bypass
	MCOML	R7,R7			; complement first longword
	MCOML	R6,R6			; complement second longword
	MCOML	R5,R5			; complement third longword
	MCOML	R4,R4			; complement last longword
	ADDL2	R8,R4			; add the negation adjustment
	ADWC	#0,R5			; propagate any carry
	ADWC	#0,R6			; propagate any carry
	ADWC	#0,R7			; propagate any carry
13$:	ADDL2	R4,FRACTION1(FP)	; add the fourth longwords
	ADWC	R5,FRACTION1+4(FP)	; add the third longwords
	ADWC	R6,FRACTION1+8(FP)	; add the second longwords
	ADWC	R7,FRACTION1+12(FP)	; add the leading longwords
	BSBW	NORMALIZE		; normalize the result
	RSB				; return
	;

	;
	;	MULTIPLY_GRAND - Multiply Two Grand Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND2 = First Floating Factor
	;				OPERAND3 = Second Floating Factor
	;
	;		returns with	OPERAND1 = The 64 Bit Floating Product
	;				R0 = Normalization Shift Count
	;
	;	Discussion
	;
	;	    This routine forms the product of two floating values 
	;	in the internal representation and deliberately limits the
	;	accuracy to 64 bits. Only the high order 64 bits of each of
	;	the operand fractions is used and the result is the high
	;	order 64 bits of the exact product. The remaining bits of the
	;	fraction are zero. Upon return the register R0 contains the
	;	distance the product was shifted during normalization.
	;
MULTIPLY_GRAND: 			; entrance
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	CLRL	R0			; clear the shift count
	BLBS	ZERO2(FP),2$		; first operand is zero - return
	BLBS	ZERO3(FP),2$		; second operand is zero - return
	CLRB	ZERO1(FP)		; clear the zero flag
	MOVL	#2,R0			; R0 = number of longwords to multiply
	MOVAB	FRACTION2+8(FP),R1	; R1 = location of first factor
	MOVAB	FRACTION3+8(FP),R2	; R2 = location of second factor
	MOVAB	FRACTION1(FP),R3	; R3 = location for product
	BSBW	MULTIPLY		; multiply the quadwords
	CLRL	R0			; clear the shift count
	ADDL3	POWER2(FP),POWER3(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN2(FP),SIGN3(FP),SIGN1(FP) ; compute the sign
	BBS	#31,FRACTION1+12(FP),1$ ; result is normalized - bypass
	INCL	R0			; set the shift count to one
	DECL	POWER1(FP)		; decrement the exponent
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the fraction
	BBC	#31,FRACTION1+4(FP),1$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1+8(FP)	; set the low order bit
1$:	CLRQ	FRACTION1(FP)		; extend the fraction to an octaword
2$:	RSB				; return
	;

	;
	;	MULTIPLY_HUGE - Multiply Two Huge Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND2 = First Floating Factor
	;				OPERAND3 = Second Floating Factor
	;
	;		returns with	OPERAND1 = 128 Bit Floating Product
	;				R0 = Normalization Shift Count
	;
	;	Discussion
	;	
	;	    This routine computes the product of two floating values
	;	in the internal representation. The fraction of the result 
	;	consists of the high order 128 bits of the exact product.
	;	Upon return the register R0 contains the distance the product
	;	was shifted during normalization.
	;
MULTIPLY_HUGE:				; entrance
	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	CLRL	R0			; clear the shift count
	BLBS	ZERO2(FP),2$		; first operand is zero - return
	BLBS	ZERO3(FP),2$		; second operand is zero - return
	CLRB	ZERO1(FP)		; clear the zero flag
	MOVL	#4,R0			; R0 = number of longwords to multiply
	MOVAB	FRACTION2(FP),R1	; R1 = location of first factor
	MOVAB	FRACTION3(FP),R2	; R2 = location of second factor
	MOVAB	TEMP(FP),R3		; use temporary area for result
	BSBW	MULTIPLY		; perform the multiplication
	CLRL	R0			; clear the shift count
	ADDL3	POWER2(FP),POWER3(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN2(FP),SIGN3(FP),SIGN1(FP) ; compute the sign
	MOVQ	TEMP+16(FP),FRACTION1(FP) ; insert second part of fraction
	MOVQ	TEMP+24(FP),FRACTION1+8(FP) ; insert first part of fraction
	BLSS	2$			; fraction is normalized - bypass
	INCL	R0			; set the shift count to one
	DECL	POWER1(FP)		; decrement the exponent
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the first part
	BBC	#31,FRACTION1+4(FP),1$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1+8(FP)	; set the low bit in the first part
1$:	ASHQ	#1,FRACTION1(FP),FRACTION1(FP) ; normalize the second part
	BBC	#31,TEMP+12(FP),2$	; low order bit should be clear - skip
	BISL2	#1,FRACTION1(FP)	; set the low bit in the second part
2$:	RSB				; return
	;

	;
	;	DIVIDE_GRAND - Divide Two Grand Floating Values
	;
	;		entered by subroutine branching
	;
	;		parameters:	OPERAND2 = The Floating Dividend
	;				OPERAND3 = The Floating Divisor
	;	
	;		returns with	OPERAND1 = 64 Bit Floating Quotient
	;
	;	Discussion
	;	
	;	    This routine computes the quotient of two floating values
	;	in the internal representation. The fractions of the two input
	;	values consist of the high order 64 bits of the two operand 
	;	fractions and the fraction of the quotient consists of the
	;	high order 63 or 64 bits of the exact quotient. The remaining
	;	bits of the fraction are set to zero. If the divisor is zero
	;	then a floating division by zero fault is signaled.
	;
DIVIDE_GRAND:				; entrance
	BLBC	ZERO3(FP),1$		; divisor is not zero - skip
	BRW	DIVIDE_FAULT		; process the floating divide fault
1$:	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	BLBS	ZERO2(FP),3$		; dividend is zero - bypass
	ASHQ	#-1,FRACTION2+8(FP),FRACTION2+8(FP) ; normalize for division
	BBCC	#31,FRACTION2+12(FP),2$ ; clear the high order bit
2$:	INCL	POWER2(FP)		; increment the exponent
	MOVL	#2,R0			; R0 = number of longwords in divisor
	MOVAB	FRACTION2(FP),R1	; R1 = dividend location
	MOVAB	FRACTION3+8(FP),R2	; R2 = divisor location
	MOVAB	FRACTION1+8(FP),R3	; R3 = quotient area location
	BSBW	DIVIDE			; perform the division
	CLRB	ZERO1(FP)		; indicate a nonzero result
	SUBL3	POWER3(FP),POWER2(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN3(FP),SIGN2(FP),SIGN1(FP) ; compute the sign
	CLRQ	FRACTION1(FP)		; extend the quotient to 128 bits
	BBS	#31,FRACTION1+12(FP),3$ ; the result is normalized - bypass
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the quotient
	DECL	POWER1(FP)		; increment the exponent
3$:	RSB				; return
	;

	;
	;	DIVIDE_HUGE - Divide Two Huge Floating Values
	;
	;		entered by subroutine branching
	;	
	;		parameters:	OPERAND2 = The Floating Dividend
	;				OPERAND3 = The Floating Divisor
	;
	;		returns with	OPERAND1 = 128 Bit Floating Quotient
	;
	;	Discussion
	;	
	;	    This routine computes the quotient of two floating values
	;	in the internal representation. The fraction of the quotient
	;	consists of the high order 127 or 128 bits of the exact 
	;	quotient. If the divisor is zero, then a floating divide by
	;	zero fault is signaled.
	;
DIVIDE_HUGE:				; entrance
	BLBC	ZERO3(FP),1$		; the divisor is not zero - skip
	BRW	DIVIDE_FAULT		; process the floating divide fault
1$:	MOVL	#1,OPERAND1(FP) 	; mark the result as zero
	BLBS	ZERO2(FP),6$		; dividend is zero - bypass
	CLRQ	TEMP(FP)		; clear the last octaword of dividend
	CLRQ	TEMP+8(FP)		; clear the last octaword of dividend
	ASHQ	#-1,FRACTION2(FP),TEMP+16(FP) ; move last part of dividend
	ASHQ	#-1,FRACTION2+8(FP),TEMP+24(FP) ; move first part of dividend
	INCL	POWER2(FP)		; increment the exponent
	BBCC	#31,TEMP+20(FP),2$	; clear a sign extension bit
2$:	BLBC	FRACTION2+8(FP),3$	; should the bit have been set ?
	BBSS	#31,TEMP+20(FP),3$	; yes - set it
3$:	BBCC	#31,TEMP+28(FP),4$	; clear the high order bit of dividend
4$:	MOVL	#4,R0			; R0 = number of longwords in divisor
	MOVAB	TEMP(FP),R1		; R1 = location of dividend
	MOVAB	FRACTION3(FP),R2	; R2 = location of divisor
	MOVAB	FRACTION1(FP),R3	; R3 = location for quotient
	BSBW	DIVIDE			; perform the division
	CLRB	ZERO1(FP)		; mark the result as nonzero
	SUBL3	POWER3(FP),POWER2(FP),POWER1(FP) ; compute the exponent
	XORB3	SIGN3(FP),SIGN2(FP),SIGN1(FP) ; compute the sign
	BBS	#31,FRACTION1+12(FP),6$ ; the result is normalized - bypass
	ASHQ	#1,FRACTION1+8(FP),FRACTION1+8(FP) ; normalize the first part
	BBC	#31,FRACTION1+4(FP),5$	; should the low order bit be set ?
	BISL2	#1,FRACTION1+8(FP)	; yes - set the bit
5$:	ASHQ	#1,FRACTION1(FP),FRACTION1(FP) ; normalize the second part
	DECL	POWER1(FP)		; decrement the exponent
6$:	RSB				; return
	;

	;
	;	NORMALIZE - Normalize a Floating Value
	;
	;		entered by subroutine branching
	;
	;		parameter:	OPERAND1 = The Unnormalized Value
	;
	;		returns with	OPERAND1 = The Normalized Result
	;
	;	Discussion
	;
	;	    This routine normalizes a floating value in the internal
	;	representation so that the high order bit of the fraction is
	;	one. This is done by locating the high order significant bit
	;	of the fraction and then by shifting the fraction so that the
	;	bit appears in the proper position. The shift count is 
	;	subtracted from the exponent so the value does not change.
	;
NORMALIZE:				; entrance
	BLBS	ZERO1(FP),2$		; the value is zero - return
1$:	TSTL	FRACTION1+12(FP)	; test the first longword
	BLSS	2$			; value is already normalized - return
	BEQL	3$			; first longword is zero - bypass
	CVTLD	FRACTION1+12(FP),R0	; use hardware to find shift count
	EXTZV	#7,#6,R0,R0		; R0 = high order bit position + 1
	SUBL2	#32,R0			; R0 = - shift count
	MNEGL	R0,R1			; R1 = shift count
	ASHQ	R1,FRACTION1+8(FP),FRACTION1+8(FP) ; position first longword
	ASHL	R0,FRACTION1+8(FP),FRACTION1+8(FP) ; get second parts together
	ASHQ	R1,FRACTION1+4(FP),FRACTION1+4(FP) ; position second longword
	ASHL	R0,FRACTION1+4(FP),FRACTION1+4(FP) ; get other parts together
	ASHQ	R1,FRACTION1(FP),FRACTION1(FP) ; position last two longwords
	SUBL2	R1,POWER1(FP)		; increment the exponent
2$:	RSB				; return
3$:	SUBL2	#32,POWER1(FP)		; decrement the exponent
	TSTL	FRACTION1+8(FP) 	; test the second longword
	BEQL	4$			; it's zero - bypass
	MOVQ	FRACTION1+4(FP),FRACTION1+8(FP) ; shift first two longwords
	MOVL	FRACTION1(FP),FRACTION1+4(FP) ; shift third longword
	CLRL	FRACTION1(FP)		; clear the final longword
	BRB	1$			; finish up
4$:	SUBL2	#32,POWER1(FP)		; decrement the exponent
	TSTL	FRACTION1+4(FP) 	; test the third longword
	BEQL	5$			; it's zero - bypass
	MOVQ	FRACTION1(FP),FRACTION1+8(FP) ; position first two longwords
	CLRQ	FRACTION1(FP)		; clear the last two longwords
	BRB	1$			; finish up
5$:	SUBL2	#32,POWER1(FP)		; decrement the exponent
	TSTL	FRACTION1(FP)		; test the fourth longword
	BEQL	6$			; it's zero - bypass
	MOVL	FRACTION1(FP),FRACTION1+12(FP) ; position the first longword
	CLRL	FRACTION1+8(FP) 	; clear the second longword
	CLRQ	FRACTION1(FP)		; clear the last two longwords
	BRW	1$			; finish up
6$:	MOVL	#1,OPERAND1(FP) 	; mark the value as zero
	RSB				; return
	;

	;
	;	MULTIPLY - Unsigned Multiple Length Integer Multiply
	;
	;		entered by subroutine branching
	;
	;		parameters:	R0 = Size of Inputs in Longwords
	;				R1 = Location of First Factor
	;				R2 = Location of Second Factor
	;				R3 = Location of Destination Area
	;
	;	Discussion
	;
	;	    This routine computes the product of two multiple length
	;	unsigned integers and stores the unsigned product in a 
	;	specified area. The parameter R0 contains the number of 
	;	longwords in each of the input factors and the number of 
	;	longwords in the product is twice the value of R0. The 
	;	parameters R1 and R2 contain the locations of the input 
	;	factors and the parameter R3 contains the location of the
	;	area for the product.
	;
	;
	;	The Algorithm
	;
	;	    The algorithm used is perfectly straightforward. The
	;	second factor is multiplied by each of the unsigned longwords
	;	of the first factor and the aligned products are added to the
	;	destination area. The multiplications and additions are
	;	performed by a series of EMUL instructions in which the two
	;	factors are longwords from each of the factors and the added
	;	operand is formed by adding target longword of the result area
	;	and from carryover information from the previous iteration
	;	of the EMUL loop. The carryover information is formed by 
	;	adding the high order bits of the previous product, the 
	;	opposite factor for each factor longword which is negative
	;	from the previous multiplication, a one if the previous 
	;	carryover longword was negative, and a one if the previous
	;	additive operand was negative. Most of these contributions are
	;	compensations for the fact that the EMUL instruction assumes
	;	that the operands are signed.
	;
	;	    To show that the algorithm is correct the major step is
	;	to show that the EMUL operations do not loose information
	;	because of overflow. To show this we make use of the fact that
	;	for two's complemented addition and multiplication information
	;	only moves in the direction of the high order bits. Therefore,
	;	if the product fits into two unsigned longwords it is correct.
	;	The unsigned information input to each EMUL step is 
	;
	;		first factor <= 2^32-1
	;		second factor <= 2^32-1
	;		longword from result area <= 2^32-1
	;		unsigned carryover information <= 2^32-1
	;
	;	The output of the step is the product of the first two values
	;	plus the second two values. This does not exceed
	;	
	;		(2^32-1)^2+2*(2^32-1) = 2^64-1
	;
	;	which is representable in two unsigned longwords so the 
	;	output carryover information fits into an unsigned longword.
	;	Consequently no information can be lost during the EMUL steps.
	;	
	;
MULTIPLY:				; entrance
	CLRL	R4			; clear the loop index
1$:	CLRL	(R3)[R4]		; clear a longword of the result
	AOBLSS	R0,R4,1$		; more longwords to clear - loop
	CLRL	R4			; clear the loop index
2$:	CLRL	R5			; clear the inner loop index
	MOVL	(R1)+,R6		; R6 = next value from first factor
	MOVAL	(R3)+,R7		; R7 = area of product being affected
	CLRL	R9			; clear the carryover information
3$:	CLRL	R10			; clear the cell to take the carry
	ADDL2	(R7),R9 		; include value so far in carryover
	ADWC	#0,R10			; remember the carry
	MOVL	(R2)[R5],R8		; R8 = next value from second factor
	BGEQ	4$			; it's not negative - skip
	ADDL2	R6,R10			; make unsigned by adding other factor
4$:	BBC	#31,R6,5$		; first factor is not negative - skip
	ADDL2	R8,R10			; make unsigned by adding other factor
5$:	BBC	#31,R9,6$		; carryover is not negative - skip
	INCL	R10			; make unsigned by adding one
6$:	EMUL	R6,R8,R9,R8		; multiply factors including carryover
	MOVL	R8,(R7)+		; accumulate the product
	ADDL2	R10,R9			; form the new carryover
	AOBLSS	R0,R5,3$		; partial product not complete - loop
	MOVL	R9,(R7) 		; store the last part of the product
	AOBLSS	R0,R4,2$		; full product not complete - loop
	RSB				; return
	;

	;
	;	DIVIDE - Unsigned Multiple Length Integer Divide
	;
	;		entered by subroutine branching
	;
	;		parameters:	R0 = Size of the Divisor in Longwords
	;				R1 = Location of the Dividend
	;				R2 = Location of the Divisor
	;				R3 = Location of the Quotient Area
	;	
	;	Discussion
	;	
	;	    This routine performs unsigned multiple length division
	;	and develops a quotient and a remainder. The number of
	;	longwords in the divisor and in the quotient area is given
	;	by the parameter R0. The number of longwords in the divisor
	;	area is twice the value of R0. The parameter R1 is the 
	;	location of the dividend, R2 is the location of the divisor,
	;	and R3 is the location for the quotient. The remainder is
	;	formed in the low order R0 longwords of the dividend area.
	;	It is assumed that the high order bit of the divisor is one
	;	and that the high order bit of the dividend is zero. These
	;	conditions insure that the quotient will fit into the quotient
	;	area.
	;
	;
	;	The Algorithm
	;
	;	    The algorithm used is a variation of the classical divide
	;	and correct method which has been adapted for the above 
	;	specifications. The algorithm has been implemented using words
	;	rather than longwords because the word version is much easier
	;	to verify for correctness since there are no problems with 
	;	using signed arithmetic operations to performed unsigned
	;	arithmetic.
	;
	;	    We let A[0..2N-1] denote the dividend as an array of words
	;	with A[0] being the low order word, and N being twice the
	;	value of R0. Similarly we let B[0..N-1] denote the divisor and
	;	C[0..N-1]. The quotient will be developed in the array
	;	A[0..N-1]. The algorithm may be given as follows:
	;
	;
	;		Step 1.	Let I = N-1 and A[2N] = 0.
	;
	;			{ The use of A[2N] is only a simplification,
	;			  it does not really appear in the program. }
	;
	;		Step 2. Let Q = entier(A[I+N-1..I+N+1]/B[N-1]+1) and
	;			let R be the remainder from the division.
	;
	;			{ This operation is performed by a single
	;			  EDIV instruction. }
	;
	;		Step 3. Let X = b*B[N-1]+B[N-2]+1 and
	;			Y = Q*(b-B[N-2]-1)+b*R+A[I+N-2].
	;
	;			{ Here b denotes 2^16 which is the "base" of
	;			  the number system we are using. These values
	;			  are used to correct the quotient. }
	;
	;		Step 4. Let Y = Y-X. If  Y >= 0 then let Q = Q+1 and
	;			repeat this step.
	;
	;			{ When this step is complete the value of Q is
	;
	;			   entier(A[I+N-2..I+N+1]/(B[N-2..N-1]+1) }
	;
	;		Step 5. Let A[I..I+N] = A[I..I+N]-Q*B[0..N-1].
	;
	;		Step 6. Let C[I] = Q and if Q is too large then add
	;		 	the overflow to C[I+1..N-1]. If I > 2 then
	;			go to Step 2.
	;
	;		Step 7. If B[0..N-1] <= A[0..N] then let
	;			C[0..N-1] = C[0..N-1]+1 and 
	;			A[0..N-1] = A[0..N-1]-B[0..N-1].
	;			The division is complete.
	;
	;
DIVIDE: 				; entrance
	ASHL	#1,R0,R0		; convert the longword count to words
	MOVAW	(R1)[R0],R1		; R1 = current position in dividend
	MOVAW	(R2)[R0],R4		; R4 = position above divisor
	MOVAW	(R3)[R0],R3		; R3 = position above quotient area
	MOVZWL	-2(R4),R9		; R9 = leading word of divisor
	INCL	R9			; form the trial divisor
	MOVL	-4(R4),R10		; R10 = leading longword of divisor
	INCL	R10			; form the correction divisor
	MCOMW	-4(R4),R11		; R11 = complemented second word
	MOVZWL	R11,R11 		; form the correction multiplier
	MOVL	R0,R4			; R4 = loop counter
	CLRL	R6			; clear the carryover information
1$:	SUBL2	#2,R1			; R1 = current position in dividend
	SUBL2	#2,R3			; R3 = current position in quotient
	MOVAW	(R1)[R0],R5		; R5 = location of next dividend word
	MOVL	-2(R5),R5		; R5 = leading longword of dividend
	EDIV	R9,R5,R5,R6		; R5 = quotient, R6 = remainder
	CLRL	R8			; clear the double length adjustment
	ASHL	#16,R6,R6		; position the remainder
	BGEQ	2$			; is the value negative ?
	INCL	R8			; yes - the sum will need adjusting
2$:	MOVW	-4(R1)[R0],R6		; include next word from dividend
	EMUL	R5,R11,R6,R6		; form the correction remainder
	ADDL2	R8,R7			; adjust the second longword
3$:	CLRL	R8			; clear the subtraction adjustment
	BBS	#31,R10,4$		; is the correction divisor negative ?
	INCL	R8			; yes - difference will need adjusting
4$:	SUBL2	R10,R6			; subtract the first longwords
	SBWC	R8,R7			; subtract the second longwords
	BLSS	5$			; result is negative - bypass
	INCL	R5			; correct the quotient
	BRB	3$			; try for another correction
5$:	MOVL	R3,R6			; R6 = current word in quotient
	CLRW	(R6)			; clear the word
	ADDL2	R5,(R6)+		; add the current quotient into it
6$:	ADWC	#0,(R6)+		; propagate any carry
	BCS	6$			; another carry - loop
	MNEGL	R5,R5			; negate the quotient
	CLRL	R6			; clear the carryover information
	CLRL	R8			; clear the loop index
7$:	MOVZWL	(R1)[R8],R7		; R7 = next word from dividend
	ADDL2	R7,R6			; add it to the carryover
	MOVZWL	(R2)[R8],R7		; R7 = next word from divisor
	EMUL	R5,R7,R6,R6		; form next word of dividend
	MOVW	R6,(R1)[R8]		; store it
	ASHQ	#-16,R6,R6		; position the carryover information
	AOBLSS	R0,R8,7$		; remainder is not complete - loop
	MOVZWL	(R1)[R0],R7		; R7 = high order word of remainder
	ADDL2	R7,R6			; add it to the carryover
	SOBGTR	R4,1$			; division is not complete - loop
	ASHL	#-1,R0,R0		; restore the count to longwords
	TSTL	R6			; is the carryover nonzero ?
	BNEQ	9$			; yes - bypass
	SUBL3	#1,R0,R4		; R4 = loop index
8$:	CMPL	(R1)[R4],(R2)[R4]	; compare remainder and divisor
	BLSSU	12$			; less than - bypass
	BGTRU	9$			; greater than - skip
	SOBGEQ	R4,8$			; more longwords to compare - loop
9$:	CLRL	R4			; clear the loop index
	BICPSW	#PSLM_C 		; clear the carry bit
10$:	SBWC	(R2)+,(R1)+		; subtract corresponding longwords
	AOBLSS	R0,R4,10$		; more lonwords to subtract - loop
	INCL	(R3)+			; increment the quotient
11$:	ADWC	#0,(R3)+		; propagate any carry
	BCS	11$			; another carry to propagate - loop
12$:	RSB				; return
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*	       Condition Code Processing Routines	       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    In order that condition code information be usable 
	;	directly by the code of the Emulator as well as be available
	;	for use in the emulated PSL, the routines which perform tests
	;	and compares set the hardware condition codes. The routine
	;	SET_CONDITION is used to move the hardware condition codes
	;	to the emulated PSL.
	;
	;	    The routines of this portion of the Emulator are extremely
	;	simple so the descriptions of routines are included with the
	;	routines. Here we will just discuss the general policy on 
	;	condition codes within the Emulator.
	;
	;
	;	General Policy on Condition Codes
	;	---------------------------------
	;
	;	    In general it is the responsibility of each of the
	;	instruction emulation routines to insure that the condition
	;	codes are correct. Since for most of the instructions
	;	presently emulated the condition codes reflect the floating
	;	value that appears in OPERAND1, the routine SET_CONDITION1
	;	is available for checking the value and setting the condition
	;	codes in the emulated PSL. In other cases these operations 
	;	must be done in line.
	;
	;	    For those instructions which return an integer result
	;	the V bit is used to indicate whether or not an integer 
	;	overflow took place. Because of this it is also checked in
	;	NORMAL_EXIT in order to determine if a integer overflow trap
	;	should be signaled. For this reason it is cleared when the
	;	instruction emulation is started in EMULATOR.
	;

	;
	;	SET_CONDITION - Capture the Condition Codes N and Z in the PSL
	;
	;		entered by subroutine branching
	;	
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the N and Z bits in the emulated PSL
	;	equal to those bits in PSL available on entry to the routine.
	;
SET_CONDITION:				; entrance
	BLSS	1$			; less than - bypass
	BGTR	2$			; greater than - bypass
	BICL2	#PSLM_NZ,PSL(FP)	; clear the N bit and Z bit in the PSL
	BISL	#PSLM_EQL,PSL(FP)	; specify equals in the PSL
	RSB				; return
1$:	BICL2	#PSLM_NZ,PSL(FP)	; clear the N bit and Z bit in the PSL
	BISL	#PSLM_LSS,PSL(FP)	; specify less than in the PSL
	RSB				; return
2$:	BICL2	#PSLM_NZ,PSL(FP)	; clear the N bit and Z bit in the PSL
	BISL2	#PSLM_GTR,PSL(FP)	; specify greater than in the PSL
	RSB				; return
	;
	;	SET_CONDITION1 - Test a Floating Value Setting the PSL
	;
	;		entered by subroutine branching
	;	
	;		parameter:	OPERAND1 = The Floating Value
	;
	;	Discussion
	;
	;	    This routine tests the floating value in OPERAND1 and
	;	sets the N and Z bits in the emulated PSL according to the
	;	outcome of the test. The V and C bits in the emulated PSL
	;	are cleared.
	;
SET_CONDITION1: 			; entrance
	MOVAB	OPERAND1(FP),R1 	; R1 = location of OPERAND1
	BSBB	TEST_REAL		; test the value
	BSBB	SET_CONDITION		; set the condition codes
	BICL2	#PSLM_VC,PSL(FP)	; clear the V bit and C bit in the PSL
	RSB
	;

	;
	;	TEST_REAL - Test all Floating Types
	;
	;		entered by subroutine branching
	;	
	;		parameter:	R1 = Floating Value Location
	;
	;	Discussion
	;
	;	    This routine tests the floating value in the internal 
	;	representation that is addressed by R1 and sets the hardware
	;	condition codes accordingly. These settings are available
	;	when the routine returns.
	;
TEST_REAL:				; entrance
	BLBS	ZERO(R1),TEST_EQL	; value is zero - bypass
	BLBC	SIGN(R1),TEST_GTR	; value is positive - bypass
	BRB	TEST_LSS		; value is negative - bypass
	;
	;	TEST_OCTA - Test an Octaword in OPERAND1
	;
	;		entered by subroutine branching
	;	
	;		parameter:	OPERAND1 = 128 Bit Octaword Value
	;
	;	Discussion
	;
	;	    This routine tests the octaword value which occupies 
	;	128 bits and starts at OPERAND1 (it is not in the internal
	;	floating representation) and sets the hardware condition
	;	codes according to the outcome of the test. These settings
	;	are available when the routine returns.
	;
TEST_OCTA:				; entrance
	MOVL	#3,R0			; initialize the index
	TSTL	OPERAND1(FP)[R0]	; test the first longword
	BGEQ	2$			; it's not negative - bypass
	RSB				; return indicating negative value
1$:	TSTL	OPERAND1(FP)[R0]	; test the next longword
2$:	BNEQ	TEST_GTR		; value is positive - bypass
	SOBGEQ	R0,1$			; more longwords to examine - loop
	BRB	TEST_EQL		; value is zero - bypass
	;

	;
	;	COMPARE_REAL - Compare Internal Format Floating Values 
	;
	;		entered by subroutine branching
	;
	;		parameters:	R1 = Location of First Floating Value
	;				R2 = Locaiton of Second Floating Value
	;
	;	Discussion
	;	
	;	    This routine compares the two floating values addressed
	;	by R1 and R2 and sets the hardware condition codes according
	;	to the outcome of the comparison. These settings are available
	;	when the routine returns.
	;
COMPARE_REAL:				; entrance
	CMPB	SIGN(R1),SIGN(R2)	; compare the sign indicators
	BNEQ	3$			; not equal - bypass
	CMPB	ZERO(R2),ZERO(R1)	; compare the zero indicators
	BNEQ	2$			; not equal - bypass
	BLBS	ZERO(R1),TEST_EQL	; both are zero and equal - bypass
	CMPL	POWER(R1),POWER(R2)	; compare the exponents
	BLSS	4$			; condition was less than - bypass
	BGTR	3$			; condition was greater - bypass
	MOVL	#3,R0			; R0 = loop index
1$:	CMPL	FRACTION(R1)[R0],-	; compare corresponding longwords
		FRACTION(R2)[R0]	; from the fractions
	BNEQ	2$			; not equal - bypass
	SOBGEQ	R0,1$			; more longwords to examine - loop
	BRB	TEST_EQL		; arrange an equals return
2$:	BLSSU	4$			; condition was less than - bypass
3$:	BLBC	SIGN(R1),TEST_GTR	; condition is greater than - bypass
	BRB	TEST_LSS		; condition is less than - bypass
4$:	BLBC	SIGN(R1),TEST_LSS	; condition is less than - bypass
	BRB	TEST_GTR		; condition is greater than - bypass
	;

	;
	;	TEST_LSS - Set the Condition Codes to Specify Less Than
	;
	;		entered by subroutine branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the hardware condition codes to specify
	;	a "less than" outcome. This setting is available when the 
	;	routine returns.
	;
TEST_LSS:				; entrance
	TSTB	#-1			; set the condition codes
	RSB				; return
	;
	;	TEST_EQL - Set the Condition Codes to Specify Equals
	;
	;		entered by subroutine branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the hardware condition codes to specify
	;	an "equals" outcome. This setting is available when the 
	;	routine returns.
	;
TEST_EQL:				; entrance
	TSTB	#0			; set the condition codes
	RSB				; return
	;
	;	TEST_GTR - Set the Condition Codes to Specify Greater Than
	;
	;		entered by subroutine branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine sets the hardware condition codes to specify
	;	a "greater than" outcome. This setting is available when the
	;	routine returns.
	;
TEST_GTR:				; entrance
	TSTB	#1			; set the condition codes
	RSB				; return
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		Exception Processing Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    In order to simplify the design of the Emulator, it was
	;	decided that whenever fault conditions were detected during
	;	instruction emulation, that control would branch immediatly
	;	to the signaling routine rather than using status codes to
	;	inform some outer routine of the condition. Because of this
	;	some care was necessary in the ordering of operations so that
	;	the Emulator is always in the correct state when faults are
	;	detected. The only trap supported is the integer overflow
	;	trap and since this condition is only signaled when the 
	;	instruction emulation is complete, there is no problem with
	;	the flow of control.
	;
	;	    For each of the exceptions recognized, there is a routine
	;	which is branched to (except for access violations in which
	;	a subroutine branch is used instead) as soon as the condition
	;	is detected. This routine pushes a shortened version of the
	;	signal array onto the stack and branches to SIGNAL_START which
	;	builds the signal and mechanism arrays in the proper place in
	;	memory and enters the signal dispatcher to search for handlers
	;	to process the condition. If the exception was a fault, the
	;	routine FAULT_RESET is called to restore the registers to
	;	their values when the instruction was started.
	;
	;
	;	Access Violations
	;	-----------------
	;
	;	    The routines READ_FAULT and WRITE_FAULT are called by
	;	subroutine branching when memory probes of read and write
	;	access fail during instruction emulation. The register R11 is
	;	assumed to contain the location of the area being probed
	;	and the register R10 is assumed to contain its length. The
	;	routine tries to produce the fault under controlled conditions
	;	and returns if it can not produce the fault. If it can produce
	;	the fault the the fault is signaled with the reason mask being
	;	the reason mask from the attempt to produce the fault and with
	;	the violation address as the address of the first byte of the
	;	area for which the access violation occurs.
	;
	;	
	;	The Signal Dispatcher
	;	---------------------
	;
	;	    The Emulator presently contains all of the code necessary
	;	for signaling the condition since it is necessary that the
	;	emulator build the signal and mechanism arrays itself and
	;	since there is no "back door" to either the signal dispatcher
	;	in the common RTL or the one in VMS. The version contained in
	;	the emulator is a copy with minor modifications of the one in
	;	LIB$SIGNAL.
	;

	;
	;	READ_FAULT - Process a Read Access Violation Fault
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Size of Area being Read
	;				R11 = Location of Area being Read
	;
READ_FAULT:				; entrance
	PUSHR	#^M<R0,R1,R2>		; save R0,R1,R2
	MOVL	R11,R2			; R2 = probed address
	PROBER	MODE(FP),#1,(R2)	; is the first byte readable ?
	BEQL	1$			; no - bypass
	PROBER	MODE(FP),#1,-1(R2)[R10]	; is the last byte readable ?
	BNEQ	1$			; yes - bypass
	MOVAB	-1(R2)[R10],R0		; R2 = address of last byte
	BICW2	#511,R2			; compute address of first bad byte
1$:	CALLS	#0,B^READ_REASON	; get the reason mask
	BLBS	R0,2$			; the read went all right - bypass
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	PUSHL	R2			; push the bad address
	PUSHL	R1			; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
2$:	POPR	#^M<R0,R1,R2>		; restore R0,R1,R2
	RSB				; get back
	;
	;	READ_REASON - Get the Reason Mask for a Read Access Violation
	;
	;		parameter:	R2 = Address for which Probe Failed
	;
	;		returns with	R0 = Status of Access Attempt
	;				R1 = Reason Mask if Unsuccessful
	;
READ_REASON:				; entrance
	.WORD	0			; entry mask
	MOVAB	B^REASON_HANDLER,(FP)	; set up the condition handler
	TSTB	(R2)			; touch the location
	MOVL	#1,R0			; indicate a successful read
	RET				; return
	;
	;	REASON_HANDLER - Condition Handler for Reason Routines
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with 	R0 = Condition Response
	;
REASON_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0 and R1 = location of arrays
	TSTL	8(R1)			; condition from establisher frame ?
	BNEQ	1$			; no - bypass
	CMPCOND	SS$_ACCVIO,4(R0)	; access violation condition ?
	BNEQ	1$			; no - bypass
	CLRL	12(R1)			; return zero status in R0
	MOVL	8(R0),16(R1)		; return the reason mask in R1
	CLRQ	-(SP)			; default PC and level for unwind
	CALLS	#2,G^SYS$UNWIND		; unwind the reason routine frame
1$:	CVTWL	#SS$_RESIGNAL,R0	; specify condition not handled
	RET				; return
	;

	;
	;	WRITE_FAULT - Process a Write Access Violation Fault
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Size of Area being Written
	;				R11 = Location of Area being Written
	;
WRITE_FAULT:				; entrance
	PUSHR	#^M<R0,R1,R2>		; save R0,R1,R2
	MOVL	R11,R2			; R2 = probed address
	PROBEW	MODE(FP),#1,(R2)	; is the first byte writeable ?
	BEQL	1$			; no - bypass
	PROBEW	MODE(FP),#1,-1(R2)[R10]	; is the last byte writeable ?
	BNEQ	1$			; yes - bypass
	MOVAB	-1(R2)[R10],R2		; R2 = address of last byte
	BICW2	#511,R2			; compute address of first bad byte
1$:	CALLS	#0,B^WRITE_REASON	; get the reason mask
	BLBS	R0,2$			; the write went all right - bypass
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	PUSHL	R2			; push the bad address
	PUSHL	R1			; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
2$:	POPR	#^M<R0,R1,R2>		; restore R0,R1,R2
	RSB				; get back
	;
	;	WRITE_REASON - Get the Reason Mask for Write Access Violation
	;
	;		parameter:	R2 = Address for which Probe Failed
	;
	;		returns with	R0 = Status of Access Attempt
	;				R1 = Reason Mask if Unsuccessful
	;
WRITE_REASON:				; entrance
	.WORD	0			; entry mask
	MOVAB	B^REASON_HANDLER,(FP)	; set up the condition handler
	ADDB2	#0,(R2)			; try to change the location
	MOVL	#1,R0			; indicate a successful write
	RET				; return
	;

	;
	;	OPCODE_FAULT - Process an Opcode Reserved to Digital Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
OPCODE_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_OPCDEC,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	ADDRESS_FAULT - Process an Invalid Addressing Mode Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
ADDRESS_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_RADRMOD,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	OPERAND_FAULT - Processed a Reserved Operand Fault
	;
	;		entered by branching
	;	
	;		no parameters
	;
OPERAND_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_ROPRAND,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	UNDERFLOW - Process a Floating Underflow Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
UNDERFLOW:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_FLTUND_F,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	OVERFLOW - Process a Floating Overflow Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
OVERFLOW:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_FLTOVF_F,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	DIVIDE_FAULT - Process a Floating Divide by Zero Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
DIVIDE_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_FLTDIV_F,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	INT_OVERFLOW - Process an Integer Overflow Trap
	;
	;		entered by branching
	;
	;		no parameters
	;
INT_OVERFLOW:				; entrance
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_INTOVF,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;

	;
	;	FAULT_RESET - Perform Reinitialization Operations for a Fault
	;
	;		entered by subroutine branching
	;	
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine subtracts the sign-extended value of each
	;	of the register modification bytes from the corresponding
	;	emulated register and clears the trace pending bit in the
	;	PSL.
	;
FAULT_RESET:				; entrance
	CLRL	R0			; clear the index
1$:	CVTBL	REGMOD_R0(FP)[R0],R1	; R1 = modifications to R[R0]
	SUBL2	R1,REG_R0(FP)[R0]	; unmodify the register
	AOBLEQ	#15,R0,1$		; more registers to reset - loop
	BBCC	#PSL_TP,PSL(FP),2$	; clear the trace pending bit
2$:	RSB				; return
	;

	;
	;	SIGNAL_START - Build the Parameter Blocks for SIGNAL
	;
	;		entered by branching
	;
	;		parameters:	(SP) = Truncated Signal Array Size (M)
	;				4(SP) = Condition Code
	;				8(SP) = First Signal Argument
	;				  .
	;				  .
	;				  .
	;				4*<M-1>(SP) = Last Signal Argument
	;
	;	Discussion
	;
	;	    This routine builds the signal and mechanism arrays
	;	for a condition generated by the Emulator. It is entered
	;	with the signal array for the condition except for the 
	;	PC and PSL pair pushed onto the Emulator's stack (with the
	;	pushed array length correspondingly shortened). The signal
	;	array, mechanism array, and the handler parameter block
	;	are then constructed on the user's emulated stack. The routine
	;	then removes the Emulator frame from the stack and enters
	;	the signal dispatching loop at SIGNAL.
	;
	;	Notes:	1. The precise format of the information pushed onto
	;		   the user's stack is given in the description of
	;		   SIGNAL below.
	;
	;		2. The method of getting out of the Emulator used in
	;		   this routine is essentially the same as that used
	;		   in NORMAL_EXIT.
	;
SIGNAL_START:				; entrance
	MOVL	(SP)+,R7		; R7 = number of signal parameters
	ASHL	#2,R7,R8		; R8 = size of the signal parameters
	ADDL3	#52,R8,R0		; R0 = size of signal information
	BSBW	TEST_FRAME		; make sure we have room for it
	MOVL	REG_SP(FP),R6		; R6 = user's stack pointer
	MOVQ	REG_PC(FP),-(R6)	; push the PC, PSL pair
	SUBL2	R8,R6			; make room for the signal parameters
	MOVC3	R8,(SP),(R6)		; push the signal parameters
	ADDL3	#2,R7,-(R6)		; push the signal array length
	MOVL	#1,-(R6)		; push code for SIGNAL (vs. STOP)
	MOVQ	REG_R0(FP),-(R6)	; push user's R0 and R1
	MNEGL	#3,-(R6)		; push -3 (depth number)
	MOVL	REG_FP(FP),-(R6)	; push the user's FP
	MOVL	#4,-(R6)		; push the mechanism array length
	MOVL	R6,-(R6)		; push the mechanism array location
	MOVAB	28(R6),-(R6)		; push the signal array location
	MOVL	#2,-(R6)		; push the handler parameter count
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put the user's PC, PSL pair back
	MOVAB	B^SIGNAL,SAVE_PC(FP)	; store the return point
	MOVAB	FRAME_END+4(FP),R0	; R0 = location of end of frame
	SUBL2	R0,R6			; R6 = distance of user SP from it
	EXTZV	#0,#2,R6,R1		; R1 = stack alignment
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store it into the frame
	ADDL2	R1,R0			; compute the parameter area location
	ASHL	#-2,R6,-4(R0)		; store the parameter count
	RET				; return (to SIGNAL)
	;

	;
	;	SIGNAL - Signal the Condition
	;
	;		entered by branching
	;
	;		parameters:	( Described in Note 3 )
	;	
	;	Discussion
	;
	;		   Following is a description of the information which
	;		   is assumed to be pushed onto the stack when the
	;		   routine SIGNAL is entered. The values are all
	;		   longwords.
	;
	;		   Handler Parameter Block:
	;
	;			(SP)	2 (handler parameter block length)
	;			4(SP)	signal array location
	;			8(SP)	mechanism array location
	;
	;		   Mechanism Array:
	;
	;			12(SP)	4 (mechanism array length)
	;			16(SP)  user's FP (establisher frame)
	;			20(SP)	-3 (establisher depth)
	;			24(SP)	user's R0
	;			28(SP)	user's R1
	;
	;		   Information Not Part of any Array:
	;
	;			32(SP)	1 (code for SIGNAL rather than STOP)
	;
	;		   Signal Array:
	;
	;			36(SP)	signal array length M
	;			40(SP)	condition code
	;			44(SP)	first signal argument
	;			  .
	;			  .
	;			  .
	;			<4*M>+28(SP) last signal argument
	;			<4*M>+32(SP) user's PC
	;			<4*M>+36(SP) user's PSL
	;
	;		   The user's stack pointer should coincide with the
	;		   address <4*M>+40(SP).
	;
	;	We now jump to the special entry point in VMS to start
	;	the search for handlers.  Execution will not return to us.
	;-

SIGNAL: 				; entrance
	JMP	G^SYS$SRCHANDLER


;	************************************************************************
;	*								       *
;	*								       *
;	*	   End of EMULATE$ VAX Instruction Subset Emulator	       *
;	*								       *
;	*								       *
;	************************************************************************

	.END
