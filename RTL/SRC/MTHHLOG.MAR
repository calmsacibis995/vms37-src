	.TITLE	MTH$HLOG 	; Floating Point Natural and Common
				; Logarithm Functions (HLOG, HLOG10)
	.IDENT /2-005/		; File: MTHHLOG.MAR  Edit: PDG2005
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
; FACILITY: MATH LIBRARY
;++
; ABSTRACT:
;
; MTH$HLOG  and  MTH$HLOG10 are functions which return the H floating point 
; natural or common logarithm of their H floating point argument.  The call
; is standard call-by-reference.  MTH$HLOG_R8 and MTH$HLOG10_R8 are special
; routines which are the same as MTH$HLOG  and  MTH$HLOG10  except  that  a 
; faster  non-standard  JSB call is used with the argument in R0 through R3 
; and no registers are saved.
;
;--
;
; VERSION: 1
;
; HISTORY:
; AUTHOR:
;	John A. Wheeler, 24-Sep-1979.
;
; MODIFIED BY:
;
;
; VERSION: 2
;
; HISTORY:
; AUTHOR:
;	Bob Hanek, 23-Jun-1981.
;
;
;

	.SBTTL	HISTORY	; Detailed Current Edit History


;
; Edit History for Version 1 of MTH$HLOG 
;
; 1-001 - Adapted from MTH$GLOG version 1-001.  JAW 24-Sep-1979
; 1-002 - Reorder additions after POLYH for greater accuracy.  JAW
;	  16-Jan-1980.
;
;
; Edit History for Version 2 of MTH$HLOG 
;
; 2-001 - Add MTH$HLOG2.  RNH 08-Aug-1981
; 2-002 - Correct entry logic for JSB entries.  Use G^ addressing for
;	  externals.  SBL 24-Aug-1981
; 2-003 - Changed MTH$$AB_ALOG to MTH$$AB_ALOG_V.  RNH 29-Sep-81
; 2-004 - Eliminated symbolic short literals.  RNH 15-Oct-81
; 2-005	- Changed H_FHI to the global symbol MTH$$AB_H_FHI.  PDG 3-Nov-81

	.SBTTL	DECLARATIONS	; Declarative Part of Module

;
; INCLUDE FILES:	MTHJACKET.MAR
;
; EXTERNAL SYMBOLS:
	.DSABL	GBL
	.EXTRN	MTH$K_LOGZERNEG		; Error code
	.EXTRN	MTH$$SIGNAL		; Math signal routine
	.EXTRN	MTH$$AB_ALOG_V		; Table of byte offsets

; EQUATED SYMBOLS:

	ACMASK = ^M<IV, R2, R3, R4, R5, R6, R7, R8>
					; Register save mask and IV enable

;
; MACROS:	none
;
; PSECT DECLARATIONS:

	.PSECT	_MTH$CODE	PIC,SHR,LONG,EXE,NOWRT
					; Program section for math routines
;
; OWN STORAGE:	none
;
; CONSTANTS:
;

;
;
;   The H_FHI table is accessed by an index obtained from the MTH$$AB_ALOG_V
;   table.  The MTH$$AB_ALOG_V table is  located  in  MTHALOG.MAR.   Indices 
;   between  0  and  13  inclusive  are  used to access entries 0 through 13 
;   respectively.   For  these  indecies,  the  first  three  items  of  the 
;   corresponding entry are  FHI,  LN_FHI_LO  and  LN_FHI_HI .  The last two 
;   items  for  these  entries  are  not  used.  Indices  between  14 and 27 
;   inclusive access entries 13 through 0 respectively.  For  these indecies,
;   the last three items in the corresponding entry are LN_FHI_HI, LN_FHI_LO 
;   and FHI.  The first two items for these entries are not used.
;

MTH$$AB_H_FHI::
; Entry  0
	.OCTA ^X000000000000000000002000DA9F4001 ; .185399055480957031250000000000000E+01
	.OCTA ^X421AE3E330BE1E1611FD7FA0396B3FE7 ; .182434402032023314126725621815896E-07
	.OCTA ^X0000BE807D885E853F2D08F13C144000 ; .617340354394026336891701170613980E+00
	.OCTA ^X6A77662D008D1E1611FD7FA0396B3FE7 ; .182434402032023314125204908634248E-07
	.OCTA ^X000000000000000000003C0014294000 ; .539377093315124511718750000000000E+00
; Entry  1
	.OCTA ^X0000000000000000000086009E3A4001 ; .161808049678802490234375000000000E+01
	.OCTA ^X1A1651666C92CAD4A248A6A11FACBFE8 ;-.334897099054787485306715784174542E-07
	.OCTA ^X0000EDD09CDBD55BF8475616ECCA3FFF ; .481240601684539933406225507426361E+00
	.OCTA ^X9528BBCF7973CAD4A248A6A11FACBFE8 ;-.334897099054787485307528659897014E-07
	.OCTA ^X000000000000000000009E003C6C4000 ; .618016183376312255859375000000000E+00
; Entry  2
	.OCTA ^X00000000000000000000A80074D14001 ; .145632410049438476562500000000000E+01
	.OCTA ^X076616CA3725BE56BF739FDC0CB13FE6 ; .782002012580221952889721780420325E-08
	.OCTA ^X00004A10EC32689134C3FF1580EF3FFF ; .375915513676946674050152469633735E+00
	.OCTA ^XEDD7A91E2104BE56BF739FDC0CB13FE6 ; .782002012580221952886230806897752E-08
	.OCTA ^X00000000000000000000F2005F914000 ; .686660349369049072265625000000000E+00
; Entry  3
	.OCTA ^X000000000000000000003A00575A4001 ; .134122049808502197265625000000000E+01
	.OCTA ^X67A2E43CEADE688A1F5CE019C5A7BFE4 ;-.330078010459087028183194612330033E-08
	.OCTA ^X0000B570E806A3162F923DC82CA03FFF ; .293580022185681810025912951334701E+00
	.OCTA ^XB2179E721475688B1F5CE019C5A7BFE4 ;-.330078010459087028184835000417384E-08
	.OCTA ^X00000000000000000000EA007DBD4000 ; .745589554309844970703125000000000E+00
; Entry  4
	.OCTA ^X000000000000000000004400423B4001 ; .125871682167053222656250000000000E+01
	.OCTA ^XC62C8D33F40BBE6DB8911FC4ECC13FE5 ; .717052012620762551060963803472821E-08
	.OCTA ^X0000D1A084893746EDC5E4C2D73A3FFE ; .230092799376253694241152352589256E+00
	.OCTA ^X250B3ED9E150BE6DB8911FC4ECC13FE5 ; .717052012620762551059486135704264E-08
	.OCTA ^X00000000000000000000720096C34000 ; .794459879398345947265625000000000E+00
; Entry  5
	.OCTA ^X00000000000000000000A40033174001 ; .119957947731018066406250000000000E+01
	.OCTA ^X4BF2704BF5DA0C332C1797A235F73FE7 ; .180424631976852194153384391464056E-07
	.OCTA ^X0000D2A06E1BE9796AD43BC974AD3FFE ; .181971041759747059533725661796263E+00
	.OCTA ^X67754F6AEF080C332C1797A235F73FE7 ; .180424631976852194153169164517935E-07
	.OCTA ^X00000000000000000000F600AAD04000 ; .833625495433807373046875000000000E+00
; Entry  6
	.OCTA ^X000000000000000000004C0027FF4001 ; .115623927116394042968750000000000E+01
	.OCTA ^XE508D66EAD727307A85B7F52A54F3FE7 ; .245235008503654116009340462882640E-07
	.OCTA ^X00003DE0E3DA3E191D014ECE29503FFE ; .145172706284598104257166714906286E+00
	.OCTA ^X7A566868A1627307A85B7F52A54F3FE7 ; .245235008503654116008959784520728E-07
	.OCTA ^X00000000000000000000A000BAD04000 ; .864872932434082031250000000000000E+00
; Entry  7
	.OCTA ^X0000000000000000000018001F834001 ; .112309408187866210937500000000000E+01
	.OCTA ^XAC20ED9E231710833B0FDFD81D633FE6 ; .830594608409781119680821972598047E-08
	.OCTA ^X00007FF09A9A38F9EE168137DB7E3FFD ; .116087441215204694735219873388379E+00
	.OCTA ^XFAAB19A91E4D10833B0FDFD81D633FE6 ; .830594608409781119680065881497159E-08
	.OCTA ^X000000000000000000002A00C7E24000 ; .890397369861602783203125000000000E+00
; Entry  8
	.OCTA ^X00000000000000000000720018B64001 ; .109653389453887939453125000000000E+01
	.OCTA ^X6C77FE6B932537A618911C7B6309BFE7 ;-.206657912834305937438876637191575E-07
	.OCTA ^X00005350408AF71C1ED7B43D79763FFD ; .921542206360097460648634898154278E-01
	.OCTA ^XA32DE46E96AD37A618911C7B6309BFE7 ;-.206657912834305937438988051281938E-07
	.OCTA ^X000000000000000000000200D2ED4000 ; .911964476108551025390625000000000E+00
; Entry  9
	.OCTA ^X00000000000000000000640013654001 ; .107576584815979003906250000000000E+01
	.OCTA ^XE5C89455C3E694FE3DD96B6816BF3FE8 ; .324505070054104206025365433569997E-07
	.OCTA ^X000085F01FC3A18779B76EEC2B243FFD ; .730327923734942776530409494420973E-01
	.OCTA ^XDD1F1F9AC0D194FE3DD96B6816BF3FE8 ; .324505070054104206025170817645574E-07
	.OCTA ^X00000000000000000000A600DBF04000 ; .929570376873016357421875000000000E+00
; Entry 10
	.OCTA ^X00000000000000000000BE000F694001 ; .106020724773406982421875000000000E+01
	.OCTA ^XFFFA4F92524356DF50072B7973603FE7 ; .216169086842986773647175954146763E-07
	.OCTA ^X0000254034AD9102B83FB339DEF03FFC ; .584643841264166981774760648830458E-01
	.OCTA ^X3632E1254F5F56DF50072B7973603FE7 ; .216169086842986773647084812194551E-07
	.OCTA ^X00000000000000000000AA00E2EC4000 ; .943211853504180908203125000000000E+00
; Entry 11
	.OCTA ^X0000000000000000000048000CA84001 ; .104944276809692382812500000000000E+01
	.OCTA ^XF590F833C5BE6CF4202D00A82565BFE8 ;-.341556199443377807287157019867087E-07
	.OCTA ^X00005DF098C4104549EE36D58B573FFC ; .482593604049819173209503543953340E-01
	.OCTA ^X82E966B3C5EE6CF4202D00A82565BFE8 ;-.341556199443377807287168712667577E-07
	.OCTA ^X00000000000000000000C000E7E04000 ; .952886581420898437500000000000000E+00
; Entry 12
	.OCTA ^X0000000000000000000092000A704001 ; .104078018665313720703125000000000E+01
	.OCTA ^X76DA2D8A21E235C8AE83AFC850963FE6 ; .979601812285972873945283749009674E-08
	.OCTA ^X000001306604EF53D39A6D5347703FFC ; .399706015874586800669454709608252E-01
	.OCTA ^X38C557A81F4D35C8AE83AFC850963FE6 ; .979601812285972873944876477698997E-08
	.OCTA ^X000000000000000000004C00EBF04000 ; .960817694664001464843750000000000E+00
; Entry 13
	.OCTA ^X00000000000000000000D20008DD4001 ; .103463470935821533203125000000000E+01
	.OCTA ^X7ADBFEA19608511B0185CFB48A813FE6 ; .114816670407461374608667056227946E-07
	.OCTA ^X000068D0D46C983483D9B3AD16EC3FFC ; .340484151203057188790477801652380E-01
	.OCTA ^X254356528FE4511B0185CFB48A813FE6 ; .114816670407461374608570133728889E-07
	.OCTA ^X000000000000000000005400EEDC4000 ; .966524720191955566406250000000000E+00

;
;  Polynomial constants tables
;


LOGTAB1:	; Constants for q(z).  Generated using eq. 6.3.10 of Hart et. 
		; al. (sin(2a) = 1/32)

	.OCTA ^X5F95F1B2A5BAC3D8F5260A619B9BBFFC ;C19 = -.502448275362084878530895804226821E-01
	.OCTA ^X92DBE7A6765790596C52CC82B1293FFC ;C18 =  .528763765645499721329654320808376E-01
	.OCTA ^X7A54AC14946576FF14A540A3C71BBFFC ;C17 = -.555549871866289307439741718980372E-01
	.OCTA ^X5E0B06A18F25A3D84658C0D9E1E03FFC ;C16 =  .588229910446883153011455339050868E-01
	.OCTA ^XAE7E786DA6F3EE3D371F00330000BFFD ;C15 = -.625000007452811547077858181299735E-01
	.OCTA ^X4B4434C70327C8039543113E11113FFD ;C14 =  .666666673290174441426279704533825E-01
	.OCTA ^X298C1180F148E440879C49242492BFFD ;C13 = -.714285714279647469240206445726274E-01
	.OCTA ^XE563A213835C94C60AE7B13B3B133FFD ;C12 =  .769230769225774005169049575655602E-01
	.OCTA ^X2CB2BF3F9152C30A555655555555BFFD ;C11 = -.833333333333336505344135125934769E-01
	.OCTA ^X0A06F262E8796F50D1751745745D3FFD ;C10 =  .909090909090911469433015746992134E-01
	.OCTA ^X62840C662AF3997A999999999999BFFD ;C9  = -.999999999999999998935034661483933E-01
	.OCTA ^XFE968C1F7E77C7071C7171C7C71C3FFD ;C8  =  .111111111111111111040128283759802E+00
	.OCTA ^XED6B8E9000D70000000000000000BFFE ;C7  = -.125000000000000000000022288060961E+00
	.OCTA ^X47B3B871499F24929249492424923FFE ;C6  =  .142857142857142857142869876170464E+00
	.OCTA ^XBE5E4E9855555555555555555555BFFE ;C5  = -.166666666666666666666666663945744E+00
	.OCTA ^XCEED967D999999999999999999993FFE ;C4  =  .199999999999999999999999998744462E+00
	.OCTA ^X0DD2000000000000000000000000BFFF ;C3  = -.250000000000000000000000000000170E+00
	.OCTA ^X59F05555555555555555555555553FFF ;C2  =  .333333333333333333333333333333390E+00
	.OCTA ^X0000000000000000000000000000C000 ;C1  = -.500000000000000000000000000000000E+00
	.OCTA ^X00000000000000000000000000000000 ;C0  =  .000000000000000000000000000000000E+00

LOGLEN1 = .-LOGTAB1/16	; no. of floating point entries


LOGTAB2:	; Constants for p(z*z). Generated using eq. 6.3.11 of Hart et.
		; al. (sin(2a) = (b - 1)/(b + 1) where b = 2**(1/7))

	.OCTA ^X8441440A9DA422727A67F0448B243FFD ;C10= .964707742165502889622792644848776E-01
	.OCTA ^X0019B5C53BD4BEC761F97E57AF203FFD ;C9 = .105255597611288497278972991576336E+00
	.OCTA ^X85B2D52687082827EEF2E8F7E1E13FFD ;C8 = .117647085221446214132332887422407E+00
	.OCTA ^XC286BAD2232FAD441440110F11113FFE ;C7 = .133333333275487876088825048524888E+00
	.OCTA ^X90B321D3AF744625146BB13B3B133FFE ;C6 = .153846153846236465950762205453645E+00
	.OCTA ^XF8411CEE61EB3082D1741745745D3FFE ;C5 = .181818181818181740845065772564621E+00
	.OCTA ^X73AA312A4DE1C7231C7171C7C71C3FFE ;C4 = .222222222222222222268705851909093E+00
	.OCTA ^X5FBA09F648D224929249492424923FFF ;C3 = .285714285714285714285697218390631E+00
	.OCTA ^XDDA89DE8999999999999999999993FFF ;C2 = .400000000000000000000000003481293E+00
	.OCTA ^X480A5555555555555555555555554000 ;C1 = .666666666666666666666666666666339E+00
	.OCTA ^X00000000000000000000000000004002 ;C0 = .200000000000000000000000000000000E+01
LOGLEN2 = .-LOGTAB2/16


H_LN_2_HI:
	.OCTA	^X0000673093C7F357A39E2FEF62E44000	; Hi 98 bits of ln2
H_LN_2_LO:
	.OCTA	^X069E16C54C5B933979A157A0F97B3F9A	; Low bits of ln2
H_LOG10_E:				; LOG10(e)
	.LONG	^XBCB73FFF, ^X6E50B152	;  0.43429448190325182765112891891660508
	.LONG	^X6AB7E32A, ^X5A68555F
H_INV_LN2_CONS:				; convert from natural log to log base
	.QUAD	^XB82F765271544001	; 2
	.QUAD	^XD23AFDA07D0FE177




	.SBTTL	MTH$HLOG  - Standard H-Floating LOG


; FUNCTIONAL DESCRIPTION:
;
; HLOG  - H floating point LOG function
;
; HLOG(X) is computed using the following approximation technique:
;
;	If X =< 0, error.  Otherwise
;
;	Let X = f * (2**n), where 1/2 <= f < 1
;
;       If n is greater than or equal to 1 than
;             set N = n - 1 and F = 2*f.  
;          Else
;             set N = n and F = f.  
;
;       Then  ln(x) = N*ln2 + ln(F)           
;
;       If |F - 1| < 2**-5 then
;             ln(F) =  W + W*P(W), where W = F - 1 and P 
;             is a polynomial of degree 18.
;          Else
;             ln(F) = ln(FHI) + Z*Q(Z*Z), where FHI is ob-
;             tained by table look-up, Q is a polynomial of
;             degree 10 and Z = (F - FHI)/(F + FHI)
;
;       NOTE: The quantities ln(FHI) and ln2 are used in the above
;             equations in two parts - a high part (containing the
;             high order bits) and a low part (containing the low
;             order bits.  In the code the high and low parts of the
;             constants are indicated by a _HI and _LO suffix respec-
;             tively.  The values were chosen such that N*LN_2_HI +
;             LN_FHI_HI is exactly representable.
;
;++
;
; CALLING SEQUENCE:
;
;	hlog.wh.v = MTH$HLOG(x.rh.r)
;		-or-
;	CALL MTH$HLOG(hlog.wh.r, x.rh.r)
;
; INPUT PARAMETERS:

	LONG = 4			; Define longword multiplier
	x = 2 * LONG			; Contents of x is the argument

; IMPLICIT INPUTS:	none
;
; OUTPUT PARAMETERS:
;
	hlog = 1 * LONG			; Contents of hlog is the result
;
;	VALUE:	H floating logarithm of the argument
;
; IMPLICIT OUTPUTS:	none
;
; COMPLETION CODES:	none
;
; SIDE EFFECTS:
;
; Signals:  MTH$_LOGZERNEG if |X| =< 0.0 with reserved operand in R0/R3 (copied
; to the signal mechanism vector CHF$L_MCH_R0/R1  by  LIB$SIGNAL).   Associated
; message is: "LOGARITHM OF ZERO OR NEGATIVE VALUE". Result is reserved operand
; -0.0 unless a user supplied (or any) error handler changes CHF$L_MCH_R0/R1.
;
; NOTE: This procedure disables floating point underflow, enables integer over-
; flow,  causes  no  floating overflow or other arithmetic traps, and preserves
; enables across the call.
;
;---


	.ENTRY	MTH$HLOG, ACMASK	; Standard call-by-reference entry
					; Disable DV (and FU), enable IV
	MTH$FLAG_JACKET			; Flag that this is a jacket procedure 
					; in case of an error in special JSB 
					; routine
	MOVH	@x(AP), R0		; R0/R3 = arg 
	BSBB	MTH$HLOG_R8		; Call special HLOG routine
	MOVO	R0, @hlog(AP)		; Store result in first argument
	RET				; Return to caller


	.SBTTL	MTH$HLOG10  - Standard H Floating Common logarithm

;++
; FUNCTIONAL DESCRIPTION:
;
; HLOG10  - H floating point LOG10 function
;
; HLOG10(X) is computed as HLOG10(E) * HLOG(X).
;
; See description of MTH$HLOG 
;
; CALLING SEQUENCE:
;
;	hlog_base_10.wh.v = MTH$HLOG10(x.rh.r)
;			-or-
;	CALL MTH$HLOG10(hlog_base_10.wh.r, x.rh.r)
;
; INPUT PARAMETERS:
;
	LONG = 4			; Define longword multiplier
	x = 2 * LONG			; Contents of x is the argument 
;
;
; OUTPUT PARAMETERS:
;
	hlog_base_10 = 1 * LONG
;
; SIDE EFFECTS:	See description of MTH$HLOG
;
;--


	.ENTRY	MTH$HLOG10, ACMASK	; Standard call-by-reference entry
					; Disable DV (and FU), enable IV
	MTH$FLAG_JACKET			; Flag that this is a jacket procedure
					; in case of an error in special JSB 
					; routine
	MOVH	@x(AP), R0		; R0/R3 = arg 
	BSBB	MTH$HLOG10_R8 		; Call special HLOG10 routine
	MOVO	R0, @hlog_base_10(AP)	; Store result in first argument
	RET				; Return to caller


	.SBTTL	MTH$HLOG2  - Standard H Floating Common logarithm

;++
; FUNCTIONAL DESCRIPTION:
;
; HLOG2  - H floating point LOG2 function
;
; HLOG2(X) is computed as HLOG2(E) * HLOG(X).
;
; See description of MTH$HLOG 
;
; CALLING SEQUENCE:
;
;	hlog_base_2.wh.v = MTH$HLOG2(x.rh.r)
;			-or-
;	CALL MTH$HLOG2(hlog_base_2.wh.r, x.rh.r)
;
; INPUT PARAMETERS:
;
	LONG = 4			; Define longword multiplier
	x = 2 * LONG			; Contents of x is the argument 
;
;
; OUTPUT PARAMETERS:
;
	hlog_base_2 = 1 * LONG
;
; SIDE EFFECTS:	See description of MTH$HLOG
;
;--


	.ENTRY	MTH$HLOG2, ACMASK	; Standard call-by-reference entry
					; Disable DV (and FU), enable IV
	MTH$FLAG_JACKET			; Flag that this is a jacket procedure 
					; in case of an error in special JSB 
					; routine
	MOVH	@x(AP), R0		; R0/R3 = arg 
	BSBB	MTH$HLOG_R8		; calculate natural log
	MULH3	H_INV_LN2_CONS,	R0, @hlog_base_2(AP)
					; convert and store result in first 
					; argument
	RET				; Return to caller

	.SBTTL	MTH$HLOGHLOG10_R8  - Special HLOG/HLOG10 routines

; Special HLOG/HLOG10 - used by the standard routine, and directly.
;
; CALLING SEQUENCE:
;	save anything needed in R0:R8
;	MOVH	..., R0			; Input in R0/R3
;	JSB	MTH$HLOG10_R8 /MTH$HLOG_R8 
;	return with result in R0/R3
; Note: This routine is written to avoid causing any integer overflows,
; floating overflows, or floating underflows or divide by 0 conditions, 
; whether enabled or not.
;
; REGISTERS USED:
;	R0/R3 - H floating argument then result
;	R4/R7 - Intermediate results
;	R0:R5 - POLYH
;	R8 - Pointer into H_FHI table



MTH$HLOG10_R8::				; Special HLOG10 routine
	MOVW	R0, R7			; R7 = biased exponent
	BLEQ	ERR			; Error if <= 0
					; User PC on top of stack
					; Note: ERROR routine depends on user
					; PC being on top of stack, so 
					; subroutine call to MTH$HLOG_R8 is not
					; used.
	BSBB	HLOG_COMMON_R8 		; Call common HLOG/HLOG10 routine
	MULH2	H_LOG10_E, R0		; R0/R3 = LOG10(e) * LOG(X)
	RSB				; Return

ERR:	BRW	ERROR

MTH$HLOG_R8::				; special LOG routine
	MOVW	R0, R7			; R7 = Biased exponent
	BLEQ	ERR			; HLOG(X) is not defined for X=<0
HLOG_COMMON_R8:
	SUBW	#^X4000, R7		; R7 = Unbiased exponent
	BLEQ	NEG_EXP			; Branch to processing for n=<0

;
; Exponent is positive.  N = n - 1 and F = 2f
;

	DECW	R7			; R7 = N = n - 1
	SUBW	R7, R0			; R0/R3 = F = 2f
	ROTL	#7, R0, R8		; R8 = index into MTH$$AB_ALOG table
	BICL	#-256, R8		;    = lo exp bit and 1st 7 fract bits
	MOVAL	G^MTH$$AB_ALOG_V, R6	; R6 = Address of RTL vector entry
	ADDL	(R6), R6		; R6 = Address of MTH$$AB_ALOG table
	MOVB	(R6)[R8], R8		; R8 = offset into H_FHI tables
	BLSS	LN_1_PLUS		; Branch to special processing 
					;   for F close to 1

;
; Compute Z, Z**2, P(Z**2) and Z*P(Z**2)
;

	CVTWH	R7, -(SP)		; Push N onto the stack
	MOVAO	MTH$$AB_H_FHI[R8], R8	; R8 = Address of FHI
	SUBH3	(R8), R0, R4		; R4/R7 = F - FHI
	ADDH2	(R8)+, R0		; R0/R3 = F + FHI
	DIVH3	R0, R4, -(SP)		; (SP) = Z = (F - FHI)/(F + FHI)
	MULH3	(SP), (SP), R0		; R0/R3 = Z**2
	POLYH	R0, #LOGLEN2-1, LOGTAB2	; R0/R3 = P(Z**2)
	MULH2	(SP)+, R0		; R0/R3 = Z*P(Z**2)

;
; Compute B = N*LN_2_LO + LN_FHI_LO + Z*P(Z*Z)
;
	MULH3	(SP), H_LN_2_LO, R4	; R4/R7 = N*LN_2_LO
	ADDH2	(R8)+, R4		; R4/R7 = N*LN_2_LO + LN_FHI_LO
	ADDH2	R4, R0			; R0/R3 = B

;
; Compute A = N*LN_2_HI + LN_FHI_HI and HLOG(X)
;
	MULH3	(SP)+, H_LN_2_HI, R4	; R4/R7 = N*LN_2_HI
	ADDH2	(R8), R4		; R4/R7 = A = N*LN_2_HI + LN_FHI_HI
	ADDH2	R4, R0			; R0/R3 = A + B = HLOG(X)
	RSB

LN_1_PLUS:
        BRB	LN_1_PLUS_W		


;
; Exponent is negative.  N = n and F = f
;

NEG_EXP:SUBW	R7, R0			; R0/R3 = F = f
	ROTL	#7, R0, R8		; R8 = index into MTH$$AB_ALOG table
	BICL	#-256, R8		;    = lo exp bit and 1st 7 fract bits
	MOVAL	G^MTH$$AB_ALOG_V, R6	; R6 = Address of RTL vector entry
	ADDL	(R6), R6		; R6 = Address of MTH$$AB_ALOG table
	MOVB	(R6)[R8], R8		; R8 = offset into H_FHI tables
	BLSS	LN_1_PLUS_W		; Branch to special processing 
					;   for F close to 1

;
; Compute Z, Z**2, P(Z**2) and Z*P(Z**2)
;

	CVTWH	R7, -(SP)		; Push N onto the stack
	MOVAO	MTH$$AB_H_FHI[R8], R8	; R8 = Address of FHI
	SUBH3	(R8), R0, R4		; R4/R7 = F - FHI
	ADDH2	(R8), R0		; R0/R3 = F + FHI
	DIVH3	R0, R4, -(SP)		; (SP)= Z = (F - FHI)/(F + FHI)
	MULH3	(SP), (SP), R0		; R0/R3 = Z**2
	POLYH	R0, #LOGLEN2-1, LOGTAB2	; R0/R3 = P(Z**2)
	MULH2	(SP)+, R0		; R0/R3 = Z*P(Z**2)

;
; Compute B = N*LN_2_LO + LN_FHI_LO + Z*P(Z*Z)
;
	MULH3	(SP), H_LN_2_LO, R4	; R4/R7 = N*LN_2_LO
	ADDH2	-(R8), R4		; R4/R7 = N*LN_2_LO + LN_FHI_LO
	ADDH2	R4, R0			; R0/R3 = B

;
; Compute A = N*LN_2_HI + LN_FHI_HI and HLOG(X)
;
	MULH3	(SP)+, H_LN_2_HI, R4	; R4/R7 = N*LN_2_HI
	SUBH2	-(R8), R4		; R4/R7 = A = N*LN_2_HI + LN_FHI_HI
	ADDH2	R4, R0			; R0/R3 = A + B = HLOG(X)
	RSB

;
; Special logic for F close to 1 
;

LN_1_PLUS_W:
	SUBH3	#1, R0, -(SP)		; (SP) = W = F - 1
	POLYH	(SP), #LOGLEN1-1,LOGTAB1; R0/R3 = Q(W)
	MULH2	(SP), R0		; R0/R3 = W*Q(W)
	CVTWH	R7, R4			; R4/R5 = N
	MULH3	R4, H_LN_2_LO, -(SP)	; (SP) = N*LN_2_LO
	ADDH2	(SP)+, R0		; R0/R3 = N*LN_2_LO + W*Q(W)
	ADDH2	(SP)+, R0		; R0/R3 = N*LN_2_LO + LN(F)
	MULH2	H_LN_2_HI, R4		; R4/R5 = N*LN_2_HI
	ADDH2	R4, R0			; R0/R3 = HLOG(X)
	RSB
;
; X =< 0.0, signal error
;
ERROR:	PUSHL	(SP)			; Return PC from JSB routine
	MOVZBL	#MTH$K_LOGZERNEG, -(SP)	; Condition value
	ASHQ	#15, #1, R0		; R0 = result = reserved operand -0.0
					; Goes to signal mechanism vector
					; (CHF$L_MCH_R0/R3) so error handler
					; Can modify the result.
	CLRQ	R2			; ...
	CALLS	#2, G^MTH$$SIGNAL	; Signal error and use real user's PC
					; Independent of CALL vs JSB
	RSB				; Return - R0 restored from CHF$L_MCH_R0/R3



	.END
