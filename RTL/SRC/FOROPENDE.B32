MODULE FOR$$OPEN_DEFLT (			! FORTRAN default open
		IDENT = '1-088'		! File: FOROPENDE.B32  Edit: SBL1088
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: FORTRAN Support Library - not user callable
!
! ABSTRACT:
!
!	This module contains a routine to perform default file
!	opening for FORTRAN programs.
!
! ENVIRONMENT: User access mode; mixture of AST level or not.
!
! AUTHOR:	Thomas N. Hastings, CREATION DATE: 6-Mar-77; Version 0
!
! MODIFIED BY:
!
!	Thomas N. Hastings, 15-Mar-77: Version 0
! 1-001	- Update version number and copyright notice.  JBS 16-NOV-78
! 1-002	- Set up the fields added to the LUB for BASIC, and remove
!	   the REQUIRE statement for FORISB, since it is not needed.
!	   This implies that we must allocate the FAB from dynamic
!	   storage, since BASIC needs it after open.  JBS 05-DEC-78
! 1-003	- Change REQUIRE file names from FOR... to OTS...  JBS 07-DEC-78
! 1-004	- Change the prefix of the LUN parameters from OPEN$ to
!	   LUB$.  JBS 08-DEC-78
! 1-005	- BASIC no longer needs the FAB, so put OPEN back the way it
!	   was: use local FAB and deallocate the FAB if it was
!	   allocated by ASSIGN or FDBSET.  JBS 11-DEC-78
! 1-006	- Make the unit numbers which map statement types to negative
!	   logical unit numbers symbolic.  JBS 11-DEC-78
! 1-007	- Change OTSOPN back to FOROPN.  JBS 13-DEC-78
! 1-008	- Remove references to OTS$$AA_LUB_TAB so that FORCB can make it
!	   OWN rather than GLOBAL.  JBS 18-DEC-78
! 1-009 - Add enhancement of setting FAB$V_SQO for sequential only
!	  access.  SBL 27-DEC-78
! 1-010	- Correct some minor editing errors in edit 009.  JBS 27-DEC-78
! 1-011 - Change FOR$$CB_RET to FOR$$CB_POP.  JBS 08-JAN-1979
! 1-012 - Allocate a prompt buffer in case the LUN is used from a
!	   BASIC program.  JBS 09-JAN-1979
! 1-013	- Set the UNIT_0 bit in the LUB if the OPEN is for the TYPE or
!	   ACCEPT LUNs, in case the program later does a BASIC INPUT
!	   or PRINT, which will use the same LUBs.  JBS 11-JAN-1979
! 1-014	- Set the TERM_DEV bit in the LUB if the device opened is a
!	   terminal.  JBS 11-JAN-1979
! 1-015	- Set the TERM_FOR bit in the LUB if the file opened is in
!	   BASIC "terminal format", defined as sequential organization
!	   with variable-length records.  JBS 11-JAN-1979
! 1-016 - Don't set the "update" bit (since we use PUT instead of
!	   UPDATE) to gain speed.  JBS 19-JAN-1979
! 1-017	- Don't allow OPEN to a file which has been CLOSED but is still
!	   active.  This should only happen if recursive I/O is
!	   allowed.  JBS 23-JAN-1979
! 1-018	- Move the exit handler to OTSEXITHA.  JBS 23-JAN-1979
! 1-019	- Be sure the exit handler is declared, no matter what kind
!	   of OPEN is used, since it may have to empty buffers.
!	   JBS 24-JAN-1979
! 1-020	- Put two dollar signs on the non-user callable entry points.
!	   JBS 26-JAN-1979
! 1-021	- Allow the unit number to be a variable with value -1, and in
!	   that case find a LUN and return its value in the variable.
!	   JBS 26-JAN-1979
! 1-022	- In spite of the above edit, give a good error message if the
!	   LUN specified is out of range or already open.  JBS 27-JAN-1979
! 1-023	- Don't set the record length in the RAB, even for fixed length
!	   records, because reading an EOF will always set it to zero.
!	   JBS 31-JAN-1979
! 1-024	- Remove edit 021 (UNIT=-1) pending a review.  JBS 11-FEB-1979
! 1-025	- Set the right margin based on the terminal width.  This is
!	   used only by BASIC.  JBS 22-FEB-1979
! 1-026 - Make RECORDSIZE checking more reasonable.  SPR 22450
!	  Add Organization=Indexed some places.  SBL 29-Mar-1979
! 1-027	- Track SBL's adding of keywords to FOROPN.REQ.  JBS 04-APR-1979
! 1-028 - More ISAM stuff.  SBL 6-Apr-79
! 1-029 - Add complete ISAM support plus BLANK= parameter.  SBL 10-Apr-79
! 1-030 - Change BLANK= to be literal based.  SBL 12-Apr-79
! 1-031	- Add LUB$B_RAT for the BASIC FSP$ function.  JBS 19-APR-1979
! 1-032 - Add more DISPOSE options.  SBL 19-Apr-1979
! 1-033 - Fix Organization consistency check. SBL 24-Apr-79
! 1-034 - Add run-time keyword lookup.  SBL 24-April-79
! 1-035 - Don't let string ISAM key type match everything.  Move check
!	  for recordsize and relative/direct to before $CREATE.
!	  SBL 25-Apr-1979
! 1-036 - Make name strings UPLIT BYTE to save a few bytes.  SBL 25-Apr-1979
! 1-037 - Allow VFC files on RECORDTYPE='VARIABLE'.  SBL 26-Apr-79
! 1-038 - Store IOSTAT directly instead of returning it.  SBL 27-Apr-79
! 1-039 - Set FAB$V_UPD if keyed access.  SBL 2-May-79
! 1-040 - Allow key types to float on the lengths.  SBL 2-May-1979
! 1-041 - Keyed access defaults to UNFORMATTED, FIXED.  SBL 7-May-1979
! 1-042 - Add FAB$V_DEL to access modes.  Change how recordtype is
!	  checked.  SBL 14-May-1979
! 1-043 - Remove checks for KEY and new file.  Allow RMS to catch them
!	  in case user constructs own key using USEROPEN.  SBL 29-May-1979
! 1-044	- Change margin to 16 bits.  JBS 30-MAY-1979
! 1-045 - Improve checking of key XAB's after OPEN.  SBL 1-Jun-1979
! 1-046 - Set MRS if RECORDSIZE given.  Require RECORDSIZE on indexed
!	  files.  Set BKS as specified in release 1 documentation in
!	  BLOCKSIZE.  SBL 7-Jun-1979
! 1-047 - Disallow RELATIVE+SEGMENTED, VARIABLE+DIRECT.  Make old-file
!	  check allow SEGMENTED=VARIABLE, rather than FIXED!  SBL 11-Jun-79
! 1-048 - Move setting of FAB$W_MRS outside of RECORDSIZE SELECT statement.
!	  This is so that DEFINE FILE works correctly.  SBL 18-Jun-1979
! 1-049	- Set the language byte in the LUB, so only FORTRAN I/O statements
!	   can be used on LUNs opened by FORTRAN.  This restriction may
!	   be relaxed in some future release.  JBS 30-JUN-1979
! 1-050 - Pass the unit number as the third USEROPEN argument.  SBL 19-July-1979
! 1-051 - Allow VARIABLE+DIRECT only on RELATIVE.  SBL 25-July-1979
! 1-052 - Add VAR_LENGTHS to FOR$$OPECLO_ARG.  Fix so that INQUIRE
!	  keywords are by reference.  SBL 6-August-1979
! 1-053	- Use a language-specific exit handler.  JBS 16-AUG-1979
! 1-054 - Correct length of VAR_LENGTHS.  SBL 28-Aug-1979
! 1-055 - RMS errors RMS$_TYP and RMS$_VER are now considered
!	  filename syntax errors.  SBL 29-Aug-1979
! 1-056 - Fix bug that didnt let you define a KEY field of 1 byte.
!	  SBL 25-Sept-1979
! 1-057 - Add open on a connected unit.  SBL 5-Oct-1979
! 1-058 - Separate into two modules.  SBL 8-Oct-1979
! 1-059 - Move FOR$$OPEN_FNAME to here.  SBL 9-Oct-1979
! 1-060 - Set RAB$V_UIF on ACCESS='DIRECT' only.  SBL 10-Oct-1979
! 1-061 - Get FAB$L_MRN after opening existing file.  SBL 12-Oct-1979
! 1-062 - Remove filename editing.  RMS does it at last!  SBL 12-Oct-1979
! 1-063 - Remove prompt buffer definitions.  SBL 15-Oct-1979
! 1-064 - If implicit file name (UNIT<0) or units 5 or 6, attempt
!	  logical name translation, substituting SYS$INPUT or
!	  SYS$OUTPUT appropriately.  Set LUB$W_R_MARGIN as list
!	  directed line width.  SBL 1-Nov-1979
! 1-065 - If old file and no recordtype specified, clear recordtype
!	  bits set in LUB before re-setting them.  SBL 13-Nov-1979
! 1-066	- Set up LUB$A_UBF.  JBS 13-NOV-1979
! 1-067 - Correct the defaulting of RECORDTYPE on old files.  SBL 26-Nov-1979
! 1-068 - Set bits in LUB for carriage control.  SBL 6-Dec-1979
! 1-069 - Set LUB$V_SEQUENTIA for sequential access.  SBL 27-Dec-1979
! 1-070 - Don't set LUB$L_LOG_RECNO to 1 if it is already non-zero - it
!	  may be a default open and the record number is already set.
!	  SBL 11-Jan-1980
! 1-071 - Allow DISP='SUBMIT' or 'DELETE' with READONLY.  Language change
!	  approved by Rich Grove.  SBL 18-Jan-1980
! 1-072 - Make sure that the calculated FAB$B_BKS does not exceed 32.  SBL 28-Jan-1980
! 1-073 - Disallow wildcards in the file spec if not USEROPEN.
!	  Class RMS$_SYN as file name specification error.  SBL 6-FEB-1980
! 1-074 - Remove wildcard check.  RMS does it.  SBL 25-FEB-1980
! 1-075 - ISAM key positions are signed longwords in OPEN argument
!	  list, not words!  SBL 12-Mar-1980
! 1-076 - The maximum recordsize allowed is 32767, not 65535.  SBL 12-Mar-1980
! 1-077 - Add FAB$M_SHRDEL to the list of share attributes.  SBL 18-Mar-1980
! 1-078 - Add support for DEFAULTFILE=string.  JAW 30-Jun-1981
! 1-079 - Increase default value of RECL for unformatted variable-length
!	  records from 126 to 2046, to improve performance when
!	  RECORDTYPE='SEGMENTED'.  JAW 17-Jul-1981
! 1-080 - Fix logic error in record type check made when user does not
!	  specify record type for an old file.  (Allowed both FIXED and
!	  SEGMENTED to be set simultaneously.)  JAW 25-Aug-1981
! 1-081 - Change algorithm for determining the length of a list-directed
!	  output record: use RECL if specified, else 80/81 depending on
!	  carriage control.  JAW 26-Aug-1981
! 1-082 - Add test for blocksize less than recordsize (made only if open
!	  or create fails and device is mag tape).  If so, signal
!	  INCRECLEN since RMS does not give a useful message in this
!	  case.  JAW 28-Aug-1981
! 1-083 - Save and restore the STS and STV around the $PARSE we do if we
!	  get an unexpected error.  SBL 28-Sep-1981
! 1-084 - Signal FOR$K_OPEFAI if RMS$_WLK and not readonly.  DGP 03-Dec-1981
! 1-085 - Set the MRS in the FAB for indexed files.  DGP 21-Dec-1981
! 1-086 - Allow existing file to be SEGMENTED only if it has RFM=VAR.  
!	  Correct 1-082 and 1-084 so that only RMS$_CRE errors check for
!	  INCRECLEN.  SBL 13-Jan-1982
! 1-087 - Complete 1-085.  It was much too simplistic and caused existing ISAM
!	  files to not be able to opened.  DGP 22-Feb-1982
! 1-088 - Unfortunately, 1-087 did not allow existing ISAM files with an MRS
!	  smaller than the default buffer size to be opened unless the
!	  RECL was explicitly specified.  Fix it.  SBL 16-Apr-1982
!--

!<BLF/PAGE>

!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';				! Define all linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    FOR$$OPEN_DEFLT : CALL_CCB NOVALUE,		! default OPEN
    FOR$$OPEN_PROC : CALL_CCB NOVALUE;		! common OPEN procedure

!
! BUILTIN ROUTINES:
!
!	NONE
!
! INCLUDE FILES:
!

LIBRARY 'RTLSTARLE';				! STARLET library for macros and symbols

REQUIRE 'RTLML:FORERR';				! FORTRAN error number definitions

REQUIRE 'RTLML:OTSLUB';				! logical Unit Block definitions

REQUIRE 'RTLIN:OTSMAC';				! macros

REQUIRE 'RTLIN:RTLPSECT';			! Define DELCARE_PSECTS macro

REQUIRE 'RTLIN:FOROPN';				! FORTRAN OPEN parameters

REQUIRE 'RTLML:FORPAR';				! FORTRAN inter-module paramters

REQUIRE 'RTLIN:RTLODBG';			! debugging macros

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!
! PSECT DECLARATIONS:
!
DECLARE_PSECTS (FOR);				! declare PSECTs for FOR$ facility
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!
!
! EXTERNAL LITERAL
!
!	NONE

EXTERNAL ROUTINE
    FOR$$ERR_OPECLO,				! OPEN/CLOSE condition handler
    FOR$$SIGNAL_STO : NOVALUE,			! Convert small FORTRAN err #
    						! to 32-bit VAX error # and SIGNAL_STOP
    FOR$$SIG_NO_LUB : NOVALUE,			! same as FOR$$SIGNAL_STO except no LUB setup
    						! so must pass LUN explicitly.
    FOR$$CB_PUSH : JSB_CB_PUSH NOVALUE,		! push current LUB/ISB/RAB, if any, and allocate LUB/ISB/RAB
    						! for this logical unit
    FOR$$CB_POP : JSB_CB_POP NOVALUE,		! Pop I/O system back to previous LUB or indicate
    						! no I/O statement is currently being processed.
    FOR$$GET_VM,				! Allocate virtual memory
    FOR$$FREE_VM : NOVALUE,			! Free virtual memory
    FOR$$SIG_FATINT : NOVALUE,			! Signal_stop internal error
    FOR$$DECL_EXITH : NOVALUE,			! Declare the exit handler
    OTS$$TAKE_LUN;				! Reserve a LUN

EXTERNAL
    FOR$$L_XIT_LOCK;				! True if exit handler already declared


GLOBAL ROUTINE FOR$$OPEN_DEFLT (		! Default OPEN
	ACCESS_VAL, 				! Access = OPEN$K_ACC_{SEQ, DIR}
	TYPE_VAL, 				! TYPE = OPEN$K_ACC_{NEW,OLD}
	FORM_VAL)				! FORM = OPEN$K_FOR_{UNF, FOR, UNS}
    : CALL_CCB NOVALUE =

!++
! ABSTRACT:
!
!	Perform default OPEN for an I/O statement for the indicated
!	logical unit. The possible parameters are a restricted
!	subset of explicit OPEN, plus FORM = 'UNSPECIFIED' (for
!	ENDFILE only). The keywords for default OPEN are:
!	ACCESS, TYPE, and FORM.
!
! FORMAL PARAMETERS:
!
!	LUB_ADR.mlu.ra		adr of LUB/ISB/RAB control block
!	ACCESS_VAL.rlu.v	Value = OPEN$K_ACC_{SEQ,DIR}
!				to indicate ACCESS = 'SEQUENTIAL'
!				or 'DIRECT'.
!	TYPE_VAL.rlu.v		Value = OPEN$K_TYPE_{NEW, OLD} TO
!				indicate TYPE = 'NEW' or 'OLD'
!	FORM_VAL.rlu.v		Value = OPEN$K_FORM_{UNF, FOR, UNS}
!				to indicate FORM = 'UNFORMATTED',
!				'FORMATTED', or 'UNSPECIFIED
!				(ENDFILE only).
!
! IMPLICIT INPUTS:
!
!	LUB$V_READ_ONLY		1 if 'READONLY' specified in CALL FDBSET
!	LUB$V_DIRECT		1 if specified on previous DEFINEFILE
!	LUB$V_OLD_FILE		1 if specified on previous CALL FDBSET
!	LUB$V_UNFORMAT		1 if specified on previous DEFINEFILE
!	LUB$W_LUN		FORTRAN logical unit number
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_DIRECT		1 if ACCESS = 'DIRECT' or DEFINEFILE
!	LUB$V_OLD_FILE		1 if TYPE = 'OLD' or CALL FDBSET 'OLD'
!	LUB$V_FORMATTED		1 if FORM = 'FORMATTED'
!	LUB$V_UNFORMAT		1 if FORM = 'UNFORMATTED' or DEFINEFILE
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	See FOR$$OPEN_PROC for SIGNAL_STOPs.
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    LOCAL
	OPEN : VECTOR [OPEN$K_KEY_MAX + 1];	! OPEN parameter array

    !+
    ! Clear OPEN parameter array
    !-

    CH$FILL (0, (OPEN$K_KEY_MAX + 1)*%UPVAL, OPEN);
!+
! Allocate the logical unit number being opened, if it is
! not one of the units associated with special FORTRAN statements
! such as TYPE or ACCEPT.
!-

    IF (.CCB [LUB$W_LUN] GEQ 0)
    THEN

	IF ( NOT OTS$$TAKE_LUN (%REF (.CCB [LUB$W_LUN]))) THEN FOR$$SIGNAL_STO (FOR$K_INVARGFOR);

    !+
    ! Setup count, ACCESS, TYPE, and FORM parameter values
    !-

    OPEN [OPEN$K_ACCESS] = .ACCESS_VAL;
    OPEN [OPEN$K_TYPE] = .TYPE_VAL;
    OPEN [OPEN$K_FORM] = .FORM_VAL;

    !+
    ! Perform the OPEN - call common procedure with a pointer
    ! to the OPEN parameter VECTOR of longword values.
    !-

    FOR$$OPEN_PROC (OPEN);
    RETURN;
    END;					! End of FOR$OPEN_DEFLT routine


GLOBAL ROUTINE FOR$$OPEN_PROC (			! Do an OPEN
	OPEN_ADR)				! Address of OPEN parameter vector
    : CALL_CCB NOVALUE =

!++
! ABSTRACT:
!
!	This routine performs the OPEN for FOR$OPEN and FOR$$OPEN_DEFLT.
!	The OPEN parameters have been picked up and placed in a
!	longword array. The index is parameter specific. The parameters
!	are processed in a logical order which minimizes the
!	distance between parameters which depend on each other.
!	Each parameter sets an appropriate part of the LUB/ISB/RAB
!	control block or the FAB control block.  If the FAB
!	has not been allocated, it is allocated.
!	Whenever the FAB, RAB, LUB, or ISB
!	are allocated they are initially set to 0. Thus, default values
!	are often indicated by zero in these structures.
!
! FORMAL PARAMETERS:
!
!	LUB_ADR.mlu.ra		Adr. of LUB/ISB/RAB control block
!	OPEN_ADR.mlu.ra		Adr. of OPEN parameter array of
!				longwords. Index is of form:
!				OPEN$K_name. A longword value of 0
!				indiates an omitted keyword.
!
! IMPLICIT INPUTS:
!
!	LUB$V_READ_ONLY		1 if 'READONLY' specified in CALL FDBSET
!	LUB$V_DIRECT		1 if specified on previous DEFINEFILE
!	LUB$V_OLD_FILE		1 if specified on previous CALL FDBSET
!	LUB$V_UNFORMAT		1 if specified on previous DEFINEFILE
!	LUB$W_LUN		FORTRAN logical unit number
!	LUB$W_RBUF_SIZE		Size in bytes of record buffer to be allocated
!	LUB$A_FAB		Adr. of FAB for FOR$$SIGNAL to find RMS error codes
!				if FDBSET had been called.
!
! IMPLICIT OUTPUTS:
!
!	LUB$V_READ_ONLY		1 if 'READONLY' present or CALL FDBSET
!	LUB$V_DIRECT		1 if ACCESS = 'DIRECT' or DEFINEFILE
!	LUB$V_OLD_FILE		1 if TYPE = 'OLD' or CALL FDBSET 'OLD'
!	LUB$V_SCRATCH		1 if TYPE = 'SCRATCH'
!	LUB$V_PRINT		1 if DISPOSE = 'PRINT'
!	LUB$V_FIXED		1 if RECORDTYPE = 'FIXED'
!	LUB$V_FORMATTED		1 if FORM = 'FORMATTED' or ommitted
!	LUB$V_UNFORMAT		1 if FORM = 'UNFORMATTED'
!				or DEFINEFILE
!	LUB$A_ASSOC_VAR		adr. of n if ASSOCIATEVARIABLE = n is present
!				in OPEN or DEFINEFILE
!	LUB$V_ASS_VAR_L		1 if n is longword
!	LUB$W_IFI		RMS internal file id. Needed in case
!				FORTRAN CLOSE done.
!	LUB$W_RBUF_SIZE		Size in bytes of record buffer allocated.
!	LUB$L_LOG_RECNO		1
!	LUB$W_R_MARGIN		List directed output line width
!	LUB$B_ORGAN		Organization, either LUB$K_ORG_SEQUE
!				or LUB$K_ORG_RELAT.
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	SIGNAL_STOPs the following errors:
!	FOR$_FILNOTFOU	(29 = 'FILE NOT FOUND')
!	FOR$_OPEFAI	(30 = 'OPEN FAILURE')
!	FOR$_INCRECLEN	(37 = 'INCONSISTENT RECORD LENGTH')
!	FOR$_INSVIRMEM	(41 = 'INSUFFICIENT VIRTUAL MEMORY)
!	FOR$_NO_SUCDEV	(42 = 'NO SUCH DEVICE')
!	FOR$_FILNAMSPE	(43 = 'FILE NAME SPECIFICATION ERROR')
!	FOR$_RECSPEERR	(44 = 'RECORD SPECIFICATION ERROR')
!	FOR$_KEYVALERR	(45 = 'KEYWORD VALUE ERROR IN OPEN STATEMENT')
!	FOR$_INCOPECLO	(46 = 'INCONSISTENT OPEN/CLOSE ARGUMENTS')
!	FOR$_INVARGFOR	(47 = 'INVALID ARGUMENT TO FORTRAN I/O LIBRARY')
!--

    BEGIN

    EXTERNAL REGISTER
	CCB : REF BLOCK [, BYTE];

    MAP
	OPEN_ADR : REF VECTOR [OPEN$K_KEY_MAX + 1];

    LOCAL
	V_DEFAULT_SIZE,
	OPEN_STATUS,				! RMS status returned on $OPEN or $CREATE
	T_DFLT_FILE_NAM : VECTOR [10, BYTE],	! 10-byte  default filename string
						! Form: FORnnn.DAT
	FAB_BLOCK : BLOCK [FAB$C_BLN, BYTE],	! allocate local FAB
	NAM_BLOCK : BLOCK [NAM$C_BLN, BYTE],	! allocate local NAME BLOCK
	XAB_BLOCK : BLOCK [XAB$C_FHCLEN, BYTE],	! allocate local FHC XAB BLOCK
	FAB : REF BLOCK [FAB$C_BLN, BYTE],	! declare FAB base pointer
	KEY_XAB : REF BLOCK [OPEN$K_XAB_SIZE, BYTE],	! ISAM key XAB
	RES_OR_EXP_NAME : VECTOR [NAM$C_MAXRSS, BYTE];	! Storage for resultant or expanded name string

    BIND
	A_SYS$INPUT = UPLIT BYTE('SYS$INPUT:'),
	A_SYS$OUTPUT = UPLIT BYTE('SYS$OUTPUT:');

    LITERAL
	L_SYS$INPUT = %CHARCOUNT ('SYS$INPUT:'),
	L_SYS$OUTPUT = %CHARCOUNT ('SYS$OUTPUT:');

    !+
    ! If ASSIGN or FDBSET were called prior to this OPEN, they will
    ! allocate a FAB and store information for OPEN in it.  If they
    ! have not been called we initialize and use our local FAB.  The
    ! FAB address is stored in the LUB for error messages and for
    ! $CONNECT.  At the end of OPEN, the FAB is freed if it is not
    ! the local FAB.
    !-

    IF .CCB [LUB$A_FAB] NEQA 0
    THEN 					! FAB already setup by ASSIGN or FDBSET
	FAB = .CCB [LUB$A_FAB]
    ELSE 					! use local FAB
	BEGIN
	FAB = FAB_BLOCK;
	CH$FILL (0, FAB$C_BLN, .FAB);
	CCB [LUB$A_FAB] = .FAB;
	FAB [FAB$B_BID] = FAB$C_BID;
	FAB [FAB$B_BLN] = FAB$C_BLN;
	END;

    CCB [RAB$L_FAB] = .FAB;
    KEY_XAB = XAB_BLOCK;			! Initial state for XAB
    CH$FILL (0, XAB$C_FHCLEN, XAB_BLOCK);	! Zero out first XAB block

    !+
    ! Set deferred write bit in the FAB for speed improvement in
    ! relative files.
    !-

    FAB [FAB$V_DFW] = 1;
!<BLF/PAGE>

!

    !+
    ! NAME
    ! Setup RMS default filename string (FAB$L_DNA, FAB$B_DNS) and
    ! file name string (FAB$L_FNA) depending on the type of statement
    ! that caused the LUN to be opened.
    !
    !	statement	file name string	default file name string
    !
    !	READ		FOR$READ:		FORREAD.DAT
    !	ACCEPT		FOR$ACCEPT:		FORACCEPT.DAT
    !	TYPE		FOR$TYPE:		FORTYPE.DAT
    !	PRINT		FOR$PRINT:		FORPRINT.DAT
    !	other		FORnnn:			FORnnn.DAT
    !
    ! Get the logical unit number from LUB$W_LUN instead of
    ! OPEN[OPEN$K_UNIT] since default open doesn't set up UNIT.
    ! LUN has been checked for being in legal range by CB_PUSH.
    ! Set the string length and address in the FAB.
    !-

    BEGIN

    LOCAL
	A_DEF_LOGNAM,				! Address of default logical name
	L_DEF_LOGNAM;				! Length of default logical name

    A_DEF_LOGNAM = 0;				! No default yet

    CASE .CCB [LUB$W_LUN] FROM LUB$K_DLUN_MIN TO LUB$K_DLUN_MAX OF
	SET

	[LUB$K_LUN_READ] : 			! READ statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORREAD.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORREAD.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$READ:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$READ:');
	    A_DEF_LOGNAM = A_SYS$INPUT;
	    L_DEF_LOGNAM = L_SYS$INPUT;
	    END;

	[LUB$K_LUN_ACCE] : 			! ACCEPT statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORACCEPT.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORACCEPT.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$ACCEPT:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$ACCEPT:');
	    A_DEF_LOGNAM = A_SYS$INPUT;
	    L_DEF_LOGNAM = L_SYS$INPUT;
	    END;

	[LUB$K_LUN_TYPE] : 			! TYPE statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORTYPE.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORTYPE.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$TYPE:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$TYPE:');
	    A_DEF_LOGNAM = A_SYS$OUTPUT;
	    L_DEF_LOGNAM = L_SYS$OUTPUT;
	    END;

	[LUB$K_LUN_PRIN] : 			! PRINT statement (therefore default open)
	    BEGIN
	    FAB [FAB$B_DNS] = %CHARCOUNT ('FORPRINT.DAT');
	    FAB [FAB$L_DNA] = UPLIT BYTE('FORPRINT.DAT');
	    FAB [FAB$B_FNS] = %CHARCOUNT ('FOR$PRINT:');
	    FAB [FAB$L_FNA] = UPLIT BYTE('FOR$PRINT:');
	    A_DEF_LOGNAM = A_SYS$OUTPUT;
	    L_DEF_LOGNAM = L_SYS$OUTPUT;
	    END;

	[OUTRANGE] : 				! Some other statement (OPEN or default OPEN)
	    BEGIN
            IF .OPEN_ADR [OPEN$K_NAME] EQLA 0 OR
               .OPEN_ADR [OPEN$K_DEFAULTF] EQLA 0
            THEN
                BEGIN
                T_DFLT_FILE_NAM [0] = %C'F';
                T_DFLT_FILE_NAM [1] = %C'O';
                T_DFLT_FILE_NAM [2] = %C'R';
                T_DFLT_FILE_NAM [3] = ((.CCB [LUB$W_LUN]/100) MOD 10) + %C'0';
                T_DFLT_FILE_NAM [4] = ((.CCB [LUB$W_LUN]/10) MOD 10) + %C'0';
                T_DFLT_FILE_NAM [5] = ((.CCB [LUB$W_LUN]) MOD 10) + %C'0';
                T_DFLT_FILE_NAM [6] = %C'.';
                T_DFLT_FILE_NAM [7] = %C'D';
                T_DFLT_FILE_NAM [8] = %C'A';
                T_DFLT_FILE_NAM [9] = %C'T';
                END;

	    !+
	    ! DEFAULTFILE
	    ! Set up default file name string to be used in RMS $OPEN
	    !-

            IF .OPEN_ADR [OPEN$K_DEFAULTF] NEQA 0
            THEN
                BEGIN
                LOCAL
                    NAM_DSC : REF BLOCK [8, BYTE];
                NAM_DSC = .OPEN_ADR [OPEN$K_DEFAULTF];
                IF .NAM_DSC [DSC$W_LENGTH] GTRU 255 THEN FOR$$SIGNAL_STO (FOR$K_FILNAMSPE);
                FAB [FAB$B_DNS] = .NAM_DSC [DSC$W_LENGTH];
                FAB [FAB$L_DNA] = .NAM_DSC [DSC$A_POINTER];
                END
            ELSE

	    !+
	    ! Default file name not specified in OPEN or this is default OPEN.
	    !-

                BEGIN
                FAB [FAB$B_DNS] = %CHARCOUNT ('FORnnn.DAT');
                FAB [FAB$L_DNA] = T_DFLT_FILE_NAM;
                END;

	    !+
	    ! FILE
	    ! Setup file name string to be used in RMS $OPEN
	    !-

	    IF .OPEN_ADR [OPEN$K_NAME] NEQA 0
	    THEN
		BEGIN

		!+
		! file name specified in OPEN
		! Set length and address in FAB
		!-

		LOCAL
		    NAM_DSC : REF BLOCK [8, BYTE];	! File name descriptor

		NAM_DSC = .OPEN_ADR [OPEN$K_NAME];	! Get descriptor

		IF .NAM_DSC [DSC$W_LENGTH] GTRU 255 THEN FOR$$SIGNAL_STO (FOR$K_FILNAMSPE);

		FAB [FAB$B_FNS] = .NAM_DSC [DSC$W_LENGTH];
		FAB [FAB$L_FNA] = .NAM_DSC [DSC$A_POINTER];
		END
	    ELSE

	    !+
	    ! File name not specified in OPEN or this is default OPEN.

	    ! If name not already setup (CALL ASSIGN), use all but last 4 characters of default filename string,
	    ! i.e., all characters but .DAT
	    ! Thus filename string is a string with no punctuation so it can be a logical name
	    !-

		IF .FAB [FAB$L_FNA] EQLA 0
		THEN
		    BEGIN
		    FAB [FAB$B_FNS] = %CHARCOUNT ('FORnnn');
		    FAB [FAB$L_FNA] = T_DFLT_FILE_NAM;

		    !+
		    ! If this is unit 5 or 6, set up default logical
		    ! name to use if translation of FOR005 or FOR006
		    ! fails.
		    !-

		    IF .CCB [LUB$W_LUN] EQL 5
		    THEN
			BEGIN
			A_DEF_LOGNAM = A_SYS$INPUT;
			L_DEF_LOGNAM = L_SYS$INPUT;
			END
		    ELSE

			IF .CCB [LUB$W_LUN] EQL 6
			THEN
			    BEGIN
			    A_DEF_LOGNAM = A_SYS$OUTPUT;
			    L_DEF_LOGNAM = L_SYS$OUTPUT;
			    END;

		    END;

	    END;				! End OUTRANGE expression
	TES;

    !+
    ! If we have an implicit logical name assignment possible
    ! (unit<0 or unit=5 or unit=6) then attempt translation of
    ! the logical name.  If it fails, then substitute the default
    ! logical name SYS$INPUT: or SYS$OUTPUT: appropriately.
    !-

    IF .A_DEF_LOGNAM NEQ 0
    THEN
	BEGIN

	LOCAL
	    LOGNAM_DSC : DSC$DESCRIPTOR,	! Logical name descriptor
	    RESULT_DSC : DSC$DESCRIPTOR;	! Translation result descriptor

	LOGNAM_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
	LOGNAM_DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	RESULT_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
	RESULT_DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	RESULT_DSC [DSC$W_LENGTH] = NAM$C_MAXRSS;	! Scratch string
	RESULT_DSC [DSC$A_POINTER] = RES_OR_EXP_NAME;
	LOGNAM_DSC [DSC$A_POINTER] = .FAB [FAB$L_FNA];
	LOGNAM_DSC [DSC$W_LENGTH] = .FAB [FAB$B_FNS];

	IF .CCB [LUB$W_LUN] LSS 0
	THEN

	!+
	! Don't translate trailing colon.
	!-

	    LOGNAM_DSC [DSC$W_LENGTH] = .LOGNAM_DSC [DSC$W_LENGTH] - 1;

	!+
	! Attempt to translate the logical name, putting the result in
	! RES_OR_EXP_NAME.  We don't care what it translated to, just
	! the fact that it does translate.  If it does not, then substitute
	! the default logical name for the file name.
	!-

	IF $TRNLOG (LOGNAM = LOGNAM_DSC, RSLBUF = RESULT_DSC) EQLU SS$_NOTRAN
	THEN
	    BEGIN
	    FAB [FAB$L_FNA] = .A_DEF_LOGNAM;
	    FAB [FAB$B_FNS] = .L_DEF_LOGNAM;
	    END;

	END;

    END;

    !+
    ! Set the filename in the LUB in case an error occurs.
    !-

    CCB [LUB$A_RSN] = .FAB [FAB$L_FNA];
    CCB [LUB$B_RSL] = .FAB [FAB$B_FNS];
!<BLF/PAGE>

!

    !+
    ! READONLY
    ! Set functions which may be done subsequently (FAB$B_FAC).
    ! If not READONLY, permit GET, PUT, TRUNCATE (via TPT), UPDATE and DELETE.
    ! If READONLY, set LUB$V_READ_ONLY bit and use RMS default functions
    ! which can be done subsequently, namely just GETs.
    !-

    IF .OPEN_ADR [OPEN$K_READONLY]
    THEN
	BEGIN
	CCB [LUB$V_READ_ONLY] = 1;
	END
    ELSE

	IF (.FAB [FAB$B_FAC] EQLU 0)
	THEN
	    FAB [FAB$B_FAC] = FAB$M_GET + FAB$M_PUT + FAB$M_TRN + FAB$M_DEL + FAB$M_UPD;

    !+
    ! ACCESS
    !-

    !+
    ! If LUB$L_LOG_RECNO is zero, then this is not a default open of
    ! a direct access file, so set the record number to 1.  Otherwise,
    ! leave it alone because it has already been set by FOR$$IO_BEG.
    !-
    IF .CCB [LUB$L_LOG_RECNO] EQL 0
    THEN
	CCB [LUB$L_LOG_RECNO] = 1;

    FAB [FAB$V_NEF] = 1;			! inhibit EOF positioning on MT

    CASE .OPEN_ADR [OPEN$K_ACCESS] FROM 0 TO OPEN$K_ACC_KEY OF
	SET

	[OPEN$K_ACC_DIR] : 			! ACCESS = 'DIRECT'
	    BEGIN
	    CCB [LUB$V_DIRECT] = 1;
	    CCB [RAB$B_RAC] = RAB$C_KEY;
	    CCB [RAB$L_KBF] = CCB [LUB$L_LOG_RECNO];
	    CCB [RAB$B_KSZ] = 0;
	    CCB [RAB$V_UIF] = 1;		! Update on $PUT
	    END;

	[0, OPEN$K_ACC_SEQ] : 			! ommitted or ACCESS = 'SEQUENTIAL'
	    BEGIN
	    CCB [LUB$V_SEQUENTIA] = 1;
	    CCB [RAB$B_RAC] = RAB$C_SEQ;
	    FAB [FAB$V_SQO] = 1;		! Speedup
	    END;

	[OPEN$K_ACC_APP] : 			! ACCESS = 'APPEND'
	    BEGIN

	    IF .CCB [LUB$V_READ_ONLY] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    CCB [RAB$V_EOF] = 1;
	    CCB [LUB$V_APPEND] = 1;
	    FAB [FAB$V_NEF] = 0;		! don't inhibit EOF positioning on MT
	    CCB [RAB$B_RAC] = RAB$C_SEQ;
	    FAB [FAB$V_SQO] = 1;		! speedup
	    END;

	[OPEN$K_ACC_KEY] : 			! ACCESS = 'KEYED'
	    BEGIN
	    CCB [RAB$B_RAC] = RAB$C_KEY;
	    CCB [RAB$B_KRF] = 0;
	    CCB [LUB$V_KEYED] = 1;		! So we know later
	    END;

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! TYPE
    !-

    CASE .OPEN_ADR [OPEN$K_TYPE] FROM 0 TO OPEN$K_TYP_UNK OF
	SET

	[OPEN$K_TYP_OLD] : 			! TYPE = 'OLD'
	    CCB [LUB$V_OLD_FILE] = 1;

	[0, OPEN$K_TYP_NEW] : 			! omitted or TYPE = 'NEW'

	    IF NOT .CCB [LUB$V_OLD_FILE]
	    THEN 				! don't do anything if FDBSET said
	    					! OLD file!

		IF .CCB [LUB$V_READ_ONLY] OR .CCB [LUB$V_APPEND] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	[OPEN$K_TYP_SCR] : 			! TYPE = 'SCRATCH'
	    BEGIN

	    IF .CCB [LUB$V_READ_ONLY] OR .CCB [LUB$V_APPEND] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    CCB [LUB$V_SCRATCH] = 1;
	    FAB [FAB$V_TMD] = 1;
	    END;

	[OPEN$K_TYP_UNK] : 			! TYPE = 'UNKNOWN'
	    BEGIN

	    IF .CCB [LUB$V_READ_ONLY] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$V_CIF] = 1;
	    END;

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! DISPOSE
    !	Set bits in LUB to indicate DISPOSE parameters.  Do not allow
    !	deletion of READONLY or SCRATCH files, printing or submitting of
    !	SCRATCH files, or saving of SCRATCH files.       
    !-

    SELECT .OPEN_ADR [OPEN$K_DISPOSE] OF
	SET

	[0] :
	;					! ommitted, do nothing

	[OPEN$K_DIS_SAV] : 			! DISPOSE = 'SAVE'

	    IF .CCB [LUB$V_SCRATCH] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	[OPEN$K_DIS_DEL, OPEN$K_DIS_PRDE, OPEN$K_DIS_SUDE] :
	    ! DISPOSE = 'DELETE', 'PRINT/DELETE', 'SUBMIT/DELETE'
	    BEGIN

	    IF .CCB [LUB$V_READ_ONLY] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    CCB [LUB$V_DELETE] = 1;
	    END;

	[OPEN$K_DIS_PRI, OPEN$K_DIS_PRDE] :
	    ! DISPOSE = 'PRINT', 'PRINT/DELETE'
	    BEGIN

	    IF .CCB [LUB$V_SCRATCH] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    CCB [LUB$V_PRINT] = 1;
	    END;

	[OPEN$K_DIS_SUB, OPEN$K_DIS_SUDE] :
	    ! DISPOSE = 'SUBMIT', 'SUBMIT/DELETE'
	    BEGIN

	    IF .CCB [LUB$V_SCRATCH]
	    THEN
		FOR$$SIGNAL_STO (FOR$K_INCOPECLO)
	    ELSE
		CCB [LUB$V_SUBMIT] = 1;

	    END;

	[OTHERWISE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! FORM
    !-

    CASE .OPEN_ADR [OPEN$K_FORM] FROM OPEN$K_FOR_UNS TO OPEN$K_FOR_UNF OF
	SET

	[OPEN$K_FOR_UNS] :
	;					! unspecified, used by default OPEN only

	[0] : 					! omitted

	    IF .CCB [LUB$V_DIRECT] OR .CCB [LUB$V_KEYED]
	    THEN
		CCB [LUB$V_UNFORMAT] = 1
	    ELSE
		CCB [LUB$V_FORMATTED] = 1;

	[OPEN$K_FOR_FOR] : 			! FORM = 'FORMATTED''
	    CCB [LUB$V_FORMATTED] = 1;

	[OPEN$K_FOR_UNF] : 			! FORM = 'UNFORMATTED'
	    CCB [LUB$V_UNFORMAT] = 1;

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! RECORDTYPE
    !-

    CASE .OPEN_ADR [OPEN$K_RECORDTY] FROM 0 TO OPEN$K_REC_SEGM OF
	SET

	[0] : 					! omitted

	    !+
	    ! Do nothing right now.  We have insufficient information
	    ! to determine the recordtype.  Wait until the organization
	    ! has been determined.
	    !-

	;

	[OPEN$K_REC_FIX] : 			! RECORDTYPE = 'FIXED'
	    BEGIN
	    CCB [LUB$V_FIXED] = 1;
	    FAB [FAB$B_RFM] = FAB$C_FIX;
	    END;

	[OPEN$K_REC_VAR] : 			! RECORDTYPE = 'VARIABLE'
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_VAR;
	    END;

	[OPEN$K_REC_SEGM] : 			! RECORDTYPE = 'SEGMENTED'
	    BEGIN

	    IF .CCB [LUB$V_DIRECT] OR .CCB [LUB$V_KEYED] OR .CCB [LUB$V_FORMATTED]
	    THEN
		FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_RFM] = FAB$C_VAR;
	    CCB [LUB$V_SEGMENTED] = 1;
	    END;

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! CARRIAGECONTROL
    !-

    CASE .OPEN_ADR [OPEN$K_CARRIAGE] FROM 0 TO OPEN$K_CAR_NON OF
	SET

	[0] : 					! omitted

	    IF .CCB [LUB$V_FORMATTED] THEN FAB [FAB$V_FTN] = 1;

	[OPEN$K_CAR_FOR] : 			! CARRIAGECONTROL = 'FORTRAN'
	    FAB [FAB$V_FTN] = 1;

	[OPEN$K_CAR_LIS] : 			! CARRIAGECONTROL = 'LIST'
	    FAB [FAB$V_CR] = 1;

	[OPEN$K_CAR_NON] :
	;					! CARRIAGECONTROL = 'NONE', do nothing

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! ORGANIZATION
    !-

    CCB [LUB$V_NOTSEQORG] = 1;			! Assume not sequential organization

    CASE .OPEN_ADR [OPEN$K_ORGANIZA] FROM 0 TO OPEN$K_ORG_IDX OF
	SET

	[0, OPEN$K_ORG_SEQ] : 			! omitted or ORGANIZATION = ;SEQUENTIAL'
	    BEGIN

	    IF .CCB [LUB$V_DIRECT] AND .FAB [FAB$B_RFM] EQLU FAB$C_VAR THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO)

	    ;

	    IF .CCB [LUB$V_KEYED] AND .OPEN_ADR [OPEN$K_ORGANIZA] NEQ 0
	    THEN
		FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_ORG] = FAB$C_SEQ;
	    CCB [LUB$V_NOTSEQORG] = 0;		! So ENDFILE will know its sequential
	    END;

	[OPEN$K_ORG_REL] : 			! ORGANIZATION = 'RELATIVE'
	    BEGIN

	    IF .CCB [LUB$V_SEGMENTED] OR .CCB [LUB$V_KEYED] THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_ORG] = FAB$C_REL;
	    END;

	[OPEN$K_ORG_IDX] : 			! ORGANIZATION = 'INDEXED'
	    BEGIN

	    IF .CCB [LUB$V_DIRECT] OR .CCB [LUB$V_APPEND] OR .CCB [LUB$V_SEGMENTED]
	    THEN
		FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	    FAB [FAB$B_ORG] = FAB$C_IDX;
	    END;

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

    !+
    ! RECORDTYPE continued
    ! We now have enough information to determine the initial recordtype
    ! if it was omitted.
    !-

    IF .OPEN_ADR [OPEN$K_RECORDTY] EQL 0
    THEN

	IF .FAB [FAB$B_ORG] EQL FAB$C_REL OR .FAB [FAB$B_ORG] EQL FAB$C_IDX OR .CCB [LUB$V_DIRECT] OR .CCB [
		LUB$V_KEYED]
	THEN
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_FIX;
	    CCB [LUB$V_FIXED] = 1;
	    END
	ELSE
	    BEGIN
	    FAB [FAB$B_RFM] = FAB$C_VAR;

	    IF .CCB [LUB$V_UNFORMAT] THEN CCB [LUB$V_SEGMENTED] = 1;

	    END;

    !+
    ! SHARED
    ! If SHARED, indicate user provided record interlock (UPI) (for SEQUENTIAL ORG only)
    ! If not SHARED, RMS defaults is read, sharing only if READONLY, else no sharing.
    !-

    IF .OPEN_ADR [OPEN$K_SHARED]
    THEN
	BEGIN
	FAB [FAB$B_SHR] = FAB$M_SHRGET + FAB$M_SHRPUT + FAB$M_SHRUPD + FAB$M_SHRDEL;

	IF NOT .CCB [LUB$V_NOTSEQORG]		! Sequential only, set UPI
	THEN
	    FAB [FAB$V_UPI] = 1;

	END;

!<BLF/PAGE>

!

    !+
    ! KEY
    !-

    IF .OPEN_ADR [OPEN$K_KEY] NEQU 0
    THEN
	BEGIN

	LOCAL
	    KEY_DEFN : REF BLOCK [12, BYTE],	! Key definition
	    KEY_NUM,				! Number of current key
	    KEY_COUNT,				! Total number of keys defined
	    XAB_ADDR;				! Address of newly allocated KEY XAB

	IF .FAB [FAB$B_ORG] NEQU FAB$C_IDX THEN FOR$$SIGNAL_STO (FOR$K_INCOPECLO);

	KEY_DEFN = .OPEN_ADR [OPEN$K_KEY];
	KEY_COUNT = .KEY_DEFN [OPEN$W_INFO];
	KEY_DEFN = .KEY_DEFN + %UPVAL;

	IF .KEY_COUNT MOD 3 NEQ 0 THEN FOR$$SIGNAL_STO (FOR$K_INVARGFOR);

	KEY_COUNT = .KEY_COUNT/3;

	!+
	! Loop through key definitions, and set up the key XABs.
	!-

	INCR KEY_NUM FROM 0 TO .KEY_COUNT - 1 DO
	    BEGIN
	    XAB_ADDR = FOR$$GET_VM (OPEN$K_XAB_SIZE);
	    KEY_XAB [XAB$L_NXT] = .XAB_ADDR;
	    KEY_XAB = .XAB_ADDR;

	    !+
	    ! Fill in KEY XAB fields
	    !-

	    CH$FILL (0, OPEN$K_XAB_SIZE, .KEY_XAB);
	    KEY_XAB [XAB$B_COD] = XAB$C_KEY;
	    KEY_XAB [XAB$B_BLN] = XAB$C_KEYLEN;

	    !+
	    ! Calculate key position and width
	    !-

	    IF .KEY_DEFN [OPEN$L_KEY_LO] LEQ 0 OR
	       .KEY_DEFN [OPEN$L_KEY_LO] GTR 32767 OR
	       .KEY_DEFN [OPEN$L_KEY_HI] GTR 32767 OR
	       .KEY_DEFN [OPEN$L_KEY_HI] LSS .KEY_DEFN [OPEN$L_KEY_LO]
	    THEN
		FOR$$SIGNAL_STO (FOR$K_INVKEYSPE);

	    KEY_XAB [XAB$W_POS0] = .KEY_DEFN [OPEN$L_KEY_LO] - 1;
	    KEY_XAB [XAB$B_SIZ0] =
	    BEGIN

	    LOCAL
		SIZE;

	    SIZE = .KEY_DEFN [OPEN$L_KEY_HI] - .KEY_DEFN [OPEN$L_KEY_LO] + 1;

	    IF .SIZE GTR 255 THEN FOR$$SIGNAL_STO (FOR$K_INVKEYSPE);

	    .SIZE
	    END;
	    KEY_XAB [OPEN$W_POS0] = .KEY_XAB [XAB$W_POS0];
	    KEY_XAB [OPEN$B_SIZ0] = .KEY_XAB [XAB$B_SIZ0];
	    KEY_XAB [XAB$B_DTP] = (SELECTONE .KEY_DEFN [OPEN$B_DTYPE] OF
		SET
		[0, DSC$K_DTYPE_T] : XAB$C_STG;
		[DSC$K_DTYPE_WU] : XAB$C_BN2;
		[DSC$K_DTYPE_W] : XAB$C_IN2;
		[DSC$K_DTYPE_LU] : IF .KEY_XAB [XAB$B_SIZ0] EQL 4 THEN XAB$C_BN4 ELSE XAB$C_BN2;
		[DSC$K_DTYPE_L] : IF .KEY_XAB [XAB$B_SIZ0] EQL 4 THEN XAB$C_IN4 ELSE XAB$C_IN2;
		[OTHERWISE] :
		    BEGIN
		    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
		    0
		    END;
		TES);
	    KEY_XAB [OPEN$B_KTYPE] = .KEY_XAB [XAB$B_DTP];

	    IF .KEY_NUM NEQ 0
	    THEN
		BEGIN
		KEY_XAB [XAB$V_CHG] = 1;
		KEY_XAB [XAB$V_DUP] = 1;
		END;

	    KEY_XAB [XAB$B_REF] = .KEY_NUM;
	    KEY_DEFN = .KEY_DEFN + (3*%UPVAL);	! Go to next definition
	    END;

	END;

    !+
    !  BLANK
    !     If user specifies BLANK='NULL' then set LUB$V_NULLBLNK
    !     else leave it alone.
    !-

    CASE .OPEN_ADR [OPEN$K_BLANK] FROM 0 TO OPEN$K_BLK_NUL OF
	SET

	[0, OPEN$K_BLK_ZER] :
	;					! Do nothing, ZERO is the default

	[OPEN$K_BLK_NUL] :
	    CCB [LUB$V_NULLBLNK] = 1;

	[OUTRANGE] :
	    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	TES;

!<BLF/PAGE>

!

    !+
    ! RECORDSIZE
    !  Set maximum record size (FAB$W_MRS) if fixed, relative, or indexed.
    !  Set V_DEFAULT_SIZE if omitted.  Set LUB$W_RBUF_SIZE to record size.
    ! Default is 128 for unformatted fixed length, 2046 for unformatted
    ! variable length (2 bytes for RMS control info to make total 2048),
    ! and 133 for formatted (line printer width) or unspecified (ENDFILE
    ! default OPEN).
    !-

    V_DEFAULT_SIZE = 0;				! assume user specifies

    SELECTONEU .OPEN_ADR [OPEN$K_RECORDSI] OF
	SET

	[0] :

	    !+
	    !  If this is a fixed length or relative file, and
	    !  is not known to exist, RECORDSIZE must be given, else
	    !  error FOR$_INCRECLEN.
	    !-

	    IF .CCB [LUB$W_RBUF_SIZE] EQLU 0
	    THEN
		BEGIN

		IF NOT .CCB [LUB$V_OLD_FILE] AND (.CCB [LUB$V_FIXED]
		  OR .FAB [FAB$B_ORG] EQL FAB$C_REL)
		THEN
		    FOR$$SIGNAL_STO (FOR$K_INCRECLEN);

		CCB [LUB$W_RBUF_SIZE] = (
		    IF .CCB [LUB$V_UNFORMAT] 	! unformatted
		    THEN
			IF .CCB [LUB$V_FIXED]
			THEN
			    128			!    fixed
			ELSE
			    2046		!    variable
		    ELSE			! formatted or unspecified (ENDFILE default open)
			133);
		V_DEFAULT_SIZE = 1;		! user took the default
		END;

	[1 TO 32767] :
	    BEGIN

	    LOCAL
		T;

	    T = .OPEN_ADR [OPEN$K_RECORDSI]*(IF .CCB [LUB$V_UNFORMAT] THEN %UPVAL ELSE 1)	!
	    + (IF .CCB [LUB$V_SEGMENTED] THEN 2 ELSE 0);

	    IF .T GTRU 32767 THEN FOR$$SIGNAL_STO (FOR$K_INCRECLEN);

	    CCB [LUB$W_RBUF_SIZE] = .T;
	    END;

	[OTHERWISE] :
	    FOR$$SIGNAL_STO (FOR$K_INCRECLEN);
	TES;

    IF .CCB [LUB$V_FIXED]
      OR (.FAB [FAB$B_ORG] EQLU FAB$C_REL)
      OR (.FAB [FAB$B_ORG] EQLU FAB$C_IDX)
    THEN FAB [FAB$W_MRS] = .CCB [LUB$W_RBUF_SIZE];

!<BLF/PAGE>

!

    !+
    ! INITIALSIZE
    ! Only set if specified in explicit OPEN, since may be set by FDBSET on default OPEN.
    !-

    IF .OPEN_ADR [OPEN$K_INITIALS] NEQ 0
    THEN
	BEGIN
	FAB [FAB$L_ALQ] = ABS (.OPEN_ADR [OPEN$K_INITIALS]);
	FAB [FAB$V_CBT] = 1;
	END;

    !+
    ! EXTENDSIZE
    ! Only set if specified explicitly in explicit OPEN, since FDBSET could set on default open.
    !-

    IF .OPEN_ADR [OPEN$K_EXTENDSI] NEQU 0
    THEN

	IF ABS (.OPEN_ADR [OPEN$K_EXTENDSI]) LSSU 1^16
	THEN
	    FAB [FAB$W_DEQ] = ABS (.OPEN_ADR [OPEN$K_EXTENDSI])
	ELSE
	    FOR$$SIGNAL_STO (FOR$K_KEYVALERR);

    !+
    ! NOSPANBLOCKS
    !-

    FAB [FAB$V_BLK] = .OPEN_ADR [OPEN$K_NOSPANBL];

    !+
    ! MAXREC
    ! Only set if explicitly passed by OPEN statement, since
    ! DEFINE FILE could have pre-set it if this is default open.
    !-

    IF .OPEN_ADR [OPEN$K_MAXREC] NEQU 0 THEN CCB [LUB$L_REC_MAX] = .OPEN_ADR [OPEN$K_MAXREC];

    FAB [FAB$L_MRN] = .CCB [LUB$L_REC_MAX];
!<BLF/PAGE>

!

    !+
    ! BLOCKSIZE
    ! Set BLOCKSIZE (used for magtape only), multi-block count (sequential org only)
    ! and bucket size (relative/indexed only).
    !-

    SELECTONEU .OPEN_ADR [OPEN$K_BLOCKSIZ] OF
	SET

	[0] :
	;					! Default, do nothing yet.

	[1 TO 65535] :
	    BEGIN
	    FAB [FAB$W_BLS] = .OPEN_ADR [OPEN$K_BLOCKSIZ];
	    CCB [RAB$B_MBC] = (.OPEN_ADR [OPEN$K_BLOCKSIZ] + 511)/512;
	    END;

	[OTHERWISE] :
	    FOR$$SIGNAL_STO (FOR$K_KEYVALERR);
	TES;

    !+
    ! Set the bucketsize based on the max of the recordsize and
    ! the blocksize (if any).  A bias of 24 bytes is added for the
    ! worst case of indexed files and variable length records.
    !-

    FAB [FAB$B_BKS] = MIN (((MAX (.CCB [LUB$W_RBUF_SIZE] + 24, .OPEN_ADR [OPEN$K_BLOCKSIZ]) + 511)/512), 32);
!<BLF/PAGE>

!

    !+
    ! BUFFERCOUNT
    ! Only set if explicitly passed by OPEN statement since FDBSET could
    ! have pre-set it if this is a default open.
    !-

    SELECTONEU .OPEN_ADR [OPEN$K_BUFFERCO] OF
	SET

	[0] :
	;

	[1 TO 127] :
	    CCB [RAB$B_MBF] = .OPEN_ADR [OPEN$K_BUFFERCO];

	[OTHERWISE] :
	    FOR$$SIGNAL_STO (FOR$K_KEYVALERR);
	TES;

    !+
    ! ASSOCIATEVARIABLE
    !-

    IF .OPEN_ADR [OPEN$K_ASSOCIAT] NEQA 0
    THEN
	BEGIN
	CCB [LUB$A_ASSOC_VAR] = .OPEN_ADR [OPEN$K_ASSOCIAT];

	IF .OPEN_ADR [OPEN$K_ASSOC_L] THEN CCB [LUB$V_ASS_VAR_L] = 1

	END;

!<BLF/PAGE>

!

    !+
    ! Initialize local NAM_BLOCK and point FAB to NAM_BLOCK so
    ! RMS can return directory ID and resultant name or expanded name string.
    ! NOTE: Resultant and expanded string areas are the same place.
    ! RMS will not return a resultant name string if file
    ! was not successfully opened, so we will use expanded string in that case.
    ! Close uses the DID if the file is to be deleted.
    !-

    CH$FILL (0, NAM$C_BLN, NAM_BLOCK);
    NAM_BLOCK [NAM$B_BID] = NAM$C_BID;
    NAM_BLOCK [NAM$B_BLN] = NAM$C_BLN;
    NAM_BLOCK [NAM$L_RSA] = NAM_BLOCK [NAM$L_ESA] = RES_OR_EXP_NAME;
    NAM_BLOCK [NAM$B_RSS] = NAM_BLOCK [NAM$B_ESS] = NAM$C_MAXRSS;
    FAB [FAB$L_NAM] = NAM_BLOCK;

    !+
    ! Initialize local FHC XAB and point the FAB to it.  We'll use it
    ! to get the largest record size from existing (OLD) files.
    ! XAB_BLOCK was zero filled when allocated.  It may have NXT set
    ! to the first KEY defining XAB.
    !-

    XAB_BLOCK [XAB$B_COD] = XAB$C_FHC;
    XAB_BLOCK [XAB$B_BLN] = XAB$C_FHCLEN;
    FAB [FAB$L_XAB] = XAB_BLOCK;
!<BLF/PAGE>

!

    !+
    ! USEROPEN
    !
    ! If a USEROPEN procedure address was specified then call the procedure
    ! to do the $OPEN and $CONNECT; it will return an RMS status code as
    ! procedure value.  Otherwise do the $OPEN and $CONNECT ourselves.
    ! Set useropen flag, just as a debugging aid in case we get a dump with an SPR.
    !-

    IF .OPEN_ADR [OPEN$K_USEROPEN] NEQA 0
    THEN
	BEGIN

	LOCAL
	    LOG_UNIT;				! Logical unit number

	LOG_UNIT = .CCB [LUB$W_LUN];		! Get the unit number
	CCB [LUB$V_USEROPEN] = 1;		! so we know the user opened the file!
	OPEN_STATUS = (.OPEN_ADR [OPEN$K_USEROPEN]) (.FAB, .CCB, LOG_UNIT);
	END
    ELSE
	BEGIN					! not USEROPEN

	!+
	! If old file is explicitly wanted, do an $OPEN. Otherwise
	! (NEW, SCRATCH, UNKNOWN, default = NEW) do a $CREATE.
	! UNKNOWN has set RMS FAB$V_CIF to do an OPEN if file
	! exists rather than a $CREATE.  If file already existed
	! on $CREATE (TYPE='UNKNOWN'), set LUB$V_OLD_FILE
	! as flag that file already existed for error checking below.
	!-

	OPEN_STATUS = (IF .CCB [LUB$V_OLD_FILE] THEN $OPEN (FAB = .FAB) ELSE $CREATE (FAB = .FAB));

	!+
	! If no error in open/create, do $CONNECT (pointer to FAB already set in RAB).
	!-

	IF .OPEN_STATUS	THEN OPEN_STATUS = $CONNECT (RAB = .CCB);

	END;

!<BLF/PAGE>

!

    !+
    ! TYPE = 'UNKNOWN' has set RMS FAB$V_CIF to do an open if file exitsts
    ! rather than a create.  If file already existed on $CREATE (TYPE='UNKNOWN'),
    ! set LUB$V_OLD_FILE as flag that file already existed for error checking below.
    !-

    IF .FAB [FAB$V_CIF] AND .FAB [FAB$L_STS] NEQU RMS$_CREATED THEN CCB [LUB$V_OLD_FILE] = 1;

    !+
    ! Store away the Directory ID in case CLOSE needs to delete
    ! the file.  Also save the IFI.
    !-

    CH$MOVE (NAM$S_DID, NAM_BLOCK [NAM$W_DID], CCB [LUB$W_DID]);
    CCB [LUB$W_IFI] = .FAB [FAB$W_IFI];

    !+
    ! If we have an expanded name string (or even better, a resultant name string),
    ! point the LUB to it instead of the user supplied name.  This will be
    ! the file name used for error messages from now on.
    !-

    IF .NAM_BLOCK [NAM$B_RSL] NEQ 0
    THEN
	BEGIN
	CCB [LUB$A_RSN] = .NAM_BLOCK [NAM$L_RSA];
	CCB [LUB$B_RSL] = .NAM_BLOCK [NAM$B_RSL];
	END
    ELSE

	IF .NAM_BLOCK [NAM$B_ESL] NEQ 0
	THEN
	    BEGIN
	    CCB [LUB$A_RSN] = .NAM_BLOCK [NAM$L_ESA];
	    CCB [LUB$B_RSL] = .NAM_BLOCK [NAM$B_ESL];
	    END;

!<BLF/PAGE>

!

    !+
    ! If OPEN or CREATE error, SIGNAL_STOP one of:
    ! FOR$_FILNOTFOU (29='FILE NOT FOUND') or
    ! FOR$_OPEFAI (30='OPEN FAILURE')
    ! FOR$_INCRECLEN (37='INCONSISTENT RECORD LENGTH')
    ! FOR$_NO_SUCDEV (42='NO SUCH DEVICE')
    ! FOR$_FILNAMSPE (43='FILE NAME SPECIFICATION ERROR)
    ! FOR$_INVKEYSPE (49='INVALID KEY SPECIFICATION')
    ! Note: OPEN_STATUS can be anything for USEROPEN, so use status in FAB.
    !-

    IF NOT .OPEN_STATUS
    THEN
	FOR$$SIGNAL_STO (

	    SELECTONEU .FAB [FAB$L_STS] OF
		SET

		[RMS$_FNF] :
		    FOR$K_FILNOTFOU;		! FILE NOT FOUND

		[RMS$_DEV] :
		    FOR$K_NO_SUCDEV;		! NO SUCH DEVICE

		[RMS$_FNM, RMS$_NOD, RMS$_TYP, RMS$_VER, RMS$_SYN] :
		    FOR$K_FILNAMSPE;		! FILE NAME SPECIFICATION ERROR

		[RMS$_POS, RMS$_SIZ, RMS$_NPK] :
		    FOR$K_INVKEYSPE;		! INVALID KEY SPECIFICATION

		[RMS$_CRE]:

		    !+
		    ! Check for the special case of a mag tape file with
		    ! blocksize less than recordsize (+ 4 if variable).
		    ! If so, signal INCRECLEN, since RMS does not give a
		    ! useful message in this case; otherwise OPEFAI.
		    !-

		    BEGIN
		    LOCAL
			OLD_STS,	! Previous FAB$L_STS
			OLD_STV;	! Previous STV
		    OLD_STS = .FAB [FAB$L_STS];
		    OLD_STV = .FAB [FAB$L_STV];
		    IF $PARSE (FAB = .FAB)	! Get device characteristics
		    
		    THEN
			BEGIN
			FAB [FAB$L_STS] = .OLD_STS;
			FAB [FAB$L_STV] = .OLD_STV;
			IF .BLOCK [FAB [FAB$L_DEV], DEV$V_SQD; 1, LONG] AND .FAB [FAB$W_BLS] NEQ 0
						! If mag tape,
			THEN
			    IF .FAB [FAB$W_BLS] LSSU .CCB [LUB$W_RBUF_SIZE]
				+ (IF NOT .CCB [LUB$V_FIXED] THEN 4 ELSE 0)
			    THEN
				FOR$K_INCRECLEN	! INCONSISTENT RECORD LENGTH
			    ELSE
				FOR$K_OPEFAI	! OPEN FAILURE
			ELSE
			    FOR$K_OPEFAI
			END
		    ELSE
			FOR$K_OPEFAI
		    END;

		[OTHERWISE]:
		    FOR$K_OPEFAI;

		TES);

!<BLF/PAGE>

!

    !+
    ! If the file we just opened was an existing file, perform a couple of
    ! consistency checks.
    !-

    IF .CCB [LUB$V_OLD_FILE]
    THEN
	BEGIN

	!+
	! Organization check:
	! If user program did not specify organization with this OPEN,
	! use the attributes from the file.  If the user program did specify,
	! check that it agrees with the file.
	!-

	IF .OPEN_ADR [OPEN$K_ORGANIZA] NEQ 0
	THEN
	    BEGIN

	    LOCAL
		T;

	    T = (CASE .OPEN_ADR [OPEN$K_ORGANIZA] FROM OPEN$K_ORG_SEQ TO OPEN$K_ORG_IDX OF
		SET
		[OPEN$K_ORG_SEQ] : FAB$C_SEQ;
		[OPEN$K_ORG_REL] : FAB$C_REL;
		[OPEN$K_ORG_IDX] : FAB$C_IDX;
		[OUTRANGE] :
		    BEGIN
		    FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
		    0
		    END;
		TES);

	    IF .T NEQ .FAB [FAB$B_ORG] THEN FOR$$SIGNAL_STO (FOR$K_INCFILORG);

	    END;

	!+
	! If ACCESS='KEYED' was specified and the file is not indexed,
	! signal an error.
	!-

	IF (.CCB [LUB$V_KEYED] AND .FAB [FAB$B_ORG] NEQ FAB$C_IDX) OR (.CCB [LUB$V_DIRECT] AND .FAB [
		FAB$B_ORG] EQL FAB$C_IDX)
	THEN
	    FOR$$SIGNAL_STO (FOR$K_INCFILORG);

!+
! If the file does not have sequential organization, then set LUB bit.
!-

	IF (.FAB [FAB$B_ORG] NEQ FAB$C_SEQ) THEN CCB [LUB$V_NOTSEQORG] = 1;

!<BLF/PAGE>

!

	!+
	! Record type check:
	! If user-program did not specified record-type in this OPEN,
	! use the file attributes. If user-program did specify
	! this OPEN, check that it agrees with the file.
	!-

	CASE .OPEN_ADR [OPEN$K_RECORDTY] FROM 0 TO OPEN$K_REC_SEGM OF
	    SET

	    [0] : 				! User did not specify
		BEGIN
		CCB [LUB$V_FIXED] = 0;		! Clear previously set bits
		CCB [LUB$V_SEGMENTED] = 0;

		IF .FAB [FAB$B_RFM] EQL FAB$C_FIX
		THEN
		    CCB [LUB$V_FIXED] = 1	! Fixed
		ELSE
		    BEGIN			! Variable
		    IF .CCB [LUB$V_DIRECT] AND NOT .CCB [LUB$V_NOTSEQORG]
		    THEN
			FOR$$SIGNAL_STO (FOR$K_INCRECTYP);
		    IF NOT .CCB [LUB$V_NOTSEQORG] AND .CCB [LUB$V_UNFORMAT] AND
			NOT .CCB [LUB$V_DIRECT] AND (.FAB [FAB$B_RFM] EQL FAB$C_VAR)
		    THEN
			CCB [LUB$V_SEGMENTED] = 1;
		    END;
		END;

	    [OPEN$K_REC_FIX] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_FIX THEN FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_VAR] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_VAR AND .FAB [FAB$B_RFM] NEQU FAB$C_VFC
		THEN
		    FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OPEN$K_REC_SEGM] :

		IF .FAB [FAB$B_RFM] NEQU FAB$C_VAR
		THEN
		    FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    [OUTRANGE] :
		FOR$$SIGNAL_STO (FOR$K_INVARGFOR);
	    TES;

	!+
	! Set maximum record number from file.
	!-

	IF .CCB [LUB$L_REC_MAX] EQL 0
	THEN
	    CCB [LUB$L_REC_MAX] = .FAB [FAB$L_MRN]
	ELSE

	    IF .FAB [FAB$L_MRN] NEQ 0 THEN CCB [LUB$L_REC_MAX] = MIN (.CCB [LUB$L_REC_MAX], .FAB [FAB$L_MRN])

	;
!<BLF/PAGE>

!

	!+
	! Record size check:
	!	If user specified a record size (with DEFINE FILE or RECORDSIZE
	!	OPEN keyword, and MRS was required by RMS (fixed or relative),
	!	or organization indexed and MRS is non-zero, then they must agree.
	!	The recordsize the OTS will use is then computed in a reasonable
	!	manner.
	!-

	IF NOT .V_DEFAULT_SIZE AND (.CCB [LUB$V_FIXED]
	  OR .FAB [FAB$B_ORG] EQL FAB$C_REL)
	THEN

	    IF .CCB [LUB$W_RBUF_SIZE] NEQU .FAB [FAB$W_MRS] THEN FOR$$SIGNAL_STO (FOR$K_INCRECLEN);

	IF (.CCB [LUB$V_FIXED]
	  OR .FAB [FAB$B_ORG] EQL FAB$C_REL)
	THEN
	    CCB [LUB$W_RBUF_SIZE] = .FAB [FAB$W_MRS]
	ELSE
	    CCB [LUB$W_RBUF_SIZE] = MAXU (.CCB [LUB$W_RBUF_SIZE], .FAB [FAB$W_MRS], .XAB_BLOCK [XAB$W_LRL]);

	IF (.FAB [FAB$B_ORG] EQLU FAB$C_IDX) AND (NOT .CCB [LUB$V_FIXED])
	THEN
!+
! For variable indexed files, determine if the MRS is zero.  If it is, this is an ISAM file
! created prior to FORTRAN V3 and should not be checked for buffer size agreement.
! If no explicit RECL was specified, use the bucketsize to compute the buffersize.
!-
	    IF .FAB [FAB$W_MRS] EQLU 0
	    THEN
		BEGIN
		IF .V_DEFAULT_SIZE
		THEN
		    CCB [LUB$W_RBUF_SIZE] = .FAB [FAB$B_BKS] * 512;
		END
	    ELSE
!+
! This is a new ISAM file.  Check to be sure that the buffer size requested does
! not exceed the Max Recordsize specified when the file was created.  Set the
! buffer size to the MRS to allow the records to grow.
!-
		IF NOT .V_DEFAULT_SIZE AND 
		       (.CCB [LUB$W_RBUF_SIZE] GTRU .FAB [FAB$W_MRS])
		THEN
		    FOR$$SIGNAL_STO (FOR$K_INCRECLEN)
		ELSE
		    CCB [LUB$W_RBUF_SIZE] = .FAB [FAB$W_MRS];
	!+
	! Key definition check.  If file is ORGANIZATION='INDEXED' and
	! user specified a KEY definition, make sure it agrees with
	! what the file actually has.  Key sizes must match, and key
	! datatypes must
	! match.  If not, signal error FOR$_INVKEYSPE.
	! Make sure that we don't interfere with key XAB's that a
	! USEROPEN might have defined.
	!-

	IF .FAB [FAB$B_ORG] EQL FAB$C_IDX
	THEN
	    BEGIN

	    LOCAL
		KEY_COUNT;			! Count of OPEN defined keys

	    BEGIN

	    LOCAL
		KEY_DEFN : REF BLOCK [12, BYTE];

	    KEY_DEFN = .OPEN_ADR [OPEN$K_KEY];

	    IF .KEY_DEFN NEQ 0 THEN KEY_COUNT = .KEY_DEFN [OPEN$W_INFO] ELSE KEY_COUNT = 0;

	    END;
	    KEY_XAB = .XAB_BLOCK [XAB$L_NXT];

	    WHILE .KEY_XAB NEQU 0 AND .KEY_COUNT GTR 0 DO
		BEGIN

		IF (.KEY_XAB [XAB$B_COD] EQL XAB$C_KEY)
		THEN
		    BEGIN

		    IF (.KEY_XAB [XAB$W_POS0] NEQ .KEY_XAB [OPEN$W_POS0]) OR (.KEY_XAB [XAB$B_SIZ0] NEQ
			.KEY_XAB [OPEN$B_SIZ0])
		    THEN
			FOR$$SIGNAL_STO (FOR$K_INVKEYSPE);

		    IF .KEY_XAB [OPEN$B_KTYPE] NEQ .KEY_XAB [XAB$B_DTP]
		    THEN
			FOR$$SIGNAL_STO (FOR$K_INVKEYSPE);

		    BEGIN

		    LOCAL
			NEXT;			! Address of next XAB in link

		    NEXT = .KEY_XAB [XAB$L_NXT];
		    FOR$$FREE_VM (OPEN$K_XAB_SIZE, .KEY_XAB);
		    KEY_XAB = .NEXT;
		    END;
		    KEY_COUNT = .KEY_COUNT - 3;
		    END;

		END;

	    END;

	END					! End of old file processing
    ELSE
!<BLF/PAGE>

!

    !+
    ! Else (file was created)
    !	Make sure V_APPEND is off so BACKSPACE will work.
    !-

	BEGIN
	CCB [LUB$V_APPEND] = 0;
	END;

    !+
    ! Set up the list-directed output record size as RECL, if specified,
    ! else 81 (80 if not FORTRAN carriage control).
    !-

    CCB [LUB$W_R_MARGIN] = (IF NOT .V_DEFAULT_SIZE THEN .CCB [LUB$W_RBUF_SIZE] ELSE
	(IF .FAB [FAB$V_FTN] THEN 81 ELSE 80));

    !+
    ! Set bits in the LUB to indicate the file's carriage control
    ! characteristics.  This information is used by INQUIRE.
    !-

    IF .FAB [FAB$V_FTN]
    THEN
	CCB [LUB$V_FTN] = 1;
    IF .FAB [FAB$V_CR]
    THEN
	CCB [LUB$V_CR] = 1;
    IF .FAB [FAB$V_PRN]
    THEN
	CCB [LUB$V_PRN] = 1;

    !+
    ! Allocate record buffer dynamically from LUB$W_RBUF_SIZE setting in bytes.
    ! Set LUB$A_RBUF_ADR to address of buffer allocated.
    !-

    CCB [LUB$A_RBUF_ADR] = FOR$$GET_VM (.CCB [LUB$W_RBUF_SIZE]);

    !+
    ! Allocate dynamic storage for the file name so the name can be
    ! used later on for error diagnostics.  Point the LUB to the new
    ! location.  (The size is already correct!)
    ! Indicate that the string name is now stored in virtual memory so
    ! it will be deallocated!
    !-

    BEGIN

    LOCAL
	T;

    T = FOR$$GET_VM (.CCB [LUB$B_RSL]);
    CH$MOVE (.CCB [LUB$B_RSL], .CCB [LUB$A_RSN], .T);
    CCB [LUB$A_RSN] = .T;
    CCB [LUB$V_VIRT_RSN] = 1;
    END;

    !+
    ! Store a code in the LUB indicating the type of organization.
    !-

    SELECTONE (.FAB [FAB$B_ORG]) OF
	SET

	[FAB$C_SEQ] :
	    CCB [LUB$B_ORGAN] = LUB$K_ORG_SEQUE;

	[FAB$C_REL] :
	    CCB [LUB$B_ORGAN] = LUB$K_ORG_RELAT;

	[FAB$C_IDX] :
	    BEGIN

	    IF .CCB [LUB$V_SEGMENTED] THEN FOR$$SIGNAL_STO (FOR$K_INCRECTYP);

	    CCB [LUB$B_ORGAN] = LUB$K_ORG_INDEX;
	    END;

	[OTHERWISE] :
	    FOR$$SIGNAL_STO (FOR$K_INCFILORG);
	TES;

    !+
    ! Deallocate the FAB if it was allocated by FDBSET or ASSIGN.
    ! Set LUB$A_FAB to zero to indicate that no FAB is present.
    !-

    IF (.CCB [LUB$A_FAB] NEQA FAB_BLOCK) THEN FOR$$FREE_VM (FAB$C_BLN, .CCB [LUB$A_FAB]);

    CCB [LUB$A_FAB] = 0;

    !+
    ! Set RAB fields that seldom change: UBF and USZ
    !-

    CCB [RAB$L_UBF] = .CCB [LUB$A_RBUF_ADR];
    CCB [RAB$W_USZ] = .CCB [LUB$W_RBUF_SIZE];
    CCB [LUB$A_UBF] = .CCB [LUB$A_RBUF_ADR];
!+
! Indicate that the file is now FORTRAN opened.
!-
    CCB [LUB$B_LANGUAGE] = LUB$K_LANG_FOR;
    CCB [LUB$V_OPENED] = 1;
!+
! Make sure that the FORTRAN exit handler will be called when the image
! exits to purge the file's I/O buffers and close it, if necessary.
!-

    IF ( NOT .FOR$$L_XIT_LOCK) THEN FOR$$DECL_EXITH ();

    RETURN;					! Return from OPEN_PROC routine
    END;					! End of OPEN_PROC routine

END						! End of FOR$$OPEN_DEFLT module

ELUDOM
