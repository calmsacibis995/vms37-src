	.TITLE	COB$INTER	COBOL Intermediate Conversions
	.IDENT	/1-019/		; File: COBINTER.MAR

;
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;
;
; FACILITY: COBOL DATA TYPE CONVERSIONS
;++
; ABSTRACT:
;	This module contains all of the data type conversions
;	to and from intermediate temporary for COBOL. 
;
;
;--
;
; VERSION: 1
;
; HISTORY:
;
; AUTHOR:
;	John Sauter, 02-JAN-1979
;
; MODIFIED BY:
;
;
;

	.SBTTL	HISTORY		; Detailed Current Edit History


; Edit History for Version 1 of COBINTER
;
; 1-001	- Original.  JBS 02-JAN-1979
; 1-002 - Continue development.  JBS 12-JAN-1979
; 1-003	- Rearrange intermediate form to put fraction before exponent.
;	   JBS 16-JAN-1979
; 1-004 - Remove the arithmetic routines.  DGP 23-Jan-79
; 1-005 - Remove the constants which refer to the Intermediate data type and
;	  put them in a Require file - COBPARINT.MDL.  DGP 29-Jan-79
; 1-006 - Change the references to the Intermediate data type parameters from
;	  COB$ to INT$.  DGP 30-Jan-79
; 1-007	- Declare externals explicitly.  JBS 06-FEB-1979
; 1-008 - Bug fixing and cleanup.  MLJ 10-Mar-1979
; 1-009 - 19 digit temps and bug fixing.  MLJ 13-Mar-1979
; 1-010 - Correct problem with high order longword in CVTIQ and CVTRIQ.  MLJ 22-Mar-1979
; 1-011 - Comment out ASHP that specified rounding in CVTIP.  WPS 11-June-1979.
; 1-012	- Correct DIVP rounding toward 0 in conversions to quad.  PDG 12-Jul-1979
; 1-013 - Get edit history in synch with ident statement.
;	  RKR 04-Sept-1979
; 1-014 - Set INT$P_I_FRAC to 2.  RKR 11-Sept-79
; 1-015 - Change all references to FOR$CNV_IN_DEFG to OTS$_CVT_T_D
;	  RKR 27-SEPT-79
; 1-016 - Change all references to FOR$CNV_OUT_E to COB$CNVOUT.
;	  RKR 27-SEPT-79
; 1-017 - Make INT$$NORMALIZE local.  Cosmetic changes.  RKR 21-OCT-79
; 1-018 - Change CIT reserved operand detection logic.  RKR 30-OCT-79
; 1-019 - Fix normalization problem in CVTPI.  MLJ 21-Nov-1979
;

	.SBTTL	DECLARATIONS

	.DSABL	GBL

;
; INCLUDE FILES:
;
	$INTDEF				; Intermediate data type format
	$DSCDEF				; Descriptor definitions
;
; EXTERNAL SYMBOLS:
;
	.EXTRN	LIB$SIGNAL	; Signal an error
	.EXTRN	LIB$STOP	; Signal a fatal error
;+
; The following are error codes for LIB$SIGNAL and LIB$STOP
;-
	.EXTRN	COB$_INTEXPOVE	; Intermediate exponent overflow
	.EXTRN	COB$_INTEXPUND	; Intermediate exponent underflow
	.EXTRN	COB$_INTRESOPE	; Intermediate reserved operand
	.EXTRN	COB$_INVDECDIG	; Invalid decimal digit
	.EXTRN	OTS$_FATINTERR	; Fatal internal OTS error
;+
; The following subroutines are used for conversion between floating
; point and text.
;-
	.EXTRN	COB$CNVOUT	; Convert floating to E format
	.EXTRN	OTS$CVT_T_D	; Convert text to floating
;
; MACROS:
;
;	NONE
;
; PSECT DECLARATIONS:
	.PSECT	_COB$CODE	PIC, SHR, LONG, EXE, NOWRT

;
; EQUATED SYMBOLS:
	INT$P_I_FRACT = 2		; Temporary until Packed supported in MDL
					; Fraction field offset

;
; OWN STORAGE:
;
;+
; The following constant has the value 2**32.  It is used for scaling
; the high 32 bits and for compensating for unsigned arithmetic.
;-
BIAS:	.PACKED	4294967296		; 2**32
;+
; The following constant is 2**32-1.  It's subtracted from negative numbers
; when converting to quad, to compensate for DIVP truncating toward zero.
;-
BIAS_1:	.PACKED	4294967295		; 2**32-1
BIAS_DIGITS=10				; Number of digits in 2**32
;
; Note that the Quadword-to-Intermediate conversion routine knows that
; the intermediate-form fraction has 18 digits.  This is because a
; quadword has 18 or (rarely) 19 digits, and the code is significantly
; more efficient if it can shift by 0 or (rarely) 1 digit rather than
; computing how much to shift, as the Packed-to-Intermediate conversion
; routine must.
;
; Similarly, NORMALIZE and CVTTI manipulate the intermediate form
; internals directly.
;--

	.SBTTL	NORMALIZE
;
; This is the code to normalize an intermediate-form number.  It is
; branched to from many places in the code.  It expects the 
; unnormalized intermediate-form number on the stack.  The normalized
; number is stored in (R8).
;
INT$$NORMALIZE:
	TSTB	INT$P_I_FRACT(SP)	; Is the number already normal?
	BEQL	2$			; Maybe not.  (May be zero.)
;
; Come here if the number is already normal.  Copy it to the result
; area and then check for underflow and overflow.  Note that this code
; knows the intermediate-form number is 12 bytes long.
;
	MOVQ	(SP),(R8)		; Copy the number
	MOVL	8(SP),8(R8)		;
	BRB	4$			; Check for fault and return
;
; The number is unnormalized or it is zero.  If all of the digits of
; the fraction are zero then the number is zero.
;
2$:	SKPC	#0,#INT$K_I_FRACT_L,INT$P_I_FRACT(SP)
					; Find first non-zero byte
	SUBL3	R0,#INT$K_I_FRACT_L,R4	; Convert to byte offset from base
	ADDL2	R4,R4			; Convert bytes to digits
	BITB	#^XF0,(R1)		; Is high digit non-zero?
	BEQL	3$			; Br if so
	DECL	R4			; No, shift one less
3$:	ASHP	R4,#INT$K_I_FRACT_D,INT$P_I_FRACT(SP),#0, -
		#INT$K_I_FRACT_D,INT$P_I_FRACT(R8)
					; Normalize and store fraction
	BEQL	6$			; Br if fraction is zero
	SUBW3	R4,INT$W_I_EXP(SP),INT$W_I_EXP(R8)
					; Adjust and store exponent
;
; Now check for overflow and underflow.
;
4$:	CMPW	INT$W_I_EXP(R8),#INT$K_I_EXP_HI
					; Is exponent too big?
	BGTR	7$			; Yes, give message
	CMPW	INT$W_I_EXP(R8),#INT$K_I_EXP_LO
					; Is exponent too small?
	BLSS	8$			; Yes, give message
	MOVL	#1,R0			; No, indicate success
5$:	ADDL2	#INT$K_I_LEN,SP		; Remove temp from stack
	RSB				; Return to caller.
;
; Come here if the fraction is zero to store a clean exponent.
;
6$:	CLRW	INT$W_I_EXP(R8)		; Set exponent to zero
	MOVL	#1,R0			; Indicate success
	ADDL2	#INT$K_I_LEN,SP		; Remove temp from stack
	RSB				; Return to caller.
;
; Come to 7$ on overflow.  Signal INTEXPOVE.
; Come to 8$ on underflow.  Signal INTEXPUND.
;
7$:	PUSHL	#COB$_INTEXPOVE		; Intermediate exponent overflow
	BRB	9$			; Print message and return to caller
8$:	PUSHL	#COB$_INTEXPUND		; Intermediate exponent underflow
9$:	CVTLP	#0,#INT$K_I_FRACT_D,INT$P_I_FRACT(R8)
					; Set fraction to zero
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	CLRL	R0			; Indicate failure
	BRB	5$			; Return to caller

	.SBTTL	COB$CVTWI_R8	Convert Word to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert a 16-bit (word) integer to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTWI_R8 (scale.rl.v, src.rw.r, dst.wx.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rw.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTWI_R8::
	SUBL2	#INT$K_I_LEN,SP		; Make room on stack for result
	CVTWL	(R7),R0			; Get source as a longword
	CVTLP	R0,#INT$K_I_FRACT_D,INT$P_I_FRACT(SP)
					; Store as fraction part
	ADDW3	R6,#INT$K_I_FRACT_D,INT$W_I_EXP(SP)
					; Compute and store exponent
	BRW	INT$$NORMALIZE		; Normalize and return.

	.SBTTL	COB$CVTLI_R8	Convert Longword to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert a 32-bit (longword) integer to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTLI_R8 (scale.rl.v, src.rl.r, dst.wx.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rl.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTLI_R8::
	SUBL2	#INT$K_I_LEN,SP		; Make room on stack for result
	CVTLP	(R7),#INT$K_I_FRACT_D,INT$P_I_FRACT(SP)
					; Store source as fraction part
	ADDW3	R6,#INT$K_I_FRACT_D,INT$W_I_EXP(SP)
					; Compute and store exponent
	BRW	INT$$NORMALIZE		; Normalize and return

	.SBTTL	COB$CVTQI_R8	Convert Quadword to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert a 64-bit (quadword) integer to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTQI_R8 (scale.rl.v, src.rq.r, dst.wx.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rq.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTQI_R8::
	SUBL2	#INT$K_I_LEN,SP		; Make room on stack for result
	CMPV	#31,#1,(R7),4(R7)	; Is number in longword range?
	BNEQ	1$			; Br if not to do slower code
	CVTLP	(R7),#INT$K_I_FRACT_D,INT$P_I_FRACT(SP)
					; Store source as fraction part
	ADDW3	R6,#INT$K_I_FRACT_D,INT$W_I_EXP(SP)
					; Compute and store exponent
	BRW	INT$$NORMALIZE		; Normalize and return
;
; Come here if the number is not in longword range.
;
1$:	SUBL2	#20,SP			; Allocate temp space
	CVTLP	4(R7),#10,(SP)		; Convert high order longword
	MULP	#BIAS_DIGITS,BIAS,#10,(SP),#19,8(SP)
					; Multiply by 2**32
	CVTLP	(R7),#10,(SP)		; Convert low order longword
	BGEQ	2$			; Br if nonnegative
	ADDP4	#BIAS_DIGITS,BIAS,#10,(SP)
					; Correct for signed conversion
2$:	ADDP4	#10,(SP),#19,8(SP)	; Sum low and high order parts
;
; Try to fit the number in 18 digits.  If this succeeds, we can use the
; normalize exit.  If not, we must truncate one low order digit.
;
	ASHP	#0,#19,(R3),#0,#INT$K_I_FRACT_D,INT$P_I_FRACT+20(SP)
					; Try to fit in 18 digits
	BVS	3$			; Fail, do special work.
	ADDW3	R6,#INT$K_I_FRACT_D,INT$W_I_EXP+20(SP)
					; Exponent with scale factor
	ADDL2	#20,SP			; Remove local temps
	BRW	INT$$NORMALIZE		; Normalize and return
;
; Come here if we have 19 digits.  We must truncate to 18 digits and
; compensate for the right shift in the exponent.
;
3$:	ASHP	#-1,#19,(R1),#0,#INT$K_I_FRACT_D,(R3)
					; Drop low digit of result
	ADDW3	R6,#INT$K_I_FRACT_D+1,INT$W_I_EXP+20(SP)
					; Exponent with scale factor
	ADDL2	#20,SP			; Remove local temps
	BRW	INT$$NORMALIZE		; Normalize and return

	.SBTTL	COB$CVTFI_R7	Convert Floating to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert single-precision floating to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTFI_R7 (src.rf.r, dst.wx.r)
;
;	Arguments are passed in R6 and R7.
;
; INPUT PARAMETERS:
;	
;	SRC.rf.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R7.
;	
;--

COB$CVTFI_R7::
	SUBL2	#INT$K_I_FRACT_D+7+8,SP	; Result string and value
	CVTFD	(R6),(SP)		; Put value on the stack
;
; Build a static descriptor pointing to the text area.
;
	PUSHAB	8(SP)			; Address = space left
	MOVB	#DSC$K_CLASS_S,-(SP)	; Class = static
	MOVB	#DSC$K_DTYPE_T,-(SP)	; Type = ASCII text
	MOVW	#INT$K_I_FRACT_D+7,-(SP) ; String length
;
; Call COB$CNVOUT.
;
	PUSHL	#INT$K_I_FRACT_D	; Number of digits in fraction
	PUSHAB	4(SP)			; Address of descriptor
	PUSHAB	16(SP)			; Address of value
	CALLS	#3,G^COB$CNVOUT	; Convert to E format
	BLBC	R0,1$			; Should never fail
;+
; Sitting on the stack now is the result string, at 16(SP).
; The string is INT$K_I_FRACT_D+7 characters in length and is in
; the following format:
;
;	+0.ddddddddddddddddddE+ee
;
; We will put the digits into the intermediate form number, with the
; sign, and the number following the E will go into the exponent.
; Note that the number in this form is already normalized.
;-
	MOVB	16(SP),18(SP)		; Put sign on top of "."
	CVTSP	#INT$K_I_FRACT_D,18(SP),#INT$K_I_FRACT_D,INT$P_I_FRACT(R7)
					; Pack the fraction
	CVTSP	#2,INT$K_I_FRACT_D+20(SP),#2,(SP)
					; Make packed exponent
	CVTPL	#2,(SP),R1		; Make exponent binary
					;     (also clears R0)
	CVTLW	R1,INT$W_I_EXP(R7)	; Store as exponent of int. number
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#INT$K_I_FRACT_D+7+8+8,SP ; Delete stack temps
	RSB				; Return to caller
;+
; Come here on failure of COB$CNVOUT.  Since any single-precision
; floating number can be represented in the intermediate form, this
; represents an OTS failure.
;-
1$:	PUSHL	#OTS$_FATINTERR		; Fatal error in OTS
	CALLS	#1,G^LIB$STOP

	.SBTTL	COB$CVTDI_R7	Convert Double to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert double-precision floating to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTDI_R7 (src.rd.r, dst.wx.r)
;
;	Arguments are passed in R6 and R7.
;
; INPUT PARAMETERS:
;	
;	SRC.rd.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R7.
;	
;--

COB$CVTDI_R7::
	SUBL2	#INT$K_I_FRACT_D+7+8,SP	; Result string and value
	MOVD	(R6),(SP)		; Put value on the stack
;
; Build a static descriptor pointing to the text area.
;
	PUSHAB	8(SP)			; Address = space left
	MOVB	#DSC$K_CLASS_S,-(SP)	; Class = static
	MOVB	#DSC$K_DTYPE_T,-(SP)	; Type = ASCII text
	MOVW	#INT$K_I_FRACT_D+7,-(SP) ; String length
;
; Call COB$CNVOUT.
;
	PUSHL	#INT$K_I_FRACT_D	; Number of digits in fraction
	PUSHAB	4(SP)			; Address of descriptor
	PUSHAB	16(SP)			; Address of value
	CALLS	#3,G^COB$CNVOUT	; Convert to E format
	BLBC	R0,1$			; Should never fail
;+
; Sitting on the stack now is the result string, at 16(SP).
; The string is INT$K_I_FRACT_D+7 characters in length and is in
; the following format:
;
;	+0.ddddddddddddddddddE+ee
;
; We will put the digits into the intermediate form number, with the
; sign, and the number following the E will go into the exponent.
; Note that the number in this form is already normalized.
;-
	MOVB	16(SP),18(SP)		; Put sign on top of "."
	CVTSP	#INT$K_I_FRACT_D,18(SP),#INT$K_I_FRACT_D,INT$P_I_FRACT(R7)
					; Pack the digits
	CVTSP	#2,INT$K_I_FRACT_D+20(SP),#2,(SP)
					; Make packed exponent
	CVTPL	#2,(SP),R1		; Make exponent binary
					;     (also clears R0)
	CVTLW	R1,INT$W_I_EXP(R7)	; Store as exponent of int. number
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#INT$K_I_FRACT_D+7+8+8,SP ; Delete stack temps
	RSB				; Return to caller
;+
; Come here on failure of COB$CNVOUT.  Since any double-precision
; floating number can be represented in the intermediate form, this
; represents an OTS failure.
;-
1$:	PUSHL	#OTS$_FATINTERR		; Fatal error in OTS
	CALLS	#1,G^LIB$STOP

	.SBTTL	COB$CVTPI_R9	Convert Packed to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert a packed integer to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTPI_R9 (scale.rl.v, srclen.rl.v, src.rp.r, dst.wx.r)
;
;	Arguments are passed in R6, R7, R8 and R9.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRCLEN.rl.v		The number of digits in the source
;	SRC.rp.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R9.
;	
;--

COB$CVTPI_R9::
	SUBL2	#INT$K_I_LEN,SP		; Make room on stack for result
	CMPL	R7,#INT$K_I_FRACT_D	; Will all digits fit?
	BGTR	12$			; No, must take significant ones.
;+
; Come here if all of the digits of the source will fit in the
; intermediate-form fraction.  This is handled as a special case
; because it occurs often and it saves having to scan the source
; looking for the most significant byte.  (Note that this is done
; in NORMALIZE anyway, so we don't save all that much.)
;-
	ASHP	#0,R7,(R8),#0,#INT$K_I_FRACT_D,INT$P_I_FRACT(SP)
					; Copy source to fraction
	ADDW3	R6,#INT$K_I_FRACT_D,INT$W_I_EXP(SP)
					; Compute and store exponent
	MOVL	R9,R8			; Point R8 to destination
	BRW	INT$$NORMALIZE		; Normalize and check for overflow
;+
; Come here when the source will not fit in the fraction part of an
; intermediate form number.  We must scan the source digits looking
; for the most significant (non-zero) digit.  The result will be
; normalized, so the NORMALIZE exit will take its fast path, just
; checking for overflow and underflow.
;-
12$:	ASHL	#-1,R7,R4		; Compute length in bytes =
	INCL	R4			;     digits/2 + 1
	SKPC	#0,R4,(R8)		; Find first non-zero byte
	SUBL2	R0,R4			; Convert to byte offset from base
	ADDL2	R4,R4			; Convert bytes to digits
	BLBS	R7,125$			; If number is even-length
	DECL	R4			;     allow for one high order zero
125$:	BITB	#^XF0,(R1)		; Is high digit non-zero?
	BNEQ	13$			; Br if not
	INCL	R4			; Count one more high order zero
;+
; R4 now contains the number of high order zeros in the input number.
; R7-R4 is thus the number of significant digits.  We want to shift the input
; number into the result such that the most significant digit is in the 18th
; digit position.  Therefore compute the shift amount as 18-(R7-R4), or
; R4 - R7 + 18.
;-
13$:	SUBL2	R7,R4
	ADDL2	#18,R4
	ASHP	R4,R7,(R8),#0,#INT$K_I_FRACT_D,INT$P_I_FRACT(SP)
					; Normalize and store fraction
	SUBL2	R4,R6			; Adjust scale
	ADDW3	R6,#INT$K_I_FRACT_D,INT$W_I_EXP(SP)
					; Compute and store exponent
	MOVL	R9,R8			; Point R8 to destination
	BRW	INT$$NORMALIZE		; Normalize and check for overflow

	.SBTTL	COB$CVTIW_R8	Convert Intermediate to Word

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to word (16-bit) integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTIW_R8 (scale.rl.v, src.rx.r, dst.ww.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.ww.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTIW_R8::
	SUBL2	#4,SP			; Make room for temp storage
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	13$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	13$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	14$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; No, compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count a signed byte?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#0,#5,(SP)
					; Scale and integerize fraction
	BVS	11$			; Won't fit in 5 digits, error
	CVTPL	#5,(SP),R1		; Make a longword
					;     (also clears R0)
	CVTLW	R1,(R8)			; Store result as a word
	BVS	11$			; Cannot, indicate an error
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#4,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If it is negative, return zero.
;-
10$:	BBS	#15,R6,14$		; Branch if negative
;+
; Come here if the number cannot be represented in 16 bits.  Give an
; error return.
;-
11$:	CLRL	R0			; Indicate failure
	ADDL2	#4,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here on the reserved operand.  Signal and give an error return.
;-
13$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	BRB	11$			; Indicate failure and return.
;+
; Come here if the source is zero or if the shift count is too small
; for ASHP.  Return zero.
;-
14$:	CLRW	(R8)			; Store zero in destination
	MOVL	#1,R0			; Indicate success
	ADDL2	#4,SP			; Remove temp from stack
	RSB				; Return to caller.

	.SBTTL	COB$CVTRIW_R8	Convert Rounded Intermediate to Word

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to word (16-bit) integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTRIW_R8 (scale.rl.v, src.rx.r, dst.ww.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.ww.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE.
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTRIW_R8::
	SUBL2	#4,SP			; Make room for temp storage
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	13$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	13$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	14$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; No, compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count a signed byte?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#5,#5,(SP)
					; Scale and integerize fraction
	BVS	11$			; Won't fit in 5 digits, error
	CVTPL	#5,(SP),R1		; Make a longword
					;     (also clears R0)
	CVTLW	R1,(R8)			; Store result as a word
	BVS	11$			; Cannot, indicate an error
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#4,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If it is negative, return zero.
;-
10$:	BBS	#15,R6,14$		; Branch if negative
;+
; Come here if the number cannot be represented in 16 bits.  Give an
; error return.
;-
11$:	CLRL	R0			; Indicate failure
	ADDL2	#4,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here on the reserved operand.  Signal and give an error return.
;-
13$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	BRB	11$			; Indicate failure and return.
;+
; Come here if the source is zero or if the shift count is too small
; for ASHP.  Return zero.
;-
14$:	CLRW	(R8)			; Store zero in destination
	MOVL	#1,R0			; Indicate success
	ADDL2	#4,SP			; Remove temp from stack
	RSB				; Return to caller.

	.SBTTL	COB$CVTIL_R8	Convert Intermediate to Longword

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to longword (32-bit) integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTIL_R8 (scale.rl.v, src.rx.r, dst.wl.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wl.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTIL_R8::
	SUBL2	#8,SP			; Make room for temp storage
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	13$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	13$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	14$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; No, compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count a signed byte?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#0,#10,(SP)
					; Scale and integerize fraction
	BVS	11$			; Won't fit in 10 digits, error
	CVTPL	#10,(SP),(R8)		; Make a longword
					;     (also clears R0)
	BVS	11$			; Cannot, indicate an error
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#8,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If it is negative, return zero.
;-
10$:	BBS	#15,R6,14$		; Branch if negative
;+
; Come here if the number cannot be represented in 32 bits.  Give an
; error return.
;-
11$:	CLRL	R0			; Indicate failure
	ADDL2	#8,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here on the reserved operand.  Signal and give an error return.
;-
13$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	BRB	11$			; Indicate failure and return.
;+
; Come here if the source is zero or if the shift count is too small
; for ASHP.  Return zero.
;-
14$:	CLRL	(R8)			; Store zero in destination
	MOVL	#1,R0			; Indicate success
	ADDL2	#8,SP			; Remove temp from stack
	RSB				; Return to caller.

	.SBTTL	COB$CVTRIL_R8	Convert Rounded Intermediate to Longword

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to longword (32-bit) integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTRIL_R8 (scale.rl.v, src.rx.r, dst.wl.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wl.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTRIL_R8::
	SUBL2	#8,SP			; Make room for temp storage
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	13$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	13$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	14$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; No, compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count a signed byte?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#5,#10,(SP)
					; Scale and integerize fraction
	BVS	11$			; Won't fit in 10 digits, error
	CVTPL	#10,(SP),(R8)		; Make a longword
					;     (also clears R0)
	BVS	11$			; Cannot, indicate an error
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#8,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If it is negative, return zero.
;-
10$:	BBS	#15,R6,14$		; Branch if negative
;+
; Come here if the number cannot be represented in 32 bits.  Give an
; error return.
;-
11$:	CLRL	R0			; Indicate failure
	ADDL2	#8,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here on the reserved operand.  Signal and give an error return.
;-
13$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	BRB	11$			; Indicate failure and return.
;+
; Come here if the source is zero or if the shift count is too small
; for ASHP.  Return zero.
;-
14$:	CLRL	(R8)			; Store zero in destination
	MOVL	#1,R0			; Indicate success
	ADDL2	#8,SP			; Remove temp from stack
	RSB				; Return to caller.

	.SBTTL	COB$CVTIQ_R8	Convert Intermediate to Quadword

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to quadword (64-bit) integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTIQ_R8 (scale.rl.v, src.rx.r, dst.wq.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wq.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTIQ_R8::
	SUBL2	#24,SP			; Make room for temp storage
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	13$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	13$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	14$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; Compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count in signed byte range?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#0,#19,(SP)
					; Scale and integerize fraction
	BVS	12$			; Won't fit in 19 digits, error
	CVTPL	#19,(SP),(R8)		; Attempt simple conversion
					;     (also clears R0)
	BVS	11$			; Simple conversion failed.
;+
; Come here if the number can be represented by a longword, which is
; quite common.  We can just spread the sign to the high 32 bits and
; return.
;-
	ASHL	#-31,(R8)+,(R8)		; Spread sign
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#24,SP			; Remove temp storage
	RSB				; Return to caller.
;+
; Come here if the number cannot be represented by a longword.  The
; correct low-order 32 bits have already been stored, we must now
; compute the high-order 32 bits.
;-
11$:	BLBC	9(SP),115$		; Skip if positive
	SUBP4	#BIAS_DIGITS,BIAS_1,#19,(SP)  ; Make more negative
115$:	DIVP	#BIAS_DIGITS,BIAS,#19,(SP),#19,12(SP)  ; Divide by 2**32
	CVTPL	#19,(R5),4(R8)		; Convert and store high bits
					;     (also clears R0)
	BVS	12$			; Number too large for a 64-bit integer
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#24,SP			; Remove temp storage
	RSB				; Return to caller
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If negative, return zero.
;-
10$:	BBS	#15,R6,14$		; Branch if negative
;+
; Come here if the number cannot be represented in 64 bits.  Give an
; error return.
;-
12$:	CLRL	R0			; Indicate failure
	ADDL2	#24,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here on reserved operand.  Signal an error and give the failure
; return to the user.
;-
13$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	BRB	12$			; Give failure return.
;+
; Come here if the source is zero or the shift count is too small for
; ASHP.  Return a zero.
;-
14$:	CLRQ	(R8)			; Set result to zero
	MOVL	#1,R0			; Indicate success
	ADDL2	#24,SP			; Remove temp from stack
	RSB				; Return to caller.

	.SBTTL	COB$CVTRIQ_R8	Convert Rounded Intermediate to Quadword

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to quadword (64-bit) integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTRIQ_R8 (scale.rl.v, src.rx.r, dst.wq.r)
;
;	Arguments are passed in R6, R7 and R8.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wq.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTRIQ_R8::
	SUBL2	#24,SP			; Make room for temp storage
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	13$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	13$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	14$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; Compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count in signed byte range?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#5,#19,(SP)
					; Scale and integerize fraction
	BVS	12$			; Won't fit in 19 digits, error
	CVTPL	#19,(SP),(R8)		; Attempt simple conversion
					;     (also clears R0)
	BVS	11$			; Simple conversion failed.
;+
; Come here if the number can be represented by a longword, which is
; quite common.  We can just spread the sign to the high 32 bits and
; return.
;-
	ASHL	#-31,(R8)+,(R8)		; Spread sign
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#24,SP			; Remove temp storage
	RSB				; Return to caller.
;+
; Come here if the number cannot be represented by a longword.  The
; correct low-order 32 bits have already been stored, we must now
; compute the high-order 32 bits.
;-
11$:	BLBC	9(SP),115$		; Skip if positive
	SUBP4	#BIAS_DIGITS,BIAS_1,#19,(SP)  ; Make more negative
115$:	DIVP	#BIAS_DIGITS,BIAS,#19,(SP),#19,12(SP)  ; Divide by 2**32
	CVTPL	#19,(R5),4(R8)		; Convert and store high bits
					;     (also clears R0)
	BVS	12$			; Number too large for a 64-bit integer
	INCL	R0			; Indicate success, R0 = 1
	ADDL2	#24,SP			; Remove temp storage
	RSB				; Return to caller
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If negative, return zero.
;-
10$:	BBS	#15,R6,14$		; Branch if negative
;+
; Come here if the number cannot be represented in 64 bits.  Give an
; error return.
;-
12$:	CLRL	R0			; Indicate failure
	ADDL2	#24,SP			; Remove temp from stack
	RSB				; Return to caller.
;+
; Come here on reserved operand.  Signal an error and give the failure
; return to the user.
;-
13$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	BRB	12$			; Give failure return.
;+
; Come here if the source is zero or the shift count is too small for
; ASHP.  Return a zero.
;-
14$:	CLRQ	(R8)			; Set result to zero
	MOVL	#1,R0			; Indicate success
	ADDL2	#24,SP			; Remove temp from stack
	RSB				; Return to caller.

	.SBTTL	COB$CVTIF_R7	Convert Intermediate to Floating

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert intermediate to single-precision floating
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTIF_R7 (src.rx.r, dst.wf.r)
;
;	Arguments are passed in R6 and R7.
;
; INPUT PARAMETERS:
;	
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wf.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R7.
;	
;--

COB$CVTIF_R7::
	CMPW	INT$W_I_EXP(R6), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	4$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R6), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	4$				 ; Yes, underflow
	SUBL2	#INT$K_I_FRACT_D+7+8,SP	; Allocate space for string and result
;+
; Convert the intermediate-form number to text using the following
; format:
;
;	+0.ddddddddddddddddddE+ee
;
; so that it can be converted by OTS$CVT_T_D.
;-
	CVTPS	#INT$K_I_FRACT_D,INT$P_I_FRACT(R6), -
		#INT$K_I_FRACT_D,10(SP)	; Convert fraction to separate
	MOVB	(R3),8(SP)		; Move sign over
	MOVW	#^A/0./,9(SP)		; Start with "+0."
	CVTWL	INT$W_I_EXP(R6),R0	; Get exponent
	CVTLP	R0,#2,(SP)		; Make a packed number
	BVS	3$			; Should never fail
	CVTPS	#2,(SP),#2,INT$K_I_FRACT_D+12(SP)
					; Make a separate sign number
	MOVB	#^A/E/,-(R3)		; Make it "E+ee"
;+
; Build the descriptor for OTS$CVT_T_D.
;-
	PUSHAB	8(SP)			; Address = area reserved
	MOVB	#DSC$K_CLASS_S,-(SP)	; Class = static
	MOVB	#DSC$K_DTYPE_T,-(SP)	; Data type = ASCII text
	MOVW	#INT$K_I_FRACT_D+7,-(SP); Length of string
;+
; Now call the conversion routine.
;-
	PUSHAB	8(SP)			; Address of value
	PUSHAB	4(SP)			; Address of descriptor
	CALLS	#2,G^OTS$CVT_T_D	; Convert the number
	BLBC	R0,2$			; Failure -- must be overflow
	CVTDF	8(SP),(R7)		; Store result for user
	BVS	2$			; Conversion failed
	MOVL	#1,R0			; Indicate success
	ADDL2	#INT$K_I_FRACT_D+7+8+8,SP ; Delete stack temps
	RSB				; Return to caller
;+
; Come here if the conversion fails.  This means that the intermediate-
; form number cannot be represented as a single-precision floating point
; number.  Store the reserved operand and return a failure indication.
;-
2$:	ADDL2	#INT$K_I_FRACT_D+7+8+8,SP ; Delete stack temps
1$:	ASHL	#15,#1,(R7)		; Store floating reserved operand
	CLRL	R0			; Indicate failure
	RSB				; Return to caller
;+
; Come here if the exponent overflowed 2 decimal digits.  The
; intermediate-form number is messed up.  Signal an internal OTS
; failure.
;-
3$:	PUSHL	#OTS$_FATINTERR		; OTS internal failure
	CALLS	#1,G^LIB$STOP

;+
; Out-of-range exponenent encountered for a CIT. Complain about it.
;-
4$:
	PUSHL	#COB$_INTRESOPE		; CIT reserved operand signal
	CALLS	#1, G^LIB$STOP		; signal and stop.

	.SBTTL	COB$CVTID_R7	Convert Intermediate to Double

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert intermediate to double-precision floating
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTID_R7 (src.rx.r, dst.wd.r)
;
;	Arguments are passed in R6 and R7.
;
; INPUT PARAMETERS:
;	
;	SRC.rx.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wd.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R7.
;	
;--

COB$CVTID_R7::
	CMPW	INT$W_I_EXP(R6), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	4$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R6), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	4$				 ; Yes, underflow
	SUBL2	#INT$K_I_FRACT_D+7+8,SP	; Allocate space for string and result
;+
; Convert the intermediate-form number to text using the following
; format:
;
;	+0.ddddddddddddddddddE+ee
;
; so that it can be converted by OTS$CVT_T_D.
;-
	CVTPS	#INT$K_I_FRACT_D,INT$P_I_FRACT(R6), -
		#INT$K_I_FRACT_D,10(SP)	; Spread out number
	MOVB	(R3),8(SP)		; Move sign over
	MOVW	#^A/0./,9(SP)		; Start with "+0."
	CVTWL	INT$W_I_EXP(R6),R0	; Get exponent
	CVTLP	R0,#2,(SP)		; Make a packed number
	BVS	3$			; Should never fail
	CVTPS	#2,(SP),#2,INT$K_I_FRACT_D+12(SP)
					; Make a separate sign number
	MOVB	#^A/E/,-(R3)		; Make it "E+ee"
;+
; Build the descriptor for OTS$CVT_T_D.
;-
	PUSHAB	8(SP)			; Address = area reserved
	MOVB	#DSC$K_CLASS_S,-(SP)	; Class = static
	MOVB	#DSC$K_DTYPE_T,-(SP)	; Data type = ASCII text
	MOVW	#INT$K_I_FRACT_D+7,-(SP); Length of string
;+
; Now call the conversion routine.
;-
	PUSHAB	8(SP)			; Address of value
	PUSHAB	4(SP)			; Address of descriptor
	CALLS	#2,G^OTS$CVT_T_D	; Convert the number
	BLBC	R0,2$			; Failure -- must be overflow
	MOVD	8(SP),(R7)		; Store result for user
	MOVL	#1,R0			; Indicate success
	ADDL2	#INT$K_I_FRACT_D+7+8+8,SP ; Delete stack temps
	RSB				; Return to caller
;+
; Come here if the conversion fails.  This means that the intermediate-
; form number cannot be represented as a double-precision floating point
; number.  Store the reserved operand and return a failure indication.
;-
2$:	ADDL2	#INT$K_I_FRACT_D+7+8+8,SP ; Delete stack temps
1$:	ASHQ	#15,#1,(R7)		; Store floating reserved operand
	CLRL	R0			; Indicate failure
	RSB				; Return to caller
;+
; Come here if the exponent overflowed 2 decimal digits.  The
; intermediate-form number is messed up.  Signal an internal OTS
; failure.
;-
3$:	PUSHL	#OTS$_FATINTERR		; OTS internal failure
	CALLS	#1,G^LIB$STOP

;+
; Out-of-range exponenent encountered for a CIT. Complain about it.
;-
4$:
	PUSHL	#COB$_INTRESOPE		; CIT reserved operand signal
	CALLS	#1, G^LIB$STOP		; signal and stop.

	.SBTTL	COB$CVTIP_R9	Convert Intermediate to Packed

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to packed integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTIP_R9 (scale.rl.v, src.rx.r, dstlen.rl.v, dst.wp.r)
;
;	Arguments are passed in R6, R7, R8 and R9.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;	DSTLEN.rl.v		The number of digits in the destination
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wp.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R9.
;	
;--

COB$CVTIP_R9::
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	12$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	12$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	13$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; Compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count in signed byte range?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#0,R8,(R9)
					; Scale and integerize fraction
					;     (also clears R0)
	BVS	11$			; Overflow means can't convert
	INCL	R0			; Indicate success, R0 = 1
	RSB				; Return to caller.
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If negative, return zero.
;-
10$:	BBS	#15,R6,13$		; Branch if negative
;+
; Come here if the number cannot be represented in the number of digits
; provided.
;-
11$:	CLRL	R0			; Indicate failure
	RSB				; Return to caller.
;+
; Come here on reserved operand.  Signal the error and give the
; failure return.
;-
12$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	CLRL	R0			; Indicate failure
	RSB				; Return to caller.
;+
; Come here if the source is zero or the shift count is too small for
; the ASHP instruction.  Return a zero.
;-
13$:	CVTLP	#0,R8,(R9)		; Set result to zero
	MOVL	#1,R0			; Indicate success
	RSB				; Return to caller.

	.SBTTL	COB$CVTRIP_R9	Convert Rounded Intermediate to Packed

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert an intermediate number to packed integer.
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTRIP_R9 (scale.rl.v, src.rx.r, dstlen.rl.v, dst.wp.r)
;
;	Arguments are passed in R6, R7, R8 and R9.
;
; INPUT PARAMETERS:
;	
;	SCALE.rl.v		The power of ten by which the internal
;				representation of the source must be
;				multiplied to scale the same as the 
;				internal representation of the dest.
;	SRC.rx.r		The number to be converted
;	DSTLEN.rl.v		The number of digits in the destination
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wp.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R9.
;	
;--

COB$CVTRIP_R9::
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_HI ; Bigger than biggest ?
	BGTR	12$				 ; Yes, overflow
	CMPW	INT$W_I_EXP(R7), #INT$K_I_EXP_LO ; Smaller than smallest
	BLSS	12$				 ; Yes, underflow
	TSTB	INT$P_I_FRACT(R7)	; Is source zero?
	BEQL	13$			; Yes, return zero.
	ADDW2	INT$W_I_EXP(R7),R6	; Compute adjusted scale
	SUBW2	#INT$K_I_FRACT_D,R6
	CVTWB	R6,R0			; Shift count in signed byte range?
	BVS	10$			; No, special handling
	ASHP	R6,#INT$K_I_FRACT_D,INT$P_I_FRACT(R7),#5,R8,(R9)
					; Scale and integerize fraction
					;     (also clears R0)
	BVS	11$			; Overflow means can't convert
	INCL	R0			; Indicate success, R0 = 1
	RSB				; Return to caller.
;+
; Come here if the shift count is not in signed byte range.  If it is
; positive, an overflow exists.  If negative, return zero.
;-
10$:	BBS	#15,R6,13$		; Branch if negative
;+
; Come here if the number cannot be represented in the number of digits
; provided.
;-
11$:	CLRL	R0			; Indicate failure
	RSB				; Return to caller.
;+
; Come here on reserved operand.  Signal the error and give the failure
; return to the user.
;-
12$:	PUSHL	#COB$_INTRESOPE		; Intermediate reserved operand
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
	CLRL	R0			; Indicate failure
	RSB				; Return to caller.
;+
; Come here if the source is zero or if the shift count is too small
; for the ASHP instruction.  Return a zero.
;-
13$:	CVTLP	#0,R8,(R9)		; Set result to zero
	MOVL	#1,R0			; Indicate success
	RSB				; Return to caller.

	.SBTTL	COB$CVTTI_R8	Convert Text to Intermediate

;++
; FUNCTIONAL DESCRIPTION:
;
;	Convert text to intermediate
;
; CALLING SEQUENCE:
;
;	JSB COB$CVTTI_R8 (srclen.rl.v, src.rt.r, dst.wx.r)
;
;	Arguments are passed in R6, R7 and R8
;
; INPUT PARAMETERS:
;	
;	SRCLEN.rl.v		The number of digits in the source
;	SRC.rt.r		The number to be converted
;
; IMPLICIT INPUTS:
;
;	All of the trap bits in the PSL are assumed off.
;
; OUTPUT PARAMETERS:
;
;	DST.wx.r		The place to store the converted number
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
;
;	1 = SUCCESS, 0 = FAILURE
;
; SIDE EFFECTS:
;
;	Destroys registers R0 through R8.
;	
;--

COB$CVTTI_R8::
	SUBL2	#INT$K_I_FRACT_D+1,SP	; Space for separate-sign fraction
;+
; Since the compiler will convert the text string with in-line code if it can,
; there is no need to include a test for this case.  Thus we will assume that
; the string is too long to be converted using decimal string instructions.
;-
	CVTLP	#0,#INT$K_I_FRACT_D,INT$P_I_FRACT(R8)
					; Initialize result to zero
	CLRW	INT$W_I_EXP(R8)		; Also set exponent to zero
;+
; Delete leading zeros from the source string so that the result will
; contain the maximum number of significant digits and be normalized.
;-
	TSTL	R6			; Any digits?
	BLEQ	14$			; No, return the zero.
10$:	CMPB	(R7)+,#^A/0/		; Is this digit zero?
	BNEQ	11$			; No, start collecting digits
	SOBGTR	R6,10$			; Loop back for another
	BRB	14$			; All digits zero, return zero.
;+
; Come here at the first non-zero digit of the string.  At this time, R6
; contains the number of digits remaining in the string, which is the
; exponent of the intermediate-form number.  We can now store it and test the
; exponent for overflow.
;-
11$:	CMPL	R6,#INT$K_I_EXP_HI	; Is exponent too big?
	BGTR	16$			; Yes, fail to convert.
	MOVW	R6,INT$W_I_EXP(R8)	; Store exponent
	DECL	R7			; Correct for autoincrement
;+
; Build a leading separate sign representation of the first 18 digits.
;-
	MOVC5	#0,(SP),#^A/0/,#INT$K_I_FRACT_D,1(SP)
					; Zero-fill the digits
	MOVB	#^A/+/,(SP)		; Insert plus sign
	CLRL	R2			; Initialize digit counter
12$:	MOVZBL	(R7)+,R0		; Get digit from input
	SUBL3	#^A/0/,R0,R1		; Convert to binary
	CMPL	R1,#9			; Check range
	BGTRU	15$			; Br if not a digit
	CMPL	R2,#18			; Do not store more than 18 digits
	BGEQU	13$			;
	MOVB	R0,1(SP)[R2]		; Store the digit
	INCL	R2			; Count the digit
13$:	SOBGTR	R6,12$			; Loop if more digits
;+
; Come here when we have processed all digits.
;-
	CVTSP	#INT$K_I_FRACT_D,(SP),#INT$K_I_FRACT_D,INT$P_I_FRACT(R8)
					; Get packed fraction
14$:	ADDL2	#INT$K_I_FRACT_D+1,SP	; Delete stack temps
	MOVL	#1,R0			; Indicate success
	RSB				; Return
;+
; Come here on an invalid digit.  Signal the error and indicate failure.
; Return the reserved operand.  The invalid digit is in R0.
;-
15$:	PUSHL	#1			; Construct ASCIC digit at top
	MOVB	R0,1(SP)		;     of stack
					; This is the FAO argument
	PUSHL	SP			; Address of FAO argument
	PUSHL	#1			; Count of FAO arguments
	PUSHL	#COB$_INVDECDIG		; Message code: Invalid decimal digit
	CALLS	#3,G^LIB$SIGNAL		; Print message for user
	ADDL2	#4,SP			; Remove FAO argument
	BRB	17$			; Set reserved operand and return
;+
; Come here if there are so many digits that the exponent overflows.
; Store the reserved operand, signal the error and give the failure
; return.
;-
16$:	PUSHL	#COB$_INTEXPOVE		; Intermediate exponent overflow
	CALLS	#1,G^LIB$SIGNAL		; Print message for user
17$:	MOVW	#INT$K_I_EXP_RES,INT$W_I_EXP(R8)
					; Exponent marks reserved operand
	CLRL	R0			; Indicate failure
	ADDL2	#INT$K_I_FRACT_D+1,SP	; Delete stack temps
	RSB				; Return
;
	.END				; End of module COB$INTER
