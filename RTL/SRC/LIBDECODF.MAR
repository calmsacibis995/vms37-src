	.TITLE	LIB$DECODE_FAULT - Decode instruction stream
	.IDENT	/1-005/			; File: LIBDECODF.MAR Edit: SBL1005

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: General Utility Library
;
; ABSTRACT:
;
;	LIB$DECODE_FAULT is a procedure which analyzes the instruction
;	stream and environment at the time of an instruction fault and
;	which calls a user-supplied procedure to "handle" the fault.
;
; ENVIRONMENT: Runs at any access mode, AST Reentrant
;
; AUTHOR: Steven B. Lionel, 12-August-1981
;
;	NOTE:  This module contains a great amount of code adapted from
;	       LIB$EMULATE, written by Derek Zave.  Because of the large
;	       amount of common code between this module, LIB$EMULATE and
;	       LIB$SIM_TRAP (also written by Derek Zave), all three
;	       modules should be investigated if a problem should be found
;	       in any one of them.
;
;
; MODIFIED BY:
;
; 1-001 - Original.  SBL 12-Aug-1981
; 1-002 - Make register change counters words instead of bytes, since the
;	  modification can conceivably be greater than 256 bytes.
;	  Increase user stack to 80 longwords to be safe.  SBL 11-Sept-1981
; 1-003 - Correct argument count test for user_arg and opcode_table.
;	  Correct test for valid standard opcode.  Correct register-mode
;	  operand processing.  SBL 20-Oct-1981
; 1-004 - Correct 1-byte vs. 2-byte opcode test. Swap order of Modify and
;	  Write access codes.  SBL 22-Oct-1981
; 1-005 - Correct and rearrange order of exception-type checks.  Use
;	  LIB$GET_OPCODE if a BPT is found.  SBL 10-Dec-1981
;--

	.SBTTL	DECLARATIONS
;
; LIBRARY MACRO CALLS:
;
	$SSDEF			; System Status Codes
	$SFDEF			; Stack frame definitions
	$DSCDEF			; Descriptor codes
	$CHFDEF			; Condition handling codes
	$PSLDEF			; Processor Status Longword codes
	$LIBDCFDEF		; LIB$DECODE_FAULT definitions
;
; EXTERNAL DECLARATIONS:
;
	.DSABL	GBL		; Force all external symbols to be declared
	.EXTRN	SYS$CALL_HANDL	; System routine that calls handlers
	.EXTRN	SYS$SRCHANDLER	; System routine that looks for handlers
	.EXTRN	SYS$UNWIND	; $UNWIND system service
	.EXTRN	LIB$GET_OPCODE	; Get original opcode from debugger
	.EXTRN	LIB$STOP	; Signal severe error
	.EXTRN	LIB$_INVARG	; Invalid argument error code
;
; MACROS:
;

;	Macro for Comparing Condition Codes
	.MACRO	CMPCOND	COND,LOC
	CMPZV	#3,#26,LOC,#COND@-3
	.ENDM

;	Macro for generating operand definition codes
	.MACRO	OPDEF	A1,A2,A3,A4,A5,A6
	.IRP	XCODE,<A1,A2,A3,A4,A5,A6>
	.IF NOT_BLANK XCODE
	.BYTE	<LIB$K_DCFTYP_%EXTRACT(1,1,XCODE)@LIB$V_DCFTYP>+ -
		LIB$K_DCFACC_%EXTRACT(0,1,XCODE)
	.ENDC
	.ENDR
	.BYTE	LIB$K_DCFOPR_END
	.ENDM
	
	
;
; EQUATED SYMBOLS:
;
;	See body of routine
;
; OWN STORAGE:
;
;	NONE
;
; PSECT DECLARATIONS:
;
	.PSECT _LIB$CODE PIC, USR, CON, REL, LCL, SHR, -
			EXE, RD, NOWRT, LONG


	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*			Assorted Definitions		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;
	;	Parameters
	;
CALL_ARGS =	80			; flexible stack space (longwords)
					; This is enough for 16 octaword
					; operands, plus some extra room.
	;
	;
	;	Call Frame Layout
	;
HANDLER =	0			; condition handler location
SAVE_PSW =	4			; saved processor status word
SAVE_MASK =	6			; register save mask
MASK_ALIGN =	14			; bit position of alignment bits
SAVE_AP =	8			; user's argument pointer
SAVE_FP =	12			; user's frame pointer
SAVE_PC =	16			; return point
REG_R0	=	20			; user's R0
REG_R1	=	24			; user's R1
REG_R2	=	28			; user's R2
REG_R3	=	32			; user's R3
REG_R4	=	36			; user's R4
REG_R5	=	40			; user's R5
REG_R6	=	44			; user's R6
REG_R7	=	48			; user's R7
REG_R8	=	52			; user's R8
REG_R9	=	56			; user's R9
REG_R10 =	60			; user's R10
REG_R11 =	64			; user's R11
FRAME_END =	68			; end of call frame
	;
	;	Call Frame Extension Layout
	;
REG_AP	=	68			; user's AP
REG_FP	=	72			; user's FP
REG_SP	=	76			; user's SP
REG_PC	=	80			; user's PC
PSL	=	84			; user's PSL
LOCAL_END =	88			; end of our local storage
TEMP	=	88			; temporary area for arithmetic
	;
	;	Local Storage Layout
	;
SAVE_ALIGN = 	HANDLER-1		; saved copy of alignment bits
SAVE_PARCNT =	SAVE_ALIGN-1		; saved copy of parameter count
MODE	=	SAVE_PARCNT-1		; access mode for probes
FLAGS	=	MODE-1			; indicator flag bits
SAVE_DEPTH =	FLAGS-4			; saved copy of signal depth
SHORT_LOCAL =	SAVE_DEPTH		; start of short local storage
REGMOD_PC =	SHORT_LOCAL-2		; changes to user's PC
REGMOD_SP =	REGMOD_PC-2		; changes to user's SP
REGMOD_FP =	REGMOD_SP-2		; changes to user's FP
REGMOD_AP =	REGMOD_FP-2		; changes to user's AP
REGMOD_R11 =	REGMOD_AP-2		; changes to user's R11
REGMOD_R10 =	REGMOD_R11-2		; changes to user's R10
REGMOD_R9 =	REGMOD_R10-2		; changes to user's R9
REGMOD_R8 =	REGMOD_R9-2		; changes to user's R8
REGMOD_R7 =	REGMOD_R8-2		; changes to user's R7
REGMOD_R6 =	REGMOD_R7-2		; changes to user's R6
REGMOD_R5 =	REGMOD_R6-2		; changes to user's R5
REGMOD_R4 =	REGMOD_R5-2		; changes to user's R4
REGMOD_R3 =	REGMOD_R4-2		; changes to user's R3
REGMOD_R2 =	REGMOD_R3-2		; changes to user's R2
REGMOD_R1 =	REGMOD_R2-2		; changes to user's R1
REGMOD_R0 =	REGMOD_R1-2		; changes to user's R0

;+
; Define sixteen octawords to hold immediate mode and register
; operands which are to be read.  For register operands, this
; allows the operand value to be unaffected by later auto-increments
; and decrements.
;-

READ_OPERANDS = REGMOD_R0 - 256		; 16 octawords for operands

;+
; Define array of read operand addresses to be passed to user's action
; routine.
;-

READ_ADDRS =	READ_OPERANDS - 64	; 16 longword addresses

;+
; Define array of write operand addresses to be passed to user's action
; routine.
;-

WRITE_ADDRS =	READ_ADDRS - 64		; 16 longword addresses


;+
; Define array of operand types to be passed to user's action routine.
;-

OPERAND_TYPES =	WRITE_ADDRS - 64	; 16 longwords

N_OF_OPERANDS =	OPERAND_TYPES- 4	; Number of operands
INSTR_OPCODE =	N_OF_OPERANDS - 4	; Zero-extended opcode

INSTR_DEF = 	INSTR_OPCODE-4		; address of instruction operand
					; definition table entry
USER_ACT_ARG =	INSTR_DEF-4		; user action routine argument
USER_ACT_ENV =	USER_ACT_ARG-4		; user action routine environment
USER_ACT_ADR =	USER_ACT_ENV-4		; user action routine address
SAVE_SIGARGS =	USER_ACT_ADR-4		; address of signal arguments
COND_NAME =	SAVE_SIGARGS-4		; saved condition name
LOCAL_START =	COND_NAME		; start of our local storage
	;
	;	Flag Bit Numbers
	;	
V_REGISTER =	0			; Current operand is a register
V_RESIGNAL =	1			; Resignal requested
	;
	;	Flag Bit Masks
	;
M_REGISTER =	1@V_REGISTER		; Current operand is a register
M_RESIGNAL =	1@V_RESIGNAL		; Resignal requested
	;

	.SBTTL	LIB$DECODE_FAULT - Decode instruction stream.
;++
; FUNCTIONAL DESCRIPTION:
;
;	This procedure is to be called by a condition handler at the
;	time of an instruction fault.  It determines the environment
;	of the fault, analyzes the instruction stream to locate
;	operands, and calls a user-supplied procedure to handle the
;	exception.
;
; CALLING SEQUENCE:
;
;	status.wlc.v = LIB$DECODE_FAULT (sigargs.rlu.ra, mechargs.rlu.ra,
;					 user_action.cx.dp
;					 [, user_arg.rz.v
;					 [, opcode_table.rbu.ra]])
;
; FORMAL PARAMETERS:
;
	sigargs = 4		; Address of signal arguments array
	mechargs = 8		; Address of mechanism arguments array
	user_action = 12	; Address of descriptor of user-action
				; procedure.  Datatype may be BPV, in
				; which case the environment value is
				; loaded into R1 before calling.  Other
				; types are assumed to be ZEM.
	user_arg = 16		; Argument to user action routine (optional)
	opcode_table = 20	; Address of byte array that specifies
				; additional opcode definitions.  See
				; text below for more information.
;
; IMPLICIT INPUTS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION STATUS:
;
;	SS$_RESIGNAL    Resignal exception to next handler
;			This status is returned if the current
;			exception is not one of the recognized
;			faults or if the instruction being
;			executed can not be found in either the
;			user-supplied instruction definition
;			tables or our own.
;
; SIDE EFFECTS:
;
;	Stack frames are unwound back to the frame which generated
;	the exception.  Further side effects may be caused by the
;	user action routine.
;
;	LIB$_INVARG	Invalid argument to Run-Time Library
;			This exception is signalled if an instruction
;			definition in the user-supplied opcode
;			table contains an invalid operand definition
;			or if more than 16 operands are defined.
;			Because this exception is signalled after the
;			signal frames are unwound, the exception
;			will appear to have come from a procedure called
;			at the point of the faulting instruction.
;
;--

	.ENTRY	LIB$DECODE_FAULT,-	; entrance
		^M<R2,R3,R4,R5>		; entry mask
	MOVL	sigargs(AP),R0		; R0 = signal array location
	MOVL	CHF$L_SIG_NAME(R0),R1	; R1 = signal name
	CMPCOND	SS$_ROPRAND,R1		; Reserved operand fault?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_FLTOVF_F,R1		; Floating overflow fault?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_FLTUND_F,R1		; Floating underflow fault?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_FLTDIV_F,R1		; Floating divide-by-zero fault?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_OPCDEC,R1		; Opcode reserved to Digital?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_OPCCUS,R1		; Opcode reserved to customers and CSS?
	BEQL	2$			; Ok if it is
	CMPCOND SS$_ACCVIO,R1		; Access violation?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_BREAK,R1		; Breakpoint fault?
	BEQL	2$			; Ok if it is
	CMPCOND	SS$_TBIT,R1		; Trace pending fault?
	BEQL	2$			; Ok if it is
1$:	MOVZWL	#SS$_RESIGNAL, R0	; Resignal exception
	RET				; Return to caller
	
;+
;  Check to see if we can at least read the instruction opcode.  If not,
;  simply resignal.  Get opcode into R3
;-

2$:	MOVL	(R0),R1			; Get signal argument count
	MOVAL	-4(R0)[R1],R1		; Get address of PC/PSL pair
	MOVQ	(R1),R1			; Get PC/PSL in R1-R2
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R2,R2 ; Get current access mode
	PROBER	R2,#1,(R1)		; Can we read first byte?
	BEQL	1$			; If not, resignal
	MOVZBL	(R1),R3			; Get first opcde byte
	CMPB	R3,#^XFD		; 2-byte opcode?
	BLSSU	3$			; skip if not
	PROBER	R2,#2,(R1)		; Probe both bytes
	BEQL	1$			; Skip if not accessible
	MOVZWL	(R1),R3			; Get both opcode bytes

;+
;  If the opcode is BPT, and if the exception is not SS$_BREAK, see
;  if the debugger has modified the instruction stream.
;-
3$:	CMPL	R3,#^X03		; Is it a BPT?
	BNEQ	4$			; No, skip
	MOVL	sigargs(AP),R0		; Get condition name
	CMPCOND	SS$_BREAK,CHF$L_SIG_NAME(R0) ; Is it SS$_BREAK?
	BNEQ	4$			; No, skip
	MOVL	R1,R4			; Save PC
	PUSHL	R1			; Push PC of instruction
	CALLS	#1,G^LIB$GET_OPCODE	; Try to get original instruction
	MOVL	R4,R1			; Restore PC
	MOVL	R0,R3			; R3 has original opcode
	CMPB	R0,#^XFD		; 2-byte opcode?
	BLSSU	4$			; skip if not	
	PROBER	R2,#2,(R1)		; Can we read both bytes?
	BEQL	1$			; Resignal if not
	MOVZWL	(R1),R3			; Get second byte
	MOVB	R0,R3			; Get first byte

;+
;  See if the opcode is defined in either the user's opcode table or
;  our own.
;-
4$:	MOVL	R3, R5			; Save "real" opcode
	CMPB	(AP),#<opcode_table/4>	; opcode_table present?
	BLSSU	STD_OPCODE		; No
	MOVL	opcode_table(AP),R4	; Get address of user opcode table
	BEQL	STD_OPCODE		; If no table, look in standard tables
10$:	MOVZBL	(R4)+,R1		; Get first byte from table
	CMPB	R1,#^XFD		; Is it a 2-byte opcode?
	BLSSU	11$			; Skip if not
	MOVZWL	-1(R4),R1		; Get two-byte code
	INCL	R4			; Update table pointer
	CMPW	R1,#^XFFFF		; End of opcode definitions?
	BEQL	STD_OPCODE		; If so, search standard tables
11$:	CMPW	R1,R3			; Is this the right opcode?
	BEQL	INSTR_FOUND		; If so, we've got it!
12$:	TSTB	(R4)+			; Skip to next opcode
	BEQL	12$			; Defined by end byte of zero
	BRB	10$			; Look at next opcode

;+
; Search our standard tables of opcode definitions.
;-

STD_OPCODE:
	CMPB	R3,#^XFD		; Known two-byte "stick"?
	BGEQU	20$			; Skip if maybe
	MOVZWL	TAB_1BYTE[R3],R4	; Get pattern offset
	BEQL	NOT_FOUND		; If zero, unknown opcode
	MOVAB	TAB_1BYTE[R4],R4	; Get pattern address
	BRB	INSTR_FOUND		; Pattern address in R4
20$:	BGTRU	NOT_FOUND		; We have only the FD stick
	ASHL	#-8,R3,R3		; Get second byte alone
	MOVZWL	TAB_2BYTE[R3],R4	; Get pattern address
	BEQL	NOT_FOUND		; If zero, unknown opcode
	MOVAB	TAB_2BYTE[R4],R4	; Get address of pattern
	BRB	INSTR_FOUND

;+
; Come here if we can't find a definition for the instruction.
;-

NOT_FOUND:
	MOVZWL	#SS$_RESIGNAL,R0	; resignal current exception
	RET				; Return to CHF

;+
;  We now know that we want to handle the exception.  Unwind the
;  stack frames back to the one which caused the exceptions.  We actually
;  don't reset SP until the very end.
;-

INSTR_FOUND:
	MOVAB	-12(FP),SP		; allocate stack space AP, FP, SP
	PUSHR	#^M<R6,R7,R8,R9,R10,R11> ; save registers R6-R11
	SUBL2	#24,SP			; allocate space for R0,R1,R2,R3,R4,R5
	MOVL	FP,R0			; R0 = current frame pointer

4$:	TSTL	(R0)			; Does that frame have a handler?
	BEQL	5$			; Skip if not
;+
;  Call frame's handler with SS$_UNWIND.  Note that this is not exactly
;  how SYS$UNWIND does it, but is our best approximation.  The difference
;  is that there is no protection from overlapping unwinds.
;-
	MOVL	R0,-(SP)		; Save our R0
	CLRQ	-(SP)			; Construct mechanism argument list
					; Use dummy R0-R1 since we'll
					; ignore what the handler do to them
					; anyway.
	CLRL	-(SP)			; Depth=0
	PUSHL	R0			; Establisher's FP
	PUSHL	#4			; Number of mechanism args
	MOVZWL	#SS$_UNWIND, -(SP)	; Create unwind signal argument list
	PUSHL	#1
	PUSHAB	8(SP)			; Mechanism list location
	PUSHAB	4(SP)			; Signal list location
	MOVL	(R0),R1			; Handler address
	JSB	G^SYS$CALL_HANDL	; Call condition handler
	ADDL2	#36,SP			; Pop back to our saved R0
	MOVL	(SP)+,R0		; Restore our R0
;+
; Ok, we're back from calling the handler.  Now unwind the frame.
;-
5$:	EXTZV	#0,#12,SAVE_MASK(R0),R1	; R1 = register save mask
	MOVAB	REG_R0(R0),R2		; R2 = start of registers in R0 frame
	CLRL	R3			; clear the register index
6$:	FFS	R3,#12,R1,R3		; find the next saved register
	BEQL	7$			; no more saved registers - bypass
	MOVL	(R2)+,(SP)[R3]		; get the register value
	INCL	R3			; increment the register number
	BRB	6$			; look some more
7$:	MOVQ	SAVE_AP(R0),48(SP)	; get the values of AP and FP
	CMPL	#SYS$CALL_HANDL+4,16(R0); is this the condition handler ?
	BEQL	8$			; yes - bypass
	MOVL	52(SP),R0		; R0 = location of next call frame
	BRB	5$			; unwind the frame
8$:	SUBL3	#28,sigargs(AP),R0 	; Find the address of the point
					; before the signal arguments list
					; where we will save the signal
					; depth, user-action procedure and
					; argument, operand pattern address
					; and opcode.
	MOVL	R0,56(SP)		; Set saved copy of SP
	MOVL	mechargs(AP),R1		; R1 = mechanism array location
	MOVQ	CHF$L_MCH_SAVR0(R1),(SP); get R0 and R1
	MOVL	CHF$L_MCH_DEPTH(R1),4(R0) ; Save signal depth
	MOVL	user_action(AP),R1	; Get user-action routine descriptor
	CMPB	DSC$B_DTYPE(R1),#DSC$K_DTYPE_BPV ; Bound procedure value?
	BNEQ	9$			; Skip if not
	MOVQ	@DSC$A_POINTER(R1),8(R0); Fetch address and environment
	BRB	10$			; 
9$:	MOVL	DSC$A_POINTER(R1),8(R0) ; Fetch address
	CLRL	12(R0)			; No environment
10$:	CLRQ	16(R0)			; Assume no user-arg 
	CMPB	(AP),#<user_arg/4>	; Is it present?
	BLSSU	11$			; No
	MOVL	user_arg(AP),16(R0)	; Fetch user-arg
11$:	MOVL	R4,20(R0) 		; Save opcode pattern address
	MOVL	R5,24(R0)		; Save opcode
	MOVL	28(R0),R1		; Get signal argument list count
	MOVL	28(R0)[R1],(R0)		; Move PSL to safe spot
	MOVL	R0,28(R0)[R1]		; Move address of saved PSL to
					; PSL's place on the stack

;+
; At this point, the stack looks like this:
;
;		+-----------------------+ <-- SP at exception time
;		|    pointer "A"	|
;		+-----------------------+
;		|	 PC		|
;		+-----------------------+
;		|   signal arg #n-2     | (if any)
;		+-----------------------+
;		| signal condition name |
;		+-----------------------|
;		|  N of signal args     |
;		+-----------------------+
;		| "original" opcode     |
;		+-----------------------+
;		| operand pattern addr  |
;		+-----------------------+
;		| user-action argument  |
;		+-----------------------+
;		|user-action environment|
;		+-----------------------+
;		| user-action address   |
;		+-----------------------+
;		|  signal depth         |
;		+-----------------------+
;		|      PSL		|  <- R0  <- pointer "A"
;		+- - - - - - - - - - - -+
;			... (unknown locations)
;		+- - - - - - - - - - - -+
;		|    saved SP		|
;		+-----------------------+
;		|    saved FP		|
;		+- - - - - - - - - - - -+
;			... (saved R2-AP)
;		+- - - - - - - - - - - -+
;		|    saved R1		|
;		+-----------------------+
;		|    saved R0		|  <- SP
;		+-----------------------+
;
;  We now restore registers R0-SP in a single POPR.  When we're done,
;  SP will point to the saved PSL where R0 points now.
;+

	POPR	#^M<R0,R1,R2,R3,R4,R5,- ; restore registers R0-SP
		R6,R7,R8,R9,R10,R11,AP,FP,SP>

;+
; Compute distance we need to move SP to get CALL_ARGS arguments.
;-
	SUBL3	28(SP),#<CALL_ARGS-9>,-(SP) ; Number of longwords to subtract
					; \\ 28(SP) is the number of sigargs
					; \\ The constant 9 includes 7
					; \\ other pushed arguments, 1 for
					; \\ the sigargs count and 1 for the
					; \\ longword which is pushed by
					; \\ this instruction.
	MULL2	#4,(SP)			; Get number of bytes
	SUBL2	(SP),SP			; There are now CALL_ARGS longwords
					; from (SP) to where we've stored
					; "pointer A". The CALLS instruction
					; will push one more longword.
	CALLS	#CALL_ARGS,B^DECODE_FAULT	; call the major routine
	HALT				; execution should never return here
	;

	.SBTTL	DECODE_FAULT - major processing routine
	;
	;	DECODE_FAULT - major processing routine
	;
	;		parameters:	( Described Below )
	;
	;	Discussion
	;
	;	    This is the major processing routine for LIB$DECODE_FAULT.
	;	The parameter list consists of CALL_ARGS+1 longwords, the last
	;	several of which contain the signal arguments list (including
	;	PC and PSL), the handler depth (from the now-clobbered
	;	mechanism list) and the addresses of the user action routine,
	;	environment, argument, instruction operand pattern
	;	address, and instruction opcode.
	;
	;	    When the routine is entered the CALLS instruction saves
	;	the user's registers R0 to R11 in order and saves AP and FP
	;	elsewhere in the frame. The routine extends the saved
	;	registers by saving the user's AP, FP, SP, PC, and PSL after
	;	the saved register area (the last two are taken from the
	;	parameter list).
	;
	;	    Because we don't know the length of the signal argument
	;	list, we need a clue as to where the values we saved begin.
	;	This is found by looking at the very last argument.  There
	;	we saved the address into the list of where the remaining
	;	values start.  Refer to the previous page for more details.
	;
	;	    The local storage is allocated by extending the stack and
	;	the register modification words are cleared (these words
	;	record small changes to the register values). The cell MODE
	;	is set equal to the current access mode for use in probing
	;	memory references. The alignment bits in the call frame and 
	;	the call parameter count are also saved so there is a safe
	;	copies to use when processing unwinds.
	;
	;	    The instruction PC is then loaded into R11 and
	;	the opcode saved.  If the trace enable bit is set
	;	in the PSL then the trace pending bit is set.   Next,
	;	each operand of the instruction is located.  For each
	;	operand, its type and location is stored in an array
	;	to be passed later to the user action routine.  However,
	;	if the FPD bit is set in the PSL, no operands are fetched.
	;	If this is the case, the number of operands passed to
	;	the user-action routine is zero.  However, the contents
	;	of register PC in the register array will point to the
	;	next instruction.  It is assumed that if FPD is set that
	;	the registers and/or stack contain preprocessed operands.
	;
	;	Notes:	1. From the description of the way the simulated
	;		   register area is constructed, it is clear that
	;		   the length longword of the parameter list is
	;		   overwritten. All of the methods of leaving
	;		   put this longword back together. The
	;		   internal condition handler does this if it 
	;		   detects an unwind.
	;
	;		2. The register change words track modifications
	;		   made to the registers because of autoincrements
	;		   and autodecrements.  This allows recovery of
	;		   the original register contents in the case of
	;		   a generated fault.
	;
	;		3. The location of the instruction being processed is
	;		   stored in the return PC for our frame
	;		   so it may be easily located from the traceback
	;		   report if we blow up.
	;
DECODE_FAULT:				; entrance
	.WORD	^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; entry mask
	MOVAB	LOCAL_START(FP),SP	; allocate the local storage
	EXTZV	#MASK_ALIGN,#2,SAVE_MASK(FP),R0 ; R0 = alignment bits
	MOVB	R0,SAVE_ALIGN(FP)	; save them
	MOVB	#CALL_ARGS,SAVE_PARCNT(FP) ; save the parameter count
	CLRB	FLAGS(FP)		; clear the flag bits
	MOVAB	W^COND_HANDLER,HANDLER(FP) ; set up the condition handler
	CLRQ	REGMOD_R0(FP)		; clear register modification words
	CLRQ	REGMOD_R4(FP)		; clear register modification words
	CLRQ	REGMOD_R8(FP)		; clear register modification words
	CLRQ	REGMOD_AP(FP)		; clear register modification words
	MOVQ	SAVE_AP(FP),REG_AP(FP)	; move user's AP and FP into place
	MOVAB	4*<CALL_ARGS+1>(AP),REG_SP(FP) ; move user's SP into place
	MOVL	4*<CALL_ARGS-1>(AP),REG_PC(FP) ; move PC into place
	MOVL	4*<CALL_ARGS>(AP),R0	; Get value of "Pointer A"
	MOVL	(R0)+,PSL(FP)		; Store user's PSL
	MOVL	(R0)+,SAVE_DEPTH(FP)	; Save handler depth
	MOVQ	(R0)+,USER_ACT_ADR(FP)	; Save user action routine address and
					; environment
	MOVL	(R0)+,USER_ACT_ARG(FP)	; Save user action argument
	MOVL	(R0)+,R4		; Get instruction pattern address
	MOVL	(R0)+,INSTR_OPCODE(FP)	; Get opcode
	MNEGL	(R0),R1			; Get minus signal arg count
	MOVAL	-4(SP)[R1],SP		; Allocate space for signal arguments
;+
; Copy signal arguments to safe place on stack.
;-
	MOVL	SP,R2			; R2 will step through the list
	MNEGL	R1,R1			; Get positive signal arg count
1$:	MOVL	(R0)+,(R2)+		; Move a longword of the sigargs
	SOBGTR	R1,1$			; Loop until done
	MOVL	PSL(FP),(R2)		; Store PSL in list
	MOVL	SP,SAVE_SIGARGS(FP)	; Save address of signal arguments
	MOVL	4(SP),COND_NAME(FP)	; Save condition name

	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,PSL(FP),R0 ; Get current access mode
	MOVB	R0,MODE(FP)		; save it for probes
	MOVL	REG_PC(FP),R11		; R11 = location of instruction
	MOVL	R11,SAVE_PC(FP)		; save it in the return PC
	CMPB	#^XFD,INSTR_OPCODE(FP)	; Is it a 2-byte opcode?
	BGTRU	4$			; no - bypass
	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the incrementation
	INCL	R11			; R11 = location of next byte
4$:	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the incrementation


;+
; R4 now contains the address of the operand pattern for this instruction.
; Set the TP bit in the PSL if T is on.  Then for each operand definition,
; read the instruction stream to evaluate the operand.
;-

	BBC	#PSL$V_TBIT,PSL(FP),5$	; the trace enable bit is clear - skip
	BBSS	#PSL$V_TP,PSL(FP),5$	; set the trace enable bit
5$:	CLRL	R5			; R5 keeps track of number of operands

OPERAND_LOOP:
	MOVZBL	(R4)+,R6		; R6 = operand definition byte
	BEQL	LAST_OPERAND		; If so, we're done here
	EXTZV	#LIB$V_DCFACC,#LIB$S_DCFACC,R6,R8 ; Access type into R8
	BEQL	INVALID_TYPE		; Check for invalid type
	CMPL	R8,#LIB$K_DCFACC_B	; Too large?
	BGTRU	INVALID_TYPE		; If so, error
	EXTZV	#LIB$V_DCFTYP,#LIB$S_DCFTYP,R6,R9 ; Data type into R9
	BEQL	INVALID_TYPE		; Check for invalid type
	CMPL	R9,#LIB$K_DCFTYP_H	; Too large?
	BGTRU	INVALID_TYPE		; If so, error
	MOVZBL	R6,OPERAND_TYPES(FP)[R5]; Store operand type code
	BSBW	GET_SPECIFIER		; Get the specifier
	AOBLEQ	#16,R5,OPERAND_LOOP	; Increment count of operands and loop
;	BRB	INVALID_TYPE		; Too many operand types

;+
; Come here if an access or data type code is invalid, or if there
; are too many operands.
;-

INVALID_TYPE:
	PUSHL	#LIB$_INVARG		; Signal LIB$_INVARG
	CALLS	#1,G^LIB$STOP

;+
; We now have all of the instruction operands found and their addresses and
; types stored.  Move the count of operands to N_OF_OPERANDS and call the
; user action routine.
;-

LAST_OPERAND:
	BBC	#PSL$V_FPD,PSL(FP),1$	; Skip if not FPD
	CLRL	R5			; No operands if FPD
1$:	MOVL	R5,N_OF_OPERANDS(FP)
	PUSHL	USER_ACT_ARG(FP)	; User action argument
	PUSHL	FP			; "context" for signal routine
	PUSHAB	USER_SIGNAL		; Address of signal routine
	PUSHL	SAVE_SIGARGS(FP)	; Address of signal arguments list
	PUSHAB	WRITE_ADDRS(FP)		; Address of writeable operands
	PUSHAB	READ_ADDRS(FP)		; Address of readable operands
	PUSHAB	OPERAND_TYPES(FP)	; Address of operand types
	PUSHAB	N_OF_OPERANDS(FP)	; Address of number of operands
	PUSHAB	REG_R0(FP)		; Address of registers
	PUSHAB	PSL(FP)			; Address of PSL
	PUSHAB	SAVE_PC(FP)		; Address of original PC
	PUSHAB	INSTR_OPCODE(FP)	; Address of opcode
	MOVQ	USER_ACT_ADR(FP),R0	; Get address/environment of routine
	CALLS	#12,(R0)		; Call user's action routine
	BLBS	R0,NORMAL_EXIT		; Resume execution if success
	BRW	RESIGNAL		; Resignal if failure
	;

	;
	;	NORMAL_EXIT - Normal End of Instruction Emulation
	;
	;		entered by branching
	;
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine restores control to the user program whenever
	;	the processing ends without causing an exception.
	;	When we return, all of the registers, PC, and the PSL are
	;	set to the emulated values.
	;
	;	    The method of leaving consists of pushing the
	;	user's PC and PSL onto the user's stack putting the saved AP
	;	and FP back in their proper places in the frame and performing
	;	the indicated adjustment so that when a RET instruction is
	;	executed all of the registers up to FP will be restored and
	;	the stack pointer will be positioned to the PC, PSL pair.
	;
	;
NORMAL_EXIT:				; entrance
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVL	#8,R0			; R0 = size of PC, PSL pair
	BSBB	TEST_FRAME		; make sure we have room to push it
	SUBL2	#8,REG_SP(FP)		; allocate room on the user's stack
	MOVQ	REG_PC(FP),@REG_SP(FP)	; push the PC, PSL pair
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put the user's PC, PSL pair back
	MOVAB	B^1$,SAVE_PC(FP)	; store our return point
	MOVAB	FRAME_END+4(FP),R0	; R0 = location of end of frame
	SUBL3	R0,REG_SP(FP),R1	; R1 = distance of user SP from it
	EXTZV	#0,#2,R1,R2		; R2 = stack alignment
	INSV	R2,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store it into the frame
	ADDL2	R2,R0			; compute the parameter area location
	ASHL	#-2,R1,-4(R0)		; store the parameter count
	RET				; return (to next instruction)
1$:	REI				; Return to the next user instruction
	;

	;
	;	TEST_FRAME - Test Frame Location and Move If Necessary
	;
	;		entered by subroutine branching
	;
	;		parameter:	R0 = Size of Information to be Pushed
	;
	;		returns with	R0 = Distance Frame was Moved
	;
	;	Discussion
	;
	;	    This routine determines whether or not the address given
	;	by subtracting R0 from the user's stack pointer can be made
	;	the location following a parameter list without the location
	;	being within the local storage. If this cannot be done then
	;	the entire procedure frame is moved so the condition can be
	;	satisfied. The distance that the procedure frame was moved
	;	is returned in R0. The value is zero if the frame is not 
	;	moved.
	;
	;	Note:	1. The switch from one frame location to another is
	;		   performed by a single indivisible POPR instruction
	;		   so we are never in an anomalous state.
	;
	;		2. If the frame is moved to a higher address, then
	;		   the saved AP and FP are changed to the values of
	;		   the emulated registers. The reason for this is
	;		   that the move may overlay a valid frame so it is
	;		   assumed that the user's AP and FP have been changed
	;		   by the instruction to information about a new valid
	;		   frame.
	;

TEST_FRAME:				; entrance
	PUSHL	#0			; push a zero
	SUBL3	R0,REG_SP(FP),R0	; compute pushed information address
	BICL2	#3,R0			; align the value
	MOVAB	LOCAL_END(FP),R1	; R1 = end of local storage
	CMPL	R0,R1			; does push extend below the frame ?
	BGEQU	2$			; no - bypass
	BICL3	#3,SP,R3		; R3 = aligned stack pointer
	SUBL2	#24,R3			; adjust for additional pushes
	MOVL	R0,R2			; R2 = address following moved frame
	CMPL	R2,R3			; does it extend into the frame ?
	BLEQU	3$			; no - bypass
	MOVL	R3,R2			; yes - use address below the frame
	BRB	3$			; bypass
2$:	MOVAB	FRAME_END+1027(FP),R2	; R2 = last possible parameter end
	CMPL	R0,R2			; does the push end above it ?
	BLEQU	5$			; no - bypass
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; change the saved AP and FP
	BICL3	#3,R0,R2		; R2 = aligned user stack pointer
3$:	SUBL2	R1,R2			; R2 = distance of the move
	PUSHL	R2			; push the quantity
	PUSHAB	(SP)[R2]		; push the modified SP
	PUSHAB	(FP)[R2]		; push the modified FP
	PUSHAB	(AP)[R2]		; push the modified AP
	PUSHAB	SAVE_ALIGN(FP)[R2]	; push the new alignment bits location
	PUSHAB	SAVE_PARCNT(FP)[R2]	; push the new parameter count address
	MOVAB	FRAME_END+4(FP)[R2],R3	; R3 = new frame end + 4 location
	SUBL3	R3,R0,R3		; R3 = distance to user's SP
	ASHL	#-2,R3,-(SP)		; push the new parameter count
	SUBL3	SP,R1,R0		; R0 = number of bytes to move
	MOVL	SP,R1			; R1 = location of bytes to move
	TSTL	R2			; will we extend the stack ?
	BGEQ	4$			; no - skip
	ADDL2	R2,SP			; yes - extend the stack pointer
4$:	MOVC3	R0,(R1),(R1)[R2]	; move the frame
	CVTLB	(SP)+,@(SP)+		; store the new parameter count
	CLRB	@(SP)+			; clear the new alignment bits
	POPR	#^M<AP,FP,SP>		; switch to the new frame
5$:	POPR	#^M<R0>			; R0 = distance frame was moved
	RSB				; return
	;

	;
	;	COND_HANDLER - Internal Condition Handler
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with	R0 = Condition Response
	;
	;	Discussion
	;	
	;	    This routine is the internal condition handler for
	;	LIB$DECODE_FAULT.  Since we don't make constructive use
	;	of exceptions in its main procedure, this routine requests 
	;	resignaling of all conditions it intercepts.
	;
	;	    If the condition is SS$_UNWIND which indicates that an
	;	unwind is about to take place, then it restores the argument
	;	count longword in the parameter list for the procedure so the
	;	unwind will work properly.
	;
COND_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0,R1 = condition array locations
	CMPCOND	SS$_UNWIND,4(R0)	; is this an unwind ?
	BNEQ	1$			; no - bypass
	MOVL	4(R1),R0		; R0 = frame location
	MOVB	SAVE_ALIGN(R0),R1	; R1 = safe copy of alignment bits
	MOVZBL	SAVE_PARCNT(FP),-(SP)	; push the argument count
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(R0) ; store align bits in frame
	ADDL2	R1,R0			; add to the frame location
	MOVL	(SP)+,FRAME_END(R0)	; store the argument count
1$:	MOVZWL	#SS$_RESIGNAL,R0	; resignal the condition
	RET				; return
	;

;+
; Instruction operand pattern tables.  There are two tables, one for
; 1-byte opcodes and the other for 2-byte opcodes.  Each entry has the
; offset from the beginning of the table to the pattern which describes
; that instruction.  If the offset is zero, no such instruction exists.
;-

TAB_1BYTE:
	.WORD	PATRN_HALT-TAB_1BYTE	; 00	HALT
	.WORD	PATRN_NOP-TAB_1BYTE	; 01	NOP
	.WORD	PATRN_REI-TAB_1BYTE	; 02	REI
	.WORD	PATRN_BPT-TAB_1BYTE	; 03	BPT
	.WORD	PATRN_RET-TAB_1BYTE	; 04	RET
	.WORD	PATRN_RSB-TAB_1BYTE	; 05	RSB
	.WORD	PATRN_LDPCTX-TAB_1BYTE	; 06	LDPCTX
	.WORD	PATRN_SVPCTX-TAB_1BYTE	; 07	SVPCTX
	.WORD	PATRN_CVTPS-TAB_1BYTE	; 08	CVTPS
	.WORD	PATRN_CVTSP-TAB_1BYTE	; 09	CVTSP
	.WORD	PATRN_INDEX-TAB_1BYTE	; 0A	INDEX
	.WORD	PATRN_CRC-TAB_1BYTE	; 0B	CRC
	.WORD	PATRN_PROBER-TAB_1BYTE	; 0C	PROBER
	.WORD	PATRN_PROBEW-TAB_1BYTE	; 0D	PROBEW
	.WORD	PATRN_INSQUE-TAB_1BYTE	; 0E	INSQUE
	.WORD	PATRN_REMQUE-TAB_1BYTE	; 0F	REMQUE
	.WORD	PATRN_BSBB-TAB_1BYTE	; 10	BSBB
	.WORD	PATRN_BRB-TAB_1BYTE	; 11	BRB
	.WORD	PATRN_BNEQ-TAB_1BYTE	; 12	BNEQ,BNEQU
	.WORD	PATRN_BEQL-TAB_1BYTE	; 13	BEQL,BEQLU
	.WORD	PATRN_BGTR-TAB_1BYTE	; 14	BGTR
	.WORD	PATRN_BLEQ-TAB_1BYTE	; 15	BLEQ
	.WORD	PATRN_JSB-TAB_1BYTE	; 16	JSB
	.WORD	PATRN_JMP-TAB_1BYTE	; 17	JMP
	.WORD	PATRN_BGEQ-TAB_1BYTE	; 18	BGEQ
	.WORD	PATRN_BLSS-TAB_1BYTE	; 19	BLSS
	.WORD	PATRN_BGTRU-TAB_1BYTE	; 1A	BGTRU
	.WORD	PATRN_BLEQU-TAB_1BYTE	; 1B	BLEQU
	.WORD	PATRN_BVC-TAB_1BYTE	; 1C	BVC
	.WORD	PATRN_BVS-TAB_1BYTE	; 1D	BVS
	.WORD	PATRN_BGEQU-TAB_1BYTE	; 1E	BGEQU,BCC
	.WORD	PATRN_BLSSU-TAB_1BYTE	; 1F	BLSSU,BCS
	.WORD	PATRN_ADDP4-TAB_1BYTE	; 20	ADDP4
	.WORD	PATRN_ADDP6-TAB_1BYTE	; 21	ADDP6
	.WORD	PATRN_SUBP4-TAB_1BYTE	; 22	SUBP4
	.WORD	PATRN_SUBP6-TAB_1BYTE	; 23	SUBP6
	.WORD	PATRN_CVTPT-TAB_1BYTE	; 24	CVTPT
	.WORD	PATRN_MULP-TAB_1BYTE	; 25	MULP
	.WORD	PATRN_CVTTP-TAB_1BYTE	; 26	CVTTP
	.WORD	PATRN_DIVP-TAB_1BYTE	; 27	DIVP
	.WORD	PATRN_MOVC3-TAB_1BYTE	; 28	MOVC3
	.WORD	PATRN_CMPC3-TAB_1BYTE	; 29	CMPC3
	.WORD	PATRN_SCANC-TAB_1BYTE	; 2A	SCANC
	.WORD	PATRN_SPANC-TAB_1BYTE	; 2B	SPANC
	.WORD	PATRN_MOVC5-TAB_1BYTE	; 2C	MOVC5
	.WORD	PATRN_CMPC5-TAB_1BYTE	; 2D	CMPC5
	.WORD	PATRN_MOVTC-TAB_1BYTE	; 2E	MOVTC
	.WORD	PATRN_MOVTUC-TAB_1BYTE	; 2F	MOVTUC
	.WORD	PATRN_BSBW-TAB_1BYTE	; 30	BSBW
	.WORD	PATRN_BRW-TAB_1BYTE	; 31	BRW
	.WORD	PATRN_CVTWL-TAB_1BYTE	; 32	CVTWL
	.WORD	PATRN_CVTWB-TAB_1BYTE	; 33	CVTWB
	.WORD	PATRN_MOVP-TAB_1BYTE	; 34	MOVP
	.WORD	PATRN_CMPP3-TAB_1BYTE	; 35	CMPP3
	.WORD	PATRN_CVTPL-TAB_1BYTE	; 36	CVTPL
	.WORD	PATRN_CMPP4-TAB_1BYTE	; 37	CMPP4
	.WORD	PATRN_EDITPC-TAB_1BYTE	; 38	EDITPC
	.WORD	PATRN_MATCHC-TAB_1BYTE	; 39	MATCHC
	.WORD	PATRN_LOCC-TAB_1BYTE	; 3A	LOCC
	.WORD	PATRN_SKPC-TAB_1BYTE	; 3B	SKPC
	.WORD	PATRN_MOVZWL-TAB_1BYTE	; 3C	MOVZWL
	.WORD	PATRN_ACBW-TAB_1BYTE	; 3D	ACBW
	.WORD	PATRN_MOVAW-TAB_1BYTE	; 3E	MOVAW
	.WORD	PATRN_PUSHAW-TAB_1BYTE	; 3F	PUSHAW
	.WORD	PATRN_ADDF2-TAB_1BYTE	; 40	ADDF2
	.WORD	PATRN_ADDF3-TAB_1BYTE	; 41	ADDF3
	.WORD	PATRN_SUBF2-TAB_1BYTE	; 42	SUBF2
	.WORD	PATRN_SUBF3-TAB_1BYTE	; 43	SUBF3
	.WORD	PATRN_MULF2-TAB_1BYTE	; 44	MULF2
	.WORD	PATRN_MULF3-TAB_1BYTE	; 45	MULF3
	.WORD	PATRN_DIVF2-TAB_1BYTE	; 46	DIVF2
	.WORD	PATRN_DIVF3-TAB_1BYTE	; 47	DIVF3
	.WORD	PATRN_CVTFB-TAB_1BYTE	; 48	CVTFB
	.WORD	PATRN_CVTFW-TAB_1BYTE	; 49	CVTFW
	.WORD	PATRN_CVTFL-TAB_1BYTE	; 4A	CVTFL
	.WORD	PATRN_CVTRFL-TAB_1BYTE	; 4B	CVTRFL
	.WORD	PATRN_CVTBF-TAB_1BYTE	; 4C	CVTBF
	.WORD	PATRN_CVTWF-TAB_1BYTE	; 4D	CVTWF
	.WORD	PATRN_CVTLF-TAB_1BYTE	; 4E	CVTLF
	.WORD	PATRN_ACBF-TAB_1BYTE	; 4F	ACBF
	.WORD	PATRN_MOVF-TAB_1BYTE	; 50	MOVF
	.WORD	PATRN_CMPF-TAB_1BYTE	; 51	CMPF
	.WORD	PATRN_MNEGF-TAB_1BYTE	; 52	MNEGF
	.WORD	PATRN_TSTF-TAB_1BYTE	; 53	TSTF
	.WORD	PATRN_EMODF-TAB_1BYTE	; 54	EMODF
	.WORD	PATRN_POLYF-TAB_1BYTE	; 55	POLYF
	.WORD	PATRN_CVTFD-TAB_1BYTE	; 56	CVTFD
	.WORD	0			; 57
	.WORD	PATRN_ADAWI-TAB_1BYTE	; 58	ADAWI
	.WORD	0			; 59
	.WORD	0			; 5A
	.WORD	0			; 5B
	.WORD	PATRN_INSQHI-TAB_1BYTE	; 5C	INSQHI
	.WORD	PATRN_INSQTI-TAB_1BYTE	; 5D	INSQTI
	.WORD	PATRN_REMQHI-TAB_1BYTE	; 5E	REMQHI
	.WORD	PATRN_REMQTI-TAB_1BYTE	; 5F	REMQTI
	.WORD	PATRN_ADDD2-TAB_1BYTE	; 60	ADDD2
	.WORD	PATRN_ADDD3-TAB_1BYTE	; 61	ADDD3
	.WORD	PATRN_SUBD2-TAB_1BYTE	; 62	SUBD2
	.WORD	PATRN_SUBD3-TAB_1BYTE	; 63	SUBD3
	.WORD	PATRN_MULD2-TAB_1BYTE	; 64	MULD2
	.WORD	PATRN_MULD3-TAB_1BYTE	; 65	MULD3
	.WORD	PATRN_DIVD2-TAB_1BYTE	; 66	DIVD2
	.WORD	PATRN_DIVD3-TAB_1BYTE	; 67	DIVD3
	.WORD	PATRN_CVTDB-TAB_1BYTE	; 68	CVTDB
	.WORD	PATRN_CVTDW-TAB_1BYTE	; 69	CVTDW
	.WORD	PATRN_CVTDL-TAB_1BYTE	; 6A	CVTDL
	.WORD	PATRN_CVTRDL-TAB_1BYTE	; 6B	CVTRDL
	.WORD	PATRN_CVTBD-TAB_1BYTE	; 6C	CVTBD
	.WORD	PATRN_CVTWD-TAB_1BYTE	; 6D	CVTWD
	.WORD	PATRN_CVTLD-TAB_1BYTE	; 6E	CVTLD
	.WORD	PATRN_ACBD-TAB_1BYTE	; 6F	ACBD
	.WORD	PATRN_MOVD-TAB_1BYTE	; 70	MOVD
	.WORD	PATRN_CMPD-TAB_1BYTE	; 71	CMPD
	.WORD	PATRN_MNEGD-TAB_1BYTE	; 72	MNEGD
	.WORD	PATRN_TSTD-TAB_1BYTE	; 73	TSTD
	.WORD	PATRN_EMODD-TAB_1BYTE	; 74	EMODD
	.WORD	PATRN_POLYD-TAB_1BYTE	; 75	POLYD
	.WORD	PATRN_CVTDF-TAB_1BYTE	; 76	CVTDF
	.WORD	0			; 77
	.WORD	PATRN_ASHL-TAB_1BYTE	; 78	ASHL
	.WORD	PATRN_ASHQ-TAB_1BYTE	; 79	ASHQ
	.WORD	PATRN_EMUL-TAB_1BYTE	; 7A	EMUL
	.WORD	PATRN_EDIV-TAB_1BYTE	; 7B	EDIV
	.WORD	PATRN_CLRQ-TAB_1BYTE	; 7C	CLRQ,CLRD,CLRG
	.WORD	PATRN_MOVQ-TAB_1BYTE	; 7D	MOVQ
	.WORD	PATRN_MOVAQ-TAB_1BYTE	; 7E	MOVAQ,MOVAD,MOVAG
	.WORD	PATRN_PUSHAQ-TAB_1BYTE	; 7F	PUSHAQ,PUSHAD,PUSHAG
	.WORD	PATRN_ADDB2-TAB_1BYTE	; 80	ADDB2
	.WORD	PATRN_ADDB3-TAB_1BYTE	; 81	ADDB3
	.WORD	PATRN_SUBB2-TAB_1BYTE	; 82	SUBB2
	.WORD	PATRN_SUBB3-TAB_1BYTE	; 83	SUBB3
	.WORD	PATRN_MULB2-TAB_1BYTE	; 84	MULB2
	.WORD	PATRN_MULB3-TAB_1BYTE	; 85	MULB3
	.WORD	PATRN_DIVB2-TAB_1BYTE	; 86	DIVB2
	.WORD	PATRN_DIVB3-TAB_1BYTE	; 87	DIVB3
	.WORD	PATRN_BISB2-TAB_1BYTE	; 88	BISB2
	.WORD	PATRN_BISB3-TAB_1BYTE	; 89	BISB3
	.WORD	PATRN_BICB2-TAB_1BYTE	; 8A	BICB2
	.WORD	PATRN_BICB3-TAB_1BYTE	; 8B	BICB3
	.WORD	PATRN_XORB2-TAB_1BYTE	; 8C	XORB2
	.WORD	PATRN_XORB3-TAB_1BYTE	; 8D	XORB3
	.WORD	PATRN_MNEGB-TAB_1BYTE	; 8E	MNEGB
	.WORD	PATRN_CASEB-TAB_1BYTE	; 8F	CASEB
	.WORD	PATRN_MOVB-TAB_1BYTE	; 90	MOVB
	.WORD	PATRN_CMPB-TAB_1BYTE	; 91	CMPB
	.WORD	PATRN_MCOMB-TAB_1BYTE	; 92	MCOMB
	.WORD	PATRN_BITB-TAB_1BYTE	; 93	BITB
	.WORD	PATRN_CLRB-TAB_1BYTE	; 94	CLRB
	.WORD	PATRN_TSTB-TAB_1BYTE	; 95	TSTB
	.WORD	PATRN_INCB-TAB_1BYTE	; 96	INCB
	.WORD	PATRN_DECB-TAB_1BYTE	; 97	DECB
	.WORD	PATRN_CVTBL-TAB_1BYTE	; 98	CVTBL
	.WORD	PATRN_CVTBW-TAB_1BYTE	; 99	CVTBW
	.WORD	PATRN_MOVZBL-TAB_1BYTE	; 9A	MOVZBL
	.WORD	PATRN_MOVZBW-TAB_1BYTE	; 9B	MOVZBW
	.WORD	PATRN_ROTL-TAB_1BYTE	; 9C	ROTL
	.WORD	PATRN_ACBB-TAB_1BYTE	; 9D	ACBB
	.WORD	PATRN_MOVAB-TAB_1BYTE	; 9E	MOVAB
	.WORD	PATRN_PUSHAB-TAB_1BYTE	; 9F	PUSHAB
	.WORD	PATRN_ADDW2-TAB_1BYTE	; A0	ADDW2
	.WORD	PATRN_ADDW3-TAB_1BYTE	; A1	ADDW3
	.WORD	PATRN_SUBW2-TAB_1BYTE	; A2	SUBW2
	.WORD	PATRN_SUBW3-TAB_1BYTE	; A3	SUBW3
	.WORD	PATRN_MULW2-TAB_1BYTE	; A4	MULW2
	.WORD	PATRN_MULW3-TAB_1BYTE	; A5	MULW3
	.WORD	PATRN_DIVW2-TAB_1BYTE	; A6	DIVW2
	.WORD	PATRN_DIVW3-TAB_1BYTE	; A7	DIVW3
	.WORD	PATRN_BISW2-TAB_1BYTE	; A8	BISW2
	.WORD	PATRN_BISW3-TAB_1BYTE	; A9	BISW3
	.WORD	PATRN_BICW2-TAB_1BYTE	; AA	BICW2
	.WORD	PATRN_BICW3-TAB_1BYTE	; AB	BICW3
	.WORD	PATRN_XORW2-TAB_1BYTE	; AC	XORW2
	.WORD	PATRN_XORW3-TAB_1BYTE	; AD	XORW3
	.WORD	PATRN_MNEGW-TAB_1BYTE	; AE	MNEGW
	.WORD	PATRN_CASEW-TAB_1BYTE	; AF	CASEW
	.WORD	PATRN_MOVW-TAB_1BYTE	; B0	MOVW
	.WORD	PATRN_CMPW-TAB_1BYTE	; B1	CMPW
	.WORD	PATRN_MCOMW-TAB_1BYTE	; B2	MCOMW
	.WORD	PATRN_BITW-TAB_1BYTE	; B3	BITW
	.WORD	PATRN_CLRW-TAB_1BYTE	; B4	CLRW
	.WORD	PATRN_TSTW-TAB_1BYTE	; B5	TSTW
	.WORD	PATRN_INCW-TAB_1BYTE	; B6	INCW
	.WORD	PATRN_DECW-TAB_1BYTE	; B7	DECW
	.WORD	PATRN_BISPSW-TAB_1BYTE	; B8	BISPSW
	.WORD	PATRN_BICPSW-TAB_1BYTE	; B9	BICPSW
	.WORD	PATRN_POPR-TAB_1BYTE	; BA	POPR
	.WORD	PATRN_PUSHR-TAB_1BYTE	; BB	PUSHR
	.WORD	PATRN_CHMK-TAB_1BYTE	; BC	CHMK
	.WORD	PATRN_CHME-TAB_1BYTE	; BD	CHME
	.WORD	PATRN_CHMS-TAB_1BYTE	; BE	CHMS
	.WORD	PATRN_CHMU-TAB_1BYTE	; BF	CHMU
	.WORD	PATRN_ADDL2-TAB_1BYTE	; C0	ADDL2
	.WORD	PATRN_ADDL3-TAB_1BYTE	; C1	ADDL3
	.WORD	PATRN_SUBL2-TAB_1BYTE	; C2	SUBL2
	.WORD	PATRN_SUBL3-TAB_1BYTE	; C3	SUBL3
	.WORD	PATRN_MULL2-TAB_1BYTE	; C4	MULL2
	.WORD	PATRN_MULL3-TAB_1BYTE	; C5	MULL3
	.WORD	PATRN_DIVL2-TAB_1BYTE	; C6	DIVL2
	.WORD	PATRN_DIVL3-TAB_1BYTE	; C7	DIVL3
	.WORD	PATRN_BISL2-TAB_1BYTE	; C8	BISL2
	.WORD	PATRN_BISL3-TAB_1BYTE	; C9	BISL3
	.WORD	PATRN_BICL2-TAB_1BYTE	; CA	BICL2
	.WORD	PATRN_BICL3-TAB_1BYTE	; CB	BICL3
	.WORD	PATRN_XORL2-TAB_1BYTE	; CC	XORL2
	.WORD	PATRN_XORL3-TAB_1BYTE	; CD	XORL3
	.WORD	PATRN_MNEGL-TAB_1BYTE	; CE	MNEGL
	.WORD	PATRN_CASEL-TAB_1BYTE	; CF	CASEL
	.WORD	PATRN_MOVL-TAB_1BYTE	; D0	MOVL
	.WORD	PATRN_CMPL-TAB_1BYTE	; D1	CMPL
	.WORD	PATRN_MCOML-TAB_1BYTE	; D2	MCOML
	.WORD	PATRN_BITL-TAB_1BYTE	; D3	BITL
	.WORD	PATRN_CLRL-TAB_1BYTE	; D4	CLRL,CLRF
	.WORD	PATRN_TSTL-TAB_1BYTE	; D5	TSTL
	.WORD	PATRN_INCL-TAB_1BYTE	; D6	INCL
	.WORD	PATRN_DECL-TAB_1BYTE	; D7	DECL
	.WORD	PATRN_ADWC-TAB_1BYTE	; D8	ADWC
	.WORD	PATRN_SBWC-TAB_1BYTE	; D9	SBWC
	.WORD	PATRN_MTPR-TAB_1BYTE	; DA	MTPR
	.WORD	PATRN_MFPR-TAB_1BYTE	; DB	MFPR
	.WORD	PATRN_MOVPSL-TAB_1BYTE	; DC	MOVPSL
	.WORD	PATRN_PUSHL-TAB_1BYTE	; DD	PUSHL
	.WORD	PATRN_MOVAL-TAB_1BYTE	; DE	MOVAL,MOVAF
	.WORD	PATRN_PUSHAL-TAB_1BYTE	; DF	PUSHAL,PUSHAF
	.WORD	PATRN_BBS-TAB_1BYTE	; E0	BBS
	.WORD	PATRN_BBC-TAB_1BYTE	; E1	BBC
	.WORD	PATRN_BBSS-TAB_1BYTE	; E2	BBSS
	.WORD	PATRN_BBCS-TAB_1BYTE	; E3	BBCS
	.WORD	PATRN_BBSC-TAB_1BYTE	; E4	BBSC
	.WORD	PATRN_BBCC-TAB_1BYTE	; E5	BBCC
	.WORD	PATRN_BBSSI-TAB_1BYTE	; E6	BBSSI
	.WORD	PATRN_BBCCI-TAB_1BYTE	; E7	BBCCI
	.WORD	PATRN_BLBS-TAB_1BYTE	; E8	BLBS
	.WORD	PATRN_BLBC-TAB_1BYTE	; E9	BLBC
	.WORD	PATRN_FFS-TAB_1BYTE	; EA	FFS
	.WORD	PATRN_FFC-TAB_1BYTE	; EB	FFC
	.WORD	PATRN_CMPV-TAB_1BYTE	; EC	CMPV
	.WORD	PATRN_CMPZV-TAB_1BYTE	; ED	CMPZV
	.WORD	PATRN_EXTV-TAB_1BYTE	; EE	EXTV
	.WORD	PATRN_EXTZV-TAB_1BYTE	; EF	EXTZV
	.WORD	PATRN_INSV-TAB_1BYTE	; F0	INSV
	.WORD	PATRN_ACBL-TAB_1BYTE	; F1	ACBL
	.WORD	PATRN_AOBLSS-TAB_1BYTE	; F2	AOBLSS
	.WORD	PATRN_AOBLEQ-TAB_1BYTE	; F3	AOBLEQ
	.WORD	PATRN_SOBGEQ-TAB_1BYTE	; F4	SOBGEQ
	.WORD	PATRN_SOBGTR-TAB_1BYTE	; F5	SOBGTR
	.WORD	PATRN_CVTLB-TAB_1BYTE	; F6	CVTLB
	.WORD	PATRN_CVTLW-TAB_1BYTE	; F7	CVTLW
	.WORD	PATRN_ASHP-TAB_1BYTE	; F8	ASHP
	.WORD	PATRN_CVTLP-TAB_1BYTE	; F9	CVTLP
	.WORD	PATRN_CALLG-TAB_1BYTE	; FA	CALLG
	.WORD	PATRN_CALLS-TAB_1BYTE	; FB	CALLS
	.WORD	PATRN_XFC-TAB_1BYTE	; FC	XFC
	.WORD	0			; FD	(2-byte opcode)
	.WORD	0			; FE	(2-byte opcode)
	.WORD	0			; FF	(2-byte opcode)

TAB_2BYTE:
	.WORD	0			; 00FD
	.WORD	0			; 01FD
	.WORD	0			; 02FD
	.WORD	0			; 03FD
	.WORD	0			; 04FD
	.WORD	0			; 05FD
	.WORD	0			; 06FD
	.WORD	0			; 07FD
	.WORD	0			; 08FD
	.WORD	0			; 09FD
	.WORD	0			; 0AFD
	.WORD	0			; 0BFD
	.WORD	0			; 0CFD
	.WORD	0			; 0DFD
	.WORD	0			; 0EFD
	.WORD	0			; 0FFD
	.WORD	0			; 10FD
	.WORD	0			; 11FD
	.WORD	0			; 12FD
	.WORD	0			; 13FD
	.WORD	0			; 14FD
	.WORD	0			; 15FD
	.WORD	0			; 16FD
	.WORD	0			; 17FD
	.WORD	0			; 18FD
	.WORD	0			; 19FD
	.WORD	0			; 1AFD
	.WORD	0			; 1BFD
	.WORD	0			; 1CFD
	.WORD	0			; 1DFD
	.WORD	0			; 1EFD
	.WORD	0			; 1FFD
	.WORD	0			; 20FD
	.WORD	0			; 21FD
	.WORD	0			; 22FD
	.WORD	0			; 23FD
	.WORD	0			; 24FD
	.WORD	0			; 25FD
	.WORD	0			; 26FD
	.WORD	0			; 27FD
	.WORD	0			; 28FD
	.WORD	0			; 29FD
	.WORD	0			; 2AFD
	.WORD	0			; 2BFD
	.WORD	0			; 2CFD
	.WORD	0			; 2DFD
	.WORD	0			; 2EFD
	.WORD	0			; 2FFD
	.WORD	0			; 30FD
	.WORD	0			; 31FD
	.WORD	PATRN_CVTDH-TAB_2BYTE	; 32FD	CVTDH
	.WORD	PATRN_CVTGF-TAB_2BYTE	; 33FD	CVTGF
	.WORD	0			; 34FD
	.WORD	0			; 35FD
	.WORD	0			; 36FD
	.WORD	0			; 37FD
	.WORD	0			; 38FD
	.WORD	0			; 39FD
	.WORD	0			; 3AFD
	.WORD	0			; 3BFD
	.WORD	0			; 3CFD
	.WORD	0			; 3DFD
	.WORD	0			; 3EFD
	.WORD	0			; 3FFD
	.WORD	PATRN_ADDG2-TAB_2BYTE	; 40FD	ADDG2
	.WORD	PATRN_ADDG3-TAB_2BYTE	; 41FD	ADDG3
	.WORD	PATRN_SUBG2-TAB_2BYTE	; 42FD	SUBG2
	.WORD	PATRN_SUBG3-TAB_2BYTE	; 43FD	SUBG3
	.WORD	PATRN_MULG2-TAB_2BYTE	; 44FD	MULG2
	.WORD	PATRN_MULG3-TAB_2BYTE	; 45FD	MULG3
	.WORD	PATRN_DIVG2-TAB_2BYTE	; 46FD	DIVG2
	.WORD	PATRN_DIVG3-TAB_2BYTE	; 47FD	DIVG3
	.WORD	PATRN_CVTGB-TAB_2BYTE	; 48FD	CVTGB
	.WORD	PATRN_CVTGW-TAB_2BYTE	; 49FD	CVTGW
	.WORD	PATRN_CVTGL-TAB_2BYTE	; 4AFD	CVTGL
	.WORD	PATRN_CVTRGL-TAB_2BYTE	; 4BFD	CVTRGL
	.WORD	PATRN_CVTBG-TAB_2BYTE	; 4CFD	CVTBG
	.WORD	PATRN_CVTWG-TAB_2BYTE	; 4DFD	CVTWG
	.WORD	PATRN_CVTLG-TAB_2BYTE	; 4EFD	CVTLG
	.WORD	PATRN_ACBG-TAB_2BYTE	; 4FFD	ACBG
	.WORD	PATRN_MOVG-TAB_2BYTE	; 50FD	MOVG
	.WORD	PATRN_CMPG-TAB_2BYTE	; 51FD	CMPG
	.WORD	PATRN_MNEGG-TAB_2BYTE	; 52FD	MNEGG
	.WORD	PATRN_TSTG-TAB_2BYTE	; 53FD	TSTG
	.WORD	PATRN_EMODG-TAB_2BYTE	; 54FD	EMODG
	.WORD	PATRN_POLYG-TAB_2BYTE	; 55FD	POLYG
	.WORD	PATRN_CVTGH-TAB_2BYTE	; 56FD	CVTGH
	.WORD	0			; 57FD
	.WORD	0			; 58FD
	.WORD	0			; 59FD
	.WORD	0			; 5AFD
	.WORD	0			; 5BFD
	.WORD	0			; 5CFD
	.WORD	0			; 5DFD
	.WORD	0			; 5EFD
	.WORD	0			; 5FFD
	.WORD	PATRN_ADDH2-TAB_2BYTE	; 60FD	ADDH2
	.WORD	PATRN_ADDH3-TAB_2BYTE	; 61FD	ADDH3
	.WORD	PATRN_SUBH2-TAB_2BYTE	; 62FD	SUBH2
	.WORD	PATRN_SUBH3-TAB_2BYTE	; 63FD	SUBH3
	.WORD	PATRN_MULH2-TAB_2BYTE	; 64FD	MULH2
	.WORD	PATRN_MULH3-TAB_2BYTE	; 65FD	MULH3
	.WORD	PATRN_DIVH2-TAB_2BYTE	; 66FD	DIVH2
	.WORD	PATRN_DIVH3-TAB_2BYTE	; 67FD	DIVH3
	.WORD	PATRN_CVTHB-TAB_2BYTE	; 68FD	CVTHB
	.WORD	PATRN_CVTHW-TAB_2BYTE	; 69FD	CVTHW
	.WORD	PATRN_CVTHL-TAB_2BYTE	; 6AFD	CVTHL
	.WORD	PATRN_CVTRHL-TAB_2BYTE	; 6BFD	CVTRHL
	.WORD	PATRN_CVTBH-TAB_2BYTE	; 6CFD	CVTBH
	.WORD	PATRN_CVTWH-TAB_2BYTE	; 6DFD	CVTWH
	.WORD	PATRN_CVTLH-TAB_2BYTE	; 6EFD	CVTLH
	.WORD	PATRN_ACBH-TAB_2BYTE	; 6FFD	ACBH
	.WORD	PATRN_MOVH-TAB_2BYTE	; 70FD	MOVH
	.WORD	PATRN_CMPH-TAB_2BYTE	; 71FD	CMPH
	.WORD	PATRN_MNEGH-TAB_2BYTE	; 72FD	MNEGH
	.WORD	PATRN_TSTH-TAB_2BYTE	; 73FD	TSTH
	.WORD	PATRN_EMODH-TAB_2BYTE	; 74FD	EMODH
	.WORD	PATRN_POLYH-TAB_2BYTE	; 75FD	POLYH
	.WORD	PATRN_CVTHG-TAB_2BYTE	; 76FD	CVTHG
	.WORD	0			; 77FD
	.WORD	0			; 78FD
	.WORD	0			; 79FD
	.WORD	0			; 7AFD
	.WORD	0			; 7BFD
	.WORD	PATRN_CLRO-TAB_2BYTE	; 7CFD	CLRO,CLRH
	.WORD	PATRN_MOVO-TAB_2BYTE	; 7DFD	MOVO
	.WORD	PATRN_MOVAO-TAB_2BYTE	; 7EFD	MOVAO,MOVAH
	.WORD	PATRN_PUSHAO-TAB_2BYTE	; 7FFD	PUSHAO,PUSHAH
	.WORD	0			; 80FD
	.WORD	0			; 81FD
	.WORD	0			; 82FD
	.WORD	0			; 83FD
	.WORD	0			; 84FD
	.WORD	0			; 85FD
	.WORD	0			; 86FD
	.WORD	0			; 87FD
	.WORD	0			; 88FD
	.WORD	0			; 89FD
	.WORD	0			; 8AFD
	.WORD	0			; 8BFD
	.WORD	0			; 8CFD
	.WORD	0			; 8DFD
	.WORD	0			; 8EFD
	.WORD	0			; 8FFD
	.WORD	0			; 90FD
	.WORD	0			; 91FD
	.WORD	0			; 92FD
	.WORD	0			; 93FD
	.WORD	0			; 94FD
	.WORD	0			; 95FD
	.WORD	0			; 96FD
	.WORD	0			; 97FD
	.WORD	PATRN_CVTFH-TAB_2BYTE	; 98FD	CVTFH
	.WORD	PATRN_CVTFG-TAB_2BYTE	; 99FD	CVTFG
	.WORD	0			; 9AFD
	.WORD	0			; 9BFD
	.WORD	0			; 9CFD
	.WORD	0			; 9DFD
	.WORD	0			; 9EFD
	.WORD	0			; 9FFD
	.WORD	0			; A0FD
	.WORD	0			; A1FD
	.WORD	0			; A2FD
	.WORD	0			; A3FD
	.WORD	0			; A4FD
	.WORD	0			; A5FD
	.WORD	0			; A6FD
	.WORD	0			; A7FD
	.WORD	0			; A8FD
	.WORD	0			; A9FD
	.WORD	0			; AAFD
	.WORD	0			; ABFD
	.WORD	0			; ACFD
	.WORD	0			; ADFD
	.WORD	0			; AEFD
	.WORD	0			; AFFD
	.WORD	0			; B0FD
	.WORD	0			; B1FD
	.WORD	0			; B2FD
	.WORD	0			; B3FD
	.WORD	0			; B4FD
	.WORD	0			; B5FD
	.WORD	0			; B6FD
	.WORD	0			; B7FD
	.WORD	0			; B8FD
	.WORD	0			; B9FD
	.WORD	0			; BAFD
	.WORD	0			; BBFD
	.WORD	0			; BCFD
	.WORD	0			; BDFD
	.WORD	0			; BEFD
	.WORD	0			; BFFD
	.WORD	0			; C0FD
	.WORD	0			; C1FD
	.WORD	0			; C2FD
	.WORD	0			; C3FD
	.WORD	0			; C4FD
	.WORD	0			; C5FD
	.WORD	0			; C6FD
	.WORD	0			; C7FD
	.WORD	0			; C8FD
	.WORD	0			; C9FD
	.WORD	0			; CAFD
	.WORD	0			; CBFD
	.WORD	0			; CCFD
	.WORD	0			; CDFD
	.WORD	0			; CEFD
	.WORD	0			; CFFD
	.WORD	0			; D0FD
	.WORD	0			; D1FD
	.WORD	0			; D2FD
	.WORD	0			; D3FD
	.WORD	0			; D4FD
	.WORD	0			; D5FD
	.WORD	0			; D6FD
	.WORD	0			; D7FD
	.WORD	0			; D8FD
	.WORD	0			; D9FD
	.WORD	0			; DAFD
	.WORD	0			; DBFD
	.WORD	0			; DCFD
	.WORD	0			; DDFD
	.WORD	0			; DEFD
	.WORD	0			; DFFD
	.WORD	0			; E0FD
	.WORD	0			; E1FD
	.WORD	0			; E2FD
	.WORD	0			; E3FD
	.WORD	0			; E4FD
	.WORD	0			; E5FD
	.WORD	0			; E6FD
	.WORD	0			; E7FD
	.WORD	0			; E8FD
	.WORD	0			; E9FD
	.WORD	0			; EAFD
	.WORD	0			; EBFD
	.WORD	0			; ECFD
	.WORD	0			; EDFD
	.WORD	0			; EEFD
	.WORD	0			; EFFD
	.WORD	0			; F0FD
	.WORD	0			; F1FD
	.WORD	0			; F2FD
	.WORD	0			; F3FD
	.WORD	0			; F4FD
	.WORD	0			; F5FD
	.WORD	PATRN_CVTHF-TAB_2BYTE	; F6FD	CVTHF
	.WORD	PATRN_CVTHD-TAB_2BYTE	; F7FD	CVTHD
	.WORD	0			; F8FD
	.WORD	0			; F9FD
	.WORD	0			; FAFD
	.WORD	0			; FBFD
	.WORD	0			; FCFD
	.WORD	0			; FDFD
	.WORD	0			; FEFD
	.WORD	0			; FFFD

	;

;+
; Instruction operand patterns
;
; Each pattern is defined using the macro OPDEF whose arguments
; describe the access type and data type of the operands.  The operand
; codes are of the form "xy", where "x" is the access type and "y" is
; the data type.
;-

PATRN_HALT:
PATRN_NOP:
PATRN_REI:
PATRN_BPT:
PATRN_RET:
PATRN_RSB:
PATRN_LDPCTX:
PATRN_SVPCTX:
PATRN_XFC:
	OPDEF

PATRN_CVTPS:
PATRN_CVTSP:
	OPDEF	RW,AB,RW,AB

PATRN_INDEX:
	OPDEF	RL,RL,RL,RL,RL,WL

PATRN_CRC:
	OPDEF	AB,RL,RW,AB

PATRN_PROBER:
PATRN_PROBEW:
	OPDEF	RB,RW,AB

PATRN_INSQUE:
	OPDEF	AB,AB

PATRN_REMQUE:
	OPDEF	AB,WL

PATRN_BSBB:
PATRN_BRB:
PATRN_BNEQ:
PATRN_BEQL:
PATRN_BGTR:
PATRN_BLEQ:
PATRN_BGEQ:
PATRN_BLSS:
PATRN_BGTRU:
PATRN_BLEQU:
PATRN_BVC:
PATRN_BVS:
PATRN_BGEQU:
PATRN_BLSSU:
	OPDEF	BB

PATRN_JSB:
PATRN_JMP:
PATRN_PUSHAB:
	OPDEF	AB

PATRN_ADDP4:
PATRN_SUBP4:
PATRN_CMPP4:
PATRN_MATCHC:
	OPDEF	RW,AB,RW,AB

PATRN_ADDP6:
PATRN_SUBP6:
PATRN_MULP:
PATRN_DIVP:
	OPDEF	RW,AB,RW,AB,RW,AB

PATRN_CVTPT:
PATRN_CVTTP:
	OPDEF	RW,AB,AB,RW,AB

PATRN_MOVC3:
PATRN_CMPC3:
	OPDEF	RW,AB,AB

PATRN_SCANC:
PATRN_SPANC:
	OPDEF	RW,AB,AB,RB

PATRN_MOVC5:
PATRN_CMPC5:
	OPDEF	RW,AB,RB,RW,AB

PATRN_MOVTC:
PATRN_MOVTUC:
	OPDEF	RW,AB,RB,AB,RW,AB

PATRN_BSBW:
PATRN_BRW:
	OPDEF	BW

PATRN_CVTWL:
PATRN_MOVZWL:
	OPDEF	RW,WL

PATRN_CVTWB:
	OPDEF	RW,WB

PATRN_MOVP:
PATRN_CMPP3:
	OPDEF	RW,AB,AB

PATRN_CVTPL:
	OPDEF	RW,AB,WL

PATRN_EDITPC:
	OPDEF	RW,AB,AB,AB

PATRN_LOCC:
PATRN_SKPC:
	OPDEF	RB,RW,AB

PATRN_ACBW:
	OPDEF	RW,RW,MW,BW

PATRN_MOVAW:
	OPDEF	AW,WL

PATRN_PUSHAW:
	OPDEF	AW

PATRN_ADDF2:
PATRN_SUBF2:
PATRN_MULF2:
PATRN_DIVF2:
	OPDEF	RF,MF

PATRN_ADDF3:
PATRN_SUBF3:
PATRN_MULF3:
PATRN_DIVF3:
	OPDEF	RF,RF,WF

PATRN_CVTFB:
	OPDEF	RF,WB

PATRN_CVTFW:
	OPDEF	RF,WW

PATRN_CVTFL:
PATRN_CVTRFL:
	OPDEF	RF,WL

PATRN_CVTBF:
	OPDEF	RB,WF

PATRN_CVTWF:
	OPDEF	RW,WF

PATRN_CVTLF:
	OPDEF	RL,WF

PATRN_ACBF:
	OPDEF	RF,RF,MF,BW

PATRN_MOVF:
PATRN_MNEGF:
	OPDEF	RF,WF

PATRN_CMPF:
	OPDEF	RF,RF

PATRN_TSTF:
	OPDEF	RF

PATRN_EMODF:
	OPDEF	RF,RB,RF,WL,WF

PATRN_POLYF:
	OPDEF	RF,RW,AB

PATRN_CVTFD:
	OPDEF	RF,WD

PATRN_ADAWI:
PATRN_ADDW2:
PATRN_SUBW2:
PATRN_MULW2:
PATRN_DIVW2:
PATRN_BISW2:
PATRN_BICW2:
PATRN_XORW2:
	OPDEF	RW,MW

PATRN_INSQHI:
PATRN_INSQTI:
	OPDEF	AB,AQ

PATRN_REMQHI:
PATRN_REMQTI:
	OPDEF	AQ,WL

PATRN_ADDD2:
PATRN_SUBD2:
PATRN_MULD2:
PATRN_DIVD2:
	OPDEF	RD,MD

PATRN_ADDD3:
PATRN_SUBD3:
PATRN_MULD3:
PATRN_DIVD3:
	OPDEF	RD,RD,WD

PATRN_CVTDB:
	OPDEF	RD,WB

PATRN_CVTDW:
	OPDEF	RD,WW

PATRN_CVTDL:
PATRN_CVTRDL:
	OPDEF	RD,WL

PATRN_CVTBD:
	OPDEF	RB,WD

PATRN_CVTWD:
	OPDEF	RW,WD

PATRN_CVTLD:
	OPDEF	RL,WD

PATRN_ACBD:
	OPDEF	RD,RD,MD,BW

PATRN_MOVD:
PATRN_MNEGD:
	OPDEF	RD,WD

PATRN_CMPD:
	OPDEF	RD,RD

PATRN_TSTD:
	OPDEF	RD

PATRN_EMODD:
	OPDEF	RD,RB,RD,WL,WD

PATRN_POLYD:
	OPDEF	RD,RW,AB

PATRN_CVTDF:
	OPDEF	RD,WF

PATRN_ASHL:
	OPDEF	RB,RL,WL

PATRN_ASHQ:
	OPDEF	RB,RQ,WQ

PATRN_EMUL:
	OPDEF	RL,RL,RL,WQ

PATRN_EDIV:
	OPDEF	RL,RQ,WL,WL

PATRN_CLRQ:
	OPDEF	WQ

PATRN_MOVQ:
	OPDEF	RQ,WQ

PATRN_MOVAQ:
	OPDEF	AQ,WL

PATRN_PUSHAQ:
	OPDEF	AQ

PATRN_ADDB2:
PATRN_SUBB2:
PATRN_MULB2:
PATRN_DIVB2:
PATRN_BISB2:
PATRN_BICB2:
PATRN_XORB2:
	OPDEF	RB,MB

PATRN_ADDB3:
PATRN_SUBB3:
PATRN_MULB3:
PATRN_DIVB3:
PATRN_BISB3:
PATRN_BICB3:
PATRN_XORB3:
	OPDEF	RB,RB,WB

PATRN_MNEGB:
PATRN_MOVB:
PATRN_MCOMB:
	OPDEF	RB,WB

PATRN_CASEB:
	OPDEF	RB,RB,RB	; User must understand branch table

PATRN_CMPB:
PATRN_BITB:
	OPDEF	RB,RB

PATRN_CLRB:
	OPDEF	WB

PATRN_TSTB:
	OPDEF	RB

PATRN_INCB:
PATRN_DECB:
	OPDEF	MB

PATRN_CVTBL:
PATRN_MOVZBL:
	OPDEF	RB,WL

PATRN_CVTBW:
PATRN_MOVZBW:
	OPDEF	RB,WW

PATRN_ROTL:
	OPDEF	RB,RL,WL

PATRN_ACBB:
	OPDEF	RB,RB,MB,BW

PATRN_MOVAB:
	OPDEF	AB,WL

PATRN_ADDW3:
PATRN_SUBW3:
PATRN_MULW3:
PATRN_DIVW3:
PATRN_BISW3:
PATRN_BICW3:
PATRN_XORW3:
	OPDEF	RW,RW,WW

PATRN_MNEGW:
PATRN_MOVW:
PATRN_MCOMW:
	OPDEF	RW,WW

PATRN_CASEW:
	OPDEF	RW,RW,RW	; User must understand branch table

PATRN_CMPW:
PATRN_BITW:
	OPDEF	RW,RW

PATRN_CLRW:
	OPDEF	WW

PATRN_TSTW:
PATRN_BISPSW:
PATRN_BICPSW:
PATRN_POPR:
PATRN_PUSHR:
PATRN_CHMK:
PATRN_CHME:
PATRN_CHMS:
PATRN_CHMU:
	OPDEF	RW

PATRN_INCW:
PATRN_DECW:
	OPDEF	MW

PATRN_ADDL2:
PATRN_SUBL2:
PATRN_MULL2:
PATRN_DIVL2:
PATRN_BISL2:
PATRN_BICL2:
PATRN_XORL2:
PATRN_ADWC:
PATRN_SBWC:
	OPDEF	RL,ML

PATRN_ADDL3:
PATRN_SUBL3:
PATRN_MULL3:
PATRN_DIVL3:
PATRN_BISL3:
PATRN_BICL3:
PATRN_XORL3:
	OPDEF	RL,RL,WL

PATRN_MNEGL:
PATRN_MOVL:
PATRN_MCOML:
PATRN_MFPR:
	OPDEF	RL,WL

PATRN_CASEL:
	OPDEF	RL,RL,RL	; User must understand branch table

PATRN_CMPL:
PATRN_BITL:
PATRN_MTPR:
	OPDEF	RL,RL

PATRN_CLRL:
PATRN_MOVPSL:
	OPDEF	WL

PATRN_TSTL:
PATRN_PUSHL:
	OPDEF	RL

PATRN_INCL:
PATRN_DECL:
	OPDEF	ML

PATRN_MOVAL:
	OPDEF	AL,WL

PATRN_PUSHAL:
	OPDEF	AL

PATRN_BBS:
PATRN_BBC:
PATRN_BBSS:
PATRN_BBCS:
PATRN_BBSC:
PATRN_BBCC:
PATRN_BBSSI:
PATRN_BBCCI:
	OPDEF	RL,VB,BB

PATRN_BLBS:
PATRN_BLBC:
	OPDEF	RL,BB

PATRN_FFS:
PATRN_FFC:
PATRN_EXTV:
PATRN_EXTZV:
	OPDEF	RL,RB,VB,WL

PATRN_CMPV:
PATRN_CMPZV:
	OPDEF	RL,RB,VB,RL

PATRN_INSV:
	OPDEF	RL,RL,RB,VB

PATRN_ACBL:
	OPDEF	RL,RL,ML,BW

PATRN_AOBLSS:
PATRN_AOBLEQ:
	OPDEF	RL,ML,BB

PATRN_SOBGEQ:
PATRN_SOBGTR:
	OPDEF	ML,BB

PATRN_CVTLB:
	OPDEF	RL,WB

PATRN_CVTLW:
	OPDEF	RL,WW

PATRN_ASHP:
	OPDEF	RB,RW,AB,RB,RW,AB

PATRN_CVTLP:
	OPDEF	RL,RW,AB

PATRN_CALLS:
	OPDEF	RL,AB

PATRN_CALLG:
	OPDEF	AB,AB

PATRN_CVTDH:
	OPDEF	RD,WH

PATRN_CVTGF:
	OPDEF	RG,WF

PATRN_ADDG2:
PATRN_SUBG2:
PATRN_MULG2:
PATRN_DIVG2:
	OPDEF	RG,MG

PATRN_ADDG3:
PATRN_SUBG3:
PATRN_MULG3:
PATRN_DIVG3:
	OPDEF	RG,RG,WG

PATRN_CVTGB:
	OPDEF	RG,WB

PATRN_CVTGW:
	OPDEF	RG,WW

PATRN_CVTGL:
PATRN_CVTRGL:
	OPDEF	RG,WL

PATRN_CVTBG:
	OPDEF	RB,WG

PATRN_CVTWG:
	OPDEF	RW,WG

PATRN_CVTLG:
	OPDEF	RL,WG

PATRN_ACBG:
	OPDEF	RG,RG,MG,BW

PATRN_MOVG:
PATRN_MNEGG:
	OPDEF	RG,WG

PATRN_CMPG:
	OPDEF	RG,RG

PATRN_TSTG:
	OPDEF	RG

PATRN_EMODG:
	OPDEF	RG,RW,RG,WL,WG

PATRN_POLYG:
	OPDEF	RG,RW,AB

PATRN_CVTGH:
	OPDEF	RG,WH

PATRN_ADDH2:
PATRN_SUBH2:
PATRN_MULH2:
PATRN_DIVH2:
	OPDEF	RH,MH

PATRN_ADDH3:
PATRN_SUBH3:
PATRN_MULH3:
PATRN_DIVH3:
	OPDEF	RH,RH,WH

PATRN_CVTHB:
	OPDEF	RH,WB

PATRN_CVTHW:
	OPDEF	RH,WW

PATRN_CVTHL:
PATRN_CVTRHL:
	OPDEF	RH,WL

PATRN_CVTBH:
	OPDEF	RB,WH

PATRN_CVTWH:
	OPDEF	RW,WH

PATRN_CVTLH:
	OPDEF	RL,WH

PATRN_ACBH:
	OPDEF	RH,RH,MH,BW

PATRN_MOVH:
PATRN_MNEGH:
	OPDEF	RH,WH

PATRN_CMPH:
	OPDEF	RH,RH

PATRN_TSTH:
	OPDEF	RH

PATRN_EMODH:
	OPDEF	RH,RW,RH,WL,WH

PATRN_POLYH:
	OPDEF	RH,RW,AB

PATRN_CVTHG:
	OPDEF	RH,WG

PATRN_CLRO:
	OPDEF	WO

PATRN_MOVO:
	OPDEF	RO,WO

PATRN_MOVAO:
	OPDEF	AO,WL

PATRN_PUSHAO:
	OPDEF	AO

PATRN_CVTFH:
	OPDEF	RF,WH

PATRN_CVTFG:
	OPDEF	RF,WG

PATRN_CVTHF:
	OPDEF	RH,WF

PATRN_CVTHD:
	OPDEF	RH,WD

	.SBTTL Operand Decoding Routines

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*	    Routines for Scanning Instruction Operands	       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    The following section contains a set of routines for
	;	scanning the operands of an instruction and determining the
	;	values and locations of operands. The code contains full error
	;	checking and also checks for the situations that the
	;	architecture considers to be unpredictable. 
	;
	;	Operand Scanning Routines
	;	-------------------------
	;
	;	The operand scanning routines are entered by loading the
	;	access type into R8, the data type into R9, and then
	;	performing a JSB-type branch to GET_SPECIFIER.
	;
	;	    When the routines are entered they scan the next 
	;	instruction operand starting at the value of the user's PC
	;	and check the operand for validity. If any exceptions are
	;	detected during operand scanning they are processed immediatly
	;	and the routines do not return. Any changes that are made to
	;	any of the registers (including PC) are recorded in the change
	;	words so faults will be handled properly.
	;
	;	    If the operand access type is READ, MODIFY or FIELD,
	;	ADDRESS or BRANCH, the address of the value is placed in the 
	;	appropriate element of the READ_ADDRS array.  If the operand 
	;	is also immediate mode or a register, its value is copied to
	;	the READ_OPERANDS array and READ_ADDRS points to that location.
	;	This is to prevent later operand specifiers from modifying
	;	registers previously used as operands, and gives a place to
	;	store immediate mode operands.
	;
	;	     If the operand access type is WRITE, MODIFY, ADDRESS, or
	;	FIELD, the address of the value is placed in the appropriate
	;	element of the WRITE_ADDRS array.  If the operand is a
	;	register, a pointer to the appropriate emulated register
	;	is used.  This permits correct implementation of the
	;	"read all operands, then write all operands" rule of
	;	the VAX architecture.
	;
	;	If the WRITE_ADDRS element is to be filled with a value that
	;	addresses our local storage then it
	;	is changed to an address that won't do any harm. This is 
	;	consistent with the notion that the area below the user's
	;	stack pointer is being continually garbaged. This check is not
	;	performed if flag bit V_REGISTER is set, which indicates that
	;	the operand is a register mode operand.
	;
	;	    If the FPD bit is set in the PSL, the only effect
	;	of decoding an operand specifier is to move the PC.
	;
	;
	;	Exceptions
	;	----------
	;
	;	    The instruction operand scanning routines perform complete
	;	error checking and immediatly signal any exceptions detected.
	;	All of these exceptions are faults. The change words are
	;	constantly kept up to date so the instruction will be left in
	;	a consistant state for restarting if a fault occurs.
	;
	;	    All fetches from memory done in scanning the instruction
	;	operand or in fetching the operand or operand address are 
	;	probed and access violations are signaled if the probes fail.
	;	All of the addressing modes specified by the architecture to
	;	be reserved addressing modes or unpredictable are checked for
	;	and are signaled as reserved addressing modes if they are
	;	detected.
	;
	;
	;	Routine Organization
	;	--------------------
	;
	;	    GET_SPECIFIER loads the length of the data type into R10
	;	and the operand specifier byte into R0. The high and low 
	;	order nibbles of this byte are stored in R1 and R2. The 
	;	register R7 which is reserved for the index modification is 
	;	cleared. The routine now branches on the high order nibble
	;	to a routine which will handle the specific kind of operand.
	;
	;	    For literals the values are expanded immediately.
	;
	;	    For index mode operand specifiers, the index modification
	;	is computed and the next operand specifier byte is loaded into
	;	R0 and decomposed as before. Again we branch on the high order
	;	nibble but this time certain addressing modes which are 
	;	illegal with indexing are checked for. Also for those 
	;	addressing modes which change register values a check is made
	;	that the register is not the same as the index register.
	;
	;	    For register mode operands the address of the emulated
	;	register is loaded into R11. A check is made that the operand
	;	does not contain PC. Then flag bit V_REGISTER  is set and 
	;	control passes to the operand reading routine.
	;
	;	    For the remaining addressing modes the operand addresses
	;	are computed in a straightforward manner and loaded into R11.
	;	for some of these addressing modes the values of registers may
	;	be changed. These changes are reflected in the change words.
	;	When the operand address is computed control passes to the 
	;	operand accessing routine.
	;	
	;	    For ADDRESS and FIELD access mode operands the operand 
	;	accessing routine returns but for all others it probes the 
	;	operand address and also checks for writes into local
	;	storage unless V_REGISTER is set. If the operand is READ or
	;	MODIFY access control passes to the operand reading routine.
	;
	;

	;
	;	Table of Data Type Lengths
	;
LENGTHS:				; table origin
	.BYTE	1			; 1 - byte
	.BYTE	2			; 2 - word
	.BYTE	4			; 3 - longword
	.BYTE	8			; 4 - quadword
	.BYTE	16			; 5 - octaword
	.BYTE	4			; 6 - F_floating
	.BYTE	8			; 7 - D_floating
	.BYTE	8			; 8 - G_floating
	.BYTE	16			; 9 - H_floating
	;
	;	Process the Next Operand Specifier
	;
GET_SPECIFIER:				; entrance
	CMPL	R8,#LIB$K_DCFACC_B	; Is this a branch address?
	BNEQ	1$			; If not, skip
	BRW	BRANCH_ACCESS		; If so, go process it
1$:	MOVZBL	LENGTHS-1[R9],R10	; R10 = data type length
	CLRL	R7			; clear the index value
	MOVL	REG_PC(FP),R11		; R11 = specifier byte location
	PROBER	MODE(FP),#1,(R11)	; can we read the specifier byte ?
	BNEQ	2$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process an access violation
2$:	MOVZBL	@REG_PC(FP),R0		; R0 = specifier byte
	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the incrementation
	EXTZV	#4,#4,R0,R1		; R1 = high order nibble of specifier
	EXTZV	#0,#4,R0,R2		; R2 = low order nibble of specifier
	CASEL	R1,#0,#15		; branch on the high order nibble
3$:	.WORD	LITERAL_MODE-3$ 	; 0 - literal mode
	.WORD	LITERAL_MODE-3$ 	; 1 - literal mode
	.WORD	LITERAL_MODE-3$ 	; 2 - literal mode
	.WORD	LITERAL_MODE-3$ 	; 3 - literal mode
	.WORD	INDEX_MODE-3$		; 4 - index mode
	.WORD	REGISTER_MODE-3$	; 5 - register mode
	.WORD	REG_DEF_MODE-3$ 	; 6 - register deferred mode
	.WORD	DECR_MODE-3$		; 7 - autodecrement mode
	.WORD	INCR_MODE-3$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-3$	; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-3$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-3$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-3$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-3$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-3$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-3$	; F - long displacement deferred mode
	;
	;	Process a Literal Mode Operand Specifier
	;
LITERAL_MODE:				; entrance
	BBS	#PSL$V_FPD,PSL(FP),20$	; Exit if FPD set
	ASHL	#1,R5,R11		; Get address of location in
	MOVAQ	READ_OPERANDS(FP)[R11],R11 ; READ_OPERANDS to store literal
	CASEL	R8,#1,#4		; branch on the access type
1$:	.WORD	2$-1$			; 1 - read only access
	.WORD	ADDRESS_FAULT-1$	; 2 - modify access
	.WORD	ADDRESS_FAULT-1$	; 3 - write only access
	.WORD	ADDRESS_FAULT-1$	; 4 - address access
	.WORD	ADDRESS_FAULT-1$	; 5 - field access
	HALT				; 6 - branch access (should not occur)
2$:	CASEL	R9,#1,#8		; branch on the data type
3$:	.WORD	6$-3$			; 1 - byte
	.WORD	6$-3$			; 2 - word
	.WORD	6$-3$			; 3 - longword
	.WORD	5$-3$			; 4 - quadword
	.WORD	4$-3$			; 5 - octaword
	.WORD	8$-3$			; 6 - F_floating
	.WORD	7$-3$			; 7 - D_floating
	.WORD	9$-3$			; 8 - G_floating
	.WORD	10$-3$			; 9 - H_floating
4$:	CLRQ	8(R11)			; clear second quadword of value
5$:	CLRL	4(R11)			; clear second longword of value
	MOVL	R0,(R11)		; Move literal value
6$:	MOVL	R11,READ_ADDRS(FP)[R5]	; Set read operand address
	CLRL	WRITE_ADDRS(FP)[R5]	; Indicate no write operand address
20$:	RSB				; return 
7$:	CLRL	4(R11)			; clear second longword of value
8$:	ASHL	#4,R0,(R11)		; position the literal bits
	BBCS	#14,(R11),6$		; include exponent bias and return
9$:	ASHL	#1,R0,(R11)		; position the literal bits
	BBCS	#14,(R11),5$		; include exponent bias and finish up
10$:	ROTL	#29,R0,(R11)		; position the literal bits
	BBCS	#14,(R11),4$		; include exponent bias and finish up
	;
	;	Process an Index Mode Operand Specifier
	;
INDEX_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BNEQ	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	BBS	#PSL$V_FPD,PSL(FP),11$	; Skip if FPD set
	MULL3	R10,REG_R0(FP)[R2],R7	; R7 = index address modification
11$:	MOVL	R2,R3			; save the register number
	MOVL	REG_PC(FP),R11		; R11 = location of next byte
	PROBER	MODE(FP),#1,(R11)	; can we read the next byte ?
	BNEQ	2$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	MOVZBL	@REG_PC(FP),R0		; R0 = next operand specifier
	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the incrementation
	EXTZV	#4,#4,R0,R1		; R1 = high order nibble of specifier
	EXTZV	#0,#4,R0,R2		; R2 = low order nibble of specifier
	CASEL	R1,#0,#15		; branch on the low order nibble
3$:	.WORD	ADDRESS_FAULT-3$	; 0 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 1 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 2 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 3 - literal mode
	.WORD	ADDRESS_FAULT-3$	; 4 - index mode
	.WORD	ADDRESS_FAULT-3$	; 5 - register mode
	.WORD	REG_DEF_MODE-3$ 	; 6 - register deferred mode
	.WORD	4$-3$			; 7 - autodecrement mode
	.WORD	4$-3$			; 8 - autoincrement mode
	.WORD	4$-3$			; 9 - autoincrement deferred mode
	.WORD	BYTE_DISP_MODE-3$	; A - byte displacement mode
	.WORD	BYTE_DEF_MODE-3$	; B - byte displacement deferred mode
	.WORD	WORD_DISP_MODE-3$	; C - word displacement mode
	.WORD	WORD_DEF_MODE-3$	; D - word displacement deferred mode
	.WORD	LONG_DISP_MODE-3$	; E - long displacement mode
	.WORD	LONG_DEF_MODE-3$	; F - long displacement deferred mode
4$:	CMPL	R2,R3			; is register the same as index ?
	BNEQ	5$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
5$:	CASEL	R1,#7,#2		; branch on the high order nibble
6$:	.WORD	DECR_MODE-6$		; 7 - autodecrement mode
	.WORD	INCR_MODE-6$		; 8 - autoincrement mode
	.WORD	INCR_DEF_MODE-6$	; 9 - autoincrement deferred mode
	;
	;	Process a Register Mode Operand Specifier
	;
REGISTER_MODE:				; entrance
	BBS	#PSL$V_FPD,PSL(FP),3$	; Skip if FPD set
	BISB2	#M_REGISTER,FLAGS(FP)	; indicate a register mode operand
	MOVAL	(R10)[R2],R3		; byte position following operand
	CMPL	#60,R3			; does the operand overlap PC ?
	BGEQ	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	MOVAL	REG_R0(FP)[R2],R11	; R11 = location of user register
	CLRL	READ_ADDRS(FP)[R5]	; Initially no read operand
	CLRL	WRITE_ADDRS(FP)[R5]	; Initially no write operand
	CASEL	R8,#1,#4		; branch on the access type
2$:	.WORD	READ_REG-2$		; 1 - read only access
	.WORD	MODIFY_REG-2$		; 2 - modify access
	.WORD	WRITE_REG-2$		; 3 - write access
	.WORD	ADDRESS_FAULT-2$	; 4 - address access
	.WORD	FIELD_REG-2$		; 5 - field access
	HALT				; 6 - branch access (shouldn't occur)
3$:	RSB				; Return for FPD set

FIELD_REG:
	MOVL	R11,READ_ADDRS(FP)[R5]	; Field reads/writes register
WRITE_REG:
	MOVL	R11,WRITE_ADDRS(FP)[R5]	; Indicate write operand address
	RSB
MODIFY_REG:
	MOVL	R11,WRITE_ADDRS(FP)[R5]	; Indicate write operand address
READ_REG:
	ASHL	#1,R5,R0		; Get address of location in
	MOVAQ	READ_OPERANDS(FP)[R0],R0 ; READ_OPERANDS to store registers
	MOVL	R0, READ_ADDRS(FP)[R5]	; Indicate write operand address
	CASEL	R9,#1,#8		; branch on the data type
1$:	.WORD	2$-1$			; 1 - byte
	.WORD	3$-1$			; 2 - word
	.WORD	4$-1$			; 3 - longword
	.WORD	6$-1$			; 4 - quadword
	.WORD	5$-1$			; 5 - octaword
	.WORD	4$-1$			; 6 - F_floating
	.WORD	6$-1$			; 7 - D_floating
	.WORD	6$-1$			; 8 - G_floating
	.WORD	5$-1$			; 9 - H_floating
2$:	CVTBL	(R11),(R0)		; save operand value
	RSB				; return
3$:	CVTWL	(R11),(R0)		; save operand value
	RSB				; return
4$:	MOVL	(R11),(R0)		; save operand value
	BRB	10$
5$:	MOVQ	8(R11),8(R0)		; save high order quadword of value
6$:	MOVQ	(R11),(R0)		; save low order quadword of value
10$:	BRW	ROPRAND_CHECK		; Check for reserved operand
	;
	;	Process a Register Deferred Mode Operand Specifier
	;
REG_DEF_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	1$			; no - skip
	BRW	ADDRESS_FAULT 		; process the reserved addressing mode
1$:	BBS	#PSL$V_FPD,PSL(FP),2$	; Return if FPD set
	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
2$:	RSB				; Return if FPD set
	;
	;	Process an Autodecrement Mode Operand Specifier
	;
DECR_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	1$			; no - skip
	BRW	ADDRESS_FAULT	 	; process the reserved addressing mode
1$:	BBS	#PSL$V_FPD,PSL(FP),2$	; Skip if FPD set
	SUBL2	R10,REG_R0(FP)[R2]	; subtract data size from register
	SUBW2	R10,REGMOD_R0(FP)[R2]	; remember the subtraction
	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
2$:	RSB				; Return if FPD set
	;
	;	Process an Autoincrement Mode Operand Specifier
	;
INCR_MODE:				; entrance
	CMPL	#15,R2			; is the register PC ?
	BGTR	2$			; no - bypass
	CASEL	R8,#1,#4		; branch on the access type
1$:	.WORD	2$-1$			; 1 - read only access
	.WORD	ADDRESS_FAULT-1$	; 2 - modify access
	.WORD	ADDRESS_FAULT-1$	; 3 - write only access
	.WORD	2$-1$			; 4 - address access
	.WORD	2$-1$			; 5 - field access
	HALT				; 6 - branch access (shouldn't occur)
2$:	BBS	#PSL$V_FPD,PSL(FP),3$	; Skip if FPD set
	ADDL3	R7,REG_R0(FP)[R2],R11	; form the operand address
	ADDL2	R10,REG_R0(FP)[R2]	; add the data size to the register
	ADDW2	R10,REGMOD_R0(FP)[R2]	; remember the addition
	BRW	ACCESS_VALUE		; finish establishing the access
3$:	RSB				; Return if FPD set
	;
	;	Process an Autoincrement Deferred Mode Operand Specifier
	;
INCR_DEF_MODE:				; entrance
	BBS	#PSL$V_FPD,PSL(FP),2$	; skip if FPD set
	MOVL	REG_R0(FP)[R2],R11	; R11 = register value
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL3	R7,(R11),R11		; form the operand address
	ADDL2	#4,REG_R0(FP)[R2]	; add longword size to the register
	ADDW2	#4,REGMOD_R0(FP)[R2]	; remember the incrementation
	BRW	ACCESS_VALUE		; finish establishing the access
2$:	RSB				; return if FPD set
	;
	;	Process a Byte Displacement Mode Operand Specifier
	;
BYTE_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the increment
	BBS	#PSL$V_FPD,PSL(FP),2$	; skip if FPD set
	CVTBL	(R11),R11		; R11 = displacement value
	ADDL2	R7,R11			; add the displacement to the index
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the result
	BRW	ACCESS_VALUE		; finish establishing the access
2$:	RSB				; Return if FPD set
	;
	;	Process a Byte Displacement Deferred Mode Operand Specifier
	;
BYTE_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the increment
	BBS	#PSL$V_FPD,PSL(FP),3$	; skip if FPD set
	CVTBL	(R11),R11		; R11 = displacement value
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access fault
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
3$:	RSB				; Return if FPD set
	;
	;	Process a Word Displacement Mode Operand Specifier
	;
WORD_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDW2	#2,REGMOD_PC(FP)	; remember the increment
	BBS	#PSL$V_FPD,PSL(FP),2$	; Skip if FPD set
	CVTWL	(R11),R11		; R11 = displacement value
	ADDL2	R7,R11			; add the index to the displacement
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the result
	BRW	ACCESS_VALUE		; finish establishing the access
2$:	RSB				; Return if FPD set
	;
	;	Process a Word Displacement Deferred Mode Operand Specifier
	;
WORD_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDW2	#2,REGMOD_PC(FP)	; remember the increment
	BBS	#PSL$V_FPD,PSL(FP),3$	; skip if FPD set
	CVTWL	(R11),R11		; R11 = displacement value
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
3$:	RSB				; Return if FPD set
	;
	;	Process a Long Displacement Mode Operand Specifier
	;
LONG_DISP_MODE: 			; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDW2	#4,REGMOD_PC(FP)	; remember the increment
	BBS	#PSL$V_FPD,PSL(FP),2$	; skip if FPD set
	MOVL	(R11),R11		; R11 = displacement value
	ADDL2	R7,R11			; add the index to the displacement
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the address
	BRW	ACCESS_VALUE		; finish establishing the access
2$:	RSB				; Return if FPD set
	;
	;	Process a Long Displacement Deferred Mode Operand Specifier
	;
LONG_DEF_MODE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDW2	#4,REGMOD_PC(FP)	; remember the increment
	BBS	#PSL$V_FPD,PSL(FP),3$	; skip if FPD set
	MOVL	(R11),R11		; R11 = displacement value
	ADDL2	REG_R0(FP)[R2],R11	; add the register to the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read longword it addresses ?
	BNEQ	2$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
2$:	ADDL3	R7,(R11),R11		; form the operand address
	BRW	ACCESS_VALUE		; finish establishing the access
3$:	RSB				; Return if FPD set
	;
	;	Set Up the Type of Access Requested
	;
ACCESS_VALUE:				; entrance
	CASEL	R8,#1,#4		; branch on the access type
1$:	.WORD	READ_CHECK-1$		; 1 - read only access
	.WORD	MODIFY_CHECK-1$ 	; 2 - modify access
	.WORD	WRITE_CHECK-1$		; 3 - write only access
	.WORD	2$-1$			; 4 - address access
	.WORD	2$-1$			; 5 - field access
	HALT				; 6 - branch access (shouldn't occur)
2$:	RSB				; return with the operand address
	;
	;	Perform Error Checking for Modify Access Operands
	;
MODIFY_CHECK:				; entrance
	BSBB	WRITE_CHECK		; check write (and read) access
	MOVL	R11,READ_ADDRS(FP)[R5]	; Set read operand address
	BRB	ROPRAND_CHECK		; Check for reserved operand
	;
	;	Perform Error Checking for Read Only Access Operands
	;
READ_CHECK:				; entrance
	MOVL	R11,READ_ADDRS(FP)[R5]	; Set read operand address
	CLRL	WRITE_ADDRS(FP)[R5]	; Indicate no write operand
	PROBER	MODE(FP),R10,(R11)	; can we read the operand ?
	BNEQ	ROPRAND_CHECK		; yes - test for reserved operand
	CMPCOND	SS$_ACCVIO,COND_NAME(FP); Is this an SS$_ACCVIO fault?
	BNEQ	1$			; Skip if not
	RSB				; Return
1$:	BSBW	READ_FAULT		; process the access violation
ROPRAND_CHECK:
	CMPCOND	SS$_ROPRAND,COND_NAME(FP); Is exception SS$_ROPRAND?
	BEQL	10$			; If so, skip operand check
	CASEL	R9,#1,#8		; case on data type
1$:	.WORD	10$-1$			; 1 - byte
	.WORD	10$-1$			; 2 - word
	.WORD	10$-1$			; 3 - longword
	.WORD	10$-1$			; 4 - quadword
	.WORD	10$-1$			; 5 - octaword
	.WORD	2$-1$			; 6 - F_floating
	.WORD	2$-1$			; 7 - D_floating
	.WORD	3$-1$			; 8 - G_floating
	.WORD	4$-1$			; 9 - H_floating
2$:	CMPZV	#7,#9,(R11),#^X100	; F or D reserved operand?
	BEQL	11$			; If so, SS$_ROPRAND
	RSB				; Else return
3$:	CMPZV	#4,#12,(R11),#^X800	; G reserved operand?
	BEQL	11$			; If so, SS$_ROPRAND
	RSB				; Else return
4$:	CMPW	(R11),#^X8000		; H reserved operand?
	BEQL	11$			; If so, SS$_ROPRAND
10$:	RSB				; Return
11$:	BRW	OPERAND_FAULT		; Cause SS$_ROPRAND fault

	;
	;	Perform Error Checking for Write Only Access Operands
	;
WRITE_CHECK:				; entrance
	PROBEW	MODE(FP),R10,(R11)	; can we write the operand ?
	BNEQ	1$			; yes - bypass
	CMPCOND	SS$_ACCVIO,COND_NAME(FP); Is exception SS$_ACCVIO?
	BEQL	1$			; If so, skip access test
	BSBW	WRITE_FAULT		; process the access violation
	BBS	#V_REGISTER,FLAGS(FP),1$ ; no local store checking - skip
	BSBW	LOCAL_TEST		; test for a write into local storage
1$:	CLRL	READ_ADDRS(FP)[R5]	; Indicate no reading
	MOVL	R11,WRITE_ADDRS(FP)[R5]	; Indicate write operand address
	RSB

BRANCH_ACCESS:
	CLRL	WRITE_ADDRS(FP)[R5]	; Indicate no write operand
	CASEL	R9,#1,#2		; Case on data type
1$:	.WORD	BRANCH_BYTE-1$		; 1 - byte
	.WORD	BRANCH_WORD-1$		; 2 - word
	.WORD	BRANCH_LONG-1$		; 3 - longword
	BRW	ADDRESS_FAULT		; All other types get SS$_RADRMOD

	;
	;	Process a Byte Branch Displacement Operand
	;
BRANCH_BYTE:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#1,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#1,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTBL	(R11),R11		; R11 = branch displacement
	INCL	REG_PC(FP)		; increment PC
	INCW	REGMOD_PC(FP)		; remember the increment
	ADDL2	REG_PC(FP),R11		; compute the branch destination
	MOVL	R11,READ_ADDRS(FP)[R5]	; Store the branch address
	RSB				; return

	;
	;	Process a Word Branch Displacement Operand
	;
BRANCH_WORD:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#2,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#2,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	CVTWL	(R11),R11		; R11 = branch displacement
	ADDL2	#2,REG_PC(FP)		; increment PC
	ADDW2	#2,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_PC(FP),R11		; compute the branch destination
	MOVL	R11,READ_ADDRS(FP)[R5]	; Store the branch address
	RSB				; return

	;
	;	Process a Longword Branch Displacement Operand
	;
BRANCH_LONG:				; entrance
	MOVL	REG_PC(FP),R11		; R11 = location of the displacement
	PROBER	MODE(FP),#4,(R11)	; can we read the displacement ?
	BNEQ	1$			; yes - skip
	MOVL	#4,R10			; R10 = size of probe
	BSBW	READ_FAULT		; process the access violation
1$:	MOVL	(R11),R11		; R11 = branch displacement
	ADDL2	#4,REG_PC(FP)		; increment PC
	ADDW2	#4,REGMOD_PC(FP)	; remember the increment
	ADDL2	REG_PC(FP),R11		; compute the branch destination
	MOVL	R11,READ_ADDRS(FP)[R5]	; Store branch address
	RSB				; return

	;
	;	Test for a Write into Local Storage
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Number of Bytes to be Written
	;				R11 = Destination Address
	;
	;		returns with	R11 = Corrected Destination Address
	;
	;	Discussion
	;	
	;	    This routine checks the write operation described by
	;	the parameters in R10 and R11 for a write into the Emulator's
	;	working storage. If such a write is about to take place, R11
	;	is changed to an address where the write will not do any harm.
	;
LOCAL_TEST:				; entrance
	MOVAB	LOCAL_END(FP),R3	; R3 = byte following local storage
	CMPL	R11,R3			; is the write above the frame ?
	BGEQU	1$			; yes - bypass
	ADDL3	R10,R11,R3		; R3 = byte following operand
	CMPL	R3,SP			; is it above the stack pointer ?
	BLEQU	1$			; no - operand is not in local storage
	MOVAB	TEMP(FP),R11		; redirect the write to TEMP
1$:	RSB				; return with the operand address
	;

	;	****************************************************************
	;	*							       *
	;	*							       *
	;	*		Exception Processing Routines		       *
	;	*							       *
	;	*							       *
	;	****************************************************************
	;
	;
	;	Introduction
	;	------------
	;
	;	    For each of the exceptions recognized, there is a routine
	;	which is branched to (except for access violations in which
	;	a subroutine branch is used instead) as soon as the condition
	;	is detected. This routine pushes a shortened version of the
	;	signal array onto the stack and branches to SIGNAL_START which
	;	builds the signal and mechanism arrays in the proper place in
	;	memory and enters the signal dispatcher to search for handlers
	;	to process the condition. If the exception was a fault, the
	;	routine FAULT_RESET is called to restore the registers to
	;	their values when the instruction was started.
	;
	;
	;	Access Violations
	;	-----------------
	;
	;	    The routines READ_FAULT and WRITE_FAULT are called by
	;	subroutine branching when memory probes of read and write
	;	access fail during instruction emulation. The register R11 is
	;	assumed to contain the location of the area being probed
	;	and the register R10 is assumed to contain its length. The
	;	routine tries to produce the fault under controlled conditions
	;	and returns if it can not produce the fault. If it can produce
	;	the fault the the fault is signaled with the reason mask being
	;	the reason mask from the attempt to produce the fault and with
	;	the violation address as the address of the first byte of the
	;	area for which the access violation occurs.
	;
	;	
	;

	;
	;	READ_FAULT - Process a Read Access Violation Fault
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Size of Area being Read
	;				R11 = Location of Area being Read
	;
READ_FAULT:				; entrance
	PUSHR	#^M<R0,R1,R2>		; save R0,R1,R2
	MOVL	R11,R2			; R2 = probed address
	PROBER	MODE(FP),#1,(R2)	; is the first byte readable ?
	BEQL	1$			; no - bypass
	PROBER	MODE(FP),#1,-1(R2)[R10]	; is the last byte readable ?
	BNEQ	1$			; yes - bypass
	MOVAB	-1(R2)[R10],R0		; R2 = address of last byte
	BICW2	#511,R2			; compute address of first bad byte
1$:	CALLS	#0,B^READ_REASON	; get the reason mask
	BLBS	R0,2$			; the read went all right - bypass
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	PUSHL	R2			; push the bad address
	PUSHL	R1			; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
2$:	POPR	#^M<R0,R1,R2>		; restore R0,R1,R2
	RSB				; get back
	;
	;	READ_REASON - Get the Reason Mask for a Read Access Violation
	;
	;		parameter:	R2 = Address for which Probe Failed
	;
	;		returns with	R0 = Status of Access Attempt
	;				R1 = Reason Mask if Unsuccessful
	;
READ_REASON:				; entrance
	.WORD	0			; entry mask
	MOVAB	B^REASON_HANDLER,(FP)	; set up the condition handler
	TSTB	(R2)			; touch the location
	MOVL	#1,R0			; indicate a successful read
	RET				; return
	;
	;	REASON_HANDLER - Condition Handler for Reason Routines
	;
	;		parameters:	P1 = Signal Array Location
	;				P2 = Mechanism Array Location
	;
	;		returns with 	R0 = Condition Response
	;
REASON_HANDLER:				; entrance
	.WORD	0			; entry mask
	MOVQ	4(AP),R0		; R0 and R1 = location of arrays
	TSTL	8(R1)			; condition from establisher frame ?
	BNEQ	1$			; no - bypass
	CMPCOND	SS$_ACCVIO,4(R0)	; access violation condition ?
	BNEQ	1$			; no - bypass
	CLRL	12(R1)			; return zero status in R0
	MOVL	8(R0),16(R1)		; return the reason mask in R1
	CLRQ	-(SP)			; default PC and level for unwind
	CALLS	#2,G^SYS$UNWIND		; unwind the reason routine frame
1$:	CVTWL	#SS$_RESIGNAL,R0	; specify condition not handled
	RET				; return
	;

	;
	;	WRITE_FAULT - Process a Write Access Violation Fault
	;
	;		entered by subroutine branching
	;
	;		parameters:	R10 = Size of Area being Written
	;				R11 = Location of Area being Written
	;
WRITE_FAULT:				; entrance
	PUSHR	#^M<R0,R1,R2>		; save R0,R1,R2
	MOVL	R11,R2			; R2 = probed address
	PROBEW	MODE(FP),#1,(R2)	; is the first byte writeable ?
	BEQL	1$			; no - bypass
	PROBEW	MODE(FP),#1,-1(R2)[R10]	; is the last byte writeable ?
	BNEQ	1$			; yes - bypass
	MOVAB	-1(R2)[R10],R2		; R2 = address of last byte
	BICW2	#511,R2			; compute address of first bad byte
1$:	CALLS	#0,B^WRITE_REASON	; get the reason mask
	BLBS	R0,2$			; the write went all right - bypass
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	PUSHL	R2			; push the bad address
	PUSHL	R1			; push the reason mask
	PUSHL	#SS$_ACCVIO		; push the condition code
	PUSHL	#3			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
2$:	POPR	#^M<R0,R1,R2>		; restore R0,R1,R2
	RSB				; get back
	;
	;	WRITE_REASON - Get the Reason Mask for Write Access Violation
	;
	;		parameter:	R2 = Address for which Probe Failed
	;
	;		returns with	R0 = Status of Access Attempt
	;				R1 = Reason Mask if Unsuccessful
	;
WRITE_REASON:				; entrance
	.WORD	0			; entry mask
	MOVAB	B^REASON_HANDLER,(FP)	; set up the condition handler
	ADDB2	#0,(R2)			; try to change the location
	MOVL	#1,R0			; indicate a successful write
	RET				; return
	;

	;
	;	OPCODE_FAULT - Process an Opcode Reserved to Digital Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
OPCODE_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_OPCDEC,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	ADDRESS_FAULT - Process an Invalid Addressing Mode Fault
	;
	;		entered by branching
	;
	;		no parameters
	;
ADDRESS_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_RADRMOD,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition
	;
	;	OPERAND_FAULT - Processed a Reserved Operand Fault
	;
	;		entered by branching
	;	
	;		no parameters
	;
OPERAND_FAULT:				; entrance
	BSBW	FAULT_RESET		; reinitialize registers and clear TP
	MOVAB	SHORT_LOCAL(FP),SP	; shorten the frame
	MOVZWL	#SS$_ROPRAND,-(SP)	; push the condition code
	PUSHL	#1			; push the number of arguments
	BRW	SIGNAL_START		; signal the condition

	;	RESIGNAL - Resignal original exception
	;
	;		entered by branching
	;
	;		no parameters
	;
	;	This routine is branched to when the user's action routine
	;	returns to us with a failure status, indicating the desire
	;	to resignal the original exception.  First we call
	;	FAULT_RESET to undo any register modifications caused by
	;	operand processing.  Note that we assume that the user has
	;	NOT modified any register or the PSL before requesting
	;	a resignal.  We then reset our SP to point to the original
	;	signal array (it's probably already there anyway) and 
	;	decrement the parameter count by 2, as needed by
	;	SIGNAL_START.  We then branch to SIGNAL_START.
	;

RESIGNAL:
	BSBB	FAULT_RESET			; Undo register modifications
	MOVL	SAVE_SIGARGS(FP),SP		; Point SP to signal args
	SUBL2	#2,(SP)				; Adjust argument count.
	BISB2	#M_RESIGNAL,FLAGS(FP)		; Indicate a resignal
	BRB	SIGNAL_START			; Do the signal

	;	USER_SIGNAL - Signal user-supplied exception
	;
	;	Calling sequence:
	;
	;	  CALL USER_SIGNAL (fault_flag.rl.r, context.rl.r,
	;			    signal_args.rl.ra)
	;
	;	Parameters:

		   fault_flag = 4	; The address of a longword whose
					; low bit, if set, indicates that
					; this exception is to be signalled
					; as a fault.  If the low bit is
					; clear, the exception is to be
					; signalled as a trap.
					;
					; If a fault, all register 
					; modifications which resulted from
					; operand processing are rolled back.
					; If a trap, the current contents
					; of the registers are used.  The
					; current state of the PSL is used in
					; either case.

		  context = 8		; The longword passed
					; to the user action routine as
					; the signal routine's context.
					; This longword contains the FP of
					; the appropriate invocation of
					; LIB$DECODE_FAULT.

		signal_args = 12	; The address of an array of longwords
					; specifying the signal arguments of
					; the exception to be signalled.
					; The first longword contains the
					; count of following longwords.  
					; Unlike the signal arguments list
					; passed to a condition handler, this
					; array does not contain the PC and
					; PSL, and the count reflects their
					; absence.
;
;	This routine is called from the user action routine when it wishes
;	to signal an exception.  The address of this routine's entry mask
;	was passed to the user action routine as an argument.
;
;	USER_SIGNAL unwinds the stack frames back to the frame of the
;	associated invocation of LIB$DECODE_FAULT, whose FP was specified
;	as "context".  This unwinding is not a full unwind, but only
;	calls associated handlers with the SS$_UNWIND condition.
;
;	The user-specified signal args are then pushed on the stack and
;	control branches to SIGNAL_START.  Depending on whether the
;	"fault_flag" parameter is set, FAULT_RESET may or may not be called.
;

USER_SIGNAL:
	.WORD	^M<R2,R3,R4>
	MOVL	context(AP),R3		; Get context FP value
	MOVL	@fault_flag(AP),R4	; Get fault indicator
	MOVL	signal_args(AP),R0	; Get address of signal args
	MOVL	(R0),R1			; Get argument count
	MOVAL	4(R0)[R1],R0		; Position R0 past signal args
1$:	PUSHL	-(R0)			; Push a signal argument
	SOBGEQ	R1,1$			; Loop till all pushed

;+
; Call handlers between our caller's frame and "context" frame with SS$_UNWIND
;-
	MOVL	SF$L_SAVE_FP(FP),R2	; Get caller's frame
2$:	TSTL	(R2)			; Does this frame have a handler?
	BEQL	3$			; Skip if not
	CLRQ	-(SP)			; Construct mechanism list
	CLRL	-(SP)			; Depth=0
	PUSHL	R2			; Establisher's FP
	PUSHL	#4			; n of mechanism args
	MOVZWL	#SS$_UNWIND,-(SP)	; Push unwind condition code
	PUSHL	#1			; n of signal args
	PUSHAB	8(SP)			; Address of mechanism args
	PUSHAB	4(SP)			; Address of signal args
	MOVL	(R2),R1			; Handler address in R1
	JSB	G^SYS$CALL_HANDL	; Call the handler
	ADDL2	#36,SP			; Reset SP
3$:	MOVL	SF$L_SAVE_FP(R2),R2	; Get next frame
	CMPL	R2,R3			; Is this our frame?
	BNEQ	2$			; Loop if not

;+
; R2 now has the desired FP.  Switch frames.  SP is pointing to the signal
; args.
;-

	MOVL	R2,FP			; Switch frames
	BLBC	R4,4$			; Skip if not fault
	BSBB	FAULT_RESET		; Roll back register modifications
4$:	BRB	SIGNAL_START		; Go do the signal
	

	;
	;	FAULT_RESET - Perform Reinitialization Operations for a Fault
	;
	;		entered by subroutine branching
	;	
	;		no parameters
	;
	;	Discussion
	;
	;	    This routine subtracts the sign-extended value of each
	;	of the register modification words from the corresponding
	;	emulated register and clears the trace pending bit in the
	;	PSL.
	;
	;	    If FPD is set in the PSL, only  the PC is rolled
	;	back.
	;
FAULT_RESET:				; entrance
	CLRL	R0			; clear the index
	BBC	#PSL$V_FPD,PSL(FP),1$	; skip if FPD clear
	MOVL	#15,R0			; only roll back PC
1$:	CVTWL	REGMOD_R0(FP)[R0],R1	; R1 = modifications to R[R0]
	SUBL2	R1,REG_R0(FP)[R0]	; unmodify the register
	AOBLEQ	#15,R0,1$		; more registers to reset - loop
	BBCC	#PSL$V_TP,PSL(FP),2$	; clear the trace pending bit
2$:	RSB				; return
	;

	;
	;	SIGNAL_START - Build the Parameter Blocks for SIGNAL
	;
	;		entered by branching
	;
	;		parameters:	(SP) = Truncated Signal Array Size (M)
	;				4(SP) = Condition Code
	;				8(SP) = First Signal Argument
	;				  .
	;				  .
	;				  .
	;				4*<M-1>(SP) = Last Signal Argument
	;
	;	Discussion
	;
	;	    This routine builds the signal and mechanism arrays
	;	for a condition generated by LIB$DECODE_FAULT. It is entered
	;	with the signal array for the condition except for the 
	;	PC and PSL pair pushed onto the stack (with the
	;	pushed array length correspondingly shortened). The signal
	;	array, mechanism array, and the handler parameter block
	;	are then constructed on the user's emulated stack. The routine
	;	then removes LIB$DECODE_FAULT's frame from the stack and enters
	;	the signal dispatching loop at SIGNAL.
	;
	;	Notes:	1. The precise format of the information pushed onto
	;		   the user's stack is given in the description of
	;		   SIGNAL below.
	;
	;		2. The method of getting out of LIB$DECODE_FAULT used in
	;		   this routine is essentially the same as that used
	;		   in NORMAL_EXIT.
	;
SIGNAL_START:				; entrance
	MOVL	(SP)+,R7		; R7 = number of signal parameters
	ASHL	#2,R7,R8		; R8 = size of the signal parameters
	ADDL3	#52,R8,R0		; R0 = size of signal information
	BSBW	TEST_FRAME		; make sure we have room for it
	MOVL	REG_SP(FP),R6		; R6 = user's stack pointer
	MOVQ	REG_PC(FP),-(R6)	; push the PC, PSL pair
	SUBL2	R8,R6			; make room for the signal parameters
	MOVC3	R8,(SP),(R6)		; push the signal parameters
	ADDL3	#2,R7,-(R6)		; push the signal array length
	MOVL	#1,-(R6)		; push code for SIGNAL (vs. STOP)
	MOVQ	REG_R0(FP),-(R6)	; push user's R0 and R1
	BBS	#V_RESIGNAL,FLAGS(FP),1$ ; Is this a resignal?
	MNEGL	#3,-(R6)		; No, push -3 (depth number)
	BRB	2$			; Skip
1$:	MOVL	SAVE_DEPTH(FP),-(R6)	; Resignal, use saved handler depth
2$:	MOVL	REG_FP(FP),-(R6)	; push the user's FP
	MOVL	#4,-(R6)		; push the mechanism array length
	MOVL	R6,-(R6)		; push the mechanism array location
	MOVAB	28(R6),-(R6)		; push the signal array location
	MOVL	#2,-(R6)		; push the handler parameter count
	MOVQ	REG_AP(FP),SAVE_AP(FP)	; put the user's PC, PSL pair back
	MOVAB	B^SIGNAL,SAVE_PC(FP)	; store the return point
	MOVAB	FRAME_END+4(FP),R0	; R0 = location of end of frame
	SUBL2	R0,R6			; R6 = distance of user SP from it
	EXTZV	#0,#2,R6,R1		; R1 = stack alignment
	INSV	R1,#MASK_ALIGN,#2,SAVE_MASK(FP) ; store it into the frame
	ADDL2	R1,R0			; compute the parameter area location
	ASHL	#-2,R6,-4(R0)		; store the parameter count
	RET				; return (to SIGNAL)
	;

	;
	;	SIGNAL - Signal the Condition
	;
	;		entered by branching
	;
	;		parameters:	( Described in Note 3 )
	;	
	;	Discussion
	;
	;		   Following is a description of the information which
	;		   is assumed to be pushed onto the stack when the
	;		   routine SIGNAL is entered. The values are all
	;		   longwords.
	;
	;		   Handler Parameter Block:
	;
	;			(SP)	2 (handler parameter block length)
	;			4(SP)	signal array location
	;			8(SP)	mechanism array location
	;
	;		   Mechanism Array:
	;
	;			12(SP)	4 (mechanism array length)
	;			16(SP)  user's FP (establisher frame)
	;			20(SP)	-3 (establisher depth)
	;			24(SP)	user's R0
	;			28(SP)	user's R1
	;
	;		   Information Not Part of any Array:
	;
	;			32(SP)	1 (code for SIGNAL)
	;
	;		   Signal Array:
	;
	;			36(SP)	signal array length M
	;			40(SP)	condition code
	;			44(SP)	first signal argument
	;			  .
	;			  .
	;			  .
	;			<4*M>+28(SP) last signal argument
	;			<4*M>+32(SP) user's PC
	;			<4*M>+36(SP) user's PSL
	;
	;		   The user's stack pointer should coincide with the
	;		   address <4*M>+40(SP).
	;
	;	We now jump to the VMS entry point to look for a handler.
	;+

SIGNAL: 				
	JMP	G^SYS$SRCHANDLER

	.END				; End of module LIB$DECODE_FAULT
