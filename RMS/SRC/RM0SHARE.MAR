	$BEGIN	RM0SHARE,001,F$RMSOPEN23,<SHARING ROUTINES>
	.SBTTL	COPYRIGHT

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;


	.SBTTL	DECLARATIONS

;++
;
;	Facility:	RMS32
;
;	Abstract:
;
;		this module is comprised of subroutines which are used by the
;		file sharing logic of rms.  these utilities were written to
;		facilitate the processing of functions which are called many
;		times or from many locations.  the functions include the
;		acquisition and release of resources and buffers.
;
; Environment:
; 
;	star processor running starlet exec.
;
; Author: r a newell,		creation date: 9-OCT-1978
;
; Modified By:
;
;	V03-001	CDS0004		C Saether		 1-Apr-1982
;		Put back the per stream synchronization routines and
;		set the INUSE flag when init'ing FRB.
;
;	V02-024	CDS0003		C Saether		14-Dec-1981
;		Change the name of a psect.
;
;	V02-023	KPL42255	P Lieberwirth		25-Nov-1981
;		The code confused the meaning of the PCB$V_SSRWAIT bit by
;		reversing the polarity.  Fix this problem and resource
;		wait mode should be set on AST allocation calls that fail
;		due to no non-paged pool.
;
;	V02-022	KPL0011		P Lieberwirth		11-Nov-1981
;		Formalize FWA use started in v02-020 by using a real field.
;
;	V02-021	CDS0002		C Saether		 9-Nov-1981
;		Don't set the frb$v_inuse flag when init'ing frb.
;		Fix broken branch.
;
;	V02-020	KPL0010		Peter Lieberwirth	22-Oct-1981
;		Add RMS facility code to the shared file name passed
;		to the lock manager.  Use better names for different
;		parts of shared file resource name in SFSB.
;
;	V02-019	KPL0009		P Lieberwirth		 7-Oct-1981
;		The last scheme for naming the shared file didn't work, so
;		fix it by looking for the real device and unit in the FWA
;		WILD field.  This info is stuffed there by PRFLNM.
;
;	V02-018	CDS0001		C Saether		20-Aug-1981
;		Noop the per process stream synchronization routines.
;		Remove reference RM$ALLOC_BCB.
;
;	V02-017	KPL0008		Peter Lieberwirth	19-Aug-1981
;		Fix a bug mapping ENQ errors in RM$INIT_SFSB.
;
;	V02-016 KPL0007		Peter Lieberwirth	27-Apr-1981
;		Add routine RM$INIT_SFSB, to allocate and initialize
;		the SFSB.
;
;	V02-015	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to CTL$GL_PCB instead.
;
;	V02-014	REFORMAT	P S Knibbe	24-Jul-1980	
;
;	V013	CDS0021		C Saether	29-FEB-1980	15:30
;		do not allow ufo open when opening file shared.
;
;	V012	CDS0020		C Saether	25-JUL-1979	15:00
;		remove sharing check code and put in rm0access
;		to implement sharing for fix length seq files
;
;	V011	RAN0017		R A Newell	16-MAR-1979	16:00
;		may need to que_stall on sfd when no frb - so use internal
;
;	V010	RAN0016		R A Newell	12-MAR-1979	 8:50
;		if no permanent frb error, can't release sifab and must own
;		it with the internal (not the temporary) frb.
;
;	V009	CDS0003		C D Saether	26-FEB-1979	18:20
;		fix loop in take_ppq
;
;	V008	RAN0008		R A Newell	23-FEB-1979	 9:23
;		comment changes to reflect current implementation
;
;	V007	CDS0002		C D Saether	22-FEB-1979	11:40
;		take sifab out of sfl if access count 0 when found,
;		fix yesterday's fix
;
;	V006	CDS0001		C D Saether	21-FEB-1979	13:45
;		clear event flag in kernel wait before waiting on it
;
;	V005	LFL0001		L F Laverdure	16-FEB-1979	19:25
;		have que_stall save r0,r1
;
;	V004	RAN0007		R A Newell	12-FEB-1978	09:30
;		further changes for last chance processing
;
;	V003	EHM0001		E H Marison	8-FEB-1979	16:58
;		modifications to run all insque/remque operations
;		on the sfd and sifab at kernel level ast disabled.
;
;	V002	RAN0007		R A Newell	7-FEB-1979	09:30
;		fixes for last chance to handle kernel mode ast
;
; Revision History:
;
;	C Saether	16-JAN-1979
;	eliminate references to fwa$l_fcbaddr
;
; 01	-
;--

;
;	Include Files:
;


;
;	Macros:
;

	$IMPDEF				; impure area definitions
	$IPLDEF				; priority level definitions
	$PSLDEF				; program state longword defs
	$PRIDEF				;
	$PCBDEF				; process control block defs
	$IMPDEF				; impure area definitions
	$CCBDEF				; channel control block defs
	$ACBDEF				; ast control block definitions
	$WCBDEF				; window control block definitions
	$FWADEF				; file work area definitions
	$IRBDEF				; irab data definitions
	$CMKRNLDEF			; change mode to kernel arguments
	$IFBDEF				; ifab data definitions
	$FABDEF				; fab data definitions
	$SFDDEF				; shared file data definitions
	$SIFBDEF			; shared ifab definitions
	$SFSBDEF			; shared file synchronization block
	$FRBDEF				; file resource block definitions
	$RMSDEF				; rms error codes
	$ENQDEF				; enq service definitions
	$LCKDEF				; enq lock definitions
	$FIBDEF				; file information block definitions

;
;	Equated Symbols:
;

;
;	Own Storage:
;

HALF_SEC:
	.LONG	-5000000		;
	.LONG	-1			; time to wait on insque interlock


	.SBTTL	RM$OPEN_SHARED - OPEN SHARED FILE ROUTINE

;++
;
; RM$OPEN_SHARE - Open shared file
;
;	this routine is called whenever a file on which sharing is allowed is to
;	be opened.
;	the sfd is first taken, and then the shared file list (sfl) is scanned
;	to determine whether the shared file is already open and exists in s0
;	space.  if it is already open, an frb is allocated for the current process
;	and the pointers to both the frb and the sifab are updated.  if the file
;	is not open, a sifab is allocated, as well as an frb for the current
;	process and the sifab is filled in with any common data from the opener's
;	ifab.
;
;	Input Parameters:
;
;		r8 - address of fab
;		r9 - address of ifab
;		r10 - address of fwa
;		r11 - address of impure area
;
;	Output Parameters:
;
;		r0 - status
;		r3 - address of frb
;		r1,r2,r4,r5,ap - destroyed
;
;	Side Effects:
;
;	if the file was not already open and is shared, shared structures have
;	been allocated out of the system paged pool.
;	if the file was open, the accessor counts have been incremented.  these
;	counts are incremented in a kernel mode routine with kernel mode ast's
;	disabled.  this is to maintain consistency in the access counts even with
;	the possibility of a kernel mode ast (delete process) happening at any
;	time.
;
;--

RM$OPEN_SHARED::
5$:	TSTL	@#RMS$GL_SFDBASE	; is sharing enabled?
	BNEQ	8$			; branch if it is
	RMSERR	SNE			; give 'sharing not enabled' error
	RSB
8$:
	BBC	#FAB$V_UFO,-
		FAB$L_FOP(R8), 9$	; ok if ufo not spec'd
	RMSERR	SHR			; else this is an error
	RSB				; return to whence we came
9$:
	BSBW	RM$GETCCB		; get the ccb
	MOVL	CCB$L_WIND(R1),R1	; get wcb address
	PUSHL	WCB$L_FCB(R1)		; save fcb address
	BSBW	RM$TAKE_SFD		; get ownership of sfd
	POPR	#^M<R1>			; get fcb address into r1
	BLBC	R0,XIT			; branch on failure
	PUSHL	R3			; save temp frb address

;
;	scan shared file list to see if there is already an entry for this file
;

	MOVAB	SFD$L_SHRF_LNK(R2),AP	; set address of sfl link
	BRB	15$
10$:	MOVAL	SIFB$L_SFL_LNK(R5),AP	; save previous link address
15$:	MOVL	(AP),R5			; look at next sifab
	BEQL	NOFIND			; zero link..file not found
	CMPL	R1,SIFB$L_FCB_ADDR(R5)	; is this the file?
	BLSSU	10$			; no, get next sifab
	BGTRU	NOFIND			; fcbaddr is greater...not found

;
;	have found the shared file, already open by another sharer.
;	increment the access counts, after making sure non-0
;

	TSTW	SIFB$W_ACC_CNT (R5)	; make sure access count non-0
	BNEQ	25$			; ok continue
	MOVL	SIFB$L_SFL_LNK(R5),(AP)	; take this one out of chain
	BRB	15$			; continue scan
25$:
	BSBW	INC_ACC_CNT		; inc access counts & release sfd
	MOVL	R5,R0			; copy sifab address
	PUSHL	R5			; save r5
	MOVL	R3,R5			; set up
	BSBW	RM$TAKE_SIFAB1		; go take sifab
	POPR	#^M<R5>			; restore sifab address

;++
;
;  allocate a permanent frb, take the sifab with it, and return our
;  temporary frb page to the free page list.  
;
;--

	BSBW	ALLOC_FRB		; get permanent frb
	BLBC	R0,NOPERMFRB		; branch on failure
	POPR	#^M<R4>			; restore temp frb addr
	INSQUE	(R3),(R4)		; insert perm. frb
	REMQUE	(R4),R4			; and remove temp frb
SETFRB:	MOVL	R3,IFB$L_FRB_PTR(R9)	; set up frb ptr in ifab
	PUSHR	#^M<R3,R5>		; save frb addr & sifab addr
	BSBW	RET_TEMP_FRB		; and return it
	POPR	#^M<R3,R5>		; store frb addr & sifab addr
XIT:	RSB				; return to caller


;++
;
;  handle errors
;
;  failed to allocate a permanent frb
;  release the shared ifab, get ownership of the sfd and go deaccess the
;  the file.  eventually, release the sfd and return status.
;
;--

NOPERMFRB:
	$PSECT_BR	L$RMS0
	PUSHL	R0			; save the status code
	MOVL	R5,R0			; sifab address
	MOVL	4(SP),R5		; get temp frb address
	MOVL	FRB$L_PID(R5),-
		FRB$L_PID+SIFB$L_TEMP_FRB(R0); store pid
	INSQUE	SIFB$L_TEMP_FRB(R0),-
		SIFB$L_FRB_FLNK(R0)	; take with internal
	REMQUE	(R5),R3			; remove temporary frb
	MOVL	R0,R5			; put sifab addr into r5
	BSBW	RM$TAKE_SFD1		; retake the sfd
	MOVL	R5,R6			; sifab addr to right reg.
	BSBW	RM$DEACSHARED		; deaccess the shared file
	MOVL	4(SP),R4		; restore temp frb addr
	BSBW	RM$RET_TEMP_FRB		; and return it to pool
	BSBW	RM$RLS_SFD		; release the sfd
	POPR	#^M<R0,R1>		; restore status & clean stack
	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
	RSB
	$PSECT_RESTORE


;++
;
;	file not already open. must go allocate a sifab and frb.
;	ap contains address of the previous sfl link which
;	must be updated with the new sifab address.
;
;--

NOFIND:	PUSHR	#^M<R1,AP>		; save fcb addr and sfd flink
	SSB	#IMP$V_TEMP1,(R11)	; set s0 request flag
	BSBW	RM$GET1PAG		; get a page
	BLBS	R0,5$			; branch if ok
	BRW	NOSIFB			; branch on error
5$:	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
	MOVL	R3,R1			; set up free space header
	MOVAB	8(R3),(R3)+		; set up forward link of space hdr
	MOVAB	4(R3),(R3)+		; set up backward link of space hdr
	MOVL	R1,(R3)+		; set up forward link of hole
	MOVL	R1,(R3)+		; set up backward link of hole
	MOVL	#504,(R3)		; set up size of hole
	MOVZBL	#SIFB$C_BLN,R2		; size of sifab to allocate
	BSBW	RM$GETS0SPC		; go allocate the sifab
	MOVL	R5,SIFB$L_SFL_LNK(R1)	; set link to next sifab
	MOVL	R1,R5			;

;
;  initialize sifab, linking it into the shared file list,
;  then increment the access counts, release the sfd, and return
;

	ASSUME	SIFB$B_BLN EQ SIFB$B_BID+1
	MOVW	#SIFB$C_BID+<SIFB$C_BLN@6>,-
		SIFB$B_BID(R5)		; set bid and bln
	POPL	SIFB$L_FCB_ADDR(R5)	; get fcb addr from stack
	MOVAL	SIFB$L_FRB_FLNK(R5),-
		SIFB$L_FRB_FLNK(R5)	; initialize frb q
	MOVAL	SIFB$L_FRB_FLNK(R5),-
		SIFB$L_FRB_BLNK(R5)	; initialize frb q

	ASSUME	SIFB$L_EBK EQ SIFB$L_HBK+4
	ASSUME	IFB$L_EBK EQ IFB$L_HBK+4

	MOVQ	IFB$L_HBK(R9),-
		SIFB$L_HBK(R5)		; set hbk and ebk
	MOVB	FAB$B_SHR(R8),-
		SIFB$B_SHR(R5)		; set sharing bits in sifb
	MOVL	@#CTL$GL_PCB,R0		; get pcb addr
	MOVL	PCB$L_PID(R0),-
		SIFB$L_PID(R5)		; store pid of owner into sifab
	BSBW	ALLOC_FRB		; allocate permanent frb
	INSQUE	(R3),SIFB$L_FRB_FLNK(R5); take sifab with permanet frb
	MOVL	R5,-
		SIFB$L_TEMP_FRB+FRB$L_SIFAB_PTR(R5); sifb adr to internal frb
	POPR	#^M<R0,R4>		; get sfd flnk and temp frb addr
	MOVL	R5,FRB$L_SIFAB_PTR(R4)	; point to sifab from temp frb
					;  so last_chance can find it
	MOVL	R5,(R0)			; link sifab into sfl list
	INCW	SIFB$W_ACC_CNT(R5)	; increment access count
	BBC	#IFB$V_WRTACC,(R9),20$	; branch if not write accessed
	INCW	SIFB$W_WACC_CNT(R5)	; increment write access count
20$:	BSBW	RM$RLS_SFD		; release the sfd
	BRW	SETFRB			; go allocate frb


;++
;
;  subroutine to increment the access counts, point to the sifab from
;  the temporary frb, and release the sfd
;
;	r3 - temp frb address
;	r5 - sifab address
;	r9 - ifab address
;		assumes sfd held by sfd frb
;	r0,r1,r3 destroyed
;
;--

INC_ACC_CNT:
	PUSHR	#^M<R3,R5,R9>		; tmp frb, sifab, ifab addrs
	PUSHL	#3			; number of parameters
	ASSUME	CMKRNL$_NARGS EQ 2
	ASSUME	CMKRNL$_ARGLST EQ 8
	$CMKRNL_S	INC_ACCS_CNTS,(SP); increment access counts
	ADDL2	#16,SP			; pop stack
20$:	BRW	RM$RLS_SFD		; release the sfd and return

;
;	do step together
;

INC_ACCS_CNTS:
	.WORD	^M<R2>			; entry mask
	MOVQ	8(AP),R1		; set up parameters
	MOVL	4(AP),R0		; get temp frb addr
	SETIPL	#IPL$_ASTDEL		; disable kernel ast's
	INCW	SIFB$W_ACC_CNT(R1)	; increment accessor count
	BEQL	ACC_CNT_BUG
	BBC	#IFB$V_WRTACC,(R2),20$	; is it a write accessor?
	INCW	SIFB$W_WACC_CNT(R1)	; yes, increment that count also
20$:	MOVL	R1,FRB$L_SIFAB_PTR(R0)	; point to sifab from frb
	SETIPL	#0			; re-enable ast's
	RET				; return

;

ACC_CNT_BUG:
	RMSPBUG	FTL$_ACCNTOVFLO		; access count overflow

;++
;
;   handle failure to get sifab page
;
;--

NOSIFB:	$PSECT_BR	L$RMS0		;
	POPR	#^M<R0,R1,R4>		; clean up stack
	CLRL	IFB$L_FRB_PTR(R9)	; say no temp frb
	BSBW	RM$RET_TEMP_FRB		; return the temporary frb
	BSBW	RM$RLS_SFD		; go release sfd
	RMSERR	SPE			; give 'pagecount exceeded' error
	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
	RSB
	$PSECT_RESTORE


;++
;
;  rm$upd_sifb_eof subroutine to update the sifab ebk field from the ifab
;  if need be.
;
;  input:
;
;	r9	ifab address
;
;  output:
;
;	r0	sifab address
;
;--

RM$UPD_SIFB_EOF::
	MOVL	IFB$L_FRB_PTR(R9),R0	; get frb address
	BEQL	10$			; branch if zero (not shared)
	MOVL	FRB$L_SIFAB_PTR(R0),R0	; get sifab address
	MOVL	IFB$L_EBK(R9),-
		SIFB$L_EBK(R0)		; set sifab ebk from ifab
10$:	RSB

	.SBTTL	RM$TAKE_SFD - ROUTINE TO GET OWNERSHIP OF SFD

;++
;
; RM$TAKE_SFD - Get ownership of SFD
;
;	this routine is called whenever ownership of the sfd is required by the
;	file sharing logic.  the normal functions requiring sfd ownership include
;	opening and closing of shared files, as additions and deletions of shared
;	ifab's may be required at these times.
;	to acquire the sfd, a temporary frb is allocated from the system paged
;	pool, and it is then enqueued into the resource queue of the sfd.  when
;	this queue entry reaches the top of the queue, it then, by definition,
;	owns the sfd resource.  if we are not at the head of the queue initially,
;	we stall.  we then are activated by the process which finally brings us
;	to the head of the queue.  at this point, the sfd's temporary frb
;	is used to replace the temporary frb in the resource queue.
;
;	because of the broken insque instruction and the possibility of receiving
;	a kernel mode ast at any moment due to a delete process function, we must
;	interlock the insque instruction ourselves and this procedure must be
;	done in kernel mode with ast's disabled.  (very messy).  what actually
;	is done is a bit is set when a process is performing an insque and
;	checking the queue state afterwards; if another process wants to insque
;	at the same time, it will detect the set bit and will go stall for one-
;	half second and will then attempt to insque, again checking the bit.
;	this procedure must be done at kernel mode with ast's disabled because
;	if any process receives a kernel mode ast while some other process is
;	doing the insque, the bit will be set, and the last chance routine will
;	not know whether or not the bit was set by the process which is going
;	away.  therefore, the whole procedure must be done atomically.
;
; Calling Sequence:
;
;		bsbw	rm$take_sfd
;
; Alternate Entry:
;
;		bsbw	rm$take_sfd1		for frb already allocated
;
; Input Parameters:
;
;		r9 - ifab address
;		r3 - frb address if entry at rm$take_sfd1
;
; Output Parameters:
;
;		r3 - frb address
;		r2 - sfd address
;		r0 - status code
;		r1, ap destroyed
;		ownership of the sfd via the sfd internal frb
;
;--

RM$TAKE_SFD::
	BSBW	ALLOC_TEMP_FRB		; get a temporary frb
	BLBC	R0,XIT1			; branch on failure
RM$TAKE_SFD1::
	MOVL	R9,FRB$L_ASTPRM(R3)	; move ifab/irab addr to frb
	MOVL	@#RMS$GL_SFDBASE,R2	; get address of sfd
	PUSHR	#^M<R2,R3>		; push sfd and frb addr
	PUSHL	#2			; push arg count
	ASSUME	CMKRNL$_NARGS EQ 2
	ASSUME	CMKRNL$_ARGLST EQ 8
	$CMKRNL_S	TAKE_SFD_1,(SP)	; call kernel routine
	ADDL2	#12,SP			; pop stack
	BLBS	R0,10$			; branch if insert done
	MOVL	R3,R0			; get frb in right register
	BSBW	QUE_STALL_SFD		; go stall
	BRB	RM$TAKE_SFD1		; try it again
10$:	BBC	#1,R0,GOT_IT		; branch if queue was empty
	BBS	#FRB$V_KRNLMODE,FRB$B_FLAGS(R3),KRNL_WAIT1; branch if kernel mode
	PUSHR	#^M<R2,R3>		; save registers
	BSBW	RM$STALL_SIFAB		; stall until at head of queue
	POPR	#^M<R2,R3>		; restore registers
	BSBW	RM$STALL_SETEFN		; set event flag

;
;	free up temporary frb by using sfd frb to hold our place
;

GOT_IT:	MOVL	FRB$L_PID(R3),SFD$L_PID(R2); store pid of owner into sfd
	INSQUE	SFD$L_TEMP_FRB(R2),(R3)	; insert sfd frb
	REMQUE	(R3),R3			; remove temporary frb
	RMSSUC				; indicate success
XIT1:	RSB				; return to caller
KRNL_WAIT1:
	BSBW	KERNEL_WAIT		; branch to kernel wait
	CMPL	SFD$L_RQ_FLNK(R2),R3	; at head of queue?
	BEQL	GOT_IT			; eql yep
	BRB	KRNL_WAIT1		; wait again



;++
;
; queue into sfd resource queue
;
;	Input Parameters:
;	      4(sp)=sfd base addr
;	      8(sp)=frb addr
;
;	calling statement:
;	      $cmkrnl take_sfd_1,(sp)
;
;	Output Parameters:
;	r0 =
;		0 = queue is interlocked (ie must stall)
;		1 = frb insque'ed and queue was empty (ie now own resouce)
;		3 = frb insque'ed and queue was not empty
;
;
;  because of a bug in the insque and remque instruction....the following
;  code is necessary to interlock it while a test is done to determine
;  whether the queue was empty or not.
;
;	as of vms v1.5 the queue interlock bit is being used in the
;	last chance rundown code to allow searching of the queue.
;	when the instructions are fixed the interlock bit should go away
;	and last chance will have to search the queue by always checking
;	the frb's forward and backward links for consistency and remque
;	if the frb is truly in the queue.
;
;__

TAKE_SFD_1:
	.WORD	^M<R2,R3>
	MOVQ	4(AP),R2		; get sfd and frb addresses
	SETIPL	#IPL$_ASTDEL		; disable kernel ast
	CLRL	R0			; assume interlocked
	BBSS	#SFD$V_INSQUEFLG,-
		SFD$B_FLGS(R2),20$	; branch if interlocked
	INSQUE	(R3),@SFD$L_RQ_BLNK(R2)	; insert at tail of queue
	MOVL	#3,R0			; assume that queue was not empty
	CMPL	(R3),4(R3)		; compare links
	BNEQ	10$			; branch if not empty
	MOVL	#1,R0			; note queue was empty
10$:	CSB	#SFD$V_INSQUEFLG,-
		SFD$B_FLGS(R2)		; clear queue interlock bit
20$:	SETIPL	#0			; enable kernel ast
	RET				; and return


;++
;
;  subroutine to allocate a temporary frb
;
;  input: r9 - ifab address
;
;  output: r0 - status code
;	   r3 - frb address
;	   r4 - destroyed
;
;--

ALLOC_TEMP_FRB:
	SSB	#IMP$V_TEMP1,(R11)	; set s0 request flag
	MOVL	#512,R2			; set size to allocate
	BSBW	RM$GET1PAG		; get temporary frb
	BLBC	R0,ERR			; branch if didn't get temp frb
	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
	MOVL	@#CTL$GL_PCB,R4		; get pcb address
	MOVL	PCB$L_PID(R4),-
		FRB$L_PID(R3)		; set pid into frb
	MOVAL	RM$STALLAST,-
		FRB$L_ASTADDR(R3)	; set ast addr into frb
	CLRB	FRB$B_FLAGS(R3)		; clear frb flags
	SSB	#FRB$V_TEMP,-
		FRB$B_FLAGS(R3)		; set bit saying temp frb addr
	CLRL	FRB$L_SIFAB_PTR(R3)	; clear sifab ptr in temp frb
	MOVL	R3,IFB$L_FRB_PTR(R9)	; set up temp frb addr in ifb
	RSB

;

ERR:	RMSERR	SPE			; sharing pagecount exceeded
	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
	RSB

	.SBTTL	RET_TEMP_FRB - ROUTINE TO RETURN TEMPORARY FRB

;++
;
; RET_TEMP_FRB - Return temporary FRB
;
;	this routine is called when a temporary frb is no longer required.  the
;	page on which it exists is returned to the free page list whose header
;	is on the initial sfd page.
;	these pages, once allocated from the system paged pool, are never
;	returned to the system, but are put on rms sfd free page list for future
;	use.
;
;	Input Parameters:
;
;		r9 - ifab address
;		r4 - temporary frb address
;
;	Output Parameters:
;
;		r0-r5 destroyed
;
;--

RM$RET_TEMP_FRB::
RET_TEMP_FRB::
	SSB	#IMP$V_TEMP1,(R11)	; set s0 request flag
	MOVL	#512,8(R4)		; set up returning size
	BSBW	RM$RET1PAG		; return the page
	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
RETURN1:
	RSB				; return to caller


	.SBTTL	RM$RLS_SFD - RELEASE OWNERSHIP OF SFD

;++
;
; RM$RLS_SFD  - Release ownership of SFD
;
;	this routine releases ownership of the sfd resource.  ownership of the
;	sfd is required typically during opening and closing of shared files.
;	this is because additions and deletions of shared ifab's may be required.
;	this routine removes the frb from the sfd resource queue and, if another
;	process is waiting in the queue, activates that process by calling
;	rm$declare_ast which enqueues a cross-process ast for that process.
;	this routine calls a subroutine which actually performs the above
;	functionality.  this is done in kernel mode with ast's disabled as this
;	must be done atomically.  this is done only because of the possibility
;	of a kernel mode ast (delete process) happening at any moment.
;
;	Calling sequence:
;
;		bsbw	rm$rls_sfd
;
;	Input Parameters:
;
;		r9 - ifab address
;		sfd owned by sfd internal frb
;
;	Output Parameters:
;
;		r0, r1, ap - destroyed
;
;--

RM$RLS_SFD::
	MOVL	@#RMS$GL_SFDBASE,R1	; get address of sfd
	PUSHL	R1			; put sfd addr on stack
	ADDL3	#SFD$L_TEMP_FRB,R1,-(SP); get sfd temp frb addr
					; and put on stack

;
;  see take_sfd_1 code for explanation of following remque interlock code.
;

	PUSHL	#2			; number of parameters

	ASSUME	CMKRNL$_NARGS EQ 2
	ASSUME	CMKRNL$_ARGLST EQ 8

	$CMKRNL_S	RLS_SFD_2,(SP)	;
	ADDL2	#12,SP			; adjust stack
	BLBS	R0,30$			; branch if release is done
	BSBW	QUE_STALL_SFD		; go stall for interlock
	BRB	RM$RLS_SFD		; go back and try again
30$:	RSB				; return


;
; *** kernel level routine ***
;
;	see take_sfd_1 for explanation of following remque interlock code.
;

RLS_SFD_2:
	.WORD	^M<R2,R3,R4,R5>		; entry mask
	MOVL	8(AP),R1		; restore r1 -- sfd addr
	SETIPL	#IPL$_ASTDEL		; disable kernel ast's
	CLRL	R0			; assume interlock problem
	BBSS	#SFD$V_INSQUEFLG,-
		SFD$B_FLGS(R1),30$	; branch if interloced
	MOVL	4(AP),R0		; restore r0 -- sfd temp frb
	REMQUE	(R0),R0			; remove frb from resource queue
	MOVAL	SFD$L_RQ_FLNK(R1),R0	; get address of forward link
	CMPL	(R0),R0			; is queue empty?
	CSB	#SFD$V_INSQUEFLG,-
		SFD$B_FLGS(R1)		; clear interlock
	BEQL	20$			; branch if queue was empty
	CLRL	8(AP)			; clear bcb arg to rm$decast routine
	MOVL	SFD$L_RQ_FLNK(R1),4(AP)	; get link to next frb in queue

;
; as arg to rm$decast routine
;

	BRW	RM$DECAST+2		; enqueue an ast for that process
20$:	RMSSUC				; note release done
30$:	SETIPL	#0			; re-enable kernel ast's
	RET				; return


	.SBTTL	ALLOC_FRB - FRB ALLOCATION ROUTINE

;++
;
; ALLOC_FRB - Allocate a FRB
;
;	this routine is called when a new frb is to allocated for an ifab.
;	the routine allocates the frb and gets an ast block for it.
;
;	Input Parameters:
;
;		r9 - ifab address
;		r5 - sifab address
;
;	implicit imputs:
;
;		caller must own sifab
;
;	Output Parameters:
;
;		r0 - status
;		r3 - frb address
;		ifb$l_frb_ptr - frb address
;		frb$l_sifab_ptr - sifab address
;		frb$v_inuse - set
;		frb$l_astprm - set
;		r1, r2, r4 destroyed
;
;--

ALLOC_FRB:
	MOVL	R5,R1			; copy sifab address (space hdr)
	MOVL	#FRB$C_BLN,R2		; set up length of frb to get
	BSBW	RM$GETS0SPC		; go allocate the frb
	BLBC	R0,30$			; branch if error
	ASSUME	FRB$M_INUSE EQ 1	;
	INCL	FRB$L_PPQ(R1)		; indicate frb in use
	MOVL	R5,FRB$L_SIFAB_PTR(R1)	; set up ptr in frb to sifab
	MOVL	R1,R3			; save frb address
	MOVL	@#CTL$GL_PCB,R1		; get pcb addr
	MOVL	PCB$L_PID(R1),FRB$L_PID(R3); set pid into frb
	MOVAL	RM$STALLAST,FRB$L_ASTADDR(R3); set ast addr into frb
	MOVL	R9,FRB$L_ASTPRM(R3)	; set up ast parameter in frb
	RSB				; return to caller
30$:	RMSERR	SPE			; give spe error
	CSB	#IMP$V_TEMP1,(R11)	; clear s0 request flag
	RSB				; return to caller

	.SBTTL	RM$RETURN_FRB - ROUTINE TO RETURN FRB TO PAGED POOL
	$NEWPSECT	F$RMSCLOSE23

;++
;
; RM$RETURN_FRB - Return FRB to paged pool
;
;	this routine merely returns the frb described by the address input in
;	r1 to the system paged pool.
;
;	Input Parameters:
;
;		r9 - address of ifab
;		r3 - address of frb
;
;	Output Parameters:
;
;		r0 through r5 destroyed
;
;--

RM$RETURN_FRB::
	MOVL	R3,R4			; save frb address
	MOVL	#FRB$C_BLN,R2		; set up size of returning space
	MOVL	FRB$L_SIFAB_PTR(R4),R3	; get address of page containing

;
; the free space header
;

	BRW	RM$RETS0SPC		; return the frb and return

	.SBTTL	RM$TAKE_PPQ - ROUTINE TO GET OWNERSHIP OF FRB
	$NEWPSECT	$RMSZ

;++
;
; RM$TAKE_PPQ - Get ownership of FRB
;
;	this routine is called to gain ownership of the frb before the process
;	can get ownership of the sifab.
;
;	Input Parameters:
;
;		r5  -  frb address
;		r9  -  irab/ifab address
;		r11 -  impure area address
;
;	Output Parameters:
;
;		r0-r3, ap  -  destroyed
;
;--

RM$TAKE_PPQ::
	BBSS	#FRB$V_INUSE,-
		FRB$L_PPQ(R5),-
		10$			; take frb, branch if in use
	RSB				; all set, leave

;
;	frb in use - see if anyone already is waiting for it
;

10$:	BICL3	#FRB$M_INUSE,-
		FRB$L_PPQ(R5),R0	; get waiter irab address
	BNEQ	30$			; branch if someone waiting
	BISL2	R9,FRB$L_PPQ(R5)	; declare stream 1st waiter
	BRB	40$			;

;
;	someone already waiting - put stream at end of list
;

20$:	MOVL	R1,R0			;

	ASSUME	IRB$L_BWB EQ IFB$L_BWB

30$:	MOVL	IRB$L_BWB(R0),R1	; get next waiter
	BNEQ	20$			; branch if more
	MOVL	R9,IRB$L_BWB(R0)	; insert this stream
40$:	CLRL	IRB$L_BWB(R9)		; note end of list
	BSBW	RM$STALL_SIFAB		; await frb
	RSB				; return to caller

	.SBTTL	RM$RLS_PPQ - ROUTINE TO RELEASE THE PPQ

;++
;
; RM$RLS_PPQ - Release the PPQ
;
;	this routine releases the ownership of the frb by releasing the ppq.
;
;	Input Parameters:
;
;		r5  - frb address
;
;	Output Parameters:
;
;		r0, r1, ap  -  destroyed
;
;--

RM$RLS_PPQ::
	BICL2	#FRB$M_INUSE,-
		FRB$L_PPQ(R5)		; release ownership
	BNEQ	10$			; branch if someone waiting
	RSB				; return to caller

;
;	another stream is waiting - send it an ast
;

10$:	MOVL	FRB$L_PPQ(R5),AP	; get ast param (irab) address
	BISL3	#FRB$M_INUSE,-
		IRB$L_BWB(AP),-
		FRB$L_PPQ(R5)		; bring up next stream,

;
; setting in use flag
;

	$DCLAST_S ASTADR=RM$STALLAST,-	; Wake up the next thread.
		ASTPRM=AP
	BLBC	R0, 20$			; Br if error.
	RSB				; Return.
20$:	BRW	ASTERR			; Bug if ast can't be declared.

	.SBTTL	RM$TAKE_SIFAB - ROUTINE TO GET OWNERSHIP OF SIFAB

;++
;
; RM$TAKE_SIFAB - Get ownership of SIFAB
;
;	this routine is called to acquire ownership of the sifab.  this is required
;	every time an rms service references the shared ifab.
;	the actually functionality is done in a subroutine which is run at
;	kernel mode with ast's disabled, due to the possibility of receiving a
;	kernel mode ast (delete process) at any moment.  this subroutine must be
;	done atomically.
;
;	alternate entry at rm$take_sifab1 with r0 = sifab address
;
;	Input Parameters:
;
;		r11 - address of impure area
;		r9 - ifab/irab address
;		r5 - address of frb
;
;	Output Parameters:
;
;		r0-r2, ap - destroyed
;
;--

RM$TAKE_SIFAB::
	MOVL	FRB$L_SIFAB_PTR(R5),R0	; get sifab address
RM$TAKE_SIFAB1::
	MOVL	R9,FRB$L_ASTPRM(R5)	; move ifab/irab addr to frb
	CMPL	SIFB$L_FRB_FLNK(R0),R5	; do we already own it?
					; possible from que_stall
	BEQL	RETURN			; yes, bypass insque

;
;  see explanation of interlock code for insque instruction in take_siab_1.
;

	PUSHR	#^M<R0,R5>		; push sifab and frb addr
	PUSHL	#2			; push arg count
	ASSUME	CMKRNL$_NARGS EQ 2
	ASSUME	CMKRNL$_ARGLST EQ 8
	$CMKRNL_S	TAKE_SIFAB_1,(SP); call kernel routine
	ADDL2	#12,SP			; pop stack
	BLBS	R0,20$			; branch if not interlocked
	BSBW	QUE_STALL		; go stall
	BRB	RM$TAKE_SIFAB		; go try again
20$:	BBC	#1,R0,RETURN		; branch if queue was empty
	BBS	#FRB$V_KRNLMODE,-
		FRB$B_FLAGS(R5),-
		KRNL_WAIT2		; branch if kernel mode
	PUSHL	R3			; save r3
	BSBW	RM$STALL_SIFAB		; stall until at head of queue
	POPL	R3			; restore r3
RETURN:	RSB				; return

;

KRNL_WAIT2:
	BSBB	KERNEL_WAIT		; go wait
	MOVL	FRB$L_SIFAB_PTR(R5),R0	; get sifab pointer
	CMPL	SIFB$L_FRB_FLNK(R0),R5	; did we get it?
	BNEQ	KRNL_WAIT2		; no back to sleep
	RSB				; all done
KERNEL_WAIT:
	$WAITFR_S	#IMP$C_IOREFN	; wait on ior event flag
	$CLREF_S	#IMP$C_IOREFN	; clear ef on return
	RSB				; return



;++
;
; queue into sifab resource queue
;
;	Input Parameters:
;	      4(sp)=sifab base addr
;	      8(sp)=frb addr
;
;	Calling sequence:
;	      $cmkrnl take_sifab_1,(sp)
;
;	Output Parameters:
;	r0 =
;		0 = queue is interlocked (ie must stall)
;		1 = frb insque'ed and queue was empty (ie now own resouce)
;		3 = frb insque'ed and queue was not empty
;
;
;  because of a bug in the insque and remque instruction....the following
;  code is necessary to interlock it while a test is done to determine
;  whether the queue was empty or not.
;
;	as of vms v1.5 the queue interlock bit is being used in the
;	last chance rundown code to allow searching of the queue.
;	when the instructions are fixed the interlock bit should go away
;	and last chance will have to search the queue by always checking
;	the frb's forward and backward links for consistency and remque
;	if the frb is truly in the queue.
;
;__

TAKE_SIFAB_1:
	.WORD	^M<R2,R3>
	MOVQ	4(AP),R2		; get sifab and frb addresses
	SETIPL	#IPL$_ASTDEL		; disable kernel ast
	CLRL	R0			; assume interlocked
	BBSS	#SIFB$V_INQUEFLG,-
		SIFB$B_FLGS(R2),20$	; branch if interlocked
	INSQUE	(R3),@SIFB$L_FRB_BLNK(R2); insert at tail of queue
	MOVL	#3,R0			; assume that queue was not empty
	CMPL	(R3),4(R3)		; compair links
	BNEQ	10$			; branch if not empty
	MOVL	#1,R0			; note queue was empty
10$:	CSB	#SIFB$V_INQUEFLG,-
		SIFB$B_FLGS(R2)		; clear queue interlock bit
20$:	SETIPL	#0			; enable kernel ast
	RET				; and return

	.SBTTL	RM$RLS_SIFAB - ROUTINE TO RELEASE THE SIFAB

;++
;
; RM$RLS_SIFAB - Release the SIFAB
;
;	this routine is called to release the shared ifab (sifab) which has been
;	owned by a particular process.  typically, this routine is called when
;	awaiting i/o completion or after an rms service has finished on
;	a shared file by a process.
;	the routine removes the current process's frb from the frb queue and,
;	if another process has enqueued for this sifab, activates that process
;	by calling another routine which schedules a cross-process ast.
;
;
;	Calling sequence:
;
;		bsbw	rm$rls_sifab
;		bsbw	rm$rls_sifab1 if r0 contains sifab addr on input
;
;	Input Parameters:
;
;		r5 - address of frb
;		r0 - address of sifab if entry at rm$rls_sifab1
;
;	Output Parameters:
;
;		r0, r1, ap - destroyed
;
;--

RM$RLS_SIFAB::
	MOVL	FRB$L_SIFAB_PTR(R5),R0	; get sifab address
	BEQL	LEAVE			; branch if none
RM$RLS_SIFAB1::
	MOVAL	SIFB$L_TEMP_FRB(R0),R1	; get addr of temp frb
	CMPL	R1,SIFB$L_FRB_FLNK(R0)	; is owner the temp frb?
	BEQL	5$			; yes, ok to release
	CMPL	SIFB$L_FRB_FLNK(R0),R5	; are we at top of queue?
	BNEQ	BUGCK2			; no, bugcheck

;
;  see explanation of interlock code for remque in take_sifab_1
;

5$:	PUSHL	R5			; save frb address
	PUSHR	#^M<R0,R5>		; push sifab and frb addr arg's
	PUSHL	#2			; push arg count

	ASSUME	CMKRNL$_NARGS EQ 2
	ASSUME	CMKRNL$_ARGLST EQ 8

	$CMKRNL_S	RLS_SIFAB_1,(SP); call kernel routine
	ADDL2	#4,SP			; pop arg count
	BLBS	R0,10$			; branch if release was done
	POPR	#^M<R0,R5>		; queue interlocked must wait
	MOVL	(SP)+,R5		;
	BSBW	QUE_STALL		; go stall
	BRB	RM$RLS_SIFAB1		; go try again
10$:	ADDL	#8,SP			; pop rest of args
	MOVL	(SP)+,R5		; restore frb address
LEAVE:	RSB				; and return


;
; *** kernel level routine ***
;
;	see explanation of interlock code for remque in take_sifab_1
;

RLS_SIFAB_1:
	.WORD	^M<R2,R3,R4,R5>
	MOVQ	4(AP),R2		; get siafb in r2 and frb in r3
	SETIPL	#IPL$_ASTDEL		; disable kernel ast
	CLRL	R0			; assume interlocked
	BBSS	#SIFB$V_INQUEFLG,-
		SIFB$B_FLGS(R2),10$	; branch if interlocked
	REMQUE	(R3),R3			; remove from queue
	MOVAL	SIFB$L_FRB_FLNK(R2),R1	; get list head addr
	CMPL	(R1),R1			; test for empty queue
	CSB	#SIFB$V_INQUEFLG,-
		SIFB$B_FLGS(R2)		; clear interlock
	BNEQ	20$			; branch if queue not empty
	INCL	R0			; flag success
10$:	SETIPL	#0			; enable kernel ast
	RET				; and return

;
; queue was not empty so declare ast for waiting process
;

20$:	CMPL	(R1),R3			; is it us again ?
	BEQL	BUGCK2			; branch if yes
	CLRL	8(AP)			; say no bcb and set
	MOVL	(R1),4(AP)		; frb address for the rm$decast routine
	BRW	DECAST_2		; go enqueue the ast and return

	.SBTTL	RM$DECLARE_AST - ROUTINE CALLED TO SET UP FOR DECLARING AST

;++
;
; RM$DECLARE_AST
;
;	this routine is used by the file sharing code to restart another process
;	which has stalled waiting for a particular resource in the shared file
;	data base.  ownership of a particular resource is achieved by reaching
;	the head of the respective queue.  this routine is called to start the
;	process which has just reached the head of the particular resource queue.
;
;	Input Parameters:
;
;		r0 - address of the frb (file resource block)
;
;	Output Parameters:
;
;		r1 - destroyed
;
;	Side Effects:
;
;	if the routine which actually enqueues the ast (rm$decast) fails, this
;	routine will detect it and will take a bugcheck system failure.  this is
;	not expected to happen, of course, but if it does, we won't know what to
;	do, so the system will crash.
;
;--

RM$DECLARE_AST::
	PUSHL	#0			; no bcb addr at this point
PUSHR0:	PUSHL	R0			; put address of frb block on stack
	PUSHL	#2			; one parameter
	ASSUME	CMKRNL$_NARGS EQ 2	;
	ASSUME	CMKRNL$_ARGLST EQ 8	;
	$CMKRNL_S	RM$DECAST,(SP)	; go queue the cross-process ast
	ADDL2	#12,SP			; adjust stack
	RSB				; return to caller
BUGCK2:	RMSTBUG	FTL$_QUEUEERR2		; queue error..sys failure
ASTERR:	RMSTBUG	FTL$_ASTDECERR		; fatal error...ast declaration error
RM$DECLARE_ASTC::
	PUSHL	R4			; push bcb address
	BRB	PUSHR0			; branch to continue

	.SBTTL	RM$DECAST - DECLARE CROSS-PROCESS AST ROUTINE

;++
;
; RM$DECAST - Declare cross-process AST
;
;	this routine is used to actually declare a cross-process ast for a
;	process which has stalled waiting for ownership of a particular resource
;	in the file sharing data base.
;
;	Input Parameters:
;
;		4(ap) - address of the frb to be awakened
;
;	Output Parameters:
;
;		r0 - status code (0=failure, 1=success)
;
;	Side Effects:
;
;	this routine must run in kernel mode.  however, because rms runs in
;	exec ring, no additional privileges are required for this routine.
;	    note:  if this routine returns a bad status (the ast was not
;		   declared), the calling procedure will take a bugcheck
;		   system failure.
;
;--

RM$DECAST::
	.WORD	^M<R2,R3,R4,R5>		; entry mask
	SETIPL	#IPL$_ASTDEL		; disable kernel ast
DECAST_2:
	MOVL	8(AP),R0		; get bcb address
	BEQL	10$			; branch if none
;	BBSS	#BCB$V_AST_DCL,-
;		BCB$B_FLGS(R0),20$	; branch if ast already declared
10$:	JSB	@#EXE$ALLOCIRP		; allocate an ast block
	BLBC	R0,40$			; didn't get it...set wait mode
15$:	MOVL	4(AP),R0		; set frb addr into r0
	MOVB	#PSL$C_EXEC,-
		ACB$B_RMOD(R2)		; set access mode of ast
	BBC	#FRB$V_KRNLMODE,-
		FRB$B_FLAGS(R0),-
		17$			; br if normal exec mode
	MOVB	#PSL$C_KERNEL,-
		ACB$B_RMOD(R2)		; must deliver a kernel ast
17$:	MOVL	FRB$L_PID(R0),-
		ACB$L_PID(R2)		; set pid of process getting ast
	MOVL	FRB$L_ASTADDR(R0),-
		ACB$L_AST(R2)		; set addr of ast routine
	MOVL	FRB$L_ASTPRM(R0),-
		ACB$L_ASTPRM(R2)	; set ast parameter
	MOVL	R2,R5			; copy ast block addr
	MOVL	#PRI$_RESAVL,R2		; raise level
	JSB	@#SCH$QAST		; enqueue ast for the process
20$:	RMSSUC				; indicate success
	SETIPL	#0			; set ipl level to 0
	RET				; return to caller

;

40$:

;
; set resource wait mode the fast way
;

	MOVL	@#SCH$GL_CURPCB,R4	; get our pcb (in kernel mode)
	EXTZV	#PCB$V_SSRWAIT,#1,-
		PCB$L_STS(R4),R5	; get current state in r5
	CSB	#PCB$V_SSRWAIT,-
		PCB$L_STS(R4)		; set wait
	JSB	@#EXE$ALLOCIRP		; allocate the ast block
	INSV	R5,#PCB$V_SSRWAIT,#1,-
		PCB$L_STS(R4)		; restore wait state
	BLBS	R0,15$			; branch if success
	BRW	ASTERR			; bugcheck otherwise

	.SBTTL	RM$SET_SIFB_ADR - ROUTINE TO SET SIFAB/IFAB ADDR

;++
;
; RM$SET_SIFAB_ADR - Set SIFAB/IFAB addr
;
;	this subroutine merely determines whether a shared ifab exists,
;	and if so, puts its address into ap.  otherwise, the normal ifab
;	address is put into ap.
;
;	Input Parameters:
;
;		r10 - ifab address
;
;	Output Parameters:
;
;		ap - ifab or sifab address
;		r0 destroyed
;
;--

RM$SET_SIFB_ADR::
	MOVL	R10,AP			; assume no sifab
	MOVL	IFB$L_FRB_PTR(R10),R0	; get frb address
	BEQL	5$			; branch if none
	MOVL	FRB$L_SIFAB_PTR(R0),AP	; get sifab address
5$:	RSB				; return

	.SBTTL	QUE_STALL, QUE_STALL_SFD - QUEUE INTERLOCKS

;++
;
; QUE_STALL - queue interlocks
;
;	this subroutine performs the stall which is required to interlock
;	the insque and remque instructions, due to the failure of these
;	instructions to consistently set the correct condition bits.
;
;	inputs:
;
;		r9 - ifab/irab address
;		r5 - frb address
;
;	outputs:
;
;		ap - destroyed
;
;--

RM$QUE_STALL::
QUE_STALL:
	BBS	#FRB$V_KRNLMODE,-
		FRB$B_FLAGS(R5),-
		RM$K_WAIT		; branch if kernel mode
	PUSHR	#^M<R0,R1,R2,R3>	; save registers
	BSBW	RM$SETEFN		; allocate an event flag
	MOVL	(SP)+,R3		; get efn from stack
	$SETIMR_S	EFN=R3,-
		DAYTIM=HALF_SEC,-
		REQIDT=R9,-
		ASTADR=RM$STALLAST	; set timer to get ast
	SSB	#FRB$V_QUE_STALL,-
		FRB$B_FLAGS(R5)		; set flag
	BSBW	RM$STALL_SIFAB		; go stall
	CSB	#FRB$V_QUE_STALL,-
		FRB$B_FLAGS(R5)		; clear flag
	BRB	RETREG			; go restore regs
RM$K_WAIT::
	PUSHR	#^M<R0,R1,R2,R3>	; save registers
	$SETIMR_S	EFN=#IMP$C_IOREFN,-
		DAYTIM=HALF_SEC		; set timer
	$WAITFR_S	#IMP$C_IOREFN	; wait for ior event flag
	$CLREF_S	#IMP$C_IOREFN	; clear it on return
RETREG:	POPR	#^M<R0,R1,R2,R3>	; restore regs
	RSB				; return
QUE_STALL_SFD:

;++
;
;	inputs:
;
;		r9 - ifab address
;
;	outputs:
;
;		ap - destroyed
;
;--

	PUSHR	#^M<R5>			; save r5
	MOVL	IFB$L_FRB_PTR(R9),R5	; set up frb address
	BNEQ	5$			; have frb - go stall
	MOVL	@#RMS$GL_SFDBASE,R5	; else get sfd address
	MOVAL	SFD$L_TEMP_FRB(R5),R5	; and use internal
5$:
	BSBB	QUE_STALL		; go stall
	POPR	#^M<R5>			; restore r5
	RSB				; return

	.SBTTL	RM$INIT_SFSB - ALLOCATE AND INITIALIZE THE SFSB

;++
; RM$INIT_SFSB
;
; This routine allocates the SFSB.  The SFSB is allocated one per IFAB,
; and is used to contain the necessary local lock manager context for
; locking the shared file.  This will be allocated even when sharing is
; only multi-stream, as the lock manager will be used in that case also.
;
; A concurrent-read lock is requested on the file also.
;
; Calling Sequence:
;
;	BSBW	RM$INIT_SFSB
;
; Input Parameters:
;
;	r10	fwa address
;	r9	ifab address
;	r8	fab address
;
; Implicit Inputs:
;
;	fwa$t_fibbuf	-	used to pick up file id
;	fwa$q_device	-	used to pick up ascii device string
;
; Output Parameters:
;
;	r0	status code
;
; Implicit Outputs:
;
;	sfsb allocated and initialized, a CR lock made on it
;	if an enq error occurs, the $FAB stv field has the system service
;	code...
;
; Completion Codes:
;
;	suc, dme, enq
;
; Side Effects:
;
;	None...
;
;--

RM$INIT_SFSB::
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7> ; save work registers
	MOVZBL	#SFSB$C_BLN,R2		; get block length to allocate
	MOVL	R9,R1			; allocate from same page as ifab
	BSBW	RM$GETSPC		; allocate it
	BLBC	R0,25$			; branch if error
	MOVL	R1,IFB$L_SFSB_PTR(R9)	; address of SFSB in IFAB
	ASSUME	SFSB$B_BLN EQ SFSB$B_BID+1
	MOVW	#SFSB$C_BID+<SFSB$C_BLN@6>,-
		SFSB$B_BID(R1)		; fill in block length and id

;
; Make a descriptor of the first two longwords in SFSB, pointing to RESNAM
; field.
;

	MOVZBW	#SFSB$C_FIX_LEN,-	;
		SFSB$W_NAME_LEN(R1)	; initialize length of RESNAM string
					;  to fixed length portion
	MOVAL	SFSB$T_RESNAM(R1),-	; address of RESNAM string
		SFSB$L_ADDRESS(R1)	;  to descriptor address field
	MOVW	#1,SFSB$W_FAC_CODE(R1)	; set RMS facility code into name

;
; Copy File ID from FIB in FWA to the first three words of the SFSB.
; Copy ascii device name from FWA into SFAB after File ID.
;

	MOVAL	FWA$T_FIBBUF(R10),R0	; get address of FIB	
	MOVW	FIB$W_FID_NUM(R0),-	;
		SFSB$W_FID_NUM(R1)	; first word of FID
	MOVW	FIB$W_FID_SEQ(R0),-	;
		SFSB$W_FID_SEQ(R1)	; second word of FID
	MOVW	FIB$W_FID_RVN(R0),-	;
		SFSB$W_FID_RVN(R1)	; last word of FID
					;
	MOVZBL	FWA$T_SHRFILDEV(R10),R0	; get length of device string
	ADDW2	R0,SFSB$W_NAME_LEN(R1)	; add it to descriptor length
	MOVC3	R0,-			; move the string to the SFSB
		FWA$T_SHRFILDEV+1(R10),-;  resnam field to name the
		SFSB$T_DEV_NAM(R1)	;  file
	MOVL	IFB$L_SFSB_PTR(R9),R1	; restore SFSB address

;
; Lock the shared file concurrent read.  This gives a parent_id to any
; subsequent record locks, and starts us on the road to RMS file
; synchronization.
;
; Currently, don't queue for the lock.  If queuing for the file lock is ever
; desired, we'll have to STALL here, since any wait for a shared file will
; probably be a long one.
;

	$ENQ_S	LKMODE	= #LCK$K_CRMODE,-
		LKSB	= SFSB$L_LKSB(R1),-
		RESNAM	= SFSB$Q_FILENAME(R1),-
		FLAGS	= #LCK$M_NOQUEUE!LCK$M_VALBLK!LCK$M_SYNCSTS!LCK$M_SYSTEM
	BLBC	R0,30$			; branch on error
	RMSSUC				; indicate success
20$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7> ; restore registers
	RSB				; return to caller

25$:	RMSERR	DME			; dynamic memory exhausted
	BRB	20$			; return error to caller

30$:	RMSERR	ENQ,R1			; default to ENQ error for RM$MAPERR
	BSBW	RM$MAPERR		; go map the error
	BRB	20$			; and return

	.END
