
MODULE RM3MISPUT (LANGUAGE (BLISS32) ,
		IDENT = 'V03-003'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                Miscellaneous put routines
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Christian Saether     CREATION DATE:        	6-JUL-78  10:56
!
!
! MODIFIED BY:
!
!	V03-002 TMK0002		Todd M. Katz		13-Apr-1982
!		Fixed a bug in RM$RECORD_SIZE. This bug only showed up when
!		a multi-bucket data level split of a prolog 3 file with index
!		compression required updating of the level 1 index with two
!		index records. The size of these two index records was being
!		incorrectly computed. I was refering to keybuffer 5 (containing
!		the compressed key of the first record) in one instance when 
!		I should have been refering to keybuffer 4 (containing the
!		compressed key of the second record), and thus the combined
!		size of the two index records was being incorrectly computed.
!
!	V03-001 LJA0007		Laurie Anderson 	25-Mar-1982
!		Change KBUFSZ to reference a macro when computing buffer 
!		size and make IFB$B_KBUFSZ a word, now: IFB$W_KBUFSZ.
!
!	V03-001	TMK0001		Todd M. Katz		03-Mar-1982
!		Fixed a bug in the determination of the record size of
!		a two-bucket with empty bucket bucket split case involving
!		prolog 3 index buckets with compressed keys.  In such a case
!		there is no key to be inserted, but due to insufficient
!		checks the routine RM$V3KEY_SZ was being called as if there
!		was a key. This routine thinks there is a key in keybuffer 2
!		and attempts to move it into keybuffer 5 so it can compress
!		it. Since there isn't a key, it ends up moving garbage into
!		the keybuffer and into the RLB which follows it guarenteeing an
!		access violation the next time RM$UNLOCK is called. The fix 
!		is to make sure that this routine will never be called for
!		this particluar prolog 3 bucket split case.
!
!
!	V02-022 KPL0001		Peter Lieberwirth	 2-Mar-1982
!		Fix linkage from v02-021
!
!	V02-021	TMK0005		Todd M. Katz		02-Mar-1982
!		Made several changes to the routines in this module:
!
!		1. RM$V3KEY_SZ is no longer a global routine.
!
!		2. Added a symbol to RM$FOOLED_YUH so that reprobing of the
!		   RAB would not be neccessairy.
!
!		3. Added support for rear-end truncation of keys in prolog 3
!		   buckets containing compressed keys. This included changes in
!		   the way the size of two compressed keys (from a multibucket
!		   split) is computed in RM$RECORD_SIZE, changes in the way the
!		   size of a single key is determined in RM$V3KEY_SZ, and 
!		   changes in the way in which keys are inserted into prolog 3
!		   buckets (with compressed keys) in RM$ADD_V3KEY. All these
!		   changes reflect the fact that compressed keys are now 
!		   rear-end truncated as well as front-end compressed.
!
!	V02-020	TMK0004		Todd M. Katz		12-Feb-1982
!		Add checks for a multibucket split in RM$RECORD_SIZE and 
!		RM$BLD_IDX_REC in all instances when it isn't absolutely
!		clear whether RMS is currently processing a two-pass two-bucket
!		split case or a two-pass multibucket split case (where both
!		records are to go in the same bucket).
!
!	V02-019	TMK0003		Todd M. Katz		08-Feb-1982
!		Document what is going on in RM$RECORD_SIZE so that someone
!		besides me might possibly understand what is going on from 
!		the comments. The current comments are both confusing and
!		wrong.
!
!	V02-018	TMK0002		Todd M. Katz		30-Jan-1982
!		Made many changes to several of these miscellaneous routines
!		inorder to fix a variety of bugs, and to add functionality
!		that was lacking. I will list the reasons for the changes
!		made, and how the routines were changed.
!
!		1. Added REC_SZ as an arguement to both RM$BLD_IDX_REC
!		   and RM$V3_IDX_REC. It was require in the former to pass
!		   it to the latter, and in the latter to fix the prolog 3
!		   multibucket split trailing key recompression bug described
!		   below.
!
!		2. Fixed a prolog 3 multibucket split key recompression bug.
!		   When a multibucket split occurs, and the index must be
!		   updated with two keys, the key at the insertion point
!		   must have its front compression redetermined. However,
!		   the key recompression routine, RM$RECOMPR_KEY, is unable
!		   to recompute the front compression of a key if its
!		   current front compression is not equal to the front
!		   compression of the key preceeding it. If it has greater
!		   compression the index is out-of-order, and if it has less,
!		   it assumes there is no need for recompression. Well, if
!		   the two keys BB AND BC were to be inserted between AA and
!		   BD, the trailing key BD was not being recompressed because
!		   its current fron compression (0) was less than the 
!		   compression of the record preceeding it (1) even though
!		   it should be recompressed to have a new front compression
!		   value of 1. The fix was that on a multibucket split, the
!		   first key is inserted and used to recompress what will
!		   become the trailing key, and then the second key is inserted
!		   and used to recompress the trailing key. This required
!		   changes to RM$ADD_V3KEY, so that recompression is NOT
!		   performed if the key being inserted is the first of two
!		   keys, and changes to RM$V3_IDX_REC, to recompress what
!		   will become the trailing key after the first of two keys
!		   is inserted, based on the first key that is inserted. In
!		   addition, I also added the change such that if the first 
!		   of two compressed keys to be inserted is zero front 
!		   compressed, then the pointer to the last noncompressed key 
!		   is incremented to this key to facilitate the determination 
!		   of the front compression of the next key when it is 
!		   inserted.
!
!		3. Added code to restrict when trailing key recompression
!		   is required. If one or two keys are inserted into a
!		   prolog 3 index bucket containing compressed keys at the
!		   beginning of the bucket's freespace, there is no need to 
!		   redetermine the front compression of the trailing key 
!		   because there is no trailing key! Formerly, the front
!		   compression of the trailing key was blindly determined
!		   as part of the process of inserting any compressed key
!		   regardless of whether there was any key that trailed the
!		   key inserted or not.
!
!		4. Changed the decision by which the keys and VBNs in prolog 
!		   3 index buckets are shifted in order to make room for the 
!		   insertion of a new key-VBN pair. At the present time, if
!		   the key/VBN is to be added as the hish order key in the 
!		   bucket, neither the keys nor the VBNs are shifted since
!		   both "grow" inward towards the center. An additional check
!		   is added to also not shift the keys or VBNs, if the
!		   number of bytes by which they are to be shifted "inwards"
!		   is 0. This will occur when the split point of an index
!		   bucket matches the insertion point, and just the VBN of
!		   the new lower order key of the new (right) bucket is to
!		   be updated to its new value.
!
!		5. Added code necesaary for support of a Prolog 1 & 2 split
!		   case. When the insertion point of a multibucket split is
!		   found to be at the split point, but there is sufficient room
!		   in an index bucket for only two index records, and the 
!		   insertion point happens to come at the bucket's beginning,
!		   both of the old index records must be moved out of the old
!		   bucket to make room for the two new index records which are
!		   both put in the old bucket. This index bucket split case
!		   required code to be added to RM$RECORD_SIZE and 
!		   RM$BLD_IDX_REC. As this split case is handled by making two
!		   passes, one for insertion of the two new index records in 
!		   the old index bucket, and the second to update a VBN pointer
!		   in the low order key of the new bucket, both of these 
!		   routines had to be modified, to take the proper action for
!		   each of the passes of this case. RM$BLD_IDX_REC oversees
!		   addition of the both keys and a VBN during the first pass,
!		   and updates a VBN during the second, while RM$RECORD_SIZE
!		   makes sure to return the proper size of the index record
!		   to be added during each pass.
!
!		6. There are three bucket split cases for when the insertion
!		   point and the bucket split point are the same and no empty
!		   buckets are involved. For all three cases, two passes must
!		   be made, and for all three cases no code existed for Prolog 
!		   3 buckets. Changes were made to RM$RECORD_SIZE, RM$SHFT_VBNS
!		   and RM$V3_IDX_REC to support these three bucket split cases.
!		   The changes made to RM$V3_IDX_REC allow the routine to
!		   recognize these three two-pass bucket split cases, which of 
!		   the two passes is in progress, and to take the appropriate
!		   action. As the VBNs in prolog 3 buckets are order from
!		   right to left and "grow inwards", if a index record with a
!		   key value less than the current high key value of the bucket
!		   is inserted, the VBNs must be shifted to make room for the
!		   VBN associated with the just inserted key. The routine which
!		   performs this shifting (RM$SHFT_VBNS) had to be modified to 
!		   recognize these three bucket split cases, which of the two 
!		   passes was current, and perform any required VBN shifting. 
!		   Finally, RM$RECORD_SIZE had to be similary modified so that
!		   it would return the size of the index record to be inserted
!		   into the "current" bucket. The size, of course, as well as 
!		   the current bucket depends upon the split case, and which 
!		   of the two passes is currently under way. The three bucket 
!		   split cases and their effect on these routines are as 
!		   follows:
!
!		   TWO-BUCKET SPLIT:
!		   During the first pass (when the index record contents of the
!		   old bucket are updated) just a key is added. The size of the
!		   record is the size of the key, and no VBNs need be shifted.
!		   During the second pass (when the index record contents of 
!		   the new index bucket are appropriately modified), just a VBN
!		   is updated. The size of the record is the difference between
!		   the VBN size required to hold the old data level VBN and the
!		   size required to hold the new data level VBN. No VBN 
!		   shifting is required unless the size is greater than 0.
!
!		   THREE-BUCKET SPLIT - ONE KEY IN EACH INDEX BUCKET:
!		   During the first pass, just a key is added to the contents 
!		   of the old index bucket so the record size is the size of
!		   the key and the no VBNs need be shifted. During the second 
!		   pass, a new key and VBN is added as the low order key in the
!		   new index bucket, and a VBN is also updated. In this case
!		   VBNs must be shifted to make room for the new VBN and any
!		   change in VBN size, and the record size includes the key 
!		   added, the VBN added, and any difference in data level 
!		   VBN size.
!
!		   THREE-BUCKET SPLIT - BOTH KEYS IN OLD INDEX BUCKET:
!		   This split case only occurs when the insertion point and
!		   the split point are at the beginning of the old index
!		   bucket and both keys in the old bucket must be moved out
!		   to make room for the two new keys. During the first pass,
!		   both keys are added as is a VBN. The record size is the
!		   size of the two keys and the VBN added, and no VBN shifting
!		   need take place. During the second pass just a VBN is
!		   updated. The record size is computed to be any difference
!		   in sizes required to hold data level VBNs, and VBN shifting
!		   takes place only if there is a difference.
!
!	V02-017	TMK0001		Todd M. Katz		11-Jan-1982
!		Make a change to RM$SHFT_VBNS which affects three-way bucket
!		splits where one of the resulting buckets is empty. The
!		routine was adjusting the offset pointer to where the
!		VBN shift should start. This is wrong, and in fact, caused
!		index corruption so I removed it.
!
!	V02-016	PSK0007		Paulina S. Knibbe	14-Dec-1981
!		Change record_size to take BKT_ADDR as an input
!
!	V02-015	PSK0006		Paulina S. Knibbe	26-Oct-1981
!		Add support for compressed indexes to rm$v3key_sz
!
!	V02-014	PSK0005		Paulina S. Knibbe	15-Aug-1981
!		Fix some problems w/large VBNs in index buckets.
!
!	V02-013	PSK0004		Paulina S. Knibbe	29-Jul-1981
!		Remove support for growing prologue three compressed
!		indexes. Add code to handle indexes with no  chars
!		compressed off of the rear.
!
!	V02-012	PSK0003		Paulina S. Knibbe	24-Jul-1981
!		Fix off-by-one error in SHIFT_VBNS; other problems
!		with growing VBNs
!
!	V02-011	PSK0002		Paulina S. Knibbe	13-Jul-1981
!		Add 'RM$SHFT_VBNS' to handle spreading the VBN chain
!		in prologue three index buckets.
!
!	V02-010	MCN0007		Maria del C. Nasr	28-Jun-1981
!		Add RM$MOVE_SIG_CNT. 
!
!	V02-009	PSK0001		Paulina S. Knibbe	08-Jun-1981
!		Add support for prologue three index buckets:
!		RM$RECORD_SIZE, RM$NEW_VBN_BYTES, RM$V3KEY_SZ
!		RM$V3_IDX_REC,RM$ADD_V3VBN,RM$ADD_V3KEY
!
!	V02-008	MCN0006		Maria del C. Nasr	16-Mar-1981
!		Increase size of record identifier to a word in the NRP.
!		Change linkage to RM$RECORD_SIZE to include IFAB.
!
!	V02-007	REFORMAT	C D Saether	01-Aug-1980	18:10
!
!	V0006	CDS0077		C D SAETHER	24-JAN-1980	13:50
!		Don't want to create dupes count field on continuation
!		SIDR arrays either.
!
!	V0005	CDS0071		C D SAETHER	15-JAN-1980	12:28
!		Fix bug creating dupes count field in SIDR records when
!		dupes aren't allowed (rm$record_size and rm$bld_new_sidr).
!
! Revision history:
!
!   Wendy Koenig, 	24-OCT-78  14:02
!   X0002 - MAKE CHANGES CAUSED BY SHARING CONVENTIONS
!
!   Christian Saether, 	26-JAN-79  9:01
!   X0003 - check down pointer before attempting to swing from empty bucket
!
!   Christian Saether,  1-july-79  11:00
!   X0004 - fix nxtrecid logic in RM$INS_REC (caused re-use of ID's)
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

!
! define default psects for code
!

PSECT
    CODE = $$RMSPUT3(PSECT_ATTR),
    PLIT = $$RMSPUT3(PSECT_ATTR);

!
! Linkages

LINKAGE
    L_INS_REC,
    L_ADD_TO_ARRAY,
    L_BLD_IDX_REC,
    L_BKT_SORT,
    L_BLD_NEW_SIDR,
    L_CNTRL_ADDR,
    L_COMPARE_KEY,
    L_COMPRESS_KEY,
    L_FOOLED_YUH,
    L_GETNEXT_REC,
    L_MOVE,
    L_MOVE_SIG_CNT,
    L_NOREAD_LONG,
    L_RECOMPR_KEY,
    L_RECORD_SIZE,
    L_RECORD_VBN,
    L_SRCH_BY_KEY,
    L_VBN_SIZE,
    L_MOVE_IN_VBN,
    RL$SHFT_VBNS = JSB() : GLOBAL (R_REC_ADDR, R_BKT_ADDR, R_IDX_DFN, R_IRAB, R_IFAB),
    RL$V3KEY_SZ = JSB (REGISTER = 0) : GLOBAL (R_BKT_ADDR, R_IDX_DFN, R_REC_ADDR,R_IFAB,R_IRAB),
    RL$V3_IDX_REC = JSB (REGISTER = 0) : GLOBAL (R_BKT_ADDR, R_IDX_DFN, R_REC_ADDR, 
				     R_IRAB, R_IFAB),
    RL$NEW_VBN_BYTES = JSB () : GLOBAL (R_BKT_ADDR, R_IDX_DFN),
    RL$FRNT_CMPR = JSB(REGISTER=8) : GLOBAL (R_IDX_DFN, R_IRAB, R_IFAB, R_BKT_ADDR);
				

! External Routines
!
EXTERNAL ROUTINE
    RM$CNTRL_ADDR	: RL$CNTRL_ADDR,
    RM$COMPRESS_KEY	: RL$COMPRESS_KEY,
    RM$NOREAD_LONG	: RL$NOREAD_LONG,
    RM$GETNEXT_REC	: RL$GETNEXT_REC,
    RM$RECORD_VBN	: RL$RECORD_VBN,
    RM$RECOMPR_KEY	: RL$RECOMPR_KEY,
    RM$COMPARE_KEY	: RL$COMPARE_KEY,
    RM$V3_VBN		: RL$SRCH_BY_KEY,
    RM$FRNT_CMPR	: RL$FRNT_CMPR,
    RM$MOVE		: RL$MOVE;

FORWARD ROUTINE
    RM$NEW_VBN_BYTES	: RL$NEW_VBN_BYTES,
    RM$SHFT_VBNS	: RL$SHFT_VBNS NOVALUE,
    RM$V3_IDX_REC	: RL$V3_IDX_REC NOVALUE,
    RM$V3KEY_SZ		: RL$V3KEY_SZ;

MACRO
    KEY_LEN	= 0,0,8,0 %,
    CMPR_CNT	= 1,0,8,0 %;


GLOBAL ROUTINE RM$VBN_SIZE (VBN) : RL$VBN_SIZE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Calculate number of bytes required to describe input VBN
!
! CALLING SEQUENCE:
!	RM$VBN_SIZE (VBN)
!
! INPUT PARAMETERS:
!	VBN - VBN whose size is to be determined
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	number of bytes needed to describe VBN
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    LOCAL
	SIZE;

    MAP
	VBN	: VECTOR [4, BYTE];

    SIZE = 3;

    DO

	IF .VBN[.SIZE] NEQ 0
	THEN
	    BEGIN
	    SIZE = .SIZE + 1;
	    RETURN .SIZE
	    END

	ELSE
	    SIZE = .SIZE - 1

    UNTIL .SIZE EQL 1;

    SIZE = .SIZE + 1
    END;


GLOBAL ROUTINE RM$RECORD_SIZE : RL$RECORD_SIZE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Calculate record size of SIDR or index records
!
! CALLING SEQUENCE:
!	RM$RECORD_SIZE()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	IFAB		- for RM$RECORD_VBN
!	IRAB		- pointer to internal RAB
!		[ STOPLEVEL ] - current level in tree
!		[ DUPS_SEEN ] - flag set if duplicates seen
!		[ CONT_BKT ] - this is continuation bucket
!		[ BIG_SPLIT ] - flag set if more than two bucket split
!		[ VBN_LEFT ]  - VBN of leftmost bucket in split
!		[ VBN_RIGHT ] - VBN of rightmost bucket in split
!		[ VBN_MID ] - VBN of middle bucket in 3-4 bucket split
!		[ NRP_PTR ]   - pointer to NRP list
!		[ REC_COUNT ] - which record this is in the bucket
!		[ POS_INS ]  - position of insert of this record
!		[ KEYBUF ] - pointer to the 5 contigious keybuffers
!
!		NRP	[ RP_VBN ] - VBN of UDR for SIDR pointer
!	IDX_DFN		- pointer to index descriptor structure
!		[ DUPKEYS ] - duplicate keys are allowed
!		[ KEYSZ ] - size of key
!	REC_ADDR - position of insert (used on index levels only)
!	BKT_ADDR - pointer to current bucket
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	size of record required
!
!	PROLOG 1 & 2:	Size is returned as a single quantity
!	PROLOG 3:	Size is returned as two contigious words. 
!			High order word contains number of VBN bytes
!			Low order word contains number of key bytes
!
! SIDE EFFECTS:
!	sets ap = 1 when checking down pointer on empty bucket cases (index level)
!
!--

    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_IRAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR,
	R_BKT_ADDR_STR;

    LOCAL
	SIZE;

    IF .IRAB[IRB$B_STOPLEVEL] EQL 0
    THEN

	! this is a data level SIDR
	!
	BEGIN

	! calculate size of record pointer part of record (always present).
	! add up VBN size plus ID byte plus control byte.
	!
	SIZE = RM$VBN_SIZE(.BBLOCK[.IRAB[IRB$L_NRP_PTR], NRP$L_RP_VBN]) + 2;

	! if no dupes seen then a new record is required, so add in key size
	! and overhead - SIDR control and ID byte + 2 byte size field
	!

	IF NOT .IRAB[IRB$V_DUPS_SEEN]
	THEN
	    BEGIN
	    SIZE = .SIZE + .IDX_DFN[IDX$B_KEYSZ] + 4;

	    ! if duplicates are allowed, then will also create a 4 byte count
	    ! field (present for compatibility but not maintained). If this is
	    ! a continuation record, do not create a dupes count field.
	    !
	    !

	    IF .IDX_DFN[IDX$V_DUPKEYS]
		AND
		NOT .IRAB[IRB$V_CONT_BKT]
	    THEN
		SIZE = .SIZE + 4;

	    END;

	END					! of SIDR data level


    ELSE

	IF .IFAB [IFB$B_PLG_VER] LSSU PLG$C_VER_3
	THEN

	    ! This is a Prolog 1 or 2 index bucket. The size to be returned is
	    ! given below for each of the possible split cases.
	    !
	    !  1) two-bucket split no empty buckets: 
	    !
	    !     size of new key + size of VBN_RIGHT 
	    !
	    !  2) two-bucket split empty bucket:
	    !
	    !     size of VBN_MID - size of old VBN in record 
	    !	  (only update VBN pointer)
	    !
	    !  3) multibucket split no empty buckets:
	    !
	    !     size of two new keys + size of first new VBN (VBN_MID)
	    !			       + size of second new VBN (VBN_RIGHT)
	    !
	    !  4) multibucket split with empty buckets:
	    !
	    !     size of two new keys + size of VBN_RIGHT
	    !     		       + size of VBN_MID 
	    !			       - size of old VBN in record 
	    !     (update one VBN pointer)
	    !
	    !  5) first pass of two-pass two-bucket split case:
	    !
	    !     size of new key + size of old VBN in record
	    !
	    !  6) second pass of two-pass two-bucket split case:
	    !
	    !     size of VBN_RIGHT - size of old VBN in record 
	    !	  (only update VBN pointer)
	    !
	    !  7) first pass of two-pass multibucket split case -
	    !	  one of the new keys in each bucket:
	    !
	    !     size of first new key + size of old VBN in record
	    !
	    !  8) second pass of two-pass multibucket split case - 
	    !	  one of the new keys in each bucket:
	    !
	    !     size of second new key + size of new VBN (VBN_MID) 
	    !     			 + size of VBN_RIGHT 
	    !				 - size of old VBN in record
	    !	  (update one VBN pointer)
	    !
	    !  9) first pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     size of the two new keys + size of new VBN (VBN_MID)
	    !				   + size of old VBN in record
	    !
	    ! 10) second pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     size of VBN_RIGHT - size of old VBN in record 
	    !	  (only update VBN pointer) 
	    !
	    ! sizes are always computed so as to include any control bytes 
	    ! required
	    !
	    BEGIN
	    SIZE = 0;

	    ! Handle all empty bucket split cases
	    !
	    IF .IRAB[IRB$V_EMPTY_BKT]
	    THEN
	    	BEGIN
		AP = 1;				! set for index level

		! In all empty bucket split cases the existing down pointer
		! must match VBN_LEFT before we modify it. If it doesn't
		! match we can't change it or we may be causing crossed 
		! pointers down to the level below.
		!
	    	IF .IRAB[IRB$L_VBN_LEFT] EQLA RM$RECORD_VBN()
	    	THEN
		    SIZE = RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]) -
		    .REC_ADDR[IRC$V_PTRSZ] - 2;

		IF NOT .IRAB[IRB$V_BIG_SPLIT]
		THEN
		    RETURN .SIZE;

		! if here then we are creating an additional down pointer in
		! addition to conditionally swinging the down pointer from the
		! empty bucket
		!
		SIZE = .SIZE + RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]) +
			.IDX_DFN[IDX$B_KEYSZ] + 1;
		RETURN .SIZE;
		END;


	    ! Determine size of index records to be added for all bucket split
	    ! cases not involving empty buckets.
	    !
	    ! If this is not the first pass of a two-pass bucket split case,
	    ! compute the difference between the current record VBN pointer 
	    ! size and the size of the VBN to swing (VBN_RIGHT). This will
	    ! facilitate computation of the record size during the second
	    ! pass of all two-pass bucket split cases when a VBN pointer must
	    ! be updated (in fact becomes the size for two of the two-pass 
	    ! bucket split cases), and it becomes part of the compuation
	    ! of the VBN pointer size required for VBN_RIGHT for all one-pass
	    ! bucket split cases.
	    !
	    IF NOT .IRAB[IRB$V_SPL_IDX]
	    THEN
		SIZE = RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT])
			 - .REC_ADDR[IRC$V_PTRSZ] - 2;

	    ! The size of the middle key key and its corresponding VBN must be 
	    ! included in the computation of record size if this is a one-pass 
	    ! multibucket case, the first pass of the two-pass multibucket 
	    ! split case where both keys go in the same (old/left) index 
	    ! bucket, or the second pass of the two-pass multibucket split 
	    ! case where one of the new keys goes in each of the old and new 
	    ! index buckets and we are currently updating the new index 
	    ! bucket with the second of the two keys and its corresponding VBN.
	    !
	    IF (.IRAB[IRB$V_BIG_SPLIT] AND NOT .IRAB[IRB$V_SPL_IDX] AND
			.IRAB[IRB$L_VBN_MID] NEQU 0)
		OR
	       (.IRAB[IRB$V_SPL_IDX] 
			AND .IRAB[IRB$V_BIG_SPLIT]
			AND (.IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ))
	    THEN
		SIZE = .SIZE + RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]) +
		       .IDX_DFN[IDX$B_KEYSZ] + 1;

	    ! Finally, the size of the record must include the size of the
	    ! first key on all one-pass bucket split cases not involving
	    ! empty buckets, and on all two-pass bucket split cases during
	    ! the first pass when the contents of the old index buckets
	    ! are being updated. 
	    !
	    ! Note that the current record size is also added in. If this is a 
	    ! one-pass bucket split cases this quantity plus the difference 
	    ! between the VBN pointer size in the old record and the VBN 
	    ! pointer size required for VBN_RIGHT (already included within 
	    ! SIZE) yield the size of VBN_RIGHT. If this is one of the two-pass
	    ! bucket split cases, it is at this point that we include in the 
	    ! size determination the size of the old record's VBN pointer.
	    !
	    IF .IRAB[IRB$L_VBN_LEFT] NEQ 0
	    THEN
		SIZE = .SIZE + .REC_ADDR[IRC$V_PTRSZ] + 2 +
			.IDX_DFN[IDX$B_KEYSZ] + 1;

	    END


	
	ELSE

	    ! This is a Prolog 3 index bucket. The size to be returned is
	    ! given below for each of the possible split cases. Note that it
	    ! will always be possible for the VBN pointer size to change in
	    ! a bucket. This requires that the additional bytes needed to 
	    ! increase the VBN pointer size of every currently existing index 
	    ! record in the current bucket to the new value be included in the 
	    ! size determination.
	    !
	    !  1) two-bucket split no empty buckets: 
	    !
	    !     size of new key + VBN pointer size of bucket
	    !			  + number of new VBN bytes
	    !
	    !  2) two-bucket split empty bucket:
	    !
	    !     number of new VBN bytes
	    !	  (only update VBN pointer)
	    !
	    !  3) multibucket split no empty buckets:
	    !
	    !     size of two new keys + 2 * VBN pointer size of bucket
	    !			       + number of new VBN bytes
	    !
	    !  4) multibucket split with empty buckets:
	    !
	    !     size of two new keys + VBN pointer size of bucket
	    !     		       + number of new VBN bytes
	    !     (update one VBN pointer)
	    !
	    !  5) first pass of two-pass two-bucket split case:
	    !
	    !     size of new key + VBN pointer size of bucket
	    !			    number of new VBN bytes
	    !
	    !  6) second pass of two-pass two-bucket split case:
	    !
	    !     number of new VBN bytes
	    !	  (only update VBN pointer)
	    !
	    !  7) first pass of two-pass multibucket split case -
	    !	  one of the new keys in each bucket:
	    !
	    !     size of first new key + VBN pointer size of bucket
	    !				+ number of new VBN bytes
	    !
	    !  8) second pass of two-pass multibucket split case - 
	    !	  one of the new keys in each bucket:
	    !
	    !     size of second new key + VBN pointer size of bucket
	    !     			 + number of new VBN bytes
	    !	  (update one VBN pointer)
	    !
	    !  9) first pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     size of the two new keys + 2 * VBN pointer size of bucket
	    !				   + number of new VBN bytes
	    !
	    ! 10) second pass of two-pass multibucket split case - 
	    !	  both of the new keys in the same bucket:
	    !
	    !     number of new VBN bytes
	    !	  (only update VBN pointer) 
	    !
	    ! Sizes are always computed so as to include any control bytes 
	    ! required. For cases 3, 4, and 9, key size include compression
	    ! of the second record if compression is enabled.
	    !
	    BEGIN

	    ! First set up some useful constants
	    !
	    LOCAL
		CONTEXT	: REF BBLOCK,   ! Address of block containing context
					! for potential update of an existing 
					! index rec
		KEY_SZ,			! Number of bytes needed to store the
					! key of the index record(s)
					! (compression index is added in and
					! front compression of the second 
					! record is subtracted)
		VBN_SZ,			! Size of all the VBNs after the 
					! insertion (they could all grow by 
					! one or two bytes)
		NEW_VBN_BYTES;		! Number of bytes which will be added 
					! to the existing VBNs because of
					! changing to a larger VBN size 
					! (may be 0)

	    ! Determine the size (VBN_SZ) of the VBNs after insertion of the 
	    ! index records to be inserted, and the number of VBN bytes
	    ! (NEW_VBN_BYTES) which will have to be added inorder adjust the
	    ! VBN pointer size of the pre-existing index records to this value.
	    ! Determination of VBN_SZ will directly depend upon the bucket
	    ! split case of the current invocation of this routine.
	    !
	    NEW_VBN_BYTES = 0;

	    ! For all one-pass bucket split cases, the VBN pointer size is the 
	    ! maximum of the number of bytes need to store the current bucket 
	    ! pointer size, VBN_RIGHT, and VBN_MID.
	    !
	    IF (NOT .IRAB[IRB$V_SPL_IDX])
		AND 
	       (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
	    THEN VBN_SZ = MAXU (RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]),
		   		RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]),
		   		.BKT_ADDR[BKT$V_PTR_SZ]+2)
	    ELSE

		! Determine VBN_SZ for the first pass of all two-pass
		! bucket split cases.
		!
		IF .IRAB[IRB$V_SPL_IDX]
		THEN 

		    ! For case 9 (two-pass multibucket split with both keys
		    ! in the same bucket) VBN_SZ is the maximum number of 
		    ! bytes needed to store VBN_MID and the current bucket
		    ! VBN pointer size.
		    !
		    IF .IRAB[IRB$V_BIG_SPLIT]
		        AND
		       (.IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ)
		    THEN VBN_SZ = MAXU (RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]),
		   			.BKT_ADDR[BKT$V_PTR_SZ]+2)

		    ! For all other two-pass bucket split cases, the VBN_SZ
		    ! is the number of bytes need to store the current VBN 
		    ! pointer bucket size.
		    !
		    ELSE VBN_SZ = .BKT_ADDR[BKT$V_PTR_SZ]+2

		! Determine VBN_SZ for the second pass of all two-pass
		! bucket split cases.
		!
		ELSE

		    ! For case 8 (two-pass multibucket split with a key
		    ! inserted in each of the buckets) VBN_SZ is the
		    ! number of bytes needed to store the maximum of the
		    ! current VBN bucket pointer size and VBN_MID.
		    !
		    IF .IRAB[IRB$L_VBN_MID] NEQU 0
		    THEN VBN_SZ = MAXU (RM$VBN_SIZE(.IRAB[IRB$L_VBN_MID]),
		   			RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]))

		    ! For all other two-pass bucket split cases, VBN_SZ becomes
		    ! the number of bytes needed to store VBN_RIGHT.
		    !
		    ELSE VBN_SZ = RM$VBN_SIZE(.IRAB[IRB$L_VBN_RIGHT]);

 	    NEW_VBN_BYTES = RM$NEW_VBN_BYTES(.VBN_SZ);

	    ! Determine the key size of the first key to be inserted.
	    ! The two bytes required as overhead for key compression are
	    ! included in the key size if index compression is enabled.
	    !
	    IF .IDX_DFN [IDX$V_IDX_COMPR]
	    THEN KEY_SZ = 2
	    ELSE KEY_SZ = 0;

	    ! For all one-pass bucket split cases where there are keys to be
	    ! inserted, and for the first pass of all two-pass bucket split
	    ! cases, the first key to be inserted is the key found in key
	    ! buffer 2.
	    !
	    IF (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
		AND
	       (NOT (.IRAB[IRB$V_EMPTY_BKT] AND NOT .IRAB[IRB$V_BIG_SPLIT]))
	    THEN KEY_SZ = .KEY_SZ + RM$V3KEY_SZ (KEYBUF_ADDR(2))
	    ELSE

		! For the second pass of the two-pass multibucket split case
		! where a key goes in each of the two index buckets (case 8)
		! the first and only key to be inserted is actually the second
		! of the two keys to be inserted, and it is found in key
		! buffer 3.
		!
		IF NOT .IRAB[IRB$V_EMPTY_BKT]
		    AND
		   (.IRAB[IRB$L_VBN_MID] NEQU 0)
		THEN KEY_SZ = .KEY_SZ + RM$V3KEY_SZ (KEYBUF_ADDR(3))

		! For the second pass of all other two-pass split cases,
		! the key size is zero.
		!
		ELSE KEY_SZ = 0;

	    IF .IRAB [IRB$V_EMPTY_BKT]
	    THEN

		! We have an empty bucket. See if we can just change the
		! VBN down pointer so we don't search the empty bucket
		! on random accesses. The existing pointer must match VBN_LEFT
		! before we change it because if if it doesn't and we modify
		! it anyway we may be causing crossed pointers down to the
		! level below.
		!
		BEGIN
		SIZE = 0;

		IF .IRAB [IRB$L_VBN_LEFT] NEQU RM$V3_VBN()
		THEN
		    NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ;

		! If there was a multiple bucket split, add new key and VBN
		!
		IF .IRAB[IRB$V_BIG_SPLIT] 
		THEN
		    BEGIN
		    SIZE = .KEY_SZ;
		    NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ;
		    END;
	        END

	    ELSE
		    
		! No empty buckets. For now, assume that entire record
		! will fit into one bucket and compute its size.
		! Always add VBN and key unless this is the second pass of one 
		! of the two-pass bucket split cases where all we are going
		! to do is update a VBN pointer. In such cases, the size
		! returned does not include the size of a VBN and a key.
		!
		BEGIN
		SIZE = .KEY_SZ;

		IF (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
		    OR
		   (.IRAB[IRB$L_VBN_MID] NEQU 0)
		THEN
		    NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ;

		! If this is a one-pass multibucket split or the first pass
		! of a two-pass multibucket split where both index records
		! are to go in the same (old) index bucket, the size of the
		! index record must include (in addition to the key size of the
		! first index record, the new VBN size of the bucket, and the 
		! number of new VBN bytes which must be added to all 
		! pre-existing VBN pointers to make them all the same size) the
		! key size of the second index record (less its front 
		! compression if index compression is enabled) and the size of
		! another new VBN. If index compression is enabled, then the
		! key size will not include any rear-end truncated characters.
		!
		IF .IRAB[IRB$V_BIG_SPLIT]
		   AND
			((NOT .IRAB[IRB$V_SPL_IDX]
			 	AND .IRAB[IRB$L_VBN_LEFT] NEQU 0)
			 OR
			(.IRAB[IRB$V_SPL_IDX]
				AND .IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ))
	 	THEN
		    BEGIN
		    NEW_VBN_BYTES = .NEW_VBN_BYTES + .VBN_SZ;

		    IF NOT .IDX_DFN [IDX$V_IDX_COMPR]
		    THEN
			SIZE = .SIZE + .IDX_DFN [IDX$B_KEYSZ]
		    ELSE
			BEGIN

			LOCAL
			    KEYBUF3	: REF BBLOCK,
			    KEYBUF4	: REF BBLOCK,
			    KEYBUF5	: REF BBLOCK,
			    NOT_USED,
			    SAVE_BKT_ADDR;

			! To determine the size of both keys, we will
			! need key buffers 3, 4, and 5.
			!
			KEYBUF3 = KEYBUF_ADDR(3);
			KEYBUF4 = KEYBUF_ADDR(4);
			KEYBUF5 = KEYBUF_ADDR(5);

			! Move the second key into key buffer 4 and compress
			! it as if it was to go at the point of insertion
			! instead of following the first key (which is to
			! be inserted there). Then recompress the second key
			! based upon the first key (which is still in key 
			! buffer 5).
			!
			RM$MOVE (.KEYBUF3[KEY_LEN] + 2,
				 .KEYBUF3,
				 .KEYBUF4);
			RM$COMPRESS_KEY (.KEYBUF4, .NOT_USED);

			SAVE_BKT_ADDR = .BKT_ADDR;
			BKT_ADDR = 0;
			RM$RECOMPR_KEY (.KEYBUF5, .KEYBUF4);
			BKT_ADDR = .SAVE_BKT_ADDR;

			! Add the size of the second key to the size of the
			! first key to obtain the key contribution to the
			! size of the record.
			!
			SIZE = .SIZE + .KEYBUF4[KEY_LEN] + 2;
		        END;
		    END;
		END;

	    ! Return the size of the record for prolog 3 index buckets as two
	    ! contigious words. The high order word contains the number of VBN
	    ! bytes required while the low order word contains the number of
	    ! bytes required to hold the key(s).
	    !
	    RETURN (.NEW_VBN_BYTES)^16 + .SIZE;
	    END;

    ! Return the size of the prolog 1 & 2 SIDR or index record as a single
    ! unified quantity.
    !
    RETURN .SIZE;
    END;


GLOBAL ROUTINE RM$ADD_TO_ARRAY : RL$ADD_TO_ARRAY NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! adds record pointer to existing SIDR array and updates size field
!
! CALLING SEQUENCE:
!	RM$ADD_TO_ARRAY()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	IRAB - pointer to internal RAB
!	    [ LST_REC ] - pointer to beginning of SIDR record being added to
!	    [ NRP_PTR ] - pointer to NRP list
!	    NRP [ RP_ID ]
!		[ RP_VBN ] - ID and VBN of UDR to put into record pointer
!	REC_ADDR - pointer to position of insert
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	REC_ADDR points to size field in record
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IRAB_STR,
	R_REC_ADDR_STR;

    LOCAL
	SIZE	: BYTE,
	VBN;

    VBN = .BBLOCK[.IRAB[IRB$L_NRP_PTR], NRP$L_RP_VBN];
    SIZE = RM$VBN_SIZE(.VBN);

    ! set pointer size field, insert ID and VBN
    !
    (.REC_ADDR)<0, 8> = .SIZE - 2;
    REC_ADDR = .REC_ADDR + 1;
    (.REC_ADDR)<0, 8> = .BBLOCK[.IRAB[IRB$L_NRP_PTR], NRP$W_RP_ID];
    REC_ADDR = .REC_ADDR + 1;
    (.REC_ADDR)<0, .SIZE*8> = .VBN;

    ! update size field for record
    !
    REC_ADDR = .IRAB[IRB$L_LST_REC];

    ! just in case we are leaving SIDR records around with no pointer arrays
    ! marked deleted, always mask off the deleted bit for the record
    !
    REC_ADDR[IRC$V_DELETED] = 0;

    ! position past record control byte, id, and dupes count field if present
    !
    !

    IF NOT .REC_ADDR[IRC$V_NOPTRSZ]
    THEN
	REC_ADDR = .REC_ADDR + .REC_ADDR[IRC$V_PTRSZ] + IRC$C_DATPTRBAS;

    REC_ADDR = .REC_ADDR + IRC$C_DATOVHDSZ;
    SIZE = .SIZE + 2;
    (.REC_ADDR)<0, 16> = .(.REC_ADDR)<0, 16> + .SIZE;
    END;


GLOBAL ROUTINE RM$BLD_NEW_SIDR (NEWID) : RL$BLD_NEW_SIDR NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! build a new SIDR record.
!
! CALLING SEQUENCE:
!	RM$BLD_NEW_SIDR (NEWID)
!
! INPUT PARAMETERS:
!	NEWID - ID to be assigned to new SIDR record
!
! IMPLICIT INPUTS:
!	IRAB [keybuf] - address of keybuffers
!
!	IFAB [kbufsz] - size of keybuffers
!
!	IDX_DFN [dupkeys] - flag if duplicate key values allowed
!		[cont_bkt] - flag if this is a continuation bucket
!		[keysz] - size of key field
!
!	REC_ADDR - address to build new record at
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	IRAB [lst_rec] - address of start of record (control byte)
!
!	REC_ADDR - address of end of record
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IRAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR;

    MAP
	NEWID	: WORD;

    ! set up LST_REC for ADD_TO_ARRAY later
    !
    IRAB[IRB$L_LST_REC] = .REC_ADDR;

    ! if duplicate keys are allowed on this index, a dupes count field will be
    ! present but not maintained.  if dupes not allowed, or this is a con
    ! tinuation bucket, then the noptrsz flag is set and no dupes count field
    ! will be present.
    !

    IF .IDX_DFN[IDX$V_DUPKEYS]
	AND
	NOT .IRAB[IRB$V_CONT_BKT]
    THEN
	BEGIN
	(.REC_ADDR)<0, 8> = 1;			! ptrsz = 1 (4 byte dupes count present)
	REC_ADDR = .REC_ADDR + 1;
	(.REC_ADDR)<0, 8> = .NEWID;		! store id of record
	REC_ADDR = .REC_ADDR + 1;
	(.REC_ADDR)<0, 32> = 0;			! clear dupes count field
	REC_ADDR = .REC_ADDR + 4;
	END
    ELSE
	BEGIN
	(.REC_ADDR)<0, 8> = IRC$M_NOPTRSZ;	! say no dupes count field
	REC_ADDR = .REC_ADDR + 1;
	(.REC_ADDR)<0, 8> = .NEWID;		! store record id
	REC_ADDR = .REC_ADDR + 1;
	END;

    ! initially set size to key size
    !
    (.REC_ADDR)<0, 16> = .IDX_DFN[IDX$B_KEYSZ];
    REC_ADDR = .REC_ADDR + 2;

    ! move in key from keybuf 2
    !
    REC_ADDR = CH$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(2), .REC_ADDR);
    RM$ADD_TO_ARRAY();
    END;


GLOBAL ROUTINE RM$MOVE_IN_VBN (VBN) : RL$MOVE_IN_VBN NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! set pointer size field and move in VBN, updating REC_ADDR
!
! CALLING SEQUENCE:
!	RM$MOVE_IN_VBN(VBN)
!
! INPUT PARAMETERS:
!	VBN - VBN to move in
!
! IMPLICIT INPUTS:
!	REC_ADDR - address to move value to
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR - points one byte beyond where value placed
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_REC_ADDR;

    BEGIN

    REGISTER
	SIZE = 1	: BYTE;

    ! get vbn size and set pointer field
    !
    SIZE = RM$VBN_SIZE(.VBN);
    (.REC_ADDR)<0, 8> = .SIZE - 2;
    REC_ADDR = .REC_ADDR + 1;

    ! stick in bucket pointer
    !
    (.REC_ADDR)<0, .SIZE*8> = .VBN;
    REC_ADDR = .REC_ADDR + .SIZE;
    END;
    END;


GLOBAL ROUTINE RM$BLD_IDX_REC (REC_SZ) : RL$BLD_IDX_REC NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine builds an index record in the buffer.  It will do one of the
! following:
!
!	0) Call RM$V3_IDX_REC to do everything for prologue three index
!	buckets.
!
!	1) replace key value of existing down pointer with the new high key
!	value (in keybuffer 2) of the original bucket (described as vbn_left)
!	and use that key value along with the value of vbn_right to create
!	a new index record pointing to the right hand bucket of the split.
!
!	2) same as the above except create another record between the two
!	described using the contents of keybuffer 3 and vbn_right.  this
!	record points to the middle record of a 3 or 4 bucket split.
!
!	3) as an option on the first situation (1), change the down
!	pointer to be the value of vbn_mid if the current down pointer matches
!	the value in vbn_left.
!
!	4) build only the left hand part of the possible pieces described above
!	and make the break just before the potential new middle bucket pointer.
!
!	5) build the part remaining after only doing 4).
!
! Any modifications to this code should be done only after thoroughly
! understanding the interactions between this routine, RM$RECORD_SIZE,
! and RM$SPLIT_EM.
!
! CALLING SEQUENCE:
!	RM$BLD_IDX_REC (REC_SZ)
!
! INPUT PARAMETERS:
!	REC_SZ	- total size of record to be inserted
!
! IMPLICIT INPUTS:
!	REC_ADDR - points to location in buffer where record is to be built
!
!	IRAB	[vbn_left] - left hand (original) bucket in split.  zero if
!			only right hand part of record to be built.
!		[vbn_mid] - possible middle bucket in 3 or 4 bucket split
!		[vbn_right] - right hand bucket of split
!		[empty_bkt] - left hand bucket is dead, i.e., no data records
!		[big_split] - more than 1 new bucket in split
!		[spl_idx] - only build left hand part of index record
!		[pos_ins] - position of insert of the new record
!		[keybuf] - address of keybuffers
!
!	IFAB	[kbufsz] - size of keybuffers
!
!	IDX_DFN	[keysz] - size of this key
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR - points to first byte beyond record.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_REC_ADDR_STR,
	R_IRAB_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR;

    IF .IFAB [IFB$B_PLG_VER] EQLU PLG$C_VER_3
    THEN

	! Prologue three index records. They basically
	! have nothing in common with pre-prologue three
	! index records. Just call the routine that
	! handles them and get out.
	!
	BEGIN

	RM$V3_IDX_REC (.REC_SZ);
	RETURN
	END;

    ! first key we have to build if present is the new key for the left
    ! hand bucket this will be zero only when splitting up index record when
    ! two new key values are required - currently 'empty' buckets (i.e.,
    ! buckets which end up without any records in them after a split) are not
    ! removed from the index
    !

    IF .IRAB[IRB$L_VBN_LEFT] NEQ 0
    THEN

	! the bucket has already been spread apart but the index record we
	! positioned to still exists where we found it, so using the existing
	! pointer, change the key value to the high key of VBN_LEFT
	!
	BEGIN

	! check for empty bucket situation, compare down pointers before
	! deciding whether to modify down pointer or not
	!

	IF .IRAB[IRB$V_EMPTY_BKT]
	THEN
	    BEGIN

	    BUILTIN
		AP;

	    AP = 1;				! set for index level

	    IF .IRAB[IRB$L_VBN_LEFT] EQLA RM$RECORD_VBN()

		! current down pointer matches so modify down pointer
		!
	    THEN
		RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_MID])
	    ELSE
		REC_ADDR = .REC_ADDR + .REC_ADDR[IRC$V_PTRSZ] + IRC$C_IDXPTRBAS
		+ IRC$C_IDXOVHDSZ;		! advance past pointer

	    IF NOT .IRAB[IRB$V_BIG_SPLIT]
	    THEN
		RETURN;				! no more to do, quit

	    END
	ELSE
	    REC_ADDR = .REC_ADDR + .REC_ADDR[IRC$V_PTRSZ] + IRC$C_IDXPTRBAS +
	    IRC$C_IDXOVHDSZ;

	! move in key from keybuffer 2
	!
	REC_ADDR = RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(2), .REC_ADDR);

	IF .IRAB[IRB$V_EMPTY_BKT]
	    AND
	    .IRAB[IRB$V_BIG_SPLIT]
	THEN
	    BEGIN
	    RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_RIGHT]);
	    RETURN

	    END;

	END;

    ! At this point all bucket splits involving empty buckets have completed.
    ! We continue for all other cases with one exception. When the insertion 
    ! point is found to be at the split point, two passes must be made - one
    ! to update the old bucket, and the second to update the new bucket. If
    ! this is the first pass to update the old bucket components we do not
    ! continue unless a multibucket split had occurred, two and only two
    ! index records could fit in an index bucket, and the split point requires
    ! both of them to be moved to the new bucket to make room for the two new 
    ! index records. In all other "first pass" situations we do not continue.
    !
    IF NOT .IRAB[IRB$V_SPL_IDX]
	OR
       (.IRAB[IRB$V_SPL_IDX] 
	    AND .IRAB[IRB$V_BIG_SPLIT]
	    AND .IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ)
    THEN
	BEGIN

	! If a multibucket split occurred, the middle VBN and its corresponding
	! key are inserted into the current index bucket with one exception.
	! If this is the second pass of a two-pass multibucket split case where
	! both records had to be put in the old index bucket, this bucket
	! updating does not take place.
	!
	IF .IRAB[IRB$V_BIG_SPLIT]
	    AND
	   (.IRAB[IRB$L_VBN_MID] NEQU 0)
	THEN
	    BEGIN
	    RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_MID]);

	    ! move in key from keybuffer 3
	    !
	    REC_ADDR = RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], 
		KEYBUF_ADDR(3), .REC_ADDR);
	    END;

	! Unless this is the first pass of one of the three two-pass index
	! bucket split cases, we always swing the pointer for VBN right.
	! If this is the first of two passes, we do not swing the pointer
	! because this pass is used to update the old index bucket components
	! and VBN_RIGHT must be swung during the second pass when the new
	! index components are updated.
	!
	IF NOT .IRAB[IRB$V_SPL_IDX]
	THEN RM$MOVE_IN_VBN(.IRAB[IRB$L_VBN_RIGHT]);
	END;

    END;


GLOBAL ROUTINE RM$BKT_SORT (BKT_ADDR) : RL$BKT_SORT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! this routine scans the bucket, makes a table of all used ID's,
! and then updates the NXTRECID and LSTRECID fields to reflect the existence
! of the lowest range of un-used ID's available.
!
! CALLING SEQUENCE:
!	RM$BKT_SORT (BKT_ADDR)
!
! INPUT PARAMETERS:
!	BKT_ADDR - pointer to bucket to be searched for ID's
!
! IMPLICIT INPUTS:
!	IDX_DFN - pointer to index descriptor
!	IRAB - pointer to internal RAB
!	IFAB - IFAB
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	low bit set if success (at least one ID was found)
!	low bit clear if all ID's in use
!
! SIDE EFFECTS:
!	NXTRECID is set to lowest ID available
!	LSTRECID is set to highest contiguous ID available after NXTRECID
!
!--

    BEGIN

    MAP
	BKT_ADDR	: REF BBLOCK;

    EXTERNAL REGISTER
	R_IDX_DFN,
	R_IFAB,
	R_IRAB;

    GLOBAL REGISTER
	R_REC_ADDR_STR;

    LOCAL
	BIT_NUM,
	BIT_LEN;

    ! create 8 longword array for table of used ID's
    !

    STACKLOCAL
	USED_IDS	: VECTOR [8];

    LOCAL
	EOB;

    DECR I FROM 7 TO 0 DO
	USED_IDS[.I] = 0;

    BEGIN

    MAP
	USED_IDS	: BITVECTOR [256];

    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    EOB = .BKT_ADDR[BKT$W_FREESPACE] + .BKT_ADDR;

    ! scan records in bucket.  set bit in bitvector for those id values found.
    !
    WHILE .REC_ADDR LSSA .EOB
    DO
	BEGIN
	USED_IDS[.REC_ADDR[IRC$B_ID]] = 1;
	RM$GETNEXT_REC();
	END;

    USED_IDS[0] = 0;				! flag set when a free id found
    USED_IDS[255] = 1;				! make sure last one always set
    END;					! of USED_IDS as bitvector
    BIT_LEN = 31;
    BIT_NUM = 1;

    ! now search the bit array for the first clear bit (that corresponds to
    ! an unused id value) one longword at a time.  when found, check the
    ! remaining bits in that longword looking for a used id.  if none found
    ! there, continue searching the remaining longwords in the array to
    ! determine the extent of the unused id values.
    !
    INCR I FROM 0 TO 7 DO

	IF NOT .USED_IDS
	THEN
	    BEGIN

	    IF NOT FFC(BIT_NUM, BIT_LEN, USED_IDS[.I], BIT_NUM)
	    THEN
		BEGIN
		BKT_ADDR[BKT$B_NXTRECID] = .I*32 + .BIT_NUM;
		USED_IDS<0, 1> = 1;
		BIT_LEN = 32 - .BIT_NUM;

		IF NOT FFS(BIT_NUM, BIT_LEN, USED_IDS[.I], BIT_NUM)
		THEN
		    BEGIN
		    BKT_ADDR[BKT$B_LSTRECID] = .I*32 + .BIT_NUM - 1;
		    EXITLOOP;

		    END
		ELSE
		    BIT_LEN = 32;

		END;

	    BIT_NUM = 0;
	    END
	ELSE

	    IF NOT FFS(BIT_NUM, BIT_LEN, USED_IDS[.I], BIT_NUM)
	    THEN
		BEGIN
		BKT_ADDR[BKT$B_LSTRECID] = .I*32 + .BIT_NUM - 1;
		EXITLOOP;

		END
	    ELSE
		BEGIN
		BIT_LEN = 32;
		BIT_NUM = 0;
		END;

    ! if this is clear, no free id's were found.  if set, at least one
    ! is available.
    !
    RETURN .USED_IDS[0];

    END;


GLOBAL ROUTINE RM$INS_REC (BUCKET, REC_SZ) : RL$INS_REC =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Insert new record into bucket.  Check for ID availability if required,
! make room by spreading existing records apart, and call appropriate
! routine to build the record.
!
! CALLING SEQUENCE:
!	RM$INS_REC (BKT_ADDR, REC_SZ)
!
! INPUT PARAMETERS:
!	BKT_ADDR - address of bucket in which to insert record
!	
!	REC_SZ - total size of record to be inserted
!
! IMPLICIT INPUTS:
!	REC_ADDR - is where to build the record
!
!	IRAB - internal stream context
!	    [dups_seen] - this is a duplicate record
!	    [spl_idx] - left hand part only of index record
!	    [pos_ins] - offset to position of insert
!
!	IFAB - internal file context, used by called routines
!
!	IDX_DFN - index descriptor, used by called routines
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	success
!	low bit clear if no id's available
!
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_REC_ADDR_STR,
	R_IRAB_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR;

    GLOBAL REGISTER
  	R_BKT_ADDR_STR;

    LOCAL
	TEMP	: BBLOCK [6];

    MACRO
	OLD_OVHD 	= TEMP[0,0,16,0] %,
	LENGTH 		= TEMP[2,0,32,0] %,
	KEY_SZ		= REC_SZ<0,16> %,
	VBN_SZ		= REC_SZ<16,16>%;

    BKT_ADDR = .BUCKET;

    OLD_OVHD = 0;

    IF .IFAB [IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN

	BEGIN

	IF .BKT_ADDR [BKT$B_LEVEL] EQL 0
	THEN
	    BEGIN

	    IF NOT .IRAB[IRB$V_DUPS_SEEN]
		    AND
			(.BKT_ADDR [BKT$B_NXTRECID] EQL 0
			OR
			(.BKT_ADDR [BKT$B_NXTRECID] GTRU .BKT_ADDR [BKT$B_LSTRECID]))
	    THEN

		RETURN_ON_ERROR (RM$BKT_SORT(.BKT_ADDR));

	    END
	ELSE

	    IF NOT .IRAB[IRB$V_SPL_IDX]
	    THEN
		OLD_OVHD = .REC_ADDR[IRC$V_PTRSZ] + IRC$C_IDXPTRBAS +
			    IRC$C_IDXOVHDSZ;
	END;

    ! figure out length of data to move and do it if non-zer0 - it will
    ! be zer0 when SIDR record is being inserted at the end of the bucket
    !
    !
    LENGTH = .BKT_ADDR[BKT$W_FREESPACE] - .IRAB[IRB$W_POS_INS] - .OLD_OVHD;

    IF (.LENGTH GTR 0)
	AND
       (.KEY_SZ GTR 0)
    THEN
	RM$MOVE(.LENGTH, .REC_ADDR + .OLD_OVHD,
	    .REC_ADDR + .KEY_SZ + .OLD_OVHD);

    ! update the freespace pointer to reflect new size of data area
    !
    BKT_ADDR [BKT$W_FREESPACE] = .BKT_ADDR [BKT$W_FREESPACE] + .KEY_SZ;

    IF .IFAB [IFB$B_PLG_VER] GEQU PLG$C_VER_3
    THEN

	! We must spread apart the VBN list, also.
	!

	RM$SHFT_VBNS();

    IF .BKT_ADDR [BKT$B_LEVEL] NEQ 0
    THEN
	BEGIN

	! insert new index record and return success
	!
	RM$BLD_IDX_REC (.REC_SZ);
	RETURN 1

	END;

    ! if duplicates seen then we simply have to add an element to array
    !
    !

    IF .IRAB[IRB$V_DUPS_SEEN]
    THEN
	RM$ADD_TO_ARRAY()
    ELSE

	! no duplicates then we must create a new record including new ID's
	!
	!
	BEGIN
	RM$BLD_NEW_SIDR(.BKT_ADDR [BKT$B_NXTRECID]);
	BKT_ADDR [BKT$B_NXTRECID] = .BKT_ADDR [BKT$B_NXTRECID] + 1
	END;

    RETURN 1

    END;

ROUTINE RM$SHFT_VBNS : RL$SHFT_VBNS NOVALUE =

!++
! 
!   RM$SHFT_VBNS
!
!	Spread the VBNs at the end of the bucket to make room for
!	the new VBN(s).
!
!	This routine handles the following conditions:
!		
!		1) two bucket split, no empty buckets
!		2) two bucket split, empty bucket
!		3) multi-bucket split (three or four), no empty buckets
!		4) multi-bucket split, empty buckets
!
!	The two-pass bucket split cases which occur when the insertion
!	point is found to be the same as the buckety split point are
!	handled as follows:
!
!		5) first pass two bucket split    - treated as 1)
!		6) second pass two bucket split   - treated as 2)
!		   first pass multi-bucket split
!		7) 	one in each bucket	  - treated as 4)
!		8)	both in old bucket	  - treated as 3)
!		   second pass multi-bucket split
!		9)	one in each bucket	  - treated as 4)
!	       10)	both in old bucket	  - treated as 2)
!	
!	In all cases it assumes that the new VBNs will be the same size
!	as the current VBNs. If they actually are larger, the routine that
!	inserts them will have to grow each one individually.
!
!    INPUT
!
!	none
!
!    IMPLICIT INPUT
!
!	IRAB
!	    [EMPTY_BUCKET]
!	    [BIG_SPLIT]
!	    [VBN_LEFT]
!	    [VBN_MID]
!	    [SPL_IDX]
!	    [POS_INS]
!	BKT_ADDR
!
!    OUTPUT
!
!	none
!
!    IMPLICIT OUTPUT
!
!	The VBN chain is spread apart and ready to insert new VBNs
!
!---
BEGIN

EXTERNAL REGISTER
    R_REC_ADDR_STR,
    R_BKT_ADDR_STR,
    R_IRAB_STR,
    R_IDX_DFN_STR,
    R_IFAB_STR;

MACRO
    OFFSET = 0,0,16,0 %;

LOCAL
    FREE_SPACE : REF BBLOCK, ! Address of offset to VBN freespace
    LENGTH,		! Number of bytes to move
    SWING_FLG,		! Logical - so we don't have to check swing conditions
			!	    every time around
    INS_ADDR,		! Address where the new VBN will be inserted
    NUM_BYTES;		! Number of bytes which will be inserted

! The swing flag is set under the following bucket split cases:
!
!	1. All empty bucket split cases			 
!	2. First pass multibucket split cases where one key goes 
!	   in each of the two index buckets
!	3. All second pass bucket split cases
!    
SWING_FLG = 0;
IF (.IRAB [IRB$V_EMPTY_BKT] 
		AND .IRAB [IRB$L_VBN_LEFT] EQLA RM$V3_VBN())
    OR
   (.IRAB[IRB$L_VBN_LEFT] EQLU 0)
    OR
   (.IRAB[IRB$V_SPL_IDX]
		AND .IRAB[IRB$V_BIG_SPLIT]
		AND .IRAB[IRB$W_POS_INS] NEQU BKT$C_OVERHDSZ)
THEN
    SWING_FLG = 1;

! Assume a two bucket split with no empties
!
INS_ADDR = RM$CNTRL_ADDR();
NUM_BYTES = .BKT_ADDR [BKT$V_PTR_SZ] + 2;

! Consider all nonmultibucket cases, and the second pass of the multibucket
! case where both index records go in the same (old) index bucket.
!
IF (NOT .IRAB [IRB$V_BIG_SPLIT])
    OR
   (.IRAB[IRB$L_VBN_MID] EQLA 0)
THEN
    BEGIN

    IF .SWING_FLG
    THEN

	! For cases 2, 6, and 10 - just update the VBN in place
	!
	NUM_BYTES = 0;
    END

	! For cases 1, and 5 - shift the VBNs to make room for 1 new VBN
	!

! Consider all multibucket cases except case 10 handled above
!
ELSE

    IF NOT .SWING_FLG
    THEN

	! For cases 3, and 8 - shift the VBNs to make room for 2 new VBNs
	!
	NUM_BYTES = .NUM_BYTES * 2;

	! For cases 4, 7, and 9 - shift the VBNs to make room for 1 new VBN
	! Cases 4, and 9 will also update one VBN in place
	!

! Now actually shift the VBN chain provided at least one VBN is being added
! and it is not being added to the end of the chain (ie the index record(s)
! to be added do not have key values higher than all index records currently
! in the bucket)
!
FREE_SPACE = .BKT_ADDR + (.IDX_DFN[IDX$B_IDXBKTSZ] * 512) - BKT$C_ENDOVHD;
LENGTH = .INS_ADDR - (.BKT_ADDR + .FREE_SPACE [OFFSET]);

IF (.LENGTH GTR 0)
    AND
   (.NUM_BYTES GTR 0)
THEN
    RM$MOVE (.LENGTH, .BKT_ADDR + .FREE_SPACE [OFFSET],
		.BKT_ADDR + .FREE_SPACE [OFFSET] - .NUM_BYTES);

! Update the free space pointer.
!
FREE_SPACE [OFFSET] = .FREE_SPACE [OFFSET] - .NUM_BYTES;
END;


GLOBAL ROUTINE RM$FOOLED_YUH : RL$FOOLED_YUH =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! routine to do all the probing, etc. to make sure the user hasn't
! been fooling around w/ rsz, rbf or the buffer describing his record
! between the time i started to position for insert and i go to insert
!
!
! CALLING SEQUENCE:
!	bsbw rm$fooled_yuh
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	irab -- mode, address of internal key buffer to check against
!	IFAB -- kbufsz
!	rab -- rsz, rbf
!	idx_dfn -- minrecsz, keysz
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	rmssuc if the user has been considerate
!	rsz or rbf if not
!
! SIDE EFFECTS:
!	ap is clobbered
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_IRAB_STR,
	R_RAB_STR,
	R_IDX_DFN_STR;

    LOCAL
	RBF_ADDR,
	STATUS;

    BUILTIN
	AP;

    ! do all the probing and comparing to make sure the user hasn't been
    ! fooling around w/ the record buffer
    !

    IF .RAB[RAB$W_RSZ] LSSU .IDX_DFN[IDX$W_MINRECSZ]
    THEN
	RETURN RMSERR(RSZ);

    RBF_ADDR = .RAB[RAB$L_RBF];
    IF RM$NOREAD_LONG(.RAB[RAB$W_RSZ], .RBF_ADDR, .IRAB[IRB$B_MODE])
    THEN
	RETURN RMSERR(RBF);

    AP = 2;

    ! If keys do not match, return error
    !

    IF RM$COMPARE_KEY(.RBF_ADDR,
		KEYBUF_ADDR(3),
		.IDX_DFN[IDX$B_KEYSZ])
    THEN
	RETURN RMSERR(RBF);

    RETURN RMSSUC()

    END;

ROUTINE RM$V3KEY_SZ (KEY_ADDR) : RL$V3KEY_SZ =

!++
!
! RM$V3KEY_SZ
!
!     This routine computes the number of chars needed to store the
!    prologue three key in KEY_ADDR at REC_ADDR.
!
! CALLING SEQUENCE:
!	RM$V3KEY_SZ (KEY_ADDR);
!
! INPUT PARAMETERS:
!	KEY_ADDR - Address of the key to be inserted
!
! IMPLICIT INPUTS:
!	BKT_ADDR - Pointer to the current bucket
!	IDX_DFN  - Pointer to index descriptor structure
!	IFAB	 - Pointer to internal FAB
!	IRAB	 - Pointer to Internal RAB
!	REC_ADDR - Address to insert key
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
!	R0 - number of bytes needed to store the key after front compression
!	     and rear-end truncation (doesn't include two bytes of overhead).
!
!--
BEGIN

MAP
    KEY_ADDR : REF BBLOCK;

EXTERNAL REGISTER
    R_BKT_ADDR_STR,
    R_IDX_DFN_STR,
    R_REC_ADDR_STR,
    R_IFAB_STR,
    R_IRAB_STR;

LOCAL
    KEYBUF	: REF BBLOCK,
    NOT_USED;

IF .BKT_ADDR [BKT$B_LEVEL] EQLU 0
	AND .IDX_DFN [IDX$B_KEYREF] EQLU 0
THEN

    ! Primary data level
    !
    BEGIN

    IF NOT .IDX_DFN [IDX$V_KEY_COMPR]
    THEN
	RETURN .IDX_DFN [IDX$B_KEYSZ];
    END

ELSE

    ! SIDR or index level
    !
    BEGIN

    ! Noncompressed key.
    !
    IF NOT .IDX_DFN [IDX$V_IDX_COMPR]
    THEN
	RETURN .IDX_DFN [IDX$B_KEYSZ];
    END;

! Must be a compressed key. Move key into keybuffer 5, compress it, and
! return its size (not including the two byte of compression overhead).
! 
KEYBUF = KEYBUF_ADDR(5);
RM$MOVE (.KEY_ADDR[KEY_LEN] + 2, .KEY_ADDR, .KEYBUF);

RM$COMPRESS_KEY (.KEYBUF, .NOT_USED);

RETURN .KEYBUF[KEY_LEN];
END;

GLOBAL ROUTINE RM$NEW_VBN_BYTES (VBN_SIZE) : RL$NEW_VBN_BYTES =
!++
!
! RM$NEW_VBN_BYTES
!
!    This routine returns the number of additional bytes which will
!    be needed if all the VBNs grow to VBN_SIZE
!
! CALLING SEQUENCE:
!
!	RM$NEW_VBN_BYTES (VBN_SIZE)
!
! INPUT PARAMETERS:
!	
!	VBN_SIZE - potential number of bytes per VBN
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR -  address of current bucket
!	IDX_DFN  -  index descriptor structure
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!
!	R0 - number of new bytes which will be needed if all the
!	     VBNs in the bucket grow to be VBN_SIZE long
!
!--
BEGIN

MACRO
    FREESPC	= 0,0,16,0 %;

GLOBAL REGISTER
    R_BKT_ADDR_STR,
    R_IDX_DFN_STR;

LOCAL
    CUR_VBN_SZ,
    FIRST_VBN	: REF BBLOCK,
    NUM_VBNS;

CUR_VBN_SZ = .BKT_ADDR [BKT$V_PTR_SZ] + 2;
IF .VBN_SIZE LEQU .CUR_VBN_SZ
THEN

    ! VBNs didn't grow 
    !
    RETURN 0;

! Number of new bytes = (new_size - old_size) * num_vbns
!
FIRST_VBN = .BKT_ADDR + (.IDX_DFN [IDX$B_IDXBKTSZ] * 512) - BKT$C_ENDOVHD;
NUM_VBNS = (.FIRST_VBN - (.BKT_ADDR + .FIRST_VBN [FREESPC]))/ (.BKT_ADDR [BKT$V_PTR_SZ] + 2);
RETURN (.VBN_SIZE - .CUR_VBN_SZ) * .NUM_VBNS;
END;

ROUTINE RM$ADD_V3VBN (VBN) : RL$V3_IDX_REC NOVALUE =
!++
!
! RM$ADD_V3VBN
!
!	This routine adds a VBN to the chain at the end of the bucket.
!	If the VBN is longer than the current VBN size all VBNs grow
!	by the appropriate number of bytes.
!
! CALLING SEQUENCE:
!
!	RM$ADD_V3VBN(.VBN)
!
! IMPLICIT INPUTS:
!	IRAB
!	BKT_ADDR
!	IDX_DFN
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!
! ROUTINE VALUE:
!
!	NONE
!
!--
BEGIN

MACRO
    OFFSET = 0,0,16,0 %;

EXTERNAL REGISTER
    R_IDX_DFN_STR,
    R_IRAB_STR,
    R_REC_ADDR_STR,
    R_IFAB_STR,
    R_BKT_ADDR_STR;

LOCAL
    NEW_SIZE,
    OLD_SIZE;

NEW_SIZE = RM$VBN_SIZE (.VBN);
OLD_SIZE = .BKT_ADDR [BKT$V_PTR_SZ] + 2;

IF .NEW_SIZE GTRU .OLD_SIZE
THEN

    ! We need to shuffle all of the VBNs down
    ! First figure out where to move them.
    !
    BEGIN

    LOCAL
	OLD_END	: REF BBLOCK,
	NUM_RECS,
	NEW_END,
	SAVE;

    OLD_END = .BKT_ADDR  + (.IDX_DFN [IDX$B_IDXBKTSZ] * 512) - BKT$C_ENDOVHD;
    NUM_RECS = (.OLD_END - (.BKT_ADDR+.OLD_END [OFFSET])) / .OLD_SIZE;
    NEW_END = .OLD_END - (.NUM_RECS * .NEW_SIZE);

    IF .BKT_ADDR [BKT$B_LEVEL] EQLU 0
	AND .IDX_DFN [IDX$V_DUPKEYS]
    THEN
	NEW_END = .NEW_END - 4;

    OLD_END [OFFSET] = .NEW_END - .BKT_ADDR - 1;

    ! Now actually move them
    !
    SAVE = .IRAB [IRB$L_REC_COUNT];
    IRAB [IRB$L_REC_COUNT] = .NUM_RECS - 1;

    WHILE .IRAB [IRB$L_REC_COUNT] GEQ 0
    DO
	BEGIN

	(.NEW_END) <0,8 * .NEW_SIZE> = .(RM$CNTRL_ADDR())<0,8*.OLD_SIZE>;
	IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] - 1;
	NEW_END = .NEW_END + .NEW_SIZE;
	END;

    IRAB [IRB$L_REC_COUNT] = .SAVE;

    ! Update the VBN size
    !
    BKT_ADDR [BKT$V_PTR_SZ] = .NEW_SIZE - 2;
    END;

! Actually add the new VBN
!
BEGIN

LOCAL
    ADDR;

ADDR = RM$CNTRL_ADDR();
(.ADDR) <0,.NEW_SIZE * 8> = .VBN;
END; ! Of local ADDR
END;
    

ROUTINE RM$ADD_V3KEY (KEY_ADDR) : RL$V3_IDX_REC NOVALUE =
!++
!
! RM$ADD_V3KEY
!
!	This routine inserts the key at KEY_ADDR into the bucket at REC_ADDR
!	The contents of the bucket have already been spread apart. The
!	trailing record is recompressed if necessary.
!
! CALLING SEQUENCE:
!
!	RM$ADD_V3KEY()
!
! IMPLICIT INPUTS:
!	IFAB
!	REC_ADDR
!	BKT_ADDR
!	IDX_DFN
!	IRAB[IRB$V_BIG_SPLIT]
!	IRAB[IRB$V_EMPTY_BKT]
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	REC_ADDR points past the inserted key
!	IRAB[IRB$L_LST_NCMP] may possibly be updated
!
! ROUTINE VALUE:
!
!	NONE
!
!--
BEGIN

MAP
    KEY_ADDR : REF BBLOCK;

EXTERNAL REGISTER
    R_IDX_DFN_STR,
    R_IFAB_STR,
    R_REC_ADDR_STR,
    R_BKT_ADDR_STR,
    R_IRAB_STR;

LOCAL
    NOT_USED;

IF NOT .IDX_DFN [IDX$V_IDX_COMPR]
THEN

    ! Fixed length index key.
    !
    BEGIN

    REC_ADDR = RM$MOVE (.IDX_DFN [IDX$B_KEYSZ], .KEY_ADDR, .REC_ADDR);
    RETURN
    END;

! Compressed index key
! First fill in the length and compression count
!
RM$COMPRESS_KEY (.KEY_ADDR, .NOT_USED);

! Now move in the new key including the two bytes of compression overhead.
!
RM$MOVE (.KEY_ADDR[KEY_LEN] + 2,
	 .KEY_ADDR,
	 .REC_ADDR);

! Fix up next record (front compression might change). This will be done
! only when a single a key is to be added, or when the second of two keys
! is being added. A key must also trail the key just inserted for this
! recompression to be performed.
!
IF (NOT .IRAB[IRB$V_BIG_SPLIT] OR  .IRAB[IRB$V_EMPTY_BKT])
   AND
   (.REC_ADDR + .REC_ADDR[KEY_LEN] + 2 
		LSSU .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE])
THEN 
    RM$RECOMPR_KEY (.REC_ADDR, .REC_ADDR + .REC_ADDR [KEY_LEN] + 2);

! If the key to be added is the first of two keys (from a multibucket split)
! and the front compression of the key just added is 0, increment the pointer
! to the last noncompressed key to this key to make the determination of the
! front compression of the second of the two keys easier.
!
IF .IRAB[IRB$V_BIG_SPLIT]
   AND
   (.REC_ADDR[CMPR_CNT] EQLU 0)
THEN IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

! Reset REC_ADDR to point to the key which follows the key(s) just inserted
!
REC_ADDR = .REC_ADDR + .REC_ADDR [KEY_LEN] + 2;
RETURN
END;

ROUTINE RM$V3_IDX_REC (REC_SZ) : RL$V3_IDX_REC NOVALUE =
!++
!
! RM$V3_IDX_REC
!
!	This routine builds a new prologue three index record. It does 
!	one of the following
!
!		2) Change a VBN (swing pointer because of empty bucket)
!		3) Add a key and VBN
!		4) Add an additional key and VBN
!
! CALLING SEQUENCE:
!
!	RM$V3_KEY_REC (REC_SZ)
!
! INPUT PARAMETERS:
!	REC_SZ	- total size of record to be inserted
!
! IMPLICIT INPUTS:
!	IRAB
!	REC_ADDR
!	BKT_ADDR
!	IDX_DFN
!	IRAB[IRB$V_SPL_IDX]
!	IRAB[IRB$V_EMPTY_BKT]
!	IRAB[IRB$B_BIG_SPLIT]
!	IRAB[IRB$W_POS_INS]
!	IRAB[IRB$L_VBN_LEFT]
!	IRAB[IRB$L_VBN_MID]
!
! OUTPUT PARAMETERS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	REC_ADDR is updated to point past the record(s) inserted
!	REC_COUNT is incremented by the number of VBN's inserted
!
!
! ROUTINE VALUE:
!
!	NONE
!
!--
BEGIN

EXTERNAL REGISTER
    R_IRAB_STR,
    R_IFAB_STR,
    R_IDX_DFN_STR,
    R_REC_ADDR_STR,
    R_BKT_ADDR_STR;

LOCAL
    SAVE_REC_ADDR;

MACRO
    KEY_SZ		= REC_SZ<0,16> %,
    VBN_SZ		= REC_SZ<16,16>%;

! Handle all empty bucket cases
!
IF .IRAB [IRB$V_EMPTY_BKT]
    AND .IRAB [IRB$L_VBN_LEFT] EQLA RM$V3_VBN()
THEN

    BEGIN

    ! Just change the VBN
    !
    RM$ADD_V3VBN(.IRAB [IRB$L_VBN_MID]);
    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] + 1;

    IF NOT .IRAB [IRB$V_BIG_SPLIT]
    THEN
	RETURN;

    ! If there was a multibucket split involving empty buckets both a key
    ! and a VBN must be added.
    !
    RM$ADD_V3VBN(.IRAB [IRB$L_VBN_RIGHT]);
    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] + 1;
    RM$ADD_V3KEY(KEYBUF_ADDR(2));
    RETURN;
    END;

! Handle all split cases not involving empty buckets.
!
! We will always add at least one key provided this is not the second pass
! of one of the three two-pass bucket split cases. If this is one of those
! three cases, the key we always add was added during the first pass when the
! old index bucket contents were updated, and should not be again added during
! this update of the new index bucket contents.
!
SAVE_REC_ADDR = .REC_ADDR;
IF .IRAB[IRB$L_VBN_LEFT] NEQU 0
THEN
    RM$ADD_V3KEY (KEYBUF_ADDR(2));

! On a multibucket split, the key which will trail the two keys added must
! be recompressed based on the first of the two keys added. This recompression
! is not done if the keys being added are being added to the end of the index
! bucket (no trailing key), if the multibucket split case is the two-pass case
! where a key is added to each of the two index buckets and this is either of
! the two passes, or if index compression is not enabled (of course).
!
IF (.IRAB[IRB$V_BIG_SPLIT]
	AND NOT .IRAB[IRB$V_SPL_IDX]
	AND .IRAB[IRB$L_VBN_LEFT] NEQU 0)
    AND
   (.IDX_DFN[IDX$V_IDX_COMPR]
	AND (.SAVE_REC_ADDR + .KEY_SZ LSSA .BKT_ADDR +
					   .BKT_ADDR[BKT$W_FREESPACE]))
THEN 
    RM$RECOMPR_KEY (.SAVE_REC_ADDR , .SAVE_REC_ADDR + .KEY_SZ);

! A key and VBN must be added for all multibucket split cases. For the one-
! pass multibucket split case and the two-pass multibucket split case this
! key is the second of two keys to be added during this current pass and the 
! first VBN. For the latter case, both keys and the VBN get added during the 
! first pass and none get added during the second pass. For the two-pass
! multibucket split case where a key is inserted in each of the old and new
! index buckets, this key and its corresponding VBN are inserted as the low
! order key in the new index bucket during the second pass having inserted
! the first key in the old index bucket during the first pass.
!
IF .IRAB [IRB$V_BIG_SPLIT]
   AND
       ((NOT .IRAB[IRB$V_SPL_IDX] 
		AND .IRAB[IRB$L_VBN_MID] NEQU 0)
	OR
	(.IRAB[IRB$V_SPL_IDX] 
		AND .IRAB[IRB$W_POS_INS] EQLU BKT$C_OVERHDSZ))
THEN
    BEGIN
    IF .IRAB[IRB$L_VBN_LEFT] NEQU 0
    THEN 
	IRAB[IRB$L_REC_COUNT] = .IRAB[IRB$L_REC_COUNT] + 1;
    RM$ADD_V3VBN (.IRAB[IRB$L_VBN_MID]);

    IRAB[IRB$V_BIG_SPLIT] = 0;
    RM$ADD_V3KEY (KEYBUF_ADDR(3));
    IRAB[IRB$V_BIG_SPLIT] = 1;
    END;

! A VBN update is always required for one-pass bucket split cases. This is
! because the VBN pointer of at least one of the index records on the current 
! level has changed because of the split at the level below it. For all 
! two-pass bucket split cases, this VBN updating must also take place, for the
! same reason. However, it always takes place during the second of the two 
! passes when the contents of the new index bucket are being modified since it
! it is the VBN pointer of one of those index records that has changed.
IF NOT .IRAB[IRB$V_SPL_IDX]
THEN
    BEGIN
    IF (.IRAB[IRB$L_VBN_LEFT] NEQU 0)
	OR
       (.IRAB[IRB$L_VBN_MID] NEQU 0)
    THEN
	IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] + 1;
    RM$ADD_V3VBN (.IRAB [IRB$L_VBN_RIGHT]);
    END;

END;

GLOBAL ROUTINE RM$MOVE_SIG_CNT(IN_KEY,BKT_ADDR,FLAG) : RL$MOVE_SIG_CNT NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Move the count of significant characters between the last key of the current
! bucket, and the first key of the next bucket to the end of the bucket.
!
! CALLING SEQUENCE:
!	RM$MOVE_SIG_CNT(IN_KEY,BKT_ADDR,FLAG)
!
! INPUT PARAMETERS:
!	IN_KEY - is either a key buffer, or bucket which contains the
!		 significant count we want to store in the bucket
!	BKT_ADDR - address of bucket to write count to
!	FLAG - indicates if IN_KEY is a key buffer, or bucket address
!		1 - bucket address
!		0 - key buffer or key size
!
! IMPLICIT INPUTS:
!	IDX_DFN - index descriptor for bucket size
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	The bucket has the right number of significant characters stored.
!
! ROUTINE VALUE:
!	number of bytes needed to describe VBN
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IDX_DFN_STR;

    LOCAL
	NEW_EOB :	REF BBLOCK,
	OLD_EOB :	REF BBLOCK;

    MACRO
	SIG_CNT = 0,0,8,0 %;

    ! Position to where significant count should be copied
    !
    NEW_EOB = .BKT_ADDR + .IDX_DFN[IDX$B_DATBKTSZ] * 512 - 2;

    IF .FLAG
    THEN
	BEGIN
	OLD_EOB = .IN_KEY + .IDX_DFN[IDX$B_DATBKTSZ] * 512 - 2;
	NEW_EOB[SIG_CNT] = .OLD_EOB[SIG_CNT];
	END
    ELSE
	NEW_EOB[SIG_CNT] = .(.IN_KEY)<0,8>;

    END;

END

ELUDOM
