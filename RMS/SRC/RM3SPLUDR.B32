
MODULE RM3SPLUDR (LANGUAGE (BLISS32) ,
		IDENT = 'V03-002'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                split user data record buckets
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Wendy Koenig     CREATION DATE:        	5-JUL-78  14:46
!
!
! MODIFIED BY:
!
!	V03-002	MCN0004		Maria del C. Nasr	31-Mar-1982
!		Do not count records that will not need rrv's when moved out
!		of the bucket.  Their id's cannot be recycled in plg 3 files.
!
!	V03-001	MCN0003		Maria del C. Nasr	25-Mar-1982
!		Use macro to calculate keybuffer address.
!
!	V02-016	DJD0001		Darrell Duffy		1-March-1982
!		Fix references to RBF for better probing
!
!	V02-015	MCN0002		Maria del C. Nasr	09-Jul-1981
!		Fix a problem with update of the first record in a duplicate
!		chain, in both old code, and new code.  Also fix problem in
!		new code with non-compressed keys.
!
!	V02-014	MCN0001		Maria del C. Nasr	02-Jun-1981
!		Add the routine to split prologue 3 data buckets.
!
!	V02-013	REFORMAT	Ron Schaefer		23-Jul-1980  14:10
!		Reformat the source
!
!	V02-012	CDS0000		Christian Saether,	01-Jan-1980  15:00
!   		FIX PROBLEM WHEN SPLITTING BECAUSE OUT OF ID'S.
!
! REVISION HISTORY:
!
!   Wendy Koenig, 	18-SEP-78  16:53
!   X0002 - FIX BUG IN BACKING UP PAST NEW RECORD
!
!   Wendy Koenig, 	19-SEP-78  10:52
!   X0003 - DO SPLIT AT POINT OF INSERT IF ASCENDING ORDER DETECTED
!
!   Wendy Koenig, 	12-OCT-78  13:21
!   X0004 - CHANGES FOR UPDATE
!
!   Wendy Koenig, 	18-OCT-78  14:03
!   X0005 - IF WE PASS BY POS_INSERT WHILE SKIPPING OVER DUPS, NOTE IT
!
!   Wendy Koenig, 	18-OCT-78  14:37
!   X0006 - FIX SOME PROBLEMS W/ 4-BKT SPLIT ($UPDATE ONLY)
!
!   Wendy Koenig, 	24-OCT-78  14:03
!   X0007 - MAKE CHANGES CAUSED BY SHARING CONVENTIONS
!
!   Wendy Koenig, 	7-NOV-78  8:58
!   X0008 - FIX EMPTY_BKT BUG, NOT BEING SET WHEN SHOULD BE
!
!   Wendy Koenig, 	22-JAN-79  17:03
!   X0009 - IF LOA TRIES TO FORCE US TO SPLIT ALL DUPS, SPLIT AT POS_INS
!
!   Wendy Koenig, 	24-JAN-79  9:51
!   X0010 - CONDITION HOLDS EVEN IF LOA NOT SET
!
!   Wendy Koenig, 	29-JAN-79  15:58
!   X0011 - FIX PROBLEM W/ DUPLICATE ENTRIES IN INDEX
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! define default psects for code
!

PSECT
    CODE = $$RMSSPLIT3(PSECT_ATTR),
    PLIT = $$RMSSPLIT3(PSECT_ATTR);

! Linkages
!

LINKAGE
    L_MOVE,
    L_RECORD_VBN,
    L_RECORD_KEY,
    L_REC_OVHD,
    L_VBN_SIZE,
    L_COMPARE_KEY,
    L_COMPARE_REC,
    L_SPLIT_UDR,
    L_SPLIT_UDR_3,
    RL$BUILD_KEY	= JSB () :
			GLOBAL (R_IDX_DFN) PRESERVE(1,2,3,4,5),
    RL$MOVE_KEY 	= JSB (REGISTER = 0, REGISTER = 6) :
			GLOBAL (R_RAB, R_IRAB, R_IFAB, R_IDX_DFN, R_BKT_ADDR),
    L_GETNEXT_REC;

! Forward Routines
!

FORWARD ROUTINE
    RM$BUILD_KEY	: RL$BUILD_KEY NOVALUE,
    RM$MOVE_KEY		: RL$MOVE_KEY NOVALUE,
    RM$SPLIT_UDR	: RL$SPLIT_UDR NOVALUE,
    RM$SPLIT_UDR_3	: RL$SPLIT_UDR_3 NOVALUE;

! External Routines
!

EXTERNAL ROUTINE
    RM$MOVE		: RL$MOVE,
    RM$RECORD_VBN	: RL$RECORD_VBN,
    RM$RECORD_KEY	: RL$RECORD_KEY,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$VBN_SIZE		: RL$VBN_SIZE,
    RM$COMPARE_KEY	: RL$COMPARE_KEY,
    RM$COMPARE_REC	: RL$COMPARE_REC,
    RM$GETNEXT_REC	: RL$GETNEXT_REC;

!++
! 	ALGORITHM FOR A TWO-BUCKET 50/50 SPLIT
!
! 	GIVEN: that the record will not fit in the bucket.
! 	i.e., we must split the bucket in some form.
!
! 	INPUTS: the bucket, the record size and the position
! 	to insert the record in the bucket
!
!
! 	GOALS: to make the split as efficient as possible:
! 	  1)  to create the fewest number of new buckets possible
! 	  2)  to use the space in the available buckets efficiently --
! 	      i.e., the bucket with the most available space should contain
! 	      the most data after the split.
!
! ALGORITHM IN A NUTSHELL:
! 	1)  A two-bucket split will occur IF AND ONLY IF there is a point in
! 	    the bucket at which all records to the left of the point and
! 	    necessary rrv's fit in a single bucket and all records to the right
! 	    of the point fit in a single bucket.  This point must be on a
! 	    record boundary and must not be in the middle of a chain of
! 	    duplicates.
! 	2)  Given that such a point exists, the most optimal point for a
! 	    2-bucket split is the point at which the actual data records
! 	    are divided evenly between the available space in the original
! 	    bucket and the available space in the new (previously empty) bucket.
!
! 	In theory, therefore, the idea is to find a point in the bucket such that
! 	the point is on a boundary between duplicate records and that
! 	1) records in the left hand side / space in the left hand bucket
! 			=
! 	2) records in the right hand side / space in the right hand bucket.
! 	In practice, the idea is to mimimize the absolute difference between
! 	ratio 1) and ratio 2). Just to make it clearer, "records in the left
! 	hand side" means the total size of the data records left of this point
! 	(not including rrv's of any kind) and "space in the left hand bucket"
! 	means the bucketsize of the data bucket minus the total size of existing
! 	rrv's and the total size of rrv's which would have to be generated.
!
!
! IMPLEMENTATION:
! 	This algorithm needs two scans of the bucket.  The first scan is very
! 	quick and determines the total size of the existing rrv's.  It also
! 	counts the number of rrv's that would have to be generated in a worst
! 	case situation (i.e., all records would be moved out).  Thus, as the
! 	second scan proceeds, all information needed to calculate the above
! 	ratios EXACTLY is available.
!
! 	In order for there to be a 2-bucket split, there must be a point
! 	in the bucket such that the right hand side fits in a single bucket.
! 	Scanning from the left (beginning) of the bucket, we can find the
! 	first point at which the right hand side will fit. Since as we
! 	continue scanning to the right we are decreasing the right hand side,
! 	the righthand side will continue to fit as we scan rightward.
!
! 	If at this point, the left hand side will not fit, we can not possibly
! 	have a 2-bucket split, since continuing our scan would only make
! 	the left hand side larger ( or it may stay the same size). Once we
! 	have found a point at which we can do a 2-bucket split we can always
! 	return to it, if in our search for a more optimal split point we
! 	leave the range in which the left hand side will fit.
! 	This can occur if the records in the bucket are of miminal size,
! 	that is to say that the records are the same size as rrv's and
! 	therefore no additional space for data is gained by scanning to the
! 	right.
!
! 	At this point ( the first point at which the right hand side will fit),
! 	ratio 1 is less than ratio 2. As we proceed to the right, ratio 1 will
! 	increase and ratio 2 will decrease. This is due to the fact that
! 	the size of the right hand size ( the numerator of ratio 2) decreases
! 	as we move rightward and the available space in the right bucket is a
! 	constant ( the denominator of ratio 2). In ratio 1, both the numerator
! 	and denominator are increasing,	but the numerator is increasing at a
! 	faster rate. As soon as we reach a point where ratio 1 is greater
! 	than or equal to ratio 2, we can stop the scan.  Now we have a choice
! 	of split points available. We can use this point or the one immediately
! 	before it ( if such a point exists). The decision is made by
! 	minimizing the absolute difference between the ratios and we have an
! 	optimal split point.
!
!
!	Things become complicated by the presence of duplicate records.
!	When duplicate records occupy more than one bucket, the subsequent
!	buckets are termed continuation buckets.  In prologue version 1 and
!	2 files, there is a pointer from the index to the first bucket only,
! 	and the continuation buckets are found only from the horizontal links
! 	in the buckets.  At one point, it was thought that disaster would
!	ensue if the continuation buckets ever had a record with a key value
!	other than that of the duplicates.  Normally, this will not happen
!	because the key value of the index pointer to the first bucket will
!	be the same as that of the duplicate records in the chain and a record
!	with a higher key value will follow the next index pointer down when
!	positioning for insert.  This will place it in the next bucket beyond
!	the chain of continuation buckets.  However, a bucket in which the
!	record with the highest value has been deleted that subsequently
!	recieves a series of duplicates creating a continuation chain will
!	generate a situation where a record with a key value between that
!	of the duplicate chain and the original high key value of the bucket
!	will be inserted at the end of the duplicate chain.  A far more common
!	situation is created by RMS-11 (at least thru v1.5) when loading a
!	file in ascending primary key sequence will pack the buckets 100%
!	(or the load factor) full, including records of non-dupe key values
!	at the end of continuation buckets.
!	At any rate, the fact that the situation exists notwithstanding,
!	much of the code that follows is there to keep duplicates together
!	when splitting, and to put only records with duplicate key values
!	in continuation buckets.  It appears to be a good thing to do from
!	an overall space efficiency standpoint over a period of time, but
!	the code could probably be considerably simplified if it wasn't
!	necessary.  With all that in mind, the split situation with all
!	possible record 'partitions' within the bucket prior to splitting
!	is as follows:
!
!	------------------------------------------------
!	! low set ! low dupes !! high dupes ! high set !
!	----------------------  ------------------------
!			       ^
!			point of insert (new record)
!
!	From the point of view of the split code, an update operation in
!	which the record is growing and causes a split is identical (almost)
!	to a new record being inserted.  The original record is removed from
!	the bucket after determining that the updated record will cause a
!	split and the updated record is more or less treated as a new record.
!	One of the most important differences is that in an update situation,
!	the 'new' record gets the id of the old record, rather than a new id.
!	Another is that because duplicate records are always inserted at
!	the end of a chain of duplicates, some split cases can only occur
!	on an update operation.
!	In fact, the situation postulated above can happen only in an update
!	situation, and may cause 3 new buckets to be generated on the split
!	operation.  This will occur when the updated record is in the
!	middle of a group of duplicate records and grows to the extent that
!	no other records will fit in the bucket with it anymore.
!	Using 1 byte key values to make this easier to visualize, the bucket
!	above prior to the update may look like this (the artificial
!	partitioning of the bucket corresponds to the breakdown above):
!
!	-----------------------------------
!	! A B C ! D D D ! D ! D D ! E F G !
!	-----------------   ---------------
!			 /\
!		 this record gets updated
!
!	The record being updated changes size and grows such that it
!	needs an entire bucket for itself.  To keep all the duplicates
!	together, the situation after the split looks like this:
!
!	---------------      -----      -------      ---------
!	! A B C D D D !  ->  ! D !  ->  ! D D !  ->  ! E F G !
!	---------------      -----      -------      ---------
!	this is the	     these two are
!	original bucket	     continuation buckets
!
!	The original bucket probably had an index pointer with the value 'G'
!	pointing to it (or some previous bucket if there was a previous index
!	update failure).  After the split, the key value for that pointer will
!	be updated to have the key value 'D', and the key value that used to
!	point to it (probably 'G'), will now point to the right hand bucket
!	(with 'E', 'F', and 'G' in it).  The continuation buckets never have
!	an index pointer to them.
!
!	All other split situations are a variation of this one, with
!	one or more of the 'partitions' not present, dependent on the key
!	value and position of insert within the bucket of the record being
!	inserted or updated.  For example, if there are no duplicates, there
!	are no 'low dupes' or 'high dupes'.  Or if the position of insert is
!	at the end of the bucket, there is no 'high set'.
!
!	Now that I've started on it, may as well try to document some other
!	interesting split situations.  Note that a '2 bucket split' means
!	that there are 2 buckets after the split, i.e., 1 new bucket is
!	added.  The situation described above is a 4 bucket split.
!
!	The most interesting split from an index updating point of view
!	is the 3 bucket split where a record is being inserted in the middle
!	of the bucket and doesn't fit in a bucket with either the low set
!	or the high set.  Again with 1 byte key values to illustrate:
!
!			G (this is supposed to represent an index
!			| pointer to this bucket with key value 'g')
!			|
!			v
!	------------------
!	! A B C !! E F G !
!	--------  --------
!		/\
!		new record with key value 'D' inserted, but is so large
!		that it has to have bucket of its own.
!
!	After split (with new index pointers):
!
!		C	   D		  G
!		|	   |		  |
!		|	   |		  |
!		v	   v		  v
!	_________      _____      _________
!	! A B C !  ->  ! D !  ->  ! E F G !
!	---------      -----      ---------
!
!	The new pointer 'C' is the bucket pointer from the original index
!	record 'G' with the new key value 'C'.  The 'D' pointer is an
!	entirely new record (i.e., key value 'D' and bucket pointer).  The
!	pointer 'G' is the key value from the original record 'G' with
!	a new bucket pointer.  The bucket pointer for the 'D' bucket comes
!	from irb$l_vbn_mid and the bucket pointer for the 'G' bucket comes
!	from irb$l_vbn_right.  Remember that all of this stuff works correctly
!	if the index update failed and we got to the bucket thats splitting
!	by following the horizontal bucket links at the data level.
!	For example, consider the following case where prior index corruption
!	exists:
!
!		G (index update failed when right hand bucket split off
!		| during a previous insert operation)
!		|
!		v
!	---------      ------------
!	! A B C !  ->  ! D !! F G !
!	---------      ----  ------
!			   /\
!			new record 'E' will be inserted here and cause split
!
!	After split:
!
!		E			  G
!		|			  |
!		|			  |
!		v			  v
!	---------      -------      -------
!	! A B C !  ->  ! D E !  ->  ! F G !
!	---------      -------      -------
!
!	The reason for the index updating behavior becomes more obvious.
!	The key value of the original down pointer 'G' has been changed to
!	the new value 'E', but retaining the original bucket pointer.  Note
!	that we split the bucket with 'D' in it, yet there is no bucket pointer
!	to it now (there wasn't before).  The key value 'G' of the original
!	bucket pointer 'G' has been used with a new bucket pointer for the
!	new bucket created by the split (this is irb$l_vbn_right).
!	Sometimes there will be a bucket split and no records will be
!	in the left hand bucket after the split.  This may happen if the
!	record being inserted belongs at the beginning of the bucket, but
!	there are enough rrv's present so that it doesn't physically fit.
!	In that case, all of the existing records will have to be moved out
!	also.  This may also occur if there are no id values left in the
!	bucket (typically caused by deleted rrv's).  In this case, we would
!	like to swing the index pointer away from the 'empty' bucket to
!	keep random access times from deteriorating.  As of prologue versions
!	1 and 2, however, it will remain in the horizontal link of data
!	buckets.  However,  we can only change the down pointer if it already
!	points to that bucket or we can potentially create crossed down
!	pointers.  The situation is illustrated below:
!
!		C	       I (index update failed on a previous split)
!		|	       |
!		|	       |
!		v	       v
!	---------      ---------      --------
!	! A B C !  ->  ! D E F !  ->  !! H I !
!	---------      ---------      /\------
!				       record with key value 'G' will be
!					inserted here
!
!	Also presume that the bucket 'G' is being inserted in has so many
!	rrv's in it that it won't fit into the existing bucket, even though
!	it will fit into a bucket without any rrv's in it.
!
!	After split:
!
!		C	       I
!		|	       |
!		|	       |
!		v	       v
!	---------      ---------      --------------      ---------
!	! A B C !  ->  ! D E F !  ->  ! rrv's only !  ->  ! G H I !
!	---------      ---------      --------------      ---------
!
!	Note that the index pointer 'I' was not moved to point to the new
!	bucket.  If it had been, the bucket containing 'D E F' would have
!	been 'lost' by random access from the index.  This condition is
!	detected by setting irb$l_vbn_left to the vbn of the rrv only
!	bucket.  During the index update procedure, the pointer will be
!	moved to point to the new bucket only if the existing down pointer
!	points to the bucket that was split, i.e., irb$l_vbn_left (this
!	is normally the case as index corruption is not normal).  Note that
!	an empty left hand bucket may also be present in a 3 bucket split
!	situation.
!
!	Following is a list of the specific split cases handled in the
!	code.  They are basically variations of the above cases.
!
!  these are all the cases of 3 and 4 bucket splits that i can think of
!  any or all of these cases can have the empty left-hand bucket
!	-- this would occur if the first split point is at the beginning
!	-- of the bucket and all data records got moved out
!
! low dups exist -- no high dups
! 	low dups fit w/ rec
! 	   3 bkt split  low, low dups w/ rec, hi set -- rec goes w/ lo
!	    ( SPLIT TYPE 1 )
!
! 	low dups don't fit w/ rec
! 	    3 bkt split w/ rec in its own continuation bucket
!	    ( SPLIT TYPE 2, W/ DUPS SEEN )
!
! hi dups exist -- no low dups
! 	hi dups fit w/ rec
! 	    3 bkt split low, hi dups w/ rec, hi set
!	    ( SPLIT TYPE 1 )
!
! 	hi dups don't fit w/ rec
! 	    if no more hi, 3 bkt split low, rec, hi = hi dups is a cont. bkt
!	    ( SPLIT TYPE 2 )
!
! 	    if there is more hi, 4 bkt split low, rec, hi dups, hi
!	    ( SPLIT TYPE 2B )
!
! no dups at all
! 	record goes in its own bucket, 3 bkt split
!	(SPLIT TYPE 3 )
!
! low dups and hi dups
! 	all dups fit together
! 	    3 bkt split w/ dups in middle bkt
!	    ( SPLIT TYPE 1 )
!
! 	no dups fit w/ record
! 	    if no more hi, 3 bkt split low, rec = cont. bkt, hi = hi dups = cont. bkt
!
!
!	    ( SPLIT TYPE 2B )
!
! 	    if there is more hi, 4 bkt split low, rec = cont. bkt, hi dups, hi
!	    ( SPLIT TYPE 2B )
!
! 	hi dups fit w/ record
! 	    if no more hi, 2 bkt split low, rec w/ hi dups = cont. bkt
! 	    ( this is a 2 bkt split case that the previous alg. wouldn't handle)
!	    ( SPLIT TYPE 4B )
!
! 	    if there is more hi, 3 bkt split low, rec w/ hi dups = cont. bkt, hi
!	    ( SPLIT TYPE 4 )
!
! 	low dups fit w/ record
! 	    if lo and hi, 4 bkt split low, low dups w/ rec, hi dups, hi
!	    ( SPLIT TYPE 5 )
!
! 	    if no lo and no hi, 3 bkt split (rrv's), low dups w/ rec, hi dups = cont.
!
! bkt
!	    ( SPLIT TYPE 5, w/ empty original bkt and no high )
!
! 	    if lo but no hi, 3 bkt split lo, low dups w/ rec, hi dups = cont. bkt
!	    ( SPLIT TYPE 5, w/ no high )
!
! 	    if hi but no low, 4 bkt split (rrv's), low dups w/ rec, hi dups, hi
!	    ( SPLIT TYPE 5, w/ empty bkt  )
!--

ROUTINE RM$MOVE_KEY (ADDRESS, CUR_REC_ADDR) : RL$MOVE_KEY NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to move the key from wherever it is desired into
!	key buffer 2.
!
! CALLING SEQUENCE:
!	bsbw rm$move_key (address,cur_rec_addr)
!
! INPUT PARAMETERS:
!	address from which to get the key from
!	the current value of rec_addr
!
! IMPLICIT INPUTS:
!	BKT_ADDR,
!	RAB - user's buffer address
!	IRAB -- pos_ins, rec_w_lo, keybuf
!	IFAB -- kbufsz, prologue version
!	IDX_DFN -- for call to record_key, and compression flags
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	key is moved into key buffer 2
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	key is moved into key buffer 2
!	AP is clobbered
!
!--

    BEGIN

    BUILTIN
	AP;

    GLOBAL REGISTER
	R_REC_ADDR_STR;

    EXTERNAL REGISTER
	R_RAB_STR,
	R_IRAB_STR,
	R_IFAB_STR,
	R_IDX_DFN_STR,
	R_BKT_ADDR_STR;

    IF  .CUR_REC_ADDR - .BKT_ADDR EQLU .IRAB[IRB$W_POS_INS]
	AND
	.IRAB[IRB$V_REC_W_LO]
    THEN
	BEGIN
	AP = 3;			! no overhead, not compressed
	REC_ADDR = .IRAB[IRB$L_RBF];
	END
    ELSE
	BEGIN
	AP = 0;
	REC_ADDR = .ADDRESS;

	! In prologue 3 version files, if the key is compressed, it must be
	! rebuilt.  Make sure that the last non-compressed pointer, is before
	! the record we are looking at.
	!

	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    BEGIN

	    IF .IRAB[IRB$L_LST_NCMP] GTRU .ADDRESS
	    THEN
		BEGIN

		GLOBAL REGISTER
		    R_REC_SIZE;

		IF .(.ADDRESS + RM$REC_OVHD() + 1)<0,8> EQLU 0
		THEN
		    IRAB[IRB$L_LST_NCMP] = .ADDRESS
		ELSE
		    IRAB[IRB$L_LST_NCMP] = .BKT_ADDR + BKT$C_OVERHDSZ;
		END;
	     END;
	END;

    ! We are storing in key buffer 2 the possible key to be inserted at the
    ! index level.
    !

    RM$RECORD_KEY ( KEYBUF_ADDR(2) );

    RETURN;

    END;


ROUTINE RM$BUILD_KEY (ADDRESS, KEYBUF) : RL$BUILD_KEY NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine builds a compressed key from the record into the
!	given buffer, knowing that the front characters are valid from
!	the previous expansion.
!
! CALLING SEQUENCE:
!	bsbw rm$build_key (address,keybuf)
!
! INPUT PARAMETERS:
!	- address in bucket which points to key compression overhead
!	- key output buffer
!
! IMPLICIT INPUTS:
!	IDX_DFN - index definition for key size
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	key is moved into appropiate key buffer
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	key is moved into appropiate key buffer
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IDX_DFN_STR;

    LOCAL
	TRUN_CHAR,
	LENGTH;

    BIND
	REC_KEY = ADDRESS : REF BBLOCK;

    MACRO
	KEY_LEN = 0,0,8,0 %,
	CMP_CNT = 1,0,8,0 %;

    KEYBUF = .KEYBUF + .REC_KEY[CMP_CNT];	! skip characters already moved
    TRUN_CHAR = .REC_KEY + .REC_KEY[KEY_LEN] + 1;
    LENGTH = .IDX_DFN[IDX$B_KEYSZ] - .REC_KEY[CMP_CNT];
    CH$COPY ( .REC_KEY[KEY_LEN], .REC_KEY + 2,
	      ..TRUN_CHAR,
	      .LENGTH, .KEYBUF );

    RETURN;

    END;


GLOBAL ROUTINE RM$SPLIT_UDR : RL$SPLIT_UDR NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!
! CALLING SEQUENCE:
!	BSBW RM$SPLIT_UDR()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	BDB pointer, BUFFER pointer, REC_ADDR = point of insert, IDX_DFN
!	in IRAB -- curbdb, associated w/ bdb and bkt_addr
!		pos_ins corresponding to rec_addr
!	in RAB -- rsz of record
!	in IFAB -- rfm
!	BKT$B_NXTRECID = 0 in original bucket signals that this is
!	a split due to a lack of id's in the bucket
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	in IRAB --
!	if 2 bkt split --
!		IRB$W_SPLIT, offset to split point
!		IRB$V_REC_W_LO -- set if split point is pos_insert and
!			record goes w/ lo set
!		new high key for original bucket in keybuffer 2
!		number of new buckets = 1
!		if original bucket was all rrv's, set IRB$V_EMPTY_BKT flag
!		if new bucket is a continuation bkt., set IRB$V_CONT_BKT flag
!	if 3 bkt split --
!		same as above w/ these changes:
!		IRB$W_SPLIT_1, offset to second split point
!		number of new buckets = 2
!		if right bucket is a continuation bkt, set IRB$V_CONT_R flag
!	if 4 bkt split --
!		same as above w/ these changes:
!		IRB$W_SPLIT_2, offset to third split point
!		number of new buckets = 3
!
! ROUTINE VALUE:
!	rmssuc
!
! SIDE EFFECTS:
!	AP is clobbered
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_IRAB_STR,
	R_RAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR,
	COMMON_IO_STR;

    LOCAL
	SAVE_REC_W_LO,
	NUM_RRVS,
	POS_INSERT,
	EOB,
	RRV,
	RHS,
	LHS,
	LAST	: REF BBLOCK,
	LAST_DIFF,
	BKTSIZE,
	REC_SIZE,
	DIFFERENCE;

    MACRO
	NEED_RRV = NUM_RRVS<0,16> %,
	NOT_NEED_RRV = NUM_RRVS<16,16> %;

    LABEL
	DO_IT,
	HALF,
	NEXT;

DO_IT :

    BEGIN

    ! define a block so that we can have some common checks before returning
    ! successfully
    !
HALF :

    BEGIN

    !+
    ! define a block so that we can simulate a go-to (naughty, naughty)
    ! if we have decided that we are positioning at the end of the bucket
    ! & we're in somewhat of an ascending order, where the last record
    ! inserted is a duplicate of the new record, skip over the 50-50 code
    ! and go to the code to take duplicates into account
    !
    ! scan 1 -- calculate
    ! size of existing rrv's and total number of rrv's needed to move the whole
    ! bucket out ( worst case) as a side effect, adjust eob ptr to pt to the
    ! rrv's instead of freespace assume not empty bucket until showed otherwise
    !-

    IRAB[IRB$V_EMPTY_BKT] = 0;

    ! new rec is tried 1st w/ hi set, then w/ lo set
    !
    IRAB[IRB$V_REC_W_LO] = 0;
    IRAB[IRB$V_NEW_BKTS] = 1;	! assume 2-bkt split until showed otherwise
    NUM_RRVS = 0;		! this zeroes NEED_RRV and NOT_NEED_RRV
    POS_INSERT = .REC_ADDR;
    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    EOB = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];
    LAST = 0;

    DO
	BEGIN

	BUILTIN
	    AP;

	IF .REC_ADDR[IRC$V_RRV]
	THEN
	    EXITLOOP;

	AP = 3;

	IF .BDB[BDB$L_VBN] EQLU RM$RECORD_VBN()
	THEN
	    NEED_RRV = .NEED_RRV + 1

	    ! the records not requiring rrv's are counted also because in the
	    ! case where we're splitting due to lack of id's, the lhs side will
	    ! fit with the new record if any of the record being moved to the
	    ! new bucket doesn't require an rrv.  this will be checked when we
	    ! check to see if the lhs will fit after the first point that the
	    ! rhs fits.
	    !
	ELSE
	    NOT_NEED_RRV = .NOT_NEED_RRV + 1;

	LAST = .REC_ADDR;
	RM$GETNEXT_REC()
	END
    UNTIL .REC_ADDR GEQU .EOB;

    ! set split_2 and split_1 to be eob, so if there's less than 3 new buckets
    ! bkt_spl can use the value w/o having to recalculate it also set up the
    ! bucket size and the record size
    !
    IRAB[IRB$W_SPLIT_1] = IRAB[IRB$W_SPLIT_2] = .REC_ADDR - .BKT_ADDR;
    BKTSIZE = .IDX_DFN[IDX$B_DATBKTSZ]*512 - BKT$C_OVERHDSZ - 1;

    ! ********* this is the way it should be if we have variable sized vbn's
    ! ******** but for now we don't since rms-11 can't handle them, so the vbn's
    ! ******** must be 4 bytes long, irregardless
    ! REC_SIZE = .RAB [RAB$W_RSZ] + 3 + RM$VBN_SIZE (.BBLOCK [.IRAB[IRB$L_NRP_PTR],NRP$L_RP_VBN]); 
    ! ******* so do it this way instead
    !
    REC_SIZE = .RAB[RAB$W_RSZ] + IRC$C_FIXOVHDSZ;

    IF .IFAB[IFB$B_RFMORG] NEQ FAB$C_FIX
    THEN
	REC_SIZE = .REC_SIZE + 2;

    ! if this is an update, may have to count in an rrv for the existing record
    !

    IF .IRAB[IRB$V_UPDATE]
    THEN
	BEGIN

	IF .BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR], NRP$L_RP_VBN]
	THEN
	    NEED_RRV = .NEED_RRV + 1

	END;

    RRV = .EOB - .REC_ADDR;			! size of existing rrv's
    EOB = .REC_ADDR;				! adjust eob

    ! special case it, if the bucket was all rrv's
    !

    IF .REC_ADDR EQLU .BKT_ADDR + BKT$C_OVERHDSZ
    THEN
	BEGIN

	! bkt is all rrv's yet the record wouldn't fit so we need to
	! allocate another bkt ( 2 bkt split) yet special case it so as not
	! to make another idx entry only to update the existing one by
	! setting empty bucket flag
	!
	IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;
	LEAVE DO_IT

	END;			! { of special case an all-rrv bucket }

    !+
    ! special case -- if we can detect a possible ascending order to these
    ! records it probably will be better to do a straight point of insert split
    ! this would put the new record in a bucket all by itself.
    ! do this kind of split if and only if all the following conditions are met:
    !    1) the record is being inserted at the end of bucket
    !    2) the last record physically in the bkt is the last record to have 
    !	    been inserted
    !    3) the last record and the new record do not have duplicate key values 
    !
    ! note that if they are duplicates, we can still make an optimization by
    ! skipping the 50-50 split code 
    !
    ! note that last cannot be zero, since if it were we
    ! would have an all rrv bkt
    !-

    IF .POS_INSERT EQLU .REC_ADDR
	AND
	(((.LAST[IRC$B_ID] + 1)  AND  %X'FF') EQLU .BKT_ADDR[BKT$B_NXTRECID])
    THEN
	BEGIN
	REC_ADDR = .LAST;

	IF RM$COMPARE_REC(KEYBUF_ADDR(3), .IDX_DFN[IDX$B_KEYSZ], 0)
	THEN
	    BEGIN

	    ! since we have detected a possible ascending order in the input
	    ! let's try to optimize a little and split at the point of insert
	    ! send the record by itself into the new bucket have to set up the
	    ! key value and the split point and that's it
	    !
	    RM$MOVE_KEY(.REC_ADDR, .REC_ADDR);
	    IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];
	    LEAVE DO_IT;

	    END
	ELSE
	    LEAVE HALF;

	! { end of trying to special case insertion of records in ascending
	! order }
	!
	END;

    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    LAST_DIFF = %X'7FFFFFFF';
    LAST = 0;
    SAVE_REC_W_LO = 0;

    ! start from the beginning of the bucket and scan rightward. first find the
    ! 1st place the rhs will fit in 1 bkt then, as long as the lhs will fit in
    ! a bkt, try to find an optimal point if there is no point where the rhs
    ! and lhs will both fit, we can't do a 2-bkt split and this case will fall
    ! out
    !

    WHILE 1
    DO
	BEGIN
	RHS = .EOB - .REC_ADDR;

	IF  .REC_ADDR LEQU .POS_INSERT
	    AND
	    NOT .IRAB[IRB$V_REC_W_LO]
	THEN
	    RHS = .RHS + .REC_SIZE;

	! the right hand side fits if there is enough room and there are id's
	! available. id's are always available in the new bucket in the update
	! situation, or if we're leaving at least 1 record behind in the old
	! bucket. note that nxtrecid is always zeroed if this is a split due to
	! lack of id's.
	!

	IF  .RHS LSSU .BKTSIZE
	    AND
	    (.BKT_ADDR[BKT$B_NXTRECID] NEQ 0
	    OR
	    .IRAB[IRB$V_UPDATE]
	    OR
	    .REC_ADDR NEQA (.BKT_ADDR + BKT$C_OVERHDSZ)
	    OR
	    .IRAB[IRB$V_REC_W_LO])
	THEN
	    BEGIN
	    LHS = .REC_ADDR - (.BKT_ADDR + BKT$C_OVERHDSZ);

	    IF  .REC_ADDR GEQU .POS_INSERT
		AND
		.IRAB[IRB$V_REC_W_LO]
	    THEN
		LHS = .LHS + .REC_SIZE;

	    ! will lhs fit ? lhs doesn't fit if there is no space in the
	    ! bucket, or if there won't be any id's available in the bucket.
	    ! if not & if there is no previous point at which it fit, goto 3-bkt
	    ! split code if there is a previous place where we could have had a
	    ! 2-bkt split, use it
	    !

	    IF .LHS + .RRV + (7*.NEED_RRV) GTRU .BKTSIZE

		! id's will be available in the original bucket if we aren't
		! out of id's to begin with, this is an update, any record
		! being moved out doesn't need an rrv, or the new record is
		! going in the new bucket
		!
		OR
		(.BKT_ADDR[BKT$B_NXTRECID] EQL 0
		AND
		NOT .IRAB[IRB$V_UPDATE]
		AND
		.NOT_NEED_RRV EQL 0
		AND
		.IRAB[IRB$V_REC_W_LO])
	    THEN
		BEGIN

		IF .LAST EQL 0
		THEN
		    EXITLOOP;

		REC_ADDR = .LAST;

		IF NOT .SAVE_REC_W_LO
		THEN
		    IRAB[IRB$V_REC_W_LO] = 0;

		! 2 bkt split is possible rec_addr points to the most
		! optimal place since we had to back up, reset last to point
		! to the record	immediately before the split point
		!
		BEGIN

		LOCAL
		    TMP;

		TMP = .REC_ADDR;
		REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		LAST = .REC_ADDR;

		WHILE .REC_ADDR NEQU .TMP
		DO
		    BEGIN
		    LAST = .REC_ADDR;
		    RM$GETNEXT_REC();
		    END;

		END;
		RM$MOVE_KEY(.LAST, .REC_ADDR);
		IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;

		! treat another exception case of the new record going off into
		! a cont. bkt all by itself
		!

		IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_POS_INS]
		THEN

		    IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_SPLIT_1]
		    THEN

			IF NOT .IRAB[IRB$V_REC_W_LO]
			THEN
			    BEGIN

			    BUILTIN
				AP;

			    AP = 3;

			    IF NOT RM$COMPARE_KEY(KEYBUF_ADDR(2),
					    KEYBUF_ADDR(3),
					    .IDX_DFN[IDX$B_KEYSZ])
			    THEN
				IRAB[IRB$V_CONT_BKT] = 1;

			    END;

		LEAVE DO_IT

		END;			! { end of lhs doesn't fit anymore }

	    ! lhs fits also, calculate the magic ratio
	    !
	    DIFFERENCE = (.LHS*.BKTSIZE) - (.RHS*(.BKTSIZE - (7*.NEED_RRV) -
	    .RRV));

	    IF .DIFFERENCE GEQ 0
	    THEN
		BEGIN

		! found the 1st point at which the magic ratio is positive
		! was the last point more optimal, if so use it
		!

		IF ABS(.DIFFERENCE) GTRU ABS(.LAST_DIFF)
		THEN
		    BEGIN

		    IF .REC_ADDR EQLU .LAST
		    THEN
			IRAB[IRB$V_REC_W_LO] = 0
		    ELSE
			(REC_ADDR = .LAST;

			IF .REC_ADDR LSSU .POS_INSERT
			THEN
			    IRAB[IRB$V_REC_W_LO] = 0);

		    LAST = 0;
		    END;

		! 2-bkt split is possible rec_addr points to the most
		! optimal place
		!

		IF .LAST EQL 0
		THEN 		! just backed up rec_addr, need to recalc last
		    BEGIN

		    LOCAL
			TMP;

		    TMP = .REC_ADDR;
		    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		    LAST = .REC_ADDR;

		    WHILE .REC_ADDR NEQU .TMP
		    DO
			BEGIN
			LAST = .REC_ADDR;
			RM$GETNEXT_REC();
			END;

		    END;

		RM$MOVE_KEY(.LAST, .REC_ADDR);
		IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;

		! treat another exception case of the new record going off into
		! a cont. bkt all by itself
		!

		IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_POS_INS]
		THEN

		    IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_SPLIT_1]
		    THEN

			IF NOT .IRAB[IRB$V_REC_W_LO]
			THEN
			    BEGIN

			    BUILTIN
				AP;

			    AP = 3;

			    IF NOT RM$COMPARE_KEY(KEYBUF_ADDR(2),
						KEYBUF_ADDR(3),
					    .IDX_DFN[IDX$B_KEYSZ])
			    THEN
				IRAB[IRB$V_CONT_BKT] = 1;

			    END;

		LEAVE DO_IT

		END;

	    ! the magic ratio isn't positive yet, so save all the context and
	    ! move on to the next record
	    !
	    LAST_DIFF = .DIFFERENCE;
	    LAST = .REC_ADDR;

	    IF .IRAB[IRB$V_REC_W_LO]
	    THEN
		SAVE_REC_W_LO = 1;

	    END;		! { end of rhs fits, is this a good point? }

	! go on to the next record
	!
NEXT :
	BEGIN

	IF  .REC_ADDR EQLU .POS_INSERT
	    AND
	    NOT .IRAB[IRB$V_REC_W_LO]
	THEN
	    BEGIN

	    ! if this is an update and we pass the record, check to see if it
	    ! needed an rrv
	    !

	    IF .IRAB[IRB$V_UPDATE]
	    THEN
		BEGIN

		IF .BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR],
			NRP$L_RP_VBN]
		THEN
		    NEED_RRV = .NEED_RRV - 1;

		END;

	    IRAB[IRB$V_REC_W_LO] = 1;
	    RM$MOVE_KEY(.REC_ADDR, .REC_ADDR);

	    IF  .REC_ADDR EQLU .EOB
	    THEN
		LEAVE NEXT

	    ELSE IF RM$COMPARE_REC(KEYBUF_ADDR(2), .IDX_DFN[IDX$B_KEYSZ], 0)
	    THEN
		LEAVE NEXT;

	    END;	! { end of at position for insert for the 1st time }

	! fool move key a little by always clearing rec_w_lo to always get the
	! key associated w/ the record at pos_ins.  (I think it is the key of
	! the record we are pointing to, not the one at pos_ins...)
	!
	BEGIN

	LOCAL
	    TMP	: BYTE;

	TMP = .IRAB[IRB$B_SPL_BITS];
	IRAB[IRB$V_REC_W_LO] = 0;
	RM$MOVE_KEY(.REC_ADDR, .REC_ADDR);
	IRAB[IRB$B_SPL_BITS] = .TMP
	END;

	DO
	    BEGIN

	    BUILTIN
		AP;

	    IF .REC_ADDR EQLU .EOB
	    THEN
		EXITLOOP;

	    AP = 3;

	    IF .BDB[BDB$L_VBN] EQLU RM$RECORD_VBN()
	    THEN
		NEED_RRV = .NEED_RRV - 1
	    ELSE
		NOT_NEED_RRV = .NOT_NEED_RRV - 1;

	    RM$GETNEXT_REC();

	    IF .REC_ADDR EQLU .EOB
	    THEN
		EXITLOOP;

	    END

	! compare_rec returns 0 if a match
	!
	UNTIL RM$COMPARE_REC(KEYBUF_ADDR(2), .IDX_DFN[IDX$B_KEYSZ], 0);

	! if the key compares brought us up to the pos of insert, see if the
	! key of the new record matches. if it does, have to include it w/ the
	! lhs
	!

	IF .REC_ADDR EQLU .POS_INSERT
	THEN
	    BEGIN

	    BUILTIN
		AP;

	    AP = 3;

	    IF NOT RM$COMPARE_KEY(KEYBUF_ADDR(2),
				  KEYBUF_ADDR(3),
				 .IDX_DFN[IDX$B_KEYSZ])
	    THEN
		BEGIN
		IRAB[IRB$V_REC_W_LO] = 1;

		IF  .IRAB[IRB$V_UPDATE]
		    AND
		    .BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR],
			NRP$L_RP_VBN]
		THEN
		    NEED_RRV = .NEED_RRV - 1;
		END;

	    END;

	IF .REC_ADDR GTRU .POS_INSERT
	THEN
	    BEGIN
	    IRAB[IRB$V_REC_W_LO] = 1;

	    IF  .IRAB[IRB$V_UPDATE]
		AND
		.BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR],
		    NRP$L_RP_VBN]
	    THEN
		NEED_RRV = .NEED_RRV - 1;
	    END;

	END;					! {end of next }
	END;		! { end of scanning to find optimal split point }

    END;					! { end of half }

    ! define a new block here so local storage can be redefined
    !
    BEGIN

    MACRO
	BEG_CHAIN = LHS %,
	END_CHAIN = RHS %,
	NUM_DUPS = NUM_RRVS %,
	DUPS = RRV %;

    BUILTIN
	AP;

    ! must be a 3 or 4 bucket split or we detected ascending order and the new
    ! record was a dupe. we'll optimize here to the extent of trying to keep a
    ! dup chain around the new record together and in the middle bucket
    ! note that in all the cases that follow the new record is going into the
    ! middle bucket. therefore, the "lhs" will always fit, since it can only
    ! get smaller ( or stay the same size, in the degenerate case). also note
    ! that in any of these case, the left hand bucket may be empty of data
    ! records (have only rrv's in it) if the first split point is at the
    ! beginning and all data records get moved out
    !
    IRAB[IRB$V_NEW_BKTS] = 2;	! assume 3-bkt split until shown otherwise
    IRAB[IRB$V_REC_W_LO] = 0;

    ! initialize key buffer 2 with the contents of key buffer 3 (the value
    ! of the primary key of the record being inserted).  This is necessary
    ! when the new record is at the beginning of the bucket and is going into
    ! a bucket all by itself and there were already 255 records in their
    ! original bucket and they all need rrv's therefore they all move into the
    ! next bucket. At any rate, that seems to be the only case where key buffer
    ! 2 is not correct coming into here and will be set correctly before
    ! leaving.
    !
    RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3), KEYBUF_ADDR(2));

    ! find beginning and end of this possible dups chain equal to the key value
    ! of the record being inserted.
    !
    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    BEGIN

    LOCAL
	STATUS;

    WHILE STATUS = RM$COMPARE_REC(KEYBUF_ADDR(3), .IRAB[IRB$B_KEYSZ], 0)
    DO
	BEGIN

	IF .REC_ADDR LSSU .POS_INSERT
	THEN
	    BEGIN
	    AP = 0;
	    RM$RECORD_KEY(KEYBUF_ADDR(2));
	    END;

	IF  .REC_ADDR EQLU .EOB
	    OR
	    .STATUS LSS 0
	THEN
	    BEGIN

	    ! !!!! SPLIT TYPE 3 !!!! no duplicates found for simplicity, do a
	    ! 3-bkt split at the point of insert w/ new record in its own
	    ! bucket
	    !
	    IRAB[IRB$W_SPLIT] = IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_POS_INS];
	    LEAVE DO_IT

	    ! { end of didn't find a duplicate, put record in its own bucket }
	    !
	    END;

	RM$GETNEXT_REC();
	END;			! { end of while no duplicate has been found }

    END;		! { end of block defining status for while loop }

    ! found the beginning of the dups chain, now find the end
    !
    NUM_DUPS = 0;
    BEG_CHAIN = .REC_ADDR;

    DO
	BEGIN
	NUM_DUPS = .NUM_DUPS + 1;
	RM$GETNEXT_REC();

	IF .REC_ADDR EQLU .EOB
	THEN
	    EXITLOOP;

	END
    UNTIL RM$COMPARE_REC(KEYBUF_ADDR(3), .IRAB[IRB$B_KEYSZ], 0);
					! compare_rec returns 0 if keys match

    END_CHAIN = .REC_ADDR;

    ! found the beginning and the end of the chain calculate its size if we got
    ! here via an update, we never called rm$srch_by_key to set dups_seen
    ! for us.  so let us do that now if necessary
    !

    IF .POS_INSERT GTRU .BEG_CHAIN
    THEN
	IRAB[IRB$V_DUPS_SEEN] = 1;

    DUPS = .END_CHAIN - .BEG_CHAIN;
    DUPS = .DUPS + .REC_SIZE;

    IF .DUPS LSSU .BKTSIZE

	! if there are 255 dupes on a put, there won't be enough id's in the
	! new bucket even if there is enough space for them.
	!
	AND
	    (.IRAB[IRB$V_UPDATE]
	    OR
	    .NUM_DUPS<0, 8> LEQU 254)
    THEN
	BEGIN

	!+
	! !!!! SPLIT TYPE 1 !!!!! 
	! duplicates found and fortunately, they all fit
	! in one bucket so 3-bkt split w/ all of the dups in the middle bucket
	! because of the optimization used for dups being inserted "in order"
	! this can sitll be a 2-bkt split if the new record is being inserted
	! at the end of the bucket 
	! 22-jan-79  if loa forced us to think that a
	! bkt w/ all dups had to be split ( only on put) be smart and just put
	! new record by itself a better solution would be not to split at all,
	! but at this date it's rather inconceivable
	! 23-jan-79 it's not only loa
	! that can fool us, the bkt might have had a lot of rrv's
	!-

	IRAB[IRB$W_SPLIT] = .BEG_CHAIN - .BKT_ADDR;
	IRAB[IRB$W_SPLIT_1] = .END_CHAIN - .BKT_ADDR;

	IF .END_CHAIN EQLU .EOB
	THEN
	    BEGIN
	    IRAB[IRB$V_NEW_BKTS] = 1;

	    IF .BEG_CHAIN EQLU (.BKT_ADDR + BKT$C_OVERHDSZ)
	    THEN
		BEGIN
		IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_SPLIT_2];
		IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];
		IRAB[IRB$V_CONT_BKT] = 1;
		END

	    END
	ELSE
	    BEGIN

	    IF .IRAB[IRB$W_SPLIT] EQLU BKT$C_OVERHDSZ<0, 16>
	    THEN
		IRAB[IRB$V_EMPTY_BKT] = 1;

	    ! Only force the record into the low bucket if it is not the
	    ! first one in the duplicate chain.
	    !

	    IF .END_CHAIN GEQU .POS_INSERT
	      AND .IRAB[IRB$W_SPLIT] NEQU .IRAB[IRB$W_POS_INS]
	    THEN
		IRAB[IRB$V_REC_W_LO] = 1;
	    END;

	LEAVE DO_IT

	END;	! { end of duplicates found and they fit in one bucket }

    ! if we had 255 dupes above we dropped thru to here and this next test
    ! will fail because it can only happen on an update so the all dupes case
    ! will fall thru to split type 2, which will put the new record by itself.
    ! consider oddball update case in which there are dups before and after
    ! position of insert. ( note that if this case doesn't apply, the duplicates
    ! were only before or after -- and didn't fit w/ record -- so new record
    ! will end up by itself. for code flow purposes, leave that till later).
    !

    IF  .IRAB[IRB$V_DUPS_SEEN]
	AND
	.END_CHAIN GTRU .POS_INSERT
    THEN
	BEGIN

	IF .DUPS - (.POS_INSERT - .BEG_CHAIN) LSSU .BKTSIZE
	THEN

	    ! if high dups will fit w/ record, put them in a bucket together
	    !
	    BEGIN

	    !+
	    ! !!!! SPLIT TYPE 4 !!!! 
	    ! 3 bkt split where middle bkt is a continuation bkt containing 
	    ! new record and dups following it
	    !
	    ! !!!! AND SPLIT TYPE 4B !!!!! however, if the hi set consists
	    ! solely of duplicates, we can still have a 2-bkt split case that
	    ! would not have been picked up by the previous algorithm ( since
	    ! it won't divide dups).
	    !-

	    IRAB[IRB$V_CONT_BKT] = 1;
	    IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];

	    IF .END_CHAIN EQLU .EOB
	    THEN
		IRAB[IRB$V_NEW_BKTS] = 1
	    ELSE
		IRAB[IRB$W_SPLIT_1] = .END_CHAIN - .BKT_ADDR;

	    REC_ADDR = .BEG_CHAIN;
	    AP = 0;
	    RM$RECORD_KEY(KEYBUF_ADDR(2));
	    LEAVE DO_IT

	    END;

	! try to fit new record w/ before-dups in middle bucket
	!

	IF .DUPS - (.END_CHAIN - .POS_INSERT) LSSU .BKTSIZE
	THEN
	    BEGIN

	    !+
	    ! !!!! SPLIT TYPE 5 !!!!! 
	    ! 3 or 4 bkt split ( depending on status of
	    ! high set) where left-middle bkt is new record w/ before-dups
	    ! and right-middle bkt, if it is needed, is a continuation bkt
	    ! w/ the after-dups. it is needed iff the dups aren't the whole hi
	    ! set it still is a continuation bkt.
	    !
	    ! ***** NOTE FROM NOV-7-78
	    ! This case doesn't take into account the fact that the
	    ! whole bucket may be dups.  In the case of all dups, we could
	    ! end up generating an empty bucket when we don't have to (if
	    ! no RRV's) or a relatively useless bucket (some RRV's). In any
	    ! event we could end up generating an extra bucket when we
	    ! don't have to
	    !-

	    IRAB[IRB$W_SPLIT] = .BEG_CHAIN - .BKT_ADDR;
	    IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_POS_INS];

	    IF .IRAB[IRB$W_SPLIT] EQLU BKT$C_OVERHDSZ<0, 16>
	    THEN
		IRAB[IRB$V_EMPTY_BKT] = 1;

	    IRAB[IRB$V_REC_W_LO] = 1;

	    IF .END_CHAIN LSSU .EOB
	    THEN
		BEGIN
		IRAB[IRB$V_NEW_BKTS] = 3;
		IRAB[IRB$W_SPLIT_2] = .END_CHAIN - .BKT_ADDR;
		END
	    ELSE
		IRAB[IRB$V_CONT_R] = 1;

	    LEAVE DO_IT

	    END;

	! { end of oddball update case w/ dups on both sides of new record }
	!
	END;

    !+
    ! !!!! SPLIT TYPE 2 !!!!!
    ! the new record must go all by itself therefore,
    ! this is a 3-bkt split if there are no after-dups or no hi set and a 4-bkt
    ! split if both of those exist even more exceptional, this can still be a
    ! 2-bkt split if there is no hi set at all ---- i.e., eob = end of the dups
    ! chain
    !-

    IRAB[IRB$W_SPLIT] = IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_POS_INS];

    IF  .IRAB[IRB$V_DUPS_SEEN]
    THEN
	BEGIN
	IRAB[IRB$V_CONT_BKT] = 1;
	REC_ADDR = .BEG_CHAIN;
	AP = 0;
	RM$RECORD_KEY(KEYBUF_ADDR(2));
	END;

    IF .POS_INSERT EQLU .EOB
    THEN
	IRAB[IRB$V_NEW_BKTS] = 1
    ELSE

	IF .POS_INSERT LSSU .END_CHAIN
	THEN
	    BEGIN

	    IF .END_CHAIN LSSU .EOB
	    THEN
		IRAB[IRB$V_NEW_BKTS] = 3
	    ELSE
		IRAB[IRB$V_CONT_R] = 1;

	    IRAB[IRB$W_SPLIT_2] = .END_CHAIN - .BKT_ADDR;
	    END;

    END;			! { end of block defining local symbols }

    END;					! { end of do_it }

    ! if the first split point is at the beginning of the data, this means that
    ! all data records will be moved out and only rrv's will be left in the
    ! original bucket ..... therefore, we can mark this bucket as empty
    !

    IF  .IRAB[IRB$W_SPLIT] EQLU BKT$C_OVERHDSZ<0, 16>
	AND
	NOT .IRAB[IRB$V_REC_W_LO]
    THEN
	IRAB[IRB$V_EMPTY_BKT] = 1;

    RETURN;

    END;					! { end of routine }


GLOBAL ROUTINE RM$SPLIT_UDR_3(RECSZ) : RL$SPLIT_UDR_3 NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine calculates bucket splits for prologue 3 version files.
!
! CALLING SEQUENCE:
!	BSBW RM$SPLIT_UDR_3(RECSZ)
!
! INPUT PARAMETERS:
!	RECSZ - packed record size including overhead
!
! IMPLICIT INPUTS:
!	BDB pointer
!	BUFFER pointer
!	REC_ADDR -- point of insert
!	RAB -- to be passed to RM$MOVE_KEY
!	IDX_DFN
!	in IRAB -- CURBDB, associated with bdb and bkt_addr
!		POS_INS corresponding to REC_ADDR
!		key buffer address
!	in IFAB -- key buffer size
!	BKT$B_NXTRECID = 0 in original bucket signals that this is
!	    a split due to a lack of id's in the bucket
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	in IRAB --
!	if 2 bkt split --
!		IRB$W_SPLIT, offset to split point
!		IRB$V_REC_W_LO -- set if split point is pos_insert and
!			record goes with lo set
!		key buffer 2 - new high key for original bucket, i.e. key to be
!			inserted at the index level
!		key buffer 4 - old high key
!		number of new buckets = 1
!		if original bucket was all rrv's, set IRB$V_EMPTY_BKT flag
!		if new bucket is a continuation bkt., set IRB$V_CONT_BKT flag
!	if 3 bkt split --
!		same as above with these changes:
!		key buffer 3 - implicitly it contains second key to be inserted
!			at the index level
!		IRB$W_SPLIT_1, offset to second split point
!		number of new buckets = 2
!		if right bucket is a continuation bkt, set IRB$V_CONT_R flag
!	if 4 bkt split --
!		same as above with these changes:
!		IRB$W_SPLIT_2, offset to third split point
!		number of new buckets = 3
!
! ROUTINE VALUE:
!	rmssuc
!
! SIDE EFFECTS:
!	AP is clobbered
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_IRAB_STR,
	R_RAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR,
	COMMON_IO_STR;

    LOCAL
	SAVE_REC_W_LO,
	NEED_RRV,
	POS_INSERT,
	EOB,
	RRV,
	RHS,
	LHS,
	LAST	: REF BBLOCK,
	LAST_DIFF,
	BKTSIZE,
	DIFFERENCE;

    LITERAL
	RRV_SIZE = 9;

    LABEL
	DO_IT,
	HALF,
	NEXT;

DO_IT :

    BEGIN

    ! define a block so that we can have some common checks before returning
    ! successfully
    !
HALF :

    BEGIN

    !+
    ! Define a block so that we can simulate a go-to (naughty, naughty),
    ! if we have decided that we are positioning at the end of the bucket
    ! & we're in somewhat of an ascending order, where the last record
    ! inserted is a duplicate of the new record, skip over the 50-50 code
    ! and go to the code to take duplicates into account.
    !
    ! scan 1 -- Calculate size of existing rrv's and total number of rrv's
    ! needed to move the whole bucket out ( worst case).  As a side effect,
    ! adjust eob pointer to point to the rrv's instead of freespace.  Assume
    ! not empty bucket until showed otherwise.
    !-

    IRAB[IRB$V_EMPTY_BKT] = 0;

    ! new rec is tried 1st with hi set, then with lo set
    !
    IRAB[IRB$V_REC_W_LO] = 0;
    IRAB[IRB$V_NEW_BKTS] = 1;	! assume 2-bkt split until showed otherwise
    NEED_RRV = 0;
    POS_INSERT = .REC_ADDR;
    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    EOB = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];
    LAST = 0;

    DO
	BEGIN

	BUILTIN
	    AP;

	IF .REC_ADDR[IRC$V_RRV]
	THEN
	    EXITLOOP;

	AP = 3;

	IF .BDB[BDB$L_VBN] EQLU RM$RECORD_VBN()
	THEN
	    NEED_RRV = .NEED_RRV + 1;

	LAST = .REC_ADDR;
	RM$GETNEXT_REC()
	END
    UNTIL .REC_ADDR GEQU .EOB;			! end of first scan

    ! Now that we have the address of the last record in the bucket, store
    ! the key of that record in key buffer 4, to be used by index updating.
    !
    IF .LAST NEQU 0
    THEN
	BEGIN

	LOCAL
	    TMP_ADDR;

	BUILTIN
	    AP;

	TMP_ADDR = .REC_ADDR;
	REC_ADDR = .LAST;
	AP = 0;			! overhead and compressed form
	RM$RECORD_KEY(KEYBUF_ADDR(4));
	REC_ADDR = .TMP_ADDR;
	END;

    ! Set SPLIT_2 and SPLIT_1 to be EOB, so if there are less than 3 new
    ! buckets BKT_SPL can use the value without having to recalculate it.
    !
    IRAB[IRB$W_SPLIT_1] = IRAB[IRB$W_SPLIT_2] = .REC_ADDR - .BKT_ADDR;

    ! Set up the bucket size
    !
    BKTSIZE = .IDX_DFN[IDX$B_DATBKTSZ]*512 - BKT$C_OVERHDSZ - BKT$C_DATBKTOVH;

    IF .IDX_DFN[IDX$V_DUPKEYS]
    THEN
	BKTSIZE = .BKTSIZE - BKT$C_DUPBKTOVH;


    ! If this is an update, may have to count in an rrv for the existing record
    !

    IF .IRAB[IRB$V_UPDATE]
    THEN
	BEGIN

	IF .BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR], NRP$L_RP_VBN]
	THEN
	    NEED_RRV = .NEED_RRV + 1;
	END;

    RRV = .EOB - .REC_ADDR;			! size of existing rrv's
    EOB = .REC_ADDR;				! adjust eob

    ! special case it, if the bucket was all rrv's
    !

    IF .REC_ADDR EQLU .BKT_ADDR + BKT$C_OVERHDSZ
    THEN
	BEGIN

	! Bkt is all rrv's yet the record wouldn't fit so we need to
	! allocate another bkt ( 2 bkt split). Yet special case it so as not
	! to make another idx entry, only to update the existing one by
	! setting empty bucket flag.
	!
	IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;
	LEAVE DO_IT

	END;			! end { of special case an all-rrv bucket }

    !+
    ! * BLOCK 1 *
    ! Special Case -- If we can detect a possible ascending order to these
    ! records it probably will be better to do a straight point of insert split
    ! which would put the new record in a bucket all by itself.
    ! Do this kind of split if and only if all the following conditions are met:
    !    1) the record is being inserted at the end of bucket
    !    2) the last record physically in the bkt is the last record to have 
    !	    been inserted
    !    3) the last record and the new record do not have duplicate key values 
    !
    ! Note that if they are duplicates, we can still make an optimization by
    ! skipping the 50-50 split code.
    !
    ! Note that LAST cannot be zero, since if it were we would have an all
    ! rrv bkt.
    !-

    IF .POS_INSERT EQLU .REC_ADDR
	AND
	(((.LAST[IRC$W_ID] + 1) AND %X'FFFF') EQLU .BKT_ADDR[BKT$W_NXTRECID])
    THEN
	BEGIN

	REC_ADDR = .LAST;

	! Check for duplicates:
	! If the key is compressed, and the new key has a length of zero, then
	!   we know it is a duplicate of the previous one.
	! If the key is not compressed, then do a straight ASCII compare of the
	!   new key (key buffer 3), and the previous key.
	!

	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    BEGIN

	    IF .(.IRAB[IRB$L_RECBUF])<0,8> NEQU 0
	    THEN
		BEGIN

		! Since we have detected a possible ascending order in the
		! input, let's try to optimize a little and split at the point
		! of insert.  Send the record by itself into the new bucket
		! and store the new high key of the old bucket in keybuf2,
		! the high key of the new bucket in keybuf4, and split point.
		!
		RM$MOVE(.IDX_DFN[IDX$B_KEYSZ],
			KEYBUF_ADDR(4),
			KEYBUF_ADDR(2));
		RM$MOVE(.IDX_DFN[IDX$B_KEYSZ],
			KEYBUF_ADDR(3),
			KEYBUF_ADDR(4));
		IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];
		LEAVE DO_IT;
		END
	    ELSE
		LEAVE HALF
	    END
	ELSE
	    BEGIN

	    LOCAL
		REC_OVHD;

	    BEGIN
	    GLOBAL REGISTER
		R_REC_SIZE;

	    REC_SIZE = 0;
	    REC_OVHD = RM$REC_OVHD();
	    END;

	    IF CH$COMPARE ( .IDX_DFN[IDX$B_KEYSZ],
			    KEYBUF_ADDR(3),
			    .IDX_DFN[IDX$B_KEYSZ],
			    .REC_ADDR + .REC_OVHD )
	    THEN
		BEGIN
		RM$MOVE(.IDX_DFN[IDX$B_KEYSZ],
			KEYBUF_ADDR(4),
			KEYBUF_ADDR(2));
		RM$MOVE(.IDX_DFN[IDX$B_KEYSZ],
			KEYBUF_ADDR(3),
			KEYBUF_ADDR(4));
		IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];
		LEAVE DO_IT;
		END
	    ELSE
		LEAVE HALF
	    END

	! * end of BLOCK 1 *
	!
	END;

    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    LAST_DIFF = %X'7FFFFFFF';
    LAST = 0;
    SAVE_REC_W_LO = 0;

    ! * BLOCK 2 * 
    ! Start from the beginning of the bucket and scan rightward. First find the
    ! 1st place the rhs will fit in 1 bkt then, as long as the lhs will fit in
    ! a bkt, try to find an optimal point. If there is no point where the rhs
    ! and lhs will both fit, we can't do a 2-bkt split and this case will fall
    ! out.
    !

    WHILE 1
    DO
	BEGIN
	RHS = .EOB - .REC_ADDR;

	IF  .REC_ADDR LEQU .POS_INSERT
	    AND
	    NOT .IRAB[IRB$V_REC_W_LO]
	THEN
	    RHS = .RHS + .RECSZ;

	! If the primary key is compressed, add the compression count of the
	! record that will become the first one in the bucket.
	!
	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    BEGIN

	    GLOBAL REGISTER
		R_REC_SIZE;

	    REC_SIZE = 0;
	    RHS = .RHS + .(.REC_ADDR + RM$REC_OVHD() + 1)<0,8>;
	    END;

	! * BLOCK 3 *
	! The right hand side fits if there is enough room and there are id's
	! available. Id's are always available in the new bucket in the update
	! situation, or if we're leaving at least 1 record behind in the old
	! bucket. note that nxtrecid is always zeroed if this is a split due to
	! lack of id's.
	!

	IF  .RHS LSSU .BKTSIZE
	    AND
	    (.BKT_ADDR[BKT$W_NXTRECID] NEQ 0
	    OR
	    .IRAB[IRB$V_UPDATE]
	    OR
	    .REC_ADDR NEQA (.BKT_ADDR + BKT$C_OVERHDSZ)
	    OR
	    .IRAB[IRB$V_REC_W_LO])
	THEN
	    BEGIN
	    LHS = .REC_ADDR - (.BKT_ADDR + BKT$C_OVERHDSZ);

	    IF  .REC_ADDR GEQU .POS_INSERT
		AND
		.IRAB[IRB$V_REC_W_LO]
	    THEN
		LHS = .LHS + .RECSZ;

	    ! * BLOCK 4 *
	    ! will lhs fit ? lhs doesn't fit if there is no space in the
	    ! bucket, or if there won't be any id's available in the bucket.
	    ! if not & if there is no previous point at which it fit, goto 3-bkt
	    ! split code if there is a previous place where we could have had a
	    ! 2-bkt split, use it
	    !

	    IF .LHS + .RRV + (RRV_SIZE * .NEED_RRV) GTRU .BKTSIZE

		! Id's will be available in the original bucket if we aren't
		! out of id's to begin with, if this is an update,
		! or if the new record is going in the new bucket
		!
		OR
		(.BKT_ADDR[BKT$W_NXTRECID] EQL 0
		AND
		NOT .IRAB[IRB$V_UPDATE]
		AND
		.IRAB[IRB$V_REC_W_LO])
	    THEN
		BEGIN

		IF .LAST EQL 0
		THEN
		    EXITLOOP;

		REC_ADDR = .LAST;

		IF NOT .SAVE_REC_W_LO
		THEN
		    IRAB[IRB$V_REC_W_LO] = 0;

		! 2 bkt split is possible rec_addr points to the most
		! optimal place since we had to back up, reset last to point
		! to the record	immediately before the split point
		!
		BEGIN

		LOCAL
		    TMP;

		TMP = .REC_ADDR;
		REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		LAST = .REC_ADDR;

		WHILE .REC_ADDR NEQU .TMP
		DO
		    BEGIN
		    LAST = .REC_ADDR;
		    RM$GETNEXT_REC();
		    END;

		END;
		RM$MOVE_KEY(.LAST, .REC_ADDR);
		IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;

		! treat another exception case of the new record going off into
		! a cont. bkt all by itself
		!

		IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_POS_INS]
		THEN

		    IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_SPLIT_1]
		    THEN

			IF NOT .IRAB[IRB$V_REC_W_LO]
			THEN
			    BEGIN

			    ! If the new last key in the bucket equals the key
			    ! to be inserted in the new bucket, then we have a
			    ! continuation bucket.
			    !
			    IF NOT CH$COMPARE ( .IDX_DFN[IDX$B_KEYSZ],
						KEYBUF_ADDR(2),
						.IDX_DFN[IDX$B_KEYSZ],
						KEYBUF_ADDR(3) )
			    THEN
				IRAB[IRB$V_CONT_BKT] = 1;

			    END;

		LEAVE DO_IT

		END;			! end of * BLOCK 4 * (LHS does not fit)

	    ! lhs fits also, calculate the magic ratio
	    !
	    DIFFERENCE = (.LHS * .BKTSIZE) - 
		(.RHS * (.BKTSIZE - (RRV_SIZE * .NEED_RRV) - .RRV));

	    ! * BLOCK 5 *
	    !

	    IF .DIFFERENCE GEQ 0
	    THEN
		BEGIN

		! found the 1st point at which the magic ratio is positive
		! was the last point more optimal, if so use it
		!

		IF ABS(.DIFFERENCE) GTRU ABS(.LAST_DIFF)
		THEN
		    BEGIN

		    IF .REC_ADDR EQLU .LAST
		    THEN
			IRAB[IRB$V_REC_W_LO] = 0
		    ELSE
			BEGIN
			REC_ADDR = .LAST;

			IF .REC_ADDR LSSU .POS_INSERT
			THEN
			    IRAB[IRB$V_REC_W_LO] = 0;
			END;

		    LAST = 0;
		    END;

		! 2-bkt split is possible rec_addr points to the most
		! optimal place
		!

		IF .LAST EQL 0
		THEN 		! just backed up rec_addr, need to recalc last
		    BEGIN

		    LOCAL
			TMP;

		    TMP = .REC_ADDR;
		    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		    LAST = .REC_ADDR;

		    WHILE .REC_ADDR NEQU .TMP
		    DO
			BEGIN
			LAST = .REC_ADDR;
			RM$GETNEXT_REC();
			END;

		    END;

		RM$MOVE_KEY(.LAST, .REC_ADDR);
		IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;

		! treat another exception case of the new record going off into
		! a cont. bkt all by itself
		!

		IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_POS_INS]
		THEN

		    IF .IRAB[IRB$W_SPLIT] EQLU .IRAB[IRB$W_SPLIT_1]
		    THEN

			IF NOT .IRAB[IRB$V_REC_W_LO]
			THEN
			    BEGIN

			    IF NOT CH$COMPARE
				( .IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(2),
				.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3) )
			    THEN
				IRAB[IRB$V_CONT_BKT] = 1;

			    END;

		LEAVE DO_IT

		END;		! end of * BLOCK 5 *

	    ! the magic ratio isn't positive yet, so save all the context and
	    ! move on to the next record
	    !
	    LAST_DIFF = .DIFFERENCE;
	    LAST = .REC_ADDR;

	    IF .IRAB[IRB$V_REC_W_LO]
	    THEN
		SAVE_REC_W_LO = 1;

	    END;		! end of * BLOCK 3 *

	! Go get the next record, but special case when we are at the position
	! of insert.
	!
NEXT :
	BEGIN

	IF  .REC_ADDR EQLU .POS_INSERT
	    AND
	    NOT .IRAB[IRB$V_REC_W_LO]
	THEN
	    BEGIN

	    ! If this is an update, check to see if it needed an rrv, since
	    ! the record will go in the left bucket.
	    !

	    IF .IRAB[IRB$V_UPDATE]
	    THEN
		BEGIN

		IF .BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR],
			NRP$L_RP_VBN]
		THEN
		    NEED_RRV = .NEED_RRV - 1;

		END;

	    ! Force record to low bucket, and put in key buffer 2 the key
	    ! of the record we are inserting (currently in keybuffer 3).
	    !
	    IRAB[IRB$V_REC_W_LO] = 1;
	    RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3), KEYBUF_ADDR(2));

	    ! If we are inserting at the end of the bucket, or if the record
	    ! at position of insert has a different key from that to be inserted,
	    ! leave NEXT so that no other record goes to the left bucket (so far).
	    ! If the key is a duplicate, then keep them together in the left
	    ! bucket.

	    IF  .REC_ADDR EQLU .EOB
	    THEN
		LEAVE NEXT
	    ELSE
		BEGIN

		GLOBAL REGISTER
		    R_REC_SIZE;

		LOCAL
		    CURR_KEY,
		    REC_OVHD;

		REC_SIZE = 0;
		REC_OVHD = RM$REC_OVHD();

		! When the key is compressed, we must build it first in key
		! buffer 5, and then compare.  This build is easy because we
		! can take the front chars from the key to be inserted.
		!

		IF .IDX_DFN[IDX$V_KEY_COMPR]
		THEN
		    BEGIN
		    CURR_KEY = KEYBUF_ADDR(5);
		    RM$MOVE ( .(.REC_ADDR + .REC_OVHD + 1)<0,8>,
			      KEYBUF_ADDR(2),
			      .CURR_KEY );
		    RM$BUILD_KEY ( .REC_ADDR + .REC_OVHD, .CURR_KEY );
		    END
		ELSE
		    CURR_KEY = .REC_ADDR + .REC_OVHD;

		IF CH$COMPARE ( .IDX_DFN[IDX$B_KEYSZ],
				KEYBUF_ADDR(2),
				.IDX_DFN[IDX$B_KEYSZ],
				.CURR_KEY )
		THEN
		    LEAVE NEXT;
		END;

	    END;	! end of { at position for insert for the 1st time }

	! Fool move key a little by always clearing REC_W_LO so that we get
	! in key buffer 2 the key associated with the record we are pointing to.
	!
	BEGIN

	LOCAL
	    TMP	: BYTE;

	TMP = .IRAB[IRB$B_SPL_BITS];
	IRAB[IRB$V_REC_W_LO] = 0;
	RM$MOVE_KEY(.REC_ADDR, .REC_ADDR);
	IRAB[IRB$B_SPL_BITS] = .TMP
	END;

	! Scan the bucket keeping duplicates together, since we do not want to
	! split in the middle of a duplicate chain.
        !
	BEGIN

	LOCAL
	    REC_OVHD,
	    S_REC_SIZE,
	    NOT_DUP;

	NOT_DUP = 0;		! assume duplicates

	BEGIN			! block to define register REC_SIZE

	GLOBAL REGISTER
	    R_REC_SIZE;

	REC_SIZE = 0;		! indicate primary data level
	REC_OVHD = RM$REC_OVHD();
	S_REC_SIZE = .REC_SIZE;
	END;

	DO
	    BEGIN

	    BUILTIN
		AP;

	    IF .REC_ADDR EQLU .EOB
	    THEN
		EXITLOOP;

	    AP = 3;

	    IF .BDB[BDB$L_VBN] EQLU RM$RECORD_VBN()
	    THEN
		NEED_RRV = .NEED_RRV - 1;

	    REC_ADDR = .REC_ADDR + .REC_OVHD + .S_REC_SIZE;	! get next rec

	    IF .REC_ADDR EQLU .EOB
	    THEN
		EXITLOOP;

	    BEGIN			! block to define register REC_SIZE

	    GLOBAL REGISTER
		R_REC_SIZE;

	    REC_SIZE = 0;		! indicate primary data level
	    REC_OVHD = RM$REC_OVHD();
	    S_REC_SIZE = .REC_SIZE;
	    END;

	    IF .IDX_DFN[IDX$V_KEY_COMPR]
	    THEN
		BEGIN

		IF .(.REC_ADDR + .REC_OVHD)<0,8> NEQU 0
		THEN
		    NOT_DUP = 1;
		END
	    ELSE
		BEGIN

		IF CH$COMPARE( .IDX_DFN[IDX$B_KEYSZ],
				KEYBUF_ADDR(2),
				 .IDX_DFN[IDX$B_KEYSZ],
				 .REC_ADDR + .REC_OVHD )
		THEN
		    NOT_DUP = 1;
		END

	    END

	! Loop until a non-duplicate record is found
	!
	UNTIL .NOT_DUP;

	END;				! end of block defining NOT_DUP

	! If the key compares brought us up to the pos of insert, see if the
	! key of the new record matches the key of the record before the
	! position of insert. If it does, have to include the new record with
	! the lhs.
	!

	IF .REC_ADDR EQLU .POS_INSERT
	THEN
	    BEGIN

	    IF NOT CH$COMPARE( .IDX_DFN[IDX$B_KEYSZ],
				KEYBUF_ADDR(2),
				.IDX_DFN[IDX$B_KEYSZ],
				KEYBUF_ADDR(3) )
	    THEN
		BEGIN
		IRAB[IRB$V_REC_W_LO] = 1;

		IF  .IRAB[IRB$V_UPDATE]
		    AND
		    .BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR],
			NRP$L_RP_VBN]
		THEN
		    NEED_RRV = .NEED_RRV - 1;
		END;

	    END;

	! If we are past the position of insert, then the new record goes in
	! in the low bucket.
	!

	IF .REC_ADDR GTRU .POS_INSERT
	THEN
	    BEGIN
	    IRAB[IRB$V_REC_W_LO] = 1;

	    IF  .IRAB[IRB$V_UPDATE]
		AND
		.BDB[BDB$L_VBN] EQLU .BBLOCK[.IRAB[IRB$L_NRP_PTR],
		    NRP$L_RP_VBN]
	    THEN
		NEED_RRV = .NEED_RRV - 1;
	    END;

	END;		! end of NEXT
	END;		! end of * BLOCK 2 *

    END;		! end of HALF

    ! define a new block here so local storage can be redefined
    !
    BEGIN

    MACRO
	BEG_CHAIN = LHS %,
	END_CHAIN = RHS %,
	DUPS = RRV %;

    BUILTIN
	AP;

    ! Must be a 3 or 4 bucket split or we detected ascending order and the new
    ! record was a dupe.  We'll optimize here to the extent of trying to keep a
    ! dup chain around the new record together and in the middle bucket.
    ! Note that in all the cases that follow the new record is going into the
    ! middle bucket.  Therefore, the "lhs" will always fit, since it can only
    ! get smaller (or stay the same size, in the degenerate case).  Also note
    ! that in any of these cases, the left hand bucket may be empty of data
    ! records (have only rrv's in it) if the first split point is at the
    ! beginning and all data records get moved 
    !
    IRAB[IRB$V_NEW_BKTS] = 2;	! assume 3-bkt split until shown otherwise
    IRAB[IRB$V_REC_W_LO] = 0;

    ! Initialize key buffer 2 with the contents of key buffer 3 (the value
    ! of the primary key of the record being inserted).  This is necessary
    ! when the new record is at the beginning of the bucket and is going into
    ! a bucket all by itself so that all the records in the bucket need rrv's
    ! since they all move into the next bucket.
    ! At any rate, that seems to be the only case where key buffer 2 is not
    ! correct coming into here and will be set correctly before leaving.
    !
    RM$MOVE(.IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3), KEYBUF_ADDR(2));

    ! Find beginning and end of this possible dups chain equal to the key value
    ! of the record being inserted.
    !
    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    BEGIN

    LOCAL
	STATUS,
	REC_OVHD,
	S_REC_SIZE,
	CURR_KEY;

    WHILE 1
    DO
	BEGIN

	BEGIN			! block to define REC_SIZE as register 1

	GLOBAL REGISTER
	    R_REC_SIZE;

	REC_SIZE = 0;
	REC_OVHD = RM$REC_OVHD();
	S_REC_SIZE = .REC_SIZE;
	END;			! end of REC_SIZE block

	! If the key is compressed, it must be rebuilt into keybuffer 5 first
	!

	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    BEGIN
	    CURR_KEY = KEYBUF_ADDR(5);
	    RM$BUILD_KEY ( .REC_ADDR + .REC_OVHD, .CURR_KEY );
	    END
	ELSE
	    ! Otherwise, we are already pointing to the beginning of the key
	    !
	    CURR_KEY = .REC_ADDR + .REC_OVHD;

	STATUS = CH$COMPARE ( .IDX_DFN[IDX$B_KEYSZ],
				KEYBUF_ADDR(3),
				.IDX_DFN[IDX$B_KEYSZ],
				.CURR_KEY );

	IF NOT .STATUS		! If key matched, found beginning of chain
	THEN
	    EXITLOOP;

	IF .REC_ADDR LSSU .POS_INSERT
	THEN
	    RM$MOVE( .IDX_DFN[IDX$B_KEYSZ], .CURR_KEY, KEYBUF_ADDR(2) );

	IF  .REC_ADDR EQLU .EOB
	    OR
	    .STATUS LSS 0
	THEN
	    BEGIN

	    ! !!!! SPLIT TYPE 3 !!!!
	    ! No duplicates found.  For simplicity, do a 3-bkt split at the
	    ! point of insert with the new record in its own bucket.
	    !
	    IRAB[IRB$W_SPLIT] = IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_POS_INS];
	    LEAVE DO_IT

	    ! { end of didn't find a duplicate, put record in its own bucket }
	    !
	    END;

	REC_ADDR = .REC_ADDR + .REC_OVHD + .S_REC_SIZE;
	END;			! { end of while no duplicate has been found }

    END;		! { end of block defining status for while loop }

    ! Found the beginning of the dups chain, now find the end.
    !
    BEG_CHAIN = .REC_ADDR;

    BEGIN

    LOCAL
	NOT_DUP,
	REC_OVHD,
	S_REC_SIZE;

    NOT_DUP = 0;				! assume more duplicates

    BEGIN
    GLOBAL REGISTER
	R_REC_SIZE;

    REC_SIZE = 0;
    REC_OVHD = RM$REC_OVHD();
    S_REC_SIZE = .REC_SIZE;
    END;

    DO
	BEGIN

	REC_ADDR = .REC_ADDR + .REC_OVHD + .S_REC_SIZE;
	IF .REC_ADDR EQLU .EOB
	THEN
	    EXITLOOP;

	BEGIN
	GLOBAL REGISTER
	    R_REC_SIZE;

	REC_SIZE = 0;
	REC_OVHD = RM$REC_OVHD();
	S_REC_SIZE = .REC_SIZE;
	END;

	IF .IDX_DFN[IDX$V_KEY_COMPR]
	THEN
	    BEGIN

	    IF .(.REC_ADDR + .REC_OVHD)<0,8> NEQU 0
	    THEN
		NOT_DUP = 1
	    END
	ELSE
	    BEGIN

	    IF CH$COMPARE ( .IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3),
			    .IDX_DFN[IDX$B_KEYSZ], .REC_ADDR + .REC_OVHD )
	    THEN
		NOT_DUP = 1
	    END;

	END

    UNTIL .NOT_DUP
    END;			! end of found end of dups chain

    END_CHAIN = .REC_ADDR;

    ! Found the beginning and the end of the chain.  Calculate its size.
    ! If we got here via an update, we never called RM$SRCH_BY_KEY to set
    ! DUPS_SEEN for us, so let us do that now if necessary.
    !

    IF .POS_INSERT GTRU .BEG_CHAIN
    THEN
	IRAB[IRB$V_DUPS_SEEN] = 1;

    DUPS = .END_CHAIN - .BEG_CHAIN;
    DUPS = .DUPS + .RECSZ;

    IF .DUPS LSSU .BKTSIZE
    THEN
	BEGIN

	!+
	! !!!! SPLIT TYPE 1 !!!!! 
	! Duplicates found and fortunately, they all fit in one bucket,
        ! so do a 3-bkt split with all of the dups in the middle bucket.
	! Because of the optimization used for dups being inserted "in order"
	! this can sitll be a 2-bkt split if the new record is being inserted
	! at the end of the bucket .
	!
	! 22-jan-79  If LOA forced us to think that a bkt with all dups had to
	! be split ( only on put) be smart and just put new record by itself.
	! A better solution would be not to split at all, but at this date
	! it's rather inconceivable.
	!
	! 23-jan-79  It's not only LOA that can fool us, the bkt might have
	! had a lot of rrv's.
	!-

	IRAB[IRB$W_SPLIT] = .BEG_CHAIN - .BKT_ADDR;
	IRAB[IRB$W_SPLIT_1] = .END_CHAIN - .BKT_ADDR;

	IF .END_CHAIN EQLU .EOB
	THEN
	    BEGIN
	    IRAB[IRB$V_NEW_BKTS] = 1;

	    IF .BEG_CHAIN EQLU (.BKT_ADDR + BKT$C_OVERHDSZ)
	    THEN
		BEGIN
		IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_SPLIT_2];
		IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];
		IRAB[IRB$V_CONT_BKT] = 1;
		END

	    END
	ELSE
	    BEGIN

	    IF .IRAB[IRB$W_SPLIT] EQLU BKT$C_OVERHDSZ<0, 16>
	    THEN
		IRAB[IRB$V_EMPTY_BKT] = 1;

	    ! Only force record into the low bucket if it is not the first
	    ! one in a duplicate chain.
	    !

	    IF .END_CHAIN GEQU .POS_INSERT
	      AND .IRAB[IRB$W_SPLIT] NEQU .IRAB[IRB$W_POS_INS]
	    THEN
		IRAB[IRB$V_REC_W_LO] = 1;
	    END;

	LEAVE DO_IT

	END;	! { end of duplicates found and they fit in one bucket }

    ! This next test can only happen on an update so the all dupes case
    ! will fall thru to split type 2, which will put the new record by itself.
    ! Consider oddball update case in which there are dups before and after
    ! position of insert. ( note that if this case doesn't apply, the duplicates
    ! were only before or after -- and didn't fit with record -- so new record
    ! will end up by itself.  For code flow purposes, leave that till later).
    !

    IF  .IRAB[IRB$V_DUPS_SEEN]
	AND
	.END_CHAIN GTRU .POS_INSERT
    THEN
	BEGIN

	IF .DUPS - (.POS_INSERT - .BEG_CHAIN) LSSU .BKTSIZE
	THEN

	    ! if high dups will fit with record, put them in a bucket together
	    !
	    BEGIN

	    !+
	    ! !!!! SPLIT TYPE 4 !!!! 
	    ! 3 bkt split where middle bkt is a continuation bkt containing 
	    ! new record and dups following it
	    !
	    ! !!!! AND SPLIT TYPE 4B !!!!! however, if the hi set consists
	    ! solely of duplicates, we can still have a 2-bkt split case that
	    ! would not have been picked up by the previous algorithm ( since
	    ! it won't divide dups).
	    !-

	    IRAB[IRB$V_CONT_BKT] = 1;
	    IRAB[IRB$W_SPLIT] = .IRAB[IRB$W_POS_INS];

	    IF .END_CHAIN EQLU .EOB
	    THEN
		IRAB[IRB$V_NEW_BKTS] = 1
	    ELSE
		IRAB[IRB$W_SPLIT_1] = .END_CHAIN - .BKT_ADDR;

	    REC_ADDR = .BEG_CHAIN;
	    RM$MOVE ( .IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3), KEYBUF_ADDR(2) );
	    LEAVE DO_IT

	    END;

	! try to fit new record with before-dups in middle bucket
	!

	IF .DUPS - (.END_CHAIN - .POS_INSERT) LSSU .BKTSIZE
	THEN
	    BEGIN

	    !+
	    ! !!!! SPLIT TYPE 5 !!!!! 
	    ! 3 or 4 bkt split ( depending on status of
	    ! high set) where left-middle bkt is new record with before-dups
	    ! and right-middle bkt, if it is needed, is a continuation bkt
	    ! with the after-dups. it is needed if the dups aren't the whole hi
	    ! set it still is a continuation bkt.
	    !
	    ! ***** NOTE FROM NOV-7-78
	    ! This case doesn't take into account the fact that the
	    ! whole bucket may be dups.  In the case of all dups, we could
	    ! end up generating an empty bucket when we don't have to (if
	    ! no RRV's) or a relatively useless bucket (some RRV's). In any
	    ! event we could end up generating an extra bucket when we
	    ! don't have to
	    !-

	    IRAB[IRB$W_SPLIT] = .BEG_CHAIN - .BKT_ADDR;
	    IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_POS_INS];

	    IF .IRAB[IRB$W_SPLIT] EQLU BKT$C_OVERHDSZ<0, 16>
	    THEN
		IRAB[IRB$V_EMPTY_BKT] = 1;

	    IRAB[IRB$V_REC_W_LO] = 1;

	    IF .END_CHAIN LSSU .EOB
	    THEN
		BEGIN
		IRAB[IRB$V_NEW_BKTS] = 3;
		IRAB[IRB$W_SPLIT_2] = .END_CHAIN - .BKT_ADDR;
		END
	    ELSE
		IRAB[IRB$V_CONT_R] = 1;

	    LEAVE DO_IT

	    END;

	! { end of oddball update case with dups on both sides of new record }
	!
	END;

    !+
    ! !!!! SPLIT TYPE 2 !!!!!
    ! the new record must go all by itself therefore,
    ! this is a 3-bkt split if there are no after-dups or no hi set and a 4-bkt
    ! split if both of those exist even more exceptional, this can still be a
    ! 2-bkt split if there is no hi set at all ---- i.e., eob = end of the dups
    ! chain
    !-

    IRAB[IRB$W_SPLIT] = IRAB[IRB$W_SPLIT_1] = .IRAB[IRB$W_POS_INS];

    IF  .IRAB[IRB$V_DUPS_SEEN]
    THEN
	BEGIN
	IRAB[IRB$V_CONT_BKT] = 1;
	REC_ADDR = .BEG_CHAIN;
	RM$MOVE ( .IDX_DFN[IDX$B_KEYSZ], KEYBUF_ADDR(3), KEYBUF_ADDR(2) );
	END;

    IF .POS_INSERT EQLU .EOB
    THEN
	IRAB[IRB$V_NEW_BKTS] = 1
    ELSE

	IF .POS_INSERT LSSU .END_CHAIN
	THEN
	    BEGIN

	    IF .END_CHAIN LSSU .EOB
	    THEN
		IRAB[IRB$V_NEW_BKTS] = 3
	    ELSE
		IRAB[IRB$V_CONT_R] = 1;

	    IRAB[IRB$W_SPLIT_2] = .END_CHAIN - .BKT_ADDR;
	    END;

    END;			! { end of block defining local symbols }

    END;					! { end of do_it }

    ! if the first split point is at the beginning of the data, this means that
    ! all data records will be moved out and only rrv's will be left in the
    ! original bucket ..... therefore, we can mark this bucket as empty
    !

    IF  .IRAB[IRB$W_SPLIT] EQLU BKT$C_OVERHDSZ<0, 16>
	AND
	NOT .IRAB[IRB$V_REC_W_LO]
    THEN
	IRAB[IRB$V_EMPTY_BKT] = 1;

    RETURN;

    END;					! { end of routine }

END

ELUDOM
