MODULE RM3CREATE (LANGUAGE (BLISS32) ,
		IDENT = 'V03-001'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!		This module is the index sequential specific create code
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        D. H. Gillespie     CREATION DATE:        	17-JUL-78  15:18
!
!
! MODIFIED BY:
!
!	V03-001 LJA0007		Laurie Anderson 	25-Mar-1982
!		Change KBUFSZ to reference a macro when computing buffer 
!		size and make IFB$B_KBUFSZ a word, now: IFB$W_KBUFSZ.
!
!	V02-033	RAS0072		Ron Schaefer		22-Feb-1982
!		Complete RAS0070/71 by completely ignoring XAB$B_TYPx
!		fields.  Maybe when someone finishes the design, we
!		will be able to implement mixed datatypes.
!
!	V02-032	RAS0071		Ron Schaefer		18-Feb-1982
!		Fix RAS0070 so that only TYP1 thru TYP7 are checked for
!		non-string dataype.
!
!	V02-031	RAS0070		Ron Schaefer		16-Feb-1982
!		Correct the prolog/datatype checks to prohibit
!		non-string Prolog 3.
!
!	V02-030	CDS0037		C Saether		 5-Feb-1982
!		Back out V02-027.
!
!	V02-029	TMK0002		Todd M. Katz		17-Jan-1982
!		The routine CHECK_OVERLAP is supposed to make sure that
!		the component parts of a multiple segment prolog 3 primary
!		key do not overlap.  However, if two segments were directly
!		adjacent, this routine was returning that they overlapped
!		because it was calculating the end points of the segments as
!		if keys could only begin at a position of 1 instead of at a
!		position of 0. Fix how the endpoints of segments are 
!		calculated.
!
!	V02-028	TMK0001		Todd M. Katz		15-Jan-1982
!		Enable index compression as the default for prolog three files
!		with key sizes greater than 5 characters.
!
!	V02-027	CDS0036		C Saether		15-Jan-1982
!		Store GBC field in the prolog.
!
!	V02-026	CDS0035		C Saether		9-Jan-1982
!		Rename psect to put this in the boonies and stop breaking
!		branches elsewhere.
!
!	V02-025	RAS0059		Ron Schaefer		8-Jan-1982
!		Fix several bugs in prologs, and areas:
!		    1. Change XAB$B_STRUCT to XAB$B_PROLOG.
!		    2. Eliminate XAB$B_COMPAT.
!		    3. Make key XAB requests for prolog level hard.
!		    4. Properly make prolog2 for REF=0,DTP=STG and REF=1,DTP=x.
!		    5. Fix duplicate buffer release bug on area allocation errors.
!
!	V02-024	PSK0006		Paulina S. Knibbe	02-Dec-1981
!		Fix problems in the way datatype is detected in long
!		key xabs.
!
!	V02-023	CDS0035		C Saether		 4-Nov-1981
!		Change reference to "xab$b_structure" to be
!		"xab$b_struct".
!
!	V02-022	PSK0005		Paulina S. Knibbe	20-Oct-1981
!		Change the compatiblity options to the RMS XAB constants.
!		Fix some random bugs in the way error checking was done.
!
!	V02-021	PSK0004		Paulina S. Knibbe	28-Sep-1981
!		Shorten XAB$B_COMPAT_BITS to XAB$B_CMP_BITS
!
!	V02-020	PSK0003		Paulina S. Knibbe	11-Sep-1981
!		Fix some more problems with multi-segmented keys
!
!	V02-019	CDS0034		C Saether		06-Sep-1981
!		Initialize variables in CHECK_1_2
!
!	V02-018	PSK0002		Paulina S. Knibbe	31-Aug-1981
!		If a segmented key has a zero length string segment,
!		return an error.
!
!	V02-017	CDS0033		C Saether		29-Aug-1981
!		Allocate lock BLB instead of BDB.  Don't allocate
!		a BCB anymore.
!
!	V02-016	PSK0001		Paulina S. Knibbe	25-Aug-1981
!		Add routine FIND_PLG_VER to return the highest possible
!		prologue version for a given file.
!
!	V02-015 MCN0001		Maria del C. Nasr	11-Aug-1981
!		Modify to create prologue 3 files.
!
!	V02-014	CDS0032		C Saether		 9-Aug-1981
!		Remove reference to RETBCB linkage, modify RELEASE linkage.
!
!	V02-013	REFORMAT	R A Schaefer		23-Jul-1980	14:07
!		Reformat the source
!
!	V02-012	RAS0011		R A Schaefer		09-Jan-1980	10:20
!		Correct REPROBE routine to allow for no XABs at all
!
!	V02-011	RAS0004		R A Schaefer		29-Nov-1979	08:50
!		Correct several small glitches:
!		1.  The LAN value in XABKEY was incorrectly defaulted to IAN.
!		2.  The RFI value in XABALL was incorrectly used.
!		3.  The KNM value in XABKAY was inadequately probed.
!
!	V02-010	CDS0031		C D Saether		21-Sep-1979	14:30
!		fix checking of legal pos and siz for non-string datatype
!
! 	V02-009	RAN0005		R A Newell		24-Jan-1979	13:58
!		UPDATE OF END BLOCK AND HIGH BLOCK FIELDS
!
! REVISION HISTORY:
!
!   Wendy Koenig, 	24-OCT-78  14:01
!   X0002 - MAKE CHANGES CAUSED BY SHARING CONVENTIONS
!
!   D. H. Gillespie, 	30-OCT-78  15:29
!   X0003 - FIX CREATE IF PROBLEMS
!
!   Wendy Koenig, 	3-NOV-78  8:53
!   X0004 - DON'T NEED UBUFSZ ANYMORE
!
!   D. H. Gillespie, 	16-NOV-78  10:44
!   X0005 - make changes for sharing
!
!   Wendy Koenig, 	1-DEC-78  14:08
!   X0006 - DEALLOCATE BCB AT END OF CREATE (IF ERROR IT WILL BE DEALLOCATED ELSEWHERE)
!
!   Wendy Koenig, 	11-JAN-79  10:22
!   X0007 - PLG VERSION 2 IF DATATYPE NOT EQUAL STRING
!
!   Christian Saether, 	12-JAN-79  18:20
!   X0008 - do not return BCB in CREATE - RELEASEALL will do it
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! define default psects for code
!
! Note:  If the PSECT for this module is not in the middle of RMS
!	the branch range problem goes away.
!

PSECT
    CODE = Z$CREATE3(PSECT_ATTR),
    PLIT = Z$CREATE3(PSECT_ATTR);

! Linkages
!

LINKAGE
    L_AL_KEY_DESC,
    L_ALBDB,
    L_BUG3,
    L_CACHE,
    L_CREATE3B,
    L_CREATECOM,
    L_EXTEND0,
    L_MAKSUM,
    L_RELEASE_FAB,
    L_UPD_SIFB_EOF;

! Local linkage definitions
!

LINKAGE
    RL$AL_KEY 		= JSB () : GLOBAL (COMMON_FABREG),
    RL$FILL 		= JSB (),
    RL$EXTEND 		= JSB (REGISTER = 7) : GLOBAL (COMMON_FABREG, XAB = 6)
			NOPRESERVE (2),
    RL$MOVE 		= JSB () : GLOBAL (XAB = 6, BUF = 7),
    RL$CHECK_OVERLAP	= JSB () : GLOBAL (XAB = 6) PRESERVE (1),
    RL$CHECK_MRS	= JSB () : GLOBAL (R_FAB, R_IFAB, XAB = 6) PRESERVE (1),
    RL$CHECK_INPUT	= JSB () : GLOBAL (R_FAB, R_IFAB, XAB = 6, PLG_VER=7),
    RL$GET_BKS 		= JSB () : GLOBAL (R_FAB, R_IFAB),
    RL$CHECK_STRUCT	= JSB (REGISTER=0) : GLOBAL (XAB=6,PLG_VER=7,R_FAB,R_IFAB),
    RL$FIND_PLG_VER	= JSB () : GLOBAL (XAB = 6, PLG_VER = 7, R_FAB, R_IFAB),
    RL$GET_KEY 		= JSB () : GLOBAL (KEYSIZE = 1, MINREC = 2, SEGS = 3, XAB = 6)
			NOTUSED (9, 10, 11),
    RL$REPROBE 		= JSB () : GLOBAL (R_IFAB, R_FAB) PRESERVE (1),
    RL$READ_PROLOG 	= JSB () : GLOBAL (COMMON_FABREG, R_BDB),
    RL$WRITE_PROLOG 	= JSB () : GLOBAL (R_BDB,COMMON_FABREG);

! Forward Routines
!

FORWARD ROUTINE
    CHECK_MRS		: RL$CHECK_MRS,
    CHECK_OVERLAP	: RL$CHECK_OVERLAP,
    EXTEND 		: RL$EXTEND,
    CHECK_STRUCT	: RL$CHECK_STRUCT,
    FIND_PLG_VER	: RL$FIND_PLG_VER,
    GET_BKS 		: RL$GET_BKS,
    GET_KEY_PARMS 	: RL$GET_KEY,
    CHECK_INPUT 	: RL$CHECK_INPUT,
    FILL		: RL$FILL NOVALUE,
    MOVE		: RL$MOVE NOVALUE,
    AL_KEY_DESC		: RL$AL_KEY,
    WRITE_PROLOGUE	: RL$WRITE_PROLOG,
    REPROBE		: RL$REPROBE,
    READ_PROLOGUE	: RL$READ_PROLOG,
    RM$CREATE3B 	: RL$CREATE3B;

! External Routines
!

EXTERNAL ROUTINE
    RM$AL_KEY_DESC	: RL$AL_KEY_DESC ADDRESSING_MODE(GENERAL),
    RM$ALBLB		: RL$ALBDB ADDRESSING_MODE(GENERAL),
    RM$BUG3		: RL$BUG3 ADDRESSING_MODE(GENERAL),
    RM$CACHE		: RL$CACHE ADDRESSING_MODE(GENERAL),
    RM$CREATECOM	: RL$CREATECOM ADDRESSING_MODE(GENERAL),
    RM$EXTEND0		: RL$EXTEND0 ADDRESSING_MODE(GENERAL),
    RM$MAKSUM		: RL$MAKSUM ADDRESSING_MODE(GENERAL),
    RM$RELEASE		: RL$RELEASE_FAB ADDRESSING_MODE(GENERAL),
    RM$UPD_SIFB_EOF	: RL$UPD_SIFB_EOF ADDRESSING_MODE(GENERAL);

EXTERNAL
    PIO$GB_RMSPROLOG: ADDRESSING_MODE (GENERAL), 	! These symbols are defined in the SHELL
    SYS$GB_RMSPROLOG: ADDRESSING_MODE (GENERAL); 	! These symbols are defined in SYSPARAM


ROUTINE CHECK_3 : RL$FIND_PLG_VER =
!++
!
! CHECK_3
!
!	This routine checks a key XAB to determine if it is a valid
!	prologue three key.
!
! Input
!
!	XAB
!
! Output
!
!	PLG_VER
!	STATUS
!
!--
BEGIN

EXTERNAL REGISTER
    R_FAB_STR,
    R_IFAB_STR,
    XAB = 6,
    PLG_VER = 7;

GLOBAL REGISTER
    SEGS = 3;

MAP
    XAB : REF BBLOCK;

LOCAL
    STATUS;

PLG_VER = 3;

! TEMPORARY CHECK, Take out when SIDR's work !
! Only allow prolog3 for single key files.
! This check is dependent upon the fact that the key XABs are dense.
!
BEGIN

LOCAL
    TEMP : REF BBLOCK;

TEMP = .XAB [XAB$L_NXT];

IF .TEMP NEQ 0 
THEN
    BEGIN
    IFNORD( %REF($BYTEOFFSET(XAB$B_COD) + $FIELDWIDTH(XAB$B_COD)/8),
	    .TEMP, IFAB[IFB$B_MODE],
	    (FAB[FAB$L_STV] = .TEMP;
	     RETURN RMSERR(XAB)));
    IF .TEMP[XAB$B_COD] EQL XAB$C_KEY
    THEN
	RETURN RMSERR(KEY);
    END;
END;

!  Now check for non-string datatypes.
!
IF .XAB [XAB$B_DTP] NEQ XAB$C_STG
THEN
    RETURN RMSERR(KEY);

! Get the relevant parameters for this XAB
!

BEGIN

GLOBAL REGISTER
    KEYSIZE = 1,
    MINREC = 2;

IF NOT (STATUS = GET_KEY_PARMS(3))
THEN
    RETURN .STATUS;

END;

! If this is a primary key, check that the
! segments don't overlap
!

IF .XAB [XAB$B_REF] EQLU 0
THEN

    IF NOT CHECK_OVERLAP (.SEGS)
    THEN
	RETURN RMSERR(SEG);

! Check that the MRS will fit
!
IF NOT CHECK_MRS (3)
THEN
    RETURN RMSERR(MRS);

RETURN RMSSUC();
END;

ROUTINE CHECK_1_2 : RL$FIND_PLG_VER =
!++
!
! CHECK_1_2
!
!	This routine checks a key XAB to determine if it is a 
!	valid prologue 1 or 2 key.
!
! Input
!	XAB
!
! Output
!	PLG_VER
!	STATUS
!
!--
BEGIN

EXTERNAL REGISTER
    XAB = 6,
    PLG_VER = 7;

MAP 
    XAB : REF BBLOCK;

! Set prolog 1 for now, we will change to prolog 2 if any non-string
! datatypes are encountered further on in the scan.
!
PLG_VER = PLG$C_VER_NO;

RETURN RMSSUC();
END;

ROUTINE CHECK_STRUCT (STRUCT) : RL$CHECK_STRUCT =
!++
!
! CHECK_STRUCT
!
!	This routine finds the highest structure (starting
!	with STRUCT) that can handle this key XAB.
!
! INPUT
!
!	STRUCT
!	XAB
!
! OUTPUT
!
!	PLG_VER
!	STATUS
!
!---
BEGIN

EXTERNAL REGISTER
    R_IFAB,
    R_FAB,
    XAB = 6,
    PLG_VER = 7;

LOCAL
    STATUS;

DECR I FROM .STRUCT TO 1 DO

    BEGIN
    CASE .I FROM 0 TO 3 OF

	SET

	[1,2] : ! Prologue 1 
		!
		BEGIN
		STATUS = CHECK_1_2 ();

		IF .STATUS
		THEN
		    RETURN .STATUS;
		END;

	[0,3] :	! Prologue 3
		!
		BEGIN
		STATUS = CHECK_3();

		IF .STATUS
		THEN
		    RETURN .STATUS;
		END;

	[OUTRANGE] : ! Invalid structure number
		RETURN RMSERR(KEY);
	TES;
    END;

! If we got here, no structure worked
!
RETURN .STATUS
END;



ROUTINE FIND_PLG_VER : RL$FIND_PLG_VER =

!++
!
! FIND_PLG_VER
!
!	This routine examines the key XAB and determines the prologue
!	version depending on a series of parameters.
!
! CALLING SEQUENCE:
!	FIND_PLG_VER()
!
! INPUT PARAMETERS:
!	None
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!
! OUTPUT PARAMETERS:
!	PLG_VER
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!	R0 :  Success or KEY 
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB,
	R_FAB,
	XAB = 6,
	PLG_VER = 7;

    MAP
	XAB : REF BBLOCK;

    LOCAL
	STATUS,
	STRUCT;

    ! First check if the user actually specified a structure number
    !
    PLG_VER = 0;
    STATUS = RMSERR (KEY);

    IF .XAB [XAB$B_BLN] GEQU XAB$C_KEYLEN
    THEN

	! The user has a long key XAB
	!
	BEGIN

	IF .XAB [XAB$B_PROLOG] GTRU 0
	THEN

	    ! We have an explicit structure number
	    ! Check that there is a valid key XAB for that
	    ! structure.
	    !
	    BEGIN


	    RETURN (CASE .XAB [XAB$B_PROLOG] FROM 1 TO 3 OF
		SET
		[1,2] : STATUS = CHECK_1_2(.XAB);
		[3]   : STATUS = CHECK_3(.XAB);
		[OUTRANGE] : 0;
		TES);

	    END;

	END;

    ! Either the user has a short XAB or he didn't specify structure 
    ! number or compatibility bits.
    ! Look for process and system defaults.
    !

    STRUCT = .PIO$GB_RMSPROLOG<0,8>;

    IF .STRUCT NEQU 0
    THEN
	! There is a default process structure level
	!
	RETURN CHECK_STRUCT (.STRUCT);
	    
    STRUCT = .SYS$GB_RMSPROLOG<0,8>;

    IF .STRUCT NEQU 0
    THEN
	! There is a default system structure level
	!
	RETURN CHECK_STRUCT (.STRUCT);

    ! Try for the best there is
    !
    RETURN CHECK_STRUCT (3);

END;

ROUTINE EXTEND (BUF) : RL$EXTEND =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is an interface to RM$EXTEND0
!
!
! CALLING SEQUENCE:
!	EXTEND(BUF)
!
! INPUT PARAMETERS:
!	BUF	- address of area buffer
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	BUF[AREA$L_CVNB] 	- start VBN
!	BUF[AREA$L_ENDVBNP1]	- # of VBN's in extent
!	BUF[AREA$L_NXTVBN]	- start VBN
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    MAP
	BUF	: REF BBLOCK;

    EXTERNAL REGISTER
	COMMON_FAB_STR,
	XAB = 6	: REF BBLOCK;

    LOCAL
	EXTEND_QT;

    ! This is a crock to avoid stack problems:
    ! Save the XAB address in area buffer
    !
    BUF[AREA$L_CVBN] = .XAB;
    EXTEND_QT = .XAB[XAB$L_ALQ];
    XAB[XAB$L_ALQ] = 0;
    BEGIN

    GLOBAL REGISTER
	ENDVBNP1 = 2,
	STARTVBN = 1;

    RETURN_ON_ERROR (RM$EXTEND0(.EXTEND_QT),
	BEGIN
	XAB = .BUF[AREA$L_CVBN]
	END);

    ENDVBNP1 = .XAB;		! XAB is R6 which is now end VBN + 1 of extend

    ! Set up IFAB EBK and HBK data
    !
    IFAB[IFB$L_EBK] = .ENDVBNP1;
    IFAB[IFB$L_HBK] = .ENDVBNP1 - 1;

    ! If we are sharing the file set up the shared IFAB data for EBK and HBK
    !
    BEGIN

    LOCAL
	PTR	: REF BBLOCK;

    IF .IFAB[IFB$L_FRB_PTR] NEQ 0
    THEN
	BEGIN
	PTR = .BBLOCK[.IFAB[IFB$L_FRB_PTR], FRB$L_SIFAB_PTR];
	PTR[SIFB$L_EBK] = .IFAB[IFB$L_EBK];
	PTR[SIFB$L_HBK] = .IFAB[IFB$L_HBK];
	END;
    END;

    XAB = .BUF[AREA$L_CVBN];			! Get back XAB address

    RETURN_ON_ERROR (REPROBE());

    BUF[AREA$L_CVBN] = .STARTVBN;
    BUF[AREA$L_NXTVBN] = .STARTVBN;
    BUF[AREA$L_CNBLK] = .ENDVBNP1 - .STARTVBN;
    END;

    XAB[XAB$L_ALQ] = .BUF[AREA$L_CNBLK];
    FAB[FAB$L_ALQ] = .FAB[FAB$L_ALQ] + .XAB[XAB$L_ALQ];
    RETURN 1;

    END;

ROUTINE GET_BKS (AREA) : RL$GET_BKS =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns the bucket size for a given area.
!
! CALLING SEQUENCE:
!	GET_BKS(ARG1)
!
! INPUT PARAMETERS:
!	ARG1 - area code
!
! IMPLICIT INPUTS:
!	FAB		- address of user's FAB
!	FAB[FAB$L_XAB]	- XAB chain
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	Number of buckets
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_FAB_STR;

    LOCAL
	XAB	: REF BBLOCK;

    XAB = .FAB[FAB$L_XAB];			! get start of XAB chain

    UNTIL .XAB EQL 0			! look for area code in XAB chain
	OR
	(.XAB[XAB$B_COD] EQL XAB$C_ALL
	AND
	.XAB[XAB$B_AID] EQL .AREA<0, 8>)
    DO
	XAB = .XAB[XAB$L_NXT];

    ! If there is no area XAB, then default bucket size is taken from the IFAB
    !

    IF .XAB EQL 0
    THEN
	RETURN .IFAB[IFB$B_BKS];

    RETURN .XAB[XAB$B_BKZ];

    END;					! end of GET_BKS

ROUTINE GET_KEY_PARMS(PLG_VER) : RL$GET_KEY =

!++
!
! GET_KEY_PARMS
!
!	This routine determines the number of segments in a key,
!	the size of the key, and the minimum record size containing key.
!	It also does key type and size validation at the segment level.
!
! CALLING SEQUENCE:
!	GET_KEY_PARMS()
!
! INPUT PARAMETERS:
!	PLG_VER - prologue version number
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!
! OUTPUT PARAMETERS:
!	KEYSIZE - total number of characters in key
!	MINREC  - minimum size of record necessary to contain key
!	SEGS - number of segments in key
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	R0 :  error code or success
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	KEYSIZE = 1,
	MINREC = 2,
	SEGS = 3,
	XAB = 6	: REF BBLOCK;

    LOCAL
	LEN	: REF VECTOR [, BYTE],
	POS	: REF VECTOR [, WORD],
	TYP	: REF VECTOR [, BYTE];

    POS = XAB[XAB$W_POS];
    LEN = XAB[XAB$B_SIZ];
    SEGS = 0;
    MINREC = 0;
    KEYSIZE = 0;

    ! When heirarchical keys (keys with mixed datatype segments get
    ! implemented, then this code is inadequate.
    !
	BEGIN

	INCR I FROM 0 TO 7 DO
	    BEGIN

	    IF .LEN[.I] NEQ 0
	    THEN
		BEGIN
		SEGS = .SEGS + 1;
		KEYSIZE = .KEYSIZE + .LEN[.I];

		IF .POS[.I] + .LEN[.I] GTRU .MINREC
		THEN
		    MINREC = .POS[.I] + .LEN[.I];
		END
	    ELSE
		EXITLOOP;
	    END;

	IF .SEGS GTRU 1  AND
	   .XAB[XAB$B_DTP] NEQ XAB$C_STG
	THEN
	    RETURN RMSERR(SEG);

	CASE .XAB[XAB$B_DTP] FROM XAB$C_STG TO XAB$C_PAC OF
	    SET

	    [XAB$C_STG]:			! string data type
		IF .KEYSIZE EQL 0  OR  .KEYSIZE GTRU 255
		THEN
		    RETURN RMSERR(SIZ);

	    [XAB$C_IN2, XAB$C_BN2] :		! 2-byte integer or binary
		BEGIN
		IF .KEYSIZE EQL 0
		THEN
		    BEGIN
		    KEYSIZE = 2;
		    XAB[XAB$B_SIZ0] = .KEYSIZE;
		    END;

		IF .KEYSIZE NEQ 2
		THEN
		    RETURN RMSERR(SIZ);
		END;

	    [XAB$C_IN4, XAB$C_BN4] :		! 4-byte integer or binary
		BEGIN
		IF .KEYSIZE EQL 0
		THEN
		    BEGIN
		    KEYSIZE = 4;
		    XAB[XAB$B_SIZ0] = .KEYSIZE;
		    END;

		IF .KEYSIZE NEQ 4
		THEN
		    RETURN RMSERR(SIZ);
		END;

	    [XAB$C_PAC] :			! packed decimal string
		IF .KEYSIZE GTRU 16		! max size is 31 nibbles + sign
		  OR .KEYSIZE EQL 0
		THEN
		    RETURN RMSERR(SIZ);

	    [OUTRANGE] :			! illegal data type
		RETURN RMSERR(DTP);

	    TES;
	END;

    RETURN 1;

    END;					! end of GET_KEY_PARMS

ROUTINE CHECK_OVERLAP(NO_SEGS) : RL$CHECK_OVERLAP =

!++
!
! CHECK_OVERLAP
!
!	This routine checks if the segments of the primary key for prologue
!	3 files overlap, or not.
!
! CALLING SEQUENCE:
!	CHECK_OVERLAP(NO_SEGS)
!
! INPUT PARAMETERS:
!	NO_SEGS :  number of segments in primary key
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	R0 :  1 - segments do not overlap
!	      0 - segments overlap
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	XAB = 6	: REF BBLOCK;

    LOCAL
	START1,
	END1,
	START2,
	END2,
	LEN	: REF VECTOR [, BYTE],
	POS	: REF VECTOR [, WORD];

    POS = XAB[XAB$W_POS];
    LEN = XAB[XAB$B_SIZ];

    ! To find out if any segments in the primary key overlap, we must
    ! find the starting and ending position of a given segment, and
    ! compare these values with the starting and ending position of all
    ! other segments in the key.
    !

    INCR I FROM 0 TO (.NO_SEGS - 2)
    DO
	BEGIN
	START1 = .POS[.I];
	END1 = .POS[.I] + .LEN[.I] - 1;

	INCR J FROM .I+1 TO (.NO_SEGS - 1)
	DO
	    BEGIN
	    START2 = .POS[.J];
	    END2 = .POS[.J] + .LEN[.J] - 1;

	    IF ((.START1 GEQ .START2) AND (.START1 LEQ .END2))
	      OR ((.END1 GEQ .START2) AND (.END1 LEQ .END2))
		OR ((.START1 LEQ .START2) AND (.END1 GEQ .END2))
	    THEN
		RETURN RMSERR(KEY);
	    END;			! end of INCR J loop
	END;				! end of INCR I loop

    RETURN 1;				! return success

    END;	


ROUTINE CHECK_MRS (PLG_VER) : RL$CHECK_MRS =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine calculates the minimum bucket size if not specified by
!	the user, and checks that the maximum record size fits in a bucket.
!
! CALLING SEQUENCE:
!	CHECK_MRS(PLG_VER)
!
! INPUT PARAMETERS:
!	PLG_VER :  prologue version
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!	FAB	 - address of file access block
!	IFAB	 - address of internal FAB
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	R0 :  MRS error if record does not fit in bucket
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_FAB_STR,
	R_IFAB_STR,
	XAB = 6	: REF BBLOCK;

    ! If the user did not specify a bucket size, find the minimum size.
    !

    IF .IFAB[IFB$B_BKS] EQL 0
    THEN
	BEGIN

	LOCAL
	    BYTES;

	IF .PLG_VER LSSU 3
	THEN
	    BEGIN
	    BYTES = .IFAB[IFB$W_MRS] + BKT$C_OVERHDSZ + IRC$C_FIXOVHDSZ;

	    IF .IFAB[IFB$B_RFMORG] EQL FAB$C_VAR
	    THEN
		BYTES = .BYTES + (IRC$C_VAROVHDSZ - IRC$C_FIXOVHDSZ);

	    END
	ELSE

	    ! Assume all kinds of compressions on for prologue 3 files...
	    !
	    BYTES = .IFAB[IFB$W_MRS] + BKT$C_OVERHDSZ + BKT$C_DATBKTOVH
			+ BKT$C_DUPBKTOVH + IRC$C_VAROVHSZ3 + IRC$C_KEYCMPOVH
			+ IRC$C_DATCMPOVH;

	IFAB[IFB$B_BKS] = (.BYTES/512) + 1;

	! If the bucket size defaults to one, make it 2 to optimize space.
	!

	IF .IFAB[IFB$B_BKS] EQL 1
	THEN
	    IFAB[IFB$B_BKS] = 2;
	FAB[IFB$B_BKS] = .IFAB[IFB$B_BKS];
	END;					! end of bucket size defaulting

    ! Decide if maximum record size will fit in bucket.
    ! For prologue 3 files, we have to consider all possible overhead due to
    ! compression.  Only do these calculations if MRS specified.
    !

    IF .IFAB[IFB$W_MRS] NEQU 0
    THEN
	BEGIN

	LOCAL
	    BYTES_IN_BKS;

	IF .PLG_VER LSSU 3
	THEN
	    BEGIN

	    BYTES_IN_BKS = (.IFAB[IFB$B_BKS]*512) - BKT$C_OVERHDSZ - 1 -
	    	    	IRC$C_FIXOVHDSZ;	    	    	    ! -1 for check byte at end

	    IF .IFAB[IFB$B_RFMORG] EQL FAB$C_VAR
	    THEN
	        BYTES_IN_BKS = .BYTES_IN_BKS - (IRC$C_VAROVHDSZ - IRC$C_FIXOVHDSZ);
	    END
	ELSE
	    BEGIN
	    BYTES_IN_BKS = (.IFAB[IFB$B_BKS]*512) - BKT$C_OVERHDSZ
		    - BKT$C_DATBKTOVH - BKT$C_DUPBKTOVH - IRC$C_FIXOVHSZ3
		    - IRC$C_KEYCMPOVH - IRC$C_DATCMPOVH;
	    
	    IF .BYTES_IN_BKS GTR 16300
	    THEN
	        BYTES_IN_BKS = 16300;
	    END;

	IF .IFAB[IFB$W_MRS] GTRU WORDMASK(.BYTES_IN_BKS)
	THEN
	    RETURN RMSERR(MRS);
	END;	    	    	    	    ! end of MRS check

    RETURN 1;
    END;	


ROUTINE CHECK_INPUT : RL$CHECK_INPUT =

!++
!
! CHECK_INPUT
!
!	This routine performs input checks specific to
!	index sequential file.  Amoung these are:
!	1)  index files must be created on random access devices (done in interface routine)
!	2)  record formats allowed:  VAR and FIX (UDF	 if BIO access)
!	3)  record size consistent with BKS
!	4)  legal BKS (0<=BKS<=32)
!	5)  key XAB checks
!	    a)  in ascending, contiguous order
!	    b)  check flags on primary key(CHG + NUL not allowed)
!	    c)  key size can not be zero
!	    d)  check that last key character is not larger than
!		minimum record size
!	    e)  check valid areas, fill sizes
!	    f)  BKS of IAN and LAN are equal
!	    g)  data type is within range
!	    h)  correct XAB length and readable
!	    i)  If keyname buffer is supplied, check that it is readable.
!	6)  area XAB checks
!	    a)  in ascending, contiguous order
!	    b)  correct XAB length and readable
!	    c)  legal BKS (default to # of blocks nec to hold 1 rec MRS long)
!	7)  must be primary key if not BIO
!
! CALLING SEQUENCE:
!	CHECK_INPUT
!
! INPUT PARAMETERS:
!	FAB 	- address of user's file access block
!	IFAB	- address of internal RMS file access block
!
! IMPLICIT INPUTS:
!	IFAB[IFB$B_MODE]
!
! OUTPUT PARAMETERS:
!	PLG_VER - prologue version number
!
! IMPLICIT OUTPUTS:
!	IFAB[IFB$W_KBUFSZ]
!	IFAB[IFB$B_BKS]
!	IFAB[IFB$W_DEQ]
!	IFAB[IFB$W_RTDEQ]
!	IFAB[IFB$B_NUM_KEYS]
!	IFAB[IFB$B_AMAX]
!	IFAB[IFB$B_AVBN] - # of prologue VBN
!	FAB[FAB$L_ALQ] - if area XAB
!	FAB[FAB$W_DEQ] - if area XAB
!	FAB[FAB$B_BKS] - if area XAB or defaulted to # of buckets nec to hold 1 rec MRS long if zero
!
! ROUTINE VALUE:
!	RFM,BKS,IMS,REF,ORD,FLG,DTP,SIZ,POS,NPK,XAB,IAN,LAN,DAN,IFL,DFL
!	SEG,KNM,AID,IBK,KSI and SUC
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    LABEL
	CHECK_XAB;

    EXTERNAL REGISTER
	PLG_VER = 7,
	R_IFAB_STR,
	R_FAB_STR,
	XAB = 6	: REF BBLOCK;

    ! Check valid RFM for index seq files.  If undefinded record format,
    ! the BIO access bit must be on.
    !

    IF .IFAB[IFB$B_RFMORG] GTRU FAB$C_VAR
    THEN
	RETURN RMSERR(RFM);

    IF  .IFAB[IFB$B_RFMORG] EQL FAB$C_UDF
	AND
	NOT .FAB[FAB$V_BIO]
    THEN
	RETURN RMSERR(RFM);

    ! Validate 0<=BKS<=32
    !

    IF .FAB[FAB$B_BKS] GTRU 32
    THEN
	RETURN RMSERR(BKS);

    IFAB[IFB$B_BKS] = .FAB[FAB$B_BKS];

    ! Now do checks on KEY and AREA XAB's . These types must be contiguous and
    ! in ascending order.
    !
    BEGIN

    LOCAL
	AREAS,					! # of area XAB's
	KEYS;					! # of key XAB's

    ! Probe the KEY and ALL XABs before we start.
    !

    RETURN_ON_ERROR (REPROBE());

    KEYS = AREAS = 0;				! initialize them
    XAB = .FAB[FAB$L_XAB];			! get start of chain

    WHILE .XAB NEQ 0
    DO
CHECK_XAB :
	BEGIN

	IF .XAB[XAB$B_COD] EQL XAB$C_KEY
	THEN
	    BEGIN

	    IF .KEYS NEQ 0
	    THEN
		BEGIN
		FAB[FAB$L_STV] = .XAB;
		RETURN RMSERR(IMX);	! check for non-contiguous key XAB
		END;

	    WHILE .XAB[XAB$B_COD] EQL XAB$C_KEY
	    DO
		BEGIN			! process all key XAB's at once
		FAB[FAB$L_STV] = .XAB;

		IF .XAB[XAB$B_BLN] NEQ XAB$C_KEYLEN
		  AND .XAB[XAB$B_BLN] NEQ XAB$C_KEYLEN_V2
		THEN
		    RETURN RMSERR(XAB);

		IF .XAB[XAB$B_REF] EQL 255
		THEN
		    RETURN RMSERR(REF);

		IF .XAB[XAB$B_REF] NEQ .KEYS<0, 8>
		THEN
		    RETURN RMSERR(ORD);

		IF .XAB[XAB$B_REF] EQL 0
		THEN
		    BEGIN

		    LOCAL
			STATUS;

		    IF .XAB[XAB$V_CHG]  OR  .XAB[XAB$V_NUL]
		    THEN
			RETURN RMSERR(FLG);

		    IF NOT (STATUS = FIND_PLG_VER())
		    THEN
			RETURN .STATUS;

		    END;

		IF .XAB[XAB$B_DTP] GTRU KEY$C_MAX_DATA
		THEN
		    RETURN RMSERR(DTP);		! check legal data type

		! If not doing prolog 3, decide if prolog 2 is required.
		!
		
		IF .XAB[XAB$B_DTP] NEQ XAB$C_STG  AND
		   .PLG_VER EQL PLG$C_VER_NO
		THEN
		    PLG_VER = PLG$C_VER_IDX;

		BEGIN

		GLOBAL REGISTER
		    KEYSIZE = 1,
		    MINREC = 2,
		    SEGS = 3;

		RETURN_ON_ERROR ( GET_KEY_PARMS(.PLG_VER) );

		IF .KEYSIZE EQL 0
		  OR .KEYSIZE GTRU 255
		THEN
		    RETURN RMSERR(SIZ);

		IF .KEYSIZE<0, 8> GTRU .IFAB[IFB$W_KBUFSZ]
		THEN
		    IFAB[IFB$W_KBUFSZ] = .KEYSIZE;

		IF .IFAB[IFB$W_MRS] NEQ 0
		  AND .MINREC<0, 16> GTRU .IFAB[IFB$W_MRS]
		THEN
		    RETURN RMSERR(POS);

		END;			! end of def of KEYSIZE, MINREC, SEGS

		IF .XAB[XAB$B_REF] EQL 0
		THEN
		    RETURN_ON_ERROR ( CHECK_MRS(.PLG_VER) );

		FAB[FAB$L_STV] = 0;
		KEYS = .KEYS + 1;
		XAB = .XAB[XAB$L_NXT];

		IF .XAB EQL 0
		THEN
		    LEAVE CHECK_XAB;

		END;			! of WHILE key XAB

	    END				! of key XAB processing
	ELSE

	    IF .XAB[XAB$B_COD] EQL XAB$C_ALL
	    THEN
		BEGIN

		IF .AREAS NEQ 0
		THEN
		    ! check for non_contiguous areas
		    !
		    BEGIN
		    FAB[FAB$L_STV] = .XAB;
		    RETURN RMSERR(IMX);
		    END;

		WHILE .XAB[XAB$B_COD] EQL XAB$C_ALL
		DO
		    BEGIN
		    FAB[FAB$L_STV] = .XAB;

		    IF .XAB[XAB$B_BLN] NEQ XAB$C_ALLLEN
		    THEN
			RETURN RMSERR(XAB);

		    IF .XAB[XAB$B_AID] EQL 255
		    THEN
			RETURN RMSERR(AID);

		    IF .XAB[XAB$B_AID] NEQ .AREAS<0, 8>
		    THEN
			RETURN RMSERR(ORD);

		    IF .XAB[XAB$B_BKZ] GTRU 32
		    THEN
			RETURN RMSERR(BKZ);

		    IF .XAB[XAB$B_BKZ] EQL 0
		    THEN
			XAB[XAB$B_BKZ] = 1;

		    IF .XAB[XAB$B_AID] EQL 0
		    THEN
 			! first area XAB overrides FAB values
			!
			BEGIN
			FAB[FAB$L_ALQ] = .XAB[XAB$L_ALQ];
			FAB[FAB$W_DEQ] = .XAB[XAB$W_DEQ];
			FAB[FAB$B_BKS] = .XAB[XAB$B_BKZ];
			END;

		    IF .XAB[XAB$B_BKZ] GTRU .IFAB[IFB$B_BKS]
		    THEN
			IFAB[IFB$B_BKS] = .XAB[XAB$B_BKZ];

		    FAB[FAB$L_STV] = 0;
		    AREAS = .AREAS + 1;
		    XAB = .XAB[XAB$L_NXT];

		    IF .XAB EQL 0
		    THEN
			LEAVE CHECK_XAB;

		    END;		! of WHILE area XAB

		END			! of area XAB processing
	    ELSE
		XAB = .XAB[XAB$L_NXT];

	END;			! end of WHILE key and area XAB check loop

    IFAB[IFB$B_NUM_KEYS] = .KEYS;		! indicate end of key chain

    ! Default to one area
    !

    IF .AREAS EQL 0
    THEN
	AREAS = 1;

    IFAB[IFB$B_AMAX] = .AREAS;

    ! Determine minimum number of VBN's to allocate for prologue and force it
    !
    BEGIN

    LOCAL
	MIN_ALLOC;

    MIN_ALLOC = ((.AREAS + 7)/8) + 1 + ((.KEYS + 3)/5);

    ! Save this value in area vbn because it is the number of VBN's used by the
    ! prologue
    !
    IFAB[IFB$B_AVBN] = .MIN_ALLOC;

    IF .MIN_ALLOC GTRU .FAB[FAB$L_ALQ]
    THEN
	FAB[FAB$L_ALQ] = .MIN_ALLOC;
    END;		! end local definition of MIN_ALLOC

    END;		! end local definition of AREAS, KEYS


    ! now that FAB[DEQ] has been defaulted from first area XAB if one, default
    ! IFAB[DEQ] and IFAB[RTDEQ]
    !
    IFAB[IFB$W_DEQ] = .FAB[FAB$W_DEQ];
    IFAB[IFB$W_RTDEQ] = .FAB[FAB$W_DEQ];

    ! Now validate the areas referred to in each key XAB and the fill per
    ! centages. If not block I/O there must be a primary key.
    !

    IF  NOT (.FAB[FAB$V_BIO]  AND  NOT .FAB[FAB$V_BRO])
    THEN
	BEGIN

	IF .IFAB[IFB$B_NUM_KEYS] EQL 0
	THEN
	    RETURN RMSERR(NPK);

	XAB = .FAB[FAB$L_XAB];

	UNTIL .XAB[XAB$B_COD] EQL XAB$C_KEY
	DO
	    XAB = .XAB[XAB$L_NXT];

	DO
	    BEGIN

	    LOCAL
		DAN,
		IAN,
		LAN;

	    FAB[FAB$L_STV] = .XAB;

	    IF .XAB[XAB$B_IAN] GEQU .IFAB[IFB$B_AMAX]
	    THEN
		RETURN RMSERR(IAN);

	    IF .XAB[XAB$B_LAN] GEQU .IFAB[IFB$B_AMAX]
	    THEN
		RETURN RMSERR(LAN);

	    IF .XAB[XAB$B_DAN] GEQU .IFAB[IFB$B_AMAX]
	    THEN
		RETURN RMSERR(DAN);

	    IAN = GET_BKS(.XAB[XAB$B_IAN]);
	    DAN = GET_BKS(.XAB[XAB$B_DAN]);
	    LAN = GET_BKS(.XAB[XAB$B_LAN]);

	    ! NOTE:  LAN can never be area 0 If LAN is zero, LAN is defaulted
	    ! to IAN
	    !

	    IF .XAB[XAB$B_LAN] EQL 0
	    THEN
		BEGIN
		LAN = .IAN;
		XAB[XAB$B_LAN] = .XAB[XAB$B_IAN];
		END;

	    ! Now check BKS of LAN equal to BKS of IAN
	    !

	    IF .IAN NEQ .LAN
	    THEN
		RETURN RMSERR(IBK);

	    ! Check that at least 2 key's fit at index level.
	    !
	    BEGIN

	    GLOBAL REGISTER
		KEYSIZE = 1,
		MINREC = 2,
		SEGS = 3;

	    BIND
		BYTES = MINREC;

	    RETURN_ON_ERROR (GET_KEY_PARMS(.PLG_VER));
	    BYTES = (.IAN*512) - BKT$C_OVERHDSZ - 1;

	    IF 2*(.KEYSIZE + 2 + IRC$C_IDXPTRBAS + IRC$C_IDXOVHDSZ) GTRU .BYTES
	    THEN
		BEGIN
		FAB[FAB$L_STV] = .XAB[XAB$B_REF];
		RETURN RMSERR(KSI);
		END;
	    END;
	
	    ! Now check valid fill percentages
	    !

	    IF .XAB[XAB$W_IFL] GTRU WORDMASK(.IAN*512)
	    THEN
		RETURN RMSERR(IFL);

	    IF .XAB[XAB$W_DFL] GTRU WORDMASK(.DAN*512)
	    THEN
		RETURN RMSERR(DFL);

	    FAB[FAB$L_STV] = 0;
	    XAB = .XAB[XAB$L_NXT];
	    END

	UNTIL .XAB EQL 0  OR  .XAB[XAB$B_COD] NEQ XAB$C_KEY;

	END;

    RETURN 1;

    END;

ROUTINE FILL (BKT_ADDR) : RL$FILL NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine fills the buffer with zeros.  It is a separate routine
!	so as not to clobber R4 and R5.
!
!
! CALLING SEQUENCE:
!	FILL()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	BKT_ADDR - address of buffer to initialize
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN
    CH$FILL(0, 512, .BKT_ADDR);
    END;

ROUTINE MOVE : RL$MOVE NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine moves key position/length information from XAB's to key descriptors on disk.
!	If alsom moves the key name if non_zero.
!	It is done as a routine so as not to clobber R4 - R5.
!
! CALLING SEQUENCE:
!	MOVE()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	BUF	- address of key descriptor buffer
!	XAB	- address of XAB containing data to be moved
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	data moved to BUF, an image of the disk key descriptor
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	BUF = 7	: REF BBLOCK,
	XAB = 6	: REF BBLOCK;

    ASSUME( %QUOTE KEY$W_POSITION,  %QUOTE KEY$W_POSITION1);
    ASSUME( %QUOTE KEY$W_POSITION1, %QUOTE KEY$W_POSITION2);
    ASSUME( %QUOTE KEY$W_POSITION2, %QUOTE KEY$W_POSITION3);
    ASSUME( %QUOTE KEY$W_POSITION3, %QUOTE KEY$W_POSITION4);
    ASSUME( %QUOTE KEY$W_POSITION4, %QUOTE KEY$W_POSITION5);
    ASSUME( %QUOTE KEY$W_POSITION5, %QUOTE KEY$W_POSITION6);
    ASSUME( %QUOTE KEY$W_POSITION6, %QUOTE KEY$W_POSITION7);
    ASSUME( %QUOTE KEY$W_POSITION7, %QUOTE KEY$B_SIZE);
    ASSUME( %QUOTE KEY$B_SIZE,  %QUOTE KEY$B_SIZE1);
    ASSUME( %QUOTE KEY$B_SIZE1, %QUOTE KEY$B_SIZE2);
    ASSUME( %QUOTE KEY$B_SIZE2, %QUOTE KEY$B_SIZE3);
    ASSUME( %QUOTE KEY$B_SIZE3, %QUOTE KEY$B_SIZE4);
    ASSUME( %QUOTE KEY$B_SIZE4, %QUOTE KEY$B_SIZE5);
    ASSUME( %QUOTE KEY$B_SIZE5, %QUOTE KEY$B_SIZE6);
    ASSUME( %QUOTE KEY$B_SIZE6, %QUOTE KEY$B_SIZE7);
    ASSUME( %QUOTE KEY$B_SIZE7, %QUOTE KEY$T_KEYNAM);

%IF $BYTEOFFSET(KEY$T_KEYNAM) + KEY$S_KEYNAM NEQ $BYTEOFFSET(KEY$L_LDVBN)
%THEN
    %WARN('WARNING CONSTANT HAS CHANGES')
%FI;

    CH$MOVE(($BYTEOFFSET(KEY$T_KEYNAM) - $BYTEOFFSET(KEY$W_POSITION)),
	XAB[XAB$W_POS], BUF[KEY$W_POSITION]);

    ! Assume probe done already on key name buffer.  Therefore just pick up and
    ! move.
    !

    IF .XAB[XAB$L_KNM] NEQ 0
    THEN
	CH$MOVE(KEY$S_KEYNAM, .XAB[XAB$L_KNM], BUF[KEY$T_KEYNAM]);

    ! Set data types values.  Propagate XAB$B_DTP to TYP0, and
    ! TYP1-TYP7 to null (STG).
    !
    BUF[KEY$B_TYPE] = .XAB[XAB$B_DTP];
    CH$FILL( 0, 7, BUF[KEY$B_TYPE1] );

    END;					! end of routine MOVE

ROUTINE AL_KEY_DESC (BUF) : RL$AL_KEY =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates a key descriptor.  This is in a separate module
!	so as not to clobber R7.
!
!
! CALLING SEQUENCE:
!	AL_KEY_DESC()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FAB_STR;

    GLOBAL REGISTER
	R_IDX_DFN_STR;

    RETURN_ON_ERROR (RM$AL_KEY_DESC(.BUF));

    RETURN 1;

    END;

ROUTINE WRITE_PROLOGUE : RL$WRITE_PROLOG =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine recalculates the check sum, sets the buffer dirty, and
!	writes it out.
!
!
! CALLING SEQUENCE:
!	WRITE_PROLOGUE()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	BDB	- address of BDB describing buffer containing prologue VBN
!	BKT_ADDR- address of buffer
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	ERROR - WPL
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FABREG,
	R_BDB_STR;

    RM$MAKSUM(.BDB[BDB$L_ADDR]);
    BDB[BDB$V_VAL] = 1;
    BDB[BDB$V_DRT] = 1;
    BEGIN

    LOCAL
	FLAGS;

    FLAGS = RLS$M_WRT_THRU;

    IF .BDB[BDB$L_VBN] EQL 1
    THEN
	FLAGS = .FLAGS	OR  RLS$M_KEEP_LOCK;

    RETURN_ON_ERROR (RM$RELEASE(.FLAGS),
	BEGIN
	STATUS = RMSERR(WPL)
	END);
    END;

    RETURN 1;

    END;

ROUTINE REPROBE : RL$REPROBE =

!++
!
! REPROBE
!	This routine reprobes all XAB's for read.
!
! CALLING SEQUENCE:
!	REPROBE()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	FAB		- address of user FAB (and XAB chain)
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_FAB_STR;

    LOCAL
	XAB	: REF BBLOCK;

    ! Go through XAB chain doing short probes.  This removes the short probes
    ! from the various loops but pays an overhead of reprobing all XAB's
    ! whether or not it would be necessary.
    !
    XAB = .FAB[FAB$L_XAB];

    UNTIL .XAB EQL 0
    DO
	BEGIN
	IFNORD(%REF($BYTEOFFSET(XAB$L_NXT) + $FIELDWIDTH(XAB$L_NXT)/8), .XAB,
	    IFAB[IFB$B_MODE],
	    (FAB[FAB$L_STV] = .XAB;
	    RETURN RMSERR(XAB)));

	IF .XAB[XAB$B_COD] EQL XAB$C_ALL
	THEN
	    IFNOWRT(%REF(XAB$C_ALLLEN), .XAB, IFAB[IFB$B_MODE],
		(FAB[FAB$L_STV] = .XAB;
		RETURN RMSERR(XAB)));

	IF .XAB[XAB$B_COD] EQL XAB$C_KEY
	THEN

	    BEGIN

	    IF .XAB [XAB$B_BLN] EQL XAB$C_KEYLEN
	    THEN
	        IFNOWRT(%REF(XAB$C_KEYLEN), .XAB, IFAB[IFB$B_MODE],
		    (FAB[FAB$L_STV] = .XAB;
		    RETURN RMSERR(XAB)))
	    ELSE
		IFNOWRT(%REF(XAB$C_KEYLEN_V2), .XAB, IFAB[IFB$B_MODE],
		    (FAB[FAB$L_STV] = .XAB;
		    RETURN RMSERR(XAB)));

	    IF .XAB[XAB$L_KNM] NEQ 0
	    THEN
		IFNORD(%REF(KEY$S_KEYNAM), .XAB[XAB$L_KNM], IFAB[IFB$B_MODE],
		    RETURN RMSERR(KNM));

	    END;

	XAB = .XAB[XAB$L_NXT];
	END;

    RETURN 1;

    END;

ROUTINE READ_PROLOGUE (VBN) : RL$READ_PROLOG =

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine locks the VBN  and zero fills the buffer allocated for it.
!	It then reprobes the XAB's which may have gone away.
!
! CALLING SEQUENCE:
!	RM$READ_PROLOGUE(VBN)
!
! INPUT PARAMETERS:
!	VBN	- VBN to lock
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FABREG,
	R_BDB_STR;

    GLOBAL REGISTER
	R_BKT_ADDR;

    RETURN_ON_ERROR (RM$CACHE(.VBN, 512, CSH$M_NOREAD  OR  CSH$M_LOCK),
	BEGIN
	STATUS = RMSERR(RPL)
	END);

    FILL(.BKT_ADDR);

    RETURN_ON_ERROR (REPROBE(),
	BEGIN

	IF .BDB[BDB$L_VBN] NEQ 1
	THEN
	    RM$RELEASE(0)
	END);

    RETURN 1;

    END;


GLOBAL ROUTINE RM$CREATE3B : RL$CREATE3B =

!++
!
! RM$CREATE3B
!
!	This routine checks the input, creates the file, allocates key descriptor and writes
!	the prologue.
!
! CALLING SEQUENCE:
!	RM$CREATE3()
!
! INPUT PARAMETERS:
!	FAB 	- address of user's file access block
!	IFAB_FILE - address of internal RMS file access block
!
! IMPLICIT INPUTS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	RFM,BKS,IMS,REF,ORD,FLG,DTP,KSZ,POS,NPK,XAB,IAN,LAN,DAN,IFL,DFL
!	and SUC
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    LOCAL
	PROLOGUE,
	CRE_STATUS;

    EXTERNAL REGISTER
	COMMON_FAB_STR;

    GLOBAL REGISTER
	BUF = 7	: REF BBLOCK,
	XAB = 6	: REF BBLOCK;

    ! set up ifab in r10, but have to save the fwa address for createcom
    !
    BEGIN

    LOCAL
	FWA;

    FWA = .IFAB;
    IFAB = .IFAB_FILE;

    ! check input
    !

    BEGIN

    GLOBAL REGISTER
	PLG_VER = 7;

    RETURN_ON_ERROR (CHECK_INPUT());
    PROLOGUE = .PLG_VER;
    IFAB [IFB$B_PLG_VER] = .PLG_VER;

    END;

    ! actually create the file on the disk
    !
    IFAB = .FWA;			! restore fwa adddress for call
    CRE_STATUS = RM$CREATECOM();

    IF  NOT .CRE_STATUS
	OR
	    (.FAB[FAB$V_CIF]
	    AND
	    .CRE_STATUS EQL RMSSUC())
    THEN
	RETURN .CRE_STATUS;

    RM$UPD_SIFB_EOF();
    END;					! {end of block defining fwa }

    ! from now on need IFAB IN R10
    !
    IFAB = .IFAB_FILE;

    ! Zero NRP list pointer since the creator is the first user
    !
    IFAB[IFB$L_NRP_LIST] = 0;

    ! write out prologue unless BIO access
    !

    IF NOT .FAB[FAB$V_BIO]
    THEN
	BEGIN

	GLOBAL REGISTER
	    R_BDB_STR;

	! One BLB is allocated as part of a shared open for use with
	! the BDB used in filename parsing (FWA), if necessary.  If
	! locking is required, a lock BLB must be allocated now.
	!

	IF NOT .IFAB[IFB$V_NORECLK]
	THEN
	    IF NOT RM$ALBLB()
	    THEN RM$BUG3();

	RETURN_ON_ERROR (REPROBE());		! I/O done so need to reprobe

	! Locate first key XAB.
	!
	XAB = .FAB[FAB$L_XAB];

	UNTIL .XAB[XAB$B_COD] EQL XAB$C_KEY
	DO	
	    XAB = .XAB[XAB$L_NXT];

	BEGIN

	LOCAL
	    CMPR_FLG,				! to be set if index or key compr
	    BDB_VBN1,
	    DISP,
	    VBN;

	CMPR_FLG = 0;				! assume not compression
	VBN = 1;
	DISP = 0;
	BDB_VBN1 = 0;

	! write out key prologue VBN's
	!

	DO
	    BEGIN

	    IF .DISP EQL 5*(KEY$C_BLN + KEY$C_SPARE)
	    THEN
		BEGIN
		DISP = 0;
		VBN = .VBN + 1;
		BUF[KEY$L_IDXFL] = .VBN;
		BUF[KEY$W_NOFF] = 0;

		RETURN_ON_ERROR (WRITE_PROLOGUE(),
		    BEGIN
		    BDB = .BDB_VBN1;

		    IF .BDB NEQ 0
		    THEN
			RM$RELEASE(0)

		    END);

		END;

	    IF .DISP EQL 0
	    THEN
		BEGIN

		RETURN_ON_ERROR (READ_PROLOGUE(.VBN),
		    BEGIN
		    BDB = .BDB_VBN1;

		    IF .BDB NEQ 0
		    THEN
			RM$RELEASE(0)

		    END);

		IF .VBN EQL 1
		THEN
		    BDB_VBN1 = .BDB;

		END
	    ELSE
		BEGIN
		BUF[KEY$L_IDXFL] = .VBN;
		BUF[KEY$W_NOFF] = .DISP;
		END;

	    BUF = .BDB[BDB$L_ADDR] + .DISP;

	    ! Now fill in key descriptor in prologue VBN and allocate in_core
	    ! key descriptor.
	    !
	    BUF[KEY$B_IANUM] = .XAB[XAB$B_IAN];
	    BUF[KEY$B_LANUM] = .XAB[XAB$B_LAN];
	    BUF[KEY$B_DANUM] = .XAB[XAB$B_DAN];

	    ! This is a crock of .... to conform with RMS_11 clug.
	    !
	    (BUF[KEY$L_ROOTVBN])<0, 8> = .XAB[XAB$B_DAN];
	    (BUF[KEY$L_ROOTVBN])<8, 8> = .XAB[XAB$B_IAN];
	    (BUF[KEY$L_ROOTVBN])<16, 8> = .XAB[XAB$B_LAN];
	    BUF[KEY$B_IDXBKTSZ] = GET_BKS(.XAB[XAB$B_IAN]);
	    BUF[KEY$B_DATBKTSZ] = GET_BKS(.XAB[XAB$B_DAN]);

	    BUF[KEY$B_DATATYPE] = .XAB[XAB$B_DTP];

	    BEGIN

	    GLOBAL REGISTER
		KEYSIZE = 1,
		MINREC = 2,
		SEGS = 3;

	    RETURN_ON_ERROR (GET_KEY_PARMS(.PROLOGUE));
	    BUF[KEY$B_SEGMENTS] = .SEGS;
	    BUF[KEY$B_NULLCHAR] = .XAB[XAB$B_NUL];
	    BUF[KEY$B_KEYSZ] = .KEYSIZE;
	    BUF[KEY$B_KEYREF] = .XAB[XAB$B_REF];
	    BUF[KEY$W_MINRECSZ] = .MINREC;

	    ! Now we must make intelligent decisions about the compression
	    ! bits for the keys.  If it is not a plg 3 file, then we want
	    ! to turn off all compression, since default is zero.
	    !

	    IF .PROLOGUE LSSU 3
	    THEN
		BEGIN
		XAB[XAB$V_IDX_NCMPR] = 1;

		IF .XAB[XAB$B_REF] EQL 0
		THEN
		    BEGIN
		    XAB[XAB$V_KEY_NCMPR] = 1;
		    XAB[XAB$V_DAT_NCMPR] = 1;
		    END;
		END

	    ! In a prologue 3 file, we decide if the compression should
	    ! be turned off depending on the key size.  If the key is less
	    ! than 6 bytes, do not allow compression.  If the data record
	    ! left after the primary key is extracted is less than 11 bytes,
	    ! do not allow data compression.
	    !
	    ELSE
	        BEGIN

		IF .KEYSIZE LSS 6
		THEN
		    XAB[XAB$V_IDX_NCMPR] = 1;


		IF .XAB[XAB$B_REF] EQL 0
		THEN
		    BEGIN

		    IF .KEYSIZE LSS 6
		    THEN
		        XAB[XAB$V_KEY_NCMPR] = 1;

		    IF .IFAB[IFB$W_MRS] NEQ 0
		      AND (.IFAB[IFB$W_MRS] - .KEYSIZE<0,16>) LSS 11
		    THEN
		        XAB[XAB$V_DAT_NCMPR] = 1;
		    END;
		END;

	    IF NOT .XAB[XAB$V_IDX_NCMPR] OR NOT .XAB[XAB$V_KEY_NCMPR]
	    THEN
		CMPR_FLG = 1;

	    ! Store flags and invert value of compression flags...
	    !
	    BUF[KEY$B_FLAGS] = .XAB[XAB$B_FLAGS]  OR  KEY$M_INITIDX;
	    BUF[KEY$V_IDX_COMPR] = NOT .XAB[XAB$V_IDX_NCMPR];

	    IF .XAB[XAB$B_REF] EQLU 0
	    THEN
		BEGIN
		BUF[KEY$V_KEY_COMPR] = NOT .XAB[XAB$V_KEY_NCMPR];
		BUF[KEY$V_REC_COMPR] = NOT .XAB[XAB$V_DAT_NCMPR];
		END;

	    END;			! end of KEYSIZE,MINREC,SEGS def

	    BUF[KEY$W_IDXFILL] = .XAB[XAB$W_IFL];

	    IF .BUF[KEY$W_IDXFILL] EQL 0
	    THEN
		BUF[KEY$W_IDXFILL] = .BUF[KEY$B_IDXBKTSZ]*512;

	    IF .BUF[KEY$W_IDXFILL] LSSU WORDMASK(.BUF[KEY$B_IDXBKTSZ]*(512/2))
	    THEN
		BUF[KEY$W_IDXFILL] = .BUF[KEY$B_IDXBKTSZ]*(512/2);

	    BUF[KEY$W_DATFILL] = .XAB[XAB$W_DFL];

	    IF .BUF[KEY$W_DATFILL] EQL 0
	    THEN
		BUF[KEY$W_DATFILL] = .BUF[KEY$B_DATBKTSZ]*512;

	    IF .BUF[KEY$W_DATFILL] LSSU WORDMASK(.BUF[KEY$B_DATBKTSZ]*(512/2))
	    THEN
		BUF[KEY$W_DATFILL] = .BUF[KEY$B_DATBKTSZ]*(512/2);

	    MOVE();

	    RETURN_ON_ERROR (AL_KEY_DESC(.BUF),
		BEGIN
		IF .BDB EQL .BDB_VBN1
		THEN
		    BDB_VBN1 = 0;
		RM$RELEASE(0);
		BDB = .BDB_VBN1;

		IF .BDB NEQ 0
		THEN
		    RM$RELEASE(0)

		END);				! allocate in_core descriptor

	    ! prepare for next key descriptor by bumping the index and
	    ! getting the next XAB
	    !

	    IF .XAB[XAB$B_REF] EQL 0
	    THEN
		DISP = 5*(KEY$C_BLN + KEY$C_SPARE)
	    ELSE
		DISP = .DISP + (KEY$C_BLN + KEY$C_SPARE);

	    XAB = .XAB[XAB$L_NXT];

	    IF .XAB EQL 0
	    THEN
		EXITLOOP;

	    END

	UNTIL .XAB[XAB$B_COD] NEQ XAB$C_KEY;

	! Write out last key VBN
	!
	BUF[KEY$L_IDXFL] = 0;
	BUF[KEY$W_NOFF] = 0;
	DISP = 0;
	VBN = .VBN + 1;

	RETURN_ON_ERROR (WRITE_PROLOGUE(),
	    BEGIN
	    BDB = .BDB_VBN1;

	    IF .BDB NEQ 0
	    THEN
		RM$RELEASE(0)

	    END);

	! If the index of any of the keys, or the primary key is compressed,
	! then add two bytes for compression overhead to the key buffer.
	!

	IF .CMPR_FLG
	THEN
	    IFAB[IFB$W_KBUFSZ] = .IFAB[IFB$W_KBUFSZ] + 2;

	! now locate first area XAB if one
	!
	XAB = .FAB[FAB$L_XAB];

	DO
	    BEGIN

	    IF .XAB[XAB$B_COD] EQL XAB$C_ALL
	    THEN
		EXITLOOP;

	    XAB = .XAB[XAB$L_NXT];
	    END
	UNTIL .XAB EQL 0;

	DO
	    BEGIN

	    IF .DISP EQL 512
	    THEN
		BEGIN
		DISP = 0;
		VBN = .VBN + 1;

		RETURN_ON_ERROR (WRITE_PROLOGUE(),
		    BEGIN
		    BDB = .BDB_VBN1;

		    IF .BDB NEQ 0
		    THEN
			RM$RELEASE(0)

		    END);

		END;

	    IF .DISP EQL 0
	    THEN

		RETURN_ON_ERROR (READ_PROLOGUE(.VBN),
		    BEGIN
		    BDB = .BDB_VBN1;

		    IF .BDB NEQ 0
		    THEN
			RM$RELEASE(0)

		    END);

	    BUF = .BDB[BDB$L_ADDR] + .DISP;

	    IF .XAB EQL 0
	    THEN
		BEGIN
		BUF[AREA$L_CVBN] = 1;
		BUF[AREA$B_ARBKTSZ] = .IFAB[IFB$B_BKS];
		BUF[AREA$L_NXTVBN] = .VBN + 1;
		BUF[AREA$L_CNBLK] = .IFAB[IFB$L_HBK];
		BUF[AREA$L_USED] = .VBN;
		BUF[AREA$W_DEQ] = .IFAB[IFB$W_DEQ];
		BUF[AREA$B_ARBKTSZ] = .IFAB[IFB$B_BKS];
		IFAB[IFB$B_AVBN] = .VBN;
		EXITLOOP;

		END
	    ELSE
		BEGIN
		BUF[AREA$B_AREAID] = .XAB[XAB$B_AID];
		BUF[AREA$W_VOLUME] = .XAB[XAB$W_VOL];
		BUF[AREA$B_ALN] = .XAB[XAB$B_ALN];
		BUF[AREA$B_AOP] = .XAB[XAB$B_AOP];
		BUF[AREA$W_DEQ] = .XAB[XAB$W_DEQ];
		BUF[AREA$B_ARBKTSZ] = .XAB[XAB$B_BKZ];

		! Copy RFI field from XAB to BUF
		!
		BEGIN

		LOCAL
		    RFI	: REF VECTOR [, WORD];

		RFI = BUF[AREA$W_RFI];
		RFI[0] = .XAB[XAB$W_RFI0];
		RFI[1] = .XAB[XAB$W_RFI2];
		RFI[2] = .XAB[XAB$W_RFI4];
		END;

		IF .XAB[XAB$B_AID] NEQ 0
		THEN
		    BEGIN

		    IF .XAB[XAB$L_ALQ] NEQ 0
		    THEN

			RETURN_ON_ERROR (EXTEND(.BUF),
			    BEGIN
			    IF .BDB EQL .BDB_VBN1
			    THEN
				BDB_VBN1 = 0;
			    RM$RELEASE(0);
			    BDB = .BDB_VBN1;

			    IF .BDB NEQ 0
			    THEN
				RM$RELEASE(0)

			    END)
		    END

		ELSE
		    BEGIN
		    BUF[AREA$L_USED] = .IFAB[IFB$B_AVBN];
		    BUF[AREA$L_NXTVBN] = .IFAB[IFB$B_AVBN] + 1;
		    IFAB[IFB$B_AVBN] = .VBN;
		    BUF[AREA$L_CVBN] = 1;
		    BUF[AREA$L_CNBLK] = .IFAB[IFB$L_HBK];
		    XAB[XAB$L_ALQ] = .FAB[FAB$L_ALQ];
		    END;

		END;

	    DISP = .DISP + AREA$C_BLN;
	    XAB = .XAB[XAB$L_NXT];

	    IF .XAB EQL 0
	    THEN
		EXITLOOP;

	    END
	UNTIL .XAB[XAB$B_COD] NEQ XAB$C_ALL;

	RETURN_ON_ERROR (WRITE_PROLOGUE(),
	    BEGIN
	    BDB = .BDB_VBN1;

	    IF .BDB NEQ 0
	    THEN
		RM$RELEASE(0)

	    END);
	END;				! { end of def of VBN, DISP}

	! now reread VBN 1 and fill in summary area information and prologue
	! version #
	!
	BEGIN

	GLOBAL REGISTER
	    R_BKT_ADDR_STR;

	RETURN_ON_ERROR (RM$CACHE(1, 512, CSH$M_LOCK),
	    BEGIN
	    STATUS = RMSERR(RPL)
	    END);

	BKT_ADDR[PLG$B_AVBN] = .IFAB[IFB$B_AVBN];
	BKT_ADDR[PLG$B_AMAX] = .IFAB[IFB$B_AMAX];
	BKT_ADDR[PLG$W_VER_NO] = .PROLOGUE;
	RM$MAKSUM(.BKT_ADDR);
	END;

	BDB[BDB$V_VAL] = 1;
	BDB[BDB$V_DRT] = 1;

	RETURN_ON_ERROR (RM$RELEASE(RLS$M_WRT_THRU),
	    BEGIN
	    STATUS = RMSERR(WPL)
	    END);

	END;

    RETURN .CRE_STATUS;

    END;

END

ELUDOM
