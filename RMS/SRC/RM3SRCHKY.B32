
MODULE RM3SRCHKY (LANGUAGE (BLISS32) ,
		IDENT = 'V03-003'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                This module starts at current bucket and searchs to stop level
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        D. H. Gillespie     CREATION DATE:        	18-APR-78  9:39
!
! MODIFIED BY:
!
!	V03-003	MCN0002		Maria del C. Nasr	25-Mar-1982
!		Use macro to calculate key buffer address.
!
!	V03-002	CDS0008		C Saether		23-Mar-1982
!		Restore BKT_ADDR when BDB is restored when leaving
!		block that confirms down pointer from level 1.
!		This was causing the check for level 0 to fail and
!		not lock the next bucket when positioning horizontally
!		at level 0.
!
!	V03-001	CDS0007		C Saether		 3-Mar-1982
!		Fix bug where horizontal reads at the stoplevel were
!		not locking the bucket on positions for insert or
!		delete.  This was working correctly for position for
!		insert at level 0 only (which is the normal place
!		where horizontal reads would take place).
!		The changes in RM$CACHE and RM$RELEASE have made them
!		sensitive to this error.
!
!	V02-039	CDS0006		C Saether		20-Jan-1982
!		Set VBN_LEFT for scan forward when not locking.
!		Clear IRB$L_REC_COUNT before calling RM$SRCH_BY_KEY
!		in the horizontal scan logic.
!		Once data level horizontal scan has started, do not
!		drop back into outer loop anymore.
!
!	V02-038	CDS0005		C Saether		14-Jan-1982
!		Put back logic to check index down pointer after
!		positioning to level on insert.  It's really necessary.
!
!	V02-037	CDS0004		C Saether		31-Dec-1981
!		Fix error path botched in V02-036.
!		Put back retry on rlk error going down tree inadvertently
!		removed by V02-036.
!
!	V02-036	CDS0003		C Saether		29-Dec-1981
!		Remove logic to check down pointer before going
!		across on position for insert.
!		Modify horizontal scan at data level on position for
!		insert to release bucket prior to going ahead.  This
!		eliminates need for special algorithms to avoid deadlock
!		with rrv updating by other streams.  Previous algorithm
!		could get into infinite loop with another process.
!
!	V02-035	PSK0009		P Knibbe		07-Oct-1981
!		Make sure all calls to RM$RECORD_VBN check for
!		prologue version.
!
!	V02-034	CDS0002		C Saether		29-Sep-1981
!		Make check for exclusive lock before setting abovelckd.
!
!	V02-033	CDS0001		C Saether		20-Aug-1981
!		Remove references to BDB$L_OWN.
!
!	V02-032	PSK0008		Paulina S. Knibbe	08-Aug-1981
!		Remove all references to SPLCTX
!
!	V02-031	PSK0007		Paulina S. Knibbe	30-Jul-1981
!		Remove support for truncated index keys.
!
!	V02-030	PSK0006		Paulina S. Knibbe	12-Jun-1981
!		1) Make RM$V3_VBN a global routine
!		2) Save LST_NCMP when bouncing back and forth between
!		   two buckets.
!		3) Add logic to support horizontal processing in V3
!		   compresses indexes.
!		4) Add RM$CHK_HORIZ
!		5) Change calls to COMP_ASCII to be CH$COMPARE
!		
!	V02-029	PSK0005		Paulina S. Knibbe	28-May-1981
!		Fix problem on GT search. Make lock-above optimization
!		work for prologue three files.
!
!	V02-028	PSK0004		Paulina S. Knibbe	03-May-1981
!		Add support for compressed keys in index, SIDR and data
!		buckets.
!
!	V02-027	PSK0003		Paulina S. Knibbe	30-Apr-1981
!		Fix problem when key goes past range in bucket
!
!	V02-026	MCN0001		Maria del C. Nasr	23-Apr-1981
!		Add support for non-compressed keys at the primary data
!		level of prologue 3 files.
!
!	V02-025	PSK0002		Paulina S. Knibbe	30-Mar-1981
!		Add support for random searching of PLG3 buckets with
!		fixed length keys.
!
!	V02-024	PSK0001		Paulina S. Knibbe	19-Mar-1981
!		Change index bucket VBN processing to handle VBN lists
!		at end of bucket
!
!	V02-023	REFORMAT	Keith B. Thompson	23-Jul-1980
!
! REVISION HISTORY:
!
!	Christian Saether, 	27-JUL-78  10:48
!	X0002 - SRCH_BY_KEY changed to store last record address for
!		ADD_TO_ARRAY
!
!	Christian Saether, 	9-AUG-78  11:55
!	X0003 - never return RNF on POSINSERT
!
!	Wendy Koenig, 	11-AUG-78  14:10
!	X0004 - only lock the root if it is the lock-above or stoplevel level
!
!	Christian Saether, 	14-AUG-78  10:21
!	X0005 - add code to disable RNF on position for insert
!
!	Christian Saether, 	24-AUG-78  9:39
!	X0006 - Add POSDELETE to SEARCH_TREE
!
!	Christian Saether, 	24-AUG-78  19:41
!	X0007 - Correct logic error horizontal positioning on insert across
!		empty buckets
!
!	Christian Saether, 	26-SEP-78  15:57
!	X0008 - never do lock_above on position for delete
!
!	D. H. Gillespie, 	6-OCT-78  17:34
!	X0009 - fix bug when positioning for insert and entire file is empty
!		from where search started and end
!
!	Christian Saether, 	9-OCT-78  12:10
!	X0010 - reverse usage of EMPT_SEEN and EMPTY_BKT so EMPTY_BKT is not
!		clobbered while searching index levels
!
!	Wendy Koenig, 	24-OCT-78  14:03
!	X0011 - make changes caused by sharing conventions
!
!	Christian Saether, 	27-OCT-78  15:09
!	X0012 - do not set DUPS_SEEN if the record is deleted on position for
!		insert
!
!	Christian Saether, 	12-DEC-78  20:17
!	X0013 - set ADUP_SEEN always when passing dupes - this has been taken
!		out 12/18/78
!
!	Christian Saether, 	15-DEC-78  11:17
!	X0014 - mask split_bits in csearch_tree before calling search_tree
!
!	Christian Saether, 	9-JAN-79  12:08
!	X0015 - on lock error going horizontal, reread bucket with lock to
!		force stall
!
!	Christian Saether, 	15-JAN-79  18:22
!	X0016 - modify lockabove logic to avoid deadlocks
!
!	Christian Saether, 	20-JAN-79  20:18
!	X0017 - confirm level 1 down pointer before going across level 0
!
!	Wendy Koenig, 	23-JAN-79  14:21
!	X0018 - zero MIDX_TMP1
!
!	Christian Saether, 	24-JAN-79  11:25
!	X0019 - set up bkt_addr after releasing empty bucket when going across
!		at data level
!
!	Christian Saether, 	26-JAN-79  9:49
!	X0020 - only clear splits bits when coming around from data level,
!		take out going across at data level kluge
!
!	Christian Saether, 	6-FEB-79  17:42
!	X0021 - do not look at owner of bdb to make lockabove decision
!
!	Christian Saether, 	14-FEB-79  14:05
!	X0022 - always go across data level primary key dupes
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

!
! define default psects for code
!

PSECT
    CODE = $$RMS3(PSECT_ATTR),
    PLIT = $$RMS3(PSECT_ATTR);

!

MACRO
    L_HIGH_KEY =
	RL$HIGH_KEY = JSB()%;


! Linkages
!

LINKAGE
    L_BUG3,
    L_CACHE,
    L_CNTRL_ADDR,
    L_COMPARE_KEY,
    L_CSEARCH_TREE,
    L_GETBKT,
    L_HIGH_KEY,
    L_KEY_DESC,
    L_MOVE,
    L_REC_OVHD,
    L_RECORD_KEY,
    L_RLSBKT,
    L_SRCH_CMPR,
    L_SRCH_BY_KEY,
    L_RECORD_VBN,
    L_SEARCH_TREE;

!
! Forward Routines
!

FORWARD ROUTINE
    RM$V3_VBN		: RL$SRCH_BY_KEY;

!
! External Routines
!

EXTERNAL ROUTINE
    RM$BUG3		: RL$BUG3,
    RM$CACHE		: RL$CACHE,
    RM$CNTRL_ADDR	: RL$CNTRL_ADDR,
    RM$COMPARE_KEY	: RL$COMPARE_KEY,
    RM$GETBKT		: RL$GETBKT,
    RM$KEY_DESC		: RL$KEY_DESC,
    RM$MOVE		: RL$MOVE,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$RECORD_KEY	: RL$RECORD_KEY,
    RM$RECORD_VBN	: RL$RECORD_VBN,
    RM$RLSBKT		: RL$RLSBKT,
    RM$SRCH_CMPR	: RL$SRCH_CMPR;

LITERAL
    LS = -1,
    GT = 1,
    EQ = 0;

ROUTINE SEARCH_FIX (GOAL) : RL$SRCH_BY_KEY =

!++
!
! SEARCH_FIX
!
!	This routine searches a PLG3 fixed length key index or SIDR bucket from 
!	the  current record address to the end of the bucket
!	for an index record equal or greater than the input search key
!
! CALLING SEQUENCE:
!	SEARCH_FIX
!
! INPUT PARAMETERS:
!
!	GOAL - 0 - be satisfied with an equal match
!	     - 1 - position past an equal match (search for GT match)
!
! IMPLICIT INPUTS:
!	REC_ADDR		- address of record in bucket to begin search on
!	BKT_ADDR		- address of current bucket
!	IDX_DFN			- address of index descriptor for current key of reference
!	IRAB			- address of internal RAB
!	IRAB[IRB$V_SRCHGT]	- if set, search for index/data record gt search key
!	IRAB[IRB$V_POSINSERT]	- if set, search for position to insert record
!	IRAB[KEY BUFFER 2]	- address of search key
!	IRAB[IRB$B_KEYSZ]	- size of key to compare
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR	- if EQ, address of index/record equal to search key
!			- if GT, at end of record data in bucket
!			- if LS, address of index/record greater than search key
!	IRAB [IRB$L_REC_COUNT]	- Number of the record who address is in REC_ADDR
!	[DUPS_SEEN]	- Set if goal is gt and we found an eq match
!
! ROUTINE VALUE:
!	R0		- 0, search key = index/data record
!			- -1, search key < index/data record
!			- 1,  search key > index/data record
!
! SIDE EFFECTS:
!
!--
BEGIN

EXTERNAL REGISTER
    R_IRAB_STR,
    R_IFAB_STR,
    R_IDX_DFN_STR,
    R_BKT_ADDR_STR,
    R_REC_ADDR_STR;

LOCAL
    STATUS,		! place to hold results of compare
    RSTART,		! address of first record in range
    REND,		! address of last record in range
    EOB;		! address past last record in bucket
        
EOB = .BKT_ADDR + .BKT_ADDR [BKT$W_FREESPACE];
RSTART = .REC_ADDR;
REND = .EOB;

! First check for an empty bucket. (Could potentially happen if
! we fail during space reclamation
!

IF .EOB LEQ .BKT_ADDR + BKT$C_OVERHDSZ
THEN
    RM$BUG3();

! Do a binary search of fixed length index records
!

WHILE 1 DO
    BEGIN
    LOCAL
	SIZE;		! Number of characters in range

    SIZE = .REND - .RSTART;
    REC_ADDR = (.RSTART + (.SIZE^-1) / .IDX_DFN[IDX$B_KEYSZ] * .IDX_DFN[IDX$B_KEYSZ]);
    STATUS = CH$COMPARE (.IRAB [IRB$B_KEYSZ], KEYBUF_ADDR(2),
			 .IRAB [IRB$B_KEYSZ], .REC_ADDR,
			 %O'0');

    CASE .STATUS FROM LS TO GT OF
	SET
	[LS]:	! Search key is < record in bucket
		! prepare to search low half of bucket
		!
		BEGIN
		REND = .REC_ADDR;

		IF .REND EQL .RSTART
		THEN

		    ! Only one record left and we just compared it
		    !
		    EXITLOOP;
		END;

	[EQ]:   ! Search key = record in bucket
		! 
		!	GENERIC SEARCH		GOAL IS EQ MATCH	
		!	    yes			    yes		   search previous
		!	    yes			    no		   search next
		!	    no			    yes		   return
		!	    no			    no		   search next
		!
		BEGIN

		IF .GOAL EQL EQ
		THEN
		    IF .IRAB [IRB$B_KEYSZ] EQL .IDX_DFN [IDX$B_KEYSZ]
		    THEN
			EXITLOOP
		    ELSE 

			! generic equal match. we must postion to the previous
			! record in order to find first equal match
			!
			BEGIN

			IF (.REND - .RSTART) EQL .IDX_DFN [IDX$B_KEYSZ]
			THEN
			    EXITLOOP;

			IF (.REND - .RSTART) EQL (.IDX_DFN [IDX$B_KEYSZ]^1)
			THEN
			    REND = .REC_ADDR
			ELSE
			    REND = .REC_ADDR + .IDX_DFN [IDX$B_KEYSZ];
		        END

		ELSE

		    ! Search past dups
		    !
		    BEGIN
		    IRAB [IRB$V_DUPS_SEEN] = 1;

		    ! If there is another record in the bucket, compare it
		    !
		    REC_ADDR = .REC_ADDR + .IDX_DFN[IDX$B_KEYSZ];

		    IF .REC_ADDR EQL .EOB
		    THEN
			STATUS = GT
		    ELSE
			STATUS = LS;

		    EXITLOOP;
		    END
		END;

	[GT]:	! Search key is > record in bucket
		!
		BEGIN
		REC_ADDR = .REC_ADDR + .IDX_DFN[IDX$B_KEYSZ];

		IF (.REND - .RSTART) LEQ (.IDX_DFN[IDX$B_KEYSZ])^1
		THEN

		    ! We just compared the last record in the range
		    ! If this is the last record in the bucket, return
		    ! with a GT status.
		    !

		    IF .REND EQL .EOB
		    THEN
			EXITLOOP
		    ELSE
			! We are not at the end of bucket so we know that
			! we must have done an earlier compare against the
			! low record of the next range and got an LS result.
			! Return that record.
			!
		        BEGIN
		        STATUS = LS;
		        EXITLOOP;
		    	END;

		! Prepare to search high half of bucket
		!
		RSTART = .REC_ADDR; 
		END;
	TES;
    END;

! We now have a record of some sort. 
! Compute the record count so that we can later pick up the VBN portion
! of the record from the end of the bucket
!
IRAB[IRB$L_REC_COUNT] = (.REC_ADDR-.BKT_ADDR-BKT$C_OVERHDSZ)/.IDX_DFN[IDX$B_KEYSZ];

RETURN .STATUS;
END;


ROUTINE SEARCH_V2 (GOAL) : RL$SRCH_BY_KEY =
!+++
!
! SEARCH_V2
!
!	This routine searches a prologue two bucket or a prologue 3 primary
!	data level with a non-compressed key bucket for a record whose value
!	is equal or greater than the search key.
!
! INPUT PARAMETER
!	GOAL 	- 0, return if you find an equal or greater than match
!		- 1, return only with a greater than match
!
! IMPLICIT INPUTS:
!	REC_ADDR		- address of record in bucket to begin search on
!	BKT_ADDR		- address of current bucket
!	IDX_DFN			- address of index descriptor for current key of reference
!	IRAB			- address of internal RAB
!	IRAB[IRB$V_SRCHGT]	- if set, search for index/data record gt search key
!	IRAB[IRB$V_POSINSERT]	- if set, search for position to insert record
!	IRAB[KEY BUFFER 2]	- address of search key
!	IRAB[IRB$B_KEYSZ]	- size of key to compare
!	IFAB[IFB$B_PLG_VER]	- prologue version number
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR	- if EQ, address of index/record equal to search key
!			- if GT, at end of record data in bucket
!			- if LS, address of index/record greater than search key
!	[ DUPS_SEEN ] 	- set if duplicates seen when SRCHGT set
!	IRB$L_LST_NCMP	- Address of last record in bucket if search key > data record
!
!
! ROUTINE VALUE:
!	R0		- 0, search key = index/data record
!			- -1, search key < index/data record
!			- 1,  search key > index/data record
!
! SIDE EFFECTS:
!	RRV are skipped
!	AP is clobbered
!
!--
BEGIN

EXTERNAL REGISTER
    R_IRAB_STR,
    R_IFAB_STR,
    R_IDX_DFN_STR,
    R_BKT_ADDR_STR,
    R_REC_ADDR_STR;

BUILTIN
    AP;

LOCAL
    OVHD,
    TOTAL_SIZE,
    STATUS,
    EOB;

EOB = .BKT_ADDR + .BKT_ADDR [BKT$W_FREESPACE];

WHILE .REC_ADDR LSSA .EOB
DO
    BEGIN

    AP = 3;  ! Initialize for a contiguous compare

    BEGIN
    GLOBAL REGISTER
	R_REC_SIZE;

    ! Search for the 1st record whose key is greater than or
    ! equal to the search key
    !

    IF (REC_SIZE = .BKT_ADDR [BKT$B_LEVEL]) EQL 0
    THEN

	! We have a data record, check if it is an RRV
	!
	BEGIN

	IF .REC_ADDR [IRC$V_RRV]
	THEN
	    RETURN GT;

	! Nope. Do the setup for compare
	!

	IF .IDX_DFN [IDX$B_KEYREF] NEQ 0
	THEN

	    ! We have a SIDR data record, set REC_SIZE to -1 as flag
	    !
	    REC_SIZE = .REC_SIZE - 1

	ELSE

	    ! We have a primary data record, set AP to 2 as flag
	    !
	    AP = .AP - 1;
 	END;

    ! Now get the number of bytes of overhead for this record
    !
    OVHD = RM$REC_OVHD();
    TOTAL_SIZE = .OVHD + .REC_SIZE;
    END; ! of block defining rec_size

    ! Actually do the comparison (finally) depending on file prologue version
    !

    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	STATUS = RM$COMPARE_KEY (.OVHD + .REC_ADDR, 
				KEYBUF_ADDR(2),
				.IRAB [IRB$B_KEYSZ])
    ELSE
	! At this moment we know we have a prologue 3 primary data level
	!
	STATUS = CH$COMPARE (.IRAB [IRB$B_KEYSZ],
			     KEYBUF_ADDR(2),
			     .IRAB [IRB$B_KEYSZ],
			     .OVHD + .REC_ADDR,
			     %O'0');

    IF .STATUS LSS 0
    THEN
	RETURN .STATUS;

    IF .STATUS EQL 0 
    THEN
	IF .GOAL EQL 0
	THEN
	    RETURN EQ
	ELSE
	    ! We have an equal match but were looking for a GT match.
	    ! Go get the next record and continue comparison (this will
	    ! position past all duplicates).
	    !
	    BEGIN
	    IRAB [IRB$L_LST_REC] = .REC_ADDR;

	    IF NOT .REC_ADDR [IRC$V_DELETED]
	    THEN
		IRAB [IRB$V_DUPS_SEEN] = 1;
	    END;

    REC_ADDR = .REC_ADDR + .TOTAL_SIZE;
    END;

! We have a GT match. Save the address of the last record in
! the bucket (we are positioned past it now).
!
IRAB [IRB$L_LST_NCMP] = .REC_ADDR - .TOTAL_SIZE;

RETURN GT
END;

GLOBAL ROUTINE RM$SRCH_BY_KEY : RL$SRCH_BY_KEY =
!++
!
!    RM$SRCH_BY_KEY
!
!	This routine searches a bucket from the current record address
!	for an index/data record equal or greater than the input search key
!
! CALLING SEQUENCE:
!	RM$SRCH_BY_KEY()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	REC_ADDR		- address of record in bucket to begin search on
!	BKT_ADDR		- address of current bucket
!	IDX_DFN			- address of index descriptor for current key of reference
!	IRAB			- address of internal RAB
!	IRAB[IRB$V_SRCHGT]	- if set, search for index/data record gt search key
!	IRAB[IRB$V_POSINSERT]	- if set, search for position to insert record
!	IRAB[KEY BUFFER 2]	- address of search key
!	IRAB[IRB$B_KEYSZ]	- size of key to compare
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR	- if EQ, address of index/record equal to search key
!			- if GT, at end of record data in bucket
!			- if LS, address of index/record greater than search key
!	IRAB [ EMPT_SEEN ] - set if no data records encountered
!	     [ DUPS_SEEN ] - set if duplicates seen when SRCHGT set
!
! ROUTINE VALUE:
!	R0		- 0, search key = index/data record
!			- -1, search key < index/data record
!			- 1,  search key > index/data record
!
! SIDE EFFECTS:
!	RRV are skipped
!	AP is clobbered
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IRAB_STR,
	R_IFAB_STR,
	R_BKT_ADDR_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    LOCAL
	BKTYP,			! Type of bucket we are searching
   	GOAL,			! Flag to say 'search past dups'
	STATUS;			! Result of a given compare


    ! If the record we are about to look at is an RRV, then we have an
    ! empty bucket.
    !

    IF .BKT_ADDR [BKT$B_LEVEL] EQL 0 
    THEN
	BEGIN
	LOCAL
	    CNTRL: REF BBLOCK;	! Control byte for 1st record

	CNTRL = RM$CNTRL_ADDR(0);

	IF .CNTRL [IRC$V_RRV]
	THEN
	    BEGIN
	    IRAB [IRB$V_EMPT_SEEN] = 1;
	    RETURN GT
	    END;
	END;

    ! Should we be satisfied with an equal match or continue searching
    ! for a greater than match ?
    !
    GOAL = EQ;

    IF .IRAB [IRB$V_SRCHGT] 
	OR (.IRAB [IRB$V_POSINSERT] AND .BKT_ADDR [BKT$B_LEVEL] EQL 0)
    THEN
	GOAL = GT;

    ! Now actually search the !!!!@@## bucket
    ! First find out what kind of bucket it is
    !

    IF .BKT_ADDR [BKT$B_LEVEL] EQL 0
	AND .IDX_DFN [IDX$B_KEYREF] EQL 0
    THEN
	BKTYP = .IDX_DFN [IDX$B_DATBKTYP]
    ELSE
	BKTYP = .IDX_DFN [IDX$B_IDXBKTYP];

    CASE .BKTYP FROM IDX$C_V2_BKT TO IDX$C_NCMPNCMP OF
	SET
	[IDX$C_V2_BKT]: ! Prologue two bucket or prologue three data bucket
			!
			STATUS = SEARCH_V2 (.GOAL);

	[IDX$C_CMPIDX]:	! Prologue three compressed index or SIDR bucket
			!
			STATUS = RM$SRCH_CMPR (.GOAL);

	[IDX$C_NCMPIDX]: ! Prologue three noncompressed index or SIDR bucket
			!
	    		STATUS = SEARCH_FIX (.GOAL);

	[IDX$C_CMPCMP]:	! Prologue three primary data bucket.
			! Primary key is compressed, data is compressed
			!
			STATUS = RM$SRCH_CMPR (.GOAL);

	[IDX$C_CMPNCMP]: ! Prologue three primary data bucket.
			! Primary key is compressed, data is NOT compressed
			!
			STATUS = RM$SRCH_CMPR (.GOAL);

	[IDX$C_NCMPCMP]: ! Prologue three data bucket.
			! Primary key is NOT compressed, data is compressed
			!
			STATUS = SEARCH_V2 (.GOAL);

	[IDX$C_NCMPNCMP]: ! Prologue three data bucket.
			! Primary key is NOT compressed, data is NOT compressed
			!
			STATUS = SEARCH_V2 (.GOAL);
	TES;

    RETURN .STATUS	
    END;	
	

ROUTINE RM$SEARCH_TREE : RL$SEARCH_TREE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches from the current record in the current bucket
!	to the stop level requested for a data record /index equal to or
!	greater than the search key.
!	NOTE: this routine should never be called by an outside routine
!		RM$CSEARCH_TREE should be used in its place
!
! CALLING SEQUENCE:
!	RM$SEARCH_TREE()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	BKT_ADDR		- address of current bucket
!	REC_ADDR		- address of record in bucket to start search at
!	IDX_DFN			- address of index descriptor for current key of reference
!	IRAB			- address of internal RAB
!	IRAB[KEYBUF2]		- address of search key
!	IRAB[IRB$B_KYSZ]	- size of key to compare(not equal to key size if generic search)
!	IRAB[IRB$B_STOPLEVEL]	- level to stop search at
!	IRAB[IRB$B_SRCHFLAGS]
!	IRAB[IRB$V_POSINSERT]	- if set, this is a position for insert
!	IRAB[IRB$V_POSDELETE]	- if set, this is position for delete
!	IRAB[IRB$V_SRCHGT]	- if set, this is a GT approximate search
!	IRAB[IRB$V_SRCHGE]	- if set, this is a GE approximate search
!	IRAB[IRB$V_FIRST_TIM]	- if set, this is the first seq. positioning
!				- after a $connect or $rewind
!	IFAB[IFB$B_EXTRABUF]	- used to decide whether to try lockabove
!				performance optimization coming down tree
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR		- address of index/data record which terminated search
!	IRAB[IRB$L_CURBDB]	- address of current BDB
!	BDB			- address of current BDB
!	IRAB[IRB$L_LOCK_BDB]	- address of level above current if locked
!	IRAB[IRB$V_ABOVELCKD]	- set when level above data level locked
!	IRAB[IRB$V_DUPS_SEEN]	- set if non-deleted duplicate key encountered
!					at data level on position for insert
!	IRAB [IRB$L_REC_COUNT]	- Set to the number of the record we found in
!				  a prologue three bucket
!
! ROUTINE VALUE:
!	RMS$_RNF		- record not found
!	RMS$_SUC		- record found, in approximate search key
!				  may not equal record/index key
!	RMS$_RLK		- on an horizontal search at level zero for position
!				  for insert, a lock error was encountered
!	miscellaneous I/O errors
!
! SIDE EFFECTS:
!	IRAB [ EMPT_SEEN ] 	- may be clobbered at any level
!	     [ EMPTY_BKT ] 	- may be clobbered at data level
!
!--

    BEGIN

    LABEL
	BLK,
	BLK1,
	BLK2,
	BLK3,
	BLK4,
	BLK5,
	BLK6;

    BUILTIN
	AP,
	TESTBITSC;

    LOCAL
	VBN;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	COMMON_IO_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    ! Consider taking these checks out once ISAM works
    !

    IF .IRAB[IRB$B_STOPLEVEL] GTRU .BKT_ADDR[BKT$B_LEVEL]
    THEN
	RETURN RMSERR(BUG);

    VBN = 0;

    DO
BLK2 :
	BEGIN

	LOCAL
	    ST;

	ST = 0;

	! if this is the 1st time, just get the 1st down pointer w/o searching
	!

	IF NOT .IRAB[IRB$V_FIRST_TIM]
	THEN
	    ST = RM$SRCH_BY_KEY()
	ELSE
	    IRAB [IRB$L_LST_NCMP] = .BKT_ADDR + BKT$C_OVERHDSZ;

	! If the status is GT then no record in this bucket terminated the
	! search. Therefore search horizontally for termination record.
	! Also search horiz when skipping over dups on position for insert
	!
	!

	IF .ST GTR 0
	THEN
	    BEGIN

	    LOCAL
		SIZE;

	    IF .BKT_ADDR[BKT$V_LASTBKT]
	    THEN

		IF .IRAB[IRB$V_POSINSERT]
		THEN
		    RETURN RMSSUC(SUC)
		ELSE
		    RETURN RMSERR(RNF);

	    BDB = .IRAB[IRB$L_CURBDB];
	    SIZE = .BDB[BDB$W_NUMB];

	    IF .VBN EQL 0
	    THEN
		VBN = .BKT_ADDR[BKT$L_NXTBKT];

	    IF (.IRAB[IRB$V_POSINSERT] AND .BKT_ADDR[BKT$B_LEVEL] EQLU 0)
	    THEN
BLK3 :		BEGIN

		! Check if we can insert the new key into the left
		!  hand bucket (the one we've got) or if we have to
		!  go get the right hand bucket in order to make the
		!  decision.
		!
		! NEXT_DOWN will be equal to -1 if none was saved,
		! causing this test to fail.  Once this test has been
		! made once, NEXT_DOWN is set to zero, again causing
		! failure on this test.
		!

		IF .VBN EQLU .IRAB [IRB$L_NEXT_DOWN]
	 	THEN
		    ! Horizontal pointer = down pointer
		    !

		    IF 	NOT (.IDX_DFN [IDX$V_DUPKEYS] AND .IDX_DFN [IDX$B_KEYREF] EQL 0)
		    THEN
			! Not a primary data bucket with possible duplicates
			!
			RETURN RMSSUC(SUC);

		! If the file is being shared in any way, and the bucket
		! in the level above was not locked coming down the tree,
		! we must re-access the level above to confirm that in
		! fact a split has not occurred and the level above index
		! bucket doesn't have a new key value in the pointer to
		! the bucket we are in.  If this is not done, the horizontal
		! positioning logic that follows may cause the record to
		! be inserted such that it is not accessible by random access.
		! The following pictures illustrate.  Assume 1 record per
		! bucket at the data level.
		!
		!   ----
		!  | 9  |  level 1    Index looks like this when coming
		!   ----              down tree looking to insert an "8".
		!    v
		!   ____
		!  | 9  |  data level
		!   ____
		!   db 1
		!   ____
		!  |5 9 |	However, by the time that db 1 is actually
		!   ----	accessed, it has split and the index updated.
		!  /    \	Yet, because the key value "8" is less than the
		! ---  ---	lowest key value in db 2, the position for
		!| 5 || 9 |	insert would be in db 1.  Rescanning the level
		! ---  ---	1 bucket for key "8" will now find the correct
		!db 1  db 2	down pointer to db 2.
		!

		! If the down pointer from level 1 can not have changed,
		! either because the file is not shared or it is still
		! locked, or it has already been checked once, then the
		! check does not have to be made.
		!

		IF .IFAB [IFB$V_NORECLK]
		    OR .IRAB [IRB$V_ABOVELCKD]
		THEN
		    BEGIN
		    IF .IRAB [IRB$L_NEXT_DOWN] NEQ 0
		    THEN
			BEGIN
			IRAB [IRB$L_VBN_RIGHT] = 0;
			IRAB [IRB$L_NEXT_DOWN] = 0;
			IRAB [IRB$L_VBN_LEFT] = .BDB [BDB$L_VBN];
			END;

		    LEAVE BLK3;
		    END
		ELSE

		    ! If NEXT_DOWN is zero, we've already been through
		    ! here once, so don't check again.
		    !

		    IF .IRAB [IRB$L_NEXT_DOWN] EQL 0
		    THEN
			LEAVE BLK3;


		! The VBN of the level 1 bucket has been saved in the
		! VBN_RIGHT field.  Reaccess the bucket.  Release the
		! level 0 bucket and exit on errors.
		!

		ST = CACHE (.IRAB [IRB$L_VBN_RIGHT],
			    .IDX_DFN [IDX$B_IDXBKTSZ]*512);
		IF NOT .ST
		THEN
		    BEGIN
		    BDB = .IRAB [IRB$L_CURBDB];
		    RM$RLSBKT(0);
		    IRAB [IRB$L_CURBDB] = 0;
		    RETURN .ST;
		    END;

		! Rescan the level 1 bucket just accessed.  If the
		! key value is no longer in the bucket at all, then
		! release both level 1 and level 0 buckets and come
		! down the tree from the top (returning RLK to CSEARCH_TREE
		! does that).
		!

		REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		IRAB [IRB$L_REC_COUNT] = 0;
		IF RM$SRCH_BY_KEY() GTR 0
		THEN
		    BEGIN
		    ST = RMSERR(RLK);
		    RM$RLSBKT(0);
		    BDB = .IRAB [IRB$L_CURBDB];
		    RM$RLSBKT(0);
		    IRAB [IRB$L_CURBDB] = 0;
		    RETURN .ST;
		    END;

		! At this point we've a down pointer in the same level
		! 1 bucket.  Check the pointer itself to see if it still
		! points to the level 0 bucket we found before.
		!

		BEGIN

		LOCAL
		    LEV0_BDB	: REF BBLOCK,
		    LEV1_VBN;

		LEV0_BDB = .IRAB [IRB$L_CURBDB];
		AP = 1;

		IF .IFAB [IFB$B_PLG_VER] LSSU PLG$C_VER_3
		THEN
		    LEV1_VBN = RM$RECORD_VBN()
		ELSE
		    LEV1_VBN = RM$V3_VBN();

		IF .LEV1_VBN NEQ  .LEV0_BDB [BDB$L_VBN]
		THEN

		    ! The pointer from the level 1 bucket is not the same,
		    ! but it is in the same level 1 bucket.  Simply release
		    ! the level 0 bucket we have accessed, and go around the
		    ! loop again so that this all happens again.
		    !
		    BEGIN
		    IRAB [IRB$B_SPL_BITS] = 0;
		    IRAB [IRB$L_CURBDB] = .BDB;
		    BDB = .LEV0_BDB;
		    RM$RLSBKT(0);
		    BDB = .IRAB [IRB$L_CURBDB];
		    BKT_ADDR = .BDB [BDB$L_ADDR];
		    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		    LEAVE BLK2;
		    END;

		! Ok, everything is cool.  The down pointer is still the
		! same.  Release the level 1 bucket and prepare to follow
		! the horizontal links at the data level for primary key.
		!

		RM$RLSBKT(0);
		BDB = .LEV0_BDB;
		BKT_ADDR = .BDB [BDB$L_ADDR];
		END;		! of block defining LEV* locals.

		IRAB [IRB$L_VBN_RIGHT] = 0;
		IRAB [IRB$L_NEXT_DOWN] = 0;
		IRAB [IRB$L_VBN_LEFT] = .BDB [BDB$L_VBN];

		END;

	    ! If this is the stoplevel on any positioning for
	    ! modification, the bucket to be read must be locked.
	    !

	    IF (.IRAB [IRB$B_SRCHFLAGS] AND (IRB$M_POSINSERT + IRB$M_POSDELETE))
		NEQ 0 AND .IRAB [IRB$B_STOPLEVEL] EQL .BKT_ADDR [BKT$B_LEVEL]
	    THEN
		IRAB [IRB$B_CACHEFLGS] = CSH$M_LOCK;

	    ! Release current bucket before reading the next one.
	    !

	    RM$RLSBKT(0);
	    IRAB [IRB$L_CURBDB] = 0;

	    ! Read in the next bucket in the horizontal chain.
	    !

	    IF NOT (ST = RM$GETBKT(.VBN, .SIZE))
	    THEN
		BEGIN

		! If the level above was locked, release it.
		!

		IF TESTBITSC(IRAB[IRB$V_ABOVELCKD])
		THEN
		    RELEASE(IRAB[IRB$L_LOCK_BDB]);

		RETURN .ST;
		END;

	    VBN = .BKT_ADDR[BKT$L_NXTBKT];
	    IRAB[IRB$L_CURBDB] = .BDB;

	    IF (.IRAB[IRB$V_POSINSERT] AND .BKT_ADDR[BKT$B_LEVEL] EQLU 0)
	    THEN

		! This is a position for insert at level 0.  
		!
		! At this point we have just read in the next bucket in the
		! horizontal chain.  The position for insert in the bucket
		! just released was at the end of that bucket.
		!
		! Basically, if the record is lower than any record in
		! the next bucket, it should be inserted at the end of
		! the previous bucket.
		!
		! Field usage is as follows:
		!  IRAB[ VBN_LEFT ] - the leftmost, non-empty bucket in
		!	which the position for insert was at the end of
		!	the bucket.
		!
		!  IRAB[ VBN_RIGHT ] - the rightmost bucket in which the
		!	position for insert was at the beginning of the
		!	bucket, i.e., less than all existing values in
		!	that bucket, or an empty bucket.  This is used
		!	to determine if VBN_LEFT may be used after backing
		!	up.
		!
		! Because the buckets are released prior to accessing the
		! next bucket, it is possible for splits to occur prior to
		! backing up, if that is necessary.  The following assumptions
		! are made:
		! 1) The position for insert can never be to the left of
		! the initial VBN_LEFT.
		! 2) The position for insert can never be in or to the right
		! of a bucket in which the position for insert was at the
		! beginning of that bucket.
		! 3) If the NXTBKT link from a VBN_LEFT matches a previously
		! accessed VBN_RIGHT, the correct position for insert is at
		! the end of VBN_LEFT.
		! 4) Empty buckets are skipped over until a non-empty bucket
		! is encountered.
		!
		! Note that an EMPT_SEEN bucket also returns greater than (GT)
		! status.  VBN_LEFT and VBN_RIGHT are initialized to zero
		! in the CSEARCH_TREE routine when positioning for insert and
		! the stoplevel is 0.
		!

		WHILE 1 DO

		BEGIN

		REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
		IRAB [IRB$L_REC_COUNT] = 0;

		ST = RM$SRCH_BY_KEY();

		IF (VBN=.BKT_ADDR[BKT$L_NXTBKT]) EQL .IRAB[IRB$L_VBN_RIGHT]
		THEN
		    BEGIN
		    IRAB [IRB$L_VBN_LEFT] = 0;
		    IRAB [IRB$L_VBN_RIGHT] = 0;
		    RETURN RMSSUC(SUC)
		    END;

		IF .ST LSS 0
		    AND
		    .REC_ADDR EQLA (.BKT_ADDR + BKT$C_OVERHDSZ)
		    OR
		    (.BKT_ADDR[BKT$V_LASTBKT] AND .IRAB[IRB$V_EMPT_SEEN])
		THEN
		    BEGIN

		    IF .IRAB [IRB$L_VBN_RIGHT] EQL 0
		    THEN
			IRAB [IRB$L_VBN_RIGHT] = .BDB [BDB$L_VBN];

		    VBN = .IRAB [IRB$L_VBN_LEFT];
		    END

		ELSE
		    BEGIN

		    IF .ST LEQ 0 OR .BKT_ADDR[BKT$V_LASTBKT]
		    THEN
			BEGIN
			IRAB [IRB$L_VBN_LEFT] = 0;
			IRAB [IRB$L_VBN_RIGHT] = 0;
			RETURN RMSSUC(SUC);
			END;

		    IF .IRAB [IRB$V_EMPT_SEEN]
		    THEN
			BEGIN
			IF .IRAB [IRB$L_VBN_RIGHT] EQL 0
			THEN
			    IRAB [IRB$L_VBN_RIGHT] = .BDB [BDB$L_VBN];
			END
		    ELSE
			BEGIN
			IRAB [IRB$L_VBN_RIGHT] = 0;
			IRAB [IRB$L_VBN_LEFT] = .BDB [BDB$L_VBN];
			END;
		    END;

		RM$RLSBKT(0);
		IRAB [IRB$L_CURBDB] = 0;
		IRAB [IRB$B_CACHEFLGS] = CSH$M_LOCK;

		IF NOT (ST=RM$GETBKT(.VBN,.SIZE))
		THEN
		    BEGIN
		    IF TESTBITSC (IRAB[IRB$V_ABOVELCKD])
		    THEN
			RELEASE(IRAB[IRB$L_LOCK_BDB]);
		    RETURN .ST
		    END;

		IRAB [IRB$L_CURBDB] = .BDB;

		END;	! of position for insert level 0 WHILE loop.
	    END		! of greater than status from srch_by_key.
	ELSE

	    ! status was less than or equal meaning we have a down pointer if
	    ! at an index level or may or may not have the data record
	    ! depending upon whether an exact match was desired or not
	    !
	    BEGIN

	    LOCAL
		SIZE;

	    IF .BKT_ADDR[BKT$B_LEVEL] EQLU .IRAB[IRB$B_STOPLEVEL]
	    THEN
		BEGIN

		IF .ST EQL 0
		THEN
		    RETURN RMSSUC(SUC)
		ELSE

		    IF .IRAB[IRB$V_POSINSERT]
			OR
			.IRAB[IRB$V_SRCHGT]
			OR
			.IRAB[IRB$V_SRCHGE]
		    THEN
			RETURN RMSSUC(SUC)
		    ELSE
			RETURN RMSERR(RNF);

		END;

	    ! Get the down pointer from the index record positioned at.
	    !

	    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
	    THEN
		BEGIN
		AP = 1;
		VBN = RM$RECORD_VBN();
		END
	    ELSE	! Version 3 index bucket
		BEGIN
		VBN = RM$V3_VBN();
		END;			    

	    IF .VBN EQLU 0
	    THEN
		RETURN (RMSERR(TRE));

	    ! Check if about to read data level and switch to data level
	    ! transfer size.
	    !

	    IF .BKT_ADDR[BKT$B_LEVEL] EQLU 1
	    THEN
		SIZE = .IDX_DFN[IDX$B_DATBKTSZ]
	    ELSE
		SIZE = .IDX_DFN[IDX$B_IDXBKTSZ];

	    SIZE = .SIZE*512;

	    ! now check to see if the next level to read needs to be locked
	    !
	    !
	    BDB = .IRAB[IRB$L_CURBDB];		! get curbdb into bdb

	    IF .IRAB[IRB$V_POSINSERT]
		OR
		.IRAB[IRB$V_POSDELETE]
	    THEN

		! lock the stop level if either position for insert or delete
		!
		!
BLK4 :
		BEGIN

		LOCAL
		    STOPLEVCHK	: BYTE;

		STOPLEVCHK = .IRAB[IRB$B_STOPLEVEL];
		STOPLEVCHK = .STOPLEVCHK + 1;

		IF .BKT_ADDR[BKT$B_LEVEL] EQL .STOPLEVCHK
		THEN
BLK5 :
		    BEGIN

		    GLOBAL REGISTER
			R_REC_SIZE;

		    ! if the stoplevel not zero, just lock it
		    !

		    IF .IRAB[IRB$B_STOPLEVEL] NEQ 0
			OR
			.IRAB[IRB$V_POSDELETE]
		    THEN
			BEGIN
			IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;
			LEAVE BLK5;

			END;

		    ! try to save the next down pointer if it's in this bucket
		    ! to avoid possible i/o at the data level
		    !
BLK6 :		    BEGIN

		    IRAB [IRB$L_NEXT_DOWN] = -1;

		    ! See if we're already at the end of the bucket.
		    !
		    CASE .IDX_DFN [IDX$B_IDXBKTYP] FROM IDX$C_V2_BKT TO IDX$C_NCMPIDX OF
		    SET
		    [IDX$C_V2_BKT]: BEGIN
				    REC_SIZE = 1;
				    REC_ADDR = .REC_ADDR + RM$REC_OVHD();
				    REC_ADDR = .REC_ADDR + .REC_SIZE;
				    END;

		    [IDX$C_CMPIDX]: BEGIN
				    REC_ADDR = .REC_ADDR + .(.REC_ADDR)<0,8> + 2;
				    END;

		    [IDX$C_NCMPIDX]:BEGIN
				    REC_ADDR = .REC_ADDR + .IDX_DFN [IDX$B_KEYSZ];
				    END;
		    TES;

		    IF .REC_ADDR GEQA .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE]
		    THEN
			LEAVE BLK6;

		    IF .IDX_DFN [IDX$B_IDXBKTYP] EQL IDX$C_V2_BKT 
		    THEN
			BEGIN
			AP = 1;
			IRAB [IRB$L_NEXT_DOWN] = RM$RECORD_VBN();
			END
		    ELSE
			BEGIN
			IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] + 1;
			IRAB [IRB$L_NEXT_DOWN] = RM$V3_VBN();
			END;

		    END;  ! of BLK6

		    ! if we have extrabufs and this bucket is locked then
		    ! we did lockabove optimization so set
		    ! abovelckd to note that and save the bdb in lock_bdb.
		    ! Also, if the blb_ptr is zero and there are extrabufs
		    ! then the file is exclusively accessed therefore the
		    ! optimization may also be made.
		    !

		    IF 	.IRAB[IRB$B_BCNT] GTRU 2
		    THEN
			IF .BDB[BDB$L_BLB_PTR] EQL 0
			THEN
			    BEGIN
			    IRAB[IRB$V_ABOVELCKD] = 1;
			    IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK OR CSH$M_NOWAIT;
			    IRAB[IRB$L_LOCK_BDB] = .BDB;
			    IRAB[IRB$L_CURBDB] = 0;
			    LEAVE BLK4;

			    END
			ELSE
			    IF .BBLOCK[.BDB[BDB$L_BLB_PTR], BLB$V_LOCK]
			    THEN
			        BEGIN
			        IRAB[IRB$V_ABOVELCKD] = 1;
			        IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK OR CSH$M_NOWAIT;
			        IRAB[IRB$L_LOCK_BDB] = .BDB;
			        IRAB[IRB$L_CURBDB] = 0;
			        LEAVE BLK4;

			        END;

		    ! We are not keeping the level above locked on the
		    ! way down.  Remember the vbn of this level 1 bucket we
		    ! just passed through because it may have to be
		    ! checked when we get to level 0.
		    !

		    IRAB [IRB$L_VBN_RIGHT] = .BDB [BDB$L_VBN];
		    IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

		    END
		ELSE

		    ! if position for insert and we have the extra buffers and
		    ! we are going all the way to level zero, then we will try
		    ! the performance optimization of keeping the level above
		    ! the data level locked to avoid going back to the root in
		    ! the event of a split.
		    !

		    IF .IRAB[IRB$V_POSINSERT]
			AND
			.IRAB[IRB$B_STOPLEVEL] EQL 0
			AND
			.IRAB[IRB$B_BCNT] GTRU 2
		    THEN
			BEGIN
			STOPLEVCHK = .STOPLEVCHK + 1;

			IF .BKT_ADDR[BKT$B_LEVEL] EQL .STOPLEVCHK
			THEN
			    BBLOCK[IRAB[IRB$B_CACHEFLGS], CSH$V_LOCK] = 1;

			END;

		! release the current bucket before going down
		!
		RM$RLSBKT(0);
		IRAB[IRB$L_CURBDB] = 0;
		END				! of BLK4
	    ELSE

		! this is not position for insert or delete so just release the
		! level above
		!
		BEGIN
		RM$RLSBKT(0);
		IRAB[IRB$L_CURBDB] = 0;
		END;

	    WHILE 1 DO
		BEGIN
		ST = RM$GETBKT(.VBN, .SIZE);

		! if successful drop out of here
		!

		IF .ST
		THEN
		    EXITLOOP;

		! if abovelckd then release it to
		! avoid deadlock.  Save the VBN of the level 1
		! bucket as it will need to be rechecked when level 0
		! is reached.
		!

		IF TESTBITSC(IRAB[IRB$V_ABOVELCKD])
		THEN
		    BEGIN
		    BDB = .IRAB[IRB$L_LOCK_BDB];
		    IRAB [IRB$L_VBN_RIGHT] = .BDB [BDB$L_VBN];
		    IRAB[IRB$L_LOCK_BDB] = 0;
		    RM$RLSBKT(0);
		    END;

		IF .ST<0,16> NEQ RMSERR(RLK)
		THEN RETURN .ST;

		IRAB [IRB$B_CACHEFLGS] = CSH$M_LOCK;
		END;

	    IRAB[IRB$L_CURBDB] = .BDB;
	    VBN = 0;
	    END;				! end else block

	REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
	IRAB [IRB$L_REC_COUNT] = 0;
	END
    UNTIL 0					! end until loop
    END;


GLOBAL ROUTINE RM$CSEARCH_TREE : RL$CSEARCH_TREE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This module controls the search through a tree.  If a start position
!	is given, the search continues from that point.  If no start position is
!	given, then the search begins at the root.  In the position for insert case,
!	when a bucket is found on a horizontal search, a record lock error is
!	returned from the search tree routine.  This controlling module then
!	restarts the search from the root to prevent deadlock.
!
! CALLING SEQUENCE:
!	RM$CSEARCH_TREE()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	IRAB			- address of internal RAB
!	IRAB[KEYBUFFER 2]	- address of search key
!	IRAB[IRB$B_KYSZ]	- size of key to compare(not equal to total key size if
!				  generic search
!	IRAB[IRB$B_STOPLEVEL]	- level to stop search at
!	IRAB[IRB$B_SRCHFLAGS]	-
!	IRAB[IRB$V_POSINSERT]	- if set, this is a position for insert
!	IRAB[IRB$V_SRCHGT]	- if set, this is a GT approximate search
!	IRAB[IRB$V_SRCHGE]	- if set, this is a GE approximate search
!	IRAB[IRB$V_FIRST_TIM]	- if set, this is the 1ST sequential positioning
!				- after a $connect or $rewind
!	IRAB[IRB$V_NORLS_RNF]	- if set, do not release on RNF error
!	IRAB[IRB$L_CURBDB]	- if zero, then start at root
!	IRAB[IRB$L_CURBDB]	- if non-zero, then
!	REC_ADDR		- address of record in bucket to start search at
!	IDX_DFN			- address of current index descriptor
!
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	REC_ADDR		- address of index/data record which terminated search
!	IRAB[IRB$L_CURBDB]	- address of current BDB
!	IRAB[IRB$L_LOCK_BDB]	- address of level above current if locked
!	IRAB[IRB$V_ABOVELCKD]	- set if level above data level locked
!	IRAB[IRB$V_NORLS_RNF]	- always cleared
!
! ROUTINE VALUE:
!	RMS$_RNF		- record not found
!	RMS$_SUC		- record found, in approximate search key
!				  may not equal record/index key
!	Miscellaneous I/O errors
!
! SIDE EFFECTS:
!	if successful, bucket is accessed
!	if RNF and NORLS_RNF is set, then bucket is accessed
!	bucket released on all other errors
!	permanence is set in the root's bdb, if not pos-for-insert
!		or there are extra buffers hanging around
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    GLOBAL REGISTER
	R_BDB_STR,
	R_BKT_ADDR_STR;

    IRAB[IRB$V_ABOVELCKD] = 0;		! make sure this is clear at the start

    WHILE 1
    DO
	BEGIN
	BDB = .IRAB[IRB$L_CURBDB];

	IF .BDB EQLU 0
	THEN

	    ! If no position given, start at root
	    !
	    BEGIN

	    ! If the index has not been initialized, read in the index des
	    ! criptor again if it still has not been initialized, return error
	    ! Once the index descriptors are shared, this code can come out
	    ! since when the index is made, the in_core index descriptors will
	    ! be updated.
	    !

	    IF .IDX_DFN[IDX$V_INITIDX]
	    THEN
		BEGIN
		IRAB[IRB$V_NEW_IDX] = 1;

		RETURN_ON_ERROR (RM$KEY_DESC(.IDX_DFN[IDX$B_KEYREF]),
		    BEGIN
		    (IRAB[IRB$V_NORLS_RNF] = 0)
		    END);

		IF .IDX_DFN[IDX$V_INITIDX]
		THEN
		    (IRAB[IRB$V_NORLS_RNF] = 0;

		    IF .IRAB[IRB$V_POSINSERT]
		    THEN
			RETURN RMSERR(IDX)
		    ELSE
			RETURN RMSERR(RNF));

		END;

	    ! Read root and make sure it is still the root.  If not reread
	    ! prologue to obtain root VBN.
	    !

	    WHILE 1
	    DO
		BEGIN

		! if pos for insert then -- if the root should turn out to be
		! the stoplevel then lock it
		!

		IF .IRAB[IRB$V_POSINSERT]
		THEN
		    BEGIN

		    IF .IRAB[IRB$B_STOPLEVEL] EQL 0
		    THEN
			BEGIN

			IRAB [IRB$L_VBN_LEFT] = 0;
			IRAB [IRB$L_VBN_RIGHT] = 0;
			IRAB [IRB$L_NEXT_DOWN] = 0;

			! If the root is at level 1, we want to save
			! it's VBN so that the down pointer from it can
			! be checked when level 0 is reached.
			!

			IF .IDX_DFN [IDX$B_ROOTLEV] EQL 1
			THEN
			    IRAB [IRB$L_VBN_RIGHT] = .IDX_DFN [IDX$L_ROOTVBN];
			END
		    ELSE

			IF .IDX_DFN[IDX$B_ROOTLEV] EQL .IRAB[IRB$B_STOPLEVEL]
			THEN
			    IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

		    END;

		! try to get the root bucket
		!

		RETURN_ON_ERROR (RM$GETBKT(.IDX_DFN[IDX$L_ROOTVBN],
			.IDX_DFN[IDX$B_IDXBKTSZ]*512),
		    BEGIN
		    (IRAB[IRB$V_NORLS_RNF] = 0)
		    END);

		! if it really is the root bucket, leave this loop
		!

		IF .BBLOCK[.BDB[BDB$L_ADDR], BKT$V_ROOTBKT]
		THEN
		    EXITLOOP;

		RM$RLSBKT(0);
		IRAB[IRB$V_NEW_IDX] = 1;

		RETURN_ON_ERROR (RM$KEY_DESC(.IDX_DFN[IDX$B_KEYREF]),
		    BEGIN
		    (IRAB[IRB$V_NORLS_RNF] = 0)
		    END);

		END;

	    IRAB[IRB$L_CURBDB] = .BDB;

	    IF NOT .IRAB[IRB$V_POSINSERT]
		OR
		(.IDX_DFN[IDX$B_KEYREF] LSSU .IFAB[IFB$B_EXTRABUF])
	    THEN
		BDB[BDB$V_PRM] = 1;

	    REC_ADDR = .BDB[BDB$L_ADDR] + BKT$C_OVERHDSZ;
	    IRAB[IRB$L_REC_COUNT] = 0;
	    END
	ELSE
	    BEGIN

	    IF .IRAB[IRB$V_FIRST_TIM]
	    THEN
		RETURN RMSERR(BUG);

	    BKT_ADDR = .BDB[BDB$L_ADDR]
	    END;

	BEGIN

	LOCAL
	    STS;

	STS = RM$SEARCH_TREE();

	IF .STS<0, 16> NEQU RMSERR(RLK)
	THEN
	    BEGIN

	    IF .STS<0, 16> EQL RMSERR(RNF)
		AND
		NOT .IRAB[IRB$V_NORLS_RNF]
	    THEN
		BEGIN
		IRAB[IRB$L_CURBDB] = 0;
		RM$RLSBKT(0)
		END;

	    IRAB[IRB$V_NORLS_RNF] = 0;

	    RETURN .STS
	    END
	END;

	IRAB[IRB$B_SPL_BITS] = 0;	! clear dups_seen, empt_seen when
					! going around again from data level
	END

    END;				! end of routine RM$CSEARCH_TREE


GLOBAL ROUTINE RM$V3_VBN : RL$SRCH_BY_KEY =
!+++
!
! RM$V3_VBN
!	
!	This routine returns the VBN associated with record number 
!	'rec_count'. It is only useful on Version 3.0 index buckets.
!
!---
BEGIN

EXTERNAL REGISTER
    R_IRAB_STR,
    R_IFAB_STR,
    R_IDX_DFN_STR,
    R_BKT_ADDR_STR,
    R_REC_ADDR_STR;

LOCAL
    VBN,		! temporary storage
    FIRST_VBN,		! addr of first VBN in bucket
    VBN_SIZE;		! size of VBNs in this index bucket

VBN_SIZE = (.BKT_ADDR[BKT$V_PTR_SZ]) + 2;
FIRST_VBN = .BKT_ADDR + (.IDX_DFN[IDX$B_IDXBKTSZ] * 512) - 4 - .VBN_SIZE;
VBN = .(.FIRST_VBN - (.VBN_SIZE * .IRAB[IRB$L_REC_COUNT]));
RETURN .VBN <0,.VBN_SIZE ^ 3>
END;
END
ELUDOM
