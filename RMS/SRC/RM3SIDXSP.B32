
MODULE RM3SIDXSP (LANGUAGE (BLISS32) ,
		IDENT = 'V03-002'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                Split SIDR data level or any index level 50-50
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Christian Saether	     CREATION DATE:        	1-AUG-78  10:18
!
!
! MODIFIED BY:
!
!	V03-002	TMK0001		Todd M. katz		21-Apr-1982
!		The routine COMP_SPL_PNT is responsible for computing the
!		index bucket split point. Under certain circumstances, it
!		will sometimes have to find the record size of the index 
!		record(s) which are to be inserted. This record size comes in
!		two parts - key and VBN, which must be added together. Because
!		the macros used to define the VBN offsets were wrong, this
!		mean't that when the total size of the new record(s) was 
!		computed, it was computed incorrectly. This could lead to the
!		split point being incorrectly calculated, and to a RMS 
!		signalled bugcheck in at least one case. To fix this problem,
!		I fixed the macro definitions, and but them in ONE place.
!
!	V03-001	MCN0001		Maria del C. Nasr	25-Mar-1982
!		Use macro to get key buffer address.
!
!	V02-019	KPL0001		Peter Lieberwirth	 2-Mar-1982
!		Define linkage omitted in v02-018
!
!	V02-018	TMK0004		Todd M. Katz	01-Mar-1982
!		Add support for rear-end truncation of keys in the index
!		of prolog 3 files with compressed keys. This involves changes
!		to RM$SPLIT_EM. When an index bucket split occurs, the new
!		(right) bucket is constructed without any thought as to where
!		the new index records will be inserted. If the prolog 3 file
!		contains compressed index keys, then the compression of the
!		first key in the new bucket must be redetermined. At the very
!		least, the key must be expanded so that it is zero front
!		compressed. As any change in front compression may affect 
!		rear-end truncation, the entire compression of the first key
!		must be redetermined.
!
!	V02-017	TMK0003		Todd M. Katz	12-Feb-1982
!		It is possible for the two-pass two-bucket split case to be
!		confused with the two-pass multibucket split case where both
!		keys are to go in the new bucket. This will occur when each
!		index bucket can only hold two keys, an index bucket containing
!		two keys (the second of which is nonzero front compressed) must
!		split to make room for an additional key, and the insertion 
!		point is computed to be at the beginning of the bucket. In this
!		case, both the insertion point and the split point are at the
!		beginning of the bucket. Since RMS doesn't always check for a
!		multibucket case when it wants to special case the special 
!		multibucket split case described above because it wrongly
!		assumes that the insertion point can only be at the beginning 
!		of a bucket in the speical two-pass multibucket split case,
!		the two-bucket case can be confused with the multibucket case.
!		Add checks for a multibucket split in all instances when it
!		isn't absolutly clear which of the two split cases is taking 
!		place.
!
!	V02-016	TMK0002		Todd M. Katz	25-Jan-1982
!		Made multiple changes affecting bucket splitting of
!		index buckets. These changes affect all prologs, and both
!		compressed and noncompressed prolog 3 keys.
!
!		1. When the new key is to be inserted as the very first record 
!		   in the new (right) index bucket following an index bucket 
!		   split, the offset to the point of insertion, 
!		   IRAB[IRB$W_POS_INS], in the new bucket was not being 
!		   correctly computed. This was because the amount of front 
!		   compression of the new low order key is saved before it is
!		   uncompressed, and then added to the offset. This is correct 
!		   except when the new key to be inserted will become the very 
!		   first key in the new bucket, and thus preceed it. What RMS 
!		   will now do is move the records into the new bucket 
!		   regardless of where the new record will be inserted, extract
!		   the amount of front compression of the new low order key and
!		   uncompress it, zero the amount of front compression if the
!		   new key is to be inserted as the very first key in the new
!		   bucket, and then proceed to insert the new key.
!
!		2. The series of checks made before incrementing the pointer,
!		   IRAB[IRB$L_LST_NCOMP], to the last noncompressed key seen
!		   was not stringent enough. What must be checked is that
!		   the current position in the bucket, REC_ADDR, is less than
!		   the point of insertion, INS_PNT. What was being checked
!		   was whether the bucket scan had past the insertion point.
!		   Since REC_ADDR is incremented to the next key position
!		   and the pointer to the last noncompressed key seen adjusted
!		   before the check is made as to whether the current bucket
!		   position is also the point of insertion, it was possible
!		   for the last noncompressed key pointer to be incremented
!		   to the key which will follow the new key when the latter 
!		   is eventually inserted. If the new key, and the key which
!		   follows it (and is pointed at by the last noncompressed
!		   key pointer) share some common front characters, the front
!		   compression of the new key will be incorrect, and the index
!		   will be corrupted.
!
!		3. There was no code handling the situation when a prolog 3
!		   index bucket splits, and the point of insertion of the new 
!		   key(s) is at the split point. In this instance, changes
!		   must be made to both the old, and the new index bucket.
!		   More specifically, if a multibucket split occurs, a new
!		   key is inserted in both the old (as the high key) and the 
!		   new (as the low key) index buckets, and a VBN pointer in the
!		   new index bucket bucket must be swung from 
!		   IRAB[IRB$L_VBN_LEFT] (its value before the split occurred) 
!		   to IRAB[IRB$L_VBN_RIGHT]. If a nonmultibucket split occurs,
!		   a new key is inserted as the high order key in the old
!		   index bucket, and the same VBN pointer swing, described
!		   above, occurs. These changes are made by forcing prolog 3
!		   files to go through the same top-level code sequence as
!		   prolog 1 and 2 files, affecting must of the changes in
!		   lower level routines.
!
!		4. In those cases when there is a key to go in the old index
!		   bucket, and the point of insertion is at the point at 
!		   which the bucket was split, and empty buckets are involved,
!		   do not update the index, and instead return an alternate
!		   success status of index not updated. Previously, the
!		   multibucket split empty bucket case was handled exactly
!		   like this, and for the two-bucket split empty bucket case,
!		   a situation which should almost never happen, the existing 
!		   code for nonprolog 3 files did not handle it correctly, and
!		   there was no code for prolog 3 files.
!
!		5. It is possible for both the point of insertion and the
!		   the split point to be at the very first record in an index
!		   bucket. This will occur when the key size is such that it
!		   is possible for two index records to be in the same bucket,
!		   and a multibucket split has occurred requiring updating of
!		   such a bucket. In this case, we want to put both new keys
!		   in the old bucket, but still swing the VBN pointer of what
!		   will become the low order key in the new index bucket.
!		   The key updating is accomplished by lower routines which
!		   will notice that not only is IRAB[IRB$V_BIG_SPLIT] and
!		   IRAB[IRB$V_SPL_IDX] set but that the point of insertion
!		   is at the very first key position of the old index bucket.
!		   That just the VBN swing should be performed for this
!		   multibucket split case will be signalled by clearing
!		   IRAB[IRB$L_VBN_MID] if the point of insertion is at the
!		   very first key position. This is contrary to what normally
!		   would occur when a multibucket split has occurred and the
!		   point of insertion is also the split point.
!
!		6. Made two changes in the computation of the split point
!		   of a prolog 3 index bucket with noncompressed keys. First,
!		   if the point of insertion of the new index record(s) is the
!		   same as that of the split point, the new index record (at
!		   least one of them) will be put in the old bucket. Second,
!		   if the new index record is to go in the old bucket and 
!		   there is insufficient room, an additional record is moved
!		   out to make room only if the point of insertion and the 
!		   split point are not the same. If they are the same, this
!		   inability to fit both records must be do to a multibucket 
!		   split since all records are the same size and at least one
!		   has been moved out. In such a case one new index record
!		   will go in the old bucket, and the second in the new index 
!		   bucket, and so no action need be taken.
!
!		7. Made a change in the computation of the split point
!		   of a prolog 2 index bucket, SIDR bucket or prolog 3
!		   index bucket with compressed keys. Only if the new record
!		   is to go in the old bucket, and there appears to be
!		   insufficient room for it, and the split point and
!		   insertion points are not the same do we make more room by 
!		   moving out additional records. This can only occur for
!		   SIDR buckets. For index buckets there will always be
!		   sufficent room unless a multibucket split has occurred
!		   requiring the insertion of two new keys. But in such
!		   instances the bucket will be split at the insertion point
!		   and one key will end up in the old and the other in the
!		   new index bucket.
!
!	V02-015	TMK0001		Todd M. Katz	09-Jan-1982
!		Made two changes affecting bucket splitting of 
!		index buckets with compressed keys. 
!
!		1. In some cases when the key to be inserted was to
!		   go in the new (right) bucket, the pointer to the
!		   last noncompressed key, IRB$L_LST_NCOMP, pointed to
!		   a key preceeding the insertion point in what will 
!		   become the old (left) bucket. This resulted in the 
!		   incorrect determination of the amount of front
!		   compression of the new key, and corruption of the file.
!		   Update this pointer to the first key in the new bucket
!		   if it does not point to a key in the new bucket
!		   preceeding the insertion point.
!
!		2. The routine RM$RECORD_SIZE returns the length of the new
!		   index record to be inserted in two parts. The first word
!		   is the key size, and the second word of the longword
!		   is the VBN size. However, the routine COMP_SPL_PNT
!		   thought that only a single value was returned. Thus, when
!		   the split point of a index bucket with compressed keys
!		   was being determined, and the routine encountered in its
!		   scan of the the bucket the point of insertion and had to 
!		   take into account the size of the new record, the resulting
!		   incorrect use of the record size returned prevented the 
!		   proper determination of the split point. In fact the 
!		   incorrect use of the record size returned resulted in the 
!		   inability to correctly split an index bucket whenever the
!		   new key was to go in the old (left) side.
!
!	V02-014	PSK0006		P S Knibbe	14-Dec-1981
!		Change RECORD_SIZE to take BKT_ADDR as an input
!
!	V02-013	PSK0005		P S Knibbe	13-Nov-1981
!		Change COMP_SPL_PNT to keep track of last record
!		with no front compression and the SPL_COUNT for
!		compressed keys
!
!	V02-012	PSK0004		P S Knibbe	26-Oct-1981
!		Add support for splitting compressed buckets
!
!	V02-011 PSK0003		P S Knibbe	25-Oct-1981
!		Set the AP flags correctly when calling RM$RECORD_KEY
!
!	V02-010	PSK0002		P S Knibbe	07-Oct-1981
!		Make sure the ptr_sz from one bucket is correctly
!		moved into the new bucket when a split occurs.
!
!	V02-009	PSK0001		P S Knibbe	07-Aug-1981
!		Add support for prologue three indexes.
!
!	V02-008	CDS0071		C D Saether	26-Feb-1981	20:00
!		Return error on spl_idx, non-empty, big_split case.
!
!	V02-007	REFORMAT	R A SCHAEFER	23-Jul-1980	14:15
!		Reformat the source.
!
!	V02-006	CDS0070		C D SAETHER	14-JAN-1980	14:35
!		Fix splitting alternate data level when no dupes count
!		field present in record.  Use rm$rec_ovhd routine.
!
! REVISION HISTORY:
!
!   Wendy Koenig, 	12-OCT-78  14:46
!   X0002 - CHANGE THE NRP STUFF
!
!   Wendy Koenig, 	24-OCT-78  14:03
!   X0003 - MAKE CHANGES CAUSED BY SHARING CONVENTIONS
!
!   Wendy Koenig, 	3-NOV-78  11:35
!   X0004 - GET RID OF ROUTINE RM$ID_AND_NRP
!
!   Christian Saether, 	26-JAN-79  9:45
!   X0005 - don't split insert of index entries on empty bucket cases
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! define default psects for code
!

PSECT
    CODE = $$RMSSPLIT3(PSECT_ATTR),
    PLIT = $$RMSSPLIT3(PSECT_ATTR);

! Linkages
!

LINKAGE
    L_CNTRL_ADDR,
    L_COMPRESS_KEY,
    L_SPLIT_EM,
    L_INS_REC,
    L_ID_AND_NRP,
    L_REC_OVHD,
    L_RECORD_SIZE,
    L_RECORD_KEY,
    L_GETNEXT_REC,
    RL$SPL_PNT = JSB(REGISTER=1) : GLOBAL (R_IDX_DFN, R_IRAB, R_REC_ADDR, R_BKT_ADDR,R_IFAB),
    RL$EXT_HIGH = JSB() : GLOBAL (R_IDX_DFN, R_IFAB, R_IRAB, R_REC_ADDR),
    RL$MOVE_VBNS = JSB (Register = 0) : GLOBAL (R_IDX_DFN, R_IRAB, R_IFAB, R_REC_ADDR);


! External Routines
!

EXTERNAL ROUTINE
    RM$CNTRL_ADDR	: RL$CNTRL_ADDR,
    RM$COMPRESS_KEY	: RL$COMPRESS_KEY,
    RM$ID_AND_NRP	: RL$ID_AND_NRP,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$RECORD_KEY	: RL$RECORD_KEY,
    RM$RECORD_SIZE	: RL$RECORD_SIZE,
    RM$GETNEXT_REC	: RL$GETNEXT_REC,
    RM$INS_REC		: RL$INS_REC;

FORWARD ROUTINE
    COMP_SPL_PNT	: RL$SPL_PNT,
    EXT_HIGH_KEY	: RL$EXT_HIGH NOVALUE,
    MOVE_VBNS		: RL$MOVE_VBNS NOVALUE;

    MACRO 
	COMPR 	= 0,8,8,0 %,
	KEY_LEN	= 0,0,8,0 %;

GLOBAL ROUTINE RM$SPLIT_EM : RL$SPLIT_EM =

!++
!
! RM$SPLIT_EM
!
! Split the bucket in CURBDB into NXTBDB for SIDR data level and
! any index level as close to 50-50 as possible.  Records are moved
! into the new bucket, the new record is inserted where appropriate,
! and the NRP information is stored in the nrp list for updating later.
! Keybuffer 2 contains the high key value of the left hand bucket after
! splitting.  No buckets are actually written out in this routine, only
! the records are moved.
!
! CALLING SEQUENCE:
!	RM$SPLIT_EM()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!
!	IDX_DFN - pointer to index descriptor for this key of reference
!	    IDX$B_KEYSZ - size of key
!
!	REC_ADDR - point in bucket where new record is to be inserted
!
!	IRAB - pointer to internal rab structure
!	    IRB$V_REC_W_LO - 0 on input
!	    IRB$V_DUPS_SEEN - set if positioned after existing record to add
!				sidr array entry
!	    IRB$L_LST_REC - address of beginning of record previous to one
!			rec_addr is positioned to (used in conjunction with
!			irb$v_dups_seen)
!	    IRB$B_STOPLEVEL - level at which insert is being done (non-zero
!			if this is primary key only)
!	    IRB$L_CURBDB - bdb describing bucket to split (left hand bucket)
!	    IRB$L_NXTBDB - bdb describing bucket to split into (right hand)
!
!	IFAB - pointer to internal fab structure
!	    IFB$W_KBUFSZ - size of keybuffers
!
!	Routines called by this routine will reference additional fields in
!	the above structures.
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	keybuffer 2 (irb$l_keybuff + ifb$w_kbufsz) contains high 
!	value of left hand bucket.
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	All records in the original bucket described by IRB$L_CURBDB
!	and the new record are split between that bucket and the new
!	(empty) bucket described by IRB$L_NXTBDB.  Only when one record
!	occupies the entire bucket (curbdb) will a continuation record
!	be created, else the entire record will be moved to the new bucket.
!	The rm$id_and_nrp routine has been called to reassign the id's in
!	the new bucket and mark nrp entries which will be affected by the
!	split.  Nrp updates will be committed at a later time after the
!	new and original buckets have been written to disk.
!
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IDX_DFN_STR,
	R_REC_ADDR_STR,
	R_IRAB_STR,
	R_IFAB_STR;

    LOCAL
	EOB;

    BEGIN			! block to limit scope of following locals

    LOCAL
	INS_PNT;

    GLOBAL REGISTER
	R_BKT_ADDR_STR;

    BKT_ADDR = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];
    EOB = .BKT_ADDR + .BKT_ADDR [BKT$W_FREESPACE];

    ! First compute the split point
    !

    INS_PNT = .REC_ADDR;

    REC_ADDR = COMP_SPL_PNT(.INS_PNT);

    ! if the split point ended up exactly where we wanted to insert the record
    ! anyway we must investigate a little further
    !

    IF .REC_ADDR EQLA .INS_PNT
    THEN

	IF NOT .IRAB[IRB$V_REC_W_LO]
	THEN

	    IF  .BKT_ADDR[BKT$B_LEVEL] EQL 0
		AND
		.IRAB[IRB$V_DUPS_SEEN]
	    THEN

		IF .REC_ADDR NEQA .EOB

		    ! this is a continuation record being added to the end of
		    ! an existing record so keep it with the low set
		    !
		THEN
		    IRAB[IRB$V_REC_W_LO] = 1
		ELSE

		    ! we are trying to insert a continuation record at the end
		    ! of the bucket.  unless the existing record occupies the
		    ! entire bucket we will move the entire record into the new
		    ! bucket and add the continuation record there.
		    !
		    BEGIN

		    IF .IRAB[IRB$L_LST_REC] NEQA .BKT_ADDR + BKT$C_OVERHDSZ
		    THEN

			! we are going to back up the split point to the
			! beginning of this record so that we do not create a
			! continuation bucket, but force the whole thing
			! into the new bucket
			!
			BEGIN
			REC_ADDR = .IRAB[IRB$L_LST_REC];
			END
		    ELSE

			! the existing record that we are positioned at the end
			! of occupies the entire bucket, therefore (sigh), we
			! are forced to make the new record anew in the new
			! bucket, causing a continuation bucket.  This is the
			! only time we will ever create a continuation bucket
			! in the SIDR data level and it is done with great
			! reluctance. Clearing DUPS_SEEN will cause the record
			! size to be correct when it is recalculated later.
			!
			BEGIN
			IRAB[IRB$L_LST_REC] = .INS_PNT;
			IRAB[IRB$V_DUPS_SEEN] = 0;
			IRAB[IRB$V_CONT_BKT] = 1;
			END;

		    END;

    ! now set up things as offsets to simplify life later on
    !
    IRAB[IRB$W_POS_INS] = .INS_PNT - .BKT_ADDR;
    IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;

    ! adjust the freespace pointer for the old (left) bucket to reflect
    ! its new size
    !
    BKT_ADDR[BKT$W_FREESPACE] = .IRAB[IRB$W_SPLIT];
    IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] - .BKT_ADDR;
    END;				! of block defining INS_PNT, BKT_ADDR

    ! now we move everything beyond the split point into the new bucket
    ! without caring where the new record is going to go
    !
    BEGIN

    LOCAL
	COMPRESSION,
	NEW_BKT	: REF BBLOCK;

    NEW_BKT = .BBLOCK[.IRAB[IRB$L_NXTBDB], BDB$L_ADDR];
    NEW_BKT[BKT$W_FREESPACE] = .EOB - .REC_ADDR;

    COMPRESSION = 0;

    ! If there is anything at all to move into the new bucket, we know
    ! move it without any regard as to where the new index record(s) will
    ! be inserted.
    !
    IF .NEW_BKT[BKT$W_FREESPACE] NEQ 0
    THEN
	BEGIN

	LOCAL
	    REC_FROM	: REF BBLOCK,
	    REC_TO	: REF BBLOCK,
	    LENGTH;

	REC_FROM   = .REC_ADDR;
	REC_TO = .NEW_BKT + BKT$C_OVERHDSZ;
	LENGTH = .NEW_BKT[BKT$W_FREESPACE];

	! If this is a prolog 3 file with compressed keys, and if the key
	! which is to be the low order key in the new bucket is not zero
	! front compressed, we construct the contents of the new index bucket
	! in two steps. First, we move in the new low order key front expanding
	! and rear-end recompressing as required. Next, the remainder of the
	! bucket is moved.
	!
	IF .IDX_DFN [IDX$V_IDX_COMPR]
	   AND
	   (.REC_ADDR[COMPR] GTR 0)
	THEN
	    BEGIN
	    BUILTIN
		AP;
	    LOCAL
		NOT_USED,
		SAVE_LST_NCMP,
		SAVE_REC_ADDR;
	    GLOBAL REGISTER
		R_BKT_ADDR;

	    ! Move the key which is to be the low-order key in the new bucket
	    ! from its current position in the old (left) bucket to its
	    ! position as the first key in the new bucket leaving room
	    ! for the compression overhead bytes.
	    !
	    AP = 1;
	    RM$RECORD_KEY (.REC_TO + 2);

	    ! Determine the compression of the low-order key of the new bucket.
	    ! This key must be and will be zero-front compressed, but it will
	    ! be rear-end truncated if possible.
	    !
	    BKT_ADDR = .NEW_BKT;
	    SAVE_LST_NCMP = .IRAB[IRB$L_LST_NCMP];
	    IRAB[IRB$L_LST_NCMP] = .REC_TO;
	    SAVE_REC_ADDR = .REC_ADDR;
	    REC_ADDR = .REC_TO;

	    RM$COMPRESS_KEY (.REC_TO, .NOT_USED);

	    IRAB[IRB$L_LST_NCMP] = .SAVE_LST_NCMP;
	    REC_ADDR = .SAVE_REC_ADDR;

	    ! Adjust the freespace offset of the new bucket to reflect the
	    ! difference between the key size of the low-order key in its
	    ! new position (as low-order key of the new bucket), and the key
	    ! size of the low-order key in its old position (as a key somewhere
	    ! in the old bucket).
	    !
	    NEW_BKT[BKT$W_FREESPACE] = .NEW_BKT[BKT$W_FREESPACE] 
						- .REC_ADDR[KEY_LEN]
						+ .REC_TO[KEY_LEN];

	    ! If the new key is not to be inserted as the very first key in
	    ! the new bucket, then the difference between the low order key
	    ! (in its old position in the old bucket) and its new position
	    ! (as low order key of the new bucket) must be saved. It will be
	    ! used in recomputing the point of insertion of the new key(s)
	    ! to be inserted if it is to go in the new bucket. If the new
	    ! key is to be inserted as the very first key in the new bucket
	    ! then this difference is not taken into account in the
	    ! recomputation of the point of insertion.
	    !
	    IF .IRAB[IRB$W_POS_INS] NEQA .IRAB[IRB$W_SPLIT]
	    THEN 
		COMPRESSION = .REC_ADDR[KEY_LEN] - .REC_TO[KEY_LEN];

	    ! Having completed part 1 of the construction of the new bucket
	    ! (movement and recompression of the new bucket's low order key)
	    ! set up so that the remaining keys may be moved from the old
	    ! to the new bucket.
	    !
	    LENGTH = .LENGTH - .REC_ADDR[KEY_LEN] - 2;
	    REC_FROM = .REC_FROM + .REC_ADDR[KEY_LEN] + 2;
	    REC_TO = .REC_TO + .REC_TO[KEY_LEN] + 2;
	    END;

	! Move those keys remaining to be moved from the old to the new bucket.
	! Note that this may include the low order key of the new index bucket
	! (in those cases not requiring recomputation of the compression of the
	! new low order key), and will include the VBNs for non-prolog 3 files.
	!
	IF .LENGTH GTR 0
	THEN
	    CH$MOVE(.LENGTH,.REC_FROM,.REC_TO);
	END;

    NEW_BKT[BKT$W_FREESPACE] = .NEW_BKT[BKT$W_FREESPACE] + BKT$C_OVERHDSZ;

    ! See if we need to move the VBN chain, also
    !
    IF .IFAB [IFB$B_PLG_VER] GEQU PLG$C_VER_3
    THEN
	MOVE_VBNS(.NEW_BKT);

    ! if this is level 0 (SIDR data level) we must now reassign the ID's of the
    ! records we moved out and put information into the NRP list so that it can
    ! be updated later.
    !
    IF .NEW_BKT[BKT$B_LEVEL] EQL 0
    THEN
	RM$ID_AND_NRP(.NEW_BKT);

    ! now set up NEW_BKT and REC_ADDR to point to the buffer and position of
    ! insert for the new record
    !
    IF .IRAB[IRB$V_REC_W_LO]
    THEN

	! Since IRAB[IRB$V_REC_W_LO] is set, the new record will be inserted
	! into the old bucket.
	!
	BEGIN
	NEW_BKT = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];

	! If this is an index bucket split, and the point of insertion is
	! exactly the same as the split point, then not only must the new
	! record be inserted as the high order key of the old bucket, but
	! the key which is at the split point and will be moved into the new
	! index bucket must have its VBN pointer swung to point to the 
	! rightmost bucket. Also, if a multibucket split is taking place,
	! the second key is inserted into the new index bucket as its low 
	! order key.
	!
	IF  (.NEW_BKT[BKT$B_LEVEL] NEQ 0)
	    AND
	    (.IRAB[IRB$W_POS_INS] + .NEW_BKT EQLA .REC_ADDR)
	THEN
	    IF NOT .IRAB[IRB$V_EMPTY_BKT]
	    THEN
		
	    ! Empty bucket situations are POTENTIALLY handled differently
	    ! from nonempty bucket situations. Handle those two-bucket
	    ! and multibucket splits not involving empty buckets.
	    !
		BEGIN
		GLOBAL REGISTER R_BKT_ADDR;
		IRAB[IRB$V_SPL_IDX] = 1;

		! First, insert a new key and VBN pair as the high order key
		! in the old index bucket.
		!
		! There is one special case which is entirely handled by the
		! lower level routines. If only two keys fit in an index 
		! bucket, a multibucket split occurs, and both keys proceed
		! the lower order key, then both new keys must be put in
		! the old bucket instead of putting one in the old and the
		! other in the index bucket. 
		!
		BKT_ADDR = .NEW_BKT;

		IF NOT RM$INS_REC(.NEW_BKT, RM$RECORD_SIZE())
		THEN
		    BUG_CHECK;

		! Finally, insert all VBNs and keys required to go in the new
		! index bucket. This is done by clearing IRAB[IRB$L_VBN_LEFT]
		! as a signal that only a VBN should be swung, and in the
		! case of a multibucket split, only a single key and VBN pair
		! should be inserted into the new bucket.
		!
		IRAB[IRB$L_VBN_LEFT] = 0;
		IRAB[IRB$V_SPL_IDX] = 0;
		IRAB[IRB$L_REC_COUNT] = 0;
		NEW_BKT = .BBLOCK[.IRAB[IRB$L_NXTBDB], BDB$L_ADDR];

		! There is one special case, a multibucket split which requires
		! both keys to go into the old index bucket because both the 
		! insertion and split point are at the beginning of the old
		! bucket. Having finished updating the old bucket with two
		! keys and a VBN, that just the VBN pointer should be swung
		! is signalled by additionally clearing IRAB[IRB$L_VBN_MID].
		!
		IF (.IRAB[IRB$V_BIG_SPLIT]
		    AND
		   (.IRAB[IRB$W_POS_INS] EQLA BKT$C_OVERHDSZ))
		THEN IRAB[IRB$L_VBN_MID] = 0
		ELSE
		    BEGIN
		    IRAB[IRB$W_POS_INS] = BKT$C_OVERHDSZ;

		    ! If a multibucket split has taken place, and the second 
		    ! of the two new keys is to go into the new bucket, adjust 
		    ! the pointer to the last noncompressed key to the first 
		    ! key in the new bucket provided index compression is 
		    ! enabled.
		    !
		    IF .IRAB[IRB$V_BIG_SPLIT] AND .IDX_DFN[IDX$V_IDX_COMPR]
		    THEN IRAB[IRB$L_LST_NCMP] = .NEW_BKT + BKT$C_OVERHDSZ;
		    END;
		END			! Of BKT_ADDR definition

	    ! At the present time, do not handle those situations involving
	    ! empty buckets. Merely return alternate success indicating that
	    ! that the index was not updated.
	    !
	    ELSE RETURN RMSERR (BUG_XX3)

	END
    ELSE

	! if record goes into the new bucket then adjust the offsets so
	! that things come out right later
	!
	BEGIN

	LOCAL
	    TMP;

	TMP = .IRAB[IRB$W_SPLIT] - BKT$C_OVERHDSZ + .COMPRESSION;
	IRAB[IRB$W_POS_INS] = .IRAB[IRB$W_POS_INS] - .TMP;
	IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] - .TMP;

	IF .IFAB [IFB$B_PLG_VER] GEQU PLG$C_VER_3
	THEN
	    BEGIN
	    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT]
				      - .IRAB [IRB$L_SPL_COUNT];

	    ! If the record to be inserted is to go in the new bucket,
	    ! and the last noncompressed key remains in the old bucket,
	    ! or would follow the index record to be inserted, change this
	    ! pointer so that it points to the first key in the new bucket.
	    !
	    IF .IDX_DFN[IDX$V_IDX_COMPR]
	       AND	
	       NOT (.IRAB[IRB$L_LST_NCMP] GEQU .NEW_BKT 
		    AND
		    .IRAB[IRB$L_LST_NCMP] LSSU .NEW_BKT + .IRAB[IRB$W_POS_INS])
	    THEN IRAB[IRB$L_LST_NCMP] = .NEW_BKT + BKT$C_OVERHDSZ;
	    END;
		

	END;

    IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] + .NEW_BKT;
    REC_ADDR = .IRAB[IRB$W_POS_INS] + .NEW_BKT;

    ! call spread and insert appropriate record routine only possible error
    ! from this is a scarcity of ID's and that is a bug here
    !

    BEGIN

    GLOBAL REGISTER
	R_BKT_ADDR;

    BKT_ADDR = .NEW_BKT;

    IF NOT RM$INS_REC(.NEW_BKT, RM$RECORD_SIZE())
    THEN
	BUG_CHECK;

    END; ! Of bkt_addr definition

    END;

    ! position to last record in left bucket and put key into keybuffer 2
    ! for index update
    !
    EXT_HIGH_KEY();
    RMSSUC (SUC)
    END;

ROUTINE COMP_SPL_PNT (INS_PNT) : RL$SPL_PNT =
!+++
!
!    COMP_SPL_PNT
!
!	This routine returns the address at which the bucket should
!	be split.
!
!    INPUT
!
!	Address to insert the new record
!
!    IMPLICIT INPUT
!
!	IDX_DFN	
!	IRAB
!	BKT_ADDR
!
!    OUTPUT
!
!	SPL_PNT - Address of first record which should be in new bucket
!	IRAB [IRB$L_SPL_CNT] - Number of first VBN which should be in new bucket
!	IRAB [IRB$V_REC_W_LO] - Set if new record should go in left bucket
!	IRAB [IRB$L_LST_NCMP] - Address of last record with a front compressoin
!				count of zero (before insertion point)
!
!    IMPLICIT OUTPUT
!
!	none
!
!---

BEGIN

EXTERNAL REGISTER
    R_IDX_DFN_STR,
    R_IRAB_STR,
    R_REC_ADDR_STR,
    R_BKT_ADDR_STR,
    R_IFAB;

LOCAL
    SPL_PNT,		! Address of first record to go into right bucket
    EOB;		! Address of first free byte

MACRO
    KEY_SZ = 0,0,16,0 %,
    VBN_SZ = 0,16,16,0 %;

    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    EOB = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];

    IF .IDX_DFN [IDX$B_IDXBKTYP] EQLU IDX$C_NCMPIDX
    THEN

	! Prolog 3 non-compressed index record
	!
	BEGIN

	LOCAL
	    VBN_ADDR,
	    TEMP: BLOCK[1];

	TEMP = RM$RECORD_SIZE();

	! Compute the address of first record past the midpoint 
	!
	SPL_PNT = .REC_ADDR + 
			(((.EOB - .REC_ADDR) / 2) / .IDX_DFN [IDX$B_KEYSZ])
						  * .IDX_DFN [IDX$B_KEYSZ];

	! Get the address of VBN split point
	!
	BEGIN

	LOCAL
	    SAVE;

	IRAB [IRB$L_SPL_COUNT] = (.SPL_PNT - .REC_ADDR) / .IDX_DFN [IDX$B_KEYSZ];
	SAVE = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_SPL_COUNT];
	VBN_ADDR = RM$CNTRL_ADDR();
	IRAB [IRB$L_REC_COUNT] = .SAVE;
	END;

	IF .SPL_PNT GEQA .INS_PNT
	THEN

	    ! The new record will go into the left bucket.
	    !
	    BEGIN

	    IRAB [IRB$V_REC_W_LO] = 1;

	    ! If there is insufficient room in the old bucket for the index
	    ! records which must be inserted, and we are not at the insertion
	    ! point then move out one more record to make room. If we are at
	    ! the insertion point then there is insufficient room because
	    ! we are attempting to insert two keys into an index bucket where
	    ! there is only room for one. In such a case one key will go in
	    ! the old bucket, and another will go in the new index bucket.
	    ! 
	    ! REMEMBER: keys are fixed in size!!!
	    !
	    IF (.VBN_ADDR - .SPL_PNT) LSSU (.TEMP [KEY_SZ] + .TEMP [VBN_SZ])
	       AND
	       (.INS_PNT NEQA .SPL_PNT)
	    THEN

		! The records we are moving out don't leave enough room
		! Move one more
		!
		BEGIN
		SPL_PNT = .SPL_PNT - .IDX_DFN [IDX$B_KEYSZ];
		IRAB [IRB$L_SPL_COUNT] = .IRAB [IRB$L_SPL_COUNT] - 1;
		END;

	    END;

	END
    ELSE
	
	! Prologue two index or SIDR bucket
	! Prologue three compressed index or SIDR bucket
	!
	BEGIN

	LOCAL
	    SAVE_COUNT;

	SAVE_COUNT = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_LST_NCMP] = .REC_ADDR;

	IF .INS_PNT NEQ .EOB
	THEN
	    BEGIN					! of block scan

	    LOCAL
		NEW_REC_SZ,
		LRA;

	    !
	    ! Compute the hypothetical 50-50 split point based on the
	    ! current bucket freespace offset pointer
	    !

	    NEW_REC_SZ = 0;
	    SPL_PNT = (.EOB - .REC_ADDR)/2 + .REC_ADDR;
	    IRAB [IRB$L_REC_COUNT] = 0;

	    ! scan bucket until we get to the record past the split point 
	    ! calculated (if the new record is going to end up in the new
	    ! (right) bucket, or until the current position plus the size of
	    ! the new record to be inserted exceeds the split point (if the
	    ! new record is going to end up in the old (left) bucket.
	    !

	    DO BEGIN
		LRA = .REC_ADDR;

		! if our current position in the bucket scan matches the
		! point of insertion, then the new record will go into
		! the old (left) bucket. at this time the size of the new 
		! record is computed so its value maybe taken into account
		! in the determination of the split point. if the insertion
		! of the new record would not cross the split point, the 
		! bucket scan continues with the next record
		! 

		IF .REC_ADDR EQLA .INS_PNT
		THEN

		    IF .IRAB[IRB$V_REC_W_LO]
		    THEN
			RM$GETNEXT_REC()
		    ELSE
			BEGIN

			LOCAL
	    		    TEMP: BLOCK[1];

			! Obtain size of the new index record(s). This is a
			! single quantity in a non-prologue 3 file, but two
			! contigious words in a prologue 3 file. It is
			! assumed that the combined size is never greater
			! than what can be stored in a word.
			!
			TEMP = RM$RECORD_SIZE();
			NEW_REC_SZ = .TEMP[KEY_SZ] + .TEMP[VBN_SZ];
			IRAB[IRB$V_REC_W_LO] = 1;
			END
		ELSE
		    BEGIN
		    RM$GETNEXT_REC();

		    ! 
		    ! if index compression is turned on, and the front 
		    ! compression of the current record is zero, and we 
		    ! have not reached the insertion point, then update
		    ! the pointer to the last noncompressed record to
		    ! facilitate computation of the front compression
		    ! of the new record to be inserted.
		    !

		    IF .IDX_DFN [IDX$V_IDX_COMPR]
			AND .REC_ADDR [COMPR] EQL 0
			AND .REC_ADDR LSSA .INS_PNT
		    THEN
			IRAB [IRB$L_LST_NCMP] = .REC_ADDR;

		    END

	    END
	    UNTIL .REC_ADDR + .NEW_REC_SZ GTRA .SPL_PNT;

	    ! if the new record goes in the old bucket, make sure we are at 
	    ! least moving out enough records to make room for it. SIDRs and
	    ! index records must be separately considered.
	    !
	    ! In the case of SIDRs, it is guaranteed that the new record will 
	    ! be as small as possible, and if even one record is moved out of 
	    ! the old bucket there will be room for it. However, if a very
	    ! small record is to be added, the possibility exists that by the
	    ! time the bucket scanning loop is exited, there will be 
	    ! insufficient room for the new record. This is because while the 
	    ! small record size at the insertion point did not cause the split 
	    ! point to be exceeded, the very large record which follows did 
	    ! and if the split was made following the large record there would 
	    ! not be enough room in the old bucket for the new record. in this
	    ! instance we still want to put the new record in the old (left)
	    ! bucket, but we want to split at the point of inserting forcing
	    ! the following big record to go in the new (right) bucket.
            !
	    ! in the case of index records, if we are not at the insertion
	    ! point then there must be room for the new records in the old
	    ! bucket, otherwise, we would have exited the above loop while
	    ! at the insertion point. if we are at the insertion point and 
	    ! there isn't room to insert new index records this can only be
	    ! because there has been a multibucket split requiring two new
	    ! keys to be inserted. in such a case, one will go in the old
	    ! bucket, and the other in the new index bucket, so nothing 
	    ! further need be done.
	    !
	    IF .IRAB[IRB$V_REC_W_LO]
		AND
		(.EOB - .REC_ADDR) LSSU .NEW_REC_SZ
		AND
		(.REC_ADDR NEQA .INS_PNT)
	    THEN
		BEGIN
		REC_ADDR = .LRA;
		IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] - 1;
		END;

	    ! 
	    ! at this point, REC_ADDR is pointing to the place where we are
	    ! going to split.
	    !

	    SPL_PNT = .REC_ADDR;
	    END

	!
	! if the point of insertion is at the end of the free-space of the
	! bucket, then this is also where we will split
	!

	ELSE
	    SPL_PNT = .INS_PNT;

	IRAB [IRB$L_SPL_COUNT] = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_REC_COUNT] = .SAVE_COUNT;

	END;

    RETURN .SPL_PNT;
END;

ROUTINE MOVE_VBNS (NEW_BKT): RL$MOVE_VBNS NOVALUE =

!+++
!
!    MOVE_VBNS
!
!	This routine moves the VBNs starting with the one corresponding
!	to REC_COUNT into the new bucket.
!
!    INPUT
!
!	NEW_BKT - Address of new bucket
!
!    IMPLICIT INPUT
!
!	IDX_DFN
!	IRAB
!	IFAB
!	REC_ADDR
!
!    OUTPUT
!
!	none
!
!    IMPLICIT OUTPUT
!
!	tbs
!
!---

BEGIN

EXTERNAL REGISTER
    R_IDX_DFN_STR,
    R_IRAB_STR,
    R_IFAB,
    R_REC_ADDR;

GLOBAL REGISTER
    R_BKT_ADDR_STR;

MAP
    NEW_BKT : REF BBLOCK;

LOCAL
    OLD_FREE	: REF BBLOCK,	! Address of old buckets VBN free pointer
    NEW_FREE	: REF BBLOCk,	! Address of new buckets VBN free pointer
    BKTSZ,	! Number of bytes in these buckets
    NEW_END,	! Address of the new end of the old bucket's VBN chain
    OLD_END,	! Address of the old end of the old bucket's VBN chain
    SIZE,	! Number of bytes to move
    DEST_ADDR;	! Starting address of VBN chain in new bucket

! First compute the number of bytes to move
!

BKT_ADDR = .BBLOCK [.IRAB [IRB$L_CURBDB], BDB$L_ADDR];
BKTSZ = (IF .BKT_ADDR [BKT$B_LEVEL] GTRU 0
	 THEN
	   	.IDX_DFN [IDX$B_IDXBKTSZ]
	 ELSE
		.IDX_DFN [IDX$B_DATBKTSZ]);

BKTSZ = .BKTSZ * 512;
OLD_FREE = .BKT_ADDR + .BKTSZ - BKT$C_ENDOVHD;
NEW_FREE = .NEW_BKT + .BKTSZ - BKT$C_ENDOVHD;

! Now get the start and end of the VBN chain to move
!
BEGIN

LOCAL
   SAVE;

SAVE = .IRAB [IRB$L_REC_COUNT];
IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_SPL_COUNT];
NEW_END = RM$CNTRL_ADDR() + .BKT_ADDR [BKT$V_PTR_SZ] + 2;
IRAB [IRB$L_REC_COUNT] = .SAVE;
END;

OLD_END = .BKT_ADDR + .OLD_FREE [0,0,16,0];
SIZE = .NEW_END - .OLD_END;
OLD_FREE [0,0,16,0] = .OLD_FREE [0,0,16,0] + .SIZE - 1;

! Finally get the destination address
!

DEST_ADDR = .NEW_FREE;

IF .BKT_ADDR [BKT$B_LEVEL] EQLU 0
    AND .IDX_DFN [IDX$V_DUPKEYS]
THEN
    DEST_ADDR = .DEST_ADDR - 4;

DEST_ADDR = .DEST_ADDR - .SIZE;

CH$MOVE (.SIZE, .OLD_END, .DEST_ADDR);

NEW_FREE [0,0,16,0] = .DEST_ADDR - .NEW_BKT;

! Move the PTR_SZ from the old bucket to the new bucket
!
NEW_BKT [BKT$V_PTR_SZ] = .BKT_ADDR [BKT$V_PTR_SZ];

END;

ROUTINE EXT_HIGH_KEY : RL$EXT_HIGH NOVALUE =

!+++
!
!    EXT_HIGH_KEY
!
!	This routine extracts the high key from the bucket in curbdb
!	and places it in keybuffer 2.
!
!    INPUT
!
!	none
!
!    IMPLICIT INPUT
!
!	IDX_DFN
!	IFAB
!	IRAB
!	REC_ADDR
!
!    OUTPUT
!
!	key buffer two has high key value
!
!---
BEGIN

LOCAL
    EOB;

EXTERNAL REGISTER
    R_IDX_DFN_STR,
    R_IFAB_STR,
    R_IRAB_STR;

GLOBAL REGISTER
    R_REC_ADDR_STR;

REC_ADDR = .BBLOCK [ .IRAB[IRB$L_CURBDB], BDB$L_ADDR];
EOB = .REC_ADDR + .REC_ADDR [BKT$W_FREESPACE];
REC_ADDR = .REC_ADDR + BKT$C_OVERHDSZ;

CASE .IDX_DFN [IDX$B_IDXBKTYP] FROM IDX$C_V2_BKT TO IDX$C_NCMPIDX OF

SET
    [IDX$C_V2_BKT] :

	! Prologue two bucket
	!
	BEGIN

	LOCAL
	    SAV_LEV,
	    DATA_PTR;

	IF (SAV_LEV = .IRAB[IRB$B_STOPLEVEL]) EQLU 0
	THEN
	    SAV_LEV = .SAV_LEV - 1;		! signal alt. data level to rec_ovhd

	! NOTE - this assumes at least 1 record
	! is left in old (left) bucket.
	!
	DO
	    BEGIN

	    GLOBAL REGISTER
		R_REC_SIZE;

	    REC_SIZE = .SAV_LEV;
	    DATA_PTR = .REC_ADDR + RM$REC_OVHD();
	    REC_ADDR = .DATA_PTR + .REC_SIZE;
	    END
	WHILE .REC_ADDR LSSA .EOB;

	! move out key from record into key buff 2
	!
	CH$MOVE(.IDX_DFN[IDX$B_KEYSZ],
		.DATA_PTR,
	    	KEYBUF_ADDR(2));
	END;

    [IDX$C_CMPIDX]:

	! Prologue three bucket with compressed index
	!
	BEGIN

	LOCAL
	    SAVE;

	DO  BEGIN
	    SAVE = .REC_ADDR;
	    REC_ADDR = .REC_ADDR + .REC_ADDR [KEY_LEN] + 2;
	    END	
	WHILE .REC_ADDR LSSA .EOB;

	REC_ADDR = .SAVE;

	! Now move the key value for this record into keybuff2
	!
	IRAB [IRB$L_LST_NCMP] = .BBLOCK [.IRAB [IRB$L_CURBDB], BDB$L_ADDR] + BKT$C_OVERHDSZ;

	BEGIN

	BUILTIN AP;

	LOCAL
	    KEYBUFF2 : REF BBLOCK,
	    SAVE;

	KEYBUFF2 = KEYBUF_ADDR(2);
	SAVE = .AP;
	AP = 1;		! Signal an index bucket with compression
	RM$RECORD_KEY(.KEYBUFF2);
	AP = .SAVE;
	END;

	END;

    [IDX$C_NCMPIDX] :

	! Non-compressed indexes
	!
	BEGIN

	REC_ADDR = .EOB - .IDX_DFN [IDX$B_KEYSZ];
	CH$MOVE (.IDX_DFN [IDX$B_KEYSZ],
		 .REC_ADDR,
		 KEYBUF_ADDR(2));
	END;
TES;
END;	
	
END

ELUDOM
