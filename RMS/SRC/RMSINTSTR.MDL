;	$begin	rmsintstr,V03-003
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;	internal rms structure definitions
;
;	Modified By:
;
;	V03-003 MCN0008		Maria del C. Nasr	25-Mar-1982
;		Change KBUFSZ to a word instead of a byte.
;
;	V03-002	CDS0015		C Saether		22-Mar-1982
;		Add GBH$L_HI_VBN field.
;		Add IFB$B_DRT_REHIT, IFB$B_GBL_REHIT,
;		GBH$L_CROSS_HIT, GBD$W_LAST_ID, GBD$W_LST_LK_ID,
;		GBD$B_REHIT_RD, and GBD$B_REHIT_LK fields.
;
;	V03-001	CDS0014		C Saether		18-Feb-1982
;		Add GBPB$L_VBNSEQNO and GBD$V_VAL fields.
;
;	V02-084	KBT0005		K B Thompson		15-Feb-1982
;		Add IRB$W_NID_RIGHT, IRB$W_NID_MID and IRB$W_RFA_NID
;
;	V02-083	KEK0018		K. E. Kinnear		9-Feb-1982
;		Add FWA$C_MTMAXNAM and FWA$C_MTLNONTAP symbols for ANSI-"a"
;		filespec parsing.  Remove padding at end of first page.
;		Lengthen FWA$T_NAMEBUF from 19 to 36 bytes long.
;
;	V02-082	CDS0013		C Saether		 4-Feb-1982
;		Move IFB$W_GBC to be part of the record attributes.
;		Add IRB$L_RBF and IRB$W_RSZ fields.
;
;	V02-081	KPL0014		Peter Lieberwirth	20-Jan-1982
;		Shorten some names in RLB.
;
;	V02-080	CDS0012		C Saether		17-Jan-1982
;		Add IFB$W_GBC field to ifab.  Add GBH$L_GS_SIZE field.
;		Change GBH$L_TRACE_FLNK and BLNK to GBH$L_TRC_FLNK and BLNK,
;		and GBPB$B_CACHE_VAL to GBPB$B_CACHE_VL so names don't
;		exceed 15 characters.  Also shorten some TRC names.
;
;	V02-079	CDS0011		C Saether		 8-Jan-1982
;		Add GBD_START, GBD_END, GBD_NEXT, SCAN_NUM to GBH struct.
;		Add NUMB, remove IOSB, delete FLAGS defs, and shuffle
;		fields in GBD structure.
;		Delete FLGS defs in GBPB structure.
;		Add FWA$T_XLTBUFF3.
;
;	V02-078	CDS0010		C Saether		30-Dec-1981
;		Add NEXT_DOWN alias for VBN_MID irab field.
;		Move KEYSZ in irab to align longwords at end.
;
;	V02-077	CDS0009		C Saether		28-Dec-1981
;		Changes to TRC fields.
;
;	V02-076	CDS0008		C Saether		 9-Dec-1981
;		Add BADBLB and BADOWNER fatal bugcheck codes.
;		Add BLB$V_WRITEBACK flag.
;		Further modify TRC and GBH definitions.
;
;	V02-075	CDS0007		C Saether		 8-Dec-1981
;		Eliminate the READAHEAD CSH and BLB flag.
;
;	V02-074 JWH0001		Jeffrey W. Horn		03-Dec-1981
;		Move Directory BDB equivalences from RM0DIRSCN into BDB
;		MDL definition.
;
;	V02-073	KPL0013		Peter Lieberwirth	23-Nov-1981
;		Clean up some RLB commentary.
;
;	V02-072	TMK0015		Todd M. Katz		12-Nov-1981
;		Add bits IFB$V_RMS_STALL and IRB$V_RMS_STALL to the IFAB
;		and IRAB respectively. These bits are set within RM0STALL
;		and cleared after delivery of RMS's AST at RM$THREADGO either
;		because RMS must wait for an I/O operation to complete
;		before it can resume its thread, or because RMS must wait for
;		a file/record lock before it can continue. NOTE: if the user
;		requested an asynchronous operation, it is RMS which is stalled
;		and must wait before completing the operation, and not the user
;		who will be able to continue.
;
;	V02-071	RAS0045		Ron Schaefer		11-Nov-1981
;		Increase the FWA internal device buffer size to 63 chars
;		in order to handle concealed device names and add
;		FWA$T_SHRFILDEV field, making the FWA over 1 page.
;
;	V02-070	RAS0040		Ron Schaefer		26-Oct-1981
;		Implement rooted directories for concealed devices.
;		Add FWA$T_MFD_FID for the root directory's FID.
;		Add FWA$V_DFLT_MFD and FWA$V_ROOT_DIR flags.
;		Add 10-byte FWA$T_ROOT_DIR buffer for root directory string.
;
;	V02-069	CDS0006		C Saether		14-Oct-1981
;		Eliminate overlap of assigned device char and blb header.
;
;	V02-068	CDS0005		C Saether		 8-Oct-1981
;		Add all cache flags to BLB flags (specifically NOBUFFER).
;
;	V02-067	CDS0004		C Saether		 9-Sep-1981
;		Add IFB$L_GBH_PTR field.  Pad out GBH to quad align length.
;		Define trace block arguments.
;
;	V02-066	CDS0003		C Saether		31-Aug-1981
;		Make IFB$W_AVLCL and IFB$W_AVGBPB part of all ifabs.
;
;	V02-065	CDS0002		C Saether		19-Aug-1981
;		Extend length of FIB 4 bytes.
;
;	V02-064	CDS0001		C Saether		14-Aug-1981
;		Modifications to BDB structure:
;		1) Remove USECNT field
;		2) Add CACHE_VAL field
;		3) Add USERS field
;		4) Add BUFF_ID field
;		5) Rename OWN to BLB_PTR field
;		6) Remove LKDINWS flag.
;
;		Add GBPB structure.
;		Add RLS$V_DEQ flag to RLS flags.
;		Add IFB$L_BLBFLNK, IFB$L_BLBBLNK to IFAB.
;		Add IFB$W_AVGBPB, IFB$W_AVLCL to IFAB.
;		Add IRB$V_GBLBUFF to IRAB book keeping bits.
;		Add a series of new bugcheck codes for cache.
;		Add GBH, TRC, GBD, and BLB structures.
;
;		Remove RLS$V_KEEP_ACC flag.
;
;	V02-063	TMK0003		T M Katz		10-Aug-1981
;		Add FWA$T_WILD, a 16 byte scratch field for RM0WILD
;
;	V02-062	TMK0002		T M Katz		10-Aug-1981
;		Change MAXDIRLEN to 81 from 60.
;
;	V02-061	PSK0010		Paulina S. Knibbe	 8-Aug-1981
;		Remove all support for truncated index keys.
;		UKEY_ONLY, CTX block. Add IRB$L_SPL_COUNT to keep
;		track of the number of the record we are moving into
;		the next bucket on an INDEX or SIDR split.
;
;	V02-060	KPL0012		Peter Lieberwirth	 3-Aug-1981
;		Move list of RLBs to IRAB from IFAB.  This makes the
;		multistreaming code much easier.
;
;	V02-059	PSK0009		Paulina S. Knibbe	08-Jun-1981
;		1) Add UKEY_ONLY bit to say to update only the key in an
;		   index record. 
;		2) Add DIFF_CHAR to IRAB to keep track of
;		   which character distinguishes between two key values
;		3) Add CTX block to hold split context for 
;		   prologue three files
;
;		PSK0008		Paulina S. Knibbe	05-May-1981
;		Add LST_NCMP to IRAB to keep track of addr of last key with
;		no front compression.
;
;		MCN0007		Maria del C. Nasr	23-Apr-1981
;		Add record buffer in IRAB for prologue 3 files.
;
;		PSK0007		Paulina S. Knibbe	21-Apr-1981
;		Make sure IRAB is an even multiple of longwords
;
;		PSK0006		Paulina S. Knibbe	17-Apr-1981
;		Add bits to IDX to tell if data level record is 
;		compressed (REC_COMPR) or if the primary key
;		is compressed (KEY_COMPR). Remove constant for 
;		largest non-compressed key (this will be in FILSTR
;		and having it in two places asks for trouble).
;		Rework the bucket types.
;
;		PSK0005		Paulina S. Knibbe	06-Apr-1981
;		Add fields to IDX to tell which flavor of bucket is
;		used for the index and primary data buckets for this
;		key.
;
;		PSK0004		Paulina S. Knibbe	30-Mar-1981
;		Add flag to IDX to indicate that the key portion of
;		the index  and SIDR records are fixed or variable. 
;		(For prologue 3 files).
;
;		PSK0003		Paulina Knibbe		19-Mar-1981
;		Add REC_COUNT to IRAB so we can maintain it while
;		searching keys and use it while fetching VBN's
;
;		PSK0002		Paulina Knibbe		17-Mar-1981
;		Add constant for longest key not compressed
;
;		PSK0001		Paulina Knibbe		16-Mar-1981
;		Change the segment size to a byte length and
;		add segment datatype to IDX structure
;
;		MCN0006		Maria del C. Nasr	13-Mar-1981
;		Increase size of record identifier to a word in the
;		IRB, NRP, and RLB internal structures.
;
;	V02-058	KPL0011		Peter Lieberwirth	2-Jun-1981
;		Change RLB to add fields for lock manager interface.
;
;	V02-057	JAK0059		J A Krycka		15-Jun-1981
;		Remove symbols from the FWA that are no longer in use, namely:
;		FWA$B_FTYPSIZ, FWA$B_FVERSIZ, FWA$B_DMYPWDSIZ, FWA$C_DMYPWDSIZ.
;
;	V02-056	KRM0017		K R Malik		27-May-1981
;		Add FWA$B_FTYPSZ and FWA$B_FVERSIZ.
;
;	V02-055	KPL0007		Peter Lieberwirth	27-Apr-1981
;		Add a pointer to the SFSB (Shared File Synchronization
;		Block) in the IFAB
;
;	V02-054	kpl0002		Peter Lieberwirth	12-Jan-1981
;		add FTL codes ENQDEQFAIL and NOCURBDB to support new
;		record locking code
;
;	V02-053 ras0053		Ron Schaefer	24-Nov-1980	14:43
;		merge RMSINT and RMSIDXSTR internal structures into 
;		one file containing all
;		in-memory structures and no on-disk structures.
;
;	V02-052	REFORMAT	Keith B. Thompson	29-JUL-1980
;
;	V051	jak0045		J A Krycka	21-MAR-1980	15:00
;		remove IFB$V_DAP_FMODE.
;
;	V050	cds0075		C D Saether	21-JAN-1980	11:25
;		remove IFB$L_FWA_BDB, IFB$W_BKS_BYTES, IFB$W_BKS_RECS.
;
;	V049	ras0010		R A Schaefer	07-JAN-1980	16:45
;		re-arrange drc fields for valid did check.
;
;	V048	ras0009		R A Schaefer	20-DEC-1979	15:30
;		add FWA$T_RNM_FID to hold the saved fid from a rename
;		for checking bad rename directory operation.
;
;	V047	jak0029		J A Krycka	18-NOV-1979	11:00
;		add FWA$V_REMRESULT to denote that fal has returned resultant
;		string.
;
;	v046	tmh0003		Tim Halvorsen	02-NOV-1979
;		add FWA$L_DIRBDB to hold address of directory buffer bdb
;		add FWA$V_FILEFOUND bit to indicate that at least one file
;		has been found - used to return FNF vs. NMF.
;
;	V045	jak0025		J A Krycka	28-SEP-1979	17:00
;		add FWA$V_DEV_UNDER in conjunction with effort to
;		modify expanded and resultant name string processing to prefix
;		an underscore to node and device names that have been subject
;		to logical name translation.
;
;	V044			Tim Halvorsen	12-SEP-1979
;		add IFB$V_SEARCH bit to mark ifabs left during searches.
;
;	V043			Tim Halvorsen	11-SEP-1979
;		overlay the fib buffer with the node descriptors to reduce
;		the total space used by fwa.  increase the size of the file
;		name and type buffers due to the new maximum sizes which can
;		occur as a result of wild characters (i.e. *a*b*c*d*e etc).
;
;	V042	jak0023		J A Krycka	27-AUG-1979	18:00
;		move FWA$T_NODEBUF to NWA$T_NODEBUF and add FWA$Q_DIR1 thru
;		FWA$Q_DIR8 in conjunction with effort in RM0XPFN to allow
;		multiple node specs in a file specification.
;
;	v041	cds0022		C Saether	26-july-79	22:45
;		add IFB$V_SEQFIL to bookkeeping bits.
;
;	V040	cds0000		C Saether	16-JAN-1979	14:00
;		remove definition of lockabove from srchflags in irab
;		and add abovelckd to bookeeping bits
;
;	V039	wsk0000		W S Koenig	10-JAN-1979	1:25
;		fix problem w/ IDX_PTR overlapping w/ AS_DEV longwords
;
;	V038	jak0017		J A Krycka	28-DEC-1978	14:30
;		make IFB$L_NWA_PTR and IFB$L_FRB_PTR separate locations so that
;		networking and file sharing do not interfere with each other.
;
;	V037	ran0003		R A Newell	20-DEC-1978	17:35
;		file sharing and isam changes.
;
;	V036	jak0007		J A Krycka	17-DEC-1978	19:00
;		change values of FWA$C_MAXNODE and FWA$C_NODBUFSIZ.
;
;	V035	jak0006		J A Krycka	21-NOV-1978	16:40
;		add FWA$V_ACCSTR definition.
;
;	V034	ran0002		R A Newell	1-NOV-1978	09:49
;		RMS32 isam modifications.  additions of isam fields, take out
;		NWA, add PLG_VER, change ASB size, define PTR_VBN, update,
;		UPD_NRP, RFA_VBN, and RFA_ID fields.
;
;++

;
;	ifab field definitions
;
;  there is one ifab (internal file access block) per open file
;
	$STRUCT IFB

;+++++*****
;  the fields thru last_fab inclusive are common between the ifab and irab
;
	F ,Q		; device characteristic and bookkeeping bit vectors
	V <
	,32		; bookkeeping bits start in longword 2
			; (but have definitions that allow them to
			;  be referenced from the start of the ifab)
			;++
			;  the following bits are defined in
			;  common with the irab
			;
	  BUSY		; stream busy
	  EOF		; file positioned at eof
	  PPF_IMAGE	; flag for indirect processing of process-
			; permanent files (restricts allowable operations)
	  ASYNC		; async i/o flag (must be zero for ifab)
	  ASYNCWAIT	; wait on async i/o (must be zero for ifab)
			;--
			;
			;  ifab specific bits
			;
	  ACCESSED	; file is accessed
	  ANSI_D	; ansi d variable records
	  RWC		; copy of fop bit from open
	  DMO		; copy of fop bit from open
	  SPL		; copy of fop bit from open
	  SCF		; copy of fop bit from open
	  DLT		; copy of fop bit from open
	  DFW		; deferred write (copy of fop bit from $open)
	  SQO		; sequential operations only
	  PPF_INPUT	; this is command 'input' stream
	  NFS		; non-file structured flag
	  WRTACC	; logical or of fac bits:
			;   put, upd, del, trn
	  MSE		; multi-streams enabled
	  CREATE	; set if doing create (may be "create if")
	  NORECLK	; record locking not required
			; (i.e., no shared access or multi-stream)
	  RW_ATTR	; set if file attributes must be re-written
	  TMP		; temporary file (i.e., no directory entry)
	  TEF		; truncate at eof due to large auto extend
	  SIFB_OWND	; sifab owned by internal frb
	  SEQFIL	; this is really a sequential file being shared
	  SEARCH	; search ifab - left during wildcard operations
	  RMS_STALL	; RMS is stalled on this file operation
	  ,1		; spare
	  NWA		; network work area control block present
	  DAP_OPEN	; open/create function was performed via dap
	  DAP		; data access protocol transmission
	  NSP		; network services protocol transmission
	  >
	 S PRIM_DEV,0,L	; device characteristics bits
			; (for primary device - bit encoding same as for fab)
	 S BKPBITS,4,L	; bookkeeping bits
;
	F BID,B		; block id
	  C BID,11	; ifab id code
	F BLN,B		; block length in longwords
	F MODE,B	; caller's mode
	F EFN,B		; event flag used for synchronous qio
	F IOS,L		; internal i/o status block
	 S BWB,0,L	; bucket wait block for inter stream waiting
	 S IOS2,2,W	; high word of io status block
	F IOS4,L	; 2nd longword of io status block
	F ASBADDR,L	; address of asynchronous context block
	F ARGLST,L	; user call parameters addr
	F IRAB_LNK,L	; pointer to irab(s)
	F CHNL,W	; i/o channel number
	F FAC,B		; file access
	  V <M
	  PUT		; (same as in fab's fac field)
	  GET
	  DEL
	  UPD
	  TRN
	  BIO
	  BRO
	  EXE
	  >
			; note: if both bio and bro set, implies block i/o
			;	access only allowed for this connect, resets
			;	to bro on disconnect (seq. file org. only).
			;
	F ORGCASE,B	; copy of org for case dispatching
	F LAST_FAB,L	; address of fab for last operation
;-----*****
	F NWA_PTR,L	; pointer to network work area control block
	F FRB_PTR,L	; pointer to "shared" file resource block
	F BDB_FLNK,L	; pointer to bdb(s)
	F BDB_BLNK,L	; bdb backward link
	F DEVBUFSIZ,W	; device default (or bls if mt) buff size
	F RTDEQ,W	; run-time default extend quantity
;
;+++++*****
;
;  the following fields must remain as is since
;  they correspond to the rms attributes stored
;  in the file header
;
	F RFMORG,B	; organization and record format
	  V <
	  RFM,4		; record format
			; (n.b. constant values defined
			;  in rfm field of fab)
	  ORG,4		; file organization
	  >
	  C SEQ,0	; sequential
	  C REL,1	; relative
	  C IDX,2	; indexed
	  C DIR,3	; direct
	  C MAXORG,2	; release 1.5 maximum
	F RAT,B		; record attributes
			; (n.b. bit offsets defined in
			;  rat field of fab)
	F LRL,W		; longest record's length
			; (or fixed record length)
	F HBK,L		; hi vbn allocated
			; (note: reversed on disk!)
	F EBK,L		; eof vbn
			; (note: reversed on disk!)
	 S EBK0,0,W
	 S EBK2,2,W
	F FFB,W		; first free byte in eof block
	F BKS,B		; bucket size (# vbns)
	F FSZ,B		; record header size for vfc
	F MRS,W		; max record size allowable
	F DEQ,W		; default extend quantity
	F GBC,W		; global buffer count
	L FHAEND	; end of file header attributes
	F DRT_REHIT,B	; hit count for local dirty buffers.
	F GBL_REHIT,B	; rehit count for gbl buffers.
;-----*****
;++
;
	F NRP_LIST	; ptr to nrp list for idx files, temp for other orgs
	 S RNS_LEN,0,L	; resultant name string length
			; (used by $search)
	 S LOCK_BDB,0,L	; lock bdb address (used by $extend for rel. file)
	F SFSB_PTR,L	; pointer to shared file synchronization block
	F AVLCL,W	; Local buffers available.
	F AVGBPB,W	; Gbl ptr blocks available.
	F GBH_PTR,L	; Pointer to global header.
	F AS_DEV,L	; assigned device characteristics
	F ,W		; (spare)
	F ASDEVBSIZ,W	; assigned device buffer size
	F BLBFLNK,L	; Forward link to BLB chain.
	F BLBBLNK,L	; Back link to BLB chain.
	L BLN_SEQ
	M 1
;--
;
;  organization-dependent fields
;
;  the following fields are used differently
;  depending upon the file's organization
;
;++
;
;  relative org specific fields
;
	P 1
	F MRN,L		; (rel) max record number
	F DVBN,L	; (rel) first data bucket vbn
	L BLN_REL
;--

;++
;
;  indexed org specific fields
;
	P 1
	F IDX_PTR,L	; (idx) pointer to primary key index descriptor
	F AVBN,B	; (idx) vbn of 1st area descriptor
	F AMAX,B	; (idx) total number of area descriptors
	F NUM_KEYS,B	; (idx) # of keys in file
	F UBUFSZ,B	; (idx) update buffer size for keys
	F KBUFSZ,W	; (idx) key buffer size
	F EXTRABUF,B	; (idx) number of extra buffers for 'cache'ing
	F PLG_VER,B	; (idx) prologue version number
	L BLN_IDX
;--
	L BLN		; ifab length
	E

;
;	 irab field definitions
;
;  there is 1 irab per connected record access stream
;
	$STRUCT IRB		; internal rab

;+++++*****
;
;  the fields thru last_rab inclusive are common between the irab and ifab
;
	F ,Q		; used to get bookkeeping bit definitions
			; to apply from start of irab
	V <
	,32		; bookkeeping bits start in longword 2
			;++
			;
			;  the following bits are defined in common
			;  with the ifab
			;
	  BUSY		; file busy
	  EOF		; stream positioned at eof
	  PPF_IMAGE	; flag for indirect processing of process-
			; permanent file
	  ASYNC		; asynchronous i/o request
	  ASYNCWAIT	; $wait issued for asynchronous i/o request
			;--
			;
			;   irab specific bits
			;
	  FIND_LAST	; last operation was a find
	  PUTS_LAST	; last operation was a put sequential
	  BIO_LAST	; this/last operation is/was a block i/o operation
			; note: this bit is set only if mixed block and record
			;       operations (bro access).  after call to rm$rset
			;	refers to the current operation and bro_sw gives
			;	type of last operation.
	  BRO_SW	; switched from record operation to block i/o operation
	  FIND		; operation is a find
	  RAHWBH	; read ahead or write behind processing
	  SKIP_NEXT	; skip to next record flag for index fo
	  DUP		; duplicate records seen
	  UNLOCK_RP	; release lock on current (rp) record
	  PPF_EOF	; give one-shot rms$_eof error on sys$input
	  PPF_SKIP	; skip sys$input record ($deck), redoing $get
			; or $find on next record
	  PPF_FNDSV	; save value for find bit when ppf_skip set
	  IDX_ERR	; index update error occurred
	  RRV_ERR	; rrv update error occurred
	  UPDATE	; operation is an update (indexed)
	  UPD_NRP	; an nrp update is necessary (indexed)
	  ABOVELCKD	; level above was locked by search_tree
	  GBLBUFF	; global buffers are in use.
	  ,3		; spare bits
	  RMS_STALL	; RMS is stalled on this record operation
	  ,3		; spare bits
	  DAP_CONN	; connect function was performed via dap
	  ,1		; spare bit
	  >
;
;  the following are alternate definitions for alternate
;  (non-conflicting) use of the above bits
;
	  V <
	  ,41		; start re-use with find
	  WRITE		; operation is a write
	  >
	 S IFAB_LNK,0,L	; pointer to ifab
	 S BKPBITS,4,L	; bookkeeping status bits
;
	F BID,B		; block id
	  C BID,10	; irab code
	F BLN,B		; block length in longwords
	F MODE,B	; caller's mode
	F EFN,B		; event flag for synchronous io
	F IOS,L		; internal i/o status block
	 S BWB,0,L	; bucket wait block for inter stream locking
	 S IOS2,2,W	; high word of io status block
	F IOS4,L	; io status block (2nd longword)
	F ASBADDR,L	; address of permanent asynchronous context block
	F ARGLST,L	; user arg list address
			; if async, points to copy at head
			; of async context block
	F IRAB_LNK,L	; pointer to next irab
	F CURBDB,L	; current bdb address
	F LAST_RAB,L	; address of rab for last operation
;-----*****
	F RLB_LNK,L	; pointer to RLBs
	F NXTBDB,L	; next bdb address
	F NRP_PTR,L	; pointer to cell in nrp list  (indexed)
	 S NRP_VBN,0,L	; next record pointer  (relative)
	 S NRP,0,L	; next record pointer (relative record #)
	F NRP_OFF,L	; next record pointer offset (relative)
	 S NRP_OFF,0,W	;     "
	 S CURVBN,0,L	; vbn of current record (relative)
	 S CACHEFLGS,0,B ; cacheflags for calls to getbkt,cache, etc. (indexed)
	 S NRP_KREF,1,B	; key of reference  (indexed)
	 S RP_KREF,2,B	; key of reference for rp  (indexed)
	 S SPL_BITS,3,B	; bits for splitting  (indexed)
	  V<M
	    BKT_NO_LO	; low bit of bucket number processing
	    NEW_BKTS,2	; number of new buckets (0-3)
	    REC_W_LO	; if splitting at pos_insert than rec goes w/ lo
	    CONT_BKT	; middle bucket is a continuation bkt
	    CONT_R	; right bucket is a continuation bkt
	    EMPTY_BKT	; bucket contains no data records
	    DUPS_SEEN	; dups seen on scan of bucket, any key
	   >
	 S ,3,B		; redefine bits
	  V<M
	    BKT_NO,2
	    BIG_SPLIT
	   >
	 S ,3,B
	  V<M
	    SPL_IDX	; split up new index record and swing pointer
	    EMPT_SEEN	; empty bucket passed over on posinsert
	   >
	F RP,L		; record pointer  (relative record #)
	 S RP_VBN,0,L	; record pointer  (relative)
	 S POS_INS,0,W	; offset for position for insert for put  (indexed)
	 S SPLIT,2,W	; first split point  (indexed)
	F RP_OFF,L	; record pointer offset
	 S LST_REC,0,L	; last record address  (indexed)
	 S PTR_VBN,0,L	; pointer vbn used by find_by_rrv (indexed)
	 S RP_OFF,0,W	; record pointer offset
	 S SPLIT_1,0,W	; second split point -- 3-bkt split  (indexed)
	 S SPLIT_2,2,W	; third split point -- 4-bkt split  (indexed)
	F OWNER_ID,L	; owner id used for record locks
	  S OWN_ID,0,W	; index part of process id (pid)
	  S OWN_ISI,2,W	; isi value for this irab
	  S PPF_ISI,2,B	; isi value for this process-permanent irab
	F BCNT,B	; i/o buffer count
	F MBC,B		; multi-block count
	F RSZ,W		; record size from user
	F RBF,L		; user record buffer address
;++
;
;  start of organization dependent fields
;
	M 1
;++
;
; used by sequential and relative files
;
	F ,W		; pad so longwords align
	F CSIZ,W	; current record size (seq)

	M 2
;++
;
;  sequential org specific fields
;
	F TEMP0,L
	 S ROVHDSZ,0,W	; overhead size for record
	 S PRE_CCTL,0,B	; 'pre' carriage control
	 S POST_CCTL,1,B ; 'post' carriage control
	 S RTOTLSZ,2,W	; total size for record
	F TEMP1,L
	 S NVBNS,0,B	; number of vbns transferred (nxtblk1)
	L BLN_SEQ
;++
;
;  relative org specific fields
;
	P 2

	L BLN_REL
;
; indexed org specific fields
;
	P 1
	F KEYBUF,L	; address of internal key buffer & update buffer
	F UPDBUF,L	; address of internal update buffer
	F RECBUF,L	; address of internal record buffer (plg 3)
	F RFA_VBN,L	; rfa vbn for search nrp data
	 S UPD_BDB,0,L	; save current bdb during insert operation
	 S LAST_VBN,0,L	; last vbn at data level for update
	F RFA_ID,W	; save id for search nrp data (plg 3)
	 S LAST_ID,0,W	; id for udr during update (plg 3)
	F SAVE_POS,W	; saved duplicate position for search nrp data
	F LOCK_BDB,L	; lock bdb addr of level below on splits
	F VBN_LEFT	; left vbn of split
	 S MIDX_TMP1	; temporary one for make index
	F VBN_RIGHT	; right vbn of split
	 S MIDX_TMP2	; temporary two for make index
	F VBN_MID	; middle vbn of split
	 S MIDX_TMP3	; temporary three for make index
	 S NEXT_DOWN,0,L ; used by search_tree
	F STOPLEVEL,B	; level to stop at on tree search
	F SRCHFLAGS,B	; search flags
	 V<M
	 POSINSERT	; position for insert
	 SRCHGT		; approximate search gt
	 POSDELETE	; position for delete
	 NEW_IDX	; need to read in new idx dsc from file
	 SRCHGE		; approximate search ge
	 NORLS_RNF	; don't release bkt on rnf error, if set
	 FIRST_TIM	; flag to indicate 1st time for seq. processing
	 PRM		; flag to indicate that the permanence bit in the bdb
			;  should be set
	  >
	F KEYSZ,B	; size of key in keybuffer #2
	F DIFF_CHAR,B	; number of the character in the search key which
			;  differs from the record it is compared against(plg3)
	F REC_COUNT,L	; number of current record in this bucket (plg 3)
	F LST_NCMP,L	; address of last key with zero front compression (plg 3)
	F SPL_COUNT,L	; number of the first record to be moved into new bucket
			;  when splitting indexes and SIDRs
	F NID_RIGHT,W	; Next record ID of the right bucket
	F NID_MID,W	; Next record ID of the middle bucket
	F RFA_NID,W	; Next record ID of the RFA bucket
	F ,W		; Spare
	L BLN_IDX
	E

;
;  asynchronous operations require that an irab have
;  an asynchronous context block (asb)
;  the asb is pointed to by the arglst field of the
;  irab if the async bookkeeping bit is set
;
;  the first four longwords are used to save the
;  caller's argument list
;
	$STRUCT ASB

	F ARGCNT,B	; argument count
			; value will be 0, 1, 2, or 3
	F BLN,B		; block length in longwords
	F STKSIZ,B	; size of saved stack in bytes
	F ,B		; spare
	F FABRAB,L	; fab or rab address
	F ERR,L		; err routine addr
	F SUC,L		; suc routine addr
	F REGS,L,40	; work space for register and stack save
			; (regs 6,7,8,10,11 - r4,r5 saved on stack)
	L BLN_FAB	; block length for fab-related operations
	L BLN_SEQ	; block length for seq org irab operations
	F ,L,1		; additional space for relative org
	L BLN_REL	; block length for rel org irab operations
	F ,L,20		; additional space for indexed org
	L BLN_IDX
	E

;
;	 file work area definitions
;
;  the file work area is used for expanding the file
;  name string and setting up the various parameter
;  blocks for interfacing with f11acp
;
	$STRUCT	FWA

	F FLAGS,Q	; various parse status flags
	V <
	DUPOK,,,M	; discard duplicate element
	NAMEFLG,,,M	; name seen this parse
	TYPEFLG,,,M	; type seen this parse
	RLF_PASS,,,M	; set if applying related file defaults
	FNA_PASS,,,M	; set if primary name string parse pass
	NAM_DVI,,,M	; set if open by name block
	CUR_VER		; set if cur file has wc ver
	,1		; spare
	>		; (end of passflgs byte)
	V <
	,8		; start defs at byte 1
	,3		; must be zero
	VERSION,,,M	; set if version seen
	TYPE,,,M	; set if type seen
	NAME,,,M	; set if name seen
	DIR,,,M		; set if directory spec seen
	DEVICE,,,M	; set if device seen
			; (end of fldflgs byte)
	EXP_VER,,,M	; set if explicit version
	EXP_TYPE,,,M	; set if explicit type
	EXP_NAME,,,M	; set if explicit name
	WC_VER		; set if wildcard (*) version
	WC_TYPE		;          "		type
	WC_NAME		;	   "		name
	EXP_DIR,,,M	; set if explicit directory
	EXP_DEV,,,M	; set if explicit device
			; (end of wildflgs byte)
	WILDCARD	; set if any wildcard seen
	NODE		; set if node name seen
	QUOTED		; set is quoted string seen
			; (valid only if node set and no fldflgs)
	GRPMBR		; set if directory in [grp,mbr] format
	WILD_DIR	; inclusive or of directory wild cards
	DIR_LVLS,3	; # of directory sublevels (0 = ufd only)
			; (end of parseflgs byte)
	>
	V <
	,32		; continue bit definitions of 2nd longword
	DIR1		; ufd level directory or group seen
	DIR2		; sfd level 1 directory or member seen
	,6		; additional sub directory level flags
			; (end of dirflgs byte)
	WILD_UFD	; the dir1 spec was a wild card
	WILD_SFD1	; the dir2 spec was a wild card
	,6		; additional sub directory wildcard flags
			; (end of dirwcflgs byte)
	LOGNAME		; a logical name has been seen this pass
			; (note: this byte is saved as context
			; when processing [.dir-list] format)
	OBJTYPE		; set if quoted string is of the 
			; "objecttype=..." form
			; (valid only if quoted set)
	NETSTR		; set if quoted string is of the
			; "objecttype=taskname/..." form
			; (valid only if quoted and objtype set)
	DEV_UNDER	; device name was prefixed with an underscore
	FILEFOUND	; true if at least one file found by parse/search
	REMRESULT	; use resultant string returned by fal
	DFLT_MFD	; default MFD string inserted, due to [-]
	ROOT_DIR	; root directory present due to concealed device
			; (end of lnflg byte)
	>
	V <
	,40		; alternate definition for dir1 and dir2
	WILD_GRP	; the grp spec contained a wild card
	WILD_MBR	; the mbr spec contained a wild card
	>
	S PASSFLGS,0,B	; flags for pass only
	S FLDFLGS,,B	; flags for fields seen
	S WILDFLGS,,B	; flags for wild cards
	S PARSEFLGS,,B	; flags for parse results
	S DIRFLGS,,B	; flags primarily for directory spec
	S DIRWCFLGS,,B	; directory wild flags
	S LNFLG,,B	; logical name flag byte
	S DIRTERM,,B	; directory spec terminator (']' or '>')
			; (note: this byte must follow the lnflg byte)
	C ALL,<<FWA$M_DEVICE!FWA$M_DIR!FWA$M_NAME!FWA$M_TYPE!FWA$M_VERSION>@-8>
			; value for all filename elements except node
;
	F ESCSTRING,L	; escape equivalence string
	S ESCFLG,,B	; set to the char <esc> if an escape string
			; seen, zero otherwise
	S ESCTYP,,B	; escape 'type' byte
	M 1
	S ESCIFI,,W	; escape ifi value
;
	P 1
			; temporary usage of the escifi field
			; for logical name translation
	S XLTMODE,,B	; mode of equivalence string
	S XLTTBL,,B	; table of equivalence string
	F XLTBUF1,Q	; primary translation buffer discriptor
	S FIB,,Q	; re-use for fib descriptor
	F BUFFLG,L	; flag for which buffer in use
			; (0 = buf2 in use, -1 = buf1 in use)
	S DIRBDB,,L	; re-use as address of directory file bdb
			; since bufflg never used in search-type fwa's
	F XLTSIZ,L	; length of equivalence string
	S FNAMSIZ,0,W	; file name size (without type and version)
			; after exit from xpfn
	F LOGNAME,Q	; logical name descriptor
	S UIC,0,L	; file owner uic
	S LOOKUP,0,L	; address of new directory cache node
	S DEVNODADR,4,L	; address of device directory cache node
	S PRO,4,W	; file protection word
	F XLTBUF2,Q	; secondary translation buffer descriptor
	S DIR,,Q	; directory name scratch buffer
	F XLTCNT,L	; number of translations done
	S UCHAR,,W	; reuse to receive user characteristics (long)word
	F DIRLEN,B	; overall directory spec length
	F SUBNODCNT,B	; number of secondary (sub) node specs found
	F ,B,2		; spare
	F BUF_PTR,L	; address of temporary buffer
;
;  descriptors for parsed filename elements
;
;******++++++
;  the following descriptors must be contiguous.
	F NODE,Q		; node name (actually node spec list) descriptor
				; (the associated buffer is nwa$t_nodebuf)
	  C MAXNODNAM,6		; max node name size
	  C MAXLNDNAM,15	; max logical node name size
	  C MAXNODLST,127	; max node spec list size (concatenated node specs)
	F DEVICE,Q		; device name descriptor
	  C MAXDEVICE,63	; max device name size
	F DIR1,Q		; directory and subdirectory descriptors
	F DIR2,Q		; (note: only 1 and 2 explicitly named)
	F ,Q			;
	F ,Q			;
	F ,Q			;
	F ,Q			;
	F ,Q			;
	F ,Q			;
	  C MAXSUBDIR,7		; max number of sub directories
	  C MAXDIRLEN,81	; max size of total directory spec
	F NAME,Q		; file name descriptor
	  C MAXNAME,9		; max file name size
	  C MTMAXNAME,36	; max file name size for ANSI-"a" name strings
	  C MTLNONTAP,17	; length of file names on tape
	F TYPE,Q		; file type descriptor
	S RNS,,Q		; re-use as resultant name string descriptor
	  C MAXTYPE,3		; max file type size
	  C RNSBUFSIZ,20	; *unused in RMS* max resultant name string size
	M 2
	F VERSION,Q		; file version descriptor
	  C MAXVER,6		; maximum version
	F QUOTED,Q		; quoted string descriptor
				; (the associated buffer is nwa$t_quotedbuf)
	  C MAXQUOTED,127	; max quoted string size
	M 3
	P 2
	F STATBLK,T,10		;
	  C STATBLK,10		; define length of statistics block
	  S SBN,0,L		; starting lbn if contiguous
	  S HBK,4,L		; high vbn
	F ,B,6			; spares (mapping over quoted)
;******------
	P 3			; (note: this does not position properly
				; unless 'f ,b,6' spares are defined above)
;******++++++
;  the following descriptors must be contiguous.
	F NODE1,Q		; primary node spec descriptor
				; (the associated buffer is nwa$t_nodebuf)
	F ,Q			; secondary (sub) node spec descriptors (1-7)
	F ,Q			; note: bytes 2-3 of each of these descriptors
	F ,Q			;	contains the flags word that is output
	F ,Q			;	from nxtfld subroutine in rm0xpfn
	F ,Q			; note:	fwa$q_node1 thru 'fwa$q_node8'
	F ,Q			;	describe the same string as does
	F ,Q			;	fwa$q_node
	  C MAXSUBNOD,7		; max number of secondary (sub) node specs
	M 4
;******------
	P 3			; overlay with node descriptors
	F FIBBUF,T,48		; fib buffer
	  C FIBLEN,48		; fib buffer size
	F RNM_FID,T,6		; saved fid for rename directory check
	F MFD_FID,T,6		; saved fid for root directory
	F ,B,4			; pad to same length as node descriptors
	P 4			; end of overlay
;
;  directory name buffers
;
	F DIR1BUF,T,9		; ufd level (or group)
	F DIR2BUF,T,9		; 1st sfd level (or member)
	F ,T,54			; additional subdirectory levels
	  C DIRBUFSIZ,9		; size of each directory buffer
;******++++++
;  the following buffers must be contiguous as eventually the
;  type and version are appended to the name string
	F NAMEBUF,T,36		; file name buffer (also used for resultant name)
	  C NAMBUFSIZ,36 	; file name buffer size
	F TYPEBUF,T,7		; file type buffer
	  C TYPBUFSIZ,7		; file type buffer size
	F VERBUF,T,6		; file version buffer
	  C VERBUFSIZ,6		; file version buffer size
;******------
	F UNDERLINE,B		; single character '_' stored here to prevent
				; additional logical name translation
	F DEVICEBUF,T,63	; device name buffer
	  C DEVBUFSIZ,63	; device name buffer size
	F WILD,T,16		; scratch field used by RM0WILD
	  C WILDSIZ,16		; scratch field size	  
	F SHRFILDEV,T,16	; shared file device id
	F ROOT_DIR,T,10		; ASCIC root directory string
	F ATR_LIST,T,128	; attribute list work area
	S XLTBUFF1,0,T,64	; scratch translation buffer
				; (also used for attribute list area in rm$access)
	S DIB,16,T,112		; device information block
	S XLTBUFF2,64,T,64	; scratch translation buffer
				; (also used for directory processing in rm$setdid
				;  and attribute list area in rm$access)
	  C XLTBUFSIZ,63	; scratch translation buffer size
	F XLTBUFF3,T,64		; scratch translation buffer 3!
	L BLN			; length of this control block
	E

;
;	 bdb field definitions
;
;  buffer descriptor block (bdb)
;
;  there is one bdb per i/o buffer
;  ( the i/o buffers exist in separate pages, page aligned)
;
	$STRUCT BDB

	F FLINK,L	; forward link
	F BLINK,L	; backward link
	F BID,B		; block id
	  C BID,12	; bdb id code
	F BLN,B		; block length in longwords
	F FLGS,B	; bdb flags
	  V <M
	  VAL		; buffer contents valid
	  DRT		; buffer content dirty
	  IOP		; buffer has i/o in progress
	  PRM		; buffer has permanence factor
	  NOLOCATE	; buffer shared - no locate mode
			; (set/cleared by rm$cache)
	  WFO		; other streams awaiting
			; the releasing of this bdb
	  AST_DCL	; ast has been declared for
			; waiting stream
	  >
	F CACHE_VAL,B	; relative value of buffer in cache
	S VERTYP,,B	; version type (1 = wild)
	F USERS,W	; number of streams referencing this buffer
	F BUFF_ID,W	; buffer identification number
	F BLB_PTR,L	; pointer to BLB chain for this BDB
	F NUMB,W	; # of bytes of buffer in use
	S DIRSEQ,,W	; UCB$W_DIRSEQ at directory read time
	F SIZE,W	; # bytes in buffer
	F ADDR,L	; address of buffer
	F VBN,L		; 1st vbn in buffer
	F VBNSEQNO,L	; vbn seq number of validity check vs. bcb copy
	S LAST,,L	; address of last directory record
	F WAIT,L	; wait thread (irab addr)
			; (for inter-stream intra-
			;  process locking only)
	S VERCOUNT,,L	; negative count of version entries scanned
	M 1
	F WK1,L		; work area 
	S REL_VBN,0,B	; current vbn rel to start of buffer
	S VAL_VBNS,,B	; # of valid vbns in buffer
	S PRE_CCTL,,B	; unit record carriage control byte ('pre')
	S POST_CCTL,,B	; unit record carriage control byte ('post')
	F CURBUFADR,L	; current buffer addr
	P 1		; re-use for i/o status block
	F IOSB,L,2	; i/o status block for buffer
	S VERSION,,L	; addr of current/next directory version entry
	S RECORD,,L	; address of current/next directory record
	L BLN		; length of bdb block
	E

;
;	GBPB field definitions
;
; Global Buffer Pointer Block (GBPB)
;
; The GBPB is the process local structure used in conjunction with
; shared global i/o buffers.  In order to minimize the impact of
; global buffers on existing code, the GBPB is identical to a BDB
; in those fields which are referenced outside of the RM$CACHE and
; RM$RELEASE routines.
;
	$STRUCT GBPB

	F FLINK,L	; forward link
	F BLINK,L	; backward link
	F BID,B		; block id
	  C BID,21	; gbpb id code
	F BLN,B		; block length in longwords
	F FLGS,B	; gbpb flags (use BDB flgs definitions)
	F CACHE_VL,B	; relative cache value of this buffer
	F USERS,W	; number of streams referencing this buffer
	F BUFF_ID,W	; buffer identification number
	F BLB_PTR,L	; pointer to BLB chain for this GBPB
	F NUMB,W	; # of bytes of buffer in use
	F SIZE,W	; # bytes in buffer
	F ADDR,L	; address of buffer
	F VBN,L		; 1st vbn in buffer
	F VBNSEQNO,L	; sequence number field.
	F GBD_PTR,L	; Pointer to the GBD for this buffer.
	L BLN		; Length of GBPB block
	E


;
;	rlb field definitions
;
;  record lock block (rlb)
;
;  the rlb describes one locked record for a particular
;  process-record stream (rab/irab). if the owner field
;  is 0 then the rlb is available for use. otherwise, it
;  describes a locked record. note: when owner is 0 the
;  record rfa fields are zeroed (0).
;
;
;                +---------------------------------------+
;                |                                       |
;rlb:            |                link                   |
;                |                                       |
;                +------------------+--------------------+
;                |                  |                    |
;                |       owner	    |        rfa4	 |
;                |                  !               id   |
;                +---------+--------+----------+---------+
;                |         |        |          |         |
;                |  flags  |reserved|   bln    |   bid   |
;                |         |        |          |         |
;                +---------+--------+----------+---------+
;                |                                       |
;                |                rfa0                   |
;		 |                                       |
;                +---------------------------------------+
;                |                  |                    |
;lksb:           | Still to be def- |  VMS status code   |
;                | ined status bits |                    |
;                +---------------------------------------+
;                |                                       |
;                |  Lock Id. (Returned for new locks,    |
;                |            input for conversions)     |
;                +---------------------------------------+
;
;
	$STRUCT	RLB

	F LNK,L			; link to next rlb
	F MISC,L		; longword definition to optimize clearing field
	  S OWNER,0,W		; owner id for locked record is
		  		;  isi for stream
				; note that owner field is now a word, not
				; a longword anymore
	  S RFA4,2,W		; 3'rd word of records rfa
				; offset for seq f.o. (bits 0:14)
				; always 0 for rel f.o. (bits 0:14)
	  S ID,2,W		; id for idx f.o.
	F BID,B			; block id
	  C BID,14		; rlb code
	F BLN,B			; block length in longwords
	F ,B			; reserved
	F FLAGS,B		; various locking flags
	V <M
	  WAIT			; propagation of ROP WAT bit
	  CR			; defines lock manager mode "concurrent read"
				; used to query lock database for records
	  PW			; allow reader access to locked record flag
				; indicate "lock for write, allow readers"
	  PR			; used to query lock database
	  >
	F RFA0,L		; 1'st and 2'nd words of record's rfa
				; seq f.o. vbn
				; rel f.o. relative record number
				; idx f.o. start vbn
	F LKSB,L		; first longword of lock status block
	  S STATUS,0,W 		; VMS status code
	  S S_BITS,2,W		; various status bits
	F LOCK_ID,L		; second longword of lksb is lock_id
	L BLN			; length of rlb
	E

;
;  directory cache node definitions
;
	$STRUCT	DRC

	F NXTFLNK,L	; link to next entry, this level
	F NXTBLNK,L	; link to previous entry, this level
	F LVLFLNK,L	; link to first entry, next lower level
	F LVLBLNK,L	; link to last entry, next lower level
			; note: the links are maintained in lru order
	F NAME,T,10	; directory name or device and unit
			; note: stored as counted string counting count itself
	F DID,W,3	; file id for directory
	S DIRSEQ,2,W	; directory sequence # for device node
	L BLN		; length of directory cache node
	E


;
;		release option flag definitions
;
	$STRUCT	RLS

	V <M
	RETURN		; return buffer and bdb to free space lists
	WRT_THRU	; write buffer if dirty
	KEEP_LOCK	; keep bdb locked
	DEQ		; always release lock
	>
	E

;
;		cache option flag definitions
;
	$STRUCT	CSH

	V <M
	LOCK		; obtain exclusive access to block
	NOWAIT		; do not wait for block on access interlock
			; collision
	NOREAD		; do not read in block
	NOBUFFER	; obtain access to block but don't allocate
			; a buffer for it and don't read it
	>
	E

;
;
;  rms overall status bit definitions
;
	$STRUCT	PIO

	V <
	INHAST		; set if asts implicitly inhibited
			; if reset by disabled ast, ast must be re-
			; enabled
	EOD		; set if searching for 'eod' string on 'input'
	SYNC1		; sync stalled operation using efn 27
	SYNC2		; sync stalled operation using efn 28
	>
	E


;
;	definitions for rms debug failure codes
;
;
;  the following codes are for temporary bug check tests, and are
;  internal to rms.  all of the codes are negative, implying that they
;  do not return to the caller, probably killing the process (if not
;  the entire system).
;
	$STRUCT	FTL

	C <,$_
	SETPRTFAIL,-1	; set protection system service failed (rm0bufmgr)
	STKTOOBIG,-2	; stack too big for asb (rm0stall)
	BADIFAB,-3	; invalid ifab (or irab) (rm0fset,rm0conn,rm0rset,
			; rm0prflnm)
	GTCHNFAIL,-4	; get channel system service failure (rm0prflnm)
	BADORGCASE,-5	; invalid orgcase value for dispatch (all rms$
			; level routines execept open and create)
	BADBDB,-6	; block not a bdb (rm0bufmgr)
	ASBALLFAIL,-7	; couldn't allocate an asb (rm0stall)
	BADASTPRM,-8	; ast parameter not a valid ifab/irab addr (rm0stall)
	CANTDOAST,-9	; couldn't redeclare ast (insf. mem.) (rm0stall)
	NOSTRUCT,-10	; rab or fab not same on ast (rm0stall)
	NOASB,-11	; asb not allocated or stream not busy on ast (rm0stall)
	NONXTBDB,-12	; no next bdb available (rm1seqxfr)
	BADBUFSIZ,-13	; disk buffer size not = 512 (rm1conn)
	ENQDEQFAIL,-14	; enq or deq service failed (rm0reclck)
	NOCURBDB,-15	; no current bdb before calling rm$release (rm0reclck)
			;   (-16 no longer used)
	DEALLERR,-17	; ifab deallocation attempted with other block(s)
			; still allocated (rms0close)
	IORNDN,-18	; i/o rundown inconsistency (either ifab or irab
			; table entries not zeroed) (rms0rndwn)
	XFERSIZE,-19	; size of requested transfer not equal to
			; or less than the current number of bytes
			; in use for the bdb (rm0cache)
	NOTLOCKED,-20	; bdb not locked and a keep lock request
			; was made on a release request.
	NODIDORFID,-21	; neither a fid nor a did was set upon exit from
			; rm$setdid (rms0erase)
	RELEASFAIL,-22	; release of non-dirty bdb failed (rm0xtnd23,rms0extend)
	NOLOCKBDB,-23	; no lock bdb found (rm0xtnd23)
	NONETWORK,-24	; network routine entered but no network support in rms
	LOCKFAILED,-25	; failed to lock prolog (rm2create)
	BADLEVEL,-26	; to search by id, structure level must be 0
	ASTDECERR,-27	; ast declaration for file sharing failed
	BCBERR,-28	; no more bcb's to release even though more bdb's
	SFDSPCERR,-29	; all space was not returned before returning sifab pag
	ACCNTOVFLO,-30	; access count overflow (rm0share)
	QUEUEERR,-31	; take sifab queue error (rm0share)
	QUEUEERR2,-32	; release sifab queue error (rm0share)
	BDBAVAIL,-33	; BDB was available and shouldn't have been.
	GBLNOLK,-34	; Record locking was not set with global buffers.
	LCKFND,-35	; A lock was found and we don't know what to do.
	NOBLB,-36	; No BLB was found and there should have been one.
	NOGBPB,-37	; No GBPB was found and should have been.
	NOLCLBUF,-38	; Should have found a local buffer.
	NORDNOTSET,-39	; NOREAD not set when NOBUFFER was.
	NOTGBPB,-40	; Found an illegit BDB.
	NOSFSB,-41	; No SFSB when allocating BLB.
	LOCKHELD,-42	; Attempted to return a BLB with lock_id neq 0
	RLSDRT,-43	; Dirty buffer found in releasall.
	BADBLB,-44	; Bad BLB found in blocking AST routine.
	BADOWNER,-45	; Owner field in BLB is bad in blocking AST routine.
	>

	E

;
;  the following internal codes are for non-fatal bug check reporting.
;  these codes are positive byte values.  they trigger a reporting action
;  and return to the caller with r0 set to rms$_bug+<8*the bug code>,
;  which is an externally documented rms error code.
;
	$STRUCT	BUG

	C <,$_
	BADDFLTDIR,1	;DEFAULT DIRECTORY STRING INVALID (RM0XPFN)
	>

	E

; index descriptor definition
;
; an index descriptor block exists for each key of reference in use.
; they are not necessarily contiguous in memory.
;
	$STRUCT	IDX
	
	F IDXFL			; forward link to next index descriptor
	F ,L			; spare
	F BID,B			; block id
	  C BID,15		; id for index descriptor block
	F BLN,B			; length of block
	F IANUM,B		; area number for index buckets
	F LANUM,B		; area number for lower index buckets
	F DANUM,B		; area number for data buckets
	F ROOTLEV,B		; level of root
	F IDXBKTSZ,B		; size of index bucket in vbn's
	F DATBKTSZ,B		; size of data bucket in vbn's
	F ROOTVBN,L		; start vbn of root bucket
	F FLAGS,B		; index/key flags
	  V<M
	  DUPKEYS		; duplicate keys allowed
	  CHGKEYS		; keys can change values
	  NULKEYS		; null key value allowed
	  IDX_COMPR		; index is compressed
	  INITIDX		; index is not initialized
	  COUNT_DUP		; maintain duplicate count
	   >

	  V<M			; primary key flags only
	  ,1			; space over dupkeys
	  NORFA			; no rfa fields in records (single key only)
	  PRG_D_RFA		; delete records and rrv's may be purged
				; from file (disables fast delete)
	  ,1
	  ,1
	  ,1
  	  KEY_COMPR		; key has been compressed at the data level
	  REC_COMPR		; data record is in compressed form
	  >

	F DATATYPE,B		; data type of key field
	  C STRING,0		; string data type
	  C SGNWORD,1		; signed binary word
	  C UNSGNWORD,2		; unsigned binary word
	  C SGNLONG,3		; signed binary long word
	  C UNSGNLONG,4		; unsigned binary long word
	  C PACKED,5		; packed decimal
	F SEGMENTS,B		; number of key field segments
	F NULLCHAR,B		; null character
	F KEYSZ,B		; total key size
	F KEYREF,B		; key of reference(0-primary)
	F MINRECSZ,W		; minimum record size
	F IDXFILL,W		; index fill
	F DATFILL,W		; data fill
	F IDXBKTYP,B		; PLG3 - type of index bucket and SIDR bucket
	  C V2_BKT,0		; Prologue two bucket
	  C CMPIDX,1		; Prologue 3, index (and SIDR) are compressed
	  C NCMPIDX,2		; Prologue 3, index (and SIDR) are not compressed
	F DATBKTYP,B		; PLG3 - type of primary data bucket
	  C CMPCMP,3		; Prologue 3, primary key is compressed, data
				;  is compressed
	  C CMPNCMP,4		; Prologue 3, primary key is compressed,
				;  data is not compressed
	  C NCMPCMP,5		; Prologue 3, primary key is not compressed
				;  data is compressed
	  C NCMPNCMP,6		; Prologue 3, primary key is not compressed
				;  data is not compressed
	F ,W			; spare
;
; the following is the length of the fixed part of the index descriptor
;
	L FIXED_BLN

;
; the following is repeated for each key segment
;
	F POSITION,W		; key segment position
	F SIZE,B		; key segment size (plg 3)
	F TYPE,B		; key segment datatype (plg 3)
	E


;
; nrp list definitions
;
	$STRUCT NRP

	F LINK,L	; link to next " next record pointer" cell
	F SPARE,B	; needed to match the next section size

; Beginning of first section (9 bytes long)

	F VBN,L		; vbn of "next record "
	F ID,W		; id of "next record " (plg 3)
	F FLAGS,B
	 V<M
	   DELETED	; the "next record " has been deleted
	   BEGINNING	; we are pointed to the beg. of a bucket
	   NEW_VBN,2	; 0,1,2 indicating what the new vbn will be,
			; used during split
	   UPD_NRP	; nrp is to be updated
	   NEW_DEL	; the new delete flag(used in $delete)
	   NEW_BEG	; the new beginning flag(used in $delete)
	  >
	F DUP_POS,W	; position count for sidr's

; Beginning of second section

	F RP_VBN,L	; vbn of "record"
	F RP_ID,W	; rp of "record" (plg 3)
	F NEW_POS,W	; the new dup_pos (used in $delete and clean up deleted records)
	F NEW_NRP,W	; new id for nrp, used during split (plg 3)
	L BLN
	C CELL,9	; Determines the size of sections within the NRP cell,
			; such that corresponding values can be referenced by
			; the same address when the NRP pointer is changed.
	E

;
; update buffer flags
;
	$STRUCT UPD

	F FLAGS,B
	 V<M
	   INS_NEW	; alternate key to be inserted from record buffer
	   OLD_DEL	; delete this key value using old record
	  >
	E

;	GBH field definitions
;
; Global Buffer Header (GBH)
;
; There is a Global Buffer Header for every file's global buffer section.
;
	$STRUCT	GBH

	F GBD_FLNK,L	; Self relative queue header for GBD's
	F GBD_BLNK,L
	F BID,B		; Block ID
	  C BID,17	; Block ID code for GBH
	F BLN,B		; Length of GBH in longwords
	F TRC_FLGS,W	; Trace flags (set to trace given function)
	  V < M
	  CACHE_IN	; Cache inputs
	  CACHE_OUT	; Cache outputs
	  RLS_IN	; Release inputs
	  RLS_OUT	; Release outputs
	  QIO_START	; Qio inputs
	  QIO_DONE	; Qio outputs
	  STALL		; Stall inputs
	  THREADGO	; Stall outputs
	  BLB_ENQ	; Bucket lock ENQ inputs
	  BLB_GRANT	; Bucket lock grant status
	  BLB_DEQ	; Bucket lock DEQ request
	  BLB_BLOCK	; Blocking AST received
	  F1
	  F2
	  F3
	  F4
	  >

	F HI_VBN,L	; Highest possible VBN value (FFFFFFFF).
	F GS_SIZE,L	; Size of total section in bytes.
	F TRC_FLNK,L	; Trace blocks forward link
	F TRC_BLNK,L	; Trace blocks back link
	F GBD_START,L	; Offset to first GBD.
	F GBD_END,L	; Offset to last GBD.
	F GBD_NEXT,L	; Offset to next cache victim GBD.
	F SCAN_NUM,L	; Number of GBD's to scan for victim.
;
; Global buffer statistics section
;
	F HIT,L		; Buffer found in global cache
	F MISS,L	; Buffer not found in global cache
	F READ,L	; Buffer read from disk into cache
	F WRITE,L	; Buffer written from cache to disk
	F DFW_WRITE,L	; Deferred writeback from cache to disk
	F CROSS_HIT,L	; Cross process hit count.
	L BLN		; Length of global buffer header structure
	E



;	TRC field definitions
;
; Trace block structure (TRC)
;
; Tracing saves at specific points in the RMS code for debugging and
; algorithm analysis purposes.
;
	$STRUCT	TRC

	F FLNK,L	; Trace block forward link
	F BLNK,L	; Trace block back link
	F BID,B		; Block ID
	  C BID,18	; Trace block code
	F BLN,B		; Length of block in longwords
	F FUNCTION,W	; Function code (see GBH definitions)
	F STRUCTURE,L	; Ifab/irab address.
	F PID,W		; Process ID
	F SEQNUM,W	; Sequence number.
	F VBN,L		; VBN requested.
	F RETURN1,L	; Address of caller.
	F RETURN2,L	; Caller's caller.
	F ARGS,L,8	; Function specific arguments
	 S ARG_FLG,,L	; Argument flags (R3).
	 S BDB_ADDR,,L	; BDB address.
	 S BDB_USERS,,W	; Use count from BDB.
	 S BDB_BUFF,,W	; BDB buffer ID.
	 S BDB_CACHE,,B	; BDB cache value.
	 S BDB_FLAGS,,B	; Status flags from BDB.
	 S BDB_SEQ,,L	; Sequence number from BDB.
	 S BLB_MODE,,B	; Mode held in BLB.
	 S BLB_FLAGS,,B	; Flags from BLB.
	 S BLB_ADDR,,L	; Address of BLB.
	 S BLB_LOCK,,L	; Lock ID from BLB.
	 S BLB_SEQ,,L	; Sequence number from BLB.
	L BLN		; NOTE: should be quadwords multiple to
			; maintain quad alignment on header
	E




;	GBD structure definitions
;
; Global Buffer Descriptor (GBD)
;
; There is a single GBD for every buffer in a global buffer
; section (used only with shared files).  The GBD's themselves
; are in the section also and linked from a queue header in
; the Global Buffer Header (GBH).
;
	$STRUCT	GBD

	F FLINK,L	; Forward link - Note: This is a self relative queue
	F BLINK,L	; Back link
	F BID,B		; Block ID
	  C BID,19	; Block ID code for GBD
	F BLN,B		; Block length of GBD
	F FLAGS,B	; Buffer status flags
	  V<M
	   VALID	; Buffer is valid.
	   >
	F CACHE_VAL,B	; Cache value of this bucket
	F VBN,L		; VBN of bucket the buffer describes
	F NUMB,W	; Number of bytes in use
	F SIZE,W	; Size of buffer in bytes
	F REL_ADDR,L	; Address of buffer relative to GBH
	F BKTSEQNUM,L	; Bkt sequence number validity check
	 S LAST_ID,,W	; Last PID to reference bucket.
	 S LST_LK_ID,,W	; PID of last locker to reference bucket.
	F USECNT,W	; Accessor count for bucket
	F REHIT_RD,B	; Rehit by same process count.
	F REHIT_LK,B	; Rehit by same locker process.
	L BLN		; NOTE: should be quad multiple to maintain
			; quad alignment on header
	E



;	BLB field definitions
;
; Bucket Lock Block (BLB)
;
; The BLB contains the argument list for the SYS$ENQ system service
; as well a pointer to the BDB it relates to and other status.
;
	$STRUCT	BLB

	F FLNK,L	; Link to next BLB
	F BLNK,L	; Back link
	F BID,B		; Block ID
	  C BID,16	; BLB code
	F BLN,B		; Block length
	F BLBFLGS,B	; Control flags for BLB
	  V<M
	  LOCK		; Corresponds to CSH$V_LOCK
	  NOWAIT	; Same as CSH$V_NOWAIT
	  NOREAD	; Same as CSH$V_NOREAD
	  NOBUFFER	; Same as CSH$V_NOBUFFER
	  IOLOCK	; Lock mode for read/write
	  DFW		; This is lock for deferred write buffer
	  WRITEBACK	; The associated buffer must be written back
	  >
	F MODEHELD,B	; Mode of current lock held.
	F BDB_ADDR,L	; BDB for which this lock is held
	F OWNER,L	; Address of stream owning this lock
	F VBN,L		; VBN of bucket lock (resource name)
	F RESDSC,L,2	; Resource name descriptor
	F LKSTS,W	; Lock status word
	F ,W		; reserved
	F LOCK_ID,L	; Lock ID
	F VALBLK,L,4	; Lock value block
	S VALSEQNO,0,L	; Sequence number part of value block
	L BLN		; Length of BLB
	E
