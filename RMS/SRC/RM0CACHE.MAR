	$BEGIN	RM0CACHE,004,$RMS23,<IO CACHE ROUTINE>


;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; Facility: rms32
;
; Abstract:
;
; This module provides a block cache and access control
; to the buckets of the relative and indexed file organizations
;
; Environment:
;	VAX/VMS
;
; Author: E.H. Marison	15-SEP-1977
;
; Modified By:
;
;	V03-004	CDS0028		C Saether		13-Apr-1982
;		Modify lock_bkt routine to attempt to toss something
;		out of the local cache when the enq results in
;		either an exenqlm or nolockid error.  Hopefully this
;		frees up a lock so the operation can continue.
;
;	V03-003	CDS0027		C Saether		30-Mar-1982
;		Correct problem when LOCK, NOREAD, NOBUFFER is
;		specified for a bucket which is already accessed
;		with a buffer.  This was causing the new flags to
;		overwrite those from the initial access and not
;		store the value block on release.
;
;		Set default error in R1 before call to MAPERR.
;		Increment use count in GBD only after GBPB accessed.
;
;		Check if BDB was present before looking at it.
;
;	V03-002	CDS0026		C Saether		22-Mar-1982
;		Modify SCAN_GBL routine to avoid end test and speed
;		up by looping in line.
;
;	V03-001	CDS0025		C Saether		 1-Mar-1982
;		Count hits and misses for global buffers.
;		Fix incorrect register use in SCAN_LOCKS checking
;		for GBPB.
;							26-Feb-1982
;		Don't bother trying to get read locks on buckets in
;		a compatible mode.  It causes conversion deadlock
;		problems when other streams (processes) are attempting
;		to modify the same bucket simultaneously.  This is
;		the same problem only partially corrected in V02-036.
;		Also have LOCK_BKT routine call RM$MAPERR to map
;		enqueue failures to RMS errors if appropriate.
;							16-Feb-1982
;		Changes to allow modification of global buffers.
;		FREE_LCL and GET_LCL_BUFF become RM$FREE_LCL and
;		RM$GET_LCL_BUFF.
;		SCAN_LOCKS changed to not return GBPB address unless
;		caller already owns it (don't want more than one
;		accessor on a GBPB at once).
;		Don't try to use global buffers if stream didn't
;		connect for them.
;							 7-Feb-1982
;		Shorten scan_local_cache to scan_lcl_cache.
;
;	V02-037	CDS0024		C Saether		 2-Feb-1982
;		Set VAL in GBPB.
;
;	V02-036	CDS0023		C Saether		27-Jan-1982
;		When upgrading a lock from CR to EX because the bucket
;		must be read, convert to NL if a deadlock occurs
;		before requeueing the request for EX.
;		Make tracing slightly easier to enable.
;
;	V02-035	CDS0022		C Saether		25-Jan-1982
;		Add tracing mechanism.
;
;	V02-034	CDS0021		C Saether		18-Jan-1982
;		Further mods for global buffer caching.
;
;	V02-033	CDS0020		C Saether		13-Jan-1982
;		FREE_LCL routine must also be prepared to release
;		BDB's that have a deferred write lock on them.  This
;		will be the case when no BDB's with users=0 can be found
;		in a multi-streaming situation.
;
;	V02-032	CDS0019		C Saether		 6-Jan-1982
;		Add support for global buffer caching.
;
;	V02-031	CDS0018		C Saether		31-Dec-1981
;		When read i/o required for a read lock, lock at
;		EX mode.  This avoids multiple simultaneous i/o's
;		when multi-streaming at the expense of some possible
;		concurrency.
;
;	V02-030	CDS0017		C Saether		30-Dec-1981
;		Check for errors on bdb's that have been written back.
;
;	V02-029	CDS0016		C Saether		 9-Dec-1981
;		Changes to support deferred writeback of buffers.
;		SCAN_LOCKS routine modified to work with write back
;		routine when write (lock) access is required to buffer.
;		FREE_LCL routine must also be prepared to stall if
;		in conflict with blocking routine.
;
;	V02-028	CDS0015		C Saether		 8-Dec-1981
;		Remove references to READAHEAD flag.
;
;	V02-027	CDS0014		C Saether		20-Nov-1981
;		Define separate entry point for upgrading lock for
;		i/o that doesn't require R3 as input.
;		Enhance commentary.  Take out superfluous MOVL in
;		SCAN_LOCKS.  GET_BLB tests for zero VBN instead of
;		OWNER.  Stop setting efn in LOCK_BKT to reflect
;		changes to lock manager when sync and deallocate
;		event flag.
;
;	V02-026	CDS0013		C Saether		 8-Oct-1981
;		Save all cache flags in blb flags and do that and
;		setting of owner in the lock_bkt routine.
;
;	V02-025	CDS0012		C Saether		 1-Oct-1981
;		Cannot test for lock_id of zero in lock status block
;		when deciding if lock request should be a conversion
;		because if a deadlock is detected on a non-conversion
;		request, the lock id will be non-zero even though the
;		lock was not granted.
;
;		If BLB for desired VBN not found when scanning locks,
;		still want to know if BDB found so that multiple BDB's
;		are not allocated.
;
;		Fix INSQUE when multiple BLB's are associated with a
;		single BDB.
;
;	V02-024	CDS0011		C Saether		29-Sep-1981
;		Ignore block i/o BDB's when looking for free one.
;		Further refinements to V02-023.
;
;	V02-023	CDS0010		C Saether		25-Sep-1981
;		Error path fixing for RLK error.
;		Correct storing of VBNSEQNO after locking.
;
;	V02-022	CDS0009		C Saether		17-Sep-1981
;		Fix on error path.  Always need BDB in R5 for read_bkt.
;
;	V02-021	CDS0008		C Saether		31-Aug-1981
;		Work on lock of bucket already in cache.
;
;	V02-020	CDS0007		C Saether		 8-Aug-1981
;		Rewrite.
;
;
;--
;


	.SBTTL	DECLARATIONS

;
; Include Files:
;

	$BDBDEF				; bucket descriptor blocks
	$BLBDEF				; bucket lock blocks
	$CSHDEF				; rm$cache flag definitions
	$ENQDEF				; enq sys service definitions
	$GBDDEF				; global buffer descriptor defs
	$GBHDEF				; global buffer header
	$GBPBDEF			; global buffer pointer block defs
	$IFBDEF				; ifab defs
	$IMPDEF				; impure area definitions
	$IRBDEF				; irab defs
	$LCKDEF				; lock manager flags, constant defs
	$PIODEF				; process i/o definitions
	$RABDEF				; record access block
	$RLSDEF				; rm$release flags
	$RMSDEF				; rms error code defs
	$SFSBDEF			; shared file lock block defs

;
; Macros:
;
;
; Equated Symbols:
;
;
; Own Storage:
;


	.SBTTL	RM$CACHE ROUTINE

;++
; RM$CACHE - access and read bucket if necessary
; RM$CACHEC
;
;    1.	 obtains access to requested block/bucket and waits
;	 for the access unless csh$v_nowait
;	 is set in the control flags.
;
;    2.	 obtains a buffer for the block unless csh$v_nobuffer
;	 is set in the control flags.
;
;    3.	 if there is a buffer read the block into it if
;	 required, and the csh$v_noread bit is off in the
;	 control flags.
;
;    4.	 waits for io completion
;
;    5.	if the csh$v_lock bit is set in the flags then
;	 exclusive access to the block is obtained.
;
; Calling sequence:
;		BSBW	RM$CACHE
;		BSBW	RM$CACHEC
;
;
; Input Parameters:
;
;	r11	impure area address
;	r10	ifab address
;	r9	irab/ifab address
;	r8	rab/fab address
;	r3	cache control flags
;	r2	transfer/buffer size in bytes
;	r1	requested vbn
;
;	rm$cachec used to optimize scan by looking at curbdb first, but
;	is no longer used.
;
; Implicit Inputs:
;
;	If shared file with record locking, assumed that caller owns the shared
;	ifab.
;
; Output Parameters:
;
;	r0	internal rms status code
;	r4	bdb address
;	r5	buffer address unless a nobuffer call
;		in which case r5 is destroyed
;	r1,r2,r3,ap destroyed
;
; ****	bdb and buffer not accessed on errors
;
; Completion Codes:
;
;	standard internal rms, including:
;
;		suc	normal success
;		rlk	block was accessed or locked and nowait
;		dme	could not get a buffer
;		exenqlm	the enq limit for this process was exceeded
;			while attempting to lock a bucket.
;		various errors writing a deferred write buffer or reading
;		in the new buffer.
;
; Side Effects:
; May have switched to running at ast level if not already there as
;	a result of stalling for i/o to complete or waiting for a
;	resource to be granted.
;
;--

TRACE:
	JSB	RM$CACH_IN
	BSBB	CACHE
	JSB	RM$CACH_OUT
	RSB

BUFF_ONLY_BR:
	BRW	BUFF_ONLY		; No lock - only want scratch buffer.

RM$CACHEC::
RM$CACHE::
	BRB	CACHE			; Patch this for tracing.
	BRB	TRACE			; Branch over this normally.
CACHE:
	TSTL	R1			; Is this VBN 0 call?
	BEQL	BUFF_ONLY_BR		; EQL then only want buffer, no lock.

	BBC	#CSH$V_NOBUFFER, R3,-	; Branch if buffer is desired.
		NEED_BUFFER
	BBS	#CSH$V_NOREAD, R3, 10$	; Expectation is that NOREAD is set.
	RMSPBUG	FTL$_NORDNOTSET		; So much for that idea.
10$:

;
; If here, this is a nobuffer request, meaning that a lock only on the
; bucket is desired.  This type of lock will be requested to interlock
; an extend type operation with other processes sharing the file.  If
; the file is open for exclusive access, nothing further is required.
;

	BBC	#IFB$V_NORECLK, (R10), 20$ ; Branch if locking req'd.
	BSBW	SCAN_LCL_CACHE		; Is it already in cache?
	MOVL	R5, R4			; See if it is.
	BEQL	15$			; Nope.  Just return.
	MOVW	#1, BDB$W_USERS(R4)	; Make it look accessed.
15$:	RMSSUC				; Success.
	RSB				; Return.

20$:
	BSBW	SCAN_LOCKS		; See if lock is already held.
	BLBC	R0, 30$			; Branch if lock not found.
	TSTL	R5			; Is there a BDB also?
	BEQL	15$			; Already have lock.  All done then.

;
; Note that finding a buffer in the cache on a nobuffer call and simply
; accessing the buffer along with the lock violates the assumptions about
; the worst case condition where two buffers plus a lock only on another
; bucket are required.  However, given the current use of the nobuffer call
; for vbn 1, and the sequence of operations used, it would not be possible
; for vbn 1 to be in the cache at the time of the nobuffer call because
; the two buffers would be occupied by the bucket being split and the area
; descriptor already.  With two streams, it is difficult to construct a
; sequence of events where block 1 could happen to be in the cache at the
; time two streams were extending separate areas during separate splits
; such that the problem would actually arise.
;
; The logic which initializes an index will call CACHE for a lock, nobuffer
; on VBN 1 when VBN 1 is already accessed with a buffer.  In that case,
; the owner will be the current stream.  The address of the BDB (as opposed
; to the BLB) must be returned in that case because the routine compares
; the original BDB address from the first call (saved in IRB$L_LOCK_BDB)
; with the return from this call to determine whether to release the lock.
; Pretty tacky, but that's the way it is.  No checks are made to determine
; if the bucket is LOCKed when one is found, as it is not believed any routines
; would do that and follow it with a LOCK, NOBUFFER call.
;

	CMPL	BLB$L_OWNER(R4), R9	; This stream already have it accessed?
	BNEQ	25$			; NEQ, then go access it normally.
	MOVL	R5, R4			; Get BDB addr into R4.
	BRB	15$			; And exit with success.
25$:	BICL2	#CSH$M_NOBUFFER!CSH$M_NOREAD, R3 ; There already is a buffer.
	BRW	LOCK_IT			; Raise mode if req'd.
30$:
	BSBW	GET_BLB			; Get a BLB for this lock.
	BSBW	LOCK_BKT		; Go lock it.
	RSB				; Return.

;
; Got the bucket locked, but no buffer with it.
;

NEED_BUFFONLY:
	DECW	IFB$W_AVLCL(R10)	; Decrement available count.
	BGEQ	GET_BUFF		; Enough buffers, go get BDB.
	BSBW	RM$FREE_LCL		; Free up a local buffer.
	BLBS	R0, GET_BUFF		; Branch and go use it on success.
	INCW	IFB$W_AVLCL(R10)	; Restore count.
	RSB				; Return with error in R0.

NEED_BUFFER:
	BBS	#IFB$V_NORECLK, (R10),-	; Branch if no locking.
		NOLOCKING

;
; Locking is being done.  Scan list of buffer lock blocks (BLB's) to
; determine if bucket already has lock.  Normally locating a bucket in
; the BLB list means that either a NL or PW lock is held on a buffer
; currently present in the local cache.
;
; Under some conditions a request is made for a lock with buffer on a
; bucket which was previously locked with the NOBUFFER flag, in which
; case a lock will be found with no BDB.
;
; Lastly, a BDB for the desired bucket may be found, but no BLB.
; This will occur when multi-streaming and another stream has the
; desired bucket accessed.  Only a BLB must be acquired in this case.
;

CHECK_LOCKS:
	BSBW	SCAN_LOCKS		; See if lock already held.
	BLBC	R0, NEED_BLB		; No - go to get BLB.
	TSTL	R5			; Was there a BDB also with the BLB?
	BEQL	NEED_BUFFONLY		; Go get a buffer for the BLB.
	BRW	CHKWBK			; Have BDB, BLB, so access them.
NEED_BLB:
	TSTL	IFB$L_GBH_PTR(R10)	; Global buffer cache present?
	BEQL	LOCAL			; EQL then there is none.

;
; Global buffer cache is present.  If a BDB has already been found, though,
; always use it.  It didn't have a BLB if here, meaning another stream
; must currently have it accessed, therefore it has a much better chance
; of being valid.
;
	TSTL	R5			; Is BDB already present?
	BNEQ	LOCAL			; NEQ then use it.
	ASSUME	IRB$B_BID EQ IFB$B_BID
	ASSUME	<IRB$C_BID & 1> EQ 0
	ASSUME	<IFB$C_BID & 1> EQ 1
	BLBS	IFB$B_BID(R9), LOCAL	; Use local if ifab operation.
	BBC	#IRB$V_GBLBUFF, (R9), LOCAL ; Use local if stream did not
					; want global buffs when connecting.
	BSBW	SCAN_GBL		; Search global cache.
	BLBS	R0, 10$			; Br if got a match and use it.

;
; Did not find the desired bucket in the global cache.
; If a lock is not requested, attempt to get a global buffer and use it.
; If a lock is requested, use a local buffer.  The belief is that if
; the bucket wasn't already in the global cache, this must be a new
; insert, therefore the chance of another process potentially having
; an interest in it is very low.  In addition, if deferred write is
; enabled, modified global buffers must be copied to a local buffer
; when they are released.  The extra cpu overhead to do that would
; outweigh the rare instances where an i/o would be saved because
; another process was interested in the same bucket.
;

	ASSUME	CSH$V_LOCK EQ 0
	BLBC	R3, 10$			; Br to use gbl if not locking.
	CLRL	R5			; Note that no buffer is present.
	BRB	LOCAL			; Go use local buffer.

;
; We wish to use global buffers.  R0 contains the status from the global
; cache scan above.   Whether or not the requested bucket was found, we
; will need a blb.  In the rare case where a global buffer cannot be freed
; when the desired bucket was not located, reset the owner and vbn fields of
; the blb just obtained, and drop through to use a local buffer instead.
;

10$:	BSBW	GET_BLB			; Get a free BLB for the lock.
	BLBS	R0, GOT_BUFF		; Branch if match found in gbl cache -
					; R0 is the result from SCAN_GBL here.
	BSBW	FIND_FREE_GBL		; Attempt to find a free global buffer.
	BLBS	R0, NEED_READ		; Br to force read if one found.
	ASSUME	<BLB$L_OWNER + 4> EQ BLB$L_VBN
	CLRQ	BLB$L_OWNER(R4)		; Free up BLB.  Drop thru to use local.
LOCAL:

;
; A local buffer is to be used.
; If R5 is non-zero, it contains the address of the BDB for the requested
; bucket even though a BLB must be obtained.
;

	DECW	IFB$W_AVLCL(R10)	; Decrement available count.
	BGEQ	10$			; Got enough - go get BLB.
	INCW	IFB$W_AVLCL(R10)	; Put count back - will go round again.
	BSBW	RM$FREE_LCL		; Free up a buffer.
	BLBC	R0, EXBR		; Exit on error.
	BBS	#IFB$V_MSE, (R10),-	; If multi-streaming, need to scan
		CHECK_LOCKS		; locks again (may have changed).
	DECW	IFB$W_AVLCL(R10)	; Dec count.  One is available now.
10$:	BSBW	GET_BLB			; Get a free BLB.
	TSTL	R5			; Is there a BDB already?
	BNEQ	GOT_BUFF		; NEQ already have one.
GET_BUFF:
	BSBW	RM$GET_LCL_BUFF		; Get a free BDB.
	BBS	#IFB$V_NORECLK, (R10),-	; Branch if not locking.
		READ_NOLOCKING
NEED_READ:
	BISB2	#BLB$M_IOLOCK,-		; Know that I/O will be req'd.
		BLB$B_BLBFLGS(R4)
GOT_BUFF:
	MOVL	R5, BLB$L_BDB_ADDR(R4)	; Store BDB address in BLB.
	BRB	LOCK_IT			; Go to lock code.

;
; Branch here when using local buffers in exclusive mode, i.e., no locking
; is being performed.
;

NOLOCKING:
	BSBW	SCAN_LCL_CACHE		; Look in local cache.
	MOVL	R5, R4			; Anticipate suc - load R4 with BDB.
	BNEQ	10$			; NEQ we have a buffer.
	BRW	NEED_BUFFONLY		; Need to go get a buffer.

;
; We have found the desired bucket in the local cache when no locking
; is required.  The bucket must be valid, therefore simply return
; with success.
;

10$:	RMSSUC				; Set success.
	INCW	BDB$W_USERS(R4)		; Note in use.
	BRW	SETR5			; Branch to set R5 and exit.
READ_NOLOCKING:

;
; Branch here after getting buffer when no locking.
;

	INCW	BDB$W_USERS(R5)		; Note in use.
	BRB	READ_BKT		; Go read bucket - no lock req'd.

EXBR:	BRW	EXIT

;
; Check for possible writeback errors.  This is only branched to after
; finding a lock with bdb (i.e., cached).  A similar check is made in
; the RM$FREE_LCL routine.
;

WBKERR:	MOVZWL	BDB$L_IOSB(R5), RAB$L_STV(R8) ; Store i/o error code.
	RMSERR	WER			; Note error with RMS code.
	RSB				; And return.
CHKWBK:	BBCC	#BDB$V_AST_DCL,-	; Branch if no writeback has been done.
		BDB$B_FLGS(R5), LOCK_IT
	BLBC	BDB$L_IOSB(R5), WBKERR	; Branch if error occured.

;
; At this point:
;	R3 = CSH flags
;	R4 = BLB
;	R5 = BDB
;

LOCK_IT:
	INCW	BDB$W_USERS(R5)		; Bump user count.
	MOVL	BDB$L_BLB_PTR(R5), R0	; Other BLB's already?
	BNEQ	10$			; NEQ there are others.
	MOVL	R4, BDB$L_BLB_PTR(R5)	; Point from BDB to our BLB.
	BRB	20$			; Branch to lock bucket.
10$:	CMPL	R0, R4			; Is this us?
	BEQL	20$			; EQL then yes it is.
	REMQUE	(R4), R4		; Remove from current position in list.
	INSQUE	(R4), (R0)		; Insert after BLB pointed to.
20$:	BSBW	LOCK_BKT		; Acquire bucket lock
	BLBC	R0, ERREX1		; Exit on error
	BBS	#BLB$V_NOREAD, BLB$B_BLBFLGS(R4),- ; All done if read not req'd
		40$
	ASSUME	BDB$B_BID EQ GBPB$B_BID
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	BLBC	BDB$B_BID(R5), 30$	; Br if BDB.

;
; If this is a global buffer, validity is based on whether the VALID
; flag is set or not, rather than the sequence numbers matching.  This
; is because locks are not always held on buffers in the global cache,
; therefore it may contain a non-zero value and yet the value block
; when the lock is obtained is zero.
; Whenever a local buffer is modified, the VALID flag will be cleared if
; a global copy exists to ensure that it will be read from disk.
;

	MOVL	GBPB$L_GBD_PTR(R5), R0	; Get pointer to GBD.
	ASSUME	GBD$V_VALID EQ 0
	BLBC	GBD$B_FLAGS(R0), 50$	; If invalid, force read of bucket.
	MOVL	BLB$L_VALSEQNO(R4),-	; It is valid, so update sequence
		GBPB$L_VBNSEQNO(R5)	; number from value block.
	BRB	40$			; And branch to exit with success.
30$:	CMPL	BLB$L_VALSEQNO(R4),-	; Compare lock value number with
		BDB$L_VBNSEQNO(R5)	; BDB sequence number.
	BNEQ	50$			; NEQ cached copy is invalid.
	BBSC	#BLB$V_IOLOCK,-		; Know bucket must be read in if set.
		BLB$B_BLBFLGS(R4), READ_BKT ; Clear so it doesn't remain set.
40$:
	MOVL	R5, R4			; Set address of BDB into R4.
	RMSSUC				; Note success
	BRB	SETR5			; Branch to exit.
50$:

;
; Bucket must be read because sequence numbers don't match, meaning the
; cached copy is invalid.  
;

	MOVL	BLB$L_VALSEQNO(R4),-	; Update BDB copy of sequence num
		BDB$L_VBNSEQNO(R5)	; assuming success.  BDB will be deq'd
					; on errors.
READ_BKT:
	MOVL	R5, R4			; Get BDB/GBPB addr into R4 for read.
	BSBW	RM$RDBUFWT		; Read in the bucket.
	BLBC	R0, ERREX		; Branch on error.
SETR5:
	MOVL	BDB$L_ADDR(R4), R5	; Buffer address into R5.
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	ASSUME	BDB$B_BID EQ GBPB$B_BID
	BLBC	BDB$B_BID(R4), 10$	; Br if this is a BDB.
	MOVL	GBPB$L_GBD_PTR(R4), R1	; Get ptr to GBD.
	BISB2	#GBD$M_VALID, GBD$B_FLAGS(R1) ; Set valid for gbl buffer.
	RSB				; Return.
10$:	REMQUE	(R4), R4		; Take out of current position.
	INSQUE	(R4), IFB$L_BDB_FLNK(R10) ; And stick it up front.
EXIT:
	RSB				; Done
ERREX:
	MOVL	#RLS$M_DEQ, R3		; Force complete release of buffer.
ERRX:	PUSHL	R0			; Save the error code.
	MOVL	R5, R4			; BDB/GBPB addr into R4 for release.
	BSBW	RM$RELEASE		; And release the buffer.
	POPR	#^M<R0>			; Restore error code.
	RSB				; And Return.
ERREX1:
	CMPW	#RMS$_RLK&^XFFFF, R0	; Was it not queued? (nowait was set)
	BNEQ	ERREX			; NEQ, it was something else.
	TSTL	BLB$L_LOCK_ID(R4)	; Was this already locked?
	BEQL	ERREX			; EQL no so DEQ entirely.
	CLRL	R3			; No need to DEQ then.
	BRB	ERRX			; Br to release it.


	.SBTTL	BUFF_ONLY path.
BUFF_ONLY:

;
; Always use local buffer for scratch buffer.
;

	DECW	IFB$W_AVLCL(R10)	; Note use of local buffer.
	BGEQ	10$			; GEQ if have enough.
	BSBW	RM$FREE_LCL		; Free up a buffer.
	BLBS	R0, 10$			; Branch if success.
	INCW	IFB$W_AVLCL(R10)	; Restore count.
	RSB				; Return with error in R0.
10$:
	BSBW	RM$GET_LCL_BUFF		; Go get a free buffer.
	INCW	BDB$W_USERS(R5)		; Note in use.
	MOVL	R5, R4			; Return BDB addr in R4.
	RMSSUC				; Note success.
	BRB	SETR5			; Set R5 and return.

	.SBTTL	SCAN_LOCKS Search BLB list for BLB.
;++
;	SCAN_LOCKS
;
;	Scan BLB list for match on desired vbn.  If BDB for that
;	vbn is found, note BDB address.  If BLB free or this stream
;	owns it, then note that also.
;	GBPB's are only reported if this stream already has it
;	accessed.  (Only 1 GBPB per accessor, ever).
;
; Calling sequence:
;
;	BSBW	SCAN_LOCKS
;
; Input Parameters:
;
;	R1 - VBN of bucket desired
;	R3 - CSH flags.
;	R9 - IFAB/IRAB address
;	R10 - IFAB
;	  IFB$L_BLBFLNK - listhead for BLB list
;
; Output Parameters:
;
;	R0 - success if non-accessed BLB or BLB owned by this
;		stream is found.
;	   - failure otherwise.
;
;	R4 - BLB address if R0 success, undefined otherwise.
;
;	R5 - BDB address of BDB for bucket R1 if any present, regardless
;		of R0 status.  Zero if no BDB for bucket R1 at all.
;	     GBPB address only if this stream currently has it accessed.
;
; Side effects:
;
;	If existing deferred writeback buffer accessed for a locker,
;	then the DFW flag in the BLB is cleared.
;	AP destroyed.
;--

SCAN_LOCKS:
	CLRL	R5			; Init BDB return.
	MOVAL	IFB$L_BLBFLNK(R10), R0	; Save for end test
	MOVL	R0, R4			; Get start of list
10$:
	ASSUME	BLB$L_FLNK EQ 0
	MOVL	(R4), R4		; Get next BLB
	CMPL	R4, R0			; At end of list?
 	BEQL	50$			; EQL get a free one
	CMPL	BLB$L_VBN(R4), R1	; Is this the one?
	BNEQ	10$			; NEQ then try next one

;
; A BLB for the requested bucket has been located.
; If this stream already owns it, return with success.
; 

	MOVL	BLB$L_BDB_ADDR(R4), AP	; Pick up BDB/GBPB address.
	CMPL	BLB$L_OWNER(R4), R9	; Does this stream own it?
	BEQL	30$			; Br if so.
	TSTL	AP			; Was there a BDB/GBPB?
	BEQL	10$			; No, keep looking.
	ASSUME	BDB$B_BID EQ GBPB$B_BID
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	BLBS	GBPB$B_BID(AP), 10$	; Ignore all other GBPB's.
	MOVL	AP, R5			; Note BDB address.
	MOVL	BLB$L_OWNER(R4), AP	; Pick up owner, if any.
	BEQL	20$			; No owner, then use it.
	CMPL	R10, AP			; Is the ifab the owner?
	BNEQ	10$			; If not, keep looking.

;
; This is a BLB for the desired bucket, with the ifab as the owner.
; It is a deferred write buffer (DFW).  If this stream only wants read
; access to the buffer, then simply use this BLB.  No conversion will
; be done in that case, which means a blocking AST to write back the
; buffer can occur at any time.  This is not a problem because readers
; don't modify the buffer.
; If the bucket is to be locked, the DFW flag is used to interlock access
; to this BLB.  By clearing the flag, the blocking AST is inhibited from
; writing back the buffer while it is being modified.  The buffer will
; be written back when this access is complete.
; If the DFW flag is already clear, it indicates that a write back is
; already in progress.  In that case, this thread must be stalled
; until the writeback is complete.
; This avoids the need to send a blocking AST in the normal multistream case.
; Dirty buffers are therefore passed from stream to stream, although
; they are not passed from process to process.
;

	ASSUME	CSH$V_LOCK EQ 0
	BLBC	R3, 20$			; If only a reader, take the buffer.
	BBSC	#BLB$V_DFW,-		; Branch unless writeback is
		BLB$B_BLBFLGS(R4), 20$	; already in progress.
	MOVL	R9, BLB$L_OWNER(R4)	; Note thread that is stalling.
	BISB2	#BLB$M_LOCK, BLB$B_BLBFLGS(R4) ; Note that thread is stalling.
	MOVQ	R2, -(SP)		; Save registers.
	BSBW	RM$STALL		; Wait for writeback to complete.
	MOVQ	(SP)+, R2		; Restore registers.
20$:
	RMSSUC				; Note success.
	RSB				; Return.

;
; BLB was found which we own.  Note the BDB/GBPB address and return success.
;

30$:	MOVL	AP, R5			; Note BDB/GBPB address.
	BRB	20$			; Return success.
50$:	CLRL	R0			; Note failure.
	RSB				; Return.

;++
;	GET_BLB
;
;	Look for free BLB from the end of list to the front.
;	A 'free BLB' has a zero vbn field.
;
; Calling sequence:
;
;	BSBW	GET_BLB
;
; Input parameters:
;
;	R10 -	ifab address
;		BLB$L_FLNK - BLB listhead forward link
;		BLB$L_BLNK - BLB listhead backward link
;
;	R9  -	structure which will own lock (ifab/irab)
;
;	R1  -	VBN to be accessed by bucket lock
;
; Output parameters:
;
;	R4  -	address of free BLB
;
; Side effects:
;
;	BLB returned in R4 is moved to head of BLB chain.
;	AP destroyed.
;	Bugcheck if no BLB is available.
;
;--

GET_BLB:
	ASSUME	BLB$L_BLNK EQ <BLB$L_FLNK + 4>
	ASSUME	IFB$L_BLBBLNK EQ <IFB$L_BLBFLNK + 4>
	MOVAL	IFB$L_BLBFLNK(R10), R4	; Get list head.
	MOVL	R4, AP			; Save for end test.
100$:	MOVL	4(R4), R4		; Get back link.
	CMPL	R4, AP			; Back at list head?
	BEQL	110$			; If so, then bugcheck
	TSTL	BLB$L_VBN(R4)		; This one free?
	BNEQ	100$			; No, move on to next one.
	MOVL	R9, BLB$L_OWNER(R4)	; Note owner.
	MOVL	R1, BLB$L_VBN(R4)	; Note resource.
	REMQUE	(R4), R4		; Remove from current place in chain.
	INSQUE	(R4), IFB$L_BLBFLNK(R10) ; Put in front to find quick.
	RSB				; Return.
110$:
	RMSPBUG	FTL$_NOBLB		; Should always find one.

;++
;	RM$FREE_LCL
;
; Toss the oldest least valuable buffer out of the cache.  This
; routine is called when the AVLCL count is less than zero, meaning
; that all BLB's are being used either for caching or access of a
; bucket.  It does not necessarily mean that there are no BDB's free
; because multiple BLB's may be tied up referencing a single BDB.
; Nonetheless, a BDB must be tossed out of the cache to free up its
; associated BLB.
;
; Calling sequence:
;
;	BSB	RM$FREE_LCL
;
; Input Parameters:
;
;	R10 -	Ifab address
;	    IFB$L_BDB_BLNK - back link of BDB listhead.
;	R9 - Thread to stall (if necessary)
;
; Output Parameters:
;
;	R0  -	status value from call to RM$RELEASE
;		DME - all valid BDB's were in use.
;
; Side effects:
;
;	AP destroyed.
;
;--

RM$FREE_LCL::
	PUSHR	#^M<R1,R2,R3,R4>	; Save registers.
	CLRL	-(SP)			; Init last BDB seen.
	MNEGL	#1, R4			; Init last cache value.
					; This should always cause the first
					; BDB possible to be selected.
	ASSUME	BDB$L_FLINK EQ 0
	ASSUME	BDB$L_BLINK EQ <BDB$L_FLINK + 4>
	MOVAL	IFB$L_BDB_FLNK(R10), R0	; Get list head into R0.
	MOVL	R0, AP			; Save for end test.
10$:
	MOVL	4(R0), R0		; Get next BDB.
	CMPL	R0, AP			; End of chain?
	BEQL	20$			; EQL means at end.
	ASSUME	BDB$B_BID EQ GBPB$B_BID
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	BLBS	BDB$B_BID(R0), 10$	; Continue scan if gbpb.
	TSTW	BDB$W_USERS(R0)		; Is this one accessed?
	BNEQ	10$			; NEQ it is - keep going.
	TSTL	BDB$L_VBN(R0)		; See if valid.
	BEQL	10$			; Continue search for valid BDB.
	CMPB	BDB$B_CACHE_VAL(R0), R4	; Less valuable than what has already
					; been seen?
	BGEQU	10$			; GEQU, then just keep looking.
	MOVL	R0, (SP)		; Save this BDB address.
	MOVZBL	BDB$B_CACHE_VAL(R0), R4	; Save this as lowest seen.
	BNEQ	10$			; If non-zero, keep trying.
	POPL	R4			; Pop BDB address off stack.
	BRB	50$			; Use the first BDB with zero value.

;
; At end of list.  If anything was noted, then use it.
; If no BDB's can be tossed out, scan the BLB list for a deferred write
; BLB, and DEQ that lock.
;

20$:
	POPL	R4			; Load R4 with BDB address.
	BNEQ	50$			; Go free it, if one found.
	ASSUME	BLB$L_FLNK EQ 0
	ASSUME	BLB$L_BLNK EQ <BLB$L_FLNK + 4>
	ASSUME	IFB$L_BLBBLNK EQ <IFB$L_BLBFLNK + 4>
	MOVAL	IFB$L_BLBFLNK(R10), R2	; Address of listhead.
	MOVL	R2, AP			; Save for end test.
30$:	MOVL	4(R2), R2		; Get next BLB (going backwards).
	CMPL	R2, AP			; Done yet?
	BEQL	40$			; EQL then at end of list.
	CMPL	BLB$L_OWNER(R2), R10	; Does ifab own this lock?
	BNEQ	30$			; No, check the next one.

;
; Have found a lock with the ifab as the owner.  This is a deferred
; write lock.  Get the BDB address into R4 and branch into code to
; release this lock and free the BLB.
;

	MOVL	BLB$L_BDB_ADDR(R2), R4	; Want BDB address in R4.
	BRB	55$			; And go release it.
40$:
	RMSERR	DME			; Couldn't find anything to release.
	BRB	80$			; Branch to exit.

50$:

;
; A BDB has been selected to toss out of the cache.  Release it, forcing
; write-thru if dirty.  The RLS$M_DEQ flag causes the buffer to be
; completely released and made available.
;
; Check now to see if a writeback is already in progress on this
; BLB.  If so, then stall until it is complete.
; At this point, we know there are no other accessors to this bucket,
; and therefore the BLB_PTR must point to the deferred write
; BLB if there is one.
;

	MOVL	BDB$L_BLB_PTR(R4), R2	; Get the BLB address.
	BEQL	60$			; No locking, just dequeue then.
	TSTL	BLB$L_OWNER(R2)		; Any owner for this lock?
	BEQL	60$			; EQL then it's not dirty.
55$:	MOVL	R9, BLB$L_OWNER(R2)	; Note thread that is stalling.
	BBSC	#BLB$V_DFW,-		; Branch if writeback has not
		BLB$B_BLBFLGS(R2), 60$	; started and claim this BLB.
	BISB2	#BLB$M_LOCK, BLB$B_BLBFLGS(R2) ; Note this thread is stalled.
	BSBW	RM$STALL		; Stall until writeback complete.
60$:
	BBCC	#BDB$V_AST_DCL,-	; Branch if no writeback has been done.
		BDB$B_FLGS(R4), 70$
	BLBC	BDB$L_IOSB(R4), 90$	; Branch if an error has occured.
70$:	MOVL	#RLS$M_DEQ, R3		; Init release flags to release lock.
					; DEQ flag implies write thru if dirty.
	INCW	BDB$W_USERS(R4)		; Make it look accessed.
	BSBW	RM$RELEASE		; And release it.
80$:	POPR	#^M<R1,R2,R3,R4>	; Restore registers.
	RSB				; Return.
90$:
	MOVZWL	BDB$L_IOSB(R4), RAB$L_STV(R8) ; Store i/o error code.
	RMSERR	WER			; Note error with RMS code.
	BRB	80$			; and return.

;++
;	SCAN_LCL_CACHE
;
;	Search list of all BDB's for match on the VBN field.
;
; Calling sequence:
;
;	BSB	SCAN_LCL_CACHE
;
; Input Parameters:
;
;	R10 - ifab address
;	    IFB$L_BDB_FLNK - forward link of BDB listhead.
;
;	R1 - VBN of bucket desired
;
; Output Parameters:
;
;	R5 - address of BDB that matches desired VBN or 0 if not found
;--

SCAN_LCL_CACHE:
	MOVAL	IFB$L_BDB_FLNK(R10), R5	; Address of BDB listhead.
	MOVL	R5, AP			; Save for end test.
10$:
	ASSUME	BDB$L_FLINK EQ 0
	MOVL	(R5), R5		; Get next BDB.
	CMPL	R5, AP			; At end of list yet?
	BEQL	50$			; EQL yes, quit.
	CMPL	BDB$L_VBN(R5), R1	; Is this the right one?
	BNEQ	10$			; No, try next one.
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	BLBS	BDB$B_BID(R5), 10$	; Not a BDB.  Continue search.
20$:	RSB				; Return.
50$:	CLRL	R5			; Note failure.
	RSB				; Return.

;++
;     RM$GET_LCL_BUFF
;
;	Search list of BDB's from the end of list to the front for
;	one with VBN=0, USERS=0, and SIZE large enough.
;
; Calling sequence:
;
;	BSBW	RM$GET_LCL_BUFF
;
; Input Parameters:
;
;	R1 - VBN desired
;	R2 - Size of bucket
;	R10 - Ifab address
;	  BDB_BLNK - Back BDB link
;
; Output Parameters:
;
;	R5 - BDB address
;	  VBN set to R1
;	  NUMB set to R2
;
; Side effects:
;
;	NOLCLBUF bugcheck if no BDB is found.
;
;--

RM$GET_LCL_BUFF::
	ASSUME	BDB$L_FLINK EQ 0
	ASSUME	BDB$L_BLINK EQ <BDB$L_FLINK + 4>
	ASSUME	IFB$L_BDB_BLNK EQ <IFB$L_BDB_FLNK + 4>
	MOVAL	IFB$L_BDB_FLNK(R10), R5	; Get BDB list head.
	MOVL	R5, AP			; Save for end test.
10$:
	MOVL	4(R5), R5		; Get next BDB.
	CMPL	R5, AP			; At end of list?
	BEQL	100$			; Bug if none found in list.
	TSTL	BDB$L_VBN(R5)		; This buffer free?
	BNEQ	10$			; NEQ it's in use.  Continue search.
	TSTW	BDB$W_USERS(R5)		; In use?
	BNEQ	10$			; NEQ in use, try another.
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	BLBS	BDB$B_BID(R5), 10$	; It's not a BDB.  Continue search.
	CMPW	BDB$W_SIZE(R5), R2	; Is this buffer large enough?
	BLSSU	10$			; LSSU not big enough - try another.

	CLRL	BDB$L_BLB_PTR(R5)	; Make sure this is 0.
	MOVL	R1, BDB$L_VBN(R5)	; Found one- store VBN.
	MOVW	R2, BDB$W_NUMB(R5)	; Store size desired.
	BBC	#IFB$V_MSE, (R10), 20$	; Branch if not multistreaming.
	BISB2	#BDB$M_NOLOCATE, BDB$B_FLGS(R5) ; Don't allow locate mode.
20$:	RSB

100$:	RMSPBUG	FTL$_NOLCLBUF		; Should always find one.

;++
;	LOCK_BKT
;	This routine is called to obtain a lock for the requested bucket
;	for either read only or modify.  In addition, it may also be known
;	that the lock must be of a high enough mode to interlock an i/o
;	operation.  The following lock manager modes are used:
;
;	LCK$K_PWMODE if holding modified buffer.  No conversion will
;		be done if this is not a LOCK request to cache.
;	LCK$K_EXMODE for all locks.
;
; Calling sequence:
;
;	BSBW	LOCK_BKT or
;
; Input Parameters:
;
;	R10 -	ifab address
;	    IFB$L_SFSB_PTR - pointer to shared file synchronization block
;		SFSB$L_LOCK_ID - lock id of shared file lock
;
;	R9  -	ifab/irab address
;	    IRB$B_EFN - event flag to use.
;
;	R4  -	BLB address
;	    BLB$B_MODEHELD - mode of lock currently held.
;	    BLB$L_LOCK_ID - ID of lock if one already held
;	    BLB$L_RESDSC - resource name descriptor (should point to BLB$L_VBN)
;
;	R3  -	Cache flags (same as input to RM$CACHE).
;
; Output Parameters:
;
;	R0  -	status value of SYS$ENQ service after call to RM$MAPERR.
;
; Side effects:
;
;	BLB$L_LKSTS field contains value of ENQ service.
;	BLB$L_VALBLK contains value block for lock requested.
;	BLB$L_OWNER is set to R9 (LOCK_BKT entry only).
;	BLB$B_MODEHELD contains mode of lock obtained.
;	BLB$B_BLBFLGS contain the cache flags also (LOCK_BKT entry only).
;
;	R1 is always destroyed.
;	If lock not granted synchonously, will return at AST level with
;	event flag (IRB$B_EFN) set and AP, R2, and R3 will be destroyed.
;
;	Bugcheck if SFSB lock not present.
;
;--

LOCK_BKT:
	MOVL	R9, BLB$L_OWNER(R4)	; Note owning stream.
	ASSUME	CSH$V_LOCK EQ 0
	ASSUME	CSH$V_NOWAIT EQ 1
	ASSUME	CSH$V_NOREAD EQ 2
	ASSUME	CSH$V_NOBUFFER EQ 3
	ASSUME	BLB$V_LOCK EQ 0
	ASSUME	BLB$V_NOWAIT EQ 1
	ASSUME	BLB$V_NOREAD EQ 2
	ASSUME	BLB$V_NOBUFFER EQ 3
	EXTV	#0,#4,R3,R0		; Extract csh flags of interest.
	INSV	R0,#0,#4,BLB$B_BLBFLGS(R4) ; Store in blb flags field.

;
; The lock may currently be held in NL, PW or EX mode.
; NL mode is used to cache local buffers.
; PW mode is used when a modified buffer is held locally.
; EX mode is normally used when a bucket is accessed.
; The exception is that if a PW lock is already held and only a read
; lock on the bucket is desired, no conversion is necessary.
; PW is converted to EX for modify access to eliminate the possibility of
; a blocking AST arriving during the access.
;

	MOVL	#LCK$K_PWMODE, R1	; Assume read lock desired.
	ASSUME	BLB$V_LOCK EQ 0
	BLBC	BLB$B_BLBFLGS(R4), 10$	; Branch if write lock not wanted.
	MOVL	#LCK$K_EXMODE, R1	; Get exclusive lock.
10$:	CMPB	BLB$B_MODEHELD(R4), R1	; Is high enough mode held already?
	BLSSU	30$			; LSSU then need to ENQ.
	RMSSUC				; Success!
	RSB				; Return.
30$:
	PUSHL	#LCK$K_EXMODE		; Save mode desired on the stack.
	TSTL	BLB$L_LOCK_ID(R4)	; Is lock already held?
	BEQL	35$			; Eql then this is new lock request.
	BISW2	#1, 2(SP)		; Note this as a conversion.
;
; Build argument list for ENQ on the stack.  No blocking AST is desired,
; so start with the AST parameter.
;

	ASSUME	<ENQ$_ACMODE + 4> EQ ENQ$_PROT
35$:	CLRQ	-(SP)			; Default protection and mode.
	ASSUME	<ENQ$_BLKAST + 4> EQ ENQ$_ACMODE
	CLRL	-(SP)			; Don't want blocking AST.
	ASSUME	<ENQ$_ASTPRM + 4> EQ ENQ$_BLKAST
	PUSHL	R9			; AST parameter is IFAB/IRAB.
	ASSUME	<ENQ$_ASTADR + 4> EQ ENQ$_ASTPRM
	PUSHAL	RM$STALLAST		; AST completion routine.
	MOVL	IFB$L_SFSB_PTR(R10), R0 ; Get address of SFSB.
	BEQL	200$			; Br if none (bug).
	ASSUME	<ENQ$_PARID + 4> EQ ENQ$_ASTADR
	PUSHL	SFSB$L_LOCK_ID(R0)	; Parent lock ID.
	ASSUME	<ENQ$_RESNAM + 4> EQ ENQ$_PARID
	PUSHAL	BLB$L_RESDSC(R4)	; Address of resource descriptor.
	ASSUME	<ENQ$_FLAGS + 4> EQ ENQ$_RESNAM
	PUSHL	#LCK$M_SYSTEM!LCK$M_SYNCSTS!LCK$M_VALBLK ; Lock flags.
	BLBC	<8*4>+2(SP), 40$	; If set this is a conversion.
	BISL2	#LCK$M_CONVERT, (SP)	; This is a conversion.
40$:	BBC	#BLB$V_NOWAIT, BLB$B_BLBFLGS(R4), 50$ ; Br if wait desired.
	BISL2	#LCK$M_NOQUEUE, (SP)	; Don't want to wait for this lock.
50$:	ASSUME	<ENQ$_LKSB + 4> EQ ENQ$_FLAGS
	PUSHAL	BLB$W_LKSTS(R4)		; Address of lock status block.
	ASSUME	<ENQ$_LKMODE + 4> EQ ENQ$_LKSB
	MOVZWL	9*4(SP), -(SP)		; Saved lock mode for lock.
	ASSUME	<ENQ$_EFN + 4> EQ ENQ$_LKMODE
	BSBW	RM$SETEFN		; Get EFN as last arg.
	ASSUME	ENQ$_NARGS EQ 11
	CALLS	#11, @#SYS$ENQ		; And go get the lock.
	BLBC	R0, 110$		; Exit on error.
	CMPW	#SS$_SYNCH, R0		; Need to stall?
	BEQL	100$			; EQL all done.
	BSBW	RM$STALL
70$:	MOVZWL	BLB$W_LKSTS(R4), R0	; Get completion status into R0.
	BLBC	R0, 110$		; Branch on error.
	POPL	R1			; Recover lock mode requested.
	MOVB	R1, BLB$B_MODEHELD(R4)	; Store lock mode in blb.
	RSB				; Return.
100$:	BSBW	RM$DEALLEFN		; Deallocate event flag flags.
	BRB	70$

;
; An error occured on the ENQ service.  Deadlock errors may occur
; normally because of the deferred write mechanism and are simply
; requeued.
;

110$:
	CMPW	#SS$_DEADLOCK, R0	; Was it deadlock?
	BEQL	35$			; Try it again if it was.
	CMPW	#SS$_EXENQLM, R0	; Exceed our lock quota?
	BEQL	150$			; Br if yes.
	CMPW	#SS$_NOLOCKID, R0	; Lock id table full?
	BEQL	150$			; Br if yes.
120$:	ADDL2	#4, SP			; 'Pop' requested lock mode.
	MOVL	#RMS$_ENQ, R1		; Default error code.
	BRW	RM$MAPERR		; Try to map error and return.

;
; This is either a case where we've exceeded our lock quota or the system
; lock id table is full.  It may be the case that something can be tossed
; out of our local cache and thereby free up a lock to continue with this
; operation.  If that fails, return with the original error.  Otherwise,
; requeue the lock request.
;

150$:	PUSHL	R0			; Save this error code.
	BSBW	RM$FREE_LCL		; Try to free a buffer.
	BLBC	R0, 160$		; Branch on failure.
	POPR	#^M<R0>			; Pop error off stack.
	BRW	35$			; Go try request again.
160$:	POPR	#^M<R0>			; Restore error code.
	BRB	120$			; Return with original error.

200$:
	RMSPBUG	FTL$_NOSFSB

;++
; 
; SCAN_GBL
;
; Scan global cache for match on desired bucket.
;
; Calling sequence:
;
;	BSBW	SCAN_GBL
;
; Input parameters:
;
;	R10 - ifab address
;	  GBH_PTR - pointer to global buffer header area
;
;	R1 - vbn of desired bucket
;
; Output parameters:
;
;	R0 - success
;	R5 - GBPB address
; else
;	R0 - failure (0)
;	R5 - addr of next lower valued GBD or zero if no GBPB found.
;
; Side effects:
;	AP destroyed.
;
;--

SCAN_GBL:
	MOVL	IFB$L_GBH_PTR(R10), R0	; Get pointer to gbl header.
	MOVL	R0, AP			; Save for later.
10$:
	ASSUME	GBH$L_GBD_FLNK EQ 0
	ASSUME	GBD$L_FLINK EQ 0
	ASSUME	GBD$L_VBN EQ GBH$L_HI_VBN
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BGEQU	20$			; GEQU either found it or not here.
	ADDL2	(R0), R0		; Get address of next GBD element.
	CMPL	GBD$L_VBN(R0), R1	; Is this one desired bucket?
	BLSSU	10$			; LSSU then keep scanning.
20$:	BEQL	30$			; EQL we found it - finish up.

	INCL	GBH$L_MISS(AP)		; Note cache miss.
	ASSUME	GBH$L_GBD_BLNK EQ 4
	ASSUME	GBD$L_BLINK EQ 4
	ADDL3	4(R0), R0, R5		; Get addr of previous element.
	CLRL	R0			; Note failure.
	RSB				;
30$:
	INCL	GBH$L_HIT(AP)		; Note cache hit and drop through.

;++
;
; GET_GBPB
;
; Branch or drop through to this point after locating GBD to get a 
; GBPB and point it to GBD.
;
; Input parameters:
;	R10 - ifab
;	  BDB_FLNK - BDB (and GBPB) listhead.
;	R0 - GBD address
;
; Output parameters:
; If	R0 - success
; then	R5 - GBPB address
; else	R5 = 0 if GBPB not found.
;
;--
GET_GBPB:
	MOVAL	IFB$L_BDB_FLNK(R10), R5	; BDB/GBPB listhead.
	MOVL	R5, AP			; Save for end test.
10$:
	ASSUME	BDB$L_FLINK EQ 0
	ASSUME	BDB$L_BLINK EQ 4
	MOVL	4(R5), R5		; Get next element.(going backwards)
	CMPL	R5, AP			; Back to listhead yet?
	BEQL	100$			; That's a bug.
	ASSUME	BDB$B_BID EQ GBPB$B_BID
	ASSUME	<BDB$C_BID & 1> EQ 0
	ASSUME	<GBPB$C_BID & 1> EQ 1
	BLBC	BDB$B_BID(R5), 10$	; Branch if BDB and keep looking.
	TSTW	GBPB$W_USERS(R5)	; Make sure it's not in use.
	BNEQ	10$			; NEQ it is, so keep looking.
;
; Found the GBPB.  Fill in relevant data from GBD.
;
	INCW	GBD$W_USECNT(R0)	; Bump use count.
	MOVL	R0, GBPB$L_GBD_PTR(R5)	; Pointer to GBD.
	MOVL	GBD$L_VBN(R0), GBPB$L_VBN(R5) ; Bucket vbn.
	ASSUME	<GBD$W_NUMB + 2> EQ GBD$W_SIZE
	ASSUME	<GBPB$W_NUMB + 2> EQ GBPB$W_SIZE
	MOVL	GBD$W_NUMB(R0), GBPB$W_NUMB(R5) ; Numb and size fields.
	MOVB	#BDB$M_VAL!BDB$M_NOLOCATE,- ; Init flags.
		GBPB$B_FLGS(R5) 	;
	MOVL	IFB$L_GBH_PTR(R10), AP	; Get pointer to gbl header.
	ADDL3	GBD$L_REL_ADDR(R0), AP, GBPB$L_ADDR(R5) ; Addr of buffer.
	RMSSUC				; Note success.
	RSB				;
100$:
	CLRL	R0			; Note failure.
	CLRL	R5			; Note no gbpb.
	RSB				;

;++
;
; FIND_FREE_GBL
;
; This routine is called when the desired bucket was not in the
; global cache.  Either find a free global buffer or toss one out
; of the cache to use.
;
; Input parameters:
;	R5 - Address of preceding GBD.
;
; Output parameters:
;
; R0 - success, failure
; R5 - GBPB addr if success.
;    - 0 if failure.
;
;--
FIND_FREE_GBL:
	PUSHR	#^M<R2,R3,R4,R5>
	CLRQ	R3			; Init lowest val, gbpb found.
	DECL	R3			; Make lowval -1.
	MOVL	IFB$L_GBH_PTR(R10), AP	; Get gbl header.
	ADDL3	GBH$L_GBD_BLNK(AP), AP, R0 ; Get last GBD in list.
	CMPL	GBD$L_VBN(R0), R3	; Is the vbn -1?
	BEQL	GOT_GBD			; EQL then just use this one.
;
; There are no available GBD's at the end of the list.
; Will have to select GBD to toss out of the cache.
;
	CLRL	-(SP)			; Note first pass.
	ADDL3	GBH$L_GBD_END(AP), AP, R5 ; End addr of scan.
	ADDL3	GBH$L_GBD_NEXT(AP), AP, R0 ; Starting point of scan.
	CMPL	GBH$L_GBD_START(AP),-	; Is NEXT pointer the
		GBH$L_GBD_NEXT(AP)	; same as the START of GBD's?
	BNEQ	10$			; NEQ then make two passes.
	INCL	(SP)			; Else only make one.
10$:	MOVL	GBH$L_SCAN_NUM(AP), R2	; Number of GBD's to search.
LTOP:
	TSTW	GBD$W_USECNT(R0)	; This one in use?
	BNEQ	LTST			; NEQ it is. Br to loop test.
	CMPB	GBD$B_CACHE_VAL(R0), R3	; Is this lowest cache value seen?
	BGEQU	SCANTST			; GEQU lower has been seen.  Ignore it.
	MOVL	R0, R4			; Save this GBD addr.
	MOVZBL	GBD$B_CACHE_VAL(R0), R3	; Save this cache value.
	BEQL	USE_GBD			; Use first zero value one found.
SCANTST:
	SOBGTR	R2, LTST		; Keep scanning if counter not run out.
	BRB	USE_GBD			; Use what's been found.
LTST:
	ACBL	R5, #GBD$C_BLN, R0, LTOP ; Keep going if limit not hit yet.

	BBSS	#0, (SP), USE_GBD	; Br if second pass.
	ADDL3	GBH$L_GBD_START(AP), AP, R0 ; Start at beginning this time.
	ADDL3	GBH$L_GBD_NEXT(AP), AP, R5 ; End with current next ptr.
	SUBL2	#GBD$C_BLN, R5		; Back up one - did it first pass.
	BRB	LTOP			; Branch into loop.
USE_GBD:
	ADDL2	#4, SP			; Pop pass counter off stack.
	ADDL3	GBH$L_GBD_NEXT(AP), AP, R0 ; Get addr of this 'victim'
	TSTB	GBD$B_CACHE_VAL(R0)	; Is it already zero?
	BEQL	10$			; EQL then can't age anymore.
	DECB	GBD$B_CACHE_VAL(R0)	; Age him a unit.
10$:	ADDL2	#GBD$C_BLN, GBH$L_GBD_NEXT(AP) ; Move on to next GBD next time.
	CMPL	GBH$L_GBD_NEXT(AP), GBH$L_GBD_END(AP) ; Is this past GBD's?
	BLEQU	20$			; LEQU it's still in range.
	MOVL	GBH$L_GBD_START(AP), GBH$L_GBD_NEXT(AP) ; Else reset to start.
20$:	MOVL	R4, R0			; Get addr of GBD to use.
	BEQL	ERXIT			; EQL didn't find one.

GOT_GBD:
	POPR	#^M<R2,R3,R4,R5>	; Restore registers.
;
; R0 = GBD to use
; R1 = vbn desired
; R2 = size of bucket
; R5 = previous GBD from search scan.
;

;
; Remove this GBD from current position in queue.
;
	ASSUME	GBD$L_FLINK EQ 0
	ASSUME	GBD$L_BLINK EQ 4
	ADDL3	(R0), R0, AP		; Addr of successor
	ADDL2	4(R0), 4(AP)		; Succ blnk = this blnk.

	ADDL3	4(R0), R0, AP		; Addr of predecessor.
	ADDL2	(R0), (AP)		; Pred flnk = this flnk.
;
; Init this GBD.
;
	ASSUME	<GBD$B_FLAGS + 1> EQ GBD$B_CACHE_VAL
	CLRW	GBD$B_FLAGS(R0)		; Init flags, cache value.
	MOVL	R1, GBD$L_VBN(R0)	; Fill in vbn of bucket.
	MOVW	R2, GBD$W_NUMB(R0)	; Note size of bucket.

	CMPL	R0, R5			; Did we select the previous GBD?
	BNEQ	10$			; NEQ no.
	ADDL2	4(R5), R5		; Get the previous one then.
10$:
	SUBL3	R0, R5, AP		; AP = offset from me to predecessor.
	MOVL	AP, 4(R0)		; My back link is to predecessor.
	ADDL3	(R5), AP, (R0)		; My flnk = predecessor's flnk.

	MNEGL	AP, (R5)		; Pred flnk = me. (Opp of me to pred).

	ADDL3	(R0), R0, AP		; AP = successor.
	SUBL3	AP, R0, 4(AP)		; Succ blnk = me.
	BRW	GET_GBPB		; Fill in GBPB.

ERXIT:
	POPR	#^M<R2,R3,R4,R5>	; Restore registers.
	CLRL	R5			; Note no GBPB.
	RSB				; R0 is already zero.
	.END
