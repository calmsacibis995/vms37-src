	$BEGIN	RM0XPFN,005,F$RMSOPEN0,<EXPAND FILENAME STRING>


;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: RMS
;
; Abstract:
;
;	This module expands the user supplied primary, default, and related
;	file name strings by the translation of logical names and the
;	application of defaults to form a fully qualified file specification.
;
; Environment: VAX/VMS, executive mode
;
; Author: Leo F. Laverdure,	Creation Date:  01-MAR-1977
;
; Modified By:
;
;	V03-005	KRM0015		K R Malik		22-Apr-1982
;		For a network filespec, stop resolving leading hyphens in the
;		directory string (at the local node), because the hyphen has
;		meaning only in the context of the default directory at the
;		remote node. For example, in a directory string of the form
;		[-.A.B], the hyphen should be passed to FAL.
;
;
;	V03-004	JAK0076		J A Krycka		20-Apr-1982
;		Scan foreign filespec within a quoted string for wildcard
;		characters, and set the NAM$V_WILDCARD bit if any found.
;
;	V03-003	JAK0073		J A Krycka		12-Apr-1982
;		Eliminate the practice of prefixing a <del> character to a
;		resultant name string to indicate that the password has been
;		masked out of the nodespec. If the resultant name string is
;		then used as a related name string this flag character was
;		used to tell RMS to translate the nodespec string to obtain
;		the original nodespec with the real password. Now NXTFLD will
;		examine the access control string for a substring of 'pasword'
;		(setting V_PWD if found) to signal that the nodespec string
;		should be translated.
;
;	V03-002	KEK0029		K. E. Kinnear 		24-Mar-1982
;		Return FNM error when we first get a quoted string (which
;		we think is ANSI) and THEN get a node spec later.  Always
;		used to give an FNM error before the advent of ANSI strings.
;
;	V03-001	RAS0079		Ron Schaefer		17-Mar-1982
;		Add support for translation table mask (FAB$B_DSBMSK).
;		All three $TRNLOG services are affected.
;
;	V02-104	KEK0025		K. E. Kinnear		15-Feb-1982
;		Stop parse scan the first time we reach PRSXIT with
;		FWA$V_NODE and FWA$V_QUOTED set, since we'll not use
;		anything else anyway, and we could get errors if 
;		there is an ANSI-"a" in the related string.
;
;	V02-103	KEK0024		K. E. Kinnear		11-Feb-1982
;		Prevent quoted names (a la ANSI) from being legal when
;		we've seen a node name to prevent conflict with use
;		of the FWA$V_QUOTED.
;
;	V02-102	KEK0018		K. E. Kinnear		15-Jan-1982
;		Add modifications for quoted ANSI-"a" filespecs.
;		Note well the re-use of the FWA$V_QUOTED -- if 
;		FWA$V_QUOTED and FWA$V_NODE set then it means there is
;		a network quoted string.  If FWA$V_QUOTED is set and
;		FWA$V_NODE is not set, it means that FWA$Q_NAME holds a
;		quoted file name for use with magtape.
;
;	V02-101	TMK0044 	Todd M. Katz		28-Dec-1981
;		Perform the file name and file type syntax check of TMK0031
;		only during the related-file parse of an output-file. This
;		requires adding a check for an output-file parse in progress
;		since the check for the related-file parse is already made.
;		Also, move the check for legal version syntax into CHECK_FIELD.
;
;		Also, take out all the changes of TMK0031 regarding the setting
;		of the NAM FNB bits with the exception of the DIRWCFLG field.
;		These bits must and will continue to represent the INPUT to the
;		parse, and NOT the result of the parse. The DIRWCFLGS field 
;		will continue to represent the outcome of the parse,
;
;	V02-100	TMK0039		Todd M. Katz	24-Dec-1981
;		Forgot to comment code added in TMK0038. I guess I really 
;		wanted number 100, and so it subconciously slipped my mind.
;		The algorithm change in TMK0031 broke the handling of 
;		partially wild output-file directories with trailing asterisks
;		and related-file directory specifications without any wild
;		(sub)directories. Fix this.
;
;	V02-099	TMK0038		Todd M. Katz	24-Dec-1981
;		Fix double underscore stuff so it "works". It broke because of
;		RAS0056 when some more sanity routines were added, and register
;		context got lost.
;
;	V02-098	TMK0031		Todd M. Katz	22-Dec-1981
;		Made a number of changes affecting output-file specifications
;		in general. First of all sticky directories: if the related
;		file has no wild (sub)directories, and the output-file has
;		a trailing ellipsis, no directory substitution takes place,
;		and the result of the output-file parse is the directory
;		specification that went in minus the ...; thus, [rms...] would
;		yield [rms]. Also, RAS0056 introduced a bug that completely 
;		blew away sticky directories. R7 context was not being lost,
;		which was the reason for the TMK0027 fix, but was being reset.
;
;		Second: added a check so that the only legal wild filename in 
;		a output-file during related-file parsing would be "*".
;
;		Third: added the same check for file type.
;
;		Forth: added the same check for file version, but made it more 
;		general in that the only legal wild file version field would be
;		"*".
;
;		Finally, changed what the NAM FNB bits are set to as the 
;		outcome of the parse of the file specification. These bits are
;		now set to reflect the contents of the expanded-name string. If
;		a particular field in the expanded-name string is wild, the
;		corresponding FNB bit is set as will be the wildcard summary
;		bit. However, if a formerly wild field is defaulted during 
;		related-file parsing, its corresponding FNB bit is cleared.
;		This was not previously the case.
;
;	V02-097	RAS0056		Ron Schaefer	21-Dec-1981
;		Upcase/compression logical name translations before checking
;		for concealed devices.
;
;	V02-096	TMK0027		Todd M. Katz	18-Dec-1981
;		More sticky directory stuff. If the output-file directory
;		specification is [*] or [*...], and the related-file directory
;		specification is [] (from a mag tape for example), immediately
;		return success. 
;
;		Also, when probes where added in RAS0051, they completely broke
;		sticky directories because they ended up clobbering the 
;		contents of R7 (the address of the RLF string required by the 
;		NXTFIELD subroutine) within STICKY_DIR.
;
;	V02-095	RAS0051		Ron Schaefer	18-Dec-1981
;		Correct incorrect/inadequate probing of NAM blocks.
;
;	V02-094	RAS0055		Ron Schaefer	16-Dec-1981
;		Correct RAS0050 for explicit _device names.
;
;	V02-093	TMK0020		Todd M. Katz	01-Dec-1981
;		Fix up sticky directory code. UIC behavior is taken into 
;		account, totally wild directories are restricted to [*], 
;		[*...], and [*,*], and UIC and UFD formats are not allowed
;		to mix. The complete algorithm, as modified, may be found 
;		prefacing the routine STICKY_DIR. In addition, UIC directory
;		lengths (in FWA$B_DIRLEN) are now computed, and UICs are 
;		treated as having 1 subdirectory in the subdirectory bit field
;		beginning at FWA$V_DIR_LVLS. NEW SOURCE !
;
;	V02-092	RAS0050		Ron Schaefer	23-Nov-1981
;		Correct the retention of explicit leading "_" so that
;		it is only retained on the actual device named used.
;
;	V02-091	RAS0040		Ron Schaefer	16-Oct-1981
;		Implement rooted directories for concealed devices.
;		Make the parsing utility routine UPCASE_COMPRESS into
;		a global routine: RM$UPCAS_CMPRS.
;		Add DFLT_MFD flag bit support.
;
;	V02-090	RAS0036		Ron Schaefer	14-Sep-1981
;		Complete RAS0034 by changing to "__" and removing the special
;		case input checks for "_.".
;
;	V02-089	RAS0034		Ron Schaefer	10-Sep-1981
;		Change the hidden device parsing logic to be triggered by
;		"_." and remove the TMH0087 change.
;
;	V02-088	TMK0008		Todd M. Katz	08-Sep-1981
;		Change a BGEQ to a BGEQU within the subroutine PROCESS_ELIPSIS
;		so that the directory specifications eight levels deep are
;		parsed correctly.
;
;	V02-087	TMH0087		Tim Halvorsen	07-Sep-1981
;		Disable RAS0029 if the equivalence string contains a
;		directory spec which must be processed.
;
;	V02-086	RAS0031		Ron Schaefer	1-Sep-1981
;		Fix buffer swap bug for _device parsing so that the
;		proper buffer is used for $TRNLOG.
;
;	V02-085	RAS0029		Ron Schaefer	20-Aug-1981
;		Change device parse logic so that a logical name that
;		translates as "_xxx" is treated as if it did not translate
;		at all.  This is step 1 in allowing us to hide physical
;		device names, and allow multiple systems per disk.
;
;	V02-084	JAK0059		J A Krycka	16-JUN-1981
;		Revise RM$CHKNAM to correctly handle extended NAM block size
;		and to include mode of caller when probing the structure.
;
;	V02-083	CDS0001		C Saether	04-Jun-1981
;		Only clear Dupok for translate on fna_pass.  This allows
;		duplicate name elements from other than FNA translations to be
;		merged into equivalence string without error.
;
;	V02-082	JAK0058		J A Krycka	22-MAY-1981
;		Move RM$EXPSTRING code from this module to a new module named
;		RM0NAMSTR. Also move NWA initialization code from this module
;		to a new module named NT0NWASET.
;
;	V02-081	KRM0014		K R Malik	11-May-1981
;		Change applies to code now in RM0NAMSTR.
;
;	V02-080	PSK0003		Paulina Knibbe	27-Apr-1981
;		Fix some problems with FWA$B_DIRLN.
;
;	V02-079 KPL0009		Peter Lieberwirth	22-Apr-1981
;		Fix bug when default directory is 8 levels deep and
;		DCL command $SET DEFAULT [-] gives an error because code
;		was not written to handle the boundary condition.
;
;	V02-078	KRM0013		K R Malik	22-Apr-1981
;		Change applies to code now in RM0NAMSTR.
;
;	V02-077	PSK0002		P S Knibbe	13-Jan-1981
;		Modify sticky dir support:
;		   add [*...]
;		       [*]
;		   remove [dir.*.dir]
;		  	  [dir...dir]
;
;	V02-076	PSK0001		P S Knibbe	13-Nov-1980
;		Add support for sticky directories on output file parse
;
;	V02-075	JAK0047		J A Krycka	22-AUG-1980
;		Fix UPCASE_COMPRESS which incorrectly handles a null character
;		following a quoted string.
;
;	V02-074	REFORMAT	J A Krycka	26-JUL-1980
;
;	V01-073	JAK0044		J A Krycka	18-MAR-1980
;		Change applies to code now in RM0NAMSTR.
;
;	V01-072	TMH0005		Tim Halvorsen	05-FEB-1980
;		Give error if attempting to back over MFD with minus.
;		Fix bug which caused error if defaulting UIC format directory
;		with '[]'.
;
;	V01-071	JAK0038		J A Krycka	31-JAN-1980
;		If FAB$V_NAM is set in a network context, use the resultant
;		name string (if present) as the file spec to simulate open by
;		Name Block. Also add $RMSDEF invocation.
;
;	V01-070	JAK0034		J A Krycka	06-JAN-1980
;		Change applies to code now in RM0NAMSTR.
;
;	V01-069	JAK0030		J A Krycka	30-NOV-1979
;		Fix bug introduced by V057 change which incorrectly treats a
;		zero DNA field as an error.
;
;	V01-068	JAK0027		J A Krycka	08-NOV-1979
;		Change applies to code now in RM0NAMSTR.
;
;	V01-067	JAK0026		J A Krycka	30-OCT-1979
;		Allow user filename strings on input to RMS (FNA, DNS, etc.)
;		to be 255 characters long, instead of 128.
;
;	V01-066	TMH0004		Tim Halvorsen	20-OCT-1979
;		Change applies to code now in RM0NAMSTR.
;
;	V01-065	JAK0025		J A Krycka	08-OCT-1979
;		Change applies to code now in RM0NAMSTR.
;
;	V01-064	TMH0003		Tim Halvorsen	02-OCT-1979
;		Fix code to insert MFD into spec if empty so that it doesn't
;		insert MFD if network node is present. Also removed spurious
;		instruction to set the address of Q_DIR1+4 to SP when
;		defaulting network specs like [.sub].
;
;	V01-063	TMH0002		Tim Halvorsen	30-SEP-1979
;		Fix bug which caused DIR_LVLS to be set incorrectly if minus
;		was found in directory spec.
;
;	V01-062	JAK0025		J A Krycka	26-SEP-1979
;		Change applies to code now in RM0NAMSTR.
;
;	V01-061	JAK0023		J A Krycka	17-SEP-1979
;		Fix bug in node-spec parsing that prematurely re-uses registers
;		causing node-spec stickness on input file parse to fail and an
;		invalid error path to be taken on node name syntax error.
;
;	V01-060	TMH0001		Tim Halvorsen	06-SEP-1979
;		Allow elipsis through wildcard directory specification and
;		mark the elipsis in the descriptor of its predecessor.
;
;	V01-059	JAK0023		J A Krycka	20-AUG-1979
;		Allow multiple node-specs to appear in a file specification
;		and similarly enhance logical node name translation to permit
;		an equivalence string to represent multiple node-specs.
;
;	V01-058	FED0002		F E Deen	07-AUG-1979
;		Allow wild card characters to pass through parse unscathed.
;
;	V01-057	FED0001		F E Deen	07-AUG-1979
;		Upcase lowercase characters in a file specification and remove
;		spaces and horizontal tabs, except do not alter characters
;		between quotes.
;
;	V01-056	JAK0022		J A Krycka	23-JUL-1979
;		Fix bug in quoted string syntax checking.
;
;	V01-055	JAK0021		J A Krycka	01-JUL-1979
;		Divide NOD error into NOD and ACS error codes.
;
;	V01-054	RAN0001		R A Newell	19-MAR-1979
;		Probe Name Block for write access.
;
;	V01-053	JAK0006		J A Krycka	14-FEB-1979
;		Change applies to code now in RM0NAMSTR.
;
;	V01-052	JAK0007		J A Krycka	07-FEB-1979
;		Change applies to code now in RM0NAMSTR.
;
;	V01-051	JAK0007		J A Krycka	19-JAN-1979
;		Fix bug in logical node name translation.
;
;	V01-050	JAK0007		J A Krycka	15-JAN-1979
;		Initialize node name translation counter and buffer flag.
;
;	V01-049	JAK0016		J A Krycka	16-DEC-1978
;		Miscellaneous clean-up prior to DECnet V1.1 code freeze.
;
;	V01-048	JAK0012		J A Krycka	15-DEC-1978
;		Fix bug that prohibits related file parse from supplying
;		node name if all other file elements have been found.
;
;	V01-047	JAK0007		J A Krycka	01-DEC-1978
;		Make node name a candidate for logical name translation.
;
;	V01-046	JAK0006		J A Krycka	21-NOV-1978
;		Change applies to code now in RM0NAMSTR.
;
;--

	.SBTTL	DECLARATIONS

;
; Include Files:
;

	$FABDEF				; Define File Access Block symbols
	$IFBDEF				; Define IFAB symbols
	$NAMDEF				; Define Name Block symbols
	$FWADEF				; Define File Work Area symbols
	$TRNLOGDEF			; Define Translate Logical Name symbols
	$LOGDEF				; Define Logical Name Table symbols
	$PSLDEF				; Define Process Status Longword symbols
	$NWADEF				; Define Network Work Area symbols
	$RMSDEF				; Define RMS completion codes

;
; Macros:
;

;++
; NXTFLD ...
;
; This macro generates a call to the NEXT_FIELD subroutine,
; building in-line offsets to action routines to handle the cases
; where the input string was null or did not contain a terminator
; character. (The action routine offsets must be forward referencing!)
;--

	.MACRO	NXTFLD EOS,NULL,DISP=W,?L
	BSB'DISP	NEXT_FIELD
L:	.BYTE	EOS-L
	.BYTE	NULL-L-1
	.IF	DF EOS
	.IF	LE <EOS-L>
	.ERROR				; Offset to EOS is negative - not allowed;
	.ENDC
	.ENDC
	.IF	DF NULL
	.IF	LE <NULL-L-1>
	.ERROR				; Offset to NULL is negative - not allowed;
	.ENDC
	.ENDC
	.ENDM	NXTFLD

;++
; CHKFLD ...
;
; This macro generates a call to the CHECK_FIELD subroutine,
; building in-line arguments to specify desired checks and operations
; and the fixed parameters necessary to carry them out.
;
; The CHECKS=   parameter specifies which bits in the R2
;		output from NXTFLD must not be on, whether
;		the field is the name or type field, and whether
;		return is to be made in-line on an error rather
;		than popping the return PC and branching to PRSERR.
;
; The MAXSIZ=   parameter specifies the maximum length of the field.
;
; The FIELD=    parameter specifies the FWA offset to the
;		string descriptor for the field and the bit
;		in the FWA flags longword.
;
; The ERR=      parameter defines the error code to be output
;		if this field is in error.
;--

	.MACRO	CHKFLD CHECKS,FIELD,MAXSIZ=63,ERR,DISP=W
	BSB'DISP	CHECK_FIELD
	.WORD	CHECKS
	.BYTE	MAXSIZ
	.BYTE	FWA$V_'FIELD
	.BYTE	FWA$Q_'FIELD
	RMSERR_WORD	ERR
	.ENDM	CHKFLD

;
; Equated Symbols:
;

	FOP=FAB$L_FOP*8			; Bit offset to FOP
	WC=FWA$B_WILDFLGS*8		; Bit offset to wild card flags
	WCNTV_MASK=<1@<FWA$V_WC_NAME-WC>>!-
	<1@<FWA$V_WC_TYPE-WC>>!-
	<1@<FWA$V_WC_VER-WC>>		; Wild name, type, or ver mask

;
; The following symbols are used by the NXTFLD and CHKFLD routines:
;

	V_NULL		= 0		; Field contains no characters
					;  (terminator only)
	V_ALPHA		= 1		; Field contains uppercase alphas
	V_NUMERIC	= 2		; Field contains numerics
	V_NOT_OCTAL	= 3		; Field contains '8' or '9'
	V_$_		= 4		; Field contains '$' or '_'
	V_WILD		= 5		; Field contains '*' or '%'
	V_MINUS		= 6		; Field contains leading '-'
	V_NAMTYP	= 7		; This field is either a filename or
					;  filetype (input to CHKFLD only)
	V_NOTERM	= 8		; Field terminated by end-of-string
					;  rather than terminator
	V_INVALID	= 9		; Field contained one or more illegal
					;  characters or non-leading minus sign
	V_ACS		= 10		; Field contains a node name followed by
					;  an access control string
	V_NOT_COPIED	= 11		; Duplicate field was not copied
					;  to element buffer (output from
					;  CHKFLD only)
	V_QUOTED	= 12		; Field contained a valid quoted 
					;  ANSI-"a" string
	V_PWD		= 13		; Password has been masked out of the
					;  access control string
	V_RETURN_ON_ERR	= 15		; Check field subroutine is to
					;  return an error rather than pop
					;  return PC and branch to PRSERR

;
; Mask versions of the above symbols:
;

	M_NULL		= 1@V_NULL
	M_ALPHA		= 1@V_ALPHA
	M_NUMERIC	= 1@V_NUMERIC
	M_NOT_OCTAL	= 1@V_NOT_OCTAL
	M_$_		= 1@V_$_
	M_WILD		= 1@V_WILD
	M_MINUS		= 1@V_MINUS
	M_NAMTYP	= 1@V_NAMTYP
	M_NOTERM	= 1@V_NOTERM
	M_INVALID	= 1@V_INVALID
	M_ACS		= 1@V_ACS
	M_NOT_COPIED	= 1@V_NOT_COPIED
	M_QUOTED	= 1@V_QUOTED
	M_PWD		= 1@V_PWD
	M_RETURN_ON_ERR	= 1@V_RETURN_ON_ERR

;
; Other definitions:
;

	ESCAPE		= ^X1B		; ASCII escape character
	SEMICOLON	= ^X3B		; ASCII value for semi-colon
	LOWERCASE_A	= ^X61		; ASCII value for lower case a
	LOWERCASE_Z	= ^X7A		; ASCII value for lower case z
	SPACE		= ^X20		; ASCII value for space
	HOR_TAB		= ^X09		; ASCII value for horizontal tab

;
; Own Storage:
;

DISK:	.ASCII	/SYS$DISK:/		; Default device string
	DISKSZ=.-DISK			;
	$NEWPSECT	F$RMSOPEN0NAM	;
EXPARGL:				;
	.BYTE	NAM$L_ESA		; Argument list for RM$EXPSTRING
	RMSERR_WORD	ESA		;
	RMSERR_WORD	ESS		;
	$PSECT_RESTORE			;

	.SBTTL	RM$XPFN - FILENAME EXPANSION CONTROL ROUTINE

;++
; RM$XPFN - four major routines are included here:
;
;	1.  RM$XPFN	-	high-level control routine to select
;				and verify the various strings to
;				be used to expand the filename.
;	2.  PARSE_STRING -	medium-level routine to parse an
;				individual string into its
;				constituent parts, translating
;				logical names, and merging the
;				results into the expanded string.
;	3.  NEXT_FIELD	-	low-level subroutine to scan the
;				input string, isolating a sub-string
;				(field) terminated by a delimiting
;				character and returning information
;				about the contents of that field.
;	4.  CHECK_FIELD	-	low-level subroutine that works
;				with the output of NEXT_FIELD,
;				performing checks and other
;				functions as directed by PARSE_STRING.
;
; The high-level control routine, RM$XPFN performs the following functions:
;
;	1.  probes the filename string and calls PARSE_STRING to parse it.
;
;	2.  if not all filename fields (device, directory, filename, 
;	    filetype, and file version) are present applies defaults
;	    in the order:
;
;		- default filename string (if any)
;		- related file (if any) for filename and/or filetype only
;		- default device by applying the logical name 'SYS$DISK:'
;		  (only if node not specified)
;		- default file directory as currently established
;		  (by login or the set default command) (only if
;		  node not specified)
;
;	3.  if a NAM block is specified and it includes an expanded
;	    string buffer, the expanded string will be copied to
;	    the buffer.
;
; <continued> ...

;
; Calling Sequence:
;
;	BSBW	RM$XPFN
;
; Input Parameters:
;
;	R8	FAB address
;	R9	IFAB address
;
; Implicit Inputs:
;
;	The contents of the FAB and related NAM block if any,
;	in particular the fields FNA, FNS, DNA, DNS, RLF, and NAM.
;		- if RLF specified, NAM in the related FAB and
;		  RSA and RSL in the NAM block
;		- if NAM, ESA and ESS
;
;	Also, the contents of the various logical name tables,
;	Especially with respect to the various system-defined names.
;
;	Also, the current default directory string.
;
;	FWA and NWA inputs:
;
;	FWA$Q_XLTBUF1	- descriptor of  63-char scratch buffer in FWA
;	FWA$Q_XLTBUF2	- descriptor of  63-char scratch buffer in FWA
;	FWA$Q_NODE	- descriptor of 127-char buffer in NWA
;	FWA$Q_DEVICE	- descriptor of  15-char buffer in FWA
;	FWA$Q_DIR1	- descriptor of   9-char buffer in FWA
;	FWA$Q_DIR2	- descriptor of   9-char buffer in FWA
;	FWA$Q_DIR2+8	- "
;	FWA$Q_DIR2+16	- "
;	FWA$Q_DIR2+24	- "
;	FWA$Q_DIR2+32	- "
;	FWA$Q_DIR2+40	- "
;	FWA$Q_DIR2+48	- "
;	FWA$Q_NAME	- descriptor of  10-char buffer in FWA
;	FWA$Q_TYPE	- descriptor of   4-char buffer in FWA
;	FWA$Q_VERSION	- descriptor of   6-char buffer in FWA
;	FWA$Q_QUOTED	- descriptor of 127-char buffer in NWA
;	FWA$Q_NODE1	- descriptor using shared node buffer in NWA
;	FWA$Q_NODE1+8	- "
;	FWA$Q_NODE1+16	- "
;	FWA$Q_NODE1+24	- "
;	FWA$Q_NODE1+32	- "
;	FWA$Q_NODE1+40	- "
;	FWA$Q_NODE1+48	- "
;	FWA$Q_NODE1+56	- "
;
;	Notes:
;		1.  the name, type, and version buffers must be
;		    adjacent and ascending in memory
;
;		2.  all other FWA fields should be zero
;
; Output Parameters:
;
;	R0	Status code
;	R1-R7	Destroyed
;	R10	FWA address
;	AP	Destroyed
;
; Implicit Outputs:
;
;	NAM block (if specified):
;		-if ESA specified buffer filled in with
;		 expanded filename string + ESL set to its
;		 length in bytes.
;
;	FWA:
;		-various flags set as per the parse
;		-FWA$B_DIRTERM set to directory terminating bracket (']' or '>')
;		-FWA$L_ESCSTRING set to escape string if seen
;		-the descriptors for the parsed filename elements
;		 are set with the sizes of the various elements
;		 of the filename string, the elements themselves
;		 having been copied to the buffers. The filetype
;		 and version are appended to the file name.
;
; Completion Codes:
;
;	Standard RMS completion codes, including:
;		SUC, FNA, DNA, RLF, SYN, NOD, DEV, DIR, FNM, TYP, VER, LNE,
;		QUO, NAM, ESA, ESS
;
; Side Effects:
;
;	None
;
;--

;+
; Entry point for RM$XPFN
;-

RM$XPFN::				;
	$TSTPT	XPFN			;
	BSBW	RM$FWASET		; Get a work page
	BLBC	R0,7$			; Branch on failure
	MOVZBL	#255,R2			; Size of largest user string
	BSBW	RM$GETSPC1		; Allocate scratch buffer
	BLBC	R0,7$			; Branch on failure
	MOVL	R1,FWA$L_BUF_PTR(R10)	; Save scratch buffer address
	BSBW	EXPAND_NAME		; Do bulk of work
	PUSHR	#^M<R0>			; Save status
	MOVZBL	#255,R2			; Size of scratch buffer
	MOVL	FWA$L_BUF_PTR(R10),R4	; Address of scratch buffer
	BSBW	RM$RETSPC1		; Return scratch buffer
	POPR	#^M<R0>			; Restore status
7$:	BLBC	R0,EXIT_XPFN		; Branch on failure
	CMPB	FWA$B_DIRLEN(R10),-	; Directory spec too long?
		#FWA$C_MAXDIRLEN	;
	BGEQU	DIR_TOO_LONG		; Branch if yes

;
; We have all the parts described separately.
; Append file type and version to the filename.
;

	TSTB	FWA$B_ESCFLG(R10)	; Branch if this is a
	BNEQ	40$			;  process permanent file
	BBC	#FWA$V_QUOTED,(R10),9$	; Branch to 20$ if network quoted
	BBS	#FWA$V_NODE,(R10),20$	;  string found
9$:	MOVAQ	FWA$Q_NAME(R10),R6	; Get name descriptor
	MOVW	(R6),FWA$W_FNAMSIZ(R10)	; Save filename size
	ADDL3	(R6)+,(R6)+,R3		; Get address past name

	ASSUME	FWA$Q_TYPE EQ <FWA$Q_NAME+8>
	ASSUME	FWA$Q_VERSION EQ <FWA$Q_TYPE+8>
	ASSUME	FWA$T_TYPEBUF EQ <FWA$T_NAMEBUF+FWA$C_NAMBUFSIZ>
	ASSUME	FWA$T_VERBUF EQ <FWA$T_TYPEBUF+FWA$C_TYPBUFSIZ>

	MOVB	#^A/./,(R3)+		; Append '.' to delimit type
	BSBB	MOVNXT			; Append type
	BBC	#FAB$V_OFP+FOP,(R8),10$	; Branch if not output file parse
	BBC	#FWA$V_CUR_VER,(R10),10$; Branch if not wildcard version
	DECW	FWA$Q_VERSION(R10)	; Dec length to get rid of star ver
10$:	MOVB	#SEMICOLON,(R3)+	; Append ';'
	BSBB	MOVNXT			; And version
	SUBL3	FWA$Q_NAME+4(R10),R3,-	; Adjust length
		FWA$Q_NAME(R10)		;

;
; Modify node descriptors to include leading underscore where
; Appropriate. Note that this code is skipped for process permanent files.
;

20$:	BBC	#FWA$V_NODE,(R10),30$	; Branch if node name not seen
	INCW	FWA$Q_NODE(R10)		; Modify node descriptor to
	DECL	FWA$Q_NODE+4(R10)	;  include leading underscore
	INCW	FWA$Q_NODE1(R10)	; Modify node descriptor to
	DECL	FWA$Q_NODE1+4(R10)	;  include leading underscore
30$:	BBC	#FWA$V_DEV_UNDER,-	; Branch if device name was not
		(R10),40$		;  prefixed by an underscore
	INCW	FWA$Q_DEVICE(R10)	; Modify device descriptor to
	DECL	FWA$Q_DEVICE+4(R10)	;  include leading underscore

;
; If user has specified a NAM block and an expanded string buffer within it,
; give him the expanded name.
;

40$:	RMSSUC				; Declare success so far
	MOVAL	@FAB$L_NAM(R8),R7	; Get NAM block address
	BNEQ	SETNAM			; And branch if there is one
EXIT_XPFN:				;
	RSB				;

;+
; Fill in the expanded filename string and FNB status bits.
;-

SETNAM:	$PSECT_BR	F$RMSOPEN0NAM	;
	BSBB	RM$CHKNAMBLK		; Check access to NAM block
	BBC	#FAB$V_NAM+FOP,(R8),15$	; Branch if not doing open by NAM block
	TSTL	NAM$W_DID(R7)		; Was directory ID an input?
	BNEQ	XITNAM			; Branch if yes (don't output anything)
	TSTL	NAM$W_FID(R7)		; Do we have a file ID?
	BNEQ	XITNAM			; Branch if yes
	BBS	#NAM$V_NODE,-		; Branch if network access
		NAM$L_FNB(R7),XITNAM	;

;
; Return expanded name string to user's buffer.
;

15$:	MOVAB	EXPARGL,AP		; Address of RM$EXPSTRING argument list
	BSBW	RM$EXPSTRING		; Return expanded name string
	BLBC	R0,XITNAM		; Quit on error
;
; Fill in the filename status bits.
;

20$:	CLRL	NAM$L_FNB(R7)		; Clear the FNB
	INSV	FWA$B_WILDFLGS(R10),-	; Set low 9 bits
		#0,#9,NAM$L_FNB(R7)	;
	TSTB	FWA$B_ESCFLG(R10)	; PPF flag set?
	BEQL	40$			; Branch if not
	SSB	#NAM$V_PPF,NAM$L_FNB(R7); Yes, set flag
40$:	EXTZV	#FWA$V_NODE,#7,(R10),R1	; Get next 7 bits
	INSV	R1,#NAM$V_NODE,#7,-	;  and set them
		NAM$L_FNB(R7)		;

	ASSUME	NAM$V_WILD_UFD EQ 24

	MOVB	FWA$B_DIRWCFLGS(R10),-	; Set directory wildcard flags
		NAM$L_FNB+3(R7)		;
XITNAM:	RSB				; Return to caller of RM$XPFN
	$PSECT_RESTORE			;

;+
; Subroutine to append file type and version to the file name.
;
; Inputs:
;
;	R3	Destination address
;	R6	Descriptor of field to append
;
; Outputs:
;
;	R0-R5	Destroyed
;	R3	Address past last byte moved
;	R6	= R6 + 8 (The descriptor referenced by R6 is updated to point
;			 point to the moved string.)
;-

MOVNXT:	MOVL	(R6)+,R0		; Get length
	MOVL	(R6),R1			; Get address of string
	MOVL	R3,(R6)+		; Save destination address in desc
	MOVC3	R0,(R1),(R3)		; Move field
	RSB				;

	.SBTTL	RM$CHKNAMBLK, CHECK NAM BLOCK VALIDITY

;+
; Subroutine to verify that R7 really points to an accessible Name Block.
;
; Inputs:
;
;	R7	NAM block address
;
; Outputs:
;
;	If an error occurs, R0 is set to the error code, the return
;	PC is popped and an RSB is executed.
;-

	$NEWPSECT	F$RMSOPEN0NAM	;
RM$CHKNAMBLK::				;
	BSBB	RM$CHKNAM		; Check NAM block validity
	BLBS	R0,90$			; Branch if ok
	ADDL	#4,SP			; Pop the return PC
90$:	RSB				;

RM$CHKNAM::				;

	ASSUME	NAM$B_BLN EQ NAM$B_BID+1

	IFNORD	#NAM$B_BLN+1,(R7),ERRNAM; Branch if BID and BLN not readable
	CMPB	NAM$B_BID(R7),#NAM$C_BID; Right ID?
	BNEQ	ERRNAM			; Branch if not
	MOVZBL	NAM$B_BLN(R7),R0	; Get user specified size
	CMPB	R0,#NAM$C_BLN_V2	; Long enough (version 2 size)?
	BLSSU	ERRNAM			; Branch if not long enough
	IFNOWRT	R0,(R7),ERRNAM		; Branch if not writeable
	RMSSUC				; Success
	RSB				;

ERRNAM:	RMSERR	NAM			; Show problem
	RSB				;
ERRDVI:	RMSERR	DVI			; Invalid device ID field
	RSB				;
ERRRLF:	RMSERR	RLF			; Can't access related file name
	RSB				;
ERRRST:	RMSERR	RST			; Can't access resutlant name
	RSB				;
	$PSECT_RESTORE			; (back to F$RMSOPEN0)

;+
; Probe string described in <R6,R7> for readability.
; R9 must contain the IFAB address.
; The Z-bit is set if the probe fails.
;-

PROBESTRING:				;
	PROBER	IFB$B_MODE(R9),R6,(R7)	; Prober buffer
	RSB				;

;
; Handle errors
;

DIR_TOO_LONG:				;
	RMSERR	DIR			; Directory spec too long
	RSB
ERRFNA:	RMSERR	FNA			; Can't access filename string
	RSB
ERRDNA:	RMSERR	DNA			; Can't access default filename string
	RSB

	.SBTTL	EXPAND_NAME

;++
; EXPAND_NAME - controls the parsing of the primary, default, and related
;	filename strings and the application of the various defaults.
;
;	It performs these functions by selecting the next string for parsing,
;	verifying its readability, and calling PARSE_STRING to include it.
;
;	EXPAND_NAME is also called recursively by PARSE_STRING at the entry
;	point DFDIR to apply the default file directory when the directory
;	is of the form [] or [.sub-directory].
;
;	Same inputs as for RM$XPFN.
;
;	Same outputs except that the expanded name string is not built up from
;	the parts.
;--

EXPAND_NAME:				; Entry point

;
; Check for non-zero device ID in the Name Block and if found
; use it to provide a device name.
;

	BBC	#FAB$V_NAM+FOP,(R8),CHKFNA; Branch if NAM DVI not to be used
	$PSECT_BR	F$RMSOPEN0NAM	;
	MOVL	FAB$L_NAM(R8),R7	; Get NAM block address
	BEQL	10$			; Branch if none specified
	BSBB	RM$CHKNAMBLK		; Check it out
	MOVAB	NAM$T_DVI(R7),R5	; Get device ID string address
	MOVZBL	(R5)+,R6		; Get string length
	BEQL	25$			; Branch if zero
	CMPL	R6,#15			; Device ID > 15 chars?
	BGTRU	ERRDVI			; Branch if so

;+
;	MOVL	FWA$Q_XLTBUF2(R10),R7	; Get address of buffer to copy DVI
;	MOVC3	R6,(R5),(R7)		; Move the string
;	MOVB	#^A/:/,(R3)		; Append colon to device name
;
; Note:	The above three instructions were replaced with the following four
;	so that DVI string will be upcased and compressed.
;	Is this really necessary since RMS returns the DVI string in uppercase?
;-

	MOVL	R5,R7			; Now <R6,R7> => DVI string descriptor
	MOVL	FWA$Q_XLTBUF2+4(R10),R5	; Get address of buffer to copy DVI
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression while copying string
	MOVB	#^A/:/,(R7)[R6]		; Append colon to device name
	INCL	R6			;  and count it
	BSBW	PARSE_STRING		; Parse device name string
	BISB2	#FWA$M_NAM_DVI,(R10)	; Flag device came from NAM block
	MOVL	FAB$L_NAM(R8),R7	; Get NAM block address again
	BSBB	RM$CHKNAMBLK		; Check access
	TSTL	NAM$W_FID(R7)		; Is file ID non-zero?
	BEQL	10$			; Continue parse if not
	BBC	#IFB$V_CREATE,(R9),20$	; All done unless create
5$:	CLRL	NAM$W_FID(R7)		; Zero the file ID for create
10$:	BRW	CHKFNA			; Continue parse
20$:	BRW	ENDPRS			; All set for open by file ID

;
; Don't allow DID or FID to be used since DVI is bad.
;

25$:	CLRL	NAM$W_DID(R7)		; Zero the directory ID
	BBC	#NAM$V_NODE,NAM$L_FNB(R7),5$; Branch if not network access
	CLRL	NAM$W_FID(R7)		; Zero the file ID

;
; Open by Name Block is not supported over the network, but it can be simulated
; by using the resultant name string returned from a previous $SEARCH, $OPEN,
; etc. This facilitates network wildcard support as many utilities open by
; Name Block after finding the next file via a $SEARCH operation.
;

	MOVZBL	NAM$B_RSL(R7),R6	; Get resultant string length
	BEQL	5$			;  and branch if zero (i.e., ignore)
	MOVL	NAM$L_RSA(R7),R7	; Get resultant string address
	BEQL	5$			;  and branch if zero (i.e., ignore)
	BSBW	PROBESTRING		; Probe readability
	BEQL	ERRRST			; Branch if inaccessible
	MOVL	FWA$L_BUF_PTR(R10),R5	; Get address of scratch buffer
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression while copying string
	BSBW	PARSE_STRING		; Parse the string
	BRB	20$			; All done even if all file name
					;  elements are not present
	$PSECT_RESTORE			;

;+
; Process the primary filename specification.
;-

CHKFNA:	MOVZBL	FAB$B_FNS(R8),R6	; Get primary filename string size
	BEQL	CHKDNA			;  and branch if zero (i.e., ignore)
	MOVL	FAB$L_FNA(R8),R7	; Get primary filename string address
	BSBB	PROBESTRING		; Probe readability
	BEQL	ERRFNA			; Branch if inaccessible
	BISB2	#FWA$M_FNA_PASS,(R10)	; Flag this pass as special
					; For setting explicit type
					; And version flags
	MOVL	FWA$L_BUF_PTR(R10),R5	; Get address of scratch buffer
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression while copying string
	BSBB	PARSE_STRING		; Parse the string
	BICB2	#FWA$M_FNA_PASS,(R10)	; End of FNA pass

;+
; Process the default filename specification.
;
; Since PARSE_STRING returned, the filename is not fully qualified.
; Therefore, defaults must be applied.
;-

CHKDNA:	BISB2	#FWA$M_DUPOK,(R10)	; Indicate duplicate parts allowed
	MOVZBL	FAB$B_DNS(R8),R6	; Get default filename string size
	BEQL	CHKRLF			;  and branch if zero
	MOVL	FAB$L_DNA(R8),R7	; Get default filename string address
	BEQL	CHKRLF			;  and branch if zero
	BSBB	PROBESTRING		; Probe readability
	BEQL	ERRDNA			; Branch if inaccessible
	MOVL	FWA$L_BUF_PTR(R10),R5	; Get address of scratch buffer
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression while copying string
	BSBB	PARSE_STRING		; Parse the string

;+
; Process the related filename specification.
;
; The filename still is not fully qualified, so use related file to supply
; missing elements.
;-

CHKRLF:	MOVL	FAB$L_NAM(R8),R7	; Get NAM block address
	BEQL	CHKDEV			; Branch if not specified
	$PSECT_BR	F$RMSOPEN0NAM	;

;
; First check to see if the parse of the related file could supply
; any of the missing filename elements, and if not, avoid this step.
;

	BBC	#FAB$V_OFP+FOP,(R8),10$	; Branch if input file parse

	ASSUME	FWA$V_NAME EQ FWA$V_TYPE+1

	CMPZV	#FWA$V_TYPE,#2,(R10),#3	; Either name or type missing?
	BNEQ	15$			; Branch if yes (RLF can provide)
	BITB	#WCNTV_MASK,FWA$B_WILDFLGS(R10); Wild name, type or ver?
	BNEQ	15$			; Branch if yes (RLF can provide)
	BBS	#FWA$V_WILD_DIR,(R10),-	; Any wild directories ?
		15$			;  Branch if yes (RLF can provide)
	BRB	40$			; Don't both with RLF pass - no
					;  additional fields can be filled in
;
; This is an input file parse.
;

10$:	BBC	#FWA$V_NODE,(R10),15$	; Branch if node name missing

	ASSUME	FWA$V_NAME EQ FWA$V_TYPE+1
	ASSUME	FWA$V_DIR EQ FWA$V_NAME+1
	ASSUME	FWA$V_DEVICE EQ FWA$V_DIR+1

	CMPZV	#FWA$V_TYPE,#4,(R10),#15; Dev, dir, name or type missing?
	BEQL	40$			; Branch if not (RLF can't help)

;
; Pick up the related file name string.
;

15$:	BSBW	RM$CHKNAMBLK		; Check it out
	MOVL	NAM$L_RLF(R7),R7	; Get related NAM block address
	BEQL	40$			; Branch if not specified
	BSBW	RM$CHKNAMBLK		; Check it out
	MOVZBL	NAM$B_RSL(R7),R6	; Get resultant string length
	BEQL	40$			;  and branch if zero (i.e., ignore)
	MOVL	NAM$L_RSA(R7),R7	; Get resultant string address
	BSBW	PROBESTRING		; Probe readability
	BEQL	ERRRLF1			; Branch if inaccessible

;
; At last we have a related file name string; parse it; but, before we
; do the related-file parse, make sure if the parse is of an output-file,
; that the filename and file type, if they are wild, are legal in their 
; format (i.e. * and * only).
;

	BISB2	#FWA$M_RLF_PASS!FWA$M_DUPOK,(R10)
					; Flag parse of related filename
					;  and declare duplicates ok
	BBC	#FAB$V_OFP+FOP,(R8),30$	; skip syntax checks if input-file

	BBC	#FWA$V_WC_NAME,(R10),20$; skip check if filename not wild
	PUSHR	#^M<R11>		; save the impure area address
	MOVL	#FWA$Q_NAME,R11		; load offset to filename descriptor
	BSBW	CHECK_WLD_FIELD		; if filename is of a legal wild
	POPR	#^M<R11>		; type the continue after restoring
	BLBS	R0,20$			; the impure area address
	RMSERR	FNM			; otherwise, return the error status
	RSB				; error in filename


20$:	BBC	#FWA$V_WC_TYPE,(R10),30$; skip check if file type not wild
	PUSHR	#^M<R11>		; save the impure area address
	MOVL	#FWA$Q_TYPE,R11		; load offset to file type descriptor
	BSBW	CHECK_WLD_FIELD		; if file type is of a legal wild
	POPR	#^M<R11>		; type then continue after restoring
	BLBS	R0,30$			; the impure area address
	RMSERR	TYP			; otherwise, return the error status
	RSB				; error in file type

30$:	MOVL	FWA$L_BUF_PTR(R10),R5	; Get address of scratch buffer
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression while copying string
	BSBW	PARSE_STRING		; Parse the string
	BICB2	#FWA$M_RLF_PASS,(R10)	; Turn off old flag
40$:	BRW	CHKDEV			; Process default device
ERRRLF1:
	BRW	ERRRLF			; Branch aid
	$PSECT_RESTORE			;

;+
; The file name still is not fully qualified.
; Get system defaults unless node name was specified.
;-

CHKDEV:	BBS	#FWA$V_NODE,(R10),ENDPRS; All set if node present
	BBS	#FWA$V_DEVICE,(R10),CHKDIR; Branch if device present
	BISL2	#FWA$M_DUPOK,(R10)	; Reallow duplicates
	MOVAB	DISK,R7			; Point to logical name 'SYS$DISK'
	MOVZBL	#DISKSZ,R6		; Get length of string

;+
; Note:	It is not necessary to upcase and compress the string 'SYS$DISK'
;	because it is defined properly in this module. It's equivalence
;	string will be upcased and compressed, however.
;
;	MOVL	FWA$L_BUF_PTR(R10),R5	; Get address of scratch buffer
;	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
;					;  compressing while copying string
;-

	BSBB	PARSE_STRING		; Parse default device string

;+
; The filename string still is not fully qualified.
; Our last hope is to apply the default directory.
;
; Note:	It is not necessary to upcase and compress the default directory string
;	because RMS$SETDD calls RM$XPFN to parse a new string prior to storing
;	it in PIO$GT_DDSTRING, thereby assuring that the default directory
;	string has been upcased and compressed.
;-

CHKDIR:	BBS	#FWA$V_DIR,(R10),ENDPRS	; Branch if directory present
	BISL2	#FWA$M_DUPOK,(R10)	; Reallow duplicates
DFDIR:	MOVAB	@#PIO$GT_DDSTRING,R7	; Get address and size of default
	MOVZBL	(R7)+,R6		;  directory string
	BSBB	PARSE_STRING		; Parse default directory string

;
; End of parse - not necessarily all elements present,
; but at least problem free
;

ENDPRS:	RMSSUC				; Exit with success
	RSB				;

	.SBTTL	PARSE_STRING - PARSE INDIVIDUAL FILENAME STRING

;++
; PARSE_STRING - is the intermediate level filename string parser.
;	It accepts the particular string to be parsed as input from
;	EXPAND_NAME and breaks it up into its constituent filename
;	elements and either saves these (by moving them to the
;	appropriate element buffer) or discards them if they are
;	permissable duplicates.
;
;	If a node spec is seen, an immediate attempt is made to translate the
;	nodename portion of the string. If this succeeds and the equivalence
;	string consists of one or more concatenated node specs, then the
;	left-most node spec is isolated and the process is repeated until
;	logical node name translation fails. Then, the primary node spec is
;	moved to the node name element buffer and all secondary node specs are
;	are appended to it. Also, there are rules for defaulting access control
;	information with respect to the recursive logical node name translation
;	procedure.
;
;	If a logical/device name is seen, it is handled as follows:
;	Initially it is not moved; instead a descriptor is set-up to point
;	to it. After parsing all remaining elements of the string, an attempt
;	is made to translate the logical/device name as a logical name. If
;	this succeeds, the equivalence string is then in turn parsed and its
;	elements merged in or discarded as for the original string. If the
;	translation fails, the equivalence string (which is identical to the
;	logical/device name string minus a leading underscore, if any) is taken
;	as a physical device name and processed accordingly.
;
;	A logical/filename is treated similarly, with the following differences:
;	It is the only string element hence there is no need to continue
;	parsing the remainder of the input string. Moreover, if the translation
;	does not succeed the equivalence string is treated as a filename.
;
;	The general technique used by PARSE_STRING is to use the NEXT_FIELD
;	subroutine to isolate a single field, then to treat it as a node,
;	device, directory, or name element based upon the field terminator and
;	current context, and finally to use the CHECK_FIELD subroutine to
;	perform various checks on the field contents and copy the field to
;	the proper element buffer, setting the field's flag.
;
; Calling Sequence:
;
;	BSBW	PARSE_STRING
;
; Input Parameters:
;
;	R6	Filename string length
;	R7	Filename string address
;	R10	FWA address
;
; Implicit Inputs:
;
;	The current contents of the FWA.
;	The contents of the filename string input.
;	The contents of the logical name tables
;
; Outputs:
;
;	R0-R7	Destroyed
;	AP	Destroyed
;
; Implicit Outputs:
;
;	The FWA is updated as per the filename element seen
;
; Completion Codes:
;
;	PARSE_STRING returns to the caller only if there were no errors
;	encountered and there remain one or more missing filename elements
;	(node excluded). If either or these occur the return PC is popped
;	from the stack and, if an error, an RSB is performed with the status
;	code in R0 (standard RMS), else a branch to ENDPRS is taken.
;
; Side Effects:
;
;	None
;
;--

;+
; Entry point for PARSE_STRING.
;-

PARSE_STRING:
	$TSTPT	PARSES			;
	BICB2	#<FWA$M_NAMEFLG!FWA$M_TYPEFLG>,(R10); Clear temporary flags
NXTDEV:	NXTFLD	EOS=LOGNM_OR_FILENM,NULL=PRSXIT; Isolate first field
CHECK_COLON:				;
	CMPB	R3,#^A/:/		; Was colon terminator?
	BNEQ	CHECK_DIR		; If not go check for directory
	BRW	GOTCOLON		; Go process node or logical/device-name
NXTDIR:	NXTFLD	EOS=GOTNAME,NULL=CHECK_LOGNAME

;
; Check for directory
;

CHECK_DIR:				;
	CMPB	R3,#^A/[/		; Accept either '[' or '<'
	BEQL	10$			; As directory indicator
	CMPB	R3,#^A/</		;
	BNEQ	CHECK_NAME		; Branch if terminator neither < nor [
10$:	BRW	PARSE_DIR		; Go parse directory spec

;
; Get next name field.
;

NXTNAM:	NXTFLD	EOS=GOTNAME,NULL=CHECK_LOGNAME

;
; We should have some type of name.
; Maybe a filename, type, or version. Check terminator.
;

CHECK_NAME:				;
	CMPB	R3,#^A/./		; Was it a period?
	BEQL	GOTNAME			; Branch if yes
	CMPB	R3,#SEMICOLON		; How about semi?
	BEQL	GOTNAME
	BRW	ERRSYN			; Bad syntax

;
; We have a name:
;	it will be a filename unless we've seen one in which case
;	it will be a fileversion
;

GOTNAME:				;
	BBSS	#FWA$V_NAMEFLG,(R10),-	; Branch if name seen this  pass
		CHECK_TYPE		;
	BRW	NAME			; Go process filename

;
; File type unless already seen
;

CHECK_TYPE:				;
	BBSS	#FWA$V_TYPEFLG,(R10),VERSION; Branch if type seen this pass
	CHKFLD	CHECKS=<M_$_ !M_MINUS !M_NAMTYP !M_QUOTED>,-
		FIELD=TYPE,-
		MAXSIZ=FWA$C_MAXTYPE,ERR=TYP
	BBC	#FWA$V_FNA_PASS,(R10),NXTNAM; Branch if not primary name string
	BBS	#V_NOTERM,R2,CHECK_LOGNAME; Branch if terminated by EOS
	BBCS	#FWA$V_EXP_VER,(R10),NXTNAM; Set explicit version flag & branch

;
; File version - doesn't catch all possible errors.
;

VERSION:
	BBS	#V_NOTERM,R2,10$	; Branch if version terminated by eos
	SSB	#V_INVALID,R2		; EOS only legal terminator for version
10$:	CHKFLD	CHECKS=<M_$_ !M_ALPHA !M_QUOTED>,-
		FIELD=VERSION,-
		MAXSIZ=FWA$C_MAXVER,ERR=VER

;+
; The filename string has been parsed into its basic parts. Check to see
; if we got a logical name, and if so go attempt its translation.
;-

CHECK_LOGNAME:				;
	BBCC	#FWA$V_LOGNAME,(R10),PRSXIT; Branch if no logical name
	BBS	#FWA$V_NAM_DVI,(R10),10$; Branch if device came from NAM block
					;  (i.e., do the translation)
	BBS	#FWA$V_DEVICE,(R10),DEVDUP; Branch if device already seen

;
; Go attempt to translate the name.
; If no translation return here and treat as device name.
;

10$:	CLRL	R2			; Indicate no problems in field
	BSBW	TRANSLATE		;

;
; It appears as if it was a device name after all.
; Allow the name even if not in standard device name
; format - if truly invalid it will be caught when
; attempting to assign the channel.
; This allows flexibility for different device/controller/unit
; naming schemes as well as remote node logical names.
;

	CHKFLD	FIELD=DEVICE,-		; Copy field
		MAXSIZ=FWA$C_DEVBUFSIZ,ERR=DEV ; Unless too long
	BBS	#V_NOT_COPIED,R2,PRSXIT	; Only if we used this spec.
	CMPB	@FWA$Q_LOGNAME+4(R10),#^A/_/; Is 1st char an underscore?
	BNEQ	PRSXIT			; Branch if not
	SSB	#FWA$V_DEV_UNDER,(R10)	; Flag leading underscore

;+
; PRSXIT ...
;
; The parse of this string is complete.
;
; If this was the parse of the primary name string (FNA), handle explicit
; flags. In particular, use the explicit type and version flags to
; set the type and version seen flags (i.e., explicit nulls type and
; version cause no defaults to be taken for these fields).  Also,
; copy the current device and directory seen flags to the explicit
; device and directory.
;-

PRSXIT:					;
	BBC	#FWA$V_FNA_PASS,(R10),10$; Branch if not FNA pass

	ASSUME	FWA$V_EXP_VER EQ <FWA$B_WILDFLGS*8>
	ASSUME	FWA$V_EXP_TYPE EQ FWA$V_EXP_VER+1
	ASSUME	FWA$V_TYPE EQ FWA$V_VERSION+1

;
; If EXP_TYPE is not set but TYPE is set, then its ok, don't unconditionally
; overwrite TYPE.
;

	INSV	FWA$B_WILDFLGS(R10),-	; Set version from
		#FWA$V_VERSION,#1,(R10)	;  'explicit' flag
	BBC	#FWA$V_EXP_TYPE,(R10),5$ ; if EXP_TYPE not set, then ignore TYPE

	INSV	FWA$B_WILDFLGS(R10),-	; Set version and type from
		#FWA$V_VERSION,#2,(R10)	;  'explicit' flags

	ASSUME	FWA$V_EXP_DIR EQ FWA$V_EXP_DEV-1
	ASSUME	FWA$V_DIR EQ FWA$V_DEVICE-1

5$:	EXTZV	#FWA$V_DIR,#2,(R10),R0	; Get dev and dir
	INSV	R0,#FWA$V_EXP_DIR,#2,(R10); And set explicit dev & dir

;
; If we have a node name and quoted string, then stop the parse in its tracks
; and don't go looking for trouble
;

10$:	BBC	#FWA$V_NODE,(R10),15$	; if not network parse, then skip it
	BBS	#FWA$V_QUOTED,(R10),PRSXIT1 ; if quoted then stop parsing here

;
; Check for a fully qualified file name string.
; If any fields are missing, return to caller to apply defaults.
;

15$:	CMPB	FWA$B_FLDFLGS(R10),#FWA$C_ALL; All of dev,dir,nam,typ,ver found?
	BNEQ	20$			; Branch if not
	BBC	#FAB$V_OFP+FOP,(R8),PRSXIT1; Branch if input file parse
	BITB	#WCNTV_MASK,FWA$B_WILDFLGS(R10); Wild name, type, or ver?
	BNEQ	20$			; If yes, go apply defaults
	BBC	#FWA$V_WILD_DIR,(R10),-	; If any wild directories
		PRSXIT1			;  go apply defaults
20$:	RSB				; Return to apply defaults
PRSXIT1:				;
	POPR	#^M<R0>			; Pop return PC
	BRW	ENDPRS			; Exit from parse successfully

GOTNAME1:				; Branch aid
	BRW	GOTNAME			; Go process filename

;
; We have a terminator that was unexpected or other unrecognizable syntax.
; Give it a general syntax error.
;

ERRSYN:	$PSECT_BR	L$RMS0		;
	RMSERR	SYN			;
	BRB	PRSERR			;
	$PSECT_RESTORE			;

;+
; We have both a logical name and a device;
; ignore the logical name unless no duplicates allowed.
;-

DEVDUP:	BBS	#FWA$V_DUPOK,(R10),PRSXIT
	$PSECT_BR	L$RMS0		;
	RMSERR	DEV			;

;
; An error condition has been encountered.
; Error code is in R0 - pop the extra PC from the stack and return.
;

PRSERR:	POPR	#^M<R1>			;
	RSB				;
	$PSECT_RESTORE			;

;+
; We have a single field with no punctuation; it is either a
; logical name or a file name. In order for it to be a logical name
; the following must be true:
;
;	1.  there must be no other filename elements.
;	2.  it must translate.
;-

LOGNM_OR_FILENM:
	TSTB	FWA$B_FLDFLGS(R10)	; Any flags set?
	BEQL	10$			; No - continue

	ASSUME	FWA$V_DEVICE GE 8

	CMPB	FWA$B_FLDFLGS(R10),-	; Only device seen?
		#<FWA$M_DEVICE@-8>	;
	BNEQ	GOTNAME1		; No - treat as filename
	BBC	#FWA$V_NAM_DVI,(R10),-	; Branch, testing this as a filename
		GOTNAME1		;  unless device came from NAM block
10$:	BBS	#FWA$V_NODE,(R10),-	; Branch if node name seen
		GOTNAME1		;
	MOVQ	R4,FWA$Q_LOGNAME(R10)	; Store the descriptor
	BSBW	TRANSLATE		; Attempt translation, if translate 
					;  returns failure, its a filename
	CMPW	R0,#SS$_NORMAL		; Check status
	BEQL	GOTCOLON		; If success, treat as a device name
	MOVQ	R4,R6			; Say filename is really a filename
	BRW	NXTNAM			;  string and go check again since
					;  it could have had a leading
					;  underscore removed

;+
; Colon was terminator.
; If there is a second colon we have a node spec,
; otherwise it is alogical/device name.
;-

GOTCOLON:				;
	TSTL	R6			; Anymore input?
	BEQL	10$			; Branch if not
	CMPB	(R7),#^A/:/		; Another colon?
	BEQL	NODE_SPEC_LIST		; Yes - branch to process node spec

;
; Process logical/device name
;

10$:	CHKFLD	CHECKS=<M_NULL!M_WILD!M_MINUS!M_QUOTED>,-
		FIELD=LOGNAME,-
		MAXSIZ=FWA$C_XLTBUFSIZ,ERR=DEV
	BRW	NXTDIR			; Go get next field

;++
; We have a node spec string ...
;
; A file specification string may begin with a list of concatenated
; node spec strings (i.e., node1::node2::node3::dev:[dir]file.typ;ver).
; Further, the node name of the leading node spec is a candidate for iterative
; logical node name translation, where each equivalence string may yield one
; or more concatenated node spec strings!
;--

NODE_SPEC_LIST:				;
	$PSECT_BR	NL$NETWORK	;

;
; See if we've ever seen a quoted string before.  If we have, then its
; an immediate error since we would have thought it to be an ANSI string
; if NODE is not set.  Once seen, a quoted string can not have its identity
; changed.
;

	BBS	#FWA$V_NODE,(R10),10$	; if were already node, don't check
	BBC	#FWA$V_QUOTED,(R10),10$ ; and if not quoted, ok too
	RMSERR	FNM			; quick error
	BRW	PRSERR			; exit with file name error

;+
; Allocate space for the Network Work Area (NWA) unless it has already
; been allocated via previous pass thru this code.
;-

10$:	BBSS	#IFB$V_NWA,(R9),-	; Check/set one-shot allocation flag
		TRANSLATE_NODE		;  and branch if not first pass
	PUSHR	#^M<R2>			; Save NEXT_FIELD status flag word
	BSBW	NT$NWA_INIT		; Allocate and initialize NWA
	POPR	#^M<R2>			; Restore NEXT_FIELD status flag word
	BLBS	R0,TRANSLATE_NODE	; Branch on success
	CSB	#IFB$V_NWA,(R9)		; Clear NWA allocated flag so that
					;  no attempt to deallocate the
					;  space will be made during close
	BRW	PRSERR			; Take error exit

;+
; Logical node name translation...
;
; Attempt to translate the node name string of the (left-most) node spec.
; For the translation to succeed, the equivalence string must represent
; one or more concatenated node specs, i.e., each field must be delimited
; by a double colon.
;
; Note:	If node name is prefixed by underscore, no translation occurs
;	but the underscore is removed.
;
; Note:	If node name contains an access control string with the password masked
;	out, then an attempt is made to translate the string consisting of
;	<node name + access control string> as a special logical node name.
;-

	ASSUME	TRNLOG$_ACMODE EQ <TRNLOG$_DSBMSK-4>
	ASSUME	TRNLOG$_TABLE EQ <TRNLOG$_ACMODE-4>
	ASSUME	TRNLOG$_RSLBUF EQ <TRNLOG$_TABLE-4>
	ASSUME	TRNLOG$_RSLLEN EQ <TRNLOG$_RSLBUF-4>
	ASSUME	TRNLOG$_LOGNAM EQ <TRNLOG$_RSLLEN-4>
	ASSUME	TRNLOG$_NARGS EQ 6
	ASSUME	NWA$L_XLTBUFFLG EQ <NWA$L_XLTCNT+4>
	ASSUME	NWA$L_XLTSIZ EQ <NWA$L_XLTBUFFLG+4>
	ASSUME	NWA$Q_LOGNAME EQ <NWA$L_XLTSIZ+4>
	ASSUME	NWA$T_NODEBUF EQ <NWA$B_UNDERLINE+1>

TRANSLATE_NODE:				;
	PUSHR	#^M<R6,R7,R9>		; Save descriptor of rest of filespec
					;  string (starting at 2nd colon) and R9
	MOVL	IFB$L_NWA_PTR(R9),R9	; Get address of NWA
	CLRL	NWA$Q_ACS(R9)		; Zero ACS size/flag
	CLRL	NWA$Q_INODE(R9)		; Initialize intermediate node spec desc
	MOVAB	NWA$T_INODEBUF+NWA$C_INODESIZ(R9),NWA$Q_INODE+4(R9)
					; Note that strings will be added to
					;  buffer from right to left!
TRANSLATE_LOOP:				;
	BBC	#V_PWD,R2,10$		; Branch if password is not masked out
					;  of access control string of node spec
	CMPB	#^A/_/,(R5)		; Remove leading underscore character
	BNEQ	20$			;  (if present) before attempting
	DECL	R4			;  translation of special logical node
	INCL	R5			;  name string with password masked out
	BRB	20$			;
10$:	BSBW	PSEUDO_CHKFLD		; Validate node spec syntax
	BBC	#V_ACS,R2,20$		; Branch if there is no embedded access
					;  control string in node spec string
	LOCC	#^A\"\,R4,(R5)		; Find start of access control string
					;  on return <R0,R1> => ACS
	SUBL2	R0,R4			; Compute size of node name string
	TSTL	NWA$Q_ACS(R9)		; Ignore this access control string if
	BNEQ	20$			;  there is a default one in ACS buffer
	MOVL	R0,NWA$Q_ACS(R9)	; Save size of ACS
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVC3	R0,(R1),@NWA$Q_ACS+4(R9); Make this current default ACS string
	POPR	#^M<R2,R4,R5>		; Restore registers
20$:	MOVQ	R4,NWA$Q_LOGNAME(R9)	; Store descriptor of node name string
					;  to translate
	MOVAL	NWA$L_XLTCNT(R9),R1	; Get address of translation counter
	AOBLEQ	#10,(R1)+,30$		; Branch if < 10 translations done
	POPR	#^M<R6,R7,R9>		; Restore descriptor on entry and R9
	BRW	ERRLNE			; Declare error in logical name

;
; Attempt logical node name translation.
;

30$:	MOVZBL	FAB$B_DSBMSK(R8),-(SP)	; Search name tables desired
	PUSHL	#0			; Do not return mode of equiv string
	PUSHL	#0			; Do not return table of equiv string
	PUSHAQ	NWA$Q_XLTBUF1(R9)	; Specify address of descriptor of
					;  buffer to receive equivalence string
	MCOML	(R1),(R1)+		; Check if this buffer is free
	BNEQ	40$			; Branch if ok
	MOVAQ	NWA$Q_XLTBUF2(R9),(SP)	; Swap buffers
40$:	MOVL	(SP),R5			; Get address of descriptor selected
	MOVL	4(R5),R5		;  and save address of buffer to be used
	PUSHAL	(R1)+			; Specify address of word to receive
					;  equivalence string size
	PUSHAQ	(R1)			; Specify address of descriptor pointing
					;  to logical name candidate
	$TSTPT	NTXLATLOG		;
	CALLS	#6,@#SYS$TRNLOG		; Translate the logical name
	MOVZWL	NWA$L_XLTSIZ(R9),R4	; Store equivalence string size
					;  note: <R4,R5> => equivalence string
	CMPW	R0,#SS$_NORMAL		; Was translation successful?
	BEQL	50$			; Branch if yes
	BRW	TRANSLATE_FAIL		; Branch if not

;
; Process the equivalence string.
;

50$:	MOVQ	R4,R6			; Copy descriptor to required registers
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression in place
	NXTFLD	EOS=ERRNOD,NULL=ERRNOD	; On return <R4,R5> => next field found
	TSTL	R6			; Any characters beyond this field?
	BEQL	ERRNOD			; Branch if not
	CMPW	#^A\::\,-1(R7)		; The equivalence string must contain
	BNEQ	ERRNOD			;  one or more node specs
	INCL	R7			; Skip over 2nd colon delimiter
	SOBGTR	R6,INTERMED_NODE	; Branch if equivalence string has
					;  more than one node spec string
					; <R6,R7> => 2nd to nth node spec
	BRW	TRANSLATE_LOOP		; Try another translation

;
; Handle access control string and node name errors.
;

ERRACS:	RMSERR	ACS			; Declare error in access cntrl string
	BRB	ERRXIT			;
ERRNOD:	RMSERR	NOD			; Declare error in node name
ERRXIT:	POPR	#^M<R6,R7,R9>		; Restore descriptor on entry and R9
	BRW	PRSERR			; Exit with completion code in R0

;+
; Process 2nd to nth node specs found in the equivalence string.
; Node names in these node specs are not candidates for logical name
; translation. Also, any access control string supplied with the above
; logical name is the default (and overrides any) access control string
; for the last node spec of the equivalence string.
;-

INTERMED_NODE:				;
	MOVL	R2,NWA$L_SAVE_FLGS(R9)	; Save flags word output from NXTFLD
	MOVQ	R4,NWA$Q_LOGNAME(R9)	; Save descriptor of 1st node spec
					;  (less ::) in equivalence string
	MOVQ	R6,NWA$Q_SAVE_DESC(R9)	; Save descriptor of 2nd to nth
					;  node specs in equivalence string

;
; Isolate each node spec in the string, validate it, and exit loop when
; the last node spec string is found.
;

10$:	NXTFLD	EOS=ERRNOD1,NULL=ERRNOD1; Find next field
	TSTL	R6			; Any characters beyond this field?
	BEQL	ERRNOD1			; Branch if not
	CMPW	#^A\::\,-1(R7)		; Is it a node spec?
	BNEQ	ERRNOD1			; Branch if not
	BSBW	PSEUDO_CHKFLD		; Validate node spec syntax
	INCL	R7			; Skip over 2nd colon delimiter
	SOBGTR	R6,10$			; Branch if another field follows
					;  <R6,R7> => rest of string

;
; Handle defaulting of access control string and append 2nd to nth node specs
; to an intermediate node spec buffer.
;

	MOVQ	NWA$Q_SAVE_DESC(R9),R6	; Restore descriptor of 2nd to nth
					;  node spec string
	TSTL	NWA$Q_ACS(R9)		; Branch if there is no defualt
	BEQL	30$			;  access control string to apply

;
; Apply default access control string to nth node spec overriding the one
; (if any) associated with it.
;
; Note:	<R4,R5> => last (nth) node spec (less double colon delimiter)
;	<R6,R7> => 2nd to nth node spec string
;

	ADDL3	R4,R5,R1		; R1 => first colon delimiter
	BBC	#V_ACS,R2,20$		; Branch if there is no access control
					;  string to override
	LOCC	#^A\"\,R4,(R5)		; <R0,R1> => ACS; note R1 => first quote
	SUBL2	R0,R6			; Reduce size of string by size
					;  of ACS being removed
20$:	ADDL2	NWA$Q_ACS(R9),R6	; Increase size of string by size
					;  of ACS to be added
	MOVC3	NWA$Q_ACS(R9),-		; Insert default access control string
		@NWA$Q_ACS+4(R9),(R1)	;  into last node spec
	MOVW	#^A\::\,(R3)		; Add delimiter to string
	CLRL	NWA$Q_ACS(R9)		; Zero ACS size/flag
30$:	ADDL2	R6,NWA$Q_INODE(R9)	; Update intermediate node spec
	SUBL2	R6,NWA$Q_INODE+4(R9)	;  descriptor
	CMPW	NWA$Q_INODE(R9),-	; Make sure that this node spec
		#NWA$C_INODESIZ		;  will not overflow buffer
	BGTRU	ERRNOD1			; Branch on error
	MOVC3	R6,(R7),@NWA$Q_INODE+4(R9); Prefix node spec to the others
	MOVQ	NWA$Q_LOGNAME(R9),R4	; Restore descriptor of 1st node spec
	MOVL	NWA$L_SAVE_FLGS(R9),R2	; Restore flags word output from NXTFLD
	BRW	TRANSLATE_LOOP		; Try another translation
ERRNOD1:				;
	BRW	ERRNOD			; Branch aid

;+
; The last attempted logical node name translation failed--we have a real
; node name. Construct the primary node spec from this node name and any
; default access control string that may be in effect. Finally, update the
; node name element buffer with the primary and any intermediate node specs
; found so far.
;-

TRANSLATE_FAIL:				;
	CMPL	R4,#FWA$C_MAXNODNAM	; Check node name string size
	BGTRU	ERRNOD1			; Branch on error
	MOVL	R5,R7			; Store address of string
	ADDL3	R4,R5,R3		; Get address past string
	MOVC3	NWA$Q_ACS(R9),-		; Append access control string (if any)
		@NWA$Q_ACS+4(R9),(R3)	;  and double colon to construct
	MOVW	#^A\::\,(R3)+		;  primary node spec string
	SUBL3	R7,R3,R6		; Now <R6,R7> => node spec string
	NXTFLD	EOS=DUMMY1,NULL=DUMMY1	; Rescan node spec string to reset
					;  flags in R2 for use by CHECK_FIELD,
					;  especially M_ACS and M_$_
					;  (EOS and null exits will not occur)
					; On return <R4,R5> => node spec
					;  string less double colon

;
; Validate and copy the primary (left-most) node spec to the node name element
; buffer. If node name has been seen during a previous pass (FNA or DNA), then
; this node spec will not be copied.
;

DUMMY1:	ADDL2	#2,R4			; Update string size to copy colons
	CHKFLD	CHECKS=<M_NULL!M_WILD!M_MINUS!M_$_!M_RETURN_ON_ERR!M_QUOTED>,-
		FIELD=NODE,-
		MAXSIZ=<FWA$C_MAXNODNAM+NWA$C_MAXACS+2>,-
		ERR=NOD
	BLBS	R0,10$			; Branch on success
	BRW	ERRXIT			; Branch on failure

;
; Update the primary node spec descriptor.
; If no copy occurred, mark this in the flag words portion of the descriptor to
; signify that intermediate and secondary node specs also should be ignored
; for this pass (DNA or RLF).
;

10$:	$SETBIT	#V_NOT_COPIED,-		; Assume that primary node spec
		FWA$Q_NODE1+2(R10)	;  was not copied to element buffer
	BBS	#V_NOT_COPIED,R2,-	; Branch if primary node spec
		TRANSLATE_DONE		;  was not copied to element buffer
	MOVQ	FWA$Q_NODE(R10),-	; Save descriptor of primary
		FWA$Q_NODE1(R10)	;  node spec string
	MOVW	R2,FWA$Q_NODE1+2(R10)	; Save its associated flags word
					;  in bytes 2-3 of the descriptor

;
; Append intermediate node specs (if any) that were generated from logical
; node name translation to the node name element buffer.
;

	MOVQ	NWA$Q_INODE(R9),R6	; Get descriptor of intermediate
					;  node spec list
20$:	NXTFLD	EOS=DUMMY2,NULL=DUMMY2	; Isolate next intermediate node spec
					;  (EOS exit will not occur)
	ADDL2	#2,R4			; Update string size to copy colons
	BSBW	APPEND_NODESPEC		; Append next intermediate node spec
					;  to node name element buffer
	INCL	R7			; Skip over second colon delimiter
	SOBGTR	R6,20$			; Branch if another field follows
					;  <R6,R7> => rest of string
DUMMY2:					;

;+
; Logical node name translation performed on the left-most node spec of
; the user supplied file specification string is complete. Now process any
; other node specs and/or a quoted string that may follow.
;-

TRANSLATE_DONE:				;
	POPR	#^M<R6,R7,R9>		; Restore descriptor of rest of filespec
					;  string (starting at 2nd colon) and R9

;
; Adjust descriptor to point past double colon that delimits the node spec
; that caused this routine (NODE_SPEC_LIST) to be entered.
;

GET_FIELD_LOOP:				;
	INCL	R7			; Skip over second colon
	SOBGTR	R6,10$			; Count it and branch if not EOS
	BRW	PRSXIT			; All done this parse

;
; Determine if the next field is a quoted string.
;

10$:	CMPB	(R7),#^A\"\		; Is next character a quote?
	BNEQ	20$			; Branch if not
	BRW	QUOTED_STRING		; Branch if yes

;
; Determine if the next field is a secondary node spec string.
;

20$:	NXTFLD	EOS=NONODE,NULL=DUMMY3	; Isotate next field
					;  (null path will not occur)
	TSTL	R6			; Any characters beyond this field?
	BEQL	30$			; Branch if not
	CMPW	#^A\::\,-1(R7)		; Is it another node spec?
	BEQL	SECONDARY_NODE		; Branch if yes
30$:	BRW	CHECK_COLON		; All done with node spec and quoted
DUMMY3:					;  string parsing
NONODE:	BRW	GOTNAME			; Branch aid

;+
; The user has supplied a secondary node spec string. Append it to the
; node name element buffer, but do not perform logical node name translation
; unless the node spec string has its password masked out.
;
; Note:	Three registers must be saved on the stack because because control
;	may be given to ERRNOD which will pop three longwords from the stack.
;-

SECONDARY_NODE:				;
	PUSHR	#^M<R6,R7,R9>		; Save registers
	BBC	#V_PWD,R2,10$		; Branch if password is not masked out
					;  of access control string of node spec
	CMPB	#^A/_/,(R5)		; Remove leading underscore character
	BNEQ	5$			;  (if present) before attempting
	DECL	R4			;  translation of special logical node
	INCL	R5			;  name string with password masked out

;
; Attempt one level of logical node name translation to obtain the original
; access control string because the current node spec string has its password
; masked out.
;

5$:	MOVL	IFB$L_NWA_PTR(R9),R9	; Get address of NWA
	MOVQ	R4,NWA$Q_LOGNAME(R9)	; Store descriptor of node spec string
					;  to translate
	MOVZBL	FAB$B_DSBMSK(R8),-(SP)	; Search name tables desired
	PUSHL	#0			; Do not return mode of equiv string
	PUSHL	#0			; Do not return table of equiv string
	PUSHAQ	NWA$Q_XLTBUF1(R9)	; Specify address of descriptor of
					;  buffer to receive equivalence string
	PUSHAL	NWA$L_XLTSIZ(R9)	; Specify address of word to receive
					;  equivalence string size
	PUSHAQ	NWA$Q_LOGNAME(R9)	; Specify address of descriptor pointing
					;  to logical name candidate
	$TSTPT	NTXLATLOG		;
	CALLS	#6,@#SYS$TRNLOG		; Translate the logical name
	MOVZWL	NWA$L_XLTSIZ(R9),R4	; Store descriptor of equivalence
	MOVL	NWA$Q_XLTBUF1+4(R9),R5	;  string in <R4,R5>
	CMPW	R0,#SS$_NORMAL		; Was translation successful?
	BNEQ	ERRNOD2			; Branch if not

;
; Process the equivalence string.
;

	MOVQ	R4,R6			; Copy descriptor to required registers

;+
; Note that the call to UPCASE_COMPRESS shown below is not required.
;
;	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
;					;  compression in place
;-

	NXTFLD	EOS=ERRNOD2,NULL=ERRNOD2; On return <R4,R5> => next field found
					;  and <R6,R7> => string past 1st colon
	CMPL	R6,#1			; Branch if there are not exactly two
	BNEQ	ERRNOD2			;  characters beyond this field
	CMPW	#^A\::\,-1(R7)		; The equivalence string must be a
	BNEQ	ERRNOD2			;  node spec

;
; Validate and append secondary node spec to node name element buffer.
;

10$:	BSBB	PSEUDO_CHKFLD		; Validate node spec syntax
	ADDL2	#2,R4			; Update string size to copy colons
	BSBB	APPEND_NODESPEC		; Append next secondary node spec
					;  to node name element buffer
	POPR	#^M<R6,R7,R9>		; Restore registers
	BRW	GET_FIELD_LOOP		; Examine next field
ERRNOD2:				;
	BRW	ERRNOD			; Branch aid

;+
; This routine determines whether a field is a possible node spec string
; that may contain a logical node name and an access control string.
;
; Inputs:
;
;	R2	Flags word from NXTFLD
;	<R4,R5>	Descriptor of field
;
; Outputs:
;
;	R0-R1	Destroyed
;
;-

PSEUDO_CHKFLD:				; Allow '$' and '_' in logical node name
	BITW	#<M_NULL!M_WILD!M_MINUS!M_QUOTED>,R2
					; Make same checks as for
					;  device logical name
	BNEQ	ERRNOD3			; Branch on error
	MOVL	R4,R1			; Copy string size
	BBC	#V_ACS,R2,10$		; Branch if no ACS present
	LOCC	#^A\"\,R4,(R5)		; On return <R0,R1> => ACS
	CMPB	R0,#NWA$C_MAXACS	; Check size of ACS
	BGTRU	ERRACS1			; Branch if too big
	SUBL3	R0,R4,R1		; Compute size of logical node name
10$:	CMPB	R1,#FWA$C_MAXLNDNAM	; Check size of logical node name
	BGTRU	ERRNOD3			; Branch if too big
	RSB				; Exit
ERRACS1:				;
	POPR	#^M<R0>			; Throw away return address on stack
	BRW	ERRACS			; Branch aid
ERRNOD3:				;
	POPR	#^M<R0>			; Throw away return address on stack
	BRW	ERRNOD			; Branch aid

;+
; This routine appends the string described by <R4,R5> to the node name element
; buffer described by FWA$Q_NODE, i.e., an intermediate or secondary node spec
; is appended to the node specs already in the node name element buffer.
; Also, a descriptor pointing to the appended string is saved in FWA.
; R0-R5 are destroyed.
;-

APPEND_NODESPEC:			;
	BBS	#V_NOT_COPIED,-		; If primary node spec was discarded
		FWA$Q_NODE1+2(R10),10$	;  this pass, then discard this one too
	INCB	FWA$B_SUBNODCNT(R10)	; Increment secondary node spec counter
	MOVZBL	FWA$B_SUBNODCNT(R10),R0	; Copy the counter
	CMPL	R0,#FWA$C_MAXSUBNOD	; Branch if there are too many
	BGTRU	ERRNOD3			;  secondary node specs
	ADDL3	FWA$Q_NODE(R10),-	; Compute address of next available
		FWA$Q_NODE+4(R10),R3	;  byte of node name buffer
	MOVAQ	FWA$Q_NODE1(R10)[R0],R1	; Get address of next node spec desc
	MOVL	R4,(R1)			; Save descriptor of node spec
	MOVL	R3,4(R1)		;  being appended
	MOVW	R2,2(R1)		; Save its associated flags word
					;  in bytes 2-3 of the descriptor
	ADDL2	R4,FWA$Q_NODE(R10)	; Adjust size in node name descriptor
	CMPW	FWA$Q_NODE(R10),-	; Make sure intermediate node spec
		#FWA$C_MAXNODLST	;  string will fit in node name buffer
	BGTRU	ERRNOD3			; Branch on error
	MOVC3	R4,(R5),(R3)		; Append next node spec string
					;  to node name element buffer
10$:	RSB				; Exit

;++
; We have a quoted string...
;
; We should only get here if we have a network quoted string -- not for
; quoted strings which appear in ANSI-"a" filespecs.
;
; It must be terminated by a quote character and there can not be any other
; filespec elements present except for the node name. (Note that no check is
; made for quote characters within the quoted string.) If this is a DNA or
; RLF parse pass and any filespec elements other than node name have already
; been found, ignore this quoted string.
;
; If this is a valid quoted string:
;  (1)	Set a flag to indicate that this is a quoted string.
;  (2)	Set a flag if the quoted string contains an equals character to
;	indicate that it is of the "objecttype=..." form.
;  (3)	Set a flag if the quoted string contains a slash character
;	after the equals character to indicate that it is of the
;	"objecttype=taskname/netacp_string" form. Note that the logical name
;	translation of SYS$NET yields an equivalence string containing a
;	quoted string of this form.
;  (4)	In addition, if the quoted string is of the form given in (3), then
;	store a character count that represents the number of characters
;	in the substring /netacp_string" (including the trailing quote).
;  (5)  Set the wildcard character flag if test (2) failed and the quoted string
;	contains one of the following characters: asterisk, percent sign, or
;	question mark.
;  (6)	Finally, copy the quoted string (including the quotes) to buffer in NWA.
;--

QUOTED_STRING:				;
	CMPW	R6,#2			; Length of quoted string must be
	BLSSU	ERRQUO			;  at least 2 characters
	CMPB	-1(R7)[R6],(R7)		; Is last character a matching quote?
	BNEQ	ERRQUO			; Branch if not
	TSTB	FWA$B_FLDFLGS(R10)	; Other elements in filespec present?
	BNEQ	SKPQUO			; Branch if yes
	CMPW	R6,#FWA$C_MAXQUOTED	; Check string size
	BGTRU	ERRQUO			; Branch if string is too big for buffer
	BBSS	#FWA$V_QUOTED,(R10),-	; Flag quoted string and
		SKPQUO			;  branch if already seen

;
; Check for a task specification string enclosed in quotes, i.e.,
; node::"objecttype=..." form.
;

	LOCC	#^A\=\,R6,(R7)		; Search for '=' within quoted string
	BEQL	10$			; Branch if no match (R0=0 on no match)
	SSB	#FWA$V_OBJTYPE,(R10)	; Flag 'objecttype=...' form
					;  of quoted string
	LOCC	#^A\/\,R0,(R1)		; Search for '/' within quoted string
	BEQL	30$			; Branch if no match
	CMPW	R0,#4			; Length of /netacp_string" must be
	BLSSU	ERRQUO			;  at least 4 characters
	SSB	#FWA$V_NETSTR,(R10)	; Flag 'objecttype=taskname/...' form
	BRB	30$			;  of quoted string

;
; Check for a wildcard foreign file specification string enclosed in quotes,
; i.e., node::"foreign-filespec" form.
;
; Note:	Since the parse operation is perform entirely at the local node, there
;	is no way to tell for sure whether or not the file specification
;	contains any wildcard characters (as understood by the remote system).
;	The best we can do here is to scan the quoted string for likey wildcard
;	characters (*, %, and ?), and set the FWA$V_WILDCARD bit if any are
;	found.
;

10$:	LOCC	#^A\*\,R6,(R7)		; Search for '*' within quoted string
	BNEQ	20$			;  and branch if found
	LOCC	#^A\%\,R6,(R7)		; Search for '%' within quoted string
	BNEQ	20$			;  and branch if found
	LOCC	#^A\?\,R6,(R7)		; Search for '?' within quoted string
	BEQL	30$			;  and branch if not found
20$:	SSB	#FWA$V_WILDCARD,(R10)	; Signal wildcard character present

;
; Save the quoted string and related information in the FWA and NWA.
;

30$:	MOVL	R6,FWA$Q_QUOTED(R10)	; Store quoted string size in descriptor
	MOVL	IFB$L_NWA_PTR(R9),R2	; Get address of NWA
	MOVB	R0,NWA$B_NETSTRSIZ(R2)	; Store # bytes in /netacp_string"
	MOVC3	R6,(R7),-		; Copy entire quoted string to its
		@FWA$Q_QUOTED+4(R10)	;  element buffer
XITQUO:	BRW	PRSXIT			; All done this parse

;
; If this is not parse of FNA string, simply ignore the quoted string
; because another filename element or previous quoted string has been seen.
;

SKPQUO:	BBC	#FWA$V_FNA_PASS,(R10),-	; Branch if not FNA pass
		XITQUO			;

;
; Process quoted string error.
;

ERRQUO:	RMSERR	QUO			; Declare error in quoted string
	BRW	PRSERR			; Exit with completion code in R0
	$PSECT_RESTORE			;

;++
; We have a file name...
;--

NAME:					;
	CHKFLD	CHECKS=<M_$_!M_MINUS!M_NAMTYP>,-
		FIELD=NAME,-
		MAXSIZ=FWA$C_MTMAXNAME,ERR=FNM
	BBC	#FWA$V_FNA_PASS,(R10),5$; Branch if not FNA pass
	BBC	#FWA$V_NAME,(R10),2$	; Branch if name not seen
	SSB	#FWA$V_EXP_NAME,(R10)	; Set explicit name flag
2$:	CMPB	R3,#^A/./		; Terminated by period?
	BNEQ	5$			; Branch if not
	SSB	#FWA$V_EXP_TYPE,(R10)	; Yes - set explicit type flag
5$:	BBS	#V_NOT_COPIED,R2,15$	; if we didn't use this string, go on
	BBC	#V_QUOTED,R2,15$		; if string not quoted, continue

;
; If we have already seen a node at this point (i.e. FWA$V_NODE set)
; then we will not allow a quoted ANSI name.  Network quoted strings
; where the quoted string immediately followed the node name do
; not pass through this code path.
; The effect of this line is to make RMS work, and to disallow quoted
; names from going over the network.  Since network magtape is not supported
; thats not a big deal, although it would be nice if one copy to the
; other unit record devices (who don't care about file names) from ANSI
; magtape over the network.
;

	BBS	#FWA$V_NODE,(R10),10$	; if node spec not legal file name

;
; We just used a quoted string for a name string - it now resides in
; FWA$Q_NAME, quotes and all.  It is not a network quoted string, either,
; as that was caught back when we saw the double quotes (if any).
;

	SSB	#FWA$V_QUOTED,(R10)	; flag quoted name in use

;
; We now will flag that we've seen a type, since having a quoted
; string "implies" a type (that's why TYPE and not EXP_TYPE is set).
; This keeps the type from showing up later by defaulting and relating
; and such.  Unfortunately, we can't use the current status of the 
; FWA$V_TYPE bit to tell us whether we've already seen a type, as at the
; end of the FNA scan EXP_TYPE if set is used to set TYPE.  EXP_TYPE is
; set even if there was only a . with no "real" type characters (to
; allow null types of course, otherwise they would fill in from the 
; defaults...).  So we have to check at this point for the length
; of the FWA$Q_TYPE descriptor.
;

	SSB	#FWA$V_TYPE,(R10)
	TSTL	FWA$Q_TYPE(R10)		; is there any type?
	BNEQ	10$			; if neq yes, oops, error

;
; Upcase quoted string in place -- can't use UPCASE_COMPRESS because:
;
; 1. We don't want to compress the string
; 2. We would have to separate access control strings from 
;    ANSI-"a" filespec quoted strings in UPCASE_COMPRESS which would
;    make necessary a full preliminary parse in UPCASE_COMPRESS
;
; While we're at it, we also count quotes so we can figure out if the
; string is to long or not.
;

	PUSHL	R2			; make some room to count quotes
	CLRL	R2			; and intialize the counter
	MOVQ	FWA$Q_NAME(R10),R0	; set up descriptors in R0,R1
	BRB	8$			; enter loop in progress
6$:	CMPB	#^A/a/,(R1)+		; get next character
	BGTRU	7$			; if less than little a
	CMPB	#^A/z/,-1(R1)		; look at same character
	BLSSU	7$			; if greater than little z
	BICB	#^X20,-1(R1)		; clear the lowercase bit
7$:	CMPB	#^A/"/,-1(R1)		; is it quote?
	BNEQ	8$			; if neq don't count it
	INCL	R2			; count quotes as while upcasing
8$:	SOBGEQ	R0,6$			; count down characters and continue

;
; We've now counted the quotes (while upcasing) and we must now see if the
; string is too long.  The final (i.e. with outer quotes removed and inner
; quotes "singled") string on magtape must be no greater than 17 characters.
; We now know the total length of the string (call it X) and we know the
; number of quotes (in R2, call it Y).  We now want to verify that
; X - (Y/2) =< 18, which will verify that the final string is no more than 17
; characters.
;

	ASHL	#-1,R2,R2		; divide Y (number of quotes) by 2
	SUBL3	R2,FWA$Q_NAME(R10),R0	; R0 = X- (Y/2)
	MOVL	(SP)+,R2		; put R2 back where it belongs
	CMPL	R0,#FWA$C_MTLNONTAP+1	; is it gtr than 18?
	BLEQ	15$			; if leq its ok

;
; return file name error here quick and easy
;

10$:	RMSERR	FNM
	BRW	PRSERR

15$:	CMPB	R3,#SEMICOLON		; Was terminator semi?
	BNEQ	20$			; Branch if not
	BISB2	#FWA$M_TYPEFLG,(R10)	; Flag type already seen
	BBC	#FWA$V_FNA_PASS,(R10),20$; Branch if not FNA pass
	SSB	#FWA$V_EXP_VER,(R10)	; Set explicit version flag
20$:	BRW	NXTNAM			; Go get another name

;++
; We have a left bracket (square or angle) indicating a directory spec.
;
; It may be of the [grp,mbr] format, [directory-name] format,
; [directory-name.directory-name2...] format, or [.directory-name...]
; format.
;
; Determine the format and copy the various parts to the directory buffers.
;--

PARSE_DIR:				;
	TSTL	R4			; Any other chars this substring?
	BEQL	5$
	BRW	ERRSYN			; Branch if yes - error
5$:	ADDB3	#2,R3,FWA$B_DIRTERM(R10); Determine whether to use ']' or '>'
					;  as teminator, taking advantage of the
					;  fact that the ASCII code for each of
					;  the right brackets is 2 more than
					;  the code for the correspoinding
					;  left bracket
;
;   If this is the related file pass and we are doing an output file parse
;   then if the directory in the current expanded filename is a
;   wildcard - replace it with the first wild field in the directory
;   of the related filename (i.e. sticky directories)
;

	BBC	#FWA$V_RLF_PASS,(R10),-	; If this isn't a related file pass
		10$			;  don't make directories sticky
	BBC	#FAB$V_OFP+FOP,(R8),-	; If this isn't output file parse
		10$			;  don't make directories sticky
	CALLS	#0,STICKY_DIR		; Go check for sticky directories
	BLBC	R0,15$			; If any errors, go report them
	CMPB	R3,FWA$B_DIRTERM(R10)	; Have we passed the whole directory ?
	BNEQU	SKPDIR			; No - go eat the rest
	BRW	DIRXIT			; Only use sticky fields

10$:	BBSS	#FWA$V_DIR,(R10),SKPDIR	; Branch if directory already seen
	NXTFLD	EOS=ERRDIR,NULL=ERRDIR	; Get first directory field
	CMPB	R3,#^A/,/		; [group,member] format?
	BEQL	GRPMBR			; Branch if yes
	CMPB	R3,FWA$B_DIRTERM(R10)	; Is it a single directory name?
	BEQL	NAMED_DIR		; Branch if yes
	CMPB	R3,#^A/./		; Must be directory-list
	BEQL	NAMED_DIR		; Branch if not - uninterpretable
15$:	BRB	ERRDIR_BR1		;

;+
; We have a comma indicating '[group,member]' directory format.
;-

GRPMBR:					;
	CHKFLD	CHECKS=<M_NULL!M_MINUS!M_$_!M_ALPHA!M_NOT_OCTAL!M_QUOTED>,-
		FIELD=DIR1,-
		MAXSIZ=3,ERR=DIR

;
; First part ok - check second part.
;

	NXTFLD	EOS=ERRDIR,NULL=ERRDIR	;
	CMPB	R3,FWA$B_DIRTERM(R10)	; Term=right bracket?
	BNEQ	ERRDIR_BR1		; Branch if not
	CHKFLD	CHECKS=<M_NULL!M_MINUS!M_$_!M_ALPHA!M_NOT_OCTAL!M_QUOTED>,-
		FIELD=DIR2,-
		MAXSIZ=3,ERR=DIR

;
; Now check for values less than 377 octal.
;

	MOVAQ	FWA$Q_DIR1(R10),R0	; Address of 1st descriptor
	BSBW	CHK377			; Check value
	ASSUME	FWA$Q_DIR2 EQ <FWA$Q_DIR1+8>
	BSBW	CHK377			; Check 2nd value
	SSB	#FWA$V_GRPMBR,(R10)	; Flag group member format
	ADDB2	FWA$Q_DIR1(R10),-	; compute the directory length of the
		FWA$B_DIRLEN(R10)	; UIC format directory by adding the
	ADDB2	FWA$Q_DIR2(R10),-	; lengths of the two separate parts
		FWA$B_DIRLEN(R10)	; together
	SSB	#FWA$V_DIR_LVLS,(R10)	; treat UIC dirs as having 2 levels
DIRXIT2:				;
	BRW	DIRXIT			; All set
ERRDIR_BR1:				;
	BRW	ERRDIR			; Error in directory format

;
; We must skip over directory spec.
;

	ASSUME	FWA$V_DUPOK EQ 0

SKPDIR:					;
	BLBC	(R10),ERRDIR_BR1	; Branch if duplicates not allowed
	LOCC	FWA$B_DIRTERM(R10),R6,(R7); Find ending delimiter
	BEQL	ERRDIR_BR1		; Error if not found
	MOVAB	-(R0),R6		; Set length minus delimiter
	MOVAB	1(R1),R7		;
	BRW	DIRXIT			;

;+
; We have a directory name.
; Check for '[]' or '[.name]' or '[-.name]'
; indicating explicit default directory.
;-

NAMED_DIR:				;
	BBS	#V_MINUS,R2,5$		; Relative if leading minus

	ASSUME	V_NULL EQ 0

	BLBC	R2,10$			; Branch if not null
5$:	BRW	DEFAULT_SUB		; Get default directory

;
; Set up to call CHECK_DIR_FIELD. Build argument list on the stack.
;
; The argument list actually is:
;
; error code, offset to DIR descriptor, directory level, max size, checks
;  3 bytes	   1 byte		   1 byte	 1 byte     2 bytes
;

10$:	PUSHL	#FWA$Q_DIR1!-		; Offset to directory descriptor
		<<RMS$_DIR&^XFFFF>@8>	; Error code for failure
	PUSHL	#<M_NULL!M_MINUS!M_$_!M_RETURN_ON_ERR!M_QUOTED>!-; Checks
		<FWA$C_MAXNAME@16>!-	; Maximum size of directory name
		<FWA$V_DIR1@24>		; FWA flag bit to set
	MOVL	SP,AP			; Set arglist address
CHECK_SUBDIR:				;
	ADDB2	R4,FWA$B_DIRLEN(R10)	; Accumulate directory spec length
	INCB	FWA$B_DIRLEN(R10)	; Count the terminator too
	BSBW	CHECK_DIR_FIELD		; Go validate the (sub)directory
	BLBC	R0,ERRSUBDIR		; Branch on error

;
; If minus sign is detected in the string already stripped by next_fild,
; then remove the previous directory name from the list.
; If we go past the top level, return error.
;

	.ENABLE	LSB
	BBC	#V_MINUS,R2,GETNXTDIR	; skip if no leading minus
2$:	BSBW	PROCESS_MINUS		; Process minus sign(s)
	BLBC	R0,ERRSUBDIR		; Branch if error detected

;
; If the previous character was a ".", then continue parsing names.
; Otherwise, exit assuming that the character must be FWA$B_DIRTERM.
;
; Can branch here from DEFAULT_SUB if leading minus was detected there.
; In that case, PROCESS_MINUS call was made there.
;

GETNXTDIR:
	CMPB	R3,#^A/./		; Another directory in list?
	BNEQ	5$			; Branch if not

;
; If elipsis is detected, then mark the previous directory descriptor
; that an elipsis follows it.
;

	BSBW	PROCESS_ELIPSIS		; Process elipsis token
	BLBC	R0,ERRSUBDIR		; Branch if error
	BLBC	R1,5$			; Branch if end of directory
	TSTL	R6			; Anything left?
	BGTR	10$			; Branch if yes

;
; Directory parse completed - if directory specification contains
; no levels (as a result of minus signs), then insert 000000 as
; directory name.
;

5$:	BBS	#FWA$V_DIR1,(R10),DIRXIT1; Skip if any names are left
	BSBW	INSERT_MFD		; Insert MFD as directory
	BRB	DIRXIT1			;

;
; Increment the number of directory levels to account for the directory
; name we are about to get via NXTFLD. (We assume it will be valid.)
;

10$:	CMPB	3(AP),#FWA$V_DIR1+FWA$C_MAXSUBDIR; Too many levels?
	BGEQ	ERRSUBDIR		; Branch if yes
	ADDW2	#1+<8@8>,3(SP)		; Move to next sub dir

	ASSUME	FWA$V_DIR_LVLS GE 24
	ASSUME	FWA$V_DIR_LVLS LT 32

	ADDB2	#<1@<FWA$V_DIR_LVLS-24>>,3(R10); Bump directory level count

;
; Get the next name in the directory spec.
;

20$:	NXTFLD	EOS=ERRSUBDIR,NULL=ERRSUBDIR; Get next field
	BBS	#V_MINUS,R2,2$		; Process leading minus signs
	CMPB	R3,FWA$B_DIRTERM(R10)	; Is it right bracket?
	BEQL	CHECK_SUBDIR		; Branch if yes
	CMPB	R3,#^A/./		; Valid terminator?
	BNEQ	ERRSUBDIR		; Branch if not
	BRW	CHECK_SUBDIR		;
	.DISABLE LSB

;
; Handle directory error
;

ERRSUBDIR:				;
	POPR	#^M<R0>			; Remove arglist from stack
ERRDIR1:				;
	POPR	#^M<R0>			; Remove return PC (or 2nd argument)
ERRDIR:	RMSERR	DIR			; Show error
	BRW	PRSERR			;  and get out

;
; Directory processed ok
; Go process next field
;

DIRXIT1:				;
	POPR	#^M<R0,R1>		; Remove argument list
DIRXIT:	BRW	NXTNAM			; Process filename

;
; Subroutine to check that octal string
; whose descriptor address is in R0 does not exceed 377.
;
; Note:	It is already known that all characters are
;	either octal or a single asterisk, and that there
;	are at most 3 characters.
;

CHK377:					;
	CMPL	(R0)+,#3		; 3 characters?
	BNEQ	10$			; No need to check unless 3
	CMPB	@(R0)+,#^A/3/		; Is first char > 3?
	BGTRU	ERRDIR1			; If so it's an error
	RSB				;
10$:	TSTL	(R0)+			; Skip to next descriptor
	RSB				;

;++
; Subroutine to process a series of minus signs.
;
; For each minus sign in the current token (all characters in
; the token must be minus signs), backup one level in the current
; directory specification. If we go past the top level, issue an error.
;
; The entry point at PROCESS_MINUS1 allows skipping the first decrement
; when we can't bump the depth because then we'd overflow the three
; bits used to represent the depth.  This happens when we want to jump
; into the directory parsing loop from DEFAULT_SUB.
;
;--

PROCESS_MINUS:				;
	DECB	3(AP)			; Decrement directory bit #
	SUBB	#8,4(AP)		; Etc, since a level was added
	SUBB	#1@<FWA$V_DIR_LVLS-24>,3(R10); due to multiple minus "name"

PROCESS_MINUS1:				; Enter with no initial level decrement
	CLRL	R0			; Assume error
2$:	CMPB	(R5)+,#^A/-/		; Leading minus sign?
	BNEQ	90$			; Error if not
	CMPB	3(AP),#FWA$V_DIR1	; Already at top level?
	BLSSU	90$			; Error if so
	BGTRU	3$			; Branch if not level 1
	CMPW	FWA$Q_DIR1(R10),#6	; Check if at MFD
	BNEQ	3$			; Branch if not
	CMPL	@FWA$Q_DIR1+4(R10),#^A/0000/; Check MFD name also
	BEQL	90$			; If - over MFD, give error
3$:	MOVZBL	3(AP),R1		; Get previous bit #
	CSB	R1,(R10)		; Mark this level not seen
	MOVZBL	4(AP),R1		; Get descriptor offset
	ADDL	R10,R1			; Address of descriptor
	CLRL	(R1)			; Zero previous descriptor length
	DECB	3(AP)			; Decrement directory bit #
	SUBB	#8,4(AP)		; Decrement descriptor offset
	SUBB	#1@<FWA$V_DIR_LVLS-24>,3(R10); Decrement # levels
	DECL	R4			;
	BGTR	2$			; Allow multiple minus signs
	RMSSUC				; Success
90$:	RSB				;

;++
; Subroutine to check if elipsis is the current delimiter, and if detected,
; mark it in the descriptor of the predessor directory name.
;
;	R0 = false if error, else true
;	R1 = false if end of directory scan, else true
;--

PROCESS_ELIPSIS:			;
	MOVL	#1,R1			; Assume not end of directory
	CLRL	R0			; Assume error
	CMPW	R6,#3			; Must be 3 chars left
	BLSS	10$			; Skip if not
	CMPW	(R7),#^A/../		; 3 dots in a row?
	BNEQ	10$			; Skip if not
	MOVZBL	4(AP),R0		; Get offset to descriptor
	CMPB	R0,#FWA$Q_DIR1		; Is there a previous name?
	BGEQU	5$			; Branch if so
	BSBB	INSERT_MFD		; If not, insert MFD
	ADDL	#8,R0			; Account for new name
5$:	MOVB	#1,2(R10)[R0]		; Set 1 in top word
	SSB	#FWA$V_WILDCARD,(R10)	; Set overall wild bit
	SSB	#FWA$V_WILD_DIR,(R10)	;  and mark wild dirspec
	SUBL	#2,R6			; Bypass elipsis
	ADDL	#2,R7			;
	CMPB	(R7),FWA$B_DIRTERM(R10)	; Ending delimiter?
	BNEQ	10$			; Branch if not
	DECL	R6			; Bypass ending delimiter
	INCL	R7			;
	CLRL	R1			; Terminate directory scan
10$:	RMSSUC				; Success
90$:	RSB				; Exit

;++
; Subroutine to insert the name "000000" into the directory spec.
;--

INSERT_MFD:				;
	SSB	#FWA$V_DFLT_MFD,(R10)	; Flag MFD was inserted
	MOVW	#6,FWA$Q_DIR1(R10)	; Insert length of "000000"
	MOVQ	#^A/000000  /,-		; Move the string "000000"
		@FWA$Q_DIR1+4(R10)	;
	ADDB	#1@<FWA$V_DIR_LVLS-24>,-; Increment # levels
		3(R10)			;
	RSB				; Exit

;+
; We have a directory spec of the form [] or [.name], or [-.name]
; implying a sub-directory of the current default directory.
; It is valid only if default directory is not of the [group,member] format.
; Call RM$XPFN recursively to apply default directory.
;-

DEFAULT_SUB:				;

;
; If this is a network filespec, then the directory string should be sent
; to the remote FAL as entered, that is, without resolving hyphens or a
; null root directory. So if a node name is present, say UFD seen and
; make the corresponding FWA descriptor point to a null root directory
; string or one consisting of one or more hyphens.
;

	BBC	#FWA$V_NODE,(R10),10$	; Branch if node not seen
	CSB	#V_MINUS,R2		; Clear minus bit in mask to avoid
					;  having it resolved in this routine
	MOVL	R4,FWA$Q_DIR1(R10)	; Store string size in DIR1 descriptor
	MOVQ	(R5),@FWA$Q_DIR1+4(R10)	; Move up to 8 hyphens to buffer
	BBCS	#FWA$V_DIR1,(R10),20$	; Say UFD seen and branch

;
; And its context (logname flag and directory terminator).
;

10$:	PUSHR	#^M<R2,R3,R4,R5,R6,R7>	; Save current registers

	ASSUME	<FWA$V_LOGNAME/8> EQ FWA$B_LNFLG
	ASSUME	FWA$B_DIRTERM EQ <FWA$B_LNFLG+1>

	MOVZWL	FWA$B_LNFLG(R10),-(SP)	;
	CLRB	FWA$B_LNFLG(R10)	; Say no logical name seen
	CSB	#FWA$V_DIR,(R10)	; Clear directory seen flag

;
; Call RM$XPFN recursively at DFDIR.
;

	BSBW	DFDIR			; Parse default directory

;
; Restore previous context.
;

	CVTLW	(SP)+,FWA$B_LNFLG(R10)	;
	POPR	#^M<R2,R3,R4,R5,R6,R7>	; Restore registers
	BLBC	R0,ERRBUG		; Branch on failure

;
; If done with directory spec, then exit immediately.
;

20$:	BBS	#V_MINUS,R2,25$		; If leading minus,
	CMPB	R3,FWA$B_DIRTERM(R10)	; Or if not ending terminator,
	BNEQ	25$			; Handle relative filespec
	BRW	DIRXIT			; Exit from directory spec

;
; Do not allow concatenation of uic format directories.
;

25$:	BBS	#FWA$V_GRPMBR,(R10),ERRDIR_BR; Branch if wrong format

;
; Setup to jump into directory name parsing loop.
;

	PUSHL	#FWA$Q_DIR1!-		; Offset to directory descriptor
		<<RMS$_DIR&^XFFFF>@8>	; Error code for failure
	PUSHL	#<M_NULL!M_MINUS!M_$_!M_RETURN_ON_ERR>!-; Checks
		<FWA$C_MAXNAME@16>!-	; Maximum size of directory name
		<FWA$V_DIR1@24>		; FWA flag bit to set
	MOVL	SP,AP			; Set arglist address
	EXTZV	#FWA$V_DIR_LVLS,#FWA$S_DIR_LVLS,-
		(R10),R1		; Get # directory levels
	ADDB2	R1,3(AP)		; And set into arg list
	ROTL	#3,R1,R1		; Make into descriptor offset
	ADDB2	R1,4(AP)		; And set into arg list
	BBC	#V_MINUS,R2,30$		; Branch if no leading minus
	BSBW	PROCESS_MINUS1		; Go handle leading minus
	BLBC	R0,40$			; Return error to caller
30$:	BRW	GETNXTDIR		; Go process rest of directory

40$:	BRW	ERRSUBDIR		; A branch aid
;
; The default directory string is messed up. This should
; never happen, but it's not too serious. Try to continue.
;

ERRBUG:					;

;+
;	RMSPBUG	BUG$_BADDFLTDIR		; Report error to log
;-

	RMSERR	BUG_DDI			; Return error to caller
	BRW	PRSERR			;
ERRDIR_BR:				;
	BRW	ERRDIR			;

;++
; Logical device name translation ...
;
; This subroutine attempts to translate the string described by
; FWA$Q_LOGNAME, as a logical name via the translate logical name
; system service, and if successful, checks for an 'escape'
; equivalence string indicating a process-permanent file in
; which case the escape string is stored in the FwA and the parse
; is terminated. 
; If not an escape string, the original string is returned to the user
; and a success return is made.
; If not an escape string or underline, the equivalence
; string replaces the parse input string and a branch is made
; to PARSE_STRING to merge in the filename elements of the
; equivalence string. If the translate was unsuccessful, a failure return is
; made to the caller with the equivalence string (identical to the
; input name minus the initial underscore if any) described by <R4,R5>.
;--

TRANSLATE:				;
	POPR	#^M<R3>			; Pick up return PC

;
; Check for maximum number of translations already done and exit if
; it is exceeded (i.e., user is in a loop).
;

10$:	AOBLEQ	#10,FWA$L_XLTCNT(R10),XLAT1; Branch if < 10 translations

;
; Either the maximum number of translations has been exceeded or the
; logical name translation yielded an escape string that was either
; the wrong length, of the wrong mode, or not the only field.
;

ERRLNE:	$PSECT_BR	L$RMS0		;
	RMSERR	LNE			; Show error
	BRW	PRSERR			; And get out
	$PSECT_RESTORE			;

;
; Use whichever of the two logical name buffers is not being used
; to receive the equivalence string.
;

	ASSUME	TRNLOG$_ACMODE EQ <TRNLOG$_DSBMSK-4>
	ASSUME	TRNLOG$_TABLE EQ <TRNLOG$_ACMODE-4>
	ASSUME	TRNLOG$_RSLBUF EQ <TRNLOG$_TABLE-4>
	ASSUME	TRNLOG$_RSLLEN EQ <TRNLOG$_RSLBUF-4>
	ASSUME	TRNLOG$_LOGNAM EQ <TRNLOG$_RSLLEN-4>
	ASSUME	TRNLOG$_NARGS EQ 6
	ASSUME	FWA$B_XLTTBL EQ <FWA$B_XLTMODE+1>
	ASSUME	FWA$Q_XLTBUF1 EQ <FWA$B_XLTTBL+1>
	ASSUME	FWA$L_BUFFLG EQ <FWA$Q_XLTBUF1+8>
	ASSUME	FWA$L_XLTSIZ EQ <FWA$L_BUFFLG+4>
	ASSUME	FWA$Q_LOGNAME EQ <FWA$L_XLTSIZ+4>

XLAT1:	MOVZBL	FAB$B_DSBMSK(R8),-(SP)	; Search name tables desired
	MOVAB	FWA$B_XLTMODE(R10),R1	; Get address of byte to receive
					;  mode of equivalence string
	PUSHAB	(R1)+			; Build arglist on stack
	PUSHAB	(R1)+			; Push address of byte to receive
					;  table # of equivalence string

	PUSHAQ	(R1)+			; Push address of buffer to receive
					;  equivalence string
;
; Complement the buffer flag and if zero switch buffers.
;

	MCOML	(R1),(R1)+		; Using right buffer?
	BNEQ	10$			; Branch if yes
	MOVAQ	FWA$Q_XLTBUF2(R10),(SP)	; No - swap buffer

;
; Save the address of the buffer used.
;

10$:	MOVL	(SP),R5			; Descriptor address
	MOVL	4(R5),R5		; Get address of buffer
	PUSHAL	(R1)+			; Receive equiv. string length here
	PUSHAQ	(R1)			; Address of logical name desc
	$TSTPT	XLATLOG			;
	CALLS	#6,@#SYS$TRNLOG		; Do the translation
	MOVL	FWA$L_XLTSIZ(R10),R4	; Pick up string length
	CMPW	R0,#SS$_NORMAL		; Check status
	BNEQ	NOTRANS			; Branch on no translation

;
; We had a translation.
;
; If node is set and:
;
;	1) the translation was not from the process table
; or	2) the translation was not from user mode
;
; then ignore the translation.
;
; If the translation yielded an device name with a leading "__"
; then ignore the translation.
;

	BBC	#FWA$V_NODE,(R10),20$	; Branch if no node spec
	CMPB	FWA$B_XLTTBL(R10),#LOG$C_PROCESS; From process table?
	BNEQ	NOTRAN_NET		; If not, treat as if no
					;  translation had occurred
	CMPB	FWA$B_XLTMODE(R10),#PSL$C_USER; User mode translation?
	BNEQ	NOTRAN_NET		; If not, ignore

;
; Check to see if we got an escape string indicating a process permanent file.
;

20$:	CMPB	(R5),#ESCAPE		; Do we have a PPF?
	BEQL	PPERMFILE		; Branch if yes
	MOVQ	R6,-(SP)		; save current position and length
	MOVQ	R4,R6			; Get into right registers
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression in place

;
; If the equivalence string has a device name with 2 leading underlines,
; then ignore the translation and preserve the logical
; name as the device name.
;

	CMPB	(R7),#^A\_\		; Got initial "_"?
	BEQL	40$			; ignore translation if so

;
; Parse the equivalence string as the filename string.
;

25$:	BBC	#FWA$V_FNA_PASS,(R10),30$ ; leave dupok if not fna pass
	BICB2	#FWA$M_DUPOK,(R10)	; Logical names must provide
					;  no duplicate fields
30$:	ADDL2	#8,SP			; throw away descriptor saved above
	BRW	PARSE_STRING		; Parse it

40$:
	CMPB	R6,#2			; At least 2 chars?
	BLSS	25$			; Can't be a hidden device if not
	CMPB	1(R7),#^A'_'		; Is next char a underline?
	BNEQ	25$			; Can't be a hidden device if not
	MCOML	FWA$L_BUFFLG(R10),-	; Flip the buffer flag back
		FWA$L_BUFFLG(R10) 
	MOVQ	(SP)+,R6		; restore saved position and length
	BRB	NOTRAN_NET		; and ignore the translation.

;+
; Ppermfile ...
;
; The equivalence string starts with an escape.
; It looks like we have a process permanent file.
;
; Check that translation came from a more privileged mode than user
; and that the equivalence string has at least 4 bytes.
;-

PPERMFILE:				;
	CMPB	FWA$B_XLTMODE(R10),-	; Branch if user mode entry
		#PSL$C_USER		;
	BEQL	20$			;
	CMPL	R4,#4			; Is escape string 4 bytes long?
	BLSSU	20$			; No - uninterpretable
	MOVL	(R5),FWA$L_ESCSTRING(R10); Store the escape string

;
; Use CHKFLD to copy the process permanent logical name
; to the device name field.
;

	MOVQ	FWA$Q_LOGNAME(R10),R4	; Get descriptor into <R4,R5>
	CHKFLD	CHECKS=<M_WILD!M_MINUS!M_QUOTED>,-
		FIELD=DEVICE,-
		MAXSIZ=FWA$C_DEVBUFSIZ,ERR=DEV
	BBC	#FWA$V_FNA_PASS,(R10),10$; Branch if not processing FNA string
	SSB	#FWA$V_EXP_DEV,(R10)	; Set explicit device flag
10$:	BRW	PRSXIT1			; All done
20$:	BRW	ERRLNE			; Error in logical name translation

;
; The translation is not to be used for a remote node.
;

NOTRAN_NET:				;
	MOVQ	FWA$Q_LOGNAME(R10),R4	; Restore logical name
	MOVL	#1,R0			; Translation valid, but not to be used

;
; No translation occurred (although a leading underscore may have been
; stripped).
; Perform an effective RSB to the return address in R3.
;

NOTRANS:				;
	JMP	(R3)			;

;++
; Entry point for UPCASE_COMPRESS.
;
; This routine copies the source string to the destination buffer while
; upcasing lowercase characters and removing space, horizontal tab, and null
; characters, except that characters enclosed in quotes are moved unaltered.
;
; Inputs:
;
;	R5	Destination buffer descriptor
;	<R6,R7>	Source string descriptor
;
; Outputs:
;
;	R5	Destroyed
;	<R6,R7>	Destination string descriptor
;--

UPCASE_COMPRESS:			;
	TSTL	R6			; Branch if source string length is
	BEQL	50$			;  zero
	PUSHL	R5			; Save destination buffer address

;
; Examine each character in the source string.
; Take advantage of the fact that the ASCII values for space, horizontal tab,
; null, and quote are less than the ASCII values for lowercase characters.
;

10$:	CMPB	(R7),#^A\"\		; Check for quote
	BGTRU	20$			; Branch if greater than quote
	BEQL	70$			; Branch if quote
	CMPB	(R7),#SPACE		; Branch if space
	BEQL	60$			;
	CMPB	(R7),#HOR_TAB		; Branch if horizontal tab
	BEQL	60$			;
	TSTB	(R7)			; Branch if null
	BEQL	60$			;
20$:	MOVB	(R7)+,(R5)+		; Append character to destination string
	CMPB	-1(R5),#LOWERCASE_A	; Determine if this is a lowercase
	BLSSU	30$			;  character
	CMPB	-1(R5),#LOWERCASE_Z	;  "
	BGTRU	30$			;  "
	BICB	#^X20,-1(R5)		; If so, convert it to uppercase
30$:	SOBGTR	R6,10$			; Check for end of source string

;
; The source string is exhausted.
;

40$:	POPL	R7			; Restore destination buffer address
	SUBL3	R7,R5,R6		; Compute length of destination string
50$:	RSB				; Exit with <R6,R7> describing
					;  upcased and compressed string

;
; A space, tab, or null character has been found, simply discard it.
;

60$:	INCL	R7			; Discard character
	BRB	30$			;

;
; A leading quote character has been found.
; Copy all characters unaltered until the matching quote is found, unless
; the leading quote was preceeded by two  colons which indicates that this is
; the start of a network quoted string (as opposed to an access control string)
;

70$:	SUBL3	(SP),R5,-(SP)		; Branch if this is first character
	CMPL	#1,(SP)+		;  or second character
	BGEQU	80$			;  of string
	CMPW	-2(R5),#^A\::\		; Branch if previous two non-compressed
	BEQL	100$			;  character were both colons

;
; This is where we skip all characters between quoted, and do not upcase or
; compress them.  This works for access control strings because they don't 
; have imbedded quotes, and it works for ANSI-"a" filespecs (which may have
; imbedded quotes) because the imbedded quotes are doubled.  That causes them
; to look like lots of short quoted strings as far as this routine is concerned
; but nevertheless, this routine will still not bother the internal characters.
;
; Note that ANSI-"a" filespecs do want to be upcased -- this is done in this
; module at label NAME: -- when we actually move the name into the FWA$Q_NAME
; buffer
;

80$:	MOVB	(R7)+,(R5)+		; Append character to destination string
	SOBGTR	R6,90$			; End of source string?
	BRB	40$			; Branch if yes
90$:	CMPB	(R7),#^A\"\		; Is next character the matching quote?
	BNEQ	80$			; Branch if not
	BRB	20$			; Branch if yes

;
; This is the start of a network quoted string. It may have embedded quote 
; characters and it must be the last element of a file specification string.
; Therefore, copy all characters unaltered until end of string is reached, 
; then work backwards to remove trailing spaces, tabs, and nulls.
;

100$:	MOVB	(R7)+,(R5)+		; Append the rest of the source string
	SOBGTR	R6,100$			;  to the destination string

;
; The source string has been exhausted. Truncate string after last non
; space, tab, or null character.
;

110$:	CMPB	-(R5),#SPACE		; Discard space
	BEQL	110$			;
	CMPB	(R5),#HOR_TAB		; Discard horizontal tab
	BEQL	110$			;
	TSTB	(R5)			; Discard null
	BEQL	110$			;
	INCL	R5			; Position pointer past new end of
	BRB	40$			;  destination string

	.SBTTL	NEXT_FIELD - SUBROUTINE TO SCAN STRING FOR TERMINATOR

;++
; Functional Description:
;
; This routine scans an input string for a terminator returning
; a descriptor for the substring preceding the terminator
; and setting flags based upon the contents of the field.
;
;
; Terminator characters are:
;
;	:[]<>.,;
;
; Valid field characters are:
;
;	Alphabetics, numerics, and $_*%
;
; Note:	Minus sign is valid only as the first character of a field.
;
; Note:	An access control string embedded in a node spec is allowed.
;
; Calling Sequence:
;
;	Via the NXTFLD macro, e.g.,
;	NXTFLD	NULL=label1,EOS=label2
;
; Input Parameters:
;
;	R6	input string size in bytes
;	R7	input string start address
;
; Implicit Inputs:
;
;	None
;
; Outputs:
;
;	R0-R1	Destroyed
;	R2	Status code
;	R3	Terminator character
;	R4	Size of substring preceding terminator
;		(does not count the terminator)
;	R5	Address of substring preceding terminator (r7 on entry)
;	R6	Size of remainder of input string (past terminator)
;	R7	Address of remainder of input string (past terminator)
;
; Implicit Outputs:
;
;	None
;
; Completion Codes:
;
;	The status code in R2 has the following bits set
;	to indicate various contents of the field.
;	All other bits are returned as zero.
;
;	V_NULL		Field contains no characters (terminator only)
;	V_ALPHA		Field contains alphabetic characters
;	V_NUMERIC	Field contains numeric characters
;	V_NOT_OCTAL	Field contains '8' or '9'
;	V_$_		Field contains '$' or '_'
;	V_WILD		Field contains '*' or '%'
;	V_MINUS		Field contains a leading minus sign
;	V_NOTERM	End-of-string was reached before terminator was found
;	V_INVALID	Field contains one or more invalid characters
;	V_ACS		Field contains a node name followed by an
;			 access control string
;	V_QUOTED	Field contains a valid quoted ANSI-"a" string
;	V_PWD		Field contains an access control string with
;			 its password masked out
;
; Side Effects:
;
;	Return is made to 1 of 3 points defined by the NXTFLD  macro:
;
;		1.  at the label defined by the NULL = parameter
;		    if the input string is null
;		2.  at the label defined by the EOS = parameter
;		    if the field is terminated by end of string
;		3.  in-line (after the two in-line byte offsets)
;		    if a terminator was seen
;--

;+
; Entry point for NEXT_FIELD.
;-

NEXT_FIELD:				;
	MOVL	R7,R5			; Copy start of string address
	CLRQ	R2			; Initialize status to success
					;  and zero the terminator
	TSTL	R6			; Check for null string
	BGTR	GETCHR			; Proceed with parse of string
NULL:	INCL	(SP)			; Bump to null return offset
	BRW	EOSRTN			; Take end-of-string exit
GETCHR:	MOVB	(R7)+,R3		; Pick up next character

;
; Check for alphabetic - takes advantage of fact that ASCII code for
; left bracket is one greater than the ASCII code for Z.
;

	CMPB	R3,#^A/[/		; Is char greater than Z?
	BGEQU	CHKBRACKET		; Branch if so
	CMPB	R3,#<^A/A/-1>		; < A?
	BGTRU	ALPHA			; Branch if not (it's alphabetic)

;
; Check for numeric character.
; Takes advantage of the fact that the ASCII code for colon
; is one greater than the code for 9.
;

	CMPB	R3,#^A/:/		; Is char > 9?
	BGEQ	CHKCOLON		; Branch if so
	CMPB	R3,#^A/0/		; Is char < 0 ?
	BLSS	10$
	BRW	NUMERIC			; Branch if not (it's numeric)

;
; Check for quote (valid only if part of access control string in node name).
;

10$:	CMPB	R3,#^A/"/		; Branch if '"'
	BNEQ	20$
	BRW	QUOTE			;

;
; Check for period, dollar sign, asterisk, percent sign, comma, and minus sign.
;

20$:	CMPB	R3,#^A/./		; Branch if '.'
	BEQL	TERMINATOR
	CMPB	R3,#^A/$/		; Branch if '$'
	BEQL	DOLLAR_UNDER		;
	CMPB	R3,#^A/*/		; Branch if '*'
	BEQL	PCENT_OR_STAR		;
	CMPB	R3,#^A/%/		; Branch if '%'
	BEQL	PCENT_OR_STAR		;
	CMPB	R3,#^A/,/		; Branch if ','
	BEQL	TERMINATOR		;
	CMPB	R3,#^A/-/		; Branch if '-'
	BEQL	MINUS			;

;
; An invalid character has been encountered.
;

INVALID:				;
	SSB	#V_INVALID,R2		; Flag invalid character
	BRB	TRYNXT			; And continue scan

;
; Check for left bracket, lower case ASCII, right bracket, underscore.
;

CHKBRACKET:				;
	BEQL	TERMINATOR		; Branch if left bracket
	CMPB	R3,#LOWERCASE_A		; Lower case ASCII?
	BLSSU	10$			; Branch if not
	CMPB	R3,#LOWERCASE_Z		; Well is it?
	BLEQU	ALPHA			; Branch if yes
10$:	CMPB	R3,#^A/_/		; Branch if '_'
	BEQL	DOLLAR_UNDER		;
	CMPB	R3,#^A/]/		; Branch if not ']'
	BNEQ	INVALID			;

;
; Character was right bracket - fall thru to terminator.
; Terminator was seen.
;

TERMINATOR:				;

;
; Calculate length of field not including terminator.
;

	SUBL3	R5,R7,R4		;
	SOBGTR	R4,10$			; Don't count terminator
	BISB2	#M_NULL,R2		; Flag null field
10$:	DECL	R6			; Decrement remaining string count
					;  to account for terminator
	ADDL2	#2,(SP)			; Skip alternate returns
	BRW	RTN			;

;
; Character was alphabetic.
; Set flag and continue scan.
;

ALPHA:	BISB2	#M_ALPHA,R2		;
TRYNXT:	SOBGTR	R6,GETCHR		; Branch if more to scan
	SUBL3	R5,R7,R4		; Set field size

;
; Input string exhausted before terminator was seen.
; Set flag to indicate no terminator and take EOS return.
; (Note that the output string cannot be null.)
;

NOTERM:	SSB	#V_NOTERM,R2		; Flag condition
EOSRTN:	MOVZBL	@0(SP),R0		; Pick up EOS return offset
	ADDL2	R0,(SP)			; Add it to return PC
	BRW	RTN


;
; Check for colon, semi-colon, <, and >
;

CHKCOLON:				;
	BEQL	TERMINATOR		; Branch if ':'
	CMPB	R3,#SEMICOLON		; Branch if ';'
	BEQL	TERMINATOR		;
	CMPB	R3,#^A/</		; Branch if '<'
	BEQL	TERMINATOR		;
	CMPB	R3,#^A/>/		; Branch if '>'
	BEQL	TERMINATOR		;
	BRB	INVALID			; It's an invalid character

;
; Character was numeric  -  check also for octal.
; Set flag and continue scan.
;

NUMERIC:				;
	BISB2	#M_NUMERIC,R2		; Show numeric
	CMPB	R3,#^A/7/		; Is it also octal?
	BLEQ	TRYNXT			; Branch if yes
	BISB2	#M_NOT_OCTAL,R2		; No, so flag it
	BRB	TRYNXT			;

;
; Character was either dollar sign or underscore.
; Set flag & continue scan.
;

DOLLAR_UNDER:				;
	BISB2	#M_$_,R2		;
	BRB	TRYNXT			;

;
; Character was either an asterisk or a percent sign.
; Set wild card flag.
;

PCENT_OR_STAR:				;
	BISB2	#M_WILD,R2		;
	BRB	TRYNXT			;

;
; Character was minus sign.
; Check for 1st character of field and if not declare invalid,
; otherwise set flag.
;

MINUS:	SUBL3	R5,R7,R4		; Get the character position
	SOBGTR	R4,INVALID		; Branch if not first character
	BISB2	#M_MINUS,R2		; Flag minus
	BRB	TRYNXT			; And continue


;+
; Character was a quote ...
;
; An access control string (appearing as an embedded quoted string) is
; allowed after the node name in a node spec string. A leading quote has been
; found, so check for the matching quote and verify that this is followed
; by a double colon delimiter before setting the V_ACS flag; otherwise,
; treat the leading quote as an invalid character.
;-

QUOTE:	$PSECT_BR	NL$NETWORK	;
	DECL	R6			; Adjust count for leading quote
					;  that was skipped
	LOCC	#^A/"/,R6,(R7)		; Search for matching quote
	BEQL	5$			; Branch if no match
	CMPB	R0,#<1+2>		; Are there at least two characters
					;  beyond the quote character?
	BLSS	5$			; Branch if not enough
	INCL	R1			; Skip over matching quote
					; Note: R6 will be adjusted at TRYNXT
	CMPW	(R1),#^A/::/		; Does double colon delimiter
					;  immediately follow?
	BNEQ	5$			; Branch if not
	SSB	#V_ACS,R2		; Denote access control string present

;
; Set V_PWD if the access control string contains a substring of 'password'
; to indicate that the password has been masked out of the node spec string.
;

	PUSHR	#^M<R0,R1,R2,R3>	; Save registers
	MOVQ	#^A/password/,-(SP)	; Push substring to match on stack
	SUBL3	R0,R6,R1		; Compute size of access control string
	MATCHC	#8,(SP),R1,(R7)		; Search for substring of 'password'
	POPR	#^M<R0,R1>		; Discard substring (preserving Z-bit)
	POPR	#^M<R0,R1,R2,R3>	; Restore registers (preserving Z-bit)
	BNEQ	3$			; Branch if no match found
	SSB	#V_PWD,R2		; Set status bit

;
; Finish processing of access control string.
;

3$:	MOVQ	R0,R6			; Update byte remaining count in R6
					;  and string pointer in R7
	BRW	TRYNXT			; Examine next character

;
; We've tried this as an access control string and it didn't make it.  Now
; we'll see if it looks good as an ANSI-"a" magtape quoted string name.
; To wit: starts and ends with a ", imbedded "'s allowed but must be
; doubled.  Characters between space and Z allowed excepting #,$,@.
; Lowercase also allowed as it will be upcased later when the string
; is copied into FWA$Q_NAME.  We verify that the initial " starts
; the string, but cannot easily verify that the last quote we see ends
; the string.  That is done at label RTN.
;
; R6 = length+1 of what's left
; R7 = Address of what's left
; R0,R1 available as scratch
; R3 used to store current character
;

5$:	INCL	R6			; Restore R6 to value on entry
	PUSHL	R3			; make some space
	SUBL3	R5,R7,R0		; are we at front of string?
	CMPB	#1,R0			; ?
	BNEQ	10$			; if neq we aren't, error
	MOVQ	R6,R0			; copy descriptor of string
	BRW	15$			; enter loop in progress

;
; Something was wrong with string -- clear quoted and exit with invalid
; since quotes which are not access control strings or ANSI-"a" quoted
; strings are invalid characters.
;

10$:	BICW2	#V_QUOTED,R2		; not quoted string anymore
	POPL	R3			; restore register
	BRW	INVALID			; set V_INVALID and renter loop

;
; Got a character in R3 -- go thru chain to see if character is valid
;

12$:	CMPB	#^A/z/,R3		; check for lowercase
	BLSSU	10$			;
	CMPB	#^A/a/,R3		; lower bound for lowercase
	BLEQU	15$			; ok -- lower case accepted
	CMPB	#^A/Z/,R3		; ANSI-"a" run
	BLSSU	10$			; greater than Z invalid
	CMPB	#^A/ /,R3		; less than space invalid
	BGTRU	10$			;
	CMPB	#^A/#/,R3		; # invalid
	BEQL	10$			;
	CMPB	#^A/$/,R3		; $ invalid
	BEQL	10$			;
	CMPB	#^A/@/,R3		; @ invalid
	BEQL	10$			;

;
; We've got a valid character
;

15$:	DECL	R0			; figure how many left
	BEQL	10$			; if last and not " then error

	MOVB	(R1)+,R3		; get next character
	CMPB	#^A/"/,R3		; is it quote?
	BNEQ	12$			; if no then check for normal chars

;
; We've got a quote (and not the leading one, either).  
;

	DECL	R0			; figure how many chars left
	BEQL	30$			; end of string

;
; String not over and we've seen a quote other then the first one.
; If another quote, then back into the scan as we're still within
; quoted string.  If not another quote, then end of quoted string
; and back to main routine.
;

	MOVB	(R1)+,R3		; get character
	CMPB	#^A/"/,R3		; is it quote?
	BEQL	15$			; if yes, then go for next char
	DECL	R1			; back up over non-quote char


;
; Exit this code section back to main routine -- set up R6,R7 to
; reflect rest of string (note R6 must be count of rest of chars +1)
; and set V_QUOTED.
;

30$:	INCL	R0			; adjust for TRYNXT SOB
	MOVQ	R0,R6			; set rest of string
	SSB	#V_QUOTED,R2		; valid quoted string so far
	POPL	R3			; restore scratch register
	BRW	TRYNXT			; reenter loop in progress
	$PSECT_RESTORE			;

;
; Common exit path -- do checks necessary for V_QUOTED.
;

RTN:

;
; At this point, V_QUOTED means that field contained
; a valid quoted string and that the quoted string started the field. A
; truly valid quoted string must entirely fill the field, so we now must
; see that if V_QUOTED is set the last character of the string is a quote.
;

10$:	BBC	#V_QUOTED,R2,15$	; If not quoted, then continue
	CMPB	#^A/"/,-1(R4)[R5]	; is last character quoted?
	BEQL	15$			; if eql yes -- leave V_QUOTED set
	BICW2	#V_QUOTED,R2		; not a valid quoted string
	SSB	#V_INVALID,R2		; and invalid if we got this far and
					;  it turned out not to be valid quoted
15$:	RSB				;

	.SBTTL	CHECK_FIELD - CHECK FOR VALID FIELD AND COPY ROUTINE

;++
; Functional Description:
;
; This routine checks the field described by <R4,R5> for
; validity based upon the field flags in R2 and the
; desired checks specified by the in-line arguments.
;
; Checks and operations performed:
;
;	1.  checks that the field contains no invalid characters
;	    (V_INVALID bit in R2).
;	2.  checks that none of the bits specified in the CHECKS=
;  	    parameter are on in R2 byte 0.
;	    (NULL, ALPHA, NUMERIC, NOT_OCTAL, $_, WILD, and MINUS)
;	3.  checks that the field size is not greater than that
;	    specified in the MAXSIZ= parameter.
;	4.  if the field is null, return.
;	5.  if FWA$V_RLF_PASS set and the field is not
;	    selected by the type of parse (input or output, based
;	    upon the FOP bit OFP), return, thus ignoring the field.
;	6.  if the filename element specified in the FIELD=
;	    parameter has already been seen, then
;	    return unless FWA$V_DUPOK is clear (duplicates
;	    not allowed) in which case generate an error.
;	7.  flag the filename element present.
;	8.  if the field is a wild card, flag that too,
;	    both for specific field and overall.
;	9.  if this is a logical name (FIELD=logname)
;	    save the descriptor only, otherwise copy the
;	    field to the element buffer setting the
;	    length in the descriptor.
;      10.  return past the in-line arguments.
;      11.  if an error is detected, generate an error by
;	    moving the code specified in the ERR=parameter
;	    to R0, popping the return PC and branching to PRSERR.
;      12.  set V_NOT_COPIED if duplicate field was ignored
;	    (i.e., not copied to element buffer).
;
; Calling Sequence:
;
;	Via the CHKFLD macro, e.g.,
;	CHKFLD	CHECKS=<M_NULL!M_WILD>,		; R2 bits that must be off
;		FIELD=DEVICE			; Field name
;		MAXSIZ=15,			; Field maximum size
;		ERR=DEV				; Error code
;
; Alternate entry at CHECK_DIR_FIELD with AP = address of arg list.
;
; Input Parameters:
;
;	R2	Flags word (from NEXT_FIELD)
;	R4	Field length
;	R5	Field starting address
;	R8	FAB address
;	R10	FWA address
;
;	The in-line parameters from the CHKFLD macro
;
; Implicit Inputs:
;
;	The current state of the FWA, including
;	FWA$B_FLDFLGS, FWA$V_RLF_PASS,  FWA$V_DUPOK, FWA$V_LOGNAME
;
; Outputs:
;
;	R0	Completion code
;	R1	Destroyed
;	R2	flags word (V_NOT_COPIED affected only)
;	R4-R5	Destroyed
;	AP	Set to address of argument list
;
; Implicit Outputs:
;
;	-FWA$B_FLDFLGS or FWA$V_LOGNAME or FWA$V_NODE set if field copied
;	-FWA$B_WILDFLGS and FWA$V_WILD set if field is wild
;	-FWA$B_DIRFLGS set if directory field (also FWA$B_DIRWCFLGS)
;	-the indicated FWA element buffer and its descriptor are
;	 updated if field copied
;
; Completion Codes:
;
;	R0	(see 10 and 11 under functional description)
;
; Side Effects:
;
;	None
;
;--

;+
; Entry point for CHECK_FIELD.
;-

CHECK_FIELD::				;
	MOVL	(SP),AP			; Get pointer to in-line args
	ADDL2	#7,(SP)			; Skip past in-line args

;+
; Alternate entry point for multi-level directory processing.
;-

CHECK_DIR_FIELD:			;
	MOVL	AP,R1			; Copy the arglist address
	BBS	#V_INVALID,R2,1$	; Branch if invalid char in field
	BITW	(R1)+,R2		; Check if any bad bit on
	BNEQ	1$			; And branch if so
	MOVZBL	(R1)+,R0		; Get MAXSIZ
	CMPL	R4,R0			; Is field too long?
	BLEQU	2$			; continue if not so
1$:	BRW	CHKERR			; go return an error

2$:	MOVZBL	(R1)+,R0		; Get FWA bit
	BBC	#FWA$V_RLF_PASS,(R10),10$; Branch if not parse of RLF string

;
; This is the parse of the related file string.
; Look at the OFP FOP bit to determine whether this field is
; to be utilized or not.
;
; The rules are:
;	If this is a parse of an input file all fields except version are sticky.
;	If this is a parse of an output file spec, only the filename and type
;	are sticky. (Sticky means they will be defaulted from the related file
;	resultant filename string.) Additionally, if the name, type, directory or
;	version of an output file string contains a wild card, this implies
;	an explicit default from the related filename string.
;

	BBC	#V_NAMTYP,(AP),5$	; If not name or type (or sticky dir) go away
3$:	BBC	#FAB$V_OFP+FOP,(R8),15$	; If not output file parse go away

;
; This is an output file parse, name or type or directory field.
; Check for wild card and if so use the RLF field, else just use if
; not already seen.
;

	ASSUME	FWA$V_WC_NAME EQ <FWA$V_NAME+8>
	ASSUME	FWA$V_WC_TYPE EQ <FWA$V_TYPE+8>

	BBS	R0,1(R10),20$		; Branch if field is wild card
	BRB	15$			; Go default the field if not seen

;
; Check for this field being the file version and process accordingly.
;

5$:	CMPB	R0,#FWA$V_VERSION	; Is this the version?
	BNEQ	9$			; Branch if not
	BBC	#FAB$V_OFP+FOP,(R8),CHKRTN; Branch if input parse (ignore)
	BBC	#FWA$V_WC_VER,(R10),CHKRTN; Branch if not wild card (")
	CSB	#FWA$V_CUR_VER,(R10)	; Clear wc ver flg for current file
	BRB	20$			; Go to RLF version

;
; The field is node, device or directory. Use as default only if this
; is an input file parse.
;

9$:	BBS	#FAB$V_OFP+FOP,(R8),CHKRTN; Ignore node, device, or directory

;
; If not wanted ...
;
; Check for field null already seen.
;

10$:	ASSUME	V_NULL EQ 0

	BLBS	R2,CHKRTN		; Branch if null field
15$:	BBSS	R0,(R10),CHKDUP		; Branch if duplicate (ignore)

;
; At this point we are really going to use the string.  If we're doing
; NAME now, and its V_QUOTED, then it is an error we we've already
; done a type.  Also show that we have a type now, too.
;

	CMPB	R0,#FWA$V_NAME		; NAME this pass?
	BNEQ	17$			; if neq no
	BBS	#V_QUOTED,R2,17$	; if quoted, ok

;
; Here we have a non-quoted name, so we can't rely on the length check done
; above by the length passed in from the call to CHKFLD.  That will check
; for the overall length of the string.  Here we check to see if the non-
; quoted name is no greater than FWA$C_MAXNAME, the "normal" length of 
; file names.
;

	CMPL	R4,#FWA$C_MAXNAME	; is name too long?
	BGTRU	1$			; if gtru yes

;
; Else show we have it now ...
;
; Check for wild card.
;

17$:	BBC	#V_WILD,R2,20$		; Branch if field not a wild card
	SSB	#FWA$V_WILDCARD,(R10)	; Set overall flag

	ASSUME	FWA$V_WC_VER EQ <FWA$V_VERSION+8>
	ASSUME	FWA$V_WILD_UFD EQ <FWA$V_DIR1+8>

	SSB	R0,1(R10)		; Set specific wild card
	TSTB	FWA$B_DIRWCFLGS(R10)	; Any directory wild card bits set,
	BEQL	18$			;  No - go away
	SSB	#FWA$V_WILD_DIR,(R10)	;  Yes - set the wild dir summary bit

;
; At same bit position in next byte
;

18$:	CMPB	R0,#FWA$V_VERSION	; Wildcard version?
	BNEQ	20$			; Branch if not
	SSB	#FWA$V_CUR_VER,(R10)	; Yes, set current file wc ver flg

;
; we have a wildcard version. check to make sure that it is of the proper
; syntax (ie "*" and only "*").
;

	CMPB	#1,R4			; if the length of the wild version
	BNEQ	CHKERR			; is not one it can't be "*"!

	CMPB	#^A'*',(R5)		; if the wild version violates the 
	BNEQ	CHKERR			; legal syntax rules return an error

;
; Calculate address of field descriptor in FWA.
;

20$:	MOVZBL	(R1),R0			; Get descriptor offset
	ADDL2	R10,R0			;  and make it an address

;
; If this is a logical name don't copy the string.
;

	CMPB	(R1),#FWA$Q_LOGNAME	;
	BEQL	CPYDSC			; Branch if this is a logical name
	PUSHR	#^M<R2,R3>		; Save flags and terminator
	MOVL	R4,(R0)+		; Save length
	MOVC3	R4,(R5),@(R0)+		;  and copy the string
	POPR	#^M<R2,R3>		; Restore flags and terminator
CHKSUC:	RMSSUC				; Exit to caller with success
	RSB				;

;
; Extended branch
;

CHKRTN:	SSB	#V_NOT_COPIED,R2	; Flag field not copied
	BRB	CHKSUC			;

;
; Don't copy of string since it's a logical name; just save descriptor.
;

CPYDSC:	MOVQ	R4,(R0)			;
	BRB	CHKRTN			;

;
; This field has already been set.
; Ignore it as long as FWA$V_DUPOK is set.
;

	ASSUME	FWA$V_DUPOK EQ 0

CHKDUP:	BLBS	(R10),CHKRTN		;

;
; If this is duplicate device because of NAM block input, ignore
; the duplicate.
;

	CMPB	R0,#FWA$V_DEVICE	; Is this a device?
	BNEQ	CHKERR			; Branch if not - solid error
	BBSC	#FWA$V_NAM_DVI,(R10),CHKRTN; Branch if device came from DVI

;
; NAM block, ignoring duplicate.
;
; An error has been encountered.
;

CHKERR:	$PSECT_BR	L$RMS0		;
	MOVZWL	5(AP),R0		; Set error code
	BBS	#V_RETURN_ON_ERR,(AP),10$; Branch if return specified
	POPR	#^M<R1>			; Pop return PC
	BRW	PRSERR			;  and exit
10$:	RSB				;
	$PSECT_RESTORE			;

;++
;
;	MOVE_RELATED
;
;	   This routine substitutes subdirectories from the related file name
;	block for subdirectories in the expanded file name string. The 
;	algorithm is as follows:
;
;		Get 1st related directory we're supposed to move
;		Move it
;		While there are related directories and the related-file
;		directory specification terminator is not encountered
;		    move them
;
;
;	CALLING SEQUENCE
;	
;	    PUSHL	number of the related subdir to start at
;	    PUSHL	#FLAG - see below
;	    CALLS	#2,STICKY_WILD
;
;	INPUT
;
;	    4(AP) - number of related subdirectories to move
;	    8(AP) - number of the related subdirectory to start with
;
;	IMPLICIT INPUT
;
;	    R2 - Flags
;	    R3 - Terminator
;	    R4 - Descriptor of current RLF subdir
;	    R5 - Descriptor of related RLF subdir
;	    R6 - Descriptor of RLF string
;	    R7 - Descriptor of RLF string
;
;	    R8 - addr of FAB
;	    R10 - addr of FWA
;
;	    R11 - Disp to expanded string directory descriptors
;
;	IMPLICIT OUTPUT
;
;	    Directory descriptor is replaced with either a related subdirectory
;	descriptor or a series of subdirectory descriptors
;
;	    FWA$V_DIR_LVLS is updated to contain the number of directories
;	now in the output-file.
;
;	OUTPUT
;
;	    R0 - status
;	    8(AP) - number of RLF subdir we just looked at
;
;--


	$NEWPSECT F$RMSOPEN0NAM
MOVE_RELATED:
	.WORD ^M<R9>
	EXTV	#FWA$V_DIR_LVLS,-	; Get the # of directory levels
		#FWA$S_DIR_LVLS,(R10),R9

;
;   Get first related directory we're supposed to move
;

	BRB	40$			; Go start loop
10$:	CMPB	R3,FWA$B_DIRTERM(R10)	; Are we done w/related directory ?
	BEQLU	M_EXIT			; Yes - exit
40$:	NXTFLD	EOS=M_EXIT,NULL=M_EXIT	; Get next related directory
	SOBGEQ	8(AP),10$		; Loop until we find it

;
;   We have a related directory name 
;   move it
;

50$:	INCL	R9			; Number of subdirs
	CMPB	R9,#FWA$C_MAXSUBDIR	; Too many subdirs ?
	BGTRU	M_ERR			; Yes - error

	ADDB2	R4,FWA$B_DIRLEN(R10)	; Accumulate the total directory length
	CMPB	#FWA$C_MAXDIRLEN,FWA$B_DIRLEN(R10) ; Is it too long ?
	BLSS	M_ERR			; Yes - exit w/err

	PUSHL	AP			; Save the argument pointer
	PUSHL	R11			; Displacement to descriptor
	BISL	#<<RMS$_DIR &^XFFFF> @8>,(SP) ; Error if anything wrong
	PUSHL	#<M_NULL!M_MINUS!M_$_!M_RETURN_ON_ERR!M_NAMTYP>!- ; Things to check for
		<FWA$C_MAXNAME @ 16>!-	; Maximum directory size
		<FWA$V_DIR1 @ 24>	; compute FWA flag to check by adding 
	ADDB2	R9,3(SP)		; subdir number to base directory bit #
	MOVL	SP,AP
	BSBW	CHECK_DIR_FIELD		; Check (and move) this directory

	ADDL	#8,SP
	MOVL	(SP),AP			; Restore the argument pointer

	BLBC	R0,M_EXIT		; Exit if error otherwise 
	CSB	R9,FWA$B_DIRWCFLGS(R10)	; clear corresponding wild dir bit
	DECL	4(AP)			; decrm counter of max# of dirs to move
	BEQL	M_EXIT			; exit if no more to be moved


;
; there may be more related-file subdirectories to move because 4(AP) > 0
; but no related-file subdirectories to move because the directory terminating
; character is encountered. this situation can arise because STICKY_DIR 
; requests 8 directories to be moved when it encounters a trailing ellipsis,
; or the output-file directory specification consists of [*] or [*...], and
; because there may be more trailing asterisks in the output-file directory
; specification then there are related-file directories to substitute. when
; the latter case is encountered, adjust the number of subdirectories so that
; when FWA$V_DIR_LVLS is set it will correct reflect the presence of the 
; remaining asterisks.
;

	CMPB	R3,FWA$B_DIRTERM(R10)	; have we moved the last one ?
	BNEQU	60$			; No, go get next dir field

	ADDL3	#FWA$V_DIR2,R9,R1	; check to see whether there are any
	BBC	R1,(R10),M_EXIT		; trailing output-file directories
	ADDL2	4(AP),R9		; and if so add the number to R9 so
	BRB	M_EXIT			; #subdirs can be set correctly in FWA

;
;   Get next related subdirectory and go move it 
;

60$:	NXTFLD	EOS=M_EXIT,NULL=M_EXIT	; 
	ADDL	#8,R11			; Position to next output descriptor
	BRB	50$			; Go move it

;
;   clean up and exit 
;

M_ERR:	RMSERR	DIR

M_EXIT: INSV	R9,#FWA$V_DIR_LVLS,-	; Restore the number of subdirs
		#FWA$S_DIR_LVLS,(R10)
	RET

;+++
;
;	STICKY_DIR
;
;	    This routine substitutes subdirectories from the RLF name block
;	for wild subdirectories in the expanded directory string.
;	The algorithm is:
;
;		if the output-file directory is in UIC format
;		    replace wild group part with related-file group part
;		    replace wild member part with related-file member part
;
;		if the output-file directory is wild (ie- [*] or [*...] ONLY)
;		    move the entire related-file directory specification
;		    if the related-file directory is in UIC format
;			mark the output-file directory as in UIC format
;
;		if the output-file directory has a trailing ellipsis ("...")
;		    move the entire related-file subdirectory tree starting 
;			from the first wild related-file (sub)directory
;		    if there is no wild related-file (sub)directory, just 
;			remove the ellipsis
;
;		if the output-file directory contains trailing asterisks ("*")
;		    substitute for the trailing asterisks, related-file
;			(sub)directories, starting with the first wild
;			related-file (sub)directory
;
;	Additional Syntax Rules:
;
;	1. No substitution occurs when the output-file directory specification
;	   is in UFD format and partially wild, but there were no wild 
;	   (sub)directories in the related-file directory specification.
;
;	2. Legal wildcards ("*" and "...") can only trail and are mutually 
;	   exclusive.
;
;	3. The format of partially wild output-file directory specifications 
;	   and their related-file directory specifications must be the SAME 
;	   (UFD and UFD or UIC and UIC).
;
;
;	CALLING SEQUENCE
;	
;	    CALLS #0,STICKY_DIR
;
;	INPUT
;
;	    none
;
;	IMPLICIT INPUT
;
;	    NXTFLD registers
;		R2 - flags
;		R3 - terminator
;		R4 - descriptor of current RLF subdir
;		R5 - descriptor of current RLF subdir
;		R6 - descriptor of RLF string
;		R7 - descriptor of RLF string
;
;		R8 - FAB
;		R10 - FWA
;
;	OUTPUT
;
;	    R0 - STATUS
;
;	IMPLICIT OUTPUT
;
;	    Wild directory descriptors may be changed to actual values
;	    FWA$V_DIR_LVLS is appropriately updated
;	    FWA$B_DIRLEN is appropriately updated
;
;	SIDE EFFECTS
;
;	    none
;
;
;---

STICKY_DIR:
	.WORD 	^M<R9,R11>
	PUSHL	R7			; temporarily store RLF string address
	BBS	#FWA$V_WILD_DIR,(R10),- ; If there are no wild directories
		10$			; there is nothing to do so go
	BRW	S_EXIT			; exit with success

;
;   initialize some variables and obtain the RLF NAM block address. probe
;   both NAM blocks.
;

10$:	MOVZBL	#FWA$V_WILD_UFD,R9	; R9 <- disp to wild dir bits in FWA
	MOVZBL	#FWA$Q_DIR1,R11		; R11 <- disp to directory descriptors
	MOVL	FAB$L_NAM(R8),R7	; Get name block addr
	BSBW	RM$CHKNAM		; Check access
	BLBC	R0,34$			; Quit on failure
	MOVL	NAM$L_RLF(R7),R7	; Get RLF block addr
	BSBW	RM$CHKNAM		; Check access
	BLBC	R0,34$			; Quit on failure
	MOVL	R7,R1			; otherwise, save RLF NAM block address
	MOVL	(SP),R7			; and restore RLF buffer address to R7


;
; implement the syntax rules restricting partially wild UFD output-file
; directory specifications to UFD formatted related-file directory 
; specifications and partially/totally wild UIC output-file directory
; specifications to UIC formatted related-file directory specifications.
; also, if the output-file directory is totally wild ([*] or [*...]) and the
; related-file directory specification is in UIC format, mark the output-file
; directory specification as being in UIC format.
;

	BBC	#FWA$V_GRPMBR,(R10),20$	; if the output-file is in UIC format
	BBC	#NAM$V_GRP_MBR,-	; but the related-file is not, then
		NAM$L_FNB(R1),35$	; go exit with an error
	BRW	80$			; both are in UIC format

20$:	BBC	#NAM$V_GRP_MBR,-	; if the related-file is in UIC format
		NAM$L_FNB(R1),30$	; but the output-file is not, the 
	BBC	R9,(R10),35$		; latter must be completely wild
	SSB	#FWA$V_GRPMBR,(R10)	; indicate output-file in UIC format

;
; if the first output-file directory is wild and is the correct type (ie - "*")
; but subdirectories follow, return an error
;

30$:	BBC	R9,(R10),40$		; if the first directory is wild,
	BSBW	CHECK_WLD_FIELD		; it must be of the correct type
	BLBC	R0,35$			; and must not be followed by any 
	BBS	#FWA$V_DIR2,(R10),35$	; directory or it is an error

;
; if the output-file directory is totally wild and of the correct syntax
; (ie [*] or [*...]), setup to substitute and go substitute in the entire
; directory specification of the related-file. if however, the related-file
; directory specification is [] then there are no related (sub)directories
; to transfer, so immediately return success.
;

	CMPB	1(R5),FWA$B_DIRTERM(R10); if the related-file contains a null
	BNEQ	33$			; length directory specification then
	BRW	S_EXIT			; go immediately return success

33$:	CLRB	FWA$B_DIRLEN(R10)	; zero the directory length
	INSV	#FWA$C_MAXSUBDIR,-	; zero the number of subdirectory
		#FWA$V_DIR_LVLS,-	; levels kept within the FWA
		#FWA$S_DIR_LVLS,(R10)
	CLRL	-(SP)			; Start with the first related subdir
	PUSHL	#FWA$C_MAXSUBDIR+1	; transfer the entire related-file dir
	CALLS	#2,MOVE_RELATED		; Go do it
34$:	BRW	EXIT			; exit with the status returned

35$:	BRW	E_EXIT			; needed to reach E_EXIT!!!


;
; if the first directory in the output-file is not wild, find the first
; wild (sub)directory in the related-file. then prepare to find the number
; of trailing asterisks or the position of the trailing ellipsis in the 
; output-file directory specification.
;

40$:	FFS	#NAM$V_WILD_UFD,-	; find the offset in the filename bit
		#FWA$C_MAXSUBDIR+1,-	; field to the first related-file wild 
		NAM$L_FNB(R1),R0	; directory indicating bit
	SUBL3	#NAM$V_WILD_UFD,R0,R1	; compute level # of the wild dir
	CLRL	(SP)			; init wild directory counter to 0

;
; when an ellipsis is encountered in the scan of the output-file directory
; specification, if legal wildcards had already been encountered ( (SP) ~= 0)
; or if any subdirectory follows, an error is returned. otherwise, go 
; move the related-file directory subtree starting with the first wild
; (sub)directory in the related-file directory specification to the output-file
; directory specification starting at the position of the trailing ellipsis.
; if no related-file wild (sub)directories exist, just return success.
;

50$:	BBCC	#0,2(R10)[R11],60$	; go look at next dir if no ellipsis

	TSTL	(SP)			; error if any wild directories
	BNEQ	35$			; had already been encountered
	INCL	R9			; Correct R9 for ellipsis position
	SUBL3	#8,R9,R0		; error if any directory follows
	BBS	R0,(R10),35$		; the ellipsis in the output-file

	CMPB	#FWA$C_MAXSUBDIR+1,R1	; if there are no wild related-file
	BEQL	75$			; (sub)directories, then return success

	ADDL	#8,R11			; Increment descriptor address
	PUSHL	R1			; # of first wild related subdir
	PUSHL	#FWA$C_MAXSUBDIR+1	; transfer as many dirs as required
	CALLS	#2,MOVE_RELATED		; Go do it
	BRW	EXIT			; return with returned status


;
; if we have completely scanned the output-file directory specification, we
; go determine how many trailing asterisk were encountered, if any. otherwise,
; we test the next subdirectory to see if its wild. if it is, we go check its
; legality. if it is not, but a wild subdirectory preceeded it, return an 
; error. finally, if the next directory is not wild and no wild subdirectory
; preceeded it, go check whether an ellipsis follows.
;

60$:	INCL	R9			; Offset for next wild dir bit
	ADDL	#8,R11			; Disp for next descriptor

	CMPB	R9,#FWA$V_WILD_UFD+8	; if looked at all directories
	BEQL	70$			; then go decide what must be done
	TSTB	(R10)[R11]		; Is descriptor null ?
	BEQL	70$			; Yes - done with out dir

	BBS	R9,(R10),65$		; if subdir is wild, check its legality
	TSTL	(SP)			; if subdirectory is nonwild but the
	BEQL	50$			; preceeding directory was, go return 
63$:	BRW	E_EXIT			; an error, else go test for an ...

;
; when a wild subdirectory is encountered its legality is checked. if it is
; of the correct type (ie "*") we continue the scan of the output-file
; directory specification by checking whether an ellipsis follows. otherwise, 
; an error is returned.
;

65$:	BSBW	CHECK_WLD_FIELD		; Is wild dir the legal type ?
	BLBC	R0,63$			; No  - exit with error
	INCL	(SP)			; yes - increment wild dir count
	DECB	FWA$B_DIRLEN(R10)	; Decrement the total directory length
	BRB	50$			; continue looking at directories


;
; if when the entire output-file directory specification has been scanned, 
; no trailing asterisks were encountered, go return success; otherwise, compute
; the wild directory bit and directory descriptor displacements for the first 
; asterisk encountered, and go move the required number of related-file
; directories. if there arn't any wild related-file (sub)directories, then
; also immediately return success.
;

70$:	TSTL	(SP)			; if no trailing wild dirs found
	BEQL	S_EXIT			; then go return success

	CMPB	#FWA$C_MAXSUBDIR+1,R1	; if there are no wild related-file
75$:	BEQL	S_EXIT			; (sub)directories, then return success

	EXTZV	#FWA$V_DIR_LVLS,-	; extract the number of subdirectory
		#FWA$S_DIR_LVLS,(R10),R0; levels in the output-file, subtract
	SUBL2	(SP),R0			; the number of trailing asterisks,
	INSV	R0,#FWA$V_DIR_LVLS,-	; and reinsert the number of leading
		#FWA$S_DIR_LVLS,(R10)	; nonwild (sub)directories into the FWA

	SUBL2	(SP),R9			; compute wild dir bit and descriptor
	MULL3	#8,(SP),R0		; displacements for the first wild
	SUBL2	R0,R11			; directory found in the output-file
	BRB	110$			; go perform the substitution


;
; for UIC formatted output-file directories, preset the number of the 
; related-file directory to be first to be moved to 0 (the group), the number
; of directories to be moved to 1 (just the group part), and predecrement the
; total directory count appropriately.
;

80$:	CLRL	R1			; preset wild related-file dir # to 0
	MOVL	#1,(SP)			; preset number of dirs to move to 1
	DECB	FWA$B_DIRLEN(R10)	; decrement total directory length

;
; if the group part of the UIC formatted output-file directory is wild, make 
; sure its of a valid type, and then set the number of subdirectory levels kept
; within the FWA to -1 so that the first directory to be replaced will be the 
; group part of the output-file.
;

	BBC	#FWA$V_WILD_GRP,-	; if group of UIC format output-file 
		(R10),90$		; dir is not wild, go check member part
	BSBB	CHECK_WLD_FIELD		; if wild group part of dir is not
	BLBC	R0,E_EXIT		; valid then return an error
	INSV	#FWA$C_MAXSUBDIR,-	; zero the number of subdirectory
		#FWA$V_DIR_LVLS,-	; levels kept within the FWA
		#FWA$S_DIR_LVLS,(R10)

;
; if both the group and member parts of the UIC formatted output-file directory
; specification are wild (ie [*,*]), then make sure both are of the correct 
; type, increment the number of directories to be moved and decrement the 
; directory length appropriately, and then go substitute in both and member 
; parts from the UIC formatted related-file. if just the group part is wild, go
; substitute just the group part from the related-file.
;

	BBC	#FWA$V_WILD_MBR,-	; if output-file dir is not [*,*]
		(R10),110$		; then go setup transfer as is
	PUSHR	#^M<R9,R11>		; save bit and descriptor displacements
	INCL	R9			; increment wild dir bit displacement
	ADDL2	#8,R11			; increment dir descriptor displacement

	BSBB	CHECK_WLD_FIELD		; if wild member part of dir is not
	POPR	#^M<R9,R11>		; valid then return an error after 
	BLBC	R0,E_EXIT		; restoring saved displacement values
	INCL	(SP)			; increment count of wild directories
	DECB	FWA$B_DIRLEN(R10)	; decrease total directory length
	BRB	110$			; go transfer both group and member


;
; if just the member part of the UIC formatted output-file directory 
; specification is wild, make sure its of the correct type, and that the member
; part of the output-file directory is to be replaced by the member part of the
; the related-file directory specification before going and performing the 
; substitution.
;

90$:	INCL	R1			; related-file member to be transfered
	INCL	R9			; incrm wild bit disp to wild member
	ADDL2	#8,R11			; incrm descriptor to UIC member slot
	BSBB	CHECK_WLD_FIELD		; if wild group part of dir is not
	BLBC	R0,E_EXIT		; valid then return an error
	SUBB2	#<1@<FWA$V_DIR_LVLS-24>>,- ; Decrement the number of subdirs
		3(R10)

;
; when either UIC formatted output-file directory specifications or partially
; wild directory specifications in UFD formatted are involved, setup to move
; the required number of related-file directories (or directory parts in the
; case of a UIC formatted output-file directory), and go move them. return
; success when the substitution is completed.
;

110$:	PUSHL	R1			; # of first wild related subdir
	PUSHL	4(SP)			; number of directories to move
	CALLS	#2,MOVE_RELATED		; Go do it
	
	BBC	#FWA$V_GRPMBR,(R10),EXIT; go exit with status if not UIC
	SSB	#FWA$V_DIR_LVLS,(R10)	; UIC treated as having 2 levels
	BRB	EXIT			; and return with status

;
; exit with the appropriate status when done.
;

E_EXIT:	RMSERR	DIR
	BRB	EXIT

S_EXIT: MOVZBL	#1,R0
EXIT:	RET				; returning with status
.PAGE


;
; CHECK_WLD_FIELD
;
; This subroutine checks a wild field in the FWA (directory, subdirectory,
; subdirectory part in the case of UIC formatted directories, filename, or
; type) to make sure that it is in legal format. Legal format is "*" and 
; and "*" only.
;
; INPUT:	R10 - address of FWA
;		R11 - offset to field descriptor, the contents of which
;		      are to be checked for wild validity
;
; OUTPUT:	R0  - 1 if descriptor contains a legally formatted wild field
;		      0 otherwise
;

CHECK_WLD_FIELD:
	PUSHR	#^M<R2>			; Save register
	CLRL	R0			; Assume failure
	CMPB	#1,(R10)[R11]		; Is field one byte ?
	BNEQU	10$			; No - illegal output wild field

	ADDL3	R10,R11,R2		; R0 <- Addr of descriptor
	CMPB	#^A'*',@4(R2)		; Is field a '*' ?
	BNEQU	10$			; No - illegal output wild field

	MOVL	#1,R0			; Set success status
10$:	POPR	#^M<R2>			; Restore register
	RSB				;

	.END				; End of module
