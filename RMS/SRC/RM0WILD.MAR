	$BEGIN	RM0WILD,022,P$RMS0MISC,<DIRECTORY WILDCARDING>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; Facility: rms32
;
; Abstract:
;	this module contains all the routines
;	necessary to perform directory wildcarding
;	in file specification processing.
;
; Environment:
;	vax/vms
;
; Author:
;	Tim Halvorsen	AUG-1979
;
; Modified By:
;
;	V02-022	KEK0018		K. E. Kinnear		9-Feb-1982
;		Fix ASSUME for SWB offset into translation buffers for
;		new length of FWA$T_NAMEBUF.
;
;	V02-021	JWH0001		Jeffrey W. Horn		18-Jan-1982
;		Fix broken subroutine branch.
;
;	V02-020	TMK0025		Todd M. Katz		16-Dec-1981
;		Rip out all SDI stuff in RM$NEXTDIR. RM0WILD will not
;		(better not) be called for anything but files on disks.
;		Also FWA$B_DIRWCFLGS is being set incorrectly on repeated
;		searches involving ellipsis traversal because it is not
;		being set to the value it had after parse before the match
;		routine is called. Fix this bug by resetting FWA$B_DIRWCFLGS
;		to the value it had (before the first search began) before 
;		the match attempt is made. This will mean no change in it
;		if there were no ellipsis, but if there were it will end up
;		being set to its new value on a successful match.
;
;	V02-019	TMK0019		Todd M. Katz		25-Nov-1981
;		Skip any subtrees rooted at null length directory
;		filenames. Such subtrees are pruned, and their
;		contents NOT searched.
;
;	V02-018	TMK0018		Todd M. Katz		18-Nov-1981
;		Initialize certain control fields within the SWB to
;		their correct values for UIC directories even if these
;		fields are not needed for wildcard processing. This is
;		to avoid confusion when these fields are looked at.
;
;	V02-017	TMK0014		Todd M. Katz		12-Nov-1981
;		Change a BBC to a BBCC so that the flag SWB$V_FIRST is
;		always cleared after the first time through RM$NEXTDIR
;
;	V02-016	RAS0040		Ron Schaefer		26-Oct-1981
;		Implement rooted directories for concealed devices.
;		When setting the FID of the MFD, use the saved MFD_FID
;		of the rooted directory.
;
;	V02-015	TMK0010		Todd M. Katz		20_Oct_1981
;
;		A check is made to see whether I/O Rundown is in progress
;		after every ACP call, and if is, RM0WILD is immediately
;		terminated with a status of RMS$_NMF.
;
;	V02-014	TMK0007		Todd M. Katz		28_Aug_1981
;
;		Performance enhancements. Initially, all leading nonwild
;		tokens are made part of the directory string, and their
;		existance is confirmed. Then, each and every remaining token
;		in the pattern string up to, but not including the first
;		ellipsis, represents the pattern for the directory name that
;		is to match it, and these are resolved. All branches below the
;		level of the root of the first ellipsis must be searched for 
;		any and all directories. If there are no ellipsis, or above the
;		root of the first ellipsis, crosswise directory tree traversal
;		can only occur if wild nonellipsis tokens were encountered. 
;		After each directory name is resolved, a call is made to a
;		matching routine to determine whether the directory string
;		now matches the entered pattern. This routine returns partial
;		or total success, and it can only return failure when it is
;		impossible to match the trailing tokens while within a bounded
;		ellipsis traversal. NOTE: the number of characters in a 
;		directory specification is limited to 81 although theoretically
;		it would be possible to have (8 levels * 9 + 8 ... * 3 + 2)
;		= 98 characters.
;
;	V02-013	TMK0006		Todd M. Katz		21_Aug_1981
;		Complete rewrite. The algorithm upon which this module had
;		been formerly based was scrapped, and a completely new one
;		substituted. The new algorithm guarentees that each and
;		every directory specification matching an inputed pattern 
;		is touched only once by performing a "pruned" pre-order
;		traversal, and returning only those directories matching
;		the inputed pattern string. Pruned in the sense that not
;		all directories are touched, but rather, as few as possible.
;		Various optimizations have been implemented to reduce
;		extraneous calls to the ACP, and several more, which are
;		required, will be included within a succeeding enhancement.
;
;		Checked this in as new module. Previous edit history invalid.
;
;	V02-012	KEK0007		K. E. Kinnear		11-Aug-1981
;		Change IFB$L_AS_DEV to IFB$L_PRIM_DEV where necessary.
;
;	V02-011 TMK0005		Todd M. Katz		11_Aug_1981
;		Delete errant ASSUME statement within FIND_DIR. It was
;		no longer needed with the addition of the new field
;		FWA$T_WILD.
;
;	V02-010 TMK0004		Todd M. Katz		10_Aug_1981
;		Correction of the parameter FWA$C_MAXDIRLEN to its
;		correct size of 81 resulted in a much larger SWB.
;		Since only 79 bytes are required ([] are not copied
;		into SWB$T_PATTERN), a change was made to reflect this
;		and to take advantage of a new scratch field, FWA$T_WILD.
;
;	V02-009	TMK0001		Todd M. Katz		29_Jul_1981
;		Fix some problems with handling of bounded elipsis
;		and multiple wild card directory specifications.
;		Changes included deletion of SWB$B_WCCLEVEL, extension
;		of SWB$B_ROOT to a word, the addition of one flag to
;		SWB$W_FLAGS (SWB$V_ROOT), and minor alterations to 
;		the depth-first search algorithm in order to resolve
;		the existing problems. Two routines (UP_PARENT and
;		STRIP_NONWILD) were completely rewritten.
;
;	V02-008	PSK0003		Paulina Knibbe		27_Apr-1981
;		Fix some problems with handling of FWA$B_DIRLN
;
;	V02-007	PSK0002		Paulina Knibbe		18-Nov-1980
;		Clear the wild directory bit for trailing specified
;		directories when there is a bounded elipsis
;
;	V02-006	PSK0001		Paulina Knibbe		12-Nov-1980
;		Set the correct wild directory bit in the FWA if the directory
;		name was originally specified by an elipsis
;
;	V02-005	MCN0002		Maria del C. Nasr	03-Sep-1980
;		Fix branch to prevent infinite loop on parse of
;		[A.B.*]*.* when B does not exist.
;
;	V02-004	REFORMAT	Ron Schaefer	25-Jul-1980
;		Reformat the source
;
;	V003	TMH0003		Tim Halvorsen	05-FEB-1980
;		if sdi device, return with mfd without accessing device.
;
;	V002	TMH0002		Tim Halvorsen	04-JAN-1980
;		fix [*.obj] from failing to do check after copy_nonwild
;		which ensures that the directory up to that point exists.
;		fix [...a...] to return [...a] as well as the subtree
;		below it -- required a check following bounded match
;		to check if the elipsis exit should be taken immediately.
;		add $devdef to generate short literals on checks.
;
;	V001	TMH0001		Tim Halvorsen	12-NOV-1979
;		consolidate multiple asterisks from [*,*] into a single
;		asterisk so that ods-1 can use [*,*] (since character
;		wildcarding is not yet done for ods-1).
;		fix bug in nextdir so that a non-wild directory string
;		is checked immediately to make sure that it exists.
;		fix bug in next_child so that maperr is called with r8
;		pointing to the fab rather than the swb.
;--

	.SBTTL	DEFINITIONS

;
; symbol definitions
;

	$FABDEF				; fab definitions
	$NAMDEF				; nam definitions
	$IFBDEF				; ifab definitions
	$FWADEF				; fwa definitions
	$FIBDEF				; fib definitions
	$DEVDEF				; device characteristics
	$IMPDEF				; image i/o segment definitions
	$PIODEF				; process i/o definitions

;
; directory string work buffer
;

	.SAVE
	.PSECT	$ABS$,ABS

	.=0
SWB$B_FLAGS:
	.BLKB	1				; flags (must be first)
	SWB$V_ELLIPSIS		= 0		; true if at ellipsis
	SWB$M_ELLIPSIS		= 1
	SWB$V_BOUNDED		= 1		; true if ellipsis bounded
	SWB$M_BOUNDED		= 2
	SWB$V_WILD		= 2		; true if wild name
	SWB$M_WILD		= 4
	SWB$V_DELIMITER		= 3		; true if following delimiter 
	SWB$M_DELIMITER		= 8
	SWB$V_TRAVERSE		= 4		; true if should skip subtree
	SWB$M_TRAVERSE		= 16
	SWB$V_FIRST		= 5		; true if first time through
	SWB$M_FIRST		= 32
	SWB$V_ELLIPSIS_EXISTS	= 6		; true if dir spec contains ...
	SWB$M_ELLIPSIS_EXISTS	= 64
	SWB$V_VALID_DID		= 7		; true if FIB DID is valid
	SWB$M_VALID_DID		= 128
SWB$B_PATLEN:
	.BLKB	1				; length of current token
SWB$B_PPOS:
	.BLKB	1				; position in pattern
SWB$B_TOKENS_LEFT:
	.BLKB	1				; number of non ... tokens left
SWB$Q_PATTERN:
	.BLKL	2				; descriptor of pattern
SWB$B_MINIMUM:
	.BLKB	1				; minimum level for success
SWB$B_MAXIMUM:
	.BLKB	1				; maximum level for success
SWB$B_FIRST_E:
	.BLKB	1				; token # of first ellipsis
SWB$B_DIRWCFLGS:
	.BLKB	1				; FWA$B_DIRWCFLGS on entry
SWB$T_PATTERN:
	.BLKB	FWA$C_MAXDIRLEN-2		; wild directory specification
SWB$C_LENGTH:

;
; define position in fwa where swb resides.  
;

	FWA$T_SWB	= FWA$T_XLTBUFF1+FWA$C_NAMBUFSIZ+-
			  FWA$C_TYPBUFSIZ+FWA$C_VERBUFSIZ
	.RESTORE

	.SBTTL	RM$NEXTDIR, GET NEXT DIRECTORY TO SEARCH

;
;++
; RM$NEXTDIR: Get next directory to search
;
;	get the next directory which matches the wildcard
;	pattern in the directory specification.
;
; inputs:
;
;	r9  = ifab address
;	r10 = fwa address
;	r11 = impure area address
;
; outputs:
;
;	r0 = nmf if no more files to search, else status
;
;	the fib is updated with the did of the next
;	directory to be used in file searches.
;--
;

RM$NEXTDIR::
	MOVAB	FWA$T_SWB(R10),R8	; get swb address

;
; the very first time this routine is called, all leading nonwild tokens are
; copied into FWA descriptors, their existance is verified, and a starting
; DID is setup in the FIB for the remainder of the token string. at this
; point, the minimum directory traversal string can be set, and a check is
; made as to whether the current directory specification is sufficient to
; match the entered pattern. note that if the base ends up as the MFD, the
; initial match attempt can be skipped (there is nothing to match) and
; the first UFD can be retrieved. if all tokens are nonwild, then there is
; nothing more to do and a status of success can be returned.
;

	BBCC	#SWB$V_FIRST,(R8),20$	; do only if first time through
	BSBW	SET_BASE		; copy all leading nonwild tokens,
	BLBS	R0,10$			; find the base DID, and return
	RSB				; if thereare any problems

10$:	MOVB	FWA$B_DIRLEN(R10),-	; set the minimum success level
		SWB$B_MINIMUM(R8)	; for traversal
	TSTB	SWB$B_PATLEN(R8)	; if all tokens in the entered pattern
	BNEQ	12$			; were nonwild then immediately return 
	BRW	110$			; success and the DID

12$:	TSTB	FWA$B_DIRLEN(R10)	; if there were leading nonwild tokens
	BEQL	15$			; with other tokens following them
	BRW	70$			; then check for pattern-string match
15$:	MOVL	(R8),FWA$T_WILD(R10)	; else move pattern of first dir name 
	BRB	40$			; to search for into field & go search


;
; traverse down one level by getting the first subdirectory of the current
; directory and appending it. under the following conditions, downward 
; traversal is aborted in favor of traversing across: the SWB traversal flag
; is set; the current directory's level is the maximum traversal level; the
; current directory has no subdirectories; the current directory represents
; the MFD (i.e. the sole directory is the current directory 000000.dir;1).
; if the token string has been exhausted, or if the current directory has no 
; subdirectories and is at the minimum traversal level, then there are no 
; directories to be located.
;

20$:	TSTB	SWB$B_PATLEN(R8)	; if token string has been exhausted
	BNEQ	25$			; then signal no more files,
	BRW	90$			; otherwise continue
25$:	BBSC	#SWB$V_TRAVERSE,(R8),45$; if we are to traverse, then traverse
	CMPB	SWB$B_MAXIMUM(R8),-	; if we have reached the maximum
		FWA$B_DIRLEN(R10)	; traversal level then branch so as to
	BEQL	45$			; begin traversing across
	SSB	#SWB$V_ELLIPSIS,-	; only traverse down other than first
		FWA$T_WILD(R10)		; time through if have seen an ellipsis

30$:	CMPL	#^X00040004,-		; if the base directory (i.e. the
		FWA$T_FIBBUF+-		; directory whose file ID is in the DID
		FIB$W_DID(R10)		; of the FIB) is not the MFD, then 
	BNEQ	40$			; continue the downward traversal
	MOVQ	FWA$Q_DIR1(R10),R4	; get first directory's descriptor
	CMPL	#6,R4			; if the file does not have exactly six
	BNEQ	40$			; chars then it can't be 000000.dir;1
	CMPL	#^A'0000',(R5)		; if the directory isn't 000000.dir;1
	BNEQ	40$			; then continue the downward traversal
	DECB	SWB$B_MINIMUM(R8)	; otherwise decrement the minimum 
	BBS	#SWB$V_ELLIPSIS_EXISTS,-; traversal level, and the maximum 
		(R8),55$		; traversal level if there are any 
	DECB	SWB$B_MAXIMUM(R8)	; ellipsis in the entered pattern and
	BRB	55$			; begin crosswise traversal

40$:	CLRL	FWA$T_FIBBUF+-		; clear the wildcard context within the
		FIB$L_WCC(R10)		; FIB to get the first subdirectory
	BSBW	NEXT_SUBDIR		; get first subdirectory of current dir
	BLBC	R0,67$			; branch if error occurred otherwise 
	BLBS	R1,70$			; see if dir spec now matches pattern


;
; traverse across the directory tree. if we are now at the minimum traversal 
; level, then there are no more directories to find, otherwise, we back up to
; the level of a wild directory by stripping off the lowest level directory,
; calling match to retrieve the characteristics of the directory name to be
; searched for, and repeating this process as long as the pattern returned
; is nonwild. once the level of a wild directory has been reached, the next
; directory at the same level matching the returned pattern is found by using
; the stripped off directory name to resynchronize the ACP. note that if any
; time match returns a status of total success, this can only be do to the
; presence of an ellipsis, and any directory will satisfy the pattern.
;

45$:	CSB	#SWB$V_VALID_DID,(R8)	; DID is no longer valid
50$:	CMPB	FWA$B_DIRLEN(R10),-	; if at minimum traversal level and
		SWB$B_MINIMUM(R8)	; no subdirectory was found then exit
	BGTR	55$			; else continue with the crosswise
	BRW	90$			; traversal across the directory tree

55$:	BSBW	PREV_DIR		; strip off the lowest level directory
	PUSHR	#^M<R4,R5>		; and save its descriptor
	PUSHL	(R8)			; save current token context
	MOVZBL	SWB$B_MINIMUM(R8),R6	; set descriptor index of 1st wild dir
	BSBW	MATCH			; retrieve pattern of dir to search for
	POPL	(R8)			; restore current token context and
	POPR	#^M<R4,R5>		; descriptor of stripped of directory
	BLBS	R1,60$			; if total success returned then branch
	BBC	#SWB$V_WILD,-		; if the pattern returned was of a 
		FWA$T_WILD(R10),55$	; nonwild token then repreat process
	BRB	65$			; otherwise continue across traversal
60$:	SSB	#SWB$V_ELLIPSIS,-	; when total success is returned, set 
		FWA$T_WILD(R10)		; it up so anything will match pattern

65$:	ADDL3	#6,R4,IFB$L_RNS_LEN(R9)	; the stripped directory's length (plus
	MOVC3	R4,(R5),-		; 6 for .dir;1) & its name are together
		FWA$T_NAMEBUF(R10)	; used to resynchronize the ACP
	MOVQ	#^A'.DIR;1  ',(R3)	; append .dir;1 to the directory name
	MOVL	#1,FWA$T_FIBBUF+-	; indicate that the ACP is to 
		FIB$L_WCC(R10)		; resynchronize by setting a bit
	BSBW	NEXT_SUBDIR		; get next directory at the same level
67$:	BLBC	R0,80$			; error   - go handle it
	BLBS	R1,70$			; success - check for pattern match
	BRB	45$			; failure - continue 1 level up


;
; determine the match status of the current directory specification against
; the pattern. there are three possible outcomes. the match could be totally
; successful, in which case the next directory meeting the stated requirements
; has been found. the match could be partially successful indicating that
; while the current specification matches the leading part of the pattern
; it is insufficient for a total match, and downward traversing should 
; continue. finally, the match could be a total failure. this can only occur
; if we are traversing within a bounded ellipsis, and can never hope to
; match the trailing tokens from the current level. we continue by traversing
; across.
;

70$:	BBS	#FWA$V_GRPMBR,(R10),100$; if UIC then total success
	PUSHL	(R8)			; save the current token information 
	MOVZBL	SWB$B_MINIMUM(R8),R6	; set descriptor index of 1st wild dir
	MOVB	SWB$B_DIRWCFLGS(R8),-	; reinitialize the directory wildcard
		FWA$B_DIRWCFLGS(R10)	; context to its value before 1st srch
	BSBW	MATCH			; determine state of the match
	POPL	(R8)			; restore current token information
	BLBS	R1,100$			; total success   - find dir's DID
	MOVB	SWB$B_DIRWCFLGS(R8),-	; 		    restore wild card
		FWA$B_DIRWCFLGS(R10)	; 		    directory context
	BLBC	R0,55$			; failure         - traverse across
	CSB 	#SWB$V_VALID_DID,(R8)	; partial success - set DID invalid
	BRW	30$			; 		    and traverse down


;
; if an error occurred during the attempt to find the next directory, or the 
; DID of the next directory, traversal of the current subtree must be aborted
; to avoid looping on the same error. if the directory specification on entry
; was wild and the directory was not found, or was do to illegal directory
; format, this traversal takes place immediately. in all other circumstances
; the error is immediately reported.
;

80$:	SSB	#SWB$V_TRAVERSE,(R8)	; set the SWB traverse flag
	BBC	#FWA$V_WILD_DIR,-	; if the directory specification was 
		(R8),120$		; nonwild then report the error
	MOVL	IFB$L_LAST_FAB(R9),R1	; obtain the address of the FAB
	CMPW	FAB$L_STV(R1),-		; if the directory or DID could not
		#SS$_NOSUCHFILE		; be found then continue the 
	BEQL	85$			; crosswise traversal one level up
	CMPW	FAB$L_STV(R1),-		; if the error was not do to illegal
		#SS$_BADIRECTORY	; directory format then report the
	BNEQ	120$			; error immediately
85$:	CSB	#SWB$V_TRAVERSE,(R8)	; clear traversal bit,
	BRW	45$			; and go traverse

;
; if there are no more files to search, return indicating no more files.
;

90$:	RMSERR	NMF			; indicate that there are no more
	RSB				; directories to search and return

;
; if a directory specification has been found that matches the entered pattern,
; find the DID of the directory specification (unless it is still valid),
; and return success.
;

100$:	BBSC	#SWB$V_FIRST,(R8),110$	; first time through then DID is valid
	BSBW	FIND_DIR		; find the DID of the directory spec
	BLBC	R0,80$			; go handle any errors encountered
110$:	MOVL	#1,R0			; else indicate success and
120$:	RSB				; return

	.SBTTL	RM$SKIP_SUBTREE, SKIP REST OF SUBTREE

;
;++
; RM$SKIP_SUBTREE: skip rest of subtree
;
;	this routine causes the current node and all nodes
;	below it to be skipped in the directory traversal.
;	we continue with the next node on the same level as
;	the current node (if there is one). this routine is
;	usually called when an error (e.g. ACP error) has 
;	occurred in whichwe want to prune the offending 
;	portion of the tree.
;
; inputs:
;
;	r10 = fwa address
;
; outputs:
;
;	none
;--
;

RM$SKIP_SUBTREE::
	SSB	#SWB$V_TRAVERSE,-	; set to skip rest of subtree
		FWA$T_SWB+SWB$B_FLAGS(R10)
	MOVL	#1,R0			; always success
	RSB

	.SBTTL	RM$INIT_SWB, INITIALIZE SWB FOR WILDCARDING

;
;++
; RM$INIT_SWB: initialize swb for wildcarding
;
;	this routine takes the parsed directory specification,
;	and recreates the input file directory specification, minus
;	the delimiter brackets, in the SWB for later use. It also
;	initializes various fields within the SWB for use later on.
;
; inputs:
;
;	r9  = ifab address
;	r10 = fwa address
;
; outputs:
;
;	r8 = swb address  -  the swb is setup from the fwa parsed fields
;	r0 = 1   	  -  always return success
;--
;

RM$INIT_SWB::

;
; allocate swb buffer for expanded string
;

	ASSUME	FWA$C_NAMBUFSIZ+FWA$C_TYPBUFSIZ+FWA$C_VERBUFSIZ+SWB$C_LENGTH LE 192
	MOVAB	FWA$T_SWB(R10),R8	; take space from fwa page


;
; if the directory specification was not in UIC format, then recreate it in
; THE SWB keeping track of the number of nonelllipses tokens, the token number
; of the first ellipsis (if there is one), and setting various flags as 
; required.
;

	CLRL	(R8)			; clear flags 
	CLRL	SWB$B_MINIMUM(R8)	; and counters
	MOVB	FWA$B_DIRWCFLGS(R10),-  ; save the wild-card context
		SWB$B_DIRWCFLGS(R8)	; present on entry in the SWB
	MOVAB	SWB$T_PATTERN(R8),R3	; initialize pattern descriptor with
	MOVL	R3,SWB$Q_PATTERN+4(R8)	; address of pattern buffer
	MOVAB	FWA$Q_DIR1(R10),R6	; obtain address of first descriptor
	BBS	#FWA$V_GRPMBR,(R10),70$	; branch if UIC format
	MOVL	#FWA$C_MAXSUBDIR+1,R7	; maximum number of dirs in a spec

10$:	TSTW	(R6)			; end of directory names?
	BEQL	40$			; branch if so
	INCB	SWB$B_TOKENS_LEFT(R8)	; increment number of tokens counter
	MOVC3	(R6),@4(R6),(R3)	; copy current directory into buffer
	MOVB	#^A'.',(R3)+		; and append delimiter
	MOVZWL	2(R6),R5		; ellipsis following this directory?
					; save flag for trailing ellipsis test
	BEQL	30$			; and branch if not trailing ellipsis
	BBSS	#SWB$V_ELLIPSIS_EXISTS,-; if this is the very first ellipsis
		(R8),20$		; encountered, set the ellipsis exists
	ADDB3	SWB$B_TOKENS_LEFT(R8),-	; flag, and save the token number of 
		#1,SWB$B_FIRST_E(R8)	; ellipsis for future reference
20$:	MOVW	#^A'..',(R3)+		; make delimiter into ellipsis
30$:	CLRL	(R6)			; initialize this slot to null
	ADDL2	#8,R6			; skip to next descriptor
	SOBGTR	R7,10$			; loop until done

40$:	TSTW	R5			; is there a trailing ellipsis?
	BNEQ	50$			; branch if so
	DECL	R3			; otherwise, remove trailing delimiter

50$:	SUBB3	R7,#FWA$C_MAXSUBDIR+1,-	; compute the maximum success level
		SWB$B_MAXIMUM(R8)	; presuppossing there are no ellipses
	BBC	#SWB$V_ELLIPSIS_EXISTS,-; but if an ellipsis was encountered, 
		(R8),60$		; then the maximum level is reset to
	MOVB	#FWA$C_MAXSUBDIR+1,-	; allow for searches to the lowest
		SWB$B_MAXIMUM(R8)	; subdirectory level supported

60$:	SUBL3	SWB$Q_PATTERN+4(R8),R3,-; compute the length of the pattern 
		SWB$Q_PATTERN(R8)	; and put it in the pattern descriptor
	SSB	#SWB$V_FIRST,(R8)	; set first time through bit
	BSBW	PARSE_PATTERN		; parse the very first pattern
	CLRB	FWA$B_DIRLEN(R10)	; mark no directory names yet
90$:	MOVL	#1,R0			; always return success
	RSB


;
; if the directory specification is in UIC format, then expand both group
; and member strings to three characters each, and store them together as
; the only token, provided neither is wild. if either or both is wild, then
; the wild strings are copied directly into the buffer without expansion,
; and one token is created as before.
;

70$:	MOVL	#FWA$V_WILD_GRP,R7	; start of directory wildcard bits
	BSBB	UIC_EXPAND		; expand group portion
	INCL	R7			; skip to next wildcard bit
	BSBB	UIC_EXPAND		; expand member portion
	MOVW	#^X0202,-		; both the minimum and maximum success
		SWB$B_MINIMUM(R8)	; levels are 2 for UIC directories
	CMPW	-2(R3),#^A'**'		; last 2 characters = '*'?
	BNEQ	60$			; branch if not
	DECL	R3			; if so, 1 asterisk will do just fine
	BRB	60$			; setup pattern descriptor

;
; expand the nonwild group/member string out to three characters, and place
; it in the buffer. if the group/member is wild, copy it into the pattern
; buffer as is.
;

UIC_EXPAND:
	MOVL	(R6)+,R0		; get length of string
	BBS	R7,(R10),20$		; skip leading zeros if wild
	SUBL3	R0,#3,R1		; number of leading zeros to insert
	BRB	15$
10$:	MOVB	#^A'0',(R3)+		; store leading zero
15$:	SOBGEQ	R1,10$			; as many as needed
20$:	MOVC3	R0,@(R6)+,(R3)		; store rest of string
	RSB

	.SBTTL	NEXT_SUBDIR, FIND THE NEXT SUBDIRECTORY

;
;++
; NEXT_SUBDIR:	find the next subdirectory
;
;	find the next subdirectory of the current directory specification. 
;	the next subdirectory might be the first subdirectory within the 
;	current specification, if we are currently traversing down the 
;	directory tree, or it might be the next subdirectory after the last 
;	subdirectory located within this directory specification, if we are 
;	traversing across the directory tree. if a subdirectory is found,
;	it is appended to the current directory specification.
;
; inputs:
;
;	r8  = SWB address
;	r9  = IFAB address
;	r10 = FWA address
;
; outputs:
;
;	r0 = status
;	r1 = false if no subdirectories left
;	     true if subdirectory located
;--
;

NEXT_SUBDIR:

;
; construct the file name to search for within the current directory 
; specification. the FWA field FWA$T_WILD contains information about
; the subdirectory we are to search for. *.dir;1 is always searched for
; whenever we are "within" an ellipsis. or an ellipsis has been encountered
; in the building of the current specification; otherwise pattern information
; is present within within the FWA field.
;

	MOVAB	FWA$T_XLTBUFF1(R10),R3	; obtain the address of the buffer
	MOVL	R3,FWA$Q_RNS+4(R10)	; and move it into the descriptor
	BBC	#SWB$V_ELLIPSIS,-	; if the pattern in the buffer is
		FWA$T_WILD(R10),5$	; that of an ellipsis, then we are
	MOVB	#^A'*',(R3)+		; to search for *.dir;1 so we move a *
	BRB	10$			; into the buffer and go append .dir;1

5$:	MOVZBL	FWA$T_WILD+1(R10),R0	; create a descriptor of the directory
	MOVZBL	FWA$T_WILD+2(R10),R1	; we are to search for in r0/r1 and
	MOVC3	R0,@SWB$Q_PATTERN+4-	; move the name of the directory
		(R8)[R1],(R3)		; into the buffer

10$:	MOVL	#^A'.DIR',(R3)+		; append the file type to the dir name
	MOVW	#^A';1',(R3)+		; append the version number to the name
	SUBL3	FWA$Q_RNS+4(R10),R3,-	; compute the length of the dir name to
		FWA$Q_RNS(R10)		; be searched for into its descriptor

	
;
; the DID of the current directory specification must be found and placed
; in the FIB in order to perform searches using the ACP. 
;

	BBSC	#SWB$V_FIRST,(R8),15$	; if this is the first time through
	BBS	#SWB$V_VALID_DID,-	; or the DID is still valid, then it
		(R8),15$		; is not necessary to find the DID
	BSBW	FIND_DIR		; if there is any problem finding the
	BLBS	R0,15$			; DID of the current specification 
	RSB				; return immediately, else continue


;
; required as input to the ACP (or the routine which is responsible for
; calling the ACP) is that a descriptor of the FIB exist in FWA$Q_FIB(R10),
; that name string wildcarding be turned on within the FIB, and that the
; descriptor of the result buffer be initialized with the size of the
; maximum possible file name string. RM$STALL also requires that general
; register R8 contains the address of the FAB.
;

15$:	MOVL	IFB$L_LAST_FAB(R9),R8	; obtain the address of the FAB
	MOVL	#FIB$C_DIRDATA,-	; load the length of the FIB
		FWA$Q_FIB(R10)		; into the FIB descriptor
	MOVAB	FWA$T_FIBBUF(R10),-	; load the address of the FIB
		FWA$Q_FIB+4(R10)	; into the FIB descriptor
	MOVZWL	#FWA$C_NAMBUFSIZ+-	; initialize the length field
		FWA$C_TYPBUFSIZ+-	; of the result descriptor
		FWA$C_VERBUFSIZ,-	; with the maximum size that
		FWA$Q_NAME(R10)		; a file name can be
	MOVW	#FIB$M_WILD,-		; set the bit within the FIB which
		FWA$T_FIBBUF+-		; indicates that a wildcard name 
		FIB$W_NMCTL(R10)	; search is to be performed


;
; the ACP will search for the next directory within the current directory
; specification, whose DID is already resident within the FIB, because the
; name string wildcard bit has been set and the input descriptor points to a
; buffer containing the string to be searched for. if the FIB field FIB$L_WCC 
; has been cleared, then to the ACP the next directory is the very first 
; subdirectory in the current directory specification which matches the pattern
; in the buffer. on the other hand, if this same field has been set to one, 
; then the next directory is the first subdirectory in the current directory 
; specification which matches the pattern in the buffer, and follows the
; subdirectory described by the descriptor FWA$Q_NAME(R10) (contains the
; address of the buffer containing the subdirectory's name), and the longword 
; IFB_L_RNS_LEN(R9) (contains the length of the subdirectory's name). the 
; following are the parameters required by the ACP to be present on the 
; current stack when it is called.
;
;	P1	#IO$_ACCESS		- ACP function code
;	P2	FWA$Q_RNS(R10)		- address of the input name descriptor
;	P3	IFB$L_RNS_LEN(R9)	- longword to recieve result name's
;					  length, and input as previous 
;					  position in directory
;	P4	FWA$Q_NAME(R10)		- address of result descriptor and
;					  input to ACP as previous position
;					  in directory
;	P5	0
;	P6	0
;

20$:	CLRQ	-(SP)			; place P5 & P6 on stack
	PUSHAB	FWA$Q_NAME(R10)		; push result descriptor address - P4
	PUSHAB	IFB$L_RNS_LEN(R9)	; push length field - P3
	PUSHAB	FWA$Q_RNS(R10)		; push input name descriptor - P2
	MOVZWL	#IO$_ACCESS,R0		; set ACP function code in R0
	JSB	RM$FCPFNC		; call the ACP and wait for reply

	BBC	#IMP$V_IORUNDOWN,-	; if I/O Rundown is in progress,
		@#PIO$GW_IIOIMPA,25$	; then RM0WILD is prematurely aborted
	RMSERR	NMF			; by setting a default error of no more
	BSBW	RM$MAPERR		; files both in R0 and in the FAB
	RSB				; and returning

25$:	MOVAB	FWA$T_SWB(R10),R8	; recover SWB address
	BLBS	R0,40$			; branch if no errors


;
; we divide ACP errors into two catagories - fatal and nonfatal. nonfatal 
; errors, such as no more subdirectories within the current directory 
; specification, are handled by this module. fatal errors maybe handled by this
; module depending upon their nature. both types of errors usaully result in 
; the traversal continuing, but in a crosswise manner one level up from the
; level of the current directory specification.
;

	CMPW	R0,#SS$_NOSUCHFILE	; if the ACP was unable to find a
	BEQL	30$			; subdirectory return no such file
	CMPW	R0,#SS$_NOMOREFILES	; if the ACP found no more files in the
	BEQL	30$			; sequence return no more files
	PUSHL	R8			; save the SWB address
	MOVL	IFB$L_LAST_FAB(R9),R8	; storing other errors requires a(FAB)
	RMSERR	FND,R1			; set default error
	BSBW	RM$MAPERR		; map to RMS error
	POPL	R8			; restore SWB address to R8
	RSB				; return fatal error

30$:	MOVL	#1,R0			; indicate no fatal error but that
	CLRL	R1			; no subdirectory was found either
	RSB				; and return

;
; the ACP found the next subdirectory - extract it for processing. if the
; directory name has a null length, go resynchronize the ACP and find the
; next directory. subtrees rooted at null length directory filenames are
; pruned.
;

40$:	MOVZWL	IFB$L_RNS_LEN(R9),R4	; get a descriptor of the result's file
	MOVAB	FWA$T_NAMEBUF(R10),R5	; name by chopping off the substring 
	SUBL2	#6,R4			; .dir;1 and resetting the length
	BEQL	55$			; if null length, go resynch ACP

;
; if the file found by the ACP was the MFD itself (i.e. the file 000000.dir;1)
; then skip it by recalling the ACP giving it this file as its current position
; within the MFD. this is so directory specifications such as [*...], [*], and
; [*,*] won't return the MFD.
;

	CMPL	#^X00040004,-		; if the current directory is not
		FWA$T_FIBBUF+-		; the MFD then don't bother checking
		FIB$W_DID(R10)		; to see whether the file just found
	BNEQ	45$			; by the ACP is 000000.dir;1
	CMPL	#6,R4			; if the file does not have exactly
	BNEQ	45$			; 6 numbers then it isn't 000000.dir;1
	CMPL	#^A'0000',(R5)		; if the file is 000000.dir;1 then go
	BEQL	55$			; and resynchronize the ACP


;
; if the directory was given in UIC format (but wild !!), then make sure
; only numeric directory names will be accepted as valid UIC format names.
;

45$:	BBC	#FWA$V_GRPMBR,(R10),60$	; branch if not in UIC format
	MOVQ	R4,R0			; duplicate result name descriptor

50$:	CMPB	(R1),#^A'0'		; if the name coallates lower then any
	BLSSU	55$			; valid UIC name - traverse across
	CMPB	(R1)+,#^A'7'		; if the result name coallates higher
	BGTRU	30$			; then any valid UIC name, then 
	SOBGTR	R0,50$			; go return no more files

	CMPL	R4,#6			; if the result name is 6 numbers long
	BEQL	60$			; then it is a valid UIC name

55$:	MOVL	#1,FWA$T_FIBBUF+-	; resynchronize the ACP to continue
		FIB$L_WCC(R10)		; the search, reload the address
	MOVL	IFB$L_LAST_FAB(R9),R8	; of the FAB into R8, and go
	BRW	20$			; look for the next subdirectory

;
; append the new subdirectory name to the current directory specification
; and return success - i.e. a subdirectory was found.
;

60$:	BSBW	APPEND_DIR		; append the subdirectory
	MOVL	#1,R0			; indicate that a subdirectory was 
	MOVL	#1,R1			; found by setting both r0 and r1
	RSB				; before returning

	.SBTTL	MATCH, COMPARE DIRECTORY SPECIFICATION WITH PATTERN STRING

;
;++
; MATCH: 	compare directory specification with pattern string
;
;	this routine is responsible for comparing the current directory
;	specification with the current pattern string. it makes this comparison
;	one token/pattern at a time, recursively calling itself with the
;	remainder of the pattern string and/or directory specification when it
;	finds the current token matches the current directory name. the 
;	algorithm employed will try all possible matching combinations when
;	ellipses are involved inorder to attempt to find a suitable
;	configuration. note that it is in the very nature of the directory
;	wildcarding algorithm, that this routine can fail only when we
;	have traversed down too deeply, because of an ellipsis, such that the
;	input pattern can never be matched. most often, a status of total
;	or partial success is returned, and in the latter case, information
;	about the next directory to look for is returned as well.
;
; inputs:
;
;	r6  = descriptor index of current directory name
;	r8  = swb
;	r10 = fwa
;
; outputs:
;
;	r0 = true if match was successful, false for fatal
;	r1 = degree of success - total or partial
;	     meaningless if r0 = false
;
;	FWA$B_DIRWCFLGS is set appropriately if the match was totally 
;	successful, trashed otherwise
;
;	FWA$T_WILD contains information about the next directory to search for
;	when a status of partial success is returned
;--
;

MATCH:
	MOVQ	FWA$Q_DIR1(R10)[R6],R2	; get current directory's descriptor

;
; if there are tokens remaining but no directories, this means that not 
; enough of the tree has been downward traversed to match the input pattern
; string. a status of partial success is returned so that the downward 
; traversal will continue as is required. there is one exception. if the
; current token is an unbounded ellipsis (and thus the last token), it
; matches the empty current directory, so a status of total success is 
; returned.
;

	TSTB	SWB$B_PATLEN(R8)	; if there are no more tokens left
	BEQL	70$			; then branch to handle that condition
	TSTL	R2			; if both tokens & directories are left
	BNEQ	10$			; branch to handle that condition too
	BBC	#SWB$V_ELLIPSIS,-	; if the current token is an unbounded
		(R8),110$		; ellipsis then return success, else
	BBS	#SWB$V_BOUNDED,(R8),110$; return partial success as the current
	BRW	120$			; directory specification is too short

;
; if there are both tokens and directories remaining, and the current token
; is an unbounded ellipsis (and thus the last token), we match the current
; directory with the ellipsis, move onto the next directory, and recurse.
; matching the directory with the ellipsis requires adjustment of the 
; directory wild card context.
;

10$:	BBC	#SWB$V_ELLIPSIS,-	; if the current token is not an 
		(R8),30$		; ellipsis branch, but if it is an
	BBS	#SWB$V_BOUNDED,(R8),20$	; unbounded ellipsis, then match the
	BSBW	SET_WCC			; current directory against the 
	BRB	100$			; ellipsis, and go continue


;
; if there are both tokens and directories remaining, and the current token
; is not a bounded ellipsis, then the action take depends upon the nature of 
; the token. if the token is a bounded ellipsis, the current directory name
; is matched against the ellipsis bounds. if the match succeeds, we recurse
; with the next token and directory. if the match fails, and it is impossible
; to ever match the entire input pattern from the current directory depth, we
; return failure, otherwise, we match the current directory with the ellipsis
; and recurse with the next directory name. finally, if the current token is 
; not an ellipsis, we match it directly with the current directory name. 
; success is handled as above. failure means that we must have prematurely
; matched an ellipsis bounds. our course of action is to back up to the last
; ellipsis, match the bounds directory to the ellipsis, and continue the 
; recursion.
;

20$:	PUSHR	#^M<R2,R3>		; save the current directory descriptor
	BSBW	NEXT_PATTERN		; roll forward to the next token
	POPR	#^M<R2,R3>		; restore the directory descriptor

30$:	MOVZBL	SWB$B_PATLEN(R8),R4	; create a descriptor for the current
	MOVZBL	SWB$B_PPOS(R8),R5	; token by moving its length into r4
	ADDL2	SWB$Q_PATTERN+4(R8),R5	; and computing its address in r5
	JSB	FMG$MATCH_NAME		; test for token-directory name match
	BLBC	R0,40$			; branch if no match
	BSBW	NEXT_PATTERN		; if they match, roll forward to next
	BRB	100$			; token, and go recurse once more

40$:	BSBW	PREV_PATTERN		; roll back to previous token and if it
	BBC	#SWB$V_ELLIPSIS,(R8),90$; isn't an ellipsis continue rollback
	BSBW	SET_WCC			; otherwise match directory to ellipsis
	TSTL	FWA$Q_DIR1+8(R10)[R6]	; if there are no more directories, go
	BEQL	50$			; test if pattern can ever be matched
	CMPB	R6,#FWA$C_MAXSUBDIR	; if we are at the maximum depth then
	BEQL	60$			; go return failure otherwise go 
	BRB	100$			; continue the recursion

50$:	SUBL3	SWB$B_TOKENS_LEFT(R8),-	; if we are at a directory depth such
		SWB$B_MAXIMUM(R8),R4	; that the input pattern can never be
	CMPB	R4,FWA$B_DIRLEN(R10)	; matched, go return failure, otherwise
	BGEQU	110$			; we go return partial success

60$:	CLRL	R0			; if we are to return failure we clear
	CLRL	R1			; both general registers r0 and r1
	RSB				; and return to recurse upwards


;
; if there are neither tokens nor directories left, then the directory
; specification does match the pattern, and so we go return total success.
; if there are no tokens left, but there are directories, this means we
; must have prematurely matched an ellipsis bounds. our course of action
; is to backup to the last ellipsis, match the bounds directory to the
; ellipsis, and continue the recursion.
;

70$:	TSTL	R2			; if there are not any tokens or 
	BEQL	120$			; directories then go return success
	BSBW	PREV_PATTERN		; otherwise backup one token

;
; when a rollback to the last encountered ellipsis is specified, the 
; directory matching the ellipsis's bounds is now matched against the ellipsis
; itself, the wild card directory context is appropriately altered, and we
; attempt to continue the matching process from this position.
; 

90$:	BSBW	PREV_PATTERN		; now rollback one token and one
	DECL	R6			; directory and if token is not an
	BBC	#SWB$V_ELLIPSIS,(R8),90$; ellipsis continue rollback, otherwise
	BSBW	SET_WCC			; match dir to ellipsis and continue

;
; we want to see if the remaining directory specification matches the
; remaining pattern tokens. Thus, we increment the directory descriptor index
; to the descriptor of the next directory, and we recurse by having match
; call match.
;

100$:	CMPB	R6,#FWA$C_MAXSUBDIR	; if we are the maximum directory level
	BEQL	120$			; then go return total success
	INCL	R6			; increment dir index to next position
	BSBW	MATCH			; see if remaining dir & tokens match
	RSB				; return final result


;
; if a status of partial success is to be returned, general register r0 is 
; set to one, general register r1 is cleared, the information about the next
; directory to search for is place in the temporary buffer FWA$T_WILD, and
; we return to initiate upwards recursion.
;

110$:	CLRL	R1			; partial success requires a zeroed r1
	MOVL	(R8),FWA$T_WILD(R10)	; put token characteristics into buffer
	BBC	#SWB$V_ELLIPSIS_EXISTS,-; if no ellipsis exists in the input
		(R8),130$		; pattern go return partial success
	BBS	#SWB$V_ELLIPSIS,-	; if the current token is an ellipsis
		(R8),130$		; go return partial success
	CMPB	FWA$B_DIRLEN(R10),-	; if there there are ellipses but they
		SWB$B_FIRST_E(R8)	; all follow the current token then
	BLSSU	130$			; go return partial success
	BISB2	#SWB$M_ELLIPSIS!-	; otherwise set the ellipsis and wild 
		SWB$M_WILD,-		; bits in the returned buffer so that
		FWA$T_WILD(R10)		; *.dir;1 will be searched for and
	BRB	130$			; go return partial success

;
; if a status of total success is to be returned, both general registers r0 
; and r1 are set to one before we return to initiate upwards recursion.
;

120$:	MOVL	#1,R1			; for total success, set both 
130$:	MOVL	#1,R0			; general registers r0 and r1 
	RSB				; before returning

	.SBTTL	SET_WCC, MAINTAIN DIRECTORY WILDCARD CONTEXT

;
;++
; SET_WCC: 	maintain directory wildcard context
;
;	this routine adjusts the directory wild card context so that it is
;	consistant with the current directory specification. it is only
;	called when a directory name is matched to an ellipsis becomming
;	wild, and requiring that the appropriate bit (corresponding to its
;	level-1) be set within this field.
;
; inputs:
;
;	r6  = number of bit to be set after shifting subfield
;	r10 = fwa
;
; outputs:
;
;	FWA$B_DIRWCFLGS with a context appropriate for the current 
;	directory specification
;--
;

SET_WCC:
	SUBL3	R6,#FWA$C_MAXSUBDIR+1,R0; get length of subfield to be shifted
	EXTZV	R6,R0,-			; extract the FWA$B_DIRWCFLGS subfield
		FWA$B_DIRWCFLGS(R10),R1	; to be shifted to the left, shift the
	ROTL	#1,R1,R1		; subfield one bit to the left,
	INSV	R1,R6,R0,-		; reinsert the shifted subfield, and
		FWA$B_DIRWCFLGS(R10)	; set the bit corresponding to the
	SSB	R6,FWA$B_DIRWCFLGS(R10)	; directory now matching the ellipsis
	RSB				; return

	
	.SBTTL	NEXT_PATTERN, SKIP TO NEXT PATTERN TOKEN

;
;++
; NEXT_PATTERN: skip to next pattern token
;
;	skip to the next token in the pattern string.  a
;	token is defined to be any directory name or an
;	ellipsis. after skipping to the next token, it
;	is parsed.
;
; inputs:
;
;	r8 = swb address
;
; outputs:
;
;--
;

NEXT_PATTERN:
	BBS	#SWB$V_ELLIPSIS,(R8),10$; if the current token is not an 
	DECB	SWB$B_TOKENS_LEFT(R8)	; ellipsis, decrement the token counter

10$:	ADDB2	SWB$B_PATLEN(R8),-	; position the pattern offset
		SWB$B_PPOS(R8)		; to the next delimiter
	CMPB	SWB$B_PPOS(R8),-	; if there are no more tokens (i.e. we
		SWB$Q_PATTERN(R8)	; have reached the end of the token
	BGEQU	20$			; string) or if the next token is an
	BBC	#SWB$V_DELIMITER,-	; ellipsis, then there is no
		(R8),20$ 		; need to bypass the delimiter token
	INCB	SWB$B_PPOS(R8)		; too, otherwise, there is such a need
20$:					; drop thru to parse_pattern

	.SBTTL	PARSE_PATTERN, PARSE CURRENT PATTERN TOKEN

;
;++
; PARSE_PATTERN: parse current pattern token
;
;	set the length and characteristics flags of the
;	current token in the pattern string.
;
; inputs:
;
;	r8 = swb address
;
; outputs:
;
;	swb$b_patlen = length of token, 0 if none
;	swb$b_flags  = flags describing token
;--
;

PARSE_PATTERN:
	BICB2	#SWB$M_ELLIPSIS!-	; clear status flags
		SWB$M_BOUNDED!-
		SWB$M_WILD!-
		SWB$M_DELIMITER,(R8)
	MOVQ	SWB$Q_PATTERN(R8),R2	; get string descriptor
	MOVZBL	SWB$B_PPOS(R8),R1	; current offset into string
	ADDL2	R1,R3			; address of string left
	SUBL2	R1,R2			; length of string left
	BEQL	50$			; branch if nothing left

;
; check if token is an ellipsis
;

20$:	CMPL	R2,#3			; 3 characters left?
	BLSSU	10$			; branch if not
	CMPW	(R3),#^A'..'		; ellipsis?
	BNEQ	10$			; branch if not
	BISB2	#SWB$M_ELLIPSIS!-	; mark ellipsis is current
		SWB$M_BOUNDED!-
		SWB$M_WILD,(R8)
	CMPL	R2,#3			; anything following ellipsis?
	BGTRU	5$			; branch if yes
	CSB	#SWB$V_BOUNDED,(R8)	; mark unbounded
5$:	MOVL	#3,R2			; set length of ellipsis
	BRB	50$


;
; find delimiter following token
;

10$:	LOCC	#^A'.',R2,(R3)		; find next dot in string
	BEQL	30$			; branch if not found
	SSB	#SWB$V_DELIMITER,(R8)	; assume 1 char. delimiter following
	CMPL	R0,#3			; if there are 3 characters left
	BLSS	30$
	CMPW	1(R1),#^A'..'		; then check for ellipsis following
	BNEQ	30$			; branch if not
	CSB	#SWB$V_DELIMITER,(R8)	; if so, set no delimiter after token

;
; if token has wild characters, set wild flag
;

30$:	SUBL2	R0,R2			; length of token passed by
	LOCC	#^A'*',R2,(R3)		; search token for wild *
	BNEQ	40$			; if found, set bit
	LOCC	#^A'%',R2,(R3)		; search token for wild %
	BEQL	50$			; if not found, set length
40$:	SSB	#SWB$V_WILD,(R8)	; mark token has wild characters

;
; set length of new token in string (r2 = length)
;

50$:	MOVB	R2,SWB$B_PATLEN(R8)	; set token length
	RSB				; return

	.SBTTL	PREV_DIR, STRIP ONE DIRECTORY NAME FROM DIRECTORY SPECIFICATION

;
;++
; PREV_DIR: strip one directory name from directory specification
;
;	strip the last directory name from the current
;	directory specification being built.
;
; inputs:
;
;	r10 = fwa address
;
; outputs:
;
;	r4/r5 = descriptor of stripped directory name
;	r0    = false if no names left to strip, else true
;--
;

PREV_DIR:
	BBC	#FWA$V_GRPMBR,(R10),10$	; branch if not uic format
	BSBB	10$			; strip member portion
	BLBC	R0,90$			; branch if nothing left
	MOVL	FWA$Q_DIR1(R10),R0	; obtain length of group portion
	ADDL2	R4,FWA$Q_DIR1(R10)	; concatenate group and member i.e.
	MOVC3	R4,(R5),-		; append member onto end of group name
		@FWA$Q_DIR1+4(R10)[R0]	; and then strip the whole thing off

10$:	MOVZBL	FWA$B_DIRLEN(R10),R1	; get number of slots in use
	DECL	R1			; backup over last slot
	BLSS	90$			; branch if none left
	MOVB	R1,FWA$B_DIRLEN(R10)	; store updated slots in use
	MOVAQ	FWA$Q_DIR1(R10)[R1],R1	; address of stripped descriptor
	MOVQ	(R1),R4			; return descriptor to caller
	CLRL	(R1)			; zero length of FWA descriptor
	MOVL	#1,R0			; indicate success and
	RSB				; return
90$:	CLRL	R0			; return error - no names left
	RSB

	.SBTTL	PREV_PATTERN, BACKUP TO PREVIOUS PATTERN TOKEN

;
;++
; PREV_PATTERN: backup to previous pattern token
;
;	backup one token in the pattern string.
;
; inputs:
;
;	r8 = swb address
;
; outputs:
;
;	r0 = false if no tokens left to strip, else true
;--
;

PREV_PATTERN:
	MOVQ	SWB$Q_PATTERN(R8),R2	; get string descriptor
	MOVZBL	SWB$B_PPOS(R8),R1	; current offset into string
	BEQL	80$			; branch if already at start
	CMPL	R1,#3			; if the previous token is less than
	BLSS	5$			; two chars then it can't be an ...
	MOVAB	-3(R3)[R1],R2		; if the previous token does not have 
	CMPW	#^A'..',(R2)		; two consecutive dots it can't be an
	BNEQ	5$			; ellipsis, likewise if it doesn't have
	CMPB	#^A'.',-1(R3)[R1]	; three consecutive dots it can't be an
	BNEQ	5$			; ellipsis, but if previous token is an
	SUBL2	#3+1,R1			; ellipsis, backup 4 places, and go 
	BRB	50$			; update the position offset
5$:	DECL	R1			; if so, skip over it
10$:	DECL	R1			; skip to previous character
	BLSS	50$			; branch if at start of string
	CMPB	(R3)[R1],#^A'.'		; reached a dot?
	BNEQ	10$			; branch if not
	INCB	SWB$B_TOKENS_LEFT(R8)	; increment nonellipsis token counter
50$:	ADDB3	#1,R1,SWB$B_PPOS(R8)	; store updated offset
	BSBW	PARSE_PATTERN		; parse current pattern token
	MOVL	#1,R0			; indicate success and
	RSB				; return
80$:	CLRL	R0			; indicate failure and
	RSB				; return

	.SBTTL	APPEND_DIR, APPEND DIRECTORY TO END OF DIRECTORY SPECIFICATION

;++
; APPEND_DIR: append directory to end of directory specification
;
;	this routine appends a directory name to the end
;	of the current directory spec being assembled.
;
; inputs:
;
;	r4/r5 = descriptor of directory name.
;	r10   = fwa address
;	r8    = swb address
;
; outputs:
;
;	r1-r3 destroyed
;--

APPEND_DIR:
	BBC	#FWA$V_GRPMBR,(R10),10$	; branch if not uic format
	MOVL	#3,R4			; only 3 characters in each part
	BSBB	10$			; append group portion
	ADDL2	R4,R5			; skip to member portion of string
					; and append it by falling thru
10$:	MOVZBL	FWA$B_DIRLEN(R10),R0	; get number of names in use
	MOVAQ	FWA$Q_DIR1(R10)[R0],R1	; address of next slot descriptor
	MOVL	R4,(R1)			; set length in descriptor
	MOVL	4(R1),R0		; get address of buffer from descriptor
	PUSHR	#^M<R4,R5>		; save input descriptor
	MOVC3	R4,(R5),(R0)		; move string into buffer
	POPR	#^M<R4,R5>		; restore input descriptor
	INCB	FWA$B_DIRLEN(R10)	; increment names in use
	RSB				; return

	.SBTTL	SET_BASE, FIND BASE DIRECTORY AND DETERMINE ITS POSITION

;
;++
; SET_BASE:	find base directory and determine its position
;
;	the base directory will either be the MFD, if the very first pattern
;	token is wild, or the last nonwild name after finding either the first
;	wild token in the pattern string, or the end of the pattern string.
;	descriptors are created in the FWA, for each of the leading nonwild
;	names encountered up to and including the base directory. the DID of
;	the base directory is then set in the FIB. upon return, the current
;	token will be the first wild token encountered, or the end of the 
;	pattern string if all tokens encountered were nonwild.
;
; inputs:
;
;	r8  = swb address
;	r10 = fwa address
;
;
; outputs:
;
;	r0 = true if base directory DID has been found
;	     false otherwise
;--
;

SET_BASE:
10$:	BBS	#SWB$V_WILD,(R8),20$	; if token is wild, then find DID
	MOVZBL	SWB$B_PATLEN(R8),R4	; get length of current token
	MOVZBL	SWB$B_PPOS(R8),R5	; get offset to current token
	ADDL2	SWB$Q_PATTERN+4(R8),R5	; compute address of current token
	BSBB	APPEND_DIR		; append token to directory spec
	BSBW	NEXT_PATTERN		; skip to next pattern token
	TSTB	SWB$B_PATLEN(R8)	; continue as long as there are
	BNEQ	10$			; nonwild tokens to copy

20$:	BSBW	FIND_DIR		; find DID of base directory
	BLBC	R0,90$			; return immediately if any problems
	MOVL	#1,R0			; otherwise indicate success and
90$:	RSB				; return

	.SBTTL	FIND_DIR, DETERMINE CURRENT DIRECTORY POSITION

;
;++
; FIND_DIR: determine current directory position
;
;	determine the did of the current result directory
;	specification.
;
; inputs:
;
;	r8  = swb address
;	r9  = ifab address
;	r10 = fwa address
;
; outputs:
;
;	r0 = status
;	the did in the fib is set.
;
;	registers r4,r5,r8 are saved.
;--
;

FIND_DIR:
	TSTB	FWA$B_DIRLEN(R10)	; if the directory specification is
	BNEQ	10$			; not empty then setup to find the DID
	MOVL	FWA$T_MFD_FID(R10),-	; if the directory specification is
		FWA$T_FIBBUF+-		; empty then the DID defaults to the
		FIB$W_DID(R10)		; DID of the MFD which is saved in
	MOVW	FWA$T_MFD_FID+4(R10),-	; the FWA.
		FWA$T_FIBBUF+-		; this is setup in the appropriate 
		FIB$W_DID_RVN(R10)	; field of the FIB
	BRB	20$			; go return success

10$:	PUSHR	#^M<R4,R5,R8>		; save registers R4-R8 and the wildcard
	PUSHL	FWA$T_FIBBUF+-		; context over DID lookup by pushing
		FIB$L_WCC(R10) 		; them on the current stack
	MOVL	IFB$L_LAST_FAB(R9),R8	; obtain the address of the FAB
	MOVAB	FWA$T_WILD(R10),-	; a 16 byte scratch buffer is required
		FWA$Q_DIR+4(R10)	; for DID lookup
	BSBW	RM$SETDID_ALT		; set DID in the FIB
	POPL	FWA$T_FIBBUF+-		; restore registers R4-R8 and the
		FIB$L_WCC(R10)		; wildcard context, saved over DID 
	POPR	#^M<R4,R5,R8>		; lookup, from the current stack

	BBC	#IMP$V_IORUNDOWN,-	; if I/O Rundown is in progress,
		@#PIO$GW_IIOIMPA,15$	; then RM0WILD is prematurely aborted
	MOVL	IFB$L_LAST_FAB(R9),R8	; by obtaining the address of the FAB,
	RMSERR	NMF			; setting a default error of no more
	BSBW	RM$MAPERR		; files both in R0 and in the FAB,
	RSB				; and returning

15$:	BLBC	R0,90$			; branch if any error occured else
20$:	SSB	#SWB$V_VALID_DID,(R8)	; set the valid DID bit in the SWB
	MOVL	#1,R0			; otherwise indicate success
90$:	RSB				; and return

	.END
