	$BEGIN	RM3PCKUNP,0003,$$RMS3,<>,<PIC,NOWRT,QUAD>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
;
; Facility:	RMS32 index sequential file organization
;
; Abstract:
;	This module contains the routine that is called whenever a data
;	record that is in compressed form must be expanded.
;
; Environment:
;	VAX/VMS Operating System internal exec routines.
;
; Author:  Maria del C. Nasr		creation date:  10-Apr-1981
;
; Modified By:
;
;	V03-003	TMK0003		Todd M. Katz		20-Apr-1982
;		The routine RM$RECOMPR_KEY currently has an undocumented
;		assumption that the new key is only leading compressed never
;		trailing compressed when it is called. This is always true
;		at the primary data level where the key is not in the bucket
;		but in an internal record buffer. This is never true at the
;		index level (regardless if this routine is called to do record
;		sizing or the actual recompression) where the key may or may 
;		not be in the actual index bucket, and it is always fully 
;		compressed - both front and rear. As a result, recompression 
;		at the index level may terminate permaturely allowing for 
;		corruption of the file at the index level at some later point.
;		To fix this problem, remove the need for this assumption when
;		the index level is involved. We will continue to assume that
;		the new key can not be smaller then the old key when the
;		primary data level is involved.
;
;	V03-002	TMK0002		Todd M. Katz		15-Apr-1982
;		The routine RM$RECOMPR_KEY may be called either to
;		fully recompress a key including elimination of newly 
;		compressed characters and adjustment of the bucket's
;		freespace offset, or for just a size determination
;		(for example during computation of the amount of space
;		needed to hold two index record keys in a prologue 3
;		file with index compression during a multi-bucket split
;		index update). A size determination is signalled by R5 
;		(BKT_ADDR) being cleared. In such a circumstance we
;		never want to reference any field in the nonexistant
;		bucket. Change this routine so this is indeed the case.
;
;	V03-001	TMK0001		Todd M. Katz		24-Mar-1982
;		Change all references to IFB$B_KBUFSZ to IFB$W_KBUFSZ.
;
;	V02-013	TMK0001		Todd M. Katz		01-Mar-1982
;		Made several changes to the routines in this module:
;
;		1. Added support for rear-end truncation of keys in
;		   key compressed prolog 3 index buckets. This included
;		   changing the linkage of RM$COMPRESS_KEY so that R3
;		   serves an an output parameter (required for data level
;		   but not index key compression), changing RM$COMPRESS_KEY
;		   so that R2 is also saved on input (and restored on output),
;		   and changing RM$RECOMPR_KEY, so that index level keys
;		   (as well as data level keys) will be rear-end truncated as 
;		   well as front-end compressed when this recompression routine
;		   is called.
;
;		2. Fixed two $DELETE bugs which either prevented records in
;		   prolog 3 files from being deleted, or caused corruption of
;		   the file itself and problems in just closing it.
;
;		   a. The first problem occurred because many of the branches
;		      are not unsigned when they should be. Thus, in for
;		      example RM$EXPAND_KEYD, this would result in a failure
;		      to reexpand the duplicate of the key being deleted, and
;		      corruption of the file. To correct this, I changed all
;		      branches to be unsigned when necessairy.
;
;		   b. The second problem occurred during expansion of the key
;		      following a deleted record in RM$EXPAND_KEY. At the
;		      time this routine is called, the record to be deleted
;		      has already been removed, and its key is residing in
;		      keybuffer 5. To expand the key that followed it (if
;		      expansion is necessairy) we shift the contents of the
;		      bucket to make room for the number of characters the key
;		      is to be expanded by. Unfortunately, there was an error
;		      in the calaculation of the number of characters to shift
;		      the bucket contents although the actual beginning and end
;		      points of the shift were correct, and the expansion was 
;		      done correctly. The number of bytes to move included the
;		      number of characters to expand the trailing key by when
;		      it should not have. Thus, if the bucket was fairly full,
;		      and the number of characters to expand the trailing key
;		      by fairly large, garbage could be moved into the control
;		      information at the end of the bucket, and into whatever
;		      follows the bucket in the process's virtual memory space.
;		      When the number of characters to shift is correctly 
;		      computed, not only is the deletion performed correctly
;		      and the data bucket not corrupted, but several access
;		      violations during $CLOSE are no longer seen!
;
;		3. The last thing I did was to change some RAB references in
;		   RM$PACK_REC, to the corresponding field in the IRAB so as
;		   to prevent having to reprobe the RAB at that point.
;
;	V02-012	PSK0002		Paulina S. Knibbe	02-Oct-1981
;		Fix problem in RM$CONV_TO_ASC and RM$CONV_FROM_ASC
;		where the stack was being handled incorrectly.
;
;	V02-011	PSK0001		Paulina S. Knibbe	24-Sep-1981
;		Fix problem in compress_rec that occurs when a 
;		record has less than four characters after primary
;		key is extracted.
;
;	V02-010	MCN0007		Maria del C. Nasr	24-Jul-1981
;		Modify RM$UNPACK_REC to do key type conversion, and use
;		key buffer 5 as the work buffer, instead of 4.  Include
;		dummy type conversion routines.
;
;	V02-009	MCN0006		Maria del C. Nasr	04-Aug-1981
;		Modify RM$EXPAND_KEY to return the number of characters
;		expanded. Also, eliminate calculation of significant
;		characters in RM$SIG_CHARS.
;
;	V02-008	MCN0005		Maria del C. Nasr	16-Jul-1981
;		Modify RM$PACK_REC and RM$COMPRESS_KEY to use the routine
;		RM$FRNT_CMPR to determine the compression count of a key
;		to be inserted without having to rebuild the previous key.
;
;	V02-007	MCN0004		Maria del C. Nasr	14-Jul-1981
;		Fix problem with compression of sequences longer than
;		255 bytes.
;
;	V02-006	PSK0002		Paulina S. Knibbe	10-Jul-1981
;		Modify recompr_key so it doesn't update the record
;		size in index and sidr buckets.
;
;	V02-005	MCN0003		Maria del C. Nasr	07-Jul-1981
;		Fix RM$RECOMPR_KEY to deal with duplicate keys correctly.
;
;	V02-004	MCN0002		Maria del C. Nasr	01-Jul-1981
;		Modify RM$SIG_CHARS to calculate number of significant
;		characters in three different modes.
;
;	V02-003	MCN0001		Maria del C. Nasr	24-Jun-1981
;		Modify RM$EXPAND_KEY to take care correctly of duplicate
;		keys.  Add entry point RM$EXPAND_KEYD to expand key after
;		a record is deleted.
;
;	V02-002	PSK0001		Paulina S. Knibbe
;		Modify RM$RECOMPR to handle index buckets also
;
;--

	.SBTTL	DECLARATIONS

;
; Include files:
;

;
; Macros:
;

	$BKTDEF
	$RABDEF
	$IRBDEF
	$IFBDEF
	$IDXDEF

;
; Equated symbols:
;

;
; Own storage:
;




	.SBTTL	RM$UNPACK_REC - unpack compressed record

;++
;
; RM$UNPACK_REC:
;	This routine is called when a data record must be transformed from
;	compressed format to "normal" format.  The routine is divided in two
;	sections.  The first part moves the primary key segments to their
;	corresponding place in the output buffer.  The second section examines
;	the data fields and moves them to the output buffer, expanding them at
;	the same time.
;
; Calling sequence:
;	BSBW	RM$UNPACK_REC
;
; Input Parameters:
;	R0 : output buffer address
;	R1 : size of input record
;
; Implicit Inputs:
;	R6 : REC_ADDR - pointer to record in the data bucket to be unpacked
;			past record size word
;	R9 : IRAB address for key buffer address
;	R10: IFAB address for key buffer size
;
; Output Parameters:
;	R0 : Actual output record size
;
; Implicit Outputs:
;	None
;
; Routine Value:
;	Record size
;
; Side Effects:
;	The unpacked record is in the output buffer.
;	Registers R1,R2,R3 are clobbered
;
; Working registers:
;
;	R1	: will always be the index pointer to the input buffer
;	R3	: index pointer to the output buffer
;	8(SP)	: size of input record
;	4(SP)	: output buffer address
;	(SP)	: number of bytes transferred to output record
;
;    First section (move primary key):
;	R8 : index descriptor pointer
;	R9 : number of segments in key
;	R10: key length
;	R11: segment length
;
;    Second section (move data fields):
;	R2 : Parameter returned by RM$CHECK_SEGMENT
;	R8 : Truncation count for the field in the compressed record
;	R9 : Points to byte past the input record
;	R10: Length of field in compressed record
;	R11: Length of data field to be moved
;
;--

RM$UNPACK_REC::

;
; Move and expand key section - this is done by first moving the key into key
; buffer 5, performing all necessary reconstrucion, and expansion, and then,
; calling the type conversion routine to convert each segment to its ASCII
; equivalent, and move it to its place in the record.
;

	PUSHR	#^M<R4,R5,R7,R8,R9,R10,R11,AP>; save registers
	MOVQ	R0,-(SP)		; save size of input record and
					;  output buffer address
	PUSHL	#0			; no bytes transferred so far
	CLRL	-(SP)			; get key descriptor for primary key
	BSBW	RM$KEY_DESC
	ADDL2	#4,SP
	MOVZWL	IFB$W_KBUFSZ(R10),R0	; determine destination buffer
	MULL2	#4,R0			;  parameter for next call (kbuf5)
	ADDL2	IRB$L_KEYBUF(R9),R0
	MOVL	#1,AP			; indicate no record overhead/compr
	BSBW	RM$RECORD_KEY
10$:	MOVZBL	IDX$B_KEYSZ(R7),R10	; get key size
	SUBL3	R10,R0,R1		; find pointer to beginning of buffer
	MOVZBL	IDX$B_SEGMENTS(R7),R9	; determine number of segments
	MOVAW	IDX$W_POSITION(R7),R8	; setup pointer to pos/size/type array
20$:	MOVZWL	(R8)+,R3		; get segment position
	ADDL2	4(SP),R3		; add output buffer start address
	PUSHL	R3			; push destination address
	PUSHL	R1			; push input address
	MOVZBL	(R8)+,R11		; get segment length
	PUSHL	R11			; push segment length
	MOVZBL	(R8)+,-(SP)		; push segment type
	BSBW	RM$CONV_FROM_ASCII	; convert to ascii and move
	ADDL2	#16,SP
	ADDL2	R11,R1			; get next segment addr in input
	SOBGTR	R9,20$			; if more segments, continue
	ADDL2	R10,(SP)		; set num of bytes transferred so far

;
; Move data section
;
; Registers are initialized with the following values:
;	R1 - beginning of data section
;	R3 - beginning of output buffer
;	R9 - end of input record 
;
	MOVL	R6,R1			; beginning of input buffer to R1
	BBC	#IDX$V_KEY_COMPR,-
		 IDX$B_FLAGS(R7),30$	; check if key compressed
	MOVZBL	(R1)+,R10		; if yes, get length from record
	INCL	R1			; skip compression count
	ADDL2	R10,R1			; add to rec addr
	BRB	40$
30$:	ADDL2	R10,R1			; add fixed key size if not compressed
40$:	MOVL	4(SP),R3		; move output record addr to work reg
	ADDL3	8(SP),R6,R9		; add size to rec addr giving end of rec
	BBS	#IDX$V_REC_COMPR,-
		 IDX$B_FLAGS(R7),50$	; check if record compressed
	SUBL3	R1,R9,R10		; if not, compute size of data section
	BRB	60$
50$:	MOVZWL	(R1)+,R10		; store next field count
60$:	CLRL	R8			; truncation count should equal 0

;
; Loop thru record identifying data fields and moving them to output buffer
;

MOVFLD:	CMPL	R1,R9			; at end of record?
	BLSSU	10$			; continue if not
	BRW	END			; return, otherwise
10$:	TSTL	R10			; is next field count 0?
	BNEQ	15$			; continue if not
	TSTL	R8			; is truncation count 0?
	BNEQ	15$			; continue if not
	BRW	END			; input record is empty now

;
; Set up parameters for RM$CHECK_SEGMENT call
;	R0 - start address of output buffer
;	R4 - current byte in the output buffer
;

15$:	MOVL	4(SP),R0
	MOVL	R3,R4
	BSBW	RM$CHECK_SEGMENT	; find out if data belongs to a key seg
	BLBC	R0,20$			; branch, if it is a data field
	ADDL2	R2,R3			; otherwise, skip key segment
	BRB	MOVFLD			; try next field

;
; The data we are pointing at with R3 is a non-key field.  Move it to the
; output buffer.
;

20$:	SUBL3	R3,R2,R11		; find length of segment to move
CONT:	CMPL	R11,R10			; compare data len with next fld count
	BGEQU	30$			; br, if not enough data in input field
	MOVC3	R11,(R1),(R3)		; move data length
	SUBL2	R11,R10			; find characters left in next field
	ADDL2	R11,(SP)		; increment number of bytes transferred
	CLRL	R11			; all of data moved
	BRB	MOVFLD			; find next segment
30$:	TSTL	R10			; only move nxt field if not equal to 0
	BEQL	40$
	MOVC3	R10,(R1),(R3)		; move next field amount of data
	SUBL2	R10,R11			; find how many left in data length
	ADDL2	R10,(SP)		; increment number of bytes transferred
	CLRL	R10			; set next field count to zero
	BBC	#IDX$V_REC_COMPR,-
		 IDX$B_FLAGS(R7),40$	; check if record compressed
	MOVZBL	(R1),R8			; store truncation count, if true
40$:	CMPL	R11,R8			; compare data length with trun count
	BGEQU	50$			; branch if using trun count (smaller)
	MOVC5	#0,(R1),-1(R1),R11,(R3)	; fill output buffer with trun char
	SUBL2	R11,R8			; truncation count is reduced
	ADDL2	R11,(SP)		; increment number of bytes tranferred
	CLRL	R11			; data length should equal zero
	BRB	MOVFLD			; try next field
50$:	MOVC5	#0,(R1),-1(R1),R8,(R3)	; fill output buffer with trun char
	SUBL2	R8,R11			; reduce data length
	ADDL2	R8,(SP)			; increment number of bytes transferred
	CLRL	R8			; set truncation count to zero
	INCL	R1			; get to next field addr
60$:	CMPL	R1,R9			; are we all done?
	BGEQU	END			; branch if yes
	MOVZWL	(R1)+,R10		; store next field count, and point
					;  to data area
	TSTL	R10			; is next field count zero?
	BNEQ	CONT			; branch if not, more to move
	TSTL	R8			; is truncation count zero?
	BNEQ	40$			; branch if not, more to move

END:	POPL	R0			; return size of output record
	ADDL2 	#8,SP			; pop output buffer addr and
					;  input record size
	POPR	#^M<R4,R5,R7,R8,R9,R10,R11,AP>; restore registers
	RSB


	.SBTTL	RM$PACK_REC - pack record to compressed form

;++
;
; RM$PACK_REC:
;	This routine is called when a data record must be transformed from
;	expanded form to compressed format.  The routine is divided in two
;	sections.  The first part moves the primary key to the beginning of
;	the output buffer, and compresses it if necessary.  The second section,
;	moves the data section doing compression when possible.
;
; Calling sequence:
;	BSBW	RM$PACK_REC
;
; Input Parameters:
;	None
;
; Implicit Inputs:
;	R5 : BKT_ADDR to determine if insert is at beginning of bucket
;	R6 : REC_ADDR - address where record is to be inserted in the bucket
;	R7 : IDX_DFN - index descriptor for the primary key
;	R8 : RAB address 
;	R9 : IRAB address for L_KEYBUF, L_RECBUF, L_LST_NCMP, L_RBF, W_RSZ
;	R10: IFAB address for W_KBUFSZ
;
; Output Parameters:
;	R0 : Actual output record size
;
; Implicit Outputs:
;	None
;
; Routine Value:
;	Record size
;
; Side Effects:
;	The packed record is in the output buffer.
;	Registers R1,R2,R3 are clobbered
;
; Working registers:
;	(SP) : stores REC_ADDR
;
;--

RM$PACK_REC::

	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11,AP>
	PUSHL	R6			; save REC_ADDR for the time being
	MOVL	IRB$L_RECBUF(R9),R0	; set up output buffer pointer
	BBC	#IDX$V_KEY_COMPR,-	; if key not compressed, branch
		 IDX$B_FLAGS(R7),10$
	ADDL2	#2,R0			; skip key compression overhead

;
; Prepare to extract the primary key from the user's buffer, and place it in
; the record buffer
;

10$:	MOVL	IRB$L_RBF(R9),R6	; change REC_ADDR to point to user's buf
	MOVL	#3,AP			; indicate no rec overhead and expanded
	BSBW	RM$RECORD_KEY		; move primary key out
	MOVL	R0,R3			; beginning of data section
	POPL	R6			; restore REC_ADDR to pos of insert
	BBC	#IDX$V_KEY_COMPR,-	; if key not compressed, branch
		 IDX$B_FLAGS(R7),20$

;
; Call routine to do compression on the primary key
;	R1 - address of key to be compressed, including overhead
;

	MOVL	IRB$L_RECBUF(R9),R1	; key to be compressed
	BSBW	RM$COMPRESS_KEY

;
; At this moment R3 is pointing to where data section should begin.
;

20$:	PUSHL	R3			; save start of data section
	MOVL	IRB$L_RBF(R9),R1	; set up pointer to input record
	MOVZWL	IRB$W_RSZ(R9),R2	; move size to a long word
	ADDL3	R2,R1,R11		; determine end of input record
	BBC	#IDX$V_REC_COMPR,-	; branch if record not compressed
		 IDX$B_FLAGS(R7),40$
	ADDL2	#2,R3			; skip next field count
40$:	CMPL	R1,R11			; are we finished?
	BGEQU	70$			; branch if yes
	MOVL	IRB$L_RBF(R9),R0	; input buffer address
	MOVL	R1,R4			; current byte in input buffer
	BSBW	RM$CHECK_SEGMENT	; find out if byte belongs to prim key
	BLBC	R0,50$			; branch, if does not
	ADDL2	R2,R1			; skip key segment
	BRB	40$			; try again

;
; Found a data segment, make sure it is not past the input buffer end
;

50$:	CMPL	R2,R11			; is data segment too long
	BLSSU	60$			; branch, if it is not
	MOVL	R11,R2			; otherwise, force the exact end of rec
60$:	SUBL3	R1,R2,R10		; find length of data segment to move
	MOVC3	R10,(R1),(R3)		; move it
	BRB	40$			; next one
70$:	POPL	R10			; save start of data section in R10
	BBC	#IDX$V_REC_COMPR,-	; branch, if record should not be compr
		 IDX$B_FLAGS(R7),80$

;
; Set input parameters to RM$COMPRESS_REC
;	R10 - start of data section
;	R11 - end of data section
;

	MOVL	R3,R11
	BSBW	RM$COMPRESS_REC		; compress data section

80$:	SUBL3	IRB$L_RECBUF(R9),R3,R0	; compute total record size
	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11,AP>
	RSB


	.SBTTL	RM$COMPRESS_KEY - does front end and rear end compression on key

;++
;
; RM$COMPRESS_KEY:
;	This routine is called to do compression on primary and index level 
;	keys. It calls RM$FRNT_CMPR to determine the number of characters that
;	can be front end compressed in the key, and then does rear end
;	truncation of repeating chars.
;
; Calling sequence:
;	BSBW	RM$COMPRESS_KEY
;
; Input Parameters:
;	R1 : key to compress, including overhead
;
; Implicit Inputs:
;	R7 : IDX_DFN - index descriptor for the primary key
;
; Output Parameters:
;	R3 points past compressed key.
;
; Implicit Outputs:
;	None
;
; Routine Value:
;	none
;
; Side Effects:
;	The compressed key in the buffer, with key length and compression
;	count updated.
;	Registers R1 is clobbered
;
; Working registers:
;
;	R2	: key size
;	R3	: where key really starts
;	R8	: address of key to compress
;
;--

RM$COMPRESS_KEY::

	PUSHR	#^M<R2,R4,R5,R8>		; save registers
	MOVB	IDX$B_KEYSZ(R7),(R1)	; initialize length to total key size
	CLRB	1(R1)			; init compr count to 0
	MOVZBL	(R1),R2			; store key size for the future
	MOVAB	2(R1),R3		; save start address of key
	MOVL	R1,R8			; parameter for next call
	MOVL	R3,R1			; assume first char will not match
	BSBW	RM$FRNT_CMPR		; determine compression count
	TSTL	R0			; R0 equals zero when no front end
	BEQL	10$			;  compression is to be done

;
; Set front end compression values
;

	MOVB	R0,1(R8)		; set compr count
	SUBB2	R0,(R8)			; decrement length by compr count
	SUBL2	R0,R2			; determine number of chars left
	ADDL3	R0,R3,R1		; point to last char missed

;
; Do rear end truncation
;

10$:	DECL	R2			; if one or no characters left, then
	BLEQ	30$			;  rear end trun cannot be done, branch
	ADDL3	R2,R1,R0		; find last byte in key
20$:	CMPB	(R0),-(R0)		; compare consecutive bytes
	BNEQ	30$			; if not equal, exit
	DECB	(R8)			; decrement key length
	SOBGTR	R2,20$			; if more chars left, branch

;
; At this moment
;	(R8) - contains compressed key length
;	R1 - points to first character of compressed key
;	R3 - to where key should be moved
;

30$:	MOVZBL	(R8),R0			; copy key length
	MOVC3	R0,(R1),(R3)		; shift chars up

	POPR	#^M<R2,R4,R5,R8>
	RSB
	


	.SBTTL	RM$COMPRESS_REC	- does random compression on data section
;++
;
; RM$COMPRESS_REC:
;	This routine is called to do compression on the data section of the
;	record.  It searches for consecutive sequences of 5 or more
;	repeating characters, and compresses them.  For each sequence that is
;	not compressed, it allocates a word to count the number of characters
;	in the data segment, and a byte to indicate the number of characters
;	compressed from the end.
;
; Calling sequence:
;	BSBW	RM$COMPRESS_REC
;
; Input Parameters:
;	R10 : Pointer to next field count
;	R11 : Pointer to truncation count (end of record)
;
; Implicit Inputs:
;	None
;
; Output Parameters:
;
; Implicit Outputs:
;	R3 points to one byte past end of record (byte after last
;	   truncation count)
;
; Routine Value:
;	none
;
; Side Effects:
;	The data section is compressed
;	Registers R1,R2,R3 are clobbered
;
; Working registers:
;	R3 : starting point of destination buffer
;	R4 : starting point of non-compressed field
;	R5 : starting point of possible compressed field
;	R8 : index register thru search
;	R9 : count of characters compressed
;
;--

RM$COMPRESS_REC::

	PUSHR	#^M<R4,R5,R8,R9,R10,R11>; save registers
	ADDL3	#2,R10,R8		; get pointer to start of data
	MOVL	R8,R3			; save destination buffer start addr
10$:	MOVL	R8,R4			; reset start point
20$:	CMPL	R11,R8			; are we all done?
	BGTRU	25$			; if no, branch
	BRW	60$			; else, exit
25$:	MOVL	R8,R5			; save start point of possible match
	CMPW	(R8)+,(R8)+		; compare consecutive words
	BNEQU	20$			; if no match, try next ones
	CMPB	-1(R8),-2(R8)		; compare characters in the word
	BNEQU	20$			; if no match, try next ones
	CMPL	R11,R8			; if we have positioned past end
	BLEQU	60$			; then we don't have enough to compress
	MOVL	#3,R9			; a match of 4 found
	CMPL	R4,R5			; should we go back?
	BEQLU	40$			; no, do not

;
; Move backwards to search for any characters that might have been missed
;
30$:	CMPB	(R5),-1(R5)		; compare bytes
	BNEQU	40$			; no match
	DECL	R5			; set new match point
	AOBLSS	#6,R9,30$		; indicate another match found, and if
					;  more left, try next

;
; Look for the first character that does not match
;

40$:	SUBL3	R8,R11,R2		; find characters left in record
	SKPC	-1(R8),R2,(R8)		; find first char that does not match
	SUBL2	R0,R2			; find how many matched
	MOVL	R1,R8			; set new starting addresses
	ACBW	#3,R2,R9,20$		; increment number matched, and if less
					;  than 5, no good

;
; Make sure count is not bigger than 255 bytes
;

	CMPL	R9,#255
	BLEQ	50$			; ok, if less
	SUBL2	#255,R9			; find how many extra
	SUBL2	R9,R8			; back out that many
	MOVL	#255,R9			; force 255 bytes

;
; A sequence long enough has been found
;

50$:	SUBL3	R4,R5,R1		; find length of non-compressed
	INCL	R1			;  section
	MOVW	R1,(R10)		; store next field count
	MOVC3	R1,(R4),(R3)		; move to destination buffer
	MOVB	R9,(R3)+		; store truncation count
	MOVL	R3,R10			; reset new next field addr
	ADDL2	#2,R3			; new next field area
	BRW	10$

;
; Move the last field if not compressed
;

60$:	CMPL	R4,R8			; was last field compressed?
	BEQLU	70$			; exit, if yes
	SUBL3	R4,R11,R1		; find length of section
	MOVW	R1,(R10)		; store next field count
	MOVC3	R1,(R4),(R3)		; move to destination buffer
	CLRB	(R3)			; truncation count is zero
	INCL	R3			; point to end of record
	BRB	80$
70$:	SUBL2	#2,R3			; point to end of record
80$:	POPR	#^M<R4,R5,R8,R9,R10,R11>; restore registers
	RSB				; return to caller


	.SBTTL	RM$RECOMPR_KEY - recompresses a compressed key

;++
;
; RM$RECOMPR_KEY:
;	This routine is called to do recompression on the primary key in
;	primary data buckets or the key in SIDR or index buckets.
;	When a new record is added, the record that follows it might need
;	modification in the primary key compression.  This procedure is
;	done by the this routine.
;
;	Inaddition, this routine may be called to assist in the sizing of a
;	key, for example, to assist in the sizing of the second key of a
;	multi-bucket split index update. In such a case, we never want to
;	actually remove any newly compressed characters or adjust the
;	bucket's freespace pointer (BKT_ADDR will be 0).
;
;	A basic assumption that has been made is that the new key can never be
;	smaller that the old key when a primary data level recompression is
;	involved. This restriction does not hold for the index level (or for
;	size determination which is at the index level), and the new key may 
;	indeed be smaller than the old key.
;
; Calling sequence:
;	BSBW	RM$RECOMPR_KEY
;
; Input Parameters:
;	R0 : new record address pointing to compression overhead
;	R1 : next record address pointing to compression overhead
;
; Implicit Inputs:
;	R5 : BKT_ADDR - BKT$W_FREESPACE
;	R7 : IDX_DFN - IDX$B_KEYSZ
;
; Output Parameters:
;	None
;
; Implicit Outputs:
;	Record size is updated.
;	If this is not a size determination, then the newly
;	compressed characters of the next record will be removed
;	and the bucket freespace will updated.
;
; Routine Value:
;	none
;
; Side Effects:
;
;--

RM$RECOMPR_KEY::

	PUSHR	#^M<R2,R3,R4,R5,R8,R9>	; save registers

;
; First check for any inconsistencies
;

	MOVL	R1,R2			; set pointer to key length
	TSTB	(R1)+			; if the length of the next key is 0,
	BEQL	EXIT			;  then we are doing an update
	MOVL	R1,R3			; set pointer to compression count
	TSTB	(R0)+			; if length of new rec is 0, then it is
	BEQL	EXIT			;  one of dup chain, do nothing
	CMPB	(R0)+,(R1)+		; compare compression counts
	BNEQU	EXIT			; if new < next, then something wrong
					; if new > next, then no compr possible


;
; Get pointer to truncated character in each key
;

	MOVZBL	(R2),R8			; R8 - points to trun char of next key
	ADDL2	R3,R8
	MOVZBL	-2(R0),R9		; R9 - points to trun char of new key
	ADDL2	R0,R9
	DECL	R9

;
; Start comparing chars to see if compression can be done
;

10$:	CMPB	(R0),(R1)		; compare chars
	BNEQ	30$			; if no match, branch
	INCB	(R3)			; increment compression count
	CMPL	R1,R8			; at truncated char?
	BEQL	20$			; branch if yes
	DECB	(R2)			; decrement key length
	INCL	R1			; get next char

20$:	CMPL	R0,R9			; at truncated char of new?
	BNEQU	25$			; No, go on
	TSTL	R5			; if this is just a size determination
	BEQL	10$			; then continue the comparison
	TSTB	BKT$B_LEVEL(R5)		; if an index bucket
	BNEQU	10$			; then also just continue comparsion
	CMPB	(R3),IDX$B_KEYSZ(R7)	; are all chars compressed?
	BLSSU	10$			; continue if not
	CLRB	(R2)			; set length to zero, we have a dup
	INCL	R1			; skip last char
	BRB	30$			; all done...
25$:	INCL	R0			; Not at end yet, continue comparing
					;  real characters
	BRB	10$

30$:	TSTL	R5			; if this is just a size determination
	BEQL	EXIT			; then we are done
	INCL	R3			; point to beginning of key
	CMPL	R1,R3			; if the same, no compression done
	BEQL	EXIT
	MOVZWL	BKT$W_FREESPACE(R5),R0	; compute start of free space
	ADDL2	R5,R0
	SUBL2	R1,R0			; find # of chars to move up
	SUBL3	R3,R1,R2		; find # of chars compressed
	SUBW2	R2,BKT$W_FREESPACE(R5)	; update free space count
	BISB3	BKT$B_LEVEL(R5),-
		BKT$B_INDEXNO(R5),R4	; if this is a primary data bucket
	BNEQU	35$
	SUBW2	R2,-4(R3)		; update record size
35$:	MOVC3	R0,(R1),(R3)		; shift chars up

EXIT:	POPR	#^M<R2,R3,R4,R5,R8,R9>	; restore registers
	RSB

	.SBTTL	RM$EXPAND_KEY - expand a compressed key

;++
;
; RM$EXPAND_KEY:
;	This routine is called to expand the key of the first record
;	in the new bucket when a split occurs.  It gets as input the
;	address of the key to base expansion on, and the address of the
;	new bucket with record to expand.
;
; RM$EXPAND_KEYD:
;	This routine is called to expand the key of the record which
;	follows a deleted record.  It gets as input the	address of the
;	key to base expansion on (deleted key), and the address of the
;	key to expand.
;
; Calling sequence:
;	BSBW	RM$EXPAND_KEY
;	BSBW	RM$EXPAND_KEYD
;
; Input Parameters:
;	RM$EXPAND_KEY
;	    R0 : address of key to base compression on
;	    R1 : address of new bucket which contains record with key to expand 
;
;	RM$EXPAND_KEYD
;	    R0 : address of key to base compression on with compression overhead
;	    R1 : address of key to expand with compression overhead
;
; Implicit Inputs:
;	R5 : bucket address of bucket which contains record deleted, and
;	     record with key to be expanded.
;	R7 : index descriptor
;
; Output Parameters:
;	None
;
; Implicit Outputs:
;	The given key is expanded.  Record size and bucket freespace are
;	updated.
;
; Routine Value:
;	Number of characters expanded
;
; Side Effects:
;
; Notes:
;
; RM$EXPAND_KEY
;	This routine determines the number of characters to be added in front
;	of a compressed key, and the characters to add.  It does this in the
;	following way:
;	    - If the compression count of the key to expand is zero, do
;	    nothing, since the key is already expanded.
;	    - If the length of the key is greater than zero, then use the
;	    compression count as the number of characters to expand.
;	    - If the length of the key is zero, then it is a duplicate, and
;	    do simple rear end truncation.
;	    - If the length of the key is one, we can run into the situation
;	    in which one of the characters that was front end compressed,
;	    can be rear end truncated again, because of the order in which
;	    compression is executed.  If that is the case, then the number of
;	    characters to expand will be less than the front end compression
;	    count.
;
; RM$EXPAND_KEYD
;	This routine determines the number of characters to be added in front
;	of a compressed key, and the characters to add.  It does this in the
;	following way:
;	    - It only expands the key if the compression count of the key
;	    to be deleted is less than the compression count of the key to
;	    be expanded.
;	    - The number of characters to be expanded is equal to the
;	    difference between the two compression counts.
;
;	Once the number of characters to expand by is determined, all the data
;	in the bucket from the key on is shifted down that number of bytes, and
;	the characters are added to the front of the key from the input key.
;	The key length and compression count are updated, and the
;	record size, and bucket free space counts are incremented.
;
;
; Working registers:
;	R6 - number of characters to expand
;	R8 - address of key to based compression on
;	R9 - points to compression overhead of key to expand
;
;--

RM$EXPAND_KEY::

	PUSHR	#^M<R2,R3,R4,R5,R6,R8,R9>; save registers
	MOVL	R0,R8			; save address for future reference
	MOVL	R1,R5			; set bucket address
	MOVAB	BKT$C_OVERHDSZ(R5),R6	; set R6 to first record in the bucket
	CLRL	R1			; indicate primary data level
	BSBW	RM$REC_OVHD		; find record overhead
	ADDL3	R0,R6,R9		; R9 points to compression overhead
	TSTB	1(R9)			; if compression count = 0, exit
	BNEQ	10$
	CLRL	R6			; no characters expanded
	BRW	EXIT_EXP
10$:	MOVZBL	1(R9),R6		; R6 is the number of bytes we might
					;  need to expand by
	CLRB	1(R9)			; compression count is zero
	CMPB	(R9),#1			; is key length one?
	BEQL	EQ_1			; branch if equal
	BGTRU	GT_1			; branch if greater

;
; The key length is equal to zero.  Therefore, we know we have a duplicate
; key.  Just eliminate the characters that can be rear end truncated, and
; move the rest.
;

	DECL	R6			; decrement the # of chars to move
	BLEQ	30$			; if key was only one byte long, leave
	ADDL3	R8,R6,R3		; point to last char in expanded key
20$:	CMPB	(R3),-(R3)		; compare consecutive bytes
	BNEQ	30$			; exit, when no match
	SOBGTR	R6,20$			; continue if any left
30$:	INCL	R6			; there is always one more
	BRB	GT_1

RM$EXPAND_KEYD::

	PUSHR	#^M<R2,R3,R4,R5,R6,R8,R9> ;save registers
	MOVQ	R0,R8			; save input for future reference
	CLRL	R6			; no chars expanded
	CMPB	1(R8),1(R9)		; compare compression counts
	BGEQU	EXIT_EXP		; continue only if deleted < next
	SUBB3	1(R8),1(R9),R6		; set R6 to number of bytes to expand
	MOVB	1(R8),1(R9)		; compr count is that of deleted rec
	TSTB	(R9)			; see if key len is zero
	BNEQ	10$

;
; The key length is equal to zero.  Therefore, we know we have a duplicate
; key.  The compression overhead and key should be equal to the what the
; key being deleted contains.
;

	MOVZBL	(R8),R6			; number of characters that will be
					;  written into key
	ADDL2	#2,R8			; skip compr ovhd, not needed
	BRB	GT_1

10$:	CMPB	R6,(R7)			; compare the number of chars to exp
					;  with the key size
	BLEQU	OK

;
; Key is too short.  Must expand rear end truncated characters to make life
; easier.
;

	MOVZBL	(R8),R0			; make R0 point to trun char
	ADDL2	R8,R0
	INCL	R0
	CLRL	R1			; R1 will contain number of chars needed
	SUBB3	(R8),IDX$B_KEYSZ(R7),R1
	SUBB2	1(R8),R1
	ADDB2	R1,(R8)			; update key length
	PUSHL	R5			; must save R5
	MOVC5	#0,(SP),(R0),R1,1(R0)	; extend the trun char
	POPL	R5			; restore R5

OK:	ADDL2	#2,R8			; skip compr ovhd, not needed
	CMPB	(R9),#1			; is key length one?
	BGTRU	GT_1			; branch if greater

;
; If the key length is one, then there is the possibility that some of the
; characters that were front end compressed are equal to the rear end truncated
; character, and therefore, they should not be added to the length of the key.
; To determine this, we position to the last character front end compressed in
; the expanded key, and start moving back, comparing each character with the
; last character of the compressed key, until a non-match is found or the first
; is reached.  For each match, the number of bytes to expand by is decremented.
;

EQ_1:	ADDL3	R8,R6,R2		; point past last char that was front
					;  end compressed
10$:	CMPB	-(R2),2(R9)		; compare characters
	BNEQ	GT_1			; if not equal, exit loop
	SOBGTR	R6,10$			; decrement number to expand, and continue

GT_1:	ADDB2	R6,(R9)			; increment length by number to expand
	ADDW2	R6,-2(R9)		; increment record size
	MOVAB	2(R9),R1		; point to first character in key
	MOVZWL	BKT$W_FREESPACE(R5),R3	; after extracting current freespace
	ADDW2	R6,BKT$W_FREESPACE(R5)	; offset, adjust it to its new value
	ADDL2	R5,R3			; find end of bucket address
	SUBL3	R1,R3,R0		; number of bytes to shift down
	ADDL3	R6,R1,R3		; to where they should be moved
	MOVC3	R0,(R1),(R3)		; shift them
	MOVC3	R6,(R8),2(R9)		; add the characters expanded

EXIT_EXP:
	MOVL	R6,R0			; return number of chars expanded
	POPR	#^M<R2,R3,R4,R5,R6,R8,R9>; restore registers
	RSB


	.SBTTL	RM$SIG_CHARS - find significant characters between two keys

;++
;
; RM$SIG_CHARS:
;	This routine determines the number of significant characters between
;	the last key of a bucket, and the first key of the next bucket.  It
;	does this in three different fashions depending on the input.
;
; Calling sequence:
;	BSBW	RM$SIG_CHARS
;
; Input Parameters:
;	R0 : address of key buffer which contains full key
;	R1 : bucket address with key to compare with.  This key has no front
;		end compression, it is rear end truncated with a pad character
;		for primary data level.
;	R2 : indicates which behavior to take
;		0 - compare two keys, calculate significant count, and store
;		    in front of key buffer
;		1 - take significant count from bucket, and store in key buffer
;		2 - compare two keys, calculate significant count, and store
;		    in IRB$B_KEYSZ
;
; Implicit Inputs:
;	R7 : Index descriptor for IDX$V_KEY_COMPR, IDX$B_KEYSZ
;	R9 : IRAB for IRB$B_KEYSZ
;
; Output Parameters:
;
; Implicit Outputs:
;	The key buffer specified on input contains the most significant
;	characters between the two keys.  The first byte of the buffer
;	indicates how many they are, if the key was shifted.  Otherwise, it
;	is stored in IRB$B_KEYSZ.
;
; Routine Value:
;	none
;
; Side Effects:
;
; Note:
;	Rear end truncation at the index level will not be implemented for
;	this version.  Therefore, the code that does all significant count
;	calculation has been commented out.  The routine will always return
;	the full key size as the number of significant chars.
;
;--

RM$SIG_CHARS::

	PUSHR	#^M<R3,R4,R5,R6,R8,R10> ; save registers
	MOVL	R0,R8			; save key buffer address for future
	MOVL	R2,R4			; save indicator
	MOVZBL	IDX$B_KEYSZ(R7),R10	; force the key size
;	BISB3	BKT$B_LEVEL(R1),-
;		 BKT$B_INDEXNO(R1),R0	; see if at primary data level
;	BNEQ	EX_SIG			; if not, process for index
;	BLBS	R4,FROM_BKT		; if R4=1, get count from bucket
;	MOVAB	BKT$C_OVERHDSZ(R1),R6	; set R6 to first record in bucket
;	CLRL	R1			; indicate primary data level
;	BSBW	RM$REC_OVHD		; find record overhead
;	ADDL2	R0,R6			; position at beginning of the key
;	BBC	#IDX$V_KEY_COMPR,-
;		 IDX$B_FLAGS(R7),10$	; is key compressed?
;	MOVZBL	(R6),R1			; get length from record
;	ADDL2	#2,R6			; skip overhead
;	BRB	20$
;10$:	MOVZBL	IDX$B_KEYSZ(R7),R1	; get length from index
;20$:	MOVZBL	IDX$B_KEYSZ(R7),R0	; get length of key in buffer
;	MOVL	R0,R10			; set num of significant chars
;	ADDL3	R0,R6,R2		; make R2 point to truncated char
;	DECL	R2
;	CMPC5	R0,(R8),(R2),R1,(R6)	; compare chars in keys
;	BEQL	STORE			; if keys are equal, exit
;	SUBL2	R0,R10			; compute num of sig chars, including
;	INCL	R10			;  char that did not match
;	BRB	STORE			; branch to store count
;
;FROM_BKT:
;	MOVZBL	IDX$B_DATBKTSZ(R7),R0
;	ASHL	#9,R0,R0
;	MOVAB	-2(R0)[R1],R0		; R0 points to sig cnt in bucket
;	MOVZBL	(R0),R10		; move count to R10
;	BNEQ	STORE			; if not equal to zero, continue
;	MOVZBL	IDX$B_KEYSZ(R7),R10	; otherwise, set to max size
;
STORE:	CMPL	R4,#2			; if R4=2, then key should not be
	BEQL	10$			;  shifted
	MOVAB	2(R8),R5		; find addr to move to
	MOVZBL	IDX$B_KEYSZ(R7),R0	; key size
	MOVC3	R0,(R8),(R5)		; shift all chars down two bytes, so
					;  no chars are lost (might be needed
					;  by update)
	MOVB	R10,(R8)		; store count in front of key
	CLRB	1(R8)			; set compression count to 0
	BRB	EX_SIG
10$:	MOVB	R10,IRB$B_KEYSZ(R9)	; store count in IRAB

EX_SIG:	POPR	#^M<R3,R4,R5,R6,R8,R10> ; restore registers
	RSB


	.SBTTL	RM$CONV_TO_ASCII - convert key to ASCII

;++
;
; RM$CONV_TO_ASCII:
;
; Calling sequence:
;	BSBW	RM$CONV_TO_ASCII
;
; Input Parameters:
;	12(SP) - destination address
;	 8(SP) - source address
;	 4(SP) - segment length
;	  (SP) - segment data type
;
; Implicit Inputs:
;
; Output Parameters:
;
; Implicit Outputs:
;
; Routine Value:
;	none
;
; Side Effects:
;
; Note:
;
;--

CONS = 24
RM$CONV_TO_ASCII::

	PUSHR	#^M<R1,R2,R3,R4,R5>

	MOVC3	4+CONS(SP),@8+CONS(SP),@12+CONS(SP)	; move segment to output

	POPR	#^M<R1,R2,R3,R4,R5>
	RSB


	.SBTTL	RM$CONV_FROM_ASCII - convert key from ASCII

;++
;
; RM$CONV_FROM_ASCII:
;
; Calling sequence:
;	BSBW	RM$CONV_FROM_ASCII
;
; Input Parameters:
;	12(SP) - destination address
;	 8(SP) - source address
;	 4(SP) - segment length
;	  (SP) - segment data type
;
; Implicit Inputs:
;
; Output Parameters:
;
; Implicit Outputs:
;
; Routine Value:
;	none
;
; Side Effects:
;
; Note:
;
;--


RM$CONV_FROM_ASCII::

	PUSHR	#^M<R1,R2,R3,R4,R5>

	MOVC3	4+CONS(SP),@8+CONS(SP),@12+CONS(SP)	; move segment to output

	POPR	#^M<R1,R2,R3,R4,R5>
	RSB
	
	.END
