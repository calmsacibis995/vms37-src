	SUBROUTINE LPA11K (LUN)
C
C	Version 'V03-000'
C
C****************************************************************************
C*									    *
C*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
C*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
C*  ALL RIGHTS RESERVED.						    *
C* 									    *
C*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
C*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
C*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
C*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
C*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
C*  TRANSFERRED.							    *
C* 									    *
C*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
C*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
C*  CORPORATION.							    *
C* 									    *
C*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
C*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
C* 									    *
C*									    *
C****************************************************************************
C
C
C
C	AUTHOR	BRIAN PORTER		CREATION DATE	20-AUG-1979
C

C++
C	Functional description:
C
C	This module displays entries made for the lpa11k.
C
C	Modified by:
C
C	v02-004	BP0004		Brian Porter,		23-NOV-1981
C		Minor edit.
C
C	v02-003	BP0003		Brian Porter,		06-NOV-1981
C		Added 'device attention' support.
C
C	v02-002	BP0002		Brian Porter,		23-JUL-1981
C		Added different uba handling.
C
C	v02-001	BP0001		Brian Porter,		29-JUN-1981
C		Removed call to UNUSED_BITS.  Added call to LOGGER and
C		DHEAD.
C**
C--

	INCLUDE 'SRC$:MSGHDR.FOR /NOLIST'

	INCLUDE 'SRC$:DEVERR.FOR /NOLIST'




	BYTE		LUN

	BYTE		MAINTENANCE(0:3)

	INTEGER*4	FIELD

	INTEGER*4	COMPRESSC

	INTEGER*4	CNTRL_MAINT

	INTEGER*4	CNTRL_STATUS

	INTEGER*4	RDA

	INTEGER*4	UBAREG(2)

	PARAMETER	TIMEOUT = 96

	EQUIVALENCE	(CNTRL_MAINT,EMB$L_DV_REGSAV(0))

	EQUIVALENCE	(CNTRL_STATUS,EMB$L_DV_REGSAV(1))

	EQUIVALENCE	(RDA,EMB$L_DV_REGSAV(2))

	EQUIVALENCE	(MAINTENANCE,EMB$L_DV_REGSAV(3))

	EQUIVALENCE	(UBAREG,EMB$L_DV_REGSAV(4))

	CHARACTER*7	V1CNTRL_MAINT(0:0)

	CHARACTER*20	V2CNTRL_MAINT(6:11)

	CHARACTER*11	V3CNTRL_MAINT(13:15)

	CHARACTER*21	V1CNTRL_STATUS(6:7)

	CHARACTER*31	FATAL_ERROR('340'O:'351'O)

	CHARACTER*33	START_ERROR('300'O:'327'O)

	CHARACTER*33	USER_ERROR('240'O:'261'O)

	CHARACTER*33	STATUS_RETURN(0:3)

	CHARACTER*4	REG_HERALD(0:3)




	DATA	V1CNTRL_MAINT(0)/'GO BIT*'/



	DATA	V2CNTRL_MAINT(6)/'IN INTERRUPT ENABLE*'/

	DATA	V2CNTRL_MAINT(7)/'IN READY*'/

	DATA	V2CNTRL_MAINT(8)/'STEP UP*'/

	DATA	V2CNTRL_MAINT(9)/'ROM 0*'/

	DATA	V2CNTRL_MAINT(10)/'ROM 1*'/

	DATA	V2CNTRL_MAINT(11)/'ENABLE ARBITRATION*'/



	DATA	V3CNTRL_MAINT(13)/'CRAM WRITE*'/

	DATA	V3CNTRL_MAINT(14)/'RESET*'/

	DATA	V3CNTRL_MAINT(15)/'RUN*'/



	DATA	V1CNTRL_STATUS(6)/'OUT INTERRUPT ENABLE*'/

	DATA	V1CNTRL_STATUS(7)/'OUT READY*'/



	DATA	FATAL_ERROR('340'O)/'SLAVE POWER LOW*'/

	DATA	FATAL_ERROR('341'O)/'MASTER FIFO R/W ERROR*'/

	DATA	FATAL_ERROR('342'O)/'I/O BUS SACK TIMEOUT*'/

	DATA	FATAL_ERROR('343'O)/'MASTER INITIAL CONDITION ERROR*'/

	DATA	FATAL_ERROR('344'O)/'MASTER/SLAVE VERSION ERROR*'/

	DATA	FATAL_ERROR('345'O)/'SLAVE COLD START TIMEOUT*'/

	DATA	FATAL_ERROR('346'O)/'FATAL SLAVE ERROR*'/

	DATA	FATAL_ERROR('347'O)/'FAST PATH DATA ERRORS*'/

	DATA	FATAL_ERROR('350'O)/'FIFO DATA ERROR*'/

	DATA	FATAL_ERROR('351'O)/'ILLEGAL FATAL ERROR CODE*'/



	DATA	START_ERROR('300'O)/'NO ROOM FOR REQUEST*'/

	DATA	START_ERROR('301'O)/'GO BIT SET WITH ''READY IN'' SET*'/

	DATA	START_ERROR('302'O)/'MULTI-USER REQ IN DEDICATED MODE*'/

	DATA	START_ERROR('303'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('304'O)/'DEDICATED REQ IN MULTI-USER MODE*'/

	DATA	START_ERROR('305'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('306'O)/'START REQUEST WITHOUT INITIALIZE*'/

	DATA	START_ERROR('307'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('310'O)/'MULTIPLE INITIALIZE COMMAND*'/

	DATA	START_ERROR('311'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('312'O)/'STOP COMMAND AND USER NOT ACTIVE*'/

	DATA	START_ERROR('313'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('314'O)/'ODD REQUEST DESCRIPTOR ARRAY ADDR*'/

	DATA	START_ERROR('315'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('316'O)/'INITIALIZE WITH IMPROPER VERSION*'/

	DATA	START_ERROR('317'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('320'O)/'DEVICE NOT PRESENT*'/

	DATA	START_ERROR('321'O)/'ILLEGAL ''START ERROR'' CODE*'/

	DATA	START_ERROR('322'O)/'ILLEGAL FUNCTION*'/

	DATA	START_ERROR('323'O)/'ILLEGAL FUNCTION*'/

	DATA	START_ERROR('324'O)/'REQUEST DESCRIPTOR ARRAY NXM*'/

	DATA	START_ERROR('325'O)/'BUFFER/USER STATUS WORD ODD ADDR*'/

	DATA	START_ERROR('326'O)/'DEVICE NOT PRESENT ON I/O BUS*'/

	DATA	START_ERROR('327'O)/'XFER COUNT LESS THAN 256 WORDS*'/



	DATA	USER_ERROR('240'O)/'NON-FATAL ERROR COUNT EXCEEDED*'/

	DATA	USER_ERROR('241'O)/'ERROR STATUS OVER-RUN*'/

	DATA	USER_ERROR('242'O)/'RANDOM CHANNEL LIST NXM*'/

	DATA	USER_ERROR('243'O)/'BUFFER OVER/UNDER -RUN*'/

	DATA	USER_ERROR('244'O)/'BUFFER NXM*'/

	DATA	USER_ERROR('245'O)/'USER STATUS WORD NXM*'/

	DATA	USER_ERROR('246'O)/'USER STATUS WORD INV BUFR INDEX*'/

	DATA	USER_ERROR('247'O)/'MASTER FIFO 7/8 FULL*'/

	DATA	USER_ERROR('250'O)/'REQ TERM BY USER STAT WORD*'/

	DATA	USER_ERROR('251'O)/'NO FIRMWARE FIFO BUFFER*'/

	DATA	USER_ERROR('252'O)/'SLAVE FIFO 7/8 FULL*'/

	DATA	USER_ERROR('253'O)/'RANDOM CHANNEL ADDRESS UNDER-RUN*'/

	DATA	USER_ERROR('254'O)/'DATA UNDER-RUN*'/

	DATA	USER_ERROR('255'O)/'CHANNEL/DEVICE NON-EXISTENT*'/

	DATA	USER_ERROR('256'O)/'ILLEGAL ''USER ERROR'' CODE*'/

	DATA	USER_ERROR('257'O)/'ILLEGAL ''USER ERROR'' CODE*'/

	DATA	USER_ERROR('260'O)/'MULT EXT TRIG DIGITAL OUTPUT REQ*'/

	DATA	USER_ERROR('261'O)/'ILLEGAL ''USER ERROR'' CODE*'/



	DATA	STATUS_RETURN(0)/'SUCCESSFUL INITIALIZED DATA XFER*'/

	DATA	STATUS_RETURN(1)/'BUFFER FULL*'/

	DATA	STATUS_RETURN(2)/'NON-FATAL BUFFER OVER-RUN*'/

	DATA	STATUS_RETURN(3)/'ILLEGAL ''STATUS RETURN'' CODE*'/




	DATA	REG_HERALD(0)	/'CS1*'/

	DATA	REG_HERALD(1)	/'CS2*'/

	DATA	REG_HERALD(2)	/'RDA*'/

	DATA	REG_HERALD(3)	/'MR*'/




	CALL FRCTOF (LUN)

	call dhead1 (lun,'UBA LPA11K')

	CALL LINCHK (LUN,2)

	WRITE(LUN,10) CNTRL_MAINT
10	FORMAT('0',T8,'LA CS1',T24,Z8.4)

	CALL OUTPUT (LUN,CNTRL_MAINT,V1CNTRL_MAINT,0,0,0,'0')

	DO 20,I = 2,3

	FIELD = LIB$EXTZV(I,1,CNTRL_MAINT)

	IF (FIELD .NE. 0) THEN

	CALL LINCHK (LUN,1)

	WRITE(LUN,15) I + 14
15	FORMAT(' ',T40,'EXTENDED BUS ADDRESS BIT ',I2,'.')
	ENDIF

20	CONTINUE

	CALL OUTPUT (LUN,CNTRL_MAINT,V2CNTRL_MAINT,6,6,11,'0')

	CALL OUTPUT (LUN,CNTRL_MAINT,V3CNTRL_MAINT,13,13,15,'0')

	CALL LINCHK (LUN,1)

	WRITE(LUN,25) CNTRL_STATUS
25	FORMAT(' ',T8,'LA CS2',T24,Z8.4)

	FIELD = LIB$EXTZV(8,8,CNTRL_STATUS)

	IF (FIELD .LT. '300'O) THEN

	FIELD = LIB$EXTZV(0,3,CNTRL_STATUS)

	CALL LINCHK (LUN,1)

	WRITE(LUN,30) FIELD
30	FORMAT(' ',T40,'USER INDEX = ',I1,'.')
	ENDIF

	CALL OUTPUT (LUN,CNTRL_STATUS,V1CNTRL_STATUS,6,6,7,'0')

	FIELD = LIB$EXTZV(8,8,CNTRL_STATUS)

	IF (FIELD .NE. 0) THEN

	CALL LINCHK (LUN,1)

	IF (FIELD .GE. '340'O) THEN

	WRITE(LUN,40) FATAL_ERROR(MIN('351'O,FIELD))
40	FORMAT(' ',T40,A<COMPRESSC (FATAL_ERROR(MIN('351'O,FIELD)))>)

	ELSE IF (FIELD .GE. '300'O) THEN

	WRITE(LUN,50) START_ERROR(MIN('330'O,FIELD))
50	FORMAT(' ',T40,A<COMPRESSC (START_ERROR(MAX('330'O,FIELD)))>)

	ELSE IF (FIELD .GE. '240'O) THEN

	WRITE(LUN,60) USER_ERROR(MIN('261'O,FIELD))
60	FORMAT(' ',T40,A<COMPRESSC (USER_ERROR(MIN('261'O,FIELD)))>)

	ELSE IF (FIELD .LE. '100'O) THEN

	WRITE(LUN,70) STATUS_RETURN(MIN('3'O,FIELD))
70	FORMAT(' ',T40,A<COMPRESSC (STATUS_RETURN(MIN('3'O,FIELD)))>)
	ENDIF
	ENDIF

	CALL LINCHK (LUN,1)

	WRITE(LUN,90) RDA
90	FORMAT(' ',T8,'LA RDA',T24,Z8.4)

	CALL LINCHK (LUN,1)

	WRITE(LUN,100) (MAINTENANCE(I+J),J = 3,0,-1)
100	FORMAT(' ',T8,'LA MR',T24,4Z2.2)

	IF (FIELD .EQ. '343'O) THEN

	CALL LINCHK (LUN,2)

	WRITE(LUN,110) MAINTENANCE(1)
110	FORMAT(' ',T40,'EXPECTED STATUS = 052 (OCTAL)',/,
	1 T40,'ACTUAL STATUS   = ',O3,' (OCTAL)')

	ELSE IF (FIELD .EQ. '344'O) THEN

	CALL LINCHK (LUN,2)

	WRITE(LUN,120) (MAINTENANCE(I),I = 0,1)
120	FORMAT(' ',T40,'MASTER VERSION NO. = ',I3,'.',/,
	1 T40,'SLAVE VERSION NO.  = ',I3,'.')

	ELSE IF (FIELD .EQ. '346'O) THEN

	IF (MAINTENANCE(0) .EQ. '200'O) THEN

	CALL LINCHK (LUN,1)

	WRITE(LUN,125)
125	FORMAT(' ',T40,'SLAVE FIFO R/W ERROR')

	ELSE IF (MAINTENANCE(1) .EQ. '201'O) THEN

	CALL LINCHK (LUN,1)

	WRITE(LUN,130)
130	FORMAT(' ',T40,'KW11-K CLOCK A OVER-RUN')
	ENDIF

	CALL LINCHK (LUN,1)

	WRITE(LUN,135) MAINTENANCE(1)
135	FORMAT(' ',T40,'SLAVE FIRMWARE SEQ = ',O3,' (OCTAL)')

	ELSE IF (FIELD .EQ. '347'O) THEN

	CALL LINCHK (LUN,2)

	WRITE(LUN,140) (MAINTENANCE(I),I = 0,1)
140	FORMAT(' ',T40,'RETURNED VALUE = ',O3,' (OCTAL)',/
	1 T40,'EXPECTED VALUE = ',O3,' (OCTAL)')

	ELSE IF (FIELD .EQ. '350'O) THEN

	CALL LINCHK (LUN,2)

	WRITE(LUN,150) (MAINTENANCE(I),I = 0,1)
150	FORMAT(' ',T40,'RETURNED VALUE = ',O3,' (OCTAL)',/
	1 T40,'EXPECTED VALUE = ',O3,' (OCTAL)')

	ELSE IF (FIELD .EQ. '322'O) THEN

	CALL LINCHK (LUN,1)

	WRITE(LUN,155) (MAINTENANCE(I),I = 1,0,-1)
155	FORMAT(' ',T40,'ADDR OF MISSING DEV = ',O6)
	ENDIF

	if (emb$w_hd_entry .ne. 98) then

	if (ubareg(1) .ne. 0) then

	call uba_datapath (lun,ubareg(1),ubareg(2))
	endif
	endif

	call linchk (lun,1)

	write(lun,160)
160	format(' ',:)

	call ucb$l_char (lun,emb$l_dv_char)

	call ucb$w_sts (lun,emb$w_dv_sts)

	call ucb$l_opcnt (lun,emb$l_dv_opcnt)

	call ucb$w_errcnt (lun,emb$w_dv_errcnt)

	if (emb$w_hd_entry .ne. 98) then

	call linchk (lun,1)

	write(lun,160)

	call lpa11k_qio (lun,emb$w_dv_func)

	call irp$w_bcnt (lun,emb$w_dv_bcnt)

	call irp$w_boff (lun,emb$w_dv_boff)

	call irp$l_pid (lun,emb$l_dv_rqpid)

	call irp$q_iosb (lun,emb$l_dv_iosb1)
	endif

	RETURN




	ENTRY B_LPA11K (LUN)




	call dhead1 (lun,'UBA LPA11K')

	CALL BRIEF16 (LUN,4,CNTRL_MAINT,REG_HERALD,EMB$T_DV_NAME,EMB$W_DV_UNIT)

	RETURN




	ENTRY C_LPA11K (LUN)




	CALL CRYPTK (LUN,16,4,CNTRL_MAINT,REG_HERALD,
	1 EMB$T_DV_NAME,EMB$W_DV_UNIT)

	RETURN

	END



	subroutine lpa11k_qio (lun,emb$w_dv_func)



	include 'src$:qiocommon.for /nolist'



	byte		lun

	integer*2	emb$w_dv_func

	integer*4	qiocode(0:1,0:63)




	if (qiocode(0,0) .eq. 0) then

	qiocode(1,01) = %loc(io$_loadmcode)

	qiocode(1,02) = %loc(io$_startmproc)

	qiocode(1,04) = %loc(io$_initialize)

	qiocode(1,05) = %loc(io$_setclockp)

	qiocode(1,06) = %loc(io$_startdatap)

	qiocode(1,07) = %loc(io$_qstop)

	qiocode(1,55) = %loc(io$_setclock)

	qiocode(1,56) = %loc(io$_startdata)

	do 10,i = 0,63

	qiocode(0,i) = 33

	if (qiocode(1,i) .eq. 0) then

	qiocode(1,i) = %loc(qio_string)
	endif

10	continue
	endif

	call irp$w_func (lun,emb$w_dv_func,
	1 qiocode(0,lib$extzv(0,6,emb$w_dv_func)))

	return

	end
