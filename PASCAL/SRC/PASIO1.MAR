;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.TITLE	PAS$IO_BASIC		; PASCAL RMS linkage
	.ident 'V03-000'
;
;*********************************************************************
;*********************************************************************
;**								    **
;**             PASCAL RMS LINKAGE FOR VAX-11/780                   **
;**             =================================                   **
;**								    **
;**								    **
;**               VERSION V1.2 -- JANUARY 1981			    **
;**								    **
;**   DEVELOPED BY:  COMPUTER SCIENCE DEPARTMENT                    **
;**                  UNIVERSITY OF WASHINGTON                       **
;**                  SEATTLE, WA 98195                              **
;**								    **
;**   AUTHORS:       MARK BAILEY, JOHN CHAN, HELLMUT GOLDE          **
;**								    **
;*********************************************************************
;*********************************************************************
;
;
; History :
;
;	1. Change PAS$IOERROR to signal all errors with LIB$STOP
;	   instead of putting out messages directly
;	   10-JUN-80 S. Azibert
;
;	2. Change routines PAS$INPUT and PAS$OUTPUT to use the filenames
;	   SYS$INPUT and SYS$OUTPUT, if PAS$INPUT and PAS$OUTPUT are not defined.
;
;	3. Change the definition of PRN_CRLF so that on a terminal, a line
;	   of output looks like:
;		<LF> <text> <CR>
;
;	4.  Fix a bug introduced into PAS$INPUT and PAS$OUTPUT.
;	    $TRNLOG_S returns one of two successful values, 
;	    whereas the code was checking for an error return.
;
;	5.  Paul Hohensee	13-Jan-81
;	    Change all tests of status returns from RMS to BLBC R0,label
;	    or BLBS R0,label instead of CMPL R0,#RMS$NORMAL;BNEQ label, etc.
;
;	6.  Add a flag (PROMPT_FLAG) so that carriage control on
;	    prompting can be done correctly.  S. Azibert  15-Jan-81
;
;	7.  Deallocate record buffer after a file is closed (PAS$CLOSE)
;	    Record buffer is initially allocated by LIB$GET_VM, but the
;	    space is never released. Ditto file name string (assuming
;	    it was allocated by LIB$GET_VM (not in static storage).
;						Paul Hohensee
;
;	8.  Eliminate call to PAS$FILENAME for PAS$INITFILES. It does not
;	    seem to be necessary, since all file names passed to
;	    PAS$INITFILES are allocated in static, read/only storage,
;	    and therefore do not need PAS$FILENAME's services.
;	    Also, since bugfix number 7 above deallocates the file name
;	    string as well as the record buffer, multiple opens on the
;	    same file in the same block would not work (they would
;	    fail in RMS due to a bad file name) if space for the
;	    file name string were allocated by LIB$GET_VM.
;						Paul Hohensee 4/6/81
;
;	9.  Fix PAS$REWRITE to do a rewind on an empty file, rather than a truncate.
;						Paul Hohensee 19-Jul-81
;
;	10. Fix PAS$OPEN to request read-only access to INCLUDE'd files.
;	    Fix PAS$INPUT to request read-only access to INPUT.
;
;	11. Change references to external routines to general addressing.
;
;	12. Use NAM$C_BLN_V2 since compiler was built with VMS V2.
;	    Steven Lionel 23-Oct-1981
;
;	13. Change PAS$OPEN so that it no longer scans leading and trailing blanks
;	    from the filename.  V2 VMS does this for us.  We had been deallocating
;	    less space than was originally allocated because of the blanks.
;						Joyce Spencer 10-Oct-1981
;
;****************************************************************
;****************************************************************
;**                                                            **
;**                                                            **
;**                   SECTION 1                                **
;**                                                            **
;**                 BASIC PROCEDURES                           **
;**                                                            **
;**                                                            **
;****************************************************************
;****************************************************************
	.PAGE
; For any file variable the following storage is assumed:
;
;		 ------------------
;        FSB:   |      POINTER     |
;		 ------------------
;		|   STATUS WORD    |
;		 ------------------
;               |       LAST       |
;		 ------------------
;               |     LINELIMIT    |
;                ------------------
;               |     LINECOUNT    |
;                ------------------
;		|  RECORD NUMBER   |
;                ------------------
;	RAB:    |                  |
;		  44(HEX) BYTES  
;		|        .         |
;		         .
;		|        .         |
;		 ------------------
;	FAB:	|                  |
;		   50(HEX) BYTES    
;		|        .         |
;			 .
;		|        .         |
;		 ------------------
;       NAM:    |		   |    NOTE: The NAM block is allocated 
;		   38(HEX) BYTES        for the PASCAL logical files
;		|        .         |    'INPUT' and 'OUTPUT' only.
;                        .
;               |                  |
;                ------------------
;
; Macro options
;
	.DSABL	GBL			; no undefined references
	.ENABL	FPT			; rounded arithmetic
;
; External references
;
	.EXTRN	LIB$GET_VM
	.EXTRN	LIB$FREE_VM
	.EXTRN	LIB$STOP		; program abort
	.EXTRN	PAS$C_DFLTLINLI		; default linelimit
	.EXTRN	PAS$_ERRACCFIL		; PASCAL error message #8304
;
	.GLOBL	PAS$BLANK_R3
;
; Provide definitions of system values
;
	$DEVDEF				; device definitions
	$TRNLOGDEF
	$FABDEF
	$FORDEF				; FORTRAN error definitions
	$NAMDEF
	$RABDEF
	$RMSDEF				; for status code checking
        $stsdef                         ; status codes
	$SSDEF				; for system services return codes
;
; PASCAL compiler constants
;
; NOTE: The constants below with the names 'PAS$C_XXXXX' are 
; used in the PASCAL compiler with the names 'XXXXX'. If the 
; values in the compiler are altered then the below values
; must be altered accordingly.
;
	PAS$C_DFLTRECSI = 257		; default buffer size
;	PAS$C_NIL = 0			; NIL pointer
	PAS$C_TRUE = 1			; TRUE
	PAS$C_FALSE = 0			; FALSE
	PAS$C_NOCARR = 0		; no carriage control
;	PAS$C_CARRIAGE = 1		; FORTRAN carriage control
	PAS$C_LIST = 2			; LIST carriage control
	PAS$C_PRN = 3			; PRN carriage control
;
; PRN carriage control constants
;
	PRN_CRLF = ^X8D01		; PRN carriage control constant
					; for <LF> <text> <CR>
	PRN_NULL = ^X0000		; PRN carriage control constant
					; for no carriage control
	PRN_LF = ^X0001			; PRN carriage control constant
					; for <LF> <prompt>
	PRN_CR = ^X8D00			; PRN carriage control constant
					; for <text> <CR>

;
; File status block constants
;
	FSB$C_BLN = ^X18		; FSB block length
	FSB$V_OPEN = 5
	FSB$V_EOF = 1
	FSB$V_EOLN = 2
	FSB$V_GET = 3
 	FSB$V_TXT = 4			; textfile flag
	FSB$V_RDLN = 0			; last access was READLN
	FSB$V_DIR = 6			; direct access flag
	FSB$V_PUT = 7
	FSB$V_INT = 8			; internal flag
	FSB$V_PRMT = 9			; prompt flag
	FSB$V_OUTPUT = 10 		; OUTPUT file flag
;	FSB$V_ACTIN = 11		; actual input flag
	FSB$V_INPUT = 12		; INPUT file flag
	FSB$V_PROMPT = 13		; prompt flag
	FSB$V_WRITPRMT = 14		; WRITELN is being called to do prompting
	FSB$V_DELZ = 30			; delete file if empty
	FSB$V_INC = 31			; included file flag
	FSB$B_CC = 6			; carriage control byte offset
	FSB$M_OPEN = ^X0020
	FSB$M_EOF = ^X0002
	FSB$M_EOLN = ^X0004
	FSB$M_GET = ^X0008
;	FSB$M_PRMT = ^X0200
	FSB$M_PUT = ^X00000080
;	FSB$M_TXT = ^X0010
	FSB$M_RDLN = ^X0001
;	FSB$M_DIR = ^X00000040
;	FSB$M_INT = ^X00000100
	FSB$M_OUTPUT = ^X0400
	FSB$M_ACTIN = ^X0800
	FSB$M_INPUT = ^X1000
	FSB$M_PROMPT = ^X2000
	FSB$M_WRITPRMT = ^X4000		
	FSB$M_DELZ = ^X40000000
	FSB$M_INC = ^X80000000
	FSB$L_CNT = 16			; line count (textfiles)
;	FSB$L_INC = 20			; INCLUDE block address
	FSB$L_LIM = 12			; linelimit
	FSB$L_LST = 8			; last word offset
	FSB$L_PFSB = 20			; Related file FSB for prompting
					; for INPUT, has address of OUTPUT FSB
					; for OUTPUT, has address of INPUT FSB
					; (shares storage with include address
					; and direct access rec buf address)
	FSB$L_REC = 20			; record buffer address for
					; direct access (shares storage
					; with include address and related
					; file FSB)
	FSB$L_STA = 4			; status word offset
;
; Character constants
;
	TAB = ^X09
	SPACE = ^X20
;	DOLLAR = ^X24
;	FORMFEED = ^XC
;	STAR = ^X2A
;	PLUS = ^X2B
;	MINUS = ^X2D
;	POINT = ^X2E
;	ZERO = ^X30
;	ONE = ^X31
;	NINE = ^X39
;	AA = ^X41
;	DD = ^X44
;	EE = ^X45
;       ZZ = ^X5A
;	UNDERSCORE = ^X5F
	AA_SMALL = ^X61
	ZZ_SMALL = ^X7A
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;       *                  *
;       *    PAS$READOK    *
;       *                  *
;       ********************
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; address of FSB
;
	.ENTRY 	PAS$READOK,^M<R6> 
	MOVL	FSB_DISP(AP),R6		; R6 = address of FSB
	BBC	#FSB$V_GET,FSB$L_STA(R6),910$
					; read access allowed?
	CALLG	(AP),PAS$EOF
	BLBS	R0,920$			; read past EOF?
	RET
;
; Read access not allowed
;
  910$:
	MOVZWL	#^X8334,-(SP)
	MOVZBL	<FSB$C_BLN+RAB$C_BLN+FAB$B_FNS>(R6),-(SP)
	PUSHL	<FSB$C_BLN+RAB$C_BLN+FAB$L_FNA>(R6)
	CALLS	#3,PAS$IOERROR
;
; Read past end-of-file
;
  920$:
	PUSHL	#RMS$_EOF
	MOVZBL	<FSB$C_BLN+RAB$C_BLN+FAB$B_FNS>(R6),-(SP)
	PUSHL	<FSB$C_BLN+RAB$C_BLN+FAB$L_FNA>(R6)
	CALLS	#3,PAS$IOERROR
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;       *   PAS$WRITEOK    *
;       *                  *
;       ********************
;
; Argument offsets
;
;	AP:				; number of arguments (1)
	FSB_DISP = 04   		; FSB address
;
	.ENTRY	PAS$WRITEOK,^M<R6>
	MOVL	FSB_DISP(AP),R6		; R6 = address of FSB
	BBC	#FSB$V_PUT,FSB$L_STA(R6),910$
					; WRITE access allowed?
	RET
;
; WRITE access not allowed
;
  910$:
	MOVZWL	#^X8344,-(SP)
	MOVZBL	<FSB$C_BLN+RAB$C_BLN+FAB$B_FNS>(R6),-(SP)
	PUSHL	<FSB$C_BLN+RAB$C_BLN+FAB$L_FNA>(R6)
	CALLS	#3,PAS$IOERROR
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*  PAS$BUFFEROVER  *
;	*                  *
;	********************
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$BUFFEROVER,^M<R6>
	MOVL	FSB_DISP(AP),R6		; R6 = address of FSB
	MOVZWL	<FSB$C_BLN+RAB$W_USZ>(R6),-(SP)
					; pass buffer size
	MOVZWL	#^X8384, -(SP)		; pass error number
	MOVZBL	<FSB$C_BLN+RAB$C_BLN+FAB$B_FNS>(R6),-(SP)
	PUSHL	<FSB$C_BLN+RAB$C_BLN+FAB$L_FNA>(R6)
	CALLS	#4,PAS$IOERROR
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*   PAS$FILENAME   *
;	*                  *
;	********************
;
; Argument offsets
;
;	AP				; number of arguments (2)
	LEN_DISP = 04			; address of string length
	STR_DISP = 08			; address of string
;
	.ENTRY	PAS$FILENAME,^M<R2,R3,R4,R5,R7,R8,R9>
	MOVZBL	@LEN_DISP(AP),R7	; R7 = string length
	MOVL	@STR_DISP(AP),R8	; R8 = string address
	SUBL2	#8,SP			; make room for string address
					; and string length
	MOVL	SP,R9			; save address
	PUSHL	R9
	MOVL	R7,4(SP)
	PUSHAL	4(SP)
	CALLS	#2,G^LIB$GET_VM
	MOVL	(R9),R9
	MOVC3	R7,(R8),(R9)
	MOVL	R9,R8

	MOVB	R7,@LEN_DISP(AP)	; store new length
	MOVL	R8,@STR_DISP(AP)	; store new string address
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*  PAS$STATUSUPDAT *
;	*                  *
;	********************
;
; Updates the FSB status word based upon the current position of the file
; pointer. If the pointer is greater than the last position (FSB$L_LST)
; then RDLN is set true and EOF is checked. If the pointer is equal to 
; last then EOLN is set true. Otherwise EOLN and RDLN are left false.
;
; Argument offsets
;
;	AP 				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$STATUSUPDAT,^M<R6> 
	MOVL	FSB_DISP(AP),R6		; R6 = address of FSB
	BICL2	#FSB$M_ACTIN,FSB$L_STA(R6)
					; clear actual input flag
	CMPL	(R6),FSB$L_LST(R6)
	BLSS	130$			; middle of line
	BEQL	120$			; end of line
;
; Passed end-of-line, clear EOLN and set RDLN
;
	BICL2	#FSB$M_EOLN,FSB$L_STA(R6)
	BISL2	#FSB$M_RDLN,FSB$L_STA(R6)
	BBC	#FSB$V_EOF,FSB$L_STA(R6),110$
	CLRL	(R6)			; E0F, clear pointer
  110$:
	RET
;
; End-of-line, set EOLN flag
;
  120$:
	BISL2	#FSB$M_EOLN,FSB$L_STA(R6)
	RET
;
; Middle of line
;
  130$:
	BICL2	#FSB$M_EOLN,FSB$L_STA(R6)
					; make sure EOLN clear
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*   PAS$IOERROR    *
;	*                  *
;	********************
;
; Argument offsets
;
;	AP				; number of arguments (variable)
	FNM_DISP = 04			; file name string address
	FNL_DISP = 08			; file name string length
;	ERR1				; an indefinite number of error
					; code may follow
;	 .
;	 .
;	 .
;
	.ENTRY	PAS$IOERROR,^M<R2,R3,R4,R5,R6,R7>
	CLRL	R5
	PUSHL	FNM_DISP(AP)
	PUSHL	FNL_DISP(AP)
	SUBL3	#2,(AP),R6		; R6 = number of error arguments
	ADDL3	#4,AP,R7		; R7 = address of arguments
	MOVL	SP,R4			; save the top of the stack address
110$:
	ADDL2	#4,R7			; update address for special codes
111$:
	ADDL2	#4,R7			; update address for non-special codes
	CMPL	(R7),#^X9000		; test if RMS error
	BGEQ	130$
	CMPL	(R7),#^X8374		; test for line limit exceeded
	BEQL	112$
	CMPL	(R7),#^X8384		; test for line length exceeded
	BNEQ	115$
112$:					; buffer overflow and linelimit
	ADDL3	#^X210000,(R7),-(SP)	; store error number,
	PUSHL	#3			; store count of FAO arguments
	PUSHL	4(R7)			; first FAO argument
	PUSHL	#0			; second and third FAO arguments are 0
	PUSHL	#0
	ADDL2	#5,R5			; count number of arguments pushed
	DECL	R6
	SOBGTR	R6,110$			; loop if more arguments
	BRB	140$
115$:
	ADDL3	#^X210000,(R7),-(SP)	; store error number for all other I/O errors
	PUSHL	#3			; push FAO count of arguments
	PUSHL	#0			; store three null arguments
	CLRQ	-(SP)
	ADDL2	#5,R5			; count number of arguments stored
	SOBGTR	R6,111$			; loop if more arguments
	BRB	140$
130$:
	PUSHL	(R7)			; store RMS  error number
	PUSHL	#0			; store null argument
	ADDL2	#2,R5			; count items pushed on the stack
	SOBGTR	R6,111$			; loop if more arguments
140$:
;
; This section of code reverses the order of the arguments to lib$stop
; that are already on the stack.  Then the error ERRACCFIL is pushed and LIB$STOP 
; is called.

;
	MOVL	SP,R3		; save the address of the top of the stack
1$:	MOVL	-(R4),R2	; move the first item from bottom of the stack
	CMPL	R4,R3		; have all the items been switched?
	BLSSU	2$		; done : all items are switched
	MOVL	(R3),(R4)	; switch two items
	MOVL	R2,(R3)+	;
	BRB	1$
2$:
	PUSHL	#0		; store FAO arguments for ERRACCFIL
	MOVQ	-8(FP),-(SP)	; push name of file being accessed
	PUSHL	#3		; store count of FAO arguments
	ADDL3	#4,#PAS$_ERRACCFIL,-(SP)	; store error message number
	ADDL2	#5,R5		; count number of arguments stored
	CALLS	R5,G^LIB$STOP	; signal errors and stop
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*   PAS$BLANK_R3   *
;	*                  *
;	********************
;
; A JSB routine which skips leading blanks on a file. It requires
; that R2 contain the FSB address. THe following values are returned
; in the designated registers.
;
;	R0:	number of bytes in the line after the skip
;	R1:	address of the byte located
;	R2:	address of the FSB (input)
;
PAS$BLANK_R3:
  110$:
	PUSHL	R2
	CALLS	#1,PAS$READOK		; check read ok and EOF
	MOVL	(R2),R1			; R1 = current buffer position
	SUBL3	R1,FSB$L_LST(R2),R0	; R0 = remaining line length
  120$:
	SKPC	#SPACE,R0,(R1)		; skip blanks
	TSTL	R0			; test for end-of-line
	BEQL	130$
	MOVL	R0,R3
	SKPC	#TAB,R0,(R1)		; skip tabs
	TSTL	R0			; test for end-of-line
	BEQL	130$
	CMPL	R0,R3			; skipped any tabs?
	BNEQ	120$
	RSB
  130$:
	BISL2	#FSB$M_RDLN,FSB$L_STA(R2)
					; force next line
	BRB	110$
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*     PAS$INPUT    *
;	*                  *
;	********************
;
; Initializes, opens, and resets the standard file INPUT.
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
; Constants
;
		INPUTLEN = 9
PASINPUT:	.ASCII	/PAS$INPUT/
SYSINPUT:	.ASCII	/SYS$INPUT/		
PASDESCR:	.LONG	INPUTLEN	; create a descriptor for PAS$INPUT
		.LONG	PASINPUT
;
	.ENTRY	PAS$INPUT,^M<R2,R3,R4,R5>
;
; Initialize
;
	SUBL2	#63,SP			; clear 63 bytes on the stack
	PUSHL	SP			; create a descriptor for RSLBUF
	PUSHL	#63			
	MOVL	SP,R4			; save the address of the descriptor
	MOVL	FSB_DISP(AP),R5		; R5 = address of FSB
	PUSHL	#PAS$C_DFLTRECSI	; maximum buffer length
	PUSHL	#1		        ; textfile
	PUSHL	#0			; external file
	PUSHL	#INPUTLEN		; input name string length
	$TRNLOG_S	LOGNAM=PASDESCR,RSLBUF=(R4)	; try to translate PAS$INPUT
	CMPL	R0,#SS$_NOTRAN		; on error,
	BEQL	1$			; use SYS$INPUT
	PUSHAL	PASINPUT		; otherwise, use PAS$INPUT
	BRB	2$
1$:	PUSHAL	SYSINPUT
2$:	PUSHL	R5			; FSB address
	CALLS	#6,PAS$INITFILES
;
; Fix up RAB, FAB, and NAM blocks
;
	ADDL3	#FSB$C_BLN,R5,R2	; R2 = address of RAB
	ADDL3	#RAB$C_BLN,R2,R3	; R3 = address of FAB
	ADDL3	#FAB$C_BLN,R3,R4	; R4 = address of NAM
	MOVL	R4,FAB$L_NAM(R3)	; NAM block address
	MOVB	#NAM$C_BID,NAM$B_BID(R4); block identification
	MOVB	#NAM$C_BLN_V2,NAM$B_BLN(R4); block length
;
; Open file
;
	BISL2	#FSB$M_INC,FSB$L_STA(R5); Fake INCLUDE'd file to get
					; read-only access
	PUSHL	#PAS$C_NOCARR		; carriage control -- not used
	PUSHL	#PAS$C_DFLTRECSI
	CLRD	-(SP)
	CLRD	-(SP)
	PUSHL	R5
	CALLS	#7,PAS$OPEN
	BICL2	#FSB$M_INC,FSB$L_STA(R5); Unfake INCLUDE'd file
;
; Reset file
;
	PUSHL	R5
	CALLS	#1,PAS$RESET
	BISL2	#FSB$M_INPUT,FSB$L_STA(R5)
					; set input flag
	RET
;
;
	.PSECT	_PAS$CODE	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*    PAS$OUTPUT    *
;	*                  *
;	********************
;
; Initializes, creates, and rewrites the standard file OUTPUT.
;
; Argument offsets
;
;	AP				; number of arguments (2)
	FSB_DISP = 04			; address of OUTPUT FSB
	INP_DISP = 08			; address of INPUT FSB
;
; Constants
;
		OUTPUTLEN = 10
SYSOUTPUT:	.ASCII	/SYS$OUTPUT/		; changed from PAS$OUTPUT for V1.2
PASOUTPUT:	.ASCII	/PAS$OUTPUT/
OUTDESCR:	.LONG	OUTPUTLEN
		.LONG	PASOUTPUT
;
	.ENTRY	PAS$OUTPUT,^M<R2,R3,R4,R5,R6,R7,R8>
;
; Initialize file
;
	SUBL2	#63,SP			; put a 63 byte buffer on the stack
	PUSHL	SP			; create the descriptor for RSLBUF
	PUSHL	#63
	MOVL	SP,R2			; save the address of the descriptor
	MOVL	FSB_DISP(AP),R6		; R6 = address of OUTPUT FSB
	ADDL3	#<FSB$C_BLN+RAB$C_BLN>,R6,R7
					; R7 = address of OUTPUT FAB
	ADDL3	#FAB$C_BLN,R7,R8	; R8 = NAM block address
	PUSHL	#PAS$C_DFLTRECSI	; maximum record size
	PUSHL	#1			; textfile
	PUSHL	#0			; external file
	PUSHL	#OUTPUTLEN		; output name string length
	$TRNLOG_S	LOGNAM=OUTDESCR,RSLBUF=(R2)	; try to translate PAS$OUTPUT
	CMPL	R0,#SS$_NOTRAN		; on error,
	BEQL	1$			; use SYS$OUTPUT
	PUSHAL	PASOUTPUT		; otherwise, use PAS$OUTPUT
	BRB	2$
1$:	PUSHAL	SYSOUTPUT		; output name string address
2$:	PUSHL	R6			; FSB address
	CALLS	#6,PAS$INITFILES
;
; Create file
;
	MOVL	R8,FAB$L_NAM(R7)	; link NAM block
	MOVC5	#0,(R8),#0,#NAM$C_BLN_V2,(R8)
					; clear NAM block
	MOVB	#NAM$C_BID,NAM$B_BID(R8)
	MOVB	#NAM$C_BLN_V2,NAM$B_BLN(R8)
	PUSHL	#PAS$C_LIST		; carriage control
	PUSHL	#PAS$C_DFLTRECSI+2	; record length (allow 2 bytes for
					; PRN carriage control buffer)
	CLRD	-(SP)
	CLRD	-(SP)
	PUSHL	R6			; FSB address
	CALLS	#7,PAS$CREATE
	ADDL2	#2,FSB$C_BLN+RAB$L_UBF(R6)
					; reserve 2 bytes for PRN carriage
					; control
;
; Rewrite file
;
	PUSHL	R6
	CALLS	#1,PAS$REWRITE
	BISL2	#FSB$M_OUTPUT,FSB$L_STA(R6)
					; set OUTPUT flag
	MOVL	INP_DISP(AP),R5		; R5 = address of INPUT FSB
	BEQL	10$			; done if no INPUT file
	BBC	#DEV$V_TRM,-
			FSB$C_BLN+RAB$C_BLN+FAB$L_DEV(R5),10$ ;
					; done if INPUT is not a terminal
	BBC	#DEV$V_TRM,FAB$L_DEV(R7),10$
					; done if OUTPUT is not a terminal
;
; INPUT and OUTPUT are going to terminals.  Reopen OUTPUT with PRN carriage
; control, and set FSB's to do prompting.
;
	$CLOSE	FAB=R7			; close OUTPUT
	MOVB	#FAB$C_VFC,FAB$B_RFM(R7); set fixed-length control format
	MOVB	#2,FAB$B_FSZ(R7)	; set control field size to 2
	CLRB	FAB$B_RAT(R7)		; clear old carriage control
	INSV	#1,#FAB$V_PRN,#1,FAB$B_RAT(R7)
					; set PRN carriage control
	$CREATE	FAB=R7			; create new OUTPUT file
	SUBL3	#2,FSB$C_BLN+RAB$L_RBF(R6),-
			FSB$C_BLN+RAB$L_RHB(R6)
					; set RAB header buffer address
					; (address of PRN carriage
					; control buffer)
	$CONNECT RAB=FSB$C_BLN(R6)	; re-connect RAB
	INSV	#1,#FSB$V_PRMT,#1,FSB$L_STA(R5)
					; set prompt bit of INPUT FSB
	MOVL	R6,FSB$L_PFSB(R5)	; set related file FSB of INPUT
	MOVL	R5,FSB$L_PFSB(R6)	; set related file FSB of OUTPUT
	MOVW	#PRN_CRLF,@FSB$C_BLN+RAB$L_RHB(R6)
					; initialize carriage control
	MOVB	#PAS$C_PRN,FSB$B_CC(R6)	; set PRN carriage control in FSB
10$:	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*   PAS$INITFILES  *
;	*                  *
;	********************
;
; Called at procedure entry time to initialize the FSB, RAB and FAB to
; PASCAL default values after clearing them.
;
; Argument offsets
;
;	AP				; number of arguments (6 per file)
;
	FSB_DISP = 04			; FSB address
	NAM_DISP = 08			; name string address
	LEN_DISP = 12			; name string length
	EXT_DISP = 16			; external/internal flag
					;   0 = external
					;   1 = internal (delete on close)
	TXT_DISP = 20			; textfile flag
					;   0 = non-textfile
					;   1 = textfile
	MRL_DISP = 24			; maximum record size
;
; Arguments above are repeated for each file
;
; Default file name
;
 DFNAM:	.ASCII	/.DAT/
	DFLEN = 4
;
	.ENTRY	PAS$INITFILES,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	DIVL3	#6,(AP),R11		; R11 = # of files (N)
	MOVL	AP,R10			; R10 = address of AP
					; (simulates AP position in loop)
   10$:					; loop until all files initialized
	MOVL	FSB_DISP(R10),R6	; R6 = address of FSB
	ADDL3	R6,#FSB$C_BLN,R7	; R7 = address of RAB
	ADDL3	R7,#RAB$C_BLN,R8	; R8 = address of FAB
;
; Clear control blocks (in case on stack)
;
	MOVC5	#0,(R6),#0, -
			#<FSB$C_BLN+RAB$C_BLN+FAB$C_BLN>,(R6)
;
; Initialize FSB
;
	INSV	TXT_DISP(R10),#FSB$V_TXT,#1,FSB$L_STA(R6)
					; textfile flag
	INSV	EXT_DISP(R10),#FSB$V_INT,#1,FSB$L_STA(R6)
					; internal flag
	MOVL	G^PAS$C_DFLTLINLI,FSB$L_LIM(R6)
					; linelimit
;
; Initialize RAB
;
	MOVB	#RAB$C_BID,RAB$B_BID(R7); block ID
	MOVB	#RAB$C_BLN,RAB$B_BLN(R7); block length
	MOVL	R8,RAB$L_FAB(R7)	; FAB address
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R7); sequential record access
	MOVW	MRL_DISP(R10),RAB$W_USZ(R7) 
					; set buffer size
;
; Initialize FAB
;
	MOVB	#FAB$C_BID,FAB$B_BID(R8); block ID
	MOVB	#FAB$C_BLN,FAB$B_BLN(R8); block length
	MOVL	NAM_DISP(R10),FAB$L_FNA(R8)
					; file specification address
	MOVB	LEN_DISP(R10),FAB$B_FNS(R8)
					; file specification size
	MOVAL	DFNAM,FAB$L_DNA(R8)	; default file name
	MOVB	#DFLEN,FAB$B_DNS(R8)	; default file name length

;	The call to PAS$FILENAME was removed under the assumption that
;	any name passed to PAS$INITFILES is in read/only static storage
;	and does not need space for it allocated by LIB$GET_VM, nor
;	does it need leading blanks stripped from it.
;
;	PUSHAL	FAB$L_FNA(R8)		; file name string address
;	PUSHAB	FAB$B_FNS(R8)		; file name string length address
;	CALLS	#2,PAS$FILENAME

	MOVB	#FAB$C_SEQ,FAB$B_ORG(R8); sequential files only
	INSV	EXT_DISP(R10),#FAB$V_TMD,#1,FAB$L_FOP(R8)
					; temporary file
	ADDL2	#24,R10			; get next FSB address
	SOBGTR	R11,10$			; decrement # of files counter
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*		   *
;	*    PAS$OPEN      *
;	*		   *
;	********************
;
; Opens an existing file. The FSB, RAB, and FAB must have been
; initialized by a call to PAS$INIT before this routine is called.
; Space for the record buffer is alocated by a call to 'GET_VM'.
; Any error in opening or connecting the file causes a runtime error.
;
; Argument offsets
;
;	AP				; number of arguments (7)
	FSB_DISP = 04			; FSB address
	NAM_DISP = 08	 		; file name string
					;    0 = use default
	LEN_DISP = 12			; file name string length
	ACC_DISP = 16			; RMS record access mode
					;    0 = sequential
					;    1 = direct
	FMT_DISP = 20			; RMS record format --- not used
					;    0 = variable
					;    1 = fixed
	MRL_DISP = 24			; maximum record length (buffer
					; size)
					;    negative = allocate zero
					;       but set USZ (used by
					;       compiler only)
					;    zero = not used
					;    positive = allocate as
					;       requested and check ok
	CAR_DISP = 28			; carriage control flag --- not used
					;    0 = no carriage control
					;    1 = fortran carriage control
                        		;    2 = CR/LF carriage control (LIST)
;
	.ENTRY	PAS$OPEN,^M<R2,R3,R4>
	JSB	CBINIT_R4		; control block initialization
					; returns R2 = address of FSB
					;         R3 = address of RAB
					;         R4 = address of FAB
;
; Open file with correct privilages (read and/or write)
;

; INCLUDE'd files are opened Read-only
;
	BBS	#FSB$V_INC,FSB$L_STA(R2),110$
;
; Read and write access
;
	CLRB	FAB$B_FAC(R4)
	BISB2	#FAB$M_GET,FAB$B_FAC(R4)
	BISB2	#FAB$M_PUT,FAB$B_FAC(R4)
	BISB2	#FAB$M_TRN,FAB$B_FAC(R4)
	$OPEN	FAB=R4
	bbc	#fsb$v_int,fsb$l_sta(r2),101$	; Better not be an internal file
	brw	920$
101$:
	BLBS	R0,120$			; branch if ok
	CMPL	R0,#RMS$_PRV		; check for privilege violation
	BNEQ	900$
;
; Read access only
;
110$:
	CLRB	FAB$B_FAC(R4)
	BISB2	#FAB$M_GET,FAB$B_FAC(R4)
	$OPEN	FAB=R4
	BLBS	R0,120$			; branch if ok
	BBS	#FSB$V_INC,FSB$L_STA(R2),900$
					; error if INCLUDE'd file and can't
					; get read access
	CMPL	R0,#RMS$_PRV
	BNEQ	900$
;
; Write access only
;
	CLRB	FAB$B_FAC(R4)
	BISB2	#FAB$M_PUT,FAB$B_FAC(R4)
	BISL2	#FAB$M_TRN,FAB$B_FAC(R4)
	$OPEN	FAB=R4
	BLBS	R0,120$			; branch if ok
	CMPL	R0,#RMS$_PRV
	BNEQ	900$
;
; Connect the file
;
  120$:
	$CONNECT RAB=R3
	CMPL	R0,#RMS$_PENDING	; check for completion
	BNEQ	121$
	$WAIT	RAB=R3
  121$:
	BLBC	R0,900$			; branch if error
	BISL2	#FSB$M_OPEN,FSB$L_STA(R2)
					; set open flag
	RET
;
; Open error, send error message and stop
;
  900$:
	PUSHL	R0			; RMS error
	MOVZWL	#^X8314,-(SP)		; PASCAL error
	MOVZBL	FAB$B_FNS(R4),-(SP)	; file name string length
	PUSHL	FAB$L_FNA(R4)		; file name string
	CALLS	#4,PAS$IOERROR
  920$:
	movzwl	#^x8314,-(sp)		; PASCAL error
	movzbl	fab$b_fns(r4),-(sp)	; file name string length
	pushl	fab$l_fna(r4)		; file name string
	calls	#3,pas$ioerror
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*    PAS$CREATE    *
;	*                  *
;	********************
;
; Creates a new file. The FSB, RAB, and FAB must have been initialized
; by a call to PAS$INIT before this routine is called. Any error in
; creating or connecting the file causes a runtime error.
;
; Argument offsets
;
;	AP				; number of arguments (7)
	FSB_DISP = 04			; FSB address
	NAM_DISP = 08			; file name string
					;    0 = use default
	LEN_DISP = 12			; file name string length
	ACC_DISP = 16			; RMS record access mode
					;    0 = sequential
					;    1 = direct
	FMT_DISP = 20			; RMS record format
					;    0 = variable
					;    1 = fixed
	MRL_DISP = 24			; maximum record length(buffer size)
					; (buffer size)
					;    negative or zero = error
					;        (not used)
					;    positive = allocate requested
					;       amount
	CAR_DISP = 28			; carriage control
					;    0 = no carriage control
					;    1 = FORTRAN carriage control
                        		;    2 = CR/LF carriage control
					;        (LIST)
;
	.ENTRY	PAS$CREATE,^M<R2,R3,R4,R5,R6>
	JSB	CBINIT_R4		; control block initialization
					; returns R2 = address of FSB
					;         R3 = address of RAB
					;         R4 = address of FAB
	CLRL	R5			; clear test register
	MOVL	CAR_DISP(AP),R6		; get carriage control into R6
	BBC	#FSB$V_OUTPUT,FSB$L_STA(R2),200$
					; check for file OUTPUT
	TSTL	FSB$L_CNT(R2)		; check line count
	BNEQ	270$
	TSTL	NAM_DISP(AP)		; check standard parameters
	BNEQ	270$
	TSTL	ACC_DISP(AP)
	BNEQ	270$
	TSTL	FMT_DISP(AP)
	BNEQ	270$
	CMPL	MRL_DISP(AP),#PAS$C_DFLTRECSI
	BNEQ	270$
;
	CMPB	R6,FSB$B_CC(R2)		; check for existing carriage
					; control
	BNEQ	280$			; return if new one is the same
	RET
;
 280$:
	CMPB	#PAS$C_PRN,FSB$B_CC(R2) ; return if old one is PRN and
	BNEQ	260$			; new one is LIST
	CMPB	R6,#PAS$C_LIST
	BNEQ	275$
	RET
;
 270$:
	BRW	910$
275$:
;
;  Old carriage control is PRN and new is not.  Disable prompting.
;
	MOVL	FSB$L_PFSB(R2),R0	; R0 = address of INPUT FSB
	INSV	#0,#FSB$V_PRMT,#1,FSB$L_STA(R0)
					; clear PROMPT bit
 260$:
	INCL	R5			; set OUTPUT flag
	BISL2	#FSB$M_DELZ,FSB$L_STA(R2)
					; set delete flag
	PUSHL	R2
	CALLS	#1,PAS$CLOSEINOUT
	BICL2	#FAB$M_DLT,FAB$L_FOP(R4); clear delete flag
 200$:
	BBC	#FSB$V_TXT,FSB$L_STA(R2),216$
					; skip if binary
	CLRB	FAB$B_RAT(R4)		; clear field
	MOVB	R6,FSB$B_CC(R2)		; set carriage control field
	CMPL	R6,#1 			; set carriage control
	BLSS	216$
	BGTR	212$
	INSV	#1,#FAB$V_FTN,#1,FAB$B_RAT(R4)
					; FORTRAN carriage control
	BRB	216$
  212$:
	INSV	#1,#FAB$V_CR,#1,FAB$B_RAT(R4)
					; CR/LF carriage control
  216$:
	TSTL	FMT_DISP(AP)		; record format
	BNEQ	220$
	MOVB	#FAB$C_VAR,FAB$B_RFM(R4); variable
	BRB	221$
  220$:
	MOVB	#FAB$C_FIX,FAB$B_RFM(R4); fixed
	MOVW	MRL_DISP(AP),FAB$W_MRS(R4)
					; set maximum record size
;
; Create file with read and write access
;
  221$:
	CLRB	FAB$B_FAC(R4)
	BISB2	#FAB$M_GET,FAB$B_FAC(R4)
	BISB2	#FAB$M_PUT,FAB$B_FAC(R4)
	BISB2	#FAB$M_TRN,FAB$B_FAC(R4)
	$CREATE	FAB=R4
	BLBC	R0,900$			; Branch on error
	$CONNECT RAB=R3
	CMPL	R0,#RMS$_PENDING	; check for completion
	BNEQ	131$
	$WAIT	RAB=R3
  131$:
	BLBC	R0,900$			; branch if error
	BISL2	#FSB$M_OPEN,FSB$L_STA(R2)
					; set open flag
	TSTL	R5			; check for file OUTPUT
	BEQL	160$
	BISL2	#FSB$M_OUTPUT,FSB$L_STA(R2)
					; set OUTPUT flag
	BICL2	#FSB$M_DELZ,FSB$L_STA(R2)
					; clear delete flag
 160$:
	RET
;
; Create error, send error message and abort
;
  900$:
	PUSHL	R0			; RMS error
	MOVZWL	#^X8314,-(SP)		; PASCAL error
	MOVZBL	FAB$B_FNS(R4),-(SP)	; file name string length
	PUSHL	FAB$L_FNA(R4)		; file name string
	CALLS	#4,PAS$IOERROR
;
; File OUTPUT erroneously opened
;
 910$:
	MOVZWL	#^X83F4,-(SP)		; error code
	MOVZBL	FAB$B_FNS(R4),-(SP)	; file name string length
	PUSHL	FAB$L_FNA(R4)		; file name string
	CALLS	#3,PAS$IOERROR
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*     CBINIT_R4    *
;	*                  *
;	********************
;
; This JSB routine initializes the RAB and FAB control blocks during 
; an OPEN/CREATE request. The addresses of the FSB, RAB, and FAB are
; returned in registers R2, R3, and R4 respectively. Space for the user
; buffer is also allocated.
;
CBINIT_R4:
	MOVL	FSB_DISP(AP),R2		; R2 = address of FSB
	ADDL3	R2,#FSB$C_BLN,R3	; R3 = address of RAB
	ADDL3	R3,#RAB$C_BLN,R4	; R4 = address of FAB
;
; Allocate buffer space
;
	TSTL	MRL_DISP(AP)
	BLEQ	120$
	BBS	#FSB$V_OUTPUT,FSB$L_STA(R2),121$
	PUSHAL	RAB$L_UBF(R3)
	PUSHAL	MRL_DISP(AP)
	CALLS	#2,G^LIB$GET_VM
	BLBS	R0,121$
	PUSHL	R0
	MOVZWL	#^X8324,-(SP)
	MOVZBL	FAB$B_FNS(R4),-(SP)
	PUSHL	FAB$L_FNA(R4)
	CALLS	#4,PAS$IOERROR
  120$:
	BEQL	121$
	MNEGL	MRL_DISP(AP),MRL_DISP(AP)
  121$:
	INSV	ACC_DISP(AP),#FSB$V_DIR,#1,FSB$L_STA(R2)
					; direct flag
	MOVW	MRL_DISP(AP),RAB$W_USZ(R3)
					; user record area size
	TSTL	NAM_DISP(AP)		; check for file name
	BEQL	910$			; branch if no file name
	MOVL	NAM_DISP(AP),FAB$L_FNA(R4)
					; file name string address
	MOVB	LEN_DISP(AP),FAB$B_FNS(R4)
					; file name string length
	PUSHAL	FAB$L_FNA(R4)		; file name string address
	PUSHAB	FAB$B_FNS(R4)		; file name string length address
	CALLS	#2,PAS$FILENAME		; translate file name
  910$:
	RSB
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*    PAS$RESET     *
;	*                  *
;	********************
;
; Rewinds a file to the beginning of information and sets/clears the
; appropriate flags in the status word of the FSB. If the file is
; not already opened (the open bit is clear) then an existing file
; is opened by a call to PAS$OPEN. The buffer is NOT filled.
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$RESET,^M<R2,R3,R4>
	MOVL	FSB_DISP(AP),R2		; R2 = address of FSB
	ADDL3	R2,#FSB$C_BLN,R3	; R3 = address of RAB
	ADDL3	R3,#RAB$C_BLN,R4	; R4 = address of FAB
	BBS	#FSB$V_OPEN,FSB$L_STA(R2),110$
					; branch if open
	BBC	#FSB$V_INT,FSB$L_STA(R2),105$
					; internal file?
;
; Error if unopened internal file
;
	PUSHL	#RMS$_FNF		; pass 'file not found' error
	MOVZBL	<FSB$C_BLN+RAB$C_BLN+FAB$B_FNS>(R2),-(SP)
	PUSHL	<FSB$C_BLN+RAB$C_BLN+FAB$L_FNA>(R2)
	CALLS	#3,PAS$IOERROR
;
; Open an unopened but existing file
;
  105$:
	PUSHL	#PAS$C_NOCARR		; carriage control -- not used
	MOVZWL	RAB$W_USZ(R3),-(SP)	; record length
	CLRD	-(SP)
	CLRD	-(SP)
	PUSHL	FSB_DISP(AP)
	CALLS	#7,PAS$OPEN
;
; Rewind the file if applicable
; Flush the buffer if necessary
;
  110$:
	BBS	#DEV$V_REC,FAB$L_DEV(R4),120$
					; can't rewind unit record  device
	BBC	#FSB$V_PUT,FSB$L_STA(R2),115$
					; last operation write?
	CMPL	(R2),RAB$L_RBF(R3)	; buffer empty
	BEQL	115$
	CALLG	(AP),PAS$WRITELN	; flush buffer
  115$:
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R3); make sure sequential
					; (for binary files)
	$REWIND	RAB=R3
	CMPL	R0,#RMS$_PENDING	; check for completion
	BNEQ	118$
	$WAIT	RAB=R3
  118$:
	BLBS	R0,120$			; branch if ok
	PUSHL	R0
	MOVZWL	#^X8354,-(SP)
	MOVZBL	FAB$B_FNS(R4),-(SP)
	PUSHL	FAB$L_FNA(R4)
	CALLS	#4,PAS$IOERROR
;
; Reset status word
;
  120$:
	BICL	#FSB$M_EOF,FSB$L_STA(R2)
	BICL	#FSB$M_EOLN,FSB$L_STA(R2) 
	BISL2	#FSB$M_GET,FSB$L_STA(R2); set read flag
	BICL2	#FSB$M_PUT,FSB$L_STA(R2); clear write flag
	BISL	#FSB$M_RDLN,FSB$L_STA(R2)
					; set READLN flag
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*    PAS$REWRITE   *
;	*                  *
;	********************
;
; Closes and deletes the existing file (if one exists) and creates a
; new file, setting/clearing the appropriate flags in the status word
; of the FSB
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$REWRITE,^M<R2,R3,R4,R5>
	MOVL	FSB_DISP(AP),R2		; R2 = address of FSB
	ADDL3	R2,#FSB$C_BLN,R3	; R3 = address of RAB
	ADDL3	R3,#RAB$C_BLN,R4	; R4 = address of FAB
	BBS	#FSB$V_OPEN,FSB$L_STA(R2),110$
					; branch if existing file
;
; Not yet opened, create a new file
;
	PUSHL	#PAS$C_LIST		; default carriage control
	MOVZWL	RAB$W_USZ(R3),-(SP)	; record size
	CLRD	-(SP)
	CLRD	-(SP)
	PUSHL	FSB_DISP(AP)
	CALLS	#7,PAS$CREATE
	BRW	180$
;
; Truncate the file from the 1st record on
;
  110$:
	BBC	#DEV$V_REC,FAB$L_DEV(R4),111$
	BRW	180$			; skip for unit record device
111$:	MOVB	#RAB$C_SEQ,RAB$B_RAC(R3); make sure sequential
					; (for binary files)
	$REWIND	RAB=R3
	CMPL	R0,#RMS$_PENDING
	BNEQ	120$
	$WAIT	RAB=R3
  120$:
	BLBS	R0,125$			; branch if ok
	BRW	900$
  125$:
	$GET	RAB=R3			; get first for truncate
	CMPL	R0,#RMS$_PENDING
	BNEQ	130$
	$WAIT	RAB=R3
  130$:
	CMPL	R0,#RMS$_EOF		; check if empty file
	BNEQ	137$

	$REWIND	RAB=R3			; if empty, rewind and set TPT bit
	CMPL	R0,#RMS$_PENDING
	BNEQ	135$
	$WAIT	RAB=R3
135$:	BLBC	R0,900$
	BISL2	#RAB$M_TPT,RAB$L_ROP(R3)
	BRB	180$

137$:	BLBC	R0,900$			; branch if error
	$TRUNCATE RAB=R3		; truncate the (empty or non-empty) file
	CMPL	R0,#RMS$_PENDING
	BNEQ	140$
	$WAIT	RAB=R3
  140$:
	BLBC	R0,900$			; branch if error
;
; Set the FSB and record address
;
  180$:
	MOVL	RAB$L_UBF(R3),RAB$L_RBF(R3)
					; set write buffer address
	MOVW	RAB$W_USZ(R3),RAB$W_RSZ(R3)
					; set write buffer size
	BICL2	#FSB$M_RDLN,FSB$L_STA(R2)
					; clear RDLN flag
	BISL	#FSB$M_EOF,FSB$L_STA(R2); set EOF
	BISL	#FSB$M_EOLN,FSB$L_STA(R2)
					; set EOLN
	BICL2	#FSB$M_GET,FSB$L_STA(R2); clear read flag
	BISL2	#FSB$M_PUT,FSB$L_STA(R2); set write flag
	CLRL	FSB$L_CNT(R2)		; clear write record count
	MOVL	RAB$L_RBF(R3),(R2)	; initialize pointer to first
	CVTWL	RAB$W_USZ(R3),R0
	ADDL3	RAB$L_RBF(R3),R0,FSB$L_LST(R2)
					; set last
	RET
;
; Error detected during rewrite
;
  900$:
	PUSHL	R0
	MOVZWL	#^X8364,-(SP)
	MOVZBL	FAB$B_FNS(R4),-(SP)
	PUSHL	FAB$L_FNA(R4)
	CALLS	#4,PAS$IOERROR
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*     PAS$FIND     *
;	*                  *
;	********************
;
; Sets access by key field and sets key value for the next read.
; The access mode is returned to sequential at the end
; of the next read (PAS$GETBIN).
;
; Argument offsets
;	AP				; number of arguments (2)
	FSB_DISP = 04			; FSB address
	REC_DISP = 08			; relative record number (by value)
;
	.ENTRY	PAS$FIND,^M<R6,R7,R8,R9>
	MOVL	FSB_DISP(AP),R6		; R6 = address of FSB
	ADDL3	#FSB$C_BLN,R6,R7	; R7 = address of RAB
	ADDL3	#RAB$C_BLN,R7,R8	; R8 = address of FAB
;
; Check if RESET called 
;
	BBC	#FSB$V_GET,FSB$L_STA(R6),930$
					; read access?
;
; Check for valid file type and set access to key
;	    (1) must be binary file
;	    (2) sequential file with fixed length records
;
	BBS	#FSB$V_TXT,FSB$L_STA(R6),910$
					; must be binary file
	CMPB	#FAB$C_SEQ,FAB$B_ORG(R8); sequential file
	BNEQ	910$
	CMPB	#FAB$C_FIX,FAB$B_RFM(R8); fixed length records
	BNEQ	910$
	MOVB	#RAB$C_KEY,RAB$B_RAC(R7); set key access
	MOVB	#4,RAB$B_KSZ(R7)	; set key size
	bicl2	#fsb$m_eof,fsb$l_sta(r6); clear eof flag
	MOVAL	FSB$L_REC(R6),RAB$L_KBF(R7)
					; set key buffer address
	MOVL	REC_DISP(AP),FSB$L_REC(R6)
					; set key
	BBC	#FSB$V_GET,FSB$L_STA(R6),115$
	BISL2	#FSB$M_RDLN,FSB$L_STA(R6)
					; set RDLN flag
 115$:
	RET
;
; Error, file not of appropriate type
;
  910$:
	MOVZWL	#^X83C4,-(SP)
	MOVZBL	FAB$B_FNS(R8),-(SP)
	PUSHL	FAB$L_FNA(R8)
	CALLS	#3,PAS$IOERROR
;
; Error, file not reset or rewritten
;
  930$:
	MOVZWL	#^X83D4,-(SP)
	MOVZBL	FAB$B_FNS(R8),-(SP)
	PUSHL	FAB$L_FNA(R8)
	CALLS	#3,PAS$IOERROR
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*    PAS$CLOSE     *
;       *  PAS$CLOSEINOUT  *
;	*                  *
;	********************
;
; Closes N files (N > 0). The pointer is set to nil and the open
; flag is cleared. Any error in closing the file causes a runtime error.
;
; Argument offsets
;
;	AP				; number of arguments (n)
;	AP+4			 	; FSB address of file #1
;	  .
;	  .
;	  .
;	AP+N				; FSB address of file #n
;
	.ENTRY	PAS$CLOSEINOUT,^M<R2,R3,R4,R5,R6,R7>
	MOVL	#1,R7			; set flag for CLOSEINOUT
	BRB	CLOSEENT
;
	.ENTRY  PAS$CLOSE,^M<R2,R3,R4,R5,R6,R7>
	CLRL	R7			; set flag for CLOSE
 CLOSEENT:
	MOVAL	-(SP),SP		; make room for parameter
					; to LIB$FREE_VM
	MOVL	(AP),R2			; R2 = number of arguments
	ADDL3	AP,#4,R3		; R3 = address of 1st FSB address
   10$:					; loop until all files closed
	MOVL	(R3),R4			; R4 = address of FSB
	ADDL3	R4,#FSB$C_BLN,R5	; R5 = address of RAB
	ADDL3	#RAB$C_BLN,R5,R6	; R6 = address of FAB
	BBC	#FSB$V_OPEN, FSB$L_STA(R4),120$
					; branch if file already closed
	BBS	#0,R7,15$		; branch if call from CLOSEINOUT
	BBS	#FSB$V_OUTPUT,FSB$L_STA(R4),130$
					; branch if file OUTPUT or INPUT
	BBS	#FSB$V_INPUT,FSB$L_STA(R4),130$
 15$:
	BBS	#FSB$V_GET,FSB$L_STA(R4),110$
					; branch if get access
	BBC	#FSB$V_TXT,FSB$L_STA(R4),110$
					; branch if not textfile
	CMPL	RAB$L_RBF(R5),(R4)
	BEQL	110$
	PUSHL	R4
	CALLS	#1,PAS$WRITELN
 110$:
	BBC	#FSB$V_DELZ,FSB$L_STA(R4),105$
					; branch if not delete
	TSTL	FSB$L_CNT(R4)		; check line count
	BNEQ	105$
	BISL2	#FAB$M_DLT,FAB$L_FOP(R6); set delete flag
 105$:
	$CLOSE	FAB=R6			; close the file
	BLBS	R0,115$			; branch if ok
        CMPL    R0,#RMS$_MKD		; check for no deletion error
        BNEQ    135$			; branch if that's not it
 115$:
	BLBS	R7,117$			; branch if file INPUT or OUTPUT

	MOVZBL	FAB$B_FNS(R6),(SP)	; deallocate file name string
	PUSHAL	FAB$L_FNA(R6)
	PUSHAL	4(SP)
	CALLS	#2,G^LIB$FREE_VM	; ignore errors

	MOVZWL	RAB$W_USZ(R5),(SP)	; deallocate file buffer
	PUSHAL	RAB$L_UBF(R5)
	PUSHAL	4(SP)
	CALLS	#2,G^LIB$FREE_VM	; ignore errors
 117$:
	BICL2	#FSB$M_OPEN,FSB$L_STA(R4)
					; clear OPEN flag
 120$:
	ADDL2	#4,R3
	DECL	R2			; loop if more files
	BLEQ	125$
	BRW	10$
 125$:	RET
;
;
; Error: file OUTPUT cannot be closed
;
 130$:
	MOVZWL	#^X83E4,-(SP)		; PASCAL error code
	MOVZBL	FAB$B_FNS(R6),-(SP)	; file name string length
	PUSHL	FAB$L_FNA(R6)		; file name
	CALLS	#3,PAS$IOERROR
 135$:
	PUSHL	R0
	MOVZWL	#^X83B4,-(SP)
	MOVZBL	FAB$B_FNS(R6),-(SP)
	PUSHL	FAB$L_FNA(R6)
	CALLS	#4,PAS$IOERROR
;
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*      PAS$EOF     *
;	*                  *
;	********************
;
; Checks for end-of-file. If the RDLN bit is set the next record
; is retrieved.
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$EOF,^MR6		; end of file
	MOVL	FSB_DISP(AP),R6		; R6 = address of variable
	BBC	#FSB$V_RDLN,FSB$L_STA(R6),10$
					; need next record?
	CALLG	(AP),PAS$ACTUALGET	; yes
   10$:
	MOVL	#PAS$C_FALSE,R0		; set function return to FALSE
	BBC	#FSB$V_EOF,FSB$L_STA(R6),99$
					; branch if not EOF
	MOVL	#PAS$C_TRUE,R0		; set function return to TRUE
  99$:
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*     PAS$EOLN     *
;	*                  *
;	********************
;
; Checks for end-of-line. If the RDLN bit is set the next record 
; is retrieved.
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$EOLN,^MR6		; end of line
	MOVL	FSB_DISP(AP),R6		; R6 = address of pointer
	BBC	#FSB$V_RDLN,FSB$L_STA(R6),110$
					; need next record
	CALLG	(AP),PAS$ACTUALGET
  110$:
	MOVL	#PAS$C_FALSE,R0		; set function return to FALSE
	BBC	#FSB$V_EOLN,FSB$L_STA(R6),199$
					; branch if not eoln
	MOVL	#PAS$C_TRUE,R0		; set function return to TRUE
 199$:
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*  PAS$ACTUALGET   *
;	*                  *
;	********************
;
; Does the actual file access for text and binary files. PAS$ACTUALGET
; is called from the compiler if the RDLN flag is set, from other
; input routines in the I-O interface, or from PAS$EOF and PAS$EOLN
; if the RDLN flag is set. The access codes should be checked before
; calling this procedure. The RDLN flag being set implies read access
; is permitted.
;
; Argument offsets
;
;	AP				; number of arguments
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$ACTUALGET,^M<R6,R7,R8>
	MOVL	FSB_DISP(AP),R6		; R6 = address of FSB
	BICL2	#FSB$M_RDLN,FSB$L_STA(R6)
					; clear RDLN flag
	ADDL3	R6,#FSB$C_BLN,R7	; R7 = address of RAB
	BBC	#FSB$V_PRMT,FSB$L_STA(R6),10$
					; branch if not prompting
;
; Prompting is performed on INPUT/OUTPUT.  Check if any characters in
; OUTPUT buffer.
;
	MOVL	FSB$L_PFSB(R6),R8	; R8 = OUTPUT FSB address
	CMPL	(R8),FSB$C_BLN+RAB$L_RBF(R8)
					; any characters in buffer?
	BEQL	10$			; no--continue
;
; Characters are present in OUTPUT buffer.  Write these characters as a
; prompt for the current GET.
;
	BISL2	#FSB$M_WRITPRMT,FSB$L_STA(R8)		; set flag to call writeln
	BBS	#FSB$V_PROMPT,FSB$L_STA(R8),1$		; was a prompt emmitted
							; on the previous line?
	MOVW	#PRN_LF,@FSB$C_BLN+RAB$L_RHB(R8)	; no, use <LF> <prompt>
	BRB	2$
1$:	MOVW	#PRN_NULL,@FSB$C_BLN+RAB$L_RHB(R8)
					; set null carriage control
2$:	PUSHL	R8			; argument is OUTPUT FSB address
	CALLS	#1,PAS$WRITELN		; write the prompt line
	MOVW	#PRN_CRLF,@FSB$C_BLN+RAB$L_RHB(R8)
					; reset normal carriage control
	BICL2	#FSB$M_WRITPRMT,FSB$L_STA(R8)	; clear the flag which affects
						; carriage control of a call to WRITELN
	BISL2	#FSB$M_PROMPT,FSB$L_STA(R8)	; set the prompt flag
10$:	$GET	RAB=R7
	CMPL	R0,#RMS$_PENDING
	BNEQ	105$
	$WAIT	RAB=R7
105$:
	CMPL	R0,#RMS$_EOF		; check for eof
	BNEQ	110$
	BISL2	#FSB$M_EOF,FSB$L_STA(R6); set EOF flag
	BRB 	111$
110$:
	BLBS	R0,111$			; branch if ok
	PUSHL	R0
	MOVZBL	<RAB$C_BLN+FAB$B_FNS>(R7),-(SP)
	PUSHL	<RAB$C_BLN+FAB$L_FNA>(R7)
	CALLS	#3,PAS$IOERROR
111$:
	MOVL	RAB$L_UBF(R7),(R6)	; set pointer to first
	BBC	#FSB$V_TXT,FSB$L_STA(R6),199$
					; done if binary file
;
; Set textfile parameters
;
	CVTWL	RAB$W_RSZ(R7),R1
	ADDL3	(R6),R1,FSB$L_LST(R6)	; set last to last+1
	MOVB	#SPACE,@FSB$L_LST(R6)	; store EOLN blank
	TSTL	R1			; check for EOLN
	BNEQ	199$
	BISL2	#FSB$M_EOLN,FSB$L_STA(R6)
					; set EOLN flag
  199$:
	BISL2	#FSB$M_ACTIN,FSB$L_STA(R6)
					; set actual input flag
	RET
;
;
	.PSECT	_PAS$CODE,	PIC,EXE,SHR,NOWRT
;
;	********************
;	*                  *
;	*   PAS$WRITELN    *
;	*                  *
;	********************
;
; Writes a record (line) to the file.
;
; Argument offsets
;
;	AP				; number of arguments (1)
	FSB_DISP = 04			; FSB address
;
	.ENTRY	PAS$WRITELN,^M<R2,R3>
	CALLG	(AP),PAS$WRITEOK
	MOVL	FSB_DISP(AP),R2		; R2 = address of FSB
	ADDL3	R2,#FSB$C_BLN,R3	; R3 = address of RAB
	SUBL3	RAB$L_RBF(R3),(R2),R0
	CVTLW	R0,RAB$W_RSZ(R3)
	BBS	#FSB$V_WRITPRMT,FSB$L_STA(R2),10$	; do a WRITELN: <text> <CR>
							; if following a prompt

	BBC	#FSB$V_PROMPT,FSB$L_STA(R2),10$
	MOVW	#PRN_CR,@FSB$C_BLN+RAB$L_RHB(R2)
	$PUT	RAB=R3
	BICL2	#RAB$M_TPT,RAB$L_ROP(R3)		; clear TPT bit
	BLBC	R0,910$
	MOVW	#PRN_CRLF,@FSB$C_BLN+RAB$L_RHB(R2)
	BRB	105$
10$:	$PUT	RAB=R3
	BICL2	#RAB$M_TPT,RAB$L_ROP(R3)		; clear TPT bit
	BLBC	R0,910$			; branch if error
105$:
	BICL2	#FSB$M_PROMPT,FSB$L_STA(R2)	; clear the prompt flag
	INCL	FSB$L_CNT(R2)		; increment line count
	CMPL	FSB$L_CNT(R2),FSB$L_LIM(R2)
					; check linelimit
	BGTR	920$			; abort if exceeded
	MOVL	RAB$L_RBF(R3),(R2)	; set pointer to first element
	RET
;
; Write error
;
910$:
	PUSHL	R0
	MOVZBL	<RAB$C_BLN+FAB$B_FNS>(R3),-(SP)
	PUSHL	<RAB$C_BLN+FAB$L_FNA>(R3)
	CALLS	#3,PAS$IOERROR
;
; Error, linelimit exceeded
;
920$:
	PUSHL	FSB$L_LIM(R2)		; pass linelimit
	MOVZWL	#^X8374,-(SP)
	MOVZBL	<RAB$C_BLN+FAB$B_FNS>(R3),-(SP)
	PUSHL	<RAB$C_BLN+FAB$L_FNA>(R3)
	CALLS	#4,PAS$IOERROR
;
;
;
	.END
