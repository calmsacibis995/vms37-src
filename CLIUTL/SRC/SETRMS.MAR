	.TITLE	SETRMS - SET RMS DEFAULT VALUES FOR PROCESS OR SYSTEM
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SET PRIVILEGED IMAGE
;
; ABSTRACT:
;
;	THIS IMAGE IMPLEMENTS THE SET RMS_DEFAULTS COMMAND
;
; ENVIRONMENT:
;
;	THIS IMAGE RUNS IN USER MODE BUT REQUIRES THE PRIVILEGE TO
;	CHANGE MODE TO KERNEL IN ORDER TO ALTER THE SYSTEM DEFAULTS
;
; AUTHOR: HJ, CREATION DATE: APRIL-18-1978
;
; MODIFICATION HISTORY:
;
;	V03-005 LJA0003		Laurie Anderson		7-January-1982
;		Eliminate /COMPATIBILITY qualifier and change /STRUCTURE
;		to /PROLOGUE
;
;	V03-004	DJD0002		Darrell Duffy		26-August-1981
;		Fix problems in /compatibility code.
;
;	V03-003	DJD0001		Darrell Duffy		24-August-1981
;		Add /COMPATIBILITY /STRUCTURE and /EXTEND_QUANTITY.
;
;	V03-002	GRR3002		G. R. Robert		10-Jun-1981
;		Made specification of at least one of /BUFFER
;		or /BLOCK required.
;
;	V03-001	GRR001		G. R. Robert		01-Jun-1981
;		Fixed /SEQUENTIAL
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CLIDEF				;CLI DEFINITIONS
	$CLIMSGDEF			; CLI messages
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
	$SHRDEF				;SHARED MESSAGE DEINITIONS


;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	STRM$V_HASH	=2		;DEFINE BIT POSITIONS FOR CLI
	STRM$V_INDEX	=3		;TO INDICATE IF OPTION USED
	STRM$V_REL	=4
	STRM$V_SEQ	=5
	STRM$V_DISK	=6
	STRM$V_MAGTAPE	=7
	STRM$V_UNIT	=8
	STRM$V_SYSTEM	=9
	STRM$V_BLKVAL	=10
	STRM$V_BUFVAL	=11

	STRM$M_HASH	=1@2		;DEFINE BIT MASKS FOR CLI
	STRM$M_INDEX	=1@3		;TO INDICATE IF OPTION USED
	STRM$M_REL	=1@4
	STRM$M_SEQ	=1@5
	STRM$M_DISK	=1@6
	STRM$M_MAGTAPE	=1@7
	STRM$M_UNIT	=1@8
	STRM$M_SYSTEM	=1@9
	STRM$M_BLKVAL	=1@10
	STRM$M_BUFVAL	=1@11

;
; OWN STORAGE:
;
	.PSECT	SET$RWDATA	LONG,RD,WRT,NOEXE

;
; DEFINE THE CALL BACK DATA STRUCTURES
;
NUMVAL:
	$CLIREQDESC	-		;
		RQTYPE=CLI$K_NUMERVAL	;CONVERT A NUMBER
STRVAL:
	$CLIREQDESC	-		;
		RQTYPE=CLI$K_ASCIIVAL	; Return a string

INP_ARGLIST:
	$ARGLST	3,-			;ARGLIST FOR OPTION PROCESSING CALLS
		INP_DESC,-		;POINTER TO REQUEST DESCRIPTOR
		SET$A_CLIWORK,-		;POINTER TO COMMON WORK AREA
		BITMAP			;ADDRESS OF CLI BIT MAP

INP_DESC:
	$CLIREQDESC	-
		RQTYPE=CLI$K_GETQUAL,-	;GET QUALIFIERS
		QUALST=INP_QUAL		;QUALIFIER LIST
INP_QUAL:
	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_BLOC,-;/BLOCKS=N
		TRUACT=BLOCKS,-
		SETLST=STRM$V_BLKVAL

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_BUFF,-;/BUFFERS=N
		TRUACT=BUFFERS,-
		SETLST=STRM$V_BUFVAL

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_HASH,-;/HASHED
		SETLST=STRM$V_HASH

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_INDE,-;/INDEXED
		SETLST=STRM$V_INDEX

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_RELA,-;/RELATIVE
		SETLST=STRM$V_REL

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_SEQU,-;/SEQUENTIAL
		SETLST=<<STRM$V_SEQ,-
			STRM$V_DISK,-
			STRM$V_MAGTAPE,-
			STRM$V_UNIT>>

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_DISK,-;/DISK
		SETLST=STRM$V_DISK

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_MAGT,-;/MAGTAPE
		SETLST=STRM$V_MAGTAPE

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_UNIT,-;/UNIT_RECORD
		SETLST=STRM$V_UNIT

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_SYST,-;/SYSTEM
		SETLST=STRM$V_SYSTEM

	$CLIQUALDEF	-
		QDCODE=CLI$K_STRM_PROL,-
		TRUACT=SET_PROLOGUE

	$CLIQUALDEF	-
		QDCODE = CLI$K_STRM_EXTE,-
		TRUACT=SET_EXTEND

	$CLIQUALDEF	END_LIST	;END OF QUALIFIER LIST

BITMAP:	.WORD	0			; BIT LIST
BLKVAL:	.BYTE	0			;USED TO HOLD /BLOCK= VALUE
BUFVAL:	.BYTE	0			;USED TO HOLD /BUFFER= VALUE
KEYVAL:	.LONG	0			; Value for a keyword

	.SBTTL	SET RMS_DEFAULTS
;++
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;
;	VIA SET RMS COMMAND
;
; INPUT PARAMETERS:
;
;	CLI$A_UTILSERV(AP) = CALL BACK ADDRESS FOR RESULT PARSER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	CHANGES TO THE DEFAULT VALUES IN THE PROCESS IO REGION
;	OR IN THE SYSTEM AREA IF /SYSTEM
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NOCMKRNL  (IF USER DOESN'T HAVE CHMK PRIV AND USES /SYSTEM)
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.SHOW BINARY
	.PSECT	SET$CODE BYTE,RD,NOWRT,EXE
	.ENTRY	SET$RMS,^M<R2,R11>

	.ENABL	LSB

	CALLG	W^INP_ARGLIST,-		;CALL BACK TO PROCESS QUALIFIERS
		@CLI$A_UTILSERV(AP)
	MOVL	#SS$_NORMAL, R0		; Assume success
	MOVW	W^BITMAP,R2		;GET THE BITMAP, WE REFERENCE IT ALOT
	BITL	#^CSTRM$M_SYSTEM, R2	; Check all but the system bit
	BEQL	10$			; If nothing to do, then ignore
	MOVL	#SET$_BUFBLKREQ,R0	;ASSUME MISSING QUALIFIER ERROR
	BITW	#STRM$M_BLKVAL-		;DID USER SPECIFY /BLOCKS_COUNT=
		!STRM$M_BUFVAL,R2	; OR /BUFFER_COUNT=?
	BEQL	10$			;BRANCH IF NEITHER SPECIFIED
	BITW	#STRM$M_MAGTAPE-	;TEST FOR /MAGTAPE
		!STRM$M_DISK-		; OR /DISK
		!STRM$M_UNIT-		; OR /UNIT_RECORD
		!STRM$M_INDEX-		; OR /INDEX OR
		!STRM$M_REL,R2		; OR /RELATIVE
	BNEQ	5$			;BYPASS DEFAULTS IF PRESENT
	BISW	#STRM$M_MAGTAPE!-	;DEFAULT MAGTAPE AND
		STRM$M_DISK!-		; DISK AND
		STRM$M_UNIT,R2		; UNIT RECORD EQUIPMENT
5$:	BBS	#STRM$V_SYSTEM,R2,90$	;BRANCH IF CHANGE SYSTEM DEFAULTS
	$CMKRNL_S B^SETPIO		;SET THE APPROPRIATE FIELDS
10$:	$EXIT_S	R0			;EXIT

SETPIO:	.WORD	0			;NO REG SAVE
	BBC	#STRM$V_BLKVAL,R2,20$	;BRANCH IF NO /BLOCK= VALUE GIVEN
	MOVB	W^BLKVAL,PIO$GB_DFMBC	;SET THE NEW MULTI BLOCK COUNT VALUE
20$:	BBC	#STRM$V_BUFVAL,R2,80$	;BRANCH IF NO /BUFFER = VALUE GIVEN
	MOVB	W^BUFVAL,R0		;GET THE NEW MULTI BUFFER COUNT VALUE
	BBC	#STRM$V_DISK,R2,30$	;BRANCH IF DON'T CHANGE SEQ DISK
	MOVB	R0,PIO$GB_DFMBFSDK	;SET NEW VALUE
30$:	BBC	#STRM$V_MAGTAPE,R2,40$	;BRANCH IF DON'T CHANGE SEQ MAGTAPE
	MOVB	R0,PIO$GB_DFMBFSMT	;SET NEW VALUE
40$:	BBC	#STRM$V_UNIT,R2,50$	;BRANCH IF DON'T CHANGE SEQ UNITRECORD
	MOVB	R0,PIO$GB_DFMBFSUR	;SET NEW VALUE
50$:	BBC	#STRM$V_HASH,R2,60$	;BRANCH IF DON'T CHANGE HASHED
	MOVB	R0,PIO$GB_DFMBFHSH	;SET NEW VALUE
60$:	BBC	#STRM$V_INDEX,R2,70$	;BRANCH IF DON'T CHANGE INDEXED
	MOVB	R0,PIO$GB_DFMBFIDX	;SET NEW VALUE
70$:	BBC	#STRM$V_REL,R2,80$	;BRANCH IF DON'T CHANGE RELATIVE
	MOVB	R0,PIO$GB_DFMBFREL	;SET NEW VALUE
80$:	MOVZWL	S^#SS$_NORMAL,R0	;SET SUCCESS
	RET				;RETURN

90$:	MOVZWL	#SS$_NOCMKRNL,R0	;ASSUME PRIVLEDGE VIOLATION
	BBC	#PRV$V_CMKRNL,-		;BRANCH IF PROCESS DOESN'T
		CTL$GQ_PROCPRIV,10$	;HAVE CMKRNL PRIVLEDGE
	$CMKRNL_S B^SETSYS		;SET APPROPRIATE FIELDS IN SYSTEM
	BRW	10$			;EXIT

SETSYS:	.WORD	0			;NO REG SAVE
	BBC	#STRM$V_BLKVAL,R2,100$	;BRANCH IF NO /BLOCK= VALUE GIVEN
	MOVB	W^BLKVAL,SYS$GB_DFMBC	;SET THE NEW MULTI BLOCK COUNT VALUE
100$:	BBC	#STRM$V_BUFVAL,R2,160$	;BRANCH IF NO /BUFFER = VALUE GIVEN
	MOVB	W^BUFVAL,R0		;GET THE NEW MULTI BUFFER COUNT VALUE
	BBC	#STRM$V_DISK,R2,110$	;BRANCH IF DON'T CHANGE SEQ DISK
	MOVB	R0,SYS$GB_DFMBFSDK	;SET NEW VALUE
110$:	BBC	#STRM$V_MAGTAPE,R2,120$	;BRANCH IF DON'T CHANGE SEQ MAGTAPE
	MOVB	R0,SYS$GB_DFMBFSMT	;SET NEW VALUE
120$:	BBC	#STRM$V_UNIT,R2,130$	;BRANCH IF DON'T CHANGE SEQ UNITRECORD
	MOVB	R0,SYS$GB_DFMBFSUR	;SET NEW VALUE
130$:	BBC	#STRM$V_HASH,R2,140$	;BRANCH IF DON'T CHANGE HASHED
	MOVB	R0,SYS$GB_DFMBFHSH	;SET NEW VALUE
140$:	BBC	#STRM$V_INDEX,R2,150$	;BRANCH IF DON'T CHANGE INDEXED
	MOVB	R0,SYS$GB_DFMBFIDX	;SET NEW VALUE
150$:	BBC	#STRM$V_REL,R2,160$	;BRANCH IF DON'T CHANGE RELATIVE
	MOVB	R0,SYS$GB_DFMBFREL	;SET NEW VALUE
160$:	MOVZWL	S^#SS$_NORMAL,R0	;SET SUCCESS
	RET				;RETURN


BLOCKS:	.WORD	^M<R2>			;ENTRY MASK
	BSBB	CNVRTVAL		;GET THE VALUE
	TSTL	R2			;VALUE IS IN R2
	BLSS	170$			;BRANCH IF NEGATIVE
	CMPL	#127,R2			;CHECK AGAINST MAXIMUM
	BLSS	170$			;BRANCH IF TOO BIG
	MOVB	R2,W^BLKVAL		;SAVE FOR LATER
	RET				;CONTINUE

BUFFERS:.WORD	^M<R2>			;ENTRY MASK
	BSBB	CNVRTVAL		;GET THE VALUE
	CMPL	R2,#-127		;CHECK AGAINST MINIMUM
	BLSS	170$			;BRANCH IF TOO SMALL
	CMPL	#127,R2			;CHECK AGAINST MAXIMUM
	BLSS	170$			;BRANCH IF TOO BIG
	MOVB	R2,W^BUFVAL		;SAVE FOR LATER
	RET				;CONTINUE

CNVRTVAL:
	MOVL	4(AP),-(SP)		;STORE ADDRESS OF QUALIFIER DESC BLOCK
	PUSHAB	W^SET$A_CLIWORK		;STORE ADDRESS OF WORK AREA
	PUSHAB	W^NUMVAL		;STORE ADDRESS OF VALUE REQ DESC
	CALLS	#3,@CLI$A_UTILSERV(AP)	;CONVERT NUMERIC VALUE
	BLBC	R0,170$			;BRANCH IF NOT NUMERIC
	MOVL	W^CLI$L_RQVALU+NUMVAL,R2 ;GET VALUE OF PARAMETER
	RSB				;RETURN WITH VALUE IN R2

170$:	MOVZWL	#SHR$_VALERR,R0		;SET ERROR RETURN
	BRW	10$			;AND EXIT


;
;	Action routines for /PROLOGUE
;

.DISABLE LOCAL_BLOCK

SET_PROLOGUE:
	.WORD	^M<R2>
	BSBB	CNVRTVAL		; Obtain the numeric value of qual
	TSTL	R2			; Trying to cancel the prologue?
	BEQL	10$			; Zero is ok too
	CMPL	R2, #2			; Check the range
	BLSSU	30$			;
	CMPL	R2, #3			; for either 2 or 3
	BGTRU	30$			;
10$:	BBC	#STRM$V_SYSTEM,-	; Trying to set system stuff?
		W^BITMAP, 20$		; 
	MOVZWL	#SS$_NOCMKRNL,R0	; Assume no privlege
	BBC	#PRV$V_CMKRNL,-		; Check for change mode kernel
		G^CTL$GQ_PROCPRIV, -	; in the process
		40$
20$:	PUSHL	R2			; Now set the process or system cell
	PUSHL	#1			; by first building the arglist
	MOVL	SP, R0			; Pointing to the arglist
	$CMKRNL_S -			; and calling the kernel mode routine
		B^SET_KSTRUCT, (R0)	; to fix the cell
	RET

30$:	BRW	SET_ERROR
40$:	BRW	SET_EXIT

SET_KSTRUCT:				; KERNEL MODE ROUTINE
	.WORD	0
	BBS	#STRM$V_SYSTEM, -	; Is this system or process
		W^BITMAP, 10$
	MOVB	4(AP), G^PIO$GB_RMSPROLOG	; Process cell
	RET
10$:	MOVB	4(AP), G^SYS$GB_RMSPROLOG	; System cell
	RET


;
;	Action routines for /EXTEND_QUANTITY
;


SET_EXTEND:
	.WORD	^M<R2>
	BSBW	CNVRTVAL		; Obtain the numeric value of qual
	CMPL	R2, #65535		; Check the range
	BGTRU	30$			;
10$:	BBC	#STRM$V_SYSTEM,-	; Trying to set system stuff?
		W^BITMAP, 20$		; 
	MOVZWL	#SS$_NOCMKRNL,R0	; Assume no privlege
	BBC	#PRV$V_CMKRNL,-		; Check for change mode kernel
		G^CTL$GQ_PROCPRIV, -	; in the process
		40$
20$:	PUSHL	R2			; Now set the process or system cell
	PUSHL	#1			; by first building the arglist
	MOVL	SP, R0			; Pointing to the arglist
	$CMKRNL_S -			; and calling the kernel mode routine
		B^SET_KEXTEND, (R0)	; to fix the cell
	RET

30$:	BRW	SET_ERROR
40$:	BRW	SET_EXIT

SET_KEXTEND:				; KERNEL MODE ROUTINE
	.WORD	0
	BBS	#STRM$V_SYSTEM, -	; Is this system or process
		W^BITMAP, 10$
	MOVW	4(AP), -		; Process cell
		G^PIO$GW_RMSEXTEND
	RET
10$:	MOVW	4(AP), -		; System cell
		G^SYS$GW_RMSEXTEND
	RET

;
;	Error exits from here
;

SET_LOOKERR:				; Map errors from lib routine
	CMPL	R0, #LIB$_AMBKEY	;
	BNEQ	10$			;
	MOVL	#CLI$_ABKEYW, R0	; Ambiguous keyword
	BRB	SET_EXIT		;
10$:	CMPL	R0, #LIB$_UNRKEY	; Unrecognized keyword
	BNEQ	SET_EXIT		; Punt anything else
	MOVL	#CLI$_INVKEY, R0	; Map to cli error
	BRB	SET_EXIT		;

SET_ERROR:
	MOVL	#SHR$_VALERR, R0	; Something wrong with a value
SET_EXIT:
	$EXIT_S	R0			; Error code in r0



	.END
