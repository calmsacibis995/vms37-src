	.TITLE	RTPAD - REMOTE TERMINAL PROGRAM
	.IDENT	'V03-004'
	.PSECT	RTPAD,NOWRT

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY: REMOTE TERMINAL SUPPORT
;
; ABSTRACT:
;
;	THIS PROGRAM RUNS ON A LOCAL NODE TO ALLOW A TERMINAL TO APPEAR TO
;	BE LOCALLY CONNECTED TO A REMOTE NODE.
;
;
; ENVIRONMENT: VMS - USER MODE
;		
;
; AUTHOR: W M CARDOZA,	 CREATION DATE: 20-AUG-79
;
; MODIFIED BY:
;
;	V03-004	WMC0064		Wayne Cardoza		9-Apr-1982
;		Don't try to disable ^T under MCR.
;
;	V03-003 WMC0063		Wayne Cardoza		1-Apr-1982
;		Zero the buffer before a SENSE.
;
;	V03-002 WMC0062		Wayne Cardoza		18-Mar-1982
;		Add TERMCHAR in DIB format back for RSX, etc.
;
;	V03-001 WMC0061		Wayne Cardoza		15-Mar-1982
;		Send extended characteristics in configuration message.
;
;	V03-013 WMC0045		Wayne Cardoza		26-Feb-1982
;		Add flad to indicate a legitimate $WAKE
;
;	V03-012	WMC0040		Wayne Cardoza		11-Feb-1982
;		Give immediate error message on link disconnect.
;
;	V03-011	MHB0079		Mark H. Bramhall	25-Jan-1982
;		Fix out of band handling for RSTS/E & TOPS-20 protocols.
;
;	V03-010 WMC0033		Wayne Cardoza		13-Jan-1982
;		Clarify the ^Y message.
;
;	V03-009	WMC0023		Wayne Cardoza		21-Dec-1981
;		Also disable ^T out of band AST's.
;		Remove an extra CR-LF on broadcasts.
;
;	V03-008 WMC0022		Wayne Cardoza		8-Dec-1981
;		New mechanism to disable ^Y out of band AST's.
;
;	V03-007	WMC0009		Wayne Cardoza		10-Nov-1981
;		Support for out of band AST's.
;
;	V03-006	WMC0008		Wayne Cardoza		19-Oct-1981
;		Assorted changes for V3 terminal driver compatibility.
;
;	V03-005 WMC0004		Wayne M. Cardoza
;		New queuing mechanism while link write in progress to prevent
;		exceeding quota.
;
;	V03-004 WMC0003		Wayne M. Cardoza	26-Jan-1981
;		Before exiting, cancel a few I/O's to free up some BUFIO quota.
;
;	V03-003	MHB0063		Mark H. Bramhall	23-Sep-1980
;		Accept FIRSTCMD's if invoked via foreign command mechanism.
;		Remove the temporary TOPS-20 code.
;		Don't to any purge type ahead on first VMS read.
;
;	V03-001	WMC0001		Wayne M. Cardoza	23-June-1980
;		fix printing of PASSTHRU error messages,
;		better error checking on link errors
;		check for exceeding quotas
;		add printing of link mailbox codes
;		change queuing so only one link write at a time
;		truncate sensemode response to proper length
;	V03-002	WMC0002		Wayne M. Cardoza	16-Sept-1980
;		fix sensemode again
;
;**
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; DEFAULT ADDRESSING MODE
;
	.DEFAULT DISPLACEMENT WORD
;
; INCLUDE FILES:
;
	$CLIDEF		;CLI CALL BACK CONTROL
	$DIBDEF		;DIB OFFSETS
	$DSCDEF		;DESCRIPTOR DEFINITIONS
	$DVIDEF		;GETDVI DEFINITIONS
	$IODEF		;I/O OP CODES & MODIFIERS
	$RDPDEF		;REMOTE DEVICE PROTOCOL
;
; MACROS:
;
	.MACRO	ONERROR ACTION,?L
	BLBS	R0,L
	ACTION
	L:
	.ENDM	ONERROR
;
	.MACRO	QUIT	STATUS=R0
	MOVL	STATUS,RETSTATUS
	$SETAST_S	ENBFLG = #0
	INCB	WAKEFLAG
	$WAKE_S
	RET
	.ENDM	QUIT
;
	.MACRO	IF_NO_QUOTA ACTION,?L
	CMPW	R0,#SS$_EXQUOTA
	BNEQ	L
	ACTION
L:
	.ENDM	IF_NO_QUOTA
;
; EQUATED SYMBOLS:
;
	MAXMSG	= 1050	;MAX LINK MESSAGE SIZE
;
;
;	AST CONTROL BLOCK
;
	AB_TYPE	= 0		;TYPE
	AB_IOSB	= AB_TYPE + 4	;I/O STATUS BLOCK
	AB_BUF	= AB_IOSB + 8	;DATA BUFFER
;
;
;	OP CODES
;
	OP_READ	= 1
	OP_WRITE = 2
	OP_SETMODE = 3
	OP_SENSEMODE = 4
	OP_CANCEL = 5
	OP_BRDCST = 6
	OP_PRMPT = ^X100
;
; OWN STORAGE:
;

;
;
	.PAGE
	.SBTTL RTPAD - MAIN ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	MAIN ROUTINE
;
; CALLING SEQUENCE:
;
;	RUN FROM A TERMINAL
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	RETURNED IF A SYSTEM SERVICE HAS AN UNEXPECTED ERROR
;
; SIDE EFFECTS:
;
;	DECNET LINK SET UP WITH A REMOTE NODE
;
;--
RTPAD:
	.WORD	0
	BSBW	INIT		;INIT THIS PROGRAM & SET UP LOGICAL LINK
1$:	$HIBER_S		;PROCEED ASYNCHRONOUS FROM NOW ON
	TSTB	WAKEFLAG
	BEQL	1$		;SPURIOUS $WAKE
	$SETAST_S	ENBFLG = #0
	$CANCEL_S	CHAN = READCHAN
	$CANCEL_S	CHAN = TERMMBXCHAN
	$CANCEL_S	CHAN = MAILCHAN
	$CANCEL_S	CHAN = LINKCHAN
	$PUTMSG_S MSGVEC = EXITMSG
	$QIO_S	CHAN = CNTRLCHAN -	;GET RID OF THE ^Y AST REQUEST
		FUNC = #IO$_SETMODE!IO$M_CTRLYAST
	CLRL	-(SP)
	PUSHAL	OLDCTRL		;REENABLE CLI OUT OF BAND CHARACTERS
	CALLS	#2,G^LIB$ENABLE_CTRL
	$SETRWM_S -			; Set resource wait mode
		WATFLG = OLDSETRWM	;  to whatever it was upon entry
	MOVL	RETSTATUS,R0	;GET SAVED STATUS
	RET			;QUIT
	.PAGE
	.SBTTL INIT - INITIALIZATION OF LINK, ETC.
;++
; FUNCTIONAL DESCRIPTION:
;
;	PERFORMS INITIALIZATION FUNCTIONS FOR RTPAD
;
; CALLING SEQUENCE:
;
;	JSB	INIT
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	CHANNEL NUMBERS, ETC.
;
; COMPLETION CODES:
;
;	WILL RETURN COMPLETION CODES OF SYSTEM SERVICES WITH UNEXPECTED ERRORS
;
; SIDE EFFECTS:
;
;	SETS UP DECNET LINK TO REMOTE NODE
;
;--

INIT:	$GETDVI_S -			; Get the device characteristics
		DEVNAM = TTYDESC, -	;  of the translated SYS$INPUT
		ITMLST = DVILIST
	ONERROR	RET			; Die if any error
	$GETDEV_S -			; RSX, ETC. WANTS THIS
		DEVNAM = TTYDESC,-
		PRIBUF = TERMCHAR
	ONERROR RET
	MOVB	DEVCLASS_TEMP,DEVCLASS	;PACK THE DATA CORRECTLY
	MOVB	DEVTYPE_TEMP,DEVTYPE
	MOVW	DEVBUFSIZ_TEMP,DEVBUFSIZ
	CMPB	DEVCLASS, #DC$_TERM ; Is it a terminal?
	BEQL	20$			; Yes
	$PUTMSG_S -			; Output an error message
		MSGVEC = NOTTERM	;  saying SYS$COMMAND not a terminal
	RET

20$:	PUSHAW	TERMMBXCHAN		; Arg #5 is the terminal mailbox chan
	PUSHAW	READCHAN		; Arg #4 is the terminal input channel
	PUSHAL	MBXSIZ			; Arg #3 is the buffer quota (def)
	PUSHAL	MBXSIZ			; Arg #2 is the maximum message (def)
	PUSHAQ	TTYDESC			; Arg #1 is the terminal device name
	CALLS	#5, G^LIB$ASN_WTH_MBX	; Assign a channel w/ a mailbox
	ONERROR	RET			; Die if any error
	$ASSIGN_S -			; Assign a channel
		DEVNAM = TTYDESC, -	;  to the terminal device
		CHAN = WRITECHAN	;  for terminal output
	ONERROR	RET			; Die if any error
	$ASSIGN_S -			; Assign a channel
		DEVNAM = TTYDESC, -	;  to the terminal device
		CHAN = CNTRLCHAN	;  for control (AST's)
	ONERROR	RET			; Die if any error
	$OPEN	FAB = SYSINFAB		;OPEN SYS$INPUT
	ONERROR	RET
	BITL	#DEV$M_TRM,SYSINFAB+FAB$L_DEV
	BEQL	25$			;NOT A TERMINAL
	$CLOSE	FAB = SYSINFAB		;WON'T USE IT
	BRB	27$
25$:	INCB	INDFLAG			;INDICATE INDIRECT FILE
	$CONNECT RAB = SYSINRAB
	ONERROR RET
27$:

; GET NODE NAME

	PUSHAB	REQ_COMMAND		; CLI request for the command line
	CALLS	#1, G^SYS$CLI		; Call back the CLI
	CMPB	REQ_COMMAND+CLI$B_RQSTAT, #CLI$K_VERB_SET ; Was it "SET HOST"?
	BNEQ	30$			; Nope
	PUSHAB	CLIWORK			; Stack address of CLI work area
	PUSHAB	REQ_INIT		; CLI request to init parameters
	CALLS	#2, G^SYS$CLI		; Call back the CLI
	PUSHAB	CLIBITMAP		; Stack address of CLI bit map
	PUSHAB	CLIWORK			; Stack address of CLI work area
	PUSHAB	REQ_PARAM		; CLI request for the input parameter
	CALLS	#3, G^SYS$CLI		; Call back the CLI
	BRB	40$			;  then go use the answer

30$:	MOVZWL	#100, REQ_PARAM+CLI$W_RQSIZE ; Limit response to 100 bytes
	MOVAB	NETDESC+8, REQ_PARAM+CLI$A_RQADDR ; Set its buffer address
	PUSHAW	REQ_PARAM+CLI$W_RQSIZE	; Arg #3 is the returned string size
	PUSHAQ	NAMEREQ			; Arg #2 is the prompt string desc
	PUSHAQ	REQ_PARAM+CLI$W_RQSIZE	; Arg #1 is the returned string desc
ASSUME	CLI$A_RQADDR EQ CLI$W_RQSIZE+4
	CALLS	#3, G^LIB$GET_FOREIGN	; Go get the command line as needed
	CMPL	R0, #RMS$_EOF		; A CTRL/Z typed?
	BNEQ	40$			; Nope
	MOVZWL	#SS$_NORMAL, R0		; Yep, change to a normal status
	RET				;  and quit

40$:	ONERROR	RET			; Die if any error
	MOVL	REQ_PARAM+CLI$A_RQADDR, R7 ; String address
	MOVZWL	REQ_PARAM+CLI$W_RQSIZE, R6 ; String size
	BEQL	30$			; Go try again on no length

	.IF	EQ	0	; ***** Start of first command handling *****

	MOVQ	R6, R0			; Copy the command line desc
	INCL	R0			; Pre-increment the count
	DECL	R1			;  and back up the character pointer
51$:	BSBB	71$			; A leading <SP>/<TAB>?
	BEQL	51$			; Yes, skip right over them...
52$:	CMPB	(R1), #^A/"/		; Entering a quoted string?
	BNEQ	59$			; Nope
53$:	BSBB	71$			; Get next in quoted string
	CMPB	(R1), #^A/"/		; Exiting the quoted string?
	BNEQ	53$			; Not yet...
59$:	BSBB	71$			; A <SP>/<TAB> for first command?
	BNEQ	52$			; Nope, continue scanning...
	SUBL	R0, R6			; Yep, remove first command from node
61$:	BSBB	71$			; A leading <SP><TAB>?
	BEQL	61$			; Yes, ignore them...
	MOVQ	R0, -(SP)		; Stack the source descriptor
	PUSHAQ	(SP)			; Arg #2 is the source desc
	PUSHAQ	FIRSTCMD		; Arg #1 is the destination desc
	CALLS	#2, G^STR$COPY_DX	; Go copy the first command string
	ADDL	#8, SP			; Clean up the stacked descriptor
	ONERROR	RET			; Die if any error
	BRB	79$			; Now go format the node name

71$:	INCL	R1			; Bump the character pointer
	DECL	R0			;  and decrement the count
	BEQL	78$			; Nothing more, no first command
	CMPB	(R1), #32		; Is the character a <SP>?
	BEQL	72$			; Yes, Z-bit = 1 (BEQL)
	CMPB	(R1), #9		; Is the character a <TAB>?
72$:	RSB				; Exit Z-bit = 1 (BEQL) if <SP>/<TAB>

78$:	ADDL	#4, SP			; Purge the return address
79$:

	.ENDC	; EQ	0	; ***** End of first command handling *****

	ADDL3	R6, R7, R0		; One past last character
80$:	CMPB	-(R0), #^A/:/		; A trailing colon?
	BNEQ	90$			; Nope
	SOBGTR	R6, 80$			; Yep, strip trailing colon(s)
	BRW	30$			; Go try again if no more length

90$:	ADDL	R6, NETDESC		; New total size
	SUBL	R6, NETDESC+4		;  and address
	MOVC	R6, (R7), @NETDESC+4	;   and node name

; SAVE THE NODE NAME DESCRIPTOR

	MOVL	R6,REMOTENODE
	MOVL	NETDESC+4,REMOTENODE+4

; CONNECT TO THE REMOTE NODE

	PUSHAB	180$			; Arg #6 is the message call routine
	PUSHAQ	FINALACS		; Arg #5 is the final ACS desc
	PUSHAQ	FINALPATH		; Arg #4 is the final path desc
	PUSHAW	MAILCHAN		; Arg #3 is the link mailbox channel
	PUSHAW	LINKCHAN		; Arg #2 is the link channel
	PUSHAQ	NETDESC			; Arg #1 is the "device" desc
	CALLS	#6, G^LIB$NET_CONNECT	; Do the remote node connection
	BLBC	R0, 100$		; Go die unless success completion
	$TRNLOG_S -			; Translate a logical name
		LOGNAM = SYS$NODE, -	;  from SYS$NODE
		RSLBUF = NODENAME, -	;  to the ending message
		RSLLEN = NODENAME	;  setting the correct length
	$QIOW_S -			; Read CONFIG message
		CHAN = LINKCHAN -	;  on the link channel
		FUNC = #IO$_READVBLK -	;  reading obviously
		IOSB = NAMEIOSB -	;  use an IOSB
		P1 = LINKMAIL+AB_BUF -	;  into this buffer
		P2 = #40		;  which is this long
	BLBS	R0, 110$		; Die unless success completion
100$:	MOVL	R0, NAMEIOSB		; Save the error status
	$PUTMSG_S -			; Output an error message
		MSGVEC = DECNETERR	;  saying some sort of link error
	MOVL	NAMEIOSB, R0		; Restore the error status
	RET				;  and die

110$:	MOVZWL	NAMEIOSB, R0		; Get the I/O completion code
	CMPW	R0, #SS$_DATAOVERUN	; Was it just a too long CONFIG?
	BEQL	120$			; Yep, ignore the fact
	BLBC	R0, 100$		; Go die unless success completion
120$:					; Continue

;		***** start temp old RSTS/E *****

	SUBW3	#1, NAMEIOSB+2, R0
	CMPW	R0, LINKMAIL+AB_BUF+1
	BNEQ	FOO_RSTS_1
	MOVL	#1@8!1, LINKMAIL+AB_BUF
	MOVL	#1@0@16!2, LINKMAIL+AB_BUF+4
FOO_RSTS_1 = .

;		***** end temp old RSTS/E *****

	CMPW	LINKMAIL+AB_BUF, #1@8!1	; Is it a CONFIG message for V1?
	BEQL	140$			; Yes
130$:	$PUTMSG_S -			; Output an error message
		MSGVEC = NOTVMS		;  saying protocol not supported
	RET

140$:	MOVB	LINKMAIL+AB_BUF+2,PROTO_ECO	;SAVE ECO LEVEL
	MOVAB	PROTOTBL-4, R2		; Get (biased) pointer to protocols
150$:	ADDL	#4, R2			; Index over address to bit number
	CMPL	R2, #ENDPROTO		; Are we out of protocols?
	BGEQU	130$			; Yep, protocol not supported
	BITW	LINKMAIL+AB_BUF+6, (R2)+ ; Not yet, does the bit match?
	BEQL	150$			; No match, loop for next protocol
	PUSHAL	OLDCTRL			; Arg #2 is returned out-of-band bits
	PUSHAL	OLDCTRL			; Arg #1 is out-of-band's to disable
	CALLS	#2, G^LIB$DISABLE_CTRL	; Get the currently enabled ones
	PUSHAL	OLDCTRL			; Arg #2 is returned out-of-band bits
	PUSHAL	OLDCTRL			; Arg #1 is out-of-band's to disable
	CALLS	#2, G^LIB$DISABLE_CTRL	; Go disable out-of-bound ASTs
	$SETRWM_S -			; Set resource wait mode
		WATFLG = #1		;  off so we never will hang
	CMPW	R0, #SS$_WASCLR		; Was it already off?
	BEQL	160$			; Nope, we'll turn it back on at exit
	INCL	OLDSETRWM		; Yep, we'll keep it off at exit
160$:	CALLS	#0, @(R2)		; Go start up selected protocol
	RSB				; Done

180$:	.WORD	^M<>			; Message call back routine
	MOVW	#<REM$_END>/65536, 6(AP) ; Replace facility code with ours
	$PUTMSG_S -			; Use $PUTMSG
		MSGVEC = (AP)		;  with the supplied message vector
	RET				;   then return
	.PAGE
	.SBTTL VMSRT - START UP VMS TO VMS PROTOCOL
;++
; FUNCTIONAL DESCRIPTION:
;
;	PERFORMS INITIALIZATION FUNCTIONS FOR VMS TO VMS PROTOCOL
;
; CALLING SEQUENCE:
;
;	CALLS	#0,VMSRT
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	CHANNEL NUMBERS, ETC.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	SETS UP MAILBOX READS FOR LINK, UNSOLICITED TERMINAL INPUT
;	ENABLES ^C, ^Y  AST'S
;
;--
;
VMSRT:	.WORD	^M<R2>
	TSTW	FINALACS
	BEQL	10$			;NO ACCESS CONTROL STRING
	$PUTMSG_S MSGVEC = ACSIGNORE	;WARN HIM WE ARE IGNORING IT
10$:	MOVAB	DEVNAM,R0		;ADDRESS OF COUNTED STRING
	MOVW	1(R0),TERMUNIT+2	;USE PART OF DEV NAME AS HIGH UNIT 	
	ADDL2	DEVNAMLEN,R0		;GET TO LAST CHAR (CONTROLLER)
	SUBB3	#^A/A/,(R0),R1		;GET CONTROLLER NUMBER
	MOVZBL	R1,R1
	ASHL	#4,R1,R1
	ADDW2	R1,TERMUNIT		;ADD CONTROLLER NUMBER TO UNIT
	TSTB	PROTO_ECO
	BEQL	20$			;LONG FORM OF CHARATERISTICS?
	ADDL	#4,CONFMSG		;YES
20$:	$QIOW_S	CHAN = LINKCHAN -	;SEND CONFIGURATION MESSAGE
		FUNC = #IO$_WRITEVBLK -
		IOSB = NAMEIOSB -
		P1 = CONFMSG+4 -
		P2 = CONFMSG
	ONERROR	QUIT			; 
	MOVZWL	NAMEIOSB, R0		; 
	ONERROR	QUIT			; 
	MOVW	TERMUNIT,INITMSG+4+RDP$W_UNIT
	$QIOW_S	CHAN = LINKCHAN	-	;TELL HIM WE ARE HERE
		FUNC = #IO$_WRITEVBLK -
		IOSB = NAMEIOSB -
		P1 = INITMSG+4 -
		P2 = INITMSG
	ONERROR	QUIT			; 
	MOVZWL	NAMEIOSB, R0		; 
	ONERROR	QUIT			; 
	$QIO_S	CHAN = MAILCHAN	-	;LINK MAILBOX READ
		FUNC = #IO$_READVBLK -
		IOSB = LINKMAIL+AB_IOSB -
		ASTADR = ASTHANDLER -
		ASTPRM = #LINKMAIL -
		P1 = LINKMAIL+AB_BUF -
		P2 = #40
	ONERROR	QUIT			; 
	$QIO_S	CHAN = TERMMBXCHAN -	;SET UP UNSOLICITED DATA MBX READ
		FUNC = #IO$_READVBLK -
		IOSB = UNSDAT+AB_IOSB -
		ASTADR = ASTHANDLER -
		ASTPRM = #UNSDAT -
		P1 = UNSDAT+AB_BUF+RDP$K_HEADERLEN+2 -
		P2 = #MAXMSG
	ONERROR	QUIT			; 
	$QIO_S	CHAN = CNTRLCHAN -		;WE WILL ALWAYS HANDLE ^Y
		FUNC = #IO$_SETMODE!IO$M_CTRLYAST -
		P1 = CNTRLC -
		P2 = #IO$M_CTRLYAST
	BLBC	R0, 99$			;NO DISABLE IF CAN'T GET IT
	$ASSIGN_S -			;CHANNEL FOR INCLUDE OUT OF BAND AST'S
		DEVNAM = TTYDESC, -
		CHAN = OUTBANDINC
	$ASSIGN_S -			;CHANNEL FOR EXCLUDE OUT OF BAND AST'S
		DEVNAM = TTYDESC, -
		CHAN = OUTBANDEXC
99$:	BSBW	GETBUF		;GET A BUFFER FOR READING LINK
	MOVAB	LINKRECV,(R0)	;INSERT STATE
	$QIO_S	CHAN = LINKCHAN -
		FUNC = #IO$_READVBLK -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AB_BUF(R0) -
		P2 = #MAXMSG
	ONERROR	QUIT			; 
	RET				; 
	.PAGE
	.SBTTL ASTHANDLER - DISPATCH AST'S
;++
; FUNCTIONAL DESCRIPTION:
;	
;	CALLS THE APPROPRIATE AST HANDLING ROUTINE
;
; CALLING SEQUENCE:
;
;	AST
;
; INPUT PARAMETERS:
;
;	THE AST PARAMETER IS A POINTER TO THE ADDRESS OF THE AST HANDLING 
;	ROUTINE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
ASTHANDLER:
	.WORD 	0
	MOVL 	4(AP),R0	;GET AST PARAMETER
	CALLS	#0,@(R0)		;CALL SERVICE ROUTINE
	RET
	.PAGE
	.SBTTL PROCMSG - PROCESS A LINK MESSAGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	ACT ON A QIO REQUEST PREVIOUSLY RECEIVED ON THE LINK
;
; CALLING SEQUENCE:
;
;	CALLS	#0,PROCMSG
;
; INPUT PARAMETERS:
;
;	R0 IS A POINTER TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	READQIO
;	WRITEQIO
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	READQIO
;	WRITEQIO
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A QIO TO THE TERMINAL MAY BE PERFORMED.
;
;--
;
PROCMSG:
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	MOVZWL	AB_BUF+RDP$W_OPCODE(R0),R1
	CLRL	R7
	MOVAB	TERMOPS,R2
	MOVZWL	(R2)+,R3		;COUNT
1$:	CMPW	R1,(R2)
	BNEQ	2$
	MOVZWL	2(R2),R7		;INTERNAL OP CODE
	BRB	3$
2$:	ADDL2	#4,R2			;SKIP
	SOBGTR	R3,1$
3$:
	BISW2	AB_BUF+RDP$W_MOD(R0),AB_BUF+RDP$W_OPCODE(R0)	;ADD OP MOD
	MOVL 	R0,R6
	.ENABL	LSB
	CASEB	R7,#OP_READ,#OP_SENSEMODE
4$:	 .WORD	READMSG-4$
	 .WORD	WRITEMSG-4$
	 .WORD	SETMSG-4$
	 .WORD	SENSEMSG-4$
	RET
;
; A READ QIO REQUEST
READMSG:
	MOVAB	QIODONE,AB_TYPE(R0)	;NEW STATE
	MOVZWL  AB_BUF+RDP$W_OPCODE(R0),R2
	BICW	FIRST_READ, R2		; Don't purge type ahead on first read
	CLRW	FIRST_READ		;  but only on the first read...
	MOVZWL  AB_BUF+RDP$L_TT_BCNT(R0),R3
	CLRL   	R4
	CLRL   	R5
	BITW 	#OP_PRMPT,R7  
	BEQL	10$
	MOVAB  	AB_BUF+RDP$T_TT_TERM+1(R0),R4	;TERM MSG SIZE ADDR+1
	MOVZBL 	-1(R4),R5	;TERM MSG SIZE
	ADDL2  	R5,R4	;PROMPT SIZE ADDRESS
	MOVZWL 	(R4)+,R5
10$:
	MOVZBL  AB_BUF+RDP$T_TT_TERM(R0),RTERMDES	;TERMINATION CHARS
	BNEQ	30$
; USE DEFAULT
	CLRL   	R1
	BRB	40$
30$:
	MOVAB  RTERMDES,R1
40$:
	MOVAB   AB_BUF+RDP$T_TT_TERM+1(R0),RTERMDES+4
	MOVL    AB_BUF+RDP$L_REFID(R0),READQIO
	TSTB	INDFLAG
	BEQL	45$
	JSB	INDREAD				;TRY THE INDIRECT FILE
45$:	$QIO_S	CHAN = READCHAN -
		FUNC = R2 -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AB_BUF+RDP$T_TT_RDATA+2(R0) -
		P2 = R3 -
		P3 = AB_BUF+RDP$L_TT_TIMOUT(R0) -
		P4 = R1 -
		P5 = R4 -
		P6 = R5
	IF_NO_QUOTA	QUIT
	BRW	110$
;
; A WRITE QIO REQUEST
WRITEMSG:
	MOVAB  	QIODONE,AB_TYPE(R0)	;NEW STATE
	MOVZWL 	AB_BUF+RDP$W_OPCODE(R0),R2
	MOVZWL 	AB_BUF+RDP$L_TT_BCNT(R0),R3
	MOVL   	AB_BUF+RDP$L_REFID(R0),WRITEQIO
	$QIO_S	CHAN = WRITECHAN -
		FUNC = R2 -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AB_BUF+RDP$T_TT_WDATA(R0) -
		P2 = R3 -
		P4 = AB_BUF+RDP$L_TT_CARCON(R0)
	IF_NO_QUOTA	QUIT
	BRW	110$
;
; A SET MODE QIO REQUEST
SETMSG:
	BITW	#IO$M_OUTBAND,AB_BUF+RDP$W_OPCODE(R0)
	BNEQ	49$
	BRW	60$
; HANDLE AN OUT OF BAND AST REQUEST
49$:	MOVL	R0,R7			;SAVE R0
	MOVAB	AB_BUF+RDP$B_TT_OUTBAND(R0),R3	;START OF DATA (MASKS)
	CMPB	(R3),#4			;FOR NOW, IT MUST BE A SINGLE LONGWORD
	BEQL	51$
	BRW	120$
51$:	MOVL	1(R3),INCMASK+4		;GET THE INCLUDE MASK
	CMPB	5(R3),#4		;AGAIN, A SINGLE LONGWORD
	BEQL	52$
	BRW	120$
52$:	MOVL	6(R3),EXCMASK+4		;EXCLUDE MASK
	$QIOW_S	CHAN = OUTBANDINC -
		FUNC = #IO$_SETMODE!IO$M_OUTBAND!IO$M_INCLUDE -
		P1 = OUTBANDAST -
		P2 = #INCMASK
	$QIOW_S	CHAN = OUTBANDEXC -
		FUNC = #IO$_SETMODE!IO$M_OUTBAND -
		P1 = OUTBANDAST -
		P2 = #EXCMASK
	MOVL	R7,R0			;RESTORE R0
	CALLS	#0,QIODONE
	BRW	110$
60$:	BITW  	#IO$M_HANGUP,AB_BUF+RDP$W_OPCODE(R0)  
	BEQL	70$
; HANGUP IS TREATED A PROGRAM EXIT
	QUIT	#SS$_NORMAL
70$:
	MOVAB  	QIODONE,AB_TYPE(R0) 	;NEW STATE
	MOVZWL 	AB_BUF+RDP$W_OPCODE(R0),R2
	MOVL   	AB_BUF+RDP$L_REFID(R0),READQIO
	BITW 	#IO$M_CTRLCAST,AB_BUF+RDP$W_OPCODE(R0)  
	BNEQ	72$
	BRW	80$
; CONTROL-C ENABLE OR DISABLE
72$:	TSTL	AB_BUF+RDP$L_TT_ASTPRM(R0)
	BEQL	75$		;DISABLE
	TSTB	CNTRCFLAG	;IS THERE ALREADY ONE ENABLED?
	BEQL	74$
	BRW	90$		;YES
74$:	INCB	CNTRCFLAG
	$QIO_S	CHAN = CNTRLCHAN -	;ENABLE
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = CNTRLC -
		P2 = #IO$M_CTRLCAST
	IF_NO_QUOTA	QUIT
	BRW	110$
75$:	$QIO_S	CHAN = CNTRLCHAN -	;DISABLE
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0
	CLRB	CNTRCFLAG	;NO ^C'S ENABLED
	BRW	110$
80$:	BITW 	#IO$M_CTRLYAST,AB_BUF+RDP$W_OPCODE(R0)  
	BEQL	100$
; CONTROL-Y ENABLE OR DISABLE
90$:	MOVQ	#SS$_NORMAL,AB_IOSB(R0)		;PRETEND WE DID THE QIO
	$DCLAST_S ASTADR = ASTHANDLER -
		  ASTPRM = R0
	BRW	110$
100$:
	MOVL	R0,R3			;WE NEED THE BUFFER ADDRESS LATER
	MOVL	#8,R4			;ASSUME SHORT FORM
	MOVQ	AB_BUF+RDP$Q_TT_CHAR(R0),CHARBUF
	TSTB	PROTO_ECO		;IS IT LEVEL 0
	BEQL	105$
	ADDL	#4,R4			;LONG FORM
	MOVL	AB_BUF+RDP$L_TT_CHAR2(R0),CHARBUF+8
105$:	$QIO_S	CHAN = READCHAN -
		FUNC = R2 -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -	  
		P1 = CHARBUF -
		P2 = R4 -
		P3 = AB_BUF+RDP$L_TT_SPEED(R0) -
		P4 = AB_BUF+RDP$L_TT_FILL(R0) -
		P5 = AB_BUF+RDP$L_TT_PARITY(R0)
; TAKE CARE OF NOT ALWAYS GETTING AST ON ERROR
	BLBS	R0,110$		;NO ERROR
	MOVW	R0,AB_IOSB(R3)	;MAKE SURE STATUS IS IN IOSB
	$DCLAST_S ASTADR = ASTHANDLER -
		  ASTPRM = R3
	BRB	110$
;
; A SENSE MODE QIO REQUEST
SENSEMSG:
	MOVAB	QIODONE,AB_TYPE(R0)	;NEW STATE
	MOVZWL	AB_BUF+RDP$W_OPCODE(R0),R2
	MOVL	AB_BUF+RDP$L_REFID(R0),READQIO
	CLRQ	AB_BUF+RDP$Q_TT_SCHAR(R0)
	CLRL	AB_BUF+RDP$Q_TT_SCHAR+8(R0)
	$QIO_S	CHAN = READCHAN -
		FUNC = R2 -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AB_BUF+RDP$Q_TT_SCHAR(R0) -
		P2 = #12
110$:
	RET
;
120$:	$PUTMSG_S MSGVEC = BADOUTBAND
	QUIT
;
	.DSABL	LSB
	.PAGE
	.SBTTL LINKRECV - PROCESS A RECEIVED MESSAGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	PROCESS THE AST INDICATING THAT A MESSAGE WAS RECEIVED ON THE LINK
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,LINKRECV
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	WRITEQIO
;	READQIO
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	AN ENTRY MAY BE ADDED TO THE QUEUE OF PENDING READS OR WRITES.
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A NEW READ OF THE LINK IS INITIATED.  IF THERE IS A ERROR ON THIS QIO,
;	A $WAKE IS ISSUED TO CAUSE A PROGRAM EXIT.
;
;	A PREVIOUS I/O MAY BE CANCELED
;
;--
;
LINKRECV:
	.WORD	^M<R2,R3,R7>
	BLBS	AB_IOSB(R0),00$		;ERROR ON LINK READ ??
	MOVZWL	AB_IOSB(R0),R2		;SAVE ERROR STATUS
	CMPW	R2,#SS$_ABORT
	BNEQ	1000$
	$SETIMR_S DAYTIM = THREESEC -	;JUST IN CASE MAILBOX DOESN'T GET REASON
		  ASTADR = LINKGONE
	RET				;LINK BROKE - LINK MBX WILL GET REASON
1000$:	$PUTMSG_S MSGVEC = DECNETERR	;LINK ERROR
	QUIT	R2
00$:	MOVZWL	AB_BUF+RDP$W_OPCODE(R0),R1
	CLRL	R7
	MOVAB	TERMOPS,R2
	MOVZWL	(R2)+,R3		;COUNT
1$:	CMPW	R1,(R2)
	BNEQ	2$
	MOVZWL	2(R2),R7		;INTERNAL OP CODE
	BRB	3$
2$:	ADDL2	#4,R2			;SKIP
	SOBGTR	R3,1$
3$:
	CMPB	R7,#OP_BRDCST
	BNEQ	4$
	JSB	BROADCAST		;GO BROADCAST IT
	BRB	40$
4$:	CMPB	R7,#OP_CANCEL
	BNEQ	5$
	JSB	CANCELIO		;GO CANCEL IT
	BRB	40$
5$:	CMPB 	R7,#OP_WRITE  
	BNEQ	20$
; A WRITE QIO
	TSTL WRITEQIO
	BNEQ	10$
; NO WRITE IN PROGRESS
	CALLS 	#0,PROCMSG
	BRB	40$
10$:
	INSQUE  (R0),@WRITEQ+4	;QUEUE IT
	BRB	40$
20$:
; A READ OR SETMODE OR SENSEMODE
	TSTL READQIO 
	BNEQ	30$
; NO READ IN PROGRESS
	CALLS 	#0,PROCMSG
	BRB	40$
30$:
	INSQUE  (R0),@READQ+4	;QUEUE IT
40$:
	BSBW	GETBUF		;GET A BUFFER FOR READING LINK
	MOVAB	LINKRECV,(R0)
	$QIO_S	CHAN = LINKCHAN -	;READ LINK AGAIN
		FUNC = #IO$_READVBLK -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AB_BUF(R0) -
		P2 = #MAXMSG
	ONERROR	QUIT
	RET
;
;
;
; CANCEL AN I/O
;
CANCELIO:
	MOVL	R0,R2
	$CANCEL_S CHAN = CNTRLCHAN	;DISABLE ^C ON A CANCEL
	CLRB	CNTRCFLAG		;NO CONTROL-C'S ENABLED
	MOVL	R2,R0
	CMPL 	AB_BUF+RDP$L_REFID(R0),READQIO
	BNEQ	20$
; CANCEL THE READ
	JSB	BUFFREE
	$CANCEL_S  CHAN = READCHAN
	RSB
20$:	CMPL 	AB_BUF+RDP$L_REFID(R0),WRITEQIO
	BNEQ	30$
; CANCEL THE WRITE
	JSB	BUFFREE
	$CANCEL_S  CHAN = WRITECHAN
	RSB
30$:
	MOVAB	READQ,R1	;GET QUEUE OF PENDING READS
31$:	MOVAB	(R1),R1
	CMPL	R1,#READQ
	BEQL	32$		;END OF QUEUE
	CMPL	AB_BUF+RDP$L_REFID(R1),AB_BUF+RDP$L_REFID(R0)
	BNEQ	31$		;TRY THE NEXT ONE
	BRB	39$		;GO CANCEL IT
32$:	MOVAB	WRITEQ,R1	;GET QUEUE OF PENDING WRITES
33$:	MOVL	(R1),R1
	CMPL	R1,#WRITEQ
	BEQL	34$		;END OF QUEUE
	CMPL	AB_BUF+RDP$L_REFID(R1),AB_BUF+RDP$L_REFID(R0)
	BNEQ	33$		;TRY THE NEXT ONE
	BRB	39$		;SAVE THE CANCEL - WRITE NOT DONE YET
34$:	JSB 	BUFFREE		;QIO ALREADY DONE - THROW OUT THE CANCEL
	RSB
39$:
	REMQUE	(R1),R1	;REMOVE THE ENTRY
	MOVL	AB_BUF+RDP$L_REFID(R1),CANMSG+RDP$L_REFID
	JSB	BUFFREE	;WE DON'T NEED THE CANCEL ANYMORE
	MOVL	R1,R0
	JSB	BUFFREE		;WE DON'T NEED THE QIO EITHER
	$QIO_S	CHAN = LINKCHAN -	;SEND THE CANCEL COMPLETE MSG
		FUNC = #IO$_WRITEVBLK -
		P1 = CANMSG -
		P2 = #RDP$K_HEADERLEN+8
	ONERROR	QUIT
	RSB
;
;
;
; BROADCAST TO THE TERMINAL
;
BROADCAST:
	MOVL 	AB_BUF+RDP$L_TT_BCNT(R0),BRDDESC	;COUNT
	MOVAB	AB_BUF+RDP$T_TT_WDATA(R0),BRDDESC+4	;ADDRESS
	CMPW	@BRDDESC+4,#^XA0D		;CHECK FOR CR-LF
	BNEQ	10$
	CLRW	@BRDDESC+4			;REMOVE IT - BRDCST ADDS ANOTHER ONE
10$:	MOVL	R0,R2
	$BRDCST_S MSGBUF = BRDDESC -
		  DEVNAM = TTYDESC
	MOVQ	R0,AB_BUF+RDP$Q_STATUS(R2)	;RETURN AN IOSB
	MOVAB	LNKWRTDONE,AB_TYPE(R2)		;NEW STATE
	MOVW	#RDP$C_END,AB_BUF+RDP$W_OPCODE(R2)	;A STATUS MESSAGE
	CLRW	AB_BUF+RDP$W_MOD(R2)
	$QIO_S	CHAN = LINKCHAN -	;WRITE MESSAGE ON LINK
		FUNC = #IO$_WRITEVBLK -
		IOSB = AB_IOSB(R2) -
		ASTADR = ASTHANDLER -
		ASTPRM = R2 -
		P1 = AB_BUF(R2) -
		P2 = #RDP$K_HEADERLEN+8
	ONERROR	QUIT
	RSB
	.PAGE
	.SBTTL QIODONE - PROCESS A COMPLETED TERMINAL QIO
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST INDICATING THAT A TERMINAL QIO HAS COMPLETED
;
; CALLING SEQUENCE:
;
;	CALLS	#0,QIODONE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A STATUS MESSAGE IS WRITTEN TO THE LINK.  IF THERE IS AN ERROR ON THIS
;	QIO, A $WAKE IS ISSUED TO CAUSE THE PROGRAM TO EXIT
;
;--
;
QIODONE:
	.WORD 	^M<R2,R3,R7>
	TSTL	AB_BUF+RDP$L_REFID(R0)		;CHECK FOR ZERO REF ID
	BNEQ	1000$
	MOVZBL	#1,AB_IOSB(R0)	;NO ERRORS
	CALLS	#0,LNKWRTDONE	;PRETEND WE SENT IT
	RET
1000$:	EXTZV	#0,#6,AB_BUF+RDP$W_OPCODE(R0),R1	;GET OP CODE (NO MOD)
	CLRL	R7
	MOVAB	TERMOPS,R2
	MOVZWL	(R2)+,R3		;COUNT
1$:	CMPW	R1,(R2)
	BNEQ	2$
	MOVZWL	2(R2),R7		;INTERNAL OP CODE
	BRB	3$
2$:	ADDL2	#4,R2			;SKIP
	SOBGTR	R3,1$
3$:
	CMPB 	R7,#OP_READ  
	BNEQ	10$
; IT WAS A READ SO WE NEED THE COUNT
	MOVZWL  AB_IOSB+2(R0),R1 	;CHARACTERS BEFORE THE TERMINATOR
	ADDW2   AB_IOSB+6(R0),R1	;TOTAL CHARACTERS
	MOVW	R1,AB_BUF+RDP$T_TT_RDATA(R0)	;SAVE IN LINK MESSAGE
	ADDW2   #2,R1			;SIZE OF READ DATA PLUS COUNT
	BRB	40$
10$:
	CMPB 	R7,#OP_WRITE
	BNEQ	20$
	CLRL	R1			;NO READ DATA
	BRB	40$
20$:
; SETMODE OR SENSEMODE
	CLRL	R1			;ASSUME NO DATA
	CMPB	R7,#OP_SETMODE
	BEQL	40$
	MOVL	#12,R1			;12 BYTES OF DATA
40$:	MOVW	#RDP$C_END,AB_BUF+RDP$W_OPCODE(R0)	;A STATUS MESSAGE
	CLRW	AB_BUF+RDP$W_MOD(R0)
	MOVQ	AB_IOSB(R0),AB_BUF+RDP$Q_STATUS(R0)
	ADDW2	#RDP$T_TT_RDATA,R1
	MOVAB	LNKWRTDONE,AB_TYPE(R0)	;NEW STATE
	$QIO_S	CHAN = LINKCHAN	-	;WRITE MESSAGE ON LINK
		FUNC = #IO$_WRITEVBLK -
		IOSB = AB_IOSB(R0) -
		ASTADR = ASTHANDLER -
		ASTPRM = R0 -
		P1 = AB_BUF(R0) -
		P2 = R1
	ONERROR	QUIT
	RET
	.PAGE
	.SBTTL LNKWRTDONE - A WRITE TO THE LINK HAS COMPLETED
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST INDICATING THAT A WRITE HAS COMPLETED ON THE LINK 
;	BY FREEING THE BUFFER.
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,LNKWRTDONE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A BUFFER IS FREED
;	THE QUEUE OF PENDING QIO'S IS CHECKED
;
;--
;
LNKWRTDONE:
	.WORD	0
	BLBS	AB_IOSB(R0),20$		;ERROR ON LINK WRITE ??
	MOVZWL	AB_IOSB(R0),R2		;SAVE ERROR STATUS
	CMPW	R2,#SS$_ABORT
	BNEQ	10$
	RET				;LINK BROKE - LINK MBX WILL GET REASON
10$:	$PUTMSG_S MSGVEC = DECNETERR	;LINK ERROR
	QUIT	R2
20$:	MOVL	AB_BUF+RDP$L_REFID(R0),R3	;SAVE ID
	BSBW	BUFFREE		;RELEASE THE BUFFER
	CMPL	R3,READQIO	;WAS THIS A READ (OR SET MODE)
	BNEQ	30$		;NO
	CLRL	READQIO		;FORGET ABOUT THE PREVIOUS ONE
	REMQUE	@READQ,R0
	BVS	30$		;NO MORE
	CALLS	#0,PROCMSG	;GO PROCESS IT
	RET
30$:	CMPL	R3,WRITEQIO	;WAS THIS A WRITE
	BNEQ	40$		;NO
	CLRL	WRITEQIO	;FORGET ABOUT THE PREVIOUS ONE
	REMQUE	@WRITEQ,R0
	BVS	40$		;NO MORE
	CALLS	#0,PROCMSG	;GO PROCESS IT
40$:	RET
	.PAGE
	.SBTTL LNKMBXDONE - MESSAGE RECEIVED ON THE LINK MAILBOX
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST INDICATING THAT A MESSAGE WAS RECEIVED ON THE LINK 
;	MAILBOX
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,LNKMBXDONE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO AN AST CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	THE PROGRAM IS ABORTED.
;
;--
;
LNKMBXDONE:
	.WORD	^M<R2>
; CONSIDER IT AN ABORT
	MOVL	R0,R2
	CMPW	AB_BUF(R2),#MSG$_DISCON
	BEQL	8$
	CMPW	AB_BUF(R2),#MSG$_EXIT
	BEQL	8$
	CMPW	AB_BUF(R2),#MSG$_THIRDPARTY
	BNEQ	1$
	QUIT	#SS$_THIRDPARTY
1$:	CMPW	AB_BUF(R2),#MSG$_PATHLOST
	BNEQ	2$
	QUIT	#SS$_PATHLOST
2$:	CMPW	AB_BUF(R2),#MSG$_ABORT	;LOG OUT - IGNORE IT
	BNEQ	10$		;GO IGNORE OTHER MESSAGE CODES
8$:	QUIT	#SS$_NORMAL	;NO STATUS MESSAGE
10$:	$QIO_S	CHAN = MAILCHAN	-	;LINK MAILBOX READ
		FUNC = #IO$_READVBLK -
		IOSB = LINKMAIL+AB_IOSB -
		ASTADR = ASTHANDLER -
		ASTPRM = #LINKMAIL -
		P1 = LINKMAIL+AB_BUF -
		P2 = #40
	ONERROR QUIT
	RET
	.PAGE
	.SBTTL OUTBANDAST - OUT OF BAND CHARACTER AST RECEIVED
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLES THE AST RESULTING FROM AN OUT OF BAND CHARACTER
;
; CALLING SEQUENCE:
;
;	CALLS	#0,OUTBANDAST
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	AST PARAMETER - CHARACTER
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A MESSAGE SENT ON LINK
;
;--
;
OUTBANDAST:
	.WORD	0
	MOVB	4(AP),OUTBANDCHAR	;GET THE CHARACTER THAT CAUSED THE AST
	MOVW	#RDP$C_ATTN,OUTBANDMSG+RDP$W_OPCODE
	MOVW	#RDP$C_TT_OUTBAND,OUTBANDMSG+RDP$W_MOD
	MOVW	TERMUNIT,OUTBANDMSG+RDP$W_UNIT
	$QIO_S	CHAN = LINKCHAN -	;SEND ON LINK
		FUNC = #IO$_WRITEVBLK -
		P1 = OUTBANDMSG -
		P2 = #RDP$K_HEADERLEN+1
	ONERROR QUIT
	RET
	.PAGE
	.SBTTL LINKGONE - TIMER EXPIRED SO LINK IS GONE
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLES THE AST RESULTING FROM THE TIMER STARTED TO WAIT FOR THE 
;	  MAILBOX TO GET THE REASON WHY THE LINK IS GONE
;
; CALLING SEQUENCE:
;
;	CALLS	#0,LINKGONE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LAST LINK MAILBOX MESSAGE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A $WAKE WILL FORCE THE PROGRAM TO EXIT
;
;--
;
LINKGONE:
	.WORD	0
	MOVZWL	LINKMAIL+AB_BUF,MBXMSGTYP	;GET REASON FROM THE LAST MAILBOX MESSAGE
	$PUTMSG_S MSGVEC = MBXMSG		;OUTPUT MESSAGE TYPE
	QUIT
	.PAGE
	.SBTTL UNSDATMBX - MESSAGE IN TERMINAL MAILBOX
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLES THE AST RESULTING FROM UNSOLICITED TERMINAL DATA OR HANGUP
;
; CALLING SEQUENCE:
;
;	CALLS	#0,UNSDATMBX
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	RETSTATUS
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A MESSAGE IS SENT ON THE LINK.  IF THIS QIO FAILS, A $WAKE FORCES THE
;	PROGRAM TO EXIT.
;
;--
;
UNSDATMBX: 
	.WORD	0
	MOVL	#RDP$K_HEADERLEN,R1		;ASSUME WE SEND THIS MUCH
	CMPW 	UNSDAT+AB_BUF+RDP$K_HEADERLEN+2,#MSG$_TRMUNSOLIC 
	BNEQ	10$
	MOVW	#RDP$C_TT_UNSOL,UNSDAT+AB_BUF+RDP$W_MOD	;UNSOL DATA
	BRB	20$
10$:
	CMPW 	UNSDAT+AB_BUF+RDP$K_HEADERLEN+2,#MSG$_TRMBRDCST
	BNEQ	18$
	MOVZWL	UNSDAT+AB_BUF+RDP$K_HEADERLEN+22,R1		;LENGTH OF BROADCAST
	ADDL2	#RDP$K_HEADERLEN+24,R1		;ADD REST + HEADER
	MOVW	R1,UNSDAT+AB_BUF+RDP$K_HEADERLEN	;SAVE IT IN MSG
	MOVW 	#RDP$C_TT_BRDCST,UNSDAT+AB_BUF+RDP$W_MOD	;BROADCAST
	BRB	20$
18$:	CMPW 	UNSDAT+AB_BUF+RDP$K_HEADERLEN+2,#MSG$_TRMHANGUP
	BNEQ	UNSMSGDONE+2		;IGNORE IT
	MOVW 	#RDP$C_TT_HANGUP,UNSDAT+AB_BUF+RDP$W_MOD	;HANGUP
20$:
	MOVW	#RDP$C_ATTN,UNSDAT+AB_BUF+RDP$W_OPCODE
	MOVW	TERMUNIT,UNSDAT+AB_BUF+RDP$W_UNIT		;TERM UNIT NUM
	MOVAB	UNSMSGDONE,UNSDAT	;NEW STATE
	$QIO_S	CHAN = LINKCHAN -		;SEND MESSAGE ON LINK
		FUNC = #IO$_WRITEVBLK -
		ASTADR = ASTHANDLER -
		ASTPRM = #UNSDAT -
		P1 = UNSDAT+AB_BUF -
		P2 = R1
	ONERROR	QUIT
	RET
	.PAGE
	.SBTTL UNSMSGDONE - DO A NEW TERMINAL MAILBOX READ
;++
; FUNCTIONAL DESCRIPTION:
;
;	WHEN THE WRITE TO THE LINK COMPLETES,DO A NEW TERMINAL MAILBOX READ.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,UNSMSGDONE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	IF THE MAILBOX READ QIO FAILS, A $WAKE IS ISSUED TO CAUSE THE PROGRAM
;	TO EXIT
;
;--
;
UNSMSGDONE:
	.WORD	0
	MOVAB	UNSDATMBX,UNSDAT	;NEW STATE
	$QIO_S	CHAN = TERMMBXCHAN -	;SET UP UNSOLICITED DATA MBX READ
		FUNC = #IO$_READVBLK -
		IOSB = UNSDAT+AB_IOSB -
		ASTADR = ASTHANDLER -
		ASTPRM = #UNSDAT -
		P1 = UNSDAT+AB_BUF+RDP$K_HEADERLEN+2 -
		P2 = #MAXMSG
	ONERROR	QUIT
	RET
	.PAGE
	.SBTTL CNTRLCAST - CONTROL-C & CONTROL-Y
;++
; FUNCTIONAL DESCRIPTION:
;
;	HANDLE THE AST RESULTING FROM A CONTROL-C OR A CONTROL-Y
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,CNTRLC
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	CNTRLYTIM
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	CNTRLYTIM
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	A MESSAGE IS SENT ON THE LINKAND FOR ^Y THE AST IS REENABLED.
;	TWO QUICK (LESS THAN 3 SEC) ^Y'S WILL ABORT THIS PROGRAM.
;--
;
CNTRLC:	.WORD	0
	MOVW	#RDP$C_ATTN,CNTRLCY+RDP$W_OPCODE
	CMPW	4(AP),#IO$M_CTRLCAST
	BNEQ	10$
	MOVW	#RDP$C_TT_CTRLC,CNTRLCY+RDP$W_MOD
	CLRB	CNTRCFLAG	;NO CONTROL-C ENABLES
	BRB	30$
10$:	CMPW	4(AP),#IO$M_CTRLYAST
	BEQL	20$
	QUIT	4(AP)			;PROBABLY A HANGUP
20$:	BSBW	CNTRLYTEST	;CHECK FOR RECENT ^Y
	$QIO_S	CHAN = CNTRLCHAN -	;RE-ENABLE IT
		FUNC = #IO$_SETMODE!IO$M_CTRLYAST -
		P1 = CNTRLC -
		P2 = #IO$M_CTRLYAST
; WE WILL START TIMING WAITING FOR A SECOND ONE
	INCB	CNTRLYTIM	;INDICATE WE HAVE ONE ^Y
	$SETIMR_S DAYTIM = THREESEC -	;TIME THREE SECONDS
		  ASTADR = YTIMEDONE
	MOVW	#RDP$C_TT_CTRLY,CNTRLCY+RDP$W_MOD
30$:
	MOVW	TERMUNIT,CNTRLCY+RDP$W_UNIT
	$QIO_S	CHAN = LINKCHAN -		;SEND MESSAGE ON LINK
		FUNC = #IO$_WRITEVBLK -
		P1 = CNTRLCY -
		P2 = #RDP$K_HEADERLEN
	ONERROR	QUIT
	RET
;
;
; ^Y TIMER HAS EXPIRED
;
YTIMEDONE:
	.WORD	0
	CLRB	CNTRLYTIM	;NO RECENT ^Y
	RET
;
;
; ASK ABORT QUESTION IF THERE WAS A RECENT ^Y
;
CNTRLYTEST:
	TSTB	CNTRLYTIM
	BNEQ	10$
	RSB			;NO RECENT ^Y - CONTINUE
10$:	$GETMSG_S MSGID = #REM$_CNTRLY -
		MSGLEN = CNTRLYMSGBUF -
		BUFADR = CNTRLYMSGBUF -
		FLAGS = #1
	$FAO_S	CTRSTR = CNTRLYMSGBUF -
		OUTLEN = CNTRLYQUESLEN -
		OUTBUF = CNTRLYQUESBUF -
		P1 = #REMOTENODE
	$QIOW_S	CHAN = READCHAN -	;ASK ABOUT THE ^Y JUST TYPED
		EFN = #1 -
		FUNC = #IO$_READPROMPT!IO$M_CVTLOW -
		P1 = ANSBUF -
		P2 = #10 -
		P5 = #CNTRLYQUES -
		P6 = CNTRLYQUESLEN
	CMPB	ANSBUF,#^A/Y/		;DID HE SAY YES
	BEQL	20$
	RSB			;HE SAID NO - SO CONTINUE
; ABORT
20$:	QUIT	#SS$_NORMAL	;NO STATUS MESSAGE
	.PAGE
	.SBTTL INDREAD - READ INDIRECT COMMAND FILE
;++
; FUNCTIONAL DESCRIPTION:
;
;	READS FROM AN INDIRECT COMMAND FILE
;
; CALLING SEQUENCE:
;
;	JSB	INDREAD
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	QIO PARAMETERS IN REGISTERS
;	SYSINRAB
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	INDFLAG
;
; COMPLETION CODES:
;
; SIDE EFFECTS:
;
;	ON AN EOF, FURTHER READS FROM THE INDIRECT FILE ARE DISABLED.
;	THE PROGRAM WILL EXIT ON AN INDIRECT FILE READ.
;
;--
;
INDREAD:
	PUSHR	#^M<R0,R1,R6>
	MOVAL	AB_BUF+RDP$T_TT_RDATA+2(R0),SYSINRAB+RAB$L_UBF	;DATA ADDRESS
	MOVW	R3,SYSINRAB+RAB$W_USZ		;REQUESTED SIZE
	$GET	RAB = SYSINRAB			;READ A RECORD
	CMPL	R0,#RMS$_NORMAL
	BNEQ	10$				;PROBLEM
	POPR	#^M<R0,R1,R6>
	CLRQ	AB_IOSB(R0)
	MOVZWL	SYSINRAB+RAB$W_RSZ,R1
	MOVW	SYSINRAB+RAB$W_RSZ,AB_IOSB+2(R0)	;SIZE OF READ
	ADDL	SYSINRAB+RAB$L_UBF,R1		;FIND WHERE TO PUT TERMINATOR
	MOVB	#^X0D,(R1)	
	MOVW	#1,AB_IOSB+6(R0)		;TERMINATOR SIZE
	MOVW	#SS$_NORMAL,AB_IOSB(R0)
	BITL	#IO$M_CVTLOW,R2
	BEQL	9$				;NO CASE CONVERSION
	MOVL	SYSINRAB+RAB$L_UBF,R6		;BUFFER ADDRESS
	MOVZWL	SYSINRAB+RAB$W_RSZ,R1		;CHARACTERS TO CHECK
5$:	CMPB	(R6),#^A/a/
	BLSS	8$				;NOT LOWER CASE
	CMPB	(R6),#^A/z/
	BGTR	8$				;NOT LOWER CASE
	SUBB	#^X20,(R6)			;MAKE IT UPPER CASE
8$:	INCL	R6				;NEXT
	SOBGTR	R1,5$
9$:	$DCLAST_S ASTADR = ASTHANDLER, -	;SIMULATE A COMPETION AST
		  ASTPRM = R0
	RET
10$:	CMPL	R0,#RMS$_EOF		;ARE WE JUST DONE WITH THE FILE
	BNEQ	20$			;REAL PROBLEM
	$CLOSE	FAB = SYSINFAB		;DON'T NEED IT
	CLRB	INDFLAG
	POPR	#^M<R0,R1,R6>
	RSB				;GO DO THE REAL QIO
20$:	QUIT
	.PAGE
	.SBTTL GETBUF - GET A BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	GET A FREE BUFFER OR ALLOCATE ONE IF THERE ARE NONE.
;
; CALLING SEQUENCE:
;
;	JSB 	GETBUF
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	BUFQUEUE
;
; OUTPUT PARAMETERS:
;
;	R0 POINTS TO THE BUFFER
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	MORE VIRTUAL MEMORY MAY BE ALLOCATED
;
;--
;
GETBUF:	REMQUE	@BUFQUEUE,R0	;GET A BUFFER
	BVS	10$
	RSB			;THERE WAS ONE
; ALLOCATE A BUFFER
10$:	PUSHAB	BUFADR		;BUFFER ADDRESS WILL BE RETURNED HERE
	PUSHAB	BUFSIZE		;REQUESTED SIZE
	CALLS 	#2,G^LIB$GET_VM
	ONERROR	QUIT
	MOVL	BUFADR,R0
	RSB
	.PAGE
	.SBTTL BUFFREE - FREE A BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	FREE A BUFFER.
;
; CALLING SEQUENCE:
;
;	JSB 	BUFFREE
;
; INPUT PARAMETERS:
;
;	R0 POINTS TO THE BUFFER
;
; IMPLICIT INPUTS:
;
;	BUFQUEUE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
BUFFREE: 
	INSQUE 	(R0),BUFQUEUE		;PUT BUFFER IN FREE LIST
	RSB
	.PAGE
	.SBTTL	READ ONLY DATA
;
;
NOTTERM:   .WORD  2,0
	   .LONG  REM$_NOTERM,0
;
TTYDESC::  .ASCID /SYS$COMMAND/
;
NAMEREQ:   .ASCID <13><10>/Node name: /
;
TERMOPS:   .WORD   <2$-1$>/4
1$:	   .WORD   IO$_READVBLK,OP_READ
	   .WORD   IO$_READLBLK,OP_READ
	   .WORD   IO$_READPBLK,OP_READ
	   .WORD   IO$_READPROMPT,OP_READ!OP_PRMPT
	   .WORD   IO$_TTYREADALL,OP_READ
	   .WORD   IO$_TTYREADPALL,OP_READ!OP_PRMPT
	   .WORD   IO$_WRITEVBLK,OP_WRITE
	   .WORD   IO$_WRITELBLK,OP_WRITE
	   .WORD   IO$_WRITEPBLK,OP_WRITE
	   .WORD   IO$_SETMODE,OP_SETMODE
	   .WORD   IO$_SETCHAR,OP_SETMODE
	   .WORD   IO$_SENSEMODE,OP_SENSEMODE
	   .WORD   IO$_SENSECHAR,OP_SENSEMODE
	   .WORD   IO$_ACPCONTROL,OP_CANCEL
	   .WORD   -1,OP_BRDCST
2$:
;
DECNETERR: .LONG  2,REM$_NETERR,0
;
NOTVMS:	   .LONG  2,REM$_NOPROT,0
;
ACSIGNORE: .LONG  2,REM$_ACSIGN,0
;
BADOUTBAND: .LONG 2,REM$_BADOUTBAND,0
;
SYS$NODE:  .ASCID /SYS$NODE/
;
THREESEC:  .LONG  -10*1000*1000*3,-1		;THREE SECOND TIMER
;
MBXSIZ:	   .LONG  MAXMSG	;ARGUMENT FOR MAILBOX CREATION
;
DVILIST:
	.WORD	4,DVI$_DEVCLASS
	.ADDRESS DEVCLASS_TEMP
	.LONG	0
	.WORD	4,DVI$_DEVTYPE
	.ADDRESS DEVTYPE_TEMP
	.LONG	0
	.WORD	4,DVI$_DEVBUFSIZ
	.ADDRESS DEVBUFSIZ_TEMP
	.LONG	0
	.WORD	4,DVI$_DEVDEPEND
	.ADDRESS DEVDEPEND
	.LONG	0
	.WORD	4,DVI$_DEVDEPEND2
	.ADDRESS DEVDEPEND2
	.LONG	0
	.WORD	16,DVI$_DEVNAM
	.ADDRESS DEVNAM
	.ADDRESS DEVNAMLEN
	.WORD	4,DVI$_UNIT
	.ADDRESS TERMUNIT
	.LONG	0
	.LONG	0			;END OF LIST
	.PAGE
	.SBTTL	READ WRITE DATA
	.PSECT	_RTPAD,LONG
;
;
LINKCHAN::  .LONG  0	;CHANNEL NUMBER FOR THE LINK
;
RDWRTCHAN::
READCHAN::  .LONG  0	;CHANNEL NUMBER FOR TERMINAL READS
;
WRITECHAN:: .LONG  0	;CHANNEL NUMBER FOR TERMINAL WRITES
;
CNTRLCHAN:: .LONG  0	;CHANNEL NUMBER FOR ^C AND ^Y ENABLES
;
TERMMBXCHAN::  .LONG  0	;CHANNEL NUMBER FOR UNSOLICITED DATA MAILBOX
;
MAILCHAN::  .LONG  0	;CHANNEL NUMBER FOR LINK MAILBOX
;
INITMSG:   .LONG  2$-1$
1$:	   .WORD  RDP$C_ATTN,RDP$C_TT_UNSOL,0,0,0
2$:
;
UNSDAT:    .LONG  UNSDATMBX
	   .BLKB  AB_BUF+MAXMSG		;FOR UNSOLICITED DATA MAILBOX
;
RETSTATUS:: .LONG  0		;SAVE A SYSTEM SERVICE STATUS
;
RTERMDES:  .BLKL  2		;TERMINATOR CHARACTER DESCRIPTOR
;
BUFQUEUE:  .LONG  BUFQUEUE,BUFQUEUE	;EMPTY BUFFER QUEUE
;
BUFADR:	   .LONG  0		;THE ADDRESS OF AN ALLOCATED BUFFER GOES HERE
;
BUFSIZE:   .LONG  AB_BUF+MAXMSG	;BUFFER SIZE
;
LINKMAIL:  .LONG  LNKMBXDONE
	   .BLKB  AB_BUF+40-4
;
READQIO:   .LONG   0		;ID OF CURRENT READ REQUEST
;
WRITEQIO:  .LONG   0		;ID OF CURRENT WRITE REQUEST
;
READQ:	   .LONG   READQ,READQ	;QUEUE OF PENDING READS
;
WRITEQ:    .LONG   WRITEQ,WRITEQ	;QUEUE OF PENDING WRITES
;
TERMUNIT:  .LONG   0		;UNIT NUMBER OF THE TERMINAL
;
NAMEIOSB:  .BLKL  2		;IOSB FOR GETTING NODE NAME
;
REQ_COMMAND: $CLIREQDESC  RQTYPE = CLI$K_GETCMD		;CLI CALL BACK
;
REQ_INIT:  $CLIREQDESC RQTYPE = CLI$K_INITPRS	;INIT THE WORK AREA
;
REQ_PARAM: $CLIREQDESC RQTYPE = CLI$K_INPUT1	;GET PARAMETER FROM CLI
;
CLIBITMAP: .LONG  0		;CLI BIT MAP
;
CLIWORK:   .BLKB  CLI$C_WORKAREA	;CLI WORK AREA
;
OLDCTRL:   .LONG  0					;CLI OUT OF BAND ENABLE FLAGS
;
NETDESC:   .LONG  2$-1$
	   .LONG  1$
	   .BLKB  100		;ALLOW 100 CHARACTER NODE NAME
1$:	   .ASCII  ?::"23="?
2$:
;
TERMCHAR::
	.LONG	DIB$K_LENGTH+16,1$	;TERM CHARACTERISTICS FOR RSX, ETC.
1$:	.BLKB	DIB$K_LENGTH+16
;
CONFMSG:   .LONG  16		;CONFIGURATION MESSAGE
	   .BYTE  1,1,1,0
	   .WORD  7,4
DEVCLASS:  .BLKB  1
DEVTYPE:   .BLKB  1
DEVBUFSIZ: .BLKW  1
DEVDEPEND: .BLKL  1
DEVDEPEND2:.BLKL  1
;
DEVNAM:	   .BLKB  16
;
CANMSG:	   .LONG  RDP$C_END,0
	   .WORD  0
	   .BLKQ  1
;
BRDDESC:   .BLKL  2		;DESCRIPTOR FOR BROADCASTS
;
CNTRLCY:   .BLKB  RDP$K_HEADERLEN	;LINK MESSAGE FOR CONTROL C OR Y
;
EXITMSG:   .LONG  3,REM$_END,1,NODENAME
;
NODENAME:: .LONG  2$-1$
	   .LONG  1$
1$:	   .BLKB  30
2$:
;
MBXMSG:    .LONG  3,REM$_NETMBX,1
MBXMSGTYP: .LONG  0
;
CNTRLYTIM: .BYTE  0		;RECENT ^Y INDICATOR
;
ANSBUF:    .BLKB  10		;RECEIVE ANSWER TO ^Y QUESTION
;
CNTRCFLAG: .BYTE  0		;INDICATE CONTROL-C ENABLES
;
OLDSETRWM: .LONG  0		;ORIGINAL RESOURCE WAIT MODE
;
CHARBUF:   .BLKB  12		;BUFFER TO TEMPORAILY HOLD TERMINAL CHARACTERISTICS
;
OUTBANDINC:  .WORD  0		;OUT OF BAND (INCLUDE) AST CHANNEL
OUTBANDEXC:  .WORD  0		;OUT OF BAND (EXCLUDE) AST CHANNEL
;
INCMASK:   .BLKL  2		;OUT OF BAND INCLUDE MASK
EXCMASK:   .BLKL  2		;OUT OF BAND EXCLUDE MASK
;
OUTBANDMSG: .BLKB  RDP$K_HEADERLEN
OUTBANDCHAR: .BYTE 0
;
FIRST_READ: .WORD IO$M_PURGE	; Don't purge type ahead (on the first read)
;
FIRSTCMD::				; First command descriptor
	.LONG	DSC$K_CLASS_D@<DSC$B_CLASS*8>
	.LONG	0

FINALPATH::				; Final path descriptor
	.LONG	DSC$K_CLASS_D@<DSC$B_CLASS*8>
	.LONG	0

FINALACS::				; Final ACS descriptor
	.LONG	DSC$K_CLASS_D@<DSC$B_CLASS*8>
	.LONG	0
;
INDFLAG:: .BYTE 0				;INDICATE INDIRECT COMMAND FILE
;
PROTO_ECO: .BYTE 0			;PROTOCOL ECO LEVEL
	.ALIGN LONG

SYSINFAB:: $FAB	FAC=GET,FNM=<SYS$INPUT>		;TO OPEN SYS$INPUT

SYSINRAB:: $RAB FAB=SYSINFAB
;
REMOTENODE:
	.BLKL	2			;REMOTE NODE NAME
;
CNTRLYMSGBUF:
	.LONG	256,1$			;BUFFER TO HOLD CONTROL Y QUESTION (BEFORE FAO)
1$:	.BLKB	256
;
CNTRLYQUESLEN:
	.LONG	0			;FINAL LENGTH OF QUESTION
;
CNTRLYQUESBUF:
	.LONG	256,CNTRLYQUES		;BUFFER TO HOLD THE FINAL QUESTION
CNTRLYQUES:
	.BLKB	256
;
WAKEFLAG::
	.BYTE	0			;FLAG FOR LEGITIMATE $WAKE
;
DEVNAMLEN:
	.LONG	0
;
DEVCLASS_TEMP:				;TEMP LOCATIONS SINCE GETDVI WANTS LONGS
	.LONG	0
DEVTYPE_TEMP:
	.LONG	0
DEVBUFSIZ_TEMP:
	.LONG	0

	.PAGE
	.SBTTL	PROTOCOL TABLE PSECTS
;
	.PSECT	PROTOTB,BYTE,NOEXE
PROTOTBL:
;
	.WORD	1@2			; <2> => VMS remote terminal protocol
	.LONG	VMSRT			; This is the initialization entry
;
	.PSECT	PROTOTBL,BYTE,NOEXE
;
	.PSECT	PROTOTBL1,BYTE,NOEXE
ENDPROTO:
;
	.END	RTPAD
