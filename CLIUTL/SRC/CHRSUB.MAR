	.TITLE	CHRSUB - CHARACTER MANIPULATION SUBROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	UTILITY SUBROUTINES
;
; ABSTRACT:	CHARACTER MANIPUATION SUBROUTINES
;
; ENVIRONMENT:	NATIVE/USER MODE CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE:	19-MAY-1977
;
; MODIFIED BY:
;
;	, : VERSION
; 01	- 
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
; MACRO TO GENERATE AN ENTRY IN THE CHARACTER CLASSIFICATION TABLE
;
; CALL:
;	CHAR	NAME,CHR
; WHERE:
;	NAME IS THE SYMBOLIC NAME SUFFIX TO "CHR$K_" FOR THE CHAR
;	CHR IS THE ASCII CHAR.
;
	.MACRO	CHAR	NAME,CHR,N
	CHR$K_'NAME == N
	.BYTE	^A\CHR\
	.ENDM

;
; EQUATED SYMBOLS:
;
; DEFINE SPECIAL SYMBOLS FOR ALPHA/NUMERIC SETS
;
	CHR$K_ALPHA == 1
	CHR$K_NUMERIC == 2

;
; OWN STORAGE:
;
	.PSECT	_PURE	RD,NOWRT,BYTE
 
CHRTBL:
	CHAR	SLASH	</>	12
	CHAR	SEMI	<;>	11
	CHAR	LBRAKT	<[>	10
	CHAR	RBRAKT	<]>	9
	CHAR	COMMA	<,>	8
	CHAR	DOT	<.>	7
	CHAR	COLON	<:>	6
	CHAR	BLANK	< >	5
	CHAR	DOLLAR	<$>	4
	CHAR	UNDRSCR	<_>	3
	.BYTE	0,0			; EOL AND FILLER FOR REMAINING COUNT
 
CHRTBLSIZ = . - CHRTBL
 
SPCNUM:	.ASCII	\-%+\			; SPECIAL CHARACTERS TREATED AS NUMERIC
SPCNUMSIZ = . - SPCNUM


	.SBTTL	TEST A CHARACTER FOR CLASS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CLASSIFY AN ASCII CHARATER INTO
;	ONE OF SEVERAL CLASSES. AN ALTERNATE ENTRY PROVIDES LOWER
;	TO UPPER CASE CONVERSION AS WELL.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	CHR$TSTCHR		; TEST THE CHARACTER
;	BSB/JSB	CHR$CVT			; CONVERT AND TEST
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS ADDRESS OF BYTE TO TEST
;
; IMPLICIT INPUTS:
;
;	STRING IS TERMINATED BY A ZERO BYTE
;
; OUTPUT PARAMETERS:
;
;	R0 SET TO "CHR$K_<CLASS_NAME>" IF ONE OF RECOGNIZED CHARACTERS
;	   ELSE SET TO MINUS 1
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
 
CHR$CVT::				; CONVERT TO UPPER CASE
	CMPB	(R6),#<^A/A/+^X20>	; LOWER CASE A?
	BLSS	CHR$TSTCHR		; BR IF NOT LOWER
	CMPB	(R6),#<^A/Z/+^X20>	; LOWER CASE Z?
	BGTR	CHR$TSTCHR		; BR IF NOT LOWER
	SUBB	#^X20,(R6)		; CONVERT TO UPPER
	BRB	CHR$TSTCHR		;
 
CHR$TSTNXT::				; TEST NEXT CHAR
	INCL	R6			; ADD ONE TI ADDRESS
 
CHR$TSTCHR::				; TEST A CHARACTER FOR CLASS
	CLRL	R0			; ASSUME END-OF-LINE
	TSTB	(R6)			; END-OF-LINE?
	BEQL	90$			; BR IF YES
	INCL	R0			; SET TYPE TO ALPHA
	CMPB	(R6),#^A/A/		; CHECK AGAINST LOW LIMIT
	BLSSU	20$			; BR IF BELOW ALPHA
	CMPB	(R6),#^A/Z/		; NOW CHECK HI END
	BLEQ	90$			; BR IF ALPHA
	CMPB	(R6),#<^A/A/+^X20>	; CHECK FOR LOWER CASE ALPHA
	BLSS	20$			; BR IF NO
	CMPB	(R6),#<^A/Z/+^X20>	; OTHER LIMIT
	BLEQ	90$			; FOUND THE CLASS
20$:	PUSHL	S^#CHR$K_NUMERIC	; SET VALUE FOR NUMERIC CHARATERS
	LOCC	(R6),#SPCNUMSIZ,SPCNUM	; CHECK FOR SPECIAL NUMERIC CHARACTERS
	POPR	#^M<R0>			; GET VALUE FOR NUMERIC CHARACTER
	BNEQ	90$			; BR IF CHARACTER IS SPECIAL NUMERIC
	CMPB	(R6),#^A/0/		; CHECK LOW LIMIT
	BLSS	30$			; BR IF NOT NUMERIC
	CMPB	(R6),#^A/9/		; WHAT ABOUT THE HI LIMIT
	BLEQ	90$			; BR IF NUMERIC
30$:	LOCC	(R6),#CHRTBLSIZ,CHRTBL	; CHECK IF ONE OF SPECIALS
	BNEQ	90$			; BR IF YES
	MOVL	#CHR$K_BLANK,R0		; ASSUME TAB
	CMPB	(R6),#^A/	/	; IS IT A TAB?
	BEQL	90$			; BR IF YES
	MOVL	#CHR$K_LBRAKT,R0	; ASSUME LEFT BRACKET
	CMPB	(R6),#^A/</		; IS IT THE FUNNY BRAKET?
	BEQL	90$			; BR IF YES
	INCL	R0			; CHANGE CODE TO RIGHT BRACKET
	CMPB	(R6),#^A/>/		; CHECK CLOSE BRAKET
	BEQL	90$			; BR IF YES
	MNEGL	#1,R0			; SET AS GENERAL SPECIAL
90$:	TSTL	R0			; SET STATUS BASED ON VALUE
	RSB				;


	.SBTTL	GET TOKEN
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PARSE THE NEXT TOKEN FROM THE
;	COMMAND LINE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	CHR$GETOKEN		; GET TOKEN FROM LINE
;	BSB/JSB	CHR$NXTOKEN		; TOKEN AFTER NEXT CHARACTER
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS ADDRESS OF NEXT BYTE ON THE LINE
;
; IMPLICIT INPUTS:
;
;	STRING IS TERMINATED BY ZERO BYTE
;
; OUTPUT PARAMETERS:
;
;	R6 IS ADVANCED TO THE FIRST NONE BLANK CHARACTER AFTER THE TOKEN.
;	R3,R4 ARE A DESCRIPTOR TO THE TOKEN
;
; IMPLICIT OUTPUTS:
;
;	"Z" BIT IS SET IF ZERO LENGTH TOKEN IS PARSED.
;
; COMPLETION CODES:
;
;	R0 IS SET TO THE TYPE OF THE CHARACTER
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENABL	LSB
 
CHR$GETOKEN::				; GET TOKEN
	DECL	R6			; BACK UP ONE FOR SKIP
CHR$NXTOKEN::				; TOKEN FOLLOWING CURRENT CHAR
	BSBB	CHR$NXTNBLK		; FIND NON-BLANK
	MOVAB	(R6),R4			; SET START ADDRESS OF TOKEN
	DECL	R6			; BACK UP SO SKIP WILL START HERE
10$:	MOVAB	1(R6),R3		; SET ADDRESS OF NEXT BYTE
	BSBB	CHR$TSTNXT		; LOOK AT NEXT CHAR
	BEQL	40$			; BR ON END OF LINE
	CMPB	R0,#CHR$K_BLANK		; VALID CHARACTER FOR TOKEN?
	BLSSU	10$			; IF LSSU YES-KEEP LOOKING FOR TERMIATOR
	BNEQ	40$			; BR IF NOT A SPACE
	BSBB	CHR$NXTNBLK		; SKIP TO NON-BLANK
40$:	SUBL	R4,R3			; FIND LENGTH OF TOKEN
50$:	RSB				; GET OUT

	.DSABL	LSB
	.SBTTL	SET NONE BLANK
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ADVANCE THE CHARACTER POINTER
;	TO  THE FIRST NONE BLANK CHARATER ON THE LINE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	CHR$SETNB		; SET NONE BLANK
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS ADDRESS OF NEXT BYTE ON THE LINE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R6 IS ADVANCED TO THE FIRST NONE BLANK CHARACTER
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 = 1 IF MORE DATA ON LINE, 0 IS NO NONE BLANK CHARACTERS
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENABL	LSB
 
CHR$SETNBLK::				; SET NONE BLANK
	DECL	R6			; BACK UP SO SKIP ONE WILL BE NOP
CHR$NXTNBLK::				; SKIP THEN-THEN NEXT NONE BLANK
20$:	BSBW	CHR$TSTNXT		;
	BEQL	40$			; BR IF END-OF-LINE
	CMPB	R0,#CHR$K_BLANK		; NEXT CHAR BLANK
	BEQL	20$			; IF YES-KEEP LOOKING
	MOVL	#1,R0			; SUCESS
40$:	RSB				; ALL DONE
 
	.DSABL	LSB
	.END
