	.TITLE	QUEMAN - QUEUE MANAGER UTILITY
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITY PROGRAMS
;
; ABSTRACT:	INIT,START,STOP AND DELETE JOB CONTROLLER QUEUES
;
;
; ENVIRONMENT:	NATIVE/USER MODE NON-PRIVILEGED CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 21-SEP-1977
;
; MODIFIED BY:
;
;	V03-001	MLJ0082		Martin L. Jack,	15-Mar-1982  16:59
;		Correct severity of $STATUS.  Fix time conversion problem
;		introduced by V02-009.
;
;	V02-009	MLJ0070		Martin L. Jack,	17-Jan-1982  18:14
;		$PURGWS before executing SYNCHRONIZE command.  Clean up unused
;		variables.  Incorporate standard queue name translation.
;
;	V02-008	MLJ35309	Martin L. Jack,	8-Jan-1982  17:37
;		Implement START/QUEUE/NODISABLE.
;
;	V02-007	GWF0114		Gary Fowler		28-Oct-1981
;		Add WS Extent
;
;	V02-006	GWF0099		Gary Fowler		13-Aug-1981
;		Make job name an ASCIC string.
;
;	V02-005	GWF0059		Gary Fowler		10-Jun-1981
;		Allow queue name to be specified on /REQUEUE
;		Add routine to process priority on /REQUEUE command
;
;	V02-004	GWF0054		Gary Fowler		01-Jun-1981
;		Clear inhibit message bit in status code returned from job
;		controller.
;
;	V02-003	LMK0001		Len Kawell		30-Dec-1979
;		Add /CHARACTERISTICS and /PROCESS action routines.
;
;	V02-002	GWF0001		Gary Fowler		04-Oct-1979
;		Add action routines to process /WSDEF, /WSQUO, /CPUDEF,
;		and /CPUMAX qualifiers.
;
;	V02-001	TMH0001		T. Halvorsen 08-Nov-1978
;		Removed unused 2nd arg from DEF_TAG in QMN$CTXBLK.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDED FILES:
;
; MACROS:
;
; MACRO TO SET AN OPTION INTO THE MESSAGE
;
	.MACRO	SETOPT	VAL,TYPE=B
	BSB'TYPE	QMN_SETOPT
	.BYTE	SMO$K_'VAL
	.ENDM

;
; MACRO TO SET AN OPTION INTO THE MESSAGE THAT MUST BE EXPLICITLY STATED
;
	.MACRO	SETEXPOPT  VAL,TYPE=B
	BSB'TYPE	QMN_SETEXPOPT
	.BYTE	SMO$K_'VAL
	.ENDM
 
;
; EQUATED SYMBOLS:
;
; MACRO LIBRARY CALLS
;
	$CLIDEF				; CLI DEFINITIONS
	$CLIVERBDEF			; VERB CODES
	$STSDEF				; STATUS LONGWORD VALUES
	$MSGDEF				; SYSTEM MESSAGE CODES
	$SMRDEF				; SYMBIONT MANAGER REQUESTS
	$CLIMSGDEF			; CLI MESSAGES
	.MACRO	$CLIMSGDEF
	.ENDM
	QMNBITS				; DEFINE QUEUE MANAGER BITS
;
; OWN STORAGE:
;
	IMPURE_DATA
 
;
; MACRO TO GENERATE LOCAL CONTEX FOR QUEMAN
;
 
    DEF_CTXBLK	QMN$CTXBLK,ALLOCATE=YES ; DEFINE START OF CONTEXT BLOCK
	DEF_ELE	QMN_L_STATUS		; SAVE AREA FOR FINAL STATUS
	DEF_ELE	QMN_L_MSGPTR		; POINTER TO NEXT BYTE IN MESSAGE
	DEF_ELE	QMN_Q_SYNQUE		; Queue name for SYNC command
	DEF_ELE	QMN_Q_IOSB,Q		; IO STATUS BLOCK
	DEF_ELE	QMN_B_CMDTYP,B		; COMMAND TYPE BYTE
	DEF_ELE	QMN_B_SPARE,B		; SPARE BYTE
	DEF_ELE	QMN_W_RSPCHAN,W		; CHANNEL FOR MAILBOX RESPONCES
    DEF_CTXEND
 
;
; DEFINE CALL BACK DATA STRUCTURES
;
 
CLIWORK:.LONG	QMN$CTXBLK
	.BLKB	CLI$C_WORKAREA-4	; RESULT PARSE WORK AREA
 
BITMAP:	.BLKL	1			; BIT MASK AREA
 
INITPRS:$CLIREQDESC	CLI$K_INITPRS,-	; CALLBACK REQUEST DESCRIPTOR FOR INIT
		ERRACT=QMN$CMDERR	;
 
GETCMD: $CLIREQDESC	CLI$K_GETCMD,-	; CALLBACK FOR COMMAND
		ERRACT=QMN$CMDERR	;
 
PARSDON: $CLIREQDESC	CLI$K_ENDPRM1,-	; REQUEST DESCRIPTOR FOR PARSE DONE
		ERRACT=QMN$CMDERR	; ERROR ACTION ROUTINE FOR COMD DONE
 
NUMVAL:	$CLIREQDESC	CLI$K_NUMERVAL	; DESCRIPTOR FOR NUMERIC VALUE CONVERT
 
ASCIIVAL: $CLIREQDESC	CLI$K_ASCIIVAL	; DESCRIPTOR FOR ASCII VALUE CONVERT

INPDESC: $CLIREQDESC	-		; REQUEST DESCRIPTOR FOR INPUT PARAMETER
		RQTYPE=CLI$K_INPUT1,-	; REQUEST PRIMARY INPUT
		ERRACT=QMN$CMDERR	; COMMAND PROCESSING ERROR ACTION
 
GETQUAL: $CLIREQDESC	-		; REQUEST DESCRIPTOR FOR CMD QUALS
		RQTYPE=CLI$K_GETQUAL,-	; REQUEST COMMAND QUALS
		ERRACT=QMN$CMDERR	; COMMAND PROCESSING ERROR ACTION
 
;
; ALLOCATE MESSAGE BUFFER FOR SEND MESSAGE TO SYMBIONT MANAGER
;
 
 
MESSAG:	.BLKB	18			; Space for message
OPTIONS:.BLKB	1024-18			; SPACE FOR OPTIONS
;
;
 
	PURE_SECTION
DEFQUE:	.ASCID	\SYS$BATCH\		;
;
; THE FOLLOWING DATA STRUCTURES ARE ORDER DEPENDENT
;
CMDLST:					; START OF COMMAND TYPE TABLE
MAXCMD = 7				; HIGHEST COMMAND NUMBER USED
	.BYTE	CLI$K_VERB_DEAS		; COMMAND 7 = DEASSIGN QUEUE
DEASCMD = 7				;
	.BYTE	CLI$K_VERB_ASSI		; COMMAND 6  =  ASSIGN QUEUE
ASSICMD = 6
	.BYTE	CLI$K_VERB_SYNC		; COMMAND 5 = SYNC
SYNCCMD = 5				;
	.BYTE	CLI$K_VERB_DELE		; COMMAND 4 = DELETE
DELECMD = 4				;
	.BYTE	CLI$K_VERB_STOP		; COMMAND 3 = STOP
STOPCMD = 3				;
	.BYTE	CLI$K_VERB_STAR		; COMMAND 2 = START
STARCMD = 2				;
	.BYTE	CLI$K_VERB_INIT		; COMMAND 1 = INITIALIZE
INITCMD = 1				;
SMRCODE:.BYTE	SMR$K_INITIAL		; REQUEST IS INITIALIZE
	.BYTE	SMR$K_START		; START DEQUEUING
	.BYTE	SMR$K_PAUSE		; THE DEFAULT FOR STOP IS PAUSE
	.BYTE	SMR$K_DELETE		; DELETE THE QUEUE
	.BYTE	SMR$K_SYNCJOB		; WAIT FOR JOB
	.BYTE	SMR$K_REDIRECT		; ASSIGN IS A REDIRECT
	.BYTE	SMR$K_REDIRECT		; LIKEWUSE FOR DEASSIGN
 
;
; THE FOLLOWING TABLE CONTAINS THE OFFSET TO QUALIFIER LISTS
;
 
PRMQUAL:.LONG	INI$G_QUALS-INPDESC	; POINTER FOR INIT QUALIFIER LIST
	.LONG	STA$G_QUALS-INPDESC	; POINTER FOR START QUALIFIER LIST
	.LONG	STO$G_QUALS-INPDESC	; POINTER FOR STOP QUALIFIER LIST
	.LONG	DEL$G_QUALS-INPDESC	; AND FOR DELETE
	.LONG	0			; NO PARAMETER QUALIFIERS FOR SYNC
	.LONG	ASS$G_QUALS-INPDESC	; QUALIFERS FOR ASSIGN
	.LONG	DEA$G_QUALS-INPDESC	; AND DEASSIGN
 
;
; THE FOLLOWING TABLE CONTAINS ADDRESS FOR COMMAND QUALIFIERS
;
 
CMDQUAL:.LONG	0			; NO COMMAND QUALIFIERS FOR INIT
	.LONG	0			; OR START
	.LONG	0			; OR STOP
	.LONG	0			; OR DELETE
	.LONG	SYN$G_QUALS-GETQUAL	; COMMAND QUALIFIERS FOR SYNC
	.LONG	0,0			; NONE FOR ASSIGN OR DEASSIGN
 
;
; THE FOLLOWING TABLE CONTAINS THE COMPONENT NAMES USED FOR PRINTING MESSAGES
;
 
NAMES:	.ASCIC	\INITQ\
	.ASCIC	\STARTQ\
	.ASCIC	\STOPQ\
	.ASCIC	\DELETQ\
	.ASCIC	\SYNC\
	.ASCIC	\ASNQUE\
	.ASCIC	\DEAQUE\
	.BYTE	0			; END OF LIST
 
;
; THE FOLLOWING TABLE CONTAINS A NON-ZERO ENTRY FOR A COMMAND THAT CHANGES
; SYMANTICS WHEN AN ENTRY QUALIFIER APPEARS ON THE COMMAND.
;
ENTRYFCN:				; SYMBIONT MANAGER FUNCTION VS COMMAND
	.BYTE	0		; NO CHAHGE TO INIT
	.BYTE	0		; OR START QUEUE
	.BYTE	SMR$K_ABORT	; STOP/ENTRY IS AN ABORT OF A BATCH JOB
	.BYTE	SMR$K_RMVJOB	; DELETE/ENTRY IS REMOVE JOB FROM QUEUE
	.BYTE	0		; SYNC IS NO CHANGE
	.BYTE	0		; ASSIGN IS LIKEWISW
	.BYTE	0		; AND ALSO DEASSIGN
;
; Following descriptor for $PURGWS.
;
QMN_ADDESC:
	.LONG	0		; Purge entire working set
	.LONG	^X7FFFFFFF

	.SBTTL	QUEUE MANAGER UTILITY
;++
; FUNCTIONAL DESCRIPTION:
; 
;	THIS IMAGE IS ACTIVATED TO PERFORM ANY OF THE OPERATOR
;	ORIENTED QUEUE FUNCTIONS.
; 
; CALLING SEQUENCE:
; 
;	ACTIVATED BY "CLI" 
; 
; INPUT PARAMETERS:
; 
;	CALL BACK ADDRESS AT "CLI$A_ULTISERV" OFF OF "AP"
; 
; IMPLICIT INPUTS:
; 
;	NONE
; 
; OUTPUT PARAMETERS:
; 
; 	NONE
; 
; IMPLICIT OUTPUTS:
; 
; 	NONE
; 
; COMPLETION CODES:
; 
; 	NONE
; 
; SIDE EFFECTS:
; 
; 	NONE
; 
;--
 
	.ENTRY	QUEMAN,0		;
	MOVAB	W^QMN$CTXBLK,R11	; SET CONTEX BLOCK
	MOVL	#1,QMN_L_STATUS(R11)	; Initialize status
	MOVQ	W^DEFQUE,QMN_Q_SYNQUE(R11) ; Default SYNC queue name
	$CREMBX_S	-		; CREATE A MAILBOX
		PROMSK	= #0,-		; NO PROTECTION
		MAXMSG	= #32,-		; BIGEST MESSAGE EVER
		BUFQUO	= #64,-		; ENOUGH BUFFER FOR 2 MESSAGES
		PRMFLG	= #0,-		; NON PERMANENT
		CHAN=QMN_W_RSPCHAN(R11)	; CHANNEL ASSIGNED RETURNED HERE
	BLBC	R0,10$			; BR IF ERROR CREATING MAILBOX
	MOVAB	W^INITPRS,R0		; REQUEST DESCRIPTOR
	BSBW	CALBAK			; DO CALLBACK
	MOVAB	W^GETCMD,R0		; REQUEST FOR COMMMAND
	BSBW	CALBAK			; REQUEST THAT INFO FROM CLI
	LOCC	W^GETCMD+CLI$B_RQSTAT,-	; CHECK COMMAND VERB TYPE AGAINST-
		#MAXCMD,CMDLST		; COMMANDS UNDERSTOOD BY THIS IMAGE
	BNEQ	20$			; BR IF MATCHED
10$:	RET				; RETURN WITH THIS ERROR
20$:	MOVB	R0,QMN_B_CMDTYP(R11)	; SAVE COMMAND TYPE
	MOVAB	W^MESSAG,R8		; SET MESSAGE BUFFER ADDRESS
	MOVZBW	SMRCODE-1[R0],(R8)	; SET DEFAULT REQUEST CODE
	MOVAB	18(R8),-		; SET ADDRESS TO STORE FIRST OPTION
		QMN_L_MSGPTR(R11)	; AS THE CUURENT END OF MESSAGE
	MOVL	CMDQUAL-4[R0],R1	; GET COMMAND QUALIFIER LIST ADDRESS
	BEQL	30$			; BR IF NONE
	MOVAB	W^GETQUAL,R0		; ADDRESS OF COMMAND QUALIFIERS
	MOVL	R1,CLI$A_QUALST(R0)	; SET ADDRESS OF QUALIFIERS
	BSBW	CALBAK			; REQUEST THE QUALIFIERS
30$:	MOVZBL	QMN_B_CMDTYP(R11),R0	; RESTORE COMMAND TYPE
	MOVAB	W^INPDESC,R2		; REQUEST DESCRIPTOR
	MOVL	PRMQUAL-4[R0],CLI$A_QUALST(R2) ; SET PROPER QUALIFIERS
	MOVL	R2,R0			; COPY ADDRESS OF REQUEST DESCRIPTOR
	BSBW	CALBAK			; ISSUE RESULT PARSE CALL BACK
	BLBS	QMN_L_STATUS(R11),40$	; BR IF NO ERRORS PARSING THE COMMAND
	BRW	RETCLI			; ELSE RETURN TO CLI
40$:	CMPB	#SYNCCMD,QMN_B_CMDTYP(R11) ; IS COMMAND SYNC FOR BATCH JOB
	BNEQ	45$			; BR IF NO
	MOVQ	CLI$Q_RQDESC(R2),R0	; Get descriptor for job name
	CMPL	R0,#9			; Limit to 9 characters
	BLEQU	41$			; Br if all right
	MOVL	#9,R0			;
41$:	MOVB	R0,20(R8)		; STORE COUNT
	MOVC5	R0,(R1),#0,#9,21(R8)	; Move job name to message
	PUSHAB	2(R8)			; Point to result area
	PUSHAQ	QMN_Q_SYNQUE(R11)	; Point to queue name
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	MOVAB	30(R8),QMN_L_MSGPTR(R11); Set end of message
	BLBS	R0,60$			; Br if successful
	PUSHAQ	QMN_Q_SYNQUE(R11)	; Point to parameter descriptor
	PUSHL	#1			; FAO argument count
	PUSHL	#SHR$_BADQNAME!<3@16>	; Message code
	PUSHL	#3			; Parameter list length
	BRW	SHOW_MSG		; Issue message
45$:	PUSHAB	2(R8)			; Point to result area
	PUSHAQ	CLI$Q_RQDESC(R2)	; Point to parameter descriptor
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	BLBS	R0,50$			; Br if successful
	PUSHAQ	CLI$Q_RQDESC(R2)	; Point to parameter descriptor
	PUSHL	#1			; FAO argument count
	PUSHL	#SHR$_BADQNAME!<3@16>	; Message code
	PUSHL	#3			; Parameter list length
	BRW	SHOW_MSG		; Issue message
50$:	CMPB	#DEASCMD,QMN_B_CMDTYP(R11) ; CHECK IF DEASSIGN
	BNEQ	55$			; BR IF NO
	CLRQ	18(R8)			; Clear second queue name
	CLRQ	26(R8)			;
	MOVAB	34(R8),QMN_L_MSGPTR(R11);
	BRB	60$			; Go to issue request
55$:	CMPB	#ASSICMD,QMN_B_CMDTYP(R11) ; CHECK IF ASSIGN
	BNEQ	60$			; Br if no
	MOVAB	W^INPDESC,R0		; GET INPUT DESCRIPTOR
	ASSUME	CLI$K_INPUT2 EQ CLI$K_INPUT1+1
	INCB	CLI$B_RQTYPE(R0)	; CHANGE REQUEST TO SECONDARY INPUT
	BSBW	CALBAK			; REQUEST SECOND PARAMETER
	PUSHAB	18(R8)			; Point to result area
	PUSHAQ	CLI$Q_RQDESC(R2)	; Point to parameter descriptor
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	MOVAB	34(R8),QMN_L_MSGPTR(R11); Point to end
	BLBS	R0,60$			; Br if successful
	PUSHAQ	CLI$Q_RQDESC(R2)	; Point to parameter descriptor
	PUSHL	#1			; FAO argument count
	PUSHL	#SHR$_BADQNAME!<3@16>	; Message code
	PUSHL	#3			; Parameter list length
	BRW	SHOW_MSG		; Issue message
60$:	PUSHAB	W^MESSAG		; FIRST BYTE IN MESSAGE
	SUBL3	(SP),QMN_L_MSGPTR(R11),-(SP) ; FIND LENGTH OF MESSAGE
	MOVZWL	QMN_W_RSPCHAN(R11),-(SP) ; RESPONCE CHANNEL
	PUSHAQ	4(SP)			; ADDRESS OF MESSAGE DESCRIPTOR
	CALLS	#4,@#SYS$SNDSMB		; SEND A MESSAGE TO SYMBIONT MANAGER
	BLBC	R0,RETCLI0		; EXIT WITH ERROR
	CMPB	#SYNCCMD,QMN_B_CMDTYP(R11) ; Was command SYNC
	BNEQ	61$			; Br if no
	$PURGWS_S INADR=QMN_ADDESC	; Purge working set for long wait
61$:	MOVAQ	-(SP),R0		; Allocate response buffer, addr to R0
	$QIOW_S	#0,QMN_W_RSPCHAN(R11),#IO$_READVBLK,-
		QMN_Q_IOSB(R11),,,(R0),#8
	ADDL2	#4,SP			; Discard first longword
	POPL	R0			; GET FINAL STATUS
	BBSC	#STS$V_INHIB_MSG,R0,62$	; CLEAR INHIBIT MESSAGE BIT
62$:	MOVL	R0,QMN_L_STATUS(R11)	; SAVE FINAL STATUS
	BLBC	R0,RETCLI0		; RETURN TO CLI
	CMPB	#DELECMD,QMN_B_CMDTYP(R11) ; WAS COMMAND DELETE
	BNEQ	70$			; BR IF NO
	MOVAB	W^QMN$G_DELE_ENTR,R0	; GET ADDRESS OF REQUEST DESCRIPTOR
	TSTW	CLI$W_RQSIZE(R0)	; ANY VALUES REMAIN?
	BEQL	70$			; BR IF NO
	MOVAB	W^OPTIONS,QMN_L_MSGPTR(R11) ; RESET MESSAGE POINTER
	PUSHL	CLI$A_UTILSERV(AP)	; CLI CALL BACK ADDRESS
	PUSHL	R0			; ADDRESS OF QUALIFIER DESCRIPTOR
	CALLS	#2,QMN_ENTRYNUM		; DO A CALL BACK
	BLBC	QMN_L_STATUS(R11),70$	; BR IF ERROR CONVERTING VALUE
	BRW	60$			;
70$:	MOVAB	W^PARSDON,R0		; REQUEST DESCRIPTOR
	BSBB	CALBAK			; REQUEST PARSE TERMINATION
RETCLI:	MOVL	QMN_L_STATUS(R11),R0	; GET FINAL STATUS
RETCLI0:RET				;

;+
; CALNVAL - CALL FOR NUMERIC VALUE
;
; CALLBAK - ISSUE GENERAL CALL BACK TO CLI
;
; LOCAL SUBROUTINES TO ISSUE CALL BACK TO CLI
;
; INPUTS:
;
;	4(AP) = ADDRESS OF QUALIFIER DESCRIPTOR (CALNVAL,CALAVAL)
;	R0    = ADDRESS OF REQUEST DESCRIPTOR   (CALBAK)
;
; OUTPUT:	NONE
;
; SIDE EFFECTS:
;
;	FOR NUMERIC VALUE CONVERSION, IF ERROR IS DETECTED, A MESSAGE 
;	IS DISPLAYED AND RETURN TO THE CALLER IS ISSUED.
;-
	.ENABL	LSB
 
CALAVAL:PUSHAB	@4(AP)			; PUSH QUALIFIER DESCRIPTOR ADDRESS
	MOVAB	W^ASCIIVAL,R0		; GET REQUEST DESCRIPTOR ADDRESS
	BRB	10$			; EXECUTE CALL BACK IN COMMON CODE
CALNVAL:PUSHAB	B^5$			; SET SUBROUTINE RETURN ADDRESS
	PUSHAB	@4(AP)			; PUSH QUALIFIER DESCRIPTOR
	MOVAB	W^NUMVAL,R0		; GET REQUEST DESCRIPTOR
	BRB	10$			; EXECUTE CALL BACK IN COMMON CODE
5$:	MOVL	W^NUMVAL+CLI$L_RQVALU,R1 ; GET THE CONVERTED VALUE
	MOVL	QMN_L_MSGPTR(R11),R2	; GET ADR OF NEXT BYTE IN MESSAGE
	BLBS	R0,30$			; BR IF NO ERROR
VALER1:	BRW	VALERR			; PRINT THE ERROR
 
CALBAK:	PUSHAB	W^BITMAP		; LAST ARGUMENT IN CALL BACK
10$:	PUSHAB	W^CLIWORK		; WORK AREA IS ALWAYS SECOND
	PUSHAB	(R0)			; REQUEST DESCRIPTOR IS ALWAYS FIRST
	CALLS	#3,@CLI$A_UTILSERV(AP)	; GO TO UTILITY SERVICE ROUTINE
30$:	RSB
 
	.DSABL	LSB

	.SBTTL	QUALIFIER ACTION ROUTINES
;+
; QUALIFIER ACTION ROUTINES
;
; THE FOLLOWING ROUTINES ARE ENTERED DIRECTLY FORM THE CLI RESULT PARSE
; ROUTINE AS THE RESULT OF A SPECFIC QUALIFIER.
;
; THE NECESSARY ACTION IS TAKEN AND CONTROL IS RETURN TO THE RESULT PARSER.
;-
	.ENABL	LSB
 
	.ENTRY	QMN_FORMS,^M<R2>	; FORMS TYPE SPECIFIED
	MOVL	4(AP),R0		; GET QUALIFIER DESCRIPTOR
	PUSHAL	CLI$Q_QDVALDESC(R0)	; PUSH ADDRESS OF FORM STRING
	MOVQ	CLI$Q_QDVALDESC(R0),R2	; SET STRING DESCRIPTOR IN CASE OF ERROR
	CALLS	#1,LIB$CNVCLIFORMS	; CHANGE FORMS ASCII TO BINARY
	BLBC	R0,VALER1		; ERROR IN FORMS TYPE
	MOVL	QMN_L_MSGPTR(R11),R2	; SET POINTER INTO DATA MESSAGE
	MOVB	#SMO$K_CURFORM,(R2)+	; STORE FORMS TYPE OPTION FLAG
	BRB	30$			; COMMON CODE WITH JOB LIMIT
 
	.ENTRY	QMN_PRIO,^M<R2>		; SPECIFY PRIORITY ON REQUEUE
	BSBB	10$			; COMMON CODE
	.BYTE	SMO$K_REQPRIO		; OPTION CODE

	.ENTRY	QMN_BATPRI,^M<R2>	; INITIAL BATCH PRIORITY
	BSBB	10$			; COMMON CODE
	.BYTE	SMO$K_INIPRI		; INITIAL PRIORITY
 
	.ENTRY	QMN_JOBCOUNT,^M<R2>	; JOB COUNT QUALIFIER
	BSBB	10$			; EXECUTE IN COMMON CODE
	.BYTE	SMO$K_JOBLIM		; OPTION FLAG WORD
10$:	BSBB	CALNVAL			; CALL FOR NUMERIC VALUE
	MOVB	@(SP)+,(R2)+		; STORE FLAG FOR OPTION
30$:	MOVB	R1,(R2)+		; NOW THE DATA
	MOVL	R2,QMN_L_MSGPTR(R11)	; SET ADJUSTED MESSAGE POINTER
	RET
 
	.ENABL	LSB
 
	.ENTRY	QMN_BACKSPACE,^M<R2>	; RESTART-BACKING UP
	BSBB	CALNVAL			; GET NUMERIC VALUE
	MNEGL	R1,R1			; COMPLEMENT THE DATA
	BRB	5$			; JOIN COMMON CODE
 
	.ENTRY	QMN_FWRDSPACE,^M<R2>	; SPACE THE LISTING FORWARD
	BSBB	CALNVAL			; GET A NUMERIC VALUE
5$:	MOVB	#SMO$K_SPCCNT,(R2)+	; STORE OPTION FLAG
	MOVW	R1,(R2)+		; STORE SPACE COUNT
	BRB	40$			; TAKE COMMON EXIT
10$:	BSBB	CALNVAL			; CALL FOR NUMERIC VALUE
20$:	MOVB	@(SP)+,(R2)+		; STORE FLAG FOR OPTION CODE
30$:	MOVB	R1,(R2)+		; NOW THE DATA
40$:	MOVL	R2,QMN_L_MSGPTR(R11)	; SET ADJUSTED MESSAGE POINTER
	RET
 
	.DSABL	LSB
 
	.ENTRY	QMN_NEXTJOB,^M<>	; RESTART - ABORTING CURRENT JOB
	SETOPT		NEXTJOB		; OPTION CODE
 
	.ENTRY	QMN_NOSWAP,^M<>		; DISABLE SWAPPING
	SETEXPOPT	DISWAP		; OPTION CODE
 
	.ENTRY	QMN_SWAP,^M<>		; ENABLE SWAPPING
	SETEXPOPT	NODISWAP	; OPTION CODE
 
	.ENTRY	QMN_TOPOFILE,^M<>	; RESTART-STARTING FILE OVER
	SETOPT		TOPOFILE	; SYMBIONT MANAGER OPTION CODE
 
	.ENTRY	QMN_BATCH,^M<>		; QUEUE IS FOR BATCH JOBS
	SETOPT		DETJOB		; QUEUE IS FOR DETACHED JOBS
 
	.ENTRY	QMN_BURST,^M<>		; QUEUE GETS BURST PAGE BY DEFAULT
	SETEXPOPT	DEFBRST		; DEFAULT A BURST PAGE
 
	.ENTRY	QMN_NOBRST,^M<>		; QUEUE GETS NO BURST PAGE BY DEFAULT
	SETEXPOPT	NODEFBRST	; SYMBIONT MANAGER OPTION CODE
 
	.ENTRY	QMN_GENPRT,^M<>		; GENERIC PRINTING ALLOWED
	SETEXPOPT	GENPRT		; SYMBIONT MANAGER OPTION CODE
 
	.ENTRY	QMN_NOGENPRT,^M<>	; GENERIC PRINTING NOT PERMITTED
	SETEXPOPT	NOGENPRT	; SYMBIONT MANAGER OPTION CODE
 
	.ENTRY	QMN_FLAG,^M<>		; JOBS GET FLAG PAGE BY DEFAULT
	SETEXPOPT	DEFFLAG		; DEFAULT A FLAG PAGE
 
	.ENTRY	QMN_NOFLAG,^M<>		; NO DEFAULT FLAG
	SETEXPOPT	NODEFFLAG	; SYMBIONT MANAGER OPTION CODE
 
	.ENTRY	QMN_GENERIC,^M<>	; QUEUE IS FOR GENERIC
	SETEXPOPT	GENDEV		; DEVICE IS GENERIC
 
	.ENTRY	QMN_NOGENDEV,^M<>	; DEVICE IS NOT GENERIC
	SETEXPOPT	NOGENDEV	; NOT A GENERIC DEVICE
 
	.ENTRY	QMN_TERMDEV,^M<>	; DEVICE IS A TERMINAL
	SETEXPOPT	TRMDEV		;
 
	.ENTRY	QMN_NOTERM,^M<>		; DEVICE IS NOT A TERMINAL
	SETEXPOPT	NOTRMDEV	;
 
	.ENABL	LSB
 
QMN_SETEXPOPT:				;
	MOVL	4(AP),R1		; GET THE QUALIFIER DESCRIPTOR
	BBC	#CLI$V_QUALEXP,CLI$B_QDSTAT(R1),10$ ; BR IF NOT EXPLICITLY STATED
QMN_SETOPT:				; SET OPTION VALUE
	MOVB	@(SP)+,-		; GET OPTION BYTE
		@QMN_L_MSGPTR(R11)	; AND STORE IN MESSAGE
	INCL	QMN_L_MSGPTR(R11)	; AJUST POINTER FOR BYTE STORED
10$:	RET				; ALL DONE

	.DSABL	LSB
 
	.ENTRY	QMN_REQUEUE,^M<R2,R3,R4,R5> ; ABORT THEN REQUEUE THE JOB
	MOVW	#SMR$K_ABORT,W^MESSAG	; SET ABORT FUNCTION
	MOVL	QMN_L_MSGPTR(R11),R3	; GET POINTER INTO MESSAGE
	MOVB	#SMO$K_REQUEUE,(R3)+	; SET REQUEUE OPTION CODE IN MESSAGE
	MOVL	4(AP),R4		; GET QUALIFIER VALUE DESCRIPTOR
	MOVZWL	CLI$W_QDVALSIZ(R4),R1	; GET SIZE OF VALUE
	BEQL	10$			; IF EQL - THEN NO QUEUE NAME SPECIFIED
	MOVB	#SMO$K_REQDEST,(R3)+	; SET OPTION CODE IN MESSAGE
	PUSHAB	(R3)			; Point to result area
	ADDL2	#16,R3			; Advance over result area
	PUSHAQ	CLI$Q_QDVALDESC(R4)	; Point to queue name
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	BLBS	R0,10$			; Br if successful
	PUSHAQ	CLI$Q_QDVALDESC(R4)	; Point to parameter descriptor
	PUSHL	#1			; FAO argument count
	PUSHL	#SHR$_BADQNAME!<3@16>	; Message code
	PUSHL	#3			; Parameter list length
	BRW	SHOW_MSG		; Issue message
10$:	MOVL	R3,QMN_L_MSGPTR(R11)	; SAVE POINTER INTO MESSAGE
	RET				; RETURN

 
;
; ENTRY SPECIFIED ON DELETE, THEREFORE IT IS A REMOVE JOB
;
	.ENTRY	QMN_ENTRYNUM,^M<R2,R3,R4,R5> ;
	BSBW	CALNVAL			; GET NUMERIC VALUE
	MOVW	R1,(R2)+		; STORE IT IN THE BUFFER
	MOVL	R2,QMN_L_MSGPTR(R11)	; UPDATE THE ADDRESS
	MOVZBL	QMN_B_CMDTYP(R11),R0	; GET CURRENT COMMAND TYPE
	MOVZBL	ENTRYFCN-1[R0],R0	; GET THE NEW FUNCTION CODE
	BEQL	20$			; BR IF NO CHANGE
	MOVW	R0,W^MESSAG		; SET SYMBIONT MANAGER FUNCTION CODE
20$:	RET				;
 
;
; ENTRY QUALIFIER IS FALSE FOR SYNC COMMAND
;
 
	.ENTRY	QMN_NOENTRY,^M<>	; ENTRY QUALIFER WAS FALSE
	CLRW	W^OPTIONS		; MAKE SURE ENTRY NUMBER IS ZERO
	RET				;
 
;
; QUEUE NAME SPECIFIED FOR SYNC COMMAND
;
 
	.ENTRY	QMN_QUEUENAM,^M<R2,R3,R4,R5> ; QUEUE NAME GIVEN
	MOVL	4(AP),R0		; GET QUEUE NAME QUALIFIER DESCRIPTOR
	MOVQ	CLI$Q_QDVALDESC(R0),QMN_Q_SYNQUE(R11) ; Save queue name
	RET				;
 
	.ENABL	LSB
 
;
; MERGE CONTENTS OF ONE QUEUE TO ANOTHER
;
 
	.ENTRY	QMN_MERGEQUE,0		;
	BSBB	10$			;
	.BYTE	SMR$K_MERGE		;
 
;
; STOP AFTER CURRENT JOB IS COMPLETE
;
 
	.ENTRY	QMN_NEXT,0		;
	BSBB	10$			; COMMON ROUTINE
	.BYTE	SMR$K_STOP		; REQUEST CODE
;
; ABORT THE PRINTER ACTION ROUTINE
;
	.ENTRY	QMN_ABORT,0		;
	BSBB	10$			;
	.BYTE	SMR$K_ABORT		; REQUEST ABORTING THE JOB
10$:	MOVZBW	@(SP)+,W^MESSAG		; SET FUNCTION ACCORDING TO THE OPTION
	RET				;
 
	.DSABL	LSB
;
; SYMBIONT PROCESS IMAGE NAME ACTION ROUTINE
;
	.ENTRY	QMN_PROC,^M<R2,R3,R4,R5>
	MOVL	4(AP),R0		; GET IMAGE NAME QUALIFIER DESCRIPTOR
	MOVL	QMN_L_MSGPTR(R11),R2	; SET POINTER INTO DATA MESSAGE
	MOVB	#SMO$K_SMBNAME,(R2)+	; STORE OPTION FLAG
	MOVZWL	CLI$W_QDVALSIZ(R0),R1	; GET LENGTH OF IMAGE NAME SUPPLIED
	CMPL	R1,#31			; STRING TOO LONG?
	BLEQU	10$			; IF LEQU, NO
	MOVL	#31,R1			; ELSE, TRUNCATE STRING
10$:	MOVB	R1,(R2)+		; SET LENGTH OF IMAGE NAME
	MOVC	R1,@CLI$A_QDVALADR(R0),(R2) ; SET STRING IN MESSAGE
	MOVL	R3,QMN_L_MSGPTR(R11)	; SET ADJUSTED MESSAGE POINTER
	RET				;
;
; WS DEFAULT AND WS QUOTA ACTION ROUTINES
;
	.ENABL	LSB

	.ENTRY	QMN_WSQUTA,^M<R2,R3,R4,R5>	; WS QUOTA
	BSBB	10$			; BR TO COMMON PROCESS
	.BYTE	SMO$K_WSQUTA		; OPTION FLAG

	.ENTRY	QMN_WSDEFLT,^M<R2,R3,R4,R5>	; WS DEFAULT
	BSBB	10$			; BR TO COMMON PROCESS
	.BYTE	SMO$K_WSDFLT		; OPTION FLAG

	.ENTRY	QMN_WSEXTNT,^M<R2,R3,R4,R5>	; WS EXTENT
	BSBB	10$			; BR TO COMMON PROCESS
	.BYTE	SMO$K_WSXTANT		; OPTION CODE

10$:	MOVL	4(AP),R0		; GET QUALIFIER DESCRIPTOR
	MOVQ	CLI$Q_QDVALDESC(R0),R4	; GET STRING DESCRIPTOR
	CMPL	#^A'NONE',(R5)		; CHECK IF "NONE"
	BEQL	30$			; BR TO NEGATE

	BSBW	CALNVAL			; CONVERT TO BINARY
	TSTL	R1			; TEST VALUE
	BEQL	30$			; IF 0 THEN SAME AS "NONE"
	BITL	#^X0FFFF0000,R1		; IN RANGE?
	BEQL	25$			; BR IF OK
	MOVL	4(AP),R0		; GET QUALIFIER DESC.
	MOVQ	R4,CLI$Q_QDVALDESC(R0)	; RESTORE STRING DESC.
	MOVL	#CLI$_ILLVAL,R0		; SET ERROR CODE
	BRW	VALERR
25$:	MOVB	@(SP)+,(R2)+		; STORE OPTION FLAG IN MSG.
	MOVW	R1,(R2)+		; STORE VALUE IN MSG.
	BRB	40$			; JOIN COMMON EXIT

30$:	MOVZBL	@(SP)+,R2		; GET OPTION CODE
	MOVZBL	#SMO$K_NOWSQUTA,R1	; ASSUME NO WS QUOTA
	CMPB	R2,#SMO$K_WSQUTA	; CHECK
	BEQL	35$			; IF EQ THEN CORRECT
	MOVZBL	#SMO$K_NOWSDFLT,R1	; ASSUME NO WS DEFAULT
	CMPB	R2,#SMO$K_WSDFLT	; CHECK
	BEQL	35$			; IF EQ THEN CORRECT
	MOVZBL	#SMO$K_NOWSXTNT,R1	; ALL THAT'S LEFT IS WS EXTENT
35$:	MOVL	QMN_L_MSGPTR(R11),R2	; GET POINTER INTO MSG.
	MOVB	R1,(R2)+		; STORE OPTION FLAG
40$:	MOVL	R2,QMN_L_MSGPTR(R11)	; UPDATE POINTER INTO MSG.
	MOVL	#1,R0			; SET SUCCESS
	RET
	.DSABL	LSB
;
; MAX CPU TIME AND DEFAULT CPU TIME LIMITS
;
	.ENABL	LSB

	.ENTRY	QMN_CPUDFT,^M<R2,R3,R4,R5>	; DEFAULT CPU TIME LIMIT
	BSBB	10$
	.BYTE	SMO$K_DCPULM		; OPTION FLAG

	.ENTRY	QMN_CPUMAX,^M<R2,R3,R4,R5>	; MAX CPU TIME LIMIT
	BSBB	10$			; BR TO COMMON CODE
	.BYTE	SMO$K_MCPULM		; OPTION FLAG

10$:	MOVL	4(AP),R0		; GET QUALIFIER DESC.
	MOVQ	CLI$Q_QDVALDESC(R0),R4	; GET STRING DESC.
	CMPL	#^A'NONE',(R5)		; CHECK IF "NONE"
	BEQL	30$			; BR IF YES - NEGATE QUALIFIER
	CMPL	#^A'INFI',(R5)		; CHECK IF "INFINITE"
	BNEQ	15$			; BR IF NOT
	CLRL	R4			; SET TIME = 0 = INIFINITE
	BRB	18$			; CONTINUE
;
; CONVERT ASCII STRING TO BINARY TIME
;
15$:	PUSHAQ	-(SP)			; PUSH ADDR. TO GET BINARY
	MOVL	4(AP),R0		; GET QUALIFIER DESC.
	PUSHAQ	CLI$Q_QDVALDESC(R0)	; PUSH ADDR. OF STRING DESC
	CALLS	#2,LIB$CVT_DTIME	; CONVERT THE TIME
	MOVQ	(SP)+,R4		; Get converted value
	BLBC	R0,16$			; BR IF ERROR CONVERTING IT
	MOVL	#CLI$_ILLVAL,R0		; ASSUME TIME VALUE IS BAD
	EDIV	#-20*10*1000,R4,R4,R5	; CONVERT TO LONG WORD
	BVC	17$			; BR IF IN RANGE
16$:	BRW	VALERR			; ELSE, ERROR
17$:	ASHL	#1,R4,R4		; MAKE IT UNSIGNED
	TSTL	R5			; REMAINDER = 0 ?
	BEQL	18$			; BR IF YES
	INCL	R4			; INCREMENT TIME LIMIT
18$:	MOVL	QMN_L_MSGPTR(R11),R2	; GET POINTER INTO MSG.
	MOVB	@(SP)+,(R2)+		; STORE OPTION FLAG
	MOVL	R4,(R2)+		; STORE VALUE
	MOVL	R2,QMN_L_MSGPTR(R11)	; STORE UPDATED POINTER
	BRB	40$			; TAKE COMMON EXIT

30$:	MOVZBL	#SMO$K_NODCPULM,R1	; ASSUME NO CPU DEFAULT
	CMPB	@(SP)+,#SMO$K_DCPULM	; CHECK ASSUMPTION
	BEQL	35$			; BR IF TRUE
	MOVZBL	#SMO$K_NOMCPULM,R1	; SET NO MAX CPU TIME LIMIT
35$:	MOVB	R1,@QMN_L_MSGPTR(R11)	; STORE OPTION IN MSG.
	INCL	QMN_L_MSGPTR(R11)	; UPDATE POINTER INTO MSG.
40$:	MOVL	#1,R0			; SET SUCCESS
	RET
	.DSABL	LSB

;
; DEQUEUE CHARACTERISTICS SPECIFIED
;
	.ENTRY	QMN_DQCHAR,^M<R2>	; DEQUEUE CHARACTERISTICS SPECIFIED
	MOVAB	W^ASCIIVAL,R2		; GET VALUE CONVERT REQUEST DESCRIPTOR
	CLRQ	-(SP)			; INITIALIZE CHARACTERISTIC FLAGS
	CLRQ	-(SP)			;
10$:	BSBW	CALAVAL			; REQUEST NEXT ASCII VALUE
	PUSHAQ	CLI$Q_RQDESC(R2)	; SET STRING DESCRIPTOR FOR VALUE
	CALLS	#1,W^LIB$CNVCLIQCHAR	; CONVERT CHARACTERISTIC TO BINARY
	BLBS	R0,15$			; BRANCH IF SUCCESS
	MOVL	4(AP),R1		; GET ADDRESS OF QUALIFIER DESC
	MOVQ	CLI$Q_RQDESC(R2),CLI$Q_QDVALDESC(R1) ; SET STRING DESC FOR MSG
	BRB	VALERR			; DISPLAY ERROR MESSAGE
15$:	BBSS	R1,(SP),20$		; SET CHARACTERISTIC FLAG
20$:	BBS	#CLI$V_MOREVALS,CLI$B_RQSTAT(R2),10$ ; BR IF MORE TO PROCESS
	MOVL	QMN_L_MSGPTR(R11),R2	; SET POINTER INTO DATA MESSAGE
	MOVB	#SMO$K_CURDQCHAR,(R2)+	; STORE OPTION FLAG
	MOVQ	(SP)+,(R2)+		; STORE CHARACTERISTIC FLAGS
	MOVQ	(SP)+,(R2)+		;
	MOVL	R2,QMN_L_MSGPTR(R11)	; SET ADJUSTED MESSAGE POINTER
	RET

;+
; VALERR - ERROR CONVERTING VALUE
;
; THIS ROUTINE IS ENTERED WHEN EVER AN ERROR IS DETECTED CONVERTING
; A VALUE.  A MESSAGE IS PRINTED AND RETURN ISSUED TO THE CALLER.
;
; INPUTS:
;	R0 = ERROR CODE FOR CONVERSION ERROR
;	4(AP) = QUALIFIER DESCRIPTOR WITH VALUE DESCRIPTOR
;
;	IT IS ASSUMMED THAT ENTRY IS MADE WITH A CALL FRAME ON THE
;	STACK.  AFTER THE MESSAGE IS PRINTED, A "RET" IS ISSUED TO
;	THE ORIGINAL CALLER.
;-
VALERR:	MOVZBL	#CLI$W_QDVALSIZ+4,R1	; SET OFFSET TO ERROR DESCRIPTOR
	BRW	CMDER1			; COMMON TO COMMAND ERROR

	.SBTTL	COMMAND PARSE ERROR HANDLER
;+
; QMN$CMDERR - COMMAND PARSE ERROR
;
; ENTER HERE FOR THE RESULT PARSE ERROR ACTION TO PRINT A MESSAGE
; CONCERNING AN ERROR PARSING THE COMMAND
;
; INPUTS:
;
;	4(AP) = ADDRESS OF REQUEST DESCRIPTOR WITH ERROR SEGMENT
;	8(AP) = ERROR CODE
;
; OUTPUTS:
;
;	THE ERROR IS PRINTED AND CONTROL IS RETURNED TO THE
;	ORIGINAL CALLER.
;-
	.ENTRY	QMN$CMDERR,^M<R2,R3>	; ERROR PROCESSING COMMAND LINE
	MOVL	8(AP),R0		; GET ERROR CODE
	MOVL	#CLI$W_RQSIZE+4,R1	; OFFSET TO BAD SEGMENT DESCRIPTOR
CMDER1:	ADDL	4(AP),R1		; POINT R1 AT ERROR SEGMENT DESCRIPTOR
	PUSHL	(R1)			; PUSH ADDRESS OF START OF ERROR SEGMENT
	ADDL	-(R1),(SP)		; FIND END OF ERROR SEGMENT
	ADDL3	W^GETCMD+CLI$W_RQSIZE,- ; FIND THE END OF THE
		W^GETCMD+CLI$W_RQSIZE+4,-(SP) ; THE ENTIRE COMMAND
	SUBL	4(SP),(SP)		; NOW THE LENGTH OF THE COMMAND
	CMPL	(SP),#80		; IS LINE TOO LONG
	BLEQU	10$			; BR IF NO
	MOVZBL	#80,(SP)		; SET REASONABLE VALUE
10$:	PUSHAQ	(SP)			; ADDRESS OF THAT DESCRIPTOR
	PUSHL	R1			; ADDRESS OF ERROR SEGMENT
	PUSHL	#<2!<1@16>>		; NUMBER OF FAO ARGUMENTS-SUPRESS PREFIX
	PUSHL	#CLI$_BADTEXT		; THE ERROR
	CLRL	-(SP)			; ZERO FAO ARG COUNT
	PUSHL	R0			; PUSH ERROR CODE
	PUSHL	#6			; TOTAL NUMBER OF ARGS IN BLOCK
	BRW	SHOW_MSG		; PRINT THE ERROR

	.SBTTL	SHOW MESSAGE
;+
; SHOW_MSG - DISPLAY A MESSAGE
;
; THIS ROUTINE IS ENTERED VIA A BR/JMP TO DISPLAY AN ERROR MESSAGE
;
; INPUTS:
;	0(SP) = THE MESSAGE DESCRIPTOR SET FOR A CALL TO SYS$PUTMSG.
;-
 
SHOW_MSG:				; OUTPUT THE ERROR
	MOVAB	W^QMN$CTXBLK,R11	; SET CONTEXT BLK ADR TO NORMAL PLACE
	BLBS	4(SP),7$		; BR IF NOT AN ERROR
	MOVL	4(SP),QMN_L_STATUS(R11)	; SAVE MOST RECENT STATUS
7$:	MOVAB	NAMES,R1		; SET ADDRESS OF COMMAND NAMES
	MOVZBL	QMN_B_CMDTYP(R11),R0	; GET THE COMMAND WE ARE DOING
	BRB	9$			; BR IF COMMON CODE
8$:	MOVZBL	(R1)+,-(SP)		; GET LENGTH OF STRING
	ADDL	(SP)+,R1		; ADVANCE TO NEXT
9$:	SOBGTR	R0,8$			; LOOP
10$:	MOVZBL	(R1)+,R0		; FORM STRING DESCRIPTOR FOR NAME
	PUSHR	#^M<R0,R1>		; PUSH THAT DEESCRIPTOR
	PUSHAQ	(SP)			; NOW PUSH THE ADDRESS OF THAT
	CLRL	-(SP)			; ZERO ADDRESS OF ACTION ROUTINE
	PUSHAB	16(SP)			; PUSH ADDRESS OF MESSAGE BUFFER
	CALLS	#3,@#SYS$PUTMSG		; PRINT THE MESSAGE
	SETBIT	STS$V_INHIB_MSG,QMN_L_STATUS(R11) ; TELL CLI - NO MORE MESSAGES
	MOVL	QMN_L_STATUS(R11),R0	; PASS ERROR TO CALLER
	RET				;
 
 
	.END	QUEMAN			;
