	.TITLE	SHOWQUE - SHOW THE SYSTEM QUEUES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITY "SHOW"
;
; ABSTRACT:	SHOW THE SYMBIONT MANAGER QUEUE
;
; ENVIRONMENT:	NATIVE NON-PRIVLEGED USER MODE CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 8-JUNE-1977
;
; MODIFIED BY:
;
;	V03-001	MLJ0086		Martin L. Jack,	3-Apr-1982  23:59
;		Translate "no such section" error from $MGBLSC to "symbiont
;		manager disabled".
;
;	V011	TMH0011		Tim Halvorsen		04-Feb-1982
;		Remove reference to CLI$K_ symbols at assembly time.
;
;	V02-010	MLJ35403	Martin L. Jack,	19-Jan-1982  2:50
;		Incorporate standard queue name translation.
;
;	V02-009	GWF0117		Gary W. Fowler		28-Oct-1981
;		Add support for WS extent.  Change bit looked at to determine
;		if job queue with /DELETE option.
;
;	V02-008	GWF0108		Gary W. Fowler		22-Sep-1981
;		Add error message to display if LIB$FID_TO_NAME returns an
;		error.
;
;	V02-007	GWF0106		Gary W. Fowler		02-Sep-1981
;		Display SYS$GB_DEFPRI is priority value in queue header is zero
;
;	V02-006	GWF0083		Gary W. Fowler		20-Jul-1981
;		Change so job name is really an ASCIC string.  Add call to
;		LIB$FID_TO_NAME to get full file specification.
;
;	V02-005	GWF0050		Gary W. Fowler		29-May-1981
;		Add file size in "INTERVENING JOBS" message
;
;	V02-004	GWF0037		Gary W. Fowler		06-May-1981
;		Add file size to display and fix problem with descriptors
;		not being reset after call to $FA0.
;
;	V02-003	LMK0001		Len Kawell		03-Jan-1979
;		Add display of dequeue characteristics and cleaned up
;		some of the other displays.
;
;	V02-002	GWF0001		Gary W. Fowler		19-Oct-1979
;		Add routines to show ws default, ws quota, and cpu time
;		limit for batch queues and jobs.
;
;	V02-001	TMH0001		T. Halvorsen		05-Nov-1978
;		Fix so SHQ_SRCQUE only copies as many queue records
;		as there is buffer space; expanded buffer to 32 pages.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;
; MACROS:
;
; MACRO TO ISSUE A CALLBACK TO THE UTILITY SERVICE ROUTINE
;
	.MACRO	CALLBAK	P1,P2
	.IF B <P2>
	PUSHAB	SHQ_W_BITS(FP)		; ADDRESS OF BIT MASK
	.IFF
	PUSHAB	P2			; ADDRESS OF THIRD ARGUEMENT
	.ENDC
	PUSHAB	W^SHOW$A_CLIWORK	; COMMON WORK AREA
	PUSHAB	P1			; THE REQUEST DESCRIPTOR
	CALLS	#3,@CLI$A_UTILSERV(AP)	; REQUEST THE SERVICE OF THE CLI
	.ENDM				;
 
;
; MACRO TO REQUST FORMATING AND OUTPUT OF A MESSAGE
;
	.MACRO	FAOUT	MSG,CNT
	BSBW	FAOUT0
	.WORD	<MSG-.-2>
	.BYTE	<CNT+3>
	.ENDM
 
;
; MACRO TO REQUEST FORMATING AND OUTPUT OF A MESSAGE
; WHEN FORMAT STRING IS COMPUTED.
;
	.MACRO	FAOUTC	MSG,CNT
.IIF DIF	<MSG><R1>,	MOVAB	MSG,R1
	BSBW	FAOUT1
	.BYTE	<CNT+3>
	.ENDM
;
; EQUATED SYMBOLS:
;
	$JBCMSGDEF			; Job controller messages
	$SMRDEF				; SYMBIONT MANAGER DEFINITONS
	$SQRDEF				; SYSTEM QUEUE RECORDS
	$SJHDEF				; SYSTEM JOB HEADER DEFS
	$SQHDEF				; SYSTEM QUEUE HEADER
	$SMQDEF				; SYSTEM QUEUE DEFINITONS
	$SYMDEF				; SYMBIONT MANAGER COMMON DEFINITIONS
 
;
; DEFINE FLAG BITS FOR CLI INTERFACE
;
	_VIELD	SHQ,0,<-		;
		<QUENAM,,M>,-		; EXPLICIT QUEUE NAMED
		<ALL,,M>,-		; ALL ENTRIES DESIRED
		<BATCH,,M>,-		; LIST ALL BATCH QUEUES
		<BRIEF,,M>,-		; CREATE BRIEF LISTING
		<DEVICE,,M>,-		; SHOW DEVICE QUEUES
		<ENTRY,,M>,-		; EXPLICIT ENTRY ONLY
		<FULL,,M>,-		; EXPANDED LISTING
		<QUEPRT,,M>,-		; QUEUE HAS BEEN PRINTED
		>
;
; DEFINE WORK - NEGATIVE INDEXS FROM \FP\
;
 
	$OFFSET	-4,NEGATIVE,<-		;
		<SHQ_W_FLAGS,1>,-	; INTERNAL FLAGS
		<SHQ_W_BITS,1>,-	; CLI BIT DEFINTIONS
		<SHQ_B_LCNT,1>,-	; LIST COUNT FOR INTERVIENING JOBS
		<SHQ_B_QCNT,1>,-	; "QUEUE" COUNTER FOR LOOP CONTROL
		<SHQ_W_SPARE,2>,-	;
		<SHQ_Q_STRDESC,8>,-	; QUAD WORD DESCRIPTOR FOR FAO STRING
		<SHQ_L_CURQUE>,-		; CURRENT QUEUE INDEX
		<SHQ_K_WRKSIZ,0>,-	; SIZE OF WORK AREA(NEGATIVE BYTE COUNT)
		>
;
; DEFINE INTERNAL WORK FLAGS
;
	_VIELD	SHQ,0,<-		; HOUSEKEEPING FLAGS
		FILPRT,-		; A FILE HAS BEEN PRINTED
		BATQUE,-		; WORKING ON A BATCH QUEUE
		HOLDQUE,-		; WORKING ON HOLD QUEUE
		CLKQUE,-		; WORKING ON CLOCK QUEUE
		>
;
; OWN STORAGE:
;
	IMPURE_DATA
 
INADR:	.LONG	0,<1@30-1>		; LIMITS FOR QUEUE TO MAP
RETADR:	.BLKL	2			; RETURN ADDRESS LIMITS FROM MAP SECTION
BIGBUF:	.BLKL	2			; LIMITS OF WORK BUFFER
TRNQUE:	.BLKB	16			; Translated queue name
;
CNV_ATIME:				; FAO CONTROL STRING FOR
	.ASCID	/!%D/			; CONVERTING CPU TIME LIMITS
;
CNV_ASCII:				; FAO CONTROL STRING FOR
	.ASCID	/!UW/			; CONVERTING WS QUOTAS TO ASCII
;
ASCII_WSQTA:
	.WORD	5			; MAX LENGTH OF WS QUOTA
	.WORD	0
	.LONG	10$			; ADDR. OUTPUT BUFFER
10$:	.BLKB	5			; OUTPUT BUFFER FOR $FA0
;
ASCII_WSDFLT:
	.WORD	5			; MAX LENGTH OF WS DEFAULT
	.WORD	0
	.LONG	10$			; ADDR. OUTPUT BUFFER
10$:	.BLKB	5			; OUTPUT BUFFER FOR $FAO
;
ASCII_WSEXT:
	.WORD	5			; MAX LENGTH OF WS EXTENT
	.WORD	0
	.LONG	10$			; ADDR. OUTPUT BUFFER
10$:	.BLKB	5			; OUTPUT BUFFER FOR $FA0
;
ASCII_MAXCPUT:
	.WORD	16			; MAX LENGHT OF MAX CPU TIME
	.WORD	0
	.LONG	10$			; ADDR. OUTPUT BUFFER
10$:	.BLKB	16			; OUTPUT BUFFER FOR $FAO
;
ASCII_DEFCPUT:
	.WORD	16			; MAX LENGTH OF DEF. CPU TIME
	.WORD	0
	.LONG	10$
10$:	.BLKB	16			; OUTPUT BUFFER FOR $FAO
;
QUAD_TIME:
	.BLKQ	1			; FOR TIME QUOTAS
;
TIME_ADDR:
	.LONG	QUAD_TIME		; ADDR. OF QUAD WORD FOR TIME
;
;
KEEP_VAL:
	.LONG	0			; TEMP STORAGE FOR $FAO

INTER_SIZE:
	.LONG	0			; SIZE OF INTERVENING JOBS

FSPEC_DESC:				; DESCRIPTOR OF FILE SPEC.
	.LONG	100
	.LONG	BUFF_SPACE
BUFF_SPACE:
	.BLKB	100
;
 
;
; CLI DATA BLOCKS
;
 
QUENAM:	$CLIREQDESC CLI$K_INPUT1,-	; GET THE QUEUE NAME IF THERE
		BITNUM=SHQ_V_QUENAM	; BIT TO SET IF NAME IS PRESENT
 
GETQUAL:$CLIREQDESC CLI$K_GETQUAL,-	; REQUEST QUALIFIERS
		QUALST=SHQUALS		; QUALIFIER LIST
 
SHQUALS:$CLIQUALDESC CLI$K_SHQU_ALL,-	; SHOW ALL ENTRIES IN SELCTED QUEUES
		TSTLST=SHQ_V_ENTRY,-	; CONFLICTS WITH ONLY 1 ENTRY
		SETLST=SHQ_V_ALL	; SET FLAG TO LIST ALL
 
	$CLIQUALDESC CLI$K_SHQU_BRIE,-	; BRIEF LISTING
		TSTLST=SHQ_V_ENTRY,-	; CONFLICTS WITH ONE ENTRY
		SETLST=SHQ_V_BRIEF	; BIT TO SET
 
	$CLIQUALDESC CLI$K_SHQU_BATC,-	; LIST ALL BATCH QUEUES
		TSTLST=SHQ_V_ENTRY,-	; CONFLICTS WITH ONE ENTRY
		SETLST=SHQ_V_BATCH	; BIT TO SET
 
	$CLIQUALDESC CLI$K_SHQU_DEVI,-	; DEVICE QUEUES
		TSTLST=SHQ_V_ENTRY,-	; CONFLICTS WITH ONE ENTRY
		SETLST=SHQ_V_DEVICE	; BIT TO SET
 
	$CLIQUALDESC CLI$K_SHQU_ENTR,-	; LIST SPECFIC ENTRY
		TSTLST=<SHQ_V_ALL,SHQ_V_BATCH,SHQ_V_DEVICE>,- ; CONFICTS WTIH-
		-			; ALL, BATCH AND DEVICE QUALIFIERS
		SETLST=SHQ_V_ENTRY	; BIT TO SET
 
	$CLIQUALDESC CLI$K_SHQU_FULL,-	; FULL LISTING DESIRED
		SETLST=SHQ_V_FULL	; BIT TO SET
	$CLIQUALDESC END_LIST
 
;
; PURE DATA KEPT IN COMMON SECTION WITH CODE FOR LOCALITY
;
	PURE_SECTION
 
;
; PARAMETERS USED TO MAP TO THE GLOBAL SECTION CONTAINING THE QUEUES
;
 
SECNAM:	SYS_STR	<JBCSYSQUE>
GBLSCPAR:
	.LONG	7			; 7 PARAMETERS
	.LONG	INADR			; POINTER TO INPUT ADDRESS LIMITS
	.LONG	RETADR			; POINTER OUTPUT ADDRESS LIMITS
	.LONG	0			; ACCESS MODE-DEFAULTED TO USER
	.LONG	<1@0>!<1@15>		; FLAGS=<GBL!SYS>
	.LONG	SECNAM			; SECTION NAME DESCRIPTOR
	.LONG	0			; IDENT
	.LONG	0			; RELATIVE PAGE NUMBER
;
; FORMAT STRINGS AND CONSTANT FIELDS FOR FAO DIRECTIVES
;
 
BATHDR:	.ASCIC	\!/ * Batch queue "!AC" Joblim=!UB, Basepri=!UB, !ACSwap !AC!/\
WSHDR:	.ASCIC	\     WS default= !10<!AS!>   WS quota= !10<!AS!>  WS extent= !10<!AS!>\
CPUHDR:	.ASCIC	\   Def CPU time= !16<!AS!>                Max CPU time= !16<!AS!>!/\
JOBQUO:	.ASCIC	\    WS default= !5<!AS!> WS quota= !5<!AS!> WS extent= !5<!AS!> CPU time= !13<!AS!>\
BATJOB:	.ASCIC	\  !AC !4UW !AD !9AF Pri=!UB !17%D!+!+!+\
BATFIL:	.ASCIC	\      !AF !+ !AC\
DEVHDR:	.ASCIC	\!/ * !AC queue "!AC" Forms=!UB, !AC !AC!AC!AC!AC!AC!AC!#(4UB)!/\
GENHDR:	.ASCIC	\!/ * Generic !AC queue "!AC" !+!AC !AC!AC!AC!AC!AC!/\
DEVJOB:	.ASCIC	\  !AC !4UW !AD !9AF Pri=!UB !17%D !AC!ZL !AC\
DVJOBX:	.ASCIC	\!_Job_count=!UB, Form_type=!UB, Characteristics=!#(4UB)\
PRTFL2:	.ASCIC	\         !AF Copies=!UB, !AC!AC!AC!AC!AC!AC Paglim=!UW\
PRTFL1:	.ASCIC	\         !AF Copies=!UB, !AC!AC!AC!AC!AC!AC\
INTVJB:	.ASCIC	\        [ !UB Intervening jobs  Size= !UL ]\
BNTVJB:	.ASCIC	\        [ !UB Intervening jobs !+]\
REDRCT:	.ASCIC	\	 This queue assigned to !AC\
NOQUE:	.ASCII	\  No such queue\
	NOQSIZ = . - NOQUE
 
NULL:	.BYTE	0
DELETE:	.ASCIC	\Delete \
FLAG:	.ASCIC	\Flag \
BURST:	.ASCIC	\Burst \
STOPD:	.ASCIC	\Stopped \
PAUSED:	.ASCIC	\Paused \
LOWER:	.ASCIC	\Lower \
GENDEV:	.ASCIC	\Gendev\
GENPRT:	.ASCIC	\Genprt\
NOGEN:	.ASCIC	\Nogen\
DEVICE:	.ASCIC	\Device\
TERMIN:	.ASCIC	\Terminal\
CURRNT:	.ASCIC	\CURR \
PENDG:	.ASCIC	\PEND \
HOLDG:	.ASCIC	\HOLD \
SIZE:	.ASCIC	\Size=\
AFTER:	.ASCIC	\AFTER\
NO:	.ASCIC	\NO\
NOFEED:	.ASCIC	\Nofeed \
PAGHDR:	.ASCIC	\Paghdr \
DBLSPC:	.ASCIC	\Dblspc\
UNTIL:	.ASCIC	\until \
NONE_SPEC:
	.ASCID	/None/
INFI_TIME:
	.ASCID	/Infinite/
CHAR:	.ASCIC	\Char=\

ERR_SPEC:					; DESCRIPTOR FOR ERROR
	.LONG	20$-10$	
	.LONG	10$
10$:	.ASCII	/*Error converting file ID*/
20$:

	.SBTTL	PRINT THE QUEUE ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE LIST THE CONTENTS OF ALL THE QUEUES
;
; CALLING SEQUENCE:
;
;	CALL	SHO_LISTQUE
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	PURE_SECTION

	.ENTRY	SHOW$QUEUE,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
 
	$EXPREG_S	#32,-		; EXPAND REGION BY 32 PAGES
		RETADR=BIGBUF,-		; LIMITS FOR BIG BUFFER
		REGION=#0		; P0 SPACE SHOULD BE EXPANDED
	BLBC	R0,10$			; BR IF AOK
	ADDL3	#1,W^BIGBUF+4,W^INADR	; SET NEXT BYTE TO MAP QUEUE
	CALLG	W^GBLSCPAR,@#SYS$MGBLSC ; MAP THE SYMBIONT MANAGERS QUEUE
	BLBS	R0,RESTART		; BR IF ALL IS WELL
	CMPW	R0,#SS$_NOSUCHSEC	; No such section error?
	BNEQ	10$			; Br if not
	MOVL	#JBC$_SYMBDSAB!2,R0	; Say symbiont manager disabled
10$:	$EXIT_S	R0			; EXIT WITH BAD STATUS
RESTART:MOVL	W^RETADR,R10		; SET BASE OF THE QUEUE
	MOVAB	SHQ_K_WRKSIZ(FP),SP	; ALLOCATE WORK AREA IN THE CALL STACK
	MOVC5	#0,(SP),#0,#-SHQ_K_WRKSIZ,(SP) ; ZERO OUT THE WORK AREA
	CALLBAK	GETQUAL			; GET COMMAND QUALIFIERS
	CALLBAK	QUENAM			; RETREIVE THE QUEUE NAME
	TSTW	W^QUENAM+CLI$W_RQSIZE	; Queue name specified?
	BEQL	5$			; Br if not
	PUSHAB	W^TRNQUE		; Point to result area
	PUSHAQ	W^QUENAM+CLI$Q_RQDESC	; Point to parameter
	CALLS	#2,G^TRAN_QUEUE		; Translate
	BLBS	R0,5$			; Br if successful
	PUSHAQ	W^QUENAM+CLI$Q_RQDESC	; Point to parameter
	PUSHL	#1			; One FAO argument
	PUSHL	#SHR$_BADQNAME!<4@16>!STS$K_SEVERE
	CALLS	#3,G^LIB$STOP		; Signal the error
5$:	MOVAB	SQH$K_SIZE(R10),(SP)	; SET ADDRESS OF FIRST QUEUE HEADER
SCAN0:	BITB	#<SHQ_M_DEVICE!SHQ_M_QUENAM>,- ; CHECK IF DEVICE QUEUE SCAN-
		SHQ_W_BITS(FP)		; IS REQUIRED AT ALL
	BEQL	40$			; BR IF CAN'T NEED A DEVICE QUEUE LIST
	MOVB	#1,SHQ_B_QCNT(FP)	; INIT COUNTER FOR ACB LOOP
10$:	MOVL	(SP),R6			; GET ADDRESS OF NEXT QUEUE TO CHECK
	CLRW	SHQ_W_FLAGS(FP)		; RESET ALL FLAGS
	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),30$ ; BR IF THIS QUEUE IS EMPTY
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),30$ ; BR IF BATCH QUEUE
	BBS	#SHQ_V_DEVICE,SHQ_W_BITS(FP),20$ ; BR IF SHOWING ALL DEVICE Q'S
	MOVAB	SMQ$T_NAME(R6),R2	; POINT AT QUEUE NAME
	MOVZBL	W^TRNQUE,R0		; Get parameter length
	CMPB	R0,(R2)+		; LENGTH'S THE SAME
	BNEQ	30$			; BR IN NO - CAN'T MATCH!
	CMPC	R0,W^TRNQUE+1,(R2)	; NAMES THE SAME?
	BNEQ	30$			; BR IF NO - LOOK AT NEXT
20$:	BSBW	LSTDEV			; LIST A DEVICE QUEUE
30$:	ADDL	#SMQ$K_SIZE,(SP)	; ADVANCT TO THE NEXT QUEUE
	ACBB	SQH$B_MAXQUE(R10),-	; HIGHEST TO GO
		#1,SHQ_B_QCNT(FP),10$	; DO LOOP PROCESSING
;
; NOW SCAN BATCH QUEUES
;
 
40$:	ASSUME	SHQ_B_QCNT+1 EQ SHQ_B_LCNT ; 
	CLRL	INTER_SIZE		; SET SIZE TO ZERO
	MOVW	#1,SHQ_B_QCNT(FP)	; INIT COUNTERS
	MOVAB	SQH$K_SIZE(R10),(SP)	; RESET POINTER TO FIRST QUEUE
	BITB	#<SHQ_M_BATCH!SHQ_M_QUENAM>,- ; CHECK IF SCAN OF BATCH QUEUES-
		SHQ_W_BITS(FP)		; IS NEEDED AT ALL
	BEQL	80$			; BR IF NO SCAN IS REQUIRED
50$:	MOVL	(SP),R6			; GET ADDRESS OF NEXT QUEUE TP CHECK
	CLRW	SHQ_W_FLAGS(FP)		; RESET ALL FLAGS
	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),70$ ; BR IF THIS QUEUE IS EMPTY
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),70$ ; BR IF NOT BATCH QUEUE
	BBS	#SHQ_V_BATCH,SHQ_W_BITS(FP),60$ ; BR IF SHOWING ALL BATCH Q'S
	MOVAB	SMQ$T_NAME(R6),R2	; POINT AT QUEUE NAME
	MOVZBL	W^TRNQUE,R0		; Get parameter length
	CMPB	R0,(R2)+		; LENGTH'S THE SAME
	BNEQ	70$			; BR IN NO - CAN'T MATCH!
	CMPC	R0,W^TRNQUE+1,(R2)	; NAMES THE SAME?
	BNEQ	70$			; BR IF NO - LOOK AT NEXT
60$:	BSBW	LSTBAQ			; LIST A BATCH QUEUE
70$:	ADDL	#SMQ$K_SIZE,(SP)	; ADVANCT TO THE NEXT QUEUE
	ACBB	SQH$B_MAXQUE(R10),-	; HIGHEST TO GO
		#1,SHQ_B_QCNT(FP),50$	; DO LOOP PROCESSING
80$:	BBS	#SHQ_V_QUEPRT,SHQ_W_BITS(FP),90$ ; BR IF A QUEUE WAS PRINTED
	PUSHAB	NOQUE
	PUSHL	#NOQSIZ
	CALLS	#2,W^SHOW$PRINT_LINE	; TELL NO QUEUE FOUND
90$:	MOVZBL	#1,R0			; SET SUCESSFUL STATUS
	RET				; BACK TO CLI

	.SBTTL	LIST DEVICE/BATCH QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PRINT THE CONTENTS OF A DEVICE OR
;	A BTACH QUEUE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	LSTDEV			; LIST A DEVICE QUEUE
;	BSB/JSB	LSTBAQ			; LIST A BATCH QUEUE
;
; INPUT PARAMETERS:
;
;	SHQ_L_CURQUE(FP) CONTAINS ADDRESS OF QUEUE HEADER TO LIST
;
; IMPLICIT INPUTS:
;
;	COMMAND LINE INPUT HAS BEEN PROCESSED
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE CONTENTS OF THE QUEUE IS LISTED IN ACCORDANCE WITH PARAMETRS.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
 
LSTDEV:	CLRL	R0			; INIT CHARACTERISTICS COUNT
	MOVZWL	#127,R1			; INIT CHARACTERISTIC NUMBER
2$:	BBC	R1,SMQ$T_DQCHAR(R6),3$	; BR IF CHARACTERISTIC NOT SPECIFIED
	PUSHL	R1			; ELSE, PUSH CHARACTERISTIC NUMBER
	INCL	R0			; INCREMENT CHARACTERISTIC COUNT
3$:	SOBGEQ	R1,2$			; DECREMENT CHARACTERISTIC NUMBER, LOOP
	PUSHL	R0			; PUSH CHARACTERISTICS COUNT
	MOVAB	NULL,R0			; GET COMMONLY USED PARAMETER
	PUSHAB	(R0)			; ASSUME NO CHARACTERISTICS
	TSTL	4(SP)			; ANY CHARACTERISTICS?
	BEQL	5$			; BR IF ASSUMED CORRECTLY
	MOVAB	CHAR,(SP)		; SET ADDRESS OF STRING
5$:	PUSHAB	(R0)			; ASSUME NO FLAG IS DEFAULTED
	BBC	#SMQ$V_DEFFLAG,SMQ$B_CHAR(R6),10$ ; BR IF ASSUMED CORRECTLY
	MOVAB	FLAG,(SP)		; SET ADDRESS OF STRING
10$:	PUSHAB	(R0)			; ASSUME NO DEFAULT FLAG
	BBC	#SMQ$V_DEFBRST,SMQ$B_CHAR(R6),20$ ; BR IF ASSUMED CORRECTLY
	MOVAB	BURST,(SP)		; ELSE SET ADDRESS OF STRING
20$:	PUSHAB	(R0)			; ASSUME QUEUE IS NOT STOPPED
	BBC	#SMQ$V_STOPPED,SMQ$B_FLAGS(R6),30$ ; BR IF ASSUMED CORRECTLY
	MOVAB	STOPD,(SP)		; ELSE SET ADDRESS OF STRING
30$:	PUSHAB	(R0)			; ASSUME QUEUE IS NOT PAUSED
	BBC	#SMQ$V_PAUSED,SMQ$B_FLAGS(R6),40$ ; BR IF ASSUMED CORRECTLY
	MOVAB	PAUSED,(SP)		; ELSE SET ADDRESS OF STRING
40$:	PUSHAB	(R0)			; ASSUME DEVICE HAS NO LOWER CASE
	BBC	#SMQ$V_LOWER,SMQ$B_CHAR(R6),50$ ; BR IF ASSUMED CORRECTLY
	MOVAB	LOWER,(SP)		; ELSE SET ADDRESS OF STRING
50$:	PUSHAB	(R0)			; ASSUME GENERIC DEVICE QUEUE
	BBS	#SMQ$V_GENDEV,SMQ$B_FLAGS(R6),60$ ; BR IF ASSUMED CORRECTLY
	MOVAB	GENPRT,(SP)		; ASSUME GENERIC PRINTING IS ALLOWED
	BBC	#SMQ$V_NOGENERIC,SMQ$B_FLAGS(R6),60$ ; BR IF GENERIC PRINTING IS OK
	MOVAB	NOGEN,(SP)		; ELSE SHOW NO GENERIC PRINTING
60$:	PUSHL	SMQ$B_FORMS(R6)		; FORMS TYPE
	PUSHAB	SMQ$T_NAME(R6)		; ADDRESS OF QUEUE NAME
	PUSHAB	DEVICE			; INDICATE DEVICE IS PRINTER
	BBC	#SMQ$V_TRMDEV,SMQ$B_CHAR(R6),70$ ; BR IF DEVICE NOT A TERMINAL
	MOVAB	TERMIN,(SP)		; SET QUEUE AS A TERMINAL TYPE
70$:	BBC	#SMQ$V_GENDEV,SMQ$B_FLAGS(R6),75$ ; BR IF NOT GENERIC QUEUE
	FAOUT	GENHDR,10		; FORMAT AND OUTPUT GENERIC QUEUE HEADER
	BRB	78$			;
75$:	FAOUT	DEVHDR,10		; FORMAT AND OUTPUT DEVICE QUEUE HEADER
78$:	MOVL	(SP)+,R0		; GET CHARACTERISTICS COUNT
	MOVAL	(SP)[R0],SP		; REMOVE CHARACTERISTICS FROM STACK
	BBC	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),80$ ; BR IF QUEUE NOT REDIRECTED
	ADDL3	R10,SMQ$L_ASNSCT(R6),R0	; FIND ADDRESS OF QUEUE REDIRECTED TO
	PUSHAB	SMQ$T_NAME(R0)		; ADDRESS OF THE NAME OF THAT QUEUE
	FAOUT	REDRCT,1		; OUTPUT MESSAGE
80$:	BRW	SHQ_DEV			; PRINT REST OF DEVICE QUEUE
;
; LSTBAQ - LIST A BATCH QUEUE
;
 
LSTBAQ:	PUSHAB	STOPD			; ASSUME QUEUE IS STOPPED
	BBS	#SMQ$V_STOPPED,SMQ$B_FLAGS(R6),10$ ; BR IF ASSUMMED CORRECTLY
	MOVAB	NULL,(SP)		; SET NULL STRING
10$:	PUSHAB	NO			; ASSUME NO SWAPPING FROM THIS QUEUE
	BBS	#SMQ$V_NOSWAP,SMQ$B_CHAR(R6),20$ ; BR IF ASSUMED CORRECTLY
	MOVAB	NULL,(SP)		; REPLACE WITH THE NULL STRING
20$:	EXTZV	#SMQ$V_INIPRI,#SMQ$S_INIPRI,- ; START BIT AND SIZE OF VIELD
		SMQ$B_CHAR(R6),-(SP)	; GET DEFAULT STARTING PRIORITY
	BNEQ	30$			; BR IF NOT SYSTEM DEFAULT
	MOVZBL	@#SYS$GB_DEFPRI,(SP)	; SET DEFAULT
30$:	PUSHL	SMQ$B_JOBLIM(R6)	; SET QUEUE JOB LIMIT IN MESSAGE
	PUSHAB	SMQ$T_NAME(R6)		; SET ADDRESS OF QUEUE
	FAOUT	BATHDR,5		; FORMAT AND OUTPUT STRING
					; JOIN BATCH JOB LISTING ROUTINE
;
; PRINT QUOTAS IF DOING FULL LISTING
;
	BBS	#SHQ_V_FULL,SHQ_W_BITS(FP),40$	; BR DOING FULL
	BRW	SHQ_BAT			; CONTINUE
40$:	PUSHL	#SMQ$V_WSEXTNT		; BIT INDICATING PRESENCE
	MOVZWL	SMQ$W_QUOFLG(R6),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_WSEXT		; ADDR. OUTPUT BUFF. DESC.
	MOVZWL	SMQ$W_WSEXTNT(R6),-(SP)	; VALUE OF WS QUOTA
	CALLS	#4,CNVT_WS		; CONVERT TO ASCII
	PUSHL	R1			; PUSH ADDR. OF DESC.

	PUSHL	#SMQ$V_WSQUTA		; BIT INDICATING PRESENCE
	MOVZWL	SMQ$W_QUOFLG(R6),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_WSQTA		; ADDR. OUTPUT BUFF. DESC.
	MOVZWL	SMQ$W_WSQUTA(R6),-(SP)	; VALUE OF WS QUOTA
	CALLS	#4,CNVT_WS		; CONVERT TO ASCII
	PUSHL	R1			; PUSH ADDR. OF DESC.
;
	PUSHL	#SMQ$V_WSDFLT		; BIT INDICATING PRESENCE
	MOVZWL	SMQ$W_QUOFLG(R6),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_WSDFLT		; ADDR. OUTPUT BUFF. DESC.
	MOVZWL	SMQ$W_WSDFLT(R6),-(SP)	; VALUE OF WS DEFAULT
	CALLS	#4,CNVT_WS		; CONVERT TO ASCII
	PUSHL	R1			; PUSH ADDR. OF DESC.
;
	FAOUT	WSHDR,3			; PRINT THE LINE
;
	PUSHL	#SMQ$V_MCPULM		; BIT INDICATING PRESENCE
	MOVZWL	SMQ$W_QUOFLG(R6),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_MAXCPUT		; ADDR. OUTPUT BUFF. DESC.
	PUSHL	SMQ$L_MCPULM(R6)	; VALUE OF MAX CPU TIME
	CALLS	#4,CNVT_TIME		; CONVERT TO ASCII
	PUSHL	R1			; PUSH ADDR. OF DESC.
;
	PUSHL	#SMQ$V_DCPULM		; BIT INDICATING PRESENCE
	MOVZWL	SMQ$W_QUOFLG(R6),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_DEFCPUT		; ADDR. OUTPUT BUFF. DESC.
	PUSHL	SMQ$L_DCPULM(R6)	; VALUE OF DEF. CPU TIME
	CALLS	#4,CNVT_TIME		; CONVERT TO ASCII
	PUSHL	R1			; PUSH ADDR. OF DESC.
	FAOUT	CPUHDR,2		; PRINT THE LINE
;
; ROUTINE TO PRINT ALL THE JOBS IN EITHER BATCH OR DEVICE QUEUES
;
; NOTE:	ON ENTRY, R6 CONTAINS THE ADDRESS OF THE QUEUE TO PRINT,
;	WHICH IS THE ADDRESS OF THE CURRENT JOB LIST.
;
 
	ASSUME	SMQ$L_CURRENT EQ 0	; CHECK ASSUMPTION
SHQ_BAT:SETBIT	SHQ_V_BATQUE,SHQ_W_FLAGS(FP) ; MARK BATCH IN PROGRESS
SHQ_DEV:SETBIT	SHQ_V_QUEPRT,SHQ_W_BITS(FP) ; MARK A QUEUE AS PRINTED
	PUSHAB	W^SHQ_SRCQUE		; INIT COROUTINE TO SEARCH QUEUES
10$:	JSB	@(SP)+			; GET NEXT JOB FROM QUEUE
	BLBC	R0,30$			; BR WHEN NO MORE CURRENT JOBS
	PUSHAB	NULL			; FOR "LOWER"
	PUSHL	SJH$L_FILESIZ(R4)	; FILE SIZE
	PUSHAB	SIZE
	PUSHAQ	SJH$Q_TIME(R4)		; ADDRESS OF TIME JOB WAS QUEUE'D
	PUSHL	SJH$B_PRTPRI(R4)	; PRIORITY JOB WAS QUEUE'D AT
	PUSHAB	SJH$T_JOBNAME+1(R4)	; ADDRESS OF JOB NAME FIELD
	MOVZBL	SJH$T_JOBNAME(R4),-(SP)	; LENGTH OF JOB NAME
	PUSHAB	SJH$T_USERNAM(R4)	; AND THE USER THAT QUEUE'D THE FILE
	PUSHL	#12			; SIZE OF THAT FIELD
	PUSHL	SJH$W_JOBSEQ(R4)	; THE JOB SEQUENCE(ENTRY)NUMBER
	PUSHAB	CURRNT			; INDICATE CURRENT JOB LISTING
	MOVAB	DEVJOB,R1		; ADDRESS OF HEADER STRING
	BBC	#SHQ_V_BATQUE,SHQ_W_FLAGS(FP),20$ ; BR IF NOT DOING BATCH
	MOVAB	BATJOB,R1		; REAL FORMAT STRING
20$:	FAOUTC	R1,11			; FORMAT AND OUTPUT-COMPUTED FORMAT
	BBC	#SHQ_V_BATQUE,SHQ_W_FLAGS(FP),22$ ; BR IF NOT DOING BATCH QUEUE
	BBC	#SHQ_V_FULL,SHQ_W_BITS(FP),10$	; BR IF NOT DOING FULL
	BSBW	PJOB_QUOTAS		; FORMAT AND PRINT QUOTAS
	BRB	10$			; CONTINUE
22$:	BSBW	PJOB_CHAR		; FORMAT AND PRINT CHARACTERISTICS
	BRW	10$			; TRY FOR NEXT ACTIVE JOB
;
; PRINT THE ACTIVE PRINT QUEUES
;
30$:	MOVAQ	SQH$K_SIZE(R10),R6	; POINT BEYOND ACTIVE QUEUES
40$:	CMPL	-(R6),-(R6)		; BACK UP TO NEXT QUEUE
	PUSHAB	W^SHQ_SRCQUE		; INIT COROUTINE
50$:	JSB	@(SP)+			; NEXT JOB PLEASE
	BLBC	R0,60$			; BR WHEN NO MORE IN THIS QUEUE
	BSBW	CK_QUE			; PRINT IF MATCHES QUEUE AND USER
	BRB	50$			; TRY FOR NEXT
60$:	MOVAB	SQH$Q_QUEUE(R10),R0	; GET LOWEST QUEUE ADDRESS
	CMPL	R6,R0			; BACK UP TO LAST QUEUE
	BGTRU	40$			; BR IF MORE QUEUES TO DO
	ADDL3	#SMQ$L_HOLDLST,SHQ_L_CURQUE(FP),R6 ; POINT A HOLD LIST
	SETBIT	SHQ_V_HOLDQUE,SHQ_W_FLAGS(FP) ; FLAG DOING HOLD QUEUE
	PUSHAB	W^SHQ_SRCQUE		; INIT COROUTINE
70$:	JSB	@(SP)+			; FIND THE NEXT FILE IN THE QUEUE
	BLBC	R0,80$			; BR IF NO MORE IN HOLD LIST
	BSBW	CK_JOB			; PRINT IF PROPER USER
	BRB	70$			; GET THE NEXT
80$:	MOVAB	SQH$L_TIMQUE(R10),R6	; LIST HEAD FOR TIME QUEUE
	SETBIT	SHQ_V_CLKQUE,SHQ_W_FLAGS(FP) ; FLAG DOING CLOCK QUEUE
	PUSHAB	W^SHQ_SRCQUE		; INIT COROUTINE
90$:	JSB	@(SP)+			; GET NEXT JOB
	BLBC	R0,100$			; BR WHEN NO MORE JOBS
	BSBW	CK_QUE			; CHECK QUEUE AND USER
	BRB	90$			; GET THE NEXT
100$:	RSB				; ALL DONE WITH THIS QUEUE


	.SBTTL	CHECK QUEUE AND JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CONDITIONALLY LIST A JOB
;	DEPENDING UPON QUEUE AND/OR USERNAME MATCH.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	CK_QUE			; CHECK QUEUE AND USER
;	BSB/JSB	CK_JOB			; CHECK ONLY USERNAME
;
; INPUT PARAMETERS:
;
;	SHQ_L_CURQUE(FP) CONTAINS ADDRESS OF QUEUE HEADER TO LIST
;	(R4) CONTAINS AN IMAGE OF THE JOB INCLUDING ALL RECORDS
;
; IMPLICIT INPUTS:
;
;	COMMAND LINE INPUT HAS BEEN PROCESSED
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE CONTENTS OF THE QUEUE IS LISTED IN ACCORDANCE WITH PARAMETRS.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENABL	LSB
 
CK_QUE:	SUBL3	R10,SHQ_L_CURQUE(FP),R0	; FIND QUEUE INDEX
	CMPW	R0,SJH$W_QINDEX(R4)	; IS THIS JOB IN CURRENT QUEUE
	BNEQ	5$			; IF NOT - DON'T LIST IT
CK_JOB:	INCB	SHQ_B_LCNT(FP)		; COUNT NUMBER OF INTERVIENING JOBS
	BBS	#SHQ_V_ALL,SHQ_W_BITS(FP),10$ ; BR SHOWING ALL JOBS IN QUEUE
	CMPC	#12,SJH$T_USERNAM(R4),- ; CHECK IF THE QUEUEE OF THIS JOB -
		@#CTL$T_USERNAME	; IS THE SAME AS CURRENT USER
	BEQL	10$			; BR IF USER MATCHES
	ADDL	SJH$L_FILESIZ(R4),-	; ADD SIZE OF THIS JOB
		INTER_SIZE		; TO SIZE OF OTHER JOBS
5$:	RSB				; IF NO MATCH, THEN RETURN
10$:	SUBB3	#1,SHQ_B_LCNT(FP),R0	; FIND NUMBER OF INTERVIENING JOBS
	BLEQ	20$			; BR IF NO INTERVENING JOBS
	PUSHL	INTER_SIZE		; SIZE OF INTERVENING JOBS
	PUSHL	R0			; PUSH COUNT OF INTERVIENING JOBS
	MOVAB	INTVJB,R1		; ASSUME A DEVICE QUEUE
	BBC	#SHQ_V_BATQUE,-		; IF BIT CLEAR THEN
		SHQ_W_FLAGS(FP),15$	;  ASSUMED OK
	MOVAB	BNTVJB,R1		; STRING FOR BATCH JOBS
15$:	FAOUTC	R1,2			; FORMAT AND OUTPUT MESSAGE
20$:	CLRB	SHQ_B_LCNT(FP)		; RESET INTERVIENING JOB COUNTER
	CLRL	INTER_SIZE		; RESET SIZE TO ZERO
	SETBIT	SHQ_V_FILPRT,SHQ_W_FLAGS(FP) ; MARK A FILE PRINTED NOW
	PUSHAB	NULL			; ASSUME LOWER NOT REQUIRED
	BBC	#SJH$V_LOWER,-		; IF BIT CLEAR
		SJH$B_FLAGS(R4),25$	;  THEN LOWER IS NOT REQUIRED
	MOVAB	LOWER,(SP)		; LOWER IS REQUIRED
25$:	PUSHL	SJH$L_FILESIZ(R4)	; FILE SIZE
	PUSHAB	SIZE			; SET "Size=" in message
	PUSHAQ	SJH$Q_TIME(R4)		; TIME JOB WAS QUEUED
	PUSHL	SJH$B_PRTPRI(R4)	; PRIORITY JOB IS QUEUED AT
	PUSHAB	SJH$T_JOBNAME+1(R4)	; ADDRESS OF JOB NAME FIELD
	MOVZBL	SJH$T_JOBNAME(R4),-(SP)	; SIZE OF THAT FIELD
	PUSHAB	SJH$T_USERNAM(R4)	; ADDRESS OF USER THAT QUEUED THE FILE
	PUSHL	#12			; LENGTH OF THAT STRING
	PUSHL	SJH$W_JOBSEQ(R4)	; THE SEQUENCE NUMBER OF THE JOB
	PUSHAB	PENDG			; ASSUME A PENDING JOB
	BBC	#SHQ_V_HOLDQUE,SHQ_W_FLAGS(FP),40$ ; BR IF CORRECT ASSUMPTION
	MOVAB	HOLDG,(SP)		; INDICATE THE JOB IS BEING HELD
40$:	BBC	#SHQ_V_CLKQUE,SHQ_W_FLAGS(FP),45$ ; BR IF NOT CLOCK QUEUE
	MOVAB	AFTER,(SP)		; SET ADDR. OF "AFTER"
45$:	MOVAB	DEVJOB,R1		; ASSUME A DEVICE QUEUE
	BBC	#SHQ_V_BATQUE,SHQ_W_FLAGS(FP),60$ ; BR IF CORRECT ASSUMPTION
	MOVAB	BATJOB,R1		; GET BATCH HEADER FORMAT STRING
60$:	FAOUTC	R1,11			; FORMAT AND OUTPUT MESSAGE
	BBC	#SHQ_V_BATQUE,SHQ_W_FLAGS(FP),63$ ; BR IF NOT DOING BATCH
	BBC	#SHQ_V_FULL,SHQ_W_BITS(FP),66$	; BR IF NOT DOING FULL
	BSBW	PJOB_QUOTAS		; FORMAT AND OUTPUT QUOTAS
	BRB	66$			; CONTINUE
63$:	BSBW	PJOB_CHAR		; FORMAT AND OUTPUT CHARACTERISTICS
66$:	BBC	#SHQ_V_FULL,SHQ_W_BITS(FP),80$ ; BR NOT DOING FULL LISTING
70$:	TSTL	(R4)			; ANY MORE RECORDS TO PRINT
	BNEQ	90$			; BR IF YES
80$:	RSB				;
 
;
; LIST THE JOB RECORDS FOR THIS JOB
;
 
90$:	MOVAB	SYM$K_RECSIZE(R4),R4	; POINT AT NEXT FOB FILE RECORD
	MOVAB	SQR$T_VOLNAM+1(R4),-(SP); ADDRESS OF VOLUME NAME
	MOVZBL	SQR$T_VOLNAM(R4),-(SP)	; LENGTH OF VOLUME NAME
	PUSHAL	FSPEC_DESC		; GETS RETURNED LENGTH
	MOVL	#100,FSPEC_DESC		; SET MAX LENGTH
	MOVAB	BUFF_SPACE,FSPEC_DESC+4	; SET BUFFER ADDRESS
	PUSHAL	FSPEC_DESC		; ADDRESS OF DESCRIPTOR
	PUSHAL	SQR$W_FILNUM(R4)	; ADDRESS OF FILE ID
	PUSHAL	12(SP)			; DESCRIPTOR OF VOLUME NAME
	CALLS	#4,LIB$FID_TO_NAME	; CONVERT TO FILE SPEC
	BLBS	R0,92$			; IF LBS - THEN CONVERT OK
	MOVQ	ERR_SPEC,FSPEC_DESC	; SET ERROR MESSAGE
92$:	CLRQ	(SP)+			; REMOVE DESCRIPTOR
	MOVAB	PRTFL1,R1		; ASSUME PRINT JOB NORMAL CASE
	MOVZWL	SQR$W_PAGCNT(R4),-(SP)	; GET PAGE LIMIT COUNT
	BEQL	100$			; BR IF NORMAL RECORD
	MOVAB	PRTFL2,R1		; SHOW PAGE LIMIT COUNT
100$:	MOVAB	NULL,R0			; COMMONLY USED VALUE
	PUSHAB	(R0)			; ASSUME NULL PARAMETER
	BBC	#SQR$V_NOFEED,SQR$B_FLAGS(R4),110$ ; BR IF OPTION IS NULL
	MOVAB	NOFEED,(SP)		; SET OPTION PRESENT TEXT
110$:	PUSHAB	(R0)			; ASSUME NULL PARAMETER
	BBC	#SQR$V_PAGHDR,SQR$B_FLAGS(R4),120$ ; BR IF OPTION IS NULL
	MOVAB	PAGHDR,(SP)		; SET OPTION PRESENT TEXT
120$:	PUSHAB	(R0)			; ASSUME NULL PARAMETER
	BBC	#SQR$V_DOUBLE,SQR$B_FLAGS(R4),130$ ; BR IF OPTION IS NULL
	MOVAB	DBLSPC,(SP)		; SET OPTION PRESENT TEXT
130$:	PUSHAB	(R0)			; ASSUME NULL PARAMETER
	BBC	#SQR$V_FLAGPAG,SQR$B_FLAGS(R4),140$ ; BR IF OPTION IS NULL
	MOVAB	FLAG,(SP)		; SET OPTION PRESENT TEXT
140$:	PUSHAB	(R0)			; ASSUME NULL PARAMETER
	BBC	#SQR$V_BRSTPAG,SQR$B_FLAGS(R4),150$ ; BR IF OPTION IS NULL
	MOVAB	BURST,(SP)		; SET OPTION PRESENT TEXT
150$:	PUSHAB	(R0)			; ASSUME NULL PARAMETER
	BBC	#SQR$V_TEMPDEL,SQR$B_FLAGS(R4),160$ ; BR IF OPTION IS NULL
	MOVAB	DELETE,(SP)		; SET OPTION PRESENT TEXT
160$:	PUSHL	SQR$B_COPYCNT(R4)	; NUMBER OF COPIES
	MOVQ	FSPEC_DESC,-(SP)	; LENGTH AND ADDRESS OF FILE SPEC
	BBC	#SHQ_V_BATQUE,SHQ_W_FLAGS(FP),170$ ; BR IF NOT DOING BATCH
	MOVAB	BATFIL,R1		; BATCH FILE FORMAT STRING
170$:	FAOUTC	R1,10			; PRINT THE LINE
	BRW	70$			; TRY FOR NEXT FILE
 
	.DSABL	LSB


	.SBTTL	SEARCH QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SEARCH A QUEUE FOR THE NEXT JOB
;	IT MONITORS THE QUEUE FOR CHANGE AND ATTEMPTS TO RESYNC IF
;	THING CHANGE WHILE THE QUEUE IS BEING PRINTED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SRCQUE			;
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE QUEUE TO SEARCH
;
; IMPLICIT INPUTS:
;
;	COMMAND LINE INPUT HAS BEEN PROCESSED
;
; OUTPUT PARAMETERS:
;
;	R4 POINTS AT A COPY OF THE QUEUE JOB HEADER FOLLOWED BY THE
;	ASSOCIATED RECORDS COPIED SEQUENTIALLY INTO A LOCAL BUFFER.
;
; IMPLICIT OUTPUTS:
;
;	REGISTERS R6 TO R9 HOLD SEARCH CONTEXT
;		R6 IS HEADER OF THE QUEUE BEING SEARCHED
;		R7 IS ADDRESS OF THE LINK TO THE LAST JOB FOUND
;		R8 IS THE ADDRESS OF THE LAST JOB FOUND
;		R9 <15-0> QUEUE SEQUENCE NUMBER LAST SEEN
;		R9 <31-16> RESERVED FOR FUTURE USE
;
; COMPLETION CODES:
;
;	R0 LBC INDICATES NO MORE JOBS IN THE CURRENT QUEUE AND
;		SUBROUTINE RETURN HAS BEEN ISSUED.
;
;	R0 LBS INDICATES A JOB HAS BEEN FOUND, R4 POINTS TO A
;		COPY OF THE JOB AND ALL ITS RECORDS, AND
;		COROUNTINE RETURN HAS BEEN ISSUED.
;
; SIDE EFFECTS:
;
;	THIS ROUTINE OPERATES AS A COROUTINE AND USES REGISTERS
;	R6 TO R9 TO HOLD CONTEXT ABOUT THE CURRENT SEARCH.
;	REGISTERS R0 TO R5 MAY BE USED WITHOUT PRESERVATION
;	BY THE CALLEE. REGISTERS R6 TO R9 MUST BE PRESERVE
;	BETWEEN COROUTINE RETURNS.
;
;--
 
SHQ_SRCQUE:				; SEARCH QUEUE FOR NEXT JOB
	MOVL	R6,R7			; COPY HEAD OF QUEUE AS LAST SEEN
	CLRB	SHQ_B_LCNT(FP)		; ZERO INTERMEDIATE COUNTER
	CLRL	INTER_SIZE		; SET SIZE TO ZERO
	CLRQ	R8			; CLR LAST JOB INDEX AND SEQUENCE NUMBER
10$:	CMPW	SQH$W_QUESEQ(R10),R9	; HAS QUEUE CHANGED SINCE LOOK
	BEQL	50$			; BR IF NO
	MOVW	SQH$W_QUESEQ(R10),R9	; SET NEW SEQUENCE
	MOVL	R6,R0			; SET ADDRESS OF QUEUE HEADER
20$:	CMPL	R0,R7			; FOUND THE PREVIOUS LINK ADDRESS?
	BEQL	10$			; IF YES - CONTINUE WITH SEARCH
	MOVL	(R0),R1			; GET OFFSET TO NEXT JOB
	BEQL	110$			; BR IF NOT FOUND - MUST RESTART
	ADDL	R10,R1			; FIND ADDRESS OF JOB
	CMPL	R1,R8			; WAS THIS THE JOB JUST PROCESSED?
	BNEQ	30$			; BR IF NO - KEEP LOOKING
	MOVL	R0,R7			; PREVIOUS JOB IS GONE, SET NEW PREVIOUS
	BRB	10$			; CONTINUE SCAN
30$:	MOVAL	SJH$L_NEXTJOB(R1),R0	; SET LINK TO NEXT JOB
	BRB	20$			; CONTIUE TRYING TO FIND THE PLACE
50$:	MOVL	(R7),R0			; GET LINK TO NEXT JOB
	BEQL	90$			; BR IF JOB IS GONE
	ADDL	R10,R0			; FIND ADDRESS OF JOB
	CMPL	R0,R8			; IS THIS THE LAST ONE PROCESSED
	BNEQ	60$			; IF NOT, THIS IS A NEW ONE, GET IT!
	MOVAL	SJH$L_NEXTJOB(R8),R7	; GET THE LINK ADDRESS TO NEXT JOB
	BRB	50$			; TRY FOR NEXT
60$:	PUSHL	R0			; SAVE ADDRESS OF NEXT JOB TO PROCESS
	MOVL	W^BIGBUF,R3		; SET ADDRESS OF BUFFER
70$:	MOVAB	SYM$K_RECSIZE-1(R3),R1	; LAST BYTE TO WRITE
	CMPL	R1,W^BIGBUF+4		; ARE WE EXCEEDING BUFFER?
	BLEQU	75$			; BRANCH IF NOT
	CLRL	SQR$L_RECLINK-SYM$K_RECSIZE(R3)	; CHOP OFF REST OF LIST
	CLRL	R0			; IGNORE REST OF RECORDS
	BRB	80$			; AND ONLY SHOW FIRST ONES
75$:	PUSHL	SQR$L_RECLINK(R0)	; SAVE INDEX TO NEXT RECORD
	MOVC	#SYM$K_RECSIZE,(R0),(R3); COPY RECORD INTO LOCAL BUFFER
	MOVL	(SP)+,R0		; GET INDEX TO NEXT QUEUE RECORD IN JOB
	BEQL	80$			; BR IF NO MORE
	ADDL	R10,R0			; FIND ADDRESS
	BRB	70$			; COPY THAT ONE ALSO
80$:	POPR	#^M<R1>			; GET THE ADDRESS OF THE JOB HEADER BACK
	CMPW	SQH$W_QUESEQ(R10),R9	; HAS THE QUEUE CHANGED RECENTLY?
	BNEQ	10$			; BR IF YES - RESYNC THIS OPERATION
	MOVL	R1,R8			; SET ADDRESS OF JOB PROCESSED
	INCL	R0			; SET NORMAL STATUS
	MOVL	W^BIGBUF,R4		; SET ADDRESS OF BUFFER
	JSB	@(SP)+			; COROUTINE RETURN
	BRW	10$			; GET NEXT
90$:	RSB				; NO MORE JOBS
;
; QUEUE CAN NOT BE RESYNCED
;
 
110$:	PUSHAB	B^100$			; ADDRESS OF MESSAGE
	PUSHL	S^#<101$-100$>		; SIZE OF LESSAGE
	CALLS	#2,SHOW$PRINT_LINE	; TELL THE USER WHATS HAPPENING
	BRW	RESTART			; RESTART THE WHOLE THING
100$:	.ASCII	\QUEUE SYNC ERROR - RESTARTING\
101$:

 

	.SBTTL	FORMAT AND OUTPUT MESSAGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO FORMAT AND OUTPUT A MESSAGE
;
; CALLING SEQUENCE:
;
; FOR FAOUT0:
;
;	JSB/BSB	FAOUT0			;
;	.WORD	<FMTSTR-.-2>		; SELF RELATIVE POINTER TO FORMAT STRING
;	.BYTE	<NUMARG+3>		; ARGUMENT CAOUNT FOR FAO
;
; FOR FAOUT1:
;
;	MOVAB	FMTSTR,R1		; ADDRESS OF FORMAT STRING
;	JSB/BSB	FAOUT1			;
;	.BYTE	<NUMARG+3>		; ARGUMENT COUNT TO FAO
;
; INPUT PARAMETERS:
;
;	4(SP) IS THE ARGUMENT LIST FOR FAO CALL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE LINE IS FORMATED AND PRINTED
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENABL	LSB
 
FAOUT1:	POPR	#^M<R3>			; GET PC OF CALLER
	BRB	10$			; JOIN COMMON CODE
 
FAOUT0:	POPR	#^M<R3>			;  GET PC OF CALLER
	CVTWL	(R3)+,R1		; GET OFFSET TO FORMAT STRING
	ADDL	R3,R1			; FIND ADDRESS OF FORMAT STRING
10$:	MOVAQ	SHQ_Q_STRDESC(FP),R0	; SET ADDRESS OF WORD QUADWORD DESC
	MOVZBL	(R1)+,(R0)		; SET LENGTH OF STRING
	MOVL	R1,4(R0)		; AND ADDRESS OF THE STRING
	MOVZBL	(R3)+,R1		; GET FAO ARGUMENT COUNT
	PUSHAQ	W^SHOW$GQ_OUT_DSC	; ADDRESS OF RESULT BUFFER DESCRIPTOR
	PUSHAW	2(R0)			; ADDRESS OF WORD TO STORE FINAL LENGTH
	PUSHAQ	(R0)			; INPUT DESCRIPTOR FOR FORMAT STRING
	CALLS	R1,@#SYS$FAO		; FORMAT THE MESSAGE
	PUSHL	W^SHOW$GQ_OUT_DSC+4	; PUSH ADDRESS OF LINE BUFFER
	PUSHL	SHQ_Q_STRDESC+2(FP)	; RESULTANT LENGTH
	CALLS	#2,SHOW$PRINT_LINE	; PRINT THE FORMATED LINE
	JMP	(R3)			; RETURN FROM SUBROUTINE
 
	.DSABL	LSB
 
	.PAGE
	.SBTTL	CONVERT WORKING SET QUOTAS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS THE VALUE OF A WORKING SET QUOTA TO AN
;	ASCII STRING USING $FAO
;
; CALLING SEQUENCE:
;
;	CALLS	CNVT_WS
;
; INPUT PARAMETERS:
;
;	4(AP)  IS THE VALUE TO CONVERT
;	8(AP)  IS THE ADDR. OF THE OUTPUT BUFFER DESCRIPTOR
;	12(AP) IS THE ADDR. OF THE QUOTA PRESENT FLAG
;	16(AP) IS A LONGWORD CONTAINING THE BIT TO TEST IN THE QUOTA
;	       PRESENT FLAG TO DETERMINE IF THE QUOTA IS THERE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R1 CONTAINS THE ADDR. OF THE OUTPUT BUFFER DESCRIPTOR.
;	= ADDR. OF DESCRIPTOR OF "NONE" IF NO QUOTA IS PRESENT
;	= ADDR. OF STRING CONTAINING VALUE IF QUOTA IS PRESENT
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENTRY	CNVT_WS,^M<>
	PUSHAQ	NONE_SPEC		; ASSUME NO QUOTA SPECIFIED
	BBC	16(AP),12(AP),10$	; TEST ASSUMPTION - BR IF TRUE
	MOVL	#5,@8(AP)		; SET LENGTH OF OUTPUT BUFFER
	$FAO_S	CTRSTR=CNV_ASCII,-	; ADDR. OF CONTROL STRING
		OUTLEN=@8(AP),-		; PLACE TO PUT LENGTH OF RESULT
		OUTBUF=@8(AP),-		; PLACE TO PUT RESULT
		P1=4(AP)		; VALUE TO CONVERT TO ASCII
	MOVL	8(AP),(SP)		; ADDR. OF DESC. OF OUTPUT
10$:	MOVL	(SP)+,R1		; RETURN THIS ADDR. IN R1
	RET

	.PAGE
	.SBTTL	CONVERT TIME LIMIT TO ASCII STRING
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CONVERT A TIME LIMIT TO AN ASCII STRING
;
; CALLING SEQUENCE:
;
;	CALLS	CNVT_TIME
;
; INPUT PARAMETERS:
;
;	4(AP)  IS THE LONGWORD CONTAINING THE TIME VALUE
;	8(AP)  IS THE ADDR. OF THE OUTPUT BUFFER DESCRIPTOR
;	12(AP) IS THE ADDR. OF THE QUOTA PRESENT FLAG
;	16(AP) IS THE LONGWORD CONTAINING THE BIT TO TEST IN THE QUOTA
;	       PRESENT FLAG TO DETERMINE IF THE QUOTA IS THERE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R1 CONTAINS THE ADDR. OF THE OUTPUT BUFFER DESCRIPTOR
;	= ADDR. OF DESCRIPTOR OF "NONE" IF NO QUOTA PRESENT
;	= ADDR. OF STRING REPRESENTING TIME VALUE IF QUOTA IS PRESENT
;
; IMPLICIT OUTPUTS:
;
;	QUAD_TIME CONTAINS VALUE OF LONGWORD TIME CONVERTED TO QUAD WORD
;	VALUE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.ENTRY	CNVT_TIME,^M<R2,R3,R4,R5>
	PUSHAQ	NONE_SPEC		; ASSUME NO QUOTA SPECIFIED
	BBC	16(AP),12(AP),10$	; TEST ASSUMPTION - BR IF TRUE
	MOVL	#16,@8(AP)		; SET LENGTH OF OUTPUT BUFFER
	MOVAL	INFI_TIME,(SP)		; ASSUME INFINITE TIME
	MOVL	4(AP),R0		; GET VALUE OF TIME
	BEQL	10$			; BR IF INFINITE
	CLRL	R3			; CLEAR VALUE TO BE ADDED IN EMUL
	BLBC	R0,5$			; TEST LOW BIT OF TIME
	MOVL	#^X0FFFE7960,R3		; ADD -.01 SEC. IN 100 NS. UNITS
5$:	EXTZV	#1,#31,R0,R0		; SHIFT RIGHT 1
	EMUL	#-20*10*1000,R0,R3,QUAD_TIME	; CONVERT TO QUAD WORD
	$FAO_S	CTRSTR=CNV_ATIME,-	; ADDR. OF CONTROL STRING
		OUTLEN=@8(AP),-		; PLACE TO PUT LENGTH OF RESULT
		OUTBUF=@8(AP),-		; PLACE TO PUT RESULT
		P1=TIME_ADDR		; ADDR. OF QUAD WORD TIME
	MOVL	8(AP),(SP)		; ADDR. OF DESC. OF OUTPUT
	MOVL	(SP),R0			; ADDR. OF DESC. OF OUTPUT
	MOVL	4(R0),R0		; ADDR. OUTPUT BUFFER
	ADDL3	#3,R0,R1		; MOVE PAST FIRST 3 CHARS.
	MOVC5	#13,(R1),#^A/ /,#16,(R0) ; RE-ARRANGE STRING
10$:	MOVL	(SP)+,R1		; RETURN THIS ADDR. IN R1
	RET

	.PAGE
	.SBTTL	FORMAT AND OUTPUT QUOTAS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO FORMAT AND OUTPUT THE WS DEFAULT, WS
;	QUOTA AND CPU LIMIT FOR A BATCH JOB ENTRY
;
; CALLING SEQUENCE:
;
;	JSB/BSB	PJOB_QUOTAS
;
; INPUT PARAMETERS:
;
;	R4 CONTAINS THE ADDR. OF THE JOB HEADER RECORD
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE LINE CONTAINING THE QUOTAS IS FORMATTED AND OUTPUT
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

PJOB_QUOTAS:
	PUSHL	#SJH$V_CPULIM		; BIT INDICATING PRESENCE
	MOVZWL	SJH$W_QUOFLG(R4),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_DEFCPUT		; ADDR. OUTPUT DESC.
	PUSHL	SJH$L_CPULIM(R4)	; VALUE OF CPU TIME LIMIT
	CALLS	#4,CNVT_TIME		; CONVERT TO ASCII
	PUSHL	R1			; ADDR. OF DESC.

	PUSHL	#SJH$V_WSXTNT		; BIT INDICATING PRESENCE
	MOVZWL	SJH$W_QUOFLG(R4),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_WSEXT		; ADDR. OUTPUT BUFF DESC.
	MOVZWL	SJH$W_WSEXTNT(R4),-(SP)	; VALUE OF WS QUOTA
	CALLS	#4,CNVT_WS		; CONVERT TO ASCII
	PUSHL	R1			; ADDR. OF DESC.

	PUSHL	#SJH$V_WSQUTA		; BIT INDICATING PRESENCE
	MOVZWL	SJH$W_QUOFLG(R4),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_WSQTA		; ADDR. OUTPUT BUFF DESC.
	MOVZWL	SJH$W_WSQUTA(R4),-(SP)	; VALUE OF WS QUOTA
	CALLS	#4,CNVT_WS		; CONVERT TO ASCII
	PUSHL	R1			; ADDR. OF DESC.

	PUSHL	#SJH$V_WSDFLT		; BIT INDICATING PRESENCE
	MOVZWL	SJH$W_QUOFLG(R4),-(SP)	; QUOTA PRESENT FLAG
	PUSHAQ	ASCII_WSDFLT		; ADDR. OUTPUT BUFF DESC.
	MOVZWL	SJH$W_WSDFLT(R4),-(SP)	; VALUE OF WS DEFAULT
	CALLS	#4,CNVT_WS		; CONVERT TO ASCII
	PUSHL	R1			; ADDR. OF DESC

	FAOUT	JOBQUO,4		; PRINT THE LINE
	RSB				; RETURN


	.PAGE
	.SBTTL	FORMAT AND OUTPUT PRINT JOB CHARACTERISTICS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO FORMAT AND OUTPUT THE JOB COPY COUNT,
;	FORMS TYPE, AND REQUIRED DEVICE DEQUEUE CHARACTERISTICS.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	PJOB_CHAR
;
; INPUT PARAMETERS:
;
;	R4 CONTAINS THE ADDR. OF THE JOB HEADER RECORD
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	A LINE CONTAINING THE CHARACTERISTICS IS FORMATTED AND OUTPUT
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

PJOB_CHAR:
10$:	CLRL	R0			; INIT CHARACTERISTICS COUNT
	MOVZWL	#127,R1			; INIT CHARACTERISTIC NUMBER
20$:	BBC	R1,SJH$T_DQCHAR(R4),30$	; BR IF CHARACTERISTIC NOT SPECIFIED
	PUSHL	R1			; ELSE, PUSH CHARACTERISTIC NUMBER
	INCL	R0			; INCREMENT CHARACTERISTIC COUNT
30$:	SOBGEQ	R1,20$			; DECREMENT CHARACTERISTIC NUMBER, LOOP
	PUSHL	R0			; PUSH CHARACTERISTICS COUNT
	BNEQ	40$			; BR IF SOME - ALWAYS DISPLAY
	CMPB	SJH$B_COPYCNT(R4),#1	; JOB COUNT GREATER THAN 1?
	BGTRU	40$			; BR IF YES
	TSTB	SJH$B_FORMS(R4)		; FORMS TYPE SPECIFIED?
	BEQL	50$			; BR IF NO - DON'T DISPLAY
40$:	MOVZBL	SJH$B_FORMS(R4),-(SP)	; PUSH FORMS TYPE
	MOVZBL	SJH$B_COPYCNT(R4),-(SP)	; PUSH JOB COUNT
	FAOUT	DVJOBX,2		; PRINT ADDITIONAL INFORMATION
50$:	MOVL	(SP)+,R0		; GET CHARACTERISTICS COUNT
	MOVAL	(SP)[R0],SP		; REMOVE CHARACTERISTICS FROM STACK
	RSB

	.END
