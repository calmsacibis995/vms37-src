	.TITLE  SHOW$MSG_UTIL - MESSAGE PRINTING UTILITIES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: 	SHOW COMMAND, MESSAGE UTILITY ROUTINES
;
; ABSTRACT:
;
;	This module contains all message formatting and printing utilities
;	for the SHOW command
;
; ENVIRONMENT:
;
;	AUTHOR: BEATRICE U.WALTHER,	CREATION DATE:	10-OCT-1977
;
; MODIFIED BY:
;
;	V03-001	GAS0065		Gerry Smith		29-Mar-1982
;		If an error occurs during open or write to SYS$OUTPUT,
;		signal the error and stop.
;
;	, : VERSION
; 01	- 
;
; 02	Gary Fowler 	22-May-1979
;	Remove FOP from $FAB so new output file will be created if
;	SYS$OUTPUT is reassigned to a file that already exists.
;	
; 03    Jim Teague
;	Changed W^ references to L^ references.
;
;--

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$RMSDEF
;
; MACROS:
;


;
; EQUATED SYMBOLS:
;
;
; define structure of a message table entry
;

$DEFINI	MSG
$DEF	MSG_Q_TEXT:
	.BLKQ	1		; descriptor to message text
$DEF	MSG_B_CODE:
	.BLKB	1		; code associated with message
$DEF	MSG_B_CONTIN:
	.BLKB	1		; continuation flag
$DEF	MSG_B_PARAM:
	.BLKB	1		; count of associated FAO parameters
	.BLKB	1		; (spare)	
$DEF	MSG_K_LENGTH:
				; length of message table entry
$DEFEND	MSG

;
; define shared messages for open/write errors
;
$SHR_MSGDEF	SHOW, 120, LOCAL,-	; make it a SHOW error
		<<OPENOUT,ERROR>,-	; error opening file
		<WRITEERR,ERROR>>	; error writing to file

;
; OWN STORAGE:
;

	.PSECT	SHOW$RWDATA	LONG,RD,WRT,NOEXE

OUTPUT_DNA:					; FILE NAME STRING
	.ASCII	/SYS$OUTPUT:/
OUTPUT_DNA_LEN =.-OUTPUT_DNA
	.ALIGN	LONG
OUTPUT_FAB:
	$FAB	FAC=PUT,-			; ALLOCATE FILE ACCESS BLOCK
		DNA=OUTPUT_DNA,-		; FOR OUTPUT
		DNS=OUTPUT_DNA_LEN,-
		NAM=OUTPUT_NAM,-		; PROVIDE A NAME BLOCK
		RAT=CR			; APPEND A CARRIAGE RETURN

OUTPUT_RAB:
	$RAB	FAB=OUTPUT_FAB			; AND RECORD ACCESS BLOCK
OUTPUT_NAM:
	$NAM	ESA=OUT_ESA,-			; EXPANDED NAME
		ESS=NAM$C_MAXRSS,-
		RSA=OUT_RSA,-			; RESULTANT NAME
		RSS=NAM$C_MAXRSS
OUT_RSA:
	.BLKB	NAM$C_MAXRSS			; RESERVE SPACE FOR RESULTANT STRING
OUT_ESA:
	.BLKB	NAM$C_MAXRSS			; RESERVE SPACE FOR EXPANDED STRING
RMS_STATUS:
	.BLKL	1				; RESERVE LONGWORD FOR RMS STATUS CODE
OUTPUT_LENGTH:
	.BLKL	1				; ACTUAL LENGTH OF OUTPUT BUFFER
SHOW$GQ_OUT_DSC::
	.LONG	OUT_BUFF_LENGTH			; BUILD DESCRIPTOR FOR OUTPUT  BUFFER
	.LONG 	OUTPUT_BUFFER			; 
OUTPUT_BUFFER:
	.BLKB	256				; ALLOCATE OUTPUT BUFFER
OUT_BUFF_LENGTH =.-OUTPUT_BUFFER

	.SBTTL	SHOW$PRINT_MSG		- PRINT MESSAGE ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE FORMATS ALL MESSAGES AND PRINTS THEM ON SYS$OUTPUT:
;	OR SYS$ERROR DEPENDING ON THE CODE ASSOCIATED WITH THE MESSAGE.
;	( SEE DESCRIPTION OF MACRO SHOW_DEFMSG FOR FORMAT OF MESSAGE TABLE)
;
; CALLING SEQUENCE:
;
;		PUSHL	#SHOW$_<MESSAGE MNEMONIC>
;		PUSHAL	ARGLIST
;		CALLS #2,SHOW$PRINT_MSG
;
; INPUT PARAMETERS:
;
;	4(AP)=	MESSAGE IDENTIFICATION NUMBER
;	8(AP)=	POINTER TO ARGUMENT LIST FOR $FAOL
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUT PARAMETERS:
;
; 	NONE
;
; IMPLICIT OUTPUT PARAMETERS:
;
;	CALLS ROUTINE SHOW$PRINT_LINE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

	.ENTRY	SHOW$PRINT_MSG,^M<R10,R11>		

;
; initialize
;

	PUSHR	#^M<R0>			; save status code 
	MULL3	8(AP),#MSG_K_LENGTH,R11
					; CALCULATE OFFSET INTO MESSAGE TABLE
	MOVL 	4(AP),R10		; POINTER TO FAO PARAMETER LIST

;
; format a message line
;


10$:
	$FAOL_S		-		; FORMAT MESSAGE INTO OUPUT BUFFER
		CTRSTR=L^SHOW$A_MSGTXT(R11), -	; FAO CONTROL STRING
		OUTLEN=L^OUTPUT_LENGTH, -		; WORD TO RECEIVE ACTUAL LENGTH
		OUTBUF=L^SHOW$GQ_OUT_DSC, -	; OUTPUT BUFFER DESCRIPTOR
		PRMLST=(R10)			; PARAMETER LIST
	BLBC	R0,99$			; branch on error

;
; print formatted line 
;


	PUSHAL	W^OUTPUT_BUFFER		; ADDRESS OF OUTPUT MESSAGE STRING
	PUSHL	W^OUTPUT_LENGTH		; RESULTANT LENGTH OF OUTPUT MESSAGE
	CALLS	#2,W^SHOW$PRINT_LINE	; PRINT LINE ON SYS$OUTPUT:
	BLBC	R0,99$			; branch on error

;
; get next line of message
;


	BLBC	L^SHOW$A_MSGTXT+MSG_K_LENGTH+MSG_B_CONTIN(R11),90$
					; NO CONTINUATION
	MOVZBL	L^SHOW$A_MSGTXT+MSG_B_PARAM(R11),R0
					; SKIP FAO PARAMETERS ALREADY PROCESSED
	ADDL2	R0,R10			; UPDATE POINTER TO PARAMETER LIST
	ADDL2	#MSG_K_LENGTH,R11	; SKIP TO NEXT MESSAGE ENTRY
	BRB	10$			; AND PROCESS NEXT LINE OF MESSAGE

;
; exits
;

90$:
	POPR	#^M<R0>			; restore return code
99$:	RET				; ALL DONE

	.SBTTL	SHOW$PRINT_LINE 	- PRINT LINE ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PRINTS A LINE ON DEVICE SYS$OUTPUT
;
; CALLING SEQUENCE:
;
;		PUSHAL	OUT_BUFFER
;		PUSHL	OUT_LENGTH
;		CALLS 	#2,SHOW$PRINT_LINE
;
;	WHERE:	OUT_LENGTH =  LENGTH OF CHARACTER STRING TO PRINT
;		OUT_BUFFER =  ADDRESS OF STRING TO PRINT
;
;	A CR/LF IS AUTOMATICALLY APPENDED FOR EACH CALL
;
;	NOTE:
;	IT IS HIGHLY RECOMMENDED TO USE THE COMMON LINE BUFFER PROVIDED
;	 THE DESCRIPTOR OF WHICH IS ADDRESSED BY GLOBAL SYMBOL:
;			SHOW$GQ_OUT_DSC
;
;
;
; INPUT PARAMETERS:
;
;		OUT_BUFFER
;		OUT_LENGTH
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	LINE IS PRINTED ON SYS$OUTPUT:
;
; COMPLETION CODES:
;
;	RMS COMPLETION CODES
;
; SIDE EFFECTS:
;
;
;	OPENS AND CONNECTS SYS$OUTPUT: IF NECESSARY
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

	.ENTRY	SHOW$PRINT_LINE,^M<R2,R3>

;
; open SYS$OUTPUT: if not opened
;

	TSTW	W^RAB$W_ISI+OUTPUT_RAB	; HAS OUTPUT ALREADY BEEN OPENED ?
	BNEQ	10$			; YES
	MOVL	#SHOW$_OPENOUT,R2	; ASSUME ERROR OPENING
	$CREATE	FAB=W^OUTPUT_FAB		; NO, OPEN IT
	BLBC	R0,100$			; BRANCH ON ERROR
	$CONNECT RAB=W^OUTPUT_RAB		; AND CONNECT
	BLBC	R0,100$			; branch on error

;
; print line on SYS$OUTPUT:
;

10$:
	MOVL	8(AP),W^OUTPUT_RAB+RAB$L_RBF
					; INSERT OUTPUT BUFFER ADDRESS
	MOVW 	4(AP),W^OUTPUT_RAB+RAB$W_RSZ
					; INSERT OUTPUT BUFFER LENGTH
	MOVL	#SHOW$_WRITEERR,R2	; ASSUME ERROR WRITING
	$PUT	RAB=W^OUTPUT_RAB	; ISSUE RMS CALL TO PUT LINE
	BLBC	R0,100$			; BRANCH IF ERROR
;
; exit
;

90$:
	RET				; RETURN

;
; if an error occurred doing I/O, signal it here and stop
;

100$:
	PUSHL	R0			; PUSH ERROR STATUS
;
; check for non-zero RSL.  If no resultant name string, try the
; expanded name string.  If both fail, simply use SYS$OUTPUT
;
	MOVZBL	OUTPUT_NAM+NAM$B_RSL,SHOW$GQ_OUT_DSC
	BEQL	110$
	MOVAL	OUT_RSA,SHOW$GQ_OUT_DSC+4
	BRB	130$
110$:
	MOVZBL	OUTPUT_NAM+NAM$B_ESL,SHOW$GQ_OUT_DSC
	BEQL	120$
	MOVAL	OUT_ESA,SHOW$GQ_OUT_DSC+4
	BRB	130$
120$:
	MOVL	#OUTPUT_DNA_LEN,SHOW$GQ_OUT_DSC
	MOVAL	OUTPUT_DNA,SHOW$GQ_OUT_DSC+4
130$:
	PUSHAL	SHOW$GQ_OUT_DSC		; PUSH OUTPUT DESCRIPTOR
	PUSHL	#1
	PUSHL	R2			; PUSH ERROR MESSAGE
	CALLS	#4,G^LIB$STOP		; SIGNAL AND STOP
	.END

