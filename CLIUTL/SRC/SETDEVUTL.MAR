	.TITLE	SETDEVUTL - SET DEVICE UTILITIES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITY "SET"
;
; ABSTRACT:	UTILITIES FOR SET$DEV AND SET$PROT
;
; AUTHOR:	LEN KAWELL 3-MAY-1978
;
; MODIFIED BY:
;
;	V03-001	EAD0055		Elliott A. Drayton	29-Mar-1982
;		In set dual port code, allow dual port enable to be done
;		without the volume being dismounted.
;
;	V02-002	EAD0001		Elliott A. Drayton	 2-Jan-1982
;		Added code to set and clear device available bit and the
;		dual port bit in disk UCB's.
;
;--
;
; LOCAL MACROS
;
 
;
; EXTERNAL SYMBOLS
;
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$UCBDEF				; UCB OFFSETS
	$VCBDEF				; VCB OFFSETS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$DYNDEF				; DYNAMIC STORAGE DEFINTIONS
	$IRPDEF				; I/O REQUEST PACKET DEFINTIONS
	$CCBDEF				; CHANNEL CONTROL BLOCK DEFINTIONS
	$CLIMSGDEF			; CLI MESSAGES
;
; ARGUMENT OFFSETS
;
UCB1	= 4				; ADDRESS OF UCB 1
UCB2	= 8				; ADDRESS OF UCB 2
CCB1	= 8				; ADDRESS OF UCB1'S CCB
FLAG	= 8				; ENABLE/DISABLE FLAG
PROT	= 8				; PROTECTION VALUE
Q_DESC	= 12				; QUEUE NAME CHARACTER DESCRIPTOR
UIC	= 12				; OWNER UIC
	.PAGE
	.SBTTL	SET SPOOLED
	.PSECT	SET$CODE,NOWRT
;++
; SET$DEV_SPOOL - KERNEL ACCESS MODE TO SET A DEVICE SPOOLED
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL LINK TWO UCBS TOGETHER TO ALLOW IMPLICIT SPOOLING.
;
; 1) LOCK I/O DATABASE FOR WRITE;
; 2) CHECK THAT SPOOL DEVICE'S REFERENCE COUNT (UCB$W_REFC) IS 1;
; 3) CHECK THAT A VOLUME IS MOUNTED ON INTERMEDIATE DEVICE AND THAT
;    IT IS NOT MARKED FOR DISMOUNT;
; 4) GET DYNAMIC STORAGE, MOVE QUEUE NAME STRING TO IT, AND SET
;    SPOOLED DEVICE'S VCB ADDRESS TO THE ADDRESS OF THE QUEUE NAME;
; 5) INCREMENT REFERENCE COUNT OF INTERMEDIATE DEVICE AND TRANSACTION
;    COUNT OF OF ITS ASSOCIATED VCB;
; 6) STORE ADDRESS OF INTERMEDIATE DEVICE UCB IN SPOOLED DEVICE'S
;    ASSOCIATED UCB ADDRESS (UCB$L_AMB);
; 7) SET SPOOLED DEVICE'S SPOOL BIT (DEV$V_SPL IN UCB$L_DEVCHAR);
; 8) UNLOCK I/O DATABASE.
;
;
; INPUTS:
;
;	UCB1(AP) = UCB OF DEVICE TO BE SPOOLED
;	UCB2(AP) = UCB OF INTERMEDIATE DEVICE
;	Q_DESC(AP) = CHARACTER STRING DESCRIPTOR OF QUEUE NAME
;
; OUTPUTS:
;
;	R0 = 1 IF SUCCES SETTING UP UCBS
;	   = SYSTEM STATUS CODE IF ANY ERROR
;--
SET$DEV_SPOOL::
	.WORD	^M<R2,R3,R4,R5,R6,R7>	; SAVE REGISTERS
;
; LOCK I/O DATABASE FOR WRITE AND CHECK IF DEVICES VALID FOR SPOOLING
;
	BSBW	LOCK_IODB		; LOCK THE I/O DATABASE
	MOVL	UCB1(AP),R6		; GET ADDR OF SPOOLED DEV'S UCB
	BBC	#DEV$V_SPL,UCB$L_DEVCHAR(R6),5$ ; IF CLEAR DEVICE NO SPOOLED
	PUSHL	#CLI$_DEVALSPL		; SET DEVICE ALREADY SPOOLED
	BRW	100$			; EXIT
5$:	CMPW	UCB$W_REFC(R6),#1	; IS SPOOLED DEV'S REF COUNT 1?
	BEQL	10$			; IF EQL YES
	MOVZWL	#SS$_DEVASSIGN!4,-(SP)	; SET DEVICE ALREADY ASSIGNED
	BRW	100$			; EXIT
10$:	MOVL	UCB2(AP),R7		; GET ADDR OF INTER DEV'S UCB
	BBC	#DEV$V_FOD,UCB$L_DEVCHAR(R7),20$ ;IF CLEAR NON-FILE ORIENTED
	BBS	#DEV$V_RND,UCB$L_DEVCHAR(R7),30$ ;IF SET IT'S A DISK
20$:	MOVZWL	#SS$_NOTFILEDEV,-(SP)	; SET NOT FILE DEVICE ERROR
	BRB	100$			; EXIT
30$:	BBC	#DEV$V_MNT,UCB$L_DEVCHAR(R7),40$ ;IF CLEAR NOT MOUNTED
	BBC	#DEV$V_DMT,UCB$L_DEVCHAR(R7),50$ ;IF SET DISMOUNTING
40$:	MOVZWL	#SS$_DEVNOTMOUNT,-(SP)	 ; SET NOT MOUNTED ERROR
	BRB	100$			 ; EXIT
;
; GET DYNAMINC STORAGE, MOVE QUEUE NAME TO IT AND SET VCB
; POINTER TO ITS ADDRESS
;
50$:	MOVZBL	#IRP$C_LENGTH,R1	; SIZE OF STORAGE 
					; (USE SIZE OF I/O REQUEST)
	JSB	@#EXE$ALONONPAGED	; ALLOCATE NON-PAGED MEMORY
	BLBS	R0,60$			; IF LOW SET - SUCCESS
	MOVZWL	#SS$_INSFMEM,-(SP)	; SET INSUFFICIENT MEMORY
	BRB	100$			; EXIT
60$:	MOVL	R2,UCB$L_VCB(R6)	; SET ADDRESS OF BLOCK IN UCB
	MOVW	R1,VCB$W_SIZE(R2)	; SET SIZE OF BLOCK
	MOVB	#DYN$C_VCB,VCB$B_TYPE(R2) ; SET TYPE OF BLOCK
	MOVAQ	Q_DESC(AP),R3		; GET ADDRESS OF QUEUE DESCIPTOR
	MOVB	(R3),VCB$B_TYPE+1(R2)	; SET QUEUE NAME SIZE
	MOVC3	(R3),@4(R3),VCB$B_TYPE+2(R2) ; SET QUEUE NAME
;
; INCREMENT THE INTERMEDIATE UCB AND VCB REFERENCE COUNTS, LINK THE
; THE UCB'S, AND SET THE SPOOLED DEVICE'S SPOOLED BIT.
;
	INCW	UCB$W_REFC(R7)		; INC REF COUNT OF INTERMEDIATE
	MOVL	UCB$L_VCB(R7),R0	; GET INTERMEDIATE VCB ADDR
	INCW	VCB$W_TRANS(R0)		; INC TRANSACTION COUNT OF VOLUME
	MOVL	R7,UCB$L_AMB(R6)	; SET INTERMEDIATE DEV UCB ADDR
	BBSS	#DEV$V_SPL,UCB$L_DEVCHAR(R6),80$ ; SET DEVICE SPOOLED
80$:	CLRL	UCB$L_PID(R6)		; CLEAR OUR OWNERSHIP
;
; UNLOCK I/O DATABASE AND RETURN STATUS
;
	PUSHL	#1			; SET SUCCESS
100$:	BSBW	UNLOCK_IODB		; UNLOCK I/O DATABASE
	POPL	R0			; SET STATUS
	RET

	.PAGE
	.SBTTL	SET NOSPOOLED
;++
; SET$DEV_NOSPOOL - KERNEL MODE ROUTINE TO SET A SPOOLED DEVICE NONSPOOLED
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL DISABLE IMPLICIT SPOOLING FOR A DEVICE.
;
; 2) LOCK I/O DATABASE FOR WRITE;
; 3) CHECK THAT DEVICE IS ACTUALLY SET SPOOLED (DEV$V_SPL);
; 4) CHECK THAT REFERENCE COUNT (UCB$W_REFC) IS 2;
; 5) DECREMENT THE REFERENCE COUNT BY 2;
; 6) CLEAR SPOOL BIT (DEV$V_SPL);
; 7) DEALLOCATE THE QUEUE NAME'S DYNAMIC STORAGE, AND CLEAR VCB ADDRESS;
; 8) GET ADDRESS OF INTERMEDIATE DEVICE'S UCB FROM UCB$L_AMD AND
;    CLEAR UCB$L_AMD;
; 9) DECREMENT TRANSACTION COUNT OF INTERMEDIATE DEVICE'S VCB;
; 10) MOVE ADDRESS OF INTERMEDIATE DEVICE'S UCB TO CHANNEL CONTROL BLOCK
;     OF SPOOLED DEVICE;
; 11) UNLOCK I/O DATABASE;
;
;
; INPUTS:
;
;	UCB1(AP) = ADDRESS OF UCB OF SPOOLED DEVICE
;	CCB1(AP) = ADDRESS OF CCB OF SPOOLED DEVICE
;
; OUTPUTS:
;
;	R0 = STATUS OF FUNCTION
;--
SET$DEV_NOSPOOL::
	.WORD	^M<R2,R3,R4,R5,R6>
;
; LOCK I/O DATABASE, CHECK THAT NO ONE HAS ANY CHANNELS ASSIGNED TO
; THE DEVICE, CHECK THAT DEVICE IS ACTUALLY SPOOLED, AND CLEAR THE
; SPOOLED FLAG.
;
	BSBW	LOCK_IODB		; LOCK THE I/O DATABASE
	MOVL	UCB1(AP),R6		; GET ADDR OF SPOOLED DEV'S UCB
	CMPW	UCB$W_REFC(R6),#2	; ANY OTHER CHANNELS ASSIGNED?
	BLEQ	10$			; IF LEQ NO
	MOVZWL	#SS$_DEVASSIGN!4,-(SP)	; SET DEVICE ASSIGNED ERROR
	BRB	50$			; EXIT

10$:	BBSC	#DEV$V_SPL,UCB$L_DEVCHAR(R6),20$ ; IF SET IT'S SPOOLED
	PUSHL	#CLI$_DEVNOTSPL		; SET NOT SPOOLED ERROR
	BRB	50$			; EXIT

;
; UNLOCK THE UCB'S AND VCB AND DEALLOCATE QUEUE NAME STORAGE
;
20$:	DECW	UCB$W_REFC(R6)		; "DE-ASSIGN" OUR CHANNEL
	MOVL	UCB$L_VCB(R6),R0	; SET ADDRESS OF QUEUE NAME
	JSB	@#EXE$DEANONPAGED	; DEALLOCATE ITS STORAGE
	CLRL	UCB$L_VCB(R6)		; CLEAR QUEUE NAME ADDRESS
	MOVL	UCB$L_AMB(R6),R1	; GET ADDR OF INTERMEDIATE UCB
	CLRL	UCB$L_AMB(R6)		; CLEAR ADDR OF INTERMEDIATE UCB
	MOVL	UCB$L_VCB(R1),R0	; GET ADDR OF INTERMEDIATE VCB
	DECW	VCB$W_TRANS(R0)		; DECREMENT ITS TRANSACTION CNT
	MOVL	CCB1(AP),R0		; GET ADDRESS OF CCB
	MOVL	R1,CCB$L_UCB(R0)	; CHANGE UCB ADDRESS TO THAT
					; OF THE INTERMEDIATE DEVICE
;
; UNLOCK I/O DATABASE AND RETURN STATUS
;
	PUSHL	#1			; SET SUCCESS
50$:	BSBW	UNLOCK_IODB		; UNLOCK I/O DATABASE
	POPL	R0			; SET STATUS
	RET


	.PAGE
	.SBTTL	SET [NO]AVAILABLE
;++
; SET$DEV_AVAIL - KERNEL MODE ROUTINE TO ENABLE/DISABLE DEVICE AVAILABLE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL SET OR CLEAR THE AVAILABLE BIT (DEV$V_AVL) IN THE
; DEVICE'S UCB.
;
;
; INPUTS:
;
;	UCB1(AP) = ADDRESS OF DEVICE'S UCB
;	FLAG(AP) = ENABLE OR DISABLE FLAG
;
; OUTPUTS:
;
;	R0 = STATUS OF FUNCTION
;--
SET$DEV_AVAIL::
	.WORD	0
	MOVL	UCB1(AP),R0		; GET THE DEVICE'S UCB ADDRESS
	BBC	#DEV$V_MNT, -		; IF CLEAR, THE DEVICE IS NOT MOUNTED
		UCB$L_DEVCHAR(R0),10$
	MOVZWL	#SS$_DEVNOTDISM,R0	; SET DEVICE NOT DISMOUNTED
	BRB	20$			; EXIT
10$:	INSV	FLAG(AP),#DEV$V_AVL, -	; SET/CLEAR BIT
		#1,UCB$L_DEVCHAR(R0) 
	MOVL	#1,R0			; SET SUCCESS
20$:	RET				; RETURN
	.PAGE
	.SBTTL	SET [NO]DUAL_PORT
;++
; SET$DEV_DUAL - KERNEL MODE ROUTINE TO ENABLE/DISABLE DUAL_PORT BIT.
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL SET OR CLEAR THE DUAL_PORT BIT (DEV$V_DUA) IN THE
; DEVICE'S UCB.
;
;
; INPUTS:
;
;	UCB1(AP) = ADDRESS OF DEVICE'S UCB
;	FLAG(AP) = ENABLE OR DISABLE FLAG
;
; OUTPUTS:
;
;	R0 = STATUS OF FUNCTION
;--
SET$DEV_DUAL::
	.WORD	0
	MOVL	UCB1(AP),R0		; GET THE DEVICE'S UCB ADDRESS
	BLBS	FLAG(AP),10$		; IF AN ENABLE FUNCTION, GO DO IT
	BBC	#DEV$V_MNT, -		; IF CLEAR, THE DEVICE IS NOT MOUNTED
		UCB$L_DEVCHAR(R0),10$
	MOVZWL	#SS$_DEVNOTDISM,R0	; SET DEVICE NOT DISMOUNTED
	BRB	20$			; EXIT
10$:	INSV	FLAG(AP),#DEV$V_DUA,#1,UCB$L_DEVCHAR(R0) ; SET/CLEAR BIT
	MOVL	#1,R0			; SET SUCCESS
20$:	RET				; RETURN

	.PAGE
	.SBTTL	SET [NO]ERROR LOGGING
;++
; SET$DEV_ERLG - KERNEL MODE ROUTINE TO ENABLE/DISABLE ERROR LOGGING
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL SET OR CLEAR THE ERRLOG BIT (DEV$V_ELG) IN THE
; DEVICE'S UCB.
;
;
; INPUTS:
;
;	UCB1(AP) = ADDRESS OF DEVICE'S UCB
;	FLAG(AP) = ENABLE OR DISABLE FLAG
;
; OUTPUTS:
;
;	R0 = STATUS OF FUNCTION
;--
SET$DEV_ERLG::
	.WORD	0
	MOVL	UCB1(AP),R0		; GET THE DEVICE'S UCB ADDRESS
	INSV	FLAG(AP),#DEV$V_ELG,#1,UCB$L_DEVCHAR(R0) ; SET/CLEAR BIT
	MOVL	#1,R0			; SET SUCCESS
	RET				; RETURN

	.PAGE
	.SBTTL	SET DEVICE PROTECTION
;++
; SET$DEV_PROT - KERNEL MODE ROUTINE TO SET A DEVICE'S PROTECTION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL SET THE DEVICE PROTECTION FIELD, UCB$W_VPROT.
;
;
; INPUTS:
;
;	UCB1(AP) = ADDRESS OF DEVICE'S UCB
;	PROT(AP) = PROTECTION VALUE
;
; OUTPUTS:
;
;	R0 = STATUS OF FUNCTION
;--
SET$DEV_PROT::
	.WORD	0
	MOVL	UCB1(AP),R0		; GET THE DEVICE'S UCB ADDRESS
	MOVW	PROT(AP),UCB$W_VPROT(R0) ; SET DEVICE'S PROTECTION
	MOVL	UIC(AP),UCB$L_OWNUIC(R0) ; SET OWNER UIC
	MOVL	#1,R0			; SET SUCCESS
	RET				; RETURN

	.PAGE
	.SBTTL	LOCK/UNLOCK I/O DATABASE
;++
; LOCK_IDB/UNLOCK_IDB - LOCK AND UNLOCK THE SYSTEM I/O DATABASE
;
; FUNCTIONAL DESCRIPTION:
;
;	LOCK - GETS THE I/O DATABASE MUTEX FOR WRITE
;	UNLOCK - RETURNS THE I/O DATABASE MUTEX AND RETURNS IPL TO 1.
;
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	I/O DATABASE LOCKED AND IPL RAISED OR UNLOCKED AND IPL LOWERED
;--

LOCK_IODB:
	MOVAL	@#IOC$GL_MUTEX,R0	; GET I/O DATA BASE MUTEX
	MOVL	@#SCH$GL_CURPCB,R4	; GET OWN PCB ADDRESS
	JSB	@#SCH$LOCKW		; AND LOCK IT
	RSB

UNLOCK_IODB:
	MOVAL	@#IOC$GL_MUTEX,R0	; GET I/O DATA BASE MUTEX
	MOVL	@#SCH$GL_CURPCB,R4	; AND OWN PCB ADDRESS
	JSB	@#SCH$UNLOCK		; AND UNLOCK IT
	SETIPL	#0			; ALSO LOWER IPL
	RSB

	.END
