	.TITLE	SETDEV - SET SPECIAL CHARACTERISTICS OF A DEVICE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITY "SET"
;
; ABSTRACT:	SET THE CHARACTERISTICS OF A DEVICE
;
; AUTHOR:	LEN KAWELL 3-MAY-1978
;
; MODIFIED BY:
;
;	V02-005 EAD0050		Elliott A. Drayton	12-Jan-1982
;		Added code to set and clear the DEV$V_AVL bit and the
;		DEV$V_DUA in UCB$L_DEVCHAR.
;
;	V02-004	MIR0051		Michael I. Rosenblum	25-Aug-1981
;		Fix to SYS$ASSIGN to do compleat translations make
;		it more advantagious to use that rather than LIB$ASSIGN_DEV
;
;	V02-003	MIR0022		Michael I. Rosenblum	24-Aug-1981
;		Fixed problem with a lack of translations on logical
;		names.
;
;	002	TMH0001		Tim Halvorsen	21-Jan-1980
;		Allow SET PROT/DEVICE for non-sharable devices
;--
;
; LOCAL MACROS
;
	.MACRO	CALLBAK	P1,P2
	.IF B <P2>
	PUSHAB	W^BITS			; ADDRESS OF BIT MASK
	.IFF
	PUSHAB	P2			; ADDRESS OF THIRD ARGUEMENT
	.ENDC
	PUSHAB	W^SET$A_CLIWORK	; COMMON WORK AREA
	PUSHAB	P1			; THE REQUEST DESCRIPTOR
	CALLS	#3,@CLI$A_UTILSERV(AP)	; REQUEST THE SERVICE OF THE CLI
	.ENDM				;
 
;
; EXTERNAL SYMBOLS
;
	$CLIMSGDEF			; CLI MESSAGE DEFINTIONS
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$DCDEF				; DEVICE CLASS DEFINITIONS
	$CCBDEF				; CHANNEL CONTROL BLOCK OFFSETS
	$PRVDEF				; PRIVILEGE DEFINTIONS
	$JPIDEF				; GET JOB/PROCESS INFO DEFINITIONS
	$UCBDEF				; GET UCB OFFSETS
;
; LOCAL SYMBOLS
;

;
; LOCAL STORAGE
;
	.PSECT	SET$RWDATA,NOEXE,LONG
 
BITS:		.LONG	0		; STORAGE FOR CLI CALL BACK
CHAN1:		.BLKL	1		; I/O CHANNEL 1
CHAN2:		.BLKL	1		; I/O CHANNEL 2

;
; ARGUMENT LIST FOR CALLING SET$DEV UTILITIES
;
;	NOTE: THE FOLLOWING ARE ORDER DEPENDENT
;
ARG_LIST:
		.LONG	3		; ARG COUNT
UCB1:		.BLKL	1		; UCB ADDRESS OF CHANNEL 1
UCB2:					; UCB ADDRESS OF CHANNEL 2
PROT:					; OR PROTECTION CODE
FLAG:					; OR ENABLE/DISABLE FLAG
CCB1:		.BLKL	1		; OR CCB ADDRESS OF CHANNEL 1
UIC:					; OWNER UIC
Q_DESC:		.BLKQ	1		; OR QUEUE NAME DESCRIPTOR
; **** NOTE: THE PRECEDING ARE ORDER DEPENDENT ****

CHAN_INFO:	.LONG	0		; DEVICE'S CHANNEL INFO
CLASS:		.BLKB	1
TYPE:		.BLKB	1
BUFF:		.BLKW	1
CHAR:		.BLKB	4
;
DEV_NAME:				; REQUEST FOR DEVICE NAME
	$CLIREQDESC	RQTYPE=CLI$K_INPUT1
CHAR_QUAL:				; REQUEST FOR QUALIFIERS
	$CLIREQDESC	RQTYPE=CLI$K_GETQUAL
DEV_QUALS:				; SET DEVICE QUALIFIERS
SP_QUAL:
	$CLIQUALDESC	QDCODE=CLI$K_STDV_SPOO,TRUACT=SPOOL,FLSACT=NOSPOOL,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STDV_ERRO,TRUACT=ERROR_LOG,-
			FLSACT=NOERROR_LOG,QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STDV_AVAI, TRUACT=AVAILABLE, -
			FLSACT=NOAVAILABLE, QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STDV_DUAL, TRUACT=DUAL_PORT, -
			FLSACT=NODUAL_PORT, QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	END_LIST

PROT_QUALS:				; SET PROTECTION QUALIFIERS
	$CLIQUALDESC	QDCODE=CLI$K_STPR_DEVI,TRUACT=PROTECTION,
			QDFLGS=<CLI$V_QDEXPA>
OWN_QUAL:
	$CLIQUALDESC	QDCODE=CLI$K_STPR_OWNE
	$CLIQUALDESC	END_LIST


STRING_VAL:				; REQUEST FOR ASCII VALUE
	$CLIREQDESC	RQTYPE=CLI$K_ASCIIVAL

	.PSECT	SET$PURE,NOWRT,NOEXE

DEF_SPOOL_DEV:				; DEFAULT SPOOLING DEVICE NAME
	.LONG	20$-10$
	.LONG	10$
10$:	.ASCII	/SYS$DISK/
20$:
GET_CHAN_INFO:	.LONG	12		; CHANNEL INFO BUFFER DESCRIPTOR
		.LONG	CHAN_INFO

PROT_CLASS:				; PROTECTION CLASSES
	.ASCII	/WGOS/			; WORLD, GROUP, OWNER, SYSTEM
PROT_ACCESS:				; ACCESS PROTECTION CODES
	.ASCII	/LPWR/			; LOGICAL, PHYSICAL, WRITE, READ

GETJPI_UIC:				; SYS$GETJPI LIST TO GET UIC
	.WORD	4			;  SIZE OF UIC BUFFER
	.WORD	JPI$_UIC		;  REQUEST TYPE
	.LONG	UIC			;  ADDRESS OF UIC BUFFER
	.LONG	0			;  (DON'T NEED THE SIZE)
	.LONG	0			; END-OF-LIST

	.PAGE
	.PSECT	SET$CODE,NOWRT
;++
; SET$DEV - SET DEVICE CHARACTERISTICS
; SET$PROT - SET DEVICE PROTECTION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE WILL SET THE FOLLOWING DEVICE CHARACTERISTICS:
;
;	1) [NO]SPOOLING
;	2) [NO]ERROR_LOGGING
;	3) PROTECTION
;
; IT IS ENTERED AS A RESULT OF A DISPATCH FROM THE SET COMMAND PROCESSOR.
;
; INPUTS:
;
;	THE CLI DATA BASE IS SET UP. 
;
; OUTPUTS:
;
;	SET$L_STATUS = STATUS OF THE OPERATION
;--
	.ENABL	LSB

SET$PROT::
	.WORD	^M<R2>
	MOVL	#PROT_QUALS-CHAR_QUAL,-	; SET QUALIFIER LIST ADDRESS
		W^CLI$A_QUALST+CHAR_QUAL
	BRB	10$

SET$DEV::				; SET DEVICE CHARACTERISTICS
	.WORD	^M<R2>
	MOVL	#DEV_QUALS-CHAR_QUAL,-	; SET QUALIFIER LIST ADDRESS
		W^CLI$A_QUALST+CHAR_QUAL
10$:	MOVAB	W^DEV_NAME,R2		; ADDRESS QUAL DESC
	CALLBAK	(R2)			; CALL CLI FOR DEVICE NAME
	BLBC	R0,ERROR		;
	MOVAB	CLI$Q_RQDESC(R2),R2	; ADDRESS NAME DESC
20$:	$ASSIGN_S (R2),W^CHAN1		; ASSIGN THE CHANNEL
	BLBC	R0,ERROR		; IF LOW CLEAR THEN ERROR AND EXIT
	SUBL3	W^CHAN1,CTL$GL_CCBBASE,R0 ; GET DEVICE'S CCB ADDRESS
	MOVL	R0,W^CCB1		; SET CCB ADDRESS
	MOVL	CCB$L_UCB(R0),W^UCB1	; SET UCB ADDRESS
	$GETCHN_S	W^CHAN1,,W^GET_CHAN_INFO
	BLBS	R0,SET_CHAR		;
;
; ERROR ASSIGNING CHANNEL OR GETTING CHARACTERISTICS
;
ERROR:	MOVL	R0,W^SET$L_STATUS	; SAVE FOR EXIT STATUS
	RET				; RETURN
;
; PROCESS QUALIFIERS
;
SET_CHAR:				; PROCESS QUALIFIERS
	MOVZWL	#SS$_NORMAL,W^SET$L_STATUS; ASSUME SUCCESS
	CALLBAK	W^CHAR_QUAL		; PROCESS QUALIFIERS
	BLBC	R0,ERROR		;
100$:	$DASSGN_S	W^CHAN1		; DEASSIGN THE DEVICE
	RET				; RETURN

	.DSABL	LSB


	.PAGE
	.SBTTL	SET AVAILABLE 
;++ 
; AVAILABLE - SET DEVICE AVAILABLE 
; 
; FUNCTIONAL DESCRIPTION: 
; 
; THIS ACTION ROUTINE WILL SET DEV$_AVL IN THE DEVICE (DISK) 
; CHARACTERISTICS LONGWORD. 
; 
; 1) CHECK DEVICE FOR VALID DEVICE CLASS OR TYPE; 
; 2) CHECK THAT SPECIFIED DEVICE IS MOUNTED
; 3) SET SPECIFIED DEVICE'S AVAILABLE BIT (DEV$V_AVL IN UCB$L_DEVCHAR); 
; 
; 
; INPUTS: 
; 
;	CHAN1 = CHANNEL NUMBER OF SPECIFIED DEVICE 
;	UCB1 = UCB ADDRESS OF SPECIFIED DEVICE 
;	CHAN_INFO = CHANNEL INFO OF SPECIFIED DEVICE 
; 
; OUTPUTS: 
; 
;	SET$L_STATUS = STATUS OF THE OPERATION 
;-- 
	.ENABL	LSB 
 
AVAILABLE: 
	.WORD	^M<R2> 
	MOVL	#1,W^FLAG		; SET FLAG TO ENABLE 
	BRB	10$			;
 
NOAVAILABLE: 
	.WORD	^M<R2> 
	CLRL	W^FLAG			; SET FLAG TO DISABLE 

10$:	BSBW	OPER_PRIV		; CHECK THAT USER HAS OPERATOR PRIV

;
; CHECK SPECIFIED DEVICE CLASS 
;
 	CMPB	W^CLASS,#DC$_DISK	; DEVICE A DISK? 
	BEQLU	20$			; IF EQL YES
	MOVZWL	#SS$_IVDEVNAM,R0	; SET INVALID DEVICE ERROR 
	BRW	30$			; EXIT
;
; GO SET THE BIT
;
20$:
	$CMKRNL_S W^SET$DEV_AVAIL,-	; SET THE DEVICE AVAILABLE
		  W^ARG_LIST 
30$:
	MOVL	R0,W^SET$L_STATUS	; SET STATUS 
	RET				; RETURN 
 
	.DSABL	LSB 

	.PAGE
	.SBTTL	SET SPOOLED
;++
; SPOOL - SET DEVICE SPOOLED
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ACTION ROUTINE WILL SET UP A DEVICE (PRINTER OR TERMINAL) FOR
; IMPLICIT SPOOLING.
;
; 1) CHECK SPOOL DEVICE FOR VALID DEVICE CLASSES;
; 2) GET INTERMEDIATE DEVICE NAME, ASSIGN A CHANNEL TO IT, CHECK THAT
;    ITS A FILE-ORIENTED DEVICE, AND GET ITS UCB ADDRESS;
; 3) LOCK I/O DATABASE FOR WRITE;
; 4) CHECK THAT SPOOL DEVICE'S REFERENCE COUNT (UCB$W_REFC) IS 1;
; 5) CHECK THAT A VOLUME IS MOUNTED ON INTERMEDIATE DEVICE AND THAT
;    IT IS NOT MARKED FOR DISMOUNT;
; 6) GET DYNAMIC STORAGE, MOVE QUEUE NAME STRING TO IT, AND SET
;    SPOOLED DEVICE'S VCB ADDRESS TO THE ADDRESS OF THE QUEUE NAME;
; 7) INCREMENT REFERENCE COUNT OF INTERMEDIATE DEVICE AND TRANSACTION
;    COUNT OF OF ITS ASSOCIATED VCB;
; 8) STORE ADDRESS OF INTERMEDIATE DEVICE UCB IN SPOOLED DEVICE'S
;    ASSOCIATED UCB ADDRESS (UCB$L_AMB);
; 9) SET SPOOLED DEVICE'S SPOOL BIT (DEV$V_SPL IN UCB$L_DEVCHAR);
; 10) UNLOCK I/O DATABASE.
;
;
; INPUTS:
;
;	CHAN1 = CHANNEL NUMBER OF SPOOLED DEVICE
;	UCB1 = UCB ADDRESS OF SPOOLED DEVICE
;	CHAN_INFO = CHANNEL INFO OF SPOOLED DEVICE
;
; OUTPUTS:
;
;	SET$L_STATUS = STATUS OF THE OPERATION
;--
SPOOL:
	.WORD	^M<R2,R3,R4,R5,R6>

	BSBW	OPER_PRIV		; CHECK THAT USER IS OPERATOR
;
; CHECK SPOOLED DEVICE CLASS 
;
	CMPB	W^CLASS,#DC$_LP		; DEVICE A PRINTER?
	BEQLU	10$			; IF EQL YES
	CMPB	W^CLASS,#DC$_TERM	; DEVICE A TERMINAL?
	BEQLU	10$			; IF EQL YES
	MOVZWL	#SS$_IVDEVNAM,R0	; SET INVALID DEVICE ERROR
	BRW	100$			; EXIT
;
; GET THE QUEUE NAME - DEFAULT TO DEVICE'S NAME
;
10$:	MOVQ	W^CLI$Q_RQDESC+DEV_NAME,W^Q_DESC ; ASSUME DEFAULT
	TSTW	W^CLI$W_QDVALSIZ+SP_QUAL ; QUEUE NAME SPECIFIED?
	BEQL	20$			; IF EQL NO - USE DEFAULT
	CALLBAK W^STRING_VAL,W^SP_QUAL 	; GET QUEUE NAME
	MOVQ	W^CLI$Q_RQDESC+STRING_VAL,- ;GET VALUE DESCRIPTOR
		W^Q_DESC
;
; GET THE INTERMEDIATE DEVICE NAME, ASSIGN A CHANNEL TO IT,
; AND GET IT'S UCB ADDRESS
;
20$:	MOVAQ	W^DEF_SPOOL_DEV,R0	; ASSUME DEFAULT DEVICE
	BBC	#CLI$V_MOREVALS,-	; IF CLEAR NONE SPECIFIED
		W^CLI$B_RQSTAT+STRING_VAL,30$
	CALLBAK W^STRING_VAL,W^SP_QUAL	; GET DEVICE NAME
	MOVAQ	W^CLI$Q_RQDESC+STRING_VAL,R0 ; GET ADDR OF DESCRIPTOR
30$:	$ASSIGN_S (R0),W^CHAN2		; ASSIGN A CHANNEL TO IT
	BLBC	R0,100$			;
	SUBL3	W^CHAN2,CTL$GL_CCBBASE,R0 ; GET CCB ADDRESS
	MOVL	CCB$L_UCB(R0),W^UCB2	; SET UCB ADDRESS
	$CMKRNL_S W^SET$DEV_SPOOL,-	; SET THE DEVICE SPOOLED
		  W^ARG_LIST
100$:
	MOVL	R0,W^SET$L_STATUS	; SET STATUS
	RET				; RETURN
	.PAGE
	.SBTTL	SET NOSPOOLED
;++
; NOSPOOL - SET DEVICE NOT SPOOLED
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ACTION ROUTINE WILL DISABLE IMPLICIT SPOOLING FOR A DEVICE.
;
; 1) LOCK I/O DATABASE FOR WRITE;
; 2) CHECK THAT DEVICE IS ACTUALLY SET SPOOLED (DEV$V_SPL);
; 3) CHECK THAT REFERENCE COUNT (UCB$W_REFC) IS 2;
; 4) DECREMENT THE REFERENCE COUNT BY 2;
; 5) CLEAR SPOOL BIT (DEV$V_SPL);
; 6) DEALLOCATE THE QUEUE NAME'S DYNAMIC STORAGE, AND CLEAR VCB ADDRESS;
; 7) GET ADDRESS OF INTERMEDIATE DEVICE'S UCB FROM UCB$L_AMD AND
;    CLEAR UCB$L_AMD;
; 8) DECREMENT TRANSACTION COUNT OF INTERMEDIATE DEVICE'S VCB
; 9) MOVE ADDRESS OF INTERMEDIATE DEVICE'S UCB TO CHANNEL CONTROL BLOCK
;     OF SPOOLED DEVICE;
; 10) UNLOCK I/O DATABASE;
; 11) QUEUE IO$_ACPCONTROL ON CHANNEL TO ASSURE DISMOUNT IF NEEDED.
;
;
; INPUTS:
;
;	CHAN1 = CHANNEL NUMBER OF SPOOLED DEVICE
;	UCB1 = UCB ADDRESS OF SPOOLED DEVICE
;	CCB1 = CCB ADDRESS OF SPOOLED DEVICE
;	CHAN_INFO = CHANNEL INFO OF SPOOLED DEVICE
;
; OUTPUTS:
;
;	SET$L_STATUS = STATUS OF THE OPERATION
;--
NOSPOOL:
	.WORD	^M<R2,R3,R4,R5,R6>

	BSBW	OPER_PRIV		; CHECK THAT USER IS OPERATOR
	$CMKRNL_S W^SET$DEV_NOSPOOL,-	; SET THE DEVICE NOT SPOOLED
		  W^ARG_LIST
	BLBC	R0,10$			; IF CLEAR ERROR
	$QIOW_S CHAN=W^CHAN1,FUNC=#IO$_ACPCONTROL ; WAKE UP THE ACP
10$:	MOVL	R0,W^SET$L_STATUS	; SET STATUS
	RET				; RETURN

	.PAGE
	.SBTTL	SET [NO]ERROR LOGGING
;++
; ERROR_LOG/NOERROR_LOG - ENABLE OR DISABLE ERROR LOGGING ON A DEVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ACTION ROUTINE WILL ENABLE OR DISABLE ERROR LOGGING ON A DEVICE
;
;
; INPUTS:
;
;	CHAN1 = CHANNEL NUMBER OF DEVICE
;	UCB1 = UCB ADDRESS OF DEVICE
;	CHAN_INFO = CHANNEL INFO OF DEVICE
;
; OUTPUTS:
;
;	SET$L_STATUS = STATUS OF THE OPERATION
;--
	.ENABL	LSB

ERROR_LOG:
	.WORD	0
	MOVL	#1,W^FLAG		; SET FLAG TO ENABLE
	BRB	10$			;

NOERROR_LOG:
	.WORD	0
	CLRL	W^FLAG			; SET FLAG TO DISABLE

10$:	BSBW	OPER_PRIV		; CHECK THAT USER IS AN OPERATOR
	$CMKRNL_S W^SET$DEV_ERLG,-	; ENABLE/DISABLE ERROR LOGGING
		  W^ARG_LIST
	MOVL	R0,W^SET$L_STATUS	; SET STATUS

	RET

	.DSABL	LSB

	.PAGE
	.SBTTL	SET PROTECTION /DEVICE
;++
; PROTECTION - SET PROTECTION FOR A DEVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ACTION ROUTINE WILL SET THE DEVICE'S UCB PROTECTION
; FIELD, UCB$W_VPROT.
;
;
; INPUTS:
;
;	CHAN1 = CHANNEL NUMBER OF DEVICE
;	UCB1 = UCB ADDRESS OF DEVICE
;	CHAN_INFO = CHANNEL INFO OF DEVICE
;
; OUTPUTS:
;
;	SET$L_STATUS = STATUS OF THE OPERATION
;--
PROTECTION:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10> ; REGISTER SAVE MASK

	BSBW	OPER_PRIV		; CHECK THAT USER IS AN OPERATOR
;
; CHECK FOR VALID DEVICE TYPES
;
	BBC	#DEV$V_FOD,W^CHAN_INFO,PARSE_PROT ; IF SET FILE STRUCTURED
	MOVL	#CLI$_IVDEVTYPE,R0	; INVALID DEVICE TYPE
	BRW	PROT_EXIT		; EXIT
;
; PARSE PROTECTION CLASSES AND CODES
;
PARSE_PROT:
	CLRL	R9			; DEFAULT PROT = ALL ACESSES
	MOVAL	W^STRING_VAL,R10	; GET ADDR OF STRING VALUE DESC
10$:	TSTW	W^CLI$W_QDVALSIZ+SET$T_PRQUAL ; A VALUE LEFT?
	BNEQ	15$			; IF NEQ YES
	MOVL	R9,W^PROT		; SET PROTECTION VALUE
	BRB	GET_UIC			; GET THE OWNER UIC
15$:	CALLBAK	(R10),W^SET$T_PRQUAL	; GET NEXT VALUE
	LOCC	@CLI$A_RQADDR(R10),#4,W^PROT_CLASS ; LOCATE PROTECTION CLASS
	BEQL	50$			; IF EQL INVALID CLASS
	DECL	R0			; CALCULATE STARTING BIT NUMBER
	MULL3	#4,R0,R8		;
	INSV	#^XF,R8,#4,R9		; START WITH NO ACCESS
	BBC	#CLI$V_KEYVALU,CLI$B_RQSTAT(R10),10$ ; IF CLEAR NO VALUE
	CALLBAK	(R10),W^SET$T_PRQUAL	; GET PROTECTION VALUE
	MOVQ	CLI$Q_RQDESC(R10),R6	; GET VALUE DESCRIPTOR
20$:	LOCC	(R7)+,#4,W^PROT_ACCESS	; LOCATE PROTECTION ACCESS CODE
	BEQL	40$			; IF EQL INVALID CODE
	DECL	R0			; CALCULATE RELATIVE BIT NUMBER
	ADDL	R8,R0			; CALCULATE ACTUAL BIT NUMBER
	BBCC	R0,R9,30$		; ALLOW SPECIFIED ACCESS
30$:	SOBGTR	R6,20$			; ANY MORE TO SCAN?
	BRB	10$			;

40$:	MOVL	#CLI$_IVPROT,R0		; SET INVALID PROTECTION ERROR
	BRB	60$			; EXIT
50$:	MOVL	#CLI$_INVKEY,R0		; SET INVALID KEYWORD ERROR
60$:	BRW	PROT_EXIT		; EXIT

;
; GET THE OWNER UIC
;
GET_UIC:
	TSTW	W^CLI$W_QDVALSIZ+OWN_QUAL ; OWNER SPECIFIED?
	BNEQ	10$			; BR IF YES
	$GETJPI_S ITMLST=W^GETJPI_UIC	; USE PROCESS'S UIC AS DEFAULT
	BRB	SET_PROT		; SET THE PROTECTION
10$:
	CALLBAK W^STRING_VAL,W^OWN_QUAL	; GET THE UIC STRING
	MOVL	W^CLI$A_RQADDR+STRING_VAL,R6 ; SET ADDR OF UIC STRING
	BSBW	CHR$TSTCHR		; TST 1ST CHARACTER
	CMPB	#CHR$K_LBRAKT,R0	; IS IT A LEFT BRACKET?
	BNEQ	20$			; BR IF NOT
	BSBW	CHR$NXTOKEN		; GET GROUP NUMBER
	MOVQ	R3,R2			; SET DESCRIPTOR TO IT
	BSBW	LIB$CVTCLIOTB		; CONVERT TO BINARY
	BLBC	R0,20$			; BR IF ERROR
	MOVW	R1,W^UIC+2		; SET GROUP NUMBER
	BSBW	CHR$TSTCHR		; TEST NEXT CHARACTER
	CMPB	#CHR$K_COMMA,R0		; IS IT A COMMA?
	BNEQ	20$			; BR IF NOT
	BSBW	CHR$NXTOKEN		; GET MEMBER NUMBER
	MOVQ	R3,R2			; SET DESCRIPTOR TO IT
	BSBW	LIB$CVTCLIOTB		; CONVERT TO BINARY
	MOVW	R1,W^UIC		; SET MEMBER NUMBER
	BLBS	R0,SET_PROT		; BR IF SUCCESS
20$:	MOVL	#CLI$_INVUIC,R0		; SET INVALID UIC ERROR
	BRB	PROT_EXIT
;
; SET THE DEVICE'S PROTECTION
;
SET_PROT:
	$CMKRNL_S W^SET$DEV_PROT,-	; SET DEVICE'S PROTECTION
		  W^ARG_LIST		;
PROT_EXIT:
	MOVL	R0,W^SET$L_STATUS	; SET STATUS
	RET	

	.PAGE
	.SBTTL	SET [NO]DUAL_PORT 
;++ 
; DUAL_PORT - SET DEVICE [NO]DUAL_PORT 
; 
; FUNCTIONAL DESCRIPTION: 
; 
; THIS ACTION ROUTINE WILL SET DEV$V_DUA IN THE DEVICE (DISK) 
; CHARACTERISTICS LONGWORD. 
; 
; 1) CHECK DEVICE FOR VALID DEVICE CLASS OR TYPE; 
; 2) SET SPECIFIED DEVICE'S DUAL_PORT BIT (DEV$V_DUA IN UCB$L_DEVCHAR); 
; 
; 
; INPUTS: 
; 
;	CHAN1 = CHANNEL NUMBER OF SPECIFIED DEVICE 
;	UCB1 = UCB ADDRESS OF SPECIFIED DEVICE 
;	CHAN_INFO = CHANNEL INFO OF SPECIFIED DEVICE 
; 
; OUTPUTS: 
; 
;	SET$L_STATUS = STATUS OF THE OPERATION 
;-- 
	.ENABL	LSB 
 
DUAL_PORT: 
	.WORD	^M<R2> 
	MOVL	#1,W^FLAG		; SET FLAG TO ENABLE 
	BRB	10$			;
 
NODUAL_PORT: 
	.WORD	^M<R2> 
	CLRL	W^FLAG			; SET FLAG TO DISABLE 

10$:	BSBW	OPER_PRIV		; CHECK THAT USER HAS OPERATOR PRIV

;
; CHECK SPECIFIED DEVICE CLASS 
;
 	CMPB	W^CLASS,#DC$_DISK	; DEVICE A DISK? 
	BEQLU	20$			; IF EQL YES
	MOVZWL	#SS$_IVDEVNAM,R0	; SET INVALID DEVICE ERROR 
	BRW	30$			; EXIT
;
; GO SET THE BIT
;
20$:
	$CMKRNL_S W^SET$DEV_DUAL,-	; SET THE DEVICE DUAL_PORT
		  W^ARG_LIST 
30$:
	MOVL	R0,W^SET$L_STATUS	; SET STATUS 
	RET				; RETURN 
 
	.DSABL	LSB 

	.PAGE
	.SBTTL	CHECK FOR OPERATOR PRIVILEGE
;++
; OPER_PRIV - CHECK THAT PROCESS HAS OPERATOR PRIVILEGE
;
; FUNCTIONAL DESCRIPTION:
;
; TEST CTL$GQ_PROCPRIV FOR PRV$V_OPER.  IF SET JUST RETURN (RSB), IF
; NOT SET, SET SET$L_STATUS TO SS$_NOPRIV AND RETURN (RET).
;
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
; 	IF PROCESS HAS OPER PRIVILEGE - NONE
;		ELSE - SET$L_STATUS = SS$_NOOPER
;
;--
OPER_PRIV:
	BBC	#PRV$V_OPER,CTL$GQ_PROCPRIV,10$ ; IF CLEAR NO PRIVILEGE
	RSB				; ELSE - JUST RETURN
10$:	MOVZWL	#SS$_NOOPER,W^SET$L_STATUS ; SET NO PRIVILEGE ERROR
	RET				; EXIT ACTION ROUTINE


	.END
