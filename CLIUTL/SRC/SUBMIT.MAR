	.TITLE	SUBMIT - CLI SUBMIT COMMAND PROCESSOR
	.IDENT	'V03-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET CLI UTILITIES
;
; ABSTRACT:	USER INTERFACE PROGRAM
;
; ENVIRONMENT:	NATIVE MODE USER CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 8-JUN-1977
;
; MODIFIED BY:
;
;	V03-002	MLJ0086		Martin L. Jack,	4-Apr-1982  0:46
;		Disallow /JOB=0, /COPIES=0.
;
;	V03-001	MLJ0084		Martin L. Jack,	27-Mar-1982  20:12
;		Correct SUBMIT/NAME/NOLOG.
;
;	V014	TMH0014		Tim Halvorsen		04-Feb-1982
;		Remove reference to CLI$K_ symbols at assembly time.
;		Change reference to FMG$FILE_SCAN to LIB$FILE_SCAN.
;
;	V02-013	MLJ0070		Martin L. Jack,	17-Jan-1982  2:46
;		Incorporate standard queue name translation.  Remove unused
;		variables, rework to avoid OWN storage as convenient.  Correct
;		test on device type to allow only disk and tape devices.
;		Clean up semantics of /LOG and /NAME by use of new routine
;		LOG_FILE_NAME.
;
;	V02-012	MLJ41218	Martin L. Jack,	15-Jan-1982  15:19
;		Make the representation of a null parameter a one byte hex FF.
;		A corresponding change in DCL turns this back into a null
;		string.
;
;	V02-011	GWF0119		Gary Fowler	29-Oct-1981
;		Add action routine for WS extent.
;
;	V02-010	GWF0085		Gary Fowler	20-Jul-1981
;		Change maximum length of job name to 9 characters.
;
;	V02-009	GWF0072		Gary Fowler	15-Jul-1981
;		Add checks for error codes returned if invalid queue name for
;		log file specified.
;
;	V02-008	GWF0046		Gary Fowler	13-May-1981
;		Modify to use EOF block in getting file size
;
;	V02-007	GWF0040		Gary Fowler	08-May-1981
;		Add file size to message
;
;	V02-006	GWF0032		Gary Fowler	21-Apr-1981
;		add routines for /NOTIFY
;
;	V02-005	GWF0024		Gary Fowler	08-Apr-1981
;		Add routines for /[NO]LOG_FILE,/[NO]PRINTER,/[NO]KEEP
;
;	V02-004	LMK0002		Len Kawell	27-Jan-1981
;		Add PRINT/REMOTE
;
;	V02-003	LMK0001		Len Kawell	30-Dec-1979
;		Add action routines for /CHARACTERISTICS.
;
;	V02-002	GWF0001		Gary Fowler	10-Oct-1979
;		add action routines for WS default, WS quota, and CPU
;		time limit
;
;	V02-001	TMH0001		Tim Halvorsen	28-Feb-1979
;		Add extended wildcard processing
;--

	.SBTTL	DECLARATIONS
;
; MACROS:
;
; MACRO TO ADD AN OTPION TO THE SYMBIONT MANAGER MESSAGE
;
	.MACRO	SETOPT	VAL,TYPE=B
	.WORD	SMT_MASK
	BSB'TYPE	SMT_SETOPT
	.BYTE	SMO$K_'VAL
	.ENDM
;
; MACRO TO ADD AN OTPION TO THE SYMBIONT MANAGER MESSAGE
;	WHEN THE OPTION MUST BE EXPLICITLY STATED IN THE COMMAND.
;
	.MACRO	SETEXPOPT	VAL,TYPE=B
	.WORD	SMT_MASK
	BSB'TYPE	SMT_SETEXPOPT
	.BYTE	SMO$K_'VAL
	.ENDM
;
; MACRO TO SET OPTION WITH BYTE VALUE
;
	.MACRO	SETBYTOPT VAL,TYPE=B
	.WORD	SMT_MASK
	BSB'TYPE 	SMT_SETBYTOPT
	.BYTE	SMO$K_'VAL
	.ENDM
 
;
; MACRO LIBRARY CALLS
;
	$CLIDEF				; CLI DEFINITIONS
	$CLIMSGDEF
	$DEVDEF				; Device characteristics
	$FABDEF				; FAB definitions
	$IODEF				; I/O function codes
	$JBCMSGDEF
	$NAMDEF				; NAM block definitions
	$RABDEF				; RAB definitions
	$RMSDEF				; RMS DEFINITIONS
	$STSDEF				; STATUS DEFINITIONS
	$SMRDEF				; SYMBIONT MANAGER DEFINTIONS
	$SHRDEF				; SHARE MESSAGE DEFINITIONS
	$XABFHCDEF			; XAB definitions

	SMTCTXBLK	ALLOCATE=NO	; DEFINE OFFSETS INTO CONTEXT BLOCK
	SMT_MASK = ^M<R2,R3,R4,R5>	; COMMON ENTRY MASK
 
;
; DEFINE LOCAL FLAG BITS
;
	_VIELD	SMT,1,<-		; START AT BIT 1
		<JOBOPN,,M>,-		; JOB IS OPEN
		<FILSNT,,M>,-		; A FILE HAS BEEN SUBMITTED
		<CMDERR,,M>,-		; ERROR PROCESSING COMMAND
		<NOLOG,,M>,-		; Explicit /NOLOG
		>
;
; OWN STORAGE:
;
	PURE_SECTION
 
SUBMIT:	.ASCIC	\SUBMIT\		; FACILITY NAME FOR SUBMIT
PRINT:	.ASCIC	\PRINT\			; LIKEWISE FOR PRINT
DEFQUE:	.ASCII	\SYS$BATCH\		; DEFAULT QUEUE NAME FOR BATCH
DEFQLN=	.-DEFQUE
DEFDEV:	.ASCII	\SYS$PRINT\		; DEFAULT QUEUE NAME FOR PRINTING
DEFDLN=	.-DEFDEV
SMT_DEFDESC:
	.ASCID	/SYS$LOGIN/

	.SBTTL	SUBMIT - SUBMIT FILE UTILITY
;++
; FUNCTIONAL DESCRIPTION:
; 
;	SUBMIT A FILE UTILITY COMMAND IMAGE
; 
; CALLING SEQUENCE
;
;	CALLED FROM COMMAND LANGUAGE INTERPRETER
;--

	.ENTRY	SUBMIT_FILE,0

	MOVAB	W^SMT$CTXBLK,R11	; SET CONTEX BLOCK
	MOVZBL	#1,SMT_L_STATUS(R11)	; ASSUME GOOD EXIT STATUS
	MOVAB	W^SMT_MESSAGE,R7	; SET ADDRESS OF MESSAGE DATA AREA
;
;	CREATE MAILBOX FOR RESPONSES FROM SYMBIONT MANAGER
;
	$CREMBX_S	-		; CREATE A MAILBOX
		PROMSK	= #0,-		; NO PROTECTION
		MAXMSG	= #32,-		; BIGEST MESSAGE EVER
		BUFQUO	= #64,-		; ENOUGH BUFFER FOR 2 MESSAGES
		PRMFLG	= #0,-		; NON PERMANENT
		CHAN=SMT_W_RSPCHAN(R11)	; CHANNEL ASSIGNED RETURNED HERE
;
;	CHANGE DEFAULTS IF COMMAND WAS PRINT INSTEAD OF SUBMIT
;
	MOVAB	W^SMT_INITPRS,R0	; REQUEST DESCRIPTOR
	BSBW	CALBAK			; DO CALLBACK
	MOVAB	W^SMT_GETCMD,R0		; SET REQUEST DESCRIPTOR FOR GET COMMAND
	BSBW	CALBAK			; AND REQUEST COMMAND DATA FOR CLI
	MOVL	#DEFQLN,SMT_Q_QUEDES(R11) ; Set up default batch queue
	MOVAB	DEFQUE,SMT_Q_QUEDES+4(R11)
	CMPB	#CLI$K_VERB_SUBM,W^SMT_GETCMD+CLI$B_RQSTAT ; WAS COMMAND SUBMIT?
	BEQL	10$			; BR IF DOING SUBMIT
	SETBIT	SMT_V_PRTCMD,SMT_B_BITMAP(R11) ; SET BIT FOR CLI TO TEST
	MOVL	#DEFDLN,SMT_Q_QUEDES(R11) ; Set up default print queue
	MOVAB	DEFDEV,SMT_Q_QUEDES+4(R11)
	MOVL	#^A/.LIS/,W^SMT_DEFNAM	; SET DEFAULT NAME STRING
;
;	INITIALIZE SYBMIONT MANAGER REQUEST MESSAGE
;
10$:	MOVW	#SMR$K_CREJOB,(R7)	; INSERT REQUEST JOB CREATION
	MOVAB	18(R7),SMT_L_MSGPTR(R11); SET POINTER TO FIRST FREE BYTE
;
;	PARSE COMMAND QUALIFIERS
;
	MOVAB	W^SMT_GETCMDQUAL,R0	; NOW GET COMMAND LEVEL QUALIFIERS
	BSBW	CALBAK			; REQUEST CLI TO PARSE THAT
	BLBC	SMT_L_STATUS(R11),30$	; BR IF PARSE ERROR
;
;	CREATE JOB QUEUE RECORD FOR QUEUE SPECIFIED IN COMMAND
;	(DEFAULTS TO SYS$PRINT OR SYS$BATCH).  THE QUEUE NAME IS
;	TRANSLATED BEFORE BEING SENT TO THE SYMBIONT MANAGER.
;
	BBS	#SMT_V_REMOTE,SMT_B_BITMAP(R11),50$ ; BR IF NON-LOCAL OPERATION
;
;	Compute log file name now that /NAME and /LOG qualifiers have been
;	processed.
;
	BBS	#SMT_V_NOLOG,SMT_W_FLAGS(R11),11$ ; Br if explicit /NOLOG
	PUSHAL	SMT_L_MSGPTR(R11)	; Point to message buffer pointer
	PUSHAQ	SMT_Q_NAMDES(R11)	; Point to /NAME qualifier descriptor
	PUSHAQ	SMT_Q_LOGDES(R11)	; Point to /LOG qualifier descriptor
	CALLS	#3,G^LOG_FILE_NAME	; Call routine to compute log filename
	BLBS	R0,11$			; Br if successful
	PUSHL	R0			; Error status
	PUSHL	#0			; No FAO argument
	PUSHL	#CLI$_INVLOGFIL		; Message
	PUSHL	#3			; Parameter list length
	BRW	SHOW_MSG		; Go issue message
11$:	PUSHAB	2(R7)			; Point to output area
	PUSHAQ	SMT_Q_QUEDES(R11)	; Point to queue name
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	BLBS	R0,15$			; Br if successful
	PUSHAQ	SMT_Q_QUEDES(R11)	; Push queue name
	PUSHL	#1			; Push FAO count
	PUSHL	#SHR$_BADQNAME!<3@16>	; Push message ID
	PUSHL	#3			; Push parameter count
	BRW	SHOW_MSG		; Issue the error
15$:	MOVC3	#16,2(R7),SMT_T_DEVNAM(R11) ; SAVE ACTUAL NAME
	BSBW	SENDMSG			; SEND THE MESSAGE
	BLBS	R0,40$			; BR IF CREATE JOB WORKED
20$:	BSBW	ERREXT			; PRINT THE ERROR AND EXIT
	.LONG	CLI$_CREQUEJOB		; ERROR CREATING JOB ON QUEUE
30$:	BRW	ERROUT			; TAKE ERROR EXIT

40$:	MOVW	R1,SMT_W_JOBNUM(R11)	; SAVE JOB NUMBER
	SETBIT	SMT_V_JOBOPN,SMT_W_FLAGS(R11) ; INDICATE JOB OPEN
;
;	SETUP SYMBIONT MESSAGE FOR ENTER FILE NAME FUNCTION
;
50$:	MOVAB	W^SMT_INPFAB,R9		; NOW INPUT STRUCTURES
	MOVAB	W^SMT_INPNAM,R10	; FINALLY NAME BLOCK
	MOVW	#SMR$K_ADDFIL,(R7)	; SET ENTER FILE FUNCTION
;
;	PROCESS ALL FILES SPECIFIED IN THE COMMAND LINE
;
60$:	MOVAB	2+16+6+6+20(R7),-	; SET ADDRESS OF FIRST BYTE IN OPTION
		SMT_L_MSGPTR(R11)	; AREA IN THE MESSAGE BUFFER
	MOVAB	W^SMT_INPDESC,R0	; INPUT FILE REQUEST DESCRIPTOR
	MOVL	R0,R5			; SAVE A COPY
	BSBW	CALBAK			; REQUEST RESULT PARSE
	BBS	#SMT_V_CMDERR,SMT_W_FLAGS(R11),70$ ; BR IF COMMAND ERROR
	CVTWB	CLI$W_RQSIZE(R5),-	; SET NAME SIZE FIELD RETURNED BY CLI 
		FAB$B_FNS(R9)		; AS INPUT NAME SIZE
	MOVL	CLI$A_RQADDR(R5),-	; LIKEWISE FOR THE ADDRESS OF
		FAB$L_FNA(R9)		; INPUT FILE NAME ENTERED
	CLRL	-(SP)			; NO DIRECTORY ACTION ROUTINE
	PUSHAB	W^INP_OPN_ERR		; ADDRESS OF ERROR ROUTINE
	PUSHAB	B^DO_FILE		; ADDRESS OF SUCCESS ROUTINE
	PUSHL	R9			; ADDRESS OF FAB BLOCK
	CALLS	#4,G^LIB$FILE_SCAN	; SEARCH ALL WILDCARD FILES
	BBS	#CLI$V_CONCATINP,-	; BRANCH IF THE MORE INPUT DATA FLAG -
		W^CLI$B_RQSTAT+SMT_INPDESC,60$ ; INDICATES MORE COMMAND INPUT
	MOVAB	W^SMT_PARSDON,R0	; REQUEST DESCRIPTOR
	BSBW	CALBAK			; REQUEST PARSE TERMINATION
	BRW	NOREXT			; TAKE NORMAL EXIT

70$:	BRW	ERROUT			; TAKE ERROR EXIT

	.SBTTL	DO_FILE, PROCESS A SINGLE FILE SPECIFICATION

;
;	PROCESS A SINGLE FILE SPECIFICATION
;

DO_FILE:
	.WORD	^M<R2,R3,R4,R5,R7,R9,R10,R11>

	MOVAB	W^SMT$CTXBLK,R11	; SET ADDRESS OF CONTEXT BLOCK
	MOVAB	W^SMT_MESSAGE,R7	; ADDRESS OF MESSAGE DATA AREA
	MOVL	4(AP),R9		; ADDRESS OF FAB BLOCK
	MOVL	FAB$L_NAM(R9),R10	; ADDRESS OF NAM BLOCK
	$OPEN	(R9),ERR=W^INP_OPN_ERR	; OPEN THE COMMAND FILE
	BLBC	R0,10$			; BRANCH IF ERROR
	BBC	S^#SMT_V_REMOTE,SMT_B_BITMAP(R11),30$ ; BR IF NOT REMOTE
	BBC	#NAM$V_NODE,NAM$L_FNB(R10),40$ ; BR IF NODE MISSING
;
;	SUBMIT THE COMMAND FILE VIA RMS
;
	BBS	S^#SMT_V_PRTCMD,SMT_B_BITMAP(R11),5$ ; BR IF PRINT COMMAND
	SETBIT	S^#FAB$V_SCF,FAB$L_FOP(R9) ; TELL RMS TO SUBMIT FILE
	BRB	7$			;
5$:	SETBIT	S^#FAB$V_SPL,FAB$L_FOP(R9) ; TELL RMS TO PRINT FILE
7$:	$CLOSE	(R9)			; GET SUBMIT ERROR IF ANY
	BLBS	R0,10$			; BR IF NO  ERROR
	BRW	70$			; TAKE ERROR OUT
10$:	RET
;
;	INVALID FILE SPECIFICATION ERROR
;
30$:	BBC	#NAM$V_NODE,NAM$L_FNB(R10),50$ ; BR IF NODE NOT PRESENT
40$:	PUSHL	#CLI$_INVFILSPE		; SET NAME ERROR
	PUSHAB	W^SMT_INPDESC		; ADDRESS OF DESCRIPTOR FOR NAME
	CALLS	#2,SMT$CMDERR		; REPORT THE ERROR
	BRW	ERROUT			; TAKE ERROR EXIT
;
;	STORE THE DEVICE AND FILE NAME INTO FILE PRINT QUEUE RECORD
;
50$:	ASSUME	NAM$T_DVI+16 EQ NAM$W_FID ; FILE ID ADJACENT TO DEVICE ID?
	ASSUME	NAM$W_FID+6  EQ NAM$W_DID ; DIRECTORY ID ADJACENT TO FILE ID?
	MOVC3	#<16+6+6>,NAM$T_DVI(R10),2(R7); COPY DEVICE, FILE AND DIR ID'S
	MOVZBL	NAM$B_RSL(R10),R2	; Get length of resultant string
	ADDL2	NAM$L_RSA(R10),R2	; Point beyond resultant string
	SUBL2	NAM$L_NAME(R10),R2	; Compute length of 'name.typ;ver'
	CMPL	R2,#19			; Truncate to 19 bytes if necessary
	BLEQU	60$			; Br if within range
	MOVL	#19,R2			; Shorten
60$:	MOVB	R2,(R3)+		; STORE SIZE OF FILENAME IN MESSAGE
	MOVC5	R2,@NAM$L_NAME(R10),-	; STORE FILE NAME IN PACKET
		#0,#19,(R3)
;
;	SUBMIT THE FILE TO THE PRINT QUEUE
;
	MOVL	#CLI$_IVDEVTYPE,R0	; ASSUME CAN'T QUEUE THE FILE
	BBS	#NAM$V_PPF,NAM$L_FNB(R10),80$ ; BR IF PROCESS PERMANENT FILE
	BBC	#DEV$V_FOD,FAB$L_DEV(R9),80$ ; CHECK FOR BAD DEVICE
	MOVL	SMT_L_MSGPTR(R11),R3	; GET POINTER INTO MESSAGE
	MOVB	#SMO$K_FILESIZ,(R3)+	; SET OPTION BYTE INTO MESSAGE
	MOVAL	SMT_HEADIN,R0		; GET ADDR. OF HEADER BLOCK INFO
	MOVL	XAB$L_EBK(R0),R1	; GET EOF BLOCK NO.
	BEQL	61$			; IF ZERO THEN DON'T DECREMENT
	TSTW	XAB$W_FFB(R0)		; TEST LAST BYTE IN BLOCK
	BNEQ	61$			; IF NOT ZERO THEN DON'T DECREMENT
	DECL	R1			; DECREMENT EOF BLOCK NUMBER
61$:	MOVL	R1,(R3)+		; SET FILE SIZE IN MESSAGE
	MOVL	R3,SMT_L_MSGPTR(R11)	; SET NEW MESSAGE POINTER
	BSBW	SENDMSG			; SEND THE MESSAGE
	BLBC	R0,80$			; BR IF SEND FAILED
	$CLOSE	(R9)			; CLOSE THE INPUT FILE
	RET

70$:	BSBB	ERREXT			; PRINT ERROR
	.LONG	CLI$_CREQUEJOB		; ERROR CREATING JOB ON QUEUE
	BRB	ERROUT			; TAKE ERROR EXIT

80$:	BSBB	ERREXT			; PRINT ERROR AND EXIT
	.LONG	CLI$_SUBMITERR		; ERROR SUBMITTING FILE TO QUEUE
	BRB	ERROUT			; EXIT

	.SBTTL	PRINT ERROR MESSAGE AND EXIT
;
;	PRINT ERROR MESSAGE AND EXIT IMMEDIATELY
;
ERREXT:	BICL3	#STS$M_SEVERITY,R0,R1	; MASK OUT SEVERITY LEVEL
	MOVL	SMT_L_PRIPTR(R11),R3	; Pointer to ASCIC /PRINT value
	CMPL	R1,#JBC$_NODESTQUE	; NO DESTINATION QUEUE?
	BEQL	10$			; BR IF YES
	CMPL	R1,#JBC$_ILLDESQUE	; ERROR IS ILLEGAL DESTINATION QUEUE?
	BEQL	10$			; BR IF YES
	MOVAB	SMT_T_DEVNAM(R11),R3	; START OF COUNTED STRING
10$:	MOVZBL	(R3)+,R2		; R2,R3 ARE STRING DESCRIPTOR FOR QUEUE
	MOVL	@(SP)+,R1		; GET ERROR CODE
	CALLG	(AP),W^EXEERR		; SHOW EXECUTION ERROR
	BBS	#SMT_V_PRTCMD,SMT_B_BITMAP(R11),NOREXT ; ONLY DELETE BATCH JOBS ON ERROR
ERROUT:	BBS	#SMT_V_REMOTE,SMT_B_BITMAP(R11),TERMIN ; ALL DONE IF REMOTE OPR
	MOVAB	(R7),R3			; SET START OF MESSAGE BUFFER
	MOVW	#SMR$K_RMVJOB,(R3)+	; REQUEST IS TO REMOVE THE JOB
	MOVC	#16,SMT_T_DEVNAM(R11),(R3) ; COPY QUEUE NAME INTO MESSAGE
	MOVW	SMT_W_JOBNUM(R11),(R3)+	; SET THE JOB THAT WAS JUST CREATED
	MOVL	R3,SMT_L_MSGPTR(R11)	; NEXT BYTE IN MESSAGE
	BSBB	SENDMSG			; SEND THAT TO SYMBIONT MANAGER
	BRB	TERMIN			; TERMINATE THIS EXECUTION
NOREXT:	MOVW	#SMR$K_CLSJOB,(R7)	; ASSUME JOB CLOSE OK
	MOVAB	2(R7),SMT_L_MSGPTR(R11)	; SET SIZE OF MESSAGE TO 2 BYTES
	BSBB	SENDMSG			; SEND THE MESSAGE
	BLBC	R0,TERMIN		; IF THAT FAILED - DON'T EVER SHOW ID
	BBS	#SMT_V_REMOTE,SMT_B_BITMAP(R11),TERMIN ; NO ID IF REMOTE SUBMIT
	BBC	#SMT_V_IDENT,SMT_B_BITMAP(R11),TERMIN ; BR IF NO ID REQUESTED
	CALLG	(AP),B^SHOWID		; GENERATE CALL FRAME FOR MESSAGE OUT
TERMIN:	$DASSGN_S SMT_W_RSPCHAN(R11)	; DEASSIGN RESPONCE MAILBOX CHANNEL
	$EXIT_S  SMT_L_STATUS(R11)	; EXIT WITH FINAL STATUS

	.SBTTL	SHOWID, DISPLAY JOB CREATED MESSAGE
;---
;
;	Show the job created message and the ID of the job.
;
;---

SHOWID:	.WORD	0			; CALL ENTRY
	PUSHAB	SMT_T_DEVNAM(R11)	; ADDRESS OF COUNTED STRING
	PUSHL	SMT_W_JOBNUM(R11)	; AND JOB NUMBER
	PUSHL	#<2!<1@16>>		; NUMBER OF FAO ARGUMENTS
	PUSHL	#CLI$_QUEJOBCRE		; INFORMATIONAL MESSAGE CODE
	PUSHL	#4			; TOTAL LENGTH OF BLOCK
	BRW	SHOW_MSG		; PRINT THE MESSAGE

	.SBTTL	SENDMSG, SEND MESSAGE TO SYMBIONT MANAGER
;
; SEND MESSAGE TO THE SYMBIONT MANAGER
;
SENDMSG:PUSHAB	(R7)			; PUSH START OF BUFFER
	SUBL3	R7,SMT_L_MSGPTR(R11),-(SP) ; FIND ACTUAL LENGTH
	MOVZWL	SMT_W_RSPCHAN(R11),-(SP) ; PUSH CHANNEL NUMBER
	PUSHAQ	4(SP)			; ADDRESS OF MESSAGE DESCRIPTOR
	CALLS	#2,@#SYS$SNDSMB		; SEND MESSAGE
	MOVAB	(SP),R0			; Point to quadword buffer
	$QIOW_S	#0,SMT_W_RSPCHAN(R11),#IO$_READVBLK,- ; READ RESPONCE
		SMT_Q_IOSB(R11),,,(R0),#8
	MOVZWL	SMT_Q_IOSB(R11),R0	; GET STATUS
	BLBC	R0,10$			; BR IF ERROR FROM THE SYSTEM
	MOVZWL	2(SP),R1		; Get job ID in R1
	MOVL	4(SP),R0		; Get status in R0
10$:	ADDL2	#8,SP			; Pop quadword buffer
	RSB				; RETURN TO CALLER, STATUS IN R0
					; Job ID in R1

	.SBTTL	SUBROUTINE TO CALL BACK CLI
;
; LOCAL SUBROUTINE TO ISSUE CALL BACK TO CLI
;
; INPUT:	R0 IS THE ADDRESS OF THE REQUEST DESCRIPTOR
; OUTPUT:	THE CALL BACK IS ISSUED, AND CONTROL IS RETURN TO CALLER
;
	.ENABL	LSB
 
CALBAK:	PUSHAB	SMT_B_BITMAP(R11)	; LAST ARGUMENT IN CALL BACK
	BRB	10$			; JOIN COMMON CODE
CALBAK1:				; ALTERNATE ENTRY-R2 HAS LAST ARGUMENT
	PUSHAB	(R2)			; SET THIRD ARGUMENT IN ARGUMENT LIST
10$:	PUSHAB	W^SMT_CLIWORK		; WORK AREA IS ALWAYS SECOND
	PUSHAB	(R0)			; REQUEST DESCRIPTOR IS ALWAYS FIRST
	CALLS	#3,@CLI$A_UTILSERV(AP)	; GO TO UTILITY SERVICE ROUTINE
	RSB
 
	.DSABL	LSB			;

	.SBTTL	QUALIFIER ACTION ROUTINES
;
; QUALIFER ACTION ROUTINES
;
; QUEUE OR DEVICE NAME EXPLICITLY STATED
;
SMT_DEVNAM::				; DEVICE NAME SPECIFIED
	.WORD	SMT_MASK		; ENTRY MASK FOR REGISTER SAVE
	MOVL	4(AP),R0		; GET REQUEST DESCRIPTOR
	MOVQ	CLI$Q_QDVALDESC(R0),-
		SMT_Q_QUEDES(R11)	; VALUE DESCRIPTOR
	RET
 
SMT_JOBNAME::				; USER HAS SUPPLIED EXPLICIT JOB NAME
	.WORD	SMT_MASK		; ENTRY MASK FOR REGISTER SAVE
	MOVL	4(AP),R0		; GET REQUEST DESCRIPTOR
	MOVQ	CLI$Q_QDVALDESC(R0),R0	; VALUES DESCRIPTOR
	MOVL	SMT_L_MSGPTR(R11),R3	; SET MESSAGE POINTER TO R3
	CMPL	R0,#9			; NAME TOO LONG?
	BLEQU	10$			; BR IF NO
	MOVZBL	#9,R0			; SET MAXIMUM LENGTH
10$:	MOVQ	R0,SMT_Q_NAMDES(R11)	; Save /NAME qualifier value
	MOVB	#SMO$K_JOBNAME,(R3)+	; SET OPTION ID BYTE
	MOVB	R0,(R3)+		; NOW THE LENGTH OF THE NAME
	MOVC	R0,(R1),(R3)		; COPY THE NAME INTO THE MESSAGE
	BRW	SETPT			; RESET POINTER AND EXIT

SMT_SPOOL::
	.WORD	SMT_MASK
	MOVL	SMT_L_MSGPTR(R11),R3	; GET POINTER INTO MESSAGE
	MOVB	#SMO$K_LOGQNAM,(R3)+	; MOVE OPTION BYTE TO MESSAGE
	MOVL	4(AP),R4		; GET REQUEST DESCRIPTOR
	PUSHAB	(R3)			; Point to output area
	PUSHAQ	CLI$Q_QDVALDESC(R4)	; Point to input queue name
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	BLBS	R0,10$			; Br if successful
	PUSHAQ	CLI$Q_QDVALDESC(R4)	; Push queue name
	PUSHL	#1			; Push FAO count
	PUSHL	#SHR$_BADQNAME!<3@16>	; Push message ID
	PUSHL	#3			; Push parameter count
	BRW	SHOW_MSG		; Issue the error
10$:	MOVAB	(R3),SMT_L_PRIPTR(R11)	; Save pointer to translated queue name
	MOVZBL	(R3)+,R0		; Get length of translated name
	ADDL3	R0,R3,SMT_L_MSGPTR(R11)	; SAVE POINTER INTO MESSAGE
	RET

SMT_LOGF::				; USER SUPPLIED A LOG FILE NAME
	.WORD	SMT_MASK		; ENTRY MASK FOR REGISTER SAVE
	MOVL	4(AP),R0		; GET REQUEST DESCRIPTOR
	MOVQ	CLI$Q_QDVALDESC(R0),-
		SMT_Q_LOGDES(R11)	; Save /LOG qualifier value
	RET
 
;
; THE FOLLOWING OPTIONS REQUIRE ONLY A BYTE OF OPTION TYPE TO BE
; INSERTED INTO THE SYMBIONT MANAGER MESSAGE.
;
SMT_DOUBLE::				; SPACING REQUESTED
	SETOPT		DOUBLE		;
 
SMT_HOLD::				; HOLD THE FILE FOR SUBMITING
	SETOPT		HOLD		; SET HOLD FILE OPTION
 
SMT_DELETE::				; DELETE FILE AFTER SUBMITING
	SETOPT		DELETE		; SET OPTION
 
SMT_BURST::				; BURST PAGE REQUESTED
	SETEXPOPT	BRSTPAG		; SET OPTION INTO MESSAGE
 
SMT_NOBURST::				; NO BURST PAGE REQUESTED
	SETEXPOPT	NOBRSTPAG	;
 
SMT_NOFLAG::				; NO FLAG PAGE
	SETEXPOPT	NOFLAGPAG	;
 
SMT_FLAGPAG::				; SUBMIT A FLAG PAGE
	SETEXPOPT	FLAGPAG
 
SMT_LOWER::				; UPPER/LOWER CASE SUBMITER ONLY
	SETOPT		LOWER
 
SMT_NOFEED::				; INHIBIT FORM FEED AT BOTTOM OF PAGE
	SETOPT		NOFEED		;
 
SMT_PRTHDR::				; SUBMIT HEADER AT TOP OF EACH FORM
	SETOPT		PAGHDR		; SUBMIT PAGE HEADERS
 
SMT_KEEP::				; DON'T DELETE LOG FILE AFTER PRINTING
	SETOPT		KEEPLOG		; OPTION BYTE

SMT_NOSPOOL::				; DON'T QUEUE PRINT REQUEST FOR .LOG
	SETEXPOPT	NOSPOOL		; OPTION BYTE

SMT_NOLOGF::				; SPECIFY NO LOG FILE
	.WORD	SMT_MASK
	BISB2	#SMT_M_NOLOG,SMT_W_FLAGS(R11) ; Remember explicit /NOLOG
	BSBB	SMT_SETEXPOPT
	.BYTE	SMO$K_NOLOG

SMT_NOTIFY::				; NOTIFY USER OF JOB COMPLETION
	SETOPT		NOTIFY		; OPTION BYTE
;
; SETEXPOPT - SET EXPLICIT OPTION
;
; THIS ROUTINE ENTERS THE OPTION IN THE MESSAGE ONLY IF USER
; EXPLICITLY INVOKED THE ASSOCIATED QUALIFIER.
;
 
SMT_SETEXPOPT:				; SET EXPLICIT OPTION
	MOVL	4(AP),R0		; GET QUALIFIER
	BBS	#CLI$V_QUALEXP,-	; WAS QUALIFIER FOUND OR DEFAULTED?
		CLI$B_QDSTAT(R0),SMT_SETOPT ; SET THE OPTION IF YES
	RET				; ELSE, IGNORE DEFAULTED VALUES
;
; SETOPT - SET OPTION
;
; COMMON ROUTINE TO SET A BYTE OPTION FLAG INTO THE MESSAGE
;
 
SMT_SETOPT:				; SET OPTION IN MESSAGE
	MOVL	SMT_L_MSGPTR(R11),R3	; SET POINTER INTO MESSAGE
	MOVB	@(SP)+,(R3)+		; STORE A BYTE
	BRW	SETPT			; RESET THE POINTER
;
; FORMS TYPE OPTION SPECIFIED, CONVERT TO A BINARY BYTE AND INSERT
; IN THE MESSAGE
;
 
SMT_FORMS::				; SET FORMS TYPE
	.WORD	SMT_MASK		; ENTRY MASK
	MOVL	4(AP),R0		; GET QUALIFIER DESCRIPTOR
	MOVQ	CLI$Q_QDVALDESC(R0),-	; SAVE FORM STRING DESC FOR ERROR MSG
		SMT_Q_IOSB(R11)		;
	PUSHAL	CLI$Q_QDVALDESC(R0)	; PUSH ADDRESS OF FORM STRING
	CALLS	#1,LIB$CNVCLIFORMS	; CHANGE FORMS ASCII TO BINARY
	BLBS	R0,10$			; BR IF SUCCESS
	BRW	VALERR			; ELSE, ERROR
10$:	MOVL	SMT_L_MSGPTR(R11),R3	; SET MESSAGE POINTER FOR DATA STORES
	BSBB	SMT_INSBYTOPT		; INSERT BYTE OPTION INTO MESSAGE
	.BYTE	SMO$K_FORMTYPE		; SET SUBMIT FORMS TYPE
 
;
; DEQUEUE CHARACTERISTICS SPECIFIED
;
SMT_DQCHAR::				; SET DEQUEUE CHARACTERISTICS TYPES
	.WORD	SMT_MASK		; ENTRY MASK
	MOVL	4(AP),R2		; GET QUALIFIER DESCRIPTOR ADDRESS
	MOVAB	W^SMT_ASCIIVAL,R4	; GET VALUE CONVERT REQUEST DESCRIPTOR
	CLRQ	-(SP)			; INITIALIZE CHARACTERISTIC FLAGS
	CLRQ	-(SP)			;
10$:	MOVL	R4,R0			; SET REQUEST DESCRIPTOR
	BSBW	CALBAK1			; REQUEST NEXT ASCII VALUE
	PUSHAQ	CLI$Q_RQDESC(R4)	; SET STRING DESCRIPTOR FOR VALUE
	CALLS	#1,LIB$CNVCLIQCHAR	; CONVERT CHARACTERISTIC TO BINARY
	BLBS	R0,15$			; BRANCH IF SUCCESS CONVERTING
	MOVQ	CLI$Q_RQDESC(R4),-	; SAVE STRING DESC FOR ERROR MESSAGE
		CLI$Q_QDVALDESC(R2) 	;
	BRW	VALERR			; DISPLAY THE ERROR MESSAGE
15$:	BBSS	R1,(SP),20$		; SET CHARACTERISTIC FLAG
20$:	BBS	#CLI$V_MOREVALS,CLI$B_RQSTAT(R4),10$ ; BR IF MORE TO PROCESS
	MOVL	SMT_L_MSGPTR(R11),R3	; SET POINTER TO MESSAGE BUFFER
	MOVB	#SMO$K_DQCHAR,(R3)+	; STORE OPTION FLAG
	MOVQ	(SP)+,(R3)+		; STORE CHARACTERISTIC FLAGS
	MOVQ	(SP)+,(R3)+		;
	BRW	SETPT			; SET POINTER AND EXIT

SMT_COPIES::				; COPY COUNT SPECIFIED
	SETBYTOPT COPIES		;
 
SMT_JOBCOPY::				; SPECIFY JOB REPEAT COUNT
	SETBYTOPT JOBCOPY		;
 
SMT_JOBPRI::				; SPECIFY JOB QUEUE PRIORITY
	SETBYTOPT JOBPRI		;
 
SMT_SETBYTOPT:				; SET OPTION WITH BYTE VALUE
	BSBB	SMT_GETNUMVAL		; GET THE VALUE
SMT_INSBYTOPT:				; INSERT BYTE OPTION INTO MESSAGE
	MOVB	@(SP)+,(R3)		; SET OPTION CODE INTO THE BUFFER
	CMPB	(R3)+,#SMO$K_JOBPRI	; Priority option?
	BEQL	10$			; Br if yes -- zero is valid
	TSTL	R1			; Zero value?
	BEQL	IVERR			; Br if yes -- invalid	
10$:	MOVB	R1,(R3)+		; SET A BYTE INTO THE BUFFER
	CMPL	R1,#255			; VALUE EXCEED A BYTE
	BGTRU	IVERR			; BR IF YES
	BRB	SETPT			; EXIT
 
SMT_PAGCNT::				; PAGE LIMIT SPECIFIED
	.WORD	SMT_MASK		; COMMON ENTRY MASK
	BSBB	SMT_GETNUMVAL		; CONVERT VALUE
	MOVB	#SMO$K_PAGCNT,(R3)+	; SET OPTION FLAG
	MOVW	R1,(R3)+		; SET WORD VALUE
	CMPL	R1,#32767		; VALUE EXCEED A WORD VALUE
	BGTRU	IVERR			; BR IF YES
SETPT:	MOVL	R3,SMT_L_MSGPTR(R11)	; RESTORE ADJUSTED POINTER
	RET
 
SMT_GETNUMVAL:				; GET NUMERIC VALUE
	MOVL	SMT_L_MSGPTR(R11),R3	; SET MESSAGE POINTER FOR DATA STORES
	MOVL	4(AP),R2		; GET QUALIFER VALUE
	MOVQ	CLI$Q_QDVALDESC(R2),-	; SAVE ORIGINAL VALUE DESCRIPTOR
		SMT_Q_IOSB(R11)		; IN SCRATCH AREA
	MOVAB	W^SMT_NUMVAL,R0		; GET NUMERIC VALUE REQUEST DESCRIPTOR
	BSBW	CALBAK1			; ISSUE CALLBAK
VALER1:	BLBS	R0,5$			; BR IF NO ERROR CONVERTING VALUE
	BRW	VALERR			; BR TO ERROR ROUTINE
5$:	MOVL	W^CLI$L_RQVALU+SMT_NUMVAL,R1 ; GET VALUE
10$:	RSB				; RETURN WITH VALUE IN R1
 
;
; VALUE EXCEEDS LIMIT FOR SPECIFIED OPTION
;
 
IVERR:	MOVL	#CLI$_ILLVAL,R0		; SET ERROR CODE
	MOVL	4(AP),R1		; GET THE QUALIFIER DESCRIPTOR
	MOVQ	SMT_Q_IOSB(R11),-	; RESET DESCRITPOR FOR VALUE
		CLI$Q_QDVALDESC(R1)	; TO USE IN ERROR PRINT OUT
	BRW	VALERR			; REPORT THE ERROR
 
SMT_TIME::				; HOLD TIME SPECIFIED
	.WORD	SMT_MASK		; COMMON ENTRY MASK
	MOVL	SMT_L_MSGPTR(R11),R3	; SET MESSAGE POINTER FOR DATA STORES
	MOVL	4(AP),R1		; GET QUALIFIER DESCRIPTOR
	CLRQ	-(SP)			; GET A QUAD WORD BUFFER
	PUSHAQ	(SP)			; SECOND ARG IS ADDRESS OF TIME BUFFER
	PUSHAQ	CLI$Q_QDVALDESC(R1)	; PUSH THE ADDRESS OF THE STRING DESC
	CALLS	#2,LIB$CVT_TIME		; CONVERT THE TIME
	BLBS	R0,10$			; BR IF NO ERROR CONVERTING VALUE
	BRW	VALERR			; BR TO ERROR ROUTINE
10$:	MOVB	#SMO$K_RLSTIM,(R3)+	; SET OPTION FLAG CODE IN MESSAGE
	MOVQ	(SP)+,(R3)+		; SET TIME VALUE INTO MESSAGE
	BRB	SETPT			; RESET POINTER AND EXIT ACTION
 
SMT_PARAMS::				; BATCH PARAMETERS
	.WORD	SMT_MASK		; ENTRY MASK
	MOVL	SMT_L_MSGPTR(R11),R3	; SET POINTER TO MESSAGE BUFFER
	MOVL	4(AP),R2		; GET QUALIFIER DESCRIPTOR
	MOVAB	W^SMT_ASCIIVAL,R4	; GET VALUE CONVERT REQUEST DESCRIPTOR
	MOVB	#SMO$K_PARAMS,(R3)+	; STORE OPTION FLAG
10$:	MOVL	R4,R0			; SET REQUEST DESCRIPTOR
	BSBW	CALBAK1			; REQUEST NEXT ASCII VALUE
	MOVQ	CLI$Q_RQDESC(R4),R0	; GET STRING DESCRIPTOR FOR VALUE
	MOVB	R0,(R3)+		; STORE SIZE OF STRING
	BNEQ	20$			; BR IF NOT THE NULL STRING
	MOVB	#1,-1(R3)		; CHANGE LENGTH TO ONE
	MOVB	#^XFF,(R3)+		; Make the string a hex FF
	BRB	30$			;
20$:	PUSHR	#^M<R2,R4,R5>		; SAVE CRITICAL REGISTERS
	MOVC	R0,(R1),(R3)		; SET STRING IN MESSAGE
	POPR	#^M<R2,R4,R5>		; RESTORE REGISTERS AFTER MOVC
30$:	BBS	#CLI$V_MOREVALS,CLI$B_RQSTAT(R4),10$ ; BR IF MORE TO PROCESS
	CLRB	(R3)+			; TERMINATE THE STRING
	BRW	SETPT			; SET POINTER AND EXIT
;
; ACTION ROUTINE FOR WS QUOTA AND WS DEFAULT
;
SMT_WSQUOTA::				; WORKING SET QUOTA
	.WORD	SMT_MASK		; ENTRY MASK
	BSBB	COMMON			; JOIN COMMON CODE
	.BYTE	SMO$K_WSQUOTA		; OPTION FLAG

SMT_WSDEFLT::				; WORKING SET DEFAULT
	.WORD	SMT_MASK		; ENTRY MASK
	BSBB	COMMON			; JOIN COMMON CODE
	.BYTE	SMO$K_WSDEFLT		; OPTION FLAG

SMT_WSEXTNT::				; WORKING SET EXTENT
	.WORD	SMT_MASK		; ENTRY MASK
	BSBB	COMMON			; JOIN COMMON CODE
	.BYTE	SMO$K_WSEXTNT		; OPTION CODE

COMMON:	MOVL	4(AP),R0		; GET QUALIFER DESC.
	MOVQ	CLI$Q_QDVALDESC(R0),R4	; GET STRING DESCRIPTOR
	CMPL	#^A'NONE',(R5)		; CHECK IF "NONE"
	BEQL	30$			; BR IF YES - NEGATE QUALIFIER
	BSBW	SMT_GETNUMVAL		; CONVERT TO BINARY
	TSTL	R1			; TEST VALUE
	BEQL	30$			; BR IF = 0 TO NEGATE
	BITL	#^X0FFFF0000,R1		; IN RANGE?
	BEQL	25$			; BR IF OK
	BRW	IVERR			; BR TO SET UP ERROR MESSAGE
25$:	MOVB	@(SP)+,(R3)+		; SET OPTION FLAG IN MESSAGE
	MOVW	R1,(R3)+		; SET VALUE IN MESSAGE
	BRW	SETPT			; BR TO RESTORE UPDATED POINTER
30$:	MOVL	SMT_L_MSGPTR(R11),R3	; GET POINTER INTO MESSAGE
	MOVZBL	#SMO$K_NOWSQUO,R1	; ASSUME NO WS QUOTA
	MOVZBL	@(SP)+,R2		; GET OPTION CODE
	CMPB	R2,#SMO$K_WSQUOTA	; CHECK IF TRUE
	BEQL	35$			; IF EQ THEN CORRECT ASSUMPTION
	MOVZBL	#SMO$K_NOWSDFT,R1	; ASSUME NO WS DEFAULT
	CMPB	R2,SMO$K_WSDEFLT	; CHECK IF TRUE
	BEQL	35$			; IF EQ THEN TRUE
	MOVZBL	#SMO$K_NOWSEXTNT,R1	; ONLY THING LEFT IS WS EXTENT
35$:	MOVB	R1,(R3)+		; SET OPTION IN MESSAGE
	BRW	SETPT			; BR TO RESTORE UPDATED POINTER
;
; ACTION ROUTINE FOR CPU TIME LIMIT
;
SMT_CPUTIM::				; CPU TIME LIMIT
	.WORD	SMT_MASK		; ENTRY MASK
	MOVL	4(AP),R0		; GET QUALIFIER DESC.
	MOVQ	CLI$Q_QDVALDESC(R0),R4	; GET STRING DESC.
	CMPL	#^A'NONE',(R5)		; CHECK IF "NONE"
	BEQL	30$			; BR IF YES - NEGATE QUALIFIER
	CMPL	#^A'INFI',(R5)		; CHECK IF "INFINITE"
	BNEQ	15$			; BR IF NOT
	CLRL	R4			; SET CPU TIME = 0 = INFINITE
	BRB	20$			; GO STORE IN MESSAGE
15$:	PUSHAQ	-(SP)			; ADDR. TO GET BINARY TIME
	MOVL	4(AP),R0		; GET QUALIFIER DESC.
	PUSHAQ	CLI$Q_QDVALDESC(R0)	; PUSH STRING DESC.
	CALLS	#2,LIB$CVT_DTIME	; CONVERT ASCII STRING TO BIN. TIME
	MOVQ	(SP)+,R4		; Get converted value
	BLBC	R0,VALERR		; BR IF ERROR CONVERTING
	MOVL	#CLI$_ILLVAL,R0		; ASSUME ILLEGAL VALUE
	EDIV	#-20*10*1000,R4,R4,R5	; CONVERT TO LONG WORD
	BVS	VALERR			; BR IF WONT FIT
	ASHL	#1,R4,R4		; MAKE UNSIGNED VALUE
	TSTL	R5			; REMAINDER = 0 ?
	BEQL	20$			; BR IF YES
	INCL	R4			; INCREMENT TIME LIMIT
20$:	MOVL	SMT_L_MSGPTR(R11),R3	; GET POINTER INTO MESSAGE
	MOVB	#SMO$K_CPULIM,(R3)+	; STORE OPTION FLAG IN MESSAGE
	MOVL	R4,(R3)+		; STORE VALUE IN MESSAGE
	BRW	SETPT			; BR TO RESTORE UPDATED POINTER
30$:	MOVL	SMT_L_MSGPTR(R11),R3	; GET POINTER INTO MESSAGE
	MOVB	#SMO$K_NOCPULM,(R3)+	; SET NO CPU TIME LIMIT
	BRW	SETPT			; BR TO RESTORE UPDATED POINTER

	.SBTTL	VALUE CONVERT ERROR
;+
; VALERR - ERROR CONVERTING VALUE
;
; THIS ROUTINE IS ENTERED WHEN EVER AN ERROR IS DETECTED CONVERTING
; A VALUE.  A MESSAGE IS PRINTED AND RETURN ISSUED TO THE CALLER.
;
; INPUTS:
;	R0 = ERROR CODE FOR CONVERSION ERROR
;	4(AP) = QUALIFIER DESCRIPTOR WITH VALUE DESCRIPTOR
;
;	IT IS ASSUMMED THAT ENTRY IS MADE WITH A CALL FRAME ON THE
;	STACK.  AFTER THE MESSAGE IS PRINTED, A "RET" IS ISSUED TO
;	THE ORIGINAL CALLER.
;-
VALERR:	MOVZBL	#CLI$W_QDVALSIZ+4,R1	; SET OFFSET TO ERROR DESCRIPTOR
	BRB	CMDER1			; GOTO COMMAND CODE FOR COMMAND ERROR

	.SBTTL	COMMAND PARSE ERROR HANDLER
;+
; SMT$CMDERR - COMMAND PARSE ERROR
;
; ENTER HERE FOR THE RESULT PARSE ERROR ACTION TO PRINT A MESSAGE
; CONCERNING AN ERROR PARSING THE COMMAND
;
; INPUTS:
;
;	4(AP) = ADDRESS OF REQUEST DESCRIPTOR WITH ERROR SEGMENT
;	8(AP) = ERROR CODE
;
; OUTPUTS:
;
;	THE ERROR IS PRINTED AND CONTROL IS RETURNED TO THE
;	ORIGINAL CALLER.
;-
SMT$CMDERR::				;
	.WORD	SMT_MASK		; ENTRY MASK
	MOVL	8(AP),R0		; GET ERROR CODE
	MOVL	#CLI$W_RQSIZE+4,R1	; OFFSET TO BAD SEGMENT DESCRIPTOR
CMDER1:	SETBIT	SMT_V_CMDERR,SMT_W_FLAGS(R11) ; FLAG THAT ERROR OCCURRED
	ADDL	4(AP),R1		; POINT R1 AT ERROR SEGMENT DESCRIPTOR
	PUSHL	(R1)			; PUSH ADDRESS OF START OF ERROR SEGMENT
	ADDL	-(R1),(SP)		; FIND END OF ERROR SEGMENT
	ADDL3	W^SMT_GETCMD+CLI$W_RQSIZE,- ; FIND THE END OF THE
		W^SMT_GETCMD+CLI$W_RQSIZE+4,-(SP) ; THE ENTIRE COMMAND
	SUBL	4(SP),(SP)		; NOW THE LENGTH OF THE COMMAND
	CMPL	(SP),#80		; IS LINE TOO LONG
	BLEQU	10$			; BR IF NO
	MOVZBL	#80,(SP)		; SET REASONABLE VALUE
10$:	PUSHAQ	(SP)			; ADDRESS OF THAT DESCRIPTOR
	PUSHL	R1			; ADDRESS OF ERROR SEGMENT
	PUSHL	#<2!<1@16>>		; NUMBER OF FAO ARGUMENTS-SUPRESS PREFIX
	PUSHL	#CLI$_BADTEXT		; THE ERROR
	CLRL	-(SP)			; ZERO FAO ARG COUNT
	PUSHL	R0			; PUSH ERROR CODE
	PUSHL	#6			; TOTAL NUMBER OF ARGS IN BLOCK
	BRW	SHOW_MSG		; PRINT THE ERROR

	.SBTTL	EXECUTION ERROR
;+
; EXEERR - COMMAND EXECUTION ERROR
;
; THIS ROUTINE IS CALLED WHEN AN ERROR IS DETECTED ATTEMPTING TO CARRY
; OUT THE COMMAND ISSUED BY THE USER.
;
; INPUTS:
;
;	R0 = SYSTEM ERROR CODE
;	R1 = THE UTILITY ERROR CODE
;	R2 = LENGTH OF QUALIFIYING STRING
;	R3 = ADDRESS OF QUALFIYING STRING
;
; OUTPUTS:
;
;	THE MESSAGE IS DISPLAYED AND RETURN TO THE CALLER IS MADE.
;-
EXEERR:	.WORD	0			;
	PUSHR	#^M<R2,R3>		; FORM DESCRIPTOR FOR TEXT
	CLRL	-(SP)			; FAO COUNT = 0
	PUSHL	R0			; SYSTEM ERROR CODE
	PUSHAQ	8(SP)			; ADDRESS OF TEXT DESCRIPTOR
	PUSHL	#1			; NUMBER OF FAO ARGS
	PUSHL	R1			; UTILITY ERROR CODE
	PUSHL	#5			; TOTAL ARGUMENT COUNT
	BRW	SHOW_MSG		;

	.SBTTL	INPUT FILE OPEN FAILURE
;+
; INP_OPN_ERR - INPUT FILE OPEN ERROR
;
; THIS ROUTINE IS ENTERED WHEN AN OPEN FAILURE IS DETECTED ON THE INPUT
; FILE.  A MESSAGE IS PRINTED AND RETURN IS MADE TO THE ORIGINAL CALLER.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF THE FAB FOR WHICH ERROR OCCURRED
;
; OUTPUTS:
;
;	NONE
;-
INP_OPN_ERR:				; ERROR OPENING INPUT FILE
	.WORD	SMT_MASK		; REGISTER SAVE MASK
	MOVL	4(AP),R0		; GET THE FAB
	MOVL	FAB$L_NAM(R0),R1	; GET NAME BLOCK ADDRESS
	MOVL	NAM$L_RSA(R1),R3	; Address of resultant string
	MOVZBL	NAM$B_RSL(R1),R2	; Length of resultant string
	BNEQ	10$			; Br if resultant string formed
	MOVL	NAM$L_ESA(R1),R3	; ADDRESS OF EXPANDED STRING
	MOVZBL	NAM$B_ESL(R1),R2	; NOW ITS LENGTH
	BNEQ	10$			; BR IF EXPANDED STRING FORMED
	MOVL	FAB$L_FNA(R0),R3	; SET INPUT FILE NAME
	MOVZBL	FAB$B_FNS(R0),R2	; AND SIZE FOR MESSAGE
10$:	PUSHR	#^M<R2,R3>		; PUSH DESCRIPTOR FOR FILE NAME
	ASSUME	FAB$L_STV EQ FAB$L_STS+4
	MOVQ	FAB$L_STS(R0),-(SP)	; PUSH RMS ERROR CODES
	PUSHAQ	8(SP)			; ADDRESS OF NAME DESCRIPTOR
	PUSHL	#1			; NUMBER OF ARGUMENTS
	PUSHL	#SHR$_OPENIN!<3@16>	; MESSAGE CODE
	PUSHL	#5			; TOTAL SIZE OF THE MESSAGE PACKET
					; FALL INTO SHOW MESSAGE

	.SBTTL	SHOW MESSAGE
;+
; SHOW_MSG - DISPLAY A MESSAGE
;
; THIS ROUTINE IS ENTERED VIA A BR/JMP TO DISPLAY AN ERROR MESSAGE
;
; INPUTS:
;	0(SP) = THE MESSAGE DESCRIPTOR SET FOR A CALL TO SYS$PUTMSG.
;-
 
SHOW_MSG:				; OUTPUT THE ERROR
	MOVAB	W^SMT$CTXBLK,R11	; SET CONTEXT BLK ADR TO NORMAL PLACE
	BLBS	4(SP),10$		; BR IF MESSAGE IS INFORMATIONAL
	BICL	#6,4(SP)		; REDUCE SEVERITY LEVEL TO WARINING
	BISL3	#STS$M_INHIB_MSG,4(SP),-; OR MOST RECENT ERROR WITH INHIBIT -
		SMT_L_STATUS(R11)	; MESSAGE AND SAVE AS CURRENT STATUS
10$:	MOVAB	PRINT,R1		; ADDRESS OF COUNTED STRING
	BBS	#SMT_V_PRTCMD,SMT_B_BITMAP(R11),20$ ; BR IF ASSUMMED CORRECTLY
	MOVAB	SUBMIT,R1		; USE SUBMIT
20$:	MOVZBL	(R1)+,R0		; FORM STRING DESCRIPTOR FOR NAME
	PUSHR	#^M<R0,R1>		; FORM A STRING DESCRIPTOR IN STACK
	PUSHAQ	(SP)			; NOW PUSH THE ADDRESS OF THAT
	CLRL	-(SP)			; ZERO ADDRESS OF ACTION ROUTINE
	PUSHAB	16(SP)			; PUSH ADDRESS OF MESSAGE BUFFER
	CALLS	#3,@#SYS$PUTMSG		; PRINT THE MESSAGE
	MOVL	SMT_L_STATUS(R11),R0	; PASS ERROR TO CALLER
	RET				;

	.END	SUBMIT_FILE
