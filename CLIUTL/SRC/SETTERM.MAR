	.TITLE	SETTERM - SET CHARACTERISTICS OF A TERMINAL
	.IDENT	'V03-003'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITY "SET"
;
; ABSTRACT:	SET THE CHARACTERISTICS OF A TERMINAL
;
; AUTHOR:	R.HEINEN 21-NOV-1977
;
; MODIFIED BY:
;	V03-003	MIR0103		Michael I. Rosenblum	05-Apr-1982
;		Enhance error checking on SET TERM/INQUIRE
;
;	V03-002	MIR0102		Michael I. Rosenblum	31-Mar-1982
;		Fix CLI error message trapping.  Make /SPEED/AUTOBAUD
;		conflicting qualifiers.
;
;	V03-001	MIR0101		Michael I. Rosenblum	26-Mar-1982
;		Turn off AUTOBAUD if the /SPEED and /PERM switches
;		are present.  Change SET TERM/INQ to return a normal
;		warning message.
;
;	V02-020	MIR0092		Michael I. Rosenblum	2-Mar-1982
;		ECHO and PASSALL characteristics should not be affected
;		by terminal device types.  LOCAL_ECHO should also set and
;		reset ECHO.  Make SET TERM/INQUIRE better handle the AVO
;		option on DEC_CRT terminals.
;
;	V02-019	MIR0090		Michael I. Rosenblum	23-Feb-1982
;		Add INQUIRE sequences to LQP02,LA100, and LA12.
;		Make passall mode unaffected by device types.
;		Change terminal characteristics to reflect the terminal
;		better.
;
;	V02-018	MIR0082		Michael I. Rosenblum	28-Jan-1981
;		The VT100J and the GIGI have answerback sequences that are
;		the same down to the digit following the ; in the sequence
;		added some code to handle this situation.  GIGI and VT125
;		REGIS are not the same so we removed the REGIS characteristic
;		from the GIGI keeping with DEC philosophy.
;
;	V02-017	MIR0073		Michael I. Rosenblum	11-Jan-1981
;		Add  LA12 inquire sequence.
;
;	V02-016 MIR0070		Michael I. Rosenblum	 5-Jan-81
;		Avoid printing the message SS$_INCOMPAT when not
;		necessary.
;
;	V02-015 MIR0059		Michael I. Rosenblum	21-Dec-81
;		Set term /UNK did not reset ansi and other informational
;		bits.  Inhanced error processing for remote terminals.
;
;	V02-014	MIR0057		Michael I. Rosenblum	14-Dec-81
;		Change to LIB$LOOKUP_KEY changed error messages also,
;		Lib errors require fao string containing the field.
;
;	V02-013	MIR0047		Michael I. Rosenblum	30-Nov-1981
;		Add AVO to VT102 ADD LA100, LQP02 and add DECCRT,
;		change ANSICRT to DECCRT, include EDIT.
;		fix bug where /INQUIRE will not recognize LA120's.
;
;	V02-012	MIR0046		Michael I. Rosenblum	 8-Oct-1981
;		Fix the device type qualifier to use LIB$LOOKUP_KEY
;		to give better translation on key words.
;
;	V02-011	MIR0036		Michael I. Rosenblum	10-Sep-1981
;		Added the ANSI option on set term Change GIGI
;		To VK100.
;
;	V02-010	MIR0015		Michael I. Rosenblum	17-Aug-1981
;		Impliment the second device dependent word.
;		Implimented set ter/inquire which will ask the terminal
;		for it's type then set it that way
;
;	V02-009	GWF0053		Gary W. Fowler		1-Jun-1981
;		Change error status to warning if invalid device name error
;		is issued.
;
;	V02-008	GWF0008		Gary W. Fowler		28-Jan-1981
;		Fix so error status is passed back to dispatcher if error
;		parsing qualifiers such as /SPEED or /CR
	.SBTTL	MACROS FOR CLI
;--
;
; LOCAL MACROS
;
	.MACRO	CALLBAK	P1,P2
	.IF B <P2>
	PUSHAB	W^BITS			; ADDRESS OF BIT MASK
	.IFF
	PUSHAB	P2			; ADDRESS OF THIRD ARGUEMENT
	.ENDC
	PUSHAB	W^SET$A_CLIWORK	; COMMON WORK AREA
	PUSHAB	P1			; THE REQUEST DESCRIPTOR
	CALLS	#3,@CLI$A_UTILSERV(AP)	; REQUEST THE SERVICE OF THE CLI
	.ENDM				;

	.MACRO	MATCHTAB	QUALIF,CHARI,PREFIX=TT$V_
	.=MATCHTABLE+CLI$K_STTT_'QUALIF
	.BYTE	PREFIX''CHARI
	.ENDM
	.SBTTL	Macro to create a Descriptor
;
	.macro	DESC	STRING
.SAVE
	.PSECT	SET$TERM$STRN
$$=.
	.ASCII	/STRING/
$$$=.-$$
.RESTORE
	.LONG	$$$
	.LONG	$$
	.ENDM
 
;
; MACRO TO GENERATE NEW TERMINAL DEFAULT BLOCKS.
;
.SAVE
	.PSECT	SET$TERM$TYPS
TYPSTRTAB:
	.PSECT	SET$TERM$TYDF
TYPDEFTAB:.LONG	NUMTYPS
	.PSECT	SET$TERM$RESD
TYPRESTAB:
	.PSECT	SET$TERM$REST
TYPRESTRN:
.RESTORE
NUMTYPS==0
;
;		Macro to define a terminal types
;
; Description:
;
;	This macro creates several data structures that define a terminal
; type.  The data structures are as follows:
;
;	TYPRESTAB:	A structure of the response strings from each terminal
;	TYPRESTRN:	The coresponding type descriptor location to the
;			response strings.
;	TYPSTRTAB:	The keyword defining the terminal type
;	TYPDEFTAB:	The coresponding type descriptor location to the
;			keyword strings
;
;	type descriptor:
;					
;		+---------------+-------+-------+
;		| Width		| page	| type	|
;		+---------------+-------+-------+
;		| Bits to reset in DEVDEPN	|
;		+-------------------------------+
;		| Bits to set in DEVDEPN	|
;		+-------------------------------+
;		| Bits to reset in DEVDEP1	|
;		+-------------------------------+
;		| Bits to set in DEVDEP1	|
;		+-------------------------------+
;
; Inputs:
;
;	TYPE	The terminal name and definition name (I.E. TT$_LA36 would
;		be LA36)
;	WID	The terminals page width
;	PAGE	The terminals page length
;	RESTT$	The bits in DEVDEPN to reset (Omit TT$_)
;	SETTT$	The bits in DEVDEPN to set (Omit TT$_)
;	RESTT2$	The bits in DEVDEP1 to reset (Omit TT2$_)
;	SETTT2$	The bits in DEVDEP1 to set (Omit TT2$_)
;	RESP	The terminal response string (upto and including
;		the semicolin if one is present no escape before
;		the string) more than 1 allowed
;
	.MACRO	TRMNL	TYPE,WID=0,PAGE=0,RESTT$=<>,SETTT$=<>,RESTT2$=<>,-
			SETTT2$=<>,RESP=<>


.SAVE
	.PSECT	SET$TERM$TYPS
$$$=.
	.ASCIC	/TYPE/
	.PSECT	SET$TERM$TYDF
	.LONG	$$$
	.LONG	TYPE'_DAT
	.IF	NB	<RESP>
		.IRP	FLAG,RESP
			.PSECT	SET$TERM$RESD
			.ASCIC	\FLAG\
			.PSECT	SET$TERM$REST
			.LONG	TYPE'_DAT
		.ENDR
	.ENDC
.RESTORE

TYPE'_DAT:
.IF NE WID+1
	.BYTE	TT$_'TYPE
NUMTYPS==NUMTYPS+2
.IFF
	.BYTE	0
.ENDC
	.BYTE	PAGE
	.WORD	WID
	TT$MASK=0
.IF	NB	<RESTT$>
		.IRP	FLAG,RESTT$
		TT$MASK=TT$MASK+TT$M_'FLAG
		.ENDR
.ENDC
	.LONG	TT$MASK
	TT$MASK=0
.IF	NB	<SETTT$>
		.IRP	FLAG,SETTT$
		TT$MASK=TT$MASK+TT$M_'FLAG
		.ENDR
.ENDC

	.LONG	TT$MASK
	TT$MASK=0
.IF	NB	<RESTT2$>
		.IRP	FLAG,RESTT2$
		TT$MASK=TT$MASK+TT2$M_'FLAG
		.ENDR
.ENDC
	.LONG	TT$MASK
	TT$MASK=0
.IF	NB	<SETTT2$>
		.IRP	FLAG,SETTT2$
		TT$MASK=TT$MASK+TT2$M_'FLAG
		.ENDR
.ENDC
	.LONG	TT$MASK
	.ENDM

;
; EXTERNAL SYMBOLS
;
	$CLIDEFQUALSET			; DEFINE QUALIFIER CODES
	$CLIMSGDEF			; DEFINE CLI MESSAGES
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE SECOND TERMINAL DEPENDENT LONGWORD
	$STSDEF				; STATUS DEFINITIONS
;
; DEFINE BITS USED TO TEST FOR CONFLICTING QUALIFIERS
;
	_VIELD	TERM,0,<-
		<LA36,,M>,-		; TERMINAL TYPE LA36
		<VT05,,M>,-		; TERMINAL TYPE VT05
		<VT52,,M>,-		; TERMINAL TYPE VT52
		<VT55,,M>,-		; TERMINAL TYPE VT55
		<VT10,,M>,-		; TERMINAL TYPE VT100
		<UNKN,,M>,-		; TERMINAL TYPE UNKNOWN
		<LA12,,M>,-		; TERMINAL TYPE LA120
		<TYPE,,M>,-		; THE TYPE QUALIFIER
		<FT,,M>,-		; TERMINAL TYPE FT1-8
		<SPEED,,M>,-		; SPEED SPECIFIED
		<AUTOB,,M>,-		; AUTOBAUD SPECIFIED
		>
;
; LOCAL STORAGE
;
	.PSECT	SET$RWDATA,NOEXE,LONG
 
CHAN:		.LONG	0		; TERMINAL CHANNEL NUMBER
BITS:		.LONG	0		; STORAGE FOR CLI CALL BACK
IOSTATUS:	.LONG	0,0		; IOSB FOR TERMINAL GET CHARACTERISTICS
UTIL_DESC:	.LONG	0,0		; UTILITY DESC
GET_CHAN_INFO:	.LONG	16
		.LONG	CHAN_INFO-4
		.LONG	0
CHAN_INFO:
		.BLKB	1
TERMTYPE:	.BLKB	1
WIDTH:		.BLKW	1
TERMCHAR:	.BLKB	4
TRM2CHAR:	.BLKB	4

MASK2:		.BLKB	4
ENABLE2:	.BLKL	1

MASK:		.BLKB	3
PAGESIZ:	.BLKB	1

ENABLE:		.BLKL	1

TMPINFO:	.BLKL	1
WIDCHG:		.BLKB	1

RECDES:		.LONG	0
		.LONG	RECSEQ

RECSEQ:		.BLKB	15
RECSEQLEN=.-RECSEQ

FOUND_KEY:	.BLKL	1

QIO:	$QIO	FUNC=IO$_SETMODE,EFN=1,IOSB=IOSTATUS,P1=CHAN_INFO,P2=12
 
TERMNAME:
	$CLIREQDESC	RQTYPE=CLI$K_INPUT1	; GET THE INPUT OR TERMINAL NAME
CHAR_QUAL:
	$CLIREQDESC	RQTYPE=CLI$K_GETQUAL,QUALST=QUALS,ERRACT=CLI_ERR
NUM_VAL:
	$CLIREQDESC	RQTYPE=CLI$K_NUMERVAL
ASCII_VAL:
	$CLIREQDESC	RQTYPE=CLI$K_ASCIIVAL
QUALS:
	$CLIQUALDESC	QDCODE=CLI$K_STTT_PERM,TRUACT=PERM
	$CLIQUALDESC	QDCODE=CLI$K_STTT_DEVI,TRUACT=TYPE,SETLST=TERM_V_TYPE
	$CLIQUALDESC	QDCODE=CLI$K_STTT_LA36,TRUACT=LA36,-
			SETLST=TERM_V_LA36,-
			TSTLST=<TERM_V_VT05,TERM_V_VT52,TERM_V_VT55,TERM_V_TYPE,-
				TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_VT05,TRUACT=VT05,-
			SETLST=TERM_V_VT05,-
			TSTLST=<TERM_V_LA36,TERM_V_VT52,TERM_V_VT55,TERM_V_TYPE,-
				TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_VT52,TRUACT=VT52,-
			SETLST=TERM_V_VT52,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT55,TERM_V_TYPE,-
				TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_VT55,TRUACT=VT55,-
			SETLST=TERM_V_VT55,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_VT10,TRUACT=VT100,-
			SETLST=TERM_V_VT10,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_UNKN,TERM_V_LA12,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_UNKN,TRUACT=UNKN,-
			SETLST=TERM_V_UNKN,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_LA12,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_LA12,TRUACT=LA120,-
			SETLST=TERM_V_LA12,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_FT>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT1,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT2,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT3,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT4,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT5,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT6,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT7,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FT8,TRUACT=FT,-
			SETLST=TERM_V_FT,-
			TSTLST=<TERM_V_LA36,TERM_V_VT05,TERM_V_VT52,TERM_V_TYPE,-
				TERM_V_VT55,TERM_V_VT10,TERM_V_UNKN,TERM_V_LA12>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_INQU,TRUACT=INQU,SETLST=TERM_V_TYPE
;
	$CLIQUALDESC	QDCODE=CLI$K_STTT_BROA,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_ECHO,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_EIGH,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_ESCA,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_HARD,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_HOLD,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_HOST,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDEF	QDCODE=CLI$K_STTT_INTE,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_LOWE,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_PASS,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_SCOP,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_READ,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_SCRI,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_TAB,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_TTSY,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_TYPE,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_UPPE,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_WRAP,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FORM,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_FULL,TRUACT=CLEAR,FLSACT=SET,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_HALF,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_LOCA,TRUACT=SETLOCA,FLSACT=CLEARLOCA,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_AUTO,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>,SETLST=TERM_V_AUTOB,-
			TSTLST=<TERM_V_SPEED>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_HANG,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_BRDC,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_NODM,TRUACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_ALTY,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_DEC_,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_REGI,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_BLOC,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_ADVA,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_EDIT,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_XON,TRUACT=SET2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_MODE,TRUACT=SET,FLSACT=CLEAR,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_ANSI,TRUACT=SET2,FLSACT=CLEAR2,-
			QDFLGS=<CLI$V_QDEXPA>
	$CLIQUALDESC	QDCODE=CLI$K_STTT_SET_,TRUACT=CLEAR2,FLSACT=SET2,-
			QDFLGS=<CLI$V_QDEXPA>
;
CRFI_QUAL:$CLIQUALDESC	QDCODE=CLI$K_STTT_CRFI,TRUACT=CRFI
LFFI_QUAL:$CLIQUALDESC	QDCODE=CLI$K_STTT_LFFI,TRUACT=LFFI
PAGE_QUAL:$CLIQUALDESC	QDCODE=CLI$K_STTT_PAGE,TRUACT=PAGE
PARI_QUAL:$CLIQUALDESC	QDCODE=CLI$K_STTT_PARI,TRUACT=PARI,FLSACT=NOPARI,-
			QDFLGS=<CLI$V_QDEXPA>
SPEE_QUAL:$CLIQUALDESC	QDCODE=CLI$K_STTT_SPEE,TRUACT=SPEE,-
			SETLST=TERM_V_SPEED,TSTLST=<TERM_V_AUTOB>
WIDT_QUAL:$CLIQUALDESC	QDCODE=CLI$K_STTT_WIDT,TRUACT=WIDT
	$CLIQUALDESC	END_LIST
;
; TABLE OF QUALIFIER TO CHARACTERISTIC CONVERSION
;
MATCHTABLE:				;
	MATCHTAB	BROA,NOBRDCST
	MATCHTAB	ECHO,NOECHO
	MATCHTAB	EIGH,EIGHTBIT
	MATCHTAB	ESCA,ESCAPE
	MATCHTAB	HARD,SCOPE
	MATCHTAB	HOLD,HOLDSCREEN
	MATCHTAB	HOST,HOSTSYNC
	MATCHTAB	INTE,PASSALL
	MATCHTAB	LOWE,LOWER
	MATCHTAB	PASS,PASSALL
	MATCHTAB	SCOP,SCOPE
	MATCHTAB	READ,READSYNC
	MATCHTAB	SCRI,SCRIPT
	MATCHTAB	TAB,MECHTAB
	MATCHTAB	TTSY,TTSYNC
	MATCHTAB	TYPE,NOTYPEAHD
	MATCHTAB	UPPE,LOWER
	MATCHTAB	WRAP,WRAP
	MATCHTAB	FORM,MECHFORM
	MATCHTAB	FULL,HALFDUP
	MATCHTAB	HALF,HALFDUP
	MATCHTAB	MODE,MODEM
	MATCHTAB	LOCA,LOCALECHO,TT2$V_
	MATCHTAB	AUTO,AUTOBAUD,TT2$V_
	MATCHTAB	HANG,HANGUP,TT2$V_
	MATCHTAB	BRDC,BRDCSTMBX,TT2$V_
	MATCHTAB	NODM,DMA,TT2$V_
	MATCHTAB	ALTY,ALTYPEAHD,TT2$V_
	MATCHTAB	DEC_,DECCRT,TT2$V_
	MATCHTAB	REGI,REGIS,TT2$V_
	MATCHTAB	BLOC,BLOCK,TT2$V_
	MATCHTAB	ADVA,AVO,TT2$V_
	MATCHTAB	EDIT,EDIT,TT2$V_
	MATCHTAB	XON,XON,TT2$V_
	MATCHTAB	ANSI,ANSICRT,TT2$V_
	MATCHTAB	SET_,SETSPEED,TT2$V_
.=MATCHTABLE+64

;
; TABLE FOR TERMINAL TYPE DATA
;

TRMNL	LA36,WID=132,PAGE=66,-
	SETTT$=LOWER,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>

TRMNL	LA34,WID=132,PAGE=66,-
	RESTT$=<MECHTAB>,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=<<<[?3;>>>

TRMNL	LA38,WID=132,PAGE=66,-
	RESTT$=<MECHTAB>,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>

TRMNL	LA120,WID=132,PAGE=66,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=<<<[?2;>>>	

TRMNL	LA100,WID=132,PAGE=66,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=<<<[?10;>>>	

TRMNL	LA12,WID=80,PAGE=66,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=<<<[?15;>>>	

TRMNL	LA24,WID=132,PAGE=66,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>

TRMNL	LQP02,WID=132,PAGE=66,-
	SETTT$=<MECHFORM,LOWER,HOSTSYNC,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=<<<[?13;>>>	

TRMNL	VT05,WID=72,PAGE=20,-
	RESTT$=<HOLDSCREEN,LOWER>,-
	SETTT$=<SCOPE,LFFILL,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>

TRMNL	VT52,WID=80,PAGE=24,-
	RESTT$=<HOLDSCREEN,MECHFORM,HOSTSYNC>,-
	SETTT$=<LOWER,SCOPE,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=</K,/L,/Z,/A,/H,/J,/B,/J,/M,/Q,/R,/S,/T>

TRMNL	VT55,WID=80,PAGE=24,-
	RESTT$=<HOLDSCREEN,MECHFORM,HOSTSYNC>,-
	SETTT$=<LOWER,SCOPE,MECHTAB>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>,-
	RESP=</C,/E>

TRMNL	VK100,WID=84,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<BLOCK,DECCRT,AVO,EDIT,REGIS>,-
	SETTT2$=<ANSICRT>,-
	RESP=<<<[?5;>>>

TRMNL	VT100,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<REGIS,BLOCK,EDIT>,-
	SETTT2$=<DECCRT,ANSICRT,AVO>,-
	RESP=<<<[?1;>>>

TRMNL	VT101,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<REGIS,BLOCK,AVO,EDIT>,-
	SETTT2$=<DECCRT,ANSICRT>

TRMNL	VT102,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<REGIS,BLOCK>,-
	SETTT2$=<DECCRT,ANSICRT,AVO,EDIT>,-
	RESP=<<<[?6;>>>

TRMNL	VT105,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<REGIS,BLOCK,EDIT,AVO>,-
	SETTT2$=<DECCRT,ANSICRT>

TRMNL	VT125,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<BLOCK,EDIT>,-
	SETTT2$=<DECCRT,ANSICRT,REGIS,AVO>,-
	RESP=<<<[?12;>>>

TRMNL	VT131,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<REGIS>,-
	SETTT2$=<DECCRT,ANSICRT,BLOCK,EDIT,AVO>,-
	RESP=<<<[?7;>>>
	

TRMNL	VT132,WID=80,PAGE=24,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<REGIS>,-
	SETTT2$=<DECCRT,ANSICRT,BLOCK,AVO,EDIT>,-
	RESP=<<<[?4;>>>

TRMNL	VT173,WID=80,PAGE=16,-
	RESTT$=<MECHFORM>,-
	SETTT$=<HOSTSYNC,MECHTAB,SCOPE,LOWER>,-
	RESTT2$=<DECCRT,ANSICRT,REGIS>,-
	SETTT2$=<BLOCK>,-
	RESP=<<<;>>>
;
TRMNL	FT1
TRMNL	FT2
TRMNL	FT3
TRMNL	FT4
TRMNL	FT5
TRMNL	FT6
TRMNL	FT7
TRMNL	FT8
TRMNL	UNKNOWN,-
	RESTT2$=<DECCRT,ANSICRT,REGIS,BLOCK,AVO,EDIT>


.SAVE
	.PSECT	SET$TERM$TYPS
	.BYTE	0
	.PSECT	SET$TERM$RESD
	.BYTE	0
.RESTORE
;
; PATCH SPACE
;
TRMNL	UNKNOWN1,-
	WID=-1,-
	RESP=<;>
TRMNL	UNKNOWN2,-
	WID=-1,-
	RESP=<;>
TRMNL	UNKNOWN3,-
	WID=-1,-
	RESP=<;>
TRMNL	UNKNOWN4,-
	WID=-1,-
	RESP=<;>
TRMNL	UNKNOWN5,-
	WID=-1,-
	RESP=<;>
;
; SET WIDTH ON DECCRTTERMINALS
;
SET132:
	.ASCII	/[?3h/
SET80:
	.ASCII	/[?3l/
SETLEN=.-SET80
;
; ASK FOR ANSWER BACK SEQUENCES.
;
DESTAB:	DESC	<Z>
	DESC	<[0c>

	.LONG	0

;
; TABLE OF SPEED TO PARAMETER CONVERTION
;
SPEED:
	.WORD	50,75,110,134,150,300,600,1200,1800,2000,2400,3600,4800,7200,9600,19200,0

IN_SPEED:.BYTE	0
OUT_SPEED:.BYTE 0

SYS_COMMAND:
	.ASCID	/SYS$COMMAND/
	.PSECT	SET$CODE,NOWRT
;++
; SET$TERM - SET TERMINAL CHARACTERISTICS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS THE CHARACTERISTICS OF A SPECIFIED TERMINAL.
; IT IS ENTERED AS A RESULT OF A DISPATCH FROM THE SET COMMAND PROCESSOR.
;
; INPUTS:
;
;	THE CLI DATA BASE IS SET UP. 
;
; OUTPUTS:
;
;	SET$L_STATUS = STATUS OF THE OPERATION
;--
SET$TERM::				; SET TERMINAL COMMAND
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVAB	W^TERMNAME,R6		; ADDRESS QUAL DESC
	CALLBAK	(R6)			; CALL CLI FOR TERMINAL NAME
	MOVAB	CLI$Q_RQDESC(R6),R6	; ADDRESS NAME DESC
	TSTL	(R6)			; NAME PRESENT?
	BNEQ	20$			; IF NEQ THEN ASSIGN THAT NAME
;
; DEFUALT NAME IS "SYS$COMMAND"
;
	MOVZBL	#3,R2			; SET UP TRANSLATE COUNTER
	MOVAB	W^SYS_COMMAND,R6	; ADDRESS DESC FOR ORIGINAL NAME
10$:	MOVQ	W^SHOW$GQ_OUT_DSC,W^UTIL_DESC
	$TRNLOG_S	(R6),W^UTIL_DESC,W^UTIL_DESC; TRANSLATE NAME
	BLBC	R0,20$			; IF LOW CLEAR THEN DONE
	CMPW	R0,#SS$_NOTRAN		; DONE?
	BEQL	20$			; IF EQL THEN YES
	MOVQ	W^UTIL_DESC,(R6)	; SET UP FOR NEXT TRANSLATION
	CMPB	@4(R6),#^X01B		; PROCESS PERM?
	BNEQ	15$			; IF NEQ THEN NO
	ADDL	#4,4(R6)		; SET NEW ADDRESS
	SUBL	#4,(R6)			; AND SIZE
	BRB	20$			; CONTINUE
15$:	SOBGTR	R2,10$			; CONTINUE UNTIL DONE
20$:	$ASSIGN_S	(R6),W^QIO+8	; ASSIGN CHANNEL TO DEVICE
	BLBC	R0,ERROR		; IF LOW CLEAR THEN ERROR AND EXIT
;
; ASSUME SET OF TEMPORARY CHARACTERISTICS
;
	$GETCHN_S	W^QIO+8,,W^GET_CHAN_INFO
	BLBC	R0,ERROR		; IF LOW CLEAR THEN ERROR
	MOVZWL	#SS$_IVDEVNAM,R0	; ASSUME DEVICE NOT TERMINAL
	INSV	#STS$K_WARNING,#STS$V_SEVERITY,-
		#STS$S_SEVERITY,R0
	BBS	#DEV$V_TRM,W^CHAN_INFO-4,SET_CHAR; BR IF NOT TERMINAL
;
; ERROR IN GETTING CHARACTERISTICS
;
ERROR:	MOVL	R0,W^SET$L_STATUS	; SAVE FOR EXIT STATUS
	RET				; RETURN
;
; PROCESS DATA
;
SET_CHAR:				; PROCESS DATA
	CLRQ	W^CHAN_INFO		;CLEAN THE BLOCK
	CLRL	W^CHAN_INFO+8		;FOR COMPATABILITY REASONS
	$QIOW_S	CHAN=W^QIO+8,-		; GET THE CURRENT INFORMATION
		FUNC=#IO$_SENSEMODE,-	;WITH THE LONG DEVDEPENT WORD
		IOSB=W^IOSTATUS,-
		P1=W^CHAN_INFO,-
		P2=#12			
	MOVL	R0,W^SET$L_STATUS
	BLBC	R0,45$			;CHECK THE RETURN STATUS
	MOVZWL	W^IOSTATUS,W^SET$L_STATUS
	BLBS	W^IOSTATUS,50$
45$:	BRW	100$
50$:	CLRQ	W^QIO+36		; RESET FILL,SPEED AND PARITY DATA
	CLRL	W^QIO+44		;
	CLRQ	W^MASK			; ZERO MASK AND ENABLES
	CLRQ	W^MASK2			; ZERO THE SECOND MASK AND ENABLES
	MNEGB	#1,W^ENABLE+3		; SET PAGE MAGIC
	MOVB	W^CHAN_INFO+7,W^PAGESIZ	; SET UP OLD PAGE
	MOVZWL	#IO$_SETMODE,W^QIO+12	; ASSUME SET TEMPORARY
	MOVZWL	#SS$_NORMAL,W^SET$L_STATUS; ASSUME SUCCESS
	CALLBAK	W^CHAR_QUAL
	MOVL	W^SET$L_STATUS,R0	; SET STATUS FROM CALL BACK
	BLBS	R0,55$			; IF CLEAR, THEN RETURN ERROR
	BRW	100$
55$:	BICL	W^ENABLE,W^CHAN_INFO+4
	BISL	W^MASK,W^CHAN_INFO+4
	BICL	W^ENABLE2,W^CHAN_INFO+8
	BISL	W^MASK2,W^CHAN_INFO+8
	TSTB	W^WIDCHG		; DID THE WIDTH CHANGE THIS TIME AROUND
	BEQL	90$			; NO THEN DON'T WORRIE ABOUT WIDTH
	BBC	#TT2$V_DECCRT,W^CHAN_INFO+8,90$; IF IT ISN'T AN DECCRT TERMINAL THEN
	CMPW	W^WIDTH,#80		; IS THE WIDH GREATER THAN 80
	BLEQ	80$			; NO THEN CHECK  80 OR LESS.
	MOVAL	W^SET132,R0		; YES THEN SEND OUT AN ESCAPE SEQUENCE
	BBS	#TT2$V_AVO,W^CHAN_INFO+8,85$; DOES THIS HAVE AVO?
	MOVB	#12,W^TERMCHAR+3	; NO THEN THE PAGE IS 12 LONG
	BRB	85$			; SAYING SO
80$:	CMPW	W^WIDTH,#80		; OR IS HE SETTING IT TO 80
	BGTR	90$			; NO THEN CHECK AVO
	MOVAL	W^SET80,R0		;ELSE SET IT TO 80
	BBS	#TT2$V_AVO,W^CHAN_INFO+8,85$; DOES THIS HAVE AVO?
	MOVB	#24,W^TERMCHAR+3	;NO THEN RESET THE TERMINAL TO 24 LINES
85$:	$QIOW_S	CHAN=W^QIO+8,-		;SET THE CHANNEL UP
		FUNC=#IO$_WRITEVBLK,-	;WRITE THE SEQUENCE
		P1=(R0),-		;ON R0
		P2=#SETLEN		; AND SET THE SCREEN TO DO IT
	BLBC	R0,95$			;MAKE SURE WE DID IT OK

90$:	TSTL	ENABLE2			;DID WE CHANGE ANYTHING IN THE NEW CHAR
	BNEQ	93$			;LONG WORD??
	MOVL	#8,W^QIO+QIO$_P2	;NO THEN DON'T SET THAT WORD
93$:	$QIOW_G	W^QIO			; SET THE MODE OR CHARACTERISTICS
	CMPW	W^IOSTATUS,#SS$_INCOMPAT; DID WE GET AN INCOMPATIBLE STATUS BACK
	BNEQ	95$			;NO THEN JUST CHECK FOR FATAL ERRORS
	MOVZWL	W^IOSTATUS,-(SP)	;GET THE ERROR AND OUTPUT IT
	CALLS	#1,G^LIB$SIGNAL		; AND SIGNAL IT...
95$:	MOVW	R0,W^SET$L_STATUS	; SAVE STATUS
	BLBC	R0,100$			; IF LOW CLEAR THEN ERROR
	MOVZWL	W^IOSTATUS,W^SET$L_STATUS	; SAVE STATUS
100$:	$DASSGN_S	W^QIO+8		; DEASSIGN THE TERMINAL
	RET				; RETURN

	.SBTTL	CLI ERROR ACTION ROUTINE
;
; HERE ON CLI QUALIFIER PROCESSING ERRORS
;
; INPUTS:
;	4(AP)	ADDRESS OF REQUEST DESCRIPTOR
;	8(AP)	ERROR STATUS
;
; OUTPUTS:
;	R0	ERROR STATUS
;	ERROR STATUS IS PASSED TO LIB$STOP
;
;
.ENTRY	CLI_ERR,^M<>
	PUSHL	8(AP)			; Store error status
	CALLS	#1,G^LIB$STOP		; Signal the error
	MOVL	8(AP),R0		; Pass the error back to the caller
	RET

	.SBTTL	PERMANENT QUALIFIER ACTION ROUTINE
;
; PERM QUALIFIER - SET PERMANENT CHARACTERISTICS
;
PERM:	.WORD	0			;
	CLRQ	W^CHAN_INFO		;CLEAN THE BLOCK FOR COMPATABILITY REASONS
	CLRL	W^CHAN_INFO+8		;
	$QIO_S	#0,W^QIO+8,#IO$_SENSECHAR,P1=W^CHAN_INFO,P2=#12
	BLBS	R0,10$			;DID WE GET AN ERROR?
	MOVL	R0,W^SET$L_STATUS	;SET THE STATUS TO THIS EROR
	RET

10$:	MOVB	W^CHAN_INFO+7,W^PAGESIZ	; SET UP PAGE SIZE MASK
	MOVZWL	#IO$_SETCHAR,W^QIO+12	; SET UP NEW FUNCTION CODE
	RET				; DONE
	.SBTTL	GENERAL SET/CLEAR ACTION ROUTINES
;
;
; SET CHARACTERISTIC
;
SET:	.WORD	0			; SET THE CHARACTERISTIC
	BSBB	GET_MASK		; GET THE MASK
	BISL	R0,W^ENABLE		; ENABLE FOR CHANGE
	BISL	R0,W^MASK		; SET VALUE AS ON
	RET				;
;
; SECOND DEV DEPENT WORD
;
SET2:	.WORD	0
SET2A:	BSBB	GET_MASK
	BISL	R0,W^ENABLE2		; ENABLE FOR CHANGE
	BISL	R0,W^MASK2
	RET
;
; CLEAR CHARACTERISTIC
;
CLEAR:	.WORD	0			; CLEAR THE CHARACTERISTIC
	BSBB	GET_MASK		; GET THE MASK
	BISL	R0,W^ENABLE		; ENABLE FOR CHANGE
	BICL	R0,W^MASK		; SET VALUE AS OFF
	RET				;
;
; SECOND DEV DEPENT WORD
;
CLEAR2:	.WORD	0
CLEAR2A:BSBB	GET_MASK
	BISL	R0,W^ENABLE2		; ENABLE FOR CHANGE
	BICL	R0,W^MASK2
	RET
;
; SUBROUTINE TO GET MASK VALUE
;
GET_MASK:				;
	MOVL	4(AP),R0		; GET QUALIFIER DESC ADDRESS
	MOVZBL	CLI$B_QDCODE(R0),R0	; GET QUALIFIER NUMBER
	MOVZBL	W^MATCHTABLE[R0],R0	; GET MASK VALUE
	ASHL	R0,#1,R0		; SET UP MASK
	RSB				;
;
; HANDLE SETTING NOECHO WITH LOCAL_ECHO
;
.ENTRY	SETLOCA,0
	BBSS	#TT$V_NOECHO,W^ENABLE,1$
1$:	BBSS	#TT$V_NOECHO,W^MASK,2$
2$:	BRB	SET2A
.ENTRY	CLEARLOCA,0
	BBSS	#TT$V_NOECHO,W^ENABLE,1$
1$:	BBCC	#TT$V_NOECHO,W^MASK,2$
2$:	BRB	CLEAR2A

	.SBTTL	TERMINAL TYPE ACTION ROUTINES
 
UNKN:	.WORD	0			;
	MOVAB	W^UNKNOWN_DAT,R0
	BRB	SET_TYPE
LA36:	.WORD	0
	MOVAB	W^LA36_DAT,R0		; GET DATA TABLE ADDRESS
	BRB	SET_TYPE		; SET UP THE TYPE
VT52:	.WORD	0			;
	MOVAB	W^VT52_DAT,R0		; ADDRESS DATA TABLE
	BRB	SET_TYPE		; SET UP TYPE
VT55:	.WORD	0			;
	MOVAB	W^VT55_DAT,R0		; ADDRESS DATA TABLE
	BRB	SET_TYPE		; SET UP TYPE
VT100:	.WORD	0
	MOVAB	W^VT100_DAT,R0		; ADDRESS DATA TABLE
	BBSS	#TT2$V_AVO,W^MASK2,SET_TYPE; SET THE AVO BIT
	BRB	SET_TYPE
VT05:	.WORD	0			;
	MOVAB	W^VT05_DAT,R0		; ADDRESS DATA TABLE
	MOVB	#3,W^QIO+41		; SET FILL COUNT
	BRB	SET_TYPE
LA120:	.WORD	0
	MOVAB	W^LA120_DAT,R0		; ADDRESS DATA TABLE
	BRB	SET_TYPE		; SET UP THE TYPE
FT:	.WORD	0			;
	MOVL	4(AP),R0		; GET QUALIFIER DESC ADDRESS
	MOVZBL	CLI$B_QDCODE(R0),R0	; GET QUALIFIER NUMBER
	SUBB	#CLI$K_STTT_FT1,R0	; COMPUTE FT # IN BINARY
	ADDB3	#TT$_FT1,R0,W^TERMTYPE	; SET TYPE ONLY
	RET				;
;
; SUBROUTINE TO SET UP TYPE FIELDS
;
SET_TYPE:
	MNEGL	#1,R2			;SET R2 TO -1 FOR STARTERS

INQ_SET:
	
	MOVB	(R0)+,W^TERMTYPE	; INSERT TYPE
	CMPB	W^TERMTYPE,#TT$_UNKNOWN	;IS THIS UNKNOWN
	BEQL	5$			;THEN HANDLE SPECAILY
	TSTW	1(R0)			;IS THERE A WIDTH?
	BEQL	10$			;NO THEN DON'T CONTINUE ON
	MOVB	(R0)+,W^PAGESIZ		; INSERT PAGE SIZE
	MOVW	(R0)+,W^WIDTH		; INSERT PAGE WIDTH
	BISL3	(R0)+,#<TT$M_CRFILL-
		!TT$M_LFFILL-
		!TT$M_SCOPE-
		!TT$M_HOLDSCREEN-
		!TT$M_HOSTSYNC-
		!TT$M_EIGHTBIT-
		!TT$M_READSYNC-
		!TT$M_NOTYPEAHD-
		!TT$M_MECHTAB-
		!TT$M_TTSYNC-
		!TT$M_WRAP-
		!TT$M_MECHFORM-
		!^XFF000000-		; LEAVE PAGESIZ ENABLED
		>,W^ENABLE		; DECLARE CHANGE BITS
	MOVB	W^MASK+3,R1		; SAVE PAGESIZ WHILE SETTING BITS
	BISL3	(R0)+,#<TT$M_WRAP!TT$M_TTSYNC>,W^MASK;
	MOVB	R1,W^MASK+3		; RESTORE PAGESIZ
7$:	BICL2	(R0),W^MASK2		;CLEAR THE BITS THAT WANT TO BE CLEARED
	BISL2	(R0)+,W^ENABLE2		; DECLARE CHANGE BITS
	BISL2	(R0),W^MASK2		; BITS TO SET
	TSTL	R2			; DO THEY WANT AVO TAMPERED WITH
	BLSS	10$			; NO THEN DON'T WORRIE ABOUT IT
	BBSS	#TT2$V_AVO,W^ENABLE2,8$	;ENABLE THIS BIT
8$:	BBCC	#TT2$V_AVO,W^MASK2,9$	;NO THEN CLEAR IT
9$:	BLBS	R2,10$			;SHOULD WE USE OUR AVO BIT
	BBSS	#TT2$V_AVO,W^MASK2,10$	;YES THEN SET IT
10$:	RET				; RETURN

5$:	ADDL3	#1+2+4+4,R0,R0		;MOVE R0 OVER IRRELIVENT INFO
	BRB	7$


	.SBTTL	VALUE ACTION ROUTINES
;
; SUBROUTINE TO GET THE NUMERIC VALUE OF A QUALIFIER
;
GET_VALUE:				;
	CLRL	R0			;
	MOVL	4(AP),R1		; ADDRESS QUALIFIER DESC
	TSTW	CLI$W_QDVALSIZ(R1)	; VALUE PRESENT?
	BEQL	20$			; ASSUME 0
	CALLBAK	W^NUM_VAL,(R1)		; GET THE VALUE
	MOVL	W^CLI$L_RQVALU+NUM_VAL,R0; GET THE VALUE
	TSTW	W^CLI$L_RQVALU+NUM_VAL+2; IN RANGE?
	BNEQ	BADPARAM		; IF NEQ THEN NO
20$:	RSB				;
;
; BAD PARAMETER EXIT
;
BADPARAM:
	MOVZWL	#SS$_BADPARAM,W^SET$L_STATUS
	RET
;
; ACTION ROUTINE FOR CR FILL
;
CRFI:	.WORD	0
	BSBW	GET_VALUE		; GET THE VALUE
	BITW	#^X0FF00,R0		; LEGAL SIZE?
	BNEQ	BADPARAM
	MOVB	R0,W^QIO+40		; SET THE VALUE
	BEQL	20$			; IF EQL THEN SHUT OFF
	BISW	#TT$M_CRFILL,W^MASK	;
20$:	BISW	#TT$M_CRFILL,W^ENABLE	; SET THE MASK BIT
	RET
;
; ACTION ROUTINE FOR LF FILL
;
LFFI:	.WORD	0
	BSBW	GET_VALUE		; GET THE VALUE
	BITW	#^X0FF00,R0		; IN RANGE?
	BNEQ	BADPARAM
	MOVB	R0,W^QIO+41		; SET THE VALUE
	BEQL	20$			; IF EQL THEN SHUT OFF
	BISW	#TT$M_LFFILL,W^MASK	;
20$:	BISW	#TT$M_LFFILL,W^ENABLE	; SET THE MASK BIT
	RET
;
; ACTION ROUTINE FOR PAGE
;
PAGE:	.WORD	0
	BSBW	GET_VALUE		; GET THE VALUE
	BITW	#^X0FF00,R0		; IN RANGE?
	BNEQ	BADPARAM
	MOVB	R0,W^PAGESIZ		; SET THE VALUE
20$:	RET
;
; ACTION ROUTINE FOR WIDTH
;
WIDT:	.WORD	0
	BSBW	GET_VALUE		; GET THE VALUE
	BITW	#^XFE00,R0		; MAX. WIDTH OF 511
	BNEQ	BADPARAM		; EXIT IF ILLEGAL
	MOVW	R0,W^WIDTH		; SET THE VALUE
	MNEGB	#1,W^WIDCHG		; WIDTH CHANGED
20$:	RET
;
; ACTION ROUTINE FOR SPEED
;
SPEE:	.WORD	^M<R1,R2,R3>
	CMPL	#IO$_SETCHAR,W^QIO+12	; WAS THIS A /PERM?
	BNEQ	5$			;NO THEN DON'T WORRIE ABOUT IT
	BBSS	#TT2$V_AUTOBAUD,W^ENABLE2,2$
2$:	BBCC	#TT2$V_AUTOBAUD,W^MASK2,5$
5$:	BSBW	GET_VALUE		; GET THE VALUE
	BSBB	50$			; GET BIT VALUE
	MOVZBW	R1,W^IN_SPEED
	MOVAB	W^NUM_VAL,R0
	BBC	#CLI$V_MOREVALS,CLI$B_RQSTAT(R0),10$
	BSBW	GET_VALUE
	BSBB	50$
	MOVB	W^IN_SPEED,R0
	MOVB	R1,W^IN_SPEED
	MOVB	R0,W^OUT_SPEED
10$:	MOVZWL	W^IN_SPEED,W^QIO+36
	MOVZBL	#1,R0
	RET

50$:	CLRL	R1
60$:	TSTW	W^SPEED[R1]
	BEQL	70$
	CMPW	W^SPEED[R1],R0
	BEQL	80$
	AOBLEQ	#16,R1,60$
70$:	BRW	BADPARAM
80$:	INCL	R1
	RSB

;
; TERMINAL TYPE ACTION ROUTINE
;
.ENTRY	TYPE,^M<R2,R3,R4,R5,R6,R7>
	PUSHL	4(AP)			;GET THE ADDRESS OF THE QUALIFIER DESCRIPTOR
	PUSHAB	W^SET$A_CLIWORK		;THE COMMAND INTERPRETER WORK AREA
	PUSHAB	W^ASCII_VAL		;GET AN ASCII VALUE
	CALLS	#3,@CLI$A_UTILSERV(AP)	;GET THE VALUE
	PUSHAL	W^FOUND_KEY		;THE KEY THAT WAS FOUND
	PUSHAB	W^TYPDEFTAB		;AND THE ADDRESS OF THE TABLE
	PUSHAQ	W^ASCII_VAL+CLI$Q_RQDESC; THE ADDRESS OF THE DESCRIPTOR
	CALLS	#3,G^LIB$LOOKUP_KEY	;MATCH A KEY WORD
	BLBS	R0,20$			; NO TROUBLE THEN DO THE WORK
	PUSHAQ	W^ASCII_VAL+CLI$Q_RQDESC; GIVE HIM THE WORD
	PUSHL	#1			;ONLY 1 FAO ARG
	PUSHL	R0			;AND THE MESSAGE
	CALLS	#3,G^LIB$SIGNAL		;AND TELL THE USER OF HIS TROUBLE
4$:	MOVL	R0,W^SET$L_STATUS	; CHANGE TO AMBIGUOUS IF NECESSARY
10$:	RET

20$:	MOVL	W^FOUND_KEY,R0		;GET THE ADDRESS OF THE BLOCK
30$:	BRW	SET_TYPE


	.SBTTL	Inquire what terminal type is available
;
; Description:
;
;	Will Inquire From the terminal an answer back sequence
; this sequence will be interpreted to get the terminal type to
; set with the options that are available.
;
; Inputs:
;
;	None
;
.ENTRY	INQU,^M<R2,R3,R4,R5>

	MNEGL	#1,R2			;TELL THEM TO IGNORE AVO NORMALY
	CLRL	R5			;START A COUNTER OF ASK SEQUENCES
	MOVW	#<SS$_DEVREQERR&^cSTS$M_SEVERITY>!STS$K_WARNING,W^SET$L_STATUS; SET AN INVALID STATUS

20$:	MOVL	W^DESTAB[R5],R0		;GET THE LENGTH
	MOVZWL	R0,R0			;...
	$QIOW_S	CHAN=W^QIO+8,-		;TRY TO GET A RESPONSE
		FUNC=#IO$_READPROMPT!IO$M_TIMED!IO$M_PURGE!IO$M_ESCAPE,-; PURGE TYPEAHEAD
		IOSB=W^IOSTATUS,-	;THE I/O STATUS
		P1=W^RECSEQ,-		;AND WAIT WITH A PROMPT
		P2=#RECSEQLEN,-		;INTO THE RECSEQ BUFFER
		P3=#4,-			;2 SECONDS TO WAIT
		P5=W^DESTAB+4[R5],-	;THE PROMPT STRING LOCATION
		P6=R0			;AND THE LENGTH OF THE PROMPT STRING
	BLBS	R0,24$			; DID WE GET AN ERROR
	MOVL	R0,W^SET$L_STATUS	; YES THEN RETURN IT
	RET				; ...

24$:	CMPW	W^IOSTATUS,#SS$_TIMEOUT	;DID IT TIME OUT?
	BEQL	30$			;YES THEN MOVE TO THE NEXT PROMPT STRING
	BLBS	W^IOSTATUS,25$		;WAS THIS OK ANYWAY
	MOVL	W^IOSTATUS,W^SET$L_STATUS;NO THEN GIVE IT ERRORS
	RET

25$:	LOCC	#^A/;/,W^IOSTATUS+6,W^RECSEQ; FIND A SEMICOLIN IF THERE IS ONE
	SUBW3	R0,W^IOSTATUS+6,W^RECDES;GET THE LENGTH TO COMPARE
	TSTL	R0			;CHECK OUT R0
	BNEQ	50$			;NOT ZERO THEN DESIFER OPTIONS LIST
	MOVL	W^RECDES,R1		;GET THE COUNT INTO R1
	DECL	R1			;SUBTRACT 1 FROM IT
	CMPB	#^A/c/,W^RECSEQ(R1)	;CHECK THE LAST CHAR FOR A "c"
	BNEQ	27$			;NO THEN CONTINUE WITH THE NORMAL SEQUENCE
	MOVB	#^A/;/,W^RECSEQ(R1)	;AND CHANGE THE LAST CHARACTER TO A ";"


27$:	PUSHAQ	W^RECDES		;THE STRING DESCRIPTOR TO COMPARE
	PUSHAL	W^TYPRESTAB		;AND THE STRING TABLE TO LOOK AT
	CALLS	#2,LIB$MATCHKEY		;AND TRY TO MATCH THE KEYWORD
	TSTL	R0			;CHECK IF WE KNOW THIS ONE
	BLEQ	30$			;NO THEN IT IS UNKNOWN
	MOVL	W^TYPRESTRN-4[R0],R0	;ELSE WE KNOW IT
	MOVL	#SS$_NORMAL,W^SET$L_STATUS
	BRW	INQ_SET			;AND WE CAN SET IT

30$:	ADDL2	#2,R5			;INCREMENT OUR COUNTER
	TSTL	W^DESTAB[R5]		;CHECK IF WE HAVE SOMETHING TO COUNT
	BEQL	40$
	BRW	20$			; YES THEN TRY SOME MORE
40$:	RET				;NO - WE DON'T KNOW IT THEN

50$:	MOVL	W^RECDES,R1		;GET THE CURRENT POSITION
	CMPB	#^A/?/,RECSEQ-2(R1)	; MAKE SURE IT IS JUST A 5
	BNEQ	51$
	CMPB	#^A/5/,RECSEQ-1(R1)	;IS THIS A VT100J OR A VK100
	BNEQ	51$			;NO THEN HANDLE NORMALY

	MOVAL	VK100_DAT,R0		;SET UP AS A VK100
	CMPB	#^A/2/,RECSEQ+1(R1)	;BUT IT COULD BE A VT100J
	BNEQ	52$			;NO THAN LEAVE IT ALONE
	MOVAL	VT100_DAT,R0		;ELSE MAKE IT A VK100J
	CLRL	R2			;WITH AVO
52$:	MOVL	#SS$_NORMAL,W^SET$L_STATUS
	BRW	INQ_SET			;THEN GO AND MAKE THE CHANGES

51$:	INCL	W^RECDES		;INCREASE IT BY 1 TO INCLUDE THE ";"
	MOVL	W^RECDES,R1		;GET THE COUNTER
	MOVL	#1,R2			;SET R2 TO INDICATE NOAVO
	BBSS	#TT2$V_AVO,W^ENABLE2,55$; RESET AVO
55$:	BBC	#1,W^RECSEQ(R1),60$	;DO WE HAVE AVO?
	CLRL	R2			;YES THEN LET AVO WORK
60$:	BRW	27$			;NOW RETURN

	.ENABL	LSB
;
; PARITY OR NO PARITY
;
NOPARI:	.WORD	0			;
	BRB	10$			;
PARI:	.WORD	0			; SET PARITY
	BISW	#TT$M_PARITY,W^QIO+44	; ENABLE PARITY
	MOVL	4(AP),R0		; GET QUALIFIER
	TSTW	CLI$W_QDVALSIZ(R0)	; VALUE PRESENT?
	BEQL	10$			; IF NO THEN ASSUME EVEN
	CALLBAK	W^ASCII_VAL,(R0)	; GET THE VALUE
	CMPB	#^A/O/,@W^CLI$Q_RQDESC+ASCII_VAL+4; ODD?
	BNEQ	10$			; IF NEQ THEN NO
	BISW	#TT$M_ODD,W^QIO+44	; SET ODD PARITY
10$:	
	BISW	#TT$M_ALTRPAR,W^QIO+44	; SET UP PARITY CHANGE
	RET
 
; 
	.END
