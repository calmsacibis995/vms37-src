	.TITLE	TYPE - CLI TYPE COMMAND PROCESSOR
	.IDENT	'V03-002'
	.DEFAULT DISPLACEMENT,WORD

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET CLI UTILITIES
;
; ABSTRACT:	USER INTERFACE PROGRAM
;
;
; ENVIRONMENT:	NATIVE MODE USER CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 2-MAY-1977
;
; MODIFIED BY:
;
;	V03-002	SHZ0002		Stephen H. Zalewski,	25-Mar-1982  13:23
;		Fixed error path from $CONNECT so STS (completion status
;		code) is picked up from the RAB instead of the FAB.
;
;	V03-001	SHZ0001		Stephen H. Zalewski,	25-Mar-1982  12:43
;		Prevent TYPE from producing an endless stream of error messages
;		when $PUT to output file fails.
;
;	V003	TMH0003		Tim Halvorsen	02-Jan-1982
;		Fix bug in TMH0002 which didn't quite output filespec
;		headers correctly for FTN files.
;
;	V002	TMH0002		Tim Halvorsen	02-Jan-1982
;		Print filespec header with the correct carriage
;		control for FTN and PRN format output files, to
;		prevent garbage header lines from being output.
;		Do not terminate copy loop on CTRL/O, thus allowing
;		a user to toggle CTRL/O on slow output devices.
;		Fix bug which caused the output file to be re-created
;		on each input file.
;
;	V001	TMH0001		Tim Halvorsen	12-Feb-1981
;		Fix error detection after $CONNECTs to input and
;		output files.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	CLI_SUBSYS = 3@16		; CLI SUBSYSTEM CODE
	TYP_MASK   = ^M<R2,R3,R11>	; STANDARD ENTRY MASK
	$CLIDEF				; CLI DEFINITIONS
	$STSDEF				; STATUS WORD DEFINITIONS
	$RABDEF				; RMS RAB DEFINITIONS
	$FABDEF				; RMS FAB DEFINITIONS
	$NAMDEF				; RMS NAME BLOCK DEFINITIONS
	$SHRDEF				; SHARED MESSAGES
	$CLIMSGDEF			; CLI MESSAGES
	.LIST	MEB
	TYPCTXBLK			; DEFINE CONTEXT BLCOK VALUES
	.NLIST	MEB
;
;
; OWN STORAGE:
;
 
	PURE_SECTION
 
TYPNAM:	.ASCID	'TYPE'
OUTFNM:	.ASCII	\SYS$OUTPUT\
	OUTSIZ=.-OUTFNM

	.SBTTL	TYPE - TYPE FILE UTILITY
;++
; FUNCTIONAL DESCRIPTION:
; 
;	TYPE A FILE UTILITY COMMAND IMAGE
; 
; CALLING SEQUENCE:
; 
;	ENTERED FROM CLI VIA A CALL INSTRUCTION
; 
; INPUT PARAMETERS:
; 
;	NONE
; 
; IMPLICIT OUTPUTS:
; 
;	THE INPUT FILE IS COPIED TO THE OUTPUT FILE WHICH
;	MAY GET CREATED.
; 
; COMPLETION CODES:
; 
;	RETURN STATUS INDICATES SUCESS OR FAILURE OF OPERATION
; 
;--

	.ENTRY	TYPE_FILE,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R11>

	MOVAB	TYP$CTXBLK,R11		; SET ADDRESS OF CONTEXT BLOCK
	MOVL	#1,TYP_L_STATUS(R11)	; SET INITIAL STATUS
	MOVAB	TYP_INITPRS,R0		; REQUEST DESCRIPTOR
	BSBW	CALBAK			; DO CALLBACK
	MOVAB	TYP_GETCMD,R0		; NOW ASK FOR COMMAND LINE DESCRIPTION
	BSBW	CALBAK			; DO CALL BACK
	MOVAB	TYP_OUTRAB,R7		; AND OUTPUT RAB
	MOVL	RAB$L_FAB(R7),R6	; SET OUTPUT FAB
	MOVAB	TYP_INPRAB,R9		; ETC
	MOVL	RAB$L_FAB(R9),R8	; ETC,ETC
;
;	LOOP THROUGH EACH FILE SPECIFICATION IN PARAMETER LIST
;
10$:	MOVAB	OUTFNM,FAB$L_FNA(R6)	; ASSUME DEFAULT NAME
	MOVB	#OUTSIZ,FAB$B_FNS(R6)	; AND DEFAULT NAME SIZE
	MOVAB	TYP_OUTDESC,R0		; REQUEST DESCRIPTOR
	BSBW	CALBAK			; ISSUE RESULT PARSE CALL BACK
	MOVAB	TYP_INPDESC,R0		; REQUEST DESCRIPTOR
	MOVL	R0,R5			; SAVE A COPY
	BSBW	CALBAK			; REQUEST RESULT PARSE
	CVTWB	CLI$W_RQSIZE(R5),-	; SET NAME SIZE FIELD
		FAB$B_FNS(R8)		; RETURNED FROM CLI
	MOVL	CLI$A_RQADDR(R5),-	; LIKEWISE FOR THE ADDRESS
		FAB$L_FNA(R8)		; OF INPUT FILE NAME
	MOVB	#FAB$M_CR,FAB$B_RAT(R8)	; SET RECORD ATTRIBUTES INCASE TT INPUT
	CLRL	-(SP)			; NO DIRECTORY ACTION ROUTINE
	PUSHAB	INP_OPN_ERR		; OPEN ERROR ACTION ROUTINE
	PUSHAB	B^DO_FILE		; FILE OPEN ROUTINE ADDRESS
	PUSHL	R8			; ADDRESS OF FAB BLOCK
	CALLS	#4,G^FMG$FILE_SCAN	; SCAN ALL FILES
	BRB	10$			; NEXT FILES OR DONE

;
;	PROCESS AN INDIVIDUAL FILE
;

DO_FILE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R11> ;
	MOVAB	TYP$CTXBLK,R11		; SET ADDRESS OF CONTEXT BLOCK
	MOVAB	TYP_OUTRAB,R7		; AND OUTPUT RAB
	MOVL	RAB$L_FAB(R7),R6	; SET OUTPUT FAB
	MOVAB	TYP_INPRAB,R9		; ETC
	MOVL	RAB$L_FAB(R9),R8	; ETC,ETC
;
; OPEN AND CONNECT TO THE INPUT FILE
;
	$OPEN	(R8),ERR=INP_OPN_ERR	; OPEN THE INPUT FILE
	BLBS	R0,25$			; CONTINUE IF OK
	RET				; SKIP FILE IF OPEN ERROR
25$:	$CONNECT  (R9),ERR=INP_CON_ERR	; CONNECT TO INPUT STREAM
	BLBS	R0,28$			; BRANCH IF OK
	BRW	53$			; SKIP FILE IF CONNECT ERROR
;
; CAUSE CTRL/O TO BE CANCELED AT THE START OF EACH NEW FILE.
;
28$:	SETBIT	RAB$V_CCO,RAB$L_ROP(R7)	; CANCEL CONTROL O ON FIRST PUT
;
; OPEN AND CONNECT TO THE OUTPUT FILE (IF NOT ALREADY OPEN) WITH THE
; CHARACTERISTICS OF THE INPUT FILE.
;
	TSTW	FAB$W_IFI(R6)		; IS FILE ALREADY OPEN?
	BNEQ	45$			; BR IF YES - DON'T OPEN AGAIN
	ASSUME	FAB$B_RAT+1 EQ FAB$B_RFM ; CHECK FOR ADJACENT BYTES
	MOVW	FAB$B_RAT(R8),FAB$B_RAT(R6) ; SET RAT&RFM FOR OUT SAME IS INPUT
	MOVW	FAB$W_MRS(R8),FAB$W_MRS(R6) ; SET MAXIMUM RECORD SIZE FOR INPUT
	MOVB	FAB$B_FSZ(R8),R0	; GET SIZE OF SIZE CONTROL
	CMPB	R0,#20			; CHECK IF ITS TOO BIG
	BLEQ	30$			; BR IF NO
	CLRL	R0			; ELSE FORGET IT
30$:	MOVB	R0,FAB$B_FSZ(R6)	; SET VALUE INTO OUTPUT FAB
	CLRB	NAM$B_ESL+TYP_OUTNAM	; ZERO EXPANDED NAME LENGTH
	$CREATE	(R6),ERR=OUT_OPN_ERR	; CREATE OUTPUT FILE
	BLBS	R0,40$			; BR IF NO ERROR
35$:	BRW	EXIT0			; TERMINATE THE EXECUTION
40$:	$CONNECT  (R7),ERR=OUT_CON_ERR	; CONNECT TO OUTPUT STREAM
	BLBC	R0,35$			; TERMINATE EXECUTION IF ERROR
;
; PRINT A HEADER LINE IN THE OUTPUT FILE, CONSISTING OF THE FILESPEC
; AND A BLANK LINE.
;
45$:	MOVL	FAB$L_NAM(R8),R3	; GET INPUT NAME BLOCK
	BBC	#NAM$V_WILDCARD,NAM$L_FNB(R3),50$ ; BR IF NO WILD CARDS SEEN
	BSBB	BLANK			; PRINT A SPACE LINE
	MOVL	NAM$L_RSA(R3),RAB$L_RBF(R7) ; SET RESULTANT NAME AS RECORD ADR
	MOVZBW	NAM$B_RSL(R3),RAB$W_RSZ(R7) ; AND THE LENGTH OF THAT
	BSBB	WRITE			; PRINT FILE NAME
	BSBB	BLANK			; PRINT A NULL LINE
;
; COPY THE CONTENTS OF THE INPUT FILE TO THE OUTPUT FILE,
; ONE RECORD AT A TIME.
;
50$:	$GET	(R9),ERR=GET_ERR	; READ A RECORD
	BLBC	R0,53$			; BR IF ERROR DETECTED
	MOVL	RAB$L_RBF(R9),-		; COPY BUFFER ADDRESS FOR THE GET
		RAB$L_RBF(R7)		; AS RECORD BUFFER FOR PUT
	MOVW	RAB$W_RSZ(R9),-		; ALSO COPY RESULTANT SIZE OF READ
		RAB$W_RSZ(R7)		; TO RECORD TO TYPE
	BSBB	PUT			; PRINT RECORD
	CLRBIT	RAB$V_CCO,RAB$L_ROP(R7)	; CANCEL CONTROL O ON FIRST PUT ONLY
	BRB	50$			; LOOP UNTIL EOF
53$:	$CLOSE	(R8),ERR=INP_CLS_ERR	; CLOSE THE INPUT FILE
	RET				; RETURN FOR NEXT FILE

;
; SUBROUTINES USED TO PRINT A HEADER LINE (BLANK OR OTHERWISE)
;

BLANK:	CLRW	RAB$W_RSZ(R7)		; SETUP TO OUTPUT NULL LINE

WRITE:	BBS	#FAB$V_FTN,FAB$B_RAT(R6),FTN ; BRANCH IF FTN FORMAT FILE
	BBC	#FAB$V_PRN,FAB$B_RAT(R6),PUT ; BRANCH IF NOT PRN FORMAT
	MOVW	#^X8D01,@RAB$L_RHB(R7)	; SET SINGLE SPACE PRN CARRIAGE CONTROL
PUT:	$PUT	(R7),ERR=TYP_ERR	; PRINT LINE
	BLBC	R0,55$			; BR IF ERROR DETECTED
	RSB				;
55$:	$CLOSE	(R6)			; CLOSE THE OUTPUT FILE
	MOVL	TYP_L_STATUS(R11),R0	; RETURN $PUT ERROR STATUS
	RET

FTN:	PUSHR	#^M<R2,R3,R4,R5,R6>	; SAVE REGISTERS
	MOVZWL	RAB$W_RSZ(R7),R6	; GET SIZE OF OUTPUT BUFFER
	SUBL	R6,SP			; ALLOCATE BUFFER ON STACK
	MOVB	#^A' ',-(SP)		; MAKE SINGLE SPACE CARRIAGE CONTROL
	MOVC3	R6,@RAB$L_RBF(R7),1(SP)	; COPY INTO SCRATCH BUFFER
	INCW	RAB$W_RSZ(R7)		; COMPUTE LENGTH OF REAL OUTPUT RECORD
	MOVL	SP,RAB$L_RBF(R7)	; SET ADDRESS OF REAL OUTPUT RECORD
	BSBB	PUT			; WRITE THE RECORD
	MOVAB	1(SP)[R6],SP		; DEALLOCATE SCRATCH BUFFER
	POPR	#^M<R2,R3,R4,R5,R6>	; RESTORE REGISTERS
	RSB

;
;	COME HERE WHEN NO MORE FILES TO TYPE
;

TYP_DONE::				; NO MORE INPUT TO PROCESS
	.WORD	0
	MOVAB	TYP_PARSDON,R0		; REQUEST DESCRIPTOR
	BSBB	CALBAK			; REQUEST PARSE TERMINATION
	MOVAB	TYP_OUTRAB,R0		; AND OUTPUT RAB
	MOVL	RAB$L_FAB(R0),R0	; SET OUTPUT FAB
	TSTW	FAB$W_IFI(R0)		; OUTPUT FILE OPEN?
	BEQL	EXIT0			; IF NOT, DON'T ATTEMPT TO CLOSE IT
	$CLOSE	(R0),ERR=OUT_CLS_ERR	; CLOSE THE OUTPUT FILE
EXIT0:	$EXIT_S	TYP_L_STATUS(R11)	; EXIT WITH STATUS 

	.SBTTL	CLI CALL BACK SUBROUTINES
;
; LOCAL SUBROUTINE TO ISSUE CALL BACK TO CLI
;
; INPUT:	R0 IS THE ADDRESS OF THE REQUEST DESCRIPTOR
; OUTPUT:	THE CALL BACK IS ISSUED, AND CONTROL IS RETURN TO CALLER
;
CALBAK: PUSHAB	TYP_BITMAP		; LAST ARGUMENT IN CALL BACK
	PUSHAB	TYP_CLIWRK		; WORK AREA IS ALWAYS SECOND
	PUSHAB	(R0)			; REQUEST DESCRIPTOR IS ALWAYS FIRST
	CALLS	#3,G^SYS$CLI		; GO TO UTILITY SERVICE ROUTINE
	RSB

	.SBTTL	ACTION ROUTINE TO HANDLE OUTPUT FILESPEC
;
; EXPLICIT OUTPUT FILE ACTION
;
 
TYP_OUTPUT::				; AN EXPLICIT OUTPUT GIVEN
	.WORD	0			; REGISTER SAVE MASK
	MOVL	4(AP),R1		; GET OUTPUT FILE REQUEST DESCRIPTOR
	CVTWB	CLI$W_RQSIZE(R1),-	; RESULTANT NAME SIZE
		TYP_OUTFAB+FAB$B_FNS	; IN OUTPUT FAB
	MOVL	CLI$A_RQADDR(R1),-	; SET ADDRESS OF USER SUPPLIED INPUT
		TYP_OUTFAB+FAB$L_FNA	; FILENAME IN FAB FILENAME ADDRSS LOC
	RET				; USE THAT NAME WHEN OPEN HAPPENS

	.SBTTL	ERROR ACTION ROUINES
;+
; TYP$CMDERR - COMMAND PARSE ERROR
;
; ENTER HERE FOR THE RESULT PARSE ERROR ACTION TO PRINT A MESSAGE
; CONCERNING AN ERROR PARSING THE COMMAND
;
; INPUTS:
;
;	4(AP) = ADDRESS OF REQUEST DESCRIPTOR WITH ERROR SEGMENT
;	8(AP) = ERROR CODE
;
; OUTPUTS:
;
;	THE ERROR IS PRINTED AND CONTROL IS RETURNED TO THE
;	ORIGINAL CALLER.
;-
TYP$CMDERR::				;
	.WORD	^M<R2,R3>		; ENTRY MASK
	MOVL	8(AP),R0		; GET ERROR CODE
	ADDL3	#CLI$W_RQSIZE+4,4(AP),R1 ; POINT A DESCRIPTOR FOR BAD SEGMENT
	PUSHL	(R1)			; PUSH ADDRESS OF START OF ERROR SEGMENT
	ADDL	-(R1),(SP)		; FIND END OF ERROR SEGMENT
	ADDL3	TYP_GETCMD+CLI$W_RQSIZE,- ; FIND THE END OF THE
		TYP_GETCMD+CLI$W_RQSIZE+4,-(SP) ; THE ENTIRE COMMAND
	SUBL	4(SP),(SP)		; NOW THE LENGTH OF THE COMMAND
	CMPL	(SP),#80		; IS LINE TOO LONG
	BLEQU	10$			; BR IF NO
	MOVZBL	#80,(SP)		; SET REASONABLE VALUE
10$:	PUSHAQ	(SP)			; ADDRESS OF THAT DESCRIPTOR
	PUSHL	R1			; ADDRESS OF ERROR SEGMENT
	PUSHL	#2			; NUMBER OF FAO ARGUMENTS
	PUSHL	#CLI$_BADTEXT		; THE ERROR
	CLRL	-(SP)			; ZERO FAO ARG COUNT
	PUSHL	R0			; PUSH ERROR CODE
	PUSHL	#6			; TOTAL NUMBER OF ARGS IN BLOCK
	BRW	SHOW_MSG		; PRINT THE ERROR

;+
; GET_ERR     - ERROR READING FILE
; TYP_ERR     - ERROR WRITING FILE
; INP_OPN_ERR - INPUT FILE OPEN ERROR
; OUT_OPN_ERR - OUTPUT FILE OPEN ERROR
; INP_CON_ERR - INPUT CONNECT ERROR
; OUT_CON_ERR - OUTPUT CONNECT ERROR
; INP_CLS_ERR - INPUT FILE CLOSE ERROR
; OUT_CLS_ERR - OUTPUT CLOSE ERROR
;
; THESE ROUTINES IS ENTERED WHEN AN ERROR IS DETECTED ON A FILE.
; A MESSAGE IS PRINTED AND RETURN IS MADE TO THE ORIGINAL CALLER.
;
; INPUTS:
;
;	4(AP) = ADDRESS OF THE FAB/RAB FOR WHICH ERROR OCCURRED
;
;-
GET_ERR:.WORD	TYP_MASK		;
	BSBB	RABERR			; PROCESS ERROR ON A RAB
	.LONG	SHR$_READERR!CLI_SUBSYS ; ERROR CODE
 
TYP_ERR:.WORD	TYP_MASK		;
	BSBB	RABERR			; PROCESS ERROR
	.LONG	SHR$_WRITEERR!CLI_SUBSYS;
 
RABERR:	MOVL	4(AP),R1		; GET THE RAB
	MOVL	RAB$L_FAB(R1),R0	; AND THE FAB
	MOVQ	RAB$L_STS(R1),FAB$L_STS(R0) ; PUT ERROR IN COMMON PLACE
	BRB	FILERR			; COMMON FILE ERROR
 
INP_OPN_ERR:				; ERROR OPENING INPUT FILE
	.WORD	TYP_MASK		; REGISTER SAVE MASK
	BSBB	FABERR			; ERROR ROUTINE
	.LONG	SHR$_OPENIN!CLI_SUBSYS	; ERROR CODE
 
OUT_OPN_ERR:				; ERROR OPENING INPUT FILE
	.WORD	TYP_MASK		; REGISTER SAVE MASK
	BSBB	FABERR			; ERROR ROUTINE
	.LONG	SHR$_OPENOUT!CLI_SUBSYS	; ERROR CODE

INP_CON_ERR:				; ERROR CONNECTING TO INPUT FILE
	.WORD	TYP_MASK		; REGISTER SAVE MASK
	BSBB	RABERR			; ERROR ROUTINE
	.LONG	SHR$_OPENIN!CLI_SUBSYS	; ERROR CODE
 
OUT_CON_ERR:				; ERROR CONNECTING TO OUTPUT FILE
	.WORD	TYP_MASK		; REGISTER SAVE MASK
	BSBB	RABERR			; ERROR ROUTINE
	.LONG	SHR$_OPENOUT!CLI_SUBSYS	; ERROR CODE
 
INP_CLS_ERR:				; ERROR CLOSING INPUT FILE
	.WORD	TYP_MASK		; REGISTER SAVE MASK
	BSBB	FABERR			; ERROR ROUTINE
	.LONG	SHR$_CLOSEIN!CLI_SUBSYS	; ERROR CODE
 
OUT_CLS_ERR:				; ERROR CLOSEING OUTPUT FILE
	.WORD	TYP_MASK		; REGISTER SAVE MASK
	BSBB	FABERR			; ERROR ROUTINE
	.LONG	SHR$_CLOSEOUT!CLI_SUBSYS ; ERROR CODE
 
FABERR:	MOVL	4(AP),R0		; GET THE FAB
FILERR:	MOVL	FAB$L_NAM(R0),R1	; GET NAME BLOCK ADDRESS
	MOVL	NAM$L_RSA(R1),R3	; SET RESULTANT STRING ADDRESS
	MOVZBL	NAM$B_RSL(R1),R2	; AND LENGTH
	BNEQ	10$			; BR IF RESULTANT NAME FORMED
	MOVL	NAM$L_ESA(R1),R3	; ADDRESS OF EXPANDED STRING
	MOVZBL	NAM$B_ESL(R1),R2	; NOW ITS LENGTH
	BNEQ	10$			; BR IF EXPANDED STRING FORMED
	MOVL	FAB$L_FNA(R0),R3	; SET INPUT FILE NAME
	MOVB	FAB$B_FNS(R0),R2	; AND SIZE FOR MESSAGE
10$:	MOVL	@(SP)+,R1		; GET THE ERROR CODE
	PUSHR	#^M<R2,R3>		; PUSH DESCRIPTOR FOR FILE NAME
	ASSUME	FAB$L_STV EQ FAB$L_STS+4
	MOVQ	FAB$L_STS(R0),-(SP)	; PUSH RMS ERROR CODES
	CMPW	#<RMS$_NMF&^XFFFF>,(SP)	; END OF WILD CARD SEQUENCE?
	BEQL	EXTERR			; BR IF YES
	CMPW	#<RMS$_EOF&^XFFFF>,(SP)	; IS ERROR END-OF-FILE
	BEQL	EXTERR			; BR IF YES - NO MESSAGE NEEDED
	PUSHAQ	8(SP)			; ADDRESS OF NAME DESCRIPTOR
	PUSHL	#1			; NUMBER OF ARGUMENTS
	PUSHL	R1			; MESSAGE CODE
	PUSHL	#5			; TOTAL SIZE OF THE MESSAGE PACKET
					; FALL INTO SHOW MESSAGE

	.SBTTL	SHOW MESSAGE
;+
; SHOW_MSG - DISPLAY A MESSAGE
;
; THIS ROUTINE IS ENTERED VIA A BR/JMP TO DISPLAY AN ERROR MESSAGE
;
; INPUTS:
;	0(SP) = THE MESSAGE DESCRIPTOR SET FOR A CALL TO SYS$PUTMSG.
;-
 
SHOW_MSG:				; OUTPUT THE ERROR
	MOVAB	TYP$CTXBLK,R11		; SET CONTEXT BLK ADR TO NORMAL PLACE
	MOVL	4(SP),R0		; GET THE PRIMARY MESSAGE ID
	BLBS	R0,10$			; BR IF NOT AN ERROR
	BICL	#6,R0			; REDUCE ERROR TO WARINING
	MOVL	R0,TYP_L_STATUS(R11)	; SAVE MOST RECENT STATUS
10$:	PUSHAQ	TYPNAM			; PUSH ADDRESS OF FACILITY NAME
	CLRL	-(SP)			; ZERO ADDRESS OF ACTION ROUTINE
	PUSHAB	8(SP)			; PUSH ADDRESS OF MESSAGE BUFFER
	CALLS	#3,@#SYS$PUTMSG		; PRINT THE MESSAGE
	SETBIT	STS$V_INHIB_MSG,TYP_L_STATUS(R11) ; TELL CLI - NO MORE MESSAGES
	MOVL	TYP_L_STATUS(R11),R0	; PASS ERROR TO CALLER
EXTERR:	RET				;

 
	.END	TYPE_FILE
