	.TITLE	SHOW$PROCESS
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	DCL SHOW command.

;
; ABSTRACT:
;
;	This module implements the SHOW PROCESS command option.
;
; ENVIRONMENT:
;
;	Runs in user mode but requires privilege to change mode to kernel.
;
; AUTHOR : BEATRICE U. WALTHER,  CREATION DATE: 10-DEC-1977
;
; MODIFIED BY:
;
;	V03-001	GAS0061		Gerry Smith		16-Mar-1982
;		Remove privilege checks.  Also, display remaining quotas
;		rather than initial values in SHOW PROCESS/QUOTA.
;
;	V02-010	LJK0124		Lawrence J. Kenah	8-Feb-1982
;		Add support for /MEMORY qualifier for current process only.
;
;	V02-009	GAS0039		Gerry Smith		 2-Feb-1982
;		Fix display bug with SHOW PROC/SUB
;
;	V02-008	00002		Meg Dumont,		25-Jan-1982  17:05
;		Add GETJPI to check priviledges and existance when the /ID
;		qualifier is specified
;
;	V02-007	MMD0001		Meg Dumont,		18-Jan-1982  18:45
;		Added show process /continuous by making info callable from
;		show process.
;
;	V02-006	MIR0021		Michael I. Rosenblum	23-Aug-1981
;		Added the show process name will give info about the
;		given process.
;
;	V02-005	GWF0092		Gary Fowler		29-Jul-1981
;		Add ENQUE quota and SYSLCK privilege.
;
;	V02-004	GWF0002		Gary Fowler		2-Nov-1979
;		Modify to treat cpu limit as unsigned long word.  Output
;		"Infinite" if time limit is infinite.
;
;	V02-003	CNH0018		Chris Hume		12-Oct-1979	12:30
;		Added PRV$V_BYPASS and brought various privilege bit tables
;		up to date.  ([VMSLIB]STARDEF.MDL is already up to date.)
;		([UAF]UAFMAIN.B32 02.02, [CLIUTL]RUNDET.MAR 01.02,
;		[VMSLIB]SETPRIV.MAR 01.02)
;
;
;	V02-002	GWF0001		Gary Fowler		31-May-1979
;		Added PFNMAP, SHMEM, and SYSPRV to list of privileges.
;--

	.SBTTL	DECLARATIONS

;
; Include files:
;

	$CLIMSGDEF			; Define cli messages
	$JPIDEF				; define JPI item codes
	$PRVDEF				; define privilege bits
	$UCBDEF				; unit control block definitions
	$DDBDEF				; device data block definitions
	$MTLDEF				; mounted volume list definitions
	$PRDEF				; processor register definitions
	$PCBDEF				; process control block definitions
	$SHRDEF				; shared messages definitions

;
; Macros:
;

;+
; The $SHR_MESSAGES macro defines facility-specific message codes
;	which are based on the system-wide shared message codes.
;
;	$SHR_MESSAGES	name, code, <<msg,severity>, ... >
;
;	where:
;	    "name" is the name of the facility (e.g., COPY)
;	    "code" is the corresponding facility code (e.g., 103)
;	    "msg" is the name of the shared message (e.g., BEGIN)
;	    "severity" is the desired message severity (e.g., 1, 0, 2, 4)
;
;-
	.MACRO	$SHR_MESSAGES	NAME,CODE,MSGCODES
;
	.IF	NDF,SHR$K_SHRDEF  ; issue $SHRDEF if not done yet
		SHR$K_SHRDEF = 1 ; define symbol to indic $SHRDEF done
		$SHRDEF		 ; define shared message codes
	.ENDC
	.IRP	MSGPAIR, <'MSGCODES>
		$SHRMSG_COD 'NAME', 'CODE', MSGPAIR
	.ENDR
	.ENDM
	.MACRO	$SHRMSG_COD NAME, CODE, MSG, SEVERITY
;
	.IF	IDN,SEVERITY,WARNING    ; if WARNING, set 0 sev
	  'NAME'$_'MSG' = 0	        ; set 0 sev (WARNING)
	.IFF
	  .IF	IDN,SEVERITY,SUCCESS    ; if SUCCESS, set 1 sev
	    'NAME'$_'MSG' = 1	        ; set 1 sev (SUCCESS)
	  .IFF
	    .IF	IDN,SEVERITY,ERROR      ; if ERROR, set 2 sev
	      'NAME'$_'MSG' = 2	        ; set 2 sev (ERROR)
	    .IFF
	      .IF IDN,SEVERITY,INFO     ; if INFO, set 3 sev
	        'NAME'$_'MSG' = 3       ; set 3 sev (INFO)
	      .IFF
	        .IF IDN,SEVERITY,SEVERE ; if SEVERE, set 4 sev
	          'NAME'$_'MSG' = 4     ; set 4 sev (SEVERE)
	        .IFF
	          'NAME'$_'MSG' = 'SEVERITY ; set specified sev
	        .ENDC
	      .ENDC
	    .ENDC
	  .ENDC
	.ENDC
	 'NAME'$_'MSG' = 'NAME'$_'MSG'+SHR$_'MSG'+<'CODE'@16>
	.ENDM

;
; JPI_ITEM - 	Build data structure necessary to call the
;		$GETJPI system service.
;
;		The space for the resulting values is allocated at the
;		current location counter:
;			- a longword for a numeric value
;			- a qudword for a quadword
;			- a string descriptor pointing to a buffer in
;			  a separate PSECT for a string result.
;		Each call also generates the corresponding JPI item descriptor
;		block in a read_only PSECT.
;
;		The list thus generated can subsequently be used directly 
;		as a parameter list to FAO.
;
;	parameters:
;		LSTN = list name 
;		X    = JPI item identifier
;		LEN  = expected length of result (null= longword)
;		TYPE = 'QUAD' : quadword
;			null  : longword or string
 
;

	.MACRO	JPI_ITEM	LSTN,X,LEN,TYPE

;
;  generate JPI item descriptor
;

	.SAVE
	.PSECT	SHOW$MSG_TXT	LONG,RD,NOWRT,NOEXE
$ITEM_LEN$=4
	.IIF	NB,LEN,$ITEM_LEN$=LEN
	.IIF	IDN,<TYPE>,<QUAD>,$ITEM_LEN$=8
	.WORD	$ITEM_LEN$,JPI$_'X	; length and code of item descriptor
	.IF 	B,LEN
	.IFT				; item is long or quadword
	.IF	IDN,<TYPE>,<QUAD>
	.IFT
	.LONG	'LSTN'_Q_'X		; point to a quadword
	.IFF
	.LONG	'LSTN'_L_'X		; point to a longword
	.IFTF
	.LONG	0			; resulting length is known
	.ENDC
	.IFF				; item is a string
	.LONG	'LSTN'_T_'X		; point to a string buffer
	.LONG	'LSTN'_Q_'X		; result length is quadword descriptor

;
; reserve buffer space if item is a string
;
	.PSECT	SHOW$JPI_STR	LONG,RD,WRT,NOEXE
'LSTN'_T_'X:
	.BLKB	$ITEM_LEN$		; reserve space for buffer

;
; restore current PSECT and generate space for resulting values or pointers
;
	.IFTF				;
	.RESTORE			; restore original PSECT
	.IFT				; item is long or quad
	.IF	IDN,<TYPE>,<QUAD>
	.IFT
'LSTN'_Q_'X:
	.BLKQ	1			; reserve a quadword
	.IFF
'LSTN'_L_'X:
	.BLKL	1			; reserve a longword
	.ENDC
	.IFF				; item is a string
'LSTN'_Q_'X:
	.BLKL	1			; space for resultant length
	.LONG	'LSTN'_T_'X		; point to resultant buffer
	.ENDC
	.ENDM	JPI_ITEM


;
; JPI_ITEM_INIT - start a JPI item list
;

	.MACRO	JPI_ITEM_INIT	LB
	.SAVE
	.PSECT	SHOW$MSG_TXT	LONG,RD,NOWRT,NOEXE

'LB:
	.RESTORE
	.ENDM	JPI_ITEM_INIT


;
; end the JPI item descriptor list
;

	.MACRO	JPI_ITEM_END
	.SAVE
	.PSECT	SHOW$MSG_TXT	LONG,RD,NOWRT,NOEXE
	.LONG	0
	.RESTORE
	.ENDM	JPI_ITEM_END

;
; Equated symbols:
;

	_VIELD	PROC,0,<-
		<QUOT,,M>,-		; /QUOTA
		<ACCO,,M>,-		; /ACCOUNTING
		<PRIV,,M>,-		; /PRIVILEGES
		<MEMO,,M>,-		; /MEMORY
		<SUBP,,M>,-		; /SUBPROCESSES
		<CONT,,M>,-		; /CONTINUOUS
		<ALL,,M>,-		; /ALL
		<IDENT,,M>,-		; /IDENTIFICATION specified
		<NAME,,M>,-		; Process name specified
		<DONE,,M>,-		; Bit to show the header was written
		>

	$SHR_MESSAGES	SHOW,120,<-	; define shared messages
		<BADLOGIC,ERROR>,-	;
		>

USER_MODE=3				; user access mode
PROGRAM_REGION=0			; code for program region
SCRATCH_PAGES=64			; scratch space needed
SCRATCH_AREA2=<8*512>			; offset to secondary scratch area (in bytes)
DEVNAM_LEN=16				; max. length of a generic device name
DEV_SPEC_LEN=DEVNAM_LEN+16		; maximum length of a device and unit string
WORD=2					; length of a word
DEV_PER_LINE=8				; number of devices to print per line
PCB$S_LNAME=16				; max length of process name

; Symbolic offsets in argument list passed to error action routines

	REQ_DESC_BLOCK = 4		; address of request descriptor block
	ERROR          = 8		; error status


;
; Own storage:
;

	.PSECT	SHOW$RWDATA	LONG,RD,WRT,NOEXE

;
; define CLI call back structures
;

PROC_A_ASCII:
	$CLIREQDESC	-
		RQTYPE=CLI$K_ASCIIVAL	; get an ascii qualifier value
PROC_A_NAME:
	$CLIREQDESC	-		; CLI request descriptor
		RQTYPE=CLI$K_INPUT1,-	; the first input (process name)
		BITNUM=PROC_V_NAME	; Bit to show its presence

PROC_A_GETIDENT:
	$CLIREQDESC	-
		RQTYPE=CLI$K_GETQUAL,-	; Request a qualifier descriptor
		QUALST=PROC_A_IDENT	; For identification
PROC_A_IDENT:
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_IDEN,-;TRY THE IDENT
		SETLST=PROC_V_IDENT,-
		TRUACT=PROC_IDENT
	$CLIQUALDEF	END_LIST	;THE END OF THIS LIST

PROC_A_GETCONT:
	$CLIREQDESC	-
		RQTYPE=CLI$K_GETQUAL,-	; Request a qualifier descriptor
		QUALST=PROC_A_CONT	; for continuous specified
PROC_A_CONT:
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_CONT,-; Try the continuous
		TRUACT=PROC_CONT_DISPLAY
	$CLIQUALDEF	END_LIST	;THE END OF THIS LIST


PROC_A_GETQUAL:
	$CLIREQDESC	-		; CLI request descriptor block 
		RQTYPE=CLI$K_GETQUAL,-	; to get qualifiers
		ERRACT=CLI_ERROR,-	; address of error action routine
		QUALST=PROC_A_QUALST	; pointer to qualifier list
PROC_A_QUALST:				; qualifier list
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_QUOT,-; /QUOTA
		SETLST=PROC_V_QUOT,-	;
		TRUACT=PROC_QUOT_PRES	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_ACCO,-; /ACCOUNTING
		SETLST=PROC_V_ACCO,-	;
		TRUACT=PROC_ACCO_PRES
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_PRIV,-; /PRIVILEGES
		SETLST=PROC_V_PRIV,-	;
		TRUACT=PROC_PRIV_PRES	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_MEMO,-; /MEMORY
		SETLST=PROC_V_MEMO,-	;
		TSTLST=<<PROC_V_NAME>,<PROC_V_IDENT>>,-
		TRUACT=PROC_MEMO_PRES	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_SUBP,-; /SUBPROCESSES
		SETLST=PROC_V_SUBP,-	;
		TRUACT=PROC_SUBP_PRES	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHPR_ALL,-	; /ALL
		SETLST=PROC_V_ALL	;
	$CLIQUALDEF	END_LIST

;
; read/write storage
;

PROC_L_BITLIS:
	.LONG	0			; qualifier bit list
PROC_Q_SCRATCH:
	.BLKQ	1			; descriptor of scratch area (first and last)
PROC_L_SCRLIM:
	.BLKL	1			; limit of scratch area
JPI_Q_IOSB:				; IOSB from the GETJPI
	.BLKQ	1

;
; build JPI calling structures and corresponding FAO parameter lists.

;

	JPI_ITEM_INIT	JPI_ITMLST	; define start of JPI item list

HDR_LIST:
	.LONG	0			; system date and time
	JPI_ITEM	HDR,TERMINAL,16	; Terminal associated
	JPI_ITEM	HDR,USERNAME,16	; user name

DEF_LIST:
	JPI_ITEM	DEF,PID		; process id
	JPI_ITEM	DEF,PRCNAM,16	; process name
	JPI_ITEM	DEF,GRP		; group number of UIC
	JPI_ITEM	DEF,MEM		; member number of UIC
	JPI_ITEM	DEF,PRIB	; base priority
DEF_Q_DEVICE:
	.LONG	DEV_SPEC_LEN		; quadword descriptor 
	.LONG	DEF_T_DEVICE		; to default device name
DEF_L_DEFDIR:
	.BLKL	1			; pointer to default directory

QUO_LIST1:
	JPI_ITEM	QUO,ACCOUNT,16	; account name
QUO_LIST2:
	JPI_ITEM	QUO,CPULIM	; cpu limit
	JPI_ITEM	QUO,DIOLM	; direct i/o limit
	JPI_ITEM	QUO,BYTCNT	; byte count limit
	JPI_ITEM	QUO,BIOLM	; buffered i/o limit
	JPI_ITEM	QUO,TQCNT	; timer queue entry limit
	JPI_ITEM	QUO,FILCNT	; open file limit
	JPI_ITEM	QUO,PAGFILCNT	; pageing file quota remaining
	JPI_ITEM	QUO,PRCLM	; subprocess quota
	JPI_ITEM	QUO,DFPFC	; default page fault cluster
	JPI_ITEM	QUO,ASTCNT	; AST limit
	JPI_ITEM	QUO,ENQCNT	; ENQUE limit
	JPI_ITEM	QUO,JOBPRCCNT	; Current total process count

ACC_LIST:
	JPI_ITEM	ACC,BUFIO	; accumulated buffered i/o count
	JPI_ITEM	ACC,WSPEAK	; peak woking set size
	JPI_ITEM	ACC,DIRIO	; accumulated direct i/o
	JPI_ITEM	ACC,VIRTPEAK	; peak virtual size
	JPI_ITEM	ACC,PAGEFLTS	; page faults
	JPI_ITEM	ACC,VOLUMES	; count of mounted volumes
	JPI_ITEM	ACC,CPUTIM	; cpu time
	JPI_ITEM	ACC,LOGINTIM,8	; compute connect time
PRV_LIST:
	JPI_ITEM	PRV,PROCPRIV,,QUAD
					; process privileges quadword

	JPI_ITEM_END			; terminate JPI item descriptor list

PROC_DEVICE_CNT:
	.BLKL	1			; count for FAO parameter list below
PROC_DEVICE_LST:
	.BLKQ	DEV_PER_LINE		; FAO parameter list for list of devices

;
; pointers to all possible privilege text strings.
;

PRIV_A_TEXT:
	.BLKL	64			; pointers to privilege text strings
$$$=.					; save location 
	.IRP	XXX,<-
		CMKRNL,-		; may change mode to kernel
		CMEXEC,-		; may change mode to exec
		SYSNAM,-		; may insert in system logical name table
		GRPNAM,-		; may insert in group logical name table
		ALLSPOOL,-		; may allocate spooled device
		DETACH,-		; may create detaches processes
		DIAGNOSE,-		; may diagnose devices
		LOG_IO,-		; may do logical i/o
		GROUP,-			; may affect other processes in same group
		NOACNT,-		; may suppress accounting message
		PRMCEB,-		; may create permanent common event clusters
		PRMMBX,-		; may create permanent mailbox
		PSWAPM,-		; may change process swap mode
		SETPRI,-		; may set any priority value
		SETPRV,-		; may set any privilege bit
		TMPMBX,-		; may create temporary mailbox
		WORLD,-			; may affect other processes in the world
		MOUNT,-			; may execute mount acp function
		OPER,-			; operator privilege
		EXQUOTA,-		; may exceede quota
		NETMBX,-		; may create network device
		VOLPRO,-		; may override volume protection
		PHY_IO,-		; may do physical i/o
		BUGCHK,-		; may make bug check log entries
		PRMGBL,-		; may create permanent global sections
		SYSGBL,-		; may create system wide global sections
		PFNMAP,-		; may map to specific phy. pages
		SHMEM,-			; may create/delete objects in shared memory
		SYSPRV,-		; may access objects via system protection
		BYPASS,-		; bypasses UIC checking
		SYSLCK,-		;
		>
	.IF	DF,PRV$V_'XXX
.=PRIV_A_TEXT+<4*PRV$V_'XXX>
	.LONG	PRV_T_'XXX
	.ENDC
	.ENDR
.=$$$

;
; buffers
;

CNV_ATIME:
	.ASCID	/!%D/
ASCII_INFI:
	.ASCID	/        Infinite/
ASCII_CPULIM:
	.WORD	16
	.WORD	0
	.LONG	10$
10$:	.BLKB	16
TIME_ADDR:
	.LONG	QUO_Q_CPULIM
DEF_T_DEVICE:
	.BLKB	DEV_SPEC_LEN		; space for default device
ACC_Q_CPUTIM:
	.BLKQ	1			; space for CPU time in delta time format
QUO_Q_CPULIM:
	.BLKQ	1			; space for CPU limit in delta time format
					; (counted string)
GETPID:
	.WORD	4			; GET OUR PID
	.WORD	JPI$_PID		;...
	.LONG	PROC_L_PID
	.LONG	0
	.LONG	0			; THE END
GETPRCNAM:
	.WORD	4			; Get the process name
	.WORD	JPI$_PRCNAM		; ...
	.LONG	PROC_Z_NAME
	.LONG	PROC_W_DESCLEN
	.LONG	0			; End
PROC_L_OURPID:
	.BLKL	1	
PROC_L_PID::
	.BLKL	1			;THE ADDRESS OF the PID
PROC_Z_NAME::
	.BLKB	15			; Process name
PROC_A_DESC::				; Process name descriptor
PROC_W_DESCLEN:
	.BLKW	1
	.BLKW	1
	.ADDRESS PROC_Z_NAME
PROC_L_STATUS::				; Status set when PROC_CONT is called
	.BLKL	1
PROC_Q_SYSTIM:
	.BLKQ	1			; space for system time
PRIV_FAO_LIST:
	.BLKL	2			; FAO parameter list for privileges


;
; text
;

	.PSECT	SHOW$MSG_TXT	LONG,RD,NOWRT,NOEXE

PRV_T_CMKRNL:
	.ASCIC	&may change mode to kernel&
PRV_T_CMEXEC:
	.ASCIC	&may change mode to exec&
PRV_T_SYSNAM:
	.ASCIC	&may insert in system logical name table&
PRV_T_GRPNAM:
	.ASCIC	&may insert in group logical name table&
PRV_T_ALLSPOOL:
	.ASCIC	&may allocate spooled device&
PRV_T_DETACH:
	.ASCIC	&may create detached processes&
PRV_T_DIAGNOSE:
	.ASCIC	&may diagnose devices&
PRV_T_LOG_IO:
	.ASCIC	&may do logical I/O&
PRV_T_GROUP:
	.ASCIC	&may affect other processes in same group&
PRV_T_NOACNT:
	.ASCIC	&may suppress accounting message&
PRV_T_PRMCEB:
	.ASCIC	&may create permanent common event clusters&
PRV_T_PRMMBX:
	.ASCIC	&may create permanent mailbox&
PRV_T_PSWAPM:
	.ASCIC	&may change process swap mode&
PRV_T_SETPRI:
	.ASCIC	&may set any priority value&
PRV_T_SETPRV:
	.ASCIC	&may set any privilege bit&
PRV_T_TMPMBX:
	.ASCIC	&may create temporary mailbox&
PRV_T_WORLD:
	.ASCIC	&may affect other processes in the world&
PRV_T_MOUNT:
	.ASCIC	&may execute mount ACP functions&
PRV_T_OPER:
	.ASCIC	&may perform operator functions&
PRV_T_EXQUOTA:
	.ASCIC	&may exceed quota&
PRV_T_NETMBX:
	.ASCIC	&may create network device&
PRV_T_VOLPRO:
	.ASCIC	&may override volume protection&
PRV_T_PHY_IO:
	.ASCIC	&may do physical I/O&
PRV_T_BUGCHK:
	.ASCIC	&may make bug check log entries&
PRV_T_PRMGBL:
	.ASCIC	&may create permanent global sections&
PRV_T_SYSGBL:
	.ASCIC	&may create system wide global sections&
PRV_T_PFNMAP:
	.ASCIC	&may map to specific physical pages&
PRV_T_SHMEM:
	.ASCIC	&may create and delete objects in shared memory&
PRV_T_SYSPRV:
	.ASCIC	&may access objects via system protection&
PRV_T_BYPASS:
	.ASCIC	&bypasses UIC checking&
PRV_T_SYSLCK:
	.ASCIC	&may lock system wide resources&
NOT_AVAIL:
	.ASCIC	&Not Available&
PROC_Q_SYSDISK:
	.LONG	SYSDISK_LEN	; descriptior to SYS$DISK logical name
	.LONG	PROC_T_SYSDISK
PROC_Q_SYSCOMND:
	.LONG	SYSCOMND_LEN	; descrpitor to SYS$COMAND logical name
	.LONG	PROC_T_SYSCOMND
PROC_T_SYSDISK:
	.ASCII	/SYS$DISK/
SYSDISK_LEN=.-PROC_T_SYSDISK
PROC_T_SYSCOMND:
	.ASCII	/SYS$COMMAND/
SYSCOMND_LEN=.-PROC_T_SYSCOMND
FAO_Q_DEVNAM:
	.LONG	FAO_DEVN_LEN		; descriptor to FAO control string
	.LONG	FAO_T_DEVNAM		; for device name
FAO_T_DEVNAM:
	.ASCII	/  !AC!UW:/
FAO_DEVN_LEN=.-FAO_T_DEVNAM
BLANK_T_STRING:
	.ASCII	/ - /			; blank string
NULL_T_STRING:
	.LONG	0			; null string

	.SBTTL	SHOW$PROCESS	- Main loop
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine represents the main loop of the SHOW PROCESS command.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	CLI$A_UTILSERV(AP) =	CLI utility call back address.
;
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 = 	SS$_NORMAL
;		status code returned by called routines
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE
	.ENTRY	SHOW$PROCESS,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	$GETJPI_S ITMLST=W^GETPID,-	;GET THE PID THEN
		  IOSB=W^JPI_Q_IOSB
	BLBC	R0,40$			;END ON ERRORS
	$WAITFR_S EFN=#0		; Make sure the event is ready
	MOVZWL	W^JPI_Q_IOSB,R0		; and valid
	BLBS	R0,50$			;END ON ERRORS
40$:	BRW	90$			;...

50$:
	MOVL	W^PROC_L_PID,W^PROC_L_OURPID; THIS PID IS OURS
	MOVAL	W^PROC_A_NAME,R10	;GET THE PROCESS ID ADDRESS
	PUSHAL	W^PROC_L_BITLIS		;SAVE THE ADDRESS OF THE BITLIST
	PUSHAL	W^SHOW$A_CLIWORK	;THE CLIWORK AREA
	PUSHL	R10			;TRY TO GET THE PROCESS NAME
	CALLS	#3,@CLI$A_UTILSERV(AP)	;GET THE QUALIFIER
	MOVAB	CLI$Q_RQDESC(R10),R10	;GET THE ADDRESS OF THE DESCRIPTOR
	TSTL	(R10)			;DO WE HAVE A PROCESS NAME
	BEQL	10$			;No check for identification

5$:	$GETJPI_S PRCNAM=(R10),ITMLST=W^GETPID,IOSB=W^JPI_Q_IOSB
	BLBC	R0,8$			;ON ERRORS TELL THEM
	$WAITFR_S EFN=#0		; Make sure the event is ready
	MOVZWL	W^JPI_Q_IOSB,R0		; and valid
	BLBS	R0,80$			;ON ERRORS TELL THEM
8$:	BRW	90$
;
; CHECK FOR IDENT QUALIFIER
;

10$:	MOVL	S^#SS$_NORMAL,W^SHOW$L_STATUS
					; assume success
	PUSHAL	W^PROC_L_BITLIS		; bit list
	PUSHAL	W^SHOW$A_CLIWORK	; address of CLI work area
	PUSHAL	W^PROC_A_GETIDENT	; request qualifiers parsing
	CALLS	#3,@CLI$A_UTILSERV(AP)	; call CLI utility service routine
	MOVL	W^SHOW$L_STATUS,R0	; get status returned by last action routine
	BLBS	R0,80$
	BRW	90$			; exit on error

80$:	MOVAL	W^PROC_L_PID,R10	; Get PID address
	$GETJPI_S PIDADR=(R10),ITMLST=W^GETPRCNAM,IOSB=W^JPI_Q_IOSB
	BLBC	R0,20$			; On error tell user
	$WAITFR_S EFN=#0		; Make sure the event is ready
	BLBS	R0,25$			; and valid
20$:	BRW	90$

25$:	MOVL	S^#SS$_NORMAL,W^SHOW$L_STATUS ; Assume success
	CLRL	PROC_L_STATUS		; Clear status for PROC_CONT
	PUSHAL	W^PROC_L_BITLIS		; bit list
	PUSHAL	W^SHOW$A_CLIWORK	; address of CLI work area
	PUSHAL	W^PROC_A_GETCONT	; Try to start up PROC_CONT (INFO)
	CALLS	#3,@CLI$A_UTILSERV(AP)	; call CLI utility service routine
	MOVL	W^SHOW$L_STATUS,R0	; get status returned by last action routine
	BLBS	PROC_L_STATUS,90$	; If LBS then PROC_CONT was called
					; exit the program

;
; get all process information at once
;
;
	CALLS	#0,W^PROC_GETINFO	; get job process information
	BLBC	R0,90$			; exit on error

;
; parse qualifiers and call true action routines
;

	MOVL	S^#SS$_NORMAL,W^SHOW$L_STATUS
					; assume success
	PUSHAL	W^PROC_L_BITLIS		; bit list

	PUSHAL	W^SHOW$A_CLIWORK	; address of CLI work area
	PUSHAL	W^PROC_A_GETQUAL	; request qualifiers parsing
	CALLS	#3,@CLI$A_UTILSERV(AP)	; call CLI utility service routine
	MOVL	W^SHOW$L_STATUS,R0	; get status returned by last action routine
	BLBC	R0,90$			; exit on error

;
; display default information if applicable
;

	BICL3	#<PROC_M_ALL!-		; mask off bit for /ALL
		  PROC_M_NAME!-		;  and ignore the presence of explicit
		  PROC_M_IDENT>,-	;  or process ID for this test
		W^PROC_L_BITLIS,R1	; store result in R1
	BNEQU	90$			; exit if any qualifier specified
	CALLS	#0,W^PROC_DEFA_PRES	; display default information
	BLBC	R0,90$			; exit on error
	BBC	#PROC_V_ALL,W^PROC_L_BITLIS,90$
					; all done if not /ALL
;
; treat /ALL qualifier
;

	CALLS	#0,W^PROC_QUOT_PRES	; display quota
	CALLS	#0,W^PROC_ACCO_PRES	; display accounting information
	CALLS	#0,W^PROC_PRIV_PRES	; display process privileges
	CMPL	W^PROC_L_PID,W^PROC_L_OURPID	; displaying current process?
	BNEQ	85$			; no. skip process pool display
	CALLS	#0,W^PROC_MEMO_PRES	; display process pool area
85$:	CMPL	W^DEF_L_PID,W^PROC_L_OURPID	; can we give him this info?
	BNEQU	90$			; no. then don't and exit
	CALLS	#0,W^PROC_SUBP_PRES	; give list of subprocesses

;
; exit
;

90$:
	MOVL	R0,W^SHOW$L_STATUS	; save return code
	RET

	.SBTTL	PROC_GETINFO	- retrieve information

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine retrieves all information about the current process
;	that is available in user mode and that is likely to be needed
;	by one of the qualifier action routines.
;	The necessary arithmetic is also performed, and pointers 
;	available at run time inserted into FAO parameter lists.
;	Device information and subprocess information however, is
;	retrieved only when needed.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	FAO parameter lists for most options are ready to be used.
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		status code returned by system services called.
;		($GETJPI and $TRNLOG)
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_GETINFO:
	.WORD	0

;
; get JPI information
;

	$GETJPI_S	PIDADR=W^PROC_L_PID,-
			ITMLST=W^JPI_ITMLST,-
			IOSB=W^JPI_Q_IOSB
	BLBC	R0,2$			; exit on error
	$WAITFR_S EFN=#0		; Make sure the event is ready
	MOVZWL	W^JPI_Q_IOSB,R0		; and valid
	BLBS	R0,5$			; If LBS then ok
2$:	BRW	90$			; else end in error
5$:

;
; perform some arithmetic and insert pointers
;

	EMUL	#-100000,W^ACC_L_CPUTIM,#0,W^ACC_Q_CPUTIM
					; convert CPU time to system format
	MOVAL	W^ACC_Q_CPUTIM,W^ACC_L_CPUTIM
					; and insert pointer to quad time
	MOVAL	W^ASCII_INFI,-(SP)	; assume time limit infinite
	MOVL	W^QUO_L_CPULIM,R0	; get cpu limit
	BEQL	8$			; br if it is infinite
	CLRL	R1			; clear value to be added in emul
	BLBC	R0,7$			; test low bit of time
	MOVL	#^X0FFFE7960,R1		; add -.01 sec in 100 ns units
7$:	EXTZV	#1,#31,R0,R0		; shift right one
	EMUL	#-20*10*1000,R0,R1,QUO_Q_CPULIM	; convert to quad word
	$FAO_S	CTRSTR=CNV_ATIME,-	; addr. of control string
		OUTLEN=W^ASCII_CPULIM,-	; place to put length of result
		OUTBUF=W^ASCII_CPULIM,-	; place to put result
		P1=W^TIME_ADDR		; addr. of quad word time
	MOVAL	W^ASCII_CPULIM,(SP)	; addr. of desc. of output
8$:	MOVL	(SP)+,W^QUO_L_CPULIM	; move to arg. list

	$GETTIM_S	W^PROC_Q_SYSTIM	; get system date and time
	SUBL2	W^PROC_Q_SYSTIM,W^ACC_T_LOGINTIM
	SBWC	W^PROC_Q_SYSTIM+4,W^ACC_T_LOGINTIM+4
					; calculate connect time (in delta format)

;
; get default device name	(translate SYS$DISK:)
;
	CMPL	W^DEF_L_PID,W^PROC_L_OURPID; CAN WE GIVE HIM THIS INFO?
	BEQL	10$			; YES THEN GIVE IT TO HIM
	CLRQ	W^DEF_Q_DEVICE		; NO THEN CLEAN OUT THE DESCRIPTOR
	MOVAB	W^NOT_AVAIL,W^DEF_L_DEFDIR; AND TELL HIM NOT AVAILABLE
	BRW	30$			;THEN EXIT GRACEFULLY

10$:	$TRNLOG_S	-
		LOGNAM=W^PROC_Q_SYSDISK,-
		RSLLEN=W^DEF_Q_DEVICE,-
		RSLBUF=W^DEF_Q_DEVICE
	BLBC	R0,90$			; exit on error
	CMPB	#27,W^DEF_T_DEVICE	; does name start with escape ?
	BNEQU	20$			; branch if no escape
	SUBL2	#4,W^DEF_Q_DEVICE		; adjust string length
	ADDL2	#4,W^DEF_Q_DEVICE+4	; adjust pointer
20$:

;
; get default directory string
;

	MOVAL	PIO$GT_DDSTRING,W^DEF_L_DEFDIR
					; make FAO entry point to it

;
; allocate scratch space for everybody
;

30$:	$EXPREG_S	-
		PAGCNT=#SCRATCH_PAGES,-
		RETADR=W^PROC_Q_SCRATCH,-
		ACMODE=#USER_MODE,-
		REGION=#PROGRAM_REGION

;
; exit
;

90$:
	RET

	.SBTTL	PROC_HEADINFO	- display header information
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine prints header information to be shown no matter
;	what qualifiers are specified.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Information already retrieved by the PROC_GETINFO routine.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_HEADINFO:
	.WORD	0

;
; print header information
;

10$:
	PUSHL	#SHOW$_PROCHDRI		;
	PUSHAL	W^HDR_LIST		; parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; issue message
	BBCS	#PROC_V_DONE,G^PROC_L_BITLIS,90$	; set bit to show it's printed
90$:
	MOVL	#SS$_NORMAL,R0		; status code
	RET

	.SBTTL	PROC_IDENT		;GET THE PROCESS IDENTIFICATION
;
; FUNCTION
;
;	Will get the pid of a process and use that for the getjpi rather
;	than the pid of a process name.
;
.entry	PROC_IDENT,^M<R2,R3,R4,R5>
	MOVAB	W^PROC_A_ASCII,R2	;GET AN ASCII VALUE FOR THE IDENT
	PUSHL	4(AP)			;GET THE QUALIFIER DESCRIPTOR
	PUSHAL	W^SHOW$A_CLIWORK	; PUSH THE BITLIST AND WORK SPACE
	PUSHL	R2
	CALLS	#3,@CLI$A_UTILSERV(AP)
	MOVAB	CLI$Q_RQDESC(R2),R2	;GET A POINTER TO THE STRING
	PUSHAL	W^PROC_L_PID		;PUT IT IN THE PID
	PUSHL	R2			;AND THE STRING DESCRIPTOR
	CALLS	#2,G^OTS$CVT_TZ_L	;ANC CONVERT IT HEX LIKE
	MOVL	R0,W^SHOW$L_STATUS	;AND MAKE THIS THE RETURN STATUS
	RET				;AND RETURN NORMALY

	.SBTTL	PROC_DEFA_PRES	- display default information
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays default information if either
;	no qualifier has been given, or /ALL has been specified as the
;	only qualifier.
;	Separate routines are called to display device information
;	(devices allocated and mounted), if any.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Information already retrieved by the PROC_GETINFO routine.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		error status returned by routines called 
;		(PROC_DEVALL and PROC_DEVMOU)
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_DEFA_PRES:
	.WORD	0

;
; check to see if the header information has been printed.
; if not, print it.
;

	BBS	#PROC_V_DONE,G^PROC_L_BITLIS,10$
	CALLS	#0,PROC_HEADINFO
	BLBC	R0,90$
;
; print default information
;

10$:	PUSHL	#SHOW$_PROCDEFA		; message identifier
	PUSHAL	W^DEF_LIST		; parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; print information

;
; print device information, if any
;

	MOVL	S^#SS$_NORMAL,R0	; assume success
	CALLS	#0,W^PROC_DEVALL	; list of devices allocated
	BLBC	R0,90$			; exit on error
	CMPL	W^DEF_L_PID,W^PROC_L_OURPID; CAN WE GIVE HIM THIS INFO?
	BNEQU	90$			; he dosen't get a volume list
					; if this isn't his process
	$CMEXEC_S	W^PROC_DEVMOUN	; List of volumes mounted
90$:
	RET

	.SBTTL	PROC_QUOT_PRES	- display quota information
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays quota information relevant to the current
;	process.
;	It is called by the CLI as a true action routine for the /QUOTA
;	qualifier, and is also invoked directly if the /ALL qualifier
;	is present.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Information already retrieved by the PROC_GETINFO routine.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_QUOT_PRES:
	.WORD	0

;
; print header information, if it hasn't already been printed
;

	BBS	#PROC_V_DONE,G^PROC_L_BITLIS,10$
	CALLS	#0,G^PROC_HEADINFO
	BLBC	R0,20$

;
; print quota information
;

10$:	PUSHL	#SHOW$_PROCQUOT1	; message identifier
	PUSHAL	W^QUO_LIST1		; parameter list aready filled
	CALLS	#2,W^SHOW$PRINT_MSG	; print information
	SUBW2	QUO_L_JOBPRCCNT,QUO_L_PRCLM	; determine true process quota
	PUSHL	#SHOW$_PROCQUOT2	; message id for part 2
	PUSHAL	W^QUO_LIST2		; parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; print 
	MOVL	S^#SS$_NORMAL,R0	; success
20$:	RET

	.SBTTL	PROC_ACCO_PRES	- display accounting information
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays accounting information relevant to the
;	current process.
;	It is called by the CLI as a true action routine for the 
;	/ACCOUNTING qualifier, and is also invoked directly if
;	the /ALL qualifier is given.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Information already retrieved by the PROC_GETINFO routine.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_ACCO_PRES:
	.WORD	0
;
; print header information, if it hasn't already been printed
;

	BBS	#PROC_V_DONE,G^PROC_L_BITLIS,10$
	CALLS	#0,G^PROC_HEADINFO
	BLBC	R0,20$


;
; display accounting information
;

10$:	PUSHL	#SHOW$_PROCACCO		; message identifier
	PUSHAL	W^ACC_LIST		; parameter list already filled
	CALLS	#2,W^SHOW$PRINT_MSG	; and print information
	MOVL	S^#SS$_NORMAL,R0	; Success
20$:	RET

	.SBTTL	PROC_PRIV_PRES	- display process privileges
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the list of process privileges
;	of the current process
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Process privilege vector retrieved by PROC_GETINFO.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;	R11 =	privilege bit (0-63)
;	R8 =	pointer to common privilege name table
;	R9 =	bit offset within longword
;	R10 =	index longword within privilege quadword
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_PRIV_PRES:
	.WORD	^M<R9,R8,R10,R11>
;
; print header information, if it hasn't already been printed
;

	BBS	#PROC_V_DONE,G^PROC_L_BITLIS,5$
	CALLS	#0,G^PROC_HEADINFO
	BLBC	R0,95$



;
; print title
;


5$:	PUSHL	#SHOW$_PROCPRI		; message id
	PUSHL	#0			; no parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; issue message

;
; selectively print privileges
;

	MOVAL	PRV$AB_NAMES,R8		; point to common privilege name table
10$:
	TSTB	(R8)+			; test first byte
	BEQLU	90$			; branch if end of list
	MOVZBL	(R8)+,R9		; get bit number
	MOVL	#1,R10			; assume second longword
	SUBL3	#32,R9,R11		; compute bit offset within lonword
	BGEQU	20$			; branch if indeed 2d word
	MOVL	R9,R11			; restore original bit offset
	CLRL	R10			; mark 1st longword
20$:
	BBC	R11,W^PRV_Q_PROCPRIV[R10],30$
					; branch if corresponding privilege bit clear
	MOVL	R8,W^PRIV_FAO_LIST	; fill in pointer to code text
	MOVL	W^PRIV_A_TEXT[R9],W^PRIV_FAO_LIST+4
					; fill in pointer to full text
	BNEQU	25$			; ok if not null
	MOVAL	W^NULL_T_STRING,W^PRIV_FAO_LIST+4
					; insert pointer to null string
25$:
	PUSHL	#SHOW$_PRIV_TEXT	; message code
	PUSHAL	W^PRIV_FAO_LIST		; parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; and issue message
30$:
	MOVZBL	(R8)+,R0		; skip string just printed
	ADDL2	R0,R8			;
	BRB	10$			; and try next one
;
; exit
;

90$:
	MOVL	S^#SS$_NORMAL,R0	; success
95$:	RET				; all done

	.SBTTL	PROC_MEMO_PRES	- display process-private pool area
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the same information for the process-specific
;	pool area in P1 space that the SHOW MEMORY /POOL /FULL command
;	displays for nonpaged or paged dynamic memory.
;
;
; CALLING SEQUENCE:
;
;	CALLx	arg-list-descriptor,PROC_MEMO_PRES
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUT:
;
;	Contents of process allocation region for current process
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUT:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL => Normal successful completion
;
; SIDE EFFECTS:
;
;	NONE
;
; Unlike the rest of the options to the SHOW PROCESS command, the /MEMORY
; option can only be used with the current process. If the /MEMORY
; qualifier is included with a process name or the /IDENT qualifier,
; the CLI returns an error and aborts the image.
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_MEMO_PRES:
	.WORD	0			; Save nothing here

; Print header information, if it hasn't already been printed

	BBS	#PROC_V_DONE,G^PROC_L_BITLIS,10$	; Header already printed?
	CALLS	#0,G^PROC_HEADINFO	; No. Print it
	BLBC	R0,20$			; Skip rest if error occurred
10$:	CALLS	#0,SHOW$PRCALLREG	; Call common routine in SHOW$MEMORY
20$:	RET				; All done. Return to caller


	.SBTTL	PROC_SUBP_PRES	- list subprocesses
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the tree of subprocesses spawned by the 
;	current process.
;
;	Algorithm:
;
;	1) in kernel mode:
;	Sequentially scan all PCB's, and construct a list of all 
;	owner - subprocess pairs in the system.
;	(i.e fill in downward pointers).
;
;	Scan the tree of subprocesses starting at the current process's pid
;	and convert pids to names.
;	Return the list of subprocess names with associated levels in 
;	scratch space.
;
;	2) in user mode:
;	Format and print above list.
;
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		code returned by system services called
;		SHOW$_BADLOGIC : scratch area overflow
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;	R6 =	counter for leaders
;	R7 =	point to list of subprocess names to format
;	R8 =	level number
;	R9 =	pointer to beginning of output buffer
;	R3 = 	pointer to current output character
;
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_SUBP_PRES:
	.WORD	^M<R2,R3,R6,R7,R8,R9>
	CMPL	W^DEF_L_PID,W^PROC_L_OURPID; CAN WE GIVE HIM THIS INFO?
	BEQL	5$			; YES THEN DO
	MOVL	#CLI$_INVKEY,W^SHOW$L_STATUS;ELSE GIVE HIM A NOPRIV ERROR
	RET				; AND RETURN


;
; construct list of subprocesses in kernel mode
;

5$:	$CMKRNL_S	W^COPY_SUBP
	BLBC	R0,98$			; exit on error

;
; print header information, if it hasn't already been printed
;

	BBS	#PROC_V_DONE,G^PROC_L_BITLIS,7$
	CALLS	#0,G^PROC_HEADINFO
	BLBC	R0,99$


;
; format and print list of subprocesses (if any)
;

7$:	MOVL	W^PROC_Q_SCRATCH,R7	; start of copied area
	TSTW	(R7)			; test if list empty
	BEQLU	90$			; exit if list empty
	PUSHL	#SHOW$_PROCSUBP		; message id for title
	PUSHL	#0			; no parameters
	CALLS	#2,W^SHOW$PRINT_MSG	; print title
	MOVL	W^SHOW$GQ_OUT_DSC+4,R9	; pointer to output buffer
10$:
	MOVZWL	(R7)+,R8		; get level number
	BEQLU	90$			; exit if end of list
	MOVL	#1,R6			; counter
	MOVL	R9,R3			; pointer to current output character
20$:
	MOVL	#^A/  - /,(R3)+		; insert one leader per level
	AOBLEQ	R8,R6,20$		; loop on number of levels
50$:
	MOVZBL	(R7)+,R0		; get character count
	MOVC3	R0,(R7),(R3)		; copy name to output buffer
	SUBL2	R9,R3			; calculate length of output string
	PUSHL	R9			; pointer to output buffer
	PUSHL	R3			; length of output buffer
	CALLS	#2,W^SHOW$PRINT_LINE	; print line
	ADDL2	#PCB$S_LNAME-1,R7	; point to next item in list
	BRB	10$			; and try for more


;
; exits
;

90$:
	MOVL	S^#SS$_NORMAL,R0		; indicate success
98$:
	BLBS	R0,99$			; exit if success
	MOVL	R0,W^SHOW$L_STATUS	; record failure in global location
99$:
	RET

	.SBTTL	COPY_SUBP	- construct list of subprocesses
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine constructs the list of subprocesses owned by the
;	current process, in 2 steps:
;
;	1) The list of all processes in the system is scanned, and
;	a list all owner - subprocess pairs is constructed in scratch space
;
;	2) The table thus constructed is scanned starting at the current
;	process's pid, and the tree of subprocesses is followed ( if any ).
;	While doing so, each pid is converted to a name that is copied
;	along with the level number, to the common scratch area.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
;	This routine is invoked through the $CMKRNL system service
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	PROC_Q_SCRATCH = descriptor to common scratch area
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	List of subprocesses owned is returned in scratch area pointed to
;	by PROC_Q_SCRATCH.
;	Format:
;	1 word 	= level
;	PCB$S_LNAME = associated process name
;	( level = 0 indicates end of list)
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		SHOW$_BADLOGIC = scratch area overflow
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;	See individual sections
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

COPY_SUBP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

;
; scan all processes and construct pairs of owner-subprocess pids in scratch area
;
;	Register usage:
;
;	R7 =	pointer to scratch area 2
;	R8 = 	limit of scratch area
;	R11=	pix
;	R10=	PCB address
;	R9 =	owner pid
;

	ADDL3	W^PROC_Q_SCRATCH,#SCRATCH_AREA2,R7
					; point to secondary scratch area
	SUBL3	#4,W^PROC_Q_SCRATCH+4,R8	; get limit of scratch area
	MOVZWL	SCH$GL_MAXPIX,R11	; get highest pix
10$:
	MOVL	SCH$GL_PCBVEC,R1	; get start of PCB pointer table
	MOVL	(R1)[R11],R10		; get address of PCB
	MOVZWL	PCB$L_OWNER(R10),R9	; get owner pid
	BEQLU	20$			; branch if no owner
	MOVW	R9,(R7)+		; copy owner pid
	MOVW	R11,(R7)+		; copy pid
	CMPL	R7,R8			; test for potential overflow
	BGEQU	80$			; branch on overflow
20$:
	SOBGEQ	R11,10$			; scan all pixes
	CLRL	(R7)			; end list with a zero word

;
; construct list of subprocesses for later printing
;
;	Register usage:
;	R7 =	pointer to scratch area 1
;	R8 =	limit of scratch area 1
;	R11=	pointer to scratch area 2
;	R9 =	pid
;	R10=	level
;	R4 =	pointer to PCB
;	R6 = 	scratch
;

	MOVL	W^PROC_Q_SCRATCH,R7	; start of scratch area for list
	ADDL3	#SCRATCH_AREA2,R7,R11	; point to secondary scratch area
	MOVL	R11,R8			; also limit for scratch area 1
	MOVL	SCH$GL_CURPCB,R4	; address of current pcb
	MOVZWL	PCB$L_PID(R4),R9	; get pid of current process
	CLRL	R10			; initialize level counter
	BRB	40$			; skip level zero

;
; process one entry
;

30$:
	ADDL3	#PCB$S_LNAME+2,R7,R6	; test for overflow
	CMPL	R6,R8
	BGEQU	80$			; branch on scratch area overflow
	MOVW	R10,(R7)+		; copy level number
	MOVL	SCH$GL_PCBVEC,R1	; get start of PCB pointer table
	MOVL	(R1)[R9],R4		; get PCB address
	PUSHR	#^M<R4>			; save PCB pointer for later check
	MOVC3	#PCB$S_LNAME,PCB$T_LNAME(R4),(R7)
					; copy process name 
	POPR	#^M<R4>			; restore PCB pointer
	CMPW	PCB$L_PID(R4),R9	; cross check validity of pid
	BEQLU	35$			; branch if ok
	MOVB	#1,(R7)+		; construct dummy process name
	MOVB	#^A/*/,(R7)		;
35$:
	MOVL	R6,R7			; update pointer to scratch area

;
; move down the tree
;

40$:
	PUSHL	R9			; save pid
	INCL	R10			; increment level counter
	CLRL	R9			; clear "next pid"

;
; move horizontally in the tree
;

50$:
	BSBW	NEXT_PID		; find next pid owned at this level
	BLBS	R0,30$			; if found, go process it

;
; move up the tree
;

	MOVL	(SP)+,R9		; else pop pid
	DECL	R10			; decrement level counter
	BNEQU	50$			; and branch if non zero

;
; end of tree scan
;

60$:
	CLRW	(R7)			; mark end of list
	MOVL	S^#SS$_NORMAL,R0		; signal success
	BRB	90$			; and exit

;
; exits
;

80$:
	MOVL	#SHOW$_BADLOGIC,R0	; signal scratch overflow
90$:
	RET				; all done

;
; NEXT_PID	-	find next pid given the owner pid and the pid beeing
;			processed.
;
;	inputs:		(SP) = owner pid
;			R9   = current pid
;			R11  = pointer to bit map array
;
; 	output:		R9   = next pid
;			R0   =  1 success: R9 updated
;				0 failure: R9 unchanged
;	Register usage:
;
;	R1 =	flag
;	R2 =	temporary entry
;	R3 =	index
;	R4 =	owner pid
;	R5 = 	pid
;

NEXT_PID:

;
; initialize
;

	CLRL	R3			; zero index
	CLRL	R1			; clear flag
	MOVZWL	4(SP),R4			; load owner pid

;
; find next entry with matching owner
;

10$:
	MOVL	(R11)[R3],R2		; load entry
	BEQLU	50$			; quit if end of list
	INCL	R3			; increment index
	CMPW	R4,R2			; compare owners
	BNEQU	10$			; branch if no match

;
; extract subprocess pid
;

	ASHL	#-16,R2,R2		; shift upper word down
	TSTW	R9			; is initial pid zero
	BEQLU 	40$			; branch to success if zero
	CMPW	R2,R9			; compare subprocess pids
	BNEQU	30$			; branch if no match
	INCL	R1			; set flag
	BRB	10$			; find next matching owner
30$:
	BLBC	R1,10$			; branch if flag still clear

;
; success
;

40$:
	MOVZWL	R2,R9			; retrieve subprocess pid
	MOVL	#1,R0			; indicate success
	RSB				; and return

;
; failure
;

50$:
	CLRL	R0			; signal failure
	RSB

	.SBTTL	PROC_DEVALL	- give list of devices allocated
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the list of devices allocated by the 
;	current process, if any.
;
; Algorithm:
;
;	1) in kernel mode:
;	scan the I/O data base ( locked for read) for an owner pid
;	(UCB$L_PID) matching the process id of the current process,
;	and copy relevant data into the scratch area.
;
;	2) in user mode:
;	format and print information, if any
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		SHOW$_BADLOGIC	= sxratch area overflow
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_DEVALL:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

;
; copy list of devices allocated into scratch space
;

	$CMKRNL_S	W^COPY_DEVALL
	BLBC	R0,99$			; exit on error

;
; format and print list of devices allocated
;

	MOVL	W^PROC_Q_SCRATCH,R9	; point to start of copied data
	MOVL	W^PROC_L_SCRLIM,R7	; point to end of copied area
	MOVL	W^PROC_Q_SCRATCH+4,R11	; point to limit of scratch area
	CLRL	R10			; signal nothing printed
10$:
	TSTB	(R9)			; anything there ?
	BEQLU	90$			; exit if no more
	CLRL	R6			; index into output list
20$:
	TSTB	(R9)			; end of list ?
	BEQLU	50$			; if end of list : go print
	MOVL	R9,R2			; point to device name
	MOVZWL	DEVNAM_LEN(R9),R3	; get unit number
	JSB	BUILD_DEVNAM		; build device name string
	BLBC	R0,80$			; branch if scratch overflow
	ADDL2	#DEVNAM_LEN+WORD,R9	; update source pointer
	INCL	R6			; account for quadword
	AOBLEQ	#<DEV_PER_LINE-1>*2,R6,20$
					; build up to one line
50$:
	ASHL	#-1,R6,W^PROC_DEVICE_CNT; insert count for FAO list
	BLBS	R10,60$			; branch of not first line
	PUSHL	#SHOW$_DEVALL		; message identifier
	BRB	70$			;
60$:
	PUSHL	#SHOW$_DEVLIS		; list without title
70$:
	PUSHAL	W^PROC_DEVICE_CNT	; parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; output message
	MOVL	#1,R10			; signal something printed
	BRB	10$			; go try for more

;
; exits
;

80$:
	MOVL	#SHOW$_BADLOGIC,R0	; signal scratch overflow
	BRB	99$			;
90$:
	MOVL	S^#SS$_NORMAL,R0	; signal success
99$:
	RET

;
;
; BUILD_DEVNAM
;
; subroutine to construct a device name
;
;	inputs: 	R2 = pointer to device name (counted string)
;			R3 = pointer to unit word
;			R7 = pointer to scratch area for building string
;			R6 = index into FAO output parameter list
;				(PROC_DEVICE_LST)
;			R11= limit of scratch area allocated
;
;	output:		device name built starting at R7
;			entry indexed by R6 points to string
;			R7 updated to point to free scratch area
;
; it is assumed that the list of devices will be SMALL on the average.
;

BUILD_DEVNAM:
	ADDL3	#DEV_SPEC_LEN,R7,R5	; test for overflow
	CMPL	R5,R11			; 
	BGEQU	10$			; branch if overflow
	MOVAL	W^PROC_DEVICE_LST[R6],R4; get address of next device list entry
	MOVL	#DEV_SPEC_LEN,(R4)
	MOVL	R7,4(R4)		; build descriptor to result string
	$FAO_S	-			; build string in scratch area
		W^FAO_Q_DEVNAM,-
		(R4),-
		(R4),-
		R2,-			; pointer to device name
		R3			; unit number
	ADDL2	#DEV_SPEC_LEN,R7	; update destination pointer
	MOVL	#1,R0			; signal success
	RSB
10$:
	CLRL	R0			; signal overflow
	RSB

	.SBTTL	COPY_DEVALL	- copy devices allocated
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine copies the list of devices allocated to the current
;	process into a scratch area.
;	It is invoked through the $CMKRNEL system service
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	Limits of scratch area : PROC_Q_SCRATCH
;
; OUTPUT PARAMETERS:
;
;	PROC_L_SCRLIM	= limit of copied area
;			  (= start of remaining scratch area)
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		SHOW$_BADLOGIC	= scratch area overflow
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;	R6 =	scratch
;	R7 =	pointer to scratch area
;	R8 =	limit of scratch area
;	R9 =	current pid
;	R10 =	pointer to UCB
;	R11 = 	pointer to DDB
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

COPY_DEVALL:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

;
; initialize
;

	MOVL	PROC_Q_SCRATCH,R7	; start of scratch area
	MOVL	PROC_Q_SCRATCH+4,R8	; limit of scratch area
	MOVAL	IOC$GL_DEVLIST-DDB$L_LINK,R11
					; address of address of first DDB
	MOVL	DEF_L_PID,R9		; compute current process id

;
; lock I/O data base for read
;

	JSB	SCH$IOLOCKR		; lock data base for read

;
; scan I/O data base
;

10$:
	MOVL	DDB$L_LINK(R11),R11	; next DDB
	BEQLU	90$			; branch if no more
	MOVAL	DDB$L_UCB-UCB$L_LINK(R11),R10
					; address of address of first UCB
20$:
	MOVL	UCB$L_LINK(R10),R10	; next UCB
	BEQLU	10$			; branch if no more
	CMPL	UCB$L_PID(R10),R9	; is owner pid current pid ?
	BNEQU	20$			; branch if not equal
	JSB	COPY_DEVNAM		; copy device name and unit
	BLBC	R0,80$			; branch on error
	BRB	20$			; try next UCB

;
; exits
;

80$:
	MOVL	#SHOW$_BADLOGIC,R0	; signal scratch overflow
	BRB	99$
90$:
	MOVL	#SS$_NORMAL,R0		; signal success
	CLRB	(R7)+			; mark end of list
	MOVL	R7,W^PROC_L_SCRLIM	; start of free scratch area
99$:
	MOVL	SCH$GL_CURPCB,R4	; address of current PCB
	PUSHR	#^M<R0>			; save status
	JSB	SCH$IOUNLOCK		; unlock I/O data base
	SETIPL	#0			; drop IPL
	POPR	#^M<R0>			; restore status
	RET				; and return


;
; subroutine to copy device name and unit
;

COPY_DEVNAM:
	MOVZBL	DDB$T_NAME(R11),R0	; point to device name
	INCL	R0			; add one for counted string
	MOVL	R7,R6			; save pointer to scratch
	ADDL	#DEVNAM_LEN+WORD,R6	; add maximum needed
	CMPL	R6,R8			; check for overflow
	BGEQU	10$			; branch on overflow
	MOVC3	R0,DDB$T_NAME(R11),(R7)	; copy device name
	ADDL2	#DEVNAM_LEN,R7		; position for unit
	MOVW	UCB$W_UNIT(R10),(R7)+	; copy unit number
	MOVL	#1,R0			; signal success
	RSB
10$:
	CLRL	R0			; scratch overflow
	RSB

	.SBTTL	PROC_DEVMOUN	- give list of devices mounted
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the list of devices mounted by the current
;	process, if any.
;
; Algorithm:
;
;	Follow the Mounted Volume list of the current process, and insert
;	pointers to relevant information into the FAO parameter list.
;
;	No interlock is needed in this case.
;
;
; CALLING SEQUENCE:
;
;	CALLS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL
;		SHOW$_BADLOGIC = scratch area overflow
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;	R6 =	index into output parameter list
;	R7 =	pointer to scratch area
;	R8 =	pointer to mounted volume list queue item
;	R9 =	pointer to mounted volume list queue head
;	R10 =	flag	(0 = first line,  1 = subsequent lines)
;	R11 = 	limit of scratch area
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

PROC_DEVMOUN:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

;
; initialize
;

	CLRL	R10			; first line 
	MOVAL	CTL$GQ_MOUNTLST,R8	; get head of mounted volume list
	MOVL	R8,R9			; remember head
	MOVL	W^PROC_Q_SCRATCH,R7	; pointer to scratch area
	MOVL	W^PROC_Q_SCRATCH+4,R11	; limit of scratch area 
5$:
	CLRL	R6			; index into output parameter list

;
; scan mounted volume list
;

10$:
	MOVL	MTL$L_MTLFL(R8),R8	; get next list item
	CMPL	R8,R9			; is it the head ?
	BEQLU	50$			; branch if head
	MOVL	MTL$L_UCB(R8),R0	; get UCB address
	MOVL	UCB$L_DDB(R0),R1	; get DDB address
	MOVAL	DDB$T_NAME(R1),R2	; point to device name
	MOVZWL	UCB$W_UNIT(R0),R3	; get unit number
	JSB	BUILD_DEVNAM		; build device name in scratch area
	BLBC	R0,80$			; branch on overflow
	INCL	R6			; account for quadword
	AOBLEQ	#<DEV_PER_LINE-1>*2,R6,10$
					; fill up to a line

;
; print list of devices
;

50$:
	TSTL	R6			; is list empty ?
	BEQLU	90$			; branch if empty
	ASHL	#-1,R6,W^PROC_DEVICE_CNT	; insert count of arguments
	BLBS	R10,60$			; branch if not first line
	PUSHL	#SHOW$_DEVMOU		; message identifier
	BRB	70$
60$:
	PUSHL	#SHOW$_DEVLIS		; format without title
70$:
	PUSHAL	W^PROC_DEVICE_CNT	; parameter list
	CALLS	#2,W^SHOW$PRINT_MSG	; print message
	MOVL	#1,R10			; signal not first line any more
	CMPL	R8,R9			; were we done ?
	BNEQU	5$			; branch if more to come
	BRB	90$			; all done

;
; exits
;

80$:
	MOVL	#SHOW$_BADLOGIC,R0	; signal overflow
	BRB	99$
90$:
	MOVL	#SS$_NORMAL,R0		; signal success
99$:
	RET

	.PAGE
	.SUBTITLE	CLI_ERROR Error Action Routine for CLI Errors

;-
; This routine is called whenever the CLI detects an error while
; parsing the input qualifiers. A signal is generated and the status
; is returned to the caller.
;
; Input Parameters:
;
;	REQ_DESC_BLOCK(AP)		; address of request descriptor block
;	ERROR(AP)			; error status
;
; Output Parameters:
;
;	None
;
; Implicit Output:
;
;	The error status is passed to LIB$STOP.
;
; Return Status:
;
;	R0 = ERROR(AP)
;-

CLI_ERROR:
	.WORD	0			; Save nothing
	PUSHL	ERROR(AP)		; Store error status
	CALLS	#1,G^LIB$STOP		; Signal the error
	MOVL	ERROR(AP),R0		; Pass the error back to the caller
	RET

	.END
