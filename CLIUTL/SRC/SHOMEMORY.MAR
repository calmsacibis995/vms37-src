	.TITLE	SHOW$MEMORY - SHOW MEMORY RESOURCES
	.IDENT	'V03-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	SHOW COMMAND
;
; ABSTRACT:
;
;	This image implements the SHOW MEMORY command option.
;
; ENVIRONMENT:
;
;	Runs in User, Exec and Kernel mode. Raises IPL to 2 and 11.
;	Holds PGDYNMTX Mutex to collect paged pool statistics.
;
; AUTHOR : Thomas S. Clark, Creation Date: 30-Jul-1980
;
; MODIFIED BY:
;
;	V03-001	LJK0145		Lawrence J. Kenah	16-Mar-1982
;		Correct long file name processing in normal display.
;
;	V02-017	LJK0138		Lawrence J. Kenah	2-Mar-1982
;		Count 32-byte packets in LEQU 32 subtotal. Place stop
;		code into scratch storage after allocation.
;
;	V02-016	LJK0129		Lawrence J. Kenah	11-Feb-1982
;		Correct error in storing file ID. Do not display any part
;		of file name if LIB$FID_TO_NAME returns an error.
;
;	V02-015	LJK0124		Lawrence J. Kenah	8-Feb-1982
;		Display of process allocation region is now invoked by
;		/MEMORY qualifier to the SHOW PROCESS command.
;
;	V02-014	LJK0121		Lawrence J. Kenah	18-Jan-1982
;		Add support for small request packet lookaside list.
;		Perform general cleanup of paging file display.
;
;	V02-013	LJK0110		Lawrence J. Kenah	5-Jan-1982
;		Do all I/O in user mode.
;		Support altered structure of nonpaged pool.
;		Add support for /FULL to pool display.
;
;	V02-012	LJK0098		Lawrence J. Kenah	8-Dec-1981
;		Add CLI interface to SHOW MEMORY to allow partial display
;		of information or full display of page file information.
;
;	V02-011	LJK0090		Lawrence J. Kenah	20-Nov-1981
;		Add display of largest block to pool display.
;		Add display of process allocation region to pool display.
;		Correct bug in traversing IRP lookaside list.
;		Use correct size of variable-sized nonpaged pool.
;		Only count bad pages that are marked as bad.
;
;	V02-010	LJK0080		Lawrence J. Kenah	11-Nov-1981
;		Change names of cells containing upper and lower limits on
;		page file index to MMG$GW_MINPFIDX and MMG$GL_MAXPFIDX.
;		Begin list with page or swap file at index 0. 
;		Reorder local symbol labels in procedure PAGEFILE.
;
;	V02-009	HRJ0028		Herb Jacobs		20-Aug-1981
;		Fix access of page swap vector to EXEC mode, now that it
;		is moved to nonpaged pool.
;
;	V02-008	LJK0044		Lawrence J. Kenah	15-Aug-1981
;		Generalize page file scan for arbitrary number of page files.
;		Eliminate references to SGN$GL_SFTMAX.
;
;	V02-007	HRJ0026		Herb Jacobs		08-Jul-1981
;		Report page file usage based on new pagefile algorithm.
;
;	V02-006	HRJ0023		Herb Jacobs		06-Jul-1981
;		Change of swapfile control block to page file control block.
;
;	V02-005	TMH0005		Tim Halvorsen		28-May-1981
;		Break down the number of swap slots in use for each swap
;		file, by examining the PCB$L_WSSWP field in each outswapped
;		process.
;
;	V02-004	LJK0020		Lawrence J. Kenah	24-Apr-1981
;		Change signature of page file in use from reservation count
;		not equal to -1 to window control block address nonzero.
;
;	V02-003	SPF0001		Steve Forgey		06-Mar-1981
;		Collect swap file information in EXEC mode.
;
;	V02-002 GRR0001 	Greg Robert		13-Oct-1980
;		Replaced references to SFT$B_SLTCNT with SFT$W_SLTCNT
;	
;	V02-001	TSC0009		Thomas S. Clark		28-Aug-1980
;		Fix bug to recognize process being in a delete pending
;		state. (SLOTS)
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	.nocross
	$DDBDEF				;DDB DEFINITIONS
	$DVIDEF				;$GETDVI REQUEST CODES
	$FCBDEF				;FCB DEFINITIONS
	$IRPDEF				;IRP DEFINITIONS
	$JPIDEF				;$GETJPI REQUEST CODES
	$NDTDEF				;ADAPTER TYPE CODES
	$PCBDEF				;PROC CTL BLK DEFINITIONS
	$PFLDEF				;PAGING FILE DEFINITIONS
	$PFNDEF				;PFN DATABASE DEFINITIONS
	$RPBDEF				;RESTART PARAMETER BLOCK DEFS
	$UCBDEF				;UCB DEFINITIONS
	$WCBDEF				;WCB DEFINITIONS
	.cross

;
; MACROS:
;

;
; MACRO TO CALL SHOW$PRINT_MSG TO TYPE A LINE(S)
;
	.MACRO	TYPEMSG	MESSAGEID,ARGLIST
		PUSHL	#MESSAGEID
		.IF	B,ARGLIST
		PUSHL	#0
		.IFF
		PUSHAL	W^ARGLIST
		.ENDC
		CALLS	#2,W^SHOW$PRINT_MSG
	.ENDM	TYPEMSG 

;
; EQUATED SYMBOLS:
;

	EVENT_FLAG = 1			; Event flag for $GETJPI use

;
; BIT FIELD DEFINITIONS FOR QUALIFIER PRESENCE LONGWORD
;

	_VIELD	MEMORY,0,<-
		<PHYS,,M>,-		; /PHYSICAL_MEMORY
		<SLOT,,M>,-		; /SLOTS
		<POOL,,M>,-		; /POOL
		<FILE,,M>,-		; /FILES
		<FULL,,M>,-		; /FULL
		<ALL,,M>,-		; /ALL
		>

; Define offset into argument list for kernel mode procedure that
; scans fixed-size (lookaside) lists.

	XRPFL = 4

; Define offsets into extended PFL control structure that exists for
; each paging or swap file currently installed.

	$DEFINI	PFL

	. = PFL$K_LENGTH

	$DEF	PFL_W_PFL_INDEX		; PFL index
		.BLKW	1		

	$DEF	PFL_W_FID		; File ID
	$DEF	PFL_W_FID_NUM		; File ID - file number
		.BLKW	1
	$DEF	PFL_W_FID_SEQ		; File ID - sequence number
		.BLKW	1
	$DEF	PFL_W_FID_RVN		; File ID - relative volume number
		.BLKW	1

	$DEF	PFL_W_UNIT		; Unit number of device
		.BLKW	1		

		.BLKW	1		; spare

	DDB_S_DEVNAMSIZ = 16		; 16-character .ASCIC device name in DDB
	PFL_S_DEVNAMSIZ = DDB_S_DEVNAMSIZ + 8	; Allow room for 5-digit unit number

	$DEF	PFL_T_DEVNAM		; Space for .ASCIC device name
		.BLKB	PFL_S_DEVNAMSIZ

	PFL_K_EXT_LENGTH = .		; Define length of extended PFL

	$DEFEND

;
; OWN STORAGE:
;
	.PSECT	SHOW$RWDATA	LONG,RD,WRT,NOEXE
;
; Define CLI call back structures
;

MEMORY_A_GETQUAL:
	$CLIREQDESC	-		; CLI request descriptor block 
		RQTYPE=CLI$K_GETQUAL,-	; to get qualifiers
		QUALST=MEMORY_A_QUALST	; pointer to qualifier list

MEMORY_A_QUALST:			; qualifier list
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHME_PHYS,-; /PHYSICAL_MEMORY
		SETLST=MEMORY_V_PHYS	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHME_SLOT,-; /SLOTS
		SETLST=MEMORY_V_SLOT	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHME_POOL,-; /POOL
		SETLST=MEMORY_V_POOL	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHME_FILE,-; /FILES
		SETLST=MEMORY_V_FILE	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHME_FULL,-; /FULL
		SETLST=MEMORY_V_FULL	;
	$CLIQUALDEF	-
		QDCODE=CLI$K_SHME_ALL,-	; /ALL
		SETLST=MEMORY_V_ALL,-	;
		TRUACT=MEMORY_ALL_PRES
	$CLIQUALDEF	END_LIST

	.ALIGN	LONG			; LOCATION COUNTER BACK TO LONGWORD 

LOCKED_CODE_RANGE:			; Range of code that executes above IPL 2
	.ADDRESS	BEGIN_LOCKED_CODE
	.ADDRESS	END_LOCKED_CODE

MEMORY_L_BITLIS:
	.LONG	0			; QUALIFIER BIT LIST

HEADER_LIST:
	.LONG	0,0			; TIME/DATE TO FORCE CURRENT TIME/DATE

;
;	MEMORY FAO ARGUMENT LIST
;

SHOW_MEM_PHY:
MEM_MB_1:
	.BLKL	1			; SPACE FOR PHYSICAL COUNT IN MB (INTEGER)
	.LONG	MEM_MB_DESC		; DESCRIPTOR FOR FRACTIONAL MB COUNT
MEM_PHY_PAGES:
	.BLKL	1			; SPACE FOR COUNT OF PHYSICAL PAGES
MEM_FREE_PAGES:
	.BLKL	1			; SPACE FOR COUNT OF FREE PAGES
MEM_USED_PAGES:
	.BLKL	1			; SPACE FOR COUNT OF PAGES IN USE
MEM_MODF_PAGES:
	.BLKL	1			; SPACE FOR COUNT OF MODIFIED PAGES

MEM_BAD_LIST:
	.BLKL	1			; SPACE FOR SIZE OF BAD PAGE LIST
MEM_BAD_PAGES:
	.BLKL	1			; SPACE FOR COUNT OF BAD PAGES
MEM_OTHER_PAGES:
	.BLKL	1			; COUNT OF OTHER PAGES ON BAD PAGE LIST

MEM_MB_DESC:
	.LONG	2			; DESCRIPTOR FOR FRACTIONAL PART
	.BLKL	1			; OF COUNT IN MB
MEM_MB_TEXT:
	.ASCII	/00  25  50  75  /	; FRACTIONS

LOCAL_MEMORY:
	.BLKL	1			; TOTAL AMOUNT OF LOCAL MEMORY
SHARED_MEMORY:
	.BLKL	1			; TOTAL AMOUNT OF MULTIPORT MEMORY

;
;	LAST PARAGRAPH FAO ARGUMENT LISTS
;

PARA_VMS:
	.BLKL	1			; SPACE FOR SIZE OF VMS

;
;	SLOT FAO ARGUMENT LIST
;

SHOW_SLOTS_LIST:
SLOTS_TOTAL:
	.BLKL	1			; SPACE FOR TOTAL # OF SLOTS
SLOTS_FREE:
	.BLKL	1			; SPACE FOR # OF FREE SLOTS
SLOTS_RES:
	.BLKL	1			; SPACE FOR # OF RESIDENT SLOTS
SLOTS_NONRES:
	.BLKL	1			; SPACE FOR # OF "NON-RESIDENT" SLOTS

; FAO argument list for variable sized pool displays

SHOW_POOL_LIST:
POOL_NAME:
	.BLKL	1			; ADDRESS OF STRING DESCRIPTOR OF AREA
SHOW_POOL_LIST2:
POOL_SIZE:
	.BLKL	1			; ADDRESS OF DESCRIPTOR OF SIZE PARAMETER
SHOW_POOL_LIST3:
SHOW_POOL_LIST4:
POOL_TOTAL:
	.BLKL	1			; SPACE FOR TOTAL SIZE OF POOL IN BYTES
POOL_TOTAL_PAGES:
	.BLKL	1			; SPACE FOR TOTAL SIZE OF POOL IN PAGES
SHOW_POOL_LIST5:
POOL_FREE:
	.BLKL	1			; SPACE FOR FREE BYTES IN POOL
POOL_INUSE:
	.BLKL	1			; SPACE FOR BYTES IN USE IN POOL
SHOW_POOL_LIST6:
POOL_MAX_BLOCK:
	.BLKL	1			; SIZE OF LARGEST BLOCK IN POOL
POOL_MIN_BLOCK:
	.BLKL	1			; SIZE OF SMALLEST BLOCK IN POOL
SHOW_POOL_LIST7:
POOL_FREE_COUNT:
	.BLKL	1			; COUNT OF NUMBER OF HOLES IN POOL
POOL_FREE_LEQU_32:
	.BLKL	1			; COUNT OF HOLES 32 BYTES OR SMALLER

; FAO parameter list for fixed-size (lookaside) list displays

SHOW_LOOK_LIST:
SHOW_LOOK_LIST3:
SHOW_LOOK_LIST4:
LOOK_LIST_NAME:
	.BLKL	1			; Descriptor for name of lookaside list
SHOW_LOOK_LIST2:
LOOK_LIST_SIZE:
	.BLKL	3			; Size of list in packets, bytes, pages
SHOW_LOOK_LIST5:
LOOK_FREE_COUNT:
	.BLKL	1			; Number of free packets
LOOK_FREE_BYTES:
	.BLKL	1			; Number of free bytes
SHOW_LOOK_LIST6:
LOOK_INUSE_COUNT:
	.BLKL	1			; Number of packets being used
LOOK_INUSE_BYTES:
	.BLKL	1			; Number of bytes in use
SHOW_LOOK_LIST7:
LOOK_SIZE_DESC:
	.BLKL	1			; Descriptor of parameter for block size
LOOK_BLOCK_SIZE:
	.BLKL	1			; Size of blocks in list
SHOW_LOOK_LIST8:
LOOK_BLOCK_MIN:
	.BLKL	1			; Lower limit on blocks allocated
					;  from this list
LOOK_CMKRNL_ARGLIST:
	.LONG	1			; A single parameter that contains
	.BLKL	1			;  the address of the listhead

; The next three longwords are used to pass information related to the
; initial and maximum sizes of each lookaside list into the common
; output routine.

LOOK_SIZE_ARRAY:
	.BLKL	1			; Descriptor for parameter name
	.BLKL	1			; Initial size of list
	.BLKL	1			; Maximum size of list

; Text descriptors that describe each portion of dynamic memory

	.PSECT	SHOW$MSG_TEXT	BYTE,RD,NOWRT,NOEXE

NPAGEDYN_DESC:
	.ASCID	\Nonpaged Dynamic Memory      \

PAGEDYN_DESC:
	.ASCID	\Paged Dynamic Memory         \

PRCALLREG_DESC:
	.ASCID	\Process Dynamic Memory Area  \

BYTES_SIZE_DESC:
	.ASCID	\bytes\

PAGEDYN_SIZE_DESC:
	.ASCID	\PAGEDYN\

SRP_NAME_DESC:
	.ASCID	\SRP\

SRPLIST_DESC:
	.ASCID	\Small Packet (SRP)\

SRP_SIZE_DESC:
	.ASCID	\SRPSIZE\

IRP_NAME_DESC:
	.ASCID	\IRP\

IRPLIST_DESC:
	.ASCID	\I/O Request Packet (IRP)\

IRP_SIZE_DESC:
	.ASCID	\fixed\

LRP_NAME_DESC:
	.ASCID	\LRP\

LRPLIST_DESC:
	.ASCID	\Large Packet (LRP)\

LRP_SIZE_DESC:
	.ASCID	\LRPSIZE + 64\

	.PSECT	SHOW$RWDATA	LONG,RD,WRT,NOEXE

;	PAGING FILE FAO ARGUMENT LIST

SHOW_PAGE_LIST:
	.ADDRESS	FILE_NAME_DESC	; DESCRIPTOR FOR FILENAME
SHOW_PAGE_LIST2:
PAGE_FREE:
	.BLKL	1			; SPACE FOR NUMBER OF FREE PAGES
PAGE_USED:
	.BLKL	1			; SPACE FOR NUMBER OF PAGES IN USE
SHOW_PAGE_LIST3:
PAGE_TOTAL:
	.BLKL	1			; SPACE FOR SIZE OF PAGING FILE
PAGE_PFL_INDEX:
	.BLKL	1			; PAGE/SWAP FILE INDEX
SHOW_PAGE_LIST4:
PAGE_FULL_SWAP_COUNT:
	.BLKL	1			; COUNT OF PROCESSES SWAPPING TO FILE
PAGE_FULL_PAGING_COUNT:
	.BLKL	1			; COUNT OF PROCESSES PAGING TO FILE
SHOW_PAGE_LIST5:
PAGE_FLAG:
	.ADDRESS	SWAP_INDIC_DESC	; DESCRIPTOR FOR PAGING INDICATOR

;
;	FILENAME SECTION
;

DEVICE_NAME_DESC:			; Descriptor for device name passed
	.BLKL		2		;  to LIB$FID_TO_NAME and $GETDVI

	FILE_NAME_SIZE = 255
FILE_NAME_ADDR:
	.BLKB	FILE_NAME_SIZE
FILE_NAME_DESC:				; Descriptor for returned filename
	.LONG		FILE_NAME_SIZE	;  from LIB$FID_TO_NAME routine
	.ADDRESS	FILE_NAME_ADDR	;  and passed to output routines

	DEVICE_NAME_SIZE = 64		; Alternate output buffer for
DEVICE_NAME_ADDR:			;  $GETDVI. Contents used if no
	.BLKB	DEVICE_NAME_SIZE	;  LOGVOLNAM returned.


SCRATCH_DESC:				; Scratch string descriptor 
	.BLKL	2			;  used by $FAO and $TRNLOG

; Space for returned length from LIB$FID_TO_NAME routine. Also used by
; $FAO, $GETDVI, and $TRNLOG.

RETURN_LENGTH:
	.BLKL	1

;  Static pieces of default file name

DEFAULT_DIRECTORY_NAME:			; Device name is loaded by $GETDVI
	.ASCID	/SYSEXE]/		; ":]" are loaded dynamically
DEFAULT_FILE_NAME:			; First 4 characters may become 
	.ASCID	/FILE.SYS/		;  either "PAGE" or "SWAP"

	.ALIGN	LONG			; Location counter back to longword 

PFL_TABLE_SIZE:
	.BLKL	1			; Size of scratch area
PFL_TABLE_ADDR:
	.BLKL	1			; Address of scratch area for PFLs
SWAP_FILE_COUNT:
	.BLKL	1			; Maximum number of swap files (SWPFILCNT)
PAGE_FILE_COUNT:
	.BLKL	1			; Maximum number of paging files (PAGFILCNT)
SWAP_FILE_TABLE:			; Address of swap file usage array
	.BLKL	1			; (PAGFILCNT + SWPFILCNT entries long)
PAGE_FILE_TABLE:			; Address of paging file usage array
	.BLKL	1			; (PAGFILCNT + SWPFILCNT entries long)

; Text descriptors that distinguish files that are used for paging
; and swapping from files used only for swapping.

	.PSECT	SHOW$MSG_TEXT	BYTE,RD,NOWRT,NOEXE

SWAP_INDIC_DESC:
	.ASCID	/This file is used exclusively for swapping./
PAGE_INDIC_DESC:
	.ASCID	/This file can be used for either paging or swapping./

	.PSECT	SHOW$RWDATA	LONG,RD,WRT,NOEXE

; Data area for call to $GETJPI to retrieve page and swap file data

PAGE_FILE_LOC:
	.BLKL	1			; Paging file address
PAGE_FILE_INDEX = PAGE_FILE_LOC + 3

SWAP_FILE_LOC:
	.BLKL	1			; Swap file location
SWAP_FILE_INDEX = SWAP_FILE_LOC + 3

GETJPI_STATUS:
	.BLKQ	1			; Status block for asynchronous $GETJPI

PID:
	.LONG	-1			; Wild card PID for $GETJPI

; Argument list for call to LIB$FID_TO_NAME

FID_TO_NAME_ARG_LIST:
	.LONG		4		; Argument count
	.ADDRESS	DEVICE_NAME_DESC	; Descriptor for device name
FID_TO_NAME_FID_ADDR:
	.BLKL		1		; Space for FID address
	.ADDRESS	FILE_NAME_DESC	; File name descriptor
	.ADDRESS	RETURN_LENGTH	; File name length goes here

; This FAO list is required to convert the unit number to an unsigned 
; decimal integer. The unit number itself is stored in the $FAO
; argument list at execution time but we must reserve space for it
; at assembly time so that the $FAO argument is the correct length.

FAO_LIST:
	$FAO	CTRSTR=FAO_CONTROL_STRING,-
		OUTLEN=RETURN_LENGTH,-
		OUTBUF=SCRATCH_DESC,-
		P1=0

	.PSECT	SHOW$RODATA	LONG,RD,NOWRT,NOEXE

JPI_ITEM_LIST:
	.WORD		4		; Destination is a longword
	.WORD		JPI$_PAGFILLOC	; Request paging file address
	.ADDRESS	PAGE_FILE_LOC	; Store result here
	.LONG		0		; Do not return length

	.WORD		4		; Destination is a longword
	.WORD		JPI$_SWPFILLOC	; Request swap file location
	.ADDRESS	SWAP_FILE_LOC	; Store result here
	.LONG		0		; Do not return length

	.LONG		0		; End of $GETJPI request list

GETJPI_LIST:
	$GETJPI		EFN=EVENT_FLAG,-
			PIDADR=PID,-
			ITMLST=JPI_ITEM_LIST,-
			IOSB=GETJPI_STATUS

DVI_ITEM_LIST:
	.WORD		FILE_NAME_SIZE	
	.WORD		DVI$_LOGVOLNAM	; Request logical volume name
	.ADDRESS	FILE_NAME_ADDR	; Store string result here
	.ADDRESS	FILE_NAME_DESC	;  and size here

	.WORD		DEVICE_NAME_SIZE
	.WORD		DVI$_DEVNAM	; Request logical volume name
	.ADDRESS	DEVICE_NAME_ADDR ; Store string result here
	.ADDRESS	RETURN_LENGTH	;  and size here

	.LONG		0		; End of $GETDVI request list

GETDVI_LIST:
	$GETDVI		EFN=EVENT_FLAG,-
			DEVNAM=DEVICE_NAME_DESC,-
			ITMLST=DVI_ITEM_LIST

FAO_CONTROL_STRING:
	.ASCID		/!UW/

TOPSYS_DESC:
	.ASCID		/SYS$TOPSYS/

TRNLOG_LIST:
	$TRNLOG		LOGNAM=TOPSYS_DESC,-
			RSLLEN=RETURN_LENGTH,-
			RSLBUF=SCRATCH_DESC,-
			DSBMSK=<^B110>	; Only search system name table

	.PAGE
	.SBTTL	SHOW$MEMORY Show System Memory Resources
;++
; Functional Description:
;
;	This routine retrieves information about various system resources,
;	formats and prints it on SYS$OUTPUT.
;
; Calling Sequence:
;
;	CALLS	#0,SHOW$MEMORY
;
;		The routine is actually called by the CLI as a result of
;		parsing parameter MEMORY on the SHOW command. 
;
; Input Parameters:
;
;	None
;
; Implicit Input:
;
;	Qualifiers specified on the SHOW MEMORY command
;
; Output Parameters:
;
;	None
;
; Implicit Output:
;
;	Memory resource information is displayed on SYS$OUTPUT.
;
; Completion Codes:
;
;	SS$_NORMAL		Normal completion
;	SS$_LKWSETFUL		Error in locking data for elevated IPL
;--

	.DEFAULT	DISPLACEMENT,WORD	; Use W^ addressing as default

	.PSECT	SHOW$CODE BYTE,RD,NOWRT,EXE

	.ENTRY	SHOW$MEMORY,0		; SHOW MEMORY resources routine

	PUSHAL	MEMORY_L_BITLIS		; Pass address of qualifier bit list,
	PUSHAL	SHOW$A_CLIWORK		;  CLI work area,
	PUSHAL	MEMORY_A_GETQUAL	;  and address of qualifier descriptors
	CALLS	#3,@CLI$A_UTILSERV(AP)	; to the CLI utility service routine
	MOVL	SHOW$L_STATUS,R0	; Use this as status
	BLBS	R0,5$			; Continue if successful parse
	BRW	90$			; Quit if parsing error occurred

5$:	BICL3	#MEMORY_M_FULL,MEMORY_L_BITLIS,R0 ; Anything other than /FULL?
	BNEQ	10$			; Branch if any other qualifier present
	MOVL	#<MEMORY_M_PHYS!-	; Default is these four displays
		  MEMORY_M_SLOT!-
		  MEMORY_M_POOL!-
		  MEMORY_M_FILE-
		 >,MEMORY_L_BITLIS	; Set all bits except /FULL

;  Lock down code that will be accessed at elevated IPL.

10$:	$LKWSET_S	LOCKED_CODE_RANGE	; Lock code in working set
	BLBC	R0,90$			; Exit if error occurred

;  Print header line for all displays

	TYPEMSG	SHOW$_MEM_HEAD1,HEADER_LIST

; Show the information based on the actual or implied setting of each
; qualifier bit in the control mask.

	BBC	#MEMORY_V_PHYS,MEMORY_L_BITLIS,20$	; /PHYSICAL_MEMORY
	CALLS	#0,MEMORY		; Print physical memory usage
20$:	BBC	#MEMORY_V_SLOT,MEMORY_L_BITLIS,30$	; /SLOTS
	CALLS	#0,SLOTS		; Print slot usage
30$:	BBC	#MEMORY_V_POOL,MEMORY_L_BITLIS,40$	; /POOL
	CALLS	#0,LOOKASIDE	; Print fixed-size pool usage
	CALLS	#0,POOL		; Print variable-sized pool usage
40$:	BBC	#MEMORY_V_FILE,MEMORY_L_BITLIS,50$	; /PAGEFILE
	CALLS	#0,PAGEFILE		; Print paging file usage
50$:	BBC	#MEMORY_V_PHYS,MEMORY_L_BITLIS,60$	; /PHYSICAL_MEMORY
	TYPEMSG	SHOW$_MEM_PARA1,PARA_VMS ; Print bottom paragraph
60$:	MOVZWL	#SS$_NORMAL,R0		; Store status
90$:	MOVL	R0,SHOW$L_STATUS	; Pass status to SHOW dispatcher
	RET				;  and exit

	.PAGE
	.SUBTITLE	MEMORY_ALL_PRES		Action Routine for /ALL Qualifier
;+
; This routine is called by the CLI parse routines if the /ALL qualifier
; is present on the SHOW MEMORY command. Its only action is to set the
; remaining bits in the qualifier status longword.
;-

MEMORY_ALL_PRES:
	.WORD	0			; Save nothing
	BISL2	#<MEMORY_M_PHYS!-
		  MEMORY_M_SLOT!-
		  MEMORY_M_POOL!-
		  MEMORY_M_FILE-
		 >,MEMORY_L_BITLIS	; Set all bits except /FULL
	MOVZWL	#SS$_NORMAL,R0		; Report success
	MOVL	R0,SHOW$L_STATUS	; Set global success status
	RET

	.PAGE
	.SBTTL	SHOW MEMORY USAGE
;
;	SHOW PHYSICAL MEMORY
;
;	THIS ROUTINE DISPLAYS INFORMATION ABOUT THE SYSTEM MEMORY.
;	THE TOTAL NUMBER OF PAGES AVAILABLE TO THE SYSTEM IS DISPLAYED
;	BOTH AS A NUMBER OF PAGES AND IN APPROXIMATE MEGABYTES. THE
;	NUMBER OF PAGES ON THE MODIFIED AND FREE LIST ARE ALSO SHOWN.
;	THE NUMBER OF PAGES IN USE BY BOTH THE SYSTEM AND USERS ARE SHOWN,
;	AND THE NUMBER OF PAGES ALWAYS IN USE BY THE SYSTEM IS DISPLAYED
;	IN THE CONCLUDING PARAGRAPH. IF THERE SHOULD BE BAD MEMORY,
;	AN ADDITIONAL LINE IS PRINTED GIVING THE NUMBER OF BAD PAGES.
;

MEMORY:
	.WORD	^M<R2,R3,R4>		; Save some registers
	TYPEMSG	SHOW$_MEM_MEMO1				; PRINT HEADER
	$CMEXEC_S	SIZE_MEMORY	; Calculate physical memory size
	MOVL	G^SCH$GL_FREECNT,MEM_FREE_PAGES	; GET # OF FREE PAGES
	MOVL	G^SCH$GL_MFYCNT,MEM_MODF_PAGES	; GET # OF MODIFIED PAGES
	CMPL	MEM_PHY_PAGES,G^MMG$GL_PHYPGCNT	; MINIMIZE PHYSICAL PAGE
	BLEQU	10$					; COUNT WITH SYSGEN SPECIFIED
	MOVL	G^MMG$GL_PHYPGCNT,MEM_PHY_PAGES	; PAGE COUNT
10$:	SUBL3	MEM_FREE_PAGES,MEM_PHY_PAGES,MEM_USED_PAGES
	SUBL2	MEM_MODF_PAGES,MEM_USED_PAGES	; GET # OF PAGES IN USE
	SUBL3	G^PFN$GL_PHYPGCNT,MEM_PHY_PAGES,PARA_VMS
	ASHL	#-11,MEM_PHY_PAGES,MEM_MB_1		; CONVERT COUNT OF
	ASHL	#-9,MEM_PHY_PAGES,R2			; PHYSICAL PAGES TO
	MULL3	MEM_MB_1,#4,R3				; MEGABYTES
	SUBL2	R3,R2
	MOVAL	MEM_MB_TEXT[R2],MEM_MB_DESC+4
	TYPEMSG	SHOW$_MEM_MEMO2,SHOW_MEM_PHY		; TYPE TEXT
	MOVL	G^SCH$GL_FREECNT+<4*PFN$C_BADPAGLST>,R4	; ANY BAD PAGES?
	BEQL	20$
	MOVL	R4,MEM_BAD_LIST
	BSBW	SCAN_BAD_LIST			; COUNT "REALLY" BAD PAGES
	MOVL	R3,MEM_BAD_PAGES		; STORE COUNT FOR FAO
	SUBL3	R3,R4,MEM_OTHER_PAGES		; STORE COUNT OF "OTHER" PAGES
	TYPEMSG	SHOW$_MEM_MEMO3,MEM_BAD_LIST	; THEN TELL THE USER
20$:	RET

	.PAGE
	.SUBTITLE	SIZE_MEMORY	Get Amount of Physical Memory

;+
;	SIZE_MEMORY	Get Amount of Physical Memory
;
;  This routine uses the memory descriptors in the Restart Parameter Block
;  to determine the amount of physical memory in use. A check is made to
;  see if multiport memory should be counted as local memory.
;
;  Calling sequence:
;
;	CALLS	#0,SIZE_MEMORY
;
;  Input parameters:
;
;	None
;
;  Implicit Input:
;
;	Memory descriptors in RPB
;
;  Output parameters:
;
;	LOCAL_MEMORY	Total memory in local memory controllers
;
;	SHARED_MEMORY	Total memory in multiport emmory controllers
;
;	MEM_PHY_PAGES	Total amount of physical memory in use by system
;			(This total does not include multiport memory 
;			 being used as shared memory.)
;
;-

SIZE_MEMORY:
	.WORD	^M<R2,R3,R4>		; Save some registers
	MOVL	G^EXE$GL_CONFREG,R0	; Get address of TR/adapter type array
	MOVL	G^EXE$GL_RPB,R1				; GET ADDR OF RPB
	MOVAL	RPB$L_MEMDSC(R1),R2			; GET ADDR OF MEMORY DESCRIPTORS
	CLRL	LOCAL_MEMORY				; INIT PAGE COUNT
	CLRL	SHARED_MEMORY				; INIT PAGE COUNT
10$:	TSTL	(R2)					; END OF MEMDSC LIST?
	BEQL	40$					; YES - GO PRINT INFO
	EXTZV	#RPB$V_TR,#RPB$S_TR,(R2),R3		; GET TR NUMBER
	MOVZBL	(R0)[R3],R3				; CONVERT TO ADAPTER TYPE
	EXTZV	#RPB$V_PAGCNT,#RPB$S_PAGCNT,(R2),R4	; GET PAGE COUNT

; The following set of assumptions state that all multiport memory adapter
; type codes are bounded by NDT$_MPM0 and NDT$_MPM3 and that no adapter
; type codes in this range represent anything other than multiport memory.

	ASSUME	NDT$_MPM0 LT NDT$_MPM1
	ASSUME	NDT$_MPM1 LT NDT$_MPM2
	ASSUME	NDT$_MPM2 LT NDT$_MPM3

	CMPB	R3,#NDT$_MPM0		; Is adapter number below MPM range
	BLSSU	20$			; If so, this is local memory
	CMPB	R3,#NDT$_MPM3		; Is adapter number above MPM range
	BGTRU	20$			; If so, this is also local memory
	ADDL2	R4,SHARED_MEMORY	; Otherwise, this is multiport memory
	BRB	30$			; Go to end of loop

20$:	ADDL2	R4,LOCAL_MEMORY		; This is local memory
30$:	ADDL2	#RPB$C_MEMDSCSIZ,R2	; Point to next memory descriptor
	BRB	10$			;  and go back to top of loop

; There are four cases that can occur here.
;
; 1.  There are no multiport memory controllers on the system.
;
; 2.  Multiport memory is being used as global shared memory.
;
; 3.  Multiport memory is being used as local memory. This case is 
;     distinguished by RPB$V_USEMPM being set in the RPB copy of R5.
;
; 4.  Only multiport memory is being used as local memory. Any memory
;     in local controllers is ignored. This is the multiprocessor
;     configuration. This case is distinguished by RPB$V_USEMPM 
;     being set in the RPB copy of R5.

40$:	BBS	#RPB$V_MPM,RPB$L_BOOTR5(R1),50$ ; Multiprocessor configuration?
	MOVL	LOCAL_MEMORY,MEM_PHY_PAGES	; Local memory is always counted
	BBC	#RPB$V_USEMPM,RPB$L_BOOTR5(R1),60$ ; Also count shared memory?
	ADDL2	SHARED_MEMORY,MEM_PHY_PAGES	; Add it in if using as local memory
	BRB	60$			;  and return

50$:	MOVL	SHARED_MEMORY,MEM_PHY_PAGES	; Only count shared memory
60$:	MOVZWL	#SS$_NORMAL,R0		; Indicate success
	RET				;  and return

	.PAGE
	.SUBTITLE	SCAN_BAD_LIST	Scan Bad Page List

;+
;	SCAN_BAD_LIST	Count pages on bad page list that are marked bad
;
;  This routine looks at all pages on the bad page list to distinguish those
;  pages that exhibit memory errors (are marked as bad) form those pages
;  placed there due to an I/O error.
;
;  Calling sequence:
;
;	BSBW	SCAN_BAD_LIST
;
;  Input parameters:
;
;	None
;
;  Implicit Input:
;
;	PFN data base listheads
;
;  Output parameter:
;
;	R3	Count of pages marked as bad
;
;-

SCAN_BAD_LIST:
	CLRL	R3			; Initialize bad page counter
	MOVL	G^<PFN$AL_HEAD+<4*PFN$C_BADPAGLST>>,R0	; Get first bad PFN
	BEQL	30$			; Zero implies none (shouldn't happen)
	MOVL	G^PFN$Ax_FLINK,R1	; Forward link array listhead to R1
	MOVL	G^PFN$AB_TYPE,R2	; PFN STATE array listhead to R2
10$:	BBC	#PFN$V_BADPAG,(R2)[R0],20$	; Is this page really bad?
	INCL	R3			; Count another bad page
20$:		PFN_REFERENCE	-
	MOVZWL	<(R1)[R0],R0>,-		; Follow FLINK to next PFN
		LONG_OPCODE=MOVL,-
		IMAGE=SHOW_MEMORY
	BNEQ	10$			; To top of loop if another PFN
30$:	RSB

	.PAGE
	.SBTTL	SHOW SLOT USAGE
;
;	SHOW PROCESS AND BALANCE SLOT USAGE
;
;	THIS ROUTINE DISPLAYS INFORMATION ABOUT THE PROCESS AND BALANCE
;	SLOTS. THE TOTAL NUMBER OF EACH TYPE OF SLOT IS SHOWN. THE NUMBER
;	OF FREE SLOTS IS DISPLAYED. THE SLOTS IN USE ARE BROKEN DOWN INTO
;	TWO CATAGORIES: RESIDENT AND NON-RESIDENT. A NON-RESIDENT BALANCE
;	SLOT IS ONE FOR WHICH NOT ALL OF THE PROCESSES WORKING SET IS 
;	RESIDENT (E.G. SWAPPED BUT WAITING FOR I/O)
;

SLOTS:
	.WORD	0			; Save nothing
	TYPEMSG	SHOW$_MEM_SLOT1		; Print header line

; Show usage of PCB vector

	$CMEXEC_S	ROUTIN=SLOTS_PCBVEC	; Gather the PCB vector data
	TYPEMSG	SHOW$_MEM_SLOT2,SHOW_SLOTS_LIST	;  and print it

; Show balance slot usage

	$CMEXEC_S	ROUTIN=SLOTS_BALANCE	; Gather the balance slot data
	TYPEMSG	SHOW$_MEM_SLOT3,SHOW_SLOTS_LIST	;  and print it
	MOVZWL	#SS$_NORMAL,R0			; Load success status
	RET					;  and return

	.PAGE
	.SUBTITLE	SLOTS_PCBVEC	Compute occupation of PCB vector

;+
;	SLOTS_PCBVEC	Compute occupation of PCB vector
;
;  This routine determines the number of processes that occupy the PCB
;  vector and the number of those processes that are currently resident.
;
;  Calling sequence:
;
;	CALLS	#0,SLOTS_PCBVEC
;
;  Input parameter:
;
;	SCH$GL_PCBVEC	Pointer to PCB vector
;
;  Output parameters:
;
;	SLOTS_TOTAL	Number of slots in the vector (MAXPROCESSCNT)
;
;	SLOTS_FREE	Number of unused slots in the vector
;
;	SLOTS_RES	Number of slots that are occupied by processes
;			that are resident (PCB$V_RES set in PCB$L_STS)
;
;	SLOTS_NONRES	Number of slots that are occupied by processes
;			that are outswapped (PCB$V_RES set in PCB$L_STS)
;
;-

SLOTS_PCBVEC:
	.WORD	^M<R2,R3,R4,R5>		; Save some registers
	MOVZWL	G^SCH$GW_PROCLIM,SLOTS_TOTAL	; GET TOTAL # OF SLOTS
	MOVZWL	G^SCH$GW_PROCCNT,R2
	ADDL2	#2,R2				; INCLUDE NULL AND SWAPPER
	SUBL3	R2,SLOTS_TOTAL,SLOTS_FREE	; GET # OF FREE SLOTS
	MOVL	G^SCH$GL_PCBVEC,R2		; GET BASE ADDR OF PIX ARRAY
	MOVAL	G^SCH$GL_NULLPCB,R3		; SAVE NULL PCB
	MOVZWL	G^SCH$GL_SWPPID,R5		; GET SWAPPER'S PIX
	INCL	R5				; START WITH NEXT SLOT
	MOVL	R5,SLOTS_RES			; INITIALIZE COUNTS
	CLRL	SLOTS_NONRES
10$:	MOVL	(R2)[R5],R4			; GET PCB ADDRESS
	CMPL	R4,R3				; IS THIS THE NULL PCB?
	BEQLU	30$				; YES - IGNORE IT
	ASSUME	PCB$V_RES EQ 0
	BLBC	PCB$L_STS(R4),20$		; CHECK STATUS
	INCL	SLOTS_RES			; RESIDENT-BUMP COUNTER
	BRB	30$
20$:	INCL	SLOTS_NONRES			; NONRESIDENT-BUMP COUNTER
	MOVZBL	PCB$L_WSSWP+3(R4),R0		; GET SWAP FILE NUMBER
30$:	AOBLEQ	G^SCH$GL_MAXPIX,R5,10$		; LOOP FOR ALL PIX
	MOVZWL	#SS$_NORMAL,R0
	RET

	.PAGE
	.SUBTITLE	SLOTS_BALANCE	Compute occupation of PCB vector

;+
;	SLOTS_BALANCE	Compute occupation of PCB vector
;
;  This routine determines the number of processes that occupy the PCB
;  vector and the number of those processes that are currently resident.
;
;  Calling sequence:
;
;	CALLS	#0,SLOTS_BALANCE
;
;  Input parameters:
;
;	SCH$GL_PCBVEC	Pointer to PCB vector
;	PHV$GL_PIXBAS	Address of process index array associated with
;			process header vector
;
;  Output parameters:
;
;	SLOTS_TOTAL	Number of balance slots (BALSETCNT)
;
;	SLOTS_FREE	Number of unused blance slots 
;
;	SLOTS_RES	Number of balance slots that are occupied by processes
;			that are resident (PCB$V_PHDRES set in PCB$L_STS)
;
;	SLOTS_NONRES	Number of balance slots that are occupied by processes
;			that are outswapped (PCB$V_PHDRES set in PCB$L_STS)
;			An outswapped process that still occupies a balance
;			slot is a process whose process body is outswapped
;			but whose process header is still resident.
;-

SLOTS_BALANCE:
	.WORD	^M<R2,R3,R4,R5>			; Save some registers
	MOVL	G^SGN$GL_BALSETCT,SLOTS_TOTAL	; GET # OF SLOTS
	CLRL	SLOTS_FREE			; INITIALIZE COUNTERS
	CLRL	SLOTS_RES
	CLRL	SLOTS_NONRES
	MOVL	G^SCH$GL_PCBVEC,R5		; GET BASE OF PCB ADDRS
	MOVL	G^PHV$GL_PIXBAS,R2		; GET BASE OF PIX ARRAY
	CLRL	R3				; START AT SLOT 0
10$:	CVTWL	(R2)[R3],R4			; GET PIX POINTER
	BGTR	20$				; IS SLOT IN USE?
	INCL	SLOTS_FREE			; NO - COUNT IT AS FREE
	BRB	40$				; AND CONTINUE
20$:	MOVL	(R5)[R4],R4			; GET PCB ADDRESS
	ASSUME	PCB$V_RES EQ 0
	BLBC	PCB$L_STS(R4),30$		; IS PROCESS RESIDENT?
	INCL	SLOTS_RES			; YES-COUNT IT AS SUCH
	BRB	40$
30$:	INCL	SLOTS_NONRES			; NO-COUNT AS NON-RES
40$:	AOBLSS	SLOTS_TOTAL,R3,10$		; LOOP FOR ALL PIX
	MOVZWL	#SS$_NORMAL,R0
	RET

	.PAGE
	.SUBTITLE	LOOKASIDE - Display Routine for Lookaside Lists

;-
; Functional Description:
;
;	This routine displays nonpaged pool statistics for fixed-size block 
;	lists. These include the small packet (SRP) lookaside list, the I/O 
;	request packet (IRP) list, and the large packet (LRP) lookaside list.
;
; Input Parameters:
;
;	None
;
; Implicit Input:
;
;	Listheads for three lookaside lists
;
; Output Parameters:
;
;	None
;
; Implicit Output:
;
;	Three lookaside list displays are written to SYS$OUTPUT
;-

LOOKASIDE:
	.WORD	^M<R2,R3>		; Save some registers
	BBS	#MEMORY_V_FULL,MEMORY_L_BITLIS,10$ ; Skip header in full display
	TYPEMSG	SHOW$_MEM_LOOK1			; Print header line

;  Get fixed-length nonpaged pool statistics. Do small packet (SRP)
;  lookaside list first.

10$:	MOVAL	G^IOC$GL_SRPFL,LOOK_CMKRNL_ARGLIST+XRPFL	; Listhead address
	$CMKRNL_S	-		; Scan the list 
		ROUTIN=LOOK_XRPLIST,-
		ARGLST=LOOK_CMKRNL_ARGLIST
	MOVAW	SRPLIST_DESC,LOOK_LIST_NAME	; Add an identifier
	MOVL	G^IOC$GL_SRPCNT,LOOK_LIST_SIZE	; Get current list size
	MOVL	G^IOC$GL_SRPSIZE,R2		; Pass block size in R2
	MOVAW	SRP_SIZE_DESC,LOOK_SIZE_DESC	; SYSGEN parameter name for size
	MOVL	G^IOC$GL_SRPMIN,LOOK_BLOCK_MIN	; Lower limit for allocation

	MOVAL	LOOK_SIZE_ARRAY,R3		; Address of auxiliary array
	MOVAW	SRP_NAME_DESC,(R3)		; Descriptor for list name
	MOVL	G^SGN$GL_SRPCNT,4(R3)		; Initial list size
	MOVL	G^SGN$GL_SRPCNTV,8(R3)		; Maximum list size
	BSBW	DISPLAY_LOOK			; Display SRP statistics

; Gather statistics for I/O Request Packet (IRP) Lookaside List

	MOVAL	G^IOC$GL_IRPFL,LOOK_CMKRNL_ARGLIST+XRPFL	; Listhead address
	$CMKRNL_S	-		; Scan the list 
		ROUTIN=LOOK_XRPLIST,-
		ARGLST=LOOK_CMKRNL_ARGLIST
	MOVAW	IRPLIST_DESC,LOOK_LIST_NAME	; Add an identifier
	MOVL	G^IOC$GL_IRPCNT,LOOK_LIST_SIZE	; Get current list size
	MOVL	#<IRP$K_LENGTH+EXE$C_ALCGRNMSK>&^C<EXE$C_ALCGRNMSK>,R2
						; Pass block size in R2
	MOVAW	IRP_SIZE_DESC,LOOK_SIZE_DESC	; Descriptor for "fixed"
	MOVL	G^IOC$GL_IRPMIN,LOOK_BLOCK_MIN	; Lower limit for allocation

	MOVAL	LOOK_SIZE_ARRAY,R3		; Address of auxiliary array
	MOVAW	IRP_NAME_DESC,(R3)		; Descriptor for list name
	MOVL	G^SGN$GL_IRPCNT,4(R3)		; Initial list size
	MOVL	G^SGN$GL_IRPCNTV,8(R3)		; Maximum list size
	BSBW	DISPLAY_LOOK			; Display IRP statistics

;  Finally, perform the same steps for the large packet (LRP) lookaside list

	MOVAL	G^IOC$GL_LRPFL,LOOK_CMKRNL_ARGLIST+XRPFL	; Listhead address
	$CMKRNL_S	-		; Scan the list 
		ROUTIN=LOOK_XRPLIST,-
		ARGLST=LOOK_CMKRNL_ARGLIST
	MOVAW	LRPLIST_DESC,LOOK_LIST_NAME	; Add an identifier
	MOVL	G^IOC$GL_LRPCNT,LOOK_LIST_SIZE	; Get current list size
	MOVL	G^IOC$GL_LRPSIZE,R2		; Pass block size in R2
	MOVAW	LRP_SIZE_DESC,LOOK_SIZE_DESC	; Descriptor for "LRPSIZE + 64"
	MOVL	G^IOC$GL_LRPMIN,LOOK_BLOCK_MIN	; Lower limit for allocation

	MOVAL	LOOK_SIZE_ARRAY,R3		; Address of auxiliary array
	MOVAW	LRP_NAME_DESC,(R3)		; Descriptor for list name
	MOVL	G^SGN$GL_LRPCNT,4(R3)		; Initial list size
	MOVL	G^SGN$GL_LRPCNTV,8(R3)		; Maximum list size
	BSBW	DISPLAY_LOOK			; Display LRP statistics

	MOVZWL	#SS$_NORMAL,R0			; Signal success
	RET					;  and return

 	.PAGE
	.SUBTITLE	POOL_XRPLIST	Scan a Lookaside List

;+
; Functional Description:
;
;	This routine counts the number of free blocks on the lookaside 
;	list pointed to by the input parameter.
;
;  Calling sequence:
;
;	CALLS	#1,POOL_IRPLIST
;
;  Input parameter:
;
;	XRPFL(AP)	Listhead of doubly linked list
;
;  Output parameter:
;
;	LOOK_FREE_COUNT	Number of free blocks in this list
;-

BEGIN_LOCKED_CODE:			; The following code executes above IPL 2

LOOK_XRPLIST:
	.WORD	^M<R2,R3>		; Save some registers
	MOVL	XRPFL(AP),R2		; Get address of forward link
	DSBINT	G^EXE$GL_NONPAGED	; Set IPL for pool access
	BSBW	SCAN_DOUBLY_LINKED_LIST	; Count number of blocks in list
	ENBINT				; Enable interrupts
	MOVL	R3,LOOK_FREE_COUNT	; Store number of free blocks
	MOVZWL	#SS$_NORMAL,R0
	RET

	.PAGE
	.SUBTITLE	SCAN_DOUBLY_LINKED_LIST	Scan doubly linked list

;+
;	SCAN_DOUBLY_LINKED_LIST	Scan a of fixed-sized blocks
;
;  This routine scans a doubly linked list of fixed-size blocks and 
;  returns the number of blocks in the list.
;
;  Calling sequence:
;
;	BSBW	SCAN_DOUBLY_LINKED_LIST
;
;  Input parameter:
;
;	R2	Address of listhead for list
;
;  Output parameter:
;
;	R3	Number of blocks in list
;
;  Side effect:
;
;	The contents of R1 are modified
;
;  This routine assumes that the caller has taken whatever synchronization
;  measures are necessary for the pool area being scanned.
;-

SCAN_DOUBLY_LINKED_LIST:
	CLRL	R3			; Set counter to zero
	MOVL	R2,R1			; Make a working copy
10$:	MOVL	(R1),R1			; Get address of next block
	CMPL	R1,R2			; At end of list yet?
	BEQL	20$			; Equal implies end of list
	INCL	R3			; Indicate another block
	BRB	10$			;  and go get the next one

20$:	RSB				; Return to caller

	.PAGE
	.SUBTITLE	DISPLAY_LOOK Output Routine for Lookaside List Displays

;+
; Functional Description:
;
;	This routine performs the common output and display functions for
;	the three fixed-sized dynamic memory areas. The routine decides
;	whether a normal or full display is requested. 
;
; Calling Sequence:
;
;	BSBW	DISPLAY_LOOK
;
; Input Parameters:
;
;	R2	Size of packets in this list
;
;	R3	Address of three-longword array containing information
;		that describes the initial and maximum sizes of the list
;
; Implicit Input:
;
;	Setting of MEMORY_V_FULL bit in MEMORY_L_BITLIS
;
;	Contents of cells in FAO parameter list for lookaside list displays
;
; Output Parameters:
;
;	Several cells in FAO parameter list for lookaside list displays
;
;		LOOK_LIST_SIZE		Size in packets, bytes, and pages
;		LOOK_FREE_BYTES		/FULL display only
;		LOOK_INUSE_COUNT
;		LOOK_INUSE_BYTES	/FULL display only
;		LOOK_BLOCK_SIZE		Passed into this routine in R2
;		
; Implicit Output:
;
;	Displays of usage statistics for specified lookaside list 
;	are written to SYS$OUTPUT.
;-

DISPLAY_LOOK:
	MOVL	R2,LOOK_BLOCK_SIZE	; Store block size in parameter list
	SUBL3	LOOK_FREE_COUNT,LOOK_LIST_SIZE,LOOK_INUSE_COUNT
	BBS	#MEMORY_V_FULL,MEMORY_L_BITLIS,10$	; Was /FULL specified?
	TYPEMSG	SHOW$_MEM_LOOK2,SHOW_LOOK_LIST	; No. Type normal display line
	RSB				;  and return to caller

10$:	MOVAL	LOOK_LIST_SIZE,R1	; Store address of size array
	BSBW	CONVERT_PACKET_COUNT	; Convert packets to bytes and pages
	MULL3	R2,(R1)+,(R1)+		; Convert free packets to free bytes
	MULL3	R2,(R1)+,(R1)+		; Convert packets in use to bytes in use
	TYPEMSG	SHOW$_MEM_LOOK_FULL1,SHOW_LOOK_LIST	; Display name of list
	TYPEMSG	SHOW$_MEM_LOOK_FULL2,SHOW_LOOK_LIST2	; Display current size
	MOVAL	LOOK_LIST_NAME,R1	; Use first four parameters again
	MOVL	(R3)+,(R1)+		; Store SYSGEN parameter name
	MOVL	(R3)+,(R1)		;  and initial size
	BSBW	CONVERT_PACKET_COUNT	; Convert packet count to bytes and pages
	TYPEMSG	SHOW$_MEM_LOOK_FULL3,SHOW_LOOK_LIST3	; Display initial size
	MOVAL	LOOK_LIST_SIZE,R1	; Reset size array pointer
	MOVL	(R3)+,(R1)		; Store maximum size
	BSBW	CONVERT_PACKET_COUNT	; Convert packets to bytes and pages
	TYPEMSG	SHOW$_MEM_LOOK_FULL4,SHOW_LOOK_LIST4	; Display maximum size

	TYPEMSG	SHOW$_MEM_LOOK_FULL5,SHOW_LOOK_LIST5	; Display free space
	TYPEMSG	SHOW$_MEM_LOOK_FULL6,SHOW_LOOK_LIST6	; Display space in use
	TYPEMSG	SHOW$_MEM_LOOK_FULL7,SHOW_LOOK_LIST7	; Display block size
	TYPEMSG	SHOW$_MEM_LOOK_FULL8,SHOW_LOOK_LIST8	; Display lower limit

	RSB

	.PAGE
	.SUBTITLE	CONVERT_PACKET_COUNT	Convert Packets to Bytes and Pages

;+
; Functional Description:
;
;	This routine converts a packet count and a packet size to a byte
;	count and the minimum number of pages required to hold that
;	number of bytes.
;
; Input Parameters:
;
;	R1	Address of 3-longword array of sizes
;	(R1)	Number of packets
;	R2	Packet size
;
; Output Parameters:
;
;	4(R1)	Byte count (packets * packet size)
;	8(R1)	Page count necessary to contain byte count
;
; Implicit Output:
;
;	R1 points at the next longword after the page count
;
; Side Effects:
;
;	R0 is destroyed by this routine
;-

CONVERT_PACKET_COUNT:
	MULL3	R2,(R1)+,(R1)		; Convert packets to bytes
	ADDL3	#511,(R1)+,R0		; Round up to next page boundary
	ASHL	#-9,R0,(R1)+		; Convert bytes to pages
	RSB

	.PAGE
	.SBTTL	SHOW POOL USAGE
;+
;	SHOW PAGED AND NON-PAGED POOL USAGE
;	
;	THIS CODE MUST NOT PAGEFAULT WHILE AT ELEVATED IPL; THEREFORE
;	IT (AND THE DATA ITEMS IT REFERENCES) ARE LOCKED IN THE WORKING
;	SET PRIOR TO THE ROUTINE BEING CALLED.
;
;	THIS ROUTINE DISPLAYS THE TOTAL NUMBER OF BYTES IN EACH POOL,
;	THE NUMBER OF BYTES IN USE, AND THE NUMBER OF FREE BYTES.
;	THE NON-PAGED POOL IS SUBDIVIDED INTO THE FIXED LENGTH LOOKASIDE
;	LISTS AND THE VARIABLE-LENGTH SEGMENTS. THE FIXED LENGTH NON-PAGED
;	POOL IS SUBDIVIDED INTO IRP PACKETS AND BIG BLOCKS.
;-

POOL:
	.WORD	^M<R2>				; Save R2
	BBS	#MEMORY_V_FULL,MEMORY_L_BITLIS,10$ ; Skip header in full display
	TYPEMSG	SHOW$_MEM_POOL1			; Print header line

;  Get variable length nonpaged pool statistics

10$:	$CMKRNL_S	ROUTIN=POOL_NPAGEDYN	; Scan the list ...
	MOVAW	NPAGEDYN_DESC,POOL_NAME		;  add a name identifier,
	MOVAW	BYTES_SIZE_DESC,POOL_SIZE	;  and a size identifier.
	BICL3	#^X1FF,G^MMG$GL_NPAGNEXT,-(SP)	; Get current end of pool
	SUBL3	G^MMG$GL_NPAGEDYN,(SP)+,R0	; Compute size of nonpaged pool
	MOVZBL	#1,R2				; Indicate nonpaged pool
	BSBW	DISPLAY_POOL			;  and print this information

;  Get paged pool statistics

	$CMKRNL_S	ROUTIN=POOL_PAGEDYN	; Scan the list ...
	MOVAW	PAGEDYN_DESC,POOL_NAME		;  add a name identifier,
	MOVAW	PAGEDYN_SIZE_DESC,POOL_SIZE	;  and a size identifier.
	MOVL	G^SGN$GL_PAGEDYN,R0		; Get total pool size
	CLRL	R2				; Indicate not nonpaged pool
	BSBW	DISPLAY_POOL			;  and print the information
	RET					; That's all for SHOW MEMORY

; Get statistics for process allocation region if /MEMORY qualifier
; was specified to the SHOW PROCESS command

SHOW$PRCALLREG::
	.WORD	^M<R2>			; Save volatile register
	BBSS	#MEMORY_V_FULL,MEMORY_L_BITLIS,20$	; Always a full display
20$:	$CMKRNL_S	ROUTIN=POOL_PRCALLREG	; Scan the list ...
	MOVAW	PRCALLREG_DESC,POOL_NAME	;  add a name identifier,
	MOVAW	BYTES_SIZE_DESC,POOL_SIZE	;  and a size identifier.
	MOVL	#<CTL$C_PRCALLSIZ@9>,R0		; Calculate total size
	CLRL	R2				; Indicate not nonpaged pool
	BSBW	DISPLAY_POOL			;  and print the information
	MOVZWL	#SS$_NORMAL,R0			; Signal success
	RET					; Return to caller

	.PAGE
	.SUBTITLE	POOL_NPAGEDYN	Scan Nonpaged Dynamic Memory

;+
;	POOL_NPAGEDYN	Scan Nonpaged Dynamic Memory
;
;  This routine scans nonpaged pool and returns current usage information.
;
;  Calling sequence:
;
;	CALLS	#0,POOL_NPAGEDYN
;
;  Input parameters:
;
;	EXE$GL_NONPAGED	Listhead of paged pool
;
;  Output parameters:
;
;	POOL_TOTAL	Total amount of space set aside for this area
;
;	POOL_FREE	Total amount of unallocated (free) space
;
;	POOL_INUSE	Amount of space currently in use (TOTAL - FREE)
;
;	POOL_FREE_COUNT	Number of discontiguous free blocks
;
;	POOL_MAX_BLOCK	Size of largest contiguous area
;
;	POOL_MIN_BLOCK	Size of smallest unallocated block
;-

POOL_NPAGEDYN:
	.WORD	^M<R2,R3,R4,R5,R6,R7>	; Save some registers
	MOVAL	G^EXE$GL_NONPAGED,R2	; Get nonpaged pool listhead
	DSBINT	(R2)+			; Set IPL for pool access
	BSBW	SCAN_SINGLY_LINKED_LIST	; Get free space, minimum, and maximum
	ENBINT				; Allow interrupts
	MOVL	R3,POOL_FREE_COUNT	; Save total number of free blocks,
	MOVL	R4,POOL_FREE_LEQU_32	;  count of blocks 32 bytes or smaller,
	MOVL	R5,POOL_FREE		;  total number of free bytes,
	MOVL	R6,POOL_MAX_BLOCK	;  size of maximum block,
	MOVL	R7,POOL_MIN_BLOCK	;  and size of minimum block
	MOVZWL	#SS$_NORMAL,R0
	RET

	.PAGE
	.SUBTITLE	POOL_PAGEDYN	Scan Paged Dynamic Memory

;+
;	POOL_PAGEDYN	Scan Paged Dynamic Memory
;
;  This routine scans paged pool and returns current usage information.
;
;  Calling sequence:
;
;	CALLS	#0,POOL_PAGEDYN
;
;  Input parameters:
;
;	EXE$GL_PAGED	Listhead of paged pool
;
;  Output parameters:
;
;	POOL_TOTAL	Total amount of space set aside for this area
;
;	POOL_FREE	Total amount of unallocated (free) space
;
;	POOL_INUSE	Amount of space currently in use (TOTAL - FREE)
;
;	POOL_FREE_COUNT	Number of discontiguous free blocks
;
;	POOL_MAX_BLOCK	Size of largest contiguous area
;
;	POOL_MIN_BLOCK	Size of smallest unallocated block
;-

POOL_PAGEDYN:
	.WORD	^M<R2,R3,R4,R5,R6,R7>	; Save some registers
	SAVIPL				; Save current IPL
	MOVAB	G^EXE$GL_PGDYNMTX,R0	; Get address of paged memory mutex
	MOVL	G^SCH$GL_CURPCB,R4	; Get current process PCB address
	PUSHR	#^M<R0,R4>		; Save these for UNLOCK call
	JSB	G^SCH$LOCKW		; Lock paged pool data base
	MOVAL	G^EXE$GL_PAGED,R2	; Get header link for free list
	BSBW	SCAN_SINGLY_LINKED_LIST	; Get free space, minimum, and maximum
	MOVL	R3,POOL_FREE_COUNT	; Save total number of free blocks,
	MOVL	R4,POOL_FREE_LEQU_32	;  count of blocks 32 bytes or smaller,
	MOVL	R5,POOL_FREE		;  total number of free bytes,
	MOVL	R6,POOL_MAX_BLOCK	;  size of maximum block,
	MOVL	R7,POOL_MIN_BLOCK	;  and size of minimum block
	POPR	#^M<R0,R4>		; Restore mutex address and PCB address
	JSB	G^SCH$UNLOCK		; Unlock the data base
	ENBINT				; Return to original IPL
	MOVZWL	#SS$_NORMAL,R0
	RET

	.PAGE
	.SUBTITLE	POOL_PRCALLREG	Scan Process Allocation Region

;+
;	POOL_PRCALLREG	Scan Process Allocation Region
;
;  This routine scans the process allocation region, a process-private
;  pool area in P1 space, and returns current usage information.
;
;  Calling sequence:
;
;	CALLS	#0,POOL_PRCALLREG
;
;  Input parameters:
;
;	CTL$GQ_ALLOCREG	Listhead of process allocation region
;
;  Output parameters:
;
;	POOL_TOTAL	Total amount of space set aside for this area
;
;	POOL_FREE	Total amount of unallocated (free) space
;
;	POOL_INUSE	Amount of space currently in use (TOTAL - FREE)
;
;	POOL_FREE_COUNT	Number of discontiguous free blocks
;
;	POOL_MAX_BLOCK	Size of largest contiguous area
;
;	POOL_MIN_BLOCK	Size of smallest unallocated block
;
;-

POOL_PRCALLREG:
	.WORD	^M<R2,R3,R4,R5,R6,R7>	; Save some registers
	MOVAL	@#CTL$GQ_ALLOCREG,R2	; Get listhead for this pool area
	DSBINT	#IPL$_ASTDEL		; Prevent ASTs while scanning this list
	BSBW	SCAN_SINGLY_LINKED_LIST	; Get free space, minimum, and maximum
	ENBINT				; ASTs are OK now
	MOVL	R3,POOL_FREE_COUNT	; Save total number of free blocks,
	MOVL	R4,POOL_FREE_LEQU_32	;  count of blocks 32 bytes or smaller,
	MOVL	R5,POOL_FREE		;  total number of free bytes,
	MOVL	R6,POOL_MAX_BLOCK	;  size of maximum block,
	MOVL	R7,POOL_MIN_BLOCK	;  and size of minimum block
	MOVZWL	#SS$_NORMAL,R0
	RET

	.PAGE
	.SUBTITLE	SCAN_SINGLY_LINKED_LIST	Scan memory-ordered list

;+
;  Functional Description:
;
;	This routine scans a memory-ordered singly linked list of blocks and
;	returns the total amount of free space , the number of free blocks,
;	the number of free blocks 32 bytes or smaller, and the sizes of the
;	largest and smallest blocks. 
;
;  Calling sequence:
;
;	BSBW	SCAN_SINGLY_LINKED_LIST
;
;  Input parameter:
;
;	R2	Address of listhead for pool area.
;
;  Output parameters:
;
;	R3	Number of distinct free blocks
;	R4	Number of free blocks 32 bytes or smaller
;	R5	Total amount of free space
;	R6	Size of largest block
;	R7	Size of smallest block
;
;  This routine assumes that the caller has taken whatever synchronization
;  measures are necessary for the pool area being scanned.
;-

SCAN_SINGLY_LINKED_LIST:
	CLRQ	R3			; Clear two free block counters
	CLRQ	R5			; Set sum and maximum to zero
	MCOML	#0,R7			; Set minimum to "infinite"
	MOVL	(R2),R2			; Get contents of first block
	BEQL	40$			; If zero, then pool is empty
10$:	INCL	R3			; Count another free block
	ADDL2	4(R2),R5		; Count this block in sum
	CMPL	#32,4(R2)		; Is block 32 bytes or smaller?
	BLSSU	15$			; Branch if larger than 32 bytes
	INCL	R4			; Otherwise, count another "small" block
15$:	CMPL	4(R2),R6		; Is this block bigger than maximum?
	BLEQU	20$			; Branch if not bigger
	MOVL	4(R2),R6		; Otherwise, record new maximum
20$:	CMPL	4(R2),R7		; Is this block smaller than minimum?
	BGEQU	30$			; Branch if not smaller
	MOVL	4(R2),R7		; Otherwise, record new minimum
30$:	MOVL	(R2),R2			; Get next block
	BNEQ	10$			; Go back to top of loop if more
	RSB				; Return to caller

; This pool area is empty. Set minimum size to zero.

40$:	CLRL	R7			; Set minimum to zero
	RSB				; Return to caller

END_LOCKED_CODE:			; End of code that executes above IPL 2

	.PAGE
	.SUBTITLE	DISPLAY_POOL Output Routine for Dynamic Memory Displays

;+
; Functional Description:
;
;	This routine performs the common output and display functions for
;	the three variable sized dynamic memory areas. The routine decides
;	whether a normal or full display is requested. If a full display
;	is being produced, and thnonpaged dynaimc memory is the area being
;	displayed, two additional lines of output are produced.
;
; Calling Sequence:
;
;	BSBW	DISPLAY_POOL
;
; Input Parameters:
;
;	R0	Size in bytes of area being displayed
;
;	R2	Nonpaged pool indicator
;		R2<0> = 1 => nonpaged dynamic memory
;		R2<0> = 0 => Some other area than nonpaged pool
;
; Implicit Input:
;
;	Setting of MEMORY_V_FULL bit in MEMORY_L_BITLIS
;
;	Contents of cells in FAO parameter list for pool displays
;
; Output Parameters:
;
;	Several cells in FAO parameter list for pool displays
;
;		POOL_TOTAL
;		POOL_INUSE
;		POOL_TOTAL_PAGE	(full display only)
;
; Implicit Output:
;
;	Displays of pool statistics for specified pool area are written
;	to SYS$OUTPUT.
;-

DISPLAY_POOL:
	MOVL	R0,POOL_TOTAL		; Store pool size in FAO parameter list
	SUBL3	POOL_FREE,R0,POOL_INUSE	; INUSE = TOTAL - FREE
	ADDL2	#511,R0			; Round size to next page boundary
	ASHL	#-9,R0,POOL_TOTAL_PAGES	; Convert to page count
	BBS	#MEMORY_V_FULL,MEMORY_L_BITLIS,10$	; Was /FULL specified?
	TYPEMSG	SHOW$_MEM_POOL2,SHOW_POOL_LIST	; No. Print normal display
	RSB				;  and return to caller

; A full display was requested in the SHOW MEMORY command

10$:	TYPEMSG	SHOW$_MEM_POOL_FULL1,SHOW_POOL_LIST
	TYPEMSG	SHOW$_MEM_POOL_FULL2,SHOW_POOL_LIST2

; Skip next two displays unless nonpaged pool

	BLBC	R2,20$
	MOVL	G^SGN$GL_NPAGEDYN,POOL_TOTAL	; Get initial pool size
	ADDL3	#511,POOL_TOTAL,R0	; Round up to next page boundary
	ASHL	#-9,R0,POOL_TOTAL_PAGES	; Convert to pages
	TYPEMSG	SHOW$_MEM_POOL_FULL3,SHOW_POOL_LIST3
	MOVL	G^SGN$GL_NPAGEVIR,POOL_TOTAL	; Get maximum pool size
	ADDL3	#511,POOL_TOTAL,R0	; Round up to next page boundary
	ASHL	#-9,R0,POOL_TOTAL_PAGES	; Convert to pages
	TYPEMSG	SHOW$_MEM_POOL_FULL4,SHOW_POOL_LIST4
	
20$:	TYPEMSG	SHOW$_MEM_POOL_FULL5,SHOW_POOL_LIST5	; Display usage data
	TYPEMSG	SHOW$_MEM_POOL_FULL6,SHOW_POOL_LIST6	; Display upper bound
	TYPEMSG	SHOW$_MEM_POOL_FULL7,SHOW_POOL_LIST7	; Display lower bound
	RSB				; Return to caller

	.PAGE
	.SUBTITLE	PAGEFILE - Display Paging File Statistics
;+
; Functional Description:
;
;	This routine gathers information about each paging and swap file.
;	In particular, the size of each file and the amount of free space
;	is displayed. In the display selected when the /FULL qualifier is
;	specified, the number of processes paging and swapping to each
;	file is added to the list of information.
;
; Input Parameters:
;
;	None
;
; Implicit Input:
;
;	SGN$GW_SWPFILCT	Maximum number of swap files that can be installed
;
;	SGN$GW_PAGFILCT	Maximum number of paging files that can be installed
;
;	Setting of MEMORY_V_FULL bit in MEMORY_L_BITLIS controls the
;	amount of information displayed for each file.
;
; Output Parameters:
;
;	None
;
; Implicit Output:
;
;	Paging file usage information is displayed on SYS$OUTPUT
;-

PAGEFILE:
	.WORD	^M<R2,R3,R4,R5,R6,R7>	; Save some registers
	MOVZWL	G^SGN$GW_SWPFILCT,SWAP_FILE_COUNT
	MOVZWL	G^SGN$GW_PAGFILCT,PAGE_FILE_COUNT
	ADDL3	PAGE_FILE_COUNT,SWAP_FILE_COUNT,R2
	EMUL	R2,#PFL_K_EXT_LENGTH,#4,PFL_TABLE_SIZE
	PUSHAL	PFL_TABLE_ADDR		; Set up argument list for LIB$GET_VM
	PUSHAL	PFL_TABLE_SIZE		; Point to requested block size
	CALLS	#2,G^LIB$GET_VM		; Allocate a scratch area
	BLBS	R0,5$			; Abandon display if no space available
2$:	RET

5$:	$CMEXEC_S	GET_PFL_DATA	; Gather data from nonpaged pool
	BLBC	R0,2$			; Skip rest if error occurred
	BBS	#MEMORY_V_FULL,MEMORY_L_BITLIS,10$	; Was /FULL specified?
	TYPEMSG	SHOW$_MEM_PAGE1		; Print header line for normal display
	BRW	40$			; Go to page file loop

; Allocate two arrays of words for each paging and swap file, so that 
; we can keep a count of how many processes are paging and swapping
; into each file. Word arrays can be used because of the VMS architectural
; limit of 32767 processes.

					; R2 = PAGFILCNT + SWPFILCNT 
10$:	ASHL	#2,R2,R1		; R1 = size of table in bytes
	SUBL	R1,SP			; Allocate the array on the stack
	MOVL	SP,SWAP_FILE_TABLE	; Store address of swap file table
	MOVAW	(SP)[R2],PAGE_FILE_TABLE ; Store address of paging file table
	MOVC5	#0,(SP),#0,R1,(SP)	; Zero the tables

; Now use the wild card mode of $GETJPI to count the number of processes
; paging and swapping into each paging and swap file.

20$:	$GETJPI_G	GETJPI_LIST	; Call $GETJPI
	BLBC	R0,30$			; Skip next if error occurred
	$WAITFR_S	EFN=#EVENT_FLAG	; Wait for $GETJPI to complete
	BLBC	GETJPI_STATUS,30$	; Skip next if error occurred
	MOVZBL	PAGE_FILE_INDEX,R0	; Get page file index for process
	INCW	@PAGE_FILE_TABLE[R0]	; Bump appropriate counter
	MOVZBL	SWAP_FILE_INDEX,R0	; Get swap file index for process
	INCW	@SWAP_FILE_TABLE[R0]	; Bump appropriate counter
	BRB	20$			; Back to top of loop

30$:	CMPW	R0,#SS$_NOMOREPROC	; This error code is loop breaker
	BNEQ	20$			; Go back for more if different error

; Now scan page and swap file array and display information about each file

40$:	MOVL	PFL_TABLE_ADDR,R7		; R7 will step through scratch area
50$:	ADDL3	(R7),#1,R0		; Is first longword -1?
	BNEQ	55$			; Continue if not -1
	BRW	90$			; Equal to -1 implies end of loop

55$:	BSBW	GET_FILE_NAME		; Translate FID to file name
	MULL3	PFL$L_BITMAPSIZ(R7),#8,PAGE_TOTAL
					; Get total number of pages
	MOVL	PFL$L_FREPAGCNT(R7),PAGE_FREE
					; Get number of free pages
	SUBL3	PAGE_FREE,PAGE_TOTAL,PAGE_USED
					; Get number of pages in use
	BBS	#MEMORY_V_FULL,MEMORY_L_BITLIS,70$	; Was /FULL specified?

; Either of these next two TYPEMSG calls is used for a normal display
; of a paging or swap file. If the file name and the usage data can fit
; on a single line, a one-line display is used. Otherwise, the file name
; is displayed on one line and the usage data is displayed on the next.

	CMPW	FILE_NAME_DESC,#SHOW$C_MEM_SHORT_NAME
					; Will file name fit on one line?
	BGTRU	60$			; Branch if name does not fit
	TYPEMSG	SHOW$_MEM_PAGE2,SHOW_PAGE_LIST	; Print single line display
	BRW	80$			; Go to common end of loop

60$:	TYPEMSG	SHOW$_MEM_PAGE3,SHOW_PAGE_LIST	; Print first of two lines
	TYPEMSG	SHOW$_MEM_PAGE4,SHOW_PAGE_LIST	; Print second of two lines
	BRB	80$			; Go to common end of loop

; The next several TYPEMSG calls are all used for a full display of
; each paging and swap file.

70$:	MOVL	PAGE_PFL_INDEX,R6	; Retrieve PFL index
	MOVZWL	@PAGE_FILE_TABLE[R6],PAGE_FULL_PAGING_COUNT
	MOVZWL	@SWAP_FILE_TABLE[R6],PAGE_FULL_SWAP_COUNT
	TYPEMSG	SHOW$_MEM_PAGE_FULL1,SHOW_PAGE_LIST	; Print file name
	TYPEMSG	SHOW$_MEM_PAGE_FULL2,SHOW_PAGE_LIST2	; Print file size
	TYPEMSG	SHOW$_MEM_PAGE_FULL3,SHOW_PAGE_LIST3	; Print free space
	TYPEMSG	SHOW$_MEM_PAGE_FULL4,SHOW_PAGE_LIST4	; Print file usage
	TYPEMSG	SHOW$_MEM_PAGE_FULL5,SHOW_PAGE_LIST5	; Display type of file

80$:	ADDL2	#PFL_K_EXT_LENGTH,R7	; Advance R7 to next slot in scratch area
	BRW	50$			;  and go back to top of loop

90$:	MOVZWL	#SS$_NORMAL,R0		; Signal success
	RET				;  and return

	.PAGE
	.SUBTITLE	GET_PFL_DATA	Gather page file control block data
;+
; Functional Description:
;
;	This routine executes in exec mode and copies all active PFL control
;	blocks and their associated file name information to a scrath buffer
;	in P1 space.
;
;  Calling sequence:
;
;	CALLS	#0,GET_PFL_DATA
;
;  Input parameters:
;
;	MMG$GL_PAGSWPVC	Pointer to array of PFL pointers
;
;	PFL_TABLE_ADDR	Address of scratch area into which all PFLs
;			currently in use will be copied.
;
; Implicit input:
;
;	Data bases for I/O system and file system
;
; Output parameters:
;
; 	None
;
; Implicit Output:
;
;	The contents of each PFL are copied from nonpaged pool to a scratch
;	area. In addition, the file ID, device name, and unit number that
;	describe each file are copied.
;
;	The default paging and swap files do not have FCBs or FIDs
;	associated with their WCBs. This information is communicated to
;	user mode by storing a -1 in the PFL index field and placing the
;	actual PFL index in PFL_W_FID_NUM. 
;
;	The two cases that can occur are as follows.
;
;	1.	PFL index is not negative
;
;		This is the case for all paging and swap files except those
;		installed by SYSINIT at boot time.
;
;	2.	PFL index is negative but FID_NUM is positive
;
;		This is a primary paging or swap file installed by SYSINIT
;		before the file system was operating. The WCB does not point
;		to a FCB and so the FID is not available. The contents of 
;		FID_NUM are the PFL index.
;
;	The end of list is indicated by placing a -1 in the first longword
;	after the last entry. This field contains the BITMAP address in a
;	valid PFL so there is no ambiguity.
;
; While the loop executes, the following register conventions are observed.
;
;	R6	Index into PFL vector
;	R7	Pointer to "real" PFL in nonpaged pool
;	R8	Pointer to WCB for this page or swap file
;	R10	Pointer to extended PFL in scratch area
;	R11	Pointer to PFL vector (of PFL pointers) in nonpaged pool
;-

GET_PFL_DATA:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	G^MMG$GL_PAGSWPVC,R11	; R11 points to top of PFL array
	MOVL	PFL_TABLE_ADDR,R10	; R10 points to start of scratch area
	CLRL	R6			; R6 is the PFL index
10$:	MOVL	(R11)[R6],R7		;  and R7 points to the "real" PFL
	BBC	#PFL$V_INITED,PFL$B_FLAGS(R7),40$	; Skip entire loop if not installed
	MOVC3	#PFL$K_LENGTH,(R7),(R10)	; Copy PFL to scratch area
	MOVL	PFL$L_WINDOW(R7),R8	; WCB address to R8
	MOVL	WCB$L_ORGUCB(R8),R5	; Pick up UCB address
	MOVW	UCB$W_UNIT(R5),PFL_W_UNIT(R10)	; Save unit number of device
	MOVL	UCB$L_DDB(R5),R5	; Get DDB address
	MOVC3	#DDB_S_DEVNAMSIZ,DDB$T_NAME(R5),PFL_T_DEVNAM(R10)
					; Copy counted ASCII string 
	MOVL	WCB$L_FCB(R8),R5	; Now get FCB address
	BEQL	20$			; No FCB for default page or swap file

; Copy three words of File ID from FCB to scratch area for this PFL

	MOVW	FCB$W_FID_NUM(R5),PFL_W_FID_NUM(R10)
	MOVW	FCB$W_FID_SEQ(R5),PFL_W_FID_SEQ(R10)
	MOVW	FCB$W_FID_RVN(R5),PFL_W_FID_RVN(R10)
	MOVW	R6,PFL_W_PFL_INDEX(R10)	; Store PFL index
	BRB	30$			; Transfer to common end of loop

; The default paging or swap file has a -1 placed in the PFL index field
; and the PFL index is stored in the first word of the file ID.

20$:	MCOMW	#0,PFL_W_PFL_INDEX(R10)	; Signal default paging or swap file
	MOVW	R6,PFL_W_FID_NUM(R10)	;  but make PFL index available

30$:	ADDL2	#PFL_K_EXT_LENGTH,R10	; Advance to scratch area for next PFL
40$:	AOBLEQ	G^MMG$GL_MAXPFIDX,R6,10$	; Loop back if more files

	MCOML	#0,(R10)		; Indicate end of active PFLs
	MOVZWL	#SS$_NORMAL,R0		; Signal success
	RET				;  and return

	.PAGE
	.SUBTITLE	GET_FILE_NAME - Translate File ID to File Name
;+
;
; This routine translates a device string, a unit number, and a file ID
; of a paging or swap file into a name for that file. If the file in
; question is the primary paging or swap file (file ID is not available)
; then a default file name is constructed.
;
; Input Parameters:
;
;	R7	Address of extended PFL in scratch area
;
; Output Parameters:
;
;	FILE_NAME_DESC	contains a string descriptor for the file name
;-

GET_FILE_NAME:
	MOVZBL	PFL_T_DEVNAM(R7),R2		; Character count to R2
	MOVL	R2,DEVICE_NAME_DESC		; Store in descriptor
	MOVAB	PFL_T_DEVNAM+1(R7),DEVICE_NAME_DESC+4	; Store string address

; Construct descriptor for "rest" of device name string

	SUBL3	R2,#PFL_S_DEVNAMSIZ,SCRATCH_DESC	; Get modified size
	MOVAB	PFL_T_DEVNAM+1(R7)[R2],SCRATCH_DESC+4	;  and address
	MOVZWL	PFL_W_UNIT(R7),FAO_LIST+FAO$_P1	; Store unit number in $FAO list
	$FAO_G	FAO_LIST			; Convert to string
	ADDL2	RETURN_LENGTH,DEVICE_NAME_DESC	; Update character count

; Set file name size in descriptor that points to file name buffer

	ASSUME	FILE_NAME_SIZE LT 256
	MOVZBL	#FILE_NAME_SIZE,FILE_NAME_DESC		; Store buffer size
	CVTWL	PFL_W_PFL_INDEX(R7),PAGE_PFL_INDEX	; PFL index to FAO list
	BLSS	10$			; Negative index implies default file
	MOVAW	PFL_W_FID(R7),FID_TO_NAME_FID_ADDR	; Store address of FID
	CALLG	FID_TO_NAME_ARG_LIST,G^LIB$FID_TO_NAME	; Convert FID to file name
	BLBS	R0,5$					; Check for error
	CLRL	RETURN_LENGTH				; Display nothing if error
5$:	MOVW	RETURN_LENGTH,FILE_NAME_DESC		; Store actual name length
	RSB				;  and return to caller

; The file names for the paging and swap files installed by SYSINIT are
; fabricated dynamically from the device name and unit number.
;
; 1.	$GETDVI translates the device name to its logical equivalent.
;	If this logical name has been deleted, the device name returned
;	by $GETDVI is used in its place.
;
; 2.	Logical name SYS$TOPSYS is translated to form the first part of
;	the directory string.
;
; 3.	The string "SYSEXE]" is added by hand.
;
; 4.	The string "PAGE" or "SWAP" is added, depending on whether this
;	is the primary paging or swap file.
;
; 5.	The string "FILE.SYS" is placed at the end.

10$:	$GETDVI_G	GETDVI_LIST	; Get proper device name
	BLBC	R0,17$			; Quit if error occurred
	TSTL	FILE_NAME_DESC		; Did we get a LOGVOLNAM?
	BNEQ	15$			; Nonzero implies that we did. Use it.
	MOVC3	RETURN_LENGTH,DEVICE_NAME_ADDR,@FILE_NAME_DESC+4
	MOVL	RETURN_LENGTH,FILE_NAME_DESC	; Otherwise, use the DEVNAM
15$:	ADDL3	FILE_NAME_DESC+4,FILE_NAME_DESC,R3 ; R3 will step through string
	MOVW	#^A\:[\,(R3)+

; Use the scratch descriptor as the output descriptor to $TRNLOG. The size of
; the area is the device name size (RETURN_LENGTH) plus two (for the ":[").

	SUBL3	RETURN_LENGTH,#<FILE_NAME_SIZE-2>,SCRATCH_DESC	
	MOVL	R3,SCRATCH_DESC+4	; Store address
	$TRNLOG_G	TRNLOG_LIST	; Translate SYS$TOPSYS
17$:	BLBC	R0,50$			; Quit in case an error occurred
	CMPW	R0,#SS$_NOTRAN		; Do not update R3 if no translation
	BEQL	20$			; Go get rest of directory string
	ADDL2	RETURN_LENGTH,R3	; Place R3 beyond translated string
	MOVB	#^A\.\,(R3)+		; Add "." separator
20$:	MOVC3	DEFAULT_DIRECTORY_NAME,@DEFAULT_DIRECTORY_NAME+4,(R3)
	MOVZWL	PFL_W_FID_NUM(R7),PAGE_PFL_INDEX	; Store PFL index
	CMPW	PAGE_PFL_INDEX,G^MMG$GW_MINPFIDX	; Is this the primary
	BEQL	30$			;  paging file? Branch if it is.
	MOVL	#^A\SWAP\,(R3)+		; Otherwise, call it SWAPFILE.SYS
	BRB	40$			;  and join the common exit code
30$:	MOVL	#^A\PAGE\,(R3)+		; Make the name PAGEFILE.SYS
	MOVAW	PAGE_INDIC_DESC,PAGE_FLAG	; Indicate that paging is allowed
40$:	MOVC3	DEFAULT_FILE_NAME,@DEFAULT_FILE_NAME+4,(R3)	; Fill in rest of name
	SUBL3	FILE_NAME_DESC+4,R3,FILE_NAME_DESC	; Store actual file name
50$:	RSB				;  and return

	.END
