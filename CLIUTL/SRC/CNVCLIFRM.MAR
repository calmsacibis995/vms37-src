	.TITLE	CNVCLIFRM - CONVERT COMMAND INPUT FORMS TYPE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITIES
;
; ABSTRACT:	THIS ROUTINE CONVERTS A FORMS/CHARACTERISTIC TYPE 
;		INTO A BINARY VALUE.
;
;
; ENVIRONMENT:	NATIVE MODE, NON-PRIVILEGED
;
; AUTHOR:  STEVE BECKHARDT,  CREATION DATE:  13-FEB-78
;
; MODIFIED BY:
;
;	V03	GWF0107		GARY FOWLER		21-SEP-1981
;		Change logical name used in opening files to SYS$MANAGER
;
;	V02	LMK0001		LEN KAWELL		15-FEB-1980
;		ADD DE-QUEUE CHARACTERISTICS CONVERSION.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	$CLIMSGDEF			; DEFINE CLI ERROR CODES
	$FABDEF				; FAB DEFINITIONS
	$RABDEF				; RAB DEFINITIONS

RCBFSZ=135				; RECORD BUFFER SIZE FOR FORMS
					; DEFINITION FILE

;
; OWN STORAGE:
;
	PURE_SECTION	PURE_CLIUTL
 

FFILNAM: .ASCIC	/SYS$MANAGER:FORMSTYPE.DAT/	; FILE NAME OF FORMS DEFINITION FILE
CFILNAM: .ASCIC /SYS$MANAGER:CHARTYPE.DAT/	; FILE NAME OF CHARACTERISTICS DEFINITION FILE



	.SBTTL	CONVERT CLI FORMS AND CHARACTERISTICS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES ARE CALLED TO CONVERT THE FORMS/CHARACTERISTICS
;	ENTERED ON A COMMAND INTO A BINARY BYTE VALUE.
;	THIS WILL CONVERT EITHER A NUMBER DIRECTLY, OR
;	A ALPHANUMERIC NAME.  ALPHANUMERIC FORMS NAMES ARE
;	STORED IN FILE "SYS$MANAGER:FORMSTYPE.DAT" AND CHARACTERISTICS
;	NAMES ARE STORED IN "SYS$MANAGER:CHARTYPE.DAT.
;	FORMS/CHARACTERISTICS DEFINITIONS IN THE FILE MUST BE IN 
;	THE FOLLOWING FORMAT:
;	%	TYPE	NUMBER
;	THE PERCENT SIGN MUST BE THE FIRST CHARACTER IN THE RECORD.
;
; CALLING SEQUENCE:
;
;	VIA "CALL" INSTRUCTION
;
; INPUT PARAMETERS:
;
;	4(AP) IS THE ADDRESS OF A QUAD WORD DESCRIPTOR FOR THE TYPE CODE
;	8(AP) IS THE ADDRESS OF BYTE TO STORE RESULT(OPTION)
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	THE CONVERTED FORMS/CHAR TYPE IS RETURNED IN R1 AND AT THE LOCATION
;	SPECIFIED IF THE CALL ARGUMENT LIST HAD MORE THAN ONE ARGUMENT.
;
; IMPLICIT OUTPUTS:
;
;	CONVERTED VALUE IN R1
;
; COMPLETION CODES:
;
;	R0 IS SET TRUE OR FALSE DEPENDING UPON SUCCESS OR FAILURE OF CONVERSION
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	PURE_SECTION	PURE_CLIUTL
 
LIB$CNVCLIFORMS::			; CONVERT FORMS TYPE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	FFILNAM,R6		; SET ADDRESS OF FORMS FILE
	BRB	CONVERT			;

LIB$CNVCLIQCHAR::			; CONVERT CHARACTERISTICS TYPE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	CFILNAM,R6		; SET ADDRESS OF CHAR FILENAME

CONVERT:				; CONVERT TYPE
	; FIRST SEE IF WE CAN CONVERT A NUMBER
	PUSHAQ	@4(AP)			; POINTER TO TOKEN DESCRIPTOR
	CALLS	#1,LIB$CVT_DECBIN	; TRY TO CONVERT IT
	BLBC	R0,5$			; CONVERSION FAILED
	BRW	60$			; SUCCESS!  VALUE IN R1

5$:	; NUMBER CONVERSION FAILED.  TRY LOOKING IT UP IN FILE
	MOVQ	@4(AP),R10		; PUT TOKEN DESCRIPTOR IN R10,R11

	; ALLOCATE SPACE FOR FAB, RAB, AND BUFFERS ON STACK
	MOVAB	-FAB$C_BLN(SP),R7	; R7 POINTS TO FAB
	MOVAB	-RAB$C_BLN(R7),R8	; R8 POINTS TO RAB
	MOVAB	-<RCBFSZ+1>(R8),R9	; R9 POINTS TO RECORD BUFFER
	MOVL	R9,SP			; SET STACK POINTER

	; CLEAR FAB AND RAB
	MOVC5	#0,(R8),#0,#RAB$C_BLN+FAB$C_BLN,(R8)

	; SET VARIOUS FAB FIELDS
	ASSUME	FAB$B_BLN  EQ FAB$B_BID+1
	MOVW	#<FAB$C_BLN@8>+FAB$C_BID,FAB$B_BID(R7)	; BLOCK ID AND LENGTH
	MOVB	#FAB$M_GET,FAB$B_FAC(R7); FILE ACCESS
	MOVB	(R6)+,FAB$B_FNS(R7)	; FILE NAME SIZE
	MOVAB	(R6),FAB$L_FNA(R7)	; FILE NAME ADDRESS

	; OPEN FILE
	$OPEN	FAB=(R7)
	BLBS	R0,15$			; SUCCESSFUL OPEN
10$:	BRW	80$			; ERROR (ASSUME FILE NOT FOUND)

15$:	; SET VARIOUS RAB FIELDS
	ASSUME	RAB$B_BLN  EQ RAB$B_BID+1
	MOVW	#<RAB$C_BLN@8>+RAB$C_BID,RAB$B_BID(R8)	; BLOCK ID AND LENGTH
	MOVAB	(R7),RAB$L_FAB(R8)	; FAB ADDRESS
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R8); RECORD ACCESS
	MOVAB	(R9),RAB$L_UBF(R8)	; USER BUFFER ADDRESS (ON STACK)
	MOVW	#RCBFSZ,RAB$W_USZ(R8)	; USER BUFFER SIZE

	$CONNECT	RAB=(R8)
	BLBC	R0,70$			; CONNECT ERROR

20$:	; READ A LINE FROM FILE
	$GET	RAB=(R8)
	BLBC	R0,70$			; ERROR (ASSUME END OF FILE)

	; GET LENGTH OF RECORD AND STORE A 0 AT THE END (FOR PARSING ROUTINES)
	MOVZWL	RAB$W_RSZ(R8),R0	; RECORD SIZE
	CLRB	(R9)[R0]		; WE NOW HAVE AN ASCIZ STRING

	; IS THIS LINE INTERESTING? (DOES IT BEGIN WITH %)
	MOVL	R9,R6			; POINTER TO BUFFER
	CMPB	(R6)+,#^A/%/
	BNEQ	20$			; NOT OF INTEREST.  GET NEXT LINE

	; NOW GET FIRST TOKEN ON LINE AND SEE IF IT MATCHES INPUT SYMBOL
	BSBW	CHR$GETOKEN		; RETURNS TOKEN DESCRIPTOR IN R3,R4
	BEQL	20$			; NULL TOKEN; GET NEXT LINE
	CMPC5	R10,(R11),#0,R3,(R4)	; IT IS CONSIDERED A MATCH IF THE INPUT
	TSTW	R0			; SYMBOL IS AN INITIAL SUBSTRING OF THE
					; TOKEN (R0=0)
	BNEQ	20$			; NO MATCH; GET NEXT LINE

	; HAVE A MATCH.  R6 POINTS TO NEXT TOKEN (HOPEFULLY VALUE)
	BSBW	CHR$GETOKEN
	BEQL	70$			; NULL TOKEN --> ERROR

	; HAVE TOKEN.  SET UP TO CALL ROUTINE TO CONVERT TO BINARY
	MOVQ	R3,-(SP)		; PUT TOKEN DESCRIPTOR ON STACK

	; BUILD ARGUMENT LIST ON STACK
	PUSHAQ	(SP)			; POINTER TO TOKEN DESCRIPTOR
	CALLS	#1,LIB$CVT_DECBIN	; CONVERT TO BINARY
	CLRQ	(SP)+			; REMOVE DESCRIPTOR
	BLBC	R0,70$			; CONVERSION ERROR

50$:	; SUCCESS RETURN (WITH CLOSE).  VALUE IS IN R1
	PUSHL	R1			; SAVE R1 ACROSS CLOSE
	$CLOSE	FAB=(R7)		; CLOSE FILE
	POPR	#^M<R1>			; RESTORE R1

60$:	; SUCCESS RETURN (WITHOUT CLOSE).  VALUE IS IN R1.
	MOVL	#CLI$_NORMAL,R0		; INDICATE SUCCESS
	CMPL	(AP),#1			; STORE IN MEMORY IF MORE THAN ONE ARG
	BLEQU	90$			; DON'T STORE
	MOVB	R1,@8(AP)		; STORE
	BRB	90$

70$:	; FAILURE RETURN (WITH CLOSE)
	$CLOSE	FAB=(R7)		; CLOSE FILE

80$:	; FAILURE RETURN (WITHOUT CLOSE)
	MOVL	#CLI$_VALCNVERR,R0	; INDICATE CONVERSION ERROR

90$:	RET
	


	.END
