	.TITLE	SHOW$ERROR	- SHOW ERRORS - DISPLAYS ERROR COUNTS
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;

;++
;  FACILITY :	DCL SHOW COMMAND
;
; ABSTRACT:	SHOW ERROR
;		This module implements the DCL SHOW ERRORS command.
;		Error counts are retrieved from the system's device data base
;		are printed on SYS$OUTPUT:.
;
;
; ENVIRONMENT:
;
;	RUNS IN USER MODE BUT REQUIRES PRIVILEGE TO CHANGE MODE TO KERNEL
;
;
; AUTHOR: 	Herb Jacobs,		CREATION DATE: 01-Jan-1982
;
; MODIFIED BY:
;
;	V001	TMH0001		Tim Halvorsen		04-Feb-1982
;		Remove reference to CLI$K_ symbols at assembly time.
;--


	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$DDBDEF				; DEVICE DATA BLOCK DEFINITIONS
	$UCBDEF				; UNIT CONTROL BLOCK DEFINITIONS
	$CLIDEF				; CLI DEFINITIONS

;
; EQUATED SYMBOLS:
;
	$M_FULL	 = 1			; /FULL QUALIFIER BIT
	$V_FULL	 = 0			; BIT POSITION OF /FULL
;
; OWN STORAGE
;

	.PSECT	SHOW$RWDATA	LONG,RD,WRT,NOEXE
;
; DEFINE CLI CALL BACK STRUCTURES
;
SHOW_ERROR_GETQU:
	$CLIREQDESC	-			; CLI REQUEST DESCRIPTOR BLOCK
		RQTYPE=CLI$K_GETQUAL, -		; TO GET QUALIFIERS
		QUALST=SHOW_ERROR_QUALS		; POINTER TO QUALIFIER LIST
SHOW_ERROR_QUALS:
	$CLIQUALDEF	-			;
		QDCODE=CLI$K_SHER_FULL, -	; SHOW ERROR/FULL
		TRUACT=ERROR_FULL		; ACTION ROUTINE
	$CLIQUALDEF	END_LIST		; END OF QUALIFIER LIST

;
; THE FOLLOWING 2 LONGWORDS MUST BE ADJACENT FOR RETURN FROM $EXPREG
;
AREA_DESC:
	.LONG	0			; STARTING ADDRESS OF SCRATCH MEMORY
END_ADDR:
	.LONG	0			; ENDING ADDRESS OF SCRATCH MEMORY
BITLIST:
	.LONG	0			; CLI BIT LIST AREA
FLAGS:
	.LONG	0			; FLAGS TO INDICATE QUALIFIER FLAGGING

	.PSECT	SHOW$MSG_TEXT	BYTE,RD,NOWRT,NOEXE


	.SBTTL	SHOW$ERROR	- MAIN ROUTINE BODY
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine represents the main control flow of the
;	the SHOW ERRORs command after all calls to the CLI have been
;	processed.
;
; CALLING SEQUENCE:
;
;	CALLS	or 	CALLG
;
; INPUT PARAMETERS:
;
;	none
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 =	SS$_NORMAL  : success
;		anything else  : error code as returned by system service
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

	.ENTRY	-
SHOW$ERRORS,	^M<>
;
; REQUEST QUALIFIERS FROM CLI
;
	PUSHAB	W^BITLIST		; BIT LIST
	PUSHAB	W^SHOW$A_CLIWORK	; CLI WORK AREA
	PUSHAB	W^SHOW_ERROR_GETQU	; CLI REQUEST QUALIFIER PARSING
	CALLS	#3,@CLI$A_UTILSERV(AP)	; CALL CLI UTILITY SERVICE ROUTINE
	BLBC	R0,90$			; BRANCH IF ERROR
;
; ALLOCATE SCRATCH SPACE TO COPY I/O DATA BASE
;
	$EXPREG_S	-		; ALLOCATE SPACE TO COPY I /O DATA BASE
		PAGCNT=#64, -		; HOW MANY PAGES
		RETADR=W^AREA_DESC	; QUADWORD TO RECIEVE ADDRESS SPACE
	BLBC	R0,90$			; BRANCH ON ERROR
10$:	$CMKRNL_S W^CREATE_LIST		; COPY DEVICE DATA BASE INTERLOCKED
	BLBC	R0,90$			; BRANCH IF ERROR ENCOUNTERED
	CALLS	#0,W^OUTPUT_LIST	; FORMAT AND PRINT INFORMATION
90$:	MOVL	R0,W^SHOW$L_STATUS	; SAVE THE RETURN VALUE
	RET

	.ENTRY	-
ERROR_FULL,	^M<>
	BISB	#$M_FULL,W^FLAGS	; SET /FULL QUALIFIER
	RET

	.SBTTL	CREATE_LIST	- COPY DEVICE DATA BASE
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called via the 'Change mode to Kernel' system service.
;
;	After requesting a read lock on the I/o data base, it copies
;	a subset of the latter to a previously allocated scratch area,
;	(using a predefined structure), then releases the lock before returning
;
;	Each successfully comleted call will result in the name from the
;	DDB/UCB and error count from the UCB.
;
;	All devices are returned except MAILBOXES and TERMINALS.
;
; CALLING SEQUENCE:
;
;	This routine is called via the 'Change mode to Kernel' System service
;
; INPUT PARAMETERS:
;
;	AREA_DESC =  pointers to start and end of scratch area
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	The memory described by AREA_DESC is now filled with devices and
;	error counts.
;
;	END_ADDR = LAST USED ADDRESS
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0:	SS$_NORMAL	= success, data was copied
;		SS$_VASFULL	= too much data for 64 page EXPREG
;
; SIDE EFFECTS:
;
;	NONE
;
; REGISTER USAGE:
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

	.ENTRY	-
CREATE_LIST,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; lock I/O data base for read
;
	MOVL	L^SCH$GL_CURPCB,R4	; ADDRESS OF OUR PCB
;%%%
	JSB	L^SCH$IOLOCKR		; LOCK I/O DATA BASE FOR READ
	MOVL	W^AREA_DESC,R3		; PICK UP WORK AREA ADDRESS
	SUBL3	#512,W^AREA_DESC+4,R6	; FAIL IF WITHIN A PAGE OF END
	MOVAL	L^IOC$GL_DEVLIST-DDB$L_LINK,R11
					; ADDRESS OF ADDRESS OF FIRST DDB
10$:	MOVL	DDB$L_LINK(R11),R11	; GET NEXT DDB
	BEQL	80$			; BRANCH IF NO MORE
	MOVL	DDB$L_UCB(R11),R10	; GET FIRST UCB ADDRESS
	BEQL	10$			; BRANCH IF NO UCB ADDRESS
	BBS	#DEV$V_MBX,UCB$L_DEVCHAR(R10),10$ ; SKIP DDB IF MAILBOX
	MOVZBL	DDB$T_NAME(R11),R7	; LENGTH OF DEVICE NAME
	INCL	R7			; ADD ONE FOR COUNTED STRING
	MOVAL	DDB$L_UCB-UCB$L_LINK(R11),R10
					; GET ADDRESS OF ADDRESS OF FIRST UCB
20$:	MOVL	UCB$L_LINK(R10),R10	; GET NEXT UCB
	BEQL	10$			; BRANCH IF NO MORE
	CMPL	R3,R6			; ARE WE NEAR END OF AREA?
	BGEQU	70$			; BRANCH IF CHANCE OF AREA FILLING
	MOVW	UCB$W_ERRCNT(R10),R0	; GET THE ERROR COUNT
	BNEQ	30$			; BRANCH IF DEVICE HAS ERRORS
	BBC	#$V_FULL,W^FLAGS,20$	; BRANCH TO NOT INCLUDE 0 ERROR COUNTS
30$:	MOVW	R0,(R3)+		; PUT IN THE ERROR COUNT
	MOVW	UCB$W_UNIT(R10),(R3)+	; MOVE IN UNIT NUMBER
	MOVC3	R7,DDB$T_NAME(R11),(R3)	; MOVE IN THE DEVICE NAME
	BRB	20$			; GO FOR NEXT UCB

70$:	MOVL	#SS$_VASFULL,R0		; INDICATE FAILURE
	BRB	90$			; EXIT

80$:	MOVL	#SS$_NORMAL,R0		; INDICATE SUCCESS 
	MOVL	R3,END_ADDR		; SET LAST USED LOCATION OF DATA
90$:	PUSHL	R0			; SAVE RETURN CODE
	MOVL	L^SCH$GL_CURPCB,R4	; ADDRESS OF CURRENT PCB
	JSB	L^SCH$IOUNLOCK		; UNLOCK I/O DATA BASE
;%%%
	SETIPL	#0			; drop IPL 
	POPR	#^M<R0>			; restore status code
	RET				; and return

	.SBTTL	OUTPUT_LIST	- FORMAT AND PRINT DEVICE DATA
;++
; FUNCTIONAL DESCRIPTION:
;
; 	Controls formatting and printing of device information previously
;	copied into a scratch area.
;
; INPUT PARAMETERS:
;
;	END_ADDR  = END ADDRESS OF DATA TO BE FORMATTED
;	AREA_DESC = STARTING ADDRESS OF DATA TO BE FORMATTED
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	Any other is failure from an external call
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	SHOW$CODE	BYTE,RD,NOWRT,EXE

	.ENTRY	-
OUTPUT_LIST,	^M<>
	PUSHL	#SHOW$_ERROR		; MESSAGE IDENTIFIER
	PUSHL	#0			; NO FAO ARGUMENT LIST
	CALLS	#2,W^SHOW$PRINT_MSG	; PRINT MESSAGE
	PUSHL	#SHOW$_ERRORCPU		; MESSAGE IDENTIFIER
	PUSHAB	G^EXE$GL_MCHKERRS	; PUSH ADDRESS OF FAO ARGUMENT LIST
	CALLS	#2,W^SHOW$PRINT_MSG	; PRINT MESSAGE
	PUSHL	#SHOW$_ERRORMEM		; MESSAGE IDENTIFIER
	PUSHAB	G^EXE$GL_MEMERRS	; PUSH ADDRESS OF FAO ARGUMENT LIST
	CALLS	#2,W^SHOW$PRINT_MSG	; PRINT MESSAGE
	MOVQ	W^AREA_DESC,R3		; START ADDRESS OF LIST TO OUTPUT
					; AND END ADDRESS OF DATA
;
; process one UCB
;
10$:	CMPL	R3,R4			; ARE WE AT END OF LIST?
	BNEQ	30$			; BRANCH IF NOT
	MOVL	#SS$_NORMAL,R0		; INDICATE SUCCESS
20$:	RET

30$:	MOVZWL	(R3)+,-(SP)		; PUSH ERROR COUNT
	MOVZWL	(R3)+,-(SP)		; PUSH UNIT NUMBER
	PUSHL	R3			; PUSH ADDRESS OF COUNTED STRING
	MOVZBL	(R3)+,R0		; GET SIZE OF STRING
	ADDL	R0,R3			; SKIP PAST DEVICE NAME FOR NEXT TIME
	PUSHL	#SHOW$_ERRORDEV		; MESSAGE IDENTIFIER
	PUSHAB	4(SP)			; PUSH ADDRESS OF FAO ARGUMENT LIST
	CALLS	#2,W^SHOW$PRINT_MSG	; PRINT MESSAGE
	ADDL	#3*4,SP			; POP THE PREVIOUS ARGUMENT LIST
	BLBS	R0,10$			; LOOP THRU ALL COLLECTED DEVICES
	RET				; EXIT WITH ERROR STATUS

	.END
