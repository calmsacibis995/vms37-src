	.TITLE	SHOWTERM - SHOW CHARACTERISTICS OF A TERMINAL
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	CLI UTILITY "SHOW"
;
; ABSTRACT:	SHOW THE CHARACTERISTICS OF A TERMINAL
;
; AUTHOR:	R.HEINEN 21-NOV-1977
;
; MODIFIED BY:
;
;	V03-011 MIR0091		Michael I Rosenblum	23-Feb-1981
;		Show term on a spooled terminal without privs would
;		cause the QIO sensemode to return a nopriv error with
;		the side affect of clearing out the SENSEMODE buffer,
;		hence giving erronious information.
;
;	V03-010	MIR0072		Michael I Rosenblum	14-Jan-1981
;		Change case of some of the qualifiers.
;
;	V03-009	MIR0070		Michael I Rosenblun	21-Dec-1981
;		Replaced GETDEV with GETDVI.
;
;	V03-008 MIR0056		Michael I Rosenblum	9-Dec-1981
;		Added DECCRT, EDIT and SETSPEED.
;
;	V03-007	MIR0045		Michael I Rosenblum	29-Oct-1981
;	Add support for VK100 and the SUBSET bit.
;
;	V03-006	MIR0034		Michael I Rosenblum	10-Aug-1981
;	Fix bug in support of GETDEV feature to get the second device
;	dependent word.
;
;	V03-005	MIR0032		Michael I Rosenblum	31-Aug-1981
;	Fixed assembaly error on local symbol.
;
;	V03-004	MIR0017		Michael I Rosenblum	17-Aug-1981
;	Added support for the new terminal driver features,  Corrected
;	error in split speed code
;
;	V03-003	MIR0005		Michael I Rosenblum	31-July-1981
;	Fixed blank owner name now prints "not available"
;
;	V03-002	MIR0001		Michael I Rosenblum	30-July-1981
;	Reformatting of the output, activated split speed code
;	Added code to show username if different from process ID
;
;	V03-001	SBL3001		Steven B. Lionel,	26-June-1980
;		Remove trailing comma from HALFDUP/FULLDUP.
;
; 0105	TMH0001		T. Halvorsen	29-Dec-1979
;	Add foreign terminal types
;
; 0101	Gary Fowler	25-APR-79
;	Added terminal type VT100
;
; 0102	Gary Fowler	28-SEP-79
;	Modifed VT100 support to account for a change in definition
;	of TT$_VT100
;
; 0103	Gary Fowler	29-OCT-1979
;	Added terminal type LA120.  Fix problem when terminal has a
;	mailbox associated with it.  Add characteristic FORM/NOFORM
;
; 0104	Gary Fowler	30-NOV-1979
;	Added characteristics FULLDUPLEX/HALFDUPLEX
;
;--
;
; LOCAL MACROS
;
	.MACRO	CALLBAK	P1,P2
	.IF B <P2>
	PUSHAB	W^BITS			; ADDRESS OF BIT MASK
	.IFF
	PUSHAB	P2			; ADDRESS OF THIRD ARGUEMENT
	.ENDC
	PUSHAB	W^SHOW$A_CLIWORK	; COMMON WORK AREA
	PUSHAB	P1			; THE REQUEST DESCRIPTOR
	CALLS	#3,@CLI$A_UTILSERV(AP)	; REQUEST THE SERVICE OF THE CLI
	.ENDM				;

;
;	MACRO TO EASE CREATION OF NEW TERMINAL TYPES
;
	.MACRO	CRETYPE	TYPE
$$=.
	.ASCIC	/TYPE/
$$$=.
.=TYPE_NAME+<TT$_'TYPE*2>
.IF GREATER	.-END_NAME
	.ERROR	TT$_'TYPE	; TERMINAL TYPE DOES NOT FIT IN TYPE TABLE
.ENDC
	.WORD	$$
.=$$$
	.ENDM

;
;	MACRO TO HANDLE SYMBOL DEFINITIONS
;
	.MACRO	SYMCRE BIT,ON_STR,OFF_STR,ON_BASE_ADR,OFF_BASE_ADR
$$_ON=.
	.ASCIC	/ON_STR/
$$_OFF=.	
	.ASCIC	/OFF_STR/
$$$=.
.=ON_BASE_ADR+<'BIT*4>		;GET TO THE RIGHT PLACE (LONG WORD TABLE
	.ADDRESS $$_ON
.=OFF_BASE_ADR+<'BIT*4>		;AND DO THE SAME FOR THE OFF ADDRESS
	.ADDRESS $$_OFF
.=$$$
	.ENDM
;
;	MACRO TO CREATE DEVICE INFORMATION INTEMS
;
	.MACRO	$GDVITM	LEN,ITEM,ADR,LEN_ADR=0
	.WORD	LEN
	.WORD	DVI$_'ITEM
	.LONG	ADR
	.LONG	LEN_ADR
	.ENDM
;
; EXTERNAL SYMBOLS
;
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$DVIDEF				; DEFINE DEVICE INFO BLOCK
	$JPIDEF				; DEFINE JPI VALUES
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE SECOND TERMINAL CHAR LONGWORD

;
; LOCAL STORAGE
;
	.PSECT	SHOW$RWDATA,NOEXE,LONG
	
 
;
; STORAGE
;
CHAN:		.LONG	0		; TERMINAL CHANNEL NUMBER
BITS:		.LONG	0		; STORAGE FOR CLI CALL BACK
IOSB:		.LONG	0,0		; IOSB FOR TERMINAL GET CHARACTERISTICS
UTIL_DESC:	.LONG	0,0		; UTILITY DESC

TER_INFO:

TER$B_DEVCLASS:	.BYTE	0		; THE TERMINAL CLASS
TER$B_DEVTYPE:	.BYTE	0		; THE TERMINAL TYPE
TER$W_DEVBUFSIZ:.WORD	0		; THE WIDTH
TER$L_DEVDEP:	.WORD	0		; THE FIRST DEVICE DEPENDENT
		.BYTE	0		;..
TER$B_LENGTH:	.BYTE	0		; TERMINAL LENGTH
TER$L_DEVDEP2:	.LONG	0		; THE SECOND DEVICE DEPENDENT WORD

TER$L_PID:	.LONG	0		; THE OWNER PID
TER$L_UNIT:	.LONG	0		; THE UNIT NUMBER

TER$L_DEVCHAR:	.LONG	0		; THE DEVICE CHARACTERISTICS

TER$L_DEVNAMLN:	.LONG	0		; THE LENGTH OF THE DEVICE NAME
TER$B_DEVNAMCT:	.BYTE	0		; COUNT IN BYTE SIZE
TER$_DEVNAM:	.BLKB	15		; MAXIMUM OF 15 BYTES

TMP$L_DEVCLASS:	.LONG	0
TMP$L_DEVTYPE:	.LONG	0
TMP$L_DEVBUFSIZ:.LONG	0

TMPTRM_INFO:
		.BLKQ	1		; PLACE TO SAVE THE TERMINAL INFO
TMPTRM$L_DEVDEP2:
		.BLKL	1		;...
;
; MAIN DEVICE CHARACTERISTICS
;
GETDVI_INFO:	$GDVITM	4,DEVCHAR,TER$L_DEVCHAR
		$GDVITM	4,DEVCLASS,TMP$L_DEVCLASS
		$GDVITM	4,DEVTYPE,TMP$L_DEVTYPE
		$GDVITM	4,DEVBUFSIZ,TMP$L_DEVBUFSIZ
		$GDVITM	4,DEVDEPEND,TER$L_DEVDEP
		$GDVITM	4,DEVDEPEND2,TER$L_DEVDEP2
		$GDVITM	4,PID,TER$L_PID
		$GDVITM	4,UNIT,TER$L_UNIT
		$GDVITM	15,DEVNAM,TER$_DEVNAM,TER$L_DEVNAMLN
		.LONG	0
;
; SECONDARY COPY OF PRIMARY SPECS
;
SECDVI_INFO:	$GDVITM	4,DEVCHAR!DVI$C_SECONDARY,TER$L_DEVCHAR
		$GDVITM	4,DEVCLASS!DVI$C_SECONDARY,TMP$L_DEVCLASS
		$GDVITM	4,DEVTYPE!DVI$C_SECONDARY,TMP$L_DEVTYPE
		$GDVITM	4,DEVBUFSIZ!DVI$C_SECONDARY,TMP$L_DEVBUFSIZ
		$GDVITM	4,DEVDEPEND!DVI$C_SECONDARY,TER$L_DEVDEP
		$GDVITM	4,DEVDEPEND2!DVI$C_SECONDARY,TER$L_DEVDEP2
		$GDVITM	4,PID!DVI$C_SECONDARY,TER$L_PID
		$GDVITM	4,UNIT!DVI$C_SECONDARY,TER$L_UNIT
		$GDVITM	15,DEVNAM!DVI$C_SECONDARY,TER$_DEVNAM,TER$L_DEVNAMLN
		.LONG	0
;
; INFO NEEDED FOR SPOOLED DEVICES
;
SPLDVI_INFO:	$GDVITM	4,UNIT!DVI$C_SECONDARY,TER$L_UNIT
		$GDVITM	15,DEVNAM!DVI$C_SECONDARY,TER$_DEVNAM,TER$L_DEVNAMLN
		.LONG	0
;
; SPOOLED DEVICE INFO
;
SPOOL_DEV:	.LONG	48
		.LONG	10$
10$:		.BLKL	16
;
NUMPERLINE==4
SAVECHAN:	.BLKL	1

CHAR_LIST:	.REPT	40
		.LONG	NULL_STRING
		.ENDR
NULL_STRING:	.BYTE	0
;
; CLI DATA BASE
;
TERMNAME:
	$CLIREQDESC	RQTYPE=CLI$K_INPUT1	; GET THE INPUT OR TERMINAL NAME
GET_QUAL:				; GET THE QUALIFIERS
	$CLIREQDESC	RQTYPE=CLI$K_GETQUAL,QUALST=QUAL_LIST
QUAL_LIST:				; QUALIFIER LIST
	$CLIQUALDESC	QDCODE=CLI$K_SHTE_PERM,TRUACT=PERM,FLSACT=NOT_PERM
	$CLIQUALDESC	END_LIST
;
; TYPE NAMES
;
TYPE_NAME:
.repeat	7
	.word	UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK,UNK
.endr
END_NAME:
UNK:	.ascic	/Unknown/
	cretype	LA36
	cretype	LA120
	cretype	LA34
	cretype	LA38
	cretype	LA12
	cretype	LA24
	cretype LA100
	cretype	LQP02
	cretype	VT55
	cretype	VT52
	cretype	VT05
	cretype	VT100
	cretype	VT101
	cretype	VT102
	cretype	VT105
	cretype	VT125
	cretype	VT131
	cretype	VT132
	cretype	VT173
	cretype	VK100
	cretype	FT1
	cretype	FT2
	cretype	FT3
	cretype	FT4
	cretype	FT5
	cretype	FT6
	cretype	FT7
	cretype	FT8
;
; POSITIVE CHARACTERISTIC STRINGS
;
POSITIVE_NAME:
	.LONG	1$,2$,3$,4$,5$,6$,0,7$,8$,9$,0,0,10$,11$,12$,13$,0,14$,15$,16$,17$,18$
1$:	.ASCIC	/Passall/
2$:	.ASCIC	/No Echo/
3$:	.ASCIC	/No Typeahead/
4$:	.ASCIC	/Escape/
5$:	.ASCIC	/Hostsync/
6$:	.ASCIC	/TTsync/
7$:	.ASCIC	/Lowercase/
8$:	.ASCIC	/Tab/
9$:	.ASCIC	/Wrap/
10$:	.ASCIC	/Scope/
11$:	.ASCIC	/Remote/
12$:	.ASCIC	/Holdscreen/
13$:	.ASCIC	/Eightbit/
14$:	.ASCIC	/No Broadcast/
15$:	.ASCIC	/Readsync/
16$:	.ASCIC	/Form/
17$:	.ASCIC	/Halfdup/
18$:	.ASCIC	/Modem/
;
; NEGITIVE CHARACTERISTIC STRINGS
;
NEGITIVE_NAME:
	.LONG	1$,2$,3$,4$,5$,6$,0,7$,8$,9$,0,0,10$,11$,12$,13$,0,14$,15$,16$,17$,18$
NUMCHRS1=<<.-NEGITIVE_NAME>/4>-1
1$:	.ASCIC	/Interactive/
2$:	.ASCIC	/Echo/
3$:	.ASCIC	/Type_ahead/
4$:	.ASCIC	/No Escape/
5$:	.ASCIC	/No Hostsync/
6$:	.ASCIC	/No TTsync/
7$:	.ASCIC	/Uppercase/
8$:	.ASCIC	/No Tab/
9$:	.ASCIC	/No Wrap/
10$:	.ASCIC	/Hardcopy/
11$:	.ASCIC	/No Remote/
12$:	.ASCIC	/No Holdscreen/
13$:	.ASCIC	/No Eightbit/
14$:	.ASCIC	/Broadcast/
15$:	.ASCIC	/No Readsync/
16$:	.ASCIC	/No Form/
17$:	.ASCIC	/Fulldup/
18$:	.ASCIC	/No Modem/
;
; Second devdepent word
;
POS2:
	.LONG	0$,1$,2$,0,4$,0,6$,7$,8$,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24$,25$,26$,27$,28$,29$
0$:	.ASCIC	/Local_echo/
1$:	.ascic	/Autobaud/
2$:	.ascic	/Hangup/
4$:	.ascic	/Brdcstmbx/
5$:	.ascic	/XON/
6$:	.ascic	/DMA/
7$:	.ascic	/Altypeahd/
8$:	.ascic	/No Set_speed/

24$:	.ascic	/ANSI_CRT/
25$:	.ascic	/Regis/
26$:	.ascic	/Block_mode/
27$:	.ascic	/Advanced_video/
28$:	.ascic	/Edit_mode/
29$:	.ascic	/DEC_CRT/
;
; Negitive of the second devdepent longword
;
neg2:
	.LONG	0$,1$,2$,0,4$,0,6$,7$,8$,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24$,25$,26$,27$,28$,29$
NUMCHRS2=<<.-NEG2>/4>-1
0$:	.ascic	/No Local_echo/
1$:	.ascic	/No Autobaud/
2$:	.ascic	/No Hangup/

4$:	.ascic	/No Brdcstmbx/
5$:	.ascic	/XOFF/
6$:	.ascic	/No DMA/
7$:	.ascic	/No Altypeahd/
8$:	.ascic	/Set_speed/

24$:	.ascic	/No ANSI_CRT/
25$:	.ascic	/No Regis/
26$:	.ascic	/No Block_mode/
27$:	.ascic	/No Advanced_video/
28$:	.ascic	/No Edit_mode/
29$:	.ascic	/No DEC_CRT/

EPAR:	.ASCIC	/Even/
OPAR:	.ASCIC	/Odd/
NOPAR:	.ASCIC	/None/
SPEED:	.WORD	0,50,75,110,134,150,300,600,1200,1800,2000,2400,3600,4800,-
		7200,9600,19200
SYS_COMMAND:
	.ASCID	/SYS$COMMAND/
;
; SPACE FOR PROCESS OWNER NAME AND GETJPI
;
OWNER_NAME:	.LONG	20
		.LONG	10$
10$:		.BLKB	20
USER_NAME:	.LONG	20
		.LONG	20$
20$:		.BLKB	20
JPI_ITEM:	.WORD	20
		.WORD	JPI$_PRCNAM
		.LONG	OWNER_NAME+8
		.LONG	OWNER_NAME
		.WORD	20
		.LONG	0
JPI_USER:	.WORD	20
		.WORD	JPI$_USERNAME
		.LONG	USER_NAME+8
		.LONG	USER_NAME
		.LONG	0
;
; NO OWNER NAME
;
NO_OWNER:	.LONG	20$-10$
		.LONG	10$
10$:		.ASCII	/No Owner/
20$:		
NOT_AVAIL:	.LONG	20$-10$
		.LONG	10$
10$:		.ASCII	/Not Available/
20$:
BLNK:	.WORD	0
LFTPRN:	.ASCIC	/(/
RITPRN:	.ASCIC	/)/

	.PSECT	SHOW$CODE,NOWRT
;++
; SHOW$TERM - SHOW TERMINAL CGHARACTERISTICS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SHOWS THE CHARACTERISTICS OF A SPECIFIED TERMINAL.
; IT IS ENTERED AS A RESULT OF A DISPATCH FROM THE SHOW COMMAND PROCESSOR.
;
; INPUTS:
;
;	THE CLI DATA BASE IS SET UP. 
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;--
SHOW$TERM::				; SHOW TERMINAL COMMAND
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVAB	W^TERMNAME,R6		; ADDRESS QUAL DESC
	CALLBAK	(R6)			; CALL CLI FOR TERMINAL NAME
	MOVAB	CLI$Q_RQDESC(R6),R6	; ADDRESS NAME DESC
	TSTL	(R6)			; NAME PRESENT?
	BNEQ	20$			; IF NEQ THEN ASSIGN THAT NAME
;
; DEFUALT NAME IS "SYS$COMMAND"
;
	MOVZBL	#3,R5			; SET UP TRANSLATE COUNTER
	MOVAB	W^SYS_COMMAND,R6	; ADDRESS DESC FOR ORIGINAL NAME
10$:	MOVQ	W^SHOW$GQ_OUT_DSC,W^UTIL_DESC
	$TRNLOG_S	(R6),W^UTIL_DESC,W^UTIL_DESC; TRANSLATE NAME
	BLBC	R0,20$			; IF LOW CLEAR THEN DONE
	CMPW	R0,#SS$_NOTRAN		; DONE?
	BEQL	20$			; IF EQL THEN YES
	MOVQ	W^UTIL_DESC,(R6)	; SET UP FOR NEXT TRANSLATION
	CMPB	@4(R6),#^X01B		; ESCAPE?
	BNEQ	15$			; IF NEQ THEN CONTINUE
	SUBL	#4,(R6)			; FOUND PROCESS PERM NAME
	ADDL	#4,4(R6)		;
	BRB	20$			; 
15$:	SOBGTR	R5,10$			; CONTINUE UNTIL DONE
;
; GET DEVICE INFO IN CASE THE TERMINAL IS ASSIGNED TO SOMEONE ELSE
;
; THIS ALLOWS SOME INFORMATION TO BE PRINTED.
;
20$:	MOVL	R6,SAVECHAN		; KEEP THE DEVICE NAME IN HAND
	$GETDVI_S	DEVNAM=(R6),ITMLST=SECDVI_INFO,EFN=#3
	MOVZWL	R0,W^SHOW$L_STATUS	; COPY CODE
	BLBS	R0,23$			; BR IF ERROR - NO SUCH DEVICE
21$:	RET
23$:	$WAITFR_S EFN=#3			; WAIT TILL WE ARE DONE
	BBC	#DEV$V_MBX,W^TER$L_DEVCHAR,25$	; CHECK IF MAILBOX
	$GETDVI_S	DEVNAM=(R6),ITMLST=GETDVI_INFO,EFN=#3; YES THEN GET
					; THE SECONDARY CHARACTERISTICS
	MOVZWL	R0,W^SHOW$L_STATUS	;GET A STATUS CODE
	BLBC	R0,21$			;BAD SCEAN
	$WAITFR_S EFN=#3

25$:	CVTLB	TMP$L_DEVCLASS,TER$B_DEVCLASS; CONVERT THE DEVICE CLASS
	CVTLB	TMP$L_DEVTYPE,TER$B_DEVTYPE; CONVERT THE DEVICE TYPE
	CVTLW	TMP$L_DEVBUFSIZ,TER$W_DEVBUFSIZ; AND THE TERMINAL WIDTH
	CVTLB	TER$L_DEVNAMLN,TER$B_DEVNAMCT; MAKE A DEVICE NAME COUNTED STRING

	MOVZWL	#SS$_IVDEVNAM,W^SHOW$L_STATUS; ASSUME DEVICE NOT TERMINAL
	BBC	#DEV$V_TRM,W^TER$L_DEVCHAR,40$; BR IF NOT TERMINAL
;
; TRY TO ASSIGN A CHANNEL TO THE TERMINAL  - TO GET SPEED AND PARITY
;
	$ASSIGN_S	(R6),W^CHAN	; ASSIGN CHANNEL TO DEVICE
	BLBC	R0,30$			; IF LOW CLEAR THEN PRINT WHAT'S AVAIL
	MOVQ	W^TER_INFO,W^TMPTRM_INFO; SAVE THE RECIEVED INFO INCASE OF
	MOVL	W^TER$L_DEVDEP2,W^TMPTRM$L_DEVDEP2;
	CLRQ	W^TER_INFO		;CLEAN THE INFO BLOCK OUT
	CLRL	W^TER$L_DEVDEP2		;AND THE SECOND DEVICE DEPENDENT WORD
	$QIOW_S	#1,W^CHAN,#IO$_SENSEMODE,W^IOSB,P1=W^TER_INFO,P2=#12
	BLBS	R0,30$			;NO ERROR THEN START THE NORMAL WORK
	MOVQ	W^TMPTRM_INFO,W^TER_INFO; RESTORE THE TERMINAL INFORMATION
	MOVL	W^TMPTRM$L_DEVDEP2,TER$L_DEVDEP2; AND SAVE THE ERROR
30$:	MOVL	R0,W^SHOW$L_STATUS	; SAVE ERROR CODE
	CALLBAK	W^GET_QUAL		; PROCESS THE QUALIFIERS
	$DASSGN_S	W^CHAN		; DEASSIGN CHANNEL
40$:	RET				; DONE
;
; PERMANENT QUALIFIER ROUTINE
;
PERM:	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>; PROCESS PERMANENT QUALIFIER
	BLBC	W^SHOW$L_STATUS,15$	; BR IF CHANNEL NOT ASSIGNED
	CLRQ	TER_INFO		;CLEAN THE INFO BLOCK OUT
	CLRL	TER$L_DEVDEP2		;FOR COMPATABILITY REASONS
	$QIOW_S	#0,W^CHAN,#IO$_SENSECHAR,W^IOSB,P1=W^TER_INFO,P2=#12
	BLBC	R0,5$			; BR IF NOT SUCCESS
	MOVZWL	W^IOSB,R0		; GET IOSB STATUS
	BLBS	R0,PRINT		; AND CONTINUE IF SUCCESS
5$:	MOVL	R0,W^SHOW$L_STATUS	; SAVE STATUS
	RET
15$:	MOVZWL	#SS$_NOPRIV,W^SHOW$L_STATUS; ASSUME NO PRIVILEGE
	RET
;
; OUTPUT CHARACTERISTICS AND NON-PERMANENT QUALIFIER ROUTINE
;
NOT_PERM:.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>; NOT  PERMANENT ENTRY
PRINT::					;
;
; OUTPUT NAME, TYPE, WIDTH AND PAGE AND OWNER
;
	MOVQ	W^NO_OWNER,W^CHAR_LIST+8; USE AN INOCUIOUS OWNER IF IT IS
	MOVAL	W^BLNK,W^CHAR_LIST+16
	MOVAQ	W^USER_NAME,W^CHAR_LIST+20; AND THE USER NAME
	MOVAL	W^BLNK,W^CHAR_LIST+24
	TSTL	TER$L_PID		;CHECK TO SEE IF THERE IS AN OWNER
	BEQL	3$			; NO OWNER THEN LEAVE AS A DEFAULT
	$GETJPI_S	ITMLST=W^JPI_ITEM,PIDADR=W^TER$L_PID
	BLBS	R0,2$
	MOVQ	W^NOT_AVAIL,W^CHAR_LIST+8
	BRB	3$
2$:	MOVQ	W^OWNER_NAME,W^CHAR_LIST+8; INSERT PARAMS
	$GETJPI_S	ITMLST=W^JPI_USER,PIDADR=W^TER$L_PID
	CMPC3	W^OWNER_NAME,@W^OWNER_NAME+4,@W^USER_NAME+4
	BNEQ	4$
3$:	CLRL	W^USER_NAME
	BRB	5$
4$:	MOVAL	W^LFTPRN,W^CHAR_LIST+16	;LEFT PAREN
	MOVAL	W^RITPRN,W^CHAR_LIST+24	;RIGHT PAREN
	LOCC	#^A/ /,W^USER_NAME,@USER_NAME+4; GET RID OF THE TRAILING BLANKS
	BEQL	5$
	SUBW2	R0,W^USER_NAME	
5$:	MOVAB	W^TER$B_DEVNAMCT,W^CHAR_LIST; ADDRESS NAME
	CLRL	R4			; ASSUME UNKNOWN
	CMPB	W^TER$B_DEVTYPE,#<END_NAME-TYPE_NAME>/2; IN RANGE?
	BGTRU	10$
 	MOVZBL	W^TER$B_DEVTYPE,R4	; GET TYPE VALUE
10$:	MOVZWL	W^TYPE_NAME[R4],W^CHAR_LIST+4; ADDRESS TYPE
	PUSHL	S^#SHOW$_TERM_L1		; OUTPUT MESSAGE
	PUSHAB	W^CHAR_LIST		;
	CALLS	#2,W^SHOW$PRINT_MSG
;
; OUTPUT PRIVILEGED LINE OF INFORMATION
;
	BLBC	W^SHOW$L_STATUS,30$; IF ASSIGN FAILED THEN NO SPEED LINE
	MOVZBL	W^IOSB+3,R7		; GET THE SPEED
	BNEQ	24$			;IF IT WERN'T ZERO THEN USE THIS SPEED
	MOVZBL	W^IOSB+2,R7		;ELSE USE THE OTHER SPEED
24$:	MOVZWL	W^SPEED[R7],W^CHAR_LIST	;
	MOVZBL	W^IOSB+5,W^CHAR_LIST+4	; INSERT LF FILL
	MOVZWL	W^TER$W_DEVBUFSIZ,W^CHAR_LIST+8; INSERT WIDTH
	MOVAB	W^NOPAR,W^CHAR_LIST+12	; ASSUME NO PARITY
	BBC	#TT$V_PARITY,W^IOSB+6,25$; PARITY?
	MOVAB	W^EPAR,W^CHAR_LIST+12	; ASSUME EVEN
	BBC	#TT$V_ODD,W^IOSB+6,25$	; BR IF EVEN
	MOVAB	W^OPAR,W^CHAR_LIST+12	;
25$:	PUSHL	S^#SHOW$_TERM_L2	;USE OUR SECOND LINE
	PUSHAB	W^CHAR_LIST		;AND USE THE NORMAL CHARACTERISTIC LIST
	CALLS	#2,W^SHOW$PRINT_MSG	;SHOW THE MESSAGE
	MOVZBL	W^IOSB+2,R8		; SPEED OUT
	MOVZWL	W^SPEED[R8],W^CHAR_LIST		
	MOVZBL	W^IOSB+4,W^CHAR_LIST+4	; INSERT CR FILL
	MOVZBL	W^TER$B_LENGTH,W^CHAR_LIST+8; INSERT PAGE
	PUSHL	S^#SHOW$_TERM_L3	; OUTPUT MESSAGE
	PUSHAB	W^CHAR_LIST		;
	CALLS	#2,W^SHOW$PRINT_MSG	;
;
; OUTPUT CHARACTERISTICS DATA
;
30$:	CLRL	R4
	MOVAB	W^CHAR_LIST,R6
	PUSHL	S^#SHOW$_TERM_L4	; SET UP FOR CALL
	PUSHL	R6			;
	MOVL	S^#NUMPERLINE-1,(R6)+	; HOW MANY OF THESE ARE ON A LINE
	MNEGL	#1,R5			;START R5 AS NEGITIVE 1

50$:	MOVL	W^POSITIVE_NAME[R4],(R6); ASSUME POSITIVE
	BEQL	65$
	INCL	R5
	CMPB	R5,S^#NUMPERLINE	;KEEP COUNT OF HOW MANY OF THESE WE USE
	BNEQ	55$			; IF WE DON'T HAVE 5 THEN DON'T WORRIE
	MOVL	(R6),4(R6)		;MOVE THE LOCATION UP 1 LONG WORD
	MOVL	S^#NUMPERLINE-1,(R6)+	;MOVE UP 1 AND PUT IN THE COUNT
	CLRL	R5
55$:	BBS	R4,W^TER$L_DEVDEP,60$	; BR IF POSITIVE
	MOVL	W^NEGITIVE_NAME[R4],(R6); SET NEGITIVE
60$:	TSTL	(R6)+			; MOVE TO NEXT
65$:	INCL	R4
	CMPL	R4,#NUMCHRS1		; TEST IF DONE YET
	BLEQU	50$

	CLRL	R4			; START OVER WITH R4

70$:	MOVL	W^POS2[R4],(R6)		; ASSUME POSITIVE
	BEQL	80$			; IF NOTHING THERE TO ASUME THEN DON'T
	INCL	R5
	CMPB	R5,#NUMPERLINE		;KEEP COUNT OF HOW MANY OF THESE WE USE
	BNEQ	73$			; IF WE DON'T HAVE 5 THEN DON'T WORRIE
	MOVL	(R6),4(R6)		;MOVE THE LOCATION UP 1 LONG WORD
	MOVL	#NUMPERLINE-1,(R6)+	;MOVE UP 1 AND PUT IN THE COUNT
	CLRL	R5
73$:	BBS	R4,W^TER$L_DEVDEP2,75$	; BR IF POSITIVE
	MOVL	W^NEG2[R4],(R6)		; SET NEGITIVE
75$:	TSTL	(R6)+			; MOVE TO NEXT
80$:	INCL	R4
	CMPL	R4,#NUMCHRS2		; TEST IF DONE YET
	BLEQU	70$

	ADDL2	#2,R5			;MOVE THE POINTER TO THE CORRECT SPOT
	MULL3	R5,#4,R0		;GET OUR OFFSET
	SUBL	R0,R6
	MOVAL	-2(R5),(R6)
	CALLS	#2,W^SHOW$PRINT_MSG
;
; OUTPUT SPOOLED DEVICE DATA
;
	BBC	#DEV$V_SPL,W^TER$L_DEVCHAR,85$; BR IF NOT SPOOLED DEVICE
	$GETDVI_S DEVNAM=@SAVECHAN,ITMLST=SPLDVI_INFO,EFN=#3;GET THE SPOOLED
	BLBC	R0,85$			; DEVICE CHARACTERISTICS (NO LUCK)
	$WAITFR_S EFN=#3		; WAIT FOR THE EVENT TO HAPPEN

	MOVL	W^TER$L_DEVNAMLN,W^CHAR_LIST; INSERT NAME SIZE
	SUBL2	#2,W^CHAR_LIST		;SUBTRACT 2 FROM THE SIZE OF THE LIST
	MOVAB	W^TER$_DEVNAM,W^CHAR_LIST+4; INSERT ADDRESS
	MOVL	W^TER$L_UNIT,W^CHAR_LIST+8; INSERT UNITNUMBER
	PUSHL	#SHOW$_TTLP_SPL		; OUTPUT MESSAGE
	PUSHAB	W^CHAR_LIST		;
	CALLS	#2,W^SHOW$PRINT_MSG
85$:	RET

	.END
