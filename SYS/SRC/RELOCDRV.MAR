	.TITLE	RELOCDRV - RELOCATE DRIVER DATABASE
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 16-JUN-78
;
; RELOCATE DRIVER DATABASE
;
; MODIFICATION HISTORY:
;
;	V02-003	KTA0058		Kerbey T. Altmann	30-Dec-1981
;		Change name to IOC$RELOC_DDT so symbol len <= 15.
;
;	V02-002	JLV0047		Jake VanNoy		13-Jul-1981
;		Added IOC$RELOC_DDT_FDT, called from SYSGEN and the
;		INIT module in SYS to relocate DDT's and FDT's to
;		absolute system addreses.
;
; MACRO LIBRARY CALLS
;
 
	$DDTDEF				;DEFINE DDT OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$DYNDEF				;DEFINE DATA STRUCTURE TYPES
	$IDBDEF				;DEFINE IDB OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE VEC OFFSETS
 
;
; LOCAL DATA
;
; STRUCTURE TYPE BYTE ARRAY
;
 
	.PSECT	Z$INIT_DRIVER
STYPE:	.BYTE	DYN$C_CRB,DYN$C_DDB,DYN$C_IDB,DYN$C_UCB ;

ASSUME	DDT$C_LENGTH EQ 38	; So new entries in DDT will be added here

RELOC_DDT_TABLE: ; All these offsets in the DDT must be relocated

	.BYTE	DDT$L_START
	.BYTE	DDT$L_UNSOLINT
	.BYTE	DDT$L_FDT
	.BYTE	DDT$L_CANCEL
	.BYTE	DDT$L_REGDUMP
	.BYTE	DDT$L_UNITINIT
	.BYTE	DDT$L_ALTSTART
	.BYTE	DDT$L_MNTVER
	.BYTE	-1			; End of table

	.PAGE
	.SBTTL	INITIALIZE DRIVER DATA BASE
;+
; IOC$INITDRV - INITIALIZE DRIVER DATA BASE
;
; THIS ROUTINE IS CALLED AFTER HAVING LOADED ALL OR PART OF A DEVICE DATA BASE.
; IT MUST BE CALLED FOR EACH UNIT THAT IS DEFINED. ITS FUNCTION IS TO USE THE
; INITIALIZATION TABLE IN THE DRIVER PROLOGUE TO INITIALIZE STATIC INFORMATION
; IN THE DRIVER DATA BASE.
;
; INPUTS:
;
;	R4 = ADDRESS OF DRIVER PROLOGUE TABLE.
;	R5 = ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;	THE DRIVER PROLOGUE TABLE IS INTERPRETED AND THE RESPECTIVE DATA BASE
;	IS INITIALIZED.
;
;	R0 LOW BIT CLEAR INDICATES A BAD DATA STRUCTURE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;-
 
	.ENABL	LSB
IOC$INITDRV::				;INITIALIZE DRIVER DATA BASE
	MOVZWL	DPT$W_INITTAB(R4),R3	;GET OFFSET TO INITIALIZATION TABLE
	BRB	10$			;BR TO COMMON CODE
	.PAGE
	.SBTTL	REINITIALIZE DRIVER DATA BASE
;+
; IOC$REINITDRV - REINITIALIZE DRIVER DATA BASE
;
; THIS ROUTINE IS CALLED AFTER HAVING LOADED A DRIVER WHOSE DEVICE DATA BASE IS
; ALREADY RESIDENT IN MEMORY. IT MUST BE CALLED FOR EACH UNIT THAT IS DEFINED.
; ITS FUNCTION IS TO INITIALIZE ONLY THOSE FIELDS IN THE DATA BASE THAT ARE NOT
; DYNAMIC.
;
; INPUTS:
;
;	R4 = ADDRESS OF DRIVER PROLOGUE TABLE.
;	R5 = ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;	THE DRIVER PROLOGUE TABLE IS INTERPRETED AND THE RESPECTIVE DATA BASE
;	IS REINITIALIZED.
;
;	R0 LOW BIT CLEAR INDICATES A BAD DATA STRUCTURE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;-
 
IOC$REINITDRV::				;REINITIALIZE DRIVER DATA BASE
	MOVZWL	DPT$W_REINITTAB(R4),R3	;GET OFFSET TO REINITIALIZATION TABLE
10$:	ADDL	R4,R3			;CALCULATE ADDRESS OF INITIALIZE TABLE
20$:	BSBB	LOCATE			;LOCATE STRUCTURE TYPE
	MOVZBL	(R3)+,R1		;GET OFFSET IN STRUCTURE
	ADDL	R1,R2			;CALCULATE BASE ADDRESS OF FIELD
	MOVZBL	(R3)+,R1		;GET OPERATION CODE
	BSBB	EXECUTE			;EXECUTE OPERATION CODE
	BRB	20$			;
	.DSABL	LSB
	.PAGE
	.SBTTL	LOCAL SUBROUTINE TO EXECUTE OPERATION CODE
;
; EXECUTE - EXECUTE OPERATION CODE
;
; THIS ROUTINE IS CALLED TO EXECUTE A SINGLE RELOCATION OPERATION CODE.
;
; INPUTS:
;
;	R1 = OPERATION CODE.
;	R2 = STRUCTURE FIELD BASE ADDRESS.
;	R3 = ADDRESS OF NEXT RELOCATION BYTE.
;	R4 = BASE ADDRESS OF DRIVER PROLOGUE TABLE.
;	R5 = ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;	IF AN INVALID OPERATION CODE IS SPECIFIED, A FAILURE IS RETURNED TO THE
;	CALLERS CALLER. ELSE THE OPERAND VALUE IS STORE IN THE SPECIFIED FIELD
;	IN THE SPECIFIED STRUCTURE.
;
 
EXECUTE:				;EXECUTE RELOCATION OPERATION
	CASE	R1,<-			;DISPATCH TO FETCH ROUTINE
		10$,-			;BYTE IMMEDIATE
		30$,-			;WORD IMMEDIATE
		50$,-			;WORD DISPLACED
		70$,-			;LONGWORD IMMEDIATE
		90$,-			;FIELD IMMEDIATE
		>
 
;
; INDIRECT OPERAND
;
 
	MOVL	@(R3)+,R0		;GET DATA LONGWORD
	CASE	R1,<-			;DISPATCH TO STORE ROUTINE
		20$,-			;STORE BYTE
		40$,-			;STORE WORD
		60$,-			;STORE WORD DISPLACED
		80$,-			;STORE LONGWORD
		100$,-			;STORE FILED
		>,LIMIT=#^X80		;
	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	CLRL	R0			;SET FAILURE INDICATION
	RSB				;
 
;
; BYTE IMMEDIATE
;
 
10$:	MOVZBL	(R3)+,R0		;GET DATA BYTE
20$:	MOVB	R0,(R2)			;STORE BYTE
	RSB				;
 
;
; WORD IMMEDIATE
;
 
30$:	MOVZWL	(R3)+,R0		;GET DATA WORD
40$:	MOVW	R0,(R2)			;STORE WORD
	RSB				;
 
;
; WORD DISPLACED
;
 
50$:	CVTWL	(R3)+,R0		;GET WORD DISPLACEMENT
60$:	ADDL	R4,R0			;CALCULATE ACTUAL ADDRESS
	BRB	80$			;
 
;
; LONGWORD IMMEDIATE
;
 
70$:	MOVL	(R3)+,R0		;GET DATA LONGWORD
80$:	MOVL	R0,(R2)			;STORE DATA LONGWORD
	RSB				;
 
;
; FIELD STRUCTURE
;
 
90$:	MOVL	(R3)+,R0		;GET DATA LONGWORD
100$:	MOVZBL	(R3)+,-(SP)		;GET STARTING BIT NUMBER
	MOVZBL	(R3)+,R1		;GET SIZE OF FIELD
	INSV	R0,(SP)+,R1,(R2)	;STORE FIELD
	RSB				;
	.PAGE
	.SBTTL	LOCAL SUBROUTINE TO LOCATE DATA STRUCTURE TYPE
;
; LOCATE - LOCATE DATA STRUCTURE TYPE
;
; INPUTS:
;
;	R5 = ADDRESS OF DEVICE UCB.
;
; OUTPUTS:
;
;	IF THE STRUCTURE TYPE CODE IS ZERO, THEN SUCCESS IS RETURNED TO THE CALLERS
;	CALLER. IF THE STRUCTURE TYPE CODE IS INVALID, THEN AN ERROR IS RETURNED
;	TO THE CALLERS CALLER. ELSE THE APPROPRIATE STRUCTURE BASE ADDRESS IS
;	RETURNED IN R2.
;
 
LOCATE:					;LOCATE DATA STRUCTURE TYPE
	BISB	#1,R0			;ASSUME END OF RELOCATION TABLE
	TSTB	(R3)			;END OF TABLE?
	BEQL	10$			;IF EQL YES
	LOCC	(R3)+,#4,STYPE		;LOCATE STRUCTURE CODE
	CASE	R0,<-			;DISPATCH TO STRUCTURE ROUTINE
		20$,-			;UCB
		30$,-			;IDB
		40$,-			;DDB
		50$,-			;CRB
		>,LIMIT=#1		;
10$:	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	RSB				;
 
;
; UCB STRUCTURE
;
 
20$:	MOVL	R5,R2			;SET UCB ADDRESS
	RSB				;
 
;
; IDB STRUCTURE
;
 
30$:	MOVL	UCB$L_CRB(R5),R2	;GET ADDRESS OF CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R2),R2 ;GET ADDRESS OF IDB
	RSB				;
 
;
; DDB STRUCTURE
;
 
40$:	MOVL	UCB$L_DDB(R5),R2	;GET ADDRESS OF DDB
	RSB				;
 
;
; CRB STRUCTURE
;
 
50$:	MOVL	UCB$L_CRB(R5),R2	;GET ADDRESS OF CRB
	RSB				;
.PAGE
.SBTTL	IOC$RELOC_DDT - relocate DDT and FDT to system addresses

;+
; 
; FUNCTIONAL DESCRIPTION:
;
;	This routine will relocate any driver-relative addresses to be
;	absolute system addresses.
;
; CALLING SEQUENCE:
;
;	JSB	IOC$RELOC_DDT
;
; INPUTS:
;
;	R11 - Address of DDB
;
; OUTPUTS:
;
;	R4,R5,R6 are destroyed, DDT and FDT are relocated.
;
; COMPLETION CODES:
;
;	None.
;
;-

IOC$RELOC_DDT::

;
; Relocate the driver dispatch table (DDT)
;

	MOVAB	RELOC_DDT_TABLE,R5	; Address of offsets table
	MOVL	DDB$L_DDT(R11),R4	; Addess of DDT

10$:	CVTBL	(R5)+,R6		; Get next offset
	BLSS	20$			; Branch if end of table
	ADDL2	R4,R6			; Add start address of driver to offset
	BBS	#31,(R6),10$		; Branch if already system address
	ADDL2	R4,(R6)			; Add in driver base
	BRB	10$			; Loop

;
; Relocate the function dispatch table (FDT)
;

20$:	MOVZWL	DDT$W_FDTSIZE(R4),R5	; Size of FDT
	MOVL	DDT$L_FDT(R4),R4	; Address of FDT
	ADDL2	R4,R5			; Add in base of FDT to get end
	ADDL2	#4,R4			; Initial offset past legal and 
					;  buffered I/O masks

30$:	ADDL2	#12,R4			; Get next dispatch block (12 bytes)
	CMPL	R5,R4			; Past end ?
	BLEQ	40$			; branch if yes
	BBS	#31,8(R4),30$		; Branch if already system address
	ADDL2	R4,8(R4)		; Add in current base
	BRB	30$

40$:	RSB
 
	.END
