	.TITLE	INIT PROCESSOR INITIALIZATION
	.IDENT	'V03-003'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; SYSTEM INITIALIZATION
;
; D. HUSTVEDT 17-SEP-76
;
; MODIFIED BY:
;
;	V03-003	PHL0043		Peter H. Lipman		06-Apr-1982
;		Boot Control Block Checksum must be initialized after
;		the system UCB address is stored in the system WCB.
;
;	V03-002	PHL0042		Peter H. Lipman		03-Apr-1982
;		Initialize checksum in Boot Control Block
;
;		Don't link the system WCB on the SYSWCB list since
;		the next insque will invalidate the BOOTCB checksum
;
;	V03-001	HRJ0060		Herb Jacobs		20-Mar-1982
;		Add back initialization of shell VBN and WINDOW pointer.
;		and set SWPFILCNT cell.
;
;	V02-068	KTA0078		Kerbey T. Altmann	15-Feb-1982
;		Change order of log name routines in boot device init.
;
;	V02-067	LJK0123		Lawrence J. Kenah	8-Feb-1982
;		Truncate MPW_WRTCLUSTER to multiple of 8. Allocate room
;		in MPW arrays for 7 additional entries (for bit-level
;		page file allocation).
;
;	V02-066	MKP0032		Kathy Perko		3-Feb-1982
;		Change BSBW to INI$BRK to a JSB so SYS will link for
;		systembuild.
;
;	V02-065	RLRUDA		Robert L. Rappaport	29-Jan-1982
;		Two changes for supporting UDA as a boot device.
;		First the virtual address of the port CSR is stored in
;		BOO$GL_SYSTEMID if we are booting from a UDA.  Second
;		the ADP address of the UNIBUS adapter block is stored in
;		the Class Driver CRB$L_INTD+VEC$L_ADP so as to facilitate
;		mapping requests later on in running the system.
;
;
;	V02-064	RIH0084		Richard I. Hustvedt	18-Jan-1982
;		Add initialization of SRP lookaside list.
;
;	V02-063	RIH0083		Richard I. Hustvedt	2-Jan-1982
;		Change initialzation of LRP and IRP lookaside lists to
;		accomodate automatic extension.
;
;	V02-062	KTA0057		Kerbey T. Altmann	28-Dec-1981
;		Redo the handling of the boot device, its control blocks
;		and the insertion into the I/O database.
;
;	V02-061	LJK0095		Lawrence J. Kenah	3-Dec-1981
;		Initialize cells in INI_RDONLY_LIST array with possibly
;		changing boundary between nonpaged and pageable exec.
;
;	V02-060	KTA0051		Kerbey T. Altmann	30-Nov-1981
;		Removed INI$PROCREG and UBA$INITIAL to SYSLOA where
;		all other CPU-dependent IPR code resides.
;
;	V02-059	SRB0042		Steve Beckhardt		30-Nov-1981
;		Added code to initialize LCK$GB_MAXDEPTH with maximum
;		allowable depth of resource names.
;
;	V02-058	WMC0013		Wayne Cardoza		16-Nov-1981
;		Add a miscellaneous initialization section. 
;		Put the global page file limit set-up in it.
;
;	V02-057	PHL0023		Peter H. Lipman		1-Nov-1981
;		Change SYS$SYSDISK to SYS$SYSDEVICE.
;		SYS$SYSDEVICE translates to a concealed device name
;		if the CONCEALED flag is set.
;
;	V02-056	JLV0107		Jake VanNoy		30-Oct-1981
;		Change TTYDEFS to $TTYDEFS.
;
;	V02-055	KTA0036		Kerbey T. Altmann	09-Oct-1981
;		Redo way loadable code vectors are connected.  Add new
;		file - SCSLOA.EXE.
;
;	V02-054	MLJ0051		Martin L. Jack,	30-Sep-1981  17:31
;		Move calculation of EXE$GL_TENUSEC above its possible use by
;		system device unit initialization routine.
;
;	V02-053	HRJ0028		Herb Jacobs		24-Aug-1981
;		Move shell to paged portion of exec and reference end of 
;		image via MMG$A_SYS_END. Fix addressing mode in invalidate
;		of bitmap page.
;
;	V02-052	SRB0031		Steve Beckhardt		20-Aug-1981
;		Added allocation of process bitmap, changed allocation
;		of lock id table and resource hash table.  Also added
;		initialization of EXE$GL_INTSTKLM which contains the
;		address of the top (limit) of the interrupt stack.
;
;	V02-051	LJK0048		Lawrence J. Kenah	20-Aug-1981
;		Page file control block vector initialization must
;		be done here and not in SYSINIT.
;
;	V02-050	LJK0044		Lawrence J. Kenah	13-Aug-1981
;		Eliminate reference to SFT, remove its macro call, and
;		change the code that initializes the base VBN of SHELL
;		to use PFL offsets.
;
;	V02-049	LJK0030		Lawrence J. Kenah	7-Aug-1981
;		Add changes necessary to support large physical memory
;		configurations. If more than 32 Mbytes of memory in
;		the PFN database, opcodes of relevant instructions are
;		modified from word context to longword context. The XDELTA
;		stored command that displays PFN onformation is altered.
;
;	V02-048	PHL0012		Peter H. Lipman		04-Aug-1981
;		The PFN bitmap from SYSBOOT via VMB can now be as large as 512
;		pages.  This covers the architectural limit of 21 bits of PFN.
;		12 bits worth = 4096 pages = 2mb fit in one page of bitmap. 9
;		additional bits gives 512 pages.  Since this is too many pages
;		to map at once, the INI_FREEMEM block of code has been altered
;		to map one bitmap page at a time. This new code also helps to
;		implement a MINPFN concept allowing PFN's below a given value
;		not to have PFN data base. 
;
;	V02-047	KTA0027		Kerbey T. Altmann	30-Jul-1981
;		Modify access to LOG$AL_LOGTBL for indirection. Also
;		add self-identifying header to all nonpaged entries.
;
;	V02-046	TCM0008		Trudy C. Matthews	30-Jul-1981
;		Changed all "7ZZ"s to "730"s.
;
;	V02-045	JLV0053		Jake VanNoy		30-Jul-1981
;		Changed interface between CONINTDSP (OPA0) and TTDRIVER.
;		Set address of DDT in UCB for system device and OPA0:.
;
;	V02-044	JLV0045		Jake VanNoy		13-Jul-1981
;		Added call to IOC$RELOC_DDT_FDT and removed relocation
;		of DDT$L_UNITINIT.
;
;	V02-043	KTA0023		Kerbey T. Altmann	22-Jun-1981
;		Redo some of the logical name initialization. Also
;		change some logic to allow for up to 16 adapters.
;
;	V02-042	TCM0007		Trudy C. Matthews	20-Jun-1981
;		Store IPR number of TU58 transmit data register in the
;		device IDB if we're booting from the console TU58 on a
;		11/750 or 11/730.  Also, rename a 16 character label to a
;		15 character one.
;
;	V02-041	STJ0049		Steven T. Jeffreys	18-Jun-1981
;		Allocate an SPT entry and map the blakhole page into
;		system space.  Create and save the system virtual address
;		of the SPT entry in EXE$GL_SVAPTE.
;
;	V02-040	KTA0022		Kerbey T. Altmann	14-Jun-1981
;		Reset the vectors for CHMK and CHME if the SSINHIBIT
;		bit is set in EXE$GL_FLAGS.
;
;	V02-039	PHL0010		Peter H. Lipman		05-Jun-1981
;		INIT no longer depends on SYS.EXE being contiguous.
;		It produces a Window Control Block from the map
;		passed in the Boot Control Block by SYSBOOT and
;		stores that WCB address in the section table entry
;		for the pageable portion of the EXEC and in the swap
;		file slot for the SHELL.
;
;	V02-038	TCM0006		Trudy C. Matthews	03-Jun-1981
;		Have INI_FREEMEM paragraph map an integral number of pages
;		of PFN bitmap.
;
;	V02-037	TCM0005		Trudy C. Matthews	08-May-1981
;		Add code to connect pointers to data structures in
;		loaded code.  Change reference to MMG$AL_SBICONF to
;		refer to MMG$GL_SBICONF instead (this field is now a
;		pointer to the array).  Clear RPB$L_ISP location to
;		initialize "successful completion of powerfail routine"
;		flag.
;
;	V02-036	SRB0018		Steve Beckhardt		23-Apr-1981
;		Added allocation of lock manager data structures.
;
;	V02-035	PHL0007		Peter H. Lipman		25-Mar-1981
;		Moved all the special non-paged pool allocation that
;		is done from the high end of pool into SYSBOOT.  This
;		allows SYSBOOT to place the new FIL$OPENFILE cache in
;		in high pool.  SYSINIT will release it when it is done
;		using it.  Pool allocation is now done in SYSBOOT for
;		the boot driver, system disk driver, terminal driver,
;		CPU dependent code (SYSLOAxxx), loadable init code
;		(INILOA).  With the exception of the boot driver, those
;		pieces of code are also read in to their location in 
;		pool by SYSBOOT.  The boot driver is moved into pool by
;		SYSBOOT and is ready to use when INIT goes mapped.
;
;	V02-034	TCM0004		Trudy C. Matthews	05-Feb-1981
;		Load loadable initialization module, INILOA.EXE.  Use loaded
;		routine INI$IOMAP to locate, initialize, and map all adapters
; 		on the system.
;
;	V02-033	SPF0002		Steve Forgey		29-Jan-1981
;		Shut interval timer off after calibrating wait loop.
;
;	V02-032	TCM0003		Trudy C. Matthews	19-Jan-1981
;		Move loading of SYSLOAxxx.EXE to before adapter I/O space is
;		mapped (use temporary mapping of boot device registers set up
;		when SYSBOOT called BOO$MAP).
;		Receive information about loadable files opened by SYSBOOT in
;		a "parameter block" instead of in registers.  The parameter
;		block is defined by module BOOPARAM.MAR, which is linked both
;		with SYSBOOT and INIT.
;		Also, remove definition of CPUDISP (now defined in SYSMAR).
;
;	V02-031	CAS0001		C. A. Samuelson		12-Dec-1980
;		Add count initialization for wait timer loop
;
;	V02-030	SPF0001		Steve Forgey		02-Oct-1980
;		Add large request packet look aside list initialization.
;
;	V02-029 WMC0001		Wayne Cardoza		3-Jul-1980
;		Make system service vectors non-pageable.
;
;
	.PAGE
; SYSTEM INITIALIZATION
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				; DEFINE ADP OFFSETS
	$BOODEF				; DEFINE BOOT CONTROL BLOCK OFFSETS
	$BTDDEF				; DEFINE BOOT DEVICE TYPES
	$CRBDEF				; DEFINE CRB OFFSETS
	$DCDEF				; DEFINE DEVICE CHARACTERISTICS
	$DDBDEF				; DEFINE DDB OFFSETS
	$DDTDEF				; DEFINE DDT OFFSETS
	$DPTDEF				; DEFINE DRIVER PROLOGUE
	$DYNDEF				; DEFINE DATA STRUCTURE TYPE CODES
	$IDBDEF				; DEFINE IDB OFFSETS
	$IPLDEF				; IPL DEFINITIONS
	$IRPDEF				; DEFINE IRP OFFSETS
	$LOGDEF				; DEFINE LOG OFFSETS
	$MPMDEF				; DEFINE MULTI-PORT MEMORY
	$NDTDEF				; DEFINE NEXUS-DEVICE TYPE CODES
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFLDEF				; PAGE FILE OFFSET DEFINITIONS
	$PFNDEF				; PFN DATA BASE OFFSET DEFINITIONS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE IPR NUMBERS
	$PRTDEF				; DEFINE PAGE PROTECTION CODES
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$PTRDEF				; POINTER CONTROL BLOCK OFFSETS
	$RBMDEF				; Define realtime SPT bit map
	$RPBDEF				; DEFINE RESTART PARAMETER BLOCK
	$SECDEF				; SECTION TABLE OFFSET DEFINITIONS
	$UBADEF				; DEFINE UBA REGISTER OFFSETS
	$UBIDEF				; DEFINE UNIBUS INTERCONNECT
					;  REGISTER OFFSETS
	$UCBDEF				; DEFINE UCB OFFSETS
	$TTYDEFS			; DEFINE TERMINAL DRIVER OFFSETS
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$VECDEF				; DEFINE VEC OFFSETS
	$WCBDEF				; DEFINE WINDOW CONTROL BLOCK OFFSETS
;
; LOCAL MACROS
;
;
; DEFINE RANGE OF PURE CODE/DATA MACRO:
;
	.MACRO	PURE,START,STOP		;
	.IF	NB	START
	.LONG	<START-<1@31>>@-7	;
	.IFF
	.LONG	0
	.ENDC
	.IF	NB	STOP
	.LONG	<STOP-^X80000200>@-7	;
	.IFF
	.LONG	0
	.ENDC
	.ENDM	PURE			;
	.PAGE
;
; LOCAL SYMBOLS
;
; CHARACTER DEFINITIONS
;
 
CR=13					; CARRIAGE RETURN
LF=10					; LINE FEED
DYN$C_HEADLEN=12			; LENGTH OF A SELF-IDENT HEADER
 
;
; LOCAL DATA
;
 
	.PSECT	Z$DEBUGA,PAGE		; PSECT TO MARK BASE OF XDELTA
XDELTABASE:				;
	.PSECT	Z$INIT000,LONG		; Psect to mark base of bootstrap
EXE$A_BOOPARAM::			; parameter block.
	.PSECT	Z$INIT,PAGE
INI_BASE:				;
;
; BOOT DEVICE LOGICAL NAME EQUIVALENCE
;
LOG$AL_DISKLOG::			; SYSTEM DEVICE LOGICAL NAME BLOCK
	.LONG	0			; FORWARD LINK
	.LONG	0			; BACKWARD LINK
	.WORD	DISKEND-LOG$AL_DISKLOG	; LENGTH OF LOGICAL NAME BLOCK IN BYTES
	.BYTE	DYN$C_LOG		; DATA STRUCTURE TYPE CODE
	.BYTE	LOG$C_SYSTEM		; LOGICAL NAME TABLE NUMBER
	.WORD	1			; UIC MEMBER NUMBER
	.WORD	1			; UIC GROUP NUMBER
	.LONG	0			; BOOT DEVICE UCB ADDRESS
	.ASCIC	/SYS$DISK/		; LOGICAL NAME STRING
	.BYTE	5			; COUNT OF NAME MINUS ANY DIGITS
	.ASCII	/_DXX000:/		; EQUIV NAME STRING ALLOW  _DUCU[uu]:
	.WORD	0			; SAFETY MARGIN
	.BLKB	<<<.-LOG$AL_DISKLOG>+15>&^C<15>>-<.-LOG$AL_DISKLOG> ;
DISKEND:				;

SYSDISKLOG:				; LOGICAL NAME BLOCK FOR SYS$SYSDEVICE
	.LONG	0			; FORWARD LINK
	.LONG	0			; BACKWARD LINK
	.WORD	SYSDISKEND-SYSDISKLOG	; LENGTH OF LOGICAL NAME BLOCK IN BYTES
	.BYTE	DYN$C_LOG		; DATA STRUCTURE TYPE CODE
	.BYTE	LOG$C_SYSTEM		; LOGICAL NAME TABLE NUMBER
	.WORD	1			; UIC MEMBER NUMBER
	.WORD	1			; UIC GROUP NUMBER
	.LONG	0			; MAILBOX UCB (NOT USED)
	.ASCIC	/SYS$SYSDEVICE/		; LOGICAL NAME STRING
	.BYTE	1			; EXTRA COUNT FOR EQUIVALENCE NAME
	.ASCII	/__/			; ASSUME CONCEALED DEVIC NAME
	.ASCII	/DDCU:::/		; ROOM FOR DDCU[uu]:
	.BLKB	<<<.-SYSDISKLOG>+15>&^C<15>>-<.-SYSDISKLOG>
SYSDISKEND:
;
; DEFAULT INTERRUPT VECTORS FOR UNIBUS SYSTEM DEVICES:
;
BOOTVECTOR:
	.WORD	^X88			; RK06/7 INTERRUPT VECTOR
	.WORD	^X70			; RL02 INTERRUPT VECTOR
;
; MEMORY MANAGEMENT DATA		;
;
PGDCOD:
;	.LONG	<MMG$AL_PGDCOD-<1@31>>@-9 ; 1ST VPN OF PAGED CODE
	.LONG	0			; CELL IS LOADED BY INIT
	.LONG	<MMG$AL_PGDCODEN-<1@31>>@-9 ; LAST + 1 VPN OF PAGED CODE
	.LONG	<PTE$C_UR ! PTE$C_KOWN ! PTE$M_TYP1 ! PTE$M_TYP0>
					; SECTION 0 PAGE TABLE ENTRY
	PGDCODBEG=PGDCOD		; BEGINNING OF PAGED CODE
	PGDCODEND=PGDCOD+4		; LAST + 1 PAGE OF PAGED CODE
					; SECTION 0 PAGE TABLE ENTRY
PAGEDYN:
	.LONG	0			; 1ST VPN OF PAGED DYNAMIC POOL
					; STORED BY INIT CODE
	.LONG	0			; LAST + 1 VPN OF PAGED DYNAMIC POOL
					; STORED BY INIT CODE
	.LONG	<PTE$C_URKW ! PTE$C_KOWN> ; DEMAND ZERO PTE
;
; SYSTEM WINDOW CONTROL BLOCK TEMPLATE FOR MAPPING THE SYSTEM IMAGE
;
SYSWCB:
	ASSUME	WCB$C_LENGTH EQ WCB$C_MAP
10$:	.BLKB	WCB$C_LENGTH		; ALLOCATE THE FRONT OF A WINDOW
20$:
	.=10$+WCB$W_SIZE		; FILL IN THE SIZE FIELD
	.WORD	WCB$C_LENGTH		; NOT COUNTING RETRIEVAL POINTERS
	.=10$+WCB$B_TYPE		; TYPE FIELD
	.BYTE	DYN$C_WCB
	.=10$+WCB$B_ACCESS		; ACCESS FIELD
	.BYTE	WCB$M_READ ! -		; ACCESSED FOR READ
		WCB$M_NOTFCP ! -	; NOT AN FCP WINDOW
		WCB$M_CATHEDRAL ! -	; CATHEDRAL WINDOW
		WCB$M_COMPLETE		; MAPS THE ENTIRE FILE
	.=10$+WCB$L_STVBN		; STARTING VIRTUAL BLOCK NUMBER
	.LONG	1
	.=20$				; BACK TO END OF WCB
;
; MESSAGES
;
NOSPACE:				; INSUFFICIENT NON-PAGED POOL
	.ASCII	<CR><LF>/%EXECINIT-F-Insufficient non-paged pool/
	.ASCIZ	<CR><LF>		;
NOPHYSMEM:				;
	.ASCII	<CR><LF>/%EXECINIT-F-Insufficient physical memory for /
	.ASCIZ	/minimum working set/<CR><LF>
NOSPT:	.ASCIZ	<CR><LF>/%EXECINIT-F-Insufficient SPT entries/<CR><LF>
BADCONUCB:				;
	.ASCIZ	<CR><LF>/%EXECINIT-F-Illegal OPA0: UCB size/<CR><LF>
BADDSKUCB:				;
	.ASCIZ	<CR><LF>/%EXECINIT-F-Illegal SYSDISK UCB size/<CR><LF>
BADTTYDRV:				;
	.ASCIZ	<CR><LF>/%EXECINIT-F-Illegally formatted terminal service/<CR><LF>
BAD_ADDRESS:
	.ASCII	<CR><LF>/%EXECINIT-F-Address is not within the/
	.ASCIZ	/ nonpaged system image, SYS.EXE/<CR><LF>
BAD_OPCODE:
	.ASCII	<CR><LF>/%EXECINIT-F-Instruction mismatch between/
	.ASCIZ	/ old opcode table and instruction stream/<CR><LF>
	.PAGE
;+
; SYSTEM BOOT ENTRY POINTS TO START UP SYSTEM
;
; INPUTS:
;
;	R0 = PHYSICAL ADDRESS OF EXE$INIT
;	R11 = PHYSICAL ADDRESS OF RESTART PARAMETER BLOCK (RPB)
;	PR$_SBR/PR$_SLR - SET TO DESCRIBE SPT
;	PR$_P0BR/PR$_P0LR - SET TO MAP EXE$INIT VIRTUAL = REAL
;-
 
	.ALIGN	LONG
EXE$INIT::				; INIT START
	MOVL	RPB$L_BOOTR5(R11),FP	; GET DEBUG FLAGS
	MTPR	#1,S^#PR$_MAPEN		; ENABLE MAPPING
	JMP	@#10$			; AND SET PC IN SYSTEM SPACE
10$:	MOVL	EXE$GL_INTSTK,SP		; SET TO USE INTERRUPT STACK
	MOVL	EXE$GL_DEFFLAGS,EXE$GL_FLAGS	; ESTABLISH CORRECT DEFAULTS
	MOVL	EXE$GL_SCB,R1		; GET ADDRESS OF SCB
	MOVAL	@#EXE$TBIT,^X28(R1)	; CONNECT SYS.EXE TRACE,
	MOVAL	@#EXE$BREAK,^X2C(R1)	;  BREAKPOINT,
	MOVAL	@#EXE$ROPRAND,^X18(R1)	;  RESERVED OPERAND,
	MOVAL	@#EXE$ACVIOLAT,^X20(R1)	;  ACCESS VIOLATION,
	MOVAL	@#MMG$PAGEFAULT,^X24(R1) ;  AND PAGE FAULT HANDLERS TO SCB
	BBC	S^#EXE$V_SSINHIBIT, -
		G^EXE$GL_FLAGS,12$	; IF WE ARE INHIBITING SYSTEM
	MOVAL	G^EXE$CMODKRNLX,^X40(R1);   SERVICES, REVECTOR THE ENTRY
	MOVAL	G^EXE$CMODEXECX,^X44(R1);   POINTS FOR THE CHMX
12$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R1,R2	; GET VPN OF SCB
	MOVL	@MMG$GL_SPTBASE[R2],R2	; GET PTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R2	; EXTRACT PFN
	ASHL	#9,R2,R2		; AND CONVERT TO BYTE ADDRESS
	MTPR	R2,S^#PR$_SCBB		; SET SYSTEM CONTROL BLOCK BASE
	BBS	#RPB$V_DEBUG,FP,20$	; KEEP DEBUGGER IF REQUESTED
15$:	NOP				; SOURCE OF NOP OPCODE
	MOVB	15$,INI$BRK		; PREVENT INITIAL BREAKPOINT
	MOVL	#<<XDELTABASE-^X80000000>@-9>,-	;
		W^FREE			; SET FREE DESCRIPTOR TO RELEASE DEBUGGER
	BRB	30$			; CONTINUE WITHOUT DEBUGGER
20$:	MOVAB	@#XDELBPT,^X2C(R1)	; SET VECTOR TO BPT
	MOVAB	@#XDELTBIT,^X28(R1)	; SET TBIT VECTOR
; FOR LARGER THAN 32 MBYTES, USE LONGWORD FORMAT ...
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=23$
		MOVAL	G^XDS$GT_LONG_PFN,G^XDS$GL_XESTRING ; SAVED XE STRING
		MOVAL	G^XDS$GT_LONG_PFN,G^XDS$GL_XFSTRING ; SAVED XF STRING
; OTHERWISE, USE WORD FORMAT
	PFN_DISP_ELSE		ELSE_CODE=23$,COMMON_CODE=26$
		MOVAL	G^XDS$GT_WORD_PFN,G^XDS$GL_XESTRING ; SAVED XE STRING
		MOVAL	G^XDS$GT_WORD_PFN,G^XDS$GL_XFSTRING ; SAVED XF STRING
	PFN_DISP_ENDIF		COMMON_CODE=26$
30$:	CLRL	R11			; INIDICATE CONSOLE TERMINAL
	MOVAL	SYS$GT_ANNOUNCE,R1	; GET ADDRESS OF ANNOUNCEMENT MESSAGE
	JSB	EXE$OUTZSTRING		; ANNOUNCE SYSTEM
;
; LOAD ARRAYS WITH VPN OF BOUNDARY BETWEEN NONPAGED AND PAGEABLE EXEC
;
	EXTZV	#VA$V_VPN,#VA$S_VPN,G^MMG$GL_PGDCOD,R0	; MAKE ADDRESS INTO VPN
	MOVL	R0,PGDCOD		; STORE IN PGDCOD ARRAY
	ASHL	#2,R0,R0		; MAKE R0 INTO BYTE INDEX INTO SPT
	MOVL	R0,PGDCOD_LIM		; LOAD THIS VALUE INTO ARRAY USED
					;  BY INI$RDONLY/INI$WRITABLE
	DECL	R0			; (UPPER LIMIT IS ONE SMALLER
	MOVL	R0,INI_RDONLY_LIST+4	;  THAN LOWER LIMIT)
;
; SET UP NONPAGED POOL LISTHEAD AND INITIAL CONTENTS
;
	MOVL	MMG$GL_NPAGEDYN,R0	; GET ADDRESS OF NON-PAGED POOL
	CLRL	(R0)			; ZAP FORWARD LINK
	MOVL	W^BOO$GL_NPAGEDYN,4(R0)	; SET SIZE OF FREE BLOCK
	MOVL	R0,EXE$GL_NONPAGED+4	; SET ADDRESS OF POOL
 
	MOVAL	@MMG$GL_SYSPHD,R5	; GET ADDRESS OF SYSTEM HEADER
	MOVB	SGN$GB_SYSPFC,PHD$B_DFPFC(R5)	; SET SYS PAGE FAULT CLUSTER
	MOVAL	EXE$GL_FLAGS,R0		; PUT FLAGS ADDRESS IN CONVENIENT PLACE
	BBC	#RPB$V_INIBPT,FP,NODEBUG ; BR IF NORMAL STARTUP(NO BREAKPOINT)
;
;	R0 = ADDRESS OF EXE$GL_FLAGS 
;	R5 = ADDRESS OF SYSTEM PROCESS HEADER.
;
	JSB	INI$BRK			; OTHERWISE BREAKPOINT
NODEBUG:				;
	MOVW	SGN$GW_MAXPRCCT,SCH$GW_PROCLIM	; SET TENATIVE LIMIT FOR PROCS
;
; SET MODIFIED PAGE WRITER PARAMETERS
;
	MOVZWL	MPW$GW_HILIM,SCH$GL_MFYLIMSV ; LIST HIGH THRESHOLD
	MOVZWL	MPW$GW_HILIM,SCH$GL_MFYLIM ; CURRENT AND SAVE VALUES
	MOVZWL	MPW$GW_LOLIM,SCH$GL_MFYLOSV ; SAVE VALUE FOR LOW THRESHOLD
	MOVZWL	MPW$GW_LOLIM,SCH$GL_MFYLOLIM ; LOW LIST THRESHOLD
	JSB	INI$WRITABLE		; SYSTEM WRITABLE UNTIL INIT COMPLETES
 
	.PAGE
	.SUBTITLE	Alter PFN references if large PFN configuration
;+
;  If there is less than 32 Mbytes of memory described in the PFN data base
;  (MMG$GW_BIGPFN contains zero), this next block of code does nothing. 
;  Otherwise, an address table is scanned.
;
;	1.  Each address must be in the nonpaged system image.
;
;	2.  The current contents are verified as a consistency check.
;
;	3.  A new (longword context) opcode is stored at that location.
;
;  Failure of either test prevents the system from being bootstrapped with
;  more than 32 Mbytes of physical memory. (That is, the PHYSICALPAGES
;  parameter must be used to allow the system to come up using less that
;  its total amount of physical memory.)
;-

	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=100$

	MOVAL	MMG$AL_FIXUPTBL,R1	; Address of opcode/address table
	MOVAL	MMG$AL_ENDDRIVE,R2	; SYS.EXE bounds check lower limit
	MOVL	MMG$GL_PGDCOD,R3	; SYS.EXE bounds check upper limit
10$:	MOVL	(R1)+,R0		; Get address of next fixup 
					;  (R1 now points to old opcode byte)
	BEQL	50$			; Zero indicates end of list
	CMPL	R0,R2			; Is address too small?
	BLSSU	20$			; Quit with error if too small
	CMPL	R0,R3			; Is address too large?
	BGEQU	20$			; Error exit in this case, too
	CMPB	(R1)+,(R0)		; Perform sanity check 
					;  (R1 now points to new opcode byte)
	BNEQU	30$			; Quit with error if different
	MOVB	(R1)+,(R0)		; Finally, alter the opcode 
					;  (R1 points to next address in table)
	BRB	10$			;  and go back for the next one

20$:	MOVAB	BAD_ADDRESS,R1		; Select address-out-of-range message
	BRB	40$			;  and join common termination code

30$:	MOVAB	BAD_OPCODE,R1		; Select opcode-mismatch message
40$:	CLRL	R11			; Specify console terminal
	JSB	EXE$OUTZSTRING		; Type out error message
	HALT				;  and finally halt the processor
;
;  This is the successful exit path after all opcodes have been altered. It
;  is necessary to execute an REI instruction in order that any instruction
;  lookahead be invalidated and the new opcodes used.
;
50$:	MOVPSL	-(SP)			; Store PSL for REI
	PUSHAB	B^100$			; Push PC also
	REI				; Drop through to next instruction 

	PFN_DISP_ENDIF		COMMON_CODE=100$
	.PAGE
	.SUBTITLE	Initialize pageable system code
INI_PAGING:
	MOVL	W^BOO$GL_BOOTCB,R6	; ADDRESS OF BOOT CONTROL BLOCK
	MOVL	R6,EXE$GL_BOOTCB	; SET ADDRESS IN SYSCOMMON
	BBC	S^#EXE$V_SYSPAGING,EXE$GL_FLAGS,20$ ; BR IF NOT PAGING SYSTEM SPACE
	CLRQ	PGDCOD_LIM		; PREVENT PROTECTION SETTING
	MOVAL	@MMG$GL_SYSPHD,R5	; ADDRESS OF SYSTEM HEADER
	CVTWL	PHD$W_PSTLAST(R5),R2	; INDEX TO LAST SECTION TABLE ENTRY
	SUBL	#SEC$C_LENGTH@-2,R2	; ALLOCATED NEW SECTION TABLE ENTRY
	MOVW	R2,PHD$W_PSTLAST(R5)	; UPDATE LAST ALLOCATED ENTRY
	MOVW	R2,PGDCOD+8		; SET PAGED CODE SECTION INDEX
	ADDL	PHD$L_PSTBASOFF(R5),R5	; BASE ADDRESS OF SECTION TABLE
	MOVAL	(R5)[R2],R2		; ADDRESS OF FIRST SECTION TABLE ENTRY
	MOVL	BOO$L_SYS_VBN(R6),SEC$L_VBN(R2) ; MAP THE ENTIRE SYSTEM IMAGE
	CLRL	SEC$L_VPXPFC(R2)	; STARTS AT SYS VIRTUAL PAGE 0
	MOVL	BOO$L_SYS_MAP(R6),SEC$L_WINDOW(R2) ; SYSTEM WINDOW
	MOVL	#1,SEC$L_REFCNT(R2)	; MAKE REFERENCE COUNT NON-ZERO
	MOVAL	W^PGDCOD,R5		; SET SPT FOR PAGED CODE
	BSBW	FILLSPT			; AND RELEASE THE PAGES OCCUPIED
20$:					;
;
;	PLACE ALL PAGES CURRENTLY REMAINING IN PFNMAP ON THE FREE LIST
;
INI_FREEMEM:				;
	MOVL	EXE$GL_RPB,R6		; GET ADDRESS OF RPB	
	MOVL	#<<EXE$RESTART-^X80000000>@-9>,R0 ; VPN OF RESTART ROUTINE
	MOVL	@MMG$GL_SPTBASE[R0],R0	; GET PTE FOR RESTART ROUTINE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0	; EXTRACT PFN
	ASHL	#9,R0,RPB$L_RESTART(R6)	; SAVE PHYSICAL ADDRESS OF RESTART ROUTINE
	CLRL	RPB$L_CHKSUM(R6)	; INIT CHECKSUM ACCUMULATOR
	CLRL	RPB$L_RSTRTFLG(R6)	; ENABLE RESTART
	MOVAB	EXE$RESTART,R0		; ADDRESS OF RESTART ROUTINE
	MOVL	#^X1F,R1		; COUNT OF LONGWORDS IN CHECKSUM
5$:	ADDL	(R0)+,RPB$L_CHKSUM(R6)	; ACCUMULATE CHECKSUM OF RESTART ROUTINE
	SOBGTR	R1,5$			; FOR ALL 31 LONGWORDS
	MFPR	#PR$_SBR,RPB$L_SBR(R6)	; SAVE SBR VALUE FOR RESTART
	MFPR	#PR$_SLR,RPB$L_SLR(R6)	; SAVE SLR VALUE FOR RESTART
	MFPR	#PR$_SCBB,RPB$L_SCBB(R6); AND SCB BASE ADDRESS
	CLRL	RPB$L_ISP(R6)		; CLEAR "SUCCESSFUL POWERFAIL" FLAG
	ROTL	#<32-9>,RPB$Q_PFNMAP+4(R6),R4 ; STARTING PFN OF BITMAP
	MOVL	MMG$GL_MAXPFN,R0	; START WITH HIGHEST PFN INCLUSIVE
	ASHL	#-12,R0,R1		; GET BITMAP PAGE NUMBER
	ADDL	R1,R4			; FIRST BITMAP PAGE TO MAP
	MOVL	SWP$GL_BALBASE,R7	; VA TO REFERENCE BITMAP PAGES
10$:	BISL3	#<PTE$C_URKW!PTE$M_VALID>,R4,-
	@SWP$GL_BALSPT			; MAP A PAGE OF THE PFN BITMAP
	INVALID	R7			; AND INVALIDATE THAT VA
	EXTZV	#0,#12,R0,R5		; BITMAP PAGE RELATIVE PFN
20$:	BBC	R5,(R7),30$		; BRANCH IF THIS PFN IS NOT USABLE
	JSB	MMG$DALLOCPFN		; MAKE USABLE PFN AVAILABLE
30$:	DECL	R0			; NEXT PFN TO CHECK
	BEQL	50$			; PFN ZERO MAY NOT BE USED
	CMPL	R0,MMG$GL_MINPFN	; DONE THEM ALL?
	BLSS	50$			; BRANCH IF YES
	SOBGEQ	R5,20$			; DO THE NEXT PAGE IN THIS BITMAP PAGE
	SOBGEQ	R4,10$			; DO THE NEXT BITMAP PAGE
					; THIS DOES NOT FALL THROUGH
50$:	CLRL	@SWP$GL_BALSPT		; CLEAN UP THE MAP ENTRY
	INVALID	R7			; AND THE TRANSLATION BUFFER
 
;
; INITIALIZE SPT FOR PAGED DYNAMIC POOL
;
INI_PAGDYN:				;
	EXTZV	#VA$V_VPN,#VA$S_VPN,MMG$GL_PAGEDYN,R4 ; VPN OF PAGED POOL
	ASHL	#-9,SGN$GL_PAGEDYN,R0	; OTHERWISE INIT IT AS NON-PAGED
	ADDL3	R0,R4,R5		; IF NOT PAGING POOL
	MOVL	MMG$GL_PAGEDYN,EXE$GL_PAGED	; SET ADDRESS OF PAGED POOL
	BBS	S^#EXE$V_POOLPGING,EXE$GL_FLAGS,30$ ; BRANCH IF PAGING PAGED POOL
10$:	MOVL	@MMG$GL_SPTBASE[R4],R0	; SPT ENTRY
	JSB	MMG$ALLOCPFN		; OTHEWISE GET A PFN
	BBC	#31,R0,20$		; BRANCH IF GOT ONE
	HALT				; NO PAGES FOR POOL, DISASTER!!
20$:	BICL	#^C<PTE$M_PFN>,R0	; LEAVE ONLY PFN BITS
	BISL3	#<PTE$M_VALID ! PTE$C_URKW ! PTE$C_KOWN>,-
		R0,@MMG$GL_SPTBASE[R4]	; SET NEW PAGE TABLE ENTRY
	BSBW	SETRESIDENT		; SET THE PFN RESIDENT
	AOBLSS	R5,R4,10$		; FOR EACH PAGE IN THE POOL
	BRB	40$			; 
 
;
; SET UP ADDRESS OF PAGED POOL AND INIT IT FOR PAGING IF ENABLED
;
30$:	MOVAL	W^PAGEDYN,R5		; ADDRESS OF PAGED POOL DESCRIPTORS
	MOVL	R4,(R5)			; 1ST VPN OF PAGED POOL
	ASHL	#-9,SGN$GL_PAGEDYN,-(SP); GET SIZE OF PAGED POOL IN PAGES
	ADDL3	(SP)+,R4,4(R5) 		; LAST + 1 OF PAGED POOL
	BSBW	FILLSPT			; SET SPT FOR PAGED POOL
40$:					;
;
; INITIALIZE LOOKASIDE I/O PACKET POOL
;
INI_IRP:				;
	MOVQ	W^BOO$GL_SPLITADR,R0	; R0 = BASE ADDRESS OF IRP LIST
					; R1 = NO. OF IRP'S TO INITIALIZE
	MOVL	R0,EXE$GL_SPLITADR	; SET LOOKASIDE LIST SPLIT ADDRESS
	MOVL	R1,IOC$GL_IRPCNT	; SET CURRENT COUNT OF IRPS
	BEQL	INI_LRP			; SKIP IF NONE
	BRB	140$			; 0 OR MORE TRIPS THROUGH THE LOOP
130$:	INSQUE	(R0),@IOC$GL_IRPBL	; INSERT I/O PACKET IN LOOKASIDE LIST
	MOVW	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,IRP$W_SIZE(R0) ; SET SIZE
	ADDL	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,R0 ; ADVANCE TO NEXT I/O PACKET
140$:	SOBGEQ	R1,130$			;
	EXTZV	#0,#9,R0,R2		; GET OFFSET IN PAGE
	BEQL	INI_LRP			; IF ZERO, NO PARTIAL PACKET
	SUBL3	R2,#512,(R0)		; SAVE SIZE OF PARTIAL PACKET IN
					;  FIRST LONGWORD OF FRAGMENT
	MOVL	R0,IOC$GL_IRPREM	; SAVE ADDRESS OF PARTIAL PACKET
;
; INITIALIZE LARGE REQUEST PACKET LOOK ASIDE LIST
;
INI_LRP:
	MOVL	W^BOO$GL_LRPSIZE,R2	; LRP SIZE FROM SYSBOOT
	MOVL	R2,IOC$GL_LRPSIZE	; STORE LRP SIZE
	MOVL	W^BOO$GL_LRPMIN,IOC$GL_LRPMIN ; STORE LRP SIZE - 20%
	CMPL	#<512-32>,IOC$GL_LRPMIN ;
	BGEQ	10$			; BR IF LRPMIN < 480
	MOVL	#<512-32>,IOC$GL_LRPMIN	; FORCE LRPMIN TO 480
10$:	MOVQ	W^BOO$GL_LRPSPLIT,R0	; R0 = LRP LOOKASIDE LIST SPLIT ADR
					; R1 = NO. OF LRP'S TO INITIALIZE
	MOVL	R0,IOC$GL_LRPSPLIT	; SET LOOKASIDE LIST SPLIT ADDRESS
	MOVL	R1,IOC$GL_LRPCNT	; SAVE CURRENT LRP COUNT
	BEQL	50$			; SKIP IF NONE
	BRB	40$			; 0 OR MORE TRIPS THROUGH LOOP
30$:	INSQUE	(R0),@IOC$GL_LRPBL	; INSERT I/O PACKET IN LOOKASIDE LIST
	MOVW	R2,IRP$W_SIZE(R0)	; SET SIZE
	ADDL	R2,R0			; ADVANCE TO NEXT I/O PACKET
40$:	SOBGEQ	R1,30$			;
	EXTZV	#0,#9,R0,R1		; GET OFFSET IN PAGE
	BEQL	50$			; IF ZERO, NO PARTIAL PACKET
	SUBL3	R1,#512,(R0)		; SAVE SIZE OF PARTIAL PACKET IN
					;  FIRST LONGWORD.
	MOVL	R0,IOC$GL_LRPREM	; SAVE ADDRESS OF PARTIAL PACKET
50$:					;
;
; INITIALIZE SMALL REQUEST PACKET LOOK ASIDE LIST
;
INI_SRP:
	MOVL	SGN$GL_SRPSIZE,R2	; SRP SIZE FROM SYSBOOT
	MOVL	R2,IOC$GL_SRPSIZE	; STORE SRP SIZE
	ASHL	#-1,R2,IOC$GL_SRPMIN ; STORE SRP SIZE / 2
10$:	MOVL	W^BOO$GL_SRPSPLIT,R0	; R0 = SRP LOOKASIDE LIST SPLIT ADR
	MOVL	SGN$GL_SRPCNT,R1	; R1 = NO. OF SRP'S TO INITIALIZE
	MOVL	R0,IOC$GL_SRPSPLIT	; SET LOOKASIDE LIST SPLIT ADDRESS
	MOVL	R1,IOC$GL_SRPCNT	; SAVE CURRENT SRP COUNT
	BEQL	50$			; SKIP IF NONE
	BRB	40$			; 0 OR MORE TRIPS THROUGH LOOP
30$:	INSQUE	(R0),@IOC$GL_SRPBL	; INSERT I/O PACKET IN LOOKASIDE LIST
	MOVW	R2,IRP$W_SIZE(R0)	; SET SIZE
	ADDL	R2,R0			; ADVANCE TO NEXT I/O PACKET
40$:	SOBGEQ	R1,30$			;
	EXTZV	#0,#9,R0,R1		; GET OFFSET IN PAGE
	BEQL	50$			; IF ZERO, NO PARTIAL PACKET
	SUBL3	R1,#512,(R0)		; SAVE SIZE OF PARTIAL PACKET IN
					;  FIRST LONGWORD.
	MOVL	R0,IOC$GL_SRPREM	; SAVE ADDRESS OF PARTIAL PACKET
50$:					;
	
	MOVZWL	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,IOC$GL_IRPMIN ; SET MIN SIZE
	MOVL	EXE$GL_NONPAGED,R11	; Save IPL for pool allocation.
	MFPR	S^#PR$_IPL,-		; Set it to 31 for allocations
		EXE$GL_NONPAGED		; during INIT execution.
;
; SET UP FILEREAD GLOBAL PARAMETERS PASSED FROM SYSBOOT
;
	MOVQ	W^BOO$GQ_FILCACHE,FIL$GQ_CACHE ; SET UP CACHE
	MOVC3	#10,W^BOO$GT_TOPSYS,FIL$GT_TOPSYS ; SET TOP LEVEL SYSTEM DIR
;
; NO ALLOCATION OF NON-PAGED POOL BEFORE THIS POINT !!!!
;
	.PAGE
	.SBTTL	Connect up loadable CPU-dependent code (SYSLOAxxx.EXE)
;
; The loadable CPU-dependent image (SYSLOAxxx.EXE) is now allocated 
; non-paged pool space and read into it by SYSBOOT.  The address of this
; code is passed in BOO$GL_SYSLOA.  Link the resident system vectors at
; EXE$AL_LOAVEC.  The loadable file now has self-describing vector and
; offset information within it.
;
; The SYSLOAxxx.EXE image starts with a longword containing the load image
; size, a longword of zero, a longword of standard pool header, followed
; by a list of self describing entries.  Each entry consists of a type byte
; and a longword self-relative offset to the loaded subroutine.
;
INI_LOADCODE:
	MOVL	W^BOO$GL_SYSLOA,R2	; Address of SYSLOAxxx image in pool
	MOVL	R2,XDEL_LOADBASE	; Save base of loadable code in
					;   XDELTA X3 register
	MOVAL	EXE$AL_LOAVEC,R3	; Address of resident vectors.
	BSBW	LINK_VEC		; Connect vectors to loaded routines.
END_SYSLOA:
	.PAGE
	.SBTTL	Connect up loadable SCS code (SCSLOA.EXE)
;
; The loadable SCS code image (SCSLOA.EXE) is now allocated non-paged 
; pool space and read into it by SYSBOOT.  The address of this code
; is passed in BOO$GL_SCSLOA.  Link the resident system vectors at
; SCS$AL_LOAVEC.  The loadable file has self-describing vector and
; offset information within it.
;
SCS_LOADCODE:
	MOVL	W^BOO$GL_UCODE,-	; Transfer the address of any
		G^SCS$GL_MCADR		;  loaded microcode
	MOVL	W^BOO$GL_SCSLOA,R2	; Address of SCSLOA image in pool
	BEQL	END_SCSLOA		; Not loaded
	MOVAL	G^SCS$AL_LOAVEC,R3	; Address of resident vectors.
	MOVL	R2,R4			; Save
	BSBW	LINK_VEC		; Connect vectors to loaded routines.
	MOVL	4(R4),R0		; Possible initialization routine
	BEQL	END_SCSLOA		; None, leave
	JSB	(R0)[R4]		; Call it
	BLBS	R0,END_SCSLOA		; No errors
	BSBW	NOPOOLERR		; Trouble! Not enough memory
	HALT				; **** FATAL ERROR ****

END_SCSLOA:
	.PAGE
	.SBTTL	Connect up loadable initialization code (INILOA.EXE)
;
; The loadable initialization code (INILOA.EXE) is now allocated non-paged
; pool space and read into it by SYSBOOT.  The address of this code
; is passed in BOO$GQ_INILOA and its size in BOO$GQ_INILOA+4.  Link the
; resident system vectors at INI$A_INILOAVEC to the entry points of the
; loaded routines.
;
LOAD_INILOA:
	MOVL	W^BOO$GQ_INILOA,R2	; Address in pool of INILOA image
;
; Link the vectors.
;
	BEQL	END_INILOA		; Branch if none.
	MOVAL	INI$A_INILOAVEC,R3	; Get address of resident vectors.
	PUSHAB	B^END_INILOA		; Done with INILOA linkage.
;
; Connect system vectors to loaded data routines and data structures.
; Subroutine LINK_VEC calculates the address of the next loaded routine
; and fills it into the next resident vector.
;
; Type and action are as follows:
;	Type <= 0	Leave
;	Type =  1	Data pointer - adjust offset
;	Type =  2	Aligned JMP - skip JMP, adjust offset, skip align
;	Type =  3	Unaligned JMP - skip JMP, adjust offset
;
; INPUTS:
;	R2/ pointer into list of self-relative offsets into loaded code
;	R3/ address at which calculated address of loaded routines/data
;	    structures should be written
;
LINK_VEC:
	ADDL	#DYN$C_HEADLEN,R2	; Step past the header
10$:	CVTBL	(R2)+,R0		; Pick up the type byte
	BLEQ	40$			; Leave if <= 0
	DECL	R0			; Check type
	BEQL	30$			; For TYPE 1, no skip, no alignment
	DECL	R0			; Check type
	BGTR	20$			; For TYPE 3, no alignment
	ADDL	#3,R3			; Round up to
	BICL	#3,R3			;  next longword boundary
20$:	TSTW	(R3)+			; Skip the JMP @#
30$:	ADDL3	R2,(R2)+,(R3)+		; Add offset and stuff
	BRB	10$			; Try for more

40$:	RSB

END_INILOA:
	.PAGE
	.SBTTL	Map Adapters
;
; Locate, initialize, and map all adapters on the system.
; Note: this routine can not be executed until after SYSLOAxxx has been loaded.
;
	INVALID				; Clear temporary boot device mapping
					; from translation buffer.
	JSB	INI$IOMAP		; Map and initialize adapters.
;
; Deallocate the pool INILOA was loaded into.
;
	MOVQ	W^BOO$GQ_INILOA,R0	; R0 = Address, R1 = size in bytes
	MOVL	EXE$GL_NONPAGED+4,R3	; Address of free non-paged pool.
	JSB	EXE$DEALLOCATE		; Deallocate INILOA's pool.
	.PAGE
	.SBTTL	Initialize real time SPT bit map
;
; Allocate and initialize a bit map that describes the SPTs reserved
; via a SYSBOOT parameter for use by real time processes that issue
; connect to interrupt requests.
;
INI_SPT:
;
; See if the number of real time SPTs requested by the system
; parameter is available in the SPT free list.
;
	MOVL	G^EXE$GL_RTIMESPT,R5	; Get number requested.
	BNEQ	5$			; If any, branch and proceed.
	BRW	END_INISPT		; in system initialization.

5$:	ADDL3	G^BOO$GL_SPTFREL,R5,R6	; Add to base of free SPTs.
	CMPL	R6,G^BOO$GL_SPTFREH	; Are there enough left?
	BLEQ	10$			; Yes. Branch forward.
	MOVAB	NOSPT,R1		; No. Report error.
	CLRL	R11			; Specify console terminal
	JSB	EXE$OUTZSTRING		; Output error report.
	HALT				; And halt processor.
;
; Calculate size of bit map control block needed and allocate it.
;
10$:	ASHL	#-5,R5,R1		; Calculate number of longwords
					; needed for bit map.
	BITL	#^X1F,R5		; Need to round up?
	BEQL	20$			; No. Branch forward.
	INCL	R1			; Yes. Add one more longword.
20$:	ASHL	#2,R1,R1		; Convert to byte count.
	ADDL	#RBM$K_LENGTH,R1	; R1 = realtime bitmap block size.
	BSBW	ALONONPAGED		; Allocate from nonpaged pool.
					; ALONONPAGED halts on error.
	MOVL	R2,G^EXE$GL_RTBITMAP	; Save block address.
	MOVL	R2,R7			; Get another copy of block address.
;
; Translate starting offset of starting SPT to the system virtual
; address of the page table entry. Then initialize the control block.
;
	ASSUME	RBM$L_STARTVPN EQ 0
	MOVL	G^BOO$GL_SPTFREL,(R7)+	; Store starting virtual page
					; number in control block.
	MOVL	R6,G^BOO$GL_SPTFREL	; Save new first free SPT.
	ASSUME	RBM$L_FREECOUNT EQ RBM$L_STARTVPN+4
	MOVL	R5,(R7)+		; Store number of SPTs.
	ASSUME	RBM$W_SIZE EQ RBM$L_FREECOUNT+4
	MOVW	R1,(R7)+		; Set block size.
	ASSUME	RBM$B_TYPE EQ RBM$W_SIZE+2
	MOVW	#DYN$C_RBM,(R7)+	; Store block type.
	ASSUME	RBM$L_BITMAP EQ RBM$B_TYPE+2
;
; In the bit map section of the control block, set each bit that
; corresponds to a reserved SPT.
;
	CLRL	R6			; Starting bit number is zero.
30$:	CMPL	#32,R5			; More than a longword of bits to set?
	BGEQ	40$			; No. Do last longword.
	INSV	#-1,R6,#32,-		; Set a longword worth of bits.
		RBM$L_BITMAP(R2)
	ADDL	#32,R6			; Move to next longword.
	SUBL	#32,R5			; Decrement count by bits set.
	BRB	30$			; Go alter more bits.

40$:	INSV	#-1,R6,R5,-		; Set remaining bits.
		RBM$L_BITMAP(R2)
END_INISPT:
	.PAGE
	.SBTTL	Initialize Lock Manager Data Structures
;
; ALLOCATE AND INITIALIZE THE LOCK ID TABLE, THE RESOURCE HASH TABLE AND
; THE PROCESS BITMAP.  THE LOCK ID TABLE IS INITIALIZED WITH EACH LONGWORD 
; CONTAINING THE INDEX OF THE NEXT LONGWORD.  THE RESOURCE HASH TABLE 
; IS INITIALIZED TO ZERO.  THE PROCESS BITMAP DOES NOT HAVE TO BE
; INITIALIZED.
;
INI_LCKIDTBL:
	MULL3	#4,LCK$GL_IDTBLSIZ,R1	; MULTIPLY NUMBER OF ENTRIES BY 4
	ADDL	#12,R1			; AND ALLOCATE THAT SIZE + 12
	BSBW	ALONONPAGED		; BYTES OF PREFIX
	MOVW	R1,8(R2)		; STORE SIZE ALLOCATED
	MOVB	#DYN$C_LKID,10(R2)	; STORE STRUCTURE TYPE
	MOVAB	12(R2),LCK$GL_IDTBL	; STORE ADDRESS OF START OF TABLE
	ADDL	#16,R2			; POINT TO SECOND ENTRY IN TABLE
	SUBL	#16,R1			; COMPUTE NUMBER OF ENTRIES
	DIVL	#4,R1			; LESS ONE
	MOVL	R1,LCK$GL_MAXID		; STORE MAX LOCK ID
	MOVL	#1,LCK$GL_NXTID		; INITIALIZE NEXT ID TO 1
	MOVL	#2,R3			; SETUP TO INITIALIZE REST OF TABLE
10$:	MOVL	R3,(R2)+		; STORE INDEX OF NEXT ENTRY IN THIS ENTRY
	AOBLEQ	R1,R3,10$		; REPEAT FOR ALL ENTRIES EXCEPT THE LAST
					; NOTE THAT THE FIRST AND LAST ENTRIES
					; CONTAIN ZERO.
;
; ALLOCATE RESOURCE HASH TABLE.  THE NUMBER OF ENTRIES IN THE HASH TABLE
; MUST BE A POWER OF TWO.  SO THE ALLOCATED SIZE IS THE SMALLEST POWER OF
; TWO LARGER THAN THE SYSGEN PARAMETER.
;
INI_RESHTBL:
	MOVL	#1,R1			; SMALLEST POSSIBLE HASH TABLE IS 1 ENTRY
	CLRL	R4			; R4 WILL BE POWER OF TWO ENTRIES
10$:	CMPL	R1,LCK$GL_HTBLSIZ	; IS R1 >= SPECIFIED SIZE?
	BGEQU	20$			; YES
	MULL	#2,R1			; NO - MULTIPLY SIZE BY TWO
	INCL	R4			; INCREMENT POWER OF TWO
	BRB	10$			; REPEAT

20$:	MULL	#4,R1			; MULTIPLY # OF ENTRIES BY 4
	ADDL	#12,R1			; ADD IN OVERHEAD
	BSBW	ALONONPAGED		; ALLOCATE MEMORY
	MOVW	R1,8(R2)		; STORE SIZE OF STRUCTURE
	MOVB	#DYN$C_RSHT,10(R2)	; STORE STRUCTURE TYPE
	MOVAB	12(R2),LCK$GL_HASHTBL	; STORE POINTER TO HASH TABLE
	MOVL	R4,LCK$GL_HTBLCNT	; STORE POWER OF TWO COUNT OF ENTRIES
					; NOTE: HASH TABLE INITIALIZED TO ZERO
;
; ALLOCATE PROCESS BITMAP.  THIS BITMAP HAS ONE BIT FOR EVERY POSSIBLE
; PROCESS IN THE SYSTEM.  THIS BITMAP ONLY GETS ALLOCATED IF DEADLOCK DETECTION
; IS ENABLED.
;
INI_PRCBITMAP:
	TSTL	LCK$GL_WAITTIME		; IS DEADLOCK DETECTION ENABLED?
	BEQL	20$			; NO
	MOVZWL	SGN$GW_MAXPRCCT,R1	; YES, GET MAX. # OF PROCESSES IN SYSTEM
	DIVL	#8,R1			; COMPUTE # OF BYTES NEEDED
	ADDL	#13,R1			; ADD IN OVERHEAD PLUS EXTRA BYTE
					; TO HANDLE TRUNCATION ERROR
	BSBW	ALONONPAGED		; ALLOCATE MEMORY
	MOVW	R1,8(R2)		; STORE SIZE OF STRUCTURE
	MOVW	#<DYN$C_PRCMAP@8>+DYN$C_INIT,10(R2) ; STORE STRUCTURE TYPE
	SUBL3	#12,R1,4(R2)		; STORE SIZE OF BITMAP PORTION ONLY
	MOVAB	12(R2),LCK$GL_PRCMAP	; STORE POINTER TO BITMAP
20$:
	.PAGE
	.SBTTL	Initialize Process State
;
; INIT PROCESS STATE
;
 
INI_PSTATE:				;
	MOVZWL	SGN$GW_MAXPRCCT,R1	; GET TOTAL COUNT OF PROCESSES
	INCL	R1			; ADD ONE FOR SYSTEM HEADER
	MULL	#6,R1			; 2 BYTES FOR SEQ + 4 BYTES FOR PCB ADDR
	ADDL	#DYN$C_HEADLEN,R1	; ADD IN HEADER LENGTH
	BSBW	ALONONPAGED		; ALLOCATE SPACE FOR SEQUENCE VECTOR
					; AND PCB VECTOR
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_PCBVEC@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,SCH$GL_PCBVEC	; SAVE POINTER TO PCB VECTOR
	MOVZWL	SGN$GW_MAXPRCCT,R1	; GET COUNT OF PROCESSES
	MOVAL	4(R2)[R1],SCH$GL_SEQVEC	; SET BASE OF SEQUENCE VECTOR
	MOVAL	MMG$AL_SYSPCB,(R2)[R1]	; SET POINTER TO SYSTEM PCB
	MOVL	(R2)[R1],R0		; GET POINTER TO SYSTEM PCB
	MOVW	R1,PCB$L_PID(R0)	; SET PROPER PIX FOR SYSTEM PCB
	DECL	R1			; COMPUTE MAXIMUM PIX VALUE
	MOVL	R1,SCH$GL_MAXPIX	; AND SET
20$:	MOVAL	SCH$GL_NULLPCB,(R2)[R1]	; INIT VECTOR TO POINT TO NULL PROCESS
	CLRW	@SCH$GL_SEQVEC[R1]	; INITIALIZE SEQUENCE COUNTER
	SOBGEQ	R1,20$			; INIT THEM ALL
	MOVL	MMG$GL_GPTE,EXE$GL_GPT	; ESTABLISH POINTER TO GLOBAL FREE LIST
	CLRL	R2			; SET NULL PRIO INCR CLASS
	MOVAL	SCH$GL_NULLPCB,R4	; GET ADDRESS OF NULL PCB
	BSBB	30$			; SETUP PROCESS PHYPCB AND STATE
	MOVAL	SCH$GL_SWPPCB,R4	; GET ADDRESS OF SWAPPER PCB
	BSBB	30$			; SETUP PROCESS PHYPCB AND STATE
	BRB	INI_PHV			; CONTINUE WITH INITIALIZATION
30$:	EXTZV	#VA$V_VPN,#VA$S_VPN,PCB$L_PHYPCB(R4),R0	; GET VPN FOR HW PCB
	MOVL	@MMG$GL_SPTBASE[R0],R0	; TRANSLATE TO ACTUAL PHYSICAL
	INSV	R0,#VA$V_VPN,#PTE$S_PFN,PCB$L_PHYPCB(R4); SET PHYSICAL ADDRESS
	MOVZWL	PCB$L_PID(R4),R0	; GET PROCESS INDEX
	MOVL	R4,@SCH$GL_PCBVEC[R0]	; AND SET ADDRESS IN PCB VECTOR
	JMP	SCH$CHSE		; AND CHANGE STATE TO EXECUTABLE
 
;
;	INITIALIZE PROCESS HEADER VECTOR
;
INI_PHV:				;
	ADDL3	#1,SGN$GL_BALSETCT,R4	; GET COUNT OF SLOTS
	ASHL	#2,R4,R1		; SIZE OF BLOCK TO ALLOCATE
	ADDL	#DYN$C_HEADLEN,R1	; ADD IN SIZE OF HEADER
	BSBW	ALONONPAGED		; ALLOCATE BLOCK FOR PHV
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_PHVEC@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,PHV$GL_PIXBAS	; SET PROCESS INDEX VECTOR
	MOVAW	(R2)[R4],PHV$GL_REFCBAS	; AND REFERENCE COUNT BASE
	MOVW	SGN$GW_MAXPRCCT,-2(R2)[R4]; SET SYSTEM PIX
	DECL	R4			; 
	MOVW	#1024,@PHV$GL_REFCBAS[R4]	; SET SYSTEM REFERENCE COUNT 
20$:	DECL	R4			; 
	BLSS	30$			; CHECK FOR DONE
	MNEGW	#1,@PHV$GL_REFCBAS[R4]	; INIT REFC
	CLRW	(R2)[R4]		; AND PIX
	BRB	20$			; AND AGAIN
30$:					;
;
;	SETUP SWAPPER MAP
;
INI_SWAP:				;
	ASHL	#2,SGN$GL_MAXWSCNT,R1	; GET SIZE TO ALLOCATE
	ADDL	#4+DYN$C_HEADLEN,R1	; ADD SPACE FOR STOPPER LONGWORD + HEAD
	BSBW	ALONONPAGED		; ALLOCATE A BLOCK FOR SWAPPER MAP
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_SWPMAP@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,SWP$GL_MAP		; SET ADDRESS OF SWAPPER MAP
	MOVAL	SCH$GL_SWPPCB,R4	; GET ADDRESS OF SWAPPER PCB
	MOVL	PCB$L_PHD(R4),R5	; AND GET HEADER ADDRESS
	MOVL	R2,PHD$L_P0BR(R5)	; SET BASE REGISTER
	INSV	SGN$GL_MAXWSCNT,#0,#24,PHD$L_P0LRASTL(R5) ; AND LENGTH REGISTER
;
; ALLOCATE MODIFIED PAGE WRITER PAGE TABLE ENTRY ARRAY
; AND PROCESS HEADER VECTOR INDEX ARRAY.
;
INI_MPW:
	MOVZWL	MPW$GW_MPWPFC,R1	; MODIFIED PAGE WRITER PAGE FAULT CLUSTER
	BICL	#7,R1			; TRUNCATE TO MULTIPLE OF 8
	BNEQ	10$			; CANNOT ALLOW ZERO
	MOVL	#16,R1			; USE MINIMUM INSTEAD
10$:	MOVW	R1,MPW$GW_MPWPFC	; RESET PARAMETER
	movw	r1,swp$gw_swpinc	; ********** temp ********** 
	ADDL2	#7,R1			; ALLOW BIT-LEVEL PAGE FILE ALLOCATION
	ROTL	#2,R1,R4		; SIZE OF PTE ARRAY
	MOVAW	DYN$C_HEADLEN(R4)[R1],R1; 6 BYTES PER PAGE TO ALLOCATE + HEADER
	BSBW	ALONONPAGED		; ALLOCATE THE STORAGE
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_MPWMAP@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,MPW$AL_PTE		; ADR OF PAGE TABLE ENTRY ARRAY
	ADDL3	R2,R4,MPW$AW_PHVINDEX	; ADR OF PROCESS HEADER VECTOR INDEX ARRAY
	.PAGE
	.SUBTITLE	MISCELLANEOUS INITIALIZATION
;
; DO SHORT PIECES OF MISCELLANEOUS SYSTEM INITIALIZATION
;
INI_MISC:
;
; INITIALIZE THE GLOBAL PAGE FILE LIMIT
;
	MOVL	SGN$GL_GBLPAGFIL,MMG$GL_GBLPAGFIL
;
; INITIALIZE PAGEFILE CONTROL BLOCK 0 FOR READ OF SHELL INTO SYSTEM WORKING SET
;
	MOVL	#<<SWP$GL_SHELLBAS&^X7FFFFFFF>@-9>+1+1,- ;SET STARTING VBN
		MMG$GL_NULLPFL+PFL$L_VBN	; FOR SHELL PROCESS
	MOVL	W^BOO$GL_BOOTCB,R0		; GET BOOT CONTROL BLOCK ADDR
	MOVL	BOO$L_SYS_MAP(R0),-		; STORE ADDRESS OF SYSTEM WCB
		MMG$GL_NULLPFL+PFL$L_WINDOW	; FOR SHELL READS INTO SYSTEM
	ADDW3	#1,SGN$GW_SWPFILES,SGN$GW_SWPFILCT ; SET ACTUAL NUMBER OF SWAP
						; FILE SLOTS
	.PAGE
	.SUBTITLE	PAGE AND SWAP FILE VECTOR INITIALIZATION
;--
;
;  Functional Description:
;
;	The page file control block vector is initialized. This vector
;	contains a longword pointer for each page file or swap file recognized
;	by the system. Each vector element is initialized to point to a
;	dummy PFL allocated in SYS.EXE. As a new page file or swap file is
;	added to the system, a vector slot is loaded with its PFL address.
;
;  Input Parameters:
;
;	SGN$GW_PAGFILCT		Maximum number of paging files
;	SGN$GW_SWPFILCT		Maximum number of swapping files
;
;  Implicit Input:
;
;	none
;
;  Output Parameters:
;
;	None
;
;  Implicit Output:
;
;	An array of longwords is allocated from nonpaged pool to contain
;	the page file control block vector. 
;
;  Completion Status:
;
;	If allocation of the vector of longwords fails, the bootstrap
;	operation is aborted.
;
;--
 
INI_PFLVEC:
	MOVZWL	G^SGN$GW_PAGFILCT,R0	; Zero extend page file count
	MOVZWL	G^SGN$GW_SWPFILCT,R1	;  ... and swap file count
	ADDL3	R0,R1,R2		; Form their sum
	PUSHL	R2			;  ... and save this result
	MULL3	#4,R2,R1		; Make R1 a byte count
	ADDL2	#PTR$K_LENGTH,R1	; Add header overhead
	PUSHL	R1			; Save requested size
	BSBW	ALONONPAGED		; Allocate the pointer block
	MOVL	(SP)+,PTR$W_SIZE(R2)	; Size is the requested size
	MOVB	#DYN$C_PTR,PTR$B_TYPE(R2) ; Set structure type as PTR
	MOVB	#DYN$C_PFL,PTR$B_PTRTYPE(R2) ; ... which locates PFLs
	MOVL	(SP),PTR$L_PTRCNT(R2)	; Store size of PFL array
	MOVAL	G^MMG$GL_NULLPFL,R3	; Set up contents of uninitialized slot
	MOVAL	PTR$L_PTR0(R2),R1	; Get address of first slot
	MOVL	R1,G^MMG$GL_PAGSWPVC 	; Store this for exec routines
	POPL	R0			; R0 is loop counter
10$:	MOVL	R3,(R1)+		; Initialize next slot
	SOBGTR	R0,10$			; If not done, load next slot
	.PAGE
;
;	INITIALIZE POINTER TO TOP OF INTERRUPT STACK AND COMPUTE MAXIMUM
;	ALLOWED DEPTH FOR LOCK MANAGER RESOURCE NAMES
;
INI_INTSTKLM:
	MOVZWL	SGN$GW_ISPPGCT,R0	; GET # OF PAGES OF INTERRUPT STACK
	ASHL	#9,R0,R0		; CONVERT TO BYTES
	SUBL3	R0,EXE$GL_INTSTK,-	; SUBTRACT FROM BASE OF STACK AND STORE
		EXE$GL_INTSTKLM
	SUBL	LCK$GL_EXTRASTK,R0	; SUBTRACT EXTRA STACK AMOUNT FROM
					; SIZE OF INTERRUPT STACK
	DIVL	#16,R0			; ALLOW 16 BYTES FOR EACH LEVEL
	CMPL	R0,#4			; MAKE SURE IT'S AT LEAST 4
	BGEQ	10$			; IT IS
	MOVL	#4,R0			; SET IT TO 4
10$:	CMPL	R0,#255			; MAKE SURE IT'S NO MORE THAN 255
	BLEQ	20$			; IT IS
	MOVL	#255,R0			; SET IT TO 255
20$:	MOVB	R0,LCK$GB_MAXDEPTH	; STORE IT
;
; POINT SYSTEM PCB AT SYSTEM PHD AND SET PROPER PIX
;
INI_SYSPCB:				;
	MOVAL	MMG$AL_SYSPCB,R4	; GET ADDRESS OF SYSTEM PCB
	MOVL	MMG$GL_SYSPHD,PCB$L_PHD(R4)	; AND SET IN SYSTEM PCB
	MOVW	SGN$GW_MAXPRCCT,PCB$L_PID(R4)	; SET SYSTEM PIX
;
; SYSBOOT PRODUCED A MAP FOR SYS.EXE AND LEFT IT IN THE BOOT CONTROL
; BLOCK.  ITS RETRIEVAL POINTERS ARE IN THE NORMALIZED FORM OF 32 BITS
; OF BLOCK COUNT, 32 BITS OF LBN.  SYSBOOT LEFT ENOUGH SPACE AT THE END
; OF THE MAP TO MAKE A REAL WCB AND PUT IT RIGHT ON TOP OF THIS MAP.
;
	MOVL	W^BOO$GL_BOOTCB,R8	; ADDRESS OF BOOT CONTROL BLOCK
	MOVL	BOO$L_SYS_MAP(R8),R6	; ADDRESS OF MAP LEFT BY SYSBOOT
	ASHL	#-3,(R6),R7		; RETRIEVAL POINTER COUNT IN MAP
	MOVW	R7,W^SYSWCB+WCB$W_NMAP	; SET COUNT IN TEMPLATE WCB
	MOVAL	4(R6),R0		; ADR OF 1ST 8 BYTE RTRV PTR
	MOVL	R6,R1			; ADR TO STORE 1ST 6 BYTE RTRV PTR
	MOVL	R7,R2			; NUMBER OF RETRIEVAL POINTERS
;
; COLLAPSE THE 8 BYTE FORMAT INTO A 6 BYTE FORMAT.  SINCE SYS.EXE ITSELF
; IS NOT 65K BLOCKS BIG, NONE OF THESE RETRIEVAL POINTERS CAN HAVE A
; NON-ZERO HIGH ORDER WORD.
;
20$:	CVTLW	(R0)+,(R1)+		; MOVE THE BLOCK COUNT
	MOVL	(R0)+,(R1)+		; AND THE STARTING LBN
	SOBGTR	R2,20$			; LOOP THROUGH ALL RTRV PTRS
	MULL	#6,R7			; NUMBER OF BYTES IN NEW RTRV PTRS
	ADDW	R7,W^SYSWCB+WCB$W_SIZE	; FIX UP TEMPLATE WCB SIZE FIELD
	MOVC3	R7,(R6),WCB$C_LENGTH(R6) ; MOVE 6 BYTE RTRV PTRS DOWN
	MOVC3	#WCB$C_LENGTH,W^SYSWCB,(R6) ; AND INSERT THE TEMPLATE WCB
;
; Initialize EXE$GL_TENUSEC.  This cell is the number of times the following
; loop will be executed in ten u-seconds.  This is done once here to
; calibrate the loop instead of reading the processor clock.  The resulting
; number is used in the system macro TIMEWAIT.
;
	MTPR	#0,#PR$_NICR		; Clear next interval count register
	MOVL	#20000,R0		; Number of times to execute test loop
	MTPR	#^X11,#PR$_ICCS		; Start clock, no interrupts
; **** Start of loop to time
35$:	BITW	#^X8000,40$		; Random BITx instruction to time
	BNEQ	40$			; Random conditional branch instruction
40$:	SOBGTR	R0,35$			; Loop
; **** End of loop to time
	MFPR	#PR$_ICR,R0		; Read count register to see how far we got
	MTPR	#0,#PR$_ICCS		; Shut clock off
	DIVL3	R0,#200000,EXE$GL_TENUSEC ; Calculate number of times to
	INCL	EXE$GL_TENUSEC		; execute the loop to kill 10 u-secs.
;
; INSERT ALL DRIVERS LINKED AS PART OF THE SYSTEM IMAGE IN THE DRIVER 
; PROLOGUE TABLE LIST SO THAT SUBSEQUENT DEVICE CONNECTIONS WILL BE ABLE
; TO FIND THEM.
;
	INSQUE	MB$DPT,IOC$GL_DPTLIST	; INSERT MAILBOX DRIVER ON DRIVER LIST
	INSQUE	NL$DPT,IOC$GL_DPTLIST	; INSERT NULL DRIVER ON DRIVER LIST
	INSQUE	OP$DPT,IOC$GL_DPTLIST	; INSERT CONSOLE DRIVER ON DRIVER LIST
;
; MOVE LOGICAL NAME FOR SYS$DISK INTO NON-PAGED POOL
;
INI_LOG:				;
	MOVAB	LOG$AL_DISKLOG,R4	; GET ADDR OF BLOCK
	MOVZWL	LOG$W_SIZE(R4),R1	; GET SIZE TO ALLOCATE
	BSBW	ALONONPAGED		; ALLOCATE IT
	MOVL	R2,@LOG$AL_LOGTBL	; STORE ADDR TEMPORARILY (SEE SWAPINIT)
	MOVC3	LOG$W_SIZE(R4),(R4),(R2); COPY BLOCK TO POOL
;
; MOVE LOGICAL NAME FOR SYS$SYSDEVICE INTO NON-PAGED POOL
;
	MOVAB	SYSDISKLOG,R4		; GET ADDRESS OF LOG. NAME BLOCK
	MOVZWL	LOG$W_SIZE(R4),R1	; GET SIZE TO ALLOCATE
	BSBW	ALONONPAGED		; ALLOCATE IT
	MOVL	R2,@LOG$AL_LOGTBL+4	; STORE ADDR TEMPORARILY
	MOVC3	LOG$W_SIZE(R4),(R4),(R2); COPY BLOCK TO POOL
;
; THE TERMINAL SERVICE IS NOW ALLOCATED NON-PAGED POOL AND READ INTO IT
; BY SYSBOOT.  THE ADDRESS IN POOL IS PASSED IN BOO$GL_TRMDRV.
; INITIALIZE THE TERMINAL DRIVER.
;
INI_TTYDRV:				;
	.ENABLE	LSB
	MOVL	W^BOO$GL_TRMDRV,R2	; ADDRESS OF TERMINAL SERVICE CODE
	MOVL	R2,G^TTY$GL_DPT		; STORE LOADED TERMINAL SERVICE DPT
	INSQUE	(R2),G^IOC$GL_DPTLIST 	; INSERT TERMINAL DRIVER ON LIST
	CMPB	#DYN$C_DPT,DPT$B_TYPE(R2) ; REALLY A DPT?
	BNEQ	50$			; NOPE, GO SAY SO
	CMPW	OPA$UCB0+UCB$W_SIZE,-	; CORRECT UCB SIZE IN CONSOLE UCB?
		DPT$W_UCBSIZE(R2)
	BGEQU	70$			; IF GEQU YES
	MOVAB	BADCONUCB,R1		; SET ILLEGAL OPA0: ERROR
	BRB	OUTZ			; AND GO DIE

50$:	MOVAB	BADTTYDRV,R1		; SET ILLEGAL FORMAT ERROR
OUTZ:	CLRL	R11			; ADDRESS CONSOLE
	JSB	EXE$OUTZSTRING		; OUTPUT IT
	HALT				;
;
; RELOCATE TTDRIVER CLASS VECTOR, SET ADDRESS OF OPA0 DDT
;
70$:	MOVZWL	DPT$W_VECTOR(R2),R1	; OFFSET TO CLASS VECTOR DISPATCH TABLE
	ADDL2	R2,R1			; CALCULATE ADDRESS
	MOVL	R1,R3			; SAVE
	
80$:	ADDL2	R2,(R1)+		; ADD IN DPT OFFSET
	TSTL	(R1)			; END OF LIST ?
	BNEQ	80$			; BRANCH IF NO
	
	MOVL	CLASS_DDT(R3),-
		OPA$GL_DDB+DDB$L_DDT	; STORE DDT IN CONSOLE DDB
	MOVL	CLASS_DDT(R3),-
		OPA$UCB0+UCB$L_DDT	; STORE DDT IN CONSOLE UCB
	MOVL	R3,-
		OPA$UCB0+UCB$L_TT_CLASS	; STORE CLASS VECTOR ADDRESS
	MOVL	CLASS_GETNXT(R3),-
		OPA$UCB0+UCB$L_TT_GETNXT ; STORE GET NEXT IN CONSOLE UCB
	MOVL	CLASS_PUTNXT(R3),-
		OPA$UCB0+UCB$L_TT_PUTNXT ; STORE PUT NEXT IN CONSOLE UCB
	MOVAL	OP$DPT,R2		; GET ADDRESS OF OPA0 DPT
	MOVZWL	DPT$W_VECTOR(R2),R1	; OFFSET TO PORT VECTOR DISPATCH TABLE
	ADDL3	R1,R2,-
		OPA$UCB0+UCB$L_TT_PORT	; SET ADDRESS IN UCB
	.DISABLE LSB
	.PAGE
	.SBTTL	INIT THE BOOT DEVICE
;
; THE BOOTSTRAP DEVICE DRIVER'S ADDRESS IN POOL IS PASSED IN BOO$GL_DSKDRV.
; FINISH ALLOCATING AND INITIALIZING THE DATA BASE TO DESCRIBE THE BOOT DEVICE,
; AND ANY CLASS/PORT DRIVERS ASSOCIATED WITH IT.
;
INI_BOOTDEVIC:				;
;
; FIGURE OUT THE DEVICE NAME FROM THE ADAPTER.
;
	MOVL	G^EXE$GL_RPB,R6		; ADDRESS OF RPB
	MNEGL	#1,-(SP)		; INIT ADAPTER COUNTS
	PUSHL	(SP)			; ALLOW FOR 8 ADAPTERS
	MOVQ	(SP),-(SP)		; ALLOW FOR 16 ADAPTERS
	MOVAL	IOC$GL_ADPLIST-ADP$L_LINK,R4	; START OF ADAPTER LIST
10$:	MOVL	ADP$L_LINK(R4),R4	; MOVE TO NEXT ADAPTER
	BEQL	20$			; BRANCH IF NONE
	MOVZWL	ADP$W_ADPTYPE(R4),R1	; GET ADAPTER TYPE CODE
	INCB	(SP)[R1]		; BUMP APPROPRIATE COUNT
	MOVB	(SP)[R1],ADP$B_NUMBER(R4); SET ADAPTER NUMBER 
	CMPW	ADP$W_TR(R4),RPB$L_BOOTR1(R6)	; IS THIS THE BOOT ADAPTER?
	BNEQ	10$			; NO, KEEP LOOKING
	MOVZBL	(SP)[R1],R5		; YES, SAVE THE COUNT
	MOVL	R4,R7			; AND ADP ADDRESS
	BRB	10$			; AND CONTINUE THROUGH ALL ADPS
20$:	ADDL	#16,SP			; CLEAN STACK
;
; FIRST CHECK FOR ANY PORT DRIVER.  IF THERE IS ONE, THEN THE DDB AND UCB
; FOR IT MUST BE ALLOCATED, SINCE THEY ARE NOT BUILT IN.
;
	MOVL	W^BOO$GL_PRTDRV,R4	; ADR IN POOL OF BOOT PORT DRIVER
	MOVL	R4,R9			; SAVE AWAY
	BEQL	50$			; THERE IS NO PORT DRIVER
	INSQUE	DPT$L_FLINK(R4),-
		G^IOC$GL_DPTLIST 	; INSERT DRIVER IN LIST
	MOVZBL	#DDB$K_LENGTH,R1	; GET SIZE OF DDB
	BSBW	ALONONPAGED		; GRAB SOME POOL
	MOVL	R2,R3			; TRANSFER
	MOVW	R1,DDB$W_SIZE(R3)	; SET THE SIZE
	MOVZBW	#DYN$C_DDB,DDB$B_TYPE(R3) ; AND TYPE
	MOVAL	G^IOC$GL_DEVLIST,R1	; PICK UP SYSTEM DDB LIST POINTER
30$:	MOVL	DDB$L_LINK(R1),R2	; CHASE DOWN THE LIST
	BEQL	40$			; UNITL THE END
	MOVL	R2,R1			; TRANSFER POINTERS
	BRB	30$			; AND CONTINUE

40$:	MOVL	R3,DDB$L_LINK(R1)	; LINK US IN
;	CLRL	DDB$L_LINK(R3)		; AND SET AS END
	BSBW	FIX_DRV_NAME		; FIX UP THE NAMES
	PUSHL	R3			; SAVE POINTER TO DDB
	MOVZWL	DPT$W_UCBSIZE(R4),R1	; PICK UP SIZE OF UCB
	BSBW	ALONONPAGED		; GET IT
	POPL	R3			; RESTORE DDB
	MOVL	R2,DDB$L_UCB(R3)	; SET POINTER
	MOVL	R3,UCB$L_DDB(R2)	; AND ANOTHER
	MOVL	R2,R10			; COPY ADDRESS
	CLRQ	(R2)+			; STEP TO SIZE
	MOVW	R1,(R2)+		; SET SIZE
	MOVZBW	#DYN$C_UCB,(R2)+	; SET TYPE
	MOVL	R2,(R2)+		; SET ASTQFL
	MOVL	UCB$L_ASTQFL(R10),(R2)	; SET ASTQBL
	MOVAL	UCB$L_IOQFL(R10),-
		UCB$L_IOQFL(R10)	; SET IOQFL
	MOVAL	UCB$L_IOQFL(R10),-
		UCB$L_IOQBL(R10)	; AND IOQBL
	CLRL	R5			; SET CLASS DRIVER TO "DUA"
;
; NOW FIX UP BOOT DISK DEVICE
;
50$:	MOVL	W^BOO$GL_DSKDRV,R4	; ADR IN POOL OF BOOT DISK DRIVER
	INSQUE	DPT$L_FLINK(R4),-
		G^IOC$GL_DPTLIST	; INSERT DRIVER IN LIST
	MOVAL	G^SYS$GL_BOOTDDB,R3	; GET DDB ADDRESS FOR BOOT DEVICE
	BSBW	FIX_DRV_NAME		; FIX UP THE NAMES
	MOVL	DDB$L_UCB(R3),R5	; PICK UP UCB ADDRESS
	CMPW	DPT$W_UCBSIZE(R4),-	; CHECK THAT PREBUILT IS LARGE
		UCB$W_SIZE(R5)		;  ENOUGH
	BLSS	60$			; YES
	MOVAB	BADDSKUCB,R1		; NO, SET ERROR MESSAGE
	BRW	OUTZ

60$:	MOVL	R5,G^EXE$GL_SYSUCB	; SET ADDRESS OF SYSTEM DEVICE UCB
	PUSHR	#^M<R1,R3>		; SAVE REGISTERS
	MOVL	W^BOO$GL_BOOTCB,R1	; GET BOOT CONTROL BLOCK ADDRESS
	MOVL	BOO$L_SYS_MAP(R1),R0	; GET WCB ADDRESS FOR SYS.EXE
	MOVL	R5,WCB$L_ORGUCB(R0)	; SET UCB IN WINDOW CONTROL BLOCK
	MOVL	BOO$L_CHECKSUM(R1),EXE$GQ_BOOTCB_D ; BYTE COUNT TO CHECKSUM
					; LEFT HERE BY SYSBOOT
	JSB	EXE$BOOTCB_CHK		; CALCULATE BOOTCB CHECKSUM IN R3
	MOVL	R3,BOO$L_CHECKSUM(R1)	; AND STORE IT
	POPR	#^M<R1,R3>		; RESTORE REGISTERS
	BBC	#DPT$V_SVP,DPT$B_FLAGS(R4),70$	; IF DRIVER REQUESTS ...
	BSBW	ALOSPT			; ALLOCATE SPT SLOT FOR UCB WINDOW
	MOVL	R0,UCB$L_SVPN(R5)	; SAVE SYSTEM VPN IN UCB
70$:	MOVZWL	RPB$W_UNIT(R6),R0	; PICK UP UNIT NUMBER FROM BOOT
	MOVW	R0,UCB$W_UNIT(R5)	; SET PROPER UNIT NUMBER
;
; NOW THE BOOT DISK DRIVER (AND ANY ASSOCIATED PORT DRIVER) HAVE BEEN HOOKED
; INTO THE DATA BASE. DDB'S AND UCB'S ARE PRESENT.
;
;	R3 -->	DISK [CLASS] DRIVER DDB
;	R4 -->	DISK [CLASS] DRIVER DPT
;	R5 -->	DISK [CLASS] DRIVER UCB
;	R6 -->	RPB
;	R7 -->	ADP FOR EITHER A REAL DISK OR A PORT
;	R9 -->	PORT DRIVER DPT (IF PRESENT)
;	R10-->	PORT DIRVER UCB (IF PRESENT)
;
; SPECIAL CODE FOR THE CONSOLE DEVICE
;
	CMPB	RPB$B_DEVTYP(R6),-	; BOOTING FROM CONSOLE BLOCK
		#BTD$K_CONSOLE		; STORAGE DEVICE?
	BNEQ	BLD_CRB			; NO
	MOVL	#^A/CSA/@8+3,-		; YES, SET DEVICE NAME
		DDB$T_NAME(R3)		; COUNTED STRING

	CPUDISP	<CONS_BOOT_780,-	; *DISPATCH ON CPU TYPE*
		 CONS_BOOT_750,-
		 CONS_BOOT_730,-
		>

CONS_BOOT_780:
	MOVAL	G^OPA$CRB,R8		; SET ADDRESS OF CRB
	BRW	FIN_DATABASE

CONS_BOOT_750:
CONS_BOOT_730:
	CLRL	R7			; CLEAR ADP POINTER
	MOVW	#1,UCB$W_UNIT(R5)	; SET UNIT NUMBER TO 1
	BRB	FILL_CRB

CONS_BOOT_END:				; *END OF CPU DEPENDENT CODE*
;
; NOW BUILD THE AUXILIARY DATA BLOCKS (CRB,IDB)
;
BLD_CRB:
	MOVL	ADP$L_CRB(R7),R8	; GET ADDRESS OF CRB IF IT EXISTS
	CMPW	#AT$_UBA,ADP$W_ADPTYPE(R7); IS THIS A UNIBUS ADAPTER?
	BEQL	FILL_CRB		; YES, ALLOCATE CRB
	BRW	FIN_DATABASE		; NO, CRB/IDB ALREADY ALLOCATED

FILL_CRB:
	BSBW	ALLOC_CRB		; GO ALLOCATE AND SETUP CRB
	MOVL	#^X9F163FBB,CRB$L_INTD(R2) ; SET PUSHR #^M<R0,...R5>
					;  JSB @#0 INTO INTERRUPT DISPATCH
	MOVL	R7,CRB$L_INTD+VEC$L_ADP(R2)	; SET POINTER TO ADP
	MOVL	R2,R8			; SAVE CRB POINTER
	MOVZWL	#<IDB$C_LENGTH+<8*4>>,R1; SIZE TO ALLOCATE FOR IDB
	BSBW	ALONONPAGED		; ALLOCATE IDB
	MOVW	R1,IDB$W_SIZE(R2)	; SET SIZE OF IDB
	MOVB	#DYN$C_IDB,IDB$B_TYPE(R2); AND STRUCTURE TYPE CODE
	MOVL	R2,CRB$L_INTD+VEC$L_IDB(R8) ; SET IDB INTO CRB
	CMPB	RPB$B_DEVTYP(R6),-	; BOOTING FROM CONSOLE BLOCK
		#BTD$K_CONSOLE		; STORAGE DEVICE?
	BNEQ	20$			; NO
	ADDL3	EXE$GL_SCB,#^XF0,R0	; YES, GET ADDRESS OF VECTOR IN SCB
	MOVAL	CRB$L_INTD+1(R8),(R0)+	; SET ADDR IN 1ST VECTOR
	MOVAL	CRB$L_INTD2+1(R8),(R0)  ; SET ADDR IN 2ND VECTOR
	MOVL	#^X9F163FBB,CRB$L_INTD2(R8) ; STORE PUSHR #^M<R0...R5>
					    ; JMP @# IN 2ND INT. DISPATCH
	MOVL	R2,CRB$L_INTD2+VEC$L_IDB(R8); STORE ADDRESS OF IDB IN CRB
	MOVL	#PR$_CSTD, -		; STORE IPR NUMBER OF CONSOLE INTERFACE
		@CRB$L_INTD+8(R8)	; REGISTER AS DEVICE CSR ADDRESS
	BRB	FIN_DATABASE

20$:	MOVL	RPB$L_CSRVIR(R6), -	; SAVE BOOT DEVICE CSR ADDRESS
		IDB$L_CSR(R2)		; IN INTERRUPT DISPATCH BLOCK
	CMPB	#BTD$K_UDA,-		; LOW ORDER BYTE OF ORIGINAL R0 TELLS
		RPB$L_BOOTR0(R6)	;  BOOT DEVICE TYPE.
	BNEQ	25$			; IF NOT BOOTING FROM A UDA BRANCH
					;  AROUND.
	MOVL	RPB$L_CSRVIR(R6), -	; COPY VIRTUAL ADDRESS OF UDA PORT CSR
		W^BOO$GB_SYSTEMID	;  TO LOW ORDER LONGWORD OF SYSTEMID
25$:
	MOVL	R7,IDB$L_ADP(R2)	; POINT IDB TO ADP
	MOVZWL	RPB$W_R0UBVEC(R6),R0	; GET USER SPECIFIED VECTOR
	BNEQ	30$			; BRANCH IF VECTOR SPECIFIED
	MOVZBL	RPB$B_DEVTYP(R6),R0	; ELSE GET DEVICE TYPE CODE
	MOVZWL	BOOTVECTOR-2[R0],R0	; GET DEFAULT INTERRUPT VECTOR
30$:	MOVAB	@ADP$L_VECTOR(R7)[R0],R0; COMPUTE ADDRESS OF VECTOR
	MOVAB	CRB$L_INTD+2(R8),(R0)	; SET ADDR OF INTERRUPT VECTOR
					;
	CPUDISP	<SET_VEC_780,-		; *DISPATCH ON CPU TYPE*
		SET_VEC_750,-		;
		SET_VEC_730>
					;
SET_VEC_730:				; IF 730, SAME ACTION AS 750
SET_VEC_750:				; IF 750, STEP VECTOR BACK 2
	DECL	(R0)			;  BYTES TO PUSHR, +1 TO SPECIFY
					;  INTERRUPT STACK
					;
SET_VEC_780:				; IF 780, VECTOR OK ALREADY
SET_VEC_END:				; *END OF CPU-DEPENDENT CODE*
					;
					;
FIN_DATABASE:				; FINISH DATABASE INITIALIZATION
;
; NOW FILL IN CORRECT EQUIVALENCE STRING FOR SYS$DISK
;
	MOVL	UCB$L_DDB(R5),R6	; PICK UP BOOT DDB
	MOVL	@LOG$AL_LOGTBL,R2	; GET ADDRESS OF SYS$DISK NAME BLOCK
	MOVZBL	LOG$C_LENGTH(R2),R1	; GET LENGTH OF LOGICAL NAME
	MOVAB	LOG$C_LENGTH+2(R2)[R1],R2 ; POINT TO EQUIVALENCE NAME (AT "_")
	MOVW	DDB$T_NAME+1(R6),1(R2)	; SET FIRST TWO CHARACTERS OF NAME
	MOVB	DDB$T_NAME+3(R6),3(R2)	; SET CONTROLLER DESIGNATOR
	MOVZWL	UCB$W_UNIT(R5),R0	; PICK UP UNIT NUMBER
	CLRL	R1			; CLEAR HI ORDER
	MOVAB	7(R2),R3		; SET R3 TO POINT TO ":"
	PUSHL	R3			; SAVE STARTING POSITION
50$:	EDIV	#10,R0,R0,R6		; GET A DIGIT
	ADDB	R6,-(R3)		; MAKE ASCII
	TSTL	R0			; CHECK IF DONE
	BNEQ	50$			; NO, CONTINUE
	MOVL	(R3),4(R2)		; LEFT JUSTIFY
	SUBL3	R3,(SP)+,R1		; NUMBER OF DIGITS
	ADDB	R1,-1(R2)		; UPDATE ASCIC COUNT
;
; FILL IN CORRECT EQUIVALENCE STRING FOR SYS$SYSDEVICE
;
	MOVL	@LOG$AL_LOGTBL+4,R6	; GET ADDRESS OF SYS$SYSDISK NAME BLOCK
	MOVZBL	LOG$C_LENGTH(R6),R1	; GET LENGTH OF LOGICAL NAME
	MOVAB	LOG$C_LENGTH+2(R6)[R1],R1 ; POINT TO EQUIV NAME (AT 1ST "_")
	BBS	S^#EXE$V_CONCEALED,-
		G^EXE$GL_FLAGS,90$ 	; BRANCH IF CONCEALING DEV NAMES
	DECB	-1(R1)			; AND FIX THE BYTE COUNT INCREMENT
90$:	MOVZBL	-1(R1),R0		; CONVERT TO LONG FOR ARITHMETIC
	ADDB	-1(R2),-1(R1)		; UPDATE BYTE COUNT
	ADDL	R0,R1			; SET NUMBER OF "_"'S
	MOVQ	(R2),(R1)		; STORE DEV. NAME, CNTRLR, AND UNIT
;
; CONNECT UP CRB/IDB
;
	.ENABLE LSB
	TSTL	R9			; PORT DRIVER?
	BEQL	10$			; NO
	MOVQ	R4,-(SP)		; YES, SAVE DSK DPT/UCB ADDRESS
	MOVQ	R9,R4			; TRANSFER PORT DPT/UCB ADDRESS
10$:	MOVL	R8,UCB$L_CRB(R5)	; CONNECT UCB TO CRB
	INCW	CRB$W_REFC(R8)		; STEP COUNT OF CONNECTED UCB'S
	MOVL	CRB$L_INTD+VEC$L_IDB(R8),R2  ; GET ADDRESS OF IDB
	BEQL	20$			; NONE
	MOVZWL	UCB$W_UNIT(R5),R0	; GET UNIT NUMBER
	MOVL	R5,IDB$L_UCBLST(R2)[R0]	; SET ADDRESS OF UCB INTO IDB LIST
	MOVW	#8,IDB$W_UNITS(R2)	; SET MAXIMUM NUMBER OF UNITS
;
; CONNECT DRIVER TO DEVICE DATA BASE AND PERFORM ANY NECESSARY RELOCATION.
;
20$:	JSB	G^IOC$INITDRV		; CONNECT DRIVER TO DATA BASE
	MOVL	UCB$L_DDB(R5),R6	; GET DDB
	MOVL	DDB$L_DDT(R6),UCB$L_DDT(R5) ; SET DDT IN UCB
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ; MUST FORCE ON SOFTWARE VOLUME VALID
;
; DITTO FOR CLASS DRIVER
;
	TSTL	R9			; ANY CLASS DRIVER?
	BEQL	40$			; NO, LEAVE
	MOVQ	(SP)+,R4		; YES, TRANSFER TO CORRECT REGISTER
	BSBW	ALLOC_CRB		; GET A CRB
	MOVAL	W^BOO$GB_SYSTEMID,-	; STUFF THE ADDRESS OF THE BOOT SYSID
		CRB$L_INTD+IDB$L_CSR(R2);  INTO A CONVENIENT PLACE
	MOVAL	CRB$L_INTD(R2),-	; PUT THAT ADDRESS IN PLACE OF IDB
		CRB$L_INTD+VEC$L_IDB(R2);  SO THAT R4->SYSID IN CONTROLLER INIT
	MOVL	R2,UCB$L_CRB(R5)	; CONNECT UCB TO CRB
	INCW	CRB$W_REFC(R2)		; STEP COUNT OF CONNECTED UCB'S
	MOVL	R7, -			; FOR CLASS DRIVER, SAVE ADP POINTER IN
		CRB$L_INTD+VEC$L_ADP(R2);  VEC SO THAT UNIBUS MAPPING ROUTINES
					;  CAN WORK.
	CLRL	R9			; CLEAR A FLAG
	BRB	20$			; CONNECT THIS DRIVER
;
; ALLOC_CRB - ALLOCATE AND PARTIALLY FILL A CRB BLOCK
;
ALLOC_CRB:
	MOVZWL	#CRB$C_LENGTH,R1	; SET SIZE TO ALLOCATE
	BSBW	ALONONPAGED		; ATTEMPT TO ALLOCATE IT
	MOVW	R1,CRB$W_SIZE(R2)	; SET STRUCTURE SIZE
	MOVB	#DYN$C_CRB,CRB$B_TYPE(R2); AND TYPE CODE
	MOVAL	CRB$L_WQFL(R2),-
		CRB$L_WQFL(R2)		; BUILD WAIT QUEUE HEADER
	MOVAL	CRB$L_WQFL(R2),-
		CRB$L_WQBL(R2)		; FLINK AND BLINK
	RSB
;
; FIX_DRV_NAME - FIX UP THE DRIVER/DEVICE NAMES IN DDB/DDT
;
FIX_DRV_NAME:
	MOVZBL	DPT$T_NAME(R4),R0	; GET SIZE OF DRIVER NAME
	INCL	R0			; BUMP TO INCLUDE COUNT
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	R0,DPT$T_NAME(R4),-
		 DDB$T_DRVNAME(R3)	; SET DRIVER NAME IN DDB
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	MOVAB	DDB$T_NAME(R3),R2	; GET ADDRESS OF DEVICE NAME
	MOVB	#3,(R2)+		; SET COUNT FOR DDB NAME
	MOVW	DDB$T_DRVNAME+1(R3),(R2)+ ; ASSUME SAME AS START OF DRIVER
	ADDB3	#^A/A/,R5,(R2)		; SET CONTROLLER BASED ON ADAPTER COUNT
	RSB
;
; RESTORE PROPER IPL FOR POOL ALLOCATION
;
40$:	MOVL	R11,G^EXE$GL_NONPAGED	; END OF INIT POOL ALLOCATION
	ASHL	#1,G^IOC$GL_IRPMIN,R0	; IRPSIZE  * 2
	DIVL	#3,R0			; 2/3 * IRPSIZE
	ADDL	#^XF,R0			; ROUND TO NEXT 16 BYTE BOUND
	BICL3	#^XF,R0,G^IOC$GL_IRPMIN	; AND SAVE AS WORKING IRPMIN	
	.DISABLE LSB
;
; INIT DEVICE CONTROLLERS FOR DEVICES WITH RESIDENT DATABASES:
;
INI_DEVICE:				;
	MNEGL	#1,AP			; Set flag for INIT ALL
	JSB	G^EXE$INIT_DEVICE
	.PAGE
	.SBTTL	MISCELLANEOUS CLEAN UP
;
FINISH_UP:
	JSB	G^INI$RDONLY		; MAKE THE SYSTEM CODE READ ONLY
	JSB	G^EXE$INIPROCREG	; INIT PROCESSOR REGISTERS
	JSB	G^MMG$ALLOCPFN		; GET A MEMORY PAGE
	MOVL	R0,G^EXE$GL_BLAKHOLE	; SAVE PFN - THIS IS THE RABBIT HOLE PAGE
	DECL	G^PFN$GL_PHYPGCNT	; DECREASE NUMBER OF PAGES AVAILABLE
;
; ALLOCATE AN SPT ENTRY AND BUILD A PTE TO MAP THE BLAKHOLE PAGE INTO
; SYSTEM SPACE.  SAVE THE SYSTEM VIRTUAL ADDRESS OF THAT PTE IN A GLOBAL
; LONGWORD, TO BE USED LATER BY THE MOUNT VERIFICATION CODE.
;
	BSBW	ALOSPT			; GET AN SPT
	MOVAL	@MMG$GL_SPTBASE[R0],R0	; CALCULATE THE SVA OF THE PTE
	MOVL	R0,G^EXE$GL_SVAPTE	; SAVE THE SVA OF THE PTE
	INSV	G^EXE$GL_BLAKHOLE,-	; SET THE PFN
		#0,#PTE$S_PFN,(R0)	;
50$:	MOVZWL	SGN$GW_SYSDWSCT,R0	; SYSTEM WORKING SET COUNT
	SUBL3	R0,SCH$GL_FREECNT,R0	; SET AVAILABLE PAGE COUNT
	ADDL3	#<<MMG$A_SYS_END-MMG$AL_PGDCODEN>@-9>,R0,-
		PFN$GL_PHYPGCNT		; ADD INIT PAGES ALSO
	MOVL	G^SGN$GL_FREELIM,-
		G^SCH$GL_FREELIM	; SET WORKING VALUE OF FREE LIMIT
	SUBL3	G^SCH$GL_FREELIM,-
		G^PFN$GL_PHYPGCNT,R0	; COMPUTE MAX WS SIZE
	MOVZWL	MPW$GW_LOLIM,R1		; SUBTRACT OUT FROM TOTAL
	SUBL	R1,R0
	SUBL	SCH$GL_FREELIM,R0	; MINUS 2*FREELIM
	CMPL	R0,SGN$GL_MAXWSCNT	; CHECK MAX WS COUNT FOR PHYS MEM
	BGEQU	60$			; BR IF OK
	MOVL	R0,SGN$GL_MAXWSCNT	; OTHERWISE LIMIT WS SIZE TO AVAILABLE MEM
60$:					;
	MOVZBL	SWP$GB_SHLP1PT,-(SP)	; GET MANDATORY PAGE TABLES FOR SHELL
	MOVZWL	SGN$GW_MINWSCNT,R1	; GET MINIMUM FLUID WORKING SET
	ADDL	SGN$GL_PHDPAGCT,R1	; ADD FIXED PROCESS HEADER
	ADDL	(SP)+,R1		; ADD NECESSARY PAGE TABLES
	ADDL	S^#SWP$C_KSTACK+1,R1	; ADD SPACE FOR KERNEL STACK AND POINTERS
	CMPL	R0,R1			; MIN WORKING SET MUST BE LESS THAN
	BGEQ	70$			; AVAILABLE PHYSICAL MEMORY
	MOVAB	W^NOPHYSMEM,R1		; SET ADDRESS OF MESSAGE
	CLRL	R11			; USE CONSOLE TERMINAL
	JSB	EXE$OUTZSTRING		; GIVE ERROR
	HALT				; ***** FATAL ERROR *****
70$:					;
	MOVZWL	#^XF03,R1		; SET TO CLEAR WARM START INHIBIT
	BSBW	ENABL_START		; NOTIFY CONSOLE
	MOVZWL	#^XF04,R1		; SET TO CLEAR BOOT INHIBIT
	BSBW	ENABL_START		; NOTIFY CONSOLE
;
;	MOVE A PIECE OF INIT INTO THE UNUSED POOL AND JUMP TO IT.
;	THIS SEGMENT OF CODE WILL RELEASE THE INIT PAGES TO THE FREELIST.
;
	MOVL	EXE$GL_NONPAGED+4,R6	; GET ADDRESS OF FREE BLOCK
	ADDL	#8,R6			; SKIP HEADER
	MOVC3	#INI_EXITSIZ,W^INI_EXITCODE,(R6)	; COPY CODE TO POOL
	MOVPSL	-(SP)			; BUILD PC PCL PAIR
	PUSHL	R6			; SET NEW PC
	REI				; TRANSFER TO CODE IN POOL
;
INI_EXITCODE:				; START OF EXIT CODE TO DESTROY INIT
	MOVAL	FREE,R5			; SET ADDRESS OF FREE MEMORY DESCRIPTOR
	PUSHAB	@#SCH$SCHED		; SET EXIT TO SCHEDULER
					; FALL THROUGH TO FILLSPT TO FREE
					;  INIT PAGES;  FILLSPT RSB
					;  EXITS TO SCH$SCHED
	.PAGE
;
; FILL THE SPT AND RELEASE PREVIOUSLY MAPPED PAGES IF ANY
;
; INPUT:
;
;	R5 = DESCRIPTOR OF RANGE OF PAGES AND NEW PTE
;		0(R5) = 1ST VIRTUAL PAGE NUMBER
;		4(R5) = LAST + 1 VIRTUAL PAGE NUMBER
;		8(R5) = NEW PAGE TABLE ENTRY TO STORE
;
; OUTPUT:
;
;	R4 ALTERED
;
 
FILLSPT:
	MOVL	(R5),R4
	PUSHL	@#MMG$GL_SPTBASE	; GET BASE ADDRESS OF SPT
20$:	BICL3	#^C<PTE$M_PFN>,@(SP)[R4],R0 ; PFN FROM SPT ENTRY IF ANY
	BEQL	40$			; BRANCH IF NONE THERE
	JSB	@#MMG$DALLOCPFN		; OTHERWISE DEALLOCATE IT
40$:	MOVL	8(R5),@(SP)[R4] 	; SET NEW SPT ENTRY
	AOBLSS	4(R5),R4,20$		; REPEAT FOR EACH PAGE IN THE RANGE
	INVALID				; INVALIDATE THE TRANSLATION BUFFER
	TSTL	(SP)+			; CLEAN STACK
	RSB				; AND RETURN
 
FREE:	.LONG	<INI_BASE-^X80000000>@-9	; START OF INIT
	.LONG	<MMG$A_SYS_END-^X80000000>@-9	; END OF INIT
	.LONG	0				; NO ACCESS PTE
INI_EXITSIZ=.-INI_EXITCODE		; SIZE OF EXIT CODE
;
; SET THE PFN IN R0 RESIDENT
;
; INPUT:
;
;	R0 = PFN
;
; OUTPUT:
;
;	NONE
;
 
SETRESIDENT:
	INCW	@PFN$AW_REFCNT[R0]	; COUNT ONE REFERENCE
	MOVAL	@MMG$GL_SPTBASE[R0],@PFN$AL_PTE[R0] ; BACK PTE POINTER
	MOVB	#PFN$C_ACTIVE,@PFN$AB_STATE[R0] ; PAGE IS ACTIVE
	MOVB	#PFN$C_SYSTEM,@PFN$AB_TYPE[R0] ; SYSTEM PAGE
	RSB
	.PAGE
	.SBTTL	NONPAGED POOL ALLOCATION SUBROUTINES
;+
; ALONONPAGED CALLS EXE$ALONONPAGED TO ALLOCATE NON-PAGED POOL.  IF POOL
; SPACE IS NOT SUFFICIENT TO CONTAIN THE REQUEST, A FATAL ERROR MESSAGE IS
; GIVEN AND EXECUTION HALTS. THE PC ON THE TOP OF STACK WILL GIVE FURTHER
; CONTEXT ABOUT THE ERROR.  THE ALLOCATED BLOCK WILL BE ZEROED.
;
; INPUT:
;	R1 - SIZE OF REQUESTED BLOCK IN BYTES
;
; OUTPUTS:
;	R0 - SUCCESS/FAILURE INDICATION
;	R1 - ALLOCATED SIZE OF BLOCK
;	R2 - ADDRESS OF BLOCK
;-
INI$ALONONPAGED::			;
ALONONPAGED:				;
	PUSHL	R1			; SAVE DESIRED ALLOCATION QUANTITY
	JSB	EXE$ALONONPAGED		; ATTEMPT TO ALLOCATE
	BLBS	R0,10$			; CONTINUE IF ALLOCATED
	MOVQ	FIL$GQ_CACHE,R1		; DEALLOCATE FIL$OPENFILE CACHE 
	BEQL	5$			; BRANCH IF ALREADY GONE, FATAL
	CLRQ	FIL$GQ_CACHE		; SAY IT IS GONE
	MOVL	R2,R0			; ADDRESS TO R0, SIZE IN R1
	PUSHL	R3			; SAVE THIS FROM DEALLOCATE
	MOVL	EXE$GL_NONPAGED+4,R3	; ADDRESS OF FREE NON-PAGED POOL
	JSB	EXE$DEALLOCATE		; DEALLOCATE THE PIECE
	POPR	#^M<R3>			; RECOVER SAVED R3
	POPR	#^M<R1>			; GET ALLOCATION QUANTITY
	BRB	ALONONPAGED		; AND TRY ALL OVER AGAIN
5$:	BSBB	NOPOOLERR		; GIVE ERROR MESSAGE
	HALT				; ***** FATAL ERROR *****
10$:	ADDL	#4,SP			; CLEAN OFF SAVED ALLOC SIZE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC5	#0,(R2),#0,R1,(R2)	; ZERO FILL BLOCK
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	RSB				; RETURN
;
; NOPOOLERR - SEND ERROR MESSAGE FOR INSUFFICIENT NON-PAGED POOL
;
NOPOOLERR:				;
	CLRL	R11			; INDICATE CONSOLE TERMINAL
	MOVAB	NOSPACE,R1		; SET ADDRESS OF ERROR MESSAGE
	JMP	EXE$OUTZSTRING		; AND OUTPUT IT
	.PAGE
	.SBTTL	ALOSPT - ALLOCATE AND FILL SPT ENTRY FOR BUFFER WINDOW
;+
; ALOSPT ALLOCATES AN SPT SLOT TO BE USED FOR BUFFER OVERMAPPING WHEN
; PERFORMING ECC CORRECTION OR OTHER SIMILAR EXCEPTIONAL I/O OPERATIONS.
; THE SYSTEM PAGE TABLE ENTRY FOR THE ALLOCATED SYSTEM VIRTUAL PAGE NUMBER
; WILL BE SET VALID, KERNEL WRITABLE BUT MAPPED TO A NON-EXISTENT PHYSICAL PAGE.
; A FATAL ERROR MESSAGE WILL BE GIVEN IF UNABLE TO ALLOCATE SPT.
;
; INPUT:
; 	BOO$GL_SPTFREL - LOWEST FREE SYSTEM VPN
;	BOO$GL_SPTFREH - HIGHEST FREE SYSTEM VPN
;
; OUTPUT:
;	R0 - SYSTEM VPN ALLOCATED
;	@MMG$GL_SPTBASE[R0] - PTE$M_VALID!PTE$M_PFN!PTE$C_KW
;-
ALOSPT:					;
	MOVL	BOO$GL_SPTFREL,R0	; GET NEXT AVAILABLE SYSTEM VPN
	CMPL	R0,BOO$GL_SPTFREH	; CHECK FOR REALLY AVAILABLE
	BLEQ	10$			; BRANCH IF YES
	MOVAB	NOSPT,R1		; SET ADDRESS OF ERROR MESSAGE
	CLRL	R11			; INDICATE CONSOLE TERMINAL	
	JSB	EXE$OUTZSTRING		; OUTPUT ERROR MESSAGE
	HALT				; **** FATAL ERROR ****
10$:	INCL	BOO$GL_SPTFREL		; MARK VPN ALLOCATED
	MOVL	#<PTE$C_KW!PTE$M_VALID!PTE$M_PFN>,-	;
		@MMG$GL_SPTBASE[R0]	; SET SPTE VALID, WRITABLE, NONEXISTENT PFN
	RSB				;
	.PAGE
	.SBTTL	ENABL_START - NOTIFY CONSOLE TO CLEAR WARM/COLDSTART FLAG
;+
; ENABL_START IS CALLED TO SEND A COMMAND TO THE CONSOLE VIA
; THE CONSOLE TXDB.
;
; INPUT:
;	R1 = CONSOLE COMMAND
;
; OUTPUT:
;	COMMAND SENT
;-
	.ENABL	LSB

ENABL_START:				; ENTER SUBROUTINE
	MFPR	#PR$_TXCS,R0		; GET TRANSMITTER STATUS
	BBC	#7,R0,ENABL_START	; WAIT FOR CONSOLE READY
	MTPR	R1,#PR$_TXDB		; ASSERT COMMAND
10$:	MFPR	#PR$_TXCS,R0		; GET TRANSMITTER STATUS
	BBC	#7,R0,10$		; WAIT FOR CONSOLE DONE
	RSB				; RETURN
	
	.DSABL	LSB
	.PAGE
	.SBTTL	RESIDENT PSECT CODE
	.PSECT	XDELTA,BYTE
;
;	INITIAL BREAKPOINT
;
; INPUT:
;	NONE
;
; OUTPUT:
;	CAUSES ENTRY TO DEBUGGER VIA BREAK POINT
;
; ***** WARNING DO NOT ALTER THIS ROUTINE, JUST A BPT AND RETURN.
;
 
INI$BRK::
	BPT				; STARTS AS BPT, CHANGED TO NOP
	RSB				; RETURN
 
;
;	MASTER WAKE INTERRUPT, CAUSED BY SOFTWARE LEVEL 5 INTERRUPT:
;
	.PSECT	$AEXENONPAGED,LONG

	.ALIGN	LONG
INI$MASTERWAKE::			; SOFTWARE LEVEL 5 INTERRUPT
	JSB	G^INI$BRK		; CALL BREAKPOINT SUBROUTINE
	REI				; RETURN FROM INTERRUPT
	.PAGE
;
; MAKE SYSTEM CODE READ ONLY, MAKE SYSTEM CODE READ/WRITE
; USED BY XDELTA AND INIT.
;
; INPUTS:	NONE
;
; OUTPUTS:	ALL REGISTERS PRESERVED
;
	.PSECT	XDELTA,BYTE
 
	.ENABL	LSB
INI$WRITABLE::
	PUSHR	#^M<R0,R1,R2,R3>	; PRESERVE REGISTERS USED
	MOVZBL	#PRT$C_URKW,R0		; PROTECTION TO USE
	BRB	20$
INI$RDONLY::
	PUSHR	#^M<R0,R1,R2,R3>	; PRESERVE REGISTERS USED
	MOVZBL	#PRT$C_UR,R0		; PROTECTION TO USE
20$:
	MOVAL	W^INI_RDONLY_LIST,R3	; GET START OF READ ONLY LIST
	BBS	S^#EXE$V_SYSWRTABL,EXE$GL_FLAGS,60$ ; BRANCH IF LEAVING SYSTEM WRITABLE
	MOVQ	(R3)+,R1		; GET A SET OF ADDRESS LIMITS
	BEQL	60$			; DONE IF NULL
40$:
	INSV	R0,#PTE$V_PROT,#PTE$S_PROT,@MMG$GL_SPTBASE[R1] ; SET PROTECTION
	ACBL	R2,#4,R1,40$		; FOR EACH PAGE
	INVALID				; INVALIDATE THE TRANSLATION BUFFER
60$:
	POPR	#^M<R0,R1,R2,R3>	; RESTORE SAVED REGISTERS
	RSB				; AND RETURN TO THE CALLER
	.DSABL	LSB			;
;
;	LIST OF READ ONLY SECTIONS IN THE RESIDENT EXEC
;
INI_RDONLY_LIST:			;
	.LIST	MEB
	PURE	MMG$FRSTRONLY,<>	; SECOND LONGWORD LOADED BY INIT
	PURE	MMG$AL_BEGDRIVE,MMG$AL_ENDDRIVE	;
;
;	THE LIST MUST TERMINATE WITH THE FOLLOWING TWO DESCRIPTORS
;
PGDCOD_LIM:				;
	PURE	<>,MMG$AL_PGDCODEN	; FIRST LONGWORD LOADED BY INIT
	.LONG	0,0			; NULL DESCRIPTOR TO TERMINATE
	.NLIST	MEB			;
	.END	EXE$INIT
