	.TITLE	SHMGSDRTN - GLOBAL SECTION DESCRIPTOR ROUTINES FOR SHARED MEMORY
	.IDENT	'V03-002'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: MEMORY MANAGEMENT
;
; ABSTRACT: ROUTINES TO TRANSLATE LOGICAL NAMES FOR GLOBAL SECTION NAMES,
;	    SEARCH ALL GSD LISTS AND TABLES, AND HANDLE SHARED MEMORY
;	    GLOBAL SECTION PAGE AND DESCRIPTOR RESOURCES.
;
; ENVIRONMENT: VAX/VMS
;
; AUTHOR: KATHLEEN D. MORSE	, CREATION DATE: 15-JAN-1979
;
; MODIFIED BY:
;
;	V03-002	KDM0100		Kathleen D. Morse	13-Apr-1982
;		Correct the shared memory global section page bitmap
;		scan to include the last byte of the bitmap, even
;		when not all of it is used.  Sysgen now correctly
;		initializes the unused bits in that byte.
;
;	V03-001	DWT0039		David Thiel		13-Apr-1982
;		Add MMG$FREEGSD routine to recover shared memory
;		GSD's and data pages after the processor that
;		created them has been re-booted.  Call it after
;		a failure to allocate a GSD or data pages.
;		Acquire the shared memory mutex and lock the bitmap
;		while pages are being released.
;		Fix error paths in READ_GSD/WRITE_GSD.
;
;	V02-023	KDM0065		Kathleen D. Morse	5-Nov-1981
;		Remove the check for a negative SHB reference count
;		until the bug is found that makes it correct.  This
;		count was to allow disconnect of the MA780, a feature
;		never implemented.
;
;	V02-022	LJK0059		Lawrence J. Kenah	4-Sep-1981
;		Reset previous mode field in PSL so that system service
;		exceptions work correctly. Add ASSUME macros so that
;		dynamically locked pages are always two adjacent pages.
;
;	V02-021	LJK0040		Lawrence J. Kenah	4-Aug-1981
;		Change still more word references to longword references.
;
;	V02-020	LJK0039		Lawrence J. Kenah	31-Jul-1981
;		Change RPTEVT macro call to use JSB linkage.
;
;	V02-019	LJK0019		Lawrence J. Kenah	23-Jun-1981
;		Change page protection on process header pages from SRKW 
;		to ERKW to allow only protected access to header pages.
;
;	V02-018	KTA0022		Kerbey T. Altmann	10-Jun-1981
;		Change another of those tiresome word offsets to long.
;
;	V02-017	KDM0049		Kathleen D. Morse	28-Mar-1981
;		Replace absolute literals with references to EXE$GL_LOCKRTRY.
;
;	V02-016	KDM0029		KATHLEEN D. MORSE	19-JAN-1980
;		Fix bug in shared memory global section table scan
;		routine when last gsd in table is used.
;
;	V02-015	KDM0013		KATHLEEN D. MORSE	3-JUN-1980
;		Allow deletion of a section table entry for which there
;		is no associated shared memory gsd.
;
;	V02-014	KDM0012		KATHLEEN D. MORSE	3-JUN-1980
;		Check that a DZRO shared memory global section is completely
;		mapped during creation and allow non-DZRO shared memory
;		global sections to be created without being mapped.
;
;	V02-013	KDM0010		KATHLEEN D. MORSE	19-MAY-1980
;		Don't search past end of shared memory bitmap for global
;		pages.
;
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;
	$DYNDEF					;DEFINE SYSTEM DATA STRUCTURES
	$GSDDEF					;GLOBAL SECTION DESCRIPTOR
	$IPLDEF					;INTERRUPT PRIORITY LEVELS
	$IRPDEF					;I/O REQUEST PACKET
	$PCBDEF					;PROCESS CONTROL BLOCK
	$PHDDEF					;PROCESS HEADER
	$PRDEF					;PRIVILEGE BITS
	$PRIDEF					;PRIORITY LEVELS
	$PSLDEF					;PROGRAM STATUS LONGWORD
	$PTEDEF					;DEFINE PAGE TABLE ENTRIES
	$SECDEF					;SECTION TABLE ENTRY
	$SHBDEF					;SHARED MEMORY CONTROL BLOCK
	$SHDDEF					;SHARED MEMORY COMMON DATA PAGE
	$SSDEF					;SYSTEM STATUS CODES
	$STATEDEF				;DEFINE EVENT STATES
	$VADEF					;VIRTUAL ADDRESS DEFINITIONS
	$WCBDEF					;DEFINE WINDOW CONTROL BLOCK

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;


	.SBTTL CLR/SET_BITMAP - CLEAR/SET BITS IN SHARED MEMORY GBL SEC BITMAP
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CLEARS/SETS THE BITS IN THE GLOBAL SECTION BITMAP
;	CORRESPONDING TO SPECIFIC PHYSICAL PAGE FRAME NUMBERS (PFN) ASSOCIATED
;	WITH A GLOBAL SECTION SPECIFIED BY A GSD.  THE GSD CONTAINS UP
;	TO #GSD$C_PFNBASMAX PIECES, EACH PIECE DESCRIBED BY TWO LONGWORDS:
;	THE RELATIVE PFN OF THE FIRST PAGE IN THE PIECE, AND A COUNT OF THE
;	NUMBER OF PAGES IN THE PIECE.  USING THIS INFORMATION, THIS ROUTINE
;	COMPUTES THE ADDRESS OF THE BITS IN THE BITMAP THAT CORRESPOND TO
;	THESE RELATIVE PFN'S.  THESE BITS ARE THEN CLEARED/SET FOR EACH PIECE OF
;	THE GLOBAL SECTION.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$SET_BITMAP
;	BSBW	MMG$CLR_BITMAP
;
; INPUT PARAMETERS:
;
;	R5 - ADDRESS OF THE SHARED MEMORY COMMON DATA PAGE
;	R6 - ADDRESS OF THE GLOBAL SECTION DESCRIPTOR
;
; IMPLICIT INPUTS:
;
;	THE GLOBAL SECTION DESCRIPTOR HAS BEEN INITIALIZED.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE CORRESPONDING BITS IN THE BITMAP ARE CLEARED/SET.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
; **********************************************************************
;
; ****************** THE FOLLOWING CODE MAY BE PAGED *******************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************

	.ENABL	LSB
MMG$SET_BITMAP::
	PUSHR	#^M<R0,R1,R2,R3,R4,R7,R8,R9,R10> ;SAVE REGISTERS
	MCOML	#0,R4				;INDICATE BITS ARE TO BE SET
	BRB	5$				;ENTER COMMON CODE

MMG$CLR_BITMAP::
	PUSHR	#^M<R0,R1,R2,R3,R4,R7,R8,R9,R10> ;SAVE REGISTERS
	CLRL	R4				;INDICATE BITS ARE TO BE CLEARED
5$:	ADDL3	R5,SHD$L_GSBITMAP(R5),R7	;GET ADR OF BITMAP
	MOVAB	GSD$L_BASPFN1(R6),R0		;GET ADR OF FIRST BASE PFN
	MOVZBL	#GSD$C_PFNBASMAX,R1		;GET # OF BASES ALLOWED IN GSD

FIND_PIECE:
	MOVL	(R0)+,R2			;GET RELATIVE BASE PFN
	MOVL	(R0)+,R3			;GET SIZE OF THIS PIECE
	BEQL	ALL_DONE			;BR ON NO MORE PIECES OF SECTION
;
; COMPUTE THE BYTE ADDRESS OF THE FIRST BIT TO CLEAR IN THE BITMAP.
;
	ASHL	#-3,R2,R10			;GET # BYTES OFFSET INTO BITMAP
	ADDL3	R7,R10,R8			;BYTE ADR OF FIRST BIT TO CLEAR
	ASHL	#3,R10,R9			;GET # OF BITS SKIPPED
	SUBL3	R9,R2,R9			;BIT OFFSET FOR FIRST BIT TO CLR
;
; LOOP CLEARING THE REMAINING BITS IN THE FIRST BYTE OF THE BITMAP TO BE
; CHANGED.
;
10$:	INSV	R4,R9,#1,(R8)			;CLEAR/SET ONE BIT OF BITMAP
	DECL	R3				;ONE LESS PAGE TO CLR BIT FOR
	BEQL	NEXT_PIECE			;BR IF NO MORE PAGES IN PIECE
	INCL	R9				;POINT TO NEXT BIT OF BYTE
	CMPB	R9,#8				;DONE WITH THIS BYTE?
	BLSS	10$				;BR ON NO, GO CLEAR ANOTHER BIT
;
; NOW DETERMINE THE NUMBER OF BYTES OF BITMAP THAT ARE TO BE TOTALLY CLEARED.
; CLEAR THESE BYTES WITH CLRB INSTRUCTIONS, THEN LOOP BACK TO CLEAR THE BITS
; AT THE END OF THE PIECE OF BITMAP WHICH DO NOT USE AN ENTIRE BYTE.
;
	INCL	R8				;POINT TO NEXT BYTE OF BITMAP
	CLRL	R9				;INDICATE FIRST BIT OF BYTE
	ASHL	#-3,R3,R10			;COMPUTE # OF BYTES TO CLEAR
	ASHL	#3,R10,R2			;COMPUTE # OF BITS CLEARED
	BEQL	25$				;BR IF NO WHOLE BYTES TO CLR
20$:	INSV	R4,R9,#8,(R8)+			;CLEAR 8 BITS OF BITMAP
	SOBGTR	R10,20$				;ONE LESS BYTE TO CLEAR
25$:	SUBL2	R2,R3				;COMPUTE # OF BITS LEFT TO CLR
	BGTR	10$				;BR TO CLEAR REMAINING BITS (<8)
;
; REPEAT CLEARING BITS FOR UP TO #GSD$C_PFNBASMAX PIECES OF SHARED MEMORY.
;
NEXT_PIECE:
	SOBGTR	R1,FIND_PIECE			;BR TO GET NEW BASE PFN AND CNT

ALL_DONE:
	POPR	#^M<R0,R1,R2,R3,R4,R7,R8,R9,R10> ;RESTORE REGISTERS
	RSB
	.DSABL	LSB

	.SBTTL	FINDGSDPFN - FIND GSD USING SPECIFIC PFN
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE TAKES A PFN AND SEARCHES THE SHARED MEMORIES TO FIND
;	THE GLOBAL SECTION THAT IS MAPPED TO THAT PFN.  IT THEN DECREMENTS THE
;	PTE REFERENCE COUNT BY ONE.  THE ROUTINE IS CALLED WHENEVER A PROCESS
;	DELETES A VIRTUAL PAGE WHICH IS MAPPED TO A SHARED MEMORY GLOBAL
;	SECTION.  NOTE:  ALL PAGES IN SHARED MEMORY ARE ASSUMED TO HAVE PFN'S
;	GREATER THAN MMG$GL_MAXPFN (THE MAXIMUM LOCAL MEMORY PFN CONTAINED IN
;	THE PFN DATA BASE).
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FINDGSDPFN
;
; INPUT PARAMETERS:
;
;	R0 - THE PFN TO BE LOCATED
;	R1 - COUNT TO DECREMENT PTE REFERENCE BY
;	     (0 FROM MMG$PTEPFNMFY)    (1 FROM MMG$DELPAG)
;
; IMPLICIT INPUTS:
;
;	THE SHARED MEMORY CONTROL BLOCKS, SHARED MEMORY COMMON DATA PAGES,
;	AND THE SHARED MEMORY GLOBAL SECTION DESCRIPTOR TABLES.
;
; OUTPUT PARAMETERS:
;
;	R4 - SHARED MEMORY CONTROL BLOCK ADDRESS (SHB)
;	R6 - GLOBAL SECTION DESCRIPTOR ADDRESS (GSD)
;
; IMPLICIT OUTPUTS:
;
;	THE PROCESSOR REFERENCE COUNT IN THE GSD THAT IS MAPPED TO THIS PFN IS
;	DECREMENTED BY ONE, IF THE GSD IS FOUND.
;
; COMPLETION CODES:
;
;	SS$_NOSUCHSEC - NO CORRESPONDING GSD FOUND FOR PFN
;	SS$_NORMAL - SUCCESSFUL DECREMENT OF GSD REF COUNT
;
; SIDE EFFECTS:
;
;	NONE
;
;--

; **********************************************************************
;
; ************** THE FOLLOWING CODE MUST BE RESIDENT *******************
;
	.PSECT	$MMGCOD
;
; **********************************************************************

MMG$FINDGSDPFN::
	.ENABL	LSB
	PUSHR	#^M<R1,R2,R3,R5,R7,R8,R10>	;SAVE REGISTERS
	PUSHL	#1				;PUSH A POSITIVE VALUE TO
	MOVL	SP,R10				;INDICATE TO MMG$VALIDATE AND
						;MMG$GETNXTGSD NOT TO USE ALL
						;SHARED MEMORIES IN SEARCH
						;JUST THE ONE PASSED IN R4,R5
	MOVL	G^EXE$GL_SHBLIST,R4		;GET FIRST SH MEM CONTROL BLOCK
	BEQL	NOT_FOUND			;BR ON NO SH MEMORIES CONNECTED
;
; A SHARED MEMORY MAY HAVE A SHARED MEMORY CONTROL BLOCK (SHB) BUT MAY NOT BE
; CONNECTED (I.E., AVAILABLE FOR USE).  THEREFORE, ONCE AN SHB IS FOUND, THE
; BIT, SHB$V_CONNECT, MUST BE SET FOR IT TO BE USED.
;
10$:	BBC	#SHB$V_CONNECT,SHB$B_FLAGS(R4),GET_NXT_SHM ;BR ON SHM DISCONCT
	MOVL	SHB$L_DATAPAGE(R4),R5		;GET ADR OF COMMON DATA PAGE
	SUBL3	SHB$L_BASGSPFN(R4),R0,R2	;GET RELATIVE PFN WITHIN MEM
	BLSS	GET_NXT_SHM			;BR IF PFN NOT IN THIS SH MEM
	CMPL	R2,SHD$L_GSPAGCNT(R5)		;IS PFN < MAX REL PFN FOR GS?
	BGTR	GET_NXT_SHM			;BR IF PFN NOT IN THIS SH MEM
;
; THE SHARED MEMORY CONTAINING THIS PFN HAS BEEN FOUND.  NOW FIND THE GSD
; WHICH IS MAPPED TO THIS PFN.
;
	ADDL3	SHD$L_GSDPTR(R5),R5,R6		;GET ADR OF FIRST GSD IN SHM TBL
	BSBW	MMG$VALIDATEGSD			;CHECK THAT GSD IS VALID
30$:	TSTL	R6				;WAS A VALID GSD FOUND?
	BEQL	NOT_FOUND			;BR ON GSD FOR PFN NOT FOUND
	MOVZBL	#GSD$C_PFNBASMAX,R3		;GET # OF MAX BASE PFN'S IN GSD
	MOVAB	GSD$L_BASPFN1(R6),R7		;GET ADR OF FIRST BASE PFN
40$:	CMPL	R2,(R7)				;IS PFN > BASE PFN?
	BLSS	50$				;BR IF PFN IS NOT IN THIS PIECE
	ADDL3	(R7),4(R7),R8			;GET PFN OF PAGE BEYOND PIECE
	BEQL	60$				;BR IF NO MORE PIECES USED
	CMPL	R2,R8				;IS PFN < LAST PAGE IN PIECE?
	BLSS	FOUND_IT			;BR IF PFN IS IN THIS PIECE
50$:	ADDL2	#8,R7				;POINT TO NEXT BASE PFN
	SOBGTR	R3,40$				;GO CHECK IF PFN IS IN NXT PIECE
60$:	BSBW	MMG$GETNXTGSD			;GET THE NEXT GSD IN SHM TBL
	BRB	30$				;GO CHECK IF PFN IS IN THIS GSD
;
; THE GSD MAPPED TO THE SPECIFIC PFN HAS BEEN FOUND.  THE PTE CORRESPONDING
; TO THIS PFN IS BEING DELETED.  THEREFORE, THE PROCESSOR REFERENCE COUNT
; IN THE GSD MUST BE DECREMENTED BY ONE. (IN OTHER WORDS, THERE WILL BE ONE
; LESS PTE MAPPED TO THIS GLOBAL SECTION)
;
FOUND_IT:
	ADDL3	#1,4(SP),R0			;GET REFCNT + LCK TO DECREMENT
	BSBW	MMG$DECSHMREF			;ONE LESS REF FOR THIS PTE
	MOVZBL	#SS$_NORMAL,R0			;SET RETURN CODE TO SUCCESS
;
; RETURN SUCCESSFULLY HERE.
;
RSB_HERE:
	ADDL2	#4,SP				;RESTORE STACK POINTER
	POPR	#^M<R1,R2,R3,R5,R7,R8,R10>	;RETURN TO CALLER
	RSB					;RETURN TO CALLER

;
; THE PFN WAS NOT WITHIN THE LAST SHARED MEMORY.  CHECK IF THERE IS ANOTHER
; SHARED MEMORY TO SEARCH.
;
GET_NXT_SHM:
	MOVL	SHB$L_LINK(R4),R4		;GET NEXT SH MEM CONTROL BLK
	BNEQ	10$				;BR IF ANOTHER MEM TO SEARCH

;
; THE PFN WAS NOT FOUND IN ANY OF THE SHARED MEMORIES.  REPORT FAILURE.
;
NOT_FOUND:
	ASSUME	SS$_NOSUCHSEC LT <^X10000>
	MOVZWL	#SS$_NOSUCHSEC,R0		;REPORT FAILURE TO FIND GSD
	BRB	RSB_HERE			;GO RETURN TO CALLER

	.DSABL	LSB

	.SBTTL	DECSHMREF/INCSHMREF - MODIFY SHARED MEMORY GSD PTE REF COUNT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE MODIFIES THE PTE REFERENCE COUNTS IN A SHARED MEMORY
;	GLOBAL SECTION DESCRIPTOR.  THERE IS ONE REFERENCE COUNT FOR EACH
;	PROCESSOR ON THE SHARED MEMORY.  THE PORT NUMBER OF THE PROCESSOR
;	IS THE INDEX TO THE CORRESPONDING REFERENCE COUNT.  THE FIRST
;	ENTRY POINT, MMG$DECSHMREF, CAUSES THE COUNT TO BE DECREMENTED
;	WHILE THE ENTRY POINT, MMG$INCSHMREF, INCREMENTS THE COUNT.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DECSHMREF
;	BSBW	MMG$INCSHMREF
;
; INPUT PARAMETERS:
;
;	R0 - THE NUMBER OF REFERENCES TO BE ADDED OR SUBTRACTED
;	R4 - ADDRESS OF THE SHARED MEMORY CONTROL BLOCK
;	R6 - ADDRESS OF THE GLOBAL SECTION DESCRIPTOR
;
; IMPLICIT INPUTS:
;
;	THE GLOBAL SECTION DESCRIPTOR HAS BEEN INITIALIZED.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE REFERENCE COUNT CORRESPONDING TO THIS PROCESSOR IS UPDATED
;	IN THE GSD.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

; **********************************************************************
;
; ************** THE FOLLOWING CODE MUST BE RESIDENT *******************
;
	.PSECT	$MMGCOD
;
; **********************************************************************

MMG$DECSHMREF::
	MNEGL	R0,R0				;NEGATE REFERENCE COUNT

MMG$INCSHMREF::
	PUSHL	R1				;SAVE REGISTER
	MOVZBL	SHB$B_PORT(R4),R1		;GET PROCESSOR PORT NUMBER
	ADDL2	R0,GSD$L_PTECNT1(R6)[R1]	;INCR REF CNT FOR CORRES PROCESSOR
	BLSS	10$				;BUGCHK IF NEGATIVE REF COUNT
	ADDL2	R0,SHB$L_REFCNT(R4)		;INCR PORT'S REF COUNT
;	BLSS	20$				;BUGCHK IF NEGATIVE REF COUNT
	NOP					;  (These should be removed
	NOP					;  and the BLSS restored after
						;  the refcnt bug is found.)
	MOVL	(SP)+,R1			;RESTORE REGISTER
	RSB					;RETURN TO CALLER

10$:	BUG_CHECK	REFCNTNEG,FATAL		;FATAL ERROR
20$:	BUG_CHECK	NEGSHBREF,FATAL		;FATAL ERROR

	.SBTTL	ALOSHMPAG - ALLOCATE PAGES GLOBAL SECTION PAGES FROM SHARED MEMORY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ACCEPTS AS INPUT THE SIZE OF THE GLOBAL SECTION TO BE
;	CREATED AND THE ADDRESS OF THE GSD WHICH DESCRIBES THE NUMBER OF
;	NON-CONTIGUOUS PIECES THAT MAY BE ALLOCATED FOR THE SECTION.  IT
;	THEN SEARCHES THE BITMAP IN THE SHARED MEMORY COMMON DATA PAGE
;	FOR THE NUMBER OF PAGES NEEDED AND STORES THE PAGES ALLOCATED IN
;	THE GSD, ALSO CLEARING THE CORRESPONDING BIT IN THE BITMAP.
;
;	THE BITMAP IS LOCKED AGAINST ACCESS BY ANY OTHER PROCESSOR DURING
;	THE ALLOCATION.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$ALOSHMPAG
;
; INPUT PARAMETERS:
;
;	R4 - ADDRESS OF THE SHARED MEMORY CONTROL BLOCK
;	R6 - ADDRESS OF THE GLOBAL SECTION DESCRIPTOR
;	R7 - COUNT OF PAGES TO BE ALLOCATED
;
; IMPLICIT INPUTS:
;
;	THE SHARED MEMORY BITMAP HAS BEEN INITIALIZED.  IT CONTAINS A BIT
;	FOR EACH PAGE TO BE USED FOR GLOBAL SECTIONS.  IF THE BIT IS SET,
;	THEN THE PAGE IS AVAILABLE FOR ALLOCATION.  IF THE BIT IS CLEAR, THE
;	PAGE IS EITHER (1) IN USE BY ANOTHER GLOBAL SECTION OR (2) IS A BAD
;	PAGE.  THE GLOBAL SECTION DESCRIPTOR CONTAINS THE NUMBER OF
;	PIECES THAT THE SECTION MAY BE BROKEN INTO.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE GSD DESCRIBES THE PAGES ALLOCATED FOR THE SECTION AND THE
;	CORRESPONDING BITS ARE CLEARED IN THE BITMAP.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - ALL PAGES FOR SECTION SUCCESSFULLY ALLOCATED
;	SS$_INSFMEM - NOT ENOUGH FREE SHARED MEMORY
;	SS$_INTERLOCK - UNABLE TO ACQUIRE BITMAP LOCK
;
; SIDE EFFECTS:
;
;	IF SUFFICIENT PAGES CANNOT BE FOUND, THE ROUTINE TO SCAN AND
;	FREE GSD'S AND DATA PAGES IS CALLED.
;
;--

; **********************************************************************
;
; ****************** THE FOLLOWING CODE MAY BE PAGED *******************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************

MMG$ALOSHMPAG::
	.ENABLE	LSB
	PUSHR	#^M<R1,R2,R3,R4,R5,R8,R9,R10,R11> ;SAVE REGISTERS
3$:	MOVZBL	#SHD$V_BITMAPLCK,R0		;BIT NUMBER OF LOCK REQUESTED
	BSBW	MMG$SHMTXLK			;GET SHM MUTEX AND BIT LOCK
						;R5=SHD ADR
	BLBC	R0,LOCK_ERR			;BR IF UNABLE TO GET BITMAP LOCK
	MOVB	SHB$B_PORT(R4),SHD$B_BITMAPLCK(R5) ;SET BITMAP LOCK OWNER
	MOVL	R7,R8				;COUNT OF PAGES REQUESTED
	MOVZBL	#GSD$C_PFNBASMAX,R4		;COUNT OF PFN BASES ALLOWED
	MOVAB	GSD$L_BASPFN1(R6),R11		;GET ADR OF FIRST BASE IN GSD
	ADDL3	R5,SHD$L_GSBITMAP(R5),R1	;VA OF GS BITMAP
	ADDL3	#7,SHD$L_GSPAGCNT(R5),R0	;COMPUTE # BITMAP BYTES, INCL
	ASHL	#-3,R0,R0			; THE LAST PARTIALLY USED BYTE
	BNEQ	NXT_PIECE			;BR TO ALLOCATE PAGES
	BRW	INSF_MEM			;BR IF NO GS PAGES AVAILABLE

LOCK_ERR:
	BRW	100$				;RETURN TO CALLER
;
; R0 = LENGTH IN BYTES OF BITMAP LEFT TO SEARCH
; R1 = BYTE ADDRESS IN BITMAP TO START SEARCHING
; R2 = BYTE ADDRESS IN BITMAP OF FIRST SET BIT
; R3 = BIT NUMBER OF FIRST SET BIT
; R4 = COUNT OF PFN BASES LEFT TO USE IN GSD
; R5 = SHARED MEMORY DATA PAGE ADDRESS
; R6 = GLOBAL SECTION DESCRIPTOR ADDRESS
; R7 = NUMBER OF PAGES REQUESTED
; R8 = NUMBER OF PAGES MORE NEEDED
; R9 = BYTE ADDRESS IN BITMAP OF FIRST CLEAR BIT
; R10 = BIT NUMBER OF FIRST CLEAR BIT
; R11 = BYTE ADDRESS IN GLOBAL SECTION DESCRIPTOR FOR NEXT PFN BASE
;

;
; THE BITMAP CONTAINS ONE BIT FOR EACH PAGE OF SHARED MEMORY ALLOCATED FOR
; GLOBAL SECTION PAGE USAGE.  A SET BIT INDICATES THAT THE PAGE MAY BE
; ALLOCATED FOR USE.  A CLEAR BIT INDICATES THAT THE PAGE IS ALREADY BEING
; USED OR IS A BAD PAGE.
;
; THE BITMAP IS SEARCHED FOR SEGMENTS OF CONTIGUOUS BITS THAT ARE SET.
; EACH PIECE OF BITMAP THAT CONTAINS CONTIGUOUS SET BITS IS DESCRIBED VIA
; FOUR REGISTERS:
;	R2 = ADDRESS OF BITMAP BYTE CONTAINING FIRST SET BIT
;	R3 = BIT NUMBER OF FIRST SET BIT WITHIN THE BYTE
;	R9 = ADDRESS OF BITMAP BYTE CONTAINING FIRST CLEAR BIT
;	R10= BIT NUMBER OF FIRST CLEAR BIT WITHIN THE BYTE
;
; THE SEARCH OF THE BITMAP FOR THESE PIECES WORKS AS FOLLOWS:
;	1. FIND THE FIRST BYTE WITH AT LEAST ONE BIT SET   (SKPC #0)
;	2. FIND THE BIT NUMBER OF THE FIRST SET BIT        (FFS)
;	3. FIND THE FIRST CLEAR BIT FOLLOWING THE SET BIT
;		A. FIRST CHECK IF THE CLEAR BIT IS IN THE
;		   SAME BYTE AS THE SET BIT; IF SO THEN    (FFC)
;		   THE PIECE IS FOUND			   (BRB GOT_PIECE)
;		B. SKIP THE BYTE CONTAINING THE FIRST SET
;		   BIT (BY RESETTING R0 AND R1)
;		C. FIND THE FIRST BYTE THAT HAS AT LEAST
;		   ONE BIT CLEAR			   (SKPC #-1)
;		D. FIND THE BIT NUMBER OF THE FIRST CLEAR
;		   BIT; THE PIECE IS FOUND		   (FFC)
;
NXT_PIECE:
	SKPC	#0,R0,(R1)			;FIND NEXT BYTE WITH A BIT SET
	BEQL	45$				;BR ON NO MORE BITS SET 
	FFS	#0,#8,(R1),R3			;FIND BIT # OF FIRST BIT SET
	MOVL	R1,R2				;SAVE ADR OF BYTE WITH BIT SET
;
; NOW FIND THE FIRST CLEAR BIT WHICH INDICATES THE END OF THIS PIECE.
;
FIND_PIECE_END:
	SUBL3	R3,#8,R10			;GET # BITS LEFT IN BYTE
	FFC	R3,R10,(R1),R10			;IS THERE A BIT CLEAR IN BYTE?
	BEQL	15$				;BR ON REST OF BITS SET IN BYTE
	MOVL	R2,R9				;SET ADR OF BYTE W/ NXT CLR BIT
	BRB	GOT_PIECE			;GO SEE IF CAN USE THIS PIECE
15$:	DECL	R0				;SKIP PAST THE BYTE WHICH
	INCL	R1				;CONTAINS THE FIRST SET BIT
	SKPC	#-1,R0,(R1)			;LOOK FOR NEXT CLR BIT IN BITMAP
	BEQL	ALL_REST_SET			;BR IF ALL OF BITMAP SET
	FFC	#0,#8,(R1),R10			;FIND BIT # OF FIRST CLR BIT
	BRB	20$				;GO SET BYTE ADR
;
; THIS CODE CAN BE ENHANCED HERE.  IT DOES NOT TAKE INTO ACCOUNT THE LAST
; BYTE OF BITMAP IF THE ENTIRE BYTE IS NOT USED.  A PIECE THAT EXTENDS TO
; THE END OF THE BITMAP WILL HAVE POINTERS THAT POINT TO THE NEXT BIT
; PAST THE END OF THE BITMAP.
;
ALL_REST_SET:
	CLRL	R10				;SAVE BIT # OF FIRST CLR BIT
20$:	MOVL	R1,R9				;SAVE ADR OF BYTE WITH BIT CLR
;
; ONCE A CONTIGUOUS PIECE OF BITMAP CONTAINING SET BITS IS FOUND, THE
; FOLLOWING INFORMATION IS IN THE REGISTERS:
;	R2 = ADDRESS OF THE BYTE IN THE BITMAP CONTAINING THE FIRST SET BIT
;	R3 = BIT NUMBER OF THE FIRST SET BIT
;	R9 = ADDRESS OF THE BYTE IN THE BITMAP CONTAINING THE FIRST CLEAR BIT
;	R10= BIT NUMBER OF THE FIRST CLEAR BIT
; THE NEXT STEP IS TO COMPUTE THE NUMBER OF PAGES CONTAINED IN THIS PIECE
; AND THE RELATIVE PFN OF THE FIRST PAGE.
;
GOT_PIECE:
	SUBL3	R2,R9,R9			;GET # BYTES WITH ALL BITS SET
	DECL	R9				;CORRECT SUBTRACTION CNT
	MULL2	#8,R9				;GET # PAGES AVAILABLE
	ADDL2	R10,R9				;ADD # PAGES BEFORE CLR BIT
	SUBL3	R3,#8,-(SP)			;GET # PAGES AFTER FIRST SET BIT
	ADDL2	(SP)+,R9			;GET TOTAL # PAGES IN PIECE
	SUBL2	SHD$L_GSBITMAP(R5),R2		;GET BYTE OFFSET TO 1ST SET BIT
	SUBL2	R5,R2				;MINUS GS PTR AND SHD ADR
	MULL2	#8,R2				;COMPUTE RELATIVE BIT # OF 1ST
	ADDL2	R3,R2				;SET BIT FROM START OF BITMAP
;
; NOW THE REGISTERS CONTAIN:
;	R2 = RELATIVE PFN OF THE FIRST PAGE IN THIS PIECE (FROM START OF BITMAP)
;	R7 = TOTAL NUMBER OF PAGES REQUESTED BY CALLER
;	R8 = NUMBER OF PAGES STILL NEEDED TO FULFILL REQUEST OF CALLER
;	     (THE PIECES ALREADY FOUND HAVE DECREMENTED THIS VALUE FROM THE
;	      VALUE CONTAINED IN R7.  REMEMBER A GLOBAL SECTION MAY BE
;	      ALLOCATED IN UP TO #GSD$C_PFNBASMAX PIECES.)
;	R9 = NUMBER OF CONTIGUOUS PAGES IN THIS PIECE
;	R1 = ADDRESS OF BYTE CONTAINING FIRST CLEAR BIT
;	R10= BIT NUMBER OF FIRST CLEAR BIT
;
	CMPL	R7,R9				;DOES ALL GS FIT IN THIS PIECE?
	BLEQ	FOUND_1_PIECE			;YES, GO USE IT
	TSTL	R8				;MORE DISCONTIG PAGES NEEDED?
	BLEQ	40$				;BR ON NO
	SOBGTR	R4,30$				;USE ONLY # OF BASES ALLOWED
	BRB	40$				;BR IF > MAX BASES ALLOWED
30$:	SUBL2	R9,R8				;USE ALL THIS PIECE
	MOVL	R2,(R11)+			;SET THIS PFN BASE IN GSD
	MOVL	R9,(R11)+			;SET SIZE OF PIECE IN GSD
;
; NOW FIND THE NEXT PIECE OF THE BITMAP WITH PAGES AVAILABLE FOR ALLOCATION.
; THIS IS DONE BY REPEATING THE SEARCH PROCESS ABOVE.  HOWEVER, THE "FIRST"
; SET BIT MAY BE WITHIN THE BYTE CONTAINING THE "LAST" CLEAR BIT.  CHECK FOR
; THIS FIRST.  IF THE NEW "FIRST" SET BIT IS WITHIN THIS BYTE, THEN CONTINUE
; ISOLATING THE PIECE BY FINDING THE NEXT CLEAR BIT (BRB FIND_PIECE_END).
; IF REST OF BITS IN BYTE ARE ALSO CLEAR, THEN UPDATE THE BITMAP SEARCH
; POINTER AND LENGTH (R1,R0) TO START THE SEARCH PAST THIS BYTE (BRB NO_BIT_SET)
; AND CONTINUE IN THE SEARCH LOOP (BRB NXT_PIECE).
;
40$:	TSTL	R0				;ANY MORE BITMAP TO SEARCH?
45$:	BEQL	END_OF_BITMAP			;BR IF NO MORE TO SEARCH
	SUBL3	R10,#8,R3			;GET # BITS AFTER CLR BIT
	FFS	R10,R3,(R1),R3			;IS THERE A SET BIT?
	BEQL	NO_BIT_SET			;BR ON NO, GO USE NEXT BYTE
	MOVL	R1,R2				;SAVE BYTE ADR OF SET BIT
	BRB	FIND_PIECE_END			;GO FIND THE END OF THIS PIECE
NO_BIT_SET:
	INCL	R1				;POINT TO NEXT BYTE OF BITMAP
	DECL	R0				;ONE LESS BYTE TO SEARCH
	BLEQ	END_OF_BITMAP			;BR ON NO MORE BITMAP TO SEARCH
	BRW	NXT_PIECE			;GO FIND NEXT PIECE
;
; NO ONE CONTIGUOUS PIECE WAS LARGE ENOUGH TO HOLD THIS GLOBAL SECTION.
; R8 CONTAINS THE NUMBER OF PAGES STILL NEEDED TO HOLD THE GLOBAL SECTION.  IF
; IT IS EQUAL TO ZERO, THEN THE SECTION WAS EXACTLY CONTAINED IN SOME NUMBER
; OF PIECES OF SHARED MEMORY.  IF IT IS LESS THAN ZERO, THEN THE LAST PIECE OF
; SHARED MEMORY USED, WAS LARGER THAN NEEDED FOR THE SECTION.  IF IT IS GREATER
; THAN ZERO, THEN THE FIRST N PIECES FOUND WERE NOT LARGE ENOUGH TO HOLD ALL OF
; THE GLOBAL SECTION (WHERE N IS THE NUMBER OF PFN BASES IN THE GSD).
;
END_OF_BITMAP:
	TSTL	R8				;MORE PAGES NEEDED?
	BGTR	INSF_MEM			;BR ON YES, FRAGMENTED MEMORY
	ADDL2	R8,-4(R11)			;SET ACTUAL SIZE OF PIECE NEEDED
	BRB	CLR_BITMAP			;BR AS GOT PAGES IN PIECES
FOUND_1_PIECE:
	MOVAB	GSD$L_BASPFN1(R6),R0		;ADR OF FIRST PFN BASE IN GSD
	MOVZBL	#GSD$C_PFNBASMAX,R1		;COUNT OF PFN BASES ALLOWED

	ASSUME GSD$L_BASCNT1 EQ <GSD$L_BASPFN1+4>

	MOVL	R2,(R0)+			;SET BASE PFN IN GSD
	MOVL	R7,(R0)+			;SET SIZE OF SECTION IN GSD
	DECL	R1				;ANY MORE BASES TO SET?
50$:	CLRQ	(R0)+				;CLEAR BASE AND COUNT
	SOBGTR	R1,50$				;REPEAT TILL ALL BASES CLEAR

CLR_BITMAP:
	BSBW	MMG$CLR_BITMAP			;CLEAR CORRESPONDING BITMAP BITS
	ASSUME	SS$_NORMAL LT <^X100>
90$:	MOVZBL	#SS$_NORMAL,R0			;REPORT SUCCESS
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),98$ ;RELEASE BITMAP LOCK
98$:	BSBW	MMG$SHMTXULK			;RELEASE SHM MUTEX
100$:	POPR	#^M<R1,R2,R3,R4,R5,R8,R9,R10,R11> ;RESTORE REGISTERS
	RSB

INSF_MEM:
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),200$ ;RELEASE BITMAP LOCK
200$:	BSBW	MMG$SHMTXULK			;RELEASE SHM MUTEX
	MOVL	<3*4>(SP),R4			;GET ADDRESS OF SHB
	BSBW	MMG$FREEGSD			;FREE UNOWNED PAGES AND GSD'S
	BLBC	R0,210$				;BR IF NOTHING WAS FREED
	BRW	3$				;TRY AGAIN TO ALLOCATE PAGES
	ASSUME	SS$_INSFMEM LT <^X10000>
210$:	MOVZWL	#SS$_INSFMEM,R0			;REPORT INSUFICIENT MEMORY
	BRB	100$				;RETURN TO USER
	.DSABL LSB

	.SBTTL	ALOSHMGSD - ALLOCATE SHARED MEMORY GLOBAL SECTION DESCRIPTOR
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES A GLOBAL SECTION DESCRIPTOR BLOCK FROM THE
;	TABLE OF GSD'S IN A SPECIFIC SHARED MEMORY.  IT ACCEPTS AS INPUT THE
;	ADDRESS OF THE SHARED MEMORY CONTROL BLOCK.  IT OUTPUTS THE ADDRESS
;	OF THE GSD ALLOCATED AND A SUCCESS CODE OR IF NO GSD IS AVAILABLE,
;	AN ERROR CODE.  THE GSD IS LOCKED FOR MODIFICATION.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$ALOSHMGSD
;
; INPUT PARAMETERS:
;
;	R4 - ADDRESS OF THE SHARED MEMORY CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	THE TABLE OF GLOBAL SECTION DESCRIPTORS IN SHARED MEMORY HAS BEEN
;	INITIALIZED.  THE CONSTANT FIELDS IN THESE DESCRIPTORS ARE ALREADY
;	INITIALIZED, ALSO.  THE SHARED MEMORY CONTROL BLOCK AND COMMON DATA
;	PAGE HAVE BEEN INITIALIZED BY CONNECTING TO THE SHARED MEMORY.
;
; OUTPUT PARAMETERS:
;
;	R0 - RETURN STATUS CODE
;	R6 - ADDRESS OF THE GLOBAL SECTION DESCRIPTOR ALLOCATED, IF SUCCESSFUL
;
; IMPLICIT OUTPUTS:
;
;	THE CONSTANT GSD FIELDS ARE ALREADY INITIALIZED AND THE GSD IS LOCKED
;	BY THE ALLOCATING PROCESSOR.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - ALL PAGES FOR SECTION SUCCESSFULLY ALLOCATED
;	SS$_GSDFULL - NO GSD AVAILABLE FOR ALLOCATION
;	SS$_EXPORTQUOTA - PORT QUOTA EXCEEDED
;
; SIDE EFFECTS:
;
;	THE GSD IS LOCKED AND NO OTHER PROCESS ON ANY PROCESSOR MAY ACCESS IT.
;
;	IF NO GSD CAN BE FOUND, FREEGSD IS CALLED TO SCAN FOR GSD'S AND DATA
;	PAGES THAT CAN BE FREED.
;
;--

MMG$ALOSHMGSD::
	.ENABLE	LSB
	PUSHR	#^M<R1,R2,R5>			;SAVE REGISTERS
3$:	MOVL	SHB$L_DATAPAGE(R4),R5		;GET ADR OF COMMON DATA PAGE
	MOVZBL	SHB$B_PORT(R4),R2		;GET PORT NUMBER
	ADAWI	#-1,SHD$W_GSDQUOTA(R5)[R2]	;ALLOC QUOTA FOR 1 CREATE
	BLSS	NO_QUOTA			;BR IF NO QUOTA AVAILABLE
	ADDL3	SHD$L_GSDPTR(R5),R5,R6		;ADR OF FIRST GSD
	BRB	20$				;GO SEE IF GSD IS UNUSED
10$:	MOVZBL	#1,R0				;ONE REF COUNT TO LOCK ENTRY
	JSB	MMG$DECSHMREF			;RELEASE LOCK ON GSD ENTRY
	MOVZWL	GSD$W_SIZE(R6),R0		;GET SIZE OF ONE GSD
	ADDL2	R0,R6				;GET ADR OF NEXT GSD
	MOVZWL	SHD$W_GSDMAX(R5),R1		;GET MAX # OF GSD'S IN TABLE
	MULL2	R1,R0				;GET SIZE OF GSD TABLE IN BYTES
	ADDL2	R5,R0				;ADD IN BASE VA FOR DATA PAGE
	ADDL2	SHD$L_GSDPTR(R5),R0		;ADD ADR OF START OF GSD TABLE
	CMPL	R6,R0				;PAST END OF GSD TABLE?
	BGEQU	NO_FREE_GSD			;BR IF PAST END OF TABLE
20$:	MOVZBL	#1,R0				;ONE REF COUNT TO LOCK ENTRY
	JSB	MMG$INCSHMREF			;LOCK ENTRY IN SHM GSD TBL
	BBS	#GSD$V_LOCKED,GSD$L_GSDFL(R6),10$ ;BR IF GSD BEING MODIFIED
	BBS	#GSD$V_VALID,GSD$L_GSDFL(R6),10$ ;BR IF GSD IS IN USE
	BBSSI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),10$ ;BR IF GSD BEING MODIFED
	INCL	SHB$L_REFCNT(R4)		;ONE FOR GSD OWNED BY THIS PORT
	MOVAB	GSD$L_BASPFN1(R6),R0		;ADR OF 1ST BASE PFN & CNT PAIR
	MOVZBL	#GSD$C_PFNBASMAX,R1		;# BASE PFN'S ALLOWED IN GSD
30$:	CLRQ	(R0)+				;CLEAR ONE BASE PFN & CNT PAIR
	SOBGTR	R1,30$				;REPEAT FOR ALL BASES
	CLRB	GSD$B_DELETPORT(R6)		;CLEAR THE DELETOR PORT #
	MOVB	SHB$B_PORT(R4),GSD$B_CREATPORT(R6) ;SET CREATOR PROCESSOR PORT #
	MOVB	SHB$B_PORT(R4),GSD$B_LOCK(R6)	;SET # OF PORT HOLDING GSD LOCK
	ASSUME	SS$_NORMAL LT <^X100>
	MOVZBL	#SS$_NORMAL,R0			;REPORT SUCCESSFUL ALLOCATION
50$:	POPR	#^M<R1,R2,R5>			;RESTORE REGISTERS
	RSB

NO_FREE_GSD:
	BSBB	MMG$FREEGSD			;FREE ABANDONED GSD'S AND PAGES
	BLBS	R0,3$				;BR IF RESOURCES WERE FREED
	ASSUME	SS$_GSDFULL LT <^X100>
	MOVZBL	#SS$_GSDFULL,R0			;REPORT NO GSD TO BE ALLOCATED
	BRB	60$				;GO RETURN QUOTA ALLOCATED

NO_QUOTA:
	MOVZWL	#SS$_EXPORTQUOTA,R0		;REPORT NO QUOTA AVAILABLE
60$:	ADAWI	#1,SHD$W_GSDQUOTA(R5)[R2]	;RETURN QUOTA ALLOCATED
	BRB	50$				;RETURN ERROR CODE TO CALLER
	.DSABL LSB

	.SBTTL	FREEGSD - FREE LOST SHARED MEMORY GLOBAL SECTION DESCRIPTORS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SCANS THE GLOBAL SECTION DESCRIPTOR BLOCKS IN THE
;	TABLE OF GSD'S IN A SPECIFIC SHARED MEMORY.  IT FREES ANY BLOCKS
;	THAT WERE CREATED BY A PROCESSOR THAT HAS BEEN REBOOTED AND ARE
;	NO LONGER ACCESSED BY ANY PROCESSOR.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FREEGSD
;
; INPUT PARAMETERS:
;
;	R4 - ADDRESS OF THE SHARED MEMORY CONTROL BLOCK
;	R5 - ADDRESS OF THE SHARED MEMORY COMMON DATA PAGE
;
; IMPLICIT INPUTS:
;
;	THE TABLE OF GLOBAL SECTION DESCRIPTORS IN SHARED MEMORY HAS BEEN
;	INITIALIZED.  THE CONSTANT FIELDS IN THESE DESCRIPTORS ARE ALREADY
;	INITIALIZED.  THE SHARED MEMORY CONTROL BLOCK AND COMMON DATA
;	PAGE HAVE BEEN INITIALIZED BY CONNECTING TO THE SHARED MEMORY.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 - RETURN STATUS CODE
;		1 IF RESOURCES WERE MADE AVAILABLE
;		0 OTHERWISE
;
; SIDE EFFECTS:
;
;	GSD'S MAY BE MADE AVAILABLE.  THE FREE PAGE BITMAP IS UPDATED.
;	R1,R2,R3 ARE DESTROYED.
;
;--

MMG$FREEGSD::
	.ENABLE	LSB
	PUSHL	R6				;SAVE REGISTERS
	CLRL	-(SP)				;ANTICIPATE FINDING NOTHING
	ADDL3	SHD$L_GSDPTR(R5),R5,R6		;ADR OF FIRST GSD
	MOVZWL	SHD$W_GSDMAX(R5),R1		;GET # OF GSD'S IN TABLE
	BRB	70$				;BEGIN GSD SCAN
10$:	BBC	#GSD$V_VALID,GSD$L_GSDFL(R6),60$ ;BR IF GSD IS NOT IN USE
	BBS	#GSD$V_LOCKED,GSD$L_GSDFL(R6),60$ ;BR IF GSD BEING MODIFIED
	BBC	#GSD$V_DELPEND,GSD$L_GSDFL(R6),60$ ;BR IF DELETE NOT PENDING
	TSTB	GSD$B_CREATPORT(R6)		;NON-EXISTENT CREATOR?
	BGEQ	60$				;BR IF CREATOR VALID
	BBSSI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),60$ ;BR IF GSD BEING MODIFIED
	MOVZBL	GSD$B_PROCCNT(R6),R2		;NUMBER OF REF COUNTS TO CHECK
	MOVAL	GSD$L_PTECNT1(R6),R0		;ADDRESS OF FIRST REF COUNT
20$:	TSTL	(R0)+				;GSD STILL IN USE?
	BNEQ	40$				;BR IF STILL IN USE
	SOBGTR	R2,20$				;ITERATE OVER ALL PORTS
	MOVZBL	#SHD$V_BITMAPLCK,R0		;NUMBER OF BIT TO LOCK
	BSBW	MMG$SHMTXLK			;ACQUIRE MUTEX AND LOCK BIT
	BLBC	R0,40$				;BR IF CAN'T LOCK BIT
	MOVB	SHB$B_PORT(R4),SHD$B_BITMAPLCK(R5) ;IDENTIFY HOLDER OF LOCK
	BSBW	MMG$SET_BITMAP			;FREE THE PAGES OF THE SECTION
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),30$ ;RELEASE BITMAP LOCK
30$:	BSBW	MMG$SHMTXULK			;RELEASE MUTEX
	BBCCI	#GSD$V_DELPEND,GSD$L_GSDFL(R6),35$ ;CLEAR DELETE PENDING
35$:	BBCCI	#GSD$V_VALID,GSD$L_GSDFL(R6),37$ ;CLEAR VALID BIT
37$:	MOVL	#1,(SP)				;FREED SOMETHING
40$:	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),60$ ;UNLOCK GSD
60$:	MOVZWL	GSD$W_SIZE(R6),R0		;GET SIZE OF ONE GSD
	ADDL2	R0,R6				;GET ADR OF NEXT GSD
70$:	SOBGEQ	R1,10$				;ITERATE OVER ALL GSD'S
	POPR	#^M<R0,R6>			;RESTORE REGISTERS AND GET STATUS
	RSB
	.DSABL LSB

	.SBTTL	FIND1STGSD - FIND THE FIRST GLOBAL SECTION TO SEARCH
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE TAKES AN INPUT STRING, BREAKS IT INTO SHARED MEMORY
;	AND GLOBAL SECTION NAMES WITH THE APPROPRIATE TRANSLATION, AND
;	RETURNS THE ADDRESS OF THE FIRST GLOBAL SECTION IN THE SEARCH PATH.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FIND1STGSD
;
; INPUT PARAMETERS:
;
;	  R6   - SYSTEM OR GROUP GLOBAL INDICATOR (1=SYSTEM, 0=GROUP)
;	 (R10) - SIZE OF SHARED MEMORY NAME (0 IF NO SH MEM NAME SPECIFIED)
;	4(R10) - ADDRESS OF ASCIC SHARED MEMORY NAME
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	IF A SHARED MEMORY IS BEING SEARCHED:
;		R4 - ADR OF SHARED MEMORY CONTROL BLOCK
;		R5 - ADR OF SHARED MEMORY COMMON DATA PAGE
;		R6 - ADR OF FIRST GSD OR 0 IF THERE IS NONE
;	IF LOCAL MEMORY IS BEING SEARCHED:
;		R4 - ADR OF LOCAL MEMORY GSD LISTHEAD
;		R6 - ADR OF FIRST LOCAL MEMORY GSD FROM LISTHEAD
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESS RETURN CODE
;	SS$_SHMNOTCNCT - SHARED MEMORY NOT CONNECTED
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$FIND1STGSD::
	BSBB	MMG$FINDSHB			;GET GS AND SHMEM NAMES
	BLBC	R0,20$				;BR ON ERROR FINDING SH MEM
	TSTL	R4				;WAS SH MEM CONTROL BLK FOUND?
	BNEQ	10$				;BR ON YES
	MOVAQ	G^EXE$GL_GSDGRPFL[R6],R4	;GET LISTHEAD FOR LOCAL MEM
	MOVL	R4,R6				;SET UP TO FIND FIRST GSD
	JSB	MMG$GETNXTGSD			;GET ADR OF FIRST LOCAL MEM GSD
	BRB	20$				;RETURN
10$:	ADDL3	SHD$L_GSDPTR(R5),R5,R6		;GET ADR OF FIRST SH MEM GSD
	JSB	MMG$VALIDATEGSD			;CHECK IF GSD IS VALID, IF NOT
						;RETURN ADDRESS OF FIRST VALID
						;GSD OR 0 IF NONE IN R6
20$:	RSB

	.SBTTL	FINDSHB - FIND SPECIFIC SHARED MEMORY CONTROL BLOCK
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SEARCHED THE SHARED MEMORY CONTROL BLOCK LIST FOR
;	A SPECIFIC SHARED MEMORY.  IF FOUND, THE ADDRESSES FOR THE CONTROL
;	BLOCK AND THE COMMON DATA PAGE FOR THAT SHARED MEMORY ARE RETURNED.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FINDSHB
;
; INPUT PARAMETERS:
;
;	 (R10) - SIZE OF SHARED MEMORY NAME (0 IF NO SH MEM NAME SPECIFIED)
;	4(R10) - ADDRESS OF ASCIC SHARED MEMORY NAME
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R4 - CONTAINS THE ADR OF THE SHARED MEMORY CONTROL BLOCK OR
;		ZERO IF NONE FOUND
;	R5 - CONTAINS THE ADR OF THE COMMON DATA PAGE FOR THE SHARED
;		MEMORY IF R4 IS NOT ZERO, OTHERWISE JUNK
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESS RETURN CODE
;	SS$_SHMNOTCNCT - SHARED MEMORY NOT CONNECTED
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$FINDSHB::
	PUSHR	#^M<R1,R2,R3>			;SAVE REGISTERS
	ASSUME	SS$_NORMAL LT <^X100>
	MOVZBL	#SS$_NORMAL,-(SP)		;ASSUME SUCCESS
	TSTL	(R10)				;IS SHARED MEM NAME SPECIFIED?
	BEQL	30$				;BR ON NO NAME
	MOVL	G^EXE$GL_SHBLIST,R4		;GET FIRST SH MEM CONTROL BLK
	BEQL	25$				;BR ON NO CONTROL BLK
10$:	BBC	#SHB$V_CONNECT,SHB$B_FLAGS(R4),20$ ;BR ON MEMORY NOT CONNECTED
	MOVL	SHB$L_DATAPAGE(R4),R5		;GET COMMON DATA PAGE ADR
	CMPC3	#16,@4(R10),SHD$T_NAME(R5)	;IS NAME STRING THE SAME?
	BEQL	40$				;RETURN SHB FOUND
20$:	MOVL	SHB$L_LINK(R4),R4		;GET NEXT SHB
	BNEQ	10$				;GO TRY TO MATCH SH MEM NAME
	ASSUME	SS$_SHMNOTCNCT LT <^X10000>
25$:	MOVZWL	#SS$_SHMNOTCNCT,(SP)		;REPORT SH MEM SHB NOT FOUND
30$:	CLRL	R4				;INDICATE SH MEM NOT FOUND
40$:	POPL	R0				;GET RETURN STATUS CODE
	POPR	#^M<R1,R2,R3>			;RESTORE REGISTERS
	RSB					;RETURN SHB ADR


	.SBTTL	GETNXT/VALIDATEGSD - GET NEXT VALID GLOBAL SECTION DESCRIPTOR
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE FINDS THE NEXT SEQUENTIAL GLOBAL SECTION DESCRIPTOR.
;	IF LOCAL MEMORY GSD'S ARE BEING SEARCHED, THEN THE "NEXT" GSD IS
;	FOUND BY THE FORWARD LINK, GSD$L_GSDFL.  IF THERE ARE NO MORE
;	LOCAL MEMORY GSD'S, THEN THE SHARED MEMORIES ARE SEARCHED FOR
;	THE NEXT GSD.  IF A SPECIFIC SHARED MEMORY IS BEING SEARCHED, I.E.,
;	THE SHARED MEMORY NAME DESCRIPTOR HAS A COUNT GREATER THAN ZERO,
;	THEN THE NEXT PHYSICALLY CONSECUTIVE GSD IS TESTED TO SEE IF IT
;	IS VALID.  IF THERE ARE NO MORE VALID GSD'S IN THE SPECIFIC
;	SHARED MEMORY REQUESTED, THE OTHER SHARED MEMORIES ARE NOT SEARCHED.
;	INSTEAD, AN ERROR CODE INDICATING NO MORE GSD'S IS RETURNED.
;
;	THE SHARED MEMORY NAME DESCRIPTOR COUNT IS SET TO MINUS ONE IF
;	THE END OF THE GSD LIST IN LOCAL MEMORY WAS REACHED AND THE SEARCH
;	IS NOW BEING EXTENDED INTO THE SHARED MEMORIES.
;
;	THE SECOND ENTRY POINT, MMG$VALIDATEGSD, IS CALLED WHEN THE FIRST
;	GSD HAS BEEN LOCATED IN THE SHARED MEMORY GSD TABLE.  IT IS USED
;	TO VALIDATE THAT THE GSD "IN HAND" IS A VALID GSD.  IF IT IS NOT
;	A VALID GSD, THEN THE ROUTINE PROCEEDS TO FIND THE FIRST VALID
;	GSD IN THE SHARED MEMORY TABLE JUST AS DESCRIBED ABOVE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$GETNXTGSD
;	BSBW	MMG$VALIDATEGSD
;
; INPUT PARAMETERS:
;
;	R6 - ADR OF LAST GSD FOUND WITH THIS SCAN
;	R10 - ADR OF STRING DESCRIPTOR FOR SHARED MEMORY NAME
;		STRING SIZE IS ZERO IF NO SHARED MEMORY NAME SPECIFIED
;		STRING SIZE IS -1 IF LOCAL MEMORY SEARCH HAS EXTENDED INTO
;			SEARCHING A SHARED MEMORY.
;	IF SHARED MEMORY SEARCH:
;		R4 - ADR OF SHARED MEMORY CONTROL BLOCK
;		R5 - ADR OF SHARED MEMORY COMMON DATA PAGE
;	IF LOCAL MEMORY SEARCH:
;		R4 - ADR OF LOCAL MEMORY GSD LISTHEAD
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R6 - ADR OF NEXT SEQUENTIAL GSD OR ZERO IF NO NEXT GSD
;
; IMPLICIT OUTPUTS:
;
;	IF LOCAL MEMORY SEARCH EXTENDS INTO SHARED MEMORY:
;		R4 - ADR OF SHARED MEMORY CONTROL BLOCK
;		R5 - ADR OF SHARED MEMORY COMMON DATA PAGE
;		4(R10) - SHARED MEMORY NAME SIZE IS SET TO -1
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

; **********************************************************************
;
; ************** THE FOLLOWING CODE MUST BE RESIDENT *******************
;
	.PSECT	$MMGCOD
;
; **********************************************************************

	.ENABL	LSB
MMG$VALIDATEGSD::
	PUSHR	#^M<R0,R1>			;REMEMBER REGISTER
	BRB	15$				;GO VALIDATE GSD "IN HAND"

MMG$GETNXTGSD::
	PUSHR	#^M<R0,R1>			;REMEMBER REGISTER
	TSTL	(R10)				;IS THIS A SHARED MEM SEARCH?
	BNEQ	20$				;BR IF SEARCHING SHARED MEMORY
	MOVL	GSD$L_GSDFL(R6),R6		;GET NEXT LOCAL MEMORY GSD
	CMPL	R4,R6				;IS THIS BACK TO LISTHEAD?
	BNEQ	70$				;NO, BR TO RETURN NEXT GSD

;
; DEFAULT SEARCH OVERFLOW FROM LOCAL MEMORY INTO SHARED MEMORY.
;
	MOVL	G^EXE$GL_SHBLIST,R4		;GET PTR TO SH MEM CONTROL BLK
10$:	BEQL	60$				;BR ON NO SHARED MEMORY
	BBC	#SHB$V_CONNECT,SHB$B_FLAGS(R4),60$ ;BR IF SH MEM NOT CONNECTED
	MOVL	SHB$L_DATAPAGE(R4),R5		;GET ADR OF COMMON DATA PAGE
	MNEGL	#1,(R10)			;INDICATE DEFAULT SH MEM SEARCH
	ADDL3	SHD$L_GSDPTR(R5),R5,R6		;GET FIRST GSD ADR
15$:	MOVZWL	GSD$W_SIZE(R6),R0		;GET SIZE OF SHMEM GSD
	BRB	30$				;GO CHECK VALIDITY OF GSD

;
; FIND NEXT SHARED MEMORY GSD IN TABLE.  SHARED MEMORY GSD'S ARE CONTAINED
; IN A TABLE AND ARE NOT LINKED VIA FORWARD AND BACKWARD LINKS.
;
20$:	MOVZBL	#1,R0				;ONE REF COUNT FOR A LOCK
	BSBW	MMG$DECSHMREF			;RELEASE THE PREVIOUS GSD LOCK
	MOVZWL	GSD$W_SIZE(R6),R0		;GET SIZE OF SHMEM GSD
	ADDL2	R0,R6				;POINT TO NEXT GSD
30$:	MOVZWL	SHD$W_GSDMAX(R5),R1		;GET MAX # GSD'S IN TABLE
	MULL2	R0,R1				;FIND SIZE OF GSD TABLE
	ADDL2	R5,R1				;ADD IN BASE VA
	ADDL2	SHD$L_GSDPTR(R5),R1		;COMPUTE ADR OF END OF TABLE
	BRB	50$				;SKIP OFFSETING TO NEXT GSD
40$:	MOVZWL	GSD$W_SIZE(R6),R0		;GET SIZE OF ONE SHMEM GSD
	ADDL2	R0,R6				;GET ADR OF NEXT GSD
50$:	CMPL	R6,R1				;PAST END OF GSD TABLE?
	BGEQU	80$				;BR IF YES, PAST LAST GSD
	MOVZBL	#1,R0				;ONE REF COUNT FOR A LOCK
	BSBW	MMG$INCSHMREF			;LOCK THE GSD
	BBS	#GSD$V_VALID,GSD$L_GSDFL(R6),70$ ;BR IF CAN READ GSD, RETURN IT
	MOVZBL	#1,R0				;ONE REF COUNT FOR A LOCK
	BSBW	MMG$DECSHMREF			;RELEASE THIS GSD LOCK
	BRB	40$				;BR TO FIND NEXT GSD
60$:	CLRL	R6				;INDICATE NO MORE GSD'S
70$:	POPR	#^M<R0,R1>			;RESTORE REGISTER
	RSB					;RETURN WITH NEXT GSD ADR
80$:	TSTL	(R10)				;SEARCHING SPECIFIC SH MEM?
	BGEQ	60$				;BR ON YES, DON'T SEARCH OTHERS
	MOVL	SHB$L_LINK(R4),R4		;GET NEXT SH MEM CONTROL BLK
	BRB	10$				;GO SHECK SHB VALIDITY

	.DSABL	LSB

	.SBTTL	GETGSNAM - GET GLOBAL SECTION NAME AND SHARED MEMORY NAME
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TAKES AN INPUT STRING WHICH MAY BE A GLOBAL SECTION NAME, A
; LOGICAL NAME, OR A SHARED MEMORY NAME AND A GLOBAL SECTION NAME.  IF THE
; STRING IS SUFFIXED WITH "_nnn" (AN UNDERSCORE FOLLOWED BY THREE DIGITS)
; THE SUFFIX IS REMOVED.  THEN THE STRING IS SUBMITTED FOR LOGICAL NAME
; TRANSLATION AND SEPARATION INTO GLOBAL SECTION NAME AND SHARED MEMORY NAME.
; THE SUFFIX IS APPENDED ONTO THE RESULTANT GLOBAL SECTION NAME.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$GETGSNAM
;
; INPUT PARAMETERS:
;
;	R9 - ADR OF STRING DESCRIPTOR FOR INPUT STRING FROM USER
;	R10 - ADR OF STRING DESCRIPTOR FOR RETURNED SHARED MEMORY NAME
;	R11 - ADR OF STRING DESCRIPTOR FOR RETURNED GLOBAL SECTION NAME
;
; IMPLICIT INPUTS:
;
;	THE INPUT STRING DESCRIPTOR POINTS TO THE STRING TO BE TRANSLATED.
;	THE OUTPUT STRING DESCRIPTORS ARE SET TO DESCRIBE THE SIZE AND
;	ADDRESS OF THE OUTPUT BUFFERS.
;
; OUTPUT PARAMETERS:
;
;	R0 CONTAINS THE STATUS CODE FOR THE TRANSLATION.
;
; IMPLICIT OUTPUTS:
;
;	THE SHARED MEMORY AND GLOBAL SECTION NAMES ARE ENTERED IN THE 
;	BUFFERS DESCRIBED BY THE INPUT STRING DESCRIPTORS.  THE DESCRIPTORS
;	ARE UPDATED.  IF AN ERROR CODE IS RETURNED, THE DESCRIPTORS ARE
;	NOT VALID.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFUL COMPLETION
;	SS$_IVLOGNAM - NAME TOO LARGE FOR USER BUFFER
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAME TRANSLATIONS
;
; SIDE EFFECTS:
;
;	NONE
;
;--

; **********************************************************************
;
; ****************** THE FOLLOWING CODE MAY BE PAGED *******************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************

MMG$GETGSNAM::
	PUSHR	#^M<R1,R9>			;SAVE REGISTERS
	PUSHL	4(R9)				;BUILD AN INPUT NAME STRING
	MOVZWL	(R9),-(SP)			;DESCRIPTOR THAT CAN BE MODIFIED
	MOVL	SP,R9				;SET ADR OF INPUT NAME STR DSC
	SUBL3	#4,(R9),R0			;GET STR SIZE MINUS SUFFIX
	BLEQ	10$				;BR IF STRING HAS NO SUFFIX
	ADDL2	4(R9),R0			;GET ADR OF SUFFIX
	CMPB	#^A/_/,(R0)			;IS THIS A SUFFIX?
	BNEQ	10$				;BR ON NO
	MOVZBL	#3,R1				;SIZE OF SUFFIX
5$:	CMPB	(R0)[R1],#^A/0/			;IS CHARACTER LESS THAN "0"?
	BLSSU	10$				;BR ON SUFFIX NOT NUMERIC
	CMPB	(R0)[R1],#^A/9/			;IS CHARACTER GREATER THAN "9"?
	BGTRU	10$				;BR ON SUFFIX NOT NUMERIC
	SOBGTR	R1,5$				;REPEAT TO CHECK ALL OF SUFFIX
	PUSHL	(R0)				;REMEMBER THE SUFFIX
	SUBL2	#4,(R9)				;SUBTRACT OFF THE SUFFIX
	BRB	20$				;GO TRANSLATE NAME
10$:	PUSHL	#0				;INDICATE NO SUFFIX
20$:	PUSHL	(R11)				;REMEMBER SIZE OF GS BUFFER
	BSBB	MMG$GSDTRNLOG			;TRANSLATE LOGICAL NAME
	BLBC	R0,50$				;BR IF ERR TRANSLATING NAME
	TSTL	4(SP)				;WAS THERE A SUFFIX?
	BEQL	50$				;BR IF NONE TO APPEND
	ADDL3	#4,(R11),R1			;GET NEW SIZE OF GS
	CMPL	(SP)+,R1			;IS BUFFER TOO SMALL FOR SUFFIX?
	BLSS	40$				;BR ON YES
	ADDL3	(R11),4(R11),R1			;GET ADR FOR SUFFIX
	MOVL	(SP)+,(R1)			;PUT SUFFIX ON END OF STRING
	BEQL	30$				;BR IF NO SUFFIX
	ADDL2	#4,(R9)				;ADD IN LENGTH OF SUFFIX
	ADDL2	#4,(R11)			;ADD IN LENGTH OF SUFFIX
30$:	ADDL2	#<4*2>,SP			;CLEAN STR DSC OFF STACK
	POPR	#^M<R1,R9>			;RESTORE REGISTERS
	RSB					;RETURN
	ASSUME	SS$_IVLOGNAM LT <^X10000>
40$:	MOVZWL	#SS$_IVLOGNAM,R0		;REPORT BUFFER TOO SMALL
	TSTL	(SP)+				;CLEAN OFF SUFFIX
	BRB	30$				;GO RETURN
50$:	ADDL2	#<4*2>,SP			;CLEAN SUFFIX AND CNT OFF
	BRB	30$				;JOIN COMMON CODE

	.SBTTL	GSDTRNLOG/MBXTRNLOG - GS/MBX LOGICAL NAME TRANSLATION

;++
; FUNCTIONAL DESCRIPTION:
;
; MMG$GSDTRNLOG TRANSLATES LOGICAL NAMES FOR GLOBAL SECTIONS.  THE OTHER
; ENTRY POINTS, MMG$MBXTRNLOG AND MMG$MBXTRNLOG, TRANSLATE LOGICAL NAMES FOR
; MAILBOXES AND COMMON EVENT FLAG CLUSTERS, RESPECTIVELY.  THE ONLY DIFFERENCE
; BETWEEN THE THREE TRANSLATIONS IS THE PREFIX ADDED TO THE LOGICAL NAME BEFORE
; IT IS TRANSLATED. THE PREFIX FOR GLOBAL SECTIONS IS "GBL$", FOR MAILBOXES
; "MBX$", AND FOR COMMON EVENT FLAGS "CEF$".  THE LOGICAL NAME TRANSLATION
; PROCEEDS IN THE AS FOLLOWS.  THE STRING IS FIRST SEARCHED FOR A COLON.
; EVERYTHING TO THE RIGHT OF THE COLON IS PLACED IN THE GLOBAL SECTION/MAILBOX/
; COMMON EVENT FLAG NAME BUFFER.  EVERYTHING TO THE LEFT OF THE COLON (OR THE
; ENTIRE STRING IF THERE IS NO COLON), IS SUFFIXED TO "GBL$"/"MBX$"/"CEF$" AND
; SUBMITTED FOR LOGICAL NAME TRANSLATION.  THIS PROCESS IS REPEATED ON THE
; RESULT OF THE TRANSLATION, WITH PIECES TO THE RIGHT OF THE FIRST COLON BEING
; PUT ON THE FRONT OF THE GLOBAL SECTION/MAILBOX/COMMON EVENT FLAG NAME AND
; STRINGS TO THE LEFT OF THE COLON RE-SUBMITTED FOR TRANSLATION.  IF EITHER THE
; GLOBAL SECTION/MAILBOX/COMMON EVENT FLAG BUFFER OR THE SHARED MEMORY BUFFER
; IS TOO SMALL TO HOLD THE CORRESPONDING NAME, AN ERROR CODE OF SS$_IVLOGNAM
; IS RETURNED IN R0.  IF THE TRANSLATION EXCEEDS TEN REPETITIONS, SS$_TOOMANYLNAM
; IS RETURNED.  THE STRING "GBL$"/"MBX$"/"CEF$" IS NOT RETURNED TO THE USER AS
; PART OF EITHER NAME BUT IS PREFIXED TO EACH STRING SUBMITTED FOR TRANSLATION.
;
; IF ANY LOGICAL NAME IS PREFIXED BY AN UNDERSCORE, IT IS NOT SUBMITTED FOR
; LOGICAL NAME TRANSLATION.  THE UNDERSCORE IS STRIPPED FROM THE NAME AND IT
; IS BROKEN INTO GLOBAL SECTION/MAILBOX/COMMON EVENT FLAG AND SHARED MEMORY
; NAMES AS DESCRIBED ABOVE.
;
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$GSDTRNLOG
;	BSBW	MMG$MBXTRNLOG
;	BSBW	MMG$CEFTRNLOG
;
; INPUT PARAMETERS:
;
;	R9 - ADR OF STRING DESCRIPTOR FOR INPUT STRING FROM USER
;	R10 - ADR OF STRING DESCRIPTOR FOR RETURNED SHARED MEMORY NAME
;	R11 - ADR OF STRING DESCRIPTOR FOR RETURNED GLOBAL SECTION/
;		MAILBOX/COMMON EVENT FLAG CLUSTER NAME
;
; IMPLICIT INPUTS:
;
;	THE INPUT STRING DESCRIPTOR POINTS TO THE STRING TO BE TRANSLATED.
;	THE OUTPUT STRING DESCRIPTORS ARE SET TO DESCRIBE THE SIZE AND
;	ADDRESS OF THE OUTPUT BUFFERS.
;
; OUTPUT PARAMETERS:
;
;	R0 CONTAINS THE STATUS CODE FOR THE TRANSLATION.
;
; IMPLICIT OUTPUTS:
;
;	THE SHARED MEMORY AND GLOBAL SECTION/MAILBOX/COMMON EVENT FLAG NAMES
;	ARE ENTERED IN THE BUFFERS DESCRIBED BY THE INPUT STRING DESCRIPTORS.
;	THE DESCRIPTORS ARE UPDATED.  IF AN ERROR CODE IS RETURNED, THE
;	DESCRIPTORS ARE NOT VALID.  IF EITHER NAME IS NOT FOUND, THE SIZE
;	FIELD IN THE DESCRIPTOR IS SET TO ZERO.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFUL COMPLETION
;	SS$_IVLOGNAM - NAME TOO LARGE FOR USER BUFFER
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAME TRANSLATIONS
;
; SIDE EFFECTS:
;
;	THIS ROUTINE ASSUMES UPPDER WORD IN RETURN STRING DESCRIPTORS IS 0.
;
;--

	.ENABLE	LSB
MMG$CEFTRNLOG::
	MOVL	#^A/CEF$/,R0			;SET INDICATOR TO USE "CEF$"
	BRB	10$				;SKIP OTHER PREFIXES

MMG$MBXTRNLOG::
	MOVL	#^A/MBX$/,R0			;SET INDICATOR TO USE "MBX$"
	BRB	10$				;SKIP OTHER PREFIXES

MMG$GSDTRNLOG::
	MOVL	#^A/GBL$/,R0			;SET INDICATOR TO USE "GBL$"
10$:	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;SAVE REGISTERS
	MOVPSL	-(SP)				;REMEMBER PREVIOUS MODE
	CLRL	-(SP)				;SET INDICATOR TO NO : FOUND
	MOVAB	-<<2+17+2+17>*4>(SP),SP		;2 BUFFERS AND 2 DESCRIPTORS
	MOVL	SP,R6				;ADR OF INPUT DESCRIPTOR
	MOVAB	8(SP),R7			;ADR OF RESULTANT DESCRIPTOR
	MOVZBL	#64,(R7)			;SIZE OF RESULTANT BUFFER
	MOVAB	84(SP),4(R7)			;ADR OF RESULTANT BUFFER
	MOVAB	16(SP),4(R6)			;ADR OF INPUT BUFFER
	MOVL	R0,@4(R6)			;INSERT PREFIX IN INPUT BUFFER
	MOVL	R0,@4(R7)			;INSERT PREFIX IN RESULT BUFFER
	ADDL2	#4,4(R7)			;POINT PAST RESULT "GBL$"

;
; R6 - ADDRESS OF STRING DESCRIPTOR FOR INPUT STRING TO BE TRANSLATED
; R7 - ADDRESS OF STRING DESCRIPTOR FOR RESULTANT TRANSLATED STRING
; (SP) - ADDRESS OF STRING DESCRIPTOR FOR INPUT STRING
; 8(SP) - ADDRESS OF STRING DESCRIPTOR FOR RESULTANT TRANSLATED STRING
; 16(SP) - BUFFER FOR INPUT STRING
; 84(SP) - BUFFER FOR RESULTANT TRANSLATED STRING
; 152(SP) - INDICATOR IF STRING CONTAINED A COLON
;

;
; R9 - ADDRESS OF STRING DESCRIPTOR FOR INPUT STRING FROM USER
; R10 - ADDRESS OF STRING DESCRIPTOR FOR OUTPUT SHARED MEMORY NAME
; R11 - ADDRESS OF STRING DESCRIPTOR FOR OUTPUT GLOBAL SECTION NAME
;

	MOVZWL	(R11),R8			;REMEMBER SIZE OF BUFFER
	ADDL2	#4,4(R6)			;GET ADR FOR LOGICAL NAME
	MOVZWL	(R9),(R6)			;GET SIZE OF LOGICAL NAME
	CMPL	#64,(R6)			;VALID LOGICAL NAME SIZE?
	BLSS	15$				;BR IF NAME SIZE TOO LARGE
	MOVC3	(R6),@4(R9),@4(R6)		;STORE INPUT STRING TO TRANSLATE
	MOVC5	#0,(R11),#0,R8,@4(R11)		;ZERO FILL GLOBAL SYMBOL BUFFER
	CLRL	(R11)				;ZERO SIZE OF GS NAME
	LOCC	#^A/:/,(R6),@4(R6)		;ARE BOTH NAMES SPECIFIED?
	MOVL	R0,152(SP)			;REMEMBER IF : EXISTED OR NOT
	BEQL	NO_COLON			;BR ON GS NAME ONLY

;
; R0 - # OF BYTES IN GLOBAL SECTION NAME PLUS THE COLON
; R1 - ADDRESS OF COLON
;

	SUBL3	#1,R0,(R11)			;GET SIZE OF GS NAME
	SUBL2	R0,R8				;WILL NAME FIT INTO BUFFER?
	BGEQ	20$				;BR IF NAME FITS IN BUFFER
15$:	CLRL	-(SP)				;SET STACK PTR FOR CLEAN-UP
	BRW	NAME_TOO_LONG			;NO, BR ON ERROR, INVALID NAME
20$:	MOVC3	(R11),1(R1),@4(R11)		;MOVE GS NAME TO OUTPUT BUFFER
	SUBL2	152(SP),(R6)			;GET SIZE OF LOGICAL NAME

NO_COLON:
	ADDL2	#4,(R6)				;ADD IN "GBL$" STRING SIZE
	SUBL2	#4,4(R6)			;POINT TO START OF "GBL$"
	PUSHL	#10				;SET TRANSLATION LOOP COUNT
	MOVL	4(R6),R0			;GET ADR OF LOGICAL NAME
	CMPB	#^A/_/,4(R0)			;IS FIRST CHARACTER AN _ ?
	BNEQ	TRANSLATE_LOOP			;BR IF NO _ FOUND, GO TRANSLATE
	BRW	DONT_TRANSLATE			;BR IF IS _, DON'T TRANSLATE IT

TRANSLATE_LOOP:
	PUSHR	#^M<R1,R2,R3,R4,R5>		;SAVE REGISTERS
;
; THE ROUTINE THAT TRANSLATES LOGICAL NAMES DOES A PROBE FROM THE PREVIOUS
; MODE (I.E., PROBABLY USER) INTO THE BUFFER CONTAINING THE NAME TO BE
; TRANSLATED.  THE BUFFER IS ON THE KERNEL STACK FOR $CRMPSC AND $MGBLSC AND
; CANNOT BE ACCESSED FROM USER MODE.  THEREFORE, THE PREVIOUS MODE MUST BE
; CHANGED TO KERNEL, TOO.  THIS IS DONE BY PUTTING A PC-PSL PAIR ON THE STACK
; AND DOING AN REI.
;
	MOVPSL	-(SP)				;GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,(SP),R0 ;GET CURRENT MODE
	INSV	R0,#PSL$V_PRVMOD,#PSL$S_PRVMOD,(SP) ;SET PREV MODE TO CUR MODE
	BSBB	REI_RTN				;FORCE PREV MODE TO BE CUR MODE
;
; THIS ROUTINE IS CALLED IN AT LEAST TWO WAYS:  (1) BY $CRMPSC, $MGBLSC, ETC.
; IN KERNEL MODE WHILE THE GSD MUTEX IS HELD, AND (2) BY SYSIMGSTA, FROM USER
; MODE WHEN MAPPING A LOCAL COPY OF THE DEBUGGER.  FROM USER MODE, THE SYSTEM
; SERVICE $TRNLOG MUST BE CALLED TO DO THE TRANSLATION.  FROM KERNEL MODE,
; THE INTERNAL ENTRY POINT LOG$TRNSLOGNAME MUST BE CALLED.
;
	CMPL	#PSL$C_KERNEL,R0		;IS CURRENT MODE KERNEL?
	BEQL	25$				;BR IF IT IS KERNEL MODE
	$TRNLOG_S -				;TRANSLATE LOGICAL NAME
		LOGNAM=(R6),-			;ADR OF INPUT STRING DESC
		RSLLEN=(R7),-			;ADR OF RETURNED STRING LENGTH
		RSLBUF=(R7)			;ADR OF RESULT STRING DESC
	BRB	26$				;SKIP THE KERNEL MODE CALL
REI_RTN:
	REI					;THIS WILL ALLOW A NEW MODE
						;TO BE SET FROM THE STACK
25$:	MOVL	R6,R1				;SET ADR OF LOG NAME STG DESC
	MOVL	(R7),R2				;SET SIZE OF RESULT STG BUFFER
	MOVL	4(R7),R3			;SET ADR OF RESULT STG BUFFER
	MOVL	G^SCH$GL_CURPCB,R4		;SET CURRENT PROCESS PCB ADR
	CLRL	R5				;INDICATE NO NAME TBL SEARCH MSK
	BSBW	LOG$TRNSLOGNAME			;TRANSLATE LOGICAL NAME
26$:	MOVL	R1,(R7)				;SET RESULT STR LNG IN STR DESC
	POPR	#^M<R1,R2,R3,R4,R5>		;RESTORE REGISTERS

	ASSUME	SS$_NORMAL LT <^X100>
	CMPB	S^#SS$_NORMAL,R0		;SUCCESSFUL TRANSLATION?
	BNEQ	50$				;BR ON UNSUCCESSFUL
	PUSHL	4(R6)				;REMEMBER BUFFER ADDRESS
	MOVQ	(R7),(R6)			;MAKE INPUT DESC BE RESULT DESC

	LOCC	#^A/:/,(R7),@4(R7)		;ARE THERE NOW TWO NAMES?
	SUBL2	R0,(R6)				;GET SIZE OF NEW LOGICAL NAME
	BNEQ	30$				;BR IF LOG NAME EXISTS
	ADDL3	#1,R0,160(SP)			;TREAT ":GSNAM" LIKE : NOT THERE
	DECL	R1				;PNT JUST BEFORE COLON
	BRB	40$				;GOING TO MOVE : INTO GS NAME
30$:	MOVL	R0,160(SP)			;REMEMBER IF : EXISTED OR NOT
	BEQL	CONT_TRANS			;BRANCH ON NO
	DECL	R0				;GET SIZE OF GS MINUS COLON
40$:	SUBL2	R0,R8				;IS OUTPUT BUFFER LARGE ENOUGH?
	BLSS	NAME_TOO_LONG2			;BR ON NAME SIZE > BUFFER SIZE
	ADDL3	4(R11),R0,R2			;GET ADR OF BYTE PAST NEW PIECE
	PUSHL	R1				;REMEMBER ADR OF :
	MOVC3	(R11),@4(R11),(R2)		;SHIFT PREV GS PIECE LEFT
	POPL	R1				;RESTORE ADR OF :
	SUBL3	#1,160(SP),R0			;GET SIZE OF NEW PIECE OF GS
	ADDL2	R0,(R11)			;ADD IN SIZE OF NEW PIECE OF GS
	MOVC3	R0,1(R1),@4(R11)		;MOVE IN NEW PIECE OF GS

CONT_TRANS:
	ADDL3	#4,(SP)+,4(R7)			;POINT RESULT BUF PAST "GBL$"
	MOVZBL	#64,(R7)			;SET SIZE OF RESULT BUFFER
	TSTL	(R6)				;IS THERE A LOGICAL NAME TO TRAN
	BEQL	90$				;BR ON NO
	ADDL2	#4,(R6)				;ADD "GBL$" SIZE TO INPUT STRING
	CMPB	#^A/_/,@4(R6)			;CHECK IF STRING STARTS WITH _
	BEQL	DONT_TRANSLATE1			;BR AND DON'T TRANSLATE IF HAS _
	SUBL2	#4,4(R6)			;MOVE PTR TO INCLUDE "GBL$"
	DECL	(SP)				;ONE MORE TRANSLATION DONE
	BLEQ	45$				;BR IF LOG NAM DEPTH TOO GREAT
	BRW	TRANSLATE_LOOP			;REPEAT UP TO 10 TRANSLATIONS
	ASSUME	SS$_TOOMANYLNAM LT <^X10000>
45$:	MOVZWL	#SS$_TOOMANYLNAM,R0		;LOGICAL NAME ERROR IF TOO MANY
	BRB	100$				;RETURN FAILURE CODE
						;TO BE SET FROM THE STACK
NAME_TOO_LONG2:
	POPL	R0				;CLEAN BUFFER ADR OFF STACK
NAME_TOO_LONG:
	ASSUME	SS$_IVLOGNAM LT <^X10000>
	MOVZWL	#SS$_IVLOGNAM,R0		;REPORT INVALID LOGICAL NAME
	BRB	100$				;RETURN FAILURE CODE
	ASSUME	SS$_NOTRAN LT <^X10000>
50$:	CMPW	#SS$_NOTRAN,R0			;WAS THERE NO TRANSLATION?
	BNEQ	100$				;BR ON SOME OTHER ERROR
	BRB	60$				;GO MOVE NAME INTO RETURN BUFFER
DONT_TRANSLATE1:
	SUBL2	#4,4(R6)			;PNT TO INCLUDE PREFIX "GBL$"
DONT_TRANSLATE:
	DECL	(R6)				;SUBTRACT 1 FOR _ OFF NAME SIZE
	INCL	4(R6)				;ADD 1 FOR _ TO NAME ADR
60$:	TSTL	(R11)				;IS THERE ANY GSD NAME?
	BNEQ	80$				;IF YES, THEN GO SET MEMORY NAME
	CLRL	(R10)				;REPORT NO MEMORY NAME FOUND
	TSTL	156(SP)				;SEE IF : SHOULD BE ON NAME
	BEQL	70$				;BR ON NO, NOT IN ORIGINAL NAME
	INCL	(R6)				;ADD ONE FOR LENGTH OF :
70$:	PUSHL	R11				;SWITCH THE GS AND MEMORY NAME
	MOVL	R10,R11				;POINTERS SO THAT WE STORE THE
	POPL	R10				;STRING AS THE GLOBAL SEC NAME
	MOVL	R8,(R10)			;RESTORE SIZE OF GS BUFFER
80$:	SUBL2	#4,(R6)				;SUBTRACT "GBL$" SIZE OFF
	CMPL	(R10),(R6)			;NAME SIZE < BUFFER SIZE?
	BLSS	NAME_TOO_LONG			;NO, WON'T FIT IN BUFFER
	ADDL2	#4,4(R6)			;POINT PAST "GBL$"
	MOVC5	(R6),@4(R6),#0,(R10),@4(R10)	;MOVE NAME TO OUTPUT BUF
	MOVL	(R6),(R10)			;MOVE IN SIZE OF NAME
	ASSUME	SS$_NORMAL LT <^X100>
90$:	MOVZBL	S^#SS$_NORMAL,R0		;REPORT SUCCESSFUL TRANSLATION
100$:	MOVAB	<<1+1+2+17+2+17>*4>(SP),SP	;GET RID OF TEMPORARY BUFFERS
	BSBW	REI_RTN				;RESTORE PREVIOUS MODE FOR MBX'S
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;RESTORE REGISTERS
	RSB
	.DSABL	LSB

	.SBTTL	MMG$READ_GSD/MMG$WRITE_GSD - READ/WRITE SHARED MEM GBL SECTION

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE READS THE PAGES OF A GLOBAL SECTION BEING CREATED INTO
; SHARED MEMORY OR WRITES THE PAGES BACK TO A DISK FILE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$READ_GSD
;	BSBW	MMG$WRITE_GSD
;
; INPUT PARAMETERS:
;
;	R6 = GLOBAL SECTION DESCRIPTOR ADDRESS
;	R2 = STARTING VIRTUAL ADDRESS INTO WHICH SECTION IS MAPPED
;		(MMG$READ_GSD ONLY)
;	R3 = ENDING VIRTUAL ADDRESS INTO WHICH SECTION IS MAPPED
;		(MMG$READ_GSD ONLY)
;	4(SP) = RETURN STATUS CODE SO FAR FOR $CRMPSC SYSTEM SERVICE
;			(MMG$READ_GSD ONLY)
;
; IMPLICIT INPUTS:
;
;	THE GSD IS FULLY INITIALIZED AS WELL THE SECTION TABLE ENTRY (IF
;	THERE IS ONE).
;
; OUTPUT PARAMETERS:
;
;	R0 CONTAINS THE STATUS CODE FOR THE I/O TRANSFER.
;
; IMPLICIT OUTPUTS:
;
;	THE GLOBAL SECTION IS READ/WRITTEN.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFUL COMPLETION
;	VARIOUS SYSTEM SERVICE FAILURE CODES.
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	MAXIO = 32				;MAXIMUM # PAGES IN ONE I/O


MMG$WRITE_GSD::
	.ENABL	LSB
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;SAVE REGISTERS
	MOVL	#1,R7				;INDICATE GS IS BEING WRITTEN
	BRB	5$				;JOIN COMMON CODE

MMG$READ_GSD::
	MOVL	4(SP),R0			;GET RETURN CODE SO FAR
	BLBC	R0,50$				;BR IF ERROR CREATING SECTION
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;SAVE REGISTERS
	CLRL	R7				;INDICATE GS IS BEING READ
5$:	MOVZBL	#GSD$C_PFNBASMAX,R11		;SET COUNT OF PFN BASES IN GSD
	ADDL3	#GSD$L_BASPFN1,R6,R10		;GET ADR OF 1ST PFN BASE IN GSD
	BBC	#SEC$V_DZRO,GSD$W_FLAGS(R6),100$ ;BR IF SECTION MUST BE READ IN
	BLBS	R7,100$				;BR IF WRITING SECTION TO DISK
;
; THE SECTION IS DEMAND-ZERO.  INITIALIZE THE PAGES TO ALL ZEROS.
;
; R10 = ADDRESS OF NEXT PFN BASE IN GSD
; R11 = NUMBER OF PFN BASES IN GSD
;
	MOVQ	R2,R7				;GET START AND END VA
	MOVZWL	#^X200,-(SP)			;SET VA INCREMENT
	SUBL3	R7,R8,-(SP)			;GET # BYTES MAPPED
	BGEQ	6$				;BR IF RANGE MAPPED FOREWARDS
	MNEGL	(SP),(SP)			;CONVERT TO POSITIVE BYTE COUNT
	MNEGL	4(SP),4(SP)			;NEGATE VA INCREMENT
6$:	ASHL	#-9,(SP),(SP)			;CONVERT FROM BYTE TO PAGE COUNT
	INCL	(SP)				;ACTUAL # OF PAGES MAPPED
	ASSUME	GSD$L_BASCNT1 EQ <GSD$L_BASPFN1 + 4>
10$:	MOVL	(R10)+,R9			;NEXT PFN BASE IN GSD
	MOVL	(R10)+,R9			;NEXT BASE CNT IN GSD
	BEQL	25$				;BR ON NO MORE PAGES TO INIT
	SUBL	R9,(SP)				;IS THIS PIECE MAPPED?
	BLSS	NOT_MAPPED			;BR ON ERROR, NOT MAPPED
20$:	MOVC5	#0,(R6),#0,#^X200,(R7)		;ZERO-FILL A PAGE
	ADDL2	4(SP),R7			;GET VA OF NEXT PAGE TO INIT
	SOBGTR	R9,20$				;REPEAT FOR EACH PAGE IN PIECE
	SOBGTR	R11,10$				;REPEAT FOR EACH PIECE OF GS
25$:	ADDL2	#4,SP				;CLEAN OFF # PAGES MAPPED
30$:	MOVZBL	#SS$_NORMAL,R0			;REPORT SUCCESS
35$:	ADDL2	#4,SP				;CLEAN OFF INCREMENT
40$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;RESTORE REGISTERS
50$:	RSB

NOT_MAPPED:
	MOVZWL	#SS$_SHMGSNOTMAP,R0		;DZRO SECTION MUST BE MAPPED, TO
	MOVL	R0,<14*4>(SP)			;ERROR CODE TO RETURN TO CALLER
	ADDL2	#4,SP				;CLEAN OFF # PAGES MAPPED
	BRB	35$				;ALLOW INIT. DURING CREATION

;
; THE SECTION WAS NOT DEMAND-ZERO, THEREFORE IT MUST BE MAPPED TO A FILE.
; (PFN MAPPED SECTIONS ARE NEVER INITIALIZED AND THUS NEVER REACH THIS CODE.)
; THE PAGES MUST BE READ FROM THE FILE INTO SHARED MEMORY BEFORE A STATUS
; CODE CAN BE RETURNED TO THE CALLER OF $CRMPSC.
;
;
; FIRST GET THE NEEDED PARAMETERS FROM THE SECTION TABLE ENTRY. (ALL GLOBAL
; SECTIONS MAPPED TO A FILE, HAVE A SECTION TABLE ENTRY IN THE SYSTEM PROCESS
; HEADER.)  THESE PARAMETERS INCLUDE THE WINDOW ADDRESS, VIRTUAL BLOCK NUMBER,
; PAGE FAULT CLUSTER SIZE FOR THE SECTION.
;
100$:	JSB	MMG$FINDSHD			;GET SHD AND SHB ADDRS
	PUSHL	SHB$L_BASGSPFN(R4)		;REMEMBER BASE PFN OF SHM
	CVTWL	GSD$W_GSTX(R6),R1		;GET SECTION TABLE INDEX
	MOVL	G^MMG$GL_SYSPHD,R0		;GET SYSTEM PROCESS HEADER
	ADDL2	PHD$L_PSTBASOFF(R0),R0		;GET BASE ADR OF PROC SEC TBL
	MOVAL	(R0)[R1],R1			;GET ADR OF SECTION TABLE ENTRY
	MOVL	SEC$L_WINDOW(R1),R2		;GET ADR OF WINDOW
	MOVL	SEC$L_VBN(R1),R0		;GET FIRST VBN MAPPED
	MOVZBL	SEC$B_PFC(R1),R6		;GET PAGE FAULT CLUSTER FOR GS
;
; NOW COMPUTE THE SIZE OF THE I/O REQUEST TO BE MADE.  THIS IS LIMITED BY
; (1) THE SIZE OF THE PIECE OF SECTION BEING INITIALIZED, (2) THE PAGE FAULT
; CLUSTER SIZE OF THE SECTION, AND (3) THE MAXIMUM I/O REQUEST ALLOWED BY THE
; SYSTEM.  THE LARGEST I/O POSSIBLE IS ALLOWED.  (REMEMBER THAT SHARED MEMORY
; SECTIONS MAY BE MAPPED IN UP TO #GSD$C_PFNBASMAX PIECES OF CONSECUTIVE PAGES.)
;
	ASSUME	GSD$L_BASCNT1 EQ <GSD$L_BASPFN1 + 4>
110$:	ADDL3	(R10)+,(SP),R8			;BASE PFN OF NEXT PIECE
	MOVL	(R10)+,R9			;CNT OF PAGES IN NEXT PIECE
	BEQL	30$				;BR IF NO MORE PAGES TO READ/WRT
120$:	MOVL	R6,R1				;ASSUME READ SIZE IS PFC SIZE
	BEQL	130$				;BR IF NO PFC SPECIFIED
	CMPL	R9,R1				;IS PIECE > CLUSTER SIZE?
	BGTR	140$				;BR IF PIECE GREATER
130$:	MOVL	R9,R1				;PIECE IS SMALLER, USE PIECE SIZ
140$:	CMPL	R1,#MAXIO			;IS READ SIZE > MAXIMUM I/O?
	BLSS	150$				;BR IF READ SIZE IS OK
	MOVZWL	#MAXIO,R1			;READ MAXIMUM SIZE I/O ALLOWED
150$:	ASHL	#9,R1,R1			;CONVERT PAGES TO BYTES
	MOVL	G^SCH$GL_CURPCB,R4		;CURRENT PROCESS CONTROL BLOCK
	MOVL	PCB$L_PHD(R4),R5		;CURRENT PROCESS HEADER ADR
;
; NOW ALLOCATE ONE PACKET THAT WILL CONTAIN AN IRP AND A LIST OF PAGE
; TABLE ENTRIES, DESCRIBING THE RANGE OF PHYSICAL PAGES TO BE READ/WRITTEN.
; THE PTE'S MUST BE CREATED AS THE PAGES MAY NOT BE MAPPED TO VIRTUAL
; ADDRESSES.  THE PTE'S MUST BE IN THE SAME BLOCK OF NON-PAGED POOL AS
; THE IRP, OTHERWISE THE PROCESS MIGHT BE DELETED AND THE POOL SPACE FOR
; THE PTE'S LOST.  THE I/O SYSTEM WILL RELEASE THE IRP IF THE PROCESS IS
; DELETED.
;
	PUSHR	#^M<R0,R1,R2>			;SAVE WINDOW ADDRESS, CNT & VBN
	ASHL	#-7,R1,R1			;# OF BYTES OF PTE NEEDED
	ASHL	#-2,R1,-(SP)			;# OF PTE'S TO BE CREATED
	ADDL2	#IRP$C_LENGTH,R1		;ADD IN SIZE OF I/O PACKET
	JSB	G^EXE$ALONONPAGED		;ALLOCATE NONPAGED PACKET
	BLBS	R0,155$				;SUCCESSFUL
	BRW	NO_IRP				;BR IF UNABLE TO GET PACKET
155$:	MOVL	R2,R5				;SET PACKET ADR FOR EXE$BLDPKT
	MOVB	#DYN$C_IRP,IRP$B_TYPE(R5)	;INDICATE THAT IT IS IRP
	MOVW	R1,IRP$W_SIZE(R5)		;SET SIZE OF PACKET ALLOCATED
	POPL	R1				;GET # OF PTE'S TO CREATE
	MOVAB	<IRP$C_LENGTH+^X3>&<^C<^X3>>(R2),R2 ;LONGWORD ALIGN ADR FOR PTE
	MOVL	R2,R3				;REMEMBER FIRST SVAPTE
;
; R1 = SIZE OF PACKET ALLOCATED IN BYTES
; R2 = LONGWORD ALIGNED ADDRESS FOR FIRST SVAPTE TO BE CREATED
; R5 = ADDRESS OF PACKET ALLOCATED
; R8 = NEXT PFN TO BE READ/WRITTEN
;
	BISL2	#<PTE$C_ERKW ! PTE$M_VALID>,R8	;SET OWNER AND VALID IN PTE
160$:	MOVAB	(R8)+,(R2)+			;SET ONE PTE
	SOBGTR	R1,160$				;LOOP FOR SIZE OF TRANSFER
	BICL2	#<PTE$C_ERKW ! PTE$M_VALID>,R8	;CLEAR OWNER AND VALID BITS
;
; FINALLY, INITIALIZE THE I/O REQUEST PACKET (IRP) ITSELF.  A LOCATION ON
; THE STACK IS ALLOCATED TO HOLD THE I/O COMPLETION STATUS CODE.  THE I/O
; COMPLETION AST ROUTINE WILL MOVE THE STATUS CODE INTO THIS LOCATION AND
; DELETE THE IRP.
;
	POPR	#^M<R0,R1,R2>			;GET WINDOW ADR, CNT & VBN
	PUSHR	#^M<R0,R1,R2>			;SAVE BYTE CNT & WINDOW ADR
	CLRQ	-(SP)				;INITIALIZE I/O RETURN STATUS
	MOVL	SP,IRP$L_IOSB(R5)		;SET ADR FOR RETURN STATUS
	MOVAB	B^SHMIODONE,IRP$L_ASTPRM(R5)	;SET AST ROUTINE ADR
	MOVB	PCB$B_PRIB(R4),IRP$B_PRI(R5)	;SET PRIORITY FOR I/O 
;
; THE INPUTS FOR EXE$BLDPKTGSR/EXE$BLDPKTGSW ARE:
;	R0 = VBN
;	R1 = NUMBER OF BYTES TO TRANSFER
;	R2 = WINDOW ADDRESS
;	R3 = SVAPTE
;	R4 = PCB ADDRESS
;	R5 = IRP ADDRESS
;
; IT DESTROYS R0, R1, R2, R3, R4 AND R5.
;
	BLBC	R7,185$			;BR IF READING SHM PAGES
	JSB	G^EXE$BLDPKTGSW		;GO BUILD & SUBMIT WRITE REQUEST
	BRB	190$			;JOIN COMMON CODE
185$:	JSB	G^EXE$BLDPKTGSR		;GO BUILD & SUBMIT READ REQUEST
;
; NOW WAIT FOR THE I/O REQUEST TO COMPLETE.  THIS IS ACCOMPLISHED BY WAITING
; FOR AN I/O COMPLETION STATUS CODE TO BE SET BY THE AST ROUTINE.  THIS CODE
; MAY OR MAY NOT BE SET BEFORE THE WAIT STATE IS ENTERED.  THE WAIT STATE
; MAY ALSO BE LEFT FOR THE WRONG REASON.  THEREFORE, THE STATUS CODE MUST BE
; CHECKED BEFORE WAITING AND UPON AWAKENING.  THE WAIT STATE IS PAGE FAULT WAIT.
;
;
; ******* THERE IS A PROBLEM HERE.  LOWERING IPL SO AS TO RECEIVE THE AST
; ******* WILL ALLOW THE PROCESS CREATING THE SHM GS TO BE DELETED WHILE
; ******* IT HOLDS AN UNFINISHED GSD.
;
190$:	PUSHL	#0				;LOWER IPL TO RECEIVE AST'S
195$:	SETIPL	SYNCHIPL			;RAISE IPL TO SYNCH AND INSURE
						;THAT CODE IS FAULTED INTO MEM
	TSTL	4(SP)				;CHECK IF I/O STATUS CODE IS SET
	BNEQ	200$				;BR IF I/O REQUEST IS COMPLETE
	MOVAQ	G^SCH$GQ_PFWQ,R2		;SET ADR OF PAGE FAULT WAIT QUE
	MOVL	G^SCH$GL_CURPCB,R4		;SET ADR OF CURRENT PROC CTL BLK
	JSB	G^SCH$WAITK			;WAIT ON A KERNEL AST
	BRB	190$				;CHECK IF AST WAS FOR THIS I/O
REI_RTN1:
	REI					;SET NEW PSL AND PC FROM STACK
200$:	BSBB	REI_RTN1			;RESTORE TO PSL BEFORE WAIT
	MOVL	(SP)+,R0			;GET I/O COMPLETION CODE
	BLBC	R0,IO_FAIL			;BR IF I/O FAILED
	TSTL	(SP)+				;CLEAN OFF STACK
	BRB	220$				;CONTINUE
;
; PLACING THE SYNCH IPL IN A LONGWORD AT THIS LOCATION WILL FORCE THE ABOVE
; SETIPL INSTRUCTION TO FAULT INTO MEMORY ALL INSTRUCTIONS BETWEEN IT AND THIS
; LONGWORD.  THIS IS NECESSARY BECAUSE THIS CODE RESIDES IN A PAGEABLE PSECT
; RUNS AT RAISED IPL, AND PAGE FAULTS CANNOT BE ALLOWED AT RAISED IPL.
; THE ASSUME MACRO GUARANTEES THAT THE SETIPL INSTRUCTION AND THE IPL
; LONGWORD ARE ON ADJACENT PAGES.
;
SYNCHIPL:
	.LONG	IPL$_SYNCH			;SYNCH IPL
205$:
	ASSUME	<205$ - 195$> LE 512		;GUARANTEE PAGE ADJACENCY
;
; THE I/O TO INITIALIZE THE GLOBAL SECTION FAILED.
;
IO_FAIL:
;
; UNABLE TO ALLOCATE AN IRP.  RETURN ERROR STATUS CODE.
;
NO_IRP:
	ADDL2	#<4*4>,SP			;WIND, CNT, VBN, PTE, & BAS PFN
	BRW	35$				;ERROR EXIT
;
; I/O REQUEST COMPLETED SUCCESSFULLY.  NOW SET UP TO DO THE NEXT
; PAGES OF THE GLOBAL SECTION.  THESE PAGES MAY BE IN THE SAME PIECE, (I.E.,
; HAVE THE SAME BASE PFN) OR THEY MAY BE PART OF THE NEXT PIECE OF THE SECTION.
; THE ENTIRE SECTION MAY NOW BE MAPPED, TOO.  THE PARAMETERS TO BE INITIALIZED
; ARE:  (1) PFN, (2) VIRTUAL BLOCK NUMBER, AND (3) NUMBER OF PAGES
; LEFT TO MAP IN THIS PIECE.
;
220$:	POPR	#^M<R0,R1,R2>			;RESTORE REGISTERS
	ASHL	#-9,R1,R1			;GET # OF PAGES READ/WRITTEN
	ADDL2	R1,R0				;GET NEXT VBN TO BE READ/WRITTEN
	SUBL2	R1,R9				;GET # PAGES IN PIECE TO XFER
	BEQL	250$				;BR IF ALL OF THIS PIECE IS DONE
	BRW	120$				;BR IF MORE OF PIECE TO READ
250$:	SOBGTR	R11,260$			;BR TO GET NEXT PIECE OF GS
	BRW	30$				;BR IF NO MORE PIECES TO READ
260$:	BRW	110$				;GO GET NEXT BASE PFN/CNT
;
; THIS IS THE AST ROUTINE CALLED WHEN I/O IS COMPLETED TO SHARED MEMORY.
; IT SETS THE COMPLETION STAUS CODE INTO A STACK ADDRESS FOR THE I/O
; REQUESTOR TO CHECK.  THE IRP IS THEN DELETED.
;
SHMIODONE:
270$:	DSBINT	NEWIPL				;DISABLE INTERRUPTS & PAGEFAULTS
	MOVL	IRP$L_IOST1(R5),@IRP$L_IOSB(R5) ;SET I/O COMPLETION STATUS CODE
	MOVL	R5,R0				;SET ADR OF IRP
	JSB	G^EXE$DEANONPAGED		;DEALLOCATE THE IRP
	MOVL	G^SCH$GL_CURPCB,R4		;GET ADR OF CURRENT PCB
	MOVZBL	#PRI$_IOCOM,R2			;SET I/O COMPLETION STATE CODE
	RPTEVT	PFCOM,CALL_TYPE=JSB		;REPORT PAGEFAULT COMPLETE EVENT
	ENBINT					;ENABLE INTERRUPTS
	RSB					;RETURN FROM AST
;
; PLACING THE SYNCH IPL IN A LONGWORD AT THIS LOCATION WILL FORCE THE ABOVE
; SETIPL INSTRUCTION TO FAULT INTO MEMORY ALL INSTRUCTIONS BETWEEN IT AND THIS
; LONGWORD.  THIS IS NECESSARY BECAUSE THIS CODE RESIDES IN A PAGEABLE PSECT
; AND PAGE FAULTS CANNOT BE ALLOWED AT RAISED IPL.
;
NEWIPL:
	.LONG	IPL$_SYNCH			;SYNCH IPL
300$:
	ASSUME	<300$ - 270$> LE 512		;GUARANTEE PAGE ADJACENCY
	.DSABL	LSB
	.PAGE
	.SBTTL	MMG$FINDGSNOTRN - FIND GSD WITHOUT LOGICAL NAME TRANSLATION

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED BY $MGBLSC AND $DGBLSC WHEN THEY CANNOT FIND A GLOBAL
; SECTION VIA THE NORMAL SEARCH PATH.  IF A SPECIFIC SHARED MEMORY WAS BEING
; SEARCHED, THE SECTION MIGHT NOT BE IN THAT MEMORY.  IF IT IS A COPY-ON-
; REFERENCE SECTION, IT WILL HAVE BEEN PLACED IN LOCAL MEMORY.  THIS ROUTINE
; CHECKS TO SEE IF THIS HAS OCCURRED.  IF THE SEARCH WAS IN A SPECIFIC SHARED
; MEMORY, THE RESULTANT GLOBAL SECTION NAME PREFIXED BY AN UNDERSCORE (CAUSING
; NO FURTHER LOGICAL NAME TRANSLATION) IS USED IN A SECOND SEARCH; THIS SEARCH
; STARTING IN LOCAL MEMORY.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FINDGSNOTRN
;
; INPUT PARAMETERS:
;
;	R7 - ADDRESS OF A SCRATCH AREA CONTAINING THE RESULTANT ASCIC GLOBAL
;	     SECTION NAME FOLLOWED BY THE IDENT QUADWORD
;	R9 - SECTION FLAGS SPECIFIED BY USER
;	R10 - 0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	     -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	     >0 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - RETURN STATUS CODE
;	R6 - GSD ADDRESS, IF FOUND
;	R10 - 0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	     -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	     >0 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED
;
; IMPLICIT OUTPUTS:
;
;	THE PREVIOUS MODE IS SET TO THE CURRENT MODE TO ALLOW THE DESCRIPTORS
;	AND BUFFERS WHICH ARE ON THE STACK TO BE PROBED.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFUL COMPLETION
;	SS$_NOSUCHSEC - NO SUCH GLOBAL SECTION
;	SS$_IVLOGNAM - INVALID LOGICAL NAME
;	SS$_ACCVIO - ACCESS VIOLATION
;
; SIDE EFFECTS:
;
;	NONE
;
;--


MMG$FINDGSNOTRN::
	TSTL	R10				;SPECIFIC SHARED MEMORY SEARCH?
	BLEQ	10$				;BR IF NOT SPEC MEM SEARCH
;
; THE ROUTINE THAT DOES A GSD TABLE SCAN PROBES THE NAME BUFFER AND THE IDENT
; QUADWORD FROM THE PREVIOUS MODE.  SINCE THESE AREAS ARE NOW ON THE KERNEL
; STACK AND THE PREVIOUS MODE IS PROBABLY USER, IT IS NECESSARY TO MAKE THE
; PREVIOUS MODE BE KERNEL.  NOTE:  NO OTHER PROBES OF USER PROVIDED DATA ARE
; DONE BY $CRMPSC OR $DGBLSC SYSTEM SERVICES FROM HERE ON.
;
	MOVPSL	-(SP)				;GET CURRENT PSL
	MOVPSL	-(SP)				;GET CURRENT PSL, AGAIN !!!
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,(SP),R0 ;EXTRACT CURRENT MODE
	INSV	R0,#PSL$V_PRVMOD,#PSL$S_PRVMOD,(SP) ;SET PREV MODE TO CUR MODE
	BSBB	REI_ROUTINE			;FORCE PREV MODE TO BE CUR MODE

	PUSHR	#^M<R1,R2,R3,R4,R5>		;SAVE REGISTERS
	SUBL	#<4*4>,SP			;BUFFER FOR NEW NAME STRING
	MOVC3	#15,1(R7),1(SP)			;COPY RESULTANT NAME STRING
	MOVB	#^A/_/,(SP)			;FORCE NO LOG NAM TRANS
	PUSHL	SP				;SET ADR IN STR DESC
	MOVZBL	(R7),-(SP)			;SET SIZ IN STR DESC
	INCL	(SP)				;ADD IN ONE UNDERSCORE CHAR
	MOVL	SP,R0				;SET ADR OF STR DESC
	MOVL	R9,R6				;SET SECTION FLAGS
	MOVAB	16(R7),R1			;SET MATCH CONTROL INFO
	BSBW	MMG$GSDSCN			;GO SEARCH AGAIN
	ADDL2	#<6*4>,SP			;RELEASE BUFFER AND STR DESC
	POPR	#^M<R1,R2,R3,R4,R5>		;RESTORE REGISTERS
	BSBB	REI_ROUTINE			;RESTORE ORIGINAL PREVIOUS MODE
10$:	RSB					;RETURN STATUS OF SEARCH

REI_ROUTINE:
	REI					;THIS WILL ALLOW A NEW MODE
						;TO BE SET FROM THE STACK
	.PAGE
	.SBTTL	MMG$UNIQUEGSD - CHECK THAT SH MEM GSD IS UNIQUE

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED BY $CRMPSC AFTER IT HAS INITIALIZED A SHARED MEMORY
; GLOBAL SECTION.  A SEARCH OF THE SPECIFIC SHARED MEMORY'S GSD TABLE IS MADE
; TO ASCERTAIN IF A GLOBAL SECTION OF THE SAME NAME WAS CREATED DURING THE
; TIME THAT $CRMPSC WAS CREATING THE SECTION.
;
; TWO LOCKS MUST BE ACQUIRED BEFORE THE SHARED MEMORY GSD TABLE MAY BE SEARCHED
; TO VERIFY A SECTION IS UNIQUE.  THE FIRST IS THE SHARED MEMORY GSD MUTEX
; WHICH INTERLOCKS PROCESSES ON ONE PROCESSOR.  THE SECOND IS THE SHARED MEMORY
; GSD TABLE LOCK CONTAINED IN THE SHARED MEMORY COMMON DATA PAGE, WHICH
; INTERLOCKS BETWEEN PROCESSORS.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$UNIQUEGSD
;
; INPUT PARAMETERS:
;
;	R4 - ADDRESS OF SHARED MEMORY CONTROL BLOCK
;	R11 - ADDRESS OF GLOBAL SECTION DESCRIPTOR TO BE VERIFIED AS UNIQUE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R5 - ADDRESS OF SHARED MEMORY COMMON DATA PAGE
;	R6 - 0 IF THE GSD IS UNIQUE
;	     OTHERWISE, ADDRESS OF DUPLICATE GSD
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$UNIQUEGSD::
	.ENABL	LSB
	PUSHR	#^M<R0,R1,R2,R3,R4,R10>		;SAVE REGISTERS
	MOVZBL	#SHD$V_GSDLCK,R0		;BIT NUMBER OF LOCK REQUESTED
	BSBW	MMG$SHMTXLK			;GET SHM MUTEX AND BIT LOCK
	BLBC	R0,ERROR_EXIT			;REPORT UNABLE TO GET BIT LOCK
	MOVB	SHB$B_PORT(R4),SHD$B_GSDLOCK(R5) ;SET OWNER OF GSD TBL LOCK
	PUSHL	#1				;INDICATE TO MMG$VALIDATE AND
	MOVL	SP,R10				;MMG$GETNXTGSD NOT TO USE ALL
						;SHARED MEMORIES IN SEARCH
						;JUST THE ONE PASSED IN R4,R5
	ADDL3	SHD$L_GSDPTR(R5),R5,R6		;GET ADR OF FIRST GSD IN SH MEM
	JSB	MMG$VALIDATEGSD			;FIND FIRST VALID GSD
	BRB	30$				;BR TO CHECK IF GSD FOUND
20$:	POPR	#^M<R4,R5>			;RESTORE SHB, SHD ADRS
	JSB	MMG$GETNXTGSD			;FIND NEXT VALID GSD
30$:	TSTL	R6				;IS THERE A GSD ADR?
	BEQL	NO_DUP_GSD			;BR ON NO MORE VALID GSD'S
	PUSHR	#^M<R4,R5>			;REMEMBER SHB, SHD ADRS
	BBS	#GSD$V_LOCKED,GSD$L_GSDFL(R6),20$ ;BR IF GSD LOCKED FOR READING
	BBS	#GSD$V_DELPEND,GSD$L_GSDFL(R6),20$ ;BR IF GSD BEING DELETION
	CMPC3	#16,GSD$T_GSDNAM(R6),GSD$T_GSDNAM(R11) ;GS'S OF SAME NAME?
	BNEQ	20$				;BR IF DIFFERENT NAMES
	POPR	#^M<R4,R5>			;RESTORE SHB,SHD ADRS
NO_DUP_GSD:
	BBCCI	#SHD$V_GSDLCK,SHD$B_FLAGS(R5),50$ ;RELEASE SHM GSD TBL LOCK
50$:	BSBW	MMG$SHMTXULK			;RELEASE SHM MUTEX
	TSTL	(SP)+				;CLEAN OFF DUMMY SHMEM NAM CNT
60$:	POPR	#^M<R0,R1,R2,R3,R4,R10>		;RESTORE REGISTERS
	RSB					;RETURN TO $CRMPSC

; ***********
; AT SOME LATER DATE, THIS SHOULD SEND AN ERROR MESSAGE TO THE ERROR LOGGER.
; ***********
ERROR_EXIT:
	CLRL	R6				;FAILURE TO ACQUIRE BIT LOCK
	BRB	60$				;RETURN ERROR STATUS
	.DSABL	LSB
	.PAGE
	.SBTTL	MMG$SHMTXLK/MMG$SHMTXULK - GET/RELEASE SHARED MEMORY MUTEX

;++
; FUNCTIONAL DESCRIPTION:
;
; THE ROUTINE MMG$SHMTXLK IS CALLED TO ACQUIRE EXCLUSIVE USE OF A SHARED
; MEMORY GLOBAL SECTION DATA STRUCTURE.  THIS IS DONE BY ACQUIRING A LOCAL
; MEMORY MUTEX AND THEN A SHARED MEMORY BIT LOCK.  A WAIT IS DONE FOR THE MUTEX
; AND A LOOP IS EXECUTED TO ACQUIRE THE BIT LOCK.  THE STATUS CODE FOR
; ACQUIRING THE LOCK, IS RETURNED.  IF THE BIT LOCK COULD NOT BE ACQUIRED, THEN
; AN ERROR CODE IS RETURNED.
;
; THE ROUTINE MMG$SHMTXULK RELEASES THE SHARED MEMORY GLOBAL SECTION DATA
; STRUCTURE MUTEX.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$SHMTXLK
;	BSBW	MMG$SHMTXULK
;
; INPUT PARAMETERS:
;
;	R0 - BIT NUMBER OF LOCK BEING REQUESTED, FOR MMG$SHMTXLK ONLY
;	R4 - ADDRESS OF SHARED MEMORY CONTROL BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - STATUS CODE, FOR MMG$SHMTXLK ONLY
;	R5 - ADR OF SHARED MEMORY COMMON DATA PAGE, FOR MMG$SHMTXLK ONLY.
;
; IMPLICIT OUTPUTS:
;
;	THE SHARED MEMORY MUTEX AND BIT LOCK MAY BE ACQUIRED BY MMG$SHMTXLK.
;	THE SHARED MEMORY MUTEX MAY BE RELEASED BY MMG$SHMTXULK.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFULLY ACQUIRED LOCKS, FOR MMG$SHMTXLK ONLY.
;	SS$_INTERLOCK  - UNABLE TO ACQUIRE LOCK, FOR MMG$SHMTXLK ONLY.
;	NONE FOR MMG$SHMTXULK.
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$SHMTXLK::
	PUSHL	R1				;SAVE REGISTER
	PUSHR	#^M<R0,R4>			;REMEMBER SHB AND BIT LOCK #
	MOVAL	G^EXE$GL_SHMGSMTX,R0		;ADR OF SH MEM GSD MUTEX
	MOVL	G^SCH$GL_CURPCB,R4		;ADR OF CURRENT PCB
	JSB	G^SCH$LOCKW			;GET UNIQUE ACCESS TO MUTEX
	POPR	#^M<R0,R4>			;RESTORE SHB AND BIT LOCK #
	MOVL	G^EXE$GL_LOCKRTRY,R1		;GET LOOP COUNT FOR BIT LOCK
	MOVL	SHB$L_DATAPAGE(R4),R5		;GET ADR OF COMMON DATA PAGE
10$:	BBSSI	R0,SHD$B_FLAGS(R5),20$		;TRY TO ACQUIRE BIT LOCK
	MOVZBL	#SS$_NORMAL,R0			;REPORT LOCK SUCCESSFULLY ACQUIR
	POPL	R1				;RESTORE REGISTER
	RSB					;RETURN SUCCESS CODE
20$:	SOBGTR	R1,10$				;TRY AGAIN TO ACQUIRE BIT LOCK
	POPL	R1				;RESTORE REGISTER
						;R0 CONTAINS 0 TO REPORT FAILURE
	MOVZWL	#SS$_INTERLOCK,R0		;REPORT ERROR STATUS
						;FALL THRU TO RELEASE SHM MUTEX
MMG$SHMTXULK::
	PUSHR	#^M<R0,R1,R4>			;SAVE REGISTERS
	MOVAL	G^EXE$GL_SHMGSMTX,R0		;ADR OF SH MEM GSD MUTEX
	MOVL	G^SCH$GL_CURPCB,R4		;ADR OF CURRENT PCB
	JSB	G^SCH$UNLOCK			;GET UNIQUE ACCESS TO MUTEX
	POPR	#^M<R0,R1,R4>			;RESTORE REGISTERS
	RSB					;RETURN TO CALLER
	.PAGE
	.SBTTL	MMG$DELSHMGS - DELETE SHARED MEMORY GLOBAL SECTION

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED DURING A SCAN OF THE SECTION TABLE FOR SECTIONS READY
; TO BE DELETED.  IT CHECKS THE PTE REFERENCE COUNTS FOR THE PARTICULAR GLOBAL
; SECTION, DETERMINING WHETHER OR NOT THE SECTION IS READY TO BE DELETED.  IF
; IT CAN BE DELETED, THEN THE PAGES ALLOCATED ARE RELEASED, THE GSD IS RELEASED,
; AND LASTLY, THE SECTION TABLE ENTRY IS RELEASED.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DELSHMGS
;
; INPUT PARAMETERS:
;
;	R1 - SECTION TABLE OFFSET
;	R3 - ADDRESS OF SECTION TABLE ENTRY TO BE DELETED
;	R5 - SYSTEM PROCESS HEADER ADDRESS
;
; IMPLICIT INPUTS:
;
;	THE SHARED MEMORY GLOBAL SECTION PAGE BITMAP MUST HAVE BEEN INITIALIZED.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	THE GLOBAL SECTION PAGES, GLOBAL SECTION DESCRIPTOR, AND SECTION TABLE
;	ENTRY ARE RELEASED, IF ALL REFERENCE COUNTS ARE ZERO.
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENABL	LSB
;
; SET INDICATOR TO CHECK LATER TO DELETE THIS SECTION.  THERE IS STILL A PROCESS
; MAPPED TO IT AT PRESENT.
;
RETRY_DEL:
	BBSSI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),NO_DEL ;SECTION STILL TO BE DEALLOC
NO_DEL:	BRW	100$				;BRANCH TO EXIT

MMG$DELSHMGS::
	PUSHR	#^M<R1,R2,R3,R4,R5,R6>		;SAVE REGISTERS
	MOVL	SEC$L_GSD(R3),R6		;GET ADR OF GSD
	BEQL	18$				;BR IF PARTIALLY CREATED GS
;
; NOW CHECK IF THE GLOBAL SECTION IS MARKED FOR DELETION.  IF SO, CHECK THE
; PROCESSOR PTE REFERENCE COUNTS TO SEE IF THE SECTION CAN BE DELETED NOW.
;
	BBC	#GSD$V_DELPEND,GSD$L_GSDFL(R6),NO_DEL ;BR IF NOT MARK FOR DEL
	MOVZBL	GSD$B_PROCCNT(R6),R2		;GET # OF PROC REF CNTS TO CHECK
	MOVAB	GSD$L_PTECNT1(R6),R3		;GET ADR OF FIRT PROC REF CNT
10$:	TSTL	(R3)+				;ARE THERE OUTSTANDING REFS?
	BNEQ	RETRY_DEL			;BR IF REF EXISTS, CAN'T DEL YET
	SOBGTR	R2,10$				;LOOP TO CHECK ALL REF CNTS
;
; THE GSD IS MARKED FOR DELETE AND ALL THE PROCESSOR REFERENCE COUNTS HAVE
; DROPPED TO ZERO.  THEREFORE, THE SHARED MEMORY GLOBAL PAGES MAY BE RELEASED
; AND THE GSD MARKED AS UNUSED.  IF THE SECTION IS WRITABLE, NOT COPY-ON-
; REFERENCE, AND MAPPED TO A FILE THEN THE SECTION MUST BE WRITTEN BACK TO
; THE FILE BEFORE IT CAN BE DELETED.
;
	CVTWL	GSD$W_GSTX(R6),R3		;IS IT MAPPED TO A FILE?
	BEQL	20$				;NO, BR AS NO OUTPUT NEEDED
	BBC	#SEC$V_WRT,GSD$W_FLAGS(R6),15$	;BR IF NOT WRITABLE
	BBS	#SEC$V_CRF,GSD$W_FLAGS(R6),15$	;DON'T WRITE OUT CRF SEC EITHER
	BSBW	MMG$WRITE_GSD			;WRITE SECTION INTO DISK FILE
15$:	ADDL3	PHD$L_PSTBASOFF(R5),R5,R2	;GET BASE OF SECTION TABLE
	MOVAL	(R2)[R3],R3			;GET ADR OF SECTION TABLE ENTRY
18$:	MOVL	SEC$L_WINDOW(R3),R3		;GET WCB ADDRESS FOR SECTION
	DECW	WCB$W_REFCNT(R3)		;LAST REF ON SHARED WINDOW?
	BGTR	20$				;BRANCH IF NOT LAST REF
	CLRW	WCB$W_NMAP(R3)			;NO RETRIEVAL POINTERS
	ASSUME WCB$W_P1_COUNT&3 EQ 0		;STARTS AT LONG WORD OFFSET
	INSQUE	WCB$W_P1_COUNT(R3),G^EXE$GL_WCBDELFL ;QUE WINDOW ON DELETE LIST
20$:	TSTL	R6				;IS THIS A PARTIALLY CREATED GS?
	BEQL	70$				;BR ON YES, NO GSD TO DELETE
	JSB	MMG$FINDSHD			;FIND THE SHB AND SHD FOR GSD
	MOVZBL	#SHD$V_BITMAPLCK,R0		;NUMBER OF BIT TO LOCK
	BSBW	MMG$SHMTXLK			;ACQUIRE MUTEX AND LOCK BIT
	BLBC	R0,300$				;BR IF CAN'T LOCK BIT
	MOVB	SHB$B_PORT(R4),SHD$B_BITMAPLCK(R5) ;IDENTIFY HOLDER OF LOCK
	BSBW	MMG$SET_BITMAP			;FREE THE PAGES OF THE SECTION
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),25$ ;RELEASE BITMAP LOCK
25$:	BSBW	MMG$SHMTXULK			;RELEASE MUTEX
	BBSSI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),30$ ;LOCK THE GSD TO RELEASE IT
30$:	BBCCI	#GSD$V_DELPEND,GSD$L_GSDFL(R6),40$ ;INDICATE NO MORE DELETE PEND
40$:	BBCCI	#GSD$V_VALID,GSD$L_GSDFL(R6),50$ ;RELEASE THE GSD
50$:	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),60$ ;UNLOCK THE GSD FOR RE-USE
60$:	MOVZBL	SHB$B_PORT(R4),R6		;GET PORT NUMBER
	DECL	SHB$L_REFCNT(R4)		;ONE LESS PORT REFCNT
	ADAWI	#1,SHD$W_GSDQUOTA(R5)[R6]	;RETURN QUOTA FOR GSD
70$:	MOVAL	@L^MMG$GL_SYSPHD,R5		;GET SYSTEM HEADER ADDRESS
	MOVL	(SP),R1				;GET SECTION TABLE OFFSET
	BSBW	MMG$DALCSTX			;GO RELEASE THE SEC TBL ENTRY
;
; RETURN SUCCESSFULLY HERE.
;
100$:	POPR	#^M<R1,R2,R3,R4,R5,R6>		;RESTORE REGISTERS
	RSB					;RETURN TO CALLER

;
; CAN'T LOCK BITMAP.  MAKE THE GSD LOOK UNOWNED AND CONTINUE CLEANING UP
; THE SECTION TABLE ENTRY.  EVENTUALLY, MMG$FREEGSD WILL FIND AND FREE
; UP THE GSD AND BITMAP.
;
300$:	CLRW	GSD$W_GSTX(R6)			;NULL SECTION TABLE INDEX
	MCOMB	#0,GSD$B_CREATPORT(R6)		;MAKE CREATOR INVALID
	BRB	60$				;REJOIN MAIN FLOW
	.DSABL	LSB
	.PAGE
	.SBTTL	MMG$FINDSHD - FIND THE SHARED MEMORY CONTAINING THIS GSD

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE FINDS THE SHARED MEMORY CONTROL BLOCK ADDRESS AND COMMON
; DATA PAGE ADDRESS FOR A SHARED MEMORY THAT CONTAINS A PARTICULAR GLOBAL
; SECTION.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FINDSHD
;
; INPUT PARAMETERS:
;
;	R6 - ADDRESS OF GLOBAL SECTION DESCRIPTOR
;
; IMPLICIT INPUTS:
;
;	THE SHARED MEMORY DATA STRUCTURES ARE AVAILABLE (NOT DISCONNECTED).
;
; OUTPUT PARAMETERS:
;
;	R4 - ADDRESS OF SHARED MEMORY CONTROL BLOCK
;	R5 - ADDRESS OF SHARED MEMORY COMMON DATA PAGE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
; ******************************************************************************
;
; *********************** THE FOLLOWING CODE MUST BE RESIDENT ******************
;
	.PSECT	$MMGCOD
;
; ******************************************************************************
;

MMG$FINDSHD::
	PUSHR	#^M<R0,R1,R2>			;SAVE REGISTERS
	MOVL	G^EXE$GL_SHBLIST,R4		;GET ADR OF FIRST SHB
	BRB	20$				;JOIN COMMON CODE
10$:	MOVL	SHB$L_LINK(R4),R4		;GET ADR OF NEXT SHB
20$:	BEQL	NO_SHD_FOUND			;IF NO NEXT SHB, FATAL ERROR
	BBC	#SHB$V_CONNECT,SHB$B_FLAGS(R4),10$ ;IF DISCONNECTED, TRY NXT SHB
	MOVL	SHB$L_DATAPAGE(R4),R5		;GET ADR OF COMMON DATA PAGE
	ADDL3	SHD$L_GSDPTR(R5),R5,R1		;FIND START OF GSD TABLE
	CMPL	R6,R1				;IS GSD WITHIN THIS TABLE?
	BLSSU	10$				;NO, GO FIND NEXT SHB
	MOVZWL	GSD$W_SIZE(R1),R0		;GET SIZE OF ONE GSD
	MOVZWL	SHD$W_GSDMAX(R5),R2		;GET NUMBER OF GSD'S IN TABLE
	MULL2	R0,R2				;GET # OF BYTES IN TABLE
	ADDL2	R1,R2				;GET ADR PAST END OF GSD TABLE
	CMPL	R6,R2				;IS GSD IN THIS TABLE?
	BGEQU	10$				;NO, GO FIND NEXT SHB
	POPR	#^M<R0,R1,R2>			;RESTORE REGISTERS
	RSB					;RETURN TO CALLER

;
; THE GSD IS NOT IN A CONNECTED SHARED MEMORY.  THIS IS AN INCONSISTENCY IN
; IN THE DATA BASE.  FOR NOW, BUGCHECK.
;
NO_SHD_FOUND:
	BUG_CHECK	NOSHMGSD,FATAL		;FATAL ERROR
	.END
