	.TITLE	SYSEVTSRV - EVENT FLAG SERVICES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, EVENT FLAG SERVICES
;
; ABSTRACT: SYSEVTSRV IMPLEMENTS THE CLEAR READ AND SET EVENT FLAG SYSTEM
;	    SERVICES AND CONTAINS THE INTERNAL CLEAR EVENT FLAG ROUTINE.
;
;--
;
; VERSION:
;
;	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:
;	R. HUSTVEDT : VERSION
;
; MODIFIED BY:
;
;	V02-005	SRB0036		Steve Beckhardt		27-Oct-1981
;		Changed SCH$GETEFC to always return via RSB.  Changed
;		SCH$CLREF and SCH$READEF to do the RET on error.  Added
;		alternate entry point SCH$CLREFR to always return via RSB.
;
;	V02-004	LJK0024		Lawrence J. Kenah	14 May 1981
;		Only take fast exit path out of $SETEF if call to SCH$POSTEF
;		was successful. This insures that system service exceptions
;		work correctly. Introduce symbolic offset for saved FP.
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$CEBDEF				; COMMON EVENT BLOCK DEFINITIONS
	$DYNDEF				; DYNAMIC DATA STRUCTURE TYPE DEFS
	$IPLDEF				; IPL DEFINITIONS
	$PCBDEF				; PCB DEFINITIONS
	$PRIDEF				; PRIORITY INCREMENT DEFINITIONS
	$SFDEF				; Stack frame symbolic offsets
	$SSDEF				; STATUS CODE DEFINITIONS
;
; EQUATES:
;
EFN=4					; DISPLACEMENT TO EVENT FLAG NUMBER ARG
MASKP=8					; DISPLACEMENT TO MASK POINTER

	.PSECT	AEXENONPAGED,BYTE	; NONPAGED EXEC

	.PAGE
	.SBTTL	 EXE$CLREF - CLEAR EVENT FLAG SERVICE 

;++
; FUNCTIONAL DESCRIPTION:
;	THE CLEAR EVENT FLAG SYSTEM SERVICE CLEARS THE SPECIFIED 
;	EVENT FLAG.  NO RESCHEDULING IS EVER NECESSARY AFTER CLEARING
;	AN EVENT FLAG.
;
;
; CALLING SEQUENCE:
;	CALL	ARGLIST,EXE$CLREF
;
;
; INPUT PARAMETERS:
;	04(AP) - EVENT FLAG NUMBER TO BE CLEARED
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE, ERROR IF BIT 0 IS SET.
;
;
; IMPLICIT OUTPUTS:
;	THE EVENT FLAG SPECIFIED WITHIN THE CLUSTER SPECIFIED
;	IS CLEARED.
;
; COMPLETION CODES:
;	SS$_WASCLR - EVENT FLAG WAS ALREADY CLEAR
;	SS$_WASSET - EVENT FLAG WAS SET
;	SS$_ILLEFC - ILLEGAL CLUSTER NUMBER (I.E. 4 - 7)
;	SS$_UNASEFC - UNASSIGNED CLUSTER NUMBER
;
; SIDE EFFECTS:
;	NONE
;
;--



EXE$CLREF::				; CLEAR EVENT FLAG SERVICE
	.WORD	^M<R2,R3,R4>		; ENTRY MASK SAVING R2,R3,R4
	MOVZBL	EFN(AP),R3		; GET EVENT FLAG NUMBER
	BSBB	SCH$CLREF		; CALL INTERNAL ROUTINE
	MOVL	SF$L_SAVE_FP(FP),FP	; RESTORE FRAME POINTER
	ADDL	S^#EXE$C_CMSTKSZ,SP	; CLEAN STACK BACK TO PC,PSL
	REI				; RETURN


	.PAGE
	.SBTTL	SCH$GETEFC - GET ADDRESS OF EVENT FLAG CLUSTER
;++
; FUNCTION:
;	SCH$GETEFC COMPUTES THE ADDRESS OF THE EVENT FLAG CLUSTER
;	SELECTED BY THE EVENT FLAG NUMBER IN R3.  THE EVENT FLAG CLUSTER
;	ADDRESS IS RETURNED IN R2.
;
; CALLING SEQUENCE:
;	BSBB/BSBW/JSB	SCH$GETEFC
;
; INPUT PARAMETERS:
;	R3 - EVENT FLAG NUMBER
;	R4 - PCB ADDRESS
;
; OUTPUT PARAMETERS:
;	R0 - STATUS CODE
;	R1 - IF LOCAL CLUSTER, (0 OR -1)
;	     IF COMMON CLUSTER, (2 OR 1)
;	R2 - ADDRESS OF EVENT FLAG CLUSTER
;	R3 - EVENT FLAG NUMBER WITHIN CLUSTER
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL COMPLETION STATUS
;	SS$_ILLEFC  -  ILLEGAL CLUSTER NUMBER
;	SS$_UNASEFC -  UNASSIGNED CLUSTER NUMBER
;
;--

SCH$GETEFC::				; GET ADDRESS OF EVENT FLAG CLUSTER
	MOVZWL	#SS$_NORMAL,R0		; ASSUME NORMAL COMPLETION
	EXTV	#5,#3,R3,R1		; EXTRACT CLUSTER NUMBER
	BLSS	30$			; ILLEGAL WITH 4,5,6,7
	MOVAL	PCB$L_EFCS(R4)[R1],R2	; GET ADDR OF EF VECTOR
	BICL	#^C<^X1F>,R3		; EXTRACT EVENT NUMBER WITHIN CLUSTER
	SOBGTR	R1,10$			; BR IF COMMON
	RSB				; RETURN WITH SUCCESS
10$:	ADDL3	#CEB$L_EFC,(R2),R2	; GET POINTER TO CEB EVENT MASK
	BGEQ	40$			; BR IF NOT ASSIGNED
	CMPB	#DYN$C_SLAVCEB,<CEB$B_TYPE-CEB$L_EFC>(R2) ; IS THIS A SLAVE CEB?
	BEQL	20$			; BR IF SLAVE, FIND MASTER CEB ADR
	RSB				; RETURN WITH SUCCESS
;
; COMPUTE ADDRESS OF MASTER CEB IN SHARED MEMORY.
;
20$:	MOVL	<CEB$L_MASTER-CEB$L_EFC>(R2),R2 ; GET ADR OF SH MEM MASTER CEB
	ADDL2	#CEB$L_EFC,R2		; POINT TO EFC IN MASTER CEB
	RSB

30$:	MOVZWL	#SS$_ILLEFC,R0		; SET ERROR CODE FOR ILLEGAL EFC
	RSB				; AND RETURN

40$:	MOVZWL	#SS$_UNASEFC,R0		; SET ERROR CODE FOR UNASSIGNED
	RSB				; AND RETURN
	.PAGE
	.SBTTL	SCH$CLREF - CLEAR EVENT FLAG (INTERNAL FORM)
;++
;	SCH$CLREF - CLEAR EVENT FLAG, INTERNAL FORM
;
; CALLING SEQUENCE:
;	JSB/BSB SCH$CLREF
;
;	SCH$CLREF WILL RETURN VIA RET RATHER THAN THE NORMAL RSB ON ERROR
;	CONDITIONS .
;	SCH$CLREFR IS AN ALTERNATE ENTRY POINT THAT ALWAYS RETURNS VIA RSB.
;
; INPUT:
;	R3 - EVENT FLAG NUMBER, ZERO FILLED.
;	R4 - PCB ADDRESS
;
; OUTPUT:
;	R0 - COMPLETION STATUS, ERROR IF BIT 0 CLEAR.
;
; COMPLETION CODES:
;	SS$_WASCLR - EVENT FLAG WAS ALREADY CLEAR
;	SS$_WASSET - EVENT FLAG WAS SET
;	SS$_ILLEFC - ILLEGAL CLUSTER NUMBER
;	SS$_UNASEFC - UNASSIGNED CLUSTER NUMBER
;--

	.ENABL	LSB

SCH$CLREFR::				; CLEAR EVENT FLAG (AND RETURN TO CALLER)
	BSBB	SCH$GETEFC		; GET ADDRESS OF EVENT FLAG CLUSTER
	BLBS	R0,5$			; ON SUCCESS JOIN COMMON CODE
	RSB				; RETURN ON FAILURE

SCH$CLREF::				; CLEAR EVENT FLAG INTERNAL 
	BSBB	SCH$GETEFC		; GET ADDRESS OF EVENT FLAG CLUSTER
	BLBC	R0,20$			; BRANCH IF ERROR
	ASSUME	SS$_WASCLR EQ SS$_NORMAL
					; SS$_NORMAL RETURNED BY SCH$GETEFC
5$:	BBCCI	R3,(R2),10$		; CLEAR AND TEST FLAG
	MOVL	#SS$_WASSET,R0		; REPORT STATUS
10$:	RSB				; RETURN TO CALLER

20$:	RET				; EXIT SERVICE IF ERROR

	.DSABL	LSB
	.PAGE
	.SBTTL	EXE$READEF - READ EVENT FLAG SYSTEM SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$READEF IMPLEMENTS THE READ EVENT FLAG SYSTEM SERVICE WHICH
;	RETURNS THE STATE OF THE EVENT FLAG CLUSTER SELECTED BY THE
;	SPECIFIED EVENT FLAG NUMBER.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$READEF
;
; INPUT PARAMETERS:
;	04(AP) - EVENT FLAG NUMBER TO SELECT PROPER CLUSTER
;	08(AP) - ADDRESS TO STORE STATE OF EVENT FLAG CLUSTER
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	@08(AP) - STATE OF 32 EVENTS IN SPECIFIED CLUSTER
;
; COMPLETION CODES:
;	SS$_WASSET  -  SPECIFIC EVENT FLAG IS CURRENTLY SET
;	SS$_WASCLR  -  SPECIFIC EVENT FLAG IS CURRENTLY CLEAR
;	SS$_ILLEFC  -  ILLEGAL EVENT FLAG CLUSTER NUMBER
;	SS$_UNASEFC -  UNASSIGNED EVENT FLAG CLUSTER
;	SS$_ACCVIO  -  ACCESS VIOLATION ON WRITE DESTINATION
;
;--

EXE$READEF::				; READ EVENT FLAG SYSTEM SERVICE
	.WORD	^M<R2,R3,R4>		; ENTRY MASK SAVING R2,R3,R4
	MOVZBL	EFN(AP),R3		; GET EVENT FLAG NUMBER 
	BSBB	SCH$GETEFC		; GET EFC ADDRESS AND CONTENT
	BLBC	R0,20$			; BRANCH ON ERROR
	ASSUME	SS$_WASCLR EQ SS$_NORMAL
	MOVL	MASKP(AP),R1		; GET ADDRESS OF DESTINATION
	IFNOWRT	#4,(R1),10$		; TEST FOR WRITABLE
	MOVL	(R2),(R1)		; STORE EVENT FLAG BIT VECTOR
	BBC	R3,(R1),20$		; EXIT IF CLEAR
	MOVZWL	#SS$_WASSET,R0		; RETURN SET STATUS CODE
	RET				; AND RETURN
10$:	MOVZWL	#SS$_ACCVIO,R0		; SET ACCESS VIOLATION
20$:	RET				; AND RETURN

	.PAGE
	.SBTTL	EXE$SETEF - SET EVENT FLAG SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$SETEF IMPLEMENTS THE SET EVENT FLAG SERVICE WHICH SETS
;	THE SPECIFIED EVENT FLAG AND CAUSES ANY APPROPRIATE RESCHEDULING.
;
; CALLING SEQUENCE:
;	CALLG	EXE$SETEF
;
; INPUT PARAMETERS:
;	04(AP) - EVENT FLAG NUMBER
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	CURRENT PCB LOCATED VIA SCH$GL_CURPCB
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;
; COMPLETION CODES:
;	SS$_WASCLR  -  SPECIFIED EVENT WAS CLEAR INITIALLY
;	SS$_WASSET  -  SPECIFIED EVENT WAS SET INITIALLY
;	SS$_ILLEFC  -  ILLEGAL CLUSTER NUMBER
;	SS$_UNASEFC -  UNASSIGNED EVENT FLAG CLUSTER NUMBER
;	SS$_BADQUEUEHDR - UNABLE TO MAKE PROCESSOR REQUEST TO UPDATE SLAVE CEB
;
;--

EXE$SETEF::				; SET EVENT FLAG SYSTEM SERVICE
	.WORD	^M<R2,R3,R4,R5>		; ENTRY MASK SAVING R2,R3,R4,R5
	MOVZBL	EFN(AP),R3		; GET EVENT FLAG NUMBER
	MOVL	PCB$L_PID(R4),R1	; GET PROCESS ID (PID)
	MOVL	#PRI$_IOCOM,R2		; SET PRIORITY INCREMENT CLASS
	BSBW	SCH$POSTEF		; POST EVENT FLAG
	BLBC	R0,10$			; DON'T USE FAST EXIT IF ERROR
	MOVL	SF$L_SAVE_FP(FP),FP	; RESTORE FRAME POINTER
	ADDL	S^#EXE$C_CMSTKSZ,SP	; CLEAN STACK BACK TO PC,PSL
	REI				; AND RETURN

10$:	RET				; EXIT THROUGH CHANGE MODE DISPATCHER
					;  COMMON EXIT PATH IF ERROR

	.END
