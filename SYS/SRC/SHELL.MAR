	.IF	NDF,LIBSWITCH
	.TITLE	SHELL PROCESS DEFINITION
	.IFF
	.TITLE	SYS$USRVECTOR - USER ACCESSIBLE P1 CELLS
	.ENDC
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, CREATE PROCESS/SWAPPER DATA BASE
;
; ABSTRACT:	SHELL DEFINES THE SWAP IMAGE FOR THE INITIAL PROCESS
;		STARTED BY THE CREATE PROCESS SYSTEM SERVICE.
;
; ENVIRONMENT:
;
; AUTHOR: RICHARD I. HUSTVEDT, CREATION DATE: 30-NOV-76
;
; MODIFIED BY:
;
;	V03-001	LJK0158		Lawrence J. Kenah	9-Apr-1982
;		Allocate array in image activator context page for
;		context to reset privileged vectors.
;
;	V02-055	TMH0055		Tim Halvorsen		9-Feb-1982
;		Increase process I/O segment to allow greater use of
;		PPF OPEN and F$SEARCH calls.
;
;	V02-054	LJK0119		Lawrence J. Kenah	5-Feb-1982
;		Add image and process context fields and two privileged
;		vector arrays to image activator context page.
;
;	V02-053	TMH0053		Tim Halvorsen		03-Jan-1982
;		Rename SYS$GL_IAFLNKPTR to SYS$GL_IAFLINK.
;
;	V02-052	HRJ0040		Herb Jacobs		28-Dec-1981
;		Add conditional assembly to flag greater than an 8 page shell.
;		If shell becomes more than 8 pages, swapper reserve process
;		creation page logic and sysgen FREELIM parameter need updating.
;
;	V02-051	TMH0051		Tim Halvorsen		26-Dec-1981
;		Add cell to hold channel to process permanent message section.
;		Add cells which point to AME context page (CMCNTX) and IAF list
;		(IAFLNKPTR), so that the AME and the debugger, respectively, can
;		link without SYS.STB.  These cells will remain in a constant
;		location from release to release, so that the AME and the
;		debugger are not linked to a given system version.
;		Make this module conditionally assembled, so that it produces
;		two object modules, one for the normal shell, and another for
;		the user accessible P1 pointer page cells which gets put into
;		STARLET.OLB.
;
;	V02-050	KTA0054		Kerbey T. Altmann	23-Dec-1981
;		Add new vector of addresses: CTL$AL_IPASTVEC.
;
;	V02-049	ACG0240		Andrew C. Goldstein,	14-Dec-1981  15:21
;		Make default file protection more restrictive
;
;	V02-048	SPF0040		Steve Forgey		02-Dec-1981
;		Add remote node descriptors (CTL$T_NODENAME, CTL$T_NODEADDR,
;		and CTL$T_REMOTEID).
;
;	V02-047	PHL0026		Peter H. Lipman		30-Nov-1981
;		Add CTL$GL_KNOWNFIL cell to pointer page
;
;	V02-046	LJK0080		Lawrence J. Kenah	5-Nov-1981
;		Change names of cells containing upper and lower limits on
;		page file index to MMG$GW_MINPFIDX and MMG$GL_MAXPFIDX.
;
;	V02-045	SRB0035		Steve Beckhardt		26-Oct-1981
;		Remove lock list head added previously.  List head
;		is now in PCB.
;
;	V02-044	TMH0044		Tim Halvorsen		22-Oct-1981
;		Add user-writable page to fixed P1 region for use as
;		global OWN storage by VMS-owned user-mode packages.
;
;	V02-043	LJK0069		Lawrence J. Kenah	29-Sep-1981
;		Make size of process allocation region a global constant
;		(called CTL$C_PRCALLSIZ) so it is accessible to utilities.
;
;	V02-042	TMH0042		Tim Halvorsen		04-Sep-1981
;		Extend size of CLI OWN storage area in P1 space to
;		allow a minimum of 8 DCL indirect levels.
;
;	V02-041	LMK0003		Len Kawell		02-Sep-1981
;		Correct names of RMS extend cells.
;
;	V02-040	HRJ0027		Herb Jacobs		26-Aug-1981
;		Change PSECT for shell to page it as part of system.
;
;	V02-039	DJD0001		Darrell Duffy		26-Aug-1981
;		Add RMS compatibility, structure and extend cells.
;
;	V02-038	LJK0047		Lawrence J. Kenah	19-Aug-1981
;		Add site-specific cell to P1 pointer page.
;
;	V02-037	LJK0046		Lawrence J. Kenah	19-Aug-1981
;		Use symbolic constant to allocate area that contains
;		the default directory string. Insure that this area
;		is at least as large as the largest default directory
;		string allowed by RMS.
;
;	V02-036	SPF0016		Steve Forgey		17-Aug-1981
;		Add image account data fields.
;
;	V02-035	HRJ0026		Herb Jacobs		11-Aug-1981
;		Perform dynamic assignment of process to page file.
;
;	V02-034	HRJ0024		Herb Jacobs		27-Jul-1981
;		Move initial swap space allocation code to SYSCREPRC.
;
;	V02-033	KTA0026		Kerbey T. Altmann	21-Jul-1981
;		Add CTL$GL_LOGTBL as a pointer to process table.
;
;	V02-032	SPF0008		Steve Forgey		15-Jul-1981
;		Move CTL$GQ_LOGIN so as to be adjacent to other accounting
;		data.
;
;	V02-031	HRJ0023		Herb Jacobs		01-Jul-1981
;		Do initial swap space allocation for process.
;
;	V02-030	KTA0024		Kerbey T. Altmann	01-Jul-1981
;		Redo CTL$GL_PLTFL, process logical name table head
;		to account for new hash table.
;
;	V02-029	LJK0030		Lawrence J. Kenah	19-Jun-1981
;		If SYSBOOT has configured longword PFN link arrays, alter
;		all affected opcodes from word context to longword context.
;		Also cause XDELTA to use longword version of stored commands
;		that display the PFN data base.
;
;	V02-028	LJK0019		Lawrence J. Kenah	19-Jun-1981
;		Change page protection on page table pages from SRKW to ERKW.
;
;	V02-027	LJK0015		Lawrence J. Kenah	19-Jun-1981
;		Create a P1 page of image activator context that remains for
;		the life of an image. This page contains the listheads for
;		the shareable image lists. (One of the unused pages in the
;		old process I/O segment is used for this purpose.)
;
;	V02-026	HRJ0020		Herb Jacobs		05-Jun-1981
;		Init authorized extent field in PHD.
;
;	V02-025	KTA0021		Kerbey T. Altmann	05-Jun-1981
;		Added cell for system service filter: GB_SSFILTER.
;
;	V03-024	TMH0024		Tim Halvorsen		11-May-1981
;		Change longword pointer to per-process message section
;		to a quadword giving its starting/ending addresses, in
;		order to allow it to be deleted.
;
;	V03-023	HRJ0020		Herb Jacobs		27-Apr-1981
;		Change for referencing PHD$W_WSSIZE for wroking set size.
;
;	V02-022	KTA0016		Kerbey T. Altmann	21-Apr-1981
;		Added CTL$GL_RUF - Pointer for recovery units.
;
;	V02-021	SRB0009		Steve Beckhardt		19-Mar-1981
;		Added lock list head
;
;	V02-020	KTA0010		Kerbey T. Altmann	11-Mar-1981
;		Removed the static allocation of the I/O channel table.
;		It is now done in PROCSTRT dynamically.
;
;	V02-019	LJK0012		Lawrence J. Kenah	2-Mar-1981
;		Initialize access mode field for CPU time limit expiration
;		AST to user mode.
;
;	V02-018	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to use CTL$GL_PCB instead.
;
;	V02-017 WMC0002		Wayne M. Cardoza	27-Jan-1981
;		16 pages are now reserved for system service vectors.
;
;	V02-016	KTA0001		Kerbey T. Altmann,	15-Jan-1981  14:45
;		Add new vector for user rundown service.
;
;	V02-015	ACG0138		Andrew C. Goldstein,	7-Jan-1981  11:37
;		Move exec and kernel exception vectors to last chance vector
;
;	V02-014	WMC0001		Wayne Cardoza		3-Jul-1980
;		Reserve P1 space for system service vectors and double map
;		them.
;
;
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$DYNDEF			;DYNAMIC DATA STRUCTURE TYPE DEFINITIONS
	$FWADEF			;RMS FILE WORK AREA CONSTANTS
	$IAFDEF			;IMAGE ACTIVATOR FIXUP VECTOR OFFSETS
	$IMPDEF			;RMS INTERNAL STRUCTURE DEFINITION
	$IPLDEF			;DEFINE INTERRUPT LEVELS
	$PCBDEF			;PROCESS CONTROL BLOCK DEFINITIONS
	$PFLDEF			;PAGE FILE DEFINITIONS
	$PFNDEF			;PFN DATA BASE DEFINITIONS
	$PHDDEF			;PROCESS HEADER DEFINITIONS
	$PQBDEF			;PROCESS QUOTA BLOCK DEFINITIONS
	$PRTDEF			;DEFINE PROTECTION CODES
	$PSLDEF			;DEFINE PSL FIELDS
	$PTEDEF			;PAGE TABLE ENTRY DEFINTIONS
	$SECDEF			;SECTION DEFINITIONS (GSTE/PSTE)
	$SGNDEF			;SYSGEN VALUE DEFINITIONS
	$VADEF			;DEFINE VIRTUAL ADDRESS FIELDS
	$WSLDEF			;WORKING SET LIST DEFINITIONS

;
; EQUATES:
;

P1PTECNT=0				; INITIALIZE COUNT OF P1 PTES
PFILPGCNT=0				; INITIALIZE COUNT OF PAGE FILE PAGES
KSTACK=3				; THREE PAGES OF KERNEL STACK
ESTACK=8				; EIGHT PAGES OF EXEC STACK
SSTACK=16				; SIXTEEN PAGES OF SUPER STACK
PARSIZE=46				; SIZE OF PROCESS ALLOCATION REGION
					; IN PAGES
IMGACTBUF=8				; EIGHT PAGES FOR IMAGE ACTIVATE BUFFER
					; FOUR FOR TOP LEVEL CALL, FOUR FOR
					; ONE RECURSIVE CALL.

SEGSIZ=60*512				; SIZE OF PROCESS I/O SEGMENT
DBGPTCNT=1				; NUMBER OF DEBUG AREA PAGE TABLES

	.IF	NDF,LIBSWITCH		; IF EXECUTIVE, DEFINE THESE GLOBALLY
PIO$C_SEGSIZ==SEGSIZ
SWP$C_DBGPTCNT==DBGPTCNT
SWP$C_KSTACK==KSTACK
	.ENDC

COMMON=4				; FOUR PAGES FOR USER COMMON
					; FOUR PAGES FOR DEC COMMON

;
; MACROS:
;

	.MACRO	WSL	SYM,TYPE	; MAKE VALID WS LIST ENTRY
	.LONG	SYM!WSL$M_VALID!WSL$C_'TYPE	; SET VALID BIT
	.ENDM	WSL

	.MACRO	CTL	SYM
	.IF	NDF,LIBSWITCH
CTL$'SYM==.-CTLVECPAG+VECTORS
	.IFF
CTL$'SYM=.-CTLVECPAG+VECTORS
	.ENDC
	.ENDM	CTL

	.MACRO	PHD	SYM
	.=PHD...+PHD$'SYM
	.ENDM	PHD


	.MACRO	PIO	SYM		; DEFINE PROCESS I/O SEGMENT SYMBOL
PIO$'SYM==PIOBASE+<.-PIO>		;
	.ENDM	PIO

	.MACRO	PIOL	SYM		; DEFINE PROCESS I/O LOCAL SYMBOL
PIOL'SYM=PIOBASE+<.-PIO>		;
	.ENDM	PIOL			;

;
; P1PTE - GENERATE PTES FOR CONTROL REGION PAGE TABLE
;

	.MACRO	P1PTE	NUM,ACCESS=NA,OWNER=K,STATE,SYM
	.IF	NB,SYM
	SYM=VA...
	.ENDC

	.REPT	NUM
	.=.-4
	.IF	IDN,<STATE>,<VALID>
	TMP...=<1@31>
	.IFF
	TMP...=0
	.ENDC

	.IF	IDN,<STATE>,<DZRO>
	PFILPGCNT=PFILPGCNT+1
	.ENDC

	.IF	IDN,<STATE>,<PFIL>
	TMP...=PTE$M_TYP1
	PFILPGCNT=PFILPGCNT+1
	P1PTECNT=P1PTECNT+1
	.ENDC
	.LONG	PTE$C_'ACCESS!PTE$C_'OWNER'OWN!TMP...

	.=.-4
	VA...=VA...-^X200
	.ENDR
	.ENDM	P1PTE

	.PAGE

	.IF	DF,LIBSWITCH		; FOR USRVECTOR MODULE,
	.PSECT	$ABS$,ABS		; DO NOT GENERATE ANY STORAGE
	.=0
	.IFF				; ELSE,

	.PSECT	AEXENONPAGED
SWP$GL_SHELIO::				; I/O PAGE COUNT FOR SHELL
	.LONG	SWP$C_SHELLSIZ		;
;
;	WARNING: SWP$C_SHLP1PT MUST BE MANUALLY COMPUTED SINCE IT IS USED
;		 TO ALLOCATE THE SPACE FOR P1 PAGE TABLE ENTRIES.  IF UPDATES
;		 ARE MADE THAT INTRODUCE MORE P1 PAGE TABLE ENTRIES, THEN
;		 VERIFY THAT THEY STILL FIT IN THE NUMBER OF PAGES PROVIDED
;
SWP$C_SHLP1PT==2			; COUNT OF BASIC P1 PAGE TABLES FOR SHELL
	.PSECT	YYSHELLPAGED,PAGE	; SHELL AT END OF PAGEABLE EXEC
SHELL:					; BASE OF SHELL SWAP IMAGE
SWP$GL_SHELLBAS::			; 
	.PAGE
	.SBTTL	SHELL PROCESS HEADER
;
;	PROCESS HEADER FOR SHELL PROCESS
;

PHD...=.				; BASE OF PROCESS HEADER
	.BLKB	PHD$C_LENGTH		; RESERVE SPACE FOR HEADER

;
;	WORKING SET LIST
;
; PAGES DESCRIBED IN THE WORKING SET LIST MUST OCCUR IN THE SAME ORDER
; WITHIN THE PROCESS BODY.
;
	.ALIGN	LONG			; AT LONGWORD RESOLUTION
WSL...=.				; BASE OF WORKING SET LIST

	WSL	<<KSPINI-<1*512>>!WSL$M_WSLOCK>,PROCESS; KERNEL STACK PAGE 1
	WSL	<<KSPINI-<2*512>>!WSL$M_WSLOCK>,PROCESS; KERNEL STACK PAGE 2
	WSL	<<KSPINI-<3*512>>!WSL$M_WSLOCK>,PROCESS; KERNEL STACK PAGE 3
	WSL	<VECTORS!WSL$M_WSLOCK>,PROCESS	; VECTOR PAGE
DYNWSL=.				; START OF DYNAMIC WORKING SET
	WSL	PIOBASE!WSL$M_MODIFY,PROCESS	; PROCESS I/O SEGMENT BASE
	WSL	PRCALLREG!WSL$M_MODIFY,PROCESS	; PROCESS ALLOCATION REGION

FWSL...=.				; FREE WORKING SET LIST
NDYN=<FWSL...-DYNWSL>@-2		; NUMBER OF DYNAMIC ENTRIES IN SHELL
SWP$C_NDYN==NDYN			; GLOBAL NAME FOR NUMBER OF DYNAMIC PAGES
	.ALIGN	PAGE			; GET TO END OF PAGE
SAV...=.				;

TMP...=<DYNWSL-PHD...>@-2		; BASE OF FLUID WORKING SET LIST

	PHD	W_WSLOCK		; POINTER TO START OF LOCKED PAGES
	.WORD	TMP...			;

	PHD	W_WSDYN			; POINTER TO START OF DYNAMIC PAGES
	.WORD	TMP...			;

	PHD	W_WSLIST		;
	.WORD	<WSL...-PHD...>@-2	; START OF WORKING SET LIST
	PHD	W_WSNEXT		; NEXT WORKING SET ENTRY
	.WORD	<TMP...+NDYN-1>		;



	PHD	L_FREP1VA		; VA OF FIRST FREE PAGE IN P1 SPACE
	.LONG	VA...-512		;

	PHD	Q_PRIVMSK		; ENABLE ALL PRIVILEGES
	.LONG	-1,-1			;

	PHD	W_QUANT			; QUANTUM OF ONE SECOND
	.WORD	-100			;

	PHD	L_KSP			; STACK POINTERS
	.LONG	KSPINI			; KERNEL STACK POINTER
	.LONG	ESPINI			; EXECUTIVE STACK POINTER
	.LONG	SSPINI			; SUPER STACK POINTER
					; NO INITIAL USER STACK

	PHD	L_PC			; INITIAL PROGRAM COUNTER
	.LONG	EXE$PROCSTRT		; START PROCESS

	PHD	L_PSL			; PROGRAM STATUS LONGWORD
	.LONG	IPL$_ASTDEL@PSL$V_IPL	; MUST RUN AT ASTDEL
	PHD	L_P0BR			; P0 BASE REGISTER
	.LONG	0			; RELATIVE OFFSET

	PHD	L_P0LRASTL		; NO AST PENDING, POLR = 0
	.LONG	<4@PHD$V_ASTLVL>	;

	PHD	L_P1BR			; SVA OF P1 PAGE TABLE BASE
	.LONG	-<1@23>			; 

	PHD	L_P1LR			; P1 LENGTH REGISTER
	.LONG	<1@21>-P1PTLEN		; 

	PHD	L_FREPTECNT		; FREE PTE'S BETWEEN P0 AND P1 PT
	.LONG	-<1+<<1@31-VA...>@-9>>	; (NUMBER OF AVAILABLE LONGWORDS

	PHD	W_PRCLM			; SUB PROCESS LIMIT
	.WORD	4			; ALLOW FOUR

	PHD	W_WSFLUID		; GUARANTEED FLUID PAGE COUNT
	.WORD	10			; GUESS AT TEN FOR NOW (WAG)

	PHD	B_DFPFC			; DEFAULT PAGE FAULT CLUSTER
	.BYTE	16			;

	PHD	B_CPUMODE		; ACCESS MODE FIELD FOR CPU TIME LIMIT
	.BYTE	PSL$C_USER		;  EXPIRATION AST STARTS WITH USER MODE

	.=SAV...			; RESTORE LOCATION COUNTER
	.PAGE
	.SBTTL	SHELL PROCESS PAGE TABLES
;
;
;	SHELL PROCESS PAGE TABLES
;
;

P1PTBAS=.				;

	TMP=<SWP$C_SHLP1PT*512>		; ALLOCATE SPACE FOR PAGE TABLES
	.BLKB	TMP			; ALLOCATE SPACE FOR PAGE TABLES
SAV...=.				; REMEMBER BASE OF PAGE TABLES

	.IFTF				; ASSEMBLE FOLLOWING FOR BOTH
					; SHELL AND USRVECTOR MODULES:

;
;	INITIALIZE VIRTUAL ADDRESS BASE
;
	VA...=1@31			;

;	P1PTE	128*DBGPTCNT		; DEBUGGER CONTEXT AREA
	VA...=VA...-<DBGPTCNT*128*512>	; ACCOUNT FOR IT IN VA...
DBGAREA=VA...				; ADDRESS OF DEBUG AREA
	P1PTE	1,URKW,K,PFIL		; VECTOR PAGE
VECTORS=VA...				;

	.IFF				; ASSEMBLE REST ONLY FOR SHELL MODULE:

CTL$GL_VECTORS==VECTORS			; BASE OF VECTOR PAGE
	P1PTE	16			; PAGES FOR SYSTEM SERVICE VECTORS
P1SYSVECTORS==VA...
	P1PTE	SSTACK,URSW,S,DZRO,SSPINI	; SUPERVISOR STACK
	P1PTE	ESTACK,SREW,E,DZRO,ESPINI	; EXECUTIVE STACK
	P1PTE	KSTACK,SRKW,K,PFIL,KSPINI	; KERNEL STACK
CTL$GL_KSPINI==KSPINI			; INITIAL KERNEL STACK
CTL$GL_KSTKBAS==VA...			; MAXIMUM TOP OF KERNEL STACK
	P1PTE	1			; NULL STOPPER PAGE
	P1PTE	1,UW,S,DZRO		; IMAGE HEADER BUFFER
MMG$IMGHDRBUF==VA...			; ADDRESS OF IMAGE HEADER BUFFER
	P1PTE	2,UREW,K,DZRO		; VECTORS FOR USER SYS SRV & ERR MSGS
CTL$A_DISPVEC==VA...			; ADR OF VECTOR PAGES FOR SYS SRV/ERRMSG
	P1PTE	4,UW,U,DZRO		; DEBUGGER CONTEXT
	P1PTE	IMGACTBUF,UW,U,DZRO	; IMAGE ACTIVATOR SCRATCH PAGES (8)
MMG$IMGACTBUF==VA...			; ADR OF IMAGE ACTIVATOR SCRATCH PAGES
CLIDATAEND=VA...
	P1PTE	6,URSW,S,DZRO		; COMMMAND INTERPRETER DATA PAGES
CLIDATAPAG=VA...			; BASE ADDRESS OF CLI DATA PAGE
	P1PTE	<PARSIZE-1>,UREW,K,DZRO	; PROCESS ALLOCATION REGION
	P1PTE	1,UREW,K,PFIL		; HEADER FOR PROCESS ALLOCATION REGION
CTL$A_PRCALLREG==VA...
PRCALLREG=VA...				; BASE ADDRESS OF ALLOCATION AREA
CTL$C_PRCALLSIZ==PARSIZE		; SIZE OF PROCESS ALLOCATION REIGON
	P1PTE	1,UREW,E,DZRO		; IMAGE ACTIVATOR CONTEXT
IMGACTCTX=VA...
	P1PTE	2			; UNUSED PAGES
;
;	THE FOLLOWING PAGE IS A USER-MODE WRITABLE CONTEXT PAGE
;	FOR MISC. USER-MODE PACKAGES THAT ARE MAINTAINED BY VMS.
;	(SEE DETAILED ALLOCATION OF PAGE BELOW)
;
	P1PTE	1,UW,K,DZRO		; GLOBAL USER-MODE OWN STORAGE PAGE
UWVECPAG=VA...
;
;	THE FOLLOWING PAGE IS A WRITABLE CONTEXT PAGE FOR
;	THE USE OF THE COMPATIBILITY MODE EMULATOR AND EXCEPTION
;
	P1PTE	1,UW,K,DZRO		; WRITABLE PAGE FOR COMPATIBILITY MODE
CTL$AG_CMEDATA==VA...			; 
;
;	THE FOLLOWING PAGES ARE FOR USE BY BASIC/BASIC-PLUS TO PROVIDE
;	THE "CORE COMMON" REQUIRED TO PASS DATA WHEN CHAINING FROM IMAGE
;	TO IMAGE.  AN IDENTICAL AREA, NEGATIVELY DISPLACED HAS BEEN ALLOCATED
;	FOR USERS AND CSS.
;
	P1PTE	COMMON,UW,K,DZRO	; DEC "CORE COMMON" PAGES
CTL$A_COMMON==VA...			; BASE ADDRESS
	P1PTE	COMMON,UW,K,DZRO	; USER "CORE COMMON" PAGES
	P1PTE	<<SEGSIZ@-9>-1>,UREW,E,DZRO
	P1PTE	1,UREW,E,PFIL		;
PIOBASE=VA...				;
USPINI=VA...				; USER STACK AREA

END...=.				; END OF CONTROL REGION

P1PTLEN=<1@31-VA...>@-9			; ENTRIES IN P1PT

SWP$C_SHLFPTE==<<.-P1PTBAS>@-2>	; FREE P1PT IN BASIC P1 PAGE TABLES
;
; RESTORE LOCATION POINTER
;
	.=SAV...			; FINISHED WITH PAGE TABLES
	P1PTECNTF=P1PTECNT		; SATISFY FORWARD REFERENCE
	PFILPGCNT=PFILPGCNT-KSTACK-1	; NO PAGE FILE FOR KERNEL STACK OR VECTORS
	SWP$C_SHELLPFIL==PFILPGCNT	; DEFINE GLOBAL VALUE FOR SHELL PAGE FILE
					; REQUIREMENT
	.PAGE
	.SBTTL	BODY OF SHELL PROCESS
;
;	BODY OF SHELL PROCESS
;
	.=SAV...			; POSITION TO END OF HEADER
;-------------------------------------------------------------------------
;
;	VECTOR PAGE
;
;-------------------------------------------------------------------------
SWP$AL_PTRPAG==.-SHELL			; ADDRESS IN SWAPPER MAP

	.IFT				; IF USRVECTOR MODULE,
	.=VECTORS			; SHOW ACTUAL ADDRESSES IN LISTING

	.IFTF				; ASSEMBLE FOLLOWING FOR BOTH
					; SHELL AND USRVECTOR MODULES:

CTLVECPAG=.				; BASE OF VECTOR PAGE
	CTL	GW_NMIOCH		; NUMBER OF CHANNELS
	.WORD	0			; FILLED IN IN PROCSTRT
	
	CTL	GW_CHINDX		; MAXIMUM CHANNEL INDEX
	.WORD	0			; FILLED IN IN PROCSTRT

	CTL	GL_RMSPP		; RMS PROCESS I/O SEGMENT POINTER
	.LONG	PIOBASE			;

	CTL	GL_RMSIP		; RMS IMAGE I/O SEGMENT POINTER
	.LONG	0			;

;
;	ARRAY OF STACK POINTERS
;
;	THE -1 ENTRY OF CTL$AL_STACK IS USED TO DETERMINE THE MAXIMUM
;	EXTENT OF THE KERNEL STACK.
;
	.LONG	CTL$GL_KSTKBAS		; MAXIMUM TOP OF KERNEL STACK
	CTL	AL_STACK		; STACK POINTER RESTART ARRAY
	.LONG	KSPINI			; KERNEL STACK POINTER
	.LONG	ESPINI			; EXEC STACK POINTER
	.LONG	SSPINI			; SUPERVISOR STACK POINTER
	.LONG	USPINI			; USER STACK POINTER

	CTL	GL_LOGTBL		; PROCESS LOGICAL NAME TABLE POINTER
	.LONG	0			; LIST HEADER
	.LONG	0			; NO MORE BACK LINKS (SPARE NOW)

;
; THE FOLLOWING THREE VECTORS MUST BE ADJACENT
;

	CTL	GL_CMSUPR		; SUPERVISOR CHANGE MODE DISPATCHER
	.LONG	0			; NULL

	CTL	GL_CMUSER		; USER CHANGE MODE DISPATCHER
	.LONG	0			; NULL

	CTL	GL_CMHANDLR		; COMPATIBILITY MODE HANDLER
	.LONG	0

	CTL	AQ_EXCVEC		; PRIMARY/SECONDARY EXCEPTION VECTORS
	.LONG	0			; KERNEL MODE PRIMARY
	.LONG	0			; KERNEL MODE SECONDARY
	.LONG	0			; EXEC MODE PRIMARY
	.LONG	0			; EXEC MODE SECONDARY
	.LONG	0			; SUPERVISOR MODE PRIMARY
	.LONG	0			; SUPERVISOR MODE SECONDARY
	.LONG	0			; USER MODE PRIMARY
	.LONG	0			; USER MODE SECONDARY

	CTL	GL_THEXEC		; EXECUTIVE TERMINATION HANDLER
	.LONG	0			; NULL

	CTL	GL_THSUPR		; SUPERVISOR TERMINATION HANDLER
	.LONG	0			; NULL

;	CTL	GL_THUSER		; USER TERMINATION HANDLER
	.LONG	0			; NULL

;	FORMER LOCATION OF COMPATIBILITY MODE CONTEXT
	CTL	GQ_COMMON		; CORE COMMON DESCRIPTOR
	.LONG	512*COMMON		; SIZE IN BYTES
	.LONG	CTL$A_COMMON		; AND ADDRESS

	CTL	GL_GETMSG		; PER-PROCESS VECTOR TO USER MESSAGE
	.LONG	0			; DISPATCHER

	CTL	AL_STACKLIM		; STACK LIMIT ARRAY (INDEXED BY MODE)
	.LONG	CTL$GL_KSTKBAS		; KERNEL STACK LO (TOP) LIMIT
	.LONG	KSPINI			; EXEC   STACK LO (TOP) LIMIT
	.LONG	ESPINI			; SUPER  STACK LO (TOP) LIMIT
	.LONG	0			; USER STACK (NOT CHECKED)

	CTL	GL_CTLBASVA		; BASE CONTROL REGION ADDRESS
	.LONG	0			; FILLED IN BY PROCSTRT

	CTL	GL_IMGHDRBF		; ADDRESS OF IMAGE ACTIVATOR'S IMAGE
					; HEADER BUFFER, IF IMAGE IS ACTIVE;
	.LONG	0			; 0 IF NO IMAGE ACTIVE

	CTL	GL_RUNDNFLG		; IMAGE RUN DOWN CONTROL FLAGS
	.LONG	0

	.IF	NDF,LIBSWITCH		; IF SHELL MODULE,
	$GBLINI	GLOBAL			; DEFINE THESE AS GLOBAL SYMBOLS
	.ENDC
	$VIELD	RND,0,<-		; RUNDOWN CONTROL BITS GLOBALLY
		IACLOCK,-		; IMAGE ACTIVATOR LOCK MUST BE RESET
		>
	$GBLINI				; RESET GLOBAL INDICATOR

	CTL	GL_PHD			; ADDRESS OF PHD WINDOW
	.LONG	0			; INIT BY INSWAP

	CTL	GQ_ALLOCREG		; HEAD OF PROCESS ALLOCATION REGION POOL
	.LONG	PRCALLREG		; ADDRESS 
	.LONG	0			;

	CTL	GQ_MOUNTLST		; MOUNTED DEVICE LIST
	.LONG	CTL$GQ_MOUNTLST		; FORWARD LINK
	.LONG	CTL$GQ_MOUNTLST		; BACKWARD LINK ( LIST EMPTY )

;************************************************************************
; NOTE: The order of the accounting data between CTL$T_USERNAME and
;	CTL$T_REMOTEID should be preserved!
;************************************************************************

	CTL	T_USERNAME		; USER NAME
	.ASCII	/SYSTEM      /		; ASSUMED USER NAME SUITABLE FOR 
					; SYSINIT AND STARTUP COMMAND FILE

	CTL	T_ACCOUNT		; ACCOUNT NAME
	.ASCII	/STARTUP /		; ASSUMED NULL ACCOUNT NAME

	CTL	GQ_LOGIN		; SYSTEM TIME AT PROCESS CREATION
	.LONG	0,0			;

	CTL	GL_FINALSTS		; FINAL EXIT STATUS FOR PROCESS
	.LONG	0			; 

	CTL	GL_WSPEAK		; PEAK WORKING SET SIZE
	.LONG	0			;

	CTL	GL_VIRTPEAK		; PEAK VIRTUAL SIZE
	.LONG	0			;

	CTL	GL_VOLUMES		; COUNT OF VOLUMES MOUNTED
	.LONG	0			;

	CTL	GQ_ISTART		; IMAGE ACTIVATION TIME
	.LONG	0,0

	CTL	GL_ICPUTIM		; INITIAL IMAGE CPU TIME
	.LONG	0

	CTL	GL_IFAULTS		; INITIAL IMAGE FAULT COUNT
	.LONG	0

	CTL	GL_IFAULTIO		; INITIAL IMAGE FAULT I/O COUNT
	.LONG	0

	CTL	GL_IWSPEAK		; IMAGE WORKING SET PEAK
	.LONG	0

	CTL	GL_IPAGEFL		; IMAGE PAGE FILE PEAK USAGE
	.LONG	0

	CTL	GL_IDIOCNT		; INITIAL IMAGE DIRECT I/O COUNT
	.LONG	0

	CTL	GL_IBIOCNT		; INITIAL IMAGE BUFFERED I/O COUNT
	.LONG	0

	CTL	GL_IVOLUMES		; INITIAL IMAGE VOLUME MOUNT COUNT
	.LONG	0

	CTL	T_NODEADDR		; REMOTE NODE ADDRESS (BINARY)
	.BYTE	0				; BYTE COUNT BYTE
	.BLKB	6				; 6 BYTES MAX

	CTL	T_NODENAME		; REMOTE NODE NAME (ASCII)
	.BYTE	0				; BYTE COUNT BYTE
	.BLKB	6				; 6 CHARACTERS MAX

	CTL	T_REMOTEID		; REMOTE ID
	.BYTE	0				; BYTE COUNT BYTE
	.BLKB	16				; 16 CHARACTERS MAX

	.BLKB	1			; LONGWORD ALIGN SECTION

;********************************
; End of adjacent accounting data
;********************************

	CTL	GQ_PROCPRIV		; PROCESS PRIVILEGE MASK
	.LONG	-1,-1			;  ALL PRIVILEGES PERMITTED

	CTL	GL_USRCHMK		; PER-PROCESS VECTOR TO USER CHANGE MODE
	.LONG	0			; TO KERNEL HANDLER

	CTL	GL_USRCHME		; PER-PROCESS VECTOR TO USER CHANGE MODE
	.LONG	0			; TO EXECUTIVE HANDLER

	CTL	GL_POWERAST		; POWER FAIL AST ADDRESS
	.LONG	0			;
	CTL	GB_PWRMODE		; ACCESS MODE FOR POWER FAIL AST
	.BYTE	0			;

	CTL	GB_SSFILTER		; SYS SERV INHIBIT FILTER MASK
	.BYTE	0	
	.BLKB	2			; SPARE
	.PAGE

;
;	ARRAY OF FINAL EXCEPTION VECTORS - ONE PER MODE
;
;	THESE VECTORS ARE USED TO LOCATE AN EXCEPTION HANDLER WHEN ALL
;	OTHER METHODS FAIL.  PERMITS DEBUGGERS TO RECEIVE CONTROL EVEN
;	WHEN THE STACK IS CLOBBERED.
;
	CTL	AL_FINALEXC		; FINAL EXCEPTION HANDLER ARRAY
	.LONG	EXE$EXCPTN		; KERNEL MODE
	.LONG	EXE$EXCPTNE		; EXECUTIVE MODE
	.LONG	0			; SUPERVISOR MODE
	.LONG	0			; USER MODE
;
;	POINTER TO BASE OF CHANNELS
;
	CTL	GL_CCBBASE		; BASE OF I/O CHANNELS
	.LONG	0			; FILLED IN IN PROCSTRT
	CTL	GQ_DBGAREA		; DEBUG AREA
	.LONG	64*1024			; SIZE
	.LONG	DBGAREA			; ADDRESS
;
;  POINTER TO RMS IMAGE
;
	CTL	GL_RMSBASE
	.LONG	0			; POINT TO RMS IN SYSTEM SPACE
;
;	PROCESS PERMANENT MESSAGE SECTION POINTER AND DEFAULT DISPLAY FLAGS
;
	CTL	GL_PPMSG		; ADDRESS OF PROCESS PERM. MSG SECTION
	.QUAD	0			; STARTING/ENDING ADDRESS OF SECTION

	CTL	GB_MSGMASK		; DEFAULT MESSAGE DISPLAY FLAGS
	.BYTE	15			; DEFAULT: FAC,SEV,IDENT AND TEXT (ALL)

	CTL	GB_DEFLANG		; DEFAULT MESSAGE LANGUAGE
	.BYTE	0			; (CURRENTLY UNUSED)

	CTL	GW_PPMSGCHN		; CHANNEL TO PROCESS PERM. MESSAGE
	.WORD	0			; SECTION (MAPPED IN CTL$GL_PPMSG)

	CTL	GL_USRUNDWN		; PER-PROCESS VECTOR TO USER RUNDOWN
	.LONG	0			;  SERVICE

	CTL	GL_PCB			; ADDRESS OF PROCESS CONTROL BLOCK
	.LONG	0			; INIT BY PROCSTRT

	CTL	GL_RUF			; POINTER TO RECOVERY UNIT BLOCKS
	.LONG	0

	CTL	GL_SITESPEC		; SITE-SPECIFIC PER-PROCESS CELL
	.LONG	0

	CTL	GL_KNOWNFIL		; PROCESS KNOWN FILE LIST POINTER
	.LONG	0

	CTL	AL_IPASTVEC		; VECTOR OF IPAST ADDRESSES
	.LONG	0,0,0,0,0,0,0,0

	CTL	GL_CMCNTX		; ADDRESS OF AME CONTEXT PAGE
	.LONG	CTL$AL_CMCNTX

	CTL	GL_IAFLNKPTR		; ADDRESS OF IAF LIST (FOR DEBUGGER)
	.LONG	CTL$GL_IAFLINK

;******************************************************************************
;
;	END OF VECTOR PAGE
;
;******************************************************************************
CTLVECEND=.
	.IF GREATER	<CTLVECEND-CTLVECPAG>-512
	.ERROR		; *** VECTOR PAGE NOW LARGER THAN A PAGE ***
	.ENDC

	.IFF				; ASSEMBLE REST ONLY FOR SHELL MODULE:

	.PAGE
	.SBTTL	PROCESS I/O SEGMENT
;----------------------------------------------------------------------------
;
;	PROCESS I/O SEGMENT INITIAL CONTENT
;
;----------------------------------------------------------------------------

	.ALIGN	PAGE			; PAGE BOUNDARY
PIO:					; BASE OF PROCESS I/O SEGMENT

	PIO	GL_FMLH			; FREE MEMORY LIST HEAD
	.LONG	PIOLFREE,PIOLFREE	;

	PIO	GL_IIOFSPLH		; FREE LIST HEADER FOR IMAGE I/O SEG
	.LONG	PIO$GL_IIOFSPLH		;
	.LONG	PIO$GL_IIOFSPLH		;

	PIO	GW_STATUS		; RMS OVERALL STATUS
	.WORD	0			;


	PIO	GT_ENDSTR		; END OF DATA STRING
	.BLKB	16			; (COUNTED STRING)

	PIO	GW_DFPROT		; DEFAULT FILE PROTECTION
	.WORD	^XFA00			; SYS:RWED, OWN:RWED, GROUP: RE, WORLD:N

	PIO	GB_DFMBC		; DEFAULT MULTI-BLOCK COUNT
	.BLKB	1

	PIO	GB_DFMBFSDK		; DEFAULT MULTI-BUFFER COUNT SEQ. DISK
	.BLKB	1

	PIO	GB_DFMBFSMT		; DEFAULT MULTI-BUFFER COUNT MAGTAPE
	.BLKB	1

	PIO	GB_DFMBFSUR		; DEFAULT MULTI-BUFFER COUNT UNIT REC.
	.BLKB	1

	PIO	GB_DFMBFREL		; DEFAULT MULTI-BUFFER COUNT RELATIVE
	.BLKB	1

	PIO	GB_DFMBFIDX		; DEFAULT MULTI-BUFFER COUNT INDEXED
	.BLKB	1

	PIO	GB_DFMBFHSH		; DEFAULT MULTI-BUFFER COUNT HASHED
	.BLKB	1

	PIO	GB_RMSCOMPAT		; Compatibility goals
	.BLKB	1			; RMS$C_CUR_VMS, CUR_RMS11, PRV_VMS
					; and PRV_RMS11

	PIO	GB_RMSPROLOG		; Structure level for RMS files
	.BLKB	1

	PIO	GW_RMSEXTEND		; Extend quantity for RMS files
	.BLKW	1

	.ALIGN	LONG

;
;	DEFAULT DIRECTORY INFORMATION
;
	PIO	GT_DDSTRING		; DEFAULT DIRECTORY STRING
TEMP$...=.
	.ASCIC	\[SYSEXE]\		; DEFAULT DIRECTORY STRING
	.BLKB	PQB$C_MAXDIRLEN-<.-TEMP$...>	; FILL TO MAXIMUM POSSIBLE SIZE

; THE DEFAULT DIRECTORY STRING IN THE PROCESS QUOTA BLOCK MOVED FROM A
; CREATOR PROCESS TO A NEWLY CREATED PROCESS MUST BE AT LEAST AS LARGE
; AS THE LARGEST DIRECTORY STRING ALLOWED BY RMS.

	ASSUME	PQB$C_MAXDIRLEN GE FWA$C_MAXDIRLEN

FIL$GT_DDSTRING==PIO$GT_DDSTRING	; FILE READ DEFAULT DIRECTORY STRING

	PIO	GL_DIRCACHE		; DIRECTORY CACHE LIST HEAD
	.LONG	PIO$GL_DIRCACHE		; EMPTY LIST
	.LONG	PIO$GL_DIRCACHE

	PIO	GL_DIRCFRLH		; FREE LIST FOR DIRECTORY CACHE NODES
	.LONG	0			;   (NOTE: SINGLY LINKED)

	.PAGE
;
;	PROCESS I/O SEGMENT CONTEXT AREA
;
	PIO	GW_PIOIMPA		;
	.WORD	0			; FLAGS
	.WORD	PRT$C_UREW		; I/O BUFFER PROTECTION
	.LONG	PIO$GL_FMLH+<3*512>	; ADDRESS OF FIRST FREE PIO SEGMENT PAGE
	.LONG	SEGSIZ-<3*512>		; SIZE OF FREE PAGE POOL

	PIOL	A1			; FREE PAGE LIST HEAD
	.LONG	PIOLA1,PIOLA1		; FREE LIST HEADER
	.BLKL	1			; SP SAVED LONGWORD
	.LONG	PIOLA10			; IFAB TABLE ADDRESS
	.LONG	PIOLA20			; IRAB TABLE ADDRESS
	.LONG	IMP$C_NPIOFILES		; # OF SLOTS PER TABLE

	PIOL	A10			; LINK TO NEXT TABLE SEGMENT
	.LONG	0			;
	.BLKL	IMP$C_NPIOFILES		; IFAB TABLE SLOTS

	PIOL	A20			; 
	.LONG	0			; LINK TO NEXT TABLE SEGMENT
	.BLKL	IMP$C_NPIOFILES		; IRAB TABLE SLOTS

	.PAGE
;
;	IMAGE I/O SEGMENT CONTEXT AREA
;
	PIO	GW_IIOIMPA		; IMAGE I/O IMPURE AREA
	.WORD	1			; FLAGS WITH IIO SEGMENT SET
	.WORD	PRT$C_UREW		; PROTECTION STO SET ON PAGES

	.LONG	0			; MUST BE INITIALIZED BY THE IMAGE
					; ACTIVATOR TO THE ADDRESS OF THE FIRST
					; PAGE IN THE IMAGE I/O SEGMENT.
					; (NOTE: THIS LONGWORD IS REFERENCED BY:
					; PIO$GW_IIOIMPA+IMP$L_IOSEGADDR)
	.LONG	0			; LENGTH OF IMAGE I/O SEGMENT IN BYTES
					; MUST BE INITIALIZED BY THE IMAGE ACTIVATOR.
					; (NOTE: THIS LONGWORD IS REFERENCED BY:
					; PIO$GW_IIOMPA+IMP$L_IOSEGLEN)

	PIOL	B1			;
	.LONG	PIOLB1,PIOLB1		; FREEPAGE LIST HEAD


	PIOL	B2			; 
	.BLKL	1			; SP SAVE LONGWORD

	.LONG	PIOLB10			; IFAB TABLE ADDRESS
	.LONG	PIOLB20			; IRAB TABLE ADDRESS
	.LONG	IMP$C_ENTPERSEG		; # OF SLOTS PER TABLE

	PIOL	B10			;
	.LONG	0			; LINK TO NEXT TABLE SEGMENT
	.BLKL	IMP$C_ENTPERSEG		; IFAB TABLE SLOTS

	PIOL	B20			; 
	.LONG	0			; LINK TO NEXT TABLE SEGMENT
	.BLKL	IMP$C_ENTPERSEG		; IRAB TABLE SLOTS

	PIO	AL_RMSEXH		; EXIT HANDLER CONTROL BLOCK
	.BLKL	2			;
	.LONG	1			; ARGUMENT COUNT
	.LONG	PIO$AL_RMSEXH+8		; STORE EXIT CODE OVER ARGUMENT COUNT

	PIOL	FREE			; FREE AREA IN END OF PAGE
FREE...:				; SAME VALUE FOR DIFFERENT LOCATION COUNTER
	.LONG	PIO$GL_FMLH		; FORWARD LINK
	.LONG	PIO$GL_FMLH		; BACKWARD LINK

	.LONG	PIOTMP...-FREE...	; SIZE OF FREE AREA
	.ALIGN	PAGE			; FILL END OF PAGE
PIOTMP...=.


	.PAGE
;----------------------------------------------------------------------------
;
;		PROCESS ALLOCATION REGION
;
;----------------------------------------------------------------------------

	.LONG	0			; FORWARD LINK 
	.LONG	512*PARSIZE		; AND SIZE OF FREE BLOCK
	.ALIGN	PAGE			; FILL REMAINDER OF PAGE
	.PAGE
	.SBTTL	INITIALZE SHELL WITH SYSGEN PARAMETERS
;++
; FUNCTIONAL DESCRIPTION:
;	SWP$SHELINIT IS CALLED BY THE SWAPPER FOLLOWING THE INSWAP OF A SHELL
;	PROCESS TO APPLY THE SYSGEN PARAMETERS AND CONFIGURE THE PROCESS
;	FOR THE PROPER WORKING SET SIZE AND VIRTUAL ADDRESS SPACE.
;	THIS CODE IS CONTAINED IN PAGES THAT ARE TO BECOME THE KERNEL
;	STACK FOR THE NEW PROCESS.
;
; CALLING SEQUENCE:
;	JSB	@#SWP$SHELINIT
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS
;	R9 - SWAPPER MAP POINTER
;	R10 - PTC$M_VALID!PTE$C_ERKW!PTE$M_MODIFY
;	R11 - SWAPPER END MAP POINTER
;
; OUTPUT PARAMETERS:
;	PHD AND CONTROL REGION FOR THE NEW PROCESS
;
;--
SWP$SHELINIT==.-SHELL			;
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER BASE ADDRESS
	MOVL	@#SWP$GL_SHELLSIZ,R0	; GET PAGES ALLOCATED FOR SHELL
	MOVAL	(R9)[R0],R11		; COMPUTE END ADDRESS IN MAP
	ASHL	#2,@#SWP$GL_SHELIO,R0	; GET I/O SIZE OF SHELL
	SUBL3	R9,R11,R1		; COMPUTE SIZE OF EXTENSION PAGES
	SUBL	R0,R1			; LESS I/O SIZE
	ROTL	#3,R1,R1		; CONVERT TO DOUBLE QUAD COUNT
	ROTL	#9,@#SWP$GL_SHELIO,R0	; COMPUTE ADDRESS AT END OF I/O TRANSFER
10$:	CLRQ	(R0)+			; CLEAR PAGES
	CLRQ	(R0)+			; NOT READ FROM SHELL
	SOBGTR	R1,10$			; 
	MOVL	R5,R2			; VA OF PHD
	JSB	@#MMG$SVAPTECHK		; GET SVA OF FIRST PHD PTE
	MOVL	(R9)+,(R3)+		; MAP PROCESS HEADER FIXED PAGE
	MOVZWL	@#SWP$GW_WSLPTE,R1	; GET COUNT OF ADDED PAGES FOR WSL+PST
	BEQL	30$			; BR IF NONE
	DECL	R1			; LESS FIXED HEADER PAGE
20$:	MOVL	-(R11),(R3)+		; MAP A WSL PAGE
	SOBGTR	R1,20$			; DO THEM ALL
30$:	MOVZWL	@#SWP$GW_EMPTPTE,R0	; GET COUNT OF EMPTY PAGES
	MOVAL	(R3)[R0],R3		; UPDATE MAP POINTER
	MOVZWL	@#SWP$GW_BAKPTE,R0	; GET COUNT OF BAK/WSL/VAL/LCK PTE
40$:	MOVL	-(R11),(R3)+		; MAP BAK/WSL/VAL/LCK PAGES
	SOBGTR	R0,40$			;
	INVALID				; INVALIDATE TRANSLATION BUFFER
;
;	ALL OF THE HEADER PAGES LESS PAGE TABLES HAVE NOW BEEN MAPPED
;
	MOVZWL	@#SWP$GW_IBALSETX,R8	; GET BALANCE SLOT INDEX
	MOVW	R8,PHD$W_PHVINDEX(R5)	; SET INTO PROCESS HEADER
	CVTWB	@#SGN$GW_DFPFC,PHD$B_DFPFC(R5)	; SET DEFAULT PAGE FAULT CLUSTER
	CLRL	R0			; COUNT MAXIMUM FREE SPACE TILL NOW
	MOVZWL	@#MMG$GW_MINPFIDX,R3	; START SCAN AT FIRST PAGE FILE
	MOVL	R3,R1			; SET DEFAULT PAGING FILE TO CHOOSE
	MOVL	@#MMG$GL_PAGSWPVC,R6	; GET ADDRESS OF PAGE FILES VECTOR
44$:	MOVL	(R6)[R3],R2		; GET ADDRESS OF NEXT PAGE FILE BLOCK
	BBC	#PFL$V_INITED,PFL$B_FLAGS(R2),46$ ; BRANCH IF NOT USABLE
	CMPL	PFL$L_FREPAGCNT(R2),R0	; CHOOSE PAGING FILE WITH MOST FREE PAGES
	BLEQ	46$			; BRANCH IF WE HAVE BETTER CANDIDATE
	MOVL	PFL$L_FREPAGCNT(R2),R0	; SAVE NEW FREE PAGE COUNT
	MOVL	R3,R1			; SAVE NEW INDEX
46$:	AOBLEQ	@#MMG$GL_MAXPFIDX,R3,44$; LOOP THROUGH ALL PAGE FILES
	MOVB	R1,PHD$B_PAGFIL(R5)	; SET PAGING FILE INDEX
	MOVB	@#SGN$GB_PGTBPFC,PHD$B_PGTBPFC(R5); SET SYSTEM DEFAULT PT CLUSTER
	MOVZWL	#<PHD$C_LENGTH@-2>,R6	; LW OFFSET TO WS LIST
	MOVW	R6,PHD$W_WSLIST(R5)	; INIT POINTER TO LIST BASE
	MOVL	@#SGN$GL_PHDPAGCT,R7	; GET TOTAL COUNT OF HEADER PAGES
	MOVZWL	@#SWP$GW_WSLPTE,R6	; GET COUNT OF WSL HEADER PAGES
	ASHL	#9,R6,PHD$L_PSTBASOFF(R5)	; SET END AS BASE FOR PST
	ADDW	@#SWP$GW_EMPTPTE,R6	; ASSUMES NO OVERFLOW POSSIBLE
	ASHL	#7,R6,R6		; CONVERT TO LONGWORD COUNT
	MOVW	R6,PHD$W_WSLX(R5)	; SET BASE OFFSET TO WSLX AREA
	ADDL	@#SGN$GL_PTPAGCNT,R7	; ADD PAGE TABLES TO COUNT
	ADDL3	#1,R7,R0		; ROUND TO LONGWORD SIZE
	DIVL	#2,R0			; 
	ADDL	R0,R6			; ALLOCATE SPACE IN WHOLE LONGWORDS
	MOVW	R6,PHD$W_BAK(R5)	; SET BASE OF BACKING STORE VECTOR
	ADDL	R7,R6			; ALLOCATE SPACE FOR BACKING STORE VECTOR
	MULL	#4,R6			; CONVERT TO BYTE OFFSET
	MOVL	R6,PHD$L_PTWSLELCK(R5)	; SET BASE OF LOCKED COUNT VECTOR
	MOVL	@#SGN$GL_PTPAGCNT,R7	; GET COUNT OF PAGE TABLES
	MOVAB	(R6)[R7],PHD$L_PTWSLEVAL(R5)	; ALLOCATE AND SET BASE OF VAL CNT
	MOVAB	@PHD$L_PTWSLEVAL(R5)[R5],R0	; SET BASE FOR VALID COUNT VEC
	MNEGL	#1,R2				; MINUS ONE FOR BACKGROUND
	MOVAB	@PHD$L_PTWSLELCK(R5)[R5],R1	; AND BASE FOR LOCKED COUNT
50$:	MOVB	R2,(R0)+		; INIT BOTH COUNT VECTORS TO MINUS ONE
	MOVB	R2,(R1)+		; 
	SOBGTR	R7,50$			; FOR ALL PAGE TABLE SLOTS
	ADDB	#4,-2(R1)		; COUNT OF LOCK PAGES FOR SHELL
	ADDB	#6,-2(R0)		; COUNT OF VALID PAGES
	MOVL	@#SGN$GL_PHDAPCNT,R6	; GET ACTUAL HEADER SIZE
	MOVZBL	@#SWP$GB_SHLP1PT,R0	; NUMBER OF PERM PAGE TABLES
	MOVW	R0,PHD$W_PTCNTLCK(R5)	; COUNT OF PT CONTAINING LOCKED PAGES
	MOVW	R0,PHD$W_PTCNTVAL(R5)	; COUNT OF PT CONTAINING VALID PAGES
	MOVW	R0,PHD$W_PTCNTACT(R5)	; COUNT OF ACTIVE PAGE TABLES
	MOVW	R0,PHD$W_PTCNTMAX(R5)	; COUNT OF PT WITH NON-ZERO ENTRIES
	ADDL	R0,R6			; MAKE ROOM IN WSLIST FOR HDR+PGTBLS
	MOVZWL	PHD$W_WSDYN(R5),R7	; GET INDEX TO CURRENT DYNAMIC ENTRIES
	PUSHL	R7			; SAVE POINTER FOR LATER USE
	ADDW	R6,PHD$W_WSLOCK(R5)	; CORRECT LOCK WSL INDEX
	ADDW	R6,PHD$W_WSDYN(R5)	; AND DYNAMIC INDEX
	ADDW	R6,PHD$W_WSNEXT(R5)	; AND NEXT POINTER
	ADDL3	R6,R7,R1		; SET DESTINATION INDEX
	MOVZBL	#SWP$C_NDYN,R0		; SET COUNT OF DYNAMIC PAGES
60$:	MOVL	(R5)[R7],(R5)[R1]	; MOVE A DYNAMIC WORKING SET PAGE
	INCL	R1			; NEXT DESTINATION
	INCL	R7			; NEXT WSL ENTRY
	SOBGTR	R0,60$			; MOVE ALL DYNAMIC PAGES
	MOVL	#<WSL$M_VALID-		; WSL ENTRIES FOR HEADER ARE VALID
		!WSL$M_WSLOCK-		; LOCKED,
		!WSL$C_PPGTBL-		; PROCESS PAGE TABLE,
		!VA$M_SYSTEM>,R8	; AND SYSTEM SPACE
	MOVL	R5,R2			; SET PHD ADDRESS TO GET SVAPTE
	JSB	@#MMG$SVAPTECHK		; SVAPTE TO R3
	MOVL	R8,R0			; MAKE WORKING COPY
	MOVZWL	@#SWP$GW_WSLPTE,R1	; COUNT OF WSLPTE 
	MOVL	(SP)+,R2		; RESTORE WORKING SET INDEX TO LOCKED
	BSBW	FILLPHD			; SET UP FOR VALID PHD PAGES
	MOVZWL	@#SWP$GW_EMPTPTE,R1	; GET COUNT OF EMPTY PTE AGAIN
	MOVAL	(R3)[R1],R3		; ADVANCE SPT ADDRESS
	ASHL	#9,R1,R1		; CONVERT TO BYTE COUNT
	ADDL	R1,R0			; AND UPDATE CURRENT VA
	MOVZWL	@#SWP$GW_BAKPTE,R1	; GET COUNT OF REMAINING HEADER PAGES
	BSBW	FILLPHD			; SET UP FOR VALID PHD PAGES
	MOVL	@#SGN$GL_PTPAGCNT,R1	; GET COUNT OF PAGE TABLES
65$:	MOVL	#PTE$C_ERKW,-4(R3)[R1]	; SET A DEMAND ZERO PAGE FOR PAGE TABLES
	SOBGTR	R1,65$			; INIT ENTIRE PAGE TABLE AREA
	MOVZBL	@#SWP$GB_SHLP1PT,R1	; GET COUNT OF P1 PAGE TABLES
	MNEGL	R1,R6			; NEGATE COUNT
	DECL	R6			; LESS ONE MORE FOR DEBUGGER PAGE
	ADDL	@#SGN$GL_PTPAGCNT,R6	; PAGE OFFSET TO PAGE TABLE
	MOVAL	(R3)[R6],R3		; COMPUTE SVAPTE
	ASHL	#9,R6,R6		; CONVERT TO BYTE OFFSET
	ADDL	R6,R0			; ADD TO CURRENT BASE WSL
	PUSHR	#^M<R1,R3>		; SAVE KEY REGS
	SUBL	S^#SWP$C_SHLP1PT,R1	; LESS STANDARD P1 PAGE TABLES
	BLEQ	80$			; BR IF NO EXTENSIONS
70$:	MOVL	-(R11),(R3)+		; STORE A PTE FOR EXTENSION
	SOBGTR	R1,70$			; DO ALL EXTENSION PAGE TABLES
80$:	MOVL	S^#SWP$C_SHLP1PT,R1	; SET COUNT OF STANDARD
90$:	MOVL	(R9)+,(R3)+		; STORE PTE FOR STANDARD
	SOBGTR	R1,90$			; DO ALL STANDARD P1PT
	POPR	#^M<R1,R3>		; RESTORE KEY REGISTERS
	BSBW	FILLPHD			; SET UP FOR VALID PHD PAGES
	ROTL	#9,@#SGN$GL_PHDPAGCT,R0	; OFFSET FOR P0BR
	ADDL	R0,PHD$L_P0BR(R5)	; FORM P0BR BASE VALUE
	ROTL	#9,@#SGN$GL_PTPAGCNT,R1	; OFFSET TO P1BR
	ADDL	R0,R1			; 
	ADDL	R1,PHD$L_P1BR(R5)	; FORM P1BR BASE VALUE
	SUBL	R0,PHD$L_FREP1VA(R5)	; COMPUTE CORRECT FREP1VA
	SUBL	R0,R1			; EXTRACT PT SIZE TOTAL
	ASHL	#-9,R0,R0		; BACK TO PAGE COUNT
	SUBL	R0,PHD$L_P1LR(R5)	; NOW CORRECT P1 LENGTH REGISTER
	ASHL	#-2,R1,R1		; COUNT OF AVAILABLE PTES
	SUBL	R0,R1			; DIMINISH BY PHD WINDOW SIZE
	ADDL	R1,PHD$L_FREPTECNT(R5)	; AND FORM COUNT OF FREE PTES
	MOVL	(R9)+,(R11)+		; RE-ARRANGE SWAP PAGE LIST TO 
	MOVL	(R9)+,(R11)+		; AGREE WITH WORKING SET LIST
	MOVL	(R9)+,(R11)+		; PTRPAG,PIO,PAR
	CLRL	(R11)+			; SET STOPPER IN MAP
	ADDL3	#512,PHD$L_FREP1VA(R5),-	; SET ADDRESS OF WINDOW
		@#<SWP$AL_PTRPAG+-	; INTO POINTER PAGE
		<CTL$GL_PHD-CTL$GL_VECTORS>>	; THROUGH SWAPPER MAP
	BBSS	#PCB$V_PHDRES,PCB$L_STS(R4),100$; MARK PHD RESIDENT
100$:					; 
	MOVZWL	PHD$W_WSLIST(R5),R0	; GET INDEX TO WS BASE
	DECL	R0			;
	ADDW3	R0,@#SGN$GL_MAXWSCNT,R1			; CALC MAX AUTHORIZED
	MOVW	R1,PHD$W_WSAUTH(R5)			; SET MAX AUTHORIZED
	MOVW	R1,PHD$W_WSQUOTA(R5)			; AND QUOTA
	MOVW	R1,PHD$W_WSEXTENT(R5)			; AND EXTENT
	MOVW	R1,PHD$W_WSAUTHEXT(R5)			; AND AUTHORIZED EXTENT
	MOVW	@#SGN$GW_MINWSCNT,PHD$W_WSFLUID(R5)	; SET FLUID REQUIREMENT
	MOVW	@#SGN$GW_DFWSCNT,R1			; GET DEFUALT WS SIZE
	ADDW	R1,R0					; CALC LAST
	MOVW	R0,PHD$W_WSLAST(R5)			; SET LAST
	MOVW	R0,PHD$W_DFWSCNT(R5)			; AND DEFAULT COUNT
	MOVW	R1,PHD$W_WSSIZE(R5)			; SET WS SIZE
	ADDL	R5,PHD$L_P0BR(R5)	; BIAS P0 BASE REGISTER
	ADDL	R5,PHD$L_P1BR(R5)	; AND P1 BASE REGISTER ALSO
;
;	REMAP SYSTEM SERVICE VECTORS FOR THIS PROCESS
;
	MOVL	#P1SYSVECTORS,R2	; PUT THEM HERE
	JSB	@#MMG$SVAPTECHK		; GET ADDRESS OF PTE FOR VECTORS
	MOVL	@#MMG$GL_SPTBASE,R0	; SYSTEM PAGE TABLE
	MOVZBL	#SGN$C_SYSVECPGS,R1	; NUMBER OF PAGES
110$:	BISL3	#PTE$M_WINDOW,(R0)+,(R3)+
	SOBGTR	R1,110$
	MNEGL	PCB$L_WSSWP(R4),PCB$L_WSSWP(R4)
					; INDICATE SHELL FINISHED TO SWAPPER
	MOVL	PCB$L_PQB(R4),R0	; GET ADDRESS OF PROCESS QUOTA BLOCK
	CVTLW	PQB$L_SWAPSIZE(R0),PHD$W_SWAPSIZE(R5) ; SET INITIAL SWAP ALLOCATION
	RSB				; RETURN

	.PAGE
	.SBTTL	FILLPHD - SETUP A VALID PHD PTE
;
;	R0 - WORKING SET LIST ENTRY, ADDRESS AND FLAGS (UPDATED)
;	R1 - COUNT OF PAGES TO FILL (UPDATED)
;	R2 - WORKING SET LIST INDEX (UPDATED)
;	R3 - SVAPTE FOR PHD PAGE (UPDATED)
;	R4 - PCB ADDRESS
;	R5 - PHD ADDRESS
;	R7 - SCRATCH
;	R8 - SCRATCH
;	R10 - PFN$C_ERKW!PFN$M_MODIFY!PFN$M_VALID
;
FILLPHD:				; SETUP VALID PHD PTES
10$:	MOVL	R0,(R5)[R2]		; STORE WORKING SET LIST ENTRY
	BICL3	R10,(R3)+,R7		; GET PFN FROM SPT
	PUSHL	@#PFN$AB_STATE		; STACK ADDRESS BASE FOR PFN STATE
	MOVB	#<PFN$C_ACTIVE!PFN$M_MODIFY>,@(SP)+[R7]	; MARK PAGE ACTIVE
	PUSHL	@#PFN$AB_TYPE		; STACK ADDRESS BASE FOR PFN TYPE
	MOVB	#PFN$C_PPGTBL,@(SP)+[R7]; SET PAGE TYPE TO PAGE TABLE
	PUSHL	@#PFN$AL_BAK		; STACK ADDRESS BASE FOR PFN BAK
	MOVZBL	PHD$B_PAGFIL(R5),R8	; GET PAGE FILE NUMBER
	ROTL	#PFN$V_PGFLX,R8,@(SP)+[R7]	; SET BACKING STORE ADDRESS
	PUSHL	@#PFN$AL_PTE		; STACK ADDRESS OF PFN PTE BACK POINTER
	MOVAL	-4(R3),@(SP)+[R7]	; SET PTE BACK POINTER FOR PAGE
;
;  The following use of the PFN_REFERENCE macro must force absolute addressing
;  because of the peculiar method in which this code executes. In addition, 
;  this code is not a part of the nonpaged executive and cannot have its opcode
;  automatically fixed up by INIT.
;
	PUSHL	@#PFN$Ax_WSLX		; STACK BASE ADDRESS OF WSLX VECTOR
		PFN_REFERENCE	-
	MOVW	<R2,@(SP)+[R7]>,- 	; SET WSLX FOR PAGE
		LONG_OPCODE=MOVZWL,-
		IMAGE=SHELL,-
		MODE=@#			; FORCE POSITION INDEPENDENCE
	INCL	R2			; NEXT WORKING SET LIST ENTRY
	MOVAL	512(R0),R0		; NEXT VA
	SOBGTR	R1,10$			; FILL ALL REQUESTED PAGES
	RSB				; AND RETURN

	.ALIGN	PAGE			; PAGE ALIGN
SWP$C_SHELLSIZ=<.-SHELL>@-9		; SIZE OF SHELL PROCESS IN PAGES
	.IF GT	SWP$C_SHELLSIZ-8
	.ERROR	SWP$C_SHELLSIZ; Shell size changed, update swapper and FREELIM
	.ENDC

	.PAGE
	.SBTTL	COMMAND LANGUAGE INTERPRETER DATA AREA
;----------------------------------------------------------------------------
;		GENERIC COMMAND LANGUAGE INTERPRETER DATA
;----------------------------------------------------------------------------

	.PSECT	$ABS$,ABS
	.=CLIDATAPAG			; SET BASE VALUE FOR REGION
CTL$AL_CLICALBK::			; CALL BACK VECTOR FOR CLI
	.BLKL	1			; 
	.BLKL	1			; ALLOW FOR EXPANSION
CTL$AG_CLIMAGE::
	.BLKL	2			; VA RANGE INTO WHICH CLI IS MAPPED


CTL$AG_CLIDATA::			; START OF DATA AREA
CTL$C_CLIDATASZ==CLIDATAEND-CTL$AG_CLIDATA	; SIZE OF DATA AREA

	.PAGE
	.SBTTL	COMPATIBILITY MODE EMULATOR CONTEXT PAGE
;----------------------------------------------------------------------------
;	COMPATIBILITY MODE EMULATOR CONTEXT PAGE
;----------------------------------------------------------------------------
	.=CTL$AG_CMEDATA		; POINT TO START OF AREA
CTL$AL_CMCNTX::				; COMPATIBILITY MODE REGISTER CONTEXT
	.BLKL	10			; SAVED BY EXCEPTION

	.PAGE
	.SBTTL	GLOBAL USER-MODE CONTEXT PAGE
;----------------------------------------------------------------------------
;	GLOBAL USER-MODE-ONLY CONTEXT PAGE
;
;	This page may ONLY be used by user-mode code, since the data
;	has absolutely no protection from errant user-mode programs.
;	Do NOT use this area for cells which cannot be wiped out by
;	any user-mode program at any time during image execution,
;	except when it only prevents that program from running.
;----------------------------------------------------------------------------
	.=UWVECPAG			; POINT TO START OF AREA

CTL$GL_DCLPRSOWN::			; ADDRESS OF DCL WRK AREA CREATED
	.BLKL	1			; BY DCL OR CLI$DCL_PARSE
CTL$GL_CLINTOWN::			; ADDRESS OF CONTEXT BLOCK USED BY
	.BLKL	1			; CLI$INTERFACE PACKAGE IN DCL/MCR

; THE REST OF THIS PAGE IS UNUSED

	.PAGE
	.SBTTL	IMAGE ACTIVATOR CONTEXT PAGE
;----------------------------------------------------------------------------
;	IMAGE ACTIVATOR CONTEXT PAGE
;
;	The following page contains image activator context that must
;	remain behind after an image is activated. The IAFLIST survives
;	across successive activations. The IAFEXE and IAFMERGE lists are
;	cleared when a new image activation is initiated. The FIXUP link
;	is cleared as soon as a given fixup pass completes.
;
;----------------------------------------------------------------------------
	.=IMGACTCTX			; Point to start of area

CTL$GL_IAFLINK::			; Listhead of linked list of fixup vectors 
	.BLKL	1			;  (containing shareable image lists)

CTL$GL_IAFLAST::			; Address of last fixup vector in list
	.BLKL	1			;  (used in normal and merged image activation)

CTL$GL_FIXUPLNK::			; Listhead of linked list of fixup 
	.BLKL	1			;  vectors used during fixup pass

CTL$GL_P1MERGE::			; Listhead of linked list of fixup vectors
	.BLKL	1			;  for images merged into P1 space

; The following data structure is an empty fixup vector that facilitates
; the fixup vector list manipulation. It is plugged into the fixup vector
; lists by PROCSTRT when a process is first created.

CTL$GL_IAFPERM::
	.BLKB	IAF$K_LENGTH

; The following label locates the link field in the just allocated structure.
; While an image is active, it locates the fixup vector for an executable image.
; It is cleared as part of the image activation initialization code path.

CTL$GL_IAFEXE == CTL$GL_IAFPERM + IAF$L_IAFLINK

IAC$GL_IMAGCTX::
	.BLKL	1			; Context that exists for life of image

IAC$GL_PROCCTX::
	.BLKL	1			; Context that exists beyond image exit

IAC$AL_VECADDR::
	.BLKL	4			; Array of altered opcode addresses

IAC$AL_VECOPCOD::
	.BLKB	4			; Array of saved opcodes

IAC$AW_VECRESET::
	.BLKW	4			; Array of offsets used to reset vectors

	.PAGE

	.IFT				; IF USRVECTOR MODULE:

;
; These symbols (SYS$...) specify which cells in the P1 pointer page may
; be used by any program, regardless of system version, without having
; to link with SYS.STB (and thus, make it system dependant).
;
; These symbols will remain constant forever and will continue to be supported
; from release to release.
;

	.MACRO	USRSYM	SYM,VALCHECK,CTLSYM
	.IF	B,CTLSYM
SYS$'SYM == CTL$'SYM
	.IF	NB,VALCHECK
	.IF	NE,CTL$'SYM'-^X'VALCHECK'
	.ERROR	; *** CTL$'SYM' MUST EQ ^X'VALCHECK' TO REMAIN COMPATIBLE WITH PREVIOUS RELEASES
	.ENDC
	.ENDC
	.IFF
SYS$'SYM == CTL$'CTLSYM
	.IF	NB,VALCHECK
	.IF	NE,CTL$'CTLSYM'-^X'VALCHECK'
	.ERROR	; *** CTL$'CTLSYM' MUST EQ ^X'VALCHECK' TO REMAIN COMPATIBLE WITH PREVIOUS RELEASES
	.ENDC
	.ENDC
	.ENDC
	.ENDM

	.DISABLE TRACEBACK

	USRSYM	GL_CMCNTX,7FFEFF88	; Address of 1 page of AME storage
	USRSYM	GL_IAFLINK,7FFEFF8C,-	; Points to IMGACT fixup listhead
			GL_IAFLNKPTR

	.ENDC				; END OF SHELL / USRVECTOR CONDITIONAL

	.END
