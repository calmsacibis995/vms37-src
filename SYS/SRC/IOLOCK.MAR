	.TITLE	IOLOCK - LOCK AND UNLOCK PAGES FOR I/O
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, MEMORY MANAGEMENT SUBROUTINES
;
; ABSTRACT:	THIS MODULE PROVIDES THE ROUTINE FOR QI/O TO LOCK DOWN
;	THE PAGES BEING TRANSFERRED AND THE ROUTINE REQUIRED BY THE I/O
;	COMPLETION LOGIC TO UNLOCK THOSE PAGES.
;
; ENVIRONMENT:	KERNEL MODE
;
;--
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 17-SEP-76
;
; MODIFIED BY:
;
;	V03-001	HRJ0060		Herb Jacobs		20-Mar-1982
;		Add support to allow swapper to lock shell pages into system
;		working set, and tell whether any need to be read.
;
;	V0212	PHL0010		Peter H. Lipman		15-May-1981
;		Do not try to adjust working set if System Space transfer.
;		Fix bug in zeroing system space page.
;		Shut off DZRO section bit if zeroing section page.
;
;	V0211	HRJ0020		Herb Jacobs		27-Apr-1981
;		Change references to PHD$W_WSSIZE to get working set size.
;
;	V0210	RIH0060		RICHARD I. HUSTVEDT	3-MAR-1980
;		ATTEMPT TO INCREASE WORKING SET BEFORE GIVING SS$_INSFWSL ERROR
;		RETURN.
;
;	V0209	KDM0023		KATHLEEN D. MORSE	10-APR-1979	09:20
;		COMBINE LOGIC AT "FAULTREQUIRED" WITH "MMG$UNLOCK1".
;
;	V0208	KDM0022		KATHLEEN D. MORSE	04-APR-1979	15:15
;		FIX BUG IN COMPUTING NUMBER OF PAGE TABLES TO LOCK.
;
;
;	V0207	SRB0001		STEVE BECKHARDT		30-MAR-1979	15:00
;		CHANGED INTERFACE TO MMG$IOLOCK AND MMG$IOLOCKPAG
;		TO ALLOW FOR I/O DEVICES THAT READ AND WRITE MEMORY.  THE
;		CHANGE ALLOWS THE CALLER TO INHIBIT AN OPTIMIZATION IN
;		MMG$IOLOCKPAG.  NOTE THAT THIS CHANGE DOES NOT CHANGE ANY
;		CODE, ONLY THE INTERFACES.  THE CODE WORKS AS IS.
;
;	V0206	KDM0001		KATHLEEN D. MORSE	14-NOV-1978	09:15
;		REMOVE RESTRICTION OF 128 PAGES FROM MMG$IOLOCK AND
;		MMG$UNLOCK.
;
;	V0210	KDM0037		KATHLEEN D. MORSE	12-JUN-1979	14:10
;		DECREMENT SECTION REFERENCE COUNT FOR CRF PAGES THAT ARE FAULTED
;		IN FOR AN I/O TRANSACTION.
;
;	, : VERSION
; 01	 -

	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$IPLDEF				;PRIORITY LEVEL DEFINITIONS
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PFNDEF				;PFN DATA BASE DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINITIONS
	$PTEDEF				;PAGE TABLE ENTRY DEFINTIONS
	$SSDEF				;SYSTEM STATUS DEFINITIONS
	$VADEF				;VIRTUAL ADDRESS VIELDS
	$WSLDEF				;WORKING SET LIST DEFINITIONS
;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;
;
; **********************************************************************
;
; **************** THIS ENTIRE MODULE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;

;++
; FUNCTIONAL DESCRIPTION:
;
;	IOLOCK ACCEPTS A VIRTUAL ADDRESS AND BYTE COUNT OF AN I/O BUFFER
;	AND A DIRECTION OF TRANSFER INDICATOR.  THE SPECIFIED PAGES
;	ARE MADE RESIDENT AND MARKED MODIFIED IF APPROPRIATE, AND THEN
;	THEY ARE LOCKED INTO MEMORY BY INCREMENTING THEIR REFERENCE COUNTS.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$IOLOCK
;
;
; INPUT PARAMETERS:
;
;	R0 = VIRTUAL ADDRESS OF BEGINNING OF BUFFER
;	R1 = SIZE OF BUFFER IN BYTES
;	R2 = TRANSFER DIRECTION INDICATOR
;		0 = WRITE OUT OF MEMORY TO I/O DEVICE
;		1 = READ INTO MEMORY FROM I/O DEVICE
;		5 = I/O DEVICE READS AND WRITES MEMORY
;	R4 = CURRENT PROCESS PCB ADDRESS
;
;	IPL MUST BE AT ASTDEL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	IF SUCCESSFUL
;		R0 = #SS$_NORMAL (LOW BIT SET)
;		R1 = SYSTEM VIRTUAL ADDRESS OF FIRST PAGE TABLE ENTRY
;
;	IF NOT SUCCESSFUL
;		R0 = 0
;		R1 = VIRTUAL ADDRESS TO FAULT AND TRY AGAIN
;	   OR
;		R0 = SYSTEM STATUS CODE (LOW BIT CLEAR)
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_INSFWSL			;INSUFICIENT WORKING SET LIMIT
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$IOLOCK::
	.ENABL	LSB
	PUSHR	#^M<R4,R5,R6,R7>
	MOVL	R2,R7			;DIRECTION INDICATOR
	EXTZV	#VA$V_BYTE,#VA$S_BYTE,R0,R6 ;STARTING BYTE IN PAGE
	BNEQ	10$			;BRANCH IF PARTIAL PAGE
	BISL	#2,R7			;FIRST PAGE IS FULL PAGE
					;UNLESS IT IS ALSO THE LAST
10$:	MOVL	@#CTL$GL_PHD,R5		;P1 SPACE ADDRESS OF PROCESS HEADER
	SUBL3	R6,R0,R3		;R3 = PAGE ALIGNED VA
	MOVAB	-(R0)[R1],R2		;R2=LAST BYTE INCLUSIVE
	BGEQ	20$			;BRANCH IF PROCESS VA
	MOVZWL	#SS$_ACCVIO,R0		;STATUS CODE FOR ACCESS VIOLATION
	BBC	#31,R3,IOLOCKACCVIO	;ENTIRE RANGE MUST BE SYSTEM SPACE
	CMPL	R2,W^SWP$GL_BALBASE	;AND BELOW BALANCE SET SLOTS
	BGEQU	IOLOCKACCVIO		;BRANCH IF NOT
	MOVAL	W^MMG$AL_SYSPCB,R4	;USE SYSTEM PCB
	MOVL	PCB$L_PHD(R4),R5	;AND SYSTEM PHD
	MOVB	#WSL$C_SYSTEM,R3	;SET SYSTEM PAGE TYPE
20$:	ADDL	R6,R1			;BYTE COUNT + OFFSET
	ASHL	#-9,R1,R6		;PAGE COUNT NOT INCLUDING LAST
					;PARTIAL PAGE IF ANY
	BITW	#VA$M_BYTE,R1		;IS LAST PAGE A PARTIAL PAGE?
	BEQL	30$			;BRANCH IF NOT
	INCL	R6			;COUNT ONE MORE PAGE
	BBSS	#31,R7,30$		;SET 'LAST PARTIAL PAGE' INDICATOR
30$:					;RETRY AFTER AUGMENTING WS SIZE
	SUBW3	PHD$W_WSDYN(R5),PHD$W_WSLIST(R5),R0 ;CALCULATE (-FIXED PORTION)
	ADDW	PHD$W_WSSIZE(R5),R0	;FIND DYNAMIC PORTION
	CMPW	R6,R0			;MAKE SURE THERE IS ENOUGH FOR REQUEST
	BLSSU	32$			;BRANCH IF ENOUGH
;
; NUMBER OF PAGES REQUIRED EXCEEDS THE DYNAMIC SIZE OF THE WORKING SET
;
	BBS	#31,R3,31$		;NO WSL ADJUST IF SYSTEM SPACE BUFFER
	PUSHL	R1			;SAVE VOLATILE REGISTER
	MOVZWL	PHD$W_WSSIZE(R5),-(SP)	;SAVE CURRENT WS SIZE
	PUSHL	#0			;NO ADDRESS FOR PREVIOUS VALUE
	MOVZBL	#127,-(SP)		;AUGMENT WS BY 127 PAGES
	CALLS	#2,EXE$ADJWSL		;CALL INTERNAL ADJUST ROUTINE
	POPR	#^M<R0,R1>		;RESTORE SAVED WSSIZE, R1
	CMPW	PHD$W_WSSIZE(R5),R0	;ANY CHANGE?
	BNEQ	30$			;IF YES, THEN TRY AGAIN
31$:	MOVZWL	#SS$_INSFWSL,R0		;INSUFFICIENT WORKING SET LIMIT
;
; ACCESS VIOLATION - ATTEMPTED I/O REQUEST TO BALANCE SET SLOTS
;
IOLOCKACCVIO:
	PUSHL	R0			;SO THAT THE POPR WILL BE RIGHT
	BRB	IOLOCKEXIT

32$:	ASHL	#-16,R3,-(SP)		;GET STARTING VA SHIFTED
	ASHL	#-16,R2,R0		;GET ENDING VA SHIFTED (ELIM BYTE OFF)
	SUBL	(SP)+,R0		;GET # OF PAGE TABLE PAGES BETWEEN VA'S
35$:	INCL	R0			;R0=COUNT OF PAGE TABLE PAGES TO LOCK
	PUSHR	#^M<R0,R3>		;SAVE START VA AND PUSH LOOP COUNTER
38$:	CMPL	S^#1,(SP)		;IS THIS THE FIRST PAGE TBL PAG TO LOCK?
	BNEQ	40$			;BR IF NOT FIRST PAGE
	MOVL	4(SP),R2		;USE STARTING VA
40$:	SETIPL	#IPL$_ASTDEL		;BACK TO ASTDEL IN ORDER TO FAULT PT
	BSBW	MMG$LOCKPGTB		;REFERENCE AND LOCK PAGE TABLE PAGE
					;RETURNS SVAPTE IN R3, IPL=SYNCH
	SUBL2	#^X10000,R2		;GET ADR IN NEXT PAGE TABLE PAGE
	SOBGTR	(SP),38$		;LOCK ALL PAGE TABLE PAGES
	POPR	#^M<R0,R2>		;CLEAN STACK, R2=STARTING VIRTUAL ADR
	MOVL	PCB$L_PHD(R4),R5	;NO LONGER SWAPPABLE, USE SYSTEM ADR OF
	PUSHL	R3			;PHD AND SAVE IT FOR RETURN TO CALLER
	BRB	55$			;START AFTER THE 'INC' SVAPTE
;
; 0(SP) = STARTING SYS VIRTUAL ADDRESS OF PAGE TABLE ENTRY
; R6 = PAGE COUNT TO LOOP THROUGH
; R7<0>  - SET IF READING INTO MEMORY
; R7<1>  - SET IF TRANSFERRING THE ENTIRE PAGE
; R7<2>  - SET IF I/O DEVICE IS READING AND WRITING MEMORY
; R7<31> - SET IF LAST PAGE IS PARTIAL PAGE
;
50$:	ADDL	#4,R3			;NEXT PAGE TABLE ENTRY ADDRESS
55$:	BBC	#31,R7,60$		;BRANCH IF LAST PAGE IS A FULL PAGE
	CMPL	R6,#1			;IS THIS THE LAST PAGE?
	BGTR	60$			;BRANCH IF NOT
	BICL	#2,R7			;INDICATE PARTIAL PAGE
60$:	BSBB	MMG$IOLOCKPAG		;LOCK THIS PAGE FOR I/O
	BLBC	R0,FAULTREQUIRED	;BRANCH IF MUST PAGE FAULT
	BISL	#2,R7			;AFTER FIRST PAGE, FULL PAGES
	MOVAL	^X200(R2),R2		;NEXT VIRTUAL PAGE
	SOBGTR	R6,50$			;ONCE FOR EACH PAGE
	.DSABL	LSB			;
;
; R0 = STATUS CODE
;
IOLOCKEXIT:
	POPR	#^M<R1,R4,R5,R6,R7>	;RESTORE REGISTERS AND RETURN R1
					;WITH SVAPTE IF SUCCESSFUL
					;OR VA TO FAULT IF NOT
	SETIPL	#IPL$_ASTDEL		;RETURN WITH IPL AS CALLED
	RSB
;
; FAILED TO LOCK THE PAGE FOR I/O, IT MUST BE PAGE FAULTED FIRST
; R3 = SVAPTE OF FIRST PAGE NOT LOCKED
;
FAULTREQUIRED:
	MOVL	R3,R1			;R1=SVAPTE OF PAGE NOT LOCKED
	MOVL	(SP)+,R3		;R3=SVAPTE OF FIRST PAGE IN TRANSFER
	MOVAL	-4(R1)[R6],R0		;R0=LAST SVAPTE FOR PG TBL PG INCLUSIVE
	SUBL2	R3,R1			;# OF BYTES OF PTE LOCKED
	ASHL	#-2,R1,R1		;R1=# PAGES IN TRANSFER LOCKED
	PUSHL	R2			;SAVE VIRTUAL ADDRESS OF BE FAULTED
	BSBW	MMG$UNLOCK1		;UNLOCK EVERYTHING THAT WAS LOCKED
	CLRL	R0			;RETURN STATUS INDICATING
	BRB	IOLOCKEXIT		;"PAGE FAULT AND TRY AGAIN"


	.SBTTL	IOLOCKPAG - LOCK INDIVIDUAL PAGE FOR I/O
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE LOCKS THE SPECIFIED PAGE FOR I/O.
; TO ACCOMPLISH THIS IT MUST MAKE THE PAGE VALID, EFFECTIVELY BY
; FAULTING THE PAGE.  BUT SINCE THIS ROUTINE DOES NOT WANT TO WAIT
; FOR A PAGE TO FAULT, IT WILL ONLY MAKE THE PAGE VALID IF IT CAN
; DO SO WITHOUT WAITING.  OTHERWISE IT PASSES BACK THE CONDITION
; THAT A FULL FLEDGED PAGE FAULT IS REQUIRED TO GET THE PAGE.
;
;	IOLOCKPAG RECOGNIZES THE SPECIAL CASE OF A NON-RESIDENT
; PAGE THAT IS GOING TO BE TOTALLY OVERWRITTEN BY THE I/O TRANSFER.
; IN THIS CASE IT DEMAND ZEROES A PAGE INSTEAD OF READING IT IN.
; HOWEVER, THIS OPTIMIZATION CAN BE INHIBITED IF THE PAGE IS ACTUALLY
; GOING TO BE READ AND WRITTEN BY THE I/O DEVICE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$IOLOCKPAG
;
; INPUT PARAMETERS:
;
;	R2 = VIRTUAL ADDRESS (LOW 9 BITS = PAGTYP)
;	     ONLY PROCESS OR SYSTEM PAGES, NO GLOBALS YET
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS (SYSTEM SPACE)
;	R7 = <0> - SET IF MODIFYING THE PAGE (READING INTO MEMORY)
;	     <1> - SET IF TRANSFERRING THE ENTIRE PAGE
;	     <2> - SET TO INHIBIT NON-RESIDENT PAGE OPTIMIZATION (SEE ABOVE)
;	     <3:7> = 0
;	IPL = SYNCH
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = #SS$_NORMAL IF LOCKED OK
;	   = 0 IF PAGE FAULT REQUIRED
;	R2,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$IOLOCKPAG::
	.ENABL	LSB
	BICL3	#^C<PTE$M_VALID		-;CHECK VALID BIT
		! PTE$M_TYP1 ! PTE$M_TYP0 -;GET PTE TYPE BITS
		! PTE$M_PGFLVB>,(R3),R0	;AND PFN/PAGE FILE VBN BITS TO R0
	BGEQ	NOTVALID		;BRANCH IF PAGE NOT VALID
;
; PAGE IS VALID, LOCK IT FOR I/O
;
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ;R0=PFN
	CMPL	R0,W^MMG$GL_MAXPFN	;DOES THIS PAGE HAVE PFN DATABASE?
	BGTR	10$			;NO, SKIP LOCK FOR PAGE
LOCKPAGE:
	INCW	@W^PFN$AW_REFCNT[R0]	;I/O REFERENCE
	BLBC	R7,10$			;BRANCH IF NOT MODIFYING PAGE
	BISB	#PTE$M_MODIFY@-24,3(R3)	;SET MODIFY BIT IN PTE
10$:	MOVZWL	#SS$_NORMAL,R0		;RETURN SUCCESS INDICATION
	RSB
	.DSABL	LSB
;
; PAGE NOT VALID
;
NOTVALID:
	BEQL	DEMANDZERO		;BRANCH IF DEMAND ZERO PAGE
	EXTV	#PTE$V_TYP0,#<PTE$V_TYP1+1-PTE$V_TYP0>,R0,R1
;
; R1 = SIGN EXTENDED VIELD OF BITS BETWEEN TYP0 AND TYP1
; IF R1 = 0 THEN BOTH BITS WERE ZERO
; R1 NEGATIVE INDICATES TYP1 BIT SET
; R1<0> IS THE TYP0 BIT
;
	BNEQ	NOTRANSITION		;BRANCH IF NOT TRANSITION PAGE
;
; PAGE IS IN TRANSITION, R0 = PFN
;
	ASSUME	PFN$C_ACTIVE EQ 7	;ALL BITS SET
	BICB3	@W^PFN$AB_STATE[R0],#PFN$C_ACTIVE,R1 ;IS PAGE ACTIVE?
	BEQL	ACTIVE			;BRANCH IF IT IS
	PUSHR	#^M<R0,R2,R3>		;SAVE SVAPTE, VA, PFN
	BSBW	MMG$FREWSLE		;GET A WORKING SET LIST ENTRY
	BLBC	R0,30$			;BRANCH IF MUST WAIT FOR ONE
	POPR	#^M<R0>			;RECOVER PFN
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],R2 ;LOCATION
	CASE	R2,<-
		PFNLIST,-		;FREE PAGE LSIT
		PFNLIST,-		;MODIFIED PAGE LIST
		20$,-			;BAD PAGE LIST
		RELEASEPEND,-		;PAGE WAITING TO BE RELEASED BY I/O DONE
		20$,-			;READ ERROR
		WRITEINPROG-		;WRITE IN PROGRESS
	>
20$:	MOVQ	(SP)+,R2		;RESTORE VA AND SVAPTE
	BRB	MUSTFAULT		;RETURN "MUST FAULT" STATUS
30$:	POPR	#^M<R0>			;CLEAN OFF SAVED PFN
	BRB	20$			;AND JOIN MUST FAULT CODE
;
; PAGE IS ON FREE OR MODIFIED PAGE LIST, R2 = LIST ID
;
PFNLIST:
	BSBW	MMG$REMPFN		;REMOVE PAGE FROM SPECIFIED LIST
WRITEINPROG:
RELEASEPEND:
	MOVQ	(SP),R2			;RESTORE VA AND SVAPTE
	BSBW	MMG$MAKEWSLE		;MAKE NEW WORKING SET LIST ENTRY
	MOVQ	(SP)+,R2		;RESTORE VA AND SVAPTE
	ASSUME	PFN$V_DELCON EQ PFN$V_LOC+PFN$S_LOC+1 ;DELCON IS 2ND BIT TO LEFT OF LOC
					;BIT IN BETWEEN IS FOR LOC EXPANSION
	INSV	#PFN$C_ACTIVE,#PFN$V_LOC,#PFN$S_LOC+2,- ;SET PAGE ACTIVE
		@W^PFN$AB_STATE[R0]	;AND CLEAR DELCON
ACTIVE:
	BBCS	#PTE$V_VALID,(R3),LOCKPAGE ;SET VALID BIT
	BRB	LOCKPAGE		;FINISH UP BY LOCKING THE PAGE
;
; RESTORE VA AND SVAPTE AND FALL THROUGH TO MUSTFAULT1
;
MUSTFAULT3:
	POPR	#^M<R2,R3>		;RESTORE VA AND SVAPTE
;
; POP 1 LONG WORD AND RETURN "MUST FAULT" INDICATION
;
MUSTFAULT1:
	TSTL	(SP)+			;CLEAN UP STACK
;
; RETURN "MUST FAULT" INDICATION
;
MUSTFAULT:
	CLRL	R0			;INDICATE FAILURE
	RSB				;
;
; MUST BE SECTION, PAGE FILE, OR GLOBAL PAGE
;
NOTRANSITION:
	BGTR	MUSTFAULT		;FAULT GLOBALS FOR NOW
;
; PAGE IS A SECTION OR PAGE FILE PAGE.  IF TOTALLY OVERWRITING IT
; THEN SUPPLY A ZEROED PAGE INSTEAD OF FAULTING IT IN.
; (ASSUMING THIS OPTIMIZATION IS NOT INHIBITED BY BIT 2 IN R7 BEING SET)
;
	CMPB	#3,R7			;TOTALLY OVERWRITING THE PAGE?
	BNEQ	MUSTFAULT		;BRANCH IF NOT, NEED TO READ IT
;
; DEMAND ZERO THIS PAGE, R0 IS BACKING STORE ADDRESS.
;
DEMANDZERO:
	EXTZV	#PFN$V_BAK,#PFN$S_BAK,R0,R0 ;CALCULATE BACKING STORE ADR
	BBC	#PTE$V_TYP0,R0,20$	;BRANCH IF PAGING FILE
	BBSC	#PTE$V_DZRO,R0,10$	;CLEAR DZRO BIT IF IT WAS SET
10$:
	BBC	#PTE$V_CRF,R0,30$	;BRANCH IF NOT CRF SECTION
	CVTWL	R0,R1			;GET SECTION TABLE INDEX
	PUSHL	R2			;SAVE VA
	BSBW	MMG$DECSECREF		;ONE LESS CRF PTE POINTING TO SECTION
	POPL	R2			;RESTORE VA
	CLRL	R0			;NULL PAGING FILE FOR CRF SECTION
20$:	INSV	PHD$B_PAGFIL(R5),#PFN$V_PGFLX,#PFN$S_PGFLX,R0 ;PAGE FILE INDEX
30$:	PUSHL	R0			;SAVE BACKING STORE ADDRESS
	MOVQ	R2,-(SP)		;SAVE SVAPTE AND VA
	BSBW	MMG$FREWSLE		;GET A WORKING SET LIST ENTRY
	MOVQ	(SP),R2			;RESTORE VA AND SVAPTE
	BLBC	R0,MUSTFAULT3		;BRANCH IF NEED TO WAIT FOR WSLE
	BSBW	MMG$ININEWPFN		;ALLOCATE AND INIT A PFN
	MOVQ	(SP)+,R2		;RESTORE VA AND SVAPTE
	BBS	#31,R0,MUSTFAULT1	;BRANCH IF MUST WAIT FOR ONE
	INCW	@W^PFN$AW_REFCNT[R0]	;2ND REFERENCE FOR I/O LOCK DOWN
	BISB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ;PAGE IS ACTIVE
	MOVL	(SP)+,@W^PFN$AL_BAK[R0]	;SET BACKING STORE ADDRESS
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>,(R3),R1 ;GET PROT AND OWNER FROM PTE
	BBCS	#PTE$V_VALID,R1,40$	;SET THE VALID BIT
40$:	BBC	#8,R7,45$		;BRANCH IF NORMAL I/O OPERATION
	BISL3	R0,R1,(R3)		;STORE THE VALID SHELL PFN
	MOVL	#3,R0			;SET ALTERNATE SUCCESS
	RSB				;RETURN

45$:	BBCS	#PTE$V_MODIFY,R1,46$	;SET THE MODIFY BIT
46$:	BISL3	R0,R1,(R3)		;AND STORE IT WITH THE PFN
;
; AT THIS POINT DROP IPL TO ASTDEL SO SOMEONE ELSE MAY RUN IF NECESSARY
; THE PROCESS HEADER HAS BEEN NAILED DOWN BY THE I/O REF COUNT ON THIS
; PAGE SO IT CAN'T SLIP AWAY.
;
	PUSHR	#^M<R2,R3,R4,R5>	;PRESERVE THESE FROM MOVC5
	BICW	#VA$M_BYTE,R2		;SHUT OFF PAGE TYPE BITS IN VA
	CMPL	R2,(SP)			;IF NOT PROCESS PAGE
	BNEQ	50$			;THEN DON'T LOWER IPL
	SETIPL	#IPL$_ASTDEL		;MAKE PROCESS SCHEDULABLE AGAIN
50$:	MOVC5	#0,(R2),#0,#^X200,(R2)	;ZERO THE PAGE
	POPR	#^M<R2,R3,R4,R5>	;RESTORE SAVED REGISTERS
	SETIPL	#IPL$_SYNCH		;BACK TO CALLED IPL
	MOVZWL	#SS$_NORMAL,R0		;PAGE SUCCESSFULLY LOCKED FOR I/O
	RSB				;RETURN TO CALLER

	.SBTTL	UNLOCK PAGES AT COMPLETION OF I/O
;++
; FUNCTIONAL DESCRIPTION:
;
;	UNLOCK PAGES THAT WERE PREVIOUSLY LOCKED FOR DIRECT I/O
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$UNLOCK
;
;
; INPUT PARAMETERS:
;
;	R1 = PAGE COUNT
;	R3 = STARTING SVAPTE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--
	.ENABL	LSB

;
; R0 = LAST SVAPTE INCLUSIVE FOR PAGE TABLE UNLOCKING (MMG$UNLOCK1 ONLY)
; R1 = COUNT OF DATA PAGES TO UNLOCK
; R3 = STARTING SVAPTE FOR UNLOCKING DATA PAGES AND PAGE TABLES
;
MMG$UNLOCK1:
	SAVIPL				;CALLER'S IPL TO STACK
	BRB	3$			;JOIN COMMON CODE

MMG$UNLOCK::
	DSBINT	#IPL$_SYNCH		;SAVE IPL AND RAISE TO SYNCH
	MOVAL	-4(R3)[R1],R0		;SVAPTE OF LAST PAGE OF XFER INCLUSIVE
;
; 0(SP) = CALLED IPL, CURRENTLY AT SYNCH
; R0 = LAST SVAPTE INCLUSIVE
; R1 = COUNT OF PAGES
; R3 = FIRST SVAPTE
;
3$:	PUSHR	#^M<R1,R3>		;PUSH START SVAPTE, PAGE COUNT
	BISW2	#^X1FC,R0		;ROUND UP TO END OF PAGE TABLE PAGE
6$:	BSBW	MMG$DECPTREF		;UNDO PAGE TABLE REFERENCE
	MOVAL	^X200(R3),R3		;GET NEXT PAGE TABLE PAGE ADDRESS
	CMPL	R0,R3			;PAST LAST PAGE OF XFER?
	BGEQU	6$			;BRANCH ON NO
	INCL	(SP)			;INCREMENT PAGE COUNT, GO CHECK IF
	BRB	25$			;NO PAGES TO UNLOCK
10$:	MOVL	(R2)+,R3		;FETCH PAGE TABLE ENTRY
	BLSS	20$			;BRANCH IF VALID
	BSBW	IOC$PTETOPFN		;RETURN R3<PFN> = PFN
20$:	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R3,R0 ;PFN TO R0
	CMPL	R0,W^MMG$GL_MAXPFN	;DOES THIS PAGE HAVE PFN DATABASE?
	BGTR	30$			;NO, NEXT PAGE
	DECREF	GTR=30$			;ONE LESS REASON FOR THIS PAGE'S RESIDENCY
	MOVQ	R1,-(SP)		;SAVE REGISTERS
	BSBW	MMG$RELPFN		;RELEASE THE PAGE
25$:	MOVQ	(SP)+,R1		;RESTORE PAGE COUNT AND STARTING SVAPTE
30$:	SOBGTR	R1,10$			;ONCE AROUND FOR EACH PAGE
	ENBINT				;RESTORE SAVED IPL
	RSB
;
; PAGE REFERENCE OR SHARE COUNT WENT NEGATIVE, FATAL ERROR
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$REFCNTNEG		;R0 = PAGE FRAME NUMBER
;	BSBW	MMG$SHRCNTNEG		;R0 = PAGE FRAME NUMBER
;
MMG$REFCNTNEG::
	BUG_CHECK REFCNTNEG,FATAL	;PFN REFERENCE COUNT NEGATIVE

MMG$SHRCNTNEG::
	BUG_CHECK SHRCNTNEG,FATAL	;PFN SHARE COUNT NEGATIVE

	.END
