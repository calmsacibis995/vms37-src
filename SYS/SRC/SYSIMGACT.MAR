	.TITLE	SYSIMGACT - IMAGE ACTIVATOR SYSTEM SERVICE
	.IDENT	'V03-006'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, MEMORY MANAGEMENT SYSTEM SERVICE
;
; ABSTRACT:
;
; ENVIRONMENT:	KERNEL MODE, RUNNING MOSTLY AT IPL ASTDEL WITH THE 
;	PROCESS HEADER LOCKED
;
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 23-SEP-76
;
; MODIFIED BY:
;
;	V03-006	LJK0166		Lawrence J. Kenah	22-Apr-1982
;		Do not disable logical name tables in NOACT case.
;
;	V03-005	LJK0162		Lawrence J. Kenah	15-Apr-1982
;		Add consistency check of shareable image list. Correct
;		misleading comment. 
;
;	V03-004	LJK0161		Lawrence J. Kenah	12-Apr-1982
;		Do not set vectors for privileged images if in P0 part
;		of merge into P1 space.
;
;	V03-003	LJK0156		Lawrence J. Kenah	5-Apr-1982
;		Make all read-only pages in protected image owned by exec.
;		Reserve only 128 bytes in TYPE 2 images.
;
;	V03-002	LJK0153		Lawrence J. Kenah	27-Mar-1982
;		Do not perform "is it installed?" test in NOACT case.
;		Restore BYTCNT quota when making shared WCB.
;		Disable process and group logical name translation if
;		activating privileged executable image.
;
;	V03-001	LJK0142		Lawrence J. Kenah	4-Mar-1982
;		Add use of image context in detecting that a privileged
;		image is being activated. Add consistency check for
;		fixup vectors to filter out bad image headers. Insure 
;		that VECTOR ISDs are also PROTECTed. Add escape for images
;		to pass name of "AME" in first block of image header.
;
;	V02-072	LJK0136		Lawrence J. Kenah	23-Feb-1982
;		Change routine that makes known file entries for shared
;		compatibility mode images to reflect label block changes.
;
;	V02-071	LJK0122		Lawrence J. Kenah	15-Feb-1982
;		On recursive call, store input name to image activator
;		in shareable image list element 0.
;
;	V02-070	LJK0120		Lawrence J. Kenah	11-Feb-1982
;		Change the way that privileged vectors are installed to
;		prevent privileged code from being called before the
;		fixups are complete.
;
;	V02-069	LJK0119		Lawrence J. Kenah	11-Feb-1982
;		Put PRIVILEGE bit into permanent image context to demand
;		that images merged into a privileged executable image
;		be installed.
;
;	V02-068	LJK0118		Lawrence J. Kenah	29-Jan-1982
;		Probe output parameters a second time before passing
;		information back to caller to insure that protection
;		has not changed.
;
;	V02-067	LJK0117		Lawrence J. Kenah	25-Jan-1982
;		Insure that privileged shareable images do not have
;		outbound calls. Do fixups for privileged shareable
;		images (.ADDRESS fixups only) in exec mode.
;
;	V02-066	LJK0116		Lawrence J. Kenah	21-Jan-1982
;		The FIXUPVEC bit in ISD$L_FLAGS is an additional
;		signature of a fixup vector. 
;
;	V02-065	LJK0112		Lawrence J. Kenah	8-Jan-1982
;		Do not allow properties of next global ISD influence
;		parameters of current ISD before recursive call is made.
;
;	V02-064	LJK0108		Lawrence J. Kenah	31-Dec-1981
;		Set COMPLETE and CATHEDRAL bits in WCBs that are
;		initialized by MMG$INIWCB.
;
;	V02-063	WMC0020		Wayne M. Cardoza	8-Dec-1981
;		Save channel number of images in last word of
;		shareable image list.  (This space is actually reserved
;		for 31 character file name.)
;
;	V02-062	PHL0025		Peter H. Lipman		19-Nov-1981
;		Invoke new IMGACTSUB routine IAC$RESET_IAF to reset
;		the fixup vector context.
;
;		Fix improper probes for file name strings
;
;	V02-061	LJK0083		Lawrence J. Kenah	11-Nov-1981
;		Move all pageable code from Y$EXEPAGED to new pageable
;		PSECT to alleviate strain on word displacements
;		throughout the pageable exec.
;
;	V02-060	LJK0071		Lawrence J. Kenah	5-Oct-1981
;		Initialize SHL entry with index 0 from NAM block instead 
;		of from FAB.
;
;	V02-059	LJK0070		Lawrence J. Kenah	29-Sep-1981
;		Add R8..R11 to register save mask. 
;
;	V02-058	LJK0062		Lawrence J. Kenah	28-Sep-1981
;		Remove calls to fixup routines. These are now done in user
;		mode by the $IMGFIX service.
;
;	V02-057	LJK0060		Lawrence J. Kenah	4-Sep-1981
;		Correct treatment of shareable images included with a
;		/SHARE=COPY option.
;
;	V02-056	LJK0055		Lawrence J. Kenah	29-Aug-1981
;		Lay groundwork for adding an access mode input parameter
;		to the image activator.
;
;	V02-055	LJK0054		Lawrence J. Kenah	29-Aug-1981
;		Alter linked list mainpulations to support based shareable
;		images where global ISDs appear before local ISDs in the
;		executable image.
;
;	V02-054	SPF0019		Steve Forgey		24-Aug-1981
;		Add image accounting initialization logic.
;
;	V02-053	LJK0038		Lawrence J. Kenah	29-Jul-1981
;		Avoid file protection checks if WCB is really a
;		network logical link block.
;
;	V02-052	LJK0037		Lawrence J. Kenah	22-Jul-1981
;		Replace local definition of control flags with symbols
;		defined in the $IACDEF macro.
;
;	V02-051	LJK0034		Lawrence J. Kenah	25-Jun-1981
;		Cause image activator to use wait logic in scheduler when
;		it is necessary for a process to wait for the KFI mutex.
;
;	V02-050	LJK0017		Lawrence J. Kenah	14-May-1981
;		Change event flag associated with $QIO that reads each VBN
;		of the image header. Add logic to distinguish genuine I/O
;		completion to spurious setting of the event flag.
;
;	V02-049	LJK0016		Lawrence J. Kenah	27-Mar-1981
;		Use G^ addressing wherever necessary to allow this service 
;		to be separated from the system image for debugging. This
;		also makes the service totally position independent,
;		allowing it to be made loadable in the future. In addition,
;		make several formatting changes.
;
;	V02-048	LJK0015		Lawrence J. Kenah	27-Mar-1981
;		Add support for fixup of external references and .ADDRESS
;		directives at image activation time. These changes are
;		required to support the shareable image enhancements
;		being produced by the linker.
;
;	V02-047	LJK0008		Lawrence J. Kenah	27-Mar-1981
;		When installing protected image sections, delete each
;		section after it is created to avoid section ownership
;		problems.
;
;	V02-046	KTA0012		Kerbey T. Altmann	05-Mar-1981
;		Add support for non-contiguous files in MANUAL_OPEN.
;		Coordinates with changes in SYSINIT & FILEREAD.
;
;	V02-045	KTA0003		Kerbey T. Altmann	21-Jan-1981
;		Correct misspelling in previous edit.
;
;	V02-044	KTA0001		Kerbey T. Altmann	19-Jan-1981
;		Add support for user rundown vector similar to the user
;		CHME vector.  Redo (re)setting of vectors
;
;	V02-043	LJK0007		Lawrence J. Kenah	1-Dec-1980
;		Make sure that byte 2 of FLAGS parameter (bits <16:23>) is
;		cleared on each trip through the ISD loop. This prevents the 
;		image activator from trying to create or map nonprotected 
;		sections with the PROTECT attribute.
;
;	V02-042	KDM0019		Kathleen D. Morse	15-Aug-1980
;		Allow non-installed shareable image files with message
;		vectors to be mapped.
;
;	V02-041	KDM0011		Kathleen D. Morse	2-Jun-1980
;		Don't map any address space for a NOACT request, since
;		the image activator treats DZRO sections as process-
;		private sections, not global sections.  (Mapping was
;		only needed for shared memory DZRO global sections.)
;
;	V02-040	KDM0009		Kathleen D. Morse	13-May-1980
;		Don't map a writable, non-crf shareable image section
;		as a private section unless it has "match-never"
;		match control.  Don't map a match-never section
;		from the shareable image file, use the executable
;		image file copy.  Also, add check that match control
;		passed in the recursive call is identical or more
;		restrictive than that in the shareable image header.
;
;--

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	LBLDF$				;COMPATIBILITY MODE LABEL BLOCK DEFINITIONS
	$ACMDEF				;ACCOUNTING MESSAGE DEFINITIONS
	$CCBDEF				;CHANNEL CONTROL BLOCK DEFINITIONS
	$DEVDEF				;DEVICE CHARACTERISTICS DEFINITIONS
	$DYNDEF				;DYNAMIC STRUCTURE TYPE DEFINITIONS
	$FABDEF				;FILE ACCESS BLOCK DEFINITIONS
	$FCBDEF				;FILE CONTROL BLOCK DEFINITIONS
	$IACDEF				;IMAGE ACTIVATOR CONTROL FLAGS
	$IAFDEF				;IMAGE ACTIVATOR FIXUP VECTOR DEFINITIONS
	$IFDDEF				;IMAGE FILE DESCRIPTOR DEFINITIONS
	$IHADEF				;IMAGE HEADER ACTIVATION SECTION DEFINITIONS
	$IHDDEF				;IMAGE HEADER DEFINITIONS
	$IHIDEF				;IMAGE HEADER IDENT SECTION DEFINITIONS
	$IHPDEF				;IMAGE HEADER PATCH SECTION DEFINITIONS
	$IHSDEF				;IMAGE HEADER SYMBOL TABLE SECTION DEFINITIONS
	$IHXDEF				;IMAGE HEADER CROSSLINKER DEFINITIONS
	$IMPDEF				;RMS IMPURE AREA DEFINITIONS
	$IPLDEF				;INTERRUPT PRIORITY LEVEL DEFINITIONS
	$ISDDEF				;IMAGE SECTION DESCRIPTOR DEF'S
	$JIBDEF				;JOB INFORMATION BLOCK DEFINITIONS
	$KFIDEF				;KNOWN FILE ENTRY DEFINITIONS
	$KFHDEF				;KNOWN FILE IMAGE HEADER DEFINITIONS
	$NAMDEF				;NAME BLOCK DEFINITIONS
	$OPDEF				;INSTRUCTION OPCODE SYMBOLIC DEFINITIONS
	$PCBDEF				;DEFINE PROCESS CONTROL BLOCK
	$PHDDEF				;DEFINE PROCESS HEADER
	$PLVDEF				;DEFINE PRIVILEGED LIBRARY VECTORS
	$PRTDEF				;DEFINE PAGE PROTECTION CODES
	$PSLDEF				;DEFINE ACCESS MODES IN PROG STAT LONGW
	$RMSDEF				;DEFINE RMS ERROR CODES
	$SECDEF				;PROCESS/GLOBAL SECTION DEF'S
	$SHLDEF				;OFFSETS IN SHAREABLE IMAGE LIST ELEMENT
	$SSDEF				;DEFINE SYSTEM ERROR CODES
	$WCBDEF				;WINDOW CONTROL BLOCK DEFINITIONS

	$CRETVADEF			;CREATE VIRTUAL ADDRESS SPACE DEFINITIONS
	$CRMPSCDEF			;CREATE AND MAP SECTION DEFINITIONS
	$MGBLSCDEF			;MAP GLOBAL SECTION DEFINITIONS
	$SETPRTDEF			;SET PROTECTION DEFINITIONS

;
; EXTERNAL SYMBOLS:
;
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
;
;   OFFSETS FROM BEGINNING OF SCRATCH AREA
;
	$OFFSET	0,NEGATIVE,<-		;NEGATIVE OFFSETS
	<IDMATCHCTL,8>,-		;IDENTIFICATION QUAD WORD
	<IOSB,8>,-			;I/O STATUS BLOCK FOR GI/O
-;					;ALSO USED FOR SAVING BEGIN AND END
-;					;ADDRESSES OF IMAGE HEADER FOR
-;					;MAKING HEADER RESIDENT.  ASSUMES
-;					;NO I/O AFTER LAST ISD IS PROCESSED.
	<USRSTACKADR,8>,-		;RETADR FOR MAPPING USER STACK
	<PROCPRIV,8>,-			;PROCESS PRIVILEGE MASK
	<IMAGEPRIV,8>,-			;PRIVILEGE BITS FROM IMAGE HEADER
	HDRVBN,-			;CURRENT HEADER VBN IN BUFFER
	IMGHDRBUF,-			;COPY OF HDRBUF(AP) FOR SETCTLREG
	RETSTATUS,-			;RETURN ERROR STATUS CODE FOR NO ACTIVAT
	AMECOD,-			;CODE NUMBER FOR AME
	HDRBLKCNT,-			;NUMBER OF BLOCKS OF HEADER IN THIS IMAGE
	CTLBASADR,-			;CONTROL REGION BASE ADDRESS, END OF "SHELL"
	CTLBASCNT,-			;BYTE COUNT IN FIXED CONTROL REGION
	BUFEND,-			;ADDRESS OF END OF BUFFER HEADER
	<KFIMATCHCTL,8>,-		;KNOWN FILE GLOBAL SECTION MATCH CONTROL
	<KFINAMSTR,16>,-		;KNOWN FILE GLOBAL SECTION NAME STRING
	<FAB,FAB$C_BLN>,-		;FILE ACCESS BLOCK
	<NAM,NAM$C_BLN>,-		;NAME BLOCK
	<MAXNEGOFF,0>-			;MOST NEGATIVE OFFSET
	>

	$OFFSET	0,POSITIVE,<-		;POSITIVE OFFSETS
-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	ARGCNT,-	 		;ARGUMENT COUNT
	INADR,-				;INPUT RANGE ADDRESS
	RETADR,-			;RETURN RANGE ADDRESS
	ACMODE,-			;ACCESS MODE OF CREATOR OF PAGES
	FLAGS,-				;SECTION FLAGS
	GSDNAM,-			;GLOBAL SECTION NAME DESCRIPTOR
	IDENT,-				;IDENTIFICATION
	RELPAG,-			;RELATIVE PAGE IN SECTION
	CHAN,-				;CHANNEL ON WHICH FILE IS OPEN
	PAGCNT,-			;SIZE OF SECTION IN PAGES
	VBN,-				;FIRST BLOCK NUMBER IN SECTION
	PROT,-				;PROTECTION
	PFC,-				;PAGE FAULT CLUSTER
-; KEEP THE PRECEDING DEFINITIONS TOGETHER

-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	STARTVA,-			;STARTING ADDRESS TO CREATE
	ENDVA,-				;ENDING ADDRESS (INCLUSIVE) TO CREATE
	RETSTARTVA,-			;RETURNED STARTING ADDRESS
	RETENDVA,-			;RETURNED ENDING ADDRESS
-; KEEP THE PRECEDING DEFINITIONS TOGETHER
	RETSTARTVA_CUM,-		;DEFAULT (CUMULATIVE) RETURN ADDRESS 
	RETENDVA_CUM,-			; ARRAY IF CALLER DOES NOT SPECIFY ONE
-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	FILELBN,-			;STARTING LOGICAL BLOCK NUMBER OF FILE
	FILESIZE,-			;FILE SIZE
-; KEEP THE PRECEDING DEFINITIONS TOGETHER

	<IOCHANCNT,2>,-			;DESIRED NO. OF CHANNELS OR 0
	<IMGIOCNT,2>,-			;DESIRED IMAGE I/O PAGE COUNT OR 0
	USRSTACKCNT,-			;DESIRED # OF USER STACK PAGES
	IOSEGADR,-			;ADR TO HOLD I/O SEGMENT IN "SHELL"
	IAFVA,-				;RELATIVE VA OF FIXUP VECTOR IF PRESENT
	IAFEXE,-			;ADDRESS OF FIXUP VECTOR FOR EXECUTABLE IMAGE
-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	CMKFIADR,-			;COMPAT MODE KNOWN FILE ENTRY ADDRESS
	IFDFLAGS,-			;IMAGE FILE DESCRIPTOR FLAGS
-; KEEP THE PRECEDING DEFINITIONS TOGETHER
	IACFLG,-			;IMAGE ACTIVATION FLAGS
	LNKFLAGS,-			;LINKER FLAGS
	<KFIFLG,2>, -			;KNOWN FILE FLAGS
	<,2> -				;SPARE FOR ALIGNMENT

	>

	$OFFSET	,,<-

-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	KRNLARG,-			;ARG LIST TO KERNEL MODE ROUTINES
	KRNLROUT,-			;KERNEL ROUTINE ADDRESS TO CALL
	IMGACTCTX,-			;IMAGE ACTIVATION CONTEXT ADDRESS
	KFIADR,-			;KNOWN FILE ENTRY ADDRESS
	GBLSECCNT,-			;GLOBAL SECTION COUNT KNOWN FILE ENTRY SHARING
-; KEEP THE PRECEDING DEFINITIONS TOGETHER
-;
-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	GSDNAMSIZ,-			;GLOBAL SECTION NAME STRING SIZE
	GSDNAMADR,-			;GLOBAL SECTION NAME STRING ADDRESS
-; KEEP THE PRECEDING DEFINITIONS TOGETHER
	<INMAPRANGE,8>,-		;ADR RANGE FOR SHAREABLE/MERGED IMG
	<RETMAPRANGE,8>,-		;ADR RANGE ACT MAPPED FOR SH/MRG IMG
	RETMAPADR,-			;ADR OF QUAD TO HOLD RET RANGE
	MAPBASE,-			;INADR BASE ADDED TO VA RANGE BEFORE MAP
-;
-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	RECUR_ARGCNT,-			;# ARGUMENTS IN CALL TO IMAGE ACTIVATOR
	RECUR_NAME,-			;ADR OF NAME DSC FOR IMAGE TO ACTIVATE
	RECUR_DFLTNAME,-		;ADR OF DEFAULT NAME STRING DSC
	RECUR_HDRBUF,-			;ADR OF HEADER BUFFER (ALWAYS 0)
	RECUR_IMGCTL,-			;IMAGE ACTIVATION CONTROL FLAGS
	RECUR_INADR2,-			;ADR OF QUADWD CONTAIN. INPUT ADR RANGE
	RECUR_RETADR2,-			;ADR OF QUADWD TO HOLD RETURN ADR RANGE
	RECUR_IDENT2,-			;ADR OF QUADWD CONTAIN. MATCH INFO
	RECUR_ACMODE,-			;ACCESS MODE OF OWNER OF PAGES
-; KEEP THE PRECEDING DEFINITIONS TOGETHER
-;
	RECUR_STARTVA,-			;REMEM STARTVA FROM ISD FOR 1ST GBLSEC
	<RECUR_INADR,8>,-		;QUADWD CONTAIN. INPUT ADR RANGE TO MAP
	<RECUR_RETADR,8>,-		;QUADWD TO HOLD RETURN ADR RANGE MAPPED
	<RECUR_IDENT,8>,-		;QUADWD CONTAIN. MATCH CTL INFORMATION
	<RECUR_NAMDSC,8>,-		;STR DSC FOR FILE NAME (RECUR CALL)
	<RECUR_DFLTDSC,8>,-		;STR DSC FOR DEFAULT NAME (RECUR CALL)
	<RECUR_FILNAM,16>,-		;BUFFER FOR ASCIC IMAGE SECTION NAME
	RECUR_SHLENTRY,-		;ADDRESS OF SHL ENTRY IN EXECUTABLE IMAGE
-;
-; KEEP THE FOLLOWING DEFINITIONS TOGETHER
	NXTKVEC_SAV,-			;SAVED OFFSET TO NEXT FREE KERNEL VECTOR
	NXTEVEC_SAV,-			;SAVED OFFSET TO NEXT FREE EXEC VECTOR
	NXTRVEC_SAV,-			;SAVED OFFSET TO NEXT FREE RUNDWN VECTOR
	NXTMVEC_SAV,-			;SAVED OFFSET TO NEXT FREE MSG VECTOR
	RMSBASE_SAV,-			;SAVED RMS BASE FROM CTL$GL_RMSBASE
-; KEEP THE PRECEDING DEFINITIONS TOGETHER
-;
	CRM_RET_CODE,-			;STATUS CODE RETURNED FROM MAPPING SEC
	<RSLTNAME,<<NAM$C_MAXRSS+1>>>,-	;RESULTANT NAME STRING
-;
-; ALL INSERTIONS MUST BE MADE BEFORE THE FOLLOWING
-;
	<MAXPOSOFF,0>,-			;MAXIMUM POSITIVE OFFSET
	<,<1024+MAXNEGOFF-.>>,-		;FILL OUT THE REMAINDER OF THE PAGES
	<OTHERHDR,512>,-		;PAGE BUFFER FOR OTHER THAN FIRST HEADER
	<FIRSTHDR,512>-			;PAGE BUFFER FOR FIRST HEADER
	>
;
; MAKE SURE THAT TOTAL SCRATCH DEFINED FITS IN THE PAGES RESERVED FOR IT.
;
	MAXTOTOFF=MAXPOSOFF-MAXNEGOFF
	ASSUME MAXTOTOFF LE 1024

;
;   OFFSETS FROM AP
;
	$OFFSET		0,POSITIVE,<-

	PARAMCNT,-			;# OF PARAMETERS SPECIFIED IN LIST
	NAME,-				;DESCRIPTOR FOR FILE NAME STRING
	DFLTNAME,-			;DESCRIPTOR FOR DEFAULT FILE NAME STRING
	HDRBUF,-			;ADDRESS OF 512 BYTE BUFFER TO WRITE IN
	IMGCTL,-			;IMAGE CONTROL FLAGS
	INADR2,-			;ADR OF INPUT ADDRESS RANGE FOR 2ND IMG
	RETADR2,-			;ADR OF RETURN ADDRESS RANGE FOR 2ND IMG
	IDENT2-				;ADDRESS OF IDENT FOR SHAREABLE IMAGE
	OWN_ACMODE-			;ACCESS MODE OF OWNER OF PAGES
	>

;	OFFSETS INTO DISPATCH VECTOR PAGES

NXTKVEC=0				;NEXT FREE KERNEL MODE VECTOR
NXTEVEC=256				;NEXT FREE EXEC MODE VECTOR
NXTRVEC=512				;NEXT FREE RUNDWN TYPE VECTOR
NXTMVEC=768				;NEXT FREE MESSAGE VECTOR

;	SYMBOLIC NAMES FOR ADDRESSING MODES

AT_R5_MODE    = ^X65			;MODE IS (R5)
ABSOLUTE_MODE = ^X9F			;MODE IS @#
JSB_ABSOLUTE  = <ABSOLUTE_MODE@8> ! OP$_JSB	;BEGINNING OF "JSB @#"
RSB_ABSOLUTE  = <ABSOLUTE_MODE@8> ! OP$_RSB	;BEGINNING OF "RSB @#"

; OWN STORAGE:

	.PSECT	$$$210,LONG
MMG$GL_IACLOCK::
	.LONG	0			;IMAGE ACTIVATOR INTERLOCK

	.SBTTL	IMAGE ACTIVATOR

;++
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,SYS$IMGACT
;
;
; INPUT PARAMETERS:
;
;	PARAMCNT(AP)	=	NUMBER OF INPUT PARAMETERS SPECIFIED IN LIST
;	NAME(AP)	=	STRING DESCRIPTOR OF FILE NAME TO ACTIVATE
;	DFLTNAME(AP)	=	STRING DESCRIPTOR FOR DEFAULT FILE NAME
;				NOT USED IF INITIALIZING SYSTEM
;	HDRBUF(AP)	=	ADDRESS OF 512 BYTE BUFFER IN WHICH THE
;				IMAGE HEADER, IMAGE FILE DESCRIPTOR, AND
;				ADDRESS OF MOST RECENTLY USED FAB ARE RETURNED
;				THE FIRST 3 LONG WORDS ARE THE ADDRESSES
;				(IN THE BUFFER) OF:
;					1) THE IMAGE HEADER ($IHDDEF)
;					2) THE IMAGE FILE DESCRIPTOR ($IFDDEF)
;					3) ADR OF FAB FOR MOST RECENT OPEN
;					   (FAB IS IN IMAGE ACTIVATOR SCRATCH
;					    PAGES); 0 IF NO FAB AVAILABLE
;				IN A RECURSIVE CALL (IAC$V_SHAREABLE SET IN 
;				IMGCTL), THIS IS THE ADDRESS OF A WORD TO 
;				RECEIVE THE CHANNEL NUMBER FOR THE SHARED IMAGE
;	IMGCTL(AP)	=	IMAGE ACTIVATION CONTROL PARAMETERS
;				BIT 0 = IAC$V_NOACT, SET IF NOT ACTIVATING
;					THE IMAGE.  USED BY INSTALL TO COMPLETE
;					THE ENHANCEMENT OF THE KNOWN FILE ENTRIES
;				BIT 1 = IAC$V_WRITABLE, SET IF IMAGE IS 
;					SUPPOSED TO BE WRITABLE
;				BIT 2 = IAC$V_SHAREABLE, SET IF IMAGE IS A SHARE-
;					ABLE IMAGE BEING ACTIVATED AS A PIECE OF
;					AN EXECUTABLE IMAGE.  (USED ONLY IN
;					RECURSIVE CALL.)
;				BIT 3 = IAC$V_PRIVILEGE, SET IF EXECUTABLE IMAGE
;					HAS AMPLIFIED PRIVILEGE. REQUIRES THE
;					SHAREABLE IMAGE TO BE INSTALLED AS A
;					KNOWN FILE.  (IAC$V_SHAREABLE MUST ALSO
;					BE SET.)
;				BIT 4 = IAC$V_MERGE, SET IF MERGING ONE EXECUTABLE
;					IMAGE INTO THE ADDRESS SPACE OF ANOTHER.
;					CAUSES THE STACK, I/O SEGMENT AND PRIVILEGE
;					AMPLIFICATION TO BE IGNORED. MUST BE SET
;					IF IMAGE ACTIVATOR CALL IS TO BE ALLOWED
;					FROM USER MODE.
;				BIT 5 = IAC$V_EXPREG, SET IF INADR2(AP) IS A
;					BLUEPRINT OF WHICH VA SPACE (P0 OR P1)
;					IS TO BE USED AND NOT THE SPECIFIC
;					ADDRESS RANGE.  (IAC$V_MERGE MUST ALSO
;					BE SET.)
;	INADR2(AP)	=	ADDRESS OF QUADWORD CONTAINING INPUT ADDRESS
;				RANGE.  IF SPECIFIED, IS THE ADDRESS SPACE TO
;				CONTAIN THE IMAGE.
;	RETADR2(AP)	=	ADDRESS OF QUADWORD TO CONTAIN THE RETURN ADDRESS
;				RANGE, I.E., THE ADDRESS SPACE ACTUALLY CONTAINING
;				THE IMAGE MAPPED IN.
;	IDENT2(AP)	=	ADDRESS OF QUADWORD CONTAINING THE VERSION
;				NUMBER AND MATCHING CRITERIA FOR A SHAREABLE
;				IMAGE.
;	ACMODE(AP)	=	ACCESS MODE OF OWNER OF PAGES (THIS PARAMETER
;				IS NOT CURRENTLY USED).
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - TOTALLY SUCCESSFUL ACTIVATION
;	SS$_SYSVERDIF - IMAGE LINKED AGAINST DIFFERENT VERSION OF SYSTEM
;			THAN IS RUNNING
;	ALL SYSTEM ERROR CODES FROM VARIOUS SYSTEM SERVICES.
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED

EXE$IMGACT::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_IMGACT		;HOP, SKIP TO REAL ROUTINE

	.PSECT	YF$$SYSIMGACT
;
; **********************************************************************
;

	.ENABL	LSB
GET_OTHER_BUF:
	ADDL2	#<512*4>,R6		;POINT TO OTHER SCRATCH BUFFER
	MOVPSL	R1			;CHECK IF CALLED FROM EXEC MODE
	CMPZV	S^#PSL$V_PRVMOD,S^#PSL$S_PRVMOD,R1,S^#PSL$C_EXEC
	BEQL	3$			;IF SO, ALLOW RECURSIVE CALL
1$:	MOVZWL	#SS$_IVSTSFLG,R0	;SET ERROR CODE TO RETURN
2$:	RET				;EXIT FROM SYSTEM SERVICE

	ASSUME IAC$V_NOACT EQ 0
3$:	BLBS	R5,1$			;BR ON ERROR, NOACT CALLS CAN'T BE RECUR
	BRB	5$			;CONTINUE

EXE_IMGACT:
	CLRL	R7			;INIT INDICATOR TO NO KFI ENTRY
	MOVL	IMGCTL(AP),R5		;COPY IMAGE ACTIVATOR CONTROL FLAGS
	BBC	#IAC$V_SETVECTOR,R5,4$	;IS THIS SPECIAL ENTRY TO SET VECTORS?
	BSBW	SET_VECTORS_AGAIN	;ALLOW PRIVILEGED CODE TO EXECUTE
	RET


4$:	BITL	#^C<IAC$M_NOACT ! -	;CHECK THAT
		IAC$M_WRITABLE ! -	;ONLY VALID
		IAC$M_SHAREABLE ! -	;CONTROL FLAGS
		IAC$M_PRIVILEGE ! -	;ARE SPECIFIED
		IAC$M_EXPREG ! -	;
		IAC$M_MERGE ! -	;
		IAC$M_P1MERGE>,R5	;
	BNEQ	1$			;BR IF ILLEGAL FLAG SPECIFIED
	MOVAL	@#MMG$IMGACTBUF-MAXNEGOFF,R6 ;SCRATCH AREA BASE ADDRESS
	BBS	#IAC$V_SHAREABLE,R5,GET_OTHER_BUF ;BR IF RECURSIVE CALL
5$:	MOVAL	FIRSTHDR(R6),R4		;ADR OF IMAGE HEADER BUFFER
	PUSHAL	(R4)			;PUSH END VIRTUAL ADDRESS (INCLUSIVE)
	PUSHAL	(R6)			;AND STARTVA PARAMETERS
	$CRETVA_S INADR=-8(FP),-	;CREATE IMAGE ACTIVATOR SCRATCH PAGES
		ACMODE=S^#PSL$C_USER
	BLBC	R0,2$			;EXIT IF FAILED TO FIND VA
	MOVL	R5,IACFLG(R6)		;REMEMBER IMAGE ACTIVATION FLAGS
	MOVL	#4,KRNLARG(R6)		;INIT ARGUMENT LIST FOR KERNEL MODE RTNS
	MOVL	R6,IMGACTCTX(R6)	;ADDRESS OF SCRATCH STORAGE AT 8(AP)
	BISB	#IAC$M_SHAREABLE,RECUR_IMGCTL(R6) ;POTENTIAL RECUR CALL CTL BIT
	BBS	#IAC$V_MERGE,IACFLG(R6),7$ ;BR IF NOT MERGE REQUEST
	BBS	#IAC$V_EXPREG,IACFLG(R6),1$ ;EXPREG ONLY LEGAL ON MERGE CALL
7$:	MOVAB	RETSTARTVA(R6),RETADR(R6) ;SET RETURN ADR BUFFER FOR $CRMPSC
	MOVAB	RECUR_FILNAM+1(R6),RECUR_NAMDSC+4(R6) ;PNT STR DESC TO BUFFER
;
; REMEMBER THE NEXT FREE VECTOR ADDRESSES.  IF AN ERROR OCCURS DURING IMAGE
; ACTIVATION, THESE VECTORS MUST BE RESET BEFORE EXITING.
;
	ASSUME	NXTEVEC_SAV EQ <NXTKVEC_SAV + 4>
	ASSUME	NXTRVEC_SAV EQ <NXTEVEC_SAV + 4>
	ASSUME	NXTMVEC_SAV EQ <NXTRVEC_SAV + 4>
	MOVAB	@#CTL$A_DISPVEC,R0	;GET ADR OF VECTOR PAGES
	MOVAB	NXTKVEC_SAV(R6),R1	;GET ADR OF FIRST SAVED VECTOR SPACE
	MOVL	NXTKVEC(R0),(R1)+	;SAVE NEXT FREE KERNEL MODE VECTOR
	MOVL	NXTEVEC(R0),(R1)+	;SAVE NEXT FREE EXEC MODE VECTOR
	MOVL	NXTRVEC(R0),(R1)+	;SAVE NEXT FREE RUNDWN TYPE VECTOR
	MOVL	NXTMVEC(R0),(R1)+	;SAVE NEXT FREE MESSAGE VECTOR
	MOVL	@#CTL$GL_RMSBASE,RMSBASE_SAV(R6) ;SAVE RMS BASE ADDRESS
;
; GO THROUGH ALL THE MOTIONS OF ACTIVATING THE IMAGE WITHOUT DAMAGING
; THE PROGRAM THAT CALLED.  THIS IS USED FOR DOING ALL THE KNOWN FILE
; ENTRY ENHANCEMENTS BY THE INSTALL PROGRAM.  NOTHING IS MAPPED DURING
; THE $CRMPSC OR $CRETVA CALLS, SINCE THE INADR ARGUMENT IS A ZERO.
; (ONLY $CRETVA RETURNS AN ERROR, WHICH IS IGNORED.)
;

	ASSUME	IAC$V_NOACT EQ 0
	BLBC	R5,10$			;BRANCH IF ACTUALLY ACTIVATING IMAGE
	ASSUME	IAC$C_LARGEST LE 7
	BITB	#^C<IAC$M_NOACT ! IAC$M_WRITABLE>, - ;ONLY WRIT IS VALID WITH
		R5			;NOACT:  ALL OTHER BITS MUST BE CLEAR
	BNEQ	INV_FLAG		;BR ON ERROR, IF ANOTHER BIT SET
	MOVZBL	S^#SS$_NORMAL,RETSTATUS(R6) ;ASSUME RETURN STATUS IS SUCCESS
	BRB	20$			;SKIP RESETTING THE RMS IMAGE CONTEXT

10$:	BBS	#IAC$V_SHAREABLE,IACFLG(R6),15$ ;DON'T RESET IF RECURSIVE CALL
	BBS	#IAC$V_MERGE,IACFLG(R6),12$ ;DON'T RESET IF MERGE CALL
	JSB	G^RM$RESET		;RESET RMS IMAGE CONTEXT
;
;  It is necessary for the fixup vector pointers from the previous image to
;  be cleared before another image is activated. Note that this code path
;  does not execute on a recursive call or merged activation nor does it
;  execute in the NOACT case. 
;
	BSBW	IAC$RESET_IAF		;RESET FIXUP VECTOR CONTEXT
12$:	CLRL	@#CTL$GL_FIXUPLNK	;CLEAR FIXUP LIST POINTER
;
15$:	MOVAL	STARTVA(R6),INADR(R6)	;ADDRESS OF STARTVA,ENDVA
20$:	MOVL	@#CTL$GL_CTLBASVA,CTLBASADR(R6) ;CONTROL REGION BASE ADDRESS
	MOVL	INADR2(AP),R0		;GET ADR OF INPUT RANGE TO MAP
	BEQL	30$			;BR IF NONE SPECIFIED
	IFNORD	#8,(R0),IMGACT_ACCVIO	;ERROR IF CALLER CANNOT ACCESS IT
	MOVQ	(R0),INMAPRANGE(R6)	;SAVE THE RANGE FOR LATER
	BBC	#IAC$V_P1MERGE,IACFLG(R6),22$ ;SKIP NEXT UNLESS P1 MERGE
	BBC	#IAC$V_MERGE,IACFLG(R6),INV_FLAG ;MERGE MUST ALSO BE SET
	BBS	#VA$V_P1,INMAPRANGE(R6),22$ ;IS THIS P1MERGE INTO P0 SPACE?
	BBSS	#IAC$V_P1MERG_P0,IACFLG(R6),22$ ;IF SO, SET INTERNAL FLAG
22$:	BBC	#IAC$V_EXPREG,IACFLG(R6),40$ ;BRANCH IF INPUT RANGE IS EXACT
	MCOML	#0,INMAPRANGE+4(R6)	;ASSUME LARGEST POSSIBLE ENDVA
	BRB	40$			;SKIP CHECK FOR REQUIRED INADR PARAMETER

INV_FLAG:
	MOVZWL	#SS$_IVSTSFLG,R0	;SET INVALID STATUS FLAG ERROR CODE
	BRB	25$			;RETURN ERROR CODE TO CALLER

BAD_PARAM:
	MOVZWL	#SS$_BADPARAM,R0	;SET ERROR CODE, BAD PARAMETERS
25$:	BRW	IMGACT_RET		;TAKE ERROR EXIT PATH


30$:	MCOML	#0,INMAPRANGE+4(R6)	;SET HIGHEST POSSIBLE ENDVA
	BBS	#IAC$V_MERGE,IACFLG(R6),BAD_PARAM ;BR IF NO IN RANGE ON MERGE
	BBS	#IAC$V_SHAREABLE,IACFLG(R6),BAD_PARAM ;BR IF NO INRANG ON SH IMG
40$:	MCOML	#0,RETSTARTVA_CUM(R6)	;INITIALIZE INTERNAL COPY OF MAPPED 
	MCOML	#0,RETSTARTVA_CUM+4(R6)	; ADDRESS RANGE TO MINUS ONE
	MOVL	RETADR2(AP),R0		;DOES CALLER WANT THIS INFORMATION?
	BEQL	50$			;SKIP PROBE IF NOT
	IFNOWRT	#8,(R0),IMGACT_ACCVIO	;ERROR IF CALLER CANNOT ACCESS ARRAY
	MOVQ	RETSTARTVA_CUM(R6),(R0)	;SET CALLER'S ARRAY TO MINUS ONE, TOO
50$:	MOVL	R0,RETMAPADR(R6)	;SAVE ADDRESS OF RETURN RANGE
	MOVL	IDENT2(AP),R0		;GET ADR OF IDENT QUADWORD
	BEQL	60$			;BR IF NONE SPECIFIED
	IFNORD	#8,(R0),IMGACT_ACCVIO	;CHECK IF QUADWORD IS READABLE BY CALLER
	MOVQ	(R0),IDMATCHCTL(R6)	;REMEMBER MATCH CONTROL AND IDENT
	BRB	70$			;CONTINUE

IMGACT_ACCVIO:
	BRW	IMGACT_ACCVIO1		;ERROR EXIT


60$:	BBS	#IAC$V_SHAREABLE,IACFLG(R6),BAD_PARAM ;RECUR REQUIRES IDENT
70$:	MOVL	NAME(AP),R0		;DESCRIPTOR FOR FILE NAME
	IFNORD	#8,(R0),IMGACT_ACCVIO 	;ERROR IF CALLER CANNOT ACCESS IT
	MOVQ	(R0),R1			;R1 = SIZE, R2 = ADDRESS
	MOVZBL	R1,R1			;LIMIT SIZE FOR PROBE
	IFNORD	R1,(R2),IMGACT_ACCVIO 	;ERROR IF CALLER CANNOT ACCESS STRING
	MOVAL	FAB(R6),R5		;ADDRESS OF FILE ACCESS BLOCK
	BBS	S^#EXE$V_INIT,G^EXE$GL_FLAGS,RMSOPEN ;USE RMS IF SYSTEM INITIALIZED
	BRW	MANUAL_OPEN		;OPEN THE FILE WITHOUT RMS OR FCP


	.DSABL	LSB
IMGACT_RET:
	BRW	IMGACT_ERREXIT
	.PAGE
	.SUBTITLE	OPEN THE IMAGE FILE

;++
;
;  At this point, the argument list has been at least partially validated
;  and the image activator impure area has been initialized. Now the image
;  file must be opened. More special action may be taken, based on the contents
;  of the image header in the image file. Two special cases that must be 
;  accounted for are compatibility mode images and images produced by the
;  cross linker. File opens without the benefit of an ACP or RMS are handled
;  out of line and have already been checked for.
;
;  Input parameters:
;
;	R1 = Size of file name string
;	R2 = Address of file name string
;
;	R5 = Address of FAB
;	R6 = Address of image activator impure area
;
;--

	.ENABL	LSB

RMSOPEN:
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1 ;ID AND SIZE ADJACENT
	MOVW	#<FAB$C_BLN@8+FAB$C_BID>,FAB$B_BID(R5) ;SET ID AND SIZE
	MOVL	R2,FAB$L_FNA(R5) 	;STORE FILE NAME ADDRESS
	MOVB	R1,FAB$B_FNS(R5) 	;AND SIZE
	MOVL	DFLTNAME(AP),R0		;DESCRIPTOR FOR DEFAULT NAME STRING
	BEQL	20$			;BRANCH IF NONE SPECIFIED
	IFNORD	#8,(R0),IMGACT_ACCVIO 	;ERROR IF CALLER CANNOT ACCESS DESCRIPTOR
	MOVQ	(R0),R0			;R0 = SIZE, R1 = ADDRESS
	MOVZBL	R0,R0			;LIMIT SIZE FOR PROBE
	IFNORD	R0,(R1),IMGACT_ACCVIO 	;ERROR IF CALLER CANNOT ACCESS STRING
	MOVL	R1,FAB$L_DNA(R5) 	;SET DEFAULT NAME ADDRESS
	MOVB	R0,FAB$B_DNS(R5) 	;AND SIZE

;
; R0-R3 = GARBAGE
; R4 = ADDRESS TO READ IMAGE HEADER INTO
; R5 = FAB ADDRESS
; R6 = IMAGE ACTIVATOR CONTEXT AREA
;
20$:
RSX_AME_OPEN:
	ASSUME	NAM EQ FAB-NAM$C_BLN
	MOVAL	NAM-FAB(R5),R3		;ADDRESS OF NAME BLOCK
	MOVL	R3,FAB$L_NAM(R5) 	;STORE IN FAB
	ASSUME	NAM$B_BLN EQ NAM$B_BID+1 ;ID AND SIZE ADJACENT
	MOVW	#<NAM$C_BLN@8+NAM$C_BID>,NAM$B_BID(R3) ;SET ID AND SIZE
	MOVAL	RSLTNAME+1(R6),NAM$L_RSA(R3) ;SET RESULT NAME STRING ADDRESS
	MOVB	#NAM$C_MAXRSS,NAM$B_RSS(R3) ;AND MAX SIZE
	MOVL	NAM$L_RSA(R3),NAM$L_ESA(R3) ;SET UP EXPANDED STRING TOO
	MOVB	NAM$B_RSS(R3),NAM$B_ESS(R3) ;IN CASE OF FID OPEN OF KNOWN FILE

	ASSUME	FAB$B_SHR EQ FAB$B_FAC+1
	MOVZBW	#FAB$M_EXE,FAB$B_FAC(R5) ;OPEN FOR EXECUTE, DEFAULT SHARING
	BBC	#IAC$V_WRITABLE,IACFLG(R6),25$ ;BRANCH IF JUST OPEN FOR READING
	MOVW	#<<FAB$M_SHRGET ! FAB$M_SHRPUT ! FAB$M_UPI>@8 !-
		FAB$M_PUT>,FAB$B_FAC(R5) ;OPEN FOR WRITING, SHARED

25$:	MOVL	#<FAB$M_UFO !-		;USER FILE OPEN
		FAB$M_UFM ! FAB$M_ESC !- ;IN USER MODE
		FAB$M_PPF !-		;PROCESS PERMANENT FILE
		FAB$M_KFO>,FAB$L_FOP(R5) ;KNOWN FILE OPEN
	CLRL	FAB$L_CTX(R5)		;KNOWN FILE ENTRY ADDRESS RETURNED HERE
	MNEGB	#1,FAB$B_RTV(R5)	;ALLOCATE AN "OPTIMAL" WINDOW
					;SMALL FOR CONTIGUOUS FILE (NORMAL CASE)
					;NO WINDOW TURN FOR FRAGMENTED IMAGE
	CLRB	FAB$B_DSBMSK(R5)	;ASSUME ALL NAME TABLES CAN BE USED
	BBC	#IFD$V_PRIV,@#IAC$GL_IMAGCTX,23$ ;BRANCH IF NOT PRIVILEGED
	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),23$		;DO NOT DISABLE IF CALLED BY INSTALL
	MOVB	#^B110,FAB$B_DSBMSK(R5)	;DISABLE PROCESS AND GROUP TABLES
23$:	CLRB	NAM$B_RSL(R3)		;RESULTANT STRING LENGTH IS RETURNED
					;IF FULL OPEN IS DONE, OTHERWISE ONLY
					;EXPANDED STRING LENGTH IS RETURNED
	$OPEN	(R5)			;OPEN THE FILE
MANUAL_OPN_DONE:
	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),31$		;NO BUFFER ON NOACT REQUEST
	MOVL	HDRBUF(AP),R2		;ADDRESS OF RETURN BUFFER
	BEQL	31$
	MOVL	R2,IMGHDRBUF(R6)	;REMEMBER IMG HDR BUF ADR FOR SETCTLREG
	BBC	#IAC$V_SHAREABLE,IACFLG(R6),30$ ;DON'T RESET IF RECURSIVE CALL
	IFNOWRT #2,(R2),IMGACT_ACCVIO2	;ERROR IF CAN'T WRITE 2 BYTES FOR CHANNEL
	BRB	31$
30$:	IFNOWRT	#512,(R2),IMGACT_ACCVIO2 ;ERROR IF CALLER CANNOT WRITE 512 BYTES
	MOVL	R5,8(R2)		;REMEM ADR OF CURRENT FAB (FOR ERR EXIT)
31$:	BLBC	R0,32$			;BRANCH IF FAILED TO OPEN SUCCESSFULLY
	MOVW	FAB$L_STV(R5),CHAN(R6)	;SAVE CHANNEL ON WHICH FILE IS OPEN
32$:	MOVL	FAB$L_CTX(R5),KFIADR(R6) ;KNOWN FILE ENTRY ADDRESS IF ANY

	ASSUME	DEV$V_SQD LE 15
	ASSUME	DEV$V_NET LE 15
	BITW	#<DEV$M_SQD ! DEV$M_NET>,FAB$L_DEV(R5) ;NEED TO "LOAD" IMAGE?
	BEQL	36$			;BR IF NOT, MAP IT AS USUAL
	BBS	#DEV$V_NET,FAB$L_DEV(R5),34$ ;BRANCH IF NETWORK FILE
	CMPW	#512,FAB$W_BLS(R5)	;BLOCK SIZE MUST BE A PAGE FOR MAGTAPE
	BNEQ	36$			;IF NOT, LET CRMPSC GIVE THE ERROR

	ASSUME	IAC$V_NOACT EQ 0
34$:	BLBS	IACFLG(R6),36$		;DISALLOW INSTALL OF SEQUENTIAL LOAD FILES

	ASSUME	IAC$V_SEQDEVLOD GE 8
	ASSUME	IAC$V_SEQDEVLOD LT 16
	BISB	#IAC$M_SEQDEVLOD@-8,IACFLG+1(R6) ;SET "LOAD IMAGE" BIT
36$:
	MOVL	R0,R2			;SAVE OPEN RETURN STATUS
	MOVAL	W^OPEN_DONE_KRNL,KRNLROUT(R6) ;SEE IF FILE IS EXECUTE ONLY
					;INCREMENT KNOWN FILE REFERENCE COUNT
	BSBW	CMKRNL			;IN KERNEL MODE
	BLBC	R0,38$			;BRANCH IF ERROR
	MOVL	R2,R0			;OPEN STATUS BACK TO R0
	MOVL	KFIADR(R6),R7		;GET KNOWN FILE ENTRY ADDRESS
	BLBS	R0,40$			;BRANCH IF OPENED SUCCESSFULLY
	BEQL	38$			;IF NOT KNOWN IMAGE, THEN EXIT
	BBC	#FAB$V_NAM+<FAB$L_FOP*8>,(R5),- ;AND IF NOT OPENING BY FILE ID
		38$			;THEN EXIT
	BSBW	ZERO_FID		;ZERO THE FILE ID AND TRY AGAIN
	BRW	25$			;ASSUMING THAT FILE WAS DELETED


IMGACT_ACCVIO2:
	BRW	IMGACT_ACCVIO1		;RETURN ERROR CODE


38$:	BRB	IMGACT_RET1

40$:	MOVB	NAM$B_RSL(R3),RSLTNAME(R6) ;BYTE COUNT OF RESULT NAME STRING
	BNEQ	50$			;BRANCH IF THIS WAS RETURNED
	MOVB	NAM$B_ESL(R3),RSLTNAME(R6) ;OTHERWISE USE EXPANDED NAME STRING SIZE
50$:	TSTL	R7			;KNOWN FILE ENTRY?
	BGEQ	IS_OPEN_NOTKFI1		;BRANCH IF NOT
;
; SUCCESSFUL OPEN OF A KNOWN FILE
;
	BBC	#KFI$V_PROCPRIV,KFI$W_FLAGS(R7),60$ ;USE THE PRIVILEGE MASK?
	MOVPSL	R1			;IF CALLED FROM USER MODE
	CMPZV	S^#PSL$V_PRVMOD,S^#PSL$S_PRVMOD,R1,S^#PSL$C_USER
	BEQL	60$			;THEN NO ENHANCEMENT OF PRIVILEGE
	MOVQ	KFI$Q_PROCPRIV(R7),PROCPRIV(R6) ;USE PRIVILEGES OF THE KNOWN IMAGE
	BISB	#IAC$M_PRIVILEGE,RECUR_IMGCTL(R6) ;REMEM PRIV IMG FOR RECUR CALL
	BISB	#IFD$M_PRIV,IFDFLAGS(R6) ;INDIC TO CALLER PRIV IMAGE VIA IFD
	BISB	#IFD$M_PRIV,@#IAC$GL_IMAGCTX	;ALSO REMEMBER FOR LATER MERGES
60$:	BBS	#KFI$V_MARKDEL,KFI$B_KFICTL(R7),100$ ;BRANCH IF MARKED FOR DELETE
	CMPW	#<RMS$_KFF&^XFFFF>,R0	;IF OPEN STATUS IS KNOWN FILE FOUND
	BEQL	IS_OPEN_KFI		;THEN IT IS ALL SET
	BBS	#FAB$V_NAM+<FAB$L_FOP*8>,(R5),- ;IF FILE WAS OPEN BY NAME BLOCK
		IS_OPEN_KFI		;THEN IT IS ALL SET
	BBS	#KFI$V_KP_OPEN,KFI$W_FLAGS(R7),- ;IF SUPPOSED TO KEEP FILE OPEN
		80$			;THEN PROMOTE WCB INTO KFI ENTRY
;
; NOT KEEPING THE FILE OPEN, AT LEAST SET UP KNOWN FILE ENTRY SO THAT
; SUBSEQUENT OPENS WILL OPEN BY FILE ID.
;
	MOVAL	W^KRNL_SET_FID,KRNLROUT(R6) ;ADR OF ROUTINE TO SET FILE ID
	BRB	120$

80$:	MOVAL	W^MAKE_SHARED_WCB,KRNLROUT(R6) ;INIT KFI ENTRY TO KEEP
	BRB	120$			;THE FILE OPEN

100$:	MOVAL	W^MARKED_FOR_DEL,KRNLROUT(R6) ;ENTRY IS MARKED FOR DELETE
					;GO GET KFI ENTRY DELETED
120$:	BSBW	CMKRNL			;DO THIS IN KERNEL MODE
	BLBS	R0,IS_OPEN_KFI		;BRANCH IF SUCCESSFUL

	.DSABL	LSB

IMGACT_RET1:
	BRW	IMGACT_ERREXIT


IS_OPEN_NOTKFI1:
	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),3$		;SKIP NEXT CASE IF INSTALLING IMAGE
	BBS	#IFD$V_PRIV,@#IAC$GL_IMAGCTX,5$	;ERROR IF IN PRIVILEGED CONTEXT
3$:	BBC	#IAC$V_PRIVILEGE,IACFLG(R6),IS_OPEN_NOTKFI ;BR IF NOT PRIVILEGED
5$:	MOVZWL	#SS$_PRIVINSTALL,R0	;SS$_PRIVINSTALL ERROR, SHAREABLE IMAGES
	BRW	IMGACT_ERREXIT		;MUST BE INSTALLED FOR PRIV EXEC IMAGE


IS_OPEN_KFI:
	MOVZWL	KFI$W_FLAGS(R7),R1	;GET KNOWN FILE FLAGS WORD

	ASSUME	KFI$V_KP_OPEN EQ 0
	BLBS	R1,10$			;IF NOT KEEPING FILE OPEN
	BICW	#<KFI$M_KP_RESHDR !-	;THEN MAY NOT KEEP HEADER RESIDENT
		KFI$M_KP_SHARED>,R1	;OR MAKE IMAGE SHARED
10$:	MOVW	R1,KFIFLG(R6)		;KEEP A STABLE COPY OF THE FLAGS
	BBC	#KFI$V_SHMIDENT,R1,15$	;BR IF SHM IDENT NOT USED FOR GBL SEC
	ASSUME	IAC$V_SHMIDENT GE 16
	ASSUME	IAC$V_SHMIDENT LT 24
	BISB	#IAC$M_SHMIDENT@-16,IACFLG+2(R6) ;SHOW SHM TYPE IDENT USED FOR GBL SEC
15$:	BBS	#KFI$V_COMPATMOD,R1,-	;IF COMPATIBILITY MODE
		RSX_KNOWN_FILE		;THEN SKIP READING THE IMAGE HEADER
	BITW	#<KFI$M_KP_RESHDR!KFI$M_IS_RESHDR>,R1 ;RESIDENT HDR?
	BEQL	40$			;BRANCH IF NOT SUPPOSED TO BE
	BBC	#KFI$V_IS_RESHDR,R1,20$	;BRANCH IF NEED TO MAKE IT RESIDENT
;
; HEADER IS RESIDENT, GET ITS ADDRESS
;
	MOVL	KFI$L_IMGHDR(R7),R3	;ADDRESS OF HEADER BUFFER
	MOVL	R3,R4			;NEED IT IN BOTH REGISTERS
	MOVL	-KFH$C_LENGTH(R3),BUFEND(R6) ;ADDRESS OF END OF BUFFER
	MNEGL	#1,HDRVBN(R6)		;IN CASE WE TRY TO READ ANOTHER BLOCK
	ASSUME	IAC$V_IS_RESHDR GE 8
	ASSUME	IAC$V_IS_RESHDR LT 16
	BISB	#IAC$M_IS_RESHDR@-8,IACFLG+1(R6) ;NOTE IMAGE HEADER IS RESIDENT
	BRW	FIRSTHDRBLK1		;PROCESS THE IMAGE HEADER AS USUAL


	ASSUME	IAC$V_KP_RESHDR GE 8
	ASSUME	IAC$V_KP_RESHDR LT 16
20$:	BISB	#IAC$M_KP_RESHDR@-8,IACFLG+1(R6) ;WANT TO MAKE HEADER RESIDENT
40$:
IS_OPEN_NOTKFI:
	MOVL	#1,HDRVBN(R6)		;ADDRESS OF FIRST HEADER BLOCK
	MOVL	R4,R3			;ADDRESS TO READ INTO

;
; R3 = ADDRESS OF HEADER TO READ INTO
; R4 = ADDRESS OF IMAGE HEADER = R3 IF FIRST HEADER BLOCK
;
NXTHDR:
	ROTL	#9,#1,R2		;R2=^X200
	ADDL3	R2,R3,BUFEND(R6)	;ADDRESS OF END OF BUFFER
	MOVL	HDRVBN(R6),R1		;DESIRED VBN TO READ
	BSBW	READ_VBN		;READ THE DESIRED BLOCK
	BLBC	R0,IMGACT_RET1		;BRANCH IF ERROR
	INCL	HDRVBN(R6)		;COUNT THE HEADER BLOCKS READ
	CMPL	R3,R4			;IS THIS 1ST HDR?
	BEQL	FIRSTHDRBLK		;BRANCH IF YES
	BRW	CHKISD			;CHECK ISD ADDRESS AND SIZE


;
; THE IMAGE OPENED WAS AN RSX TASK
; START THE RSX APPLICATION MIGRATION EXECUTIVE (RSX AME)
;


;
; COMPATIBILITY MODE IMAGES MAY NOT BE STARTED VIA MERGE REQUESTS OR
; RECURSIVE CALLS.
;
INV_RSX_FLAG:
	BRW	INV_FLAG		;BR TO RETURN ERROR MESSAGE


	.ENABL	LSB

RSX_IMAGE:
	BBS	#IAC$V_MERGE,IACFLG(R6),INV_RSX_FLAG ;BR IF ERROR, INV MERGE
	BBS	#IAC$V_SHAREABLE,IACFLG(R6),INV_RSX_FLAG ;BR ON ERR, INV RECUR
	MOVL	R0,AMECOD(R6)		;SAVE THE DESIRED AME CODE
	TSTL	R7			;KNOWN FILE?
	BGEQ	20$			;BRANCH IF NOT
	BSBW	KFI_COMPAT_MODE		;YES, INIT COMPAT MODE KNOWN FILE ENTRY
	BRB	20$

RSX_KNOWN_FILE:
	BBS	#IAC$V_MERGE,IACFLG(R6),INV_RSX_FLAG ;BR IF ERROR, INV MERGE
	BBS	#IAC$V_SHAREABLE,IACFLG(R6),INV_RSX_FLAG ;BR ON ERR, INV RECUR
	BSBW	KFI_DECREF		;IF KNOWN FILE, RELEASE THE REFERENCE
	MOVZWL	KFI$W_AMECOD(R7),AMECOD(R6) ;GET DESIRED AME CODE
20$:	BRW	AME_IMAGE		;SET UP TO ACTIVATE DESIRED AME


	.DSABL	LSB

BADIMGHDR:
	MOVZWL	#SS$_BADIMGHDR,R0
	BRW	IMGACT_ERREXIT


;
; VALIDATE THE IMAGE HEADER
;
FIRSTHDRBLK:
	CVTWL	^X1FE(R4),R0		;RSX TASK IMAGE?
	BGEQ	RSX_IMAGE		;BRANCH IF AME REQUIRED
	INCL	R0			;MUST BE -1 ELSE ERROR
	BNEQ	BADIMGHDR		;BRANCH IF BAD HEADER
FIRSTHDRBLK1:
	.ENABL	LSB
	CMPW	IHD$W_SIZE(R4),-	;DOES IHD FIT WITH WORST CASE IFD
		#<512-<8+IFD$C_LENGTH+<<NAM$C_MAXRSS+4>&^C<3>>>> ;IN HEADER BUFFER
	BGTR	BADIMGHDR		;BAD HEADER IF IT DOESN'T
	CMPW	#IHX$K_MAJORID,IHD$W_MAJORID(R4) ;CROSS LINKER FORMAT?
	BNEQ	60$			;BRANCH IF NOT
;
; CROSS LINKER FORMAT
;

	BBS	#IAC$V_MERGE,IACFLG(R6),30$ ;BR IF ERROR, INVALID MERGE
	BBS	#IAC$V_SHAREABLE,IACFLG(R6),30$ ;BR ON ERR, INVALID RECURSION
	ASSUME	IAC$V_XLINKER GE 8
	ASSUME	IAC$V_XLINKER LT 16
	BISB	#IAC$M_XLINKER@-8,IACFLG+1(R6) ;SET CROSS LINKER FORMAT
	ASSUME	IAC$V_KP_RESHDR GE 8
	ASSUME	IAC$V_KP_RESHDR LT 16
	BICB	#IAC$M_KP_RESHDR@-8,IACFLG+1(R6) ;NO RESHDR FOR CROSS LINKER
	MOVZBL	IHX$B_HDRBLKCNT(R4),HDRBLKCNT(R6) ;GET HEADER BLOCK COUNT
	DECL	IMAGEPRIV(R6)		;ASSUME THAT IMAGE HAS
	DECL	IMAGEPRIV+4(R6)		;REQUESTED ALL PRIVILEGES
	BRW	75$			;SKIP HEADER ID AND PRIV CHECKS


;
; CROSS LINKER IMAGES MAY NOT BE ACTIVATED WITH MERGE OR RECURSIVE CALLS.
;
30$:	BRW	INV_FLAG		;RETURN ERROR CODE TO CALLER


60$:	CMPW	#IHD$K_MAJORID,IHD$W_MAJORID(R4) ;NATIVE FORMAT?
	BNEQ	BADIMGHDR		;BRANCH IF BAD HEADER
	MOVZBL	IHD$B_HDRBLKCNT(R4),HDRBLKCNT(R6) ; HEADER BLOCK COUNT
	ASSUME	IHD$W_IMGIOCNT EQ IHD$W_IOCHANCNT+2
	ASSUME IMGIOCNT EQ IOCHANCNT+2
	MOVL	IHD$W_IOCHANCNT(R4),IOCHANCNT(R6) ;CHANNEL COUNT AND IMAGE
					;I/O COUNT SPECIFIED AT LINK TIME
	CMPW	#IHD$L_SYSVER,IHD$W_ACTIVOFF(R4) ;IS SYSTEM VERSION IN IHD?
	BLSS	62$			;BR IF VERSION IS IN IMAGE HEADER
	MOVL	#1,R0			;SET A DUMMY SYSTEM VERSION AS IMAGE
					;HAD NO SYSTEM VERSION
	DECL	IMAGEPRIV(R6)		;ASSUME THAT THE IMAGE HAS ALL
	DECL	IMAGEPRIV+4(R6)		;PRIVILEGES ALLOWED
	CMPW	#IHD$L_LNKFLAGS,IHD$W_ACTIVOFF(R4) ;ARE LINK FLAGS IN IHD?
	BLSS	63$			;BR IF FLAGS ARE IN IMAGE HEADER
	BRB	64$			;BR PAST LNKFLAG CODE AS NOT IN IHD

;
; THERE ARE TWO SOURCES OF MATCH CONTROL INFORMATION:  THE SHAREABLE IMAGE
; HEADER AND THE INADR2 ARGUMENT OF THE RECURSIVE CALL.  THE INADR2 VALUE
; MUST MATCH OR BE MORE RESTRICTIVE THAN THE CONTENTS OF THE SHAREABLE
; IMAGE HEADER.  THE FOLLOWING TABLE HAS A BIT FOR EACH POSSIBLE COMBINATION
; OF MATCH CONTROL VALUES.  THE SHAREABLE IMAGE HEADER VALUE IS USED AS
; A BYTE OFFSET INTO THE TABLE.  THE INADR2 VALUE IS USED AS A BIT
; INDEX INTO A PARTICULAR BYTE OF THE TABLE.  IF THE BIT IS SET, THEN
; THE COMBINATION OF VALUES IS LEGAL; IF THE BIT IS CLEAR, THEN THE
; COMBINATION IS ILLEGAL AND AN ERROR MESSAGE, SS$_SHRIDMISMAT, IS RETURNED.
;
MATCHCTLTBL:				;SHAREABLE IMAGE HEADER VALUE:
	.BYTE	^B00001111		;  0 - MATCH ALL
	.BYTE	^B00001010		;  1 - MATCH EQUAL
	.BYTE	^B00001110		;  2 - MATCH LEQ
	.BYTE	^B00000000		;  3 - MATCH NEVER (ALL ZEROS SINCE
					;  MATNEV RECURSIVE CALLS CAN'T HAPPEN)
	.BYTE	^B00000000		;  4 - UNUSED VALUES
	.BYTE	^B00000000		;  5 - UNUSED VALUES
	.BYTE	^B00000000		;  6 - UNUSED VALUES
	.BYTE	^B00000000		;  7 - UNUSED VALUES

IDMISMATCH:
	MOVZWL	#SS$_SHRIDMISMAT,R0	;IDENT MISMATCH FOR SHR IMG
	BRW	IMGACT_ERREXIT		;RETURN WITH ERROR STATUS

BADIMGHDR2:
	BRW	BADIMGHDR		;BRANCH AID FOR ERROR PATH

62$:	MOVL	IHD$L_SYSVER(R4),R0	;GET VERSION OF SYSTEM IMAGE LINKED W/
	MOVQ	IHD$Q_PRIVREQS(R4),IMAGEPRIV(R6) ;GET PRIVILEGES FROM IHD
63$:	MOVL	IHD$L_LNKFLAGS(R4),LNKFLAGS(R6) ;GET IMAGE HEADER LINK FLAGS
64$:	TSTL	R0			;IS THERE A SYSTEM VERSION # TO CHECK?
;
; REPLACING THE "BEQL 65$" WITH "BRB 65$" WILL TURN OFF VERSION CHECKING.
;
	BEQL	65$			;BR IF NO VERSION # TO CHECK
	CMPL	R0,#SYS$K_VERSION	;DOES CURRENT SYSTEM VERSION NUMBER
					;MATCH THAT IN THE IMAGE HEADER?
	BEQL	65$			;BR IF IT MATCHES
	ASSUME	IAC$V_NOCMKRNL GE 8
	ASSUME	IAC$V_NOCMKRNL LT 16
	BISB	#IAC$M_NOCMKRNL@-8,IACFLG+1(R6) ;DOESN'T MATCH, THEREFORE SET
					;FLAG TO REMOVE CMKRNL/CMEXEC PRIVS
65$:	CMPB	IHD$B_IMGTYPE(R4),#IHD$K_LIM ;IS THIS A SHAREABLE IMAGE?
	BNEQ	70$			;BRANCH IF NOT
	ASSUME	IAC$V_LIM GE 8
	ASSUME	IAC$V_LIM LT 16
	BISB	#IAC$M_LIM@-8,IACFLG+1(R6)	;YES, NOTE THAT IT IS
	BBC	#IAC$V_SHAREABLE,IACFLG(R6),70$ ;BR IF NOT RECURSIVE CALL
	EXTZV	#IHD$V_MATCHCTL,#IHD$S_MATCHCTL,- ;MATCH CONTROL FROM IMG HDR
		LNKFLAGS(R6),R1		;MUST MATCH OR BE LESS RESTRICTIVE
	BBC	IDMATCHCTL(R6),-	;THAN THAT PASSED IN RECURSIVELY
		MATCHCTLTBL[R1],IDMISMATCH ;BR IF MORE RESTRICTIVE, ERROR
	BBC	#IAC$V_SHAREABLE,IACFLG(R6),70$ ;BR IF NOT RECURSIVE CALL
	TSTL	IDMATCHCTL(R6)		;WHAT IS THE MATCH CONTROL?
	BEQL	70$			;BR IF MATCH ALWAYS, OK TO USE SHR IMG
	CMPB	IDMATCHCTL+7(R6),IHD$L_IDENT+3(R4) ;MAJOR ID MATCH?
	BNEQ	IDMISMATCH		;BR IF DOES NOT MATCH, CAN'T USE SHR IMG
	CMPL	IDMATCHCTL+4(R6),IHD$L_IDENT(R4) ;COMPARE MAJOR AND MINOR ID'S
	BGTRU	IDMISMATCH		;BR IF MINOR ID MISMATCH, CAN'T USE SHR
	BLBC	IDMATCHCTL(R6),70$	;BR IF EXACT MATCH NOT REQUIRED, USE SHR
	BNEQ	IDMISMATCH		;BR IF MINOR ID MISMATCH, CAN'T USE SHR
;
; ADD OTHER VALIDITY CHECKS HERE
;
70$:	CMPB	#<IHD$K_MINORID & ^XFF>,IHD$W_MINORID(R4) ;IS MINOR ID LESS
	BGTRU	75$			; (BR IF MINOR ID) IS UNDERSTOOD
	BLSSU	BADIMGHDR2		;THAN OR EQUAL TO THAT UNDERSTOOD
	CMPB	#<IHD$K_MINORID @ -8>,IHD$W_MINORID+1(R4) ;BY SYS$IMGACT?
	BLSSU	BADIMGHDR2		;BR IF MINOR ID IS NEWER, ERROR
;
; CHANNEL COUNT PARAMETER IS CURRENTLY IGNORED
;
;
;  See if image contains fixup vector, data area used by image activator
;  for activation time address fixups.
;
75$:	CMPW	IHD$W_ACTIVOFF(R4),#IHD$L_IAFVA ;TREAT AS NONE PRESENT
	BLEQU	77$			; IF OLD IMAGE HEADER FORMAT
	MOVL	IHD$L_IAFVA(R4),IAFVA(R6) ;SAVE FOR LATER USE IN FIXUP LOOP
	BRB	78$			;REJOIN COMMON CODE
77$:	CLRL	IAFVA(R6)		;OLD IMAGES DO NOT HAVE FIXUP VECTORS
78$:	MOVZWL	IMGIOCNT(R6),R1		;WAS IMAGE I/O PAGE COUNT INCLUDED IN LINK?
	BNEQ	80$			;BRANCH IF SPECIFIED
	MOVZWL	G^SGN$GW_IMGIOCNT,R1	;OTHERWISE USE SYSTEM DEFAULT
80$:	ROTL	#9,R1,R1		;FORM BYTE COUNT
	SUBL3	R1,CTLBASADR(R6),IOSEGADR(R6) ;REMEMBER STARTVA FOR IOSEGMENT
	MOVL	IOSEGADR(R6),CTLBASADR(R6) ;EXTEND THE "SHELL" AND SET NEW BASE
;
; IMAGE IS ACTIVATED FOR USER MODE
;
90$:	MOVL	S^#PSL$C_USER,ACMODE(R6) ;INIT ACMODE PARAMETER
	MOVAL	GSDNAMSIZ(R6),GSDNAM(R6) ;ADR OF GLOBAL SECTION NAME DESCRIPTOR
	MOVAL	IDMATCHCTL(R6),IDENT(R6) ;ADR OF GBL SECTION MATCH CONTROL
	SUBL3	CTLBASADR(R6),#^X80000000,CTLBASCNT(R6) ;NO OF BYTES IN SHELL
;
; IF THIS ACTIVATION IS INTO A SPECIFIC VIRTUAL ADDRESS RANGE, A BASE OFFSET
; MUST BE COMPUTED.  THIS BASE WILL BE ADDED TO THE VIRTUAL ADDRESSES COMPUTED
; FROM THE IMAGE SECTION DESCRIPTORS.  IF NO INPUT RANGE WAS SPECIFIED, THE
; BASE IS ZERO.  OTHERWISE, THE BASE IS COMPUTED BY SUBTRACTING THE STARTING
; VIRTUAL ADDRESS FROM THE FIRST IMAGE SECTION DESCRIPTOR FROM THE STARTING
; ADDRESS SPECIFIED IN THE INPUT RANGE.  THIS CODE DOES NOT UNDERSTAND THE
; CORRECT COMPUTATION IF THE ISD CONTAINS A P1 ADDRESS AND SO RETURNS AN ERROR.
; THIS BASE WORKS FOR MERGE IMAGE ACTIVATES AND SHAREABLE IMAGE ACTIVATES.
;
	ASSUME	IAC$V_SHAREABLE LE 7
	ASSUME	IAC$V_MERGE LE 7
	BITB	#<IAC$M_SHAREABLE ! IAC$M_MERGE>,IACFLG(R6) ;IF NOT RECURSIVE OR MERGE
	BEQL	NXTISDADR3		;THEN NO INPUT RANGE IS SPECIFIED
	MOVL	INMAPRANGE(R6),MAPBASE(R6) ;ASSUME EXPLICIT INPUT RANGE SPECIFIED
	BBC	#IAC$V_EXPREG,IACFLG(R6),100$ ;BR IF EXPLICIT RANGE SPECIFIED
	MOVL	@#CTL$GL_PHD,R0		;GET ADR OF PROCESS HEADER
	BBS	S^#VA$V_P1,INMAPRANGE(R6),NOP1VA_ERR ;P1 BLUEPRINT NOT IMPLEMENTED
	MOVL	PHD$L_FREP0VA(R0),MAPBASE(R6) ;USE FIRST AVAIL P0 SPACE AS BASE
100$:	MOVZWL	ISD$W_SIZE(R3),R0	;COMPUTE THE ADDRESS OF THE
	ADDL2	R0,R3			;FIRST ISD IN THE IMAGE HEADER
	ASHL	#9,ISD$L_VPNPFC(R3),R0	;GET FIRST VA TO BE MAPPED
	BBS	S^#VA$V_P1,R0,NOP1VA_ERR ;BR ON ERR, DON'T UNDERSTAND P1 HERE
	SUBL2	R0,MAPBASE(R6)		;COMPUTE BASE TO ADD TO VA MAPPED
	BRW	CHKISD			;GO CHECK AND MAP FIRST ISD


NXTISDADR3:
	BRW	NXTISDADR		;GET ADDRESS OF FIRST ISD
	.DSABL	LSB
	.PAGE
	.SUBTITLE	PROCESS EACH IMAGE SECTION DESCRIPTOR

;++
;
;  At this point, the image file has been opened and all processing based
;  on data in the fixed portion of the image file has been done. Now, each
;  image section descriptor in the image header is interpreted and action
;  is taken based on the ISD type. Basically, these actions are the following.
;
;  o	ISD for private section			$CRMPSC
;
;  o	ISD for demand zero section		$CRETVA
;
;	  - Demand zero sections in P0 space cause $CRETVA to be called
;	  - A type code of 253 (decimal) indicates the user stack. Its
;	    size is stored and the user stack creation is deferred until
;	    the completion code executes. The user stack is created with
;	    a call to $EXPREG.
;
;  o	ISD for global section			$IMGACT
;
;	  - All ISDs with the same name are grouped together and a single
;	    recursive activation call is made.
;	  - The recursive call determines whether the global section has been
;	    created. If so, a series of $MGBLSC calls are made, one for each
;	    private ISD in the shareable image. If not, a series of private
;	    sections are created. Note that global ISDs in a shareable image 
;	    are ignored.
;
;  Input parameters:
;
;	R3 = Address of the first image section descriptor
;	R5 = Address of FAB for image file
;	R6 = Address of image activator impure area
;
;--

;
; SET UP CONTEXT FOR MAPPING OR CREATING GLOBAL SECTIONS FOR SHARABLE KNOWN FILE
;
KFI_SHARED:
	TSTL	KFINAMSTR(R6)		;GLOBAL SECTION NAME INITIALIZED?
	BNEQ	20$			;BRANCH IF YES
	BSBW	KFI_GBLSECNMINI		;NO, INIT THE NAME STRING
	MOVL	#ISD$K_MATEQU,KFIMATCHCTL(R6) ;ASSUME MATCH EQUAL, NOT SHR IMG
	MOVL	FAB$L_CTX(R5),KFIMATCHCTL+4(R6) ;IDENT = KFIADR ! SEQUENCE NO.
	BBC	#IAC$V_LIM,IACFLG(R6),20$ ;BRANCH IF NOT SHAREABLE IMAGE
	CLRL	KFIMATCHCTL+4(R6)	;ASSUME MATCH ALWAYS FOR SHAREABLE IMAGE
	EXTZV	#IHD$V_MATCHCTL,#IHD$S_MATCHCTL,- ;GET MATCH CONTROL
		LNKFLAGS(R6),KFIMATCHCTL(R6) ;FROM LINK FLAGS
	BEQL	20$			;BRANCH IF MATCH ALWAYS
;
; IDENT LONG WORD MAY BE INFERRED AS PRESENT IF THE LNKFLAGS CONTAIN
; AN NON-ZERO MATCHCTL FIELD.
;
	MOVL	IHD$L_IDENT(R4),KFIMATCHCTL+4(R6) ;GET VALUE TO COMPARE
20$:	BSBW	KFI_GBLSECNMNXT		;FORM NEXT GLOBAL SECTION NAME
	BSBW	KFI_SHMIDENTINI		;INITIALIZE IDENT FOR SHARED MEM IMAGES
	BLBC	R0,IMGACT_RET2		;BR ON LOG NAM TRANS ERROR
	INCW	GBLSECCNT(R6)		;UPDATE THE SECTION NUMBER
	BISW	#SEC$M_GBL,FLAGS(R6)	;FORCE GLOBAL SECTION
	MOVQ	KFIMATCHCTL(R6),IDMATCHCTL(R6) ;SET GBL SEC MATCH CONTROL
	BBC	#KFI$V_IS_SHARED,KFIFLG(R6),30$ ;IF ALREADY SHARED, THEN
	BRW	KFI_GLOBAL_SEC		;JUST MAP THE SECTION


30$:	BRW	PROCESS_SEC		;OTHERWISE CREATE THE SECTION NOW


NOP1VA_ERR:
	MOVZWL	#SS$_NOP1VA,R0		;REPORT ERROR CODE
IMGACT_RET2:
	BRW	IMGACT_ERREXIT


;
; PROCESS THE NEXT IMAGE SECTION DESCRIPTOR
; R3 = ISD ADDRESS
;
NXTISD:
	ASSUME	ISD$V_GBL EQ 0
	BBC	#IAC$V_SHAREABLE,IACFLG(R6),3$ ;BR IF NOT A RECUR CALL
	BBS	#ISD$V_COPYALWAY,ISD$L_FLAGS(R3),NXTISDADR3 ;BR IF COPYALWAY
	BLBS	ISD$L_FLAGS(R3),NXTISDADR3	;IGNORE GBL ISD ON RECUR
3$:	MOVZWL	ISD$W_PAGCNT(R3),R2	;NUMBER OF PAGES IN THIS SECTION
	ROTL	#9,R2,R1		;CONVERT TO NUMBER OF BYTES
	ASHL	#9,ISD$L_VPNPFC(R3),R0	;STARTING VIRTUAL ADDRESS OF SECTION
	BBC	S^#VA$V_P1,R0,10$	;IF P1 SPACE ADDRESS
	CMPB	#ISD$K_USRSTACK,ISD$B_TYPE(R3) ;IS THIS THE USER STACK?
	BNEQ	4$			;BR IF IT IS NOT THE USER STACK
	MOVZWL	ISD$W_PAGCNT(R3),USRSTACKCNT(R6) ;REMEMBER STACK SIZE FOR LATER
	BRB	NXTISDADR3		;DON'T CREATE STACK SPACE TILL LATER

4$:	BITL	#<IAC$M_SHAREABLE ! IAC$M_MERGE>,IACFLG(R6) ;P1 SECTIONS NOT
	BNEQ	NOP1VA_ERR		;ALLOWED IN SHAREABLE/MERGE CALLS
	SUBL	CTLBASCNT(R6),R0	;BIAS STARTING VA BY SIZE OF "SHELL"
10$:	MOVAB	-(R1)[R0],R1		;ENDVA = STARTVA+COUNT-1
	ADDL3	MAPBASE(R6),R0,STARTVA(R6) ;GET STARTING VA TO BE MAPPED
	ADDL3	MAPBASE(R6),R1,ENDVA(R6) ;GET ENDING VA TO BE MAPPED
	CMPL	ENDVA(R6),INMAPRANGE+4(R6) ;EXCEEDED INPUT MAP RANGE?
	BLEQU	15$			;BR IF WITHIN ALLOWED RANGE
	MOVZWL	#SS$_SHARTOOBIG,R0	;REPORT ERROR
	BRB	IMGACT_RET2		;EXIT WITH ERROR STATUS CODE

15$:	MOVZWL	ISD$L_FLAGS(R3),R0	;SECTION FLAGS
	BICB3	#^C<ISD$M_GBL ! ISD$M_CRF ! - ;GET GLOBAL, COPY ON REFERENCE
		ISD$M_DZRO ! ISD$M_WRT>, - ;DEMAND ZERO AND WRITABLE BITS
		R0,FLAGS(R6)		;FROM SECTION FLAGS

	ASSUME	SEC$V_SYSGBL GT SEC$V_PERM
	ASSUME	SEC$V_PERM GE 8
	ASSUME	SEC$V_SYSGBL LE 15
					;THE NEXT INSTRUCTION CLEARS
					; BYTE 2 IN FLAGS PARAMETER
20$:	MOVZBW	#<SEC$M_SYSGBL ! -	;IF THE SECTIONS ARE GLOBAL
		SEC$M_PERM>@-8,FLAGS+1(R6) ;THEN THEY ARE SYSTEM WIDE, PERMANENT
	TSTL	R7			;IS THERE A KNOWN FILE ENTRY
	BGEQ	30$			;BRANCH IF NONE
	BBC	#KFI$V_PROTECT,KFI$W_FLAGS(R7),30$	;BRANCH UNLESS PROTECTED
	BBC	#ISD$V_WRT,ISD$L_FLAGS(R3),40$	;SET READ-ONLY PAGES TO EXEC OWNED
30$:	BBC	#ISD$V_PROTECT,ISD$L_FLAGS(R3),NXTISD_CONT ;SKIP WRT PROT IF CLR
40$:	BISL	#<SEC$M_PROTECT ! <PSL$C_EXEC @ SEC$V_WRTMOD>>,FLAGS(R6)
					;SET EXEC OWNED, UREW SECTION PAGES
NXTISD_CONT:
	ASSUME	SEC$V_GBL EQ 0
	BLBC	R0,4$			;STAY IN LINE IF NOT GLOBAL SECTION
2$:	BRW	RECUR_PATH		;BR IF GLOBAL SECTION TO RECURSIVE PATH


4$:	BBC	#IAC$V_SHAREABLE,IACFLG(R6),8$ ;BR IF NOT RECUR CALL
	BRW	GLOBAL_SEC		;BR IF THIS IS RECUR CALL


8$:	BBC	#ISD$V_COPYALWAY,R0,12$	;IGNORE GBLCLUSTR IF COPYALWAY SET
	BBC	#IAC$V_LIM,IACFLG(R6),13$ ;IGNORE LINKABLE IMG COPYALWAY
	BRW	NXTISDADR1		;IGNORE GBLCLUSTR IF COPYALWAYS


12$:	BBS	#IAC$V_GBLCLUSTR,IACFLG(R6),2$ ;BR IF NO MORE IN GBL CLUSTR
13$:	BBC	#SEC$V_DZRO,R0,15$	;BRANCH IF NOT DEMAND ZERO
	BRW	DZRO_SEC		;DEMAND ZERO ISD


;
; CRF SECTIONS ARE GLOBAL FOR LINKABLE IMAGES, BUT NOT FOR NORMAL SHARED IMAGES
;
15$:	BBC	#SEC$V_CRF,R0,20$	;BRANCH IF NOT COPY ON REFERENCE
	BBC	#IAC$V_LIM,IACFLG(R6),PROCESS_SEC ;BRANCH IF NOT LINKABLE IMAGE
20$:	BBC	#KFI$V_KP_SHARED,KFIFLG(R6),PROCESS_SEC ;BRANCH IF SHARED
	BRW	KFI_SHARED


;
; PROCESS IMAGE SECTION DESCRIPTOR
;
PROCESS_SEC:
	MOVL	R2,PAGCNT(R6)		;AND SIZE OF SECTION IN PAGES
	MOVL	ISD$L_VBN(R3),VBN(R6)	;FILE VIRTUAL BLOCK NUMBER
	BBC	#IAC$V_SEQDEVLOD,IACFLG(R6),5$ ;BR IF NOT "LOADING" IMAGE
	BSBW	LOAD_SECTION		;LOAD RATHER THAN MAP THE SECTION
	BRB	25$

5$:	BBS	#IAC$V_XLINKER,IACFLG(R6),10$ ;IGNORE PFC IF CROSS LINKER
	MOVZBL	ISD$B_PFC(R3),PFC(R6)	;PAGE FAULT CLUSTER
10$:	MOVL	#CRMPSC$_NARGS,ARGCNT(R6) ;SET THE ARGUMENT COUNT
20$:	$CRMPSC_G (R6)			;AND CREATE AND MAP THE PROCESS SECTION
25$:	BLBC	R0,27$			;BR IF ERROR CREATING SECTION
	BRW	RET_MAPRANGE		;GO SET RETURN RANGE MAPPED


27$:	BBSC	#SEC$V_GBL,FLAGS(R6),30$ ;BRANCH IF TRYING TO CREATE GLOBAL

	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),NXTISDADR1	;BRANCH IF NOT ACTIVATING, IGNORE ERROR
	BRW	IMGACT_ERREXIT		;OTHERWISE RETURN ERROR CONDITION


;
; FAILED TO CREATE A GLOBAL SECTION, IF REALLY ACTIVATING AN IMAGE, TRY
; TO CREATE AND MAP A PROCESS SECTION INSTEAD.
;
	ASSUME	IAC$V_NOTSHARED GE 16
	ASSUME	IAC$V_NOTSHARED LT 24
30$:	BISB	#IAC$M_NOTSHARED@-16,IACFLG+2(R6) ;DON'T SET IS_SHARED

	ASSUME	IAC$V_NOACT EQ 0
	BLBC	IACFLG(R6),20$		;UNLESS NOT ACTUALLY ACTIVATING,
	BLBC	RETSTATUS(R6),NXTISDADR1 ;IF ALREADY ERROR CODE, FORGET NEW ONE
	MOVL	R0,RETSTATUS(R6)	;REMEMBER RETURN ERROR STATUS CODE
					;TRY CREATING PROCESS SECTION
NXTISDADR1:
	BRW	NXTISDADR


;
; GLOBAL SECTION DESCRIPTOR SCANNING FOR RECURSIVE IMAGE ACTIVATE
;
RECUR_PATH:
	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),NXTISDADR1	;FORGET GBL SECTIONS IF NOT ACTIVATING
	ASSUME	SEC$V_GBL EQ 0
	BLBC	R0,10$			;SKIP NEXT STEPS IF LOCAL ISD
	TSTL	IAFVA(R6)		;NONZERO CONTENTS INDICATES VERSION 3
	BEQL	10$			; FORMAT. BRANCH IF OLD FORMAT. ALSO 
	BBS	#ISD$V_BASED,ISD$L_FLAGS(R3),10$ ; SKIP IF BASED SHAREABLE IMAGE
	ADDL3	#1,RETENDVA_CUM(R6),STARTVA(R6) ;GET LAST ADDRESS MAPPED AS FIRST ADDRESS
	ASSUME	ENDVA EQ <STARTVA + 4>
	MOVL	#^X7FFFFFFF,ENDVA(R6)	;SET VERY LARGE ENDING VA
10$:	BBSS	#IAC$V_GBLCLUSTR,IACFLG(R6),GET_NXT_PIECE ;BR IF NOT 1ST GBL ISD
	BBC	#ISD$V_WRT,FLAGS(R6),15$	;BR IF SECTION IS READ-ONLY
	BBS	#ISD$V_CRF,FLAGS(R6),15$	;BR IF SECTION WRT AND CRF
	BISB	#IAC$M_WRITABLE,RECUR_IMGCTL(R6) ;REQUEST WRITABLE IMG ACTIVATE
15$:	MOVQ	STARTVA(R6),RECUR_INADR(R6)	;GET ADR RANGE TO BE MAPPED
	BBC	#ISD$V_LASTCLU,ISD$L_FLAGS(R3),20$ ;BR IF NOT LAST CLUSTER ISD
	MOVL	#^X7FFFFFFF,RECUR_INADR+4(R6)	;SET VERY LARGE ENDING VA
20$:	EXTZV	#ISD$V_MATCHCTL,#ISD$S_MATCHCTL, -
		ISD$L_FLAGS(R3),RECUR_IDENT(R6) ;GET MATCH CONTROL FLAGS
	BEQL	30$				;BR IF NO MATCH CONTROL
	MOVL	ISD$L_IDENT(R3),RECUR_IDENT+4(R6) ;GET IDENT TO MATCH
30$:	MOVZBL	ISD$T_GBLNAM(R3),RECUR_NAMDSC(R6)	;GET SIZ OF GBL SEC NAME
	MOVQ	ISD$T_GBLNAM(R3),RECUR_FILNAM(R6) ;SAVE IMAGE SECTION NAME
	MOVQ	ISD$T_GBLNAM+8(R3),RECUR_FILNAM+8(R6) ;FOR RECURSIVE CALL
	BBCC	#IAC$V_NOCOPY,IACFLG(R6),40$ ;ASSUME ALL PRIVATE COPIES EXIST
40$:	ADDL3	RECUR_NAMDSC(R6),RECUR_NAMDSC+4(R6),R0 ;FIND END OF NAME
	CMPL	#^A/_001/,-(R0)		;SUFFIX MUST BE _001
	BEQL	MAP_PRIVATECOPY		;1ST NAME IN CLUSTER, CHK PRIVATE COPY
	MOVZWL	#SS$_RELINK,R0		;OBSOLETE FIELD TEST IMAGE W/ COPYALWAYS
	BRW	IMGACT_ERREXIT		;SECTION NOT INDICATED IN GBL CLUSTER


;
; CONSECUTIVE GLOBAL IMAGE SECTION DESCRIPTOR
;
GET_NXT_PIECE:
	CMPB	ISD$T_GBLNAM(R3),RECUR_NAMDSC(R6) ;NAM SIZ SAME AS CURR CLUSTER?
	BEQL	10$			;BR IF SAME NAME, ANOTHER SEC IN CLUSTER
	BRW	RECUR_CALL_NOW		;BR IF DIFFERENT, MUST BE NEW CLUSTER


10$:	PUSHR	#^M<R0,R1,R2,R3>	;SAVE REGISTERS
	SUBL3	#4,RECUR_NAMDSC(R6),R1	;STRIP OFF SUFFIX _00N
	CMPC3	R1,@RECUR_NAMDSC+4(R6),<ISD$T_GBLNAM+1>(R3) ;SAME NAME?
	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS
	BNEQ	RECUR_CALL_NOW		;BR IF DIFFERENT, MUST BE NEW CLUSTER
	CMPL	STARTVA(R6),RECUR_INADR(R6) ;DOES THIS PIECE FOLLOW PREVIOUS?
	BLEQU	BAD_ISD		;BR ON NO, ERROR IF NOT PREV OR OVERLAP
	CMPL	#^X7FFFFFFF,RECUR_INADR+4(R6) ;IGNORE ENDVA ON LAST CLUSTER
	BEQL	20$			;BRANCH TO IGNORE ENDVA TEST
	CMPL	STARTVA(R6),RECUR_INADR+4(R6) ;DOES PIECE OVERLAP PREVIOUS?
	BLEQU	BAD_ISD		;BR ON YES, ERROR IF OVERLAP OF PIECES
	MOVL	STARTVA+4(R6),RECUR_INADR+4(R6) ;SET END VA TO BE MAPPED
20$:
;
; CHECK FOR A PRIVATE COPY OF THIS SHAREABLE IMAGE SECTION IN THE EXECUTABLE
; IMAGE.  IF ONE EXISTS, MAP IT (EVEN THOUGH A RECURSIVE CALL WILL BE DONE TO
; MAP THE SECTION).  THUS IF THE SHAREABLE IMAGE IS FOUND, IT WILL OVERMAP
; THE PRIVATE COPIES MAPPED FROM THE EXECUTABLE IMAGE.  IF THE SHAREABLE IMAGE
; IS NOT FOUND AND THERE WERE PRIVATE COPIES FOR EACH SECTION IN THE SHAREABLE
; IMAGE, CONTINUE THE ACTIVATION.  TO FORCE USE OF PRIVATE COPIES IN EXECUTABLE
; IMAGES, A USER MAY DEFINE A LOGICAL NAME FOR THE SHAREABLE IMAGE "FILENAME"
; TO REASSIGN IT SO THAT THE FILE IS NOT FOUND.  WRITABLE SECTIONS, HOWEVER,
; REQUIRE THE SHAREABLE IMAGE TO BE INSTALLED.
;
MAP_PRIVATECOPY:
	TSTL	ISD$L_VBN(R3)		;IS THERE A PRIVATE COPY IN EXEC IMG?
	BNEQ	20$			;BR ON COPY FOUND, GO MAP IT
10$:	BBSS	#IAC$V_NOCOPY,IACFLG(R6),15$ ;SET INDICATOR FOR NO PRIVATE COPY
15$:	BRW	NXTISDADR1		;CONTINUE, ASSUMING RECUR CALL WILL WORK


20$:	BICW	#SEC$M_GBL,FLAGS(R6)	;FORCE PROCESS SECTION CREATION
	BBC	#SEC$V_WRT,FLAGS(R6),30$ ;BR IF SECTION NOT WRITABLE
	BBS	#SEC$V_CRF,FLAGS(R6),30$ ;BR IF SECTION IS COPY-ON-REFERENCE
	BRB	10$			;WRITABLE SECTIONS MUST BE INSTALLED

30$:	MOVZWL	ISD$W_PAGCNT(R3),R2	;GET COUNT OF PAGES IN SECTION
	BBS	#ISD$V_DZRO,FLAGS(R6),40$ ;BR IF SECTION IS DEMAND-ZERO
	BRW	PROCESS_SEC		;GO MAP PRIVATE COPY OF SECTION


40$:	BRW	DZRO_SEC		;GO CREATE DEMAND-ZERO SECTION PAGES


BAD_ISD:
	MOVZWL	#SS$_BADISD,R0		;SET ERROR CODE, ISD IS BAD
	BRW	IMGACT_ERREXIT		;RETURN ERROR CODE TO CALLER


;
; DEFAULT NAME STRING FOR RECURSIVE CALL (I.E., SHAREABLE IMAGES)
;
RECUR_DNAM:
	.ASCII	/SYS$SHARE:.EXE/
RECUR_DSIZ=.-RECUR_DNAM

RECUR_CALL_NOW:
	.ENABL	LSB
	ASSUME	IAC$V_GBLCLUSTR GE 16
	ASSUME	IAC$V_GBLCLUSTR LT 24
	BICB	#IAC$M_GBLCLUSTR@-16,IACFLG+2(R6) ;INDIC NO LONGER GBL ISD CLUSTR
	MOVAB	RECUR_INADR(R6),RECUR_INADR2(R6) ;SET ADR OF INPUT VA RANGE QUAD
	MOVAB	RECUR_RETADR(R6),RECUR_RETADR2(R6) ;SET ADR OF RET VA RANGE QUAD
	MOVAB	RECUR_IDENT(R6),RECUR_IDENT2(R6) ;SET ADR OF MATCH CTL QUADWORD
	MOVAB	RECUR_DFLTDSC(R6),RECUR_DFLTNAME(R6) ;SET ADR OF DEFAULT NAM DSC
					;THIS CODE TAKES ADVANTAGE OF THE AME
					;DEFAULT NAME STRING BEING THE SAME
					;AS THE DEFAULT NAME STRING NEEDED HERE.
	MOVAB	RECUR_DNAM,RECUR_DFLTDSC+4(R6) ;SET NAME STR ADR INTO STR DSC
	MOVZBL	#RECUR_DSIZ,RECUR_DFLTDSC(R6) ;SET SIZE OF NAME STRING
	MOVZBL	#8,RECUR_ARGCNT(R6)	;SET # OF ARGS IN IMGACT CALL
	MOVAB	RECUR_NAMDSC(R6),RECUR_NAME(R6) ;SET ADR OF FILE NAME STRING DSC
	SUBL2	#4,RECUR_NAMDSC(R6)	;STRIP OFF SUFFIX _00N
	MOVL	IMGHDRBUF(R6),R0	;REMEMBER IMG HDR BUF ADR FOR SETCTLREG
	MOVAB	FAB(R6),8(R0)		;GET ADR OF FAB IN USUAL SCRATCH BUFFER
	ADDL2	#<512*4>,8(R0)		;POINT TO FAB IN ALTERNATE SCRATCH PAGES
	CMPL	#ISD$K_MATNEV,RECUR_IDENT(R6) ;CHECK IF MATCH NEVER
	BNEQ	2$			;NO. CONTINUE
	BRW	MATCH_NEVER		;YES. DON'T MAP ANY OF SHR IMG

;  The logic in this section breaks down into five cases. They are handled
;  according to the following rules.
;
;	A SHL exists but has no base address associated with it yet.
;	This means that the shareable image has not yet been mapped.
;
;	  1.	In the usual case, the $IMGACT_G call is made with the EXPREG
;		flag set, indicating that the shareable image will be mapped
;		into the first available address range.
;
;	  2.	If the shareable image is based at a particular virtual address
;		(ISD$V_BASED) in ISD$L_FLAGS is set, then that address range is
;		passed along in the recursive call.
;
;	A SHL exists and the SHL entry contains a nonzero base address.
;
;	  3.	In this case, the recursive call is skipped altogether.
;
;	There is no SHL entry for the shareable image in the shareable image
;	list associated with the executable image. 
;
;	  4.	The executable image does not have a fixup vector associated
;		with it. In this case, an empty fixup vector is created and 
;		filled in as part of activation.

2$:	CLRL	R1			; Initialize SHL address to zero
	BBS	#IAC$V_P1MERG_P0,IACFLG(R6),5$ ; Skip next if first half of P1 merge
	MOVAQ	RECUR_NAMDSC(R6),R0	; Get descriptor for shareable image
	BSBW	IAC$SRCH_SHL_D		; See if SHL entry exists.
	BLBS	R0,5$			; Continue if SHL found
	CMPW	R0,#SS$_DIRFULL		; Do we need to create new fixup vector?
	BNEQ	RECUR_ERROR		; No. Report some other error.
	BSBW	CREATE_IAF		; Create empty fixup vector
	BLBC	R0,RECUR_ERROR		; Quit if this call fails
	BRB	2$			;  and force a successful SHL search

5$:	MOVL	R1,RECUR_SHLENTRY(R6)	; Save its address 
	BEQL	7$			; Skip next test if none
	IFNORD	#4,SHL$L_BASEVA(R1),15$	; Can base address cell be read?
	TSTL	SHL$L_BASEVA(R1)	; Is it mapped yet?
	BNEQ	10$			; Skip entire recursive call if so
	MOVAB	SHL$K_LENGTH-2(R1),RECUR_HDRBUF(R6) ; Save channel here
7$:	$IMGACT_G RECUR_ARGCNT(R6)	; Recursive call for shar img
	BLBC	R0,RECUR_ERROR		;BR IF ERR ACTIVATING SHAREABLE IMAGE
	MOVL	RECUR_RETADR(R6),R0	; Get starting VA of mapped range
	MOVL	RECUR_SHLENTRY(R6),R1	; Is there a SHL entry to load?
	BEQL	8$			; Branch if none
	IFNOWRT	#4,SHL$L_BASEVA(R1),15$	; Can base address cell be written?
	MOVL	R0,SHL$L_BASEVA(R1)	; Update SHL entry in executable image
8$:	MOVL	RECUR_RETADR+4(R6),R1	; Get ending VA of mapped range, too
	BSBW	UPDATE_RETADR		;UPDATE CALLER'S RANGE QUADWORD
10$:	BICL	#^C<IAC$M_SHAREABLE>,RECUR_IMGCTL(R6) ;INIT FLAGS FOR NEXT CALL
	CLRQ	RECUR_IDENT(R6)		;INITIALIZE MATCH CONTROL FOR NXT CALL
	TSTW	(R3)			;ANY MORE ISD'S?
	BEQL	END_OF_ISDS1		;BR IF NO MORE ISD'S
	MOVL	ISD$L_FLAGS(R3),R0	;RESTORE CONTENTS OF R0
	BRW	NXTISD_CONT		;CONTINUE WITH CURRENT ISD


15$:	MOVZWL	#SS$_ACCVIO,R0		;FIXUP VECTOR IS INACCESSIBLE
	BRB	25$			;ABORT ACTIVATION WITH ERROR

NXTISDADR2:
	BRW	NXTISDADR		;CONTINUE WITH NEXT SECTION


END_OF_ISDS1:
	BRW	END_OF_ISDS		;ALL DONE MAPPING IN LAST CLUSTER


MATCH_NEVER:
	MOVL	#RMS$_FNF,R0		;FORCE EXECUTABLE IMAGE COPY TO BE USED
RECUR_ERROR:
	CMPL	#RMS$_FNF,R0		;IS ERROR CODE "FILE NOT FOUND"?
	BNEQ	20$			;BR IF NOT THAT ERROR
	BBC	#IAC$V_NOCOPY,IACFLG(R6),10$ ;BR IF PRIVATE COPIES ALL MAPPED
20$:	ADDL2	#8,SP			;CLEAN OFF STACK
25$:	BRW	IMGACT_ERREXIT		;RETURN TO CALLER WITH ERROR CODE


	.DSABL	LSB
;
; GLOBAL IMAGE SECTION DESCRIPTOR
;
GLOBAL_SEC:
;
; MAKE SURE THAT THERE CAN BE NO CREATION OR DELETION OF GLOBAL SECTIONS
; FOR THE KNOWN FILES AT THIS POINT.  OTHERWISE IT WOULD BE POSSIBLE TO
; MAP A SECTION FROM ONE KNOWN FILE AND THE SUPPOSEDLY RELATED SECTION(S)
; FROM ANOTHER.
;
	BBS	#ISD$V_COPYALWAY,R0,NXTISDADR2 ;SKIP COPYALWAY ON RECUR CALL
	BBS	S^#RND$V_IACLOCK,@#CTL$GL_RUNDNFLG,30$ ;BRANCH IF ALREADY LOCKED
	MOVAB	SET_ACTIVE_LCK,KRNLROUT(R6) ;CALL THE LOCK ROUTINE
	BSBW	CMKRNL			;IN KERNEL MODE
;
; THE FORMAT OF THE GLOBAL SECTION NAME IS UP TO 11 CHARACTERS OF NAME
; FOLLOWED BY "_001" FOR THE FIRST GLOBAL ISD FROM THAT LINKABLE IMAGE.
; ALL GLOBAL ISD'S FOR A GIVEN LINKABLE IMAGE ARE IN NUMERIC ORDER AND
; DENSE IN THAT NO OTHER GLOBAL ISD'S CAN INTERVENE.
;
30$:	TSTL	R7			;WAS THE FILE INSTALLED? (HAS GBL SEC)
	BNEQ	35$			;CONTINUE IF FILE WAS ALREADY INSTALLED
	BRW	NOT_INSTALLED		;BRANCH IF FILE WAS NOT INSTALLED


35$:	TSTL	KFINAMSTR(R6)		;IS THE GLOBAL SECTION NAME INITIALIZED?
	BNEQ	40$			;BR IF IT IS INITIALIZED
	BSBW	KFI_GBLSECNMINI		;SET THE GLOBAL SECTION NAME
40$:	BSBW	KFI_GBLSECNMNXT		;INCREMENT THE _00N SUFFIX

KFI_GLOBAL_SEC:
	MOVL	#MGBLSC$_NARGS,ARGCNT(R6) ;SET ARGUMENT COUNT
	$MGBLSC_G (R6)			;AND MAP THE GLOBAL SECTION
	BLBS	R0,RET_MAPRANGE		;CONTINUE IN LINE IF SUCCESSFUL
	BRW	GBL_SEC_MAPERR		;BRANCH IN NOT SUCCESSFUL

RET_MAPRANGE:
	ASSUME	IAC$V_NOACT EQ 0
	BLBC	IACFLG(R6),10$		;CONTINUE IN LINE IF REALLY ACTIVATING
	BRW	NXTISDADR		;DON'T RESET VECTORS ON NOACT CALL


10$:	BBC	#ISD$V_VECTOR,ISD$L_FLAGS(R3),15$ ;NO VECTORS TO SET IF VECTOR CLR
	BBC	#ISD$V_PROTECT,ISD$L_FLAGS(R3),13$ ;ERROR IF PROTECT NOT SET, TOO
	BBS	#IAC$V_P1MERG_P0,IACFLG(R6),15$ ;SKIP IF P0 PART OF P1 MERGE
	MOVL	R0,CRM_RET_CODE(R6)	;REMEMBER STATUS CODE FROM MAPPING SEC
	MOVAL	W^SET_VECTORS,KRNLROUT(R6) ;GO ADD NEW MSG/CHANGE MODE VECTORS
	BSBW	CMKRNL			;(KERNEL MODE TO WRITE CTL$GL_RMSBASE)
	BLBS	R0,15$			;KEEP GOING IF SUCCESSFUL
12$:	BRW	IMGACT_ERREXIT		;OTHERWISE, REPORT ERROR


13$:	MOVZWL	#SS$_BADISD,R0		;VECTOR ISD IS NOT ALSO PROTECTED
	BRB	12$

14$:	MOVZWL	#SS$_BADIMGHDR,R0	;INCONSISTENT IMAHE HEADER CONTENTS
	BRB	12$

;  Check if section just mapped is a fixup vector. If so, take appropriate
;  action depending on whether the activation in progress is a normal
;  activation of an executable image or it is a recursive call.
;  The three cases are:
;
;  1.	If activating an executable image, add it to the end of the
;	master fixup vector list. In addition, add the fixup vector to
;	the front of the list of fixups to be done.
;
;  2.	If activating a nonprivileged shareable image, add it to the
;	front of the list of fixups to be done.
;
;  3.	If activating a privileged shareable image, insure that there
;	are no outbound calls. Do the internal .ADDRESS fixups at this
;	point. The fixup vector is not added to any list.
;
;  In all three cases, the name of the image being activated is stored
;  in the master fixup vector list. 

15$:	ASHL	#9,ISD$L_VPNPFC(R3),R1	;GET RELATIVE ADDRESS OF SECTION
	BEQL	23$			;FIXUP VECTOR IS NEVER AT RELATIVE 0
	BBS	#ISD$V_FIXUPVEC,ISD$L_FLAGS(R3),20$	;SECTION A FIXUP VECTOR?
 					;ANOTHER TEST IS MATCH BETWEEN VA IN ISD
					; AND IAFVA FIELD IN IMAGE HEADER
	CMPL	R1,IAFVA(R6)		;CHECK IF TWO RELATIVE ADDRESSES AGREE
	BNEQ	23$			;SKIP IF NO MATCH

;  There is an assumption at work here about the address used by the linker
;  for the fixup vector. The linker never uses relative address 0 for the
;  fixup vector so the previous tests include the case where no fixup
;  vector is present.

20$:	CMPL	R1,IAFVA(R6)		;PERFORM CONSISTENCY CHECK ON HEADER
	BNEQ	14$			;ERROR IF NO MATCH
	BBS	#IAC$V_P1MERG_P0,IACFLG(R6),23$ ;ALSO SKIP IF P0 PART OF P1 MERGE
	MOVL	RETSTARTVA(R6),R0	;ACTUAL BASE ADDRESS MAPPED TO R0
	BBS	#ISD$V_PROTECT,ISD$L_FLAGS(R3),25$ ;PRIVILEGED SHAREABLE IAMGE?
	MOVL	@#CTL$GL_FIXUPLNK,IAF$L_FIXUPLNK(R0) ;ADD THIS IAF TO FRONT OF
	MOVL	R0,@#CTL$GL_FIXUPLNK	; SHAREABLE IMAGE LIST

;  A fixup vector for the executable image has its address stored at the end of
;  the main fixup vector list in P1 space. The shareable image name is stored
;  at index zero of the fixup vector for a shareable image.

	BBS	#IAC$V_SHAREABLE,IACFLG(R6),30$ ;TAKE BRANCH IF IN RECURSIVE CALL

;  This is fixup vector for executable image or merged shareable image.
;  Store its address at the end of the fixup vector list that is
;  specific to this activation.

	MOVL	@#CTL$GL_IAFLAST,R1	; Get address of current last element
	MOVL	R0,IAF$L_IAFLINK(R1)	; Make it point to new IAF
	MOVL	R0,@#CTL$GL_IAFLAST	; Make new IAF the last IAF
	CLRL	IAF$L_IAFLINK(R0)	;  and zap its link field
	MOVL	R0,IAFEXE(R6)		; Remember this IAF for later in
					;  the activation
	BRB	30$			; Go to code that stores name

23$:	BRB	40$			; Branch aid to skip over code

25$:	MOVL	RETSTARTVA_CUM(R6),R1	; Store base address in R1
	BSBW	IAC$PRVSHRIMG		; Do fixups in exec mode for
					;  privileged shareable image
	BLBC	R0,12$			; Report error if unsuccessful
	MOVL	RETSTARTVA(R6),R0	; Otherwise, restore R0 and continue

;  Store the name of the image currently being activated (executable or 
;  shareable) to the SHL entry at index 0. In the case of an executable
;  image, the name returned from the $OPEN call is stored. In the case
;  of a shareable image, the input name to the recursive call is stored.

30$:	ADDL2	IAF$L_SHLSTOFF(R0),R0	;NOW R0 POINTS TO THE SHL ENTRY FOR
					; THE IMAGE THAT IS BEING ACTIVATED
	BSBB	45$			;IS SHL WITHIN BOUNDS?
	PUSHR	#^M<R2,R3,R4,R5>	;PRESERVE REGISTERS ACROSS MOVC5
	CLRW	SHL$K_LENGTH-2(R0)	;SAVE CHANNEL
	BBS	#IAC$V_SEQDEVLOD,IACFLG(R6),35$	;A SEQUENTIAL DEVICE
	MOVW	CHAN(R6),SHL$K_LENGTH-2(R0) ;SAVE CHANNEL
35$:	BBS	#IAC$V_SHAREABLE,IACFLG(R6),37$	;BRANCH IF RECURSIVE CALL
	MOVAB	NAM(R6),R2		;POINT R2 AT THE NAM BLOCK
	MOVZBL	NAM$B_NAME(R2),R1	;MAKE SIZE OPERAND A WORD
	MOVB	R1,SHL$T_IMGNAM(R0)	;STORE CHARACTER COUNT 
	MOVC5	R1,@NAM$L_NAME(R2),#0,#SHL$C_MAXNAMLNG-2,SHL$T_IMGNAM+1(R0) 
					;COPY STRING THAT WAS RETURNED FROM RMS
	BRB	39$			;JOIN COMMON CODE

37$:	MOVZBL	FAB$B_FNS(R5),R1	;MAKE SIZE OPERAND A WORD
	MOVB	R1,SHL$T_IMGNAM(R0)	;STORE CHARACTER COUNT 
	MOVC5	R1,@FAB$L_FNA(R5),#0,#SHL$C_MAXNAMLNG-2,SHL$T_IMGNAM+1(R0) 
					;COPY STRING THAT WAS PASSED TO RMS
39$:	POPR	#^M<R2,R3,R4,R5>	;RESTORE MOVC5 REGISTERS 
40$:	MOVQ	RETSTARTVA(R6),R0	;GET ADDRESS RANGE JUST MAPPED
	BSBW	UPDATE_RETADR		;UPDATE RETURN RANGE QUADWORD
	BRB	NXTISDADR		;CONTINUE WITH NEXT SECTION

; VALIDATE CONTENTS OF FIXUP VECTOR (R0 POINTS TO SHL 0)

45$:	CMPL	R0,RETSTARTVA(R6)	;SHL ABOVE LOWER LIMIT?
	BLSSU	50$			;ERROR IF NOT
	MOVAB	SHL$K_LENGTH(R0),R1	;GET UPPER END OF SHL 0
	CMPL	R1,RETSTARTVA+4(R6)	;SHL BELOW UPPER LIMIT?
	BGTRU	50$			;ERROR IF NOT
	RSB

50$:	MOVZWL	#SS$_BADIMGHDR,R0	;REPORT AS "BAD IMAGE HEADER"
	BRB	IMGACT_RET4		;ABORT ACTIVATION

NOT_INSTALLED:				;NOTE:  LOCAL COPIES OF NON-CRF WRITABLE
					;SECTIONS ARE NEVER!!! ALLOWED.  THUS
					;ALL WRITABLE SHAREABLE IMAGES MUST BE
					;INSTALLED.
	MOVZWL	#SS$_NOTINSTALL,R0	;SET RETURN ERROR CODE
GBL_SEC_MAPERR:
	BBC	#SEC$V_WRT,FLAGS(R6),10$ ;BR IF OK TO MAP AS PROCESS SECTION
	BBC	#SEC$V_CRF,FLAGS(R6),IMGACT_RET4 ;DON'T MAP PROCESS SECTION
10$:	BICW	#SEC$M_GBL,FLAGS(R6)	;MAPPING PROCESS SECTION NOT GLOBAL
	MOVZWL	ISD$W_PAGCNT(R3),R2	;GET SECTION PAGE COUNT
	BRW	PROCESS_SEC


;
; DEMAND ZERO PRIVATE SECTION, R1 = ENDVA
;
DZRO_SEC:
	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),NXTISDADR	;DON'T MAP PRIVATE SECTIONS FOR NOACT
	MOVL	#CRETVA$_NARGS,ARGCNT(R6) ;SET THE ARGUMENT COUNT
	$CRETVA_G (R6)			;AND CREATE THE DEMAND ZERO PAGES
	BLBC	R0,IMGACT_RET4		;BRANCH IF CREATE FAILED
	BRW	RET_MAPRANGE		;KEEP GOING IF CREATE SUCCEEDED



IMGACT_RET4:
	BRW	IMGACT_ERREXIT		;EXIT WITH ERROR STATUS CODE


NXTISDADR:
	MOVZWL	ISD$W_SIZE(R3),R0	;USE THE SIZE OF THIS ISD
	ADDL	R0,R3			;TO FORM THE ADDRESS OF THE NEXT ONE

	.ENABL	LSB

CHKISD:
	SUBL3	R3,BUFEND(R6),R2	;SPACE LEFT IN BUFFER
	BLEQ	BADIMGHDR1		;ERROR IF AT OR OFF THE END
	CVTWL	ISD$W_SIZE(R3),R0	;SIZE OF THIS ISD
	BEQL	END_OF_ISDS		;IF ZERO THEN ALL DONE
	BLSS	NXTHDRADR		;IF NEGATIVE THEN GET NEXT HEADER BLOCK
	CMPL	R0,R2			;DOES ISD FIT IN THIS BUFFER?
	BGTR	BADIMGHDR1		;ERROR IF NOT
	CMPL	R0,#ISD$K_LENDZRO	;AT LEAST AS BIG AS SMALLEST ISD?
	BLSS	BADIMGHDR1		;ERROR IF NOT
	ASSUME	SEC$V_GBL EQ 0
	ASSUME	SEC$V_DZRO EQ 2
	BICB3	#^C<SEC$M_GBL ! SEC$M_DZRO>,-
		ISD$L_FLAGS(R3),R1	;GET GBL AND DZRO BITS
	BEQL	120$			;BRANCH IF NOT GBL AND NOT DZRO
	BLBC	R1,140$			;BRANCH IF NOT GBL BUT DZRO
;
; GLOBAL ISD
;
115$:	CMPL	R0,#ISD$K_LENGLBL	;RIGHT LENGTH FOR GLOBAL ISD?
	BEQL	140$			;BRANCH IF OK
BADIMGHDR1:
	BRW	BADIMGHDR		;IMAGE HEADER IS BAD FORMAT


;
; PROCESS SECTION ISD
;
120$:	CMPL	R0,#ISD$K_LENPRIV	;RIGHT LENGTH FOR PROCESS ISD?
	BNEQ	115$			;GLOBAL LENGTH IS OK TOO

140$:	BRW	NXTISD			;GO PROCESS THIS ISD


	.DSABL	LSB

;
; MORE ISD'S IN THE NEXT HEADER BLOCK
;
NXTHDRADR:
	DECL	HDRBLKCNT(R6)		;ANY MORE HEADER BLOCKS?
	BLEQ	BADIMGHDR1		;ERROR IF NOT
	MOVAL	OTHERHDR(R6),R3		;ADDRESS OF BUFFER FOR SUBSEQUENT HEADER BLOCKS
	ASSUME	IAC$V_KP_RESHDR GE 8
	ASSUME	IAC$V_KP_RESHDR	LT 16
	BICB	#IAC$M_KP_RESHDR@-8,IACFLG+1(R6) ;ONLY SINGLE BLK HDRS MAY BE RES
	MOVAL	512(R3),BUFEND(R6)	;SET END OF 2ND BUFFER
;
; IF ACTIVATING FROM A SEQUENTIAL LOAD DEVICE, 2ND HEADER BUFFER HAS
; ALREADY BEEN READ IN (SEE LOAD_SECTION CODE), JUST START SCANNING IT.
;
	BBS	#IAC$V_SEQDEVLOD,IACFLG(R6),CHKISD ;BR IF HEADER ALREADY IN MEMORY
	BRW	NXTHDR			;READ THE NEXT HEADER BLOCK


;
; NOT ACTIVATING THE IMAGE, JUST COMPLETE THE KNOWN FILE ENTRY ENHANCEMENT
; AND RETURN AN ACCESS VIOLATION
;
NOACT:
	MOVAL	W^KFI_MAK_SHR_RES,KRNLROUT(R6) ;SET ROUTINE TO CALL
	BSBW	CMKRNL			;FINISH KNOWN FILE ENHANCEMENTS
	BLBS	RETSTATUS(R6),5$	;IF RET STATUS IS SUCCESS, USE CUR R0
	MOVL	RETSTATUS(R6),R0	;RETURN PREVIOUS ERROR STATUS CODE
5$:	PUSHL	R0			;REMEMBER RETURN STATUS CODE
	BRW	IMGACT_ERREXIT1		;EXIT WITH STATUS, SKIPPING THE
					;KFI_DECREF CALL WHICH WAS ALREADY
					;DONE BY KFI_MAK_SHR_RES


IMGACT_RET5:
	BRW	IMGACT_ERREXIT		;EXIT WITH ERROR STATUS IN R0


RECUR_CALL_NOW1:
	BRW	RECUR_CALL_NOW		;GO MAP GBL SECTION CLUSTER (RECUR CALL)
	.PAGE
	.SUBTITLE	IMAGE ACTIVATOR COMPLETION PATH

;++
;
;  At this point. all ISDs contained in the image file have been processes.
;  This path tends to several details.
;
;  o	The image I/O segment is created.
;
;  o	The user stack is created.
;
;  o	The kernel mode routine SETCTLREG is called to make any adjustments
;	to the P1 pointer page, to set the PR$_USP register, and to set the
;	privilege mask.
;
;  o	Any address fixups for shareable images are performed at this time.
;
;  Input parameters:
;
;	R6 = Address of image activator impure area
;
;--

END_OF_ISDS:
	.ENABL	LSB
	BBC	#IAC$V_SEQDEVLOD,IACFLG(R6),30$ ;BRANCH IF NOT A SEQUENTIAL DEVICE
	$DASSGN_S CHAN=CHAN(R6)		;CLOSE THE FILE, DONE READING IT
	CLRW	CHAN(R6)		;RETURN A ZERO CHANNEL
30$:
	BBC	#IAC$V_SHAREABLE,IACFLG(R6),40$ ;SAVE CHANNEL IF SHAREABLE IMAGE
	MOVL	IMGHDRBUF(R6),R0	;IS THERE A PLACE TO PUT IT?
	BEQL	40$			;SKIP RETURN OF CHANNEL IF NONE
	IFWRT	#2,(R0),35$		;IS BUFFER STILL ACCESSIBLE?
	BRW	IMGACT_ACCVIO1		;ABORT ACTIVATION IF NOT


35$:	MOVW	CHAN(R6),(R0)		;RETURN CHANNEL NUMBER
40$:
	BBS	#IAC$V_GBLCLUSTR,IACFLG(R6),RECUR_CALL_NOW1 ;REMEM TO MAP CLUSTR
	MOVQ	R3,IOSB(R6)		;SAVE ADR OF END AND BEGIN OF HEADER
					;IN CASE IT IS BEING MADE RESIDENT

	ASSUME	IAC$V_NOACT EQ 0
	BLBS	IACFLG(R6),NOACT	;BRANCH IF NOT ACTIVATING THE IMAGE
	BBS	#IAC$V_SHAREABLE,IACFLG(R6),80$ ;NO STACK IF SHAREABLE IMAGE
	BBS	#IAC$V_MERGE,IACFLG(R6),80$ ;NO STACK IF MERGING IMAGE
;
; CHANNEL COUNT PARAMETER IS CURRENTLY IGNORED
;
	MOVZWL	IMGIOCNT(R6),R1		;IMAGE I/O PAGE COUNT SPEC. AT LINK TIME
	BNEQ	70$			;BRANCH IF SPECIFIED
	MOVZWL	G^SGN$GW_IMGIOCNT,R1	;OTHERWISE USE SYSTEM DEFAULT
70$:	ROTL	#9,R1,R1		;FORM BYTE COUNT
	BBS	#IHD$V_P0IMAGE,LNKFLAGS(R6),90$ ;BR IF THIS IS P0 ONLY IMAGE
	MOVL	IOSEGADR(R6),R0		;GET STARTVA FOR IOSEGMENT
	MOVQ	R0,-(SP)		;SAVE IMAGE I/O SECTION DESCRIPTOR
	MOVAB	-(R1)[R0],R1		;ENDVA=STARTVA+SIZE-1
	BRB	100$			;CONTINUE WITH COMMON CODE

80$:	BRW	150$			;BR AID TO SKIP I/O SEG & USER STACK


90$:	PUSHL	R1			;SAVE SIZE OF STACK
	$EXPREG_S	PAGCNT=#1,-	;FIND VA OF NEXT FREE PAGE
			RETADR=STARTVA(R6),-
			ACMODE=#PSL$C_USER
	BLBC	R0,IMGACT_RET6		;RETURN ERROR CODE IF NOT SUCCESSFUL
	MOVL	STARTVA(R6),R0		;GET STARTING VA FOR I/O SEGMENT
	MOVL	(SP),R1			;RESTORE SIZE OF IOSEGMENT IN BYTES
	MOVAB	(R1)[R0],R1		;ENDVA=STARTVA+SIZE-1
	PUSHL	R0			;REMEMBER STARTVA
100$:	MOVQ	R0,STARTVA(R6)		;STORE RANGE TO CREATE
	MOVL	#CRETVA$_NARGS,ARGCNT(R6) ;# OF PARAMS TO CRETVA
	MOVW	#<PRT$C_UREW @ 8 ! PSL$C_EXEC>,ACMODE(R6) ;EXEC PAGES
	$CMKRNL_S G^MMG$CRETVA,(R6)	;CREATE THE PAGES USING PRIVILEGED
					;KERNEL MODE ENTRY POINT TO CRETVA
	BLBC	R0,IMGACT_RET6		;EXIT IF FAILED TO CREATE

	ASSUME	IMP$L_IOSEGLEN EQ IMP$L_IOSEGADDR+4
	MOVQ	(SP)+,@#PIO$GW_IIOIMPA+IMP$L_IOSEGADDR ;IMAGE I/O ADDRESS AND SIZE
	EXTZV	#IHD$V_NOP0BUFS,#1,LNKFLAGS(R6),R0 ;PASS THROUGH THE P0 SPACE
	INSV	R0,#IMP$V_NOP0BUFS,#1,@#PIO$GW_IIOIMPA ;BUFFER INHIBIT FLAG TO RMS
	ASHL	#-9,G^SGN$GL_EXUSRSTK,R0 ;CALCULATE PAGES OF EXTRA USER STACK
	MOVL	USRSTACKCNT(R6),R1	;CNT OF STACK PAGES SPEC AT LINK TIME
	BNEQ	110$			;BR IF COUNT SPECIFIED
	MOVZBL	#20,R0			;DEFAULT TO A REASONABLE AMOUNT OF STACK
110$:	ADDL2	R1,R0			;COMPUTE TOTAL STACK SIZE
	BSBW	CREATE_STACK		;CREATE USER STACK PAGES
	BLBS	R0,125$			;BR IF SUCCESSFUL
IMGACT_RET6:
	BRW	IMGACT_ERREXIT		;RETURN ERROR STATUS


125$:	BBC	#IAC$V_XLINKER,IACFLG(R6),150$ ;BRANCH IF NOT CROSS LINKER FORMAT
;
; THIS IS A CROSS LINKER HEADER, MAKE IT INTO A NATIVE MODE FORMAT
;
	MOVW	#IHX$T_IMGNAM,IHD$W_ACTIVOFF(R4) ;FORM A NATIVE MODE HEADER
	MOVQ	IHX$Q_STARTADR(R4),IHX$T_IMGNAM(R4) ;MOVE THE START ADDRESS VECTOR
	CLRQ	IHD$W_SYMDBGOFF(R4)	;CLEAR THE OFFSETS TO OTHER AREAS
	CLRQ	IHX$T_IMGNAM+8(R4)
	ASSUME	IHX$T_IMGNAM+16 EQ IHD$L_LNKFLAGS
	CLRQ	IHX$T_IMGNAM+16(R4)	;ZERO REST OF IMAGE NAME FIELD
					;MAKES A NULL LNKFLAGS FOR XLINKER
	MOVW	#IHX$L_DSTVBN,IHD$W_SIZE(R4) ;ASSUME JUST TRANSFER ADDRESSES PRESENT
	CMPW	IHD$W_MINORID(R4),#IHX$K_MINORID1 ;DEBUG DATA TOO?
	BLSS	150$			;BRANCH IF NOT
	MOVL	IHX$L_TFRADR3(R4),IHX$T_IMGNAM+8(R4) ;STORE 3RD TRANSFER ADDRESS
	MOVW	IHD$W_SIZE(R4),IHD$W_SYMDBGOFF(R4) ;SYMBOL TABLE AREA OFFSET
	ADDW	#12,IHD$W_SIZE(R4)	;ADJUST SIZE
;
; BIAS ANY P1 TRANSFER ADDRESSES
;
150$:	BBS	#IAC$V_IS_RESHDR,IACFLG(R6),180$ ;IF RESIDENT HEADER, ALREADY DONE
	MOVZWL	IHD$W_ACTIVOFF(R4),R3	;OFFSET TO TRANSFER VECTOR
	ADDL	R4,R3			;ADDRESS OF TRANSFER VECTOR
	MOVZBL	#2,R2			;GET MAXIMUM NUMBER OF TRANSFER ADRS
155$:	BITL	#<VA$M_P1 ! VA$M_SYSTEM>,(R3)[R2] ;IS THIS P0 SPACE?
	BEQL	160$			;BR IF IT IS P0 SPACE
	CMPL	CTLBASADR(R6),(R3)[R2]	;IS TRANSFER ADR WITHIN THE SHELL?
	BLSSU	170$			;BR IF WITHIN SHELL, DON'T BIAS TRAN ADR
	SUBL	CTLBASCNT(R6),(R3)[R2]	;BIAS P1 ADR BY BASE ADR OF SHELL
	BRB	170$			;CONTINUE, GO GET NEXT TRANSFER ADR

160$:	ADDL	MAPBASE(R6),(R3)[R2]	;BIAS P0 ADR BY THE P0 MAPPING BASE VA
170$:	SOBGEQ	R2,155$			;CONTINUE FOR ALL THREE TRANSFER ADRS
180$:	BBS	#IAC$V_SHAREABLE,IACFLG(R6),300$ ;NO RET BUF IF SHAREABLE IMAGE
	MOVL	IMGHDRBUF(R6),R3	;ADDRESS OF RETURN BUFFER

; THIS ASSUMPTION GUARANTEES THAT ALL RETURNED DATA FITS IN A SINGLE PAGE

	ASSUME	<12+IHD$K_LENGTH+20+8+255> LE 512

	IFWRT	#512,(R3),190$		;IS IFD BUFFER STILL ACCESSIBLE?
	BRW	IMGACT_ACCVIO1		;RETURN ERROR IF NOT


190$:	MOVZWL	(R4),R0			;SIZE OF IMAGE HEADER DESCRIPTOR
	MOVAB	12(R3),(R3)+		;SET ADR OF IHD IN BUFFER
	MOVAB	8(R3)[R0],(R3)+		;SET ADR OF IFD IN BUFFER
	CLRL	(R3)+			;NO MORE FAB; CRETVA BELOW DELETES IT
	MOVC3	R0,(R4),(R3)		;MOVE THE IMAGE HEADER DESCRIPTOR
;
; R3 CONTAINS THE ADDRESS OF THE NEXT BYTE NOT STORED INTO
;
	MOVL	#IFD$K_LENGTH,R0	;SIZE OF IMAGE FILE DESCRIPTOR
					;IF NO RESULTANT STRING
	MOVZBL	RSLTNAME(R6),R1		;SIZE OF RESULTANT STRING
	BEQL	200$			;BRANCH IF NULL
	ADDL	#4,R1			;ADD COUNT BYTE AND ROUND UP
	BICL	#3,R1			;TO LONG WORD BOUNDARY
	ROTL	#16,R0,R0		;RESULT NAME OFFSET IN HIGH WORD
	ADDW3	#IFD$K_LENGTH,R1,R0	;SIZE OF IFD INCLUDING RESULT STRING
200$:	MOVL	R0,(R3)+		;SIZE AND NAME OFFSET
	CLRL	(R3)+			;2 RESERVED OFFSETS
	MOVL	CHAN(R6),(R3)+		;IMAGE CHANNEL AND COMPAT MODE CHAN

	ASSUME	IFDFLAGS EQ CMKFIADR+4
	MOVQ	CMKFIADR(R6),(R3)+	;COMPAT MODE KNOWN FILE ENTRY ADDRESS
					;AND IMAGE FILE DESCRIPTOR FLAGS
	MOVZBL	RSLTNAME(R6),(R3)+	;SET SIZE OF RESULTANT FILE NAME
	MOVAB	<IFD$K_LENGTH+1-<IFD$Q_CURPROG+4>>(R3),(R3)+ ;SET ADR OF FILNAM
	MOVC3	R1,RSLTNAME(R6),(R3)	;MOVE THE RESULTANT NAME STRING
300$:	MOVAL	W^SETCTLREG,KRNLROUT(R6) ;SET UP USER STACK, PROCESS PRIVILEGES,
	BSBW	CMKRNL			;AND RELEASE KNOWN FILE ENTRY
	PUSHL	S^#SS$_NORMAL		;SAVE SUCCESSFUL COMPLETION INDICATION
	.DSABL	LSB
IMGACT_EXIT:
	BLBS	(SP),400$		;BR IF SUCCESSFUL RETURN STATUS
	MOVAL	W^RESET_VECTORS,KRNLROUT(R6) ;RESTORE VECTORS TO INPUT VALUES
	BSBW	CMKRNL			;(KERNEL MODE TO WRITE CTL$GL_RMSBASE)
	BRB	450$			;DON'T INIT PAGES ON ERROR EXIT

400$:	BBC	#IAC$V_NOCMKRNL,IACFLG(R6),410$ ;BR IF SYS VERSIONS MATCHED
	MOVZWL	#SS$_SYSVERDIF,(SP)	;RETURN ALTERNATE INFORMATIONAL STATUS
;
;  Do not do address fixups in a recursive call or if a known image
;  image is being installed.
;
410$:	BITL	#<IAC$M_NOACT!-		;SKIP IF CALLED BY INSTALL,
		IAC$M_SHAREABLE!-	; OR IF RECURSIVE CALL, 
		IAC$M_P1MERG_P0>,-	; OR IF P0 PART OF P1 MERGE
		IACFLG(R6)
	BNEQ	430$

;  By now, all SHL entries for shareable images have had their base addresses
;  filled in. However, the SHL for the executable image has not had its
;  base address filled in. That must be done before the fixups are done.
;  This information is contained in the return range array, either the one
;  specified by the caller or the one supplied by default. That address
;  is passed to the fixup subroutine.

	MOVL	IAFEXE(R6),R0		;GET ADDRESS OF FIXUP VECTOR
	BEQL	430$			;SKIP IF THERE IS NONE
	IFNORD	#4,IAF$L_SHLSTOFF(R0),IMGACT_ACCVIO1
	ADDL2	IAF$L_SHLSTOFF(R0),R0	;POINT R0 TO SHL ENTRY NUMBER 0
	IFNOWRT	#4,SHL$L_BASEVA(R0),IMGACT_ACCVIO1
	MOVL	RETSTARTVA_CUM(R6),SHL$L_BASEVA(R0) ;STORE BASE ADDRESS OF EXECUTABLE IMAGE
430$:	MOVL	RETMAPADR(R6),R0	;DOES CALLER WANT MAPPED ADDRESS RANGE?
	BEQL	440$			;EQUAL IMPLIES NO
	IFNOWRT	#8,(R0),IMGACT_ACCVIO1	;QUADWORD STILL WRITABLE?
	MOVQ	RETSTARTVA_CUM(R6),(R0)	;RETURN ADDRESS RANGE ACTUALLY MAPPED
440$:	$CRETVA_S INADR=-8(FP),- 	;MAKE IMAGE ACTIVATOR SCRATCH PAGES
		ACMODE=S^#PSL$C_USER	;DEMAND ZERO AGAIN
	BBC	#ACM$V_IMAGE,G^EXE$GL_ACMFLAGS,450$;IMAGE ACCOUNTING ENABLED ?
	BITL	#<IAC$M_NOACT!-		;SKIP IF CALLED BY INSTALL,
		IAC$M_SHAREABLE!-	; OR IF RECURSIVE CALL, 
		IAC$M_MERGE>,-		; OR IF MERGED ACTIVATION CALL
		IACFLG(R6)
	BNEQ	450$
	BISL3	@#CTL$GQ_ISTART,@#CTL$GQ_ISTART+4,R0;IMAGE ACCOUNTING ACTIVE ?
	BNEQ	450$			; IF NEQ, YES
	MOVAL	W^IMAGE_ACNT,KRNLROUT(R6); INITIALIZE IMAGE ACCOUNTING DATA
	BSBW	CMKRNL
450$:	MOVL	(SP)+,R0		;RECOVER STATUS CODE
	RET				;RETURN TO CALLER





IMGACT_ACCVIO1:
	MOVZWL	S^#SS$_ACCVIO,R0	;ACCESS VIOLATION
IMGACT_ERREXIT:
	PUSHL	R0			;SAVE ERROR STATUS
	BSBW	KFI_DECREF		;RELEASE KNOWN FILE ENTRY IF ANY
;
; 0(SP) = ERROR STATUS
;
IMGACT_ERREXIT1:
	MOVL	CHAN(R6),R2		;GET BOTH CHANNELS
	TSTW	R2			;FIRST CHANNEL ASSIGNED?
	BEQL	20$			;BRANCH IF NOT
10$:	$DASSGN_S R2			;DEASSIGN THE CHANNEL
	CLRW	R2			;THIS CHANNEL IS DEASSIGNED
20$:	ROTL	#16,R2,R2		;GET SECOND CHANNEL IF ANY
	BNEQ	10$			;BRANCH IF ANOTHER TO DEASSIGN

	BBS	#IAC$V_RETRY,IACFLG(R6),30$ ;BRANCH IF SUPPOSED TO RETRY
	MOVAB	IAC$CLRIACLOCK,KRNLROUT(R6) ;CLEAR IMAGE ACTIVATOR LOCK
	BSBW	CMKRNL			;IF ONE WAS SET
	BRW	IMGACT_EXIT		;AND EXIT


30$:	MOVL	FP,SP			;RESET THE STACK FRAME
	BRW	EXE$IMGACT+2		;AND RESTART THE SERVICE FROM THE BEGINNING
	.PAGE
	.SUBTITLE	CREATE_STACK	Create User Stack Space
;+
;	Create Stack Space at end of P0 or P1 space
;
; Calling Sequence:
;
;	JSB	CREATE_STACK
;
; Input Parameters:
;
;	R0 = Number of pages to create
;
; Implicit Input:
;
;	R6 = Address of image activator impure area
;
; Output Parameters:
;
;	USRSTACKADR(R6)		One byte beyond region just created
;	USRSTACKADR+4(R6)	Low address of region just created
;
; Implicit Output:
;
;	The requested number of pages is created 
;
;		at the low address end of P1 space for normal images or
;
;		at the high address end of P0 space for P0 only images
;
; Return Status:
;
;	Status from SYS$EXPREG returned in R0
;
; Side Effects:
;
;	R1 is destroyed
;-

CREATE_STACK:
	PUSHL	#1			; Assume stack is in P1 space
	BBC	#IHD$V_P0IMAGE,LNKFLAGS(R6),10$ ; Branch if not a P0-only image
	CLRL	(SP)			; else force the stack to be in P0 space
10$:	$EXPREG_S -			; Create the stack space
		PAGCNT=R0,-		; Desired number of pages
		REGION=(SP),-		; Expand P0 or P1 space
		ACMODE=#PSL$C_USER,-	; These are user pages
		RETADR=USRSTACKADR(R6)	; Return range of addresses created
	BLBC	R0,30$			; Quit if failed to expand region 
	TSTL	(SP)+			; Was stack in P0 space
	BNEQ	20$			; Branch if not
	PUSHL	USRSTACKADR(R6)		; Otherwise, put return address array
	MOVL	USRSTACKADR+4(R6),USRSTACKADR(R6) ;  in canonical order of high
	POPL	USRSTACKADR+4(R6)	;  address followed by low address
20$:	INCL	USRSTACKADR(R6)		; Finally, make first longword point to
					;  one byte beyond created region.
30$:	RSB				; Return to caller
	.PAGE
	.SUBTITLE	CREATE_IAF	Create shareable image list
;+
;	Create shareable image list dynamically
;
; Abstract:
;
;	This routine is called when an old (pre Version 3) executable image
;	that links with new shareable images is activated. In such cases, a
;	shareable image list associated with the executable image must be
;	dynamically created. 
;
;	The size of the fixup vector accepts as input the size (in blocks)
;	of the image header and calculates the maximum number of different
;	shareable images that could fit into such a header. A fixup vector
;	large enough to hold that number of shareable image names is then
;	created and the offset fields initialized.
;
; Calling Sequence:
;
;	JSB	CREATE_IAF
;
; Implicit Input:
;
;	R6 = Address of image activator impure area
;
; Implicit Output:
;
;	A number of pages is created at the low address end of P1 space
;	(high address end of P0 space if P0-only image) and initialized
;	as an empty fixup vector. The address at which the image I/O 
;	segment will be mapped is altered.
;
; Return Status:
;
;	Status from CREATE_STACK (actually SYS$EXPREG) returned in R0
;
; Side Effects:
;
;	R1 and R2 are destroyed (by CREATE_STACK)
;-

CREATE_IAF:
	BBS	#IAC$V_P1MERGE,IACFLG(R6),30$	; This is not during a P1 merge
	ASHL	#9,HDRBLKCNT(R6),R0	; Convert to byte count
	DIVL3	#ISD$K_LENGLBL,R0,-(SP)	; Save number of global ISDs that fit
	ADDL3	(SP),#1,R0		; Include an extra slot for main program
	MULL2	#SHL$K_LENGTH,R0	; Convert to byte count for SHL list
	ADDL2	#<IAF$K_LENGTH + 511>,R0 ; Allow for fixed size portion of 
					;  fixup vector and rounding factor.
	ASHL	#-9,R0,R0		; Convert back to page count
	BSBW	CREATE_STACK		; Create the address space
	BLBC	R0,20$			; Skip rest if space was not created
	MOVL	USRSTACKADR+4(R6),R0	; Low address of range mapped to R0 
;
;  Add to end of fixup vector list so it's out of the way
;
	MOVL	@#CTL$GL_IAFLAST,R1	; Get address of current last element
	MOVL	R0,IAF$L_IAFLINK(R1)	; Make it point to new IAF
	MOVL	R0,@#CTL$GL_IAFLAST	; Make new IAF the last IAF
	CLRL	IAF$L_IAFLINK(R0)	;  and zap its link field
;
;  The space just created consists of demand zero pages. Only those fields
;  in the with nonzero contents need to be initialized.
;
	ASSUME	<IAF$W_FLAGS> EQ <IAF$W_SIZE + 2>
	MOVZWL	#IHD$K_LENGTH,IAF$W_SIZE(R0) ; Store size and clear flags word
	MOVZWL	#IHD$K_LENGTH,IAF$L_SHLSTOFF(R0) ; Only a SHL in this fixup vector
	MOVL	#1,IAF$L_SHRIMGCNT(R0)	; Reserve one slot
	POPL	IAF$L_SHLEXTRA(R0)	; Restore count of extra SHL entries
;
;  Update the variables that describe the low address end of P1 space.
;
	SUBL3	USRSTACKADR+4(R6),USRSTACKADR(R6),R1 ; Get number of bytes mapped
	SUBL2	R1,IOSEGADR(R6)		; Bias address of image I/O segment
	SUBL2	R1,CTLBASADR(R6)	; Bias address of image activator shell
	ADDL2	R1,CTLBASCNT(R6)	; Revise page count of image activator shell
10$:	MOVZWL	#SS$_NORMAL,R0		; Indicate success
	RSB

20$:	ADDL2	#4,SP			; Clean number of SHL entries off stack
	RSB				;  and return with error

30$:	MOVZWL	#SS$_RELINK,R0		; Cannot use old shareable images
	RSB				;  in a P1 merged activation
	.PAGE
	.SBTTL	UPDATE_RETADR - UPDATE RETURN MAP RANGE
;
;	UPDATE MAPPED RANGE QUADWORD RETURNED TO CALLER
;
; INPUTS:
;
;	R0 = STARTING VA MAPPED
;	R1 = ENDING VA MAPPED
;	R6 = ADDRESS OF IMGACT SCRATCH STORAGE
;	RETMAPADR(R6) = ADDRESS OF CALLER'S RETADR QUADWORD
;
; OUTPUTS:
;
;	CALLER'S RETADR QUADWORD IS UPDATED.
;
UPDATE_RETADR:
	PUSHR	#^M<R2,R3>		;SAVE REGISTERS
	MOVAL	RETSTARTVA_CUM(R6),R2	;LOCATE QUADWORD TO STORE NEW LIMITS
	ADDL3	#1,(R2),R3		;IS THIS FIRST SECTION MAPPED?
	BNEQ	10$			;BRANCH IF IT IS NOT
	MOVL	R0,(R2)			;SET START VA MAPPED
10$:	MOVL	R1,4(R2)		;SET END VA MAPPED
	POPR	#^M<R2,R3>		;RESTORE REGISTERS
	RSB
	.PAGE
	.SBTTL	KFI_GBLSECNMINI, KFI_GBLSECNMNXT, IAC$TRNGBLSEC
;
; KFI_GBLSECNMINI - INITIALIZE KNOW FILE GLOBAL SECTION NAME STRING
;
; CALLING SEQUENCE:
;
;	BSBW	KFI_GBLSECNMINI
;
; INPUTS:
;
;	R6 = ADDRESS OF IMAGE ACTIVATOR SCRATCH STORAGE
;	R7 = ADDRESS OF KNOWN FILE ENTRY
;
; OUTPUTS:
;
;	R2,R3 PRESERVED
;	KFINAMSTR(R6) = COUNTED ASCII STRING FOR GLOBAL SECTION NAME
;
KFI_GBLSECNMINI:
	PUSHR	#^M<R2,R3,R4,R5>	;SAVE REGISTERS FROM MOVC
	MOVAB	KFINAMSTR(R6),R3	;ADDRESS TO STORE GLOBAL SEC NAME STRING
	MOVZBL	KFI$B_FILNAM(R7),R1	;OFFSET TO KNOWN FILE "FILE NAME" STRING
	ADDL	R7,R1			;ADDRESS OF FILE NAME STRING
	MOVZBL	(R1)+,R0		;SIZE OF STRING TO MOVE
	ADDB3	#4,R0,(R3)+		;STORE BYTE COUNT OF GBL SEC NAME STRING
					;HIGH 24 BITS OF R0 ASSUMED ZERO
	MOVC3	R0,(R1),(R3)		;MOVE THE FILE NAME AND COUNT BYTE
	MOVL	#^A/_000/,(R3)		;STORE SECTION NAME SUFFIX
	POPR	#^M<R2,R3,R4,R5>	;RESTORE SAVED REGISTERS
	RSB
	.PAGE
;
; KFI_GBLSECNMNXT - FORM THE NEXT KNOWN FILE GLOBAL SECTION NAME BY
;	BY ADDING 1 (IN ASCII) TO THE LAST CHARACTERS OF THE NAME
;
; CALLING SEQUENCE:
;
;	BSBW	KFI_GBLSECNMNXT
;
; INPUTS:
;
;	KFINAMSTR(R6) = COUNTED ASCII GLOBAL SECTION NAME
;
; OUTPUTS:
;
;	R2,R3 PRESERVED
;	GLOBAL SECTION NAME ALTERED TO GET THE "NEXT" NAME
;	GSDNAMSIZ(R6) - GLOBAL SECTION NAME DESCRIPTOR SET UP
;
KFI_GBLSECNMNXT:
	MOVAB	KFINAMSTR(R6),R1	;ADDRESS OF COUNTED STRING
	MOVZBL	(R1)+,R0		;SIZE OF STRING
	MOVQ	R0,GSDNAMSIZ(R6)	;SET GLOBAL SECTION NAME DESCRIPTOR
	ADDL	R0,R1			;ADDRESS OF LAST+1 BYTE
10$:	INCB	-(R1)			;ADD ONE
	CMPB	(R1),#^A/9/		;IN DECIMAL ASCII
	BLEQ	20$			;BRANCH IF NO CARRY
	MOVB	#^A/0/,(R1)		;STORE ZERO AND CARRY A ONE
	CMPB	#^A/_/,-1(R1)		;NO CARRY PAST THE SEPARATOR
	BNEQ	10$
20$:	RSB
	.PAGE
	.SBTTL	LOAD_SECTION - LOAD SECTION FROM SEQ DEV
;
; LOAD_SECTION - LOAD A PROCESS SECTION FROM A SEQUENTIAL DEVICE
;	BY READING THE PAGES INTO VIRTUAL MEMORY.  THIS ALLOWS AN
;	IMAGE TO BE RUN FROM A BLOCK STRUCTURED DEVICE THAT CAN BE
;	SEQUENTIALLY (BUT NOT RANDOMLY) ACCESSED A PAGE AT A TIME.
;
; CALLING SEQUENCE:
;
;	BSBW	LOAD_SECTION
;
; INPUTS:
;
;	INADR(R6)  - ADDRESSS OF RANGE OF ADDRESSES TO LOAD INTO
;	PAGCNT(R6) - NUMBER OF PAGES TO LOAD
;	CHAN(R6)   - I/O CHANNEL ON WHICH THE FILE IS OPEN
;	FLAGS(R6)  - SECTION FLAGS FOR MAPPING THIS SECTION
;
; OUTPUTS:
;
;	R0 - RETURN STATUS
;	R3 - PRESERVED
;
LOAD_SECTION:
	PUSHL	R3			;PRESERVE THIS REGISTER
	ROTL	#9,#1,R2		;R2=#512, THE BYTE COUNT TO READ
;
; HDRVBN IS 2 IF JUST READ IN THE FIRST HEADER, IT IS -1 IF THE HEADER
; WAS RESIDENT,  THIS CODE USES IT AS A FLAG INDICATING THAT THIS IS
; THE LOAD OF THE VERY FIRST IMAGE SECTION.  IT IS ONLY USED BY THE
; READ NEXT HEADER LOGIC WHICH CANNOT BE EXECUTED AGAIN FOR A
; SEQUENTIAL LOAD DEVICE.
;
	TSTL	HDRVBN(R6)		;FIRST TIME THROUGH THIS CODE?
	BLEQ	12$			;BRANCH IF NOT
	CLRL	HDRVBN(R6)		;DON'T TAKE THIS PATH AGAIN
;
; ZERO THE DEBUG SYMBOL TABLE AREA OF THE IMAGE HEADER TO AVOID CONFUSING
; THE DEBUGGER.  IT WOULD NOT BE ABLE TO MAP THE SYMBOL TABLE ANYWAY.
;
	MOVZWL	IHD$W_SYMDBGOFF(R4),R0	;OFFSET TO SYMBOL TABLE AREA
	BEQL	2$			;BRANCH IF NONE PRESENT
	CMPW	R0,#512-IHS$C_LENGTH	;MAKE SURE THE FOLLOWING CLEARS ARE
	BGTRU	4$			;WITHIN THE HEADER BLOCK, BR IF NOT
	ADDL	R4,R0			;ADDRESS OF SYMBOL TABLE AREA

	ASSUME	IHS$C_LENGTH EQ 12
	CLRQ	(R0)+			;CLEAR THE ENTIRE
	CLRL	(R0)			; SYMBOL TABLE AREA
;
; BEFORE THE FIRST SECTION PAGE IS LOADED, ANY ADDITIONAL IMAGE HEADER
; PAGES MUST BE READ IN.  THE CURRENT DESIGN ONLY ALLOWS FOR ONE ADDITIONAL
; HEADER PAGE BUFFER, SO ANY IMAGES WITH 3 OR MORE IMAGE HEADER PAGES
; WILL NOT BE ACTIVATED.
;
2$:	CMPL	HDRBLKCNT(R6),#2	;EXACTLY A TWO BLOCK HEADER?
	BLSS	12$			;BRANCH IF ALL HEADER BLOCKS READ IN
	BEQL	6$			;BRANCH IF NEED TO READ 2ND HEADER
4$:	MOVZWL	#SS$_BADIMGHDR,R0	;3 OR MORE BLOCK HEADER CAN'T BE HANDLED
	BRB	50$

6$:	CLRL	R1			;NO VBN FOR SEQ DEV
	MOVAL	OTHERHDR(R6),R3		;ADDRESS OF 2ND HEADER BUFFER
	BSBB	READ_VBN		;READ THE 2ND HEADER BLOCK
	BLBC	R0,50$			;BRANCH IF ERROR
12$:
	MOVL	#CRETVA$_NARGS,ARGCNT(R6) ;ARGUMENT COUNT FOR CRETVA
	$CRETVA_G (R6)			;CREATE THE DESIRED ADDRESS SPACE
	BLBC	R0,50$			;BR IF ERROR
	MOVL	@INADR(R6),R3		;STARTING VIRTUAL ADDRESS TO READ INTO
20$:	CLRL	R1			;NO VIRTUAL BLOCK REQUIRED
	BSBB	READ_VBN		;READ THE NEXT BLOCK
	BLBC	R0,50$			;BR IF READ FAILED
	ADDL	R2,R3			;NEXT ADDRESS TO READ INTO
	SOBGTR	PAGCNT(R6),20$		;LOOP THROUGH SPECIFIED # OF PAGES
	BBS	#SEC$V_WRT,FLAGS(R6),50$ ;BR IF SECTION SHOULD BE BE WRITABLE
	$SETPRT_S -			;MAKE THE PAGE READ ONLY
		INADR=@INADR(R6),-	;RANGE OF ADDRESSES TO SET PROTECTION
		ACMODE=#PSL$C_USER,-	;USER OWNED PAGES
		PROT=S^#PRT$C_UR	;USER READ ONLY
50$:	POPL	R3			;RECOVER SAVED REGISTER
	RSB				;AND RETURN WITH STATUS IN R0
	.PAGE
	.SBTTL	READ_VBN, AME_IMAGE
;
; READ_VBN - READ A VIRTUAL BLOCK FROM THE IMAGE FILE
;
; CALLING SEQUENCE:
;
;	BSBW	READ_VBN
;
; INPUTS:
;
;	R1 = DESIRED VBN
;	R2 = BYTE COUNT = ^X200
;	R3 = STARTING VIRTUAL ADDRESS
;	CHAN(R6) = CHANNEL ON WHICH IMAGE FILE IS OPEN
;	IOSB(R6) = ADDRESS OF 8 BYTE I/O STATUS BLOCK TO USE
;
; OUTPUTS:
;
;	R0 = RETURN STATUS
;	R2,R3 PRESERVED
;
READ_VBN:
	$QIOW_S -			;DO THE READ A PAGE AT A TIME
		EFN=#26,-		;USE A RESERVED EVENT FLAG
		CHAN=CHAN(R6),-		;CHANNEL ON WHICH FILE IS OPEN
		FUNC=#IO$_READVBLK,-	;QI/O READ VIRTUAL BLOCK
		IOSB=IOSB(R6),-		;ADDRESS OF I/O STATUS BLOCK
		P1=(R3),-		;ADDRESS TO READ INTO
		P2=R2,-			;NUMBER OF BYTES TO READ
		P3=R1			;DESIRED VIRTUAL BLOCK NUMBER
	BLBC	R0,20$			; Return immediately if error occurred
10$:	MOVZWL	IOSB(R6),R0		; Return I/O status as completion code
	BEQL	30$			; If zero, then I/O not really done
					; Event flag was set spuriously
					; Branch out of line to wait for I/O
20$:	RSB				; Return to caller


30$:	$CLREF_S	EFN=#26		; Clear the event flag and wait again
	MOVZWL	IOSB(R6),R0		; Did I/O complete while in SYS$CLREF?
	BNEQ	20$			; Simply return if it did
	$WAITFR_S	EFN=#26		; Otherwise, wait for event flag again
	BRB	10$			;  and see whether this setting of the
					;  event flag is for real
	.PAGE
	.SBTTL	AME_IMAGE, SET UP TO ACTIVATE AME
;
; AME_IMAGE - SET UP TO ACTIVATE AN APPLICATIONS MIGRATION EXECUTIVE
;	IMAGE IN RESPONSE TO A RUN COMMAND FOR A COMPATIBILITY MODE
;	PROGRAM
;
; CALLING SEQUENCE:
;
;	BRW	AME_IMAGE


;
; INPUTS:
;
;	R4 = IMAGE HEADER ADDRESS
;	R5 = FAB ADDRESS
;	R6 = IMGACT CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	     OTHERWISE IMAGE WAS NOT A KNOWN FILE
;
; OUTPUTS:
;
;	EXITS VIA BRW RSX_AME_OPEN WITH CONTEXT SET UP TO
;	ACTIVATE THE DESIRED AME
;

	.ENABLE		LOCAL_BLOCK

AME_IMAGE:
	MOVL	FAB$L_CTX(R5),CMKFIADR(R6) ;SAVE KFI ADR AND SEQUENCE NO.
	ROTL	#16,CHAN(R6),CHAN(R6)	;SAVE RSX IMAGE CHANNEL
	MOVZBL	AMECOD(R6),R0		;DESIRED AME TYPE CODE

;+
; Legal values in the next-to-last byte of the image header are 0, 1, or 2.
;
;	Last-1 = 0 => activate RSX.EXE	(if last NEQ 0, then error)
;	Last-1 = 1 => activate BPA.EXE	(if last NEQ 0, then error)
;	Last-1 = 2 => the name of the image to activate is contained in the 
;			last 128 bytes of the first block of the image header
;			(excluding the final two bytes)
;-

	CASE	R0,-			;DISPATCH ON AME TYPE
		<10$,-			;STORE NAME OF RSX.EXE FOR TYPE 0
		 10$,-			;STORE NAME OF BPA.EXE FOR TYPE 1
		 30$>			;HEADER CONTAINS IMAGE NAME FOR TYPE 2
	BRW	40$			;ANYTHING ELSE IS AN ERROR

10$:	TSTB	AMECOD+1(R6)		;ANYTHING BUT ZERO HERE IS AN ERROR
	BNEQ	40$
	MOVAL	B^AME_NAM[R0],R0	;ADDRESS OF ASCIC AME NAME
20$:	MOVB	(R0)+,FAB$B_FNS(R5)	;SIZE OF AME NAME STRING
	BEQL	40$			;ZERO IS ILLEGAL
	MOVL	R0,FAB$L_FNA(R5)	;ADDRESS OF AME NAME STRING
	MOVAL	B^RSX_AME_DNAM,FAB$L_DNA(R5) ;DEFAULT NAME ADDRESS
	MOVB	#RSX_AME_DSIZ,FAB$B_DNS(R5) ;DEFAULT NAME SIZE

	BICL	#^C<IAC$M_NOACT>,IACFLG(R6) ;CLEAN START FOR AME ACTIVATION
	CLRW	KFIFLG(R6)		;NO KNOWN FILE ATTRIBUTES
	PUSHR	#^M<R4,R5>		;SAVE REGISTERS
	MOVZBL	RSLTNAME(R6),R0		;GET SIZE OF RESULTANT NAME STRING
	INCL	R0			;ADD ONE FOR THE COUNT BYTE
	MOVC3	R0,RSLTNAME(R6),-	;MOVE THE RESULTANT NAME STRING INTO
		@#CTL$AG_CMEDATA	;PLACE FOR AME'S USE
	POPR	#^M<R4,R5>		;RESTORE REGISTERS
	BRW	RSX_AME_OPEN		;OPEN THE RSX AME


AME_NAM:				;4 BYTES EACH (COUNT, AND ASCII)
	.ASCIC	/RSX/			;0 = RSX AME
	.ASCIC	/BPA/			;1 = BPA AME (BASIC PLUS)

RSX_AME_DNAM:
	.ASCII	/SYS$SYSTEM:.EXE/
	RSX_AME_DSIZ=.-RSX_AME_DNAM

	TYPE_2_NAM_SIZ = 128		;RESERVE 128 BYTES FOR .ASCIC NAME

;+
; If the next-to-last byte of the image header contains a 02 and the
; last byte contains a 0, then the last 128 bytes of the first block of
; the image header contain the counted ASCII name of the native image to
; activate. The name of the image passed to the image activator is
; stored as a counted ASCII string at location CTL$AG_CMEDATA. 
;-

30$:	TSTB	AMECOD+1(R6)		;LAST BYTE MUST BE ZERO
	BNEQ	40$			;ILLEGAL IF NOT 0
	MOVAB	<512-TYPE_2_NAM_SIZ>(R4),R0	;POINT R0 TO IMAGE NAME IN IMAGE HEADER
	CMPB	(R0),#<TYPE_2_NAM_SIZ-3>	;CHECK FOR LEGAL NAME SIZE
					; 1-BYTE COUNT, 2-BYTE AME CODE
	BLEQU	20$			;BRANCH IF LENGTH OK

40$:	BRW	BADIMGHDR		;REPORT "BAD IMAGE HEADER" ERROR

	.DISABLE	LOCAL_BLOCK

	.PAGE
	.SBTTL	KFI_LOCKR, KFI_LOCK_MTX
;
; KERNEL MODE ROUTINE FOR LOCKING THE KNOWN FILE MUTEX FOR READING OR WRITING
;	THIS ROUTINE CALLS ITS CALLER AS A COROUTINE SUCH THAT WHEN
; THAT ROUTINE RETURNS VIA AN RSB, THE MUTEX IS UNLOCKED AND THIS ROUTINE
; THEN RETURNS WITH AN RSB TO THE CALLERS' CALLER.  E.G.
;
; THIS ROUTINE CALLED VIA BSB
;
;	...
;	...
;
;	BSBW	KFI_LOCKR
;
;	OR
;
;	BSBW	KFI_LOCKW
;
; PROCESS UNDER THE PROTECTION OF THE WRITE MUTEX
;
;	...
;	...
;
; RETURN TO UNLOCK MUTEX WITH R0 = STATUS CODE.  RETURN IS THEN MADE
; VIA RSB TO THIS ROUTINE'S CALLER.
;
;	RSB
;
; CALLING SEQUENCE:
;
;	BSBW	KFI_LOCKR
;	BSBW	KFI_LOCKW
;
; INPUTS:
;
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;
KFI_LOCKR:
	MOVAL	G^SCH$LOCKR,R2		;ADDRESS OF LOCK FOR READING ROUTINE
;
; ENTER HERE WITH R2 = ADDRESS OF LOCK ROUTINE
;
KFI_LOCK_MTX:
	POPR	#^M<R1>			;PICK UP RETURN ADDRESS
	MOVAL	G^EXE$GL_KFIMTX,R0	;ADDRESS OF KNOWN FILE MUTEX
	PUSHL	R0			;SAVE MUTEX ADDRESS
	PUSHAL	B^20$			;CALLER WILL RSB TO HERE
	PUSHL	R1			;CALLER'S ADDRESS TO CALL BACK
	JMP	(R2)			;LOCK THE MUTEX AND RETURN TO
					;THIS ROUTINE'S CALLER AT IPL=ASTDEL
;
; UNLOCK THE MUTEX NOW AND RETURN TO CALLER'S CALLER.
; R0 = SYSTEM STATUS CODE
; R4 = PROCESS CONTROL BLOCK ADDRESS
;
20$:	PUSHL	R0			;SAVE STATUS CODE
	MOVL	4(SP),R0		;MUTEX ADDRESS
	JSB	G^SCH$UNLOCK		;UNLOCK THE KNOWN FILE MUTEX
	SETIPL	#0			;BACK TO IPL 0
	POPR	#^M<R0,R1>		;RECOVER STATUS, CLEAN OFF MUTEX ADDRESS
	RSB				;AND RETURN
	.PAGE
	.SBTTL	KFI_INCREF - INCREMENT KFI REFERENCE COUNT
;
;	INCREMENT KNOWN FILE ENTRY REFERENCE COUNT THUS LOCKING THE ENTRY FROM
; DELETION WHILE IT IS IN USE BY THE IMAGE ACTIVATOR.  IT WILL BE UNLOCKED
; AT THE COMPLETION OF THE IMAGE ACTIVATION.  LOCKING THE ENTRY THIS WAY
; MAKES IT UNNECESSARY TO HOLD A MUTEX FOR THE ENTIRE IMAGE ACTIVATION, WHICH
; WOULD HAVE REQUIRED RUNNING ENTIRELY IN KERNEL MODE.
;
;	UNDER THE PROTECTION OF THE READ MUTEX THIS ROUTINE VERIFIES THAT
; THE KNOWN FILE ENTRY ADDRESS AND THE SEQUENCE NUMBER BITS IN THE LOW BITS
; OF THE ADDRESS STILL AGREE.  THE ENTRY MIGHT HAVE BEEN DELETED FROM THE
; KNOWN FILE QUEUE AFTER IT WAS FOUND BY THE KNOWN FILE SCAN IN RMS OPEN
; BUT BEFORE THE IMAGE ACTIVATOR COULD LOCK THE ENTRY.
;
;	THE SEQUENCE NUMBER CHECK BEING PERFORMED DEPENDS UPON THE FACT
; THAT DELETED ENTRIES ARE PLACED ON A FREE LIST FOR KNOWN FILE ENTRIES
; RATHER THAN BEING RELEASED TO DYNAMIC POOL.  THIS IS KEY SINCE ONCE RELEASED
; TO POOL, A KNOWN FILE ENTRY COULD BE ALIASED (MALICIOUSLY OR OTHERWISE)
; WITH POSSIBLY SERIOUS EFFECTS ON THE IMAGE ACTIVATOR.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
KFI_INCREF:
	BSBB	KFI_LOCKR		;COROUTINE CALL TO LOCK KFI MUTEX FOR READING
	BICB	#KFI$M_KFISEQ,R7	;CLEAR SEQUENCE NUMBER BITS IN KFIADR
	XORB3	KFIADR(R6),KFI$B_KFISEQ(R7),R0 ;CHECK THAT SEQUENCE BITS
	BITB	#KFI$M_KFISEQ,R0	;ARE THE SAME AS IN THE KFI ENTRY
	BNEQ	20$			;BRANCH IF THEY DISAGREE
	INCW	KFI$W_REFCNT(R7)	;LOCK THE KFI ENTRY AGAINST DELETION
	MOVL	R7,KFIADR(R6)		;STORE KFI ADR WITHOUT SEQUENCE BITS
	MOVZWL	S^#SS$_NORMAL,R0	;SUCCESSFUL RETURN
	RSB
;
; MAKE IT APPEAR AS IF NO KNOWN FILE ENTRY WAS FOUND AND RETRY THE IMAGE ACTIVATION
;
20$:	CLRL	KFIADR(R6)		;NO KNOWN FILE ENTRY
	BRW	KRNL_RETRY_RSB		;SET RETRY, AND RETURN ERROR
	.PAGE
	.SBTTL	OPEN_DONE_KRNL
;
; THIS ROUTINE IS CALLED IN KERNEL MODE AFTER THE FILE IS OPENED
; (NOT NECESSARILY SUCCESSFULLY) IN ORDER TO FIND OUT IF THE FILE
; IS EXECUTE ONLY AND IN ORDER TO INCREMENT THE KNOWN FILE REFERENCE COUNT
; IF THIS IS A KNOWN FILE
;
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
OPEN_DONE_KRNL:
	MOVZWL	CHAN(R6),R0		;CHANNEL IF FILE WAS OPENED
	JSB	G^IOC$VERIFYCHAN	;VERIFY CHANNEL, RETURN CCB ADR
	BLBC	R0,20$			;BRANCH IF CHANNEL NO GOOD
	MOVL	CCB$L_WIND(R1),R0	;GET FILE WINDOW IF OPENED OK
	BGEQ	20$			;BRANCH IF NO WINDOW
	CMPB	#DYN$C_WCB,WCB$B_TYPE(R0) ;IS THIS REALLY A WCB?
	BNEQ	20$			;SKIP PROTECTION CHECK IF NOT
	MOVL	WCB$L_FCB(R0),R0	;GET FILE CONTROL BLOCK ADDRESS
	BEQL	20$			;BRANCH IF "NOT_FCP_WINDOW"
	MOVZWL	B^FCB$W_FILEPROT(R0),R1	;PROTECTION WORD
	MOVL	B^FCB$L_FILEOWNER(R0),R2 ;AND OWNER OF THE FILE
	MOVL	W^PCB$L_ARB(R4),R0	;GET ACCESS RIGHTS BLOCK
	JSB	G^EXE$CHKRDACCES	;SEE IF FILE MAY BE READ
	BLBS	R0,20$			;BRANCH IF FILE IS READABLE
	BBSS	#IFD$V_EXEONLY,IFDFLAGS(R6),20$ ;NOTE FILE IS EXECUTE ONLY
20$:	TSTL	R7			;IF FILE IS A KNOWN FILE
	BNEQ	KFI_INCREF		;COUNT A REFERENCE FOR IT AND RETURN
	MOVL	S^#SS$_NORMAL,R0	;OTHERWISE JUST RETURN SUCCESSFULLY
	RSB
	.PAGE
	.SBTTL	KFI_DECREF
;
; EXEC MODE ROUTINE TO DECREMENT THE KNOWN FILE REFERENCE COUNT
;
; CALLING SEQUENCE:
;
;	BSBW	KFI_DECREF
;
; INPUTS:
;
;	R6 = ADDRESS OF IMAGE ACTIVATOR CONTEXT AREA
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;

	.ENABL	LSB

KFI_DECREF:
	TSTL	R7
	BGEQ	10$			;BRANCH IF NOT A KNOWN FILE
	MOVAL	W^KRNL_KFI_DECREF,KRNLROUT(R6) ;DEC REFCNT IN KERNEL MODE
;
; FALL THRU TO CMKRNL
;
	.PAGE
	.SBTTL	CMKRNL - CALL A ROUTINE IN KERNEL MODE
;
; EXEC MODE ROUTINE TO CALL A DESIRED ROUTINE IN KERNEL MODE
;
; CALLING SEQUENCE:
;
;	BSBW	CMKNRL
;
; INPUTS:
;
;	KRNLARG(R6) = ARGUMENT LIST TO BE PASSED TO THE DISPATCHER BELOW
;
CMKRNL:
	$CMKRNL_S B^KRNL_DISPAT,KRNLARG(R6) ;CALL THE DIPATCHER IN KERNEL MODE
10$:	RSB

	.DSABL	LSB
	.PAGE
	.SBTTL	KRNL_DISPAT - KERNEL MODE DISPATCHER
;
; KERNEL MODE ROUTINE TO DISPATCH TO DESIRED ROUTINE
;
; CALLING SEQUENCE:
;
;	CALLG	KRNL_DISPAT,ARGLIST
;
; INPUTS:
;
;	 4(AP) = SUBROUTINE TO CALL WITH JSB
;	 8(AP) = ADDRESS OF IMAGE ACTIVATOR CONTEXT AREA
;	12(AP) = KNOWN FILE ENTRY ADDRESS IF NON-ZERO
;	R4     = PROCESS CONTROL BLOCK ADDRESS FROM CHANGE MODE TO KERNEL DISPATCHER
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;
KRNL_DISPAT:
	.WORD	^M<R2,R3,R6,R7>
	MOVQ	8(AP),R6		;R6 = ADR OF CONTEXT AREA
					;R7 = KNOWN FILE ENTRY ADR IF NEGATIVE
	JSB	@4(AP)			;CALL DESIRED KERNEL MODE ROUTINE
	RET				;AND RETURN TO EXEC MODE
	.PAGE
	.SBTTL	SETCTLREG
;
; KERNEL MODE ROUTINE FOR SETTING UP THE USER STACK AND PROCESS PRIVILEGE MASK
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;

	.ENABL	LSB

2$:	BITL	S^#<<1 @ PRV$V_CMKRNL> ! - ;ANY CMKRNL OR CMEXEC
		    <1 @ PRV$V_CMEXEC>>,R0 ;TO BE TURNED OFF?
	BNEQ	4$			;BRANCH IF YES
	BBSC	#IAC$V_NOCMKRNL,IACFLG(R6),16$ ;NO, NOTE THAT IT WASN'T DONE
4$:	BICL	S^#<<1 @ PRV$V_CMKRNL> ! - ;YES, TURN OFF CMKRNL PRIVILEGE
		    <1 @ PRV$V_CMEXEC>>,R0 ;AND CMEXEC PRIVILEGE
	BRB	16$

SETCTLREG:
	JSB	IAC$CLRIACLOCK		;CLEAR IMAGE ACTIVATOR LOCK IF SET
	BBS	#IAC$V_SHAREABLE,IACFLG(R6),KFI_MAK_SHR_RES ;BR IF NOT EXECUTABL
	BBS	#IAC$V_MERGE,IACFLG(R6),KFI_MAK_SHR_RES ;BR IF MERGING IN IMAGE
	MOVL	USRSTACKADR(R6),R0	;USER STACK ADDRESS IF SPECIFIED
10$:	MOVL	R0,@#CTL$AL_STACK+<PSL$C_USER*4> ;SET USER STACK ADR IN CTRL REGION
	SUBL	G^SGN$GL_EXUSRSTK,R0	;RESERVE SAFETY AREA
	MTPR	R0,S^#PR$_USP		;SET PROCESSOR REGISTER
	MOVQ	@#CTL$GQ_PROCPRIV,R0	;GET PROCESS DEFAULT PRIVILEGES
	MOVQ	IMAGEPRIV(R6),R2	;GET PRIVILEGES FROM IMAGE HEADER
	MCOML	R2,R2			;NOW DO A MCOML AND BICL COMBINATION
	BICL	R2,R0			;TO AND THE PROCESS'S PRIVILEGES WITH
	MCOML	R3,R3			;THE PRIVILEGES FROM THE IMAGE HEADER
	BICL	R3,R1			;THUS MINIMIZING THE PRIVILEGES
	BISL	PROCPRIV(R6),R0		;ENHANCE FOR PRIVILEGED KNOWN IMAGE
	MOVL	IMGHDRBUF(R6),@#CTL$GL_IMGHDRBF ;PTR TO CUR ACTIVE IMAGE HEADER
	BISL	PROCPRIV+4(R6),R1	;
	BBS	#IAC$V_NOCMKRNL,IACFLG(R6),2$ ;BRANCH IF SYSTEM VERSIONS MISMATCH
16$:	MOVQ	R0,PCB$Q_PRIV(R4)	;SET NEW PRIVILEGES IN PCB
	MOVL	@#CTL$GL_PHD,R2		;GET ADR OF PROCESS HEADER
	MOVQ	R0,PHD$Q_PRIVMSK(R2)	;STORE PRIVILEGE MASK FOR PROCESS
	MOVQ	PROCPRIV(R6),PHD$Q_IMAGPRIV(R2) ;STORE PRIVILEGE MASK FOR IMAGE
KFI_MAK_SHR_RES:
	TSTL	R7			;KNOWN FILE?
	BGEQ	60$			;BRANCH IF NO
	BBC	#KFI$V_KP_SHARED,KFIFLG(R6),20$ ;BRANCH IF NOT SUPPOSED TO BE SHARED
	BBS	#KFI$V_IS_SHARED,KFIFLG(R6),20$ ;BRANCH IF ALREADY MADE SHARED

	ASSUME	KFI$L_IDENT EQ KFI$B_MATCHCTL+4
	MOVQ	KFIMATCHCTL(R6),KFI$B_MATCHCTL(R7) ;SAVE GLOBAL SECTION MATCH
					;CONTROL FOR DELETE GLOBAL SECTION LOGIC
	MOVW	GBLSECCNT(R6),KFI$W_GBLSECCNT(R7) ;SET COUNT OF GLOBAL SECTIONS
	BBS	#IAC$V_NOTSHARED,IACFLG(R6),20$ ;DON'T SET IS_SHARED IF
					;ONE OR MORE GLOBAL SECTIONS
					;FAILED TO BE CREATED.
	BBSSI	#KFI$V_IS_SHARED,KFI$W_FLAGS(R7),20$ ;KNOWN FILE IS SHARED NOW
20$:	BBC	#IAC$V_KP_RESHDR,IACFLG(R6),40$ ;BRANCH IF NOT MAKING IMG HDR RESIDENT
	BSBW	KRNL_MAK_RESHDR		;MAKE IMAGE HEADER RESIDENT
	JSB	IAC$CLRIACLOCK		;CLEAR IMAGE ACTIVATOR LOCK
					;R4 MUST BE PROCESS CONTROL BLOCK ADR
40$:	BBC	#IAC$V_LIM,IACFLG(R6),50$ ;BRANCH IF NOT LINKABLE IMAGE
	BBSSI	#KFI$V_LIM,KFI$W_FLAGS(R7),50$ ;KFI ENTRY IS FOR LINKABLE IMAGE
50$:	BBC	#IAC$V_SHMIDENT,IACFLG(R6),55$ ;BR IF NO SHM IDENT COMPUTED
	BBSS	#KFI$V_SHMIDENT,KFI$W_FLAGS(R7),55$ ;SET SHM IDENT USED
55$:
;
; FALL THROUGH TO KRNL_KFI_DECREF
;
	.PAGE
	.SBTTL	KRNL_KFI_DECREF
;
; KERNEL MODE ROUTINE TO DECREMENT THE KNOWN FILE REFERENCE COUNT
; ***** THE FOLLOWING ALTERATIONS ARE MADE TO THE KNOWN FILE ENTRY
; ***** WITHOUT THE PROTECTION OF A MUTEX AND ARE ONLY PROPERLY INTERLOCKED
; ***** IN A SINGLE PROCESSOR SYSTEM.  A READ MUTEX IS REQUIRED TO MAKE
; ***** THIS CODE WORK CORRECTLY FOR A SYMMETRIC MULTI-PROCESSING SYSTEM.
;
;	THE REFERENCE COUNT LOGIC WORKS AS FOLLOWS.  IN THE KNOWN FILE
; SCANNER, THE KNOWN FILE ENTRY ADDRESS IS STORED IN FAB$L_CTX WITH THE
; TWO LOW ORDER BITS OF KFI$B_KFISEQ.  WHEN THE IMAGE ACTIVATOR REGAINS 
; CONTROL AFTER THE $OPEN AND FAB$L_CTX IS NON-ZERO, IT GRABS THE READ 
; MUTEX IN ORDER TO BUMP THE REFCNT THUS PROTECTING THE KNOWN FILE ENTRY
; FROM SUBSTANTIVE CHANGE.  IN ORDER TO CLOSE THE WINDOW BETWEEN THE KNOWN
; FILE SCANNER STORING THE KFI ENTRY ADDRESS AND THE IMAGE ACTIVATOR 
; LOCKING THE KNOWN FILE ENTRY, A SEQUENCE NUMBER FIELD IS MAINTAINED
; IN THE KNOWN FILE ENTRY.  AFTER GRABBING THE READ MUTEX THE SEQUENCE 
; BITS IN FAB$L_CTX ARE COMPARED WITH KFI$B_KFISEQ.  IF THEY DON'T AGREE
; THEN THE KNOWN FILE ENTRY WAS DELETED AND POSSIBLY REUSED.  IT WOULD
; TAKE 4 SUCH CYCLES TO FOUL UP THE SEQUENCE CHECK AND 2 RATHER STRETCHES
; THE IMAGINATION.  IT IS KEY TO THIS DESIGN THAT THE KNOWN FILE ENTRIES
; ARE NEVER RETURNED TO PAGED POOL BUT INSTEAD ARE KEPT ON A KNOWN FILE
; ENTRY FREE LIST.  THIS IS THE ONLY WAY THAT THE SEQUENCE NUMBER BEHAVES
; PROPERLY.  A UTILITY MIGHT BE ABLE TO MOVE THEM FROM THE FREE LIST TO
; PAGED POOL, BUT THE IMAGE ACTIVATOR CANNOT DO IT ON THE FLY.  AT THE 
; COMPLETION OF THE IMAGE ACTIVATION (SUCCESSFULLY OR NOT) THE REFCNT
; IS DECREMENTED, RELEASING THIS PROCESS' REQUIREMENT THAT THE KNOWN 
; FILE ENTRY REMAIN STABLE.
;
;	THE COUNTER IS BIASED BY 1 FOR THE EXISTENCE OF THE KNOWN FILE ENTRY
; ON THE KNOWN FILE QUEUE, SO IT CAN NEVER REACH ZERO UNLESS THE KNOWN
; FILE ENTRY HAS BEEN "DELETED".  THE DELETE OPERATION MERELY REMOVES THIS
; BIAS FROM THE REFCNT, REMOVES THE ENTRY FROM THE "ACTIVE" KNOWN FILE LIST
; AND QUEUES IT ON THE DELETE PENDING LIST.  ONLY IF THE ENTRY IS ON THE
; DELETE PENDING LIST (WHERE THE KNOWN FILE SCANNER WILL NOT FIND IT), CAN
; THE FOLLOWING DECREMENT TAKE THE REFERENCE COUNT TO ZERO.  IN THIS CASE
; NO OTHER PROCESS COULD POSSIBLY BE USING THE ENTRY AND IT IS THE TIME TO
; COMPLETE ITS DELETION.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NON-ZERO
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
KRNL_KFI_DECREF:
	DECW	KFI$W_REFCNT(R7)	;ONE LESS REFERENCE FOR THE KNOWN FILE ENTRY
	BLEQ	80$			;BRANCH IF READY TO BE DELETED
60$:	MOVZWL	S^#SS$_NORMAL,R0	;INDICATE SUCCESS
	RSB
80$:	BRW	KFI_RELEASE		;GO RELEASE THE KNOWN FILE ENTRY


	.DSABL	LSB
	.PAGE
	.SBTTL	IMAGE ACTIVATOR INTERLOCK LOGIC

;
; THE FOLLOWING CODE IS DESIGNED TO INTERLOCK THE CREATION AND DELETION
; OF THE GLOBAL SECTIONS ASSOCIATED WITH LINKABLE (SHAREABLE) IMAGES SO
; THAT THERE IS NO RACE BETWEEN THE CREATION OF THE GLOBAL SECTIONS FOR
; A GIVEN LINKABLE IMAGE AND THE ACTIVATION OF AN IMAGE THAT REFERENCES
; THOSE GLOBAL SECTIONS.  THE GOAL IS TO GUARANTEE THAT AN IMAGE
; REFERENCING THE GLOBAL SECTIONS OF A LINKABLE IMAGE GETS ALL OF ITS
; GLOBAL SECTIONS FROM THE SAME LINKABLE IMAGE.
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
;
; LOCK THE KNOWN FILE MUTEX FOR WRITING AND GET THE IMAGE ACTIVATOR LOCK
; FOR WRITING.  WAIT FOR THE KNOWN FILE MUTEX IF BUSY.  IF IMAGE ACIVATOR
; LOCK CANNOT BE SET THEN RELEASE THE MUTEX AND WAIT FOR THE IMAGE
; ACTIVATOR LOCK.
;
; CALLING SEQUENCE:
;
;	BSBW	IAC_KFI_LOCKW		;KERNEL MODE ROUTINE
;
; INPUTS:
;
;	R0 = ADDRESS OF KNOWN FILE MUTEX
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	IPL = 0
;
; OUTPUTS:
;	
;	IPL = ASTDEL
;	KNOWN FILE MUTEX LOCKED FOR WRITING
;	MMG$IACLOCK SET TO PCB ADDRESS
;	RND$V_IACLOCK SET IN CTL$GL_RUNDNFLG
;
IAC_KFI_LOCKW:
10$:	PUSHL	R0			;SAVE ADDRESS OF KNOWN FILE MUTEX
	JSB	G^SCH$LOCKW		;LOCK THE MUTEX FOR WRITING
;
; RETURNS AT IPL=ASTDEL
;
	DSBINT	S^#IPL$_SYNCH		;STACK CURRENT IPL, RAISE TO SYNCH
	TSTL	W^MMG$GL_IACLOCK	;SEE IF LOCK IS ALREADY IN USE
	BEQL	60$			;BRANCH IF IT IS AVAILABLE
	CMPL	R4,W^MMG$GL_IACLOCK	;ALREADY LOCKED BY THIS PROCESS?
	BEQL	80$			;BRANCH IF YES
;
; CANNOT LOCK THE IMAGE ACTIVATOR LOCK, RELEASE THE KNOWN FILE MUTEX
;
	ENBINT				;BACK TO ASTDEL
	MOVL	(SP),R0			;RECOVER MUTEX ADDRESS
	JSB	G^SCH$UNLOCK		;RELEASE THE KNOWN FILE MUTEX
;
; MUST NOW WAIT FOR THE IMAGE ACTIVATOR LOCK
;
	SETIPL	S^#IPL$_SYNCH		;BACK TO SYNCH
	TSTL	W^MMG$GL_IACLOCK	;DID IT JUST BECOME AVAILABLE?
	BNEQ	40$			;BRANCH IF NOT
	SETIPL	#0			;YES, START FROM SCRATCH
30$:	POPR	#^M<R0>			;GET THE KNOWN FILE MUTEX ADDRESS
	BRB	10$			;AND GO LOCK THE MUTEX AGAIN

40$:	BSBB	WAIT_ACTIVE_LCK		;WAIT FOR IMAGE ACTIVATOR LOCK
	BRB	30$			;AND THEN START OVER

;
; IMAGE ACTIVATOR LOCK IS AVAILABLE, LOCK IT NOW
;
60$:	MOVL	R4,W^MMG$GL_IACLOCK	;RECORD PCB ADDRESS OF LOCKER
	BBSS	S^#RND$V_IACLOCK,@#CTL$GL_RUNDNFLG,80$ ;UNDO THIS IN RUNDOWN
80$:	POPR	#^M<R0,R1>		;R0=SAVED IPL, CLEAN OFF SAVED MUTEX ADR
	ENBINT	R0			;RESTORE IPL TO ASTDEL
	RSB
	.PAGE
;
; WAIT FOR IMAGE ACTIVATOR LOCK TO BECOME AVAILABLE
;
; CALLING SEQUENCE:
;
;	BSBW	WAIT_ACTIVE_LOCK	;KERNEL MODE ROUTINE
;
; INPUTS:
;
;	IPL=SYNCH
;
; OUTPUTS:
;
;	R4 = CURRENT PCB ADDRESS
;
WAIT_ACTIVE_LCK:
	MOVPSL	-(SP)
	INSV	#0,S^#PSL$V_IPL,S^#PSL$S_IPL,(SP) ;FORM PC, PSL PAIR ON STACK
	MOVZWL	S^#RSN$_IACLOCK,R0	;RESOURCE TO WAIT FOR
	JSB	G^SCH$RWAIT		;PUT THE PROCESS INTO MWAIT STATE
	RSB				;RETURN AND TRY AGAIN
	.PAGE
;
; LOCK THE IMAGE ACTIVATOR LOCK FOR READING, THUS GUARANTEEING THAT
; THE GLOBAL SECTIONS FOR A LINKABLE IMAGE WILL REMAIN CONSISTENT WHILE
; THE PROGRAM LOOPS THROUGH AND MAPS EACH ONE.
;
; CALLING SEQUENCE:
;
;	BSBW	SET_ACTIVE_LCK		;KERNEL MODE ROUTINE
;
; INPUTS:
;
;	R4 = CURRENT PROCESS CONTROL BLOCK ADDRESS
;	IPL = 0
;
; OUTPUTS:
;
;	R0 = SUCCESS STATUS
;	W^MMG$GL_IACLOCK INCREMENTED
;	RND$V_IACLOCK SET IN CTL$GL_RUNDNFLG TO MAKE SURE THAT RUNDOWN
;		WILL UNDO THIS INCREMENT.
;
SET_ACTIVE_LCK:
10$:	SETIPL	S^#IPL$_SYNCH		;RAISE IPL
	TSTL	W^MMG$GL_IACLOCK	;WRITE LOCKED?
	BLSS	30$			;BRANCH IF YES, MUST WAIT
	INCL	W^MMG$GL_IACLOCK	;RECORD ANOTHER READ LOCK
	BBSS	S^#RND$V_IACLOCK,@#CTL$GL_RUNDNFLG,20$ ;RUNDOWN SHOULD UNDO THIS
20$:	SETIPL	#0			;BACK TO IPL 0
	MOVL	S^#SS$_NORMAL,R0	;RETURN SUCCESS STATUS
	RSB
;
; SOMEONE HAS THE IMAGE ACTIVATOR LOCK WRITE LOCKED
;
30$:	CMPL	R4,W^MMG$GL_IACLOCK	;IF IT IS THIS PROCESS
	BEQL	20$			;THEN OK
	BSBB	WAIT_ACTIVE_LCK		;WAIT FOR IMAGE ACTIVATOR LOCK
	BRB	10$			;AND START OVER
	.PAGE
;
; RELEASE IMAGE ACTIVATOR LOCK
;
; CALLING SEQUENCE:
;
;	BSBW	IAC$CLRIACLOCK		;KERNEL MODE ROUTINE
;
; INPUTS:
;
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	IPL = 0
;
; OUTPUTS:
;
;	R0 = SUCCESS STATUS
;	W^MMG$GL_IACLOCK DECREMENTED IF READ LOCKED, CLEARED IF WRITE LOCKED
;	RND$V_IACLOCK CLEARED IN CTL$GL_RUNDNFLG
;
IAC$CLRIACLOCK::
	SETIPL	S^#IPL$_SYNCH		;RAISE TO SYNCH
	BBCC	S^#RND$V_IACLOCK,@#CTL$GL_RUNDNFLG,40$ ;BRANCH IF NOT LOCKED
	CMPL	R4,W^MMG$GL_IACLOCK	;WRITE LOCKED?
	BEQL	20$			;BRANCH IF YES, CLEAR THE LOCK
	DECL	W^MMG$GL_IACLOCK	;COUNT ONE LESS READ LOCK
	BRB	30$

20$:	CLRL	W^MMG$GL_IACLOCK	;CLEAR THE WRITE LOCK
30$:	BNEQ	40$			;BRANCH IF STILL READ LOCKED
	MOVZWL	S^#RSN$_IACLOCK,R0	;RESOURCE TO REPORT AVAILABLE
	JSB	G^SCH$RAVAIL		;REPORT IT AS AVAILABLE
40$:	SETIPL	#0			;BACK TO IPL 0
	MOVL	S^#SS$_NORMAL,R0	;RETURN SUCCESS STATUS
	RSB
	.PAGE
	.SBTTL	KFI_RELEASE - RELEASE THE KNOWN FILE ENTRY

	.PSECT	YF$LOWUSE

;
; KERNEL MODE ROUTINE TO COMPLETE THE DELETION OF A KNOWN FILE ENTRY 
; AFTER THE REFERENCE COUNT HAS GONE TO ZERO
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
KFI_RELEASE:
	BSBW	KFI_LOCKW		;LOCK THE KNOWN FILE MUTEX FOR WRITING
	TSTW	KFI$W_REFCNT(R7)	;RELEASE ENTRY IF STILL NOT REFERENCED
	BGTR	80$			;OTHERWISE LEAVE IT ALONE
	BBC	#KFI$V_DONOTOPEN,KFI$B_KFICTL(R7),20$ ;BRANCH IF NO WINDOW PRESENT
	MOVL	KFI$L_WINDOW(R7),R2	;GET WINDOW ADDRESS
	BGEQ	20$			;BRANCH IF NONE THERE
	DECW	WCB$W_REFCNT(R2)	;REMOVE THE BIAS FOR THE KNOWN FILE ENTRY
					;LAST DEASSIGN WILL REALLY DEACCESS THE FILE
20$:	BBC	#KFI$V_KP_SHARED,KFI$W_FLAGS(R7),40$ ;BRANCH IF NOT SHARABLE
	MOVZWL	KFI$W_GBLSECCNT(R7),R3	;GET COUNT OF SECTIONS
	BEQL	40$			;BRANCH IF NONE WERE CREATED
	BSBW	KFI_GBLSECNMINI		;INITIALIZE THE KNOW FILE GBL SECTION NAME
	MOVZBL	KFI$B_MATCHCTL(R7),KFIMATCHCTL(R6) ;GET GBL SECTION
	MOVL	KFI$L_IDENT(R7),KFIMATCHCTL+4(R6) ;MATCH CONTROL
30$:	BSBW	KFI_GBLSECNMNXT		;NEXT GLOBAL SECTION NAME
	PUSHAQ	KFIMATCHCTL(R6)		;ADDRESS OF IDENT QUAD WORD
	PUSHAQ	GSDNAMSIZ(R6)		;ADDRESS OF GLOBAL SECTION NAME DESCRIP
	MOVZWL	#<SEC$M_SYSGBL ! SEC$M_PERM ! SEC$M_GBL>,-(SP) ;FLAGS
	CALLS	#3,G^MMG$DGBLSC1	;DELETE THE GLOBAL SECTION
	SOBGTR	R3,30$			;LOOP THROUGH ALL POSSIBLE SECTIONS
40$:	BBC	#KFI$V_IS_RESHDR,KFI$W_FLAGS(R7),60$ ;BRANCH IF HEADER IS NOT RESIDENT
	SUBL3	#12,KFI$L_IMGHDR(R7),R0	;ADDRESS OF IMAGE HEADER TO RELEASE
	JSB	G^EXE$DEAPAGED		;DEALLOCATE PAGED POOL
60$:	MOVZBL	KFI$B_KFIQNUM(R7),R3	;GET KNOWN FILE QUEUE NUMBER
	MOVL	G^EXE$GL_KNOWNFIL,R0	;ADDRESS OF QUEUE HEADS
	MOVL	(R0)[R3],R3
;
;  0(R3) = ACTIVE QUEUE HEAD
;  8(R3) = DELETE PENDING QUEUE HEAD
; 16(R3) = FREE ENTRY QUEUE HEAD
;
	REMQUE	(R7),R7			;REMOVE KFI ENTRY FROM ITS CURRENT QUEUE
	INSQUE	(R7),@20(R3)		;AND PUT IT ON THE TAIL OF THE FREE ENTRY QUEUE
80$:	MOVZWL	S^#SS$_NORMAL,R0	;SET SUCCESSFUL RETURN STATUS
	RSB				;AND RETURN
	.PAGE
	.SBTTL	SET/ZERO_FID, KFI_LOCKW

	.PSECT	YF$LOWUSE

;
; EXEC MODE ROUTINE TO ZERO THE FILE ID IN KNOWN FILE ENTRY
;
; CALLING SEQUENCE:
;
;	BSBW	ZERO_FID
;
; INPUTS:
;
;	R6 = ADDRESS OF CONTEXT AREA
;
ZERO_FID:
	MOVAL	B^KRNL_ZERO_FID,KRNLROUT(R6) ;ZERO FILE ID IN KERNEL MODE
	BRW	CMKRNL
	.PAGE
	.SBTTL	KRNL_SET_FID - SET FID IN KNOWN FILE ENTRY
;
; KERNEL MODE ROUTINES TO SET AND CLEAR FILE ID IN THE KNOWN FILE ENTRY
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
KRNL_SET_FID:
	BSBB	KFI_LOCKW		;COROUTINE CALL TO LOCK MUTEX FOR WRITING
;
; KNOWN FILE SCANNER SHOULD CAUSE THIS FILE TO BE OPENED BY FILE ID.
;
	BBSS	#KFI$V_FILIDOPEN,KFI$B_KFICTL(R7),40$ ;SET TO OPEN BY FILE ID
					;BRANCH IF ALREADY OPENING BY FILE ID
	MOVQ	NAM$W_FID+NAM(R6),KFI$W_FID(R7) ;SET FILE ID TO USE
	MOVZWL	S^#SS$_NORMAL,R0	;INDICATE SUCCESSFUL RETURN
	RSB
;
; THIS IS THE CASE OF A SECOND PROCESS TRYING TO SET UP THE KNOWN FILE
; ENTRY FOR OPENING BY FILE ID.  2 OR MORE PROCESSES MADE IT THROUGH THE
; FULL OPEN BY FILE NAME LOGIC BEFORE ANY OF THEM COULD SET UP FOR FILE ID
; OPEN.  SINCE IT IS POSSIBLE THAT THE OPENS WERE ACTUALLY FOR DIFFERENT FILES
; IT IS NECESSARY TO FORCE THIS CALLER THROUGH THE ERROR EXIT PATH AND
; CAUSE A FULL RETRY.
;
40$:	BRW	KRNL_RETRY_RSB
	.PAGE
	.SBTTL	KRNL_ZERO_FID - ZERO FID IN KNOWN FILE ENTRY
;
; KERNEL MODE ROUTINE TO ZERO THE FILE ID IN THE KNOWN FILE ENTRY
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
KRNL_ZERO_FID:
	BSBB	KFI_LOCKW		;COROUTINE CALL TO LOCK MUTEX FOR WRITING
	BICB	#KFI$M_FILIDOPEN,KFI$B_KFICTL(R7) ;STOP OPENING BY FILE ID
	CLRQ	KFI$W_FID(R7)		;ZERO THE FILE ID
	MOVZWL	S^#SS$_NORMAL,R0	;SUCCESSFUL RETURN
	RSB
;
; ENTRY POINT TO LOCK THE KNOWN FILE MUTEX FOR WRITING
;
KFI_LOCKW:
	MOVAL	IAC_KFI_LOCKW,R2	;ADDRESS OF LOCK ROUTINE
	BRW	KFI_LOCK_MTX		;JOIN KFI_LOCK CODE
	.PAGE
	.SBTTL	MARKED_FOR_DEL, MAKE_SHARED_WCB

	.PSECT	YF$LOWUSE
;
; KERNEL MODE ROUTINE TO PUT A WINDOW INTO THE KNOWN FILE ENTRY AND THUS
; AVOID ALL SUBSEQUENT OPENS FOR THIS FILE.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;

	.ENABL	LSB

MARKED_FOR_DEL:
	BSBB	KFI_LOCKW		;LOCK KNOWN FILE MUTEX FOR WRITING
	BRB	60$			;MARK THE KFI ENTRY FOR DELETION

MAKE_SHARED_WCB:
	BSBB	KFI_LOCKW		;LOCK THE KNOWN FILE MUTEX FOR WRITING
	MOVZWL	CHAN(R6),R0		;CHANNEL ON WHICH FILE IS OPEN
	JSB	G^IOC$VERIFYCHAN	;VERIFY IT AND RETURN CCB ADR IN R1
	BLBC	R0,40$			;BRANCH IF BAD CHANNEL
;
; NOW SET THE "DONOTOPEN" BIT IN KFICTL SO THAT SUBSEQUENT KNOWN FILE
; OPENS WILL BYPASS OPENING THE FILE AND RETURN RMS$_KFF
; IT IS POSSIBLE THAT AT THIS POINT THE "DONOTOPEN" BIT IS ALREADY
; SET.  THIS WOULD HAPPEN IF 2 OR MORE PROCESSES ARE TRYING TO ACTIVATE 
; THIS IMAGE FILE.  EACH GOT THE FILE OPEN INDIVIDUALLY AND EACH TRIED TO
; CALL THIS ROUTINE TO ENHANCE THE KNOWN FILE ENTRY.  THE FIRST ONE
; ENHANCED THE ENTRY, THE OTHERS WILL BACK ALL THE WAY OUT, CLOSE THE FILE
; AND RETRY THE IMAGE ACTIVATION FROM THE TOP.
;
	BBSS	#KFI$V_DONOTOPEN,KFI$B_KFICTL(R7),100$ ;SET INDICATOR THAT FILE
					;IS ALREADY OPEN, BRANCH IF ALREADY SET
	MOVL	CCB$L_WIND(R1),R2	;GET FILE WINDOW ADDRESS FROM CHANNEL
	BBSS	#WCB$V_SHRWCB,WCB$B_ACCESS(R2),20$ ;MAKE WINDOW SHARED
					;BRANCH IF IT ALREADY IS
	MOVL	R2,R0			;GET WINDOW ADDRESS
	JSB	G^MMG$RET_BYT_QUOTA	;RESTORE BYTCNT QUOTA TO FILE OWNER
20$:	MOVL	R2,KFI$L_WINDOW(R7)	;PUT WCB POINTER IN KNOWN FILE ENTRY
	INCW	WCB$W_REFCNT(R2)	;COUNT A 2ND REF FOR THE KNOWN FILE ENTRY
	MOVL	WCB$L_FCB(R2),R0	;FILE CONTROL BLOCK ADDRESS
	BEQL	30$			;BRANCH IF NOT AN FCP WINDOW
	BBS	S^#FCB$V_MARKDEL,B^FCB$W_STATUS(R0),60$
					;BRANCH IF FILE IS MARKED FOR DELETE
30$:	MOVZWL	S^#SS$_NORMAL,R0	;SUCCESSFUL COMPLETION STATUS
40$:	RSB
;
; MUST DELETE THIS KNOWN FILE ENTRY AND MAKE ANOTHER
;
60$:	MOVZBL	KFI$B_KFIQNUM(R7),R3	;WHICH KNOWN FILE QUEUE IS THIS ENTRY ON
	MOVL	G^EXE$GL_KNOWNFIL,R0	;ADDRESS OF QUEUE HEADS
	MOVL	(R0)[R3],R3		; FOR THIS KNOWN FILE QUEUE
;
;  0(R3) = ACTIVE QUEUE HEADER
;  8(R3) = DELETE PENDING QUEUE HEADER
; 16(R3) = FREE ENTRY QUEUE HEADER
;
	BBS	#KFI$V_NOREPLACE,KFI$B_KFICTL(R7),80$ ;BRANCH IF DELETE NOT REPLACE
	REMQUE	@16(R3),R0		;GET A FREE ENTRY TO USE
	BVS	30$			;BRANCH IF NONE AVAILABLE
					;IGNORE THE DELETE PENDING
	CVTBL	KFI$B_KFISEQ(R0),-(SP)	;SAVE SEQUENCE NUMBER OF NEW ENTRY
	PUSHR	#^M<R0,R3,R4,R5>	;SAVE THESE FROM MOVC
	MOVC3	KFI$W_SIZE(R7),(R7),(R0) ;COPY THE KNOWN FILE ENTRY
	POPR	#^M<R0,R3,R4,R5>	;RESTORE SAVED REGISTERS
	CVTLB	(SP)+,KFI$B_KFISEQ(R0)	;RESTORE SEQUENCE NUMBER OF NEW ENTRY
	BICB	#<KFI$M_FILIDOPEN !-	;ALL KFI ENTRY ENHANCEMENTS
		KFI$M_DONOTOPEN !-	;WILL BE DONE ON THE FIRST
		KFI$M_NOREPLACE ! -
		KFI$M_MARKDEL>,KFI$B_KFICTL(R0) ;ACTIVATION OF THE IMAGE
	MOVW	#1,KFI$W_REFCNT(R0)	;1 REFERENCE FOR THE KFI ENTRY ITSELF

	ASSUME	KFI$W_GBLSECCNT EQ KFI$W_FLAGS+2
	MOVZBL	KFI$W_FLAGS(R0),KFI$W_FLAGS(R0) ;HIGH BYTE OF FLAGS CONTAINS
					;ONLY THE DYNAMIC BITS
					;ALSO ZERO GBLSECCNT

	ASSUME	KFI$L_IMGHDR EQ KFI$L_WINDOW+4
	CLRQ	KFI$L_WINDOW(R0)	;NO OPEN CONTEXT YET
	INSQUE	(R0),@KFI$L_KFIQBL(R7)	;PUT THIS ENTRY IN THE ACTIVE LIST
80$:
	REMQUE	(R7),R7			;REMOVE THE KFI ENTRY FROM THE ACTIVE QUEUE
	DECW	KFI$W_REFCNT(R7)	;REMOVE BIAS FROM REFCNT
	INCB	KFI$B_KFISEQ(R7)	;ALTER SEQUENCE NUMBER OF DELETED ENTRY
					;WHERE THE OLD ENTRY WAS.
	INSQUE	(R7),8(R3)		;PLACE DELETED ENTRY ON DELETE PENDING QUEUE
KRNL_RETRY_RSB:

	ASSUME	IAC$V_RETRY GE 8
	ASSUME	IAC$V_RETRY LE 15
100$:	BISB	#IAC$M_RETRY@-8,IACFLG+1(R6) ;INDICATE THAT IMAGE ACTIVATION SHOULD
					;BE RESTARTED FROM THE BEGINNING
	CLRL	R0			;AFTER A FULL ERROR EXIT CLEANUP
	RSB

	.DSABL	LSB
	.PAGE
	.SBTTL	KRNL_MAK_RESHDR, KFI_COMPAT_MODE
;
; KERNEL MODE ROUTINE TO MAKE AN IMAGE HEADER RESIDENT
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;	IOSB(R6) = ADDRESS OF END OF IMAGE HEADER
;	IOSB+4(R6) = ADDRESS OF BEGINNING OF IMAGE HEADER
;
KRNL_MAK_RESHDR:
	BSBW	KFI_LOCKW		;LOCK THE MUTEX FOR WRITING
					;CO-ROUTINE CALL BACK
					;RSB TO UNLOCK AND RETURN TO CALLER
	BBS	#KFI$V_IS_RESHDR,KFI$W_FLAGS(R7),20$ ;BRANCH IF ALREADY RESIDENT
	SUBL3	IOSB+4(R6),IOSB(R6),R1	;SIZE OF IMAGE HEADER
	ADDL	#<KFH$C_LENGTH+4>,R1	;3 LONG WORDS OVERHEAD AT BEGINNING
					;FOR DYNAMIC STRUCTURE FORMAT
					;1 LONG WORD AT END TO INCLUDE
					;STOPPER FOR THE IMAGE HEADER
	PUSHL	R1			;SAVE SIZE TO ALLOCATE
	JSB	G^EXE$ALOPAGED		;ALLOCATE FROM PAGED POOL
	POPR	#^M<R1>			;RECOVER SIZE TO BE ALLOCATED
	BLBC	R0,40$			;BRANCH IF FAILED

	ASSUME	KFH$L_BUFEND EQ 0
	ASSUME	KFH$L_KFIADR EQ 4
	ASSUME	KFH$C_LENGTH EQ 12
	ADDL3	R1,R2,(R2)+		;STORE ADDRESS OF END OF HEADER
					;IN THE FIRST LONG WORD
	MOVL	R7,(R2)+		;KFI ENTRY ADDRESS IN 2ND LONG WORD
	MOVW	R1,(R2)+		;SIZE OF KNOWN FILE HEADER
	MOVZBW	S^#DYN$C_KFH,(R2)+	;TYPE OF DYNAMIC DATA
	MOVL	R2,KFI$L_IMGHDR(R7)	;ADDRESS OF KNOWN FILE HEADER
	SUBL	#KFH$C_LENGTH,R1	;SIZE OF HEADER TO MOVE
	PUSHR	#^M<R4,R5>		;SAVE THESE FROM MOVC
	MOVC3	R1,@IOSB+4(R6),(R2)	;MOVE THE HEADER TO KNOWN FILE HEADER
	POPR	#^M<R4,R5>		;RESTORE REGISTERS
	BBSSI	#KFI$V_IS_RESHDR,KFI$W_FLAGS(R7),20$ ;HEADER IS RESIDENT NOW
20$:	MOVZWL	S^#SS$_NORMAL,R0	;SUCCESSFUL RETURN INDICATION
40$:	RSB
;
; EXEC MODE ROUTINE TO DO THE KNOWN FILE ENHANCEMENT OF A COMPATIBILITY MODE IMAGE.
;
KFI_COMPAT_MODE:
	MOVAB	B^10$,KRNLROUT(R6)	;ADDRESS OF KERNEL MODE ROUTINE
	BRW	CMKRNL			;CALL THE FOLLOWING IN KERNEL MODE
	.PAGE
;
; KERNEL MODE ROUTINE TO DO THE KNOW FILE ENHANCEMENT OF A COMPATIBLITY MODE IMAGE
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NEGATIVE
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
10$:	BBC	#KFI$V_KP_SHARED,KFIFLG(R6),50$ ;BRANCH IF NOT SUPPOSED TO BE SHARED
	TSTL	AMECOD(R6)		;IF OTHER THAN RSX AME
	BNEQ	45$			;THEN NO SHARING
;
; COMPATIBILITY MODE SHARED KNOWN FILE
;
	BBCCI	#KFI$V_KP_RESHDR,KFI$W_FLAGS(R7),40$ ;MAY NOT KEEP HEADER RESIDENT
40$:	BSBW	KFI_GBLSECNMINI		;INIT FOR GLOBAL SECTION NAME
	BSBW	KFI_GBLSECNMNXT		;FORM NEXT/FIRST GLOBAL SECTION NAME
	MOVL	#ISD$K_MATEQU,KFIMATCHCTL(R6) ;IDENT WILL BE MATCH EQUAL
	MOVL	FAB+FAB$L_CTX(R6),KFIMATCHCTL+4(R6) ;ON KFIADR ! SEQUENCE NO.
	MOVAB	FIRSTHDR(R6),R4		;ADDRESS OF COMPAT MODE LABEL BLOCK
	BSBW	KFI_SHMIDENTINI		;INITIALIZE SHARED MEMORY IMAGE IDENT
	BLBS	R0,42$			;BR IF LOG NAM TRANS SUCCESSFUL
	BRW	140$			;BR IF LOG NAM TRANS ERROR


;
; SEE IF COMPATIBILITY MODE IMAGE IS A MULTI-USER IMAGE OR A LIBRARY/COMMON
;
42$:	CLRL	R2			;ASSUME ONLY 7 LIBRARY DESCRIPTORS
	CMPB	L$BSYS(R4),#4		;RSX-11M TASK? (ONLY 7 POSSIBLE)
	BNEQ	43$			;IF NEQ YES, R2 IS CORRECT
	MOVZBL	#<8*<L$BLIB-L$BPAR>>/2,R2 ;ALLOW FOR 8 MORE DESCRIPTORS
43$:	BITW	#TS$NHD,L$BFLG(R4)	;IS THERE A HEADER?

	BNEQ	60$			;BRANCH IF NOT, MUST BE LIBRARY
	MOVZWL	L$BROB(R4)[R2],R1	;VBN OF MULTI-USER READ-ONLY SEGMENT
	MOVZWL	L$BROL(R4)[R2],R0	;SIZE (64 BYTE UNITS) OF SEGMENT IF PRESENT
	BNEQ	80$			;BRANCH IF IT IS PRESENT
;
; THIS IMAGE IS NEITHER A MULTI-USER IMAGE NOR A LIBRARY/COMMON
;
45$:
	BBCCI	#KFI$V_KP_SHARED,KFI$W_FLAGS(R7),120$ ;CANNOT BE SHARED
50$:	BRB	120$

;
; COMPATIBILITY MODE IMAGE HAS NO HEADER, TREAT IT AS A LIBRARY/COMMON
;
60$:	MOVZWL	L$BHRB(R4)[R2],R1	;STARTING VBN - 1 OF COMMON
	INCL	R1			;STARTING VBN OF COMMON
	MOVZWL	L$BLDZ(R4),R0		;SIZE IN 64 BYTE UNITS
80$:	ADDL	#7,R0			;ROUND UP SIZE TO THE NEXT 512 BYTES
	DIVL	#8,R0			;AND FORM PAGE COUNT
	MOVZWL	#<SEC$M_SYSGBL ! SEC$M_PERM ! - ;PERMANENT SYSTEM WIDE
		SEC$M_GBL>,R2		;GLOBAL SECTION, READ ONLY
	BBC	#IAC$V_WRITABLE,IACFLG(R6),100$ ;BRANCH IF READ ONLY SECTION
	BISL	#SEC$M_WRT,R2		;MAKE SECTION WRITABLE
100$:	$CRMPSC_S -			;CREATE THE SECTION
		INADR=0,-		;WITHOUT MAPPING IT
		ACMODE=S^#PSL$C_USER,-	;FOR USER MODE
		FLAGS=R2,-
		GSDNAM=GSDNAMSIZ(R6),-
		IDENT=KFIMATCHCTL(R6),-
		CHAN=CHAN(R6),-		;CHANNEL ON WHICH THE FILE IS OPEN
		PAGCNT=R0,-
		VBN=R1
	BLBC	R0,140$			;BRANCH IF FAILED TO CREATE GLOBAL SECTION
					;DON'T SET COMPATMOD BIT
					;KEEP TRYING ON EACH ACTIVATION
;
; GLOBAL SECTION SUCCESSFULLY CREATED
;
	ASSUME	KFI$L_IDENT EQ KFI$B_MATCHCTL+4
	MOVQ	KFIMATCHCTL(R6),KFI$B_MATCHCTL(R7) ;RECORD IDENT FOR DELETING PURPOSES
	MOVW	#1,KFI$W_GBLSECCNT(R7)	;ONE GLOBAL SECTION TO DELETE
	BBC	#IAC$V_SHMIDENT,IACFLG(R6),110$ ;BR IF SECTION NOT IN SH MEM
	BBSSI	#KFI$V_SHMIDENT,KFI$W_FLAGS(R7),110$ ;SET SH MEM BIT
110$:	BBSSI	#KFI$V_IS_SHARED,KFI$W_FLAGS(R7),120$ ;INDICATE WAS MADE SHARED
120$:	BBSSI	#KFI$V_COMPATMOD,KFI$W_FLAGS(R7),130$ ;IS COMPAT MODE IMAGE
130$:	MOVW	AMECOD(R6),KFI$W_AMECOD(R7)	;RECORD WHICH AME
140$:	CLRL	KFINAMSTR(R6)		;MUST CLEAN UP ALL SIDE EFFECTS
					;SO THAT RSX.EXE CAN BE ACTIVATED
	BRW	KRNL_KFI_DECREF		;RELEASE REFERENCE ON COMPAT MODE
					;KNOWN FILE ENTRY AND RETURN
					;TO THIS ROUTINE'S CALLER
	.PAGE
	.SBTTL	MANUAL FILE OPEN - NO RMS OR FCP AVAILABLE
;
; CALLING SEQUENCE:
;
;	BRW	MANUAL_OPEN
;
; INPUTS:
;
;	RUNS IN EXEC MODE
;	R0 = ADDRESS OF NAME STRING DESCRIPTOR
;	R1 = SIZE OF NAME STRING
;	R2 = ADDRESS OF NAME STRING
;	R4 = ADDRESS OF INDEX FILE HEADER BUFFER
;	R5 = ADDRESS OF FILE ACCESS BLOCK (FAB)
;	R6 = ADDRESS OF SCRATCH AREA
;
; OUTPUTS:
;
;	BRANCHES TO MANUAL_OPN_DONE IF SUCCESSFUL
;	RETURNS WITH ERROR STATUS IN R0 IF NOT
;
; EQUATED SYMBOLS:
;
	$OFFSET	<RSLTNAME+4>,POSITIVE,<-
	<RTRVBUF,8>,-			;RETRIEVAL POINTER BUFFER DESCRIPTOR
	RTRVLEN,-			;RETURNED LENGTH OF RTRV PTR BUF
	<STATBLK,8>-			;STATISTICS BLOCK FROM FIL$OPENFILE
	>

	.PSECT	YFILEREAD BYTE,EXE

MANUAL_OPEN:
	MOVQ	R1,IOSB(R6)		;SAVE NAME DESCRIPTOR
	MOVAL	FIRSTHDR+512(R6),RTRVBUF+4(R6) ;ADR OF RTRV PTR BUFFER
	MOVZWL	#512,RTRVBUF(R6)	;MAX SIZE OF RETRIEVAL POINTER BUFFER
	PUSHAL	RTRVBUF(R6)		;ADDRESS OF RTRV BUF DESCRIPTOR
	PUSHAL	RTRVLEN(R6)		;ADR TO RETURN RTRV BUF LENGTH
	PUSHAL	STATBLK(R6)		;ADDRESS TO RETURN STATBLK
	PUSHAL	OTHERHDR(R6)		;FILE HEADER BUFFER
	PUSHAL	(R4)			;INDEX FILE HEADER BUFFFER
	PUSHL	R0			;ADDRESS OF NAME DESCRIPTOR
	PUSHAL	CHAN(R6)		;ADDRESS OF RETURN CHANNEL
	CALLS	#7,G^FIL$OPENFILE 	;"OPEN" THE FILE
	MOVZWL	CHAN(R6),FAB$L_STV(R5)	;PUT CHANNEL WHERE RMS WOULD
	BLBC	R0,40$			;EXIT IF ERROR
	MOVZWL	#SS$_BADIMGHDR,R0	;FILE IS TOO FRAGMENTED TO BE OF USE
	CMPL	RTRVLEN(R6),RTRVBUF(R6)	;IF NUM OF POINTERS WON'T ON A PAGE
	BGTR	40$			;EXIT ON ERROR
	MOVZWL	#SS$_BADIMGHDR,R0	;ASSUME BAD IMAGE HEADER
	MOVL	RTRVLEN(R6),RTRVBUF(R6)	;ACTUAL LENGTH OF RTRV PTR BUF
	BEQL	40$			;BRANCH IF FILE IS EMPTY
	MOVAL	B^INIT_WINDOW,KRNLROUT(R6) ;ALLOCATE AND INIT A WINDOW
	BSBW	CMKRNL			;IN KERNEL MODE
	BLBC	R0,40$			;BRANCH IF ERROR
	PUSHR	#^M<R0,R4,R5>		;SAVE THESE REGISTERS FROM MOVC
	MOVC3	IOSB(R6),(R2),RSLTNAME+1(R6)	;SAVE THE IMAGE NAME
	POPR	#^M<R0,R4,R5>		;RESTORE SAVED REGISTERS
	MOVAL	NAM(R6),R3		;ADDRESS OF NAME BLOCK
	MOVB	IOSB(R6),NAM$B_RSL(R3)	;SAVE SIZE OF IMAGE NAME STRING
	BRW	MANUAL_OPN_DONE		;REJOIN COMMON IMAGE ACTIVATION CODE


;
; ERROR EXITS
;
40$:	RET				;RETURN WITH R0 INDICATING STATUS
	.PAGE
;
; KERNEL MODE ROUTINE TO INTERFACE TO THE ALLOCATE AND INIT WINDOW ROUTINE
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS INVOKED IN KERNEL MODE AT IPL 0 WITH A JSB INSTRUCTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS FROM THE CHANGE MODE TO KERNEL DISPATCHER
;	R6 = IMAGE ACTIVATOR CONTEXT AREA ADDRESS
;	R7 = KNOWN FILE ENTRY ADDRESS IF NON-ZERO
;	IOSB(R6) = SIZE OF NAME STRING
;	IOSB+4(R6) = ADDRESS OF NAME STRING
;	RTRVBUF(R6) = SIZE IN BYTES OF RETRIEVAL POINTER BUFFER
;	RTRVBUF+4(R6) = ADDRESS OF RETRIEVAL POINTER BUFFER
;	R0-R4 MAY BE ALTERED
;	R5 MUST BE PRESERVED
;
INIT_WINDOW:
	MOVZWL	CHAN(R6),R0		;CHANNEL INDEX
	JSB	G^IOC$VERIFYCHAN	;VERIFY CHANNEL, GET CCB ADDRESS IN R1
	BLBC	R0,80$			;BRANCH IF BAD CHANNEL
	PUSHL	R1			;SAVE CCB ADDRESS
	MOVL	CCB$L_UCB(R1),R3	;UCB ADDRESS
	MOVQ	RTRVBUF(R6),R1		;R1 = NO. OF BYTES OF RTRV PTRS
					;R2 = ADR OF RETRIEVAL PTR BUF
	BSBB	MMG$INIWCB		;ALLOCATE AND INIT A WINDOW CONTROL BLOCK
	POPR	#^M<R1>			;RECOVER CCB ADDRESS
	BLBC	R0,80$			;BRANCH IF FAILED
	MOVL	R2,CCB$L_WIND(R1)	;SET WINDOW ADDRESS IN CHANNEL
	MOVL	PCB$L_JIB(R4),R0	;GET ADR OF JOB INFORMATION BLOCK
	DECW	JIB$W_FILCNT(R0)	;CHARGE A FILE AGAINST THE QUOTA
	MOVB	S^#PSL$C_USER+1,CCB$B_AMOD(R1) ;USER MODE CHANNEL
;
; SEE IF THIS IMAGE IS THE FCP FOR THE SYSTEM VOLUME
;
	MOVL	KFI$GL_F11AACP,R7	;GET ADDRESS OF KNOWN FILE ENTRY
	BEQL	60$			;BRANCH IF NONE EXISTS (WEAK GLOBAL)
	CMPL	S^#FCPSTRSIZ,IOSB(R6)	;DO STRING SIZES MATCH?
	BNEQ	60$			;BRANCH IF NOT
	CMPC3	S^#FCPSTRSIZ1,B^FCPSTR,@IOSB+4(R6) ;FIRST PARTS EQUAL?
	BNEQ	60$			;BRANCH IF NOT
	MOVZBL	(R3)+,R4		;SAVE STRUCTURE LEVEL CHAR (A, OR B)
	CMPC3	S^#FCPSTRSIZ2,(R1),(R3)	;LAST PARTS EQUAL?
	BNEQ	60$			;BRANCH IF NOT
	CMPB	#^A/A/,R4		;"A" FOR STRUCTURE LEVEL 1
	BEQL	40$			;BRANCH IF IT IS
	CMPB	#^A/B/,R4		;"B" FOR STRUCTURE LEVEL 2
	BNEQ	60$			;BRANCH IF NOT A MATCH
;
; PUT STRUCTURE LEVEL CHARACTER IN KNOWN FILE ENTRY
;
40$:	MOVZBL	KFI$B_FILNAM(R7),R0	;OFFSET TO COUNTED FILE NAME IN KFI ENTRY
	MOVB	R4,4(R7)[R0]		;STORE IN 4TH CHARACTER OF COUNTED STRING
					;1ST IS COUNT, NEXT 3 ARE "F11"
	CLRB	KFI$B_KFISEQ(R7)	;ZERO SEQUENCE NUMBER
	MOVL	R7,FAB$L_CTX+FAB(R6)	;PUT KFI ADR WHERE RMS WOULD
	INCL	KFI$L_USECNT(R7)	;COUNT THE USE OF THE KFI ENTRY
60$:	MOVZWL	S^#SS$_NORMAL,R0	;SUCCESSFUL COMPLETION
80$:	RSB

;
; FCP NAME FOR STRUCTURE LEVEL 1 OR 2 VOLUME
;
FCPSTR:
	.ASCII	/[SYSEXE]F11/		;FOLLOWED BY "A" OR "B"
	FCPSTRSIZ1=.-FCPSTR
10$:	.ASCII	/ACP.EXE/
	FCPSTRSIZ2=.-10$
	FCPSTRSIZ=.+1-FCPSTR		;SIZE OF FULL FCP NAME STRING
	.PAGE
	.SBTTL	INIWCB - INIT WINDOW CONTROL BLOCK

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES AND FILLS IN A WINDOW CONTROL BLOCK
; IT RUNS IN KERNEL MODE AT IPL=0
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$INIWCB
;
;
; INPUT PARAMETERS:
;
;	R1 = NUMBER OF BYTES IN RETRIEVAL POINTER BUFFER
;	R2 = ADDRESS OF RETRIEVAL POINTER BUFFER - ENTRIES ARE EACH
;	     8 BYTES CONSISTING OF A 4 BYTE BLOCK COUNT AND A 4 BYTE LBN
;	R3 = UCB ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 LOW BIT SET IF OK, LOW BIT CLEAR IF ERROR
;	R2 = WINDOW CONTROL BLOCK ADDRESS IF SUCCESSFUL
;	R3 PRESERVED IF SUCCESSFUL
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--


	.PSECT	YFILEREAD BYTE,EXE

MMG$INIWCB::
	DIVL	#8,R1			;COUNT OF 8 BYTE RETRIEVAL POINTERS
	PUSHR	#^M<R1,R2,R3,R4,R5>	;SAVE INPUTS AND SOME WORKING REGISTERS
	CLRL	R4			;INIT COUNT OF 6 BYTE RTRV PTRS
10$:	ADDL3	#^XFFFE,(R2),R0		;GET ROUNDED UP BLOCK COUNT
	DIVL	#^XFFFF,R0		;NO. OF 6 BYTE PTRS REQUIRED
	ADDL	R0,R4			;ACCUMULATE THE COUNT
	ADDL	#8,R2			;ADDR OF NEXT 8 BYTE RTRV PTR
	SOBGTR	R1,10$			;LOOP THROUGH THEM ALL
	MULL3	#6,R4,R1		;BYTE COUNT FOR 6 BYTE POINTERS
	ADDL	#WCB$K_LENGTH,R1	;DESIRED BLOCK SIZE TO ALLOCATE
	JSB	G^EXE$ALONONPAGED	;ALLOCATE NON PAGED DYNAMIC MEMORY
	BLBC	R0,100$			;BRANCH IF FAILED TO ALLOCATE
;
; R1 = ALLOCATED SIZE, R2 = ADDRESS OF ALLOCATED AREA
;
	DIVL3	#8,R1,R3		;TRUNCATED NO. OF QUAD WORDS TO ZERO
	MOVL	R2,R0			;MAKE A COPY OF THE WCB ADDRESS
20$:	CLRQ	(R0)+			;CLEAR THE WCB
	SOBGTR	R3,20$
	MOVW	R1,WCB$W_SIZE(R2)	;SAVE ALLOCATED WCB SIZE
	MOVB	S^#DYN$C_WCB,WCB$B_TYPE(R2) ;SET TYPE FIELD
	MOVB	#<WCB$M_READ ! -	;FILE ACCESSED FOR READING
		WCB$M_NOTFCP>,WCB$B_ACCESS(R2) ;BUT NOT BY FCP
	MOVW	R4,WCB$W_NMAP(R2)	;RETRIEVAL POINTER COUNT
	INCL	WCB$L_STVBN(R2)		;STARTING VBN IS 1
	INSQUE	(R2),G^EXE$GL_SYSWCBFL	;MAINTAIN A LIST OF THESE WCB'S
	MOVQ	(SP)+,R4		;R4 = NO. OF 8 BYTE RTRV PTRS
					;R5 = ADDR OF FIRST 8 BYTE RTRV PTR
	PUSHL	R2			;SAVE WCB ADDRESS
	ADDL	#WCB$W_P1_COUNT,R2	;STARTING ADDR IN WCB TO STORE RTRV PTRS
;
; THE FOLLOWING DOUBLE LOOP CONSISTS OF AN OUTER LOOP THAT ITERATES
; THROUGH THE 8 BYTE RETRIEVAL POINTERS AND AN INNER LOOP THAT MAKES
; AS MANY 6 BYTE FORMAT RETRIEVAL POINTERS AS NECESSARY.  NOTE THAT
; THE 6 BYTE FORMAT IS 2 BYTES OF BLOCK COUNT AND 4 BYTES OF LBN.
; THE BLOCK COUNT HOLDS 2**16-1 BLOCKS SINCE 0 REALLY MEANS 0.
;
30$:	MOVZWL	#^XFFFF,R3		;MAX BLOCK COUNT FOR 6 BYTE RTRV PTR
	MOVQ	(R5)+,R0		;R0=4 BYTE BLOCK COUNT, R1=LBN
40$:	CMPL	R3,R0			;USE THE MINIMUM BLOCK COUNT
	BLEQU	50$			;BRANCH IF MAX IS THE SMALLER
	MOVL	R0,R3			;MAX TOO BIG, USE WHAT'S LEFT
50$:	MOVW	R3,(R2)+		;STORE BLOCK COUNT
	MOVL	R1,(R2)+		;AND STARTING LBN
	ADDL	R3,R1			;FORM NEXT LBN
	SUBL	R3,R0			;AND REMAINING BLOCK COUNT
	BNEQ	40$			;BRANCH IF MORE BLOCKS TO MAP
	SOBGTR	R4,30$			;BRANCH IF MORE 8 BYTE RTRV PTRS
	POPR	#^M<R2,R3,R4,R5>	;R2 = WCB ADR, R3 = UCB ADR
					;RESTORE SAVED R4,R5
	BISB2	#<WCB$M_COMPLETE ! -	;FILE IS COMPLETELY MAPPED
		  WCB$M_CATHEDRAL>,-	; AND SHOULD REMAIN COMPLETELY MAPPED,
		WCB$B_ACCESS(R2)	; EVEN IF THE FILE IS EXTENDED
	MOVL	R3,WCB$L_ORGUCB(R2)	;SET UCB ADDRESS IN WINDOW
	MOVZWL	S^#SS$_NORMAL,R0	;INDICATE SUCCESSFUL COMPLETION
	RSB				;AND RETURN
;
; ERROR EXIT WITH R0 = STATUS CODE
;
100$:	POPR	#^M<R1,R2,R3,R4,R5>	;RESTORE SAVED REGISTERS
	RSB
	.PAGE
	.SBTTL	SHMIDENTINI

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE DETERMINES IF A KNOWN FILE IS IN SHARED MEMORY OR NOT.  IF IT
; IS, THEN THE LINK CREATION DATE IN THE IMAGE HEADER IS USED AS AN IDENT OR
; THE LAST PATCH DATE (IF ONE EXISTS).  COMPATABILITY MODE IMAGES THAT HAVE NO
; HEADER HAVE ZERO FOR AN IDENT.
;
; CALLING SEQUENCE:
;
;	BSBW	KFI_SHMIDENTINI
;
; INPUT PARAMETERS:
;
;	R4 = ADR OF FIRST BLOCK OF IMAGE HEADER
;	R6 = ADR OF SCRATCH AREA
;	R7 = ADR OF KNOWN FILE ENTRY
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - RETURN STATUS CODE FROM LOGICAL NAME TRANSLATION
;
; IMPLICIT OUTPUTS:
;
;	THE IDENT IS UPDATED IF THE KNOWN FILE IS IN SHARED MEMORY.
;
; COMPLETION CODES:
;
;	NONE
;
;--

	.PSECT	YF$LOWUSE

KFI_SHMIDENTINI:
	MOVZBL	#SS$_NORMAL,R0			;ASSUME SUCCESS
	PUSHR	#^M<R9,R10,R11>			;SAVE REGISTERS
	BBS	#IAC$V_SHMIDENT,IACFLG(R6),10$ ;BR IF KFI SHM IDENT KNOWN
;
; R9 - ADR OF STRING DESC FOR INPUT NAME
; R10 - ADR OF STRING DESC FOR RESULTANT SHARED MEMORY NAME
; R11 - ADR OF STRING DESC FOR RESULTANT GLOBAL SECTION NAME
;
	PUSHL	GSDNAMADR(R6)			;SET ADR IN INPUT NAME DESC
	SUBL3	#4,GSDNAMSIZ(R6),-(SP)		;SET SIZ IN INPUT NAME DESC
	MOVL	SP,R9				;SET ADR OF INPUT NAME STR DESC
	SUBL	#<4*4>,SP			;BUFFER FOR SH MEM NAME
	MOVAB	1(SP),-(SP)			;ADR FOR SH MEM NAME
	PUSHL	#15				;SIZ OF SH MEM NAME BUFFER
	MOVL	SP,R10				;ADR OF SH MEM STR DESC
	SUBL	#<4*4>,SP			;BUFFER FOR GS NAME
	MOVAB	1(SP),-(SP)			;ADR FOR GS NAME
	PUSHL	#15				;SIZ OF GS NAME BUFFER
	MOVL	SP,R11				;ADR OF GS STR DESC
	JSB	G^MMG$GSDTRNLOG		;GET LOGICAL NAME TRANSLATION
	BLBC	R0,60$				;BR IF ERROR
	TSTL	(R10)				;IS THERE A SH MEM NAME?
	BEQL	60$				;BR IF NO SH MEM NAME
10$:	BBS	#IAC$V_LIM,IACFLG(R6),55$	;BR IF LINKABLE IMAGE
	BBC	#IAC$V_IS_RESHDR,IACFLG(R6),20$ ;BR IF HDR IS NOT RESIDENT
	BBC	#KFI$V_COMPATMOD,KFI$W_FLAGS(R7),40$ ;BR IF NOT COMPAT IMAGE
	BRB	30$				;BR ON COMPAT IMAGE

20$:	CVTWL	^X1FE(R4),R11			;IS THIS COMPAT. MODE IMAGE?
	BLSS	40$				;BR IF NOT COMPATIBILITY IMAGE
30$:	CLRL	KFIMATCHCTL+4(R6)		;ASSUME NO HEADER
	BITW	#TS$NHD,L$BFLG(R4)		;IS THERE A HEADER ON IMAGE?
	BNEQ	50$				;BR IF THERE IS NO HEADER
	MOVL	L$BDAT+2(R4),KFIMATCHCTL+4(R6)	;USE DATE IN HEADER AS IDENT
	BRB	50$				;GO SET MATCH CONTROL FLAGS

40$:	MOVZWL	IHD$W_IMGIDOFF(R4),R11		;OFFSET TO IMAGE IDENT SECTION
	ADDL2	R4,R11				;ADR OF IMAGE IDENT SECTION
	MOVL	IHI$Q_LINKTIME+2(R11),KFIMATCHCTL+4(R6) ;USE TIME AS IDENT
	TSTW	IHD$W_PATCHOFF(R4)		;IS THE IMAGE PATCHED?
	BEQL	50$				;BR IF IT IS NOT PATCHED
	MOVZWL	IHD$W_PATCHOFF(R4),R11		;OFFSET TO IMAGE PATCH SECTION
	ADDL2	R4,R11				;ADR OF IMAGE PATCH SECTION
	MOVL	IHP$Q_PATDATE+2(R11),KFIMATCHCTL+4(R6) ;USE PATCH TIME AS IDENT
50$:	MOVL	#ISD$K_MATEQU,KFIMATCHCTL(R6)	;ALWAYS REQUIRE IDENT MATCH
55$:	BBSS	#IAC$V_SHMIDENT,IACFLG(R6),70$	;RECORD SHM IDENT COMPUTED
60$:	ADDL	#<14*4>,SP			;RELEASE BUFFERS AND STR DESC'S
70$:	POPR	#^M<R9,R10,R11>			;RESTORE REGISTERS
80$:	RSB					;RETURN
	.PAGE
	.SBTTL	SET_VECTORS - ADD NEW MESSAGE/CHANGE MODE VECTORS

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE READS THE SECTION JUST MAPPED AND ADDS ENTRIES TO THE APPROPRIATE
; PLACE IN THE VECTOR PAGES FOR THE NEW VECTORS.  IF ANY ERROR IS ENCOUNTERED
; WHILE VALIDATING THE VECTORS, THE IMAGE ACTIVATOR EXITS WITH AN ERROR STATUS.
; BEFORE EXITING, THE VECTORS ARE RESET TO THEIR CONTENTS UPON ENTERING $IMGACT.
;
; AT THIS TIME, EACH VECTOR CONTAINS AN INSTRUCTION SEQUENCE THAT READS
;
;	RSB	@#ADDRESS
;
; IF THE IMAGE IS ABORTED OR ANY OTHER ABNORMAL EXIT OCCURS BEFORE THE FIXUP
; CODE EXECUTES, THE PRESENCE OF THE RSB PREVENTS CODE THAT IS NOT FIXED UP
; FROM EXECUTING. AFTER THE FIXUPS HAVE BEEN SUCCESSFULLY COMPLETED, EACH
; "RSB" IS REPLACED WITH A "JSB".
;
; CALLING SEQUENCE:
;
;	JSB	SET_VECTORS
;
; INPUT PARAMETERS:
;
;	R6 = ADR OF IMAGE ACTIVATION SCRATCH AREA
;	R7 = ADR OF KFI OR 0, IF NO KFI
;	CRM_RET_CODE(R6) = RETURN STATUS CODE FROM MAPPING IMAGE SECTION
;
; OUTPUT PARAMETERS:
;
;	R0 = RETURN STATUS CODE
;
; IMPLICIT OUTPUTS:
;	
;	R1-R3 DESTROYED
;	NEW VECTORS ARE ADDED, IF SUCCESSFUL.
;
; COMPLETION CODES:
;
;	SS$_BADVEC - ILLEGAL VECTOR
;	SS$_PROTINSTALL - PROTECTED VECTOR NOT INSTALLED
;
;--

	.PSECT	YF$$SYSIMGACT

SET_VECTORS:
	.ENABL	LSB
	ASSUME	NXTKVEC EQ 0
	ASSUME	NXTEVEC-NXTKVEC EQ 256
	ASSUME	NXTRVEC-NXTEVEC EQ 256
	ASSUME	PLV$L_VERSION EQ PLV$L_TYPE+4
	ASSUME	PLV$L_KERNEL EQ PLV$L_VERSION+4
	ASSUME	PLV$L_EXEC EQ PLV$L_KERNEL+4
	ASSUME	PLV$L_USRUNDWN EQ PLV$L_EXEC+4
	ASSUME	PLV$L_RMS EQ PLV$L_USRUNDWN+8
	MOVL	RETSTARTVA(R6),R1	;GET ADDRESS OF IMAGE SECTION MAPPED
	CASE	(R1)+,TYPE=L,-
		LIMIT=#PLV$C_TYP_CMOD,- ;CASE ON TYPE OF VECTOR
		<CMOD_VECTOR,-		;CHANGE MODE VECTOR (KERNEL,EXEC,RMS)
		MSG_VECTOR-		;ERROR MESSAGE VECTOR
		>
;
; ILLEGAL TYPE OF VECTOR, IF FALL THROUGH CASE INSTRUCTION.
;
10$:	MOVZWL	#SS$_BADVEC,R0		;SET RETURN ERROR CODE
20$:	RSB				;RETURN
30$:	MOVZWL	#SS$_PROTINSTALL,R0	;SET RETURN ERROR CODE
	RSB				;RETURN

;
; CHANGE MODE TYPE OF VECTORS, INCLUDING KERNEL, EXEC, AND RMS VECTORS
;
CMOD_VECTOR:
	CMPL	#SYS$K_VERSION,(R1)+	;LINKED AGAINST RUNNING SYSTEM?
	BNEQ	10$			;BR IF LINKED AGAINST DIFFERENT SYSTEM
	TSTL	R7			;WAS THE PROTECTED SECTION INSTALLED?
	BEQL	30$			;BR IF NOT INSTALLED, NO KFI
	BBC	#KFI$V_PROTECT,KFI$W_FLAGS(R7),30$ ;BR IF NOT INSTALLED /PROTECT 
	CMPL	#SS$_NORMAL,CRM_RET_CODE(R6) ;CHK FOR IMG SECTION INSTALLED UREW
	BNEQ	30$			;BR ON ERR, ALTER RET STATUS SS$_IVLVEC
	BBC	#KFI$V_IS_SHARED,KFI$W_FLAGS(R7),30$ ;BR IF NOT GLOBAL SECTION
	MOVAB	PLV$L_CHECK-PLV$L_KERNEL(R1),R0	;GET ADR OF CHECK FIELD, FOR MAP VA CHK
	TSTL	(R0)			;IS THERE A VALUE TO CHECK?
	BEQL	40$			;BR IF 0, PIC SECTION
	CMPL	R0,PLV$L_CHECK-PLV$L_KERNEL(R1)	;CONTENTS MUST = VA MAPPED AT
	BNEQ	10$			;BR ON ERR, NONPIC MAPPED IN WRONG PLACE
40$:	MOVAB	@#CTL$A_DISPVEC-NXTEVEC,R0 ;GET ADR OF 1ST PAGE OF DISPATCH VECTORS
	BSBB	DOVEC			; Do the KERNEL vector
	BSBB	DOVEC			; Do the EXEC vector
	BSBB	DOVEC			; Do the RUNDWN vector
	TSTL	(R1)+			; Reserved field - must be zero
	BNEQ	10$			; Not zero is error
;
; USER RMS DISPATCHER
;
	TSTL	(R1)			;NEW RMS VECTOR?
	BEQL	50$			;BR IF NONE SPECIFIED
	ADDL3	(R1),R1,@#CTL$GL_RMSBASE ;SET ADR OF NEW RMS
	BRB	50$			;RETURN SUCCESS CODE

;
; ERROR MESSAGE VECTORS.
;	R1 --> Vector + 4
;
MSG_VECTOR:
	TSTL	(R1)			;RESERVED FIELD, MBZ
	BNEQ	10$			;BR ON ERROR, FIELD NOT INITIALIZED TO 0
	CMPL	#6,PLV$L_MSGDSP-4(R1)	;OFFSET TO DISPATCHER MUST BE 6
	BNEQ	10$			;BR ON ERROR, VECTOR NOT CORRECT
	CMPL	#<-			;MSG DISPATCHER = "NOP,NOP,JSB (R5)"
		<AT_R5_MODE@24>!-	;HIGH BYTE CONTAINS (R5)
		<OP$_JSB@16>!-		;JSB INSTRUCTION
		<OP$_NOP@8>!-		;TWO NOP INSTRUCTIONS
		<OP$_NOP>-
		>,12-4(R1)		
	BNEQ	10$			;BR ON ERROR, NOT CORRECT DISPATCHER
	MOVAB	@#CTL$A_DISPVEC+NXTMVEC,R0 ;GET ADR OF MSG VECTOR AREA
	ADDL3	(R0),R0,R2		;GET ADR FOR NEW VECTOR

; NEED TO ALLOW ROOM FOR SIX BYTES OF INSTRUCTION PLUS A LONGWORD THAT
; CONTAINS AN "RSB" IN ITS LOW BYTE AND ZEROS IN THE REST.

	MOVAB	256-10(R0), R3		;END OF CURRENT VECTOR AREA
	CMPL	R3, R2			;ROOM TO ADD ANOTHER VECTOR?
	BLSS	VECTOR_FULL		;BR IF NOT ENOUGH ROOM
	MOVW	#JSB_ABSOLUTE,(R2)+	;SET "JSB @#" INTO VECTOR
	MOVAB	14-4(R1),(R2)+		;SET ADR OF MESSAGE DISPATCHER, JSB (R5)
	MOVZBL	#OP$_RSB,(R2)		;SET "RSB" AT END OF VECTORS
	SUBL3	R0,R2,(R0)		;SET NEW NEXT FREE VECTOR POINTER

; If the message section is writable, this indicates that it is a pointer
; section that contains the name of the file that contains the actual
; messages. Such sections must be writable from user mode.

50$:	MOVZBL	#SS$_NORMAL,R0		;RETURN SUCCESS CODE
	IFNOWRT	#4,(R1),55$,#PSL$C_EXEC	;IS PAGE UREW? BRANCH IF NOT
	$SETPRT_S	-
		INADR=RETSTARTVA(R6),-	;HERE IS RANGE OF SECTION JUST MAPPED
		PROT=#PRT$C_UW,-	;NEW PROTECTION IS WIDE OPEN ACCESS
		ACMODE=#PSL$C_EXEC	;CHECK FOR EXEC OWNERSHIP
55$:	RSB				;RETURN
;
; Subroutine to add new vector information from PLV to vector page in P1
;
;	R0 - Address of start of last vector area
;	R1 - Address of entry in PLV vector
;
DOVEC:	MOVAB	NXTEVEC-NXTKVEC(R0), R0	;GET ADR OF OFFSET TO NEXT FREE VECTOR
	TSTL	(R1)			;NEW VECTOR?
	BEQL	60$			;BR IF NONE SPECIFIED
	ADDL3	(R0), R0, R2		;GET ADR FOR NEXT FREE VECTOR

; NEED TO ALLOW ROOM FOR SIX BYTES OF INSTRUCTION PLUS A LONGWORD THAT
; CONTAINS AN "RSB" IN ITS LOW BYTE AND ZEROS IN THE REST.

	MOVAB	256-10(R0), R3		;END OF CURRENT VECTOR AREA
	CMPL	R3, R2			;ROOM TO ADD ANOTHER VECTOR?
	BLSS	VECTOR_FULL		;BR IF NOT ENOUGH ROOM
	MOVW	#RSB_ABSOLUTE,(R2)+	;SET "RSB @#" INTO VECTOR
	ADDL3	(R1), R1, (R2)+		;CALCULATE ABS ADDR OF DISPATCHER
	MOVZBL	#OP$_RSB, (R2)		;SET "RSB" AT END OF VECTOR LIST
	SUBL3	R0, R2, (R0)		;GET NEW OFFSET TO NEXT FREE VECTOR
60$:	TSTL	(R1)+			;ADVANCE TO NEXT VECTOR SLOT
	BBSS	#IFD$V_SETVECTOR,@#IAC$GL_IMAGCTX,70$	;INDICATE WORK TO DO
70$:	RSB

VECTOR_FULL:
	MOVZWL	#SS$_VECFULL,R0		;SET RETURN ERROR CODE, VECTOR FULL
	RSB				;RETURN

	.DSABL	LSB

	.PAGE
	.SUBTITLE	SET_VECTORS_AGAIN
;+
; Functional Description:
;
;	This routine is called by the fixup routine after fixups have
;	been done for a privileged shareable image to change all of the 
;	RSB @# combinations to JSB @#. Only after the fixups have been
;	successfully completed can these routines be allowed to execute.
;
; Implicit Input:
;
;	CTL$A_DISPVEC	Address of two pages of vector area in P1 space. 
;			
; Implicit Output:
;
;	All occurrences in these two of RSB @# are changed to JSB @#.
;-

	.PSECT	YF$$SYSIMGACT

SET_VECTORS_AGAIN:
	MOVAL	@#CTL$A_DISPVEC,R3	; Get address of start of area
	MOVAB	NXTKVEC+4(R3),R1	; Get first kernel dispatcher instruction 
	BSBW	20$			; Change RSB to JSB
	MOVAB	NXTEVEC+4(R3),R1	; Do same for exec dispatcher
	BSBW	20$			; Change RSB to JSB
	MOVAB	NXTRVEC+4(R3),R1	; Do user-written rundown routines
	BSBW	20$			; Change RSB to JSB
	BBCC	#IFD$V_SETVECTOR,@#IAC$GL_IMAGCTX,10$	; Indicate no more work
10$:	MOVZWL	#SS$_NORMAL,R0		; Indicate success
	RSB				; Return to caller

20$:	MOVL	#<<256-8>/6>,R0		; Initialize loop count
30$:	CMPW	(R1),#RSB_ABSOLUTE	; Is it "RSB @#"?
	BNEQ	40$			; No. Skip replacement
	MOVW	#JSB_ABSOLUTE,(R1)	; Replace "RSB" with "JSB"
40$:	ADDL2	#6,R1			; Advance to next instruction
	SOBGTR	R0,30$			; All done yet?
	RSB				; Yes. Return

	.PAGE
	.SBTTL	RESET_VECTORS - RESTORE VECTORS TO THEIR INPUT VALUES

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RESETS THE NEXT FREE POINTERS IN THE VECTOR PAGES TO THE VALUES
; THAT THEY CONTAINED AT THE INITIAL $IMGACT CALL.  AN "RSB" IS PLACED IN THE
; OFFSET THAT IS THE NEXT FREE VECTOR.
;
; CALLING SEQUENCE:
;
;	BSBW	RESET_VECTORS
;
; INPUT PARAMETERS:
;
;	R6 = ADDRESS OF IMAGE ACTIVATION SCRATCH AREA
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	R1,R2 DESTROYED
;	VECTORS ARE RESET
;
; COMPLETION CODES:
;
;	NONE
;
;--
	.PSECT	YF$$SYSIMGACT

RESET_VECTORS:
	ASSUME	NXTEVEC_SAV EQ NXTKVEC_SAV+4
	ASSUME	NXTRVEC_SAV EQ NXTEVEC_SAV+4
	ASSUME	NXTMVEC_SAV EQ NXTRVEC_SAV+4
	ASSUME	RMSBASE_SAV EQ NXTMVEC_SAV+4
	ASSUME	NXTEVEC EQ NXTKVEC+256
	ASSUME	NXTRVEC EQ NXTEVEC+256
	ASSUME	NXTMVEC EQ NXTRVEC+256
	MOVAB	@#CTL$A_DISPVEC+768, R1	;GET ADR OF LAST VECTOR PAGE
	MOVAB	RMSBASE_SAV+4(R6), R2	;SET ADDRESS OF SAVE AREA
	MOVL	-(R2), @#CTL$GL_RMSBASE	;RESET RMS DISPATCHER BASE
	BSBB	10$			;DO MESSAGE
	BSBB	10$			;DO RUNDWN
	BSBB	10$			;DO EXEC
;					;FALL THRU TO DO KERNEL AND RETURN
10$:	MOVL	-(R2), (R1)		;RESTORE OFF TO NEXT FREE VEC
	ADDL3	(R1), R1, R3		;COMPUTE ADDRESS OF THE NEXT FREE
	MOVZBL	#OP$_RSB, (R3)		;PLACE AN "RSB" TO END VECTOR LIST
	MOVAB	-256(R1), R1		;STEP TO NEXT VECTOR AREA
	RSB				;RETURN

	.PAGE
	.SUBTITLE	IMAGE_ACNT	Initialize Image Accounting Data
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE INITIALIZES THE IMAGE ACCOUNTING DATA IN THE PROCESS P1 VECTOR
; PAGE.
;
; CALLING SEQUENCE:
;
;	BSBW	IMAGE_ACNT
;
; INPUT PARAMETERS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	R0 DESTROYED
;
; COMPLETION CODES:
;
;	NONE
;
;--

IMAGE_ACNT:
	MOVL	@#CTL$GL_PHD,R0		; PHD ADDRESS
	MOVL	PHD$L_CPUTIM(R0),@#CTL$GL_ICPUTIM;INITIAL CPU TIME
	MOVL	PHD$L_PAGEFLTS(R0),@#CTL$GL_IFAULTS;INITIAL PAGE FAULTS
	MOVL	PHD$L_PGFLTIO(R0),@#CTL$GL_IFAULTIO;INITIAL PAGE FAULT I/O COUNT
	CLRQ	@#CTL$GL_IWSPEAK	;INITIALIZE IMAGE WS AND PAGE FILE PEAK
	MOVQ	PHD$L_DIOCNT(R0),@#CTL$GL_IDIOCNT;INITIAL DIRECT & BUFFERED I/O
	MOVL	@#CTL$GL_VOLUMES,@#CTL$GL_IVOLUMES;INITIAL MOUNT COUNT
	MOVQ	G^EXE$GQ_SYSTIME,@#CTL$GQ_ISTART;IMAGE ACTIVATION TIME
	RSB

	.END
