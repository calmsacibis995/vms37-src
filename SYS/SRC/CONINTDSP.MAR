	.TITLE	CONINTDSP -  CONSOLE INTERRUPT DISPATCHER
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
;
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER.
;
; ABSTRACT:
;
; CONSOLE INTERRUPT DISPATCHER AND DEVICE DEPENDENT SUBROUTINES.
;
; AUTHOR:
;
;	R.HEINEN 14-SEPT-76
;
;	V03-001	JLV0199		Jake VanNoy		22-MAR-1982
;		Fix race condition with class driver that garbages
;		output at high baud rates.
;
;	V02-014	JLV0190		Jake VanNoy		23-FEB-1982
;		Fix system-crashing bug by making sure top 3 bytes
; 		of R3 are zero before calling putnxt in ttdriver.
;
;	V02-013	JLV0092		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-012	JLV0067		Jake VanNoy		14-Aug-1981
;		Change MOVZBW to MOVZBL to clear out high end of R3,
;		update interface to TTDRIVER (take out TSTL R3's).
;
;	V02-011	JLV0056		Jake VanNoy		13-Jul-1981
;		Change dispatching to TTDRIVER through the PORT/CLASS
;		interface. Incomplete as far as condition codes passed
;		from TTDRIVER (TSTL R3's must be taken out).
;
;	V10	LMK0002		Len Kawell	11-Feb-1980
;		Add default allocation protection initialization to unit init.
;
;	V09	MHB0014		M. H. Bramhall	25-Sep-1979
;		Fix console (OPA0) UCB size.
;		Use terminal service independent dispatches.
;
;	V08	SRB0001		STEVE BECKHARDT		31-AUG-1979
;		MADE SEVERAL CHANGES TO SUPPORT A LOADABLE CONSOLE
;		FLOPPY DRIVER.
;
;	V07	LMK0001		LEN KAWELL	9-JUL-1979
;		CHANGED REFERENCE TO IDB$B_UNITS TO IDB$W_UNITS.
;--
;
; EXTERNAL DEFINITIONS
;
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$IDBDEF				; DEFINE IDB
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$UCBDEF				; DEFINE UCB
	$TTYDEFS			; DEFINE TERMINAL OFFSETS
;
; LOCAL STORAGE
;
	.PSECT	$$$105_PROLOGUE
OP$DPT::				; DRIVER START
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=CON_END,-		; END OF DRIVER
		ADAPTER=UBA,-		; FAKE ADAPTER
		UCBSIZE=<^X0BC>,-	; SIZE
		NAME=OPERATOR,-		; NAME
		VECTOR=OP_VECTOR	;

	DPT_STORE INIT
	DPT_STORE REINIT
	DPT_STORE END			;
	
	.PSECT	$$$250,LONG,WRT
;
; UNLIKE DZDRIVER, WHERE THESE VECTORS ARE TO-BE-RELOCATED OFFSETS,
; OP_VECTOR VALUES ARE SYSTEM ADDRESS CONSTANTS, READY TO BE USED
; WITHOUT RELOCATION.
;

OP_VECTOR:

	.LONG	CON$STARTIO		; START ROUTINE
	.LONG	 IOC$RETURN		; DISCONNECT ROUTINE
	.LONG	 IOC$RETURN		; SET LINE ROUTINE
	.LONG	 IOC$RETURN		; DATA SET ROUTINE
	.LONG	CON$XON			; XON ROUTINE
	.LONG	CON$XOFF		; XOFF ROUTINE
	.LONG	CON$STOP		; STOP ROUTINE
	.LONG	CON$STOP2		; STOP2 ROUTINE
	.LONG	CON$ABORT		; ABORT ROUTINE
	.LONG	CON$RESUME		; RESUME ROUTINE
	.LONG	 IOC$RETURN		; SET MODEM ROUTINE
	.LONG	 IOC$RETURN		; START DMA ROUTINE
	.LONG	 IOC$RETURN		; MAINTENANCE ROUTINE
	.LONG	0			; END OF VECTOR	

;
; OUTPUT INTERRUPT QUEUE
;
 
CURR:	.BYTE	-1			;CURRENT UNIT EXPECTING OUTPUT DONE
NEXT:	.BYTE	-1			;NEXT UNIT TO OUTPUT
DATA:	.BLKW	1			;NEXT DATA TO OUTPUT
	
	.PSECT	$$$115_DRIVER,LONG

	.SBTTL	CONSOLE CONTROLLER INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE CONTROLLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE CONTROLLER.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;--
CON$INITIAL::				; INITIALIZE CONSOLE INTERFACE
	MTPR	#^X040,#PR$_RXCS	; ENABLE INPUT INTERRUPTS
	MTPR	#^X040,#PR$_TXCS	; ENABLE OUTPUT INTERRUPTS
	MNEGW	#1,CURR			; SET NO UNITS WAITING FOR OUTPUT
	RSB

	.SBTTL	CONSOLE UNIT INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE UNITS.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;--
CON$INITLINE::
	BITW	#UCB$M_INT!UCB$M_POWER,UCB$W_STS(R5); POWER FAILED OR INTERRUPT EXPECTED?
	BNEQ	CON$DISCON		; IF NEQ THEN YES
	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),CON$DISCON; BR IF NOT TERMINAL
	TSTW	UCB$W_REFC(R5)		; REFCOUNT 0?
	BNEQ	CON$DISCON		; IF NEQ THEN NO SET UP

	PUSHL	R0			; SAVE R0
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS OF CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R0)	; INITIALIZE THE UCB FOR CONSOLE TERMINAL
	POPL	R0			; RESTORE R0

	MOVW	TTY$GW_PROT,UCB$W_VPROT(R5) ; SET DEFAULT DEVICE PROTECTION
	MOVL	TTY$GL_OWNUIC,UCB$L_OWNUIC(R5) ; SET DEFAULT OWNER UIC
CON$DISCON:: 				; NULL ENTRY FOR CONSOLE TERMINAL DISCONNECT
	RSB				;

	.SBTTL CONSOLE RECIEVER INTERRUPT DISPATCHER
;++
; CON$INTINP - CONSOLE INTERRUPT ON INPUT READY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AS A RESULT OF A RECEIVER INTERRUPT ON THE
; CONSOLE INTERFACE. THE INTERRUPT CAN BE GENERATED BY THE CONSOLE
; TERMINAL OR FLOPPY DRIVE.
;
; CONSOLE TERMINAL:	ALL RECEIVED DATA CHARACTERS ARE CONSIDERED
;			UNSOLICITED AND RESULT IN AN ENTRY INTO THE
;			TERMINAL DRIVER COMMON CHARACTER BUFFERING
;			ROUTINE "@UCB$L_TT_PUTNXT(R5)".
;
; CONSOLE FLOPPY:	RECEIVER INTERRUPTS FROM THE CONSOLE FLOPPY
;			MUST BE EXPECTED (UCB$V_INT = 1). IF THE 
;			INTERRUPT IS EXPECTED THEN UCB$V_INTTYPE IS SET
;			IN UCB$W_STS TO SIGNAL A RECEIVER INTERRUPT.
;			THE DRIVER IS THEN ENTERED AT ITS WAIT FOR INTERRUPT
;			CONTEXT PC.
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
CON$INTINP::
	MFPR	#PR$_RXDB,R3		; MOVE DATA FROM INTERFACE
;
; GET THE ASSOCIATED UCB
;
	MOVL	@(SP)+,R4		; GET IDB ADDRESS
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICW	#^C<3>,R2		;
	CMPW	R2,IDB$W_UNITS(R4)	; LEGAL UNIT NUMBER?
	BGEQU	30$			; DISMISS INTERRUPT
5$:	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB ADDRESS
	BEQL	30$			; NO UCB - DISMISS INTERRUPT
	BISW	#UCB$M_INTTYPE,UCB$W_STS(R5); SET RECEIVER INTERRUPT
	BBS	#DEV$V_TRM,-		; ENTER FLOPPY INTERRUPT CODE
		UCB$L_DEVCHAR(R5),10$
	BRW	FLOPINT			; IF NOT TERMINAL UCB
;
; CONSOLE TERMINAL INTERRUPT
;
10$:	MOVZBL	R3,R3			; ZERO TOP 3 BYTES
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BEQL	30$			; IF EQL THEN NO CHARACTER TO OUTPUT
20$:	BSBW	CON$STARTIO		; OUTPUT THE CHARACTER
30$:	BRW	DISMIS			; GO

	.SBTTL	START I/O ON CONSOLE INTERFACE
;++
; CON$STARTIO - START I/O ON CONSOLE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO OUTPUT A CHARACTER TO THE CONSOLE INTERFACE.
; IF THE INTERFACE IS READY THE DATA IS OUTPUT DIRECTLY. IF THE INTERFACE
; IS NOT READY THEN THE DATA IS QUEUED AND SUBSEQUENTLY OUTPUT ON THE
; NEXT READY INTERRUPT.
;
; IN EITHER CASE, A RETURN TO THE CALLER IS DONE TO ENTER A "WAIT FOR
; INTERRUPT" STATE.
;
; INPUTS:
;
;	R3 = DATA TO OUTPUT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4,R5 ARE PRESERVED.
;--

.ENABLE LSB

CON$STARTIO::				;

	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),5$	; BRANCH IF FLOPPY
	BLSS	20$				; BRANCH
;
; INSERT UNIT NUMBER IN DATA WORD
;
5$:
CON$STARTIO1:
	MOVZBL	UCB$W_UNIT(R5),R2	; PICK UP UNIT NUMBER
	INSV	R2,#8,#2,R3		; INSERT UNIT NUMBER AND CLEAR OTHER BITS
;
; INITIATE I/O IF NO PREVIOUS UNIT WAITING
;
	TSTB	CURR			; OTHER UNIT WAITING?
	BLSS	10$			; IF LSS NO, OUTPUT DATA AND RETURN
	MOVB	R2,NEXT			; SAVE UNIT NUMBER
	MOVW	R3,DATA			; SAVE DATA
	RSB				; EXIT
10$:					;
	MOVB	R2,CURR			; SAVE UNIT NUMBER OF CURRENT SENDER
	MTPR	R3,#PR$_TXDB		; SEND DATA
	RSB

20$:	BISW	#TTY$M_TANK_BURST,-
		UCB$W_TT_HOLD(R5)	; SET BURST MODE
;
; TAKE CHARACTER OUT OF BURST BUFFER AND TRY TO OUTPUT IT IMMEDIATELY
;
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3	; OUTPUT NEXT BYTE
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	5$			; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
	BRB	5$

.DISABLE	LSB


	.SBTTL	CONSOLE TRANSMITTER INTERRUPT SERVICE
;++
; CON$INTOUT - CONSOLE TRANSMITTER INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CONSOLE UNIT READY INTERRUPT OCCURS.
;
; A SEARCH IS MADE OF THE COLD STORAGE BUFFER FOR DATA TO OUTPUT.
; IF ANY IS FOUND THEN IT IS OUTPUT. IF NO VALID DATA IS FOUND THEN
; THE INTERRUPT STATE OF THE UNIT IS CHECKED FOR EXPECTED INTERRUPT.
; IF NO INTERRUPT IS EXPECTED, THE INTERRUPT IS DISMISSED. IF AN INTERRUPT
; IS EXPECTED THEN THE DRIVER IS ENTERED. IN THE CASE OF THE CONSOLE TERMINAL,
; A SPECIFIC ROUTINE IS ENTERED TO GET THE NEXT CHARACTER AVAILABLE TO OUTPUT
; ON THE UNIT. IN THE CASE OF THE CONSOLE FLOPPY, THE WAIT FOR INTERRUPT
; CONTEXT IS TAKEN FROM THE UCB AND THE SPECIFIED ROUTINE IS ENTERED.
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
CON$INTOUT::				;
	MOVL	@(SP)+,R4		; GET ADDRESS OF IDB
	CVTBL	NEXT,R2			; GET UNIT NUMBER OF NEXT SENDER
	BLSS	10$			; IF LSS NO SENDER WAITING
	MNEGB	#1,NEXT			; RESET SENDER-WAITNG
	MOVZWL	DATA,R3			; GET DATA TO SEND
	MTPR	R3,#PR$_TXDB		; TRANSMIT DATA
10$:					;
	MOVZBL	CURR,R3			; GET UNIT NUMBER OF CURRENT SENDER
	MOVB	R2,CURR			; SET UNIT NUMBER OF NEXT CURRENT
	TSTB	R3			; SPURIOUS INTERRUPT?
	BLSS	DISMIS			; IF LSS YES
	MOVL	IDB$L_UCBLST(R4)[R3],R5	; GET ADDRESS OF UCB
	BBCC	#UCB$V_INTTYPE,UCB$W_STS(R5),FLOPINT ; SET OUTPUT INTERRUPT
FLOPINT:				;
	BBS	#DEV$V_TRM,UCB$L_DEVCHAR(R5),20$ ; IF BIT CLEAR, UNIT = FLOPPY
	BBCC	#UCB$V_TIM,UCB$W_STS(R5),10$ 	 ; CLEAR TIMEOUT PENDING
10$:	BBCC	#UCB$V_INT,UCB$W_STS(R5),DISMIS  ; EXIT IF NOT WAITING FOR INTERRUPT
;
; DEVICE IS A FLOPPY
;
	MOVL	UCB$L_FR4(R5),R4	; RESTORE R4 CONTEXT
	JSB	@UCB$L_FPC(R5)		; ENTER FLOPPY INTERRUPT HANDLER
	BRB	DISMIS
;
; DEVICE IS A TERMINAL 
;
20$:	BSBB	TERMINALIO

DISMIS:					;
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;
.PAGE
TERMINALIO:
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	BURST			; YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-		; DISPATCH
		XOFF,-			; SEND XOFF
		XON,-			; SEND XON
		STOP,-			; STOP OUTPUT
		STOP2,-			; ALTERNATE STOP
		BURST,-			; BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL TERMINAL DRIVER ROUTINE
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BLSS	START_BURST		; BURST SPECIFIED
	BEQL	EXIT			; NONE
	BSBW	CON$STARTIO1		; INITIATE I/O
	BRB	EXIT_INT		; EXIT WITH INTERRUPT EXPECTED

START_BURST:
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
BURST:
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3	; SET NEXT OUTPUT CHARACTER
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	10$			; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)

10$:	BSBW	CON$STARTIO1		; OUTPUT CHARACTER
	BRB	EXIT_INT		; EXIT WITH INTERRUPT EXPECTED

STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; RESET OUTPUT ACTIVE
	BRB	EXIT

STOP2:
	BICB	#UCB$M_INT,UCB$W_STS(R5); SHOW OUTPUT NOT ACTIVE
	BRB	EXIT

	.ENABLE	LSB
XOFF:
	BICW	#TTY$M_TANK_XOFF,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	BBC	#TTY$V_SX_TYPFUL,-
		UCB$Q_TT_STATE(R5),10$	; SKIP IF NOT TYPEAHEAD FULL

	BBS	#TT$V_HOSTSYNC,UCB$L_DEVDEPEND(R5),10$ ; XOFF CORRECT
	MOVZBL	#TTY$C_BELL,R3		; USE BELL CHARACTER
	BRB	25$
10$:
	MOVZBL	#TTY$C_XOFF,R3		; USE XOFF
	BRB	20$
XON:
	BICW	#TTY$M_TANK_XON,-	; RESET XON STATE
		UCB$W_TT_HOLD(R5)
	MOVZBL	#TTY$C_XON,R3		; SEND XON
20$:
	BITL	#TT$M_HOSTSYNC!TT$M_READSYNC,-
		UCB$L_DEVDEPEND(R5)	; HOST OR READ SYNC TERMINAL?
	BEQL	EXIT			; NO, SKIP OUTPUT
25$:	BSBW	CON$STARTIO1		; OUTPUT CHARACTER

EXIT_INT:
	BISB	#UCB$M_INT,UCB$W_STS(R5); SHOW OUTPUT ACTIVE
EXIT:
	RSB

	.DISABLE	LSB

.PAGE
.SBTTL	CONSOLE PORT ACTION ROUTINES
;++
; CON$XOFF -	SEND XOFF
; CON$XON -	SEND XON
; CON$STOP -	STOP OUTPUT
; CON$STOP2 -	ALTERNATE STOP
; CON$ABORT -	ABORT CURRENT OUTPUT
; CON$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
	.ENABLE	LSB

CON$XOFF:
	BISW	#TTY$M_TANK_XOFF,UCB$W_TT_HOLD(R5)	; SCHEDULE XOFF
	BRB	5$					; JOIN COMMON CODE

CON$XON:
	BISW	#TTY$M_TANK_XON,UCB$W_TT_HOLD(R5)	; SCHEDULE XON
5$:
	BBS	#UCB$V_INT,UCB$W_STS(R5),10$		; IF OUTPUT ACTIVE,

	PUSHR	#^M<R1,R2,R3,R4>			; SAVE REGISTERS
	BSBW	TERMINALIO				; START OUTPUT
	POPR	#^M<R1,R2,R3,R4>			; RESTORE REGISTERS
	BBSS	#UCB$V_INT,UCB$W_STS(R5),10$		; SHOW OUTPUT ACTIVE
10$:
	RSB
	.DISABLE	LSB

CON$STOP:
	BBSS	#TTY$V_ST_CTRLS,-
		UCB$Q_TT_STATE(R5),5$			; BLOCK NEW OUTPUT
5$:
	BISW	#TTY$M_TANK_STOP,-			; SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	RSB

CON$STOP2:						; USED FOR BROADCAST DELAY
	BBSS	#TTY$V_ST_CTRLS,-
		UCB$Q_TT_STATE(R5),5$			; BLOCK NEW OUTPUT
5$:
	BISW	#TTY$M_TANK_STOP2,-			; SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	BISB	#UCB$M_TIM,UCB$W_STS(R5)		; SHOW TIMER ACTIVE
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
	RSB

CON$ABORT:
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),-	; RESET BURST ACTIVE
		10$					; 
10$:
	ADDL3	#2,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
							; IN CASE OUTPUT ACTIVE
	RSB

CON$RESUME:
	PUSHL	R1					; SAVE A REGISTER
	BBCC	#TTY$V_ST_CTRLS,UCB$Q_TT_STATE(R5),5$	; ALLOW CLASS OUTPUT
5$:	BICW	#TTY$M_TANK_STOP!TTY$M_TANK_STOP2-
		,UCB$W_TT_HOLD(R5)			; RESET STOP CONDITIONS
	BBC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),20$	; BRANCH IF NO BURST IN PROGRESS

	MOVZWL	UCB$W_TT_OUTLEN(R5),R1			; NUMBER OF BURST CHARS
	DIVL	#4,R1					; DIV BY 4 (CHAR TIME)
	ADDL2	#2,R1					; MIN TIME
	ADDL3	R1,G^EXE$GL_ABSTIM,UCB$L_DUETIM(R5)	; SET TIME OUT
	BRB	30$

20$:	ADDL3	#2,G^EXE$GL_ABSTIM,-			; RESTORE TIMER FOR BURST
		UCB$L_DUETIM(R5)
30$:
	BISB	#UCB$M_TIM,UCB$W_STS(R5)		; SIGNAL TIMER ACTIVE
	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	PUSHR	#^M<R1,R2,R3,R4>			; SAVE REGISTERS
	BSBW	TERMINALIO				; START I/O
	POPR	#^M<R1,R2,R3,R4>			; RESTORE REGISTERS
40$:
	POPL	R1
	RSB


 
CON_END:
	.END
