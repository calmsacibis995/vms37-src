	.IF	NDF,RMSSWITCH
	.IF	NDF,LIBSWITCH
	.TITLE	CMODSSDSP - CHANGE MODE SYSTEM SERVICE DISPATCHER
	.IFF
	.IF	NDF,P1VSWITCH
	.TITLE	SYS$VECTOR - SYSTEM SERVICE VECTOR DEFINITIONS
	.IFF
	.TITLE	SYS$P1_VECTOR - P1 SYSTEM SERVICE VECTOR DEFINITIONS
	.ENDC
	.ENDC
	.IFF
	.TITLE	SYS$RMS_VECTOR - RMS SERVICE VECTOR DEFINITIONS
	.ENDC
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 22-JUN-76
;
;  MODIFIED BY:
;
;	V03-001	LJK0150		Lawrence J. Kenah	23-Feb-1982
;		Move $GETMSG from exec mode to caller's mode.
;
;	V02-052 MSH0002		Maryann Hinden		05-Feb-1982
;		Modify last change.
;
;	V02-051 MSH0001		Maryann Hinden		25-Jan-1982
;		Fix PROBE problem; correct byte count for user 
;		system service.
;
;	V02-050	SRB0041		Steve Beckhardt		30-Nov-1981
;		Added 4th argument (FLAGS) to $DEQ system service.
;
;	V02-049 WMC0012		Wayne Cardoza		12-Nov-1981
;		Reduce number of symbols generated only in S0 space.
;
;	V02-048	PHL0024		Peter H. Lipman		12-Nov-1981
;		Change parameter count on $GETDVI from 9 to 8
;
;	V02-047	RLR0001		Robert L. Rappaport	10-Nov-1981
;		Changed BRW to JMP to eliminate linking truncation error.
;
;	V02-046 DWT0004		David W. Thiel		10-Nov-1981
;		Remove RSB at SYS$CALL_HANDL+5.
;
;	V02-045	LJK0081		Lawrence J. Kenah	6-Nov-1981
;		Add extra quadword to $IMGFIX system service to allow
;		its future expansion to a composite system service.
;
;	V02-044	PHL0018		Peter H. Lipman		14-Oct-1981
;		Add $GETDVI system service.
;		Fix entry masks for $GETDEV and $GETCHN
;
;	V02-043	LJK0074		Lawrence J. Kenah	6-Oct-1981
;		Add entry mask for service that always returns success.
;		Add global entry point for service that always fails.
;
;	V02-042 JAY0004		John A. Ywoskus		05-Oct-81
;		Change parameter count for $GETSYI to add 
;		null arguments for compatability with $GETJPI.
;
;	V02-041	LJK0070		Lawrence J. Kenah	29-Sep-1981
;		Add R8..R11 to register save mask for $IMGACT service.
;
;	V02-040	LMK0003		Len Kawell		03-Sep-1981
;		Change dispatcher CASE offsets to use .SIGNED_WORD to
;		catch truncation errors.
;
;	V02-039	TMH0039		Tim Halvorsen		29-Aug-1981
;		Expand register save masks for CANCEL, DASSGN and DALLOC
;
;	V02-038	LJK0056		Lawrence J. Kenah	29-Aug-1981
;		Add image address fixup service
;
;	V02-037	LJK0055		Lawrence J. Kenah	29-Aug-1981
;		Add access mode parameter to image activator
;
;	V02-036 JAY0001		John A. Ywoskus		25-Aug-1981
;		Add new service GETSYI.
;
;	V02-035	BLS0066		Benn Schreiber		 5-Aug-1981
;		Remove global macro invocations, change module name
;		to contain a dollar sign.
;
;	V02-034	KTA0022		Kerbey T. Altmann	10-Jun-1981
;		Added new entry points for CHMx services to check
;		for inhibited services.
;
;	V02-033	KTA0021		Kerbey T. Altmann	06-Jun-1981
;		Added new services SETSSF and SETSTK.
;
;	V02-032	KTA0016		Kerbey T. Altmann	12-May-1981
;		Added extra check on possible ACCVIO to ignore the
;		error if not a VMS system service.
;
;	V02-031	KDM0047		Kathleen D. Morse	25-Mar-1981
;		Only lower IPL to 0 if system service failure mode
;		is enabled, and only for kernel system services.
;
;	V02-030 SRB0012		Steve Beckhardt		24-Mar-1981
;		Added GCOMPSRVB and GCOMPSRVE macros for generating
;		composite system service entry vectors.
;		Added $ENQW entry vector.
;
;	V02-029	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to use CTL$GL_PCB instead.
;
;	V02-028	WMC0002		Wayne M. Cardoza	27-Jan-1981
;		Change method of avoiding having some symbols generated in P1.
;
;	V02-027	CNH0048		Chris Hume		19-Jan-1981
;		Fixed system sources that have an extra comma in their
;		macro calls.
;
;	V02-026	ACG0138		Andrew C. Goldstein,	7-Jan-1981  11:41
;		Add entry vector for condition handler search,
;		add extra RSB to condition handler call vector
;
;	V02-025	SRB0008		Steve Beckhardt		06-Jan-1981
;		Added second region for system service vector
;		definitions.  Also added vector definitions for $ENQ
;		and $DEQ.
;
;	V02-024	RIH0011		Richard I. Hustvedt	05-Jan-1981
;		Make exec mode exceptions correctly delete process.
;
;	V02-023	WMC0001		Wayne Cardoza		05-Jul-1980
;		Add new conditional and code for generating the P1 space
;		system service vector definitions.
;
;
; CHANGE MODE SYSTEM SERVICE DISPATCHER
;
; MACRO LIBRARY CALLS
;
 
	$CHFDEF				;DEFINE CONDITION HANDLING OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PHDDEF				;DEFINE PHD OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
	$SGNDEF				;DEFINE SYSGEN PARAMETERS
;
; LOCAL EQUATES
;
	CAT0 =		1@0
	CAT7 =		1@7
	DEF_MASK =	CAT0!CAT7	;INHIBIT FOR 'ALL' AND 'NOT EXIT'
	EXC_MASK =	CAT7		;INHIBIT ONLY FOR 'ALL' CASE
;
; LOCAL MACROS
;
;	GSYSSRV	- GENERATE SYSTEM SERVICE ENTRY VECTOR
;
;	GSYSSRV	SRVNAME,MODE,NARG,REGISTERS,MASK,NOSYNC
;
;	WHERE:
;		SRVNAME - SERVICE NAME LESS ANY PREFIX (SYS$,EXE$,RMS$$)
;		MODE - MODE DESIGNATOR FOR SERVICE (K,E,ALL,R)
;		NARG - REQUIRED NUMBER OF ARGUMENTS
;		REGISTERS - REGISTER SAVE LIST
;		MASK - SERVICE INHIBIT MASK(BIT SET IN CAT INHIBITS)
;		NOSYNC - NON-ZERO IF RMS SYNCHRONIZATION CODE NOT TO BE INCLUDED
;

	.MACRO	GSYSSRV,SRVNAME,MODE,NARG,REGS,MASK=DEF_MASK,NOSYNC
	.IF	NDF,RMSSWITCH
	.IF	DF,LIBSWITCH
	.PSECT	$$$0000,QUAD
	.IFF
	.PSECT	$$$000,QUAD
	.ENDC
	.ALIGN	QUAD
	.IF DF	LIBSWITCH
SYS$'SRVNAME::
	.IFF
	.WORD	^M<REGS>
	.IF B	NOSYNC
	SRV'MODE	SRVNAME,NARG,MASK
	.IFF
	SRV'MODE	SRVNAME,NARG,MASK,NOSYNC
	.ENDC
	.IFT
	.BLKL	2	
	.ENDC
	.IFF
	SRV'MODE	SRVNAME,NARG,MASK
	.ENDC
	.ENDM	GSYSSRV

;
;	GCOMPSRVB - GENERATE COMPOSITE SYSTEM SERVICE ENTRY VECTOR BEGIN
;
;	GCOMPSRVB  SRVNAME,REGISTERS
;
;	WHERE:
;		SRVNAME - SERVICE NAME LESS ANY PREFIX (SYS$, EXE$)
;		REGISTERS - REGISTER SAVE LIST
;

	.MACRO	GCOMPSRVB,SRVNAME,REGS
	.IF	NDF,RMSSWITCH
	.IF	DF,LIBSWITCH
	.PSECT	$$$0000,QUAD
	.IFF
	.PSECT	$$$000,QUAD
	.ENDC
	.ALIGN	QUAD
	.IF DF	LIBSWITCH
SYS$'SRVNAME::
	.IFF
	.ENABL	LSB
COMPSTRT=.
	.WORD	^M<REGS>
	.ENDC
	.ENDC
	.ENDM	GCOMPSRVB

;
;	GCOMPSRVE - GENERATE COMPOSITE SYSTEM SERVICE ENTRY VECTOR END
;
;	GCOMPSRVE	QUADWORDS
;
;	WHERE:
;		QUADWORDS - NUMBER OF QUADWORDS TO RESERVE FOR VECTOR
;

	.MACRO	GCOMPSRVE,QUADS
	.IF	NDF,RMSSWITCH
	.IF	DF,LIBSWITCH
	.BLKQ	QUADS
	.IFF
COMPSIZE=.-COMPSTRT
	.IF	GE,QUADS*8-COMPSIZE
	.BLKB	QUADS*8-COMPSIZE
	.IFF
	.ERROR		; VECTOR EXCEEDS ALLOCATED SIZE ;
	.ENDC
	.DSABL	LSB
	.ENDC
	.ENDC
	.ENDM	GCOMPSRVE


;
;	SRVK - GENERATE ENTRY FOR KERNEL MODE SERVICE
;
;	SRVK	SRVNAME,NARG,MASK
;
 
	.MACRO	SRVK,SRVNAME,NARG,MASK
	.IF	NDF,RMSSWITCH
CMK$C_'SRVNAME=KCASCTR
	CHMK	#SRVNAME
	RET
	.PSECT	Y$CMODKN,BYTE
	ASSUME NARG LE 127
	.BYTE	NARG
	.PSECT	Y$CMODKX,BYTE
	.BYTE	MASK
	.PSECT	Y$CMODK,BYTE
	.SIGNED_WORD	EXE$'SRVNAME-KCASE+2
SRVNAME=KCASCTR
KCASCTR=KCASCTR+1
	.ENDC
	.ENDM	SRVK

;
;	SRVE - GENERATE ENTRY FOR EXECUTIVE MODE SERVICE
;
 
	.MACRO	SRVE,SRVNAME,NARG,MASK
	.IF	NDF,RMSSWITCH
CME$C_'SRVNAME=ECASCTR
	CHME	#SRVNAME
	RET
	.PSECT	Y$CMODEN,BYTE
	ASSUME NARG LE 127
	.BYTE	NARG
	.PSECT	Y$CMODEX,BYTE
	.BYTE	MASK
	.PSECT	Y$CMODE,BYTE
	.SIGNED_WORD	EXE$'SRVNAME-ECASE+2
	.ENDC
SRVNAME=ECASCTR
ECASCTR=ECASCTR+1
	.ENDM	SRVE
;
;
;    MACROS FOR GENERATING RMS SYSTEM VECTORS
;
	.MACRO	RMSSRV	SRVNAME	NARG=1,REGS=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>,-
			MASK,NOSYNC=0
	GSYSSRV	SRVNAME,R,NARG,<REGS>,MASK,NOSYNC
	.ENDM	RMSSRV
;
;  SRVR - GENERATE ENTRY FOR RMS SERVICE (EXEC MODE)
;
	.MACRO	SRVR	SRVNAME,NARG,MASK,NOSYNC
	.IF	NDF,RMSSWITCH
CME$C_'SRVNAME=RCASCTR
	CHME	#SRVNAME
	.IF EQ NOSYNC
	.IIF GT <.+2-RMSSYNC>-127, RMSSYNC=RMSWBR	;RESET BRANCH DESTINATION
RMSWBR=.
	BRB	RMSSYNC
	.IFF
	RET
	.ENDC
	.PSECT	Y$CMODEN,BYTE
	ASSUME NARG LE 127
	.BYTE	NARG
	.PSECT	Y$CMODEX,BYTE
	.BYTE	MASK
	.IFF
	.PSECT	$$$RMSVEC,BYTE,NOWRT
	.SIGNED_WORD	RMS$'SRVNAME-RCASE+2
	.ENDC
SRVNAME=RCASCTR
RCASCTR=RCASCTR+1
	.ENDM	SRVR

;
;	SRVALL - GENERATE ENTRY FOR ALL MODE SERVICE
;
 
	.MACRO	SRVALL,SRVNAME,NARG,MASK
	.IF NDF,RMSSWITCH
	JMP	@#EXE$'SRVNAME+2
	.ENDC
	.ENDM	SRVALL

	.IF	DF,RMSSWITCH
	.NLIST	CND
ECASCTR=0
	.IFF
	.IF	NDF,LIBSWITCH

;
; GLOBAL SYMBOLS
;
 
EXE$C_CMSTKSZ==4*5			;NUMBER OF LONGWORDS IN DISPATCH CALL FRAME
	.PAGE
	.SBTTL	CHANGE MODE TO EXECUTIVE DISPATCHER
;+
; EXE$CMODEXEC - CHANGE MODE TO EXECUTIVE DISPATCHER
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A CHANGE MODE TO EXECUTIVE
; INSTRUCTION IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
; INPUTS:
;
;	00(SP) = CHANGE MODE PARAMETER CODE.
;	04(SP) = SAVED PC OF EXCEPTION.
;	08(SP) = SAVED PSL OF EXCEPTION.
;
;	00(AP) = NUMBER OF SYSTEM SERVICE CALL ARGUMENTS.
;	04(AP) = FIRST ARGUMENT.
;	      .
;	      .
;	      .
;	4*N(AP) = N'TH ARGUMENT.
;
; OUTPUTS:
;
;	***TBS***
;
; NOTE:
;
;	DISPATCH TO RMS ROUTINES ASSUMES THAT R3, R4, & R8 ARE NOT DESTROYED
;	BY THE THE SERVICE EXIT CODE FOR SUCCESSFUL RETURNS.
;-
 
	.PSECT	Y$CMODEX,BYTE		;START OF THE MASK TABLE
B_EMASK:
	.PSECT	Y$CMODE,QUAD
EXACCVIO:				;CHANGE MODE TO EXEC ACCESS VIOLATION
	MOVL	SP,FP			;SET FP TO POINT TO CALL FRAME
	CMPW	R0,#RCASCTR		;IS THIS A BUILTIN OR RMS FUNCTION?
	BGEQU	EXEDSP			;NO, NOT NECESSARILY ACCVIO
	BRW	ACCVIO_RET		;
EXE$EXCPTNE::				;EXECMODE SYSTEM SERVICE EXCEPTION
	.WORD	0			;NULL ENTRY MASK
	BUG_CHECK SSRVEXCEPT		;NON-FATAL EXCEPTION IF IN EXEC MODE
	MOVL	CHF$L_SIGARGLST(AP),R1	;GET ADDRESS OF SIGNAL ARGUMENTS
	$EXIT_S	CHF$L_SIG_NAME(R1)	;AND EXIT WITH SIGNAL AS STATUS
EXINSARG:				;CHANGE MODE TO EXEC INSUFFICIENT ARGS
	CMPW	R0,#RCASCTR		;IS THIS A BUILTIN OR RMS FUNCTION?
	BGEQU	EXEDSP			;NO, NOT NECESSARILY INSARG
	BRW	INSARG			;
	.ALIGN	QUAD
EXE$CMODEXECX::
	BICL3	8(SP),#PSL$M_CURMOD,R0	;CHECK THE PREVIOUS MODE
	BNEQ	EXE$CMODEXEC		;NO CHECK NEEDED FOR NON-USER MODE
	MOVZBL	(SP),R0			;PICK UP THE CHME CODE (MOD 256)
	BITB	W^B_EMASK[R0],@#CTL$GB_SSFILTER	;'AND' WITH THE INHIBIT MASK
	BEQL	EXE$CMODEXEC		;THIS CODE IS ALLOWED
	MOVZWL	#SS$_INHCHME,R1		;SET THE EXECPTION CODE
	BRW	INHEXCP			;AND REFLECT IT
	.ALIGN	QUAD
EXE$CMODEXEC::				;CHANGE MODE TO EXECUTIVE DISPATCH
					;NOTE: MEMORY WRITING INSTRUCTIONS ARE
					;CAREFULLY INTERLACED WITH REGISTER TO
					;REGISTER OPERATIONS FOR SPEED.
	POPL	R0			;REMOVE CHANGE MODE PARAMETER FROM STACK
	PUSHAB	W^SRVEXIT		;RETURN ADDRESS FOR CALL FRAME
	MOVZBL	R0,R1			;BOUND RANGE OF CHME CODE VALUES
	PUSHL	FP			;SAVE FP
	MOVZBL	W^B_EXECNARG[R1],R1	;GET REQUIRED NUMBER OF ARGUMENTS
	PUSHL	AP			;SAVE AP
	MOVAL	@#4[R1],FP		;CALCULATE LENGTH OF ARGUMENT LIST
	CLRQ	-(SP)			;PSW, REGISTER SAVE MASK FOR CALL FRAME
	IFNORD	FP,(AP),EXACCVIO	;BR IF ARGLIST INACCESSIBLE
	MOVL	SP,FP			;SET FP TO POINT TO CALL FRAME
	CMPB	(AP),R1			;CHECK FOR REQUIRED NUMBER OF ARGUMENTS
	BLSSU	EXINSARG		;INSUFFICIENT NUMBER OF ARGUMENTS
					;  (R0 HAS CHME CODE)
EXEDSP:	CASEW	R0,#0,S^#ECASMAX	;DISPATCH TO PROPER SERVICE ROUTINE
ECASCTR=0				;START WITH 0 FOR CHME CODE
ECASE:					;BASE OF CHME CASE TABLE
	.PSECT	Y$CMODEN,BYTE		;REQUIRED NUMBER OF ARG TABLE
B_EXECNARG:				;DEFINE TABLE BASE

;
;	NOTE THAT THE OUT OF RANGE FALL THROUGH FROM THE CASEW FOLLOWS
;	THE SYSTEM SERVICE VECTOR GENERATION.
	.PAGE
	.SBTTL	ASTEXIT SYSTEM SERVICE
;+
; ASTEXIT - SERVICE TO EXIT AN ACTIVE AST AND ALLOW PENDING ASTS TO 
;	    BE DELIVERED.
;
; THIS SYSTEM SERVICE IS INVOKED WITH A CHMK #ASTEXIT NOT CONTAINED IN
; A STANDARD SYSTEM SERVICE VECTOR TO AVOID CLUTTERING THE STACK WITH AN
; ADDITIONAL CALL FRAME DURING AST EXIT PROCESSING.
;
; INPUTS:
; 	NONE
;
; OUTPUTS:
;	PCB$B_ASTACT IS CLEARED FOR THE ISSUING MODE
;	PHD$B_ASTLVL IS SET TO THE ACCESS MODE OF THE NEXT PENDING AST, IF ANY.
;
;-

	.PSECT	Y$CMODK,QUAD
INHEXCP1:
	MOVL	12(SP),FP		;PICK UP THE OLD FP FROM FRAME
	ADDL	#5*4,SP			;CLEAN OFF THE FRAME
	PUSHL	R0			;RESTORE THE CHMX CODE
INHEXCP:PUSHL	R1			;PUSH THE EXECPTION CODE
	PUSHL	#4			;PUSH THE NUMBER OF ARGUMENTS
	JMP	G^EXE$REFLECT		;REFLECT THE EXCEPTION

CHECKARGLIST:				;CHECK ARGUMENT LIST FOR ACCESSIBILITY
	IFNORD	#4,(AP),ACCVIO_RET	;IS COUNT READABLE?
	CVTBL	(AP),R1			;GET COUNT
	BLSS	10$			;IF LSS, 128 OR MORE ARGS
	ASHL	#2,R1,R1		;CONVERT TO BYTE COUNT
	IFNORD	R1,4(AP),ACCVIO_RET	;IS ARUMENT LIST READABLE?
	RSB				;

10$:	MOVZBL	R1,R1			;ZERO HIGH THREE BYTES
	ASHL	#2,R1,R1		;CONVERT TO BYTE COUNT
	PUSHL	R0			;SAVE REGISTERS
	PUSHL	R2
	PUSHL	R3
	MOVAL	4(AP),R0		;GET ADDRESS
	CLRL	R3			;ACCESS MODE
	JSB	EXE$PROBER		
	POPL	R3			;RESTORE REGISTERS
	POPL	R2
	BLBC	R0,20$			;IF LBC, ACCESS VIOLATION
	POPL	R0
	RSB				;RETURN

20$:	POPL	R0
	BRB	ACCVIO_RET		;RETURN ERROR

	.ALIGN  QUAD			;** THIS IS ADDED TO FIX
					;** A BROKEN BRANCH INST. -
					;** BEQL ASTEXIT IN EXE$CMODKRNL
						
ASTEXIT:				;EXIT ACTIVE AST
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,4(SP),R0 ;GET PREVIOUS MODE
	PUSHL	R2			;SAVE R2 (PUSHR IS SLOWER!)
	PUSHL	R4			;SAVE R4
	MOVL	SCH$GL_CURPCB,R4	;GET PCB CURRENT PCB ADDRESS
	SETIPL	#IPL$_ASTDEL		;DISABLE KERNEL AST DELIVERY
	BBCCI	R0,PCB$B_ASTACT(R4),10$	;CLEAR AST ACTIVE BIT FOR MODE
10$:	BSBW	SCH$NEWLVL		;COMPUTE NEW AST LEVEL SETTING
	POPL	R4			;RESTORE R4
	POPL	R2			;RESTORE R2
	REI				;AND EXIT
	.PAGE
	.SBTTL	CHANGE MODE DETECTED ERROR HANDLING
;+
; ACCVIO - ACCESS VIOLATION DETECTED IN ARGUMENT LIST
; INSARG - INSUFFICIENT ARGUMENTS SUPPLIED FOR SERVICE
; SSFAIL - ABNORMAL STATUS RETURNED BY SERVICE ROUTINE
;
; THESE ROUTINES TAKE THE APPROPRIATE ACTION TO RETURN THE ERROR INDICATION
; TO THE ORIGINAL CALLER.
;
;-
ACCVIO:					;
	MOVL	SP,FP			;SET FRAME POINTER BEFORE RET
	CMPW	R0,#KCASCTR		;IS THIS AN UNRECOGNIZED CODE?
	BGEQU	KERDSP			;YES, NOT NECESSARILY ACCVIO
ACCVIO_RET:				;
	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION
	RET				;

KINSARG:CMPW	R0,#KCASCTR		;IS THIS AN UNRECOGNIZED CODE?
	BGEQU	KERDSP			;YES, NOT NECESSARILY INSARG
INSARG:	MOVZWL	#SS$_INSFARG,R0		;SET INSUFFICIENT NUMBER OF ARGUMENTS
	RET				;
SRVEXIT:				;SERVICE EXIT
	BLBC	R0,SSFAIL		;BR IF ABNORMAL COMPLETION
SRVREI:	REI				;
EXE$EXCPTN::				;SYSTEM SERVICE EXCEPTION
	.WORD	0			;ENTRY MASK
	BUG_CHECK SSRVEXCEPT,FATAL	;UNEXPECTED SYSTEM SERVICE EXCEPTION
SSFAIL:	BITL	#7,R0			;TEST SEVERITY FIELD
	BEQL	SRVREI			;IF EQL WARNING
	BRW	SSFAILMAIN		;GOTO MAIN SSFAIL LOGIC
	.PAGE
	.SBTTL	CHANGE MODE TO KERNEL DISPATCHER
;+
; EXE$CMODKRNL - CHANGE MODE TO KERNEL DISPATCHER
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A CHANGE MODE TO KERNEL
; INSTRUCTION IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
; INPUTS:
;
;	00(SP) = CHANGE MODE PARAMETER CODE.
;	04(SP) = SAVED PC OF EXCEPTION.
;	08(SP) = SAVED PSL OF EXCEPTION.
;
;	00(AP) = NUMBER OF SYSTEM SERVICE CALL ARGUMENTS.
;	04(AP) = FIRST ARGUMENT.
;	      .
;	      .
;	      .
;	4*N(AP) = N'TH ARGUMENT.
;
; OUTPUTS:
;
;	***TBS***
;-
 
	.PSECT	Y$CMODKX,BYTE		;START OF THE MASK TABLE
B_KMASK:
	.BYTE	0			;ALLOW FOR ASTEXIT (CHMK #0)!!!
	.PSECT	Y$CMODK,QUAD
	.ALIGN	QUAD
EXE$CMODKRNLX::
	BICL3	8(SP),#PSL$M_CURMOD,R0	;CHECK THE PREVIOUS MODE
	BNEQ	EXE$CMODKRNL		;NO CHECK NEEDED FOR NON-USER MODE
	MOVZBL	(SP),R0			;PICK UP THE CHMK CODE
	BITB	W^B_KMASK[R0],@#CTL$GB_SSFILTER	;'AND' WITH THE INHIBIT MASK
	BEQL	EXE$CMODKRNL		;THIS CODE IS ALLOWED
	MOVZWL	#SS$_INHCHMK,R1		;SET THE EXECPTION CODE
	BRW	INHEXCP			;AND REFLECT IT
	.ALIGN	QUAD
EXE$CMODKRNL::				;CHANGE MODE TO KERNEL DISPATCH
					;NOTE: MEMORY WRITING INSTRUCTIONS ARE
					;CAREFULLY INTERLACED WITH REGISTER
					;INSTRUCTIONS FOR SPEED.
	POPL	R0			;REMOVE CHANGE MODE PARAMETER FROM STACK
	BEQL	ASTEXIT			;IF ZERO, AST EXIT SYSTEM SERVICE
	PUSHAB	B^SRVEXIT		;RETURN ADDRESS
	MOVZBL	R0,R1			;BOUND RANGE OF CHMK CODES TO 0,255
					;AND 256 BYTES ACCESSIBLE FROM B_KRNLNARG
	PUSHL	FP			;SAVE FP
	MOVZBL	W^B_KRNLNARG[R1],R1	;GET NUMBER OF REQUIRED ARGUMENTS
	PUSHL	AP			;SAVE AP
	MOVAL	@#4[R1],FP		;CALCULATE LENGTH OF ARGUMENT LIST
	CLRQ	-(SP)			;PSW AND REGISTER SAVE MASK
	IFNORD	FP,(AP),ACCVIO		;DECLARE ACCESS VIOLATION
	MOVL	SP,FP			;SET FRAME POINTER FOR CALL FRAME
	CMPB	(AP),R1			;CHECK FOR REQUIRED NUMBER OF ARGS
	BLSSU	KINSARG			;IF LSSU, INSUFFICIENT ARGUMENTS
KERDSP:	MOVL	SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	CASEW	R0,#1,#KCASMAX		;DISPATCH TO PROPER SERVICE ROUTINE
KCASE:					;BASE OF CHMK CASE TABLE
KCASCTR=1				;CHMK CODES START AT 1
	.PSECT	Y$CMODKN,BYTE		;REQUIRED NUMBER OF ARG TABLE
B_KRNLNARG=.-1				;CHMK CODES ARE 1 ORIGIN
	.ENDC
	.IFF
	.PAGE
	.SBTTL	SYSTEM SERVICE VECTOR DEFINITION
;
;
;	DEFINE ALL SYSTEM SERVICE VECTOR POSITIONS
;
;

	.IF	NDF,LIBSWITCH		;REAL PSECT IF NOT LIBRARY
	.PSECT	$$$000,QUAD
	.IFF				;OTHERWISE ABS PSECT
	.PSECT	$$$0000,QUAD,ABS
	.IF	NDF,P1VSWITCH
.=^X80000000				;BIASED AT THE START OF SYSEM SPACE
	.IFF
.=^X7FFEDE00 				;BIASED IN P1 SPACE
	.ENDC
	.ENDC
	.IFF
VECBASE:					;VECTOR AREA BASE

;
;	QIO AND WAIT COMPOSITE SERVICE
;
;	THE QIO AND WAITFR COMPOSITE SERVICE OCCUPIES THE FIRST TWO
;	SYSTEM SERVICE VECTOR POSITIONS.  IT IS CONSTRUCTED BY
;	FROM TWO DISCRETE CHMK INSTRUCTIONS, ONE PERFORMING THE QIO
;	AND THE OTHER PERFORMING THE WAITFR, WHICH RELY UPON THE
;	COMPATIBLE ARGUMENT LISTS OF THESE TWO SERVICES. WAITFR HAS
;	A SINGLE ARGUMENT, THE EVENT FLAG, WHICH IS THE FIRST ARGUMENT
;	IN THE QIO ARGUMENT LIST.
;

 	.ALIGN	QUAD
	.IF DF	LIBSWITCH
SYS$QIOW::				;QIO AND WAIT SYSTEM SERVICE
	.IFF
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;SAVE R2-R11
	CHMK	#QIO			;FIRST QIO
	BLBC	R0,10$			;SKIP WAIT IF ERROR
	CHMK	#WAITFR			;THEN WAIT FOR SINGLE EVENT
10$:	RET				;RETURN
	.IFT
	.BLKL	4			;JUST RESERVE SPACE IF LIBRARY
	.ENDC
	.IFF
 
;
; CONDITION HANDLER DISPATCH VECTOR
;
; THE FOLLOWING VECTOR IS INCLUDED IN THE SYSTEM VECTOR SPACE SO THAT BOTH
; HARDWARE-DETECTED (EXCEPTIONS) AND SOFTWARE-DETECTED (SIGNALS) CONDITIONS
; CAN BE DISPATCHED FROM THE SAME CALL INSTRUCTION. THIS IS NECESSARY SO
; THAT THE STACK SEARCH ALGORITHM AND THE UNWIND SYSTEM SERVICE CAN DETECT
; AND PROPERLY PROCESS MULTIPLE ACTIVE SIGNALS AND/OR EXCEPTIONS.
;
 
	.ALIGN	QUAD
	.IF DF	LIBSWITCH
	.IF DF	P1VSWITCH		;DON'T PUT IN P1
SYS$CALL_HANDL == . - ^X7FFEDE00 + ^X80000000
	.IFF
SYS$CALL_HANDL::			;CONDITION HANDLER DISPATCH
	.ENDC	
	.IFF
	CALLG	4(SP),(R1)		;CALL CONDITION HANDLER
	RSB				;
	.IFT
	.BLKQ	1			;RESERVE SPACE
	.ENDC
	.IFF
 
;
; COMMAND INTERPRETER DISPATCH VECTOR
;
; THE FOLLOWING VECTOR IS INCLUDED IN THE SYSTEM VECTOR SPACE SO THAT DIRECT
; CALLS CAN BE MADE TO THE CURRENT COMMAND INTERPRETER WITHOUT HAVING TO KNOW
; THE ADDRESS OF ITS SERVICE ROUTINE.
;
 
	.ALIGN	QUAD
	.IF DF	LIBSWITCH

SYS$CLI::				;COMMAND INTERPRETER DISPATCH
	.IFF
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;SAVE R2-R11
	JMP	CLIJMP			;INDIRECT DISPATCH TO CURRENT COMMAND INTERPRETER
	.IFT
	.BLKQ	1			;RESERVE SPACE
	.ENDC
	.IFF
	.ALIGN	QUAD
	.ENDC
 
;
;	DEFINE REMAINING SERVICES
;

	GSYSSRV	ADJSTK,K,3,-		;ADJUST OUTER MODE STACK POINTER
		<R2,R3,R4,R5,R6>,-	;REGISTERS R2-R6
		EXC_MASK		;EXCEPTION MASK
	GSYSSRV	ADJWSL,K,2,-		;ADJUST WORKING SET LIMIT
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	ALCDNP,K,4,-		;ALLOCATE DIAGNOSTIC PAGE
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R7
	GSYSSRV	ALLOC,K,4,-		;ALLOCATE DEVICE
		<R2,R3,R4,R5,R6>	;REGISTERS R2-R6
	GSYSSRV	ASCEFC,K,4,-		;ASSOCIATE COMMON EVENT FLAG CLUSTER
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	ASCTIM,ALL,3,-		;CONVERT TO ASCII TIME
		<R2,R3,R4,R5,R6>	;REGISTERS R2-R6
	GSYSSRV	ASSIGN,K,4,-		;ASSIGN I/O CHANNEL
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	BINTIM,ALL,2,-		;CONVERT TO BINARY TIME
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	CANCEL,K,1,-		;CANCEL I/O ON CHANNEL
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	CANTIM,K,2,-		;CANCEL TIMER REQUEST
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	CANWAK,K,2,-		;CANCEL WAKE UP REQUESTS
		<R2,R3,R4,R5>		;REGISTERS R2-R5
;
; ***** THE FOLLOWING IS OUT OF ALPHABETIC ORDER AS ITS NAME WAS CHANGED
;
	GSYSSRV	CRMPSC,K,12,-		;CREATE AND MAP SECTION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	CLRPAR,K,2,-		;CLEAR HARD PARITY ERROR
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	CMEXEC,E,2,-		;CHANGE MODE TO EXECUTIVE
		<R4>			;REGISTER R4
	GSYSSRV	CMKRNL,K,2,-		;CHANGE MODE TO KERNEL
		<R4>			;REGISTER R4
	GSYSSRV	CLREF,K,1,-		;CLEAR EVENT FLAG
		<R2,R3,R4,R5>		;REGISTERS R2-R5. SEE WAITFR COMMENTS.
	GSYSSRV	CNTREG,K,4,-		;CONTRACT REGION
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R7
	GSYSSRV	GETPTI,K,5,-		;GET PAGE TABLE INFORMATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10> ;REGISTERS R2-R10
	GSYSSRV	CRELOG,K,4,-		;CREATE LOGICAL NAME
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	CREMBX,K,7,-		;CREATE MAILBOX
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	CREPRC,K,12,-		;CREATE PROCESS
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	CRETVA,K,3,-		;CREATE VIRTUAL ADDRESS
		<R2,R3,R4,R5,R6,R7,R8>,-;REGISTERS R2-R8
		EXC_MASK		;EXCEPTION MASK
	GSYSSRV	DACEFC,K,1,-		;DISASSOCIATE EVENT FLAG CLUSTER
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	DALLOC,K,2,-		;DEALLOCATE DEVICE
		<R2,R3,R4,R5,R8>	;REGISTERS R2-R5,R8
	GSYSSRV	DASSGN,K,1,-		;DEASSIGN I/O CHANNEL
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	DCLAST,K,3,-		;DECLARE AST SYSTEM SERVICE
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	DCLEXH,K,1,-		;DECLARE EXIT HANDLER
		<R2,R3,R4>		;REGISTERS R2-R4
	GSYSSRV	DELLOG,K,3,-		;DELETE LOGICAL NAME
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	DELMBX,K,1,-		;DELETE MAILBOX
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	DELPRC,K,2,-		;DELETE PROCESS
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R5
	GSYSSRV	DELTVA,K,3,-		;DELETE VIRTUAL ADDRESS
		<R2,R3,R4,R5,R6,R7>,-	;REGISTERS R2-R7
		EXC_MASK		;EXCEPTION MASK
	GSYSSRV	DGBLSC,K,3,-		;DELETE GLOBAL SECTION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10> ;REGISTERS R2-R10
	GSYSSRV	DLCDNP,K,2,-		;DEALLOCATE DIAGNOSTIC PAGE
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R7
	GSYSSRV	DLCEFC,K,1,-		;DELETE COMMON EVENT CLUSTER
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	UPDSEC,K,8,-		;UPDATE SECTION FILE
		<R2,R3,R4,R5,R6,R7,R8>	;R2-R8
	GSYSSRV	SNDERR,K,1,-		;SEND MSG TO ERROR LOGGER
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	EXIT,K,1,-		;IMAGE EXIT
		<R4>,0			;REGISTER R4, ALWAYS ALLOWED!
	GSYSSRV	EXPREG,K,4,-		;EXPAND PROGRAM REGION
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	FAO,ALL,0,-		;FORMAT ASCII OUTPUT
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTERS R2-R11
	GSYSSRV	FAOL,ALL,0,-		;FORMAT ASCII OUTPUT WITH VALUE LIST
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	FORCEX,K,3,-		;FORCE EXIT
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	IMGSTA,ALL,6,-		;IMAGE STARTUP
		<>			;REGISTERS NONE
	GSYSSRV	GETJPP,K,2,-		;GET JOB/PROCESS PARAMETERS
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	GETTIM,E,1,-		;GET TIME
		<>			;NO REGISTERS
	GSYSSRV	GTCHAN,K,5,-		;GET I/O CHANNEL DEVICE INFORMATION
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	HIBER,K,0,-		;HIBERNATE
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	IMGACT,E,8,-		;IMAGE ACTIVATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	LCKPAG,K,3,-		;LOCK PAGE IN MEMORY
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	LKWSET,K,3,-		;LOCK PAGES IN WORKING SET
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	MGBLSC,K,7,-		;MAP GLOBAL SECTION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	PURGWS,K,1,-		;PURGE WORKING SET
		<R2,R3,R4,R5,R6,R7,R8>	;R2-R8
	GSYSSRV	NUMTIM,E,2,-		;CONVERT TIME TO NUMERIC
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R7
	GSYSSRV	SNDOPR,E,2,-		;SEND MSG TO OPERATOR
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	;REGISTERS R2-R11
	GSYSSRV	QIO,K,12,-		;QUEUE I/O REQUEST
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	READEF,K,2,-		;READ EVENT FLAG
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	RESUME,K,2,-		;RESUME PROCESS
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	RUNDWN,K,1,-		;RUNDOWN
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R7
	GSYSSRV	SNDSMB,E,2,-		;SEND MSG TO SYMBIONT MANAGER
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	;REGISTERS R2-R11
	GSYSSRV	SCHDWK,K,4,-		;SCHEDULE WAKEUP
		<R2,R3,R4,R5,R6,R7,R8,R9> ;REGISTERS R2-R9
	GSYSSRV	SETAST,K,1,-		;SET AST ENABLE SERVICE
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	SETEF,K,1,-		;SET EVENT FLAG
		<R2,R3,R4,R5>		;REGISTERS R2-R5. SEE WAITFR COMMENTS.
	GSYSSRV	SETEXV,K,4,-		;SET EXCEPTION VECTOR
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	SETPRN,K,1,-		;SET PROCESS  NAME
		<R2,R3,R4,R5,R6,R7>	;REGISTERS R2-R7
	GSYSSRV	SETPRA,K,2,-		;SET POWER RECOVERY AST
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	SETIMR,K,4,-		;SET TIMER
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	SETPRI,K,4,-		;SET PROCESS PRIORITY
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	SETPRT,K,5,-		;SET PAGE PROTECTION
		<R2,R3,R4,R5,R6,R7,R8,R9> ;REGISTERS R2-R9
	GSYSSRV	SETRWM,K,1,-		;SET RESOURCE WAIT MODE
		<R4>			;REGISTER R4
	GSYSSRV	SETSFM,K,1,-		;SET SYSTEM SERVICE FAILURE MODE
		<R4>,EXC_MASK		;REGISTER R4, AND EXECPTION MASK
	GSYSSRV	SETSWM,K,1,-		;SET PROCESS SWAP MODE
		<R4>			;REGISTER R4
	GSYSSRV	SUSPND,K,2,-		;SUSPEND PROCESS
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	TRNLOG,K,6,-		;TRANSLATE LOGICAL NAME
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	ULKPAG,K,3,-		;UNLOCK PAGE FROM MEMORY
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	ULWSET,K,3,-		;UNLOCK PAGES FROM WORKING SET
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	UNWIND,ALL,2,-		;UNWIND PROCEDURE CALL STACK
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	WAITFR,K,1,-		;WAIT FOR EVENT FLAG
		<R2,R3,R4,R5,R6>	;REGISTERS R2-R6.  IF R8 IS EVER USED
					;THE RMS SYCHRONIZATION CODE MUST BE
					;MODIFIED TO SAVE IT ALSO.
	GSYSSRV	WAKE,K,2,-		;WAKE PROCESS
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	WFLAND,K,2,-		;WAIT FOR LOGICAL AND OF EVENT FLAGS
		<R2,R3,R4,R5,R6>	;REGISTERS R2-R6
	GSYSSRV	WFLOR,K,2,-		;WAIT FOR LOGICAL OR OF EVENT FLAGS
		<R2,R3,R4,R5,R6>	;REGISTERS R2-R5
	GSYSSRV	BRDCST,K,2,-		;BROADCAST TO TERMINALS
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	DCLCMH,K,3,-		;DECLARE CHANGE MODE HANDLER
		<R4>			;SAVE R4
	GSYSSRV	SETPFM,K,1,-		;SET PAGE FAULT MONITORING
		<R2,R3,R4,R5,R6,R7,R8>	;REGISTERS R2-R8
	GSYSSRV	GETMSG,ALL,5,-		;GET MESSAGE
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	DERLMB,K,1,-		;DECLARE ERROR LOG MAILBOX
		<R2,R3,R4,R5>		;REGISTERS R2-R5
	GSYSSRV	CANEXH,K,1,-		;CANCEL EXIT HANDLER
		<R2,R3,R4>		;REGISTERS R2-R4
	GSYSSRV	GETCHN,K,5,-		;GET CHANNEL INFORMATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	GETDEV,K,5,-		;GET DEVICE INFORMATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	GETJPI,K,7,-		;GET JOB PROCESS INFORMATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	PUTMSG,ALL,3,-		;PUT FORMATTED ERROR MESSAGE
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	EXCMSG,ALL,2,-		;OUTPUT EXCEPTION SUMMARY MESSAGE
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	SNDACC,E,2,-		;SEND MSG TO ACOUNTING MANAGER
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	SETIME,K,1,-		;SET SYSTEM TIME
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTERS R2-R11
	GSYSSRV	SETPRV,K,4,-		;SET PRIVILEGES
		<R2,R3,R4,R5,R6,R7,R8> 	;REGISTERS R2-R8
		.PAGE
;
;	SPECIAL VECTORS FOR AST DELIVERY AND CLEARING
;
;	SYS$CLRAST CLEARS THE CURRENTLY ACTIVE AST STATUS
;
;	SYS$GL_ASTRET CONTAINS THE VALUE OF THE RETURN ADDRESS FROM
;	THE CALL INSTRUCTION USED TO DISPATCH AN AST. THIS VALUE CAN
;	BE USED WHEN SEARCHING UP THE STACK FOR THE AST CALL FRAME.
;
	.IF	NDF,RMSSWITCH
	.IF	DF,LIBSWITCH
	.PSECT	$$$0000,QUAD
	.IFF
	.PSECT	$$$000,QUAD
	.ENDC
	.ALIGN	QUAD
	.IF	DF,LIBSWITCH
SYS$CLRAST::				;CLEAR ACTIVE AST
	.BLKL	2			;
	.IFF
	.WORD	^M<>			;SAVE NO REGISTERS
	CHMK	#CLRAST			;DO SPECIAL CHMK
	RET				;AND RETURN
CLRAST=0				;
	.ENDC
	.ALIGN	QUAD			;
	.IF	DF,LIBSWITCH
SYS$GL_ASTRET::				;
	.BLKL	1
SYS$GL_COMMON::				;ADDRESS OF CORE COMMON DESCRIPTOR
	.BLKL	1			;
	.IFF
	.LONG	EXE$ASTRET		;RETURN ADDRESS FROM AST DISPATCHING
					;CALL
	.LONG	CTL$GQ_COMMON		;ADDRESS OF "CORE COMMON" DESCRIPTOR
	.ENDC				;

;
; ENTRY VECTOR FOR CONDITION HANDLER SEARCH. LIB$SIGNAL USES THIS VECTOR
; TO SHARE EXCEPTION'S CODE TO SEARCH FOR AND CALL CONDITION HANDLERS.
; THIS ENTRY IS NOT CALLED; RATHER, IT IS JUMPED TO. NO RETURN IS MADE.
;

	.ALIGN	QUAD
	.IF DF	LIBSWITCH
SYS$SRCHANDLER::
	.IFF
	JMP	@#EXE$SRCHANDLER	;JUMP TO COMMON CODE
	.IFT
	.BLKQ	1			;RESERVE SPACE
	.ENDC

	.ENDC				;
;
;  NOTE THAT THE CODE IN PSECT $$$000 AT THIS POINT CANNOT EXCEED 320 (HEX)
;  WITHOUT MODIFYING THE RMS SYNCHRONIZATION CODE WHICH PRECEDES THE RMS
;  VECTORS WHICH CANNOT BE MOVED.
;

.PAGE
	.IIF	NDF,LIBSWITCH,	RCASCTR=ECASCTR
	.IF	DF,RMSSWITCH
;
;  CASE DISPATCHER FOR RMS SERVICES
;
;	R0 HAS SERVICE DISPATCH CODE.
;	IF IN RANGE DISPATCHES TO APPROPRIATE RMS SERVICE,
;	ELSE SIMPLY DOES AN RSB
;
	.PSECT	$$$RMSVEC,BYTE,NOWRT	;MUST BE FIRST PSECT IN RMS
RMS$DISPATCH:				;MUST BE FIRST CODE IN FIRST RMS PSECT
	CASEW	R0,S^#RCASMIN,S^#RCASMAX

RCASE:
	.IFTF
	.IIF	NDF,LIBSWITCH,	RCASMIN=RCASCTR
	.IFF
	.PAGE
;++
;
;  RMS SERVICES
;
;
;  RMS SYNCHRONIZATION ROUTINE
;
;  THE FOLLOWING ROUTINE IS USED BY THE VARIOUS RMS SERVICES IN ORDER
;  TO AWAIT I/O COMPLETION.  THE ROUTINE IS IN THE VECTOR AREA IN ORDER
;  TO WAIT AT THE CALLER'S MODE,  THUS ALLOWING AST ACTIVITY FOR EITHER
;  USER OR SUPERVISOR MODE, OR BOTH.
;
;  THE FAB/RAB IS CHECKED FOR A LEGAL BLOCK ID, I.E., A 1 OR 3, AND
;  AN ERROR RETURNED IF INVALID.  THE STRUCTURE IS NOT REPROBED.
;
;  NOTE THAT EACH RMS SERVICE VECTOR TERMINATES WITH A BRANCH TO THIS
;  ROUTINE.
;
;  THIS ROUTINE ASSUMES THAT THE FOLLOWING REGISTERS HAVE BEEN SET BY THE
;  EXITING RMS EXEC-LEVEL CODE WHENEVER A STALL IS REQUIRED:
;
;	R3	EFN TO WAIT ON
;	R8	RAB/FAB ADDRESS TO WAIT ON
;	R4	(RMSWAIT_BR ENTRY POINT ONLY, $WAIT SERVICE) FLAG FOR WAIT TYPE
;		(0 = SAME RAB, 1 = DIFFERENT RABS)
;
;--
	.IF NDF,LIBSWITCH
	.PSECT	$$$000,QUAD
	.IFF
	.PSECT	$$$0000,QUAD
	.IFTF
	.BLKB	^X320-<.-VECBASE>
	.IFT
RMSWAIT_IO_DONE:
;
;  THE ARGUMENTS ARE PUSHED ON THE STACK AND THE AP SET UP AS IF A 'CALLS'
;  INSTRUCTION WERE BEING EXECUTED.  THE CHANGE MODE TO KERNEL SERVICE IS
;  EXECUTED DIRECTLY.  THIS SAVES THE OVERHEAD OF A 'CALLS' INSTRUCTION.
;  R8 MUST NOT BE DESTROYED BY ANY OF THE SERVICES USED HERE.
;
	PUSHL	R3			;EVENT FLAG TO WAIT FOR
	MOVAB	-4(SP),AP		;SET UP AP AS IF USING CALLS INSTR.
	PUSHL	#1			;NUMBER OF ARGUMENTS
USERWAIT:
	CHMK	I^#WAITFR		;DO 'NAKED' WAITFR TO SAVE CALLS TIME
;
;  CHECK TO SEE IF THE USER STRUCTURE POINTED TO BY R8 IS STILL VALID BY
;  CHECKING THE BLOCK ID TO BE SURE THAT IT IS EITHER A RAB (BID=1) OR
;  A FAB (BID=3).  THIS WON'T CATCH THE CASE WHERE WHAT SHOULD HAVE BEEN
;  A FAB NOW LOOKS LIKE A RAB OR VICE VERSA  BUT WILL CATCH EVERYTHING
;  ELSE.  IF THE STRUCTURE IS NOT READABLE OR WRITEABLE THEN THE USER
;  WILL GET AN ACCESS VIOLATION.  THE BID FOR A FAB/RAB IS AT BYTE 0,
;  THE STS FOR A FAB/RAB IS AT BYTE 8.
;
10$:	BLBC	(R8),40$		;NOT SET, THEN NOT A FAB OR RAB
	BITB	#^B11111100,(R8)	;IS IT A 1 OR 3?
	BNEQ	40$			;NEQ NO SO BLOW THE WHISTLE
	MOVL	8(R8),R0		;GET RMS STATUS CODE
	BEQL	20$			;AND WAIT AGAIN IF NOT SET
	BLBC	R0,30$			;BRANCH IF FAILURE CODE
	RET				;RETURN TO CALLER
;
;  CLEAR THE RMS EVENT FLAG, CHECK STATUS AGAIN AND WAIT 1 MORE TIME IF
;  OPERATION STILL NOT DONE.  THE APPROPRIATE ARGUMENTS FOR THE CLREF
;  AND SETEF (IF EXECUTED) REMAIN ON THE STACK FROM THE WAITFR ABOVE.
;  THE AP MUST BE PRESERVED.
;
20$:	CHMK	I^#CLREF		;DO A 'NAKED' CLREF, THE ARGUMENTS
					;ARE ON STACK AND AP STILL SET UP
					;FROM THE WAITFR ABOVE
	TSTL	8(R8)			;AND RE-CHECK STATUS
	BEQL	USERWAIT		;BRANCH TO WAIT FOR FLAG AGAIN..
					;... IF STATUS STILL ZERO
	CHMK	I^#SETEF		;I/O COMPLETE - LEAVE EFN SET
	BRB	10$			;AND RESTORE R0 STATUS CODE
;
;  BRANCH TO CHECK STATUS CODE FOR ERROR OR SEVERE ERROR
;
30$:	JMP	@#RMS_ERR
;
;  BRANCH TO RETURN INVALID STRUCTURE ERROR
;
40$:	JMP	@#BAD_STRUCT
;
;  ENTRY HERE FROM $WAIT SERVICE.  THIS SERVES AS AN EXTENDED BRANCH
;  TO THE $WAIT SYNCHRONIZATION CODE IN THE Y$CMODE PSECT.
;
RMSWAIT_BR:
	JSB	@#RMS_WAIT_SYNC			;DO $WAIT SYNCHRONIZATION
;
;
;  ENTRY HERE FROM EACH VECTOR
;  CHECK FOR POSSIBLE STALL
;
RMSCHK_STALL:
	CMPW	R0,#RMS$_STALL&^XFFFF	;IS THE STATUS CODE I/O STALL?
	BEQL	RMSWAIT_IO_DONE		;BRANCH IF YES
	RET				;BACK TO CALLER
	.ALIGN	QUAD
	.IFF
	.BLKB	^X48			;THIS TAKES THE SPACE OF THE CODE
					;WHEN GENERATING THE GLOBAL SYMBOLS
	.ENDC
	.IFF
.PAGE
;
;
;  DEFINE RMS SERVICES
;
	.IIF	NDF,LIBSWITCH,RMSSYNC=RMSCHK_STALL
	.ENDC
;
;  HIGH USE RECORD OPERATIONS
;
	RMSSRV	DELETE		;DELETE A RECORD
	RMSSRV	FIND		;FIND RECORD
	RMSSRV	FREE		;RELEASE LOCK ON ALL RECORDS
	RMSSRV	GET		;GET A RECORD
	RMSSRV	PUT		;PUT A RECORD
	RMSSRV	READ		;READ A BLOCK
	RMSSRV	RELEASE		;RELEASE LOCK ON NAMED RECORD
	RMSSRV	UPDATE		;REWRITE EXISTING RECORD
	.IF	NDF,RMSSWITCH
	.IIF	NDF,LIBSWITCH,RMSSYNC=RMSWAIT_BR	;REDEFINE FOR $WAIT ONLY
	.ENDC
	RMSSRV	WAIT		;STALL FOR RECORD OPERATION COMPLETE
	.IF	NDF,RMSSWITCH
	.IIF	NDF,LIBSWITCH,RMSSYNC=RMSCHK_STALL	;RESTORE STANDARD SYNC ADDR
	.ENDC
	RMSSRV	WRITE		;WRITE BLOCK
;
;  LOWER USAGE OPERATIONS
;
	RMSSRV	CLOSE		;CLOSE FILE
	RMSSRV	CONNECT		;CONNECT RAB
	RMSSRV	CREATE		;CREATE FILE
	RMSSRV	DISCONNECT	;DISCONNECT RAB
	RMSSRV	DISPLAY		;DISPLAY FILE INFORMATION
	RMSSRV	ERASE		;ERASE (DELETE) FILE
	RMSSRV	EXTEND		;EXTEND FILE ALLOCATION
	RMSSRV	FLUSH		;FINISH I/O ACTIVITY FOR STREAM
	RMSSRV	MODIFY		;MODIFY FILE ATTRIBUTES
	RMSSRV	NXTVOL		;NEXT VOLUME
	RMSSRV	OPEN		;OPEN FILE
	RMSSRV	REWIND		;REWIND FILE
	RMSSRV	SPACE		;POSITION FOR TRANSFER
	RMSSRV	TRUNCATE	;TRUNCATE FILE
	RMSSRV	ENTER		;ENTER FILENAME INTO DIRECTORY
	RMSSRV	PARSE		;PARSE FILENAME SPECIFICATION
	RMSSRV	REMOVE		;REMOVE FILENAME FROM DIRECTORY
	RMSSRV	RENAME,NARG=4	;RENAME A FILE
	RMSSRV	SEARCH		;SEARCH A FILE DIRECTORY
	RMSSRV	SETDDIR,NARG=3,NOSYNC=1
				;SET DEFAULT DIRECTORY STRING
	RMSSRV	SETDFPROT,REGS=<R2,R3>,NARG=2,NOSYNC=1
				;SET DEFAULT FILE PROTECTION MASK
	RMSSRV	SSVEXC,REGS=<>,NOSYNC=1
				;GENERATE SYS SERV EXCEPTION
	RMSSRV	RMSRUNDWN,NARG=2,NOSYNC=1
				;PERFORM RUNDOWN ON RMS FILES


	.IF	NDF,RMSSWITCH

; NOTE:  RMSVECEND MARKS THE END OF THE CURRENTLY DEFINED RMS VECTORS.
;	 SSVECREG2 MARKS THE START OF THE SECOND REGION OF SYSTEM
;	 SERVICE VECTORS.  THERE IS EMPTY SPACE BETWEEN THESE REGIONS
;	 FOR FUTURE RMS VECTORS.  IF NECESSARY, THIS SPACE CAN ALSO
;	 BE USED FOR SYSTEM SERVICE VECTORS BY BACKING UP SSVECREG2
;	 (TOWARDS THE RMS VECTORS) AND ADDING NEW SYSTEM SERVICE VECTORS
;	 BEFORE THE ALREADY DEFINED ONES.  IN OTHER WORDS, THESE TWO
;	 VECTOR REGIONS MAY GROW TOWARDS EACH OTHER.  IF THEY COLLIDE,
;	 AN ASSEMBLY ERROR IS GENERATED.
	
	.IF	DF,LIBSWITCH
	.PSECT	$$$0000,QUAD
	.IFF
	.PSECT	$$$000,QUAD		; CMODSSDSP
	.ENDC

RMSVECEND:
.=VECBASE+^X5C0
SSVECREG2:			; START OF SYSTEM SERVICE VECTOR REGION 2
	.IIF	GT,RMSVECEND-SSVECREG2,-
	.ERROR			; RMS VECTORS EXCEEDED PREALLOCATED SPACE ;
	.ENDC

	.PAGE
	.SBTTL	REGION 2 OF SYS. SERV. VECTOR DEFINITIONS

;
; NOTE:  THERE IS CURRENTLY NO PROVISION FOR ADDING EXEC MODE SERVICES
;	 IN THIS VECTOR REGION.  TO DO SO REQUIRES ADDING ANOTHER CASE TABLE
;	 AS THE RMS SERVICES SEPARATE THESE SERVICES FROM THE PRECEEDING
;	 EXEC MODE SERVICES (THE CASE COUNTERS ECASCTR AND RCASCTR ARE 
;	 NOT SET UP TO HANDLE TWO SEPARATE REGIONS).
;

	GSYSSRV	ENQ,K,11,-		; ENQUEUE
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTERS R2-R11
	GSYSSRV	DEQ,K,4,-		; DEQUEUE
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTERS R2-R11
	GCOMPSRVB ENQW,-		; ENQUEUE AND WAIT
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTERS R2-R11
	.IF	NDF,RMSSWITCH
	.IF	NDF,LIBSWITCH
	CHMK	#ENQ
	CMPW	R0,#SS$_SYNCH
	BEQL	10$
	BLBC	R0,10$
	CHMK	#WAITFR
10$:	RET
	.ENDC
	.ENDC
	GCOMPSRVE	3		; RESERVE 3 QUADWORDS FOR VECTOR
	GSYSSRV	SETSSF,K,1,-		; SET SYSTEM SERVICE FILTER MASK
		<R4>			; REGISTER R4
	GSYSSRV	SETSTK,K,3,-		; SET STACK LIMITS
		<R2,R4>			; REGISTERS R2,R4
	GSYSSRV	GETSYI,K,7,-		; GET SYSTEM INFORMATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTERS R2-R11
	GSYSSRV	IMGFIX,ALL,0,-		; IMAGE ADDRESS RELOCATION FIXUP
		<>			; REGISTERS NONE
	GCOMPSRVB	IMGFIX_2,-	; ********** TEMP **********
		<>
	GCOMPSRVE	1		; ********** TEMP **********
	GSYSSRV	GETDVI,K,8,-		; GET DEVICE AND VOLUME INFORMATION
		<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTERS R2-R11
.PAGE
	.NLIST
	.IF	NDF,RMSSWITCH
	.IF	NDF,LIBSWITCH		;GENERATE CODE IF NOT LIBRARY FORM
	.LIST
	.PSECT	$$$000,BYTE
CLIJMP:
	PUSHL	@#CTL$AL_CLICALBK	;PIC JUMP FOR CLI CALLBACK
	JMP	@(SP)+
	.BLKB	<SGN$C_SYSVECPGS@9>-<.-VECBASE>	;FILL REMAINDER OF RESERVED PAGES

	.PAGE
	.SBTTL	ILLEGAL CHME OR CHMK CODE VALUE HANDLING
;
;
;	END OF CHME DISPATCH TABLE
;
 
	.PSECT	Y$CMODE,QUAD
	JSB	@CTL$GL_RMSBASE		;SEE IF RMS DOES THIS SERVICE
					;  (R0 HAS CHME CODE)
	TSTB	@#CTL$GB_SSFILTER	; ANY INHIBIT BITS ON?
	BEQL	5$			; NO, ALL OKAY
	MOVZWL	#SS$_INHCHME,R1		; YES, SET THE EXCEPTION CODE
	BRW	INHEXCP1		; DEAL WITH BAD CODE

5$:	BSBW	CHECKARGLIST		; VERIFY ARGUMENT LIST ACCESSIBILITY
	MOVL	@#CTL$GL_USRCHME,R1	; GET PER-PROCESS USER CHME VECTOR
	BEQL	10$			; NOT PRESENT, TRY SYSTEM WIDE

;
;	CALL PER-PROCESS "USER" SUPPLIED PLUG-ON HANDLER FOR CHME 
;	WITH UNRECOGNIZED CODES.
;
;	R0 - CODE FROM CHME/CHMK (LONGWORD)
;	R1 - ADDRESS OF ROUTINE
;	(SP) - RETURN ADDRESS IN CASE CODE IS NOT LEGAL.
;	       IF AN RSB IS ISSUED, THEN THE SYSTEM-WIDE HANDLER WILL BE
;	       GIVEN AN OPPORTUNITY BEFORE DECIDING THAT THE CODE IS REALLY ILLEGAL.
;		(NORMAL RETURN IS A RET AFTER PERFORMING FUNCTION)
;
	JSB	(R1)			; CALL PER-PROCESS USR CHME HANDLER
					; RETURNS ONLY IF ILLEGAL CODE
10$:	MOVL	L^EXE$GL_USRCHME,R1	; ELSE TRY SYSTEM WIDE VECTOR
	BEQL	20$			; NOT PRESENT, ILLEGAL
	JSB	(R1)			; CALL SYSTEM WIDE USER CHME HANDLER
;
;	CALL SYSTEM-WIDE "USER" SUPPLIED PLUG-ON HANDLER FOR CHME 
;	WITH UNRECOGNIZED CODES.
;
;	R0 - CODE FROM CHME/CHMK (LONGWORD)
;	R1 - ADDRESS OF ROUTINE
;	(SP) - RETURN ADDRESS TO GIVE SS$_ILLSER ERROR
;		(NORMAL RETURN IS A RET AFTER PERFORMING FUNCTION)
;
					; RETURNS ONLY IF ILLEGAL CODE
20$:	BRW	ILLSER			;

ECASMAX=ECASCTR-1
;
;
;  RMS $WAIT SYNCHRONIZATION CODE.
;
;  LOOK AT FLAG IN R4 TO DETERMINE IF THIS IS A $WAIT FOR THE SAME OR DIFFERENT
;  RABS.  IF SAME, MERELY RSB;  IF DIFFERENT, WAIT ON EVENT FLAG AND THEN
;  RE-EXECUTE THE $WAIT SERVICE.
;

RMS_WAIT_SYNC:
	BLBS	R4,10$			;BRANCH IF DIFFERENT RABS
	RSB				;HANDLE WITH STANDARD STALL
10$:	TSTL	(SP)+			;POP RETURN PC FROM STACK
	CMPW	R0,#RMS$_STALL&^XFFFF	;IS STALL REQUIRED?
	BEQL	20$			;BRANCH IF YES
	RET				;NO - BACK TO USER
20$:	$WAITFR_S	R3		;WAIT ON SPECIFIED EVENT FLAG
	JMP	SYS$WAIT+2		;RE-EXECUTE RMS $WAIT
;
;  THE FOLLOWING CODE IS AN ERROR PATH FROM THE RMS SYCHRONIZATION CODE
;  THAT PRECEDES THE RMS VECTORS.  IT WAS MOVED HERE BECAUSE CODE WAS
;  ADDED THERE AND BECAUSE THE RMS VECTORS CAN'T MOVE, THIS CODE DID.
;
;  BAD USER STRUCTURE DETECTED - RETURN ERROR IN R0, STATUS OF RECORD
;  OPERATION WILL BE LOST
;
BAD_STRUCT:
	MOVL	#RMS$_STR,R0		;CHANGE STATUS TO BAD STRUCTURE ERROR 
;
;  CHECK STATUS CODE FOR ERROR OR SEVERE ERROR
;
RMS_ERR:
	BITB	#6,R0			;ERROR OR SEVERE ERROR?
	BEQL	99$			;BRANCH IF NOT
;
;  MUST RETURN TO EXEC MODE TO GENERATE POSSIBLE SYSTEM SERVICE FAILURE EXCEPTION
;
	MOVL	R0,R2			;STATUS CODE TO R2
	CHME	I^#SSVEXC		;GENERATE EXCEPTION IF ENABLED
99$:	RET
;
;	END OF CHMK DISPATCH TABLE
;
 
	.PSECT	Y$CMODK,QUAD
;
; UNIMPLEMENTED SERVICES, DEFINED TO PROVIDE CLEAN LINK.
; REMOVE NAME AND VERIFY GSYSSRV ENTRY WHEN SERVICE IS IMPLEMENTED.
;
;
;	CALL PER-PROCESS "USER" SUPPLIED PLUG-ON HANDLER FOR CHMK 
;	WITH UNRECOGNIZED CODES.
;
;	R0 - CODE FROM CHME/CHMK (LONGWORD)
;	R1 - ADDRESS OF ROUTINE
;	(SP) - RETURN ADDRESS TO GIVE SS$_ILLSER ERROR
;		(NORMAL RETURN IS A RET AFTER PERFORMING FUNCTION)
;

	TSTB	@#CTL$GB_SSFILTER	; ANY INHIBIT BITS ON?
	BEQL	5$			; NO, ALL OKAY
	MOVZWL	#SS$_INHCHMK,R1		; YES, SET THE EXCEPTION CODE
	BRW	INHEXCP1		; DEAL WITH BAD CODE

5$:	BSBW	CHECKARGLIST		; VERIFY ARGUMENT LIST ACCESSIBILITY
	MOVL	@#CTL$GL_USRCHMK,R1	; GET PER-PROCESS VECTOR
	BEQL	10$			; NOT PRESENT, TRY FOR SYSTEM WIDE
	JSB	(R1)			; CALL PER-PROCESS HANDLER
					; RETURNS ONLY IF CODE IN R0 IS NOT
;
;	CALL SYSTEM-WIDE "USER" SUPPLIED PLUG-ON HANDLER FOR CHMK 
;	WITH UNRECOGNIZED CODES.
;
;	R0 - CODE FROM CHME/CHMK (LONGWORD)
;	R1 - ADDRESS OF ROUTINE
;	(SP) - RETURN ADDRESS TO GIVE SS$_ILLSER ERROR
;		(NORMAL RETURN IS A RET AFTER PERFORMING FUNCTION)
;
					; HANDLED BY PER PROCESS HANDLER
10$:	MOVL	L^EXE$GL_USRCHMK,R1	; ELSE GET SYSTEM WIDE VECTOR
	BEQL	20$			; NOT PRESENT, ILLEGAL SERVICE
	JSB	(R1)			; CALL SYSTEM WIDE HANDLER
					; RETURN ONLY IF ILLEGAL CODE
20$:					;
EXE$ALCDNP:				;
EXE$CLRPAR:				;
EXE$DLCDNP:				;
EXE$GETJPP:				;***** REUSE THIS VECTOR
EXE$GTCHAN:				;***** REUSE THIS VECTOR

EXE$FAILURE::				; THIS PROCEDURE ALWAYS FAILS

	NOP
	NOP

ILLSER:	MOVZWL	#SS$_ILLSER,R0		;ILLEGAL SYSTEM SERVICE
	RET				;

EXE$SUCCESS::				; THIS PROCEDURE ALWAYS SUCCEEDS
	NOP				; THESE TWO INSTRUCTIONS CAN ALSO
	NOP				;  SERVE AS A HARMLESS ENTRY MASK
	MOVZWL	#SS$_NORMAL,R0		; RETURN SUCCESSFUL STATUS
	RET

SSFAILMAIN:				;SSFAIL MAIN LOGIC
	MOVL	G^CTL$GL_PCB,R1		;GET PCB ADDRESS
	TSTW	PCB$W_MTXCNT(R1)	;MUTEX COUNT ZERO?
	BNEQ	20$			;IF NEQ NO
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,- ;EXTRACT PREVIOUS MODE FROM
		4(SP),-(SP)		;SAVED PSL
	ADDL	#PCB$V_SSFEXC,(SP)	;ADD IN BASE BIT NUMBER
	BBC	(SP)+,PCB$L_STS(R1),10$ ;IF CLEAR, FAILURE EXCEPTION DISABLED
	MOVPSL	-(SP)			;GET CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,(SP),(SP)+ ;IF CURRENT MODE IS
	BNEQ	5$			;NOT KERNEL, THEN BRANCH
	SETIPL	#0			;FORCE IPL TO 0 FOR ERROR PATH
5$:	JMP	EXE$SSFAIL		;GENERATE SYSTEM SERVICE FAILURE EXCEPTION
10$:	REI				;AND RETURN FROM SERVICE WITH ERROR STATUS
20$:	BUG_CHECK MTXCNTNONZ,FATAL	;MUTEX COUNT NONZERO AT SERVICE EXIT
 
KCASMAX=KCASCTR-2
 
	.ENDC

	.IFTF
	.IIF	NDF,LIBSWITCH,	RCASMAX=RCASCTR-<1+RCASMIN>
	.IFF
	.LIST
	.PSECT	$$$RMSVEC,BYTE,NOWRT
	RSB				;NOT AN RMS EXEC MODE SERVICE
;
;  SERVICE TO MERELY MOVE RMS STATUS CODE IN R2 TO R0 AND RET,
;  THUS GENERATING A SYSTEM SERVICE FAILURE EXCEPTION IF ENABLED
;
RMS$SSVEXC=.-2
	MOVL	R2,R0			;MOVE STATUS CODE TO R0
	RET				;AND LET RET DO THE REST
	.ENDC
	.END
