	.TITLE	FORKCNTRL - FORK PROCESS CONTROL
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 9-AUG-76
;
; MODIFIED BY R.HEINEN ON 13-OCT-76; ALLOW FORK TO IPL 6
; FORK CREATION AND DISPATCHING
;
; V02-007	LJK0076		Lawrence J. Kenah	3-Nov-1981
;		Remove check for "queue previously not empty" when making
;		fork request. The fork interrupt request is always made.
;
; V02-006	STJ0129		STEVEN T. JEFFREYS,	19-OCT-1981
;		ADDED AN ENTRY POINT FOR EACH FORK LEVEL, TO AVOID HAVING
;		TO READ THE IPL REGISTER.
;
; V02-005	STJ0126		STEVEN T. JEFFREYS,	01-OCT-1981
;		REMOVED EXEX$FORKIPL8DSP AND OPTIMIZED THE GENERALIZED
;		FORK DISPATCHER TO BE FAST FOR ALL FORK IPLS.
;
; V02-004	STJ0047		STEVEN T. JEFFREYS,	05-JUN-1981
;		FIXED UP CODE COMMENTS, AND DID SOME MORE OPTIMIZIATIONS,
;		THIS TIME TRADING SPEED FOR SPACE.
;
; V02-003	STJ0037		STEVEN T. JEFFREYS,	18-MAY-1981
;		ADDED EXE$FORKIPL8DSP, A FORK DISPATCHER OPTIMIZED FOR
;		IPL 8 FORK INTERRUPT DISPATCHING.  ALSO INCLUDES GENERAL
;		PERFORMANCE ENHANCEMENT OF EXE$FORKDSPTH.  THE BADFORKIPL
;		BUGCHECK CONTEXT HAS CHANGED AS A RESULT OF THE PERFORMANCE
;		TRADEOFFS.
;
; V02-002	STJ0032		STEVEN T. JEFFREYS,	20-APR-1981
;		MOVED MFPR INSTRUCTION IN DISPATCH LOOP TO OUTSIDE THE LOOP,
;		SO IT IS EXECUTED ONLY ONCE PER FORK DISPATCH INTERRUPT.
;
; MACRO LIBRARY CALLS
;
 
	$FKBDEF				;DEFINE FKB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$UCBDEF				;DEFINE UCB OFFSETS
	.PAGE
	.SBTTL	CREATE I/O DRIVER FORK PROCESS
;+
; EXE$IOFORK - CREATE I/O DRIVER FORK PROCESS
;
; THIS ROUTINE IS CALLED BY AN I/O DRIVER TO CREATE A FORK PROCESS.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	***TBS***
;-
 
	.PSECT	A$EXENONPAGED,LONG
EXE$IOFORK::				;CREATE I/O DRIVER FORK PROCESS
	BICW	#UCB$M_TIM,UCB$W_STS(R5);DISABLE TIMEOUT AND FALL THROUGH
					;TO EXE$FORK

	.SBTTL	CREATE FORK PROCESS
;+
; EXE$FORK - CREATE FORK PROCESS
;
; THIS ROUTINE IS CALLED TO CREATE A FORK PROCESS.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = ADDRESS OF FORK BLOCK.
;
; OUTPUTS:
;
;	***TBS***
;-
 
EXE$FORK::				;CREATE FORK PROCESS
	MOVQ	R3,FKB$L_FR3(R5)	;SAVE REGISTERS R3 AND R4
	POPL	FKB$L_FPC(R5)		;SET FORK PROCESS PC
	MOVZBL	FKB$B_FIPL(R5),R4	;GET FORK IPL
	MOVAQ	W^SWI$GL_FQFL-<6*8>[R4],R3 ;GET ADDRESS OF FORK QUEUE LISTHEAD
	INSQUE	(R5),@4(R3)		;INSERT FORK BLOCK IN FORK QUEUE
	SOFTINT	R4			;INITIATE SOFTWARE INTERRUPT
	RSB				; AND RETURN

	.SBTTL	SOFTWARE INTERRUPT ENTRY POINTS
;+
; THE APPROPRIATE ENTRY POINT IS AUTOMATICALLY VECTORED TO WHEN THE SOFTWARE 
; INTERRUPT PRIORITY ARBITRATION LOGIC IN THE CENTRAL PROCESSOR DETECTS A
; PENDING INTERRUPT AT LEVEL 6, 8, 9, 10, OR 11 AND THE CURRENT PRIORITY LEVEL
; IS LOWER THAN THE PENDING LEVEL. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = INTERRUPT PC.
;	04(SP) = INTERRUPT PSL.
;
; THERE IS AN ENTRY POINT FOR EACH FORK LEVEL SO THAT THE HARDWARE IPL REGISTER
; WILL NOT HAVE TO BE READ TO DETERMINE THE CURRENT PROCESSOR IPL.  READING THE
; IPL REGISTER IS SLOW ENOUGH TO WARRANT THE ADDITIONAL CODE.
;-

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL6DSP::			;FORK IPL 6 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL9DSP::			;FORK IPL 9 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+24,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL10DSP::			;FORK IPL 10 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+32,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL11DSP::			;FORK IPL 11 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+40,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL8DSP::			;FORK IPL 8 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+16,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	NOP				;PAD OUT TO LONGWORD BOUNDARY
	;
	; DROP THROUGH TO COMMON CODE
	;

	.SBTTL	SOFTWARE INTERRUPT FORK DISPATCHER
;+
; EXE$FORKDSPTH - SOFTWARE INTERRUPT FORK DISPATCHER
;
; FOR EACH OF THE LEVELS 6, 8, 9, 10, AND 11, THERE EXISTS A QUEUE OF FORK
; BLOCKS WAITING TO BE PROCESSED. WHEN A FORK BLOCK IS ENTERED IN ITS 
; CORRESPONDING QUEUE AND IT IS THE FIRST TO BE ENTERED (I. E. THE QUEUE
; WAS PREVIOUSLY EMPTY), A SOFTWARE INTERRUPT IS REQUESTED FOR THAT LEVEL.
; THE FORK DISPATCHER GAINS CONTROL AND EMPTIES THE QUEUE ONE ENTRY AT A
; TIME. AS EACH FORK IS DISPATCHED, REGISTERS R3 AND R4 ARE RESTORED FROM
; THE FORK BLOCK AND THE FORK PROCESS IS CALLED VIA A JSB INSTRUCTION.
; ON RETURN, THE FORK DISPATCHER RETRIEVES THE NEXT ENTRY FROM THE QUEUE
; AND REPEATS THE DISPATCHING OPERATION. THIS PROCESS CONTINUES UNTIL
; THERE ARE NO MORE FORKS TO DISPATCH AT WHICH TIME THE INTERRUPT IS
; DISMISSED.
;
; 
;-
	.ALIGN	LONG
EXE$FORKDSPTH::				;SOFTWARE INTERRUPT FORK DISPATCHER
	PUSHL	R5			;SAVE R5 .
	PUSHL	R4			;SAVE R4  .
	PUSHL	R3			;SAVE R3   . PUSHLS ARE FASTEST!
	PUSHL	R2			;SAVE R2  .
	PUSHL	R1			;SAVE R1 .
	PUSHL	R0			;SAVE R0.
	REMQUE	@(R6),R5		;REMOVE NEXT ENTRY FROM FORK QUEUE
	BVS	20$			;IF VS NO ENTRY REMOVED
;
; DISPATCH FORK PROCESS WITH:
;
;	R0 THRU R2 = SCRATCH REGISTERS.
;	R3 AND R4 = RESTORED FROM FORK BLOCK.
;	R5 = ADDRESS OF FORK BLOCK.
;
10$:	MOVQ	FKB$L_FR3(R5),R3	;RESTORE REGISTERS R3 AND R4
	JSB	@FKB$L_FPC(R5)		;DISPATCH FORK
	REMQUE	@(R6),R5		;REMOVE NEXT ENTRY FROM FORK QUEUE
	BVC	10$			;IF VC THERE IS MORE TO DO
20$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6> ;RESTORE FORK PROCESS REGISTER SET
	REI				;DISMISS INTERRUPT	

	.END
