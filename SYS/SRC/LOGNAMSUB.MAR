	.TITLE	LOGNAMSUB - LOGICAL NAME RELATED SUBROUTINES
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 13-JUN-76
;
; MODIFICATION HISTORY:
;
;	V02-006	MSH0001		Maryann Hinden		19-Feb-1982
;		Fix PROBE problem.
;
;	V02-005	LMK0003		Len Kawell		05-Sep-1981
;		Add new entry, LOG$TRANSLATE, which assumes caller
;		has already verified the input logical name.
;
;	V02-004	KTA0026		Kerbey T. Altmann	21-Jul-1981
;		Redo so that LOG$AL_LOGTBL accessed with a level of
;		indirection; add support for separate table sizes.
;
;	V02-003	KTA0022		Kerbey T. Altmann	17-Jun-1981
;		Extensive rewrite to accommodate the use of a hash
;		table for locating logical names in system/group.
;
;	V02	LMK0001		LEN KAWELL		7-JUL-1979
;		ADDED NEW ENTRY POINT FOR LOG$INSLOGN: LOG$INSLOGN_LCK WHICH
;		JUST ASSUMES THAT THE TABLE IS ALREADY LOCKED.
;
;
; LOGICAL NAME RELATED SUBROUTINES
;
; MACRO LIBRARY CALLS
;
 
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY SWITCHES
	$LOGDEF				;DEFINE LOG OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$UCBDEF				;DEFINE UCB OFFSETS
	.PAGE
	.SBTTL	DELETE LOGICAL NAME TABLE ENTRY
;+
; LOG$DELETE - DELETE LOGICAL NAME TABLE ENTRY
;
; THIS ROUTINE IS CALLED TO DELETE A LOGICAL NAME TABLE ENTRY AND RETURN ITS
; STORAGE TO THE APPROPRIATE ALLOCATION REGION.
;
; INPUTS:
;
;	R1 = ADDRESS OF ENTRY TO BE DELETED.
;
;	IT IS ASSUMED THAT THE RESPECTIVE LOGICAL NAME TABLE IS LOCKED FOR
;	WRITE ACCESS.
;
; OUTPUTS:
;
;	THE ENTRY IS REMOVED FROM ITS RESPECTIVE LOGICAL NAME TABLE AND THE
;	STORAGE IS RETURNED TO THE APPROPRIATE ALLOCATION REGION. IF THE ENTRY
;	HAS AN ASSOCIATED MAILBOX UCB ADDRESS, THEN THE LINKAGE FROM THE UCB
;	TO THE LOGICAL NAME ENTRY IS CLEARED.
;-
 
	.PSECT	Y$EXEPAGED
LOG$DELETE::				;DELETE LOGICAL NAME TABLE ENTRY
	MOVL	LOG$L_MBXUCB(R1),R0	;GET ASSOCIATED UCB ADDRESS
	BEQL	10$			;IF EQL NONE
	CLRL	UCB$L_LOGADR(R0)	;CLEAR LINKAGE FROM UCB TO NAME ENTRY
10$:	MOVL	R1,R0			;SAVE THE POINTER TO THE BLOCK
	MOVQ	LOG$L_LTFL(R1), R1	;PICK BOTH LINKS
	MOVL	R1,LOG$L_LTFL(R2)	;STORE NEXT PTR IN PREVIOUS BLOCK
	BEQL	20$			;THIS IS THE END OF THE LINE
	MOVL	R2,LOG$L_LTBL(R1)	;STORE PREVIOUS PTR IN NEXT BLOCK
20$:	BBC	#1,LOG$B_TABLE(R0),30$	;IF CLR, GROUP OR SYSTEM TABLE
	MOVZWL	LOG$W_SIZE(R0),R1	;GET SIZE OF BLOCK TO DEALLOCATE
	MOVAB	@#CTL$GQ_ALLOCREG,R3	;GET ADDRESS OF ALLOCATION LISTHEAD
	BRW	EXE$DEALLOCATE		;DEALLOCATE PROCESS DYNAMIC MEMORY

30$:	BRW	EXE$DEAPAGED		;DEALLOCATE SYSTEM PAGED MEMORY
	.PAGE
	.SBTTL	INSERT IN LOGICAL NAME TABLE
;+
; LOG$INSLOGN - INSERT IN LOGICAL NAME TABLE
; LOG$INSLOGN_LCK - INSERT IN PREVIOUSLY LOCKED LOGICAL NAME TABLE
;
; THIS ROUTINE IS CALLED TO INSERT A NEW ENTRY IN THE SPECIFIED LOGICAL
; NAME TABLE. IF AN ENTRY ALREADY EXISTS AND IS IN THE GROUP OR SYSTEM
; TABLE OR IS IN THE PROCESS TABLE AND HAS AN EQUAL ACCESS MODE, THEN THE
; NEW ENTRY SUPERSEDES THE OLD.
;
; INPUTS:
;
;	R3 = LOGICAL NAME TABLE NUMBER (LOG$INSLOGN_LCK ONLY).
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ADDRESS OF LOGICAL NAME BLOCK.
;
; OUTPUTS:
;
;	THE LOGICAL NAME IS INSERTED IN THE SPECIFIED TABLE.
;
;	R0 ALWAYS CONTAINS SUCCESS WITH:
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;		R0 = SS$_SUPERSEDE - LOGICAL NAME SUPERCEDED.
;-

LOG$INSLOGN::				;INSERT IN LOGICAL NAME TABLE
	MOVZBL	LOG$B_TABLE(R5),R3	;GET NAME TABLE NUMBER
	BSBB	LOG$LOCKW		;LOCK NAME TABLE FOR WRITE
LOG$INSLOGN_LCK::			;INSERT IN LOCKED LOGICAL NAME TABLE
	MOVL	R3,R2			;TRANSFER TABLE NUMBER
	MOVZBL	LOG$B_AMOD(R5),R3	;SET SEARCH ACCESS MODE
	PUSHL	#SS$_NORMAL		;ASSUME NEW LOGICAL NAME
	MOVAB	LOG$C_LENGTH(R5),R1	;GET ADDRESS OF LOGICAL NAME STRING
	MOVZBL	(R1)+,R0		;GET LENGTH OF STRING
	BSBB	LOG$SEARCHLOG		;SEARCH FOR CORRESPONDING LOGICAL NAME
	BLBC	R0,20$			;IF LBC SEARCH FAILURE
	PUSHL	LOG$L_LTBL(R1)		;SET TO INSERT NEW ENTRY BEFORE OLD
	BBC	#1,LOG$B_TABLE(R1),10$	;IF CLR, THEN GROUP OR SYSTEM TABLE
	CMPB	LOG$B_AMOD(R5),LOG$B_AMOD(R1) ;SUPERSEDE OLD ENTRY?
	BNEQ	15$			;IF NEQ NO
10$:	BSBB	LOG$DELETE		;DELETE LOGICAL NAME
	MOVZWL	#SS$_SUPERSEDE,4(SP)	;SET LOGICAL NAME SUPERSEDED
15$:	POPL	R1			;RECOVER POINTER
20$:	MOVL	LOG$L_LTFL(R1),R2	;R2-->NEXT
	MOVL	R2, LOG$L_LTFL(R5)	;INSERT AS NEXT POINTER IN CURRENT
	BEQL	30$			;WE ARE AT END OF CHAIN
	MOVL	R5, LOG$L_LTBL(R2)	;INSERT CURRENT INTO NEXT BLOCK
30$:	MOVL	R5, LOG$L_LTFL(R1)	;INSERT CURRENT INTO PREVIOUS
	MOVL	R1, LOG$L_LTBL(R5)	;SET PREVIOUS INTO CURRENT
	MOVZBL	LOG$B_TABLE(R5),R3	;RETRIEVE NAME TABLE NUMBER
	BSBB	LOG$UNLOCK		;UNLOCK NAME TABLE
	POPL	R0			;SET COMPLETION STATUS
	RSB				;
	.PAGE
	.SBTTL	LOCK LOGICAL NAME TABLE
;+
; LOG$LOCKR - LOCK LOGICAL NAME TABLE FOR READ ACCESS
; LOG$LOCKW - LOCK LOGICAL NAME TABLE FOR WRITE ACCESS
;
; THESE ROUTINES ARE CALLED TO SYNCHRONIZE ACCESS TO A SPECIFIED LOGICAL NAME
; TABLE.
;
; INPUTS:
;
;	R3 = LOGICAL NAME TABLE NUMBER.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	IF THE SPECIFIED NAME TABLE IS THE GROUP OR SYSTEM TABLE, THEN THE
;	RESPECTIVE NAME TABLE IS LOCKED FOR THE SPECIFIED ACCESS.
;
;	REGISTERS R1, R2, AND R3 ARE PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
LOG$LOCKR::				;LOCK LOGICAL NAME TABLE FOR READ ACCESS
	PUSHAB	W^SCH$LOCKR		;SET ADDRESS OF LOCK ROUTINE
	BRB	10$			;
LOG$LOCKW::				;LOCK LOGICAL NAME TABLE FOR WRITE ACCESS
	PUSHAB	W^SCH$LOCKW		;SET ADDRESS OF LOCK ROUTINE
	BRB	10$			;
	.PAGE
	.SBTTL	UNLOCK LOGICAL NAME TABLE
;+
; LOG$UNLOCK - UNLOCK NAME TABLE
;
; THIS ROUTINE IS CALLED TO UNLOCK A LOGICAL NAME TABLE AND ALLOW ACCESS BY
; OTHER PROCESSES.
;
; INPUTS:
;
;	R3 = LOGICAL NAME TABLE NUMBER.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	IF THE SPECIFIED NAME TABLE IS THE GROUP OR SYSTEM TABLE, THEN THE
;	RESPECTIVE TABLE IS UNLOCKED.
;-
 
LOG$UNLOCK::				;UNLOCK NAME TABLE
	PUSHAB	W^SCH$UNLOCK		;SET ADDRESS OF LOCK ROUTINE
10$:	BBC	#1,R3,20$		;IF CLR, GROUP OR SYSTEM TABLE
	TSTL	(SP)+			;CLEAN STACK
	RSB				;
20$:	MOVAL	L^LOG$AL_MUTEX[R3],R0	;GET ADDRESS OF LOGICAL NAME TABLE MUTEX
	JMP	@(SP)+			;PERFORM SYNCHRONIZATION OPERATION
	.DSABL	LSB
	.PAGE
	.SBTTL	SEARCH FOR LOGICAL NAME
;+
; LOG$SEARCHLOG - SEARCH FOR LOGICAL NAME
;
; THIS ROUTINE IS CALLED TO SEARCH A LOGICAL NAME TABLE FOR A LOGICAL NAME
; MATCH.
;
; INPUTS:
;
;	R0 = LENGTH OF LOGICAL NAME STRING.
;	R1 = ADDRESS OF LOGICAL NAME STRING.
;	R2 = NAME TABLE NUMBER.
;	R3 = SEARCH ACCESS MODE (PROCESS TABLE ONLY).
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
;	IT IS ASSUMED THAT THE RESPECTIVE LOGICAL NAME TABLE IS LOCKED FOR
;	READ ACCESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R1 = ADDRESS OF LOGICAL NAME BLOCK ON WHICH SEARCH FAILED.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R1 = ADDRESS OF LOGICAL NAME BLOCK THAT CONTAINS MATCH.
;-
 
LOG$SEARCHLOG::				;SEARCH FOR LOGICAL NAME
	PUSHR	#^M<R5,R6,R7,R8>	;SAVE REGISTERS
	MOVQ	R0,R7			;TRANSFER TO NON-VOLATILE REGISTERS
	MOVL	R3,R6			;DITTO
	MOVL	G^LOG$AL_LOGTBL[R2],R5	;OBTAIN POINTER TO ADDR OF NAME TABLE
	PUSHL	(R5)			;SAVE ADDRESS OF NAME TABLE
	BSBB	LOG$HASH		;HASH THE NAME
	MOVAL	@(SP)+[R3],R2		;PROBE THE HASH TABLE
10$:	MOVL	R2,R3			;SAVE THE CURRENT POINTER
	MOVL	(R3),R2			;GET THE NEXT ENTRY
	BEQL	60$			;NONE THERE
	MOVAB	LOG$C_LENGTH(R2),R5	;GET ADDRESS OF LOGICAL NAME STRING
	CMPB	R7,(R5)+		;STRING LENGTHS MATCH?
	BGTRU	10$			;IF GTR NOT YET
	BLSSU	60$			;IF LSS NEVER MATCH
	CMPB	#LOG$C_GROUP,LOG$B_TABLE(R2) ;SEARCHING GROUP NAME TABLE?
	BNEQ	20$			;IF NEQ NO
	CMPW	PCB$L_UIC+2(R4),LOG$W_GROUP(R2) ;GROUP NUMBER MATCH?
	BGTRU	10$			;IF GTR NOT YET
	BLSSU	60$			;IF LSS NEVER MATCH
20$:	PUSHR	#^M<R2,R3,R4>		;SAVE SEARCH PARAMETERS
	CMPC3	R7,(R8),(R5)		;LOGICAL NAME STRINGS MATCH?
	POPR	#^M<R2,R3,R4>		;RETRIEVE SEARCH PARAMETERS
	BGTRU	10$			;IF GTR NOT YET
	BLSSU	60$			;IF LSS NEVER MATCH
	BBC	#1,LOG$B_TABLE(R2),30$	;IF CLR, SYSTEM OR GROUP TABLE
	CMPB	R6,LOG$B_AMOD(R2)	;ENTRY ACCESS MODE ALLOW MATCH?
	BLSS	10$			;IF LSS NO
30$:	MOVL	#1,R0			;INDICATE MATCH FOUND
	MOVL	R2,R1			;SET ADDRESS OF LOGICAL NAME BLOCK
40$:	POPR	#^M<R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

60$:	MOVL	R3,R1			;NOT FOUND, SET POINTER TO PREVIOUS
	MOVZWL	#SS$_NOLOGNAM,R0	;SET NO LOGICAL NAME MATCH
	BRB	40$			;

;+
; LOG$HASH - THE HASH FUNCTION
;
; INPUTS:
;	R0 = LEN
;	R1 = ADDR OF CHAR
;	R2 = NAME TABLE NUMBER
;
; OUTPUTS:
;	R2 SCRATCHED
;	R3 = RETURN HASH FUNCTION
;	R4 PRESERVED
;	R5 SCRATCHED
;-

LOG$HASH::
	MOVZBL	G^LOG$AB_HTBLCNT[R2],R5	;OBTAIN THE NUMBER OF BITS TO SHIFT
	MOVL	R0,R2			;START HASH WITH LENGTH
	BICL3	#-4,R0,R0		;REMAINDER OF DIVIDE BY FOUR
	ASHL	#-2,R2,R3		;DIVIDE BY FOUR
	BEQL	30$			;NOT EVEN THAT LONG
10$:	XORL	(R1)+,R2		;XOR IN THE CHARACTERS
	ROTL	#9,R2,R2		;SCRAMBLE A BIT
	SOBGTR	R3,10$			;LOOP UNTIL DONE
	BRB	30$			;NEED A ZERO TRIP LOOP
20$:	XORB	(R1)+,R2		;XOR IN A CHARACTER
	ROTL	#13,R2,R2		;SCRAMBLE
30$:	SOBGEQ	R0,20$			;LOOP UNTIL DONE
	MULL	#^X71279461,R2		;MULT BY A FUNNY NUMBER
;	CLRL	R3			;CLEAR HIGH ORDER BITS
	ASHQ	R5,R2,R2		;GRAB HIGH BITS
	RSB
	.PAGE
	.SBTTL	TRANSLATE LOGICAL NAME
;+
; LOG$TRNSLOGNAME - TRANSLATE LOGICAL NAME BY DESCRIPTOR
; LOG$TRANSLATE - TRANSLATE LOGICAL NAME
;
; THIS ROUTINE IS CALLED TO TRANSLATE A LOGICAL NAME TO A RESULTANT STRING.
; A SEARCH OF THE PROCESS, FOLLOWED BY THE GROUP, AND THEN THE SYSTEM
; LOGICAL NAME TABLE IS CONDUCTED IN AN ATTEMPT TO LOCATE A LOGICAL NAME
; STRING THAT MATCHES THE SPECIFIED LOGICAL NAME STRING. IF A MATCH IS FOUND,
; THEN, THE EQUIVALENCE STRING IS RETURNED AS THE RESULTANT STRING. IF NO
; MATCH FOUND, THEN THE INPUT STRING IS RETURNED AS THE RESULTANT STRING.
;
; THE CALLER IS ASSUMED TO HAVE PROBED THE RESULTANT STRING BUFFER FOR PROPER
; ACCESSIBLITY. FOR LOG$TRNSLOGNAME, THE LOGICAL NAME STRING IS PROBED FOR 
; READ ACCESSIBILITY.  FOR LOG$TRANSLATE, THE CALLER IS ASSUMED TO HAVE
; PROBED THE LOGICAL NAME STRING AND VERIFIED IT'S SIZE.
;
; INPUTS:
;
;	R0 = SIZE OF LOGICAL NAME STRING (LOG$TRANSLATE ONLY).
;	R1 = ADDRESS OF LOGICAL NAME STRING DESCRIPTOR (LOG$TRNSLOGNAME ONLY).
;	   = ADDRESS OF LOGICAL NAME (LOG$TRANSLATE ONLY)
;	R2 = SIZE OF RESULTANT STRING BUFFER.
;	R3 = ADDRESS OF RESULTANT STRING BUFFER.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = NAME TABLE SEARCH DISABLE MASK.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO TRANSLATE.
;
;		R0 = SS$_ACCVIO - ACCESS VIOLATION.
;		R0 = SS$_IVLOGNAM - INVALID LOGICAL NAME.
;		R0 = SS$_RESULTOVF - RESULTANT STRING OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESS.
;
;		R0 = SS$_NORMAL - TRANSLATION MADE, EQUIVALENCE STRING
;			RETURNED.
;		R0 = SS$_NOTRAN - TRANSLATION MADE, INPUT STRING RETURNED.
;
;			R1 = LENGTH OF RESULT STRING IN BYTES.
;			R2 = TRANSLATION TABLE NUMBER.
;			R3 = ASSIGNMENT ACCESS MODE.
;-
 
LOG$TRNSLOGNAME::			;TRANSLATE LOGICAL NAME BY DESCRIPTOR
	MOVZWL	(R1),R0			;GET LENGTH OF LOGICAL NAME STRING
	BEQL	10$			;IF EQL INVALID LOGICAL NAME
	ASSUME  LOG$C_NAMLENGTH LE 512
	CMPW	R0,#LOG$C_NAMLENGTH-1	;LEGAL NAME STRING LENGTH?
	BLEQU	30$			;IF LEQU YES
10$:	MOVZWL	#SS$_IVLOGNAM,R0	;SET INVALID LOGICAL NAME
	RSB				;
20$:	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION
	RSB				;
30$:	MOVL	4(R1),R1		;GET ADDRESS OF LOGICAL NAME STRING
	IFNORD	R0,(R1),20$		;CAN LOGICAL NAME STRING BE READ?

LOG$TRANSLATE::				;TRANSLATE LOGICAL NAME
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7> ;SAVE REGISTERS
	MOVZWL	#SS$_NORMAL,R7		;ASSUME NORMAL COMPLETION
	MOVL	#LOG$C_PROCESS,R6	;SET STARTING TABLE NUMBER
	CMPB	#^A/_/,(R1)		;LOGICAL NAME STRING START WITH UNDERSCORE?
	BEQL	60$			;IF EQL YES
40$:	MOVL	R6,R3			;SET NAME TABLE NUMBER
	BSBW	LOG$LOCKR		;LOCK NAME TABLE FOR READ
	BBS	R6,20(SP),50$		;IF SET, NAME TABLE SEARCH DISABLED
	MOVQ	(SP),R0			;RETRIEVE LOGICAL NAME STRING PARAMETERS
	MOVL	R6,R2			;GET NAME TABLE NUMBER
	MOVZBL	#PSL$C_USER,R3		;SET SEARCH ACCESS MODE
	BSBW	LOG$SEARCHLOG		;SEARCH FOR LOGICAL NAME
	BLBS	R0,70$			;IF LBS MATCH FOUND
50$:	MOVL	R6,R3			;SET NAME TABLE NUMBER
	BSBW	LOG$UNLOCK		;UNLOCK NAME TABLE
	SOBGEQ	R6,40$			;ANY MORE TABLES TO SEARCH?
	MOVL	#LOG$C_PROCESS,R6	;RESET NAME TABLE NUMBER
	MOVQ	(SP),R0			;RETRIEVE LOGICAL NAME STRING PARAMETERS
	INCL	R0			;BIAS STRING PARAMETERS FOR ADJUSTMENT
	DECL	R1			;
60$:	MOVZWL	#SS$_NOTRAN,R7		;SET NO TRANSLATION
	CLRQ	R4			;CLEAR TABLE NUMBER AND ACCESS MODE
	DECL	R0			;DECREMENT NUMBER OF CHARACTERS
	INCL	R1			;INCREMENT STRING ADDRESS
	BRB	80$			;
70$:	MOVZBL	LOG$B_TABLE(R1),R4	;GET TRANSLATION TABLE NUMBER
	MOVZBL	LOG$B_AMOD(R1),R5	;GET ASSIGNMENT ACCESS MODE
	MOVZBL	LOG$C_LENGTH(R1),R0	;GET SIZE OF LOGICAL NAME
	MOVAB	LOG$C_LENGTH+1(R1)[R0],R1 ;GET ADDRESS OF EQUIVALENCE STRING
	MOVZBL	(R1)+,R0		;GET LENGTH OF EQUIVALENCE STRING
80$:	MOVZWL	#SS$_RESULTOVF,(SP)	;ASSUME RESULT OVERFLOW
	MOVL	R0,4(SP)		;SAVE LENGTH OF RESULT STRING
	MOVQ	8(SP),R2		;RETRIEVE RESULTANT STRING BUFFER PARAMETERS
	MOVQ	R4,8(SP)		;SAVE TABLE NUMBER AND ACCESS MODE
	CMPL	R0,R2			;EQUIVALENCE STRING TOO LARGE?
	BGTR	90$			;IF GTR YES
	MOVC	R0,(R1),(R3)		;MOVE EQUIVALENCE STRING TO RESULTANT STRING
	MOVL	R7,(SP)			;SET COMPLETION STATUS
90$:	MOVL	R6,R3			;SET NUMBER OF TABLE TO UNLOCK
	MOVL	16(SP),R4		;RETRIEVE CURRENT PROCESS PCB ADDRESS
	BSBW	LOG$UNLOCK		;UNLOCK NAME TABLE

	.IF NE CA$_MEASURE		;CHECK FOR MEASUREMENT ENABLED
	INCL	PMS$GL_LOGNAM		;IF YES COUNT TRANSLATIONS
	.ENDC

	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7> ;RESTORE REGISTERS R0 THRU R6
	RSB				;
 
	.END
