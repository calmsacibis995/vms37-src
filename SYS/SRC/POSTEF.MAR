	.TITLE	POSTEF - POST EVENT FLAGS
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SCHEDULER
;
; ABSTRACT: POSTS AN EVENT FLAG FOR A PROCESS SPECIFIED BY PID.
;	    POSTEF IS AN INTERNAL SERVICE ROUTINE ONLY.
;
;--
;
; VERSION:
;
;
; AUTHOR:
;	R. HUSTVEDT : VERSION
;
; MODIFIED BY:
;
;	V03-001	KDM0096		Kathleen D. Morse	11-Apr-1982
;		Remove logic that increments the shared memory master
;		common event block when a PRQ is sent.
;
;	V02-008	KDM0073		Kathleen D. Morse	5-Jan-1982
;		Set alternate status code into correct offset off stack,
;		instead of wiping out saved R4.
;
;	V02-007	KDM0050		Kathleen D. Morse	09-Apr-1981
;		Save registers wiped out by EXE$DEANONPAGED for shared memory
;		common event flag requests.  Also, use correct register for
;		loop counter.
;
;	V02-006	KDM0049		Kathleen D. Morse	28-Mar-1981
;		Replace absolute literals with references to EXE$GL_LOCKRTRY.
;
;
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$CEBDEF				; CEB DEFINITIONS
	$DYNDEF				; DYNAMIC DATA STRUCTURE TYPE DEFS
	$FKBDEF				; FORK BLOCK DEFINITIONS
	$IPLDEF				; IPL DEFINITIONS
	$IRPDEF				; I/O REQUEST PACKET DEFS
	$PCBDEF				; PCB DEFINITIONS
	$PRQDEF				; INTER-PROCESSOR REQUEST BLOCK DEFS
	$SHBDEF				; SHARED MEMORY CONTROL BLOCK DEFS
	$SSDEF				; STATUS CODE DEFINITIONS
	$STATEDEF			; STATE DEFINITIONS
;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

;
; FIXED DATA:
	.PSECT	AEXENONPAGED,BYTE	;NONPAGED EXEC

	.PAGE
	.SBTTL	SCH$POSTEF - POST EVENT FLAG 

;++
; FUNCTIONAL DESCRIPTION:
;	POST EVENT FLAG WILL SET AN EVENT FLAG SPECIFIED BY NUMBER
;	FOR A PROCESS SPECIFIED BY PROCESS ID(PID) AND CAUSE ANY
;	NECESSARY RESCHEDULING IF THIS EVENT SATISFIES A WAIT 
;	CONDITION FOR THE PROCESS.
;
; CALLING SEQUENCE:
;
;	JSB	SCH$POSTEF		(ALSO BSB)
;
; INPUT PARAMETERS:
;	R1 - PROCESS IDENTIFICATION (PID)
;	R2 - PRIORITY INCREMENT CLASS NUMBER
;	R3 - EVENT FLAG NUMBER
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	R4 - PCB ADDRESS OF PROCESS SPECIFIED BY PID
;
; IMPLICIT OUTPUTS:
;	EVENT FLAG BIT SELECTED BY PID AND EVENT FLAG NUMBER
;	IS SET.
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL SUCCESSFUL COMPLETION
;	SS$_NONEXPR -  NON-EXISTENT PROCESS
;	SS$_WASCLR  -  SPECIFIED EVENT WAS CLEAR INITIALLY
;	SS$_WASSET  -  SPECIFIED EVENT WAS SET INITIALLY
;	SS$_ILLEFC  -  ILLEGAL CLUSTER NUMBER
;	SS$_UNASEFC -  UNASSIGNED CLUSTER NUMBER
;
; SIDE EFFECTS:
;	CAN CAUSE RESCHEDULING OF ONE OR MORE PROCESSES.
;--

SCH$POSTEF::					; POST EVENT FLAG ENTRY
	MOVZWL	R1,R0				; GET INDEX TO PCB ADDRESS
	DSBINT	#IPL$_SYNCH			; BLOCK SYSTEM EVENTS
	MOVL	@W^SCH$GL_PCBVEC[R0],R4		; AND GET PCB ADDRESS
	CMPL	R1,PCB$L_PID(R4)		; CHECK FOR PID MATCH
	BNEQ	NONEXPR				; PROCESS IS GONE
	EXTV	#5,#3,R3,R1			; GET CLUSTER NUMBER
	BLSS	ILLEFC				; BR IF ILLEGAL CLUSTER NUMBER
	BICL	#^C<^X1F>,R3			; EXTRACT EVENT NUMBER
	MOVAL	PCB$L_EFCS(R4)[R1],R0		; GET CLUSTER OR PTR ADDR
	PUSHL	#SS$_WASCLR			; ASSUME FLAG WAS CLEAR
	SOBGTR	R1,COMMON			; CHECK FOR COMMON
	.ENABL	LSB
LOCAL:						; POST LOCAL EF
	BBSS	R3,(R0),15$			; SET FLAG, BR IF ALREADY SET
10$:	MOVZBL	PCB$B_WEFC(R4),R1		; GET NUMBER OF WAIT CLUSTER
	MOVAL	PCB$L_EFCS(R4)[R1],R1		; AND COMPUTE ITS ADDRESS
	BSBW	CHKWAIT				; IS WAIT SATISFIED?
EXITN:	POPL	R0				; SET RETURN STATUS CODE
EXITEN:	ENBINT					; 
EXIT:						;
	RSB					; RETURN

15$:	MOVZBL	#SS$_WASSET,(SP)		; SET STATUS, FLAG ALREADY SET
	BRB	10$				; CONTINUE
	.DSABL LSB

ILLEFC:
	MOVZWL	#SS$_ILLEFC,R0			; SET ERROR STATUS CODE
	BRB	EXITEN				; RETURN ERROR TO CALLER

NONEXPR:					; NONEXISTENT PROCESS
	MOVZWL	#SS$_NONEXPR,R0			; SET NONEXISTENT CODE
	BRB	EXITEN				; AND EXIT ENABLING

	.ENABL	LSB
UNASEFC:
	MOVZWL	#SS$_UNASEFC,12(SP)		; SET ERROR STATUS CODE
	BRB	30$				; RESET REGISTERS

COMMON:						; COMMON EVENT POST
	PUSHL	R4				; SAVE R4
	MOVQ	R5,-(SP)			; SAVE R5,R6
	ADDL3	#CEB$L_WQFL,(R0),R5		; POINT TO HEAD OF WAIT QUEUE
	BGEQ	UNASEFC				; BR IF CLUSTER IS NOT ASSIGNED
	MOVL	(R5),R4				; GET HEAD OF WAIT QUEUE
	CMPB	#DYN$C_SLAVCEB,<CEB$B_TYPE-CEB$L_WQFL>(R5) ; IS IT A SLAVE CEB?
	BEQL	50$				; BR IF IT IS A SLAVE
	BBSSI	R3,<CEB$L_EFC-CEB$L_WQFL>(R5),40$ ; SET EVENT FLAG; CHECK STATUS
20$:	CMPL	R4,R5				; CHECK FOR END OF WAIT QUEUE
	BEQL	30$				; DONE
	MOVL	(R4),R6				; SAVE REAL FLINK
	MOVAL	<CEB$L_EFC-CEB$L_WQFL>(R5),R0	; POINT TO EVENT FLAG MASK
	BSBB	EXE$CHKWAIT2			; CHECK FOR WAIT SATISFIED
	MOVL	R6,R4				; NEXT IN WAIT QUEUE
	BRB	20$				; CONTINUE
30$:	MOVQ	(SP)+,R5			; RESTORE R5,R6
	MOVL	(SP)+,R4			; AND R4
	BRB	EXITN				; AND EXIT

40$:	MOVZBL	#SS$_WASSET,12(SP)		; SET STATUS, FLAG ALREADY SET
	BRB	20$				; CONTINUE

;
; SET SHARED MEMORY COMMON EVENT FLAG.
;
50$:	PUSHL	R0			; SAVE R0
	MOVQ	R1,-(SP)		; SAVE REGISTERS
	MOVL	(R0),R0			; GET ADR OF SLAVE CEB
	MOVL	CEB$L_MASTER(R0),R2	; GET ADR OF MASTER CEB
	BBSSI	R3,CEB$L_EFC(R2),110$	; SET THE MASTER COPY FIRST/QUIT IF SET
	MOVZBL	CEB$B_PROCCNT(R2),R1	; GET MAX # OF SLAVE CEB'S
	DECL	R1			; CONVERT COUNT OF PORTS INTO INDEX
60$:	TSTL	CEB$L_VASLAVE1(R2)[R1]	; IS THERE A SLAVE CEB?
	BEQL	90$			; BR IF NO SLAVE, DON'T SEND PROC MSG
	CMPL	R0,CEB$L_VASLAVE1(R2)[R1] ; IS THIS THE CURRENT PROCESSOR?
	BEQL	80$			; BR TO SET FLAG/DON'T SEND MSG TO SELF
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	BSBB	EXE$SHM_CEF_REQ		; SEND PROCESSOR REQUEST FOR CEF COPY
	BLBS	R0,70$			; BR IF SUCCESSFUL
	MOVL	R0,48(SP)		; REMEMBER ERROR CODE IN R0
70$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	BRB	90$			; CONTINUE CHECKING SLAVE CEB'S
80$:	MOVL	CEB$L_EFC(R2),CEB$L_EFC(R0) ; SET SLAVE FLAG
90$:	SOBGEQ	R1,60$			; LOOP FOR MAX NUMBER OF PROCESSORS
100$:	MOVQ	(SP)+,R1		; RESTORE EVENT FLAG NUMBER
	POPL	R0			; RESTORE R0
	BRB	20$			; JOIN COMMON CODE

110$:	MOVZBL	#SS$_WASSET,24(SP)	; SET STATUS CODE, FLAG ALREADY SET
	BRB	100$			; CONTINUE
	.DSABL	LSB
	.PAGE
	.SBTTL	CHKWAIT - CHECK FOR WAIT CONDITION SATISFIED

;++
; FUNCTIONAL DESCRIPTION:
;	CHKWAIT CHECKS THE WAIT CONDITION SPECIFIED IN THE PCB
;	AND RESTARTS THE PREOCESS IF IT IS SATISFIED.
;
; CALLING SEQUENCE:
;	JSB/BSB	CHKWAIT
;
; INPUT PARAMETERS:
;	R0 - EVENT FLAG CLUSTER ADDRESS
;	R1 - ADDRESS OF EVENT FLAG CLUSTER THAT PROCESS IS WAITING ON
;	R2 - PRIORITY INCREMENT CLASS
;	R4 - PCB ADDRESS
;
; SIDE EFFECTS:
;	IF THE WAIT CONDITION IS SATISFIED, THE PROCESS WILL RESUME
;	EXECUTION.  R3 IS DESTROYED.
;
;--

CHKWAIT:					; CHECK FOR WAIT SATISFIED
	.ENABL	LSB
	CMPL	R0,R1				; IS PROCESS WAITING FOR THIS
	BNEQ	20$				; CLUSTER? BR IF NOT
EXE$CHKWAIT2::
	BICL3	PCB$L_EFWM(R4),(R0),R3		; TEST WITH MASK
	BEQL	20$				; WAIT NOT SATISFIED
	BBS	#PCB$V_WALL,PCB$L_STS(R4),30$	; CHK FOR WAIT ANY
;
;	AT THIS POINT:
;			R2 - PRIORITY INCREMENT CLASS NUMBER
;			R4 - PCB ADDRESS OF PROCESS TO ACTIVATE
;
10$:	RPTEVT	EVENT				; REPORT EVENT SET
20$:	RSB					; RETURN
30$:	MCOML	R3,R3				; INVERT MASKED EVENTS
	CMPL	PCB$L_EFWM(R4),R3		; CHECK FOR ALL
	BEQL	10$				; WAIT NOW SATISFIED
	RSB					; RETURN
	.DSABL	LSB
	.PAGE
	.SBTTL	EXE$SHM_CEF_REQ - SEND SHARED MEMORY PROCESSOR REQUEST FOR CEF
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SENDS A MESSAGE TO ANOTHER PROCESSOR VIA A SHARED MEMORY
;	REQUESTING IT TO UPDATE ITS SLAVE CEB.  THIS IS DONE WHENEVER A COMMON
;	EVENT FLAG IN SHARED MEMORY GOES FROM CLEAR TO SET.  THIS ROUTINE MUST
;	BE ENTERED VIA A JSB-TYPE INSTRUCTION SO THAT THE CO-ROUTINE CALLS
;	BETWEEN ITSELF AND MA$REQUEST WORK CORRECTLY.
;
;	FIRST, A FORK BLOCK IS ALLOCATED.  ALL INFORMATION TO BE CONTAINED IN
;	THE INTER-PROCESSOR REQUEST BLOCK IS STORED IN THIS FORK BLOCK.
;	MA$REQUEST IS THEN CALLED TO ALLOCATE A REQUEST BLOCK.  IF THERE IS NO
;	FREE BLOCK, MA$REQUEST RETURNS TO THE CALLER OF SHM_CEF_REQ, I.E.,
;	SCH$POSTEF.  LATER ON, WHEN A REQUEST BLOCK IS FREED UP, A CO-ROUTINE
;	CALL RETURNS TO SHM_CEF_REQ WITH THE ADDRESS OF THE REQUEST BLOCK AND
;	THE ADDRESS OF THE FORK BLOCK.  SHM_CEF_REQ THEN INITIALIZES THE
;	REQUEST BLOCK, DEALLOCATES THE FORK BLOCK, AND RETURNS TO MA$REQUEST.
;	THE OTHER PROCESSOR WILL HANDLE DEALLOCATION OF THE REQUEST BLOCK.
;
;	THE SHARED MEMORY MASTER COMMON EVENT BLOCK MAY BE RELEASED AND
;	RE-USED  DURING THIS ASYNCHRONOUS PROCESS.  THIS DOES NOT MATTER
;	SINCE AN EXTRANEOUS COPY OF THE FLAGS FROM THE MASTER CEB TO THE
;	SLAVE CEB WILL HURT NOTHING.  THE RECEIVING LOGIC MERELY EXITS
;	IF NO SLAVE CEB EXISTS WHEN THE PRQ IS RECEIVED.
;
;	THIS ROUTINE MAY OR MAY NOT RETURN EXECUTION TO SCH$POSTEF.  IF THERE IS
;	AN ERROR ALLOCATING A FORK BLOCK, THIS ERROR IS RETURNED TO SCH$POSTEF.
;	ONCE MA$REQUEST IS CALLED, THE FLOW OF EXECUTION MAY PROCEED DIRECTLY
;	FROM MA$REQUEST BACK TO SCH$POSTEF.  THIS OCCURS IF THERE IS NO REQUEST
;	PACKET IMMEDIATELY AVAILABLE.  IT IS ASSUMED THAT A PACKET WILL
;	EVENTUALLY BECOME AVAILABLE AND THEREFORE A SUCCESSFUL STATUS IS
;	RETURNED TO SCH$POSTEF.  WHEN THE PACKET BECOMES AVAILABLE, THE REST OF
;	SHM_CEF_REQ IS EXECUTED AS A FORK PROCESS.  ANY ERRORS ENCOUNTERED AT
;	THIS TIME ARE NOT REPORTED TO THE USER AS THEY OCCUR ASYNCHRONOUSLY
;	TO HIS REQUEST.
;
;	IF THERE IS A REQUEST PACKET AVAILABLE, THEN THE FLOW OF EXECUTION
;	RETURNS FROM MA$REQUEST TO SHM_CEF_REQ VIA A CO-ROUTINE CALL.
;	SHM_CEF_REQ INITIALIZES THE REQUEST BLOCK AND RELEASES THE FORK
;	BLOCK.  THEN IT RETURNS TO MA$REQUEST.  MA$REQUEST PLACES THE REQUEST
;	ON THE APPROPRIATE QUEUE, INTERRUPTS THE APPROPRIATE PORT, AND RETURNS
;	TO SCH$POSTEF.
;
;	IF MA$REQUEST ENCOUNTERS AN ERROR (SUCH AS A BAD QUEUE HEADER), IT
;	RETURNS THIS ERROR CODE TO SHM_CEF_REQ VIA AN RSB INSTEAD OF A
;	CO-ROUTINE CALL.  SHM_CEF_REQ RELEASES THE FORK BLOCK AND RETURNS,
;	ONLY NOT TO MA$REQUEST, IN THIS CASE, BUT TO SCH$POSTEF.  SCH$POSTEF
;	WILL RETURN THIS ERROR CODE TO THE USER.  NOTE THAT THE SYSTEM
;	SERVICE WILL HAVE PARTIAL SUCCESS AS THE MASTER CEB FLAG WILL HAVE
;	BEEN UPDATED.
;
; CALLING SEQUENCE:
;
;	JSB	EXE$SHM_CEF_REQ
;
; INPUT PARAMETERS:
;
;	R0 - VA OF SLAVE CEB FOR PORT THAT THE REQUEST IS FROM
;	R1 - PORT # TO SEND THE REQUEST TO
;	R2 - ADDRESS OF THE MASTER CEB IN SHARED MEMORY
;
; IMPLICIT PARAMETERS:
;
;	THE SHARED MEMORY DATA STRUCTURES.
;
; OUTPUT PARAMETERS:
;
;	R0 - COMPLETION STATUS CODE
;	R1 - R5 DESTROYED
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFUL COMPLETION
;	SS$_BADQUEUEHDR - UNABLE TO ALLOCATE INTER-PROCESSOR REQUEST BLOCK
;	OTHERS FROM ALLOCATION/DEALLOCATION ROUTINES.
;--

EXE$SHM_CEF_REQ:			; RTN TO SEND INTER-PROCESSOR REQUEST

	.ENABL	LSB
	ASSUME IRP$C_LENGTH GT <FKB$C_LENGTH + 12>
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE REGISTERS
	MOVZWL	#IRP$C_LENGTH,R1	; ALLOCATE IRP INSTEAD OF FKB FOR SPEED
	BSBW	EXE$ALONONPAGED		; GET A FORK BLOCK BUT DO NOT WAIT
					; FOR THE RESOURCE IF NONE IS AVAILABLE
	BLBS	R0,5$			; BR IF SUCCESSFUL, BLOCK ALLOCATED
	MOVL	R0,(SP)			; REMEMBER ERROR CODE
	BRB	RETURN			; RETURN ERROR CODE TO CALLER
5$:	MOVL	R2,R5			; SAVE ADDRESS OF FKB
	POPR	#^M<R0,R1,R2,R3>	; RESTORE REGISTERS
;
; INITIALIZE THE FORK BLOCK WITH EVERYTHING NEEDED TO INITIALIZE THE
; INTER-PROCESSOR REQUEST PACKET AS EXECUTION MAY CHANGE TO A FORK PROCESS.
;
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5) ; SET FORK IPL
	MOVW	R1,<FKB$C_LENGTH>(R5)	; SET PORT # REQUEST IS SENT TO
	MOVL	CEB$L_SHB(R0),R4	; GET ADR OF SH MEM CONTROL BLOCK
	MOVZBW	SHB$B_PORT(R4),<FKB$C_LENGTH+2>(R5) ; SET PORT # SENDING REQUEST
	MOVZBL	#PRQ$C_SETEF,<FKB$C_LENGTH+8>(R5) ; REMEMBER SUB-TYPE OF PRQ BLK
	MOVZWL	CEB$W_INDX(R0),<FKB$C_LENGTH+4>(R5) ; SET INDEX TO MASTER CEB
	MOVL	SHB$L_ADP(R4),R4	; ADR OF ADAPTOR CONTROL BLOCK
;
; NOW ACQUIRE AN INTER-PROCESSOR REQUEST BLOCK.  EXECUTION THROUGH THE
; FOLLOWING LINES OF CODE MAY BE ASYNCHRONOUS IF NO BLOCK IS CURRENTLY
; AVAILABLE.  ASYNCHRONOUS EXECUTION WILL BE DONE AS A FORK PROCESS.
;
20$:	JSB	MA$REQUEST		; ALLOCATE A REQUEST BLOCK
					; R4 AND R5 MUST BE PRESERVED THRU RSB
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE REGISTERS AS SET BY MA$REQUEST
	BLBC	R0,ERROR_PRQ		; BR IF ERROR ALLOCATING REQUEST BLOCK
;
; R2 - INTER-PROCESSOR REQUEST BLOCK ADDRESS
; R5 - FORK BLOCK ADDRESS
;
	ASSUME PRQ$W_FR_PORT EQ <PRQ$W_TO_PORT + 2>
	MOVL	<FKB$C_LENGTH>(R5),PRQ$W_TO_PORT(R2) ; SET PORT #'S
	MOVB	FKB$B_FIPL(R5),FKB$B_FIPL(R2) ; SET REQUEST HANDLER IPL
	MOVW	#PRQ$C_EXEC,PRQ$W_DISPATCH(R2) ; SET EXECUTIVE REQUEST TYPE
	MOVW	<FKB$C_LENGTH+8>(R5),PRQ$W_REQTYPE(R2) ; SET REQUEST SUB-TYPE
	MOVL	<FKB$C_LENGTH+4>(R5),PRQ$L_PARAM(R2) ; SET INDEX TO MASTER CEB
ERROR_PRQ:
	MOVL	R5,R0			; SET ADR OF FORK BLOCK TO RELEASE
	BSBW	EXE$DEANONPAGED		; RELEASE FORK BLOCK
RETURN:
	POPR	#^M<R0,R1,R2,R3>	; RESTORE REGISTERS AND ERROR CODE
	RSB				; RETURN TO MA$REQUEST OR SCH$POSTEF

	.DSABL	LSB

	.END
