
	.TITLE	SYSASCEFC - ASSOCIATE, DISASSOCIATE AND DELETE COMMON EVENT FLAG CLUSTER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT:
;
; ENVIRONMENT:
;
;--
;
;	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:	R. HUSTVEDT	 CREATION DATE: 3-OCT-76
;
; MODIFIED BY:
;
;	V02-010 MSH0001		Maryann Hinden		26-Jan-1982
;		Fix PROBE problem.
;
;	V02-009	KDM0077		Kathleen D. Morse	15-Jan-1982
;		Use master pid for owner of cluster so that quota is
;		returned correctly if a sub-process creates a cluster.
;
;	V02-008	KDM0076		Kathleen D. Morse	15-Jan-1982
;		Do not charge quota for permanent, local memory common
;		event flag clusters.
;
;	V02-007	KDM0069		Kathleen D. Morse	18-Nov-1981
;		Fix miscellaneous shared memory common event flag bugs.
;
;	V02-006	KDM0049		Kathleen D. Morse	28-Mar-1981
;		Replace absolute literals with references to EXE$GL_LOCKRTRY.
;
;
;	, : VERSION
; 01	 -

	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$CEBDEF				; DEFINE COMMON EVENT CONTROL BLOCK
	$DYNDEF				; DEFINE DATA STRUCTURE TYPES
	$IPLDEF				; DEFINE IPL VALUES
	$JIBDEF				; DEFINE JIB OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRQDEF				; DEFINE INTER-PROCESSOR REQUEST
	$PRVDEF				; DEFINE PRIVILEGE BITS
	$SHBDEF				; DEFINE SHARED MEMORY CONTROL BLOCK
	$SHDDEF				; DEFINE SHARED MEMORY COMMON DATA PAGE
	$SSDEF				; DEFINE STATUS CODE VALUES
	$STATEDEF			; DEFINE SCHEDULER STATES

;
; EQUATED SYMBOLS:
;

EFN=4					; EFN ARGUMENT DISPLACEMENT
NAME=8					; NAME ARGUMENT DISPLACEMENT
PROT=12					; PROTECTION MASK DISPLACEMENT
PERM=16					; PERMANENT INDICATOR DISPLACEMENT

;
; OWN STORAGE:
;

	.PAGE
	.SBTTL	RETQUOTA - RETURN CEF QUOTA
;+
; FUNCTIONAL DESCRIPTION:
;	RETQUOTA RETURNS THE QUOTA TO THE ORIGINAL CREATOR OF THE
;	COMMON EVENT CLUSTER.  IF THE PROCESS IDENTIFIED AS THE CLUSTER
;	CREATOR HAS BEEN DELETED, THEN NO OPERATION IS PERFORMED.
;
; CALLING SEQUENCE:
;	BSB/JSB	RETQUOTA
;
; INPUT PARAMETERS:
;	R0 - ADDRESS OF COMMON EVENT BLOCK
;	R2 - PROCESS INDEX OF CREATOR
;
; OUTPUT PARAMETERS:
;	R0 - R0 (PRESERVED)
;
;--

RETQUOTA:				; RETURN QUOTA
	DSBINT	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	MOVL	@W^SCH$GL_PCBVEC[R2],R1	; CONVERT TO PCB ADDRESS
	CMPL	PCB$L_PID(R1),CEB$L_PID(R0) ; CHECK FOR EXISTENCE
	BNEQ	10$			; NO, IGNORE QUOTA
	MOVL	PCB$L_JIB(R1),R1	; GET JIB ADDRESS
	INCW	JIB$W_TQCNT(R1)		; GIVE BACK QUOTA
10$:	ENBINT				; ENABLE SYSTEM EVENTS
	RSB				; RETURN
	.PAGE
	.SBTTL	EXE$DACEFC - DISASSOCIATE COMMON EVENT CLUSTER

;++
; FUNCTIONAL DESCRIPTION:
;	EXE$DACEFC IMPLEMENTS THE DISASSOCIATE COMMON EVENT CLUSTER
;	SYSTEM SERVICE.  THE ISSUING PROCESS IS DISASSOCIATED WITH
;	THE CLUSTER SELECTED BY THE SPECIFIED EVENT FLAG NUMBER AND
;	THE CLUSTER CONTROL BLOCK (CEB) WILL BE RELEASED IF THE REFERENCE
;	COUNT BECOMES ZERO AND IT IS NOT MARKED PERMANENT.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$DACEFC
;
; INPUT PARAMETERS:
;	EFN(AP) - EVENT FLAG NUMBER TO SELECT CLUSTER TO DISASSOCIATE.
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;
; COMPLETION CODES:
;	SS$_NORMAL  -  SUCCESSFUL COMPLETION
;	SS$_ILLEFC  -  ILLEGAL EVENT FLAG NUMBER FOR COMMON EVENT CLUSTER
;		       MUST BE 64-127
;
; SIDE EFFECTS:
; 	IF THE REFERENCE COUNT FOR THE SELECTED COMMON EVENT CLUSTER
;	BECOMES ZERO AND IT IS NOT MARKED AS PERMANENT, IT WILL BE
;	DELETED.
;
;--

	.PSECT	Y$EXEPAGED,BYTE
EXE$DACEFC::				; DISASSOCIATE COMMON EVENT CLUSTER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; SAVE REGISTERS R2-R11
	BSBB	GETCLUSTER		; GET CLUSTER INDEX AND VALIDATE
	PUSHL	PCB$L_EFC2P(R4)[R8]	; PUSH ADDRESS OF CEB FOR THIS CLUSTER
	CLRL	PCB$L_EFC2P(R4)[R8]	; CLEAR POINTER
	BSBW	CEBLOCK			; LOCK MUTEX FOR WRITE
	MOVL	R4,R7			; REMEMBER PCB ADDRESS
	BRW	DISASOC			; DISASSOCIATE CLUSTER
	.PAGE
	.SBTTL	GETCLUSTER - GET AND VERIFY CLUSTER NUMBER

;++
; FUNCTIONAL DESCRIPTION:
;	GETCLUSTER EXTRACTS THE CLUSTER NUMBER FROM THE EFN ARGUMENT,
;	VALIDATES IT AND SUBTRACTS THE LOCAL EVENT CLUSTER BIAS TO
;	FORM A COMMON EVENT CLUSTER INDEX.  IF THE CLUSTER NUMBER
;	IS NOT A VALID COMMON EVENT CLUSTER, AN EXIT IS MADE FROM
;	THE SERVICE BY ISSUING A RET.
;
; CALLING SEQUENCE:
;	BSB/JSB	GETCLUSTER
;
; INPUT PARAMETERS:
;	EFN(AP) - EVENT FLAG NUMBER
;
; OUTPUT PARAMETERS:
;	R8 - COMMON EVENT CLUSTER INDEX
;
; COMPLETION CODES:	(ON ERROR RETURN ONLY)
;	SS$_ILLEFC - ILLEGAL COMMON EVENT CLUSTER
;
;--

GETCLUSTER:				; GET COMMON EVENT CLUSTER INDEX
	EXTV	#5,#3,EFN(AP),R8	; EXTRACT CLUSTER FROM EFN
	SUBL	#2,R8			; SUBTRACT BIAS
	BLSS	10$			; ILLEGAL CLUSTER NUMBER
	RSB				; SUCCESSFUL RETURN

10$:	MOVZWL	#SS$_ILLEFC,R0		; SET ERROR CODE
	RET				; AND EXIT SERVICE CALL


	.PAGE
	.SBTTL	EXE$ASCEFC - ASSOCIATE AND CREATE COMMON EVENT CLUSTER

;++
; FUNCTIONAL DESCRIPTION:
;	EXE$ASCEFC IMPLEMENTS THE ASSOCIATE COMMON EVENT CLUSTER SYSTEM 
;	SERVICE.  IF THE NAMED COMMON EVENT CLUSTER DOES NOT ALREADY
;	EXIST, IT WILL BE CREATED.  IF IT ALREADY EXISTS, THE PROCESS
;	WILL BE ASSOCIATED WITH IT, PROTECTION PERMITTING.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$ASCEFC
;
; INPUT PARAMETERS:
;	EFN(AP)  - EVENT FLAG NUMBER TO SPECIFY CLUSTER NUMBER
;	NAME(AP) - ADDRESS OF STRING DESCRIPTOR FOR NAME OF CLUSTER
;	PROT(AP) - PROTECTION MASK FOR CLUSTER IF CREATING
;	PERM(AP) - INDICATOR TO SPECIFY CREATION OF PERMANENT CLUSTER
;	R4 - PCB ADDRESS
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;
; IMPLICIT OUTPUTS:
;	PCB$L_EFC2P - POINTER TO COMMON EVENT CONTROL BLOCK IF CLUSTER 2
;	PCB$L_EFC3P - POINTER TO COMMON EVENT CONTROL BLOCK IF CLUSTER 3
;
; COMPLETION CODES:
;	SS$_NORMAL      - SUCCESSFUL COMPLETION
;	SS$_ACCVIO      - LOGICAL NAME INACCESSIBLE
;	SS$_EXQUOTA     - QUOTA FOR COMMON EVENT BLOCK CREATION EXHAUSTED
;	SS$_ILLEFC      - ILLEGAL CLUSTER NUMBER (NOT 0,1,2,3)
;	SS$_IVLOGNAM    - COUNT FOR LOGICAL NAME NOT 1-15
;	SS$_NOPRIV      - PRIVILEGE VIOLATION
;	SS$_SHMNOTCNCT  - SHARED MEMORY NOT CONNECTED
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAME TRANSLATIONS
;
; SIDE EFFECTS:
;	AN IMPLIED DISASSOCIATE IS PERFORMED ON THE SPECIFIED CLUSTER
;	AND THE PREVIOUSLY ASSOCIATED COMMON EVENT CLUSTER MAY BE
;	DELETED IF IT IS NOT MARKED PERMANENT AND ITS REFERENCE COUNT
;	BECOMES ZERO.
;
;--

	.ENABL	LSB
EXE$ASCEFC::				; ASSOCIATE COMMON EVENT CLUSTER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTER SAVE MASK
	BSBB	GETCLUSTER		; GET CLUSTER INDEX AND VALIDATE
	MOVL	NAME(AP),R9		; GET POINTER TO CLUSTER NAME
	PUSHL	PERM(AP)		; SAVE PERMANENT INDICATOR
	SUBL	#<4*8>,SP		; ALLOCATE SPACE FOR NAMES ON STACK
	BSBW	LOCLUST			; LOCATE CLUSTER
	MOVL	PCB$L_JIB(R7),R10	; GET ADDRESS OF JIB
	MOVAB	JIB$W_TQCNT(R10),R10	; POINT TO TQCNT FIELD
;
; R2 = ADR OF LOCAL COMMON EVENT BLOCK (PERHAPS SLAVE)
;      (0 IF NOT YET CREATED)
; R4 = ADR OF SHARED MEMORY CONTROL BLOCK (IF IN SHARED MEMORY)
; R5 = ADR OF SHARED MEMORY COMMON DATA PAGE (IF IN SHARED MEMORY)
; R6 = ADR OF SHARED MEMORY MASTER COMMON EVENT BLOCK (IF IN SHARED MEMORY)
;      (0 IF NOT YET CREATED)
; R7 = ADR OF PROCESS CONTROL BLOCK
; R8 = INDEX TO APPROPRIATE CLUSTER IN PCB
; R10 = ADDRESS OF JIB$W_TQCNT, QUOTA FOR COMMON EVENT BLOCKS
;  0(SP) = ASCIC COMMON EVENT FLAG CLUSTER NAME
; 16(SP) = ASCIC SHARED MEMORY NAME
; 32(SP) = PERMANENT INDICATOR
;
	TSTL	R2			; WAS NAME FOUND
	BEQL	10$			; BR IF NAME NOT FOUND, CREATE CEB
	BRW	ASSOCIATE		; BR AS NAME FOUND, ASSOCIATE IT
10$:	TSTL	R6			; IS THERE A MASTER SHMCEB?
	BEQL	11$			; BR IF NO MASTER EXISTS
	MOVB	CEB$B_STS(R6),32(SP)	; FORCE SLAVES TO BE SAME AS MASTER
11$:	BLBC	32(SP),15$		; SKIP PRMCEB PRIV CHK IF CREATING TEMP
	BBS	#PRV$V_PRMCEB,@PCB$L_PHD(R7),15$ ;BR IF HAVE PRIV TO CREATE
12$:	MOVZBL	#SS$_NOPRIV,R0		; SET ERROR CODE
	BRB	36$			; AND RETURN FROM SYSTEM SERVICE
15$:	TSTB	16(SP)			; IS THIS A SHARED MEMORY CLUSTER?
	BNEQ	30$			; BR IF YES, DONT CHARGE QUOTA
	BLBS	32(SP),32$		; DONT CHARGE QUOTA IF PERM CLUSTER
	TSTW	(R10)			; CHECK IF QUOTA REMAINING
	BGTRU	20$			; CONTINUE IF QUOTA REMAINING
	MOVZBL	#SS$_EXQUOTA,R0		; SET STATUS CODE FOR QUOTA EXHAUSTED
	BRB	37$			; AND RETURN FROM SYSTEM SERVICE
20$:	DECW	(R10)			; ACCOUNT FOR COMMON EVENT BLOCK
	BRB	32$			; GO ALLOCATE A LOCAL MEMORY CEB
30$:	TSTL	R6			; IS MASTER SHMCEB ALREADY CREATED?
	BNEQ	32$			; BR IF MASTER SHMCEB EXISTS
	BBC	#PRV$V_SHMEM,@PCB$L_PHD(R7),12$ ; EXIT SERVICE IF NOT PRIVILEGED
	BSBW	ALOSHMCEB		; GO ALLOCATE A MASTER SHMCEB
					; R6 = ADR OF MASTER SHMCEB
	BLBC	R0,37$			; BR IF NO FREE CEB
32$:	BSBW	EXE$ALLOCCEB		; ALLOCATE SPACE FOR CEB/SLAVCEB
					; R2 = ADR OF SLAVE CEB
	BLBS	R0,40$			; CONTINUE IF SUCCESSFUL
	TSTL	R6			; IS THIS A SHARED MEMORY CLUSTER?
	BNEQ	36$			; BR IF YES, DONT RETURN QUOTA
	BLBS	32(SP),37$		; SKIP QUOTA IF CREATING PERM
35$:	INCW	(R10)			; RETURN QUOTA IF ERROR
	BRW	EXIT			; RETURN ERROR TO SYSTEM SERVICE
36$:	TSTL	R6			; IS THERE A MASTER CEB?
	BEQL	37$			; BR ON NO MASTER CEB
	PUSHL	R0			; REMEMBER FIRST ERROR CODE
	BSBW	DEC_SHMCEB_REF		; RELEASE LOCK PREVENTING DELETION
	POPL	R0			; IGNORE POTENTIAL INTERLOCKING PROBLEM
	BBS	#CEB$V_VALID,CEB$L_CEBFL(R6),37$ ; BR IF MASTER NOT JUST CREATED
	BBCCI	#CEB$V_LOCKED,CEB$L_CEBFL(R6),37$ ; RELEASE MASTER FOR OTHER USE
37$:	BRW	EXIT			; EXIT IF NO SPACE FOR CEB
40$:					;
;
; R2 = ADR OF LOCAL COMMON EVENT BLOCK (PERHAPS SLAVE)
; R4 = ADR OF SHARED MEMORY CONTROL BLOCK (IF IN SHARED MEMORY)
; R5 = ADR OF SHARED MEMORY COMMON DATA PAGE (IF IN SHARED MEMORY)
; R6 = ADR OF SHARED MEMORY MASTER COMMON EVENT BLOCK (IF IN SHARED MEMORY)
; R7 = ADR OF PROCESS CONTROL BLOCK
; R10 = ADDRESS OF JIB$W_TQCNT, QUOTA FOR COMMON EVENT BLOCK
;
;
; FIRST INITIALIZE THE CEB FIELDS USED IN THE LOCAL MEMORY CEB AND NOT
; IN THE SLAVE CEB.  THIS ALLOWS A BRANCH BACK TO 41$ IF A RACE OCCURS
; DURING CREATION OF THE MASTER CEB.
;
	MOVW	PROT(AP),CEB$W_PROT(R2)	; SET PROTECTION MASK
	INSV	32(SP),#CEB$V_PERM,#1,CEB$B_STS(R2) ; SET PERMANENT FLAG
;
; NOW INITIALIZE THE CEB FIELDS IN COMMON TO A LOCAL MEMORY CEB AND A
; SLAVE CEB.
;
41$:	MOVAL	CEB$L_WQFL(R2),CEB$L_WQFL(R2) ; SET UP WAIT QUEUE HEADER
	MOVAL	CEB$L_WQFL(R2),CEB$L_WQBL(R2) ; FORWARDS AND BACKWARDS LINKS
	CLRW	CEB$W_WQCNT(R2)		; CLEAR QUEUE COUNT
	CLRL	CEB$L_EFC(R2)		; EVENT FLAG SET
	CLRW	CEB$W_REFC(R2)		; INIT REFERENCE COUNT TO 1
	MOVL	PCB$L_UIC(R7),CEB$L_UIC(R2) ; SET UIC OF CLUSTER OWNER
	MOVL	<JIB$L_MPID-JIB$W_TQCNT>(R10),CEB$L_PID(R2) ; AND MASTER PID SO
					; THAT QUOTA WILL BE RETURNED CORRECTLY
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS FOR MOVC3
	MOVC3	#16,16(SP),CEB$T_EFCNAM(R2) ; FILL IN CLUSTER NAME
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	MOVW	#SCH$C_CEF,CEB$W_STATE(R2) ; SET WAIT STATE NUMBER
	TSTB	16(SP)			; IS THIS IN SHARED MEMORY?
	BNEQ	39$			; BR IF IN SHARED MEMORY
	BRW	50$			; BR IF IN LOCAL MEMORY
39$:	MOVZBL	SHB$B_PORT(R4),R1	; GET PROCESSOR PORT INDEX
	MOVB	#DYN$C_SLAVCEB,CEB$B_TYPE(R2) ; INDICATE ENTRY IS SLAVE CEB
	MOVL	CEB$L_EFC(R6),CEB$L_EFC(R2) ; COPY FLAGS FROM MASTER CEB
	MOVL	R4,CEB$L_SHB(R2)	; SET ADR OF SHARED MEMORY CONTROL BLOCK
	MOVL	R2,CEB$L_VASLAVE1(R6)[R1] ; SET VA OF SLAVE CEB
	MOVL	R6,CEB$L_MASTER(R2)	; SET ADR OF MASTER IN SLAVE CEB
	BSBW	INC_SHMCEB_REF		; ADD REFCNT FOR SLAVCEB TO MASTER CEB
;	BLBC	R0,XXX			; BR IF INTERLOCK ERROR
	BBCC	#CEB$V_PERM,CEB$B_STS(R2),115$ ; SLAVES ARE ALWAYS TEMP
115$:	ADDL3	R5,SHD$L_CEFPTR(R5),R1	; GET ADR OF SHM CEF TABLE
	SUBL3	R1,R6,R1		; GET OFFSET TO CEB ENTRY
	MOVZWL	CEB$W_SIZE(R6),R0	; GET SIZE OF ONE ENTRY
	DIVL2	R0,R1			; GET # OF ENTRIES INTO TABLE
	MOVW	R1,CEB$W_INDX(R2)	; SET INDEX INTO MASTER CEB TABLE
	BBC	#CEB$V_VALID,CEB$L_CEBFL(R6),112$ ; BR IF MASTER JUST CREATED
	BRW	50$			; BR IF MASTER NOT JUST CREATED
;
; HERE CHECK IF THE NEWLY CREATED MASTER SHMGSD IS UNIQUE OR NOT.
;
112$:	BSBW	UNIQUE_CEB		; CHECK THAT ANOTHER CEB WAS NOT CREATED
	TSTL	R11			; WAS THERE A DUPLICATE?
	BEQL	48$			; BR ON NO DUPLICATE
	MOVZBL	SHB$B_PORT(R4),R3	; GET PORT # INDEX
	BBSSI	#CEB$V_PERM,CEB$B_STS(R6),113$ ; INHIBIT DELETION CODE EXECUTION
113$:	CLRL	CEB$L_VASLAVE1(R6)[R3]	; INDICATE NO SLAVE ASSOCIATED
	BSBW	DEC_SHMCEB_REF		; RELEASE ASSOC AND SLAVECEB REFCNTS ON
	BSBW	DEC_SHMCEB_REF		; MASTER CEB JUST CREATED
					; IGNORE INTERLOCK ERRORS FOR BOTH
	BBCCI	#CEB$V_LOCKED,CEB$L_CEBFL(R6),42$ ; RELEASE CEB FOR OTHER USE
42$:	TSTL	CEB$L_VASLAVE1(R11)[R3]	; IS THERE ALREADY A SLAVE CEB?
	BEQL	43$			; BR TO USE SLAVE CEB JUST CREATED
	MOVL	R2,R0			; SET ADR OF SLAVE CEB JUST CREATED
	JSB	EXE$DEANONPAGED		; RELEASE SLAVE CEB
	MOVZBL	SHB$B_PORT(R4),R3	; GET PORT # INDEX (DESTROYED BY JSB)
	MOVL	CEB$L_VASLAVE1(R11)[R3],R2 ; GET ADR OF OLD SLAVE CEB
	BRB	ASSOCIATE		; GO ASSOCIATE WITH OLD SLAVE CEB
43$:	MOVL	R11,R6			; SET ADR OF DUPLICATE MASTER CEB
	MOVB	CEB$B_STS(R6),CEB$B_STS(R2) ; SET SLAVE STATUS SAME AS MASTER
	MOVW	CEB$W_PROT(R6),CEB$W_PROT(R2) ; COPY PROTECTION FROM DUPLICATE
	BRW	41$			; GO INITIALIZE SLAVE CEB AGAIN
48$:	BBSSI	#CEB$V_VALID,CEB$L_CEBFL(R6),49$ ; INDICATE ENTRY IS VALID
49$:	BBCCI	#CEB$V_LOCKED,CEB$L_CEBFL(R6),50$ ; CLEAR THE LOCK BIT
;
; ADD NEW SLAVE CEB TO LOCAL MEMORY DATA STRUCTURES.
;
50$:	INCW	SCH$GW_CEBCNT		; INCREMENT COUNT OF COMMON EVENT BLOCKS
	INSQUE	(R2),SCH$GQ_CEBHD	; INSERT CEB IN LIST

	.DSABL	LSB

ASSOCIATE:				; R6 MAY NOT BE MASTER CEB FOR R2 HERE
	INCW	CEB$W_REFC(R2)		; REFERENCE CLUSTER
	PUSHL	PCB$L_EFC2P(R7)[R8]	; GET POINTER TO CURRENT CLUSTER
	MOVL	R2,PCB$L_EFC2P(R7)[R8]	; SET CLUSTER POINTER IN PCB
DISASOC:
	.ENABL	LSB
	MOVL	(SP)+,R0		; GET OLD CLUSTER ADDRESS
	BEQL	EXITN			; NONE
	CMPB	#DYN$C_SLAVCEB,CEB$B_TYPE(R0) ; IS THIS A SLAVE CEB?
	BNEQ	5$			; BR IF NORMAL LOCAL MEMORY CEB
	MOVL	CEB$L_SHB(R0),R4	; GET ADR OF SHARED MEMORY CONTROL BLOCK
	MOVL	CEB$L_MASTER(R0),R6	; GET ADR OF MASTER CEB
	PUSHL	R0			; SAVE ADR OF SLAVE CEB
	BSBW	DEC_SHMCEB_REF		; DECREMENT ASSOC REFCNT IN MASTER CEB
	POPL	R0			; IGNORE POTENTIAL INTERLOCK ERROR
5$:	DECW	CEB$W_REFC(R0)		; DECREMENT REFERENCE COUNT
	BGTR	EXITN			; STILL BUSY, CANT RELEASE YET
	CMPB	#DYN$C_SLAVCEB,CEB$B_TYPE(R0) ; IS THIS A SLAVE CEB?
	BEQL	10$			; BR IF YES, DONT RETURN QUOTA
	BBS	#CEB$V_PERM,CEB$B_STS(R0),EXITN	; PERMANENT CLUSTER
	BBS	#CEB$V_NOQUOTA,CEB$B_STS(R0),10$ ; CHECK FOR QUOTA
	MOVZWL	CEB$L_PID(R0),R2	; GET PIX OF CREATOR
	JSB	RETQUOTA		; RETURN QUOTA
10$:	DECW	SCH$GW_CEBCNT		; DECREASE COUNT OF COMMON EVENT BLOCKS
	REMQUE	(R0),R1			; REMOVE FROM LIST
	CMPB	#DYN$C_SLAVCEB,CEB$B_TYPE(R0) ; IS THIS A SLAVE CEB?
	BNEQ	20$			; BR IF NORMAL LOCAL MEMORY CEB
	JSB	EXE$DEANONPAGED		; RELEASE SLAVE CEB
	MOVZBL	SHB$B_PORT(R4),R1	; PORT # FOR THIS PROCESSOR
	CLRL	CEB$L_VASLAVE1(R6)[R1]	; INDICATE NO SLAVE CEB FOR PROCESSOR
	BSBW	DEC_SHMCEB_REF		; RELEASE SLAVCEB REFCNT IN MASTER CEB
	BRB	EXIT			; BRANCH TO COMMON CODE

20$:	JSB	EXE$DEANONPAGED		; DEALLOCATE SPACE FOR LOCAL CEB
EXITN:	MOVZBL	#SS$_NORMAL,R0		; SET NORMAL COMPLETION STATUS
EXIT:	PUSHL	R0			; SAVE COMPLETION STATUS
EXITE:	MOVAL	EXE$GL_CEBMTX,R0	; GET ADDRESS OF CEB MUTEX
	MOVL	R7,R4			; RESTORE ADDRESS OF PCB
	JSB	SCH$UNLOCK		; AND FREE IT
	POPR	#^M<R0>			; RESTORE COMPLETION CODE
	SETIPL	#0			; ENABLE
	RET				; AND RETURN TO CALLER

	.DSABL	LSB
	.PAGE
	.SBTTL	EXE$DLCEFC - DELETE COMMON EVENT CLUSTER
NAME=4					; NAME DISPLACEMENT IN ARGLIST


;++
; FUNCTIONAL DESCRIPTION:
;	EXE$DLCEFC IMPLEMENTS THE DELETE COMMON EVENT CLUSTER SYSTEM
;	SERVICE WHICH PERMITS A PERMANENT COMMON EVENT CLUSTER TO BE
;	MARKED FOR DELETION WHEN ITS REFERENCE COUNT BECOMES ZERO.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$DLCEFC
;
; INPUT PARAMETERS:
;	NAME(AP) - ADDRESS OF STRING DESCRIPTOR FOR NAME OF CLUSTER
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;
; COMPLETION CODES:
;	SS$_NORMAL  -  SUCCESSFUL COMPLETION OF SERVICE
;	SS$_NOPRIV  -  INSUFFICIENT PRIVILEGE TO DELETE CLUSTER
;
; SIDE EFFECTS:
;	IF THE REFERENCE COUNT FOR THE SPECIFIED CLUSTER IS ZERO, 
;	THE CLEARING OF THE PERMANENT BIT WILL CAUSE IT TO BE DELETED.
;
;--

EXE$DLCEFC::				; DELETE COMMON EVENT CLUSTER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; REGISTER SAVE MASK
	MOVL	NAME(AP),R9		; GET POINTER TO CLUSTER NAME
	SUBL	#32,SP			; CREATE SPACE FOR NAME STRINGS
	BSBB	LOCLUST			; LOCATE CLUSTER BY NAME
	TSTL	R2			; WAS NAME FOUND
	BEQL	40$			; NO, GO CHECK IF THERE'S A MASTER CEB
	CMPL	PCB$L_UIC(R7),CEB$L_UIC(R2) ; OWNER OF CLUSTER?
	BEQL	10$			; YES, PERMIT ANYWAY
	BBS	#PRV$V_PRMCEB,@PCB$L_PHD(R7),10$ ; CONTINUE IF PRIVILEGED
5$:	MOVZBL	#SS$_NOPRIV,R0		; SET ERROR CODE
	BRB	EXIT			; EXIT RELEASING MUTEX
10$:	BBCC	#CEB$V_PERM,CEB$B_STS(R2),20$ ; CLEAR PERMANENT FLAG
	BBSS	#CEB$V_NOQUOTA,CEB$B_STS(R2),20$ ; SET NO QUOTA
20$:	PUSHL	R2			; SAVE CLUSTER ADDRESS
	INCW	CEB$W_REFC(R2)		; TEMPORARILY REFERENCE IT
	TSTL	R6			; IS THERE A MASTER CEB, ALSO?
	BEQL	30$			; BR IF NO MASTER CEB TO DELETE
	BBC	#PRV$V_SHMEM,@PCB$L_PHD(R7),5$ ; BR IF NOT PRIV TO DELETE
	BBCCI	#CEB$V_PERM,CEB$B_STS(R6),25$ ; CHANGE STATUS TO TEMP FOR DELET
25$:	MOVB	SHB$B_PORT(R4),CEB$B_DELETPORT(R6) ; INDICATE PORT # OF DELETOR
30$:	BRW	DISASOC			; DISASSOCIATE
					; RELEASING CEB IF IDLE
40$:	TSTL	R6			; IS THERE A MASTER CEB TO DELETE?
	BEQL	EXITN			; BR IF NONE, EXIT WITH NORMAL STATUS
	CMPL	PCB$L_UIC(R7),CEB$L_UIC(R6) ; OWNER OF CLUSTER?
	BEQL	50$			; YES, PERMIT DELETION
	BBC	#PRV$V_PRMCEB,@PCB$L_PHD(R7),5$ ; BR IF NOT PRIVILEGED
50$:	BBC	#PRV$V_SHMEM,@PCB$L_PHD(R7),5$ ; BR IF NOT PRIV TO DELETE
60$:	BBCCI	#CEB$V_PERM,CEB$B_STS(R6),70$ ; CHANGE STATUS TO TEMP FOR DELETE
70$:	BSBW	DEC_SHMCEB_REF		; RELEASE SEARCH CNT; TRY TO DEL MASTER
	BRW	EXIT			; EXIT AT COMPLETION CODE REPORTING



	.PAGE
	.SBTTL	CEBLOCK - LOCK COMMON EVEN BLOCK MUTEX FOR WRITE

;++
; FUNCTIONAL DESCRIPTION:
;	CEBLOCK LOCKS THE COMMON EVENT BLOCK MUTEX FOR WRITE AND
;	RETURNS WITH IPL AT IPL$_ASTDEL.
;
; CALLING SEQUENCE:
;	BSB/JSB	CEBLOCK
;
; INPUT PARAMETERS:
;
;	R4 - PCB ADDRESS
;
;--

CEBLOCK:				; LOCK CEB MUTEX FOR WRITE
	MOVAL	EXE$GL_CEBMTX,R0	; SET ADDRESS OF MUTEX
	JMP	SCH$LOCKW		; LOCK IT FOR WRITE

	.PAGE
	.SBTTL	LOCLUST	- LOCATE CLUSTER GIVEN NAME

NAME=8					; NAME DISPLACEMENT IN ARGLIST
;++
; FUNCTIONAL DESCRIPTION:
;	LOCLUST SEARCHES THE LIST OF COMMON EVENT BLOCKS FOR THE 
;	NAMED CLUSTER AND RETURNS THE ADDRESS OF THE CLUSTER.
;	IF NO ERROR CONDITIONS ARE ENCOUNTERED, LOCLUST RETURNS WITH
;	THE CEB MUTEX LOCKED FOR WRITE.  IN THE EVENT OF ERROR, THE
;	MUTEX IS UNLOCKED AND A RET IS ISSUED TO EXIT THE SERVICE.
;
; CALLING SEQUENCE:
;	BSB/JSB	LOCLUST
;
; INPUT PARAMETERS:
;	04(SP) - 16 BYTE AREA INTO WHICH CEF CLUSTER NAME WILL BE MOVED
;	14(SP) - 16 BYTE AREA INTO WHICH SHARED MEMORY NAME WILL BE MOVED
;	R4 - PCB ADDRESS
;	R9 - ADDRESS OF NAME STRING DESCRIPTOR
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
; ALL CASES:
;	R1,R3 - DESTROYED
;	R7 - PCB ADDRESS OF CURRENT PROCESS
; IF LOCAL MEMORY COMMON EVENT CLUSTER NAME:
;	R2 - ADDRESS OF LOCAL MEMORY CEB  (0 IF NAME NOT FOUND)
;	R4 - R5 DESTROYED
;	R6 - 0
; IF SHARED MEMORY COMMON EVENT CLUSTER NAME:
;	R2 - ADDRESS OF SLAVE CEB (0 IF NO SLAVE FOUND)
;	R4 - SHARED MEMORY CONTROL BLOCK ADDRESS
;	R5 - SHARED MEMORY COMMON DATA PAGE ADDRESS
;	R6 - ADDRESS OF SHARED MEMORY MASTER CEB (0 IF NAME NOT FOUND)
;
; COMPLETION CODES:
;
;	SS$_ACCVIO      - LOGICAL NAME INACCESSIBLE
;	SS$_IVLOGNAM    - COUNT FOR LOGICAL NAME NOT 1-15
;	SS$_NOPRIV      - PRIVILEGE VIOLATION
;	SS$_SHMNOTCNCT  - SHARED MEMORY NOT CONNECTED
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAME TRANSLATIONS
;
;--

LOCLUST:				; LOCATE CLUSTER
	.ENABL	LSB

	PUSHR	#^M<R9,R10,R11>		; SAVE REGISTERS
	MOVL	R4,R7			; SAVE PCB ADDRESS
	IFNORD	#8,(R9),30$		; TEST DESCRIPTOR READABILITY
;
; CREATE STRING DESCRIPTORS FOR COMMON EVENT CLUSTER AND SHARED MEMORY NAME
; BUFFERS.  THEN PERFORM LOGICAL TRANSLATION OF USER-PROVIDED NAME TO
; DETERMINE ACTUAL CLUSTER NAME AND SHARED MEMORY NAME.
;
	MOVZBL	(R9),R1			; GET COUNT FROM DESCRIPTOR (LE 255)
	BEQL	50$			; ILLEGAL STRING LENGTH
	IFNORD	R1,@4(R9),30$		; CHECK READABILITY OF STRING
	PUSHAB	<<4*4>+1>(SP)		; SET UP STRING DESCRIPTOR FOR
	PUSHL	#15			; CEF CLUSTER NAME
	MOVL	SP,R11			; SET ADR OF CEF NAME STR DSC
	PUSHAB	<<4*10>+1>(SP)		; SET UP STRING DESCRIPTOR FOR
	PUSHL	#15			; SHARED MEMORY NAME
	MOVL	SP,R10			; SET ADR OF SHM NAME STR DSC
	BSBW	MMG$CEFTRNLOG		; DETERMINE CEF AND SHM NAMES
	BLBC	R0,60$			; BR IF ERROR IN LOGICAL NAME TRANS
	MOVB	(R11),<4*6>(R11)	; MAKE ASCIC CEF NAME
	BEQL	50$			; BR IF NO CEF NAME SPECIFIED
	DECL	4(R11)			; CONVERT TO POINT TO ASCIC NAME
	MOVB	(R10),<4*12>(R10)	; MAKE ASCIC SHM NAME
	BNEQ	FIND_SHM_CEB		; BR IF CEF CLUSTER IS IN SHARED MEMORY
	BSBB	CEBLOCK			; LOCK CEB LIST TO PROHIBIT WRITERS
;
; FIND COMMON EVENT BLOCK IN LOCAL MEMORY.
;
	MOVAL	SCH$GQ_CEBHD,R10	; GET ADDRESS OF CEB LIST
	MOVL	R10,R6			; AND POINTER TO HEAD OF LIST
10$:	MOVL	(R6),R6			; FLINK ONWARD
	CMPL	R10,R6			; CHECK FOR END OF LIST
	BEQL	15$			; BR IF AT END OF LIST, ENTRY NOT FOUND
40$:	CMPW	CEB$W_GRP(R6),PCB$W_GRP(R7) ; SAME GROUP?
	BNEQ	10$			; NO, TRY ANOTHER
	CMPC3	#16,@4(R11),CEB$T_EFCNAM(R6) ; COMPARE THE NAMES
	BNEQ	10$			; NOT EQUAL, TRY ANOTHER
	CMPB	#DYN$C_SLAVCEB,CEB$B_TYPE(R6) ; SLAVE CEB?
	BEQL	10$			; BR IF SLAVE, DON'T USE CEB
	CMPL	CEB$L_UIC(R6),PCB$L_UIC(R7) ; OWNER UIC?
	BEQL	20$			; YES CONTINUE
	BLBC	CEB$W_PROT(R6),20$	; CONTINUE IF NO ERROR
;
; NO ACESSS ALLOWED TO COMMON EVENT BLOCK.
;
45$:	MOVL	R7,R4			; RESET ADR OF PCB
	MOVAL	EXE$GL_CEBMTX,R0	; SET ADDRESS OF MUTEX
	JSB	SCH$UNLOCK		; UNLOCK MUTEX
	MOVZBL	#SS$_NOPRIV,R0		; SET ERROR CODE
	RET				; AND RETURN FROM SERVICE
30$:	MOVZWL	#SS$_ACCVIO,R0		; INDICATE ACCESS VIOLATION
	RET				; AND EXIT SERVICE
50$:	MOVZWL	#SS$_IVLOGNAM,R0	; INDICATE ILLEGAL STRING
60$:	RET				; EXIT FROM SYSTEM SERVICE
;
; RETURN ADDRESS OF LOCAL COMMON EVENT BLOCK (IF FOUND) ELSE 0.
;
15$:	CLRL	R6			; INDICATE NONE FOUND
20$:	MOVL	R6,R2			; RETURN ADR OF CEB
	CLRL	R6			; RETURN NO MASTER SHMGSD
25$:	ADDL	#<4*4>,SP		; CLEAN STR DSC'S OFF STACK
	POPR	#^M<R9,R10,R11>		; RESTORE REGISTERS
	RSB				; AND RETURN

;
; FIND COMMON EVENT BLOCK IN SHARED MEMORY.
;
FIND_SHM_CEB:
					; R10=ADR OF STR DESC FOR SHM NAME
	DECL	4(R10)			; POINT TO ASCIC SHM NAME
	BSBW	MMG$FINDSHB		; FIND SHARED MEMORY CONTROL BLOCK
	BLBC	R0,60$			; BR IF MEMORY IS NOT CONNECTED
					; R4=SHB ADR, R5=SHD ADR
	MOVL	R4,R9			; REMEMBER SHB ADR
	MOVL	R7,R4			; SET CURRENT PCB ADR
	BSBW	CEBLOCK			; LOCK CEB LIST TO PROHIBIT WRITERS
	MOVL	R9,R4			; RESTORE SHB ADR
	ADDL3	SHD$L_CEFPTR(R5),R5,R6	; ADR OF 1ST CEB IN SHM CEF TABLE
	MOVZWL	CEB$W_SIZE(R6),R9	; GET SIZE OF ONE CEB
	MOVZWL	SHD$W_CEFMAX(R5),R10	; GET MAXIMUM CEB'S IN TABLE
	BEQL	160$			; BR IF NO CEB TBL AT ALL
140$:	BSBW	INC_SHMCEB_REF		; LOCK THIS CEB AGAINST DELETION
	BLBC	R0,155$			; DONT USE ENTRY IF IT IS REFCNT LOCKED
	BBS	#CEB$V_LOCKED,CEB$L_CEBFL(R6),150$ ; BR IF ENTRY BEING CREATED
	BBC	#CEB$V_VALID,CEB$L_CEBFL(R6),150$ ; BR IF ENTRY NOT IN USE
	CMPW	CEB$W_GRP(R6),PCB$W_GRP(R7) ; IS THIS CEB IN PROCESS' GROUP?
	BNEQ	150$			; BR IF IT IS IN DIFFERENT GROUP
	CMPC3	#16,@4(R11),CEB$T_EFCNAM(R6) ; DOES NAME OF CLUSTER MATCH?
	BNEQ	150$			; BR IF DIFFERENT NAME
	CMPL	CEB$L_UIC(R6),PCB$L_UIC(R7) ; DOES PROCESS OWN THIS CLUSTER?
	BEQL	170$			; BR IF PROCESS OWNS THIS CLUSTER
	BLBC	CEB$W_PROT(R6),170$	; BR IF CLUSTER IS NOT PROTECTED
	BSBW	DEC_SHMCEB_REF		; RELEASE LOCK AGAINST DELETION
					; IGNORE POTENTIAL INTERLOCK ERROR
	BRB	45$			; GO RELEASE MUTEX AND EXIT SERVICE
150$:	BSBW	DEC_SHMCEB_REF		; RELEASE LOCK AGAINST DELETION
					; IGNORE POTENTIAL INTERLOCK ERROR
155$:	ADDL2	R9,R6			; ADR OF NEXT CEB IN SHM CEF TABLE
	SOBGTR	R10,140$		; SEARCH ALL OF CEB TABLE
160$:	CLRL	R6			; INDICATE NO MASTER CEB FOUND
	CLRL	R2			; INDICATE NO SLAVE CEB FOUND
	BRB	180$			; RETURN TO COMMON CODE
170$:	MOVZBL	SHB$B_PORT(R4),R2	; GET PORT # INDEX FOR VA OF SLAVE CEB
	MOVL	CEB$L_VASLAVE1(R6)[R2],R2 ; SET ADR OF SLAVE CEB
180$:	BRW	25$			; RETURN TO COMMON CODE

	.DSABL	LSB
	.PAGE
	.SBTTL	ALOSHMCEB - ALLOCATE SHARED MEMORY MASTER COMMON EVENT BLOCK

;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE ALLOCATES AND INITIALIZES A SHARED MEMORY MASTER COMMON
;	EVENT BLOCK.  SOME FIELDS HAVE ALREADY BEEN INITIALIZED BY SYSGEN.
;
; CALLING SEQUENCE:
;	BSBW	ALOSHMCEB
;
; INPUT PARAMETERS:
;	R4 - ADDRESS OF SHARED MEMORY CONTROL BLOCK
;	R5 - ADDRESS OF SHARED MEMORY COMMON DATA PAGE
;
; IMPLICIT INPUTS:
;	COMMON DATA PAGE MUST BE INITIALIZED.
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	R6 - ADDRESS OF SHARED MEMORY MASTER CEB, IF SUCCESSFUL
;	   - 0, IF ERROR
;
; IMPLICIT OUTPUTS:
;	THE MASTER CEB IS INITIALIZED.  ITS REF COUNT IS UP BY ONE TO LOCK IT.
;
; COMPLETION CODES:
;	SS$_NORMAL   - SUCCESSFUL COMPLETION
;	SS$_NOSHMBLOCK - NO SHARED MEMORY MASTER CEB AVAILABLE
;
; SIDE EFFECTS:
;	THE MASTER CEB IS LOCKED PREVENTING OTHER PROCESSES FROM USING IT.
;
;--

	.ENABL	LSB
ALOSHMCEB:
	PUSHR	#^M<R1,R2>		; SAVE REGISTERS
	ADDL3	SHD$L_CEFPTR(R5),R5,R6	; GET ADR OF FIRST CEB IN SHM TABLE
	MOVZWL	CEB$W_SIZE(R6),R2	; GET SIZE OF ONE SHMCEB
	MOVZWL	SHD$W_CEFMAX(R5),R1	; GET # OF ENTRIES IN TABLE
	BRB	20$			; JOIN COMMON CODE
10$:	BSBW	DEC_SHMCEB_REF		; UNLOCK THE PREVIOUS ENTRY FOR DELETION
					; IGNORE POTENTIAL INTERLOCK ERROR
15$:	ADDL2	R2,R6			; GET ADDRESS OF NEXT CEB IN TABLE
	SOBGTR	R1,20$			; BR IF ANOTHER ENTRY TO CHECK
	BEQL	NO_FREE_CEB		; BR IF NO ENTRY AVAILABLE
20$:	BSBW	INC_SHMCEB_REF		; LOCK THE ENTRY
	BLBC	R0,15$			; DONT USE ENTRY IF IT IS REFCNT LOCKED
	BBS	#CEB$V_LOCKED,CEB$L_CEBFL(R6),10$ ; BR IF ENTRY BEING MODIFIED
	BBS	#CEB$V_VALID,CEB$L_CEBFL(R6),10$ ; BR IF ENTRY ALREADY IN USE
	BBSSI	#CEB$V_LOCKED,CEB$L_CEBFL(R6),10$ ; BR IF SOMEONE JUST TOOK IT
;
; FOUND AN UNUSED ENTRY.  NOW INITIALIZE IT.
;
	MOVB	SHB$B_PORT(R4),CEB$B_LOCK(R6) ; INDICATE PORT LOCKING ENTRY
	INSV	44(SP),#CEB$V_PERM,#1,CEB$B_STS(R6) ; SET PERMANENT FLAG
	CLRL	CEB$L_EFC(R6)		; INITIALIZE EVENT FLAGS
	MOVL	PCB$L_PID(R7),CEB$L_PID(R6) ; INITIALIZE UIC OF OWNER
	MOVL	PCB$L_UIC(R7),CEB$L_UIC(R6) ; AND UIC OF CLUSTER OWNER
	MOVZWL	PROT(AP),CEB$W_PROT(R6)	; INITIALIZE PROTECTION OF CLUSTER
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC3	#16,28(SP),CEB$T_EFCNAM(R6) ; SET NAME OF CLUSTER
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGISTERS
	ASSUME CEB$B_DELETPORT EQ <CEB$B_CREATPORT + 1>
	MOVZBW	SHB$B_PORT(R4),CEB$B_CREATPORT(R6) ; INIT CREATOR/DELETOR PORTS
	MOVZBL	#SS$_NORMAL,R0		; REPORT SUCCESS
30$:	POPR	#^M<R1,R2>		; RESTORE REGISTERS
	RSB				; RETURN TO CREATE SLAVE CEB

NO_FREE_CEB:
	MOVZWL	#SS$_NOSHMBLOCK,R0	; REPORT FAILURE
	CLRL	R6			; INDICATE NO MASTER CEB, TO USE COMMON
					; ERROR PATHS IN CALLER CODE
	BRB	30$			; RETURN TO CLEAN UP

	.DSABL	LSB
	.PAGE
	.SBTTL	INC_SHMCEB_REF/DEC_SHMCEB_REF - ALTER REFCNT ON SHMEM MASTER CEB

;++
; FUNCTIONAL DESCRIPTION:
;	THESE ROUTINES INCREMENT/DECREMENT RESPECTIVELY A PROCESSOR REFERENCE
;	COUNT IN A SHARED MEMORY COMMON EVENT BLOCK BY ONE.  THE PORT NUMBER
;	IS USED AS AN INDEX IN DETERMINING WHICH PROCESSOR REFERENCE COUNT TO
;	ALTER.  THIS IS DONE TO LOCK AN ENTRY SO THAT IT CANNOT BE RELEASED
;	WHILE A PROCESSOR IS SCANNING IT.  A REFERENCE LOCK BIT IN THE MASTER
;	MUST BE HELD WHILE UPDATING A REFERENCE COUNT AND WHILE CHECKING THAT
;	AN ENTRY'S REFERENCE COUNTS FOR DELETION.  THIS PREVENTS A RACE
;	CONDITION BETWEEN ASSOCIATION AND DELETION OF COMMON EVENT FLAGS.
;	NOTE THAT EXECUTION MUST ALREADY BE SINGLE STREAMED ON THE PROCESSOR
;	EXECUTING THIS CODE VIA MUTEXES.
;
;	THESE ROUTINES ASSUME THAT THE PROCESSOR REFERENCE COUNTS ARE
;	IMMEDIATELY PRECEEDED BY THE SLAVE CEB VIRTUAL ADDRESSES IN THE
;	MASTER CEB.
;
; CALLING SEQUENCE:
;	BSBW	INC_SHMCEB_REF
;
; INPUT PARAMETERS:
;	R4 - ADDRESS OF SHARED MEMORY CONTROL BLOCK
;	R6 - ADDRESS OF SHARED MEMORY MASTER COMMON EVENT BLOCK
;
; IMPLICIT INPUTS:
;	THE SHARED MEMORY MUST BE CONNECTED AND THE REFERENCE COUNTS IN THE
;	MASTER CEB SET UP AT SYSGEN TIME.
;
; OUTPUT PARAMETERS:
;	R0 - STATUS CODE
;
; IMPLICIT OUTPUTS:
;	THE MASTER CEB'S REF COUNT IS UP/DOWN BY ONE TO LOCK/RELEASE IT.
;
; COMPLETION CODES:
;	SS$_NORMAL - SUCCESSFUL COMPLETION
;	SS$_INTERLOCK - UNABLE TO OBTAIN ENTRY REF COUNT LOCK
;
; SIDE EFFECTS:
;	THE MASTER CEB CANNOT DISAPPEAR UNTIL THE REFERENCE COUNT IS RELEASED.
;
;--

INC_SHMCEB_REF:
	MOVQ	R1,-(SP)		; SAVE REGISTERS
	MOVZBL	SHB$B_PORT(R4),R1	; GET PORT # FOR INDEX TO PROC REFCNT
	MOVZBL	CEB$B_PROCCNT(R6),R2	; GET # OF PROCESSOR SLAVE VA'S IN CEB
	ASHL	#2,R2,R2		; CONVERT TO BYTE CNT, SLAVEVA=LONGWORD
	ADDL2	R6,R2			; OFFSET PAST THE SLAVE VA'S
	BSBW	GET_REFCNT_LCK		; ACQUIRE REF COUNT LOCK IN SHMCEB
	BLBC	R0,10$			; BR IF UNABLE TO ACQUIRE LOCK
	ADAWI	#1,CEB$L_VASLAVE1(R2)[R1] ; INCREMENT PROCESSOR REF COUNT
	BBCCI	#CEB$V_REFCNTLCK,CEB$L_CEBFL(R6),10$ ; RELEASE REF CNT LOCK
10$:	MOVQ	(SP)+,R1		; RESTORE REGISTER
	RSB

DEC_SHMCEB_REF:
	MOVQ	R1,-(SP)		; SAVE REGISTERS
	MOVZBL	SHB$B_PORT(R4),R1	; GET PORT # FOR INDEX TO PROC REFCNT
	MOVZBL	CEB$B_PROCCNT(R6),R2	; GET # OF PROCESSOR SLAVE VA'S IN CEB
	ASHL	#2,R2,R2		; CONVERT TO BYTE CNT, SLAVEVA=LONGWORD
	ADDL2	R6,R2			; OFFSET PAST THE SLAVE VA'S
	BSBW	GET_REFCNT_LCK		; ACQUIRE REF COUNT LOCK IN SHMCEB
	BLBC	R0,10$			; BR IF UNABLE TO ACQUIRE LOCK
	ADAWI	#-1,CEB$L_VASLAVE1(R2)[R1] ; INCREMENT PROCESSOR REF COUNT
	BLSS	ERR_BUGCHK		; BUGCHECK IF ILLEGAL REFERENCE COUNT
	BBCCI	#CEB$V_REFCNTLCK,CEB$L_CEBFL(R6),10$ ; RELEASE REF CNT LOCK
10$:	MOVQ	(SP)+,R1		; RESTORE REGISTER
	BBC	#CEB$V_PERM,CEB$B_STS(R6),20$ ; BR IF CLUSTER CAN BE DELETED
	RSB
20$:	BRW	EXE$SHM_DELETE		; TRY TO RELEASE CEB

ERR_BUGCHK:
	BUG_CHECK	CEBREFNEG,FATAL	; FATAL ERROR
	.PAGE
	.SBTTL	EXE$SHM_DELETE - TRY TO DELETE (RELEASE) MASTER CEB IN SH MEM

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS TWO FUNCTIONS:  (1) IF THE DELETE PENDING FLAG IS
; SET, THEN IT INFORMS THE OTHER PROCESSORS ON THE SHARED MEMORY THAT THE
; STATUS OF THE CEB IS NOW CHANGED, AND (2) IT CHECKS WHETHER OR NOT THE
; SHARED MEMORY CEB CAN BE RELEASED IMMEDIATELY.
;
; THE SHARED MEMORY CEB CAN ONLY BE RELEASED IF ALL THE REFERENCE COUNTS
; ARE ZERO (ONE COUNT PER PROCESSOR).  IF A COUNT IS NOT ZERO, THEN ONE OF THE
; FOLLOWING IS OUTSTANDING:
;	1) A SLAVE CEB STILL EXISTS FOR THE MASTER CEB
;	2) AN INTER-PROCESSOR REQUEST MESSAGE EXISTS FOR THE MASTER CEB
;	3) A PROCESSOR IS REFERENCING THE MASTER DURING A SHM CEB TBL SEARCH
;
; CALLING SEQUENCE:
;	JSB	EXE$SHM_DELETE
;
; INPUT PARAMETERS:
;
;	R6 - MASTER CEB ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	VARIOUS SYSTEM STATUS CODES.
;
; SIDE EFFECTS:
;
;	THE MASTER CEB MAY BE DELETED.  THE OTHER PROCESSORS MAY BE INFORMED
;	OF A CHANGE IN STATUS OF THE CEB.
;
;--

	.PSECT	AEXENONPAGED,BYTE
EXE$SHM_DELETE::
	MOVQ	R1,-(SP)		; SAVE REGISTER
40$:	MOVZBL	CEB$B_PROCCNT(R6),R1	; GET # OF REFERENCE COUNTS TO CHECK
	MOVAL	CEB$L_VASLAVE1(R6)[R1],R2 ; GET ADR OF 1ST REF COUNT
	BSBW	GET_REFCNT_LCK		; ACQUIRE REF COUNT LOCK
	BLBC	R0,90$			; IGNORE POTENTIAL INTERLOCK ERROR
50$:	TSTW	(R2)+			; ANY REFERENCES?
	BNEQ	80$			; BR IF THERE IS AN OUTSTANDING REF
	SOBGTR	R1,50$			; REPEAT FOR EACH REF CNT
	BBSSI	#CEB$V_LOCKED,CEB$L_CEBFL(R6),60$ ; LOCK IT AGAINST SEARCHES
60$:	BBCCI	#CEB$V_VALID,CEB$L_CEBFL(R6),70$ ; MARK IT NO LONGER VALID
70$:	BBCCI	#CEB$V_LOCKED,CEB$L_CEBFL(R6),80$ ; RELEASE GSD FOR OTHER USE
80$:	BBCCI	#CEB$V_REFCNTLCK,CEB$L_CEBFL(R6),90$ ; RELEASE REF CNT LOCK

90$:	MOVQ	(SP)+,R1		; RESTORE REGISTERS AND STATUS CODE
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	UNIQUE_CEB - CHECK THAT SH MEM CEB IS UNIQUE

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED AFTER A SHARED MEMORY MASTER CEB IS INITIALIZED.
; A SEARCH OF THE SPECIFIC SHARED MEMORY'S CEB TABLE IS MADE TO ASCERTAIN IF A
; COMMON EVENT FLAG CLUSTER OF THE SAME NAME WAS CREATED DURING THE TIME THAT
; $ASCEFC WAS CREATING THE SECTION.
;
; TWO LOCKS MUST BE ACQUIRED BEFORE THE SHARED MEMORY CEB TABLE MAY BE SEARCHED
; TO VERIFY A SECTION IS UNIQUE.  THE FIRST IS THE SHARED MEMORY CEB MUTEX
; WHICH INTERLOCKS PROCESSES ON ONE PROCESSOR.  THE SECOND IS THE SHARED MEMORY
; CEB TABLE LOCK CONTAINED IN THE SHARED MEMORY COMMON DATA PAGE, WHICH
; INTERLOCKS BETWEEN PROCESSORS.
;
; THE REGISTER CONVENTION (R6=ADR OF MASTER CEB JUST CREATED AND R11=ADR OF
; MASTER CEB THAT IS THE DUPLICATE) IS SWITCHED DURING THIS ROUTINE TO MAKE
; THE ROUTINES INC_SHMCEB_REF AND DEC_SHMCEB_REF LOCK THE DUPLICATE ENTRY.
;
; CALLING SEQUENCE:
;
;	BSBW	UNIQUE_CEB
;
; INPUT PARAMETERS:
;
;	R4 - ADDRESS OF SHARED MEMORY CONTROL BLOCK
;	R5 - ADDRESS OF SHARED MEMORY COMMON DATA PAGE
;	R6 - ADDRESS OF COMMON EVENT BLOCK TO BE VERIFIED AS UNIQUE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R11 - 0 IF THE CEB IS UNIQUE
;	     OTHERWISE, ADDRESS OF DUPLICATE CEB
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	Y$EXEPAGED,BYTE
UNIQUE_CEB:
	.ENABL	LSB
	PUSHR	#^M<R0,R1,R2,R3,R6,R8,R9> ; SAVE REGISTERS
	MOVL	R6,R11			; REMEMBER ADR OF MASTER CEB JUST CREAT
	BSBW	SHMCEFTBLK		; GET SHM MUTEX AND BIT LOCK
	BLBC	R0,ERROR_EXIT		; REPORT UNABLE TO GET BIT LOCK
	MOVB	SHB$B_PORT(R4),SHD$B_CEFLOCK(R5) ; SET OWNER OF CEB TBL LOCK
	ADDL3	SHD$L_CEFPTR(R5),R5,R6	; GET ADR OF FIRST CEB IN SH MEM
	MOVZWL	CEB$W_SIZE(R6),R8	; GET SIZE OF ONE SHMCEB
	MOVZWL	SHD$W_CEFMAX(R5),R9	; GET # OF CEB'S IN SHM TBL
30$:	BSBW	INC_SHMCEB_REF		; LOCK CEB AGAINST DELETION
	BLBC	R0,45$			; DONT USE ENTRY IF IT IS REFCNT LOCKED
	BBS	#CEB$V_LOCKED,CEB$L_CEBFL(R6),40$ ;BR IF CEB LOCKED FOR READING
	BBC	#CEB$V_VALID,CEB$L_CEBFL(R6),40$ ;BR IF CEB IS NOT IN USE
	CMPW	CEB$W_GRP(R6),CEB$W_GRP(R11) ; ARE CEB'S IN SAME GROUP?
	BNEQ	40$			; BR IF NOT, KEEP LOOKING
	CMPC3	#16,CEB$T_EFCNAM(R11),CEB$T_EFCNAM(R6) ; CEB'S HAVE SAME NAME?
	BNEQ	40$			; BR IF DIFFERENT NAMES
	CMPL	R6,R11			; IS THIS THE CEB JUST MADE?
	BNEQ	50$			; BR IF DIFFERENT, FOUND DUPLICATE
40$:	BSBW	DEC_SHMCEB_REF		; RELEASE LOCK AGAINST DELETION
					; IGNORE POTENTIAL INTERLOCK ERROR
45$:	ADDL2	R8,R6			; GET ADR OF NEXT SHMCEB
	SOBGTR	R9,30$			; LOOK AT EACH ENTRY IN SHM TBL
	CLRL	R6			; INDICATE NO DUPLICATE ENTRY
50$:	BBCCI	#SHD$V_CEFLCK,SHD$B_FLAGS(R5),60$ ; RELEASE SHM CEB TBL LOCK
60$:	MOVL	R6,R11			; RETURN DUPLICATE ENTRY ADR IN R11
	POPR	#^M<R0,R1,R2,R3,R6,R8,R9> ; RESTORE REGISTERS
	RSB				; RETURN TO $ASCEFC

; ***********
; AT SOME LATER DATE, THIS SHOULD SEND AN ERROR MESSAGE TO THE ERROR LOGGER.
; ***********
ERROR_EXIT:
	CLRL	R6			; FAILURE TO ACQUIRE BIT LOCK
	BRB	60$			; RETURN ERROR STATUS
	.DSABL	LSB
	.PAGE
	.SBTTL GET_REFCNT_LCK - ACQUIRE SHMCEB REFERENCE COUNT LOCK

;++
; FUNCTIONAL DESCRIPTION:
;
; THE ROUTINE IS CALLED TO ACQUIRE EXCLUSIVE USE OF A SHARED MEMORY COMMON
; EVENT FLAG BLOCK.  THIS IS DONE BY LOOPING TO ACQUIRE A BIT LOCK IN THE
; MASTER CEB.  IF THE BIT LOCK COULD NOT BE ACQUIRED, THEN AN ERROR CODE IS
; RETURNED.
;
;
; CALLING SEQUENCE:
;
;	BSBW	GET_REFCNT_LCK
;
; INPUT PARAMETERS:
;
;	R6 - ADDRESS OF SHARED MEMORY COMMON EVENT BLOCK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFULLY ACQUIRED LOCK
;	SS$_INTERLOCK  - UNABLE TO ACQUIRE LOCK
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	AEXENONPAGED,BYTE
GET_REFCNT_LCK:
	PUSHL	R1			; SAVE REGISTER
	MOVL	G^EXE$GL_LOCKRTRY,R1	; GET LOOP COUNT FOR BIT LOCK
10$:	BBSSI	#CEB$V_REFCNTLCK,CEB$L_CEBFL(R6),20$ ; TRY TO ACQUIRE BIT LOCK
	MOVZBL	#SS$_NORMAL,R0		; REPORT LOCK SUCCESSFULLY ACQUIR
	POPL	R1			; RESTORE REGISTER
	RSB				; RETURN SUCCESS CODE
20$:	SOBGTR	R1,10$			; TRY AGAIN TO ACQUIRE BIT LOCK
	POPL	R1			; RESTORE REGISTER
	MOVZWL	#SS$_INTERLOCK,R0	; REPORT ERROR STATUS
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	SHMCEFTBLK - ACQUIRE EXCLUSIVE USE OF SHARED MEMORY TABLE

;++
; FUNCTIONAL DESCRIPTION:
;
; THE ROUTINE IS CALLED TO ACQUIRE EXCLUSIVE USE OF A SHARED MEMORY COMMON
; EVENT FLAG TABLE.  THIS IS DONE BY LOOPING TO ACQUIRE A SHARED MEMORY BIT
; LOCK.  IF THE BIT LOCK COULD NOT BE ACQUIRED, THEN AN ERROR CODE IS RETURNED.
;
; CALLING SEQUENCE:
;
;	BSBW	SHMCEFTBLK
;
; INPUT PARAMETERS:
;
;	R5 - ADDRESS OF SHARED MEMORY COMMON DATA PAGE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFULLY ACQUIRED LOCK
;	SS$_INTERLOCK  - UNABLE TO ACQUIRE LOCK
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	Y$EXEPAGED,BYTE
SHMCEFTBLK:
	PUSHL	R1			; SAVE REGISTER
	MOVL	G^EXE$GL_LOCKRTRY,R1	; GET LOOP COUNT FOR BIT LOCK
10$:	BBSSI	#SHD$V_CEFLCK,SHD$B_FLAGS(R5),20$ ; TRY TO ACQUIRE BIT LOCK
	MOVZBL	#SS$_NORMAL,R0		; REPORT LOCK SUCCESSFULLY ACQUIR
	POPL	R1			; RESTORE REGISTER
	RSB				; RETURN SUCCESS CODE
20$:	SOBGTR	R1,10$			; TRY AGAIN TO ACQUIRE BIT LOCK
	POPL	R1			; RESTORE REGISTER
	MOVZWL	#SS$_INTERLOCK,R0	; REPORT ERROR STATUS
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	SHD_FIND_SHB - FIND SH MEM CONTROL BLOCK FOR SPECIFIC SHD

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TAKES COMMON DATA PAGE ADDRESS AND FINDS THE SHARED MEMORY
; CONTROL BLOCK ADDRESS FOR THIS SHARED MEMORY.
;
; CALLING SEQUENCE:
;
;	BSBW	SHD_FIND_SHB
;
; INPUT PARAMETERS:
;
;	R5 - ADDRESS OF SHARED MEMORY COMMON DATA PAGE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 - STATUS CODE
;	R4 - SHB ADR, OR 0
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFULLY FOUND SHB ADR
;	SS$_SHMNOTCNCT - SHARED MEMORY NOT CONNECTED
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.PSECT	Y$EXEPAGED,BYTE
SHD_FIND_SHB:
	.ENABL	LSB
	MOVZBL	#SS$_NORMAL,R0		; ASSUME SUCCESS
	MOVL	EXE$GL_SHBLIST,R4	; GET ADR OF FIRST SHB
10$:	BEQL	NOT_FOUND		; BR IF NO SHB ADR
	BBC	#SHB$V_CONNECT,SHB$B_FLAGS(R4),GET_NXT_SHM ; BR IF MEM NOT CONCT
	CMPL	SHB$L_DATAPAGE(R4),R5	; DOES THE COM DATA PAGE ADR MATCH?
	BNEQ	GET_NXT_SHM		; BR IF NO MATCH, FIND NEXT SHB ADR
	RSB				; SHB FOUND, RETURN ADR
GET_NXT_SHM:
	MOVL	SHB$L_LINK(R4),R4	; GET NEXT SHB IN LIST
	BRB	10$			; CONTINUE
NOT_FOUND:
	MOVZWL	#SS$_SHMNOTCNCT,R0	; NO MORE MEM, REPORT SHB NOT FOUND
	RSB
	.DSABL	LSB


	.END
