	.TITLE	RSE - REPORT SYSTEM EVENT
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SCHEDULER
;
; ABSTRACT:
;	THIS MODULE CONTAINS THE SYSTEM EVENT REPORTING ROUTINES AND
;	THEIR SUPPORTING SUBROUTINES.
;
; ENVIRONMENT:
;	MODE = KERNEL	
;--
;
	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:	R. HUSTVEDT	 CREATION DATE: 6-SEP-76
;
;	V02-014	LJK0093		Lawrence J. Kenah	1-Dec-1981
;		Add global label to allow SENDAST mechanism to be available
;		as a general mechanism for delivering EXIT ASTs to a
;		process.
;
;	V02-013	LJK0085		Lawrence J. Kenah	17-Nov-1981
;		Alter method in which process that has exceeded its CPU 
;		time limit gets extra time for execution.
;		Do not deliver ASTs for automatic working set adjustment
;		or CPU time expiration if process is marked for delete.
;
;	V02-012	HRJ0033		Herb Jacobs		08-Nov-1981
;		Remove use of AWSMAX limiting parameter.
;
;	V02-011	HRJ0020		Herb Jacobs		17-Jul-1981
;		Account for WSEXTENT being index rather than size.
;
;	V02-010	JLV0050		Jake VanNoy		2-Jul-1981
;		Changed PSECT names from ASE1, ASE2 to AES1, AES2 to
;		allow SYSBRDCST to grow with affecting the size of
;		this module.
;
;	V02-009	HRJ0020		Herb Jacobs		20-Apr-1981
;		Added support to allow working sets to conditionally grow
;		to new quota WSEXTENT based on system wide BORROWLIM.
;
;	V02-008	LJK0012		Lawrence J. Kenah	2-Mar-1981
;		Prevented enqueuing of multiple ASTs for automatic working set
;		adjustment by using input access mode parameter as flag.
;		Put this check into common code with enqueuing of ASTs for
;		CPU time limit expiration.
;
;	V02-007	SRB0007		Steve Beckhardt		22-Oct-1980
;		Fixed bug in cpu time expiration AST handler by
;		clearing the AST.
;

	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$DYNDEF				; DEFINE STRUCTURE TYPE CODES
	$CEBDEF				; DEFINE COMMON EVENT BLOCK
	$IPLDEF				; IPL DEFINITIONS
	$PCBDEF				; PCB DEFINITIONS
	$PHDDEF				; PROCESS HEADER DEFINITIONS
	$PRDEF				; PROCESSOR REGISTER DEFS
	$PRIDEF				; PRIORITY INCREMENT CLASSES
	$SSDEF				; DEFINE STATUS CODES
	$STATEDEF			; STATE DEFINITIONS
	$WQHDEF				; WAIT QUEUE HEADER DEFINITIONS
;
; MACROS:
;
	.MACRO	EVENT,EVTN,STATLIST,EACTION,CONT=0
	.IF	NB,EVTN
EVT$_'EVTN==EVTCTR
	.ENDC
EVTCTR=EVTCTR+1
	.WORD	EACTION-STACT
RSE...=.
	.PSECT	AES2,BYTE
STMSK=CONT
	.IRP	ST,<STATLIST>
STMSK=STMSK+<1@SCH$C_'ST>
	.ENDR	
	.LONG	STMSK
	.PSECT	AES1,BYTE
.=RSE...
	.ENDM	EVENT

;
;	GENERATE MASK FOR WAIT STATES
;
;	GMASK	STATENAME
;

	.MACRO	GMASK,STATE
ST=SCH$C_'STATE
WAITST=WAITST+<1@ST>
	.ENDM	GMASK
;
; EQUATED SYMBOLS:
;
EVTCTR=0				; INITIALIZE EVENT COUNTER TO 0
WAITST=0				; INITIALIZE WAIT STATE MASK
ASTEXIT=0				; AST EXIT CHANGE MODE CODE
;
; OWN STORAGE:
;
	.PSECT	AES2,BYTE		; STATE EVENT MASK PSECT
STET=	.				; BASE OF STATE EVENT TABLE
	.PSECT	AES1,BYTE
	.PAGE
	.SBTTL	SCH$RSE - REPORT SYSTEM EVENT

;++
; FUNCTIONAL DESCRIPTION:
;	SCH$RSE RECEIVES SYSTEM EVENT REPORTS FROM VARIOUS SOURCES
;	AND PERFORMS THE APPROPRIATE ACTION FOR THE SPECIFIED PROCESS.
;	EVENT REPORTING MUST BE PERFORMED WITH IPL=IPL$_SYNCH.
;	AS A SIDE EFFECT OF AN EVENT REPORT, THE RESCHEDULING INTERRUPT
;	MAY BE TRIGGERED IF APPROPRIATE.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$RSE
;	.BYTE	EVT$_EVENTNAME
;
;	THIS CALLING SEQUENCE IS GENERATED BY THE RPTEVT SYSTEM MACRO
;	
;	REPEVT	EVENTNAME
;
; INPUT PARAMETERS:
;	R2 - SITUATIONAL PRIORITY INCREMENT CLASS NUMBER
;	R4 - PCB ADDRESS OF PROCESS FOR WHICH EVENT IS REPORTED
;
;	EVENT NUMBER CONTAINED IN BYTE LOCATED BY ADDRESS AT TOP 
;	OF STACK.  @(SP)
;
; IMPLICIT INPUTS:
;	SCHEDULER DATA BASE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	A RESECHEDULING INTERRUPT MAY BE REQUESTED IF THE SPECIFIED
;	PROCESS IS HIGHER IN PRIORITY THAN THE CURRENT PROCESS.
;
;--

SCH$RSE::				; REPORT SYSTEM EVENT
	MOVZBL	@(SP),R3		; GET EVENT NUMBER 
	INCL	(SP)			; UPDATE RETURN ADDRESS
	MOVZWL	PCB$W_STATE(R4),R1	; GET CURRENT STATE NUMBER
10$:	MOVL	W^STET[R3],R0		; GET STATE MASK FOR EVENT
	BBS	R1,R0,ACTION		; DO ACTION IF STATE BIT SET
	INCL	R3			; CHECK NEXT ACTION
	BLBS	R0,10$			; IF CONTINUATION
	RSB				; OTHERWISE IGNORE EVENT
	
ACTION:	CASEL	R3,#0,S^#MAXEVT		; SWITCH ON EVENT NUMBER(UPDATED)
STACT:					; BASE OF ACTION TABLE
	EVENT	AST,<-			; AST EVENT
		CEF,-			; COMMON EVENT FLAG WAIT
		COLPG,-			; COLLIDED PAGE WAIT
		FPG,-			; FREE PAGE WAIT
		HIB,-			; RESIDENT HIBERNATE
		HIBO,-			; NON-RESIDENT HIBERNATE
		LEF,-			; LOCAL EVENT FLAG WAIT
		LEFO,-			; LOCAL EVENT FLAG WAIT (NON-RES)
		MWAIT,-			; MUTEX WAIT
		PFW,-			; PAGE FAULT WAIT
		>,EVENTE		; AST EXECUTABLE STATE CHANGE
EVT$_COLPGA==EVT$_AST			; USE SAME EVENT FOR COLLIDED PAGE AVAIL


	EVENT	EVENT,<LEF>,LEFEVT,CONT=1	; EVENT FLAG SETTING
	EVENT	,<CEF>,CEFEVT,CONT=1	; COMMON EVENT FLAG SET
	EVENT	,<LEFO>,EVENTE		; NON-RESIDENT LOCAL EVENT

	EVENT	FPGA,<-			; FREE PAGE AVAILABLE
		FPG,-			; FREE PAGE WAIT STATE
		>,EVENTF		; EXECUTABLE STATE CHANGE
	EVENT	WAKE,<-			; WAKE EVENT
		HIB,-			; RESIDENT HIBERNATE
		HIBO,-			; NON-RESIDENT HIBERNATE
		>,EVENTE		;


	EVENT	RESUME,<-		; RESUME EVENT
		SUSP,-			; RESIDENT SUSPENDED
		SUSPO,-			; NON-RESIDENT SUSPENDED
		>,EVENTE		; EXECUTABLE


	EVENT	PFCOM,<-		; PAGE FAULT COMPLETE EVENT
		PFW,-			; PAGE FAULT WAIT
		>,EVENTE		; EXECUTABLE

	EVENT	SETPRI,<-		; SET PRIORITY EVENT
		COM,-			; RESIDENT COMPUTE
		COMO,-			; NON-RESIDENT COMPUTE
		>,EVENTF		; EXECUTABLE

	EVENT	SWPOUT,<-		; SWAP OUT EVENT
		HIB,-			; RESIDENT HIBERNATE
		LEF,-			; RESIDENT LOCAL EVENT FLAG WAIT
		SUSP,-			; RESIDENT SUSPENDED
		>,SWPO,CONT=1		; SIMPLE SWAP OUT
	EVENT	,<-			; SWAP OUT EVENT CONINUATION
		COM,-			; RESIDENT COMPUTE
		>,SWPOE			; EXECUTABLE OUTSWAP

;
;	IF CASE FALLS THROUGH, THEN BUGCHECK WITH ILLEGAL EVENT
;	NUMBER.
;
MAXEVT=EVTCTR-1				; MAXIMUM EVENT NUMBER
	BUG_CHECK ILLEVTNUM,FATAL	; ILLEGAL EVENT NUMBER

	.PAGE
;
;	COMMON EVENT FLAG SET
;
CEFEVT:					;
	BLBC	PCB$L_STS(R4),EVENTE	; BR IF NOT RESIDENT
LEFEVT:					; LOCAL EVENT FLAG SET FOR RESIDENT PROCESS
	MOVL	PCB$L_PHD(R4),R3	; POINT TO PHD
	ADDL	#4,PHD$L_PC(R3)		; SKIP PC OVER CHMK INSTRUCTION
	MOVZWL	#SS$_NORMAL,PHD$L_R0(R3); SET NORMAL COMPLETION FOR WAIT
;
;	EVENT EXECUTABLE ACTION ROUTINE
;

EVENTE:					; EVENT EXECUTABLE STATE CHANGE
EVENTF:					; ACTIVATE WITH NO WAIT TIME ACCOUNTING
	PUSHAB	B^SCH$CHSE		; MAKE UNWAIT EXIT THROUGH CHSE
;	BRB	SCH$UNWAIT		; AND FALL INTO UNWAIT

	.PAGE
	.SBTTL	SCH$UNWAIT - DECREMENT COUNT IN WAIT QUEUE
;++
;
; FUNCTIONAL DESCRIPTION:
;	SCH$UNWAIT DECREMENTS THE NUMBER OF PROCESSES IN THE WAIT
;	QUEUE SELECTED BY THE SPECIFIED PCB AND STATE VALUE.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$UNWAIT
;
; INPUT PARAMETERS:
;	R1 - STATE NUMBER (PRESERVED)
;	R2 - UNUSED	  (PRESERVED)
;	R4 - PCB ADDRESS  (PRESERVED)
;
; IMPLICIT INPUTS:
;	PCB LOCATED BY ADDRESS IN R4
;
; IMPLICIT OUTPUTS:
;	COUNT IN WAIT QUEUE HEADER IS DECREMENTED IF STATE IS A WAIT
;	STATE.
;
;--

SCH$UNWAIT::				; DECREMENT PROPER WAIT COUNT
	BBC	R1,B^WAITMSK,20$	; SKIP OUT IF NOT WAIT STATE
	CMPW	#SCH$C_CEF,R1		; CHECK FOR COMMON EVENT FLAG WAIT
	BEQL	30$			; CEF WAIT
	MULL	#WQH$C_LENGTH,R1	; COMPUTE BYTE INDEX TO WQ HDR
	MOVAB	W^SCH$AQ_WQHDR[R1],R0	; COMPUTE ADDRESS OF WAIT Q HEADER
10$:	DECW	WQH$W_WQCNT(R0)		; DECREMENT WAIT QUEUE COUNT
20$:	RSB				; RETURN

30$:	MOVZBL	PCB$B_WEFC(R4),R0	; WAIT CLUSTER NUMBER
	MOVL	PCB$L_EFCS(R4)[R0],R0	; GET CLUSTER ADDRESS
	ADDL	#CEB$L_WQFL,R0		; POINT TO WAIT QUEUE HEADER
	BRB	10$			; GO DECREMENT WAIT COUNT

	GMASK	CEF			; COMMON EVENT FLAG
	GMASK	LEF			; LOCAL EVENT FLAG WAIT
	GMASK	LEFO			; LOCAL EVENT FLAG WAIT
	GMASK	HIB			; HIBERNAT WAIT
	GMASK	HIBO			; HIBERNATE WAIT
	GMASK	FPG			; FREE PAGE WAIT
	GMASK	COLPG			; COLLISION PAGE WAIT
	GMASK	PFW			; PAGE FAULT WAIT
	GMASK	SUSP			; SUSPENDED WAIT
	GMASK	SUSPO			; SUSPENDED WAIT
	GMASK	MWAIT			; MUTEX WAIT
WAITMSK:.LONG	WAITST			; MASK OF WAIT STATES

	.PAGE
	.SBTTL	SITUATIONAL PRIORITY INCREMENT TABLE
;
; FIXED DATA:
;		SITUATIONAL PRIORITY INCREMENT TABLE
;		    (INDEXED BY PRIORITY INCREMENT CLASS)
;

B_PINC:					;
	.BYTE	0			; CLASS 0 - NONE
	.BYTE	2			; CLASS 1 - I/O COMPLETE
	.BYTE	3			; CLASS 2 - RESOURCE AVAIL
	.BYTE	4			; CLASS 3 - TERM OUTPUT COMP
	.BYTE	6			; CLASS 4 - TERM INPUT COMP


EXESTATE:				; EXECUTABLE STATE MASK
	.LONG	<1@SCH$C_COM>!<1@SCH$C_COMO>

	.PAGE
	.SBTTL	SCH$CHSE - CHANGE STATE TO EXECUTABLE
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$CHSE CHANGES THE STATE OF A PROCESS, AS REPRESENTED BY
;	ITS PCB, TO AN EXECUTABLE STATE.  THE RESCHEDULING INTERRUPT
;	WILL BE TRIGGERED IF THE PROCESS IS RESIDENT AND HAS A PRIOITY
;	GREATER THAN THAT OF THE CURRENTLY EXECUTING PROCESS.  A 
;	PRIORITY INCREMENT CLASS NUMBER SUPPLIED AS A REGISTER CONTAINED
;	ARGUMENT IS USED TO COMPUTE THE NEW PROCESS PRIORITY FROM ITS
;	BASE PRIORITY.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$CHSE	
;
; INPUT PARAMETERS:
;	R0 - NEW PRIORITY	(SCH$CHSEP ONLY)
;	R2 - PRIORITY INCREMENT CLASS NUMBER   (SCH$CHSE ONLY)
;		0 => NO INCREMENT (PAGEFAULT I/O COMPLETION)
;		1 => NON-TERMINAL I/O COMPLETION
;		2 => RESOURCE AVAILABILITY
;		3 => TERMINAL OUTPUT COMPLETION
;		4 => TERMINAL INPUT COMPLETION
;	R4 - PCB ADDRESS
;
; IMPLICIT INPUTS:
;	SCH$AQ_COMT - COMPUTE QUEUE HEADERS FOR COM,COMO STATES
;	SCH$GB_PRI  - CURRENT PROCESS PRIORITY.
;
;
; OUTPUT PARAMETERS:
;	R2 - R2 , PRIORITY INCREMENT CLASS NUMBER IF SCH$CHSE. (PRESERVED)
;	R3 - R3 (PRESERVED)
;
; IMPLICIT OUTPUTS:
;	SCH$AQ_COMH  -  VECTOR OF COMPUTE QUEUE HEADERS.
;	SCH$GL_COMQS -  COMPUTE QUEUE SUMMARY BIT VECTOR.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	THE PCB SPECIFIED IS REMOVED FROM ITS PRESENT STATE QUEUE
;	AND INSERTED IN THE APPROPRIATE COMPUTE QUEUE, COM OR COMO,
;	AT THE PRIORITY COMPUTED FOR THE SPECIFIED SITUATION CLASS.
;	THE SUMMARY BIT FOR THE DESTINATION STATE QUEUE IS SET TO
;	NOTE THAT IT IS OCCUPIED.
;	IF THE NEW PRIORITY FOR THE PROCESS IS GREATER THAN THAT OF
;	CURRENT PROCESS AND IT IS RESIDENT, THE RESCHEDULING INTERRUPT 
;	WILL BE TRIGGERED.
;
;--
SCH$CHSE::				;CHANGE TO EXECUTABLE STATE
	CLRL	R0			; CLEAR HIGH SUM BITS FOR ADDB
	SUBB3	B_PINC[R2],PCB$B_PRIB(R4),R0	; ADD PRIORITY INCR
	CMPB	R0,PCB$B_PRI(R4)	; CHECK FOR > CURRENT PRI
	BLEQ	10$			; NO
	MOVB	PCB$B_PRI(R4),R0	; KEEP CURRENT PRIORITY INSTEAD
10$:	CMPB	R0,#16			; CHECK FOR RESULT >15
	BGEQ	SCH$CHSEP		; YES, USE COMPUTED VALUE
	MOVB	PCB$B_PRIB(R4),R0	; KEEP AT BASE IF LESS

;
;	SCH$CHSEP - SUB-ENTRY POINT WITH PRIORITY PRECOMPUTED IN R0
;

SCH$CHSEP::				; ENTRY WITH PRIO IN R0
	MFPR	#PR$_IPL,R1		; GET IPL
	CMPL	R1,#IPL$_SYNCH		; MUST BE AT SYNCH OR GREATER
	BLSS	BADIPL			; NO, FATAL ERROR
	REMQUE	(R4),R1			; REMOVE FROM CURREN QUEUE
	BNEQ	10$			; CONTINUE IF QUEUE NOTEMPTY
	MOVZWL	PCB$W_STATE(R4),R1	; GET OLD STATE
	BBC	R1,EXESTATE,10$		; NO SUMMARY BITS
	MOVZBL	PCB$B_PRI(R4),R1	; GET CURRENT PRI
	BLBC	PCB$W_STATE(R4),5$	; SKIP IF RESIDENT
	ADDL	#32,R1			; MAKE NONRES PRIO
5$:	BBCC	R1,W^SCH$GL_COMQS,10$	; CLEAR PRESENCE BIT FOR STATE
10$:	MOVB	R0,PCB$B_PRI(R4)	; SAVE NEW PRIO
	MOVL	#SCH$C_COM,R1		; ASSUME COM STATE
	BLBS	PCB$L_STS(R4),20$	; CHECK FOR RESIDENCE
	INCL	R1			; COMO=COM+1
	ADDL2	#32,R0			; COMO HEADERS FOLLOW COM
	BSBW	SCH$SWPWAKE		; WAKE SWAPPER
	BRB	30$			; COMPLETE STATE CHANGE
20$:	CMPB	W^SCH$GB_PRI,R0		; IS PRIO GREATER THAN CURRENT PROCESS
	BLSS	30$			; NO, DONT RESCHEDULE
	SOFTINT	#IPL$_SCHED		; TRIGGER RESCHEDULE INTERRUPT
30$:	MOVW	R1,PCB$W_STATE(R4)	; SET NEW STATE
	MOVAQ	W^SCH$AQ_COMT[R0],R1	; COMPUTE HDR ADDR
	BBSS	R0,W^SCH$GL_COMQS,40$	; SET SUMMARY BIT FOR NEW QUEUE
40$:	INSQUE	(R4),@(R1)+		; INSERT IN NEW QUEUE
	RSB				; RETURN

BADIPL:	BUG_CHECK BADRSEIPL,FATAL	; BAD IPL AT ENTRANCE TO RSE

	.PAGE
	.SBTTL	SWPO - SWAP OUT SIMPLE NON-EXECUTABLE
;
;	SWPO - SWAP OUT ACTION ROUTINE FOR SIMPLE NON-EXECUTABLE STATES
;
SWPO:					; NON-EXECUTABLE OUTSWAP
	BSBW	SCH$UNWAIT		; REMOVE FROM WAIT QUEUE
	INCW	PCB$W_STATE(R4)		; UPDATE STATE NUMBER
	REMQUE	(R4),R1			; REMOVE FROM WAIT QUEUE
	INSQUE	(R4),@WQH$L_WQBL+WQH$C_LENGTH(R0)	; INSERT AT TAIL OF QUEUE
	INCW	WQH$W_WQCNT+WQH$C_LENGTH(R0)	; NOTE COUNT IN WAIT QUEUE
	RSB				; EXIT

;
;	SWPOE - SWAP OUT EXECUTABLE ACTION ROUTINE
;
SWPOE:	MOVZBL	PCB$B_PRI(R4),R0	; GET PRIORITY
	BRW	SCH$CHSEP		; AND CHANGE TO COMO
	.PAGE
	.SBTTL	SCH$QEND - QUANTUM END ROUTINE

;++
;
; FUNCTIONAL DESCRIPTION:
;	SCH$QEND IS CALLED BY THE TIMER WHEN THE QUANTUM FOR THE CURRENT
;	PROCESS HAS BEEN EXHAUSTED.  A NEW QUANTUM IS INITIALIZED
;	THE PROCESS PLACED AT ITS BASE PRIORITY AND THE RESCHEDULING
;	INTERRUPT TRIGGERED.  A CHECK IS MADE FOR CPU TIME LIMIT EXPIRATION
;	AND APPROPRIATE EXIT ASTS GENERATED WHEN THE LIMIT IS REACHED.
;	THE AUTOMATIC WORKING SET SIZE LOGIC IS INVOKED IF ENABLED TO
;	TRADEOFF WORKING SET SIZE AGAINST PAGEFAULT RATE.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$QEND
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;	R5 - PROCESS HEADER ADDRESS
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS
;	PROCESS HEADER OF CURRENT PROCESS
;
; IMPLICIT OUTPUTS:
;	PHD$W_QUANT - INITIALIZED TO A NEW QUANTUM 
;	PCB$V_INQUAN - INITIAL QUANTUM FLAG CLEARED
;
;--

SCH$QEND::				; QUANTUM END ROUTINE
	BBCC	#PCB$V_INQUAN,PCB$L_STS(R4),10$ ; CLEAR INITIAL QUAN FLAG
10$:	MOVW	SCH$GW_QUAN,PHD$W_QUANT(R5)   ; SET NEW QUANTUM
	CMPB	PCB$B_PRI(R4),#16	; CHECK FOR REAL-TIME
	BLSS	50$			; YES
	BSBW	SCH$SWPWAKE		; AND FORCE SWAP SCHEDULE
;
;
;	CHECK FOR CPU TIME LIMIT EXPIRATION
;
	TSTL	PHD$L_CPULIM(R5)	; IS THERE ANY LIMIT?
	BNEQ	60$			; YES, GO CHECK IT OUT
40$:	BBS	#PCB$V_DISAWS,PCB$L_STS(R4),45$ ; BRANCH IF ADJUSTMENT DISABLED
	MOVL	W^SCH$GL_WSINC,R3	; ASSUME INCREMENT
	BEQL	45$			; BR IF NO AUTO WS ADJUSTMENT
	BSBB	WSADJUST		; ELSE GO DO IT
45$:	TSTL	W^SCH$GL_COMOQS		; IS THERE ANY INSWAP PENDING?
	BEQL	47$			; NO
	MOVB	PCB$B_PRIB(R4),PCB$B_PRI(R4)	; YES, FORCE TO BASE PRIORITY
	BSBW	SCH$SWPWAKE		; AND WAKE SWAPPER
47$:	SOFTINT	#IPL$_SCHED		; TRIGGER RESCHEDULING INT
50$:	RSB				; AND RETURN

;
;	A non-zero limit exists, check for processor time expiration
;
;	If CPU time limit is exceeded then an additional amount of time will
;	be allowed for each access mode.  An AST will be issued to cause an
;	exit for each of the access modes.  The additional time allowance will
;	be provided for each access mode.
;

60$:	SUBL3	PHD$L_CPULIM(R5),PHD$L_CPUTIM(R5),R0 ; HAS LIMIT BEEN REACHED
	BLSSU	40$			; NO, CONTINUE NORMALLY
;
;	CPU LIMIT HAS EXPIRED, AN AST WILL BE SENT TO NOTIFY THE PROCESS
;
	ADDL2	W^SGN$GL_EXTRACPU,R0	; COMPUTE TOTAL AMOUNT OF EXTRA TIME
	ADDL2	R0,PHD$L_CPULIM(R5)	; GIVE EXTRA TIME FOR CLEANUP
	ADDL2	R0,PHD$L_EXTRACPU(R5)	;  AND RECORD AMOUNT OF EXTRA TIME
	MOVAB	PHD$B_CPUMODE(R5),R0	; GET ADDRESS OF AST ACCESS MODE
	PUSHAB	40$			; SET RETURN ADDRESS
	MOVZWL	#SS$_EXCPUTIM,R3	; PASS EXIT STATUS TO SENDAST
SCH$FORCEDEXIT::
	BSBW	SENDAST			; SEND AST TO PROCESS
;
;	CPU TIME EXPIRATION AST HANDLER
;
CPUABRT:.WORD	0			; NULL ENTRY MASK
	CHMK	S^#ASTEXIT		; EXIT FROM AST ROUTINE (CLEAR AST)
10$:	$EXIT_S	4(AP)			; EXIT TO INVOKE EXIT HANDLERS
	BRB	10$			; JUST IN CASE

;
;	Adjust working set size automatically to achieve desired tradeoff
;	between page fault rate and working set size.  There are two page
;	fault rate thresholds: SCH$GL_PFRATL, the lower threshold and
;	SCH$GL_PFRATH, the higher threshold.  Each time SCH$QEND is invoked,
;	the page fault rate is computed and compared with these thresholds.
;	If it is above the high threshold the working set size is increased
;	by SCH$GW_WSINC and if the rate is below the lower threshold, the
;	working set size is decreased by SCH$GW_WSDEC.  The actual adjustment
;	is performed by a normal kernel mode AST.
;
;	Automatic adjustment of working set size is constrained by the values:
;	SCH$GW_AWSMIN and WSEXTENT per process that establish upper and lower 
;	values  for automatic working set size adjustment.  Working set size
;	adjustment is further constrained by the process quota.
;
;
;	R3 - Working set increment
;
WSADJUST:				; AUTO-ADJUST WORKING SET SIZE
	SUBL3	PHD$L_TIMREF(R5),-	; COMPUTE DELTA-T
		PHD$L_CPUTIM(R5),R0	;
	BNEQ	10$			; BR IF NON-ZERO
	INCL	R0			; ELSE FORCE TO ONE FOR DIVIDE
10$:	
	CMPL	R0,W^SCH$GL_AWSTIME	; IS THIS A MEANINGFUL INTERVAL?
	BLSS	NOADJUST		; NO, TRY AGAIN LATER
	SUBL3	PHD$L_PFLREF(R5),-	; COMPUTE DELTA-PGFLT
		PHD$L_PAGEFLTS(R5),R1	;
	MOVL	PHD$L_PAGEFLTS(R5),PHD$L_PFLREF(R5) ; SAVE NEW PAGE FAULT REF
	MOVL	PHD$L_CPUTIM(R5),PHD$L_TIMREF(R5)   ; AND SAVE CPUTIME REF
	MULL	#1000,R1		; MULTIPLY BY SCALE FACTOR
	DIVL	R0,R1			; AND COMPUTE PAGEFLTS/10SEC
	MOVL	R1,PHD$L_PFLTRATE(R5)	; SAVE CURRENT RATE
	CMPL	R1,W^SCH$GL_PFRATH	; ARE WE ABOVE HIGH THRESHOLD?
	BGEQ	ADJUSTUP		; YES, 
	MNEGL	W^SCH$GL_WSDEC,R3	; NO, GET DECREMENT VALUE
	CMPL	R1,W^SCH$GL_PFRATL	; ARE WE BELOW LOW THRESHOLD?
	BGEQ	NOADJUST		; NO, IN DEAD BAND -- NOTHING TO DO
	CMPW	PCB$W_PPGCNT(R4),W^SCH$GW_AWSMIN ; ARE WE AT LOWER WS LIMIT?
	BLEQU	NOADJUST		; YES, NOTHING TO DO
	BRB	ADJUST			;
NOADJUST:				;
	RSB				;
ADJUSTUP:				;
	SUBW3	PHD$W_WSLIST(R5),PHD$W_WSQUOTA(R5),R1
					; ASSUME HIGH LIMIT WILL BE QUOTA
	MOVZWL	PHD$W_WSSIZE(R5),R0	; GET CURRENT WORKING SET SIZE
	CMPW	W^SCH$GL_BORROWLIM,W^SCH$GL_FREECNT ; ARE THERE LOTS OF FREE PAGES?
	BGTR	10$			; BRANCH IF MEMORY IS AT A PREMIUM
	SUBW3	PHD$W_WSLIST(R5),PHD$W_WSEXTENT(R5),R1
					; ALLOW LARGER GROWTH SIZE
10$:	CMPW	R0,R1			; ARE WE AT MAXIMUM SIZE?
	BGTRU	NOADJUST		; YES, CAN'T GO ANY LARGER
	SUBW	PCB$W_GPGCNT(R4),R0	; DETERMINE IF WS IS FULL
	SUBW	PCB$W_PPGCNT(R4),R0	; BY SUBTRACTING CURRENT PHYSICAL SIZE
	BGTRU	NOADJUST		; BR SPACE LEFT
	BLSSU	WSERR			; BRANCH IF WS SMALLER THAN PAGES IN USE
ADJUST:	MOVAB	PHD$B_AWSMODE(R5),R0	; GET ADDRESS OF AST ACCESS MODE 
	BSBB	SENDAST			; SEND AST TO PROCESS

ADJWS:	.WORD	0			;
	MOVL	@#CTL$GL_PHD,R1		; GET PHD ADDRESS SO 
	CLRB	PHD$B_AWSMODE(R1)	;  ACCESS MODE FLAG CAN BE RESET
	$ADJWSL_S	4(AP)		; ADJUST BY PARAMETER IN AST ARGLIST
	RET				; AND RETURN

WSERR:	BUG_CHECK WSSIZEERR,FATAL	; WORKING SET SIZE CALC IN ERROR
	.PAGE
	.SBTTL	SENDAST - Send AST to process
;++
; FUNCTIONAL DESCRIPTION: SENDAST IS CALLED BY SCH$QEND TO SEND ASTS TO THE
;	PROCESS THAT INVOKE FUNCTIONS UNAVAILABLE TO THE ENVIRONMENT OF SCH$QEND.
;	THESE INCLUDE ADJUSTING THE WORKING SET AND EXITTING.
;
; INPUT PARAMETERS:
;
;	R0	- ADDRESS OF ACCESS MODE FOR AST
;		   (NEGATIVE CONTENTS PREVENT SENDING AST)
;	R3	- AST PARAMETER
;	R4	- PCB ADDRESS
;	(SP)	- AST ADDRESS
;	4(SP)	- RETURN ADDRESS FOR THIS SUBROUTINE
;--
SENDAST:				;
	PUSHL	R0			; SAVE ADDRESS OF ACCESS MODE
	PUSHL	R3			; AND AST PARAMETER
	TSTB	(R0)			; CHECK VALUE OF ACCESS MODE
	BLSS	10$			; DO NOT QUEUE AST IF NEGATIVE
	BBS	#PCB$V_DELPEN,PCB$L_STS(R4),10$ ;  NOR IF MARKED FOR DELETE
	MOVZWL	#ACB$C_LENGTH,R1	; SET SIZE REQUIRED
	BSBW	EXE$ALONONPAGED		; ALLOCATE A BLOCK
	BLBC	R0,10$			; NONE, TRY LATER
	MOVB	#DYN$C_ACB,ACB$B_TYPE(R2); SET TYPE OF STRUCTURE
	MOVW	R1,ACB$W_SIZE(R2)	; AND SIZE OF STRUCTURE
	MOVL	(SP)+,ACB$L_ASTPRM(R2)	; AND AST PARAMETER VALUE
	MOVB	@(SP),ACB$B_RMOD(R2)	; SET ACCESS MODE FOR AST
	DECB	@(SP)+			; INDICATE SUCCESS FOR THIS ACCESS MODE
	MOVL	(SP)+,ACB$L_AST(R2)	; SET AST ADDRESS
	MOVL	PCB$L_PID(R4),ACB$L_PID(R2)	; SET PID FOR AST
	PUSHR	#^M<R4,R5>		; SAVE REGS FOR QAST
	MOVL	R2,R5			; SET ADDRESS OF ACB
	CLRL	R2			; NULL PRIORITY INCREMENT
	BSBW	SCH$QAST		; QUEUE AST FOR PROCESS
	POPR	#^M<R4,R5>		; RESTORE PCB,PHD ADDRESSES
	RSB				; EXIT

;  Error path if nonpaged pool allocation fails or if AST access mode is
;  negative, indicating either an AST in progress (for automatic working
;  set adjustment) or all access modes are done (for CPU time limit expiration)

10$:	ADDL	#12,SP			; CLEAN PARAMETERS FROM STACK
	RSB				; AND EXIT

	.PAGE

	.SBTTL	SCH$WAKE - WAKE PROCESS INTERNAL
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$WAKE WAKES THE PROCESS SPECIFIED BY THE PID SUPPLIED.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$WAKE
;
; INPUT PARAMETERS:
;	R1 - PID OF PROCESS TO WAKE
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	R4 - PCB ADDRESS OF PROCESS AWAKENED
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL SUCCESSFUL COMPLETION STATUS
;	SS$_NONEXPR -  NONEXISTENT PROCESS (INVALID PID)
;
; ENVIRONMENT:
;	IPL = IPL$_SYNCH
;
;--
SCH$WAKE::				; WAKE PROCESS INTERNAL
	MOVZWL	R1,R4			; GET PROCESS INDEX (PIX)
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	; LOOK UP PCB ADDRESS
	CMPL	R1,PCB$L_PID(R4)	; VERIFY PID
	BNEQ	30$			; REPORT ERROR
	BBSS	#PCB$V_WAKEPEN,PCB$L_STS(R4),10$   ; SET WAKE PENDING
10$:					;
	MOVZBL	#PRI$_RESAVL,R2		; SET PRIORITY INCREMENT CLASS
	RPTEVT	WAKE			; REPORT WAKE EVENT
	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS CODE
20$:	RSB				; RETURN

30$:	MOVZWL	#SS$_NONEXPR,R0		; SET NONEXISTENT PROCESS STATUS
	RSB				;
	.PAGE
	.SBTTL	SCH$SWPWAKE - WAKE SWAPPER PROCESS
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$SWPWAKE AWAKENS THE SWAPPER PROCESS TO PERFORM SOME OPERATION.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$SWPWAKE
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R0-R4 PRESERVED
;
; SIDE EFFECTS:
;	A WAKE EVENT IS GENERATED FOR THE SWAPPER PROCESS WHICH CAN
;	CAUSE THE PROCESSOR TO BE RESCHEDULED.
;
;--

SCH$SWPWAKE::				; WAKE SWAPPER PROCESS
	TSTL	W^SCH$GL_COMOQS		; ANY INSWAP CANDIDATES?
	BNEQ	10$			; YES, MUST WAKE SWAPPER THEN
	CMPL	W^SCH$GL_MFYCNT,W^SCH$GL_MFYLIM ; ARE THERE MODIFIED PAGES TO WRITE?
	BGEQ	10$			; YES, MUST WAKE SWAPPER THEN
	CMPL	W^SCH$GL_FREECNT,W^SCH$GL_FREELIM ; DO WE NEED FREE PAGES?
	BLSS	10$			; YES, MUST WAKE SWAPPER THEN
	TSTW	W^SCH$GW_DELPHDCT	; ARE THERE DELETED HEADERS TO PURGE?
	BNEQ	10$			; YES, MUST WAKE SWAPPER THEN
	TSTL	W^EXE$GL_PFATIM		; WAS THERE A POWER FAIL RECOVERY?
	BEQL	20$			; BR IF NONE
10$:	TSTB	W^SCH$GB_SIP		; SWAPPER ALREADY BUSY?
	BNEQ	20$			; BR IF YES
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE R0-R4
	MOVL	W^SCH$GL_SWPPID,R1	; GET PID OF SWAPPER
	BSBB	SCH$WAKE		; AND AWAKEN IT
	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE R0-R4
20$:	RSB				; AND RETURN TO CALLER

	.END
