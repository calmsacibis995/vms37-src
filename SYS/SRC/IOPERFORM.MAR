	.TITLE	IOPERFORM - I/O PERFORMANCE DATA COLLECTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 18-NOV-77
;
; I/O PERFORMANCE MEASUREMENT DATA COLLECTION ROUTINES
;
; MODIFIED BY:
;
; V02-002 RIH0001	RICHARD I. HUSTVEDT	29-AUG-1980
;	Performance optimization when I/O data collection is not active.
;
; MACRO LIBRARY CALLS
;
 
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$IRPDEF				;DEFINE IRP OFFSETS
	$PBHDEF				;DEFINE PBH OFFSETS
	$PDBDEF				;DEFINE PDB OFFSETS
	$PIBDEF				;DEFINE PIB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTER DEFINITIONS
	$UCBDEF				;DEFINE UCB OFFSETS
	.PAGE
	.SBTTL	END OF I/O TRANSACTION
;+
; PMS$END_IO - END OF I/O TRANSACTION
;
; THIS ROUTINE IS CALLED AT THE END OF AN I/O TRANSACTION TO ENTER A MESSAGE
; IN THE I/O PERFORMANCE DATA COLLECTION BUFFER.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF I/O PERFORMANCE DATA COLLECTION IS ENABLED AND THE CURRENT I/O PACKET
;	CONFORMS TO THE SELECTION CRITERIA, THEN AN END OF I/O TRANSACTION IS
;	PLACED IN THE CURRENT DATA BUFFER.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-
 
	.IF DF	CA$_MEASURE_IOT
 
	.PSECT	$AEXENONPAGED
PMS$END_IO::				;END OF I/O TRANSACTION
	TSTL	W^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	5$			;BR IF YES
	RSB				;ELSE RETURN
5$:	PUSHR	#^M<R0,R1,R2,R3>	;SAVE REGISTERS
	MOVZBL	#PIB$K_EIO_SIZE,R1	;SET SIZE OF MESSAGE BUFFER
	DSBINT	#15			;DISABLE SOFTWARE INTERRUPTS
	BSBW	ALLOCATE		;ALLOCATE MESSAGE BUFFER
	MOVB	#PIB$K_EIO,PIB$B_TYPE(R0) ;INSERT MESSAGE TYPE
	MOVQ	IRP$L_MEDIA(R3),PIB$Q_EIO_IOSB(R0) ;INSERT FINAL I/O STATUS
	BRW	COMMON			;
	.PAGE
	.SBTTL	END OF I/O REQUEST
;+
; PMS$END_RQ - END OF I/O REQUEST
;
; THIS ROUTINE IS CALLED AT THE END OF AN I/O REQUEST TO ENTER A MESSAGE IN THE
; I/O PERFORMANCE DATA COLLECTION BUFFER.
;
; INPUTS:
;
;	R5 = ADDRESS OF I/O REQUEST PACKET.
;
;	ROUTINE IS ASSUMED TO HAVE BEEN CALLED FROM I/O POST AT I/O POST
;	LEVEL.
;
; OUTPUTS:
;
;	IF I/O PERFORMANCE DATA COLLECTION IS ENABLED AND THE CURRENT I/O PACKET
;	CONFORMS TO THE SELECTION CRITERIA, THEN AN END OF I/O REQUEST TRANSACTION
;	IS PLACED IN THE CURRENT DATA BUFFER.
;
;	IF ANY BUFFERS ARE READY TO PROCESS, THEN THE I/O PERFORMANCE DATA
;	COLLECTION PROCESS IS AWAKENED.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-
 
PMS$END_RQ::				;END OF I/O REQUEST
	TSTL	W^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	5$			;BR IF YES
	RSB				;ELSE RETURN
5$:	PUSHR	#^M<R0,R1,R2,R3>	;SAVE REGISTERS
	MOVL	R5,R3			;COPY ADDRESS OF I/O PACKET
	MOVZBL	#PIB$K_ERQ_SIZE,R1	;SET SIZE OF MESSAGE BUFFER
	DSBINT	#15			;DISABLE SOFTWARE INTERRUPTS
	BSBB	ALLOCATE		;ALLOCATE MESSAGE BUFFER
	MOVB	#PIB$K_ERQ,PIB$B_TYPE(R0) ;INSERT MESSAGE TYPE
	TSTW	PDB$W_BUFCNT(R2)	;ANY FULL BUFFERS?
	BEQL	10$			;IF EQL NO
	MOVQ	R4,-(SP)		;SAVE REGISTERS
	MOVL	PDB$L_PID(R2),R1	;GET DATA COLLECTION PROCESS INDENTIFICATION
	BSBW	SCH$WAKE		;WAKE PROCESS
	MOVQ	(SP)+,R4		;RESTORE REGISTERS
10$:	BRB	COMMON			;
	.PAGE
	.SBTTL	START OF I/O TRANSACTION
;+
; PMS$START_IO - START OF I/O TRANSACTION
;
; THIS ROUTINE IS CALLED AT THE START OF AN I/O TRANSACTION TO ENTER A MESSAGE
; IN THE CURRENT I/O PERFORMANCE DATA COLLECTION BUFFER.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF I/O PERFORMANCE DATA COLLECTION IS ENABLED AND THE CURRENT I/O PACKET
;	CONFORMS TO THE SELECTION CRITERIA, THEN AN START OF I/O TRANSACTION IS
;	PLACED IN THE CURRENT DATA BUFFER.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-
 
PMS$START_IO::				;START OF I/O TRANSACTION
	TSTL	W^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	5$			;BR IF YES
	RSB				;ELSE RETURN
5$:	PUSHR	#^M<R0,R1,R2,R3>	;SAVE REGISTERS
	MOVZBL	#PIB$K_SIO_SIZE,R1	;SET SIZE OF MESSAGE BUFFER
	DSBINT	#15			;DISABLE SOFTWARE INTERRUPTS
	BSBB	ALLOCATE		;ALLOCATE MESSAGE BUFFER
	MOVB	#PIB$K_SIO,PIB$B_TYPE(R0) ;INSERT MESSAGE TYPE
	MOVW	IRP$W_BCNT(R3),PIB$W_SIO_BCNT(R0) ;INSERT TRANSFER BYTE COUNT
	MOVL	IRP$L_MEDIA(R3),PIB$L_SIO_MEDIA(R0) ;INSERT MEDIA ADDRESS
	BRB	COMMON			;
	.PAGE
	.SBTTL	START OF I/O REQUEST
;+
; PMS$START_RQ - START OF I/O REQUEST
;
; THIS ROUTINE IS CALLED AT THE START OF AN I/O REQUEST TO ENTER A MESSAGE IN THE
; I/O PERFORMANCE DATA COLLECTION BUFFER.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF I/O PERFORMANCE DATA COLLECTION IS ENABLED AND THE CURRENT I/O PACKET
;	CONFORMS TO THE SELECTION CRITERIA, THEN AN START OF I/O REQUEST TRANSACTION
;	IS PLACED IN THE CURRENT DATA BUFFER.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-
 
PMS$START_RQ::				;START OF I/O REQUEST
	DSBINT	#15			;DISABLE SOFTWARE INTERRUPTS
	MOVL	W^PMS$GL_IOPFMSEQ,IRP$L_SEQNUM(R3) ;INSERT PACKET SEQUENCE NUMBER
	INCL	W^PMS$GL_IOPFMSEQ	;INCREMENT I/O TRANSACTION SEQUENCE NUMBER
	TSTL	W^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	5$			;BR IF YES
	ENBINT				;ENABLE INTERRUPTS
	RSB				;AND RETURN
5$:	PUSHR	#^M<R0,R1,R2,R3>	;SAVE REGISTERS
	MOVZBL	#PIB$K_SRQ_SIZE,R1	;SET SIZE OF MESSAGE BUFFER
	BSBB	ALLOCATE		;ALLOCATE MESSAGE BUFFER
	MOVB	#PIB$K_SRQ,PIB$B_TYPE(R0) ;INSERT MESSAGE TYPE
	MOVB	IRP$B_PRI(R3),PIB$B_SRQ_PRI(R0) ;INSERT REQUEST PRIORITY
	MOVL	IRP$L_PID(R3),PIB$L_SRQ_PID(R0) ;INSERT REQUESTER PID
	MOVL	IRP$L_UCB(R3),PIB$L_SRQ_UCB(R0) ;INSERT DEVICE UCB ADDRESS
	MOVW	IRP$W_FUNC(R3),PIB$W_SRQ_FUNC(R0) ;INSERT I/O FUNCTION CODE
	MOVW	IRP$W_STS(R3),PIB$W_SRQ_STS(R0) ;INSERT PACKET STATUS WORD
COMMON:	ENBINT				;ENABLE INTERRUPTS
	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS
	RSB				;
	.PAGE
	.SBTTL	ALLOCATE MESSAGE BUFFER
;
; ALLOCATE - ALLOCATE MESSAGE BUFFER
;
; THIS ROUTINE IS CALLED TO:
;
;	1. TEST IF I/O PERFORMANCE MEASUREMENT IS ENABLED,
;	2. TEST IF THE DEVICE CLASS MATCHES,
;	3. TEST IF THE DEVICE TYPE MATCHES,
;	4. TEST IF THE FUNCTION CODE IS TO BE RECORDED, AND
;	5. TEST IF THE STATUS FIELD MATCHES.
;
; IF ALL OF THESE TESTS ARE SUCCESSFUL, THEN AN ATTEMPT IS MADE TO ALLOCATE
; AN I/O PERFORMANCE MEASUREMENT MESSAGE BUFFER.
;
; INPUTS:
;
;	R1 = SIZE OF MESSAGE TO ALLOCATE.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
;	REGISTERS R0, R1, R2, AND R3 ARE ASSUMED TO HAVE BEEN SAVED AND ALL
;	SOFTWARE INTERRUPTS ARE DISABLED.
;
; OUTPUTS:
;
;	IF I/O PERFORMANCE MEASUREMENT IS NOT ENABLED OR ANY OF THE SELECTION
;	CRITERIA FAILS, THEN THE RETURN ADDRESS IS REMOVED FROM THE STACK, THE
;	INTERRUPT LEVEL AND REGISTERS ARE RESTORED, AND A RETURN TO THE ORIGINAL
;	CALLER IS EXECUTED. ELSE AN ATTEMPT IS MADE TO ALLOCATE AN I/O PERFORM-
;	ANCE MEASUREMENT MESSAGE BUFFER.
;
;	IF THE ALLOCATION ATTEMPT FAILS, THEN THE RETURN ADDRESS IS REMOVED FROM
;	THE STACK, THE INTERRUPT LEVEL AND REGISTERS ARE RESTORED, AND A RETURN
;	TO THE ORIGINAL CALLER IS EXECUTED. ELSE THE MESSAGE BUFFER IS ALLOCATED,
;	THE TIME AND SEQUENCE NUMBER ARE FILLED IN, AND A RETURN TO THE CALLER
;	IS EXECUTED.
;
 
ALLOCATE:				;ALLOCATE MESSAGE BUFFER
	MOVL	W^PMS$GL_IOPFMPDB,R2	;GET ADDRESS OF I/O PERFORMANCE DATA BLOCK
	BEQL	60$			;IF EQL I/O PERFORMANCE MEASUREMENT DISABLED
	MOVL	IRP$L_UCB(R3),R0	;GET ADDRESS OF DEVICE UCB
	TSTB	PDB$B_DEVCLASS(R2)	;ALL CLASSES MATCH?
	BLSS	10$			;IF LSS YES
	CMPB	UCB$B_DEVCLASS(R0),PDB$B_DEVCLASS(R2) ;DEVICE CLASS MATCH?
	BNEQ	60$			;IF NEQ NO
10$:	TSTB	PDB$B_DEVTYPE(R2)	;ALL TYPES MATCH?
	BLSS	20$			;IF LSS YES
	CMPB	UCB$B_DEVTYPE(R0),PDB$B_DEVTYPE(R2) ;DEVICE TYPE MATCH?
	BNEQ	60$			;IF NEQ NO
20$:	EXTZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;GET I/O FUNCTION CODE
		IRP$W_FUNC(R3),R0	;
	BBC	R0,PDB$Q_FUNC(R2),60$	;IF CLR, FUNCTION NOT ENABLED
	BICW3	PDB$W_ANDM(R2),IRP$W_STS(R3),R0 ;CLEAR MISCELLANEOUS BITS
	XORW	PDB$W_XORM(R2),R0	;TEST FOR EQUALITY
	BNEQ	60$			;IF NEQ NO MATCH
30$:	TSTL	PDB$L_CURBUF(R2)	;ANY BUFFER CURRENTLY AVAILABLE?
	BEQL	40$			;IF EQL NO
	ADDL3	R1,PDB$L_NXTBUF(R2),R0	;CALCULATE ADDRESS OF FREE SPACE
	CMPL	R0,PDB$L_ENDBUF(R2)	;BEYOND END OF BUFFER?
	BLEQU	70$			;IF LEQU NO
	INSQUE	@PDB$L_CURBUF(R2),@PDB$L_FILLBL(R2) ;INSERT BUFFER IN FILLED LIST
	INCW	PDB$W_BUFCNT(R2)	;INCREMENT FULL BUFFER COUNT
	CLRL	PDB$L_CURBUF(R2)	;CLEAR ADDRESS OF CURRENT BUFFER
40$:	REMQUE	@PDB$L_FREEFL(R2),R0	;GET NEXT BUFFER FROM FREE LIST
	BVS	50$			;IF VS NO BUFFER AVAILABLE
	MOVL	R0,PDB$L_CURBUF(R2)	;SET ADDRESS OF AVAILABLE BUFFER
	MOVAB	PBH$K_START(R0),PDB$L_NXTBUF(R2) ;SET ADDRESS OF FREE SPACE
	MOVZWL	PBH$W_SIZE(R0),-(SP)	;GET LENGTH OF DATA BUFFER
	MOVAB	@(SP)+[R0],PDB$L_ENDBUF(R2) ;SET ENDING ADDRESS OF BUFFER
	BRB	30$			;
50$:	BISB	#1,PDB$B_OVERRUN(R2)	;SET OVERRUN INDICATOR
60$:	TSTL	(SP)+			;REMOVED RETURN FROM STACK
	ENBINT				;ENABLE INTERRUPTS
	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS
	RSB				;
 
;
; MESSAGE BUFFER SUCCESSFULLY ALLOCATED
;
 
70$:	MOVL	PDB$L_NXTBUF(R2),R0	;GET ADDRESS OF NEXT SPACE IN BUFFER
	ADDL3	R0,R1,PDB$L_NXTBUF(R2)	;CALCULATE ADDRESS OF NEXT AVAILABLE SPACE
	MOVL	PDB$L_CURBUF(R2),R1	;GET ADDRESS OF CURRENT BUFFER
	INCW	PBH$W_MSGCNT(R1)	;INCREMENT MESSAGE COUNT
	EXTZV	#10,#32,W^EXE$GQ_SYSTIME,PIB$L_SRQ_TIME(R0) ;INSERT CURRENT TIME
	MOVL	IRP$L_SEQNUM(R3),PIB$L_SRQ_SEQN(R0) ;INSERT SEQUENCE NUMBER
	RSB				;
 
	.ENDC
 
	.END
