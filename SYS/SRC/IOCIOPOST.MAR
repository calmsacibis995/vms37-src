	.TITLE	IOCIOPOST - I/O COMPLETION POSTING
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, I/O SYSTEM
;
; ABSTRACT:
;	IOCIOPOST IMPLEMENTS THE DEVICE INDEPENDENT COMPLETION PROCESSING FOR
;	I/O PACKETS.  IT IS INVOKED BY QUEUEING THE PACKET ON THE I/O POST QUEUE
;	AND TRIGGERING THE IPL$_IOPOST SOFTWARE INTERRUPT.  SOME OF THE IOPOST
;	OPERATIONS SUCH AS SETTING EVENT FLAGS, UNLOCKING BUFFER PAGES,
;	RELEASING BUFFERS AND PAGING I/O COMPLETION ARE PERFORMED IN THE IOPOST
;	INTERRUPT SERVICE ROUTINE, WHILE OTHER OPERATIONS THAT REQUIRE ACCESS
;	TO PROCESS ADDRESS SPACE ARE PERFORMED BY SENDING A SPECIAL KERNEL AST.
;
; ENVIRONMENT:	MODE = KERNEL, RESIDENT
;
;--
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: R. HUSTVEDT, CREATION DATE: 26-AUG-76
;
; MODIFIED BY:
;
;	V03-001	MSH0001		Maryann Hinden		16-Mar-1982
;		Use word count for complex buffers.  Fix PROBE problem.
;		
;	V02-017	ACG0229		Andrew C. Goldstein,	11-Dec-1981  21:31
;		Add virtual I/O counters
;
;	V02-016	ROW0012		Ralph O. Weber		6-AUG-1981
;		Alter Byte I/O post-processing to convert IRP$W_BOFF to a 
;		longword before using it to update JIB$L_BYTCNT.
;
;	V02-014	RLRLBCNT	Robert L. Rappaport	16-Mar-1981
;		Changes necessitated by the changes in the real lengths
;		of the IRP BCNT (BCNT, OBCNT, ABCNT) fields from words
;		to longwords.
;
;	V02-014	KDM0046		KATHLEEN D. MORSE	13-MAR-1981
;		Set event flag for I/O completion after the IOSB and I/O
;		buffers are written, not before.
;
;	V02-013	KDM0025		Kathleen D. Morse	29-Oct-1980
;		Swap I/O completion should not set an event flag.  This
;		fixes a bug in deletion of a writeable, shared memory
;		global section, which uses swap I/O to update the section
;		to a disk file.
;
;	V02-012	ACG0176		Andrew C. Goldstein,	6-Jun-1980  17:07
;		Redirect UCB pointer in I/O packet after map virtual
;
;**

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ACBDEF				; AST CONTROL BLOCK DEFINITIONS
	$AQBDEF				; DEFINE AQB OFFSETS
	$CADEF				; CONDITIONAL ASSEMBLY PARAMETERS
	$CCBDEF				; CCB DEFINITIONS
	$CXBDEF				; DEFINE CXB OFFSETS
	$IPLDEF				; IPL DEFINITIONS
	$IRPDEF				; IRP DEFINITIONS
	$IRPEDEF			; IRPE DEFINITIONS
	$JIBDEF				; JIB DEFINITIONS
	$PCBDEF				; PCB DEFINITIONS
	$PFNDEF				; PFN DATA BASE DEFINITIONS
	$PHDDEF				; PROCESS HEADER DEFINITIONS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRIDEF				; PRIORITY INCREMENT DEFS
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$RSNDEF				; DEFINE RESOURCE WAIT NUMBERS
	$UCBDEF				; DEFINE UCB OFFSETS
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$VCBDEF				; DEFINE VCB OFFSETS
	$WCBDEF				; DEFINE WCB OFFSETS
	$WQHDEF				; WAIT QUEUE HEADER DEFINITIONS

;
; OWN STORAGE:
;
	.PSECT	$AEXENONPAGED,LONG
PRITBL:					; TABLE OF PRIORITY INCR CLASSES
	.BYTE	PRI$_IOCOM		; 0 => DIRECT WRITE
	.BYTE	PRI$_TOCOM		; 1 => BUFFERED WRITE
	.BYTE	PRI$_IOCOM		; 2 => DIRECT READ
	.BYTE	PRI$_TICOM		; 3 => BUFFERED READ

	.SBTTL	I/O COMPLETION POSTING
;++
; FUNCTIONAL DESCRIPTION:
;
;	IOC$IOPOST IS INITIATED BY TRIGGERING AN IPL$_IOPOST SOFTWARE
;	INTERRUPT AFTER PLACING A COMPLETED I/O PACKET IN THE IOPOST
;	QUEUE.  IOC$IOPOST PERFORMS ALL APPROPRIATE COMPLETION ACTIVITY
;	REQUIRED FOR THE PACKET EITHER DIRECTLY OR BY QUEUEING KERNEL
;	ASTS TO CONCLUDE PROCESSING IN THE CONTEXT OF THE PROCESS
;	WHEN REQUIRED.
;
; CALLING SEQUENCE:
;
;	SOFTINT	#IPL$_IOPOST
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	IOC$GL_PSFL - IOPOSTING QUEUE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
;--

	.ENABL	LSB
IOC$IOPOST::				; I/O POSTING INTERRUPT
	MOVQ	R4,-(SP)		; SAVE
	MOVQ	R2,-(SP)		; NORMAL
	MOVQ	R0,-(SP)		; REGISTERS
IOPOST:	REMQUE	@W^IOC$GL_PSFL,R5	; GET HEAD OF POST QUEUE
	BVC	10$			; QUEUE NOT YET EMPTY
	MOVQ	(SP)+,R0		; RESTORE
	MOVQ	(SP)+,R2		; REGISTERS
	MOVQ	(SP)+,R4		; AND EXIT
	REI				; IF QUEUE EMPTY

5$:	BRW	VIRTUAL			; PROCESS VIRTUAL I/O COMPLETION

7$:	JSB	(R1)			; CALL END ACTION ROUTINE
	BRB	IOPOST			;

10$:	MOVL	IRP$L_PID(R5),R1	; GET PID/END ACTION ADDRESS
	BLSS	7$			; BR IF END ACTION ADDRESS
					; (SYSTEM SPACE ADDRESSES ARE NEGATIVE)
	MOVZWL	R1,R1			; GET PROCESS INDEX
	MOVL	@W^SCH$GL_PCBVEC[R1],R4	; AND TRANSLATE TO PCB ADDRESS
	BBC	#IRP$V_BUFIO,IRP$W_STS(R5),12$	; IF CLEAR, DIRECT I/O
	BRW	BUFIO			; BUFFERED I/O
12$:	INCW	PCB$W_DIOCNT(R4)	; UPDATE DIRECT I/O COUNT
	MOVL	IRP$L_SVAPTE(R5),R3	; GET ADDRESS OF FIRST PTE

	ASSUME	IRP$V_PAGIO LE 7
	ASSUME	IRP$V_SWAPIO LE 7
	BITB	#<IRP$M_PAGIO ! IRP$M_SWAPIO>,IRP$W_STS(R5) ; PAGIO OR SWAPIO?
	BNEQ	PAGIO_OR_SWAPIO
 
;
; DIRECT I/O COMPLETION
;
 
DIRIO:	TSTL	R3			; PTE ADDRESS VALID?
	BEQL	18$			; IF EQL NO PAGES TO UNLOCK
	MOVL	IRP$L_BCNT(R5),R1	; GET REQUESTED TRANSFER BYTE COUNT
	MOVZWL	IRP$W_BOFF(R5),R2	; GET BYTE OFFSET IN PAGE
	BBC	#IRP$V_VIRTUAL,IRP$W_STS(R5),UNLOCK ; BRANCH IF NOT VIRTUAL I/O
	BLBC	IRP$L_IOST1(R5),5$	; BRANCH IF ERROR IN VIRTUAL REQUEST
	TSTW	IRP$L_OBCNT+2(R5)	; WAS ORIGINAL COUNT > 64K?
	BEQL	14$			; EQL IMPLIES NO
	CMPL	IRP$L_IOST1+2(R5),-	; LONGWORD COMPARE FOR > 64K OBCNT
		IRP$L_OBCNT(R5)		; IF COMPLETED ORIGINAL BYTE COUNT
					; THEN NO SPECIAL VIRTUAL PROCESSING
	BRB	16$			; BRANCH AROUND TO COMMON 'BNEQ'
14$:
	CMPW	IRP$L_IOST1+2(R5),-	; *NOTE 'CMPW' DUE TO CODE PATH FOR <64K BCNT
		IRP$L_OBCNT(R5)		; IF COMPLETED ORIGINAL BYTE COUNT
					; THEN NO SPECIAL VIRTUAL PROCESSING
16$:
	BNEQ	5$			; OTHERWISE DO THE SEGMENTED COMPLETION
UNLOCK:	MOVAB	511(R1)[R2],R1		; COMBINE OFFSET AND COUNT AND ROUND
	ASHL	#-VA$S_BYTE,R1,R1	; CONVERT TO NUMBER OF PAGES
	BSBW	MMG$UNLOCK		; UNLOCK PAGES
18$:	BBC	#IRP$V_EXTEND,-
		IRP$W_STS(R5),19$	; BRANCH IF NO IRPE'S ATTACHED
	BSBW	UNLOCK_MORE		; UNLOCK AREAS DESCRIBED IN IRPE'S
19$:					; REFERENCE LABEL
 
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_RQ		; INSERT END OF I/O REQUEST MESSAGE
 
	.ENDC
 
	BRB	30$			;
 
;
;	PAGE I/O OR SWAP I/O COMPLETION
;

PAGIO_OR_SWAPIO:			; HERE WE ASSUME DISK I/O FOR PAGING
					;  AND SWAPPING AND WE FURTHER RELY
					;  ON THE FACT THAT ALL DISK DRIVERS
					;  TRADITIONALLY RETURN ZERO IN THE 2ND
					;  LONGWORD OF THE I/O STATUS BLOCK FOR
					;  DATA TRANSFER OPERATIONS.  THEREFORE
					;  THIS IS COMPATIBLE WITH DISK CLASS
					;  DRIVER WHICH GROWS THE # OF BYTES
					;  TRANSFERRED FIELD IN THE IOSB TO A
					;  FULL LONGWORD.
	BLBS	IRP$L_IOST1(R5),20$	; BR IF SUCCESSFUL I/O TRANSFER
	CMPL	IRP$L_IOST1+2(R5),-
		IRP$L_BCNT(R5)		; ERR PATH ONLY: IF DRIVER SAID
	BLSSU	20$			; IT TRANSFERRED LESS THAN TOTAL REQUEST
	CLRL	IRP$L_IOST1+2(R5)	; THEN BELIEVE IT, ELSE ASSUME NO XFR.
20$:
	CMPL	IRP$L_IOST1+2(R5),-
		IRP$L_OBCNT(R5)		; IF COMPLETED THE
					; ORIGINAL BYTE COUNT
	BEQL	26$			; THEN NO SEGMENTING NECESSARY
;
; THIS MUST BE EITHER A SEGMENTED REQUEST OR AN ERROR
;
	ADDL	IRP$L_IOST1+2(R5),-
		IRP$L_ABCNT(R5)		; UPDATE ACCUMULATED BYTE COUNT
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-
		IRP$L_IOST1+2(R5),R1	; R1 CONTAINS # PAGES TRANSFERRED
	ADDL	R1,IRP$L_SEGVBN(R5)	; NEXT STARTING VBN (OR ERROR VBN)
	BLBC	IRP$L_IOST1(R5),24$	; BRANCH IF ERROR
	SUBL3	IRP$L_ABCNT(R5),-
		IRP$L_OBCNT(R5),-	; CALCULATE REMAINING BYTE
		IRP$L_BCNT(R5)		; COUNT TO BE TRANSFERRED
	BNEQ	BRW_QNXTSEG		; BRANCH IF ANOTHER SEGMENT TO DO
;
; LAST SEGMENT COMPLETED OR ERROR
;
24$:
	MOVL	IRP$L_ABCNT(R5),-
		IRP$L_IOST1+2(R5)	; SET BYTES TRANSFERRED
	MOVL	IRP$L_DIAGBUF(R5),R3	; GET SAVED SVAPTE
	MOVL	R3,IRP$L_SVAPTE(R5)	; AND PUT IT BACK
26$:
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_RQ		; INSERT END OF I/O REQUEST MESSAGE
 
	.ENDC
 
	BBS	#IRP$V_PAGIO,IRP$W_STS(R5),PAGIO ; BRANCH IF PAGE I/O

;
;	SWAP I/O COMPLETION
;

	MOVL	IRP$L_ASTPRM(R5),ACB$L_KAST(R5)	; SET KERNEL AST ADDRESS
	BRB	40$			; AND ENQUEUE AST

;
; BUFFERED I/O COMPLETION
;
 
BUFIO:	INCW	PCB$W_BIOCNT(R4)	; UPDATE BUFFERED I/O COUNT
	BBC	#IRP$V_FILACP,IRP$W_STS(R5),NOTACP ; BR IF NOT ACP I/O
	INCW	PCB$W_DIOCNT(R4)	; RESTORE DIRECT I/O COUNT
NOTACP:					;
 
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_RQ		; INSERT END OF I/O REQUEST MESSAGE
 
	.ENDC
 
	MOVL	PCB$L_JIB(R4),R0	; GET JIB ADDRESS
	MOVZWL	IRP$W_BOFF(R5),R1	; Convert I/O byte count to a longword.
	ADDL	R1,JIB$L_BYTCNT(R0)	; Update Byte Count Quota.
	MOVL	IRP$L_SVAPTE(R5),R0	; ANY BUFFER SPECIFIED?
	BEQL	30$			; IF EQL NO
	MOVAB	W^BUFPOST,ACB$L_KAST(R5) ; ASSUME READ FUNCTION
	BBS	#IRP$V_FUNC,IRP$W_STS(R5),40$  ; IF SET, READ FUNCTION
	BSBW	EXE$DEANONPAGED		; DEALLOCATE WRITE BUFFER
30$:	MOVAB	W^DIRPOST,ACB$L_KAST(R5) ; SET SPECIAL KERNEL AST ADDRESS
40$:	EXTZV	#IRP$V_BUFIO,#2,IRP$W_STS(R5),R0  ; GET PACKET TYPE
	BBS	#IRP$V_TERMIO,IRP$W_STS(R5),50$	; BR IF TERMINAL I/O
	BICW	#1,R0			; ELSE TREAT AS NORMAL I/O COMPLETION
50$:					; FOR PRIORITY INCREMENT SELECTION
	MOVL	IRP$L_PID(R5),R1	; PROCESS IDENTIFICATION
	MOVZBL	PRITBL[R0],R2		; SET PRIORITY INCREMENT CLASS
IOPOST_KAST:
	BISB	#^X80,ACB$B_RMOD(R5)	; SET INTERNAL AST FLAG
	BSBW	SCH$QAST		; NOW QUEUE THE KERNEL AST
	BRW	IOPOST			; GET NEXT PACKET TO POST
	.DSABL	LSB

BRW_QNXTSEG:
	BRW	QNXTSEG			; GO DO THE NEXT VIRTUAL SEGMENT

	.SBTTL	PAGIO - PAGE I/O COMPLETION
;
; PAGING I/O COMPLETION
;
; INPUTS:
;
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = I/O REQUEST PACKET ADDRESS
;
;		FOR PAGE READ COMPLETION, THE FOLLOWING LOCATIONS IN THE
;	I/O REQUEST PACKET HAVE SPECIAL SIGNIFICANCE.
;
;	IRP$L_ASTPRM	= ORIGINAL PROCESS PAGE TABLE ENTRY BACKING STORE
;			  ADDRESS IF PAGE WAS A COPY ON REFERENCE PAGE.
;			  PFN$V_GBLBAK SET IF IT WAS GLOBAL CRF
;			= 0 IF NOT A COPY ON REFERENCE PAGE
;	IRP$L_AST	= MASTER PTE CONTENTS IF GLOBAL CRF (>0)
;			= SLAVE PTE ADDRESS IF GLOBAL NOT CRF (<0)
;			= 0 IF NOT GLOBAL
;
;		FOR PAGE WRITE COMPLETION, THE FOLLOWING LOCATIONS IN
;	THE I/O REQUEST PACKET HAVE SIGNIFICANCE.
;
;	IRP$B_RMOD	= REQUEST MODE ! ACB$V_QUOTA.  IF ACB$V_QUOTA IS SET,
;			  PROCESS REQUESTED AN AST ON PAGE WRITE COMPLETION
;	IRP$L_AST	= AST ADDRESS IF REQUESTED
;	IRP$L_ASTPRM	= AST PARAMETER IF SPECIFIED
;	IRP$L_IOSB	= ADDRESS OF I/O STATUS BLOCK IF SPECIFIED.  IF
;			  NON-ZERO, THEN PROCESS EXPECTS I/O STATUS RETURNED.
;
PAGIO:	MOVQ	R6,-(SP)		; SAVE SOME MORE REGISTERS
	MOVL	R5,R6			; USE R6 FOR IRP ADDRESS

	SETIPL	#IPL$_SYNCH		; SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVL	PCB$L_PHD(R4),R5	; USE R5 FOR PROCESS HEADER ADR
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; FORM PAGE COUNT
		IRP$L_IOST1+2(R6),R7	; OF THE DATA TRANSFERRED
	BBS	#IRP$V_FUNC,IRP$W_STS(R6),PAGRD_DONE ; BRANCH IF PAGE READ
;
; PAGE WRITE COMPLETE - R7 = NUMBER OF PAGES
;	CONDITION CODES SET FROM LOAD OF R7
;
	BEQL	60$			; BRANCH IF NO PAGES SUCCESSFULLY TRANSFERRED
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,(R3),R0 ;GET PFN FROM PTE
	CMPL	R0,MMG$GL_MAXPFN	;IS THIS PAGE IN SHARED MEMORY?
	BGTRU	60$			;BR IF PAGE IN SH MEM, NO PFN DATABASE
20$:	PUSHL	R3			; SAVE SVAPTE
	BSBW	PFN_IO_DONE		; SET PFN DATA BASE
;
; CONDITION CODES SET FROM DECREF
;
	BGTR	40$			; BRANCH IF REFCNT NOT 0
	BSBW	MMG$RELPFN		; RELEASE THE PAGE
40$:	ADDL3	#4,(SP)+,R3		; GET NEXT PTE ADDRESS
	SOBGTR	R7,20$			; DO THE NEXT PAGE IF ANY
60$:	SUBW3	#IRP$C_LENGTH,IRP$W_SIZE(R6),R7 ; IF EXTENDED I/O PACKET
					; THEN COMPLETION IS DONE BY
					; SPECIAL UPDATE SECTION KERNEL AST
	BLBC	IRP$L_IOST1(R6),PAGWRT_ERR ; BRANCH IF PAGE WRITE ERROR
;
; CONDITION CODES SET FROM LOAD OF R7
;
PAGWRT_ERR_DONE:
	BEQL	PAGIO_DONE1		; BRANCH IF NOT, COMPLETE THE I/O HERE
	BRB	PAGIO_DONE2		; COMPLETE I/O IN PROCESS CONTEXT
PAGWRT_ERR:
	BRW	PAGWRT_ERR1
;
; PAGE READ COMPLETE - R7 = NUMBER OF PAGES
;	CONDITION CODES SET FROM LOAD OF R7
;
PAGRD_DONE:
	BEQL	100$			; BRANCH IF NO PAGES SUCCESSFULLY TRANSFERRED
20$:	BSBW	PFN_IO_DONE		; RECORD PAGE READ DONE
;
; CONDITION CODES SET FROM DECREF
;
	BGTR	30$			; BRANCH IF REFCNT NOT ZERO
;
; NO MORE REFERENCES FOR THIS PAGE, DON'T MAKE IT VALID, RELEASE IT
;
	PUSHAL	4(R3)			; SAVE PTE ADR FOR NEXT PTE
	BSBW	MMG$RELPFN		; RELEASE THE PFN
	POPR	#^M<R3>			; RECOVER PTE FOR NEXT PAGE IN CLUSTER
	ADDL3	#4,IRP$L_AST(R6),R1	; GLOBAL PAGE?
	BGEQ	80$			; BRANCH IF IT ISN'T
	BRB	60$			; YES, SET CONTEXT FOR NEXT PAGE IN CLUSTER
30$:	BISB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ; PAGE IS NOW ACTIVE
	BBSS	#PTE$V_VALID,R0,40$	; TURN VALID ON WITH PFN
40$:	BISL	R0,(R3)+		; SET VALID IN PTE
					; NEXT PTE ADDRESS IN R3
	MOVL	IRP$L_AST(R6),R1	; GLOBAL PAGE?
	BGEQ	80$			; BRANCH IF NOT
;
; PAGE IS A GLOBAL PAGE, R1 = PROCESS PTE, MUST MAKE IT VALID TOO
;
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>,(R1),R2 ; PROTECTION AND OWNER FIELDS
	BISL3	R0,R2,(R1)+		; MAKE PROCESS PTE VALID
60$:	MOVL	R1,IRP$L_AST(R6)	; SET UP FOR NEXT PAGE IN CLUSTER
80$:	SOBGTR	R7,20$			; DO THE NEXT PAGE IF ANY
100$:	BLBC	IRP$L_IOST1(R6),PAGRD_ERR ; BRANCH IF PAGE READ ERROR
;
; LAST PAGE IN CLUSTER HAS BEEN PROCESSED, COMPLETE THE PROCESSING
; ASSOCIATED WITH THE TRANSFER AS A WHOLE.
;
PAGIO_DONE:
	MOVL	IRP$L_ASTPRM(R6),R1	; COPY ON REFERENCE SECTION?
	BEQL	20$			; BRANCH IF NOT
	BBC	#PFN$V_GBLBAK,R1,10$	; BRANCH IF NOT GBL CRF
	MOVAL	@MMG$GL_SYSPHD,R5	; SYSTEM HDR FOR GBL CRF PAGE
	MOVL	IRP$L_AST(R6),R1	; CONTENTS OF GBL PTE FOR GBL CRF
10$:	CVTWL	R1,R1			; SECTION INDEX
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; PAGE COUNT FROM
		IRP$L_IOST1+2(R6),R0	; BYTE COUNT TRANSFERRED
	BSBW	MMG$SUBSECREF		; SUBTRACT R0 FROM SECTION REFERENC COUNT
;
; REPORT THAT PAGE I/O HAS COMPLETED.
;
; NORMALLY IT IS ONLY NECESSARY TO REPORT "PAGE FAULT COMPLETE"
; TO THE PROCESS THAT INITIATED THE I/O, BUT FOR SYSTEM PAGES
; AND FOR GLOBAL PAGES, MULTIPLE FAULTS CAN OCCUR FOR THE SAME
; PAGE WHILE IT IS ON ITS WAY INTO MEMORY.  ALL PROCESSES WHICH
; FAULT THE PAGE WHILE ITS STATE IS "READ IN PROGRESS" GET QUEUED
; ON THE COLLISION PAGE QUEUE, AND THE COLLISION BIT IS SET IN THE
; TYPE BYTE OF THE PFN DATA BASE.  THIS ROUTINE ALSO REPORTS THE
; COLLISION PAGE AVAILABLE EVENT TO ALL PROCESSES ON THE COLLISION
; QUEUE, IF THE COLLISION BIT IS SET.
;
20$:
PAGIO_DONE1:
	MOVZBL	#PRI$_NULL,R2		; SET FOR NULL PRIORITY INCREMENT
	RPTEVT	PFCOM			; REPORT PAGE FAULT COMPLETE
;
; IRP$W_BOFF WAS INCREMENTED IF ANY OF THE PAGES HAD THE COLLISION BIT SET
;
;	R7 = NON ZERO IF SUPPOSED TO ISSUE KERNEL AST
;	     USED ONLY FOR PAGE WRITE COMPLETION
;	     BUT MUST BE ZERO FOR PAGE READ COMPLETION
;
PAGIO_DONE2:
	TSTW	IRP$W_BOFF(R6)		; ANY PAGES WITH COLLISION BIT SET?
	BEQL	60$			; BRANCH IF NOT
	PUSHL	R4			; SAVE PCB ADDRESS
40$:	TSTW	W^SCH$GQ_COLPGWQ+WQH$W_WQCNT ; ANYONE WAITING?
	BLEQ	50$			; BRANCH IF NOT
	MOVL	W^SCH$GQ_COLPGWQ,R4	; GET NEXT PCB
	RPTEVT	COLPGA			; REPORT "COLLISION PAGE AVAILABLE"
	BRB	40$			; REPEAT UNTIL QUEUE IS EMPTY
50$:	POPR	#^M<R4>			; RESTORE SAVED PCB ADDRESS
60$:	SETIPL	#IPL$_IOPOST		; LOWER TO I/O POST LEVEL
	TSTL	R7			; EXHAUSTED PAGE COUNT NON-ZERO?
	BNEQ	PAGIO_KAST		; BRANCH IF YES, COMPLETE I/O IN PROCESS
	BLBC	IRP$L_IOST1(R6),PAGIO_ERR ; BRANCH IF MORE ERROR PROCESSING TO DO
	MOVL	R6,R0			; GET PACKET ADDRESS FOR RELEASE
	MOVQ	(SP)+,R6		; RESTORE SAVED REGISTERS
;
; R0 = I/O REQUEST PACKET ADDRESS
;
PAGIO_ERR_DONE:
	BSBW	EXE$DEANONPAGED		; AND RELEASE IT
	MOVZWL	#RSN$_ASTWAIT,R0	; SET AST WAIT RESOURCE WAIT NUMBER
	BSBW	SCH$RAVAIL		; SET RESOURCE AVAILABLE
	BRW	IOPOST			; CONTINUE TO PROCESS POST QUEUE
;
; COMPLETE THE PAGE WRITE IN THE PROCESS CONTEXT
;
PAGIO_KAST:
	MOVL	R6,R5			; I/O PACKET ADDRESS BACK TO NORMAL REG
	MOVQ	(SP)+,R6		; RESTORE SAVED REGISTERS
	MOVL	IRP$L_PID(R5),R1	; PROCESS ID FOR ISSUING KERNEL AST
	MOVAB	MMG$UPDSECAST,ACB$L_KAST(R5) ; ADDRESS TO START KERNEL AST
	MOVZBL	#PRI$_IOCOM,R2		; PRIORITY INCREMENT
	BRW	IOPOST_KAST		; ISSUE THE KERNEL AST
;
; PAGE READ ERROR - CLEAN UP LOGIC
;
;	R3 = PTE ADDRESS OF BAD PAGE
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS
;	R6 = I/O REQUEST PACKET ADDRESS
;	R7 = 0 AND MUST BE PRESERVED
;	IRP$L_AST(R6) = PROCESS PTE ADR OF BAD PAGE IF GLOBAL PAGE
;	IRP$L_ASTPRM(R6) = GPTX FOR START OF TRANSFER IF GLOBAL CRF
;
PAGRD_ERR:
	BSBW	PFN_IO_DONE		; COMPLETE THE I/O FOR ERR PAGE
	MOVB	#<PFN$M_DELCON ! PFN$C_RDERR>,- ; SET PAGE TO
		@W^PFN$AB_STATE[R0]	; READ ERROR STATE
	MOVL	IRP$L_ASTPRM(R6),R1	; GET BACKING STORE ADR IF CRF
	BEQL	120$			; BRANCH IF NOT COPY ON REFERENCE
	BBC	#PFN$V_GBLBAK,R1,100$	; BRANCH IF NOT GLOBAL CRF
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; ADJUST GPTX BY
		IRP$L_IOST1+2(R6),R2	; TRANSFERRED PAGE COUNT
	ADDL	R2,R1			; TO GET CORRECT GPTX FOR BAD PAGE
	ADDL3	#1,R1,IRP$L_ASTPRM(R6)	; SET GPTX FOR START OF NEXT TRANSFER
100$:	MOVL	R1,@W^PFN$AL_BAK[R0]	; FIX BACKING STORE ADDRESS
120$:	TSTL	IRP$L_AST(R6)		; IF GLOBAL PAGE (NOT CRF)
	BGEQ	140$
	ADDL	#4,IRP$L_AST(R6)	; THEN SKIP OVER PROCESS PTE ADR
140$:	TSTW	@W^PFN$AW_REFCNT[R0]	; IS THIS THE LAST REFERENCE?
	BGTR	160$			; BRANCH IF NOT
	TSTW	@W^PFN$AW_SWPVBN[R0]	; IF THIS PROCESS HAS BEEN SWAPPED OUT
	BEQL	150$
	MOVZBL	#PFN$C_BADPAGLST,R2	; THEN PUT THIS PAGE IN LIMBO
	BSBW	MMG$INSPFNT		; ON THE BAD PAGE LIST
	BRB	160$
150$:	BSBW	MMG$RELPFN		; OTHERWISE RELEASE THE PAGE
160$:	BRW	PAGIO_DONE		; COMPLETE THIS PORTION OF THE PAGE READ
;
; DO THE REMAINING SEGMENT OF THE I/O FOR A PAGE READ OR WRITE ERROR
; SKIP OVER THE PORTION THAT WAS TRANSFERRED SUCCESSFULLY AND SKIP OVER
; THE PAGE IN ERROR WHICH WAS DEALT WITH BY EITHER PAGRD_ERR OR
; PAGWRT_ERR AND SET UP TO TRANSFER THE REMAINING PAGES IF ANY.
; NOTE THAT FOR PAGE WRITE ERRORS THE REST OF THE TRANSFER IS NOT DONE
; IF I/O COMPLETION STATUS IS RETURNED TO THE PROCESS.
;
PAGIO_ERR:
	MOVL	R6,R5			; IRP ADDRESS
	MOVQ	(SP)+,R6		; RESTORE ADDITIONAL SAVED REGISTERS
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; GET PAGE COUNT TRANSFERRED
		IRP$L_IOST1+2(R5),R1
	INCL	R1			; COUNT THE ERROR PAGE AS DONE
	ROTL	#9,R1,R0		; BYTE COUNT COMPLETED
	SUBL	R0,IRP$L_OBCNT(R5)	; BYTE COUNT REMAINING
	BEQL	40$			; BRANCH IF NOTHING LEFT TO DO
	CLRL	IRP$L_ABCNT(R5)		; ZERO ACCUMULATED BYTE COUNT

	CLRW	IRP$W_BOFF(R5)		; ZERO BOFF AND
	MOVL	IRP$L_OBCNT(R5),-
		IRP$L_BCNT(R5)		; SET NEW BYTE COUNT
	INCL	IRP$L_SEGVBN(R5)	; SEGMENT VBN WAS POINTING AT ERROR VBN
	MOVL	IRP$L_DIAGBUF(R5),R3	; STARTING SVAPTE OF ENTIRE TRANSFER
	MOVAL	(R3)[R1],IRP$L_DIAGBUF(R5) ; STARTING PTE ADDRESS OF THIS SEGMENT

	.IF	DF,CA$_MEASURE_IOT
	PUSHL	R3			;REMEMBER SVAPTE
	MOVL	R5,R3			;SET ADR OF IRP
	BSBW	PMS$START_RQ		; INSERT START OF I/O REQUEST MESSAGE
	POPL	R3			;RESTORE SVAPTE
	.ENDC

	BRW	QNXTSEG			; QUEUE THIS SEGMENT AND RETURN TO IOPOST
40$:	MOVL	R5,R0			; I/O PACKET ADDRESS
	BRW	PAGIO_ERR_DONE
;
; PAGE WRITE ERROR - CLEAN UP LOGIC
;
;	R3 = PTE ADDRESS FOR ERROR PAGE
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS
;	R6 = I/O REQUEST PACKET ADDRESS
;	R7 = 0 IF ALL COMPLETION LOGIC IS DONE IN IOPOST
;	   = NON-ZERO IF COMPLETION (AND ERROR REPORT) ARE TO BE
;	     RETURNED TO THE PROCESS.
;
PAGWRT_ERR1:
	PUSHL	R7			; SAVE KERNEL AST FLAG
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; PAGE COUNT TRANSFERRED
		IRP$L_IOST1+2(R6),R0
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; ORIGINAL PAGE COUNT
		IRP$L_OBCNT(R6),R7
	SUBL	R0,R7			; COUNT OF REMAINING PAGES
	TSTL	(SP)			; IF NOT REPORTING ERROR TO PROCESS
	BNEQ	20$
	MOVL	#1,R7			; ONLY CLEAN UP THE ERROR PAGE HERE
					; REST OF TRANSFER WILL BE DONE BY PAGIO_ERR
20$:	CLRL	-(SP)			; INIT "ERROR PAGE" FLAG
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,(R3),R0 ;GET PFN FROM PTE
	CMPL	R0,MMG$GL_MAXPFN	;IS THIS PAGE IN SHARED MEMORY?
	BGTRU	130$			;BR IF PAGE IN SH MEM, NO PFN DATABASE
70$:	PUSHL	R3			; SAVE SVAPTE
	BSBW	PFN_IO_DONE		; COMPLETE I/O FOR THIS PAGE
	BBSS	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],80$ ; FORCE MODIFY BIT
80$:
;
; CONDITION CODES STILL SET FROM DECREF AT END OF PFN_IO_DONE
;
	BGTR	120$			; BRANCH IF NOT THE LAST REFERENCE
	BBSS	#0,4(SP),100$		; BRANCH IF NOT ERROR PAGE
;
; THIS IS THE PAGE THAT HAD THE WRITE ERROR
;
	MOVL	#PFN$C_BADPAGLST,R2	; PUT IT ON THE BAD PAGE LIST
	BSBW	MMG$INSPFNT		; WITH "MODIFY" SET AND "BAD" CLEAR
	BRB	120$
100$:	BSBW	MMG$RELPFN		; NO MORE REFERENCES, RELEASE THE PAGE
120$:	ADDL3	#4,(SP)+,R3		; NEXT PTE ADDRESS
	SOBGTR	R7,70$
130$:	POPR	#^M<R0,R1>		;CLEAN OFF BAD PAGE FLAG
					; R1 = SAVED KERNEL AST INDICATOR
	MOVL	R1,R7			; PUT IT IN R7, SET CONDITION CODES
	BRW	PAGWRT_ERR_DONE
;
; PFN_IO_DONE
;
; INPUTS:
;
;	R3 = SVAPTE
;	R4 = PROCESS CONTROL BLOCK ADDRESS OF PROCESS THAT REQUESTED THE I/O
;	R5 = PROCESS HEADER OF THE PROCESS THAT REQUESTED THIS I/O
;	R6 = I/O REQUEST PACKET ADDRESS
;
; OUTPUTS:
;
;	R0 = PFN
;	R3 PRESERVED
;	IRP$W_BOFF(R6) INCREMENTED IF THIS WAS A COLLISION PAGE
;	CONDITION CODES SET FROM DECW @W^PFN$AW_REFCNT[R0]
;
PFN_IO_DONE:
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,(R3),R0 ; GET PAGE FRAME NUMBER
	BICB3	#^C<PFN$M_COLLISION ! PFN$M_PAGTYP>,- ; FETCH THESE
		@W^PFN$AB_TYPE[R0],R1	; BITS FROM PFN TYPE BYTE
	BBCC	#PFN$V_COLLISION,R1,20$	; CLEAR COLLISION BIT, BRANCH IF WAS CLEAR
	BICB	#PFN$M_COLLISION,@W^PFN$AB_TYPE[R0] ; CLEAR IT IN PFN DATA
	INCW	IRP$W_BOFF(R6)		; MUST EMPTY THE COLLISION QUEUE
20$:	CMPB	R1,#PFN$C_PPGTBL	; IF PROCESS PAGE TABLE PAGE
	BNEQ	40$
	MOVZWL	PHD$W_PHVINDEX(R5),R1	; MUST COUNT ONE LESS
	BSBW	MMG$DECPHDREF1		; PROCESS HEADER REFERENCE
40$:	DECREF				; ONE LESS REFERENCE FOR THE PAGE
	RSB				; RETURN WITH CONDITION CODES SET
					; TO NEW STATE OF THE REFCNT



	.SBTTL	VIRTUAL I/O COMPLETION
;
; VIRTUAL I/O COMPLETION
;
; CALLING SEQUENCE:
;
;	BRW	VIRTUAL
;
; INPUTS:
;
;	R1 = REQUESTED BYTE COUNT, POSSIBLY DIFFERENT FROM TRANSFERRED
;	     BYTE COUNT FOR MAGTAPE
;	R2 = IRP$W_BOFF CONTENTS
;	R3 = SVAPTE OF START OF TRANSFER
;
; OUTPUTS:
;
;	BRANCHES TO UNLOCK, PRESERVING R1,R2,R3
;	OR BRANCHES TO IOPOST
;

	.ENABL	LSB

VIRTUAL:				; VIRTUAL I/O FUNCTION
	TSTW	IRP$L_OBCNT+2(R5)	; SEE IF BYTE COUNT > 64K
	BEQL	1$			; EQL IMPLIES NO, BRANCH TO OLD CODE
	MOVL	IRP$L_IOST1+2(R5),R0	; ELSE PICKUP LONGER COUNT

	ADDL	R0,IRP$L_ABCNT(R5)	; ACCUMULATE TOTAL BYTES TRANSFERED
	ASHL	#-VA$S_BYTE,R0,R0	; CALCULATE NUMBER OF BLOCKS TRANSFERED
	ADDL	R0,IRP$L_SEGVBN(R5)	; CALCULATE DISK ADDRESS OF NEXT SEGMENT
	MOVL	IRP$L_ABCNT(R5),-
		IRP$L_IOST1+2(R5)	; SET ACCUMULATED BYTES TRANSFERED
	BRB	3$			; REJOIN COMMON CODE
1$:
	MOVZWL	IRP$L_IOST1+2(R5),R0	; GET ACTUAL NUMBER OF BYTES TRANSFERED
	ADDL	R0,IRP$L_ABCNT(R5)	; ACCUMULATE TOTAL BYTES TRANSFERED
	ASHL	#-VA$S_BYTE,R0,R0	; CALCULATE NUMBER OF BLOCKS TRANSFERED
	ADDL	R0,IRP$L_SEGVBN(R5)	; CALCULATE DISK ADDRESS OF NEXT SEGMENT
	MOVW	IRP$L_ABCNT(R5),-	; *NOTE MOVW DUE TO CODE PATH THAT
		IRP$L_IOST1+2(R5)	;  INSURES  < 64K BYTE TRANSFER
					; SET ACCUMULATED BYTES TRANSFERED
3$:
	BLBC	IRP$L_IOST1(R5),20$	; IF LBC I/O ERROR
	MOVL	IRP$L_UCB(R5),R0	; GET ADDRESS OF DEVICE UCB
	BBS	S^#DEV$V_SQD,UCB$L_DEVCHAR(R0),10$ ; IF SET, SEQUENTIAL DEVICE
	SUBL3	IRP$L_ABCNT(R5),-
		IRP$L_OBCNT(R5),-	; CALCULATE BYTES REMAINING
		IRP$L_BCNT(R5)		;
	BEQL	10$			; IF EQL NONE
	ASHL	#-VA$S_BYTE,R1,R1	; CALCULATE NUMBER OF PAGES REQUESTED
QNXTSEG:
	INCL	W^PMS$GL_SPLIT		; COUNT A SPLIT TRANSFER
	MOVAL	(R3)[R1],IRP$L_SVAPTE(R5) ; SET ADDRESS OF NEXT PTE ENTRY
	MOVL	R5,R3			; COPY I/O REQUEST PACKET ADDRESS
	MOVL	IRP$L_UCB(R3),R5	; GET ADDRESS OF DEVICE UCB
	BSBB	IOC$QNXTSEG		; QUEUE THE NEXT VIRTUAL SEGMNET
5$:	BRW	IOPOST
;
; ALL SEGMENTS OF THIS TRANSFER ARE COMPLETE
;
10$:
	MOVL	IRP$L_OBCNT(R5),R1	; GET ORIGINAL BYTE COUNT
	MOVL	IRP$L_DIAGBUF(R5),R3	; GET ORIGINAL PAGE TABLE ADDRESS
	BRW	UNLOCK			;
 
;
; I/O OPERATION ENDED WITH AN UNSUCCESSFUL STATUS
;
;		IF THE DEVICE IS A SEQUENTIAL DEVICE, THEN THE I/O PACKET IS
;		MERELY SENT TO THE ACP FOR NOTIFICATION OF THE ERROR.
;
;		IF THE DEVICE IS A RANDOM DEVICE, THEN THE VIRTUAL BLOCK NUMBER
;		STORED IN IRP$L_SEGVBN IS THE BLOCK THAT HAS AN ERROR.
;
 
20$:	MOVL	R5,R3			; COPY IRP ADDRESS
	DECW	PCB$W_DIOCNT(R4)	; ADJUST DIRECT I/O COUNT
	BICW	#IRP$M_VIRTUAL,IRP$W_STS(R3) ; CLEAR VIRTUAL I/O FLAG
	MOVL	IRP$L_DIAGBUF(R3),IRP$L_SVAPTE(R3) ; RESET PAGE TABLE ADDRESS
	MOVL	IRP$L_OBCNT(R3),R2	; GET ORIGINAL BYTE COUNT
	BSBB	IOC$QTOACP		; QUEUE PACKET TO ACP
	BRB	5$

	.DSABL	LSB

	.SBTTL	QUEUE NEXT SEGMENT
;
; FUNCTIONAL DESCRIPTION:
;
;	IOC$QNXTSEG PERFORMS THE FUNCTION OF QUEUEING THE NEXT
;	SEGMENT OF A VIRTUAL I/O REQUEST THAT DID NOT MAP TO A
;	SINGLE CONTIGUOUS I/O REQUEST.
;
; CALLING SEQUENCE:
;
;	BSBW	IOC$QNXTSEG
;
; INPUTS:
;
;	R3 = I/O REQUEST PACKET ADDRESS
;	R4 = PCB ADDRESS ASSOCIATED WITH THE PID IN THE PACKET
;	R5 = UCB ADDRESS OF THE ASSOCIATED DEVICE
;
; OUTPUTS:
;
;	R4 NOT PRESERVED
;
IOC$QNXTSEG::
	MOVL	IRP$L_WIND(R3),R2	; GET ADDRESS OF MAPPING WINDOW
	MOVL	IRP$L_BCNT(R3),R1	; GET SIZE OF NEXT SEGMENT
	MOVL	IRP$L_SEGVBN(R3),R0	; GET STARTING VIRTUAL BLOCK NUMBER
;
; ALTERNATE ENTRY TO IOC$QNXTSEG:
;
;	BSBW	IOC$QNXTSEG1
;
; ADDITIONAL INPUTS:
;
;	R0 = VIRTUAL BLOCK NUMBER OF START OF NEXT SEGMENT
;	R1 = DESIRED BYTE COUNT OF NEXT SEGMENT
;	R2 = WINDOW ADDRESS
;
IOC$QNXTSEG1::
	DECW	PCB$W_DIOCNT(R4)	; ADJUST THE DIRECT I/O COUNT
	BSBW	IOC$MAPVBLK		; MAP VIRTUAL TO LOGICAL BLOCK
	MOVL	R5,IRP$L_UCB(R3)	; STORE POSSIBLY MODIFIED UCB ADDRESS
	SUBL	R2,IRP$L_BCNT(R3)	; CALCULATE SIZE OF NEXT SEGMENT
	BEQL	30$			; IF EQL TOTAL MAP FAILURE
	MOVL	R1,R0			; COPY STARTING LOGICAL BLOCK NUMBER
	MOVL	IRP$L_BCNT(R3),R2	; GET TRANSFER BYTE COUNT
	DECL	R2			; ROUND DOWN AND...
	ASHL	#-VA$S_BYTE,R2,R2	; SHIFT DOWN FOR BLOCK COUNT - 1
	ADDL	R1,R2			; COMPUTE ENDING BLOCK NUMBER
	BCS	25$			; BRANCH ON OVERFLOW
	CMPL	R2,UCB$L_MAXBLOCK(R5)	; AND CHECK AGAINST DEVICE SIZE
	BGEQU	25$			; BRANCH IF NOT LEGAL
	BSBW	IOC$CVTLOGPHY		; CONVERT LOGICAL TO PHYSICAL BLOCK
	BRW	EXE$INSIOQ		; INSERT I/O PACKET IN DEVICE QUEUE
					; AND RETURN
;
; TO HERE IF THE VIRTUAL BLOCKS MAP OFF THE END OF THE VOLUME. COMPLETE THE
; I/O WITH AN ERROR. WE QUEUE THE PACKET FOR PROCESSING, RATHER THAN WANDERING
; OFF INTO THE COMPLETION CODE BECAUSE THIS IS A GENERALLY CALLABLE ROUTINE.
;
25$:	MOVZWL	#SS$_ILLBLKNUM,IRP$L_IOST1(R3) ; SET ILLEGAL BLOCK NUMBER STATUS
	CLRL	IRP$L_IOST2(R3)		; ZERO 2ND I/O STATUS LONGWORD
	INSQUE	(R3),@IOC$GL_PSBL	; INSERT AT TAIL OF I/O POST QUEUE
	BNEQ	26$			; BRANCH IF NOT EMPTY
	SOFTINT	#IPL$_IOPOST		; WAKE UP I/O COMPLETION
26$:	RSB

30$:
;
; ALTERNATE ENTRY TO IOC$WAKACP:
;
;	BSBW	IOC$QTOACP
;
; INPUTS:
;
;	R2 = DESIRED BYTE COUNT
;	R3 = IRP ADDRESS
;	PCB$W_DIOCNT(R4) ALREADY DECREMENTED
;
IOC$QTOACP:
	MOVL	R2,IRP$L_BCNT(R3)	; SET REMAINING BYTES TO TRANSFER
	MOVL	IRP$L_WIND(R3),R2	; GET WINDOW ADDRESS
	BBS	#WCB$V_NOTFCP,WCB$B_ACCESS(R2),- ; IF SET THEN
		NOTFCPWCB		; NOT FCP WINDOW
	MOVL	IRP$L_UCB(R3),R2	; GET ADDRESS OF DEVICE UCB
;
; FUNCTIONAL DESCRIPTION:
;
;	SUBROUTINE TO QUEUE AN I/O PACKET FOR AN ACP PROCESS AND WAKE
;	THE PROCESS IF ITS QUEUE WAS PREVIOUSLY EMPTY.
;
; CALLING SEQUENCE:
;
;	BSBW	IOC$WAKACP
;
; INPUTS:
;
;	R2 = DEVICE UCB ADDRESS
;	R3 = I/O REQUEST PACKET ADDRESS
;
; OUTPUTS:
;
;	R4 ALTERED
;
IOC$WAKACP::				; QUEUE I/O PACKET AND WAKE ACP PROCESS
	DSBINT	#IPL$_SYNCH		; SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVL	UCB$L_VCB(R2),R2	; GET ASSOCIATED VCB ADDRESS
	MOVL	VCB$L_AQB(R2),R2	; GET ACP QUEUE BLOCK ADDRESS
	BSBW	EXE$INSERTIRP		; INSERT I/O PACKET IN ACP QUEUE
	BNEQ	10$			; IF NEQ NOT FIRST IN QUEUE
	MOVL	AQB$L_ACPPID(R2),R1	; GET ACP PROCESS ID
	BSBW	SCH$WAKE		; WAKE ACP PROCESS
	BLBS	R0,10$			; IF LBS ACP STILL PRESENT
	BUG_CHECK NONEXSTACP		; NONEXISTENT ACP PROCESS
10$:	ENBINT				; RESTORE SAVED IPL
	RSB				;
;
; WINDOW IS NOT AN FCP WINDOW, ONLY USED FOR BOOT TIME INTIALIZED WINDOWS
; FOR CONTIGUOUS FILES.  IT IS NOT POSSIBLE TO NEED TO TURN SUCH A WINDOW.
;
NOTFCPWCB:
	BUG_CHECK NOTFCPWCB,FATAL

	.SBTTL	BUFFERED READ COMPLETION AST ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	BUFPOST PERFORMS ALL NECESSARY COMPLETION OPERATIONS REQUIRED
;	FOR A BUFFERED READ OPERATION IN THE CONTEXT OF THE PROCESS
;	ISSUING THE I/O REQUEST.
;
; CALLING SEQUENCE:
;
;	JSB	BUFPOST
;
; INPUT PARAMETERS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = IRP/AST CONTROL BLOCK.
;
; IMPLICIT INPUTS:
;
;	SCH$GL_CURPCB - POINTER TO PCB OF CURRENT PROCESS
;--

BUFPOST:				; BUFFERED READ COMPLETION
	PUSHR	#^M<R5,R6,R7>		; SAVE REGISTERS
	MOVL	IRP$L_SVAPTE(R5),R6	; GET ADDRESS OF I/O BUFFER
	MOVL	IRP$L_BCNT(R5),R7	; GET COUNT OF BYTES OR DESCRIPTORS
	BBC	#IRP$V_COMPLX,IRP$W_STS(R5),40$ ;IF CLR, NOT COMPLEX BUFFER FORMAT
	BBS	#IRP$V_CHAINED,IRP$W_STS(R5),50$ ;IF SET ,CHAINED BUFFERS
	MOVL	(R6),R6			; GET ADDRESS OF FIRST BUFFER DESCRIPTOR
10$:	MOVZWL	2(R6),R0		; GET COUNT OF BYTES TO TRANSFER
	BEQL	30$			; IF EQL NONE THIS DESCRIPTOR
	MOVL	4(R6),R1		; GET ADDRESS OF USER BUFFER
	ADDL	R1,R0			; CALCULATE ENDING ADDRESS OF BUFFER
	BICW	#VA$M_BYTE,R1		; TRUNCATE ADDRESS TO PAGE BOUNDARY
	SUBL	R1,R0			; COMPUTE NUMBER OF BYTES TO PROBE
	MOVZWL	(R6),R4			; GET OFFSET TO DATA AREA
	CVTWL	#-^X200,R3		; SET ADDITION CONSTANT
20$:	IFNOWRT	R0,(R1),35$,(R6)[R4]	; CAN BUFFER BE WRITTEN?
	SUBL	R3,R1			; UPDATE ADDRESS OF BUFFER
	MOVAW	(R0)[R3],R0		; UPDATE REMAINING LENGTH
	BGTR	20$			; IF GEQ MORE TO CHECK
	MOVC	2(R6),1(R6)[R4],@4(R6)	; MOVE DATA TO USER BUFFER
	MOVL	(SP),R5			; RESTORE ADDRESS OF I/O PACKET
30$:	ADDL	#8,R6			; ADVANCE TO NEXT BUFFER DESCRIPTOR
	SOBGTR	R7,10$			; ANY MORE DESCRIPTORS TO PROCESS?
	BRW	130$			;
35$:	BRB	120$			; CONTINUE
40$:	BSBW	MOVBUF			; MOVE BUFFER TO USER
	MOVL	(SP),R5			; RETRIEVE ADDRESS OF I/O PACKET
	BBC	#IRP$V_MBXIO,IRP$W_STS(R5),130$; BR IF NOT MAILBOX READ
	MOVZBL	#RSN$_MAILBOX,R0	; SET UP RESOURCE RELEASE
	BSBW	SCH$RAVAIL		; DECLARE MAILBOX RESOURCE AVAILABLE
	BRB	130$			;

;
; NB: THE FOLLOWING SECTION OF CODE USES A WORD-SIZE BUFFER LENGTH
;     (ALTHOUGH IRP$L_BCNT WAS EXPANDED TO BE A LONGWORD).  
;
50$:	MOVL	R7,R0			; SET LENGTH OF USER BUFFER
	MOVL	4(R6),R1		; SET ADDRESS OF USER BUFFER
	ADDL	R1,R0			; CALCULATE END OF USER BUFFER
	BICW	#VA$M_BYTE,R1		; TRUNCATE TO PAGE BOUNDARY
	SUBL	R1,R0			; COMPUTE NUMBER OF BYTES TO PROBE
	EXTZV	#0,#2,IRP$B_RMOD(R5),R2 ; GET REQUEST ACCESS MODE
	CVTWL	#-^X200,R3		; SET ADDITION CONSTANT
60$:	IFNOWRT	R0,(R1),90$,R2		; CAN BUFFER BE WRITTEN?
	SUBL	R3,R1			; UPDATE ADDRESS OF BUFFER
	MOVAW	(R0)[R3],R0		; CALCULATE NEW LENGTH
	BGTR	60$			; IF GEQ MORE TO PROBE
	MOVL	4(R6),R3		; GET STARTING ADDRESS OF USER BUFFER
70$:	CMPW	R7,CXB$W_LENGTH(R6)	; REMAINING LENGTH LARGER THAN DATA AREA?
	BGEQU	80$			; IF GEQU YES
	MOVW	R7,CXB$W_LENGTH(R6)	; TRUNCATE LENGTH OF DATA AREA
80$:	MOVC	CXB$W_LENGTH(R6),@(R6)+,(R3) ; MOVE DATA TO USER BUFFER
	MOVL	(SP),R5			; RETRIEVE ADDRESS OF I/O PACKET
	SUBW	CXB$W_LENGTH-4(R6),R7	; REDUCE REMAINING BYTES TO TRANSFER
	BEQL	100$			; IF EQL DONE
	MOVL	CXB$L_LINK-4(R6),R6	; GET ADDRESS OF NEXT BUFFER IN CHAIN
	BNEQ	70$			; IF NEQ MORE TO GO
	BRB	100$			;
90$:	BSBW	ACCVIO			; SET ACCESS VIOLATION
100$:	MOVL	IRP$L_SVAPTE(R5),R0	; GET ADDRESS OF FIRST BUFFER
110$:	MOVL	CXB$L_LINK(R0),R6	; GET ADDRESS OF NEXT BUFFER
	BEQL	140$			; IF EQL NONE
	BSBW	EXE$DEANONPAGED		; DEALLOCATE BUFFER
	MOVL	R6,R0			; SET ADDRESS OF NEXT BUFFER
	BRB	110$			;
120$:	BSBW	ACCVIO			; SET ACCESS VIOLATION STATUS
130$:	MOVL	IRP$L_SVAPTE(R5),R0	; GET ADDRESS OF BUFFER TO RELEASE
140$:	BSBW	EXE$DEANONPAGED		; DEALLOCATE BUFFER
	POPR	#^M<R5,R6,R7>		; RESTORE REGISTERS

	.SBTTL	DIRECT I/O COMPLETION AST ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	DIRPOST PERFORMS ALL GENERAL I/O COMPLETION ACTIVITIES WHICH
;	MUST BE DONE IN THE CONTEXT OF THE PROCESS. THESE INCLUDE
;	I/O STATUS POSTING IF AN IOSB WAS SPECIFIED, CHANNEL CONTROL
;	BLOCK ACTIVITY COUNT DECREMENTING, QUEUEING OF ANY REQUESTED
;	AST OR RELEASE OF THE I/O REQUEST PACKET.
;
; CALLING SEQUENCE:
;
;	JSB	DIRPOST
;
; INPUT PARAMETERS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = IRP/AST CONTROL BLOCK ADDRESS.
;
; IMPLICIT INPUTS:
;
;	SCH$GL_CURPCB - POINTER TO CURRENT PCB
;--

DIRPOST:				; DIRECT I/O POSTING AST
	EXTZV	#IRP$V_BUFIO,#1,IRP$W_STS(R5),R0 ; GET INDEX TO ACCOUNTING ENTRY
	MOVL	@#CTL$GL_PHD,R1		; GET PROCESS HEADER ADDRESS
	INCL	PHD$L_DIOCNT(R1)[R0]	; ACCOUNT FOR BUFFERED OR DIRECT I/O

	.IF NE	CA$_MEASURE		; CHECK FOR MEASUREMENT ENABLED
	INCL	PMS$GL_DIRIO[R0]	; UPDATE MEASUREMENT I/O COUNTER
	.ENDC

	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R5),10$ ; IF CLR, NO DIAGNOSTIC BUFFER
	PUSHR	#^M<R5,R6,R7>		; SAVE REGISTERS
	MOVL	IRP$L_DIAGBUF(R5),R6	; GET ADDRESS OF DIAGNOSTIC BUFFER
	MOVZWL	IRP$W_SIZE(R6),R7	; GET SIZE OF DIAGNOSTIC BUFFER
	SUBL	#12,R7			; REDUCE BY SIZE OF BUFFER HEADER
	BSBW	MOVBUF			; MOVE DIAGNOSTIC INFORMATION TO USER
	POPR	#^M<R5,R6,R7>		; RESTORE REGISTERS
	MOVL	IRP$L_DIAGBUF(R5),R0	; RETRIEVE ADDRESS OF DIAGNOSTIC BUFFER
	BSBW	EXE$DEANONPAGED		; DEALLOCATE DIAGNOSTIC BUFFER
10$:	CVTWL	IRP$W_CHAN(R5),R0	; GET CHANNEL NUMBER (NEGATED)
	MOVAB	@CTL$GL_CCBBASE[R0],R1	; SET CCB BASE ADDRESS
	DECW	CCB$W_IOC(R1)		; DECREMENT I/O COUNT FOR CHANNEL
	BNEQ	30$			; NOT IDLE YET
	MOVL	CCB$L_DIRP(R1),R3	; GET ADDRESS OF DEACCESS PACKET
	BEQL	30$			; IF EQL NONE
	CLRL	CCB$L_DIRP(R1)		; CLEAR ADDRESS OF DEACCESS PACKET
	INCW	CCB$W_IOC(R1)		; ACCOUNT FOR DEACCESS
	MOVL	CCB$L_UCB(R1),R2	; GET ASSIGNED DEVICE UCB ADDRESS
	BSBW	IOC$WAKACP		; QUEUE I/O PACKET AND WAKE ACP
					; R4 ALTERERED
30$:
;
; R4 DOES NOT NECESSARILY HAVE CURRENT PCB ADDRESS IN IT AT THIS POINT
;
IOC$DIRPOST1::
	MOVL	IRP$L_IOSB(R5),R0	; GET IOSB ADDRESS
	BEQL	35$			; IF EQL NONE SPECIFIED
	EXTZV	#0,#2,IRP$B_RMOD(R5),R1	; GET REQUEST ACCESS MODE
	IFNOWRT	#8,(R0),35$,R1		; CAN I/O STATUS BE WRITTEN?
	MOVQ	IRP$L_IOST1(R5),(R0)	; MOVE STATUS INTO IOSB
35$:	MOVL	IRP$L_PID(R5),R1	; PROCESS IDENTIFICATION
	CLRL	R2			; SET PRIORITY INCREMENT CLASS
	MOVZBL	IRP$B_EFN(R5),R3	; GET EVENT FLAG NUMBER
	BSBW	SCH$POSTEF		; AND POST IT
	BBS	#IRP$V_EXTEND,IRP$W_STS(R5),50$ ; BRANCH TO DEALLOCATE IRPE'S
37$:	BBC	#ACB$V_QUOTA,IRP$B_RMOD(R5),40$ ; IF CLR, NO AST SPECIFIED
	CLRL	R2			; SET NULL PRIORITY INCREMENT
	BRW	SCH$QAST		; QUEUE AST FOR REQUESTOR
40$:	MOVL	R5,R0			; SETUP ADDRESS FOR DEALLOCATE
	BRW	EXE$DEANONPAGED		; AND RELEASE I/O PACKET


	;
	; DEALLOCATE IRPE'S
	;

50$:	MOVL	IRP$L_EXTEND(R5),R0	; GET ADDRESS OF FIRST IRPE

60$:	CLRL	R4			; WILL HOLD ADDRESS OF NEXT IRPE
	BBC	#IRPE$V_EXTEND,IRPE$W_STS(R0),70$ ; BR. IF NO MORE IRPE'S
	MOVL	IRPE$L_EXTEND(R0),R4	; SAVE ADDRESS OF NEXT IRPE
70$:	BSBW	EXE$DEANONPAGED		; DEALLOCATE IRPE POINTED TO BY R0
	MOVL	R4,R0			; PUT ADDRESS OF NEXT IRPE IN R0
	BNEQ	60$			; BR. IF THERE IS ANOTHER IRPE
	BRB	37$			; DONE DEALLOCATING IRPE'S

	.SBTTL	MOVE DATA TO USER BUFFER
;
; SUBROUTINE TO MOVE DATA FROM A SIMPLE BUFFERED I/O BUFFER TO A USER BUFFER
;
 
MOVBUF:					; MOVE BUFFER
	MOVL	R7,R1			; SET LENGTH OF USER BUFFER
	BEQL	5$			; BR IF NULL STRING
	MOVL	4(R6),R0		; GET ADDRESS OF USER BUFFER
	EXTZV	#0,#2,IRP$B_RMOD(R5),R3 ; GET REQUEST ACCESS MODE
	JSB	EXE$PROBEW		; CHECK ACCESS
	BLBC	R0,ACCVIO		; IF LBC, NO ACCESS
	MOVC	R7,@(R6)+,@(R6)+	; MOVE DATA TO USER BUFFER
5$:	RSB				; RETURN
ACCVIO:	MOVW	#SS$_ACCVIO,IRP$L_IOST1(R5) ; SET FINAL TRANSFER STATUS
	RSB

	.SBTTL	UNLOCK AREAS IN IRPE'S
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UNLOCKS THE AREAS DESCRIBED BY FIELDS IN THE IRPE'S.  EACH
;	IRPE HAS SPACE TO HOLD TWO AREA DESCRIPTIONS.
;
; CALLING SEQUENCE:
;
;	BSBW	UNLOCK_MORE
;
; INPUT PARAMETERS:
;
;	R5 = I/O REQUEST PACKET ADDRESS
;
; SIDE EFFECTS:
;
;	R0 - R3 ARE NOT PRESERVED
;--

	ASSUME	IRP$L_EXTEND EQ IRPE$L_EXTEND

UNLOCK_MORE:
	PUSHL	R5			; SAVE IRP ADDRESS

10$:	; UNLOCK AREAS SPECIFIED IN NEXT IRPE

	MOVL	IRPE$L_EXTEND(R5),R5	; GET ADDRESS OF NEXT IRPE
	MOVL	IRPE$L_SVAPTE1(R5),R3	; GET SVAPTE OF FIRST AREA
	BEQL	20$			; BR. IF NOTHING TO UNLOCK
	MOVZWL	IRPE$W_BOFF1(R5),R2	; GET BYTE OFFSET IN PAGE
	MOVL	IRPE$L_BCNT1(R5),R1	; GET SIZE OF AREA
	BSBB	UNLK			; UNLOCK FIRST AREA

20$:	MOVL	IRPE$L_SVAPTE2(R5),R3	; GET SVAPTE OF SECOND AREA
	BEQL	30$			; BR. IF NOTHING TO UNLOCK
	MOVZWL	IRPE$W_BOFF2(R5),R2	; GET BYTE OFFSET IN PAGE
	MOVL	IRPE$L_BCNT2(R5),R1	; GET SIZE OF AREA
	BSBB	UNLK			; UNLOCK SECOND AREA

30$:	BBS	#IRPE$V_EXTEND,IRPE$W_STS(R5),10$ ; BR. IF THERE'S ANOTHER IRPE
	POPL	R5			; RESTORE R5
	RSB

	;
	; LOCAL SUBROUTINE TO UNLOCK PAGES
	;
	;	R1 = BYTE COUNT (OR SIZE OF AREA)
	;	R2 = BYTE OFFSET IN PAGE
	;	R3 = SVAPTE OF START OF AREA
	;

UNLK:	MOVAB	511(R1)[R2],R1		; COMBINE OFFSET AND SIZE AND ROUND
	ASHL	#-VA$S_BYTE,R1,R1	; CONVERT TO NUMBER OF PAGES TO UNLOCK
	BSBW	MMG$UNLOCK		; UNLOCK PAGES
	RSB


	.END
