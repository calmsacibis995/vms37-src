	.TITLE	PHDUTL - PROCESS HEADER UTILITIES
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, MEMORY MANAGEMENT UTILITIY ROUTINES
;
; ABSTRACT:
;
; ENVIRONMENT:	KERNEL MODE, RUNNING MOSTLY AT IPL ASTDEL WITH THE 
;	PROCESS HEADER LOCKED
;
;--
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 23-SEP-76
;
; MODIFIED BY:
;
;	V03-001	HRJ0062		Herb Jacobs		01-APR-1982
;		Fix a timing window problem in EXPANDPHD with SWAPPER.
;
;	V02-014	HRJ0027		Herb Jacobs		18-Aug-1981
;		Bump WSEXTENT on image exit with too small a working set.
;
;	V02-013	HRJ0025		Herb Jacobs		01-Aug-1981
;		Use common routine to release swap space at image rundown.
;
;	V02-012	HRJ0023		Herb Jacobs		01-Jul-1981
;		Release swap space allocation at image rundown.
;
;	V02-011	LJK0030		Lawrence J. Kenah	23-Jun-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V02-010	LJK0019		Lawrence J. Kenah	23-Jun-1981
;		Change page protection on process header pages from SRKW 
;		to ERKW to allow only protected access to header pages.
;
;	V02-009	HRJ0020		Herb Jacobs		27-Apr-1981
;		Change reference to PHD$W_WSSIZE for working set size.
;		Compress WSLAST over empties at image exit.
;
;	V02-008	ACG0177		Andrew C. Goldstein,	6-Jun-1980  14:08
;		Reset privilege mask in ARB at image exit
;
;	V02-007	RIH0001		Richard Hustvedt	5-May-1980
;		Compute dynamic working set entries in image reset to
;		correct problem decreasing the working set for on image
;		processes.
;
;	V02-006	KDM29916	Kathleen D. Morse	25-Apr-1980
;		Add another entry point, MMG$DALCSTXSCN1, for SYSCRMPSC calls.
;
;	V02-005	KDM0001		Kathleen D. Morse	16-Apr-1980
;		Fix comment line.
;
; 01	 -

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$ARBDEF				;ACCESS RIGHTS BLOCK DEFINITIONS
	$CCBDEF				;CHANNEL CONTROL BLOCK DEFINITIONS
	$IPLDEF				;PROCESSOR PRIORITY LEVELS
	$OPDEF				; DEFINE OPCODE EQUIVALENT VALUES
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINITIONS
	$PRTDEF				;PROTECTION CODE DEFINITIONS
	$PSLDEF				;PROCESSOR STATUS LONGWORD DEFINITIONS
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$SECDEF				;SECTION TABLE ENTRY DEFINITIONS
	$SSDEF				;SYSTEM STATUS DEFINITIONS
	$VADEF				;VIRTUAL ADDRESS VIELD DEFINITIONS
	$WCBDEF				;WINDOW CONTROL BLOCK DEFINITIONS
	$WSLDEF				;WORKING SET LIST DEFINITIONS
;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
;
; OWN STORAGE:
;

	.SBTTL	IMGRESET - IMAGE RESET, DELETE IMAGE PAGES

;++
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$IMGRESET
;		MUST BE CALLED FROM KERNEL MODE AT IPL = 0
;
;
; INPUT PARAMETERS:
;
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;
;	DELETES ALL PAGES IN P0 SPACE
;	DELETES ALL PAGES IN P1 SPACE EXCEPT THE FIXED PORTION
;	RESETS THE PROCESS SECTION TABLE
;	RESETS THE WORKING SET SIZE TO THE DEFAULT
;
;	R0 = ERROR STATUS CODE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$IMGRESET::
	PUSHL	R5			;PRESERVE R5
	MOVL	G^CTL$GL_PHD,R5		;R5=PHD ADDRESS
	BSBW	IAC$CLRIACLOCK		;CLEAR IMAGE ACTIVATOR INTERLOCK
	JSB	MMG$EXTRADYNWS		;FORCE EXTRA DYNAMIC WS COMPUTATION
	BSBW	RM$RESET		;RESET RMS CONTEXT
	BSBW	MMG$WSPEAKCHK		;ENABLE OR DISABLE WORKING SET PEAK CHECK
;
; DELETE P0 SPACE
;
10$:	CLRQ	-(SP)			;2 LONG WORDS FOR RANGE TO DELETE
	MOVL	SP,R2			;ADDRESSED BY R2
	MOVL	#<<1@30>-1>,(R2)	;STARTVA = TOP OF P0 SPACE
					;ENDVA = 0
	TSTL	PHD$L_FREP0VA(R5)	;IF NOTHING TO DELETE
	BEQL	25$			;DON'T CALL THE SERVICE
	$DELTVA_S INADR=(R2),ACMODE=#PSL$C_KERNEL ;DELETE P0 SPACE
	BLBC	R0,40$			;BRANCH IF ERROR
;
; DELETE P1 SPACE
;
25$:
	INCL	(R2)			;STARTVA = LOWEST P1 SPACE ADR
	SUBL3	#512,CTL$GL_CTLBASVA,4(R2)
					;ENDVA = HIGHEST P1 SPACE ADR
					;BELOW THE FIXED REGION
	CMPL	PHD$L_FREP1VA(R5),4(R2)	;IF P1 SPACE IS EMPTY
	BGEQ	30$			;SKIP THE DELETE SERVICE
	$DELTVA_S INADR=(R2),ACMODE=#PSL$C_KERNEL ;DELETE P1 SPACE
	BLBC	R0,40$			;BRANCH IF ERROR
	JSB	CHK_DBG_SYMTAB		;SEE IF ANY SYMBOL TABLE TO DELETE
	TSTL	R0			;IF ZERO, NONE TO DELETE
	BEQL	30$			;BRANCH IF NONE
	MOVL	#^X7FFFFFFF,4(R2)	;DELETE DEBUGGER SYMBOL TABLE
	MOVW	6(R2),2(R2)		;TOP 65K BYTES OF P1 SPACE
	$DELTVA_S INADR=(R2),ACMODE=#PSL$C_KERNEL ;DELETE DEBUG SYMBOL TABLE
	BLBC	R0,40$			;BRANCH IF ERROR
30$:	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL EXIT
	SUBW3	PHD$W_WSLIST(R5),PHD$W_DFWSCNT(R5),R1 ;SIZE OF DEFAULT WS-1
	INCW	R1			;REAL SIZE OF DEF WSL
	SUBW	PHD$W_WSSIZE(R5),R1	;MINUS NUMBER OF PAGES
	CVTWL	R1,R1			;TO CHANGE WORKING SET SIZE BY
	BEQL	40$			;BRANCH IF NO
35$:	$ADJWSL_S R1			;ADJUST THE WORKING SET LIMIT
40$:	CVTWL	PHD$W_EXTDYNWS(R5),R1	;ENOUGH EXTRA DYNAMIC WORKING SET
					;TO RUN A REASONABLE IMAGE?
	SUBL3	R1,#2,R1		;MAKE SURE WE CAN HAVE AT LEAST 2
					;MORE PAGE TABLES THEN CURRENTLY HAVE
	BLEQ	50$			;BRANCH IF GOT ENOUGH
;
; R1 IS THE NUMBER OF ADDITIONAL WORKING SET ENTRIES NEEDED
;
	ADDW3	PHD$W_WSSIZE(R5),PHD$W_WSLIST(R5),R2 ;GET END OF WS POINTER
	CMPW	R2,PHD$W_WSQUOTA(R5)	;IF WE ARE AT QUOTA
	BLEQU	35$			;BRANCH IF QUOTA SUPPORTS NEEDED
					;INCREASE IN WSSIZE
	ADDW	R1,PHD$W_WSQUOTA(R5)	;QUOTA IS ARTIFICIALLY LOW, RAISE IT
	CMPW	PHD$W_WSQUOTA(R5),PHD$W_WSEXTENT(R5) ;EXTENT MUST ALWAYS >= QUOTA
	BLEQU	35$			;BRANCH IF OK
	MOVW	PHD$W_WSQUOTA(R5),PHD$W_WSEXTENT(R5) ;BUMP EXTENT TO QUOTA
	BRB	35$			;AND ADD MORE PAGES TO WORKING SET

50$:	SETIPL	#IPL$_ASTDEL		;RAISE IPL AND
	BSBW	MMG$SECTBLRST		;RESET THE SECTION TABLE
	SETIPL	#0			;LOWER PRIORITY LEVEL
					;EMPTY PST FREE LIST
	MOVQ	G^CTL$GQ_PROCPRIV,(R5)	;SET DEFAULT PRIVILEGES
	MOVL	PCB$L_ARB(R4),R0	;GET ACCESS RIGHTS BLOCK ADDRESS
	MOVQ	(R5),ARB$Q_PRIV(R0)	;AND RESET COPY OF PRIVILEGE MASK
	CLRL	G^CTL$GL_IMGHDRBF	;NO CURRENTLY ACTIVE IMAGE
;
; SEE IF ANY GLOBAL SECTIONS TO BE DELETED AS A RESULT OF RELEASING THE
; PROCESS' ADDRESS SPACE
;
	MOVAL	@MMG$GL_SYSPHD,R5	;SYSTEM PROCESS HEADER ADDRESS
	BBC	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),60$ ;BRANCH IF NO GBL SECS TO DELETE?
	MOVAL	EXE$GL_GSDMTX,R0	;ADDRESS OF GLOBAL SECTION MUTEX
	BSBW	SCH$LOCKW		;LOCK THE MUTEX FOR WRITING
;
; RETURNS AT IPL = ASTDEL MITH MUTEX LOCKED FOR WRITING
;
	BSBB	MMG$DALCSTXSCN		;SCAN AND DELETE GLOBAL SECTIONS
	BSBW	MMG$GSDMTXULK		;RELEASE THE GLOBAL SECTION MUTEX
					;STAYS AT IPL = ASTDEL
	BSBW	MMG$DELGBLWCB		;DELETE ANY WINDOWS RELEASED
60$:	MOVL	G^CTL$GL_PHD,R5		;R5=PHD ADDRESS
	BSBW	MMG$COMPRESS		;SHRINK WSLAST BY WHATEVER WE CAN
					;RETURNS AT IPL 0
	POPR	#^M<R2,R3,R5>		;CLEAN OFF 8 BYTES INTO R2, R3
					;AND RESTORE R5
	RSB

; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
MMG$COMPRESS:
	SETIPL	#IPL$_SYNCH		;LOCK PAGING DATABASE
	MOVZWL	PHD$W_WSLAST(R5),R0	;GET POINTER TO END OF ACTIVE WS LIST
	ADDW3	PHD$W_WSSIZE(R5),PHD$W_WSLIST(R5),R1 ;SET MINIMUM SIZE OF WSL
	CMPW	R0,R1			;ARE WE ALREADY AT MINIMUM?
	BLSSU	100$			;BRANCH IF SO
	MNEGL	#1,R2			;SET UP FOR DECREMENT LOOP
70$:	TSTL	(R5)[R0]		;IS ENTRY EMPTY?
	BNEQ	80$			;BRANCH IF NOT
	ACBL	R1,R2,R0,70$		;LOOP THRU MAXIMUM POSSIBLE REDUCTION
80$:	CMPW	PHD$W_WSNEXT(R5),R0	;IS WSNEXT STILL IN RANGE
	BLEQU	90$			;BRANCH IF YES
	MOVW	R0,PHD$W_WSNEXT(R5)	;UPDATE TO SAFE PLACE
90$:	MOVW	R0,PHD$W_WSLAST(R5)	;RESET TO NEW MINIMUM END

100$:	BSBB	MMG$CALCSWAPSIZE	;FORM THE SIZE IN R2 OF MINIMUM SWAP AREA
	MOVL	PCB$L_WSSWP(R4),R0	;GET SWAP TYPE VBN OF ALLOCATION
	BEQL	120$			;BRANCH IF NON-SWAPPABLE PROCESS
	MOVZWL	PHD$W_SWAPSIZE(R5),R1	;SET SIZE OF CURRENT ALLOCATION
	CMPL	R1,R2			;IS CURRENT HOLDING CORRECT?
	BEQL	120$			;BRANCH IF SO
	BSBW	MMG$ALLOCSWPAREA	;ALLOCATE A SWAP AREA, R0-R3 CHANGED
	BLEQ	130$			;BRANCH IF THIS FAILED, IT CAN'T
	MOVL	R0,PCB$L_WSSWP(R4)	;UPDATE SWAP FILE VBN
	MOVW	R2,PHD$W_SWAPSIZE(R5)	;AND SIZE OF AREA
120$:	SETIPL	#0			;DROP BACK TO DESIRED IPL TO EXIT
	RSB				;RETURN

130$:	BUG_CHECK INSSWPFIL,FATAL	;BITMAP CONSISTENCY PROBLEM

MMG$CALCSWAPSIZE::
	ADDW3	PCB$W_PPGCNT(R4),PCB$W_GPGCNT(R4),R0 ;GET CURRENT PAGE COUNT
	MOVZWL	W^SWP$GW_SWPINC,R1	;ROUND UP TO NEXT GROUP
	CLRL	R2			;INIT COUNT FOR WHAT WE NEED BACK
110$:	ADDL	R1,R2			;BUMP OUR ALLOCATION AMOUNT
	CMPW	R0,R2			;IS OUR PHYSICAL SIZE BIGGER THAN THIS?
	BGTR	110$			;HANDLE CORRECT MULTIPLE OF 8 CASE
	RSB

	.SBTTL	CHK_DBG_SYMTAB - ANY DEBUG SYMBOL TABLE TO DELETE?
;
; INPUTS:
;
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE IS OK)
;
; OUTPUTS:
;
;	R0 = 0 IF DEBUG SYMBOL TABLE PAGE TABLE IS ALREADY EMPTY
;	   = NON ZERO IF DEBUG SYMBOL TABLE PAGE TABLE NEEDS TO BE DELETED
;	R1,R2,R3 PRESERVED
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
CHK_DBG_SYMTAB:
	SETIPL	#IPL$_SYNCH		;NO SWAPPING WHILE LOOKING AT SPT
	EXTZV	#VA$V_VPN,#VA$S_VPN,-	;SPT INDEX FOR FIRST
		PHD$L_P0BR(R5),R0	;PAGE TABLE PAGE
	ADDL	W^SGN$GL_PTPAGCNT,R0	; 
	DECL	R0			;INDEX TO LAST PAGE TABLE
	BICL3	#^C<PTE$M_VALID !-	;GET VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 !- ;PAGE TYPE BITS
		PTE$M_PGFLVB>,-		;AND BACKING STORE ADR OR PFN
		@W^MMG$GL_SPTBASE[R0],R0
					;FROM SPT ENTRY OF LAST PAGE TABLE
;
; WILL BE ZERO IF THE PAGE TABLE IS DEMAND ZERO
;
	SETIPL	#0			;RESET IPL
	RSB				;AND RETURN

	.SBTTL	DECSECREF - DECREMENT SECTION TABLE REFERENCE COUNT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DECREMENTS THE REFERENCE COUNT ON THE SECTION TABLE
; SPECIFIED.  IF THE REFERENCE COUNT GOES TO ZERO AND THE SECTION IS NOT
; PERMANENT, THEN THE SECTION DELETION LOGIC IS TRIGGERED.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DECSECREF
;	BSBW	MMG$SUBSECREF		;SUBTRACT R0 FROM SECTION REFERENCE COUNT
;
; INPUT PARAMETERS:
;
;	R0 = NUMBER OF REFERENCES TO SUBTRACT IF ENTERED AT SUBSECREF
;	R1 = SECTION TABLE INDEX
;	R5 = PROCESS HEADER ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
	.ENABL	LSB
MMG$SUBSECREF::
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R2 ;BASE ADDRESS OF SECTION TABLE
	SUBL	R0,SEC$L_REFCNT(R2)[R1]	;REDUCE THE REFERENCE COUNT
	BLEQ	10$			;BRANCH IF NO MORE REFERENCES
	RSB

MMG$DECSECREF::
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R2 ;BASE ADDRESS OF SECTION TABLE
	DECL	SEC$L_REFCNT(R2)[R1]	;COUNT ONE LESS SECTION REFERENCE
	BGTR	20$			;BRANCH IF SECTION IS STILL IN USE
10$:	BLSS	40$			;BRANCH IF COUNT WENT NEGATIVE
	ROTL	#<31-SEC$V_PERM>,SEC$W_FLAGS(R2)[R1],R2 ;PERMANENT BIT TO SIGN BIT
	BLSS	20$			;BRANCH IF SECTION PERMANENT
	BBSSI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),20$ ;NOTE SECTION TO BE DEALLOCATED
20$:	RSB
40$:	BUG_CHECK SECREFNEG,FATAL	;SECTION REFERENCE COUNT WENT NEGATIVE

	.DSABL	LSB

	.SBTTL	DALCSTXSCN - DEALLOCATE SECTION INDEX SCANNER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SCANS THE SECTION TABLE LOOKING FOR SECTIONS WITH
; ZERO REFERENCE COUNTS TO BE DEALLOCATED.  EACH SECTION FOUND IS UNCHAINED
; FROM ITS SECTION CHAIN, THE WINDOW IS RESTORED TO ITS CHANNEL IF THIS
; IS THE LAST SECTION IN THE CHAIN, AND FINALLY THE SECTION IS DEALLOCATED.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DALCSTXSCN
;
; INPUT PARAMETERS:
;
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE)
;	IPL = ASTDEL
;	GSD MUTEX LOCKED IF THIS IS THE SYSTEM PROCESS HEADER.  ONLY SECTIONS
;		THAT EXIST IN SYSTEM PROCESS HEADER ARE GLOBAL SECTIONS.
;		ALLOWABLE EXCEPTIONS MUST NEVER HAVE REFCNT=0.
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
	.ENABLE	LSB
MMG$DALCSTXSCN1::			;ENTRY POINT USED BEFORE GSDSCN REQUEST
	MOVL	MMG$GL_SYSPHD,R5	;GET SYSTEM PROCESS HEADER ADDRESS
MMG$DALCSTXSCN::
	BBCCI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),40$ ;BRANCH IF NOTHING TO SCAN FOR
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R3 ;BASE OF SECTION TABLE
	CVTWL	PHD$W_PSTLAST(R5),R1	;INDEX TO LAST SECTION ALLOCATED
20$:	TSTL	SEC$L_REFCNT(R3)[R1]	;DEALLOCATE THIS SECTION?
	BEQL	50$			;BRANCH IF NEED TO DEALLOCATE
30$:	ADDL	#SEC$C_LENGTH@-2,R1	;NEXT SECTION INDEX
	BLSS	20$			;BRANCH IF NOT AT END OF TABLE
40$:	RSB
;
; IF THIS IS NOT A PERMANENT SECTION, THEN NEED TO DEALLOCATE IT
;
50$:	ROTL	#<32-<SEC$V_PERM+1>>,SEC$W_FLAGS(R3)[R1],R2 ;PERMANENT BIT TO SIGN BIT
	BLSS	30$			;BRANCH IF PERMANENT SECTION
	BSBB	60$			;DO THE DEALLOCATE
	BRB	30$			;AND CONTINUE THE SCAN
;
; NEED TO DEALLOCATE PROCESS OR GLOBAL SECTION, RSB FROM HERE WHEN DONE
; MUST PRESERVE R1 AND R3
;
60$:	BBS	#<SEC$V_GBL+<32-<SEC$V_PERM+1>>>,R2,200$ ;BRANCH IF GLOBAL SECTION
	PUSHL	R1			;SAVE SECTION INDEX
	MOVL	SEC$L_CCB(R3)[R1],R2	;CHANNEL CONTROL BLOCK ADDRESS
	MOVL	SEC$W_SECXFL(R3)[R1],R0	;GET FORWARD AND BACKWARD SECTION INDEX LINKS
	BEQL	130$			;BRANCH IF UCB TYPE SECTION
	CMPW	R1,R0			;IF CURRENT = FORWARD, THIS IS THE LAST
	BNEQ	110$			;SECTION IN THE CHAIN
	MOVL	SEC$L_WINDOW(R3)[R1],CCB$L_WIND(R2) ;PUT WINDOW ADR BACK IN CHANNEL
	BRB	130$			;AND DEALLOCATE THE SECTION
110$:	CMPW	CCB$L_WIND(R2),R1	;IF SECTION INDEX IN CCB
	BNEQ	120$			;POINTS TO SECTION BEING DELETED
	MOVW	R0,CCB$L_WIND(R2)	;THEN POINT IT AT THE FORWARD LINK
120$:	ASHL	#-16,R0,R2		;BACKWARD SECTION INDEX
	MOVAL	(R3)[R2],R1		;ADR OF BACKWARD SECTION TABLE ENTRY
	MOVW	R0,SEC$W_SECXFL(R1)	;BAKSEC(FL) = CURSEC(FL)
	CVTWL	R0,R0			;FORWARD SECTION INDEX
	MOVAL	(R3)[R0],R1		;ADR OF FORWARD SECTION TABLE ENTRY
	MOVW	R2,SEC$W_SECXBL(R1)	;FORSEC(BL) = CURSEC(BL)
130$:	POPR	#^M<R1>			;RECOVER SECTION INDEX TO BE DEALLOCATED
	BRB	MMG$DALCSTX		;DEALLOCATE THE SECTION TABLE ENTRY
					;AND RETURN
;
; DEALLOCATE GLOBAL SECTION
;
200$:	PUSHR	#^M<R1,R3>		;SAVE SECTION TABLE BASE, SECTION INDEX
	MOVAL	(R3)[R1],R3		;ADDRESS OF SECTION TABLE ENTRY
	BBS	#SEC$V_SHMGS,SEC$W_FLAGS(R3),SHM_GS ;BR IF GS IS IN SHM
	JSB	MMG$DELGBLSEC		;DELETE THE GLOBAL SECTION
210$:	POPR	#^M<R1,R3>		;RESTORE SECTION TABLE BASE AND INDEX
	RSB
;
; THIS SECTION IS IN SHARED MEMORY.  CHECK IF IT IS READY TO BE DELETED.
; NOTE THAT ALL SHARED MEMORY GLOBAL SECTIONS MUST BE PERMANENT.  SINCE THIS
; ONE IS NOT PERMANENT, A $DGBLSC REQUEST MUST HAVE BEEN ISSUED FOR IT.
;
SHM_GS:
	BSBW	MMG$DELSHMGS		;CHECK IF SHM GS CAN BE DELETED
	BRB	210$			;CONTINUE SCAN

	.DSABL	LSB

	.SBTTL	DALCSTX - DEALLOCATE SECTION TABLE INDEX
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PLACES THE GIVEN SECTION TABLE ENTRY ON THE THE
; SECTION TABLE FREE LIST, TURNING ON THE SIGN BIT OF THE REFCNT LONG WORD
; AS AN INDICATION THAT IT IS NOT IN USE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DALCSTX
;
; INPUT PARAMETERS:
;
;	R1 = SECTION TABLE INDEX
;	R5 = PROCESS HEADER ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0,R1,R2,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$DALCSTX::
	ADDL3	PHD$L_PSTBASOFF(R5),R5,-(SP) ;BASE ADDRESS OF SECTION TABLE
	ADDL3	#SEC$L_REFCNT,(SP),-(SP) ;OFFSET TO REFERENCE COUNT
	MNEGL	#1,@(SP)+[R1]		;NEG REF COUNT MEANS NOT IN USE
	CVTWL	PHD$W_PSTFREE(R5),@(SP)+[R1] ;PUT FREE POINTER INTO THIS SECTION ENTRY
	MOVW	R1,PHD$W_PSTFREE(R5)	;AND THIS SECTION INDEX IN FREE POINTER
	RSB

	.SBTTL	ALCSTX - ALOCATE SECTION TABLE INDEX
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ALLOCATES A SECTION TABLE INDEX FROM THE
; SECTION TABLE BELONGING TO THE SPECIFIED PROCESS HEADER
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$ALCSTX
;
; INPUT PARAMETERS:
;
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS
;	IPL = ASTDEL
;		ASSUMPTION: ONLY GST IS ALLOCATED FROM THE SYSTEM HEADER
;		AND THE GLOBAL SECTION MUTEX IS LOCKED FOR WRITING WHEN
;		THIS IS DONE.  OTHERWISE, THE SYSTEM HEADER WOULD REQUIRE
;		IPL = SYNCH
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;	R1 = SECTION TABLE INDEX IF SUCCESSFUL
;	R2,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_SECTBLFUL			;SECTION TABLE FULL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$ALCSTX::
	CVTWL	PHD$W_PSTFREE(R5),R1	;SEE IF ANY SECTIONS ON FREE LIST
	BEQL	20$			;BRANCH IF NONE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R0 ;BASE ADDRESS OF SECTION TABLE
	CVTLW	(R0)[R1],PHD$W_PSTFREE(R5) ;REMOVE THIS SECTION FROM FREE LIST
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION
	RSB				;RETURN TO CALLER
;
; NEED TO ALLOCATE A NEW SECTION
;
20$:	MOVZBL	#SEC$C_LENGTH@-2,R1	;SPACE REQUIRED IN LONG WORDS
	PUSHR	#^M<R2,R3>		;PRESERVE THESE REGISTERS
	BSBB	MMG$ALCPHD		;TRY TO ALLOCATE PROCESS HEADER SPACE
	POPR	#^M<R2,R3>		;RESTORE SAVED REGISTERS
	BLBC	R0,40$			;BRANCH IF NOT ENOUGH SPACE AVAILABLE
	SUBW	R1,PHD$W_PSTLAST(R5)	;UPDATE LAST ALLOCATED PST INDEX
	CVTWL	PHD$W_PSTLAST(R5),R1	;SECTION INDEX
40$:	RSB

	.SBTTL	ALCPHD - ALLOCATE PROCESS HEADER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ALLOCATE SOME SPACE IN THE PROCESS HEADER
;	FOR EITHER A NEW SECTION TABLE ENTRY OR SOME NUMBER OF WORKING
;	SET LIST ENTRIES.  THE WORKING SET LIST ENTRIES GROW TOWARD LARGER
;	ADDRESSES FROM PHD$W_WSLAST.  THE SECTION TABLE GROWS FROM THE
;	HIGHEST ADDRESS TOWARD THE END OF THE WORKING SET.  WHEN THEY
;	MEET, IT IS POSSIBLE THAT THERE IS STILL MORE SPACE AVAILABLE IF
;	THE PROCESS SECTION TABLE BASE ADDRESS IS NOT EQUAL TO THE P0 PAGE
;	TABLE ADDRESS.  IN ORDER TO ALLOW THE SECTION TABLE TO BE EASILY
;	RELOCATED TO A HIGHER ADDRESS, ALL SECTION INDICES ARE NEGATIVE
;	LONG WORD INDICES FROM A SECTION BASE ADDRESS.  THIS ADDRESS IS
;	COMPUTED AS THE SUM OF THE PROCESS HEADER ADDRESS AND THE CONTENTS
;	OF PSTBASOFF.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$ALCPHD
;
; INPUT PARAMETERS:
;
;	R1 = NUMBER OF LONG WORDS REQUIRED
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE UNLESS SYSTEM PCB)
;	IPL = ASTDEL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;	R1 = PRESERVED IF SUCCESSFUL
;	   = NUMBER OF LONG WORDS AVAILABLE IF FAILED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		;SUCCESSFUL COMPLETION
;	SS$_SECTBLFUL		;SECTION TABLE FULL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$ALCPHD::
;
; ESTABLISH HOW MUCH ROOM IS AVAILABLE
;
10$:	CVTWL	PHD$W_PSTLAST(R5),R0	;SECTION INDEX TO LOWEST ADDRESSED SECTION
	ADDL3	R5,PHD$L_PSTBASOFF(R5),R2 ;P1 ADR OF END OF PROC SEC TAB
	MOVAL	(R2)[R0],R0		;LOWEST ADDRESS IN SECTION TABLES
	MOVZWL	PHD$W_WSLAST(R5),R2	;WSLX FOR LAST (INCLUSIVE) ENTRY
	MOVAL	4(R5)[R2],R2		;ADR OF FIRST AVAILABLE BYTE BEYOND WSL
	SUBL3	R2,R0,R2		;NO. OF BYTES AVAILABLE
	BLSS	ALCPHDBUG		;BRANCH IF OVERLAP, ERROR
	DIVL	#4,R2			;CONVERT TO LONG WORDS
	CMPL	R1,R2			;ENOUGH SPACE AVAILABLE
	BGTR	20$			;BRANCH IF NOT, TRY TO GET MORE
	MOVZWL	#SS$_NORMAL,R0		;INDICATE SUCCESSFUL COMPLETION
	RSB				;AND RETURN
;
; NEED TO EXPAND PROCESS HEADER IF POSSIBLE
; R0 = P1 SPACE ADDRESS OF LOWEST ADDRESSED SECTION TABLE ENTRY
; R1 = DESIRED LONG WORD COUNT
; R2 = NO. OF LONG WORDS AVAILABLE WITHOUT EXPANSION
;
20$:	PUSHR	#^M<R0,R1,R2>		;SAVE AVAIL, DESIRED, & LOWEST P1 ADRS
	CVTWL	PHD$W_PSTLAST(R5),R0	;GET OFFSET TO LAST SEC TBL ENTRY
	BSBB	MMG$SECTBLRST		;TRY TO COMPRESS SECTION TABLE
	CMPW	PHD$W_PSTLAST(R5),R0	;LAST SEC TBL ENTRY SAME AS BEFORE?
	BEQL	25$			;BR IF LAST ENTRY IS SAME AS BEFORE
	POPR	#^M<R0,R1,R2>		;RESTORE AVAIL, DESIRED, $ LOWEST P1
	BRB	10$			;TRY TO ALLOCATE SECTION NOW
25$:	POPL	R0			;RESTORE P1 ADR OF LOWEST SEC TBL ENTRY
	ROTL	#<32-2>,PHD$L_PSTBASOFF(R5),R1 ;LONG WORD OFFSET TO BASE OF PST
	CMPW	R1,PHD$W_PSTBASMAX(R5)	;AT MAX PST BASE?
	BGEQ	40$			;BRANCH IF YES, CANNOT EXPAND
	JSB	MMG$EXPANDPHD		;EXPAND PROCESS HEADER IF POSSIBLE
30$:	POPR	#^M<R1,R2>		;R1=DESIRED SPACE, R2=AVAILABLE SPACE
	BLBS	R0,10$			;IF EXPANDED OK, TRY TO ALLOCATE AGAIN
	MOVL	R2,R1			;OTHERWISE RETURN WHAT IS AVAILABLE
	RSB				;ALONG WITH ERROR CONDITION IN R0
40$:	MOVZWL	#SS$_SECTBLFUL,R0	;SECTION TABLE FULL
	BRB	30$

ALCPHDBUG:
	BUG_CHECK ALCPHD,FATAL
	.PAGE
	.SBTTL	SECTBLRST - RESET SECTION TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO COMPRESS THE SECTION TABLE PORTION OF THE
;	PROCESS HEADER.  IT WILL RESET THE POINTER TO THE LAST SECTION TABLE
;	USED IF SOME ENTRIES PREVIOUSLY IN USE ARE NO LONGER ALLOCATED.  THIS
;	ROUTINE IS CALLED AT IMAGE RESET TIME AND ALSO WHEN TRYING TO
;	EXPAND THE WORKING SET OR THE PROCESS SECTION TABLE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$SECTBLRST
;
; INPUT PARAMETERS:
;
;	R5 - PROCESS HEADER ADDRESS
;
; IMPLICIT INPUTS:
;
;	IPL = ASTDEL
;
; OUTPUT PARAMETERS:
;
;	R0,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; ****************************************************************************
;
; ********************** THE FOLLOWING CODE MAY BE PAGED ********************
;
	.PSECT	Y$EXEPAGED
;
; ****************************************************************************

MMG$SECTBLRST:

	CLRW	PHD$W_PSTFREE(R5)	;ASSUME ALL SECTIONS AVAILABLE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R2 ;BASE ADDRESS OF SECTION TABLE
	CVTWL	PHD$W_PSTLAST(R5),R1	;GET OFFSET TO LAST SEC TBL ENTRY USED
	BRB	30$			;ENTER SEARCH LOOP

20$:	TSTL	SEC$L_REFCNT(R2)[R1]	;ARE THERE PAGES STILL MAPPED TO SEC?
	BGEQ	40$			;BR ON YES, PAGE MAPPED OR BACKING STORE
	ADDL2	#SEC$C_LENGTH@-2,R1	;GET OFFSET TO NEXT SECTION TABLE ENTRY
30$:	BLSS	20$			;KEEP SEARCHING FOR SECTION IN USE
	CLRW	PHD$W_PSTLAST(R5)	;NO SECTION STILL IN USE
	RSB

40$:	MOVW	R1,PHD$W_PSTLAST(R5)	;FOUND FIRST SECTION STILL IN USE
	BRB	80$			;CONTINUE SEARCHING FOR MORE SECTIONS

;
; THE REMAINING SECTIONS ARE EITHER IN USE (REFCNT GEQ 0) OR DELETED
; (REFCNT LSS 0).  THE DELETED ONE MUST BE CHAINED ONTO THE FREE SECTION LIST.
;
60$:	TSTL	SEC$L_REFCNT(R2)[R1]	;IS THE SECTION STILL IN USE?
	BGEQ	80$			;BR IF ALLOCATED FOR USE
	CVTWL	PHD$W_PSTFREE(R5),SEC$L_CCB(R2)[R1] ; CHAIN THIS ENTRY
	MOVW	R1,PHD$W_PSTFREE(R5)	;ONTO THE TREE LIST

80$:	ADDL	#SEC$C_LENGTH@-2,R1	;GET OFFSET TO NEXT SECTION TABLE ENTRY
	BLSS	60$			;BR IF ANOTHER ENTRY
	RSB

	.SBTTL	EXPANDPHD - EXPAND THE PROCESS HEADER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ATTEMPTS TO ADD A NEW PAGE OF ZEROES AT THE CURRENT
;	END OF THE SECTION TABLE.  IF THERE WAS SOME ROOM BEFORE THE P0 PAGE
;	TABLE, THEN THIS WILL SUCCEED AND THE SECTION TABLE IS MOVED INTO
;	THE NEW AREA.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$EXPANDPHD
;
; INPUT PARAMETERS:
;
;	R0 = ADDRESS OF LOWEST ADDRESSED SECTION TABLE ENTRY
;	     P1 SPACE ADDRESS UNLESS SYSTEM PROCESS HEADER
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE UNLESS SYSTEM HEADER)
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_SECTBLFUL		;SECTION TABLE FULL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
MMG$EXPANDPHD:
	SETIPL	#IPL$_SYNCH		;PROTECT PROCESS HEADER DATA BASE
	PUSHR	#^M<R0,R4,R5,R6>	;
	MOVL	PHD$L_PSTBASOFF(R5),R6	;BYTE OFFSET TO END OF SECTION TABLE
	ADDL3	R6,R5,R2		;P1 SPACE ADDRESS FOR THE NEW PAGE
	BSBW	MMG$PTEADRCHK		;GET ITS PTE ADDRESS
	TSTL	(R3)			;P1 PTE SHOULD BE ZERO
	BEQL	5$			;BRANCH IF OK
	SETIPL	#IPL$_ASTDEL		;BACK TO AST LEVEL
	POPR	#^M<R0,R4,R5,R6>	;FIX STACK
	MOVZWL	#SS$_SECTBLFUL,R0	;SECTION TABLE FULL
	RSB

5$:	ADDL3	R6,PCB$L_PHD(R4),R2	;SYSTEM ADR OF NEXT
					;AVAILABLE PAGE OF PROCESS HEADER
	BSBW	MMG$SVAPTECHK		;GET SYS VA OF PTE FOR SYSTEM PTE
	TSTL	(R3)			;MUST BE 0 OR DATA BASE ERROR
	BNEQ	30$			;BRANCH IF ERROR
	ROTL	#PTE$V_PROT,#PRT$C_ERKW,(R3) ;MAKE INTO DEMAND ZERO PAGE
10$:	SETIPL	#IPL$_ASTDEL		;BACK TO PAGE FAULTABLE STATE
;
; This code must run at ASTDEL to both allow the pagefault and prevent a growth
; AST.  This code is allowed to loop, since the swapper could break in here and
; remove this page from the working set as the result of a shrink, although
; unlikely- and is never expected to do it continuously causing a code loop.
;
	TSTB	@PCB$L_PHD(R4)[R6]	;FAULT THE PROCESS HEADER PAGE
					;THROUGH ITS SYSTEM ADDRESS
	SETIPL	#IPL$_SYNCH		;PROTECT PROCESS HEADER DATA BASE AGAIN
	MOVAB	@PCB$L_PHD(R4)[R6],R2	;ADDRESS OF NEW PROCESS HEADER PAGE
	BSBW	MMG$SVAPTECHK		;GET SYS VIRTUAL ADR OF SPTE
	MOVL	(R3),R0			;GET THE SPT ENTRY
	BGTR	10$			;LOOP IF ENTRY EXISTS, BUT IS NOT VALID
	BEQL	EXPANDPHDBUG		;BRANCH IF NOT VALID, ERROR
	PUSHL	R0			;SAVE THE SPTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ;GET THE PFN
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R0],R1>,-	;GET WORKING SET LIST INDEX
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BISL	#WSL$M_WSLOCK,(R5)[R1]	;SET THE WORKING SET LOCK
					;PROCESS HDR PAGE IS NOT A CANDIDATE
					;FOR WORKING SET LIST REPLACEMENT
	PUSHR	#^M<R2,R3>		;SAVE SVAPTE AND VA FROM SWAPWSLE
	MOVZWL	PHD$W_WSDYN(R5),R2	;WSLX TO SWAP TO
	BSBW	MMG$SWAPWSLE		;SWAP INTO LOCKED PORTION
	INCW	PHD$W_WSDYN(R5)		;DYNAMIC PORTION STARTS ONE HIGHER
	CMPW	PHD$W_WSNEXT(R5),PHD$W_WSDYN(R5) ;MAKE SURE WSNEXT IS OK
	BGEQU	20$			;BRANCH IF IT IS
	MOVW	PHD$W_WSLAST(R5),PHD$W_WSNEXT(R5) ;MUST RESET IT
20$:	POPR	#^M<R2,R3>		;RECOVER VA, SVAPTE
	BSBW	MMG$EXTRADYNWS		;RECOMPUTE EXTRA DYNAMIC WSLE COUNT
	ADDL3	R6,R5,R2		;P1 SPACE ADDRESS FOR THE NEW PAGE
	BSBW	MMG$PTEADRCHK		;GET ITS PTE ADDRESS
	MOVL	(SP)+,R1		;LOAD SVAPTE
	TSTL	(R3)			;P1 PTE TOO SHOULD HAVE BEEN ZERO
	BEQL	40$			;BRANCH IF OK
	CMPL	R1,(R3)			;STILL OK IF SAME, SWAP AT ABOVE IPL 2
					;COULD CAUSE THIS TO BE FILLED
30$:	BNEQ	EXPANDPHDBUG		;BRANCH IF IT WASN'T, ERROR
40$:	MOVL	R1,(R3)			;FILL IN P1 SPACE PTE
;
; NOW MOVE THE SECTION TABLE PAGE(S) TO OPEN UP SOME SPACE BETWEEN
; THE WORKING SET LIST AND THE SECTION TABLE.
; MUST NOT LOWER IPL AT THIS POINT BECAUSE MODIFIED PAGE WRITER MIGHT
; TRY TO ACCESS THE SECTION TABLE.
; R2 = P1 VIRTUAL ADDRESS OF 1ST BYTE OF NEW PAGE
; 0(SP) = ADDRESS OF LOWEST ADDRESSED SECTION TABLE ENTRY
;
	MOVAL	^X200(R6),PHD$L_PSTBASOFF(R5) ;PST BASE IS 1 PAGE HIGHER
	MOVL	(SP),R1			;ADDRESS OF 1ST SECTION TABLE ENTRY
	SUBL	R1,R2			;NO. OF BYTES OF SECTION TABLE TO MOVE
	MOVC3	R2,(R1),^X200(R1)	;MOVE SECTION TABLE 1 PAGE
	MOVC5	#0,(R1),#0,#^X200,@(SP)+ ;ZERO 1 PAGE FROM 1ST SEC TBL ENTRY
	MOVZWL	#SS$_NORMAL,R0		;SET SUCCESS CODE
	SETIPL	#IPL$_ASTDEL		;BACK TO AST LEVEL
	POPR	#^M<R4,R5,R6>		;RESTORE REGISTERS
	RSB				;AND RETURN
;
; DATA BASE INCONSISTENCY
;
EXPANDPHDBUG:
	BUG_CHECK EXPANDPHD,FATAL

	.END
