	.TITLE	CVT_ATB - ASCII NUMBER TO BINARY CONVERSION
	.IDENT	'V03-000'		

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;
; EQUATED SYMBOLS:
;
	COUNT	= 4			; COUNT ARG IN ARG LIST
	STRING	= 8			; STRING ARG
	RESULT	= 12			; RESULT ADDRESS

;++
;
; FACILITY: SYSTEM LIBRARY
;
; ABSTRACT:
;
;	THIS ROUTINE PERFORMS ASCII INTEGER TO BINARY CONVERSION IN
;	DECIMAL, OCTAL, AND HEX RADIX; RADIX DETERMINED BY ENTRY POINT.
;	AN OPTIONAL LEADING SIGN IS ACCEPTED.
;
; ENVIRONMENT:
;
;	STAR NATIVE MODE PROCESSOR, ANY ACCESS LEVEL. NO SPECIAL
;	INSTRUCTIONS OR SYSTEM SERVICES ARE USED. 9 LONGWORDS OF
;	STACK SPACE NEEDED.
;
;--
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:  ANDREW C. GOLDSTEIN  26-JAN-78  16:48
;
; MODIFIED BY:
;	, : VERSION
; 01	 -

	.PAGE
	.SBTTL	DECLARATIONS
;++
;
; FUNCTIONAL DESCRIPTION:
;
; THE ROUTINE WORKS IN THE OBVIOUS MANNER OF ALL CONVERSION ROUTINES:
; IT SCANS THE INPUT STRING AND CONVERTS EACH CHARACTER INTO ITS
; NUMERICAL EQUIVALENT AND CHECKS IT FOR LEGALITY AGAINST THE RADIX.
; THE NUMBER BEING ACCUMULATED IS THEN MULTIPLIED BY THE RADIX AND THE
; NEW DIGIT IS ADDED IN. NON-RADIX CHARACTERS IN THE INPUT STRING CAUSE
; AN ERROR RETURN. A SIGN IN OTHER THAN THE FIRST CHARACTER POSITION
; AND OVERFLOW FROM 32 BITS (UNSIGNED) ALSO CAUSE AN ERROR RETURN.
;
; CALLING SEQUENCE:
;	CALL LIB$CVT_DTB (COUNT,STRING,RESULT)	; CONVERT DECIMAL TO BINARY
;	CALL LIB$CVT_OTB (COUNT,STRING,RESULT)	; CONVERT OCTAL TO BINARY
;	CALL LIB$CVT_HTB (COUNT,STRING,RESULT)	; CONVERT HEX TO BINARY
;
;
; INPUT PARAMETERS:
;	COUNT:	BYTE COUNT OF INPUT STRING
;	STRING:	ADDRESS OF INPUT STRING
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	RESULT:	ADDRESS TO STORE LONGWORD RESULT
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 = 1	SUCCESFUL CONVERSION
;	   = 0	ILLEGAL CHARACTER OR ZERO BYTE COUNT
;
; SIDE EFFECTS:
;	NONE
;
;--

	.ENABL	LSB

	.PSECT	YCVTATB,WRT
;
; BASE AND VALUE TABLES TO CONVERT DIGITS INTO THEIR NUMERICAL VALUES
;
BASETAB:	.BYTE	^A'a',    ^A'A',    ^A'0'
TOPTAB:		.BYTE	^A'z',    ^A'Z',    ^A'9'
VALTAB:		.BYTE	^A'a'-10, ^A'A'-10, ^A'0'-00


LIB$CVT_DTB::				; ENTRY FOR DECIMAL CONVERT
	.WORD	^M<R2,R3,R4,R5>		; SAVE REGISTERS 2-5
	MOVL	#10,R2			; R2 = RADIX
	BRB	10$

LIB$CVT_OTB::				; ENTRY FOR OCTAL CONVERT
	.WORD	^M<R2,R3,R4,R5>		; SAVE REGISTERS 2-5
	MOVL	#8,R2			; R2 = RADIX
	BRB	10$

LIB$CVT_HTB::				; ENTRY FOR HEX CONVERT
	.WORD	^M<R2,R3,R4,R5>		; SAVE REGISTERS 2-5
	MOVL	#16,R2			; R2 = RADIX

10$:	CLRQ	R0			; ZERO INITIAL NUMBER
	CLRQ	R3			; AND STRING POINTER & SIGN
	DECL	R3			; BACK OFF COUNT
	BRB	70$			; AND ENTER PRE-TESTED LOOP

20$:	MOVZBL	@STRING(AP)[R3],R5	; GET NEXT CHARACTER
	TSTL	R3			; SEE IF THIS IS FIRST CHARACTER
	BNEQ	30$			; SKIP SIGN CHECK IF NOT
	CMPB	R5,#^A'+'		; CHECK FOR PLUS
	BEQL	70$
	CMPB	R5,#^A'-'		; CHECK FOR MINUS
	BNEQ	30$			; BRANCH IF NOT
	INCL	R4			; SET NEGATIVE FLAG
	BRB	70$			; OK - LOOP FOR NEXT CHARACTER

30$:	CLRL	R1			; INIT TABLE INDEX
40$:	CMPB	R5,BASETAB[R1]		; CHECK DIGIT AGAINST BASE CHARACTER
	BLSSU	50$			; BRANCH IF DIGIT IS LESS
	CMPB	R5,TOPTAB[R1]		; CHECK DIGIT AGAINST TOP CHARACTER
	BLEQU	60$			; BRANCH IF LESS - VALID
50$:	AOBLSS	#3,R1,40$		; NOT THIS RANGE - TRY NEXT LOWER BASE
	BRB	90$			; NOT A LEGAL DIGIT

60$:	SUBB	VALTAB[R1],R5		; COMPUTE NUMERIC VALUE (NOTE - ALWAYS +)
	CMPL	R5,R2			; CHECK DIGIT AGAINST RADIX
	BGEQU	90$			; TOUGH LUCK ......
	EMUL	R2,R0,R5,R0		; SCALE VALUE BY RADIX AND ADD DIGIT
	TSTL	R1			; CHECK FOR OVERFLOW
	BNEQ	90$

70$:	AOBLSS	COUNT(AP),R3,20$	; LOOP FOR DIGITS

	BLBC	R4,80$			; CHECK SIGN BIT
	MNEGL	R0,R0			; MAKE NEGATIVE IF DESIRED
80$:	MOVL	R0,@RESULT(AP)		; STORE RESULT
	MOVL	#1,R0			; RETURN TRUE
	RET
;
; TO HERE ON ANY BAD CHARACTER
;
90$:	CLRL	R0			; RETURN FALSE
	RET

	.DSABL	LSB



	.END
