	.TITLE	PAGEFAULT - TRANSLATION NOT VALID EXCEPTION HANDLER
	.IDENT	'V03-003'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, TRANSLATION NOT VALID EXCEPTION HANDLER
;
; ABSTRACT:
;
; ENVIRONMENT:
;
;--
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 14-SEP-76
;
; MODIFIED BY:
;
;	V03-003	KDM0081		Kathleen D. Morse	31-Mar-1982
;		Change MMG$INVALIDATE to MPH$INVALIDHK to indicate that
;		this symbol is required for MP.EXE only.
;
;	V03-002	HRJ0060		Herb Jacobs		20-Mar-1982
;		Add synchronization flags to FREWSLE so it can safely
;		be called from SWAPPER process context.
;
;	V03-001 WMC0061		Wayne Cardoza		15-Mar-1982
;		Fix an incorrect branch.
;
;	V02-033	HRJ0054		Herb Jacobs		20-Feb-1982
;		Control working set extends based on free page list size.
;
;	V02-032	HRJ0051		Herb Jacobs		02-Feb-1982
;		Resource wait processes producing modified pages when
;		modified page writer is busy.
;
;	V02-031	HRJ0049		Herb Jacobs		25-Jan-1982
;		Fix aggressivness of dead page table scanning,
;		make WSLE skipping a sysgen parameter.
;
;	V02-030	HRJ0046		Herb Jacobs		17-Jan-1982
;		Fix bug causing dead page table scan to be skipped and
;		add possible wait to FREWSLE when needing modified page
;		writer to recover dead page tables.  Remove page file
;		resource wait.
;
;	V02-029	RIH0084		Richard I. Hustvedt	02-Jan-1981
;		Use TBCHK to refine choice in FREWSLE.
;
;	V02-028 SPF0055		Steve Forgey		02-Jan-1981
;		Update image working set peak.
;
;	V02-027	HRJ0034		Herb Jacobs		14-Nov-1981
;		Remove page file wait condition and rename file full bit.
;
;	V02-026	LJK0083		Lawrence J. Kenah	12-Nov-1981
;		Change broken word displacement to use G^ addressing.
;
;	V02-025	HRJ0030		Herb Jacobs		30-Oct-1981
;		Add limit check to size of dynamic space for swap slot
;		based on maximum authorized quota.
;
;	V02-024	WMC0011		Wayne Cardoza		25-Oct-1981
;		Clean up DZRO paths for global pages with page file backing 
;		store.
;
;	V02-023	SPF0022		Steve Forgey		28-Aug-1981
;		Add PHD$L_PGFLTIO logic.
;
;	V02-022	HRJ0023		Herb Jacobs		19-Aug-1981
;		More cleanup of V02-015, MWAIT on page file.
;
;	V02-021	HRJ0027		Herb Jacobs		14-Aug-1981
;		Change L^ references to SYSPHD to W^ references.
;
;	V02-020	LJK0044		Lawrence J. Kenah	13-Aug-1981
;		Change PGFLVBN to MAXVBN in PFL structure.
;
;	V02-019	WMC0001		Wayne M Cardoza		12-Aug-1981
;		Changes to allow global sections with page file backing 
;		store.  Master PTE DZRO pages are now legal.
;
;	V02-018	LJK0042		Lawrence J. Kenah	4-Aug-1981
;		Do not report an access violation the first time that a 
;		process faults the header of another process. Simply
;		dismiss the page fault.
;
;	V02-017	LJK0034		Lawrence J. Kenah	4-Aug-1981
;		Eliminate as much wait logic as possible from this module.
;		Cause memory management wait code to use centralized routines
;		in module SYSWAIT.
;
;	V02-016	LJK0030		Lawrence J. Kenah	4-Aug-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations. Modify calls to DECSHR macro
;		to include extra parameter passed on to PFN_REFERENCE.
;
;	V02-015	HRJ0023		Herb Jacobs		17-Jul-1981
;		Change algorithm for determination if process should
;		go into page file wait.
;
;	V02-014	SPF0005		Steve Forgey		06-Jul-1981
;		Add global valid fault counter.
;
;	V02-013	HRJ0023		Herb Jacobs		01-Jul-1981
;		Add dynamic swap file allocation support to working
;		set growth logic.
;
;	V02-012	HRJ0021		Herb Jacobs		21-May-1981
;		Cleanup of free working set list entry loop,
;		remove goodpage logic.
;
;	V02-011	HRJ0020		Herb Jacobs		17-Apr-1981
;		Change the way the working set list scan is done to
;		eliminate the need of keeping WSLAST exact to compute
;		the current working set size.  The current working set
;		size is now maintained in WSSIZE.
;
;	V02-010	LJK0010		Lawrence J. Kenah	13-Mar-1981
;		If the PTE$V_CHKPNT bit is set in the backing store
;		address of a page being removed from the working set,
;		that backing store address is forgotten and BAK is
;		reset to contain a not-yet-allocated block in the paging
;		file. In addition, the checkpoint bit must be turned off
;		before the VBN in the paging file is calculated. (These
;		changes support the checkpoint facility.)
;
;	V02-009	KDM0028		KATHLEEN D. MORSE	08-DEC-1980
;		Change FRE_TRY_SKIP to MMG$FRE_TRYSKIP.
;
;	V02-008	KDM0022		KATHLEEN D. MORSE	28-AUG-1980
;		Fix comment line.
;
;	V02-007	KDM0006		KATHLEEN D. MORSE	30-APR-1980
;		Add picture of kernel stack following a pagefault.
;
; 01	 -

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CADEF				;CONDITIONAL ASSEMBLY DEFINITIONS
	$IPLDEF				;PROCESSOR PRIORITY LEVEL DEFINITIONS
	$IRPDEF				;I/O REQUEST PACKET DEFINITIONS
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINTIONS
	$PRDEF				;PROCESSOR REGISTER DEFINITIONS
	$PFLDEF				;PAGE FILE CONTROL BLOCK DEFINITIONS
	$PFNDEF				;PFN DATA BASE DEFINITIONS
	$PSLDEF				;PROCESSOR STATUS LONG WORD DEFINITIONS
	$PTEDEF				;PAGE TABLE ENTRY OFFSETS
	$RSNDEF				;RESOURCE NAME DEFINITIONS
	$SECDEF				;SECTION TABLE DEFINITIONS
	$SSDEF				;SYSTEM STATUS DEFINITIONS
	$VADEF				;VIRTUAL ADDRESS VIELDS
	$WQHDEF				;WAIT QUEUE HEADER DEFINITIONS
	$WSLDEF				;WORKING SET LIST DEFINITIONS
;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

	$OFFSET <4*6>,POSITIVE,<-
	FLTCTL,-			;OFFSET TO FAULT CONTROL BITS
	FLTVA,-				;OFFSET TO FAULT VIRTUAL ADDRESS
	FLTPC,-				;OFFSET TO FAULT PC
	FLTPSL-				;OFFSET TO FAULT PSL
	>

	$VIELD	PGF,0,<-		;DEFINE PAGE FAULT CONTROL BITS
		LENVIO,-		;LENGTH VIOLATION
		PGTBFLT,-		;PAGE TABLE FAULT
		WRTACC-			;REFERENCE WAS WRITE OR MODIFY
	>
;
; OFFSETS INTO I/O PACKET WHILE BEING USED AS SCRATCH STORAGE FOR CLUSTERING
;
	$OFFSET	0,POSITIVE,<-
		PTEDAT,-		;MASTER PTE CONTENTS
		SVAPTE,-		;MASTER PTE ADDRESS
		SIZE_TYPE,-		;RESERVED FOR SIZE AND TYPE
		VA,-			;VIRTUAL ADDRESS
		AST,-			;AST INFO
		ASTPRM,-		; AND PARAMETER
		GPTX,-			;PROCESS PTE CONTENT FOR GLOBAL PAGE
		GPTX_PTE,-		;PROCESS PTE ADR FOR GLOBAL PAGE
		<CLUSTER,1>,-		;DESIRED CLUSTER SIZE
		<COUNT,1>,-		;CURRENT COUNT OF PAGES
		<STATE,1>,-		;SAVED PFN_STATE BYTE
		<PRI,1>,-		;PRIORITY OF I/O TRANSFER
		BAK,-			;PFN BACKING STORE ADDRESS
		INC1,-			;+ OR - 1
		INC4,-			;+ OR - 4
		INC512,-		;+ OR - 512
		VBN,-			;VIRTUAL BLOCK NUMBER
		WINDOW,-		;WINDOW CONTROL BLOCK ADR
		FP_SAV,-		;SAVED FP
		<PCB_SAV,8>,-		;SAVED PCB, PHD ADDRESS
		PHVREFCADR,-		;PROCESS HEADER REFERENCE COUNT ADDRESS
		<CLU_SCRATCH_SIZ,0>-	;SIZE OF THIS SCRATCH AREA
		>

	ASSUME	CLU_SCRATCH_SIZ LE IRP$C_LENGTH
	ASSUME	SIZE_TYPE EQ IRP$W_SIZE
	ASSUME	AST EQ IRP$L_AST
	ASSUME	ASTPRM EQ IRP$L_ASTPRM
	ASSUME	PRI EQ IRP$B_PRI
;
; OWN STORAGE:
;
	.PSECT	$$$210,LONG
;
; STATISTICS
;
PMS$GL_FAULTS::
	.BLKL	1			;COUNT OF PAGE FAULTS
PMS$GL_RDFLTS::				;OBSOLETE NAME
PMS$GL_PREADS::
	.BLKL	1			;PAGE READS
PMS$GL_PREADIO::
	.BLKL	1			;I/O REQUESTS TO READ THE PAGES
PMS$GL_PWRITES::
	.BLKL	1			;MODIFIED PAGES WRITTEN
PMS$GL_PWRITIO::
	.BLKL	1			;I/O REQUESTS TO WRITE THE MODIFIED PAGES
PMS$GL_DZROFLTS::
	.BLKL	1			;DEMAND ZERO PAGE FAULTS
PMS$AL_TRANSFLT::
	.BLKL	<1@PFN$S_LOC>		;PAGE FAULTS OUT OF TRANSITION STATES
PMS$GL_DPTSCN::
	.BLKL	1			;DEAD PAGE TABLE SCANS
PMS$GL_GVALID::
	.BLKL	1			;GLOBAL VALID FAULTS

	.SBTTL	PAGE FAULT HANDLER

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS MODULE CONTAINS THE PAGEFAULT HANDLER.  IT IS ENTERED VIA A
; TRANSLATION-NOT-VALID FAULT.  AT THE TIME OF A FAULT, THE KERNEL
; STACK CONTAINS THE FOLLOWING INFORMATION:
;
;	+-----------------------------+
;	!       REASON MASK           ! --> BIT 0 - ALWAYS 0 FOR
;	+-----------------------------+             TRANS-NOT-VALID FAULTS
;	!   INVALID VIRTUAL ADDRESS   !     BIT 1 - 0 INDIC VIRT ADR NOT VALID
;	+-----------------------------+             1 INDIC ASSOC PTE NOT VALID
;	!  PC OF FAULTING INSTRUCTION !     BIT 2 - 0 INDIC READ ACCESS
;	+-----------------------------+             1 INDIC MODIFY/WRITE ACCESS
;	! PSL OF FAULTING INSTRUCTION !
;	+-----------------------------+
;
; CALLING SEQUENCE:
;	NONE
;
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THIS ENTIRE MODULE MUST BE RESIDENT *****************
;
	.PSECT	$MMG$COD,LONG
;
; **********************************************************************
;
	.LIST	MEB

IPLHI:	BUG_CHECK PGFIPLHI,FATAL	;IPL TOO HIGH FOR PAGE FAULT

	.SBTTL	SYSTEM PAGE FAULT, ESTABLISH PAGE TYPE

	.ENABL	LSB
;
; BAD SYSTEM PAGE - PROCESS HEADER OR PAGE TABLE PAGE FOR ANOTHER PROCESS
;
;  IF THE PROCESS HEADER HAS JUST BEEN INSWAPPED (PHD$V_NOACCVIO IS SET),
;  SIMPLY DISMISS THE FAULT. IN ALL OTHER CASES, REPORT AN ACCESS VIOLATION
;  EXCEPTION. 
;
;	IF THE PROCESS WAS OUTSWAPPED WHILE ACCESSING ITS OWN HEADER,
;	DISMISSING THE EXCEPTION WILL CAUSE THE REFERENCE TO OCCUR AGAIN,
;	BUT THIS TIME TO THE CORRECT BALANCE SLOT.
;
;	IF THE PROCESS WAS MAKING AN ILLEGAL REFERENCE TO THE HEADER OF ANOTHER
;	PROCESS, DISMISSING THE EXCEPTION WILL CAUSE THE SAME ILLEGAL REFERENCE
;	TO OCCUR AGAIN, BUT NOW WITH PHD$V_ACCVIO CLEAR, CAUSING AN ACCESS
;	VIOLATION TO BE REPORTED.

BADSYSPAG:
	BBSC	#PHD$V_NOACCVIO,PHD$W_FLAGS(R5),10$ ;BRANCH IF HEADER JUST INSWAPPED
	BRW	ACVIOLAT		;FAKE AN ACCESS VIOLATION

10$:	BRW	PGFCOMPLETE		;SIMPLY DISMISS THE PAGE FAULT

;
; SEE IF PAGE IS A GLOBAL PAGE TABLE PAGE, OTHERWISE ERROR
;
GPGTBL:
	CMPW	R0,SGN$GL_BALSETCT	;SYSTEM BALANCE SET SLOT?
	BLSS	BADSYSPAG		;BRANCH IF NOT
	CMPL	R2,W^MMG$GL_MAXGPTE	;LEGAL GPTE ADDRESS
	BGEQU	BADSYSPAG
	MOVB	#WSL$C_GPGTBL,R2	;PAGE IS GLOBAL PAGE TABLE
	BRB	50$
;
; PAGE IS NOT SYSTEM PAGE TYPE, COULD BE GLOBAL PAGE TABLE, PROCESS PAGE TABLE
; OR PROCESS HEADER PAGE
;
NOTSYSTEM:
	ASHL	#-9,R0,R0		;SCALE VA DIFFERENCE TO PAGE NUMBER
	MOVL	PCB$L_PHD(R4),R5	;ADDRESS OF PROCESS HEADER
	DIVL	W^SWP$GL_BSLOTSZ,R0	;PROCESS HEADER INDEX
	CMPW	R0,PHD$W_PHVINDEX(R5)	;THIS PROCESS' HEADER?
	BNEQ	GPGTBL			;BRANCH IF NOT, MAYBE GLOBAL PAGE TABLE
	MOVB	#WSL$C_PPGTBL,R2	;ASSUME PROCESS PAGE TABLE
	BRB	70$
;
; PAGE FAULT MONITORING ENABLED FOR THIS PROCESS
;
PGFMONITOR:
	BSBW	PFM$MON			;CALL THE RECORDING ROUTINE
	BRB	PGFMONITOR1		;RETURN IN LINE
;
; PAGE FAULT FOR SYSTEM SPACE VIRTUAL ADDRESS
;	R2 = FAULT VA, LOW BITS CLEARED
;	R4 = PROCESS PCB ADDRESS
;
SYSTEMSPACE:
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R3 ;PAGE NUMBER IN SYSTEM SPACE
	SUBL3	W^SWP$GL_BALBASE,R2,R0 ;ABOVE BASE OF BALANCE SET SLOTS?
	BGEQ	NOTSYSTEM		;BRANCH IF NOT SYSTEM PAGE TYPE
40$:	MOVB	#WSL$C_SYSTEM,R2	;SYSTEM PAGE
50$:	MOVAL	W^MMG$AL_SYSPCB,R4	;ADDRESS OF SYSTEM PCB
	MOVL	PCB$L_PHD(R4),R5	;ADDRESS OF SYSTEM PROCESS HEADER
70$:	MOVAL	@W^MMG$GL_SPTBASE[R3],R3 ;ADDRESS OF PAGE TABLE ENTRY
	BRB	GETPAGELOC

;
; THIS IS A PROCESS PAGE TABLE FAULT
;
PPGTBL:
	BICL3	#^X1FF,R3,R2		;R2 = FAULT VA
	BRB	SYSTEMSPACE

	.DSABL	LSB

	.SBTTL	EXECEPTION ENTRY POINT - PAGE TYPE DISPATCHER

	.ALIGN	LONG
MMG$PAGEFAULT::
	PUSHL	R5			;SAVE R5
	PUSHL	R4			;SAVE R4
	CMPZV	#PSL$V_IPL,#PSL$S_IPL,<12+8>(SP),#IPL$_ASTDEL ;CHECK FAULT IPL
	BGTR	IPLHI			;BRANCH IF IPL IS TOO HIGH
	PUSHL	R3			;SAVE R3
	SETIPL	#IPL$_SYNCH		;LOCK THE DATA BASE
	PUSHL	R2			;SAVE R2
	MOVL	W^SCH$GL_CURPCB,R4	;R4 = ADDRESS OF PCB
	PUSHL	R1			;SAVE R1
	PUSHL	R0			;SAVE R0
	BICL3	#^X1FF,FLTVA(SP),R2	;R2 = VA OF FAULT (LOW BITS CLEAR)
	BLSS	SYSTEMSPACE		;BRANCH IF SYSTEM SPACE ADDRESS
	MOVL	PCB$L_PHD(R4),R5	;R5 = ADDRESS OF HEADER
	BBS	#PHD$V_PFMFLG,PHD$W_FLAGS(R5),PGFMONITOR ;BRANCH IF PAGE FAULT MONITORING
PGFMONITOR1:
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R3 ;VIRTUAL PAGE IN P0 OR P1 SPACE
	BBC	#VA$V_P1,R2,P0ADDR	;BRANCH IF P0 SPACE
	MOVAL	@PHD$L_P1BR(R5)[R3],R3	;GET SYS VIRT ADR OF PTE FOR P1 SPACE
	BRB	GETPAGELOC
VALID:	BRW	PGFCOMPLETE		;IF VALID, JUST EXIT
P0ADDR:	MOVAL	@PHD$L_P0BR(R5)[R3],R3	;GET SYS VIRT ADR OF PTE FOR P0 SPACE
;
; R2 = VA (LOW BITS = PAGTYP), R3 = SVAPTE
;
GETPAGELOC:
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R0 ;INDEX TO SPT ENTRY
	MOVAL	@W^MMG$GL_SPTBASE[R0],R1 ;ADDRESS OF SPTE FOR PAGE TABLE
	TSTL	(R1)			;IS SPTE VALID?
	BGEQ	PPGTBL			;BRANCH IF NOT, FAULT IT
	BICL3	#^C<PTE$M_VALID		-;CHECK VALID BIT
		! PTE$M_TYP1 ! PTE$M_TYP0 -;GET PTE TYPE BITS
		! PTE$M_PGFLVB>,(R3),R0	;AND PFN/PAGE FILE VBN BITS TO R0
	BLSS	VALID			;BRANCH IF VALID
;
; R0 = TYP1 ! TYP0 ! PGFLVB,  VALID IS KNOWN TO BE OFF AT THIS POINT
; R1 = SPT ENTRY ADDRESS FOR PAGE TABLE PAGE
; R2 = VA (LOW BITS = PAGTYP)
; R3 = SVAPTE
;
	INCL	W^PMS$GL_FAULTS		;COUNT ALL THE PAGE FAULTS
	INCL	PHD$L_PAGEFLTS(R5)	;COUNT PROCESS' PAGE FAULTS
	PUSHL	R3			;SAVE NEEDED VOLATILE REGISTERS
	PUSHL	R2
	PUSHL	R1
	BSBW	MMG$FREWSLE		;FREE A WORKING SET LIST ENTRY
	BLBC	R0,RSRCWAIT_3		;BRANCH IF HAVE TO WAIT
;
; ***** ALL POINTS DISPATCHED TO FROM HERE MUST REMEMBER THAT
; ***** 0(SP) = VA (LOW BITS = PAGTYP), 4(SP) = SVAPTE
;
	MOVL	8(SP),R3		;SVAPTE
;
; MUST RECHECK VALIDITY OF PAGE TABLE PAGE, SINCE FREWSLE MIGHT HAVE DISCARDED IT
;
	TSTL	@(SP)+			;IS PAGE TABLE PAGE VALID?
	BGEQ	PPGTBL_2		;NO, GO FAULT THE PAGE TABLE
;
; MUST FETCH PAGE TABLE ENTRY CONTENTS AGAIN SINCE DEAD PAGE TABLE SCAN
; IN FREWSLE MIGHT HAVE DISCARDED THE PAGE.  NOTE THAT VALID IS KNOWN 0.
;
	BICL3	#^C<PTE$M_VALID ! -	;FETCH VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 !- ;PTE TYPE BITS
		PTE$M_PGFLVB>,(R3),R0	;AND PGFLVB, GPTX, SECX, PFN
	BEQL	DZRO_PTE_0		;BRANCH IF PAGE IS DEMAND ZERO
;
; FORM R1 = 4 BIT SIGN EXTENDED VIELD LOW BIT = TYP0, SIGN = TYP1
;
	EXTV	#PTE$V_TYP0,#<PTE$V_TYP1+1-PTE$V_TYP0>,R0,R1
	BNEQ	NOTRANSITION		;BRANCH IF NOT TRANSITION PAGE
;
; THIS IS A PAGE IN TRANSITION
; R0 = PFN, R2 = VA (LOW BITS = PAGTYP), R3 = SVAPTE
;
TRANSITION:
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],R2 ;PAGE LOCATION

	.IF	GT,CA$_MEASURE
	INCL	W^PMS$AL_TRANSFLT[R2]	;COUNT VARIOUS TRANSITION FAULTS
	.ENDC
	
	CASE	R2,<-
		PFNLIST,-		;ON THE FREE PAGE LIST
		PFNLIST,-		;ON THE MODIFIED PAGE LIST
		PFNLIST,-		;ON THE BAD PAGE LIST
		RELEASEPEND,-		;RELEASE PENDING
		READERR,-		;PAGE READ ERROR
		WRITEINPROG,-		;PAGE WRITE IN PROGRESS
		READINPROG-		;PAGE READ IN PROGRESS
	>
LOCBAD:	BUG_CHECK PGFLOCBAD,FATAL	;BAD PAGE LOCATION FIELD

DZRO_PTE_0:
	BRW	DZRO_PTE
RSRCWAIT_3:
	ADDL	#3*4,SP			;CLEAN OFF 3 LONG WORDS
	BRW	RESOURCEWAIT		;AND GO WAIT FOR A RESOURCE
PPGTBL_2:
	POPR	#^M<R0,R1>		;CLEAN OFF 2 LONG WORDS, SCRATCH R0,R1
	BRW	PPGTBL			;FAULT A PROCESS PAGE TABLE

	.SBTTL	PAGE FILE, SECTION TABLE INDEX, OR GLOBAL PAGE
;
; GLOBAL PAGE, MASTER PTE VALID.
; R0 = MASTER PTE CONTENTS (VALID, MODIFY AND PFN BITS)
; 0(SP) = PROCESS VA (LOW BITS = PAGTYP), 4(SP) = SLAVE PTE ADDRESS
;
GBLVALID:
	INCL	W^PMS$GL_GVALID		;UPDATE GLOBAL VALID COUNTER
	MOVQ	(SP),R2			;R2=VA (LOW BITS = PAGTYP), R3=SVAPTE
	PUSHL	R0			;SAVE MASTER PTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ;PAGE FRAME NUMBER
	BSBW	MMG$MAKEWSLE		;MAKE A WORKING SET LIST ENTRY
	POPR	#^M<R1,R2,R3>		;R1=MASTER PTE, R2=VA, R3=SVAPTE
	BRW	SETSLAVEPTE		;SET PROCESS' PTE AND EXIT
;
; DEMAND ZERO GLOBAL SECTION WITH PAGE FILE BACKING STORE
;
GBLDZRO_PGFL:
	MOVL	#PTE$M_TYP0,R0		;ADD A TYP0 BIT TO THE MASTER PTE (0)
	BRW	GBLDZRO			;GO JOIN COMMON CODE
;
; BAD MASTER PAGE TABLE ENTRY FORMAT FOR A GLOBAL PAGE
;
GBLBAD:	BUG_CHECK PGFGBLBAD,FATAL	;BAD MASTER PTE FORMAT FOR GLOBAL PAGE
;
; PAGE IS NOT A TRANSITION OR DEMAND ZERO PAGE
; R0 = LOW 23 BITS OF PTE AND TYPE BITS (PAGE FILE VBN, GPTX OR STX)
; R1 = RESULT OF EXTV ABOVE, CONDITION CODES SET FROM EXTV
; 0(SP) = VA (LOW BITS = PAGTYP), 4(SP) = SVAPTE
;
NOTRANSITION:
	BLSS	NOTGLOBAL		;BRANCH IF TYP1 SET, NOT A GLOBAL PAGE
	BBCC	#PTE$V_TYP0,R0,10$	;LEAVE JUST GLOBAL PAGE TABLE INDEX
10$:	MOVAL	@W^MMG$GL_GPTBASE[R0],R3 ;ADDRESS OF MASTER PTE
	ROTL	#<32-<PTE$V_OWN-WSL$V_PAGTYP>>,(R3),R1 ;OWNER FIELD TO LOW BITS
;
; MASTER PTE OWNER FIELD CONTAINS THE VALUE PFN$C_GLOBAL OR PFN$C_GBLWRT
;
	BICB3	#^C<WSL$M_PAGTYP>,R1,(SP) ;SET PAGE TYPE FIELD
	BICL3	#^C<PTE$M_VALID ! -	;GET THE VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! - ;THE PTE TYPE BITS
		PTE$M_PGFLVB>,(R3),R0	;AND PAGE FILE VBN, OR STX
	BLSS	GBLVALID		;BRANCH IF MASTER PTE IS VALID
	BEQL	GBLDZRO_PGFL		;MASTER PTE IS DEMAND ZERO
	EXTV	#PTE$V_TYP0,#<PTE$V_TYP1+1-PTE$V_TYP0>,R0,R1
;
; R1 = 0 IF TYP1 AND TYP0 ARE BOTH ZERO
; R1 = NEGATIVE IF TYP1 IS SET
; R1<0> = 1 IF TYP0 IS SET
;
	BEQL	TRANSITION		;BRANCH IF GLOBAL TRANSITION
	BGTR	GBLBAD			;BRANCH IF GLOBAL AGAIN, ERROR
;
; MASTER PAGE TABLE ENTRY IS A SECTION OR PAGE FILE ADDRESS
;
20$:	BLBC	R1,30$			;BRANCH IF PAGE FILE
	BBS	#PTE$V_DZRO,R0,GBLDZRO	;BRANCH IF DEMAND ZERO GLOBAL SECTION
	BBS	#PTE$V_CRF,R0,GBLCRF	;BRANCH IF COPY ON REFERENCE
;
; GLOBAL SECTION (NOT CRF OR DZRO) OR PAGE FILE BACKING STORE ADR
;
30$:	MOVL	4(SP),R0		;SAVE SLAVE PTE ADR INDICATING GLOBAL
	BRB	GBLNOTRESIDENT		;
;
; GLOBAL COPY ON REFERENCE PAGE
;
GBLCRF:
	CLRB	(SP)			;SAY PAGE IS PROCESS PAGE
	MOVL	R3,R0			;MASTER PTE ADDRESS
	BRB	GBLNOTRESIDENT		;

	.SBTTL	PAGE NOT RESIDENT, QUEUE A READ REQUEST
	.ENABL	LSB

;
; MUST WAIT FOR AN I/O REQUEST PACKET
;
IRPWAIT_3:
	POPR	#^M<R1>			;CLEAN OFF 1 LONG WORD
	MOVZBL	#RSN$_NPDYNMEM,R1	;NON PAGED DYNAMIC MEMORY RESOURCE NUMBER
10$:	POPR	#^M<R2,R3>		;CLEAN OFF 2 LONG WORDS
	BRW	RESOURCEWAIT		;WAIT FOR RESOURCE IN R1
;
; THIS PAGE READ WOULD EXCEED THIS PROCESS' DIRECT I/O QUOTA.
; WAIT UNTIL SOME OF HIS OUTSTANDING I/O COMPLETES.
;
DIOCNTWAIT_2:
	MOVZBL	#RSN$_ASTWAIT,R1	;AST WAIT RESOURCE NUMBER
	BRB	10$

	.DSABL	LSB

;
; NO I/O PACKETS ON THE SIDE LIST, MUST ALLOCATE ONE FROM NON-PAGED POOL
; 0(SP) = PLACE TO STORE ADDRESS OF PACKET, TOTAL OF 3 LONG WORDS ON STACK
;
GET_IRP:
	MOVL	R0,(SP)			;SAVE REGISTER
	MOVZBL	#IRP$C_LENGTH,R1	;SIZE OF I/O PACKET
	BSBW	EXE$ALONONPAGED		;ALLOCATE THE PACKET
	BLBC	R0,IRPWAIT_3		;BRANCH IF NONE AVAILABLE
	POPR	#^M<R0>			;RESTORE SAVED REGISTER
	PUSHL	R2			;I/O PACKET ADDRESS
	BRB	GOT_IRP			;REJOIN THE MAIN FLOW
;
; MUST WAIT FOR A FREE PAGE, 5 LONG WORDS ON STACK, FIRST 2 ARE GARBAGE
; 8(SP) = I/O REQUEST PACKET ADDRESS TO BE DEALLOCATED, LAST 2 ARE SCRATCH
;
FREPAGWAIT_5:
	POPR	#^M<R0,R1>		;SCRATCH R0,R1
	POPR	#^M<R0,R1,R2>		;I/O PACKET ADDRESS TO R0
	MOVZBL	#IRP$C_LENGTH,IRP$W_SIZE(R0) ;SET PACKET SIZE AND CLEAR TYPE
	BSBW	EXE$DEANONPAGED		;AND DEALLOCATE IT
	BRW	FREEPAGEWAIT
;
; DEMAND ZERO PROCESS SECTION PAGE
;
DZRO_PROC_SEC:
	BRW	DZRO_PTE
;
; DEMAND ZERO GLOBAL SECTION PAGE
;
GBLDZRO:
	MOVL	(R3),R1			;MASTER PTE CONTENTS
	BRW	DZRO_GBL_SEC
;
; PAGE IS NOT A GLOBAL PAGE
; R1<31>=TYP1, R1<0>=TYP0, R0 = TYP1 ! TYP0 ! PGFLVB
;
NOTGLOBAL:
	BLBC	R1,10$			;BRANCH IF NOT SECTION PAGE
	BBS	#PTE$V_DZRO,R0,DZRO_PROC_SEC ;BRANCH IF DEMAND ZERO PROCESS SECTION
10$:	CLRL	R0			;INDICATE NO SLAVE PAGE TABLE ENTRY
;
; 0(SP) = VA (LOW BITS = PAGTYP), 4(SP) = SVAPTE (SLAVE IF GLOBAL)
; R0	= MASTER PTE ADDRESS IF GLOBAL CRF
;	= SLAVE PTE ADDRESS IF GLOBAL NOT CRF
;	= 0 IF NOT GLOBAL
;
GBLNOTRESIDENT:
	CMPB	PHD$B_PGTBPFC(R5),#1	;IF CLUSTERING PAGE TABLE PAGES
	BLEQ	40$
	EXTZV	#VA$V_VPN,#VA$S_VPN,4(SP),R2 ;SEE IF ADJACENT PAGE TABLES
	MOVAL	@W^MMG$GL_SPTBASE[R2],R1 ;NEED TO BE FAULTED, GET SPT ENTRY ADR
	BITL	#<PTE$M_VALID ! -
		PTE$M_TYP1 ! PTE$M_TYP0 ! -
		PTE$M_PGFLVB>,-(R1)	;CHECK PREVIOUS SPT ENTRY
	BGTR	10$			;BRANCH IF NOT VALID, NOT DZRO
	BITL	#<PTE$M_VALID ! -
		PTE$M_TYP1 ! PTE$M_TYP0 ! -
		PTE$M_PGFLVB>,8(R1)	;CHECK NEXT SPT ENTRY
	BLEQ	40$			;BRANCH IF IT IS VALID
;
; NEXT PAGE TABLE NEEDS TO BE FAULTED
;
	INCL	R2			;SET NEXT SPT INDEX
	BRB	20$
;
; PREVIOUS PAGE TABLE NEEDS TO BE FAULTED
;
10$:	DECL	R2			;SET PREVIOUS SPT INDEX
20$:	ROTL	#9,R2,R2		;TURN SPT INDEX BACK INTO
	BBSS	#VA$V_SYSTEM,R2,30$	;SYSTEM VIRTUAL ADDRESS
30$:	POPR	#^M<R0,R1>		;CLEAN STACK SCRATCH R0,R1
	BRW	SYSTEMSPACE		;GO FAULT THE PAGE TABLE
40$:	MOVL	W^SCH$GL_CURPCB,R1	;COULD HAVE SYSTEM PCB IN R4
	TSTW	PCB$W_DIOCNT(R1)	;ENOUGH DIRECT I/O QUOTA FOR THIS READ?
					;NOTE THAT BUILDPKT WILL CHARGE THE READ
	BLEQ	DIOCNTWAIT_2		;BRANCH IF NO, MUST WAIT.
	REMQUE	@W^IOC$GL_IRPFL,-(SP)	;GET AN I/O PACKET FROM THE SIDE LIST
	BVS	GET_IRP			;BRANCH IF NEED TO GET ONE FROM THE POOL
;
; R0	= MASTER PTE ADDRESS IF GLOBAL CRF
;	= SLAVE PTE ADDRESS IF GLOBAL NOT CRF
;	= 0 IF NOT GLOBAL
; 0(SP) = I/O REQUEST PACKET ADDRESS
;
GOT_IRP:
	MOVQ	4(SP),R2		;R2=VA (LOW BITS = PAGTYP), R3=SVAPTE
	CLRL	-(SP)			;INIT CRF INDICATOR TO "NOT CRF PAGE"
	PUSHL	R0			;SAVE GLOBAL, GBLCRF INDICATOR
	BSBW	MMG$ININEWPFN		;ALLOCATE AND INIT A NEW PFN
	TSTL	R0			;PFN ALLOCATED SUCCESSFULLY?
	BLSS	FREPAGWAIT_5		;BRANCH IF NOT, MUST WAIT
	MOVL	@W^PFN$AL_PTE[R0],R3	;GET MASTER PTE ADDRESS
					;SAME AS SLAVE UNLESS GLOBAL
	MOVL	R3,16(SP)		;SAVE FOR LATER USE
	INCW	@W^PFN$AW_REFCNT[R0]	;2ND REFERENCE FOR PAGE I/O
;
; FORM R2 = BACKING STORE ADDRESS
; 0(SP)  = MASTER PAGE TABLE ENTRY ADDRESS IF GLOBAL CRF
;	 = SLAVE  PAGE TABLE ENTRY ADDRESS IF GLOBAL NOT CRF
;	 = 0 IF NOT GLOBAL PAGE
; 4(SP)  = 0 INITIALIZED TO "NOT COPY ON REFERENCE"
;	  SET THIS TO CORRECT BACKING STORE ADDRESS IF CRF PAGE
; 8(SP)  = I/O REQUEST PACKET ADDRESS
; 12(SP) = VIRTUAL ADDRESS (LOW BITS = PAGTYP)
; 16(SP) = SVAPTE, GLOBAL IF NOT GBL CRF, PROCESS IF NOT GBL OR IF GBL CRF
;
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>,(R3),R1 ;R1 = PROT AND OWN
	BICL3	R1,(R3),R2		;R2 = TYP1 ! TYP0 ! PGFLVB
	BISL3	R0,R1,(R3)		;PTE = PROT ! OWN ! PFN = TRANSITION PTE
	BBSC	#PTE$V_TYP1,R2,20$	;BRANCH IF PAGE FILE OR SECTION
;
; GLOBAL COPY ON REFERENCE PAGE
;
	MOVL	(SP)+,R3		;GET MASTER PAGE TABLE ENTRY ADDRESS
	BISL3	#PFN$M_GBLBAK,R2,(SP)	;GBL BACKING STORE ADR IN CRF INDICATOR
	PUSHL	(R3)			;SAVE MASTER PAGE TABLE ENTRY CONTENTS
	EXTZV	#PFN$V_BAK,#PFN$S_BAK,(R3),R2 ;GET ADR FROM MASTER PTE
	BRB	25$			;TO COPY ON REFERENCE SECTION LOGIC
;
; PAGE FILE OR SECTION ADDRESS
;
20$:	BBC	#PTE$V_TYP0,R2,40$	;BRANCH IF PAGING FILE
	BBC	#PTE$V_CRF,R2,50$	;BRANCH IF NOT CRF
;
; COPY ON REFERENCE SECTION TABLE ENTRY
;
	MOVL	R2,4(SP)		;SAVE BACKING ADDRESS IN CRF INDICATOR
25$:	MOVL	PHD$L_PAGFIL(R5),-	;NULL PAGE FILE ADDRESS
		@W^PFN$AL_BAK[R0]	;"NOT YET ALLOCATED" PAGING FILE ADR
	BISB	#<PFN$M_MODIFY ! PFN$C_RDINPROG>,-
		@W^PFN$AB_STATE[R0]	;FORCE MODIFY BIT, READ IN PROGRESS
	BRB	60$
;
; PAGING FILE BACKING STORE ADDRESS
;
40$:	MOVL	R5,R1
	TSTL	(SP)			;IS IT GLOBAL
	BEQL	45$			;NO
	MOVAL	@W^MMG$GL_SYSPHD,R1	;GET SYSTEM HEADER
45$:	BISL	PHD$L_PAGFIL(R1),R2	;SET PAGE FILE INDEX
;
; SECTION TABLE BACKING STORE ADDRESS
;
50$:	BISB	#PFN$C_RDINPROG,@W^PFN$AB_STATE[R0] ;READ IN PROGRESS
	MOVL	R2,@W^PFN$AL_BAK[R0]	;STORE BACKING STORE ADDRESS
;
; R0 = PFN
; R2 = BACKING STORE ADDRESS
; R3 = PAGE TABLE ENTRY ADDRESS, PROCESS ADR IF NOT GLOBAL,
;	GLOBAL ADDRESS IF GLOBAL OR GLOBAL CRF
; R4 = PROCESS PCB IF PROCESS PAGE, PROCESS PAGE TABLE, OR GLOBAL PAGE,
;    = SYSTEM PCB IF SYSTEM PAGE OR GLOBAL PAGE TABLE
; R5 = PROCESS HEADER ADDRESS CORRESPONDING TO THE ABOVE PCB ADDRESS
; 0(SP)  = MASTER PTE CONTENTS IF GLOBAL CRF (>0)
;	 = SLAVE PTE ADDRESS IF GLOBAL NOT CRF (<0)
;	 = 0 IF NOT GLOBAL
; 4(SP)  = 0 IF PAGE IS NOT COPY ON REFERENCE
;	 = BACKING STORE ADDRESS (FOR GBL CRF TOO) IF CRF PAGE
; 8(SP)  = I/O REQUEST PACKET ADDRESS
; 12(SP) = VIRTUAL ADDRESS (LOW BITS = PAGTYP)
; 16(SP) = SVAPTE, GLOBAL IF NOT GBL CRF, PROCESS IF NOT GBL OR IF GBL CRF
;
60$:	MOVL	8(SP),R1		;ADDRESS OF I/O REQUEST PACKET
	MOVL	FP,FP_SAV(R1)		;SAVE A REGISTER
	MOVL	R1,FP			;USE THIS FOR CLUSTER CONTEXT
	MOVQ	R4,PCB_SAV(FP)		;SAVE PCB, PHD ADDRESSES
	TSTL	(SP)			;LESS THAN 0 IF GLOBAL PAGE
	BEQL	70$			;BRANCH IF NOT GLOBAL PAGE
	BGTR	65$			;BRANCH IF GLOBAL CRF
	MOVAL	L^MMG$AL_SYSPCB,R4	;USE SYSTEM PCB FOR GLOBAL PAGES
					;WANT THE PRIORITY FROM IT
65$:	MOVAL	@W^MMG$GL_SYSPHD,R5	;SYSTEM PROCESS HEADER ADDRESS
;
; IF THE BACKING STORE ADDRESS IN R2 IS A GLOBAL ADDRESS, THEN R3 IS THE MASTER PTE
; AND R5 IS THE SYSTEM PROCESS HEADER, OTHERWISE R3 IS THE PROCESS PTE
; ADDRESS AND R5 IS THE PROCESS HEADER ADDRESS.
;
70$:	MOVQ	R2,PTEDAT(FP)		;SAVE PTE DATA, AND ADDRESS

	ASSUME	ASTPRM EQ AST+4
	MOVQ	(SP)+,AST(FP)		;STORE PARAMETERS TO IOPOST IN IRP
;
; FETCH THE TRANSFER PRIORITY FROM PROCESS PCB IF PROCESS PAGE,
; PROCESS PAGE TABLE, OR GLOBAL CRF PAGE.  USE SYSTEM PRIORITY
; IF SYSTEM PAGE, GLOBAL PAGE, OR GLOBAL PAGE TABLE.
;
	MOVB	PCB$B_PRIB(R4),PRI(FP)	;STORE PRIORITY OF TRANSFER IN IRP
	MOVL	@W^PFN$AL_BAK[R0],BAK(FP) ;SAVE BACKING STORE ADDRESS
	BICB3	#^C<PFN$M_MODIFY ! PFN$M_LOC>,- ;AND STATE BYTE INFORMATION
		@W^PFN$AB_STATE[R0],STATE(FP) ;FROM PFN DATA OF FIRST PAGE
	CLRL	(SP)			;THROUGH WITH IRP ADDRESS, USE FOR SCRATCH
					;WILL BE PAGE TABLE FAULT CLUSTER IF PPGTBL
	CLRL	PHVREFCADR(FP)		;ADDRESS OF PROCESS HEADER REF CNT IF PPGTBL

	ASSUME	PFN$C_PROCESS EQ 0
	ASSUME	PFN$C_SYSTEM  EQ 1
	ASSUME	PFN$C_GLOBAL  EQ 2
	ASSUME	PFN$C_GBLWRT  EQ 3
	ASSUME	PFN$C_PPGTBL  EQ 4
	ASSUME	PFN$C_GPGTBL  EQ 5
	CMPZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,- ;IF PAGE TABLE PAGE
		4(SP),#PFN$C_PPGTBL	;THEN SEPARATE CLUSTER FACTOR
	BLSS	90$			;BRANCH IF NOT PAGE TABLE
	BGTR	80$			;BRANCH IF GLOBAL PAGE TABLE
;
; MUST RECORD A PROCESS HEADER REFERENCE FOR PAGE READ OF PROCESS HEADER PAGE
;
	MOVZWL	PHD$W_PHVINDEX(R5),R1	;PROCESS HEADER VECTOR INDEX
	MOVAW	@W^PHV$GL_REFCBAS[R1],R1 ;ADDRESS OF PROCESS HEADER REF CNT
	INCW	(R1)			;COUNT ANOTHER REFERENCE
	MOVL	R1,PHVREFCADR(FP)	;SAVE ADDRESS FOR CLUSTERING CODE
	MOVB	PHD$B_PGTBPFC(R5),(SP)	;GET PAGE TABLE CLUSTER FACTOR
	BNEQ	90$			;BRANCH IF SPECIFIED
80$:	MOVL	#1,(SP)			;INDICATE NO CLUSTERING
90$:	BSBW	MMG$INIBLDPKT		;SET UP REGISTERS TO CALL BUILDPKT
	BBS	#EXE$V_NOCLUSTER,W^EXE$GL_FLAGS,110$ ;BRANCH IF CLUSTERING DISABLED
	MOVQ	PCB_SAV(FP),R4		;RECOVER PCB, PHD ADDRESSES

	ASSUME	SEC$B_PFC EQ PFL$B_PFC
	MOVB	SEC$B_PFC(R1),1(SP)	;PAGE FAULT CLUSTER FROM
					;SECTION OR PAGE FILE CONTROL BLOCK
	MOVZBL	(SP),R1			;SEE IF PAGE TABLE CLUSTER SPECIFIED
	BGTR	100$			;BRANCH IF SPECIFIED
	MOVZBL	1(SP),R1		;SEE IF PAGE FILE OR SECTION TABLE
					;CLUSTER WAS SPECIFIED
	BGTR	100$			;BRANCH IF IT WAS
	MOVZBL	PHD$B_DFPFC(R5),R1	;DEFAULT FROM PROCESS HEADER
					;PROCESS IF PROCESS OR GLOBAL PAGE
					;SYSTEM IF SYSTEM PAGE
100$:	CMPL	R1,#1			;CLUSTER OF 1?
	BLEQ	110$			;BRANCH IF YES
	ADDL	#4,SP			;CLEAN OFF CLUSTER FACTOR SCRATCH
	BRW	TRY_TO_CLUSTER		;GO TRY TO CLUSTER
110$:	MOVL	#1,R1			;ONE PAGE READ
	ADDL	#8,SP			;CLEAN OFF VIRTUAL ADDRESS
	MOVL	(SP)+,R3		;SVAPTE FROM PFN$AL_PTE
;
; R0 = VBN, R1 = PAGE COUNT, R2 = WINDOW, R3 = SVAPTE, FP = IRP
;
QUEUE_PAGE_READ:

	INCL	W^PMS$GL_PREADIO	;COUNT PAGE READ I/O REQUESTS (SYSTEM)
	ADDL	R1,W^PMS$GL_PREADS	;AND THE NUMBER OF PAGES READ
	MOVL	W^SCH$GL_CURPCB,R4	;PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	;PHD ADDRESS
	INCL	PHD$L_PGFLTIO(R5)	;COUNT PAGE READ I/O REQUESTS (PROCESS)
	ASHL	#9,R1,R1		;FORM BYTE COUNT TO TRANSFER
	MOVL	FP,R5			;I/O PACKET ADDRESS
	MOVL	FP_SAV(R5),FP		;RESTORE SAVED REGISTER

;
; R0 = VBN
; R1 = NUMBER OF BYTES TO READ
; R2 = WINDOW ADDRESS
; R3 = SVAPTE (MASTER IF GLOBAL, SLAVE IF GLOBAL CRF)
; R4 = PROCESS PCB ADDRESS
; R5 = I/O REQUEST PACKET ADDRESS
;
; IRP$L_AST(R5)
;    = MASTER PTE CONTENTS IF GLOBAL CRF (>0)
;    = SLAVE PTE ADDRESS IF GLOBAL NOT CRF (<0)
;    = 0 IF NOT GLOBAL
; IRP$L_ASTPRM(R5)
;    = BACKING STORE ADDRESS IF CRF PAGE (GBLBAK SET IF GBL CRF)
;    = 0 IF NOT CRF PAGE
; IRP$B_PRI(R5) = DESIRED TRANSFER PRIORITY
;
	BSBW	EXE$BUILDPKTR		;BUILD AND QUEUE THE I/O PACKET
;
; THE FOLLOWING WAITS THE PROCESS AT THE FAULTING MODE
;
PROCPAG:
	MOVAQ	W^SCH$GQ_PFWQ,R0	;PAGE FAULT WAIT QUEUE ADDRESS
	BSBB	MMG$PGFLTWAIT_1		;PUT PROCESS ON PAGE FAULT WAIT QUEUE
PGFEXIT:
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS SAVED BY PAGE FAULT
	ADDL	#8,SP			;CLEAN OFF THE EXCEPTION PARAMETERS
;
; STACK NOW CONTAINS JUST THE FAULT PC, PSL PAIR
;
MMG$SVPCTX::
	SVPCTX				;SAVE PROCESS CONTEXT
	MOVL	W^SCH$GL_CURPCB,R4	;GET PCB ADDRESS
	BRW	SCH$WAITM		;JOIN COMMON WAIT CODE FOLLOWING SVPCTX
;
; NO FREE PAGES AVAILABLE ON THE FREE PAGE LIST, MUST WAIT
;
FREEPAGEWAIT:
	MOVAQ	W^SCH$GQ_FPGWQ,R0	;WAIT ON FREE PAGE WAIT QUEUE
	BRB	FREEPAGEWAIT1
;
; WAIT FOR RESOURCE IN R1 TO BECOME AVAILABLE
;
RESOURCEWAIT:
	BSBB	MMG$RESRCWAIT		;SET UP TO WAIT FOR THE RESOURCES
	BRB	PGFEXIT			;AND EXIT TO THE SCHEDULER
;
; FAULT FOR PAGE WHICH IS ALREADY ON THE WAY INTO MEMORY
;
READINPROG:
	POPR	#^M<R2,R3>		;R2=VA (LOW BITS = PAGTYP), R3=SVAPTE
	ASSUME	PFN$C_PROCESS EQ 0
	BITB	#PFN$M_PAGTYP,@W^PFN$AB_TYPE[R0] ;PROCESS PAGE?
	BEQL	PROCPAG			;BRANCH IF YES
	BBSS	#PFN$V_COLLISION,@W^PFN$AB_TYPE[R0],10$ ;COLLISION OCCURRED
10$:
	MOVAQ	W^SCH$GQ_COLPGWQ,R0	;COLLISION PAGE WAIT QUEUE
FREEPAGEWAIT1:
	BSBB	MMG$PGFLTWAIT_1		;PLACE PROCESS ON THE COLLISION QUEUE
	BRB	PGFEXIT			;EXIT TO THE SCEDULER
;
; WAIT FOR RESOURCE IN R1 TO BECOME AVAILABLE
; R0,R1,R2,R3 ALTERED, R4 RETURNED WITH CURRENT PCB ADDRESS
;
	.ENABL	LSB
MMG$RESRCWAIT::
	MOVL	W^SCH$GL_CURPCB,R4	;R4 = CURRENT PCB ADDRESS
	MOVL	R1,PCB$L_EFWM(R4) 	;SET RESOURCE NEEDED
	BBSSI	R1,W^SCH$GL_RESMASK,10$ ;NOTE SOMEONE WAITING
10$:
	MOVAQ	W^SCH$GQ_MWAIT,R0	;WAIT ON MISCELLANEOUS QUEUE
	BRB	20$			;GO WAIT THIS PROCESS
MMG$PGFLTWAIT_1:
	MOVL	W^SCH$GL_CURPCB,R4	;MUST WAIT THE PROCESS PCB
MMG$PGFLTWAIT::
20$:
	INCW	WQH$W_WQCNT(R0)		;COUNT THIS PROCESS WAITING
	INSQUE	(R4),(R0)		;QUEUE THIS PCB
	MOVW	WQH$W_WQSTATE(R0),PCB$W_STATE(R4) ;SET WAIT STATE IN PCB
	RSB

	.DSABL	LSB

	.SBTTL	FORM A CLUSTER OF PAGES TO READ
;
; R0 = VBN IN FILE OF FIRST PAGE TO READ
; R1 = DESIRED CLUSTER SIZE
; R2 = WINDOW CONTROL BLOCK ADDRESS
; R4 = PCB ADDRESS, PROCESS IF PROCESS OR GLOBAL PAGE, SYSTEM IF SYSTEM PAGE
; R5 = PHD ADDRESS, PROCESS IF PROCESS OR GLOBAL PAGE, SYSTEM IF SYSTEM PAGE
; FP = I/O REQUEST PACKET ADDRESS
; 0(SP) = VIRTUAL ADDRESS (LOW BITS = PAGTYP)
; 4(SP) = SVAPTE FROM PFN$AL_PTE
;

	.ENABL	LSB

TRY_TO_CLUSTER:
	MOVL	(SP)+,VA(FP)		;SAVE VIRTUAL ADDRESS
	MOVL	R0,VBN(FP)		;SET VIRTUAL BLOCK NUMBER

	ASSUME	COUNT EQ CLUSTER+1
	BISW3	#^X0100,R1,CLUSTER(FP)	;SET COUNT AND CLUSTER
	MOVL	R2,WINDOW(FP)		;WINDOW ADDRESS
;
; PUT PTEDAT INTO FORM OF TYP1 ! TYP0 ! PGFLVB
;
	ASSUME	PFN$V_PGFLX GE 24
	ASSUME	PTE$V_TYP1 GE 24
	MOVB	#PTE$M_TYP1@-24,PTEDAT+3(FP) ;TURN TYP1 BACK ON, CLEAR PAGE FILE INDEX
	MOVL	AST(FP),R3		;PROCESS PTE ADR IF GBL NOT CRF
	BEQL	30$			;BRANCH IF NOT GLOBAL PAGE
	BLSS	10$			;BRANCH IF GBL NOT CRF
;
; GLOBAL COPY ON REFERENCE PAGE
;
	MOVL	(SP),R3			;PROCESS PTE ADR WHEN GBL CRF
	MOVL	ASTPRM(FP),R2		;GPTX PTE CONTENTS FOR THIS CASE
	BRB	20$

CLU_END1:
	BRW	CLU_END

;
; GLOBAL PAGE NOT COPY ON REFERENCE
;
10$:	MOVL	(R3),R2			;GPTX FROM PROCESS PTE
20$:	BICL	#^C<PTE$M_TYP1 ! PTE$M_TYP0 !- ;ISOLATE PAGE TYPE
		PTE$M_GPTX>,R2		;AND GPTX BITS

	ASSUME	GPTX_PTE EQ GPTX+4
30$:	MOVQ	R2,GPTX(FP)		;SET GPTX AND GPTX_PTE
	MOVL	#1,INC1(FP)		;INIT TO SCAN FORWARDS

	.DSABL	LSB

CLU_INI_INC:
	ASHL	#2,INC1(FP),INC4(FP)	;+ OR - 4
	ASHL	#9,INC1(FP),INC512(FP)	;+ OR - 512
CLU_NXT:
	ADDL3	INC4(FP),SVAPTE(FP),R3	;NEXT PTE TO CHECK
	MOVL	R3,SVAPTE(FP)		;UPDATE CONTEXT
	BBS	#PTE$V_TYP0,PTEDAT(FP),20$ ;BRANCH IF SECTION ADDRESS
	ADDL	INC1(FP),PTEDAT(FP)	;INCREMENT PAGE FILE ADDRESS
20$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;CHECK THAT PTE IS RESIDENT
	TSTL	@W^MMG$GL_SPTBASE[R1]	;BY MAKING SURE ITS SPTE IS VALID
	BGEQ	CLU_END1		;BRANCH IF IT ISN'T
	BICL3	#^C<PTE$M_VALID !-	;GET VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! -;PAGE TYPE BITS
		PTE$M_PGFLVB>,(R3),R0	;AND PAGE FILE/GPTX BITS FROM PTE
	CMPL	R0,PTEDAT(FP)		;MUST AGREE IF THIS PAGE IS IN THE CLUSTER
	BNEQ	CLU_END1		;BRANCH IF AT END OF CLUSTER
	TSTL	GPTX_PTE(FP)		;WAS THAT THE MASTER PTE FOR A GLOBAL?
	BEQL	60$			;BRANCH IF NO, IT WAS PROCESS PTE
;
; MUST TEST THAT PROCESS PTE POINTS AT THE GPTX
;
	ADDL3	INC4(FP),GPTX_PTE(FP),R3 ;NEXT PROCESS PTE ADR
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;CHECK THAT THIS PTE IS ACCESSIBLE
	TSTL	@W^MMG$GL_SPTBASE[R1]	;BY MAKING SURE ITS SPTE IS VALID
	BGEQ	CLU_END1		;BRANCH IF IT ISN'T
	BICL3	#^C<PTE$M_VALID ! -	;GET VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! -;PAGE TYPE BITS
		PTE$M_PGFLVB>,(R3),R0	;AND PGFLVB/GPTX FROM PTE
	ADDL3	INC1(FP),GPTX(FP),R2	;NEXT GLOBAL PAGE TABLE INDEX
	CMPL	R0,R2			;IN THE CLUSTER?
	BNEQ	CLU_END1		;BRANCH IF NOT

	ASSUME	GPTX_PTE EQ GPTX+4
	MOVQ	R2,GPTX(FP)		;UPDATE GPTX
;
; R1 = SPT INDEX FOR PAGE TABLE PAGE
; R3 = PROCESS PTE ADDRESS
;
60$:	PUSHR	#^M<R1,R3>		;SAVE PROCESS PTE ADR, SPT INDEX
	BSBW	MMG$FREWSLE		;GET A FREE WORKING SET LIST ENTRY
	MOVQ	(SP)+,R2		;RESTORE PROCESS PTE ADR, SPT INDEX
	BLBC	R0,CLU_END_RESRC1	;IF CANNOT GET ONE, END THE CLUSTER
;
; MUST CHECK THE SPT ENTRY FOR PROCESS PAGE TABLE IS STILL VALID
; FREWSLE MIGHT HAVE DISCARDED IT FROM THE WORKING SET.
;
	TSTL	@W^MMG$GL_SPTBASE[R2]	;IS SPT ENTRY FOR PT STILL VALID
	BGEQ	CLU_END_RESRC		;BRANCH IF NOT
	ADDL3	INC512(FP),VA(FP),R2	;NEXT VIRTUAL ADDRESS
	MOVL	R2,VA(FP)		;UPDATE THE CONTEXT
	BSBW	MMG$ININEWPFN		;ALLOC AND INIT A PFN
	TSTL	R0			;IF NO PFN'S AVAILABLE
	BLSS	CLU_END_RESRC		;THEN END THE CLUSTER
	INCB	COUNT(FP)		;COUNT ANOTHER PAGE IN THE CLUSTER
	MOVL	PHVREFCADR(FP),R1	;PROCESS HEADER REF CNT ADR
					;IF THIS IS A PROCESS PAGE TABLE PAGE
	BEQL	70$			;BRANCH IF NOT A PROCESS PAGE TABLE PAGE
	INCW	(R1)			;COUNT ANOTHER PROCESS HEADER REFERENCE
70$:	MOVL	@W^PFN$AL_PTE[R0],R3	;PROCESS PTE ADR IF NOT GLOBAL OR IF GBL CRF
					;GLOBAL PTE ADR IF GLOBAL NOT CRF
	INCW	@W^PFN$AW_REFCNT[R0]	;SECOND REFERENCE FOR I/O IN PROGRESS
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>,(R3),R1 ;PROTECTION AND OWNER FIELDS
	BISL3	R0,R1,(R3)		;FORM TRANSITION PTE FORMAT
	MOVL	BAK(FP),R2		;BACKING STORE FROM PREV PFN
	BBS	#PTE$V_TYP0,R2,80$	;BRANCH IF SECTION ADDRESS
	ASHL	#32-PFN$S_BAK,R2,R1	;IF NOT A NULL PAGE FILE ADDRESS
	BEQL	80$
	ADDL	INC1(FP),R2		;THEN INCREMENT THE ADDRESS
	MOVL	R2,BAK(FP)		;AND UPDATE THE CONTEXT
80$:	MOVL	R2,@W^PFN$AL_BAK[R0]	;SET BACKING STORE ADR FOR THIS PFN
	BISB	STATE(FP),@W^PFN$AB_STATE[R0] ;USE STATE FROM PREV PFN
	CMPB	COUNT(FP),CLUSTER(FP)	;IS CLUSTER FULL?
	BGEQ	CLU_END_RESRC		;BRANCH IF YES, QUEUE THE READ
	BRW	CLU_NXT			;NO, TRY FOR ANOTHER PAGE
CLU_END_RESRC1:
	BRB	CLU_END_RESRC
;
; END OF CLUSTER
;
CLU_END:
	CMPB	COUNT(FP),#1		;IF AT LEAST 2 PAGES IN CLUSTER
	BGTR	CLU_END_RESRC		;THEN READ THE CLUSTER
	MNEGL	INC1(FP),INC1(FP)	;OTHERWISE TRY TO SCAN BACKWARDS
	BGTR	CLU_END_RESRC		;UNLESS ALREADY TRIED THAT
	SUBL	#4,SVAPTE(FP)		;BACK TO STARTING SVAPTE
	BBS	#PTE$V_TYP0,PTEDAT(FP),20$ ;BRANCH IF SECTION PAGE
	DECL	PTEDAT(FP)		;BACK TO ORIG PAGE FILE VBN
20$:	BRW	CLU_INI_INC
;
; SET UP TO DO THE PAGE READ
;
CLU_END_RESRC:
	MOVL	(SP)+,R3		;GET PTE ADR OF FIRST PFN IN CLUSTER
	MOVL	VBN(FP),R0		;AND ITS ASSOCIATED VBN IN THE FILE
	MOVZBL	COUNT(FP),R1		;NUMBER OF PAGES IN THE CLUSTER
	TSTL	INC1(FP)		;IF CLUSTER WENT BACKWARDS
	BGTR	20$
	SUBL3	R1,#1,R2		;-(COUNT-1)
	ADDL	R2,R0			;ADJUST FILE VBN
	MOVAL	(R3)[R2],R3		;AND PTE ADR
	MOVL	AST(FP),R4		;PROCESS PTE ADDRESS FOR GLOBAL PAGE?
	BEQL	20$			;BRANCH IF NOT GLOBAL
	BLSS	10$			;BRANCH IF GLOBAL BUT NOT CRF
	ADDL	R2,ASTPRM(FP)		;ADJUST GLOBAL BACKING STORE ADDRESS
	BRB	20$
10$:	MOVAL	(R4)[R2],AST(FP)	;ADJUST PROCESS PTE ADDRESS FOR GLOBAL PAGE
20$:	MOVL	WINDOW(FP),R2		;GET WINDOW ADDRESS
	BRW	QUEUE_PAGE_READ		;GO QUEUE THE PAGE READ

	.SBTTL	DEMAND ZERO PAGE
;
; MUST WAIT FOR FREE PAGES TO BECOME AVAILABLE
;
DZROFPGWAIT_5:
	ADDL	#<5*4>,SP		;CLEAN OFF 5 LONG WORDS
	BRW	FREEPAGEWAIT		;AND GO WAIT FOR A FREE PAGE
;
; THIS IS A DEMAND ZERO FORMAT PAGE TABLE ENTRY, R0 = 0
;
DZRO_PTE:
	CLRL	R3			;NO GLOBAL MASTER PTE ADDRESS
	CLRL	R1			;NO MASTER PTE CONTENTS
;
; R0 = BACKING STORE ADDRESS, TYP1 ! TYP0 ! PGFLVB
; R1 = MASTER PAGE TABLE ENTRY CONTENTS IF GLOBAL, 0 IF NOT
; R3 = GLOBAL PAGE TABLE ENTRY ADDRESS IF GLOBAL, 0 IF NOT
; 0(SP) = FAULT VA (LOW BITS = PAGTYP)
; 4(SP) = CORRESPONDING SVAPTE
;
DZRO_GBL_SEC:
	PUSHR	#^M<R0,R1,R3>		;SAVE GBL PTE ADR, GBL PTE CONTENTS,
					;AND BACKING STORE ADDRESS
	MOVQ	12(SP),R2		;R2=VA, R3=SVAPTE
	BSBW	MMG$ININEWPFN		;ALLOCATE AND INIT A PFN
	TSTL	R0			;SEE IF A PFN WAS ALLOCATED
	BLSS	DZROFPGWAIT_5		;BRANCH IF HAVE TO WAIT
	BISB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ;MARK PAGE ACTIVE
	MOVL	PHD$L_PAGFIL(R5),R2	;ASSUME NULL PAGE FILE BACKING STORE
	MOVL	(SP)+,R1		;GET BACKING STORE ADDRESS
	BEQL	20$			;BRANCH IF DEMAND ZERO FORMAT
	BBS	#PTE$V_CRF,R1,20$	;BRANCH IF DZRO, CRF SECTION
	BBS	#PTE$V_TYP1,R1,10$	;CHECK FOR GLOBAL WITH PAGE FILE BACING STORE
	BBCC	#PTE$V_TYP0,R1,10$
; PAGE FILE BACKING STORE GLOBAL SECTION
	MOVAL	@W^MMG$GL_SYSPHD,R2	;GET SYSTEM HEADER
	MOVL	PHD$L_PAGFIL(R2),R2	;BACKING STORE ADDRESS
	BRB	20$
10$:	BICL3	#<PTE$M_DZRO ! ^C<PFN$M_BAK>>,R1,R2 ;BACKING STORE ADR
					;WITH DZRO SHUT OFF
20$:	MOVL	R2,@W^PFN$AL_BAK[R0]	;STORE THE BACKING STORE ADDRESS
;
;  0(SP) = MASTER PTE CONTENTS IF GLOBAL, 0 IF NOT
;  4(SP) = MASTER PTE ADDRESS  IF GLOBAL, 0 IF NOT
;  8(SP) = VIRTUAL ADDRESS (LOW BITS = PAGE TYPE)
; 12(SP) = SYSTEM VIRTUAL ADDRESS OF PROCESS PAGE TABLE ENTRY
;
	MOVQ	8(SP),R2		;R2=VA (LOW BITS = PAGTYP), R3=SVAPTE
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>, -
		(R3),-(SP)		;PROTECTION AND OWNER FROM PTE
	BISL3	#<PTE$M_VALID ! PTE$C_KW ! -
		PTE$M_MODIFY>,R0,(R3)	;MAKE PAGE KERNEL WRITE FOR ZEROING
	SUBL3	R5,R3,-(SP)		;SAVE BYTE INDEX TO PTE
	CMPZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,- ;IF THIS IS NOT A PROCESS PAGE
		R2,#PFN$C_PROCESS	;THEN DON'T LOWER IPL TO ZERO PAGE
	BNEQ	22$			;STAY AT HIGHER IPL IF NOT PROCESS PAGE

	SETIPL	#IPL$_ASTDEL		;SWAPPABLE WHILE ZEROING THE PAGE

22$:
	.IF	GT,CA$_MEASURE
	INCL	W^PMS$GL_DZROFLTS	;COUNT DEMAND ZERO PAGE FAULTS
	.ENDC

;
; ***** BE AWARE THAT THE FOLLOWING CLRB ASSUMES THAT BIT 8 IS NOT
; ***** IN USE FOR ANY OF THE PAGE TYPE FLAGS, ETC.
;
	CLRB	R2			;CLEAR OUT THE PAGE TYPE
	MOVC5	#0,(R4),#0,#^X200,(R2)	;ZERO THE PAGE, PCB ADDRESS TO R1
	MOVL	R1,R4			;RECOVER PCB ADDRESS
	SETIPL	#IPL$_SYNCH		;NOT SWAPPABLE WHILE COMPLETING THE FAULT
	ADDL3	PCB$L_PHD(R4),(SP)+,R3	;RE-BIAS BYTE INDEX TO PTE TO GET SVAPTE
	BICL3	#^C<PTE$M_VALID ! PTE$M_MODIFY ! -
		PTE$M_PFN>,(R3),R0	;EVEN PFN MIGHT HAVE CHANGED
	BISL3	R0,(SP)+,(R3)		;SET PTE WITH CORRECT PROT AND OWNER
	INVALID	8(SP),R2		;INVALIDATE TRANSLATION BUFFER
	MOVQ	(SP),R1			;SEE IF DZRO GLOBAL
	BEQL	60$			;BRANCH IF NOT, BOTH ARE ZERO
	CMPL	R1,(R2)			;STILL THE SAME PTE CONTENT?
	BEQL	40$			;BRANCH IF YES, NO RACE TO ZERO THE PAGE
;
; MORE THAN ONE PROCESS STARTED TO ZERO THIS GLOBAL DEMAND ZERO PAGE
; THIS PROCESS LOST THE RACE, CLEAN UP AND REFAULT.
;
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ;ISOLATE THE PFN
	MOVL	R0,(SP)			;AND SAVE IT
	MOVL	PCB$L_PHD(R4),R5	;GET PROCESS HEADER ADDRESS
	INCW	@W^PFN$AW_REFCNT[R0]	;RELEASE WSLE AND SHRCNT, BUT NOT PFN
	MOVZWL	PHD$W_WSNEXT(R5),R1	;WORKING SET LIST INDEX
	MOVL	8(SP),R2		;VIRTUAL ADDRESS (LOW BITS = PAGTYP)
	BSBW	MMG$FREWSLX		;FREE THE WORKING SET LIST ENTRY
	BLBS	R0,30$			;BRANCH IF SUCCESSFUL
;
; FREWSLX COULD ONLY RETURN FAILURES STATUS IF PAGE FILE BACKING STORE
; NEEDED TO BE RESERVED AND THERE WAS NONE AVAILABLE.  THIS PAGE ALREADY
; HAS BACKING STORE, SO THIS CANNOT HAPPEN.
;
	BUG_CHECK FREWSLX,FATAL

30$:	POPR	#^M<R0,R3>		;GET PFN AND MASTER PTE ADDRESS
	BSBW	MMG$RLPFNSAVPTE		;RELEASE PFN, SAVE PTE CONTENTS
	ADDL	#8,SP			;CLEAN OFF VA, PROCESS PTE
	BRB	PGFCOMPLETE
;
; GLOBAL DEMAND ZERO PAGE, MAKE MASTER PTE VALID TOO
;
40$:	BICL	#^C<PTE$M_PROT ! PTE$M_OWN>,R1 ;MASTER PTE PROTECTION AND OWNER
	BISL3	R0,R1,(R2)		;SET MASTER PTE VALID
60$:	ADDL	#4*4,SP			;CLEAN OFF 4 LONG WORDS
	.dsabl	lsb
PGFCOMPLETE:
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE THE REGISTERS
	ADDL	#8,SP			;CLEAN OFF THE EXCEPTION PARAMETERS
	REI				;AND RETURN FROM THE EXCEPTION

	.SBTTL	FREE, MODIFIED, OR BAD PAGE LIST, RELEASE PENDING
;
; THIS IS A FAULT OFF THE FREE, MODIFIED, OR BAD PAGE LISTS
; R0 = PFN, R2 = LISTID,
; 0(SP) = VA (LOW BITS = PAGTYP), 4(SP) = SVAPTE
;
	.ENABL	LSB
PFNLIST:
	BSBW	MMG$REMPFN		;REMOVE PFN FROM LIST
WRITEINPROG:
RELEASEPEND:
	MOVQ	(SP),R2			;R2 = VA, R3 = SVAPTE
	BSBW	MMG$MAKEWSLE		;MAKE A WORKING SET LIST ENTRY
	MOVQ	(SP)+,R2		;R2=VA, R3=SVAPTE
;
; SET PAGE ACTIVE AND VALID
;
	MOVL	@W^PFN$AL_PTE[R0],R1	;GET MASTER PTE ADDRESS

	ASSUME	PFN$V_DELCON EQ PFN$V_LOC+PFN$S_LOC+1 ;DELCON IS 2ND BIT TO LEFT OF LOC
					;BIT IN BETWEEN IS FOR LOC EXPANSION
	INSV	#PFN$C_ACTIVE,#PFN$V_LOC,#PFN$S_LOC+2,- ;SET PAGE ACTIVE
		@W^PFN$AB_STATE[R0]	;AND CLEAR DELCON
	BBSS	#PTE$V_VALID,(R1),50$	;SET VALID BIT
50$:	CMPB	R2,#WSL$C_GLOBAL	;GLOBAL OR PAGE TABLE PAGE?
	BGEQ	100$			;BRANCH IF YES
60$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE SAVED REGISTERS
	ADDL	#8,SP			;CLEAN OFF THE EXCEPTION PARAMETERS
	REI				;AND RETURN FROM FAULT
;
; GLOBAL PAGE OR PAGE TABLE PAGE
;
100$:	CMPB	R2,#WSL$C_PPGTBL	;PROCESS PAGE TABLE PAGE?
	BGEQ	120$			;BRANCH IF PROCESS OR GLOBAL PAGE TABLE
;
; GLOBAL PAGE
;
	BICL3	#^C<PTE$M_VALID ! PTE$M_MODIFY ! PTE$M_PFN>,(R1),R1 ;MASTER PTE
;
; R1 = VALID AND PFN BITS TO STORE INTO SLAVE PTE
; R3 = SLAVE PTE ADDRESS
;
SETSLAVEPTE:
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>,(R3),R2 ;PROTECTION AND OWNER FROM SLAVE PTE
	BISL3	R1,R2,(R3)		;STORE THE NEW SLAVE PTE
	BRB	60$			;AND EXIT THROUGH COMMON CODE
;
; PROCESS OR GLOBAL PAGE TABLE
;
120$:	BGTR	60$			;BRANCH IF GLOBAL PAGE TABLE
	PUSHL	R1			;SAVE REGISTER AROUND THE CALL
	BSBW	MMG$DECPHDREF		;ONE LESS LOCK ON HDR SPTE
	POPR	#^M<R1>			;RESTOR REGISTER
	BRB	60$			;AND EXIT THROUGH COMMON CODE

	.DSABL	LSB
;
; FAILED TO READ THE DESIRED PAGE, RELEASE THE PFN AND ISSUE AN EXCEPTION
; R0    = PAGE FRAME NUMBER
; R4    = PROCESS CONTROL BLOCK ADDRESS
; R5    = SYSTEM ADDRESS OF PROCESS HEADER
; 0(SP) = VIRTUAL ADDRESS (LOW BITS = PAGE TYPE)
; 4(SP) = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;
READERR:
	POPR	#^M<R2,R3>		;R2=VA (LOW BITS = PAGTYP), R3=SVAPTE
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R0],R1>,-	;GET WORKING SET LIST INDEX IF NOT GLOBAL
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED

	ASSUME	PFN$C_PROCESS EQ 0
	ASSUME	PFN$C_SYSTEM  EQ 1
	ASSUME	PFN$C_GLOBAL  EQ 2
	ASSUME	PFN$C_GBLWRT  EQ 3
	ASSUME	PFN$C_PPGTBL  EQ 4
	ASSUME	PFN$C_GPGTBL  EQ 5
	CMPV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R2,#PFN$C_GLOBAL ;IS PAGE GLOBAL?
	BLSS	20$			;BRANCH IF NOT
;
; GLOBAL PAGE DOES NOT HAVE WORKING SET LIST INDEX IN WSLX ARRAY
; MUST SCAN THE PROCESS' WORKING SET LIST FOR THE VIRTUAL ADDRESS
;
	SUBL	R5,R3			;UNBIAS SVAPTE, COULD BE SWAPPED HERE
	MOVL	@#CTL$GL_PHD,R5		;USE P1 SPACE HEADER WINDOW
	BSBW	MMG$SCNWSLX		;SCAN FOR THE WORKING SET LIST INDEX
;
; COULD HAVE BEEN SWAPPED IN THE ABOVE ROUTINE, BUT IPL IS BACK AT SYNCH NOW
;
	MOVL	PCB$L_PHD(R4),R5	;RECOVER SYSTEM ADDRESS OF PHD
	ADDL	R5,R3			;REBIAS PTE ADDRESS
	TSTL	R1			;SEE IF FOUND WORKING SET LIST ENTRY
	BEQL	40$			;IF NOT, PAGE WENT AWAY OR SOME OTHER
					;PROCESS WAS THE ORIGINATOR OF THE I/O
20$:	MOVL	(R5)[R1],R2		;FETCH WORKING SET LIST ENTRY
	PUSHR	#^M<R2,R3>		;SAVE VIRTUAL ADDRESS AND PTE ADDRESS
	BSBW	MMG$FREWSLX		;FREE THIS WORKING SET LIST ENTRY
	POPR	#^M<R2,R3>		;RECOVER VA AND SVAPTE
	BLBS	R0,30$			;BRANCH IF SUCCESSFUL
;
; FREWSLX CAN ONLY FAIL IF PAGE FILE NEEDED TO BE ALLOCATED AND IT COULDN'T BE
; THIS CASE IS NOT POSSIBLE HERE.
;
	BUG_CHECK FREWSLX,FATAL
;
; IF THIS PAGE FAULT IS FROM USER OR SUPER MODE THEN ISSUE A
; PAGE READ ERROR EXCEPTION.
;
30$:	CMPZV	#PSL$V_CURMOD,#PSL$S_CURMOD,- ;IF FAULTING MODE IS
		FLTPSL(SP),#PSL$C_SUPER	;USER OR SUPER
	BGEQ	40$			;THEN PAGE READ ERROR EXCEPTION
;
; THIS IS A BAD SITUATION NOW, AN EXCEPTION IN EXEC OR KERNEL MODE WILL
; CRASH THE SYSTEM.  IF THIS PAGE IS OWNED BY USER OR SUPER THEN TRY
; SUBSTITUTING A PAGE OF ZEROS.  THIS SHOULD SATISFY THE SYSTEM CODE WHICH
; IS ACCESSING THE PROCESS PAGE SINCE IT IS PARANOID ABOUT USER SUPPLIED
; DATA.  THE NEW PAGE WILL BE EXEC READ WRITE BUT OWNED BY THE ORIGINAL
; OWNER.  THIS WILL RESULT IN AN ACCESS VIOLATION WHEN THE PAGE IS TOUCHED
; IN USER OR SUPER MODE.
;
	EXTZV	#PTE$V_OWN,#PTE$S_OWN,(R3),R0 ;GET THE PAGE OWNER
	CMPL	R0,#PSL$C_SUPER		;OWNED BY USER OR SUPER?
	BLSS	40$			;BRANCH IF NOT, READ ERROR FOR
					;A CRUCIAL PAGE, ISSUE THE PAGE
					;READ ERROR EXCEPTION, DOWN WE GO.
	SETIPL	#IPL$_ASTDEL		;LOWEST POSSIBLE FAULT IPL
;
; FORM ARGUMENT LIST FOR CRETVA
;
	PUSHL	R2			;VIRTUAL ADDRESS TO CREATE
	PUSHR	#^M<R0,R2>		;ANOTHER COPY OF ADR TO FORM RANGE
					;ACCESS MODE PARAMETER
	MOVB	S^#PRT$C_EW,1(SP)	;SET DESIRED PAGE PROTECTION
	PUSHL	#0			;NULL RETURN ADDRESS
	PUSHAL	8(SP)			;ADDRESS OF RANGE TO CREATE
	CALLS	#5,G^MMG$CRETVA		;KERNEL MODE ENTRY TO CRETVA
					;PRESERVES IPL
					;STRIP OFF INPUT RANGE WHEN DONE
	BRW	PGFCOMPLETE		;FAULT THIS PAGE FROM SCRATCH
40$:	INCW	FLTCTL+2(SP)		;INDICATE PAGE READ ERROR
ACVIOLAT:
	MOVZWL	FLTPSL+2(SP),R0		;GET IPL FROM FAULT PSL
	ENBINT	R0			;AND RESTORE IT
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS SAVED BY PAGE FAULT
	BBCC	#16,(SP),10$		;BRANCH IF ACCESS VIOLATION
	BRW	EXE$PAGRDERR		;ISSUE THE EXCEPTION
10$:	BRW	EXE$ACVIOLAT		;ACCESS VIOATION

	.SBTTL	SCANDEADPT - SCAN A DEAD PAGE TABLE FOR TRANSITION PAGES
;
; INPUTS:
;
;	R2 = VIRTUAL ADDRESS OF PAGE TABLE (LOW BITS = PAGE TYPE)
;	R5 = PROCESS HEADER ADDRESS
;	IPL = SYNCH
;
; OUTPUTS:
;
;	NONE
;
SCANDEADPT:
	SUBW3	PHD$W_PTCNTVAL(R5),PHD$W_PTCNTACT(R5),R0 ;ACTIVE PAGE TABLES
					;THAT DON'T CONTAIN VALID WSLE'S
					;ARE "DEAD PAGE TABLES"
	BLEQ	50$			;BRANCH IF NO DEAD PAGE TABLES
	ADDW	R0,R0			;DOUBLE COUNT FOR WORST CASE PAGE TABLE
	SUBW	PHD$W_WSSIZE(R5),R0	;SUBTRACT OUT CURRENT WSL SIZE
	ADDW	PHD$W_WSDYN(R5),R0	;ADD IN LOCKED ENTRY COUNT
	SUBW	PHD$W_WSLIST(R5),R0	; LOCKED = (WSDYN-WSLIST)
	BLSS	50$			;BRANCH IF SAFE TO POSTPONE DEAD PAGE
					;TABLE SCAN
	SUBL3	PHD$L_P0BR(R5),R2,R0	;BYTE OFFSET FROM FIRST P0 PAGE TABLE
	BLSS	50$			;BRANCH IF PROCESS HEADER PAGE
	ASHL	#-9,R0,R0		;FORM PAGE NUMBER
	ADDL	R5,R0			;ADD IN PHD BASE
	ADDL	PHD$L_PTWSLEVAL(R5),R0	;ADD IN OFFSET TO BYTE ARRAY OF COUNTS
					;OF VALID WSLE'S IN EACH PAGE TABLE
	TSTB	(R0)			;IS THIS A DEAD PAGE TABLE
	BGEQ	50$			;BRANCH IF NOT
;
; R1,R2,R3 ARE PRESERVED UP TO THIS POINT
;
	MOVW	R1,PHD$W_WSNEXT(R5)	;UPDATE NEXT POINTER
	INCL	W^PMS$GL_DPTSCN		;COUNT THESE SCANS
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R0 ;PAGE NUMBER OF THE PT IN SYSTEM SPACE
	BICL3	#^C<PTE$M_VALID ! PTE$M_PFN>,- ;GET PFN AND VALID BIT
		@W^MMG$GL_SPTBASE[R0],R0	;FROM SPT ENTRY FOR THE PAGE TABLE
	BBCC	#PTE$V_VALID,R0,40$	;CLEAR VALID BRANCH IF IT WAS CLEAR
	PUSHL	#0			;FLAG FOR MODIFIED PAGE WRITER NEEDED
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_SHRCNT[R0],-(SP) >,-	;NUMBER OF TRANSITION PAGES
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BEQL	40$			;IF NONE, INCONSISTENT
	BICW	#VA$M_BYTE,R2		;START SCANNING PT AT BEGINNING
	MOVZBL	#128,R3			;AT MOST 128 PTE'S
20$:	BICL3	#^C<PTE$M_VALID ! -	;GET THE VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! - ;PTE TYPE BITS
		PTE$M_PFN>,(R2)+,R0	;AND THE PFN FROM THE PTE
	BEQL	30$			;BRANCH IF DEMAND ZERO PAGE
	ASHL	#-PTE$V_TYP0,R0,R1	;VALID, TYP1, TYP0 ALL 0 IF TRANSITION
	BEQL	60$			;BRANCH IF TRANSITION PAGE
30$:	SOBGTR	R3,20$			;LOOP THROUGH THE PAGE TABLE
	BRB	100$			;ALL DONE, CNT=# I/O REQ OUTSTANDING
40$:	BUG_CHECK SCANDEADPT,FATAL	;SPT ENTRY FOR PAGE TABLE NOT VALID

50$:	MOVL	#1,R0			;SET CONTINUE RATHER THAN RESTART
	RSB
					;SHRCNT FOR PAGE TABLE IS 0
					;DIDN'T FIND SHRCNT TRANSITION PAGES
					;BEFORE RUNNING OFF THE END OF THE PT
;
; THIS IS A TRANSITION PAGE
;
60$:	PUSHR	#^M<R2,R3>		;SAVE THESE REGISTERS
	EXTZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,- ;GET PAGE LOCATION
		@W^PFN$AB_STATE[R0],R2	;FROM THE STATE BYTE
	CMPL	R2,#PFN$C_MFYPAGLST	;ON MODIFIED OR FREE PAGE LIST
	BGTR	90$			;BRANCH IF NOT ON EITHER
	BEQL	80$			;BRANCH IF ON MODIFIED PAGE LIST
;
; PAGE IS ON THE FREE PAGE LIST
;
	BSBW	MMG$REMPFN		;ON FREE LIST, REMOVE IT
	BISB	#PFN$M_DELCON,@W^PFN$AB_STATE[R0] ;FORCE DELETE CONTENTS
	BSBW	MMG$RELPFN		;AND RELEASE THE PAGE
	BRB	90$
;
; PAGE IS ON MODIFIED PAGE LIST
;
80$:	BISB	#PFN$M_DELCON,@W^PFN$AB_STATE[R0] ;DELETE CONTENTS AFTER WRITING
	BISB	#1,12(SP)		;FLAG MODIFIED PAGE RELEASE NEEDED
90$:	POPR	#^M<R2,R3>		;RESTORE SAVE REGISTERS
	SOBGTR	(SP),30$		;COUNT DOWN THE TRANSITION COUNT
100$:	POPR	#^M<R0,R1>		;CLEAN OFF THE EXHAUSTED COUNT AND FLAG
	BLBC	R1,110$			;BRANCH IF NO MODIFIED PAGE WRITING
	CLRL	W^SCH$GL_MFYLOLIM	;MAKE SURE IT'S WRITTEN SOON
	CLRW	W^SCH$GL_MFYLIM		;CLEAR COUNT, NOT WRITE REQUESTED FLAG
	MOVZWL	#RSN$_MPLEMPTY,R1	;SET RESOURCE TO WAIT FOR
	ADDL	#4,SP			;RETURN TO ORIGINAL CALLER
110$:	CLRL	R0			;SET FAILURE (OR RESTART)
	RSB

	.SBTTL	WSLEPFN - FETCH PFN FROM WORKING SET LIST ENTRY
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$WSLEPFN
;
; INPUTS:
;
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	     FOR A PAGE THAT IS IN THE WORKING SET LIST
;
; OUTPUTS:
;
;	R0 = PFN
;	R2,R3 PRESERVED
;
WSLEPFNMSK:
	.LONG	^C<PTE$M_VALID ! PTE$M_TYP0 ! PTE$M_TYP1 ! PTE$M_PGFLVB>

	.ENABL	LSB

MMG$WSLEPFN::
	BICL3	B^WSLEPFNMSK,(R3),R0	;GET VALID, TYP0, TYP1, PFN/GPTX
	ASHL	#-PTE$V_TYP0,R0,R1	;SEE IF TRANSITION OR VALID PAGE
	BGTR	FRE_GBLTRANS		;BRANCH IF NEITHER
10$:	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ;GET PFN
20$:	RSB				;AND RETURN
;
; INPUTS:
;
;	R0 = PAGE TABLE ENTRY WITH TYP0, TYP1 AND GPTX BITS
;	R1 = RESULT OF SHIFTING R0 BY -PTE$V_TYP0
;	   = 1 IF PAGE IS GLOBAL
;	   > 1 IF PAGE TYPE IS INVALID FOR THIS CONTEXT
;
; OUTPUTS:
;
;	R0 = PFN IF GLOBAL PAGE IN TRANSITION
;	BUGCHK IF NOT
;
FRE_GBLTRANS:
	SOBGTR	R1,WSLVANVAL		;BRANCH IF NOT GLOBAL FORMAT
	BBCC	#PTE$V_TYP0,R0,WSLVANVAL ;CLEAR TYP0, MUST HAVE BEEN SET
	BICL3	B^WSLEPFNMSK,@W^MMG$GL_GPTBASE[R0],R0 ;FETCH MASTER PTE
	ASHL	#-PTE$V_TYP0,R0,R1	;MAKE SURE THIS IS IN TRANSITION
	BEQL	20$			;BRANCH IF IT IS, R0 = PFN
WSLVANVAL:
	BUG_CHECK WSLVANVAL,FATAL	;WORKING SET LIST ENTRY VIRTUAL
					;ADDRESS IS NOT VALID
	.DSABL	LSB

	.SBTTL	FREWSLE - FREE A WORKING SET LIST ENTRY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CHOOSES A WORKING SET LIST ENTRY, RELEASES THE
; PAGE WHICH OCCUPIES IT (IF ANY), MARKS THE ENTRY AVAILABLE, AND
; LEAVES THE WSNEXT POINTER POINTING TO THE AVAILABLE ENTRY.
;	IN RELEASING A PAGE, IF ITS BACKING STORE ADDRESS IS A
; "NOT YET ALLOCATED" PAGING FILE ADDRESS, THEN A PAGING FILE VBN
; IS ALLOCATED AT THIS TIME.  IT IS POSSIBLE THAT NO VBN'S ARE AVAILABLE
; AND THUS THIS ROUTINE CAN RETURN UNSUCCESSFULLY.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$FREWSLE
;
; INPUT PARAMETERS:
;
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS - MAY BE P1 SPACE ADDRESS
;		IF WORKING WITH PROCESS WORKING SET LIST
;	IPL = SYNCH
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;
;	IF SUCCESSFUL
;		R0 LOW BIT IS SET
;	IF NOT SUCCESSFUL
;		R0 LOW BIT IS CLEAR AND
;		R1 = RESOURCE TO WAIT FOR (#RSN$_XXXXX)
;
; IMPLICIT OUTPUTS:
;
;	IF A WORKING SET ENTRY WAS FREED,  IT IS PLACED ON THE FREE LIST
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

; FOR MMG$FREWSLX ENTRY POINT
;
; INPUTS:
;
;	R1  = WORKING SET LIST INDEX
;	R2  = VIRTUAL ADDRESS (LOW BITS  = PAGE TYPE)
;	R3  = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4  = PROCESS CONTROL BLOCK ADDRESS
;	R5  = PROCESS HEADER ADDRESS
;	IPL = SYNCH
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = RESOURCE TO WAIT FOR IF NOT SUCCESSFUL
;

;
; FOUND AN EMPTY WORKING SET LIST ENTRY, CHECK WHETHER THERE IS A
; NEW PEAK WORKING SET SIZE AND WHETHER SWAP AREA NEEDS TO GROW.
;
; R0 = GPGCNT+PPGCNT
;
	.ENABLE	LSB

10$:	BBC	#PHD$V_WSPEAKCHK,PHD$W_FLAGS(R5),15$ ;BRANCH IF CANNOT BE
					;ABOVE PREVIOUS PEAK WORKING SET SIZE
	CMPW	R0,G^CTL$GL_WSPEAK	;ABOVE PREVIOUS RECORDED PEAK?
	BLSSU	15$			;BRANCH IF NOT
	ADDW3	#1,R0,G^CTL$GL_WSPEAK	;YES, NEW PEAK INCLUDES THE PAGE
					;ABOUT TO BE ADDED TO THE WORKING SET
15$:	BBC	#PHD$V_IWSPEAKCK,PHD$W_FLAGS(R5),20$ ;BRANCH IF CANNOT BE
					;ABOVE PREVIOUS PEAK WORKING SET SIZE
	CMPW	R0,G^CTL$GL_IWSPEAK	;ABOVE PREVIOUS RECORDED PEAK?
	BLSSU	20$			;BRANCH IF NOT
	ADDW3	#1,R0,G^CTL$GL_IWSPEAK	;YES, NEW PEAK INCLUDES THE PAGE
					;ABOUT TO BE ADDED TO THE WORKING SET
20$:	MOVW	R1,PHD$W_WSNEXT(R5)	;UPDATE NEXT POINTER
	CMPW	R0,PHD$W_SWAPSIZE(R5)	;IS THERE ENOUGH ROOM TO SWAP PROCESS?
	BLSSU	30$			;BRANCH IF YES
	SUBW3	PHD$W_WSLIST(R5),PHD$W_WSAUTH(R5),R0 ;GET AUTHORIZED QUOTA
	CMPW	PHD$W_SWAPSIZE(R5),R0	;ENOUGH SPACE TO COVER QUOTA?
	BGEQU	30$			;BRANCH IF SO, DON'T NEED ANY MORE
	MOVL	PCB$L_WSSWP(R4),R0	;GET BLOCK LOCATION OF LAST ALLOCATION
	BEQL	30$			;BRANCH IF NON SWAPPING TYPE PROCESS
	MOVZWL	PHD$W_SWAPSIZE(R5),R1	;GET CURRENT SIZE
	MOVZWL	W^SWP$GW_SWPINC,R2	;NEW INCREMENT
	ADDL	R1,R2			;NEW DESIRED SIZE
	BSBW	MMG$ALLOCSWPAREA	;ALLOCATE A SWAP AREA, R0-R3 CHANGED
	BLEQ	40$			;BRANCH IF ALLOCATION FAILED
	MOVL	R0,PCB$L_WSSWP(R4)	;UPDATE SWAP FILE VBN
	MOVW	R2,PHD$W_SWAPSIZE(R5)	;AND SIZE OF AREA
30$:	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL RETURN INDICATION
	RSB

35$:	BRB	10$			;GET BRANCH DESTINATION TO REACH

40$:	CLRL	R3			;FORCE SKIP COUNT TO ZERO
	MOVZWL	PHD$W_WSNEXT(R5),R1	;INDEX TO NEXT CANDIDATE TO DISCARD
	ADDW3	PCB$W_PPGCNT(R4),PCB$W_GPGCNT(R4),R0 ;CURRENT PAGE COUNT IN USE
	SUBW	PHD$W_WSQUOTA(R5),R0	;IS THIS WITHIN QUOTA OR EXTENT?
	ADDW	PHD$W_WSLIST(R5),R0	;COUNT IS STILL OVER BY 1
	BGTR	90$			;BRANCH IF GREATER THAN QUOTA TO FREE
					;A WSLE, I.E. RUN RATHER THAN WAIT
	MOVZWL	#RSN$_SWPFILE,R1	;R1 = RESOURCE TO WAIT FOR
	CLRL	R0			;RETURN FAILURE INDICATION
	RSB				;RETURN RESOURCE TO WAIT FOR IN R1

LCKWSLE_NOTPGTB:
	BUG_CHECK BADLCKWSLE,FATAL	;LOCKED WORKING SET LIST ENTRY NOT PAGE TABLE
WSSIZEERR:
	BUG_CHECK WSSIZEERR,FATAL	;VALUE OF WSSIZE IS SMALLER THAN IN USE
WSLENOVAL:
	BUG_CHECK WSLENOVAL,FATAL	;WSL ENTRY NOT VALID
;
; THIS IS A LOCKED PAGE IN THE DYNAMIC PORTION OF THE WORKING SET LIST
; IT MUST BE A PAGE TABLE PAGE, NOTE THE CONDITION CODES ARE STILL SET
; FROM THE FETCH OF THE WORKING SET LIST ENTRY.
;
50$:	BGEQ	LCKWSLE_NOTPGTB		;BRANCH IF THIS IS NOT A PAGE TABLE
	BBS	#WSL$V_PAGTYP,R2,60$	;BRANCH TO SKIP GLOBAL PAGE TABLE PAGES
	BSBW	SCANDEADPT		;SCAN THE PAGE TABLE TO SEE IF "DEAD"
					;IF SO RID IT OF TRANSITION PAGES.
	BLBS	R0,60$			;AND NOW GET A FREE WS LIST ENTRY
MMG$FREWSLE::
	MOVZWL	W^SGN$GW_WSLMXSKP,R3	;MAX NUMBER OF TB VALID ENTRIES TO SKIP
	MOVZWL	PHD$W_WSNEXT(R5),R1	;INDEX TO NEXT CANDIDATE TO DISCARD
	TSTL	(R5)[R1]		;IS THIS ENTRY FREE?
	BEQL	80$			;BRANCH IF SO, CHECK FOR TRULY FREE
60$:	ACBW	PHD$W_WSLAST(R5),#1,R1,70$ ;OTHERWISE POINT TO NEXT ENTRY
	MOVZWL	PHD$W_WSDYN(R5),R1	;BACK TO THE TOP
70$:	MOVL	(R5)[R1],R2		;R2 = VA FROM WSLE
	BNEQ	120$			;BRANCH IF ENTRY IN USE
80$:	ADDW3	PCB$W_PPGCNT(R4),PCB$W_GPGCNT(R4),R0 ;CURRENT PAGE COUNT IN USE
	CMPW	R0,PHD$W_WSSIZE(R5)	;ARE PAGES IN USE = WORKING SET SIZE?
	BEQL	90$			;BRANCH IF SO, NEED TO REPLACE A PAGE
	BGTRU	WSSIZEERR		;BRANCH IF MORE PAGES IN WS THAN IN WSSIZE
	SUBW3	PHD$W_WSLIST(R5),PHD$W_WSQUOTA(R5),R2 ;QUOTA NUMBER OF PAGES-1
	CMPW	R0,R2			;ARE WE WITHIN QUOTA NUMBER OF PAGES?
	BLEQU	35$			;BRANCH IF SO, ALLOWED ANOTHER PAGE
	CMPL	W^SCH$GL_GROWLIM,W^SCH$GL_FREECNT ;ENOUGH FREE PAGES TO EXTEND?
	BLSS	35$			;BRANCH IF SO
90$:	SUBL3	#1,R1,R0		;SAVE INDEX OF LAST NON-ZERO WSLE
100$:	ACBW	PHD$W_WSLAST(R5),#1,R1,110$ ;OTHERWISE POINT TO NEXT ENTRY
	MOVZWL	PHD$W_WSDYN(R5),R1	;BACK TO THE TOP
	BLBS	W^MMG$GB_FREWFLGS,110$	;IF SWAPPER REQUESTED, DON'T MOVE LAST
	MOVW	R0,PHD$W_WSLAST(R5)	;SHRINK WSLAST BACK OVER 0 WSLE'S
					;THIS IS SAFE BECAUSE WS IS FULL
110$:	MOVL	(R5)[R1],R2		;R2 = VA FROM WSLE
	BEQL	100$			;BRANCH IF UNUSABLE FREE ENTRY
120$:	BLBC	R2,WSLENOVAL		;BRANCH IF ENTRY NOT VALID
	BBS	#WSL$V_WSLOCK,R2,50$	;SKIP ENTRY IF IT IS LOCKED
					;CONDITION CODES STILL SET FROM LOAD OF R2
	BBC	S^#EXE$V_TBCHK,W^EXE$GL_FLAGS,130$ ;BRANCH IF TBCHK NOT ENABLED
	MTPR	R2,#PR$_TBCHK		;TEST FOR VALID IN TB
	BVC	130$			;BRANCH IF NO VALID TRANSLATION
	SOBGEQ	R3,60$			;SKIP PAGE UNLESS COUNT EXHAUSTED
130$:	MOVW	R1,PHD$W_WSNEXT(R5)	;UPDATE NEXT POINTER
	BSBW	MMG$SVAPTECHK		;RETURN R3 = SYS VA OF PAGE TABLE ENTRY
					;OK FOR PROCESS PAGE TABLES AND
					;PROCESS HEADER PAGES WITH PROCESS PCB ADR
	.DISABLE LSB
;
; R1 = WSLX, R2 = VA FROM WSLE, R3 = SVAPTE, R4 = PCB, R5 = PHD
;
	BBC	#PTE$V_MODIFY,(R3),MMG$FREWSLX	;BRANCH IF PAGE NOT MODIFIED
					;IF ENTRY NOT VALID MODIFY=0 SO BRANCH
	CMPW	W^MPW$GL_WAITLIM,W^SCH$GL_MFYCNT ;ABOVE WAIT PROCESS THRESHOLD?
	BGTR	MMG$FREWSLX		;BRANCH IF SO
	BBS	S^#MMG$V_NOWAIT,W^MMG$GB_FREWFLGS,MMG$FREWSLX
					;BRANCH IF THIS IS SWAPPER
	MOVZWL	#RSN$_MPWBUSY,R1	;R1 = RESOURCE TO WAIT FOR
	CLRL	R0			;RETURN FAILURE INDICATION
	RSB				;RETURN RESOURCE TO WAIT FOR IN R1

	.ENABLE	LSB

MMG$FREWSLX::
	PUSHL	R1			;SAVE WSLX FOR DELETE BY WSLX

	ASSUME PTE$V_MODIFY EQ PTE$V_TYP1
	BICL3	#^C<PTE$M_VALID ! -	;FETCH VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! - ;PTE TYPE BITS
		PTE$M_GPTX>,(R3),R0	;AND PFN/GPTX FROM PAGE TABLE ENTRY
	BBSC	#PTE$V_VALID,R0,10$	;BRANCH IF PTE VALID
					;CLEAR VALID BIT IN R0
;
; PAGE TABLE ENTRY NOT VALID,
;	PAGE IN TRANSITION AND READINPROG OR
;	GLOBAL PTE POINTING TO TRANSITION PTE
;
	ASHL	#-PTE$V_TYP0,R0,R1	;IF NEITHER TYP1 OR TYP0 IS SET
	BEQL	30$			;BRANCH TO RELEASE PAGE
;
; THIS WORKING SET LIST ENTRY POINTED TO A PAGE WITH A PAGE TABLE ENTRY
; WHICH IS NEITHER VALID NOR IN TRANSITION.  THIS PAGE MUST BE A GLOBAL
; PAGE ON THE WAY IN TO MEMORY.  THE GLOBAL PTE MUST BE IN TRANSITION.
;
	BSBW	FRE_GBLTRANS		;GET PFN IF PAGE IS GLOBAL TRANSITION
	BRB	30$			;RELEASE ACTIVE PAGE

10$:	BBCC	#PTE$V_MODIFY,R0,20$	;CLR MODIFY BIT IN R0, BR IF CLR
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ;RECORD MODIFY BIT
MPH$INVALIDHK::				;MULTI-PROCESSING CODE HOOKS IN HERE
20$:	BICB	#<PTE$M_VALID ! PTE$M_MODIFY>@-24,3(R3)	;RESET VALID AND MODIFY
					;LEAVING TRANSITION PAGE FOR I/O TO SEE
	INVALID	R2			;INVALIDATE TRANSLATION BUFFER
MMG$FRE_TRYSKIP::			;HOOK RETURN LOCATION FOR MP SUPPORT
;
; RELEASE THIS WORKING SET LIST ENTRY
;
30$:	MOVL	@W^PFN$AL_BAK[R0],R1	;GET BACKING STORE ADDRESS (VBN)
	BBS	#PTE$V_CHKPNT,R1,90$	;BRANCH IF CHECKPOINTABLE
40$:	BBS	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],50$ ;BRANCH IF PAGE MODIFIED
	ASHL	#32-PFN$S_BAK,R1,R1	;DOES PAGE HAVE BACKING STORE?
	BNEQ	70$			;BRANCH IF YES
;
; NULL PAGE FILE BACKING STORE ADDRESS, AND PAGE IS NOT MODIFIED
;
NULLPGFL_NOMFY:
	BUG_CHECK MFYNULPGFL,FATAL
;
; NOW THAT WE HAVE A MODIFIED COPY OF THE PAGE IN MEMORY, NO NEED FOR OBSOLETE
; PAGE FILE COPY.
;
50$:	PUSHL	R3			;SAVE SVAPTE
	BSBW	MMG$DALCBAKSTORE	;RELEASE OLD PAGE FILE BACKING STORE
	POPR	#^M<R3>			;RESTORE SVAPTE
;
; PFN$AL_BAK[R0] IS ALL SET UP, R0 = PFN, R2 = VA, R3 = SVAPTE (SLAVE IF GBL)
;
70$:	ASSUME	PFN$C_PROCESS EQ 0
	ASSUME	PFN$C_SYSTEM  EQ 1
	ASSUME	PFN$C_GLOBAL  EQ 2
	ASSUME	PFN$C_GBLWRT  EQ 3
	ASSUME	PFN$C_PPGTBL  EQ 4
	ASSUME	PFN$C_GPGTBL  EQ 5

	CMPV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R2,#PFN$C_GLOBAL ;GLOBAL PAGE?
	BLSSU	130$			;BRANCH IF PROCESS OR SYSTEM
	BLSS	120$			;BRANCH IF PROCESS OR GLOBAL PAGE TABLE
;
; GLOBAL PAGE - MAKE SLAVE PTE INTO GLOBAL FORMAT
;
	SUBL3	W^MMG$GL_GPTBASE,@W^PFN$AL_PTE[R0],R1 ;BYTE INDEX TO GPTE
	ROTL	#32-2,R1,R1		;GLOBAL PAGE TABLE INDEX
	ASSUME	PTE$V_TYP0 EQ PTE$S_GPTX ;TYP0 ADJACENT TO GPTX FIELD
	BBSS	#PTE$V_TYP0,R1,80$	;SET TYP0 BIT FOR GLOBAL FORMAT
80$:	INSV	R1,#PTE$V_GPTX,#PTE$S_GPTX+1,(R3) ;STORE GPTX + TYP0 IN PTE
					;CHANGING FROM TRANSITION TO GLOBAL
	BSBW	MMG$DECPTREF		;SLAVE PTE NO LONGER LOCKED
	DECSHR	GTR=150$,-		;ONE LESS SHARER, BRANCH IF STILL IN USE
		IMAGE_FLAG=SYS_NONPAGED
	MOVL	@W^PFN$AL_PTE[R0],R1	;GET MASTER PTE ADR
	BICB	#<PTE$M_VALID ! PTE$M_MODIFY>@-24,3(R1) ;FORM TRANSITION PTE
	BRB	130$			;GO COUNT ONE LESS WSL REF

;  SEE IF OLD BACKING STORE ADDRESS SHOULD BE FORGOTTEN AND BAK REINITIALIZED

90$:	BBS	#PTE$V_TYP0,R1,100$	;BRANCH IF SECTION PAGE
	MOVZBL	PHD$B_PAGFIL(R5),R1	;MUST CHECK FOR LARGE PAGING FILE
	MOVL	@W^MMG$GL_PAGSWPVC[R1],R1 ;GET ADDR OF PAGE FILE CONTROL BLOCK
	BBS	#PTE$V_CHKPNT,PFL$L_MAXVBN(R1),110$;BRANCH IF PART OF LARGE VBN
100$:	BBC	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],110$;BRANCH IF UNMODIFIED PAGE
	MOVL	PHD$L_PAGFIL(R5),@W^PFN$AL_BAK[R0] ;RESET BACKING STORE ADDRESS
110$:	MOVL	@W^PFN$AL_BAK[R0],R1	;GET BACKING STORE ADDRESS
	BRW	40$			;CONTINUE

;
; PROCESS OR GLOBAL PAGE TABLE
;
120$:	CMPZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R2,#PFN$C_PPGTBL ;PROCESS PAGE TABLE?
	BNEQ	130$			;BRANCH IF NO
	MOVZWL	PHD$W_PHVINDEX(R5),R1	;PROCESS HEADER VECTOR INDEX
	INCW	@W^PHV$GL_REFCBAS[R1]	;ADD A PROCESS HEADER REFERENCE
					;WHEN PROCESS PAGE TABLE IS PUT
					;INTO TRANSITION STATE
130$:	DECREF	EQL=140$		;COUNT ONE LESS WSL REF
;
; OTHER REFERENCES OUTSTANDING, COULD BE DIRECT I/O, PAGING I/O
; IF CURRENT PAGE STATE IS "ACTIVE" CHANGE IT TO "RELEASE PENDING" WHICH
; IF REFAULTED WILL BE TRANSFORMED BACK TO ACTIVE.
; LEAVE "READ IN PROGRESS" STATE AS IS.
;
	CMPZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],#PFN$C_ACTIVE
					;UNLESS STATE IS "ACTIVE"
	BNEQ	150$			;LEAVE IT AS IT WAS
	INSV	#PFN$C_RELPEND,#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0]
					;OTHERWISE SET RELEASE PENDING STATE
	BRB	150$
;
; R0 = PFN, REFCNT = 0, R2 = VA, R3 = SVAPTE
;

140$:	BSBW	MMG$RELPFN		;REFCNT = 0, RELEASE PFN
150$:	MOVL	(SP)+,R1		;RECOVER SAVED WSLX
	BSBB	MMG$DELWSLEX		;DELETE WORKING SET LIST ENTRY (BY INDEX)
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL RETURN INDICATION
	RSB

	.DISABLE LSB

	.SBTTL	DELWSLEX - DELETE WORKING SET LIST ENTRY BY INDEX
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DELETES THE WORKING SET LIST ENTRY INDEXED BY
; R1, AND PLACES THE WORKING SET LIST ENTRY ON THE FREE LIST.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DELWSLEX
;	BSBW	MMG$DELWSLEPPG
;
; INPUT PARAMETERS:
;
;	R1 = WORKING SET LIST INDEX
;	R2 = VIRTUAL ADDRESS IF ENTERING AT DELWSLEPPG
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	.ENABL	LSB

MMG$DELWSLEX::
	MOVL	(R5)[R1],R2		;FETCH WORKING SET LIST ENTRY
	EXTZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R2,R3  ;GET THE PAGE TYPE
	CASE	R3,<-			;AND DISPATCH ON IT
		30$,-			;PROCESS PAGE
		45$,-			;SYSTEM PAGE
		10$,-			;GLOBAL READ ONLY
		10$,-			;GLOBAL WRITABLE
		45$,-			;PROCESS PAGE TABLE
		45$  >			;GLOBAL PAGE TABLE
	BUG_CHECK DELWSLEX,FATAL	;BAD PAGE TYPE
;
; GLOBAL PAGE, READ ONLY OR WRITABLE
;
10$:	BSBB	DECVALWSLECNT		;DEC VALID WORKING SET LIST ENTRY COUNT
	DECW	PCB$W_GPGCNT(R4)	;ONE LESS GLOBAL PAGE IN WORKING SET
	BRB	50$
;
; PROCESS PAGE, R2 = VIRTUAL ADDRESS
;
MMG$DELWSLEPPG::
30$:	BSBB	DECVALWSLECNT		;DECREMENT VALID WORKING SET LIST ENTRY CNT
45$:	DECW	PCB$W_PPGCNT(R4)	;ONE LESS PROCESS PAGE IN WORKING SET
50$:	CLRL	(R5)[R1]		;FREE THE WORKING SET LIST ENTRY
	RSB

	.DSABL	LSB

DECVALWSLECNT:
	ADDL3	PHD$L_PTWSLEVAL(R5),R5,R3 ;BASE ADR OF BYTE ARRAY OF COUNTS OF
					;VALID WSLE'S IN EACH PAGE TABLE
	EXTV	#VA$V_VPN+7,#VA$S_VPN+1-7,R2,R2 ;BITS 16:30 OF VA SIGN EXTENDED
	BGEQ	10$			;BRANCH IF P0 SPACE
	ADDL	W^SGN$GL_PTPAGCNT,R3	;END ADDRESS OF BYTE ARRAY
10$:	DECB	(R3)[R2]		;ONE LESS VALID WSLE IN THIS PAGE TABLE
	BGEQ	20$			;BRANCH IF PT STILL HAS OTHER VALID WSLE'S
	DECW	PHD$W_PTCNTVAL(R5)	;ONE LESS PT WITH VALID WSLE'S
20$:	RSB

	.SBTTL	ININEWPFN - ALLOCATE AND INIT A NEW PFN
;++
; FUNCTIONAL DESCRIPTION:
;
;	ALLOCATE A NEW PFN AND INITIALIZE THE PFN DATA BASE FOR IT
; AND MAKE A WORKING SET LIST ENTRY.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$ININEWPFN		;ALLOCATE AND INIT NEW PFN
;
; INPUT PARAMETERS:
;
;	R2 = FAULT VA (LOW BITS = PAGTYP)
;	R3 = SVAPTE (SLAVE IF GLOBAL)
;	R4 = PCB ADDRESS (PROCESS IF GLOBAL)
;	R5 = PROCESS HEADER ADDRESS (PROCESS IF GLOBAL)
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = PFN, OR NEGATIVE IF NONE AVAILABLE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

ININEWPFNWAIT:
	POPR	#^M<R2,R3,R5>		;RESTORE SAVED REGISTERS
	RSB				;AND RETURN NO FREE PAGES INDICATION

MMG$ININEWPFN::
	PUSHL	R5			;SAVE PHD
	PUSHL	R3			;SAVE SVAPTE
	PUSHL	R2			;SAVE VA
	BSBW	MMG$ALLOCPFN		;ALLOCATE A NEW PFN
	BBS	#31,R0,ININEWPFNWAIT	;BRANCH IF NONE AVAILABLE
	MOVQ	(SP),R2			;R2=VA, R3=SVAPTE
	CMPV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R2,#PFN$C_GLOBAL ;GLOBAL PAGE?
	BLSS	40$			;BRANCH IF NOT
	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,(R3),R3 ;GLOBAL PAGE TABLE INDEX
	MOVAL	@W^MMG$GL_GPTBASE[R3],R3	;SVAPTE OF MASTER
	MOVAL	@W^MMG$GL_SYSPHD,R5	;SYSTEM PROCESS HEADER ADR FOR GLOBAL
40$:	BBS	#VA$V_SYSTEM,R2,50$	;DON'T COUNT PT REF FOR SYSTEM PAGE
	BSBW	MMG$INCPTREF		;LOCK PAGE TABLE ENTRY (NOT FOR SYSTEM)
50$:	MOVL	R3,@W^PFN$AL_PTE[R0]	;STORE PTE ADDRESS
	ASSUME	PFN$V_PAGTYP EQ 0
	ROTL	#<32-WSL$V_PAGTYP>,R2,R2 ;POSITION PAGE TYPE FIELD
	BICB3	#^C<PFN$M_PAGTYP>,R2,@W^PFN$AB_TYPE[R0] ;SET PAGE TYPE
	POPR	#^M<R2,R3,R5>		;R2=VA, R3=SVAPTE, R5=PHD
;
; FALL THROUGH TO MMG$MAKEWSLE
;

	.SBTTL	MAKEWSLE - MAKE A WORKING SET LIST ENTRY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ENTERS SPECIFIED VIRTUAL ADDRESS INTO THE WORKING
; SET LIST.  IT ASSUMES THAT THERE IS A FREE WORKING SET LIST ENTRY ON THE
; FREE LIST.  IF THE PAGE IS A GLOBAL PAGE THE SLAVE PAGE TABLE ENTRY IS
; LOCKED AT THIS TIME AND THE SHRCNT AND/OR REFCNT IS INCREMENTED.
; THIS ROUTINE ALSO KEEPS THE ACTIVE PAGE COUNTERS IN THE PCB (PPGCNT, GPGCNT).
;
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$MAKEWSLE
;
; INPUT PARAMETERS:
;
;	R0 = PAGE FRAME NUMBER
;	R2 = VA (LOW BITS = PAGTYP)
;	R3 = SVAPTE (SLAVE IF GLOBAL)
;	R4 = PCB ADDRESS (PROCESS IF GLOBAL)
;	R5 = PHD ADDRESS (PROCESS IF GLOBAL)
;
; IMPLICIT INPUTS:
;
;	FREE WORKING SET LIST CONTAINS AT LEAST ONE ENTRY
;
; OUTPUT PARAMETERS:
;
;	R0 = PFN PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$MAKEWSLE::
	MOVZWL	PHD$W_WSNEXT(R5),R1	;WSLX FOR FREE ENTRY

	ASSUME	WSL$V_VALID EQ 0
	BLBS	(R5)[R1],20$		;BRANCH IF ENTRY BUSY, ERROR
	BISL3	#WSL$M_VALID,R2,(R5)[R1] ;STORE NEW WSLE

	EXTZV	#WSL$V_PAGTYP,#WSL$S_PAGTYP,R2,R1 ;EXTRACT THE PAGE TYPE
	CASE	R1,<-			;AND DISPATCH ON IT
		50$,-			;PROCESS PAGE
		70$,-			;SYSTEM PAGE
		30$,-			;GLOBAL READ ONLY
		30$,-			;GLOBAL WRITABLE
		70$,-			;PROCESS PAGE TABLE
		70$  >			;GLOBAL PAGE TABLE
20$:	BUG_CHECK MAKEWSLE,FATAL	;BAD PAGE TYPE OR 
					;WSNEXT POINTS TO VALID WSLE
;
; GLOBAL PAGE, READ ONLY OR WRITABLE
;
30$:	BSBB	MMG$INCPTREF		;LOCK THE SLAVE PAGE TABLE ENTRY
	BSBB	INCVALWSLECNT		;INC VALID WORKING SET LIST ENTRY COUNT
	INCW	PCB$W_GPGCNT(R4)	;ANOTHER GLOBAL PAGE IN WORKING SET LIST
		PFN_REFERENCE	-
	ACBW	<#1,#1,@W^PFN$Ax_SHRCNT[R0],80$>,-	;COUNT SHARER, BRANCH IF FIRST
		LONG_OPCODE=ACBL,-
		IMAGE=SYS_NONPAGED
	BRB	90$
;
; PROCESS PAGE
;
50$:	BSBB	INCVALWSLECNT		;INC VALID WORKING SET LIST ENTRY COUNT
70$:	INCW	PCB$W_PPGCNT(R4)	;ONE MORE ACTIVE PROCESS PAGE IN WSL
		PFN_REFERENCE	-
	MOVW	<PHD$W_WSNEXT(R5),@W^PFN$Ax_WSLX[R0]>,-	;SET INDEX TO WSLE
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
					;ONLY FOR PRIVATE PAGES

80$:	INCW	@W^PFN$AW_REFCNT[R0]	;ANOTHER REFERENCE FOR THE PAGE
90$:	RSB

INCVALWSLECNT:
	ADDL3	PHD$L_PTWSLEVAL(R5),R5,R3 ;BASE ADR OF BYTE ARRAY OF COUNTS OF
					;VALID WSLE'S IN EACH PAGE TABLE
	EXTV	#VA$V_VPN+7,#VA$S_VPN+1-7,R2,R2 ;BITS 16:30 OF VA SIGN EXTENDED
	BGEQ	10$			;BRANCH IF P0 SPACE
	ADDL	W^SGN$GL_PTPAGCNT,R3	;BASE ADR TO NEGATIVE INDEX FROM
10$:	INCB	(R3)[R2]		;ANOTHER VALID WSLE IN THIS PAGE TABLE
	BGTR	20$			;BRANCH IF NOT THE FIRST
	INCW	PHD$W_PTCNTVAL(R5)	;ANOTHER PAGE TABLE WITH VALID WSLE'S
20$:	RSB

	.SBTTL	LOCKPGTB - LOCK PAGE TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	LOCKPGTB TAKES A VIRTUAL ADDRESS, REFERENCES AND
;	LOCKS THE ASSOCIATED PAGE TABLE, AND RETURNS THE SYSTEM
;	VIRTUAL ADDRESS OF THE PAGE TABLE ENTRY.  IT IS CALLED
;	WITH IPL = ASTDEL OR LOWER AND RETURNS WITH IPL = SYNCH.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$LOCKPGTB
;
; INPUT PARAMETERS:
;
;	R2 = VIRTUAL ADDRESS
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE IF PROCESS PCB,
;		SYSTEM SPACE OF SYSTEM PCB)
;	IPL = ASTDEL OR LOWER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R2 PRESERVED
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	IPL = SYNCH
;
; IMPLICIT OUTPUTS:
;
;	PAGE TABLE LOCKED VIA INCPTREF
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$LOCKPGTB::
	BSBW	MMG$PTEREF		;REFERENCE PTE, GET SVAPTE
					;RETURNS AT IPL=SYNCH
	BLBC	R0,INCPTREFBUG		;BRANCH IF LENGTH VIOLATION
;
; FALL THROUGH TO MMG$INCPTREF
;

	.SBTTL	INCPTREF - INCREMENT PAGE TABLE REFERENCE COUNT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE ACCEPTS THE ADDRESS OF A PAGE TABLE ENTRY AND
; LOCKS THE ASSOCIATED PAGE TABLE INTO MEMORY.  IT ALSO MAINTAINS THE
; COUNT OF SUCH LOCKED PAGE TABLES IN THE PROCESS HEADER VECTOR.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$INCPTREF
;
; INPUT PARAMETERS:
;
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY (MASTER IF GLOBAL)
;	R5 = PROCESS HEADER ADDRESS (SYSTEM IF GLOBAL)
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0,R2,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$INCPTREF::
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;GET PAGE NUMBER OF PT CONTAINING THIS PTE
;
; ***** WARNING ***** THE FOLLOWING DEPENDS ON GPTBASE = SPTBASE
;
	MOVL	@W^MMG$GL_SPTBASE[R1],R1	;PTE FOR PAGE TABLE
	BGEQ	20$			;DISASTER IF NOT VALID
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R1,R1 ;PAGE FRAME NUMBER
	CMPL	R1,W^MMG$GL_MAXPFN	; IS THERE PFN DATABASE?
	BGTR	5$			; NO, SKIP INCREMENT
		PFN_REFERENCE	-
	ACBW	<#1,#1,@W^PFN$Ax_SHRCNT[R1],10$>,-	;INC SHRCNT, BRANCH IF FIRST PTE
		LONG_OPCODE=ACBL,-
		IMAGE=SYS_NONPAGED
5$:	RSB
;
; SHARE COUNT JUST WENT FROM 0 TO 1 INDICATING THAT THE FIRST ACTIVE
; PAGE TABLE ENTRY WAS JUST PLACED IN THE PAGE TABLE
;
; ASSUMPTION HERE IS THAT THIS ROUTINE IS NOT CALLED FOR SYSTEM PAGE TABLES
; THIS IS EITHER A PROCESS OR GLOBAL PAGE TABLE.
;
10$:		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R1],R1>,-	;WORKING SET LIST INDEX
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BISL	#WSL$M_WSLOCK,(R5)[R1]	;SET WORKING SET LOCKDOWN BIT
	INCW	PHD$W_PTCNTACT(R5)	;ANOTHER ACTIVE PAGE TABLE
	MOVZWL	PHD$W_PHVINDEX(R5),R1	;PROCESS HEADER VECTOR INDEX
	INCW	@W^PHV$GL_REFCBAS[R1]	;COUNT ANOTHER PAGE TABLE LOCKED
	RSB
;
; PAGE TABLE PAGE WAS NOT VALID
;
20$:
INCPTREFBUG:
	BUG_CHECK INCPTREF,FATAL	;PAGE TABLE NOT VALID
					;LENGTH VIOLATION FROM LOCKPGTB

	.SBTTL	DECPTREF - DECREMENT PAGE TABLE REFERENCE COUNT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DECREMENTS THE REFERENCE COUNT FOR THE PAGE TABLE
; CONTAINING THE PAGE TABLE ENTRY ADDRESSED BY R3.  IF THE RESULTING REFERENCE
; COUNT INDICATES THAT NO MORE PAGE TABLE ENTRIES ARE IN USE, THE PROCESS
; HEADER VECTOR REFERENCE COUNT IS DECREMENTED AS WELL INDICATING A
; FREE PAGE TABLE
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DECPTREF
;
; INPUT PARAMETERS:
;
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0,R2,R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$DECPTREF::
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;INDEX TO SPT ENTRY FOR PAGE TABLE
	MOVL	@W^MMG$GL_SPTBASE[R1],R1	;PTE FOR PAGE TABLE
	BGEQ	40$			;BRANCH IF NOT VALID, ERROR
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R1,R1 ;PAGE FRAME NUMBER FOR PAGE TABLE
	CMPL	R1,W^MMG$GL_MAXPFN	;IS THERE PFN DATA BASE FOR THIS PAGE?
	BGTR	20$			;NO, SKIP DECREMENT
	DECSHR	PFN=R1,GTR=20$,-	;ONE LESS ACTIVE PTE IN THIS PT
		IMAGE_FLAG=SYS_NONPAGED
;
; SHARE COUNT JUST WENT TO 0, THIS PAGE TABLE IS NO LONGER REQUIRED
; TO REMAIN RESIDENT
; R1 = PFN FOR PAGE TABLE PAGE
;
	PUSHL	R0			;SAVE THIS REGISTER
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R1],R0>,-	;USE IT TO HOLD THE WORKING SET LIST INDEX
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	MOVAL	@W^MMG$GL_SYSPHD,R1	;ADDRESS OF SYSTEM HEADER
	CMPL	R3,R1			;PTE ADR IN SYSTEM HEADER?
	BGEQU	10$			;BRANCH IF YES, GLOBAL PAGE TABLE
	SUBL3	W^SWP$GL_BALBASE,R3,R1	;ADR RELATIVE TO BEGIN OF BAL SET
	DIVL	W^SWP$GL_BSLOTSZ,R1	;PROCESS HEADER INDEX
	ASHL	#-9,R1,R1		;DIVIDE BY PAGE SIZE
	BSBB	MMG$DECPHDREF1		;DECREMENT PROCESS HEADER REFERENCE COUNT
	MULL	W^SWP$GL_BSLOTSZ,R1	;CONVERT PROCESS HEADER INDEX
	ROTL	#9,R1,R1		;MULL BY PAGE SIZE
	ADDL	W^SWP$GL_BALBASE,R1	;TO PROCESS HEADER ADDRESS
10$:	BICL	#WSL$M_WSLOCK,(R1)[R0]	;SHUT OFF WORKING SET LOCK
	DECW	PHD$W_PTCNTACT(R1)	;ONE LESS ACTIVE PAGE TABLE
	BLSS	40$			;BRANCH IF ERROR
	POPR	#^M<R0>			;RESTORE SAVED REGISTER
20$:	RSB				;AND RETURN
;
; PAGE TABLE PTE NOT VALID, OR PAGE TABLE REFERENCE COUNT IS BAD
; OR PTCNTACT WENT NEGATIVE
;
40$:	BUG_CHECK DECPTREF,FATAL	;ERROR IN DECPTREF

	.SBTTL	DECPHDREF - DECREMENT PROCESS HEADER REFERENCE COUNT
;++
; FUNCTIONAL DESCRIPTION:
;
;	DECPHDREF REDUCES THE PROCESS HEADER REFERENCE COUNT AND INFORMS
;	THE SWAPPER IF THE COUNT GOES TO ZERO.  THIS COUNT IS RAISED ONCE
;	FOR EACH REASON THAT A GIVEN SPT ENTRY IS BUSY NOT COUNTING THE
;	WORKING SET LIST ENTRY REFERENCE.  THE FOLLOWING ARE REASONS WHY
;	THE REFERENCE COUNT IS INCREASED FOR A GIVEN PAGE TABLE PAGE.
;		1. PLACED ON THE FREE OR MODIFIED LIST
;		2. READ OR WRITE IN PROGRESS
;		3. SHARE COUNT IS ABOVE 0, I.E. IT CONTAINS ACTIVE PTE'S
;	THE REFERENCE COUNT IS DECREASED UNDER THE FOLLOWING CONDITIONS:
;		1. SHARE COUNT DECREASED FROM 1 TO 0, I.E. LAST PTE GONE
;		2. READ OR WRITE COMPLETE
;		3. PAGE CONTENTS DELETED (DELCONPFN)
;		4. FAULTED OUT OF TRANSITION STATE
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DECPHDREF		;R5 = PROCESS HEADER ADDRESS
;	BSBW	MMG$DECPHDREF1		;R1 = PROCESS HEADER VECTOR INDEX
;
; INPUT PARAMETERS:
;
;	DECPHDREF
;		R5 = PROCESS HEADER ADDRESS FOR PAGE TABLE PAGE
;
;	DECPHDREF1
;		R1 = PROCESS HEADER VECTOR INDEX
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	DECPHDREF
;		ONLY R1 ALTERED
;
;	DECPHDREF1
;		ALL REGISTERS PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$DECPHDREF::
	MOVZWL	PHD$W_PHVINDEX(R5),R1	;PROCESS HEADER VECTOR INDEX
MMG$DECPHDREF1::
	DECW	@W^PHV$GL_REFCBAS[R1]	;COUNT ONE LESS REFERENCE
	BEQL	10$			;BRANCH IF THAT WAS THE LAST REFERENCE
	RSB
10$:	BRW	SCH$SWPWAKE		;INFORM THE SWAPPER, HEADER MAY GO
					;AND RETURN TO THIS ROUTINE'S CALLER

	.SBTTL	INIBLDPKT - INIT FOR CALLING BUILDPKT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS UP R0-R2 FOR A SINGLE PAGE READ/WRITE
; TO THE ADDRESS SPECIFIED BY THE BACKING STORE ADDRESS.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$INIBLDPKT
;
; INPUT PARAMETERS:
;
;	R2 = BACKING STORE ADDRESS
;	R3 = PAGE TABLE ENTRY ADDRESS (MASTER IF GLOBAL)
;	R5 = PROCESS HEADER ADDRESS (SYSTEM HEADER IF GLOBAL PAGE)
;		THIS IS ONLY USED FOR SECTION TYPE BACKING STORE ADDRESSES
;		IF THE BACKING STORE ADDRESS IN R2 IS KNOWN TO BE A 
;		PAGING FILE ADDRESS, THEN IT SELF DESCRIBES AND THIS
;		PARAMETER IS IGNORED.
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = VIRTUAL BLOCK NUMBER
;	R1 = SECTION OR PAGE FILE CONTROL BLOCK ADDRESS
;	R2 = WINDOW ADDRESS
;	R3 = PAGE TABLE ENTRY ADDRESS (PRESERVED)
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$INIBLDPKT::
	BBS	#PFN$V_GBLBAK,R2,10$	;NOT AN I/O ADDRESS IF GBL BAK
	BBS	#PTE$V_TYP0,R2,20$	;BRANCH IF SECTION ADDRESS
	EXTZV	#PFN$V_PGFLX,#PFN$S_PGFLX,R2,R1 ;PAGE FILE INDEX
	MOVL	@W^MMG$GL_PAGSWPVC[R1],R1 ;PAGE FILE CONTROL BLOCK ADDRESS
	EXTZV	#PTE$V_PGFLVB,#PTE$S_PGFLVB,R2,R0 ;PAGE FILE VBN
	BBC	#PTE$V_CHKPNT,R0,5$	;SKIP NEXT CHECK IF BIT CLEAR
	MCOML	PFL$L_MAXVBN(R1),-(SP)	;SEE IF BIT IS PART OF LARGE VBN OR
	BICL2	(SP)+,R0		; TURN IT OFF IF BIT REPRESENTS CHECKPOINTING
5$:	BNEQ	40$			;BRANCH IF GOOD VBN
;
; INVALID BACKING STORE ADDRESS FOR I/O
;
10$:	BUG_CHECK IVBAKADIO,FATAL	;INVALID BACKING STORE ADR FOR I/O
;
; SECTION TABLE BACKING STORE ADDRESS
;
20$:	CVTWL	R2,R2			;SECTION TABLE INDEX
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R1 ;SECTION TABLE BASE ADDRESS
	MOVAL	(R1)[R2],R1		;SECTION TABLE ENTRY ADDRESS
	SUBL3	PHD$L_P0BR(R5),R3,R0	;BYTE OFFSET FROM BASE OF PAGE TABLE
	ASHL	#-2,R0,R0		;LONG WORD INDEX FROM PAGTBL BASE
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,SEC$L_VPXPFC(R1),R2 ;VIRTUAL PAGE NUMBER
	SUBL	R2,R0			;RELATIVE PAGE IN SECTION
40$:
	ASSUME	SEC$L_VBN EQ PFL$L_VBN
	ASSUME	SEC$L_WINDOW EQ PFL$L_WINDOW
	ADDL	SEC$L_VBN(R1),R0	;FORM FILE VBN
	MOVL	SEC$L_WINDOW(R1),R2	;FILE WINDOW
	RSB

	.END
