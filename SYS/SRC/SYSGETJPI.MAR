	.TITLE	SYSGETJPI - GET JOB PROCESS INFORMATION SYSTEM SERVICE
	.IDENT	'V03-005'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: VMS Executive, System services.
;
; ABSTRACT:
;
;	Return accounting, quota, and informational data about the current
;	process, or any other process.
;
; ENVIRONMENT: Kernel Mode
;
; AUTHOR: Henry M. Levy	, CREATION DATE: 20-October-1977
;
; MODIFIED BY:
;
;	V03-005	LJK0157		Lawrence J. Kenah	7-Apr-1982
;		Add support for JPI$_IMAGECOUNT for LIB$SPAWN's benefit
;
;	V03-004	LJK0155		Lawrence J. Kenah	1-Apr-1982
;		Handle quota deductions in consistent fashion.
;
;	V03-003 MSH0001		Maryann Hinden		23-Mar-1982
;		Fix broken BSBW's.
;
;	V03-002	DWT0032		David Thiel		22-Mar-1982
;		Correct length of probe for returning asynchronous result
;		length.
;
;	V03-001	LJK0146		Lawrence J. Kenah	16-Mar-1982
;		Correct bugs along code path for not enough nonpaged pool.
;		Use action routine to convert AUTHPRI item. Do not return
;		address items for another process. Add additional check
;		that item list has not changed before second scan.
;
;	V02-034	LJK0127		Lawrence J. Kenah	9-Feb-1982
;		Get account name from JIB instead of from P1 pointer page 
;		to parallel user name.
;
;	V02-033	LJK0100		Lawrence J. Kenah	11-Dec-1981
;		Add PAGFILLOC and SWPFILLOC, the backing store addresses
;		in the paging and swap files.
;
;	V02-032	LJK0084		Lawrence J. Kenah	13-Nov-1981
;		Add AUTHPRI field to JPI definition. Remove IAFLINK code
;		that was added in LJK0050 (V02-026).
;
;	V02-031	LJK0083		Lawrence J. Kenah	12-Nov-1981
;		Move all pageable code from YEXEPAGED to new pageable
;		PSECT to alleviate strain on word displacements
;		throughout the pageable exec.
;
;	V02-030	LJK0082		Lawrence J. Kenah	11-Nov-1981
;		Write accessibility of multiple page buffer can
;		now be done in global routine EXE$PROBEW.
;
;	V02-029	LJK0075		Lawrence J. Kenah	11-Nov-1981
;		Local routine DEANONPAGED cannot be called from code that
;		is dynamically locked into memory because a page fault
;		might occur and page faults are not allowed above IPL 2.
;
;	V02-028	LJK0058		Lawrence J. Kenah	2-Sep-1981
;		Add contents of site-specific cell in P1 pointer page.
;
;	V02-027	LJK0057		Lawrence J. Kenah	2-Sep-1981
;		Restore BYTCNT quota in all successful return paths,
;		independent of whether the caller specified an AST.
;
;	V02-026	LJK0050		Lawrence J. Kenah	21-Aug-1981
;		Add contents of fixup vector pointer in image activator
;		context page. This allows the debugger to obtain this
;		information without linking against SYS.STB.
;
;	V02-025	LJK0049		Lawrence J. Kenah	21-Aug-1981
;		Do not restart service unless wild card mode is in effect.
;		This removes potential infinite loop in kernel mode.
;
;	V02-024 ROW0010		Ralph O. Weber		4-AUG-1981
;		Change the sizes of JIB$L_BYTLM and JIB$L_BYTCNT from 2 bytes 
;		to 4 bytes in PCBTBL.
;
;	V02-023	HRJ0020		Herb Jacobs		21-May-1981
;		Remainder of change to return WSSIZE as working set size.
;
;	V02-022	LJK0026		Lawrence J. Kenah	20-May-1981
;		Allowed retrieval of PHD$L_FREPTECNT, JIB$W_PRCCNT,
;		and JIB$W_PGFLCNT.
;
;	V02-021	TCM0003		Trudy C. Matthews	06-May-1981
;		Change BSBW to JSB.
;
;	V02-020	SRB0020		Steve Beckhardt		24-Apr-1981
;		Changed several BSBW's to JSB's because word displacements
;		could no longer reach.
;
;	V02-019	HRJ0020		Herb Jacobs		20-Apr-1981
;		Added access to ENQ count and limit, and WSEXTENT, change
;		to way WSSIZE is returned.  WSSIZE needs later change when
;		more of the change is in place.
;
;	V02-018	STJ0029		Steven T. Jeffreys	4-Apr-1981
;		Fix bugs in call-to/return-from probe loop.
;
;	V02-017	LJK0011		Lawrence J. Kenah	3-Mar-1981
;		Minor bug fixes to avoid potential deadlocks. Extended
;		AST control block and data buffer are allocated as 
;		single block of nonpaged pool.
;
;	V02-016	TCM0002		Trudy C Matthews	26-Feb-1981
;		Probe output buffer in a loop.
;
;	V02-015	TCM0001		Trudy C Matthews	16-Feb-1981
;		Change BSBW to JSB.
;
;	V02-014	SPF0001		Steven P. Forgey	23-Jan-1981
;		Change BRW to BSBW.
;
;	V02-013	KTA0005		Kerbey T. Altmann	22-Jan-1981
;		Change some word offsets to long.
;
;	V02-012	KDM0012		Kathleen D. Morse	3-Jun-1980
;		Fix branch displacements.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$ACBDEF				; AST control block parameters
	$DYNDEF				; dynamic memory block types
	$IFDDEF				; image file descriptor block
	$IPLDEF				; interrupt priority levels
	$JIBDEF				; define job information block
	$JPIDEF				; define GETJPI item identifiers
	$PCBDEF				; define process control block
	$PHDDEF				; define process header
	$PSLDEF				; processor state longword
	$STATEDEF			; scheduler state definitions
	$PRDEF				; define processor registers
	$PRIDEF				; define priority increment classes
	$RSNDEF				; define resource wait codes
	$SSDEF				; define status codes

;
; MACROS:
;

;
; Macros to define entries in the four item information tables.
; There is a table for each data structure from which the user may
; request information, and one table for information returned as an
; address.  Tables are indexed by low byte of item identifier.
;

	.MACRO	PCBITM NAME,OFFSET,DATATYPE,LENGTH,STRUCT=PCB
	.=PCBTBL+<<JPI$_'NAME&^XFF>*4>
	.WORD	'STRUCT'$'OFFSET
	.BYTE	<<DATATYPE@5>!LENGTH>
	.BYTE	JPI$C_'STRUCT'TYPE
	.ENDM	PCBITM

	.MACRO	PHDITM NAME,OFFSET,DATATYPE,LENGTH,STRUCT=PHD
	.=PHDTBL+<<JPI$_'NAME&^XFF>*4>
	.WORD	'STRUCT'$'OFFSET
	.BYTE	<<DATATYPE@5>!LENGTH>
	.BYTE	JPI$C_'STRUCT'TYPE
	.ENDM	PHDITM

	.MACRO	CTLITM NAME,ADDRESS,DATATYPE,LENGTH,STRUCT=CTL
	.=CTLTBL+<<JPI$_'NAME&^XFF>*6>
	.LONG	ADDRESS
	.BYTE	<<DATATYPE@5>!LENGTH>
	.BYTE	JPI$C_'STRUCT'TYPE
	.ENDM	CTLITM

	.MACRO	ADRITM NAME,ADDRESS,STRUCT=ADR
	.=ADRTBL+<<JPI$_'NAME&^XFF>*5>
	.LONG	ADDRESS
	.BYTE	JPI$C_'STRUCT'TYPE
	.ENDM	ADRITM

;
; This macro defines the entries to the table of special items.
; The items in this table must be handled by action routines 
; before being returned.  Each entry has a word item identifier
; followed by the address of an action routine.
;

	.MACRO	SPECIAL_ITEM NAME,ROUTINE
	.WORD	JPI$_'NAME
	.ADDRESS ROUTINE
	.ENDM	SPECIAL_ITEM

;
; EQUATED SYMBOLS:
;

	EFN = 4				; event flag number argument
	PIDADR = 8			; address of PID
	PRCNAM = 12			; address of name descriptor
	ITMLST = 16			; address of item identifiers
	IOSB = 20			; I/O status block address
	ASTADR = 24			; ast routine address
	ASTPRM = 28			; ast parameter

;
; One quadword local is left on stack for routines which may 
; manipulate values before returning them.
;

	LOCAL_SPACE = -8

	MAX_ADR_ITEM = <JPI$_LASTADR&^XFF>-1 ; maximum ADRTBL item number
	MAX_CTL_ITEM = <JPI$_LASTCTL&^XFF>-1 ; maximum CTLTBL item number
	MAX_PCB_ITEM = <JPI$_LASTPCB&^XFF>-1 ; maximum PCBTBL item number
	MAX_PHD_ITEM = <JPI$_LASTPHD&^XFF>-1 ; maximum PHDTBL item number
	MAXSTRUC = 4			; maximum structure code

	JPI$C_JIBTYPE = JPI$C_PHDTYPE+1	; JIB structure type code
;
; Data type codes (all numeric types have same code)
;

	VALUE = 0			; numeric value
	BSTRING = 1			; blank filled string
	CSTRING = 2			; counted ascii string
;
; AST control block extensions
;
	$DEFINI	ACB

	.=ACB$L_KAST+4				;

$DEF	ACB_L_DADDR	.BLKL	1		; data buffer address
$DEF	ACB_L_EFN	.BLKL	1		; event flag number
$DEF	ACB_L_IOSB	.BLKL	1		; completion AST routine addr
$DEF	ACB_L_OPID	.BLKL	1		; original requester's PID
$DEF	ACB_L_IMGCNT	.BLKL	1		; PHD$L_IMGCNT of requester
$DEF	ACB_L_COUNT	.BLKL	1		; item descriptor count
$DEF	ACB_L_ILIST				; item descriptor list

	ACB_C_IDESC = 12			; item descriptor size

	$DEFEND	ACB


;
; OWN STORAGE:
;

	.PSECT	YF$$SYSGETJPI

;
; This array contains the maximum item number for each of the
; four item data structures, indexed by structure number.
;

MAXCOUNT:
	.BYTE	MAX_ADR_ITEM
	.BYTE	MAX_CTL_ITEM
	.BYTE	MAX_PCB_ITEM
	.BYTE	MAX_PHD_ITEM

;
; Define the four item data structures.  Each data structure is indexed
; by item identifier.  The PCB and PHD tables contain a word offset
; followed by a byte code for each item followed by a byte of structure type.
; The CTL table contains a longword address followed by a byte code and the
; ADR table contains a longword address.  The code contains the length of the
; item in the low five bits, and the item type in the high three bits.  The
; types are value, counted string, and blank filled string.
;

ADRTBL:
	.BLKB	5*<MAX_ADR_ITEM+1>		; define adr table
CTLTBL:
	.BLKB	6*<MAX_CTL_ITEM+1>		; define ctl table
PCBTBL:
	.BLKB	4*<MAX_PCB_ITEM+1>		; define pcb table
PHDTBL:
	.BLKB	4*<MAX_PHD_ITEM+1>		; define phd table

	.SAVE					; save current location

;
; Define Entries to ADRTBL
;

	ADRITM	EXCVEC,CTL$AQ_EXCVEC		; address of exception vectors
	ADRITM	FINALEXC,CTL$AL_FINALEXC	; address of final exception vectors

;
; Define Entries to CTLTBL
;

	CTLITM	VIRTPEAK,CTL$GL_VIRTPEAK,VALUE,4 ; peak virtual size
	CTLITM	WSPEAK,CTL$GL_WSPEAK,VALUE,4	; peak working set size
	CTLITM	USERNAME,JIB$T_USERNAME,BSTRING,12,JIB ; username string
	CTLITM	ACCOUNT,JIB$T_ACCOUNT,BSTRING,8,JIB ; account name string
	CTLITM	PROCPRIV,CTL$GQ_PROCPRIV,BSTRING,8 ; quadword process privileges
	CTLITM	VOLUMES,CTL$GL_VOLUMES,VALUE,4	;  number of volumes mounted
	CTLITM	LOGINTIM,CTL$GQ_LOGIN,BSTRING,8	; process creation time
	CTLITM	IMAGNAME,CTL$GL_IMGHDRBF,VALUE,4 ; image header buffer address
						  ; which is used to get image name
	CTLITM	SITESPEC,CTL$GL_SITESPEC,VALUE,4 ; Per-process site-specific cell

;
; Define Entries to PCBTBL
;

	PCBITM	ASTACT,B_ASTACT,VALUE,1		; access modes with active ASTs
	PCBITM	ASTEN,B_ASTEN,VALUE,1		; access modes with ASTs enabled
	PCBITM	PRI,B_PRI,VALUE,1		; current process priority
	PCBITM	OWNER,L_OWNER,VALUE,4		; PID of creator
	PCBITM	UIC,L_UIC,VALUE,4		; UIC of process
	PCBITM	GRP,W_GRP,VALUE,2		; group field of UIC
	PCBITM	MEM,W_MEM,VALUE,2		; member field of UIC
	PCBITM	STS,L_STS,VALUE,4		; process status
	PCBITM	STATE,W_STATE,VALUE,2		; process state
	PCBITM	PRIB,B_PRIB,VALUE,1		; process base priority
	PCBITM	APTCNT,W_APTCNT,VALUE,2		; active page table count
	PCBITM	TMBU,W_TMBU,VALUE,2		; termination mailbox unit
	PCBITM	GPGCNT,W_GPGCNT,VALUE,2		; global page count in ws
	PCBITM	PPGCNT,W_PPGCNT,VALUE,2		; process page count in ws
	PCBITM	ASTCNT,W_ASTCNT,VALUE,2		; ast count remaining
	PCBITM	BIOCNT,W_BIOCNT,VALUE,2		; buffered I/O count remaining
	PCBITM	BIOLM,W_BIOLM,VALUE,2		; buffered I/O limit
	PCBITM	BYTCNT,L_BYTCNT,VALUE,4,JIB	; buffered I/O byte count remaining
	PCBITM	DIOCNT,W_DIOCNT,VALUE,2		; direct I/O count remaining
	PCBITM	DIOLM,W_DIOLM,VALUE,2		; direct I/O count limit
	PCBITM	ENQCNT,W_ENQCNT,VALUE,2,JIB	; enqueue count remaining
	PCBITM	ENQLM,W_ENQLM,VALUE,2,JIB	; enqueue count limit
	PCBITM	FILCNT,W_FILCNT,VALUE,2,JIB	; open file count remaining
	PCBITM	TQCNT,W_TQCNT,VALUE,2,JIB	; count remaining of time queue entries
	PCBITM	EFWM,L_EFWM,VALUE,4		; event flag wait mask
	PCBITM	EFCS,L_EFCS,VALUE,4		; local event flags 0-31
	PCBITM	EFCU,L_EFCU,VALUE,4		; local event flags 32-64
	PCBITM	PID,L_PID,VALUE,4		; process identification
	PCBITM	BYTLM,L_BYTLM,VALUE,4,JIB	; buffered I/O byte count limit
	PCBITM	PRCCNT,W_PRCCNT,VALUE,2		; subprocess count
	PCBITM	JOBPRCCNT,W_PRCCNT,VALUE,2,JIB	; total subprocess count in job
	PCBITM	PRCNAM,T_LNAME,CSTRING,16	; process name string
	PCBITM	TERMINAL,T_TERMINAL,CSTRING,8	; login terminal name
	PCBITM	SWPFILLOC,L_WSSWP,VALUE,4	; swap file backing store address

;
; Define entries to PHDTBL
;

	PHDITM	CURPRIV,Q_PRIVMSK,BSTRING,8	; quadword current privilege mask
	PHDITM	WSSIZE,W_WSSIZE,VALUE,2		; current working set size
	PHDITM	WSAUTH,W_WSAUTH,VALUE,2		; authorized working set size
	PHDITM	WSQUOTA,W_WSQUOTA,VALUE,2	; quota on working set size
	PHDITM	WSEXTENT,W_WSEXTENT,VALUE,2	; maximum extent on working set
	PHDITM	WSAUTHEXT,W_WSAUTHEXT,VALUE,2	; authorized working set extent
	PHDITM	DFWSCNT,W_DFWSCNT,VALUE,2	; default working set size
	PHDITM	FREP0VA,L_FREP0VA,VALUE,4	; first free addr. at end of P0 space
	PHDITM	FREP1VA,L_FREP1VA,VALUE,4	; first free addr. at end of P1 space
	PHDITM	FREPTECNT,L_FREPTECNT,VALUE,4	; available pages for expansion
	PHDITM	DFPFC,B_DFPFC,VALUE,1		; default page fault cluster
	PHDITM	CPUTIM,L_CPUTIM,VALUE,4		; process cputime accumulated
	PHDITM	PRCLM,W_PRCLIM,VALUE,2,JIB	; subprocess quota
	PHDITM	ASTLM,W_ASTLM,VALUE,2		; ast limit
	PHDITM	PAGEFLTS,L_PAGEFLTS,VALUE,4	; process accumulated faults
	PHDITM	DIRIO,L_DIOCNT,VALUE,4		; accumulated direct I/Os
	PHDITM	BUFIO,L_BIOCNT,VALUE,4		; accumulated buffered I/Os
	PHDITM	CPULIM,L_CPULIM,VALUE,4		; limit on cputime
	PHDITM	PGFLQUOTA,L_PGFLQUOTA,VALUE,4,JIB ; max. virtual page count
	PHDITM	PAGFILCNT,L_PGFLCNT,VALUE,4,JIB ; current paging file usage
	PHDITM	FILLM,W_FILLM,VALUE,2,JIB	; open file limit
	PHDITM	TQLM,W_TQLM,VALUE,2,JIB		; limit on time queue entries
	PHDITM	AUTHPRIV,Q_AUTHPRIV,BSTRING,8	; authorized privilege mask
	PHDITM	IMAGPRIV,Q_IMAGPRIV,BSTRING,8	; installed image privilege mask
	PHDITM	AUTHPRI,B_AUTHPRI,VALUE,1	; authorized base priority
	PHDITM	PAGFILLOC,L_PAGFIL,VALUE,4	; page file backing store address
	PHDITM	IMAGECOUNT,L_IMGCNT,VALUE,4	; image counter (clocked by RUNDOWN)


	.RESTORE				; restore location

;
; Table to define items which must be handled
; by action routines.
;

SPECIAL:
	SPECIAL_ITEM	PRI,SPC_PRI		; handle priority ...
	SPECIAL_ITEM	PRIB,SPC_PRI		; ... evaluations
	SPECIAL_ITEM	AUTHPRI,SPC_PRI		; all of them
						; compute working set
	SPECIAL_ITEM	WSAUTH,SPC_WORKSET	; ...parameters
	SPECIAL_ITEM	WSQUOTA,SPC_WORKSET	;
	SPECIAL_ITEM	WSEXTENT,SPC_WORKSET	;
	SPECIAL_ITEM	WSAUTHEXT,SPC_WORKSET	;
	SPECIAL_ITEM	DFWSCNT,SPC_WORKSET	;
	SPECIAL_ITEM	IMAGNAME,SPC_IMAGNAME	; find image name

SPECIAL_LEN = <.-SPECIAL>/6			; compute number of entries
	.PAGE
	.SBTTL	SYSGETJPI - GETJPI main program

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This service allows a process to receive information about itself, or
;	any process which it has the UIC privilege to examine.
;	
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	EFN(AP) = number of the event flag to set when all of the requested
;		  data is valid. 
;	PIDADR(AP) = address of a longword containing the process ID of the
;		     process for which the information is being requested
;	PRCNAM(AP) = address of a string descriptor for the process name
;		     of the process for which the information is requested
;	ITMLST(AP) = address of a list of item descriptors of the form:
;
;		+-----------------------------+
;		!  ITEM CODE   !  BUF. LENGTH !
;		+-----------------------------+
;		!      BUFFER ADDRESS         !
;		+-----------------------------+
;		!  ADDRESS TO RETURN LENGTH   !
;		+-----------------------------+
;
;	IOSB(AP) = address of a quadword I/O status block to receive final
;		status
;	ASTADR(AP) = address of an AST routine to be called when all of the
;		requested data has been supplied.
;	ASTPRM(AP) = 32 bit ast parameter
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	SS$_NORMAL -> normal completion
;	SS$_ACCVIO -> ITMLST can not be read by the calling access mode,
;			or the return buffer or return length word can not
;			be written by the calling access mode
;	SS$_BADPARAM -> an invalid item identifier was supplied
;	SS$_IVLOGNAM -> zero or greater than maximum length process name string
;	SS$_NONEXPR -> nonexistant/deleted process or invalid process ID
;		       specified
;	SS$_NOPRIV -> calling process does not have privilege to get information
;		      about the specified process.
;
; SIDE EFFECTS:
;
;	none
;--

	.PSECT	YEXEPAGED		; only entry mask in this program section

	.ENTRY	EXE$GETJPI,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_GETJPI		; transfer to real procedure

	.PSECT	YF$$SYSGETJPI

EXE_GETJPI:
	BSBW	NAMPID			; get PID/PCB address of desired process
	BLBC	R0,15$			; exit if invalid process specified
	MOVAL	LOCAL_SPACE(SP),SP	; allocate local space on stack
;
; Check for, and clear possible IOSB
;
	MOVL	IOSB(AP),R1		; get IOSB address
	BEQL	3$			; branch if none
	IFNOWRT	#8,(R1),30$		; check access to it
	CLRQ	(R1)			; clear IOSB
;
; Check for, and clear event flag
;
3$:	MOVZBL	EFN(AP),R3		; get event flag number
	JSB	SCH$CLREF		; clear this event flag
4$:	BLBC	R0,15$			; and return on errors.
;
; Validate AST, if present. Note R4 still has our PCB address, and R9
; has the PCB address of the process we want information from.
;
	TSTL	ASTADR(AP)
	BEQL	5$			; no AST to check.
	TSTW	PCB$W_ASTCNT(R4)	; is quota exceeded?
	BLEQ	35$			; branch if so and return error
;
; R10 is used to count the items that are in the other process's address
; space. The accumulated size of the user buffers is kept track of
; on top of the stack.
;
5$:	CLRL	R10			; no items yet
	PUSHL	#0			; no accumulated size either
;
; Loop through the item descriptor blocks, validating the requested item
; identifiers and moving accessible items.  A zero item identifier terminates
; the list.
;

	MOVL	ITMLST(AP),R5		; get item descriptor list address
	IFNORD	#4,(R5),30$		; check first longword readable
10$:
	MOVZWL	(R5)+,R6		; get buffer size
	MOVZWL	(R5)+,R1		; get item identifier
	BEQL	50$			; done if zero, take normal exit
	IFNORD	#12,(R5),30$		; check rest of this descriptor ...
					; ... plus first longword of next one
	MOVQ	(R5)+,R7		; get buffer address and return address
	PUSHL	R1			; save R1 across accessibility check
	MOVL	R7,R0			; buffer address to R0
	MOVL	R6,R1			; and size to R1
	CLRL	R3			; PROBE will use PSL<PRVMOD>
	JSB	EXE$PROBEW		; check write accessibility of buffer
	POPL	R1			; restore R1 for use by CHECKITEM
15$:	BLBC	R0,GRET			; return error if inaccessible
	PUSHL	R5			; save R5 from action routines
	BSBW	CHECKITEM		; validate identifier and get item info.
	BLBC	R0,40$			; invalid item if error
	CMPL	R9,SCH$GL_CURPCB	; is this for current process?
	BEQL	20$			; branch if yes
	CMPB	#JPI$C_PCBTYPE,R2	; is this from the PCB then?
	BEQL	20$			; if yes, go pick it up
	CMPB	#JPI$C_JIBTYPE,R2	; is this from the JIB?
	BEQL	20$			; if yes, go pick it up
	CMPB	#JPI$C_ADRTYPE,R2	; is this type ADDRESS?
	BEQL	45$			; return zero
	INCL	R10			; else count up one more for later.
	ADDL2	R6,4(SP)		; and count size of user buffer
	BRB	25$
20$:	BSBW	MOVEIT			; move item to user
25$:	POPL	R5			; restore R5
	BLBS	R0,10$			; back for next descriptor if ok
					; ...else return length not writable

30$:	MOVZWL	#SS$_ACCVIO,R0		; access violation
	BRB	GRET

35$:	MOVZWL	#SS$_EXQUOTA,R0		; AST quota exceeded
	BRB	GRET

40$:	MOVZWL	#SS$_BADPARAM,R0	; illegal item or request
	BRB	GRET

45$:	MOVAL	LOCAL_SPACE(FP),R4	; address item in another process
	CLRL	(R4)			; return zero
	BRB	20$			; ... through common subroutine

50$:	MOVZWL	#SS$_NORMAL,R0		; normal return
	TSTL	R10			; any items in another process's space?
	BNEQ	RESCAN			; if so, go obtain them.
;
; Set the event flag, post the completion status, and declare a completion AST
;
GRET:	PUSHL	R0			; save completion status
	MOVL	SCH$GL_CURPCB,R4	; get PCB address
	MOVL	PCB$L_PID(R4),R1	; get process's PID
	CLRL	R2			; set null priority increment
	MOVL	EFN(AP),R3		; get event flag number to set
	JSB	SCH$POSTEF		; set the event flag
10$:	MOVL	IOSB(AP),R1		; get address of IOSB
	BEQL	20$			; branch if none
	IFNOWRT	#8,(R1),20$		; check if writable
	MOVL	(SP),(R1)		; store completion status
20$:	MOVL	ASTADR(AP),R5		; get address of AST routine
	BEQL	30$			; branch if none specified
	MOVPSL	R4			; get PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R4,R4 ; extract previous mode
	$DCLAST_S (R5),ASTPRM(AP),R4	; queue the completion AST
30$:	POPL	R0			; restore completion status
	RET				; and return.
	.PAGE
	.SBTTL	RESCAN - Rescan item list creating list of items in process
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to obtain information that is contained in another process's
;	virtual address space.  This is accomplished by first creating a list
;	of items that are to be obtained from the other process. An AST is
;	then queued to the process to execute a routine in this service that 
;	copies the desired items to a buffer in non-paged pool.  The routine
;	then queues another AST back to the requesting process to execute
;	another routine in this service to copy the items from the system
;	buffer to the requester's buffers.
;
; CALLING SEQUENCE:
;
;	Branch
;
; INPUTS:
;
;	R10 = number of items that are in other process's address space
;	R11 = PID of other process
;	(SP) = accumulated size of user buffers. A buffer of this size
;		will be allocated from nonpaged pool to hold data from
;		the target process.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	An extended AST control block is allocated and filled-in with the
;	usual AST parameters with the extension containing a list of
;	item descriptors.  A data buffer is also allocated to contain the
;	item data.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	lots
;--

	.ENABLE	LOCAL_BLOCK

5$:	BBC	#PCB$V_SSRWAIT,PCB$L_STS(R4),7$ ; do not wait if set
	ENBINT				; allow interrupts again
	MOVZWL	#SS$_INSFMEM,R0		; indicate no pool left
6$:	BRB	GRET			; and join common exit path

; There is not enough nonpaged pool. The process must be placed into resource
; wait until pool becomes available.

7$:	MOVPSL	R0			; get current PSL
	BICL3	#PSL$M_IPL,R0,(SP)	; wait at IPL 0 to allow ASTs 
	MOVZWL	#RSN$_NPDYNMEM,R0	; ... for some pool to be given back
	JSB	G^SCH$RWAIT		; quota check will be repeated
	MOVL	R6,R1			;  when process executes again
	BRB	8$			; pool available. repeat quota check

RESCAN:
;
; Allocate an extended AST block
;
	MOVL	SCH$GL_CURPCB,R4	; get current PCB address
	MULL3	#ACB_C_IDESC,R10,R1	; compute size of item descriptors
	ADDL2	#ACB_L_ILIST,R1		; plus header
	ADDL2	(SP),R1			; plus buffer size
	MOVL	R1,R6			; save request size for later storage
8$:	JSB	G^EXE$BUFFRQUOTA	; check buffer quota
	BLBC	R0,6$			; quit if not enough quota
9$:	DSBINT	120$			; elevate IPL to SYNCH
	JSB	G^EXE$ALONONPAGED	; now allocate the chunk of pool
	BLBC	R0,5$			; get out if no pool available
;
; Fill-in the standard AST parameters and header information
;
	ENBINT				; allow scheduling again
	MOVL	PCB$L_JIB(R4),R0	; get JIB address
	SUBL	R6,JIB$L_BYTCNT(R0)	; adjust buffer quota
	MOVL	R11,ACB$L_PID(R2)	; PID of target process
	MOVL	R2,R11			; save address of AST block
	MOVW	R6,ACB$W_SIZE(R11)	; save block size for deallocation
	MOVB	#DYN$C_ACB,ACB$B_TYPE(R11) ; set block type
	MOVPSL	R1			; get PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R1,R1 ; get requester's mode
	BISB3	#<1@ACB$V_KAST>,R1,ACB$B_RMOD(R11) ; and put into block
	MOVAB	W^MOVEFU,ACB$L_KAST(R11)	; special kernel address
	MOVL	ASTADR(AP),ACB$L_AST(R11) ; return ast address
	BEQL	10$			; skip quota check if none
	MOVZWL	#SS$_EXQUOTA,R0		; assume exceeded
	TSTL	PCB$W_ASTCNT(R4)	; any left
	BEQL	35$			; hop, skip to error return
	DECW	PCB$W_ASTCNT(R4)	; subtract from quota
	BBSS	#ACB$V_QUOTA,ACB$B_RMOD(R11),10$ ; and record that fact in ACB
10$:	MOVL	ASTPRM(AP),ACB$L_ASTPRM(R11) ; and parameter
	MOVZBL	EFN(AP),ACB_L_EFN(R11)	; efn to set on return
	MOVL	IOSB(AP),ACB_L_IOSB(R11) ; address of possible iosb
	MOVL	PCB$L_PID(R4),ACB_L_OPID(R11) ; our PID
	MOVL	CTL$GL_PHD,R3		; get address of process header
	MOVL	PHD$L_IMGCNT(R3),ACB_L_IMGCNT(R11) ; sequence number of this image
	MOVL	R10,ACB_L_COUNT(R11)	; item count
	CLRL	ACB_L_DADDR(R11)	; no data buffer yet
					; allocated but location not recorded
;
; Loop through the list, copying the item descriptors for items in the
; process's address space to the extended AST block.
;
; The item descriptor list will look like:
;
;	+--------------------------------+
;	! actual length ! buffer length  !
;	+--------------------------------+
;	!    user buffer address         !
;	+--------------------------------+
;	! address to return length       !
;	+--------------------------------+
;
	MOVAL	ACB_L_ILIST(R11),R8	; get address of item descriptor list
	MOVL	ITMLST(AP),R7		; get address of item specifier list
	IFNORD	#4,(R7),30$		; check first longword still readable

15$:	MOVZWL	(R7)+,R6		; get user buffer size
	MOVZWL	(R7)+,R1		; get item identifier
	BEQL	40$			; if zero, we're done with list.
	IFNORD	#12,(R7),30$		; check still readable
	MOVQ	(R7)+,-(SP)		; get user buffer and length addresses
	BSBW	CHECKITEM		; get structure type into R2
	BLBC	R0,20$			; make sure argument list has not changed
	MOVQ	(SP)+,R3		; get user buffer and length addresses
	MOVZBL	#<<1@JPI$C_PCBTYPE>!-	; create mask of types in system space
		  <1@JPI$C_JIBTYPE>!-	;  plus address type, which is 
		  <1@JPI$C_ADRTYPE>>,R5 ;  returned as zero if not for caller
	BBS	R2,R5,15$		; branch if we already got it
	DECL	R10			; decrement item counter
	BLSS	20$			; error if count goes negative
	SUBL2	R6,(SP)			; subtract user buffer size from input
	BLSS	20$			; error if result goes negative
	MOVW	R6,(R8)+		; copy user buffer size
	MOVW	R1,(R8)+		; copy item identifier
	MOVQ	R3,(R8)+		; copy user buffer and length address
	BRB	15$			; and loop through till done.

20$:	PUSHL	S^#SS$_BADPARAM		; set bad parameters failure
	BRB	35$			;

30$:	PUSHL	S^#SS$_ACCVIO		; set access violation failure
35$:	BRW	100$			;

40$:	TSTL	R10			; count should be zero
	BNEQ	20$			; error if it is not.
	TSTL	(SP)+			; so should size be zero
	BNEQ	20$			; error if it is not.
	MOVL	R8,ACB_L_DADDR(R11)	; fill in buffer address
;
; The AST is queued to the destination process unless it has delete or
; suspend pending set, or is currently suspended.
;
50$:	SETIPL	120$			; raise IPL to synch, lock code
	MOVL	R11,R5			; set address of AST block
	MOVZWL	ACB$L_PID(R5),R4	; PIX of destination process
	MOVL	@SCH$GL_PCBVEC[R4],R4	; get PCB address
	CMPL	PCB$L_PID(R4),ACB$L_PID(R5) ; see if PIDs the same
	BNEQ	80$			; and exit if not
	BBS	#PCB$V_DELPEN,PCB$L_STS(R4),80$ ; or if delete pending
	BBS	#PCB$V_SUSPEN,PCB$L_STS(R4),90$ ; or if suspend pending
	CMPW	#SCH$C_SUSP,PCB$W_STATE(R4)
	BEQL	90$			; process suspended, error exit
	CMPW	#SCH$C_SUSPO,PCB$W_STATE(R4)
	BEQL	90$			; or suspended out of memory
	CMPW	#SCH$C_MWAIT,PCB$W_STATE(R4)
	BEQL	90$			; or an indeterminately long wait state
	MOVL	#PRI$_TICOM,R2		; give a big priority increment
	JSB	SCH$QAST		; queue AST to other process
;
; If process is in compute state and at a lower priority than the requesting
; process, boost its current priority to the requesting process's current
; priority.  (Required because event reporting won't normally boost a COM
; state process's priority).
;
	CMPW	#SCH$C_COM,PCB$W_STATE(R4) ; process in compute state?
	BEQL	60$			;
	CMPW	#SCH$C_COMO,PCB$W_STATE(R4) ; or compute out of memory
	BNEQ	70$			; 
60$:	MOVL	SCH$GL_CURPCB,R3	; get requestor's PCB address
	MOVB	PCB$B_PRI(R3),R0	; get requestor's current priority
	CMPB	R0,PCB$B_PRI(R4)	; other process have a higher priority?
	BGEQU	70$			; if GEQU yes - don't boost priority
	CMPB	#16,R0			; will boost be into realtime priority?
	BGTRU	70$			; if GTRU yes - don't boost priority
	JSB	SCH$CHSEP		; boost other process's priority
70$:	MOVZWL	#SS$_NORMAL,R0		; so far, so good.
	SETIPL	#0			;
	RET				;
;
; Error recovery when the process we want to send the AST to has vanished,
; has delete pending, or is suspended; we must release both blocks
;
80$:	MOVZWL	#SS$_NONEXPR,-(SP)	; non-existent process
	BRB	100$

90$:	MOVZWL	#SS$_SUSPENDED,-(SP)	; process is suspended
					;
100$:	MOVZWL	ACB$W_SIZE(R11),R0	; need to restore BYTCNT quota
	MOVL	G^SCH$GL_CURPCB,R4	; to caller of $GETJPI
	MOVL	PCB$L_JIB(R4),R1	; get JIB address
	ADDL2	R0,JIB$L_BYTCNT(R1)	; and give back quota
	BBC	#ACB$V_QUOTA,ACB$B_RMOD(R11),105$ ; also ASTCNT if that
	INCW	PCB$W_ASTCNT(R4)	; was subtracted before
105$:	MOVL	R11,R0			; get address of AST block
	JSB	G^EXE$DEANONPAGED	; deallocate the block
	POPL	R0			; restore status
	SETIPL	#0			; restore IPL to allow page faults
	CMPW	R0,#SS$_NONEXPR		; is error nonexistent process?
	BEQL	130$			; branch if yes
110$:	BRW	GRET			; 


;
; The preceding code must raise IPL to synchronize access to process database,
; but since it is paged it must be locked in memory. The usage of the SETIPL
; macro above, both raises IPL and faults the code into memory.
;
120$:
	.BYTE	IPL$_SYNCH		; end of locked code region
	ASSUME	<.-9$> LE 512		; only 512 bytes can be locked
	ASSUME	<.-50$> LE 512		; only 512 bytes can be locked

;  If process has disappeared (has already been deleted or is in a delete
;  pending state) in the interval between selection and queuing the AST, 
;  and the initial call indicated wild card mode, then go back to the 
;  beginning of the service. Note that wild card mode is indicated by a
;  negative number (usually -1) in the upper word of the PID argument in 
;  the caller's argument list.

130$:	MOVL	PIDADR(AP),R1		; Get PIDADR from argument list
	BEQL	110$			; If not there, can't be wild card mode
	IFNORD	#2,2(R1),110$		; Don't repeat if cannot read parameter
	TSTW	2(R1)			; Look at wild card indicator
	BGEQ	110$			; Must be negative for wild card mode
	MOVL	FP,SP			; Restore SP to its value on entry
	BRW	EXE$GETJPI + 2		;  and go back to the beginning.

	.DISABLE	LOCAL_BLOCK

	.PAGE
	.SBTTL	CHECKITEM - Validate item identifier

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to validate item identifier and return information
;	about the item.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R9 = PCB address
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	R1 = item identifier
;	R2 = structure number
;	R3 = item length
;	R4 = item address (actual address for PCB data, assumes current process
;		for other data)
;	R5 = item type code
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit clear -> successful return
;	R0 low bit set -> invalid item identifier
;
; SIDE EFFECTS:
;
;	none
;--

CHECKITEM:
	CLRL	R0			; assume error
	MOVZBL	R1,R3			; get item number
	EXTZV	#8,#8,R1,R2		; get structure number
	BEQL	80$			; error if structure number zero
	CMPB	R2,#MAXSTRUC		; structure number valid?
	BGTRU	80$			; error if not
	CMPB	R3,MAXCOUNT-1[R2]	; check max item values (1 origin)
	BGTRU	80$			; error if illegal item number
	CASE	R2,<10$,50$,20$,30$>B,#1 ; case on structure base

10$:					; item is an address
	MOVAL	ADRTBL[R3],R4		; address is table address
	ADDL	R3,R4			; base+indexvalue*5
	MOVZBL	4(R4),R2		; get structure type code
	MOVL	#4,R3			; size of data is four bytes
	MOVZBL	#VALUE,R5		; item is a value
	BRB	70$			; all done
20$:					; item is from PCB
	MOVL	R9,R4			; get back PCB address
	MOVAL	PCBTBL,R5		; get address of PCB item table
	BRB	40$			; continue
30$:					; item is from process header
	MOVL	@#CTL$GL_PHD,R4		; get process header address
	MOVAL	PHDTBL,R5		; get address of PHD item table
40$:
	MOVAL	(R5)[R3],R3		; compute address in item table
	MOVZWL	(R3)+,R5		; get offset into data structure

	BRB	60$			; 
50$:					; item is in control region
	MULL	#6,R3			; compute index into item table
	CLRL	R4			; assume zero base value
	MOVAB	CTLTBL[R3],R3		; get address of item information
	MOVL	(R3)+,R5		; get item address
60$:	MOVZBL	1(R3),R2		; fetch actual structure type
	CMPB	#JPI$C_JIBTYPE,R2	; is it the JIB?
	BNEQ	65$			; br if not
	MOVL	PCB$L_JIB(R9),R4	; else get address of JIB
65$:	ADDL	R5,R4			; form complete address
	EXTZV	#5,#3,(R3),R5		; get item type code
	EXTZV	#0,#5,(R3),R3		; get item length
70$:	INCL	R0			; set successful return
80$:	RSB				; return to caller
	.PAGE
	.SBTTL	MOVEIT - Move data to user's buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Move the requested data to user buffer. Zero fill to end of buffer.
;	Return actual data length to user.  Assumes user's buffer has
;	been probed.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R2 = data structure number
;	R3 = item length
;	R4 = item address
;	R5 = item type code
;	R6 = user buffer length
;	R7 = user buffer address
;	R8 = address to return length
;	R11 = PID of process to get data from
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit set -> success
;	R0 low bit clear -> access violation on write of length
;
; SIDE EFFECTS:
;
;	Registers R1-R4 destroyed
;--

MOVEIT:

;
; Call routine to check for special conditions
;

	BSBB	CHECK_SPC

;
; Check for counted string, and find actual length if so.
;

	CMPL	#CSTRING,R5		; is this special string?
	BNEQ	10$			; branch if not
	MOVZBL	(R4)+,R3		; get length and skip length byte
;
; Check that process still exists.  This assures that data address is good.
;
10$:	MOVZWL	R11,R0			; get process ID index
	MOVL	@SCH$GL_PCBVEC[R0],R0	; get PCB address
	CMPL	PCB$L_PID(R0),R11	; same PID?
	BEQL	15$			; branch if yes
	CLRL	R3			; else, zero data size
;
; Move the data
;
15$:	PUSHR	#^M<R3,R5>		; save needed registers from movc
	MOVC5	R3,(R4),#0,R6,(R7)	; move data to user's buffer, zero fill
	POPR	#^M<R3,R5>		; restore registers
	CLRL	R0			; set error code return
	TSTL	R8			; did caller want return length?
	BEQL	30$			; branch if not
	IFNOWRT	#2,(R8),40$		; exit if word not writable
	CMPL	R3,R6			; see how much was moved
	BLEQ	20$			; use valid data length if it fit
	MOVL	R6,R3			; else give him "too short" buffer size
20$:	MOVW	R3,(R8)			; return length to user
30$:	INCL	R0			; set success code
40$:	RSB				; return
	.PAGE
	.SBTTL	SPECIAL - Handle special conditions

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	These routines handle data items which must be transformed
;	before they are returned to the user.  Generally, some
;	transformation is applied to the data item and the newly
;	computed item is stored in LOCAL_SPACE on the stack.
;	The handling routine then changes R4 to point to LOCAL_SPACE
;	so that MOVEIT will move the item from local storage.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R3 = item length
;	R4 = item address
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;--

CHECK_SPC:

;
; Registers R5 and R6 are saved at this level and may be used by
; the action routines without being saved.  Action routines are JSB'ed
; to with R5 containing the address of LOCAL_SPACE on the stack.
;

	MOVQ	R5,-(SP)		; save registers
	MOVL	#SPECIAL_LEN,R5		; get number of table entries
	MOVAL	SPECIAL,R6		; get address of table
10$:
	CMPW	R1,(R6)+		; does entry match item?
	BEQL	20$			; yes, go handle it
	ADDL	#4,R6			; skip handler address
	SOBGTR	R5,10$			; scan rest of table
	BRB	30$			; nothing to do, exit
20$:
	MOVAL	LOCAL_SPACE(FP),R5	; load local address for action routine
	JSB	@(R6)+			; call action routine
30$:
	MOVQ	(SP)+,R5		; restore registers
	RSB
;
; Data handling routines
;

;
; Internal priority must be subtracted from 31 before being returned.
;

SPC_PRI:
	SUBB3	(R4),#31,(R5)		; compute external priority
	MOVL	R5,R4			; change address for move routine
	RSB

;
; Working set pointers are indices into working set list
; and must be subtracted from first list element.
;

SPC_WORKSET:
	MOVL	@#CTL$GL_PHD,R6		; get process header address
	SUBW3	PHD$W_WSLIST(R6),(R4),(R5) ; compute argument size
	MOVL	R5,R4			; change item address
	INCW	(R4)			; must add one to index
	RSB

;
; The current image file name is in the Image File Descriptor Block.  It
; is also in user writable memory, so all addresses must be probed.
;
; Inputs:
;	R4 = CTL$GL_IMGHDRBUF, address of image header buffer
;
; Outputs:
;	R3 = size of image file name
;	R4 = address of image file name
;
SPC_IMAGNAME:
	MOVL	(R4),R4			; get address of image header buffer
	BEQL	10$			; if EQL, no image active
	MOVL	4(R4),R5		; get address of image file descriptor
	IFNORD	#8,IFD$Q_CURPROG(R5),10$,#PSL$C_USER ; check access to desc
	MOVQ	IFD$Q_CURPROG(R5),R3	; get image name descriptor
	MOVZBL	R3,R3			; assure size of string is in range
	IFNORD	R3,(R4),10$,#PSL$C_USER	; check access to string
	RSB				;
10$:
	CLRQ	R3			; zero string descriptor
	RSB				;
	.PAGE
	.SBTTL	MOVEFU - Move data from user to system buffer
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered as the result of a special kernel AST
;	generated by a process requesting information through $GETJPI
;	on another process.  MOVEFU is passed control information and
;	the item list in the AST packet.  Also chained into the AST
;	packet is another packet for returning the data.  This packet
;	is returned by issuing a special kernel AST to the process
;	requesting the information, to the label MOVETU in GETJPI.
;
; CALLING SEQUENCE:
;
;	JSB (as the result of a special kernel AST)
;
; INPUTS:
;
;	R0:R3 - scratch
;	R4 - PCB ADDRESS
;	R5 - AST control block address
;	Control block (see below)
;
; OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	If the process requesting information still exists, a special
;	kernel AST is issued to address MOVETU to process the filled
;	information packets.
;
;--
	.enable lsb
MOVEFU:
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11,FP>
	MOVL	SP,FP			; set address of local storage
	MOVAL	LOCAL_SPACE(SP),SP	; allocate local storage
	MOVL	ACB_L_OPID(R5),ACB$L_PID(R5) ; turn the block around
	MOVAB	W^MOVETU,ACB$L_KAST(R5)	; new AST routine 
	BISB2	#<1@ACB$V_KAST>,ACB$B_RMOD(R5)	; set special kernel bit again
	MOVL	ACB_L_COUNT(R5),R10	; get item count
	MOVL	ACB_L_DADDR(R5),R11	; get data block address
	MOVAL	ACB_L_ILIST(R5),R6	; point to start of item list
;
; Loop through item descriptor list, moving data to the system buffer
;
10$:	MOVZWL	(R6)+,R7		; get system buffer size
	MOVL	R6,R9			; save address of item identifier
	MOVZWL	(R6)+,R1		; item identifier
	BSBW	CHECKITEM		; get address and size of item
	BSBW	CHECK_SPC		; check for special types
	CMPL	#CSTRING,R5		; counted string?
	BNEQ	20$			; branch if not
	MOVZBL	(R4)+,R3		; get length and skip length byte
20$:	MOVW	R3,(R9)			; store size over old item identifier
	MOVC5	R3,(R4),#0,R7,(R11)	; move data to system buffer
	MOVL	R3,R11			; update system buffer pointer
	ADDL	#8,R6			; update item descriptor pointer
					; by skipping user buffer addresses
	SOBGTR	R10,10$			; decrement item count and loop
;
; We have moved all the data to the system buffer. Restore registers, and
; check to see if the requesting process is still active, before we queue the
; return kernel AST.
;
	MOVAL	-LOCAL_SPACE(SP),SP	; remove local storage from stack
	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11,FP>
30$:	SETIPL	50$			; raise IPL to synch, lock code.
	MOVZWL	ACB_L_OPID(R5),R1	; old PID
	MOVL	@SCH$GL_PCBVEC[R1],R1	; PCB address associated.
	CMPL	PCB$L_PID(R1),ACB$L_PID(R5)	; same PID in both places?
	BNEQ	40$			; error if not.
	BBS	#PCB$V_DELPEN,PCB$L_STS(R1),40$ ; error if delete pending
	CLRL	R2			; null priority increment
	JSB	SCH$QAST		; queue the AST
	SETIPL	#IPL$_ASTDEL		; drop back to AST delivery level
	RSB				;
;
; If the process did not exist, or was marked for delete, deallocate the 
; blocks and return.
;
40$:	SETIPL	#IPL$_ASTDEL		; drop back to AST delivery level
	MOVL	R5,R0			; get AST block address
DEANONPAGED:				; local point for all calls to EXE$D...
	JMP	G^EXE$DEANONPAGED	; deallocate it and exit
;
; The preceding code must raise IPL to synchronize access to process database,
; but since it is paged it must be locked in memory. The usage of the SETIPL
; macro above, both raises IPL and faults the code into memory.
;
50$:
	.BYTE	IPL$_SYNCH		; end of locked code region
	ASSUME	<.-30$> LE 512		; only 512 bytes can be locked
	.disable lsb

	.PAGE
	.SBTTL	MOVETU - Move data from system buffer to user
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	MOVETU is entered as the result of a special kernel AST queued by
;	the routine MOVEFU from the process we were requesting information
;	from on a GETJPI system service.  The data buffer has been filled,
;	and now we must move that data from the system buffer to the user.
;
;	Prior to storing the data, we check to see if the copy of PHD$L_IMGCNT
;	that was saved in the packet is the same as that in the process header.
;	If they are not equal, it means the image that issued the GETJPI service
;	has exited, and a new image is in memory; we should not move the data
;	to the user.
;
; CALLING SEQUENCE:
;
;	JSB (as the result of a special kernel AST)
;
; INPUTS:
;
;	R0:R3 - scratch
;	R4 - PCB address
;	R5 - AST control block address
;	Control block data
;
; OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	Attempts to move data to user buffers, as requested by original
;	GETJPI request. May cause setting of event flags, IOSB, and
;	possibly an AST to the requestor.  Errors in processing result
;	in an attempt to post the error status in the IOSB, if specified.
;--
MOVETU:
;
; See if PHD$L_IMGCNT has what we think it has in it, and free the blocks
; and exit if it doesn't; if not equal, a different image is running!
;
	MOVL	CTL$GL_PHD,R3		; get process header address
	CMPL	PHD$L_IMGCNT(R3),ACB_L_IMGCNT(R5) ; see if the same thing.
	BEQL	10$			; go move data if equal
	BBC	#ACB$V_QUOTA,ACB$B_RMOD(R5),5$ ; has AST quota been charged?
	INCW	PCB$W_ASTCNT		; give it back
5$:	MOVL	R5,R0			; get address of AST block
	MOVL	PCB$L_JIB(R4),R1	; get address of JIB
	MOVZWL	ACB$W_SIZE(R0),R2	; convert count to longword
	ADDL	R2,JIB$L_BYTCNT(R1)	; restore buffer quota
	BRB	DEANONPAGED		; deallocate AST block and exit

10$:
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	ACB$B_RMOD(R5),R9	; get requester's access mode
	MOVL	ACB_L_COUNT(R5),R10	; get item count
	MOVL	ACB_L_DADDR(R5),R1	; get data buffer address
	MOVAL	ACB_L_ILIST(R5),R6	; get starting address of the list
;
; Loop through item descriptor list, moving data to user buffer(s)
;
20$:
	MOVZWL	(R6)+,R7		; user buffer length
	MOVZWL	(R6)+,R8		; actual data length
	MOVL	(R6)+,R5		; user buffer address
;
; Check that requester still has write access to his buffer
;
	MOVL	R5,R0			; buffer address to R0
	PUSHL	R1			; Save R1
	MOVL	R7,R1			; and size to R1
	MOVL	R9,R3			; use access mode value from ACB for PROBE
	JSB	EXE$PROBEW		; check write accessibility of buffer
	POPL	R1			; Restore R1
	BLBC	R0,50$			; get out if buffer inaccessible
;
; Now actually move the data
;
	MOVC3	R7,(R1),(R5)		; move data to user buffer
	MOVL	(R6)+,R0		; get address to store actual length
	BEQL	40$			; branch if no length wanted
	IFNOWRT	#2,(R0),50$,R9		; requester still have access to buffer?
	CMPL	R8,R7			; actual data length less than user's?
	BLEQ	30$			; branch if yes - use actual length
	MOVL	R7,R8			; use user buffer length
30$:	MOVW	R8,(R0)			; return buffer length
40$:	SOBGTR	R10,20$			; decrement item count and loop
	MOVZWL	#SS$_NORMAL,R0		; set successful completion
	BRB	60$			;
50$:	MOVZWL	#SS$_ACCVIO,R0		; set access violation failure
;
; Restore original registers, set the event flag, and post completion status
;
60$:	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>
	PUSHL	R0			; save status
	MOVL	ACB_L_EFN(R5),R3	; get event flag number
	MOVL	PCB$L_PID(R4),R1	; and PID for process
	CLRL	R2			; set null priority increment
	JSB	G^SCH$POSTEF		; set the event flag
	POPL	R0			; restore exit status
	MOVL	ACB_L_IOSB(R5),R3	; possible IOSB address?
	BEQL	70$			; branch if none supplied
	IFNOWRT	#4,(R3),70$,ACB$B_RMOD(R5) ; check if IOSB still accessable
	MOVL	R0,(R3)			; store completion status
; Return the BYTCNT quota to the caller
;
70$:	MOVZWL	ACB$W_SIZE(R5),R2	; convert to longword
	MOVL	PCB$L_JIB(R4),R1	; get JIB address
	ADDL	R2,JIB$L_BYTCNT(R1)	; restore buffer quota
;
; If an AST was specified, queue it to caller and return.
;
	TSTL	ACB$L_AST(R5)		; is an address supplied?
	BEQL	80$			; branch if not.
	CLRL	R2			; no priority increment
	JMP	SCH$QAST		; queue AST to user and exit
;
; No AST specified, deallocate the AST control block and return.
;
80$:	MOVL	R5,R0			; set the address of the AST block
	BRW	DEANONPAGED		; deallocate the block and exit
	.PAGE
	.SBTTL	NAMPID - Get specified process ID
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to convert a process name to a PID and check privileges. If a
;	valid PID or process name is specified, the standard conversion
;	routine EXE$NAMPID is simply called.  If, however, a PID that implies
;	a "wildcard" PID (-1) is specified, then the next active process is
;	chosen as the process ID to pass to EXE$NAMPID.  EXE$NAMPID then
;	checks the requestor's privilege to obtain information about the
;	process and returns the process's PCB address.
;
; INPUTS:
;
;	R4 = current process PCB address
;	PIDADR(AP) = address of specified PID
;	PRCNAM(AP) = address of specified process name descriptor
;
; OUTPUTS:
;
;	R0 = success/failure of operation
;	R4 = current process PCB address
;	R9 = specified process PCB address
;	R11 = specified process PID
;	@PIDADR(AP) = specified process PID or special "wildcard" context PID
;--
NAMPID:
	.ENABL	LSB
	CLRL	R5			; assume not "wildcard" PID
	MOVL	PIDADR(AP),R6		; get PID address
	BEQL	20$			; if eql - none
	IFNOWRT	#4,(R6),50$		; check access to PID
	MOVL	(R6),R0			; get PID
	BGEQ	20$			; if geq - standard PID
;
; "Wildcard" type PID specified
;
	CVTWL	R0,R5			; get PIX (Process IndeX) from PID
	BGTR	10$			; if gtr, valid PIX
	MOVZWL	SCH$GL_SWPPID,R5	; else, start with process after SWAPPER
10$:	INCW	R5			; increment PIX
	CMPW	R5,SCH$GL_MAXPIX	; is PIX in valid range?
	BGTRU	60$			; if gtru, no - no more processes
	MOVL	@SCH$GL_PCBVEC[R5],R0	; get PCB address
	CMPL	R0,#SCH$GL_NULLPCB	; unused process slot?
	BEQL	10$			; if eql, yes - try next one
	BBS	#PCB$V_DELPEN,PCB$L_STS(R0),10$ ; also get next one if this
					; one is going away
	MOVL	PCB$L_PID(R0),(R6)	; store PID in argument list
;
; Convert process name to PID, if specified, and check privileges
;
20$:	ADDL	#4,AP			; make PIDADR top argument
	JSB	25$			; get into nonpaged pool
	.SAVE_PSECT			; save current .PSECT context

;  The reason for jumping to the nonpaged exec rather than dynamically
;  locking down pageable pages is that EXE$NAMPID cannot be entered
;  above IPL 2 and the dynamic locking would cause that to happen. The
;  reason that EXE$NAMPID must be entered at IPL 2 or lower is that it
;  touches the caller's argument list (which contains arguments that
;  could fault) and page faults are not allowed above IPL 2.

	.PSECT	AEXENONPAGED		; EXE$NAMPID returns at IPL$_SYNCH
25$:	BSBW	EXE$NAMPID		; get PCB address and check privileges
	SETIPL	#0			; restore IPL - PCB is no longer locked
	RSB				; go back to paged code

	.RESTORE_PSECT			; get paged .PSECT context back
	SUBL	#4,AP			; restore argument pointer
	MOVL	R1,R11			; save PID
	TSTW	R5			; "wildcard" type PID specified?
	BEQL	30$			; if eql, no
	MNEGW	#1,2(R6)		; else, set continuation context
;
; Check PID address and return
;
30$:	BLBC	R0,40$			; branch if error
	MOVL	R4,R9			; save PCB address
	CMPW	R11,SCH$GL_SWPPID	; is PID valid?
	BGTRU	40$			; if GTRU, yes
	MOVZWL	#SS$_NONEXPR,R0		; NULL and SWAPPER are invalid
40$:	MOVL	SCH$GL_CURPCB,R4	; restore current PCB address
	RSB

50$:	MOVZWL	#SS$_ACCVIO,R0		; set access violation
	BRB	40$			;
60$:	MOVZWL	#SS$_NOMOREPROC,R0	; set no more processes
	BRB	40$			;

	.END
