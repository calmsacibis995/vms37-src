	.TITLE	PROCSTRT - PROCESS STARTUP AND INITIALIZATION
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, PROCESS CREATION SYSTEM SERVICE
;
; ABSTRACT:
;	PROCSTRT CONTAINS THE CODE NECESSARY TO CONCLUDE THE CREATION
;	OF A PROCESS WHICH MUST BE EXECUTED IN THE CONTEXT OF THAT PROCESS.
;
; ENVIRONMENT:
;	MODE=KERNEL, EXECUTING IN CONTEXT OF NEW PROCESS
;
; AUTHOR: R. I. HUSTVEDT	, CREATION DATE: 27-DEC-76
;
; MODIFIED BY:
;
;	V03-001	LJK0158		Lawrence J. Kenah	9-Apr-1982
;		Initialize privileged vector reset context.
;
;	V02-023	LJK0127		Lawrence J. Kenah	12-Feb-1982
;		Copy account name to JIB.
;
;	V02-022	TMH0022		Tim Halvorsen		08-Jan-1982
;		Get default message flags of new process from parent
;		process.
;
;	V02-021	ACG0251		Andrew C. Goldstein,	29-Dec-1981  22:30
;		Get default file protection from creator
;
;	V02-021	LJK0088		Lawrence J. Kenah	18-Nov-1981
;		Capture PQB address immediately so that page fault with
;		potential resource wait does not overwrite PQB address.
;
;	V02-019	LJK0068		Lawrence J. Kenah	10-Nov-1981
;		Add initialization of PHD$B_AUTHPRI with new value
;		of base priority.
;
;	V02-018	LJK0062		Lawrence J. Kenah	10-Sep-1981
;		Add call to perform activation time address relocation.
;
;	V02-017	LMK0003		Len Kawell		03-Sep-1981
;		Change PSECT name to re-order system image.
;
;	V02-016	LJK0048		Lawrence J. Kenah	19-Aug-1981
;		Move image activator fixups so that they precede
;		EXE$PROCIMGACT label.
;
;	V02-015	LJK0046		Lawrence J. Kenah	19-Aug-1981
;		Move largest allowed default directory string into PQB
;		to process I/O segment in P1 space.
;
;	V02-015	KTA0027		Kerbey T. Altmann	30-Jul-1981
;		Modification for indirection in log table pointers.
;
;	V02-014	LJK0015		Lawrence J. Kenah	17-Jul-1981
;		Initialize image activator fixup vector lists.
;
;	V02-013	KTA0024		Kerbey T. Altmann	05-Jul-1981
;		Allocate logical name hash table for process.
;
;	V02-012	KTA0022		Kerbey T. Altmann	14-Jun-1981
;		Removed exception table, use one in SYSPUTMSG instead.
;		Do not attempt to print any messages if system
;		services inhibited for this process.
;
;	V02-011	HRJ0020		Herb Jacobs		27-Apr-1981
;		Add new quota PHD$W_WSEXTENT.
;
;	V02-010	KTA0010		Kerbey T. Altmann	03-Mar-1981
;		Add support for SYSGEN parameter CHANNELCNT by creating
;		the channel table here dynamically instead of in SHELL.
;
;	V02-009	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to use CTL$GL_PCB instead.
;
;	V02-008	KTA0001		Kerbey T. Altmann	16-Jan-1981
;		Add support for user rundown service vector.
;
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$CCBDEF				; CHANNEL CONTROL BLOCK DEFINITIONS
	$CHFDEF				; CONDITION HANDLER DEFINITIONS
	$CLIMSGDEF			; DEFINE COMMAND INTERPRETER STATUS CODES
	$IHDDEF				; IMAGE HEADER DESCRIPTOR DEFINITIONS
	$JIBDEF				; DEFINE JIB OFFSETS
	$OPDEF				; SYMBOLIC NAMES FOR INSTRUCTION OPCODES
	$PCBDEF				; DEFINE PCB OFFSETS
	$PHDDEF				; DEFINE PROCESS HEADER
	$PQBDEF				; DEFINE PROCESS QUOTA BLOCK OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRTDEF				; DEFINE PAGE PROTECTION VALUES
	$PSLDEF				; DEFINE PSL FIELDS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$STSDEF				; DEFINE STATUS CODE FIELDS
;
; MACROS:
;

	.MACRO	CRELOG,SRC,RESULT	;
	BSBW	CREATELOG		;
	.BYTE	<SRC-DESCBASE>,<RESULT/4>	;
	.ENDM	CRELOG			;
;
; EQUATED SYMBOLS:
;
NXTKVEC=0			;OFFSET TO NEXT FREE KERNEL VECTOR
NXTEVEC=256			;OFFSET TO NEXT FREE EXEC VECTOR
NXTRVEC=512				; OFFSET TO NEXT FREE RUNDWN VECTOR
NXTMVEC=768			;OFFSET TO NEXT MESSAGE VECTOR

;
; OWN STORAGE:
;

	.PSECT	YEXEPAGED2,BYTE		; PAGED PSECT
INPNAM:	.ASCII	/SYS$INPUT/		; INPUT NAME STRING
OUTNAM:	.ASCII	/SYS$OUTPUT/		; OUTPUT NAME STRING
ERRNAM:	.ASCII	/SYS$ERROR/		; ERROR NAME STRING
DISKNAM:.ASCII	/SYS$DISK/		; DISK NAME STRING
TTNAM:	.ASCII	/TT/			; TT NAME STRING ***TEMP***
DEFTYP:	.ASCII	/.EXE/			; DEFAULT IMAGE FILE NAME
DESCBASE:				; DESCRIPTOR BASE
INPDESC:.LONG	9,INPNAM		; INPUT STRING DESCRIPTOR
OUTDESC:.LONG	10,OUTNAM		; OUTPUT STRING DESCRIPTOR
ERRDESC:.LONG	9,ERRNAM		; ERROR STRING DESCRIPTOR
EXE$GQ_SYSDISK::			; DESCRIPTOR FOR SYS$DISK
	.LONG	8,DISKNAM		; 
TTDESC:	.LONG	2,TTNAM			; TT STRING DESCRIPTOR
DEFDESC:.LONG	4,DEFTYP		; DEFAULT TYPE DESCRIPTOR
 
;
; CATCH ALL HANDLER FATAL CONDITION MESSAGE SUFFIX
;
 
SUFFIX:	.ASCIZ	/image exit forced./	;
	.PAGE
	.SBTTL	EXE$PROCSTRT - STARTUP NEW PROCESS
;++
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;	NONE
;
; INPUT PARAMETERS:
;	SCH$GL_CURPCB - POINTS TO PCB OF CURRENT PROCESS
;	PCB$L_PQB - POINTER TO PROCESS QUOTA BLOCK
;
; IMPLICIT INPUTS:
;	IPL = IPL$_ASTDEL
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	LOGICAL NAMES ARE DEFINED FOR 'SYS$INPUT', 'SYS$OUTPUT', AND 'SYS$ERROR'
;	BASED ON THE STRINGS PASSED IN THE PROCESS QUOTA BLOCK.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--


;
;  The PQB address must be stored before any instruction that can cause a page 
;  fault. If a page fault occurs and the process is put into a resource wait
;  state, then the PQB address will be lost because the EFWM field, used to
;  store the resource number, overlaps PCB$L_PQB. This forces the first
;  two instructions into a nonpaged program section.
;

	.PSECT	AEXENONPAGED

EXE$PROCSTRT::				; STARTUP NEW PROCESS
	MOVL	SCH$GL_CURPCB,R4	; GET POINTER TO CURRENT PCB
	MOVL	PCB$L_PQB(R4),R6	; GET POINTER TO PROCESS QUOTA BLOCK
	JMP	G^EXE_PROCSTRT		; CONTINUE IN PAGEABLE EXEC

	.PSECT	YEXEPAGED2

EXE_PROCSTRT:
;
;	N O T E :   THERE CAN BE NO I/O TO A PROCESS CHANNEL BETWEEN HERE
;		    AND THE END OF THE NEW CHANNEL CREATION CODE.
;
	MOVL	G^MMG$GL_RMSBASE,G^CTL$GL_RMSBASE ; SET RMS DISPATCHER BASE
	MOVL	G^MMG$GL_CTLBASVA,G^CTL$GL_CTLBASVA ; SET CTL BASE ADDRESS
;
; INITIALIZE THE DISPATCH VECTORS.
;
	MOVAB	@#CTL$A_DISPVEC,R5	; GET ADR OF 1ST VECTOR PAGE
	MOVZBL	#04,NXTKVEC(R5)		; SET OFFSET TO 1ST FREE KERNEL VECTOR
	MOVZBL	#04,NXTEVEC(R5)		; SET OFFSET TO 1ST FREE EXEC VECTOR
	MOVZBL	#04,NXTRVEC(R5)		; SET OFFSET TO 1ST FREE RUNDWN VECTOR
	MOVZBL	#04,NXTMVEC(R5)		; SET OFFSET TO 1ST FREE MESSAGE VECTOR
	MOVZBL	#OP$_RSB,NXTKVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVZBL	#OP$_RSB,NXTEVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVZBL	#OP$_RSB,NXTRVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVZBL	#OP$_RSB,NXTMVEC+4(R5)	; SET AN "RSB" INTO THE 1ST FREE VECTOR
	MOVAB	NXTKVEC+4(R5),G^CTL$GL_USRCHMK ; SET POINTER TO START OF VECTOR
	MOVAB	NXTEVEC+4(R5),G^CTL$GL_USRCHME ; SET POINTER TO START OF VECTOR
	MOVAB	NXTRVEC+4(R5),G^CTL$GL_USRUNDWN ; SET POINTER TO START OF VECTOR
	MOVAB	NXTMVEC+4(R5),G^CTL$GL_GETMSG ; SET POINTER TO START OF VECTOR
	MOVL	R4,G^CTL$GL_PCB		; SET POINTER TO PCB
	ASSUME PHD$Q_PRIVMSK EQ 0
	MOVL	@#CTL$GL_PHD,R5		; GET SAFE POINTER TO PROCESS HEADER WINDOW
	MOVL	PCB$L_JIB(R4),R7	; GET JIB ADDRESS
	MOVQ	PQB$T_ACCOUNT(R6),@#CTL$T_ACCOUNT ; INHERIT ACCOUNT
	MOVQ	PQB$T_ACCOUNT(R6),JIB$T_ACCOUNT(R7) ; PUT IT HERE, TOO
	PUSHR	#^M<R4,R5>		; SAVE MOVC REGISTERS
	TSTB	PQB$T_USERNAME(R6)	; TEST FOR NULL STRING
	BEQL	10$			; YES DONT MOVE
	MOVC3	#12,PQB$T_USERNAME(R6),@#CTL$T_USERNAME ; AND USERNAME
	MOVC3	#12,PQB$T_USERNAME(R6),-; SET USER NAME IN JIB ALSO
		JIB$T_USERNAME(R7)	;
10$:	TSTB	PQB$T_DDSTRING(R6)	; CHECK FOR NULL STRING
	BEQL	20$			; YES, DONT MOVE ANYTHING
	MOVC3	#PQB$C_MAXDIRLEN,-
		PQB$T_DDSTRING(R6),@#PIO$GT_DDSTRING ; AND DEFAULT DIRECTORY
20$:	POPR	#^M<R4,R5>		; RESTORE MOVC REGISTERS
	.ENABL	LSB
SETQUOTAS:				; SET PROPER QUOTAS FROM PQB
	MOVL	PQB$L_CPULM(R6),PHD$L_CPULIM(R5) ; SET CPU TIME LIMIT
	CVTLW	PQB$L_ASTLM(R6),PHD$W_ASTLM(R5)  ; SET AST LIMIT
	MOVL	SGN$GL_MAXWSCNT,R1	; GET MAXIMUM WORKING SET LIST LENGTH
	SUBL3	SCH$GL_FREELIM,PFN$GL_PHYPGCNT,R0 ; GET AVAILABLE PAGES
	CMPL	R0,R1			; MINIMIZE WITH SPECIFIED QUOTA
	BLEQ	10$			; USE QUOTA
	MOVL	R1,R0			; USE MAXIMUM WORKING SET COUNT
10$:	MOVZWL	PQB$L_WSEXTENT(R6),R1	; GET MAXIMUM PAGES FOR WORKING SET
	MOVZWL	PQB$L_WSQUOTA(R6),R2	; GET MAXIMUM QUOTA FOR WORKING SET
	MOVZWL	PQB$L_WSDEFAULT(R6),R3	; GET DESIRED DEFAULT
	CMPL	R1,R2			; EXTENT MUST BE BIGGER THAN QUOTA
	BGEQ	20$			; YES, USE IT AS IS
	MOVL	R2,R1			; FORCE TO QUOTA (EXTENT MAY BE 0)
20$:	CMPL	R1,R0			; EXTENT MUST BE LESS THAN MAX PAGES
	BLEQ	30$			; BRANCH IF OK AS IS
	MOVL	R0,R1			; SET EXTENT TO MAX MEMORY
30$:	CMPL	R2,R1			; QUOTA MUST BE LESS THAN EXTENT
	BLEQ	40$			; BRANCH IF OK AS IS
	MOVL	R1,R2			; SET QUOTA TO EXTENT
40$:	CMPL	R3,R2			; DEFAULT MUST BE LESS THAN QUOTA
	BLEQ	50$			; BRANCH IF OK AS IS
	MOVL	R2,R3			; SET DEFAULT TO QUOTA
50$:	SUBW3	#1,PHD$W_WSLIST(R5),R0	; GET BASE OFFSET TO WORKING SET LIST
	ADDW	R0,R1			; GET EXTENT
	MOVW	R1,PHD$W_WSEXTENT(R5)	; SET EXTENT
	MOVW	R1,PHD$W_WSAUTHEXT(R5)	; SET AUTHORIZED EXTENT
	ADDW	R0,R2			; GET QUOTA
	MOVW	R2,PHD$W_WSQUOTA(R5)	; QUOTA VALUE
	MOVW	R2,PHD$W_WSAUTH(R5)	; AUTHORIZED VALUE
	ADDW3	R0,R3,PHD$W_DFWSCNT(R5)	; SAVE DEFAULT WORKING SET SIZE

	EXTZV	#PCB$V_HIBER,#1,PCB$L_STS(R4),R8; SAVE HIBERNATE CONTROL
	MOVB	PCB$B_PRIB(R4),PHD$B_AUTHPRI(R5) ; SET INITIAL PROCESS PRIORITY
	MOVQ	PQB$Q_PRVMSK(R6),@PCB$L_PHD(R4)	; SET PRIVILEGES FOR PROCESS
	MOVQ	PQB$Q_PRVMSK(R6),@#CTL$GQ_PROCPRIV; BOTH PERMANENT AND CURRENT
	MOVQ	PQB$Q_PRVMSK(R6),PHD$Q_AUTHPRIV(R5) ; AND AUTHORIZED MASKS
	MOVW	PQB$W_FILEPROT(R6),@#PIO$GW_DFPROT ; GET DEFAULT FILE PROTECTION
	MOVB	PQB$B_MSGMASK(R6),@#CTL$GB_MSGMASK ; GET DEFAULT MESSAGE FLAGS
	MOVAL	-PQB$C_LENGTH(SP),SP	; RESERVE SPACE FOR PQB ON STACK
	PUSHR	#^M<R4,R5>		; SAVE PCB AND PHD POINTERS
	MOVC3	#PQB$C_LENGTH,(R6),8(SP); COPY PQB TO STACK
	POPR	#^M<R4,R5>		; RESTORE PCB,PHD POINTERS
	MOVL	R6,R0			; PROCESS QUOTA BLOCK ADDRESS
	JSB	EXE$DEANONPAGED		; DEALLOCATE IT
	MOVL	SP,R6			; NOW POINT TO STACK COPY
	MOVQ	EXE$GQ_SYSTIME,@#CTL$GQ_LOGIN	; SAVE LOGIN TIME
;
; ALLOCATE THE PROCESS LOGICAL NAME HASH TABLE AND INITIALIZE IT.
;
	MOVL	G^LOG$GL_HTBLSIZP,R1	; SIZE OF TABLE IN ENTRIES
	MOVAL	@#12[R1],R1		; MULT BY 4 AND ADD 12 FOR OVERHEAD
	MOVAB	@#CTL$GQ_ALLOCREG,R3	; HEAD OF PROCESS ALLOC REGION
	JSB	G^EXE$ALLOCATE		; ALLOCATE IT
	CLRQ	(R2)+			; CLEAR UNUSED WORDS
	MOVW	R1,(R2)+		; INSERT SIZE
	MOVZBW	#DYN$C_RSHT,(R2)+	; INSERT BLOCK TYPE
	MOVL	R2, @#CTL$GL_LOGTBL	; STORE POINTER AWAY
	SETIPL	#0			; AND DROP IPL **** ALLOW DELPRC NOW ****
	CRELOG	INPDESC,PQB$T_INPUT	; CREATE INPUT LOGICAL NAME
	CRELOG	OUTDESC,PQB$T_OUTPUT	; CREATE OUTPUT LOGICAL NAME
	CRELOG	ERRDESC,PQB$T_ERROR	; CREATE ERROR LOGICAL NAME
	CRELOG	TTDESC,PQB$T_INPUT	; CREATE TT LOGICAL NAME ***TEMP***
	CRELOG	EXE$GQ_SYSDISK,PQB$T_DISK;CREATE DEFAULT DISK DEVICE NAME
	MOVAL	@#MMG$IMGHDRBUF,AP	; IMAGE HEADER BUFFER ADDRESS
	BSBW	MMG$IMGRESET		; RESET ADDRESS SPACE AND SET WSLAST
;
; CREATE THE I/O CHANNEL TABLE FROM P1 SPACE (JUST AFTER - LOWER ADDRESSES -
; THE PHD WINDOW).  THE NUMBER OF CHANNELS IS PICKED UP FROM THE SYSGEN
; PARAMETER 'CHANNELCNT'.  AT SOME FUTURE DATE IT COULD BE DONE ON A PER-
; PROCESS BASIS.  
;			********  N O T E  *********
;
; THIS CHANGE MEANS THAT NO I/O CAN BE DONE UNTIL AFTER THIS SECTION OF CODE.
;
	MOVAL	@#CTL$GL_CTLBASVA, R5	; KEEP IN REGISTER
	SUBL3	#1, (R5), -(SP)		; 'LAST' PAGE IN P1
	MOVZWL	G^SGN$GW_PCHANCNT, R3	; PICK UP SYSGEN PARAM FOR #CHANNELS
	MOVL	R3,R4			; HOLD IN REGISTER TILL FINISHED
	INCL	R3			; ALLOW FOR 'WASTED' CCB
	MULL2	#CCB$C_LENGTH, R3	; CONVERT TO #BYTES
	SUBL3	R3, (R5), -(SP)		; 'FIRST' PAGE OF CHANNELS
	MOVAQ	-(SP), R2		; SPACE FOR RETADR
	$CRETVA_S  INADR=8(R2)-		; CREATE P1 SPACE FOR CHANNELS
		   RETADR=(R2)-
		   ACMODE=#PSL$C_KERNEL	; KERNEL OWNER
	BLBC	R0, 60$			; ERROR
	BICW	#511, 8(R2)		; ROUND UP
	CMPL	(R2), 8(R2)		; DID WE GET OUR FULL REQUEST?
	BNEQ	60$			; NO, ERROR OUT
	CMPL	4(R2), 12(R2)		; MAKE DOUBLY SURE
	BNEQ	60$			; NO, ERROR OUT
	$SETPRT_S  INADR=8(R2)-		; SET PROTECTION ON PAGES
		   RETADR=(R2)-
		   ACMODE=#PSL$C_KERNEL-
		   PROT=#PRT$C_UREW	;     TO USER READ-EXEC WRITE
	BLBS	R0, 70$			; SUCCESS, SKIP ERROR
60$:	BUG_CHECK  UNABLCREVA		; NON-FATAL BUGCHECK
	$EXIT_S	R0			; EXIT THE PROCESS WITH THE ERROR
;
70$:	MOVL	8(R2), (R5)		; UPDATE BASE OF VA IN CTL REGION
	SUBL3	#CCB$C_LENGTH-1, 4(R2),-; STORE BASE OF CHANNEL TABLE
		@#CTL$GL_CCBBASE
	MOVW	R4, @#CTL$GW_NMIOCH	; SET NUMBER OF CHANNELS
;
; NOTE(!!!!):	THE ABOVE ASSIGNMENT MUST BE DONE AT THE VERY END OF THIS
;		SECTION OF CODE, AS THE CELL NMIOCH BEING NON-ZERO IS AN
;		INDICATOR TO IOC$FFCHAN THAT THERE IS ACTUALLY A REAL
;		CHANNEL TABLE TO LOOK AT.
;
	MOVZBL	PQB$T_IMAGE(R6),(AP)	; SIZE OF IMAGE NAME STRING
	MOVAL	8(AP),4(AP)		; ADDRESS OF IMAGE NAME STRING
	MOVC3	(AP),PQB$T_IMAGE+1(R6),8(AP) ; MOVE THE NAME STRING
;
; R0-R5 DESTROYED BY ABOVE
;
	MOVAL	PQB$C_LENGTH+16(SP),SP	; CLEAN PQB + $CRETVA ARGS FROM STACK
	ROTL	#PSL$V_PRVMOD,#<PSL$C_EXEC@2+PSL$C_EXEC>,-(SP) ; FORM EXEC PSL
	BSBW	80$			; CHANGE TO EXEC MODE

;
; INITIALIZE FIXUP VECTOR LINKED LISTS TO CONTAIN A SINGLE DUMMY ENTRY
;
	MOVAL	@#CTL$GL_IAFPERM,@#CTL$GL_IAFLINK
	MOVAL	@#CTL$GL_IAFPERM,@#CTL$GL_IAFLAST

;
; INITIALIZE ARRAY THAT DETERMINES HOW PRIVILEGED VECTORS ARE RESET
;
	MOVAW	@#IAC$AW_VECRESET,R0	; STORE ARRAY ADDRESS
	MOVW	#4,(R0)+		; KERNEL VECTOR
	MOVW	#4,(R0)+		; EXEC VECTOR
	MOVW	#4,(R0)+		; RUNDOWN VECTOR
	MOVW	#4,(R0)+		; MESSAGE VECTOR

EXE$PROCIMGACT::			; ENTRY POINT FOR STAND-ALONE SYSGEN
	MOVZBL	(AP),R2			; GET ADR OF FILENAME STRING DESC
	ADDL	#3,R2			; ROUND THE NUMBER OF BYTES IN
	BICL	#3,R2			; THE NAME UP TO A LONGWORD BOUNDRY
	SUBL	R2,SP			; ALLOCATE SPACE FOR NAME ON STACK
	PUSHAB	(SP)			; BUILD STRING DESCRIPTOR FOR
	MOVZBL	(AP),-(SP)		; FILENAME ON THE STACK
	MOVL	SP,R1			; GET ADR OF STRING DESCRIPTOR
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVC3	R2,@4(AP),@4(R1)	; MOVE FILENAME TO STACK
	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	$IMGACT_S -			; ACTIVATE THE IMAGE
		NAME  =(AP),-		; DESCRIPTOR FOR IMAGE NAME
		DFLNAM=DEFDESC,-	; DEFAULT NAME DESCRIPTOR
		HDRBUF=(AP)		; ADDRESS IF IMAGE HEADER BUFFER
	ADDL	#8,R2			; CALCULATE # OF BYTES ON STACK
	ADDL	R2,SP			; AND CLEAN THEM OFF
	BLBC	R0,75$			; BRANCH IF IMGACT FAILED
	MOVAB	W^EXE$CLI_UTILSRV+2,G^CTL$AL_CLICALBK ; SET CLI CALL BACK ADDRESS
	ROTL	#PSL$V_PRVMOD,#<PSL$C_EXEC@2+PSL$C_EXEC>,-(SP) ; FORM EXEC PSL
	BSBB	80$			; CHANGE MODE TO EXECUTIVE
	MOVAB	@#PIO$AL_RMSEXH,R0	; GET ADDRESS OF EXIT HANDLER CONTROL BLOCK
	MOVAB	W^EXE$RMSEXH,4(R0)	; SET ADDRESS OF RMS EXIT HANDLER
	$DCLEXH_S (R0)			; DECLARE EXECUTIVE MODE EXIT HANDLER
75$:	BLBC	R0,120$			; IF LBC ERROR
	ROTL	#PSL$V_PRVMOD,#<PSL$C_USER@2+PSL$C_USER>,-(SP) ; FORM USER PSL
	BSBB	80$			; CHANGE TO USER MODE
	CLRL	FP			; TERMINATE CALL FRAME CHAIN
	CALLG	(AP),B^90$		; CREATE TOP FRAME
80$:	REI				; CHANGE TO NEW MODE
90$:	.WORD	0			; ENTRY MASK 
	MOVAB	B^EXE$CATCH_ALL,(FP)	; SET EXCEPTION HANDLER ADDRESS
	$SETEXV_S #2,B^EXE$CATCH_ALL	; DECLARE LAST CHANCE HANDLER
	$IMGFIX_S			; PERFORM ADDRESS RELOCATION
	BLBC	R0,120$			; QUIT IF ERROR OCCURS
	PUSHL	R8			; SAVE HIBERNATE FLAG
100$:	MOVQ	(AP),R2			; GET IMAGE HEADER BLOCK DESCRIPTOR
	CLRL	-(SP)			; CLEAR COMMAND INTERPRETER FLAGS
	PUSHL	IHD$L_LNKFLAGS(R2)	; PUSH LINKER FLAGS
	MOVQ	R2,-(SP)		; THIRD AND FOURTH ARGUMENTS TO PROG
	PUSHAB	B^EXE$CLI_UTILSRV	; PUSH ADDRESS OF CLI CALL BACK ROUTINE
	MOVZWL	IHD$W_ACTIVOFF(R2),R1	; OFFSET TO TRANSFER VECTOR
	ADDL	R1,R2			; FORM ADDRESS OF START VECTOR
	PUSHAL	(R2)			; MOVE TO ARGUMENT LIST
	BLBC	24(SP),110$		; BR IF NO HIBERNATE
	$HIBER_S			; SET, HIBERNATE UNTIL SOME WAKE
110$:	CALLS	#6,@(R2)+		; CALL IMAGE
	BLBC	R0,120$			; EXIT IF NOT SUCCESS
	BLBS	(SP),100$		; CHECK FOR HIBERNATE AGAIN
120$:	BRB	EXE$EXIT_IMAGE		;
 
;
; DUMMY COMMAND INTERPRETER CALL BACK ROUTINE
;
 
	.ENTRY	EXE$CLI_UTILSRV,^M<>
	MOVL	#CLI$_INVREQTYP,R0	; SET INVALID REQUEST TYPE STATUS
	RET				;

	.DSABL	LSB
	.PAGE
	.SBTTL	EXIT IMAGE AND RUN DOWN FILES
;+
;
; EXE$EXIT_IMAGE - EXIT IMAGE AND RUN DOWN FILES
;
; THIS ROUTINE IS JUMPED TO AT THE CONCLUSION OF IMAGE EXECUTION TO RUN DOWN
; RMS FILES AND TO RETURN THE FINAL IMAGE STATUS.
;
; INPUTS:
;
;	R0 = FINAL IMAGE STATUS.
;
; OUTPUTS:
;
;	IMAGE EXIT IS EXECUTED.
;-
 
EXE$EXIT_IMAGE::			; EXIT IMAGE
	PUSHL	R0			; SAVE FINAL IMAGE STATUS
	PUSHL	#1			; SET NUMBER OF ARGUMENTS
10$:	CALLG	(SP),@#SYS$EXIT		; EXIT IMAGE
	BRB	10$			;
	.PAGE
	.SBTTL	CATCH ALL CONDITION HANDLER
;+
; EXE$CATCH_ALL - CATCH ALL CONDITION HANDLER
;
; THIS ROUTINE IS ENTERED AS THE RESULT OF AN UNFIELDED OR IMPROPERLY HANDLED
; EXCEPTION CONDITION OR SOFTWARE SIGNAL.
;
; INPUTS:
;
;	CHF$L_MCHARGLST(AP) = ADDRESS OF MECHANISM ARGUMENT LIST.
;	CHF$L_SIGARGLST(AP) = ADDRESS OF CONDITION ARGUMENT LIST.
;
; OUTPUTS:
;
;	A MESSAGE IS ISSUED USING THE SYS$PUTMSG SYSTEM SERVICE AND A TEST IS
;	MADE ON THE CONDITION NAME TO DETERMINE IF THE IMAGE SHOULD BE ALLOWED
;	TO CONTINUE EXECUTION. THE FOLLOWING CONDITIONS CAUSE A FORCED IMAGE
;	EXIT:
;
;		1. ANY ENTRY TO THIS ROUTINE VIA THE LAST CHANCE VECTOR.
;
;		2. THE CONDITION NAME HAS A SEVERITY OF "SEVERE ERROR".
;
;	IF A FORCED IMAGE EXIT IS PERFORMED, THEN A SUMMARY OF THE CONDITION
;	ARGUMENTS AND FINAL REGISTERS ARE WRITTEN TO SYS$OUTPUT.
;-
 
	.ENTRY	EXE$CATCH_ALL,^M<>
	PUSHL	#0			; SET EXCEPTION NAME FLAG FALSE
	PUSHL	R2			; SAVE REGISTER
	MOVL	CHF$L_SIGARGLST(AP),R2	; GET ADDRESS OF SIGNAL ARGUMENTS
	PUSHL	(R2)			; SAVE NUMBER OF ARGUMENTS
	CMPW	CHF$L_SIG_NAME(R2),#SS$_SSFAIL	; IS EXCEPTION SYS. SERV. FAIL.?
	BNEQ	5$			; NO
	$SETSFM_S	#0		; YES, TURN OFF SYS. SERV. FAIL. EXCEP.
5$:	TSTW	CHF$L_SIG_NAME+2(R2)	; POSSIBLY SYSTEM EXCEPTION NAME?
	BNEQ	20$			; IF NEQ NO
	INCL	8(SP)			; SET EXCEPTION NAME FLAG TRUE
	MOVAB	W^EXE$EXCEPTABLE,R1	; GET ADDRESS OF EXCEPTION TABLE
	MOVZBL	(R1)+,R0		; SET LOOP COUNT
10$:	TSTB	(R1)+			; SKIP NUMBER OF ARGUMENTS
	MOVZWL	(R1)+,-(SP)		; GET NEXT HARDWARE EXCEPTION CODE
	CMPZV	#STS$V_CODE,#STS$S_CODE,- ; CONDITION VALUE HARDWARE CODE?
		CHF$L_SIG_NAME(R2),(SP)+ ;
	BEQL	30$			; IF EQL YES
	SOBGTR	R0,10$			; ANY MORE TO COMPARE?
	CLRL	8(SP)			; SET EXCEPTION NAME FALG FALSE
20$:	SUBL	#2,(R2)			; ADJUST LENGTH OF ARGUMENT LIST
30$:	TSTB	@#CTL$GB_SSFILTER	; SYSTEM SERVICE INHIBITED NOW?
	BNEQ	35$			; YES, DO NOT TRY TO PRINT ANYTHING
	PUSHL	#0			; CLEAR ADDRESS OF FACILITY NAME DESCRIPTOR
	PUSHL	#0			; CLEAR ADDRESS OF ACTION ROUTINE
	PUSHAB	(R2)			; SET ADDRESS OF MESSAGE VECTOR
	CALLS	#3,@#SYS$PUTMSG		; OUTPUT MESSAGE
35$:	POPL	(R2)			; RESTORE ARGUMENT COUNT
	MOVL	CHF$L_SIG_NAME(R2),R0	; GET CONDITION NAME
	POPL	R2			; RESTORE REGISTER
	MOVL	CHF$L_MCHARGLST(AP),R1	; GET ADDRESS OF MECHANISM ARRAY
	ADDL3	#3,CHF$L_MCH_DEPTH(R1),-(SP) ; LAST CHANCE ENTRY?
	BEQL	50$			; IF EQL YES
	BLBS	R0,40$			; IF LBS SUCCESS CODE
	CMPZV	#STS$V_SEVERITY,#STS$S_SEVERITY,- ; SEVERE ERROR OR GREATER?
		R0,#STS$K_SEVERE 	;
	BGEQ	50$			; IF GEQ YES
40$:	MOVZWL	#SS$_CONTINUE,R0	; SET CONTINUATION CODE
	RET				;

50$:	BLBC	4(SP),60$		; IF LBC NOT EXCEPTION
	TSTB	@#CTL$GB_SSFILTER	; SYSTEM SERVICES INHIBITED NOW?
	BNEQ	60$			; YES, DON'T TRY TO PRINT ANYTHING
	PUSHL	R0			; SAVE EXCEPTION NAME
	PUSHAB	(AP)			; SET ADDRESS OF SIGNAL ARGUMENTS
	PUSHAB	SUFFIX			; SET ADDRESS OF MESSAGE SUFFIX
	CALLS	#2,EXE$EXCMSG		; OUTPUT EXCEPTION SUMMARY
	POPL	R0			; RESTORE EXCEPTION NAME
60$:	BBSS	#STS$V_INHIB_MSG,R0,70$	; SET INHIBIT MESSAGE BIT
70$:	BRW	EXE$EXIT_IMAGE		;
	.PAGE
	.SBTTL	EXECUTIVE MODE EXIT HANDLER
;+
; EXE$RMSEXH - EXECUTIVE MODE EXIT HANDLER
;
; THIS ROUTINE IS CALLED AS THE RESULT OF AN ATTEMPTED EXIT FROM EXECUTIVE MODE.
; ITS FUNCTION IS TO RUN DOWN ALL RMS FILES.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	RMS FILES ARE RUN DOWN.
;-
 
	.ENTRY	EXE$RMSEXH,^M<>
	MOVAB	-128(SP),SP		; ALLOCATE STRING BUFFER
	PUSHAB	(SP)			; BUILD BUFFER DESCRIPTOR
	PUSHL	#0			;
10$:	MOVZBL	#128,(SP)		; SET LENGTH OF STRING BUFFER
	PUSHL	#0			; RUN DOWN IMAGE AND INDIRECT PROC PERM
	PUSHAB	4(SP)			; PUSH ADDRESS OF BUFFER DESCRIPTOR
	CALLS	#2,@#SYS$RMSRUNDWN	; RUN DOWN THE NEXT FILE
	BLBC	R0,10$			; IF LBC MORE TO GO
	RET				;
	.PAGE
	.SBTTL	CREATELOG - CREATE LOGICAL NAME
;++
; FUNCTIONAL DESCRIPTION:
;	CREATELOG CALLS THE CREATE LOGICAL NAME SYSTEM SERVICE
;	TO CREATE THE LOGICAL NAME EQUIVALENCES GIVEN IN THE QUOTA
;	BUFFER.
;
; CALLING SEQUENCE:
;	BSBW	CREATELOG
;	.BYTE	DESCRIPTOR-DESCBASE
;	.BYTE	PQB$T_<OFFSET>
;
; INPUT PARAMETERS:
;	R6 - ADDRESS OF PROCESS QUOTA BLOCK
;	@(SP) - BYTE OFFSET FROM DESCRIPTOR BASE TO DESCRIPTOR
;	1+@(SP) - PROCESS QUOTA BLOCK OFFSET
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	CREATION OF SPECIFIED LOGICAL NAMES
;
;--

CREATELOG:				; CREATE LOGICAL NAME
	MOVL	(SP),R2			; GET ARGUMENT POINTER
	ADDL	#2,(SP)			; CORRECT RETURN PC VALUE
	MOVZBL	(R2)+,R3		; GET DESCRIPTOR OFFSET
	MOVAB	DESCBASE[R3],R3		; COMPUTE ADDRESS OF DESCRIPTOR
	MOVZBL	(R2),R2			; GET PROCESS QUOTA BLOCK OFFSET
	MOVAL	(R6)[R2],R2		; COMPUTE ADDRESS OF STRING
	MOVZBL	(R2)+,R1		; GET STRING LENGTH
	BEQL	10$			; NULL, IGNORE
	MOVQ	R1,-(SP)		; STACK STRING DESCRIPTOR
	MOVL	SP,R2			; SAVE DESCRIPTOR ADDRESS
	$CRELOG_S	#2,(R3),(R2),#1	; CREATE NAME
	ADDL	#8,SP			; CLEAN STACK OF DESCRIPTOR
10$:	RSB				; AND RETURN



	.END
