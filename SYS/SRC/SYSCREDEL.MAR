	.TITLE	SYSCREDEL - SYSTEM SERVICE CREATE & DELETE PAGE
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, MEMORY MANAGEMENT SERVICES
;
; ABSTRACT:	SYSCREPAG IMPLEMENTS THE SERVICES WHICH CREATE NEW
;	DEMAND ZERO PAGES IN THE VIRTUAL ADDRESS SPACE OF THE CALLER.
;
; ENVIRONMENT:	THESE SERVICES RUN IN KERNEL MODE WITH THE MEMORY
;	MANAGEMENT DATA BASE LOCKED WHEN NECESSARY.
;
;--
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 9-SEP-76
;
; MODIFIED BY:
;
;	V03-001	SOP0001		John Sopka		22-Mar-1982
;		Restore caller's IPL before return from MMG$CRETVA.
;
;	V02-021	WMC0035		Wayne Cardoza		2-Feb-1981
;		Fix incorrect error paths on insufficient working set in CREPAG.
;		Fix problem in global page deletion.
;
;	V02-020	KDM0071		Kathleen D. Morse	2-Dec-1981
;		Remove one reason that process must be locked onto the
;		primary processor, for each PFNMAP page deleted.
;
;	V02-019	SPF0056		Steve Forgey		02-Jan-1981
;		Update image page file peak.
;
;	V02-018	WMC0009		Wayne Cardoza		19-Oct-1981
;		Fix problem with with resource wait after purge working set
;		scan.
;
;	V02-017	WMC0003		Wayne Cardoza		26-AUG-1981
;		Wait for resource if purge working set scan returns an error.
;
;	V02-016	WMC0002		Wayne Cardoza		25-Aug-1981
;		Fix bug in deleting a page file backing store global page.
;
;	V02-015 WMC0001		Wayne Cardoza		12-Aug-1981
;		Changes for page file backing store global sections.
;
;	V02-014	HRJ0023		Herb Jacobs		01-Jul-1981
;		Update to new page file deallocation interface.
;
;	V02-013	LJK0030		Lawrence J. Kenah	27-May-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V02-012	LJK0022		Lawrence J. Kenah	19-May-1981
;		Replace CDL$x_ symbols with MMG$x_ symbols. Add $MMGDEF
;		macro. Make these offsets local symbols.
;
;	V02-011	HRJ0020		Herb Jacobs		27-Apr-1981
;		Change reference to PHD$W_WSSIZE for working set size.
;
;	V02-010	TSC0001		THOMAS S. CLARK		02-JUL-1980
;		FIX BUG IN EXPREG LOGIC THAT CREATES NEW PAGES OVER EXISTING
;		PAGES IF EXPREG IS PASSED A PAGE COUNT GREATER THAN 1@22. ALSO
;		FIX SIMILAR BUG IN CNTREG. BOTH WILL NOW RETURN ILLPAGCNT ERROR.
;

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$IPLDEF				;PROCESSOR PRIORITY LEVELS
	$IRPDEF				;I/O REQUEST PACKET DEFINITIONS
	$JIBDEF				;JOB INFORMATION BLOCK DEFINITIONS
	$MMGDEF				; Offsets from FP into scratch area
	$OPDEF				; Define opcode equivalent values
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINTIONS
	$PFNDEF				;PAGE FRAME NUMBER DATA BASE
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINTIONS
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$RSNDEF				;RESOURCE WAIT NUMBER DEFINIONS
	$SECDEF				;SECTION TABLE DEFINITIONS
	$SSDEF				;SYSTEM STATUS CODE DEFINTIONS
	$VADEF				;VIRTUAL ADDRESS VIELDS
	$WSLDEF				;WORKING SET LIST ENTRY DEFINTIONS
;
; EXTERNAL SYMBOLS:
;
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
; OFFSET FROM AP
;
	INADR		= 4		;OFFSET TO INPUT RANGE
	PAGCNT		= 4		;OFFSET TO PAGE COUNT
	RETADR		= 8		;OFFSET TO RETURN RANGE
	ACMODE		= 12		;ACCESS MODE
	REGION		= 16		;OFFSET TO REGION
;
; OWN STORAGE:
;

	.SBTTL	EXPREG - EXPAND PROGRAM/CONTROL REGION

;++
; FUNCTIONAL DESCRIPTION:
;
;	THE EXPAND REGION SYSTEM SERVICE EXPANDS THE PROGRAM REGION (REGION = 0)
;	OR THE CONTROL REGION (REGION = 1) OF THE PROCESS SPACE BY THE
;	NUMBER OF PAGES SPECIFIED IN THE PAGCNT PARAMETER.  THE NEW PAGES
;	ARE DEMAND ZERO PAGES OWNED BY THE MODE OF THE CALLER WITH
;	READ/WRITE PROTECTION FOR THE CALLING MODE AND ALL MORE PRIVILEGED MODES.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$EXPREG
;
; INPUT PARAMETERS:
;
;	PAGCNT(AP) = NUMBER OF PAGES TO ADD TO THE REGION
;	RETADR(AP) = ADDRESS OF A 2 LONGWORD ARRAY INTO WHICH IS RETURNED
;		THE STARTING AND ENDING VIRTUAL ADDRESSES (INCLUSIVE)
;		OF THE PAGES JUST CREATED
;	ACMODE(AP) = THE ACCESS MODE (MAXIMIZED WITH THE CALLERS MODE
;		USED AS THE OWNER OF THE NEW PAGE(S)
;	REGION(AP) = THE INDICATOR FOR WHICH REGION TO EXPAND
;		0 = PROGRAM REGION
;		1 = CONTROL REGION
;
; IMPLICIT INPUTS:
;
;	CURRENT PCB LOCATED VIA SCH$GL_CURPCB
;	PROCESS HEADER AS SPECIFIED IN PCB$L_PHD OF THE PCB
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_ACCVIO			;RETURN ADDRESS RANGE INACCESSIBLE
;	SS$_VASFULL			;VIRTUAL ADDRESS SPACE FULL
;	SS$_ILLPAGCNT			;ILLEGAL PAGE COUNT PARAMETER
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;

	.ENABL	LSB

5$:	MOVZWL	#SS$_ILLPAGCNT,R0	;ILLEGAL PAGE COUNT PARAM
	RET

	.ENTRY	EXE$EXPREG,^M<R2,R3,R4,R5,R6,R7,R8>

	SUBL	#-MMG$C_LENGTH,SP	;RESERVE SCRATCH AREA
	BSBW	MMG$RETADRINI		;INIT RETURN RANGE AND SCRATCH AREA
	BSBB	MMG$CREPAGINI		;INIT FOR CREATING DZRO PAGES
	SUBL3	#1,PAGCNT(AP),R1	;R1=# PAGES TO BE ALLOCATED - 1
	BITL	#^C<VA$M_VPG & -	;PAGE COUNT TOO LARGE?
	^C<VA$M_P1 ! VA$M_SYSTEM>>@-9,R1;(HIGH 11 BITS NOT CLEAR?)
	BNEQ	5$			;BRANCH FOR ERROR IF NOT CLEAR
	ASHL	#9,R1,R1		;EXPRESS AS BYTES
;
; ***** LOCK THE PROCESS HEADER HERE
;
	SETIPL	#IPL$_ASTDEL		;NO AST'S WHILE MODIFYING PHD
	MOVL	@#CTL$GL_PHD,R5		;R5=PHD ADR
	BLBS	REGION(AP),10$		;BRANCH IF P1 SPACE
	MOVL	PHD$L_FREP0VA(R5),R2	;STARTVA=1ST FREE P0 SPACE PAGE
	ADDL3	R1,R2,R3		;R3=ENDVA (INCLUSIVE)
	BRB	15$			;TO THE COMMON CREATE CODE
10$:	MOVL	PHD$L_FREP1VA(R5),R2	;STARVA=1ST FREE P1 SPACE PAGE
	SUBL3	R1,R2,R3		;R3=ENDVA (INCLUSIVE)
15$:
	BSBW	MMG$CRECOM2		;TO THE COMMON CREATE CODE
	RET

	.DSABL	LSB

	.SBTTL	CREPAGINI - INITIALIZE FOR CREATING DEMAND ZERO PAGES

;
; INPUTS:
;
;	MMG$L_MAXACMODE(FP) CONTAINS THE MAXIMIZED ACCESS MODE
;
; OUTPUTS:
;
;	R6 = ADDRESS OF CREPAG SUBROUTINE TO BE CALLED
;	R8 = DEMAND ZERO PAGE TABLE ENTRY FOR SPECIFIED ACCESS MODE
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$CREPAGINI:
	MOVAL	W^MMG$CREPAG,R6		;ADR OF INITITAL DELETE SCANNER FOR CREATE
	MOVZBL	MMG$L_MAXACMODE(FP),R8	;ACCESS MODE OF WRITER/OWNER
	BBSS	#MMG$V_CHGPAGFIL,MMG$L_MAXACMODE(FP),10$ ;CHARGE PAGE FILE QUOTA
10$:	MOVZBL	B^MMG$AB_DZRO[R8],R8	;PROTECTION AND OWNER FIELDS
	ASHL	#PTE$V_OWN,R8,R8	;SHIFT INTO POSITION
	RSB

MMG$AB_DZRO:
	.BYTE	<PTE$C_KW ! PTE$C_KOWN>@-PTE$V_OWN ;KERNEL
	.BYTE	<PTE$C_EW ! PTE$C_EOWN>@-PTE$V_OWN ;EXEC
	.BYTE	<PTE$C_SW ! PTE$C_SOWN>@-PTE$V_OWN ;SUPER
	.BYTE	<PTE$C_UW ! PTE$C_UOWN>@-PTE$V_OWN ;USER

	.SBTTL	CRETVA - CREATE PAGES AT SPECIFIED VIRTUAL ADDRES

;++
; FUNCTIONAL DESCRIPTION:
;	THE CREATE VIRTUAL ADDRESS SPACE SYSTEM SERVICE CREATES NEW DEMAND
;	ZERO PAGES IN THE SPECIFIED RANGE OF VIRTUAL ADDRESSES.
;	IF ANY PAGES ALREADY EXIST IN THE RANGE, THEY ARE DELETED
;	THE NEW PAGES ARE READ/WRITE TO THE CALLING MODE AND ALL MORE
;	PRIVILEGED MODES.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$CRETVA
;	CALLG	ARGLIST,MMG$CRETVA	;PRIVILEGED, NON VECTORED ENTRY POINT
;					;ACCEPTS DESIRED PAGE PROTECTION IN ACMODE+1
;					;PRESERVES IPL IF LEQ ASTDEL
;
;
; INPUT PARAMETERS:
;
;	INADR(AP) = ADDRESS OF 2 LONG WORDS THE 1ST OF WHICH SPECIFIES
;		THE STARTING VIRTUAL ADDRESS TO CREATE, THE 2ND SPECIFIES
;		THE ENDING VIRTUAL ADDRESS TO CREATE (INCLUSIVE).
;	RETADR(AP) = ADDRESS OF A 2 LONGWORD ARRAY INTO WHICH IS RETURNED
;		THE STARTING AND ENDING VIRTUAL ADDRESSES (INCLUSIVE)
;		OF THE PAGES JUST CREATED
;	ACMODE(AP) = THE ACCESS MODE (MAXIMIZED WITH CALLING MODE)
;		USED AS THE OWNER OF THE NEW PAGE(S)
;	ACMODE+1(AP) = THE PROTECTION TO USE FOR THE NEW PAGE WHEN
;		CALLED AT THE PRIVILEGED MMG$CRETVA ENTRY POINT
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_ACCVIO			;ACCESS VIOLATION
;	SS$_NOPRIV			;NO PRIVILEGE TO CREATE/DELETE PAGE
;	SS$_VASFULL			;VIRTUAL ADDRESS SPACE FULL
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;

	.ENABL	LSB

MMG$CRETVA::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8>
	MOVZBL	ACMODE+1(AP),R7		;PICK UP DESIRED PAGE PROTECTION IF SPECIFIED
	BRB	10$

	.ENTRY	EXE$CRETVA,^M<R2,R3,R4,R5,R6,R7,R8>

	CLRL	R7			;NO PAGE PROTECTION SPECIFIED
10$:	SUBL	#-MMG$C_LENGTH,SP	;RESERVE SCRATCH AREA
	BSBB	MMG$INADRINI		;GET INPUT RANGE TO R4, R5
					;INIT RETURN RANGE AND SCRATCH AREA
	BSBB	MMG$CREPAGINI		;INIT FOR CREATING DZRO PAGES
	TSTL	R7			;PAGE PROTECTION SPECIFIED?
	BEQL	20$			;BRANCH IF NOT
	INSV	R7,#PTE$V_PROT,#PTE$S_PROT,R8 ;SET DESIRED PAGE PROTECTION
20$:	BSBB	CRECOM3			;INVOKE COMMON PROCESSING LOOP
	ENBINT	MMG$L_CALLEDIPL(FP)	;RESTORE IPL AT CALL
	RET

	.DSABL	LSB
;
; R6 = SUBROUTINE ADDRESS OF CREPAG OR SETPRTPAG
; IF THIS IS THE SET PROTECTION SERVICE, R8 = NEW PROTECTION
; ENTERED VIA BSBB MMG$CRECOM1
;
MMG$CRECOM1::
	BSBB	MMG$INADRINI		;GET INPUT RANGE TO R4, R5
					;INIT RETURN RANGE AND SCRATCH AREA
CRECOM3:
	MOVQ	R4,R2			;R2 = START OF RANGE, R3 = END
;
; OPERATE ON PAGES STARTING WITH THE ADDRESS IN R2 ENDING WITH THE
; ADDRESS IN R3 INCLUSIVE.
;
;
; ***** LOCK THE PROCESS HEADER HERE
;
	SETIPL	#IPL$_ASTDEL		;NO AST'S WHILE MODIFYING PHD
;
; R2 = STARTING VA, R3 = ENDING VA
; R6 = SUBROUTINE TO CALL, R8 = PROTECTION
; ALTERNATE ENTRY POINT ENTERED VIA BSBB MMG$CRECOM2
;
MMG$CRECOM2::
	BSBW	MMG$CREDEL		;COMMON CREATE/DELETE LOOP
	BSBB	MMG$RETRANGE		;RETURN RANGE OPERATED ON
	RSB				;AND RETURN

	.SBTTL	CNTREG - CONTRACT PROGRAM/CONTROL REGION
;++
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$CNTREG
;
;
; INPUT PARAMETERS:
;
;	PAGCNT(AP)	=	NUMBER OF PAGES TO DELETE
;	RETADR(AP)	=	RETURN ADDRES RANGE OF PAGES DELETED
;	ACMODE(AP)	=	ACCESS MODE TO CHECK AGAINST PAGE OWNER
;	REGION(AP)	=	0 FOR PROGRAM REGION
;			=	1 FOR CONTROL REGION
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_ACCVIO			;ACCESS VIOLATION
;	SS$_ILLPAGCNT			;ILLEGAL PAGE COUNT
;	SS$_PAGOWNVIO			;PAGE OWNER VIOLATION
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
	.ENTRY	EXE$CNTREG,^M<R2,R3,R4,R5,R6,R7>

	SUBL	#-MMG$C_LENGTH,SP	;RESERVE SCRATCH AREA
	BSBB	MMG$RETADRINI		;INIT RETURN RANGE AND SCRATCH AREA
	SUBL3	#1,PAGCNT(AP),R1	;R1=DESIRED PAGE COUNT - 1
	BITL	#^C<VA$M_VPG & -	;PAGE COUNT TOO LARGE
	^C<VA$M_P1 ! VA$M_SYSTEM>>@-9,R1;(HIGH 11 BITS NOT CLEAR?)
	BNEQ	20$			;BRANCH FOR ERROR IF NOT CLEAR
	ASHL	#9,R1,R1		;FORM BYTE COUNT
;
; ***** LOCK THE PROCESS HEADER HERE
;
	SETIPL	#IPL$_ASTDEL		;NO AST'S WHILE MODIFYING THE PHD
	MOVL	@#CTL$GL_PHD,R5		;R5=PROCESS HEADER
	BLBS	REGION(AP),10$		;BRANCH IF CONTROL REGION
;
; FORM R2 = THE FIRST ADDRESS TO DELETE, AND R3 = THE LAST ADDRESS
; DELETE STARTING FROM THE END OF THE REGION
;
	SUBL3	#^X200,PHD$L_FREP0VA(R5),R2 ;LAST ADR IN P0 SPACE
	SUBL3	R1,R2,R3		;END OF RANGE TO DELETE
	BRB	15$			;TO THE COMMON DELETE CODE
10$:	ADDL3	#^X200,PHD$L_FREP1VA(R5),R2 ;END OF P1 SPACE
	ADDL3	R1,R2,R3		;END OF RANGE TO DELETE
15$:	BRW	DELCOM			;TO THE COMMON DELETE CODE
20$:	MOVZWL	#SS$_ILLPAGCNT,R0	;ILLEGAL PAGE COUNT
	RET

	.SBTTL INADRINI, RETADRINI - INIT SCRATCH AREA AND RANGES
;++
; FUNCTIONAL DESCRIPTION:
;
;	GET THE INPUT RANGE, INITIALIZE THE RETURN RANGE, AND INITIALIZE
; THE SCRATCH AREA WHICH IS ASSUMED TO ALREADY BE RESERVED ON THE STACK.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$INADRINI		;GET INPUT RANGE AND FALL INTO RETADRINI
;	BSBW	MMG$RETADRINI		;INIT RETURN RANGE AND SCRATCH AREA
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	MMG$C_LENGTH BYTES RESERVED ON TOP OF STACK AND ADDRESSED  BY FP
;
; OUTPUT PARAMETERS:
;
;	R4, R5 CONTAIN THE INPUT RANGE IF ENTERED AT INADRINI
;	RSB TO CALLER IF SUCCESSFUL, RET WITH STATUS IN R0 IF ERROR
;	MMG$L_MAXACMODE(FP)	=	MAXIMIZED ACCESS MODE
;	MMG$L_CALLEDIPL(FP)	=	CALLERS IPL
;	MMG$L_SAVRETADR(FP)	=	RETURN ADDRESS SPECIFIED BY USER
;	USER SPECIFIED RETURN RANGE INITIALIZED TO -1,-1
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_ACCVIO			;ACCESS VIOLATION
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$INADRINI::
	MOVL	INADR(AP),R4		;GET ADDRESS OF INPUT RANGE
	BEQL	ACCVIO			;ERROR IF NO ADDRESS RANGE SPECIFIED
	IFNORD	#8,(R4),ACCVIO		;BRANCH IF RANGE IS INACCESSIBLE
	MOVQ	(R4),R4			;GET THE INPUT RANGE
MMG$RETADRINI::
	EXTZV	#0,#2,ACMODE(AP),R0	;GET CALLER SPECIFIED ACCESS MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE WITH PREVIOUS
	MOVL	R0,MMG$L_MAXACMODE(FP)	;AND SAVE RESULT IN THE SCRATCH AREA
	SAVIPL	MMG$L_CALLEDIPL(FP)	;STORE CALLER'S IPL
	MOVL	RETADR(AP),MMG$L_SAVRETADR(FP) ;GET THE RETURN ADDRESS
	MNEGL	#1,R1			;INIT THE RANGE TO -1, -1
	MOVL	R1,R2
;
; FALL THROUGH TO MMG$RETRANGE
;

	.SBTTL	RETRANGE - RETURN RANGE OF PAGES
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE RETURNS THE RANGE OF PAGES OPERATED ON TO THE
; USER SPECIFIED ADDRESS.  A ZERO ADDRESS INDICATES NO RETURN RANGE
; AND THE ADDRESS IS PROBED FOR WRITING 8 BYTES.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$RETRANGE
;
; INPUT PARAMETERS:
;
;	R1, R2 = RANGE OF ADDRESSES TO BE RETURNED
;
; IMPLICIT INPUTS:
;
;	MMG$L_SAVRETADR(FP) = THE USER SPECIFIED RETURN ADDRESS
;
; OUTPUT PARAMETERS:
;
;	RETURNS VIA RSB IF NO ERROR
;	RETURNS VIA RET WITH ERROR CODE IN R0 IF ACCESS VIOLATION
;	R0 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_ACCVIO			ACCESS VIOLATION IF CAN'T WRITE RANGE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$RETRANGE:
	MOVL	MMG$L_SAVRETADR(FP),R3	;USER SPECIFIED RETURN ADR
	BEQL	20$			;BRANCH IF NONE SPECIFIED
	IFNOWRT	#8,(R3),ACCVIO		;BRANCH IF NOT WRITABLE
	MOVQ	R1,(R3)			;RETURN THE RANGE
20$:
	RSB
;
; ACCESS VIOLATION
;
ACCVIO:
	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION CODE
	RET				;AND RETURN IT

	.SBTTL	DELTVA - DELETE VIRTUAL ADDRESS SPACE PAGES
;++
; FUNCTIONAL DESCRIPTION:
;
;	DELTVA DELETES PAGES STARTING WITH THE SECOND ADDRESS FROM INADR
;	ENDING WITH THE FIRST ADR IN INADR. THE SPECIFIED ACCESS MODE
;	(MAXIMIZED WITH THE CALLER'S MODE) IS CHECKED AGAINST THE
;	OWNER OF EACH PAGE AND MUST BE AT LEAST AS PRIVILEGED. 
;	EACH PAGE IS MADE INACCESSIBLE.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$DELTVA
;
;
; INPUT PARAMETERS:
;
;	INADR(AP)	=	INPUT RANGE OF ADDRESSES
;	RETADR(AP)	=	RETURN RANGE OF ADDRESSES
;	ACMODE(AP)	=	ACCESS MODE TO USE FOR CHECK OF DELETE PRIV
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_ACCVIO			;ACCESS VIOLATION
;	SS$_PAGOWNVIO			;PAGE OWNER VIOLATION
;	SS$_NOPRIV			;NO PRIVILEGE, TRIED TO DELETE SYS PAGE
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
	.ENTRY	EXE$DELTVA,^M<R2,R3,R4,R5,R6,R7>

	SUBL	#-MMG$C_LENGTH,SP	;RESERVE SCRATCH AREA
	BSBB	MMG$INADRINI		;GET INPUT RANGE TO R4, R5
					;INIT RETURN RANGE AND SCRATCH AREA
	MOVL	R5,R2			;DELETE FROM THE 2ND ADDRESS
	MOVL	R4,R3			;THROUGH THE FIRST
;
; ***** LOCK THE PROCESS HEADER HERE
;
	SETIPL	#IPL$_ASTDEL		;NO AST'S WHILE MODIFYING THE PHD
	MOVL	@#CTL$GL_PHD,R5		;ADDRESS OF PROCESS HEADER
	BBS	#VA$V_P1,R2,10$		;BRANCH IF P1 SPACE ADDRESS
;
; P0 SPACE ADDRESS
;
	CMPL	R2,PHD$L_FREP0VA(R5)	;FIRST ADDRESS WITHIN REGION
	BLSSU	20$			;BRANCH IF YES
	CMPL	R3,PHD$L_FREP0VA(R5)	;IF SECOND ADDRESS IS ALSO BEYOND END
	BGEQU	20$			;THEN FORGET ADJUSTING THE RANGE
	SUBL3	#1,PHD$L_FREP0VA(R5),R2	;START WITH FIRST EXISTING PAGE
	BRB	20$
;
; P1 SPACE ADDRESS
;
10$:	ADDL3	#^X1FF,PHD$L_FREP1VA(R5),R0 ;FIRST BYTE ADR NOT IN P1 SPACE
	CMPL	R0,R2			;FIRST ADDRESS WITHIN REGION
	BLSSU	20$			;BRANCH IF YES
	CMPL	R0,R3			;IF SECOND ADDRESS IS ALSO BEYOND END
	BGEQU	20$			;THEN FORGET ADJUSTING THE RANGE
	ADDL3	#1,R0,R2		;START WITH FIRST PAGE IN REGION
20$:
;
; 0(SP) = SAVED CALLER'S IPL, R2 = STARTING VA, R3 = ENDING VA
; R6 = SUBROUTINE TO CALL
;
DELCOM:
	MOVAL	L^MMG$DELPAG,R6		;R6 = ADR OF INITIAL DELETE SCANNER
					;CALLED TO SCAN WORKING SET LIST
	SUBL3	R2,R3,-(SP)		;SAVE WHETHER STARTVA = ENDVA
	BSBB	MMG$CREDEL		;DO THE DELETION
	TSTL	(SP)+			;IF STARTVA WAS = ENDVA
	BEQL	10$			;SKIP THE RETURN RANGE EXCHANGE
	MOVQ	R1,R2			;EXCHANGE R1 AND R2
	MOVL	R3,R1			;VIA R3
10$:
	ENBINT	MMG$L_CALLEDIPL(FP)	;RESTORE CALLER'S IPL
	BSBB	MMG$RETRANGE		;RETURN THE RANGE DELETED
	RET				;AND EXIT

	.SBTTL	CREDEL - CREATE/DELETE COMMON LOOP
;
; INPUTS
;	R2 = FIRST ADDRESS TO CREATE/DELETE/SET PROTECTION
;	R3 = LAST ADDRESS TO CREATE/DELETE/SET PROTECTION
;	R6 = SUBROUTINE TO CALL
;		CREPAG, DELPAG, SETPRTPAG, LKWSETPAG, ULWSETPAG
;	R7 = SAVED AND READY TO USE AS LOOP INCREMENT
;	R8 = NEW PAGE PROTECTION IF THIS IS SETPRT
;	MMG$L_MAXACMODE(FP) = MAXIMIZED ACCESS MODE
;
; OUTPUTS:
;	R0 = COMPLETION CODE
;	R1 = FIRST ADDRESS CREATED/DELETED
;	R2 = LAST ADDRESS CREATED/DELETED
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS IN P1 SPACE
;	R6,R7 ALTERED
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$CREDEL:
	MOVL	R6,MMG$L_PAGESUBR(FP)	;ADDRESS OF PER/PAGE SUBROUTINE
	ASHL	#9,#1,R7		;ADDRESS INCREMENT IF GOING FORWARDS
	ASHL	#-9,R3,R6		;HIGH VIRTUAL PAGE NUMBER
	BLSS	55$			;BRANCH IF SYSTEM SPACE
	ASHL	#-9,R2,R0		;LOW VIRTUAL PAGE NUMBER
	BLSS	55$			;BRANCH IF SYSTEM SPACE
	SUBL	R0,R6			;NUMBER OF PAGES BASE 0
;
; THE FOLLOWING COMPARE MUST BE DONE WITH R2, R3 EXACTLY AS THEY
; CAME FROM THE CALLER SO THAT A RANGE OF 205,204 WILL YIELD A RETURN
; RANGE OF 3FF,200 INSTEAD OF 200,3FF.
;
	CMPL	R2,R3			;GOING FORWARDS IN THE ADDRESS SPACE?
	BLSSU	10$			;BRANCH IF YES
	BGTRU	5$			;BRANCH IF BACKWARDS
	BBC	#VA$V_P1,R2,10$		;IF EQUAL, THEN FORWARD FOR P0
					;BACKWARDS FOR P1
5$:	MNEGL	R6,R6			;NO, BACKWARDS, MAKE PAGE COUNT POSITIVE
	MNEGL	R7,R7			;ADDRESS INCREMENT = -^X200
10$:	ASHL	#9,R0,R2		;NORMALIZED STARTING VA
	MOVL	R2,MMG$L_SVSTARTVA(FP)	;SAVE STARTING VA
	MOVL	L^SCH$GL_CURPCB,R4	;PROCESS CONTROL BLOCK ADDRESS
	MOVL	@#CTL$GL_PHD,R5		;PROCESS HEADER ADDRESS
30$:	MOVL	MMG$L_MAXACMODE(FP),R0	;ACCESS MODE
;
; EACH OF THE PER PAGE SUBROUTINES IS CALLED WITH THE FOLLOWING REGISTERS
;	R0 = ACCESS MODE
;	R2 = VIRTUAL ADDRESS OF PAGE TO OPERATE ON (LOW 9 BITS CLEAR)
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE)
;	R6 = NUMBER OF PAGES - 1 LEFT TO PROCESS (INCLUDING THE ONE IN R2)
;	R7 = +^X200 IF GOING FORWARD IN ADDRESS SPACE
;	   = -^X200 IF GOING BACKWARDS IN ADDRESS SPACE
;
; ALL ROUTINES ARE EXPECTED TO PRESERVE R2, R4, R5, R6, R7, BUT IT IS
; OK FOR A ROUTINE TO DO MORE THAN ONE PAGE BY ADDING R7 TO R2 FOR EACH
; AND DECREMENTING R6.
;
	JSB	@MMG$L_PAGESUBR(FP)	;CALL THE PER-PAGE ROUTINE
	BLBC	R0,40$			;BRANCH IF ERROR CONDITION
	ADDL	R7,R2			;NEXT VIRTUAL ADDRESS
	SOBGEQ	R6,30$			;LOOP THROUGH THE PAGES
40$:	MOVL	MMG$L_SVSTARTVA(FP),R1	;RECOVER STARTING VIRTUAL ADDRESS
	CMPL	R1,R2			;ANY PAGES SUCCESSFULLY PROCESSED?
	BEQL	60$			;BRANCH IF NO
	SUBL	R7,R2			;BACK TO LAST PAGE PROCESSED
	BBS	#31,R7,45$		;BRANCH IF GOING BACKWARDS
	BISW	#^X1FF,R2		;ENDVA IS END OF PAGE
	RSB
45$:	BISW	#^X1FF,R1		;ENDVA IS END OF PAGE
	RSB
55$:	MOVZWL	#SS$_NOPRIV,R0		;NO PRIVILEGE
60$:	CLRL	MMG$L_SAVRETADR(FP)	;NULL RETURN ADR FOR NULL RANGE
	RSB

	.SBTTL	CREPAG - CREATE A SINGLE PAGE

;++
; FUNCTIONAL DESCRIPTION:
;	CREPAG CREATES ONE PAGE IN THE P0 OR P1 PAGE TABLE.  IF NECESSARY
; THE PAGE TABLE IS EXTENDED, WHICH CAN FAIL WHEN THERE ARE NO PTE'S 
; AVAILABLE.  THE PTE IS DELETED IF NECESSARY AND IS THEN SET
; TO THE VALUE SPECIFIED.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$CREPAG
;
; INPUT PARAMETERS:
;
;	R0 = MODE FOR CREATING NEW PAGE IN LOW BYTE
;	     MMG$V_CHGPAGFIL SET IF CHARGING PAGE FILE QUOTA FOR THIS PAGE
;	R2 = VIRTUAL ADDRESS OF PAGE TO CREATE (LOW 9 BITS = 0)
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS - P1 OR SYSTEM SPACE
;	R6 = COUNT - 1 OF PAGES REMAINING TO PROCESS INCLUDING THIS ONE
;	R7 = +^X200 IF GOING FORWARDS, -^X200 IF GOING BACKWARDS
;	R8 = NEW CONTENTS OF PAGE TABLE ENTRY
;
;	THE CURRENT IPL MUST BE AT ASTDEL
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = ERROR STATUS CODE
;	R2 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	PTE CORRESPONDING TO SPECIFIED VIRTUAL ADDRESS IS DELETED AND
;	THE DESIRED PTE IS STORED
;
;	IF PAGE TABLE EXPANSION IS NECESSARY THEN THE FOLLOWING 
;	ARE AFFECTED:
;
;	PHD$L_FREP0VA OR PHD$L_FREP1VA	;1ST FREE PAGE AT END OF P0/P1 PAGE TABLE
;	PHD$L_P0LRASTL OR PHD$L_P1LR	;LENGTH OF PT IN HARDWARE PCB
;	PR$_P0LR OR PR$_P1LR		;LENGTH OF PT IN PROCESSOR REG
;	PHD$L_FREPTECNT			;FREE PTE COUNTER
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_VASFULL			;VIRTUAL ADDRESS SPACE FULL
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
	.ENABL	LSB

;
; PAGE TABLE ENTRY IS NOT EMPTY, MUST DELETE THE PAGE FIRST
;
DELETEFIRST:
	MOVZBL	4(SP),R0		;ACCESS MODE
	JSB	MMG$DELPAG		;DELETE THE PAGE
	BLBC	R0,35$			;BRANCH IF ERROR
	POPR	#^M<R0,R1>		;R1 = ACCESS MODE
	MOVL	R1,R0			;PLACE IT IN R0
;
; FALL THROUGH TO CREPAG
;
MMG$CREPAG::
	PUSHL	R0			;SAVE ACCESS MODE
	BBC	#VA$V_P1,R2,20$		;BRANCH IF P0 SPACE
;
; P1 SPACE
;
	MOVAL	PHD$L_P1BR(R5),R3	;ADR OF POINTER TO P1PT
	SUBL3	R2,PHD$L_FREP1VA(R5),-(SP) ;BEYOND END OF REGION?
	BLSS	80$			;BRANCH IF NOT
;
; 0(SP) = NO. OF BYTES BEYOND P1VA (INTEGRAL NO. OF PAGES)
;	NOTE THAT THIS IS ^X200 SHORT OF WHAT MUST BE ADDED TO REGION
;
	MULL3	R7,R6,R1		;NO. OF BYTES LEFT TO PROCESS
					;+ IF GOING FORWARDS, - IF GOING BACKWARDS
	BGEQ	40$			;BRANCH IF EXPANSION IS NOT IN THE
					;NATURAL GROWTH DIRECTION OF THE REGION
	MNEGL	R1,R1			;NO. OF BYTES TO ADD TO SIZE OF REGION
	BRB	30$			;TRY TO EXPAND TO FIT LAST PAGE
;
; P0 SPACE
;
20$:	MOVAL	PHD$L_P0BR(R5),R3	;ADR OF POINTER TO P0PT
	SUBL3	PHD$L_FREP0VA(R5),R2,-(SP) ;BEYOND END OF REGION?
	BLSS	80$			;BRANCH IF NOT
;
; 0(SP) = NO. OF BYTES BEYOND P0VA (INTEGRAL NO. OF PAGES)
;	NOTE THAT THIS IS ^X200 SHORT OF WHAT MUST BE ADDED TO REGION
;
	MULL3	R7,R6,R1		;NO. OF BYTE LEFT TO BE CREATED
					;+ IF GOING FORWARD, - IF GOING BACKWARDS
	BLEQ	40$			;BRANCH IF NOT FORWARD
;
; TRY EXPANDING REGION TO FIT LAST PAGE TO BE CREATED
; CREATION IS IN THE DIRECTION OF THE EXPANDING REGION
;
30$:	ADDL	(SP),R1			;AMOUNT EVENTUALLY NEEDED TO EXPAND BY
	MOVAL	^X200(R1),R1		;
	BSBW	EXPANDCHK		;TRY EXPANDING BY THAT MUCH
	BLBS	R0,80$			;BRANCH IF REGION EXPANDED
	CMPW	R0,#SS$_VASFULL
	BNEQ	40$			;NOT VIRTUAL ADDRESS SPACE FULL

;
; CAN'T EXPAND REGION BY THE FULL AMOUNT THAT WILL BE NEEDED
; SO EXPAND BY WHAT IS LEFT UNLESS THAT'S NOT ENOUGH FOR THE CURRENT PAGE
;
	ROTL	#9,PHD$L_FREPTECNT(R5),R1 ;SPACE LEFT FOR EXPANDING
	CMPL	R1,(SP)			;EXPAND BY SPACE REMAINING UNLESS
					;MORE IS NEEDED FOR THIS PAGE
	BGTR	50$			;BRANCH IF THERE'S ENOUGH
35$:	BRB	90$			;OTHERWISE VIRTUAL ADR SPACE FULL
;
; JUST EXPAND FOR THIS PAGE
;
40$:	ADDL3	#^X200,(SP),R1		;AMOUNT NEEDED FOR THIS PAGE
50$:	BSBB	EXPANDCHK		;TRY EXPANDING BY THIS AMOUNT
	BLBC	R0,90$			;BRANCH IF NO ROOM
;
; 0(SP) = GARBAGE, 4(SP) = ACCESS MODE, 5(SP) NONZERO IF CHARGING PAGE FILE QUOTA
; R2 = VA, R3 = ADDRESS OF POINTER TO APPROPRIATE PAGE TABLE
;
80$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R1 ;VIRTUAL PAGE NUMBER
	TSTL	@(R3)[R1]		;PTE EMPTY?
	BNEQ	DELETEFIRST		;BRANCH IF NO, MUST DELETE IT
	BBC	#MMG$V_CHGPAGFIL,4(SP),85$ ;BRANCH IF NOT CHARGING FOR PAGE FILE
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	DECL	JIB$L_PGFLCNT(R0)	;CHARGE A PAGE FILE PAGE
	BLSS	100$			;BRANCH IF OVER QUOTA
	SUBL3	JIB$L_PGFLCNT(R0),JIB$L_PGFLQUOTA(R0),R0 ;PAGE FILE PAGES IN USE
	CMPL	R0,G^CTL$GL_VIRTPEAK	;MAINTAIN MAX PAGE FILE USED
	BLSSU	82$
	MOVL	R0,G^CTL$GL_VIRTPEAK	;SET NEW PEAK VALUE
	MOVL	R0,G^CTL$GL_IPAGEFL	;SET NEW PEAK VALUE
	BRB	85$
82$:	CMPL	R0,G^CTL$GL_IPAGEFL	;MAINTAIN MAX PAGE FILE USED (IMAGE)
	BLSSU	85$
	MOVL	R0,G^CTL$GL_IPAGEFL	;SET NEW PEAK VALUE
85$:	MOVL	R8,@(R3)[R1]		;STORE NEW PTE
	MOVZWL	#SS$_NORMAL,R0		;INDICATE SUCCESSFUL COMPLETION
90$:	ADDL	#2*4,SP			;CLEAN OFF STACK
	RSB
;
; EXCEEDED PAGE FILE QUOTA
;
100$:	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	INCL	JIB$L_PGFLCNT(R0)	;RESTORE CORRECT COUNT
	MOVZWL	#SS$_EXQUOTA,R0		;EXCEEDED QUOTA
	BRB	90$			;RETURN THE ERROR

	.DSABL	LSB

	.SBTTL	EXPANDCHK - EXPAND REGION CHECKING FOR SPACE AVAILABLE

;
; INPUTS:
;
;	R1 = NO. OF BYTES TO EXPAND BY (INTEGRAL NO. OF PAGES)
;	R2 = VIRTUAL ADDRESS (PROVIDING THE P0/P1 SPACE INDICATOR)
;	R5 = PROCESS HEADER ADDRESS
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;		SS$_NORMAL FOR SUCCESSFUL
;		SS$_VASFULL FOR VIRTUAL ADDRESS SPACE FULL
;		SS$_INSFWSL FOR INSUFFICIENT WORKING SET LIMIT
;	R2, R3 PRESERVED
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
EXPANDCHK:
	ASHL	#-9,R1,R0		;NUMBER OF PAGES REQUIRED
	SUBL	R0,PHD$L_FREPTECNT(R5)	;ENOUGH FREE PAGE TABLE ENTRIES
	BLSS	40$			;BRANCH IF NOT
	BBS	#VA$V_P1,R2,20$		;BRANCH IF P1 SPACE ADDRESS
;
; P0 SPACE ADDRESS
;
	ADDL	R0,PHD$L_P0LRASTL(R5)	;ADJUST LENGTH OF REGION
	ADDL	R1,PHD$L_FREP0VA(R5)	;AND NEXT FREE P0 VIRTUAL ADDRESS
	LDP0LR	PHD$L_P0LRASTL(R5)	;ADJUST HARDWARE LENGTH REGISTER
	BRB	30$			;EXIT THROUGH COMMON CODE
;
; P1 SPACE ADDRESS
;
20$:	SUBL	R0,PHD$L_P1LR(R5)	;ADJUST LENGTH OF REGION
	SUBL	R1,PHD$L_FREP1VA(R5)	;AND NEXT FREE P1 VIRTUAL ADR
	LDP1LR	PHD$L_P1LR(R5)		;AND HARDWARE LENGTH REGISTER
30$:	BSBB	UPDATPTCNT		;UPDATE MAX PAGE TABLE COUNT
	TSTW	R1			;IF NOT ENOUGH DYNAMIC WSLE'S LEFT
	BLSS	50$			;THEN TOO MUCH VA SPACE FOR WS LIMIT
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION CODE
	RSB
;
; NOT ENOUGH ROOM IN VIRTUAL ADDRESS SPACE FOR SPECFIED EXPANSION
;
40$:	ADDL	R0,PHD$L_FREPTECNT(R5)	;FIX UP FREE PAGE TABLE ENTRY COUNTER
	MOVZWL	#SS$_VASFULL,R0		;RETURN 'VIRTUAL ADDRESS SPACE FULL'
	RSB
;
; ADDITION OF DESIRED VIRTUAL ADDRESS SPACE WILL RESULT IN TOO FEW
; DYNAMIC PAGES IN THE WORKING SET LIST.  REFUSE TO ADD THE SPACE.
;
50$:	PUSHL	R1			;SAVE VOLIATILE REGISTER
	MOVZWL	PHD$W_WSSIZE(R5),-(SP)	;SAVE CURRENT WSSIZE
	PUSHL	#0			;NO ADDRESS FOR PREVIOUS VALUE
	MOVZBL	#127,-(SP)		;AUGMENT WS BY 127 PAGES
	CALLS	#2,EXE$ADJWSL		;CALL INTERNAL ADJUST WS ROUTINE
	POPR	#^M<R0,R1>		;RESTORE SAVED WSSIZE, R1
	CMPW	PHD$W_WSSIZE(R5),R0	;DID WS GROW AT ALL?
	BNEQ	30$			;YES, GO TRY AGAIN
	PUSHL	R3
	BSBW	MMG$CONTRACT		;GO CLEAN UP
	POPR	#^M<R3>
	MOVZWL	#SS$_INSFWSL,R0		;INSUFFICIENT WORKING SET LIMIT
	RSB

	.SBTTL	UPDATPTCNT - UPDATE (MAX) PAGE TABLE COUNT

; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CALCULATES THE MAXIMUM NUMBER OF PAGE TABLES THAT
; MAY BE REQUIRED TO SUPPORT THE VIRTUAL ADDRESS SPACE CURRENTLY CREATED.
; THE CALCULATION IS BASED SOLELY ON THE CURRENT SETTINGS FOR THE ENDS
; OF P0 AND P1 SPACE, HOLES IN THE ADDRESS SPACE ARE NOT DEALT WITH.
;
; INPUTS:
;
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE IF PROCESS)
;
; OUTPUTS:
;
;	R1 = WORD CONTAINING EXTRA DYNAMIC WORKING SET LIST ENTRY COUNT
;	R2,R3 PRESERVED
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
UPDATPTCNT:
	EXTZV	#0,#7,PHD$L_P0LRASTL(R5),R0 ;NO. OF ENTRIES TO FILL LAST P0PT
	SUBL3	R0,PHD$L_FREPTECNT(R5),R0 ;NO. OF FREE PTE'S STARTING
					;AT THE NEXT PAGE TABLE BOUNDARY
	ASHL	#-7,R0,R0		;TRUNCATED DIVIDE BY 128 YIELDS
					;COUNT OF EMPTY PAGE TABLES
	BGEQ	10$			;BRANCH IF SOME EMPTY PAGE TABLES
	CLRL	R0			;NO EMPTY PAGE TABLES
10$:	SUBW3	R0,SGN$GL_PTPAGCNT,PHD$W_PTCNTMAX(R5) ;SET MAX PAGE TABLE COUNT
	JMP	MMG$EXTRADYNWS		;COMPUTE AND RETURN EXTRA DYNAMIC WSLE COUNT

	.SBTTL	DELPAG - DELETE A SINGLE PAGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DELETES THE PAGE SPECIFIED, CLEARING ITS PAGE TABLE
; ENTRY.  IF THIS IS THE LAST PAGE OF THE RANGE TO BE DELETED OR IF
; IT RESULTS IN A LENGTH VIOLATION, THEN THE CONTRACT REGION LOGIC IS CALLED.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DELPAG
;
;
; INPUT PARAMETERS:
;
;	R0 = ACCESS MODE TO CHECK AGAINST PAGE OWNER
;	     MMG$V_DELGBLDON SET IF ALREADY HAVE DONE A PURGE OF THE GLOBAL
;		PAGES IN THE SPECIFIED ADDRESS RANGE
;	R2 = VIRTUAL ADDRESS (LOW 9 BITS = 0)
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS - P1 OR SYSTEM SPACE
;	R6 = COUNT - 1 OF PAGES REMAINING TO  BE DELETED INCLUDING THIS ONE
;	R7 = +^X200 IF GOING FORWARD IN ADDRESS SPACE
;	   = -^X200 IF GOING BACKWARDS IN ADDRESS SPACE
;	IPL = ASTLVL
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = STATUS CODE
;	R2 PRESERVED
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL RETURN
;	SS$_PAGOWNVIO			;PAGE OWNER VIOLATION
;
; SIDE EFFECTS:
;
;	R1,R3 - DESTROYED
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
;
; DELETE A PAGE MAPPED BY PFN
;
PFNMAPDEL:
	INVALID	R2			;INVALIDATE THE TRANSLATION BUFFER
	CMPW	PCB$W_DIOLM(R4),PCB$W_DIOCNT(R4) ;ANY DIRECT I/O FOR PROCESS?
	BGTRU	IOWAIT			;BR ON YES, GO WAIT FOR I/O TO COMPLETE
	DECL	PHD$L_MPINHIBIT(R5)	;REMOVE ONE REASON THAT PROCESS MUST
					;BE LOCKED ON PRIMARY PROCESSOR
DELPTE1:
	BRW	DELPTE			;OK TO DELETE PAGE
IOWAIT:
	MOVZBL	#RSN$_ASTWAIT,R1	;WAIT FOR AST'S
	BRW	DELPAGRESWAIT		;GO WAIT FOR I/O TO COMPLETE

;
; DELETE PTE TO A SHARED MEMORY GLOBAL SECTION PAGE.
;
SHMPAGDEL:
	CMPW	PCB$W_DIOLM(R4),PCB$W_DIOCNT(R4) ;ANY DIRECT I/O FOR PROCESS?
	BGTRU	IOWAIT			;BR ON YES, GO WAIT FOR I/O TO COMPLETE
	PUSHR	#^M<R1,R4,R6>		;SAVE REGISTERS
	MOVZBL	#1,R1			;COUNT TO DECREMENT PTE REFERENCE BY
	BSBW	MMG$FINDGSDPFN		;FIND SHARED MEMORY GSD FOR THIS PFN
	POPR	#^M<R1,R4,R6>		;RESTORE REGISTERS
;
; AT SOME TIME, A SEND MESSAGE TO THE ERROR LOGGER COULD BE ADDED HERE.
;
	BLBS	R0,DELPTE1		;BR ON GSD FOUND, GO DELETE PTE
	BUG_CHECK NOSHMGSD,FATAL	;FATAL ERROR IF NOT ASSOCIATED WITH GS
;
; PURGE WORKING SET SCAN GOT A RESOURCE ERROR
; 0(SP) = SAVED R8
;
WSSCNWAIT:
	MOVL	R8,R1			;RESOURCE TO WAIT FOR
	MOVL	(SP)+,R8		;RESTORE R8
	MOVPSL	-(SP)			;RESOURCE WAIT ROUTINE NEEDS THIS
	ADDL2	#4,SP			;JUNK WORD
	PUSHL	R0			;ACCESS MODE
	DSBINT #IPL$_SYNCH
	BRW	DELPAGRESWAIT

;
; LENGTH VIOLATION FOR THIS VIRTUAL ADDRESS
;
DELPAGLENVIO:
	CLRL	R6			;OTHERWISE, FAKE RANGE COMPLETED
	BRW	DELPAGLAST		;CONTRACT THE REGION IF POSSIBLE
					;CHECK FOR LAST IN RANGE
BRDELPAGSUCCESS:
	BRW	DELPAGSUCCESS
BRDELPAGRET:
	BRW	DELPAGRET
;
; PAGE LOCKED IN WORKING SET
;
DELPAGLOCKED:
	CMPW	R1,PHD$W_WSLOCK(R5)	;IF PERMANENT PAGE, SUCCESSFUL NOP
	BLSSU	BRDELPAGSUCCESS		;ALLOWING SWAPPER TO USE DELTVA
	MOVZBL	(SP),R0			;RECOVER ACCESS MODE
	ENBINT	4(SP)			;RESTORE IPL TO THAT OF CALLER
	PUSHL	R8			;SAVE R8 AROUND THE FOLLOWING CALL
	MOVL	#<SS$_WASSET @16 !-	;SET PARAMETER TO UNLOCK THE
		WSL$M_WSLOCK ! WSL$M_PFNLOCK>,R8 ;WORKING SET LIST ENTRY
	BSBW	MMG$LCKULKPAG		;UNLOCK THE PAGE FROM THE WORKING SET
	POPR	#^M<R8>			;RESTORE R8
	BLBC	R0,BRDELPAGRET		;BRANCH IF ERROR
	BRW	DELAGAIN		;GO RESTART DELPAG FROM THE TOP

;
; R1 = PAGE TYPE AND IS KNOWN NOT TO BE ZERO
;

DELPAGNOTPROCES:
	ASSUME	PFN$C_SYSTEM EQ 1
	ASSUME	PFN$C_PPGTBL EQ 4	;NEGATIVE FIELD VALUE
	DECL	R1			;IF 1 OR NEGATIVE
	BLEQ	BRDELPAGSUCCESS		;THEN, SUCCESSFUL NOP
					;ALLOWING SWAPPER TO USE DELTVA
DELGBLRDINPROG:
	POPR	#^M<R0,R1,R3>		;R0=ACCESS MODE, R1=SAVED IPL
					;CLEAN OFF SAVED PSL INTO R3
	ENBINT	R1			;BACK TO CALLER'S IPL
	PUSHL	R8			;SAVE THIS REGISTER
	CLRL	R8			;SCANNING FOR GLOBAL PAGES
	BSBW	MMG$PURGWSSCN		;DELETE GLOBAL PAGES IN THE ADDRESS RANGE
					;FROM THE WORKING SET LIST
	TSTL	R8			;CHECK FOR ERROR
	BNEQ	WSSCNWAIT		;GO WAIT FOR A RESOURCE
	MOVL	(SP)+,R8		;RESTORE R8
;
; FALL THROUGH TO DELPAG
;

	.ENABL	LSB

MMG$DELPAG::
	MOVPSL	-(SP)			;SAVE PSL
	SAVIPL				;PUSH CALLER'S IPL
	PUSHL	R0			;SAVE ACCESS MODE
	BSBW	MMG$PTEREF		;REFERENCE PTE, RETURN SVAPTE
					;RETURNS AT IPL=SYNCH
	BLBC	R0,DELPAGLENVIO		;BRANCH IF LENGTH VIOLATION
;
; R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;
	MOVL	(R3),R1			;FETCH PAGE TABLE ENTRY
	BEQL	BRDELPAGSUCCESS		;BRANCH IF ALREADY DELETED
	MOVZBL	(SP),R0			;ACCESS MODE
	BSBW	MMG$PAGETYPE		;CHECK ACCESS, RETURN PAGE TYPE
	BLBC	R0,BRDELPAGRET		;BRANCH IF PAGE OWNER VIOLATION
;
; R1 <0:7> PAGE TYPE TO CASE ON (TYP0*2 + TYP1)
; R2 = VA, R3 = SVAPTE, IPL = SYNCH
; 0(SP) = ACCESS MODE, 4(SP) = SAVED IPL, 8(SP) = SAVED PSL
;
	EXTZV	#PTE$V_PGFLVB,#PTE$S_PGFLVB,(R3),R0 ;PFN, PGFLVB, GPTX, OR SECTION
	CASE	TYPE=B, SRC=R1, DISPLIST=<- ;DISPATCH ON THE PTE TYPE
		DELTRANS,-		;PAGE IN TRANSITION (OR DZRO)
		DELPAGFIL,-		;PAGING FILE
		DELGLOBAL,-		;GLOBAL PAGE
		DELSTX-			;SECTION TABLE INDEX
	>
;
; FALL THROUGH THE CASE STATEMENT FOR VALID PAGE TABLE ENTRY
;
DELVALID:
	ASSUME PTE$V_WINDOW LE PTE$S_PGFLVB
	BBSC	#PTE$V_WINDOW,R0,50$	;BR IF PFNMAP-ED
	CMPL	R0,MMG$GL_MAXPFN	;IS PFN IN SHARED MEMORY?
	BGTRU	55$			;BR ON YES, GO ALTER SHM GSD REF CNT
	EXTV	#PFN$V_PAGTYP,#PFN$S_PAGTYP, - ;GET PAGE TYPE
		@W^PFN$AB_TYPE[R0],R1
	ASSUME	PFN$C_PROCESS EQ 0
	BNEQ	DELPAGNOTPROCES	;BRANCH IF NOT PROCESS PAGE
;
; CHECK TO SEE THAT PAGE IS NOT LOCKED IN THE WORKING SET
;
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R0],R1>,-	;INDEX TO WORKING SET LIST ENTRY
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BITL	#<WSL$M_WSLOCK ! WSL$M_PFNLOCK>,(R5)[R1] ;LOCKED OR PERMANENT PAGE?
	BNEQ	57$			;BRANCH IF YES
	CMPW	@W^PFN$AW_REFCNT[R0],#1	;MUST WAIT IF REFERENCE COUNT IS UP
	BGTR	90$			;INDICATING I/O IN PROGRESS
	BBS	#PTE$V_MODIFY,(R3),40$	;BRANCH IF PAGE MODIFIED
	BBC	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],60$ ;BRANCH IF PAGE NOT MODIFIED
40$:	ROTL	#<31-PTE$V_TYP0>,@W^PFN$AL_BAK[R0],R1 ;SECTION BACKING STORE?
	BGEQ	60$			;BRANCH IF NOT
	BRW	DELPAG_WRTBAK		;MUST WRITE THIS PAGE BACK
50$:	BRW	PFNMAPDEL		;BR TO DELETE PFNMAP-ED PAGE
55$:	BRW	SHMPAGDEL		;BR TO DELETE SHARED MEMORY PAGE
57$:	BRW	DELPAGLOCKED		;BR TO DELETE LOCKED PAGE
DELPAG_WRTDONE:
60$:	BICB3	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0],R1 ;FETCH ALL BUT MODIFY BIT
	BISB3	#PFN$M_DELCON,R1,@W^PFN$AB_STATE[R0] ;SET DELCON, CLEAR MODIFY
	BICB	#<PTE$M_VALID ! PTE$M_MODIFY>@-24,3(R3) ;MAKE PTE INTO TRANSITION FORMAT
	INVALID	R2			;AND INVALIDATE THE TRANSLATION BUFFER
	PUSHL	R2			;SAVE VA
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R0],R1>,-	;GET WORKING SET LIST INDEX
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	XORL3	R2,(R5)[R1],R3		;HIGH VA BITS MUST AGREE
	ASHL	#-VA$S_BYTE,R3,R3	;SHIFT OUT THE ONES THAT MAY DIFFER
	BNEQ	WSLXVANOMAT		;AND BRANCH IF HIGH BITS DISAGREE
	BSBW	MMG$DELWSLEPPG		;DELETE WORKING SET LIST ENTRY
					;FOR PRCESS PAGE
;
; IF THE PAGE WAS QUEUED FOR WRITING, THEN THE REFERENCE COUNT WILL BE UP
;
	DECREF	GTR=80$			;ONE LESS REF WITH WSLE RELEASED
	BSBW	MMG$RELPFN		;WILL RESULT IN PTE CONTAINING ITS
					;BACKING STORE FORMAT
	BRB	DELAGAIN1		;GO DELETE THE PTE
;
; WORKING SET LIST ENTRY AND VIRTUAL ADDRESS DISAGREE
;
WSLXVANOMAT:
	BUG_CHECK WSLXVANMAT,FATAL
;
; I/O IN PROGRESS ON THIS PAGE, MUST WAIT
;
DELPAGIOWAIT1:
80$:	POPR	#^M<R2>			;RESTORE SAVED VA
90$:	BRB	DELPAGIOWAIT		;WAIT FOR I/O COMPLETION

	.DSABL	LSB
;
; WAIT FOR I/O TO COMPLETE OR RESOURCE TO BECOME AVAILABLE
; 0(SP) = SAVED ACCESS MODE, TO BE RESTORED TO R0
; 8(SP) = PSL AT ENTRY TO DELPAG
; R2, R4, R5, R6, R7, R8 AS THEY WERE ON ENTRY TO DELPAG
; R1 = RESOURCE TO WAIT FOR
;
	.ENABL	LSB
DELPAGRESWAIT:
	PUSHL	R2			;SAVE VIRTUAL ADDRESS
	BSBW	MMG$RESRCWAIT		;SET UP TO WAIT FOR THE RESOURCE
	BRB	10$

;
; R0 = PAGE FRAME NUMBER
;
DELPAGIOWAIT:
	BISB	#PFN$M_RPTEVT,@W^PFN$AB_TYPE[R0] ;WAKE THIS PROCESS ON I/O COMPLETE
					;DELCONPFN WILL CLEAR THIS BIT
	PUSHL	R2			;SAVE VIRTUAL ADDRESS
	MOVAQ	W^SCH$GQ_PFWQ,R0	;PAGE FAULT WAIT QUEUE HEAD
	BSBW	MMG$PGFLTWAIT		;SET UP TO WAIT ON PAGE FAULT WAIT QUEUE
10$:	POPR	#^M<R2>			;RESTORE SAVED VIRTUAL ADDRESS
	POPR	#^M<R0>			;R0 = SAVED ACCESS MODE
	MOVAL	W^MMG$DELPAG,(SP)	;STORE PC TO RESTART AT
	BRW	MMG$SVPCTX		;AND EXIT TO SCHEDULER

	.DSABL LSB
;
; TRANSITION PAGE ON FREE, MODIFIED OR BAD PAGE LIST
; R0 = PFN, R1 = LIST ID
;
MFY_OR_FRELST:
	PUSHL	R2			;SAVE VA
	MOVL	R1,R2			;GET LIST ID
	BEQL	20$			;BRANCH IF FREE LIST
	BLBC	R2,10$			;BRANCH IF BAD PAGE LIST
	ROTL	#<31-PTE$V_TYP0>,@W^PFN$AL_BAK[R0],R1 ;TYP0 BIT TO SIGN BIT
	BGEQ	10$			;BRANCH IF NOT SECTION PAGE (TYP0=0)
	POPR	#^M<R2>			;RECOVER SAVED VA
	BRB	DELFAULT		;AND FAULT THE SECTION PAGE
10$:	BICB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ;OTHERWISE SKIP THE WRITE
20$:	BSBW	MMG$DELPFNLST		;REMOVE PAGE FROM LIST AND DELETE CONTENTS
DELAGAIN1:
	POPR	#^M<R2>			;RECOVER SAVED VA
	BRB	DELAGAIN
;
; THIS IS A PAGE IN TRANSITION OR A DEMAND ZERO PAGE
; R0 = PFN, R2 = VA, R3 = SVAPTE
;
DELTRANS:
	TSTL	R0			;ZERO PFN INDICATES DEMAND ZERO PAGE
	BEQL	BRBINCPGFLCNT		;BRANCH IF IT IS

	ASSUME	PFN$C_FREPAGLST EQ 0
	ASSUME	PFN$C_MFYPAGLST EQ 1
	ASSUME	PFN$C_BADPAGLST EQ 2
	ASSUME	PFN$C_RELPEND   EQ 3
	ASSUME	PFN$C_RDERR     EQ 4	;-4
	ASSUME	PFN$C_WRTINPROG EQ 5	;-3
	ASSUME	PFN$C_RDINPROG  EQ 6	;-2
	ASSUME	PFN$C_ACTIVE    EQ 7	;-1

	EXTV	#PFN$V_LOC,#PFN$S_LOC,-	;GET PAGE'S LOCATION
		@W^PFN$AB_STATE[R0],R1
	CASE	R1,<-
		DELPAGIOWAIT,-		;-3 = 5 = WRITE IN PROGRESS
		DELFAULT,-		;-2 = 6 = READ IN PROGRESS
		DELVALID,-		;-1 = 7 = ACTIVE
		MFY_OR_FRELST,-		;FREE PAGE LIST
		MFY_OR_FRELST,-		;MODIFIED PAGE LIST
		MFY_OR_FRELST-		;BAD PAGE LIST
		>,TYPE=B,LIMIT=#-3
DELFAULT:
	ENBINT	4(SP)			;OTHERWISE RESTORE IPL
;
; FAULT THE PAGE OUT OF THE TRANSITION STATE
;
	TSTB	(R2)			;REFERENCE THE PAGE
DELAGAIN:
	POPR	#^M<R0>			;RESTORE R0 = ACCESS MODE
	ENBINT				;POP AND RESTORE SAVED IPL
	ADDL	#4,SP			;CLEAN OFF SAVED PSL
	BRW	MMG$DELPAG		;RESTART THE ROUTINE FROM THE TOP
;
; THIS IS A PAGE FILE PTE
; R0 = PAGE FILE VBN
;
DELPAGFIL:
	TSTL	R0			;NULL PAGE FILE VBN?
	BEQL	BRBINCPGFLCNT		;BRANCH IF YES
	PUSHR	#^M<R2,R3>		;SAVE VA, SVAPTE
	MOVZBL	PHD$B_PAGFIL(R5),R3	;PAGE FILE INDEX IN R1
	BSBW	MMG$DALCPAGFIL		;DEALLOCATE THE PAGING FILE VBN
	POPR	#^M<R2,R3>		;RESTORE R2 = VA, R3 = SVAPTE
BRBINCPGFLCNT:
	BRW	INCPGFLCNT		;GO DELETE THE PTE
;
; THIS IS A GLOBAL PTE
; R0 = GLOBAL PAGE TABLE INDEX
;
DELGLOBAL:
	.ENABL	LSB
	BICL3	#^C<PTE$M_VALID ! -	;VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! - ;PAGE TYPE BITS
		PTE$M_PGFLVB>,@W^MMG$GL_GPTBASE[R0],R1 ;ETC, FROM MASTER PTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R1,R0 ;PFN FROM VALID OR TRANSITION PTE
	BBS	#PTE$V_VALID,R1,20$	;BRANCH IF MASTER PTE IS VALID
	BBS	#PTE$V_TYP1,R1,30$	;BRANCH IF NOT TRANSITION PAGE
	BBC	#PTE$V_TYP0,R1,15$	;BRANCH IF TRANSITION PTE
10$:	BUG_CHECK IVGBLTYP,FATAL	;INVALID GLOBAL MASTER PTE TYPE

;
; TRANSITION PAGE TABLE ENTRY
;
15$:	EXTV	#PFN$V_LOC,#PFN$S_LOC,-	;IF PAGE IS READ IN PROGRESS
		@W^PFN$AB_STATE[R0],R1	;READ ERROR, OR ACTIVE BUT NOT VALID
					;THEN MUST SEE IF THERE IS A WSLE
	BGEQ	20$			;BRANCH IF ON PFN LIST OR RELPEND
	CMPB	#<PFN$C_WRTINPROG ! <<-1>@PFN$S_LOC>>,R1 ; IF NOT WRITE IN PROGRESS
	BNEQ	40$			;THEN READ IN PROG, READ ERR, ACTIVE
;
; SEE IF I/O IS IN PROGRESS ON THIS PAGE
;
20$:	CLRL	R1			;COMPARE REFCNT AGAINST 0
		PFN_REFERENCE	-
	TSTW	<@W^PFN$Ax_SHRCNT[R0]>,-	;IF SHRCNT IS 0
		LONG_OPCODE=TSTL,-
		IMAGE=SYS_NONPAGED
	BEQL	22$
	INCL	R1			;OTHERWISE COMPARE REFCNT AGAINST 1
22$:	CMPW	@W^PFN$AW_REFCNT[R0],R1	;I/O IN PROGRESS ON THIS PAGE?
	BLEQ	26$			;BRANCH IF NOT
	CMPW	PCB$W_DIOLM(R4),PCB$W_DIOCNT(R4) ;ANY DIRECT I/O'S FOR THIS PROCESS?
	BGTRU	50$			;BRANCH IF YES
26$:	MOVL	@W^PFN$AL_BAK[R0],R1	;BACKING STORE ADDRESS
30$:	BBC	#PTE$V_TYP0,R1,60$	;BRANCH IF NOT SECTION TABLE
	BBS	#PTE$V_DZRO,R1,DELFAULT1 ;FAULT IF DEMAND ZERO
	BBC	#PTE$V_CRF,R1,35$	;BRANCH IF NOT COPY ON REFERENCE SECTION
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	INCL	JIB$L_PGFLCNT(R0)	;ONE LESS PAGE FILE PAGE CHARGED
35$:	CVTWL	R1,R1			;ISOLATE GLOBAL SECTION TABLE INDEX
	PUSHR	#^M<R2,R5>		;SAVE THESE
	MOVAL	@L^MMG$GL_SYSPHD,R5	;ADDRESS OF SYSTEM HEADER
	BSBW	MMG$DECSECREF		;COUNT ONE LESS SECTION REFERENCE
	POPR	#^M<R2,R5>		;RESTORE SAVED REGISTERS
	BRW	DELPTE			;FINISH DELETING THE PAGE TABLE ENTRY
40$:	BBSS	#MMG$V_DELGBLDON,(SP),20$ ;IF ALREADY DELETED THESE GLOBAL
					;WSLE'S, THEN DON'T DO IT AGAIN
	BRW	DELGBLRDINPROG		;GO DO THE DELGBL SCAN

DELFAULT1:
	BRW	DELFAULT		;BR TO FAULT PAGE

;
; THIS GLOBAL PAGE HAS I/O OUTSTANDING AND THIS PROCESS HAS SOME
; DIRECT I/O'S IN PROGRESS.  JUST IN CASE HE IS RESPONSIBLE FOR THE
; I/O REQUEST ON THIS PAGE, MAKE HIM WAIT FOR ALL HIS DIRECT I/O
; REQUESTS TO COMPLETE.
;
50$:	MOVZWL	#RSN$_ASTWAIT,R1	;WAIT FOR AN AST TO OCCUR
	BRW	DELPAGRESWAIT

;
; HANDLE THE POSSIBILITY OF A GLOBAL SECTION WITH PAGE FILE BACKING STORE
;
60$:	
	CMPZV	#PTE$V_TYP0,#2,R1,#0	;CHECK FOR PAGE FILE
	BNEQ	10$
	BSB	FNDGBLSECTBL
	BRB	DELPTE

	.DSABL	LSB
;
; FIND THE GLOBAL SECTION TABLE FOR A GIVEN GPTX
; DECREMENT THE REFERENCE COUNT
;
FNDGBLSECTBL:
	PUSHR	#^M<R2,R5,R6,R7>
	MOVAL	@L^MMG$GL_SYSPHD,R5	;ADDRESS OF SYSTEM HEADER
	EXTZV	#PTE$V_PGFLVB,#PTE$S_PGFLVB,(R3),R6  ;GET THE GPT INDEX
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R0  ;BASE OF SECTION TABLE
	MOVL	MMG$GL_GBLSECFND,R1	;DO WE HAVE A PREVIOUS MATCH TO START WITH
	BNEQ	10$			;YES
5$:	CVTWL	PHD$W_PSTLAST(R5),R1	;INDEX TO LAST SECTION
10$:	MOVAL	(R0)[R1],R2		;SECTION ADDRESS
	TSTL	SEC$L_REFCNT(R2)	;IGNORE IF NEGATIVE REF COUNT
	BLEQ	20$
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,-
		SEC$L_VPXPFC(R2),R7	;BASE FOR THIS SECTION
	CMPL	R6,R7
	BLSS	20$			;WRONG ONE
	ADDL2	SEC$L_PAGCNT(R2),R7
	CMPL	R6,R7
	BGEQ	20$			;WRONG ONE
	BSBW	MMG$DECSECREF		;GO DEC THE REF COUNT
	BRB	30$
20$:	TSTL	MMG$GL_GBLSECFND	;IS THIS THE FIRST LOOP
	BEQL	25$			;NO
	CLRL	MMG$GL_GBLSECFND
	BRB	5$
25$:	ADDL2	#SEC$C_LENGTH@-2,R1	;NEXT SECTION
	BLSS	10$
30$:	POPR	#^M<R2,R5,R6,R7>
	RSB
;
; THIS IS A PROCESS SECTION PAGE
; R0 = SECTION INDEX AND FLAGS
;
DELSTX:					;PROCESS SECTION PAGE
	BBS	#PTE$V_DZRO,R0,DELFAULT1 ;FAULT IF DEMAND ZERO
	CVTWL	R0,R1			;SECTION INDEX
	PUSHL	R2			;SAVE VA
	BSBW	MMG$DECSECREF		;DECREASE SECTION REFERENCE COUNT
	POPR	#^M<R2>			;RECOVER SAVED VA
	BBC	#PTE$V_CRF,R0,DELPTE	;BRANCH IF NOT CRF SECTION
INCPGFLCNT:
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	INCL	JIB$L_PGFLCNT(R0)	;ONE LESS PAGE FILE PAGE CHARGED
;
; FALL THROUGH TO DELPTE
;
DELPTE:
	CLRL	(R3)			;JUST ZERO THE PTE
	TSTL	R6			;LAST PAGE OF THE RANGE?
	BEQL	DELPAGLAST		;YES, GO CONTRACT THE REGION

DELPAGSUCCESS:
	MOVZWL	#SS$_NORMAL,R0		;SUCCESS RETURN
;
; 0(SP) = ACCESS MODE, 4(SP) = IPL TO RESTORE, 8(SP) = SAVED PSL
;
DELPAGRET:
	ENBINT	4(SP)			;RESTORE SAVED IPL
	ADDL	#12,SP			;ADJUST THE STACK
	RSB				;AND RETURN
;
; LAST PAGE OF THE DELETE RANGE
;
DELPAGLAST:
	SETIPL	#IPL$_ASTDEL		;NO NEED FOR SYNCH HERE
	JSB	MMG$CONTRACT		;CONTRACT REGION IF POSSIBLE
	BRB	DELPAGSUCCESS		;AND EXIT SUCCESSFULLY
;
; MUST WRITE SECTION PAGE BACK TO DISK BEFORE DELETE
; 0(SP) = SAVED ACCESS MODE
; 8(SP) = SAVED PSL AT ENTRY TO DELPAG
;
DELPAG_WRTBAK:
	PUSHR	#^M<R0,R2,R3>		;SAVE SOME REGISTERS
	TSTW	PCB$W_DIOCNT(R4)	;EXHAUSTED DIRECT I/O QUOTA?
	BEQL	40$			;BRANCH IF YES, WAIT FOR SOME TO COMPLETE
	REMQUE	@W^IOC$GL_IRPFL,R2	;GET AN I/O PACKET FROM THE SIDE LIST
	BVC	20$			;BRANCH IF GOT ONE
	MOVZBL	#IRP$C_LENGTH,R1	;SIZE OF PACKET TO ALLOCATE
	BSBW	EXE$ALONONPAGED		;ALLOCATE IT FROM NON-PAGED POOL
	MOVZBL	#RSN$_NPDYNMEM,R1	;IN ANTICIPATION OF ALLOCATION FAILURE
	BLBC	R0,60$			;BRANCH IF MUST WAIT FOR A PACKET
20$:	MOVL	R2,R1			;I/O PACKET ADDRESS TO R1
	POPR	#^M<R0,R2,R3>		;R0=PFN, R2=VA, R3=SVAPTE
	MOVZBW	#IRP$C_LENGTH,IRP$W_SIZE(R1) ;SET SIZE FIELD
					;TYPE FIELD FILLED IN BY WRTPGSBAK
	MOVB	(SP),IRP$B_RMOD(R1)	;REQUESTING MODE FROM ACCESS MODE PARAM
	MOVL	R2,IRP$L_SEGVBN(R1)	;SAVE STARTING VA FOR SCAN
	PUSHR	#^M<R0,R2,R3>		;PRESERVE THESE ACROSS THE CALL
	MOVL	@W^PFN$AL_BAK[R0],R2	;BACKING STORE ADDRESS IN R2
	BSBW	MMG$WRTPGSBAK		;WRITE A CLUSTER OF PAGES BACK
	POPR	#^M<R0,R2,R3>		;RESTORE SAVED REGISTERS
	INSV	#PFN$C_WRTINPROG,#PFN$V_LOC,#PFN$S_LOC,-
		@W^PFN$AB_STATE[R0]	;FORCE THIS PAGE TO WRITE IN PROGRESS
	BRW	DELPAG_WRTDONE
;
; DIRECT I/O QUOTA EXCEEDED, MUST WAIT FOR A DIRECT I/O TO COMPLETE
;
40$:	MOVZBL	#RSN$_ASTWAIT,R1	;WAIT FOR AN AST TO OCCUR
;
; UNABLE TO WRITE SECTION PAGE BACK, MUST WAIT FOR RESOURCE IN R1
;
60$:	POPR	#^M<R0,R2,R3>		;R0=PFN, R2=VA, R3=SVAPTE
	BRW	DELPAGRESWAIT		;GO WAIT FOR THE RESOURCE

	.SBTTL	CONTRACT - ADJUST THE LENGTH OF THE SPECIFIED REGION

;
; INPUTS:
;
;	R2 = VIRTUAL ADDRESS (USED ONLY TO SPECIFY P0/P1 SPACE)
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = PROCESS HEADER ADDRESS (P1 SPACE REQUIRED)
;	IPL = ASTDEL
;
; OUTPUTS:
;
;	R2 PRESERVED
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$CONTRACT:
	PUSHL	R2			;SAVE VIRTUAL ADDRESS
	BSBW	MMG$DALCSTXSCN		;SEE IF ANY SECTIONS TO DEALLOCATE
	POPR	#^M<R2>			;RESTORE VIRTUAL ADDRESS
	MNEGL	#1,R0			;INITIAL COUNT OF PAGES TO REDUCE THE REGION BY
	BBS	#VA$V_P1,R2,40$		;BRANCH IF P1 SPACE
;
; P0 SPACE
;
	EXTV	#VA$V_VPN,#VA$S_VPN+1,-	;GET VIRTUAL PAGE NUMBER
		PHD$L_FREP0VA(R5),R3	;OF FIRST FREE PAGE IN P0 SPACE
	ADDL	SGN$GL_PHDLWCNT,R3	;AND FORM PAGE TABLE INDEX
	PUSHL	R0			;-1 FOR GOING BACKWARDS THROUGH PTE'S
	MFPR	#PR$_P0LR,R1		;NUMBER OF PAGES IN P0 SPACE
	BRB	70$			;START SCAN OF ZERO PTE'S
;
; P1 SPACE
;
40$:	EXTV	#VA$V_VPN,#VA$S_VPN+1,-	;VIRTUAL PAGE NO.
		PHD$L_FREP1VA(R5),R3	;0F FIRST FREE PAGE IN P1 SPACE
	ADDL	SGN$GL_P1LWCNT,R3	;FORM PT INDEX
	PUSHL	#1			;+1 FOR GOING FORWARD THROUGH PTE'S
	SUBL3	PHD$L_P1LR(R5),#1@21,R1	;NO. OF PAGES IN P1 SPACE
	BRB	70$			;START SCANNING FOR ZERO PTE'S
;
; 0(SP) = +1 IF GOING FORWARD IN PTE'S (P1 SPACE)
;	= -1 IF GOING BACKWARDS IN PTE'S (P0 SPACE)
; R0 = -1 WITH LOOP ENTERED AT 70$
; R1 = MAX NUMBER OF PAGE TABLE ENTRIES TO SCAN (POSSIBLY 0)
; R3 = PTE INDEX FOR THE FIRST NON-EXISTING PAGE IN THE REGION
;
60$:	TSTL	@PCB$L_PHD(R4)[R3]	;DELETED PAGE TABLE ENTRY?
	BNEQ	80$			;BRANCH IF NOT
70$:	ADDL	(SP),R3			;NEXT PAGE TABLE INDEX
	AOBLSS	R1,R0,60$		;TEST NEXT PTE
;
; R0 = NUMBER OF PAGES TO CONTRACT THE REGION BY, POSSIBLY 0
;
80$:	ADDL	R0,PHD$L_FREPTECNT(R5)	;THAT MANY MORE FREE PAGE TABLE ENTRIES
	ROTL	#9,R0,R1		;NO. OF BYTES TO CONTRACT REGION BY
	TSTL	(SP)+			;CLEAN OFF PTE SCAN DIRECTION
	BGTR	90$			;BRANCH IF P1 SPACE
;
; P0 SPACE
;
	SUBL	R0,PHD$L_P0LRASTL(R5)	;ADJUST NO. OF PAGES
	SUBL	R1,PHD$L_FREP0VA(R5)	;ADJUST FIRST FREE P0 SPACE VIRT ADR
	BLSS	120$			;ERROR IF NOT STILL P0 SPACE
	LDP0LR	PHD$L_P0LRASTL(R5)	;LOAD HARDWARE P0 SPACE LENGTH REGISTER
	BRB	100$
;
; P1 SPACE
;
90$:	ADDL	R0,PHD$L_P1LR(R5)	;UPDATE P1 LENGTH
	ADDL	R1,PHD$L_FREP1VA(R5)	;AND FIRST FREE P1 VIRT ADR
	BLSS	120$			;ERROR IF NOT STILL P1 SPACE
	LDP1LR	PHD$L_P1LR(R5)		;UPDATE HARDWARE P1 LENGTH REGISTER
100$:	BSBW	UPDATPTCNT		;UPDATE MAX PAGE TABLE COUNT
	RSB
;
; FREE P0/P1 VIRTUAL ADDRESS IS FOULED UP
;
120$:	BUG_CHECK CONTRACT,FATAL	;BAD FREP0VA OR FREP1VA

	.SBTTL	PAGETYPE - CALCULATE PAGE TYPE

;
; INPUTS:
;
;	R0 = ACCESS MODE FOR PAGE OWNER CHECK
;	R1 = PAGE TABLE ENTRY CONTENTS (NOT 0)
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;		SS$_NORMAL IF SUCCESSFUL
;		SS$_PAGOWNVIO IF CAN'T OPERATE ON THIS PAGE
;	R1 = PAGE TYPE CODE IN LOW BYTE
;		0 = TRANSITION
;		1 = PAGE FILE
;		2 = GLOBAL
;		3 = SECTION INDEX
;		4 = VALID
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;
MMG$PAGETYPE::
	CMPZV	#PTE$V_OWN,#PTE$S_OWN,R1,R0 ;PAGE OWNER OK?
	BLSS	20$			;BRANCH IF NO
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION
	BBC	#PTE$V_VALID,R1,10$	;BRANCH IF PAGE NOT VALID
	MOVL	#4,R1			;CODE FOR VALID PAGE
	RSB
10$:	EXTV	#PTE$V_TYP0,#<PTE$V_TYP1+1-PTE$V_TYP0>,R1,R1
;
; LOW BIT = TYP0, SIGN BIT = TYP1
;
	ROTL	#1,R1,R1		;BIT 0 = TYP1, BIT 1 = TYP0
	BICB	#^C<3>,R1		;CLEAR REST OF THE BYTE
	RSB				;AND RETURN THE PAGE TYPE
;
; PAGE OWNER VIOLATION
;
20$:	MOVZWL	#SS$_PAGOWNVIO,R0	;PAGE OWNER VIOLATION
	RSB



	.END
