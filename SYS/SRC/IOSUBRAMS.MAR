	.TITLE	IOSUBRAMS - NONPAGED RANDOM ACCESS MASS STORAGE I/O RELATED ROUTINES
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; AUTHOR: D. N. CUTLER 16-MAR-1977
;
; MODIFIED BY:
;
;	V02-005	ACG0237		Andrew C. Goldstein,	9-Dec-1981  11:39
;		Add cathedral window support; check mapping against
;		file size in FCB
;
;	V02-004	GRR2004		Greg R. Robert,		14-Jun-1981
;		Added alternate entry point to IOC$CVTLOGPHY
;
;	V02-003	ACG0176		Andrew C. Goldstein,	6-Jun-1980  13:54
;		Redirect UCB to file's UCB on unsuccessful virtual map
;
;**
;
;
; NONPAGED RANDOM ACCESS MASS STORAGE I/O RELATED ROUTINES
;
; MACRO LIBRARY CALLS
;
 
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$FCBDEF				;DEFINE FCB OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PTEDEF				;DEFINE PAGE TABLE ENTRY FIELDS
	$RVTDEF				;DEFINE RVT OFFSETS
	$SSDEF				;DEFINE I/O STATUS CODES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VADEF				;DEFINE VIRTUAL ADDRESS FIELDS
	$WCBDEF				;DEFINE WCB OFFSETS

	.SBTTL	APPLY ECC CORRECTION
;+
; IOC$APPLYECC - APPLY ECC CORRECTION
;
; THIS ROUTINE IS CALLED TO APPLY AN ECC CORRECTION TO DATA THAT HAS BEEN
; TRANSFERED INTO MEMORY FROM A DISK DEVICE.
;
; INPUTS:
;
;	R0 = NUMBER OF BYTES OF DATA THAT WERE TRANSFERED UP TO, BUT NOT
;		INCLUDING, BLOCK TO BE CORRECTED (MUST BE A MULTIPLE OF 512
;		BYTES).
;	R5 = DEVICE UNIT UCB ADDRESS.
;
;	UCB$W_BCNT(R5) = LENGTH OF TRANSFER IN BYTES.
;	UCB$W_EC1(R5) = STARTING BIT NUMBER OF ERROR BURST.
;	UCB$W_EC2(R5) = EXCLUSIVE OR CORRECTION PATTERN.
;	UCB$L_SVAPTE(R5) = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE THAT MAPS
;		THE TRANSFER.
;
; OUTPUTS:
;
;	THE CORRECTION PATTERN IS EXCLUSIVE OR'ED WITH THE DATA IN MEMORY
;	PROVIDING THE NECESSARY CORRECTION.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
	.PSECT	WIONONPAGED
IOC$APPLYECC::				;APPLY ECC CORRECTION
	PUSHR	#^M<R3,R4>		;SAVE REGISTERS
	MOVZWL	UCB$W_EC1(R5),R2	;GET STARTING BIT NUMBER OF ERROR BURST
	DECL	R2			;CONVERT TO RELATIVE BIT NUMBER
	BICB3	#^XF8,R2,R1		;ISOLATE PATTERN SHIFT COUNT
	DIVL	#8,R2			;CALCULATE RELATIVE BYTE OFFSET IN BLOCK
	ADDL	R0,R2			;CALCULATE RELATIVE OFFSET IN BUFFER
	MOVZWL	UCB$W_EC2(R5),R0	;GET EXCLUSIVE OR CORRECTION PATTERN
	ASHL	R1,R0,R0		;SHIFT PATTERN TO PROPER POSITION
	MOVL	#3,R4			;SET LOOP COUNT
10$:	CMPW	R2,UCB$W_BCNT(R5)	;BYTE OFFSET WITHIN RANGE?
	BGEQU	40$			;IF GEQU NO
	MOVZWL	UCB$W_BOFF(R5),R1	;GET BYTE OFFSET IN PAGE
	ADDL	R2,R1			;CALCULATE BYTE OFFSET OF TRANFER PTE
	ASHL	#-VA$S_BYTE,R1,R1	;CALCULATE LONGWORD OFFSET TO TRANSFER PTE
	MOVL	@UCB$L_SVAPTE(R5)[R1],R3 ;GET TRANSFER PTE
	BLSS	20$			;IF LSS VALID PTE
	BSBW	IOC$PTETOPFN		;CONVERT TO VALID PTE
20$:	MULL3	#4,UCB$L_SVPN(R5),R1	;CALCULATE BYTE OFFSET TO SYSTEM PTE
	INSV	R3,#PTE$V_PFN,-		;MOVE TRANSFER PTE INTO SYSTEM PAGE TABLE
		#PTE$S_PFN,@MMG$GL_SPTBASE[R1]	;
	ASHL	#VA$S_BYTE-2,R1,R1	;CONVERT SVPN TO SYSTEM VIRTUAL ADDRESS
	BBSS	#VA$V_SYSTEM,R1,30$	;SET SYSTEM VIRTUAL ADDRESS BIT
30$:	INVALID	R1			;INVALIDATE TRANSLATION BUFFER
	ADDL3	UCB$W_BOFF(R5),R2,R3	;CALCULATE BYTE OFFSET IN BLOCK
	INSV	R3,#VA$V_BYTE,#VA$S_BYTE,R1 ;INSERT BYTE OFFSET IN BLOCK
	XORB	R0,(R1)			;CORRECT MEMORY BYTE
	ASHL	#-8,R0,R0		;SHIFT NEXT CORRECTION BYTE INTO PLACE
	INCL	R2			;UPDATE OFFSET IN BUFFER
	SOBGTR	R4,10$			;ANY MORE CORRECTIONS TO MAKE?
40$:	POPR	#^M<R3,R4>		;RESTORE REGISTERS
	BISW	#UCB$M_ECC,UCB$W_DEVSTS(R5) ;SET ECC CORRECTION MADE
	RSB				;

	.SBTTL	CONVERT LOGICAL BLOCK TO PHYSICAL ADDRESS
;+
; IOC$CVTLOGPHY - CONVERT LOGICAL BLOCK TO PHYSICAL ADDRESS
;
; THIS ROUTINE IS CALLED TO CONDITIONALLY CONVERT A LOGICAL BLOCK NUMBER
; TO A PHYSICAL DISK ADDRESS AND STORE THE RESULT IN THE I/O PACKET.
;
; INPUTS:
;
;	R0 = LOGICAL BLOCK NUMBER TO BE CONVERTED.
;	R3 = I/O PACKET ADDRESS.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF UCB$V_NOCNVRT IS CLEAR IN UCB$W_DEVSTS, THE LOGICAL BLOCK NUMBER
;	IS CONVERTED TO A PHYSICAL DISK ADDRESS USING THE DISK GEOMETRY PARA-
;	METERS IN THE UCB. THE RESULT IS STORED IN THE MEDIA ADDRESS LONGWORD
;	OF THE I/O PACKET.
;
;	IF UCB$V_NOCNVRT IS SET, THE BLOCK NUMBER IS STORED IN THE MEDIA ADDRESS
;	LONGWORD WITHOUT CONVERSION.
;
;	IF THE ROUTINE IS ENTERED AT IOC$CVTLOGPHYU, THEN UCB$V_NOCNVRT IS
;	IGNORED.
;
;	R3 IS PRESERVED ACROSS CALL.
;-

	.ENABLE	LOCAL_BLOCK

IOC$CVTLOGPHY::				;CONVERT LOGICAL BLOCK TO PHYSICAL ADDRESS
	MOVL	R0,IRP$L_MEDIA(R3)	;ASSUME NO CONVERSION
	BBS	#UCB$V_NOCNVRT,UCB$W_DEVSTS(R5),10$ ;BYPASS CONVERSION IF SET
IOC$CVTLOGPHYU::			;UNCONDITIONAL ENTRY POINT
	MOVZBL	UCB$L_DEVDEPEND(R5),R2	;GET NUMBER OF SECTORS PER TRACK
	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R2,R0,R0,IRP$L_MEDIA(R3) ;CALCULATE SECTOR NUMBER AND STORE
	MOVZBL	UCB$L_DEVDEPEND+1(R5),R2 ;GET NUMBER OF TRACKS PER CYLINDER
	EDIV	R2,R0,R0,R1		;CALCULATE TRACK AND CYLINDER
	MOVB	R1,IRP$L_MEDIA+1(R3)	;STORE TRACK NUMBER
	MOVW	R0,IRP$L_MEDIA+2(R3)	;STORE CYLINDER NUMBER
10$:	RSB				;

	.DISABLE LOCAL_BLOCK


	.SBTTL	MAP VIRTUAL TO LOGICAL BLOCK
;+
; IOC$MAPVBLK - MAP VIRTUAL TO LOGICAL BLOCK
;
; THIS ROUTINE IS CALLED TO MAP A VIRTUAL BLOCK TO A LOGICAL BLOCK USING A
; MAPPING WINDOW.
;
; INPUTS:
;
;	R0 = VIRTUAL BLOCK NUMBER.
;	R1 = NUMBER OF BYTES TO MAP.
;	R2 = ADDRESS OF WINDOW MAPPING BLOCK.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES A TOTAL MAPPING FAILURE.
;
;		R2 = NUMBER OF UNMAPPED BYTES.
;
;	R0 LOW BIT SET INDICATES PARTIAL MAP WITH:
;
;		R1 = LOGICAL BLOCK NUMBER OF FIRST BLOCK.
;		R2 = NUMBER OF UNMAPPED BYTES.
;		R5 = UCB ADDRESS OF DEVICE UNIT (POSSIBLY MODIFIED).
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
	.ENABLE	LOCAL_BLOCK

10$:	BUG_CHECK STRNOTWCB,FATAL	;STRUCTURE IS NOT A WINDOW BLOCK

IOC$MAPVBLK::				;MAP VIRTUAL TO LOGICAL BLOCK
20$:	DSBINT	UCB$B_FIPL(R5)		;SYNCHRONIZE ACCESS TO SYSTEM DATABASE
	PUSHR	#^M<R1,R3,R4,R6,R7,R8>	;SAVE REGISTERS
	MOVAB	-1(R0),R7		;SAVE START VBN -1
	MOVL	R2,R3			;GET COPY OF WINDOW ADDRESS
;
; THE WINDOW MAY CONSIST OF A CHAIN OF WCB SEGMENTS. SEARCH THROUGH THE
; CHAIN UNTIL WE FIND ONE WHICH IS BEYOND THE DESIRED VBN OR WE REACH
; THE END OF THE CHAIN.
;
30$:	CMPB	WCB$B_TYPE(R3),#DYN$C_WCB ;SEE IF THIS IS REALLY A WINDOW
	BNEQ	10$			;IF NEQ NO
	CMPL	R0,WCB$L_STVBN(R3)	;CHECK VBN AGAINST START VBN OF WINDOW
	BLSSU	40$			;BRANCH IF VBN PRECEDES WINDOW
	MOVL	R3,R2			;ELSE ADVANCE TO THIS WINDOW SEGMENT
	MOVL	WCB$L_LINK(R2),R3	;LOOK AT NEXT WINDOW SEGMENT
	BNEQ	30$			;BRANCH TO LOOK AT IF IT EXISTS

40$:	MOVZWL	WCB$W_NMAP(R2),R3	;GET COUNT OF RETRIEVAL POINTERS
	BEQL	60$			;BRANCH IF EMPTY WINDOW
	MOVAL	WCB$L_STVBN(R2),R4	;POINT TO STARTING VBN
	SUBL	(R4)+,R0		;SUBTRACT STARTING VBN FROM DESIRED
	BBS	#DEV$V_SQD,UCB$L_DEVCHAR(R5),70$ ;IF SET, SEQUENTIAL DEVICE
	BLSSU	60$			;BRANCH IF VBN PRECEDES WINDOW
 
;
; SCAN THE WINDOW, SUBTRACTING THE COUNT FIELD OF EACH POINTER FROM THE
; CURRENT RELATIVE BLOCK NUMBER.
;
 
50$:	MOVZWL	(R4)+,R1		;GET COUNT FIELD OF RETRIEVAL POINTER
	SUBL	R1,R0			;SUBTRACT FROM RELATIVE BLOCK NUMBER
	BLSSU	80$			;BRANCH IF VBN LOCATED IN THIS POINTER
	TSTL	(R4)+			;SKIP LBN FIELD OF POINTER
	SOBGTR	R3,50$			;LOOP THRU WINDOW
60$:	CLRL	R0			;VBN IS BEYOND WINDOW
	MOVL	WCB$L_ORGUCB(R2),R5	;REDIRECT UCB TO VOLUME CONTAINING THE FILE
	BRB	140$			;RETURN FAILURE
 
;
; DEVICE IS A SEQUENTIAL DEVICE. FIRST MAPPING POINTER CONTAINS THE UCB ADDRESS
; OF THE CURRENT VOLUME THAT IS BEING PROCESSED. ALL BYTES ALWAYS MAP.
;
 
70$:	MOVL	(R4),R5			;GET CURRENT VOLUME UCB ADDRESS
	BRB	120$			;
 
;
; FOUND THE RETRIEVAL POINTER CONTAINING THE STARTING VBN. R0 NOW
; CONTAINS A NEGATIVE VALUE WHICH IS THE NUMBER OF BLOCKS BETWEEN
; THE STARTING VBN AND THE END OF THE POINTER.
;
 
80$:	MOVL	R0,R8			;SAVE # BLOCKS MAPPED PAST START VBN
	ADDL	(R4)+,R1		;FIRST LBN BEYOND THIS POINTER
	ADDL	R1,R0			;COMPUTE STARTING LBN
 
;
; IF THE NEXT RETRIEVAL POINTER IS CONTIGUOUS WITH THE ONE FOUND, ADD
; IN ITS COUNT TO HANDLE THE CASE WHERE A TRANSFER SPANS TWO POINTERS.
; NOTE THAT THE GREATEST NUMBER OF CONTIGUOUS POINTERS A TRANSFER CAN
; SPAN IS TWO.
;
 
	DECL	R3			;SEE IF THERE IS ANOTHER POINTER
	BLEQ	90$			;BRANCH IF NONE
	MOVZWL	(R4)+,R3		;GET COUNT OF NEXT RETRIEVAL POINTER
	CMPL	R1,(R4)			;SEE IF THE NEXT POINTER IS CONTIGUOUS
	BNEQ	90$			;BRANCH IF NOT
	SUBL	R3,R8			;ADD TO # BLOCKS MAPPED (NEGATIVE)
 
;
; EXTRACT THE LBN AND RVN COMPONENTS OF THE STARTING "LBN" AND SWITCH
; TO THE RIGHT UCB IF THIS IS A MULTI-VOLUME SET.
;
 
90$:	EXTZV	#0,#24,R0,R1		;EXTRACT LBN PART
	EXTZV	#24,#8,R0,R0		;EXTRACT RVN
	BEQL	100$			;BRANCH IF NOT VOLUME SET
	MOVL	WCB$L_RVT(R2),R6	;GET RELATIVE VOLUME TABLE ADDR
	MOVL	RVT$L_UCBLST-4(R6)[R0],R5 ;GET THE RIGHT UCB ADDRESS

;
; CHECK THE RANGE OF VBN'S PROVIDED BY THE MAP POINTER AGAINST THE
; FILE SIZE RECORDED IN THE FCB. REDUCE IT IF THE FCB INDICATES A
; SMALLER FILE SIZE THAN THE WINDOW.
;

100$:	BBS	#WCB$V_NOTFCP,WCB$B_ACCESS(R2),110$ ;SKIP CHECK IF NO FCB
	MOVL	WCB$L_FCB(R2),R6	;GET FCB ADDRESS
	SUBL	FCB$L_FILESIZE(R6),R7	;COMPUTE NEG BLOCKS PAST DESIRED VBN
	BGEQU	60$			;BRANCH IF VBN PAST END OF FILE
	CMPL	R7,R8			;COMPARE AGAINST BLOCKS MAPPED
	BLSSU	110$			;BRANCH IF LESS MAPPED BY WINDOW
	MOVL	R7,R8			;ELSE LIMIT TO FILE SIZE
 
;
; SEE IF THE ENTIRE TRANSFER IS MAPPED CONTIGUOUSLY.
;
 
110$:	INCL	PMS$GL_HIT		;COUNT A WINDOW HIT
	ASHL	#9,R8,R8		;CONVERT TO # BYTES MAPPED
	BVS	120$			;BRANCH IF COUNT IS HUGE
	ADDL	R8,(SP)			;SUBTRACT FROM BYTES DESIRED
	BGEQ	130$			;BRANCH IF NOT TOTAL MAP
120$:	CLRL	(SP)			;ZERO INDICATES COMPLETE MAP
130$:	MOVL	#SS$_NORMAL,R0		;INDICATE SUCCESS
140$:	POPR	#^M<R2,R3,R4,R6,R7,R8>	;RESTORE REGISTERS
	ENBINT				;ALLOW INTERRUPTS
	RSB				;

	.DISABLE LOCAL_BLOCK

	.SBTTL	UPDATE TRANSFER PARAMETERS
;+
; IOC$UPDATRANSP - UPDATE TRANSFER PARAMETERS
;
; THIS ROUTINE IS CALLED TO UPDATE THE TRANSFER PARAMETERS AFTER A DISK ERROR
; HAS BEEN DISCOVERED BUT GOOD DATA WAS TRANSFERED.
;
; INPUTS:
;
;	R0 = NUMBER OF BYTES OF DATA THAT WERE TRANSFERED (MUST BE A MULTIPLE
;		OF 512 BYTES).
;	R5 = DEVICE UNIT UCB ADDRESS.
;
;	UCB$W_BCNT(R5) = LENGTH OF TRANSFER IN BYTES.
;	UCB$W_DA(R5) = CURRENT SECTOR AND TRACK ADDRESS.
;	UCB$W_DC(R5) = CURRENT CYLINDER ADDRESS.
;	UCB$L_SVAPTE(R5) = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE THAT MAPS
;		THE TRANSFER.
;
; OUTPUTS:
;
;	THE NUMBER OF BYTES REMAINING TO BE TRANSFERED, THE SYSTEM VIRTUAL
;	ADDRESS OF THE NEXT PTE, AND THE CURRENT DISK ADDRESS OF THE TRANSFER
;	ARE UPDATED.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
IOC$UPDATRANSP::			;UPDATE TRANSFER PARAMETERS
	SUBW	R0,UCB$W_BCNT(R5)	;CALCULATE REMAINING BYTES TO TRANSFER
	ASHL	#-7,R0,R0		;CALCULATE PTE LONGWORDS TO SKIP OVER
	ADDL	R0,UCB$L_SVAPTE(R5)	;UPDATE SYSTEM VIRTUAL ADDRESS OF NEXT PTE
	DIVL	#4,R0			;CALCULATE NUMBER OF SECTORS TRANSFERED
	ADDB	R0,UCB$W_DA(R5)		;UPDATE SECTOR ADDRESS
 
;
; RIPPLE CARRY FROM SECTOR TO TRACK AND FROM TRACK TO CYLINDER
;
 
10$:	CMPB	UCB$L_DEVDEPEND(R5),UCB$W_DA(R5) ;SECTOR OVERFLOW?
	BGTRU	20$			;IF GTRU NO
	SUBB	UCB$L_DEVDEPEND(R5),UCB$W_DA(R5) ;SUBTRACT OUT A TRACK
	INCB	UCB$W_DA+1(R5)		;INCREMENT TRACK ADDRESS
	CMPB	UCB$L_DEVDEPEND+1(R5),UCB$W_DA+1(R5) ;TRACK OVERFLOW?
	BGTRU	10$			;IF GTRU NO
	SUBB	UCB$L_DEVDEPEND+1(R5),UCB$W_DA+1(R5) ;SUBTRACT OUT A CYLINDER
	INCW	UCB$W_DC(R5)		;UPDATE CYLINDER ADDRESS
	BRB	10$			;
20$:	RSB				;

	.SBTTL	SENSE DISK'S SIZE FDT ROUTINE
;+
; IOC$SENSEDISK - SENSE DISK'S SIZE FDT ROUTINE
;
; THIS ROUTINE IS THE STANDARD SENSEMODE/SENSECHAR FDT ROUTINE FOR
; DISK DEVICES.  IT OBTAINS THE DISK'S SIZE, IN LOGICAL BLOCKS, FROM THE
; UCB (UCB$L_MAXBLOCK) AND IMMEDIATELY COMPLETES THE I/O REQUEST WITH
; THE SECOND LONGWORD OF THE FINAL I/O STATUS EQUAL TO THE DISK'S SIZE.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE DISK'S SIZE, IN LOGICAL BLOCKS, IS OBTAINED FROM THE UCB
;	AND THE I/O IS COMPLETED WITH THE SECOND I/O STATUS LONGWORD
;	EQUAL TO THE DISK'S SIZE.
;-
 
IOC$SENSEDISK::				;SENSE DISK'S SIZE
	MOVL	UCB$L_MAXBLOCK(R5),R1	;GET DISK'S SIZE IN LOGICAL BLOCKS
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BRW	EXE$FINISHIO		;FINISH I/O OPERATION
 
	.END
