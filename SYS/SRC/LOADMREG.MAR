	.TITLE	LOADMREG - LOAD MBA AND UBA MAP REGISTERS
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 1-NOV-77
;
; LOAD MBA MAP REGISTERS
;
; MODIFIED BY:
;
;	V03-008	RLRUDAM2	Robert L. Rappaport	5-Feb-1982
;		Fixed minor glitch in IOC$LUBAUDAMAP caused by addition
;		of CDRP$L_UBARSRCE.
;
;	V03-007	RLRUDAM1	Robert L. Rappaport	22-Jan-1982
;		Corrected IOC$LUBAUDAMAP so that it tests for byte offsets.
;
;	V03-006	RLRUDAMP	Robert L. Rappaport	21-Dec-1981
;		Added IOC$LUBAUDAMAP which loads the UBA map registers
;		using the CDRP passed by the UDA Port Driver.
;
;	V05	LMK0001		Len Kawell		23-Aug-1980
;		Added IOC$LOADUBAMAPN which loads the registers without
;		accessing the UCB or CRB.
;
;	V04	RLR-TS04	Robert L. Rappaport	7-DEC-1979
;		Added an alternate entrypoint to IOC$LOADUBAMAP to
;		support byte aligned UNIBUS DMA devices
;
;	V03	NPKCOMET	N. KRONENBERG	11-JUN-1979
;		RETURNED IOC$LOADUBAMAP TO MODULE LOADMREG.
;
;	V02	NPKCOMET	N. KRONENBERG	1-FEB-1979
;		REMOVED IOC$LOADUBAMAP TO MODULE LIOSUB.
;
	.PAGE
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				;DEFINE ADP OFFSETS
	$CDRPDEF			;DEFINE CDRP OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$MBADEF				;DEFINE MBA REGISTER OFFSET DEFINITIONS
	$PTEDEF				;DEFINE PAGE TABLE ENTRY FIELDS
	$UBADEF				;DEFINE UCB OFFSETS
	$UBMDDEF			;DEFINE UBMD OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE CRB TRANSFER VECTOR OFFSETS
	.PAGE
	.SBTTL	LOAD MASSBUS ADAPTER MAP REGISTERS
;+
; IOC$LOADMBAMAP - LOAD MASSBUS ADAPTER MAP REGISTERS
;
; THIS ROUTINE IS CALLED TO LOAD THE MASSBUS ADAPTER MAP REGISTERS, THE
; BYTE COUNT REGISTER, AND THE VIRTUAL ADDRESS REGISTER.
;
; INPUTS:
;
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = UCB ADDRESS OF UNIT TRANSFER IS TO OCCUR ON.
;
; OUTPUTS:
;
;	THE TRANSFER BYTE COUNT, STARTING PAGE OFFSET, AND ADDRESS OF THE
;	PAGE TABLE ENTIRES THAT DESCRIBE THE TRANSFER ARE RETRIEVED FROM
;	THE SPECIFED UCB AND USED TO LOAD THE MBA BYTE COUNT, VIRTUAL ADDRESS,
;	AND MAP REGISTERS. ONE ADDITIONAL MAP REGISTER IS LOADED AS INVALID
;	TO STOP THE TRANSFER IF A HARDWARE FAILURE SHOULD OCCUR.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
	.PSECT	WIONONPAGED
IOC$LOADMBAMAP::			;LOAD MASSBUS ADAPTER MAP REGISTERS
	PUSHL	R3			;SAVE REGISTERS
	MOVZWL	UCB$W_BCNT(R5),R2	;GET TRANSFER BYTE COUNT
	MNEGL	R2,MBA$L_BCR(R4)	;LOAD BYTE COUNT REGISTER
	MOVZWL	UCB$W_BOFF(R5),R1	;GET BYTE OFFSET IN PAGE
	MOVL	R1,MBA$L_VAR(R4)	;LOAD STARTING VIRTUAL ADDRESS
	MOVL	R1,MBA$L_VAR(R4)	;*****TEMP UNTIL MBA ECO ******
	MOVAB	^X1FF(R2)[R1],R2	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R2,R2		;CALCULATE NUMBER OF MAP REGISTERS TO LOAD
	MOVAL	MBA$L_MAP(R4),R1	;GET ADDRESS OF MBA MAP REGISTERS
	MOVL	UCB$L_SVAPTE(R5),R0	;GET ADDRESS OF PAGE TABLE
10$:	MOVL	(R0)+,(R1)+		;LOAD MAP REGISTER
	BGEQ	30$			;IF GEQ PTE INVALID
20$:	SOBGTR	R2,10$			;ANY MORE TO LOAD?
	CLRL	(R1)			;LOAD INVALID MAP ENTRY
	MOVL	(SP)+,R3		;RESTORE REGISTER
	RSB				;
30$:	MOVL	-4(R0),R3		;GET THE PTE (NOT FROM MAP REGISTER!)
	BSBW	IOC$PTETOPFN		;GET PFN FROM INVALID PTE
	BISL3	#^X80000000,R3,-4(R1)	;AND LOAD THE MAP REGISTER
	BRB	20$			;
	.PAGE
	.SBTTL	LOAD UNIBUS ADAPTER MAP REGISTERS
;+
; IOC$LOADUBAMAP  - LOAD UNIBUS ADAPTER MAP REGISTERS
; IOC$LOADUBAMAPA - LOAD UNIBUS ADAPTER MAP REGISTERS ALTERNATE ENTRY FOR
;	BYTE ALIGNED UNIBUS DMA DEVICES WHICH NEVER WISH TO SET THE BYTE
;	OFFSET BIT IN MAP REGISTERS.  IN ALL OTHER RESPECTS THESE TWO
;	ENTRYPOINTS PRODUCE IDENTICAL RESULTS.
;
; THIS ROUTINE IS CALLED TO LOAD THE UNIBUS ADAPTER MAP REGISTERS.
;
; INPUTS:
;
;	R5 = UCB ADDRESS OF UNIT TRANSFER IS TO OCCUR ON.
;
;	IT IS ASSUMED THAT THE DATAPATH AND MAP REGISTERS HAVE BEEN PREVIOUSLY
;	ASSIGNED.
;
; OUTPUTS:
;
;	EACH MAP REGISTER IS LOADED WITH THE APPROPRIATE PAGE FRAME NUMBER
;	MERGED WITH THE DATAPATH DESIGNATOR AND BYTE OFFSET BIT. ONE ADDITIONAL
;	MAP REGISTER IS LOADED AS INVALID TO STOP THE TRANSFER IF A HARDWARE
;	FAILURE SHOULD OCCUR.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
IOC$LOADUBAMAPA::		;LOAD UNIBUS ADAPTER MAP REGISTERS - ALTERNATE
				; HERE WE DUPLICATE THE CODE IN THE OTHER ENTRY
				;  EXCEPT THAT WE DO NOT CHECK WHETHER THE BYTE
				;  OFFSET IS ODD.  INSTEAD WE BRANCH DIRECTLY
				;   PAST THE SETTING OF THE BYTE OFFSET BIT.
	MOVQ	R3,-(SP)		;SAVE REGISTERS
	MOVZWL	UCB$W_BOFF(R5),R1	;GET BYTE OFFSET IN PAGE
	MOVZWL	UCB$W_BCNT(R5),R2	;GET TRANSFER BYTE COUNT
	MOVL	UCB$L_CRB(R5),R3	;GET ADDRESS OF CRB
	EXTZV	#VEC$V_DATAPATH,-	;GET DATAPATH
		#VEC$S_DATAPATH,-	; NUMBER
		CRB$L_INTD+VEC$B_DATAPATH(R3),R4
	BRB	10$			; BRANCH AROUND TO JOIN COMMON CODE
IOC$LOADUBAMAP::			;LOAD UNIBUS ADAPTER MAP REGISTERS
	MOVQ	R3,-(SP)		;SAVE REGISTERS
	MOVZWL	UCB$W_BOFF(R5),R1	;GET BYTE OFFSET IN PAGE
	MOVZWL	UCB$W_BCNT(R5),R2	;GET TRANSFER BYTE COUNT
	MOVL	UCB$L_CRB(R5),R3	;GET ADDRESS OF CRB
	EXTZV	#VEC$V_DATAPATH,-	;GET DATAPATH
		#VEC$S_DATAPATH,-	; NUMBER
		CRB$L_INTD+VEC$B_DATAPATH(R3),R4
	BLBC	R1,10$			;IF LBC WORD ALIGNED TRANSFER
	BISB	#^X10,R4		;SET BYTE OFFSET BIT
10$:	BISW	#^X400,R4		;MERGE VALID WITH BYTE OFFSET AND DATAPATH
	BBC	#VEC$V_LWAE,-		;BRANCH IF LONGWORD ACCESS NOT ENABLED
		CRB$L_INTD+VEC$B_DATAPATH(R3),15$
	BISB	#^X20,R4		;ELSE SET LWAE FOR MAP REG
15$:	MOVAB	^X1FF(R2)[R1],R2	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R2,R2		;CALCULATE NUMBER OF MAP REGISTERS TO LOAD
	CMPB	R2,CRB$L_INTD+VEC$B_NUMREG(R3) ;ENOUGH MAP REGISTERS ASSIGNED?
	BGEQU	40$			;IF GEQU NO
	MOVL	@CRB$L_INTD+VEC$L_ADP(R3),R1 ;GET ADDRESS OF CONFIGURATION REGISTER
	EXTZV	#VEC$V_MAPREG,-		;GET STARTING REGISTER
		#VEC$S_MAPREG,-
		CRB$L_INTD+VEC$W_MAPREG(R3),R0
	MOVAL	UBA$L_MAP(R1)[R0],R1	;GET ADDRESS OF FIRST MAP REGISTER TO LOAD
	MOVL	UCB$L_SVAPTE(R5),R0	;GET ADDRESS OF PAGE TABLE
20$:	MOVL	(R0)+,R3		;GET NEXT PAGE TABLE ENTRY
	BLSS	30$			;IF LSS VALID PAGE TABLE ENTRY
	BSBB	IOC$PTETOPFN		;GET PFN FROM INVALID PTE
30$:	INSV	R4,#21,#11,R3		;INSERT VALID, BYTE OFFSET, AND DATAPATH
	MOVL	R3,(R1)+		;LOAD UBA MAP REGISTER
	SOBGTR	R2,20$			;ANY MORE TO LOAD?
	CLRL	(R1)			;LOAD INVALID MAP ENTRY
	MOVQ	(SP)+,R3		;RESTORE REGISTERS
	RSB				;
40$:	BUG_CHECK UBMAPEXCED,FATAL	;UNIBUS MAP REGISTER ALLOCATION EXCEEDED
	.DSABL	LSB
	.PAGE
	.SBTTL	GET PFN FROM INVALID PTE
;+
; IOC$PTETOPFN - GET PFN FROM INVALID PTE
;
; THIS ROUTINE IS CALLED TO RETURN THE PAGE FRAME NUMBER FROM A
; PAGE TABLE ENTRY WHICH HAS ALREADY BEEN DETERMINED TO BE NOT VALID.
;
; INPUTS:
;
;	R3 = PAGE TABLE ENTRY
;
; OUTPUTS:
;
;	R3 = PAGE FRAME NUMBER AND MAY INCLUDE THE FOLLOWING FIELDS
;		VALID BIT, MODIFY BIT, PROTECTION FIELD, OWNER FIELD
;
;	ALL OTHER REGISTERS PRESERVED
;-

	.ENABL	LSB
GLOBAL:
	MOVL	@MMG$GL_GPTBASE[R3],R3	;GLOBAL PAGE TABLE ENTRY
	BLSS	10$			;BRANCH IF VALID
IOC$PTETOPFN::
	BICL	#^C<PTE$M_TYP1 ! PTE$M_TYP0 !- ;PTE TYPE BITS
		PTE$M_GPTX>,R3		;AND GPTX/PFN
	BBS	#PTE$V_TYP1,R3,20$	;BRANCH IF BAD PTE FOR I/O
	BBSC	#PTE$V_TYP0,R3,GLOBAL	;BRANCH IF GLOBAL PAGE
10$:	RSB
20$:	BUG_CHECK INVPTEFMT,FATAL	;INVALID PAGE TABLE ENTRY FORMAT
	.DSABL	LSB
 
	.PAGE
	.SBTTL	Load UBA map registers
;++
; IOC$LOADUBAMAPN - Load UBA map registers
;
;  Functional description:
;
;	This routine is called to load the UNIBUS adapter map registers.
;	It differs from IOC$LOADUBAMAPN in that it does not obtain its
;	variant inputs from the UCB and CRB (which are normally synchronized
;	at fork IPL).  Also, the byte offset and longword aligned 
;	capabilities are not supported.
;
; Inputs:
;
;	R1 = buffer address
;	R2 = number of map registers allocated
;	     (last one should be extra one for wild transfer stopper)
;	R3 = starting map register allocated
;	R4 = datapath number
;	R5 = UCB address
;
; Outputs:
;
;	R0-R4 destroyed.  R5 preserved.
;--
IOC$LOADUBAMAPN::			;
	PUSHL	R4			; Save datapath number
	EXTZV	S^#VA$V_VPN,S^#VA$S_VPN,R1,R1 ; Get buffer virtual page number
	MOVL	G^MMG$GL_SPTBASE,R4	; Get system page table addres
	MOVAL	(R4)[R1],R0		; Get first PTE address
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	@CRB$L_INTD+VEC$L_ADP(R4),R4 ; Get first UBA register address
	MOVAL	UBA$L_MAP(R4)[R3],R1	; Get address of first map register
	BISL3	#1@<UBA$V_MAP_VALID-UBA$V_MAP_DPD>,- ; Get datapath number
		(SP)+,R4		; and set map register valid bit
	DECL	R2			; Subtract last register from count
20$:	MOVL	(R0)+,R3		; Get next page table entry
	BLSS	30$			; Br if valid page
	BSBB	IOC$PTETOPFN		; Get PFN from invalid (global) page
30$:	INSV	R4,#UBA$V_MAP_DPD,-	; Insert datapath and valid bit,
		#32-UBA$V_MAP_DPD,R3	; clearing other PTE flags
	MOVL	R3,(R1)+		; Load the map register
	SOBGTR	R2,20$			; Loop through all registers
	CLRL	(R1)			; Invalidate last one to stop wild xfer
	RSB				;
	.PAGE	
	.SBTTL	LOAD UNIBUS ADAPTER MAP REGISTERS FOR UDA PORT
;+
; IOC$LUBAUDAMAP - LOAD UNIBUS ADAPTER MAP REGISTERS FOR UDA PORT
;
; INPUTS:
;
;	R5 => CDRP OF I/O REQUEST.
;
;	IT IS ASSUMED THAT THE DATAPATH AND MAP REGISTERS HAVE BEEN PREVIOUSLY
;	ASSIGNED.
;
; OUTPUTS:
;
;	EACH MAP REGISTER IS LOADED WITH THE APPROPRIATE PAGE FRAME NUMBER
;	MERGED WITH THE DATAPATH DESIGNATOR AND BYTE OFFSET BIT. ONE ADDITIONAL
;	MAP REGISTER IS LOADED AS INVALID TO STOP THE TRANSFER IF A HARDWARE
;	FAILURE SHOULD OCCUR.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
IOC$LUBAUDAMAP::		;LOAD UNIBUS ADAPTER MAP REGISTERS

	MOVQ	R3,-(SP)		;SAVE REGISTERS
	MOVZWL	CDRP$W_BOFF(R5),R1	; R1=BYTE OFFSET IN PAGE
	MOVZWL	CDRP$W_BCNT(R5),R2	; R2=TRANSFER BYTE COUNT
	MOVAB	CDRP$L_UBARSRCE(R5),R0	; R0 => MAPPING RESOURCE DESCRIPTOR
	EXTZV	#VEC$V_DATAPATH,-	; GET DATAPATH
		#VEC$S_DATAPATH,-	; NUMBER
		UBMD$B_DATAPATH(R0),R4

	BLBC	R1,10$			;IF LBC WORD ALIGNED TRANSFER
	BISB	#^X10,R4		;SET BYTE OFFSET BIT
10$:	BISW	#^X400,R4		;MERGE VALID WITH BYTE OFFSET AND DATAPATH
	MOVAB	^X1FF(R2)[R1],R2	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R2,R2		;CALCULATE NUMBER OF MAP REGISTERS TO LOAD

	CMPB	R2,UBMD$B_NUMREG(R0)	;ENOUGH MAP REGISTERS ASSIGNED?
	BGEQU	40$			;IF GEQU NO

	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	MOVL	UCB$L_CRB(R3),R3	; R3 => CRB.

	ASSUME	ADP$L_CSR	EQ	0
	MOVL	@CRB$L_INTD+VEC$L_ADP(R3),R1	; R1 => UBA CSR.
	EXTZV	#VEC$V_MAPREG,-			; GET STARTING REGISTER
		#VEC$S_MAPREG,-
		UBMD$W_MAPREG(R0),R0

	MOVAL	UBA$L_MAP(R1)[R0],R1	;GET ADDRESS OF FIRST MAP REGISTER TO LOAD
	MOVL	CDRP$L_SVAPTE(R5),R0	;GET ADDRESS OF PAGE TABLE
20$:	MOVL	(R0)+,R3		;GET NEXT PAGE TABLE ENTRY
	BLSS	30$			;IF LSS VALID PAGE TABLE ENTRY
	BSBW	IOC$PTETOPFN		;GET PFN FROM INVALID PTE
30$:	INSV	R4,#21,#11,R3		;INSERT VALID, BYTE OFFSET, AND DATAPATH
	MOVL	R3,(R1)+		;LOAD UBA MAP REGISTER
	SOBGTR	R2,20$			;ANY MORE TO LOAD?
	CLRL	(R1)			;LOAD INVALID MAP ENTRY
	MOVQ	(SP)+,R3		;RESTORE REGISTERS
	RSB				;
40$:	BUG_CHECK UBMAPEXCED,FATAL	;UNIBUS MAP REGISTER ALLOCATION EXCEEDED
	.END
