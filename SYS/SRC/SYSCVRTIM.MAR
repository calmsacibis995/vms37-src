	.TITLE	SYSCVRTIM - SYSTEM SERVICES TO CONVERT TIME
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 6-JAN-76
;
; SYSTEM SERVICES TO CONVERT TIME
;
;	CONVERT BINARY TIME TO ASCII STRING
;	CONVERT ASCII STRING TO BINARY TIME
;	CONVERT BINARY TIME TO NUMERIC FORMAT
;
;	THE CONVERSION ALGORITHMS USED HEREIN WERE DEVELOPED BY P. CONKLIN,
;	M. SPIER, AND D. ROSENBERY ON THE PDP-10.
;
; MODIFIED BY:
;
;	V03-001	KDM0086		Kathleen D. Morse	02-Apr-1982
;		Correctly acquire system time, even in case where
;		secondary processor is accessing EXE$GQ_SYSTIME while
;		the primary processor is updating it (11/782 case).
;
;	V02-004	ROW37307	Ralph O. Weber		27-Jul-1981
;		Fix EXE$BINTIM to treat decimal point preceeding hundredths of 
;		a second field as a true decimal point.  IE: to cause 0:0:0.1 
;		to convert to 1 tenth of a second rather than to 1 hundredth 
;		of a second.  Also allow indefinite length fractional value 
;		fields.  Use the thousandths digit to round the hundredths 
;		value, and ignore all digits following the thousandths digit.  
;		The entire field, upto the first trailing blank, is still 
;		processed.  Therefore, non-numeric characters in the 
;		fractional seconds field will still produce an Invalid Time 
;		return code.
;
;	V02-003	TCM0001		Trudy C. Matthews	03-Jun-1981
;		Fix CONVERT subroutine in EXE$BINTIM to ignore blanks.  This
;		fix allows trailing blanks after a truncated time field.
;
;
;
; MACRO LIBRARY CALLS
;
 
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINTIONS FOR CONVERT BINARY TIME TO ASCII STRING
;
 
ATIMLEN=4				;ADDRESS OF WORD TO STORE LENGTH
ATIMBUF=8				;ADDRESS OF OUTPUT BUFFER DESCRIPTOR
ATIMADR=12				;ADDRESS OF 64-BIT ABSOLUTE OR DELTA TIME
ACVTFLG=16				;CONVERSION INDICATOR
 
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR CONVERT ASCII STRING TO BINARY TIME
;
 
BTIMBUF=4				;ADDRESS OF ASCII STRING DESCRIPTOR
BTIMADR=8				;ADDRESS TO STORE 64-BIT ABSOLUTE OR DELTA TIME
 
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR CONVERT BINARY TIME TO NUMERIC TIME
;
 
NTIMBUF=4				;ADDRESS OF 7-WORD BUFFER TO RECEIVE TIME
NTIMADR=8				;ADDRESS OF 64-BIT ABSOLUTE OR DELTA TIME
 
;
; CONVERSION CONSTANTS
;
; TOTAL DAYS IN A CENTURY
;
 
CENTURYDAYS=<100*365>+<100/4>-<100/100>	;
 
;
; AVERAGE QUARTER DAYS PER CENTURY
;
 
QDAYSPCENT=<<<100*365>+<100/4>-<100/100>>*4>+<400/400> ;
 
;
; AVERAGE QUARTER DAYS PER YEAR
;
 
QDAYSPYEAR=<365*4>+1			;
 
;
; TOTAL DAYS IN A QUADRICENTURY
;
 
QUADRIDAYS=<400*365>+<400/4>-<400/100>+<400/400> ;
 
;
; TOTAL DAYS IN A QUADYEAR
;
 
QUADYEARDAYS=<365*4>+1			;
 
;
; OFFSET IN DAYS FROM 1-JAN-1501 TO 17-NOV-1858
;
 
TIMOFF1=<<1858-1501>*365>+<<1858-1501>/4>-<<1858-1501>/100>+<<1858-1501>/400>+ -;
       31+28+31+30+31+30+31+31+30+31+17 ;
 
;
; OFFSET IN DAYS FROM 1-JAN-1601 TO 17-NOV-1858
;
 
TIMOFF2=<<1858-1601>*365>+<<1858-1601>/4>-<<1858-1601>/100>+<<1858-1601>/400>+ -;
       31+28+31+30+31+30+31+31+30+31+17 ;
 
;
; CHARACTER CODE DEFINITIONS
;
 
BLANK=32				;
COLON=58				;
HYPHEN=45				;
NINE=57					;
ONE=48					;
PERIOD=46				;
 
;
; NUMERIC TIME BUFFER OFFSET DEFINITIONS
;
 
YEAR=0					;
MONTH=2					;
DAY=4					;
HOUR=6					;
MINUTE=8				;
SECOND=10				;
HUNDREDTH=12				;
 
;
; LOCAL DATA
;
; MONTH, DAY CONVERSION TABLE
;
	.PSECT	Y$EXEPAGED
DATETABLE:				;DATE CONVERSION TABLE
	.BYTE	31			;JANUARY
	.BYTE	29			;FEBRUARY
	.BYTE	31			;MARCH
	.BYTE	30			;APRIL
	.BYTE	31			;MAY
	.BYTE	30			;JUNE
	.BYTE	31			;JULY
	.BYTE	31			;AUGUST
	.BYTE	30			;SEPTEMBER
	.BYTE	31			;OCTOBER
	.BYTE	30			;NOVEMBER
	.BYTE	31			;DECEMBER
 
;
; MONTH CONVERSION TABLE
;
 
MONTHTAB:				;
	.ASCII	<3>/JAN/		;
	.ASCII	<3>/FEB/		;
	.ASCII	<3>/MAR/		;
	.ASCII	<3>/APR/		;
	.ASCII	<3>/MAY/		;
	.ASCII	<3>/JUN/		;
	.ASCII	<3>/JUL/		;
	.ASCII	<3>/AUG/		;
	.ASCII	<3>/SEP/		;
	.ASCII	<3>/OCT/		;
	.ASCII	<3>/NOV/		;
	.ASCII	<3>/DEC/		;
 
;
; HOURS, MINUTES, SECONDS, HUNDREDTHS CONVERSION TABLE
;
 
TIMETABLE:				;TIME CONVERSION TABLE
	.BYTE	100			;HUNDREDTHS
	.BYTE	60			;SECONDS
	.BYTE	60			;MINUTES AND HOURS
 
;
; CONVERSION CONTROL STRINGS
;
 
DATE:	.ASCII	/!2SW-!AC-!4ZW /	;
DELTA:	.ASCII	/!4SW /			;
TIME:	.ASCII	/!2ZW:!2ZW:!2ZW.!2ZW/	;
	.PAGE
	.SBTTL	CONVERT BINARY TIME TO ASCII STRING
;+
; EXE$ASCTIM - CONVERT BINARY TIME TO ASCII STRING
;
; THIS SERVICE PROVIDES THE CAPABILITY TO CONVERT AN ABSOLUTE OR DELTA
; TIME FROM 64-BIT FORMAT TO AN ASCII STRING.
;
; INPUTS:
;
;	ATIMLEN(AP) = ADDRESS OF WORD TO RECEIVE OUTPUT LENGTH.
;	ATIMBUF(AP) = ADDRESS OF OUTPUT BUFFER DESCRIPTOR.
;	ATIMADR(AP) = ADDRESS OF 64-BIT TIME VALUE. IF ZERO, THEN THE CURRENT
;		SYSTEM TIME IS USED. POSITIVE VALUES ARE INTERPRETED AS
;		ABSOLUTE TIMES AND NEGATIVE VALUES AS DELTA TIMES.
;	ACVTFLG(AP) = CONVERSION INDICATOR.
;		LOW BIT CLEAR INDICATES BOTH DATE AND TIME ARE TO BE CON-
;			VERTED.
;		LOW BIT SET INDICATES ONLY TIME IS TO BE CONVERTED.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CONVERT TIME TO ASCII.
;
;		R0 = SS$_ACCVIO - 64-BIT TIME VALUE OR OUTPUT BUFFER DESCRIPTOR
;			CANNOT BE READ BY CALLING ACCESS MODE, OR OUTPUT BUFFER
;			CANNOT BE WRITTEN BY CALLING ACCESS MODE.
;
;		R0 = SS$_IVTIME - SPECIFIED DELTA TIME IS GREATER THAN 9999
;			DAYS.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
EXE$ASCTIM::				;CONVERT TIME TO ASCII
	.WORD	^M<R2,R3,R4,R5,R6>	;ENTRY MASK
	MOVQ	@ATIMBUF(AP),-(SP)	;SAVE OUTPUT BUFFER DESCRIPTOR
	MOVL	SP,R6			;SAVE ADDRESS OF OUTPUT BUFFER DESCRIPTOR
	CLRL	-(SP)			;CLEAR SPACE FOR LENGTH FROM FAO
	MOVL	SP,R5			;SAVE ADDRESS OF LENGTH
	CLRL	R2			;ASSUME ABSOLUTE TIME SPECIFIED
	MOVL	ATIMADR(AP),R3		;GET ADDRESS OF 64-BIT TIME VALUE
	BEQL	10$			;IF EQL NONE SPECIFIED
	MOVQ	(R3),R0			;GET 64-BIT TIME VALUE
	BGEQ	10$			;IF GEQ ABSOLUTE TIME
	INCL	R2			;INDICATE DELTA TIME
10$:	SUBL	#<<<7*2>+3>/4>*4,SP	;ALLOCATE NUMERIC TIME BUFFER
	MOVL	SP,R4			;SAVE ADDRESS OF NUMERIC TIME BUFFER
	$NUMTIM_S (R4),(R3)		;CONVERT TIME TO NUMERIC FORMAT
	BLBC	R0,60$			;IF LBC CONVERSION FAILURE
	
;
; CONVERT TIME TO ASCII FORMAT
;
 
	BLBS	ACVTFLG(AP),40$		;IF LBS ONLY TIME IS TO BE CONVERTED
	BLBS	R2,20$			;IF LBS DELTA TIME SPECIFIED
 
;
; CONVERT DATE
;
 
	MOVZWL	MONTH(R4),R2		;GET NUMERIC MONTH VALUE
	MOVAL	W^MONTHTAB-4[R2],R2	;GET ADDRESS OF MONTH COUNTED STRING
	PUSHAL	W^DATE			;BUILD DESCRIPTOR FOR CONTROL STRING
	PUSHL	#DELTA-DATE		;
	BRB	30$			;
 
;
; CONVERT DELTA TIME
;
 
20$:	PUSHAL	W^DELTA			;BUILD CONTROL STRING DESCRIPTOR
	PUSHL	#TIME-DELTA		;
30$:	MOVL	SP,R1			;COPY ADDRESS OF CONTROL STRING DESCRIPTOR
	$FAO_S	(R1),(R5),(R6),DAY(R4),R2,YEAR(R4) ;CONVERT DELTA TIME OR DATE
	BLBC	R0,60$			;IF LBC CONVERT FAILURE
	SUBW	(R5),(R6)		;ANY SPACE LEFT IN TIME BUFFER?
	BLEQ	50$			;IF LEQ NO
	ADDL	(R5),4(R6)		;UPDATE TIME BUFFER ADDRESS
 
;
; CONVERT TIME
;
 
40$:	PUSHAL	W^TIME			;BUILD CONTROL STRING DESCRIPTOR
	PUSHL	#EXE$ASCTIM-TIME	;
	MOVL	SP,R1			;COPY ADDRESS OF CONTROL STRING DESCRIPTOR
	$FAO_S	(R1),2(R5),(R6),HOUR(R4),MINUTE(R4),SECOND(R4),HUNDREDTH(R4) ;
50$:	MOVL	ATIMLEN(AP),R1		;LENGTH ADDRESS SPECIFIED?
	BEQL	60$			;IF EQL NO
	ADDW3	(R5)+,(R5),(R1)		;COMPUTE AND RETURN OUTPUT LENGTH
60$:	RET				;
	.PAGE
	.SBTTL	CONVERT ASCII STRING TO BINARY TIME
;+
; EXE$BINTIM - CONVERT ASCII STRING TO BINARY TIME
;
; THIS SERVICE PROVIDES THE CAPABILITY TO CONVERT AN ASCII STRING TO A
; 64-BIT ABSOLUTE OR DELTA TIME.
;
; INPUTS:
;
;	BTIMBUF(AP) = ADDRESS OF ASCII STRING DESCRIPTOR.
;	BTIMADR(AP) = ADDRESS TO STORE 64-BIT TIME VALUE.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CONVERT TIME TO ASCII.
;
;		R0 = SS$_IVTIME - ASCII STRING HAS INVALID SYNTAX OR TIME
;			COMPONENT IS OUT OF RANGE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
EXE$BINTIM::				;CONVERT ASCII STRING TO BINARY TIME
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8> ;ENTRY MASK
	SUBL	#<<<7*2>+3>/4>*4,SP	;ALLOCATE NUMERIC TIME BUFFER
	MOVL	SP,R7			;SAVE ADDRESS OF NUMERIC TIME BUFFER
	MOVQ	@BTIMBUF(AP),R5		;GET ADDRESS AND LENGTH OF ASCII STRING
	CLRL	R8			;ASSUME DELTA TIME
10$:	DECW	R5			;ANY MORE CHARACTERS?
	BLSS	30$			;IF LSS NO
	CMPB	#BLANK,(R6)+		;SKIP LEADING BLANK?
	BEQL	10$			;IF EQL YES
	INCW	R5			;CORRECT NUMBER OF CHARACTERS
	LOCC	#HYPHEN,R5,-(R6)	;ABSOLUTE TIME FORMAT?
	BEQL	30$			;IF EQL NO
	INCL	R8			;INDICATE ABSOLUTE TIME
	$NUMTIM_S (R7)			;CONVERT CURRENT TIME TO NUMERIC FORMAT
 
;
; CONVERT ABSOLUTE TIME
;
 
	MOVAL	DAY(R7),R4		;SET ADDRESS TO STORE DAY
	BSBW	CONVERT			;CONVERT DAY FIELD
	.BYTE	HYPHEN			;EXPECTED TERMINATOR
	TSTW	R5			;ANY MORE CHARACTERS?
	BNEQ	11$			;BRNCH IF THERE ARE MORE CHARACTERS.
	BRW	CVRTIME			;IF NO MORE CHARACTERS, CONVERT TIME.
11$:	CMPB	#HYPHEN,(R6)+		;MONTH FIELD VOID?
	BEQL	20$			;IF EQL YES
	MATCHC	#3,-(R6),#4*12,W^MONTHTAB ;SEARCH FOR MONTH SUBSTRING MATCH
	BEQL	14$			;SKIP ERROR BRANCH IF MATCH FOUND
	BRW	IVTIME			;IF NEQ NO MATCH FOUND
14$:	SUBL3	R2,#4*12,R2		;CALCULATE CHARACTERS TO START OF SUBSTRING + 4
	BITL	#3,R2			;MULTIPLE OF 4?
	BEQL	16$			;BRANCH IF MULTIPLE OF 4
	BRW	IVTIME			;IF NOT MULTIPLE OF 4, THEN ERROR
16$: 	DIVW3	#4,R2,MONTH(R7)		;CONVERT TO MONTH AND STORE
	ADDL	#3,R6			;UPDATE ADDRESS OF ASCII STRING
	SUBW	#3,R5			;UPDATE COUNT OF REMAINING CHARACTERS
	BLSS	IVTIME			;IF LSS INVALID SYNTAX
	BGTR	18$			;IF GTR CHARACTERS REMAINING
	BRW	CVRTIME			;OTHERWISE END OF STRING
18$:	CMPB	#HYPHEN,(R6)+		;FIELD TERMINATED PROPERLY?
	BNEQ	IVTIME			;IF NEQ NO
20$:	DECW	R5			;DECREMENT COUNT OF REMAINING CHARACTERS
	MOVAL	YEAR(R7),R4		;SET ADDRESS TO STORE YEAR
	BRB	40$			;
 
;
; CONVERT DELTA TIME
;
 
30$:	MOVAL	YEAR(R7),R4		;GET ADDRESS TO STORE YEAR
	CLRL	(R4)+			;CLEAR YEAR AND MONTH
	CLRQ	(R4)			;CLEAR DAY, HOUR, MINUTE, AND SECOND
	CLRW	HUNDREDTH(R7)		;CLEAR HUNDREDTH
40$:	BSBB	CONVERT			;CONVERT RELATIVE DAY OR YEAR FIELD
	.BYTE	BLANK			;EXPECTED TERMINATOR
50$:	DECW	R5			;ANY REMAINING CHARACTERS?
	BGEQ	53$			;BRANCH IF CHARACTERS REMAINING
	BRW	CVRTIME			;ELSE GO PROCESS WHAT WE'VE GOT
53$:	CMPB	#BLANK,(R6)+		;NEXT CHARACTER BLANK?
	BEQL	50$			;IF EQL YES
	DECL	R6			;BACK UP TO NONBLANK CHARACTER
	INCL	R5			;ADJUST REMAINING CHARACTER COUNT
 
;
; CONVERT TIME
;
 
	MOVAL	HOUR(R7),R4		;SET ADDRESS TO STORE HOUR
	BSBB	CONVERT			;CONVERT HOUR FIELD
	.BYTE	COLON			;EXPECTED TERMINATOR
	BSBB	CONVERT			;CONVERT MINUTE FIELD
	.BYTE	COLON			;EXPECTED TERMINATOR
	BSBB	CONVERT			;CONVERT SECOND FIELD
	.BYTE	PERIOD			;EXPECTED TERMINATOR

					;Convert Hundredth Field
					;This must be done differently because
					;this is a fractional value.
					;Establish max useable digits,
	MOVL	#3, R3			;including the rounding digit.
	CLRW	(R4)			;Clear accumulated value.
70$:	DECW	R5			;Any more characters?
	BLSS	80$			;Branch if no more characters.
	MOVZBL	(R6)+, R1		;Get the next character.
	CMPB	R1, #BLANK		;A blank marks the end of the field.
	BEQL	80$			;Branch if at end of the field.
	SUBL	#ONE, R1		;Subtract out character bias.
	BLSS	IVTIME			;Branch if invalid character.
	CMPL	#NINE-ONE, R1		;Result value within digit range?
	BLSS	IVTIME			;Branch if invalid character.
	SOBGTR	R3, 73$			;Branch if using this digit directly.
	BLSS	70$			;Branch if ignoring this digit.
	CMPL	#5, R1			;Else digit as the rounding digit.
	BGTR	70$			;Branch if rounding has no effect.
	INCW	(R4)			;If rounding up, do it.
	BRB	70$			;Then loop, but for a regular digit, 
73$:	MULW	#10, (R4)		;multiply partial result by 10.
	BVS	IVTIME			;An overflow means an invalid time.
	ADDW	R1, (R4)		;Accumulate fracitonal value.
	BVS	IVTIME			;Overflow means invalid time.
	BRB	70$			;Loop till end occurs.

80$:	DECL	R3			;Insure that truncated digits are
	BLEQ	CVRTIME			;included as zeros in the final
	MULW	#10, (R4)		;fractional (hundredths) field value.
	BRB	80$			;NB: this will always overflow a word
					;if the fractional field has a
					;resolution greater than thousandths.
;
; INVALID SYNTAX OR TIME COMPONENT
;

IVTIME:	MOVZWL	#SS$_IVTIME,R0		;SET INVALID TIME
	RET

;
; SUBROUTINE TO CONVERT NUMERIC FIELD TO BINARY
;
 
CONVERT:				;CONVERT FIELD
	CLRL	R0			;CLEAR ACCUMULATED VALUE
10$:	TSTW	(R4)+			;POINT PAST NEXT FIELD
11$:	DECW	R5			;ANY MORE CHARACTERS?
	BLSS	CVRTIME			;IF LSS NO
	MOVZBL	(R6)+,R1		;GET NEXT CHARACTER
	CMPB	R1,@(SP)		;EXPECTED TERMINATOR?
	BEQL	20$			;IF EQL YES
	CMPB	R1,#BLANK		;BLANK CHARACTER?
	BEQL	11$			;IGNORE BLANKS
	SUBL	#ONE,R1			;SUBTRACT OUT CHARACTER BIAS
	BLSS	IVTIME			;IF LSS INVALID CHARACTER
	CMPL	#NINE-ONE,R1		;RESULT VALUE WITHIN RANGE?
	BLSS	IVTIME			;IF LSS INVALID CHARACTER
	MULW	#10,R0			;MULTIPLY PARTIAL RESULT BY 10
	BVS	IVTIME			;IF VS INVALID TIME
	ADDW	R1,R0			;ACCUMULATE VALUE
	BVS	IVTIME			;IF VS INVALID TIME VALUE
	MOVW	R0,-(R4)		;STORE VALUE
	BRB	10$			;
20$:	INCL	(SP)			;INCREMENT PAST TERMINATOR
	RSB				;
 
;
; CHECK CONVERTED DATE AND TIME VALUES
;
 
CVRTIME:				;
	CMPW	#9999,DAY(R7)		;DAY WITHIN UPPER LIMIT?
	BLSSU	IVTIME			;IF LSSU NO
	CMPW	#24,HOUR(R7)		;HOUR WITHIN LIMITS?
	BLEQU	IVTIME			;IF LEQU NO
	CMPW	#60,MINUTE(R7)		;MINUTE WITHIN LIMITS?
	BLEQU	IVTIME			;IF LEQU NO
	CMPW	#60,SECOND(R7)		;SECOND WITHIN LIMITS?
	BLEQU	IVTIME			;IF LEQU NO
	MOVZWL	DAY(R7),R5		;GET DAY VALUE
	BLBS	R8,5$			;IF LBS ABSOLUTE TIME
	BRW	40$			;
 
;
; CONVERT YEARS TO QUADRICENTURIES, CENTURIES, QUADYEARS, YEARS
;
 
5$:	BEQL	IVTIME			;IF EQL INVALID TIME
	MOVZWL	YEAR(R7),R0		;GET YEAR VALUE
	MOVAW	-1601(R0),R0		;CALCULATE YEARS PAST 1601
	BLSS	IVTIME			;IF LSS INVALID TIME
	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#400,R0,R0,R1		;CALCULATE QUADRICENTURIES
	CLRL	R2			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#100,R1,R1,R2		;CALCULATE CENTURIES
	CLRL	R3			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#4,R2,R2,R3		;CALCULATE QUADYEARS AND YEARS
 
;
; CONVERT QUADRICENTURIES, CENTURIES, QUADYEARS, YEARS TO DAYS
;
 
	MULW	#365,R3			;CALCULATE NUMBER OF DAYS PAST LEAP YEAR
	EMUL	#QUADYEARDAYS,R2,R3,R2	;CALCULATE NUMBER OF QUADYEAR DAYS AND SUM
	MULL	#CENTURYDAYS,R1		;CALCULATE NUMBER OF CENTURY DAYS
	EMUL	#QUADRIDAYS,R0,R1,R5	;CALCULATE NUMBER OF QUADRIDAYS AND SUM
	CLRL	R0			;CLEAR INITIAL LOOP INDEX
	MOVZWL	MONTH(R7),R6		;GET SPECIFIED MONTH VALUE
10$:	ADDL	R2,R5			;ACCUMULATE TOTAL DAYS
	MOVZBL	W^DATETABLE[R0],R2	;GET NUMBER OF DAYS IN MONTH
	CMPL	#1,R0			;SECOND MONTH OF YEAR?
	BNEQ	30$			;IF NEQ NO
	MOVZWL	YEAR(R7),R3		;GET SPECIFIED YEAR VALUE
	BITL	#3,R3			;YEAR MULTIPLE OF 4?
	BNEQ	20$			;IF NEQ NO
	CLRL	R4			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#100,R3,R3,R4		;CALCULATE CENTURY AND YEAR IN CENTURY
	TSTL	R4			;YEAR MULTIPLE OF 100?
	BNEQ	30$			;IF NEQ NO
	BITL	#3,R3			;YEAR MULTIPLE OF 400?
	BEQL	30$			;IF EQL YES
20$:	DECL	R2			;REDUCE NUMBER OF DAYS IN MONTH
30$:	AOBLSS	R6,R0,10$		;ANY MORE DAYS TO ACCUMULATE?
	MOVZWL	#SS$_IVTIME,R0		;ASSUME INVALID DAY OF MONTH
	MOVZWL	DAY(R7),R1		;GET SPECIFIED DAY
	SUBL	#TIMOFF2,R5		;SUBTRACT OUT NUMBER OF DAYS TO 17-NOV-1858
	ADDL	R1,R5			;CALCULATE TOTAL NUMBER OF DAYS
	BLSS	60$			;IF LSS INVALID TIME
	CMPL	R1,R2			;DAY WITHIN LIMITS?
	BGTRU	60$			;IF GTRU NO
 
;
; CONVERT TIME TO TENTHS OF MICROSECONDS
;
 
40$:	MOVZWL	HOUR(R7),R0		;GET HOUR VALUE
	MOVZWL	MINUTE(R7),R1		;GET MINUTE VALUE
	EMUL	#60,R0,R1,R0		;CONVERT HOURS TO MINUTES AND SUM
	MOVZWL	SECOND(R7),R1		;GET SECOND VALUE
	EMUL	#60,R0,R1,R0		;CONVERT MINUTES TO SECONDS AND SUM
	MOVZWL	HUNDREDTH(R7),R1	;GET HUNDREDTH VALUE
	EMUL	#100,R0,R1,R0		;CONVERT SECONDS TO HUNDREDTHS AND SUM
	EMUL	#100000,R0,#0,R0	;CONVERT TO TENTHS OF MICROSECONDS
 
;
; CONVERT DAYS TO TENTHS OF MICROSECONDS
;
 
	EMUL	#843750000,R5,#0,R2	;MULTIPLY BY 864000000000/1024
	ASHQ	#10,R2,R2		;MULTIPLY BY 1024
 
;
; COMBINE RESULTS AND STORE 64-BIT TIME
;
 
	ADDL	R0,R2			;ADD LOW ORDER PARTS
	ADWC	R1,R3			;ADD HIGH ORDER PARTS
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION
	BLBS	R8,50$			;IF LBS ABSOLUTE TIME
	MNEGL	R3,R3			;CONVERT TO DELTA TIME
	MNEGL	R2,R2			;
	SBWC	#0,R3			;
50$:	MOVQ	R2,@BTIMADR(AP)		;STORE 64-BIT TIME VALUE
60$:	RET				;
	.PAGE
	.SBTTL	CONVERT BINARY TIME TO NUMERIC TIME
;+
; EXE$NUMTIM - CONVERT BINARY TIME TO NUMERIC TIME
;
; THIS SERVICE PROVIDES THE CAPABILITY TO CONVERT AN ABSOLUTE OR DELTA TIME
; FROM 64-BIT FORMAT TO INTEGER DATE AND TIME VALUES.
;
; INPUTS:
;
;	NTIMBUF(AP) = ADDRESS OF 7-WORD BUFFER TO RECEIVE CONVERTED DATE AND
;		TIME VALUES.
;	NTIMADR(AP) = ADDRESS OF 64-BIT TIME VALUE. IF ZERO, THEN THE CURRENT
;		SYSTEM TIME IS USED. POSITIVE VALUES ARE INTERPRETED AS
;		ABSOLUTE TIMES AND NEGATIVE VALUES AS DELTA TIMES.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CONVERT TO NUMERIC TIME.
;
;		R0 = SS$_ACCVIO - 64-BIT TIME VALUE CANNOT BE READ BY CALLING
;			ACCESS MODE OR TIME BUFFER CANNOT BE WRITTEN BY
;			CALLING ACCESS MODE.
;
;		R0 = SS$_IVTIME - SPECIFIED DELTA TIME IS GREATER THAN 9999
;			DAYS.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
EXE$NUMTIM::				;CONVERT TO NUMERIC TIME
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;ENTRY MASK
	MOVL	NTIMBUF(AP),R7		;GET ADDRESS OF 7-WORD TIME BUFFER
	IFNOWRT	#7*2,(R7),10$		;CAN TIME BUFFER BE WRITTEN?
	MOVZWL	#SS$_NORMAL,R0		;ASSUME NORMAL COMPLETION
5$:	MOVQ	EXE$GQ_SYSTIME,R1	;ASSUME TIME NOT SPECIFIED
	CMPL	EXE$GQ_SYSTIME,R1	;VERIFY THAT THE VALUE ACQUIRED
	BNEQ	5$			; WAS NOT BEING MODIFIED DURING
	CMPL	EXE$GQ_SYSTIME+4,R2	; THE ACQUISITION. THIS SYNCHS ACCESS BY
	BNEQ	5$			; THE SECONDARY IN THE 11/782 SYSTEM.
	MOVL	NTIMADR(AP),R3		;GET ADDRESS OF 64-TIME VALUE
	BEQL	20$			;IF EQL NONE SPECIFIED
	IFNORD	#8,(R3),10$		;CAN 64-BIT TIME VALUE BE READ?
	MOVQ	(R3),R1			;GET 64-BIT TIME VALUE
	BGEQ	20$			;IF GEQ ABSOLUTE TIME
	MNEGL	R2,R2			;NEGATE DELTA TIME VALUE
	MNEGL	R1,R1			;
	SBWC	#0,R2			;
	BBSC	#0,R0,20$		;INDICATE DELTA TIME VALUE
10$:	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION
	RET				;
 
;
; R1 AND R2 CONTAIN 64-BIT ABSOLUTE TIME VALUE IN UNITS OF TENTHS OF MICRO-
; SECONDS. CALCULATE DAYS PAST BASE TIME AND FRACTION OF DAY BY DIVIDING
; BY 864000000000 WHICH IS THE NUMBER OF TENTHS OF MICROSECONDS IN A DAY.
; THE DIVISION IS PERFORMED IN THREE STEPS TO INSURE BOTH QUOTIENT AND
; REMAINDER STAY WITHIN 32 BITS.
;
; CALCULATE DAYS BY DIVIDING BY 1024 AND THEN 843750000. QUOTIENT IS DAYS
; AND REMAINDER IS FRACTION OF DAY.
;
 
20$:	EXTZV	#0,#10,R1,R4		;SAVE REMAINDER FROM NEXT DIVIDE
	ASHQ	#-10,R1,R1		;DIVIDE BY 1024
	EDIV	#843750000,R1,R1,R2	;CALCULATE DAYS AND FRACTION OF DAY
 
;
; R1 CONTAINS DAYS PAST BASE TIME, R2 PLUS R4 CONTAIN FRACTION OF DAY.
; R2 CONTAINS PART OF FRACTION IN UNITS OF 864000000000/1024 AND
; R4 CONTAINS REMAINDER IN UNITS OF TENTHS OF MICROSECONDS.
;
; CALCULATE FRACTION OF DAY IN HUNDREDTHS OF SECONDS BY DIVIDING BY 
; 100000 WHICH IS THE NUMBER OF TENTHS OF MICROSECONDS IN A HUNDRETH
; OF A SECOND.
;
 
	CLRL	R3			;CLEAR HIGH PART OF DIVIDEND
	ASHQ	#10,R2,R2		;CONVERT BACK TO TENTHS OF MICROSECONDS
	BISL	R4,R2			;ADD REMAINDER BACK
	EDIV	#100000,R2,R5,R2	;CALCULATE FRACTION OF DAY IN HUNDREDTHS
 
;
; R1 CONTAINS DAYS PAST THE BASE TIME AND R5 CONTAINS THE FRACTION OF DAY
; IN HUNDREDTHS OF A SECOND.
;
 
	BBCS	#0,R0,70$		;IF CLR, DELTA TIME SPECIFIED
 
;
; ADD TIME OFFSET SO THAT DAY IS RELATIVE TO 1-JAN-1501.
;
 
	ADDL	#TIMOFF1,R1		;ADD TIME OFFSET
 
;
; CALCULATE NUMBER OF QUADRICENTURIES THAT HAVE PAST SINCE 1501.
;
 
	CLRL	R2			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#QUADRIDAYS,R1,R1,R2	;CALCULATE NUMBER OF QUADRICENTURIES
 
;
; R1 CONTAINS THE NUMBER OF QUADRICENTURIES AND R2 CONTAINS THE NUMBER OF
; DAYS INTO THE NEXT QUADRICENTURY. CALCULATE THE NUMBER OF CENTURIES BY
; CONVERTING TO QUARTER DAYS INTO NEXT QUADRICENTURY AND THEN DIVIDING BY
; THE AVERAGE NUMBER OF QUARTER DAYS IN A CENTURY.
;
 
	MULL	#4,R2			;CALCULATE NUMBER OF QUARTER DAYS
	CLRL	R3			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#QDAYSPCENT,R2,R2,R3	;CALCULATE NUMBER OF CENTURIES
 
;
; R2 CONTAINS THE NUMBER OF CENTURIES AND R3 CONTAINS THE NUMBER OF QUARTER
; DAYS INTO THE NEXT CENTURY.
;
; CALCULATE YEARS BY DISCARDING ANY FRACTION OF A DAY, ADDING 3/4'THS OF A
; DAY, AND DIVIDING BY THE AVERAGE NUMBER OF DAYS IN A YEAR. THE LEAP DAY
; OF EACH FOUR YEAR CYCLE IS FORCED INTO THE FOURTH YEAR.
;
 
	CLRL	R4			;CLEAR HIGH PART OF DIVIDEND
	BISL	#3,R3			;TRUNCATE FRACTION AND ADD 3/4'THS OF DAY
	EDIV	#QDAYSPYEAR,R3,R3,R4	;CALCULATE NUMBER OF YEARS
	DIVL	#4,R4			;CALCULATE NUMBER OF DAYS MINUS ONE
	INCL	R4			;CONVERT TO ACTUAL JULIAN DAY OF YEAR
 
;
; R1 CONTAINS NUMBER OF QUADRICENTURIES.
; R2 CONTAINS NUMBER OF CENTURIES.
; R3 CONTAINS NUMBER OF YEARS.
; R4 CONTAINS JULIAN DAY OF YEAR.
;
; CALCULATE ACTUAL YEAR.
;
 
	MOVAL	(R2)[R1],R1		;COMBINE CENTURIES AND QUADRICENTURIES
	MULL	#50,R1			;CALCULATE NUMBER OF DOUBLE CENTURIES
	MOVAW	1501(R3)[R1],R1		;CALCULATE ACTUAL YEAR
	MOVW	R1,(R7)+		;STORE YEAR
 
;
; TEST FOR NONLEAP YEAR AND BIAS DAY IF AFTER 28-FEB.
;
 
	BITL	#3,R1			;YEAR MULTIPLE OF 4?
	BNEQ	30$			;IF NEQ NO
	CLRL	R2			;CLEAR HIGH PART OF DIVIDEND
	EDIV	#100,R1,R1,R2		;CALCULATE CENTURY AND YEAR IN CENTURY
	TSTL	R2			;YEAR MULTIPLE OF 100?
	BNEQ	40$			;IF NEQ NO
	BITL	#3,R1			;YEAR MULTIPLE OF 400?
	BEQL	40$			;IF EQL YES
30$:	CMPL	#31+28,R4		;AFTER 28-FEB?
	BGEQ	40$			;IF GEQ NO
	INCL	R4			;ADJUST FOR TABLE BIAS
40$:	MOVL	#1,R1			;INITIALIZE MONTH
50$:	MOVZBL	W^DATETABLE-1[R1],R2	;GET NUMBER OF DAYS IN MONTH
	SUBL	R2,R4			;SUBTRACT FROM JULIAN DAY
	BLEQ	60$			;IF LEQ CORRECT MONTH FOUND
	AOBLEQ	#12,R1,50$		;LOOP THROUGH ALL MONTHS
60$:	MOVW	R1,(R7)+		;STORE MONTH
	ADDW3	R2,R4,(R7)+		;STORE DAY
	BRB	80$			;
 
;
; DELTA TIME SPECIFIED - STORE RELATIVE DAY
;
 
70$:	CLRL	(R7)+			;CLEAR YEAR AND MONTH
	MOVW	R1,(R7)+		;STORE DAY
	CMPL	#10000,R1		;RELATIVE DAY WITHIN LIMITS?
	BGTRU	80$			;IF GTRU YES
	MOVZWL	#SS$_IVTIME,R0		;SET INVALID TIME
	RET				;
 
;
; R5 CONTAINS FRACTION OF DAY IN HUNDREDTHS OF SECONDS.
;
; CALCULATE HOUR, MINUTE, SECOND, AND HUNDREDTH OF SECOND.
;
 
80$:	ADDL	#8,R7			;POINT TWO BYTES PAST END OF BUFFER
	CLRL	R1			;CLEAR LOOP INDEX
90$:	MOVZBL	W^TIMETABLE[R1],R2	;GET NEXT UNIT DIVISOR
	CLRL	R6			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R2,R5,R5,R6		;CALCULATE NEXT PART
	MOVW	R6,-(R7)		;STORE NEXT PART
	AOBLEQ	#2,R1,90$		;LOOP FOR HUNDREDTHS, SECONDS, AND MINUTES
	MOVW	R5,-(R7)		;STORE HOUR
	RET				;
 
	.END
