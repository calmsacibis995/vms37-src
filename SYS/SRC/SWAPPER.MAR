	.TITLE	SWAPPER  WORKING SET SWAPPER 
	.IDENT	'V03-003'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SWAPPER
;
; ABSTRACT: THE SWAPPER SCHEDULES AND EXECUTES SWAPPING OF PROCESS
;	    WORKING SETS BETWEEN SWAP STORAGE AND MAIN MEMORY.
;
; ENVIRONMENT:
;	MODE = KERNEL ,  RESIDENT
;
; AUTHOR:  R. HUSTVEDT	 CREATION DATE: 30-NOV-76
;
; MODIFIED BY:
;
;	V03-003	RIH0098		Richard I. Hustvedt	12-Apr-1982
;		Purge all lists of pages associated with a deleted
;		process header.
;
;	V03-002	HRJ0060		Herb Jacobs		20-Mar-1982
;		Fix how shell gets read when it is not totally in the
;		system working set.  This fixes hanging the swapper in
;		either FPG waits or MWAITS.  Add flags for FREWSLE so
;		swapper can safely use it without affecting process
;		synchronized data bases.
;
;	V03-001	STJ0235		Steven T. Jeffreys	17-Mar-1982
;		Create system-wide process quota list.  Used by various
;		pieces of the system to create special system processes.
;
;	V02-026	RIH0095		Richard I. Hustvedt	2-Mar-1982
;		Add use of FREEGOAL parameter.
;
;	V02-025	LJK0128		Lawrence J. Kenah	9-Feb-1982
;		Create the SYSINIT process with resource wait mode disabled.
;
;	V02-024	HRJ0028		Herb Jacobs		25-Aug-1981
;		Perform MOVC of shell to page it rather than QIO read.
;
;	V02-023	HRJ0025		Herb Jacobs		7-Aug-1981
;		Remove goodpage logic.
;
;	V02-022	LJK0042		Lawrence J. Kenah	5-Aug-1981
;		Set flag in PHD following inswap of process header to
;		signal page fault handler not to cause an access violation
;		when one process faults the header page of another process.
;
;	V02-019	LJK0030		Lawrence J. Kenah	5-Aug-1981
;		(Addition to V02-014) Add parameter to DECSHR macro calls
;		that will be passed along to the PFN_REFERENCE macro.
;
;	V02-020	HRJ0025		Herb Jacobs		01-Aug-1981
;		Fix bug in V02-018.
;
;	V02-019	KTA0027		Kerbey T. Altmann	31-Jul-1981
;		Modify code in init to use extra level of indirection
;		on access to LOG$AL_LOGTBL.
;
;	V02-018	HRJ0025		Herb Jacobs		31-Jul-1981
;		Fix force outswap path for shortage of balance set
;		slots in call to oswpsched.
;
;	V02-017	SPF0006		Steve Forgey		06-Jul-1981
;		Add cumulative pages inswapped counter.
;
;	V02-016	HRJ0023		Herb Jacobs		01-Jul-1981
;		Interface change to swap in the page file.
;
;	V02-015	KTA0024		Kerbey T. Altmann	01-Jul-1981
;		Redo the one-time initialization and include
;		the new logical name hash table.
;
;	V02-014	LJK0030		Lawrence J. Kenah	23-Jun-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V02-013	LJK0029		Lawrence J. Kenah	23-Jun-1981
;		Make listheads for three physical page lists longwords instead 
;		of words and change all references to these listheads.
;
;	V02-012	LJK0019		Lawrence J. Kenah	23-Jun-1981
;		Change page protection on process header pages from SRKW 
;		to ERKW to allow only protected access to header pages.
;
;	V02-011	HRJ0020		Herb Jacobs		20-Apr-1981
;		Changes to support working set shrinking in favor of
;		swapping done by OSWPSCHED.
;
;	V02-010	RIH0039		Richard I. Hustvedt	11-May-1981
;		Move setup of process header address into PHD$L_PHD to
;		provide synchronization with process inswap.  Assumed by ASTDEL.
;
;	V02-009	RIH32713	Richard I. Hustvedt	30-Sep-1980
;		Remove use of SFT$B_IOSZ.
;
;	V02-008	WMC0001		Wayne Cardoza		3-Jul-1980
;		Do not use the $CREPRC macro so that we can use the 80000000
;		vector rather than P1 space
;
;	V02-007	KDM0005		KATHLEEN D. MORSE	24-APR-1980
;		Do not fault global pages out of the working set during
;		outswap if they have been locked into the working set.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$ACBDEF				; DEFINE AST CONTROL BLOCK OFFSETS
	$DYNDEF				; DEFINE STRUCTURE TYPE CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				; DEFINE I/O REQUEST PACKET OFFSETS
	$LOGDEF				; DEFINE LOGICAL NAME OFFSETS
	$OPDEF				; Define opcode equivalent values
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFLDEF				; DEFINE SWAP FILE TABLE OFFSETS
	$PFNDEF				; DEFINE PFN VALUES
	$PHDDEF				; DEFINE PHD OFFSETS
	$PQLDEF				; DEFINE QUOTA SYMBOLS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRCDEF				; CREATE PROCESS FLAGS
	$PTEDEF				; DEFINE PAGE TABLE ENTRY
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$WSLDEF				; DEFINE WORKING SET LIST BITS
;
; MACROS:
;


;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	$$$220,LONG		; SWAPPER/SCHEDULER WRITABLE DATA
IOROUTINE:				; ADDRESS OF PROPER BUILD PACKET ROUTINE
	.LONG	0			;
IOEA:	.LONG	0			; I/O END ACTION RETURN
RWSSWP:	.LONG	0			; REMAINING WS SWP ADDRESS
RSVAPTE:.LONG	0			; REMAINING SVA OF PTE
RPGCNT:	.WORD	0			; REMAINING PAGE COUNT
OSWPPGS:.WORD	0			; OUTSWAP PAGE COUNT
OSWPPCB:.LONG	0			; PCB ADDRESS OF OUTSWAP PROCESS
SWP$GW_BALCNT::				; COUNT OF PROCESSES IN BALANCE SET
	.WORD	-1			; EXCLUDING NULL PROCESS AND SWAPPER
SCH$GW_SWPFCNT::			; COUNT OF SUCCESSIVE SWAP
	.WORD	0			; SCHEDULE FAILURES.

	.PSECT	YF$LOWUSE		; PAGED PSECT AT END OF SYS.EXE

IMGDESC:.ASCID	/SYSINIT.EXE/		; SYSTEM INITIALIZATION PROCESS
TT0DESC:.ASCID	/OPA0:/

;
; Define a quota list to be used by various pieces of the system when
; creating a special system process, like a Files-11 ACP.  Every quota
; is mentioned explicitly.  Note that this list can be tailored by
; copying it to some temporary location and appending new quota items
; to the end of the list.  The $CREPRC system service uses the last
; value of a specified quota in the list when it creates a process.
; Note that the end of the list must be terminated by a zero byte,
; and that the length of the list, as given by PQL$C_SYSPQLLEN, does not
; include the list terminator.
;

PQL$AB_SYSPQL::				; System process quota list
	.BYTE	PQL$_ASTLM		; Process AST limit
	.LONG	10
	.BYTE	PQL$_BIOLM		; Process buffered I/O limit
	.LONG	10
	.BYTE	PQL$_BYTLM		; Process buffered I/O byte limit
	.LONG	32768
	.BYTE	PQL$_CPULM		; Process CPU time limit
	.LONG	0			; Zero implies no limit
	.BYTE	PQL$_DIOLM		; Process direct I/O limit
	.LONG	10
	.BYTE	PQL$_FILLM		; Process open file limit
	.LONG	60
	.BYTE	PQL$_PGFLQUOTA		; Process page file quota
	.LONG	20000
	.BYTE	PQL$_PRCLM		; Process subprocess creation limit
	.LONG	8
	.BYTE	PQL$_TQELM		; Process timer queue entry limit
	.LONG	8
	.BYTE	PQL$_WSDEFAULT		; Process default working set size
	.LONG	100
	.BYTE	PQL$_WSQUOTA		; Process working set quota
	.LONG	200
	.BYTE	PQL$_WSEXTENT		; Process working set extent limit
	.LONG	1000
	.BYTE	PQL$_ENQLM		; Process lock limit
	.LONG	100
10$:	.BYTE	PQL$_LISTEND		; End of process quota list

PQL$C_SYSPQLLEN == 10$ - PQL$AB_SYSPQL	; Length of list (minus terminator)
	.PAGE
	.SBTTL	EXE$SWAPINIT - INITIALIZATION AND STARTUP FOR SWAPPER
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$SWAPINIT is entered when the swapper process is first
;	scheduled after a system boot/startup.  This transfer occurs
;	via the initial PC value built into the hardware PCB for the
;	SWAPPER process.  R4 contains the address of the SWAPPER PCB.
;
;--

EXE$SWAPINIT::				; SWAPPER initialization
;
; Initialize paged pool
;
	MOVL	G^EXE$GL_PAGED,R11	; Point to start of paged pool
	CLRL	(R11)+			; Zap forward link
	MOVL	G^SGN$GL_PAGEDYN,(R11)	; And set size
;
; Allocate logical name hash table.  The number of entries in the hash table
; must be a power of two.  So the allocated size is the smallest power of
; two larger than the sysgen parameter.
;
	MOVL	#2, R8			; Do this three times
10$:	SUBL3	#1,G^LOG$GL_HTBLSIZ[R8],R7  ; Pick up one less than sysgen parm
	CVTLF	R7,R7			; Convert to floating
	EXTZV	#7,#7,R7,R7		; Pick up exponent-now the power of 2
	CVTLB	R7,G^LOG$AB_HTBLCNT[R8]	; Store power of two count of entries
	CLRL	R1			; Clear a register
	BBSS	R7,R1,20$		; The size of the table rounded up
20$:	MOVL	R1,G^LOG$GL_HTBLSIZ[R8]	; Write back the correct value
	SOBGEQ	R8,10$			; Loop three times
	MOVAB	G^LOG$AL_LOGTBL+8, R6	; Grab pointer
	MOVL	-(R6),R7		; Find address
	PUSHL	(R7)			; Save addr of SYS$SYSDISK block
	MOVL	-(R6),R7		; Find address
	PUSHL	(R7)			; Save addr of SYS$DISK block
;
; Do the SYSTEM table
;
	MOVL	G^LOG$GL_HTBLSIZ,R1	; Pick up size
	BSBB	30$
;
; Do the GROUP table
;
	MOVL	G^LOG$GL_HTBLSIZ+4,R1   ; Pick up size
	BSBB	30$
					; NOTE that the hash table has been
					; initialized to zero
;
; Now link the two logical name blocks already allocated.
;
	POPL	R5			; Recover addr of SYS$DISK block
	CLRL	LOG$L_LTFL(R5)		; Just in case
	JSB	G^LOG$INSLOGN		; Insert in the table
 	POPL	R5			; Address of sys$sysdisk block
	CLRL	LOG$L_LTFL(R5)		; Just in case
	JSB	G^LOG$INSLOGN		; Insert in the table
;
; Create initial processes
;

; The $CREPRC_S macro cannot be used because that macro generates a
; call through the P1 system service vector pages and the swapper does 
; not have a P1 space. The sense of the Create process call is the
; following.
;
;	$CREPRC_S	INPUT=TT0DESC,-	;
;			OUTPUT=TT0DESC,-;
;			ERROR=TT0DESC,-	;
;			IMAGE=IMGDESC,-	;
;			UIC=#^X80020,-	;
;			STSFLG=#<PRC$M_NOACNT!PRC$M_SSRWAIT>,-
;			BASPRI=#2	;

	PUSHL	#<PRC$M_NOACNT!PRC$M_SSRWAIT>
	CLRL	-(SP)
	PUSHL	#^X80020
	PUSHL	#2
	CLRQ	-(SP)
	PUSHL	#0
	PUSHAQ	TT0DESC
	PUSHL	(SP)
	PUSHL	(SP)
	PUSHAQ	IMGDESC
	PUSHL	#0
	CALLS	#12,@#SYS$CREPRC-P1SYSVECTORS+^X80000000
	JMP	G^LOOP			; Jump off to the main loop
;
; Subroutine to initialize hash table
;
30$:	MOVAL	@#12[R1],R1		; Add in overhead and convert to bytes
	JSB	G^EXE$ALOPAGED		; Allocate memory
	CLRQ	(R2)+			; Clear out unused words
	MOVW	R1,(R2)+		; Store size of structure
	MOVZBW	#DYN$C_RSHT,(R2)+	; Store structure type
	MOVL	R2,@(R6)+		; Store pointer to hash table(group)
	RSB
	.PAGE
	.SBTTL	SWAPPER - MAIN LOOP
;++
; FUNCTIONAL DESCRIPTION:
;	THE MAIN LOOP OF THE SWAPPER IS EXECUTED WHENEVER THE SWAPPER IS AWAKENED
;	FOR ANY REASON.  EACH OF THE FUNCTIONAL ROUTINES WILL CHECK TO SEE IF
;	THEY HAVE ANY ACTION TO PERFORM.
;--
	.PSECT	$AEXENONPAGED		; NON-PAGED PSECT
LOOP:	BSBB	BALANCE			; BALANCE FREE PAGE COUNT
	BSBW	MMG$WRTMFYPAG		; WRITE MODIFIED PAGES
	BSBB	SWAPSCHED		; SCHEDULE SWAP
	TSTL	W^EXE$GL_PFATIM		; CHECK FOR POWER FAIL TIME
	BEQL	15$			; BRANCH IF NO POWERFAIL
	JSB	EXE$POWERAST		; GIVE ANY REQUIRED POWER FAIL ASTS
15$:	MOVL	W^SCH$GL_CURPCB,R4	; GET PROPER PCB ADDRESS
	MOVAQ	W^SCH$GQ_HIBWQ,R2	; AND ADDRESS OF WAIT QUEUE HEADER
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS WHILE CHECKING
	BBSC	#PCB$V_WAKEPEN,PCB$L_STS(R4),20$ ; TEST AND CLEAR WAKE PENDING
	PUSHL	#0			; NULL PSL
	BSBW	SCH$WAITK		; WAIT WITH STACK CLEAN
20$:	SETIPL	#0			; DROP IPL
	BRB	LOOP			; CHECK FOR WORK TO DO
	.DISABLE LSB
	.PAGE
	.SBTTL	BALANCE FREE PAGE COUNT
;++
; FUNCTIONAL DESCRIPTION:
;	BALANCE WILL ENSURE THAT THE FREE PAGE LIST HAS AT LEAST THE NUMBER OF
;	PAGES SPECIFIED BY THE PARAMETER FREELIM.  IF NOT, PAGES WILL BE MADE 
;	AVAILABLE BY EITHER WRITING MODIFIED PAGES OR OUTSWAPPING PROCESSES.
;	IF SUFFICIENT FREE PAGES ARE AVAILABLE, THEN A CHECK IS MADE FOR 
;	DELETED PROCESS HEADERS IN NEED OF CLEANUP.
;--
BALANCE:				; BALANCE FREE PAGE COUNT

	SUBL3	W^SGN$GL_FREEGOAL,W^SCH$GL_FREECNT,R3 ; SUFFICIENT FREE PAGES?
	BLSS	20$			; NO, MUST ACQUIRE SOME
	TSTW	W^SCH$GW_DELPHDCT	; CHECK FOR DELETED PROCESS HEADERS
	BEQL	10$			; NONE, EXIT
	CLRL	R3			; INDICATE NO FREE PAGES NEEDED
	BRB	25$			;
10$:	RSB				; IN BALANCE, RETURN
20$:					;
	BBS	S^#SCH$V_MPW,W^SCH$GB_SIP,25$	; MODIFIED PAGE WRITING ACTIVE
	SUBL3	W^SCH$GL_MFYLOLIM,W^SCH$GL_MFYCNT,R0 ; HOW MUCH WILL WRITING PAGES
	BLEQ	25$			; NONE, MUST OUTSWAP
	ADDL	R3,R0			; YIELD RELATIVE TO WHAT WE NEED?
	BLSS	25$			; NOT ENOUGH, MUST OUTSWAP
	MOVL	W^SCH$GL_MFYLOLIM,W^SCH$GL_MFYLIM ; TRIGGER MODIFIED PAGE WRITING
	RSB				; AND EXIT TO LET IT HAPPEN
;
;	MUST OUTSWAP, FIRST CHECK FOR SWAP IN PROGRESS SINCE SWAPPER IS
;	NOT RE-ENTRANT.  IF PURGING DELETED HEADERS, THEN THE NUMBER OF
;	REQUIRED PAGES (IN R3) WILL BE SET TO ZERO.  AN INFINITE INSWAP PRIORITY
;	WILL BE ASSUMED WHILE BALANCING THE NUMBER FO FREE PAGES.
;
25$:	BBSS	S^#SCH$V_SIP,W^SCH$GB_SIP,10$	; EXIT IF SWAPPER ALREADY BUSY
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>	; SAVE NON-STANDARD REGISTERS
	CLRB	W^SWP$GB_ISWPRI		; SET PRIORITY FOR SWAP SCHEDULE
	MOVL	R3,FP			; GET AND TEST FREE PAGE DEFICIT
	BGEQ	30$			; NONE, PURGING DELETED HEADERS
	TSTW	W^SWP$GW_BALCNT		; CHECK FOR SINGULAR BALANCE SET
	BNEQ	30$			; NO, CAN OUTSWAP
	CLRL	FP			; PREVENT OUTSWAP SCHEDULE
30$:	BRW	OUTSWAP			; TRY TO FORCE AN OUTSWAP

	.PAGE
	.SBTTL	SCHEDULE SWAP
;++
; FUNCTIONAL DESCRIPTION:
;	SWAPSCHED IS CALLED BY THE MAIN LOOP OF THE SWAPPER PROCESS TO CHECK
;	ELIGIBLE INSWAP CANDIDATES AND TO PROVIDE MEMORY NEEDED FOR THEIR
;	INSWAP.  A QUICK EXIT WILL BE TAKEN IF THE SWAPPER IS ALREADY BUSY.
;	NO OUTSWAP WILL BE NEEDED IF THE NUMBER OF REQUIRED PAGES CAN BE
;	TAKEN FROM THE FREE PAGE LIST LEAVING AT LEAST FREELIM STILL FREE.
;	OTHERWISE OUTSWAP WILL BE ENTERED TO MAKE PAGES AVAILABLE BY ANY
;	MEANS NECESSARY.
;--
QEMPTY:	BUG_CHECK QUEUEMPTY,FATAL	; EMPTY QUEUE OR NOT A PCB

SWAPSCHED:				;
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	BBSS	S^#SCH$V_SIP,W^SCH$GB_SIP,5$	; EXIT IF SWAP IN PROGRESS
	FFS	#0,#32,W^SCH$GL_COMOQS,R2; FIND HIGHEST PRIORITY QUEUE
	BNEQ	10$			; FOUND ONE
	BBCC	S^#SCH$V_SIP,W^SCH$GB_SIP,5$	; CLEAR SWAP IN PROGRESS
5$:	SETIPL	#0			; DROP IPL
	RSB				; AND RETURN

10$:					;
	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>	; SAVE REGS OTHER THAN R0-R5
	MOVAQ	W^SCH$AQ_COMOH[R2],R3	; COMPUTE ADDRESS OF QUEUE HEADER
	MOVL	(R3),R4			; GET PCB ADDRESS
;
; THE FOLLOWING CHECK IS NEEDED DUE TO THE ODIOUS MISLEADING SYMPTOMS THAT
; MIGHT OTHERWISE RESULT.
;
	CMPB	#DYN$C_PCB,PCB$B_TYPE(R4); IS THIS A GOOD PCB?
	BNEQ	QEMPTY			;  BUGCHECK IF NOT
;
; DETERMINE THE SIZE OF THE INSWAP CANDIDATE, TAKING INTO ACCOUNT THE FACT
; THAT THE PROCESS HEADER MIGHT ALREADY BE RESIDENT.
;
	MOVZWL	PCB$W_PPGCNT(R4),R0	; COUNT OF PROCESS PAGES
	MOVZWL	PCB$W_GPGCNT(R4),R10	; COUNT OF GLOBAL PAGES
	ADDL	R0,R10			; SUM PAGE COUNTS
	BBC	#PCB$V_PHDRES,PCB$L_STS(R4),15$	; CONTINUE IF HEADER NON-RESIDENT
	MOVZWL	PCB$W_APTCNT(R4),R0	; GET ACTIVE PAGE TABLE COUNT
	SUBL	R0,R10			; SUBTRACT RESIDENT HEADER PAGES FROM REQUIRED
15$:					;
	SUBL3	W^SCH$GL_FREELIM,W^SCH$GL_FREECNT,R0	; COMPUTE PAGES AVAILABLE
	MOVB	PCB$B_PRI(R4),W^SWP$GB_ISWPRI	; SAVE PRIORITY OF INSWAP
	SUBL3	R10,R0,FP			; WILL PROCESS FIT?
	BLSS	20$			; NO, MUST OUTSWAP
	MOVW	W^SCH$GW_SWPFAIL,W^SCH$GW_SWPFCNT	; RESET FAILURE COUNTER
	BRW	INSWAP			; YES PERFORM SWAP
;
; IF INSWAPPING A NON-REAL TIME PROCESS, THEN CHECK TO SEE IF ITS CURRENT
; PRIORITY IS THE DEFAULT BACKGROUND PRIORITY.  IF SO, THEN DELAY AT LEAST
; SWAPRATE INTERVAL SINCE THE LAST INSWAP.  THE EFFECT WILL BE TO AVOID FILLING
; THE BALANCE SET WITH CRUNCHING PROCESSES IMMEDIATELY.
;
20$:					; SCHEDULE OUTSWAP
	CMPB	#16,PCB$B_PRI(R4)	; IS THIS A REAL TIME PROCESS?
	BGTR	40$			; BR IF SO
	SUBB3	W^SYS$GB_DEFPRI,#31,R1	; CONVERT PRIORITY TO INTERNAL FORM
	CMPB	R2,R1			; IS THIS A CRUNCHER OR LOW PRIORITY JOB?
	BLSS	40$			; BR IF NOT
	MFPR	#PR$_TODR,R1		; GET CURRENT TIME IN 10MS UNITS
	CMPL	R1,W^SWP$GL_SWTIME	; HAS INTERVAL ELAPSED?
	BGTRU	40$			; BR IF YES
	BRW	SWAPEXIT		; CAN'T DO SWAP NOW
40$:					;
	.PAGE
	.SBTTL	OUTSWAP
;--------------------------------------------------------------------
;
;	SCHEDULE AND PERFORM OUTSWAPS IF POSSIBLE
;
;--------------------------------------------------------------------
; FUNCTIONAL DESCRIPTION:
;	THE OUTSWAP STRATEGY IS TO FREE PROCESS HEADERS FOR OUTSWAP PROCESSES,
;	USE AVAILABLE MODIFIED PAGES (AFTER WRITING THEM) AND FINALLY AS A LAST
;	RESORT OUTSWAP ANOTHER PROCESS.  ONLY ONE OF THESE ACTIONS WILL BE TAKEN
;	AT A TIME THEN THE SCHEDULING SITUATION WILL BE RE-EVALUATED.  THE VALUE
;	IN FP INDICATES THE SIZE OF THE PAGE DEFICIT AND WILL BE SET POSITIVE IF
;	ENTERED FROM BALANCE TO FREE DELETED PROCESS HEADERS.
;
; INPUT:	FP - NEGATIVE VALUE WILL PERMIT PROCESS OUTSWAP
;		     ZERO OR POSITIVE WILL PURGE HEADERS ONLY.
;

OUTSWAP:				; TRY TO OUTSWAP
	SUBL3	#1,SGN$GL_BALSETCT,R8	; INIT INDEX FOR BALANCE SLOT SCAN
	MCOML	#0,R9			; INDICATE NO FREE LIST PURGE CANDIDATE
10$:	TSTW	@W^PHV$GL_REFCBAS[R8]	; IS SLOT IN NEED OF CLEANUP?
	BNEQ	12$			; CONTINUE IF NOT RELEASABLE
	BRW	60$			; GO RELEASE PAGE TABLES AND HEADER
12$:	CVTWL	@W^PHV$GL_PIXBAS[R8],R4	; GET PROCESS INDEX
	BLEQ	15$			; DELETED PROCESS OR VACANT SLOT
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	; GET PCB ADDRESS FOR PIX
	BLBS	PCB$L_STS(R4),20$	; SKIP IF PROCESS IS RESIDENT
15$:	BEQL	20$			; VACANT SLOT
	TSTL	R9			; CHECK FOR REMEMBERED INDEX
	BGEQ	20$			; YES DONT OVERWRITE
	MOVL	R8,R9			; SAVE BALANCE SLOT NUMBER OF CANDIDATE
20$:	SOBGEQ	R8,10$			; TRY ALL SLOTS
	MOVL	R9,R8			; GET AND TEST SLOT INDEX FOR SECONDARY CANDIDATE
	BGEQ	24$			; BR IF SLOT FOR CLEANUP
	TSTL	FP			; CHECK FOR HEADER PURGE
	BGEQ	22$			; EXIT IF SO
;
; SINCE THERE WAS NO HEADER TO FREE, WE MUST NOW WRITE MODIFIED PAGES OR OUTSWAP
; SOME PROCESS.  ONLY IF MODIFIED PAGES (MFYCNT-LOLIM) WILL TOTALLY SATISFY OUR
; NEEDS WILL THEY BE WRITTEN.  OTHERWISE THE LEAST USEFUL (BY SOME OPINION) PROCESS
; WILL BE OUTSWAPPED AND THE SITUATION RECONSIDERED.
;
	BSBW	SCH$OSWPSCHED		; SCHEDULE OUTSWAP
	TSTL	R4			; ANY CANDIDATE?
	BNEQ	23$			; YES
22$:	BRW	SWAPEXIT		; ELSE EXIT AND TRY LATER
23$:	BRW	70$			; GO DO OUTSWAP
;
; A HEADER SLOT IN NEED OF CLEANUP WAS FOUND, NOW SCAN THE FREELIST FOR ALL
; PAGES WHOSE PTE BACK POINTERS PLACE THEM WITHIN THIS HEADER.  DELETE THE
; CONTENT OF THOSE PAGES VIA MMG$DELCONPFN TO FINALLY REDUCE THE REFERENCE
; COUNT BINDING THE HEADER.
;
24$:	ROTL	#2,W^SWP$GL_BSLOTSZ,R7	; GET SIZE OF BALANCE SLOT IN BYTES
	MULL3	R7,R8,R6		; COMPUTE OFFSET TO BASE OF SLOT
	PUSHAB	@W^SWP$GL_BALSPT[R6]	; ADD BASE TO GET ADDRESS
	ROTL	#7,R6,R2		; FORM OFFSET TO PHD BASE
	PUSHAB	@W^SWP$GL_BALBASE[R2]	; BASE ADDRESS FOR PHD
	ROTL	#7,R7,R1		; MUL SPT SLOT SIZE BY 128
	PUSHAB	@4(SP)[R7]		; FORM HIGH LIMIT FOR PAGTBLPPTE
	PUSHAB	@4(SP)[R1]		; ANS SAVE PTE HIGH LIMIT

;
;	AT THIS POINT:
;
;	00(SP) - HIGH LIMIT ADDRESS FOR PROCESS HEADER
;	04(SP) - HIGH LIMIT FOR PROCESS PAGE TABLE PTE
;	08(SP) - LOW LIMIT FOR PROCESS HEADER
;	12(SP) - LOW LIMIT  FOR PROCESS PAGE TABLE PTE
;
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	ASSUME	PFN$C_MFYPAGLST	EQ 1	;
	ASSUME	PFN$C_BADPAGLST	EQ 2	;
	CLRL	R7			; ASSUME ONLY FREELIST SCAN
	TSTW	@W^PHV$GL_PIXBAS[R8]	; IS THIS A DELETED PROCESS HEADER?
	BGEQ	25$			; BR IF NOT.  ONLY SCAN FREELIST
	MOVL	#PFN$C_BADPAGLST,R7	; INITIALIZE LOOP SCAN TO BADPAGLST
25$:	MOVL	W^PFN$AL_HEAD[R7],R0	; GET HEAD OF LIST TO START SCAN
	BEQL	45$			; NO PAGES, DONE
30$:		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_FLINK[R0],R9>,-	; GET FORWARD LINK
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	MOVL	@W^PFN$AL_PTE[R0],R3	; GET SVA OF PTE FOR PAGE
	ASSUME	PFN$C_PPGTBL EQ 4	
	ASSUME	PFN$C_GPGTBL EQ 5
	EXTZV	#2,#1,@W^PFN$AB_TYPE[R0],R1	; GET PAGE TABLE BIT
	CMPL	R3,8(SP)[R1]		; COMPARE WITH LOW LIMIT
	BLSSU	40$			; OUT OF RANGE
	CMPL	R3,(SP)[R1]		; COMPARE WITH HIGH LIMIT
	BGEQU	40$			; OUT OF RANGE
	BLBC	R7,35$			; BR IF FREE OR BAD LIST
	MOVL	@PFN$AL_BAK[R0],R2	; GET BACKING STORE ADDRESS
	BBS	#PTE$V_TYP0,R2,40$	; LEAVE MODIFIED SECTION PAGES
35$:	MOVL	R7,R2			; SET LIST NUMBER FOR DELETE
	BSBW	MMG$REMPFN		; REMOVE PAGE FROM FREE LIST
	BSBW	RELDELPAGE		; RELEASE PAGE DELETING CONTENT
40$:	MOVL	R9,R0			; FLINK TO NEXT PAGE
	BNEQ	30$			; ANOTHER PAGE TO TRY
45$:	SOBGEQ	R7,25$			; NEXT LIST
	ADDL	#16,SP			; CLEAN STACK OF LIMITS
	TSTW	@W^PHV$GL_REFCBAS[R8]	; DID WE FREE PROCESS HEADER
	BEQL	60$			; YES, RELEASE IT
;
; THERE ARE TWO REASONS THAT MIGHT PREVENT THE HEADER FROM BEING RELEASED BY
; THE FREELIST SCAN:
; 			1. SOME OF THE TRANSITION PAGES ARE ON THE MODIFED LIST.
;			2. THERE IS I/O IN PROGRESS ON THE TRANSITION PAGES.
; TO COVER THE FORMER CASE (SINCE WE CANT REALLY TELL), THE MODIFIED LIST MUST
; BE TOTALLY FLUSHED.  HOWEVER THIS IS ACTUALLY QUITE RARE.
;
	CLRL	W^SCH$GL_MFYLOLIM	; FORCE ENTIRE MODIFY LIST TO BE WRITTEN
	CLRW	W^SCH$GL_MFYLIM		; CLEAR PART OF HI LIMIT, NOT PART THAT
					; INDICATES MODIFIED WRITING IN PROGRESS
	MCOML	#0,R9			; NO, TRY FOR ANOTHER
	BRW	20$			; NOW ATTEMPT CLEANUP
60$:	BRW	RELPHD			; GO RELEASE PROCESS HEADER
70$:					;
;
;	R4 - PCB OF OUTSWAP CANDIDATE, ALREADY MARKED NON-RESIDENT
;

	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS

	DECW	W^SWP$GW_BALCNT		; DECREASE NUMBER IN BALANCE SET
	BSBW	OSINIT			; INIT REGISTERS FOR SCAN
	CLRW	PCB$W_APTCNT(R4)	; INITIALIZE ACTIVE PAGE TABLE COUNT
	MOVZWL	PHD$W_WSLIST(R5),R7	; WS INDEX FOR PERM PAGES
	MOVZWL	PHD$W_WSLAST(R5),R6	; END OF WORKING SET LIST
;
;	REGISTER CONVENTIONS FOR OWSLOOP ARE:
;
;	R0 - PFN
;	R1 - SCRATCH, WSLX
;	R2 - WORKING SET LIST ENTRY (VIRTUAL ADDRESS+FLAGS)
;	R3 - SVA OF PTE FOR WORKING SET LIST ENTRY
;	R4 - PCB ADDRESS
;	R5 - PHD ADDRESS
;	R6 - END INDEX TO WORKING SET LIST
;	R7 - WSLX (WORKING SET LIST INDEX)
;	R8 - PTE CONTENT
;	R9 - WORKING POINTER TO SWP$AL_MAP
;	R10 - PTE$M_VALID!PTE$C_ERKW
;	R11 - BASE ADDRESS OF SWP$AL_MAP
;
OWSLOOP:				; OUTSWAP WS LOOP
	MOVL	(R5)[R7],R2		; GET WORKING SET LIST ENTRY
	BLBC	R2,NOTVALID		; SKIP IF NOT VALID
	BSBW	MMG$SVAPTECHK		; CONVERT VA TO SVA OF PTE
;
;	R3 <- SVA OF PTE FOR VA IN R2
;
	MOVL	(R3),R8			; GET CONTENT OF PTE
	BLSS	10$			; CONTINUE IF VALID PAGE
	DECL	R2			; CLEAR VALID FLAG
10$:	BICB	#^C<WSL$M_VALID!WSL$M_PAGTYP!WSL$M_PFNLOCK>,R2; ISOLATE INTERESTING FLAGS FOR PAGE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R8,R0	; GET PFN FROM PTE
	BSBB	OSDISPATCH		; DISPATCH ON PAGE TYPE
NOTVALID:				;
	AOBLEQ	R6,R7,OWSLOOP		; PROCESS ENTIRE WORKING SET LIST
	BRB	PROCWRT			; DONE WITH WORKING SET LIST, RESET HEADER
OSDISPATCH:				; 
	ASSUME	WSL$V_VALID   EQ  0
	ASSUME	WSL$V_PAGTYP  EQ  1
	ASSUME	WSL$V_PFNLOCK EQ  4
	ASSUME	PFN$C_PROCESS EQ  0
	ASSUME	PFN$C_SYSTEM  EQ  1
	ASSUME	PFN$C_GLOBAL  EQ  2
	ASSUME	PFN$C_GBLWRT  EQ  3
	ASSUME	PFN$C_PPGTBL  EQ  4
	ASSUME	PFN$C_GPGTBL  EQ  5
	MOVAL	(R5)[R7],FP		; COMPUTE ADDRESS OF WSL ENTRY
	CASE	R2,<-			; SWITCH ON WSL PAGE TYPE + PTE VALID BIT
		PROCTRANS,-		; 0 => PROCESS TRANSITION PAGE
		PROCVALID,-		; 1 => PROCESS VALID PAGE
		WSLERR,-		; 2 => ????  BUGCHECK
		WSLERR,-		; 3 => ????  BUGCHECK
		GBLTRANS,-		; 4 => GLOBAL TRANSITION
		GBLVALID,-		; 5 => GLOBAL VALID
		GBLWRTTRANS,-		; 6 => GLOBAL WRITABLE TRANSITION
		GBLWRTVALID-		; 7 => GLOBAL WRITABLE VALID
		PPGTBLTRANS,-		; 8 => PROCESS PAGE TABLE TRANSITION
		PPGTBLVALID,-		; 9 => PROCESS PAGE TABLE VALID
		>,TYPE=B		;
	RSB				; SKIP PFN LOCK PAGES

SPACEFAIL:
	BUG_CHECK INSSWPFIL,FATAL	; INSUFFICIENT SWAP FILE SPACE

PROCWRT:				; RESET PROCESS HEADER BASE REGISTERS
	MOVL	PCB$L_WSSWP(R4),R2	; GET SWAP ADDRESS
	BLEQ	SPACEFAIL		; BRANCH IF NO VBN AVAILABLE TO USE
	MOVZWL	PCB$W_APTCNT(R4),R0	; GET COUNT OF ACTIVE PAGE TABLES
	MOVL	R4,W^OSWPPCB		; SAVE ADDRESS OF OUTSWAP PROCESS
	SUBL	R11,R9			; COMPUTE NUMBER OF PAGES * 4
	ROTL	#<32-2>,R9,R4		; DIVIDE COUNT BY 4
	CMPW	R4,PHD$W_SWAPSIZE(R5)	; DO WE HAVE ENOUGH SPACE FOR SWAP
	BGTRU	SPACEFAIL		; BRANCH IF NOT, THIS IS FATAL
	MOVW	R4,W^OSWPPGS		; SAVE COUNT OF OUTSWAP PAGES
	MOVL	R11,R3			; SVAPTE FOR OUTSWAP I/O
	ADDL	R0,R2			; SKIP HEADER AND ACTIVE PAGE TABLES
	.PAGE

;----------------------------------------------------------------------------
;
;	DO OUTSWAP I/O FOR PROCESS HEADER AND BODY
;
;----------------------------------------------------------------------------
	INCL	W^SWP$GL_OSWPCNT	; ACCOUNT FOR OUTSWAP
	BSBW	SWPWRITE		; WRITE HEADER AND BODY
	BLBS	R0,20$			; CONTINUE IF NO I/O ERROR
	BUG_CHECK OUTSWPERR,FATAL	; **** OUT SWAP I/O ERROR
20$:					;

	BSBW	RELINIT			; INIT REGISTERS FOR RELEASE LOOP
	MOVL	PCB$L_PHD(R4),R5	; GET POINTER TO PHD
	MOVZWL	PHD$W_PHVINDEX(R5),R8	; GET PROCESS HEADER SLOT INDEX
30$:	BICL3	R10,(R9)+,R0 		; GET PAGE NUMBER TO RELEASE
	CMPZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,@W^PFN$AB_TYPE[R0],#PFN$C_GLOBAL	;
	BEQL	80$			; PAGE IS GLOBAL, COMPLEX CLEANUP
	MOVL	@W^PFN$AL_PTE[R0],R6	; GET POINTER TO PAGE TABLE FOR  PAGE
	BICL	#<PTE$M_VALID!PTE$M_MODIFY>,(R6); CLEAR VALID AND MODIFY
	TSTW	@W^PFN$AW_SWPVBN[R0]	; WAS I/O IN PROGRESS?
	BEQL	40$			; NO, DONT MARK PAGE MODIFIED
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; MARK PAGE MODIFIED
	CMPZV	#PFN$V_LOC,#PFN$S_LOC,-	; IF THIS WAS READ IN PROGRESS
		@W^PFN$AB_STATE[R0],#PFN$C_RDERR ; AND IS NOW PAGE READ ERROR
	BNEQ	40$			;
	DECREF				; AND IF THIS IS THE LAST REFERENCE
	BNEQ	60$			;
	MOVZBL	#PFN$C_BADPAGLST,R2	; THEN DIVERT THE PAGE TO
	BSBW	MMG$INSPFNT		; THE BAD PAGE LIST
	BRB	60$			;
40$:	DECREF				; DECREMENT REFERENCE COUNT FOR PAGE
	BNEQ	55$			; NOT RELEASABLE YET
50$:	BSBW	MMG$RELPFN		; RELEASE PFN AS APPROPRIATE
	BRB	60$			; GO FOR NEXT PAGE
55$:	CMPZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],- ;
		#PFN$C_ACTIVE		; IS STATE ACTIVE?
	BNEQ	60$			; NO, THEN LEAVE UNCHANGED
	INSV	#PFN$C_RELPEND,-	; MAKE STATE BE RELEASE PENDING
		#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0]; IF SOME I/O OUTSTANDING
60$:	SOBGTR	R7,30$			; NEXT PAGE IN LIST
	BRW	RELPHD			; RELEASE PROCESS HEADER IF POSSIBLE
80$:	DECSHR	GTR=60$,-		; DECREASE SHARE COUNT FOR PAGE
		IMAGE_FLAG=SYS_NONPAGED
	BRB	40$			; RELEASE PAGE TO FREE LIST IF REFCNT=0
	.PAGE
	.SBTTL	RELPHD - RELEASE PROCESS HEADER
;++
; FUNCTIONAL DESCRIPTION:
;	RELPHD CHECKS THE REFERENCE  COUNT ON THE PROCESS HEADER
;	AND RELEASES THE PAGE TABLES FROM THE PROCESS HEADER WHEN ALL
;	OF THEIR PAGES HAVE BEEN RELEASED.  THE PAGE TABLES ARE FIRST WRITTEN
;	TO THE SWAP IMAGE IF THEY ARE MARKED AS UPDATED.
;
; CALLING SEQUENCE:
;	BRW/JMP	RELPHD
;
; INPUT PARAMETERS:
;	R8 - BALANCE SLOT INDEX FOR HEADER TO BE RELEASED
;
; OUTPUT PARAMTERS:
;	R0-R7,R9,R10 VOLATILE
;
; SIDE EFFECTS:
;	THE PAGE TABLES FROM THE PROCESS HEADER MAY BE WRITTEN TO THE
;	SWAP IMAGE FOR THE PROCESS IF THEY HAVE BEEN UPDATED.
;
;--


RELPHD:					;
	TSTW	@W^PHV$GL_REFCBAS[R8]	; SEE IF PROCESS HEADER IS RELEASABLE
	BEQL	5$			; YES, FREE ACTIVE PAGE TABLES
	BRW	OSWPEXIT		; NO, TRY LATER
5$:	MOVL	W^SWP$GL_BSLOTSZ,R7	; SET ITERATION COUNT TO WHOLE BALANCE SLOT
	MULL3	R7,R8,R1		; GET LONG WORD OFFSET TO SLOT
	MOVAL	@W^SWP$GL_BALSPT[R1],R6	; POINT TO BASE OF THIS SLOT
	BSBW	OSINIT			; INIT REGISTERS FOR SCAN
	CVTWL	@W^PHV$GL_PIXBAS[R8],R4	; GET INDEX TO PROCESS IN SLOT
	BLSS	12$			; BR IF DELETED PROCESS
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	; AND TRANSLATE TO PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS
	MOVL	R8,PCB$L_PHD(R4)	; INDICATE NO PHD FOR PROCESS
	SUBL	R5,PHD$L_P0BR(R5)	; UNBIAS MEMORY MANAGEMENT BASE REGISTERS
	SUBL	R5,PHD$L_P1BR(R5)	; FOR BOTH P0 AND P1 SPACE
	BBCC	#PCB$V_PHDRES,PCB$L_STS(R4),7$	; MARK PHD NON-RESIDENT
7$:	MOVZWL	PHD$W_WSLX(R5),AP	; GET POINTER TO WSLX SAVE AREA
	MOVAL	(R5)[AP],AP		; AND CONVERT TO BYTE ADDRESS
	MOVZWL	PHD$W_BAK(R5),FP	; GET POINTER TO BACKING STORE VECTOR
	MOVAL	(R5)[FP],FP		; AND CONVERT TO BYTE ADDRESS
	CLRW	PHD$W_EMPTPG(R5)	; CLEAR COUNT OF EMPTY WSL PAGES
10$:	MOVL	(R6)+,(FP)+		; COPY ENTRY FROM SPT
	BLSS	15$			; BR IF VALID
	BNEQ	11$			; BR IF NOT EMPTY WSL PAGE
	INCW	PHD$W_EMPTPG(R5)	; COUNT EMPTY WSL PAGES
11$:	CLRL	-4(R6)			; ZAP INVALID ENTRY TO NO-ACCESS
	CLRW	(AP)+			; AND CLEAR WSLX VALUE FOR PAGE
	BRB	20$			; 
12$:	BRW	DELPHD			; FINISH DELETE FOR PROCESS
15$:	EXTZV	#PTE$V_PFN,#PTE$S_PFN,-4(FP),R0	; GET PFN FOR VALID ENTRY
	BEQL	11$			; DEMAND ZERO OR NULL PTE
	INSV	@W^PFN$AL_BAK[R0],#PTE$V_PGFLVB,#PTE$S_PGFLVB,-4(FP)	; SAVE BACKUP ADDR
		PFN_REFERENCE	-
	MOVW	<@W^PFN$Ax_WSLX[R0],(AP)+>,-	; AND WORKING SET LIST INDEX
		LONG_OPCODE=CVTLW,-
		IMAGE=SYS_NONPAGED
	BISL3	R0,R10,(R9)+		; SET INTO SWAPPER MAP
	BBSS	#PTE$V_VALID,-4(FP),20$	; MARK PAGE VALID FOR INSWAP PURPOSES
20$:	SOBGTR	R7,10$			; SCAN ENTIRE BALANCE SLOT
	SUBL	R11,R9			; COMPUTE NUMBER OF PAGES * 4
	MOVL	PCB$L_WSSWP(R4),R2	; WORKING SET SWAP SLOT
	MOVL	R4,W^OSWPPCB		; SAVE PCB ADDRESS FOR SLOT OWNER
	ROTL	#<32-2>,R9,R4		; DIVIDE COUNT BY 4
	MOVW	R4,W^OSWPPGS		; SAVE COUNT OF OUTSWAP PAGES
	MOVL	R11,R3			; SET SVA OF MAP FOR I/O
	INCL	W^SWP$GL_HOSWPCNT	; ACCOUNT FOR HEADER OUTSWAP
	BSBW	SWPWRITE		; WRITE ACTIVE PAGE TABLES
	BLBS	R0,30$			; CONTINUE IF NO ERROR
	BUG_CHECK APTWRTERR,FATAL	; **** ACTIVE PAGE TABLE SWAP I/O ERROR
30$:	BSBW	RELINIT			; INIT REGISTERS FOR RELEASE LOOP
	MOVL	PCB$L_PHD(R4),R8	; RESTORE BALANCE SLOT INDEX
40$:	BICL3	R10,(R9)+,R0		; ISOLATE PAGE FRAME NUMBER
	MOVL	@W^PFN$AL_PTE[R0],R6	; GET PTE ADDRESS
	MOVL	R0,(R6)			; MAKE PTE CORRECT BUT INVALID
	DECW	@W^PFN$AW_REFCNT[R0]	; DROP REFERENCE COUNT 
	BEQL	50$			; MUST BE ZERO
	BUG_CHECK APTREFHIGH,FATAL	; INCONSISTENT PAGE TABLE REFERENCE COUNT
50$:	MOVL	R6,R3			; SVAPTE FOR DELCON
	BSBW	RELDELPAGE		; RELEASE PAGE THROUGH DELCONPFN
	CLRL	(R6)			; SET NO ACCESS ON PFN
	SOBGTR	R7,40$			; CONTINUE FOR ALL ACTIVE PAGE TABLES
	MNEGW	#1,@W^PHV$GL_REFCBAS[R8]	; MARK BALANCE SLOT AVAIL
	CLRW	@W^PHV$GL_PIXBAS[R8]	; AND SET PIX TO NULL
	CLRL	PCB$L_PHD(R4)		; AND SEVER CONNECTION WITH PROCESS

OSWPEXIT:				; OUTSWAP COMPLETE
	BRW	SWAPRETRY		; RETRY SWAP SCHEDULE AFTER OUTSWAP
	.PAGE
	.SBTTL	DELPHD - DELETE PROCESS HEADER FOR DELETED PROCESS
;
; FUNCTIONAL DESCRIPTION:
;	DELPHD IS ENTERED BY RELPHD IF THE PROCESS INDEX ASSOCIATED WITH
;	THE BALANCE SLOT IS NEGATIVE INDICATING THE PROCESS HAS BEEN DELETED.
;	NOW THAT THE REFERENCE COUNT FOR THE HEADER IS ZERO, ALL PAGES AND
;	BACKING STORE PAGES CAN BE RELEASED PERMITTING RELEASE OF THE BALANCE
;	SLOT.  AT THIS POINT THE SPT ENTRIES ARE VALID WITH A PFN, DEMAND ZERO,
;	OR BACKING STORE ADDRESS FORM.  THERE ARE NO REMAINING TRANSITION PAGES.
;
; INPUT PARAMETERS:
;	R1 - PRODUCT OF SGN$C_BSLOTSZ * BALANCE_SLOT_INDEX
;	R6 - ADDRESS OF FIRST SPT ENTRY FOR THIS BALANCE SLOT
;	R7 - SGN$C_BSLOTSZ
;	R8 - BALANCE_SLOT_INDEX
;	R10- MASK OF PTE$M_VALID!PTE$M_MODIFY!PTE$C_ERKW
;
DELPHD:					;
	ROTL	#9,R1,R5		; COMPUTE OFFSET TO PHD FROM BASE
	ADDL	W^SWP$GL_BALBASE,R5	; FORM PHD ADDRESS
	MOVZBL	PHD$B_PAGFIL(R5),R11	; GET PAGING FILE NUMBER
10$:	MOVL	(R6)+,R0		; GET PTE FROM SPT
	BEQL	40$			; BR IF EMPTY
	BLSS	20$			; BR IF VALID
	BBS	#PTE$V_TYP1,R0,25$	; BR IF TYPE 1 (BACKING STORE)
20$:	BICL	R10,R0			; ISOLATE PFN
	BEQL	30$			; SKIP DEMAND ZERO PTE
	MOVL	@W^PFN$AL_BAK[R0],R9	; GET BACKUP ADDRESS
	BICB	#<<PTE$M_VALID!PTE$M_MODIFY>@-24>,-1(R6) ; CLEAR VALID AND MODIFY
	BSBW	RELDELPAGE		; RELEASE PAGE
	MOVL	R9,R0			; GET BACKUP ADDRESS
25$:	EXTZV	#PTE$V_PGFLVB,#PTE$S_PGFLVB,R0,R0	; GET PAG FIL VB
	BEQL	30$			; BR IF NONE
	MOVL	R11,R3			; SET PAGING FILE NUMBER FOR RELEASE
	BSBW	MMG$DALCPAGFIL		; DEALLOCATE PAGING FILE PAGE
30$:	CLRL	-4(R6)			; ZAP SPT ENTRY
40$:	SOBGTR	R7,10$			; RELEASE ENTIRE HEADER
	INVALID				; INVALIDATE HEADER
	MNEGW	#1,@W^PHV$GL_REFCBAS[R8]	; MARK SLOT EMPTY
	CLRW	@W^PHV$GL_PIXBAS[R8]	; POINT OWNER PIX AT NULL PROCESS
	DECW	W^SCH$GW_DELPHDCT	; ACCOUNT FOR DELETED HEADER
	BRW	SWAPRETRY		; AND RETRY SWAP ATTEMPT
	.PAGE
	.SBTTL	GBLTRANS/GBLVALID/GBLWRTVALID - HANDLE GLOBAL PAGES

;
;	GBLTRANS HANDLES THE CASE OF A GLOBAL PAGE IN TRANSITION,
;	WHICH IMPLIES THAT THE PAGE HAS BEEN FAULTED BUT IS NOT YET
;	RESIDENT.  THE WORKING SET LIST ENTRY FOR THIS PAGE WILL BE
;	DELETED AND THE PAGE WILL HAVE TO BE FAULTED AGAIN.
;

GBLTRANS:				; TRANSITION GLOBAL PAGE
GBLWRTTRANS:				; TRANSITION WRITABLE GLOBAL PAGE
	INSV	@W^MMG$GL_GPTBASE[R0],#PTE$V_PFN,#PTE$S_PFN,R0	; GET GLOBAL PFN FROM MASTER

	.ENABL	LSB
GBLDROP:				; DROP GLOBAL PAGE FROM WORKING SET
	MOVL	R7,R1			; GET WSL INDEX FOR RELEASE
	PUSHL	R3			; SAVE SVAPTE FOR FOLLOWING DECPTREF
	BSBW	MMG$DELWSLEX		; DELETE WSL GIVEN INDEX
	POPR	#^M<R3>			; RESTORE SVAPTE
	BSBW	MMG$DECPTREF		; AND DROP PAGE TABLE REFERENCE
	DECSHR	GTR=10$,-		; DECREASE SHARE COUNT
		IMAGE_FLAG=SYS_NONPAGED		
PROCDROP:
	DECREF	GTR=20$			; AND REF COUNT IF LAST SHARER
	BSBW	MMG$RELPFN		; RELEASE PAGE IF LAST REFERENCE
10$:					;
	RSB				; RETURN FOR NEXT PAGE
20$:	CMPZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],- ;
		#PFN$C_ACTIVE		; CHECK FOR ACTIVE STATE
	BNEQ	30$			; NO, THEN LEAVE STATE UNCHANGED
	INSV	#PFN$C_RELPEND,-	; SET STATE TO RELEASE PENDING IF
		#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0] ; I/O OUTSTANDING
30$:	RSB				;
	.DSABL	LSB

;
;	GBLVALID HANDLES A VALID, NON-WRITABLE, PAGE.
;
GBLVALID:				; VALID GLOBAL PAGE
;
;	IF THE GLOBAL PAGE IS BEING ACTIVELY SHARED THEN IT WILL BE DROPPED
;	FROM THE WORKING SET AND REFAULTED LATER (PRESUMABLY WITHOUT I/O).
;
	BBS	#WSL$V_WSLOCK,(FP),10$	; DON'T DROP PAGES LOCKED IN WORKING SET
		PFN_REFERENCE	-
	CMPW	<#1,@W^PFN$Ax_SHRCNT[R0]>,-	; IS THERE ACTIVE SHARING OF THIS PAGE?
		LONG_OPCODE=CMPL,-
		IMAGE=SYS_NONPAGED
	BNEQ	GBLWRTVALID		; YES, DROP IT AND REFAULT LATER
;
;	OTHERWISE THE PAGE WILL BE WRITTEN TO THE SWAP IMAGE SINCE IT IS
;	UNLIKELY TO BE RESIDENT UPON INSWAP.
;
10$:	BISL3	R0,R10,(R9)+		; SET IN SWAPPER MAP FOR OUT SWAP
	BSBW	MMG$DECPTREF		; DROP PAGE TABLE REFERENCE FOR PAGE
GBLRESET:				; RESET SLAVE PTE TO GPTX FORMAT
	SUBL3	W^MMG$GL_GPTBASE,@W^PFN$AL_PTE[R0],R1	; GET GPTX FOR PAGE
	ROTL	#<32-2>,R1,R1		; AND CONVERT TO CORRECT SCALE
	ASSUME	PTE$V_TYP0 EQ PTE$S_GPTX
	BBSS	#PTE$V_TYP0,R1,10$	; MARK AS GLOBAL
10$:	BICL3	#<PTE$M_VALID ! -	; OBTAIN PERMANENT BITS FOR PTE
		  PTE$M_TYP0  ! -	; BY CLEARING ALL OTHERS
		  PTE$M_TYP1  ! -	;
		  PTE$M_PFN>,(R3),R2	; TO FORM TRANSITION GLOBAL PTE
	BISL3	R1,R2,(R3)		; MUST SET ENTIRE PTE AT ONE TIME
					; SO THAT I/O CAN SEE CONSISTENT PTE
	RSB				; RETURN FOR NEXT PAGE

;
;	GBLWRTVALID HANDLES THE CASE OF A WRITABLE GLOBAL PAGE.
;	SUCH PAGES ARE DROPPED FROM THE WORKING SET BEFORE OUTSWAPPING
;	AND MUST BE SUBSEQUENTLY RE-FAULTED.
;
GBLWRTVALID:				; VALID WRITABLE GLOBAL PAGE
	BBCC	#PTE$V_MODIFY,(R3),10$	; TEST AND CLEAR MODIFY BIT IN SLAVE PTE
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; AND SAVE MODIFY STATE
10$:	BSBB	GBLRESET		; RESET PTE
	BRB	GBLDROP			; DELETE WORKING SET LIST ENTRY

	.PAGE
	.SBTTL	PROCTRANS - PROCESS PAGE IN TRANSITION
;
;	THIS PAGE IS IN TRANSITION DUE TO THE FACT THAT THE PAGE FAULT
;	READ OPERATION HAS NOT YET COMPLETED.  IT IS TREATED AS AN
;	I/O IN PROGRESS PAGE.
;
PROCTRANS:				; PROCESS PAGE IN TRANSITION
	CMPZV	#PFN$V_LOC,#PFN$S_LOC,-	; IF THIS PAGE COULD NOT
		@W^PFN$AB_STATE[R0],#PFN$C_RDERR ; BE SUCCESSFULLY READ
	BNEQ	PROCVALID		;
	MOVL	R7,R1			; DROP IT FROM THE WORKING SET
	BSBW	MMG$DELWSLEX		; DELETE THE WSL ENTRY GIVEN WSL INDEX
	BRB	PROCDROP		; AND RELEASE THE PFN IF LAST REF

;
;	PROCVALID HANDLES THE CASE OF A VALID PROCESS PAGE WHICH INCURS
;	SOME SPECIAL PROCESSING IF THERE IS I/O IN PROGRESS.  AN I/O IN 
;	PROGRESS PAGE IS SWAPPED WITH THE BODY OF THE PROCESS TO RESERVE
;	SPACE FOR IT IN THE SWAP IMAGE AND IS LATER WRITTEN WITH CORRECT 
;	CONTENT BY THE MODIFIED PAGE WRITER TO THIS RESERVED SPACE IN THE
;	SWAP IMAGE.
;
PROCVALID:				; PROCESS VALID PAGE
	.ENABL	LSB
10$:					;
	BBSC	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],20$	; BR IF PAGE MODIFIED
	BBC	#PTE$V_MODIFY,(R3),30$	; BR IF PAGE NOT MODIFIED
20$:	BBSS	#WSL$V_MODIFY,(FP),30$	; SET WORKING SET MODIFIED BIT
30$:					;
	CMPW	#1,@W^PFN$AW_REFCNT[R0]	; CHECK FOR I/O OUTSTANDING
	BEQL	40$			; NO, NONE
	BLBC	R2,SETWRTBAK		; BRANCH IF TRANSITION PAGE
	BBC	#WSL$V_MODIFY,(FP),40$	; DONT WRITE UNMODIFIED PAGES
SETWRTBAK:				; SET PAGE FOR WRITE BACK TO SWAP FILE
	SUBL3	R11,R9,R1		; GET OFFSET TO PAGE IN SWAP MAP
	DIVL	#4,R1			; SCALE BACK TO PAGE NUMBER
	MOVW	R1,@W^PFN$AW_SWPVBN[R0]	; SET OFFSET INTO SWAP IMAGE LESS APTCNT
40$:					;
	BISL3	R0,R10,(R9)+		; PUT PAGE IN SWAPPER MAP
;
;	SET DELETE CONTENT FLAG TO CAUSE PAGE TO BE PLACED AT HEAD
;	OF FREE PAGE LIST AND CONTENT FORGOTTEN.
;
DELCON:	BISB	#PFN$M_DELCON,@W^PFN$AB_STATE[R0] ; SET TO DELETE CONTENT
	RSB				; RETURN FOR NEXT PAGE
	.DSABL	LSB			;

WSLERR:	BUG_CHECK IVWSETLIST,FATAL	; INVALID WORKING SET LIST ENTRY

	.PAGE
	.SBTTL	PAGE TABLE WORKING SET LIST ENTRIES
;
;	PAGE TABLE AND PROCESS HEADER ENTRIES IN THE WORKING SET LIST
;	ARE IGNORED DURING THE PROCESS BODY OUTSWAP SCAN OF THE WORKING
;	SET LIST.
;
PPGTBLTRANS:				; TRANSITION PAGE TABLE
PPGTBLVALID:				; VALID PAGE TABLE
	INCW	PCB$W_APTCNT(R4)	; ACCUMULATE ACTIVE PAGE TABLE COUNT
	SUBL	R5,(FP)			; UNBIAS WSL VA FOR PAGE TABLE
	BBSS	#VA$V_SYSTEM,(FP),10$	; BUT FORCE SYSTEM BIT ON IN VA
10$:	RSB				; RETURN

	.PAGE
	.SBTTL	INSWAP
;------------------------------------------------------------------------------
;	PERFORM REQUESTED INSWAP
;
;	INPUTS:
;		R4 - PCB ADDRESS OF INSWAP CANDIDATE
;------------------------------------------------------------------------------

INSWAP:					; PERFORM INSWAP
	MOVL	PCB$L_PHD(R4),R5	; GET CURRENT PROCESS HEADER SLOT
	BEQL	10$			; NONE, MUST ALLOCATE ONE
	MOVZWL	PHD$W_PHVINDEX(R5),R8	; GET BALANCE SLOT INDEX
	BRB	40$			; AND CONTINUE
10$:	CLRL	R8			; INIT INDEX FOR BALANCE SLOT SEARCH
20$:	TSTW	@W^PHV$GL_REFCBAS[R8]	; CHECK FOR EMPTY
	BLSS	30$			; YES, GOT ONE
	AOBLSS	SGN$GL_BALSETCT,R8,20$	; TRY ALL BALANCE SET SLOTS
	ROTL	#31,#1,FP		; SET FLAG TO PERMIT OUTSWAPPING
					; OF PROCESSES
	BRW	OUTSWAP			; OUTSWAP IF NECESSARY TO GET SLOT
30$:	MOVW	PCB$L_PID(R4),@W^PHV$GL_PIXBAS[R8]	; SET PIX FOR BALANCE SET SLOT
	CLRW	@W^PHV$GL_REFCBAS[R8]	; AND BUMP REFERENCE COUNT
	MULL3	W^SWP$GL_BSLOTSZ,R8,R0	; COMPUTE BALANCE SLOT OFFSET
	ROTL	#9,R0,PCB$L_PHD(R4)	; MAKE BYTE OFFSET 
					; POSITIVE UNTIL I/O COMPLETE
40$:	CLRL	R9			; INITIALIZE SWAPPER MAP INDEX
50$:	BSBW	MMG$ALLOCPFN		; ALLOCATE A PAGE
	TSTL	R0			; MAKE SURE IT WAS ALLOCATED
	BGEQ	60$			; YES, CONTINUE
	BUG_CHECK INSNFREPAG,FATAL	; INSUFFICIENT FREE PAGES
60$:	INCW	@W^PFN$AW_REFCNT[R0]	; REFERENCE PAGE
	MOVB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0]	; AND MARK IT ACTIVE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,@W^SWP$GL_MAP[R9] ; MARK VALID, WRITABLE
	AOBLSS	R10,R9,50$		; REPEAT FOR ALL REQUIRED PAGES
	CLRL	@W^SWP$GL_MAP[R9]	; PUT STOPPER IN LIST
;
;	ALL PAGES HAVE NOW BEEN ACQUIRED AND A BALANCE SET SLOT
;	ALLOCATED.  THE INSWAP I/O OPERATION CAN NOW BE PERFORMED.
;
	INCW	W^SWP$GW_BALCNT		; ADD ONE PROCESS TO BALANCE SET
	MOVL	R4,W^SWP$GL_INPCB	; SAVE POINTER TO IN SWAP PCB
	MOVL	R10,W^SWP$GL_ISPAGCNT	; SAVE COUNT OF ALLOCATED PAGES
	MOVW	R8,W^SWP$GW_IBALSETX	; AND BALANCE SET SLOT NUMBER
;--------------------------------------------------------------------
;
;	PERFORM INSWAP I/O OPERATION
;
;--------------------------------------------------------------------

	MOVL	PCB$L_WSSWP(R4),R2	; GET SWAP IMAGE DISK ADDRESS
	BLEQ	COPYSHELL		; BRANCH IF SHELL IN SWAP
	BBC	#PCB$V_PHDRES,PCB$L_STS(R4),70$	; SWAP EVERYTHING IF HEADER NON-RES
	MOVZWL	PCB$W_APTCNT(R4),R0	; GET ACTIVE PAGE TABLE COUNT
	ADDL	R0,R2			; ADD PAGE TABLE COUNT
70$:	MOVAL	@W^SWP$GL_MAP,R3	; SVA OF PAGE TABLE FOR I/O
	MOVL	R10,R4			; NUMBER OF PAGES TO READ
	ADDL2	R10,W^SWP$GL_ISWPPAGES	; UPDATE TOTAL PAGES INSWAPPED
	INCL	W^SWP$GL_ISWPCNT	; BUMP INSWAP COUNTER
	BSBW	SWPREAD			; PERFORM READ
	BLBS	R0,80$			; BRANCH IF NO ERROR IN READ
	BUG_CHECK	INSWAPERR,FATAL	; **** BUGCHECK ON I/O ERROR
80$:	BRW	SETUP			; SET UP PROCESS IN BALANCE SLOT

COPYSHELL:
	MOVAL	W^MMG$AL_SYSPCB,R4	; ADDRESS OF SYSTEM PCB
	MOVL	PCB$L_PHD(R4),R5	; ADDRESS OF SYSTEM PROCESS HEADER
	MOVL	W^SWP$GL_SHELIO,R6	; GET I/O PAGE COUNT FOR SHELL
	MOVAB	L^SWP$GL_SHELLBAS,R2	; GET ADDRESS OF SHELL
	BSBW	MMG$SVAPTECHK		; GET ADDRESS OF PAGE TABLE ENTRY
	PUSHR	#^M<R3,R6>		; SAVE SVAPTE AND PAGE COUNT FOR LATER
	CLRL	R8			; SET FLAG INDICATING NO I/O NEEDED
	MOVZWL	#256+3,R7		; SET FLAGS TO LOCK ONLY VALID OR
					; TRANSITION PAGES AND CREATE OTHERS
					; WITHOUT ZEROING THE PHYSICAL PAGE
	MOVB	#WSL$C_SYSTEM,R2	; SET PAGE TYPE IN LOW BITS
	BISB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; PREVENT FREWLSE MWAIT
10$:	BSBW	MMG$IOLOCKPAG		; LOCK THE PAGE INTO SYSTEM WORKING SET
	BLBS	R0,20$			; BRANCH IF SUCCEEDED
	BUG_CHECK INSNFREPAG,FATAL	; INSUFFICIENT FREE PAGES
20$:	BISB	R0,R8			; SET FLAG (BIT 1) IF WE HAVE TO I/O IT
	MOVAB	512(R2),R2		; BUMP VA TO NEXT PAGE
	ADDL	#4,R3			; BUMP PTE TO NEXT ENTRY
	SOBGTR	R6,10$			; LOOP THROUGH THE PAGES
	POPR	#^M<R3,R4>		; RECOVER SVAPTE AND PAGE COUNT
	BBC	#1,R8,40$		; BRANCH IF ALL SHELL PAGES IN MEMORY
	BICB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; ALLOW FREWLSE MWAIT
	CLRL	R2			; SHELL IS PAGE FILE 0 AND VBN 0
	BSBW	SWPREAD			; PERFORM SHELL READ
	BLBS	R0,30$			; BRANCH IF NO ERROR IN READ
	BUG_CHECK INSWAPERR,FATAL	; **** BUGCHECK ON I/O ERROR
30$:	BISB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; PREVENT FREWLSE MWAIT
40$:	SETIPL	#IPL$_ASTDEL		; ALLOW RESCHEDULE AND PAGEFAULTS WHILE
					; COPYING SHELL BUT NOT COMPLETION ASTS
	MOVL	W^SWP$GL_SHELIO,R6	; GET I/O PAGE COUNT FOR SHELL
	MOVAB	L^SWP$GL_SHELLBAS,R7	; GET ADDRESS OF SHELL
	ASHL	#9,R6,R0		; GET BYTE COUNT
	CLRL	R1			; FORM DESTINATION VA
	MOVC3	R0,(R7),(R1)		; COPY THE SHELL TO LOCATION 0
	SETIPL	#IPL$_SYNCH		; BACK TO BLOCKING IPL
	BICB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; ALLOW FREWLSE MWAIT
	MOVQ	R6,R1			; SET UP COUNT AND VA OF SHELL AGAIN
	BSBW	MMG$SVAPTECHK		; GET ADDRESS OF PAGE TABLE ENTRY
	BSBW	MMG$UNLOCK		; DROP THE REFERENCE COUNTS
					; CONTINUE PROCESS CREATION
	.PAGE

;--------------------------------------------------------------------
;
;	SET UP PROCESS IN BALANCE SET SLOT
;
;--------------------------------------------------------------------

SETUP:					; SETUP INSWAP PROCESS
	BSBW	OSINIT			; INIT REGISTERS
	MOVL	W^SWP$GL_INPCB,R4	; GET PCB ADDRESS OF INSWAP PROCESS
	TSTL	PCB$L_PHD(R4)		; CHECK FOR NEWLY ALLOCATED PHD
	BLSS	10$			; BR IF NOT
	ADDL	W^SWP$GL_BALBASE,PCB$L_PHD(R4)	; AND SET ADDRESS IN PCB
10$:	TSTL	PCB$L_WSSWP(R4)		; CHECK FOR SHELL INSWAP
	BGTR	NOTSHELL		; BR IF NOT
	INVALID				; CLEAR TRANSLATION BUFFER
	JSB	@#SWP$SHELINIT		; CALL SHELL INITIALIZATION
					; WHICH RETURNS WITH A FULLY INITED PHD
NOTSHELL:				;
	MOVZWL	W^SWP$GW_IBALSETX,R8	; AND BALANCE SET INDEX
	MULL3	W^SWP$GL_BSLOTSZ,R8,R7	; COMPUTE OFFSET TO THIS SLOT
	MOVAL	@W^SWP$GL_BALSPT[R7],R7	; FORM BASE ADDRESS OF MAP FOR SLOT
	MOVL	R7,R3			; NOW POINT TO PROCESS HEADER
	BBSS	#PCB$V_PHDRES,PCB$L_STS(R4),5$	; SKIP IF PROCESS HEADER STILL RESIDENT
	INCL	W^SWP$GL_HISWPCNT	; COUNT SWAPS INCLUDING HEADER
	BSBW	FILLPHD			; SET INTO SPT ENTRIES
;
;	FILLPHD RETURNS WITH R5 POINTING TO THE PROCESS HEADER POSITION
;	WITHIN ITS P0 SPACE.
;
	MOVW	R8,PHD$W_PHVINDEX(R5)	; SET BALANCE SLOT INDEX
	ADDL	PCB$L_PHD(R4),PHD$L_P0BR(R5)	; RELOCATE P0 BASE REGISTER
	ADDL	PCB$L_PHD(R4),PHD$L_P1BR(R5)	; RELOCATE P1 BASE REGISTER
	BBSS	#PHD$V_NOACCVIO,PHD$W_FLAGS(R5),5$ ; INDICATE PHD INSWAP TO PAGER
5$:	EXTZV	#0,#PTE$S_PFN,(R7),R0	; GET PHYSICAL ADDRESS OF PCB
	ROTL	#9,R0,R0		; AND SET IN SOFTWARE PCB
	MOVAB	PHD$L_PCB(R0),PCB$L_PHYPCB(R4)	; ADD OFFSET TO HW PCB
;
;	NOW SET PAGES FROM WORKING SET LIST INTO PAGE TABLE ENTRIES
;
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS
	INVALID				; CLEAR TRANSLATION BUFFER TO SEE IT
;
;	A WINDOW IN P1 SPACE IS DOUBLE MAPPED TO ALL OF THE PROCESS
;	HEADER EXCEPT FOR THE PAGE TABLES. THIS PERMITS REFERENCE TO 
;	MOST OF THE PROCESS HEADER WHILE RUNNING AT IPL LESS THAN THE
;	SCHEDULER.  TO REFERENCE THE PROCESS HEADER IN SYSTEM SPACE
;	A PROCESS(OTHER THAN THE SWAPPER) MUST RAISE TO IPL$_SYNCH.
;

	MOVL	SWP$GL_PHDBASVA,R2	; VIRTUAL ADDRESS OF PHD WINDOW
	BSBW	MMG$SVAPTECHK		; GET POINTER TO WINDOW PTE
	MOVL	W^SGN$GL_PHDPAGCT,R2	; SET COUNT OF PAGES FOR WINDOW
	MOVL	#<PTE$C_URKW!PTE$M_VALID>,R1	; SKELETON PTE
10$:	MOVL	(R7)+,R0		; GET SWAPPER PTE FOR PHD
	BLSS	20$			; BR IF VALID PAGE
	CLRL	(R3)+			; NO, SET NO ACCESS
	BRB	30$			;
20$:	INSV	R0,#PTE$V_PFN,#PTE$S_PFN,R1	; AND INSERT PFN INTO WINDOW PTE
	MOVL	R1,(R3)+		; STORE IN WINDOW AND ADVANCE TO NEX PTE
30$:	SOBGTR	R2,10$			; MAP ENTIRE PHD WINDOW
;
;	THE REMAINING LIST OF PAGES READ BY THE SWAPPER ARE NOW PROCESSED
;	ACCORDING TO THE CONTENT OF THE WORKING SET LIST IN THE HEADER OF
;	THE INSWAP PROCESS.  THE DISPOSITION OF EACH INSWAP PAGE DEPENDS
;	ON ITS TYPE AND WHETHER THE PAGE IS ALREADY PRESENT IN WHICH CASE
;	THE NEW, REDUNDANT COPY IS DISCARDED.  SHARED PAGES READ FROM THE
;	SWAP IMAGE WHICH ARE NOT ALREADY RESIDENT BECOME THE MASTER COPY
;	AS WELL AS SATISFYING THE REQUIREMENT OF THE INSWAP PROCESS.
;
	ROTL	#PTE$V_VALID,#1,R11	; FORM VALID MASK
	MOVZWL	PHD$W_WSLIST(R5),R6	; INDEX TO START OF PERM ENTRIES
	MOVZWL	PHD$W_WSLAST(R5),R7	; POINTER TO LAST WS ENTRY
	.ENABL	LSB			;
WSLOOP:	MOVL	(R5)[R6],R2		; GET A WORKING SET ENTRY
	BSBB	10$			; AND PROCESS IT
	AOBLEQ	R7,R6,WSLOOP		; SCAN ENTIRE WORKING SET LIST
5$:	BICL3	R10,(R9)+,R0		; GET AND RELEASE EXCESS PAGES
	BEQL	7$			; BR IF NO MORE
	BSBW	RELPAGE			; RELEASE AN EXCESS PAGE
	BRB	5$			; AND TRY FOR ANOTHER
7$:	BRW	SETASTLVL		; END OF WORKING SET LIST
	ASSUME	WSL$V_VALID EQ 0	; FOR USE OF BLBS
10$:	BLBS	R2,20$			; CHECK FOR VALIDITY, BR IF VALID
15$:	RSB				; GET NEXT WSL ENTRY IF NOT VALID
17$:	ADDL	R5,R2			; REBIAS VA FOR WSL ENTRY
	BISL3	R11,R2,(R5)[R6]		; AND SET SYSTEM BIT IN VA
18$:	RSB				; NEXT WORKING SET LIST ENTRY
20$:					;
	BLSS	17$			; SKIP PAGE TABLE ENTRIES
	BSBW	MMG$SVAPTECHK		; GET SVA OF PTE FOR PAGE
;
;	R0 - ALL BITS EXCEPT PFN FIELD ARE CLEAR
;	R2 - WS LIST ENTRY
;	R3 - SVA OF PTE
;	R4 - INSWAP PROCESS PCB
;	R5 - PHD ADDRESS FOR INSWAP PROCESS
;	R6 - WORKING SET INDEX
;	R7 - END INDEX TO WORKING SET
;	R8 - BALANCE SET SLOT INDEX
;	R9 - ADDRESS OF PHYSICAL PAGE POINTER IN SWP$AL_MAP
;	R10 - PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY
;	R11 - CONSTANT PFN$M_VALID
;
	BICL3	R10,(R9)+,R0		; GET PFN FROM MAP
	BNEQ	30$			; GOT A GOOD PFN
	BUG_CHECK ZEROPAGE,FATAL	; ZERO PAGE TABLE ENTRY FROM SWAP MAP
30$:	MOVL	(R3),AP			; GET CONTENT OF PTE
	BGEQ	35$			; PTE VALID => PFN LOCK, NOT SWAPPED
;
; IF THE PAGE IS VALID, IT MUST HAVE BEEN LOCKED IN MEMORY AND WAS IGNORED AT
; OUTSWAP.  THE REDUNDANT PAGE ALLOCATED FOR THIS WORKING SET LIST ENTRY MUST
; BE RELEASED AFTER ALL WORKING SET LIST ENTRIES ARE PROCESSED.  NO OTHER 
; ACTION IS NEEDED SINCE THE PTE FOR THE LOCKED PAGE IS ALREADY CORRECT.
; THE PFN THAT WOULD HAVE MATCHED THIS ENTRY REALLY BELONGS TO THE NEXT
; WSL WITHOUT PFNLOCK SET, SO THE MAP POINTER IN R9 MUST BE BACKED UP FOR
; ANOTHER TRY.
;
	BBC	#WSL$V_PFNLOCK,R2,32$	; ERROR IF PAGE NOT LOCKED IN MEMORY
	TSTL	-(R9)			; BACK UP IN SWAPPER MAP
	RSB				; AND CONTINUE WITH NEXT WSL
32$:	BUG_CHECK	ICPAGELOC,FATAL	; INCONSISTENT PTE/WSL
35$:	BBC	#PTE$V_TYP1,AP,NTYP1	; BR IF NOT TYPE 1
	MOVL	R3,@W^PFN$AL_PTE[R0]	; NOTE LOCATION OF PTE
		PFN_REFERENCE	-
	MOVW	<R6,@W^PFN$Ax_WSLX[R0]>,-	; AND POSITION IN WORKING SET
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
	EXTZV	#PFN$V_BAK,#PFN$S_BAK,(R3),R1 ; GET BACKING ADR FROM PTE
	BBS	#PTE$V_TYP0,R1,40$	; BR IF SECTION ADDRESS
	INSV	PHD$B_PAGFIL(R5),#PFN$V_PGFLX,#PFN$S_PGFLX,R1
					; SET PAGING FILE NUMBER
40$:	MOVL	R1,@W^PFN$AL_BAK[R0]	; STORE BACKING ADDRESS
	MOVB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0]; SET PAGE ACTIVE
RECONNECT:				; RECONNECT TO PAGE
	BICL3	#^C<PTE$M_PROT!PTE$M_OWN>,(R3),R1	; RETAIN PERMANENT BITS
	MOVAL	(R5)[R6],R2		; GET ADDRESS OF WORKING SET LIST ENTRY
	BBCC	#WSL$V_MODIFY,(R2),50$	; CHECK FOR MODIFIED AND CLEAR
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; RECORD MODIFY STATE
50$:	BISL	R11,R1			; SET VALID BIT FOR PTE
	BISL3	R0,R1,(R3)		; MERGE BITS WITH PFN  AND STORE IN PGTBL
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1	; GET VPN OF PAGE TABLE
	INSV	@W^MMG$GL_SPTBASE[R1],#0,#PTE$S_PFN,R0	; GET PT PFN
					; ASSUMES HIGH ORDER BITS OF R0 ARE CLEAR
		PFN_REFERENCE	-
	TSTW	<@W^PFN$Ax_SHRCNT[R0]>,-	; CHECK FOR FIRST ACTIVE PAGE
		LONG_OPCODE=TSTL,-
		IMAGE=SYS_NONPAGED
	BNEQ	60$			; NO, JUST RAISE SHARE COUNT FOR PT
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R0],R1>,-	; GET INDEX TO WSL ENTRY FOR PAGE TABLE
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BISL	#WSL$M_WSLOCK,(R5)[R1]	; AND MARK IT LOCKED IN WORKING SET
	INCW	PHD$W_PTCNTACT(R5)	; COUNT ANOTHER ACTIVE PAGE TABLE
	INCW	@W^PHV$GL_REFCBAS[R8]	; RAISE REFERENCE COUNT OF BALANCE SLOT
60$:					;
		PFN_REFERENCE	-
	INCW	<@W^PFN$Ax_SHRCNT[R0]>,-	; INDICATE ANOTHER ACTIVE PAGE FOR PT
		LONG_OPCODE=INCL,-
		IMAGE=SYS_NONPAGED
	RSB				; RETURN TO GET NEXT WSL ENTRY
	.DSABL	LSB			;
NTYP1:					; GLOBAL OR TRANSITION
	BBS	#PTE$V_TYP0,AP,11$	; BR IF GLOBAL PAGE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,AP,FP	; GET OLD PFN IF ANY
	BEQL	12$			; BR IF ZERO PAGE (BUG CHECK)
;
;	RELEASE PFN FOR PAGE ALREADY PRESENT
;
	BSBW	RELPAGE			; RELEASE DUPLICATE PAGE
	MOVL	FP,R0			; GET SAVED PFN
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],R2
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	ASSUME	PFN$C_MFYPAGLST EQ 1	;
	ASSUME	PFN$C_BADPAGLST EQ 2	;
	ASSUME	PFN$C_RELPEND	EQ 3	;
	ASSUME	PFN$C_RDERR	EQ 4	;
	ASSUME	PFN$C_WRTINPROG	EQ 5	;
	ASSUME	PFN$C_RDINPROG	EQ 6	;
	ASSUME	PFN$C_ACTIVE	EQ 7	;
	CASE	R2,<-			; DISPATCH ON PAGE LOCATION
		20$,-			; 0 => FREE PAGE LIST
		20$,-			; 1 => MODIFIED PAGE LIST
		60$,-			; 2 => BAD PAGE LIST, PAGE READ/WRITE ERR
		30$,-			; 3 => RELEASE PENDING
		10$,-			; 4 => PAGE READ ERROR
		30$,-			; 5 => WRITE IN PROGRESS
		40$,-			; 6 => READ IN PROGRESS
		30$>			; 7 => ACTIVE ( I/O NOT YET COMPLETE

10$:	BUG_CHECK ICPAGELOC,FATAL	; INCONSISTENT PAGE LOCATION

11$:	BRW	GLOBAL			; GLOBAL PAGE
12$:	BUG_CHECK ZEROPAGE,FATAL	; ZERO PFN IN PTE

20$:	PUSHL	R3			; SAVE SVAPTE
	BSBW	MMG$REMPFN		; UNLINK PFN FROM FREE OR MODIFY LIST
	POPR	#^M<R3>			; RESTORE SVAPTE
	MOVAL	(R5)[R6],R2		; COMPUTE ADDRESS OF WSL ENTRY
30$:	BISL	R11,(R3)		; SET VALID BIT FOR PTE
	ASSUME	PFN$V_LOC EQ 0		; TO USE BISB INSTEAD OF INSV
	BISB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0]	;
40$:	BICB	#<PFN$M_DELCON!-	; CLEAR DELETE AND
		PFN$M_MODIFY>,-		; MODIFY
		@W^PFN$AB_STATE[R0]	; FLAGS
45$:	INCW	@W^PFN$AW_REFCNT[R0]	; RAISE REFERENCE COUNT
	CLRW	@W^PFN$AW_SWPVBN[R0]	; INDICATE NO ALTERNATE LOCATION
	MOVAL	(R5)[R6],R2		; COMPUTE ADDRESS OF WSL ENTRY
	BBCC	#WSL$V_MODIFY,(R2),50$	; CLEAR MODIFY BIT FOR WSL
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; RECORD PAGE AS MODIFIED
50$:		PFN_REFERENCE	-
	MOVW	<R6,@W^PFN$Ax_WSLX[R0]>,-	; SET WORKING SET LIST INDEX FOR PAGE
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
	RSB				; AND RETURN FOR NEXT PAGE
;
; PAGE IS ON THE BAD PAGE LIST.  IT HAS THE FOLLOWING POSSIBLE STATES
;	1) BADPAG BIT SET IN PFN$AB_TYPE => BUG_CHECK
;	2) SWPVBN CLEAR => PAGE WRITE ERROR, CORRECT COPY OF MODIFY BIT
;	   IS THE LOGICAL OR OF THE WSLE BIT AND THE PFN BIT
;	3) SWPVBN SET => PAGE READ ERROR, SET RDERR STATE.
;
60$:	BBS	#PFN$V_BADPAG,@W^PFN$AB_TYPE[R0],10$ ; ERROR IF BADPAG
	PUSHL	R3			; SAVE PTE ADDRESS
	BSBW	MMG$REMPFN		; UNLINK PFN FROM THE BAD PAGE LIST
	POPR	#^M<R3>			; RESTORE PTE ADDRESS
	MOVAL	(R5)[R6],R2		; COMPUTE ADDRESS OF WSL ENTRY
	TSTW	@W^PFN$AW_SWPVBN[R0]	; IF SWPVBN SET, THEN PAGE READ ERROR
	BNEQ	80$			; BRANCH IF PAGE READ ERROR
;
; PAGE WRITE ERROR
;
	ASSUME	PFN$V_MODIFY EQ 7
	TSTB	@W^PFN$AB_STATE[R0]	; IF PFN MODIFY BIT IS SET
	BGEQ	30$			;
	BBSS	#WSL$V_MODIFY,(R2),30$	; THEN JAM THE WSL ENTRY MODIFY BIT
	BRB	30$			; AND CONNECT TO THE PAGE
;
; PAGE READ ERROR
;
80$:	MOVB	#<PFN$M_DELCON ! PFN$C_RDERR>,- ; SET DELCON
		@W^PFN$AB_STATE[R0]	; AND PAGE READ ERROR STATE
	BICW	#<WSL$M_MODIFY>,(R2)	; CLEAN UP WSLE
	BRB	45$			; AND LEAVE PTE IN TRANSITION STATE
;
;	INSWAP GLOBAL PAGE
;
GLOBAL:					; GLOBAL PAGE INSWAP
	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,AP,R1	; GET GLOBAL PAGE TABLE INDEX
	MOVAL	@W^MMG$GL_GPTBASE[R1],R1	; AND CONVERT TO ADDRESS OF GPTE
	MOVL	(R1),R2			; PICK UP GLOBAL MASTER PTE
	BLSS	10$			; BR IF VALID
	BBS	#PTE$V_TYP0,R2,5$	; BR IF GLOBAL SECTION TYPE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R0	; GET PFN OF TRANSITION PAGE
	ASSUME	PFN$C_FREPAGLST EQ 0
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],R2	; TEST FOR FREE PAGE LIST
	BEQL	20$			; YES, REFAULT IT
	CMPB	#PFN$C_RDINPROG,R2	; IS IT READ IN PROGRESS
	BNEQ	6$			; NO, ERROR
	BRW	60$			; YES, WAIT FOR IT
5$:	BRB	50$			;
6$:	BUG_CHECK	ICPAGELOC,FATAL	; 

10$:					; INSWAP WITH VALID GLOBAL PAGE
	BSBW	RELPAGE			; RELEASE REDUNDANT PAGE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R0	; GET PFN FROM MASTER
	BRB	40$			; AND GO SETUP SLAVE PTE
20$:					; GLOBAL ON FREE LIST
	PUSHL	R0			; SAVE MASTER PFN
	BICL3	R10,-4(R9),R0		; GET REDUNDANT PFN
	BSBW	RELPAGE			; AND RELEASE IT (PRESERVING R1-R3)
	POPR	#^M<R0>			; RESTORE MASTER PFN
	BISL	R11,(R1)		; SET PAGE VALID
	PUSHR	#^M<R1,R3>		; SAVE SVAGPTE, SVAPTE
	BSBW	MMG$REMPFN		; REMOVE PFN FROM FREELIST
	POPR	#^M<R1,R3>		; RESTORE SVAGPTE, SVAPTE
	INSV	#PFN$C_ACTIVE,#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0]	;
	INCW	@W^PFN$AW_REFCNT[R0]	; RAISE REFERENCE COUNT
	BRB	40$			;
30$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R1,R1	; GET VPN OF PAGE TABLE
	MOVL	@W^MMG$GL_SPTBASE[R1],R1	; GET PAGE TABLE PTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R1,R1	; EXTRACT PFN 
		PFN_REFERENCE	-
	TSTW	<@W^PFN$Ax_SHRCNT[R1]>,-	; CHECK FOR FIRST REFERENCE TO PTABLE
		LONG_OPCODE=TSTL,-
		IMAGE=SYS_NONPAGED
	BNEQ	35$			; NO
	BUG_CHECK GBLPAGSZRO,FATAL	; GLOBAL PAGE SHARE COUNT ZERO
	INCW	@W^PFN$AW_REFCNT[R1]	; RAISE REFERENCE COUNT
	MOVL	SGN$GL_BALSETCT,R2	; POINT TO SYSTEM SLOT
	INCW	@W^PHV$GL_REFCBAS[R2]	; OTHERWISE RAISE SLOT COUNT
35$:		PFN_REFERENCE	-
	INCW	<@W^PFN$Ax_SHRCNT[R1]>,-	; RAISE GLOBAL PAGE TABLE SHARE COUNT
		LONG_OPCODE=INCL,-
		IMAGE=SYS_NONPAGED
40$:		PFN_REFERENCE	-
	INCW	<@W^PFN$Ax_SHRCNT[R0]>,-	; RAISE SHARE COUNT FOR GLOBAL PAGE
		LONG_OPCODE=INCL,-
		IMAGE=SYS_NONPAGED
	BRW	RECONNECT		; RECONNECT AND REFERENCE PAGE TABLE
50$:	EXTZV	#PFN$V_BAK,#PFN$S_BAK,R2,@W^PFN$AL_BAK[R0] ; SAVE BACKING ADDR
	BICL	#^C<PTE$M_PROT!PTE$M_OWN>,R2	; SAVE PROTECTION AND OWNER FIELDS
	BISL	R11,R2			; SET PTE VALID
	BISL3	R0,R2,(R1)		; AND STORE WITH PFN IN GPT
	MOVL	R1,@W^PFN$AL_PTE[R0]	; SET SVAGPTE IN PFN DATA BASE
	MOVB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ; SET STATE TO ACTIVE
	MOVB	#PFN$C_GLOBAL,@W^PFN$AB_TYPE[R0]  ; AND TYPE TO GLOBAL
	BRB	30$			; NOW GO SETUP SLAVE PTE

60$:	BISB	#PFN$M_COLLISION,@W^PFN$AB_TYPE[R0]	; FLAG COLLISION FOR PAGEREAD
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGS OVER WAIT
	MOVL	W^SCH$GL_CURPCB,R4	; AND SET PCB ADDRESS
	BSBW	SCH$NEWLVL		; SET ASTLVL CORRECTLY
	MOVAQ	W^SCH$GQ_COLPGWQ,R2	; GET ADDRESS OF WAIT QUEUE
	PUSHL	#0			; NULL KERNEL MODE PSL
	BSBW	SCH$WAITK		; WAIT WITH NO CALL FRAME
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGS
	BICL3	R10,-4(R9),R0		; RESTORE CURRENT PFN
	BRW	GLOBAL			; AND ATTEMPT TO REASSOCIATE PAGE


;
;	SET PROPER AST LEVEL
;
SETASTLVL:				;
	MOVAL	PCB$L_ASTQFL(R4),R3	; GET POINTER TO HEAD OF AST QUEUE
	MOVL	(R3),R2			; GET POINTER TO FIRST AST CONTROL BLOCK
	CMPL	R3,R2			; IS LIST EMPTY?
	BEQL	20$			; YES, DONE
	CLRL	R0			; ASSUME KERNEL MODE
	MOVB	ACB$B_RMOD(R2),R3	; GET ACTUAL MODE
	BLSS	10$			; BR IF SPECIAL KERNEL AST
	EXTZV	#ACB$V_MODE,#ACB$S_MODE,R3,R0 ; GET ACCESS MODE
	BICB3	PCB$B_ASTACT(R4),PCB$B_ASTEN(R4),R1	; CHECK FOR DELIVERABILITY
	BBC	R0,R1,20$		; BR IF NOT PRESENTLY DELIVERABLE
10$:	MOVB	R0,PHD$B_ASTLVL(R5)	; SET AST LEVEL FOR PROCESS
20$:	BISL	#<<1@PCB$V_RES>!<1@PCB$V_INQUAN>>,PCB$L_STS(R4) ; MARK PROCESS RESIDENT
	MOVW	SCH$GW_QUAN,PHD$W_QUANT(R5)	; AND GIVE NEW QUANTUM
	MOVZBL	PCB$B_PRI(R4),R0	; GET CURRENT PRIORITY OF PROCESS
	SUBB3	R0,#31,R1		; COMPUTE EXTERNAL PRIORITY FOR COMPARE
	CMPB	R1,W^SYS$GB_DEFPRI	; IS THIS A "CRUNCHER"?
	BGTR	30$			; NO, CONTINUE
	MFPR	#PR$_TODR,R1		; GET CURRENT TIME OF DAY
	ADDL3	W^SCH$GL_SWPRATE,R1,W^SWP$GL_SWTIME ; SET NEW CRUNCHER INTERVAL
30$:	BSBW	SCH$CHSEP		; CHANGE TO RESIDENT COMPUTE
SWAPRETRY:				; RETRY SWAP SCHEDULING
	MOVL	W^SCH$GL_CURPCB,R4	; GET PCB ADDRESS
	BBSSI	#PCB$V_WAKEPEN,PCB$L_STS(R4),20$	; SET TO CANCEL HIBER
20$:
	.DSABL	LSB
SWAPEXIT:				; EXIT SWAPPER
	BBCC	S^#SCH$V_SIP,W^SCH$GB_SIP,10$	; CLEAR SWAP IN PROGRESS
10$:	
SWAPEXITA:				; ALTERNATE EXIT, LEAVING SIP SET
	POPR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>	; RESTORE REGISTERS
	SETIPL	#0			; DROP IPL
	RSB				;
	.PAGE
	.SBTTL	FILLPHD - FILL SPT ENTRIES TO MAP PHD
;++
; FUNCTIONAL DESCRIPTION:
;	FILLPHD SETS THE PTE ENTRIES FOR THE PROCESS HEADER INTO THE
;	SPT.
;
; CALLING SEQUENCE:
;	BSB/JSB	FILLPHD
;
; INPUT PARAMETERS:
;	R3  -  POINTER TO FIRST SPT ENTRY FOR PHD
;	R9  -  ADDRESS OF SWAPPER MAP ENTRY TO BE MOVED TO SPT
;	R10 -  PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY
;
; OUTPUT PARAMETERS:
;	R5 - ZERO
;	R6 - DESTROYED
;	R9 - UPDATED
;	R11 - DESTROYED
;	AP - DESTROYED
;	FP - DESTROYED
;--

FILLPHD:				;

	CLRL	R5			; SET PHD ADDRESS TO SWAPPER P0 SPACE
	INVALID				; TO SEE CORRECT PROCESS HEADER IN SWAPPER P0
	CLRL	R11			; INIT HEADER PAGE INDEX 
	MOVZWL	PHD$W_EMPTPG(R5),R6	; GET COUNT OF EMPTY PAGES
	ASHL	#9,R6,R6		; CONVERT TO BYTE OFFSET
	MOVZWL	PHD$W_WSLX(R5),AP	; FORM BASE ADDRESS FOR WSLX
	MOVAL	(R5)[AP],AP		; SAVE VECTOR FOR PHD
	MOVZWL	PHD$W_BAK(R5),FP	; FORM BASE ADDRESS FOR BACKING STORE ADDRESS
	MOVAL	(R5)[FP],FP		; VECTOR
	SUBL	R6,AP			; ACCOUNT FOR EMPTY PAGES
	SUBL	R6,FP			; BY SUBTRACTING THEIR SPACE
	MOVL	W^SWP$GL_BSLOTSZ,R6	; SET ITERATION COUNT FOR ENTIRE HEADER
10$:	MOVL	(FP)+,(R3)+		; SET BACKUP FORM OF PTE IN SPT SLOT
	BGEQ	30$			; DONE IF NOT VALID
	BICL3	R10,(R9)+,R0		; GET PAGE FROM SWAPPER MAP
	MOVAL	-(R3),@W^PFN$AL_PTE[R0]	; SET PTE BACK POINTER
	EXTZV	#PFN$V_BAK,#PFN$S_BAK,(R3),R1	; ISOLATE BACKING STORE ADDRESS
	INSV	PHD$B_PAGFIL(R5),#PFN$V_PGFLX,#PFN$S_PGFLX,R1	; ADD FILE NUMBER
	MOVL	R1,@W^PFN$AL_BAK[R0]	; SAVE IN PFN DATA BASE
		PFN_REFERENCE	-
	MOVW	<(AP)[R11],@W^PFN$Ax_WSLX[R0]>,-	; SAVE WORKING SET LIST INDEX
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
	BISL3	R0,R10,(R3)+		; SET VALID PTE FOR PAGE
	MOVB	#<PFN$C_ACTIVE!PFN$M_MODIFY>,@W^PFN$AB_STATE[R0] ; MARK PAGE ACTIVE
	MOVB	#PFN$C_PPGTBL,@W^PFN$AB_TYPE[R0]	; STORE TYPE IN PFN DATA BASE
30$:	AOBLSS	R6,R11,10$		; FILL ENTIRE PROCESS HEADER
	RSB


	.PAGE
	.SBTTL	RELINIT - INITIALIZE REGISTERS FOR PAGE RELEASE LOOP
;++
; FUNCTIONAL DESCRIPTION:
;	RELINIT SETS UP REGISTERS FOR THE PAGE RELEASE LOOPS FOLLOWING
;	OUTSWAP I/O OPERATIONS.
;
; CALLING SEQUENCE:
;	BSB/JSB	RELINIT
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R0  -  0
;	R4  -  OUT SWAP PCB ADDRESS (OSWPPCB)
;	R7  -  PAGE COUNT TO RELEASE
;	R9  -  BASE ADDRESS FOR SWAPPER MAP (SWP$AL_MAP)
;	R10 -  PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY
;	R11 -  BASE ADDRESS FOR SWAPPER MAP (SWP$AL_MAP)
;
;--

RELINIT:				; RELEASE LOOP INITIALIZATION
	MOVL	W^OSWPPCB,R4		; GET PCB ADDRESS OF OUT SWAP PROCESS
	MOVZWL	W^OSWPPGS,R7		; AND PAGE COUNT FOR RELEASE LOOP
;	BRB	OSINIT			; FALL INTO OSINIT
	.PAGE
	.SBTTL	OSINIT - OUTSWAP SCAN REGISTER INITIALIZATION
;++
; FUNCTIONAL DESCRIPTION:
;	OSINIT SETS UP REGISTERS FOR PAGE TABLE SCANS REQUIRED DURING
;	OUTSWAPPING.
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R9 - BASE ADDRESS OF SWAPPER MAP (SWP$AL_MAP)
;	R10 - PTE$C_ERKW!PTE$M_VALID
;	R11 - BASE ADDRESS OF SWAPPER MAP (SWP$AL_MAP)
;
;--

OSINIT:					;
	MOVAL	@W^SWP$GL_MAP,R9		; SET BASE OF SWAPPER MAP
	MOVL	R9,R11			; AND MAKE REFERENCE COPY
	MOVL	#<PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY>,R10 ; MASK TO VALIDATE SWAP PTE
	RSB				; RETURN
	.PAGE
	.SBTTL	RELPAGE - RELEASE DUPLICATE PAGE
;++
; FUNCTIONAL DESCRIPTION:
;	RELPAGE RELEASES A PHYSICAL PAGE WHICH DUPLICATES A PAGE ALREADY
;	PRESENT FOR THE PROCESS.  THIS SITUATION CAN ARISE DUE TO A PARTIAL
;	INSWAP OR A GLOBAL PAGE WHICH IS ALREADY PRESENT.
;
; CALLING SEQUENCE:
;	BSB/JSB	RELPAGE
;
; INPUT PARAMETERS:
;	R0 - PFN TO RELEASE
;	R3 - SVA OF PTE (RELDELPAGE ONLY)
;
; OUTPUT PARAMETERS:
;	R1 - PRESERVED (RELPAGE ONLY)
;	R2 - PRESERVED (RELPAGE ONLY)
;	R3 - PRESERVED (RELPAGE ONLY)
;
;--


RELDELPAGE:				; RELEASE PAGE THROUGH DELCONPFN
	BSBW	MMG$DELCONPFN		; DELETE PAGE CONTENT AND INIT PFN DATA
RELPAGE:				; RELEASE PAGE
	PUSHR	#^M<R1,R2,R3>		; PRESERVE REGISTERS
	CLRB	@W^PFN$AB_STATE[R0]	; INIT PFN DATA FOR RELEASE
	CLRW	@W^PFN$AW_REFCNT[R0]	; ZERO REFERENCE COUNT
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	CLRL	R2			; INDICATE FREELIST
	BSBW	MMG$INSPFNH		; RELEASE PFN TO HEAD OF FREE LIST
	POPR	#^M<R1,R2,R3>		; RESTORE REGISTERS
	RSB				; AND RETURN TO CALLER

	.PAGE
	.SBTTL	SWPREAD/SWPWRITE - SWAPPER I/O ROUTINES
;++
; FUNCTIONAL DESCRIPTION:
;	SWPREAD AND SWPWRITE PERFORM THE DETAIL WORK REQUIRED TO READ
; 	OR WRITE A SET OF CONTIGUOUS PAGES IN A WORKING SET SWAP IMAGE.
;	THE CALL TO EITHER SWPREAD OR SWPWRITE IS ACTUALLY A CO-ROUTINE
;	CALL WHICH RETURNS ONLY AFTER ALL SEGMENTS OF THE I/O OPERATION
;	HAVE BEEN PERFORMED.  THIS RETURN IS EFFECTED BY A SPECIAL KERNEL
;	AST.
;
; CALLING SEQUENCE:
;	BSB/JSB	SWPREAD/SWPWRITE
;
; INPUT PARAMETERS:
;	R0 - SWAP FILE INDEX
;	R2 - WSSWP FORM DISK ADDRESS
;	R3 - SYSTEM VIRTUAL ADDRESS OF PTE
;	R4 - PAGE COUNT
;
;	00(SP) - RETURN ADDRESS AFTER I/O COMPLETION
;	04(SP) - SAVED R6
;	08(SP) - SAVED R7
;	12(SP) - SAVED R8
;	16(SP) - SAVED R9
;	20(SP) - SAVED R10
;	24(SP) - SAVED R11
;	28(SP) - SAVED AP
;	32(SP) - SAVED FP
;	36(SP) - SAVED IPL
;	40(SP) - RETURN TO PREVIOUS THREAD
;
; IMPLICIT INPUTS:
;	PAGE FILE TABLE ENTRY (PFL) SELECTED BY WSSWP INPUT
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS OF I/O OPERATION
;
;--

	.ENABL	LSB			
SWPREAD:				; SWAP READ INITIATION
	PUSHAB	W^EXE$BLDPKTSWPR	; SET ADDRESS OF BUILD PACKET ROUTINE
	BRB	10$			;
SWPWRITE:				; SWAP WRITE INITIATION
	PUSHAB	W^EXE$BLDPKTSWPW	; SET ADDRESS OF BUILD PACKET ROUTINE
10$:	MOVAB	W^IOROUTINE,R1		; ADDRESS OF I/O DATA
	MOVQ	(SP)+,(R1)+		; SAVE I/O END ACTION ADDRESS
	POPR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>; RESTORE REGISTERS OTHER THAN STANDARD SET
15$:	EXTZV	#24,#8,R2,R0		; GET SWAP FILE INDEX
	MOVL	@W^MMG$GL_PAGSWPVC[R0],R0; GET BASE ADDRESS OF PAGE FILE TABLE
	MOVZBL	#127,R5			; SET I/O SIZE
	CMPL	R4,R5			; COMPARE REMAINING PGCNT WITH MAX TRANSFER
	BGTR	20$			; USE MAXIMUM TRANSFER
	MOVL	R4,R5			; SET TRANSFER TO REMAINING PAGES
20$:	ADDL3	R5,R2,(R1)+		; SAVE UPDATED DISK ADDRESS
	MOVAL	(R3)[R5],(R1)+		; AND UPDATED SAVPTE
	SETIPL	#0			; DROP IPL
	SUBW3	R5,R4,(R1)		; SAVE REMAINING PAGE COUNT
	PUSHL	R3			; SAVE SVAPTE
	PUSHL	PFL$L_WINDOW(R0)	; GET WINDOW ADDRESS 
	ROTL	#9,R5,-(SP)		; CONVERT PAGES TO BYTE COUNT
	EXTZV	#0,#24,R2,-(SP)		; AND ISOLATE BLOCK NUMBER
	ADDL	PFL$L_VBN(R0),(SP)	; ADD BASE VBN
	MOVL	W^SCH$GL_CURPCB,R4	; SET PCB ADDRESS
	REMQUE	@W^IOC$GL_IRPFL,R5	; GET A PACKET IF POSSIBLE
	BVC	30$			; BR IF ONE AVAILABLE
	BSBW	EXE$ALLOCIRP		; ALLOCATE ONE THE LONG WAY
	MOVL	R2,R5			; SET PACKET ADDRESS IN PROPER REGISTER
30$:	MOVAB	B^IODONE,IRP$L_ASTPRM(R5); SET ADDRESS FOR COMPLETION
	SUBB3	W^SWP$GB_PRIO,#31,IRP$B_PRI(R5)	; SET PRIORITY FOR TRANSFER
	POPR	#^M<R0,R1,R2,R3>	; RESTORE VBN,BYTECNT,WINDOW,SVAPTE
	JSB	@W^IOROUTINE		; CALL READ OR WRITE ROUTINE
	RSB				; AND RETURN TO ORIGINAL CALLER

IODONE:					; CONTINUATION CALLED AS KERNEL AST
	PUSHL	IRP$L_MEDIA(R5)		; SAVE COMPLETION STATUS
	MOVL	R5,R0			; SET PACKET ADDRESS FOR RELEASE
	BSBW	EXE$DEANONPAGED		; AND RELEASE IT
	MOVL	(SP)+,R0		; RESTORE STATUS
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	BLBC	R0,60$			; EXIT IF ERROR
	MOVAB	W^RWSSWP,R1		; GET ADDRESS OF REMAINING TRANSFER PARAMS
	MOVQ	(R1),R2			; RESTORE WSSWP,SVAPTE TO R2,R3
	MOVZWL	B^<RPGCNT-RWSSWP>(R1),R4	; AND REMAINING PAGE COUNT
	BEQL	60$			; DONE IF NO MORE PAGES REMAIN
	BRW	15$			; CONTINUE IF MORE PAGES REMAIN
60$:	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>; SAVE NON-STANDARD REGISTERS
	JMP	@W^IOEA			; AND CONTINUE SWAP

	.DSABL	LSB			;
	.END
