
	.TITLE	MUTEX - MUTEX WAIT ROUTINES
	.IDENT	'V03-000'		;

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SCHEDULER
;
; ABSTRACT:
;	THIS MODULE CONTAINS THE ROUTINES WHICH IMPLEMENT THE MUTEX
;	LOCK AND UNLOCK SERVICES FOR INTERNAL EXECUTIVE USE.
;
;
; ENVIRONMENT:
;	MODE = KERNEL
;
;--
;
;	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:	R. HUSTVEDT  CREATION DATE: 25-AUG-76
;
; MODIFIED BY:
;
;	V02-004	KDM34943	KATHLEEN D. MORSE	13-JAN-1981
;		Save current and base priorities for all processes holding
;		a mutex and restore them when all mutexes are released.
;		For non real-time processes, set current and base priorities
;		to 16 while they hold a mutex.
;
;	V02-003	RIH0004		RICHARD I. HUSTVEDT	04-DEC-1980	08:45
;		Prevent loss of previous priority for multiple mutex case.
;
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$DYNDEF				; STRUCTURE TYPE DEFINITIONS
	$IPLDEF				; IPL DEFINITIONS
	$MTXDEF				; MUTEX DEFINITIONS
	$PCBDEF				; PCB DEFINITIONS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRIDEF				; PRIORITY INCR CLASS DEFS
	$PSLDEF				; PSL DEFINITIONS
	$SSDEF				; SYSTEM STATUS CODES
	$STATEDEF			; SCHEDULER STATE DEFS
	$WQHDEF				; WAIT QUEUE HEADER DEFS
;
; EQUATED SYMBOLS
;

	.PSECT	AEXENONPAGED,BYTE	; NONPAGED EXEC
	.PAGE
	.SBTTL	SCH$RWAIT - RESOURCE WAIT

;++
; FUNCTIONAL DESCRIPTION:
;	SCH$RWAIT SUSPENDS THE EXECUTION OF A PROCESS UNTIL REQUIRED
;	RESOURCES ARE AVAILABLE.
;
; CALLING SEQUENCE:
;	SETIPL/DSBINT #IPL$_SYNCH
;	PUSHL	<PSL>
;	BSB/JSB	SCH$RWAIT
;
; INPUT PARAMETERS:
;	R0 - RESOURCE NUMBER FOR WHICH TO WAIT
;	R4 - PCB ADDRESS
;	00(SP) - PC AT WHICH TO RESUME
;	04(SP) - PSL WITH WHICH TO RESUME
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEX WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;
; OUTPUTS:
;	R0-R3 PRESERVED
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--

SCH$RWAIT::				;;; RESOURCE WAIT ENTRY POINT
	BBSSI	R0,W^SCH$GL_RESMASK,10$	;;; SET WAITING FLAG
10$:	BRB	WAITR			;;; AND ENTER WAIT STATE

	.PAGE
	.SBTTL	SCH$LOCKWNOWAIT - LOCK MUTEX FOR WRITE WITHOUT WAITING

;++
; FUNCTIONAL DESCRIPTION:
;	SCH$LOCKWNOWAIT LOCKS THE SPECIFIED MUTEX FOR EXCLUSIVE WRITE ACCESS
;	TO THE PROTECTED STRUCTURE.  IF ANOTHER PROCESS HAS ALREADY CLAIMED
;	THE MUTEX, THEN THIS ROUTINE RETURNS A FAILURE INDICATION.
;
;
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$LOCKWNOWAIT
;
;
; INPUT PARAMETERS:
;	R0 - ADDRESS OF MUTEX
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEX WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	MUTEX LOCATED BY R0
;
; OUTPUTS:
;	R0 LOW BIT SET IF LOCKED SUCCESSFULLY
;	   LOW BIT CLEAR IF MUTEX IN USE
;	R1-R3 PRESERVED
;	IPL = ASTDEL
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--
SCH$LOCKWNOWAIT::
	SETIPL	#IPL$_SYNCH		;;; RAISE TO SYNCH IPL
	BBSSI	#MTX$V_WRT,(R0),20$	;;; SET WRITE PENDING
	INCW	MTX$W_OWNCNT(R0)	;;; RAISE OWNER COUNT
	BNEQ	10$			;;; RETURN FAILURE IF BUSY
	MOVZWL	#SS$_NORMAL,R0		;;; INDICATE SUCCESSFUL COMPLETION
	BRB	LKEX			;;; AND MERGE WITH COMMON EXIT CODE
10$:	DECW	MTX$W_OWNCNT(R0)	;;; CORRECT COUNT
20$:	CLRL	R0			;;; SET FAILURE RETURN INDICATION
	SETIPL	#IPL$_ASTDEL		;;; LOWER TO ASTDEL
	RSB				; AND RETURN
	.PAGE
	.SBTTL	SCH$IOLOCKW - LOCK I/O DATA BASE MUTEX FOR WRITE
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$IOLOCKW RETURNS TO THE CALLER WHEN THE I/O DATABASE MUTEX
;	HAS BEEN LOCKED FOR WRITE ASSURING EXCLUSIVE ACCESS.
;
;
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$IOLOCKW
;
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEX WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	I/O DATABASE MUTEX
;
; OUTPUTS:
;	R0 = ADDRESS OF I/O DATABASE MUTEX
;	R1-R3 PRESERVED
;	IPL = ASTDEL
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--
 
SCH$IOLOCKW::				; LOCK I/O DATA BASE FOR WRITE ACCESS
	MOVAB	IOC$GL_MUTEX,R0		; GET ADDRESS OF I/O DATABASE MUTEX
	.PAGE
	.SBTTL	SCH$LOCKW - LOCK MUTEX FOR WRITE
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$LOCKW RETURNS TO THE CALLER WHEN THE SPECIFIED MUTEX
;	HAS BEEN LOCKED FOR WRITE ASSURING EXCLUSIVE ACCESS TO THE
;	PROTECTED STRUCTURE.
;
;
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$LOCKW
;
;
; INPUT PARAMETERS:
;	R0 - ADDRESS OF MUTEX
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEX WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	MUTEX LOCATED BY R0
;
; OUTPUTS:
;	R0-R3 PRESERVED
;	IPL = ASTDEL
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--

SCH$LOCKW::				; LOCK MUTEX FOR WRITE
10$:	SETIPL	#IPL$_SYNCH		;;; RAISE TO SYNCH IPL
	BBSSI	#MTX$V_WRT,(R0),30$	;;; SET WRITE PENDING
	INCW	MTX$W_OWNCNT(R0)	;;; RAISE OWNER COUNT
	BNEQ	20$			;;; WAIT IF BUSY
	BRB	LKEX			;;; MERGE WITH COMMON EXIT CODE

20$:					;;; MUST WAIT FOR EXCLUSIVE USE
	DECW	MTX$W_OWNCNT(R0)	;;; CORRECT COUNT
30$:	BSBB	WAITM			;;; AND WAIT FOR MUTEX
	BRB	10$			; REPEAT LOCK ATTEMPT WHEN
					; RESCHEDULED
	.PAGE				;
	.SBTTL	SCH$IOLOCKR - LOCK I/O DATABASE MUTEX FOR READ
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$IOLOCKR RETURNS TO THE CALLER WHEN NO WRITERS OWN THE I/O
;	DATABASE MUTEX THUS ASSURING THE I/O DATABASE WILL REMAIN UN-
;	CHANGED UNTIL THE MUTEX IS RELEASED. IPL IS RAISED TO PREVENT
;	AST DELIVERY WHILE THE MUTEX IS OWNED AND THE PROCESS WILL NOT
;	BE OUTSWAPPED.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$IOLOCKR
;
; INPUT PARAMETERS:
;	R4 - CURRENT PROCESS PCB ADDRESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEX WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	I/O DATABASE MUTEX
;
; OUTPUTS:
;	R0 = ADDRESS OF I/O DATABASE MUTEX
;	R1-R3 PRESERVED
;	IPL = ASTDEL
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--
 
SCH$IOLOCKR::				; LOCK I/O DATABASE FOR READ ACCESS
	MOVAB	IOC$GL_MUTEX,R0		; GET ADDRESS OF I/O DATA BASE MUTEX
	.PAGE				;
	.SBTTL	SCH$LOCKR - LOCK MUTEX FOR READ
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$LOCKR RETURNS TO THE CALLER WHEN NO WRITERS OWN THE
;	SPECIFIED MUTEX.  THUS THE STRUCTURE PROTECTED BY THE MUTEX
;	WILL REMAIN UNCHANGED UNTIL THE MUTEX IS RELEASED.  IPL IS
;	RAISED TO PREVENT AST DELIVERY WHILE THE MUTEX IS OWNED AND
;	THE PROCESS WILL NOT BE OUTSWAPPED.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$LOCKR
;
; INPUT PARAMETERS:
;	R0 - ADDRESS OF MUTEX
;	R4 - CURRENT PROCESS PCB ADDRESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEX WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	MUTEX
;
; OUTPUTS:
;	R0-R3 PRESERVED
;	IPL = ASTDEL
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--

SCH$LOCKR::				; LOCK MUTEX FOR READ
	SETIPL	#IPL$_SYNCH		;;; RAISE TO SYNCH IPL
	BBS	#MTX$V_WRT,(R0),RDWAIT	;;; WAIT IF WRITE PENDING OR
					;;; IN PROGRESS
	INCW	MTX$W_OWNCNT(R0)	;;; INCREASE OWNER COUNT
LKEX:	CMPB	#DYN$C_PCB,PCB$B_TYPE(R4) ; CHECK FOR PCB
	BNEQ	20$			; BUG CHECK IF NOT PCB
	INCW	PCB$W_MTXCNT(R4)	;;; NOTE IN PCB ALSO
	CMPW	PCB$W_MTXCNT(R4),#1	; IS THIS THE FIRST MUTEX IT OWNS?
	BNEQ	10$			; BR IF OWNS MORE THAN 1 MUTEX
	MOVB	PCB$B_PRI(R4),PCB$B_PRISAV(R4); SAVE CURRENT PRIORITY
	MOVB	PCB$B_PRIB(R4),PCB$B_PRIBSAV(R4) ; SAVE BASE PRIORITY
	CMPB	#16,PCB$B_PRI(R4)	; IS THIS A REAL TIME PROCESS?
	BGTRU	10$			; BR IF SO
	MOVB	#15,PCB$B_PRI(R4)	; ELSE FORCE TO LOWEST RT PRIORITY
	MOVB	#15,PCB$B_PRIB(R4)	; AND SET PRIORITY BASE TO RT
10$:	SETIPL	#IPL$_ASTDEL		;;; DROP TO ASTDEL IPL
	RSB				;;; AND RETURN
20$:	BRW	NOTPCB			;

RDWAIT:					;;; MUST WAIT FOR READ
	PUSHAL	SCH$LOCKR		;;; RETRY AFTER WAIT

WAITM:					;;; WAIT FOR MUTEX TO FREE
	PUSHL	(SP)			;;; FORM PC, PSL ON STACK
	MOVPSL	4(SP)			;;; BUILD PSL
	INSV	#IPL$_ASTDEL,#PSL$V_IPL,#PSL$S_IPL,4(SP) ;;; SET IPL TO ASTDEL
WAITR:	MOVL	R0,PCB$L_EFWM(R4)	;;; SAVE ADDRESS OF MUTEX
	INSQUE	(R4),W^SCH$GQ_MWAIT	;;; INSERT AT HEAD OF WAIT QUEUE
	INCW	W^SCH$GQ_MWAIT+WQH$W_WQCNT	;;; INCREMENT COUNT IN QUEUE
	MOVW	#SCH$C_MWAIT,PCB$W_STATE(R4)	;;; SET STATE 
	BRW	SCH$WAITL		;;; WAIT WITH STACK CLEAN, STATE SET

	.PAGE
	.SBTTL	SCH$RAVAIL - DECLARE RESOURCE AVAILABILITY

;++
; FUNCTIONAL DESCRIPTION:
;	SCH$RAVAIL IS CALLED TO SIGNAL THE AVAILABILITY OF THE SPECIFIED
;	RESOURCE AND RELEASE ANY WAITING PROCESSES.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$RAVAIL
;
; INPUT PARAMETERS:
;	R0 - RESOURCE NUMBER
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--

SCH$RAVAIL::				; DECLARE RESOURCE AVAILABILITY
	BBCCI	R0,W^SCH$GL_RESMASK,EXIT	; CLEAR AND TEST WAITING FLAG
	DSBINT	#IPL$_SYNCH		;;; BLOCK SYSTEM EVENTS
	BRB	UNLOCK			;;; MERGE WITH COMMON CODE
	.PAGE
	.SBTTL	SCH$IOUNLOCK - UNLOCK I/O DATABASE MUTEX
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$IOUNLOCK RELEASES OWNERSHIP OF THE I/O DATABASE MUTEX AND
;	RE-ACTIVATES ANY WAITING PROCESSES IF THE MUTEX HAS BECOME
;	AVAILABLE AS A CONSEQUENCE OF THIS UNLOCK REQUEST.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$IOUNLOCK
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEXT WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	I/O DATABASE MUTEX
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--
 
SCH$IOUNLOCK::				; UNLOCK I/O DATABASE MUTEX
	MOVAB	IOC$GL_MUTEX,R0		; GET ADDRESS OF I/O DATABASE MUTEX
	.PAGE
	.SBTTL	SCH$UNLOCK - UNLOCK MUTEX
;++
; FUNCTIONAL DESCRIPTION:
;	SCH$UNLOCK RELEASES OWNERSHIP OF THE SPECIFIED MUTEX AND
;	RE-ACTIVATES ANY WAITING PROCESSES IF THE MUTEX HAS BECOME
;	AVAILABLE AS A CONSEQUENCE OF THIS UNLOCK REQUEST.
;
; CALLING SEQUENCE:
;	BSB/JSB	SCH$UNLOCK
;
; INPUT PARAMETERS:
;	R0 - MUTEX ADDRESS
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	SCH$GQ_MWAIT - MUTEXT WAIT QUEUE HEADER
;	PCB OF CURRENT PROCESS
;	MUTEX
;
; IMPLICIT OUTPUTS:
;	*** TBS ***
;
; SIDE EFFECTS:
;	*** TBS ***
;
;--

SCH$UNLOCK::				; UNLOCK MUTEX
	DSBINT	#IPL$_SYNCH		;;; RAISE TO SYNCH IPL
	CMPB	#DYN$C_PCB,PCB$B_TYPE(R4); STRUCTURE MUST BE PCB
	BNEQ	NOTPCB			;
	DECW	PCB$W_MTXCNT(R4)	;;; NOTE UNLOCK IN PCB
	BNEQ	10$			;;; MORE STILL OWNED 
	MOVB	PCB$B_PRIBSAV(R4),PCB$B_PRIB(R4) ; RESTORE SAVED BASE PRIORITY
	MOVB	PCB$B_PRISAV(R4),R1	; GET ORIGINAL PRIORITY
	MOVB	R1,PCB$B_PRI(R4)	; RESTORE IT
	MOVB	R1,W^SCH$GB_PRI		; AND ANNOUNCE IT
	FFS	#0,#32,W^SCH$GL_COMQS,R2; FIND PRIORITY OF NEXT COMPUTABLE PROCESS
	CMPB	R1,R2			; CHECK FOR DELAYED PREMPTION
	BLEQU	10$			; NO, CONTINUE
	SOFTINT	#IPL$_SCHED		; ELSE RESCHEDULE WHEN IPL DROPS
10$:	DECW	MTX$W_OWNCNT(R0)	;;; DECREMENT OWNERSHIP COUNT
	BGEQ	EXITN			;;; EXIT IF NOT LAST
	BBCCI	#MTX$V_WRT,(R0),EXITN	;;; EXIT IF NO WRITE IN PROGRESS
					;;; OR PENDING
UNLOCK:	PUSHR	#^M<R0,R4>		;;; SAVE PCB ADDRESS
	MOVAL	W^SCH$GQ_MWAIT,R3	;;; GET ADDRESS OF WAIT QUEU
	MOVL	(R3),R4			;;; AND HEAD PCB
	MOVZBL	#PRI$_RESAVL,R2		;;; SET PRIORITY INCREMENT CLASS
10$:	CMPL	R3,R4			;;; CHECK FOR END OF QUEUE
	BEQL	30$			;;; YES, DONE
	CMPL	(SP),PCB$L_EFWM(R4)	;;; IS PROCESS WAITING FOR THIS MUTEX
	BNEQ	20$			;;; NO, SKIP IT
	PUSHL	(R4)			;;; SAVE FLINK
	BSBW	SCH$CHSE		;;; CHANGE TO EXECUTABLE STATE
	DECW	WQH$W_WQCNT(R3)		;;; DECREASE QUEUE LENGTH
	POPR	#^M<R4>			;;; RESTORE FLINK
	BRB	10$			;;; AND CONTINUE
20$:	MOVL	(R4),R4			;;; FLINK ON TO NEXT PCB
	BRB	10$			;;; AND CONTINUE
30$:	POPR	#^M<R0,R4>		;;; RESTORE REGISTERS
EXITN:	ENBINT				;;; ENABLE INTERRUPTS
EXIT:	RSB				; AND RETURN

NOTPCB:	BUG_CHECK NOTPCB,FATAL		; STRUCTURE NOT PCB
	.END
