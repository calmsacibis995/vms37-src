	.TITLE	SYSPCNTRL PROCESS CONTROL SERVICES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, PROCESS CONTROL SYSTEM SERVICES
;
; ABSTRACT:
;	THIS MODULE CONTAINS THE ROUTINES WHICH IMPLEMENT THE PROCESS
;	CONTROL SERVICES, SUSPEND, RESUME, HIBERNATE AND WAKE.
;
; AUTHOR:
;	R. HUSTVEDT
;
; MODIFIED BY:
;
;	V03-001	LJK0152		Lawrence J. Kenah	24-Mar-1982
;		Store PID at IPL 2 instead of at IPL 7 to prevent possible
;		page faults at elevated IPL.
;
;	V02-002	TMH0002		Tim Halvorsen		23-Jan-1982
;		Allow access to other processes in the same job,
;		instead of the current check which allows access only
;		to direct subprocesses.  This allows you to "see" and
;		re-ATTACH to a parent process without privileges.
;
;	V02-001	TCM0001		Trudy C. Matthews	16-Mar-1981
;		Have EXE$NAMPID return success if process id's are identical.
;---
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$IPLDEF				; IPL DEFINITIONS
	$PCBDEF				; PCB OFFSET DEFINITIONS
	$PRDEF				; PROCESSOR REGISTER DEFS
	$PRIDEF				; PRIORITY INCREMENT DEFINITIONS
	$PRVDEF				; PRIVILEGE BIT DEFINITIONS
	$RSNDEF				; RESOURCE NUMBER DEFINITIONS
	$SSDEF				; STATUS DEFINITIONS
	$STATEDEF			; SCHEDULER STATE DEFINITIONS
;
; EQUATED SYMBOLS:
;
PID=4					; DISPLACEMENT TO PID ARGUMENT
PRCNAM=8				; DISPLACEMENT TO PROCESS NAME

	.PSECT	AEXENONPAGED,BYTE	; NONPAGED EXEC

	.PAGE
	.SBTTL	EXE$SUSPND - SUSPEND SYSTEM SERVICE
;++
;	EXE$SUSPND - SUSPEND SYSTEM SERVICE
;
; FUNCTIONAL DESCRIPTION:
;	EXE$SUSPND IMPLEMENTS THE SUSPEND PROCESS SYSTEM SERVICE.
;	THIS SERVICE CAUSES THE SPECIFIED PROCESS TO BE SUSPENDED
;	BY INITIATING A KERNEL MODE AST IF NOT THE CURRENT PROCESS.
;	A SUSPENDED PROCESS CANNOT RECEIVE ASTS AND WILL ONLY BE
;	RESUMED AS A RESULT OF THE RESUME SYSTEM SERVICE OR A 
;	DELETE PROCESS REQUEST.
;
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$SUSPND
;
;
; INPUT PARAMETERS:
;	04(AP) - PROCESS IDENTIFICATION POINTER (PID)
;	08(AP) - PROCESS NAME DESCRIPTOR POINTER
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS
;	PCB OF TARGET PROCESS
;	
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;	@PID(AP) - PROCESS IDENTIFICATION OF TARGET PROCESS
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL SUCCESSFUL COMPLETION
;	SS$_NOPRIV  -  INSUFFICIENT PRIVILEGE FOR REQUESTED OPERATION
;	SS$_NONEXPR -  NON-EXISTENT PROCESS
;	SS$_ACCVIO  -  ACCESS VIOLATION ON WRITE DESTINATION
;	SS$_INSFMEM -  INSUFFICIENT DYNAMIC MEMORY FOR REQUEST
;			( ONLY RETURNED IF NO RESOURCE WAIT ENABLE )
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$SUSPND::				; SUSPEND SYSTEM SERVICE
	.WORD	^M<R2,R3,R4,R5>		; REGISTER SAVE MASK FOR R2-R5
	BSBW	EXE$NAMPID		; TRANSLATE AND VERIFY ARGS
	SETIPL	#0			; ENABLE
	PUSHL	R1			; SAVE PID
	BLBC	R0,20$			; CONTINUE IF NO ERROR
	BBSSI	#PCB$V_SUSPEN,PCB$L_STS(R4),10$	; EXIT IF ALREADY SUSPENDED
	BSBW	EXE$ALLOCIRP		; ALLOCATE I/O PACKET FOR AST
	BLBC	R0,20$			; IF LBC THEN NO PACKET ALLOCATED
	MOVL	R2,R5			; SETUP POINTER TO AST CONTROL BLK
	MOVAL	B^SUSPND,ACB$L_KAST(R5)	; SET FOR KERNEL AST OM PROCESS
	MOVB	#^X80,ACB$B_RMOD(R5)	; SET ACCESS MODE FOR AST
	MOVL	(SP)+,ACB$L_PID(R5)	; SET PID FOR AST
	CLRL	R2			; SET NULL PRIORITY INCREMENT
	BSBW	SCH$QAST		; QUEUE KERNEL AST
10$:	BRB	EXITN			; EXIT WITH NORMAL STATUS
20$:	RET				; ERROR RETURN

	.PAGE
;
; KERNEL AST ROUTINE TO SUSPEND PROCESS
;
; CALLING SEQUENCE:
;	JSB	SUSPND
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS
;	R5 - ADDRESS OF AST CONTROL BLOCK
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS LOCATED VIA SCH$GL_CURPCB
;
; IMPLICIT OUTPUTS:
;	PCB$V_SUSPEN - CLEARED
;			       > WHEN PROCESS IS RESUMED
;	PCB$V_RESPEN - CLEARED
;-

SUSPND:					; SUSPEND KERNEL AST ROUTINE
	MOVL	R5,R0			; GET PACKET ADDRESS FOR RELEASE
	BSBW	EXE$DEANONPAGED		; DEALLOCATE PACKET
10$:	MOVPSL	-(SP)			;;; SAVE PSL ON STACK
	SETIPL	#IPL$_SYNCH		;;; DISABLE SYSTEM EVENTS
	BBCCI	#PCB$V_RESPEN,PCB$L_STS(R4),30$	;;; BR IF NO PENDING RESUME
	BBCCI	#PCB$V_SUSPEN,PCB$L_STS(R4),20$	; CLEAR SUSPEND PENDING
20$:	SETIPL	#IPL$_ASTDEL		; DROP TO ASTDEL IPL
	TSTL	(SP)+			; CLEAN PSL FROM STACK
	RSB				; AND EXIT
30$:	MOVAL	W^SCH$GQ_SUSP,R2	;;; GET QUEUE HEADER ADDRESS
	BSBW	SCH$WAITK		;;; WAIT WITH CLEAN STACK
	BRB	10$			; AND CLEAR RESUME PENDING FLAG


	.PAGE
	.SBTTL	EXE$RESUME - RESUME SYSTEM SERVICE
;++
;	EXE$RESUME - RESUME SYSTEM SERVICE
;
; FUNCTIONAL DESCRIPTION:
;	EXE$RESUME IMPLEMENTS THE RESUME SYSTEM SERVICE WHICH RESTARTS
;	A SUSPENDED PROCESS.
;
; INPUT PARAMETERS:
;	04(AP) - PROCESS IDENTIFICATION POINTER (PID)
;	08(AP) - PROCESS NAME DESCRIPTOR POINTER
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS
;	PCB OF TARGET PROCESS
;	PROCESS HEADER OF CURRENT PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;	@PID - PROCESS IDENTIFICATION OF TARGET PROCESS
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL SUCCESSFUL COMPLETION
;	SS$_NOPRIV  -  INSUFFICIENT PRIVILEGE FOR REQUESTED OPERATION
;	SS$_NONEXPR -  NON-EXISTENT PROCESS
;	SS$_ACCVIO  -  ACCESS VIOLATION ON WRITE DESTINATION
;
; SIDE EFFECTS:
;	NONE
;--

EXE$RESUME::				; RESUME SYSTEM SERVICE
	.WORD	^M<R2,R3,R4>		; REGISTER SAVE MASK FOR R2-R4
	BSBB	EXE$NAMPID		; CONVERT AND VALIDATE
	BLBC	R0,EXIT			; EXIT IF ERROR OCCURRED
	MOVZBL	#PRI$_RESAVL,R2		;;; SET PRIORITY INCREMENT CLASS
	BBSSI	#PCB$V_RESPEN,PCB$L_STS(R4),10$ ;;; SET RESUME PENDING
10$:	RPTEVT	RESUME			;;; REPORT RESUME EVENT
	BRB	EXITN			;;; AND TAKE NORMAL EXIT

	.PAGE
	.SBTTL	EXE$HIBER - HIBERNATE SYSTEM SERVICE
;++
;	EXE$HIBER - HIBERNATE SYSTEM SERVICE
;
; FUNCTIONAL DESCRIPTION:
;	EXE$HIBER IMPLEMENTS THE HIBERNATE SYSTEM SERVICE WHICH
;	PLACES THE PROCESS IN A WAIT STATE, HIB , UNTIL IT
;	IS RE-AWAKENED BY A WAKE SYSTEM SERVICE.  ASTS MAY BE DELIVERED
;	WHILE THE PROCESS IS IN A HIBERNATE STATE.
;
;
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$HIBER
;
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	PROCESS CONTROL BLOCK(PCB) OF THE PROCESS ISSUING THE HIBERNATE
;	SYSTEM SERVICE.
;
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	SS$_NORMAL - NORMAL SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;	THE PROCESS WILL BE PLACED IN A WAIT STATE UNTIL EITHER
;	AN AST IS DELIVERED OR A WAKE REQUEST IS MADE.
;
;--


EXE$HIBER::				; HIBERNATE SYSTEM SERVICE
	.WORD	^M<R2,R3,R4>		; REGISTER SAVE MASK FOR R2-R4
	SETIPL	#IPL$_SYNCH		;;; BLOCK SCHEDULING EVENTS
	BBCCI	#PCB$V_WAKEPEN,PCB$L_STS(R4),10$  ;;; CHECK FOR PENDING WAKE
	BRB	EXITN			;;; AND RETURN TO CALLER

10$:					;;; MUST HIBERNATE
	MOVAL	W^SCH$GQ_HIBWQ,R2	;;; SET ADDRESS OF WAIT QUEUE HDR
	BRW	SCH$WAIT		;;; AND WAIT
	.PAGE
	.SBTTL	EXE$WAKE - WAKE SYSTEM SERVICE
;++
;	EXE$WAKE - WAKE SYSTEM SERVICE
;
; FUNCTIONAL DESCRIPTION:
;	THE WAKE SYSTEM SERVICE CAUSES A PROCESS IN A HIBERNATE STATE
;	TO BE CHANGED TO AN EXECUTABLE STATE AND RE-EXECUTED.
;	IF THE TARGET OF A WAKE SERVICE IS NOT CURRENTLY HIBERNATING, 
;	THEN A BIT IS POSTED WHICH WILL CAUSE A SUBSEQUENT HIBERNATE
;	CALL BY THAT PROCESS TO RETURN IMMEDIATELY.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$WAKE
;
; INPUT PARAMETERS:
;	04(AP) = PROCESS IDENTIFICATION (PID) OF PROCESS TO WAKE
;	08(AP) = ADDRESS OF PROCESS NAME DESCRIPTOR
;	R4 - PCB ADDRESS
;	
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS
;	ALL PCBS LOCATED BY THE VECTOR @SCH$GL_PCBVEC
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	@PID(AP) - PROCESS IDENTIFICATION (PID) OF PROCESS AWAKENED
;
; IMPLICIT OUTPUTS:
;	PCB$V_WAKEPEN BIT IN PCB$L_STS OF TARGET PROCESS WILL BE
;	SET IF PROCESS IS NOT HIBERNATING.
;
; COMPLETION CODES:
;	SS$_NORMAL - NORMAL SUCCESSFUL COMPLETION
;	SS$_NONEXPR - NON-EXISTENT PROCESS
;	SS$_NOPRIV - NO PRIVILEGE FOR ATTEMPTED OPERATION
;	SS$_ACCVIO - ACCESS VIOLATION ON WRITE DESTINATION
;
; SIDE EFFECTS:
;	THE TARGET PROCESS WILL BE CHANGED TO AN EXECUTABLE STATE,
;	COM OR COMO, IF IT IS IN A HIBERNATE STATE AND
;	RESCHEDULING WILL BE INITIATED IF NECESSARY.
;
;--
EXE$WAKE::				; WAKE SYSTEM SERVICE
	.WORD	^M<R2,R3,R4>		; SAVE MASK FOR R2-R4
	BSBB	EXE$NAMPID		; CONVERT NAME TO PID
;
;	R0 - SUCCESS INDICATOR
;	R1 - PID CORRESPONDING TO NAME STRING
;	R4 - PCB ADDRESS IF NAME WAS FOUND
;
	BLBC	R0,EXIT			; CONTINUE IF PROCESS LOCATED
	BSBW	SCH$WAKE		;;; WAKE PROCESS BY PID
EXITN:					; EXIT HIBERNATE SERVICE
	MOVZWL	#SS$_NORMAL,R0		; SET NORMAL COMPLETION
EXIT:					; RETURN WITH R0 SET
	SETIPL	#0			; ENABLE
	RET				; AND RETURN TO CALLER


	.PAGE
	.SBTTL	EXE$NAMPID - CONVERT PROCESS NAME TO PID
;++
;	EXE$NAMPID  -  CONVERT PROCESS NAME TO PID
;
; FUNCTIONAL DESCRIPTION:
;	EXE$NAMPID OBTAINS THE PROPER PID AND PCB ADDRESS FOR A
;	STANDARD PROCESS CONTROL SERVICE ARGUMENT LIST CONSISTING
;	OF A PID/PROCESS-NAME PAIR.  THE ABSENCE OF BOTH SELECTS THE
;	CURRENT PROCESS.  AFTER ANY NECESSARY NAME TRANSLATION AND
;	PID VALIDATION, GROUP AND WORLD PROCESS CONTROL PRIVILEGES
;	ARE CHECKED.
;
;
; CALLING SEQUENCE:
;	JSB/BSB	EXE$NAMPID
;
; INPUT PARAMETERS:
;	PID(AP) - ADDRESS OF PID SOURCE/DESTINATION 
;	PRCNAM(AP) - POINTER TO PROCESS DESCRIPTOR TO CONVERT TO PID
;	R4 - PCB ADDRESS
;
; IMPLICIT INPUTS:
;	@SCH$GL_PCBVEC - VECTOR OF PCB ADDRESSES 
;	PHD$L_PRIV - PRIVILEGE BIT VECTOR IN PROCESS HEADER
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;	R1 - PROCESS IDENTIFICATION (PID) OF NAMED PROCESS.
;	     ZERO IF NO MATCH IS FOUND.
;	R4 - PCB ADDRESS OF PROCESS IF MATCH IS FOUND.
;	@PID(AP) - PROCESS IDENTIFICATION (PID) OF SELECTED PROCESS
;	IPL - IPL$_SYNCH (IPL UNCHANGED IF SS$_ACCVIO OR SS$_IVLOGNAM)
;
; COMPLETION CODES:
;	SS$_NORMAL  -  NORMAL SUCCESSFUL COMPLETION
;	SS$_IVLOGNAM  -  INVALID LOGICAL NAME STRING
;	SS$_NONEXPR -  NONEXISTENT PROCESS OR INVALID PID
;	SS$_NOPRIV  -  NO PRIVILEGE FOR SPECIFIED OPERATION.
;	SS$_ACCVIO  -  ACCESS VIOLATION FOR WRITE DESTINATION
;
; SIDE EFFECTS:
;	NONE
;
;--
EXE$NAMPID::				; TRANSLATE PNAME TO PID
	MOVL	PID(AP),R0		; GET PID ADDRESS
	BEQL	10$			; NO PID ADDRESS
	IFNOWRT	#4,(R0),ACCVIO		; ERROR IF ACCESS VIOLATION
	MOVL	(R0),R1			; NOW FETCH PID
	BNEQ	GOTPID			; YES,
10$:	MOVL	PCB$L_PID(R4),R1	; ASSUME CALLERS PID
	MOVL	PRCNAM(AP),R3		; GET PNAME ADDRESS IF SPECIFIED
	BNEQ	20$			; WAS SPECIFIED
	BRW	RETN			; NONE SPECIFIED, RETURN
20$:					; MUST LOOK UP PROCESS NAME
	IFNORD	#8,(R3),ACCVIO		; CHECK DESCRIPTOR FOR READABLITY
	MOVQ	(R3),R2			; GET DESCRIPTOR
	TSTW	R2			; AND CHECK FOR ZERO LENGTH
	BEQL	IVLNAM			; NOT A VALID NAME STRING
	CMPW	#15,R2			; CHECK FOR MAXIMUM LENGTH
	BLSSU	IVLNAM			; NOT A VALID NAME STRING
	IFNORD	R2,(R3),ACCVIO		; ACCESS VIOLATION IF STRING NOT READABLE
	PUSHL	R0			; SAVE PID ADDRESS
	MOVL	SCH$GL_MAXPIX,R0	; INITIALIZE PROCESS INDEX
PIXLOOP:				; LOOP FOR EACH PROCESS INDEX
	MOVL	@W^SCH$GL_PCBVEC[R0],R1	; GET PCB ADDRESS FROM VECTOR
	CMPW	PCB$W_GRP(R1),PCB$W_GRP(R4) ; COMPARE GROUP NUMBERS
	BNEQ	NEXTPIX			; NOT SAME GROUP, NEXT PIX
	CMPB	R2,PCB$T_LNAME(R1)	; COMPARE NAME LENGTH
	BNEQ	NEXTPIX			; DIFFERENT LENGTH
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE REGISTERS FOR CMPC3
	CMPC3	R2,(R3),PCB$T_LNAME+1(R1)	; COMPARE TEXT OF NAME
	POPR	#^M<R0,R1,R2,R3>	; RESTORE REGISTERS
	BEQL	GOTNAM			; FOUND A MATCHING PROCESS NAME
NEXTPIX:				; STEP TO NEXT PROCESS
	SOBGEQ	R0,PIXLOOP		; UPDATE INDEX AND TRYA AGAIN
	TSTL	(SP)+			; CLEAN PID ADDRESS FROM STACK
	BRB	NONEX			; EXIT WITH NONEXISTENT PROCESS STATUS

ACCVIO:					; ACCESS VIOLATION
	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR CODE
	RSB				; AND EXIT

IVLNAM:					; INVALID NAME
	MOVZWL	#SS$_IVLOGNAM,R0	; SET ERROR CODE
	RSB				; AND RETURN

GOTNAM:	MOVL	PCB$L_PID(R1),R1	; GET FULL PID FOR NAME
	POPL	R0			; RESTORE PID ADDRESS
GOTPID:					; VERIFY PID AND CHECK PRIV
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	MOVZWL	R1,R2			; EXTRACT PROCESS INDEX
	CMPL	R2,SCH$GL_MAXPIX	; TEST AGAINST MAXIMUM VALUE
	BGTRU	NONEX			; NONEXISTENT IF GTRU THAN MAXPIX
	MOVL	@W^SCH$GL_PCBVEC[R2],R2	; GET PCB ADDRESS
	CMPL	R1,PCB$L_PID(R2)	; CHECK FOR VALID PID
	BEQL	VALPID			; YES,
NONEX:					; PROCESS NON-EXISTENT
	MOVZWL	#SS$_NONEXPR,R0		; SET ERROR STATUS
	RSB				; AND RETURN TO CALLER
VALPID:					; PID IS VALID, CHECK PRIV
	CMPL	PCB$L_JIB(R2),PCB$L_JIB(R4) ; IS IT IN OUR JOB (TREE)?
	BEQL	RETURN			; IF SO, ALLOW IT WITHOUT PRIVILEGES
	IFPRIV	WORLD,RETURN,R4		; SUCCESS IF WORLD PRIVILEGE
	CMPW	PCB$W_GRP(R2),PCB$W_GRP(R4) ; ARE GROUP NUMBERS EQUAL
	BNEQ	NOPRIV			; IF NOT, NO PRIVILEGE
	IFNPRIV	GROUP,NOPRIV,R4		; ERROR IF NOT GROUP PRIV
RETURN:					; SUCCESSFUL EXIT 
	MOVL	R2,R4			; MOVE PCB ADDRESS OF TARGET
RETN:					; NORMAL STATUS EXIT
	TSTL	R0			; WAS PID ADDRESS SPECIFIED
	BEQL	10$			; NO, SKIP STORE OF PID
	SETIPL	#IPL$_ASTDEL		; ALLOW PAGE FAULTS
	MOVL	R1,(R0)			; STORE PID IN DESTINATION
	CLRL	R0			; DO NOT WRITE PID A SECOND TIME
	BRB	GOTPID			; MAKE SURE THAT PID IS STILL VALID

10$:	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	RSB				; AND RETURN TO CALLER
NOPRIV:	MOVZWL	#SS$_NOPRIV,R0		; SET ERROR STATUS
	RSB				; AND RETURN TO CALLER

	.PAGE
	.SBTTL	EXE$SETPRN - SET PROCESS NAME

;++
; FUNCTIONAL DESCRIPTION:
;	EXE$SETPRN IMPLEMENTS THE SET PROCESS NAME SYSTEM
;	SERVICE WHICH ALLOWS A PROCESS TO ESTABLISH A LOGICAL NAME
;	FOR ITSELF.  ALL SUCH LOGICAL NAMES ARE IMPLICITLY QUALIFIED
;	BY THE GROUP NUMBER OF THE PROCESS THEREBY ALLOWING THE SAME
;	LOGICAL NAME TO BE USED BY PROCESSES IN DIFFERENT GROUPS.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$SETPRN
;
; INPUT PARAMETERS:
;	04(AP) - ADDRESS OF PROCESS NAME STRING DESCRIPTOR
PRCNAM=4
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	SCH$GL_CURPCB - POINTER TO PCB OF CURRENT PROCESS
;	@SCH$GL_PCBVEC - VECTOR OF ALL PCB ADDRESSES
;
; OUTPUT PARAMETERS:
; 	NONE
;
; IMPLICIT OUTPUTS:
;	PCB$T_NAME IN CURRENT PCB IS FILLED WITH THE SPECIFIED NAME
;	PROVIDED NO ERROR HAS OCURRED.
;
; SIDE EFFECTS:
;	NONE
; 
; COMPLETION CODES:
;	SS$_NORMAL    -  NORMAL SUCCESSFUL COMPLETION STATUS
;	SS$_ACCVIO    -  ALL OR PART OF NAME STRING IS INACCESSIBLE FOR READ
;	SS$_IVLOGNAM  -  ILLEGAL LOGICAL NAME STRING LENGTH (>15)
;	SS$_DUPLNAM   -  DUPLICATE PROCESS NAME WITHIN GROUP
;
;--

EXE$SETPRN::				; SET PROCESS NAME
	.WORD	^M<R2,R3,R4,R5,R6,R7>	; SAVE REGISTERS R2-R7
	MOVL	PRCNAM(AP),R5		; GET ADDRESS OF PROCESS NAME
	BNEQ	5$			; WAS SPECIFIED
	CLRL	PCB$T_LNAME(R4)		; CLEAR NAME FIELD OF PCB
	BRB	65$			; AND EXIT WITH NORMAL STATUS
5$:	IFNORD	#8,(R5),80$		; CHECK ACCESS FOR DESCRIPTOR
	MOVQ	(R5),-(SP)		; PUSH DESCRIPTOR ON STACK
	TSTW	(SP)			; CHECK FOR ZERO LENGTH STRING
	BEQL	10$			; INVALID NAME
	IFNORD	(SP),@4(SP),80$		; PROBE ENDS OF STRING
	CMPW	(SP),#15		; CHECK FOR MAXIMUM LENGTH
	BLEQU	20$			; IF LEQU, WITHIN LIMIT
10$:	MOVZWL	#SS$_IVLOGNAM,R0	; INVALID PROCESS NAME STATUS
	RET				; AND RETURN
20$:	MOVL	SCH$GL_MAXPIX,R6	; SET MAXIMUM PROCESS INDEX
30$:	MOVL	@W^SCH$GL_PCBVEC[R6],R7	; GET PCB ADDRESS
	CMPW	PCB$W_GRP(R4),PCB$W_GRP(R7)  ; CHECK FOR SAME GROUP
	BNEQ	40$			; NO, SKIP IT
	CMPB	(SP),PCB$T_LNAME(R7)	; COMPARE LENGTHS
	BNEQ	40$			; NOT EQUAL, TRY ANOTHER
	CMPC3	(SP),@4(SP),PCB$T_LNAME+1(R7)    ; COMPARE NAMES WITH COUNTS
	BEQL	50$			; MATCH
40$:	SOBGEQ	R6,30$			; CONTINUE FOR ALL PCBS
	BRB	60$			; NOT FOUND
50$:	CMPL	R4,R7			; SAME PROCESS?
	BNEQ	70$			; DUPLICATE NAME ERROR
60$:	MOVB	(SP),PCB$T_LNAME(R4)	; SAVE NAME LENGTH
	MOVC3	(SP),@4(SP),PCB$T_LNAME+1(R4)	; MOVE NAME TO PCB
65$:	MOVZWL	#SS$_NORMAL,R0		; SUCCESSFUL STATUS
	RET				; AND RETURN
70$:	MOVZWL	#SS$_DUPLNAM,R0		; DUPLICATE NAME WITHIN GROUP
	RET				; AND RETURN

80$:	MOVZWL	#SS$_ACCVIO,R0		; ACCESS VIOLATION
	RET				; RETURN WITH ERROR STATUS
	.END
