	.TITLE	SYSCRMPSC - Create and Map Section System Service
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
; ABSTRACT:
;
; ENVIRONMENT:
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 24-APR-78
;
; MODIFIED BY:
;
;	V03-001	LJK0137		Lawrence J. Kenah	27-Mar-1982
;		When a WCB is turned into a shared WCB, restore the BYTCNT
;		quota to the creator of the window. Change error return
;		when attempting to create a section on a device that is
;		not file structured.
;
;	V02-043	LJK0134		Lawrence J. Kenah	17-Feb-1982
;		Correct oversimplifications made in V02-042. Some windows
;		do not have associated FCBs. Some CCBs contain PST indexes
;		instead of WCB addresses.
;
;	V02-042	LJK0132		Lawrence J. Kenah	15-Feb-1982
;		Add support for cathedral windows, guaranteeing that
;		memory management I/O requests never require ACP action.
;
;	V02-041	KDM0071		Kathleen D. Morse	2-Dec-1981
;		Lock processes that do PFNMAPs onto the primary by
;		incrementing PHD$L_MPINHIBIT.
;
;	V02-040	WMC0014		Wayne Cardoza		16-Nov-1981
;		Move the global page file limit initialization to INIT.
;
;	V02-039	LJK0083		Lawrence J. Kenah	12-Nov-1981
;		Move all pageable code from Y$EXEPAGED to new pageable PSECT 
;		to alleviate strain on word displacements throughout the
;		pageable exec. Change all word displacements in this module 
;		to G^ addressing.
;
;	V02-038	WMC0009		Wayne Cardoza		19-Oct-1981
;		Fix two transposed lines of code.
;
;	V02-037	WMC0002		Wayne Cardoza		21-Aug-1981
;		Add support for limit on page file used for global pages.
;
;	V02-036	WMC0001		Wayne Cardoza		12-Aug-1981
;		Changes for page file backing store global sections.
;
;	V02-035	KDM0055		Kathleen D. Morse	02-Jul-1981
;		Require a non-zero pagecount parameter for creation
;		of shared memory sections.
;
;	V02-034	KDM0054		Kathleen D. Morse	02-Jun-1981
;		Fix error path recovery for shared memory global section
;		mismatch when section is not mapped.
;
;	V02-033	LJK0022		Lawrence J. Kenah	19-May-1981
;		Replace CDL$x_ symbols with MMG$x_ symbols. Add $MMGDEF
;		macro. Make these offsets local symbols.
;
;	V02-032	LJK0021		Lawrence J. Kenah	19-May-1981
;		Take correct error path when attempting PFN mapping to a file
;		to avoid unlocking the GSD mutex when it has not been locked.
;
;	V02-031	KTA0011		Kerbey T. Altmann	10-Mar-1981
;		Fix special case code in INITSECTBL to understand about
;		multi-retrieval pointer WCB's that have no FCB's: non-
;		contiguous files opened by boot time FIL$OPENFILE.
;
;	V02-030	KDM0038		KATHLEEN D. MORSE	26-FEB-1981
;		Dont create section table entries for process demand-zero,
;		copy-on-reference sections and map them as DZRO format PTEs.
;
;	V02-029	KDM33527	KATHLEEN D. MORSE	03-FEB-1981
;		Move GSD address to R11, so that error paths will work
;		for local memory and PFNMAP global sections, as well
;		as those in shared memory.
;
;	V02-028	KDM0032		KATHLEEN D. MORSE	02-FEB-1981
;		Fix check for shared memory global section mapped
;		backwards in address space.  Correct error recovery
;		path un-mapping for a shared memory $CRMPSC request.
;
;	V02-027	KDM0031		KATHLEEN D. MORSE	20-JAN-1981
;		Remove checks for non-PFNMAP section, not mapped to
;		a file as this was never implemented.
;
;	V02-026	KDM0016		KATHLEEN D. MORSE	16-JUN-1980
;		Close off code that incorrectly maps the pieces of a
;		shared memory global section.  The problem occus when
;		a global section is broken into multiple pieces and
;		the user requests the section be mapped backwards.
;		The error code, SS$_IVSSRQ, is returned.
;		**** This should be fixed correctly for Release 3.0.
;
;	V02-025	KDM0014		KATHLEEN D. MORSE	3-JUN-1980
;		On all error paths, give back quota and reference for a
;		shared memory global section that fails to be created.
;
;	V02-024	KDM0012		KATHLEEN D. MORSE	3-JUN-1980
;		Check that a DZRO shared memory global section is completely
;		mapped during creation and allow non-DZRO shared memory
;		global sections to be created without being mapped.
;
;	V02-023	KDM29916	KATHLEEN D. MORSE	25-APR-1980
;		Call MMG$DALCSTXSCN1 before calling MMG$GSDSCN, so that
;		temporary global sections with reference counts of zero
;		are deleted and are not re-mapped by the next gsd scan.
;
;	V02-022	KDM0003		KATHLEEN D. MORSE	17-APR-1980
;		Release section table entry if shm gsd is not unique.
;
;	V02-021	KDM0002		KATHLEEN D. MORSE	17-APR-1980
;		Return correct status for error during shm section
;		table entry creation.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CCBDEF				;CHANNEL CONTROL BLOCK DEFINITIONS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DYNDEF				;DYNAMIC DATA STRUCTURE DEFINTIONS
	$FCBDEF				;FILE CONTROL BLOCK DEFINITIONS
	$FIBDEF				;FILE INFORMATION BLOCK DEFINITIONS
	$GSDDEF				;GLOBAL SECTION DESCRIPTOR DEFINTIONS
	$IPLDEF				;PROCESSOR PRIORITY LEVELS
	$JIBDEF				;JOB INFORMATION BLOCK OFFSETS
	$MMGDEF				;OFFSETS FROM FP INTO SCRATCH AREA
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINTIONS
	$PRTDEF				;PROTECTION CODE DEFINITIONS
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
	$PSLDEF				;DEFINE PROCESS MODES
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$SECDEF				;SECTION TABLE DEFINITIONS
	$SHBDEF				;SHARED MEMORY CONTROL BLOCK DEFINITIONS
	$SHDDEF				;SHARED MEMORY COMMON DATA PAGE DEF.
	$SSDEF				;SYSTEM STATUS CODE DEFINTIONS
	$UCBDEF				;DEFINE UNIT CONTROL BLOCKS
	$VADEF				;VIRTUAL ADDRESS VIELDS
	$WCBDEF				;WINDOW CONTROL BLOCK DEFINITIONS
;
; EXTERNAL SYMBOLS:
;
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
; OFFSET FROM AP
;
	INADR		= 4		;OFFSET TO INPUT RANGE
	RETADR		= 8		;OFFSET TO RETURN RANGE
	ACMODE		= 12		;ACCESS MODE
	FLAGS		= 16		;MAP SECTION FLAGS
	GSDNAM		= 20		;GLOBAL SECTION NAME DESCRIPTOR ADDRESS
	IDENT		= 24		;SECTION IDENTIFIER
	RELPAG		= 28		;RELATIVE PAGE TO START MAPPING AT
	CHAN		= 32		;CHANNEL THAT FILE TO MAP IS OPEN ON
	SECPAGCNT	= 36		;NUMBER OF PAGES IN SECTION
	VBN		= 40		;FILE VBN AT WHICH SECTION BEGINS
	PFN		= 40		;STARTING PFN TO BE MAPPED
	PROT		= 44		;SECTION PROTECTION CODE
	PFC		= 48		;SECTION PAGE FAULT CLUSTER
;
; OWN STORAGE:
;

	.SBTTL	CRMPSC - CREATE AND MAP SECTION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THE CREATE AND MAP SECTION SERVICE CREATES A NEW SECTION
; OF THE SPECIFIED NAME UNLESS THAT NAME ALREADY EXISTS.  IN EITHER CASE
; IT THEN MAPS THE SPECIFIED SECTION.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$CRMPSC
;
; INPUT PARAMETERS:
;
;	INADR(AP) = ADDRESS OF 2 LONG WORDS THE 1ST OF WHICH SPECIFIES
;		THE STARTING VIRTUAL ADDRESS TO CREATE, THE 2ND SPECIFIES
;		THE ENDING VIRTUAL ADDRESS TO CREATE (INCLUSIVE).
;	RETADR(AP) = ADDRESS OF A 2 LONGWORD ARRAY INTO WHICH IS RETURNED
;		THE STARTING AND ENDING VIRTUAL ADDRESSES (INCLUSIVE)
;		OF THE PAGES JUST CREATED
;	ACMODE(AP) = THE ACCESS MODE (MAXIMIZED WITH CALLING MODE)
;		USED AS THE OWNER OF THE NEW PAGE(S)
;	FLAGS(AP)  = BIT  0  - GBL - GLOBAL IF SET, PROCESS IF CLEAR
;		     BIT  1  - CRF - COPY ON REFERENCE
;		     BIT  2  - DZRO - DEMAND ZERO
;		     BIT  3  - WRT - WRITABLE IF SET, READ ONLY IF CLEAR
;		     BITS 4 - 5 RESERVED, MUST BE ZERO
;		     BITS 6 & 7 - WRTMOD - WRITE ACCESS FOR SECTION
;		     BITS 8 - 13 RESERVED, MUST BE ZERO
;		     BIT  14 - PERM - PERMANENT IF SET, TEMPORARY IF CLEAR
;		     BIT  15 - SYSGBL - SYSTEM GLOBAL IF SET, GROUP GLOBAL IF CLEAR
;		     BIT  16  - PFNMAP - MAP TO SPECIFIC PFN'S, IF SET
;		     BIT  17  - EXPREG - MAP TO FIRST FREE SPACE AVAILABLE
;		     BIT  18 - PROTECT - SET IF WRITE ACCESS MODE SPECIFIED
;		     BIT  19 - PAGFIL - USE PAGE FILE BACKING STORE FOR GLOBAL SECTION
;		     BITS 20  - 31 RESERVED, MUST BE ZERO
;	GSDNAM(AP) = THE DESCRIPTOR OF THE GLOBAL SECTION NAME
;	IDENT(AP)  = ADDRESS OF QUAD WORD CONTAINING SECTION IDENTIFICATION
;		     FIRST LONG WORD CONTAINS THE MATCH CONTROL INFORMATION
;			0 = ISD$K_MATALL, MATCH ALWAYS
;			1 = ISD$K_MATEQU, MATCH IF IDENTS ARE EQUAL
;			2 = ISD$K_MATLEQ, MATCH IF HIGH 8 BITS ARE EQUAL
;			    AND LOW 24 BITS ARE LESS THAN OR EQUAL TO
;			    THE ID STORED IN THE GLOBAL SECTION.
;		     SECOND LONG WORD CONTAINS THE IDENT TO BE COMPARED
;	RELPAG(AP) = RELATIVE PAGE IN SECTION TO START MAPPING
;	CHAN(AP)   = CHANNEL ON WHICH FILE IS ACCESSED
;	SECPAGCNT(AP) = NUMBER OF PAGES (STARTING AT THE ABOVE VBN) IN THE SECTION
;	VBN(AP)    = STARTING VIRTUAL BLOCK IN FILE THAT BECOMES THE
;			FIRST BLOCK OF THE GLOBAL SECTION
;	PFN(AP)	= STARTING PFN TO BE MAPPED, IF PFNMAP FLAG SET
;	PROT(AP) = PROTECTION APPLIED TO SECTION
;	PFC(AP)    = PAGE FAULT CLUSTER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_IVSECFLG - INVALID SECTION FLAGS
;	SS$_ACCVIO - ACCESS VIOLATION
;	SS$_CREATED - SECTION SUCCESSFULLY CREATED
;	SS$_NORMAL - EXISTING SECTION SUCESSFULLY MAPPED
;	SS$_ILLPAGCNT - PAGE COUNT LESS THAN ZERO
;	SS$_GSDFULL - NO FREE GSD TO ALLOCATE
;	SS$_IVSECIDCTL - INVALID SECTION IDENT MATCH CONTROL
;	SS$_GPTFULL - NO GLOBAL PAGE TABLE SPACE TO ALLOCATE
;	SS$_NOTFILEDEV - NOT A FILE ORIENTED DEVICE
;	SS$_IVCHNLSEC - INVALID CHANNEL FOR SECTION
;	SS$_ENDOFFILE - END OF FILE ENCOUNTERED MAPPING SECTION
;	SS$_VASFULL - VIRTUAL ADDRESS SPACE FULL
;	SS$_INSFMEM - INSUFFICIENT SHARED MEMORY GLOBAL PAGES AVAILABLE
;	SS$_INTERLOCK - UNABLE TO ACQUIRE SHARED MEMORY BIT MAP LOCK
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAMES (DEPTH > 10)
;	SS$_IVLOGNAM - INVALID LOGICAL NAME
;	SS$_SHMNOTCNCT - SHARED MEMORY DATA STRUCTURES NOT CONNECTED
;	SS$_NOPRIV - NO PRIVILEGE FOR ATTEMPTED OPERATION
;	SS$_SECTBLFUL - SECTION TABLE FULL
;	SS$_PAGOWNVIO - PAGE OWNER VIOLATION (RE-MAPPING A PAGE IN USE)
;	SS$_IVCHAN - INVALID CHANNEL
;	SS$_EXQUOTA - EXCEEDED PAGING FILE QUOTA (FOR CRF SECTIONS)
;	SS$_NOWRT - UNABLE TO CREATE WRITABLE SECTION TO READ-ONLY FILE
;	SS$_IDMISMATCH - IDENT MISMATCH WITH EXISTING GLOBAL SECTION
;	SS$_EXPORTQUOTA - EXCEEDED PORT'S QUOTA FOR GSD'S
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC
;
; **********************************************************************
;
	.ENABL	LSB

;
; NO INPUT RANGE ADDRESS SPECIFIED
;
CRMPSC_NOINADR:
	ASSUME	SEC$V_GBL EQ 0
	BLBC	R9,CRMPSC_ACCVIO	;ONLY LEGAL FOR GLOBAL SECTIONS
	BBC	#SEC$V_PERM,R9,CRMPSC_ACCVIO ;WHICH ARE PERMANENT
	DECL	R4			;-1 INDICATES NO RANGE TO MAP
	BRB	15$			;REJOIN CRMPSC CODE

FLAG_ERROR1:
	MOVZWL	#SS$_IVSECFLG,R0	;SET INVALID SECTION FLAG ERROR CODE
	BRB	CRMPSC_RET		;BRANCH TO ERROR RETURN
CRMPSC_ACCVIO:
	MOVZWL	#SS$_ACCVIO,R0		;CANNOT ACCESS THE RANGE TO MAP
CRMPSC_RET:
	RET

	.PSECT	Y$EXEPAGED		;PUT ENTRY POINT INTO SEPARATE PSECT

;**********  EXE$CRMPSC  ENTRY POINT

	.ENTRY	EXE$CRMPSC,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_CRMPSC		;TRANSFER TO REAL PROCEDURE

	.PSECT	YF$$SYSCRMPSC		;BACK TO $CRMPSC PSECT

EXE_CRMPSC:
	SUBL	S^#-MMG$C_LENGTH,SP	;RESERVE A SCRATCH AREA
	MOVL	FLAGS(AP),R9		;GLOBAL SECTION FLAGS
	MOVL	INADR(AP),R4		;ADDRESS OF RANGE TO MAP
	BEQL	CRMPSC_NOINADR		;BRANCH IF NULL RANGE
	IFNORD	#8,(R4),CRMPSC_ACCVIO	;BRANCH IF RANGE NOT ACCESSIBLE
	MOVQ	(R4),R4			;PICK UP THE RANGE
15$:	PUSHL	#0			;REMEMBER NO START RETADR YET
	MOVZWL	#SS$_CREATED,-(SP)	;ASSUME SECTION WILL BE CREATED
	PUSHR	#^M<R4,R5>		;SAVE RANGE FOR MAPPING LATER
	BSBW	MMG$RETADRINI		;INIT RETURN RANGE, AND SCRATCH AREA
	MOVL	R9,R0			;GLOBAL SECTION FLAGS
	BSBW	MMG$VFYSECFLG		;VERIFY SECTION FLAGS
	MOVL	R0,R9			;USE VERIFIED FLAGS
	CLRL	R8			;ASSUME NO SECTION TABLE ADDRESS
	MOVZWL	CHAN(AP),R6		;CHANNEL PARAMETER
	BNEQ	17$			;BR ON MAPPED TO A FILE
	BBS	#SEC$V_PAGFIL,R9,20$	;SKIP CHANNEL CHECKS IF PAGE FILE
	BBC	#SEC$V_PFNMAP,R9,FLAG_ERROR1 ;ERR IF NOT PFNMAP AND NO CHANNEL
	BRB	20$			;SKIP CHANNEL VERIFICATION AS NO CHANNEL

CRMPSC_FOUND:				;GLOBAL SECTION EXISTS, JUST MAP TO IT
	ADDL	#6*4,SP			;CLEAN OFF THE STACK
	MOVZWL	#SS$_NORMAL,8(SP)	;INDICATE SECTION ALREADY EXISTS
	BRW	MAPGBLSEC1		;GO MAP THE SECTION

17$:	BITL	#SEC$M_PFNMAP!SEC$M_PAGFIL,R9 ;BR IF PAGE FILE OR PFNMAPPED TO A FILE
	BNEQ	FLAG_ERROR1

; CALL TO IOC$VERIFYCHAN THAT WAS MADE HERE IS NOW BEING MADE IN CHECK_WINDOW

19$:	BSBW	CHECK_WINDOW		;INSURE THAT FILE IS COMPLETELY MAPPED
	BLBC	R0,CRMPSC_RET		;BRANCH IF FILE NOT FULLY MAPPED
20$:	MOVL	G^SCH$GL_CURPCB,R4	;GET PCB ADDRESS
	BBC	#SEC$V_CRF,R9,25$	;BRANCH IF NOT CRF SECTION
	BBSS	S^#MMG$V_CHGPAGFIL,B^MMG$L_MAXACMODE(FP),25$ ;MUST CHARGE PAGE FILE

	ASSUME	SEC$V_GBL EQ 0
25$:	BLBC	R9,CRMPSC_PROCESS	;BRANCH IF CREATING PROCESS SECTION
	MOVAL	G^EXE$GL_GSDMTX,R0	;ADR OF GLOBAL SECTION MUTEX
	JSB	G^SCH$LOCKW		;LOCK GSD MUTEX FOR WRITING
;
; RETURNS WITH IPL = ASTDEL
; R8 = CHANNEL CONTROL BLOCK ADDRESS, IF PFNMAP CLEAR
; R9 = SECTION FLAGS
; 0(SP)  = STARTVA
; 4(SP) = ENDVA
; 8(SP) = SUCCESS CODE FOR MAP GLOBAL SECTION
;
; ***** NOTE:  ALL EXITS FROM THIS POINT ON MUST UNLOCK THE GSD MUTEX.
;
; FIRST, BEFORE DOING A GSD SCAN, DO A DEALLOCATE SECTION SCAN.  THIS
; SCAN MUST BE DONE IN ORDER TO COMPLETE THE DELETION OF A TEMPORARY
; GLOBAL SECTION WHOSE REFERENCE COUNT HAS DROPPED TO ZERO.
;
	BSBW	MMG$DALCSTXSCN1		;SCAN FOR SECTIONS TO DEALLOCATE --
;
	SUBL	#<6*4>,SP		;MAKE ROOM FOR GSD NAME
	MOVL	SP,R7			;R7 = ADDRESS OF GSD NAME STORAGE

	ASSUME	IDENT EQ GSDNAM+4
	MOVQ	GSDNAM(AP),R0		;DESCRIPTOR ADDRESS FOR GLOBAL SECTION NAME
					;ADDRESS OF IDENTIFICATION QUAD WORD
	MOVL	R9,R6			;SECTION FLAGS
	BSBW	MMG$GSDSCN		;SCAN FOR THE NAME
;
; R4 = SHARED MEMORY CONTROL BLOCK ADR IF GLOBAL SECTION IS IN SHARED MEMORY
; R5 RETURNED WITH SYSTEM PROCESS HEADER ADDRESS WHETHER SUCCESSFUL OR NOT
; R10 =   0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	  -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	  >0 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED
;
	BLBS	R0,CRMPSC_FOUND		;BRANCH IF SECTION ALREADY EXISTS
	CMPW	#SS$_NOSUCHSEC,R0	;CONTINUE WITH CREATION IF NOT FOUND
	BNEQ	ULKGSDMTXRET1		;BRANCH IF SOME OTHER ERROR
;
; GLOBAL SECTION NAME DOESN'T EXIST, CREATE A NEW ONE
; ALLOCATE A GLOBAL SECTION DESCRIPTOR BLOCK
; 0(SP) - 16(SP) = GSD NAME COUNTED STRING
; 20(SP) - 24(SP) = IDENTIFICATION QUAD WORD
;

	ASSUME	PRV$V_SYSGBL EQ PRV$V_PRMGBL+1
	ASSUME	SEC$V_SYSGBL EQ SEC$V_PERM+1
	MOVL	@#CTL$GL_PHD,R11	;YES, THEN CHECK FOR PRIVILEGE TO DO SO
	EXTZV	#PRV$V_PRMGBL,#2,(R11),R0 ;GET PRIVILEGES FOR PERM AND SYS
	EXTZV	#SEC$V_PERM,#2,R9,R1	;GET DESIRED PERMANENT AND SYSTEM WIDE FLAGS
	BICL	R0,R1			;IF ANY DESIRED BITS STILL LEFT ON
	BNEQ	CRMPSC_NOPRIV		;THEN NO PRIV FOR REQUESTED OPERATION
	BBC	#SEC$V_PFNMAP,R9,30$	;IS PFNMAPPING REQUESTED?
	BBS	#PRV$V_PFNMAP,PHD$Q_PRIVMSK(R11),30$ ;BR ON HAVE PRIV
	BRB	CRMPSC_NOPRIV		;REPORT NO PRIV TO DO PFNMAP
CRMPSC_PROCESS:				;BRANCH ASSIST TO PROCESS SECTION MAP
	BRW	MAP_PROCESS_SEC		;GO MAP PROCESS SECTION
;
; ERROR IN SECTION FLAGS AND TYPE OF SECTION REQUESTED
;
FLAG_ERROR:
	MOVZWL	#SS$_IVSECFLG,R0	;REPORT INVALID SECTION FLAGS
28$:	BRB	ULKGSDMTXRET1		;RETURN ERROR STATUS TO CALLER
;
; NO PRIVILEGE TO CREATE OR MAP THE GLOBAL SECTION
;
CRMPSC_NOPRIV:
	MOVZWL	#SS$_NOPRIV,R0		;NO PRIVILEGE FOR REQUESTED OPERATION
ULKGSDMTXRET1:
	BRW	ULKGSDMTXRET
ILL_PAG_CNT:
	MOVZBL	#SS$_ILLPAGCNT,R0	;REPORT SECTION HAS NO PAGES IN IT
	BRB	ULKGSDMTXRET1		;RETURN TO CALLER
SHM_NOT_MAP:
	MOVZWL	#SS$_SHMGSNOTMAP,R0	;REPORT SECTION IS NOT BEING MAPPED
	BRB	ULKGSDMTXRET1		;RETURN TO CALLER
					;R5=SYSTEM PROCESS HEADER ADR
30$:	MOVL	SECPAGCNT(AP),R7	;SET COUNT OF PAGES IN SECTION
	BLSS	ILL_PAG_CNT		;ERROR, ILLEGAL PAGE COUNT
	TSTL	R10			;IS SECTION IN SHARED MEMORY?
	BLEQ	LOCAL_MEM_GSD		;BR ON NO
	TSTL	R7			;IS A NON-ZERO PAGECOUNT SPECIFIED?
	BEQL	ILL_PAG_CNT		;BR ON NO, THIS IS NOT IMPLEMENTED
	BBC	#PRV$V_SHMEM,PHD$Q_PRIVMSK(R11),CRMPSC_NOPRIV ;SHMEM PRIV NEEDED
	BBS	#SEC$V_CRF,R9,LOCAL_MEM_GSD ;SHARED MEMORY CAN'T BE CRF
	BBS	#SEC$V_PFNMAP,R9,FLAG_ERROR ;SHMEM GSD CAN'T BE PFNMAPPED
	BBC	#SEC$V_PERM,R9,FLAG_ERROR ;SHARED MEMORY MUST BE PERMANENT
	BBSS	#SEC$V_SHMGS,R9,31$	;INDICATE SECTION IS IN SHARED MEMORY
31$:	BBC	#SEC$V_DZRO,R9,32$	;IF NOT DZRO, THEN NEED NOT BE MAPPED
	TSTL	RELPAG(AP)		;FOR SH MEM GS, ALL SECTION MUST BE
	BNEQ	SHM_NOT_MAP		;MAPPED OTHERWISE IT CAN'T BE INITED
	MOVL	<7*4>(SP),R0		;THIS MEANS RELPAG MUST BE ZERO AND
	BEQL	SHM_NOT_MAP		;THE INPUT ADDRESS RANGE MUST SPECIFY
	MCOML	R0,R0			;A VALID RANGE OF ADDRESSES (MINUS
	BEQL	SHM_NOT_MAP		;ONE AND ZERO ARE NOT VALID)
					;R4=SHARED MEMORY CONTROL BLOCK ADR
32$:	BSBW	MMG$ALOSHMGSD		;ALLOCATE A SHARED MEMORY GSD
	BLBC	R0,28$			;BR IF UNABLE TO GET A GSD
					;R4=SHARED MEMORY CONTROL BLOCK ADR
	BSBW	MMG$ALOSHMPAG		;ALLOCATE PAGES OF SHARED MEMORY
	BLBC	R0,RELEAS_GSD_RET	;BR IF COULDN'T GET ENOUGH PAGES
	TSTL	R8			;IS GS MAPPED TO A FILE?
	BNEQ	COMMON_INIT1		;BR IF MAPPED TO A FILE
	BRW	NO_FILE_INIT		;BR IF NOT MAPPED TO A FILE
LOCAL_MEM_GSD:
	TSTL	R8			;IS SECTION MAPPED TO A FILE?
	BNEQ	321$			;YES
	BBS	#SEC$V_PAGFIL,R9,321$	;NOT PAGE FILE
	BRB	PFNMAP_GSD		;BR ON TO TO CREATE EXTENDED GSD
321$:	REMQUE	@L^EXE$GL_GSDFREFL,R6	;GET A FREE GSD IF ANY
	BVC	COMMON_INIT1		;BRANCH IF GOT ONE
	MOVZBL	#GSD$C_LENGTH,R1	;NUMBER OF BYTES NEEDED
	JSB	G^EXE$ALOPAGED		;ALLOCATE FROM PAGED POOL
	BLBS	R0,NORMAL_GSD		;BRANCH IF ONE AVAILABLE
36$:	MOVZWL	#SS$_GSDFULL,R0		;GLOBAL SECTION DESCRIPTOR TABLE FULL
37$:	BRW	ULKGSDMTXRET		;UNLOCK THE MUTEX AND RETURN ERROR
RELEAS_PAG_RET:
	MOVZBL	#SHD$V_BITMAPLCK,R0	;NUMBER OF BIT LOCK REQUESTED
	BSBW	MMG$SHMTXLK		;REQUEST MUTEX AND BIT LOCK
; **********
; AT SOME TIME THIS SHOULD SEND A MESSAGE TO THE ERROR LOGGER.
; **********
	BLBC	R0,34$			;UNABLE TO GET BIT LOCK
	BSBW	MMG$SET_BITMAP		;RELEASE ALL PAGES ALLOCATED FOR GS
	BSBW	MMG$SHMTXULK		;RELEASE SHM MUTEX
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),33$ ;RELEASE BIT LCK
33$:	BRB	34$			;JOIN COMMON CODE
RELEAS_GSD_RET:				;R0 CONTAINS ERROR CODE
	PUSHL	R0			;REMEMBER RETURN STATUS CODE
34$:	MOVZBL	#1,R0			;ONE REFERENCE COUNT THAT LOCKS GSD
	JSB	G^MMG$DECSHMREF		;IS GIVEN BACK
	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),35$ ;UNLOCK THE GSD
35$:	MOVZBL	SHB$B_PORT(R4),R1	;GET PORT # FOR THIS PROCESSOR
	DECL	SHB$L_REFCNT(R4)	;ONE LESS GSD OWNED BY THIS PORT
	ADAWI	#1,SHD$W_GSDQUOTA(R5)[R1] ;GIVE SHM GSD QUOTA BACK TO PORT
	MOVL	(SP)+,R0		;RESTORE RETURN STATUS CODE
	BRB	37$			;ERROR RETURN
NORMAL_GSD:
	MOVL	R2,R6			;ADDRESS OF NEW GSD
	MOVZBW	#GSD$C_LENGTH,GSD$W_SIZE(R6) ;FILL IN SIZE OF GSD
	MOVB	#DYN$C_GSD,GSD$B_TYPE(R6) ;AND TYPE CODE
COMMON_INIT1:
	BRB	COMMON_INIT		;SKIP EXTGSD SPECIFIC INITIALIZATION
PFNMAP_GSD:
	MOVZBL	#GSD$C_EXTGSDLNG,R1	;GET NUMBER OF EXTGSD BYTES NEEDED
	JSB	G^EXE$ALOPAGED		;ALLOCATE FROM PAGED POOL
	BLBC	R0,36$			;BRANCH IF NONE AVAILABLE
	MOVL	R2,R6			;REMEMBER ADDRESS OF NEW EXTGSD
	MOVZBW	#GSD$C_EXTGSDLNG,GSD$W_SIZE(R6) ;FILL IN SIZE OF EXTGSD
	MOVB	#DYN$C_EXTGSD,GSD$B_TYPE(R6) ;AND TYPE CODE
	CLRL	GSD$L_REFCNT(R6)	;INITIALIZE REFERENCE TO SECTION
	MOVL	PFN(AP),GSD$L_BASEPFN(R6) ;FILL IN STARTING PFN FOR SECTION
	MOVL	R7,GSD$L_PAGES(R6)	;AND NUMBER OF PAGES IN SECTION
	BNEQ	NO_FILE_INIT		;BR IF PAGE COUNT VALID
	BRW	ILL_PAG_CNT		;BR IF BAD PAGE COUNT
NO_FILE_INIT:
	MOVW	PROT(AP),GSD$W_PROT(R6)	;AND PROTECTION FOR SECTION
	CLRW	GSD$W_GSTX(R6)		;SET NO SECTION TABLE INDEX
	CLRL	R10			;REMEMBER NO SECTION TABLE ENTRY
	CLRL	GSD$L_FILUIC(R6)	;0 INDICATES BYPASS FILE PROT CHECK
COMMON_INIT:
	MOVL	G^SCH$GL_CURPCB,R0	;GET PCB ADDRESS
	MOVL	PCB$L_UIC(R0),GSD$L_PCBUIC(R6) ;SET UIC OF CREATOR FROM PCB
	MOVQ	(SP)+,GSD$T_GSDNAM(R6)	;STORE SECTION NAME
	MOVQ	(SP)+,GSD$T_GSDNAM+8(R6)
	MOVQ	(SP)+,R0		;R0=MATCH CONTROL, R1=IDENTIFICATION DATA
	INSV	B^MMG$L_MAXACMODE(FP),#SEC$V_AMOD,- ;SET THE ACCESS
		#SEC$S_AMOD,R9		;MODE OF THE SECTION
	MOVW	R9,GSD$W_FLAGS(R6)	;FILL IN SECTION FLAGS
	CMPL	R0,#SEC$K_MATLEQ	;VALID MATCH CONTROL
	BGTR	BADMATCHCTL		;BRANCH IF NOT
	MOVL	R1,GSD$L_IDENT(R6)	;SET GLOBAL SECTION IDENT
	TSTL	R8			;IS GS MAPPED TO A FILE?
	BNEQ	MAP_TO_FILE		;BR ON MAPPED TO A FILE
	BBS	#SEC$V_PAGFIL,R9,MAP_TO_FILE  ;IS IT PAGE FILE BACKING STORE
	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS GS IN SHARED MEMORY?
	BEQL	SHM_GS_MAP		;BR IF IN SHARED MEMORY
	BRW	70$			;BR IF IN LOCAL MEMORY OR PFNMAP
SHM_GS_MAP:
	CLRL	SEC$L_REFCNT(R10)	;DON'T USE SEC TBL REFCNT FOR SH MEM GS
	BRW	MAPGBLSEC2		;GO MAP THE SECTION
;
; ALLOCATE A GLOBAL SECTION TABLE ENTRY FOR THE NEW SECTION
; R4 = SHARED MEMORY CONTROL BLOCK ADDRESS IF GLOBAL SECTION IS IN SHARED MEM
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R6 = GLOBAL SECTION DESCRIPTOR ADDRESS
; R7 = COUNT OF PAGES IN SECTION
; R8 = CHANNEL CONTROL BLOCK ADDRESS
; R9 = SECTION FLAGS
; 0(SP) = STARVA
; 4(SP) = ENDVA
; 8(SP) = SUCCESS CODE FOR MAP GLOBAL SECTION
;
MAP_TO_FILE:
	BSBW	INITSECTBL		;ALLOCATE AND INIT SECTION TABLE
					;R2 AND R3 DESTROYED
	BLBC	R0,GSTFULL1		;BRANCH IF NONE AVAILABLE
	MOVW	SEC$W_FLAGS(R10),GSD$W_FLAGS(R6) ;RECORD FLAGS IN GSD
;
; R1  = SECTION TABLE INDEX
; R7  = SECTION PAGE COUNT
; R10 = SECTION TABLE BASE ADDRESS
;
	MOVW	R1,GSD$W_GSTX(R6)	;SAVE SECTION INDEX
	CLRL	GSD$L_FILUIC(R6)	;ASSUME NO FILE PROTECTION CHECK
	MOVL	SEC$L_WINDOW(R10),R0	;GET WINDOW ADDRESS
	BEQL	392$			;NO WINDOW - PAGE FILE BACKING STORE
	MOVL	WCB$L_FCB(R0),R0	;CHAIN TO FCB ADDRESS
	BEQL	38$			;BRANCH IF NOT AN FCP WINDOW
	BISW3	PROT(AP),FCB$W_FILEPROT(R0),- ;SET POSSIBLY RESTRICTED
		GSD$W_PROT(R6)		;FILE PROTECTION
	MOVL	FCB$L_FILEOWNER(R0),R0	;AND FETCH THE FILE'S OWNER
38$:	MOVL	R0,GSD$L_FILUIC(R6)	;SET FILE OWNER INTO GSD
					;0 INDICATES BYPASS FILE PROT CHECK
	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS GS IN SHARED MEMORY?
39$:	BEQL	SHM_GS_MAP		;BR ON YES, GO READ SECTION INTO MEMORY
;
; GET GLOBAL PAGE TABLE ENTRIES
;
391$:	ADDL3	#3,R7,R1		;PAGCNT + 2 FOR STOPPER ENTRIES
	BICL	#1,R1			;ROUND UP TO EVEN NO. OF LONG WORDS
	MULL	#4,R1			;DESIRED NO. OF BYTES OF GPTE
	MOVAL	G^EXE$GL_GPT,R3		;GPT ALLOCATION LIST HEAD
	JSB	G^EXE$ALLOCATE		;GET SOME GPT
	BLBS	R0,40$			;BRANCH IF GOT SOME
	BRW	GPTFULL			;GLOBAL PAGE TABLE FULL
;
;
; BAD MATCH CONTROL FIELD FOR SECTION
;
BADMATCHCTL:				;BAD MATCH CONTROL FIELD
	MOVZWL	#SS$_IVSECIDCTL,R0	;INVALID SECTION IDENT CONTROL
GSTFULL1:
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BLEQU	BRGSTFULL		;BR IF LOCAL MEMORY OR EXTENDED GSD
	PUSHL	R0			;SAVE ERROR STATUS CODE
	BRW	RELEAS_PAG_RET		;BR IF SHARED MEMORY GSD
;
; CHECK FOR PAGE FILE LIMIT EXCEEDED
;
392$:	SUBL	SEC$L_PAGCNT(R10),MMG$GL_GBLPAGFIL
	BGEQ	391$			;NO PROBLEMS
	ADDL3	SEC$L_PAGCNT(R10),MMG$GL_GBLPAGFIL,R0
	PUSHL	#SS$_EXGBLPAGFIL
	BRW	FRESTXERR		;THIS WILL ALSO FIX UP THE LIMIT
;
BRGSTFULL: BRW	GSTFULL
;
;
; INITIALIZE GLOBAL PAGE TABLE ENTRIES
;
; R2 = ADDRESS OF FIRST GPTE ALLOCATED, FRONT STOPPER GPTE
; R7 = DESIRED SECTION PAGE COUNT
; R10 = SECTION TABLE ENTRY ADDRESS
;
40$:	CLRL	(R2)+			;SET FRONT STOPPER FOR GLOBAL SECTION
	MOVL	R2,R3			;FIRST GPTE ADDRESS
	SUBL	MMG$GL_GPTBASE,R2	;BYTE OFFSET FROM BEGINNING OF GPT
	DIVL	#4,R2			;LONG WORD OFFSET = GPTX
	BISL	R2,SEC$L_VPXPFC(R10)	;PUT GPTX IN (PFC ALREADY PRESENT)
;
; R3 = ADDRESS OF FIRST GLOBAL PTE TO FILL IN
; R5 = PROCESS HEADER ADDRESS FOR SYSTEM
; R7 = SECTION PAGE COUNT
;
	MOVL	#2@PTE$V_OWN,R2		;GLOBAL DZRO FORMAT FOR PAGE FILE BACKING STORE
	BBS	#SEC$V_PAGFIL,R9,45$	;PAGE FILE BACKING STORE
	ASSUME	SEC$V_DZRO EQ SEC$V_CRF+1 ;REQUIRE BITS TO BE ADJACENT
	ASSUME	SEC$V_WRT EQ SEC$V_DZRO+1
	EXTZV	#SEC$V_CRF,#3,SEC$W_FLAGS(R10),R2 ;CRF, DZRO, AND WRT BITS
	BISW	#<PTE$M_TYP1 ! PTE$M_TYP0 !- ;SECTION TYPE PTE
		<2@PTE$V_OWN>>@-16,R2	;OWNER FIELD USED FOR GLOBAL BITS
	ASSUME	GSD$W_GSTX GE 2
	MOVL	GSD$W_GSTX-2(R6),R1	;HIGH 16 BITS OF R1 = SEC TBL INDEX
	ASHQ	#16,R1,R1		;R2 = PAGE TABLE ENTRY
	BBC	#SEC$V_WRT,SEC$W_FLAGS(R10),50$ ;BRANCH IF NOT WRITABLE
45$:	BBSS	#PTE$V_OWN,R2,50$	;SET GBLWRT BIT IN OWNER FIELD
50$:
;
; R7 = COUNT OF GLOBAL PAGE TABLE ENTRIES TO LOCK AND FILL IN
; R2 = PAGE TABLE ENTRY TO STORE IN NEW GPTE'S
; R3 = ADDRESS OF FIRST GLOBAL PAGE TABLE ENTRY
;
60$:	MOVB	#IPL$_SYNCH,(R3)	;SET UP TO REFERENCE PAGE AND
	MTPR	(R3),B^PRIPL		;FAULT IN CODE AND RAISE TO SYNCH
					;ALL IN ONE INSTRUCTION
	JSB	G^MMG$INCPTREF		;LOCK THE GLOBAL PAGE TABLE
	SETIPL	#IPL$_ASTDEL		;BACK TO PAGE FAULTABLE STATE
	MOVL	R2,(R3)+		;STORE NEW GPT ENTRY
	SOBGTR	R7,60$			;LOOP THROUGH SPECIFIED NO. OF PTE'S
	CLRL	(R3)			;ZERO STOPPER AT END OF GLOBAL SECTION
70$:	EXTZV	#SEC$V_SYSGBL,#1,R9,R0	;SYSTEM OR GROUP GLOBAL BIT
	MOVAQ	G^EXE$GL_GSDGRPFL[R0],R0 ;ADDRESS OF APPROPRIATE LIST

;
; QUEUE THE NEW GSD ON THE FRONT OF THE APPROPRIATE LIST.  PLACING IT ON THE
; FRONT ALLOWS FOR THE INSTALLATION OF A NEW COPY OF SAY A FORTRAN OTS WITH
; AN IDENT THAT IS GREATER THAN THE OLD BUT UPWARD COMPATIBLE.  THE NEW ONE
; IS FOUND FIRST IF THE MATCH IS MATLEQ.  THE OLD ONE IS STILL AVAILABLE FOR
; MATCH EQUAL.
;
	INSQUE	(R6),(R0)		;PLACE GSD ON THE SYSTEM OR GROUP GLOBAL LIST
	BRW	MAPGBLSEC2		;GO MAP THE SECTION

PRIPL:					;THE PROCESSOR REGISTER NUMBER IS
	.LONG	PR$_IPL			;PLACED IN THIS LOCATION, INSTEAD OF
					;BEING REFERENCED SYMBOLICALLY ABOVE,
					;TO FAULT IN THE CODE THAT IS TO BE
					;EXECUTED AT RAISED IPL.
	ASSUME	<.-60$> LE 512		;PREVENT INTERVENING PAGE

;
; GLOBAL PAGE TABLE FULL
; R0 = SYSTEM STATUS CODE
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R10 = SECTION TABLE ENTRY ADDRESS
;
GPTFULL:
	PUSHL	#SS$_GPTFULL		;GLOBAL PAGE TABLE FULL
FRESTXERR:
	TSTL	SEC$L_WINDOW(R10)
	BNEQ	79$
	ADDL	SEC$L_PAGCNT(R10),MMG$GL_GBLPAGFIL ;PAGE FILE BACKING STORE - ADJUST LIMIT
79$:	CLRL	SEC$L_GSD(R10)		;GSD WILL BE DELETED BELOW
	ASSUME SEC$L_PAGCNT EQ SEC$L_REFCNT+4 ;FIELDS MUST BE ADJACENT
	CLRQ	SEC$L_REFCNT(R10)	;SET INDICATORS FOR DELGBLSEC
	BBCC	#SEC$V_PERM,SEC$W_FLAGS(R10),80$ ;LET SECTION BE DELETED
80$:	BBSSI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),90$ ;SET DELETION FLAG
90$:	BSBW	MMG$DALCSTXSCN		;SCAN FOR SECTIONS TO DEALLOCATE
	MOVL	(SP)+,R0		;GET ERROR CODE
;
; GLOBAL SECTION TABLE FULL
; R0 = SYSTEM STATUS CODE
;
GSTFULL:
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BEQL	RELEAS_EXTGSD		;BR IF TO DELETE EXTENDED GSD
	INSQUE	(R6),G^EXE$GL_GSDFREFL	;PUT GSD BACK ON FREE LIST
;
; UNLOCK THE GLOBAL SECTION MUTEX AND RETURN WITH STATUS CODE IN R0
;
ULKGSDMTXRET:
	PUSHL	R0			;SAVE STATUS CODE
	BSBW	MMG$GSDMTXULK		;UNLOCK THE GSD MUTEX
					;RETURNS R4=PCB ADR FOR MMG$DELGBLWCB
EXTGSD_RET:
	BSBW	MMG$DELGBLWCB		;DELETE ANY GLOBAL WINDOW CONTROL BLOCKS
	POPL	R0			;RESTORE ERROR STAUS CODE TO RETURN
	SETIPL	B^MMG$L_CALLEDIPL(FP)	;RESTORE CALLER'S IPL
MAPSEC_RET:
	RET
RELEAS_EXTGSD:
	PUSHL	R0			;REMEMBER ERROR CODE TO RETURN
	MOVL	R6,R0			;SET ADR OF BLOCK TO BE DEALLOCATED
	JSB	G^EXE$DEAPAGED		;RELEASE EXTENDED GSD
	BRB	EXTGSD_RET		;RETURN TO CALLER

	.DSABL	LSB

	.SBTTL	MGBLSC - MAP GLOBAL SECTION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THE MAP GLOBAL SECTION SYSTEM SERVICE MAPS A SPECIFIED GLOBAL
; SECTION INTO A SPECIFIED RANGE OF VIRTUAL ADDRESS SPACE.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$MGBLSC
;
; INPUT PARAMETERS:
;
;	INADR(AP) = ADDRESS OF 2 LONG WORDS THE 1ST OF WHICH SPECIFIES
;		THE STARTING VIRTUAL ADDRESS TO CREATE, THE 2ND SPECIFIES
;		THE ENDING VIRTUAL ADDRESS TO CREATE (INCLUSIVE).
;	RETADR(AP) = ADDRESS OF A 2 LONGWORD ARRAY INTO WHICH IS RETURNED
;		THE STARTING AND ENDING VIRTUAL ADDRESSES (INCLUSIVE)
;		OF THE PAGES JUST CREATED
;	ACMODE(AP) = THE ACCESS MODE (MAXIMIZED WITH CALLING MODE)
;		USED AS THE OWNER OF THE NEW PAGE(S)
;	FLAGS(AP)  = BIT  0  - GBL - GLOBAL IF SET, PROCESS IF CLEAR
;		     BIT  1  - CRF - COPY ON REFERENCE
;		     BIT  2  - DZRO - DEMAND ZERO
;		     BIT  3  - WRT - WRITABLE IF SET, READ ONLY IF CLEAR
;		     BITS 4 - 5, RESERVED, MUST BE ZERO
;		     BITS 6 & 7 - WRTMOD - WRITE ACCESS FOR SECTION
;		     BITS 8 - 13 RESERVED, MUST BE ZERO
;		     BIT  14 - PERM - PERMANENT IF SET, TEMPORARY IF CLEAR
;		     BIT  15 - SYSGBL - SYSTEM GLOBAL IF SET, GROUP GLOBAL IF CLEAR
;		     BIT  16  - PFNMAP - MAP TO SPECIFIC PFN'S, IF SET
;		     BIT  17  - EXPREG - MAP TO FIRST FREE SPACE AVAILABLE
;		     BIT  18 - PROTECT - SET IF WRITE ACCESS MODE SPECIFIED
;		     BITS 19  - 31 RESERVED, MUST BE ZERO
;	GSDNAM(AP) = THE DESCRIPTOR OF THE GLOBAL SECTION NAME
;	IDENT(AP)  = ADDRESS OF QUAD WORD CONTAINING SECTION IDENTIFICATION
;		     FIRST LONG WORD CONTAINS THE MATCH CONTROL INFORMATION
;			0 = ISD$K_MATALL, MATCH ALWAYS
;			1 = ISD$K_MATEQU, MATCH IF IDENTS ARE EQUAL
;			2 = ISD$K_MATLEQ, MATCH IF HIGH 8 BITS ARE EQUAL
;			    AND LOW 24 BITS ARE LESS THAN OR EQUAL TO
;			    THE ID STORED IN THE GLOBAL SECTION.
;		     SECOND LONG WORD CONTAINS THE IDENT TO BE COMPARED
;	RELPAG(AP) = RELATIVE PAGE IN SECTION TO START MAPPING
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESS
;	SS$_IVSECFLG - INVALID SECTION FLAGS
;	SS$_ENDOFFILE - END OF FILE ENCOUNTERED
;	SS$_NOPRIV - NO PRIVILEGE FOR ATTEMPTED OPERATION
;	SS$_VASFULL - VIRTUAL ADDRESS SPACE FULL
;	SS$_IVLOGNAM - INVALID LOGICAL NAME
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAMES (DEPTH > 10)
;	SS$_SHMNOTCNCT - SHARED MEMORY DATA STRUCTURES NOT CONNECTED
;	SS$_NOSUCHSEC - NO SUCH GLOBAL SECTION
;	SS$_PAGOWNVIO - PAGE OWNER VIOLATION (RE-MAPPING PAGES ALREADY IN USE)
;	SS$_EXQUOTA - EXCEEDED PAGING FILE QUOTA (FOR CRF SECTIONS)
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC
;
; **********************************************************************
;

	.PSECT	Y$EXEPAGED		;PUT ENTRY POINT INTO SEPARATE PSECT

;*************  EXE$MGBLSC  ENTRY POINT

	.ENTRY	EXE$MGBLSC,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_MGBLSC		;TRANSFER TO REAL PROCEDURE

	.PSECT	YF$$SYSCRMPSC		;BACK TO $CRMPSC PSECT

EXE_MGBLSC:
	SUBL	S^#-MMG$C_LENGTH,SP	;RESERVE A SCRATCH STORAGE AREA
	BSBW	MMG$INADRINI		;GET INPUT RANGE TO R4, R5
					;INIT RETURN RANGE AND SCRATCH AREA
	PUSHL	#0			;REMEMBER NO START RETADR YET
	PUSHL	#SS$_NORMAL		;SAVE SUCCESS RETURN CODE
	PUSHR	#^M<R4,R5>		;PUSH ENDVA, STARTVA
	MOVL	FLAGS(AP),R0		;SECTION FLAGS
	BSBW	MMG$VFYSECFLG		;VERIFY SECTION FLAGS
	MOVL	R0,R9			;USE VERIFIED SECTION FLAGS
	MOVL	G^SCH$GL_CURPCB,R4	;PROCESS CONTROL BLOCK ADDRESS
	MOVAL	G^EXE$GL_GSDMTX,R0	;GLOBAL SECTION MUTEX
	JSB	G^SCH$LOCKW		;LOCK GSD FOR WRITING
	BSBW	MMG$DALCSTXSCN1		;SCAN FOR SECTIONS TO DELETE
;
; RETURNS AT ASTDEL
;
	SUBL	#<6*4>,SP		;RESERVE SPACE FOR GSD NAME
	MOVL	SP,R7			;ADDRESS OF SCRATCH SPACE

	ASSUME	IDENT EQ GSDNAM+4
	MOVQ	GSDNAM(AP),R0		;DESCRIPTOR ADDRESS FOR GLOBAL SECTION NAME
					;ADDRESS OF IDENTIFICATION QUAD WORD
	MOVL	R9,R6			;SECTION FLAGS
	BSBW	MMG$GSDSCN		;SCAN GSD'S FOR THIS NAME
	BLBS	R0,5$			;BRANCH IF SECTION FOUND
	CMPL	#SS$_NOSUCHSEC,R0	;WAS THE ERROR DUE TO SECTION NOT FOUND?
	BNEQ	ULKGSDMTXRET		;IF NO, RETURN ERROR CODE TO CALLER
;
; 0(SP) = STARTVA, 4(SP) = ENDVA
; 8(SP) = SUCCESS CODE (SS$_NORMAL OR SS$_EXISTED) TO BE RETURNED IF
;	MAPPING IS SUCCESSFUL.
; R4 = SHARED MEMORY CONTROL BLOCK ADDRESS IF GLOBAL SECTION IS IN SH MEM
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R6 = GLOBAL SECTION DESCRIPTOR BLOCK ADDRESS
; R9 = SECTION FLAGS
; R10 IS   0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	  -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	  >0 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED

;
; IF THE GLOBAL SECTION WAS NOT FOUND, PERHAPS IT IS BECAUSE THE SECTION IS
; COPY AND REFERENCE AND THERE WAS A LOGICAL NAME WHICH STATED IT WAS IN
; SHARED MEMORY.  SINCE CRF SECTIONS ARE PLACED IN LOCAL MEMORY INSTEAD OF
; SHARED MEMORY, USE THE RESULTANT GLOBAL SECTION NAME AND SEARCH FOR THAT
; IN LOCAL MEMORY.  THIS IS DONE BY FORCING NO LOGICAL TRANSLATION OF THE
; GLOBAL SECTION NAME (PREFIXING IT WITH AN UNDERSCORE).
;
	BSBW	MMG$FINDGSNOTRN		;FIND GSD WITH NO LOGICAL TRANSLATION
5$:	ADDL2	#<6*4>,SP		;RECLAIM THE SCRATCH AREA
	BLBC	R0,ULKGSDMTXRET		;BRANCH IF SECTION NOT FOUND
;
MAPGBLSEC1:
	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS GS IN SHARED MEMORY?
	BEQL	7$			;BR ON YES, CAN'T ALWAYS ACCESS SEC TBL
	CVTWL	GSD$W_GSTX(R6),R10	;IS GS MAPPED TO A FILE?
	BEQL	7$			;BR ON NOT MAPPED TO A FILE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R0 ;BASE ADDRESS OF SECTION TABLE
	MOVAL	(R0)[R10],R10		;ADDRESS OF SECTION TABLE ENTRY
7$:	ROTL	#31-SEC$V_CRF,GSD$W_FLAGS(R6),R0 ;GET FLAGS FROM GSD
	BGEQ	10$			;BRANCH IF NOT COPY ON REFERENCE
	BBSS	S^#MMG$V_CHGPAGFIL,B^MMG$L_MAXACMODE(FP),10$
					;MUST CHARGE PAGES AGAINST PAGE FILE QUOTA
10$:	EXTZV	#<SEC$V_AMOD-<SEC$V_CRF+1>>,- ;GET ACCESS MODE OF SECTION
		#SEC$S_AMOD,R0,R0
	CMPB	B^MMG$L_MAXACMODE(FP),R0 ;SEE IF THIS CALLER CAN MAP THE SECTION
	BGTR	MGBLSC_NOPRIV		;BRANCH IF CANNOT MAP THE SECTION
	CMPB	GSD$B_TYPE(R6),#DYN$C_GSD ;WHAT TYPE OF GSD IS THIS?
	BNEQU	MAPGBLSEC2		;BR IF NOT LOCAL MEMORY TYPE
	INCL	SEC$L_REFCNT(R10)	;BIAS THE SECTION REFERENCE COUNT
					;SO THAT IT CAN'T BE DELETED
;
; R5  = SYSTEM PROCESS HEADER ADDRESS
; R9  = SECTION FLAGS
; R10 = SECTION TABLE ENTRY ADDRESS
;
	ASSUME DYN$C_EXTGSD GT DYN$C_GSD
	ASSUME DYN$C_EXTGSD LT DYN$C_SHMGSD
MAPGBLSEC2:
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS EXTENDED GSD?
	BNEQU	MAPGBLSEC3		;BR IF LOCAL MEMORY OR SHARED MEMORY
	INCL	GSD$L_REFCNT(R6)	;YES, BIAS GSD REFCNT SO IT CAN'T
					;BE DELETED BUT MUTEX CAN BE UNLOCKED
MAPGBLSEC3:
	.ENABL	LSB
	PUSHL	R4			;SAVE SHB ADDRESS
	BSBW	MMG$GSDMTXULK		;UNLOCK THE GLOBAL SECTION MUTEX
	POPL	R4			;RESTORE SHB ADDRESS
	MOVL	R6,R11			;SAVE GSD ADR FOR ERROR PATH RECOVERY
	BBC	#SEC$V_EXPREG,R9,MAPGBLSEC4 ;BR IF RANGE IS EXPLICITLY STATED
;
; FIND THE FIRST AVAILABLE VIRTUAL ADDRESS AND COMPUTE THE RANGE TO BE MAPPED.
;
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;WHAT TYPE OF GSD IS THIS?
	BLSSU	30$			;BR IF LOCAL MEMORY GSD
	BEQL	40$			;BR IF EXTENDED GSD
	CLRL	R1			;INITIALIZE COUNT OF PAGES IN SHMGSD
	MOVZBL	#GSD$C_PFNBASMAX,R7	;MAX NUMBER OF BASES ALLOWED
	MOVAB	GSD$L_BASPFN1(R6),R8	;ADR OF FIRST GSD BASE PFN
10$:	TSTL	(R8)+			;IS THIS BASE USED?
	ADDL2	(R8)+,R1		;ADD THESE PAGES INTO SIZE OF SECTION
20$:	SOBGTR	R7,10$			;REPEAT FOR NEXT BASE
	BRB	50$			;JOIN COMMON CODE
30$:	MOVL	SEC$L_PAGCNT(R10),R1	;SIZE OF LOCAL MEMORY GLOBAL SECTION
	BRB	50$			;JOIN COMMON CODE

MGBLSC_NOPRIV:
	BRW	CRMPSC_NOPRIV		;NO PRIV TO MAP GLOBAL SECTION

40$:	MOVL	GSD$L_PAGES(R6),R1	;SIZE OF EXTENDED GSD SECTION
50$:	MOVL	RELPAG(AP),R0		;GET # OF PAGES NOT TO BE MAPPED
	BLSS	55$			;BR IF ILLEGAL NUMBER OF PAGES
	CMPL	R0,R1			;ARE MORE PAGES SKIPPED THAN IN SECTION?
	BGEQ	55$			;BR IF ILLEGAL NUMBER OF PAGES
	SUBL	R0,R1			;GET # OF PAGES IN SECTION TO MAP
	ASHL	#9,R1,R1		;CONVERT PAGE COUNT TO # OF
	DECL	R1			;BYTES BETWEEN START VA AND END VA
	MOVL	@#CTL$GL_PHD,R0		;GET PROCESS HEADER FOR PROCESS
	POPR	#^M<R2,R3>		;FIND REGION TO MAP SECTION INTO
	BBC	#VA$V_P1,R2,60$		;BR IF MAPPING INTO P0 SPACE
	ADDL3	#^X1FF,PHD$L_FREP1VA(R0),R3 ;ENDING VA IN P1 SPACE
	SUBL3	R1,R3,R2		;STARTING VA IN P1 SPACE
	BRB	70$			;JOIN COMMON CODE
55$:	BRW	ILL_RELPAG		;BR TO RETURN ERROR CODE
60$:	MOVL	PHD$L_FREP0VA(R0),R2	;STARTING VA IN P0 SPACE
	ADDL3	R1,R2,R3		;ENDING VA IN P0 SPACE
70$:	PUSHR	#^M<R2,R3>		;REMEMBER VA RANGE TO BE MAPPED
	.DSABL	LSB
;
; BUILD A PAGE TABLE ENTRY TO PUT IN THE PROCESS PAGE TABLE
;
MAPGBLSEC4:
	.ENABLE	LSB
	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS A MAP BY PFN?
	BLSSU	6$			;NO, BR TO CREATE LOCAL MEM GPTX PTE
	BEQL	5$			;YES, BR TO CREATE VALID WINDOW PTE
	MOVZBL	#GSD$C_PFNBASMAX,R7	;GET # OF BASES ALLOWED
	MOVAB	GSD$L_BASPFN1(R6),R10	;GET ADR OF FIRST PFN BASE
MAP_NXT_BASE:
	MOVL	(R10)+,R8		;GET PFN BASE FOR FIRST PIECE OF SECTION
	MOVL	(R10)+,R9		;GET SIZE OF FIRST PIECE OF SECTION
	BNEQ	3$			;BR IF MORE SECTION TO MAP
	BRW	NO_MORE_PAGES		;BR IF ALL SECTION MAPPED
3$:	ADDL2	SHB$L_BASGSPFN(R4),R8	;ADD IN BASE PFN FOR GS PAGES
	BBCS	#PTE$V_VALID,R8,4$	;SET VALID BIT IN PTE
4$:	PUSHR	#^M<R9,R10>		;SAVE ADR OF PFN BASES AND PIECE SIZE
	CLRL	R10			;FORCE USE OF GSD FLAGS
	MOVL	MMG$L_VFYFLAGS(FP),R9	;RESTORE FLAGS FOR SETSECPROTOWN CALL
	BSBW	SETSECPROTOWN		;SET SECTION PROTECTION AND OWNER
	POPR	#^M<R9,R10>		;RESTORE ADR OF PFN BASES AND PIECE SIZE
	BRB	8$			;BR PAST NO SECTION TABLE CODE
5$:	CLRL	R10			;REMEMBER NO SECTION TABLE ENTRY EXISTS
	MOVL	GSD$L_BASEPFN(R6),R8	;CREATING VALID PTE
	BISL2	#<PTE$M_VALID ! PTE$M_WINDOW>,R8 ;SET VALID & WINDOW
	BRB	7$			;SKIP PAGE TABLE INDEX
6$:	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,- ;GET THE FIRST GLOBAL
		SEC$L_VPXPFC(R10),R8	;PAGE TABLE INDEX
7$:	BSBW	SETSECPROTOWN		;SET SECTION PROTECTION AND OWNER
8$:	MOVL	R6,R11			;SAVE GSD ADDRESS FOR MMG$MAPSECPAG
	BLBC	R0,13$			;BRANCH IF PROTECTION VIOLATION
	CMPL	#SS$_NORMAL,R0		;WAS THERE AN ALTERNATE SUCCESS CODE?
	BEQL	9$			;BR IF CODE WAS NORMAL SUCCESS
	MOVL	R0,8(SP)		;SET ALTERNATE RETURN CODE
;
; R4= SHB ADDRESS, IF GLOBAL SECTION IS IN SHARED MEMORY
; VALIDATE THIS PROCESS' ACCESS TO THIS FILE
; NOTE: SINCE REFCNT IS INCREMENTED ABOVE, GSD CAN'T GO AWAY EVEN THOUGH
; GSD MUTEX IS RELEASED.
;
9$:	MOVL	GSD$L_FILUIC(R6),R2	;GET FILE OWNER
	BEQL	15$			;BRANCH IF SKIPPING FILE PROTECTION CHECK
	MOVZWL	GSD$W_PROT(R6),R1	;AND PROTECTION
;
; CHECK THAT THE CALLER HAS READ OR WRITE ACCESS TO THE SECTION
; ACCORDING TO HOW IT IS TO BE MAPPED.
;
	MOVL	G^SCH$GL_CURPCB,R0	;SET CURRENT PROCESS CONTROL BLOCK ADR
	MOVL	PCB$L_ARB(R0),R0	;GET ACCESS RIGHTS BLOCK
	MOVAL	EXE$CHKRDACCES,R3	;ADDRESS OF READ ACCESS CHECK
	BBC	#SEC$V_WRT,MMG$L_VFYFLAGS(FP),10$ ;BR IF NOT WRITING THE SECTION
	BBS	#SEC$V_CRF,MMG$L_VFYFLAGS(FP),10$ ;CRF DOESNT NEED WRITE ACCESS
	MOVAB	B^<EXE$CHKWRTACCES-EXE$CHKRDACCES>(R3),R3 ;ADR OF WRITE ACCESS CHECK
					;R0=ADDRESS OF ACCESS RIGHTS BLOCK
					;R1=PROTECTION MASK
					;R2=UIC ASSOCIATED WITH PROTECTION MASK
10$:	JSB	(R3)			;CALL THE ACCESS CHECK ROUTINE
	BLBS	R0,15$			;BRANCH IF CALLER HAS DESIRED ACCESS
13$:	BRW	PRE_MAP_ERR		;BRANCH IF ACCESS DENIED
;
; R7 - COUNT OF PFN BASES ALLOWED IN GSD
; R10 - ADR OF NEXT PFN BASE IN GSD
;
15$:	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BLSSU	MAP_LOCAL_MEM		;NO, GO USE SECTION TABLE ENTRY
	BGTRU	SHM_GSD			;NO, GO USE SHARED MEMORY GSD
	MOVL	GSD$L_PAGES(R6),R9	;YES, GET # OF PAGES IN SECTION FROM GSD
	BRB	30$			;SKIP FINDING # PAGES FROM SECTION TBL
SHM_GSD:
	CMPB	#GSD$C_PFNBASMAX,R7	;IS THIS THE FIRST BASE?
	BNEQ	COMMON_MAP		;NO, BR THEN TO SKIP RELPAG OFFSETING
	MOVL	RELPAG(AP),R0		;GET STARTING RELATIVE PAGE TO MAP
	CMPL	R0,R9			;SEE IF RELPAG IS PAST THIS PIECE
	BLSSU	COMMON_MAP		;BR IF MUST MAP PART OF THIS PIECE
20$:	DECL	R7			;DEC COUNT OF PIECES OF SECTION TO MAP
	BNEQ	TRY_NXT_BASE		;BR IF ANOTHER PIECE TO MAP (MAYBE)
ILL_RELPAG:
	MOVZWL	#SS$_ENDOFFILE,R0	;REMEMBER THERE WERE NO PAGES TO MAP
	BRW	PRE_MAP_ERR		;BR IF NO SECTION TO MAP AT ALL
TRY_NXT_BASE:
	MOVL	(R10)+,R8		;GET PFN BASE OF NEXT PIECE
	ADDL2	(R10)+,R9		;ADD NEXT BASE COUNT TO RELPAG OFFSET
	CMPL	R0,R9			;IS RELPAG PAST THIS PIECE?
	BGEQU	20$			;BR IF NOTHING IN THIS PIECE TO MAP
	SUBL2	R0,R9			;GET OFFSET TO FIRST PFN TO MAP
	SUBL3	R9,-4(R10),R0		;GET # OF PAGES IN PIECE NOT MAPPED
	ADDL2	R0,R8			;GET FIRST PFN TO BE MAPPED
	BRW	3$			;BR TO CREATE PTE
MAP_LOCAL_MEM:
	MOVL	SEC$L_PAGCNT(R10),R9	;NUMBER OF PAGES IN THE SECTION
30$:	MOVL	RELPAG(AP),R0		;STARTING RELATIVE PAGE TO MAP
	BLSS	ILL_RELPAG		;BR IF ILLEGAL RELPAG, NEGATIVE
	CMPL	R0,R9			;IS RELPAG WITHIN THE SECTION?
	BGEQ	ILL_RELPAG		;BR IF ILLEGAL RELPAG, PAST SECTION
	SUBL	R0,R9			;FEWER PAGES TO MAP
	ADDL	R0,R8			;BIAS STARTING GPTX
35$:	CMPB	GSD$B_TYPE(R6),#DYN$C_GSD ;IS THIS NORMAL GSD?
	BNEQ	COMMON_MAP		;BR ON NO, DON'T SET TYP0 BIT
	BBSS	#PTE$V_TYP0,R8,COMMON_MAP ;GLOBAL PAGE TYPE
;
; 0(SP) = STARVA, 4(SP) = ENDVA
; R6 = GLOBAL SECTION DESCRIPTOR BLOCK ADDRESS
; R8 = STARTING PTE CONTENTS, R9 = MAXIMUM PAGE COUNT TO MAP
; R10 = GLOBAL SECTION TABLE ADDRESS
;
COMMON_MAP:
	POPR	#^M<R2,R3>		;R2 = STARTVA, R3 = ENDVA
	MCOML	R2,R0			;STARTVA = -1?
	BEQL	84$			;BRANCH IF YES, NO RANGE TO MAP
	DECL	R9			;PAGE COUNT BASE 0
	CMPL	R2,R3			;CHECK DIRECTION OF MAPPING
	BLSSU	60$			;BRANCH IF FORWARDS
	BGTRU	50$			;BRANCH IF BACKWARDS
	BBC	#VA$V_P1,R2,60$		;WHEN EQUAL, FORWARD IF P0, BACKWARDS IF P1
50$:	ADDL	R9,R8			;START AT LAST GPTX WHEN MAPPING BACKWARDS
60$:	MOVAL	W^MMG$MAPSECPAG,R6	;MAP SECTION PAGE ROUTINE
	PUSHR	#^M<R3,R4,R7,R10>	;SAV VA RANGE,SHB,PFNBASCNT,PFNBAS ADR
	CMPB	GSD$B_TYPE(R11),#DYN$C_SHMGSD ;IS THIS A SHARED MEMORY GSD?
	BNEQ	65$			;BR IF IT IS NOT
	CLRL	R10			;INIDICATE NO GST CNT TO INCREMENT
65$:	BSBW	MMG$CRECOM2		;USE THE COMMON CREATE PAGE CODE
	SUBL3	R1,R2,R9		;GET # BYTES ACTUALLY MAPPED
	BGEQ	67$			;BR IF RANGE IS IN INCREASING ORDER
	MNEGL	R9,R9			;NEGATE THE BYTE COUNT, RANGE DECR ORDER
67$:	ASHL	#-9,R9,R9		;CONVERT BYTE COUNT TO PAGE COUNT
	POPR	#^M<R3,R4,R7,R10>	;GET VA RANGE,SHB,PFNBASCNT,PFNBAS ADR
	INCL	R9			;ACTUAL COUNT OF PAGES MAPPED
	BLBS	R0,80$			;IF SUCCESSFUL USE SUCCESS STATUS
					;ALREADY ON TOP OF STACK
70$:	MOVL	R0,(SP)			;OTHERWISE SAVE ERROR STATUS
;
; 0(SP) = SYSTEM STATUS CODE
; R11 = GLOBAL SECTION DESCRIPTOR ADDRESS
;
80$:	CMPB	GSD$B_TYPE(R11),#DYN$C_EXTGSD ;IS THIS AN EXTENDED GSD?
	BLSSU	85$			;NO, BR TO CLEAN UP SECTION TBL ENTRY
	BGTRU	PIECE_MAPPED		;NO, BR IF SHARED MEMORY GSD
82$:	MOVAL	G^EXE$GL_GSDMTX,R0	;GET MUTEX TO LOCK
	MOVL	G^SCH$GL_CURPCB,R4	;GET ADR OF PROCESS PCB
	JSB	G^SCH$LOCKW		;LOCK GSD MUTEX FOR WRITING
	DECL	GSD$L_REFCNT(R11)	;RELEASE THE GSD TO ALLOW DELETION
	BSBW	MMG$GSDMTXULK		;UNLOCK GSD MUTEX
	BRB	90$			;ALL DONE
84$:	CLRL	R9			;INDICATE NO PAGES MAPPED
	BRB	80$			;JOIN COMMON CODE
85$:	CVTWL	GSD$W_GSTX(R11),R1	;SECTION INDEX
	MOVAL	@L^MMG$GL_SYSPHD,R5	;SYSTEM PROCESS HEADER
	JSB	G^MMG$DECSECREF		;REMOVE SECTION REFERENCE BIAS
88$:	MOVL	G^SCH$GL_CURPCB,R4	;GET ADR OF PROCESS PCB
	BSBW	MMG$DELGBLWCB		;DELETE ANY GLOBAL WINDOWS
90$:	POPR	#^M<R0>			;SYSTEM STATUS CODE
	RET				;RETURN STATUS TO CALLER
;
; THE USER REQUESTED THAT NO PAGES BE MAPPED OR THERE WAS AN ERROR BEFORE
; THE PAGES WERE MAPPED.  SHARED MEMORY GSD'S MUST BE MAPPED FOR CREATION; THIS
; IS CHECKED IN $CRMPSC (FOR A VALID RELPAG, ONLY).
;
PRE_MAP_ERR:
	MOVL	R0,(SP)			;SAVE RETURN ERROR CODE
110$:	CMPB	GSD$B_TYPE(R11),#DYN$C_EXTGSD ;WHAT TYPE OF GSD IS THIS?
	BLSSU	85$			;BR IF LOCAL MEMORY
	BEQL	82$			;BR IF EXTENDED GSD
	MOVZBL	#1,R0			;ONE REF COUNT FOR A LOCK
	JSB	G^MMG$DECSHMREF		;RELEASE THE GSD LOCK
	BBS	#GSD$V_VALID,GSD$L_GSDFL(R6),88$ ;BR IF NOT CREATING GS
	BRW	SHM_UNMAPPED		;BR TO DELETE GS AS CANNOT ALWAYS
					;INITIALIZE A SHARED MEMORY GS.
;
; A PIECE OF A SHARED MEMORY GLOBAL SECTION HAS BEEN MAPPED.  UPDATE THE
; RETURN RANGE OF VIRTUAL ADDRESSES MAPPED AND SET UP TO MAP THE NEXT PIECE.
;
PIECE_MAPPED:
	MOVL	R9,R0			;GET COUNT OF PTE'S JUST CREATED
	BEQL	140$			;BR IF NOTHING MAPPED
	MOVL	R11,R6			;RESTORE GSD ADR
	BBS	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),120$ ;BR IF UN-MAPPING GS
					;R4=SHB ADDRESS
	JSB	G^MMG$INCSHMREF		;INCREMENT THE PROCESSOR REF COUNT
	TSTL	4(SP)			;IS START RETADR A VALID ADR?
	BNEQ	120$			;BR ON YES, FIRST ADR MAPPED SET
	MOVL	R1,4(SP)		;ASSUME RETADR NOT SPEC, USE INADR VALUE
120$:	PUSHR	#^M<R2,R3>		;REMEM NEW START VA AND END VA
	INCL	(SP)			;ROUND NEW START VA TO PAGE BOUNDRY
	DECL	R7			;ONE LESS PIECE OF SECTION TO MAP
	BLEQ	NO_MORE_PAGES		;BR IF NO MORE PIECES IN SECTION
	CMPL	R2,R3			;MAPPED BACKWARDS?
	BGTRU	125$			;BR IF YES, RETURN ERROR CODE
	BBS	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),122$ ;BR IF UN-MAPPING GS
	BLBC	8(SP),NO_MORE_PAGES	;DON'T TRY TO MAP MORE IF GOT ERROR
122$:	BRW	MAP_NXT_BASE		;BR ON ANOTHER PIECE TO MAP/UNMAP


124$:	BRB	88$			;HOP, SKIP FOR BROKEN BRANCH DISPLACEMENT


125$:	MOVZWL	#SS$_IVSSRQ,8(SP)	;*** BACKWARDS MAPPING IS BROKEN
					;*** FOR MULTIPLE PIECE SECTIONS
;
; NO MORE PIECES OF SHARED MEMORY SECTION LEFT TO MAP.  THIS MAY OR MAY NOT
; BE AN ERROR, DEPENDING UPON WHETHER OR NOT AT LEAST ONE PAGE WAS MAPPED.
;
NO_MORE_PAGES:
	POPR	#^M<R2,R3>		;CLEAN OFF START VA AND END VA
	MOVL	MMG$L_SAVRETADR(FP),R0	;GET ADDRESS OF RETURN ADR BUFFER
	BEQL	140$			;BR ON RETURN ADDRESS NOT REQUESTED
	IFNOWRT	#8,(R0),140$		;CHECK IF BUFFER IS ACCESSIBLE
	MOVL	4(SP),(R0)		;RESET TO VERY 1ST STARTVA IN RET RANGE
140$:	MOVZBL	#1,R0			;ONE REF COUNT FOR THE GSD LOCK
					;R4=SHB ADDRESS
	JSB	G^MMG$DECSHMREF		;REMOVE THE GSD LOCK
	BBSC	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),SHM_UNMAPPED ;BR IF INIT FAILED
	BBSSI	#GSD$V_VALID,GSD$L_GSDFL(R6),124$ ;BR ON $MGBLSC REQUEST
;
; THE GLOBAL SECTION DESCRIPTOR WAS NOT VALID.  THEREFORE, THE GSD IS BEING
; MAPPED DUE TO A $CRMPSC REQUEST.  THE PAGES MUST NOW BE INITIALIZED.
; 
					;R6=GSD,INADR(AP),(SP)=MAP STATUS CODE
	MOVL	4(SP),R2		;STARTVA FOR VERY FIRST PAGE MAPPED
	BSBW	MMG$READ_GSD		;BR TO READ SECTION INTO MEMORY
	BLBC	R0,RELEAS_SHMGS		;BR IF FAILED TO INIT SECTION PAGES
;
; NOW THE SHARED MEMORY GSD TABLE MUST BE SEARCHED, CHECKING FOR SUCCESSFUL
; CREATION OF A GLOBAL SECTION WITH THE SAME NAME AS THE ONE BEING CREATED.
; THIS ALLOWS THE GSD TABLE TO BE OPEN FOR ACCESS DURING THE LENGTHY PROCESS
; OF INITIALIZING THE SECTION PAGES.  HOWEVER, IT ALSO ALLOWS TWO USERS TO
; TRY TO CREATE THE SAME SECTION AT THE SAME TIME.
;
					;R11=GSD,R4=SHB
	BSBW	MMG$UNIQUEGSD		;VALIDATE THAT THE NEW GSD IS UNIQUE
					;R5=SHD,R6=DUPLICATE GSD ADR
	TSTL	R6			;IS THERE A DUPLICATE GSD?
	BEQL	135$			;BR IF THERE IS NOT A DUPLICATE
;
; NOW CHECK THAT THE DUPLICATE GLOBAL SECTION PASSES THE IDENT MATCH CONTROL
; TEST.  IF IT DOES NOT, THEN RETURN AN ERROR CODE TO THE USER.  IF IT DOES
; MATCH, THEN GO MAP THE DUPLICATE.
;
	TSTL	GSD$L_IDENT(R6)		;IS THIS ALWAYS MATCH?
	BEQL	141$			;BR TO USE SECTION IF ALWAYS MATCH
	CMPB	GSD$L_IDENT+3(R6),GSD$L_IDENT+3(R11) ;DOES MAJOR ID MATCH?
	BNEQ	133$			;BR ON NO, CAN'T USE DUP SECTION
	CMPL	GSD$L_IDENT(R6),GSD$L_IDENT(R11) ;COMPARE ENTIRE LONGWORD
	BGTRU	133$			;BR IF LARGER, NO MATCH, CAN'T USE DUP
	BLBC	GSD$L_IDENT(R6),141$	;BR IF EXACT MATCH NOT REQUIRED
	BEQL	141$			;BR IF AN EXACT MATCH, CAN USE DUP
133$:	MOVZWL	#SS$_IDMISMATCH,(SP)	;REPORT DUPLICATE GS NAME
	MOVZBL	#1,R0			;ONE REFCNT FOR LOCK
	JSB	G^MMG$DECSHMREF		;RELEASE LOCK ON DUP AS WON'T MAP TO IT
	BRB	143$			;RETURN TO USER WITHOUT MAPPING DUP
135$:	BRW	150$			;BR ASSIST FOR NO DUP GSD PATH
141$:	BBSSI	#GSD$V_DUPGSD,GSD$L_GSDFL(R11),142$ ;RECORD DUP GSD CREATED
142$:	MOVL	R0,(SP)			;REMEMBER ERROR CODE
143$:	MOVL	R6,GSD$L_GSDBL(R11)	;REMEMBER ADR OF DUP GSD TO MAP TO
	MOVL	R11,R6			;RESTORE ADR OF GSD BEING CREATED
;
; AT THIS POINT, THE GLOBAL SECTION MUST BE RELEASED.  EITHER THE GLOBAL
; SECTION COULD NOT BE INITIALIZED OR A DUPLICATE SECTION WAS FOUND.  IF A
; DUPLICATE SECTION WAS FOUND, THE NEW SECTION MUST BE DELETED AND THE OLD
; SECTION MAPPED, INSTEAD.  THEREFORE, BEFORE RETURNING A STATUS CODE TO THE
; USER, THE PAGES MUST BE UNMAPPED FROM HIS VIRTUAL  ADDRESS SPACE.  THIS IS
; DONE BY SETTING A TEMP DELETE FLAG, AND THEN RE-EXECUTING THE $MGBLSC LOGIC
; CALLING $DELPAG INSTEAD OF $CREPAG.  WHEN THE LAST REFERENCE (PTE) TO THE
; SECTION IS DELETED, THEN THE SHARED MEMORY PAGES ASSOCIATED WITH THE SECTION
; AND THE GSD MAY BE RELEASED.  IF THERE IS A DUPLICATE SECTION, THEN A $MGBLSC
; IS PERFORMED TO IT.
;
RELEAS_SHMGS:
	TSTL	4(SP)			;WAS ANYTHING MAPPED?
	BEQL	SHM_UNMAPPED		;BR ON NO, NOTHING TO UNMAP
	BBCS	#GSD$V_INITFAIL,GSD$L_GSDFL(R6),144$ ;SET TMP DEL INDIC
144$:	MOVZBL	#1,R0			;REF COUNT INCREMENT
					;R4=SHB ADDRESS
	JSB	G^MMG$INCSHMREF		;LOCK GSD SO IT CAN'T BE DELETED
145$:	PUSHL	R3			;LAST ENDING VA MAPPED
	PUSHL	8(SP)			;FIRST STARTING VA MAPPED
	BRW	MAPGBLSEC4		;REPEAT CODE, UNMAPPING THE VA SPACE
SHM_UNMAPPED:
	MOVL	MMG$GL_SYSPHD,R5	;GET ADR OF SYSTEM PROCESS HEADER
	CVTWL	GSD$W_GSTX(R6),R1	;GET SECTION TABLE ENTRY INDEX
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R0 ;COMPUTE ADR OF SECTION TBL ENTRY
	MOVAL	(R0)[R1],R10		;SO THAT IT CAN BE RELEASED
	CLRL	SEC$L_GSD(R10)		;INDICATE NO GSD CONNECTED TO IT
	ASSUME	SEC$L_PAGCNT EQ SEC$L_REFCNT+4
	CLRQ	SEC$L_REFCNT(R10)	;CLEAR REFCNT, SO IT WILL BE DELETED
	BBCC	#SEC$V_PERM,SEC$W_FLAGS(R10),151$ ;CLEAR THE PERMANENT FLAG
151$:	BBSSI	#PHD$V_DALCSTX,-	;LET SOMEONE IN PROPER
		PHD$W_FLAGS(R5),152$	;STATE DELETE IT (HOLDING GSD MUTEX)
152$:	MOVZBL	#SHD$V_BITMAPLCK,R0	;NUMBER OF BIT LOCK REQUESTED
	BSBW	MMG$SHMTXLK		;REQUEST MUTEX AND BIT LOCK
; **********
; AT SOME TIME THIS SHOULD SEND A MESSAGE TO THE ERROR LOGGER.
; **********
	BLBC	R0,146$			;UNABLE TO ACQUIRE BIT MAP LOCK
	MOVL	SHB$L_DATAPAGE(R4),R5	;GET ADR OF COMMON DATA PAGE
	BSBW	MMG$SET_BITMAP		;RELEASE ALL PAGES ALLOCATED FOR GS
	BSBW	MMG$SHMTXULK		;RELEASE SHM MUTEX
	BBCCI	#SHD$V_BITMAPLCK,SHD$B_FLAGS(R5),146$ ;RELEASE BIT LCK
146$:	BBCCI	#GSD$V_VALID,GSD$L_GSDFL(R6),147$ ;SET THE GSD NOT VALID
147$:	CLRL	R11			;ASSUME NO DUPLICATE GSD TO MAP TO
	BBCCI	#GSD$V_DUPGSD,GSD$L_GSDFL(R6),148$ ;BR IF NO DUP GSD TO MAP TO
	MOVL	GSD$L_GSDBL(R6),R11	;GET ADR OF DUPLICATE GSD
148$:	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R6),149$ ;UNLOCK THE GSD FOR REUSE
149$:	MOVZBL	SHB$B_PORT(R4),R1	;GET PORT # FOR THIS PROCESSOR
	ADAWI	#1,SHD$W_GSDQUOTA(R5)[R1] ;GIVE BACK SHM GSD QUOTA FOR PORT
	DECL	SHB$L_REFCNT(R4)	;ONE LESS SHM GSD OWNED BY THIS PORT
	MOVL	R11,R6			;SET ADR OF DUPLICATE GSD TO MAP TO
	BEQL	160$			;BR TO RETURN ERROR CODE
	BRB	145$			;BR TO MAP TO DUPLICATE GSD
150$:	BBCCI	#GSD$V_LOCKED,GSD$L_GSDFL(R11),160$ ;UNLOCK THE GSD FOR USE
160$:	BRW	88$			;ALL DONE, GO CLEAN UP
	.DSABL	LSB

	.SBTTL	SETSECPROTOWN - SET SECTION PROTECTION AND OWNER
;
; INPUTS:
;
;	R6  = GLOBAL SECTION DESCRIPTOR ADDRESS
;	R8  = PAGE TABLE ENTRY WITH SECTION INDEX, FLAGS, PAGE TYPE BITS
;	      OR PAGE TABLE ENTRY WITH PFN FOR PFNMAP-ING
;	R9  = SECTION FLAGS
;	R10 = SECTION TABLE ENTRY ADDRESS OR 0 IF GSD TYPE IS EXTENDED GSD
;	MMG$L_MAXACMODE(FP) = MAXIMIZED ACCESS MODE
;
; OUTPUTS:
;
;	R0 = SYSTEM STATUS CODE
;	R8 OWNER AND PROTECTION FIELDS FILLED IN
;
SETSECPROTOWN:
	.ENABL	LSB
	PUSHL	#SS$_NORMAL		;ASSUME NORMAL SUCCESS RETURN CODE
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,R9,R1 ;GET WRTMOD MAPPER SPECIFIED
	TSTL	R10			;IS THERE A SECTION TABLE ENTRY?
	BEQL	2$			;BR IF NO SECTION TABLE
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,- ;GET ACCESS MODE FROM SECTION
		SEC$W_FLAGS(R10),R0	;TABLE ENTRY, I.E., WHAT CREATOR SPEC
	BRB	4$			;JOIN COMMON CODE
2$:	TSTL	R6			;IS THERE A GLOBAL SECTION DESCRIPTOR?
	BEQL	10$			;BR ON LOCAL PFNMAP, CREATOR=MAPPER
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,- ;GET ACCESS MODE FROM GSD
		GSD$W_FLAGS(R6),R0	;I.E., WHAT CREATOR OF GS SPECIFIED
4$:	CMPL	R0,R1			;NOW MINIMIZE THE WRITE ACCESS
	BLEQ	5$			;BR IF MAPPER SPECIFIED MORE ACCESS
	MOVZWL	#SS$_IVLVEC,(SP)	;SET ALTERNATE RETURN SUCCESS CODE
	MOVL	R1,R0			;USE CREATOR'S ACCESS
5$:	EXTZV	#0,#2,B^MMG$L_MAXACMODE(FP),R1 ;GET READ ACCESS MODE
	CMPL	R0,R1			;IF WRTMOD > ACMOD, THEN USE ACMOD
	BLSS	15$			;TO PREVENT ILLEGAL ACCESS, E.G., ERUW
10$:	MOVL	R1,R0			;AND TO SET CORRECT OWNER FIELD
15$:	INSV	R0,#PTE$V_OWN,#PTE$S_OWN,R8 ;SET PAGE OWNER IN PTE
;
; CALCULATE PROTECTION FIELD
;
	BBC	#SEC$V_WRT,R9,NO_WRT_ACCESS ;BR IF NOT TRYING TO WRITE SECTION
	TSTL	R10			;IS THERE A SECTION TABLE ENTRY?
	BNEQ	20$			;YES, GO CHECK ITS FLAGS
	TSTL	R6			;IS THIS A GLOBAL SECTION?
	BEQL	30$			;NO, THEN MUST BE LOCAL PFNMAP
					;WITH NO GSD OR SECTION TBL ENTRY (ONLY
					;FLAGS ARE IN R9 AND ALREADY TESTED)
	BBC	#SEC$V_WRT,GSD$W_FLAGS(R6),100$ ;BRANCH IF ILLEGAL TO WRITE
	BRB	30$			;GO GET ACCESS MODE
20$:	BBC	#SEC$V_WRT,SEC$W_FLAGS(R10),100$ ;BRANCH IF ILLEGAL TO WRITE
30$:	MULL2	#3,R0			;SCALE WRITE ACCESS MODE BY THREE BITS
	EXTV	R0,#3,B^WRTMOD_TBL,R0	;GET PTE CODE FOR THIS WRITE MODE
	BGEQ	GET_READ_ACCESS		;BR IF NOT USER MODE WRITE
	MOVZBL	#PRT$C_UW,R0		;SET USER MODE WRITE, SPECIAL CASE
	BRB	SET_PTE_PROT		;GO SET PROTECTION FIELD OF PTE
WRTMOD_TBL:
	.WORD	^B100000001010		;3 BIT PTE CODES, INDEXED BY 3 * WRTMOD
NO_WRT_ACCESS:
	MOVZBL	#3,R0			;SET PTE CODE FOR READ ONLY ACCESS
GET_READ_ACCESS:
	INSV	R1,#2,#2,R0		;INSERT READ ACCESS BESIDE WRITE ACCESS
SET_PTE_PROT:
	INSV	R0,#PTE$V_PROT,#PTE$S_PROT,R8 ;PUT PROTECTION IN PTE
90$:	MOVL	(SP)+,R0		;SET RETURN STATUS CODE
	RSB
;
; TRIED TO MAP READ ONLY SECTION WRITABLE
;
100$:	MOVZWL	#SS$_NOPRIV,(SP)	;SET RETURN ERROR CODE, NO PRIVILEGE
	BRB	90$			;RETURN ERROR CODE
	.DSABL	LSB

	.SBTTL	INITSECTBL - ALLOC & INIT SECTION TABLE ENTRY
;
; INPUTS:
;
;	R5 = PROCESS HEADER ADDRESS
;	R6 = GLOBAL SECTION DESCRIPTOR ADDRESS IF GLOBAL SECTION
;	   = CHANNEL CONTROL BLOCK ADDRESS IF PROCESS SECTION
;	R7 = NUMBER OF PAGES TO BE MAPPED
;	R8 = CHANNEL CONTROL BLOCK ADDRESS
;	R9 = SECTION FLAGS
;
; OUTPUTS:
;
;	R0  = SYSTEM STATUS CODE
;	R1  = SECTION TABLE INDEX
;	R2,R3 ALTERED
;	R7  = SECTION PAGE COUNT
;	R10 = SECTION TABLE ADDRESS
;
;
; ***** NOTE THAT SECTION SIZE MUST BE SUCH THAT SECTION INDICES HAVE THE
; ***** LOW BIT ZERO.
;
	ASSUME	SEC$C_LENGTH@-2&1 EQ 0

	.ENABL	LSB
;
; GLOBAL SECTION BEING CREATED ON CHANNEL WITH PROCESS SECTION INDEX
; GET WINDOW ADDRESS
;
10$:	MOVL	@#CTL$GL_PHD,R0		;PROCESS HEADER ADDRESS
	ADDL	PHD$L_PSTBASOFF(R0),R0	;FORM BASE OF PROCESS SECTION TABLE
	MOVL	SEC$L_WINDOW(R0)[R2],R2	;GET WINDOW ADDRESS FROM PROCESS SECTION
	BRB	100$			;AND REJOIN THE NORMAL FLOW
;
; SPECIAL CASE CODE FOR NON-FCP WINDOW - I.E. ONE CREATED WITHOUT BENEFIT OF
; THE ACP - USUALLY DONE AT SYSTEM INITIALIZATION TIME. THE LOOP IS TO
; TAKE CARE OF POSSIBLY NON-CONTIGUOUS FILES.
;
40$:	PUSHL	R1			;NEED A SCRATCH REGISTER
	CLRL	-(SP)			;INITILIZE TOTAL VBN'S
	MOVZWL	WCB$W_NMAP(R2),R1	;PICK UP NUMBER OF MAPPING POINTERS
	MOVAB	WCB$W_P1_COUNT(R2),R2	;POINT AT FIRST ONE
45$:	MOVZWL	(R2),R0			;PICK UP THE NUMBER OF BLOCKS/POINTER
	ADDL2	R0,(SP)			;ADD TO TOTAL MAPPED
	ADDL2	#6,R2			;ADVANCE TO NEXT POINTER
	SOBGTR	R1,45$			;TAKE CARE OF THEM ALL
	MOVQ	(SP)+,R0		;RESTORE R1.  R0 = TOTAL VBNS IN FILE
	BRW	120$			;AND REJOIN THE MAIN PATH CODE
;
; CHANNEL IS ACTIVE OR OTHERWISE INAPPROPRIATE FOR CREATING A SECTION
;
50$:	MOVZWL	#SS$_NOTFILEDEV,-(SP)	;FILE NOT RND, FOD, OR DIR
	BRB	70$			;GO RELEASE SECTION TABLE ENTRY
60$:	MOVZWL	#SS$_IVCHNLSEC,-(SP)	;INVALID CHANNEL FOR SECTION
70$:	JSB	G^MMG$DALCSTX		;DEALLOCATE SECTION TABLE ENTRY
	POPR	#^M<R0>			;GET ERROR STATUS
80$:	RSB

81$:	BRW	230$
82$:	BRB	10$

INITSECTBL:
	BSBW	MMG$ALCSTX		;ALLOCATE SECTION TABLE INDEX
	BLBC	R0,80$			;BRANCH IF NONE AVAILABLE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R3 ;BASE ADDRESS OF SECTION TABLE
	MOVAL	(R3)[R1],R10		;ADDRESS OF SECTION TABLE ENTRY
	MOVL	R6,(R10)		;CCB ADDRESS OR GSD ADDRESS
	MOVW	R9,SEC$W_FLAGS(R10)	;SET FLAGS
	TSTL	R8
	BEQL	81$			;NO CHANNEL - SKIP ALL THIS STUFF
	TSTW	CCB$W_IOC(R8)		;IF ANY OUTSTANDING I/O ON CHANNEL
	BNEQ	60$			;THEN IT CANNOT BE USED
	MOVL	CCB$L_UCB(R8),R0	;GET UCB FOR DEVICE CHARACTERISTICS
	BICL3	UCB$L_DEVCHAR(R0), -	;CHECK THAT DEVICE HAS DIRECTORIES,
		#<DEV$M_DIR!DEV$M_FOD!DEV$M_RND>,R0 ;FILES, AND IS RANDOM-ACCESS
	BNEQ	50$			;BRANCH IF ANY CHARACTERISTIC IS MISSING
	MOVL	CCB$L_WIND(R8),R2	;WINDOW ADDRESS FROM CHANNEL
	BEQL	60$			;BRANCH IF NO FILE IS OPEN
	BLBS	R2,60$			;CAN'T USE CHAN IF ACCESS/DEACCESS PENDING
	BLSS	100$			;BRANCH IF WINDOW ADDRESS
	CVTWL	R2,R2			;FORM PROCESS SECTION INDEX
	BLBS	R9,82$			;BRANCH IF CREATING A GLOBAL SECTION
	MOVL	SEC$L_WINDOW(R3)[R2],R2	;FETCH WINDOW FROM PROCESS SECTION
100$:	MOVL	R2,SEC$L_WINDOW(R10)	;SET WINDOW ADDRESS IN SECTION TABLE
	BBS	#WCB$V_WRITE,WCB$B_ACCESS(R2),105$ ;BR IF FILE WRITE ACCESSED
	BBC	#SEC$V_WRT,R9,110$	;BRANCH IF NOT MAPPING FOR WRITE
	BBS	#SEC$V_CRF,R9,110$	;WRITE AND CRF IS OK FOR READ ONLY FILE
	MOVZWL	#SS$_NOWRT,-(SP)	;ERROR, CANNOT CREATE WRITABLE SECTION
	BRB	70$			;TO A READ ONLY FILE, RETURN TO USER

	ASSUME	SEC$V_WRT LE 7
105$:	BISB	#SEC$M_WRT,SEC$W_FLAGS(R10) ;NOTE SECTION WRITABLE
110$:	MOVL	WCB$L_FCB(R2),R0	;FCB ADDRESS FROM WINDOW
	BNEQ	112$			;GOT A REAL ONE
	BRW	40$			;BRANCH IF NONE THERE
112$:	BBSS	#WCB$V_NOTRUNC,WCB$W_ACON(R2),115$ ;DISALLOW TRUNCATE ON THE FILE
	INCW	FCB$W_TCNT(R0)		;COUNT TRUNCATE LOCKS
115$:	MOVL	B^MMG$L_EFBLK(FP),R0	;LAST VIRTUAL BLOCK THAT MAY BE MAPPED
120$:	SUBL3	#1,VBN(AP),R2		;DESIRED STARTING VBN - 1
	BGEQ	130$			;IF WAS SPECIFIED AS 0
	CLRL	R2			;THEN MAKE IT VBN 1
130$:	ADDL3	#1,R2,SEC$L_VBN(R10)	;SET STARTING VBN IN SECTION TABLE
	TSTL	R7			;NUMBER OF PAGES IN SECTION
					;STARTING AT SPECIFIED VBN
	BGTR	140$			;BRANCH IF NOT DEFAULTED TO "ENTIRE FILE"
	MOVL	R0,R7			;USE ENTIRE FILE
140$:	ADDL3	R7,R2,-(SP)		;FORM HIGHEST VBN TO BE MAPPED
	CMPL	R0,(SP)+		;TRYING TO MAP BEYOND EOF?
	BGTR	150$			;BRANCH IF NOT
	SUBL3	R2,R0,R7		;FORM NEW PAGCNT = MAXVBN - (STARTVBN - 1)
	BLEQ	290$			;BRANCH IF NOTHING TO MAP, EOF
150$:	MOVL	R7,SEC$L_PAGCNT(R10)	;SET SECTION SIZE
	BLBC	R9,170$			;BRANCH IF PROCESS SECTION
;
; GLOBAL SECTION - ONCE THE WINDOW IS MADE SHARED, DALCSTX CANNOT BE
; USED TO DELETE THE SECTION TABLE ENTRY.  DALCSTXSCN MUST BE USED
; BECAUSE IT RELEASES THE WINDOW.
;
	MOVL	SEC$L_WINDOW(R10),R0	;WINDOW ADDRESS
	BBSS	#WCB$V_SHRWCB,WCB$B_ACCESS(R0),160$ ;MAKE INTO SHARED WINDOW
					;BRANCH IF ALREADY A SHARED WINDOW
	BSBW	MMG$RET_BYT_QUOTA	;RESTORE BYTCNT QUOTA TO FILE OWNER
160$:	INCW	WCB$W_REFCNT(R0)	;ANOTHER REFERENCE FOR SECTION ENTRY
	BRB	180$
;
; PROCESS SECTION
;
170$:	MOVL	CCB$L_WIND(R8),R0	;GET WINDOW OR SECTION FROM CHANNEL
	BGTR	190$			;BRANCH IF SECTION INDEX
	MOVZWL	R1,CCB$L_WIND(R8)	;1ST PROCESS SECTION ON CHANNEL
					;STORE SECTION INDEX IN CCB
180$:	MOVL	R10,R0			;SECTION TABLE ENTRY ADDRESS
	BRB	200$			;INIT FORWARD AND BACKWARD SECTION INDICES
;
; SUBSEQUENT SECTION (NOT THE FIRST) ON THIS CHANNEL
;
190$:	CVTWL	R0,R0			;INSERT AFTER THIS SECTION
	MOVW	R0,SEC$W_SECXBL(R10)	;CURSEC(BL) = BAKSECX
	MOVAL	(R3)[R0],R0		;ADR OF BACKWARD SECTION TABLE ENTRY
	MOVW	SEC$W_SECXFL(R0),SEC$W_SECXFL(R10) ;CURSEC(FL) = BAKSEC(FL)
200$:	MOVW	R1,SEC$W_SECXFL(R0)	;BAKSEC(FL) = CURSECX
	CVTWL	SEC$W_SECXFL(R10),R0	;FORWARD SECTION INDEX (FORSECX)
	MOVAL	(R3)[R0],R0		;FORWARD SECTION TABLE ENTRY ADDRESS
	MOVW	R1,SEC$W_SECXBL(R0)	;FORSEC(BL) = CURSECX
	MOVL	#1,SEC$L_REFCNT(R10)	;NO REFERENCES YET
	CVTBL	PFC(AP),R0		;GET PAGE FAULT CLUSTER
	BGEQ	210$			;BRANCH IF NOT TOO BIG
	MOVZBL	#127,R0			;IT WAS TOO BIG, SET TO MAX

	ASSUME	SEC$B_PFC EQ SEC$L_VPXPFC+3
210$:	ASHL	#24,R0,SEC$L_VPXPFC(R10) ;SET PFC, ZERO VIRTUAL PAGE INDEX
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION
	RSB
;
; PAGE FILE BACKING STORE
;
230$:	BISB	#SEC$M_WRT,SEC$W_FLAGS(R10) ;NOTE SECTION WRITABLE
	MOVL	R7,SEC$L_PAGCNT(R10)	;SET SECTION SIZE
	CLRL	SEC$L_WINDOW(R10)	;NO WINDOW - PAGE FILE BACKING STORE
	BRB	180$
;
; ATTEMPT TO CREATE A SECTION BEYOND END OF FILE
;
290$:	MOVZWL	#SS$_ENDOFFILE,-(SP)	;SET RETURN STATUS
	BRW	70$			;CLEAN UP AND EXIT

	.DSABL	LSB

	.SBTTL	MAP PROCESS SECTION
;
; CALLING SEQUENCE:
;
;	BRW	MAP_PROCESS_SECTION
;
; INPUTS:
;
;	R4 = PCB ADDRESS
;	R8 = CHANNEL CONTROL BLOCK ADDRESS, IF PFNMAP FLAG IS CLEAR
;	R9 = SECTION FLAGS
;	0(SP) = STARTVA
;	4(SP) = ENDVA
;	8(SP) = SUCCESS CODE FOR MAP SECTION
;	PFN(AP) = FIRST PFN TO MAP TO, IF PFNMAP FLAG IS SET
;
MAP_PROCESS_SEC:
	SETIPL	#IPL$_ASTDEL		;NO AST'S WHILE MANIPULATING HEADER
	CLRL	R11			;INDICATE NO GSD ADR
	MOVL	@#CTL$GL_PHD,R5		;PROCESS HEADER ADDRESS
	BBC	#SEC$V_PFNMAP,R9,1$	;IS PFNMAPPING REQUESTED?
	BBS	#PRV$V_PFNMAP,PHD$Q_PRIVMSK(R5),1$ ;BR ON HAVE PRIV
	MOVZWL	#SS$_NOPRIV,R0		;NO PRIVILEGE FOR REQUESTED OPERATION
	BRW	90$			;RETURN ERROR CODE TO CALLER
1$:	BSBW	MMG$DALCSTXSCN		;SCAN FOR SECTIONS TO DEALLOCATE
	MOVL	R8,R6			;CCB ADDRESS

	MOVL	SECPAGCNT(AP),R7	;GET # OF PAGES IN SECTION
	PUSHL	R9			;REMEMBER FLAGS
	ASSUME	<SEC$M_CRF!SEC$M_DZRO> EQ 6
	CMPZV	#1,#2,R9,#<<SEC$M_CRF!SEC$M_DZRO>@-1> ;IF CRF+DZRO, THEN DONT
	BEQL	8$			;CREATE SECTION TABLE ENTRY JUST PTES
	BBS	#SEC$V_PFNMAP,R9,10$	;DON'T CREATE SECTION PTE FOR PFNMAP-ING
	ASSUME	<<SEC$M_DZRO!SEC$M_CRF!SEC$M_WRT>&^XFFFFFF00> EQ 0
	MOVZBL	R9,R9			;ELIM GBL FLAGS, PFNMAP, & EXPREG
	BSBW	INITSECTBL		;ALLOCATE AND INIT A SECTION TABLE ENTRY
	BLBS	R0,5$			;BR IF SECTION TABLE ENTRY CREATED
	BRW	90$			;BR IF NONE AVAILABLE OR ERROR
;
; R1  = SECTION TABLE INDEX
; R7  = SECTION PAGE COUNT
; R10 = SECTION TABLE ENTRY ADDRESS
;

	ASSUME	SEC$V_WRT EQ SEC$V_DZRO+1
	ASSUME	SEC$V_DZRO EQ SEC$V_CRF+1
5$:	EXTZV	#SEC$V_CRF,#3,SEC$W_FLAGS(R10),R8 ;GET CRF, DZRO, WRT BITS
	BISW	#<PTE$M_TYP1 ! PTE$M_TYP0>@-16,R8 ;OR IN TYPE BITS
	ROTL	#16,R8,R8		;PUT IN HIGH 16 BITS
	MOVW	R1,R8			;SET SECTION INDEX
	BRB	15$			;SKIP PFNMAP-ING PTE CREATION
8$:	CLRL	R8			;USE DEMAND-ZERO PTE FORMAT
	BRB	12$			;CONTINUE MAPPING SECTION
10$:	MOVL	PFN(AP),R8		;GET STARTING PFN FOR SECTION
	BISL	#^X<PTE$M_VALID ! PTE$M_WINDOW>,R8 ;SET VALID AND WINDOW BITS
12$:	CLRL	R10			;INDICATE NO SECTION TABLE ENTRY
	CLRL	R6			;NO GSD ADDRESS
15$:	BSBW	SETSECPROTOWN		;SET SECTION PROTECTION AND OWNER
	BLBC	R0,20$			;BRANCH IF BAD PROTECTION CODE
	CMPL	#SS$_NORMAL,R0		;WAS ALTERNATE SUCCESS CODE RETURNED?
	BEQL	16$			;BR IF NORMAL CODE RETURNED
	MOVL	R0,12(SP)		;SAVE ALTERNATE CODE TO RETURN TO CALLER
16$:	POPL	R0			;GET FLAGS BACK
	POPR	#^M<R2,R3>		;R2=STARTVA, R3=ENDVA
	BBC	#SEC$V_EXPREG,R0,19$	;BR IF RANGE IS EXPLICITLY STATED
;
; FIND THE FIRST AVAILABLE VIRTUAL ADDRESS AND COMPUTE THE RANGE TO BE MAPPED.
;
	ASHL	#9,R7,R1		;CONVERT PAGE COUNT TO # OF
	DECL	R1			;BYTES BETWEEN START VA AND END VA
	MOVL	@#CTL$GL_PHD,R0		;GET PROCESS HEADER FOR PROCESS
	BBC	#VA$V_P1,R2,17$		;BR IF MAPPING INTO P0 SPACE
	ADDL3	#^X1FF,PHD$L_FREP1VA(R0),R3 ;ENDING VA IN P1 SPACE
	SUBL3	R1,R3,R2		;STARTING VA IN P1 SPACE
	BRB	19$			;JOIN COMMON CODE
17$:	MOVL	PHD$L_FREP0VA(R0),R2	;STARTING VA IN P0 SPACE
	ADDL3	R1,R2,R3		;ENDING VA IN P0 SPACE
19$:	SUBL3	#1,R7,R9		;SECTION PAGE COUNT BASE 0
	MOVAL	W^MMG$MAPSECPAG,R6	;MAP SECTION PAGE ROUTINE
	BSBW	MMG$CRECOM2		;CREATE THE PAGES
	BLBS	R0,30$			;IF SUCCESSFUL, USE SUCCESS CODE AT 0(SP)
20$:	MOVL	R0,(SP)			;OTHERWISE SAVE ERROR CODE
30$:	TSTL	R10			;IS THERE A SECTION TABLE ENTRY?
	BEQL	85$			;BR ON NO SECTION TABLE ENTRY
	SUBL3	#1,SEC$L_REFCNT(R10),SEC$L_PAGCNT(R10) ;SET ACTUAL PAGE COUNT
	BEQL	80$			;BRANCH IF NO PAGES MAPPED
;
; AT LEAST ONE PAGE WAS MAPPED.
; R1, R2 CONTAIN THE RETURN RANGE VALUES
;
	BLBC	R1,40$			;BRANCH IF R1 IS THE LOWEST ADDRESS
	MOVL	R2,R1			;R2 WAS THE LOWEST
40$:	EXTV	#VA$V_VPN,#VA$S_VPN+1,R1,R0 ;GET VIRTUAL PAGE INDEX
	BGEQ	50$			;BRANCH IF NOT P1 SPACE
	ROTL	#7,SGN$GL_PTPAGCNT,R1	;OFFSET IN LONG WORD FROM BEGIN OF PAGE TABLE
	ADDL	R1,R0			;CORRECT P1 SPACE INDEX
50$:	BISL	R0,SEC$L_VPXPFC(R10)	;SET VIRTUAL PAGE INDEX, PRESERVE PFC
80$:	CVTWL	R8,R1			;SECTION TABLE INDEX
	JSB	G^MMG$DECSECREF		;COUNT ONE LESS SECTION REFERENCE
85$:	POPR	#^M<R0>			;GET THE RETURN STATUS CODE
90$:	RET				;AND RETURN TO CALLER

	.SBTTL	MAPSECPAG - MAP A SINGLE PROCESS/GLOBAL SECTION PAGE

;++
; FUNCTIONAL DESCRIPTION:
;	MAPSECPAG MAPS A SINGLE PAGE OF A GLOBAL SECTION AT THE
; SPECIFIED VITUAL ADDRESS.  AS IN CREPAG, THE PAGE TABLE IS EXTENDED
; IF NECESSARY (WHICH COULD FAIL IF THE VIRTUAL ADDRESS SPACE IS FULL),
; AND THE PAGE TABLE ENTRY IS DELETED IF NECESSARY AND THEN SET TO
; SPECIFIED VALUE.
;
;	THIS ROUTINE IS ALSO USED TO UNMAP THE PAGES OF SHARED MEMORY GLOBAL
; SECTION WHICH FOR SOME REASON COULD NOT BE INITIALIZED.  THE BIT,
; GSD$V_INITFAIL, INDICATES THAT THE RANGE OF VIRTUAL ADDRESS SPACE IS TO
; BE DELETED INSTEAD OF CREATED.  THIS SERVICE WILL ONLY BE NEEDED FOR SHARED
; MEMORY GLOBAL SECTIONS SINCE ONLY THIS TYPE OF SECTION IS INITIALIZED BEFORE
; THE $CRMPSC STATUS CODE CAN BE RETURNED TO THE USER.  THE NEW CONTENTS OF
; THE PAGE TABLE ENTRY (R8) IS NOT USED WHEN DELETING VIRTUAL ADDRESS SPACE.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$MAPSECPAG
;
; INPUT PARAMETERS:
;
;	R0 = MODE FOR CREATING NEW PAGE
;	R2 = VIRTUAL ADDRESS OF PAGE TO CREATE
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS - P1 OR SYSTEM SPACE
;	R6 = COUNT-1 OF PAGES TO BE MAPPED ACCORDING TO THE INPUT RANGE
;	R7 = +^X200 IF MAPPING FORWARDS IN THE VIRTUAL ADDRESS SPACE
;	   = -^X200 IF MAPPING BACKWARDS IN THE VIRTUAL ADDRESS SPACE
;	R8 = NEW CONTENTS OF PAGE TABLE ENTRY
;	R9 = COUNT-1 OF PAGES LEFT IN THE SECTION THAT COULD BE MAPPED
;	R10 = GLOBAL SECTION TABLE ENTRY ADDRESS OR 0 IF NONE APPLIES
;	R11 = GLOBAL SECTION DESCRIPTOR ADDRSS OR 0 IF NONE APPLIES
;
;	THE CURRENT IPL MUST BE AT ASTDEL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = ERROR STATUS CODE
;	R2 PRESERVED
;	R1,R3-R7,R9 DESTROYED
;
; IMPLICIT OUTPUTS:
;
;	PTE CORRESPONDING TO SPECIFIED VIRTUAL ADDRESS IS DELETED AND
;	THE DESIRED PTE IS STORED
;
;	IF PAGE TABLE EXPANSION IS NECESSARY THEN THE FOLLOWING 
;	ARE AFFECTED:
;
;	PHD$L_FREP0VA OR PHD$L_FREP1VA	;1ST FREE PAGE AT END OF P0/P1 PAGE TABLE
;	PHD$L_P0LRASTL OR PHD$L_P1LR	;LENGTH OF PT IN HARDWARE PCB
;	PR$_P0LR OR PR$_P1LR		;LENGTH OF PT IN PROCESSOR REG
;	PHD$L_FREPTECNT			;FREE PTE COUNTER
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_NOPRIV			;NO PRIVILEGE TO CREATE/DELETE PAGE
;	SS$_VASFULL			;VIRTUAL ADDRESS SPACE FULL
;
; SIDE EFFECTS:
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC
;
; **********************************************************************
;
MMG$MAPSECPAG:
	CMPL	R6,R9			;MORE PAGES THAN IN THE SECTION?
	BLEQ	10$			;BRANCH IF NOT
	MOVL	R9,R6			;YES, USE SECTION SIZE
10$:	MOVAL	B^20$,B^MMG$L_PAGESUBR(FP) ;SKIP INIT CODE FOR SUBSEQUENT PAGES
	ASHL	#-9,R7,R9		;+1 OR -1 DEPENDING ON DIRECTION
	TSTL	R11			;IS THIS A GLOBAL SECTION MAPPING?
	BEQL	18$			;NO, THEN BR AS THIS IS PROCESS SECTION
	CMPB	GSD$B_TYPE(R11),#DYN$C_SHMGSD ;IS THIS A SHARED MEMORY GSD?
	BNEQ	20$			;BR IF NOT A SHARED MEMORY GSD
	BBC	#GSD$V_INITFAIL,GSD$L_GSDFL(R11),20$ ;BR IF NOT UNMAPPING VA
	MOVAL	B^15$,B^MMG$L_PAGESUBR(FP) ;SKIP INIT CODE FOR SUBSEQUENT PAGES
15$:	JSB	G^MMG$DELPAG		;UNMAP A PAGE OF VA SPACE
	BRB	22$			;SKIP CREATING A NEW PAGE
18$:	BBS	#PTE$V_WINDOW,R8,20$	;BR IF PFNMAP, NEED TO INC PFN IN PTE
	CLRL	R9			;NO INC FOR NORMAL PROCESS SEC PTE'S
20$:	BSBW	MMG$CREPAG		;CREATE AND STORE THE PAGE TABLE ENTRY
22$:	BLBC	R0,30$			;BRANCH IF ERROR
	TSTL	R10			;CHECK IF NO SECTION TABLE ENTRY
	BEQL	25$			;BR ON NONE
	INCL	SEC$L_REFCNT(R10)	;COUNT USES OF THIS GLOBAL SECTION
25$:	ADDL	R9,R8			;NEXT PTE; (DELPAG DOESN'T USE R8)
	BBC	#PTE$V_WINDOW,R8,30$	;BR IF NOT PFNMAP, NO NEED TO LOCK
	INCL	PHD$L_MPINHIBIT(R5)	;LOCK PROCESS ONTO PRIMARY PROCESSOR
30$:	RSB



	.SBTTL	CHECK_WINDOW	INSURE FULLY MAPPED FILE

;+
; Functional Description:
;
;	This routine checks that a file is completely mapped (that the
;	mapping pointers for the file are permanently resident) and that
;	the file will remain completely mapped while the section exists.
;
;	There is an assumption at work here that the ACP can tolerate the
;	CATHEDRAL bit being turned on while it is working on extending
;	the file.
;
; Calling Sequence:
;
;	BSBW	CHECK_WINDOW
;
; Input Parameters:
;
;	R6		Channel on which file is open
;	FP		Address of $CRMPSC impure area
;
; Implicit Input:
;
;	None
;
; Output Parameters:
;
;	R2		Channel index
;	R8		Address of Channel Control Block
;	MMG$L_EFBLK(FP)	Largest block in file that can be mapped
;
; Implicit Output:
;
;	WCB$V_COMPLETE and WCB$V_CATHEDRAL bits are set in WCB$B_ACCESS.
;
; Completion Codes:
;
;	SS$_NORMAL			; Successful completion
;	SS$_EXBYTLM			; ACP remap operation failed
;	Error codes returned from IOC$VERIFYCHAN
;-

;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	YF$$SYSCRMPSC

	.ENABLE		LOCAL_BLOCK

BEGIN_LOCKED_CODE:

CHECK_WINDOW:
	MOVL	R6,R0			; Input parameter to VERIFYCHAN
	BSBW	IOC$VERIFYCHAN		; Verify it and return CCB address

; R1	Address of channel control block
; R2	Index into channel table

	PUSHR	#^M<R2,R3,R4,R5>	; Save some registers
	BLBC	R0,25$			; Branch if bad channel parameter
	MOVL	R1,R8			; Channel control block address
10$:	MOVL	CCB$L_UCB(R8),R0	; Get UCB for device characteristics
	BICL3	UCB$L_DEVCHAR(R0), -	; Check that device ...
		#<DEV$M_DIR!-		;  has directories,
		  DEV$M_FOD!-		;  is file oriented,
		  DEV$M_RND>,R0		;  and is random access
	BNEQ	30$			; Error if any characteristic is missing
	BICL3	#1,CCB$L_WIND(R8),R2	; Get window address, clearing low bit
	BEQL	35$			; Error if no file open on channel
	BLSS	15$			; Branch if R2 contains window address
	CVTWL	R2,R2			; Sign extend PSTX
	MOVL	@#CTL$GL_PHD,R0		; Get process header address
	ADDL2	PHD$L_PSTBASOFF(R0),R0	; Point R0 to base of section table
	MOVL	SEC$L_WINDOW(R0)[R2],R2	; Get window address from PSTE
	BGEQ	35$			; Error unless system address
15$:	SETIPL	W^LOCK_IPL		; Lock code and synchronize
	BBC	#WCB$V_COMPLETE,WCB$B_ACCESS(R2),40$	; Step out of line 
					;  if file is not completely mapped
	MOVL	WCB$L_FCB(R2),R3	; Get FCB address
	BEQL	20$			; All done if not FCP window

; Note that the previous branch relies on the fact that all non-FCP windows
; have already had the CATHEDRAL bit set. In addition, there is special
; code in routine INITSECTBL that takes care of file size for non-FCP
; files so that MMG$L_EFBLK does not have to be loaded. (In fact, the
; common exit code loads MMG$L_EFBLK with 0.)

	MOVL	FCB$L_EFBLK(R3),R3	; Save end-of-file block
	BBSS	#WCB$V_CATHEDRAL,WCB$B_ACCESS(R2),20$	; Set CATHEDRAL bit
20$:	SETIPL	#0			; Allow page faults to occur
	MOVL	R3,MMG$L_EFBLK(FP)	; Store end-of-file block
	MOVZWL	#SS$_NORMAL,R0		; Indicate success
25$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				;  and return

30$:	MOVZWL	#SS$_NOTFILEDEV,R0	; Device is not file structured
	BRB	25$			; Restore registers and return

35$:	MOVZWL	#SS$_IVCHNLSEC,R0	; Return "invalid channel" error
	BRB	25$			; Restore registers and return

; Call ACP with REMAP control function to insure that all mapping pointers for
; this file are permanently resident.

40$:	SETIPL	#0			; Lower IPL to call system services
	SUBL2	#FIB$K_LENGTH,SP	; Allocate space for FIB on stack
	MOVC5	#0,(SP),#0,#FIB$K_LENGTH,(SP)	; Fill FIB with zeros
	MOVW	#FIB$C_REMAP,FIB$W_CNTRLFUNC(SP); Set ACP control function
	PUSHAL	(SP)			; Make FIB descriptor (address
	PUSHL	#FIB$K_LENGTH		;   and length)
	MOVL	SP,R5			; Save FIB address for $QIO call
	MOVAQ	-(SP),R4		; Allocate space for IOSB
	$QIOW_S	EFN=#26,-
		CHAN=R6,-
		FUNC=#IO$_ACPCONTROL,-
		IOSB=(R4),-
		P1=(R5)
	BLBS	R0,50$			; Check completion status if successful
45$:	ADDL2	#<FIB$K_LENGTH+8+8>,SP	; Reset stack
	BRB	25$			; Signal an error if $QIO failed

50$:	MOVZWL	(R4),R0			; Real status resides in IOSB
	BEQL	60$			; If zero, then I/O not really done
					; Event flag was set spuriously
					; Branch out of line to wait for I/O
55$:	BLBC	R0,45$			; Signal an error if ACP REMAP failed
	ADDL2	#<FIB$K_LENGTH+8+8>,SP	; Reset stack
	BRW	10$			;  and perform the checks again

LOCK_IPL:
	.LONG	IPL$_SYNCH		; Synchronization IPL

END_LOCKED_CODE:

; The following test insures that the code that is dynamically locked
; does not span more than two consecutive pages.

	ASSUME	<END_LOCKED_CODE-BEGIN_LOCKED_CODE> LE 512

60$:	$CLREF_S	EFN=#26		; Clear the event flag and wait again
	MOVZWL	(R4),R0			; Did I/O complete while in SYS$CLREF?
	BNEQ	55$			; Simply return if it did
	$WAITFR_S	EFN=#26		; Otherwise, wait for event flag again
	BRB	50$			;  and see whether this setting of the
					;  event flag is for real

	.DISABLE	LOCAL_BLOCK

	.PAGE
	.SUBTITLE	MMG$RET_BYT_QUOTA		RETURN BYTCNT QUOTA 
;+
;	Return BYTCNT Quota to Owner of File
;
; Functional Description:
;
;	When a window is converted to a shared WCB as part of global
;	section creation, the BYTCNT quota that was charged against
;	the process that opened the file must be returned.
;
; Input Parameter:
;
;	R0	Address of primary WCB
;
; Implicit Input:
;
;	JIB of process that opened file
;
; Output Parameters:
;
;	None
;
; Implicit Output:
;
;	JIB$L_BYTCNT is updated to account for the entire chain of WCBs.
;
;	Each WCB in a chain of WCBs has the following fields changed
;
;		WCB$L_PID is cleared
;		WCB$W_REFCNT is set to 1
;		WCB$V_SHRWCB in WCB$B_ACCESS is set
;-

MMG$RET_BYT_QUOTA::
	PUSHR	#^M<R0,R1,R2,R3>	; Get some registers to work with
5$:	DSBINT	30$			; Synchronize access to data
	MOVZWL	WCB$L_PID(R0),R1	; Get process index
	MOVL	@SCH$GL_PCBVEC[R1],R1	; Convert to PCB address
	CMPL	PCB$L_PID(R1),WCB$L_PID(R0)	; Make a consistency check
	BNEQ	20$			; Return if PIDs do not match
	MOVL	PCB$L_JIB(R1),R1	; Finally, store JIB address
	CLRL	R3			; Initialize sum

10$:	MOVZWL	WCB$W_SIZE(R0),R2	; Extract size of next WCB
	ADDL2	R2,R3			; Include in sum
	CLRL	WCB$L_PID(R0)		; Zap PID to eliminate link to process
	MOVW	#1,WCB$W_REFCNT(R0)	; Initialize REFCNT for one access
	BISB	#WCB$M_SHRWCB,WCB$B_ACCESS(R0)	; Set SHRWCB bit
	MOVL	WCB$L_LINK(R0),R0	; Get next WCB in chain
	BNEQ	10$			; Loop back if next WCB exists

	ADDL2	R3,JIB$L_BYTCNT(R1)	; Restore BYTCNT quota
20$:	ENBINT				; Allow rescheduling to occur
	POPR	#^M<R0,R1,R2,R3>	; Restore registers
	RSB				;  and return

30$:	.LONG	IPL$_SYNCH		; Synchronization IPL

	ASSUME	<.-5$> LE 512		; Can only lock 512 bytes this way

	.END
