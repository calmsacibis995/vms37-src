	.TITLE	SYSIMGSTA - Image Startup System Service
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility:	EXECUTIVE
;
; Abstract:
;	This code is part of the System image.  It is entered directly
;	as the 'DEBUG' transfer address, even when the real DEBUG
;	will not be invoked, since it is this 'bootstrap' which
;	decides whether to 
;		1) simply start up the user image directly,
;		2) map the bulk of DEBUG into the users' P0 space
;		   and transfers control to DEBUG,
;		3) catch an SS$_DEBUG signal and arrange to have
;		   a mapped DEBUGger attached to a running process,
;		or
;		4) catch any other signal, report it, and try to
;		   invoke the mapped image which prints a 'traceback' or
;		   symbolic dump of where the program was when it faulted.
;
; Environment:
;	Runs at user mode, non-AST level in the System address space.
;
; Author:	Carol Peters, Creation date: 21 July 1977
;
; Modified by:
;
;	V02-007	LJK0103		Lawrence J. Kenah	16-Dec-1981
;		Add comment about assumption made by DEBUG and TRACEBACK.
;
;	V02-006	LJK0062		Lawrence J. Kenah	29-Sep-1981
;		Add call to $IMGFIX service after merged activation so
;		that activation-time relocation can occur.
;
;	V02-005	LJK0064		Lawrence J. Kenah	10-Sep-1981
;		Remove call to Purge Working Set to allow date pages
;		faulted in as a result of address relocation fixups 
;		to remain in the working set.
;
;
;--

	.SBTTL	DECLARATIONS

;
; Include files:
;
	$CLIDEF				; Command interpreter flags
	$FABDEF				; file access block definitions
	$IACDEF				; Image activation control flags
	$IHDDEF				; image header definitions
	$NAMDEF				; name block definitions
	$PHDDEF				; process header block definitions
	$SECDEF				; process/global section definitions
	$SSDEF				; system service status definitions
	$STSDEF				; status code definitions

	$IMGACTDEF			; Image activator argument definitions
;
; Macros:
;
;
; Equated symbols:
;
	IMGHDRBLKCNT=1			; Number of image header blocks  on
					; the front of the DEBUG/TRACE images
	MAXTRNNAM=64			; Maximum # of bytes in translation of
					; LIB$DEBUG or LIB$TRACE
;
; Offsets into the vector at the front of the DEBUG and TRACE images
;
	$OFFSET	0,POSITIVE,<-
		DEBUG_WRT_PAGES,-
		DEBUG_WRT_ENDPG,-
		DEBUG_START_ADR -
		>

;
; Offsets from R6 used by the mapin logic
;
	$OFFSET	0,POSITIVE,<-
		<,<<IMGACT$_NARGS+1>*4>>,- ; Argument list for $IMGACT call
		<IMGACT_INADR,8>,-	; Input address range to map image at
		<IMGACT_RETADR,8>,-	; Ret adr range where image was mapped
		<NAMDSC,8>,-		; Descriptor for untranslated file name
		<DFLTNAMDSC,8>,-	; Descriptor for default file string
		<TRNNAMDSC,8>,-		; Descriptor for translated file spec
		<TRNNAMESTRING,MAXTRNNAM>,- ; Buffer for translated file spec
		<HDRBUF,512>,-		; Image header buffer for $IMGACT
		<SCRATCHSIZE,0>,-	; size of area address off of FP
		>
;
; An 'arg' vector is passed to TRACE using the following
; locations thru SECT_BOUNDS.  FAULT_PC must remain the first
; of these locations (we use it to address the vector), and
; the order of these variables must not change.
; The storage for this vector and any additional own data is allocated
; off the end of the call frame generated by the call to BOOT_START.
; The FP needed to address this own data is found at exception time
; as the "establisher frame" in the "mechanism array."
;
	$OFFSET	0,POSITIVE,<-
		FAULT_PC,-		; Pass the PC on to TRACE.EXE
		FAULT_FP,-		; Pass to TRACE the FP when the fault occurred.
		<PROG_START,0>,-	; Program start address
		FIRST_FP,-		; What FP was when user image was invoked initially.
		SIGNAL_ARRAY,-		; Address of signal array.
		<SECT_BOUNDS,8>,-	; Beginning of TRACE's symbol table,
-;
-; end of TRACE's 'arg' vector.
-; beginning of TRACE's additional own data
-;
-; Additional own storage variables are to be added here
-;
		SAVED_AP,-		; Saved AP that image was invoked with
		MAP_SEC_XADDR,-		; Where to JMP to invoke TRACE, 0 if not mapped
		<TRACE_CTX_SIZ,0>,-	; Size of own storage reserved at end of frame
		>

	.SBTTL	DEBUG_BOOT	- DEBUG/TRACEBACK/IMAGE ACTIVATOR

;++
; Functional description:
;	This 'bootstrap' invokes one of DEBUG, TRACEback, or the
;	users' image, depending on flags passed on by/from LINK
;	and CLI.  In all cases, we set up the argument list, etc, 
;	in such a way that the image being invoked does not know
;	that DBGBOOT was there.  If DEBUG or TRACE is selected,
;	this routine finds out where the user program's P0 space ends.
;	It then maps the DEBUG/TRACE global section into the space following
;	the user's P0 space, marks the DEBUG/TRACE impure storage area
;	as "copy on reference", and transfers control to the initialization
;	code in the DEBUG/TRACE global section.
;
; Calling sequence:
;	CALLS	#6, EXE$IMGSTA
;
; Input parameters:
;	4(AP)	- transfer vector address
;	8(AP)	- address of CLI parse information (not used)
;	12(AP)	- address of image header information
;	16(AP)	- address of image file information
;	20(AP)	- LINK status bits
;	24(AP)	- CLI status bits
;
; Implicit inputs:
;	We may use one of two image files, DEBUG.EXE or TRACE.EXE, both
;	located in the logical device SYS$LIBRARY.
;
; Output parameters:
;	R0	- system status code.
;		  = SS$_RESIGNAL if error code from $CRMPSC or $MGBLSC
;		    or anything else in this driver module fails
;		  = SS$_NORMAL or other DBG$_... returns from the rest
;		    of DEBUG in the other case.
;
; Implicit outputs:
;	The stack frame created when this BOOT is called (by CLI)
;	remains around to contain the frame handler we need to
;	catch programs which fault when there is no DEBUG 
;	around.
;
; Completion codes:
;	SS$_NORMAL - successfully mapped in DEBUG/TRACE
;	SS$_RESIGNAL - unable to map in DEBUG/TRACE
;
; Side effects:
;	Lets user run DEBUG, his image directly, or TRACEback.
;--

	.PSECT	YF$$SYSIMGSTA BYTE,EXE

	.LIST	MEB

	.SBTTL	Start the Program or DEBUG

	.ENTRY	EXE$IMGSTA,0

	ASSUME	TRACE_CTX_SIZ-4 EQ MAP_SEC_XADDR
	CLRL	-(SP)			; no mapped section transfer address
	SUBL	#TRACE_CTX_SIZ-4,SP	; reserve traceback own storage
	MOVL	AP,SAVED_AP(SP)		; Save AP that program is called with
	MOVL	4(AP),R0		; Address of transfer vector
	MOVL	4(R0),PROG_START(SP)	; Save program start address and avoid
					; referencing the transfer vector after purge
	BBS	S^#CLI$V_DEBUG,24(AP),-	; See if command-line override given
		CLI_OVERRIDE
	BBS	S^#IHD$V_LNKDEBUG,20(AP),- ; No override - check for $LINK/DEBUG
		DEBUG_MAPIN
CLI_OVERRIDE:
	BBS	S^#CLI$V_DBGTRU,24(AP),- ; Check for $RUN/DEBUG
		DEBUG_MAPIN
; DEBUG will not come up - either because "$RUN program" was given along with
; $LINK program (i.e. no $LINK/DEBUG or $RUN/DEBUG), or because "$RUN/NODEBUG"
; as given.
;

BE_SILENT:
					; Set up a frame handler to look
					; after invoking traceback if the
					; 'standalone' image faults if
					; the user types ^Y DEBUG to attach
					; DEBUG to an already-running image.
	MOVAL	B^BOOT_HANDLER,(FP)
	ADDL	#4,4(AP)		; Adjust transfer vector to ignore
					; the fact that DEBUG is around
	CALLG 	(AP),@PROG_START(SP)	; and invoke the user program directly.
	RET

	.SBTTL	Exception Handler for TRACE

;
;  Control is passed to DEBUG or TRACEBACK with a JMP instruction. The
;  register save mask at BOOT_HANDLER thus serves as the register save
;  mask for these procedures. Both DEBUG and TRACEBACK assume that all
;  registers have been saved. 
;

BOOT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; save mask
	MOVQ	4(AP),R0		; Pick up pointer to signal arg list.
					; R1 = address of mechanism array
	SUBL3	#TRACE_CTX_SIZ,4(R1),R8 ; Address of own storage
;
; The debugger is started up if the exception name is SS$_DEBUG.
; Traceback happens if error level is WARNING, SEVERE, or ERROR.
; Otherwise we let DCL's frame handler decide 
; what to do with this exception.
;
	CMPL	4(R0),#SS$_DEBUG	; if DEBUG exception,
	BEQL	DO_DEBUG		; then start up the debugger
	EXTZV	#STS$V_SEVERITY+32,#STS$S_SEVERITY,(R0),R2
					; Check for exact match to the
					;  severity levels which cause TRACE
	CMPB	#STS$K_WARNING,R2
	BEQL	DO_TRACE
	CMPB	#STS$K_ERROR,R2
	BEQL	DO_TRACE
	CMPB	#STS$K_SEVERE,R2
	BEQL	DO_TRACE
	MOVZWL	#SS$_RESIGNAL,R0	;  This signal is not for us.
	RET
;
; Start up the debugger as a result of a DEBUG exception.
;
DO_DEBUG:
	MOVL	AP,R2			; save condition handler AP
	MOVL	SAVED_AP(R8),AP		; AP when image was first invoked
	MOVL	R2,4(AP)		; replace start vector address with
					; condition handler AP
	BBSS	#CLI$V_DBGEXCP,24(AP),10$ ; DEBUG exception triggerred
					; the starting of the debugger
10$:
;
; Map the debugger in and transfer control to it
;
DEBUG_MAPIN:
	MOVAB	B^DEBUGNAME,R7		; Address of debugger name string
	BSBB	MAPIN			; Map it in
	JMP	(R1)			; and transfer control to it
;
; Start up TRACE
;
DO_TRACE:
;
; Build a vector of args to TRACEback and pass on a pointer to this vector
; in the same way as DEBUG usually gets a pointer to the transfer vector.
;
	MOVL	R0,SIGNAL_ARRAY(R8)	; Put signal arg ptr into traceback vector.
	MOVL	4(R1),FIRST_FP(R8)	; Put first FP into traceback vector.
	MOVL	12(FP),FAULT_FP(R8)	; FP at time of the exception
	MOVZBL	(R0),AP			; Signal argument count
	MOVL	-(R0)[AP],FAULT_PC(R8)	; Put the fault PC in the vector
	MOVL	SAVED_AP(R8),AP		; AP when image was first invoked
	MOVL	R8,4(AP)		; Pass address of traceback vector
					; in place of the transfer vector
	MOVL	MAP_SEC_XADDR(R8),R1	; Is TRACE already mapped in?
	BNEQ	10$			; Branch if it is
	CLRQ	SECT_BOUNDS(R8)		; Init section bounds for TRACE
	MOVAB	B^TRACENAME,R7		; Mapping in TRACE
	BSBB	MAPIN			; Go map the image in
	MOVL	R1,MAP_SEC_XADDR(R8)	; Save its transfer address
10$:	JMP	(R1)			; and transfer control to TRACE/DEBUG

	.SBTTL	Map in and Start DEBUG or TRACE
;
; DEBUG and TRACE name strings
;
TRACENAME:
	.ASCII	/LIB$TRACE/		; Logical name to translate into file
					; spec and file name prefixed by LIB$
	LNAMESIZ=.-TRACENAME

DEBUGNAME:
	.ASCII	/LIB$DEBUG/		; Logical name to translate into file
					; spec and file name prefixed by LIB$
	ASSUME	LNAMESIZ EQ .-DEBUGNAME

DEFAULTNAMDSC:
	.ASCID	/SYS$LIBRARY:.EXE/	; RMS default name string for $IMGACT

FACNAMDES:				; str dsc for facility name for err msgs
	.ASCID	/DEBUGBOOT/
;
; Map DEBUG or TRACE in as a shared GLOBAL section or as a process section.
;
; CALLING SEQUENCE:
;
;	BSBW	MAPIN
;
; INPUTS:
;
;	R7    = Address of name string for DEBUG or TRACE
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL or SS$_RESIGNAL
;	R1 = Transfer address for entering the desired program
;	R2,R3,R4,R5,R6 SCRATCH
;
;	If any error occurs, this routine exits via RET with status in R0
;
MAPIN:
	MOVAL	-SCRATCHSIZE(SP),SP	; reserve scratch storage on the stack
	MOVL	SP,R6			; R6 = base of scratch area
	MOVC5	#0,(SP),#0,#SCRATCHSIZE,(SP) ; zero the scratch storage
	MOVL	G^CTL$GL_PHD,R0		; address of process header window
;
; Initialize the argument list for $IMGACT merge request system service call.
;
	MOVL	#IMGACT$_NARGS,(R6)	; Set argument count for $IMGACT call
	MOVAB	NAMDSC(R6),IMGACT$_NAME(R6) ; Set adr of input file name desc
	MOVAB	DEFAULTNAMDSC,IMGACT$_DFLNAM(R6) ; Set adr of default name str
	MOVL	#<IAC$M_MERGE ! IAC$M_EXPREG>,IMGACT$_IMGCTL(R6) ; Set ctl flags
	MOVAB	HDRBUF(R6),IMGACT$_HDRBUF(R6) ; Set adr of image header buffer
	MOVAB	IMGACT_INADR(R6),IMGACT$_INADR(R6) ; Set adr of input va range
	MOVAB	IMGACT_RETADR(R6),IMGACT$_RETADR(R6) ; Set adr of return range
	CLRL	IMGACT$_IDENT(R6)	; No match ident specified
	MOVZWL	#^X200,IMGACT_INADR(R6) ; Set a blueprint P0 address range for
	MOVL	#1@30-1,IMGACT_INADR+4(R6) ; mapping to first free va space
	MOVZBL	#LNAMESIZ,NAMDSC(R6)	; Init size of name to translate
	MOVL	R7,NAMDSC+4(R6)		; Init adr of nam to translate
	MOVZBL	#MAXTRNNAM,TRNNAMDSC(R6) ; Set size of translated name buffer
	MOVAB	TRNNAMESTRING(R6),TRNNAMDSC+4(R6) ; Set adr of tran name buffer
;
; Now do a logical name translation of LIB$DEBUG/LIB$TRACE to get the file
; specification to pass to $IMGACT.  If there is no translation, then strip
; the LIB$ off the name and pass that.
;
	$TRNLOG_S -			; Translate to get file spec
		LOGNAM=NAMDSC(R6),-	; Name string to be translated
		RSLLEN=TRNNAMDSC(R6),-	; Resultant size of translated string
		RSLBUF=TRNNAMDSC(R6)	; Adr of translated string buffer desc
	CMPL	#SS$_NORMAL,R0		; Successful translation?
	BNEQ	40$			; Branch if not successful
	MOVQ	TRNNAMDSC(R6),NAMDSC(R6) ; Pass translated string to $IMGACT
	BRB	60$			; Go call image activator
40$:	CMPW	#SS$_NOTRAN,R0		; Was there no logical translation?
	BNEQ	ERROR_RET		; No, there was an error, ret w/status
	SUBL2	#4,NAMDSC(R6)		; Strip the LIB$ off the file name that
	ADDL2	#4,NAMDSC+4(R6)		; is passed to the image activator
60$:	$IMGACT_G	(R6)		; Let image activator map in the image
	BLBC	R0,ERROR_RET		; Branch on error to return w/ status
	$IMGFIX_S			; Do address relocation fixups
	BLBC	R0,ERROR_RET		; Branch on error to return w/ status

;+
; A vector in the DEBUG global section contains the start of impure
; storage, the end of impure storage, and the transfer address of DEBUG
; itself.  This vector is in PSECT DBG$ABS_ZERO, and is always the first
; thing in DEBUG.EXE. Since DEBUG.EXE is linked with a base of zero, the
; vector is the first thing in the global section.
;
;
; The third address in the vector is DEBUG's transfer address.
; Add the DEBUG transfer address to the base address of the
; first mapped page and jump to it.
;-
TRANS_CONTROL:
	MOVL	IMGACT_RETADR(R6),R1	; Get mapped address of section
	ADDL3	DEBUG_START_ADR(R1),R1,R1 ; compute DEBUG start address
	MOVAL	SCRATCHSIZE(R6),SP	; remove scratch storage from stack
	RSB				; return transfer address to caller

ERROR_RET:
	BICL3	#STS$M_SEVERITY,R0,-(SP) ; Reduce error code severity to warning
	MOVW	#15,-(SP)		; Print all pieces of err msg
	MOVW	#1,-(SP)		; Set the number of parameters
	MOVL	SP,R0			; Save adr of argument list
	$PUTMSG_S (R0),,FACNAMDES	; Report error to user
	MOVZWL	#SS$_RESIGNAL,R0	; Resignal the error
	RET				; Return with error status

	.END
