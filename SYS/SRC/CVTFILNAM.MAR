	.TITLE	CVTFILNAM - Converts ASCII to RAD50
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	Used by BOOT58 and FILEREAD
;
; ABSTRACT:
;
;	Converts an ASCII string file name, type, and version number
;	to a 6-word RAD50 file name and type, and a 16-bit binary
;	version number.
;
; ENVIRONMENT:
;
;	any
;
; AUTHOR:
;
;	Carol Peters	22 March 1979
;		Extracted from the Release 1 module FILEREAD.MAR; all
;		code and definitions are unchanged from Release 1 form.
;
; MODIFIED BY:
;
;--

	.SBTTL	DECLARATIONS

;
; Include files
;

	$SSDEF				; Status code definitions

;
; Equated symbols
;

	LCA	=	^O141		;LOWER CASE A
	LCZ	=	^O172		;LOWER CASE Z
	UCA	=	^O101		;UPPER CASE A
	UCZ	=	^O132		;UPPER CASE Z
	ZERO	=	^O60		;ASCII ZERO
	NINE	=	^O71		;ASCII NINE
	DOT	=	^O56		;ASCII PERIOD
	SEMI	=	^O73		;ASCII SEMICOLON

;
; PSECT declaration
;

	.PSECT	YFILEREAD,BYTE,EXE

	.SBTTL	CVTFILNAM - CONVERT FILE NAME FROM ASCII TO RAD50

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS THE ASCII FILE NAME (NAME, TYPE, VERSION)
; TO THE FILE NAME BLOCK FORM OF 3 WORDS RAD50 NAME, 1 WORD OF TYPE
; AND 1 WORD OF VERSION.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$CVTFILNAM
;
; INPUT PARAMETERS:
;
;	FILNAM(AP)	=		;STRING DESCRIPTOR OF FILE NAME STRING
;	FILNAMBLK(AP)	=		;ADDRESS OF 5 WORD BLOCK
;						3 WORD RAD50 FILE NAME
;						1 WORD RAD50 FILE TYPE
;						1 WORD BINARY VERSION
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;	FILNAME BLOCK FILLED IN
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			SUCCESSFUL COMPLETION
;	SS$_BADFILENAME			SYNTAX ERROR IN FILE NAME
;
; SIDE EFFECTS:
;
;	NONE
;
; EQUATED SYMBOLS:
;
;    OFFSETS FROM AP
;
	FILNAM		=	4	;DESCRIPTOR OF ASCII FILE NAME STRING
	FILNAMBLK	=	8	;ADDRESS OF 5 WORD FILE NAME BLOCK
;
;    OFFSETS FROM FP
;
	TYPE		=	-3	;BEGINNING OF TYPE FIELD
	NAME		=	-12	;BEGINNING OF NAME FIELD
;
;--

FIL$CVTFILNAM::
	.WORD	^M<R2,R3,R4,R5,R6>
	CLRQ	-(SP)			;RESERVE AND ZERO A
	CLRL	-(SP)			;12 BYTE NAME STRING
	MOVQ	@FILNAM(AP),R5		;R5 = SIZE, R6 = ADR OF STRING
	MOVAB	NAME(FP),R4		;ADDRESS TO STORE NAME
	MOVL	#9,R3			;UP TO 9 CHARACTERS
	BRB	40$
;
; STORE UP TO 9 CHARACTERS OF RAD50 IN THE BYTE ARRAY ADDRESSED BY R4
; IN PREPARATION FOR CONVERTING INTO THE PACKED RAD50 FORMAT
;
20$:
	MOVB	(R6)+,R0		;GET THE NEXT CHARACTER
	CMPB	#DOT,R0			;IS IT A DOT?
	BEQL	FILETYPE		;BRANCH IF YES
	CMPB	#SEMI,R0		;IS IT A SEMICOLON
	BEQL	VERSION			;BRANCH IF YES
	BSBB	STORER50BYTE		;CONVERT AND STORE THE CHARACTER
40$:
	SOBGEQ	R5,20$			;COUNT THE CHARACTERS IN THE STRING
	BRB	BUILDFNB		;END OF STRING, NO TYPE, NO VERSION
;
; NOW SET UP THE 3 BYTE ARRAY OF FILE TYPE
;
FILETYPE:
	MOVAB	TYPE(FP),R4		;ADDRESS OF BYTE ARRAY
	MOVL	#3,R3			;MAX SIZE OF FILE TYPE
	BRB	40$
20$:
	MOVB	(R6)+,R0		;GET NEXT CHARACTER
	CMPB	#SEMI,R0		;IS IT A SEMICOLON?
	BEQL	VERSION			;BRANCH IF YES
	CMPB	#DOT,R0			;DOT FOR VERSION TOO
	BEQL	VERSION			;BRANCH IF VERSION DELIMITER
	BSBB	STORER50BYTE		;CONVERT AND STORE THE BYTE
40$:
	SOBGEQ	R5,20$			;LOOP THROUGH THE CHARACTERS
	BRB	BUILDFNB		;END OF STRING, NO VERSION
;
; VERSION DELIMITER FOUND, CONVERT THE VERSION
;
VERSION:
	ADDL3	#4*2,FILNAMBLK(AP),-(SP) ;ADDRESS TO STORE VERSION
	MOVQ	R5,-(SP)		;PUSH ADDRESS, PUSH SIZE OF VERSION STRING
	CALLS	#3,LIB$CVT_DTB		;CONVERT DECIMAL VERSION STRING TO BINARY
	BLBC	R0,BADFILNAM		;BRANCH IF BAD FILE NAME
;
; NOW PACK THE TEMPORARY BYTE STRING INTO THE RAD50 WORDS
;
BUILDFNB:
	MOVL	FILNAMBLK(AP),R4	;ADDRESS TO STORE PACKED RAD50
	MOVAB	NAME(FP),R3		;ADDRESS OF NAME STRING
	TSTB	(R3)			;ANY NAME GIVEN?
	BEQL	20$			;BRANCH IF NO
	BSBB	PACKRAD50		;1ST 3 CHARACTERS
	BSBB	PACKRAD50		;2ND 3 CHARACTERS
	BSBB	PACKRAD50		;3RD 3 CHARACTERS
20$:
	ADDL3	#3*2,FILNAMBLK(AP),R4	;ADDRESS TO STORE FILE TYPE
	MOVAB	TYPE(FP),R3		;ADDRESS OF TYPE STRING
	TSTB	(R3)			;ANY FILE TYPE PRESENT?
	BEQL	40$			;BRANCH IF NOT
	BSBB	PACKRAD50		;CONVERT 3 CHARACTERS
40$:
	MOVZWL	#SS$_NORMAL,R0		;INDICATE SUCCESS
	RET

	.SBTTL	STORER50BYTE - CONVERT AND STORE ASCII BYTE TO RAD50
;++
; FUNCTIONAL DESCRIPTION:
;
;	CONVERT ASCII BYTE TO RAD50 AND STORE IN THE SPECIFIED BYTE ARRAY
;
; CALLING SEQUENCE:
;
;	BSBB	STORER50BYTE
;
; INPUT:
;
;	R0 = ASCII BYTE
;	R3 = SIZE OF BYTE ARRAY TO STORE IN
;	R4 = ADDRESS OF BYTE ARRAY TO STORE IN
;
; OUTPUT:
;
;	RSB IF SUCCESSFUL, RET WITH ERROR CODE IN R0 IF ERROR
;	R3, R4 UPDATED TO REFLECT THE ADDITIONAL BYTE STORED
;
;--

	.ENABL	LSB

STORER50BYTE:
	BSBB	ASCIITORAD50		;CONVERT TO RAD50
	SOBGEQ	R3,20$			;BRANCH IF ROOM TO STORE THIS CHARACTER
BADFILNAM:
	MOVZWL	#SS$_BADFILENAME,R0	;RETURN ERROR CODE
	RET
20$:
	MOVB	R0,(R4)+		;STORE IT
	RSB				;AND RSB SUCCESSFULLY

	.DSABL	LSB

	.SBTTL	PACKRAD50 - PACK 3 BYTES OF RAD50 CHARACTERS INTO A WORD
;++
; FUNCTIONAL DESCRIPTION:
;
;	PACK 3 BYTES OF RAD50 CHARACTERS INTO A WORD
;
; CALLING SEQUENCE:
;
;	BSBB	PACKRAD50
;
; INPUTS:
;
;	R3 = RAD50 BYTE STRING ADDRESS
;	R4 = ADDRESS OF WORD ARRAY TO STORE IN
;
; OUTPUTS:
;
;	R3 UPDATED TO POINT TO NEXT GROUP OF 3 CHARACTERS
;	R4 UPDATED TO POINT AT NEXT WORD TO STORE IN
;
;--

PACKRAD50:
	MOVZBL	(R3)+,R0		;BUILD PACKED WORD IN R0
	MULW	#40*40,R0		;START ACCUMULUATING IN R0
	MOVZBL	(R3)+,R1		;SECOND CHARACTER TO TEMP
	MULW	#40,R1			;MULTIPLY BY THE RADIX
	ADDW	R1,R0			;AND ACCUMULATE
	MOVZBL	(R3)+,R1		;LAST CHARACTER
	ADDW3	R1,R0,(R4)+		;ACCUMULATE AND STORE RESULT
	RSB

	.SBTTL	ASCIITORAD50 - CONVERT ASCII CHARACTER TO RAD50
;++
; FUNCTIONAL DESCRIPTION:
;
;	CONVERT ASCII CHARACTER TO ITS RAD50 EQUIVALENT
;
; CALLING SEQUENCE:
;
;	BSBB	ASCIITORAD50
;
; INPUTS:
;
;	R0 = CHARACTER TO CONVERT
;
; OUTPUTS:
;
;	RSB IF SUCCESSFUL, RET WITH ERROR CODE IN R0 IF ERROR
;	R0 = RAD50 EQUIVALENT
;	R1,R2,R3 PRESERVED
;
;--

ASCIITORAD50:
	CMPB	R0,#LCZ			;LOWER CASE ALPHA?
	BGTRU	BADFILNAM		;BRANCH IF BAD RAD50
	CMPB	R0,#LCA
	BLSS	10$			;BRANCH IF NOT
	SUBB	#LCA-1,R0		;CONVERT TO ALPHA
	RSB				;AND RETURN SUCCESSFULLY
10$:
	CMPB	R0,#UCZ			;UPPER CASE ALPHA?
	BGTR	BADFILNAM		;BRANCH IF BAD RAD50
	CMPB	R0,#UCA
	BLSS	20$			;BRANCH IF NOT ALPHA
	SUBB	#UCA-1,R0		;CONVERT TO RAD50 ALPHA
	RSB				;AND RETURN SUCCESSFULLY
20$:
	CMPB	R0,#NINE		;NUMERIC?
	BGTR	BADFILNAM		;BRANCH IF BAD RAD50
	CMPB	R0,#ZERO
	BLSS	BADFILNAM		;BRANCH IF BAD RAD50
	SUBB	#ZERO-30,R0		;CONVERT TO RAD50 NUMERIC
	RSB				;AND RETURN SUCCESSFULLY

	.END
