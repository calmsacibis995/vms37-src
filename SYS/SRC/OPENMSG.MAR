	.TITLE OPENMSG - OPEN MESSAGE FILES FOR SYSTEM OUTPUT AND ERROR
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 9-JAN-78
;
; MODIFIED BY:
;
;	V02-004	LMK0001		Len Kawell		03-Sep-1981
;		Change PSECT name to re-order system image.
;
;	V02-003	ACG0200		Andrew C. Goldstein,	10-Mar-1981  15:59
;		$SETPRV changed to read new mask before writing old
;
;	V02-002	ACG0194		Andrew C. Goldstein,	27-Feb-1981  17:04
;		Remove enhanced privileges while opening message output
;
;	V001	TMH0001		Tim Halvorsen	24-Feb-1981
;		Add routine to close the files
;
;**
;
; OPEN MESSAGE FILES FOR SYSTEM OUTPUT AND ERROR
;
; MACRO LIBRARY CALLS
;
 
	$FABDEF				;DEFINE FAB OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
 
;
; LOCAL SYMBOLS
;
 
BUFSIZ=256				;MAXIMUM RECORD SIZE
ESCAPE=1@8+27				;ESCAPE EQUIVALENCE NAME PREFIX
 
;
; LOCAL DATA
;
 
	.PSECT	YEXEPAGED2,BYTE
ERRNAM:	.ASCIC	/SYS$ERROR/		;'SYS$ERROR' FILE NAME STRING
FILTYP:	.ASCIC	/.LOG/			;DEFAULT FILE NAME STRING
ISINAM:	.ASCIC	/SYS$PUTMSG/		;'SYS$PUTMSG' FILE NAME STRING
OUTNAM:	.ASCIC	/SYS$OUTPUT/		;'SYS$OUTPUT' FILE NAME STRING

	.SBTTL	OPEN MESSAGE FILES FOR SYSTEM OUTPUT AND ERROR
;+
; EXE$OPEN_MSG - OPEN FILES FOR SYSTEM OUTPUT AND ERROR
;
; THIS ROUTINE IS CALLED TO OPEN FILES FOR SYSTEM OUTPUT AND ERROR.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	RAB'S ARE ALLOCATED ON THE STACK FOR THE FILES 'SYS$OUTPUT' AND 
;	'SYS$ERROR', AND THE FILE ISI/IFI VALUES ARE OBTAINED EITHER BY ACTUALLY
;	OPENING THE RESPECTIVE FILES OR BY LOGICAL NAME TRANSLATION.
;
;	R10 = ADDRESS OF ALLOCATED 'SYS$OUTPUT' RAB.
;	R11 = ADDRESS OF ALLOCATED 'SYS$ERROR' RAB.
;-
 
EXE$OPEN_MSG::				;OPEN MESSAGE FILES FOR SYSTEM OUTPUT AND ERROR
;
; ALLOCATE 2 RABS FOR SYS$OUTPUT AND SYS$ERROR ON THE CALLER'S STACK
;
	POPL	R0			;SAVE RETURN ADDRESS
	MOVAB	-RAB$C_BLN(SP),R10	;ALLOCATE SPACE FOR 'SYS$OUTPUT' RAB
	MOVAB	-2*RAB$C_BLN(SP),R11	;ALLOCATE SPACE FOR 'SYS$ERROR' RAB
	MOVL	R11,SP			;SET NEW STACK ADDRESS
	PUSHL	R0			;RESTORE RETURN ADDRESS
;
; ALLOCATE AND INITIALIZE A FAB FOR OPENING THE FILES
;
	MOVAB	-FAB$C_BLN(SP),SP	;ALLOCATE SPACE FOR FAB
	MOVL	SP,R9			;SAVE ADDRESS OF FAB
	MOVC5	#0,(R9),#0,#FAB$C_BLN,(R9) ;CLEAR FAB
	MOVB	#FAB$C_BLN,FAB$B_BLN(R9) ;SET LENGTH OF FAB
	MOVB	#FAB$C_BID,FAB$B_BID(R9) ;SET IDENTIFICATION OF FAB
	MOVB	FILTYP,FAB$B_DNS(R9)	;SET DEFAULT NAME STRING SIZE
	MOVAB	FILTYP+1,FAB$L_DNA(R9)	;SET DEFAULT NAME STRING ADDRESS
	MOVW	#BUFSIZ,FAB$W_MRS(R9)	;SET MAXIMUM RECORD SIZE
	MOVB	#FAB$M_PUT,FAB$B_FAC(R9) ;SET FILE ACCESS MODE
	ASSUME	FAB$M_SQO LE 255
	MOVL	#FAB$M_CIF!FAB$M_SQO,FAB$L_FOP(R9) ;SET FILE OPEN OPTIONS
	MOVB	#FAB$M_CR,FAB$B_RAT(R9)	;SET ATTRIBUTES
;
; INITIALIZE BOTH RABS
;
	MOVC5	#0,(R10),#0,#RAB$C_BLN,(R10) ;CLEAR OUTPUT FILE RAB
	MOVB	#RAB$C_BID,RAB$B_BID(R10) ;SET RAB BLOCK IDENTIFICATION
	MOVB	#RAB$C_BLN,RAB$B_BLN(R10) ;SET RAB BLOCK LENGTH
	MOVL	R9,RAB$L_FAB(R10)	;SET ADDRESS OF FAB
	ASSUME	RAB$V_EOF EQ 8
	MOVB	#RAB$M_EOF@-8,RAB$L_ROP+1(R10) ;APPEND TO END OF FILE
	MOVC	#RAB$C_BLN,(R10),(R11)	;DUPLICATE OUTPUT FILE RAB
	ASSUME	RAB$V_CCO EQ 31
	MOVB	#RAB$M_CCO@-24,RAB$L_ROP+3(R11) ;SET CANCEL CONTROL O
;
; TRANSLATE THE LOGICAL NAME SYS$PUTMSG TO SEE IF THE FILE IS ALREADY
; OPENED VIA A PREVIOUS CALL.  IF THE LOGICAL NAME EXISTS, ITS TRANSLATION
; CONSISTS OF THE ISI'S FOR THE OUTPUT AND ERROR RABS, SO RE-ESTABLISH
; THE EXISTING STREAM AND BYPASS THE OPENS.
;
	PUSHAB	ISINAM+1		;BUILD ISI NAME STRING DESCRIPTOR
	MOVZBL	ISINAM,-(SP)		;
	MOVL	SP,R8			;SAVE ADDRESS OF ISI NAME STRING DESCRIPTOR
	SUBL	#12,SP			;ALLOCATE SPACE FOR EQUIVALENCE NAME
	MOVL	SP,R7			;SAVE ADDRESS OF EQUIVALENCE NAME
	PUSHL	SP			;BUILD EQUIVALENCE NAME DESCRIPTOR
	PUSHL	#10			;
	MOVL	SP,R6			;SAVE ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S LOGNAM=(R8),-		;TRANSLATE LOGICAL NAME
		RSLBUF=(R6)
	CMPW	S^#SS$_NORMAL,R0	;NORMAL COMPLETION?
	BNEQ	10$			;IF NEQ NO
	CMPW	#ESCAPE,(R7)		;SPECIAL ESCAPE EQUIVALENCE NAME?
	BEQL	40$			;IF EQL YES
 
;
; CREATE FILES FOR SYS$OUTPUT AND SYS$ERROR AND SAVE RESULTANT ISI VALUES
;
 
10$:	MOVAB	ERRNAM,R0		;GET ADDRESS OF 'SYS$ERROR' NAME STRING
	BSBB	CREATE_FILE		;CREATE 'SYS$ERROR' FILE
	MOVL	R4,R5			;SAVE 'SYS$ERROR' IFI
	MOVAB	OUTNAM,R0		;GET ADDRESS OF 'SYS$OUTPUT' NAME STRING
	BSBB	CREATE_FILE		;CREATE 'SYS$OUTPUT' FILE
	MOVL	R5,R2			;SET 'SYS$ERROR' IFI
	MOVL	R11,R3			;SET 'SYS$ERROR' RAB
	BSBB	CONNECT_RAB		;CONNECT RECORD STREAM
	CMPW	R4,R5			;'SYS$OUTPUT' AND 'SYS$ERROR' IFI'S MATCH?
	BEQL	20$			;IF EQL YES
 
;
; 'SYS$ERROR' AND 'SYS$OUTPUT' ARE NOT THE SAME FILE
;
 
	MOVL	R4,R2			;SET 'SYS$OUTPUT' IFI
	MOVL	R10,R3			;SET 'SYS$OUTPUT' RAB
	BSBB	CONNECT_RAB		;CONNECT RECORD STREAM
	BRB	30$			;
 
;
; 'SYS$ERROR' AND 'SYS$OUTPUT' ARE SAME FILE
;
 
20$:	MOVW	RAB$W_ISI(R11),RAB$W_ISI(R10) ;COPY ISI NUMBER
 
;
; CREATE LOGICAL NAME "SYS$PUTMSG" EQUIVALENCED TO ERROR AND OUTPUT ISI NUMBERS
;
 
30$:	MOVW	#ESCAPE,(R7)		;INSERT SPECIAL ESCAPE PREFIX
	MOVW	RAB$W_ISI(R10),2(R7)	;INSERT 'SYS$OUTPUT' ISI NUMBER
	MOVW	RAB$W_ISI(R11),4(R7)	;INSERT 'SYS$ERROR' ISI NUMBER
	MOVW	R4,6(R7)		;INSERT 'SYS$OUTPUT' IFI NUMBER
	MOVW	R5,8(R7)		;INSERT 'SYS$ERROR' IFI NUMBER
	$CRELOG_S LOGNAM=(R8),-		;CREATE LOGICAL NAME
		EQLNAM=(R6),-
		TBLFLG=#LOG$C_PROCESS

;
; INSERT ISI NUMBERS IN RABS AND RETRIEVE ERROR/OUTPUT EQUIVALENCE INDICATOR
;
 
40$:	MOVW	2(R7),RAB$W_ISI(R10)	;INSERT 'SYS$OUTPUT' ISI NUMBER
	MOVW	4(R7),RAB$W_ISI(R11)	;INSERT 'SYS$ERROR' ISI NUMBER
	MOVAB	FAB$C_BLN+8+12+8(SP),SP	;REMOVE ALLOCATED SPACE FROM STACK
	RSB				;

	.SBTTL	INTERNAL SUBROUTINES
;
; CONNECT_RAB - CONNECT RECORD STREAM
;
; THIS ROUTINE IS CALLED TO CONNECT A RECORD STREAM TO A RAB.
;
; INPUTS:
;
;	R2 = FILE IFI NUMBER.
;	R3 = ADDRESS OF RAB.
;
; OUTPUTS:
;
;	THE SPECIFIED RAB IS CONNECTED AND IMPLIED CARRIAGE CONTROL IS INSERTED
;	IN THE RESULTANT ISI NUMBER.
;
;	NOTE ALL ERRORS ARE IGNORED.
;
 
CONNECT_RAB:				;CONNECT RAB
	MOVW	R2,FAB$W_IFI(R9)	;INSERT IFI NUMBER
	$CONNECT RAB=(R3)		;CONNECT RECORD STREAM
	RSB				;

 
;
; CREATE_FILE
;
; THIS ROUTINE IS CALLED TO CREATE A FILE AND RETURN THE RESULTANT IFI.
;
; NOTE THAT WHATEVER AMPLIFIED PRIVILEGES THE IMAGE MAY HAVE ARE TEMPORARILY
; REMOVED BY THIS ROUTINE DURING ITS EXECUTION. THIS IS TO PREVENT A USER
; FROM WRITING BOGUS FILES BY REDEFINING SYS$OUTPUT OR SYS$ERROR.
;
; INPUTS:
;
;	R0 = ADDRESS OF FILE NAME COUNTED STRING.
;
; OUTPUTS:
;
;	R4 = RESULTANT FILE IFI NUMBER.
;
;	NOTE ALL ERRORS ARE IGNORED.
;
 
CREATE_FILE:				;CREATE FILE
	MOVB	(R0)+,FAB$B_FNS(R9)	;INSERT FILENAME STRING SIZE
	MOVAB	(R0),FAB$L_FNA(R9)	;INSERT FILE NAME ADDRESS

	PUSHR	#^M<R0,R1,R2>		;SAVE R2 AND ALLOCATE PRIVILEGE MASK BUFFER
	MOVL	SP,R2			;POINT TO PRIVILEGE MASK BUFFER
	$SETPRV_S PRMFLG=#1,PRVPRV=(R2)	;READ PROCESS CURRENT PRIVILEGES
	MCOML	(R2),(R2)		;GENERATE COMPLEMENT
	MCOML	4(R2),4(R2)		;OF PRIVILEGE MASK
	$SETPRV_S PRMFLG=#0,ENBFLG=#0,PRVADR=(R2),PRVPRV=(R2) ;CLEAR AMPLIFIED PRIVILEGES

	CLRW	FAB$W_IFI(R9)		;CLEAR IFI NUMBER
	MOVB	#FAB$M_CR,FAB$B_RAT(R9) ;SET RECORD ATTRIBUTES
	MOVB	#FAB$C_VAR,FAB$B_RFM(R9) ;SET RECORD FORMAT
	MOVPSL	R0			;READ CURRENT PSL
	CMPZV	#PSL$V_CURMOD,#PSL$S_CURMOD,- ;CURRENT MODE USER?
		R0,#PSL$C_USER		;
	BEQL	10$			;IF EQL YES
	BBSS	#FAB$V_PPF,FAB$L_FOP(R9),10$ ;SET PROCESS PERMANENT FILE
10$:	$CREATE FAB=(R9)		;CREATE FILE
	MOVZWL	FAB$W_IFI(R9),R4	;GET RESULTANT IFI NUMBER

	$SETPRV_S PRMFLG=#0,ENBFLG=#1,PRVADR=(R2) ;RESTORE IMAGE PRIVILEGES
	POPR	#^M<R0,R1,R2>		;CLEAN STACK AND RESTORE R2
	RSB				;

	.SBTTL	CLOSE MESSAGE FILES
;+
; EXE$CLOSE_MSG - CLOSE MESSAGE FILES OPENED BY EXE$OPEN_MSG
;
; THIS ROUTINE IS CALLED TO CLOSE THE FILES FOR USED TO OUTPUT
; MESSAGES.  IF CALLER IN USER MODE, THE FILES ARE LEFT OPEN AS
; AN OPTIMIZATION SINCE THEY WILL EVENTUALLY GET CLOSED BY IMAGE
; RUNDOWN.  HOWEVER, FOR OTHER ACCESS MODES, THE FILES MUST BE
; CLOSED HERE.
;
; INPUTS:
;
;	LOGICAL NAME "SYS$PUTMSG" CONTAINING 5 WORDS:
;
;		ESCAPE,OUTISI,ERRISI,OUTIFI,ERRIFI
;
; OUTPUTS:
;
;	THE FILES ARE CLOSED, IF POSSIBLE.
;-

EXE$CLOSE_MSG::
;
; IF WE ARE IN USER MODE, KEEP THE FILES OPEN AS AN OPTIMIZATION
; BECAUSE THEY WILL EVENTUALLY GET CLOSED BY RMS RUNDOWN WHEN THE
; IMAGE IS RUNDOWN.
;
	MOVPSL	R0			;GET CURRENT PSL
	CMPZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R0,#PSL$C_USER ;IN USER MODE?
	BNEQ	10$			;BRANCH IF NOT
	RSB				;EXIT - LEAVE FILES OPEN
;
; ALLOCATE AND INITIALIZE A FAB FOR OPENING THE FILES
;
10$:	PUSHR	#^M<R2,R3,R4,R4,R5>
	MOVAB	-FAB$C_BLN(SP),SP	;ALLOCATE SPACE FOR FAB
	MOVC5	#0,(SP),#0,#FAB$C_BLN,(SP) ;CLEAR FAB
	MOVL	SP,R2			;SAVE ADDRESS OF FAB
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#FAB$C_BID+<FAB$C_BLN@8>,FAB$B_BID(R2) ;SET BLOCK ID/LENGTH
;
; TRANSLATE THE LOGICAL NAME SYS$PUTMSG TO SEE IF THE FILE IS OPENED VIA
; EXE$OPEN_MSG.  IF THE LOGICAL NAME EXISTS, GET THE IFI'S AND USE THEM
; TO CLOSE THE FILES.
;
	PUSHAB	ISINAM+1		;BUILD ISI NAME STRING DESCRIPTOR
	MOVZBL	ISINAM,-(SP)		;
	MOVL	SP,R3			;SAVE ADDRESS OF ISI NAME STRING DESCRIPTOR
	SUBL	#12,SP			;ALLOCATE STORAGE FOR EQUIVALENCE NAME
	MOVL	SP,R4			;SAVE ADDRESS OF EQUIVALENCE NAME
	PUSHL	SP			;BUILD EQUIVALENCE NAME DESCRIPTOR
	PUSHL	#10			;
	MOVL	SP,R0			;SAVE ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S LOGNAM=(R3),-		;TRANSLATE LOGICAL NAME
		RSLBUF=(R0)
	CMPW	S^#SS$_NORMAL,R0	;NORMAL COMPLETION?
	BNEQ	50$			;IF NEQ NO
	CMPW	#ESCAPE,(R4)		;SPECIAL ESCAPE EQUIVALENCE NAME?
	BNEQ	50$			;IF EQL YES
;
; CLOSE SYS$ERROR
;
	MOVW	6(R4),FAB$W_IFI(R2)	;SET IFI INTO FAB
	$CLOSE	FAB=(R2)		;CLOSE SYS$ERROR
;
; IF SYS$OUTPUT IS NOT THE SAME AS SYS$ERROR, THEN CLOSE IT
;
	CMPW	6(R4),8(R4)		;BOTH IFI'S THE SAME?
	BEQL	20$			;BRANCH IF SO
	MOVW	8(R4),FAB$W_IFI(R2)	;SET IFI INTO FAB
	$CLOSE	FAB=(R2)		;CLOSE SYS$OUTPUT
;
; DELETE LOGICAL NAME "SYS$PUTMSG" TO INDICATE FILES CLOSED.
;
20$:	$DELLOG_S LOGNAM=(R3),-		;DELETE LOGICAL NAME
		TBLFLG=#LOG$C_PROCESS
50$:	MOVAB	FAB$C_BLN+8+12+8(SP),SP	;DEALLOCATE FAB AND SCRATCH SPACE
	POPR	#^M<R2,R3,R4,R5>	;RESTORE REGISTERS
	RSB
 
	.END
