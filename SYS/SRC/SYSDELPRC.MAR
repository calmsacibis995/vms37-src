	.TITLE	SYSDELPRC - DELETE PROCESS SYSTEM SERVICE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT:	SYSDELPRC IMPLEMENTS THE DELETE PROCESS SYSTEM SERVICE
;	WHICH CAUSES A PROCESS TO BE DELETED FROM THE SYSTEM AFTER
;	RELEASING ALL OF ITS RESOURCES.
;
; ENVIRONMENT:
;	MODE=KERNEL
;
; AUTHOR:	R. I. HUSTVEDT, CREATION DATE: 30-DEC-76
;
; MODIFIED BY:
;
;	V03-001	ACG0178		Andrew C. Goldstein,	1-Apr-1982  11:21
;		Remove FILECNTNONZ bugcheck
;
;	V02-026 SRB0047		Steve Beckhardt		2-Mar-1982
;		Modified code that removes ACBs from the PCB to honor
;		the nodelete bit.
;
;	V02-025	WMC0045		Wayne Cardoza		24-Feb-1982
;		Fix incorrect call to RMSRUNDWN
;
;	V02-023	WMC0033		Wayne M. Cardoza	4-Jan-1982
;		Setup arguments for privileged library rundown.  It may now
;		be called from either here or SYSRUNDWN.
;
;	V02-022	WMC0032		Wayne Cardoza		23-Dec-1981
;		Move privileged library rundown here from SYSRUNDWN so
;		it occurs before RMS rundown.
;
;	V02-021	LJK0085		Lawrence J. Kenah	17-Nov-1981
;		Do not allow parent to benefit from CPU time expiration 
;		of subprocess. If CPU time limit is exceeded, return
;		deficit to parent.
;
;	V02-020	KDM42146	Kathleen D. Morse	10-Nov-1981
;		Remove check for sub-process deletion error from $DELPRC
;		and associated bugcheck.  Code was over-cautious.
;
;	V02-019	SPF0012		Steve Forgey		29-Jul-1981
;		Add new accounting message formats and functions.
;
;	V02-018	STJ0069		Steven T. Jeffreys	19-Jul-1981
;		Modified invocation of the DECREF macro to force
;		a general addressing mode JSB to MMG$REFCNTNEG.
;
;	V02-017	HRJ0023		Herb Jacobs		01-Jul-1981
;		New deallocation of swapfile space for process.
;
;	V02-016	HRJ0022		Herb Jacobs		05-Jun-1981
;		Fix out of range branch to MMG$DELCONPFN.
;
;	V02-015	KTA0021		Kerbey T. Altmann	02-Jun-1981
;		Make a check that PID is not SWAPPER or NULL before
;		allowing the deletion.
;
;	V02-014	LJK0018		Lawrence J. Kenah	14-May-1981
;		After the subprocess count in the creator's PCB has been
;		decremented, report the ASTWAIT resource available so the
;		creator is sure to become computable on even a very quiet system.
;
;	V02-013	TMH0012		Tim Halvorsen		11-May-1981
;		Prevent ASTs while deleting P0/P1 space, to avoid access
;		violations trying to reference the system service vector
;		in P1 space.  All ASTs queued during this time will be
;		deleted when the process is evaporated later on.
;
;	V02-012	KDM36273	Kathleen D. Morse	06-Mar-1981
;		Remove race condition during deletion of creator process
;		and its sub-processes.  The sub-processes cannot let the
;		creator continue until they are done with the JIB.
;
;	V02-011	KTA0011		Kerbey T. Altmann	02-Mar-1981
;		Add code to create a channel table over the supervisor
;		stack if none already exits for the termination mailbox.
;
;	V02-010	KTA0010		Kerbey T. Altmann	28_Feb-1981
;		Update the search algorithm used by previous edit so as
;		to conform to the new meaning of CTL$GW_CHINDX.
;
;	V02-009	ACG0189		Andrew C. Goldstein,	13-Feb-1981  11:21
;		Bug check on channel deassign failures
;
;	V02-008 SPF0001		Steve Forgey		04-Feb-1981
;		Remove nonzero file count bug check.
;
;	V02-007	STJ0022		Steven T. Jeffreys	28-Jan-1981
;		Install bug trap to detect a nonzero file count.
;
;	V02-006	WMC0001		Wayne Cardoza		03-Jul-1980
;		Don't use the DELTVA macro so that we will use the 80000000
;		system service vector rather than P1.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$ACBDEF				; DEFINE AST CONTROL BLOCK OFFSETS
	$ACCDEF				; DEFINE TERMINATION MESSAGE OFFSETS
	$ACMDEF				; DEFINE ACCOUNTING MESSAGE OFFSETS
	$CCBDEF				; DEFINE CHANNEL CONTROL BLOCK
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				; DEFINE JOB INFORMATION BLOCK OFFSETS
	$MSGDEF				; DEFINE SYSTEM MESSAGE TYPE CODES
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFNDEF				; DEFINE PFN CONSTANTS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTER NAMES
	$PRIDEF				; DEFINE PRIORITY INCREMENTS
	$PTEDEF				; DEFINE PTE FIELDS
	$PSLDEF				; DEFINE PSL FIELDS AND VALUES
	$RSNDEF				; DEFINE RESOURCE NUMBERS
	$SECDEF				; DEFINE SECTION TABLE ENTRY
	$SSDEF				; DEFINE SYSTEM SERVICE STATUS CODES
	$UCBDEF				; DEFINE UNIT CONTROL BLOCK OFFSETS

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

ACB_L_CPULIM = ACB$L_KAST + 4
ACB_L_CPUTIM = ACB_L_CPULIM + 4

;
; OWN STORAGE:
;
	.PSECT	AEXENONPAGED
	.PAGE
	.SBTTL	EXE$DELPRC - DELETE PROCESS SYSTEM SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$DELPRC IMPLEMENTS THE DELETE PROCESS SYSTEM SERVICE WHICH CAUSES
;	A PROCESS TO BE DELETED FROM THE SYSTEM.  IF THE SPECIFIED
;	PROCESS EXISTS, A SPECIAL KERNEL AST IS QUEUED FOR IT TO
;	PERFORM THE DELETION PROCESSING IN THE CONTEXT OF THE TARGET
;	PROCESS.  A PROCESS THEREFORE DELETES ITSELF.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$DELPRC
;
; INPUT PARAMETERS:
;	PIDADR(AP)  - ADDRESS OF THE PROCESS IDENTIFICATION OF THE
;		      PROCESS TO BE DELETED.
;	PRCNAM(AP) - ADDRESS OF STRING DESCRIPTOR FOR PROCESS LOGICAL NAME 
;		      STRING.
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	CURRENT PROCESS PCB AND PHD
;	PCB OF TARGET PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	@PIDADR(AP) - PROCESS IDENTIFICATION OF DELETED PROCESS
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	SS$_NORMAL   -   SUCCESSFUL COMPLETION 
;	SS$_NONEXPR  -   NONEXISTENT PROCESS
;	SS$_NOPRIV   -   NO PRIVILEGE, TARGET PROCESS IS NOT A SUBPROCESS
;			 AND ISSUING PROCESS DOES NOT HAVE PROCESS CONTROL
;			 PRIVILEGE FOR GROUP OR WORLD.
;	SS$_INSFMEM  -	 INSUFFICIENT DYNAMIC MEMORY AVAILABLE FOR SERVICE
;			 AND RESOURCE WAIT MODE DISABLED.
;
; SIDE EFFECTS:
;	A SPECIAL KERNEL AST WILL BE ENQUEUED FOR THE PROCESS TO BE
;	DELETED WHICH MAY CAUSE RESCHEDULING TO OCCUR.
;
;--


	.ENTRY	EXE$DELPRC,^M<R2,R3,R4,R5,R6,R7>	; SAVE R2-R7
	BSBW	EXE$NAMPID		; CONVERT NAME/PID TO PCB ADDRESS
	BLBC	R0,RETURN		; EXIT IF ERROR
	BBSS	#PCB$V_DELPEN,PCB$L_STS(R4),RETN	; DONE IF MARKED FOR DELETE
	SETIPL	#0			; DROP IPL BEFORE ALLOCATE REQUEST
	CMPW	R1,W^SCH$GL_SWPPID	; IS PID VALID?
	BGTRU	10$			; IF GTRU, YES
	MOVZWL	#SS$_NONEXPR,R0		; NULL AND SWAPPER ARE INVALID
	BRB	RETURN			; TELL THE USER

10$:	PUSHL	R1			; AND SAVE PID OF TARGET PROCESS
	$RESUME_G	(AP)		; RESUME PROCESS
	BSBW	EXE$ALLOCIRP		; ALLOCATE AST PACKET
	BLBC	R0,RETURN		; RETURN ERROR IF NONE
	MOVL	R2,R5			; SET ADDRESS FOR ENQUEUE
	MOVAB	L^DELETE,ACB$L_KAST(R5)	; SET ADDRESS FOR DELETE ACTION
	MOVB	#<1@ACB$V_KAST>,ACB$B_RMOD(R5)	; MARK AS KERNEL MODE AST
	MOVL	(SP)+,ACB$L_PID(R5)	; SET PID OF TARGET
	MOVZBL	#PRI$_RESAVL,R2		; SET PRIORITY INCREMENT
	BSBW	SCH$QAST		; AND QUEUE AST FOR PROCESS
RETN:	MOVZWL	#SS$_NORMAL,R0		; SET NORMAL STATUS
RETURN:	
	SETIPL	#0			; ENABLE
	RET				; AND RETURN

	.PSECT	Y$EXEPAGED		; PAGED CODE PSECT
	.PAGE
	.SBTTL	DELETE - PERFORM DELETE ACTIONS IN CONTEXT OF PROCESS
;++
; FUNCTIONAL DESCRIPTION: DELETE EXECUTES AS THE RESULT OF A KERNEL
;	AST INITIATED BY THE DELETE PROCESS SYSTEM SERVICE.  IT PERFORMS
;	THE ACTIONS NECESSARY TO DELETE A PROCESS AND RETURN ITS RESOURCES.
;	TERMINATION MESSAGES ARE SENT TO THE TERMINATION MAILBOX UNIT
;	SPECIFIED WHEN THE PROCESS WAS CREATED AND TO THE SYMBIONT
;	MANAGER IF ACCOUNTING IS NOT DISABLED FOR THIS PROCESS.
;
; CALLING SEQUENCE:
;	SETIPL	#IPL$_ASTDEL
;	JSB	DELETE
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS
;	R5 - AST CONTROL BLOCK ADDRESS
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS (LOCATED VIA SCH$GL_CURPCB)
;	PHD OF CURRENT PROCESS
;
; IMPLICIT OUTPUTS:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--

DOREI:	REI				; FOR OUTWARD MODE CHANGE

DELETE:					; PERFORM DELETE OPERATIONS
	MOVL	R5,R0			; SET ADDRESS FOR ACB RELEASE
	BSBW	EXE$DEANONPAGED		; DEALLOCATE AST CONTROL BLOCK

	BSBW	SCH$NEWLVL		; COMPUTE NEW AST LEVEL
	SETIPL	#0			; AND DROP IPL
	BBCC	#PCB$V_SSRWAIT,PCB$L_STS(R4),10$	; ENABLE RESOURCE WAIT
10$:					;
;-------------------------------------------------------------
;
;	INVOKE THE USER RUNDOWN SERVICE(S)
;
;	The user service is invoked in KERNEL mode with a JSB and must
;	exit with a RSB.
;
;	R4 - Pointer to current PCB
;	R7 - Acess mode of call to rundown routine (always 0)
;	ACMODE(AP) - always 0
;
;	The above parameters are the same as in the call from SYSRUNDWN.
;
;-------------------------------------------------------------

	CLRL	R7			; KERNEL MODE RUNDOWN
	PUSHL	AP
	CLRL	-(SP)			; ANOTHER KERNEL MODE ACCESS PARAMETER
	PUSHL	#1
	MOVL	SP,AP
	MOVL	@#CTL$GL_USRUNDWN, R5	; GET PER-PROCESS USER RUNDOWN VECTOR
	BEQL	15$			; NOT PRESENT, SKIP ON
	JSB	(R5)			; CALL THRU THE VECTOR(S)
15$:	MOVL	G^EXE$GL_USRUNDWN, R5	; GET SYSTEM-WIDE USER RUNDOWN VECTOR
	BEQL	18$			; NOT PRESENT, SKIP ON
	JSB	(R5)			; CALL THRU THE VECTOR(S)
18$:	ADDL	#8,SP			; CLEAN UP
	MOVL	(SP)+,AP

;--------------------------------------------------------------
;
;	RMS RUNDOWN
;
;--------------------------------------------------------------

	MOVAB	-136(SP),SP		; ALLOCATE STRING BUFFER
20$:	MOVZBL	#128,(SP)		; SET COUNT FOR STRING BUFFER
	MOVAL	8(SP),4(SP)		; FORM ADDRESS PART OF DESCRIPTOR
	PUSHL	#2			; LAST CHANCE RMS CLEANUP
	PUSHAB	4(SP)			; SET ADDRESS OF STRING BUFFER	
	CALLS	#2,@#SYS$RMSRUNDWN	; DEFAULT CLOSE OF OPEN RMS FILES
	BLBC	R0,20$			; REPEAT IF MORE TO CLOSE

;--------------------------------------------------------------------
;
;	FIND AND DELETE ALL SUB-PROCESSES
;
;--------------------------------------------------------------------

SUBDELETE:				; DELETE SUB-PROCESSES
	TSTW	PCB$W_PRCCNT(R4)	; ANY SUB-PROCESSES?
	BEQL	50$			; NO, CONTINUE
	MOVZWL	SCH$GL_MAXPIX,R6	; INITIALIZE INDEX FOR PROCESS SCAN
10$:	MOVL	@L^SCH$GL_PCBVEC[R6],R3	; GET A PCB ADDRESS
	CMPL	PCB$L_PID(R4),PCB$L_OWNER(R3)	; DO WE OWN IT
	BNEQ	20$			; NO, TRY ANOTHER
	$DELPRC_S	PCB$L_PID(R3)	; MARK IT FOR DELETE
20$:	SOBGTR	R6,10$			; CONTINUE
30$:	MOVPSL	-(SP)			; SAVE PSL
	DSBINT	W^SUBWIPL,R6		; BLOCK SYSTEM EVENTS, SAVE IPL IN R6
	TSTW	PCB$W_PRCCNT(R4)	; CHECK COUNT OF SUB-PROCESSES STILL RUNNING
	BEQL	40$			; DONE
	MOVZWL	#RSN$_ASTWAIT,R0	; SET RESOURCE NUMBER
	BSBW	SCH$RWAIT		; AND WAIT FOR AN AST
	BRB	30$			; CHECK AGAIN WHEN AWAKENED
40$:	SETIPL	R6			; RESTORE IPL
50$:					; DONE, ALL SUB-PROCESSES DELETED
	BRB	RUNDWN			; CONTINUE WITH RUNDOWN
SUBWIPL:				;
	.LONG	IPL$_SYNCH		; MARKER FOR END OF TEMP NON-PAGED

;---------------------------------------------------------------------
;
;	RUNDOWN PROCESS ACTIVITY
;
;---------------------------------------------------------------------
RUNDWN:					; RUNDOWN PROCESS ACTIVITY
	PUSHL	#0			; SET MODE FOR RUNDOWN
	CALLS	#1,SYS$RUNDWN		; RUNDOWN AT KERNEL MODE
	MOVL	@#CTL$GL_PHD,R5		; GET PROCESS HEADER ADDRESS
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R2 ; GET ADDRESS OF SECTION TABLE
	CLRL	-(SP)			; ASSUME NO PAGES WILL BE DELETED
	SUBL	#16,SP			; SAVE ROOM FOR INRANGE AND RETRANGE
	MOVL	SP,R3			; REMEMBER SCRATCH AREA ADDRESS
	CVTWL	PHD$W_PSTLAST(R5),R6	; GET INDEX TO LAST SEC TBL ENTRY USED
	BRB	8$			; JOIN COMMON LOOP
4$:	TSTL	SEC$L_REFCNT(R2)[R6]	; ANY PAGES MAPPED?
	BLSS	6$			; BR IF NOTHING MAPPED TO THIS SECTION
;
; DO A $DELTVA FOR THIS SECTION.
;
	MOVAL	(R2)[R6],R7		; ADDRESS OF SECTION TABLE ENTRY
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,SEC$L_VPXPFC(R7),4(R3) ; GET START VPN
	CMPZV	#PHD$V_P0LR,#PHD$S_P0LR,PHD$L_P0LRASTL(R5),4(R3) ; IS VA IN P0?
	BGTRU	5$			; BR IF IT IS IN P0 SPACE
	ROTL	#7,SGN$GL_PTPAGCNT,R0	; GET LONGWD OFFSET FROM BEGIN OF PAGTBL
	SUBL	R0,4(R3)		; GET VPN IN P1 SPACE
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,4(R3),4(R3) ; MASK OFF SIGN BITS
5$:	ASHL	#9,4(R3),4(R3)		; GET VA OF FIRST PAGE MAPPED
	ASHL	#9,SEC$L_PAGCNT(R7),(R3) ; GET # OF BYTES IN SECTION
	ADDL2	4(R3),(R3)		; GET VA OF LAST PAGE MAPPED
	DECL	(R3)			; GET ADR OF LAST BYTE MAPPED
	$DELTVA_S	(R3),8(R3)	; DELETE PAGES FOR THIS SECTION
	CMPL	#-1,8(R3)		; WERE ANY PAGES DELETED?
	BEQL	6$			; BR IF NONE DELETED
	MOVL	#1,16(R3)		; INDICATE SECOND RUNDWN REQUIRED
6$:	ADDL2	#SEC$C_LENGTH@-2,R6	; GET OFFSET TO NEXT SECTION TABLE ENTRY
8$:	BLSS	4$			; GO CHECK NEXT SECTION
	ADDL	#16,SP			; CLEAN INRANGE AND RETRANGE OFF STACK
	TSTL	(SP)+			; WERE ANY PAGES DELETED?
	BEQL	10$			; NO, THEN DON'T BOTHER WITH 2ND RUNDWN
	PUSHL	#0			; SET MODE FOR RUNDOWN
	CALLS	#1,SYS$RUNDWN		; RUNDOWN AT KERNEL MODE
	BRB	55$			; BYPASS FOLLOWING BUG TRAP

;********************************************************************
;
; TEMPORARY BUG TRAP: SCAN THE CHANNEL TABLE AND LOOK FOR ASSIGNED
; CHANNELS. THERE SHOULD BE NONE.
;
;********************************************************************

10$:	MOVZWL	@#CTL$GW_CHINDX,R5	; GET MAXIMUM INDEX + 16
	BEQL	55$			; NO CHANNEL TABLE
	MNEGL	R5,R5			; CONVERT TO NEGATIVE OFFSET
	ADDL3	#CCB$B_AMOD, -
		@#CTL$GL_CCBBASE,R3	; COMPUTE ADDRESS OF HIGHEST CHANNEL
40$:	TSTB	(R3)[R5]		; IS THIS CHANNEL STILL ASSIGNED?
	BEQL	50$			; BRANCH IF NOT
	BUG_CHECK FILCNTNONZ,FATAL	; IT REALLY SHOULD HAVE WORKED

50$:	ADDL2	#CCB$C_LENGTH,R5	; NEXT CHANNEL
	BLSS	40$			; LOOP THRU
55$:

;********************************************************************
; END OF BUG TRAP
;********************************************************************
;
;	DISMOUNT ALL MOUNTED VOLUMES
;
	REMQUE	@CTL$GQ_MOUNTLST,R6	; GET A VOLUME TO BE DISMOUNTED
	BVS	20$			; NONE, FINISHED WITH DISMOUNT LIST
	CLRL	R3			; UNLOAD UPON DISMOUNT
	BSBW	IOC$DISMOUNT		; DISMOUNT IT
	BRB	10$			; AND TRY FOR ANOTHER
20$:					;
	$DALLOC_S	ACMODE=#0	; DEALLOCATE ALL
	CMPW	PCB$W_DIOCNT(R4),PCB$W_DIOLM(R4) ; WAIT FOR DIRECT I/O COMPLETION
	BNEQ	20$			;
30$:	CMPW	PCB$W_BIOCNT(R4),PCB$W_BIOLM(R4) ; AND BUFFERED I/O
	BNEQ	30$			;

;--------------------------------------------------------------------
;
;	SEND REMAINING QUOTAS TO OWNER IF SUB-PROCESS
;
;--------------------------------------------------------------------
RELQUOTA:				; RELEASE QUOTAS
	CLRB	PCB$T_LNAME(R4)		; REMOVE PROCESS NAME
	MOVL	PCB$L_OWNER(R4),R6	; GET PID OF OWNER
	BEQL	MESSAGES		; IF EQL, NOT A SUBPROCESS
	PUSHL	R4			; SAVE PCB ADDRESS
	MOVZWL	R6,R6			; EXTRACT PIX FROM OWNER PID
	MOVL	@L^SCH$GL_PCBVEC[R6],R4	; AND GET PCB
	BSBW	EXE$ALLOCIRP		; ALLOCATE AST CONTROL BLOCK
	BLBC	R0,20$			; SKIP QUOTA RETURN IF ERROR
	MOVL	R2,R5			; SET ADDRESS OF QUOTA AST BLOCK
	MOVAB	W^RETQUOTA,ACB$L_KAST(R5)	; SET AST ADDRESS FOR SPECIAL
					; KERNEL AST TO RETURN QUOTAS
	MOVB	#<1@ACB$V_KAST>,ACB$B_RMOD(R5)	; FLAG AS SPECIAL KERNEL AST
	MOVL	PCB$L_PID(R4),ACB$L_PID(R5)	; SET TARGET PID FOR AST
	MOVL	(SP),R2			; GET PCB ADDRESS FOR PROCESS BEING DELETED
	MOVL	@#CTL$GL_PHD,R1		; GET PROCESS HEADER ADDRESS
	SUBL3	PHD$L_EXTRACPU(R1),PHD$L_CPULIM(R5),ACB_L_CPULIM(R5)
					; SAVE CPULIMIT LESS BONUS
	MOVL	PHD$L_CPUTIM(R1),ACB_L_CPUTIM(R5)
					;  AND ACCUMULATED CPU TIME
	MOVZWL	#PRI$_RESAVL,R2		; SET PRIORITY INCREMENT CLASS
	BSBW	SCH$QAST		; QUEUE AST FOR CREATOR
20$:	POPR	#^M<R4>			; RESTORE PCB ADDRESS
	SETIPL	#0			; DROP IPL TO ISSUE SYSTEM SERVICE REQUESTS

;--------------------------------------------------------------------
;
;	TERMINATION MESSAGES
;
;--------------------------------------------------------------------
MESSAGES:				; SEND TERMINATION MESSAGES
	TSTW	PCB$W_TMBU(R4)		; TERMINATION MAILBOX SPECIFIED ?
	BEQL	10$			; IF EQL, NO
	BSBW	TERMMSG			; SEND MESSAGE TO TERMINATION MAILBOX
10$:					; SEND MESSAGE TO JOB CONTROLLER
	BBC	#PCB$V_BATCH,PCB$L_STS(R4),20$	; IF BC, NOT A BATCH JOB
	BBCC	#PCB$V_SSRWAIT,PCB$L_STS(R4),20$; ENABLE RESOURCE WAIT MODE
20$:	
	CLRL	R5			; NOT A SPECIAL KERNEL AST ROUTINE
	BSBW	EXE$PRCDELMSG		; SEND PROCESS DELETE MESSAGE

;---------------------------------------------------------------------
;
;	DESTROY PROCESS
;
;---------------------------------------------------------------------
DESTROY:				;
	SETIPL	#IPL$_ASTDEL		; NO MORE ASTS AFTER THIS POINT
	SUBL	#16,SP			; 4 LONGWORDS OF STORAGE
	MOVL	SP,R2			; SAVE BASE
	MOVL	#<1@30>,(R2)		; SET STARTVA
	MOVL	#<<1@31>-1>,4(R2)	; END AT VECTOR PAGE
; WE CAN'T USE THE MACRO SINCE THE P1 VECTORS WILL DISAPPEAR
;	$DELTVA_S	(R2),8(R2)	; DELETE FROM KERNEL STACK TO VECTORS
	PUSHL	#0
	PUSHAQ	8(R2)
	PUSHAQ	(R2)
	CALLS	#3,SYS$DELTVA-P1SYSVECTORS+^X80000000 ; DELETE KSTK TO VECTORS
					; ENTER & EXIT DELTVA AT IPL(ASTDEL)
	SETIPL	W^DESTROY_SYNCH		; BLOCK SYSTEM EVENTS
					; AND LOCK PAGABLE CODE
	SVPCTX				; SAVE PROCESS CONTEXT
					; AND GO TO INTERRUPT STACK
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS
	MOVZWL	PHD$W_PHVINDEX(R5),R10	; GET BALANCE SLOT INDEX
	MOVAB	L^SCH$GL_NULLPCB,R3	; GET POINT TO NULL PROCESS PCB
	MOVL	R3,L^SCH$GL_CURPCB	; SET AS CURRENT PCB
	MOVZWL	@L^PHV$GL_PIXBAS[R10],R1 ; GET PROCESS INDEX
	MOVL	R3,@L^SCH$GL_PCBVEC[R1]	; RELEASE PROCESS INDEX SLOT
	MOVZWL	PHD$W_WSLOCK(R5),R9	; POINT TO FIRST NON PERM PAGE
	CLRL	(R5)[R9]		; MARK WITH A ZERO
	MOVZWL	PHD$W_WSLIST(R5),R8	; LONGWORD INDEX TO START OF WORKING SET LIST
	MOVAL	(R5)[R8],R8		; FORM BYTE ADDRESS OF START OF WSLIST
40$:	MOVL	(R8)+,R2		; GET VA OF PERM PAGE
	BEQL	60$			; DONE, NONE LEFT
	BLBC	R2,40$			; IGNORE IF NOT VALID
	BLSS	40$			; OR IF HEADER PAGES (SYSTEM ADDRESS)
	BSBW	DELPAGE			; DELETE PAGE
	BRB	40$			; CONTINUE

60$:	REMQUE	@PCB$L_ASTQFL(R4),R0	; REMOVE PENDING AST CONTROL BLOCKS
	BVS	70$			; NONE LEFT
	BBS	#ACB$V_NODELETE,-	; BR. IF NODELETE BIT IS SET.  THIS
		ACB$B_RMOD(R0),60$	; SHOULD NOT HAPPEN BUT IF IT DOES MAY
					; RESULT IN LOSING POOL (WHICH IS 
					; PREFERABLE OVER A DOUBLE DEALLOCATE).
	BSBB	DEANONPAGED		; DEALLOCATE SPACE FOR ACB
	BRB	60$			; AND CONTINUE
70$:	MOVL	PCB$L_WSSWP(R4),R0	; GET VBN OF AREA TO FREE IN SWAPFILE
	BEQL	80$			; NONE, CONTINUE
	MOVZWL	PHD$W_SWAPSIZE(R5),R1	; SIZE OF AREA TO FREE
	EXTZV	#24,#8,R0,R3		; SET SWAP FILE NUMBER
	EXTZV	#0,#24,R0,R0		; GET VBN OF AREA
	MOVL	@L^MMG$GL_PAGSWPVC[R3],R3 ; GET ADDRESS OF PFL CONTROL BLOCK
	JSB	L^MMG$DEALLOCPAGFIL	; DEALLOCATE AREA
80$:	MOVL	PCB$L_JIB(R4),R0	; GET ADDRESS OF JIB FOR RELEASE
	BEQL	90$			; BR IF NONE
	DECW	JIB$W_PRCCNT(R0)	; ONE LESS PROCESS IN THIS TREE
	CMPL	PCB$L_PID(R4),JIB$L_MPID(R0) ; IS THIS THE MASTER PROCESS?
	BNEQ	90$			; BR IF NOT
	BSBB	DEANONPAGED		; DEALLOCATE JIB
90$:	MOVZWL	PCB$L_OWNER(R4),R0	; GET PIX FROM OWNER UIC
	BEQL	100$			; BR IF NOT A SUB-PROCESS
	MOVL	@L^SCH$GL_PCBVEC[R0],R0	; GET ADDRESS OF OWNER PCB
	DECW	PCB$W_PRCCNT(R0)	; DECREMENT COUNT OF SUB-PROCESSES
	MOVL	#RSN$_ASTWAIT,R0	; NOTIFY PARENT PROCESS THAT ITS
	BSBW	SCH$RAVAIL		;  SUBPROCESS COUNT HAS BEEN DECREMENTED
100$:	MOVL	R4,R0			; SET ADDRESS OF PCB FOR RELEASE
	BSBB	DEANONPAGED		; AND DELETE IT
	DECW	L^SWP$GW_BALCNT		; DECREASE COUNT IN BALANCE SET
	BSBW	SCH$SWPWAKE		; WAKE SWAPPER
	MCOMW	#0,@L^PHV$GL_PIXBAS[R10] ; INDICATE PROCESS HEADER TO BE DELETED
	INCW	L^SCH$GW_DELPHDCT	; FLAG SWAPPER'S ATTENTION
	DECW	L^SCH$GW_PROCCNT	; ONE LESS PROCESS NOW
	JMP	L^SCH$SCHED		; AND SCHEDULE FOR ANOTHER PROCESS

DEANONPAGED:				;
	JMP	L^EXE$DEANONPAGED	; JUMP TO REACH REAL DEANONPAGED
	.PAGE
	.SBTTL	DELPAGE - DELETE PAGE
;++
; FUNCTIONAL DESCRIPTION:
;	DELPAGE DELETES THE CONTENTS OF THE SPECIFIED PAGE AND PLACES
;	 THE PFN ON THE FREE PAGE LIST.
;
; CALLING SEQUENCE:
;	BSB	DELPAGE
;
; INPUT PARAMETERS:
;	R2 - VIRTUAL ADDRESS OF PAGE TO RELEASE
;	R4 - PCB ADDRESS OF PROCESS OWNING PAGE
;	R5 - PROCESS HEADER ADDRESS OF PROCESS OWNING PAGE
;
; OUTPUT PARAMETERS:
; 	NONE
;
;--

DELPAGE:				; DELETE PAGE
	JSB	MMG$SVAPTECHK		; GET SVA OF PTE FOR PAGE
	BBCC	#PTE$V_VALID,(R3),50$	; EXIT IF NOT VALID
	BBCC	#PTE$V_MODIFY,(R3),10$	; CLEAR MODIFY INDICATOR
10$:	EXTZV	#0,#PTE$S_PFN,(R3),R0	; GET PFN FROM PTE
	DECREF	,,,L^,,JSB		; DROP REFERENCE COUNT ON PAGE
	BGTR	50$			; BR IF CANT RELEASE YET
	BICB	#PFN$M_MODIFY,@L^PFN$AB_STATE[R0] ; MAKE SURE NO MODIFY BIT
20$:	JSB	MMG$DELCONPFN		; DELETE CONTENT OF PFN
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	CLRL	R2			; INDICATE FREE LIST
	JSB	MMG$INSPFNH		; INSERT AT HEAD OF FREE LIST
50$:	RSB				;

DESTROY_SYNCH:				; END OF NONPAGABLE AREA
	.LONG	IPL$_SYNCH		; SYNCHRONIZATION IPL TO BLOCK SYSTEM EVENTS
	.PAGE
	.SBTTL	TERMMBX - SEND MESSAGE TO TERMINATION MAILBOX

;---------------------------------------------------------------------
;
;	BUILD PROCESS TERMINATION MESSAGE AND SEND TO TERMINATION 
;	MAILBOX UNIT.
;
;---------------------------------------------------------------------

TERMMSG:				; SEND TERMINATION MESSAGES
	MOVL	SP,R10			; SAVE STACK STATE
	PUSHL	PCB$L_OWNER(R4)		; PID OF SUBPROCESS OWNER (0 => NONE)
	MOVL	@#CTL$GL_PHD,R5		; GET PROCESS HEADER ADDRESS
	MOVQ	@#CTL$GQ_LOGIN,-(SP)	; LOGIN TIME
	ASSUME	ACC$L_OWNER EQ ACC$Q_LOGIN+8
	PUSHL	@#CTL$GL_VOLUMES	; COUNT OF MOUNTED VOLUMES
	ASSUME	ACC$Q_LOGIN EQ ACC$L_VOLUMES+4
	PUSHL	PHD$L_DIOCNT(R5)	; DIRECT I/O COUNT
	ASSUME	ACC$L_VOLUMES EQ ACC$L_DIOCNT+4
	PUSHL	PHD$L_BIOCNT(R5)	; BUFFERED I/O COUNT
	ASSUME	ACC$L_DIOCNT EQ ACC$L_BIOCNT+4
	PUSHL	@#CTL$GL_WSPEAK		; PEAK WORKING SET SIZE
	ASSUME	ACC$L_BIOCNT EQ ACC$L_WSPEAK+4
	PUSHL	#0			; PEAK PAGING FILE USAGE
	ASSUME	ACC$L_WSPEAK EQ ACC$L_PGFLPEAK+4
	PUSHL	PHD$L_PAGEFLTS(R5)	; TOTAL PROCESS PAGE FAULTS
	ASSUME	ACC$L_PGFLPEAK EQ ACC$L_PAGEFLTS+4
	PUSHL	PHD$L_CPUTIM(R5)	; SAVE ACCUMULATED CPU TIME FOR PROCESS
	ASSUME	ACC$L_PAGEFLTS EQ ACC$L_CPUTIM+4
	MOVAB	@#CTL$T_USERNAME+12,R0	; GET BASE ADDRESS
	MOVQ	-(R0),-(SP)		; LAST HALF OF USER NAME
	PUSHL	-(R0)			; FIRST LONGWORD OF USER NAME
	MOVAB	W^<CTL$T_ACCOUNT-CTL$T_USERNAME>(R0),R0 ; POINT PAST ACCOUNT
	ASSUME	ACC$L_CPUTIM EQ ACC$T_USERNAME+12
	MOVQ	(R0),-(SP)		; SET ACCOUNT INTO RECORD
	ASSUME	ACC$T_USERNAME EQ ACC$T_ACCOUNT+8
	MOVQ	EXE$GQ_SYSTIME,-(SP)	; LOGOUT TIME
	ASSUME	ACC$T_ACCOUNT EQ ACC$Q_TERMTIME+8
	PUSHL	#0			; JOBID
	ASSUME	ACC$Q_TERMTIME EQ ACC$L_JOBID+4
	PUSHL	PCB$L_PID(R4)		; PROCESS ID
	ASSUME	ACC$L_JOBID EQ ACC$L_PID+4	
	PUSHL	@#CTL$GL_FINALSTS	; FINAL STATUS OF PROCESS
	ASSUME	ACC$L_PID EQ ACC$L_FINALSTS+4
	PUSHL	#MSG$_DELPROC		; MESSAGE TYPE
	ASSUME	ACC$L_FINALSTS EQ ACC$W_MSGTYP+4
	MOVL	SP,R7			; MESSAGE ADDRESS
	MOVZWL	PCB$W_TMBU(R4),R0	; TERMINATION MAILBOX UNIT
	MOVQ	#^A/MB00000:/,-(SP)	; SKELETON FOR DEVICE STRING
	CLRL	R1			; INIT FOR EDIV
	MOVAB	7(SP),R3		; POINTER TO LSD OF DEVICE NAME
10$:	EDIV	#10,R0,R0,R2		; CONVERT A DECIMAL DIGIT
	ADDB	R2,-(R3)		; SET DIGIT INTO NAME STRING IN ASCII
	TSTL	R0			; CHECK FOR END
	BNEQ	10$			; NOT YET, CONVERT ANOTHER DIGIT
	PUSHL	SP			; BUILD STRING DESCRIPTOR FOR 
	PUSHL	#8			; MAILBOX NAME
	MOVL	SP,R8			; AND SAVE POINTER TO NAME DESCRIPTOR
	MOVAL	-(SP),R9		; RESERVE SPACE FOR CHANNEL
;
; CHECK FOR PRESENCE OF CHANNEL TABLE, IF NON-EXISTENT (I.E. PROCESS DELETED
; BEFORE THE CREATION OF IT) USE A PAGE OF SUPERVISOR STACK FOR IT.
;
	TSTW	@#CTL$GW_NMIOCH		; IS THERE A VALID CHANNEL TABLE?
	BNEQ	20$			; YES, SKIP TO ASSIGN
	PUSHL	R4			; SAVE PCB ADDRESS
	MOVL	@#CTL$AL_STACK+<4*PSL$C_SUPER>,R3	; PICK UP SUPER SP
	MOVAB	-CCB$C_LENGTH(R3),-
		@#CTL$GL_CCBBASE	; MAKE IT TABLE BASE
	MOVC5	#0,(SP),#0,#512,-512(R3); CLEAR IT OUT
	POPL	R4			; RESTORE PCB ADDRESS
	MOVZWL	#<512/CCB$C_LENGTH>-1,-	; SET NUMBER OF CHANNELS
		@#CTL$GW_NMIOCH
;
; ASSIGN CHANNEL TO MAILBOX AND WRITE THE MESSAGE
;
20$:
	$ASSIGN_S	DEVNAM=(R8),-	; ATTEMPT TO ASSIGN CHANNEL TO
			CHAN=(R9)	; MAILBOX
	BLBC	R0,30$			; UNABLE TO ASSIGN, IGNORE
	$QIO_S		CHAN=(R9),-	; SEND TERMINATION MESSAGE
			FUNC=#<IO$_WRITEVBLK!IO$M_NOW>,-
			P1=(R7),-	; MESSAGE ADDRESS
			P2=#ACC$C_TERMLEN; MESSAGE SIZE
30$:
	$DASSGN_S	CHAN=(R9)	; DEASSIGN CHANNEL
	MOVL	R10,SP			; RESTORE STACK STATE
	RSB

	.PAGE
	.SBTTL	RETURN QUOTAS TO CREATING PROCESS
;----------------------------------------------------------------------------
;
;		RETURN QUOTAS TO CREATING PROCESS
;
;----------------------------------------------------------------------------

;++
; FUNCTIONAL DESCRIPTION:
;	RETQUOTA IS ENTERED VIA A SPECIAL KERNEL AST DIRECTED TO THE
;	CREATOR OF A SUB-PROCESS.  THE AST CONTROL BLOCK CONTAINS THE
;	UNUSED QUOTAS TO BE RETURNED TO THE CREATOR.
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;	R5 - POINTER TO AST CONTROL BLOCK
;	BYTCNT(R5) - BUFFERED I/O BYTE COUNT QUOTA
;	CPULIM(R5) - CPU TIME LIMIT REMAINING
;	FILLM(R5)  - OPEN FILE QUOTA
;	PRCLM(R5)  - SUB-PROCESS QUOTA
;	TQLM(R5)   - TIMER QUEUE ENTRY QUOTA
;	PGFLQUOTA(R5) - PAGING FILE QUOTA
;
; OUTPUT PARAMETERS:
;	PHD$L_CPUTIM, PHD$L_CPULIM, PHD$W_FILLM, PHD$W_PRCLM, PHD$W_TQLM,
;	PHD$L_PGFLQUOTA AND PCB$W_BYTLM HAVE THE CORRESPONDING REMAINING
;	QUOTA VALUES ADDED TO THEM.
;
; SIDE EFFECTS:
;	THE AST CONTROL BLOCK LOCATED VIA R5 IS RELEASED TO THE NON-PAGED
;	DYNAMIC MEMORY POOL.
;
; ENVIRONMENT:
;	IPL$_ASTDEL  -  AST DELIVERY IPL WHILE CARRYING POINTER TO 
;			AST CONTROL BLOCK.
;
;--
RETQUOTA:				;
	MOVL	@#CTL$GL_PHD,R1		; GET SAFE POINTER TO PROCESS HEADER
	TSTL	PHD$L_CPULIM(R1)	; CHECK FOR NO QUOTA
	BEQL	20$			; YES SKIP RETURN OF CPU QUOTA
	SUBL3	ACB_L_CPUTIM(R5),ACB_L_CPULIM(R5),R0 ; GET DIFFERENCE
	BGEQU	10$			; EXCESS OR DEFICIT (BRANCH IF EXCESS)
	MNEGL	R0,-(SP)		; HANDLE DEFICIT VERY CAREFULLY
	CMPL	(SP)+,PHD$L_CPULIM(R1)	; CAN CREATOR ACCOMMODATE DEFICIT?
	BLSSU	10$			; BRANCH IF YES
	SUBL2	R0,PHD$L_CPUTIM(R1)	; OTHERWISE, TREAT DEFICIT AS ELAPSED
					;  CPU TIME
	BRB	20$			;  DEALLOCATE AST CONTROL BLOCK

10$:	ADDL2	R0,PHD$L_CPULIM(R1)	; GIVE BACK EXCESS 
20$:	MOVL	R5,R0			; GET ADDRESS FOR RELEASE
	BRW	EXE$DEANONPAGED		; RETURN VIA DEALLOCATE NONPAGED

	.END
