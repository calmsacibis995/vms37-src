	.TITLE	SYSDGBLSC - DELETE GLOBAL SECTION SYSTEM SERVICE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;
; ABSTRACT:
;
;
; ENVIRONMENT:
;
; AUTHOR: PETER H. LIPMAN, CREATION DATE: 9-MAY-77
;
; MODIFIED BY:
;
;	V03-001	DWT0038		David Thiel		 7-Apr-1982
;		Allow any processor to delete global sections in
;		shared memory after the creating processor has
;		been rebooted.
;		Correct entry mask to be consistent with the change
;		mode dispatcher.
;		Use an interlocked instruction to set a bit in
;		the shared memory.
;
;	V02-029	GAS0053		Gerry Smith		 3-Mar-1982
;		Fix descriptor build for GSD
;
;	V02-028 MSH0001		Maryann Hinden		23-Feb-1982
;		Fix PROBE problem.
;
;	V02-027	LMP0009		L. Mark Pilant		 5-Feb-1982  11:08
;		Fix range limitation to avoid Linker truncation errors.
;
;	V02-026	WMC0002		Wayne Cardoza		20-Aug-1981
;		Support for limit on page file used for global sections.
;
;	V02-025	WMC0001		Wayne Cardoza		12-Aug-1981
;		Add support for page file backing store global sections.
;
;	V02-024	HRJ0023		Herb Jacobs		01-Jul-1981
;		Fix currently unused path to dealloacte paging file for
;		the deleted global section.
;
;	V02-023	LJK38594	Lawrence J. Kenah	18-Jun-1981
;		Do not place an extended GSD used for a PFN-mapped global
;		section on the GSD free list. Instead, deallocate the GSD back
;		to paged pool. 
;
;	V02-022	LJK0022		Lawrence J. Kenah	19-May-1981
;		Replace CDL$x_ symbols with MMG$x_ symbols. Add $MMGDEF
;		macro. Make these offsets local symbols.
;
;	V02-021	KTA0014		Kerbey T. Altmann	10-Apr-1981
;		Change some code to accommodate changed IOC$FFCHAN.
;
;	V02-020	KDM36490	KATHLEEN D. MORSE	18-MAR-1981
;		Use correct register for SEC$V_SYSGBL check.
;
;	V02-019	KDM35937	KATHLEEN D. MORSE	26-FEB-1981
;		Prohibit global, demand-zero, copy-on-reference sections.
;		Return SS$_IVSECFLG instead.
;
;	V02-018	KDM0030		KATHLEEN D. MORSE	19-JAN-1981
;		Return SS$_IVSECFLG for requests to create temporary
;		PFNMAP global sections.  If they are created, they hang
;		around indefinitely because there is no section table entry
;		upon which the delayed deletion algorithm depends.
;
;	V02-017	KDM0026		KATHLEEN D. MORSE	17-NOV-1980
;		Fix check for protect bit in section flags.
;
;	V02-016	KDM0021		KATHLEEN D. MORSE	28-AUG-1980
;		Add check for section flags.  A demand-zero section
;		must also be either copy-on-reference or writable.
;
;	V02-015	KDM0020		KATHLEEN D. MORSE	28-AUG-1980
;		Fix bug in PFNMAP global section deletion.
;
;	V02-014	KDM29916	KATHLEEN D. MORSE	25-APR-1980
;		Remove the delete pending bit, SEC$V_DELPEND, as it is
;		unnecessary.
;
;	V02-013	KDM29877	KATHLEEN D. MORSE	17-APR-1980
;		Fix register used for WCB insque.
;
;	V02-012	KDM29444	KATHLEEN D. MORSE	11-APR-1980
;		Add test for mutex being held by process trying to do
;		MMG$DELGBLWCB.  Don't call other system services if mutex
;		is being held (INSTALL path through $IMGACT holds KFI mutex).
;		Also, ignore $DASSGN failure codes in MMG$DELGBLWCB as
;		any error is harmless.  Remove the bugcheck for that error.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CCBDEF				;CHANNEL CONTROL BLOCK DEFINITIONS
	$DYNDEF				;DYNAMIC STRUCTURE TYPES
	$GSDDEF				;GLOBAL SECTION DESCRIPTOR DEFINITIONS
	$IPLDEF				;PROCESSOR PRIORITY LEVELS
	$JIBDEF				;JOB INFORMATION BLOCK DEFINITIONS
	$LOGDEF				;LOGICAL NAME STRING DEFINITIONS
	$MMGDEF				;OFFSETS FROM FP INTO SCRATCH AREA
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PFNDEF				;PFN DATA BASE DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINITIONS
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
	$PSLDEF				;PROCESSOR STATUS LONGWORD DEFINITIONS
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$SECDEF				;SECTION TABLE DEFINITIONS
	$SHBDEF				;SHARED MEMORY CONTROL BLOCK DEF
	$SSDEF				;SYSTEM STATUS DEFINITIONS
	$UCBDEF				;UNIT CONTROL BLOCK DEFINITIONS
	$WCBDEF				;WINDOW CONTROL BLOCK DEFINITIONS
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
;
; OFFSETS FROM AP
;
	$OFFSET	4,POSITIVE,<-
		FLAGS,-			;GLOBAL SECTION CONTROL FLAGS
		GSDNAM,-		;GLOBAL SECTION NAME DESCRIPTOR ADDRESS
		IDENT,-			;ADDRESS OF SECTION IDENTIFICATION
	>
;
; OWN STORAGE:
;

	.SBTTL	VFYSECFLG - VERIFY SECTION FLAGS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE VERIFIES THAT THE SECTION FLAGS CONTAIN ONLY
;	THOSE FLAG BITS DEFINED AT THE USER INTERFACE
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$VFYSECFLG
;
; INPUT PARAMETERS:
;
;	R0 = SECTION FLAGS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	IF SECTION FLAGS ARE NOT LEGAL, THEN THIS ROUTINE EXITS WITH RET
;	OTHERWISE IT RSB'S TO ITS CALLER WITH:
;
;	R0 PRESERVED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_IVSECFLG			;INVALID SECTION FLAGS
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$VFYSECFLG::
	BITL	#^C<SEC$M_GBL ! -	;GLOBAL/PROCESS SECTION
		SEC$M_CRF ! -		;COPY ON REFERENCE
		SEC$M_DZRO ! -		;DEMAND ZERO
		SEC$M_WRT ! -		;WRITABLE
		SEC$M_SYSGBL ! -	;SYSTEM/GROUP GLOBAL
		SEC$M_PFNMAP ! -	;MAP TO SPECIFIC PFN'S
		SEC$M_EXPREG ! -	;MAP TO FIRST FREE VA SPACE
		SEC$M_PROTECT ! -	;PROTECTED SECTION
		SEC$M_PAGFIL ! -	;PAGE FILE BACKING STORE
		SEC$M_WRTMOD ! -	;WRITE ACCESS MODE
		SEC$M_PERM >,R0		;PERMANENT/TEMPORARY
	BNEQ	20$			;BRANCH IF ANY BAD BITS
	BBS	#SEC$V_PFNMAP,R0,18$	;BR TO DO FURTHER CHECKS IF PFNMAP
	BBC	#SEC$V_PAGFIL,R0,5$
	BBS	#SEC$V_CRF,R0,20$	;CRF NOT LEGAL FOR PAGE FILE BACKING STORE
	BBC	#SEC$V_GBL,R0,20$	;MUST BE GBL
5$:	BBC	#SEC$V_DZRO,R0,10$	;IS THIS A DEMAND-ZERO SECTION?
	BITL	#<SEC$M_CRF!SEC$M_WRT>,R0 ;IF YES, THEN IT MUST BE CRF OR
	BEQL	20$			;WRT TOO, ELSE ERROR
	ASSUME	<SEC$M_GBL!SEC$M_CRF!SEC$M_DZRO> EQ 7
	CMPZV	#0,#3,R0,#<SEC$M_GBL!SEC$M_CRF!SEC$M_DZRO> ;GBL, CRF, DZRO
	BEQL	20$			;SECTIONS ARE PROHIBITED

10$:	PUSHL	R0			;SAVE FLAGS
	MOVZBL	#PSL$C_USER,R0		;ASSUME WRITE ACCESS MODE NOT SPECIFIED
	BBC	#SEC$V_PROTECT,(SP),15$	;BR IF WRITE ACCESS MODE NOT SPECIFIED
	EXTZV	#SEC$V_WRTMOD,#SEC$S_WRTMOD,(SP),R0 ;GET WRT ACMODE SPECIFIED
	BSBW	EXE$MAXACMODE		;MAXIMIZE WRT MODE WITH PREV MODE
15$:	INSV	R0,#SEC$V_WRTMOD,#SEC$S_WRTMOD,(SP) ;PUT MAX WRT MODE IN FLAGS
	MOVL	(SP)+,R0		;SET VERIFIED FLAGS AND WRT MODE
	MOVL	R0,MMG$L_VFYFLAGS(FP)	;REMEMBER VERIFIED FLAGS FOR LATER USE
	RSB				;OK, RETURN TO CALLER

18$:	BITL	#<SEC$M_CRF!SEC$M_DZRO>,R0 ;PFNMAP SECTIONS CANNOT BE CRF
	BNEQ	20$			;OR DZRO. BR IF FLAGS ILLEGAL.
;
; THIS CODE REQUIRES SEC$V_PERM TO BE SET FOR ALL PFNMAP GLOBAL SECTIONS.
; TEMPORARY PFNMAP GLOBAL SECTIONS NEVER GO AWAY BECAUSE THE DELAYED
; DELETION MECHANISM FOR GLOBAL SECTIONS REQUIRES THE SECTION TO HAVE
; A SECTION TABLE ENTRY.  PFNMAP SECTIONS DO NOT HAVE SECTION TABLE
; ENTRIES BECAUSE THEY ARE NOT ASSOCIATED WITH A FILE.  THUS, THE
; ROUTINE MMG$DALCSTXSCN NEVER FINDS PFNMAP GLOBAL SECTIONS.
;
	BBC	#SEC$V_GBL,R0,10$	;BR IF PROCESS PFNMAP SECTION
	BBS	#SEC$V_PERM,R0,10$	;BR ON FLAGS OK, GBL PERM PFNMAP SEC
20$:	MOVZWL	#SS$_IVSECFLG,R0	;INVALID SECTION FLAGS
	RET				;RETURN FROM SYSTEM SERVICE

	.SBTTL	GSDMTXULK - UNLOCK GLOBAL SECTION MUTEX
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UNLOCKS THE GLOBAL SECTION MUTEX
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$GSDMTXULK
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	SCH$GL_CURPCB = PROCESS CONTROL BLOCK OWNING THE MUTEX
;	EXE$GL_GSDMTX = MUTEX TO UNLOCK
;
; OUTPUT PARAMETERS:
;
;	R4 = CURRENT PCB ADDRESS
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; THE FOLLOWING ROUTINE IS INVOKED BY THE SWAPPER THROUGH CHKDGBLSC.
; IT MAY LATER BE REQUIRED TO REMAIN RESIDENT.
;
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;
MMG$GSDMTXULK::
	MOVL	L^SCH$GL_CURPCB,R4	;PROCESS CONTROL BLOCK ADDRESS
	MOVAL	L^EXE$GL_GSDMTX,R0	;GLOBAL SECTION MUTEX
	JSB	SCH$UNLOCK		;UNLOCK THE MUTEX
	RSB				;AND RETURN

	.SBTTL	DGBLSC - DELETE GLOBAL SECTION SYSTEM SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,@#SYS$DGBLSC
;	CALLG	ARGLIST,MMG$DGBLSC1
;
; INPUT PARAMETERS:
;
;	FLAGS(AP)  = BIT  0  - GBL - GLOBAL IF SET, PROCESS IF CLEAR
;		     BIT  1  - CRF - COPY ON REFERENCE
;		     BIT  2  - DZRO - DEMAND ZERO
;		     BIT  3  - WRT - WRITABLE IF SET, READ ONLY IF CLEAR
;		     BITS 4  - 13 RESERVED, MUST BE ZERO
;		     BIT  14 - PERM - PERMANENT IF SET, TEMPORARY IF CLEAR
;		     BIT  15 - SYSGBL - SYSTEM GLOBAL IF SET, GROUP GLOBAL IF CLEAR
;		     BIT  16 - PFNMAP - MAP TO SPECIFIC PFN'S
;		     BIT  17 - EXPREG, MAP TO FIRST FREE SPACE AVAILABLE
;				(UNUSED FOR $DGBLSC)
;		     BITS 18 - 31 RESERVED, MUST BE ZERO
;		     ***** NOTE THAT ONLY SYSGBL AND PFNMAP ARE REQUIRED FOR
;		     ***** THIS SERVICE.
;	GSDNAM(AP) = ADDRESS OF DESCRIPTOR FOR GLOBAL SECTION NAME
;	IDENT(AP)  = ADDRESS OF QUAD WORD CONTAINING SECTION IDENTIFICATION
;		     FIRST LONG WORD CONTAINS THE MATCH CONTROL INFORMATION
;			0 = SEC$K_MATALL, MATCH ALWAYS
;			1 = SEC$K_MATEQU, MATCH IF IDENTS ARE EQUAL
;			2 = SEC$K_MATLEQ, MATCH IF HIGH 8 BITS ARE EQUAL
;			    AND LOW 24 BITS ARE LESS THAN OR EQUAL TO
;			    THE ID STORED IN THE GLOBAL SECTION.
;		     SECOND LONG WORD CONTAINS THE IDENT TO BE COMPARED
;	R4	   = PROCESS CONTROL BLOCK ADDRESS
;			  SET UP BY THE CHANGE MODE TO KERNEL DISPATCHER
;	IPL = ASTDEL IF CALLED AT MMG$DGBLSC1
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;	IPL PRESERVED WHEN CALLED AT MMG$DGBLSC1
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_IVSECFLG - INVALID SECTION FLAGS
;	SS$_NOPRIV - NO PRIVILEGE FOR ATTEMPTED OPERATION (PRMGBL)
;	SS$_NORMAL - SUCCESS
;	SS$_NOTCREATOR - NOT ON GLOBAL SECTION'S CREATOR PROCESSOR
;	SS$_IVLOGNAM - INVALID LOGICAL NAME
;	SS$_NOSUCHSEC - NO SUCH GLOBAL SECTION
;	SS$_IVSECIDCTL - INVALID SECTION MATCH IDENT CONTROL
;	SS$_ACCVIO - ACCESS VIOLATION
;	SS$_TOOMANYLNAM - TOO MANY LOGICAL NAMES (DEPTH > 10)
;	SS$_SHMNOTCNCT - SHARED MEM DATA STRUCTURES NOT CONNECTED TO LOCAL MEM
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;

	.ENABL	LSB

;
; NO PRIVILEGE TO DELETE A GLOBAL SECTION
;
PRIV_ERR:
	MOVZWL	#SS$_NOPRIV,R0		;NO PRIVILEGE FOR SPECIFIED OPERATION
	RET

MMG$DGBLSC1::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	MOVZBL	#1,R8			;INDICATE IMAGE ACTIVATOR DELETE REQUEST
	BRB	10$

;*************  EXE$DGBLSC  ENTRY POINT
	.ENTRY	EXE$DGBLSC,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	CLRL	R8			;INDICATE NORMAL $DGBLSC REQUEST
	IFNPRIV	PRMGBL,PRIV_ERR		;BR IF NO PRIVILEGE TO
					;CREATE/DELETE PERMANENT GLOBAL SECTIONS
10$:	SUBL	S^#-MMG$C_LENGTH,SP	;RESERVE SCRATCH AREA
	SAVIPL				;SAVE CALLER'S IPL ON STACK
	MOVL	FLAGS(AP),R0		;SECTION FLAGS
	BLBS	R8,15$			;BR IF IMAGE ACT. REQ., NO PRIV CHK
	BBC	#SEC$V_SYSGBL,R0,15$	;BR IS NOT TRYING TO DELETE SYSGBL GS
	IFNPRIV	SYSGBL,PRIV_ERR		;BR IF NO PRIV TO DELETE SYSGBL SECTION
15$:	BSBW	MMG$VFYSECFLG		;VERIFY SECTION FLAGS
	MOVL	R0,R6			;VERIFIED SECTION FLAGS TO R6
	MOVAL	L^EXE$GL_GSDMTX,R0	;MUTEX FOR GLOBAL SECTIONS
	JSB	SCH$LOCKW		;CLAIM THE MUTEX FOR WRITING
;
; RETURNS AT IPL = ASTDEL
;
	SUBL	#24,SP			;RESERVE SCRATCH FOR GSD NAME
	MOVL	SP,R7			;ADDRESS OF SCRATCH AREA

	ASSUME	IDENT EQ GSDNAM+4
	MOVQ	GSDNAM(AP),R0		;GET NAME AND IDENT ADDRESSES
	MOVL	R6,R9			;REMEMBER FLAGS FOR MMG$FINDGSNOTRN
	BSBW	MMG$GSDSCN		;FIND THE GLOBAL SECTION IF IT EXISTS
	BLBS	R0,20$			;BR IF GSD FOUND
	BSBW	MMG$FINDGSNOTRN		;CHECK IF THIS CRF SECTION NOT IN SH MEM
20$:	ADDL	#24,SP			;RETURN SCRATCH STORAGE
	BLBS	R0,25$			;BRANCH IF FOUND SECTION
	BRW	80$			;BRANCH IF SECTION DOESN'T EXIST
;
; R4 = SHARED MEMORY CONTROL BLOCK ADDRESS IF GLOBAL SECTION IS IN SH MEM
; R5 = SYSTEM PROCESS HEADER ADDRESS
; R6 = GLOBAL SECTION DESCRIPTOR BLOCK ADDRESS
; R10 IS   0 IF THE GSD WAS FOUND IN LOCAL MEMORY
;	  -1 IF THE LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES
;	  >1 IF A SPECIFIC SHARED MEMORY NAME WAS SPECIFIED
;
25$:	CVTWL	GSD$W_GSTX(R6),R1	;SECTION INDEX
	BEQL	30$			;BR IF GS NOT MAPPED TO A FILE
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R3 ;SECTION TABLE BASE ADDRESS
	MOVAL	(R3)[R1],R3		;SECTION ADDRESS
30$:	CMPB	GSD$B_TYPE(R6),#DYN$C_EXTGSD ;IS THIS A NORMAL GSD?
	BGTRU	SHMEM_DEL		;NO, BR AS IT IS A SHM GSD
	BEQL	NOT_MAP_TO_FILE		;NO, BR AS IT IS AN EXTENDED GSD
	REMQUE	(R6),R0			;REMOVE GSD FROM ITS LIST
	INSQUE	(R0),L^EXE$GL_GSDDELFL	;AND PLACE IT ON THE DELETE PENDING LIST
	BBCC	#SEC$V_PERM,GSD$W_FLAGS(R6),40$ ;CLEAR PERM, ALLOW DELETION
40$:	TSTL	R1			;IS THERE A SECTION TABLE ENTRY?
	BEQL	50$			;BR IF NO, NOT MAPPED TO A FILE
	BBCC	#SEC$V_PERM,SEC$W_FLAGS(R3),45$ ;CLEAR PERM, ALLOW DELETION
45$:	TSTL	SEC$L_REFCNT(R3)	;IF NO MORE REFERENCES
	BNEQ	50$			;INDICATE THAT THERE IS A SECTION
	BBSSI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),50$ ;TO BE DEALLOCATED
50$:	PUSHL	#SS$_NORMAL		;RECORD SUCCESS
;
; 0(SP) = SYSTEM STATUS CODE
; 4(SP) = SAVED CALLER' IPL
;
55$:	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS THERE A SHMGSD TO UNLOCK?
	BNEQ	60$			;BR IF OTHER TYPE OF GSD
	MOVZBL	#1,R0			;SET REFERENCE COUNT
	JSB	G^MMG$DECSHMREF		;RELEASE GSD SO CAN DISAPPEAR
60$:	BSBW	MMG$DALCSTXSCN		;SCAN FOR SECTIONS TO DEALLOCATE
	BSBW	MMG$GSDMTXULK		;UNLOCK THE GLOBAL SECTION MUTEX
	BSBW	MMG$DELGBLWCB		;DELETE ANY WCB'S ON WCBDEL QUEUE
	POPR	#^M<R0>			;RESTORE SYSTEM STATUS CODE
	ENBINT				;RESTORE CALLER'S IPL
	RET				;AND RETURN FROM SYSTEM SERVICE

;
; SECTION BEING DELETED IS IN SHARED MEMORY.  SEE IF PROCESS REQUESTING
; DELETION IS ON SAME PROCESSOR AS PROCESS THAT CREATED THE SECTION.
;
SHMEM_DEL:
	BLBS	R8,65$			;BR IF IMAGE ACT. REQ., NO PRIV CHK
	MOVL	@#CTL$GL_PHD,R9		;GET PHD OF CURRENT PROCESS
	BBS	#PRV$V_SHMEM,PHD$Q_PRIVMSK(R9),65$ ;BR IF HAVE PRIV FOR REQ
	MOVZWL	#SS$_NOPRIV,-(SP)	;REPORT NO PRIVILEGE FOR REQUEST
	BRB	55$			;BR ON NO PRIV TO DO REQUEST
65$:	TSTB	GSD$B_CREATPORT(R6)	;NON-EXISTENT CREATOR?
	BLSS	67$			;BRANCH IF NON-EXISTENT TO ALLOW DELETION
	CMPB	SHB$B_PORT(R4),GSD$B_CREATPORT(R6) ;IS THIS PROC THE CREATOR?
	BNEQ	70$			;BR IF IT IS NOT, CANNOT DELETE SECTION
67$:	BBSSI	#GSD$V_DELPEND,GSD$L_GSDFL(R6),40$ ;MARK THE GSD FOR DELETION
	BRB	40$			;BRANCH TO COMMON CODE
70$:	MOVZWL	#SS$_NOTCREATOR,-(SP)	;REPORT UNABLE TO DELETE SHM GLOB SEC
	BRB	55$			;BR TO REPORT ERROR CODE
;
; ERROR FROM THE GLOBAL SECTION DESCRIPTOR LIST SCAN
;
80$:	PUSHL	R0			;SAVE ERROR STATUS
	BRB	60$			;EXIT THROUGH THE UNLOCK CODE
;
; THIS IS AN EXTENDED GSD.  IT DOES NOT HAVE A CORRESPONDING SECTION TABLE
; ENTRY, I.E., A PFN-MAPPED SECTION.  THERE IS NO REFERENCE COUNT KEPT FOR
; A PFN-MAPPED SECTION, REQUIRING A DELAYED DELETION MECHANISM.
; SINCE THE GSD MUTEX IS BEING HELD FOR WRITE DURING THE $DGBLSC REQUEST,
; THERE IS NO RISK THAT ANY OTHER PROCESS IS ACCESSING THE GSD.
; THEREFORE, IT CAN BE DEALLOCATED TO PAGED POOL IMMEDIATELY.
;
NOT_MAP_TO_FILE:
	BLBS	R8,85$			;BR IF IMAGE ACT. REQ., NO PRIV CHK
	MOVL	@#CTL$GL_PHD,R9		;GET PHD OF CURRENT PROCESS
	BBS	#PRV$V_PFNMAP,PHD$Q_PRIVMSK(R9),85$ ;BR IF HAVE PRIV FOR REQ
	MOVZWL	#SS$_NOPRIV,R0		;REPORT NO PRIVILEGE FOR REQUEST
	BRB	80$			;BR ON NO PRIV TO DO REQUEST
85$:	REMQUE	(R6),R0			;REMOVE EXTENDED GSD FROM ACTIVE LIST
	BSBW	EXE$DEAPAGED		;DEALLOCATE EXTGSD TO PAGED POOL
	PUSHL	#SS$_NORMAL		;RECORD SUCCESS
	BRB	60$			; AND JOIN COMMON CODE

	.DSABL	LSB

	.SBTTL	GSDSCN - GLOBAL SECTION DESCRIPTOR SCANNER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SCANS THE GLOBAL SECTION DESCRIPTOR QUEUE FOR
; A SECTION WITH THE SPECIFIED NAME.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$GSDSCN
;
; INPUT PARAMETERS:
;
;	R0 = DESCRIPTOR ADDRESS OF GLOBAL SECTION NAME
;	R1 = ADDRESS OF QUAD WORD OF SECTION IDENT INFORMATION
;	R6 = SECTION FLAGS
;		IF SYSGBL IS SET SEARCH SYSTEM GLOBAL LIST
;		OTHERWISE SEARCH GROUP GLOBAL LIST
;	R7 = ADDRESS OF 24 BYTE SCRATCH AREA TO STORE THE
;		GLOBAL SECTION NAME IN COUNTED STRING FORMAT
;	GSD MUTEX IS LOCKED (FOR READ OR WRITE AS APPROPRIATE) BEFORE CALLING
;	IPL = ASTDEL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;	R4 = ADDRESS OF SHARED MEMORY CONTROL BLOCK, IF GSD IS IN SHARED MEMORY
;	R5 = SYSTEM PROCESS HEADER ADDRESS
;	R6 = GLOBAL SECTION DESCRIPTOR BLOCK ADDRESS IF FOUND
;	R10 = 0 IF GSD IS IN LOCAL MEMORY,
;	      -1 IF LOCAL MEMORY SEARCH EXTENDED INTO SHARED MEMORY TABLES,
;	      > 0 IF IN SHARED MEMORY
;
; IMPLICIT OUTPUTS:
;
;	GLOBAL SECTION NAME (ASCIC) IS RETURNED IN THE SCRATCH AREA.
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_IVLOGNAM			;INVALID NAME
;	SS$_IVSECIDCTL			;INVALID SECTION IDENT MATCH CONTROL
;	SS$_NOSUCHSEC			;NO SUCH (GLOBAL) SECTION
;	SS$_ACCVIO			;ACCESS VIOLATION
;
; SIDE EFFECTS:
;
;	NONE
;
;--

;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *****************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;

	.ENABL	LSB

BADNAME:
	MOVZWL	#SS$_IVLOGNAM,R0	;SET ERROR STATUS
	BRB	ERREXIT			;
BADIDENT:
	MOVZWL	#SS$_IVSECIDCTL,R0	;INVALID SECTION ID MATCH CONTROL
	BRB	ERREXIT
ACCVIO:
	MOVZBL	#SS$_ACCVIO,R0		;REPORT ACCESS VIOLATION
ERREXIT:
	CLRL	R10			;INDICATE LOCAL MEMORY ON ERROR
	BRW	35$

MMG$GSDSCN::
	PUSHR	#^M<R8,R9,R11>		;REMEMBER REGISTERS
	CLRQ	R2			;ASSUME NULL IDENT IFORMATION
	TSTL	R1			;0 ADDRESS MEANS NO IDENT TO MATCH
	BEQL	5$			;BRANCH IF NO IDENT
	IFNORD	#8,(R1),ACCVIO		;BRANCH IF CALLER CANNOT READ THE QUAD WORD
	MOVQ	(R1),R2			;GET THE IDENT INFORMATION
	CMPL	R2,#SEC$K_MATLEQ	;MATCH CONTROL OK?
	BGTR	BADIDENT		;BRANCH IF BAD
5$:	MOVQ	R2,16(R7)		;STORE IDENT INFO IN SCRATCH AREA
	IFNORD	#8,(R0),ACCVIO		;CHECK ACCESSABILITY OF DESCRIPTOR
	MOVZWL	(R0),R9			;GET SIZE OF STRING
	BEQL	BADNAME			;BR IF NO STRING SPECIFIED
	MOVL	4(R0),R10		;GET ADR OF INPUT GS STRING 
	ASSUME  LOG$C_NAMLENGTH LE 512
	CMPW	#<LOG$C_NAMLENGTH-1>,R9 ;IS NAME LONGER THAN MAXIMUM ALLOWED?
	BLSSU	BADNAME			;BR IF ILLEGAL NAME SIZE
	IFNORD	R9,(R10),ACCVIO		;CHK IF STRING ACCESSABLE
	MOVQ	R9,-(SP)		;MOVE INPUT GS DESC TO STACK
	MOVL	SP,R9			;GET ADDR
	MOVAB	1(R7),-(SP)		;SET ADR OF GS BUFFER IN STR DESC
	PUSHL	#15			;SET SIZE OF GS BUFFER IN STR DESC
	MOVL	SP,R11			;SET ADR OF GS DESC
	SUBL	#<4*4>,SP		;GRAB SHARED MEMORY NAME BUFFER
	MOVAB	1(SP),-(SP)		;SET ADR OF SH MEM BUFFER IN STR DESC
	PUSHL	#15			;SET SIZE OF SH MEM BUFFER IN STR DESC
	MOVL	SP,R10			;SET ADR OF SH MEM DESC
	BSBW	MMG$GETGSNAM		;GET GS AND SH MEM NAMES
	BLBS	R0,7$			;BR ON NAMES CORRECT
	CLRL	(R10)			;INDICATE LOCAL MEMORY
	BRB	ERROR_EXIT		;
7$:	DECL	4(R10)			;ADR OF ASCIC SH MEM NAME
	MOVB	(R10),@4(R10)		;MAKE SH MEM NAME INTO ASCIC STRING
	MOVB	(R11),(R7)		;MAKE GS NAME INTO ASCIC STRING
	BEQL	NO_GS_NAME		;ERROR, NO GS NAME SPECIFIED
	MCOML	#0,R8			;NEGATIVE ONE FOR SYSTEM GLOBAL
	EXTZV	#SEC$V_SYSGBL,#1,R6,R6	;SYSTEM GLOBAL BIT
	BNEQ	10$			;BRANCH IF SYSTEM GLOBAL
;
; GROUP GLOBAL SECTION SCAN - GET GROUP CODE FROM PCB
;
	MOVL	L^SCH$GL_CURPCB,R8	;PROCESS CONTROL BLOCK ADDRESS
	MOVZWL	PCB$W_GRP(R8),R8	;GROUP CODE TO MATCH
10$:	BSBW	MMG$FIND1STGSD		;POSITION POINTERS FOR GSD SEQ SEARCH
	BLBC	R0,ERROR_EXIT		;BR ON ERROR FINDING SPECIFIC SH MEM
	BRB	25$			;GO CHECK FIRST GSD
20$:	JSB	G^MMG$GETNXTGSD		;GET NEXT LOGICAL GSD ENTRY ADR
25$:	TSTL	R6			;WAS THERE ANOTHER GSD?
	BEQL	GS_NOT_FOUND		;BR ON NO MORE GSD'S
	CMPB	GSD$B_TYPE(R6),#DYN$C_SHMGSD ;IS THIS A SHARED MEM GSD?
	BNEQ	27$			;BR IF NOT SH MEM GSD
	BBS	#GSD$V_LOCKED,GSD$L_GSDFL(R6),20$ ;BR IF GS IS LOCKED FOR READ
	BBS	#GSD$V_DELPEND,GSD$L_GSDFL(R6),20$ ;BR IF GS IS MARKED FOR DELETE
27$:	BBS	#31,R8,30$		;BRANCH IF NOT COMPARING GROUP CODE
	CMPW	R8,GSD$W_PCBGRP(R6)	;DOES THIS SECTION BELONG TO THIS GROUP?
	BNEQ	20$			;BRANCH IF NOT, TRY NEXT GSD
30$:	CMPC3	#16,(R7),GSD$T_GSDNAM(R6) ;COUNT AND NAME MATCH?
	BNEQ	20$			;BRANCH IF NO, TRY NEXT GSD

	ASSUME	SEC$K_MATALL EQ 0
	ASSUME	SEC$K_MATEQU EQ 1
	ASSUME	SEC$K_MATLEQ EQ 2

	MOVL	16(R7),R0		;FETCH IDENT MATCH CONTROL
	BEQL	33$			;BRANCH IF ALWAYS MATCH
	CMPB	23(R7),GSD$L_IDENT+3(R6) ;DOES MAJOR ID MATCH
	BNEQ	20$			;BRANCH IF NOT
	CMPL	20(R7),GSD$L_IDENT(R6)	;NOW COMPARE ENTIRE LONG WORD
	BGTRU	20$			;IF LARGER, THEN NO MATCH
	BLBC	R0,33$			;BRANCH IF EXACT MATCH NOT REQUIRED
	BNEQ	20$			;BRANCH IF NOT AN EXACT MATCH
33$:	MOVZWL	#SS$_NORMAL,R0		;INDICATE GSD FOUND
ERROR_EXIT:
	MOVL	(R10),R10		;SET INDICATOR IF GS IS IN SHMEM
34$:	ADDL	#<10*4>,SP		;CLEAN OFF GS DESC,SHM DESC AND BUFFER
35$:	POPR	#^M<R8,R9,R11>		;RESTORE REGISTERS
	MOVAL	@L^MMG$GL_SYSPHD,R5	;SYSTEM PROCESS HEADER ADDRESS
	RSB				;AND RETURN
NO_GS_NAME:
	MOVZWL	#SS$_IVLOGNAM,R0	;INDICATE NO GS NAME SPECIFIED
	BRB	ERROR_EXIT		;RETURN
GS_NOT_FOUND:
	MOVZWL	#SS$_NOSUCHSEC,R0	;INDICATE GSD NOT FOUND
	BRB	ERROR_EXIT		;RETURN

	.DSABL	LSB

	.SBTTL	DELGBLSEC - DELETE GLOBAL SECTION SUBROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DELGBLSEC
;
; INPUT PARAMETERS:
;
;	R1 = GLOBAL SECTION TABLE INDEX
;	R3 = GLOBAL SECTION TABLE ADDRESS
;	R5 = SYSTEM PROCESS HEADER ADDRESS
;
;	IPL = ASTDEL
;	GLOBAL SECTION MUTEX LOCKED FOR WRITING
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;

DELGBLSEC_BUG:
	BUG_CHECK DELGBLSEC,FATAL	;BAD MASTER PTE FORMAT FOR THIS CONTEXT

MMG$DELGBLSEC::
	MOVL	SEC$L_GSD(R3),R2	;GET ADR OF GLOBAL SECTION DESCRIPTOR
	BEQL	10$			;BRANCH IF PARTIALLY CREATED (NO GSD)
	REMQUE	(R2),R2			;REMOVE GSD FROM NORMAL LIST
	INSQUE	(R2),L^EXE$GL_GSDDELFL	;PUT GSD ON DELPEND LIST, PROHIBIT USE
10$:	MOVL	SEC$L_PAGCNT(R3),R0	;NUMBER OF PAGES IN SECTION
	BEQL	75$			;CHECK FOR INCOMPLETE SECTION
	PUSHR	#^M<R0,R1,R3>		;PUSH SECTION ADR, INDEX, PAGE COUNT
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,-	;FIRST GLOBAL PAGE TABLE INDEX
		SEC$L_VPXPFC(R3),R3	;
	MOVAL	@W^MMG$GL_GPTBASE[R3],R3 ;ADDRESS OF FIRST GPTE
	PUSHR	#^M<R0,R3>		;PUSH 1ST GPTE ADR, GPTE COUNT
;
; 0(SP)  = COUNT OF GPTE'S
; 4(SP)  = FIRST GPTE ADDRESS
; 8(SP)  = COUNT OF GPTE'S
; 12(SP) = GLOBAL SECTION INDEX
; 16(SP) = GLOBAL SECTION ADDRESS
;
	SETIPL	#IPL$_SYNCH		;RAISE TO SYNCH FOR THIS SCAN
;
; THE FOLLOWING SCAN OF THE GLOBAL PAGE TABLE ENTRIES IS DONE TO ELIMINATE
; ALL TRANSITION PAGES POINTING AT THE GPTE'S.
;
20$:	BICL3	#^C<PTE$M_VALID ! -	;GET THE VALID BIT
		PTE$M_TYP1 ! PTE$M_TYP0 ! - ;PTE TYPE BITS
		PTE$M_GPTX>,(R3)+,R0	;AND PFN/GPTX BITS FROM THE PTE
	BEQL	40$			;DZRO
	BLSS	DELGBLSEC_BUG		;BRANCH IF INCONSISTENT
	ASHL	#-PTE$V_TYP0,R0,R1	;ONLY TYPE BITS LEFT, RIGHT ADJUSTED
	BNEQ	40$			;BRANCH IF NOT A TRANSITION PAGE
	ASSUME	PFN$C_FREPAGLST EQ 0
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,-	;GET THE PAGE'S LOCATION
		@W^PFN$AB_STATE[R0],R2	;
	BNEQ	100$			;IF NOT ON FREE LIST, WAIT UNTIL IT IS
	PUSHL	R3			;SAVE REGISTERS AROUND THE FOLLOWING
	BSBW	MMG$DELPFNLST		;DELETE PAGE FROM PFN LIST
	POPR	#^M<R3>			;RESTORE REGISTERS
40$:	SOBGTR	(SP),20$		;ONCE FOR EACH GLOBAL PAGE TABLE ENTRY
	TSTL	(SP)+			;CLEAN OFF EXHAUSTED COUNT
	MOVL	(SP),R3			;1ST GPTE ADDRESS
	MOVL	4(SP),R0		;COUNT OF GPTE'S
;
; THE SECOND SCAN OF THE GLOBAL PAGE TABLE ENTRIES IS DONE TO DECREMENT
; THE GLOBAL PAGE TABLE REFERENCE COUNT AND TO RELEASE PAGING FILE
; BACKING STORE.  THIS WAS NOT DONE IN THE PREVIOUS SCAN BECAUSE THAT
; SCAN REQUIRED THAT THERE BE NO SIDE EFFECTS SO THAT IT COULD FAIL
; AND BE RESTARTED.
;
60$:	BBS	#PTE$V_TYP0,(R3),70$	;BRANCH IF NOT PAGING FILE BACKING STORE
	PUSHR	#^M<R0,R3>		;SAVE REGISTER AROUND THE FOLLOWING
	EXTZV	#PTE$V_PGFLVB,#PTE$S_PGFLVB,(R3),R0 ;GET PAGE VBN TO DEALLOCATE
	BEQL	65$			;DZRO
	MOVZBL	PHD$B_PAGFIL(R5),R3	;INDEX OF SYSTEM PAGING FILE
	BSBW	MMG$DALCPAGFIL		;DEALLOCATE PAGING FILE
65$:	POPR	#^M<R0,R3>		;RESTORE REGISTERS
70$:	BSBW	MMG$DECPTREF		;ONE LESS PAGE TABLE REFERENCE
	CLRL	(R3)+			;DELETE THE GPTE
	SOBGTR	R0,60$			;NEXT GPTE
;
;  0(SP) = FIRST GPTE ADDRESS
;  4(SP) = COUNT OF GPTE'S
;  8(SP) = GLOBAL SECTION INDEX
; 12(SP) = GLOBAL SECTION ADDRESS
;
	SETIPL	#IPL$_ASTDEL		;BACK TO CALLED IPL
	SUBL3	#4,(SP)+,R0		;ADDRESS OF FRONT STOPPER FOR THIS SECTION
	ADDL3	#3,(SP)+,R1		;GPTE COUNT + 2 FOR STOPPERS + 1 TO ROUND EVEN
	BICL	#1,R1			;ROUND TO EVEN NO. OF GPTE'S
	MULL	#4,R1			;NO. OF BYTES OF GPTE TO RELEASE
	MOVAL	W^EXE$GL_GPT,R3		;TO GPT FREE POOL
	BSBW	EXE$DEALLOCATE		;RELEASE THEM
	POPR	#^M<R1,R3>		;R1=SECTION INDEX, R3=SECTION ADDRESS
75$:	MOVL	SEC$L_WINDOW(R3),R0	;GET WCB ADDRESS FOR SECTION
	BEQL	120$			;IF NO WINDOW, SKIP ALL THIS STUFF
	BBC	#WCB$V_SHRWCB,WCB$B_ACCESS(R0),80$ ;BRANCH IF NOT SHARED WINDOW
	DECW	WCB$W_REFCNT(R0)	;LAST REFERENCE ON SHARED WINDOW?
	BGTR	90$			;BRANCH IF NOT
80$:	CLRW	WCB$W_NMAP(R0)		;NO RETRIEVAL POINTERS

	ASSUME	WCB$W_P1_COUNT&3 EQ 0	;STARTS AT LONG WORD OFFSET
	INSQUE	WCB$W_P1_COUNT(R0),W^EXE$GL_WCBDELFL ;QUEUE WINDOW ON WCB DELETE LIST

	ASSUME	SEC$L_GSD EQ 0		;1ST LONG WORD IN SECTION IS GSD ADDRESS
90$:	MOVL	(R3),R0			;GET GSD ADDRESS
	BEQL	95$			;BRANCH IF NONE
	REMQUE	(R0),R0			;REMOVE GLOBAL SECTION DESCRIPTOR
					;FROM GSD ACTIVE LIST
	INSQUE	(R0),@W^EXE$GL_GSDFREBL	;AND PLACE IT ON THE FREE LIST
95$:	JMP	MMG$DALCSTX		;DEALLOCATE THE GLOBAL SECTION INDEX
					;AND RETURN
;
; PAGE IS IN TRANSITION STATE.  IT IS GUARANTEED TO END UP ON THE FREE PAGE
; LIST WHEN WHATEVER IS GOING ON IS COMPLETED
;
100$:	CLRL	W^SCH$GL_MFYLOLIM	;FORCE THE MODIFIED PAGE WRITER TO
	CLRW	W^SCH$GL_MFYLIM		;START, TO GET PAGES ON FREE LIST
	SETIPL	#IPL$_ASTDEL		;BACK TO CALLER'S IPL
	ADDL	#5*4,SP			;CLEAN UP THE STACK
	BBSSI	#PHD$V_DALCSTX,PHD$W_FLAGS(R5),110$ ;SECTION STILL TO BE DEALLOCATED
110$:	RSB				;AND RETURN
;
; Add page count to the global section page file limit
;
120$:	ADDL2	SEC$L_PAGCNT(R3),MMG$GL_GBLPAGFIL
	BRB	90$

	.SBTTL	DELGBLWCB - DELETE GLOBAL WINDOW CONTROL BLOCKS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE REMOVES ANY WINDOW CONTROL BLOCKS FROM THE WCBDEL
; LIST AND DEACCESSES THE FILES BY FILLING IN A CHANNEL AND DEASSIGNING IT
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$DELGBLWCB
;
; INPUT PARAMETERS:
;
;	R4 = PCB ADDRESS OF PROCESS
;	IPL = ASTDEL, MAY BE LOWERED TO 0 FOR A WHILE, BUT RETURNS AT ASTDEL
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
;--
;
; **********************************************************************
;
; **************** THE FOLLOWING CODE MAY BE PAGED *********************
;
	.PSECT	Y$EXEPAGED
;
; **********************************************************************
;

MMG$DELGBLWCB::
	TSTW	PCB$W_MTXCNT(R4)	;DOES THE PROCESS OWN ANY MUTEXES?
	BNEQ	15$			;BR IF IT DOES, CAN'T CALL ANY SYS SRV
10$:	REMQUE	@L^EXE$GL_WCBDELFL,R3	;GET NEXT WCB TO DEACCESS
	BVC	20$			;BRANCH IF GOT ONE
15$:	RSB				;NO MORE ON THE LIST
20$:	SUBL	#WCB$W_P1_COUNT,R3	;ADDRESS OF WINDOW CONTROL BLOCK
	BSBW	IOC$FFCHAN		;FIND A FREE CHANNEL
	BLBC	R0,40$			;BRANCH IF NONE AVAILABLE
;
; R1 = CHANNEL NUMBER
; R2 = CCB ADDRESS
;
	MOVL	PCB$L_JIB(R4),R0	;GET ADDRESS OF JOB INFORMATION BLOCK
	TSTW	JIB$W_FILCNT(R0)	;CAN WE CHARGE HIM FOR A FILE?
	BEQL	40$			;BRANCH IF NOT
	DECW	JIB$W_FILCNT(R0)	;CHARGE FOR THIS FILE
	MOVL	WCB$L_ORGUCB(R3),R0	;UCB ADDRESS FROM WINDOW
	INCW	UCB$W_REFC(R0)		;COUNT A REFERENCE AND
	MOVL	R0,CCB$L_UCB(R2)	;PUT IT IN THE CHANNEL
	MOVL	R3,CCB$L_WIND(R2)	;PUT WINDOW IN CHANNEL
	INCB	CCB$B_AMOD(R2)		;ASSIGN CHANNEL IN KERNEL MODE
	BBC	#WCB$V_SHRWCB,WCB$B_ACCESS(R3),30$ ;IF SHARED WINDOW
	INCW	WCB$W_REFCNT(R3)	;COUNT A REFERENCE

30$:	SETIPL	#0			;DROP TO IPL 0
	$DASSGN_S R1			;DEASSIGN CHANNEL (THUS DEACCESSING FILE)
	SETIPL	#IPL$_ASTDEL		;BACK TO ASTDEL
	BRB	10$			;GO GET ANOTHER WCB IF ANY MORE
;
; R3 = WCB ADDRESS, PUT IT BACK ON THE WCBDEL QUEUE
;
40$:	INSQUE	WCB$W_P1_COUNT(R3),L^EXE$GL_WCBDELFL ;RE-QUEUE THE WCB
	RSB				;AND RETURN


	.END
