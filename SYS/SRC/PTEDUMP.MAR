	.TITLE	PTEDUMP - DUMP PTE AND PFN DATA BASE
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: USER MODE MEMORY MANAGEMENT DIAGNOSTIC ROUTINE
;
; ABSTRACT:
;
; ENVIRONMENT: REQUIRES READABILITY OF KERNEL DATA BASES
;
;--
;
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 19-OCT-76
;
; MODIFIED BY:
;	, : VERSION
; 01	 -

	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PTEDEF				;PAGE TABLE ENTRY DEFINTIONS
	$SSDEF				;SYSTEM STATUS DEFINTIONS
	$VADEF				;VIRTUAL ADDRESS DEFINITIONS
	$WSLDEF				;WORKING SET LIST DEFINITIONS
;
; EXTERNAL SYMBOLS:
;

;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
;    OFFSETS FROM AP
;
	PARAMCNT	=	0	;PARAMETER COUNT
	VA		=	4	;VIRTUAL ADDRESS
	ADRBYTECNT	=	8	;ADR OF RETURN BYTE COUNT
	OUTSTRING	=	12	;ADR OF OUTPUT STRING DESCRIPTOR
	PROCESSINDEX	=	16	;PROCESS INDEX
	PTEADR		=	16	;PAGE TABLE ENTRY ADDRESS
	PHDADR		=	20	;PROCESS HEADER ADDRESS
	PFNBASE		=	24	;BASE OF PFN DATA
	MAXPAGCNT	=	28	;SGN$C_MAXPAGCNT
					;NO. OF PAGES COVERED BY PFN DATA BASE
;
;    OFFSETS FROM FP
;
	FAOARG		=	-4	;FAO ARGUMENT LIST POINTER
	PTEINDEX	=	-8	;SAVED INDEX TO PAGE TABLE ENTRY
;
; OWN STORAGE:
;
	.PSECT	YEXEPAGED		;PAGED PSECT

	.SBTTL	TABLES AND CONTROL STRINGS
;
; PROTECTION CODE TABLE
;
PROTECTIONTBL:
	.ASCII	/NA  /
	.ASCII	/****/
	.ASCII	/KW  /
	.ASCII	/KR  /
	.ASCII	/UW  /
	.ASCII	/EW  /
	.ASCII	/ERKW/
	.ASCII	/ER  /
	.ASCII	/SW  /
	.ASCII	/SREW/
	.ASCII	/SRKW/
	.ASCII	/SR  /
	.ASCII	/URSW/
	.ASCII	/UREW/
	.ASCII	/URKW/
	.ASCII	/UR  /
;
; OWNER FIELD
;
OWNERTBL:
	.ASCII	/KESU/
;
; PAGE TABLE ENTRY TYPE
;
PTETYPETBL:
	.ASCII	/TRANS/
	.ASCII	/GPTX /
	.ASCII	/PGFIL/
	.ASCII	/STX  /
	.ASCII	/DZRO /
	.ASCII	/VALID/
	.ASCII	/IOPAG/
;
; MODIFY FLAG TABLE
;
MODIFYTBL:
	.ASCII	/ M/
;
; LOCKED IN WORKING SET LIST TABLE

WSLOCKTBL:
	.ASCII	/ L/
;
; FAO CONTROL STRINGS
;
PTECTL:
	.ASCII	/!XL !XL (!AD !AD !AD !AD !AD)/
	PTECTLSIZ=.-PTECTL

	.ASCII	/ !XB !XB !5UW !XL !XL !XW !XW/
	PFNCTLSIZ=.-PTECTL
MMG$PTEDUMPHDR::
	.BYTE	20$-10$
10$:
	.ASCII	$   VA         PAGE TABLE ENTRY       $
	.ASCII	$ STS   REF    BAK     SVAPTE  BLNK FLNK$
20$:

	.SBTTL	MMG$PTEDUMP - DUMP PTE AND PFN DATA BASE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE FORMATS A SINGLE LINE (WITH NO LEADING OR TRAILING
; CR,LF) INTO THE BUFFER SPECIFIED BY THE ADDRESS OF A STRING DESCRIPTOR
; THE TEXT DESCRIBES THE PAGE TABLE ENTRY AND ITS PFN DATA BASE IF ANY
; FOR THE SPECIFIED VA IN THE SPECIFIED PROCESS.
;
;
; CALLING SEQUENCE:
;
;	CALLG	ARGPTR,MMG$PTEDUMP
;
; INPUT PARAMETERS:
;
;	VA(AP)		=	VIRTUAL ADDRESS
;	ADRBYTECNT(AP)	=	ADDRESS TO RETURN SIZE IN BYTES OF OUTPUT STRING
;	OUTSTRING(AP)	=	DESCRIPTOR OF OUTPUT STRING
;	PROCESSINDEX(AP)=	PROCESS INDEX IN LOW 16 BITS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS
;	@ADRBYTECNT(AP) = SIZE OF STRING FORMATTED OR 0 IF NOTHING DONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;	SS$_LENVIO			;LENGTH VIOLATION
;					;VA IS OFF THE END OF THE PAGE TABLE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

MMG$PTEDUMP::
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	MOVL	VA(AP),R2		;VIRTUAL ADDRESS
	MOVZWL	PROCESSINDEX(AP),R0	;GET THE PROCESS INDEX
	MOVZWL	#SGN$C_PHDPAGCNT@7,R1	;OFFSET FROM PHD TO P0PT
					;ASSUMING P0 SPACE VIRTUAL ADDRESS
	CMPL	R0,#MMG$C_SYSPIX	;LEGAL?
	BGTR	40$			;BRANCH IF NO, SAY NO PAGES
	BLSS	10$			;BRANCH IF NOT SYSTEM PCB
	MOVZWL	#MMG$C_SYSPHDLEN@-2,R1	;OFFSET FROM SYSPHD TO SYSPT
	BBSS	#31,R2,10$		;JAM SYSTEM BIT IN VIRTUAL ADR
10$:
	MOVL	SCH$AL_PCB[R0],R4	;GET PCB ADDRESS
;
; R4 = PCB ADDRESS, R2 = VIRTUAL ADDRESS, R1 = P0 OR SYSTEM SPACE OFFSET
; ALL PROCESS HEADER REFERENCES MUST INDIRECT THROUGH PCB SINCE THIS
; CODE IS SWAPPABLE.
;
	EXTV	#VA$V_VPN,#VA$S_VPN+1,R2,R3 ;SIGN EXTENDED VIRT PAGE NUMBER
					;INCLUDING P1 SPACE BIT
	BLSS	20$			;BRANCH IF P1 SPACE
	MOVZBL	#PHD$L_FREP0VA@-2,R0	;LONG WORD INDEX TO FREP0VA
	CMPL	R2,@PCB$L_PHD(R4)[R0]	;ADR BEYOND END OF P0 SPACE
	BLSSU	30$			;BRANCH IF NOT LENGTH VIOLATION
	BRB	40$
;
; P1 SPACE VIRTUAL ADDRESS
;
20$:	MOVZBL	#PHD$L_FREP1VA@-2,R0	;LONG WORD INDEX TO FREP1VA
	CMPL	R2,@PCB$L_PHD(R4)[R0]	;OFF THE END OF P1 SPACE?
	BLEQU	40$			;BRANCH IF YES, LENGTH VIOLATION
	MOVZWL	#<SGN$C_PHDPAGCNT+SGN$C_PTPAGCNT>@7,R1 ;OFFSET TO P1PT END
30$:	ADDL	R1,R3			;INDEX TO PTE
	MOVAL	PCB$L_PHD(R4),R5	;POINTER TO PROCESS HEADER ADDRESS
	MOVAL	PFN$A_BASE,R6		;BASE OF PFN DATA
	MOVL	#SGN$C_MAXPAGCNT,R7	;NO. OF PAGES COVERED BY PFN DATA BASE
	BRB	FORMATPTE		;GO FORMAT THE PAGE TABLE ENTRY
40$:	MOVZWL	#SS$_LENVIO,R0		;LENGTH VIOLATION
	BRB	NULLSTRING

	.SBTTL	SDA$PTEDUMP - DUMP PTE AND PFN DATA BASE

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE FORMATS A SINGLE LINE (WITH NO LEADING OR TRAILING
; CR,LF) INTO THE BUFFER SPECIFIED BY THE ADDRESS OF A STRING DESCRIPTOR
; THE TEXT DESCRIBES THE PAGE TABLE ENTRY AND ITS PFN DATA BASE IF ANY
; FOR THE SPECIFIED VA.
;	IT PROVIDES THE SYSTEM DUMP ANALYZER WITH A STANDARD FORMATTING
; ROUTINE WHICH IS INDEPENDENT OF SYSTEM GENERATION DIFFERENCES.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGPTR,SDA$PTEDUMP
;
; INPUT PARAMETERS:
;
;	VA(AP)		=	VIRTUAL ADDRESS
;	ADRBYTECNT(AP)	=	ADDRESS TO RETURN SIZE IN BYTES OF OUTPUT STRING
;	OUTSTRING(AP)	=	DESCRIPTOR OF OUTPUT STRING
;	PTEADR(AP)	=	PAGE TABLE ENTRY ADDRESS
;	PHDADR(AP)	=	PROCESS HEADER ADDRESS
;	PFNBASE(AP)	=	PFN$A_BASE - BASE ADDRESS OF PFN DATA BASE
;	MAXPAGCNT(AP)	=	SGN$C_MAXPAGCNT - PAGES COVERED BY PFN DATA BASE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS
;	@ADRBYTECNT(AP) = SIZE OF STRING FORMATTED OR 0 IF NOTHING DONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			;SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;
;	NONE
;
;--

SDA$PTEDUMP::
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	MOVL	VA(AP),R2		;VIRTUAL ADDRESS
	SUBL3	PHDADR(AP),PTEADR(AP),R3 ;FORM INDEX TO PAGE TABLE ENTRY
	ASHL	#-2,R3,R3		;LONG WORD INDEX
	MOVAL	PHDADR(AP),R5		;POINTER TO PROCESS HEADER ADDRESS
	MOVL	PFNBASE(AP),R6		;BASE ADR OF PFN DATA BASE
	MOVL	MAXPAGCNT(AP),R7	;PAGE COUNT COVERED BY PFN DATA BASE
;
; FALL THROUGH TO FORMAT PTE
;

	.SBTTL	FORMAT THE PAGE TABLE ENTRY
;
; R2 = VIRTUAL ADDRESS
; R3 = LONG WORD INDEX TO PAGE TABLE ENTRY
; R5 = POINTER TO PROCESS HEADER ADDRESS
; R6 = BASE OF PFN DATA ARRAY
; R7 = NO. OF PAGES COVERED BY THE PFN DATA BASE
;
	.ENABL	LSB
FORMATPTE:
	SUBL3	#21*4,FP,SP		;RESERVE FAO PARAMETER BUFFER
	MOVL	SP,FAOARG(FP)		;AND SAVE ITS ADDRESS
	MOVL	R3,PTEINDEX(FP)		;SAVE INDEX TO PTE
	MOVL	SP,R4			;R4 USED TO STORE FAO PARAMS
;
; SET UP TO CONVERT VA, PTE, AND FORMATTED PTE
;
	MOVL	R2,(R4)+		;VIRTUAL ADDRESS
	MOVL	@(R5)[R3],R3		;R3 = PAGE TABLE ENTRY
	BNEQ	30$			;BRANCH IF NOT DELETED
	MOVZWL	#SS$_NORMAL,R0		;NO OUTPUT FOR 0 PTE'S
NULLSTRING:
	CLRL	@ADRBYTECNT(AP)		;RETURN STRING IS 0 BYTES
	RET
30$:
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R3,R0 ;R0 = PFN IF PRESENT
	MOVL	#5,R1			;ASSUME VALID PTE TYPE
	MOVL	R3,(R4)+		;CONVERT PTE IN HEX
	BGEQ	45$			;BRANCH IF NOT VALID
	CMPL	R0,R7			;LEGAL PFN?
	BLSS	60$			;YES, VALID PAGE
	INCL	R1			;ASSUME IT'S AN I/O PAGE
	BRB	50$			;AND SAY NO PFN
45$:
	EXTZV	#PTE$V_TYP0,#1,R3,R1	;FORM THE PTE TYPE CODE
	BBC	#PTE$V_TYP1,R3,40$	;IF TYPE BIT 1 IS 0 BRANCH
	BISL	#2,R1			;SET HIGH ORDER TYPE BIT
40$:
	TSTL	R1			;TYPE 0 IS TRANSITION OR DZRO
	BNEQ	50$			;BRANCH IF NOT TYPE 0
	TSTL	R0			;PFN = 0 IF DZRO
	BNEQ	60$			;BRANCH IF TRANSITION
	MOVL	#4,R1			;TYPE CODE FOR DZRO
50$:
	MNEGL	#1,R0			;NO PFN IN THIS PTE
;
; R1 = PTE TYPE CODE, SEE TABLE, R0 = PFN OR -1 IF NONE
;
60$:
	MULL	#5,R1			;PTE TYPE CODE IS 5 CHARS WIDE
	MOVL	#5,(R4)+		;SIZE OF PTE TYPE STRING
	MOVAB	PTETYPETBL[R1],(R4)+	;ADR OF PTE TYPE STRING
	CLRQ	R1			;ASSUME NO MODIFY OR LOCK BITS
	BBC	#PTE$V_VALID,R3,70$	;BRANCH IF PTE NOT VALID
	EXTZV	#PTE$V_MODIFY,#1,R3,R1	;GET MODIFY BIT FROM PTE
	BBS	#31,R0,70$		;BRANCH IF NO PFN
	BBS	#31,@FAOARG(FP),70$	;BRANCH IF SYSTEM ADDRESS
	MULL3	S^#PFN$C_WSLX,R7,R2	;BYTE OFFSET TO WSLX ARRAY
	ADDL	R6,R2			;BYTE ADDRESS OF WSLX ARRAY
	MOVZWL	(R2)[R0],R2		;WORKING SET LIST INDEX
	BEQL	70$			;BRANCH IF NOT A WSL INDEX
	MOVL	@(R5)[R2],R2		;WORKING SET LIST ENTRY
	EXTZV	#WSL$V_WSLOCK,#1,R2,R2	;WORKING SET LIST LOCK BIT
70$:
	MOVL	#1,(R4)+		;SIZE OF MODIFY STRING
	MOVAB	MODIFYTBL[R1],(R4)+	;ADR OF MODIFY STRING
	MOVL	#1,(R4)+		;SIZE OF WRK SET LOCK STRNG
	MOVAB	WSLOCKTBL[R2],(R4)+	;ADR OF WRK SET LOCK STRING

	EXTZV	#PTE$V_PROT,#PTE$S_PROT,R3,R1 ;R1 = PROTECTION CODE
	MOVL	#4,(R4)+		;SIZE OF PROTECTION STRING
	MOVAL	PROTECTIONTBL[R1],(R4)+	;ADR OF PROTECTION STRING

	EXTZV	#PTE$V_OWN,#PTE$S_OWN,R3,R1 ;R1 = OWNER OF PTE
	MOVL	#1,(R4)+		;SIZE OF OWNER STRING
	MOVAB	OWNERTBL[R1],(R4)+	;ADR OF OWNER STRING
;
; NOW SET UP TO CONVERT THE PFN DATA BASE IF ANY
;
	PUSHAL	PTECTL			;FORM CONTROL STRING DESCRIPTOR
	PUSHL	#PTECTLSIZ		;ON THE STACK
	MOVL	SP,R1			;R1 = ADDRESS OF STRING DESCR
	BBS	#31,R0,80$		;BRANCH IF NO PFN
	MOVZBL	#PFNCTLSIZ,(R1)		;INCLUDE PFN CONTROL STRING
	MULL3	S^#PFN$C_STATE,R7,R2	;BYTE OFFSET TO STATE ARRAY
	ADDL	R6,R2			;ADDRESS OF STATE ARRAY
	MOVZBL	(R2)[R0],(R4)+		;STATE BYTE
	MULL3	S^#PFN$C_TYPE,R7,R2	;BYTE OFFSET TO TYPE ARRAY
	ADDL	R6,R2			;ADDRESS OF TYPE ARRAY
	MOVZBL	(R2)[R0],(R4)+		;TYPE BYTE
	MULL3	S^#PFN$C_REFCNT,R7,R2	;BYTE OFFSET TO REFCNT ARRAY
	ADDL	R6,R2			;ADDRESS OF REFCNT ARRAY
	MOVZWL	(R2)[R0],(R4)+		;REFERENCE COUNT
	MULL3	S^#PFN$C_BAK,R7,R2	;BYTE ADDRESS OF BACKING STORE ARRAY
	ADDL	R6,R2			;ADDRESS OF BACKING STORE ARRAY
	MOVL	(R2)[R0],(R4)+		;BACKING STORE ADDRESS
	MULL3	S^#PFN$C_PTE,R7,R2	;BYTE OFFSET TO PTE ARRAY
	ADDL	R6,R2			;ADDRESS OF PTE ARRAY
	MOVL	(R2)[R0],(R4)+		;PTE POINTER
	MULL3	S^#PFN$C_BLINK,R7,R2	;BYTE OFFSET TO BLINK ARRAY
	ADDL	R6,R2			;ADDRESS OF BLINK ARRAY
	MOVZWL	(R2)[R0],(R4)+		;BACK LINK
	MULL3	S^#PFN$C_FLINK,R7,R2	;BYTE OFFSET TO FLINK ARRAY
	ADDL	R6,R2			;ADDRESS OF FLINK ARRAY
	MOVZWL	(R2)[R0],(R4)+		;FORWARD LINK
80$:
	MOVL	R3,R0			;PAGE TABLE ENTRY CONTENTS
	MOVL	PTEINDEX(FP),R3		;INDEX TO PAGE TABLE ENTRY
	CMPL	@(R5)[R3],R0		;STILL THE SAME PTE?
	BEQL	90$			;BRANCH IF YES
	MOVL	VA(AP),R2		;MUST RETRY, GET VA
	BRW	FORMATPTE		;START OVER AGAIN
90$:
	$FAOL_S	(R1),@ADRBYTECNT(AP),@OUTSTRING(AP),@FAOARG(FP)
	RET

	.DSABL	LSB


	.END
