
	.TITLE	BUFFERCTL - I/O BUFFER CONTROL
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 9-AUG-76
;
; MODIFIED BY:
;
;	04	STJ0002		S. JEFFREYS		29-FEB-1980
;	ADD ALTERNATE ENTRY POINTS FOR IOC$MOVTOUSER AND IOC$MOVFRUSER.
;
;	03	STJ0001		S. JEFFREYS		26-SEP-1979
;	MODIFY IOC$PUTBYTE AND IOC$GETBYTE TO WORK CORRECTLY FOR
;	BUFFERS THAT ARE PAGE ALIGNED.
;
;	02	CAM001		C. MONIA		15-FEB-1979
;	ADD IOC$PUTBYTE AND IOC$GETBYTE ROUTINES FOR TU-58 SUPPORT
;
;
; I/O BUFFER CONTROL ROUTINES
;
; MACRO LIBRARY CALLS
;
 
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$UCBDEF				;DEFINE UCB OFFSETS
	.PAGE
	.SBTTL	GET ONE BYTE OF DATA FROM USER BUFFER
;+
; IOC$GETBYTE - GET ONE BYTE OF DATA FROM USER'S BUFFER
;
; THIS ROUTINE IS CALLED BY AN I/O DRIVER TO GET A SINGLE BYTE  FROM THE
; USER'S BUFFER.
;
; PRIOR TO CALLING THIS ROUTINE, A CALL TO IOC$INITBUFWIND MUST BE MADE TO
; MAP THE SYSTEM PAGE TABLE ENTRY INTO THE USER'S BUFFER
;
; INPUTS:
;
;	R0 = SYSTEM VIRTUAL ADDRESS OF ONE-PAGE WINDOW INTO USER'S BUFFER.
;	R5 = ADDRESS OF UCB.
;
; OUTPUTS:
;
;	R0 = UPDATED SYSTEM VIRTUAL ADDRESS
;	R1 = ONE BYTE OF DATA (ZERO EXTENDED)
;
;	UCB$L_SVAPTE IS UPDATED WHENEVER A PAGE BOUNDARY IS CROSSED
;
; THE DRIVER IS EXPECTED TO SAVE THE VALUE OF R0 FOR SUBSEQUENT CALLS.
;
;-
 
	.PSECT	WIONONPAGED
 
IOC$GETBYTE::				;
	MOVB	(R0)+,R1		;GET BYTE FROM USER'S BUFFER
	BITW	#^X01FF,R0		;OVERFLOW PAGE BOUNDARY?
	BNEQ	10$			;IF NEQ NO
	ADDL	#4,UCB$L_SVAPTE(R5)	;UPDATE ADDRESS OF PROCESS PTE
	BSBB	IOC$FILSPT		;FILL SPT, COMPUTE SYSTEM ADDRESS OF PAGE
10$:	RSB				;RETURN
	.PAGE
	.SBTTL	PUT ONE BYTE OF DATA INTO USER'S BUFFER
;+
; IOC$PUTBYTE - PUT ONE BYTE OF DATA IN USER'S BUFFER
;
; THIS ROUTINE IS CALLED BY AN I/O DRIVER TO PUT A SINGLE BYTE OF DATA
; INTO THE USER'S BUFFER.
;
; PRIOR TO CALLING THIS ROUTINE, A CALL TO IOC$INITBUFWIND MUST BE MADE TO
; MAP THE SYSTEM PAGE TABLE ENTRY INTO THE USER'S BUFFER.
;
; INPUTS:
;
;	R0 = SYSTEM VIRTUAL ADDRESS OF ONE-PAGE WINDOW INTO USER'S BUFFER
;	R1 LOW BYTE = DATA TO BE TRANSFERRED TO USER
;	R5 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	R0 = UPDATED SYSTEM VIRTUAL ADDRESS OF BUFFER WINDOW
;
;	UCB$L_SVAPTE IS UPDATED WHENEVER A PAGE BOUNDARY IS CROSSED
;
; THE DRIVER IS EXPECTED TO SAVE THE VALUE OF R0 FOR SUBSEQUENT CALLS.
;
;-
 
IOC$PUTBYTE::				;
	MOVB	R1,(R0)+		;PUT BYTE INTO USERS'S BUFFER
	BITW	#^X01FF,R0		;OVERFLOW PAGE BOUNDARY?
	BNEQ	10$			;IF NEQ NO
	ADDL	#4,UCB$L_SVAPTE(R5)	;UPDATE ADDRESS OF PROCESS PTE
	BSBB	IOC$FILSPT		;FILL SPT, COMPUTE SYSTEM ADDRESS OF PAGE
10$:	RSB				;RETURN
	.PAGE
	.SBTTL	INITIALIZE FOR SINGLE BYTE TRANSFERS
;+
; IOC$INITBUFWIND - INITIALIZE ONE-PAGE WINDOW INTO USER'S BUFFER
;
; THIS ROUTINE MUST BE CALLED BY A DRIVER TO SETUP THE INITIAL ONE-
; PAGE WINDOW INTO A USER'S BUFFER BEFORE CALLING IOC$GETBYTE OR
; IOC$PUTBYTE.
;
; INPUTS:
;
;	R5 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	R0 = SYSTEM VIRTUAL ADDRESS OF WINDOW INTO USER'S BUFFER
;-
 
IOC$INITBUFWIND::			;
	BSBB	IOC$FILSPT		;FILL SPT, COMPUTE VIRTUAL ADDRESS OF PAGE
	BISW	UCB$W_BOFF(R5),R0	;MERGE BYTE OFFSET INTO ADDRESS
	RSB				;
	.PAGE
	.SBTTL	MOVE FROM USER BUFFER
;+
; IOC$MOVFRUSER - MOVE FROM USER BUFFER
;
; THIS ROUTINE IS CALLED BY AN I/O DRIVER TO MOVE A STRING FROM A USER
; BUFFER TO AN INTERNAL BUFFER.
;
; INPUTS:
;
;	R1 = ADDRESS OF INTERNAL BUFFER.
;	R2 = NUMBER OF BYTES TO BE MOVED.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	***TBS***
;-
 
	.ENABLE	LSB
IOC$MOVFRUSER::				;MOVE FROM USER BUFFER
	BSBB	IOC$INITBUFWIND		;SETUP WINDOW INTO BUFFER
	BRB	20$			;
IOC$MOVFRUSER2::
10$:	BITW	#^X01FF,R0		;OVERFLOW PAGE BOUNDRY?
	BNEQ	20$			;IF NEQ NO
	ADDL	#4,UCB$L_SVAPTE(R5)	;UPDATE ADDRESS OF USER PTE
	BSBB	IOC$FILSPT		;FILL SYSTEM PTE WITH PROPER RELOCATION
IOC$MOVFRUSER1::
20$:	MOVB	(R0)+,(R1)+		;MOVE BYTE TO INTERNAL BUFFER
	SOBGTR	R2,10$			;ANY MORE BYTES TO MOVE?
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	MOVE TO USER BUFFER
;+
; IOC$MOVTOUSER - MOVE TO USER BUFFER
;
; THIS ROUTINE IS CALLED BY AN I/O DRIVER TO MOVE A STRING FROM AN INTERNAL
; BUFFER TO A USER BUFFER.
;
; INPUTS:
;
;	R1 = ADDRESS OF INTERNAL BUFFER.
;	R2 = NUMBER OF BYTES TO BE MOVED.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
; ***TBS***
;-
 
	.ENABLE	LSB
IOC$MOVTOUSER::				;MOVE TO USER BUFFER
	BSBB	IOC$INITBUFWIND		;INITIALIZE WINDOW INTO BUFFER
	BRB	20$			;
IOC$MOVTOUSER2::
10$:	BITW	#^X01FF,R0		;OVERFLOW PAGE BOUNDRY?
	BNEQ	20$			;IF NEQ NO
	ADDL	#4,UCB$L_SVAPTE(R5)	;UPDATE ADDRESS OF USER PTE
	BSBB	IOC$FILSPT		;FILL SYSTEM PTE WITH PROPER RELOCATION
IOC$MOVTOUSER1::
20$:	MOVB	(R1)+,(R0)+		;MOVE BYTE TO USER BUFFER
	SOBGTR	R2,10$			;ANY MORE BYTES TO MOVE?
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	FILL SYSTEM PTE WITH TRANSFER PTE
;+
; IOC$FILSPT - FILL SYSTEM PTE WITH TRANSFER PTE
;
; THIS ROUTINE IS CALLED TO FILL A SYSTEM PTE WITH A TRANSFER PTE OF A
; LOCKED DOWN BUFFER SO THAT IT MAY BE DIRECTLY ADDRESS.
;
; INPUTS:
;
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	R0 = SYSTEM VIRTUAL ADDRESS OF START OF PAGE CONTAINING THE BUFFER.
;
;	REGISTERS R1, R2, AND R3 ARE PRESERVED ACROSS CALL.
;-
 
IOC$FILSPT::				;FILL SYSTEM PTE WITH TRANSFER PTE
	PUSHL	R3			;SAVE REGISTERS
	MULL3	#4,UCB$L_SVPN(R5),R0	;CALCULATE BYTE OFFSET IN SYSTEM PAGE TABLE
	MOVL	@UCB$L_SVAPTE(R5),R3	;GET CONTENTS OF TRANSFER PTE
	BLSS	10$			;IF LSS ENTRY IS VALID
	BSBW	IOC$PTETOPFN		;GET PFN FOR INVALID PTE
10$:	INSV	R3,#PTE$V_PFN,#PTE$S_PFN,@MMG$GL_SPTBASE[R0]
					;SET SYSTEM PTE ENTRY PFN
	ASHL	#7,R0,R0		;CONVERT SVPN TO SYSTEM VIRTUAL ADDRESS
	BBSS	#31,R0,20$		;
20$:	INVALID	R0			;INVALIDATE TRANSLATION BUFFER
	POPR	#^M<R3>			;RESTORE REGISTERS
	RSB				;
 
	.END
;
