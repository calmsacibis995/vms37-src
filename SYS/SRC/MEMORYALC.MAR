	.TITLE	MEMORYALC - DYNAMIC MEMORY ALLOCATION
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 3-AUG-76
;
;	V03-001	ROW0071		Ralph O. Weber		17-MAR-1982
;		Alter extend variable non-paged pool code to use BLEQU while 
;		testing proposed next variable page against SYSGEN maximum 
;		value.  This insures that a runaway pool hogger cannot cause 
;		the pool extension mechanism to extend variable non-paged pool 
;		beyond the SYSGEN defined maximum size.
;
;	V02-016 RIH0089		Richard I. Hustvedt	12-Feb-1982
;		Remove allocation histogram code.  Add fork mechanism to
;		call extendpool when an interrupt routine encounters an
;		allocation failure.
;
;	V02-015	LJK0130		Lawrence J. Kenah	12-Feb-1982
;		Change EXE$DEASHARED to reflect change in CHECKBLOCK.
;		Shorten name of alternate entry in EXE$DEANONPAGED.
;
;	V02-014	RIH0084		Richard I. Hustvedt	18-January-1981
;		Add small request packet list.
;
;	V02-013	RIH0083		Richard I. Hustvedt	31-December-1981
;		Implement automatic extension of non-paged pool.
;
;	V02-012	DJD0001		Darrell Duffy		29-December-1981
;		Remove any defaulting of structure size to irp size.
;		*Temp* Instrument memory allocation to study distribution
;		of sizes requested to determine if another lookaside list
;		is indicated.  This code will be removed before ship.
;
;	V02-011	LJK0105		Lawrence J. Kenah	17-Dec-1981
;		Add EXE$DEANONPAGED_SIZE entry point that allows blocks
;		larger than 65k bytes to be deallocated. (This change 
;		has made R1 an input parameter to CHECKBLOCK rather
;		than an output parameter from that routine.)
;		Correct bugs that might have allowed blocks larger than
;		65k bytes to be allocated from a lookaside list.
;
;	V02-010	SRB0038		Steve Beckhardt		29-Oct-1981
;		Added routine EXE$ALONPAGWAIT to allocate memory
;		and wait in caller's mode, if necessary.
;
;	V02-009	KTA0037		Kerbey T. Altmann	12-Oct-1981
;		Round all block sizes up to next <MASK> boundary.
;
;	V02-008	KTA0025		Kerbey T. Altmann	17-Jul-1981
;		MODIFY EXE$ALLOCATE TO RETURN LARGEST BLOCK IT
;		FOUND IN R2 ON AN UNSUCCESFUL SEARCH.
;
;	V0207	SPF0001		Steve Forgey		17-Oct-1980
;		ADD LRP LOOKASIDE LIST ALLOCATION AND DEALLOCATION.
;
;	V0206	LMK0003		LEN KAWELL		02-NOV-1979
;		ADD RESOURCE REPORTING TO SHARED MEMORY DEALLOCATION.
;
;
;	V0205	RIH0031		RICHARD I. HUSTVEDT	08-AUG-1979
;		ADD ALLOCATE ROUTINE FOR JIB AND CHANGE USE OF LOOKASIDE
;		LIST TO SATISFY IRP-SIZE AND SMALLER REQUESTS.
;
;	V0204	KDM0034		KATHLEEN D. MORSE	22-MAY-1979
;		ADD ASSUMPTIONS FOR COMMON EVENT BLOCK SIZES.
;
;	V0203	LMK0002		LEN KAWELL		18-MAY-1979
;		ADDED DEALLOCATION OF "SPECIAL" TYPES OF NON-PAGED
;		POOL BLOCKS.
;
;	V0202	LMK0001		LEN KAWELL		25-FEB-1979
;		ADDED SHARED MEMORY POOL ALLOCATION/DEALLOCATION
;
; DYNAMIC MEMORY ALLOCATION
;
; MACRO LIBRARY CALLS
;
 
	$CEBDEF				;DEFINE COMMON EVENT BLOCKS
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$JIBDEF				;DEFINE JIB OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PQBDEF				;DEFINE PQB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PSLDEF				;DEFINE PSL FIELDS
	$PTEDEF				;DEFINE PTE FIELDS
	$RSNDEF				;DEFINE RESOURCE WAIT NUMBERS
	$SHBDEF				;DEFINE SHARED MEM CONTROL BLOCK
	$SHDDEF				;DEFINE SHARED MEM DATAPAGE
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$TQEDEF				;DEFINE TQE OFFSETS
 	$VADEF				;DEFINE VIRTUAL ADDRESS FIELDS

;
; LOCAL SYMBOLS
;
; ALLOCATION GRANULARITY MASK
;
 
MASK=^XF				;16 BYTE ALLOCATION GRANULARITY
EXE$C_ALCGRNMSK==MASK			; ALLOCATION GRANULARITY MASK

	.PSECT	AEXENONPAGED		; NONPAGED EXEC
	.PAGE
	.SBTTL	ALLOCATE MEMORY AND CONDITIONALLY WAIT
;+
; EXE$ALLOCBUF - ALLOCATE BUFFERED I/O BUFFER AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BUFFERED I/O BUFFER. IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY
; ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCCEB - ALLOCATE COMMON EVENT BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A COMMON EVENT BLOCK. IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY
; ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCJIB - ALLOCATE JOB INFORMATION BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A JOB INFORMATION BLOCK. IF SUFFICIENT 
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY ENTERED
; DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCIRP - ALLOCATE I/O REQUEST PACKET AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN I/O PACKET. IF SUFFICIENT MEMORY
; IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY ENTERED
; DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCPCB - ALLOCATE PROCESS CONTROL BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A PROCESS CONTROL BLOCK WHEN
; CREATING A NEW PROCESS.  IF SUFFICIENT MEMORY IS NOT AVAILABLE, THEN
; A RESOURCE WAIT STATE IS CONDITIONALLY ENTERED DEPENDING ON THE CURRENT
; PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCPQB - ALLOCATE PROCESS QUOTA BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A PROCESS QUOTA BLOCK WHEN CREATING
; A NEW PROCESS.  IF SUFFICIENT MEMORY IS NOT AVAILABLE, THEN A RESOURCE
; WAIT STATE IS ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT
; MODE.
;
; EXE$ALLOCTQE - ALLOCATE TIME QUEUE ENTRY AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A TIME QUEUE ENTRY. IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY
; ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; INPUTS:
;
;	R4 = NORMALLY CURRENT PROCESS PCB ADDRESS, BUT NOT REQUIRED.
;
; IF ENTRY AT EXE$ALLOCBUF, THEN
;
;	R1 = SIZE OF REQUESTED BUFFER IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF ALLOCATION FAILURE WITH CALLING IPL PRESERVED.
;
;		R0 = SS$_INSFMEM = INSUFFICIENT MEMORY AVAILABLE TO ALLOCATE
;			BUFFER.
;
;	R0 = LOW BIT SET IF SUCCESSFUL ALLOCATION WITH:
;
;		R1 = SIZE OF REQUESTED BUFFER IN BYTES.
;		R2 = ADDRESS OF ALLOCATED BUFFER WITH SIZE AND TYPE FIELDS
;			FILLED IN.
;
;		AND IPL SET TO AST DELIVERY LEVEL.
;
;	R4 = ORIGINAL R4 OR CURRENT PCB IF A WAIT OCCURRED.
;-
 
	.ENABL	LSB
EXE$ALLOCBUF::				;ALLOCATE BUFFERED I/O BUFFER
	PUSHL	#DYN$C_BUFIO		;SET DATA STRUCTURE TYPE
	BRB	20$			;
EXE$ALLOCCEB::				;ALLOCATE COMMON EVENT BLOCK
	PUSHL	#DYN$C_CEB		;SET DATA STRUCTURE TYPE
	MOVZWL	#<CEB$C_LENGTH+MASK>&<^C<MASK>>,R1 ;AND LENGTH OF BLOCK
	BRB	20$			;
EXE$ALLOCJIB::				;ALLOCATE JOB INFORMATION BLOCK - COND WAIT
	PUSHL	#DYN$C_JIB		;SET STRUCTURE TYPE
	MOVZWL	#<JIB$C_LENGTH+MASK>&<^C<MASK>>,R1 ;AND LENGTH OF BLOCK
	BRB	20$			;MERGE WITH COMMON ALLOCATE CODE
EXE$ALLOCIRP::				;ALLOCATE I/O PACKET - CONDITIONAL WAIT
	PUSHL	#DYN$C_IRP		;SET DATA STRUCTURE TYPE
	MOVZBL	#<IRP$C_LENGTH+MASK>&<^C<MASK>>,R1 ;SET SIZE OF BUFFER REQUIRED
	BRB	20$			;
EXE$ALLOCPCB::				;ALLOCATE PROCESS CONTROL BLOCK
	PUSHL	#DYN$C_PCB		;SET DATA STRUCTURE TYPE
	MOVZBL	#<PCB$C_LENGTH+MASK>&<^C<MASK>>,R1 ;AND STRUCTURE SIZE
	BRB	20$			;
EXE$ALLOCPQB::				;ALLOCATE PROCESS QUOTA BLOCK
	PUSHL	#DYN$C_PQB		;SET DATA STRUCTURE TYPE
	MOVZWL	#<PQB$C_LENGTH+MASK>&<^C<MASK>>,R1 ;AND STRUCTURE SIZE
	BRB	20$			;
EXE$ALLOCTQE::				;ALLOCATE TIME QUEUE ENTRY
	PUSHL	#DYN$C_TQE		;SET DATA STRUCTURE TYPE
	MOVZBL	#<TQE$C_LENGTH+MASK>&<^C<MASK>>,R1 ;SET SIZE OF BUFFER REQUIRED
20$:	MOVPSL	-(SP)			;READ CURRENT PSL
	DSBINT	#IPL$_SYNCH		;SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	PUSHL	R1			;SAVE REQUEST SIZE
	BSBB	EXE$ALONONPAGED		;ATTEMPT TO ALLOCATE PACKET
	POPR	#^M<R1,R3>		;RETRIEVE REQUEST SIZE AND PREVIOUS IPL
	BLBC	R0,40$			;IF LBC NO PACKET ALLOCATED
	MOVW	R1,IRP$W_SIZE(R2)	;INSERT SIZE OF ALLOCATED BLOCK
	MOVZBW	4(SP),IRP$B_TYPE(R2)	;INSERT DATA STRUCTURE TYPE
					;AND CLEAR MISCELLANEOUS BYTE
	MOVZWL	#IPL$_ASTDEL,R3		;SET TO RAISE TO AST DELIVERY LEVEL
30$:	ENBINT	R3			;ALLOW INTERRUPTS
	ADDL	#8,SP			;REMOVE PSL AND STRUCTURE TYPE FROM STACK
	RSB				;
40$:	MOVZWL	#SS$_INSFMEM,R0		;SET INSUFFICIENT MEMORY
	MOVL	W^SCH$GL_CURPCB,R4	;FORCE CURRENT PCB ADDRESS
	BBS	#PCB$V_SSRWAIT,PCB$L_STS(R4),30$ ;IF SET, NO WAIT
	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
	BSBW	SCH$RWAIT		;WAIT FOR NONPAGED MEMORY
	BRB	20$			;
	.DSABL	LSB
	.PAGE
	.SBTTL	EXE$ALONPAGWAIT - ALLOCATE MEMORY AND WAIT IN CALLER'S MODE
;+
; EXE$ALONPAGWAIT - ALLOCATE NON-PAGED MEMORY AND OPTIONALLY WAIT IN CALLER'S
;		    ACCESS MODE.
;
; THIS ROUTINE IS CALLED TO ALLOCATE NON-PAGED MEMORY.  IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN THE PROCESS IS PLACED IN A RESOURCE
; WAIT STATE IF RESOURCE WAIT MODE IS ENABLED.  OTHERWISE, AN ERROR IS
; RETURNED.  THIS ROUTINE IS INTENDED TO BE CALLED BY SYSTEM SERVICES
; THAT NEED TO ALLOCATE NON-PAGED POOL.  IF IT IS NECESSARY TO WAIT, THE
; STACK IS TRIMMED BACK TO WAIT IN THE MODE OF THE (SYSTEM SERVICE) CALLER.
; WHEN THE PROCESS IS RESUMED, IT RESUMES AT THE BEGINNING OF THE SYSTEM
; SERVICE.  AS A RESULT OF THIS INTERFACE, IT IS NECESSARY TO PROVIDE A
; WAY FOR THE SYSTEM SERVICE TO PERFORM ANY NECESSARY CLEANUP BEFORE
; BEING PLACED IN THE WAIT STATE.  THIS IS PROVIDED BY ALLOWING THE 
; SYSTEM SERVICE TO SPECIFY AN OPTIONAL CLEANUP ROUTINE TO BE CALLED
; PRIOR TO PLACING THE PROCESS IN A WAIT STATE.
;
; INPUTS:
;
;	R0 = ADDRESS OF CLEANUP ROUTINE (0 INDICATES NO ROUTINE)
;	R1 = SIZE OF BUFFER REQUIRED (IN BYTES)
;
;	IPL MUST BE AT IPL$_ASTDEL OR LOWER
;
; OUTPUTS:
;
;	R0 = SS$_INSFMEM IF ALLOCATION FAILURE AND RESOURCE WAIT MODE
;	     DISABLED.  IPL IS AT IPL$_ASTDEL.
;
;	   = LOW BIT SET IF SUCCESSFUL ALLOCATION.  IPL IS AT IPL$_ASTDEL.
;
;	R1 = SIZE OF ALLOCATED BUFFER
;
;	R2 = ADDRESS OF ALLOCATED BUFFER
;
;	R4 = ORIGINAL R4 IF ALLOCATION WAS SUCCESSFUL.
;
;	   = CURRENT PROCESS PCB ADDRESS IF ALLOCATION FAILURE AND RESOURCE
;	     WAIT MODE DISABLED.
;
; NOTES:
;
;	IPL IS ALWAYS AT IPL$_ASTDEL ON RETURN.
;	R3 IS NOT PRESERVED.
;	THE CLEANUP ROUTINE IS CALLED AT IPL$_SYNCH (THEREFORE IT
;	MUST BE NON-PAGEABLE).
;-

EXE$ALONPAGWAIT::
	PUSHL	R0			; SAVE ADDRESS OF CLEANUP ROUTINE
	SETIPL	#IPL$_SYNCH		; RAISE IPL TO SYNCH
	BSBB	EXE$ALONONPAGED		; TRY TO ALLOCATE THE MEMORY
	BLBC	R0,20$			; FAILED TO ALLOCATE IT
10$:	SETIPL	#IPL$_ASTDEL		; LOWER IPL TO ASTDEL
	ADDL	#4,SP			; REMOVE ADDRESS OF CLEANUP ROUTINE
	RSB				; RETURN

20$:	; FAILED TO ALLOCATE.  IF RESOURCE WAIT MODE IS ENABLED THEN
	; REMOVE CALL FRAME FROM STACK AND WAIT IN CALLER'S MODE.
	; OTHERWISE, RETURN ERROR.

	MOVZWL	#SS$_INSFMEM,R0		; SET STATUS CODE
	MOVL	W^SCH$GL_CURPCB,R4	; GET CURRENT PROCESS PCB ADDRESS
	BBS	#PCB$V_SSRWAIT,PCB$L_STS(R4),10$  ; BR. IF NO WAIT
	POPL	R0			; GET ADDRESS OF CLEANUP ROUTINE
	BEQL	30$			; NO CLEANUP ROUTINE
	JSB	(R0)			; CALL CLEANUP ROUTINE
30$:	MOVL	FP,SP			; TRIM STACK BACK TO START OF FRAME
	MOVQ	8(SP),AP		; RESTORE PRE-CALL AP AND FP
	ADDL	S^#EXE$C_CMSTKSZ,SP	; CLEAN CALL FRAME OFF STACK
	SUBL	#4,(SP)			; BACK UP SAVED PC TO POINT TO CHMK
	MOVZBL	#RSN$_NPDYNMEM,R0	; SET NON-PAGED MEM. RESOURCE NUMBER
	BRW	SCH$RWAIT		; WAIT FOR RESOURCE
	.PAGE
	.SBTTL	ALLOCATE NONPAGED DYNAMIC MEMORY
;+
; EXE$ALONONPAGED - ALLOCATE NONPAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM THE NONPAGED POOL.
; IF THE BLOCK IS THE SAME SIZE AS AN I/O PACKET, AN ATTEMPT IS MADE TO ALLO-
; CATE IT FROM THE LOOKASIDE LIST.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-
 
	.ENABL	LSB
200$:	BRW	20$			;BAD ALLOCATION REQUEST
EXE$ALONONPAGED::			;ALLOCATE NONPAGED MEMORY
	ADDL	#MASK,R1		;ROUND SIZE UP TO NEXT BOUNDRY
	BICL	#MASK,R1		;TRUNCATE SIZE BACK TO MULTIPLE
	BEQL	200$			;IF EQL BAD ALLOCATION REQUEST
	CMPL	#<IRP$C_LENGTH+MASK>&<^C<MASK>>,R1 ;SIZE GREATER THAN IRP ?
	BLSSU	LRP			;IF LSSU, YES
	CMPL	R1, W^IOC$GL_IRPMIN	;IS THE BLOCK TOO SMALL?
	BLSSU	SRP			;YES, TRY SMALL PACKETS
	REMQUE	@W^IOC$GL_IRPFL,R2	;REMOVE FIRST PACKET FROM LOOK ASIDE LIST
	BVS	LISTCHK			;IF VS EMPTY LIST
	MOVL	#SS$_NORMAL,R0		;SET SUCCESSFUL COMPLETION
	RSB				;

LRP:	CMPL	W^IOC$GL_LRPMIN,R1	;SIZE LESS THAN LRP MINIMUM ?
	BGTRU	VAR			;IF GTRU, YES
	CMPL	W^IOC$GL_LRPSIZE,R1	;SIZE GREATER THAN LRP ?
	BLSSU	VAR			;IF LSSU, YES
	REMQUE	@W^IOC$GL_LRPFL,R2	;REMOVE FIRST PACEKT FROM LRP LIST
	BVS	LISTCHK			;IF VS, EMPTY LIS
	MOVL	#SS$_NORMAL,R0
	RSB
LISTCHK:
	BSBW	EXE$EXTENDPOOL		;ATTEMPT TO EXTEND POOL
	BLBS	R0,EXE$ALONONPAGED	;RETRY LISTS IF SOMETHING EXTENDED
VAR:	MOVAB	W^EXE$GL_NONPAGED,R3	;GET ADDRESS OF NONPAGED MEMORY LISTHEAD
	DSBINT	(R3)+			;DISABLE INTERRUPTS
	BSBB	EXE$ALLOCATE		;ALLOCATE BLOCK
	ENBINT				;ENABLE INTERRUPTS
	BLBC	R0,EXTENDCHK		;BR IF FAILURE
	RSB				;
EXTENDCHK:				;CHECK FOR POOL EXTENSION
	BISL	#1,W^MMG$GL_NPAGNEXT	;SET FLAG FOR EXTENSION
	BSBW	EXE$EXTENDPOOL		;ATTEMPT TO EXTEND POOL
	BLBS	R0,EXE$ALONONPAGED	;AND REPEAT ALLOCATION ATTEMPT
	RSB				;

SRP:	CMPL	R1,W^IOC$GL_SRPSIZE	;CHECK FOR FIT IN SMALL PACKETS
	BGTRU	VAR			;MUST USE VARIABLE POOL
;	CMPL	R1,W^IOC$GL_SRPMIN	;CHECK FOR LOWER BOUND
;	BLSSU	VAR			;MUST USE VARIABLE POOL
	REMQUE	@W^IOC$GL_SRPFL,R2	;REMOVE FIRST PACEKT FROM SRP LIST
	BVS	LISTCHK			;IF VS, EMPTY LIST
	MOVL	#SS$_NORMAL,R0		;
	RSB				;

	.PAGE
	.SBTTL	ALLOCATE PAGED DYNAMIC MEMORY
;+
; EXE$ALOPAGED - ALLOCATE PAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM THE PAGED POOL.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-
 
EXE$ALOPAGED::				;ALLOCATE PAGED DYNAMIC MEMORY
	ADDL	#MASK,R1		;ROUND SIZE UP TO NEXT BOUNDRY
	BICL	#MASK,R1		;TRUNCATE SIZE BACK TO MULTIPLE
	BEQL	20$			;IF EQL BAD ALLOCATION REQUEST
	SAVIPL				;SAVE CURRENT IPL
	PUSHL	R4			;SAVE REGISTER
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	MOVL	W^SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	BSBW	SCH$LOCKW		;LOCK PAGED MEMORY DATA BASE FOR WRITE
	MOVAB	W^EXE$GL_PAGED,R3	;GET ADDRESS OF PAGED MEMORY LISTHEAD
	BSBB	EXE$ALLOCATE		;ALLOCATE BLOCK
	PUSHR	#^M<R0,R1,R2>		;SAVE REGISTERS
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	BSBW	SCH$UNLOCK		;UNLOCK PAGED MEMORY DATA BASE
	POPR	#^M<R0,R1,R2,R4>	;RESTORE REGISTERS
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
20$:	BUG_CHECK BADALORQSZ		;BAD ALLOCATION REQUEST SIZE
	CLRL	R0			;INDICATE NO BLOCK ALLOCATED
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	GENERAL ALLOCATE MEMORY SUBROUTINE
;+
; EXE$ALLOCATE - ALLOCATE MEMORY SUBROUTINE
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM A POOL WHOSE ENTRIES
; ARE MAINTAINED IN A MEMORY ORDER SORTED LIST.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;	R3 = ADDRESS OF ALLOCATION REGION LISTHEAD.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;		R2 = SIZE OF LARGEST BLOCK FOUND
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-

EXE$ALLOCATE::				;ALLOCATE MEMORY
	CLRL	-(SP)			;TEMP STORAGE
	MOVL	R3,R0			;COPY ADDRESS OF FIRST FREE BLOCK ADDRESS
10$:	MOVL	R0,R2			;SAVE ADDRESS OF PREVIOUS FREE BLOCK
	MOVL	(R2),R0			;GET ADDRESS OF NEXT FREE BLOCK
	BEQL	30$			;IF EQL NO MEMORY AVAILABLE
	CMPL	4(R0), (SP)		;GREATER THAN PREVIOUS?
	BLSSU	15$			;NO, CONTINUE
	MOVL	4(R0), (SP)		;YES, UPDATE COUNTER
15$:	CMPL	R1,4(R0)		;FREE BLOCK BIG ENOUGH?
	BGTRU	10$			;IF GTRU NO
	BEQL	20$			;IF EQL FREE BLOCK IS EXACT SIZE
	ADDL3	R0,R1,R3		;CALCULATE ADDRESS OF NEW FREE BLOCK
	MOVL	(R0)+,(R3)+		;COPY LINK TO NEXT FREE BLOCK
	SUBL3	R1,(R0),(R3)		;CALCULATE SIZE OF NEW FREE BLOCK
	MOVAL	-(R3),-(R0)		;SET LINK TO NEW FREE BLOCK
20$:	MOVL	(R0),(R2)		;COPY LINK TO NEW FREE BLOCK
	MOVAB	(R0)+,R2		;SET ADR OF ALLOCATED BLOCK, INDICATE SUCCESS
	ADDL	#4,SP			;CLEAN UP COUNTER
	RSB

30$:	POPL	R2			;RECOVER THE COUNTER
	RSB				;
	.PAGE
	.SBTTL	DEALLOCATE NONPAGED DYNAMIC MEMORY
;+
; EXE$DEANONPAGED - DEALLOCATE NONPAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A BLOCK OF MEMORY TO A NONPAGED POOL.
; IF THE BLOCK IS A SHARED MEMORY BLOCK TYPE, THE BLOCK IS DEALLOCATED TO
; THE SHARED MEMORY POOL.  OTHERWISE, THE BLOCK'S ADDRESS IS CHECKED TO SEE
; IF IT WAS ALLOCATED FROM THE I/O PACKET LOOKASIDE LIST AND IF SO,
; IT IS RETURNED TO THAT LIST.  OTHERWISE IT IS MERGED INTO THE NORMAL
; NONPAGED POOL.
;
; INPUT:
;
;	IF ENTRY IS AT EXE$DEANONPAGED
;
;		R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;		IRP$W_SIZE(R0) = SIZE OF BLOCK TO BE DEALLOCATED.
;		IRP$B_TYPE(R0) = TYPE OF BLOCK TO BE DEALLOCATED.
;
;	IF ENTRY IS AT EXE$DEANONPAGED_SIZE
;
;		R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;		R1 = SIZE OF BLOCK TO BE DEALLOCATED (ASSUMED NONZERO)
;
; OUTPUTS:
;
;	THE SPECIFIED BLOCK IS RETURNED TO THE APPROPRIATE POOL.
;-
 
	.ENABL	LSB
EXE$DEANONPAGED::			;DEALLOCATE NONPAGED DYNAMIC MEMORY
	TSTB	IRP$B_TYPE(R0)		;IS BLOCK A SHARED MEMORY BLOCK?
	BGEQ	5$			;IF GEQ NO
	BRW	EXE$DEASHARED		;ELSE, DEALLOCATE IT

5$:	MOVZWL	IRP$W_SIZE(R0),R1	;GET SIZE OF BLOCK IN BYTES

EXE$DEANONPGDSIZ::			;DEALLOCATE NONPAGED DYNAMIC MEMORY
	BSBB	CHECKBLOCK		;CHECK DEALLOCATION PARAMETERS
	MOVAB	W^EXE$GL_NONPAGED,R3	;GET ADDRESS OF NONPAGED MEMORY LISTHEAD
	DSBINT	(R3)+			;DISABLE INTERRUPTS
	CMPL	R0,W^IOC$GL_SRPSPLIT	;SMALL REQUEST PACKET?
	BLSSU	8$			;BR IF NOT
	INSQUE	(R0),@W^IOC$GL_SRPBL	;INSERT NEW PACKET AT END OF LIST
	BRB	20$			;
8$:	CMPL	R0,W^EXE$GL_SPLITADR	;I/O REQUEST PACKET
	BLSSU	10$			;IF LSSU NO
	INSQUE	(R0),@W^IOC$GL_IRPBL	;INSERT NEW PACKET AT END OF LIST
	BRB	20$			;
10$:	CMPL	R0,W^IOC$GL_LRPSPLIT	;LARGE REQUEST PACKET
	BLSSU	15$			;IF LSSU, NO
	INSQUE	(R0),@W^IOC$GL_LRPBL	;INSERT NEW PACKET AT END OF LIST
	BRB	20$			;
15$:	BSBB	EXE$DEALLOCATE		;DEALLOCATE BLOCK
20$:	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
	BRB	30$			;
	.PAGE
	.SBTTL	DEALLOCATE PAGED DYNAMIC MEMORY
;+
; EXE$DEAPAGED - DEALLOCATE PAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A BLOCK OF MEMORY TO THE PAGED POOL.
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;
; OUTPUTS:
;
;	THE SPECIFIED BLOCK OF MEMORY IS RETURNED TO THE PAGED POOL.
;-
 
EXE$DEAPAGED::				;DEALLOCATE PAGED DYNAMIC MEMORY
	MOVZWL	IRP$W_SIZE(R0),R1	;GET SIZE OF BLOCK IN BYTES
	BSBB	CHECKBLOCK		;CHECK DEALLOCATION PARAMETERS
	SAVIPL				;SAVE CURRENT IPL
	PUSHR	#^M<R0,R4>		;SAVE REGISTERS
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	MOVL	W^SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	BSBW	SCH$LOCKW		;LOCK PAGED MEMORY DATA BASE FOR WRITE
	POPL	R0			;RESTORE REGISTER
	MOVAB	W^EXE$GL_PAGED,R3	;GET ADDRESS OF PAGED MEMORY LISTHEAD
	BSBB	EXE$DEALLOCATE		;DEALLOCATE BLOCK
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	BSBW	SCH$UNLOCK		;UNLOCK PAGED MEMORY DATA BASE
	POPL	R4			;RESTORE REGISTER
	MOVZWL	#RSN$_PGDYNMEM,R0	;SET PAGED DYNAMIC MEMORY RESOURCE NUMBER
30$:	BSBW	SCH$RAVAIL		;MARK RESOURCE AVAILABLE
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	CHECK BLOCK PARAMETERS SUBROUTINE
;
; CHECKBLOCK - CHECK BLOCK PARAMETERS SUBROUTINE
;
; INPUT PARAMETERS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED
;	R1 = SIZE OF BLOCK TO BE DEALLOCATED
;
; OUTPUT PARAMETER:
; 
;	R1 = MODIFIED SIZE OF BLOCK TO BE DEALLOCATED
;	     (SIZE IS ROUNDED UP TO NEXT MULTIPLE OF QUANTUM OF ALLOCATION)
;
 
CHECKBLOCK:				;CHECK BLOCK PARAMETERS
	BITL	#MASK,R0		;BLOCK ALIGNED ON BOUNDRY?
	BNEQ	10$			;IF NEQ NO - BAD DEALLOCATION
	ADDL	#MASK,R1		;ROUND SIZE UP TO NEXT BOUNDRY
	BICL	#MASK,R1		;TRUNCATE SIZE BACK TO MULTIPLE
	BNEQ	20$			;IF NEQ OKAY
10$:	BUG_CHECK BADDALRQSZ		;BAD DEALLOCATION REQUEST SIZE OR ADDRESS
	TSTL	(SP)+			;REMOVE RETURN FROM STACK
20$:	RSB				;
	.PAGE
	.SBTTL	GENERAL DEALLOCATION SUBROUTINE
;+
; EXE$DEALLOCATE - DEALLOCATION SUBROUTINE
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;	R1 = SIZE OF BLOCK IN BYTES
;	R3 = ADDRESS OF ALLOCATION REGION LISTHEAD.
;
; OUTPUTS:
;
;	NONE
;-

EXE$DEALLOCATE::			;DEALLOCATE BLOCK
10$:	MOVL	R3,R2			;SAVE ADDRESS OF PREVIOUS FREE BLOCK
	MOVL	(R2),R3			;GET ADDRESS OF NEXT FREE BLOCK
	BEQL	20$			;IF EQL END OF LIST
	CMPL	R0,R3			;BLOCK LOGICALLY GO HERE?
	BGTRU	10$			;IF GTRU NO
	BEQLU	50$			;IF EQLU DOUBLE DEALLOCATION
20$:	MOVL	R3,(R0)			;ASSUME NO AGGLOMERATION
	ADDL3	R0,R1,-(SP)		;CALCULATE ADDRESS OF END OF BLOCK
	CMPL	R3,(SP)+		;END OF BLOCK EQUAL TO NEXT IN LIST?
	BNEQ	30$			;IF NEQ DO NOT AGGLOMERATE
	MOVL	(R3)+,(R0)		;MOVE LINK TO BLOCK BEING RELEASED
	ADDL	(R3),R1			;ACCUMULATE LENGTH OF NEW FREE BLOCK
30$:	PUSHL	R2			;CALCULATE ENDING ADDRESS OF PREVIOUS BLOCK
	MOVL	R0,(R2)+		;ASSUME NO AGGLOMERATION
	ADDL	(R2),(SP)		;ADD LENGTH TO BLOCK BASE ADDRESS
	CMPL	R0,(SP)+		;END ADDRESS EQUAL TO BLOCK BEING RELEASED?
	BNEQ	40$			;IF NEQ DO NOT AGGLOMERATE BLOCKS
	ADDL	(R2),R1			;ACCUMULATE SIZE OF NEW FREE BLOCK
	MOVL	(R0),-(R2)		;MOVE LINK TO PREVIOUS FREE BLOCK
	MOVL	R2,R0			;SET ADDRESS OF NEW FREE BLOCK
40$:	MOVL	R1,4(R0)		;SET SIZE OF FREE BLOCK
	RSB				;
50$:	BUG_CHECK DOUBLDEALO,FATAL	;DOUBLE DEALLOCATION OF MEMORY BLOCK

	.PAGE
	.SBTTL	ALLOCATE A BLOCK OF SHARED MEMORY POOL
;+
; EXE$ALOSHARED - ALLOCATE A BLOCK OF SHARED MEMORY POOL
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM THE
; SHARED MEMORY POOL.
;
; INPUTS:
;
;	R2 = ADDRESS OF SHARED MEMORY CONTROL BLOCK (SHB).
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-
 
EXE$ALOSHARED::				;ALLOCATE SHARED MEMORY POOL
	MOVL	SHB$L_DATAPAGE(R2),R0	;GET ADDRESS OF DATA PAGE
					;(PAGE ALIGNED SO LOW BIT CLEAR)
	CLRL	R1			;INIT RETRY COUNT

10$:	REMQHI	SHD$Q_POOL(R0),R2	;REMOVE A BLOCK FROM POOL
	BCS	30$			;BR IF QUEUE LOCKED - RETRY
	BVS	20$			;BR IF NO ENTRY - FAILURE
	MOVZWL	IRP$W_SIZE(R2),R1	;GET SIZE OF BLOCK
	INCL	R0			;SET SUCCESSFUL COMPLETION
20$:	RSB				;

30$:	AOBLEQ	W^EXE$GL_LOCKRTRY,R1,10$ ;INCREMENT RETRY COUNT AND TRY AGAIN
	RSB				;IF RETRIES EXHAUSTED, QUEUE HEADER BAD
	.PAGE
	.SBTTL	DEALLOCATE A BLOCK OF SHARED MEMORY POOL
;+
; EXE$DEASHARED - DEALLOCATE A BLOCK OF SHARED MEMORY POOL
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A BLOCK OF MEMORY TO THE
; APPROPRIATE SHARED MEMORY POOL.
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;	IRP$W_SIZE(R0) = SIZE OF BLOCK TO BE DEALLOCATED.
;
; OUTPUTS:
;
;	THE SPECIFIED BLOCK IS RETURNED TO APPROPRIATE SHARED MEMORY POOL.
;
;	R0-R3 NOT PRESERVED.
;-
 
EXE$DEASHARED::				;DEALLOCATE SHARED MEMORY
	MOVZWL	IRP$W_SIZE(R0),R1	;GET SIZE OF BLOCK IN BYTES
	BSBB	CHECKBLOCK		;CHECK DEALLOCATION PARAMETERS
	MOVAL	W^EXE$GL_SHBLIST,R1	;GET ADDR OF SHARED MEMORY
					; CONTROL BLOCK LISTHEAD
	ASSUME	SHB$L_LINK EQ 0		;
10$:
	MOVL	SHB$L_LINK(R1),R1	;GET ADDR OF NEXT SHB
	BEQL	40$			;BR IF NONE - ERROR
	CMPL	R0,SHB$L_DATAPAGE(R1)	;CHECK IF BLOCK IS FROM MEMORY
	BLEQU	10$			;BR IF NOT
	CMPL	R0,SHB$L_POOLEND(R1)	;CHECK IF BLOCK IS FROM MEMORY
	BGTRU	10$			;BR IF NOT
	MOVL	SHB$L_DATAPAGE(R1),R3	;GET ADDR OF DATAPAGE
	CLRL	R2			;INIT RETRY COUNT
20$:
	INSQTI	(R0),SHD$Q_POOL(R3)	;DEALLOCATE BLOCK TO POOL
	BCC	30$			;BR IF QUEUE NOT LOCKED - SUCCESS
	AOBLEQ	W^EXE$GL_LOCKRTRY,R2,20$ ;INCREMENT RETRY COUNT AND TRY AGAIN
	BUG_CHECK BADQHDR		;IF RETRIES EXHAUSTED, QUEUE HEADER BAD
30$:	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
	BRW	MA$RAVAIL		;REPORT RESOURCE AVAILABLE AND RETURN

40$:	BUG_CHECK BADDALRQSZ		;BAD DEALLOCATION REQUEST ADDRESS
	RSB				;
	.PAGE
	.SBTTL	EXE$EXTENDPOOL - EXTEND NONPAGED POOL IF POSSIBLE
;+
; EXE$EXTENDPOOL - EXTEND NONPAGED POOL IF POSSIBLE
;
; THIS ROUTINE IS CALLED UPON A FAILURE TO ALLOCATE NON-PAGED POOL AND
; IT WILL ALLOCATE ADDITIONAL PAGES FOR ANY OF THE THREE SUBDIVISIONS
; OF NONPAGED POOL, THE IRP LIST, THE LRP LIST OR THE VARIABLE ALLOCATION
; AREA.
; 
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 - COMPLETION STATUS 
; 
;		LOW BIT CLEAR IF NO EXTENSION PERFORMED
;-
EXE$EXTENDPOOL::
	CMPB	#31,W^EXE$GL_NONPAGED	; IS INIT RUNNING?
	BEQL	30$			; YES
	MOVPSL	-(SP)			; GET CURRENT PSL
	BITL	#PSL$M_IS,(SP)+		; AND CHECK FOR INTERRUPT STACK
	BEQL	30$			; CONTINUE IF NOT
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE REGISTERS DESTROYED BY FORK
	BBSS	#0,W^IOC$GL_PFKBINT,10$	; BR IF FORK BLOCK IN USE
	MOVAB	W^IOC$GL_POOLFKB,R5	; GET ADDRESS OF FORK BLOCK
	BSBB	20$			; PUSH ADDRESS OF CALLER'S CALLER
10$:	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	CLRL	R0			; INDICATE FAILURE
	RSB				; EXIT IF ON INTERRUPT STACK
20$:	BSBW	EXE$FORK		; FORK TO IPL$_QUEUEAST
;
; 	CONTINUATION IS AT IPL=IPL$_QUEUEAST (6) TO PERMIT SAFE ALLOCATION
;	OF PAGES FROM THE FREE PAGE LIST.
;
	BICL	#1,W^IOC$GL_PFKBINT	; INDICATE FORK BLOCK FREE
30$:	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9>	; SAVE REGISTERS
	DSBINT	W^EXE$GL_NONPAGED	; SYNCHRONIZE DATABASE
	CLRL	R5			; ASSUME FAILURE
CHECKIRP:				;
	MOVZWL	#<IRP$C_LENGTH+MASK>&<^C<MASK>>,R2 ; SIZE OF IRP
	MOVAB	W^MMG$GL_IRPNEXT,R3	; SET ADDRESS OF NEXT VA
	MOVAB	W^IOC$GL_IRPREM,R6	; ADDRESS OF PARTIAL PACKET
	MOVAB	W^IOC$GL_IRPCNT,R7	; ADDRESS OF PACKET COUNT
	MOVAB	W^IOC$GL_IRPFL,R8	; ADDRESS OF PACKET LIST
	MOVAB	W^SGN$GL_IRPCNTV,R9	; ADDRESS OF MAXIMUM COUNT
	BSBW	EXTENDLIST		; EXTEND LIST
CHECKSRP:				;
	MOVL	W^IOC$GL_SRPSIZE,R2 	; SIZE OF SRP
	MOVAB	W^MMG$GL_SRPNEXT,R3	; SET ADDRESS OF NEXT VA
	MOVAB	W^IOC$GL_SRPREM,R6	; ADDRESS OF PARTIAL PACKET
	MOVAB	W^IOC$GL_SRPCNT,R7	; ADDRESS OF PACKET COUNT
	MOVAB	W^IOC$GL_SRPFL,R8	; ADDRESS OF PACKET LIST
	MOVAB	W^SGN$GL_SRPCNTV,R9	; ADDRESS OF MAXIMUM COUNT
	BSBB	EXTENDLIST		; EXTEND LIST
CHECKLRP:				;
	MOVL	W^IOC$GL_LRPSIZE,R2 	; SIZE OF LRP
	MOVAB	W^MMG$GL_LRPNEXT,R3	; SET ADDRESS OF NEXT VA
	MOVAB	W^IOC$GL_LRPREM,R6	; ADDRESS OF PARTIAL PACKET
	MOVAB	W^IOC$GL_LRPCNT,R7	; ADDRESS OF PACKET COUNT
	MOVAB	W^IOC$GL_LRPFL,R8	; ADDRESS OF PACKET LIST
	MOVAB	W^SGN$GL_LRPCNTV,R9	; ADDRESS OF MAXIMUM COUNT
10$:	BSBB	EXTENDLIST		; EXTEND LIST
	BLBS	R0,10$			; TRY AGAIN FOR MULTIPAGE PACKETS
CHECKVAR:				; 
;
; EXTEND VARIABLE AREA
;
	MOVAB	W^MMG$GL_NPAGNEXT,R3	; GET ADDRESS OF NEXT VA CELL
	BLBC	(R3),90$		; BR IF VARIABLE EXTENSION NOT NEEDED
	ADDL3	W^SGN$GL_NPAGEVIR,W^MMG$GL_NPAGEDYN,R0 ; COMPUTE UPPER BOUND
	CMPL	R0,(R3)			; CHECK FOR AT LIMIT
	BLEQU	90$			; BR IF AT OR PAST LIMIT
	BSBW	EXTENDPAGE		; TRY TO ADD ANOTHER PAGE
	TSTL	R0			; CHECK STATUS
	BLSS	90$			; BR IF FAILURE
	BICL	#1,(R3)			; CLEAR FLAG
	SUBL3	#512,(R3),R0		; COMPUTE ADDRESS OF NEW SEGMENT
	MOVZWL	#512,IRP$W_SIZE(R0)	; SET SIZE
	MOVL	#1,R5			; RECORD SUCCESS STATUS
	BSBW	EXE$DEANONPAGED		; ADD NEW PAGE TO POOL
	BRB	100$			; AND EXIT
90$:	MOVZWL	#RSN$_NPDYNMEM,R0	; SET RESOURCE TYPE
	BLBC	R5,100$			; BR IF NOTHING AVAILABLE
	BSBW	SCH$RAVAIL		; REPORT RESOURCE AVAILABLE
100$:	MOVL	R5,R0			; SET COMPLETION STATUS
	ENBINT				; RESTORE CALLER'S IPL
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9> ; RESTORE REGISTERS
	RSB

	.PAGE
	.SBTTL	EXTENDLIST - EXTEND SELECTED PACKET LIST
;+
; EXTENDLIST - EXTEND SELECTED PACKET LIST IF NEEDED
;
; THIS ROUTINE EXTENDS THE SELECTED LIST IF NECESSARY BY ADDING ONE
; PAGE AT A TIME
;
; INPUTS:
;
;	R2 = PACKET SIZE
;	R3 = ADDRESS OF MMG$GL_xRPNEXT, NEXT VA TO ALLOCATE
;	R6 = ADDRESS OF IOC$GL_xRPREM, ADDRESS OF PARTIAL PACKET
;	R7 = ADDRESS OF IOC$GL_xRPCNT, COUNT OF ALLOCATED PACKETS
;	R8 = ADDRESS OF IOC$GL_xRPFL, LIST HEADER
;	R9 = ADDRESS OF SGN$GL_xRPCNTV, MAXIMUM COUNT TO ALLOCATE
;
; OUTPUTS:
;
;	R0 = COMPLETION STATUS, LOW BIT CLEAR IF NO EXTENSION OR NOT NEEDED
;
;-
EXTENDLIST:				;
	CMPL	R8,(R8)			; IS LIST EMPTY?
	BNEQ	70$			; IF NOT, EXIT
	CMPL	(R9),(R7)		; CHECK FOR POSSIBLE EXTENSION
	BLEQ	70$			; NO, LIST IS AT MAXIMUM SIZE
	BSBB	EXTENDPAGE		; ATTEMPT TO ADD A PAGE
	TSTL	R0			; CHECK FOR SUCCESS
	BLSS	70$			; BR IF FAILED TO EXTEND
	MOVL	(R6),R0			; GET ADDRESS OF PARTIAL PACKET
	BNEQ	10$			; BR IF ONE PRESENT
	SUBL3	#512,(R3),R0		; COMPUTE ADDRESS OF NEW PAGE
	CLRL	(R0)			; INIT SIZE
10$:	MOVL	(R0),R1			; GET SIZE OF FRAGMENT
	MOVAB	512(R1),R1		; AND AUGMENT BY NEW PAGE
20$:	SUBL	R2,R1			; DIMINISH SIZE BY ONE PACKET
	BLSS	30$			; BRANCH IF INSUFFICIENT SPACE LEFT
	MOVW	R2,IRP$W_SIZE(R0)	; SET SIZE
	INCL	(R7)			; COUNT ANOTHER PACKET
	INSQUE	(R0),(R8)		; INSERT ON LIST
	ADDL	R2,R0			; ADVANCE ADDRESS
	BRB	20$			;
30$:	ADDL	R2,R1			; CORRECT SIZE OF FRAGMENT
	BEQL	40$			; BR IF NO FRAGMENT
	MOVL	R1,(R0)			; SAVE SIZE OF FRAGMENT
	BRB	50$			;
40$:	CLRL	R0			; ZAP FRAGMENT POINTER
50$:	MOVL	R0,(R6)			; SAVE NEW FRAGMENT POINTER
60$:	MOVL	#1,R0			; SET SUCCESS
	RSB
70$:	CLRL	R0			; SET FAILURE
	RSB				

	.PAGE
	.SBTTL	EXTENDPAGE - EXTEND SPECIFIED AREA BY ONE PAGE
;+
; EXTENDPAGE - EXTEND SPECIFIED AREA BY ONE PAGE
;
; THIS ROUTINE EXTENDS THE SPECIFIED AREA BY ONE PAGE PROVIDED THAT THE
; PAGE CAN BE ALLOCATED WITHOUT REDUCING THE FLUID PAGES BELOW THE NUMBER
; REQUIRED TO ACCOMODATE THE CURRENT MAXIMUM WORKING SET SIZE.  THE EXTENSION
; MAY ALSO BE PREVENTED IF NO PAGES ARE AVAILABLE OR THE SPECIFIED AREA IS
; FULL.
;
; INPUTS:
;
;	R3 = ADDRESS OF CELL CONTAINING VA TO BACK WITH PHYSICAL PAGE
;
; OUTPUTS:
;
;	R0 = COMPLETION STATUS, NEGATIVE MEANS FAILURE
;	@R3 = ADVANCED TO POINT TO THE NEXT PAGE IF SUCCESS
;
;	R1,R2,R3 PRESERVED
;-
EXTENDPAGE:
	MNEGL	#1,R0				; ASSUME FAILURE
	DSBINT	W^EXE$GL_NONPAGED		; SYNCHRONIZE
	PUSHR	#^M<R1,R2>			; SAVE REGISTERS
	EXTZV	#VA$V_VPN,#VA$S_VPN,(R3),R2	; GET VIRTUAL PAGE NUMBER
	MOVAL	@W^MMG$GL_SPTBASE[R2],R2	; COMPUTE SVAPTE
	TSTL	(R2)				; CHECK FOR EMPTY
	BNEQ	80$				; BR IF FILLED
	MOVZWL	W^MPW$GW_LOLIM,R1		; GET LOW LIMIT FOR MODIFY LIST
	ADDL	W^SGN$GL_FREELIM,R1		; ADD FREE LIST LIMIT
	SUBL3	R1,W^PFN$GL_PHYPGCNT,R1		; AND COMPUTE NET FLUID PAGE COUNT
	CMPL	R1,W^SGN$GL_MAXWSCNT		; COMPARE WITH MAX WORKING SET
	BLEQ	80$				; BR IF NO ROOM FOR GROWTH
	PUSHR	#^M<R1,R2,R3>			; SAVE VOLATILE REGISTERS
	BSBW	MMG$ALLOCPFN			; AND ATTEMPT TO ALLOCATE A PFN
	POPR	#^M<R1,R2,R3>			; RESTORE VOLATILE REGISTERS
	TSTL	R0				; CHECK STATUS
	BLSS	80$				; BR IF NO PAGE ALLOCATED
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,(R2) ; SET PAGE INTO SPT
	DECL	W^PFN$GL_PHYPGCNT		; ONE LESS FLUID PAGE
	ADDL	#512,(R3)			; ADVANCE POINTER TO NEXT PAGE
80$:	POPR	#^M<R1,R2>			; RESTORE REGISTERS
	ENBINT					; RESTORE IPL
	RSB


	.END
