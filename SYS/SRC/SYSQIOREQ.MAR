	.TITLE	SYSQIOREQ - QUEUE I/O REQUEST SYSTEM SERVICE
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; AUTHOR:
;
;	D. N. CUTLER,	14-JUN-76
;
; FACILITY:
;
;	SYSTEM SERVICE QUEUE I/O REQUEST
;
; MODIFIED BY:
;
;	V02-014	ACG0239		Andrew C. Goldstein,	11-Dec-1981  11:43
;		Permit I/O rundown functions to offline devices
;
;	V02-013	LJK0076		Lawrence J. Kenah	3-Nov-1981
;		Remove check for "queue previously not empty" when making
;		software interrupt request. The request is always made.
;
;	V02-012	ROW0041		Ralph O. Weber		27-OCT-1981
;		Modify as appropriate to assume that all DDT and FDT addresses 
;		are system virtual addresses.  Three sites modified; 
;		1) acquisition of FDT address in EXE$QIO, 2) FDT dispatching 
;		in EXE$QIO, 3) calling of alternate start routine in 
;		EXE$ALTQUEPKT.  A test for zero DDT$L_ALTSTART was also 
;		removed since the DDTAB macro will place IOC$RETURN in 
;		DDT$L_ALTSTART whenever that argument is omitted or given 
;		as zero.
;
;	V02-011 ROW0008		Ralph O. Weber		30-JUL-1981
;		Alter EXE$QIO and EXE$ALTQUEPKT to use UCB pointer to DDT
;		rather than DDB pointer.  Three sites modified; 1) locating 
;		the FDT, 2) allocating a diagnostic buffer, 3) locating 
;		the alternate start I/O routine.  Also removed an 
;		exteranous form-feed in EXE$ALTQUEPKT.
;
;	V02-010	RIH0040		RICHARD I. HUSTVEDT	11-MAY-1981
;		FIX WAIT CODE FOR ACCESS PENDING TO WAIT IN THE MODE
;		OF THE CALLER.
;
;	V02-009	RIH0001		RICHARD I. HUSTVEDT	25-AUG-1980
;		GENERAL PERFORMANCE ENHANCEMENT.  MAIN QIO PATH FOR COMMON
;		OPERATIONS WAS STRAIGHTENED TO MINIMIZE TAKEN BRANCHES AND
;		REMOVE SUBROUTINE CALLS.
;
;
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; MACRO LIBRARY CALLS
;
 
	$ACBDEF				;DEFINE ACB OFFSETS
	$AQBDEF				;DEFINE AQB OFFSETS
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$CCBDEF				;DEFINE CCB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEV VALUES
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$IODEF				;DEFINE IO FUNCTION CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PHDDEF				;DEFINE PHD OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRIDEF				;DEFINE PRIORITY CLASS INCREMENTS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RSNDEF				;DEFINE RESOURCE WAIT NUMBERS
	$SECDEF				;DEFINE SEC OFFSETS
	$SSDEF				;DEFINE STATUS VALUES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VCBDEF				;DEFINE VCB OFFSETS
	$WCBDEF				;DEFINE WINDOW CONTROL BLOCK OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
EFN=4					;EVENT FLAG NUMBER
CHAN=8					;I/O CHANNEL NUMBER
FUNC=12					;I/O FUNCTION CODE
IOSB=16					;ADDRESS OF I/O STATUS BLOCK
ASTADR=20				;ADDRESS OF AST SERVICE ROUTINE
ASTPRM=24				;AST SERVICE ROUTINE PARAMETER
P1=28					;FIRST FUNCTION DEPENDENT PARAMETER
P2=32					;SECOND FUNCTION DEPENDENT PARAMETER
P3=36					;THIRD FUNCTION DEPENDENT PARAMETER
P4=40					;FOURTH FUNCTION DEPENDENT PARAMETER
P5=44					;FIFTH FUNCTION DEPENDENT PARAMETER
P6=48					;SIXTH FUNCTION DEPENDENT PARAMETER
 
;
; FUNCTION DECISION TABLE OFFSET DEFINITIONS
;
 
LEGAL=0					;LEGAL FUNCTION MASK
IOTYPE=8				;I/O FUNCTION TYPE MASK
FDTACT=16				;ACTION ROUTINE MASKS
	.PAGE
	.SBTTL	QIO ERROR AND EXCEPTION HANDLING ROUTINES
;
; MISCELLANEOUS ERROR HANDLING AND EXCEPTION HANDLING ROUTINES.  THESE HAVE
; BEEN MOVED OUT OF LINE TO MAKE THE COMMON PATH NEARLY BRANCH FREE.
;

CLREF:					;
	BSBW	SCH$CLREF		;CLEAR SPECIFIED EVENT FLAG
	BRB	VCHAN			;CONTINUE WITH QIO
IVCHAN:	MOVZWL	#SS$_IVCHAN,R0		;SET ERROR STATUS
	BRB	ERRORB			;AND ERROR REQUEST
PRIVERR: MOVZWL	#SS$_NOPRIV,R0		;SET ERROR STATUS
ERRORB:	BRW	ERROR			;AND ERROR REQUEST

;
; An access or deaccess operation is pending for this channel.  Wait for 
; it to complete, then retry the QIO.
;

DACSPND:SETIPL	#IPL$_SYNCH		;SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVZWL	#RSN$_ASTWAIT,PCB$L_EFWM(R4) ;SET AST WAIT RESOURCE NUMBER
	MOVAQ	W^SCH$GQ_MWAIT,R2	;SET ADDRESS OF WAIT QUEUE
	BBSS	PCB$L_EFWM(R4),W^SCH$GL_RESMASK,10$ ;SET WAITING FLAG
10$:	BRW	SCH$WAIT		;WAIT FOR AST
;
; Device is marked spooled.  Acquire intermediate UCB address if virtual funtion.
;
SPOOL:	CMPL	S^#IO$_LOGICAL,R7	;VIRTUAL I/O FUNCTION?
	BGEQ	NSPOOL			;IF GEQ NO
	MOVL	UCB$L_AMB(R5),R5	;GET INTERMEDIATE DEVICE UCB ADDRESS
	BRB	NSPOOL			;
	.PAGE
	.SBTTL	QUEUE I/O REQUEST
;+
; EXE$QIOREQ - QUEUE I/O REQUEST
;
; THIS SERVICE PROVIDES THE CAPABILITY TO INITIATE AN I/O OPERATION
; BY QUEUEING A REQUEST TO A DEVICE'S ASSOCIATED DRIVER.  ONCE THE
; OPERATION HAS BEEN INITIATED, CONTROL WILL RETURN TO THE CALLER
; WHO CAN SYNCHRONIZE I/O COMPLETION IN ONE OF THREE WAYS:
;
;	1) SPECIFY THE ADDRESS OF AN AST ROUTINE THAT WILL BE
;	   EXECUTED WHEN THE I/O COMPLETES.
;
;	2) WAIT FOR THE SPECIFIED EVENT FLAG TO BE SET.
;
;	3) POLL THE SPECIFIED I/O STATUS BLOCK FOR A COMPLETION
;	   STATUS.
;
; THIS ROUTINE VERIFIES THE FUNCTION INDEPENDENT PARAMETERS, ALLOCATES
; AN I/O REQUEST PACKET, COPIES THE FUNCTION INDEPENDENT PARAMETERS AND
; PROCESS INFORMATION TO THE I/O PACKET, CHECKS ACCESS TO THE DEVICE,
; AND CALLS THE DRIVER'S FUNCTION DECISION TABLE ROUTINE(S) THAT CORRESPOND
; TO THE SPECIFIED FUNCTION.  IT IS THEN UP TO THE FDT ROUTINE TO EITHER
; COMPLETE THE REQUEST IMMEDIATELY (EXE$ABORTIO OR EXE$FINISHIO) OR TO
; QUEUE THE I/O REQUEST FOR FURTHER PROCESSING BY THE DRIVER'S STARTIO
; ROUTINE (EXE$QIODRVPKT).
;
; INPUTS:
;
;	EFN(AP) = EVENT FLAG NUMBER.
;	CHAN(AP) = I/O CHANNEL NUMBER.
;	FUNC(AP) = I/O FUNCTION CODE.
;	IOSB(AP) = ADDRESS OF I/O STATUS BLOCK.
;	ASTADR(AP) = ADDRESS OF AST SERVICE ROUTINE.
;	ASTPRM(AP) = AST SERVICE ROUTINE PARAMETER.
;	P1(AP) TO P6(AP) = FUNCTION DEPENDENT PARAMETERS.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO INITIATE THE I/O REQUEST.
;
;		R0 = SS$_ABORT - A NETWORK LOGICAL LINK WAS BROKEN.
;
;		R0 = SS$_ACCVIO - THE I/O STATUS BLOCK CANNOT BE WRITTEN BY
;			THE CALLER.
;
;		R0 = SS$_DEVOFFLINE - THE SPECIFIED DEVICE IS OFFLINE.
;
;		R0 = SS$_EXQUOTA - THE PROCESS HAS EXCEEDED ITS BUFFERED I/O
;			QUOTA, DIRECT I/O QUOTA, OR BUFFERED I/O BYTE COUNT
;			QUOTA AND HAS DISABLED RESOURCE WAIT MODE.  OR, THE
;			PROCESS HAS EXCEEDED ITS AST LIMIT QUOTA.
;
;		R0 = SS$_ILLEFC - AN ILLEGAL EVENT FLAG NUMBER WAS SPECIFIED.
;
;		R0 = SS$_INSFMEM - INSUFFICIENT DYNAMIC MEMORY IS AVAILABLE
;			TO ALLOCATE AN I/O REQUEST PACKET AND THE PROCESS HAS
;			DISABLED RESOURCE WAIT MODE.
;
;		R0 = SS$_IVCHAN - AN INVALID CHANNEL NUMBER WAS SPECIFIED.
;
;		R0 = SS$_NOPRIV - THE SPECIFIED CHANNEL DOES NOT EXIST OR WAS
;			ASSIGNED FROM A MORE PRIVILEGED ACCESS MODE.  OR, THE
;			PROCESS DOES NOT HAVE THE PRIVILEGE TO PERFORM THE
;			SPECIFIED TYPE OF I/O FUNCTION ON THE DEVICE.
;
;		R0 = SS$_UNASEFC - UNASSOCIATED EVENT FLAG CLUSTER SPECIFIED.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENTRY	EXE$QIO,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; Clear specified event flag.  For local event flags, this is done in line.
;

QIO:	MOVZBL	EFN(AP),R3		;GET EVENT FLAG NUMBER
	CMPB	R3,#63			;CHECK FOR LOCAL
	BGTRU	CLREF			;IF NO, MUST DO FULL CLREF
	BBCC	R3,PCB$L_EFCS(R4),VCHAN	;CLEAR SPECIFIED EVENT FLAG

;
; Validate channel number, compute CCB address and acquire UCB address.
;

VCHAN:	BICL3	#<^XFFFF0000!<CCB$C_LENGTH-1>>,-;FETCH CHANNEL NUMBER AND
		CHAN(AP),R0 		;CLEAR EXTRANEOUS BITS
	BEQL	IVCHAN			;IF EQL INVALID CHANNEL
	CMPW	R0,@#CTL$GW_CHINDX	;LEGAL CHANNEL NUMBER?
	BGTRU	IVCHAN			;IF GTRU NO
	MNEGL	R0,R9			;CONVERT TO CHANNEL INDEX
	MOVAB	@CTL$GL_CCBBASE[R9],R6	;GET ADDRESS OF CORRESPONDING CCB
	MOVPSL	R3			;READ CURRENT PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R3,R11 ;EXTRACT PREVIOUS MODE FIELD
	ASHL	#16,R9,R9		;PREPARE CHANNEL INDEX FOR LATER MERGE
	CMPB	R11,CCB$B_AMOD(R6)	;CALLER HAVE PRIVILEGE TO ACCESS CHANNEL?
	BGEQ	PRIVERR			;IF GEQ NO
	MOVL	CCB$L_UCB(R6),R5	;GET ASSIGNED DEVICE UCB ADDRESS
 	BLBS	CCB$L_WIND(R6),DACSPND	;IF LBS ACCESS/DEACCESS PENDING

;
; Isolate function code and begin decoding
;

	MOVZWL	FUNC(AP),R10		;GET I/O FUNCTION CODE AND MODIFIERS
	BICL3	#^C<IO$M_FCODE>,R10,R7	;CLEAR ALL BUT I/O FUNCTION CODE
	BBS	S^#DEV$V_SPL,UCB$L_DEVCHAR(R5),SPOOL ;IF SET, DEVICE IS SPOOLED

;
; Acquire FDT address.
;

NSPOOL:	MOVL	UCB$L_DDT(R5),R0	;GET ADDRESS OF DDT
	MOVL	DDT$L_FDT(R0),R8	;GET ADDRESS OF FDT
	BBC	R7,LEGAL(R8),ILLIO	;IF CLR, ILLEGAL I/O FUNCTION
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),OFFLINE ;IF CLR, DEVICE OFFLINE

;
; Probe and clear IOSB if it is specified.
;

PRIOSB:	MOVL	IOSB(AP),R1		;GET ADDRESS OF I/O STATUS BLOCK
	BEQL	NOIOSB			;IF EQL NONE SPECIFIED
	IFNOWRT	#8,(R1),ACCVIO		;CAN I/O STATUS BLOCK BE WRITTEN?
	CLRQ	(R1)			;CLEAR I/O STATUS BLOCK

;
; Charge appropriate I/O counts depending upon type.  Counts will have to
; be backed out if no I/O packet is available.  Set IPL to block process
; deletion once we are committed.
;

NOIOSB:	SETIPL	#IPL$_ASTDEL		;PREVENT PROCESS DELETION
	BBC	R7,IOTYPE(R8),DIRECT	;IF CLR, DIRECT I/O FUNCTION
	ASSUME	IRP$M_BUFIO EQ 1	;TO ALLOW INCREMENT BELOW
	INCW	R9			;SET IRP$M_BUFIO
	DECW	PCB$W_BIOCNT(R4)	;CHARGE FOR ANOTHER BUFFERED I/O
	BGEQ	OK			;OK IF NOT NEGATIVE
	PUSHAW	PCB$W_BIOCNT(R4)	;SET ADDRESS OF QUOTA CELL
NOCNT:	MOVL	(SP),R2			;FETCH QUOTA ADDRESS
	INCW	(R2)			;BACKOUT CHARGE
	BSBW	EXE$SNGLEQUOTA		;CHECK UNIT QUOTA OF I/O FUNCTION TYPE
	BLBC	R0,ERROR		;IF LBC QUOTA EXCEEDED
	DECW	@(SP)+			;CHARGE FOR I/O OF TYPE
	BRB	OK			;

ILLIO:	MOVZWL	#SS$_ILLIOFUNC,R0	;SET ILLEGAL I/O FUNCTION STATUS
	BRB	ERROR			;

OFFLINE:CMPB	#IO$_DEACCESS,R7	;CHECK FOR DEACCESS I/O FUNCTION
	BEQL	PRIOSB			;ALLOW IT TO PROCEED
	CMPB	#IO$_ACPCONTROL,R7	;LIKEWISE FOR ACP CONTROL
	BEQL	PRIOSB			;SO THAT A FILE ON AN OFFLINE DEVICE
					;MAY BE CLOSED
	MOVZWL	#SS$_DEVOFFLINE,R0	;SET DEVICE OFFLINE STATUS
	BRB	ERROR			;

ACCVIO:	MOVZWL	S^#SS$_ACCVIO,R0	;SET ACCESS VIOLATION STATUS
ERROR:	SETIPL	#0			;ALLOW INTERRUPTS
	PUSHL	R0			;SAVE FINAL STATUS
	MOVL	PCB$L_PID(R4),R1	;GET PROCESS ID OF CURRENT PROCESS
	CLRL	R2			;SET PRIORITY CLASS INCREMENT
	MOVZBL	EFN(AP),R3		;GET SPECIFIED EVENT FLAG NUMBER
	BSBW	SCH$POSTEF		;POST SPECIFIED EVENT FLAG
	POPR	#^M<R0>			;RESTORE FINAL STATUS
	RET				;
 
;
; ALLOCATE REQUEST I/O PACKET - WHEN THE LOOKASIDE LIST IS EMPTY.
;
 
ALLOC:	BSBW	EXE$ALLOCIRP		;ALLOCATE I/O REQUEST PACKET
	BLBS	R0,SUCCES		;IF LBS SUCCESSFUL ALLOCATION
	PUSHAW	PCB$W_BIOCNT(R4)	;ASSUME BUFFERED I/O
	BLBS	R9,NALLOC		;IF SET, BUFFERED I/O
	PUSHAW	PCB$W_DIOCNT(R4)	;ELSE DIRECT I/O
NALLOC:	INCW	@(SP)+			;RESTORE COUNT, SINCE NO I/O STARTED
	BRB	ERROR			;

;
; Convert section index to window address.
;

SECTION:CVTWL	CCB$L_WIND(R6),R0	;SIGN EXTEND SECTION INDEX
	MOVL	@#CTL$GL_PHD,R1		;GET ADDRESS OF PROCESS HEADER
	ADDL	PHD$L_PSTBASOFF(R1),R1	;CALCULATE BASE ADDRESS OF SECTION TABLE
	MOVL	SEC$L_WINDOW(R1)[R0],-4(R2)	;GET ADDRESS OF REAL WINDOW
	BRB	NOSECT			;

	.IF DF	CA$_MEASURE_IOT
 
STARTRQ:BSBW	PMS$START_RQ		;INSERT START OF I/O REQUEST MESSAGE
	BRW	PMSDONE			;

	.ENDC

NODCNT:	PUSHAW	PCB$W_DIOCNT(R4)	;SET FOR DIRECT I/O FUNCTION
	BRB	NOCNT			;

DIRECT:	DECW	PCB$W_DIOCNT(R4)	;CHARGE FOR ANOTHER DIRECT I/O
	BLSS	NODCNT			;BR IF NONE ALLOWED
OK:	
GTPKT:	REMQUE	@W^IOC$GL_IRPFL,R2	;GET I/O PACKET FROM LOOK ASIDE LIST
	BVS	ALLOC			;IF VS EMPTY LIST
 
;
; BUILD DEVICE INDEPENDENT PART OF I/O PACKET
;
; R2 - IRP Address
; R4 - PCB Address
; R5 - UCB Address
; R6 - CCB Address
; R7 - Function code (original)
; R8 - FDT address
; R9 - Channel index @ 16 + (IRP$M_BUFIO -- if buffered I/O)
; R10 - Function code (transformed)
; R11 - Access mode
;
SUCCES:	INCW	CCB$W_IOC(R6)		;INCREMENT OUTSTANDING I/O ON CHANNEL
	ASSUME	IRP$W_SIZE EQ 8		;FOR FOLLOWING OPTIMIZATION
	MOVAQ	(R2)+,R3		;COPY ADDRESS AND ADD IRP$W_SIZE TO R2
	MOVQ	ASTADR(AP),R0		;INSERT AST ADDRESS AND PARAMETER
	MOVL	PCB$L_ARB(R4),IRP$L_ARB(R3) ;COPY ACCESS RIGHTS BLOCK ADDRESS
	ASSUME	IRP$B_RMOD EQ 11	;FOR SHIFT BELOW
	TSTL	R0			;CHECK FOR AST
	BEQL	5$			;NONE
	BISB	#ACB$M_QUOTA,R11	;NOTE QUOTA CHARGE
	DECW	PCB$W_ASTCNT(R4)	;CHARGE QUOTA
5$:	ASHL	#24,R11,R11		;ALIGN ACCESS MODE 
	ASSUME	IRP$B_TYPE EQ 10	;FOR BISL BELOW
	BISL3	R11,#<<DYN$C_IRP@16>!IRP$C_LENGTH>,(R2)+ ;INSERT TYPE AND LENGTH
	ROTL	#16,PCB$B_PRIB-3(R4),R11;FETCH AND ALIGN PRIORITY
	ASSUME	IRP$L_PID EQ 12		;
	MOVL	PCB$L_PID(R4),(R2)+	;INSERT PROCESS ID OF CURRENT PROCESS
	MOVB	EFN(AP),R11		;MERGE EVENT FLAG NUMBER

	ASSUME	IRP$L_AST EQ 16		;FOR MOVQ BELOW
	ASSUME	IRP$L_ASTPRM EQ 20	;FOR MOVQ BELOW
	MOVQ	R0,(R2)+		;INSERT AST ADDRESS AND PARAMETER
	ROTL	#16,R11,R11		;ALIGN PRIORITY AND EVENT FLAG NUMBER

	ASSUME	IRP$L_WIND EQ 24
	MOVL	CCB$L_WIND(R6),(R2)+	;GET WINDOW ADDRESS
	BGTR	SECTION			;BR IF SECTION INDEX

	ASSUME	IRP$L_UCB EQ 28
NOSECT:	MOVL	R5,(R2)+		;INSERT DEVICE UCB ADDRESS
	ASSUME	IRP$W_FUNC EQ 32
	MOVW	R10,R11			;MERGE I/O FUNCTION CODE
	ASSUME	IRP$B_EFN EQ 34
	ASSUME	IRP$B_PRI EQ 35
	ASSUME	IRP$L_IOSB EQ 36
	MOVL	R11,(R2)+		;INSERT PRI,EFN,FUNC
	ADDL	#FDTACT-12,R8		;POINT TO ACTION ROUTINE MASKS
	MOVL	IOSB(AP),(R2)+		;INSERT I/O STATUS BLOCK ADDRESS
	ADDL	#P1,AP			;POINT TO FIRST FUNCTION DEPENDENT PARAMETER
	ASSUME	IRP$W_CHAN EQ 40
	ASSUME	IRP$W_STS EQ 42
	ROTL	#16,R9,(R2)+		;INSERT CHANNEL INDEX AND STATUS
	BICL3	#1,R7,R9		;PREPARE FOR VIRTUAL CHECK BELOW
	CLRQ	(R2)+			;CLEAR PTE ADDRESS, BYTE OFFSET, AND BYTE COUNT
	CLRL	(R2)			;

	.IF DF	CA$_MEASURE_IOT
	TSTL	W^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	STARTRQ			;BR IF YES
	.ENDC

	SETIPL	#15			;DISABLE SOFTWARE INTERRUPTS
	MOVL	W^PMS$GL_IOPFMSEQ,IRP$L_SEQNUM(R3) ;INSERT PACKET SEQUENCE NUMBER
	INCL	W^PMS$GL_IOPFMSEQ	;INCREMENT I/O TRANSACTION SEQUENCE NUMBER
	SETIPL	#IPL$_ASTDEL		;ENABLE INTERRUPTS
 
PMSDONE:				;
	MOVL	UCB$L_DEVCHAR(R5),R11	;GET DEVICE CHARACTISTICS FOR MANY
					;COMPARES BELOW 
;
; CHECK IF REQUESTING PROCESS HAS PRIVILEGE TO ACCESS DEVICE
;
; NOTE: LOW BIT OF FUNCTION CODE WAS CLEARED ABOVE
;
	ASSUME	IO$_READVBLK-IO$_WRITEVBLK EQ 1 
ACCESS:	CMPL	S^#IO$_WRITEVBLK,R9	;VIRTUAL READ OR WRITE?
	BNEQ	15$			;IF NEQ NO
	BBC	S^#DEV$V_FOD,R11,5$ 	;IF CLR, NOT FILE DEVICE
 
;
; THE FOLLOWING TEST IS NECESSITATED BY THE SYSTEM INITIALIZATION SEQUENCE
;
 
	TSTL	IRP$L_WIND(R3)		;WINDOW ADDRESS SPECIFIED?
	BNEQ	90$			;IF NEQ YES
	BBC	S^#DEV$V_MNT,R11,60$ 	;IF CLR, DEVICE NOT MOUNTED
	BBC	S^#DEV$V_FOR,R11,80$ 	;IF CLR, MOUNTED STRUCTURED
 
;
; CONVERT VIRTUAL READ/WRITE FUNCTION TO ITS LOGICAL COUNTERPART
;
 
5$:	SUBL	S^#IO$_READVBLK-IO$_READLBLK,R7 ;CONVERT TO LOGICAL FUNCTION
	SUBW	S^#IO$_READVBLK-IO$_READLBLK,IRP$W_FUNC(R3) ;
	BITL	#<DEV$M_SPL!-		;NOT SPOOLED,
		DEV$M_FOD!-		;NOT FILE DEVICE,
		DEV$M_SHR>,R11 		;AND NOT SHARABLE
	BNEQ	15$			;BR IF SATISFIED
;
; CHECK IF AST QUOTA IS EXCEEDED
;
 
90$:	TSTW	PCB$W_ASTCNT(R4)	;AST QUEUE ENTRY QUOTA EXCEEDED?
	BLSS	75$			;IF LEQ YES
 
;
; SCAN FUNCTION DECISION TABLE CALLING EACH SELECTED ACTION ROUTINE WITH:
;
;	R0 = ADDRESS OF ACTION ROUTINE ENTRY POINT.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FDT DISPATCH ADDRESS. (UPDATED TO POINT TO ACTION ROUTINE MASKS)
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
;	NB: in the Guide to Writing a Device Driver, we document the contents 
;	of R0 as being the address of the FDT action routine entry point.  
;	This is the only reason that the dispatch code below does not read:
;		JSB	@8(R8)
;	Should future gererations wish to modify FDT dispatching to use the 
;	single dispatch instruction, they must bear the responsibility for 
;	breaking user written drivers.
 
110$:	ADDL	#12,R8			;POINT TO NEXT FUNCTION MASK
	BBC	R7,(R8),110$		;IF CLR, THEN ACTION NOT SELECTED
	MOVL	8(R8),R0		;GET ADDRESS OF ACTION ROUTINE
	JSB	(R0)			;CALL ACTION ROUTINE
	BRB	110$			;

;
; CONTINUE DECODING FUNCTIONS OTHER THAN VIRTUAL READ/WRITE
;

15$:	CMPL	S^#IO$_LOGICAL,R7	;VIRTUAL I/O FUNCTION?
	BLSS	80$			;IF LSS YES
 
;
; LOGICAL OR PHYSICAL I/O FUNCTION
;
 
	IFPRIV	PHY_IO,80$		;PROCESS HAVE PHYSICAL I/O PRIVILEGE?
	CMPL	S^#IO$_PHYSICAL,R7	;PHYSICAL I/O FUNCTION?
	BLSS	20$			;IF LSS NO
	IFNPRIV	LOG_IO,60$		;PROCESS HAVE LOGICAL I/O PRIVILEGE?
	MOVAB	W^EXE$CHKPHYACCES,R10	;SET FOR PHYSICAL I/O FUNCTION CHECK
	BRB	30$			;

40$:	BBC	S^#DEV$V_SHR,R11,80$ 	;IF CLR, DEVICE NOT SHAREABLE
50$:	MOVZWL	UCB$W_VPROT(R5),R1	;GET VOLUME PROTECTION MASK
	MOVL	UCB$L_OWNUIC(R5),R2	;GET VOLUME OWNER UIC
	MOVL	PCB$L_ARB(R4),R0	;GET ACCESS RIGHTS BLOCK
	JSB	(R10)			;CHECK ACCESS TO VOLUME
	BLBS	R0,80$			;IF LBS ACCESS ALLOWED
60$:	MOVZWL	#SS$_NOPRIV,R0		;SET NO PRIVILEGE STATUS
70$:	BRW	EXE$ABORTIO		;
75$:	TSTL	IRP$L_AST(R3)		;DOES THIS REQUEST NEED AN AST?
	BEQL	110$			;NO, THEN CAN'T BE QUOTA EXCEEDED.
	MOVZWL	#SS$_EXQUOTA,R0		;AST QUOTA EXCEEDED
 	BRB	70$			;
;
; PROCESS HAS ACCESS TO DEVICE
;
 
80$:	CMPL	S^#IO$_PHYSICAL,R7	;LOGICAL OR VIRTUAL I/O FUNCTION?
	BLSS	90$			;IF LSS YES
	BISW	#IRP$M_PHYSIO,IRP$W_STS(R3) ;SET PHYSICAL I/O FLAG
	MOVL	<P6-P1>(AP),R9		;GET ADDRESS OF DIAGNOSTIC BUFFER
	BEQL	90$			;IF EQL THEN NOT SPECIFIED
;
; Process diagnostic buffer parameter
;
	IFNPRIV	DIAGNOSE,60$		;PROCESS HAVE PRIVILEGE TO DIAGNOSE?
	MOVL	UCB$L_DDT(R5),R1	;GET ADDRESS OF DDT
	MOVZWL	DDT$W_DIAGBUF(R1),R1	;GET SIZE OF DIAGNOSTIC BUFFER
	BEQL	90$			;IF EQL NO DIAGNOSTIC FUNCTIONS
	PUSHL	R3			;SAVE I/O PACKET ADDRESS
	BSBW	EXE$ALLOCBUF		;ALLOCATE DIAGNOSTIC BUFFER
	POPL	R3			;RETRIEVE I/O PACKET ADDRESS
	BLBC	R0,70$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,IRP$L_DIAGBUF(R3)	;SAVE ADDRESS OF DIAGNOSTIC BUFFER
	MOVAB	12(R2),(R2)+		;SET POINTER TO DATA AREA
	MOVL	R9,(R2)			;SAVE USER ADDRESS OF DIAGNOSTIC BUFFER
	BISW	#IRP$M_DIAGBUF,IRP$W_STS(R3) ;SET DIAGNOSTIC BUFFER PRESENT
130$:	BRW	90$
;
; LOGICAL I/O FUNCTION
;
 
20$:	IFPRIV	LOG_IO,130$		;PROCESS HAVE LOGICAL I/O PRIVILEGE?
	MOVAB	W^EXE$CHKLOGACCES,R10	;SET FOR LOGICAL I/O FUNCTION CHECK
 
;
; PHYSICAL OR LOGICAL I/O FUNCTION - CHECK ACCESSIBILITY OF DEVICE
;
 
30$:	BBS	S^#DEV$V_SPL,R11,60$ 	;IF SET, SPOOLED DEVICE
	BBC	S^#DEV$V_FOD,R11,40$ 	;IF CLR, NOT FILE DEVICE
	BBC	S^#DEV$V_MNT,R11,60$ 	;IF CLR, DEVICE NOT MOUNTED
	BBC	S^#DEV$V_FOR,R11,60$ 	;IF CLR, MOUNTED STRUCTURED
	BRW	50$			;
	.PAGE
	.SBTTL	BUILD I/O PACKET FOR PAGE READ/WRITE
;+
; EXE$BUILDPKTR - BUILD I/O PACKET FOR PAGE READ
; EXE$BUILDPKTW - BUILD I/O PACKET FOR PAGE WRITE
; EXE$BLDPKTSWPR - BUILD I/O PACKET FOR SWAP READ
; EXE$BLDPKTSWPW - BUILD I/O PACKET FOR SWAP WRITE
; EXE$BLDPKTGSR - BUILD I/O PACKET FOR SHARED MEMORY GLOBAL SECTION READ
; EXE$BLDPKTGSW - BUILD I/O PACKET FOR SHARED MEMORY GLOBAL SECTION WRITE
;
; THIS ROUTINE IS CALLED TO FILL OUT AND QUEUE AN I/O PACKET
; FOR A SWAPPING OR PAGING READ OR WRITE.
;
; INPUTS:
;
;	R0 = VIRTUAL BLOCK NUMBER
;	R1 = NUMBER OF BYTES TO TRANSFER (PAGE INCREMENTS)
;	R2 = WINDOW ADDRESS FOR MAPPING VBN TO LBN
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4 = CURRENT PROCESS CONTROL BLOCK ADDRESS
;	     PCB$W_DIOCNT(R4) IS ASSUMED GREATER THAN ZERO
;	     AND MUST BE CHECKED BY THE CALLER.
;	R5 = I/O REQUEST PACKET ADDRESS
;	     WITH THE FOLLOWING FIELDS ALREADY FILLED IN
;
;	IRP$W_SIZE(R5) AND IRP$B_TYPE(R5)
;	    FOR ENTRY AT EXE$BUILDPKTW, EXE$BLDPKTGSR, AND EXE$BLDPKTGSW,
;		THESE ARE FILLED IN BY THE CALL.  FOR ALL OTHER ENTRY POINTS
;		THEY ARE FILLED IN BY THIS CODE.
;	IRP$L_AST(R5) =
;	     FOR PAGE READ CASE - SYSTEM VIRTUAL ADDRESS OF SLAVE (PROCESS)
;		PAGE TABLE ENTRY FOR THE CASE OF A GLOBAL PAGE READ.
;		THIS MUST BE 0 FOR A SYSTEM OR PROCESS PAGE READ.
;	     FOR PAGE WRITE CASE - STANDARD QI/O AST ADDRESS
;	     FOR SWAPIO CASE - THIS PARAMETER IS CURRENTLY NOT USED
;
;	IRP$L_ASTPRM(R5) =
;	     FOR PAGE READ CASE - THE CONTENTS OF THE FAULTED PAGE TABLE ENTRY
;		USED TO RECOVER THE ORIGINAL BACKING STORE ADDRESS WHEN A PAGE
;		READ ERROR OCCURRED FOR A COPY ON REFERENCE PAGE.
;	     FOR PAGE WRITE CASE - STANDARD QI/O AST PARAMETER
;	     FOR SWAPIO CASE - ADDRESS OF KERNEL AST ROUTINE TO CALL
;
;	IRP$B_PRI(R5) = THE PRIORITY AT WHICH THE TRANSFER IS TO BE QUEUED
;
;	IRP$B_RMOD(R5) =
;	    FOR PAGE WRITE CASE - STANDARD QI/O MODE OF REQUESTER
;	    FOR ALL OTHER CASES - CONTAINS GARBAGE WHICH IS IGNORED
;
;	IRP$B_EFN(R5)  =
;	    FOR PAGE WRITE CASE - STANDARD QI/O EVENT FLAG NUMBER
;	    FOR ALL OTHER CASES - CONTAINS GARBAGE WHICH IS IGNORED
;
;	IRP$L_IOSB(R5) =
;	    FOR PAGE WRITE CASE - STANDARD QI/O I/O STATUS BLOCK ADDRESS
;	    FOR ALL OTHER CASES - CONTAINS GARBAGE WHICH IS IGNORED
;
; OUTPUTS:
;
;	R4,R5 ALTERED
;-

	.ENABL	LSB
EXE$BLDPKTGSR::
	PUSHL	#<<IRP$M_SWAPIO ! IRP$M_VIRTUAL ! IRP$M_FUNC>@16 -
		! IO$_READPBLK>		;SET FOR READ FUNCTION
	BRB	20$			;TYPE/SIZE ALREADY SET IN PACKET
EXE$BLDPKTGSW::
	PUSHL	#<<IRP$M_SWAPIO ! IRP$M_VIRTUAL>@16 -
		! IO$_WRITEPBLK>	;SET FOR READ FUNCTION
	BRB	20$			;TYPE/SIZE ALREADY SET IN PACKET
EXE$BLDPKTSWPR::			;BUILD SWAP READ PACKET
	PUSHL	#<<IRP$M_SWAPIO ! IRP$M_VIRTUAL ! IRP$M_FUNC>@16 -
		! IO$_READPBLK>		;SET FOR READ FUNCTION
	BRB	10$			;
EXE$BLDPKTSWPW::			;BUILD SWAP WRITE PACKET
	PUSHL	#<<IRP$M_SWAPIO ! IRP$M_VIRTUAL>@16 -
		! IO$_WRITEPBLK>	;SET FOR WRITE FUNCTION
	BRB	10$			;
EXE$BUILDPKTW::				;BUILD I/O PACKET FOR PAGE WRITE
	PUSHL	#<<IRP$M_PAGIO ! IRP$M_VIRTUAL>@16 -
		! IO$_WRITEPBLK>	;SET FOR WRITE FUNCTION
	BRB	20$			;
EXE$BUILDPKTR::				;BUILD I/O PACKET FOR PAGE READ
	PUSHL	#<<IRP$M_PAGIO ! IRP$M_VIRTUAL ! IRP$M_FUNC>@16 -
		! IO$_READPBLK>		;SET FOR READ FUNCTION
10$:	INSV	#<DYN$C_IRP@16 ! IRP$C_LENGTH>,- ;SET SIZE
		#0,#24,IRP$W_SIZE(R5)	;AND TYPE OF PACKET
20$:	MOVL	R3,IRP$L_SVAPTE(R5)	;SYSTEM VIRTUAL ADR OF PAGE TABLE ENTRY
	MOVL	R3,IRP$L_DIAGBUF(R5)	;NEED COPY OF ORIGINAL FOR SEGMENTED XFERS
	MOVL	R5,R3			;PACKET ADDRESS TO R3
	MOVL	(SP)+,R5		;GET FUNCTION AND STATUS BITS
	MOVW	R5,IRP$W_FUNC(R3)	;SET FUNCTION CODE

	ASSUME	IRP$W_STS EQ IRP$W_CHAN+2
	CLRW	R5			;ZERO THE CHANNEL
	MOVL	R5,IRP$W_CHAN(R3)	;SET CHANNEL AND STATUS
	MOVL	WCB$L_ORGUCB(R2),R5	;GET UCB ADDRESS FROM WINDOW
	MOVL	R5,IRP$L_UCB(R3)	;SET UCB ADDRESS
	MOVL	PCB$L_PID(R4),IRP$L_PID(R3) ;PROCESS ID FROM PCB
	MOVL	R0,IRP$L_SEGVBN(R3)	;STARTING VIRTUAL BLOCK NUMBER
	MOVL	R2,IRP$L_WIND(R3)	;WINDOW ADDRESS
	MOVL	PCB$L_ARB(R4),IRP$L_ARB(R3) ;ACCESS RIGHTS BLOCK ADDRESS

	CLRW	IRP$W_BOFF(R3)		;ZERO BYTE OFFSET
	MOVL	R1,IRP$L_BCNT(R3)	;SET BYTE COUNT
	CLRL	IRP$L_ABCNT(R3)		;ZERO ACCUMULATED BYTE COUNT
	MOVL	R1,IRP$L_OBCNT(R3)	;SET ORIGINAL BYTE COUNT

	.IF	DF,CA$_MEASURE_IOT

	BSBW	PMS$START_RQ		;INSERT START OF I/O REQUEST MESSAGE

	.ENDC

	BRW	IOC$QNXTSEG1		;QUEUE THE FIRST SEGMENT OF THE I/O REQUEST
					;AND RETURN
	.DSABL	LSB
	.PAGE
	.SBTTL	COMPLETE I/O OPERATION
;+
; EXE$ABORTIO - ABORT I/O OPERATION
;
; THIS ROUTINE IS JUMPED TO FROM A FUNCTION DECISION TABLE ACTION ROUTINE
; TO FINISH AN I/O OPERATION WITHOUT RETURNING THE FINAL I/O STATUS.
;
; EXE$FINISHIO - FINISH I/O OPERATION
;
; THIS ROUTINE IS JUMPED TO FROM A FUNCTION DECISION TABLE ACTION ROUTINE
; TO FINISH AN I/O OPERATION AND RETURN THE FINAL I/O STATUS.
;
; EXE$FINISHIOC - FINISH I/O OPERATION WITH SECOND I/O STATUS LONGWORD CLEARED
;
; THIS ROUTINE IS JUMPED TO FROM A FUNCTION DESCISION TABLE ACTION ROUTINE
; TO FINISH AN I/O OPERATION AND RETURN THE FINAL I/O STATUS WITH THE
; SECOND I/O STATUS LONGWORD CLEARED.
;
; INPUTS:
;
;	R0 = FIRST LONGWORD OF FINAL I/O STATUS.
;	R1 = SECOND LONGWORD OF FINAL I/O STATUS.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE FINAL I/O STATUS IS STORED IN THE I/O PACKET AND THE PACKET IS
;	INSERTED IN THE I/O POST PROCESSING QUEUE. A SOFTWARE INTERRUPT
;	IS GENERATED TO INITIATE I/O POST PROCESSING AND THE FIRST WORD
;	OF THE FINAL I/O STATUS IS RETURNED AS THE SERVICE STATUS.
;-
 
	.ENABL	LSB
EXE$ABORTIO::				;ABORT I/O OPERATION
	CLRL	IRP$L_IOSB(R3)		;CLEAR ADDRESS OF I/O STATUS BLOCK
	BBCC	#ACB$V_QUOTA,IRP$B_RMOD(R3),10$ ;IF CLR, NO AST SPECIFIED
	INCW	PCB$W_ASTCNT(R4)	;UPDATE AVAILABLE AST QUEUE ENTRIES
	BRB	10$			;
EXE$FINISHIOC::				;FINISH I/O OPERATION CLEAR SECOND LONGWORD
	CLRL	R1			;CLEAR SECOND I/O STATUS LONGWORD
EXE$FINISHIO::				;FINISH I/O OPERATION
	INCL	UCB$L_OPCNT(R5)		;INCREMENT OPERATIONS COMPLETED
	MOVQ	R0,IRP$L_MEDIA(R3)	;STORE FINAL I/O STATUS
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
10$:	INSQUE	(R3),@W^IOC$GL_PSBL	;INSERT I/O PACKET IN POST PROCESS QUEUE
	SOFTINT	#IPL$_IOPOST		;INITIATE SOFTWARE INTERRUPT
	BRB	QIORETURN		;
	.DSABL	LSB
	.PAGE
	.SBTTL	QUEUE I/O PACKET TO DRIVER
;+
; EXE$QIODRVPKT - QUEUE I/O PACKET TO DRIVER
;
; THIS ROUTINE IS JUMPED TO FROM A FUNCTION DECISION TABLE ACTION ROUTINE
; TO QUEUE AN I/O PACKET TO THE APPROPRIATE DRIVER.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE I/O PACKET IS QUEUED BY PRIORITY IN THE APPROPRIATE DEVICE
;	QUEUE AND A NORMAL COMPLETION STATUS IS RETURNED.
;-
 
EXE$QIODRVPKT::				;QUEUE I/O PACKET
	BSBB	EXE$INSIOQ		;INSERT I/O PACKET IN DEVICE QUEUE
	BRB	EXE$QIORETURN		;
	.PAGE
	.SBTTL	EXE$ALTQUEPKT - Call driver ALTSTART entry point

;
; EXE$ALTQUEPKT - activates a driver at its ALTSTART entry point
;
; Routine description:
;
;	Locates and calls a driver entry point supplied as an alternate
;	START I/O entry point. Does not test for unit busy before the
;	call. Exits by returning to caller.
;
;	The routine expects to gain control at or below driver fork
;	level. The routine raises to driver fork IPL before the call,
;	and restores the previous IPL before returning to its caller.
;
; Inputs:
;
;	R3	- address of packet or buffer
;	R5	- address of UCB
;
; Outputs:
;
;	Control returns to the requesting process.
;
;	The routine destroys R0-R1.
;
;--

EXE$ALTQUEPKT::				; Start I/O in driver.
	DSBINT	UCB$B_FIPL(R5)		; Raise to fork IPL.
	MOVL	UCB$L_DDT(R5),R0	; Get address of unit's DDT.
	JSB	@DDT$L_ALTSTART(R0)	; Call alternate start I/O routine.
	ENBINT				; Reenable interrupts.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	QUEUE I/O PACKET TO ACP
;+
; EXE$QIOACPPKT - QUEUE I/O PACKET TO ACP
;
; THIS ROUTINE IS JUMPED TO FROM A FUNCTION DECISION TABLE ACTION ROUTINE
; TO QUEUE AN I/O PACKET TO THE APPROPRIATE ACP.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
;	CURRENT IPL MUST BE AT SYNCH OR HIGHER LEVEL.
;
; OUTPUTS:
;
;	R4 ALTERED
;	THE I/O PACKET IS QUEUED AT THE END OF THE APPROPRIATE ACP QUEUE
;	AND A NORMAL COMPLETION STATUS IS RETURNED.
;-
 
EXE$QIOACPPKT::				;QUEUE I/O PACKET TO ACP
	MOVL	UCB$L_VCB(R5),R2	;GET ADDRESS OF VCB
	MOVL	VCB$L_AQB(R2),R2	;GET ADDRESS OF ACP AQB
	BSBB	EXE$INSERTIRP		;INSERT I/O PACKET IN ACP QUEUE
	BNEQ	EXE$QIORETURN		;IF NEQ NOT FIRST ENTRY IN QUEUE
	MOVL	AQB$L_ACPPID(R2),R1	;GET ACP PROCESS ID
	BSBW	SCH$WAKE		;WAKE UP ACP PROCESS
	BLBS	R0,EXE$QIORETURN	;IF LBS ACP STILL PRESENT
	BUG_CHECK NONEXSTACP		;NONEXISTENT ACP PROCESS
EXE$QIORETURN::				;QUEUE I/O REQUEST COMPLETION STATUS RETURN
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
QIORETURN:				;RETURN SPECIFIED STATUS
	SETIPL	#0			;ALLOW ALL INTERRUPTS
	RET				;
	.PAGE
	.SBTTL	INSERT I/O PACKET IN UNIT QUEUE
;+
; EXE$INSIOQ - INSERT I/O PACKET IN UNIT QUEUE
;
; THIS ROUTINE IS CALLED TO INSERT AN I/O PACKET IN A UNIT QUEUE AND CALL
; THE APPROPRIATE I/O DRIVER IF THE UNIT IS NOT BUSY.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;-
 
EXE$INSIOQ::				;INSERT IN I/O QUEUE
	DSBINT	UCB$B_FIPL(R5)		;RAISE IPL TO FORK LEVEL
	BBSS	#UCB$V_BSY,UCB$W_STS(R5),10$ ;IF SET, THEN DEVICE IS BUSY
	BSBW	IOC$INITIATE		;INITIATE I/O FUNCTION
	BRB	20$			;
10$:	MOVAL	UCB$L_IOQFL(R5),R2	;GET ADDRESS OF I/O QUEUE LISTHEAD
	BSBB	EXE$INSERTIRP		;INSERT I/O PACKET IN DEVICE QUEUE
20$:	ENBINT				;ENABLE INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	INSERT I/O PACKET IN QUEUE BY PRIORITY
;+
; EXE$INSERTIRP - INSERT I/O PACKET IN QUEUE BY PRIORITY
;
; THIS ROUTINE IS CALLED TO INSERT AN I/O PACKET IN A SPECIFIED QUEUE BY
; PRIORITY.
;
; INPUTS:
;
;	R2 = ADDRESS OF QUEUE LISTHEAD.
;	R3 = ADDRESS OF I/O PACKET.
;
;	CURRENT IPL MUST BE THE FORK LEVEL OF THE RESPECTIVE DRIVER PROCESS
;	OR HIGHER.
;
; OUTPUTS:
;
;	THE I/O PACKET IS INSERTED IN THE SPECIFIED QUEUE BY PRIORITY AND
;	THE 'Z' CONDITION CODE IS RETURNED TO THE CALLER.
;
;		'Z' = 1 = ENTRY WAS FIRST ENTRY IN THE QUEUE.
;
;		'Z' = 0 = ENTRIES WERE ALREADY IN THE QUEUE.
;
;	R2 AND R3 ARE PRESERVED ACROSS THE CALL.
;-
 
EXE$INSERTIRP::				;INSERT I/O PACKET IN QUEUE BY PRIORITY
	MOVL	R2,R1			;COPY LISTHEAD ADDRESS
10$:	MOVL	IRP$L_IOQBL(R1),R1	;GET ADDRESS OF NEXT ENTRY
	CMPL	R2,R1			;END OF QUEUE?
	BEQL	20$			;IF EQL YES
	CMPB	IRP$B_PRI(R3),IRP$B_PRI(R1) ;NEW ENTRY PRIORITY GREATER?
	BLSSU	10$			;IF LSS YES
20$:	INSQUE	IRP$L_IOQFL(R3),IRP$L_IOQFL(R1) ;INSERT PACKET IN I/O QUEUE
	RSB				;
 
	.END
