	.TITLE	SYSQIOFDT - SYSTEM SERVICE QUEUE I/O FDT SUBROUTINES
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 15-SEP-76
;
; MODIFIED BY:
;
;	V03-001	MSH0001		Maryann Hinden		16-Mar-1982
;		Fix PROBE problem.
;
;	V02-011	DJD0001		Darrell Duffy		23-Dec-1981
;		Fix EXE$WRITECHKR and EXE$READCHKR to store IRP$L_BCNT
;		as a longword and not as a word.  This allows greater
;		than 64K transfers to work correctly for drivers that
;		support them.
;
;	V02-010	TMH0010		Tim Halvorsen		1-Dec-1981
;		Fix bug in KDM0066 which caused AP to be incorrectly set
;		upon restarting the QIO.   This resulted in spurious "invalid
;		I/O channel" errors from QIO's which were forced into MWAIT
;		for some reason.
;
;	V02-009	KDM0066		Kathleen D. Morse	9-Jov-1981
;		Fix I/O resource waiting routine so that the indicator
;		that a process is waiting is set after the EXE$DEANONPAGED
;		call, not before.
;
;	V02-008	SGD2003		Scott G. Davis		23-Sep-1981
;		Fix bug which causes system crash if an inaccessible
;		buffer is specified in a SETMODE or SETCHAR operation.
;		The V02-007 fix (RSB instead of BRW EXE$ABORTIO)
;		was incorrect and is hereby superseded.
;
;	V02-007	SGD2002		Scott G. Davis		11-Jun-1981
;		Fix bug which causes system crash if an inaccessible
;		buffer is specified in a SETMODE or SETCHAR operation.
;
;	V02-006	SRB0002		Steve Beckhardt		02-Sep-1980
;		Fixed bug where backing out a QIO to put the process into
;		resource wait mode did not deallocate a possible diagnostic
;		buffer.  Since this produced duplicate code in two routines,
;		a common subroutine (BACKOUT_QIO) was created.
;
; SYSTEM SERVICE QUEUE I/O FUNCTION DECISION TABLE SUBROUTINES
;
; MACRO LIBRARY CALLS
;
 
	$ACBDEF				;DEFINE ACB OFFSETS
	$CCBDEF				;DEFINE CCB OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$PCBDEF				;DEFINE PCB VALUES
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VADEF				;DEFINE VIRTUAL ADDRESS FIELDS
	$SFDEF				;DEFINE CALL FRAME
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
P1=0					;FIRST FUNCTION DEPENDENT PARAMETER
P2=4					;SECOND FUNCTION DEPENDENT PARAMETER
P3=8					;THIRD FUNCTION DEPENDENT PARAMETER
P4=12					;FOURTH FUNCTION DEPENDENT PARAMETER
P5=16					;FIFTH FUNCTION DEPENDENT PARAMETER
P6=20					;SIXTH FUNCTION DEPENDENT PARAMETER
	.PAGE
	.SBTTL	PLACE PROCESS IN I/O RESOURCE WAIT
;+
; EXE$IORSNWAIT - PLACE PROCESS IN I/O RESOURCE WAIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY FDT PROCEEDURES TO RE-START A QIO REQUEST
; AFTER A RESOURCE WAIT. THE CURRENT I/O IS CLEANED UP AND THE PRE-QIO
; STACK IS SET UP. THEN THE PROCESS IS PLACED IN THE WAIT STATE.
; IF THE PROCESS DOES NOT HAVE RESOURCE WIAT ENABLED, THE I/O IS ABORTED
; WITH A STATUS SPECIFIED BY THE CALLER.
;
;
; IMPLICIT INPUTS:
;
;	CALLER MUST BE AT IPL=IPL$_SYNCH OR GREATER.
;
; INPUTS:
;
;	R0 = STATUS TO RETURN IF NO WAIT REQUESTED
;	R1 = RESOURCE NUMBER TO WAIT FOR
;	R3 = ADDRESS OF CURRENT PACKET
;	R4 = ADDRESS OF THE CURRENT PCB
;	R6 = ADDRESS OF CHANNEL CONTROL BLOCK
;
; OUTPUTS:
;
;	R0,R1,R2,R3 ARE USED.
;
;	CONTROL IS TRANSFERED TO EXE$ABORTIO IF NO RESOURCE WAIT
;	HAS BEEN REQUESTED,
;
;	OR TO SCH$WAIT IF RESOURCE WAIT IS REQUESTED.
;
;-
 
EXE$IORSNWAIT::				;PLACE PROCESS IN RESOURCE WAIT
	BBS	#PCB$V_SSRWAIT,PCB$L_STS(R4),50$ ;BR IF NO WAIT REQUEST
	MOVZBL	R1,PCB$L_EFWM(R4)	;SET UP WAIT MARKER
	PUSHL	R1			;REMEMBER RESOURCE NUMBER
10$:	BSBW	BACKOUT_QIO		;CLEANUP QIO
	BBSS	(SP)+,W^SCH$GL_RESMASK,30$ ;INDICATE PROCESS IS WAITING
30$:	MOVL	SF$L_SAVE_AP(FP),AP	;RESTORE PRE-QIO ARGUMENT LIST POINTER
	MOVL	FP,SP			;CLEAN STACK BACK TO CALL FRAME
	MOVAQ	W^SCH$GQ_MWAIT,R2	;ADDRESS WAIT LIST
	BRW	SCH$WAIT		;PLACE PROCESS IN WAIT STATE
;
; NO RESOURCE WAIT REQUESTED - ABORT THE I/O
;
50$:	BRW	EXE$ABORTIO		; 
	.PAGE
	.SBTTL	ONE PARAMETER FUNCTION PROCESSING
;+
; EXE$ONEPARM - ONE PARAMETER FUNCTION PROCESSING
;
; THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO
; PROCESS A ONE PARAMETER FUNCTION THAT REQUIRES NO SPECIAL CHECKING.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
	.ENABL	LSB
EXE$ONEPARM::				;ONE PARAMETER FUNCTION PROCESSING
	MOVL	P1(AP),IRP$L_MEDIA(R3)	;STORE PARAMETER IN MEDIA ADDRESS
	BRB	10$			;
	.PAGE
	.SBTTL	ZERO PARAMETER FUNCTION PROCESSING
;+
; EXE$ZEROPARAM - ZERO PARAMETER FUNCTION PROCESSING
;
; THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO
; PROCESS A ZERO PARAMETER FUNCTION THAT REQUIRES NO ADDITION CHECKING.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
EXE$ZEROPARM::				;ZERO PARAMETER FUNCTION PROCESSING
	CLRL	IRP$L_MEDIA(R3)		;CLEAR PARAMETER
10$:	BRW	EXE$QIODRVPKT		;QUEUE I/O PACKET TO DRIVER
	.DSABL	LSB
	.PAGE
	.SBTTL	READ AND WRITE FUNCTION PROCESSING
;+
; EXE$READ - READ FUNCTION PROCESSING
; EXE$WRITE - WRITE FUNCTION PROCESSING
; EXE$MODIFY - MODIFY FUNCTION PROCESSING
;
; THESE ROUTINES ARE CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER TO
; PROCESS A READ OR WRITE PHYSICAL OR LOGICAL FUNCTION.
; EXE$MODIFY IS USED FOR FUNCTIONS THAT READ AND WRITE MEMORY.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
	.ENABL	LSB
EXE$MODIFY::				;MODIFY FUNCTION PROCESSING
	MOVAL	B^EXE$MODIFYLOCK,R2	;SET ADDRESS OF BUFFER CHECK ROUTINE
	BRB	5$
EXE$READ::				;READ FUNCTION PROCESSING
	MOVAL	B^EXE$READLOCK,R2	;SET ADDRESS OF BUFFER CHECK ROUTINE
5$:	BBCS	#IRP$V_FUNC,IRP$W_STS(R3),10$ ;SET READ FUNCTION STATUS
EXE$WRITE::				;WRITE FUNCTION PROCESSING
	MOVAL	B^EXE$WRITELOCK,R2	;SET ADDRESS OF BUFFER CHECK ROUTINE
10$:	MOVL	P4(AP),IRP$B_CARCON(R3)	;INSERT CARRIAGE CONTROL BYTE
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;PHYSICAL I/O FUNCTION?
		IRP$W_FUNC(R3),#IO$_PHYSICAL ;
	BLEQ	20$			;IF LEQ YES
	SUBW	#IO$_READLBLK-IO$_READPBLK,- ;CONVERT TO PHYSICAL FUNCTION
		IRP$W_FUNC(R3)		;
20$:	MOVZWL	P2(AP),R1		;GET NUMBER OF BYTES TO TRANSFER
	BEQL	30$			;IF EQL NONE
	MOVL	P1(AP),R0		;GET STARTING VIRTUAL ADDRESS OF TRANSFER
	JSB	(R2)			;CHECK BUFFER AND LOCK IN MEMORY
30$:	BRW	EXE$QIODRVPKT		;QUEUE I/O PACKET TO DRIVER
	.DSABL	LSB
	.PAGE
	.SBTTL	READ AND WRITE FUNCTION BUFFER CHECK AND LOCK ROUTINES
;+
; EXE$READLOCK - CHECK BUFFER FOR READ ACCESSIBILITY AND LOCK
; EXE$WRITELOCK - CHECK BUFFER FOR WRITE ACCESSIBILITY AND LOCK
; EXE$MODIFYLOCK - CHECK BUFFER FOR READ ACCESSIBILITY AND LOCK
;
; THESE ROUTINES ARE CALLED TO CHECK THE ACCESSIBILITY OF AN I/O BUFFER AND
; TO LOCK THE BUFFER IN MEMORY FOR A DIRECT MEMORY TRANSFER.
;
; INPUTS:
;
;	R0 = STARTING ADDRESS OF I/O BUFFER.
;	R1 = LENGTH OF TRANSFER IN BYTES.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;
; OUTPUTS:
;
;	THE I/O BUFFER IS CHECKED FOR THE PROPER ACCESSIBILITY. IF THE
;	CHECK SUCCEEDS, THEN THE BUFFER IS LOCKED IN MEMORY AND THE STARTING
;	ADDRESS OF THE PAGE TABLE ENTRIES THAT MAP THE TRANSFER IS STORED
;	IN THE I/O PACKET. ELSE THE I/O IS COMPLETED WITH A STATUS OF
;	ACCESS VIOLATION.
;-
 
EXE$READLOCK::				;CHECK BUFFER FOR READ FUNCTION AND LOCK
	BSBB	EXE$READLOCKR		;EXE$READLOCKR RETURNS NORMALLY ON
					;SUCCESS, VIA COROUTINE CALL ON FAILURE
	RSB				;RETURNS TO CALLER ON SUCCESS, TO
					;EXE$READLOCKR ON FAILURE

EXE$WRITELOCK::				;CHECK BUFFER FOR WRITE FUNCTION AND LOCK
	BSBB	EXE$WRITELOCKR		;EXE$WRITELOCKR RETURNS NORMALLY ON
					;SUCCESS, VIA COROUTINE CALL ON FAILURE
	RSB				;RETURNS TO CALLER ON SUCCESS, TO
					;EXE$WRITELOCKR ON FAILURE

EXE$MODIFYLOCK::			;CHECK BUFFER FOR MODIFY FUNCTION AND LOCK
	BSBB	EXE$MODIFYLOCKR		;EXE$MODIFYLOCKR RETURNS NORMALLY ON
					;SUCCESS, VIA COROUTINE CALL ON FAILURE
	RSB				;RETURNS TO CALLER ON SUCCESS, TO
					;EXE$MODIFYLOCKR ON FAILURE
	.PAGE
	.SBTTL	READ AND WRITE BUFFER CHECK AND LOCK AND RETURN ROUTINES
;+
; EXE$READLOCKR - CHECK BUFFER FOR READ ACCESSIBILITY AND LOCK AND RETURN
;		  ON ERROR
; EXE$WRITELOCKR - CHECK BUFFER FOR WRITE ACCESSIBILITY AND LOCK AND RETURN
;		   ON ERROR
; EXE$MODIFYLOCKR - CHECK BUFFER FOR READ ACCESSIBILITY AND LOCK AND RETURN
;		    ON ERROR
;
; THESE ROUTINES ARE CALLED TO CHECK THE ACCESSIBILITY OF AN I/O BUFFER
; AND TO LOCK THE BUFFER IN MEMORY FOR A DIRECT MEMORY TRANSFER.  IN
; ADDITION, THESE ROUTINES PERFORM A COROUTINE CALL IF THERE IS AN ERROR
; OR ANY PAGES HAVE TO BE FAULTED IN.  THE PURPOSE OF THE COROUTINE 
; CALL IS TO ALLOW THE CALLER TO PERFORM ANY NECESSARY CLEANUP BEFORE
; THE QIO IS BACKED UP OR ABORTED.  THESE ROUTINES ARE TYPICALLY CALLED
; BY DRIVERS THAT MUST LOCK MULTIPLE AREAS INTO MEMORY.  SINCE THESE 
; ROUTINES CANNOT UNLOCK AREAS PREVIOUSLY LOCKED, THE COROUTINE CALL ALLOWS
; THE CALLER (THE DRIVER) TO UNLOCK PREVIOUSLY LOCKED AREAS (AND PERFORM
; ANY OTHER CLEANUP) AND THEN RETURN HERE TO BACK UP OR ABORT THE I/O.
;
; EXE$MODIFYLOCKR IS USED WHEN THE BUFFER WILL BE READ AND WRITTEN BY THE
; I/O DEVICE.  IT DISABLES AN OPTIMIZATION IN MMG$IOLOCK WHICH IS USED
; WHEN THE BUFFER IS ONLY WRITTEN.
;
; INPUTS:
;
;	R0 = STARTING ADDRESS OF I/O BUFFER.
;	R1 = LENGTH OF BUFFER IN BYTES.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;
; OUTPUTS:
;
;	THE I/O BUFFER IS CHECKED FOR THE PROPER ACCESSIBILITY.  IF THE
;	CHECK SUCCEEDS, THEN THE BUFFER IS LOCKED IN MEMORY AND THE STARTING
;	ADDRESS OF THE PAGE TABLE ENTRIES THAT MAP THE TRANSFER IS STORED
;	IN THE I/O PACKET.
;
;	R0 = RETURN CODE
;
;	NOTE THAT IF THERE ARE NO ERRORS AND NO PAGES HAVE TO BE FAULTED
;	IN, THEN THESE ROUTINES RETURN NORMALLY.  HOWEVER, IF THERE IS AN
;	ERROR OR A PAGE HAS TO BE FAULTED IN, THEN THE CALLER IS CALLED
;	BY A COROUTINE CALL.  THE CALLER'S RSB THEN RETURNS HERE WHERE
;	THE QIO IS EITHER BACKED UP OR ABORTED.  NOTE THAT IN THIS CASE
;	THE CALLER'S ERROR HANDLING CODE MUST PRESERVE ALL REGISTERS,
;	INCLUDING R0 AND R1.
;-
	.ENABL	LSB
EXE$MODIFYLOCKR::			;CHECK BUFFER FOR MODIFY FUNCTION AND LOCK
	PUSHL	R0			;SAVE STARTING ADDRESS OF BUFFER
	BSBW	EXE$READCHKR		;CHECK BUFFER FOR READ FUNCTION
	BISL	#4,R2			;DISABLE OPTIMIZATION IN MMG$IOLOCK
	BRB	10$

EXE$READLOCKR::				;CHECK BUFFER FOR READ FUNCTION AND LOCK
	PUSHL	R0			;SAVE STARTING ADDRESS OF BUFFER
	BSBW	EXE$READCHKR		;CHECK BUFFER FOR READ FUNCTION
	BRB	10$

EXE$WRITELOCKR::			;CHECK BUFFER FOR WRITE FUNCTION AND LOCK
	PUSHL	R0			;SAVE STARTING ADDRESS OF BUFFER
	BSBW	EXE$WRITECHKR		;CHECK BUFFER FOR WRITE FUNCTION
10$:	BLBC	R0,15$			;BRANCH IF ERROR
	POPL	R0			;RESTORE STARTING ADDRESS OF BUFFER
	BICW3	#^C<VA$M_BYTE>,R0,IRP$W_BOFF(R3) ;SET BYTE OFFSET IN PAGE
	PUSHL	R3			;SAVE ADDRESS OF I/O PACKET
	BSBW	MMG$IOLOCK		;LOCK PAGES FOR I/O
	MOVL	(SP)+,R3		;RETRIEVE ADDRESS OF I/O PACKET
	BLBC	R0,20$			;IF LBC LOCK FAILURE
	MOVL	R1,IRP$L_SVAPTE(R3)	;INSERT ADDRESS OF FIRST PTE IN PACKET
	RSB				;
15$:	ADDL	#4,SP			;THROW AWAY OLD R0
20$:	JSB	@(SP)+			;COROUTINE CALL TO CLEANUP
	TSTL	R0			;ERRORS ENCOUNTERED?
	BNEQ	50$			;IF NEQ YES
	PUSHL	R1			;SAVE VIRTUAL ADDRESS OF PAGE TO FAULT
	BSBB	BACKOUT_QIO		;CLEANUP QIO
	POPR	#^M<R1>			;RETRIEVE VIRTUAL ADDRESS OF PAGE TO FAULT
	MOVL	FP,SP			;TRIM STACK BACK TO CHANGE MODE FRAME
	MOVQ	8(FP),AP		;RESTORE USER ARGUMENT AND FRAME POINTERS
	ADDL	S^#EXE$C_CMSTKSZ,SP	;REMOVE CHANGE MODE CALL FRAME FROM STACK
	SUBL3	#4,(SP)+,R0		;CALCULATE RESTART ADDRESS
	PUSHAB	B^40$			;SET NEW RETURN ADDRESS
	REI				;
40$:	TSTB	(R1)			;FAULT USER BUFFER AGAIN
	JMP	(R0)			;REPEAT SYSTEM SERVICE
50$:	BRW	EXE$ABORTIO		;ABORT I/O REQUEST
	.DSABL	LSB
	.PAGE
	.SBTTL	BACKOUT A QIO
;+
; BACKOUT_QIO - BACKOUT A QIO
;
; THIS ROUTINE IS CALLED TO BACKOUT A QIO.  IT DECREMENTS THE CHANNEL I/O
; COUNT, INCREMENTS THE DIRECT OR BUFFERED I/O COUNT, DEALLOCATES THE
; DIAGNOSTIC BUFFER (IF PRESENT), OPTIONALLY INCREMENTS THE AST COUNT, AND
; FINALLY DEALLOCATES THE IRP.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET
;	R4 = CURRENT PROCESS PCB ADDRESS
;	R6 = ADDRESS OF CCB
;
; OUTPUTS:
;
;	R0 - R3 = CLOBBERED
;
;-

BACKOUT_QIO:				;BACKOUT A QIO
	DECW	CCB$W_IOC(R6)		;DECREMENT CHANNEL I/O COUNT
	BBC	#IRP$V_BUFIO,IRP$W_STS(R3),10$ ;BR IF NOT BUFFERED I/O
	INCW	PCB$W_BIOCNT(R4)	;ADJUST COUNT OF BUFFERED I/O
	BRB	20$			;CONTINUE
10$:	INCW	PCB$W_DIOCNT(R4)	;ADJUST DIRECT I/O COUNT
20$:	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),30$  ;BR. IF NO DIAGNOSTIC BUFFER
	MOVL	IRP$L_DIAGBUF(R3),R0	;GET ADDRESS OF DIAGNOSTIC BUFFER
	PUSHL	R3			;SAVE R3
	BSBW	EXE$DEANONPAGED		;DEALLOCATE DIAGNOSTIC BUFFER
	POPL	R3			;RESTORE R3
30$:	BBC	#ACB$V_QUOTA,IRP$B_RMOD(R3),40$ ;BR IF AST NOT REQUESTED
	INCW	PCB$W_ASTCNT(R4)	;ADJUST AST COUNT
40$:	MOVL	R3,R0			;DEALLOCATE PACKET
	BSBW	EXE$DEANONPAGED		;
	RSB

	.SBTTL	CHECK BUFFER ACCESSIBILITY FOR READ FUNCTION
;+
; EXE$READCHK - CHECK BUFFER ACCESSIBILITY FOR READ FUNCTION
;
; THIS ROUTINE IS CALLED TO CHECK BUFFER ACCESSIBILITY FOR A READ I/O
; FUNCTION.
;
; INPUTS:
;
;	R0 = ADDRESS OF BUFFER.
;	R1 = SIZE OF TRANSFER IN BYTES.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF BUFFER IS NOT WRITE ACCESSIBLE, THEN THE I/O REQUEST IS TERM-
;	INATED VIA EXE$IOFINISH WITH A STATUS OF SS$_ACCVIO.
;
;	IF BUFFER IS WRITE ACCESSIBLE, THEN THE FOLLOWING VALUES ARE RE-
;	TURNED:
;
;		R0 = ADDRESS OF BUFFER.
;		R1 = SIZE OF TRANSFER IN BYTES.
;		R2 = READ FUNCTION INDICATOR (1).
;		R3 = ADDRESS OF I/O REQUEST PACKET.
;
;		IRP$W_BCNT(R3) = SIZE OF TRANSFER IN BYTES.
;		IRP$W_FUNC(R3) = READ.
;-
 
	.ENABL	LSB
EXE$READCHK::				;CHECK BUFFER FOR READ FUNCTION
	PUSHL	R0			;SAVE ADDRESS OF BUFFER
	BSBB	EXE$READCHKR		;CHECK BUFFER
	BRB	10$
	.PAGE
	.SBTTL	CHECK BUFFER ACCESSIBILITY FOR WRITE FUNCTION
;+
; EXE$WRITECHK - CHECK BUFFER ACCESSIBILITY FOR WRITE FUNCTION
;
; THIS ROUTINE IS CALLED TO CHECK BUFFER ACCESSIBILITY FOR A WRITE I/O
; FUNCTION.
;
; INPUTS:
;
;	R0 = ADDRESS OF BUFFER.
;	R1 = SIZE OF TRANSFER IN BYTES.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF BUFFER IS NOT READ ACCESSIBLE, THEN THE I/O REQUEST IS TERM-
;	INATED VIA EXE$IOFINISH WITH A STATUS OF SS$_ACCVIO.
;
;	IF BUFFER IS READ ACCESSIBLE, THEN THE FOLLOWING VALUES ARE RE-
;	TURNED:
;
;		R0 = ADDRESS OF BUFFER.
;		R1 = SIZE OF TRANSFER IN BYTES.
;		R2 = WRITE FUNCTION INDICATOR (0).
;		R3 = ADDRESS OF I/O REQUEST PACKET.
;
;		IRP$W_BCNT(R3) = SIZE OF TRANSFER IN BYTES.
;		IRP$W_FUNC(R3) = WRITE.
;-
 
EXE$WRITECHK::				;CHECK BUFFER FOR WRITE FUNCTION
	PUSHL	R0			;SAVE ADDRESS OF BUFFER
	BSBB	EXE$WRITECHKR		;CHECK BUFFER		
10$:	BLBS	R0,20$			;BRANCH IF SUCCESS	
	BRW	EXE$ABORTIO		;ABORT I/O		
20$:	POPL	R0			;RESTORE ADDRESS OF BUFFER
	RSB							
	.DSABL	LSB
	.PAGE
	.SBTTL	CHECK BUFFER ACCESSIBILITY FOR READ FUNCTION AND RETURN
;+
; EXE$READCHKR - CHECK BUFFER ACCESSIBILITY FOR READ FUNCTION AND RETURN
;
; THIS ROUTINE IS CALLED TO CHECK BUFFER ACCESSIBILITY FOR A READ I/O
; FUNCTION.  STATUS IS RETURNED IN R0.
;
; INPUTS:
;
;	R0 = ADDRESS OF BUFFER.
;	R1 = SIZE OF TRANSFER IN BYTES.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF THE BUFFER IS NOT WRITE ACCESSIBLE, THEN THE FOLLOWING
;	VALUE IS RETURNED:
;
;	R0 = SS$_ACCVIO
;
;	IF BUFFER IS WRITE ACCESSIBLE, THEN THE FOLLOWING VALUES ARE RE-
;	TURNED:
;
;		R0 = SS$_NORMAL
;		R1 = SIZE OF TRANSFER IN BYTES.
;		R2 = READ FUNCTION INDICATOR (1).
;		R3 = ADDRESS OF I/O REQUEST PACKET.
;
;		IRP$L_BCNT(R3) = SIZE OF TRANSFER IN BYTES.
;		IRP$W_FUNC(R3) = READ.
;-
 
	.ENABL	LSB
EXE$READCHKR::				; CHECK BUFFER FOR READ FUNCTION
	MOVL	R1,IRP$L_BCNT(R3)	; SAVE R1
	BSBB	10$			; CHECK ACCESS
	MOVL	IRP$L_BCNT(R3),R1	; RESTORE R1
	BLBC	R0,5$			; IF LBC, NO ACCESS
	BISW	#IRP$M_FUNC,IRP$W_STS(R3) ; SET READ FUNCTION
	MOVL	#1,R2			; SET READ FUNCTION INDICATOR
5$:	RSB

10$:	ADDL	R0,R1			; ENDING ADDRESS OF BUFFER
	BICW	#VA$M_BYTE,R0		; TRUNCATE TO START OF PAGE
	SUBL	R0,R1			; CALCULATE LENGTH OF BUFFER TO PROBE
	CVTWL	#-^X200,R2		; SET ADDRESS ADJUSTMENT CONSTANT
15$:	CVTLW	R1,R1			; GREATER THAN 32k?
	BVS	30$			; IF VS, YES; CHECK BY CHUNKS

20$:	IFNOWRT	R1,(R0),ACCVIO		; CAN ENDS OF USER'S BUFFER BE WRITTEN?
	SUBL	R2,R0			; CALCULATE VA OF NEXT PAGE
	MOVAW	(R1)[R2],R1		; CALCULATE NEW LENGTH
	BGTR	20$			; IF GTR THEN MORE TO TEST
	MOVZWL	#SS$_NORMAL,R0		; INDICATE SUCCESS
	RSB				;  AND RETURN

30$:	MOVQ	R0,-(SP)		; SAVE CURRENT VALUES ON STACK
	MOVZWL	#^X7E00,R1		; SIZE OF CHUNK USED STEPPING THRU BUF.
					;  (32K - 1 PAGE)
	ADDL	R1,(SP)			; ADVANCE ADDRESS BY THIS AMOUNT
	SUBL	R1,4(SP)		; DECREASE COUNT
	BSBB	20$			; PROBE CHUNK
	BLBC	R0,ACCVIO1		; IF LBC, NO ACCESS
	MOVQ	(SP)+,R0		; POP PRE-ADJUSTED VALUES OFF STACK
	BRB	15$			; SEE IF LENGTH NOW LT 32K

ACCVIO1:
	ADDL	#8,SP
	RSB
ACCVIO:
	MOVZWL	#SS$_ACCVIO,R0
	RSB

	.PAGE
	.SBTTL	CHECK BUFFER ACCESSIBILITY FOR WRITE FUNCTION AND RETURN
;+
; EXE$WRITECHKR - CHECK BUFFER ACCESSIBILITY FOR WRITE FUNCTION AND RETURN
;
; THIS ROUTINE IS CALLED TO CHECK BUFFER ACCESSIBILITY FOR A WRITE I/O
; FUNCTION.  STATUS IS RETURNED IN R0
;
; INPUTS:
;
;	R0 = ADDRESS OF BUFFER.
;	R1 = SIZE OF TRANSFER IN BYTES.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;
; OUTPUTS:
;
;	IF BUFFER IS NOT READ ACCESSIBLE, THEN THE FOLLOWING VALUE IS
;	RETURNED:
;
;	R0 = SS$_ACCVIO
;
;	IF BUFFER IS READ ACCESSIBLE, THEN THE FOLLOWING VALUES ARE RE-
;	TURNED:
;
;		R0 = SS$_NORMAL
;		R1 = SIZE OF TRANSFER IN BYTES.
;		R2 = WRITE FUNCTION INDICATOR (0).
;		R3 = ADDRESS OF I/O REQUEST PACKET.
;
;		IRP$L_BCNT(R3) = SIZE OF TRANSFER IN BYTES.
;		IRP$W_FUNC(R3) = WRITE.
;-
 
EXE$WRITECHKR::				;CHECK BUFFER FOR WRITE FUNCTION
	MOVL	R1,IRP$L_BCNT(R3)	; SAVE R1
	BSBB	40$			; CHECK ACCESS
	MOVL	IRP$L_BCNT(R3),R1	; RESTORE R1
	BLBC	R0,35$			; IF LBC, NO ACCESS
	CLRL	R2			; SET WRITE FUNCTION INDICATOR
35$:	RSB

40$:	ADDL	R0,R1			; ENDING ADDRESS OF BUFFER
	BICW	#VA$M_BYTE,R0		; TRUNCATE TO START OF PAGE
	SUBL	R0,R1			; CALCULATE LENGTH OF BUFFER TO PROBE
	CVTWL	#-^X200,R2		; SET ADDRESS ADJUSTMENT CONSTANT
45$:	CVTLW	R1,R1			; GREATER THAN 32k?
	BVS	60$			; IF VS, YES; CHECK BY CHUNKS

50$:	IFNORD	R1,(R0),ACCVIO		; CAN ENDS OF USER'S BUFFER BE READ?
	SUBL	R2,R0			; CALCULATE VA OF NEXT PAGE
	MOVAW	(R1)[R2],R1		; CALCULATE NEW LENGTH
	BGTR	50$			; IF GTR THEN MORE TO TEST
	MOVZWL	#SS$_NORMAL,R0		; INDICATE SUCCESS
	RSB				;  AND RETURN

60$:	MOVQ	R0,-(SP)		; SAVE CURRENT VALUES ON STACK
	MOVZWL	#^X7E00,R1		; SIZE OF CHUNK USED STEPPING THRU BUF.
					;  (32K - 1 PAGE)
	ADDL	R1,(SP)			; ADVANCE ADDRESS BY THIS AMOUNT
	SUBL	R1,4(SP)		; DECREASE COUNT
	BSBB	50$			; PROBE CHUNK
	BLBC	R0,ACCVIO1		; IF LBC, NO ACCESS
	MOVQ	(SP)+,R0		; POP PRE-ADJUSTED VALUES OFF STACK
	BRB	45$			; SEE IF LENGTH NOW LT 32K
	.DSABL	LSB
	.PAGE
	.SBTTL	SET DEVICE MODE AND CHARACTERISTICS FUNCTIONS (AT FDT LEVEL)
;+
; EXE$SETCHAR - SET DEVICE MODE AND CHARACTERISTICS FUNCTIONS (AT FDT LEVEL)
;
; THIS ROUTINE PLACES THE NEW CHARACTERISTICS SPECIFIED BY THE QUADWORD POINTED
; TO BY P1 INTO THE SECOND AND THIRD LONGWORDS OF THE DEVICE UCB.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE CHARACTERISTICS SPECIFIED BY THE QUADWORD POINTER TO BY P1 ARE STORED
;	IN THE SECOND AND THIRD LONGWORDS OF THE DEVICE UCB.
;-
 
	.ENABL	LSB
EXE$SETCHAR::				;SET DEVICE MODE AND CHARACTERISTICS
	MOVL	P1(AP),R1		;GET ADDRESS OF CHARACTERISTICS
	IFNORD	#8,(R1),BUFFER_ACCVIO	;SEE IF CHAR QUADWORD ACCESSIBLE
	CMPL	#IO$_SETMODE,R7		;SET MODE FUNCTION?
	BEQL	10$			;IF EQL YES
	MOVW	(R1),UCB$B_DEVCLASS(R5)	;SET DEVICE TYPE AND CLASS
10$:	MOVW	2(R1),UCB$W_DEVBUFSIZ(R5) ;SET DEFAULT BUFFER SIZE
	MOVL	4(R1),UCB$L_DEVDEPEND(R5) ;SET DEVICE CHARACTERISTICS
	BRB	20$			;
	.PAGE
	.SBTTL	SET DEVICE MODE AND CHARACTERISTICS FUNCTIONS
;+
; EXE$SETMODE - SET DEVICE CHARACTERISTICS AND MODE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PLACES THE NEW CHARACTERISTICS SPECIFIED BY P1 INTO
; THE I/O PACKET FOR INSERTION INTO THE UCB WHEN THE UNIT IS IDLE.
; THE INPUT DATA IS IN THE FORM RETURNED BY $GTCHAN. THE SPECIFIED BUFFER
; IS ASSUMED TO BE 12 BYTES IN LENGTH. THE P2 LENGTH SPECIFIER IS IGNORED.
;
; THE NEW CHARACTERISTICS ARE PLACED IN IRP$L_MEDIA/MEDIA+4 AND THE
; PACKET IS QUEUED VIA EXE$QIODRVPKT.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB
;	R5 = ACB ADDRESS
;	R6 = ASSIGNED CCB ADDRESS
;	AP = ADDRESS OF THE QIO ARGUMEMT P1
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;	R3+ ARE PRESERVED.
;
; COMPLETION CODES:
;
;	SS$_NORMAL - SUCCESSFUL
;	SS$_ACCVIO - BUFFER ACCESS VIOLATION
;-
 
EXE$SETMODE::				;SET DEVICE MODE AND CHARACTERISTICS
	MOVL	P1(AP),R1		;ADDRESS BUFFER
	IFNORD	#8,(R1),BUFFER_ACCVIO	;SEE IF CHAR QUADWORD ACCESSIBLE
	MOVQ	(R1),IRP$L_MEDIA(R3)	;INSERT CHARACTERISTICS IN I/O PACKET
	BRW	EXE$QIODRVPKT		;QUEUE THE PACKET

BUFFER_ACCVIO:
	MOVZWL	#SS$_ACCVIO,R0		;MARK FOR ACCESS VIOLATION
	BRW	EXE$ABORTIO		;ABORT THE I/O
	.PAGE
	.SBTTL	SENSE DEVICE MODE AND CHARACTERISTICS FUNCTIONS
;+
; EXE$SENSEMODE - SENSE DEVICE MODE AND CHARACTERISTICS FUNCTIONS
;
; THIS ROUTINE OBTAINS THE CURRENT DEVICE MODE/CHARACTERISTICS FROM THE DEVICE
; DEPENDENT CHARACTERISTICS LONGWORD IN THE UCB AND IMMEDIATELY COMPLETES THE
; I/O OPERATION WITH THE SECOND LONGWORD OF THE FINAL I/O STATUS EQUAL TO THE
; DEVICE DEPENDENT CHARACTERSITICS.
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
;	THE DEVICE DEPENDENT CHARACTERISTICS ARE OBTAINED FROM THE UCB AND
;	THE I/O IS COMPLETED WITH THE SECOND I/O STATUS LONGWORD EQUAL TO THE
;	DEVICE CHARACTERISTICS.
;-
 
EXE$SENSEMODE::				;SENSE DEVICE MODE/CHARACTERISTICS
	MOVL	UCB$L_DEVDEPEND(R5),R1	;GET DEVICE DEPENDENT CHARACTERSITICS
20$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	BRW	EXE$FINISHIO		;FINISH I/O OPERATION
	.DSABL	LSB
	.PAGE
	.SBTTL	CARRIAGE CONTROL INTERPRETATION
;+
; EXE$CARRIAGE - INTERPRET CARRIAGE CONTROL SPECIFIER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY THE LINE PRINTER DRIVER AND THE TERMINAL
; DRIVER TO INTERPRET THE CARRIAGE CONTROL SPECIFIER IN IRP$B_CARCON .
; NOTE THAT IRP$B_CARCON IS USED AS A LONGWORD!
;
; THE SPECIFIER IS AS FOLLOWS:
;
;	.BYTE 1 -- FORTRAN CARRIAGE CONTROL CHARACTER IF NOT 0
;	.BYTE 2 -- ***** IGNORED *****
;	.BYTE 3 -- PREFIX CARRIAGE CONTROL
;	.BYTE 4 -- SUFFIX CARRIAGE CONTROL
;
; THE PRE/SUF FIELDS ARE AS FOLLOWS
;
;	IF BIT 7=0 THEN BITS 6-0 ARE THE NUMBER OF NEWLINES TO INSERT.
;	IF BIT 7=1 AND BIT 6=0 THEN BITS 4-0 ARE THE ASCII CHARACTER TO
;			       OUTPUT. ASCII SET C0 OR C1 IS SPECIFIED BY BIT 5.
;	IF BIT 7=1 AND BIT 6=1 THEN BITS 5-0 ARE THE PRINTER CHANNEL NUMBER
;
; ASCII SET C0 IS ASSUMED AND BIT 6 IS IGNORED IF BIT 7=0.
;
; INPUTS:
;
;	R3 = ADDRESS OF THE I/O PACKET
;	R5 = ADDRESS OF THE UCB
;
; OUTPUTS:
;
;	IRP$B_CARCON IS SET UP TO REFLECT THE PRE/SUF CHARACTERS TO SEND.
;
;	BYTE 0 = NUMBER OF CHARACTERS TO SEND
;	BYTE 1 = CHARACTER, IF 0 THEN NEWLINE
;
;	IRP$B_CARCON+2 HAS THE SUFFIX CONTROL.
;
;	R0,R1 ARE USED.
;
;-
;
; LOCAL DATA TABLE
;
CCTABLE:				; CARRIAGE CONTROL TO FORTRAN MATCH TABLE
	.BYTE	1,0,1,13		; SPACE => 1 NL, 1 CR
	.ASCII	/ /
	.BYTE	2,0,1,13		; "0" => 2 NL, 1 CR
	.ASCII	/0/
	.BYTE	1,12,1,13		; "1" => 1 FF, 1 CR
	.ASCII	/1/
	.BYTE	0,0,1,13		; "+" => NOTHING, 1 CR
	.ASCII	/+/
	.BYTE	1,0,0,0			; "$" => 1 NL, NOTHING
	.ASCII	/$/
	.BYTE	1,0,1,13		; DEFAULT => 1 NL, 1 CR
	.BYTE	0			; TABLE END
;
;
;
EXE$CARRIAGE::				; INTERPRET CARRIAGE CONTROL
	MOVZBL	IRP$B_CARCON(R3),R1	; GET FORTRAN SPECIFIER
	BEQL	20$			; IF EQL THEN TRY PRE/SUF
	MOVAB	B^CCTABLE,R0		; ADDRESS MATCH TABLE
10$:	MOVL	(R0)+,IRP$B_CARCON(R3)	; ASSUME MATCH
	TSTB	(R0)			; END OF TABLE?
	BEQL	15$			; IF EQL THEN YES
	CMPB	(R0)+,R1		; MATCH?
	BNEQ	10$			; NO THEN SEARCH
15$:	RSB				; ELSE RETURN
;
; PRE/SUF CARRIAGE CONTROL
;
20$:	MOVZBL	IRP$B_CARCON+2(R3),R1	; GET PREFIX SPECIFIER
	BEQL	30$			; IF EQL THEN NONE
	BSBB	100$			; INTERPRET THE SPECIFIER
30$:	MOVB	R1,IRP$B_CARCON(R3)	; INSERT NUMBER
	MOVB	R0,IRP$B_CARCON+1(R3)	; INSERT CHARACTER
	MOVZBL	IRP$B_CARCON+3(R3),R1	; GET SUFFIX SPECIFIER
	BEQL	40$			; IF EQL THEN NONE
	BSBB	100$			; CONVERT THE SPECIFIER
40$:	MOVB	R1,IRP$B_CARCON+2(R3)	; INSERT NUMBER
	MOVB	R0,IRP$B_CARCON+3(R3)	; INSERT CHARACTER
	RSB				; RETURN
;
; SUBROUTINE TO INTERPRET PRE/SUF SPECIFIER
;
100$:	CLRL	R0			; ASSUME NEWLINE
	BBC	#7,R1,110$		; IF BIT 7 CLEAR THEN DONE
	BICB3	#^X0E0,R1,R0		; REMOVE OTHER BITS
	MOVZBL	#1,R1			; SET ONE CHARACTER
110$:	RSB				; RETURN
 
	.END
