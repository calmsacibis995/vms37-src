	.TITLE	FILEREAD - FILES11 LEVEL 1 & 2 FILE READING ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:	USER CALLABLE PROCEDURES
;
; ABSTRACT:
;
;	THIS SET OF ROUTINES PROVIDES THE CAPABILITY OF "OPENING" AND
; READING FILES BY FILE NAME FROM A FILES11 STRUCTURE LEVEL 1 OR 2 VOLUME.
; THERE IS NO MULTI-VOLUME SUPPORT, AND MULTI-HEADER SUPPORT IS LIMITED
; TO RETURNING THE CORRECT FILE SIZE IN THE STATBLK.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 14-DEC-76
;
; MODIFIED BY:
;
;	V02-007	PHL0019		Peter H. Lipman		31-Oct-1981
;		Fix bug in FIL$RDCHKFILHDR having to do with overflowing
;		the callers retrieval pointer buffer for multi-header files.
;		Fix documentation for FIL$STATBLK showing that the returned
;		retrieval pointer length is the number of bytes that would
;		have been stored if the buffer had been large enough.
;
;	V02-006	PHL0009		Peter H. Lipman		06-May-1981
;		TOPSYS directory was not being used properly.
;
;	V02-005	PHL0007		Peter H. Lipman		14-Mar-1981
;		Add cacheing of directory lookups, directory header info,
;		directory data blocks, and index file header.
;		Change interface to FIL$RDWRTLBN to allow the reading 
;		of multiple blocks.
;		Implement multiple level directory lookups and a new
;		top level directory in which all the system directories
;		are found.
;	V02-004	PHL0006		Peter H. Lipman		13-Dec-1980
;		Add capability to return retrieval pointer information
;		and thus allow all non-contiguous files to be handled
;		at boot time.
;--
	.page
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	.nocross
	$DIRDEF				;DIRECTORY ENTRY OFFSET DEFINITIONS
	$FATDEF				;RECORD ATTRIBUTE AREA DEFINITIONS
	$FH1DEF				;FILE HEADER DEFINITIONS, LEVEL 1
	$FH2DEF				;FILE HEADER DEFINITIONS, LEVEL 2
	$FM1DEF				;	MAP AREA, LEVEL 1
	$FM2DEF				;	MAP AREA, LEVEL 2
	$FIDDEF				;FILE ID OFFSET DEFINITIONS
	$HM1DEF				;HOME BLOCK DEFINITIONS, LEVEL 1
	$HM2DEF				;HOME BLOCK DEFINITIONS, LEVEL 2
	$IODEF				;I/O DEFINITIONS
	$PSLDEF				;PROCESSOR STATUS LONG WORD DEFINITIONS
	$SSDEF				;SYSTEM SERVICE DEFINITIONS
	$VADEF				;VIRTUAL ADDRESS DEFINITIONS
;
; MACROS:
;
	.MACRO	READVBN	CHAN,VBN,BUFADR,HDRADR
	.LIST	MEB
		PUSHAL	HDRADR
		PUSHAL	BUFADR
		PUSHL	VBN
		PUSHL	CHAN
		CALLS	#4,W^FIL$READVBN
	.NLIST	MEB
	.ENDM	READVBN

	.MACRO	READLBN	CHAN,VBN,BUFADR
	.LIST	MEB
		ROTL	#9,#1,-(SP)
		MOVZWL	#IO$_READLBLK,-(SP)
		PUSHAL	BUFADR
		PUSHL	VBN
		PUSHL	CHAN
		CALLS	#5,W^FIL$RDWRTLBN
	.NLIST	MEB
	.ENDM	READLBN
	.cross
;
; EQUATED SYMBOLS:
;
	ASSUME	FH1$B_MPOFFSET EQ FH2$B_MPOFFSET
	ASSUME	FH1$W_STRUCLEV EQ FH2$W_STRUCLEV
	ASSUME	FH1$W_CHECKSUM EQ FH2$W_CHECKSUM
	ASSUME	HM1$W_STRUCLEV EQ HM2$W_STRUCLEV
	ASSUME	HM1$W_CHECKSUM1 EQ HM2$W_CHECKSUM1
	ASSUME	HM1$W_CHECKSUM2 EQ HM2$W_CHECKSUM2
	ASSUME	FH1$W_CHECKSUM EQ HM1$W_CHECKSUM2
	ASSUME	FH1$V_CONTIG EQ FH2$V_CONTIG

	FH1$W_VBNOFFSET = FH1$W_CHECKSUM ;SAVE INDEX FILE VBN OFFSET
					;IN THIS PLACE IN INDEX FILE HEADER

	ASSUME	FH1$C_LEVEL1@-8 EQ 1
	FH1$V_LEVEL1 = 8

	ASSUME	FH2$C_LEVEL2@-8 EQ 2
	FH2$V_LEVEL2 = 9
	FH2$V_BIGFILNUM = 10		;IF SET USE HIGH 8 BITS OF FILE ID RVN
					;FIELD AS FILE NUMBER EXTENSION
					;BIT IS PLACED IN FH2$W_STRUCLEV
					;BY THE FIL$MOUNT CODE

	FIL$C_CACHE_ID = 1		;VERSION OF THE FILEREAD CACHE
;
; OFFSETS INTO HEADER PORTION OF THE FILEREAD CACHE
;
	$OFFSET	0,POSITIVE,<-
	<FIL$W_CACHE_ID,2>,-		;CACHE IDENT, AND WRITE INTERLOCK BIT
	<,2>,-				;SPARE
	FIL$L_DIROFF,-			;OFFSET IN BYTES TO DIRECTORY CACHE
	FIL$L_DIRNXT,-			;NEXT OFFSET TO ALLOCATE DIR CACHE ENTRY
	<FIL$L_DIRMAX,0>,-		;MAX OFFSET FOR DIR CACHE
	FIL$L_LBNOFF,-			;OFFSET IN BYTES TO BEGIN OF LBN CACHE
	FIL$L_LBNNXT,-			;NEXT OFFSET TO ALLOCATE LBN CACHE
	FIL$L_LBNMAX,-			;MAX OFFSET FOR LBN CACHE
	<FIL$A_IXFHDR,512>,-		;INDEX FILE HEADER
	<FIL$C_SIZE,0>-			;START OF DIRECTORY CACHE
	>
;
; OFFSETS INTO DIRECTORY CACHE ENTRIES
;
	$OFFSET 0,POSITIVE,<-
	<FIL$A_DIR_FID,6>,-		;DIRECTORY ID
	<FIL$T_DIR_NAM,10>,-		;COUNTED NAME OF DIRECTORY - NO ".DIR"
	<FIL$Q_DIR_HDR,0>,-		;DIRECTORY HEADER INFORMATION
	<FIL$W_DIR_BKCNT,2>,-		;SIZE IN BLOCKS OF DIRECTORY FILE
	<FIL$B_DIR_LVL,1>,-		;STRUCTURE LEVEL OF DIRECTORY
	<,1>,-				;SPARE BYTE
	FIL$L_DIR_LBN,-			;STARTING LBN OF DIRECTORY
	FIL$L_DIR_BFOFF,-		;OFFSET TO DIR LBN BUFFER
	<FIL$W_DIR_BFCNT,2>,-		;SIZE IN BLOCKS OF DIR LBN BUFFER
	<FIL$A_DIR_OFID,6>,-		;OUTPUT FILE ID FROM LOOKUP
	<FIL$C_DIR_SIZE,0>-		;SIZE OF DIRECTORY CACHE ENTRY
	>
;
; MAKE THESE GLOBAL SO THAT A CACHE SIZE CAN BE PROPERLY CALCULATED
; THE CALCULATION IS:
;
;	FIL$C_SIZE + (DIRCNT * FIIL$C_DIR_SIZE> + <LBNCNT * 512>
;
	.GLOBAL	FIL$C_SIZE,FIL$C_DIR_SIZE
;
; DEFINE THE FOLLOWING WEAK REFERENCES, THEY NEED NOT BE PRESENT
;
	.WEAK	FIL$GQ_CACHE		;DESCRIPTOR FOR FILEREAD CACHE
	.WEAK	FIL$GT_DDDEV		;ASCIC DEFAULT DEVICE NAME STRING
	.WEAK	FIL$GT_TOPSYS		;ASCIC TOP LEVEL SYSTEM DIRECTORY
;
; OWN STORAGE:
;

	.PSECT	YFILEREAD,BYTE,EXE

FIL_GQ_CACHE:
	.ADDRESS FIL$GQ_CACHE
FIL_GT_DDDEV:
	.ADDRESS FIL$GT_DDDEV
FIL_GT_TOPSYS:
	.ADDRESS FIL$GT_TOPSYS

	.SBTTL	FIL$OPENFILE - RETURN FILE HEADER AND STATISTICS BLOCK
;++
; FUNCTIONAL DESCRIPTION:
;
;	THE OPENFILE ROUTINE ACCEPTS A FULL FILE NAME IN THE FORMAT
;	DEV:[DIR]FILE.TYP;VERSION.
; IT ASSIGNS AND RETURNS A CHANNEL, READS THE FILE HEADER, RETURNS THE
; STATISTICS BLOCK, AND OPTIONALLY RETURNS THE RETRIEVAL POINTERS IN
; A NORMALIZED (LONG WORD COUNT, LONG WORD LBN) FORMAT.
; THE DIRECTORY MAY BE IN ANY OF THE STANDARD FORMATS:
;	[10,40], [010040], [ABCDEFGHI], OR WITH < AND > REPLACING [ AND ].
; VERSION MAY BE ZERO IN WHICH CASE THE HIGHEST VERSION IS FOUND
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$OPENFILE
;
; INPUT PARAMETERS:
;
;	CHANADR(AP)	=	ADDRESS TO RETURN CHANNEL
;	FILNAM(AP)		ADDRESS OF 2 LONG WORD FILE NAME STRING DESCRIPTOR
;				1 - SIZE OF STRING
;				2 - ADDRESS OF STRING
;					DB1:[10,40]FILTST.EXE
;	IXFHDR(AP)		ADDRESS OF 512 BYTE BUFFER TO BE USED FOR
;					THE INDEX FILE HEADER
;	FILHDR(AP)		ADDRESS OF 512 BYTE BUFFER TO RETURN FILE HEADER
;	STATBLK(AP)		ADDRESS OF 2 LONG WORD BLOCK IN WHICH THE
;				FOLLOWING WILL BE RETURNED
;				1 - LOGICAL BLOCK NUMBER OF FIRST BLOCK OF
;					FILE OR 0 IF FILE IS NOT CONTIGUOUS
;				2 - SIZE OF FILE IN BLOCKS
;	RTRVPTRLEN(AP)	=	ADDRESS TO RETURN THE NUMBER OF
;				BYTES OF RETRIEVAL POINTERS STORED
;				***** OPTIONAL PARAMETER *****
;	RTRVPTRBUF(AP)	=	ADDRESS OF RETRIEVAL POINTER
;				BUFFER DESCRIPTOR.  THIS PARAMETER
;				IS PRESENT IF AND ONLY IF
;				RTRVPTRLEN IS PRESENT.
;				THE RETRIEVAL POINTERS ARE RETURNED IN
;				THE FORM 32 BIT BLOCK COUNT, 32 BIT LBN
;				A ZERO BUFFER DESCRIPTOR ADDRESS OR A
;				ZERO BUFFER ADDRESS MEANS DON'T
;				RETURN RETRIEVAL POINTER INFO
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		SUCCESSFUL COMPLETION
;	SS$_NOSUCHFILE		FAILED TO FIND DIRECTORY OR FILE
;	SS$_BADFILENAME		SYNTAX ERROR IN DIRECTORY OR FILE NAME STRING
;
; THE FOLLOWING COMPLETION CODES INDICATE FILE STRUCTURE PROBLEMS
;
;	SS$_BADCHKSUM		CHECKSUM ERROR IN HOME BLOCK, INDEX FILE HEADER
;				DIRECTORY FILE HEADER OR FILE HEADER
;	SS$_BADFILEHDR		FILE HEADER CONSISTENCY CHECK FAILED FOR
;				INDEX FILE, DIRECTORY FILE, OR DESIRED FILE
;	SS$_FILESTRUCT		HOME BLOCK INDICATES THAT THIS VOLUME
;				CONTAINS A NON-SUPPORTED FILE STRUCTURE
;				OR POSSIBLY THE HOMEBLOCK IS GARBAGE
;
; SIDE EFFECTS:
;
;	NONE
;
; EQUATED SYMBOLS
;
;    OFFSETS FROM AP
;
	ARGCNT		= 0
	CHANADR		= 4
	FILNAM		= 8
	IXFHDR		= 12
	FILHDR		= 16
	STATBLK		= 20
	RTRVPTRLEN	= 24		; OPTIONAL
	RTRVPTRBUF	= 28		; PRESENT IF AND ONLY IF RTRVPTRLEN IS
;
;    OFFSETS FROM FP
;
	$OFFSET	0,NEGATIVE,<-
	<FID,6>,-			;3 WORD FILE IDENTIFIER
	<DIRNAM,16>,-			;DIRECTORY NAME AREA
	<NAMBLK,10>,-			;5 WORD NAME BLOCK AREA
	<NAMDSC,12>,-			;NAME DESCRIPTOR AREA
	<SCRATCHSIZE,0>-		;SIZE OF SCRATCH AREA
	>
;
; THE FILE DESCRIPTION ON THE STACK LOOKS AS FOLLOWS:
;
;	+---------------------------+
;	|   DIRECTORY NAME COUNT    |	:NAMDSC
;	|---------------------------|
;	| ADDRESS OF DIRECTORY NAME |
;	+---------------------------+
;	|     ADDRESS OF NAMBLK     |
;	+---------------------------+
;	|                           |   :NAMBLK
;	+---------------------------+
;	|                           |
;	+---------------------------+
;	|                           |
;	|                           |
;	+---------------------------+
;	|                           |	:DIRNAM
;	|      ASCII STRING OF      |
;	|       DIRECTORY FILE      |
;	|      NAME.TYPE;VERSION    |
;	|                           |
;	+---------------------------+
;	|          FILE ID          |	:FILID
;	|          NUMBER           |
;	+---------------------------+
;	|  RELATIVE VOLUME NUMBER   |
;	+---------------------------+
;
;--

	.ENABL	LSB

FIL$OPENFILE::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R11>
	BSBW	ASSIGN_DEV		;ASSIGN THE DEVICE OONCE IN CALLER'S MODE
	BLBS	R0,OPENFILE_2		;BRANCH IF SUCCESSFUL
	RET
OPENFILE_1:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R11>
OPENFILE_2:
	SUBL	#-SCRATCHSIZE,SP	;RESERVE SCRATCH STORAGE
	MOVAL	NAMBLK(FP),NAMDSC+8(FP)	;SET ADDRESS OF NAME BLOCK
;
; IF CACHE DESCRIPTOR EXISTS AND IS IN SYSTEM SPACE, THEN WE
; HAD BETTER BE IN KERNEL MODE TO USE THE CACHE.
;
	MOVL	W^FIL_GQ_CACHE,R11	;IS CACHE IN SYSTEM SPACE?
	BGTR	10$			;BRANCH IF DESCRIPTOR PRESENT
					;AND NOT IN SYSTEM SPACE
	BEQL	20$			;BRANCH IF NO DESCRIPTOR PRESENT
	MOVPSL	R0			;GET PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R0,R0 ;FETCH CURRENT MODE
	BEQL	10$			;BRANCH IF ALREADY IN KERNEL MODE
	$CMKRNL_S B^OPENFILE_1,(AP)	;CALL THIS PROCEDURE IN KERNEL MODE
	CMPL	R0,#SS$_NOPRIV		;ASSUME NOPRIV MEANS WE COULDN'T
					;GET IN TO KERNEL MODE
	BEQL	15$
	RET
10$:	MOVL	FIL$GQ_CACHE+4,R11	;IS THE CACHE ENABLED?
	BEQL	20$			;BRANCH IF NOT
	CMPW	FIL$W_CACHE_ID(R11),#FIL$C_CACHE_ID ;CORRECT VERSION OF CACHE?
	BEQL	20$			;BRANCH IF YES
15$:	CLRL	R11			;DISABLE THE CACHE
20$:	MOVAL	FIL$GT_DDSTRING,R7	;ADDRESS OF COUNTED STRING
	MOVZBL	(R7)+,R6		;GET BYTE COUNT
	INCL	R7			;STEP OVER BRACKET
	SUBL	#2,R6			;DON'T COUNT THE BRACKETS
;
; GET FILE NAME STRING, AND STRIP DEVICE OFF IF PRESENT
;
	MOVL	FILNAM(AP),R0		;ADDRESS OF FILE NAME DESCRIPTOR
	BEQL	32$			;BRANCH IF NO NAME SPECIFIED
	MOVQ	(R0),R2			;R2 = SIZE, R3 = ADDRESS
	LOCC	#^A/:/,R2,(R3)		;DEVICE NAME PRESENT?
	BEQL	25$			;BRANCH IF NOT
	MOVAB	1(R1),R3		;ADDRESS BEYOND ":"
	MOVAB	-(R0),R2		;REMAINING SIZE
;
; SEE IF DIRECTORY SPECIFIED IN THE FILE NAME STRING
;
25$:	CMPB	#^A/[/,(R3)		;DIRECTORY DELIMITER?
	BEQL	30$			;BRANCH IF YES
	CMPB	#^A/</,(R3)		;ALTERNATE CHARACTER
	BNEQ	40$			;BRANCH IF NO DIRECTORY SPECIFIED
30$:	ADDB3	#2,(R3)+,R0		;SCAN FOR MATCHING BRACKET ] OR >
	DECL	R2			;ADJUST SIZE AND ADR OF STRING
	LOCC	R0,R2,(R3)		;SCAN FOR CLOSE BRACKET
	BNEQ	35$			;BRANCH IF FOUND IT
32$:	BRW	BADFILNAM		;BAD FILE NAME IF NO CLOSE BRACKET
35$:	MOVL	R3,R7			;ADDRESS OF DIRECTORY NAME
	SUBL3	R3,R1,R6		;SIZE OF DIRECTORY NAME
	MOVAB	-(R0),R2		;SIZE REMAINING SKIP CLOSE BRACKET
	MOVAL	1(R1),R3		;ADR OF REMAINING STRING BEYOND CLOSE BRACKET
;
; SET UP COMMON ARGUMENT LIST FOR MOUNT, FINDFILID, RDCHKFILHDR
;
;	+---------------------------+
;	|       ARGUMENT COUNT      |	: AP
;	+---------------------------+
;	|       CHANNEL NUMBER      |
;	+---------------------------+
;	|      NAME DESCRIPTOR      |
;	+---------------------------+
;	| INDEX FILE HEADER BUF ADR |
;	+---------------------------+
;	|  FILE HEADER BUFFER ADDR  |
;	+---------------------------+
;	| ADDR OF STATISTICS BLOCK  |
;	+---------------------------+
;	| ADDRESS OF FILE ID BLOCK  |
;	+---------------------------+
;	|  ADDR OF RTRV PTR LENGTH  |
;	+---------------------------+
;	| ADDR OF RTRV PTR BUF DSCR |
;	+---------------------------+
;
40$:	CLRQ	-(SP)			;ASSUME NO RETRIEVAL POINTERS REQUESTED
	CMPL	ARGCNT(AP),#RTRVPTRBUF/4 ;RETRIEVAL POINTER PARAMETERS PRESENT?
	BLSS	45$			;BRANCH IF NOT
	MOVQ	RTRVPTRLEN(AP),(SP)	;PUT RTRV PTR PARAMS IN LIST
45$:	PUSHAL	FID(FP)			;ADDRESS OF FILE ID
	MOVQ	FILHDR(AP),-(SP)	;PUSH STATBLK ADR, FILHDR ADR
	PUSHL	IXFHDR(AP)		;INDEX FILE HEADER ADDRESS
	PUSHAL	NAMDSC(FP)		;ADR OF 3 LONG WORD NAME DESCRIPTOR
	PUSHL	@CHANADR(AP)		;CHANNEL TO USE, LONG WORD FOR BOOTING
	PUSHL	#6			;PARAMETER COUNT
	TSTL	R11			;CACHE ENABLED?
	BEQL	50$
	MOVAL	FIL$A_IXFHDR(R11),IXFHDR(SP) ;USE CACHED INDEX FILE HEADER
	BRB	60$			;AND SKIP THE MOUNT
50$:	CALLG	(SP),W^FIL$MOUNT	;"MOUNT THE VOLUME" (READ HOME
					;BLOCK, INDEX FILE HEADER, GET
					;STRUCTURE LEVEL OF VOLUME)
	BLBC	R0,100$			;BRANCH IF ERROR
;
; SET UP FOR THE DIRECTORY LOOK UP
;
60$:	MOVW	#FID$C_MFD,FID(FP)	;MFD FILE NUMBER
	MOVL	#FID$C_MFD,FID+2(FP)	;MFD FILE SEQUENCE NO., RVN = 0
	TSTL	W^FIL_GT_TOPSYS		;TOP LEVEL SYSTEM DIRECTORY PRESENT?
	BEQL	70$			;BRANCH IF NOT
	MOVAL	FIL$GT_TOPSYS,R1	;GET ADDRESS OF TOP LEVEL DIR STRING
	MOVZBL	(R1)+,R0		;GET SIZE T0 R0, ADR TO R1
	BEQL	70$			;BRANCH IF NONE SPECIFIED
	MOVQ	R6,-(SP)		;SAVE DIRECTORY STRING DESCRIPTOR
	MOVQ	R0,R6			;TREAT TOPSYS LIKE DIR STRING
	BSBW	FORMDIRSTRING		;FORM THE DIRECTORY NAME
	MOVQ	(SP)+,R6		;RESTORE READ DIRECTORY DESCRIPTOR
	BRB	75$
70$:	BSBW	FORMDIRSTRING		;GET NEXT DIRECTORY TO LOOKUP
75$:	MOVQ	R0,NAMDSC(FP)		;STORE DESCRIPTOR OF ITS NAME
80$:	PUSHAL	(SP)			;REAL ADDRESS OF ARGUMENT LIST
	PUSHL	R11			;CACHE ADDRESS IF ANY
	CALLS	#2,W^FIL$FINDFILID	;FIND THE FILE ID
	BLBC	R0,100$			;BRANCH IF ERROR
	CLRQ	NAMBLK(FP)		;REINIT NAME BLOCK
	CLRW	NAMBLK+8(FP)
	TSTL	R6			;ANY MORE DIRECTORY NAMES?
	BGTR	70$			;BRANCH IF YES, LOOKUP THE NEXT
	MOVQ	R2,NAMDSC(FP)		;DESCRIPTOR FOR FILE TO LOOKUP
	CLRL	R2			;STOP THE LOOKUP LOOP
	TSTL	NAMDSC(FP)		;ALREADY DONE?
	BGTR	80$			;BRANCH IF NO, DO THE LAST ONE
85$:	CMPL	ARGCNT(AP),#RTRVPTRBUF/4 ;RETRIEVAL POINTERS DESIRED?
	BLSS	90$			;BRANCH IF NOT
	ADDL	#2,(SP)			;ADDITIONAL ARGUMENTS ARE PRESENT
90$:	CALLG	(SP),W^FIL$RDCHKFILHDR	;READ AND CHECK FILE HEADER
100$:	RET

	.DSABL	LSB

	.SBTTL	FIL$CACHE_INIT - INIT FILEREAD CACHE
;++
; FUNCTIONAL DESCRIPTION:
;
;	CACHE_INIT PERFORMS THE INITIALIZATION FOR THE FILEREAD CACHE
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$CACHE_INIT
;
; INPUT PARAMETERS:
;
;	CHANADR(AP)		ADDRESS TO RETURN LONG WORD CHANNEL
;	FILNAM(AP)		ADDRESS OF DEVICE NAME STRING DESCRIPTOR
;				THE DEVICE NAME MUST CONTAIN THE ":"
;				IF THE ADDRESS IS 0, THE STRING IS NULL,
;				OR THE NAME DOES NOT CONTAIN A ":", THE
;				DEFAULT DEVICE NAME IS USED
;	CACHE_SIZE(AP)		SIZE IN BYTES OF FILEREAD CACHE
;	CACHE_ADR(AP)		ADDRESS OF FILEREAD CACHE
;	DIR_CACHE_CNT(AP)	NUMBER OF DIRECTORY CACHE ENTRIES
;	LBN_CACHE_CNT(AP)	NUMBER OF LBN CACHE ENTRIES
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = ALWAYS SUCCESSFUL STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	FIL$GQ_CACHE QUAD WORD FILLED IN WITH SIZE AND ADDRESS OF CACHE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;
;	NONE
;
;
; EQUATED SYMBOLS, OFFSETS FROM AP
;
	CHANADR		=	4
	FILNAM		=	8
	CACHE_SIZE	=	12
	CACHE_ADR	=	16
	DIR_CACHE_CNT	=	20
	LBN_CACHE_CNT	=	24
;
;--
FIL$CACHE_INIT::
	.WORD	^M<R2,R3,R4,R5,R10,R11>
	
	ASSUME	CACHE_SIZE+4 EQ CACHE_ADR
	MOVQ	CACHE_SIZE(AP),R10	;R10=SIZE, R11=ADR
	SUBL3	#FIL$C_SIZE,R10,R0	;BYTES LEFT FOR DIR AND LBN CACHES
	BLSS	100$			;BRANCH IF NOT ENOUGH CACHE SPACE
	MOVW	#FIL$C_CACHE_ID,FIL$W_CACHE_ID(R11) ;SET CACHE_ID
					;ALLOWS MOVING CACHES BETWEEN FILEREAD'S
	MOVL	#FIL$C_SIZE,FIL$L_DIROFF(R11) ;BEGINNING OF DIR CACHE
	MOVL	#FIL$C_SIZE,FIL$L_DIRNXT(R11) ;NEXT AVAILABLE SLOT IN DIR CACHE
	MULL3	#FIL$C_DIR_SIZE,DIR_CACHE_CNT(AP),R1 ;BYTE COUNT FOR DIR CACHE
	SUBL	R1,R0			;BYTE COUNT LEFT FOR LBN CACHE
	BLSS	100$			;BRANCH IF NOT ENOUGH SPACE
	ADDL3	#FIL$C_SIZE,R1,FIL$L_DIRMAX(R11) ;END OF DIR CACHE

	ASSUME	FIL$L_DIRMAX EQ FIL$L_LBNOFF
	MOVL	FIL$L_LBNOFF(R11),FIL$L_LBNNXT(R11) ;NEXT LBN ENTRY TO ALLOCATE
	ASHL	#9,LBN_CACHE_CNT(AP),R1 ;BYTE COUNT IN LBN CACHE
	CMPL	R1,R0			;ENOUGH ROOM FOR WHOLE LBN CACHE
	BLEQ	20$			;BRANCH IF YES
	BICL3	#^X1FF,R0,R1		;USE WHAT IS LEFT TRUNCATED
20$:	ADDL3	R1,FIL$L_LBNNXT(R11),FIL$L_LBNMAX(R11) ;END OF LBN CACHE
	BSBW	ASSIGN_DEV		;ASSIGN THE DEVICE
	BLBC	R0,100$			;BRANCH IF ERROR
	PUSHAL	FIL$A_IXFHDR(R11)	;ADDRESS TO READ INDEX FILE HEADER
	CLRL	-(SP)			;UNUSED PARAMETER
	PUSHL	@CHANADR(AP)		;CHANNEL JUST ASSIGNED
	CALLS	#3,W^FIL$MOUNT		;MOUNT THE VOLUME, RETURN INDEX FILE HDR
	BLBC	R0,100$			;BRANCH IF ERROR
	MOVQ	R10,FIL$GQ_CACHE	;SAVE DESCRIPTOR OF CACHE
100$:	MOVL	S^#SS$_NORMAL,R0
	RET

	.SBTTL	FIL$CACHE_TRUNC - TRUNCATE FILEREAD CACHE
;++
; FUNCTIONAL DESCRIPTION:
;
;	CACHE_TRUNC TRUNCATES THE FILEREAD CACHE AND MAKES IT IMPOSSIBLE
; TO ADD MORE DIRECTORY CACHE OR DIRECTORY LBN ENTRIES TO IT.  IN EFFECT
; THIS ROUTINE TURNS THE CACHE INTO A READ-ONLY DATA BASE.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$CACHE_TRUNC
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	FIL$GQ_CACHE		DESCRIPTOR FOR THE CACHE
;
; OUTPUT PARAMETERS:
;
;	R0 = ALWAYS SUCCESSFUL STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	FIL$GQ_CACHE FILLED IN WITH ALTERED SIZE OF CACHE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;
;	NONE
;
; EQUATED SYMBOLS
;
;
;--

FIL$CACHE_TRUNC::
	.WORD	0
	MOVL	FIL$GQ_CACHE+4,R0	;ADDRESS OF THE CACHE
	MOVL	FIL$L_DIRNXT(R0),FIL$L_DIRMAX(R0) ;NO NEW DIRECTORY CACHE ENTRIES
	MOVL	FIL$L_LBNNXT(R0),FIL$L_LBNMAX(R0) ;NO MORE LBN BUFFERS
	MOVL	FIL$L_LBNNXT(R0),FIL$GQ_CACHE	;SET NEW SIZE OF CACHE
	MOVL	S^#SS$_NORMAL,R0
	RET

	.SBTTL	ASSIGN_DEV - ASSIGN A DEVICE AND RETURN A CHANNEL
;++
; FUNCTIONAL DESCRIPTION:
;
;	ASSIGN THE GIVEN DEVICE AND RETURN A CHANNEL NUMBER
;	FOR BOOTING THIS VALUE IS A LONG WORD
;
; INPUTS:
;
;	FILNAM(AP)	= ADDRESS OF STRING DESCRIPTOR 
;			  IF DEVICE NAME IS PRESENT IT MUST HAVE ":"
;	CHANADR(AP)	= ADDRESS TO RETURN LONG WORD OF CHANNEL NUMBER
;
; OUTPUTS:
;
;	R0,R1 ALTERED
;	R2 = SIZE OF DEVICE NAME STRING (DEFAULT IF NOT IN NAME STRING)
;	     MAYBE 0 IF DEFAULT DEVICE STRING WAS NOT PRESENT
;	     THIS IS THE CASE WHEN BOOTSTRAPPING.
;	R3 = ADDRESS OF DEVICE NAME STRING
;	     0 IF DEFAULT DEVICE STRING WAS NOT PRESENT
;
;--

ASSIGN_DEV:
	CLRL	R0			;ASSUME NULL DEFAULT DEVICE STRING
	TSTL	W^FIL_GT_DDDEV		;ADDRESS OF DEFAULT DEVICE COUNTED STRING
	BEQL	10$			;BRANCH IF NO DEFAULT DEVICE STRING
	MOVAL	FIL$GT_DDDEV,R1		;GET THE ADDRESS
	MOVZBL	(R1)+,R0		;SIZE OF DEFAULT DEVICE STRING
10$:	PUSHR	#^M<R0,R1>		;PUSH DEFAULT DEVICE DESCRIPTOR
	CLRQ	R2			;ASSUME NULL STRING DESCRIPTOR
	MOVL	FILNAM(AP),R0		;ADDRESS OF STRING DESCRIPTOR
	BEQL	20$			;BRANCH IF NO NAME GIVEN
	MOVQ	(R0),R2			;R2 = SIZE, R3 = ADR OF FILE NAME STRING
	LOCC	#^A/:/,R2,(R3)		;ANY DEVICE SPECIFIED?
	BEQL	20$			;BRANCH IF NONE
	MOVL	R3,4(SP)		;ADDRESS OF DEVICE NAME
	SUBL3	R3,R1,(SP)		;SIZE OF DEVICE NAME STRING
20$:	MOVL	SP,R0			;ADDRESS OF DEV NAME DESCRIPTOR
	$ASSIGN_S (R0),@CHANADR(AP)	;ASSIGN THE CHANNEL
	POPR	#^M<R2,R3>		;GET DEVICE NAME SIZE AND ADDRESS
	RSB

	.SBTTL	STORE3DIGITS - STORE 3 ASCII DIGITS
;++
; FUNCTIONAL DESCRIPTION:
;
;	STORE 3 DIGITS OF DIRECTORY STRING
;
; CALLING SEQUENCE:
;
;	BSBB	STORE3DIGITS
;
; INPUT:
;
;	R0 = NO. OF DIGITS TO PUT IN STRING
;	R1 = ADDRESS + 1 OF RIGHT MOST DIGIT
;	R2 = ADDRESS AT WHICH TO STORE 3 DIGITS
;
; OUTPUTS:
;
;	NONE
;
;--

STORE3DIGITS:
	CMPL	R0,#3			;3 DIGITS OR LESS SPECIFIED?
	BLEQ	5$			;YES. BRANCH.
	BRW	BADFILNAM		;NO. DIRECTORY STRING BAD. EXIT
					;WITH ERROR.
5$:	MOVW	#^A/00/,(R2)+		;BACKGROUND WITH ASCII 0
	MOVB	#^A/0/,(R2)+		;
	BRB	20$			;START LOOP AT BOTTOM
10$:	MOVB	-(R1),-(R2)		;STORE BYTES LAST TO FIRST
					;LEAVING LEADING ASCII 0'S
20$:	SOBGEQ	R0,10$			;LOOP ZERO OR MORE TIMES
	RSB

	.SBTTL	FORMDIRSTRING - GET A DIRECTORY STRING
;++
; FUNCTIONAL DESCRIPTION:
;
;	PULL THE FIRST DIRECTORY NAME OFF THE FRONT OF THE INPUT
;	DIRECTORY STRING AND FORM THE FULL FILE NAME OF THE DIRECTORY
; 	TO LOOK UP.
;
; CALLING SEQUENCE:
;
;	BSBW	FORMDIRSTRING
;
; INPUTS:
;
;	R6 = SIZE OF DIRECTORY STRING
;	R7 = ADDRESS OF DIRECTORY STRING
;		THE STRING CONTAINS NO BRACKETS,
;		IT MAY BE OF THE FORM "DIR1.DIR2.DIR3...DIRN"
;		THE FIRST AND ONLY ITEM MAY BE IN THE FORM GROUP,MEMBER
;	DIRNAM(FP) = ADDRESS OF AREA TO BUILD THE NAME
;
; OUTPUTS:
;
;	R0 = SIZE OF DIRECTORY STRING
;	R1 = ADDRESS OF DIRECTORY STRING
;	R2,R3 PRESERVED
;	R6,R7 UPDATED TO POINT AT THE REST OF THE STRING
;--

FORMDIRSTRING:
	LOCC	#^A/./,R6,(R7)		;FIND NEXT DIRECTORY STRING
	SUBL3	#1,R0,R6		;SIZE OF REST, SKIP THE "."
					;-1 IF EMPTY
	SUBL3	R7,R1,R0		;BYTE COUNT OF DIRECTORY NAME
	MOVL	R7,R1			;ADDRESS OF DIRECTORY NAME
	MOVAB	1(R1)[R0],R7		;ADDRESS OF NEXT BYTE BEYOND "."
	PUSHR	#^M<R0,R1,R2>		;SAVE STRING DESCRIPTORS AND R2
	CMPL	R0,#9			;LENGTH OF DIRECTORY STRING OKAY?
	BLEQ	5$			;YES. BRANCH.
	BRW	BADFILNAM		;NO. EXIT WITH ERROR.
5$:	LOCC	#^A/,/,R0,(R1)		;GOOD STRING: ANY ","?
	BEQL	20$			;BRANCH IF NOT, RETURN THE DESCRIPTOR AS IS
	PUSHL	R0			;SAVE REMAINING BYTE COUNT
	SUBL3	R0,4(SP),R0		;BYTE COUNT TO LEFT OF ","
	MOVAL	DIRNAM(FP),R2		;ADDRESS TO STORE FIRST 3 CHARS
	BSBB	STORE3DIGITS		;STORE THEM
	SUBL3	#1,(SP)+,R0		;COUNT OF CHARS TO RIGHT OF ","
	ADDL3	(SP)+,(SP)+,R1		;ADR OF BYTE TO RIGHT OF LAST CHAR
	MOVAL	DIRNAM+3(FP),R2		;ADR TO STORE LAST 3 CHARS OF DIR NAME
	BSBB	STORE3DIGITS		;STORE THEM
	POPR	#^M<R2>			;RESTORE SAVED R2
	MOVL	#6,R0			;6 BYTES STRING SIZE
10$:	MOVAB	DIRNAM(FP)[R0],R1	;POINT TO END OF STRING
	MOVL	#^A/.DIR/,(R1)+		;PUT TYPE IN STRING
	MOVW	#^A/;1/,(R1)		;AND VERSION AS WELL
	MOVAB	DIRNAM(FP),R1		;ADDRESS OF STRING
	ADDL	#6,R0			;SIZE INCLUDES ".DIR;1"
	RSB
20$:	PUSHR	#^M<R3,R4,R5>		;SAVE THESE FROM MOVC3
;
; 12(SP) = SIZE OF STRING, 16(SP) = ADDRESS
;
	MOVC3	12(SP),@16(SP),DIRNAM(FP) ;MOVE NAME TO SCRATCH AREA
	POPR	#^M<R3,R4,R5>		;RESTORE REGISTERS
	POPR	#^M<R0,R1,R2>
	BRB	10$

	.SBTTL	MOUNT - MOUNT THE VOLUME, INIT FOR FILE LOOKUP
;++
; FUNCTIONAL DESCRIPTION:
;
;	MOUNT PERFORMS THE NECESSARY INITIALIZATION FOR FILE LOOKUP.
; IT READS THE HOME BLOCK, AND THEN RETURNS THE INDEX FILE HEADER TO THE
; SPECIFIED BUFFER.  THE INDEX FILE HEADER IS ALTERED BY RECORDING THE
; VIRTUAL BLOCK OFFSET REQUIRED TO TRANSLATE 'FILE NUMBER' TO INDEX FILE VBN
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$MOUNT
;
; INPUT PARAMETERS:
;
;	CHAN(AP)		CHANNEL ON WHICH DEVICE IS ASSIGNED
;	UNUSED			2ND PARAMETER NOT USED 
;	IXFHDR(AP)		ADDRESS TO RETURN INDEX FILE HEADER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		SUCCESSFUL COMPLETION
;	SS$_FILESTRUCT		FILE STRUCTURE LEVEL NOT SUPPORTED
;	SS$_BADCHKSUM		CHECKSUM ERROR ON HOME BLOCK OR INDEX FILE HEADER
;	SS$_BADFILEHDR		INDEX FILE HEADER IS BAD
;
; SIDE EFFECTS:
;
;	NONE
;
;
; EQUATED SYMBOLS, OFFSETS FROM AP
;
	CHAN		=	4
	IXFHDR		=	12
;
;--

FIL$MOUNT::
	.WORD	^M<R2,R3,R4>
	MOVL	IXFHDR(AP),R3		;ADDRESS OF BUFFER
	ROTL	#9,#1,-(SP)		;NUMBER OF BYTES TO READ
	MOVZWL	#IO$_READLBLK,-(SP)	;READ LOGICAL BLOCK FUNCTION
	PUSHL	R3			;BUFFER ADDRESS
	PUSHL	#1			;LOGICAL BLOCK NUMBER 1 IS HOME BLK
	PUSHL	CHAN(AP)		;CHANNEL
	PUSHL	#5			;NO. OF ARGUMENTS
	CALLG	(SP),W^FIL$RDWRTLBN	;READ THE HOME BLOCK
	BLBC	R0,30$			;BRANCH IF ERROR
	MOVL	R3,R1			;ADDRESS OF HOME BLOCK
	MOVZWL	#HM1$W_CHECKSUM1@-1,R0	;NO. OF WORDS IN FIRST CHECKSUM
	BSBW	FIL$CHECKSUM1		;CHECK THE FIRST CHECKSUM
	MOVL	R3,R1			;ADR OF HOME BLOCK AGAIN
	BSBW	FIL$CHECKSUM		;CHECK THE MAIN CHECKSUM
	CASE	HM1$W_STRUCLEV+1(R3),<-
		15$,-			;STRUCTURE LEVEL 1
		10$-			;STRUCTURE LEVEL 2
		>,TYPE=B,LIMIT=#1
5$:	MOVZWL	#SS$_FILESTRUCT,R0	;UNSUPPORTED FILE STRUCTURE LEVEL
	RET
;
; STRUCTURE LEVEL 2
;
10$:	MOVL	HM2$L_IBMAPLBN(R3),R1	;INDEX BIT MAP STARTING LBN
	MOVZWL	HM2$W_IBMAPSIZE(R3),R0	;INDEX BIT MAP SIZE IN BLOCKS
	MOVL	HM2$L_MAXFILES(R3),R4	;MAXIMUM FILES ON VOLUME
					;ONLY INTERESETED IN HIGH 16 BITS
	MULW3	#4,HM2$W_CLUSTER(R3),R4	;4*CLUSTER TO LOW WORD OF R4
	BRB	20$
;
; STRUCTURE LEVEL 1
;
15$:	ROTL	#16,HM1$L_IBMAPLBN(R3),R1 ;LOGICAL BLK NO. OF 1ST INDEX BIT MAP BLK
	MOVZWL	HM1$W_IBMAPSIZE(R3),R0	;NO. OF BLOCKS OF INDEX BIT MAP
	MOVL	#2,R4			;NUMBER OF VBN'S BEFORE INDEX FILE BIT MAP
20$:	ADDW	R0,R4			;LOW WORD IS VBNOFFSET
					;FROM FILE ID TO INDEX FILE VBN
;
; READ INDEX FILE HEADER
;	R0 - NUMBER OF BLOCKS IN INDEX FILE
;	R1 - STARTING LBN OF INDEX FILE
;
	ADDL3	R0,R1,8(SP)		;DESIRED LBN TO ARG LIST
	CALLS	(SP)+,W^FIL$RDWRTLBN	;READ INDEX FILE HEADER
					;STRIP OFF THE ARGUMENT LIST
	BLBC	R0,30$			;BRANCH IF ERROR
	MOVL	R3,R1			;ADDRESS OF HEADER
	CLRL	-(SP)			;FORM FILE ID ON STACK
	PUSHL	#^X10001		;FOR THE INDEX FILE HEADER
	MOVL	SP,R0			;ADDRESS OF FILE ID
	BSBW	FIL$CHKFILHDR		;CHECK THE FILE HEADER (SEE IF
					;FILE IDS MATCH)
	MOVW	R4,FH1$W_VBNOFFSET(R3)	;STORE VBN OFFSET
;
; IF MAXFILES WAS GREATER THAN ^XFFFF THEN HIGH 16 BITS OF R4 WILL BE
; NON-ZERO.  IN THIS CASE, RECORD THE BIGFILNUM BIT IN THE STRUCLEV WORD
;
	ASHL	#-16,R4,R4		;SEE IF HIGH 16 BITS = 0
	BEQL	25$
	BBSS	#FH2$V_BIGFILNUM,FH2$W_STRUCLEV(R3),25$ ;MUST USE HIGH 8 BITS
					;OF RVN FIELD AS FILE NUMBER EXTENSION
25$:	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION
30$:	RET

	.SBTTL	FINDFILID - FIND FILE ID FOR SPECIFIED FILE
;++
; FUNCTIONAL DESCRIPTION:
;
;	FINDFILID SCANS A SPECIFIED DIRECTORY FOR A FILE AND
; RETURNS ITS FILE ID IF FOUND.  STRUCTURE LEVEL 1 AND 2 DIRECTORIES
; ARE SUPPORTED, 0 VERSION NUMBER MEANS FIND MOST RECENT VERSION,
; -1 VERSION (FIND OLDEST) IS NOT SUPPORTED.  VERSION FOUND IS RETURNED IN
; THE NAME BLOCK ADDRESSED BY THE FILE DESCRIPTOR (LEVEL 1 ONLY).
; NOTE THAT NON-CONTIGUOUS DIRECTORIES ARE NOT SUPPORTED.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$FINDFILID
;
; INPUT PARAMETERS:
;
;	CHAN(AP)		;CHANNEL ON WHICH DEVICE IS ASSIGNED
;	FILDSC(AP)	=	ADDRESS OF 3 LONG WORD FILE DESCRIPTOR
;				1 - SIZE OF ASCII STRING,  A 0 VALUE MEANS
;					USE THE CONTENTS OF THE NAMBLK BELOW
;				2 - ADDRESS OF ASCII STRING
;				3 - ADDRESS OF NAME BLOCK - USED ONLY FOR LEVEL 1
;					MAY CONTAIN DEFAULTS, BUT MUST BE
;					AT LEAST INITIALIZED TO ZERO
;					IT WILL BE WRITTEN.
;	IXFHDR(AP)		ADR OF INDEX FILE HDR AS RETURNED FROM FIL$MOUNT
;	DIRBUF(AP)		ADR OF 512 BYTE BUFFER TO USE FOR DIRECTORY SCAN
;	STATBLK(AP)		ADDRESS OF 2 LONG WORD AREA USED FOR A
;				SCRATCH STATISTICS BLOCK
;	FILID(AP)		ADR OF 3 WORD AREA USED BOTH AS THE ID OF
;				THE DIRECTORY TO SCAN AND AS THE PLACE TO
;				RETURN THE ID OF THE FILE FOUND
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		SUCCESSFUL COMPLETION
;	SS$_NOSUCHFILE		FILE NOT FOUND
;	SS$_BADFILENAME		SYNTAX ERROR IN FILE NAME
;	SS$_BADCHKSUM		CHECKSUM ERROR ON DIRECTORY FILE HEADER
;	SS$_BADFILEHDR		DIRECTORY FILE HEADER WAS BAD
;
; SIDE EFFECTS:
;
;	NONE
;
;
; EQUATED SYMBOLS, OFFSETS FROM AP
;
	CHAN		=	4
	FILDSC		=	8
	IXFHDR		=	12
	DIRBUF		=	16
	STATBLK		=	20
	FILID		=	24
;
; OFFSETS FROM FP
;
	$OFFSET	0,NEGATIVE,<-
	DIR_BFCNT,-			;BUFFER COUNT REMAINING IN LBN CACHE
	DIR_BUF,-			;NEXT BUFFER ADDRESS IN DIR LBN CACHE
	ENTRY_ADR,-			;FOUND CACHE ENTRY ADR
	<ENTRY,FIL$C_DIR_SIZE>,-	;CACHE ENTRY FOR SEARCH/CREATE
	<SCRATCH_SIZE,0>-		;SIZE OF SCRATCH AREA
	>
;
;--

FIL$FINDFILID::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	SUBL	#-SCRATCH_SIZE,SP	;ALLOCATE SCRATCH SPACE
	MOVC5	#0,(SP),#0,#-SCRATCH_SIZE,(SP) ;ZERO THE SCRATCH STORAGE
	CLRL	R11			;ASSUME NO CACHE
	CMPL	(AP),#2			;IF ONLY 2 ARGUMENTS
	BNEQ	5$
	MOVL	4(AP),R11		;THE FIRST IS THE CACHE ADDRESS
	MOVL	8(AP),AP		;THE SECOND IS THE REAL ARGUMENT LIST
5$:	TSTL	R11			;CACHE ENABLED?
	BEQL	65$			;BRANCH IF NOT
;
; WE DO HAVE A CACHE TO LOOK IN AND MAKE ENTRIES IN, SET UP THE
; SCRATCH REGION FOR A LOOKUP
;
	ASSUME	ENTRY EQ SCRATCH_SIZE	;SCRATCH CACHE ENTRY MUST BE ON TOP
	ASSUME	FIL$A_DIR_FID EQ 0	;DIR ID IS AT FRONT OF CACHE ENTRY
	MOVC3	#6,@FILID(AP),(SP)	;STORE DIRECTORY ID
	MOVQ	@FILDSC(AP),R0		;GET LOOKUP NAME DESCRIPTOR
	CMPL	R0,#6			;MUST BE MORE THAN ".DIR;1"
	BLEQ	10$			;BRANCH IF NOT A DIRECTORY NAME
	CMPL	R0,#15			;AT MOST 9 CHAR WITH ".DIR;1"
	BGTR	10$			;BRANCH IF NOT A DIRECTORY NAME
	ADDL3	R0,R1,R2		;POINT OFF END OF NAME STRING
	CMPW	#^A/;1/,-(R2)		;LAST 2 BYTES ";1" ?
	BNEQ	10$			;BRANCH IF NOT A DIRECTORY NAME
	CMPL	#^A/.DIR/,-(R2)		;PRECEDED BY ".DIR" ?
	BNEQ	10$			;BRANCH IF NOT A DIRECTORY NAME
	SUBL	#6,R0			;JUST KEEP THE NAME PART
	MOVB	R0,FIL$T_DIR_NAM+ENTRY(FP) ;PUT SIZE AND NAME STRING
	MOVC3	R0,(R1),FIL$T_DIR_NAM+1+ENTRY(FP) ;IN ENTRY TO LOOKUP
10$:	ADDL3	FIL$L_DIROFF(R11),R11,R8 ;ADDRESS OF DIRECTORY CACHE
	ADDL3	FIL$L_DIRNXT(R11),R11,R9 ;ADDRESS OF LAST+1 BYTE
	BRB	60$			;LOOP 0 OR MORE TIMES

	ASSUME	FIL$T_DIR_NAM EQ FIL$A_DIR_FID+6
20$:	CMPC3	#6+10,FIL$A_DIR_FID+ENTRY(FP), - ;DOES FID AND NAME MATCH?
		FIL$A_DIR_FID(R8)
	BNEQ	30$			;BRANCH IF DIDN'T MATCH ALL OF IT
	MOVL	R8,ENTRY_ADR(FP)	;RECORD THAT A MATCH WAS FOUND
	BRB	70$
;
; FAILED TO MATCH THE ENTIRE ENTRY, DID WE MATCH THE DIR ID FIELD?
;
30$:	CMPL	R0,#10			;IF 10 OR LESS CHAR'S LEFT
	BGTR	50$			;THEN MATCHED THE DIR ID
	MOVL	R8,ENTRY_ADR(FP)	;SAVE THIS PARTIAL MATCH
	TSTB	FIL$T_DIR_NAM+ENTRY(FP)	;IF NOT SEARCHING FOR A DIR NAME
	BEQL	70$			;THEN THIS ENTRY WILL DO FINE
50$:	ADDL	#FIL$C_DIR_SIZE,R8	;ADDRESS OF NEXT CACHE ENTRY
60$:	CMPL	R8,R9			;DONE SCANNING DIR CACHE?
	BLSSU	20$			;BRANCH IF NOT, CHECK NEXT ENTRY
;
; ENTRY_ADR(FP)	= ADDRESS OF CACHE HIT ENTRY
;		= 0 IF NO MATCH FOUND
; IF WE DROP THROUGH TO HERE AND WE GOT A CACHE HIT, THEN IT WAS
; NOT EXACTLY WHAT WE WERE LOOKING FOR.  BUT IT DID MATCH THE DIRECTORY.
;
	MOVL	ENTRY_ADR(FP),R8	;WAS THERE A CACHE HIT?
65$:	BEQL	READ_DIR_HEADER		;BRANCH IF NO
	BRB	80$			;YES, FOR DIRECTORY LBN AND SIZE
;
; FOUND WHAT WE WERE LOOKING FOR - MAY ONLY NEED DIRECTORY LBN AND SIZE
;
70$:	TSTL	FIL$A_DIR_OFID(R8)	;DID WE GET A FILE ID?
	BEQL	80$			;BRANCH IF NOT
	MOVC3	#6,FIL$A_DIR_OFID(R8),@FILID(AP) ;RETURN THE FILE ID
	MOVZWL	S^#SS$_NORMAL,R0	;SET SUCCESS STATUS
72$:	RET				;AND RETURN
;
; CACHE HIT ONLY FOUND THE DIRECTORY LBN AND SIZE, SAVING THE
; READ OF THE DIRECTORY FILE HEADER.
;
80$:	MOVQ	FIL$Q_DIR_HDR(R8),FIL$Q_DIR_HDR+ENTRY(FP) ;SAVE DIRHDR
					;INFO FOR MAKING A NEW ENTRY
					;WITH THE DIRECTORY FID IN IT
	MOVL	FIL$L_DIR_BFOFF(R8),FIL$L_DIR_BFOFF+ENTRY(FP)
	MOVW	FIL$W_DIR_BFCNT(R8),FIL$W_DIR_BFCNT+ENTRY(FP)
					;SAVE DIR LBN CACHE INFO TOO
;
; AT THIS POINT ENTRY(FP) CONTAINS DIRECTORY LBN CACHE INFORMATION
; IF ONE HAD ALREADY EXISTED OR IF WE JUST CREATED IT.
; SET UP THE WORKING LOCATIONS FOR THE DIRECTORY LBN CACHE
;
90$:	SUBL3	#1,FIL$L_DIR_LBN+ENTRY(FP),R6 ;R6=STARTING LBN - 1
	MOVZWL	FIL$W_DIR_BKCNT+ENTRY(FP),R7 ;R7=SIZE OF DIRECTORY IN BLOCKS
	MOVZWL	FIL$W_DIR_BFCNT+ENTRY(FP),DIR_BFCNT(FP) ;BUFFER COUNT IN LBN CACHE
	ADDL3	FIL$L_DIR_BFOFF+ENTRY(FP),R11,DIR_BUF(FP) ;STARTING ADR IN CACHE
	ADDL	R6,R7			;LAST LBN OF FILE INCLUSIVE
	BLBC	FIL$B_DIR_LVL+ENTRY(FP),100$ ;BRANCH IF STRUCTURE LEVEL 1
	BRW	FIND_LEVEL2_1
100$:	BRW	FIND_LEVEL1_1
BADDIR2:
	BRW	BADDIR
BADRET1:
	RET
;
; CACHE WAS NOT ENABLED OR THERE WAS NOT A HIT FOR THIS DIRECTORY
;
READ_DIR_HEADER:
	CALLG	(AP),FIL$RDCHKFILHDR	;READ AND CHECK DIRECTORY FILE HEADER
	BLBC	R0,BADRET1		;BRANCH IF ERROR
	MOVL	DIRBUF(AP),R5		;ADDRESS OF BUFFER TO READ DIRECTORY BLOCKS
	SUBL3	#1,@STATBLK(AP),R6	;GET START LBN - 1
;
; IF THIS RESULT IS NEGATIVE, THEN THE DIRECTORY WAS NOT CONTIGUOUS.
; THIS CODE SUPPORTS ONLY CONTIGUOUS DIRECTORIES, ANOTHER BUFFER WOULD
; BE REQUIRED TO HOLD THE DIRECTORY HEADER IN ORDER TO SUPPORT NON-CONTIGUOS
; DIRECTORIES.  SUCH DIRECTORIES ARE ONLY CREATED BY FILES-11 WHEN
; A DIRECTORY MUST BE EXTENDED AND THERE IS NOT ENOUGH CONTIGUOUS SPACE
; ANYWHERE ON THE VOLUME TO MAKE A NEW DIRECTORY OF THE CORRECT SIZE.
;
	BLSS	BADDIR2			;BRANCH IF NOT CONTIGUOUS
;
; SEE IF THIS LOOKS LIKE A DIRECTORY FILE
;
	MOVAL	FH1$W_RECATTR(R5),R4	;ADDRESS OF LEVEL 1 RECORD ATTRIBUTES
	SUBB3	#1,FH1$W_STRUCLEV+1(R5),R10 ;0 IF LEVEL 1, 1 IF LEVEL 2
	BEQL	10$			;BRANCH IF LEVEL 1
	MOVAL	FH2$W_RECATTR(R5),R4	;ADDRESS OF LEVEL 2 RECORD ATTRIBUTES
10$:	ROTL	#16,FAT$L_EFBLK(R4),R7	;VBN OF DIRECTORY EOF
	TSTW	FAT$W_FFBYTE(R4)	;IF ZERO, EFBLK IS LAST+1 VBN
	BNEQ	20$
	DECL	R7			;CORRECT TO GET LAST VBN
20$:	ADDL3	#1,R6,FIL$L_DIR_LBN+ENTRY(FP) ;SAVE START LBN,
	MOVW	R7,FIL$W_DIR_BKCNT+ENTRY(FP) ;DIRECTORY SIZE,
	MOVB	R10,FIL$B_DIR_LVL+ENTRY(FP) ;AND STRUCTURE LEVEL
;
; SEE IF WE CAN SET UP A CACHE OF THE DIRECTORY BLOCKS FOR THIS DIRECTORY
;
	TSTL	R11			;ANY CACHEING ENABLED?
	BEQL	80$			;BRANCH IF NOT
	SUBL3	FIL$L_LBNNXT(R11),FIL$L_LBNMAX(R11),R2 ;NO. OF BYTES
					;AVAILABLE TO ALLOCATE
	ASHL	#-9,R2,R2		;NO. OF PAGES AVAILABLE
	BEQL	80$			;BRANCH IF NO SPACE AT ALL
	CMPL	R2,R7			;ENOUGH ROOM FOR WHOLE DIR
	BLEQ	40$			;BRANCH IF NOT, USE WHAT IS LEFT
	MOVL	R7,R2			;YES, USE THE RIGHT SIZE
40$:	MOVL	FIL$L_LBNNXT(R11),R3	;OFFSET TO DIR LBN CACHE
;
; READ THE DISK BLOCKS INTO THE LBN CACHE.
;
	ASHL	#9,R2,-(SP)		;BYTE COUNT TO TRANSFER
	MOVZWL	#IO$_READLBLK,-(SP)	;READ LOGICAL BLOCK FUNCTION
	PUSHAB	(R11)[R3]		;BUFFER ADDRESS
	PUSHL	FIL$L_DIR_LBN+ENTRY(FP)	;STARTING LBN
	PUSHL	CHAN(AP)		;CHANNEL
	CALLS	#5,FIL$RDWRTLBN		;FILL THE DIR LBN CACHE
	BLBC	R0,80$			;BRANCH IF ERROR
;
; NOTE THAT DIRECTORY BLOCKS ARE IN MEMORY
;
	MOVL	R2,DIR_BFCNT(FP)	;COUNT OF BLOCKS READ IN
	MOVAB	(R11)[R3],DIR_BUF(FP)	;ADDRESS OF FIRST BLOCK READ IN
	TSTB	FIL$T_DIR_NAM+ENTRY(FP)	;ARE WE LOOKING UP ANOTHER DIRECTORY?
	BNEQ	80$			;BRANCH IF YES, DON'T ALLOCATE
					;A PERMANENT CACHE ENTRY FOR 
					;AN INTERMEDIATE LEVEL DIRECTORY
	MOVW	R2,FIL$W_DIR_BFCNT+ENTRY(FP) ;SET UP FOR PERMANENT ENTRY
	MOVL	R3,FIL$L_DIR_BFOFF+ENTRY(FP) ;SAVE THE SIZE AND OFFSET OF CACHE
	ASHL	#9,R2,R1		;NO. OF BYTES IN CACHE
	ADDL	R1,FIL$L_LBNNXT(R11)	;ALLOCATE THE CACHE
;
; IF IT WAS POSSIBLE TO READ THE DIRECTORY INTO THE LBN CACHE AREA,
; THE SCAN WILL FIND THESE BLOCKS AS THEY ARE NEEDED.
;
80$:
;
; R6 = STARTING LBN - 1 FOR THE DIRECTORY
; R7 = COUNT OF BLOCKS OF DIRECTORY TO BE SCANNED
; R10[0:7] = 0 IF STRUCTURE LEVEL 1
;	   = 1 IF STRUCTURE LEVEL 2
;
	ADDL	R6,R7			;LAST LBN OF FILE (INCLUSIVE)
	BLBS	R10,FIND_LEVEL2		;BRANCH IF STRUCTURE LEVEL 2
	BRW	FIND_LEVEL1

;
; ERROR RETURNS.
;
BADDIR:	MOVZWL	#SS$_BADIRECTORY,R0
BADRET:	RET
BADFILNAM:
	MOVZWL	#SS$_BADFILENAME,R0	;RETURN ERROR CODE.
	RET

	.SBTTL	FIL$FINDFILID - STRUCTURE LEVEL 2
;
; STRUCTURE LEVEL 2
;
FIND_LEVEL2:
	BBC	#FH2$V_DIRECTORY,FH2$L_FILECHAR(R5),BADDIR ;DIRECTORY BIT MUST BE SET

	ASSUME	FAT$B_RATTRIB EQ FAT$B_RTYPE+1
	CMPW	#<FAT$M_NOSPAN @ 8 + FAT$C_VARIABLE>,- ;VARIABLE LENGTH
		FAT$B_RTYPE(R4)		;RECORDS NOT CROSSING BLOCK BOUNDARIES
	BNEQ	BADDIR			;BRANCH IF BAD RECORD ATTRIBUTES
;
; ***** NOTE THAT EACH BLOCK MUST END IN A RECORD SIZE OF -1
; ***** A RECORD IS NOT ALLOWED TO EXACTLY FILL THE BLOCK
; ***** PDP-11 FILE CONTROL SERVICES WILL READ THIS FILE CORRECTLY, BUT
; ***** WILL NOT WRITE IT PROPERLY.  LIKEWISE FOR RMS-11 AND RMS-32
;
FIND_LEVEL2_1:
	MOVQ	@FILDSC(AP),R8		;R8 = SIZE, R9 = ADDRESS OF FILE NAME STRING
	CLRL	R10			;ASSUME DEFAULT VERSION
	MOVQ	R8,R3			;COPY FILE NAME DESCRIPTOR
	LOCC	#^A/./,R3,(R4)		;FIND FILE TYPE DELIMITER IF PRESENT
	BEQL	40$			;BRANCH IF NOT PRESENT
	MOVAB	-(R0),R3		;SIZE OF REMAINING STRING
	MOVAB	1(R1),R4		;ADDRESS OF STRING BEYOND DELIMITER
40$:	LOCC	#^A/;/,R3,(R4)		;SEE IF VERSION DELIMITER PRESENT
	BNEQ	60$			;BRANCH IF IT IS
	LOCC	#^A/./,R3,(R4)		;TRY ALTERNATE VERSION DELIMITER
	BEQL	120$			;BRANCH IF NO VERSION STRING PRESENT
;
; R0 = BYTE COUNT OF VERSION STRING PLUS DELIMITER
; R1 = ADDRESS OF VERSION DELIMITER
;
60$:	SUBL	R0,R8			;REDUCE FILE NAME STRING SIZE
					;ELIMINATING VERSION STRING AND DELIMITER
	PUSHAL	-(SP)			;RESERVE LONG WORD FOR VERSION NUMBER
					;AND PUSH ITS ADDRESS
	PUSHAB	1(R1)			;ADDRESS OF VERSION STRING
	PUSHAB	-(R0)			;SIZE OF VERSION STRING
	CALLS	#3,LIB$CVT_DTB		;CONVERT DECIMAL VERSION STRING TO BINARY
	BLBC	R0,BADFILNAM		;BRANCH IF SYNTAX ERROR IN VERSION STRING
	MOVL	(SP)+,R10		;FETCH EXPLICIT VERSION NUMBER
;
; R6  = ADDRESS OF LAST LBN READ FROM DIRECTORY FILE (FIRST - 1)
; R7  = ADDRESS OF LAST LBN (INCLUSIVE) TO BE READ FROM DIRECTORY FILE
; R8  = SIZE OF NAME STRING TO SCAN FOR
; R9  = ADDRESS OF NAME STRING TO SCAN FOR
; R10 = FILE VERSION NUMBER IF EXPLICIT, OR 0 IF DEFAULT TO LATEST VERSION
;
	BRB	120$			;BEGIN LOOP AT BOTTOM
;
; R5 = ADDRESS OF NEXT RECORD
;
100$:	MOVZBL	DIR$B_NAMECOUNT(R5),R4	;GET SIZE OF "NAME.TYP" STRING
	CMPC5	R8,(R9),#0,R4,DIR$T_NAME(R5) ;SEE IF STRINGS MATCH
	BEQL	200$			;BRANCH IF THEY DO
	BLSS	140$			;BRANCH IF BEYOND WHERE NAME WOULD GO
	MOVZWL	DIR$W_SIZE(R5),R0	;USING THE SIZE OF THIS RECORD
	MOVAB	2(R5)[R0],R5		;FORM ADDRESS OF NEXT RECORD
110$:	TSTW	DIR$W_SIZE(R5)		;END OF BLOCK? (MARKED WITH -1)
	BGTR	100$			;BRANCH IF NOT
120$:	AOBLEQ	R7,R6,160$
140$:	MOVZWL	#SS$_NOSUCHFILE,R0	;CANNOT FIND FILE
150$:	RET
160$:	BSBW	READ_DIR_LBN		;READ THE NEXT DIRECTORY LBN
	BRB	110$
;
; FOUND A MATCH OF FILE NAME AND TYPE
;
200$:	INCL	R4			;ROUND UP NAME COUNT
	BICL	#1,R4			;TO EVEN NUMBER OF BYTES
	MOVAB	DIR$T_NAME(R5)[R4],R3	;ADDRESS OF FIRST VERSION ENTRY
	MOVZWL	DIR$W_SIZE(R5),R0	;SIZE OF THIS RECORD
	MOVAB	2(R5)[R0],R5		;FORM ADDRESS OF BEGINNING OF NEX RECORD
					;WHICH IS ALSO THE END OF THE VERSIONS
	TSTL	R10			;LATEST VERSION DESIRED?
	BEQL	240$			;BRANCH IF YES, R3 IS ADDRESS OF
					;DESIRED VERSION AND FILE ID
230$:	CMPW	R10,DIR$W_VERSION(R3)	;IS THIS THE RIGHT VERSION?
	BEQL	240$			;BRANCH IF YES
	BGTRU	140$			;BRANCH IF PAST WHERE IT WOULD BE
	ADDL	#DIR$C_VERSION,R3	;NEXT VERSION ENTRY
	CMPL	R3,R5			;END OF RECORD?
	BLSSU	230$			;BRANCH IF NOT, CHECK NEXT VERSION
	BRB	110$			;VERSION NOT IN THIS VERSION CHAIN
					;SEE IF IT IS IN THE NEXT RECORD
;
; FOUND THE FILE ID, RETURN IT TO CALLER
;
240$:	MOVQ	DIR$W_FID(R3),R6	;GET THE FILE ID
	MOVZWL	R7,R7
	MOVC3	#6,DIR$W_FID(R3),@FILID(AP) ;AND RETURN IT TO THE CALLER
;
; SEE IF WE SHOULD MAKE A CACHE ENTRY FOR THIS LOOKUP
; R6,R7 = FID
;
EXIT_FILID_FND:
	TSTL	R11			;IS THE CACHE ENABLED?
	BEQL	100$			;BRANCH IF NOT, JUST RETURN THE FID
	TSTB	FIL$T_DIR_NAM+ENTRY(FP)	;WAS LOOKUP FOR A DIRECTORY?
	BNEQ	20$			;BRANCH IF YES, MAKE A CACHE ENTRY
	TSTL	ENTRY_ADR(FP)		;CACHE HIT FOR THIS DIR HDR?
	BNEQ	100$			;BRANCH IF YES
	BRB	30$			;MAKE THE CACHE ENTRY FOR THIS DIR HDR
20$:	MOVL	R6,FIL$A_DIR_OFID+ENTRY(FP) ;STORE THE FID FOUND
	MOVW	R7,FIL$A_DIR_OFID+4+ENTRY(FP)
30$:	MOVL	FIL$L_DIRNXT(R11),R8	;GET OFFSET TO FREE SPACE
	ADDL3	#FIL$C_DIR_SIZE,R8,R0	;FORM OFFSET TO END OF NEW ENTRY
	CMPL	R0,FIL$L_DIRMAX(R11)	;ENOUGH SPACE FOR NEW ENTRY?
	BGTR	90$			;BRANCH IF NOT
	MOVL	R0,FIL$L_DIRNXT(R11)	;YES, ALLOCATE THE NEW ENTRY
	MOVC3	#FIL$C_DIR_SIZE,ENTRY(FP),(R11)[R8] ;AND WRITE IT
90$:
100$:	MOVZWL	#SS$_NORMAL,R0		;INDICATE SUCCESSFUL COMPLETION
	RET
;
; BAD DIRECTORY FILE
;
BADDIR1:
	BRW	BADDIR

	.SBTTL	FIL$FINDFILID - STRUCTURE LEVEL 1
;
; STRUCTURE LEVEL 1 FIND
; R4 = ADDRESS OF RECORD ATTRIBUTES
;
FIND_LEVEL1:
	CMPB	#FAT$C_FIXED,FAT$B_RTYPE(R4) ;FIXED LENGTH RECORD?
	BNEQ	BADDIR1			;BRANCH IF NOT
	CMPW	#16,FAT$W_RSIZE(R4)	;16 BYTES EACH
	BNEQ	BADDIR1			;BRANCH IF NOT
;
; GET FILE NAME BLOCK FOR STRUCTURE LEVEL 1 DIRECTORY SCAN
;
FIND_LEVEL1_1:
	MOVL	FILDSC(AP),R3		;ADDRESS OF 3 LONG WORD FILE DESCRIPTOR
	TSTL	(R3)			;SIZE OF ASCII STRING
	BEQL	25$			;BRANCH IF NAME BLOCK ALL SET UP
	PUSHL	8(R3)			;ADDRESS OF NAME BLOCK
	PUSHAL	(R3)			;ADDRESS OF STRING DESCRIPTOR
	CALLS	#2,W^FIL$CVTFILNAM	;CONVERT ASCII STRING TO NAME BLOCK (RAD50)
	BLBC	R0,90$			;BRANCH IF ERROR
25$:	MOVL	8(R3),R3		;ADDRESS OF NAME BLOCK
	MOVZWL	8(R3),(SP)		;SAVE FILE VERSION OVER FILE SIZE
					;THAT WAS LEFT FROM THE STATBLK CALL
	MOVL	FILID(AP),R0		;ADDRESS OF RETURN FILE ID
	CLRL	(R0)+			;INIT TO ZERO
	CLRW	(R0)			;ALL 3 WORDS.
	MOVAL	511(R5),R4		;ADDRESS OF LAST BYTE OF BUFFER
	BRB	80$			;START DIRECTORY SCAN AT BOTTOM OF LOOP
;
; THE FOLLOWING REGISTER CONVENTION ARE USED IN THE DIRECTORY SCAN
;	R2 = CURRENT DIRECTORY ENTRY BEING SCANNED
;	R3 = NAMEBLOCK TO COMPARE AGAINST
;	R4 = ADDRESS OF LAST BYTE OF DIRECTORY BLOCK
;	R5 = ADDRESS OF DIRECTORY BUFFER
;	R6 = LOGICAL BLOCK NUMBER OF CURRENT DIRECTORY BLOCK
;	R7 = LAST LOGICAL BLOCK NUMBER (INCLUSIVE) TO SCAN
;	0(SP) = VERSION OF FILE FROM NAME BLOCK
;
30$:	BSBW	READ_DIR_LBN		;READ THE NEXT DIRECTORY LBN
	MOVL	R5,R2			;SET DIRECTORY RECORD POINTER
40$:	TSTW	(R2)			;IS THIS DIRECTORY RECORD EMPTY
	BEQL	70$			;BRANCH IF YES
	MOVAL	6(R2),R1		;STEP OVER FILE ID TO NAME PORTION
	MOVL	R3,R0			;MAKE A SCRATCH COPY OF NAME BLOCK ADR
	CMPL	(R0)+,(R1)+		;CHECK 1ST 2 WORDS OF RAD50 FILE NAME
	BNEQ	70$			;BRANCH IF NO MATCH
	CMPL	(R0)+,(R1)+		;LAST WORD OF RAD50 FILE NAME
					;AND THE 1 WORD RAD50 FILE TYPE
	BNEQ	70$			;BRANCH IF NO MATCH
;
; NOW CHECK THE VERSION, IF SPECIFIED VERSION WAS 0 WE'RE LOOKING FOR
; THE LARGEST VERSION WHICH OTHERWISE MATCHES, KEEP THE CURRENT LARGEST
; IN THE INPUT NAME BLOCK, THUS RETURNING THE VERSION NUMBER FOUND.
;
	TSTW	(SP)			;SEARCHING FOR HIGHEST VERSION?
	BEQL	50$			;BRANCH IF YES
	CMPW	(R0),(R1)		;NO, JUST COMPARE FOR EXACT MATCH
	BNEQ	70$			;BRANCH IF NO MATCH
	BRB	100$			;FILE FOUND, EXIT LOOP
50$:	CMPW	(R0),(R1)		;HIGHER THAN PREVIOUS HIGHEST VERSION?
	BGEQU	70$			;BRANCH IF NOT
	MOVW	(R1),(R0)		;RECORD HIGHEST VERSION FOUND
	MOVL	(R2),@FILID(AP)		;AND RECORD ITS FILE ID
70$:	ACBL	R4,#16,R2,40$		;NEXT DIRECTORY RECORD IF ANY
80$:	AOBLEQ	R7,R6,30$		;NEXT DIRECTORY BLOCK IF ANY
;
; DIRECTORY COMPLETELY SCANNED, IF LOOKING FOR HIGHEST VERSION, THEN
; POSSIBLY A FILE WAS FOUND, OTHERWISE NO MATCH.
;
	TSTL	@FILID(AP)		;IF ANY FILE ID WAS STORED
					;THEN A FILE WAS FOUND
	BNEQ	120$			;BRANCH IF FILE WAS FOUND
	MOVZWL	#SS$_NOSUCHFILE,R0	;NO SUCH FILE
90$:	RET
;
; EXACT MATCH, FILE FOUND
;
100$:	MOVL	(R2),@FILID(AP)		;RETURN THE FILE ID
120$:	MOVL	@FILID(AP),R6		;FETCH FILE ID
	CLRL	R7			;INTO R6,R7
	BRW	EXIT_FILID_FND

	.SBTTL	READ_DIR_LBN - READ NEXT DIRECTORY LBN
;++
; FUNCTIONAL DESCRIPTION:
;
;	READ THE NEXT DIRECTORY LBN FROM THE DISK OR POINT AT
;	THE CACHED COPY IF ONE IS PRESENT
;
; CALLING SEQUENCE:
;
;	BSBW	READ_DIR_LBN
;
; INPUT:
;
;	R6 = DESIRED LBN
;	DIRBUF(AP) = BUFFER ADDRESS TO READ IT INTO 
;	CHAN(AP) = CHANNEL FOR FIL$RDWRTLBN
;	DIR_BFCNT(FP) = COUNT OF BUFFERS REMAINING IN DIR LBN CACHE
;	DIR_BUF(FP) = ADDRESS OF NEXT BUFFER IN DIR LBN CACHE
;
; OUTPUTS:
;
;	R5 = ADDRESS OF DESIRED DIRECTORY LBN
;	RSB IF SUCCESSFUL
;	RET WITH STATUS IN R0 IF ERROR
;	R0, R1 DESTROYED, OTHERS PRESERVED
;
;--

READ_DIR_LBN:
	TSTL	DIR_BFCNT(FP)		;ANYTHING LEFT IN DIR LBN CACHE?
	BEQL	20$			;BRANCH IF NOT
	DECL	DIR_BFCNT(FP)		;COUNT ANOTHER BUFFER USED
	MOVL	DIR_BUF(FP),R5		;LOAD ADDRESS OF BUFFER
	MOVAL	512(R5),DIR_BUF(FP)	;AND POINT TO NEXT BUFFER IF ANY
10$:	RSB
;
; DIR LBN CACHE RAN OUT OF BLOCKS OR NEVER HAD ANY AT ALL
;
20$:	MOVL	DIRBUF(AP),R5		;ADDRESS OF BUFFER TO READ INTO
	READLBN	CHAN(AP),R6,(R5)	;READ THE DESIRED LBN
	BLBS	R0,10$			;BRANCH IF READ SUCCESSFULLY
	RET				;RETURN ERROR STATUS

	.SBTTL	RDCHKFILHDR - READ AND CHECK FILE HEADER
;++
; FUNCTIONAL DESCRIPTION:
;
;	RDCHKFILHDR READS AND VALIDATES A FILE HEADER GIVEN ITS FILE ID
; AND THE INDEX FILE HEADER AS RETURNED BY FIL$MOUNT.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$RDCHKFILHDR
;
; INPUT PARAMETERS:
;
;	CHAN(AP)		CHANNEL ON WHICH DEVICE IS ASSIGNED
;	UNUSED			UNUSED PARAMETER
;	IXFHDR(AP)		ADR OF INDEX FILE HEADER AS RETURNED BY FIL$MOUNT
;	FILHDR(AP)		ADDRESS OF 512 BYTE BUFFER FOR FILE HEADER
;	STATBLK(AP)		ADR OF 2 LONG WORD AREA TO RETURN STATISTICS BLOCK
;	FILID(AP)		ADDRESS OF 3 WORD FILE ID OF DESIRED FILE HEADER
;	RTRVPTRLEN(AP)	=	ADDRESS TO RETURN THE NUMBER OF
;				BYTES OF RETRIEVAL POINTERS STORED
;				***** OPTIONAL PARAMETER *****
;	RTRVPTRBUF(AP)	=	ADDRESS OF RETRIEVAL POINTER
;				BUFFER DESCRIPTOR.  THIS PARAMETER
;				IS PRESENT IF AND ONLY IF
;				RTRVPTRLEN IS PRESENT.
;				THE RETRIEVAL POINTERS ARE RETURNED IN
;				THE FORM 32 BIT BLOCK COUNT, 32 BIT LBN
;				A ZERO BUFFER DESCRIPTOR ADDRESS OR A
;				ZERO BUFFER ADDRESS MEANS DON'T
;				RETURN RETRIEVAL POINTER INFO
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL		SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;
;	NONE
;
;
; EQUATED SYMBOLS
;
;    OFFSETS FROM AP
;
	ARGCNT		=	0
	CHAN		=	4
	IXFHDR		=	12
	FILHDR		=	16
	STATBLK		=	20
	FILID		=	24
	RTRVPTRLEN	=	28	; OPTIONAL PARAMETER
	RTRVPTRBUF	=	32	; PRESENT IF AND ONLY IF RTRVPTRLEN IS
;
;    OFFSETS FROM FP
;
	$OFFSET	0,NEGATIVE,<-
	<HDRCNT>,-			;COUNT OF FILE HEADERS READ
	<TMPRTRVLEN>,-			;TEMP RTRV PTR BYTE COUNT
	<TMPRTRVDSC,8>-			;TEMP RTRV PTR BUFFER DESCRIPTOR
	>
;
;--

FIL$RDCHKFILHDR::
	.WORD	^M<R2,R3,R4,R5,R6>
	MNEGL	#1,-(SP)		;COUNT OF HEADER BLOCKS READ
	CLRL	-(SP)			;INIT RTRV PTR BYTE COUNT
	CLRQ	-(SP)			;ASSUME NO RTRV PTR BUFFER
	CMPL	ARGCNT(AP),#RTRVPTRBUF/4 ;RTRV PTR PARAMS PRESENT?
	BLSS	2$			;BRANCH IF NOT
	MOVL	RTRVPTRBUF(AP),R0	;RTRV BUFFER DESCRIPTOR ADDRESS
	BEQL	2$			;BRANCH IF NONE SPECIFIED
	MOVQ	(R0),TMPRTRVDSC(FP)	;MAKE COPY OF BUF DESCRIPTOR
	CLRL	@RTRVPTRLEN(AP)		;INIT RETURNED BYTE COUNT

	ASSUME	FILHDR EQ IXFHDR+4
2$:	MOVQ	IXFHDR(AP),R2		;R2 = INDEX FILE HEADER ADDRESS
					;R3 = FILE HEADER ADDRESS
	ASSUME	FILID EQ STATBLK+4
	MOVQ	STATBLK(AP),R4		;R4 = RETURN STATBLK ADDRESS
					;R5 = ADDRESS OF FILE ID
	MOVQ	(R5),-(SP)		;COPY FILE ID TO WRITABLE SCRATCH
	MOVL	SP,R5			;AND REMEMBER ITS ADDRESS
	MOVAQ	-(SP),R6		;RESERVE SCRATCH STATISTICS BLOCK
					;AND SAVE ITS ADDRESS IN R6
	CLRQ	(R4)			;INIT THE RETURN STAT BLOCK
	DECL	(R4)			;-1 LBN MEANS NOT YET STORED
5$:	MOVZWL	(R5),-(SP)		;FILE NUMBER TO LONG WORD
	BBC	#FH2$V_BIGFILNUM,FH2$W_STRUCLEV(R2),10$ ;BRANCH IF NO BIG FIL NUM
	MOVB	FID$B_NMX(R5),2(SP)	;HIGH 8 BITS OF RVN COMPLETE FILE NUMBER
10$:	MOVL	(SP)+,R0		;IF FILE ID IS ZERO,
	BNEQ	12$
	BRW	40$			;THEN READ LAST HEADER BLOCK
12$:	MOVZWL	FH1$W_VBNOFFSET(R2),R1	;RECOVER VBN OFFSET FROM INDEX FILE HEADER
	ADDL	R1,R0			;ADD VBN OFFSET TO FORM INDEX FILE VBN
	INCL	HDRCNT(FP)		;COUNT EACH HEADER READ
	READVBN	CHAN(AP),R0,(R3),(R2)	;READ THE FILE HEADER
	BLBC	R0,50$			;BRANCH IF ERROR
	BBS	#31,HDRCNT(FP),50$	;BRANCH IF JUST RE-READING MAIN HEADER
	MOVL	R5,R0			;GET FILE ID ADDRESS
	MOVL	R3,R1			;ADDRESS OF FILE HEADER
	BSBW	FIL$CHKFILHDR		;CHECK THE FILE HEADER
	MOVL	IXFHDR(AP),R2		;INDEX FILE HEADER ADDRESS
	PUSHAL	TMPRTRVDSC(FP)		;RTRV PTR BUF DESCRIPTOR
	PUSHAL	TMPRTRVLEN(FP)		;ADDRESS TO RETURN BYTE COUNT
	PUSHL	R6			;ADDRESS OF SCRATCH STAT BLOCK
	PUSHL	R3			;ADDRESS OF FILE HEADER
	CALLS	#4,W^FIL$STATBLK	;READ STATISTICS BLOCK
	MOVL	TMPRTRVLEN(FP),R1	;ANY RTRV PTR INFO TO RETURN?
	BEQL	16$			;ZERO IF NONE REQUESTED
	ADDL	R1,@RTRVPTRLEN(AP)	;ACCUMULATE RTRVPTR BYTE COUNT
	CMPL	R1,TMPRTRVDSC(FP)	;MORE SPACE NEEDED THAN WOULD FIT?
	BLEQ	14$			;BRANCH IF NOT
	MOVL	TMPRTRVDSC(FP),R1	;SAY WE USED IT ALL UP
14$:	ADDL	R1,TMPRTRVDSC+4(FP)	;GET NEW STARTING ADDRESS
	SUBL	R1,TMPRTRVDSC(FP)	;AND CALC NEW SIZE REMAINING
16$:	MCOML	(R4),R1			;SEE IF START LBN HAS BEEN SET
	BNEQ	20$			;BRANCH IF IT HAS
	MOVL	(R6),(R4)		;SET IT ONCE ONLY
20$:	ADDL	4(R6),4(R4)		;ADD IN THE SIZE FROM THIS HEADER
	MOVQ	FH2$W_EXT_FID(R3),(R5)	;GET EXTENSION FILE ID IF ANY
	BBS	#FH2$V_LEVEL2,FH2$W_STRUCLEV(R3),30$ ;GOT IT IF LEVEL2
	MOVZBL	FH1$B_MPOFFSET(R3),R0	;GET WORD OFFSET TO LEVEL1 MAP AREA
	MOVAW	(R3)[R0],R0		;ADDRESS OF MAP AREA
	MOVL	FM1$W_EX_FILNUM(R0),(R5) ;GET EXTENSION FILE NUMBER IF ANY
	CLRL	4(R5)			;ZERO RVN
30$:	BRW	5$			;READ THIS HEADER IF ANY
;
; LAST FILE HEADER READ, SEE IF MUST RE-READ THE ORIGINAL HEADER
;
40$:	TSTL	HDRCNT(FP)		;WAS -1, BUMPED ONCE PER READVBN
	BLEQ	45$			;BRANCH IF STILL HAVE MASTER FILE HEADER
	MOVQ	@FILID(AP),(R5)		;ORIGINAL FILE ID AGAIN
	BBCS	#31,HDRCNT(FP),30$	;SET SIGN BIT AND GO READ ORIGINAL HEADER
45$:	MOVZWL	#SS$_NORMAL,R0		;RETURN SUCCESS STATUS
50$:	RET

	.SBTTL	READVBN, WRITEVBN - READ/WRITE VIRTUAL BLOCK
;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES READ OR WRITE A VIRTUAL BLOCK FROM A FILE.
; VOLUME IS SPECIFIED BY THE CHANNEL TO WHICH IT IS ASSIGNED, AND THE
; FILE IS SPECIFIED BY THE ADDRESS OF ITS FILE HEADER WHICH WAS PREVIOUSLY
; READ BY A CALL TO FIL$RDFILHDR.
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$READVBN
;	CALLG	ARGLIST,FIL$WRITEVBN
;
; INPUT PARAMETERS:
;
;	CHAN(AP)	=		;CHANNEL TO WHICH VOLUME IS ASSIGNED
;	VBN(AP)		=		;DESIRED VIRTUAL BLOCK NUMBER
;	BUFADR(AP)	=		;ADDRESS OF BUFFER TO READ INTO
;	FILHDR(AP)	=		;ADDRESS OF FILE HEADER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			SUCCESSFUL RETURN
;	SS$_ENDOFFILE			SPECIFIED VBN BEYOND END OF FILE
;
; SIDE EFFECTS:
;
;	NONE
;
;
; EQUATED SYMBOLS:
;
;    OFFSET FROM AP
;
	CHAN		=	4	;CHANNEL TO WHICH VOLUME IS ASSIGNED
	VBN		=	8	;VIRTUAL BLOCK NUMBER
	BUFADR		=	12	;BUFFER ADDRESS TO READ INTO
	FILHDR		=	16	;ADDRESS OF FILE HEADER
;
;    OFFSETS FROM FP
;
	IOFUNCTION	=	-4	;SAVED I/O FUNCTION CODE
;
;--

FIL$WRITEVBN::
	.WORD	^M<R2,R3,R4,R5>
	MOVZWL	#IO$_WRITELBLK,-(SP)
	BRB	RDWRTVBN

FIL$READVBN::
	.WORD	^M<R2,R3,R4,R5>
	MOVZWL	#IO$_READLBLK,-(SP)

RDWRTVBN:
	MOVL	FILHDR(AP),R5		;BASE ADR OF FILE HEADER
	MOVZWL	FH1$W_STRUCLEV(R5),R2	;STRUCTURE LEVEL
	BSBB	INIRTRVPTRSCAN		;SET UP TO SCAN RETRIEVAL POINTERS
;
; R4 = POINTER TO FIRST RETRIEVAL POINTER,
; R5 = POINTER TO FIRST BYTE BEYOND LAST RETRIEVAL POINTER
; LOOP THROUGH RETRIEVAL POINTERS TO FIND THE ONE WHICH CONTAINS THE DESIRED VBN
;
	SUBL3	#1,VBN(AP),R3		;VBN BASE 0 TO LOOK FOR
20$:	BSBB	GETRTRVPTR		;FETCH NEXT RETRIEVAL POINTER
	CMPL	R3,R0			;IS VBN IN THIS RETRIEVAL POINTER
	BLSS	40$			;BRANCH IF YES
	SUBL	R0,R3			;PASS OVER THAT MANY VBN'S
	CMPL	R4,R5			;ANY MORE RETRIEVAL POINTERS?
	BLSSU	20$			;BRANCH IF YES
	MOVZWL	#SS$_ENDOFFILE,R0	;RETURN END OF FILE INDICATION
	RET
;
; VBN IS IN THIS RETRIEVAL POINTER, R1 = STARTING LBN
;
40$:	ROTL	#9,#1,-(SP)		;NUMBER OF BYTES TO READ/WRITE
	PUSHL	IOFUNCTION(FP)		;FUNCTION CODE
	PUSHL	BUFADR(AP)		;BUFFER TO TRANSFER TO/FROM
	ADDL3	R3,R1,-(SP)		;LBN
	PUSHL	CHAN(AP)		;CHANNEL
	CALLS	#5,W^FIL$RDWRTLBN	;TRANSFER THE BLOCK
	RET

	.SBTTL	INIRTRVPTRSCAN - INITIALIZE RETRIEVAL POINTER SCAN
;++
; FUNCTIONAL DESCRIPTION:
;
;	LOCATE START AND END OF RETRIEVAL POINTERS IN A FILE HEADER.
;
; CALLING SEQUENCE:
;
;	BSBW	INIRTRVPTRSCAN
;
; INPUT:
;
;	R2 = STRUCTURE LEVEL
;	R5 = FILE HEADER ADDRESS
;
; OUTPUT:
;
;	R4 = ADDRESS OF 1ST RETRIEVAL POINTER
;	R5 = ADDRESS OF FIRST BYTE BEYOND LAST RETREIVAL POINTER
;
;--

INIRTRVPTRSCAN:
	MOVZBL	FH1$B_MPOFFSET(R5),R0	;WORD OFFSET TO MAP AREA
	MOVAW	(R5)[R0],R4		;BASE ADR OF MAP AREA
	BBS	#FH2$V_LEVEL2,R2,20$	;BRANCH IF LEVEL2
	MOVZBL	FM1$B_INUSE(R4),R5	;WORDS OF RETRIEVAL POINTERS IN USE
	ADDL	#FM1$C_POINTERS,R4	;BEGINNING OF RETRIEVAL POINTERS
10$:	MOVAW	(R4)[R5],R5		;ADR JUST BEYOND LAST VALID RTRV PTR
	RSB
20$:	MOVZBL	FH2$B_MAP_INUSE(R5),R5	;NO. OF WORDS OF RTRV PTRS IN USE
	BRB	10$

	.SBTTL	GETRTRVPTR - CONVERT NEXT RETRIEVAL POINTER
;++
; FUNCTIONAL DESCRIPTION:
;
;	CONVERT NEXT RETRIEVAL POINTER TO NUMBER OF BLOCKS COVERED BY
;	POINTER AND STARTING LBN.
;
; CALLING SEQUENCE:
;
;	BSBW	GETRTRVPTR
;
; INPUTS:
;
;	R2 = STRUCTURE LEVEL WORD
;	R4 = ADDRESS OF NEXT RETRIEVAL POINTER
;
; OUTPUTS:
;
;	R0 = NUMBER OF BLOCKS COVERED BY THE RETRIEVAL POINTER
;	R1 = STARTING LOGICAL BLOCK NUMBER
;	R2,R3 PRESERVED
;
;--

GETRTRVPTR:
	BBS	#FH2$V_LEVEL2,R2,20$	;BRANCH IF STRUCTURE LEVEL 2
;
; STRUCTURE LEVEL 1 RETRIEVAL POINTERS - 4 BYTES EACH
;	BYTE 0 = BITS 16 - 23 OF LOGICAL BLOCK NUMBER
;	BYTE 1 = COUNT - 1 OF BLOCKS COVERED BY THIS POINTER
;	BYTES 2-3 = BITS 0:15 OF LOGICAL BLOCK NUMBER
;
	MOVZBL	1(R4),R0		;COUNT - 1
	MOVZWL	2(R4),R1		;LOW LBN BITS
	INSV	(R4)+,#16,#8,R1		;PUT HIGH LBN BITS IN
	BRB	INCRSB			;INCREMENT COUNT AND EXIT
;
; STRUCTURE LEVEL 2 RETRIEVAL POINTERS
;	BITS 14:15 = RETRIEVAL POINTER FORMAT
;
20$:	EXTZV	#FM2$V_FORMAT,#FM2$S_FORMAT,(R4),R0 ;FORMAT TO R0
	CASE	R0,<-
		PLACEMENT,-		;PLACEMENT FORMAT
		FORMAT1,-		;FORMAT 1
		FORMAT2-		;FORMAT 2
		>
;
; FORMAT 3 = 8 BYTES
;
;	BITS 0:13 = BITS 16:29 OF COUNT - 1
;	BITS 14:15 = FORMAT = 3
;	BYTES 2-3 = BITS 0:15 OF COUNT - 1
;	BYTES 4-7 = LOGICAL BLOCK NUMBER
;
FORMAT3:
	ROTL	#16,(R4)+,R0		;FORM COUNT - 1
	INSV	#0,#30,#2,R0		;ZERO HIGH 2 BITS
	MOVL	(R4)+,R1		;GET LBN
	BRB	INCRSB			;INCREMENT COUNT AND EXIT
;
; PLACEMENT CONTROL - THIS IS NOT A RETRIEVAL POINTER, RATHER IT 
;	CONSISTS OF 2 BYTES OF PLACEMENT INFORMATION.  TREAT AS IF 0 
;	LENGTH RETRIEVAL POINTER.
;	R0 = 0
;
PLACEMENT:
	MNEGL	#1,R1			;IMPOSSIBLE LBN
	ADDL	#2,R4			;BUMP THE POINTER
	CLRL	R0			;CLEAR BLOCK COUNT
	RSB
;
; FORMAT 1 = 4 BYTES
;	BITS 0:7 = COUNT - 1
;	BITS 8:13 = BITS 16:21 OF LOGICAL BLOCK NUMBER
;	BYTES 2-3 = BITS 0:15  OF LOGICAL BLOCK NUMBER
;
FORMAT1:
	MOVL	(R4)+,R0		;FETCH ENTIRE RETRIEVAL POINTER
	EXTZV	#FM2$V_HIGHLBN,#FM2$S_HIGHLBN,R0,R1 ;FETCH HIGH LBN BITS
	ASHQ	#16,R0,R0		;FORM R1 = LBN
	MOVZBL	-4(R4),R0		;REFETCH COUNT - 1
INCRSB:
	INCL	R0			;FORM COUNT
	RSB				;AND RETURN
;
; FORMAT 2 = 6 BYTES
;
;	BITS 0:13 = COUNT - 1
;	BITS 14:15 = FORMAT = 2
;	BYTES 2-5 = LBN
;
FORMAT2:
	MOVZWL	(R4)+,R0		;FETCH COUNT - 1 AND FORMAT BITS
	EXTZV	#FM2$V_COUNT2,#FM2$S_COUNT2,R0,R0 ;COUNT - 1
	MOVL	(R4)+,R1		;LBN
	BRB	INCRSB			;INCREMENT COUNT AND RETURN

	.SBTTL	STATBLK - GET FILE STATISTICS BLOCK
;++
; FUNCTIONAL DESCRIPTION:
;
;	GIVEN A FILE HEADER, RETURN THE FILE STATISTICS BLOCK
;	AND OPTIONALLY RETURN THE RETRIEVAL POINTERS
;
; CALLING SEQUENCE:
;
;	CALLG	ARGLIST,FIL$STATBLK
;
; INPUT PARAMETERS:
;
;	FILHDR(AP)	=		;ADDRESS OF THE FILE HEADER
;	STATBLK(AP)	=		;ADDRESS TO RETURN STATISTICS BLOCK
;	RTRVPTRLEN(AP)	=		;ADDRESS TO RETURN THE NUMBER OF
;					;BYTES OF RETRIEVAL POINTERS
;					;FOUND IN THE FILE HEADER(S).
;					;***** OPTIONAL PARAMETER *****
;	RTRVPTRBUF(AP)	=		;ADDRESS OF RETRIEVAL POINTER
;					;BUFFER DESCRIPTOR.  THIS PARAMETER
;					;IS PRESENT IF AND ONLY IF
;					;RTRVPTRLEN IS PRESENT.
;					;ZERO DESCRIPTOR ADDRESS OR ZERO
;					;BUFFER ADDRESS MEANS DON'T
;					;RETURN RETRIEVAL POINTER INFO
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0 = SYSTEM STATUS CODE
;	STATBLK CONTAINS 2 LONGWORDS
;		LBN OF 1ST BLOCK IF CONTIGUOUS OR ZERO IF NOT
;		SIZE OF FILE IN BLOCKS
;	RTRVPTRLEN RECEIVES THE NUMBER OF BYTES OF RETRIEVAL POINTER
;		INFORMATION THAT WOULD HAVE BEEN STORED IN THE RETRIEVAL 
;		POINTER BUFFER GIVEN A LARGE ENOUGH BUFFER.
;	THE RETRIEVAL POINTER BUFFER RECEIVES NORMALIZED RETRIEVAL
;		POINTERS IN THE FORMAT 32 BIT COUNT, 32 BIT STARTING LBN
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_NORMAL			SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;
;	NONE
;
;
; EQUATED SYMBOLS:
;
;    OFFSETS FROM AP
;
	ARGCNT		=	0	;NUMBER OF ARGUMENTS
	FILHDR		=	4	;ADDRESS OF FILE HEADER
	STATBLK		=	8	;ADDRESS TO RETURN STATISTICS BLOCK
	RTRVPTRLEN	=	12	;ADDRESS TO RETURN COUNT OF BYTES
					;STORED IN THE RETRIEVAL POINTER BUFFER
	RTRVPTRBUF	=	16	;ADDRESS OF RETRIEVAL POINTER
					;BUFFER DESCRIPTOR
;
;--

FIL$STATBLK::
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	CLRQ	R6			;ASSUME NOT DOING RETRIEVAL POINTERS
	CMPL	ARGCNT(AP),#RTRVPTRBUF/4 ;RTRV PTR PARAMS PRESENT?
	BLSS	5$			;BRANCH IF NOT
	MOVL	RTRVPTRBUF(AP),R0	;ADDRESS OF BUFFER DESCRIPTOR
	BEQL	5$			;BRANCH IF NOT SPECIFIED
	MOVQ	(R0),R6			;R6 = MAX SIZE, R7 = BUFFER ADR
	BICL	#7,R6			;EVEN MULTIPLE OF 8 BYTES
	CLRL	@RTRVPTRLEN(AP)		;INIT RETURN BYTE COUNT
5$:	MOVL	FILHDR(AP),R5		;ADDRESS OF FILE HEADER
	MOVZWL	FH1$W_STRUCLEV(R5),R2	;STRUCTURE LEVEL
	MOVZBL	FH2$L_FILECHAR(R5),R0	;FILE CHARACTERISTICS IF LEVEL 2
	BBS	#FH2$V_LEVEL2,R2,10$	;BRANCH IF STRUCTURE LEVEL 2
	MOVZBL	FH1$W_FILECHAR(R5),R0	;GET LEVEL 1 FILE CHARACTERISTICS
10$:	EXTZV	#FH1$V_CONTIG,#1,R0,-(SP) ;CONTIGUOUS BIT TO TOP OF STACK
	BSBW	INIRTRVPTRSCAN		;INIT FOR SCAN OF RETRIEVAL POINTERS
	CLRL	R3			;INIT REGISTER TO COUNT BLOCKS
	BRB	50$			;START AT BOTTOM OF LOOP IN CASE
					;FILE HAS NO RETRIEVAL POINTERS
20$:	BSBW	GETRTRVPTR		;GET THE NEXT RETRIEVAL POINTER
	TSTL	R3			;IS THIS FIRST RTRV PTR?
	BNEQ	40$			;BRANCH IF ALREADY COUNTED SOME
;
; FIRST RETRIEVAL POINTER
;
	TSTL	R0			;IGNORE EMPTY ONES
	BEQL	50$
	BLBC	(SP),40$		;BRANCH IF FILE NOT CONTIGUOUS
					;0(SP) = 0 IN THIS CASE
	MOVL	R1,(SP)			;SET LBN OF 1ST NON-ZERO RTRV PTR
40$:	ADDL	R0,R3			;ACCUMULATE COUNT OF BLOCKS
	TSTL	R6			;ANY MORE ROOM FOR RTRV PTRS?
	BEQL	45$			;BRANCH IF NO MORE BUFFER SPACE
	MOVL	R0,(R7)+		;STORE SIZE OF RETRIEVAL POINTER
	MOVL	R1,(R7)+		;AND STORE LBN
	SUBL	#8,R6			;USED 8 MORE BYTES OF SPACE
45$:	TSTL	R7			;DOES CALLER WANT RTRV PTR INFO?
	BEQL	50$			;BRANCH IF NOT, DON'T COUNT POINTERS
	ADDL	#8,@RTRVPTRLEN(AP)	;UPDATE RTRV PTR BYTE COUNT
50$:	CMPL	R4,R5			;ANY MORE RETRIEVAL POINTERS?
	BLSSU	20$			;BRANCH IF YES
	POPR	#^M<R2>			;GET SAVED STARTING LBN
	MOVQ	R2,@STATBLK(AP)		;RETURN THE STATISTICS BLOCK
	MOVZWL	#SS$_NORMAL,R0		;SUCCESSFUL COMPLETION
	RET

	.SBTTL	FIL$CHKFILHDR - CHECK FILE HEADER VALIDITY
;++
; FUNCTIONAL DESCRIPTION:
;
;	CHECK THE VALIDITY OF A FILE HEADER
;
; CALLING SEQUENCE:
;
;	BSBW	FIL$CHKFILHDR
;
; INPUT PARAMETERS:
;
;	R0 = ADDRESS OF FILE ID
;	R1 = ADDRESS OF FILE HEADER
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	RSB TO CALLER IF FILE HEADER VALID
;	RET IF NOT VALID WITH R0 = ERROR STATUS
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SS$_BADFILEHDR		FILE ID CODES DON'T MATCH
;	SS$_NOSUCHFILE		FILE IS MARKED AS DELETED
;
; SIDE EFFECTS:
;
;	NONE
;
;--

FIL$CHKFILHDR:
	CASE	FH1$W_STRUCLEV+1(R1),<-
		5$,-			;STRUCTURE LEVEL 1
		10$-			;STRUCTURE LEVEL 2
		>,TYPE=B,LIMIT=#1
	BRB	30$			;BAD FILE HEADER
;
; STRUCTURE LEVEL 1
;
5$:	MNEGL	#1,-(SP)		;NO RVN TO CHECK
	MOVL	FH1$W_FID_NUM(R1),-(SP)	;PUSH FILE ID ON STACK
	BRB	15$
;
; STRUCTURE LEVEL 2
;
10$:	MOVZWL	FH2$W_FID_RVN(R1),-(SP)	;PUSH RELATIVE VOLUME NUMBER
	MOVL	FH2$W_FID_NUM(R1),-(SP)	;PUSH FILE ID ON STACK
15$:	TSTW	(SP)			;FILE DELETED?
	BEQL	40$			;BRANCH IF YES
	CMPL	(R0)+,(SP)+		;FILE NUM AND FILE SEQ NUM AGREE?
	BNEQ	30$			;BRANCH IF NOT, BAD HEADER
	TSTL	(SP)			;CHECKING RVN?
	BLSS	20$			;BRANCH IF NOT
	CMPW	(R0),(SP)		;RELATIVE VOLUME NUMBER AND
					;FILE NUMBER EXTENSION AGREE
	BNEQ	30$			;BRANCH IF NOT
20$:	POPR	#^M<R0>			;CLEAN OFF STACK
	BRB	FIL$CHECKSUM		;GO VERIFY THE CHECKSUM
30$:	MOVZWL	#SS$_BADFILEHDR,R0	;THIS HEADER IS BAD
	RET
40$:	MOVZWL	#SS$_NOSUCHFILE,R0	;DELETED FILE
	RET

	.SBTTL	CHECKSUM - VALIDATE A CHECKSUM
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CALCULATES AND CHECKS THE FILE11 CHECKSUM FOR
; FILE HEADERS AND THE HOMEBLOCK.
;
; CALLING SEQUENCE:
;
;	BSBW	FIL$CHECKSUM		;CHECK FILE HEADER CHECKSUM
;	BSBW	FIL$CHECKSUM1		;CHECK SPECIFIED NO. OF WORDS IN R0
;
; INPUT PARAMETERS:
;
;	R0 = NO. OF WORDS TO CHECK IF ENTERING AT CHECKSUM1
;	R1 = ADDRESS OF BUFFER TO CHECK
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	RSB TO CALLER IF CHECKSUM IS OK
;	RET TO TOP LEVEL WITH ERROR CODE IN R0 IF CHECKSUM IS WRONG
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

FIL$CHECKSUM:
	MOVZWL	#FH1$W_CHECKSUM@-1,R0	;NO. OF WORDS TO CHECK
FIL$CHECKSUM1:
	CLRL	R2			;INIT THE SUM
10$:
	ADDW	(R1)+,R2		;ACCUMULATE THE SUM
	SOBGTR	R0,10$			;ONCE FOR EACH WORD
	CMPW	R2,(R1)			;CHECKSUM OK?
	BNEQ	20$			;BRANCH IF NOT
	RSB
20$:
	MOVZWL	#SS$_BADCHKSUM,R0	;ERROR STATUS IN R0
	RET


	.END
