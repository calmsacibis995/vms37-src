	.TITLE	TIMESCHDL - TIME DEPENDENT SCHEDULING
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 15-JUN-76
;
; TIME RELATED ACTIVITY
;
;	UPDATE TIME OF DAY,
;	CHECK FOR ITEM READY IN TIMER QUEUE, AND
;	PERFORM DEVICE TIMEOUT.
;	UPDATE MEASUREMENT STATISTICS IF MEASUREMENT IS ENABLED.
;
; MODIFICATION HISTORY:
;
;	V03-001	ROW0078		Ralph O. Weber		1-APR-1982
;		Enhance documentation regarding multiple use of timer queue
;		entry blocks.
;
;	V02-016 RIH0091		Richard I. Hustvedt	18-Feb-1982
;		Correct queue empty problem caused by process scan in V02-015.
;
;	V02-015	RIH0090		Richard I. Hustvedt	16-Feb-1982
;		Add scan of PCB vector for processes needing priority boost
;		to free locks held by low priority processes that are blocked
;		by high priority compute activity.
;
;	V02-014	RLR0002		Robert L. Rappaport	13-Jan-1982
;		Added a BEQL instruction following fetching of first UCB
;		from DDB in EXE$TIMEOUT to allow for the possibility of
;		a DDB with no UCB's as yet.
;
;	V02-013	JLV0094		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-012	SRB0031		Steve Beckhardt		20-Aug-1981
;		Added code to check for lock wait timeouts and initiate
;		deadlock search.
;
;	V02-011	KTA0020		Kerbey T. Altmann	03-Jun-1981
;		Add code to check certain CRB's for a DUETIME and
;		call a routine if needed.
;
;	V02-010	RLR0001		Robert L. Rappaport for R. Spitz	19-Nov-1980
;		Use common definition for Terminal UCB extension.
;
;	V02-009	KDM0023		Kathleen D. Morse	16-Sep-1980
;		Change quantum end check to be less specific, value
;		may be GEQ instead of EQL.
;
	.PAGE
	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
 
	$ACBDEF				;DEFINE ACB OFFSETS
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$ERLDEF				;DEFINE ERL OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LKBDEF				;DEFINE LKB OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PHDDEF				;DEFINE PHD OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRIDEF				;DEFINE PRIORITY INCREMENTS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RSNDEF				;DEFINE RESOURCE WAIT NUMBERS
	$STATEDEF			;DEFINE SCHEDULER STATE VALUES
	$TQEDEF				;DEFINE TQE OFFSETS
	$UCBDEF				;DEFINE UCB OFFSETS
	$TTYDEFS			; TTY UCB extension (must FOLLOW $UCBDEF)
	$TTYDEF				;DEFINE TTY SYMBOLS
	.PAGE
	.SBTTL	HARDWARE CLOCK INTERRUPTS
;+
; EXE$HWCLKINT - HARDWARE CLOCK INTERRUPT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN THE CLOCK COUNT REGISTER
; OVERFLOWS. THE CURRENT ABSOLUTE TIME IS UPDATED, THE ACCOUNTING INTEGRAL
; OF THE CURRENT PROCESS IS INCREMENTED, AND THE QUANTUM OF THE CURRENT
; PROCESS IS INCREMENTED. IF THE PROCESS QUANTUM TRANSISTS TO ZERO OR THE
; FIRST ENTRY IN THE TIMER QUEUE CAN BE REMOVED, THEN A SOFTWARE INTERRUPT
; IS REQUESTED ON THE TIMER LEVEL. THE CLOCK INTERRUPT IS THEN DISMISSED.
;
;	THE CLOCK IS CURRENTLY SET TO INTERRUPT AT 10MS INTERVALS.
;-
 
	.PSECT	A$EXENONPAGED,LONG
EXE$HWCLKINT::				;HARDWARE CLOCK INTERRUPT
	PUSHL	R0			;SAVE REGISTER R0
	MTPR	#^X800000C1,#PR$_ICCS	;CLEAR INTERRUPT + ERROR AND RE-ENABLE
10$:	ADDL	#100000,W^EXE$GQ_SYSTIME ;UPDATE SYSTEM ABSOLUTE TIME
	ADWC	#0,W^EXE$GQ_SYSTIME+4	;

;
; IF MEASUREMENT IS ENABLED, UPDATE TIMER STATISTICS FIELDS.
;

	.IF NE	CA$_MEASURE

	CVTBL	11(SP),R0		;GET UPPER BYTE OF SAVED PSL
	BGEQ	20$			;BRANCH IF CM BIT NOT SET
	MOVZBL	#5,R0			;ELSE INSERT CM INDEX
20$:	BICB	#^XF8,R0		;CONVERT EXTENDED BYTE TO INDEX
	INCL	W^PMS$GL_KERNEL[R0]	;INCREMENT STATISTICS VECTOR

	.ENDC

	BBS	#PSL$V_IS,8(SP),25$	;IF SET, DON'T ADD INTERRUPT SERVICE TIME
	MOVL	W^SCH$GL_CURPCB,R0	;GET ADDRESS OF CURRENT PROCESS PCB
	MOVL	PCB$L_PHD(R0),R0	;GET ADDRESS OF PROCESS HEADER
	INCL	PHD$L_CPUTIM(R0)	;INCREMENT ACCOUNTING INTEGRAL
	INCW	PHD$W_QUANT(R0)		;INCREMENT TIME QUANTUM
	BGEQ	30$			;IF GEQ, QUANTUM RUNOUT
25$:
	MOVL	W^EXE$GL_TQFL,R0	;GET ADDRESS OF FIRST ENTRY IN TIME QUEUE
	CMPL	TQE$Q_TIME+4(R0),W^EXE$GQ_SYSTIME+4 ;COMPARE HIGH ORDER PARTS OF TIME
	BLSSU	30$			;IF LSSU ENTRY DUE
	BGTRU	40$			;IF GTRU ENTRY NOT DUE
	CMPL	TQE$Q_TIME(R0),W^EXE$GQ_SYSTIME ;COMPARE LOW ORDER PARTS OF TIME
	BGTRU	40$			;IF GTRU ENTRY NOT DUE
30$:	SOFTINT	#IPL$_TIMER		;REQUEST SOFTWARE INTERRUPT ON TIMER LEVEL
40$:	POPL	R0			;RESTORE R0
	REI				;
	.PAGE
	.SBTTL	SOFTWARE TIMER INTERRUPTS
;+
; EXE$SWTIMINT - SOFTWARE TIMER INTERRUPTS
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A SOFTWARE INTERRUPT IS
; REQUESTED ON THE TIMER LEVEL. TIMER INTERRUPTS ARE REQUESTED WHEN THE
; CURRENT PROCESS HAS EXCEEDED ITS CPU TIME QUANTUM OR THE FIRST ENTRY IN
; THE TIMER QUEUE IS DUE.
;-
 
	.ALIGN	LONG
EXE$SWTIMINT::				;SOFTWARE TIMER INTERRUPTS
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE REGISTERS R0 THRU R5
	MOVL	W^SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	;GET ADDRESS OF PROCESS HEADER
	TSTW	PHD$W_QUANT(R5)		;QUANTUM END?
	BLSS	CHKTMQ			;IF LSS NO
	BSBW	SCH$QEND		;CALL SCHEDULER TO RESET QUANTUM
CHKTMQ:	MOVL	W^EXE$GL_TQFL,R5	;GET ADDRESS OF FIRST ENTRY IN TIME QUEUE
	SETIPL	#IPL$_HWCLK		;RAISE IPL TO HARDWARE CLOCK LEVEL
	CMPL	TQE$Q_TIME+4(R5),W^EXE$GQ_SYSTIME+4 ;COMPARE HIGH ORDER PARTS OF TIME
	BLSSU	20$			;IF LSSU ENTRY IS DUE
	BGTRU	10$			;IF GTRU ENTRY IS NOT DUE
	CMPL	TQE$Q_TIME(R5),W^EXE$GQ_SYSTIME ;COMPARE LOW ORDER PARTS OF TIME
	BLEQU	20$			;IF LEQU ENTRY IS DUE
10$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS R0 THRU R5
	REI				;
 
;
; REMOVE DUE ENTRY FROM TIMER QUEUE
;
 
20$:	REMQUE	(R5),R5			;REMOVE FIRST ENTRY FROM TIME QUEUE
	SETIPL	#IPL$_TIMER		;LOWER IPL TO SOFTWARE TIMER LEVEL
	EXTZV	#0,#2,TQE$B_RQTYPE(R5),R0 ;GET REQUEST TYPE
	CASE	R0,<TIMER,SYSUB,WAKEUP>	;DISPATCH TO PROCESSING ROUTINE
	BUG_CHECK INVTQEFMT		;INVALID TIME QUEUE ENTRY FORMAT
	BRB	CHKTMQ			;
 
;
; PROCESS SYSTEM SUBROUTINE
;
; **** WARNING ****
;
; Upon return from the system subroutine call, this routine expects R5 to 
; contain the address of a valid timer queue entery.  The TQE$V_REPEAT bit 
; of that TQE will be tested, and if it is set, the TQE will be reentered in 
; the timer queue.  Therefore, the call system subroutine CANNOT use the TQE, 
; pointed to by R5 at entry, for some other purpose and return here without 
; placing the address of a valid TQE in R5.
;
; To this end, the executive system table contains a global symbol, 
; EXE$AL_TQENOREPT, which repersents the address of a always valid always 
; non-repeating timer queue entry.  Timer system subroutines wishing to use 
; the TQE which caused them to be called for purposes other than continued 
; use of the timer queue may load the address represented by EXE$AL_TQENOREPT 
; into R5 before returing to this routine.  This prevents duplicate use of 
; the TQE block which resulted in the system subroutine being called.
;
; For example, a system subroutine which decides to discontinue its timed 
; operations and deallocate the TQE would execute at least the following 
; instructions:
;	...
;	MOVL	R5, R0			;NB: this uses the TQE 
;	JSB	G^COM$DRVDEALMEM	;    as an IPL 6 fork block.
;	...
;	MOVAL	G^EXE$AL_TQENOREPT, R5	;Setup no repeat TQE.
;	RSB

SYSUB:	MOVQ	TQE$L_FR3(R5),R3	;LOAD SUBROUTINE CONTEXT
	JSB	@TQE$L_FPC(R5)		;CALL SYSTEM SUBROUTINE
	BBC	#TQE$V_REPEAT,TQE$B_RQTYPE(R5),CHKTMQ ;IF CLR, NOT REPEATABLE
	BRB	REPTIM			;INSERT REPEAT REQUEST IN TIME QUEUE
 
;
; PROCESS TIMER
;
 
	.ENABL	LSB
TIMER:	MOVL	TQE$L_PID(R5),R1	;GET TARGET PROCESS ID
	MOVZBL	#PRI$_TIMER,R2		;SET PRIORITY INCREMENT CLASS
	MOVZBL	TQE$B_EFN(R5),R3	;GET EVENT FLAG NUMBER
	BSBW	SCH$POSTEF		;POST EVENT FLAG
	BLBC	R0,30$			;IF LBC PROCESS NO LONGER IN SYSTEM
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	INCW	JIB$W_TQCNT(R0)		;UPDATE AVAILABLE TIME QUEUE ENTRIES
	BBC	#ACB$V_QUOTA,TQE$B_RMOD(R5),20$ ;IF CLR, NO AST SPECIFIED
	MOVB	TQE$B_RMOD(R5),TQE$B_RQTYPE(R5) ;SET AST ACCESS MODE
	MOVZBL	#PRI$_TIMER,R2		;SET PRIORITY INCREMENT CLASS
	BSBW	SCH$QAST		;QUEUE AST FOR PROCESS
	BRB	40$			;
10$:	MOVZWL	TQE$L_RQPID(R5),R4	;GET REQUESTING PROCESS INDEX
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	;GET PROCESS PCB ADDRESS
	CMPL	PCB$L_PID(R4),TQE$L_RQPID(R5) ;PROCESS ID MATCH?
	BNEQ	30$			;IF NEQ NO
	INCW	PCB$W_ASTCNT(R4)	;UPDATE AVAILABLE AST QUEUE ENTRIES
	BRB	30$			;
20$:	MOVZBL	#RSN$_ASTWAIT,R0	;SET AST WAIT RESOURCE NUMBER
	BSBW	SCH$RAVAIL		;DECLARE RESOURCE AVAILABLE
30$:	MOVL	R5,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	BSBW	EXE$DEANONPAGED		;DEALLOCATE TIME QUEUE ENTRY
	BRB	40$			;
 
;
; PROCESS WAKE UP
;
 
WAKEUP:	MOVL	TQE$L_PID(R5),R1	;GET TARGET PROCESS ID
	BSBW	SCH$WAKE		;WAKE PROCESS
	BLBC	R0,10$			;IF LBC PROCESS NOT IN SYSTEM
	BBC	#TQE$V_REPEAT,TQE$B_RQTYPE(R5),10$ ;IF CLR, THEN NOT REPEATABLE
REPTIM:	MOVQ	TQE$Q_DELTA(R5),R0	;GET DELTA REPEAT TIME
	ADDL	TQE$Q_TIME(R5),R0	;ADD LOW ORDER PARTS OF TIME
	ADWC	TQE$Q_TIME+4(R5),R1	;ADD HIGH ORDER PARTS OF TIME
	BSBW	EXE$INSTIMQ		;INSERT ENTRY IN TIME QUEUE
40$:	BRW	CHKTMQ			;
	.DSABL	LSB
	.PAGE
	.SBTTL	SEARCH FOR TIME OUTS
;+
; EXE$TIMEOUT - SEARCH FOR TIME OUTS
;
; THIS ROUTINE IS ENTERED ONCE A SECOND TO PERFORM VARIOUS FUNCTIONS THAT
; NEED TO BE PERFORMED ONCE A SECOND.  THESE INCLUDE:
;
;	1)  SCAN THE DEVICE DATABASE FOR DEVICES THAT MAY HAVE TIMED OUT
;	2)  SCAN FOR CRB'S  THAT MAY HAVE TIMED OUT
;	3)  SCAN FOR WAITING LOCKS THAT MAY HAVE TIMED OUT (INITIATE
;	    DEADLOCK SEARCH)
;	4)  WAKE THE SWAPPER, IF NECESSARY
;	5)  WAKE THE ERROR LOG PROCESS, IF NECESSARY
;	6)  SCAN FOR MEMORY CRD ERRORS AND REENABLE MEMORY INTERRUPTS
;	7)  UPDATE THE SYSTEM ABSOLUTE TIME IN SECONDS
;-
 
EXE$TIMEOUT::				;SEARCH FOR TIME OUTS
	PUSHL	R6			;SAVE A REGISTER
	PUSHL	R5			;SAVE ANOTHER
	MOVL	DDB$L_LINK(R3),R6	;GET ADDRESS OF FIRST DDB
	BSBW	SCH$SWPWAKE		;WAKE SWAPPER IF NECESSARY
	INCL	W^EXE$GL_ABSTIM		;UPDATE ABSOLUTE TIME IN SECONDS
	BBC	#ERL$V_TIMER,W^ERL$GB_BUFFLAG,10$ ;IF CLR, TIMER NOT ACTIVE
	BSBW	ERL$WAKE		;WAKE ERROR LOG FORMAT PROCESS
10$:	BSBW	ECC$REENABLE		;WAKE CRD INTERRUPT REENABLE AND SCAN

;
; SCAN FOR DEVICE TIMEOUTS
;

20$:	MOVL	DDB$L_UCB(R6),R5	;GET ADDRESS OF FIRST UCB
	BEQL	60$			;EQL MEANS NO UCB'S AS YET ON THIS DDB
	BBS	#DEV$V_MBX,UCB$L_DEVCHAR(R5),60$ ;IF SET, DEVICE IS MAILBOX
30$:	BBS	#UCB$V_TIM,UCB$W_STS(R5),70$ ;IF SET, TIME OUT ENABLED
40$:	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),50$ ;IF CLR, DEVICE NOT TERMINAL
	BBS	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),90$ ;IF SET, READ TIMEOUT ENABLED
50$:	MOVL	UCB$L_LINK(R5),R5	;GET ADDRESS OF NEXT UCB
	BNEQ	30$			;IF NEQ MORE TO SCAN
60$:	MOVL	DDB$L_LINK(R6),R6	;GET ADDRESS OF NEXT DDB
	BNEQ	20$			;IF NEQ MORE TO SCAN

;
; FINISHED DEVICE SCAN, NOW CHECK THE LIST OF CRB'S
;

	MOVAL	W^IOC$GL_CRBTMOUT,R6	;PICK UP LIST HEAD
65$:	MOVL	(R6),R6			;ANY MORE TO SCAN?
	BEQL	CHECK_LOCKS		;NO, DONE
	SETIPL	#IPL$_POWER		;SET TO POWERFAIL
	CMPL	CRB$L_DUETIME-CRB$L_TIMELINK(R6),-
		W^EXE$GL_ABSTIM		;YES, IS THIS ONE DUE?
	BGTRU	66$			;NO, SCAN AGAIN
	MOVAL	-CRB$L_TIMELINK(R6),R3	;YES, PICK UP POINTER TO CRB
	MNEGL	#1, CRB$L_DUETIME(R3)	;SET FOR NO MORE TIMEOUTS
	JSB	@CRB$L_TOUTROUT(R3)	;CALL THE TIMEOUT ROUTINE
66$:	SETIPL	#IPL$_TIMER		;RESET THE IPL
	BRB	65$			;CONTINUE SCAN


;
; DEVICE HAS ENABLED TIME OUT - SEE IF IT HAS TIMED OUT
;

70$:	CMPL	UCB$L_DUETIM(R5),W^EXE$GL_ABSTIM ;POSSIBLE TIME OUT?
	BGTRU	40$			;IF GTRU NO
	SETIPL	#IPL$_POWER		;RAISE TO POWERFAIL IPL
	BBC	#UCB$V_TIM,UCB$W_STS(R5),80$ ;IF CLR, THEN TIME OUT NOT ENABLED
	CMPL	UCB$L_DUETIM(R5),W^EXE$GL_ABSTIM ;DEVICE TIME OUT?
	BGTRU	80$			;IF GTRU NO
	BICW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;DISABLE INTERRUPT AND TIMEOUT
	BISW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;SET DEVICE TIMED OUT
	SETIPL	UCB$B_DIPL(R5)		;LOWER TO DEVICE IPL
	MOVQ	UCB$L_FR3(R5),R3	;RETRIEVE SAVED R3 AND R4
	MOVL	UCB$L_FPC(R5),R2	;GET SAVED PC
	CVTWL	-(R2),-(SP)		;GET OFFSET TO EXCEPTION ROUTINE
	ADDL	(SP)+,R2		;CALCULATE ADDRESS OF EXCEPTION ROUTINE
	JSB	(R2)			;CALL EXCEPTION ROUTINE
80$:	SETIPL	#IPL$_TIMER		;LOWER IPL TO THAT OF TIMER
	BRB	40$			;
 
;
; TERMINAL READ TIMED IN PROGRESS
;
 
90$:	CMPL	UCB$L_TT_RDUE(R5),W^EXE$GL_ABSTIM ;TIME OUT POSSIBLE?
	BGTRU	50$			;IF GTRU THEN NO
	SETIPL	#IPL$_POWER		;RAISE TO DEVICE IPL
	BBC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),100$ ;IF CLR, TIMEOUT NOT ENABLED
	CMPL	UCB$L_TT_RDUE(R5),W^EXE$GL_ABSTIM ;TIMED OUT?
	BGTRU	100$			;IF GTRU THEN NO
	SETIPL	UCB$B_DIPL(R5)		; SET IPL TO DEVICE INTERRUPT LEVEL
	JSB	@UCB$L_TT_RTIMOU(R5)	;GO OFF TO THE TERMINAL SERVICE
100$:	SETIPL	#IPL$_TIMER		;LOWER IPL TO THAT OF TIMER
	BRW	50$			;


;
; SCAN FOR WAITING LOCKS THAT MAY HAVE TIMED OUT.  INITIATE A DEADLOCK
; SEARCH IF ONE IS FOUND.  NOTE THAT WE DON'T LOOP HERE.  I.E. WE
; WILL DO AT MOST ONE SEARCH PER SECOND.
;

CHECK_LOCKS:
	MOVAL	W^LCK$GL_TIMOUTQ,R5	;GET ADDRESS OF LIST HEAD
10$:	MOVL	(R5),R6			;GET FIRST ENTRY ON LIST
	CMPL	R5,R6			;IS LIST EMPTY?
	BEQL	20$			;YES
	CMPL	LKB$L_DUETIME(R6),-	;NO, HAS THIS ONE TIMED OUT?
		W^EXE$GL_ABSTIM
	BGTRU	20$			;NO, ALSO NO NEED TO LOOK FURTHER
					;AS LIST IS ORDERED
	BSBW	LCK$SEARCHDLCK		;SEARCH FOR DEADLOCK
					;FALL THROUGH HERE (BUT WE COULD
					;LOOP TO 10$)
20$:
;
; SCAN PCB VECTOR FOR PROCESSES NEEDING PRIORITY BOOST
;
SCAN_PROC:
	MOVZWL	W^SGN$GW_PIXSCAN,R5	;GET NUMBER OF PROCESSES TO SCAN
	BEQL	100$			;NONE, DO NOTHING
	MOVZWL	W^EXE$GW_SCANPIX,R6	;GET PIX TO CHECK
10$:	MOVL	@W^SCH$GL_PCBVEC[R6],R4	;FETCH PCB ADDRESS FOR PIX
	CMPW	R6,PCB$L_PID(R4)	;IS THIS AN ACTIVE PCB?
	BNEQ	20$			;NO, SKIP IT.
	BISW3	#1,PCB$W_STATE(R4),R0	;GET STATE u 1
	CMPW	#<SCH$C_COM!1>,R0	;IS STATE COM OR COMO?
	BNEQ	20$			;BR IF NOT
	MOVL	W^SCH$GL_COMQS,R0	;GET SUMMARY LONGWORD
	EXTZV	#0,#5,W^SCH$GB_PRI,R1	;GET CURRENT PRIORITY
	BBSS	R1,R0,15$		;SET BIT FOR CURRENT PROCESS
15$:	FFS	#16,#15,R0,R0 		;GET HIGHEST BACKGROUND PRIORITY
	CMPB	R0,PCB$B_PRI(R4)	;IS PROCESS ALREADY HIGHER PRIORITY?
	BGEQ	20$			;BR IF SO
	BSBW	SCH$CHSEP		;SET TEMPORARY PRIORITY BOOST
20$:	AOBLEQ	W^SCH$GL_MAXPIX,R6,30$	;NEXT PROCESS INDEX
	MOVL	#2,R6			;SET TO START PAST SWAPPER AND NULL
30$:	SOBGTR	R5,10$			;SCAN FOR NUMBER OF PROCESSES REQUESTED
	MOVW	R6,W^EXE$GW_SCANPIX	;SAVE NEW VALUE
100$:					;


;
; ALL DONE - RETURN
;

TIMEOUT_DONE:
	MOVQ	(SP)+,R5		;RESTORE REGISTERS
	RSB				;RETURN
 
	.END
