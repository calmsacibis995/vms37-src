	.TITLE CONSOLIO - CONSOLE TERMINAL I/O ROUTINES
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 12-AUG-76
;
; CONSOLE I/O ROUTINES
;
; Modified by:
;	V02-004	TCM0002		Trudy C. Matthews	10-Aug-1981
;		Remember to strip parity bit when checking for XON/XOFF.
;
;
;	V02-003	TCM0001		Trudy C. Matthews	14-May-1981
;		Added XON/XOFF recognition during terminal I/O.
;
; MACRO LIBRARY CALLS
;
 
	$PRDEF				;DEFINE PROCESSOR REGISTERS
 
;
; LOCAL SYMBOLS
;
; CHARACTER DEFINITIONS
;
 
BLANK=32				;BLANK
CR=13					;CARRIAGE RETURN
LF=10					;LINE FEED
SEVEN=55				;DIGIT 7
ZERO=48					;DIGIT 0
	CONTROL_S = 19
	CONTROL_Q = 17
 
;
; TERMINAL REGISTER DEFINITIONS
;
 
RCSR=-4					;OFFSET RECEIVER CSR
RDBR=-2					;OFFSET RECEIVER DBR
TCSR=0					;OFFSET TRANSMITTER CSR
TDBR=2					;OFFSET TRANSMITTER DBR
 
;
; LOCAL DATA
;
; HEX CONVERSION TABLE
;
 
	.PSECT	$AEXENONPAGED
EXE$AB_HEXTAB::				;HEXDECIMAL CONVERSION TABLE
	.ASCII	/0/			;0 DIGIT
	.ASCII	/1/			;1 DIGIT
	.ASCII	/2/			;2 DIGIT
	.ASCII	/3/			;3 DIGIT
	.ASCII	/4/			;4 DIGIT
	.ASCII	/5/			;5 DIGIT
	.ASCII	/6/			;6 DIGIT
	.ASCII	/7/			;7 DIGIT
	.ASCII	/8/			;8 DIGIT
	.ASCII	/9/			;9 DIGIT
	.ASCII	/A/			;10 DIGIT
	.ASCII	/B/			;11 DIGIT
	.ASCII	/C/			;12 DIGIT
	.ASCII	/D/			;13 DIGIT
	.ASCII	/E/			;14 DIGIT
	.ASCII	/F/			;15 DIGIT
	.PAGE
	.SBTTL	CONVERT LONGWORD TO HEX AND OUTPUT DIGITS
;+
; EXE$OUTHEX - CONVERT LONGWORD TO HEX AND OUTPUT DIGITS
;
; THIS ROUTINE IS CALLED VIA A JSB TO CONVERT A LONGWORD TO HEX AND
; OUTPUT THE RESULTANT DIGITS TO A SPECIFIED DEVICE IN NONINTERRUPT
; MODE.
;
; INPUTS:
;
;	R1 = VALUE TO BE CONVERTED.
;	R11 = OUTPUT DEVICE CSR ADDRESS.
;
; OUTPUTS:
;
;	THE SPECIFED VALUE IS CONVERTED TO HEX AND OUTPUT.
;-
	.PSECT	Z$INIT__BUGC		;
 
EXE$OUTHEX::				;CONVERT AND OUTPUT HEX LONGWORD
	MOVL	#28,R2			;SET POSITION OF FIRST FOUR BIT FIELD
10$:	EXTZV	R2,#4,R1,R0		;GET NEXT FOUR BITS OF VALUE
	MOVZBL	@#EXE$AB_HEXTAB[R0],R0	;GET ASCII CHARACTER
	BSBB	EXE$OUTCHAR		;OUTPUT DIGIT
	ACBB	#0,#-4,R2,10$		;ANY MORE DIGITS TO CONVERT?
	RSB				;
	.PAGE
	.SBTTL	OUTPUT BLANK CHARACTER
;+
; EXE$OUTBLANK - OUTPUT BLANK CHARACTER
;
; THIS ROUTINE IS CALLED VIA A JSB TO OUTPUT A BLANK CHARACTER TO A
; SPECIFIED DEVICE.
;
; INPUTS:
;
;	R11 = OUTPUT DEVICE CSR ADDRESS.
;
; OUTPUTS:
;
;	BLANK CHARACTER IS OUTPUT TO SPECIFIED DEVICE.
;-
 
EXE$OUTBLANK::				;OUTPUT BLANK CHARACTER
	MOVZBL	#BLANK,R0		;SET BLANK CHARACTER
	BRB	EXE$OUTCHAR		;
	.PAGE
	.SBTTL	OUTPUT CHARACTER
;+
; EXE$OUTCHAR - OUTPUT CHARACTER
;
; THIS ROUTINE IS CALLED VIA A JSB TO OUTPUT A CHARACTER TO A SPECIFIED
; DEVICE.
;
; INPUTS:
;
;	R0 = CHARACTER TO OUTPUT.
;	R11 = OUTPUT DEVICE CSR ADDRESS (ZERO IMPLIES CONSOLE TERMINAL).
;
; OUTPUTS:
;
;	CHARACTER IS OUTPUT TO THE SPECIFIED DEVICE. IF THE CHARACTER
;	IS A CARRIAGE RETURN AND THE OUTPUT DEVICE IS THE CONSOLE TERMINAL,
;	THEN A SUFFICIENT NUMBER OF FILL CHARACTERS ARE ALSO OUTPUT.
;-
 
EXE$OUTCHAR::				;OUTPUT CHARACTER
	PUSHL	R1			; GET A WORKING REGISTER
	TSTL	R11			;CONSOLE TERMINAL?
	BNEQ	20$			;IF NEQ NO
	MFPR	#PR$_RXCS,R1		; READ RECEIVE CONTROL REGISTER
	BBS	#7,R1,80$		; BRANCH IF RECEIVED A CHARACTER
10$:
	MFPR	#PR$_TXCS,R1		; READ TRANSMIT CONTROL REGISTER
	BBC	#7,R1,10$		; LOOP UNTIL READY
	BEQL	10$			;IF EQL NO
	MTPR	R0,#PR$_TXDB		;OUTPUT CHARACTER
	BRB	30$			;
20$:	BITW	#^X080,TCSR(R11)	;DEVICE READY?
	BEQL	20$			;IF EQL NO
	MOVB	R0,TDBR(R11)		;OUTPUT CHARACTER
30$:	CMPB	#CR,R0			;CARRIAGE RETURN?
	BNEQ	60$			;IF NEQ NO
	TSTL	R11			;CONSOLE TERMINAL?
	BNEQ	60$			;IF NEQ NO
40$:	CLRL	R0			;SET FILL CHARACTER
	PUSHL	#2			;SET FILL COUNT
50$:	BSBB	EXE$OUTCHAR		;OUTPUT A FILL CHARACTER
	SOBGTR	(SP),50$		;ANY MORE FILLS TO OUTPUT?
	TSTL	(SP)+			;CLEAN STACK
60$:	POPL	R1			; RESTORE WORKING REGISTER
	RSB
;
; Received an input character while output was taking place.  Check to see
; if it was an XOFF (Control-S) character.
;
80$:
	MFPR	#PR$_RXDB,R1		; GET THE CHARACTER
	CMPZV	#0,#7,R1,#CONTROL_S	; IS IT A CONTROL-S?
	BNEQ	10$			; IF NOT, BRANCH TO OUTPUT
;
; Received an XOFF (Control-S) character.  Wait until receiving an XON
; before continuing.  Throw away any input characters that arrive before
; the XON (Control-Q).
;
90$:
	MFPR	#PR$_RXCS,R1		; HAVE WE RECEIVED A CHARACTER?
	BBC	#7,R1,90$		; NO, LOOP UNTIL WE HAVE
	MFPR	#PR$_RXDB,R1		; GET THE INPUT CHARACTER
	CMPZV	#0,#7,R1,#CONTROL_Q	; IS IT A CONTROL-Q?
	BNEQ	90$			; NO, GO WAIT FOR ANOTHER CHARACTER
	BRB	10$			; GOT IT! NOW CONTINUE OUTPUT
	.PAGE
	.SBTTL	OUTPUT CARRIAGE RETURN/LINE FEED PAIR
;+
; EXE$OUTCRLF - OUTPUT CARRIAGE RETURN/LINE FEED PAIR
;
; THIS ROUTINE IS CALLED TO OUTPUT A CARRIAGE RETURN/LINE FEED PAIR TO A
; SPECIFIED DEVICE.
;
; INPUTS:
;
;	R11 = OUTPUT DEVICE CSR ADDRESS.
;
; OUTPUTS:
;
;	A CARRIAGE RETURN FOLLOWED BY A LINE FEED IS OUTPUT TO THE SPECIFIED
;	DEVICE.
;-
 
EXE$OUTCRLF::				;OUTPUT CARRIAGE RETURN/LINE FEED PAIR
	MOVZBL	#CR,R0			;SET CARRIAGE RETURN CHARACTER
	BSBB	EXE$OUTCHAR		;OUTPUT CARRIAGE RETURN
	MOVZBL	#LF,R0			;SET LINE FEED CHARACTER
	BRB	EXE$OUTCHAR		;OUTPUT LINE FEED CHARACTER
	.PAGE
	.SBTTL	OUTPUT COUNTED AND ZERO TERMINATED STRINGS
;+
; EXE$OUTCSTRING - OUTPUT COUNTED STRING
;
; THIS ROUTINE IS CALLED VIA A JSB TO OUTPUT A STRING WHOSE FIRST CHARACTER
; IS THE NUMBER OF CHARACTERS TO BE OUTPUT.
;
; INPUTS:
;
;	R1 = ADDRESS OF COUNTED STRING.
;	R11 = OUTPUT DEVICE CSR ADDRESS.
;
; OUTPUTS:
;
;	THE NUMBER OF CHARACTERS SPECIFIED BY THE FIRST BYTE OF THE STRING
;	ARE OUTPUT TO THE SPECIFIED DEVICE. OUTPUT IS ALSO TERMINATED IF
;	A ZERO BYTE IS ENCOUNTERED BEFORE THE COUNT IS EXHAUSTED.
;-
 
	.ENABL	LSB
EXE$OUTCSTRING::			;OUTPUT COUNTED STRING
	MOVZBL	(R1)+,R2		;SET COUNT OF CHARACTERS TO OUTPUT
	BRB	10$			;
 
;+
; EZE$OUTZSTRING - OUTPUT ZERO TERMINATED STRING
;
; THIS ROUTINE IS CALLED VIA A JSB TO OUTPUT A STRING THAT IS TERMINATED BY
; A ZERO BYTE.
;
; INPUTS:
;
;	R1 = ADDRESS OF ZERO TERMINATED STRING.
;	R11 = OUTPUT DEVICE CSR ADDRESS.
;
; OUTPUTS:
;
;	CHARACTERS FROM THE SPECIFIED STRING ARE OUTPUT UNTIL A ZERO BYTE
;	IS ENCOUNTERED.
;-
 
EXE$OUTZSTRING::			;OUTPUT ZERO TERMINATED STRING
	MOVZBL	#255,R2			;SET MAXIMUM ALLOWABLE STRING LENGTH
10$:	MOVZBL	(R1)+,R0		;GET NEXT CHARACTER FROM INPUT STRING
	BEQL	20$			;IF EQL END OF STRING
	BSBB	EXE$OUTCHAR		;OUTPUT CHARACTER
	SOBGTR	R2,10$			;ANY MORE CHARACTERS TO OUTPUT?
20$:	RSB				;
	.DSABL	LSB
 
	.END
