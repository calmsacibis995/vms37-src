	.TITLE	DISMOUNT - DISMOUNT A MOUNTED MASS STORAGE VOLUME
	.IDENT	'V03-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; FACILITY:  
;
;	MASS STORAGE DEVICE MANAGEMENT SUBROUTINES
;
; ABSTRACT:
;
;	THIS ROUTINE DISMOUNTS THE INDICATED DEVICE.
;
;
; ENVIRONMENT:
;
;	VAX/VMX EXEC
;	MODE = KERNEL
;
;
; AUTHOR:  ANDREW C. GOLDSTEIN, CREATION DATE:  2-NOV-1977  14:10
;
; MODIFIED BY:
;
;	V03-002	STJ0257		Steven T. Jeffreys,	12-Apr-1982
;		- Do not mung device allocation access mode.
;		- Make code AST reentrant.  This includes the addtion
;		  of the local subroutine DO_IO.
;
;	V03-001	STJ0229		Steven T. Jeffreys,	23-Mar-1982
;		Clear the 'mount verification possible' bit in the VCB
;		so that $DISMOU will succeed even if no volume is present
;		in the drive (as in version 2).
;
;	V02-008	ACG0248		Andrew C. Goldstein,	23-Dec-1981  11:56
;		Fix logical name interlocks
;
;	V02-007	ACG0226		Andrew C. Goldstein,	24-Nov-1981  22:29
;		Issue IO$_AVAILABLE on DISMOUNT/NOUNLOAD
;
;	V0006	STJ0138		Steven T. Jeffreys,   12-Nov-1981
;		Use IOC$CVT_DEVNAM to format the device name.
;
;	V0005	ACG0062		Andrew C. Goldstein,  16-Oct-1979  13:53
;		Unload volumes mounted foreign on dismount
;
;	V0004	ACG0003		Andrew C. Goldstein,  1-Feb-1979  11:07
;	Add handling of dummy MTL entry for volume set
;
;   Andrew C. Goldstein, 12-Jul-78  20:08
;   V0003 - ADD ERROR LOG ENTRY FOR FOREIGN DISMOUNT
;
;**

;
; DEFINE SYSTEM CONTROL BLOCKS
;
	$DDBDEF				; DDB
	$DEVDEF				; DEVICE CHARACTERISTICS BITS
	$EMBETDEF			; DEFINE ERROR LOG MESSAGE CODES
	$EMBVMDEF			; DEFINE ERROR LOG BUFFER FORMAT
	$LOGDEF				; DEFINE LOGICAL NAME BLOCK
	$IODEF				; DEFINE I/O FUNCTION CODES
	$PCBDEF				; PROCESS CONTROL BLOCK
	$PHDDEF				; PROCESS HEADER
	$PRDEF				; PROCESSOR REGISTER CODES
	$PRVDEF				; PRIVILEGE BIT DEFINITIONS
	$MTLDEF				; MOUNTED VOLUME LIST ENTRY
	$SSDEF				; SYSTEM SERVICE CODES
	$UCBDEF				; UCB
	$VCBDEF				; VCB
;
; LOCAL STORAGE ALLOCATED ON STACK (ADDRESSED OFF R3)
;
NAME_LENGTH	= 32			; LENGTH OF DEVICE NAME BUFFER
CHANNEL		= 0			; CHANNEL NUMBER
DEVICE_NAME	= 4			; STRING DESCRIPTOR OF DEVICE NAME
NAME_STRING	= 12			; DEVICE NAME STRING BUFFER

LOCAL_SIZE	= 44			; TOTAL SIZE OF STACK LOCALS

	.PSECT	Y$DISMOUNT

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE DISMOUNTS THE INDICATED MOUNTED VOLUME LIST ENTRY.
;	THE MTL AND LOGICAL NAME, IF IT STILL EXISTS, ARE DELETED, AND THE
;	VOLUME SHARE COUNT IS DECREMENTED. IF THE SHARE COUNT GOES TO
;	ZERO, THE VOLUME ITSELF IS DISMOUNTED.
;
; CALLING SEQUENCE:
;	JSB IOC$DISMOUNT
;
; INPUT PARAMETERS:
;	R3 = LBC TO UNLOAD VOLUME
;	     LBS TO NOT UNLOAD
;	R4 = ADDRESS OF PROCESS PCB
;	R6 = ADDRESS OF MOUNTED VOLUME LIST ENTRY
;
; IMPLICIT INPUTS:
;	IPL  -  IPL$_ASTDEL
;
; OUTPUT PARAMETERS:
;	R0-R2,R6 SMASHED, OTHER REGISTERS PRESERVED
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL,SS$_NOIOCHAN
;
; SIDE EFFECTS:
;	VOLUME DISMOUNTED: LOGICAL NAME & MTL DEALLOCATED, VCB GONE OR SOON
;	TO GO, ACP PROCESS MAY BECOME DELETED
;
;--


IOC$DISMOUNT::
	PUSHR	#^M<R3,R5>		; SAVE REGISTERS
	MOVL	MTL$L_UCB(R6),R5	; GET UCB ADDRESS
	MOVL	MTL$L_LOGNAME(R6),R1	; GET ADDRESS OF LOGICAL NAME
	BEQL	10$			; BRANCH IF NONE
	MOVZBL	LOG$B_TABLE(R1),R3	; GET LOG NAME TABLE NUMBER
	PUSHL	R3			; SAVE TABLE NUMBER
	BSBW	LOG$LOCKW		; LOCK THE TABLE
	BSBW	LOG$DELETE		; DELETE THE LOGICAL NAME
	POPL	R3			; GET BACK TABLE NUMBER
	BSBW	LOG$UNLOCK		; AND UNLOCK THE TABLE

10$:	MOVZBL	MTL$B_STATUS(R6),-(SP)	; SAVE MTL ENTRY STATUS BYTE
	MOVL	R6,R0			; GET MTL ADDRESS IN R0
	BGEQ	20$			; BRANCH IF PROCESS SPACE ADDRESS
	BSBW	EXE$DEAPAGED		; DEALLOCATE TO SYSTEM PAGED POOL
	BRB	30$
20$:	MOVZWL	MTL$W_SIZE(R6),R1	; GET BLOCK SIZE
	MOVAL	@#CTL$GQ_ALLOCREG,R3	; AND PROCESS ALLOCATION LIST HEAD
	BSBW	EXE$DEALLOCATE		; AND DEALLOCATE TO PROCESS POOL

;
; NOW LOCK THE I/O DATABASE MUTEX AND DECREMENT THE VOLUME SHARE COUNT.
; IF IT GOES TO ZERO, MARK THE UCB FOR DISMOUNT.
;
	ASSUME	MTL$V_VOLSET EQ 0
30$:	BLBS	(SP)+,35$		; BRANCH IF MTL ENTRY WAS FOR VOLUME SET
	BSBW	SCH$IOLOCKW		; LOCK I/O DATABASE
	MOVL	UCB$L_VCB(R5),R0	; AND VCB ADDRESS
	DECW	VCB$W_MCOUNT(R0)	; DECREMENT MOUNT COUNT
	BEQL	40$			; BRANCH IF NOW IDLE
	BSBW	SCH$IOUNLOCK		; ELSE UNLOCK I/O DATABASE
35$:	SETIPL	#0
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	BRW	120$			; AND GET OUT

40$:	BBSS	#DEV$V_DMT,UCB$L_DEVCHAR(R5),50$ ; SET MARK FOR DISMOUNT
50$:	BLBC	(SP),60$		; BRANCH IF VOLUME TO BE UNLOADED
	BBCC	#UCB$V_UNLOAD,UCB$W_STS(R5),60$ ; ELSE CLEAR UNLOAD BIT
60$:	BICB2	#<1@VCB$V_MOUNTVER>,-	; CLEAR MV BIT IN THE VCB
		VCB$B_STATUS2(R0)	;
	BBCC	#UCB$V_DEADMO,UCB$W_STS(R5),70$ ; BRANCH IF NOT TO DEALLOCATE
	BBCC	#DEV$V_ALL,UCB$L_DEVCHAR(R5),70$ ; BRANCH IF NOT ALLOCATED
	DECW	UCB$W_REFC(R5)		; DROP REFERENCE COUNT AND
	CLRL	UCB$L_PID(R5)		; CLEAR PID TO DEALLOCATE
70$:	BBSC	#UCB$V_MOUNTING,UCB$W_STS(R5),80$ ; CLEAN UP STATUS BITS
80$:	BSBW	SCH$IOUNLOCK		; UNLOCK THE I/O DATABASE
	SETIPL	#0

;
; ASSIGN A CHANNEL TO THE DEVICE. IF IT IS MOUNTED FILES-11, ISSUE A DISMOUNT
; QIO. (IF IT IS MOUNTED FOREIGN, DEASSIGNING THE CHANNEL WILL COMPLETE THE
; CLEANUP).
;
	SUBL	#LOCAL_SIZE,SP		; ALLOCATE LOCAL STORAGE ON STACK
	MOVL	SP,R3
	MOVL	#NAME_LENGTH,R0		; SET NAME BUFFER LENGTH
	MOVAL	NAME_STRING(R3),R1	; SET NAME BUFFER ADDRESS
	MOVL	R1,DEVICE_NAME+4(R3)	; COPY ADDRESS TO DESCRIPTOR
	BSBW	IOC$CVT_DEVNAM		; FORMAT THE DEVICE NAME
	MOVL	R1,DEVICE_NAME(R3)	; SAVE RESULTANT STRING LENGTH
	CLRL	CHANNEL(R3)		; INIT CHANNEL NUMBER
	$ASSIGN_S CHAN=CHANNEL(R3),-	; AND ASSIGN A CHANNEL TO THE DEVICE
		  DEVNAM=DEVICE_NAME(R3)
	BLBC	R0,110$			; IF THIS FAILS, WE WILL HAVE A HUNG DEVICE

	BBS	#DEV$V_FOR,UCB$L_DEVCHAR(R5),90$ ; BRANCH IF DEVICE IS FOREIGN
	PUSHL	#<IO$_ACPCONTROL!IO$M_DMOUNT>
	PUSHL	CHANNEL(R3)		; PUSH CHANNEL NUMBER
	CALLS	#2,DO_IO		; ISSUE THE DISMOUNT QIO
100$:	$DASSGN_S  CHAN=CHANNEL(R3)	; DEASSIGN THE CHANNEL
110$:	ADDL	#LOCAL_SIZE,SP		; RESTORE STACK POINTER
120$:	POPR	#^M<R3,R5>		; RESTORE REGISTERS
	RSB
;
; FOR A DEVICE MOUNTED FOREIGN, CONSTRUCT AND SEND THE ERROR LOG MESSAGE
; SIGNALLING DISMOUNT.
;
90$:	MOVZBL	#EMB$K_VM_LENGTH,R1	; LENGTH OF ERROR LOG MESSAGE
	BSBW	ERL$ALLOCEMB		; ALLOCATE AN ERROR LOG BUFFER
	BLBC	R0,100$			; BRANCH IF FAILURE
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE ADDRESS OF BUFFER AND R3, R4, R5
	ASSUME	EMB$L_VM_ERRCNT EQ EMB$L_VM_OWNUIC+4
	ASSUME	EMB$L_VM_OPRCNT EQ EMB$L_VM_ERRCNT+4
	ASSUME	EMB$W_VM_UNIT EQ EMB$L_VM_OPRCNT+4
	ASSUME	EMB$B_VM_NAMLNG EQ EMB$W_VM_UNIT+2
	ASSUME	EMB$T_VM_NAMTXT EQ EMB$B_VM_NAMLNG+1
	ASSUME	EMB$W_VM_VOLNUM EQ EMB$T_VM_NAMTXT+15
	ASSUME	EMB$W_VM_NUMSET EQ EMB$W_VM_VOLNUM+2
	ASSUME	EMB$T_VM_LABEL EQ EMB$W_VM_NUMSET+2
	MOVW	#EMB$K_VD,EMB$W_VM_ENTRY(R2) ; MESSAGE CODE = DISMOUNT
	ADDL	#EMB$L_VM_OWNUIC,R2	; POINT TO ENTRIES TO BE FILLED IN
	MOVL	UCB$L_OWNUIC(R5),(R2)+	; VOLUME OWNER UIC
	MOVZWL	UCB$W_ERRCNT(R5),(R2)+	; VOLUME ERROR COUNT
	MOVL	UCB$L_OPCNT(R5),(R2)+	; VOLUME OPERATION COUNT
	MOVW	UCB$W_UNIT(R5),(R2)+	; UNIT NUMBER
	ADDL3	#VCB$T_VOLNAME,UCB$L_VCB(R5),-(SP) ; SAVE ADDRESS OF VOLUME LABEL
	ADDL3	UCB$L_DDB(R5),#DDB$T_NAME,R6 ; CALCULATE DEVICE NAME ADDRESS
	MOVZBL	(R6),R0			; GET LENGTH OF DEVICE NAME
	INCL	R0			; BUMP TO INCLUDE COUNT BYTE
	MOVC5	R0,(R6),#0,#16,(R2)	; COPY DEVICE NAME INTO MESSAGE
	CLRL	(R3)+			; ZERO REL VOL NUMBER AND VOLUME SET SIZE
	MOVC3	#12,@(SP)+,(R3)		; COPY VOLUME LABEL
	POPR	#^M<R2>
	BSBW	ERL$RELEASEMB		; RELEASE ERROR LOG BUFFER AND SEND
	POPR	#^M<R3,R4,R5>
;
; SEE IF THE VOLUME IS TO BE UNLOADED. IF SO, CHECK THE REFERENCE COUNT. IF THE
; VOLUME IS IDLE, ISSUE AN UNLOAD QIO. OTHERWISE, JUST REWIND IT. IF THE
; VOLUME IS NOT IDLE, IT WILL NOT BE UNLOADED (IT IS NOT POSSIBLE TO ISSUE
; THE UNLOAD QIO FROM INSIDE THE DEASSIGN CHANNEL SERVICE).
;
	MOVZWL	UCB$W_REFC(R5),R0	; GET THE VOLUME REFERENCE COUNT
	BBC	#DEV$V_ALL,UCB$L_DEVCHAR(R5),95$ ; BRANCH IF NOT ALLOCATED
	DECL	R0			; ADJUST REF COUNT FOR ALLOCATION
95$:	CMPL	R0,#2			; SEE IF THE VOLUME IS IDLE (THIS ROUTINE
	BGTRU	100$			; AND ITS CALLER EACH HAVE 1 CHANNEL)
					; BRANCH IF BUSY
	ASSUME	PHD$Q_PRIVMSK EQ 0
	CLRL	R2			; ASSUME PRIVILEGE BIT CLEAR
	BBCS	#PRV$V_PHY_IO,@PCB$L_PHD(R4),96$ ; SET PHY_IO PRIVILEGE AND TEST
	INCL	R2			; BIT WAS SET - SAVE STATE
96$:	MOVZWL	#IO$_AVAILABLE,R0	; ASSUME JUST REWIND, NO UNLOAD
	BBC	#UCB$V_UNLOAD,UCB$W_STS(R5),97$ ; BRANCH IF NO UNLOAD
	MOVZWL	#IO$_UNLOAD,R0		; SET UP FOR UNLOAD
97$:	PUSHL	R0			; PUSH I/O FUNCTION CODE
	PUSHL	CHANNEL(R3)		; PUSH CHANNEL NUMBER
	CALLS	#2,DO_IO		; ISSUE THE UNLOAD OR REWIND QIO
	INSV	R2,#PRV$V_PHY_IO,#1,@PCB$L_PHD(R4) ; RESTORE PRIVILEGE BIT
	BRW	100$
	.PAGE
	.SBTTL	DO_IO - COMMON I/O ROUTINE
;++
; DO_IO
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS AN ENVELOPE PROCDURE FOR ALL I/O DONE BY THIS
;	MODULE.  USE A SYSTEM EVENT FLAG FOR THE I/O, AND CODE THE ROUTINE
;	TO BE TOLERANT OF RANDOME EVENT FLAG SETTING AND CLEARING.
;
; INPUT:
;
;	CHAN(AP) = CHANNEL NUMBER TO USE FOR THE I/O
;	FUNC(AP) = I/O FUNCTION CODE
;
; OUTPUT:
;
;	NONE.
;
; ROUTINE VALUE:
;
;	R0	= SOME SYSTEM STATUS CODE
;--

;
; USEFUL SYMBOLS
;

CHAN = 4				; OFFSET TO CHANNEL NUMBER
FUNC = 8				; OFFSET TO I/O FUNCTION CODE
DISMOUNT_EFN = 26			; EVENT FLAG TO USE FOR I/O


DO_IO:	.WORD	^M<R2>			; COMMON I/O ROUTINE
	CLRQ	-(SP)			; CREATE IOSB ON STACK
	MOVL	SP,R2			; COPY ADDRESS OF LOCAL IOSB
	$QIOW_S	EFN=#DISMOUNT_EFN,-	; USE SYSTEM EVENT FLAG
		CHAN=CHAN(AP),-		; USE CHANNEL SUPPLIED BY CALLER
		FUNC=FUNC(AP),-		; USE FUNCTION CODE SUPPLIED BY CALLER
		IOSB=(R2)		; USE LOCAL IOSB
	BLBC	R0,69$			; BRANCH IF ERROR
;
; TEST TO SEE IF THE I/O ACTUALLY COMPLETED.  THIS MIGHT NOT BE THE CASE,
; AS SOMEONE MAY HAVE SET THE EVENT FLAG TO SIGNAL SOME OTHER EVENT.
;
10$:	TSTW	(R2)			; CHECK THE I/O STATUS FROM THE IOSB
	BNEQ	100$			; BRANCH IF NOT ZERO
	$CLREF_S  EFN=#DISMOUNT_EFN	; CLEAR THE EVENT FLAG
	TSTW	(R2)			; CHECK THE I/O STATUS FROM THE IOSB
	BNEQ	100$			; BRANCH IF NOT ZERO
	$WAITFR_S EFN=#DISMOUNT_EFN	; WAIT FOR THE EVENT FLAG TO BE SET
	BRB	10$			; TRY AGAIN ...
69$:	MOVL	R0,(R2)			; STASH THE FAILURE STATUS IN THE IOSB
100$:	$SETEF_S  EFN=#DISMOUNT_EFN	; SET THE EVENT FLAG
	MOVZWL	(R2),R0			; SET THE RETURN STATUS IN R0
	RET				; RETURN
	.END
