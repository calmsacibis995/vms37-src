	.TITLE	SYSSETIME - SYSTEM SERVICE TO SET CURRENT SYSTEM TIME
	.IDENT	'V03-002'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; LEN KAWELL 14-FEB-79
;
; MODIFICATION HISTORY:
;
;	V03-002	PHL0042		Peter H. Lipman		02-Apr-1982
;		Validate the boot control block before using the
;		SYSPARAM map to write the system image.
;
;	V03-001	DWT0034		David Thiel		30-Mar-1982
;		Avoid using event flag 0.
;
;	V02-008	MLJ41905	Martin L. Jack		31-Jan-1982
;		TQE's that were specified with an absolute time no longer are
;		adjusted during a $SETTIM.  They expire when the absolute value
;		of the new time has passed, rather than when the original
;		interval has elapsed.  This is now considered more intuitively
;		correct behavior.
;
;	V02-007	KTA0068		Kerbey T. Altmann	10-Jan-1982
;		Modify RECAL to allow up to 1 day setback in time.
;
;	V02-006	PHL0023		Peter H. Lipman		1-Nov-1981
;		Change SYS$SYSDISK to SYS$SYSDEVICE
;
;	V02-005	KTA0036		Kerbey T. Altmann	05-Oct-1981
;		Fix bug in V02-004 that caused write-locked system
;		disks to hang the bootstrap procedure.
;
;	V02-004	PHL0010		Peter H. Lipman		05-Jun-1981
;		SYS.EXE is no longer required to be contiguous.
;		Use the SYSPARAM virtual to logical map in the 
;		Boot Control Block to update the sysparam portion
;		of SYS.EXE.
;
;	V02-003	KTA0006		Kerbey T. Altmann	29-Jan-1981
;		REDO RECAL LOGIC TO ALWAYS CHECK FOR YEAR-END ROLL-OVER
;		AND ALWAYS UPDATE PR$_TODR, EXE$GL_TODR, and EXE$GQ_TODCBASE
;		ALSO, CHECK FOR INVALID PROCESS CLOCK TIME.
;
;	V02	SRB0001		STEVE BECKHARDT		12-OCT-1979
;		CHANGED SYSTEM DISK LOGICAL NAME TO SYS$SYSDISK
;
; SYSTEM SERVICE TO SET THE CURRENT SYSTEM TIME
;
; DOES ANYBODY REALLY KNOW WHAT TIME IT IS?
; DOES ANYBODY REALLY CARE?
; IF SO I CAN'T IMAGINE WHY,
; WE'VE ALL GOT TIME ENOUGH TO DIE.
;				CHICAGO 1971
;
	.PAGE
	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
 
	$BOODEF				;DEFINE BOOT CONTROL BLOCK OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$TQEDEF				;DEFINE TIMER QUEUE ENTRIES
	$VADEF				;DEFINE VIRTUAL ADDRESSES
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
TIMADR=4				;NEW TIME

;
; SYSTEM EVENT FLAG TO USE FOR I/O.
; THE CODE ASSUMES THAT THIS FLAG MAY BE SET ANOMALOUSLY
; AND ALWAYS EXITS WITH THE FLAG SET SO THAT OTHER
; MODULES MAY USE THE SAME FLAG IN A SIMILAR FASHION.
;
FLAG=30					;EVENT FLAG 30

;
; OWN STORAGE
;
	.PSECT	YEXEPAGED		;PAGED DATA AND CODE

;
; BASE TIME FOR TIME-OF-DAY PROCESSOR REGISTER (TODR). THE TODR CAN'T
; CONTAIN THE ENTIRE SYSTEM TIME, SO IT IS DEFINED TO CONTAIN A VALUE
; RELATIVE TO THE BASE TIME.  THE BASE TIME IS DEFINED AS:
;
;		01-JAN-CURRENT_YEAR 00:00:00.00
;
; TO ALLOW CONVERSION OF THE TODR VALUE TO SYSTEM TIME FORMAT,
; THE TODR AND ITS CORRESPONDING SYSTEM TIME ARE STORED IN THE SYSTEM
; IMAGE FILE (SYS$SYSTEM:SYS.EXE).  BECAUSE ALL TODR'S HAVE THE SAME
; BASE, A DISK THAT IS BOOTED ON ONE SYSTEM CAN BE TRANSPORTED TO
; ANOTHER SYSTEM AND THE TIME WILL BE SET CORRECTLY.
;
BASETIME:				;BASE TIME FOR TIME-OF-DAY REGISER
	.ASCII	/01-JAN-/		;
BASEYEAR = .-BASETIME			;(OFFSET TO YEAR)
	.ASCII	/XXXX 00:00:00.00/	;
BASETIMESZ = .-BASETIME			;BASE TIME STRING SIZE
STACKSIZE = <8+8+BASETIMESZ+3>&^C3	;STACK SIZE NEED ROUNDED TO MULT OF 4
					; (QUAD TIME + DESCR + BUFFER)
;
; TO DETERMINE WHETHER OR NOT THE PROCESSOR TIME-OF-YEAR CLOCK (PR$_TODR) HAS
; ROLLED OVER THE YEAR, WE MUST KNOW HOW LONG THE BASE YEAR WAS.  TO CALULATE
; THAT TIME, WE NEED A DEFINITION OF THE END OF THE YEAR.  USING THE ABOVE
; DEFINITION OF THE FIRST OF THE YEAR AND THE FOLLOWING END OF YEAR, WE CAN
; USE THE APPROPRIATE SYSTEM SERVICES TO CALCULATE THAT SPAN OF TIME - ALWAYS
; PROPERLY ALLOWING FOR LEAP YEARS.
;
ENDTIME:
	.ASCII	/31-DEC-XXXX 23:59:59.99/	; END OF YEAR (- 10ms)

;
; SYSTEM DISK LOGICAL NAME
;
SYSDISK:				;SYSTEM DISK LOGICAL NAME
	.ASCID	/SYS$SYSDEVICE/
	.PAGE
	.SBTTL	SET TIME
;+
; EXE$SETTIME - SET CURRENT SYSTEM TIME
;
; THIS SERVICE PROVIDES THE CAPABILITY TO RESET THE CURRENT SYSTEM TIME.
;
; INPUTS:
;
;	TIMADR(AP) = ADDRESS OF NEW TIME VALUE.  ZERO FOR ADDRESS OR
;		TIME VALUE CAUSES THE PROCESSOR'S TIME-OF-DAY CLOCK
;		TO BE USED TO RECALIBRATE THE CURRENT SYSTEM TIME.
;
;	R4 = ADDRESS OF CURRENT PROCESS PCB.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO SET SYSTEM TIME.
;
;		R0 = SS$_ACCVIO - TIME VALUE CANNOT BE READ BY CALLING
;			ACCESS MODE.
;
;		R0 = SS$_IVTIME - A NEGATIVE TIME VALUE WAS SPECIFIED,
;			OR AN INVALID PROCESSOR CLOCK VALUE WAS FOUND.
;
;		R0 = SS$_NOIOCHAN - NO I/O CHANNEL IS AVAILABLE FOR
;			USE BY THE SERVICE.
;
;		R0 = SS$_NOPRIV - THE CALLING PROCESS DOES NOT HAVE
;			OPER OR LOG_IO PRIVILEGE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION, SYSTEM TIME SET.
;
;
;	CURRENT SYSTEM TIME (EXE$GQ_SYSTIME) IS SET TO SPECIFIED
;	TIME.  PROCESSOR'S TIME-OF-DAY CLOCK IS UPDATED TO NEW TIME.
;	NEW TIME IN SYSTEM TIME FORMAT AND TIME-OF-DAY CLOCK
;	FORMAT IS WRITTEN TO SYSTEM IMAGE FILE (SYS$SYSTEM:SYS.EXE).
;-
	.ENTRY	EXE$SETIME,-		;SET CURRENT SYSTEM TIME
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;(ENTRY MASK)

	MOVZWL	S^#SS$_NOPRIV,R0	;ASSUME NO PRIVILEGE
	IFNPRIV	OPER,10$		;BR IF NO OPER PRIVILEGE
	IFNPRIV	LOG_IO,10$		;BR IF NO LOG_IO PRIVILEGE
	MOVZWL	S^#SS$_ACCVIO,R0	;ASSUME ACCESS VIOLATION
	SUBL3	#STACKSIZE,FP,SP	;GRAB SOME TEMPORARY SPACE
	MOVL	SP,R7			;HOLD POINTER TO IT
	MOVL	TIMADR(AP),R1		;GET ADDR OF NEW TIME ARG
	BEQL	RECAL			;BR IF NONE
	IFNORD	#8,(R1),10$		;CAN TIME BE READ?
	MOVZWL	#SS$_IVTIME,R0		;ASSUME INVALID TIME
	MOVQ	(R1),R10		;GET TIME - R10,R11
	BGTR	COMPUTE_TODR		;BR IF VALID TIME
	BEQL	RECAL			;BR IF ZERO - RECALIBRATE
10$:
	RET				;RETURN WITH FAILURE
	.PAGE
	.SBTTL	COMPUTE TIME-OF-DAY CLOCK VALUE
;++
;
; COMPUT_TODR - COMPUTE NEW TIME-OF-DAY CLOCK VALUE.
;
;	COMPUTE NEW TIME-OF-DAY CLOCK VALUE BY COMPUTING THE NEW
;	TIME AFTER THE BASE TIME AND SCALING TO 10 MSEC UNITS.
;
; INPUTS:
;
;	R10,R11 = NEW SYSTEM TIME.
;
; OUTPUTS:
;
;	R0 = NEW TIME-OF-DAY CLOCK VALUE.
;
;--
COMPUTE_TODR:				;COMPUTE TIME-OF-DAY CLOCK VALUE
	MOVAB	BASETIME,R2		;GRAB CORRECT TIME STRING
	BSBB	CVT_TIME		;CONVERT THE TIME
	MOVQ	R10,R0			;GET NEW TIME
	SUBL	(R6)+,R0		;COMPUTE YEAR'S DELTA
	SBWC	(R6),R1			;IN 100 NANOSECOND UNITS
	EDIV	W^SCALE,R0,R0,R1	;SCALE TO 10 MS UNITS
	ASHL	#1,R0,R0		; (SINCE NO UNSIGNED EDIV)
	ADDL	#<1@28>,R0		;COMPUTE BIASED VALUE FOR TODR
					;VALUES LESS THAN BIAS ARE USED
					;TO DETECT CLOCK POWERFAIL
	BRW	SET_TODR		;GO SET TIME-OF-DAY CLOCK
	.page
	.SBTTL	CVT_TIME
;++
;
; CVT_TIME - CONVERT AN ASCII STRING TO A BINARY TIME
;
; INPUTS:
;
;	R2 - POINTER TO TIME STRING
;	R10, R11 - NEW TIME IN BINARY
;
; OUTPUTS:
;
;	R6 - POINTER TO QUAD WORD TIME
;	R7 - POINTER TO ASCII TIME
;	R8 - POINTER TO DESCRIPTOR FOR ASCII TIME
;	R9 - ASCII VALUE OF BASE YEAR
;
;--

CVT_TIME:
	SUBL3	#8,FP,R6		;SET BINARY TIME BUFFER ADDR
	MOVL	R6,R8			;SET A REGISTER
	MOVL	R7,-(R8)		;CREATE DESCR
	MOVL	#BASETIMESZ,-(R8)	;LENGTH FIELD
	MOVQ	R10,(R6)		;SET NEW TIME IN BUFFER
	$ASCTIM_S TIMADR=(R6),-		;CONVERT NEW TIME TO ASCII
		  TIMBUF=(R8)		;
	MOVL	BASEYEAR(R7),R9		;GET NEW TIME'S YEAR
	MOVC	#BASETIMESZ,(R2),(R7)	;MOVE TODR BASE TO ASCII BUFFER
	MOVL	R9,BASEYEAR(R7)		;MOVE NEW TIME'S YEAR TO BUFFER
	$BINTIM_S TIMADR=(R6),-		;COMPUTE TODR BASE IN BINARY
		  TIMBUF=(R8)		;
	RSB				;LEAVE
	.PAGE
	.SBTTL	RECALIBRATE
;++
;
; RECAL - RECALIBRATE USING TIME-OF-DAY CLOCK
;
;	THE TIME-OF-DAY CLOCK IS SPECIFIED TO BE MORE ACCURATE
;	THAN THE INTERVAL TIMER. IF THE SYSTEM HAS BEEN UP AWHILE, THIS
;	FUNCTION CAN BE USED TO RECALIBRATE THE SYSTEM TIME.  THIS
;	FUNCTION IS ALSO USED BY SYSINIT TO SET THE SYSTEM TIME AT
;	EACH RE-BOOT.
;
;	IT IS IMPORTANT TO NOTE THAT THE HARDWARE CLOCK HAS A LIMIT
;	OF ABOUT 15 MONTHS.  IT SHOULD NEVER BE ALLOWED TO REACH THIS
;	LIMIT; THUS ANY VMS SYSTEM SHOULD BE BOOTED, OR A SET TIME
;	REQUEST SHOULD BE DONE AT LEAST ONCE BETWEEN 1-JAN AND 1-APR
;	OF EACH YEAR.
;
;	DELTA-TOD = PR$_TODR - EXE$GL_TODR
;	DELTA-TIME = DELTA-T0D * SCALE
;	EXE$GQ_SYSTIME, EXE$GQ_TODCBASE = EXE$GQ_TODCBASE + DELTA-TIME
;	PR$_TODR = PR$_TODR - BASE-YEAR IF PR$_TODR > BASE_YEAR
;
; INPUTS:
;
;	TIME-OF-DAY PROCESSOR CLOCK.
;
; OUTPUTS:
;
;	R0 = NEW TIME-OF-DAY CLOCK VALUE
;	R10,R11 = NEW SYSTEM TIME COMPUTED FROM TIME-OF-DAY CLOCK
;
;--

RECAL:					;RECALIBRATE USING TOD CLOCK
;
; CALCULATE HOW LONG THE BASE YEAR (DEFINED BY THE VALUE IN EXE$GQ_TODCBASE)
; IS.  THIS VALUE MAY BE NEEDED LATER TO CORRECT THE YEAR ROLLOVER IN THE
; HARDWARE TIME OF YEAR CLOCK.  THE CALCULATION IS DONE EARLY BECAUSE
; 1) IT DOES NOT DEPEND ON ANY CHANGING REGISTERS, AND 2) IT CAN BE DONE
; AT ZERO IPL ($BINTIM IS PAGED).
;
	MOVAQ	G^EXE$GQ_TODCBASE,AP	;GET A POINTER
	MOVQ	(AP),R10		;PICK UP CURRENT BASE TIME
	MOVAB	ENDTIME,R2		;GRAB PROPER TIME STRING
	BSBB	CVT_TIME		;CONVERT THE TIME
	MOVQ	(R6),R10		;HOLD YEAR-END TIME
	MOVC	#BASETIMESZ,BASETIME,(R7) ;MOVE BASE STRING TO BUFFER
	MOVL	R9,BASEYEAR(R7)		;MOVE NEW TIME'S YEAR TO BUFFER
	$BINTIM_S TIMADR=(R6),-		;COMPUTE TODR BASE IN BINARY
		  TIMBUF=(R8)		;
	SUBL	(R6)+,R10		;COMPUTE BASE YEAR'S LENGTH(-10 ms)
	SBWC	(R6),R11		;IN 100 NANOSECOND UNITS
	ADDL	B^SCALE2,R10		;ADD IN THE MISSING 10 MS
	ADWC	#0,R11			;
	MOVQ	R10,R0			;COPY
	EDIV	B^SCALE,R0,R0,R1	;SCALE TO 10 MS UNITS
	ASHL	#1,R0,R2		; (SINCE NO UNSIGNED EDIV)
;
; AT THIS POINT:
;	R10:R11 = THE NUMBER OF 10 NANOSECONDS IN THE BASE YEAR
;	R2 = THE NUMBER OF 10 MILLISECONDS IN THE BASE YEAR
;
; WE MUST CHECK THE PROCESSOR'S TIME OF YEAR CLOCK (PR$_TODR) TO SEE IF
; IT HAS HAS MORE THAN A YEAR'S WORTH OF TICKS IN IT.  IF SO, WE SUBTRACT
; OUT THE YEAR FROM THE CLOCK. IF NOT, WE DO NOT CHANGE THE CLOCK.
; IN EITHER CASE, WE THEN UPDATE THE SYSTEM TIME FROM THE CORRECT
; VALUE OF THE TODC.
;
LOCK_START:				;START OF LOCKED-DOWN CODE
	DSBINT	W^LOCK_IPL		;DISABLE ALL INTERRUPTS AND
					; LOCK CODE IN MEMORY
	MFPR	#PR$_TODR,R0		;GET TIME OF DAY CLOCK VALUE
	SUBL3	G^EXE$GL_TODR,R0,R1	;GET TOD DELTA TIME (10 MS UNITS)
	BGTRU	5$			;ZERO OR POSITIVE IS OKAY
	CMPL	R1,#-<24*60*60*100>	;IF NEGATIVE, THEN IF MORE THAN A DAY
	BLSSU	ERROR			;INVALID TIME IN PROCESSOR CLOCK
	EMUL	B^SCALE2,R1,#0,R10	;ELSE COVERT TO 100 NANOSECONDS
	BRB	20$			;AND CONTINUE ON

5$:	ADDL3	#<1@28>,R2,R3		;ADD IN THE BIAS TO THE YEAR
	CMPL	R0,R3			;CORRECTION NEEDED FOR CLOCK?
	BLSSU	10$			;NO CORRECTION NEEDED
;
; THE CLOCK HAS ONE YEAR TOO MANY TICKS.  WE MUST SUBTRACT OUT
; THE BASE YEAR FROM THE PROCESSOR TODC. AFTER THE YEAR IS SUBTRACTED OUT,
; THE DELTA WILL BE CORRECT.
;
	SUBL	R2,R0			;SUBTRACT OUT A YEAR
10$:
;
; AT THIS POINT:
;	R0 = CORRECT TODR + BIAS TO GO INTO PROCESSOR REGISTER
;	R1 = CORRECT TODR DELTA TO FIGURE TIME
;
	EXTZV	#1,#31,R1,R10		;DIVIDE BY 2
					;(SINCE NO UNSIGNED EMUL)
	EMUL	B^SCALE,R10,#0,R10 	;COMPUTE 100 NANOSECOND DELTA
	BLBC	R1,20$			;BR IF NO CORRECTION NEEDED
	ADDL	B^SCALE2,R10		;ADD LAST 10MS UNIT
	ADWC	#0,R11			;TO QUADWORD
20$:	ADDL	(AP),R10		;FORM ABSOLUTE TIME
	ADWC	4(AP),R11		;
	BRB	SET_TODR1		;SET THE TODR REGISTER
;
; THE VALUE IN THE PROCESSOR CLOCK WAS LESS THAN THE BIAS (2^28) OR
; IT WAS GREATER THAN THE LAST VALUE STORED IN EXE$GL_TODR - INDICATING
; THAT THE SYSTEM DISK HASN'T BEEN BOOTED IN A VERY LONG TIME AND THUS
; THE YEAR WITHIN DATE WILL NOT BE CORRECT.
;
ERROR:	ENBINT
	MOVZWL	#SS$_IVTIME,R0		;INVALID PROCESSOR CLOCK VALUE
	RET				;LEAVE AND REPORT IT
;
; SCALING VALUE FOR CALCULATIONS - MUST BE HERE SINCE IT IS REFERENCED
; FROM WITHIN A LOCKED-DOWN SECTION OF CODE.
;
SCALE:	.LONG	<100*1000*2>		;NUMBER OF 100 NS IN 10 MS * 2
SCALE2:	.LONG	<100*1000>		;NUMBER OR 100 NS IN 10 MS
	.PAGE
	.SBTTL	SET TODR
;++
;
; SET_TODR - SET NEW TIME-OF-DAY CLOCK VALUE
;
;	SET NEW TIME IN TIME-OF-DAY CLOCK, SYSTEM TIME, AND SAVE BOTH
;	IN SYSTEM PARAMETERS.  ALSO RECOMPUTE REMAINING TIME INTERVAL
;	IN TIMER QUEUE ENTRIES.
;
; INPUTS:
;
;	R0 = NEW TIME-OF-DAY CLOCK VALUE
;	R10,R11 = NEW SYSTEM TIME
;--
SET_TODR:
	DSBINT	B^LOCK_IPL		;DISABLE ALL INTERRUPTS AND
					;LOCK CODE IN MEMORY
SET_TODR1:
	MTPR	R0,#PR$_TODR		;SET AS CURRENT TIME
	MFPR	#PR$_TODR,R0		;GET TIME (MAY BE DIFFERENT THAN
					; WHAT WAS WRITTEN)
	MOVL	R0,G^EXE$GL_TODR	;SAVE TOD REG OF BASE
	MOVQ	R10,G^EXE$GQ_TODCBASE	;SAVE SYSTEM TIME OF TOD REG
	MOVQ	G^EXE$GQ_SYSTIME,R4	;GET CURRENT SYSTEM TIME
	MOVQ	R10,G^EXE$GQ_SYSTIME	;SET NEW SYSTEM TIME
;
; Recompute expiration times that were not specified as absolute so that the
; remaining interval is the same for the new system time.  Absolute expirations
; will occur with respect to the absolute value of the new system time.
;
	SUBL	R4,R10			;COMPUTE DELTA OF
	SBWC	R5,R11			; OLD AND NEW TIMES
	MOVAB	G^EXE$GL_TQFL,R3	;GET ADDRESS OF TIMER QUEUE HEAD
	MOVQ	(R3),R0			; Get existing timer queue
	MOVQ	R0,-(SP)		; Save existing timer queue
	MOVL	SP,TQE$L_TQFL(R1)	; Readjust links of endmost entries
	MOVL	SP,TQE$L_TQBL(R0)	;
	MOVL	R3,(R3)			; Reinitialize timer queue to empty
	MOVL	R3,4(R3)		;
10$:	REMQUE	@0(SP),R5		; Remove an entry from saved queue
	BVS	30$			; Br if no more to remove
	TSTL	TQE$Q_TIME+4(R5)	;IS THIS A VALID TIME?
					;(PERMANENT ENTRY IS INVALID)
	BLSS	20$			;BR IF NOT
	BBS	#TQE$V_ABSOLUTE,TQE$B_RQTYPE(R5),20$
					; Br if specified as absolute time
	ADDL	R10,TQE$Q_TIME(R5)	;ADD SYSTEM TIME DELTA
	ADWC	R11,TQE$Q_TIME+4(R5)	; TO REMAINING INTERVAL
20$:	MOVQ	TQE$Q_TIME(R5),R0	; Get time value
	JSB	G^EXE$INSTIMQ		; Reinsert in queue
	BRB	10$			;
30$:	ADDL2	#8,SP			; Clean up temporary queue
	ENBINT				;RE-ENABLE INTERRUPTS
	BRB	SAVE_TIME		;SAVE TIME IN SYSTEM IMAGE
;
; THE PRECEDING CODE MUST DISABLE ALL INTERRUPTS, BUT SINCE IT IS
; PAGED IT MUST BE LOCKED IN MEMORY.  THE USAGE OF THE DSBINT MACRO
; ABOVE, BOTH DISABLES INTERRUPTS AND FAULTS INTO MEMORY THE CODE
; BETWEEN THE DSBINT AND LOCK_IPL.
;
LOCK_IPL:				;IPL NEEDED TO BLOCK EVERYTHING
	.LONG	IPL$_POWER		;
LOCK_END:				;END OF LOCKED-DOWN CODE
	ASSUME	<LOCK_END-LOCK_START> LE 512 ;ONE PAGE TO A CUSTOMER
	.PAGE
	.SBTTL	SAVE TIME
;++
;
; SAVE_TIME - SAVE TIME-OF-DAY CLOCK VALUE AND SYSTEM TIME
;
;	SAVE TIME OF DAY REGISTER AND CORRESPONDING SYSTEM TIME IN THE
;	SYSTEM IMAGE FILE.  THESE ARE LOCATED IN THE SYSTEM PARAMETERS
;	SO WE WILL JUST WRITE THE SYSTEM PARAMETER PAGE(S).
;
; INPUTS:
;
;	EXE$GL_TODR = TIME-OF-DAY CLOCK VALUE.
;	EXE$GQ_TODCBASE = SYSTEM CORRESPONDING TO TIME-OF-DAY CLOCK.
;--
SAVE_TIME:				;SAVE TIME IN SYSTEM IMAGE FILE
	MOVAB	G^EXE$A_SYSPARAM,R2	;GET SYSTEM PARAMETER ADDRESS
	JSB	EXE$BOOTCB_CHK		;IS THE BOOT CONTROL BLOCK OK?
	BEQL	10$			;BRANCH IF YES
	BUG_CHECK BADBOOTCB		;ISSUE NON-FATAL BUGCHECK
	MOVL	S^#SS$_NORMAL,R0	;FAKE A SUCCESSFUL COMPLETION
	BRW	EXIT			;AND EXIT
10$:	MOVL	BOO$L_PARAM_MAP(R1),R3	;ADR OF VIRTUAL TO LOGICAL MAP
	ASHL	#-3,(R3)+,R6		;RETRIEVAL POINTER COUNT
	MOVAL	-(SP),R4		;ALLOCATE BUFF FOR CHANNEL
	MOVAQ	-(SP),R5		;ALLOCATE BUFF FOR IOSB
	$ASSIGN_S DEVNAM=SYSDISK,-	;ASSIGN A CHANNEL TO SYSTEM DISK
		  CHAN=(R4)		;
	BLBC	R0,EXIT			;BR IF ERROR
20$:	ASHL	#9,(R3)+,R7		;BYTE COUNT FOR THIS RTRV PTR
	MOVL	(R3)+,R8		;STARTING LBN FOR THIS PIECE
	$QIO_S	CHAN=(R4),-		;SAVE NEW TOD WITH SYSTEM PARAMS
		FUNC=S^#IO$_WRITELBLK,-	;
		EFN=#FLAG,-		;EVENT FLAG
		P1=(R2),-		;VIRTUAL ADDRESS OF BUFFER
		P2=R7,-			;BYTE COUNT TO TRANSFER
		P3=R8,-			;LBN
		IOSB=(R5)		;
	BLBC	R0,60$			;BRANCH IF FAILED TO QUEUE REQUEST
30$:	$WAITFR_S #FLAG			;WAIT FOR EVENT FLAG TO SET AGAIN
	TSTW	(R5)			;DID I/O COMPLETE?
	BNEQ	50$			;BRANCH IF I/O ACTUALLY COMPLETED
	$CLREF_S #FLAG			;CLEAR THE EVENT FLAG TO PREPARE FOR WAIT
	TSTW	(R5)			;DID I/O COMPLETE?
	BEQL	30$			;BRANCH IF NOT DONE
	$SETEF_S #FLAG			;SET FLAG FOR CLEAN COMPLETION
50$:	MOVZWL	(R5),R0			;GET STATUS FROM IOSB
	BLBC	R0,60$			;IF ERROR, THEN QUIT
	ADDL	R7,R2			;SET UP TO WRITE FROM NEXT VA
	SOBGTR	R6,20$			;LOOP THROUGH THE RETRIEVAL POINTERS
60$:	PUSHL	R0			;SAVE STATUS
	$DASSGN_S CHAN=(R4)		;DEASSIGN CHANNEL
	POPR	#^M<R0>			;RESTORE STATUS
EXIT:					;
	RET				;AND RETURN

	.END
