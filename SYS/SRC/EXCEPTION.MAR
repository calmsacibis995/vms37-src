	.TITLE	EXCEPTION - EXCEPTION HANDLING
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 6-JUL-76
;
; MODIFIED BY:
;
;	V02-016	MSH0001		Maryann Hinden		09-Feb-1982
;		Fix PROBE problem.
;
;	V02-015	ACG0261		Andrew C. Goldstein,	4-Feb-1982  13:50
;		Fix skipping over vectored handler invocations
;		in nested exceptions.
;
;	V02-014	ACG0260		Andrew C. Goldstein,	1-Feb-1982  16:25
;		Make failure to create stack space non-fatal for user
;		and super modes
;
;	V02-013	ACG0242		Andrew C. Goldstein,	30-Dec-1981  19:12
;		Catch exceptions at AST call site
;
;	V02-012	ACG0224		Andrew C. Goldstein,	23-Nov-1981  14:31
;		Fix access mode used to report AST faults
;
;	V02-011	ACG0222		Andrew C. Goldstein,	17-Nov-1981  16:52
;		Fix context bug in compatibility mode check
;
;	V02-010 DWT0003		David W. Thiel		11-Nov-1981
;		Allow T-bit traps during call to a condition handler.
;		Fix SEARCH's condition handler.
;		Define global entry (EXE$SIGTORET) for a condition handler
;		that turns an exception into a return with status.
;
;	V02-009	KDM0064		Kathleen D. Morse	25-Aug-1981
;		Change label of EXCEPTION to EXE$EXCEPTION, for the use of
;		the multi-processing code.
;
;	V02-008	LJK0036		Lawrence J. Kenah	23-Jun-1981
;		Convert fatal exception for executive mode into a
;		nonfatal bugcheck.
;
;	V02-007	KTA0022		Kerbey T. Altmann	10-Jun-1981
;		Add some code for inhibited system services. Change
;		stack range check to use new top limit array.
;
;	V02-006	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to use CTL$GL_PCB instead.
;
;	V02-005	ACG0183		Andrew C. Goldstein,	29-Dec-1980  20:01
;		Fix condition handler search bugs, add entry point for
;		LIB$SIGNAL, add support for LIB$STOP, add checks to catch
;		call failures to handlers.
;
;
; HARDWARE EXCEPTION HANDLING
;
;****************************************************************************
;
; FAIR WARNING!! THE EXCEPTION REFLECTION AND CONDITION HANDLING CODE IN
; THIS MODULE CRAWLS WITH ASSUMPTIONS ABOUT THE FORMAT OF THE STACK AND
; ARGUMENT LISTS, AS DOCUMENTED IN VARIOUS COMMENTS THROUGHOUT. SINCE
; THE STACK POINTER MOVES FREQUENTLY, NO ATTEMPT HAS BEEN MADE TO USE
; SYMBOLIC OFFSETS FOR STACK RELATIVE REFERENCES. CHANGES TO THE STACK
; FORMAT SHOULD BE MADE ONLY AFTER THOROUGH INSPECTION AND UNDERSTANDING
; OF THE CODE (NOT TO MENTION APPENDIX C OF THE ARCHITECTURE HANDBOOK).
; NOTE ALSO THAT LIB$SIGNAL MUST TRACK THE STACK FORMATS USED HERE.
;
;****************************************************************************
;
; MACRO LIBRARY CALLS
;
 
	$CHFDEF				;DEFINE CONDITION HANDLING ARGLIST OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$MCHKDEF			;DEFINE MACHINE CHECK RECOVERY BITS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PHDDEF				;DEFINE PHD OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$STSDEF				;DEFINE STATUS CODE FIELDS
	$VADEF				;DEFINE VIRTUAL ADDRESS FIELDS
 
;
; LOCAL SYMBOLS
;
; CALL FRAME OFFSET DEFINITIONS
;
 
HANDLER=0				;CONDITION HANDLER ADDRESS
SAVPSW=4				;SAVED PSW FROM CALL
SAVMSK=6				;REGISTER SAVE MASK
SAVAP=8					;SAVED AP REGISTER IMAGE
SAVFP=12				;SAVED FP REGISTER IMAGE
SAVPC=16				;SAVED PC REGISTER IMAGE
SAVRG=20				;OTHER SAVED REGISTER IMAGES
 
;
; LOCAL DATA
;
 
	.PSECT	YEXEPAGED1,LONG

FINAL_IDX	= 0			;INDICES TO FETCH MESSAGE ADDRESSES
ATTCONSTO_IDX	= 1
BADHANDLER_IDX	= 2
BADAST_IDX	= 3

MSG_VECTOR:
	.ADDRESS	FINALMSG
	.ADDRESS	ATTCONSTO_MSG
	.ADDRESS	BADHANDLER_MSG
	.ADDRESS	BADAST_MSG

FINALMSG:				;FINAL EXCEPTION MESSAGE
	.ASCIZ	/bad stack or no handler specified./ ;
ATTCONSTO_MSG:				;ATTEMPT TO CONTINUE FROM STOP MESSAGE
	.ASCIZ	/attempt to continue from STOP./
BADHANDLER_MSG:				;BAD CONDITION HANDLER MESSAGE ADDRESS
	.ASCIZ	/invalid condition handler address or entry mask./
BADAST_MSG:				;BAD AST MESSAGE ADDRESS
	.ASCIZ	/invalid AST address or entry mask./

	.SBTTL	ACCESS VIOLATION FAULT
;+
; EXE$ACVIOLAT - ACCESS VIOLATE FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN AN ACCESS VIOLATION IS
; DETECTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ACCESS VIOLATION REASON MASK.
;	04(SP) = ACCESS VIOLATION VIRTUAL ADDRESS.
;	08(SP) = EXCEPTION PC.
;	12(SP) = EXCEPTION PSL.
;
; ACCESS VIOLATION REASON MASK FORMAT IS:
;
;	BIT 0 = TYPE OF ACCESS VIOLATION.
;		0 = PTE ACCESS CODE DID NOT PERMIT INTENTED ACCESS.
;		1 = P0LR, P1LR, OR S0LR LENGTH VIOLATION.
;	BIT 1 = PTE REFERENCE.
;		0 = SPECIFIED VIRTUAL ADDRESS NOT ACCESSIBLE.
;		1 = ASSOCIATED PAGE TABLE ENTRY NOT ACCESSIBLE.
;	BIT 2 = INTENDED ACCESS TYPE.
;		0 = READ.
;		1 = MODIFY.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.PSECT	$AEXENONPAGED,LONG
	.ALIGN	LONG
EXE$ACVIOLAT::				;ACCESS VIOLATION FAULTS
	CMPZV	#PSL$V_CURMOD,#PSL$S_CURMOD,12(SP),#PSL$C_USER ; CHECK FOR USER 
	BNEQ	ACVIOLAT		;NO, REALLY AN ACCESS VIOLATION
	PUSHR	#^M<R0,R1,R2,R3>	;SAVE WORKING REGISTERS
	MOVL	<4+<4*4>>(SP),R2	;GET BASE ADDRESS FOR EXTEND
	JSB	EXE$EXPANDSTK		;EXPAND STACK
	BLBC	R0,10$			;BR IF CANT EXTEND
	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS
	ADDL	#8,SP			;CLEAN EXCEPTION PARAMETERS FROM STACK
	REI				;AND RETURN TO RETRY INSTRUCTION
10$:	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS
ACVIOLAT:				;
	MOVZWL	#SS$_ACCVIO,-(SP)	;SET EXCEPTION NAME
	BRW	EX5ARG			;

	.SBTTL	ARITHMETIC TRAPS
;+
; EXE$ARITH - ARITHMETIC TRAPS
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN AN ARITHMETIC TRAP IS
; DETECTED AT THE END OF AN INSTRUCTION. THE STATE OF THE STACK ON ENTRY
; IS:
;
;	00(SP) = ARITHMETIC EXCEPTION CODE.
;	04(SP) = EXCEPTION PC.
;	08(SP) = EXCEPTION PSL.
;
; POSSIBLE ARITHMETIC EXCEPTION CODES ARE:
;
;	0 = UNDEFINED.
;	1 = INTERGER OVERFLOW.
;	2 = INTEGER DIVIDE BY ZERO.
;	3 = FLOATING OVERFLOW.
;	4 = FLOATING DIVIDE BY ZERO.
;	5 = FLOATING UNDERFLOW.
;	6 = DECIMAL STRING OVERFLOW.
;	7 = DECIMAL STRING DIVIDE BY ZERO.
;	8 = FLOATING OVERFLOW FAULT.
;	9 = FLOATING DIVIDE BY ZERO FAULT.
;      10 = FLOATING UNDERFLOW FAULT.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$ARITH::				;ARITHMETIC TRAPS
	MULL	#8,(SP)			;CALCULATE EXCEPTION NAME OFFSET
	ADDW	#SS$_ARTRES,(SP)	;CALCULATE ACTUAL EXCEPTION NAME
	BRW	EX3ARG			;

	.SBTTL	AST DELIVERY STACK FAULT
;+
; EXE$ASTFLT - AST DELIVERY STACK FAULT
;
; THIS ROUTINE IS ENTERED VIA A JMP FROM THE AST DELIVERY MODULE 
; WHEN AN INVALID STACK IS DETECTED WHILE ATTEMPTING TO DELIVER AN
; AST.  THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = SP VALUE AT FAULT (UNMODIFIED BY AST DELIVERY).
;	04(SP) = AST PARAMETER OF FAILED AST.
;	08(SP) = PC AT AST DELIVERY INTERRUPT.
;	12(SP) = PSL AT AST DELIVERY INTERRUPT.
;	16(SP) = PC TO WHICH AST WOULD HAVE BEEN DELIVERED.
;	20(SP) = PSL AT WHICH AST WOULD HAVE BEEN DELIVERED.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF ARGUMENTS ARE PUSHED
; ON THE STACK.  FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;
; NOTE THAT THE PREVIOUS MODE FIELD IN THE PSL IS KERNEL MODE IN THIS
; ENTRY POINT, SINCE AST'S (AND AST FAULTS) RESULT FROM INTERRUPTS, AS
; OPPOSED TO ALL OTHER EXCEPTIONS WHICH RESULT FROM FAULTS OR TRAPS.
; SINCE THE EXCEPTION MAIN BODY EXPECTS PREVIOUS MODE TO BE THE MODE
; IN WHICH THE EXCEPTION OCCURRED, AND THE MODE TO WHICH IT WILL BE
; REPORTED, WE MUST FIX IT UP ACCORDINGLY.
;-

EXE$ASTFLT::				;AST DELIVERY STACK FAULT
	MOVZWL	#SS$_ASTFLT,-(SP)	;PUSH EXCEPTION CODE
	PUSHL	#7			;AND COUNT OF ARGUMENTS
	BICL3	#^C<PSL$M_PRVMOD>,28(SP),-(SP) ;CONSTRUCT PROPER PSL
	PUSHAB	W^EXE$EXCEPTION		;AND EXCEPTION ENTRY POINT
	REI				;SET PSL AND ENTER COMMON EXCEPTION CODE

	.SBTTL	BREAKPOINT FAULT
;+
; EXE$BREAK - BREAKPOINT FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A BREAKPOINT
; INSTRUCTION IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = EXCEPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$BREAK::				;BREAKPOINT FAULT
	MOVZWL	#SS$_BREAK,-(SP)	;SET EXCEPTION NAME
	BRW	EX3ARG			;

	.SBTTL	CHANGE MODE TO SUPERVISOR TRAP
;+
; EXE$CMODSUPR - CHANGE MODE TO SUPERVISOR TRAP
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A CHANGE MODE TO SUPER-
; VISOR INSTRUCTION IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = CHANGE MODE CODE.
;	04(SP) = EXCEPTION PC.
;	08(SP) = EXCEPTION PSL.
;
; IF THE PROCESS HAS DECLARED A CHANGE MODE TO SUPERVISOR HANDLER, THEN THE
; EXCEPTION IS DIRECTLY VECTORED TO THE SPECIFIED HANDLER. ELSE THE EXCEPTION
; NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE PUSHED ON THE STACK.
; FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$CMODSUPR::				;CHANGE MODE TO SUPERVISOR TRAP
	MOVZWL	#SS$_CMODSUPR,-(SP)	;SET EXCEPTION NAME
	PUSHL	@#CTL$GL_CMSUPR		;GET CONTENTS OF CHANGE MODE VECTOR
	BRB	EXCCMD			;

	.SBTTL	CHANGE MODE TO USER TRAP
;+
; EXE$CMODUSER - CHANGE MODE TO USER TRAP
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A CHANGE MODE TO USER
; INSTRUCTION IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = CHANGE MODE CODE.
;	04(SP) = EXCEPTION PC.
;	08(SP) = EXCEPTION PSL.
;
; IF THE PROCESS HAS DECLARED A CHANGE MODE TO USER HANLDER, THEN THE EXCEPTION
; IS VECTORED DIRECTLY TO THE SPECIFIED HANDLER. ELSE THE EXCEPTION NAME FOLLOWED
; BY THE NUMBER OF ARGUMENTS ARE PUSHED ON THE STACK. FINAL PROCESSING IS ACCOM-
; PLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$CMODUSER::				;CHANGE MODE TO USER TRAP
	MOVZWL	#SS$_CMODUSER,-(SP)	;SET EXCEPTION NAME
	PUSHL	@#CTL$GL_CMUSER		;GET CONTENTS OF CHANGE MODE VECTOR
EXCCMD:	BEQL	10$			;IF EQL NO DISPATCHER SPECIFIED
	POPL	(SP)			;REMOVE EXCEPTION NAME FROM STACK
	RSB				;
10$:	ADDL	#4,SP			;CLEAN STACK
	BRW	EXSSXT			;

	.SBTTL	COMPATIBILITY MODE FAULTS
;+
; EXE$COMPAT - COMPATIBILITY MODE FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A COMPATIBILITY MODE
; EXCEPTION IS DETECTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = COMPATIBILITY EXCEPTION CODE.
;	04(SP) = EXCEPTION PC.
;	08(SP) = EXCEPTION PSL.
;
; POSSIBLE COMPATIBILITY EXCEPTION CODES ARE:
;
;	0 = RESERVED INSTRUCTION EXECUTION.
;	1 = BPT INSTRUCTION EXECUTION.
;	2 = IOT INSTRUCTION EXECUTION.
;	3 = EMT INSTRUCTION EXECUTION.
;	4 = TRAP INSTRUCTION EXECUTION.
;	5 = ILLEGAL INSTRUCTION EXECUTION.
;	6 = ODD ADDRESS FAULT.
;	7 = TBIT TRAP.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$COMPAT::				;COMPATIBILITY MODE FAULTS
	MOVQ	R0,@#CTL$AL_CMCNTX	;SAVE R0,R1 IN COMPATIBILITY CONTEXT REGION
	MOVAL	@#CTL$AL_CMCNTX+8,R0	;GET ADDRESS OF COMPATIBILITY CONTEXT AREA
	MOVQ	R2,(R0)+		;SAVE R2,R3
	MOVQ	R4,(R0)+		;SAVE R4,R5
	MOVL	R6,(R0)+		;SAVE R6
	MOVL	(SP)+,(R0)+		;SAVE EXCEPTION CODE AND REMOVE FROM STACK
	MOVQ	(SP)+,(R0)		;SAVE PC AND PSL AND REMOVE FROM STACK
	PUSHL	#<PSL$C_USER@PSL$V_PRVMOD>!<PSL$C_USER@PSL$V_CURMOD> ;FABRICATE PSL FOR CME
	PUSHL	@#CTL$GL_CMHANDLR	;COMPATIBILITY MODE HANDLER ADDRESS
	BEQL	20$			;BRANCH IF NONE SPECIFIED
	REI				;JUMP TO COMPATIBILITY HANDLER

;
; NO COMPATIBILITY MODE HANDLER WAS DECLARED.  RESTORE THE STACK AND
; SAVED REGISTER, AND CONTINUE THROUGH NORMAL EXCEPTION CODE.  R0 NOW
; POINTS TO THE SAVED PC IN THE COMPATIBILITY CONTEXT AREA.
;

20$:	MOVQ	(R0),(SP)		;RESTORE EXCEPTION PC AND PSL
	PUSHL	-(R0)			;PUSH EXCEPTION CODE AGAIN
	MOVL	-28(R0),R0		;RESTORE R0 FROM TOP OF CONTEXT AREA
	MOVZWL	#SS$_COMPAT,-(SP)	;SET EXCEPTION NAME
EX4ARG:	PUSHL	#4			;SET NUMBER OF SIGNAL ARGUMENTS
	BRW	EXE$EXCEPTION		;FINISH IN COMMON CODE

	.SBTTL	KERNEL STACK NOT VALID FAULT
;+
; EXE$KERSTKNV - KERNEL STACK NOT VALID FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A KERNEL STACK NOT
; VALID IS DETECTED DURING A CHANGE MODE INSTRUCTION, DURING AN REI
; INSTRUCTION, OR DURING AN ATTEMPT TO PUSH EXCEPTION INFORMATION ON
; THE KERNEL STACK. THIS EXCEPTION RUNS ON THE INTERRUPT STACK. THE
; STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = EXCEPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; A FATAL KERNEL STACK NOT VALID BUGCHECK IS DECLARED.
;-
 
	.ALIGN	LONG
EXE$KERSTKNV::				;KERNEL STACK NOT VALID FAULT
	BUG_CHECK KRNLSTAKNV,FATAL	;KERNEL STACK NOT VALID

	.SBTTL	SIGNAL UNRECOVERABLE MACHINE CHECK
;+
; EXE$MCHECK - SIGNAL UNRECOVERABLE MACHINE CHECK
;
; THIS ROUTINE IS ENTERED FROM THE MACHINE CHECK HANDLER TO SIGNAL
; THE ERROR BACK TO EITHER USER OR SUPERVISOR MODE.  IF THE MACHINE
; CHECK OCCURRED IN EXEC OR KERNEL MODE CONTROL DOES NOT COME HERE
; AND INSTEAD THE MACHINE CHECK HANDLER BUGCHECKS.
; STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = MACHINE CHECK EXCEPTION CODE
;	04(SP) = EXCEPTION PC
;	08(SP) = EXCEPTION PSL
;
; POSSIBLE CODES ARE:
;
;
; NO ALIGNMENT IS NECESSARY HERE, REI GETS US HERE
;-

EXE$MCHECK::
	MOVZWL	#SS$_MCHECK,-(SP)	;SET EXCEPTION NAME
	BRB	EX3ARG			;FINISH IN COMMON CODE

	.SBTTL	OPCODE RESERVED TO CUSTOMER FAULT
;+
; EXE$OPCCUS - OPCODE RESERVED TO CUSTOMER FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN AN OPCODE THAT IS RESERVED
; TO CUSTOMERS IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = EXCEPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$OPCCUS::				;OPCODE RESERVED TO CUSTOMERS FAULT
	MOVZWL	#SS$_OPCCUS,-(SP)	;SET EXCEPTION NAME
	BRB	EX3ARG			;

	.SBTTL	OPCODE RESERVED TO DIGITAL FAULT
;+
; EXE$OPCDEC - OPCODE RESERVED TO DIGITAL FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN AN OPCODE THAT IS RESERVED
; TO DIGITAL IS EXECUTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = EXECPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$OPCDEC::				;OPCODE RESERVED TO DIGITAL FAULT
	CMPB	#^XFF,@(SP)		;POSSIBLY A BUG CHECK?
	BEQL	20$			;IF EQL YES
10$:	MOVZWL	#SS$_OPCDEC,-(SP)	;SET EXCEPTION NAME
	BRB	EX3ARG			;
20$:	PUSHL	(SP)			;COPY ADDRESS OF INSTRUCTION
	INCL	(SP)			;CALCULATE ADDRESS OF NEXT BYTE
	IFNORD	#1,@(SP),40$		;CAN NEXT BYTE BE READ?
	CMPB	#^XFE,@(SP)		;BUGCHECK WORD?
	BEQL	30$			;IF EQL YES
	CMPB	#^XFD,@(SP)+		;BUGCHECK LONG?
	BNEQ	10$			;IF NEQ NO
	TSTL	-(SP)			;ADJUST STACK POINTER
30$:	TSTL	(SP)+			;REMOVE INSTRUCTION ADDRESS FROM STACK
	BRW	EXE$BUG_CHECK		;
40$:	PUSHL	#0			;SET REASON FOR ACCESS VIOLATION
	BRW	EXE$ACVIOLAT		;

	.SBTTL	PAGE READ FAULT
;+
; EXE$PAGRDERR - PAGE READ FAULT
;
; THIS ROUTINE IS ENTERED VIA A JUMP FROM THE TRANSLATION NOT VALID
; EXCEPTION ROUTINE WHEN A READ ERROR OCCURS IN TRYING TO MAKE THE
; DESIRED PAGE VALID.  THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = TRANSLATION NOT VALID REASON MASK.
;	04(SP) = TRANSLATION NOT VALID VIRTUAL ADDRESS.
;	08(SP) = EXCEPTION PC.
;	12(SP) = EXCEPTION PSL.
;
; TRANSLATION NOT VALID REASON MASK FORMAT IS:
;
;	BIT 0 = 0 (USED ONLY FOR ACCESS VIOLATION).
;	BIT 1 = PTE REFERENCE.
;		0 = SPECIFIED VIRTUAL ADDRESS NOT VALID.
;		1 = ASSOCIATED PAGE TABLE ENTRY NOT VALID.
;	BIT 2 = INTENDED ACCESS TYPE.
;		0 = READ.
;		1 = MODIFY.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
EXE$PAGRDERR::				;PAGE READ ERROR
	MOVZWL	#SS$_PAGRDERR,-(SP)	;SET EXCEPTION NAME
EX5ARG:	PUSHL	#5			;SET NUMBER OF SIGNAL ARGUMENTS
	BRW	EXE$EXCEPTION		;FINISH IN COMMON CODE

	.SBTTL	RESERVED ADDRESSING MODE FAULT
;+
; EXE$RADRMOD - RESERVED ADDRESSING MODE FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN AN ATTEMPT TO USE A
; RESERVED ADDRESSING MODE IS DETECTED. THE STATE OF THE STACK ON ENTRY
; IS:
;
;	00(SP) = EXCEPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$RADRMOD::				;RESERVED ADDRESSING MODE FAULT
	MOVZWL	#SS$_RADRMOD,-(SP)	;SET EXCEPTION NAME
	BRB	EX3ARG			;

	.SBTTL	RESERVED OPERAND FAULT
;+
; EXE$ROPRAND - RESERVED OPERAND FAULT
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN AN ATTEMPT TO USE A
; RESERVED OPERAND IS DETECTED. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = EXCEPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; THE EXCEPTION NAME FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE
; PUSHED ON THE STACK. FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$ROPRAND::				;RESERVED OPERAND FAULT
	MOVZWL	#SS$_ROPRAND,-(SP)	;SET EXCEPTION NAME
	BRB	EX3ARG			;

	.SBTTL	TBIT PENDING TRAP
;+
; EXE$TBIT - TBIT PENDING TRAP
;
; THIS ROUTINE IS AUTOMATICALLY VECTORED TO WHEN A TBIT PENDING EXCEPTION
; IS DETECTED AT THE END OF AN INSTRUCTION. THE STATE OF THE STACK ON ENTRY
; IS:
;
;	00(SP) = EXCEPTION PC.
;	04(SP) = EXCEPTION PSL.
;
; IF THE TRAP OCCURED FROM COMPATIBILITY MODE, THEN THE CODE FOR COMPATIBILITY
; MODE TBIT TRAP (7) IS PUSHED ON THE STACK AND AN EXIT IS MADE THROUGH
; THE COMPATIBILITY MODE EXCEPTION ROUTINE. ELSE THE TBIT EXCEPTION NAME
; FOLLOWED BY THE NUMBER OF EXCEPTION ARGUMENTS ARE PUSHED ON THE STACK.
; FINAL PROCESSING IS ACCOMPLISHED IN COMMON CODE.
;-
 
	.ALIGN	LONG
EXE$TBIT::				;TBIT PENDING TRAP
	PUSHL	#7			;ASSUME TRAP FROM COMPATIBILITY MODE
	BBC	#PSL$V_CM,8(SP),10$	;IF CLEAR, NOT FROM COMPATIBILITY MODE
	BRW	EXE$COMPAT		;IF SET, GO TO COMPATIBILITY MODE CODE
10$:	ADDW	#SS$_TBIT-7,(SP)	;ADJUST NAME TO THAT FOR TBIT
EX3ARG:	PUSHL	#3			;SET NUMBER OF SIGNAL ARGUMENTS
	BRW	EXE$EXCEPTION		;

	.SBTTL	SYSTEM SERVICE FAILURE EXCEPTION
;+
; EXE$SSFAIL - SYSTEM SERVICE FAILURE EXCEPTION
;
; THIS ROUTINE IS JUMPED TO FROM THE SYSTEM SERVICE CHANGE MODE DISPATCHER
; WHEN THE RETURN STATUS FROM A SYSTEM SERVICE INDICATES FAILURE, THE
; PREVIOUS MODE WAS USER, AND THE CURRENT PROCESS IS ENABLED FOR SYSTEM
; SERVICE FAILURE EXCEPTIONS. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = CHANGE MODE PC.
;	04(SP) = CHANGE MODE PSL.
;
; WITH:
;
;	R0 = FINAL SYSTEM SERVICE STATUS.
;-
 
EXE$SSFAIL::				;SYSTEM SERVICE FAILURE EXCEPTION
	PUSHL	R0			;PUSH REASON FOR SERVICE FAILURE
	MOVZWL	#SS$_SSFAIL,-(SP)	;SET EXCEPTION NAME
 
;
; THE FOLLOWING EXCEPTIONS CONVERGE TO THIS POINT:
;
;	CHANGE MODE TO SUPERVISOR,
;	CHANGE MODE TO USER, AND
;	SYSTEM SERVICE FAILURE.
;
 
EXSSXT:	PUSHL	#4			;SET NUMBER OF SIGNAL ARGUMENTS
	JMP	EXE$REFLECT		;REFLECT EXCEPTION TO PREVIOUS MODE

	.SBTTL	REFLECT EXCEPTION FROM MODE OTHER THAN KERNEL
;+
; EXE$REFLECT - REFLECT EXCEPTION FROM MODE OTHER THEN KERNEL
;
; THIS ROUTINE IS JUMPED TO REFLECT AN EXCEPTION FROM A MODE OTHER THAN KERNEL.
; THE SIGNAL ARGUMENTS ARE ASSUMED TO BE SET UP PROPERLY ON THE STACK.
; NOTE THAT THE PREVIOUS MODE FIELD OF THE PSL CONTAINS THE ACCESS MODE
; OF THE EXCEPTION.
;-
 
	.PSECT	YEXEPAGED1
EXE$REFLECT::				;REFLECT EXCEPTION
	PUSHL	#1			;SAVE CODE INDICATION SIGNAL
	PUSHR	#^M<R0,R1>		;SAVE REGISTERS R0 AND R1
	MNEGL	#3,-(SP)		;SET INITIAL FRAME DEPTH
	PUSHL	FP			;SET INITIAL HANDLER ESTABLISHER FRAME
	PUSHL	#4			;SET NUMBER OF MECHANISM ARGUMENTS
 
;
; AT THIS POINT THE STACK HAS THE FOLLOWING FORMAT:
;
;	00(SP) = NUMBER OF MECHANISM ARGUMENTS (ALWAYS 4).
;	04(SP) = FP OF HANDLER ESTABLISHER FRAME (TENTATIVE).
;	08(SP) = FRAME DEPTH (ALWAYS -3).
;	12(SP) = SAVED R0.
;	16(SP) = SAVED R1.
;	20(SP) = FLAGS LONGWORD
;	24(SP) = NUMBER OF SIGNAL ARGUMENTS.
;	28(SP) = EXCEPTION NAME (INTEGER VALUE).
;	32(SP) = FIRST EXCEPTION PARAMETER (IF ANY).
;	36(SP) = SECOND EXCEPTION PARAMETER (IF ANY).
;	      .
;	      .
;	      .
;	28+N*4(SP) = N'TH EXCEPTION PARAMETER (IF ANY).
;	28+N*4+4(SP) = EXCEPTION PC.
;	28+N*4+8(SP) = EXCEPTION PSL.
;
 
	MOVPSL	R0			;READ CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R0,R1 ;CURRENT MODE KERNEL?
	BEQL	30$			;IF EQL YES
	CMPZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R0,R1 ;IS CURRENT EQL PREVIOUS?
	BEQL	40$			;IF EQL YES
 
;
; ADJUST PREVIOUS MODE STACK POINTER USING SYSTEM SERVICE
;
 
	PUSHR	#^M<R2,R3,R4>		;SAVE REGISTERS R2, R3, AND R4
	ADDL3	#7,36(SP),R3		;CALCULATE NUMBER OF LONGWORDS TO MOVE
	PUSHAB	W^NORMAL		;ASSUME INFORMATION CAN BE COPIED
	CLRL	-(SP)			;SET TO USE CURRENT STACK POINTER VALUE
	PUSHAB	(SP)			;PUSH ADDRESS TO STORE UPDATED STACK VALUE
	ASHL	#2,R3,-(SP)		;CALCULATE STACK ADJUSTMENT VALUE
	MNEGL	(SP),(SP)		;SET NEGATIVE ADJUSTMENT VALUE
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R0,-(SP) ;PUSH ACCESS MODE OF STACK
	PUSHL	#3			;PUSH NUMBER OF ARGUMENTS
	CALLG	(SP),@#SYS$ADJSTK	;ADJUST PREVIOUS MODE STACK POINTER
	BLBS	R0,20$			;IF LBS SUCCESSFUL COMPLETION
10$:	MOVAB	W^BADSTACK,20(SP)	;SET BAD STACK RETURN
	MOVL	4(SP),R2		;RETRIEVE PREVIOUS ACCESS MODE
	MOVL	@#CTL$AL_STACK[R2],16(SP) ;SET TO USE SPECIFED STACK POINTER VALUE
	CALLG	(SP),SYS$ADJSTK		;RELOAD PREVIOUS MODE STACK POINTER
	BLBS	R0,20$			;IF LBS SUCCESSFUL COMPLETION
	SUBL3	#4,@#CTL$AL_STACK[R2],-(SP) ;CALCULATE TOP ADDRESS OF STACK RANGE
	ADDL3	12(SP),(SP),-(SP)	;CALCULATE BOTTOM ADDRESS OF STACK RANGE
	BSBW	CRESTACK		;RE-CREATE VIRTUAL SPACE UNDER STACK
	ADDL	#8,SP			;REMOVE VIRTUAL ADDRESS DESCRIPTOR
	BRB	10$			;AND TRY AGAIN

20$:	ADDL	#16,SP			;REMOVE ARGUMENT LIST FROM STACK
	POPR	#^M<R1>			;GET NEW PREVIOUS MODE STACK POINTER VALUE
	BRW	COPYARGS		;
30$:	JMP	REFLECT			;
40$:	BRW	NORMAL			;

	.SBTTL	COMMON EXCEPTION EXIT
;
; ALL EXCEPTIONS CONVERGE TO THIS POINT WITH:
;
;	00(SP) = NUMBER OF SIGNAL ARGUMENTS.
;	04(SP) = EXCEPTION NAME (INTEGER VALUE).
;	08(SP) = FIRST EXCEPTION PARAMETER (IF ANY).
;	12(SP) = SECOND EXCEPTION PARAMETER (IF ANY).
;	      .
;	      .
;	      .
;	04+N*4(SP) = N'TH EXCEPTION PARAMETER (IF ANY).
;	04+N*4+4(SP) = EXCEPTION PC.
;	04+N*4+8(SP) = EXCEPTION PSL.
;
; NOTE THAT THE PREVIOUS MODE FIELD OF THE PSL CONTAINS THE ACCESS MODE
; OF THE EXCEPTION.
;
 
	.PSECT	$AEXENONPAGED,LONG
	.ENABL	LSB
EXE$EXCEPTION::				;THIS LABEL MUST BE GLOBAL FOR MP CODE
	PUSHL	#1			;SET CODE INDICATING SIGNAL
	PUSHR	#^M<R0,R1>		;SAVE REGISTERS R0 AND R1
	MNEGL	#3,-(SP)		;SET INITIAL FRAME DEPTH
	PUSHL	FP			;SET INITIAL HANDLER ESTABLISHER FRAME
	PUSHL	#4			;SET NUMBER OF MECHANISM ARGUMENTS
 
;
; AT THIS POINT THE STACK HAS THE FOLLOWING FORMAT:
;
;	00(SP) = NUMBER OF MECHANISM ARGUMENTS (ALWAYS 4).
;	04(SP) = FP OF HANDLER ESTABLISHER FRAME (TENTATIVE).
;	08(SP) = FRAME DEPTH (ALWAYS -3).
;	12(SP) = SAVED R0.
;	16(SP) = SAVED R1.
;	20(SP) = FLAGS LONGWORD
;	24(SP) = NUMBER OF SIGNAL ARGUMENTS.
;	28(SP) = EXCEPTION NAME (INTEGER VALUE).
;	32(SP) = FIRST EXCEPTION PARAMETER (IF ANY).
;	36(SP) = SECOND EXCEPTION PARAMETER (IF ANY).
;	      .
;	      .
;	      .
;	28+N*4(SP) = N'TH EXCEPTION PARAMETER (IF ANY).
;	28+N*4+4(SP) = EXCEPTION PC.
;	28+N*4+8(SP) = EXCEPTION PSL.
;
 
REFLECT:				;REFLECT EXCEPTION TO PROPER ACCESS MODE
	ADDL3	#6,24(SP),R0		;CALCULATE LONGWORD OFFSET TO SAVED PSL
	ASSUME	PSL$V_CM EQ 31
	TSTL	(SP)[R0]		;PREVIOUSLY IN COMPATIBILITY MODE?
	BGEQ 	10$			;BRANCH IF NOT
	MOVAL	@#CTL$AL_CMCNTX,R1	;GET ADDRESS OF COMPATIBILITY CONTEXT AREA
	MOVQ	12(SP),(R1)+		;SAVE R0 AND R1
	MOVQ	R2,(R1)+		;SAVE R2 AND R3
	MOVQ	R4,(R1)+		;SAVE R4 AND R5
	MOVL	R6,(R1)+		;SAVE R6
	MOVZBL	#8,(R1)+		;SET CM EXCEPTION TYPE
	MOVL	-4(SP)[R0],(R1)+	;SAVE PC
	MOVL	(SP)[R0],(R1)		;SAVE PSL
10$:	MOVPSL	R1			;READ CURRENT PSL
	MFPR	#PR$_IPL,R0		;READ CURRENT IPL
	CMPL	#IPL$_ASTDEL,R0		;INVALID PRIORITY LEVEL?
	BLSS	20$			;IF LSS YES
	BBC	#PSL$V_IS,R1,30$	;IF CLR, THEN NOT ON INTERRUPT STACK
20$:	BUG_CHECK INVEXCEPTN,FATAL	;INVALID EXCEPTION
30$:	IFNORD	#4,@#CTL$AL_STACK,20$	;IS THERE A CONTROL REGION?
					; (NOT SWAPPER,NULLPROC)
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R1,R0 ;EXTRACT PREVIOUS MODE FIELD
	BNEQ	35$			;IF EQL PREVIOUS MODE WAS KERNEL
	JMP	NORMAL			;
35$:	JMP	37$			;GOTO PAGED CODE
	.PSECT	YEXEPAGED1
37$:	PUSHR	#^M<R2,R3,R4>		;SAVE REGISTERS R2, R3, R4
	PUSHAB	W^NORMAL		;ASSUME INFORMATION CAN BE COPIED
	MOVL	R0,R2			;SAVE PREVIOUS MODE
	ADDL3	#7,40(SP),R3		;CALCULATE NUMBER OF LONGWORDS TO MOVE
	MFPR	R2,R1			;READ PREVIOUS MODE STACK POINTER
	BSBW	CHECK_STACK		;CHECK STACK RANGE
	BNEQ	40$			;CONTINUE IF STACK OK
	CMPL	#PSL$C_USER,R2		;IS IT USER MODE STACK FAULT?
	BNEQ	50$			;NO, THEN BAD STACK
	PUSHR	#^M<R1,R2,R3>		;SAVE REGISTERS
	MOVL	R0,R2			;GET LOWEST STACK ADDRESS FROM CHECK_STACK
	BSBW	EXE$EXPANDSTK		;AND CALL TO EXPAND STACK
	POPR	#^M<R1,R2,R3>		;RESTORE REGISTERS
	BLBC	R0,50$			;BR IF ANY ERROR TO DECLARE BAD STACK
40$:	CMPL	R1,@#CTL$AL_STACK[R2]	;TOP ADDRESS OF STACK IN RANGE?
	BGTRU	50$			;IF GTRU NO
	CMPL	#PSL$C_USER,R2		;PREVIOUS MODE USER?
	BEQL	70$			;IF EQL YES
	CMPL	R0,@#CTL$AL_STACKLIM[R2];BOTTOM ADDRESS OF STACK IN RANGE?
	BGEQU	70$			;IF GEQU YES
50$:	MOVAB	W^BADSTACK,(SP)		;SET BAD STACK RETURN
	MOVL	@#CTL$AL_STACK[R2],R1	;GET STARTING ADDRESS OF PREVIOUS MODE STACK
	BSBW	CHECK_STACK		;CHECK STACK RANGE
	BNEQ	70$			;IF NEQ SUCCESSFUL RANGE CHECK
	PUSHAL	-(R1)			;PUSH TOP ADDRESS OF STACK RANGE
	MOVAB	-1024+4(R1),-(SP)	;PUSH BOTTOM ADDRESS OF STACK RANGE
	BSBB	CRESTACK		;RE-CREATE STACK SPACE
	ADDL	#8,SP			;REMOVE VIRTUAL ADDRESS LIMITS FROM STACK
	MOVL	@#CTL$AL_STACK[R2],R1	;GET STARTING ADDRESS OF PREVIOUS MODE STACK
70$:	ASHL	#2,R3,R0		;CALCULATE NUMBER OF BYTES TO MOVE
	SUBL	R0,R1			;CALCULATE NEW TOP OF STACK ADDRESS
	MTPR	R1,R2			;SET NEW PREVIOUS MODE STACK POINTER
	BRW	COPYARGS		;

	.DSABL	LSB

;
; SUBROUTINE TO CREATE VIRTUAL SPACE WHERE THE STACK SHOULD BE. TOP
; OF STACK (UNDER THE CALL PC) IS A VA DESCRIPTOR; R2 CONTAINS ACCESS
; MODE.
;

CRESTACK:
	$SETSFM_S #0			;TURN OFF SYSTEM SERVICE EXCEPTIONS
	MOVAB	4(SP),R1		;SET ADDRESS OF VIRTUAL ADDRESS LIMITS
	PUSHL	R0			;SAVE PREVIOUS STATE OF FAILURE MODE
	$CRETVA_S (R1),(R1),R2		;CREATE STACK PAGES FOR EXCEPTION
	CMPL	(SP)+,#SS$_WASSET	;WAS SYS. SERV. FAILURE EXCEP. SET?
	BNEQ	10$			;NO
	PUSHL	R0			;YES, SAVE STATUS FROM $CRETVA
	$SETSFM_S #1			;AND SET IT AGAIN
	POPL	R0			;RESTORE STATUS FROM $CRETVA
10$:	BLBC	R0,VAFAIL		;DEAL WITH FAILURE TO CREATE STACK
	RSB
;
; TO HERE ON FAILURE TO CREATE VIRTUAL ADDRESS SPACE FOR THE BASE STACK.
; THIS ONLY OCCURRS (1) IF THE USER HAS DELETED HIS ORIGINAL STACK AND
; THEN RUN OUT HIS VIRTUAL ADDRESS SPACE, OR (2) IF THE STACK BASE AND
; LIMIT REGISTERS ARE SCROZZLED. ACTION DEPENDS ON THE ACCESS MODE OF
; THE ORIGINAL EXCEPTION: FOR USER AND SUPER MODE, WE QUIETLY DELETE
; THE PROCESS; FOR EXEC AND KERNEL MODE WE BUGCHECK NON-FATALLY AND
; FATALLY, RESPECTIVELY.
;
; NOTE: R2 CONTAINS PREVIOUS ACCESS MODE
;
VAFAIL:	CMPL	R2,#PSL$C_EXEC		;CHECK ACCESS MODE OF EXCEPTION
	BLSSU	20$			;BRANCH IF KERNEL
	BGTRU	10$			;BRANCH IF USER OR SUPER
	BUG_CHECK UNABLCREVA		;NON-FATAL FOR EXEC MODE
10$:	$DELPRC_S			;BYE, BYE
20$:	BUG_CHECK UNABLCREVA,FATAL	;FATAL FOR KERNEL MODE

	.SBTTL	SEARCH FOR AND CALL CONDITION HANDLER
;
; PUSH ARGUMENT LIST ON STACK
;
 
	.ENABL	LSB
NORMAL:					;NORMAL EXIT FROM STACK COPY
	PUSHAL	(SP)			;PUSH ADDRESS OF MECHANISM ARGUMENTS
	PUSHAL	28(SP)			;PUSH ADDRESS OF SIGNAL ARGUMENTS
	PUSHL	#2			;PUSH NUMBER OF ARGUMENTS
 
;
; CHECK THE PC OF THE EXCEPTION. IF IT IS IN THE CONDITION HANDLER CALL
; VECTOR, THEN AN EXCEPTION HAS OCCURRED ATTEMPTING TO CALL A CONDITION
; HANDLER (E.G., DUE TO BAD ADDRESS OR ENTRY MASK). IF THIS IS THE CASE,
; EXIT THE IMAGE TO AVOID AN EXCEPTION LOOP. WE DO THE SAME FOR CALLS
; TO AST ROUTINES. WHILE THIS IS NOT STRICTLY A BAD STACK, REPORTING THE
; EXCEPTION WITH THE AST CONTEXT RECORDED IN THE STACK IS SUCH A PAIN
; THAT IT IS NOT WORTH IT.  THE SPECIAL CASE OF A T-BIT PENDING EXCEPTION
; IS ALLOWED SINCE THIS CASE CANNOT RESULT IN A LOOP.
;
EXE$SRCHANDLER::			;ENTRY POINT FOR EXTERNAL USE
	MOVB	36(SP),35(SP)		;SAVE SIGNAL VECTOR LENGTH
	CMPL	40(SP),#SS$_TBIT	;CHECK FOR T-BIT PENDING EXCEPTION
	BEQL	10$			;BRANCH IF YES - SKIP CHECKS
	ADDL3	#8,36(SP),R1		;COMPUTE LONGWORD OFFSET TO SAVED PC
	CMPL	(SP)[R1],#SYS$CALL_HANDL ;COMPARE TO HANDLER CALL SITE
	BEQL	BAD_HANDLER		;BRANCH IF YES
	CMPL	(SP)[R1],#EXE$ASTDEL	;COMPARE TO AST CALL SITE
	BEQL	BAD_AST			;BRANCH IF YES

;
; SEARCH FOR CONDITION HANDLER
;
10$:	CALLG	(SP),W^SEARCH		;SEARCH FOR CONDITION HANDLER
	BLBC	R0,20$			;IF LBC FATAL ERROR
 
	BBC	#1,32(SP),11$		;BRANCH IF THIS IS NOT A STOP
	INSV	#STS$K_SEVERE,#STS$V_SEVERITY,#STS$S_SEVERITY,40(SP)
					;FOR STOP, FORCE SEVERITY TO FATAL
;
; CALL CONDITION HANDLER
;
 
11$:	JSB	@#SYS$CALL_HANDL	;CALL HANDLER VIA SYSTEM VECTOR
	BLBC	R0,10$			;IF LBC RESIGNAL
	BBS	#1,32(SP),CONT_FROM_STOP ;BRANCH IF ATTEMPTING TO CONTINUE FROM STOP
	MOVZBL	35(SP),(SP)		;GET ORIGINAL SIGNAL ARG COUNT
	ADDL	#8,(SP)			;CALCULATE LONGWORD OFFSET TO SAVED PC
	MULL	#4,(SP)			;CALCULATE NUMBER OF BYTES TO REMOVE
	MOVQ	24(SP),R0		;RESTORE R0 AND R1
	ADDL	(SP),SP			;REMOVE ARGUMENT LIST FROM STACK
	REI				;
 
;
; TO HERE ON ATTEMPT TO CONTINUE FORM A CALL TO STOP
;
CONT_FROM_STOP:				;SET FINAL STATUS AND MESSAGE
	MOVL	#<LIB$_ATTCONSTO&^CSTS$M_SEVERITY>!ATTCONSTO_IDX,R0
	CMPL	20(SP),#-3		;SEE IF JUST CALLED LAST CHANCE HANDLER
	BRB	12$			;AND FLOW INTO EXIT CODE

;
; TO HERE IF AN EXCEPTION OCCURRED ATTEMPTING TO CALL A HANDLER
;
BAD_HANDLER:
	MOVL	40(SP),R0		;SET CONDITION AS FINAL STATUS
					;SET MESSAGE STRING
	INSV	#BADHANDLER_IDX,#STS$V_SEVERITY,#STS$S_SEVERITY,R0
	CMPL	32(SP)[R1],#-3		;SEE IF TRYING TO CALL LAST CHANCE HANDLER
12$:	BNEQ	20$			;IF NOT, GO TO CALL IT
	MOVL	R0,32(SP)		;SAVE CONDITION AND MESSAGE
	BRB	30$			;IF YES, DON'T CALL IT AGAIN

;
; TO HERE IF AN EXCEPTION OCCURRED ATTEMPTING TO CALL AN AST
;
BAD_AST:
	MOVL	40(SP),R0		;SET CONDITION AS FINAL STATUS
					;SET MESSAGE STRING
	INSV	#BADAST_IDX,#STS$V_SEVERITY,#STS$S_SEVERITY,R0
	BRB	20$
;
; BAD STACK WHEN TRYING TO COPY EXCEPTION ARGUMENTS
;
 
BADSTACK:				;BAD STACK EXIT FROM STACK COPY
	PUSHAL	(SP)			;PUSH ADDRESS OF MECHANISM ARGUMENTS
	PUSHAL	28(SP)			;PUSH ADDRESS OF SIGNAL ARGUMENTS
	PUSHL	#2			;PUSH NUMBER OF ARGUMENTS
					;SET BAD STACK STATUS
	MOVZWL	#<SS$_BADSTACK&^CSTS$M_SEVERITY>!FINAL_IDX,R0

20$:	MOVL	R0,32(SP)		;SAVE FINAL STATUS AND MESSAGE
	$SETSFM_S	#0		; CLEAR SYS. SERVICE FAILURE EXCEP. MODE
	MOVPSL	R0			;READ CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R0,R0 ;EXTRACT CURRENT MODE
	MOVL	@#CTL$AL_FINALEXC[R0],R1;GET ADDRESS OF LAST CHANCE HANDLER
	BEQL	30$			;IF EQL NONE
	MNEGL	#3,20(SP)		;SET FRAME DEPTH TO MINUS THREE
	JSB	@#SYS$CALL_HANDL	;CALL LAST CHANCE CONDITION HANDLER
	BRB	35$

30$:	MOVPSL	R0			;READ CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R0,R0 ;EXTRACT CURRENT MODE
	CMPL	#PSL$C_EXEC,R0		;EXECUTIVE OR KERNEL MODE?
	BGEQU	45$			;IF GEQU YES
35$:	EXTZV	#STS$V_SEVERITY,#STS$S_SEVERITY,32(SP),R0 ;GET MESSAGE INDEX
	TSTB	@#CTL$GB_SSFILTER	;ARE SYSTEM SERVICES INHIBITED?
	BNEQ	40$			;YES, DON'T TRY TO PRINT ANYTHING
	PUSHAB	(SP)			;PUSH ADDRESS OF CONDITION ARGUMENT LIST
	PUSHL	MSG_VECTOR[R0]		;PUSH ADDRESS OF FINAL EXCEPTION MESSAGE
	CALLS	#2,EXE$EXCMSG		;PRINT FINAL EXCEPTION MESSAGE
40$:	MOVL	32(SP),R0		;RETRIEVE FINAL STATUS
	INSV	#STS$K_SEVERE,#STS$V_SEVERITY,#STS$S_SEVERITY,R0
	$EXIT_S	R0			;EXIT PROCESS

45$:	BGTRU	50$			;BRANCH IF KERNEL MODE
	BUG_CHECK FATALEXCPT		;FATAL EXECUTIVE MODE EXCEPTION
	BRB	40$			;GO DELETE THE PROCESS	

50$:	BUG_CHECK FATALEXCPT,FATAL	;FATAL KERNEL MODE EXCEPTION

	.DSABL	LSB
 
;
; COPY ARGUMENTS TO PREVIOUS MODE STACK AND EXIT TO PREVIOUS MODE
;
 
COPYARGS:				;COPY ARGUMENT LISTS TO PREVIOUS MODE STACK
	MOVAB	16(SP),R0		;GET ADDRESS OF ARGUMENTS TO COPY
10$:	MOVL	(R0)+,(R1)+		;COPY EXCEPTION ARGUMENTS TO PREVIOUS STACK
	SOBGTR	R3,10$			;ANY MORE LONGWORDS TO COPY?
	BICL	#PSL$M_CM!PSL$M_TBIT!-	;CLEAR COMPATIBILITY, T-BIT, T PENDING, AND
		PSL$M_FPD!PSL$M_TP,-(R0) ;FIRST PART DONE
	POPL	-(R0)			;SET RETURN ADDRESS
	POPR	#^M<R2,R3,R4>		;RESTORE REGISTERS R2, R3, R4
	MOVL	R0,SP			;REMOVE ARGUMENTS FROM KERNAL STACK
	REI				;
 
;
; SUBROUTINE TO CHECK ACCESSIBILITY OF STACK ADDRESS RANGE
;
; INPUTS:
;	R1 - STACK POINTER
;	R3 - PARTIAL LONGWORD COUNT
;
; OUTPUTS:
;	R0 - BOTTOM ADDRESS OF RANGE
;	Z CONDITION CODE - 0 IF ACCESSIBLE, ELSE 1	
;
;	R1,R2,R3 ARE PRESERVED.
;	
CHECK_STACK:				;CHECK STACK ADDRESS RANGE
	PUSHR	#^M<R1,R2,R3>		;SAVE REGISTERS
	ADDL3	#3+1+17,R3,R1		;CALCULATE TOTAL LONGWORDS IN RANGE
	MULL	#4,R1			;CALCULATE NUMBER OF BYTES IN RANGE
	SUBL3	R1,(SP),R0		;CALCULATE BOTTOM ADDRESS OF RANGE
	PUSHL	R0			;SAVE THIS QUANTITY
	CLRL	R3			;ACCESS MODE TO MAXIMIZE WITH PSL<PRVMOD>
	JSB	EXE$PROBEW		;CHECK WRITE ACCESS
	BITL	#1,R0			;SET CONDITION CODE
	POPR	#^M<R0,R1,R2,R3>	;RESTORE REGISTERS (NOTE: COND. CODES
					; PRESERVED
	RSB				;RETURN

	.SBTTL	SEARCH FOR CONDITION HANDLER
;
; SEARCH - SEARCH FOR CONDITION HANDLER
;
; THIS IS A SPECIAL INTERNAL ROUTINE THAT IS CALLED IN THE INITIAL SEARCH
; FOR A CONDITION HANDLER AND ON RESIGNAL FROM A PREVIOUSLY SIGNALLED
; CONDITION.
;
; INPUTS:
;
;	00(AP) = NUMBER OF CONDITION ARGUMENTS.
;	04(AP) = ADDRESS OF SIGNAL ARGUMENT LIST.
;	08(AP) = ADDRESS OF MECHANISM ARGUMENT LIST.
;	12(AP) = NUMBER OF MECHANISM ARGUMENTS.
;	16(AP) = FP OF HANDLER ESTABLISHER FRAME.
;	20(AP) = FRAME DEPTH.
;	24(AP) = SAVED R0.
;	28(AP) = SAVED R1.
;	32(AP) = FLAGS LONGWORD
;	36(AP) = NUMBER OF SIGNAL ARGUMENTS.
;	40(AP) = EXCEPTION NAME (INTEGER VALUE).
;	44(AP) = FIRST EXCEPTION PARAMETER (IF ANY).
;	48(AP) = SECOND EXCEPTION PARAMETER (IF ANY).
;	      .
;	      .
;	      .
;	40+N*4(AP) = N'TH EXCEPTION PARAMETER (IF ANY).
;	40+N*4+4(AP) = EXCEPTION PC.
;	40+N*4+8(AP) = EXCEPTION PSL.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO LOCATE CONDITION HANDLER.
;
;		R0 = SS$_ACCVIO - STACK CANNOT BE READ FROM CURRENT MODE.
;
;		R0 = SS$_NOHANDLER - NO CONDITION HANDLER COULD BE FOUND.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R1 = ADDRESS OF CONDITION HANDLER.
;
 
SEARCH:					;SEARCH FOR CONDITION HANDLER
	.WORD	0			;ENTRY MASK
	MOVAB	W^EXE$SIGTORET,(FP)	;SET ADDRESS OF CONDITION HANDLER
10$:	MOVL	16(AP),R0		;GET PREVIOUS FRAME ADDRESS
20$:	MOVPSL	R1			;READ CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1 ;EXTRACT CURRENT MODE
	INCL	20(AP)			;INCREMENT FRAME DEPTH
	BEQL	50$			;IF EQL FIRST STACK FRAME
	BGTR	40$			;IF GTR OTHER STACK FRAME
	MOVAQ	@#CTL$AQ_EXCVEC[R1],R0	;GET ADDRESS OF EXCEPTION VECTOR QUADWORD
	CMPL	#-2,20(AP)		;EXAMINE PRIMARY VECTOR?
	BEQL	30$			;IF EQL YES
	TSTL	(R0)+			;ADJUST TO SECONDARY VECTOR
30$:	MOVL	(R0),R1			;GET ADDRESS OF CONDITION HANDLER
	BNEQ	60$			;IF NEQ CONDITION HANDLER FOUND
	BRB	10$			;
40$:	BLBS	22(AP),100$		;IF LBS SEARCH COUNT OVERFLOW
45$:	MOVPSL	R1			;READ CURRENT PSL
	EXTZV	#PSL$V_CURMOD,#PSL$S_CURMOD,R1,R1 ;EXTRACT CURRENT MODE
					;RANGE CHECK FP TO MAKE SURE WE ARE IN
					;THE RIGHT STACK. THIS IS CRUCIAL, SINCE
					;THERE IS NO OTHER MECHANISM TO PREVENT
					;FOLLOWING THE FP LINKAGE INTO CALL
					;FRAMES BELONGING TO AN OUTER MODE.
	CMPL	R0,@#CTL$AL_STACK[R1]	;FRAME POINTER WITHIN STACK RANGE?
	BGTRU	100$			;IF GTRU NO
	CMPL	#PSL$C_USER,R1		;IF IN USER MODE
	BEQL	46$			;SKIP TOP RANGE CHECK
	CMPL	R0,@#CTL$AL_STACKLIM[R1];FRAME POINTER WITHIN STACK RANGE?
	BLSSU	100$			;IF LSSU NO
46$:	CMPL	#SYS$CALL_HANDL+4,SAVPC(R0) ;CALL FROM CONDITION DISPATCHER?
	BEQL	70$			;BRANCH IF YES - MUST SKIP FRAMES
	MOVL	SAVFP(R0),R0		;GET ADDRESS OF PREVIOUS FRAME
	BEQL	100$			;IF EQL NONE
48$:	MOVL	R0,16(AP)		;SAVE ADDRESS OF ESTABLISHER FRAME
50$:	MOVL	(R0),R1			;GET ADDRESS OF CONDITION HANDLER
	BEQL	10$			;IF EQL NONE
60$:	BISL	#1,R0			;INDICATE SUCCESSFUL COMPLETION
	RET				;

70$:	EXTZV	#0,#12,SAVMSK(R0),R1	;GET REGISTER SAVE MASK
	EXTZV	#14,#2,SAVMSK(R0),-(SP)	;GET STACK ALIGNMENT BIAS
	ADDL	#SAVRG,R0		;ADD OFFSET TO REGISTER SAVE AREA
	ADDL	(SP)+,R0		;ADD STACK ALIGNMENT BIAS
80$:	BLBC	R1,90$			;IF LBC CORRESPONDING REGISTER NOT SAVED
	ADDL	#4,R0			;ADJUST FOR SAVED REGISTER
90$:	ASHL	#-1,R1,R1		;ANY MORE REGISTERS SAVED?
	BNEQ	80$			;IF NEQ YES
	MOVL	CHF$L_MCHARGLST+4(R0),R1 ;GET ADDRESS OF MECHANISM ARGUMENTS
	MOVL	CHF$L_MCH_FRAME(R1),R0	;GET ADDRESS OF ESTABLISHER FRAME
	TSTL	CHF$L_MCH_DEPTH(R1)	;CHECK IF THIS IS A VECTORED HANDLER
	BLSS	48$			;IF SO, DON'T SKIP "ESTABLISHER"
	BRB	45$			;

100$:	MOVZWL	#SS$_NOHANDLER,R0	;SET NO HANDLER FOUND
	RET				;

	.SBTTL	EXE$SIGTORET - TURN EXCEPTION INTO RETURN STATUS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS IS A CONDITION HANDLER THAT TURNS AN EXCEPTION IN THE ESTABLISHER
;	FRAME INTO A RETURN FROM THE ESTABLISHER FRAME WITH THE EXCEPTION NAME
;	AS THE STATUS.  EXCEPTIONS FROM ANY FRAME OTHER THAN THE ESTABLISHER
;	ARE RESIGNALLED.  UNWINDS ARE IGNORED.
;
; INPUT PARAMETERS:
;	00(AP) = NUMBER OF CONDITION ARGUMENTS.
;	04(AP) = ADDRESS OF SIGNAL ARGUMENT LIST.
;	08(AP) = ADDRESS OF MECHANISM ARGUMENT LIST.
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;		SS$_RESIGNAL - ALWAYS
;
 
EXE$SIGTORET::
	.WORD	0

	ASSUME	CHF$L_MCHARGLST,EQ,CHF$L_SIGARGLST+4
	MOVQ	CHF$L_SIGARGLST(AP),R0	; GET ADDRESS OF SIGNAL ARGUMENT LIST
	CMPL	#SS$_UNWIND,CHF$L_SIG_NAME(R0) ; UNWINDING?
	BEQL	10$			; BRANCH TO EXIT IF YES
	TSTL	CHF$L_MCH_DEPTH(R1)	; EXCEPTION WITHIN ESTABLISHER FRAME?
	BNEQ	10$			; BRANCH AND RETURN RESIGNAL IF NO
	MOVL	CHF$L_SIG_NAME(R0),CHF$L_MCH_SAVR0(R1) ; SET RETURN STATUS
	CLRQ	-(SP)			; CLEAR DEPTH AND NEW PC ARGUMENTS
	CALLS	#2,G^SYS$UNWIND		; UNWIND TO ESTABLISHER'S CALLER
10$:	MOVZWL	#SS$_RESIGNAL,R0	; RETURN RESIGNAL STATUS
	RET				;

	.SBTTL	EXE$EXPANDSTK - EXPAND USER STACK
;++
; FUNCTIONAL DESCRIPTION:
;	EXPAND STACK IS CALLED BY EXE$ACVIOLAT,  REFLECT, AND SYS$ADJSTK
;	TO ALLOCATE MORE SPACE TO THE USER STACK.
;
; INPUT PARAMTERS:
;	R2 - VIRTUAL ADDRESS LOWER BOUND FOR STACK.
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;		SS$_NORMAL - SUCCESSFUL COMPLETION
;		SS$_VASFULL -VIRTUAL ADDRESS SPACE FULL
;		SS$_PAGOWNVIO - PAGE OWNER VIOLATION
;		SS$_EXQUOTA - PAGING FILE QUOTA EXCEEDED
;		SS$_INSFWSL - INSUFFICIENT WORKING SET SIZE
;--
EXE$EXPANDSTK::				;
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE WORKING REGISTERS
	MOVL	@#CTL$GL_PCB,R4		; GET PCB ADDRESS
	CMPL	R2,@#CTL$AL_STACK+12	; IS ADDRESS IN USER STACK?
	BGTRU	50$			; NO, DEFINITE ACCESS VIOLATION
	BBC	#VA$V_P1,R2,50$		; BR IF NOT P1 SPACE ADDRESS
	MOVL	@#CTL$GL_PHD,R5		; GET PHD ADDRESS
	JSB	MMG$PTEINDX		; GET LW INDEX TO PTE IN PHD
	BLBC	R0,20$			; BR IF JUST EXPAND REGION
	TSTL	@PCB$L_PHD(R4)[R3]	; CHECK PTE OF ACCVIO VA
	BNEQ	50$			; BR IF NOT EMPTY
10$:	INCL	R3			; NEXT PTE INDEX
	TSTL	@PCB$L_PHD(R4)[R3]	; CHECK PTE FOR EMPTY
	BNEQ	30$			; NO, STOPPER FOR CREATE
	MOVAB	512(R2),R2		; AUGMENT VA BY ANOTHER PAGE
	BRB	10$			; AND TRY ANOTHER PAGE
20$:	MOVL	PHD$L_FREP1VA(R5),R2	; SET ENDING ADDRESS TO FREP1VA
30$:	PUSHL	4(SP)			; BUILD INADR DESCRIPTOR
	PUSHL	R2			; 
	MOVAQ	-(SP),R3		; CREATE SPACE FOR RETADR
	$CRETVA_S 8(R3),(R3),#PSL$C_USER; CREATE SPACE
	BLBS	R0,40$			; BR IF SUCCESS
	PUSHL	R0			; SAVE ERROR STATUS
	$DELTVA_S (R3),8(R3),#PSL$C_USER; DELETE PARTIAL AREA
	POPL	R0			; RESTORE COMPLETION CODE
40$:	ADDL	#16,SP			; CLEAN STACK
	BRB	60$
50$:	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR STATUS
60$:	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				; AND RETURN

 

	.SBTTL	EXE$MCHK_PRTCT - MACHINE CHECK RECOVERY BLOCK
 
;++
; EXE$MCHK_PRTCT -ENABLE RECOVERY BLOCK FOR MACHINE CHECK EXCEPTIONS
;
; FUNCTIONAL DESCRIPTION:
;
;	ALLOW A SPECIFIED BLOCK OF KERNEL CODE TO PROTECT ITS SELF
;	FROM FATAL MACHINE CHECKS, THEN FIND OUT IF ONE OCCURED WITHING
;	THE EXECUTION OF THE BLOCK.
;
; INPUTS:
;
;	R0 = FUNCTION MASK TO FILTER SPECIFIC TYPES OF MACHINE CHECKS
;	(SP) = RETURN ADDRESS (START OF RECOVERY BLOCK)
;	4(SP) = END OF RECOVERY BLOCK ADDRESS
;	MUST BE IN KERNEL MODE
;	CODE IN RECOVERY BLOCK EXECUTES AT IPL 31
;
; OUTPUTS:
;
;	WHEN INSTRUCTION AFTER END OF RECOVERY BLOCK IS REACHED,
;		R0 = 0 IF MACHINE CHECK OCCURRED
;		R1 = 1 IF MACHINE CHECK DID NOT OCCUR
;	ALL OTHER REGISTERS PRESERVED
;
; CALLING SEQUENCE:
;
;	PUSHAL	END_LABEL		; LABEL, END OF RECOVERY BLOCK ON STACK
;	MOVL	#MASK,R0		; FUNCTION FILTER MASK
;	JSB	EXE$MCHK_PRTCT		; INITIATE RECOVERY BLOCK
;		.			; PROTECTED CODE, EXECUTED AT IPL 31
;		.
;		.
;	RSB				; END OF RECOVERY BLOCK RETURN
; END_LABEL:				; END OF RECOVERY BLOCK LABEL
;	BLBS	R0,MCHK_OK		; IF LBS, NO MACHINE CHECK OCCURED
;	BRW	MCHK_ERROR		; ELSE, CODE FAULTED
;--
 
	.PSECT	$AEXENONPAGED,LONG
 
EXE$MCHK_PRTCT::
 
	MOVQ	W^MCHK$GL_MASK,-(SP)	; SAVE PREVIOUS MASK AND SP - RECURSIVE
					; SO MACHINE CHECK HANDLER CAN USE PRTCT
	DSBINT				; GO TO IPL 31 FOR REMAINDER OF BLOCK
	MOVL	R0,W^MCHK$GL_MASK	; CURRENT FUNCTION MASK
	MOVL	SP,W^MCHK$GL_SP		; SAVE CURRENT SP FOR POTENTIAL RECOVERY
	JSB	@<3*4>(SP)		; CALL PROTECTED CODE BACK
 
; IF PROTECTED CODE EXECUTED WITHOUT A MACHINE CHECK, IT RETURNS HERE
 
	MOVZWL	#SS$_NORMAL,R0		; NORMAL COMPLETION, NO MACHINE CHECK
 
; RESTORE MASK AND SP OF OLD, FINAL RETURN TO CALLER
 
PROTECT_RETURN:				; COMMON RETURN TO END OF RECOVERY BLOCK
 
	MOVQ	<1*4>(SP),W^MCHK$GL_MASK ; RESTORE PREVIOUS MASK AND SP
	ENBINT				; BACK TO ORIGONAL IPL
	ADDL	#<3*4>,SP		; CLEAN UP STACK
	RSB				; FINAL RETURN TO CALLER AT END OF
					; RECOVERY BLOCK LABEL

;++
;
; EXE$MCHK_BUGCHK - HANDLE ALL BUGCHECKS FOR WHICH PROTECTION IS DESIRED
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS REOUTINE IS CALLED FROM WITHIN MACHINE CHECK HANDLER JUST
;	BEFORE ISSUING A FATAL BUG-CHECK.  IF A CURRENT PROTECTION BLOCK
;	IS IN EFFECT, A RETURN IS MADE AT THE END OF RECOVERY BLOCK LABEL
;	AFTER PROTECTED CODE.  ELSE, IF NO PROTECTION BLOCK IN EFFECT, RETURN
;	TO MAHCINE CHECK WHICH ISSUES THE FATAL BUG-CHECK.
;
; INPUTS:
;
;	(SP) = RETURN ADDRESS TO MACHINE CHECK
;	4(SP) = ADDRESS OF MACHINE CHECK PC,PSL FROM EXCEPTION
;	8(SP) = FUNCTION FILTER MASK BUILT BY MACHINE CHECK, DESCRIBES THE
;		TYPE OF MACHINE CHECK FOR TESTING AGIANST MASK SPECIFIED BY
;		PROTECTED CODE.
;
; OUTPUTS:
;
;	IF NO RECOVERY BLOCK IN EFFECT:
;
;		PC,PSL POINTER AND MASK REMOVED FROM STACK
;		RSB BACK TO MACHINE CHECK
;		ALL REGISTERS PRESERVED
;
;	IF RECOVERY BLOCK IN EFFECT:
;
;		MODE, IPL, STACK SET TO THAT IN EFFECT WHEN RECOVERY BLOCK
;			DECLARED.
;		R0 - CODE INDICATING MACHINE CHECK OCCURED
;		RETURN TO END OF RECOVERY BLOCK LABEL
;		ALL OTHER REGISTERS PRESERVED
;
;--
 
EXE$MCHK_BUGCHK::
 
	PUSHR	#^M<R0,R1,R2>		; SAVE SOME REGISTERS
	MOVQ	<4*4>(SP),R1		; GET PC,PSL POINTER AND MASK
	BSBB	MCHK_TEST		; CURRENTLY A RECOVERY BLOCK?
	BLBS	R0,15$			; BRANCH IF YES
10$:	POPR	#^M<R0,R1,R2>		; NO RECOVERY BLOCK, RESTORE REGS
	MOVL	(SP)+,4(SP)		; MOVE RETURN ADDRESS UP ON STACK
	ADDL	#<4*1>,SP		; CLEAR STACK OF MASK
	RSB				; RETURN TO MACHINE CHECK HANDLER
 
15$:	BICB	#MCHK$M_LOG,R2		; IGNORE LOG INHIBIT BIT
	BITL	R2,W^MCHK$GL_MASK	; PROTECTION DESIRED HERE?
	BEQL	10$			; NO, RETURN TO MACHINE CHECK
	POPR	#^M<R0,R1,R2>		; RESTORE REGISTERS
	MOVL	4(SP),SP		; RESET STACK TO INTERRUPT PC,PSL
	MOVAL	W^20$,(SP)		; REI BACK HERE INSTEAD
	REI				; BACK TO PROTECTED CODES' MODE, ETC.
20$:	MOVZWL	#SS$_MCHECK,R0		; ERROR CODE IN R0
	MOVL	W^MCHK$GL_SP,SP		; RESET STACK FOR RETURN
	BRB	PROTECT_RETURN		; RETURN TO END OF PROTECTED CODE

;++
; MCHK_TEST - TEST TO SEE IF RECOVERY BLCOK ENABLED AT TIME OF MACHINE CHECK
;
; INPUTS:
;
;	R1 - POINTER TO PC,PSL OF MACHINE CHECK EXCEPTION
;
; OUTPUTS:
;
;	R0 - .TRUE. IF RECOVERY BLOCK CURRENTLY IN EFFECT
;	     .FALSE. IF NO RECOVERY BLOCK
;	ALL OTHER REGISTERS PRESERVED
;
;--
 
MCHK_TEST:
 
	CLRL	R0			; ASSUME NO RECOVERY BLOCK
	TSTL	W^MCHK$GL_SP		; IF SP NOT ZERO, THEN RECOVERY BLCOK
	BEQL	40$
	INCL	R0			; SET LOW BIT, INDICATING RECOVERY BLOCK
40$:
	RSB				; RETURN

;++
;
; EXE$MCHK$_TEST - TEST RECOVERY BLOCK FOR MASK MATCH
;
; FUNCTIONAL DESCRIPTION:
;
;	TEST TO SEE IF MACHINE CHECK RECOVERY BLOCK EXEISTS WHEN MACHINE
;	CHECK EXCEPTION OCCURRED.  IF SO, CHECK TO SEE IF FUNCTION MASK
;	BITS MATCH.
;
; INPUTS:
;
;	R1 - POINTS TO PC,PSL PAIR ON STACK FROM MACHINE CHECK
;	R2 - CONTAINS BITS TO TEST AGAINST MASK SPECIFIED BY PROTECTED CODE
;
; OUTPUTS:
;
;	R0 - .TRUE. IF RECOVERY BLOCK IN EFFECT AND MASKS MATCH
;	     .FALSE. IF NEITHER RECOVERY BLOCK OR MASK MATCH
;	R2 - DESTROYED
;	ALL OTHER REGISTERS PRESERVED
;
;--
 
EXE$MCHK_TEST::
 
	BSBB	MCHK_TEST		; RECOVERY BLOCK IN EFFECT HERE?
	BLBC	R0,50$			; NO, RETURN WITH R0 CLEAR
 
	ASSUME	MCHK$M_LOG EQ 1
 
	BLBS	R2,60$			; HANDLE LOG BIT SEPARATELY
45$:	BITL	R2,W^MCHK$GL_MASK	; MASKS MATCH?
	BNEQ	50$			; YES
47$:	CLRL	R0			; NO, R0 = .FALSE.
50$:	RSB				; RETURN
 
60$:	BLBC	W^MCHK$GL_MASK,47$	; ERROR LOG NOT DISABLED
	DECL	R2			; WANT TO DISABLE LOGGING, CHECK REST
					; OF MASK FOR ERROR TYPE
	BRB	45$
 
	.END
