	.TITLE	IOSUBPAGD - PAGED I/O RELATED SUBROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 13-JUN-76
;
; PAGED I/O RELATED SUBROUTINES
;
;
; MODIFIED BY:
;
;	V02-020	ACG0267		Andrew C. Goldstein,	17-Feb-1982  20:46
;		Fix register usage in PCB reference in SEARCHUNIT
;
;	V02-019	SRB41845	Steve Beckhardt		13-Jan-1981
;		Changed IOC$CREATE_UCB to store the master PID in the
;		creator PID field instead of the process PID.  This fixes a bug
;		that caused quota to be lost when deleting a temporary mailbox
;		created by a subprocess.
;
;	V02-018	ACG0250		Andrew C. Goldstein,	29-Dec-1981  20:37
;		Add IOC$SEARCHALC to search for allocated devices
;
;	V02-017	PHL0026		Peter H. Lipman		2-Dec-1981
;		Add an ASSUME to IOC$SEARCHDEV to make sure that the
;		maximum logical name length can be probed in one probe.
;
;	V02-016	PHL0020		Peter H. Lipman		28-Oct-1981
;		Upcase logical device names and device names in
;		IOC$SEARCHDEV and IOC$SEARCHGEN
;
;		Alternate success code for concealed device name
;		for $GETDVI.
;
;	V02-015	PHL0016		Peter H. Lipman		13-Sep-1981
;		IOC$SEARCHDEV must return SS$_IVLOGNAM if the device
;		name string length is illegal.
;
;		Implement hidden devices, "__" prefix, by stripping
;		up to two underscores.
;
;	V02-014	LMK0003		Len Kawell		05-Sep-1981
;		Fix bugs in new IOC$SEARCHDEV.
;
;	V02-013	PHL0014		Peter H. Lipman		29-Aug-1981
;		Fix bug in new IOC$SEARCHDEV logic which fails to strip "_"
;		off a logical name which has the RMS IFI data on the front.
;
;	V02-012	PHL0014		Peter H. Lipman		29-Aug-1981
;		IOC$SEARCHDEV logic for translating names was rewritten.
;		It now allows logical names with a trailing ":" to get
;		translated properly.  It will handle a result string with
;		RMS IFI data imbedded.  It is all ready to enable a
;		translate loop instead of the single level translation,
;		but for now it does only one iteration.
;
;	V02-011	STJ0053		Steven T. Jeffreys	29-June-1981
;		Removed IOC$CVT_DEVNAM and placed it in IOSUBNPAG.
;		The routine has been made nonpagable, and the call
;		interface has changed slightly.
;
;	V02-010	RLR0001		Robert L. Rappaport	16-June-1981
;		Inverted intructions that link UCB into chain in
;		IOC$CREATE_UCB.
;
;	V02-009	KTA0014		Kerbey T. Altmann	10-APr-1981
;		Modified IOC$FFCHAN to include CCB address in R2.
;
;	V02-008	KTA0010		Kerbey T. Altmann	03-Mar-1981
;		Change Find-First-Channel to set the 'high water'
;		mark for all channels.  This will be used by SYSRUNDWN.
;		Also change the test in VERIFYCHAN to match.
;
;	V02-007	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to use CTL$GL_PCB instead.
;
;	V02-006	MLG0001		Matthew L. Goldworm,	2-Dec-1980
;		Prevent crash caused when IOC$VERIFYCHAN is called with 
;		junk in high-order R0
;
;	V02-005	STJ0004		Steven Jeffreys		2-Sep-1980
;		Add SS$_NODEVAVL message to IOC$SEARCHGEN to indicate
;		that the generic device type exists but no drives are
;		available.
;
;
; MACRO LIBRARY CALLS
;
 
	$ACBDEF				;DEFINE AST CONTROL BLOCK
	$CCBDEF				;DEFINE CCB OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$IPLDEF				;DEFINE IPL LEVELS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$UCBDEF				;DEFINE UCB OFFSETS
 
;
; LOCAL SYMBOLS
;
; CHARACTER DEFINITIONS
;
 
COLON=58				;COLON
NINE=57					;DIGIT 9
UCA=65					;UPPER CASE A
UCZ=100					;UPPER CASE Z
UNDERSCORE=95				;UNDERSCORE
ZERO=48					;DIGIT 0
ESCAPE=27				;ASCII ESCAPE CHARACTER
 
	.PSECT	Y$EXEPAGED
	.PAGE
	.SBTTL	CREATE MAILBOX OR NETWORK UCB
;+
; IOC$CREATE_UCB - CREATE MAILBOX OR NETWORK UCB
;
; THIS ROUTINE IS CALLED TO CREATE A MAILBOX OR NETWORK UCB AND LINK IT INTO
; THE I/O DATABASE.
;
; INPUTS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ADDRESS OF CLONE UCB.
;
;	I/O DATABASE IS LOCKED FOR WRITE ACCESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO ALLOCATE UCB.
;
;		R0 = SS$_INSFMEM - INSUFFICIENT MEMORY TO ALLOCATE MAILBOX
;			OR NETWORK UCB.
;
;	R0 LOW BIT SUCCESS INDICATES SUCCESSFUL CREATION.
;
;		R2 = ADDRESS OF ALLOCATED UCB.
;
;	CONTROL IS RETURNED WITH I/O DATABASE STILL LOCKED FOR WRITE ACCESS.
;-
 
IOC$CREATE_UCB::			;CREATE MAILBOX OR NETWORK UCB
	MOVZWL	UCB$W_SIZE(R5),R1	;GET SIZE OF BLOCK TO ALLOCATE
	BSBW	EXE$ALONONPAGED		;ALLOCATE BLOCK FROM NONPAGED MEMORY
	BLBC	R0,40$			;IF LBC ALLOCATION FAILURE
	PUSHR	#^M<R2,R4,R5>		;SAVE REGISTERS
	MOVC	R1,(R5),(R2)		;COPY CLONE UCB TO NEW UCB
	POPR	#^M<R2,R4,R5>		;RESTORE REGISTERS
	MOVL	R2,UCB$L_FQFL(R2)	;SET MESSAGE/REQUEST QUEUE FORWARD LINK
	MOVL	R2,UCB$L_FQBL(R2)	;SET MESSAGE/REQUEST QUEUE BACKWARD LINK
	CLRQ	UCB$L_ASTQFL(R2)	;CLEAR AST QUEUE LISTHEAD/STATE AND NODENAME
	CLRQ	UCB$W_MSGMAX(R2)	;CLEAR MESSAGE COUNTS/CONNECT NUMBERS
	MOVL	PCB$L_UIC(R4),UCB$L_OWNUIC(R2) ;INSERT CREATOR UIC
	MOVAB	UCB$L_IOQFL(R2),UCB$L_IOQFL(R2) ;SET I/O QUEUE FORWARD LINK
	MOVAB	UCB$L_IOQFL(R2),UCB$L_IOQBL(R2) ;SET I/O QUEUE BACKWARD LINK
	MOVW	#1,UCB$W_REFC(R2)	;SET INITIAL REFERENCE COUNT
	MOVW	#UCB$M_ONLINE,UCB$W_STS(R2) ;SET INITIAL DEVICE INDEPENDENT STATUS
	CLRW	UCB$W_DEVSTS(R2)	;CLEAR INITIAL DEVICE DEPENDENT STATUS
	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	MOVL	JIB$L_MPID(R0),UCB$L_CPID(R2) ;STORE MASTER PID AS CREATOR
	CLRL	UCB$L_OPCNT(R2)		;CLEAR COUNT OF OPERATIONS COMPLETED
	CLRQ	UCB$L_SVAPTE(R2)	;CLEAR PTE ADDRESS, BYTE OFFSET, AND COUNT
10$:	INCW	UCB$W_MB_SEED(R5)	;INCREMENT MAILBOX/NETWORK UCB SEED
	MOVZWL	UCB$W_MB_SEED(R5),R0	;GET CURRENT MAILBOX/NETWORK SEED
	MOVL	UCB$L_DDB(R5),R1	;GET ADDRESS OF MAILBOX/NETWORK DDB
	MOVAB	DDB$L_UCB-UCB$L_LINK(R1),R1 ;SET TO START AT FIRST UCB
20$:	MOVL	R1,R3			;SAVE ADDRESS OF PREVIOUS UCB
	MOVL	UCB$L_LINK(R3),R1	;GET ADDRESS OF NEXT UCB
	BEQL	30$			;IF EQL NONE
	CMPW	R0,UCB$W_UNIT(R1)	;UNIT NUMBER MATCH?
	BEQL	10$			;IF EQL YES
	BGTRU	20$			;IF GTRU CONTINUE SCAN
30$:	MOVW	R0,UCB$W_UNIT(R2)	;INSERT MAILBOX/NETWORK UNIT NUMBER
	MOVL	R1,UCB$L_LINK(R2)	;SET LINK TO NEXT UCB IN NEW UCB
	MOVL	R2,UCB$L_LINK(R3)	;SET LINK TO NEW UCB IN PREVIOUS UCB
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF MAILBOX/NETWORK CRB
	INCW	CRB$W_REFC(R0)		;UPDATE MAILBOX/NETWORK CRB REFERENCE COUNT
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	RSB				;
40$:	MOVZWL	#SS$_INSFMEM,R0		;SET INSUFFICIENT MEMORY STATUS
	RSB				;
	.PAGE
	.SBTTL	FIND FREE I/O CHANNEL
;+
; IOC$FFCHAN - FIND FREE I/O CHANNEL
;
; THIS ROUTINE IS CALLED TO SEARCH THE I/O CHANNEL TABLE FOR A FREE CHANNEL.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO FIND FREE I/O CHANNEL.
;
;		R0 = SS$_NOIOCHAN - NO I/O CHANNEL AVAILABLE.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R1 = AVAILABLE CHANNEL NUMBER.
;		R2 = CCB ADDRESS FOR CHANNEL IN R1
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
IOC$FFCHAN::				;FIND FREE I/O CHANNEL
	ADDL3	@#CTL$GL_CCBBASE,-
		#CCB$B_AMOD,R0		;BASE AND OFFSET TO TEST ASSIGNMENT
	MNEGL	#CCB$C_LENGTH,R1	;SET STARTING CHANNEL INDEX
	MOVZWL	@#CTL$GW_NMIOCH,R2	;GET NUMBER OF I/O CHANNELS
	BEQL	15$			;THERE ARE NONE
10$:	TSTB	(R0)[R1] 		;CHANNEL ASSIGNED?
	BEQL	20$			;IF EQL NO
	SUBL	#CCB$C_LENGTH,R1	;CALCULATE NEXT CHANNEL INDEX
	SOBGTR	R2,10$			;ANY MORE CCB'S TO EXAMINE?
15$:	MOVZWL	#SS$_NOIOCHAN,R0	;INDICATE FAILURE
	RSB				;

20$:	MNEGL	R1,R2			;CONVERT TO POSITIVE VALUE
	CMPW	R2,@#CTL$GW_CHINDX	;CHECK AGAINST CURRENT HI-WATER MARK
	BLSSU	30$			;NO, JUST LEAVE
	MOVW	R2,@#CTL$GW_CHINDX	;YES, SET NEW MARK
30$:	MOVAB	-CCB$B_AMOD(R0)[R1],R2	;LOAD R2 WITH CCB ADDRESS
	MNEGL	R1,R1			;MAKE POSITIVE (*TEMP*)
	MOVZWL	#SS$_NORMAL,R0		;INDICATE SUCCESS
	RSB				;
	.PAGE
	.SBTTL	SEARCH FOR DEVICE
;+
; IOC$SEARCHDEV - SEARCH FOR PHYSICAL DEVICE
; IOC$SEARCHGEN - SEARCH FOR GENERIC DEVICE
; IOC$SEARCHALC - SEARCH FOR GENERIC POSSIBLY ALLOCATED DEVICE
;
; THIS ROUTINE IS CALLED TO SEARCH THE DEVICE DATA BASE FOR A SPECIFIED
; DEVICE. IT IS ASSUMED THAT THE DEVICE DATA BASE HAS BEEN LOCKED FOR
; READ ACCESS.
;
; INPUTS:
;
;	R1 = ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
;	     ***** THIS STRING HAS NOT YET BEEN PROBED,
;	     ***** BUT THE DESCRIPTOR HAS BEEN.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO FIND DEVICE.
;
;		R0 = SS$_IVDEVNAM - INVALID DEVICE NAME.
;		R0 = SS$_NONLOCAL - NONLOCAL DEVICE.
;		R0 = SS$_NOSUCHDEV - NO SUCH DEVICE.
;		R0 - SS$_NODEVAVL - DEVICE EXISTS BUT IS NOT AVAILABLE
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION STATUS
;		R0 = SS$_CONCEALED - DEVICE NAME WAS A CONCEALED DEVICE
;			NAME, IT BEGAN WITH TWO UNDERSCORES.
;
;		R1 = UCB ADDRESS OF DEVICE UNIT.
;-
 
	.ENABL	LSB
IOC$SEARCHGEN::				;SEARCH FOR GENERIC DEVICE
	MOVL	#1,R2			;INDICATE GENERIC DEVICE SEARCH
	BRB	10$			;
IOC$SEARCHALC::				;SEARCH FOR GENERIC DEVICE
	MOVL	#5,R2			;INDICATE GENERIC DEVICE SEARCH
	BRB	10$			;ALLOWING ALLOCATION BY SEARCHER
IOC$SEARCHDEV::				;SEARCH FOR PHYSICAL DEVICE
	MOVL	#2,R2			;INDICATE PHYSICAL DEVICE SEARCH
10$:	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10> ;SAVE REGISTERS
	MOVAB	-LOG$C_NAMLENGTH(SP),SP	;ALLOCATE SPACE FOR RESULT STRING
	MOVL	#10,R8			;MAXIMUM NUMBER OF ITERATIONS
					;TO TAKE THROUGH TRNLOG
	MOVL	#SS$_NORMAL,R9		;INITIALIZE STATUS FROM 
					;PREVIOUS (NON-EXISTENT) TRNLOG
	MOVL	#SS$_NORMAL,R10		;ASSUME SUCCESS RETURN STATUS
					;NOT A CONCEALED DEVICE NAME
	MOVZWL	(R1),R4			;GET LENGTH OF DEVICE/LOGICAL NAME
	BEQL	20$			;IF EQL INVALID NAME
	CMPW	R4,#LOG$C_NAMLENGTH-1	;NAME TOO LONG?
	BGTRU	20$			;IF GTRU YES
	MOVL	4(R1),R5		;GET ADDRESS OF DEVICE/LOGICAL NAME

	ASSUME	LOG$C_NAMLENGTH-1 LE 512 ;OK TO USE SINGLE PROBE
	IFRD	R4,(R5),110$		;CHECK NAME ACCESS AND
					;MAKE THE TESTS BEFORE THE 1ST TRNLOG

	MOVZWL	S^#SS$_ACCVIO,R0	;SET FAILURE
	BRB	40$			;
20$:	MOVZWL	#SS$_IVLOGNAM,R0	;INVALID LOGICAL NAME
40$:	BRW	330$
60$:	BRW	270$			;INVALID DEVICE NAME

;
; TRY TO TRANSLATE A LOGICAL NAME
; FIRST CONVERT LOWER CASE a - z TO UPPER CASE
; MUST MOVE THE STRING TO THE STORAGE ON THE STACK IN THE CASE THAT
; THE STRING DESCRIBED BY R4,R5 WAS THE ORIGINAL INPUT PARAMETER STRING
;
; R4 = SIZE OF NAME STRING
; R5 = ADDRESS OF NAME STRING
; SP = ADDRESS OF RESULT NAME BUFFER (LOG$C_NAMLENGTH BYTES)
; SP+NAM$C_NAMLENGTH+8 = SAVED R4 = PCB ADDRESS
;

70$:	MOVL	SP,R2			;ADDRESS TO MOVE UPCASED STRING TO
	MOVL	R4,R1			;NUMBER OF BYTES TO MOVE AND UPCASE
80$:	MOVB	(R5),(R2)+		;MOVE THE NEXT CHARACTER
	CMPB	(R5)+,#^A/a/		;IF GEQU THEN LOWER CASE A
	BLSSU	90$
	CMPB	-1(R5),#^A/z/		;AND LEQU LOWER CASE Z
	BGTRU	90$
	SUBB	#32,-1(R2)		;CONVERT TO UPPER CASE
90$:	SOBGTR	R1,80$			;LOOP THROUGH THE WHOLE STRING
	MOVL	SP,R3			;ADDRESS OF RESULT NAME BUFFER
	MOVZBL	#LOG$C_NAMLENGTH,R2	;SIZE OF RESULT NAME BUFFER
	MOVL	SP,R1			;ADDRESS OF LOGICAL NAME
	MOVL	R4,R0			;SIZE OF LOGICAL NAME
	MOVL	<LOG$C_NAMLENGTH+8>(R3),R4  ;RECOVER SAVED R4 = PCB ADDRESS
	CLRL	R5			;SET TO SEARCH ALL NAME TABLES
	BSBW	LOG$TRANSLATE		;TRANSLATE LOGICAL NAME STRING
	BLBC	R0,40$			;IF LBC RESULT STRING TOO LARGE
	MOVL	R0,R9			;SAVE STATUS FOR LATER "NOTRAN" CHECK
	MOVL	R1,R4			;SAVE LENGTH OF RESULT STRING IN BYTES
	BEQL	60$			;IF EQL INVALID DEVICE NAME
	MOVL	SP,R5			;SAVE ADDRESS OF RESULTANT STRING

110$:	CMPB	#ESCAPE,(R5)		;RMS IFI ON THE FRONT?
	BNEQ	120$			;BRANCH IF NOT
	ADDL	#4,R5			;SKIP AROUND THE PPF DATA
	SUBL	#4,R4			;AND ADJUST SIZE OF DEVICE STRING
	BLEQ	60$			;BRANCH IF BAD DEVICE NAME

;
; TAKE 1 OR 2 UNDERSCORES OFF THE FRONT.  IF ANY ARE REMOVED, THEN
; THE DEVICE THAT FOLLOWS MUST NOT BE TRANSLATED ANY FURTHER.  NOTE
; THAT THE DEVICE AFTER THE RMS PROCESS PERMANENT FILE DATA MAY BE
; A LOGICAL DEVICE NAME.
;

120$:	CLRL	R0			;INIT "UNDERSCORES STRIPPED" FLAG
140$:	CMPB	#UNDERSCORE,(R5)	;LEADING UNDERSCORE?
	BNEQ	150$			;BRANCH IF NOT
	INCL	R5			;STRIP IT OFF
	DECL	R4			;AND ADJUST THE COUNT
	BLEQ	60$			;BRANCH IF BAD DEVICE NAME
	BBCS	#0,R0,140$		;ONE MORE TRY IF THIS IS NOT THE 2ND
	MOVZWL	#SS$_CONCEALED,R10	;TWO UNDERSCORES REMOVED, CONCEALED DEVICE
150$:	BLBS	R0,200$			;IF ANY STRIPPED, THEN PHYSICAL DEVICE
 
;
; AT THIS POINT R4,R5 DESCRIBE A STRING WHICH IS EITHER THE INITIAL
; STRING PASSED TO THIS ROUTINE OR A TRANSLATION OF IT.  IF THE STRING
; HAD ONE OR TWO LEADING UNDERSCORES, THIS PATH IS NOT EXECUTED.
; A CHECK WILL NOW BE MADE TO SEE IF THIS STRING
; CONTAINS A "::" AND IS THUS A NODENAME.  IF NOT, THE STRING UP TO
; BUT NOT INCLUDING THE ":" (IF PRESENT) WILL BE A CANDIDATE FOR 
; TRANSLATION.  THIS TRANSLATION WILL BE ATTEMPTED IF THE RESULT
; OF A PREVIOUS TRANSLATION WAS NOT SS$_NOTRAN AND IF THE ITERATION
; COUNTER HAS NOT EXPIRED.
;

	LOCC	#^A/:/,R4,(R5)		;SEARCH STRING FOR A COLON
	BEQL	180$			;IF EQL COLON NOT FOUND
	DECL	R0			;POSSIBLY A NODE NAME?
	BEQL	170$			;IF EQL NO
	CMPB	#^A/:/,1(R1)		;NEXT CHARACTER A COLON?
	BEQL	250$			;IF EQL YES
170$:	SUBL3	R5,R1,R4		;SIZE OF STRING UP TO COLON
180$:	CMPW	#SS$_NOTRAN,R9		;LAST TRANSLATION GAVE "NOTRAN"?
	BEQL	200$			;BRANCH IF YES, DON'T DO ANOTHER
	DECL	R8			;ITERATION COUNT EXHAUSTED?
					;N+1 ITERATIONS FOR N TRNLOG'S
	BLSS	200$			;BRANCH IF YES
	BRW	70$			;NO, TRY ANOTHER TRANSLATION

200$:	MOVQ	R4,R0			;COPY DEVICE NAME PARAMETERS
	MOVL	SP,R5			;DEV/CONTROLLER NAME IN SCRATCH BUF
220$:	MOVZBL	(R1),R2			;GET NEXT CHARACTER
	BBC	#6,R2,230$		;BR IF CODE 0-^X3F - MUST BE NUMERIC
	BICB	#^X20,R2		;COLLAPSE LOWER CASE TO UPPER CASE
					;NON-ALPHABETICS ARE ILLEGAL IN BOTH COLUMNS
	CMPB	R2,#^A/Z/		;POSSIBLE ALPHABETIC?
	BGTRU	270$			;BR IF NOT
	CMPB	R2,#^A/A/		;POSSIBLE ALPHABETIC?
	BLSSU	270$			;BR IF NOT
	INCL	R1			;POINT TO NEXT CHARACTER
	MOVB	R2,(R5)+		;STORE IN SCRATCH STORAGE
	SOBGTR	R0,220$			;ANY MORE CHARACTERS TO SCAN?
230$:	CLRL	R6			;CLEAR UNIT NUMBER
	MOVL	SP,R5			;ADDRESS OF DEVICE/CONTROLLER NAME
	SUBL	R0,R4			;LENGTH OF DEVICE/CONTROLLER NAME
	BEQL	270$			;IF EQL NO DEVICE NAME SPECIFIED
240$:	DECL	R0			;ANY MORE CHARACTERS IN STRING?
	BLSS	280$			;IF LSS NO
	MOVZBL	(R1)+,R2		;GET NEXT CHARACTER
	CMPB	#COLON,R2		;DEVICE NAME TERMINATOR?
	BEQL	280$			;IF EQL YES
	BISL	#2,LOG$C_NAMLENGTH(SP)	;SET EXPLICIT UNIT NUMBER FLAG
	SUBB	#ZERO,R2		;POSSIBLY A DECIMAL DIGIT?
	BLSS	270$			;IF LSS NO
	CMPB	#NINE-ZERO,R2		;DECIMAL DIGIT?
	BLSS	270$			;IF LSS NO
	MULW	#5,R6			;SCALE CURRENT UNIT NUMBER BY 10
					; IN TWO STEPS, FOR OVERFLOW CHECK
	BVS	270$			;IF VS OVERFLOW - NUMBER TOO BIG
	ADDW	R6,R6			;SECOND STEP OF SCALE BY 10
	ADDL	R2,R6			;ADD NEW DIGIT TO ACCUMULATION
	BRB	240$			;
 
;
; NONLOCAL DEVICE
;
 
250$:	MOVZWL	#SS$_NONLOCAL,R0	;SET NONLOCAL DEVICE
260$:	BRB	330$			;
 
;
; INVALID DEVICE NAME
;
 
270$:	MOVZWL	#SS$_IVDEVNAM,R0	;SET INVALID DEVICE NAME
	BRB	330$

;
; SEARCH DEVICE DATA BASE FOR NAME/UNIT MATCH
;
 
280$:	MOVL	#1,R7			;SET DEVICE NAME LENGTH ADJUSTMENT VALUE
	MOVZWL	#SS$_NOSUCHDEV,R9	;ASSUME NO SUCH DEVICE
	MOVAL	L^IOC$GL_DEVLIST-DDB$L_LINK,R8 ;GET ADDRESS OF I/O DATABASE LISTHEAD
290$:	BSBB	SEARCHDEV		;SEARCH FOR DEVICE NAME MATCH
	BNEQ	310$			;IF NEQ MATCH NOT FOUND
	BLBS	LOG$C_NAMLENGTH(SP),300$	;IF LBS GENERIC DEVICE NAME SEARCH
	CMPB	#^A/A/,DDB$T_NAME+1(R8)[R4] ;CONTROLLER 'A'?
	BNEQ	290$			;IF NEQ NO
300$:	BSBB	SEARCHUNIT		;SEARCH FOR UNIT NUMBER MATCH
	BLBS	R9,320$			;BR IF UNIT NUMBER MATCH FOUND
	BLBS	LOG$C_NAMLENGTH(SP),290$	;IF LBS GENERIC DEVICE NAME SEARCH
310$:	CLRL	R7			;CLEAR DEVICE NAME LENGTH ADJUSTMENT VALUE
	MOVAL	L^IOC$GL_DEVLIST-DDB$L_LINK,R8 ;GET ADDRESS OF I/O DATABASE LISTHEAD
	BSBB	SEARCHDEV		;SEARCH FOR DEVICE NAME MATCH
	BNEQ	320$			;IF NEQ MATCH NOT FOUND
	BSBB	SEARCHUNIT		;SEARCH FOR UNIT NUMBER MATCH
320$:	MOVL	R9,R0			;SET STATUS IN R0
330$:	MOVAB	LOG$C_NAMLENGTH(SP),SP	;REMOVE DEVICE NAME STRING FROM STACK
	BLBC	R0,340$			;IF COMPLETED SUCCESSFULLY,
	MOVL	R10,R0			;USE CONCEALED/NORMAL SUCCESS STATU
340$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10> ;RESTORE REGISTERS
	RSB				;
	.DSABL	LSB
 
;
; SUBROUTINE TO SEARCH FOR DEVICE NAME MATCH
;
 
SEARCHDEV:				;SEARCH FOR DEVICE NAME
10$:	MOVL	DDB$L_LINK(R8),R8	;GET ADDRESS OF NEXT DDB
	BEQL	20$			;IF EQL END OF LIST
	MOVAL	DDB$T_NAME(R8),R0	;GET ADDRESS OF GENERIC DEVICE NAME
	SUBB3	R7,(R0)+,R1		;CALCULATE LENGTH OF STRING TO COMPARE
	CMPB	R1,R4			;LENGTH OF NAMES MATCH?
	BNEQ	10$			;IF NEQ NO
	CMPC	R4,(R0),(R5)		;COMPARE DEVICE NAMES
	BNEQ	10$			;IF NEQ NAMES DO NOT MATCH
	RSB				;
20$:	INCL	R8			;INDICATE SEARCH FAILURE
	RSB				;
 
;
; SUBROUTINE TO SEARCH FOR UNIT NUMBER MATCH
;
 
SEARCHUNIT:				;SEARCH FOR UNIT NUMBER
	MOVL	G^CTL$GL_PCB,R3		;GET PCB ADDRESS
	MOVZWL	#SS$_NOSUCHDEV,R9	;ASSUME NO SUCH DEVICE
	MOVAL	DDB$L_UCB-UCB$L_LINK(R8),R1 ;GET ADDRESS OF NEXT UCB ADDRESS
10$:	MOVL	UCB$L_LINK(R1),R1	;GET ADDRESS OF NEXT UCB
	BEQL	40$			;IF EQL END OF LIST
	BBC	#1,LOG$C_NAMLENGTH+4(SP),20$ ;IF CLR, GENERIC SEARCH
	CMPW	R6,UCB$W_UNIT(R1)	;UNIT NUMBER MATCH?
	BEQL	30$			;IF EQL YES
	BRB	10$			;
20$:	MOVZWL	UCB$W_REFC(R1),R0	;REFERENCE COUNT ZERO?
	BEQL	25$			;BRANCH IF YES
	BBC	#2,LOG$C_NAMLENGTH+4(SP),10$ ;BRANCH IF ALLOCATION NOT ALLOWED
	DECL	R0			;REF COUNT 1?
	BNEQ	10$			;IF NEQ NO
	BBC	#DEV$V_ALL,UCB$L_DEVCHAR(R1),10$ ;IF CLR, DEVICE NOT ALLOCATED
	CMPL	UCB$L_PID(R1),PCB$L_PID(R3) ;IS PROCESS THE OWNER?
	BNEQ	10$			;BRANCH IF NOT
25$:	BBS	#DEV$V_MNT,UCB$L_DEVCHAR(R1),10$ ;IF SET, DEVICE MOUNTED
	BBC	#DEV$V_SPL,UCB$L_DEVCHAR(R1),30$ ;IF CLR, DEVICE NOT SPOOLED
	IFNPRIV	ALLSPOOL,10$,R3		;PROCESS HAVE PRIVILEGE TO ALLOCATE?
30$:	MOVZWL	#SS$_NORMAL,R9		;INDICATE UNIT NUMBER MATCH
35$:	RSB				;
40$:	BBS	#1,LOG$C_NAMLENGTH+4(SP),35$ ;BR IF NOT GENERIC SEARCH
	MOVZWL	#SS$_NODEVAVL,R9	;INDICATE NO DEVICE AVAILABLE
	RSB				;
	.PAGE
	.SBTTL	UNLOCK I/O DATA BASE AND RETURN STATUS
;+
; IOC$UNLOCK - UNLOCK I/O DATA BASE AND RETURN STATUS
;
; THIS ROUTINE IS JUMPED TO AT THE END OF AN I/O RELATED SYSTEM SERVICE TO
; UNLOCK THE I/O DATA BASE, SET THE CURRENT PROCESSOR PRIORITY TO ZERO,
; AND TO RETURN STATUS TO THE CHANGE MODE DISPATCHER.
;
; INPUTS:
;
;	R0 = FINAL SYSTEM SERVICE STATUS VALUE.
;
; OUTPUTS:
;
;	THE I/O DATA BASE IS UNLOCKED, THE CURRENT PROCESSOR PRIORITY IS SET
;	TO ZERO, AND A RETURN TO THE CHANGE MODE DISPATCHER IS EXECUTED.
;-
 
IOC$UNLOCK::				;UNLOCK I/O DATA BASE AND RETURN STATUS
	PUSHL	R0			;SAVE FINAL SYSTEM SERVICE STATUS VALUE
	MOVL	G^CTL$GL_PCB,R4		;GET PCB ADDRESS
	BSBW	SCH$IOUNLOCK		;UNLOCK I/O DATA BASE
	SETIPL	#0			;ALLOW ALL INTERRUPTS
	POPR	#^M<R0>			;RETRIEVE FINAL SERVICE STATUS VALUE
	RET				;
	.PAGE
	.SBTTL	VERIFY I/O CHANNEL NUMBER
;+
; IOC$VERIFYCHAN - VERIFY I/O CHANNEL NUMBER
;
; THIS ROUTINE IS CALLED TO VERIFY AND TRANSLATE AN I/O CHANNEL NUMBER TO
; A CCB ADDRESS. THE CHANNEL IS CHECKED FOR ACCESSIBILITY BY THE PREVIOUS
; ACCESS MODE.
;
; INPUTS:
;
;	R0 = I/O CHANNEL NUMBER IN LOW ORDER WORD
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO VERIFY.
;
;		R0 = SS$_IVCHAN - INVALID CHANNEL NUMBER.
;		R0 = SS$_NOPRIV - NO PRIVILEGE TO ACCESS CHANNEL.
;		R1 = ADDRESS OF CCB IF R0 = SS$_NOPRIV
;
;	R0 LOW BIT SET INDICATES VERIFY SUCCESS WITH:
;
;		R1 = ADDRESS OF CCB.
;		R2 = CHANNEL INDEX.
;-
 
IOC$VERIFYCHAN::			;VERIFY I/O CHANNEL NUMBER
	BICL	#<^XFFFF0000!<CCB$C_LENGTH-1>>,R0 ;CLEAR EXTRANEOUS BITS
	BEQL	10$			;IF EQL INVALID CHANNEL
	CMPW	R0,@#CTL$GW_CHINDX	;LEGAL CHANNEL NUMBER?
	BGTRU	10$			;IF GTRU NO
	MNEGL	R0,R2			;CONVERT TO CHANNEL INDEX
	MOVAB	@CTL$GL_CCBBASE[R2],R1	;GET ADDRESS OF CORRESPONDING CCB
	MOVPSL	R3			;READ CURRENT PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R3,R3 ;EXTRACT PREVIOUS MODE FIELD
	MOVZWL	#SS$_NOPRIV,R0		;ASSUME CALLER DOES NOT HAVE PRIVILEGE
	CMPB	R3,CCB$B_AMOD(R1)	;CALLER HAVE PRIVILEGE TO ACCESS CHANNEL?
	BGEQ	20$			;IF GEQ NO
	BBCS	#0,R0,20$		;INDICATE SUCCESS
10$:	MOVZWL	#SS$_IVCHAN,R0		;SET INVALID CHANNEL
20$:	RSB				;
 
	.END
