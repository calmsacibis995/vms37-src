	.TITLE	SYSWAIT EVENT FLAG WAIT SERVICES
	.IDENT	'V03-000'
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY: EXECUTIVE, EVENT FLAG SERVICES
;
; ABSTRACT: WAIT CONTAINS THE THREE FORMS OF EVENT FLAG WAIT
;	    SYSTEM SERVICES WHICH PROVIDE FOR SINGLE EVENT WAIT AS
;	    WELL AS COMBINATIONS OF MULTIPLE EVENTS.
;
;--
;
; AUTHOR:
;	R.HUSTVEDT : VERSION
;
; MODIFIED BY:
;
;	V02-011	LJK0114		Lawrence J. Kenah	20-Jan-1982
;		Repair broken word displacements.
;
;	V02-010	RIH0044		Richard I. Hustvedt	12-Jun-1981
;		Replace use of ASTLVL processor register with PHD$B_ASTLVL
;		to provide for MP.
;
;	V02-009	LJK0034		Lawrence J. Kenah	11-Jun-1981
;		Add SCH$WAITM entry point so that memory management
;		wait code uses common entry into the scheduler.
;
;	V02-008	LJK0023		Lawrence J. Kenah	13 May 1981
;		Put assumptions about PSL layout into ASSUME macros
;
;	V02-007	LJK0009		Lawrence J. Kenah	13 May 1981
;		Speed up boolean logic along $WFLAND code path
;
;	V03-006	HRJ0020		Herb Jacobs		4-May-1981
;		Record time of day at wait for longwait determination.
;
;	V02-005	RIH0028		RICHARD I. HUSTVEDT	24-APR-1981
;		ADD CHECK FOR WAIT AT IPL 2 TO PREVENT COMPUTE LOOP WHEN
;		AST IS PENDING.
;
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$CEBDEF					;COMMON EVENT BLOCK DEFS
	$DYNDEF					;DYNAMIC STRUCTURE TYPES
	$IPLDEF					;IPL DEFINITIONS
	$PCBDEF					;PCB DEFINITIONS
	$PHDDEF					;PHD DEFINITIONS
	$PRDEF					;PROCESSOR REGISTER DEFS
	$PSLDEF					;PSL DEFINITIONS
	$SHBDEF					;SHARED MEMORY CONTROL BLK DEFS
	$SHDDEF					;SHARED MEMORY COMMON DATA PAGE
	$SSDEF					;STATUS CODE DEFINITIONS
	$STATEDEF				;STATE DEFINITIONS
	$WQHDEF					;WAIT QUEUE HEADER DEFS
;
; EQUATES:
;
EFN=4						;EVENT FLAG NUMBER
MASK=8						;WAIT MASK
	.PSECT	AEXENONPAGED			;NON-PAGED
	.PAGE
	.SBTTL	EXE$WFLAND - WAIT FOR LOGICAL AND OF EVENT FLAGS
;++
;
;	EXE$WFLAND - WAIT FOR LOGICAL AND OF EVENT FLAGS
;
; FUNCTIONAL DESCRIPTION:
;	EXE$WFLAND RETURNS TO THE CALLER WHEN THE SET OF EVENT
;	FLAGS SELECTED BY THE MASK ARE ALL SET AND RETURNS THE
;	STATE OF ALL EVENT FLAGS IN THE SPECIFIED CLUSTER.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$WFLAND
;
; INPUT PARAMETERS:
;	04(AP) - EVENT FLAG NUMBER SELECTING CLUSTER
;	08(AP) - MASK SELECTING COMBINATION OF EVENTS
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	     CONDITION IS SATISFIED.
;
; SIDE EFFECTS: 
;	IF THE SET OF EVENT FLAGS SELECTED BY THE MASK ARE NOT
;	ALL SET, THEN THE PROCESS ISSUING THE WAIT SERVICE CALL WILL
;	BE PLACED IN A WAIT STATE.
;
; COMPLETION CODES:
;	SS$_NORMAL - NORMAL SUCCESSFUL COMPLETION
;	SS$_ILLEFC - ILLEGAL EVENT FLAG CLUSTER NUMBER.  EVENT NUMBER
;		     NOT IN THE RANGE 0-127.
;	SS$_UNASEFC - UNASSIGNED EVENT FLAG CLUSTER.
;
;--
EXE$WFLAND::				;WAIT FOR LOGICAL AND
	.WORD	^M<R2,R3,R4,R5>		;REGISTER SAVE MASK FOR R2-R5
	MOVL	#1,R1			;SET MODE TO WAITALL
	BRB	WFRL			;AND MERGE WITH COMMON CODE
	.PAGE
	.SBTTL	EXE$WFLOR - WAIT FOR LOGICAL OR OF EVENTS
;++
;	EXE$WFLOR - WAIT FOR LOGICAL OR OF EVENTS
;
; FUNCTIONAL DESCRIPTION:
;	EXE$WFLOR RETURNS TO THE CALLER WHEN ANY OF THE
;	EVENTS SELECTED BY THE MASK WITHIN THE SPECIFIED CLUSTER
;	ARE SET AND RETURNS THE STATE OF ALL 32 EVENT FLAGS IN THE
;	CLUSTER.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$WFLOR
;
; INPUT PARAMETERS:
;	04(AP) - EVENT FLAG NUMBER TO SELECT CLUSTER
;	08(AP) - MASK SELECTING DESIRED COMBINATION OF EVENTS
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	     IS SATISFIED.
;
;
; COMPLETION CODES:
;	SS$_NORMAL - NORMAL SUCCESSFUL COMPLETION
;	SS$_ILLEFC - ILLEGAL EVENT FLAG NUMBER NOT IN THE RANGE 0-127.
;	SS$_UNASEFC - UNASSIGNED EVENT FLAG CLUSTER.
;
; SIDE EFFECTS:
;	THE PROCESS ISSUING THE SERVICE CALL IS BE PLACED IN A
;	WAIT STATE IF NONE OF THE SPECIFIED EVENTS ARE SET.
;
;--
EXE$WFLOR::				;WAIT FOR LOGICAL OR
	.WORD	^M<R2,R3,R4,R5>		;REGISTER SAVE MASK FOR R2-R5
	CLRL	R1			;SET MODE TO WAIT ANY
WFRL:	MOVL	MASK(AP),R0		;GET WAIT MASK
	BRB	EXE$WAIT		;MERGE WITH COMMON CODE
	.PAGE
	.SBTTL	EXE$WAITFR - WAIT FOR SINGLE EVENT
;++
;	EXE$WAITFR - WAIT FOR SINGLE EVENT
;
;
; FUNCTIONAL DESCRIPTION:
;	EXE$WAITFR RETURNS TO THE CALLER WHEN THE SPECIFIED SINGLE
;	EVENT FLAG IS SET.  UPON RETURN THE STATE OF ALL 32 EVENT FLAGS
;	WITHIN THE CLUSTER CONTAINING THE SPECIFIED EVENT ARE RETURN.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$WAITFR
;
; INPUT PARAMETERS:
;	04(AP)=EVENT FLAG NUMBER
;	R4 - PCB ADDRESS OF CURRENT PROCESS 
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	     SATISIFIED.
;
; SIDE EFFECTS:
;	IF THE SPECIFIED EVENT FLAG IS NOT SET, THE PROCESS ISSUING THE
;	WAIT SYSTEM SERVICE WILL BE PLACED IN THE APPROPRIATE WAIT
;	STATE.
;
; COMPLETION CODES:
;	SS$_NORMAL - NORMAL SUCCESSFUL COMPLETION
;	SS$_ILLEFC - ILLEGAL EVENT FLAG NUMBER NOT IN THE RANGE 0-127.
;	SS$_UNASEFC - UNASSIGNED EVENT FLAG CLUSTER.
;
; ENVIRONMENT:
;	MODE=KERNEL
;--
EXE$WAITFR::				;WAIT FOR SINGLE EVENT
	.WORD	^M<R2,R3,R4,R5>		;SAVE REGISTERS R2,R3,R4,R5
	CLRL	R1			;SET MODE 
	ROTL	EFN(AP),#1,R0		;INIT MASK
;	BRB	EXE$WAIT		;AND MERGE WITH COMMON CODE
	.PAGE
	.SBTTL	EXE$WAIT - WAIT COMMON CODE
;++
;	EXE$WAIT - WAIT COMMON CODE
;
; INPUT:
;	04(AP) = EVENT FLAG NUMBER
;	R0 = MASK SELECTING EVENTS OF INTEREST
;	R1 = ANY/ALL MODE SELECTOR
;		0 => ANY
;		1 => ALL
;	R4 = PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	CEB IF NON-LOCAL CLUSTER.
;
; OUTPUT:
;	R0 - COMPLETION STATUS CODE
;	     SATISIFIED.
;--
EXE$WAIT:				;WAIT COMMON CODE
	CVTBL	EFN(AP),R2		;GET CLUSTER NUMBER
	BLSS	10$			;ILLEGAL IF NOT (0,1,2,3)
	ASHL	#-5,R2,R2		;RIGHT ALIGN CLUSTER NUMBER
	MOVAL	PCB$L_EFCS(R4)[R2],R3	;POINTER TO PCB EVENT CLUSTER
	MOVB	R2,PCB$B_WEFC(R4)	;SAVE WAIT CLUSTER NUMBER
	SOBGTR	R2,30$			;BR IF COMMON CLUSTER R2 = (2,3)
	MOVAQ	SCH$GQ_LEFWQ,R2		;SET WAIT QUEUE POINTER
	BRB	WAITCK			;
10$:	MOVZWL	#SS$_ILLEFC,R0		;SET ERROR CODE FOR ILLEGAL CLUSTER
	RET				;AND EXIT
20$:	MOVZWL	#SS$_UNASEFC,R0		;SET ERROR CODE FOR UNASSIGNED
	RET				;AND EXIT
30$:	ADDL3	#CEB$L_EFC,(R3),R2	;GET CEB ADDRESS FOR EVENT FLAGS
	BGEQ	20$			;CEB ASSIGNED (SYSTEM SPACE ADDRESS)
	CMPB	#DYN$C_SLAVCEB,<CEB$B_TYPE-CEB$L_EFC>(R2) ;IS THIS IN SH MEM?
	BNEQ	40$			;BR IF IN LOCAL MEMORY
	MOVL	<CEB$L_MASTER-CEB$L_EFC>(R2),R3 ;GET ADR OF MASTER CEB
	MOVL	CEB$L_EFC(R3),(R2)	;COPY EFC FROM MASTER TO SLAVE CEB
	ASSUME	<CEB$L_EFC+4> EQ CEB$L_WQFL
40$:	MOVAL	(R2)+,R3		;GET EVENT POINTER AND WAIT QUEUE ADDR
					; R3=CEB$L_EFC, R2=CEB$L_WQFL
;
;	R0 - MASK SELECTING EVENTS OF INTEREST
;	R1 - ANY/ALL MODE SELECTOR
;	R2 - ADDRESS OF WAIT QUEUE HEADER
;	R3 - ADDRESS OF EVENT FLAG VECTOR
;	R4 - PCB ADDRESS
;
WAITCK:					;CHECK FOR WAIT SATISFIED
	SETIPL	#IPL$_SYNCH		;BLOCK SCHEDULING ACTIVITY
	BITL	(R3),R0			;WAIT FOR LOGICAL OR MAY BE SATISFIED
	BEQL	WAIT			;NO, MUST WAIT
	BLBS	R1,WAITALL		; 1 => WAIT FOR ALL IN MASK
NOWAIT:					;
	MOVL	#SS$_NORMAL,R0		;RETURN SUCCESS CODE
	MOVL	12(FP),FP		;GET SAVED FRAME POINTER
	ADDL	S^#EXE$C_CMSTKSZ,SP	;CLEAN STACK TO PC,PSL
	REI				;RETURN TO CALLER

WAITALL:				; WAIT FOR ALL SELECTED EVENTS
	BICL2	(R3),R0			; CLEAR BITS FOR ALREADY SET FLAGS
	BEQL	NOWAIT			;YES, DONT WAIT
WAIT:	INSV	R1,#PCB$V_WALL,#1,PCB$L_STS(R4)	;SET WAIT ALL FLAG
	MCOML	R0,PCB$L_EFWM(R4)	;SAVE INVERTED WAIT MASK
	.PAGE
	.SBTTL	SCH$WAIT - PLACE PROCESS IN SELECTED WAIT QUEUE
;++
;	SCH$WAIT - PLACE PROCESS IN SELECTED WAIT QUEUE
;
; FUNCTIONAL DESCRIPTION:
;	SCH$WAIT PLACES THE CURRENT PROCESS IN A WAIT QUEUE
;	SELECTED BY A WAIT QUEUE HEADER ADDRESS SUPPLIED IN A REGISTER
;	A NEW PROCESS IS THEN SELECTED FOR EXECUTION.
;
; CALLING SEQUENCE:
;	JMP/BR	SCH$WAIT
;
; INPUT PARAMETERS:
;	R2 - WAIT QUEUE HEADER ADDRESS
;	R4 - PCB ADDRESS
;	00(SP) - PC AT WHICH TO RESTART PROCESS
;	04(SP) - PSL WITH WHICH TO RESTART PROCESS
;
; IMPLICIT INPUTS:
;	NONE
;
; SIDE EFFECTS:
;	THE PROCESS SPECIFIED BY THE PCB ADDRESS IN R4 IS PLACED 
;	IN THE WAIT QUEUE LOCATED BY R2, ITS CONTEXT SAVED,
;	AND A NEW PROCESS SCHEDULED.
;
;
;--

SCH$WAIT::				;PLACE PROCESS IN WAIT STATE
	CMPW	PCB$W_DIOCNT(R4),PCB$W_DIOLM(R4) ; CHECK FOR DIRECT I/O
	BNEQ	10$			;YES, DONT TRIGGER SWAPPER
	CMPW	PCB$W_BIOCNT(R4),PCB$W_BIOLM(R4) ;CHECK FOR BUFFERED I/O
	BEQL	10$			;NO, NOT A LONG WAIT
	BSBW	SCH$SWPWAKE		;WAKE SWAPPER
10$:					;
	MOVL	12(SP),FP		;RESTORE FP
	ADDL2	S^#EXE$C_CMSTKSZ,SP	;CLEAN UP KERNEL STACK
	SUBL2	#4,(SP)			;BACK UP SAVED PC
SCH$WAITK::				;WAIT WITH STACK ALREADY CLEAN
	INCW	WQH$W_WQCNT(R2)		;INCREMENT COUNT FOR QUEUE
	INSQUE	(R4),WQH$L_WQFL(R2)	;INSERT IN QUEUE
	MOVW	WQH$W_WQSTATE(R2),PCB$W_STATE(R4) ;SET STATE FOR PROCESS
;
;					THE STATE NUMBER IS CONTAINED
;					IN THE QUEUE HEADER
;
SCH$WAITL::				;WAIT WITH STATE SET, STACK CLEANED
	SVPCTX				;SAVE PROCESS CONTEXT
SCH$WAITM::				;ENTRY FOR MEMORY MANAGEMENT WAIT CODE
	MOVL	PCB$L_PHD(R4),R5	;GET PROCESS HEADER ADDRESS
	ADDW	SCH$GW_IOTA,PHD$W_QUANT(R5) ;CHARGE QUOTA FOR VOLUNTARY WAIT
	MOVW	EXE$GQ_SYSTIME+2,PHD$W_WAITIME(R5) ;RECORD TIME AT WAIT START
	CMPB	#4,PHD$B_ASTLVL(R5)	;NULL ASTLVL?
	BNEQ	20$			;NO, DO LONG CHECK
10$:	BRW	W^SCH$SCHED		;GO SCHEDULE NEXT PROCESS

20$:	MOVZBL	PHD$B_ASTLVL(R5),R0	;FETCH AND ZERO EXTEND PENDING ASTLVL 
	CMPZV	#PSL$V_CURMOD,#PSL$S_CURMOD,PHD$L_PSL(R5),R0 ;COMPARE WITH WAIT
					;ACCESS MODE
	BLSS	10$			;BRANCH IF AST NOT DELIVERABLE

;
;  Test for assumptions that are being made about the layout of the
;  PSL that enables the next instruction to work correctly.
;
;	o  IPL field begins on a byte boundary
;	o  IPL field fits into a single byte


	ASSUME	<<<PSL$V_IPL/8>*8> - PSL$V_IPL> EQ 0 ; IPL must be byte aligned
	ASSUME	PSL$S_IPL LE 8		; IPL field must fit into byte

	BITB	#<PSL$M_IPL@-PSL$V_IPL>,-
		<PSL$V_IPL/8>+PHD$L_PSL(R5) ;MUST BE AT IPL 0 FOR DELIVERY
	BNEQ	10$			;BRANCH IF AST NOT DELIVERABLE
	CLRL	R2			;SET NULL PRIORITY INCREMENT
	RPTEVT	AST			;REPORT AST EVENT
	BRB	10$			;GO SCHEDULE NEXT PROCESS

	.END
