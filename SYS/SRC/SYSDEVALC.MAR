	.TITLE	SYSDEVALC - SYSTEM SERVICES FOR DEVICE ALLOCATION
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 9-SEP-76
;
; MODIFIED BY:
;
;	V03-001	STJ0258		Steven T. Jeffreys,	12-Apr-1982
;		If the device is mounted, do not deallocate it, and
;		return SS$_DEVMOUNT as the status code.
;
;	V02-010	ACG0250		Andrew C. Goldstein,	29-Dec-1981  20:39
;		Add option to search for allocated device
;
;	V02-009	PHL0026		Peter H. Lipman		01-Dec-1981
;		Fix incorrect probe of PHYBUF.
;
;	V02-008	PHL0020		Peter H. Lipman		29-Oct-1981
;		IOC$SEARCHGEN has a new alternate success code
;		SS$_CONCEALED for use by $GETDVI.  One code path
;		in $ALLOC would have returned that status to the
;		caller.  For now at least, do not allow that status
;		to be returned.
;
;	V02-007	ROW0039		Ralph O. Weber		26-OCT-1981
;		Alter DECREF to assume DDT$L_CANCEL contains a system virtual
;		address.
;
;	V02-06	RNG0001		Rod N. Gamache		29-Aug-1981
;		Clear extra register passed to driver's CANCEL entry point.
;
;	V02-05	ROW0007		Ralph O. Weber		30-JUL-1981
;		Alter DECREF to get DDT address from UCB rather than DDB.
;
;	V02-04	STJ0058		STEVEN T. JEFFREYS	02-JUL-1981
;		CHANGED EXE$ALLOC TO USE R5 TO HOLD THE UCB ADDRESS,
;		AND R6 TO HOLD THE STATUS.  THIS IS NECESSARY DUE TO
;		A CHANGE IN THE INTERFACE TO IOC$CVT_DEVNAM.
;
;	V02-03	STJ0013		STEVEN T. JEFFREYS	04-Dec-1980
;		CLEAR THE OPR BIT IN UCB$L_DEVCHAR FOR TERMINALS,
;		REMOTE TERMINALS, AND MAILBOXES WHEN THE DEVICE IS
;		DEALLOCATED.
;
;	V02	LMK0001		LEN KAWELL		20-JAN-1980
;		ADDED NONSHAREABLE DEVICE ALLOCATION PRIVILEGE CHECK.
;
; SYSTEM SERVICES FOR DEVICE ALLOCATION
;
;	ALLOCATE DEVICE
;	DEALLOCATE DEVICE
;
; MACRO LIBRARY CALLS
;
 
	$CANDEF				;DEFINE CANCEL REASON CODES
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$UCBDEF				;DEFINE UCB OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR ALLOCATE DEVICE
;
 
DEVNAM=4				;ADDRESS OF DEVICE NAME STRING DESCRIPTOR
PHYLEN=8				;ADDRESS TO STORE LENGTH OF PHYSICAL NAME
PHYBUF=12				;ADDRESS OF PHYSICAL NAME BUFFER DESCRIPTOR
ALACMODE=16				;ACCESS MODE
 
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR DEALLOCATE DEVICE
;
 
DEVNAM=4				;ADDRESS OF DEVICE NAME STRING DESCRIPTOR
DLACMODE=8				;ACCESS MODE
	.PAGE
	.SBTTL	ALLOCATE DEVICE
;+
; EXE$ALLOC - ALLOCATE DEVICE
;
; THIS SERVICE PROVIDES THE CAPABILITY TO RESERVE A DEVICE FOR EXCLUSIVE
; USE.
;
; INPUTS:
;
;	DEVNAM(AP) = ADDRESS OF DEVICE NAME STRING DESCRIPTOR.
;	PHYLEN(AP) = ADDRESS TO STORE LENGTH OF PHYSICAL NAME.
;	PHYBUF(AP) = ADDRESS OF PHYSICAL NAME BUFFER DESCRIPTOR.
;	ALACMODE(AP) = ACCESS MODE DEVICE IS TO BE ALLOCATED TO.
;		       BIT 8 = 1 TO ALLOW FINDING OF ALLOCATED DEVICES
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO ALLOCATE DEVICE.
;
;		R0 = SS$_ACCVIO - DEVICE NAME STRING, DEVICE NAME STRING
;			DESCRIPTOR, OR PHYSICAL NAME BUFFER DESCRIPTOR 
;			CANNOT BE READ BY CALLING ACCESS MODE, OR PHYSICAL
;			NAME BUFFER CANNOT BE WRITTEN BY CALLING ACCESS
;			MODE.
;
;		R0 = SS$_DEVALLOC - DEVICE ALREADY ALLOCATED TO ANOTHER
;			PROCESS.
;
;		R0 = SS$_DEVMOUNT - DEVICE CURRENTLY MOUNTED AND CANNOT
;			BE ALLOCATED.
;
;		R0 = SS$_IVDEVNAM - DEVICE NAME STRING CONTAINS INVALID
;			CHARACTERS OR NO DEVICE NAME STRING DESCRIPTOR
;			SPECIFIED.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			DEVICE NAME STRING SPECIFIED.
;
;		R0 = SS$_NONLOCAL - SPECIFIED DEVICE EXISTS ON A REMOTE
;			SYSTEM.
;
;		R0 = SS$_NOPRIV - DEVICE CURRENTLY SPOOLED AND PROCESS DOES
;			NOT HAVE PRIVILEGE TO ALLOCATE.
;
;		R0 = SS$_NOSUCHDEV - SPECIFIED DEVICE DOES NOT EXIST ON
;			HOST SYSTEM OR NO ALLOCATABLE UNIT CAN BE FOUND.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_DEVALRALLOC - DEVICE IS ALREADY ALLOCATED TO CALLING
;			PROCESS.
;
;		R0 = SS$_BUFFEROVF - NORMAL COMPLETION, PHYSICAL NAME OVER-
;			FLOWED PHYSICAL NAME BUFFER.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION, PHYSICAL NAME TRANSFERED
;			TO PHYSICAL NAME BUFFER.
;-
 
	.PSECT	Y$EXEPAGED
	.ENTRY	EXE$ALLOC,^M<R2,R3,R4,R5,R6>
	MOVZWL	#SS$_IVDEVNAM,R6	;SET INVALID DEVICE NAME STATUS
	BSBW	LOCK			;LOCK I/O DATA BASE AND GET DEVICE NAME
	BEQL	27$			;IF EQL NO DEVICE NAME SPECIFIED
	BBC	#8,ALACMODE(AP),1$	;BRANCH IF ALLOCATED DEV NOT PERMITTED
	BSBW	IOC$SEARCHALC		;SEARCH FOR GENERIC ALLOCATED DEVICE
	BRB	2$
1$:	BSBW	IOC$SEARCHGEN		;SEARCH FOR GENERIC DEVICE
2$:	MOVL	R0,R6			;SAVE SEARCH STATUS
	BLBC	R6,27$			;IF LBC SEARCH FAILURE
	MOVL	#SS$_NORMAL,R6		;HIDE POSSIBLE SS$_CONCEALED STATUS
	MOVL	R1,R5			;SAVE DEVICE UCB ADDRESS
;
; RETURN PHYSICAL DEVICE NAME
;
	MOVL	PHYBUF(AP),R1		;GET ADDRESS OF NAME BUFFER DESCRIPTOR
	BEQL	20$			;IF EQL NONE
	IFNORD	#8,(R1),55$		;CAN NAME BUFFER DESCRIPTOR BE READ?
	MOVZWL	(R1),R0			;GET LENGTH OF NAME BUFFER
	BEQL	20$			;IF EQL ZERO LENGTH BUFFER
	CMPW	R0,#255			;WAS BUFFER SIZE REASONABLE?
	BLEQU	5$			;BRANCH IF OK
	MOVZBL	#255,R0			;USE SMALLER, BUT STILL ABSURD SIZE
5$:	MOVL	4(R1),R1		;GET ADDRESS OF NAME BUFFER
	IFNOWRT	R0,(R1),55$		;CAN NAME BUFFER BE WRITTEN?
	MOVL	PHYLEN(AP),R3		;GET ADDRESS TO STORE NAME LENGTH
	BEQL	10$			;IF EQL NONE
	IFNOWRT	#2,(R3),55$		;CAN NAME LENGTH BE WRITTEN?
10$:	BSBW	IOC$CVT_DEVNAM		;CONVERT DEVICE NAME AND UNIT
	MOVL	R0,R6			;SAVE COMPLETION STATUS
	TSTL	R3			;ADDRESS TO STORE LENGTH SPECIFIED?
	BEQL	20$			;IF EQL NONE SPECIFIED
	MOVW	R1,(R3)			;INSERT LENGTH OF CONVERTED STRING
;
; CHECK IF PROCESS ALREADY ALLOCATED DEVICE OR CAN ALLOCATE THE DEVICE
;
20$:	MOVL	UCB$L_PID(R5),R0	;GET PROCESS ID OF OWNER
	BEQL	30$			;IF EQL DEVICE NOT OWNED
	CMPL	R0,PCB$L_PID(R4)	;OWNED BY CURRENT PROCESS?
	BEQL	60$			;IF EQL YES
25$:	MOVZWL	#SS$_DEVALLOC,R6	;SET DEVICE ALREADY ALLOCATED
27$:	BRB	80$			;

30$:	BBC	#DEV$V_SPL,UCB$L_DEVCHAR(R5),40$ ;IF CLR, DEVICE NOT SPOOLED
	IFPRIV	ALLSPOOL,45$		;PROCESS HAVE PRIVILEGE TO ALLOCATE?
	BRB	47$			;
40$:	TSTW	UCB$W_REFC(R5)		;ANY CHANNELS ASSIGNED TO DEVICE?
	BNEQ	25$			;IF NEQ YES
	BBS	#DEV$V_MNT,UCB$L_DEVCHAR(R5),50$ ;IF SET, DEVICE MOUNTED
45$:	BBS	#DEV$V_SHR,UCB$L_DEVCHAR(R5),70$ ;IF SET, SHAREABLE DEVICE
	MOVL	PCB$L_ARB(R4),R0	;GET ACCESS RIGHTS BLOCK ADDRESS
	MOVZWL	UCB$W_VPROT(R5),R1	;GET DEVICE PROTECTION MASK
	MOVL	UCB$L_OWNUIC(R5),R2	;GET DEVICE OWNER UIC
	BSBW	EXE$CHKRDACCES		;CHECK USER'S RIGHT TO ALLOCATE DEVICE
	BLBS	R0,70$			;IF LBS OK
47$:	BRW	NOPRIV			;ELSE NO PRIVILEGE

50$:	MOVZWL	#SS$_DEVMOUNT,R6	;SET DEVICE MOUNTED STATUS
	BRB	80$			;
55$:	MOVZWL	#SS$_ACCVIO,R6		;SET ACCESS VIOLATION STATUS
	BRB	80$			;

60$:	CMPW	#SS$_NORMAL,R6		;NORMAL COMPLETION STATUS?
	BNEQ	70$			;IF NEQ NO
	BBC	#DEV$V_ALL,UCB$L_DEVCHAR(R5),70$ ;IF CLR, DEVICE NOT ALLOCATED
	MOVZWL	#SS$_DEVALRALLOC,R6	;SET DEVICE ALREADY ALLOCATED STATUS
;
; ALLOCATE THE DEVICE BY SETTING OWNER PID, SETTING ALLOCATED CHARACTERISTIC,
; INCREMENTING THE REFERENCE COUNT, AND SETTING THE ALLOCATOR'S ACCESS MODE
;
70$:	MOVL	PCB$L_PID(R4),UCB$L_PID(R5) ;SET OWNER PROCESS ID
	BBSS	#DEV$V_ALL,UCB$L_DEVCHAR(R5),80$ ;IF SET, DEVICE ALREADY ALLOCATED
	INCW	UCB$W_REFC(R5)		;INCREMENT REFERENCE COUNT
	EXTZV	#0,#2,ALACMODE(AP),R0	;GET SPECIFIED ACCESS MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE ACCESS MODE
	MOVB	R0,UCB$B_AMOD(R5)	;SET ALLOCATING ACCESS MODE
80$:	MOVL	R6,R0			;SET FINAL STATUS
	BRW	IOC$UNLOCK		;
	.PAGE
	.SBTTL	DEALLOCATE DEVICE
;+
; EXE$DALLOC - DEALLOCATE DEVICE
;
; THIS SERVICE PROVIDES THE CAPABILITY TO RELINQUISH EXCLUSIVE USE OF A
; DEVICE.
;
; INPUTS:
;
;	DEVNAM(AP) = ADDRESS OF DEVICE NAME STRING DESCRIPTOR. ZERO
;		IMPLIES ALL.
;	DLACMODE(AP) = ACCESS MODE FOR DEALLOCATION.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO DEALLOCATE DEVICE.
;
;		R0 = SS$_ACCVIO - DEVICE NAME STRING OR DEVICE NAME STRING
;			DESCRIPTOR CANNOT BE READ BY CALLING ACCESS MODE.
;
;		R0 = SS$_DEVASSIGN - DEVICE CANNOT BE DEALLOCATED BECAUSE
;			PROCESS STILL HAS CHANNELS ASSIGNED.
;
;		R0 = SS$_DEVMOUNT - DEVICE CANNOT BE DEALLOCATED BECAUSE IT
;			IS STILL MOUNTED.
;
;		R0 = SS$_DEVNOTALLOC - DEVICE NOT ALLOCATED OR NOT ALLOCATED
;			TO PROCESS.
;
;		R0 = SS$_IVDEVNAM - DEVICE NAME STRING CONTAINS INVALID
;			CHARACTERS.
;
;		R0 = SS$_IVLOGNAM - ZERO OR GREATER THAN MAXIMUM LENGTH
;			DEVICE NAME STRING SPECIFIED.
;
;		R0 = SS$_NOPRIV - CALLING ACCESS MODE DOES NOT HAVE PRIVILEGE
;			TO DEALLOCATE DEVICE.
;
;		R0 = SS$_NOSUCHDEV - SPECIFIED DEVICE DOES NOT EXIST ON
;			HOST SYSTEM.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENTRY	EXE$DALLOC,^M<R2,R3,R4,R5,R8>
	EXTZV	#0,#2,DLACMODE(AP),R0	;GET DEALLOCATION ACCESS MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE ACCESS MODE
	MOVL	R0,R5			;SAVE MAXIMIZED ACCESS MODE
	BSBB	LOCK			;LOCK I/O DATA BASE AND SEARCH FOR DEVICE
	BEQL	10$			;IF EQL NO DEVICE NAME SPECIFIED
	BSBW	IOC$SEARCHDEV		;SEARCH FOR PHYSICAL DEVICE
	BLBC	R0,50$			;IF LBC SEARCH FAILURE
	CMPL	UCB$L_PID(R1),PCB$L_PID(R4) ;DEVICE ALLOCATED TO CURRENT PROCESS?
	BNEQ	40$			;IF NEQ NO
	CMPB	R5,UCB$B_AMOD(R1)	;CAN SPECIFED ACCESS MODE DEALLOCATE DEVICE?
	BGTR	NOPRIV			;IF GTR NO
	BBC	#DEV$V_ALL,UCB$L_DEVCHAR(R1),40$ ;IF CLR, DEVICE NOT ALLOCATED
	MOVZWL	#SS$_DEVASSIGN,R0	;ASSUME DEVICE ASSIGNED
	CMPW	#1,UCB$W_REFC(R1)	;REFERENCE COUNT ONE?
	BNEQ	50$			;IF NEQ NO
	JSB	DECREF			;DECREMENT REFERENCE COUNT AND CALL DRIVER
	BRB	UNLOCK			;
10$:	MOVAB	L^IOC$GL_DEVLIST-DDB$L_LINK,R3 ;GET ADDRESS OF I/O DATABASE LISTHEAD
20$:	MOVL	DDB$L_LINK(R3),R3	;GET ADDRESS OF NEXT DDB
	BEQL	NORMAL			;IF EQL END OF LIST
	MOVAB	DDB$L_UCB-UCB$L_LINK(R3),R1 ;GET ADDRESS OF NEXT UCB ADDRESS
30$:	MOVL	UCB$L_LINK(R1),R1	;GET ADDRESS OF NEXT UCB
	BEQL	20$			;IF EQL END OF LIST
	CMPL	UCB$L_PID(R1),PCB$L_PID(R4) ;DEVICE ALLOCATED TO CURRENT PROCESS?
	BNEQ	30$			;IF NEQ NO
	CMPB	R5,UCB$B_AMOD(R1)	;CAN ACCESS MODE DEALLOCATE DEVICE?
	BGTR	30$			;IF GTR NO
	BBC	#DEV$V_ALL,UCB$L_DEVCHAR(R1),30$ ;IF CLR, DEVICE NOT ALLOCATED
	CMPW	#1,UCB$W_REFC(R1)	;REFERENCE COUNT ONE?
	BNEQ	30$			;IF NEQ NO
	JSB	DECREF			;DECREMENT REFERENCE COUNT AND CALL DRIVER
	BRB	30$			;
40$:	MOVZWL	#SS$_DEVNOTALLOC,R0	;SET DEVICE NOT ALLOCATED TO PROCESS
50$:	BRB	UNLOCK			;
	.PAGE
	.SBTTL	LOCK I/O DATA BASE AND SEARCH FOR DEVICE
;
; SUBROUTINE TO LOCK I/O DATA BASE, SEARCH FOR DEVICE, AND CHECK FOR MAILBOX.
;
 
LOCK	:				;LOCK I/O DATA BASE AND SEARCH FOR DEVICE
	JSB	SCH$IOLOCKW		;LOCK I/O DATABASE FOR WRITE ACCESS
	MOVL	DEVNAM(AP),R1		;GET ADDRESS OF DEVICE NAME STRING DESCRIPTOR
	BEQL	10$			;IF EQL NONE
	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION STATUS
	IFNORD	#8,(R1),UNLOCK		;CAN DEVICE NAME DESCRIPTOR BE READ?
10$:	RSB				;
NOPRIV:	MOVZWL	#SS$_NOPRIV,R0		;SET NO PRIVILEGE
	BRB	UNLOCK			;
NORMAL:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION
UNLOCK:	BRW	IOC$UNLOCK		;UNLOCK I/O DATA BASE AND RETURN
	.PAGE
	.SBTTL	DECREMENT REFERENCE COUNT, CLEAR OWNERSHIP, AND CALL DRIVER
;
; SUBROUTINE TO DECREMENT REFERENCE COUNT, CLEAR OWNERSHIP, AND CALL DRIVER
;
 
	.PSECT	WIONONPAGED
DECREF:					;
	MOVZWL	#SS$_DEVMOUNT,R0	;ASSUME DEVICE MOUNTED
	BBS	#DEV$V_MNT,-		;BRANCH IF DEVICE MOUNTED
		UCB$L_DEVCHAR(R1),30$	;
	BBCC	#DEV$V_ALL,UCB$L_DEVCHAR(R1),10$ ;CLEAR DEVICE ALLOCATED
10$:	DECW	UCB$W_REFC(R1)		;DECREMENT REFERENCE COUNT
	CLRL	UCB$L_PID(R1)		;CLEAR OWNER PROCESS ID
	PUSHR	#^M<R1,R3,R5>		;SAVE REGISTERS
	MOVL	UCB$L_DDT(R1),R0	;GET ADDRESS OF DDT
	MOVL	R1,R5			;SET ADDRESS OF DEVICE UCB
	CLRL	R2			;CLEAR CHANNEL NUMBER
	DSBINT	UCB$B_FIPL(R5)		;RAISE TO DRIVER FORK LEVEL
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF CURRENT I/O PACKET
	ASSUME	CAN$C_CANCEL EQ 0
	CLRL	R8			;INDICATE PLAIN CANCEL
	JSB	@DDT$L_CANCEL(R0)	;CALL CANCEL I/O ROUTINE
	ENBINT				;ENABLE INTERRUPTS
	POPR	#^M<R1,R3,R5>		;RESTORE REGISTERS
	MOVZWL	#SS$_NORMAL,R0		;SET SUCCESS STATUS
	BITL	#DEV$M_TRM!DEV$M_MBX,-	;IS THIS A TERMINAL, REMOTE TERMINAL OR MAILBOX?
		UCB$L_DEVCHAR(R1)	;
	BEQL	30$			;BRANCH IF NOT
	BBSC	S^#DEV$V_OPR,-		;CLEAR THE OPR BIT.
		UCB$L_DEVCHAR(R1),30$	;THIS IS AN IMPLICIT OPERATOR DISABLE.
30$:	RSB				;
 
	.END
