	.TITLE	MAHANDLER - MA780/MA750 MULTIPORT MEMORY PORT HANDLER
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
;
; FACILITY:  
;
;	VAX/VMS EXECUTIVE
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS THE VAX MULTIPORT MEMORY INTERRUPT
;	DISPATCHER AND REQUEST HANDLER.
;
; ENVIRONMENT:
;
;	KERNEL MODE, INTERRUPT AND FORK PROCESS.
;
; AUTHOR:	LEN KAWELL, 27-APR-79
;
; MODIFICATION HISTORY:
;
;	V03-001	KDM0096		Kathleen D. Morse	11-Apr-1982
;		Remove reference count increment and decrement for
;		shared memory master common event blocks via PRQs.
;
;	V02-012	KDM43102	Kathleen D. Morse	6-Jan-1982
;		Set address of event flag cluster before each call to
;		EXE$CHKWAIT2, which wipes out R0 if a RPTEVT is needed.
;		Also, removed duplicated instruction.
;
;	V02-011	KDM0070		Kathleen D. Morse	18-Nov-1981
;		Remove extraneous optimization of event flag wait queue check.
;
;	V02-010	KDM41026	Kathleen D. Morse	18-Nov-1981
;		Fix MA780 inter-processor request REMQUE.
;
;	V02-009	KDM0049		Kathleen D. Morse	28-Mar-1981
;		Replace absolute literals with references to EXE$GL_LOCKRTRY.
;
;
;--
	.PAGE
	.SBTTL	DEFINITIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	$ADPDEF				; ADAPTER CONTROL BLOCK
	$CEBDEF				; COMMON EVENT BLOCK
	$CRBDEF				; CHANNEL REQUEST BLOCK
	$FKBDEF				; FORK BLOCK
	$IPLDEF				; INTERRUPT PRIORITY LEVELS
	$MPMDEF				; MULTI-PORT MEMORY REGISTERS
	$PRDEF				; PRIORITY LEVEL DEFINTIONS
	$PRIDEF				; PRIORITY INCREMENT DEFINITIONS
	$PRQDEF				; INTER-PROCESSOR REQUEST
	$RSNDEF				; RESOURCE NUMBER DEFINITIONS
	$SHBDEF				; SHARED MEMORY CONTROL BLOCK
	$SHDDEF				; SHARED MEMORY DATAPAGE
	$SSDEF				; SYSTEM ERROR CODES
	$VECDEF				; INTERRUPT VECTOR


;
; OWN STORAGE:
;
	.PSECT	$$$115_DRIVER

	.PAGE
	.SBTTL	INTER-PROCESSOR REQUEST HANDLER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY A DRIVER OR AN EXEC FUNCTION TO
;	EITHER SEND A REQUEST TO OR JUST INTERRUPT ANOTHER PROCESSOR
;	THAT IS CONNECTED TO A PORT OF THE MULTIPORT MEMORY.
;
; INPUTS:
;
;	R4 = ADAPTER CONTROL BLOCK ADDRESS.
;	R5 = IF LSS 0 - ADDRESS OF A FORK BLOCK TO USE IF REQUEST
;			BLOCK IS NOT AVAILABLE.
;	     IF GEQ 0 - PORT NUMBER OF PROCESSOR TO JUST INTERRUPT.
;
; OUTPUTS:
;
;	WHEN THIS ROUTINE IS CALLED WITH A FORK BLOCK ADDRESS, IT WILL
;	ATTEMPT TO ALLOCATE A REQUEST BLOCK.  IF THE REQUEST FAILS,
;	THE CONTEXT OF THE CALLER WILL BE SAVED IN THE FORK BLOCK, THE
;	FORK BLOCK BLOCK WILL BE INSERTED IN THE REQUEST BLOCK WAIT 
;	QUEUE AND A RETURN TO THE CALLER'S CALLER IS EXECUTED.
;
;	IF A REQUEST BLOCK IS ALLOCATED SUCCESSFULLY, CONTROL WILL
;	RETURN TO THE CALLER VIA A CO-ROUTINE CALL SO THE CALLER CAN
;	FILL-IN THE REQUEST BLOCK.
;
;	THE CALLER WILL THEN PERFORM ANOTHER CO-ROUTINE CALL TO RETURN
;	TO THIS ROUTINE SO THE BLOCK CAN BE INSERTED IN THE DESIRED
;	PROCESSOR'S INTER-PROCESSOR REQUEST QUEUE.  IF IT IS THE
;	FIRST REQUEST IN THE QUEUE AN INTER-PORT INTERRUPT WILL
;	ALSO BE REQUESTED TO WAKE-UP THE DISPATCHER ON THE PORT.
;
;
;	IF THIS ROUTINE IS CALLED WITH A PORT NUMBER INSTEAD OF A
;	FORK BLOCK ADDRESS, IT WILL JUST REQUEST AN INTERRUPT FOR
;	THE PROCESSOR ON THE SPECIFIED PORT.  IT IS THEN UP TO THE
;	INTERRUPTED PROCESSOR TO DETERMINE WHAT THE INTERRUPT WAS 
;	FOR.
;
;	R0 = SUCCESS OR FAILURE OF OPERATION.  THIS SHOULD BE CHECKED
;	     BY THE CALLER BOTH TIMES THIS ROUTINE RETURNS.
;
;	R3,R4,R5 ARE PRESERVED.
;
;--
MA$REQUEST::				; REQUEST HANDLER
	MOVL	R5,R1			; FORK BLOCK ADDRESS SPECIFIED?
	BGEQ	REQ_INTERRUPT		; IF GEQ, NO - JUST AN INTERRUPT
	MOVL	ADP$L_SHB(R4),R1	; GET SHB ADDRESS
	MOVL	SHB$L_DATAPAGE(R1),R1	; GET DATAPAGE ADDRESS
	MOVZBL	ADP$B_PORT(R4),R0	; GET OUR PORT NUMBER
	BBSSI	R0,SHD$W_PRQWAIT(R1),5$	; ASSUME FAILURE (AVOID MISSING NOTIFICATION)
5$:	QRETRY	SUCCESS=10$-		; GET A REQUEST BLOCK
	REMQHI	SHD$Q_PRQ(R1),R2	;
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS CODE
	RSB				
10$:
	BVS	NOBLOCKS		; IF V-SET, NO BLOCKS LEFT
	MOVZBL	ADP$B_PORT(R4),R0	; GET OUR PORT NUMBER
	BBCCI	R0,SHD$W_PRQWAIT(R1),RETURN_BLOCK ; CLEAR WAITING FLAG
;
; RETURN ADDRESS OF REQUEST BLOCK TO CALLER
;
RETURN_BLOCK:				; RETURN ADDRESS OF BLOCK
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	JSB	@(SP)+			; CO-ROUTINE CALL CALLER BACK
;
; INSERT BLOCK IN DESIRED PORT'S REQUEST QUEUE
;
	PUSHL	R4			; SAVE REGISTER
	MOVZWL	PRQ$W_TO_PORT(R2),R1	; GET DESIRED PORT NUMBER
	MOVL	ADP$L_SHB(R4),R0	; GET SHB ADDRESS
	MOVL	SHB$L_DATAPAGE(R0),R4	; GET DATAPAGE ADDRESS
	QRETRY 	SUCCESS=10$-		; INSERT REQUEST IN PORT'S WORK QUEUE
	INSQTI	(R2),SHD$Q_PRQWRK(R4)[R1]
	MOVZWL	#SS$_BADQUEUEHDR,R0	; SET FAILURE STATUS CODE
	BRB	20$			;
10$:	BEQL	30$			; IF EQL, FIRST ENTRY IN QUEUE
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
20$:	POPL	R4			; RESTORE REGISTER
	RSB				;

30$:	POPL	R4			; RESTORE REGISTER
;
; REQUEST AN INTER-PORT INTERRUPT TO WAKE-UP PROCESSOR ON DESIRED
; PORT.
;
REQ_INTERRUPT:				; REQUEST AN INTER-PORT INTERRUPT
	MOVZBL	ADP$B_PORT(R4),R0	; GET OUR PORT NUMBER
	MULL	#MPM$C_PORTS,R0		; COMPUTE INTERRUPT REQUEST BIT #
	ADDL	R1,R0			; ...
	ADDL	#MPM$V_IIR_CTL,R0	; ...
	MOVL	ADP$L_CSR(R4),R1	; GET ADAPTER CSR ADDRESS
	ASHL	R0,#1,MPM$L_IIR(R1)	; SET PORT INTERRUPT REQUEST BIT
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	RSB				;

;
; NO BLOCKS ARE AVAILABLE.  SAVE THE CALLER'S CONTEXT IN THE FORK
; BLOCK, INSERT THE FORK BLOCK IN THE REQUEST BLOCK WAIT QUEUE, AND
; RETURN TO THE CALLER'S CALLER.
;
NOBLOCKS:				; NO REQUEST BLOCKS AVAILABLE
	MOVQ	R3,FKB$L_FR3(R5)	; SAVE REGISTERS
	POPL	FKB$L_FPC(R5)		; SAVE RETURN ADDRESS
	INSQUE	(R5),@ADP$L_PRQQBL(R4)	; INSERT FORK BLOCK IN WAIT QUEUE
	MOVL	#SS$_NORMAL,R0		; SET SUCCESS
	RSB				; RETURN TO CALLER'S CALLER
	.PAGE
	.SBTTL	REPORT RESOURCE AVAILABILITY TO INTERESTED PORTS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO REPORT TO ANY PROCESSORS THAT A RESOURCE
;	HAS BEEN MADE AVAILABLE.
;
; INPUTS:
;
;	R0 = RESOURCE NUMBER OF RESOURCE MADE AVAILABLE.
;	R1 = SHARED MEMORY CONTROL BLOCK (SHB) ADDRESS.
;
; OUTPUTS:
;
;	ANY PROCESSORS WAITING FOR THE SPECIFIED RESOURCE ARE INTERRUPTED
;	TO NOTIFY THEM THE RESOURCE IS AVAILABLE.
;
;	R0,R1,R2,R3 ARE NOT PRESERVED.
;--
MA$RAVAIL::				;
	MOVL	SHB$L_DATAPAGE(R1),R2	; GET ADDRESS OF DATAPAGE
	TSTW	SHD$W_RESWAIT(R2)[R0]	; ANYONE WAITING FOR THE RESOURCE?
	BEQL	30$			; IF EQL, NO
	PUSHL	SHB$L_ADP(R1)		; SAVE ADDRESS OF ADAPTER CONTROL BLOCK
	CLRL	R3			; INIT PORT NUMBER

10$:	MOVAW	SHD$W_RESWAIT(R2)[R0],R1 ; GET ADDRESS OF RESOURCE WAIT MASK
	BBC	R3,(R1),20$ 		; IF CLR, NO ONE WAITING AT PORT
	MOVAW	SHD$W_RESAVAIL(R2)[R0],R1 ; GET ADDRESS OF AVAILABLE MASK
	BBSSI	R3,(R1),15$		; SET PORT'S RESOURCE AVAIL BIT
15$:	BBSSI	R3,SHD$W_RESSUM(R2),20$ ; SET PORT'S RESOURCE AVAIL SUMMARY BIT
20$:	AOBLSS	#MPM$C_PORTS,R3,10$	; INCREMENT PORT NUMBER AND LOOP
	POPL	R3			; GET ADDRESS OF ADAPTER CONTROL BLOCK
	MOVZWL	SHD$W_RESWAIT(R2)[R0],R1 ; GET RESOURCE WAIT MASK
	BSBW	INTERRUPT_PORTS		; INTERRUPT WAITING PORTS
30$:
	RSB				;

	.PAGE
	.SBTTL	INTER-PORT INTERRUPT DISPATCHER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT
;	OCCURS ON A MULTI-PORT MEMORY.  THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF BYTE FOLLOWING "JSB  @#MA$INT" IN ADP$L_INTD.
;	04(SP) - 24(SP) = SAVED R0 - R5.
;	28(SP) = INTERRUPT PC.
;	32(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	THE FIRST REQUEST BLOCK IN THIS PORT'S INTER-PROCESSOR REQUEST
;	QUEUE IS DEQUEUED.  THE REQUEST BLOCK IS THEN USED AS A FORK
;	BLOCK WHICH IS THEN ENTERED INTO THE LOWEST IPL DEVICE DRIVER
;	FORK QUEUE.  IF THE FORK BLOCK WAS THE FIRST IN THE FORK QUEUE,
;	A SOFTWARE INTERRUPT IS POSTED TO DISPATCH THE FORK PROCESS WHEN
;	THE IPL IS LOW ENOUGH.  WHEN ALL THE REQUEST BLOCKS HAVE BEEN
;	DEQUEUED FROM THE PORT'S INTER-PROCESSOR REQUEST QUEUE, AND
;	REQUEUED TO THE FORK QUEUE, THE INTERRUPT IS DISMISSED.
;--
MA$INT::				;MA780/MA750 INTERRUPT DISPATCHER
	MOVL	(SP)+,R3		; GET ADDRESS OF BYTE IN ADP
	MOVAB	-<ADP$L_INTD+8>(R3),R3	; COMPUTE ADDRESS OF ADP
	MOVL	ADP$L_CSR(R3),R0	; GET CSR ADDRESS
	MOVZBL	ADP$B_PORT(R3),R2	; GET PORT NUMBER
	MULL3	#MPM$C_PORTS,R2,R1	; COMPUTE INTERRUPT REQUEST BIT #
	ASHL	R1,#^XF,MPM$L_IIR(R0)	; CLEAR ANY INTERRUPT REQUESTS
	MOVL	ADP$L_SHB(R3),R4	; GET ADDRESS OF SHB
	BNEQ	10$			; IF NEQ, MEMORY CONNECTED
	BRW	INT_EXIT		; ELSE, IGNORE INTERRUPT
10$:	MOVL	SHB$L_DATAPAGE(R4),R4	; GET ADDRESS OF DATAPAGE
					; R2 = PORT NUMBER
					; R3 = ADP ADDRESS
					; R4 = DATAPAGE ADDRESS
	PUSHR	#^M<R3,R4>		; SAVE R3-R4
	BBSSI	R2,SHD$W_POLL(R4),DEQUEUE_BLOCK ; INDICATE THIS PROCESSOR ACTIVE
;
; DEQUEUE THE NEXT REQUEST BLOCK IN OUR WORK QUEUE AND REQUEUE TO THE
; APPROPRIATE FORK QUEUE.
;
DEQUEUE_BLOCK:				; DEQUEUE NEXT REQUEST BLOCK
	MOVQ	(SP),R3			; RESTORE R3-R4
	QRETRY	SUCCESS=10$-		; DEQUEUE THE NEXT REQUEST BLOCK
	REMQHI	SHD$Q_PRQWRK(R4)[R2],R5	;
	BUG_CHECK BADQHDR		; REMQHI FAILED - BAD QUEUE HEADER
10$:	BVS	BLOCK_AVAIL		; IF V-SET, NO BLOCKS LEFT
	PUSHAB	DEQUEUE_BLOCK		; SET RETURN PC
	PUSHAB	W^REQUEST_DISP		; SET FORK PC
	JMP	G^EXE$FORK		; INSERT BLOCK IN FORK QUEUE
;
; IF THERE ARE ANY FORK PROCESSES ON THIS PROCESSOR WAITING FOR INTER-PROCESSOR
; REQUEST BLOCKS, AND IF ANY BLOCKS ARE NOW AVAILABLE, GIVE THEM TO THE
; PROCESSES AND RESTART THEM.
;
BLOCK_AVAIL:				; CHECK IF ANY BLOCKS AVAILABLE
	BBC	R2,SHD$W_PRQWAIT(R4),RESOURCE_AVAIL ; IF CLR, NO PROCESSES WAITING
10$:	MOVQ	(SP),R3			; RESTORE R3-R4
	QRETRY	SUCCESS=20$-		; ATTEMPT TO ALLOCATE A FREE BLOCK
	REMQHI	SHD$Q_PRQ(R4),R5	;
	BUG_CHECK BADQHDR		; REMQHI FAILED - BAD QUEUE HEADER
20$:	BVS	RESOURCE_AVAIL		; IF V-SET, NO BLOCK AVAILABLE
	REMQUE	@ADP$L_PRQQFL(R3),R1	; GET NEXT WAITING FORK BLOCK
	BNEQ	30$			; IF NEQ, NOT LAST ENTRY
	BBCCI	R2,SHD$W_PRQWAIT(R4),30$ ; ELSE LAST, CLEAR WAITING FLAG
30$:	BVS	50$			; IF SET, NO PROCESSES LEFT
	MOVL	R1,R3			; SET ADDRESS OF FORK BLOCK
	MOVB	FKB$B_FIPL(R3),FKB$B_FIPL(R5) ; SET FORK IPL
	PUSHAB	B^10$			; SET RETURN PC
	PUSHAB	B^40$			; SET FORK PC
	JMP	G^EXE$FORK		; INSERT BLOCK IN FORK QUEUE
40$:
	MOVL	R5,R2			; SET ADDRESS OF REQUEST BLOCK
	MOVL	R3,R5			; SET ADDRESS OF DRIVER FORK BLOCK
	MOVQ	FKB$L_FR3(R5),R3	; RESTORE REGISTERS
	PUSHL	FKB$L_FPC(R5)		; SET RETURN ADDRESS OF HANDLER CALLER
	BRW	RETURN_BLOCK		; RETURN TO HANDLER
	RSB				;
50$:
	BSBW	DEALLOC_BLOCK		; DEALLOCATE UNEEDED BLOCK
;
; IF THERE IS A RESOURCE NOW AVAILABLE THAT PROCESS(S) ON THIS PROCESSOR
; ARE WAITING FOR, CREATE A FORK PROCESS TO REPORT THE AVAILABILITY TO
; THE SCHEDULER.
;
RESOURCE_AVAIL:				;
	BBC	R2,SHD$W_RESSUM(R4),50$ ; IF CLR, NONE TO REPORT
	BBSSI	R2,SHD$W_PRQWAIT(R4),50$ ; ASSUME NO BLOCKS AVAILABLE
					; AND IF THERE ALREADY AREN'T, EXIT
	QRETRY	SUCCESS=20$-		; ATTEMPT TO ALLOCATE A BLOCK
	REMQHI	SHD$Q_PRQ(R4),R5	;
	BUG_CHECK BADQHDR		; REMQHI FAILED - BAD QUEUE HEADER
20$:	BVS	50$			; IF V-SET, NO BLOCK AVAILABLE
	BBCCI	R2,SHD$W_PRQWAIT(R4),30$ ; CLEAR WAIT FLAG
30$:	BBCCI	R2,SHD$W_RESSUM(R4),40$	; CLEAR RESOURCE REPORT SUMMARY
40$:	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5) ; SET FORK IPL
	MOVW	#PRQ$C_EXEC,PRQ$W_DISPATCH(R5) ; SET EXEC DISPATCHER ID
	MOVW	#PRQ$C_RESAVL,PRQ$W_REQTYPE(R5) ; SET RESOURCE AVAILABLE TYPE
	PUSHAB	B^50$			; SET RETURN PC
	PUSHAB	W^REQUEST_DISP		; SET FORK PC
	JMP	G^EXE$FORK		; CREATE FORK PROCESS
50$:	ADDL	#8,SP			; REMOVE SAVED R3-R4
INT_EXIT:				; EXIT INTERRUPT
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	REI				;

	.PAGE
	.SBTTL	INTER-PROCESSOR REQUEST DISPATCHER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY THE FORK PROCESS DISPATCHER WHEN
;	IT DISPATCHES A FORK BLOCK THAT IS AN INTER-PROCESSOR REQUEST
;	BLOCK.
;
; INPUTS:
;
;	R0-R2 = SCRATCH.
;	R3 = ADAPTER CONTROL BLOCK ADDRESS.
;	R4 = SHARED MEMORY DATAPAGE ADDRESS.
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS.
;
; DISPATCHING OCCURS AS FOLLOWS:
;
;	THE REQUEST DISPATCHER ID CODE IS EXAMINED AND IF IT IS
;	AN EXECUTIVE REQUEST (PRQ$C_EXEC) THEN THE EXEC REQUEST HANDLER
;	IS CALLED.  IF IT IS NOT THE EXECUTIVE REQUEST ID, THE ID
;	CODE IS USED AS AN INDEX INTO THE DRIVER DISPATCHER VECTOR
;	TABLE TO CALL THE DRIVER INTER-PROCESSOR REQUEST DISPATCHER.
;
;	WHEN THE CALLED DISPATCHER RETURNS, THE REQUEST BLOCK IS
;	DEALLOCATED TO THE SHARED MEMORY REQUEST QUEUE AND A RETURN
;	TO THE FORK PROCESS DISPATCHER IS EXECUTED.
;
;--
REQUEST_DISP:				; PROCESSOR REQUEST DISPATCHER
	PUSHR	#^M<R3,R4,R5>		; SAVE REGISTERS
	ASSUME	PRQ$C_EXEC EQ 0
	MOVZWL	PRQ$W_DISPATCH(R5),R1	; GET DISPATCHER ID
	BNEQ	10$			; IF NEQ, NOT EXECUTIVE REQUEST
;
; CALL APPROPRIATE EXECUTIVE INTER-PROCESSOR REQUEST HANDLER
;
	PUSHAB	B^15$			; SET RETURN ADDRESS
	CASE	PRQ$W_REQTYPE(R5),<-	; CALL REQUEST HANDLER
		SETEF,-			;  UPDATE EVENT FLAGS
		RESAVL-			;  REPORT RESOURCE AVAILABLE
		>			;
5$:	BUG_CHECK UNKNPRQ		; UNKNOWN REQUEST ID
	BRB	15$			;
;
; CALL CLASS DRIVER INTER-PROCESSOR REQUEST DISPATCHER
;
10$:
	MOVL	ADP$L_VECTOR(R3),R0	; GET ADDRESS OF VECTOR TABLE
	MOVL	(R0)[R1],R0		; GET ADDRESS OF DISPATCHER
	BEQL	15$			; IF EQL, UNUSED VECTOR
					; (CAN OCCUR AFTER CRASH IF REQUESTS ARE LEFT)
	JSB	(R0)			; CALL DRIVER DISPATCHER
15$:
	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
;
; DEALLOCATE THE REQUEST BLOCK
;
DEALLOC_BLOCK:				; DEALLOCATE THE REQUEST BLOCK
	QRETRY	SUCCESS=10$-		; DEALLOCATE REQUEST BLOCK
	INSQTI	(R5),SHD$Q_PRQ(R4)	;
	BUG_CHECK BADQHDR		; INSQTI FAILED - BAD QUEUE HEADER
10$:
	MOVZWL	SHD$W_PRQWAIT(R4),R1	; AN PROCESSORS WAITING FOR A BLOCK?
	BEQL	20$			; IF EQL, NO
	BSBB	INTERRUPT_PORTS		; NOTIFY WAITING PORTS
20$:
	RSB				;

	.PAGE
	.SBTTL	INTERRUPT_PORTS - ROUTINE TO INTERRUPT SELECTED PORTS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS THE INTERRUPT REQUEST BITS FOR THE SELECTED PORTS.
;
; INPUTS:
;
;	R1 = MASK OF PORTS TO BE INTERRUPTED.
;	R3 = ADAPTER CONTROL BLOCK ADDRESS
;--
INTERRUPT_PORTS:			;
	MOVZBL	ADP$B_PORT(R3),R0	; GET OUR PORT NUMBER
	MULL	#MPM$C_PORTS,R0		; COMPUTE INTERRUPT REQUEST BIT #
	ADDL	#MPM$V_IIR_CTL,R0	; ...
	ASHL	R0,R1,R0		; ...
	MOVL	ADP$L_CSR(R3),R1	; GET ADAPTER CSR ADDRESS
	MOVL	R0,MPM$L_IIR(R1)	; SET PORTS' INTERRUPT REQUEST BIT(S)
	RSB				;

	.PAGE
	.SBTTL	MA$INITIAL - INITIALIZE MULTI-PORT MEMORY ADAPTER
;++
;
; MPM$INITIAL - INITIALIZE MULTI-PORT MEMORY ADAPTER
;
; THIS ROUTINE IS CALLED AT SYSTEM INTIALIZATION AND AFTER A POWER
; RECOVERY RESTART TO INITIALIZE THE PORT ADAPTER BY CLEARING ANY
; ERRORS AND ENABLING ALL INTERRUPTS.
;
; INPUTS:
;
;	R4 = ADDR OF ADAPTER CSR.
;
;	IPL = 31
;
; OUPUTS:
;
;	ANY ERRORS IN PORT ARE CLEARED AND ALL INTERRUPTS ARE ENABLED.
;--
MA$INITIAL::				; INTIALIZE PORT
	CLRL	MPM$L_CR(R4)		; CLEAR INTERRUPT ENABLE AND DIAG BITS
	CLRL	MPM$L_SR(R4)		; CLEAR INVALIDATE DISABLE AND DIAG BITS
	MOVL	MPM$L_INV(R4),R0	; GET INVALIDATION REGISTER CONTENTS
	BICL	#^C<MPM$M_INV_STADR>,R0	; CLEAR ALL BITS BUT STARTING ADDRESS
	ASSUME	MPM$V_INV_ID EQ 0	; CACHED ID'S START AT BIT 0
	BISL3	#1@0,R0,MPM$L_INV(R4)	; SET CPU (NEXUS 0) AS CACHED
	CLRL	MPM$L_CSR1(R4)		; CLEAR DIAGNOSTIC BITS
	CLRL	MPM$L_MR(R4)		; CLEAR DIAGNOSTIC BITS
	MOVL	#MPM$M_CSR_PU,-		; CLEAR ANY POWER-UP STATUS
		MPM$L_CSR(R4)		;
	MOVL	#MPM$M_CR_ERRS,-	; CLEAR ANY PORT ERRORS
		MPM$L_CR(R4)		;
	MOVL	#MPM$M_SR_SS!-		; CLEAR ANY STATUS ERRORS AND
		MPM$M_SR_IDL!-		;  ENABLE ERROR INTERRUPTS
		MPM$M_SR_IT!-		;
		MPM$M_SR_AGP!-		;
		MPM$M_SR_MXF!-		;
		MPM$M_SR_ACA!-		;
		MPM$M_SR_EIE,-		;
		MPM$L_SR(R4)		;
	MOVL	#MPM$M_ERR_ELR!-	; CLEAR ANY ARRAY ERRORS
		MPM$M_ERR_IMP,-		;
		MPM$L_ERR(R4)		;
	BBS	S^#EXE$V_CRDENABL,-	; BRANCH IF CRD ERROR LOGGING ENABLED
		EXE$GL_DEFFLAGS,10$	;
	MOVL	#MPM$M_ERR_ICRD,-	; ELSE, INHIBIT CRD ERROR LOGGING
		MPM$L_ERR(R4)		;
10$:	MOVL	#MPM$M_CSR1_MIA,-	; CLEAR ANY ERROR
		MPM$L_CSR1(R4)		;
	CLRL	MPM$L_MR(R4)		; CLEAR ANY DIAGNOSTIC SETTINGS
	MOVL	MPM$L_CSR(R4),R0	; GET CSR REGISTER
	EXTZV	#MPM$V_CSR_PORT,-	; GET PORT NUMBER
		#MPM$S_CSR_PORT,R0,R0	;
	MULL	#MPM$C_PORTS,R0		; COMPUTE INTERRUPT ENABLE BIT #
	ADDL	#MPM$V_IIE_CTL,R0	; ...
	ASHL	R0,#^XF,MPM$L_IIE(R4)	; ENABLE INTERPORT INTERRUPTS
	MOVL	#MPM$M_CR_MIE!-		; ENABLE ALL INTERRUPTS
		MPM$M_CR_EIE,-		;
		MPM$L_CR(R4)		;
					;  FROM ALL PORTS
	RSB				; RETURN
	.PAGE
	.SBTTL	UPDATE LOCAL COPY OF EVENT FLAG CLUSTER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE HANDLES THE INTER-PROCESSOR REQUEST TO COPY THE MASTER
;	COMMON EVENT FLAGS INTO THE SLAVE COMMON EVENT BLOCK.  SOME PRQS
;	MAY BE DELIVERED AFTER THE SLAVE COMMON EVENT BLOCK HAS BEEN
;	DELETED.  THIS HAPPENS FREQUENTLY AFTER A PROCESSOR CRASHES
;	AND REBOOTS.  THE LOGIC HANDLES THIS BY IGNORING THE PRQ.
;
; INPUTS:
;
;	R4 = SHARED MEMORY DATA PAGE ADDRESS
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL - SUCCESSFUL RETURN
;--
SETEF:
	DSBINT	#IPL$_SYNCH		; RAISE TO SYNCH FOR REFCNT CHANGE
	MOVZWL	PRQ$L_PARAM(R5),R0	; GET INDEX TO MASTER CEB
	ADDL3	SHD$L_CEFPTR(R4),R4,R3	; GET ADR OF 1ST MASTER CEB
	MOVZWL	CEB$W_SIZE(R3),R2	; GET THE SIZE OF ONE MASTER CEB
	MULL2	R0,R2			; GET BYTE OFFSET TO THIS MASTER
	ADDL2	R2,R3			; R3=ADR OF MASTER CEB
	MOVZWL	PRQ$W_TO_PORT(R5),R1	; RECEIVER PORT #
	MOVL	CEB$L_VASLAVE1(R3)[R1],R1 ; R1=ADR OF SLAVE CEB, OR 0
	BEQL	40$			; BR IF SLAVE NO LONGER EXISTS
	MOVL	CEB$L_EFC(R3),CEB$L_EFC(R1) ; COPY FLAGS FROM MASTER
	PUSHR	#^M<R3,R4,R5,R6>	; SAVE REGISTERS
	MOVAB	CEB$L_WQFL(R1),R6	; GET HEAD OF WAIT QUEUE FOR CEFC
	MOVZBL	#PRI$_IOCOM,R2		; SET PRIORITY INCREMENT
	MOVL	(R6),R4			; GET FIRST PCB IN WAIT QUEUE
20$:	CMPL	R4,R6			; IS THIS THE END OF THE QUEUE?
	BEQL	30$			; BR IF END OF QUEUE
	MOVL	(R4),R5			; REMEMBER NEXT PCB IN QUEUE
	MOVAL	<CEB$L_EFC-CEB$L_WQFL>(R6),R0 ; POINT TO EVENT FLAG MASK
	BSBW	EXE$CHKWAIT2		; CHECK IF THE PROCESS CAN RUN NOW
	MOVL	R5,R4			; GET NEXT PCB IN WAIT QUEUE
	BRB	20$			; CONTINUE LOOPING THROUGH ALL OF QUEUE
30$:					; NO MORE PCB'S IN WAIT QUEUE
	POPR	#^M<R3,R4,R5,R6>	; RESTORE REGISTERS
40$:					; NO SLAVE CEB EXISTED, SO NO WAITERS
	MOVZBL	#SS$_NORMAL,R0		; RETURN SUCCESS STATUS
	ENBINT				; LOWER FROM SYNCH
	RSB				; RETURN

	.PAGE
	.SBTTL	REPORT RESOURCE AVAILABILITY TO LOCAL SYSTEM
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE HANDLES THE INTERPROCESSOR REQUEST TO REPORT
;	THAT A RESOURCE IS AVAILABLE TO THE LOCAL SYSTEM.
;
; INPUTS:
;
;	R3 = ADAPTER CONTROL BLOCK ADDRESS.
;	R4 = SHARED MEMORY DATAPAGE ADDRESS.
;	R5 = INTER-PROCESSOR REQUEST BLOCK ADDRESS.
;
; OUTPUTS:
;
;	RESOURCE AVAILABILITY IS REPORTED, THEREBY UNBLOCKING ANY PROCESSES
;	THAT ARE WAITING FOR THE RESOURCE.
;--
RESAVL:					;
	DSBINT	#IPL$_SYNCH		; SYNCHRONIZE DATABASE ACCESS
	MOVZBL	ADP$B_PORT(R3),R2	; GET OUR PORT NUMBER
	PUSHR	#^M<R2,R3>		; SAVE REGISTERS
	MOVL	#1,R0			; INIT RESOURCE NUMBER

10$:	MOVAW	SHD$W_RESAVAIL(R4)[R0],R1 ; GET ADDRESS OF AVAILABLE MASK
	BBCCI	(SP),(R1),20$		; IF CLR, RESOURCE NOT AVAILABLE
	MOVAW	SHD$W_RESWAIT(R4)[R0],R1 ; GET ADDRESS OF WAIT MASK
	BBCCI	(SP),(R1),20$		; IF CLR, NO PROCESSES WAITING
	BSBW	SCH$RAVAIL		; REPORT RESOURCE AVAILABLE
20$:	AOBLSS	#RSN$_MAX,R0,10$	; INCREMENT RESOURCE NUMBER AND LOOP
	POPR	#^M<R2,R3>		; RESTORE REGISTERS
	ENBINT				; RESTORE IPL
	RSB

	.END
