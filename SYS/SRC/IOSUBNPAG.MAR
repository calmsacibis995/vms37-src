	.TITLE	IOSUBNPAG - NONPAGED I/O RELATED SUBROUTINES
	.IDENT	'V03-000'
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 13-JUN-76
;
;
; NONPAGED I/O RELATED SUBROUTINES
;
; MODIFICATION HISTORY:
;
;	V02-025	RLRATLRQ	Robert L. Rappaport		1-Mar-1982
;		Modified IOC$ALTREQCOM in conjunction with changes to
;		DUDRIVER's FUNCTION_EXIT routine, to allow MOUNT
;		VERIFICATION to work with Disk Class Driver.
;
;	V02-024	RLRMAPU1	Robert L. Rappaport		22-Jan-1982
;		For UDA map and datapath allocation calls, changed
;		destination of UBMD from @CDRP$L_LBUFH_AD to CDRP$L_UBARSRCE.
;		Also for UDA datapath deallocation, eliminated test
;		for CDRP fork block since previous change (RLRDPNW)
;		changed UDA datapath allocation to nowait which guarantees
;		that only UCB fork blocks can be on this wait Q.
;
;	V02-023	RNG0001		Rod N. Gamache			05-Jan-1982
;		Fix references no longer in word range.
;
;	V02-022	RLRDPNW		Robert L. Rappaport		30-Dec-1981
;		Made IOC$REQDATAPUDA a NOWAIT entrypoint.  If no data paths
;		are available, it simply returns.  Also changed BLSS
;		instruction in RELDATAP_COMMON to BLEQ.  This allows a
;		call to release the direct data path to simply return.
;
;	V02-021	RLRMAPU		Robert L. Rappaport		21-Dec-1981
;		Changed references in IOC$RELMAPUDA from CDRP$T_LBUFHNDL
;		to @CDRP$L_LBUFH_AD.
;
;	V02-020	STJ0146		Steven T. Jeffreys	01-Dec-1981
;		Added the IOC$BROADCAST routine.
;
;	V02-019	RLR0003		Robert L. Rappaport	18-Nov-1981
;		Make IOC$ALTREQCOM a global entry point.
;
;	V02-018	RLRMAP		Robert L. Rappaport	6-Nov-1981
;		Major rework of the UNIBUS map register and data path
;		allocation routines.  Two major objectives accomplished
;		by this rework.  First the routines were made compatible
;		with MAP calls (thru UDA port driver).  Second the
;		data structure maintaining the state of UNIBUS map register
;		allocation has been changed from a bit map to an array
;		of descriptors that define continguous extents of available
;		map registers.
;
;	V02-017	LJK0076		Lawrence J. Kenah	3-Nov-1981
;		Remove check for "queue previously not empty" when making
;		software interrupt request. The request is always made.
;
;	V02-016	ROW0040		Ralph O. Weber		27-OCT-1981
;		Modify IOC$DIAGBUFILL and IOC$INITIATE to assume that 
;		DDT$L_REGDUMP and DDT$L_START, respectively, contain
;		system virtual addresses. 
;
;	V02-015	RLR0002		Robert L. Rappaport	23-Oct-1981
;		Simplify IOC$ALTREQCOM so that:
;			1. It assumes that the final I/O status has
;				already been stored in IRP$L_MEDIA.
;			2. It does not complete an errorlog buffer.
;
;	V02-014	SRB0031		Steve Beckhardt		21-Aug-1981
;		Change several word displacements to longword displacements.
;
;	V02-013 ROW0016		Ralph O. Weber		14-AUG-1981
;		Change W^EXE$GL_ABSTIM in IOC$WFIKPCH and IOC$WFIRLCH to
;		L^EXE$GL_ABSTIM.  Also add 1981 to copyright list.
;
;	V02-012 ROW0011		Ralph O. Weber		6-AUG-1981
;		Alter IOC$DELMBX to convert UCB$W_CHARGE to a longword before 
;		using it to update JIB$L_BYTLM and JIB$L_BYTCNT.
;
;	V02-011 ROW0003		Ralph O. Weber		31-JUL-1981
;		Alter IOC$DIAGBUFILL and IOC$INITIATE to get DDT address
;		from UCB instead of DDB.
;
;	V02-010	RLR0001		Robert L. Rappaport	31-Jul-1981
;		Added IOC$ALTREQCOM entry point.  Alternate entry
;		point for disk and tape class drivers.
;
;	V02-009	EAD0001		Elliott A. Drayton	 6-Jul-1981
;		Add entry to Request Unibus Map Register.
;
;	V02-008	KTA0024		KERBEY T. ALTMANN	04-JUL-1981
;		CHANGED IOC$DELMBX TO CALL LOG$DELETE.
;
;	0207	STJ0048		STEVEN T. JEFFREYS,	08-JUN-1981
;		ADDED SUPPORT FOR MOUNT VERIFICATION.  THIS INCLUDES:
;			- LIBERAL REWRITE OF IOC$REQCOM.
;			- MOVED IOC$CVT_DEVNAM HERE FROM IOSUBPAGD, AND
;			  MADE THE ROUTINE CALLABLE FROM DEVICE DRIVERS.
;			- ADDED A NEW ROUTINE, IOC$MNTVER, WHICH IS
;			  A SPECIAL ROUTINE USED TO START AND COMPLETE
;			  MOUNT VERIFICATION FOR MOST DRIVERS.  DISK
;			  CLASS DRIVERS ARE AN EXCEPTION.
;
;
;	0206	KDM0086		KATHLEEN D. MORSE	07-JAN-1980
;		CHANGE UCB$W_DEVSTS TO UCB$W_STS, AND EMB$W_DV_DEVSTS TO
;		EMB$W_DV_STS.
;
;	0205	RIH0033		R. HUSTVEDT		16-OCT-1979
;		CHANGE PCB$W_BYTLM TO JIB$L_BYTLM.
;
;	0204	NPK0002		N. KRONENBERG		21-SEP-1979
;		MODIFIED IOC$RELDATAP TO ZERO THE DATAPATH 
;		NUMBER IN THE CALLERS CRB.
;
;	0203	NPKCOMET	N. KRONENBERG		11-FEB-1979
;		MODIFIED IOC$REQDATAP AND IOC$RELDATAP TO HANDLE
;		6 BIT DATAPATH NUMBERS.
;
;	0202	LMK0001		LEN KAWELL		07-FEB-1979
;		ADDED IOC$ALLOSPT ROUTINE THAT ALLOCATES SYSTEM
;		PAGE TABLE ENTRIES.
	.PAGE
;
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				;DEFINE ADP OFFSETS
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$CDRPDEF			;DEFINE CLASS DRIVER I/O REQUEST PACKET
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS FLAGS
	$DYNDEF				;DEFINE DYNAMIC POOL BLOCK TYPES
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LOGDEF				;DEFINE LOGICAL NAME BLOCK OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$TTYDEF				;DEFINE TERMINAL WRITE PACKET OFFSETS
	$UBMDDEF			;Define UNIBUS Map Descriptor structure
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE CRB VECTOR OFFSETS
	.PAGE
	.SBTTL	CANCEL I/O ON CHANNEL
;+
; IOC$CANCELIO - CANCEL I/O ON CHANNEL
;
; THIS ROUTINE IS A DEVICE INDEPENDENT CANCEL I/O ROUTINE THAT CONDITIONALLY
; MARKS THE UCB SUCH THAT THE CURRENT I/O REQUEST WILL BE CANCELED IF CONDITIONS
; WARRANT SUCH A ACTION.
;
; INPUTS:
;
;	R2 = NEGATIVE OF THE CHANNEL NUMBER.
;	R3 = CURRENT IO PACKET.
;	R4 = PCB ADDRESS.
;	R5 = UCB ADDRESS.
;
; OUTPUTS:
;
;	IF THE DEVICE IS BUSY, THE REQUEST IS FOR THE CURRENT PROCESS, AND
;	THE I/O WAS ISSUED FROM THE DESIGNATED CHANNEL, THEN THE CANCEL I/O
;	BIT IS SET IN THE CORRESPONDING UCB.
;
;	R2, R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
	.PSECT	WIONONPAGED
IOC$CANCELIO::				;CANCEL I/O ON CHANNEL
	BBC	#UCB$V_BSY,UCB$W_STS(R5),10$ ;IF CLR, DEVICE NOT BUSY
	CMPL	IRP$L_PID(R3),PCB$L_PID(R4) ;PROCESS ID MATCH?
	BNEQ	10$			;IF NEQ NO
	CMPW	R2,IRP$W_CHAN(R3)	;CHANNEL NUMBER MATCH
	BNEQ	10$			;IF NEQ NO
	BISW	#UCB$M_CANCEL,UCB$W_STS(R5) ;SET CANCEL PENDING
10$:	RSB				;
	.PAGE
	.SBTTL	DELETE MAILBOX
;+
; IOC$DELMBX - DELETE MAILBOX
;
; THIS ROUTINE IS CALLED TO CHECK IF A DEVICE IS A MAILBOX AND WHETHER
; IT IS MARKED FOR DELETION.
;
; INPUTS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = UCB ADDRESS OF MAILBOX TO DELETE.
;
;	I/O DATA BASED LOCKED AND AT AST DELIVERY LEVEL.
;
; OUTPUTS:
;
;	IF THE DEVICE IS A MAILBOX, ITS REFERENCE COUNT IS ZERO, AND IT
;	IS MARKED FOR DELETE, THEN THE SPECIFIED UCB IS REMOVED FROM THE
;	MAILBOX UCB LIST AND DEALLOCATED. IF A LOGICAL NAME IS ASSOCIATED
;	WITH THE MAILBOX, THEN IT IS ALSO DELETED. THE PROCESS BUFFERED
;	I/O QUOTA IS UPDATED.
;-
 
IOC$DELMBX::				;DELETE MAILBOX
	MOVL	UCB$L_DDB(R5),R0	;GET ADDRESS OF DDB
	MOVAB	DDB$L_UCB-UCB$L_LINK(R0),R0 ;GET ADDRESS OF FIRST UCB LINK
	BBC	S^#DEV$V_MBX,UCB$L_DEVCHAR(R5),70$ ;IF CLR, DEVICE NOT MAILBOX
	TSTW	UCB$W_REFC(R5)		;REFERENCE COUNT ZERO?
	BNEQ	70$			;IF NEQ NO
	BBC	#UCB$V_DELMBX,UCB$W_DEVSTS(R5),70$ ;IF CLR, NO DELETE
10$:	MOVL	R0,R1			;SAVE ADDRESS OF LAST UCB
	MOVL	UCB$L_LINK(R1),R0	;GET ADDRESS OF NEXT UCB
	CMPL	R0,R5			;UCB ADDRESS MATCH?
	BNEQ	10$			;IF NEQ NO
	MOVL	UCB$L_LINK(R5),UCB$L_LINK(R1) ;REMOVE UCB FROM UCB LIST
	MOVL	UCB$L_CRB(R5),R2	;GET ADDRESS OF CRB
	DECW	CRB$W_REFC(R2)		;DECREMENT REFERENCE COUNT
	MOVL	UCB$L_LOGADR(R5),R1	;GET ADDRESS OF LOGICAL NAME ENTRY
	BEQL	20$			;IF EQL NONE
	MOVZBL	LOG$B_TABLE(R1),R3	;GET LOGICAL NAME TABLE NUMBER
	BSBW	LOG$LOCKW		;LOCK NAME TABLE FOR WRITE
	PUSHL	R3			;SAVE LOGICAL NAME TABLE NUMBER
	BSBW	LOG$DELETE		;DELETE LOGICAL NAME BLOCK
	POPL	R3			;RETRIEVE LOGICAL NAME TABLE NUMBER
	BSBW	LOG$UNLOCK		;UNLOCK NAME TABLE
20$:	BBS	#UCB$V_PRMMBX,UCB$W_DEVSTS(R5),40$ ;IF SET, PERMANENT MAILBOX
	MOVZWL	UCB$L_CPID(R5),R1	;GET PROCESS INDEX
	DSBINT	#IPL$_SYNCH		;SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVL	@SCH$GL_PCBVEC[R1],R1	;GET ADDRESS OF PROCESS PCB
	CMPL	PCB$L_PID(R1),UCB$L_CPID(R5) ;PROCESS ID MATCH?
	BNEQ	30$			;IF NEQ NO
	MOVL	PCB$L_JIB(R1),R0	;GET JIB ADDRESS
	MOVZWL	UCB$W_CHARGE(R5),R1	;Convert charged byte count to longword
	ADDL	R1,JIB$L_BYTLM(R0)	;Update Byte Count Limit
	ADDL	R1,JIB$L_BYTCNT(R0)	;Update Byte Count Quota
30$:	ENBINT				;ENABLE INTERRUPTS
 
;
; CLEAN UP MAILBOX MESSAGES
; THERE ARE NO OUTSTANDING I/O OPERATIONS.
;
 
40$:	REMQUE	@(R5),R0		;FETCH MESSAGE BLOCK
	BVS	50$			;IF VS THEN NONE
	BSBB	60$			;DEALLOCATE MESSAGE BLOCK
	BRB	40$			;CONTINUE UNTIL EXHAUSTED
50$:	MOVL	R5,R0			;SET ADDRESS OF BLOCK TO RELEASE
60$:	BSBW	EXE$DEANONPAGED		;DEALLOCATE MAILBOX UCB AND RETURN
70$:	RSB				;
	.PAGE
	.SBTTL	FILL DIAGNOSTIC BUFFER
;+
; IOC$DIAGBUFILL - FILL DIAGNOSTIC BUFFER
;
; THIS ROUTINE IS CALLED AT THE END OF AN I/O OPERATION, BUT BEFORE RELEASING
; THE I/O CHANNEL, TO FILL THE FINAL DEVICE PARAMETERS INTO AN INTERNAL DIAG-
; NOSTIC BUFFER IF ONE IS SPECIFIED.
;
; INPUTS:
;
;	R4 = ADDRESS OF DEVICE CSR REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF A DIAGNOSTIC BUFFER WAS SPECIFIED IN THE ORIGINAL REQUEST, THEN
;	THE COMPLETION TIME, FINAL ERROR COUNTERS, AND DEVICE REGISTERS ARE
;	FILLED INTO THE DIAGNOSTIC BUFFER.
;-
 
IOC$DIAGBUFILL::			;FILL DIAGNOSTIC BUFFER
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),10$ ;IF CLR, NO DIAGNOSTIC BUFFER
	MOVL	@IRP$L_DIAGBUF(R3),R0	;GET ADDRESS OF INTERNAL BUFFER DATA AREA
	ADDL	#8,R0			;POINT PAST START TIME
	MOVQ	EXE$GQ_SYSTIME,(R0)+	;INSERT COMPLETION TIME
	MOVZWL	UCB$B_ERTCNT(R5),(R0)+	;INSERT FINAL ERROR COUNTERS
	MOVL	UCB$L_DDT(R5),R2	;GET ADDRESS OF DDT
	JSB	@DDT$L_REGDUMP(R2)	;CALL DEVICE SPECIFIC REGISTER DUMP ROUTINE
10$:	RSB				;
	.PAGE
	.SBTTL	RELEASE I/O CHANNEL
;+
; IOC$RELCHAN - RELEASE ALL I/O CHANNELS
; IOC$RELSCHAN - RELEASE SECONDARY I/O CHANNEL
;
; THIS ROUTINE IS CALLED AT THE END OF AN I/O OPERATION TO RELEASE ALL
; CHANNELS THE I/O WAS BEING PERFORMED ON.
;
; INPUTS:
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE CHANNELS ARE RELEASED AND AN ATTEMPT IS MADE TO REMOVE THE NEXT
;	WAITING DRIVER PROCESS FROM EACH CHANNEL QUEUE. IF A DRIVER PROCESS
;	IS WAITING, THEN THE CHANNEL IS ASSIGNED TO THAT DRIVER PROCESS AND
;	IT IS CALLED VIA A JSB TO ITS CHANNEL WAIT RETURN ADDRESS. WHEN THE
;	CALLED DRIVER PROCESS RETURNS, A RETURN IS MADE TO THE DRIVER PROCESS
;	THAT RELEASED THE CHANNEL. IF THERE IS NO DRIVER PROCESS WAITING FOR
;	THE CHANNEL, THEN THE CHANNEL STATUS IS SET TO IDLE.
;
;	R3 AND R4 ARE PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
IOC$RELSCHAN::				;RELEASE SECONDARY I/O CHANNEL
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONARY CRB
	BRB	20$			;
IOC$RELCHAN::				;RELEASE I/O CHANNEL
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONDARY CRB
	BEQL	10$			;IF EQL NONE
	BSBB	20$			;RELEASE SECONDARY CHANNEL
10$:	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
20$:	BBC	#CRB$V_BSY,CRB$B_MASK(R0),30$ ;IF CLR, THEN CHANNEL NOT BUSY
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1 ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R1)	;DRIVER PROCESS OWN CHANNEL?
	BNEQ	30$			;IF NEQ NO
	REMQUE	@CRB$L_WQFL(R0),R2	;GET ADDRESS OF NEXT DRIVER FORK BLOCK
	BVS	40$			;IF VS NO DRIVER PROCESS WAITING
	PUSHR	#^M<R3,R4,R5>		;SAVE CONTEXT OF CURRENT DRIVER PROCESS
	MOVL	R2,R5			;COPY ADDRESS OF DRIVER PROCESS FORK BLOCK
	MOVL	UCB$L_FR3(R5),R3	;LOAD WAITING DRIVER PROCESS CONTEXT
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	MOVL	R5,IDB$L_OWNER(R1)	;SET ADDRESS OF OWNER PROCESS UCB
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT CHANNEL WAIT RETURN ADDRESS
	POPR	#^M<R3,R4,R5>		;RESTORE PREVIOUS DRIVER PROCESS CONTEXT
30$:	RSB				;
40$:	CLRL	IDB$L_OWNER(R1)		;CLEAR OWNER UNIT UCB ADDRESS
	BICB	#CRB$M_BSY,CRB$B_MASK(R0) ;CLEAR CHANNEL BUSY
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	REQUEST I/O CHANNEL
;+
; IOC$REQPCHANH - REQUEST PRIMARY I/O CHANNEL HIGH PRIORITY
; IOC$REQSCHANH - REQUEST SECONDARY I/O CHANNEL HIGH PRIORITY
; IOC$REQPCHANL - REQUEST PRIMARY I/O CHANNEL LOW PRIORITY
; IOC$REQSCHANL - REQUEST SECONDARY I/O CHANNEL LOW PRIORITY
;
; THESE ROUTINES ARE CALLED TO REQUEST AN I/O CHANNEL TO PERFORM AN I/O
; OPERATION ON.
;
; INPUTS:
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
; OUTPUTS:
;
;	IF THE SPECIFIED I/O CHANNEL IS IDLE, THEN IT IS IMMEDIATELY
;	ASSIGNED TO THE CURRENT DRIVER PROCESS. ELSE THE DRIVER PROCESS
;	CONTEXT IS SAVED IN ITS FORK BLOCK, THE FORK BLOCK IS INSERTED
;	IN THE CHANNEL WAIT QUEUE, AND A RETURN TO THE DRIVER PROCESS'
;	CALLER IS EXECUTED.
;
;	WHEN THE CHANNEL IS ASSIGNED, THE CSR ADDRESS OF THE ASSIGNED
;	CONTROLLER IS RETURNED TO THE CALLER IN REGISTER R4.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
IOC$REQSCHANH::				;REQUEST SECONDARY I/O CHANNEL HIGH PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONDARY CRB
	BRB	10$			;
IOC$REQSCHANL::				;REQUEST SECONDARY I/O CHANNEL LOW PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONDARY CRB
	BRB	20$			;
IOC$REQPCHANH::				;REQUEST PRIMARY I/O CHANNEL HIGH PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
10$:	MOVL	R0,R2			;SET ADDDRESS OF WAIT QUEUE LISTHEAD
	BRB	30$			;
IOC$REQPCHANL::				;REQUEST PRIMARY I/O CHANNEL LOW PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
20$:	MOVL	CRB$L_WQBL(R0),R2	;GET ADDRESS OF LAST ENTRY IN QUEUE
30$:	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1 ;GET ADDRESS OF IDB
	BBSS	#CRB$V_BSY,CRB$B_MASK(R0),40$ ;IF SET, THEN CHANNEL BUSY
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	MOVL	R5,IDB$L_OWNER(R1)	;SET OWNER UCB ADDRESS
	RSB				;
40$:	MOVL	R3,UCB$L_FR3(R5)	;SAVE R3 IN FORK BLOCK
	POPL	UCB$L_FPC(R5)		;SAVE CHANNEL WAIT RETURN ADDRESS
	INSQUE	UCB$L_FQFL(R5),CRB$L_WQFL(R2) ;INSERT DRIVER PROCESS IN CHANNEL WAIT QUEUE
	CMPL	R5,IDB$L_OWNER(R1)	;CURRENT DRIVER PROCESS OWNER?
	BNEQ	50$			;IF NEQ, BRANCH TO RETURN
	BRW	IOC$RELCHAN		;IF EQL BRW TO RELEASE CHANNELS
50$:
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	I/O Request Completion Processing for Class Drivers

;+
; IOC$ALTREQCOM - I/O Request Complete Alternate Entry.
;
; This routine is entered when an I/O operation is completed on one
;	one of the devices using the disk or tape class drivers.
;	The packet is inserted in the I/O finish queue for I/O post
;	processing.
;
; INPUTS:
;
;	R0 = First  longword of I/O status
;	R1 = Second longword of I/O status
;	R5 = CDRP address
;
; OUTPUTS:
;
;	The I/O packet is inserted in the I/O Post Processing Queue,
;	a Software interrupt is requested to initiate I/O Post
;	Processing.
;-

IOC$ALTREQCOM::
	MOVAB	CDRP$L_IOQFL(R5),R3	; R3 => IRP section of CDRP. This is
					;  for compatibility with rest of QIO
					;  logic.
	MOVL	IRP$L_UCB(R3),R5	; R5 => UCB.
	INCL	UCB$L_OPCNT(R5)		; Increment operations completed
 
	BLBC	R0,20$			; LBC implies I/O error, so goto call
					;  MOUNT VERIFICATION just in case.
10$:
	MOVQ	R0,IRP$L_MEDIA(R3)	; Save final I/O status in IRP.

	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_IO		; Insert end of I/O transaction message
 
	.ENDC
 
	INSQUE	(R3),@L^IOC$GL_PSBL	; Insert packet in POST process queue
	SOFTINT	#IPL$_IOPOST		; Initiate SOFTWARE INTERRUPT
	RSB
20$:
	BSBW	EXE$MOUNTVER		; If LBC, call MOUNT VERIFICATION.
	BRB	10$			; Go back to normal flow.
	.PAGE
	.SBTTL	I/O REQUEST COMPLETION PROCESSING
;+
; IOC$REQCOM - I/O REQUEST COMPLETE
;
; THIS ROUTINE IS ENTERED WHEN AN I/O OPERATION IS COMPLETED ON A
; DEVICE UNIT. THE FINAL I/O STATUS IS STORED IN THE ASSOCIATED I/O
; PACKET AND THE PACKET IS INSERTED IN THE I/O FINISH QUEUE FOR
; I/O POST PROCESSING. DEVICE UNIT BUSY IS CLEARED AND AN ATTEMPT
; IS MADE TO START ANOTHER I/O REQUEST ON THE DEVICE UNIT.
;
; IF THE I/O REQUEST COMPLETED WITH AN ERROR, AND THE DEVICE IS
; A DISK, THEN BRANCH TO THE MOUNT VERIFICATION CODE, WHICH WILL
; DETERMINE IF THE SITUATION REQUIRES MOUNT VERIFICATION.
;
; IF MOUNT VERIFICATION IS IN PROGRESS, NO FURTHER I/O REQUESTS WILL
; BE INITIATED.  THIS HAS A SIDE EFFECT OF KEEPING THE 'BSY' BIT IN
; WHATEVER STATE IT IS CURRENTLY IN.  FOR CONVENTIONAL DISK DRIVERS,
; THE BSY BIT WILL BE LEFT ON, WHICH WILL BLOCK $QIO FROM INITIATING
; ANY NEW I/O ON THE DEVICE.  FOR THE DISK CLASS DRIVER, THE BUSY 
; BIT WILL BE OFF, WHICH WILL ALLOW $QIO TO INITIATE NEW I/O.
;
; INPUTS:
;
;	R0 = FIRST LONGWORD OF I/O STATUS.
;	R1 = SECOND LONGWORD OF I/O STATUS.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE I/O PACKET IS INSERTED IN THE I/O POST PROCESSING QUEUE
;	AND DEVICE UNIT BUSY IS CLEARED. A SOFTWARE INTERRUPT IS
;	REQUESTED TO INITIATE I/O POST PROCESSING.
;-
 
	.ENABL	LSB
IOC$REQCOM::				;I/O DONE PROCESSING
	BBCC	#UCB$V_ERLOGIP,UCB$W_STS(R5),10$ ;IF CLR, ERROR LOG NOT IN PROGRESS
	MOVL	UCB$L_EMB(R5),R2	;GET ADDRESS OF ERROR MESSAGE BUFFER
	MOVW	UCB$W_STS(R5),EMB$W_DV_STS(R2) ;INSERT FINAL DEVICE STATUS
	MOVW	UCB$B_ERTCNT(R5),EMB$B_DV_ERTCNT(R2) ;INSERT FINAL ERROR COUNTERS
	MOVQ	R0,EMB$Q_DV_IOSB(R2)	;INSERT FINAL I/O STATUS
	PUSHL	R0			;SAVE R0
	BSBW	ERL$RELEASEMB		;RELEASE ERROR MESSAGE BUFFER
	POPL	R0			;RESTORE R0
10$:	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	INCL	UCB$L_OPCNT(R5)		;INCREMENT OPERATIONS COMPLETED
	BLBC	R0,DISKCHK		;IF I/O ERROR, CHECK FOR DISK DEVICE
;
; DO NOT SAVE THE I/O STATUS IN THE IRP UNTIL IT HAS BEEN DECIDED THAT
; MOUNT VERIFICATION IS NOT NECESSARY.  THIS IS TO AVOID OVERWRITING THE
; PHYSICAL DISK ADDRESS STORED IN THE IRP AT OFFSET IRP$L_MEDIA.
;
20$:	MOVQ	R0,IRP$L_MEDIA(R3)	;STORE FINAL I/O STATUS
 
	.IF DF	CA$_MEASURE_IOT
 
	TSTL	L^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	DO_PMS			;BRANCH IF YES
 
	.ENDC

PMSEND:	INSQUE	(R3),@L^IOC$GL_PSBL	;INSERT PACKET IN POST PROCESS QUEUE
	SOFTINT	#IPL$_IOPOST		;INITIATE SOFTWARE INTERRUPT
	BBS	#UCB$V_MNTVERIP,-	;BRANCH IF MOUNT VERIFICATION IN PROGRESS
		UCB$W_STS(R5),RELEASE	;(NOTE THIS LEAVES 'BSY' AS IS)
NXTIRP:	REMQUE	@UCB$L_IOQFL(R5),R3	;REMOVE I/O PACKET FROM DEVICE UNIT QUEUE
	BVC	IOC$INITIATE		;IF VC INITIATE NEXT FUNCTION
	BICW	#UCB$M_BSY,UCB$W_STS(R5) ;CLEAR UNIT BUSY
RELEASE:				;RELEASE ALL CHANNELS
	BRW	IOC$RELCHAN		;
;
; IF THIS IS A DISK DEVICE, CALL THE MOUNT VERIFICATION ROUTINE
; TO DETERMINE IF MOUNT VERIFICATION IS NECESSARY.  IF NOT, CONTROL
; WILL RETURN, AND THE REQUEST WILL BE COMPLETED IN THE NORMAL MANNER.
;
DISKCHK:
	CMPB	#DC$_DISK,-		;IS THIS DEVICE A DISK?
		UCB$B_DEVCLASS(R5)	;
	BNEQ	20$			;BRANCH IF NOT
	BSBW	EXE$MOUNTVER		;START MOUNT VERIFICATION
	BRB	20$			;COMPLETE I/O REQUEST

	.IF DF	CA$_MEASURE_IOT

DO_PMS:	BSBW	PMS$END_IO		;INSERT END OF I/O TRANSACTION MESSAGE
	BRB	PMSEND			;REJOIN COMMON CODE

	.ENDC
	.DSABL	LSB
	.PAGE
	.SBTTL	MOUNT VERIFICATION HELPER
;++
; IOC$MNTVER	- Assist driver with mount verification.
;
; This routine is called by EXE$MOUNTVER to perform some driver-specific
; actions necessary for mount verification.  This routine is used by non-
; CLASS drivers, and is called by default if EXE$MOUNTVER finds the address
; of IOC$RETURN in DDT$L_MNTVER.
;
; Inputs:
;
;	R3	= IRP address or 0
;	R5	= UCB address
;
; Outputs:
;
;	None.
;
; Side effects:
;
;	If R3 contains an IRP address, the IRP will be queued to the
;	head of the UCB's IRP work queue.  If R3 contains is zero, then
;	remove the IRP from the head of the UCB's work queue and attempt
;	to initiate the I/O.
;--

IOC$MNTVER::				;Driver-specific mount verification code
	TSTL	R3			;Check IRP address
	BEQL	NXTIRP			;Branch if none
	INSQUE	IRP$L_IOQFL(R3),-	;Requeue the IRP
		UCB$L_IOQFL(R5)		;
	RSB				;Return
	.PAGE
	.SBTTL	INITIATE I/O FUNCTION ON DEVICE
;+
; IOC$INITIATE - INITIATE NEXT FUNCTION ON DEVICE
;
; THIS ROUTINE IS CALLED TO INITIATE THE NEXT FUNCTION ON A DEVICE BY CLEARING
; STATUS BITS, SETTING THE OPERATION START TIME IF A DIAGNOSTIC BUFFER IS
; SPECIFIED, AND CALLING THE DRIVER AT ITS START I/O ENTRY POINT.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	CANCEL I/O, POWERFAIL, AND TIME OUT STATUS BITS ARE CLEARED, THE
;	CURRENT SYSTEM TIME IS FILLED INTO THE INTERNAL DIAGNOSTIC BUFFER
;	IF ONE IS SPECIFIED, AND THE DRIVER IS CALLED AT ITS START I/O ENTRY
;	POINT.
;-
 
IOC$INITIATE::				;INITIATE I/O FUNCTION
	MOVL	R3,UCB$L_IRP(R5)	;SAVE I/O PACKET ADDRESS
 
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$START_IO		;INSERT START OF I/O TRANSACTION MESSAGE
 
	.ENDC
 
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;COPY TRANSFER PARAMETERS
	BICW	#UCB$M_CANCEL!UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR CANCEL AND TIME OUT
	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),10$ ;IF CLR, NO DIAGNOSTIC BUFFER
	MOVL	@IRP$L_DIAGBUF(R3),R0	;GET ADDRESS OF DIAGNOSTIC BUFFER DATA AREA
	MOVQ	EXE$GQ_SYSTIME,(R0)	;INSERT I/O OPERATION START TIME
10$:	MOVL	UCB$L_DDT(R5),R0	;GET ADDRESS OF DRIVER DISPATCH TABLE
	JMP	@DDT$L_START(R0)	;START I/O OPERATION
	.PAGE
	.SBTTL	Allocate Buffered Data Path
;+
; ALLOCATE BUFFERED DATA PATH CODE -
;
; IOC$REQDATAP - Entrypoint (called from traditional drivers) where caller
;	wishes to be queued (using UCB fork block) if no buffered data path
;	is available at the time of the call.
; INPUT:
;		R5 => UCB.
;
; IOC$REQDATAPNW - Entrypoint to call when caller does not want to wait for
;	unavailable data path.
; INPUT:
;		R5 => UCB
;
; IOC$REQDATAPUDA - Entrypoint (called from UDA port driver) where CDRP
;	is used as the source of information about the request and where
;	the caller does not want to wait for unavailable datapath.
;
; INPUT:
;		R5 => CDRP
;-

IOC$REQDATAP::
	BSBB	IOC$REQDATAPNW		; Try to alloc. and get control after.
	BLBS	R0,10$			; LBS implies allocation success.

	MOVQ	R3,UCB$L_FR3(R5)	; Save driver context in UCB fork block.
	POPL	UCB$L_FPC(R5)		; Save caller's return point.
	INSQUE	UCB$L_FQFL(R5),-	; Queue fork block to resource wait queue.
		@ADP$L_DPQBL(R1)	;  Assumes IOC$ALODATAP saves R1=>ADP.
10$:	RSB				; Return to caller or caller's caller.

IOC$REQDATAPNW::
	MOVL	UCB$L_CRB(R5),R0		; R0=>CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R1	; R1=>ADP (pass to IOC$ALODATAP)
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R0),R2	; R2=>UBMD   "   "      "

	BRB	IOC$ALODATAP		; NOWAIT, RSB from IOC$ALODATAP
					;  returns to our caller.
IOC$REQDATAPUDA::
	MOVL	CDRP$L_UCB(R5),R0		; R0=>UCB.
	MOVL	UCB$L_CRB(R0),R0		; R0=>CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R1	; R1=>ADP (pass to IOC$ALODATAP).
	MOVAB	CDRP$L_UBARSRCE(R5),R2		; R2=>UBMD  "   "       "

	BRB	IOC$ALODATAP		; Branch to allocate a data path.
					;  NOWAIT, RSB from IOC$ALODATAP
					;  returns to our caller.
	.PAGE
; IOC$ALODATAP - Common subroutine called by above routines to allocate
;	a UNIBUS buffered datapath.
;
; INPUTS:
;	R1 => ADP wherein the datapath allocation bit map is stored.
;	R2 => UBA mapping descriptor in user's data structure.
;
; OUTPUTS:
;	R0 LBS - implies allocation success
;		datapath field in R2 => UBA mapping descriptor is set to the
;			number of the datapath allocated.
;		appropriate bit in datapath allocation bit map is cleared.
;	R0 LBC - implies allocation failure.
;

IOC$ALODATAP:
	BBS	#VEC$V_PATHLOCK,-	; If this user has a permanently allocated
		UBMD$B_DATAPATH(R2),10$	;  datapath, branch around to success.

	ASSUME	ADP$C_NUMDATAP  EQ  16
	FFS	#0,-			; Find first available datapath,
		#ADP$C_NUMDATAP,-	;  according to bit map.  Note failure
		ADP$W_DPBITMAP(R1),-	;  leaves R0 with the value "16", an
		R0			;  even number with the low bit clear.
	BEQL	20$			; EQL implies failure.

	INSV	R0,-			; Upon success, R0 has number of the
		#VEC$V_DATAPATH,-	;  available datapath to allocate.
		#VEC$S_DATAPATH,-	;  So we update the user's datapath
		UBMD$B_DATAPATH(R2)	;  descriptor pointed at by R2.

	BBSC	R0,ADP$W_DPBITMAP(R1),10$; And we update the bit map.
	BUG_CHECK INCONSTATE		 ; We shouldn't be here obviously.

10$:	MOVL	S^#SS$_NORMAL,R0	; Indicate allocation success.
20$:	RSB				; And we return to our caller.
	.PAGE
	.SBTTL	Release Buffered Data Path
;+
; RELEASE BUFFERED DATA PATH CODE -
;
; IOC$RELDATAPUDA - Entry point called from UDA port driver in response
;	to an UNMAP call.  Here the data as to the buffered data path
;	is in the CDRP.
;
; INPUTS:
;	R5 => CDRP
;
; IOC$RELDATAP - Entry point called from traditional drivers to release
;	the buffered datapath described in CRB$L_INTD+VEC$B_DATAPATH.
;
; INPUTS:
;	R5 => UCB
;
; OUTPUTS:
;	Datapath re-allocated (if any waiters). R0, R1, and R2 modified.
; NOTE: Since calls to IOC$REQDATAPUDA are NOWAIT, fork blocks dequeued
;	here from ADP$L_DPQFL are guaranteed to be UCB's.
;

IOC$RELDATAPUDA::
	MOVL	CDRP$L_UCB(R5),R0	; R0 => UCB.
	MOVL	UCB$L_CRB(R0),R0	; R0 => CRB.
	MOVAB	CDRP$L_UBARSRCE(R5),R2	; R2 => UBMD.
	BRB	RELDATAP_COMMON
IOC$RELDATAP::
	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R0),R2	; R2 => UBMD.
RELDATAP_COMMON:
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R1	; R1 => ADP.
	CVTBL	UBMD$B_DATAPATH(R2),R0		; Get datapath designator.
	BLEQ	10$				; If LSS permanent assignment.
						; If EQL we had NO datapath to
						;  release.
	INSV	#0,-				; Zero datapath number.
		#VEC$V_DATAPATH,#VEC$S_DATAPATH,-
		UBMD$B_DATAPATH(R2)
	EXTZV	#VEC$V_DATAPATH,-	 ; Extract datapath number.
		#VEC$S_DATAPATH,R0,R2	 ;
	REMQUE	@ADP$L_DPQFL(R1),R0	 ; R0 => next driver fork block
	BVS	20$			 ; If VS no driver process waiting

	MOVQ	R3,-(SP)		 ; Save R3, R4, R5
	PUSHL	R5			
	MOVL	R0,R5			 ; R5 => driver fork block.
	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB.
	INSV	R2,#VEC$V_DATAPATH,#VEC$S_DATAPATH,-
		CRB$L_INTD+VEC$B_DATAPATH(R1)	; Store assigned datapath #.
	MOVQ	UCB$L_FR3(R5),R3		; Restore driver context.
	JSB	@UCB$L_FPC(R5)			; Call back waiting driver.
	POPL	R5			  ; Restore deallocator's R5,R4,R3
	MOVQ	(SP)+,R3		  ;
10$:	RSB				  ; Return to deallocator.
20$:	BBCS	R2,ADP$W_DPBITMAP(R1),10$ ; Set datapath bit and exit
	BUG_CHECK INCONSTATE		  ; Inconsistent state.
	RSB				  ;
	.PAGE
	.SBTTL	REQUEST AND ALLOCATE UNIBUS MAP REGISTERS FOR CLASS DRIVER
;+
; IOC$REQMAPUDA - REQUEST AND ALLOCATE UNIBUS MAP REGISTERS FOR CLASS DRIVER
;
; THIS ROUTINE IS CALLED TO ALLOCATE UBA MAP REGISTERS AND TO MARK THE ALLOCATION
; IN THE UBA MAP REGISTER ALLOCATION DATA STRUCTURES.
;
; INPUTS:
;
;	R4 = ADDRESS OF PORT DESCRIPTOR TABLE.
;	R5 = ADDRESS OF CLASS DRIVER REQUEST PACKET (CDRP).
;
; OUTPUTS:
;
;	IF MAP REGISTERS ARE ALLOCATED FOR THE CDRP, THE APPROPRIATE FIELDS
;	IN THE CDRP ARE MODIFIED TO INDICATE WHICH REGISTERS, AND THE NUMBER
;	OF REGISTERS THAT HAVE BEEN ALLOCATED.  ALSO THE ALLOCATION DATA
;	STRUCTURE IN THE ADP IS MODIFIED.
;
;	IF MAP REGISTERS CANNOT BE ALLOCATED AT THIS TIME, THE CDRP IS
;	QUEUED ONTO THE RESOURCE WAIT LIST AND THE UCB$W_RWAITCNT IS
;	INCREMENTED.
;
;-
 
IOC$REQMAPUDA::				; Allocate UBA map registers for class driver.
	BSBB	IOC$ALOMAPUDA		; Call to allocate map registers if available.
					;  Returns R2 => ADP.

; If here, low bit of R0 tells us whether we were successful in the allocation
;	attempt.

	BLBS	R0,10$			; Branch around if successful.
	MOVQ	R3,CDRP$L_FR3(R5)	; Save driver process context
	INCW	@CDRP$L_RWCPTR(R5)	; One more CDRP, on this UCB, awaiting
					;  resources.
	POPL	CDRP$L_FPC(R5)		; Save map register wait return address
	INSQUE	CDRP$L_FQFL(R5),-
		@ADP$L_MRQBL(R2)	; Insert process in map register wait queue
10$:	RSB				;
	.PAGE
	.SBTTL	REQUEST UNIBUS MAP REGISTERS
;+
; IOC$REQMAPREG - REQUEST UNIBUS MAP REGISTERS
; IOC$REQMAPREGN - REQUEST UNIBUS MAP REGISTERS WITH ARGUMENT IN R3
;
; THIS ROUTINE IS CALLED TO REQUEST UNIBUS MAP REGISTERS TO PERFORM AN
; I/O TRANSFER.
;
; INPUTS:
;
;	R3 = NUMBER OF MAP REGISTERS TO ALLOCATE (ARGUMENT SPECIFIED ENTRY).
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	IT IS ASSUMED THAT THE CALLER OWNS THE I/O CHANNEL ON WHICH THE
;	TRANSFER IS TO OCCUR ON.
;
; OUTPUTS:
;
;	IF MAP REGISTERS HAVE BEEN PERMANENTLY ASSIGNED TO THE ASSOCIATED
;	I/O CHANNEL, THEN CONTROL IS IMMEDIATELY RETURNED TO THE CALLER.
;	ELSE AN ATTEMPT IS MADE TO ALLOCATE THE REQUESTED NUMBER OF MAP REG-
;	ISTERS. IF SUFFICIENT CONTIGUOUS MAP REGISTERS ARE FOUND, THEN THEY
;	ARE ASSIGNED TO THE ASSOCIATED I/O CHANNEL AND CONTROL IS RETURNED
;	TO THE CALLER. ELSE THE DRIVER PROCESS CONTEXT IS SAVED IN ITS FORK
;	BLOCK, THE FORK BLOCK IS INSERTED IN THE MAP REGISTER WAIT QUEUE,
;	AND A RETURN TO THE DRIVER PROCESS' CALLER IS EXECUTED.
;-
 
 	.ENABL	LSB
IOC$REQMAPREGN::			;Req. UNIBUS map reg. w/specified arg.
	BSBB	IOC$ALOUBAMAPN		;Allocate UBA map reg. arg. specified
	BRB	5$			;Go check status
IOC$REQMAPREG::				;REQUEST UNIBUS MAP REGISTERS
	BSBB	IOC$ALOUBAMAP		; ALLOCATE UBA MAP REGISTER
5$:
	BLBS	R0,10$			;IF LBS SUCCESSFUL ALLOCATION
	MOVQ	R3,UCB$L_FR3(R5)	;SAVE DRIVER PROCESS CONTEXT
	POPL	UCB$L_FPC(R5)		;SAVE MAP REGISTER WAIT RETURN ADDRESS
	INSQUE	UCB$L_FQFL(R5),@ADP$L_MRQBL(R2) ;INSERT PROCESS IN MAP REGISTER WAIT QUEUE
10$:	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	ALLOCATE UNIBUS MAP REGISTERS
;+
; IOC$ALOUBAMAP - ALLOCATE UBA MAP REGISTERS (CRB DATABASE SPECIFIED)
; IOC$ALOUBAMAPN - ALLOCATE UBA MAP REGISTERS (ARGUMENT SPECIFIED)
; IOC$ALOMAPUDA - ALLOCATE UBA MAP REGISTERS (FOR CLASS DRIVER(S))
;
; This routine is called to allocate uba map registers and to mark the allocation
;	in the map register allocation structure located in the ADP.  The state
;	of the UNIBUS map registers is maintained in a set of descriptors
;	that describe contiguous extents of allocatable (i.e. free) map
;	registers.  A map register descriptor consists of the
;	corresponding elements of two distinct arrays (of one word items)
;	located in the ADP.  These arrays, ADP$W_MRNREGARY and ADP$W_MRFREGARY,
;	contain the number of map registers and the first map register in each
;	contiguous extent of free map registers.  These arrays are each
;	preceeded by a one word field containing all 1's (-1) so that compares
;	made against the "previous" descriptor fail when the current desciptor
;	is the one whose index is zero.
;
;	ADP$L_MRACTMDRS maintains the number of active descriptors, i.e. the
;	number of elements of each array which contain valid data.
;
; INPUTS: (FOR IOC$ALOUBAMAP AND ALOUBAMAPN)
;	R3 = NUMBER OF MAP REGISTERS TO ALLOCATE (IOC$ALOUBAMAPN only).
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; INPUT:  (FOR IOC$ALOMAPUDA)
;	R5 => CDRP
;
; OUTPUTS:
;	R0 = SUCCESS INDICATION.
;	R2 => ADP
;-
	.enabl	lsb
IOC$ALOMAPUDA:
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVL	CDRP$L_BCNT(R5),R3	; Get transfer byte count
	MOVZWL	CDRP$W_BOFF(R5),R4	; Get byte offset in page
	MOVAB	^X3FF(R3)[R4],R3	; Calculate highest relative byte and round
	ASHL	#-9,R3,R3		; Calculate number of map registers required

	MOVL	CDRP$L_UCB(R5),R1		; R1 => UCB.
	MOVL	UCB$L_CRB(R1),R1		; R1 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2	; R2 => ADP.

	MOVAB	CDRP$L_UBARSRCE(R5),R1	; R1 => UBMD.
	BRB	COMMON_ALOUBAMAP	; Branch to common code.

IOC$ALOUBAMAPN::			;ALLOCATE UBA MAP REGISTERS ARGUMENT SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;
	BRB	5$			;

IOC$ALOUBAMAP::				;ALLOCATE UBA MAP REGISTERS CRB SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVZWL	UCB$W_BCNT(R5),R3	;GET TRANSFER BYTE COUNT
	MOVZWL	UCB$W_BOFF(R5),R4	;GET BYTE OFFSET IN PAGE
	MOVAB	^X3FF(R3)[R4],R3	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R3,R3		;CALCULATE NUMBER OF MAP REGISTERS REQUIRED
5$:
	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2	; R2 => ADP.
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R1),R1	; R1 => UBMD.
	BBS	#VEC$V_MAPLOCK,-		; If SET, already permanently
		UBMD$W_MAPREG(R1),40$		;  allocated, so branch around.

; Here:
;	R1 => UBMD - caller's structure where we record registers allocated
;	R2 => ADP
;	R3 =  number of map registers to allocate
;

COMMON_ALOUBAMAP:
	INCL	R3			; Round up request to next multiple
	BICB	#1,R3			;  of 2.
	CLRL	R5			; Establish loop variable.
10$:
	CMPW	R3,ADP$W_MRNREGARY(R2)[R5]	; See if enough regs described here.
	BLEQ	20$				; LEQ implies YES.

	AOBLSS	ADP$L_MRACTMDRS(R2),R5,10$	; Else branch back and continue
	CLRL	R0				; If here, allocation failure.
	BRB	50$				; Branch around to return.
20$:
	MOVW	ADP$W_MRFREGARY(R2)[R5],-	; Allocate from low end of extent
		UBMD$W_MAPREG(R1)		;  by copying 1st map reg. #.
	MOVB	R3,UBMD$B_NUMREG(R1)		; Set # of map regs allocated.
	SUBW	R3,ADP$W_MRNREGARY(R2)[R5]	; Subtract out # regs allocated.
	BNEQ	30$				; NEQ implies extent not empty,
						;   branch around deallocate.
	BSBW	DEALLOC_DESCRIP			; Call to deallocate descriptor.
	BRB	40$				;  And branch back to return.
30$:
	ADDW	R3,ADP$W_MRFREGARY(R2)[R5]	; Bump descriptor past
						;  allocated registers.
40$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success.
50$:	POPL	R5			; Restore R5,R4,R3
	MOVQ	(SP)+,R3		;
	RSB
	.dsabl	lsb
	.PAGE
	.SBTTL	Allocate a specific set of UNIBUS Map Registers
;+
; IOC$ALOUBAMAPSP
;
; This routine is called to allocate a specific set of UNIBUS Map Registers.
;
; INPUTS:
;	R3 =  # of map registers to allocate
;	R4 =  # of first map register to allocate
;	R5 => UCB
;
; OUTPUTS:
;	R0 =  Success or failure indication
;		Note R0, R1 and R2 modified.
;-

IOC$ALOUBAMAPSP::
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R2	; R2 => ADP.
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R0),R1	; R1 => UBA mapping descriptor.

	BLBC	R4,10$			; Prepare to round DOWN to even boundary.
	BICB	#1,R4			; Clear low bit if set and
	INCL	R3			;  then increment # of registers to allocate.
10$:
	INCL	R3			; Prepare to round UP to even # of registers.
	BICB	#1,R3			;

	CLRL	R5			; R5 will be index register.
20$:
	CMPW	R4,ADP$W_MRFREGARY(R2)[R5]	; Are registers we want in
						;  current extent?
	BLSS	30$			; LSS means current extent is beyond the
					;  desired registers. Therefore they are
					;  not availiable and we have failed.
	BEQL	50$			; EQL means they are at the beginning
					;  of the current extent.

; Here the registers we want are either within the middle of the current
;	extent or else beyond the current extent.

	ADDW3	ADP$W_MRFREGARY(R2)[R5],-	; R0 = 1st register beyond
		ADP$W_MRNREGARY(R2)[R5],R0	;  current extent.
	CMPW	R4,R0				; Are we in current extent?
	BLSS	40$				; LSS means YES, in current.
	AOBLSS	ADP$L_MRACTMDRS(R2),R5,20$	; Loop thru all extents.
30$:						; Failure if we fall thru.
	CLRL	R0				; Set failure code.
	BRB	80$				; And branch to return.
40$:

; Here the first register we want is greater than the first register of
;	current extent (defined by R5 = index) and is less than or equal to
;	the last register of the extent. R0 contains the # of the register just
;	beyond the current extent.  In other words,
;
;	ADP$W_MRFREGARY(R2)[R5] < R4 < R0

	SUBW	R4,R0			; R0 = length of subextent based at R4.
	CMPW	R0,R3			; Compare to # of registers needed.
	BLSS	30$			; LSS means failure.

	MOVW	R4,UBMD$W_MAPREG(R1)	; Success. Fill in user's descriptor
	MOVB	R3,UBMD$B_NUMREG(R1)	;  with base register and # of registers.

;	SUBW3	ADP$W_MRFREGARY(R2)[R5],R4,-	; Distance from beginning of
;		ADP$W_MRNREGARY(R2)[R5]		;  extent to R4 is new length.
	SUBW	R0,ADP$W_MRNREGARY(R2)[R5]	; Equivalent result.

	SUBW	R3,R0			; R0 = # regs. left in sub-extent.
	BEQL	50$			; EQL means we do not have to allocate
					;  and fill a new extent descriptor.
	INCL	R5			; R5 = index of new extent descriptor.
	MOVW	R0,-(SP)		; Save length of new extent.
	BSBW	ALLOC_DESCRIP		; Call to allocate a new descriptor.

	ADDW3	R4,R3,ADP$W_MRFREGARY(R2)[R5]	; Fill in new descriptor with
	MOVW	(SP)+,ADP$W_MRNREGARY(R2)[R5]	;  1st register and # registers.
	BRB	70$				; Branch around to success.
50$:

; Here the first register we want is equal to the first register of the current
;	extent (defined by index register R5).  In other words,
;
;	R4 = ADP$W_MRFREGARY(R2)[R5]

	CMPW	R3,ADP$W_MRNREGARY(R2)[R5]	; See if we have enough registers.
	BGTR	30$				; GTR implies failure.

	MOVW	R4,UBMD$W_MAPREG(R1)	; Success.  Fill in user's descriptor
	MOVW	R3,UBMD$B_NUMREG(R1)	;  with 1st register and # allocated.

	SUBW	R3,ADP$W_MRNREGARY(R2)[R5]	; Update current descriptor.
	BEQL	60$				; EQL means current extent now
						;  empty. Go to deallocate.
	ADDW	R3,ADP$W_MRFREGARY(R2)[R5]	; If not empty, update 1st register.
	BRB	70$				; Branch around deallocate.
60$:
	BSBW	DEALLOC_DESCRIP			; Deallocate system descriptor.
70$:	MOVL	S^#SS$_NORMAL,R0	; Set success indicator.
80$:	POPL	R5			; Restore R5,R4,R3
	MOVQ	(SP)+,R3		;
	RSB				; And return to caller.
	.PAGE
	.SBTTL	Permanently Allocate UNIBUS Map Registers
;+
; IOC$ALOUBAMAPRM  - Permanently Allocate UBA Map Registers (CRB Database Specified)
; IOC$ALOUBAMAPRMN - Permanently Allocate UBA Map Registers (Argument Specified)
;
; This routine is called to permanently allocate UNIBUS map registers.
;	Here we allocate the map registers from the highest numbered
;	available registers.
;
; INPUTS:
;	R3 =  # Registers to allocate (IOC$ALOUBAMAPRMN only)
;	R5 => UCB
;
; OUTPUTS:
;	R0 = Success indication
;
;-

	.enabl	LSB
IOC$ALOUBMAPRMN::			;ALLOCATE UBA MAP REGISTERS ARGUMENT SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	BRB	5$			;
IOC$ALOUBMAPRM::			;ALLOCATE UBA MAP REGISTERS CRB SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVZWL	UCB$W_BCNT(R5),R3	;GET TRANSFER BYTE COUNT
	MOVZWL	UCB$W_BOFF(R5),R4	;GET BYTE OFFSET IN PAGE
	MOVAB	^X3FF(R3)[R4],R3	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R3,R3		;CALCULATE NUMBER OF MAP REGISTERS REQUIRED
5$:
	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2	; R2 => ADP
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R1),R1	; R1 => UBMD.
	BBS	#VEC$V_MAPLOCK,-		; If SET, already permanently
		UBMD$W_MAPREG(R1),30$		;  allocated, so branch around.

	INCL	R3			; Round up request to next multiple
	BICB	#1,R3			;  of 2.
	MOVL	ADP$L_MRACTMDRS(R2),R5	; R5 = index beyond last MRD.
10$:
	CMPW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; See if enough regs described here.
	BLEQ	20$				; LEQ implies YES.

	SOBGTR	R5,10$				; Else branch back and continue
	CLRL	R0				; If here, allocation failure.
	BRB	40$				; Branch around to return.
20$:
	ADDW3	ADP$W_MRFREGARY-2(R2)[R5],-	; Calculate register # beyond
		ADP$W_MRNREGARY-2(R2)[R5],R0	;  last extent.
	SUBW	R3,R0				; We allocate from high end. R0
						;  contains 1st reg. to alloc.
	MOVW	R0,UBMD$W_MAPREG(R1)		; Record 1st register allocated.
	BISW	#VEC$M_MAPLOCK,UBMD$W_MAPREG(R1);  and mark it permanent.
	MOVB	R3,UBMD$B_NUMREG(R1)		; Set # of map regs allocated.
	SUBW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; Subtract out # regs allocated.
	BEQL	50$				; EQL implies descriptor not
						;  valid; branch to deallocate.
30$:
	MOVL	S^#SS$_NORMAL,R0	; Indicate success.
40$:
	POPL	R5			; Restore R5,R4,R3
	MOVQ	(SP)+,R3		;
	RSB
50$:
	DECL	R5			; R5 = index of descriptor to dealloc.
	BSBW	DEALLOC_DESCRIP		; Call to deallocate descriptor.
	BRB	30$			;  And branch back to return.
	.dsabl	lsb
	.PAGE
;+
; DEALLOC_DESCRIP - Common internal subroutine called to deallocate
;	a UBA Map Register descriptor.
;
; INPUTS:
;	R2 => ADP
;	R5 =  index of descriptor to deallocate.
; OUTPUTS:
;	The UBA Map Allocation structures are updated by contracting
;		descriptors over the deallocated one.
;	Register R5 is modified.
;-

DEALLOC_DESCRIP:
	DECL	ADP$L_MRACTMDRS(R2)	; Decrement # active descriptors.
10$:
	MOVW	ADP$W_MRNREGARY+2(R2)[R5],-	; Move data towards lower index
		ADP$W_MRNREGARY(R2)[R5]		;  to fill up hole.
	MOVW	ADP$W_MRFREGARY+2(R2)[R5],-	;
		ADP$W_MRFREGARY(R2)[R5]		;
	AOBLSS	ADP$L_MRACTMDRS(R2),R5,10$	; Loop thru rest of active MDRS.
	RSB

;+
; ALLOC_DESCRIP - Common internal subroutine to allocate a UBA map register
;	descriptor in the middle of the range of descriptors.
;
; INPUTS:
;	R2 => ADP
;	R5 =  index of where we must allocate descriptor
; OUTPUTS:
;	Allocation is accomplished by creating a hole in each of the arrays
;		by moving descriptor items to the next higher element.
;	Note R0 is modified.
;-

ALLOC_DESCRIP:
	MOVL	ADP$L_MRACTMDRS(R2),R0		; R0 = # active descriptors.
10$:
	CMPL	R0,R5				; Have we finished?
	BLEQ	20$				; LEQ implies YES.
	MOVW	ADP$W_MRNREGARY-2(R2)[R0],-	; Starting from ends of arrays,
		ADP$W_MRNREGARY(R2)[R0]		;  copy # register items.

	MOVW	ADP$W_MRFREGARY-2(R2)[R0],-	;
		ADP$W_MRFREGARY(R2)[R0]		;
	SOBGTR	R0,10$				; And loop back until we reach
						;  the hole we have created.
20$:	INCL	ADP$L_MRACTMDRS(R2)		; Increment # active descriptors.
	RSB					; Return to caller
	.PAGE
	.SBTTL	Release UNIBUS Map Registers
;+
; IOC$RELMAPUDA - RELEASE UNIBUS MAP REGISTERS (CALLED FROM UDA PORT DRIVER)
; IOC$RELMAPREG - RELEASE UNIBUS MAP REGISTERS
;
; This routine is called to release UNIBUS map registers that were previously
; assigned for an I/O transfer.
;
; INPUTS:
;   (For IOC$RELMAPUDA only)
;
;	R5 => CDRP
;
;   (For IOC$RELMAPREG call only)
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
;	It is assumed that the caller still owns the I/O channel on which
;	the transfer took place.
;
; OUTPUTS:
;
;	If the mapping registers have been permanently assigned to the asso-
;	ciated I/O channel (only possible for IOC$RELMAPREG), then control
;	is immediately returned to the caller.  Else the mapping registers are
;	released (via a call to IOC$DALOCUBAMAP) and we then go into a loop
;	removing waiting driver processes from the Map Register Wait Queue
;	until either the Queue is completely drained or we run out of map
;	registers to satisfy the needs of a given waiting driver process.
;	Driver processes waiting here have their context stored in either
;	a UCB fork block or a CDRP fork block and the processing required to
;	resume each of these types of driver process is slightly different.
;	What is done for each is to allocate the required map registers
;	(via a call to IOC$ALOUBAMPA for UCB threads and via a call to
;	IOC$ALOUBAMAP for CDRP threads) and to resume the waiting driver
;	process.  Resuming a UCB thread is done by restoring register
;	context and JSB'ing to the saved PC.  Resuming a CDRP thread is
;	accomplished by calling SCS$RESUMEWAITR.
;-
	.enabl	lsb
IOC$RELMAPUDA::
	MOVQ	R3,-(SP)		; Save R3-R6
	MOVQ	R5,-(SP)		;

	MOVL	CDRP$L_UCB(R5),R0	; R0 => UCB of deallocator.
	MOVL	UCB$L_CRB(R0),R1	; R1 => CRB => ADP with alloc. structure.
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2	; R2 => ADP.
	MOVL	R2,R6				; R6 => ADP also.

	MOVAB	CDRP$L_UBARSRCE(R5),R3	; R3 => UBMD.
	MOVZWL	UBMD$W_MAPREG(R3),R4	; R4 has 1st mapreg #.
	MOVZBL	UBMD$B_NUMREG(R3),R3	; R3 has # of mapregs.
	BRB	10$			; Branch to common code.

IOC$RELMAPREG::				; Release unibus map registers
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB.
	BBS	#VEC$V_MAPLOCK,-	; If SET, permanent allocation so branch.
		CRB$L_INTD+VEC$W_MAPREG(R1),50$
	MOVQ	R3,-(SP)		; Save R3-R6
	MOVQ	R5,-(SP)		;

	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2 ;GET ADDRESS OF ADP
	MOVL	R2,R6			;SAVE ADDRESS OF ADP
	MOVZWL	CRB$L_INTD+VEC$W_MAPREG(R1),R4 ;GET STARTING MAP REGISTER NUMBER
	MOVZBL	CRB$L_INTD+VEC$B_NUMREG(R1),R3 ;GET NUMBER OF REGISTERS TO DEALLOC
10$:
	BSBW	IOC$DALOCUBAMAP		; Free up UBA map resources.
20$:
	REMQUE	@ADP$L_MRQFL(R6),R5	;GET ADDRESS OF NEXT DRIVER FORK BLOCK
	BVS	40$			;IF VS NO DRIVER PROCESS WAITING

	CMPB	#DYN$C_UCB,-		; See if we dequeued a UCB or a CDRP.
		UCB$B_TYPE(R5)
	BNEQ	REALLOC_CD_MAPREGS	; NEQ implies a CDRP.

	BSBW	IOC$ALOUBAMAP		;SEARCH MAP REGISTER BITMAP AND ALLOCATE
	BLBC	R0,30$			;IF LBC ALLOCATION FAILURE
	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVE PROCESS CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT MAP REGISTER WAIT RETURN ADDRESS
	BRB	20$			;
30$:	INSQUE	UCB$L_FQFL(R5),ADP$L_MRQFL(R6) ;REINSERT DRIVER PROCESS AT FRONT OF QUEUE
40$:	MOVQ	(SP)+,R5		; Restore R3-R6
	MOVQ	(SP)+,R3		;
50$:	RSB				;

REALLOC_CD_MAPREGS:			; Reallocate mapregs to a class driver
					;  process.
	BSBW	IOC$ALOMAPUDA		; Allocate map registers if we can.
	BLBC	R0,30$			; LBC implies allocation failure, branch

	JSB	SCS$RESUMEWAITR		; Resume waiting thread and any backed
					;  up IRP's.
	BRB	20$			; Branch back to try and allocate more
					;  UNIBUS map registers.
	.dsabl	lsb
	.PAGE
;+
; IOC$DALOCUBAMAP - Common internal subroutine to update the UBA Map allocation
;	structures to include the map registers specified here among the
;	available map registers.
;
; INPUTS:
;	R2 => ADP
;	R3 =  # map registers to free.
;	R4 =  first map register to free.
;
; OUTPUTS:
;	The UBA Map Allocation structures are updated.
;
;	Registers R0, R1 and R5 are modified.
;
;-

IOC$DALOCUBAMAP:
	CLRL	R5			; Initialize loop variable.
	ADDL3	R4,R3,R1		; R1 = map register beyond extent.
10$:
	CMPW	R1,ADP$W_MRFREGARY(R2)[R5]	; See if map registers to free
						;  are before those described
						;  by current descriptor.
	BLEQ	20$				; LEQ implies yes.

	AOBLSS	ADP$L_MRACTMDRS(R2),R5,10$	; Else branch back and try next.
	BRB	40$				; If here, registers to free
						;  beyond those described by
						;  last descriptor. So branch
						;  to try and absorb at end of
						;  last descriptor.
20$:
	BNEQ	40$			; NEQ implies that although we alloca-
					;  registers before the current des-
					;  criptor, we are not contiguous with
					;  it.  So we branch to try and absorb
					;  these registers in the previous one.

; Here we can absorb the registers in the current descriptor.

	ADDW3	ADP$W_MRNREGARY-2(R2)[R5],-	; Calculate end of previous
		ADP$W_MRFREGARY-2(R2)[R5],R0	;  extent and move to R0.
	CMPW	R0,R4				; Does it coincide with start
						;  of this extent?
	BEQL	30$				; EQL implies yes.

; Here we have the most likely case. The map registers that we are freeing can
;	be absorbed into the top of the current descriptor but not also in the
;	previous descriptor.

	MOVW	R4,ADP$W_MRFREGARY(R2)[R5]	; First register freed becomes
						;  first register of current
						;  descriptor.
	ADDW	R3,ADP$W_MRNREGARY(R2)[R5]	; Number of registers is sum of
						;  registers freed and registers
						;  previously described here.
	RSB

; Here we have the case where the map registers being freed fall between two
;	discontiguous blocks and exactly span the difference.  We then can
;	describe the entire group with one descriptor, and so we also
;	deallocate the current descriptor.  Note new combined descriptor
;	will still begin at same map register number so we do NOT alter
;	this item.

30$:
	ADDW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; Partial sum of registers
						;  being freed and previous ones.
	ADDW	ADP$W_MRNREGARY(R2)[R5],-	; Now add in registers described
		ADP$W_MRNREGARY-2(R2)[R5]	;  in current descriptor.

	BRW	DEALLOC_DESCRIP			; BRW to subroutine and let it
						;  return to our caller.

; Here we cannot absorb the freed map registers in the current descriptor.
;	We test to see if we can absorb them in the previous descriptor.

40$:
	ADDW3	ADP$W_MRNREGARY-2(R2)[R5],-	; Calculate end of previous
		ADP$W_MRFREGARY-2(R2)[R5],R0	;  extent and move to R0.
	CMPW	R0,R4				; See if contigous with previous.
	BNEQ	50$				; NEQ implies NO.

	ADDW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; Sum # of registers in extent.
	RSB

; Here we must allocate a new descriptor to describe the map registers we
;	are freeing.  Conditions at this time are as follows:
;
;		R2 => ADP
;		R3 =  # registers to free
;		R4 =  first register to free
;		R5 =  index of where we must allocate descriptor
;
;	Allocation is accomplished by calling subroutine ALLOC_DESCRIP
;

50$:
	BSBW	ALLOC_DESCRIP			; Alloc R5 = index of descriptor.
	MOVW	R3,ADP$W_MRNREGARY(R2)[R5]	; Fill in allocated descriptor.
	MOVW	R4,ADP$W_MRFREGARY(R2)[R5]	;
	RSB
	.PAGE
	.SBTTL	RETURN TO CALLER
;+
; IOC$RETURN - RETURN TO CALLER
;
; THIS ROUTINE IS CALLED AS A RESULT OF A DDT DISPATCH TO A NULL ENTRY. ITS
; FUNCTION IS MERELY TO RETURN TO ITS CALLER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	NONE.
;-
 
IOC$RETURN::				;RETURN TO CALLER
	RSB				;
	.PAGE
	.SBTTL	WAITFOR INTERRUPT OR TIMEOUT AND KEEP CHANNEL
;+
; IOC$WFIKPCH - WAITFOR INTERRUPT OR TIMEOUT AND KEEP CHANNEL
;
; THIS ROUTINE IS CALLED TO SOFTWARE ENABLE INTERRUPTS AND TIMEOUT ON
; A DEVICE UNIT AND TO KEEP THE CHANNEL. THIS ROUTINE CAN BE CALLED AT 
; EITHER FORK OR DEVICE INTERRUPT LEVEL.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = TIMEOUT VALUE IN SECONDS.
;	08(SP) = IPL TO LOWER TO AFTER SETTING WAIT.
;	12(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE TIMEOUT VALUE IS COMPUTED AND STORED IN DUE TIME, REGISTERS R3 AND
;	R4 ALONG WITH THE RETURN PC ARE SAVED IN THE FORK BLOCK, INTERRUPTS AND
;	TIMEOUT ARE ENABLED, AND A RETURN TO THE CALLER'S CALLER IS EXECUTED.
;-
 
IOC$WFIKPCH::				;WAITFOR INTERRUPT/TIMEOUT AND KEEP CHANNEL
	ADDL	#2,(SP)			;CALCULATE OFFSET TO NORMAL RETURN
	MOVQ	R3,UCB$L_FR3(R5)	;SAVE REGISTERS R3 AND R4
	POPL	UCB$L_FPC(R5)		;SAVE INTERRUPT RETURN ADDRESS
	BISW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;ENABLE INTERRUPT AND TIMEOUT
	ADDL3	(SP)+,L^EXE$GL_ABSTIM,UCB$L_DUETIM(R5) ;SET TIMEOUT TIME
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR UNIT TIMED OUT
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	WAITFOR INTERRUPT OR TIMEOUT AND RELEASE CHANNEL
;+
; IOC$WFIRLCH - WAITFOR INTERRUPT OR TIMEOUT AND RELEASE CHANNEL
;
; THIS ROUTINE IS CALLED TO SOFTWARE ENABLE INTERRUPTS AND TIMEOUT ON A DEVICE
; UNIT AND TO RELEASE THE CHANNEL. THIS ROUTINE CAN ONLY BE CALLED AT FORK LEVEL.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = TIMEOUT VALUE IN SECONDS.
;	08(SP) = IPL TO LOWER TO AFTER SETTING WAIT.
;	12(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE TIMEOUT VALUE IS COMPUTED AND STORED IN DUE TIME, REGISTERS R3 AND
;	R4 ALONG WITH THE RETURN PC ARE SAVED IN THE FORK BLOCK, INTERRUPTS AND
;	TIMEOUT ARE ENABLED, THE CHANNEL IS RELEASED, AND A RETURN TO THE CALLER'S
;	CALLER IS EXECUTED.
;-
 
IOC$WFIRLCH::				;WAITFOR INTERRUPT/TIMEOUT AND RELEASE CHANNEL
	ADDL	#2,(SP)			;CALCULATE OFFSET TO NORMAL RETURN
	MOVQ	R3,UCB$L_FR3(R5)	;SAVE REGISTERS R3 AND R4
	POPL	UCB$L_FPC(R5)		;SAVE INTERRUPT RETURN ADDRESS
	BISW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;ENABLE INTERRUPT AND TIMEOUT
	ADDL3	(SP)+,L^EXE$GL_ABSTIM,UCB$L_DUETIM(R5) ;SET TIMEOUT TIME
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR UNIT TIMED OUT
	ENBINT				;ENABLE INTERRUPTS
	BRW	IOC$RELCHAN		;RELEASE ALL CHANNELS AND RETURN TO CALLER
 

	.PAGE
	.SBTTL	ALLOCATE SYSTEM PAGE TABLE
;+
; IOC$ALLOSPT - ALLOCATE SYSTEM PAGE TABLE
;
; THIS ROUTINE ALLOCATES SYSTEM PAGE TABLE (SPT) ENTRIES.
; 
; INPUTS:
;
;	R1 = NUMBER OF SPT ENTRIES TO BE ALLOCATED
;
;	BOO$GL_SPTFREL = LOWEST FREE VPN
;	BOO$GL_SPTFREH = HIGHEST FREE VPN
;
;	IT IS ASSUMED THAT THE CALLER IS RUNNING AT IPL$_SYNCH.
;
; OUTPUTS:
;
;	R0 = SUCCESS INDICATION.
;	R2 = STARTING PAGE NUMBER ALLOCATED (SVPN).
;	R3 = ADDRESS OF BASE OF SYSTEM PAGE TABLE (MMG$GL_SPTBASE).
;
;	R1 IS PRESERVED ACROSS CALL.
;-
IOC$ALLOSPT::				;ALLOCATE SYSTEM PAGE TABLE
	CLRL	R0			;ASSUME FAILURE
	MOVL	L^BOO$GL_SPTFREL,R2	;GET NEXT AVAILABLE SYSTEM VPN
	ADDL3	R1,R2,R3		;COMPUTE NEXT WITH THIS ALLOCATION
	CMPL	R3,L^BOO$GL_SPTFREH	;ARE THERE ENOUGH AVAILABLE?
	BGEQU	10$			;BR IF NO
	MOVL	R3,L^BOO$GL_SPTFREL	;MARK THE ENTRIES ALLOCATED
	MOVL	L^MMG$GL_SPTBASE,R3	;GET ADDR OF BASE OF SPT
	INCL	R0			;SET SUCCESS
10$:
	RSB				;
	.PAGE
	.SBTTL	CONVERT DEVICE NAME AND UNIT
;+
; IOC$CVT_DEVNAM - Convert device name and unit
;
; This routine is called to convert a device name and unit number to a physical
; device name string.
;
; Inputs:
;
;	The caller is assumed to have PROBEd the output buffer for write access.
;	The I/O data base is locked for read access.  This means that the caller
;	owns the I/O data base mutex and/or is at IPL SYNCH or higher.
;
;	R0 = length of output buffer.
;	R1 = address of output buffer.
;	R5 = address of device UCB.
;
; Outputs:
;
;	The device name and unit number are converted and stored in the specified
;	output buffer. The following register values are returned:
;
;		R0 = Final conversion status.
;		R1 = Length of conversion string.
;-
 
IOC$CVT_DEVNAM::			;Convert device name and unit
	PUSHR	#^M<R2,R3,R4,R5>	;Save registers
	;
	; Push a quadword onto the stack.  The quadword will land
	; on the stack so that when the POPR at the end of the routine
	; is executed, R0 will contain the routine value, and R1 will
	; contain the length of the formatted device name.
	;
	MOVQ	#SS$_NORMAL,-(SP)	;Put a 1 and a 0 on the stack
	CLRQ	-(SP)			;Reserve 8 bytes on the stack for the unit # string
	MOVL	SP,R3			;Copy 'buffer' address to R3
	CLRL	-(SP)			;Save high 0 for EDIV
	MOVZWL	UCB$W_UNIT(R5),-(SP)	;Get device unit number
	MOVL	UCB$L_DDB(R5),R2	;Get DDB address
	MOVAL	DDB$T_NAME(R2),R2	;Get address of ASCIC device name
	MOVZBL	(R2)+,R4		;Get length of device name
	;
	; Precede the device name with a "_" (underscore character) to
	; indicate that this is a physical device name.
	;
	MOVZBL	#^A/_/,R5		;Put underscore character in R5
	BSBB	100$			;Put it in the output buffer
	;
	; Copy device name to buffer.
	;
20$:	MOVB	(R2)+,R5		;Move one byte to output buffer
	BSBB	100$			;Put the character in the output buffer
	SOBGTR	R4,20$			;Branch if more to copy
	;
	; Convert the device unit number to ASCII and save it on the
	; stack.  Note that the digits are stored in reverse order.
	;
30$:	EDIV	#10,(SP),(SP),R5	;(SP) = quotient, R5 = remainder
	ADDB3	#^A/0/,R5,(R3)+		;Convert to ASCII and save the digit
	INCL	R4			;Increment the digit counter
	TSTL	(SP)			;Check quotient
	BNEQ	30$			;Branch if more digits to convert
	;
	; Copy as much of the unit number string
	; to the output buffer string as possible.
	;
40$:	MOVB	-(R3),R5		;Get a digit
	BSBB	100$			;Copy digit to output buffer
	SOBGTR	R4,40$			;Branch if more digits to copy
	;
	; Terminate the device name with a ":" (colon).
	;
	MOVZBL	#^A/:/,R5		;Put a ":" in R5
	BSBB	100$			;Put the ":" in output buffer
	;
	; Clean up the stack and exit.  The stack has been set up so that
	; the proper values will be stored in R0 and R1 by the POPR.
	;
	ADDL	#<4*4>,SP		;Remove 4 longwords from the stack
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;Restore registers
	RSB				;Return

;++
;
; The following code is a local subroutine to place a given
; byte in the output buffer.  A count is kept of all characters
; placed in the output buffer.  If the output buffer is full,
; the byte is not copied, the count is not increased, and a
; special status code in placed on the stack.  This status code
; will later be placed in R0 as the return status of IOC$CVT_DEVNAM.
; Note that there is now an extra longword on the stack due to the
; subroutine call.
;--

100$:	SOBGEQ	R0,110$			;Decrease output buffer length
	MOVZWL	#SS$_BUFFEROVF,20(SP)	;Set buffer overflow status
	RSB
110$:	INCL	24(SP)			;Count characters stored
	MOVB	R5,(R1)+		;Copy character to output buffer
	RSB				;Return
	.PAGE
	.SBTTL	BROADCAST TO A TERMINAL
;++
; IOC$BROADCAST
;
;	This routine will allow driver fork processes to broadcast a
;	given message to given terminal.  The broadcast request is
;	dispatched to the proper terminal and control returns immediately
;	to the caller.  Some time later the broadcast will complete, and
;	at that time all the necessary post-processing will be done.
;
;	This routine does not implement all the features of the $BRDCST system
;	service, but only the bare minimum necessary to send a message to a 
;	single terminal.  For more information about the terminal broadcast
;	mechanism, see the module SYSBRDCST.
;
; Input:
;
;	R1 = Message length
;	R2 = Message address
;	R5 = Address of target terminal's UCB
;
; Implicit input:
;
;	IPL$_ASTDEL  <=  CURRENT_IPL  <=  UCB$B_FIPL(R5)
;
; Output:
;
;	None.  The contents of R1 .. R5 are preserved across the call.
;
; Routine value:
;
;	SS$_NORMAL	- The broadcast completed successfully.
;	SS$_INSFMEM	- Insufficient dynamic nonpaged pool for the request.
;	SS$_DEVOFFLINE	- The target terminal has rejected the request.
;	SS$_ILLIOFUNC	- The specified UCB does not belong to a terminal.
;			  (Therefore a BROADCAST is an illegal I/O function.)
;--

SAVED_R0 = 0				;.
SAVED_R1 = 4				; .
SAVED_R2 = 8				; .
SAVED_R3 = 12				; . Symbolic offsets to saved registers
SAVED_R4 = 16				; .
SAVED_R5 = 20				;.

IOC$BROADCAST::				; Broadcast to a terminal
	MOVZWL	#SS$_ILLIOFUNC,R0	; Assume device not a terminal
	BBC	#DEV$V_TRM,-		; Branch if not a terminal
		UCB$L_DEVCHAR(R5),14$	; 
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save R0 .. R5
	ADDL2	#TTY$K_WB_HDRLEN,R1	; Calculate the total pool required
	MOVZWL	#SS$_INSFMEM,SAVED_R0(SP); Assume allocation failure
	BSBW	EXE$ALONONPAGED		; Allocate the pool
	BLBC	R0,13$			; Exit if error
	;
	; Fill in the Terminal Write Packet (TWP).
	; Note that EXE$ALONONPAGED the pool size
	; in R1 and the pool address in R2.
	;
	MOVW	R1,TTY$W_WB_SIZE(R2)	; Set TWP size
	MOVB	#DYN$C_TWP,-		; Set TWP structure type
		TTY$B_WB_TYPE(R2)	;
	MOVB	#IPL$_QUEUEAST,-	; Set the TWP fork IPL (for later use)
		TTY$B_WB_FIPL(R2)	;
	MOVL	#1,TTY$L_WB_FR3(R2)	; Request refresh of read prompt
	MOVAB	TTY$L_WB_DATA(R2),-	; Set address of message start
		TTY$L_WB_NEXT(R2)	;
	ADDL3	SAVED_R1(SP),-		; Set address of message end
		TTY$L_WB_NEXT(R2),-	;
		TTY$L_WB_END(R2)	;
	MOVAB	B^END_BROADCAST,-	; Set callback address
		TTY$L_WB_RETADDR(R2)	;
	CLRL	TTY$L_WB_IRP(R2)	; Clear pointer to associated IRP
	PUSHL	R2			; Save TWP address
	MOVC3	4+SAVED_R1(SP),-	; Copy the message text to the TWP
		@4+SAVED_R2(SP),-	; (note the stack depth changed)
		TTY$L_WB_DATA(R2)	;
	;
	; Queue the broadcast request to the terminal.
	; The disposition of the broadcast request will be determined
	; by the contents of TTY$L_WB_END.  Note that if the request is
	; accepted by a remote terminal, or is rejected outright, the
	; TWP is no longer needed, and may be deallocated.  The TTY$L_WB_END
	; field of the TWP will contain one of the following values:
	;
	;	System address:	request accepted by TTDRIVER
	;	1:		request accepted by RTTDRIVER
	;	2:		request rejected
	;
	MOVL	(SP),R3			; Put TWP address in R3
	MOVL	4+SAVED_R5(SP),R5	; Restore UCB address
	BSBW	EXE$ALTQUEPKT		; Queue the request to the terminal
	POPL	R0			; Remove TWP address from the stack
	MOVZWL	#SS$_NORMAL,SAVED_R0(SP); Assume success 
	TSTL	TTY$L_WB_END(R0)	; Check for rejection
	BEQL	69$			; Branch if request rejected
	BGTR	80$			; Branch if remote terminal accepted
13$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore the registers
14$:	RSB				; Return
69$:	MOVZWL	#SS$_DEVOFFLINE,-	; Set broadcast rejection status
		SAVED_R0(SP)		;
80$:	BSBW	COM$DRVDEALMEM		; Deallocate the TWP
	BRB	13$			; Take common exit path

;
; The following code performs all of the necessary broadcast post-processing.
; This entry point is FORKed to at IPL IPL$_QUEUEAST from the terminal driver.
; The fork block is the TWP.
;
END_BROADCAST:				; Post-processor for broadcast requests
	MOVL	R5,R0			; Copy TWP address
	BRW	EXE$DEANONPAGED		; Deallocate the TWP and return
	.END
