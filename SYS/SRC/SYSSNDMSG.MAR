	.TITLE	SYSSNDMSG - SEND MESSAGE SYSTEM SERVICES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;
;	STARLET SYSTEM SERVICE
;
; ABSTRACT:
;
;	COMMON MODULE FOR SEND TO OPERATOR AND SYMBIONT MANAGER.
;
; AUTHOR: R.HEINEN, CREATION DATE: 11-JUL-77
;
; MODIFIED BY:
;
;	V03-001	KDM0086		Kathleen D. Morse	02-Apr-1982
;		Correctly acquire system time, even in case where
;		secondary processor is accessing EXE$GQ_SYSTIME while
;		the primary processor is updating it (11/782 case).
;
;	V02-011 MSH0001		Maryann Hinden	       23-Feb-1982
;		Fix second probe error
;	
;	V02-010	PHL0027		Peter H. Lipman		2-Dec-1981
;		Repair probe error
;
;	V02-009	SPF0015		Steven Forgey		14-Aug-1981
;		Add new accounting message formats and functions.
;
;	V02-008	STJ0046		Steven T. Jeffreys	03-Jun-1981
;		Fix accvio when process goes into MWAIT for nonpaged pool.
;
;	V02-007	GWF0026		Gary W. Fowler		09-Apr-1981
;		Increase maximum allowed size of message to job controller
;
;	V02-006	PCG0001		Peter C. George		16-Feb-1981
;		Add OPCMSG expansion.
;
;	V02-005	KDM0037		Kathleen D. Morse	12-Feb-1981
;		Change non-kernel mode references to SCH$GL_CURPCB
;		to use CTL$GL_PCB instead.
;
;	V02-004	STJ0023		Steven T. Jeffreys,	28-Jan-1981
;		Make $SNDACC, $SNDOPR, and $SNDSMB conditionally enter
;		resource wait mode if EXE$WRTMAILBOX failed with the
;		status code SS$_INSFMEM.
;
;	V02-003	STJ0016		Steven T. Jeffreys,	12-Jan-1981
;		Made maximum message size checking more flexible.
;		Added EXE$SETOPR routine.
;		Liberal rewrite of $SNDOPR
;
;
;--
	.PSECT	Y$EXEPAGED
;
; EXTERNAL SYMBOLS
;
	$ACMDEF				; DEFINE ACCOUNTING MESSAGE OFFSETS
	$CCBDEF				; DEFINE CHANNEL CONTROL BLOCK
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$EMBDEF	SS			; DEFINE ERROR MESSAGE BUFFER OFFSETS
	$MSGDEF				; DEFINE MESSAGE TYPES
	$OPCDEF				; DEFINE OPERATOR MESSAGES
	$OPCMSG				; OPERATOR COMMUNICATIONS MESSAGES
	$PCBDEF				; DEFINE PCB
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRVDEF				; DEFINE PRIVILEGE MASK
	$SSDEF				; DEFINE SYSTEM STATUS RETURN CODES
	$UCBDEF				; DEFINE UCB
	$IPLDEF				; DEFINE IPL CONSTANTS
	$RSNDEF				; DEFINE RESOURCE NUMBERS
;
; LOCAL SYMBOLS
;
MSG=4
MBX=8
;
; The messages sent by $SNDACC, $SNDERR, and $SNDOPR consist of
; a common header followed by the user specified message.  The 
; common header has the following format:
;
;	.WORD	<message type>
;	.WORD	<reply mailbox channel #>
;	.QUAD	<sender's privilege mask>
;	.LONG	<sender's UIC>
;	.BLKB	<sender's USERNAME.  12 bytes, blank filled>
;	.BLKB	<sender's ACCOUNT.  8 bytes, blank filled>
;	.BYTE	<sender's base priority>
;	.BYTE	<unused>
;
COMMON_HDR=38				; Common header size



	.SBTTL	EXE$SNDACC - SEND MESSAGE TO ACCOUNT MANAGER
;++
; EXE$SNDACC - SEND MESSAGE TO ACCOUNT MANAGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ACCOUNT MANAGER MAILBOX SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE JOB CONTROLLER MAILBOX.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED AND THE REQUEST REPLY MAILBOX
; IS CHECKED FOR BEING A MAILBOX AND ACCESSIBLE TO THE PROCESS.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE QUADWORD DESC FOR THE MESSAGE TEXT.
;	MBX(AP) = CHANNEL NUMBER OF THE MAILBOX FOR THE REPLY.
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - DEVICE OFFLINE
;--
EXE$SNDACC::				; SEND TO ACCOUNTING MANAGER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	#MSG$_SNDACC,R11	; SET MESSAGE TYPE CODE
	MOVAB	SYS$GL_JOBCTLMB,R5	; ADDRESS TARGET MAILBOX
	MOVZWL	#200,R7			; SET MAXIMUM MESSAGE SIZE
	BRB	BUILDMSG		; CONTINUE IN COMMON

	.SBTTL	EXE$SNDSMB - SEND MESSAGE TO SYMBIONT MANAGER
;++
; EXE$SNDSMB - SEND MESSAGE TO SYMBIONT MANAGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO SYMBIONT MANAGER MAILBOX SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE JOB CONTROLLER MAILBOX.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED AND THE REQUEST REPLY MAILBOX
; IS CHECKED FOR BEING A MAILBOX AND ACCESSIBLE TO THE PROCESS.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE QUADWORD DESC FOR THE MESSAGE TEXT.
;	MBX(AP) = CHANNEL NUMBER OF THE MAILBOX FOR THE REPLY.
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - DEVICE OFFLINE
;--
EXE$SNDSMB::				; SEND TO SYMBIONT MANAGER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	#MSG$_SNDSMB,R11	; SET MESSAGE TYPE CODE
	MOVAB	SYS$GL_JOBCTLMB,R5	; SET ADDRESS OF MAILBOX
	MOVZWL	#1000,R7		; SET MAXIMUM MESSAGE SIZE
	BRB	BUILDMSG		; CONTINUE IN COMMON

	.SBTTL	EXE$SNDOPR - SEND MESSAGE TO OPERATOR MAILBOX
;++
; EXE$SNDOPR - SEND MESSAGE TO OPERATOR MAILBOX
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO OPERATOR MAILBOX SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE OPERATOR MAILBOX.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED AND THE REQUEST REPLY MAILBOX
; IS CHECKED FOR BEING A MAILBOX AND ACCESSIBLE TO THE PROCESS.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE QUADWORD DESC FOR THE MESSAGE TEXT.
;	MBX(AP) = CHANNEL NUMBER OF THE MAILBOX FOR THE REPLY.
;
; OUTPUTS:
;	
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	OPC$_NOPERATOR - NO OPERATOR COVERAGE
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;--
EXE$SNDOPR::				; SEND TO OPERATOR
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	#MSG$_OPRQST,R11	; SET MESSAGE TYPE CODE
	MOVAB	SYS$GL_OPRMBX,R5	; SET ADDRESS OF MAILBOX
	MOVZWL	#<1024-COMMON_HDR>,R7	; SET MAXIMUM USER MESSAGE SIZE
	BRB	BUILDMSG		; CONTINUE IN COMMON

	.SBTTL	BUILD MESSAGE SUBROUTINE
;++
; BUILDMSG - BUILD MESSAGE ROUTINE FOR EXE$SNDOPR/EXE$SNDSMB
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE BUILDS THE REQUESTED MESSAGE ON THE EXEC STACK
; AND ENTERS A KERNEL MODE ROUTINE TO PERFORM THE MAILBOX VALIDATION
; AND SEND THE MESSAGE.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;	MBX(AP) = CHANNEL NUMBER OF THE REPLY MAILBOX IF ANY
;	R5 = MAILBOX UCB ADDRESS
;	R7 = MAXIMUM MESSAGE SIZE
;	R11 = MESSAGE TYPE
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - DEVICE OFFLINE
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;		     OR THE MESSAGE REQUEST TYPE REQUIRES THE OPERATOR PRIV.
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;	SS$_BADPARAM - MESSAGE SIZE ERROR
;--
BADPARAM:
	MOVZWL	#SS$_BADPARAM,R0	; SET BAD PARAM ERROR
ERROR:	RET				; ERROR RETURN
BUILDMSG:				; BUILD MESSAGE
	;
	; MINIMIZE THE ALLOWABLE MESSAGE SIZE WITH
	; THE SYSTEM MAXBUF PARAMETER.
	;
	CMPW	IOC$GW_MAXBUF,R7	; COMPARE MAX MSG SIZE AGAINST SYS MAX
	BGEQU	10$			; BRANCH IF SYSTEM MAX GREATER
	MOVZWL	IOC$GW_MAXBUF,R7	; SET MAXBUF AS MSG LIMIT
	;
	; CHECK THE INPUT PARAMETERS
	;
10$:	MOVL	MSG(AP),R1		; GET MESSAGE DESCRIPTER
	BEQL	BADPARAM		; IF EQL THEN NO MESSAGE AND ERROR
	BSBW	EXE$PROBER_DSC		; PROBE DESCRIPTOR AND BUFFER
	BLBC	R0,ERROR		; BRANCH IF ERROR
	;
	; R1<0:15> = SIZE, R2 = ADDRESS OF BUFFER
	;
	MOVL	R2,R9			; SAVE ADDRESS OF BUFFER
	MOVZWL	R1,R8			; GET SIZE OF MESSAGE
	BEQL	BADPARAM		; IF EQL THEN ILLEGAL
	CMPW	R8,R7			; LEGAL SIZE?
	BGTRU	BADPARAM		; IF GTRU THEN NO
	ADDL3	#COMMON_HDR+3,R8,R1	; CALC SIZE OF TOTAL MESSAGE
	CMPW	#MSG$_OPRQST,R11	; SYMBIONT OR ACCOUNTING MGR MESSAGE?
	BEQL	15$			; IF EQL, NO
	ADDL2	#<ACM$Q_SYSTIME+8-ACM$B_PROCPRI+2>,R1;ALLOCATE SPACE FOR ID DATA
15$:
	BICB	#3,R1			; ROUND DOWN SIZE
	MOVZWL	#SS$_INSFMEM,R0		; ASSUME NO STACK
	SUBL3	R1,SP,R3		; ADDRESS MESSAGE STORAGE
	CMPL	R3,@#CTL$AL_STACK	; IN KERNEL STACK?
	BLEQU	ERROR			; IF LEQU THEN YES
	;
	; BUILD THE MESSAGE ON THE EXEC STACK.
	;
	MOVL	R3,SP			; ALLOCATE THE SPACE
	PUSHR	#^M<R3,R5>		; SAVE SIZE AND UCB ADDRESS
	MOVW	R11,(R3)+		; INSERT MESAGE TYPE
	MOVW	MBX(AP),(R3)+		; INSERT REPLY MAILBOX CHANNEL NUMBER
	MOVL	G^CTL$GL_PCB,R6		; GET ADDRESS OF PCB

	ASSUME	PHD$Q_PRIVMSK EQ 0

	MOVQ	@PCB$L_PHD(R6),(R3)+	; INSERT PRIVILEGE MASK
	MOVL	PCB$L_UIC(R6),(R3)+	; INSERT UIC
	MOVC3	#20,@#CTL$T_USERNAME,(R3); INSERT USER NAME AND ACCOUNT NAME
	SUBB3	PCB$B_PRIB(R6),#31,(R3)+; INSERT BASE PRIORITY
	CLRB	(R3)+			; CLEAR SPARE BYTE
	CMPW	#MSG$_OPRQST,R11	; ACCOUNTING OR SYMBIONT MESSAGE ?
	BEQL	20$			; IF EQL, NO
;***********************************************************************
;
	ASSUME	ACM$W_MAILBOX EQ ACM$W_TYPE+2
	ASSUME	ACM$Q_PRVMSK EQ ACM$W_MAILBOX+2
	ASSUME	ACM$L_UIC EQ ACM$Q_PRVMSK+8
	ASSUME	ACM$T_USERNAME EQ ACM$L_UIC+4
	ASSUME	ACM$T_ACCOUNT EQ ACM$T_USERNAME+12
	ASSUME	ACM$B_PROCPRI EQ ACM$T_ACCOUNT+8
	ASSUME	ACM$L_PID EQ ACM$B_PROCPRI+4
	ASSUME	ACM$L_STS EQ ACM$L_PID+4
	ASSUME	ACM$L_OWNER EQ ACM$L_STS+4
	ASSUME	ACM$T_TERMINAL EQ ACM$L_OWNER+4
	ASSUME	ACM$Q_SYSTIME EQ ACM$T_TERMINAL+8
;
;***********************************************************************
	CLRW	(R3)+			; CLEAR SPARE BYTES
	MOVL	PCB$L_PID(R6),(R3)+	; INSERT PROCESS ID
	MOVL	PCB$L_STS(R6),(R3)+	; INSERT PROCESS STATUS
	MOVL	PCB$L_OWNER(R6),(R3)+	; INSERT OWNER PID (0 => NONE)
	MOVQ	PCB$T_TERMINAL(R6),(R3)+; INSERT TERMINAL NAME
19$:
	MOVQ	EXE$GQ_SYSTIME,(R3)	; CURRENT SYSTEM TIME
	CMPL	EXE$GQ_SYSTIME,(R3)	; VERIFY THAT VALUE ACQUIRED WAS
	BNEQ	19$			;  NOT BEING MODIFIED AT THE SAME
	CMPL	EXE$GQ_SYSTIME+4,4(R3)	;  AT THE SAME TIME.  ACQUIRE TIME
	BNEQ	19$			;  AGAIN IF IT CHANGED.
	ADDL	#8,R3			; POINT TO NEXT FIELD
20$:
	MOVC3	R8,(R9),(R3)		; COPY MESSAGE
	SUBL3	(SP),R3,-(SP)		; CALC MESSAGE SIZE
	$CMKRNL_S	B^SENDMSG,(SP)	; SEND MESSAGE IN KERNEL MODE
	RET				; RETURN AND CLEAN STACK

	.SBTTL	SEND MESSAGE ROUTINE
;++
; SENDMSG - KERNEL MODE MESSAGE SEND ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RUNS IN KERNEL MODE AND SENDS THE MESSAGE TO THE
; TARGET MAILBOX.
;
; INPUTS:
;
;	0(AP) = SIZE OF MESSAGE
;	4(AP) = ADDRESS OF THE MESSAGE
;	8(AP) = MAILBOX UCB ADDRESS
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERTATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_IVCHAN - SPECIFIED CHANNEL INVALID
;	SS$_MBTOOSML - MESSAGE EXCEEDS MAILBOX SIZE
;	SS$_DEVOFFLIN - NO LISTENER FOR SYMBIONT OR JOB CONTROLLER
;	OPC$_NOPERATOR - NO LISTENER FOR OPERATOR REQUEST
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_NOPRIV - PROCESS DOES NOT HAVE READ ACCESS TO SPECIFIED MAILBOX
;	SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT TO MAILBOX
;--
SENDMSG:				; 
	.WORD	0			; SAVE NO REGISTERS
	MOVL	4(AP),R5		; GET MESSAGE ADDRESS
	MOVZWL	2(R5),R0		; GET CHANNEL NUMBER
	BEQL	10$			; IF EQL THEN NO REPLY
	MOVL	SCH$GL_CURPCB,R4	; GET CURRENT PCB
	BSBW	IOC$VERIFYCHAN		; CHECK OUT CHANNEL NUMBER
	BLBC	R0,20$			; BR IF ERROR
	MOVL	CCB$L_UCB(R1),R1	; GET UCB OF REPLY MAILBOX
	MOVW	UCB$W_UNIT(R1),2(R5)	; INSERT UNIT NUMBER OF MAILBOX
	MOVZWL	#SS$_DEVNOTMBX,R0	; ASSUME DEVICE NOT MAILBOX
	BBC	#DEV$V_MBX,UCB$L_DEVCHAR(R1),20$; BR IF NOT MAILBOX
	MOVL	UCB$L_OWNUIC(R1),R2	; GET UIC OF BOX OWNER
	MOVZWL	UCB$W_VPROT(R1),R1	; GET PROTECTION MASK
	MOVL	PCB$L_ARB(R4),R0	; GET ACCESS RIGHTS BLOCK
	BSBW	EXE$CHKRDACCES		; CHECK ACCESS
	BLBC	R0,20$			; BR IF ERROR IN ACCESS
	MOVL	PCB$L_ARB(R4),R0	; GET ACCESS RIGHTS BLOCK
	BSBW	EXE$CHKWRTACCES		; CHECK OUT FOR WRITE
	BLBC	R0,20$			; AND RETURN IF NO ACCESS
10$:
	MOVL	8(AP),R5		; ADDRESS UCB OF MAILBOX
	MOVQ	(AP),R3			; GET SIZE AND ADDRESS OF MESSAGE
	BSBB	EXE$SENDMSG		; SEND MESSAGE
20$:
	RET
	.PAGE
;+
; EXE$SENDMSG -- Send mail box message
;
; INPUTS:	R3 = message size
;		R4 = message address
;		R5 = UCB address
;
;-

EXE$SENDMSG::
;
; Check the reference count in the UCB to see if the
; mailbox has a listener.  Note that both the JOB CONTROLER
; mailbox and the OPERATOR mailbox have an initial ref. count
; of 1.  Therefore, if there is a listener at the mailbox,
; the reference count must be greater than 1.
;
	CMPW	UCB$W_REFC(R5),#1	; DOES A LISTENER EXIST?
	BLEQU	10$			; BRANCH IF NOT
;
; The message must faulted in before calling EXE$WRTMAILBOX.
; The manner in which this is done verges on the magical.
; For a detailed explanation, see below.
;
; First round the address of the message (on the EXEC stack)
; DOWN to the nearest page boundary.  Then raise IPL to ASTDEL
; to block AST delivery.  This step is necessary to avoid
; pagefaults incurred during the execution of the AST routine.
; Since we now have a page-aligned base address of the message
; in R2, we can use one instruction to fault in the pages,
; two pages with each operand referenced.  This is done by
; choosing the operand address and instruction operand context
; so that the operand is split across a page boundary.
; Note that if the size (rounded up) in pages of the message
; is N, then the maximum number of pages that must be faulted
; in is N+1.  If the message size is small, and the message
; resides near the end of the EXEC stack, it is possible that
; we may overrun the EXEC stack.  This is ok, because the
; KERNEL stack follows the EXEC stack, and we're in KERNEL
; mode right now (remember?).  Note that after the KERNEL
; stack is a page that is inacessable.  As a result, the message
; size (in pages) must not exceed the number of pages in the
; KERNEL stack.
; 
	BICL3	#^X01FF,R4,R2		; ROUND ADDRESS DOWN
	SETIPL	#IPL$_ASTDEL		; BLOCK AST DELIVERY
	CMPW	511(R2),1023(R2)	; FAULT IN 4 CONTIGUOUS PAGES
	JSB	G^EXE$WRTMAILBOX	; WRITE MESSAGE
	SETIPL	#0			; ENABLE AST DELIVERY
	BLBC	R0,10$			; BRANCH IF ERROR
	RSB
;
; SOMETHING IS WRONG.  EITHER THERE IS NO LISTENER FOR
; THE SPECIFIED MAILBOX, OR THERE IS INSUFFICIENT NON-
; PAGED POOL TO MAIL THE MESSAGE.  CHECK THE STATUS CODE
; AND DO THE APPROPRIATE THING.
;
10$:	CMPW	R0,#SS$_INSFMEM		; INSUFFICIENT MEMORY?
	BEQL	30$			; BRANCH IF YES
;
; NO LISTENER IS PRESENT.
;
; IF THE SPECIFIED MAILBOX IS THE OPERATOR MAILBOX THEN
; THE SENDER IS INFORMED THAT NO OPERATOR IS PRESENT.
;
	MOVZWL	#SS$_DEVOFFLINE,R0	; ASSUME NO LISTENER
	CMPB	#MSG$_OPRQST,(R4)	; OPERATOR?
	BNEQ	20$			; IF NEQ THEN NO
	MOVL	#OPC$_NOPERATOR,R0	; SET NO OPERATOR SUCCESS STATUS
20$:	RSB				; RETURN
;
; THERE WAS INSUFFICIENT NONPAGED POOL TO SEND THE MESSAGE.
; IF THE PROCESS HAS RESOURCE WAIT MODE ENABLED, WAIT FOR
; THE POOL TO FREE UP.  IF NOT, THEN RETURN THE ERROR STATUS.
;
30$:
	PUSHR	#^M<R3,R4,R5>		; SAVE SIZE AND ADDRESS OF MESSAGE
					; AND UCB ADDRESS
	MOVL	SCH$GL_CURPCB,R4	; GET CURRENT PROCESS PCB ADDRESS
	BBS	#PCB$V_SSRWAIT,-	; IF SET, NO WAIT
		PCB$L_STS(R4),40$	;
	MOVZWL	#RSN$_NPDYNMEM,R0	; SET RESOURCE WAIT NUMBER
	MOVPSL	-(SP)			; PUSH PSL ON STACK
	SETIPL	#IPL$_SYNCH		; RAISE IPL TO SYNCH
	BSBW	SCH$RWAIT		; WAIT FOR NONPAGED MEMORY
	POPR	#^M<R3,R4,R5>		; RESTORE SIZE AND ADDRESS OF MESSAGE
					; AND UCB ADDRESS
	BRB	EXE$SENDMSG		; TRY AGAIN
40$:
	POPR	#^M<R3,R4,R5>		; RESTORE SIZE AND ADDRESS OF MESSAGE
					; AND UCB ADDRESS
	RSB

	.SBTTL	EXE$OPRSNDERL - OPERATOR SEND MESSAGE TO ERROR LOGGER
;++
; EXE$OPRSNDERL - OPERATOR SEND MESSAGE TO ERROR LOGGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ERROR LOGGER SYSTEM SERVICE
; FOR THE OPERATOR COMMUNICATION PROCESS.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE ERROR LOG FORMAT PROGRAM.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;--
	.ENABL	LSB
 
EXE$OPRSNDERL::				; SEND TO ERROR LOGGER
	.WORD	^M<R2,R3,R4,R5>		;
	PUSHL	S^#EMB$K_OM		; SET MESSAGE TYPE TO OPERATOR MESSAGE
	BRB	10$			; JOIN COMMON CODE
	.PAGE
	.SBTTL	EXE$NETSNDERL - NETWORK SEND MESSAGE TO ERROR LOGGER
;++
; EXE$NETSNDERL - NETWORK SEND MESSAGE TO ERROR LOGGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ERROR LOGGER SYSTEM SERVICE
; FOR THE NETWORK COMMUNICATION PROCESS.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE ERROR LOG FORMAT PROGRAM.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;--
 
EXE$NETSNDERL::				; SEND TO ERROR LOGGER
	.WORD	^M<R2,R3,R4,R5>		;
	PUSHL	S^#EMB$K_NM		; SET MESSAGE TYPE TO NETWORK MESSAGE
	BRB	10$			; JOIN COMMON CODE
	.PAGE
	.SBTTL	EXE$SNDERL - SEND MESSAGE TO ERROR LOGGER
;++
; EXE$SNDERR - SEND MESSAGE TO ERROR LOGGER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PROVIDES THE SEND TO ERROR LOGGER SYSTEM SERVICE.
; THE ACTION IS TO BUILD A MESSAGE CONSISTING OF A COMMON HEADER
; AND THE USER SPECIFIED TEXT AND THEN SEND IT TO THE ERROR LOG FORMAT PROGRAM.
; THE SPECIFIED MESSAGE IS ADDRESSED CHECKED.
;
; INPUTS:
;
;	MSG(AP) = ADDRESS OF THE MESSAGE DESCRIPTER
;	R4	= ADDRESS OF CURRENT PROCESS PCB - COURTESY OF CMKRNL
;
; OUTPUTS:
;
;	R0 = STATUS OF THE OPERATION
;
; STATUS CODES RETURNED:
;
;	SS$_NORMAL - SUCCESSFUL OPERATION
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR THE REQUEST
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_NOPRIV - PROCESS DOES NOT HAVE REQUIRED PRIVILEGE
;--
EXE$SNDERR::				; SEND TO ERROR LOGGER
	.WORD	^M<R2,R3,R4,R5>		; REGISTERS USED
	MOVW	#SS$_NOPRIV,R0		; ASSUME SUER HAS NO PRIVILEGE
	IFNPRIV	BUGCHK,30$		; BR IF NO PRIVILEGE
	PUSHL	S^#EMB$C_SS		; SET MESSAGE TYPE CODE
;
; 0(SP) = MESSAGE TYPE CODE
;
10$:	MOVL	MSG(AP),R1		; GET ADDRESS OF MESSAGE DESCRIPTOR
	BSBW	EXE$PROBER_DSC		; CHECK ACCESS TO DESCRIPTOR AND BUFFER
	BLBC	R0,30$			; BR IF CAN'T READ DESCRIPTOR OR BUFFER
;
; R1<0:15> = SIZE, R2 = ADDRESS OF BUFFER
;
	MOVZWL	R1,R1			; GET SIZE OF MESSAGE AS A WORD
	MOVQ	R1,R4			; R4 = SIZE, R5 = ADDRESS OF BUFFER
	ADDL	#EMB$K_SS_LENGTH+3,R1	; SET SIZE OF MESSAGE BUFFER NEEDED
	BICL	#3,R1			; MODULO 4 BYTES
	BSBW	ERL$ALLOCEMB		; ATTEMPT TO ALLOCATE A BUFFER
	BLBC	R0,20$			; BR IF CAN'T ALLOCATE BUFFER
	CVTLW	(SP)+,EMB$W_SS_ENTRY(R2) ; STORE MESSAGE TYPE
	MOVW	R4,EMB$W_SS_MSGSZ(R2)	; STORE LENGTH OF DATA MESSAGE
	PUSHL	R2			; SAVE STARTING ADDRESS OF BUFFER
	MOVC	R4,(R5),EMB$B_SS_MSGTXT(R2) ; INSERT USERS DATA INTO THE BUFFER
	POPR	#^M<R2>			; RESTORE START OF MESSAGE
	BSBW	ERL$RELEASEMB		; RELEASE THE BUFFER TO THE ERROR LOGGER
	MOVL	S^#SS$_NORMAL,R0	; SET SUCCESSFUL STATUS
	RET				; SUCCESSFUL RETURN
20$:	MOVZWL	#SS$_INSFMEM,R0		; SET INSUFFICIENT MEMORY FLAG
30$:	RET				; ERROR RETURN
	.DSABL	LSB
 

	.SBTTL	SETOPR - set OPR bit in device UCB
;++
; EXE$SETOPR
;
; Functional Descripton:
;
;	This routine will set or clear the OPR bit in a
;	terminal, remote terminal, or mailbox UCB.
;
; Input:
;
;	DEVNAM(AP)	= Address of device name descriptor
;	BIT_STATE(AP)	= Value of the OPR bit.  Must be 0 or 1.
;
; Implicit Inputs:
;
;	The caller has OPER privilege.
;
; Output:
;
;	None.
;
; Implict Outputs:
;
;	R1 = address of device UCB
;
; Routine value:
;
;	R0 = The status of the operation.  Possible values listed below.
;
;	SS$_NORMAL	- The operation was completed.
;
;	SS$_ACCVIO	- The device name descriptor could not be accessed.
;	SS$_BADPARAM	- The bit state was not 0 or 1.
;	SS$_IVDEVNAM	- The device name specified was not valid.
;	SS$_NONLOCAL	- The specified device is not local.
;	SS$_NOPRIV	- The caller does not have OPER privilege.
;	SS$_NOSUCHDEV	- The specified device does not exist.
;--

;
; Local symbols
;

DEVNAM = 4				; Offset to device descriptor parameter
BIT_STATE = 8				; Offset to OPR bit state parameter

	.ENTRY	EXE$SETOPR,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; Check the input parameters.
;
;
; Make sure the caller has OPER privilege.
;
	MOVZWL	#SS$_NOPRIV,R0		; Assume insufficeint privilege
	MOVL	G^CTL$GL_PCB,R4		; Get current process PCB address
	IFNPRIV	OPER,13$		; Branch if no OPER privilege
;
; PROBE the device name descriptor for read access.
; The actual device name string is PROBEd by LOG$TRNSLOGNAME
; during processing by IOC$SEARCHDEV.
;
	MOVL	DEVNAM(AP),R3		; Get the device descriptor address
	MOVZWL	#SS$_ACCVIO,R0		; Assume not readable
	IFNORD	#8,(R3),13$		; Check descriptor for readability
;
; Check the bit_state parameter.
;
	MOVZWL	#SS$_BADPARAM,R0	; Assume value not 0 or 1
	BITL	#^C1,BIT_STATE(AP)	; Test for all but low bit set
	BEQL	20$			; Branch if yes
13$:	RET				; Exit with error
;
; Lock the I/O database for read access and search for the device.
; If the device exists, and it is a terminal, remote terminal or
; mailbox, then set the OPR bit as indicated.  A side effect of
; locking the I/O database is that the IPL is raised to IPL$_ASTDEL.
;
20$:	BSBW	SCH$IOLOCKR		; Lock I/O database for read access
	MOVL	R3,R1			; Get device name descriptor address
	BSBW	IOC$SEARCHDEV		; Search for the device
	BLBC	R0,UNLOCK		; Branch if error
;
; Check the device type.  R1 now contains the device UCB address.
;
	MOVZWL	#SS$_IVDEVNAM,R0	; Assume invalid device
	BITL	#DEV$M_TRM!DEV$M_MBX,-	; Check device type
		UCB$L_DEVCHAR(R1)	;
	BEQL	UNLOCK			; Branch if not an operator type device
;
; Set the OPR bit as indicated.
;
	MOVZWL	#SS$_NORMAL,R0		; Set normal return status
	TSTL	BIT_STATE(AP)		; Set or clear?
	BEQL	30$			; Branch if clear desired
	BBSS	#DEV$V_OPR,-		; Set the OPR bit
		UCB$L_DEVCHAR(R1),25$	;
25$:	BRB	UNLOCK			; Exit
30$:	BBCC	#DEV$V_OPR,-		; Clear the OPR bit
		UCB$L_DEVCHAR(R1),UNLOCK;
UNLOCK:	PUSHL	R0			; Save return status
	BSBW	SCH$IOUNLOCK		; Unlock the I/O database
	SETIPL	#0			; Allow all interrupts
	MOVL	(SP)+,R0		; Restore return status
	RET				; Return

	.END	
