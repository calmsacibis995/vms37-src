	.TITLE	EXCEPTMSG - EXCEPTION MESSAGE FORMAT AND PRINT ROUTINE
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 9-NOV-77
;
; EXCEPTION MEESAGE FORMAT AND PRINT ROUTINE
;
; Modified by:
;
;	V02-003	LMK0001		Len Kawell		3-Sep-1981
;		Change PSECT names to re-order system image.
;
;	V02-002	LJK0033		Lawrence J. Kenah	2-Jun-1981
;		Add dump of top of stack to output display
;
	.PAGE
	.SUBTITLE	DECLARATIONS	
;
; MACRO LIBRARY CALLS
;
 
	$CHFDEF				;DEFINE CONDITION HANDLING ARGLST OFFSETS
	$FABDEF				;DEFINE FAB OFFSETS
	$RABDEF				;DEFINE RAB OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
MESSAGE=4				;ADDRESS OF ASCIZ STRING
SIGNAL=8				;ADDRESS OF SIGNAL ARGUMENT LIST
 
;
; OUTPUT FORMAT BUFFER SIZE
;
 
BUFSIZ=80				;
 
;
; LOCAL DATA
;
 
	.PSECT	YEXEPAGED2,BYTE
HEADNG:	.ASCIZ	/  Improperly handled condition, / ;
REGMSG:	.ASCIZ	/	Register dump/	;
REGDMP:	.ASCII	/	R0 = /<0>/  R1 = /<0>/  R2 = /<0>/  R3 = /<0><128> ;
	.ASCII	/	R4 = /<0>/  R5 = /<0>/  R6 = /<0>/  R7 = /<0><128> ;
	.ASCII	/	R8 = /<0>/  R9 = /<0>/  R10= /<0>/  R11= /<0><128> ;
	.ASCII	/	AP = /<0>/  FP = /<0>/  SP = /<0>/  PC = /<0><128> ;
	.ASCII	/	PSL= /<0><128>	;
SIGCTL:	.ASCIZ	/		 /	;
SIGCTL_BY_3:
	.ASCIZ	/					 /
SIGMSG:	.ASCIZ	/	Signal arguments	      Stack contents/
SIGNAM:	.ASCIZ	/	Name   = /	;SIGNAL NAME
SIGNUM:	.ASCIZ	/	Number = /	;SIGNAL ARGUMENTS NUMBER
	.PAGE
	.SBTTL	EXCEPTION MESSAGE FORMAT AND PRINT ROUTINE
;+
; EXE$EXCMSG - EXCEPTION MESSAGE FORMAT AND PRINT ROUTINE
;
; THIS ROUTINE IS CALLED WHEN NO EXCEPTION HANDLER CAN BE FOUND OR ALL HANDLERS
; RESIGNAL. ITS FUNCTION IS TO PRINT A SUMMARY OF THE CURRENT PROCESS STATE AND
; WHY THE PROCESS RECEIVED THE EXCEPTION.
;
; INPUTS:
;
;	MESSAGE(AP) = ADDRESS OF MESSAGE SUFFIX STRING.
;	SIGNAL(AP) = ADDRESS OF SIGNAL ARGUMENT LIST.
;
; OUTPUTS:
;
;	THE HEADING MESSAGE IS FORMATTED BY ADDING THE SPECIFIED SUFFIX AND
;	IS THEN WRITTEN TO 'SYS$ERROR'. THIS INFORMATION IS FOLLOWED BY A DUMP
;	OF THE SIGNAL ARGUMENTS AND GENERAL REGISTERS. WHILE THE OUTPUT IS
;	BEING WRITTEN TO 'SYS$ERROR' IT IS ALSO WRITTEN TO 'SYS$OUTPUT' IF
;	THEY ARE DIFFERENT FILES.
;-
 
	.ENTRY	EXE$EXCMSG,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BSBW	EXE$OPEN_MSG		;OPEN MESSAGE FILES AND INITIALIZE RAB'S
	MOVAB	-BUFSIZ(SP),SP		;ALLOCATE SPACE FOR OUTPUT BUFFER
	MOVL	SP,R7			;SAVE ADDRESS OF OUTPUT BUFFER
	MOVAB	-17*4(SP),SP		;ALLOCATE REGISTER SAVE AREA
	MOVL	SIGNAL(AP),R6		;GET ADDRESS OF SIGNAL ARGUMENTS
	MOVL	SP,R0			;SET ADDRESS OF REGISTER SAVE AREA
	MOVL	CHF$L_MCHARGLST(R6),R1	;GET ADDRESS OF MECHANISM ARRAY
	MOVQ	CHF$L_MCH_SAVR0(R1),(R0)+ ;INSERT ORIGINAL R0 AND R1
	MOVAB	20(FP),R1		;GET ADDRESS OF SAVED REGISTERS
	MOVL	#10,R2			;SET REGISTER COUNT
10$:	MOVL	(R1)+,(R0)+		;INSERT ORIGINAL REGISTERS
	SOBGTR	R2,10$			;ANY MORE REGISTERS TO SAVE?
	MOVQ	8(FP),(R0)+		;INSERT ARGUMENT AND FRAME POINTERS
	MOVL	CHF$L_SIGARGLST(R6),R6	;GET ADDRESS OF SIGNAL ARRAY
	MOVL	(R6),R5			;GET NUMBER OF SIGNAL ARGUMENTS
	MOVAL	4(R6)[R5],R8		;INSERT STACK POINTER ADDRESS 
	MOVL	R8,(R0)+		;USE R8 AS STACK LIST TRAVERSAL REGISTER
	MOVL	-4(R6)[R5],(R0)+	;INSERT SAVED PROGRAM COUNTER
	MOVL	(R6)[R5],(R0)		;INSERT SAVED PROCESSOR STATUS
	MOVAB	(R7),RAB$L_RBF(R10)	;SET ADDRESS OF RECORD BUFFER
	MOVAB	(R7),RAB$L_RBF(R11)	;SET ADDRESS OF RECORD BUFFER
	BSBW	PUT			;OUTPUT RECORD
	MOVAB	HEADNG,R1		;GET ADDRESS OF INITIAL HEADING
	BSBW	INSERT			;INSERT HEADING IN OUTPUT BUFFER
	MOVL	MESSAGE(AP),R1		;GET ADDRESS OF MESSAGE SUFFIX
	BSBW	PUTI			;INSERT SUFFIX IN OUTPUT BUFFER AND PRINT
	MOVAB	SIGMSG,R1		;GET ADDRESS OF SIGNAL ARGUMENT MESSAGE
	BSBW	PUTI			;INSERT MESSAGE IN OUTPUT BUFFER AND PRINT
	SUBL3	#1,(R6),R5		;CALCULATE NUMBER OF SIGNAL ARGUMENTS - 1
	SUBL3	#8,R5,-(SP)		;STORE DIFFERENCE ON STACK
	BLEQU	15$			;BRANCH IF SIGNAL ARRAY SMALLER
	MOVL	#8,R5			;STACK DISPLAY IS SMALLER
15$:	MOVAB	SIGNUM,R1		;GET ADDRESS OF ARGUMENT NUMBER PREFIX
	BSBW	PUTC_BOTH		;WRITE TWO COLUMN ENTRIES
	MOVAB	SIGNAM,R1		;GET ADDRESS OF SIGNAL NAME PREFIX
	BSBW	PUTC_BOTH		;WRITE TWO COLUMN ENTRIES
20$:	MOVAB	SIGCTL,R1		;GET ADDRESS OF INDENT MESSAGE
	BSBW	PUTC_BOTH		;WRITE TWO COLUMN ENTRIES
	SOBGTR	R5,20$			;ANY MORE TO CONVERT?
	POPL	R5			;RETRIEVE DIFFERENCE
	BEQL	REG_DUMP		;NO DIFFERENCE. GO DUMP REGISTERS
	BGTR	25$			;SIGNAL ARRAY LARGER. DUMP BALANCE.
22$:	MOVAB	SIGCTL_BY_3,R1		;DUMP BALANCE OF STACK (UP TO 10 LONGWORDS)
	BSBB	INSERT			;INSERTED EXTENDED INDENT INTO OUTPUT RECORD
	BSBW	PUTC_R8			;OUTPUT THIS STACK LONGWORD
	AOBLSS	#0,R5,22$		;GO GET NEXT ONE
	BRB	REG_DUMP		;ALL DONE. DUMP REGISTERS

25$:	MOVAB	SIGCTL,R1		;DUMP BALANCE OF SIGNAL ARRAY
	BSBB	INSERT			;INSERTED INDENT INTO OUTPUT RECORD
	BSBB	PUTC_R6			;OUTPUT THIS SIGNAL ARRAY ELEMENT
	SOBGTR	R5,25$			;GO GET NEXT ONE

REG_DUMP:
	BSBB	PUT			;OUTPUT BLANK LINE
	MOVAB	REGMSG,R1		;GET ADDRESS OF REGISTER DUMP MESSAGE
	BSBB	PUTI			;INSERT MESSAGE IN OUTPUT BUFFER AND PRINT
	MOVL	#5,R4			;SET NUMBER OF LINES TO PRINT
	MOVAB	REGDMP,R5		;SET ADDRESS OF REGISTER DUMP CONTROL STRING
	MOVL	SP,R6			;SET ADDRESS OF REGISTER SAVE AREA
30$:	CVTBL	(R5)+,R0		;GET NEXT BYTE FROM CONTROL STRING
	BLEQ	40$			;IF LEQ CONTROL BYTE
	BSBB	PUTB			;PUT BYTE IN OUTPUT BUFFER
	BRB	30$			;
40$:	BLSS	50$			;IF LSS END OF LINE
	BSBB	CONVERT_R6		;CONVERT NEXT REGISTER VALUE
	BRB	30$			;
50$:	BSBB	PUT			;OUTPUT RECORD
	SOBGTR	R4,30$			;ANY MORE LINES TO PRINT?
	BSBB	PUT			;OUTPUT RECORD
	RET				;
	.PAGE	
	.SUBTITLE	UTILITY SUBROUTINES
;
; INSERT TEXT IN OUTPUT BUFFER
;
 
	.ENABL	LSB
INSERT:	MOVZBL	(R1)+,R0		;GET NEXT BYTE FROM TEXT STRING
	BEQL	10$			;IF EQL END OF TEXT STRING
	BSBB	PUTB			;PUT BYTE IN OUTPUT BUFFER
	BRB	INSERT			;
 
;
; PUT BYTE IN OUTPUT BUFFER
;
 
PUTB:	TSTW	RAB$W_RSZ(R10)		;ANY ROOM LEFT IN BUFFER?
	BEQL	10$			;IF EQL NO
	DECW	RAB$W_RSZ(R10)		;DECREMENT NUMBER OF BYTES REMAINING
	MOVB	R0,(R7)+		;INSERT BYTE IN OUTPUT BUFFER
10$:	RSB				;
	.DSABL	LSB
 
;
; INSERT TEXT IN OUTPUT BUFFER AND OUTPUT RECORD AND BLANK RECORD
;
 
PUTI:	BSBB	INSERT			;INSERT TEXT IN BUFFER
	BSBB	PUT			;OUTPUT RECORD
 
;
; OUTPUT CURRENT RECORD AND RESET RECORD PARAMETERS
;
 
PUT:	SUBL3	RAB$L_RBF(R10),R7,R0	;CALCULATE LENGTH OF OUTPUT RECORD
	MOVW	R0,RAB$W_RSZ(R10)	;SET LENGTH OF OUTPUT RECORD
	MOVW	R0,RAB$W_RSZ(R11)	;SET LENGTH OF OUTPUT RECORD
	$PUT	RAB=(R10)		;OUTPUT RECORD
	MOVL	RAB$L_RBF(R10),R7	;RESET OUTPUT RECORD POINTER
	MOVZBW	#BUFSIZ,RAB$W_RSZ(R10)	;RESET OUTPUT RECORD BUFFER SIZE
	CMPW	RAB$W_ISI(R10),RAB$W_ISI(R11) ;ERROR AND OUTPUT FILES EQUIVALENCT?
	BEQL	10$			;IF EQL YES
	$PUT	RAB=(R11)		;OUTPUT RECORD
10$:	RSB				;
 
;
; CONVERT HEXDECIMAL VALUE AND OUTPUT RECORD
;
 
PUTC_R6:
	BSBB	CONVERT_R6		;CONVERT HEXADECIMAL VALUE
	BRB	PUT			;OUTPUT RECORD

PUTC_BOTH:
	BSBB	INSERT			;INSERT INDENT PREFIX IN OUTPUT BUFFER
	BSBW	CONVERT_R6		;CONVERT NUMBER AND PUT INTO RECORD
	MOVAB	SIGCTL,R1		;ADD HORIZONTAL SPACER
	BSBB	INSERT			;ADD SPACER TO OUTPUT RECORD
PUTC_R8:
	BSBB	CONVERT_R8		;CONVERT HEXDECIMAL VALUE
	BRB	PUT			;OUTPUT RECORD

;
; CONVERT NUMBER BASE 16
;
 
	.ENABLE		LOCAL_BLOCK

CONVERT_R6:				;LIST TRAVERSED BY R6
	MOVL	(R6)+,R1		;GET NUMBER TO BE CONVERTED
	BRB	5$			;JOIN COMMON CODE

CONVERT_R8:				;LIST TRAVERSED BY R8
	MOVL	(R8)+,R1		;GET NUMBER TO BE CONVERTED
5$:	MOVL	#28,R2			;SET STARTING BIT NUMBER
10$:	EXTZV	R2,#4,R1,R0		;GET NEXT HEXDECIMAL DIGIT
	MOVZBL	EXE$AB_HEXTAB[R0],R0	;CONVERT HEXDIGIT TO ASCII
	BSBB	PUTB			;PUT BYTE IN OUTPUT BUFFER
	ACBB	#0,#-4,R2,10$		;ANY MORE DIGITS TO CONVERT?
	RSB				;
 
	.DISABLE	LOCAL_BLOCK

	.END
