	.IF	NDF,PRMSW
	.TITLE	SCSVEC - System Communications Service Vectors
	.IFF
	.TITLE	SCSLOA - System Communications Service Loadcode
	.ENDC
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	Executive data base
;
; ABSTRACT:
;	This module contains the global entry point vectors for System
;	Communications Services (SCS).  The targets of these vectors are
;	updated to point to the actual SCS image after it is loaded into
;	non-paged pool.
;
; ENVIRONMENT:  
;
; AUTHOR:  KERBEY T. ALTMANN, CREATION DATE:	22-APR-1981
;
; MODIFIED BY:
;
;	V03-001	ROW0081		Ralph O. Weber		10-APR-1982
;		Replace SCS$LKP_RDTCDRP and SCS$LKP_RDTWAIT with completely 
;		redesigned routines which perform the same functions.  Also 
;		make several other minor changes; change PUSHLs to PUSHRs, 
;		etc.
;
;
;--

	.page
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES
;
	.nocross
	.IF	DF,PRMSW		; For linkage with SCS
	$CDLDEF
	$CDRPDEF
	$CDTDEF
	$CRBDEF
	$DDBDEF
	$DDTDEF
	$DYNDEF
	$PBDEF
	$PDTDEF
	$RDDEF
	$RDTDEF
	$SBDEF
	$SDIRDEF
	$SSDEF
	$UCBDEF
	.ENDC
;
; LOCAL MACROS
;
	.MACRO	LOADVEC	ENTRY,TYPE=3

	.IF	NDF,PRMSW		; For linkage with SYS.EXE,...
	 .IF	LE,TYPE-2		; Types 0,1,2 require alignment
	  .ALIGN  LONG
	 .ENDC

ENTRY::
	 .IF	LE,TYPE-1		; Data structure or pointer to such
	  .IF	EQ,TYPE+1		; For type=-1 (queheads)
	   .LONG  ENTRY
	   .LONG  ENTRY
	  .IFF				; For all other data structures
	   .LONG  0
	  .ENDC
	 .ENDC

	 .IF	GE,TYPE-2		; If defining vector to a routine...
	  JMP	@#EXE$LOAD_ERROR
	 .ENDC


	.IFF				; For linkage with loadable code
	 .IF	GE,TYPE-1		; For types >= 1
	  .BYTE	TYPE
	  .LONG	<ENTRY-.>
	 .ENDC
	.ENDC

	.ENDM
	.cross

;
; Misc labels
;
	.IF	NDF,PRMSW		; For linkage with SYS.EXE
	.PSECT	$$$500,LONG

;
; Quadword linked list heads
;

	LOADVEC	SCS$GQ_CONFIG,TYPE=-1
	LOADVEC	SCS$GQ_DIRECT,TYPE=-1

;
; Longword pointers
;

	LOADVEC	SCS$GL_BDT,TYPE=0
	LOADVEC	SCS$GL_CDL,TYPE=0
	LOADVEC	SCS$GL_RDT,TYPE=0
	LOADVEC	SCS$GL_MCLEN,TYPE=0
	LOADVEC	SCS$GL_MCADR,TYPE=0

;
; Vector list
;

SCS$AL_LOAVEC::
	.IFF
	.PSECT	$$$000,LONG
SCS_START:
	.LONG	SCS_END-.
	.LONG	INIT_BEGIN-SCS_START	; Initialization code
	.WORD	SCS_END-SCS_START	; Size of code
	.BYTE	DYN$C_LOADCODE		; Type of block
	.BYTE	DYN$C_LC_SCS		; Subtype
	.ENDC

	LOADVEC	SCS$ACCEPT
	LOADVEC	SCS$ALLOC_CDT
	LOADVEC	SCS$ALLOC_RSPID
	LOADVEC	SCS$CONFIG_PTH
	LOADVEC	SCS$CONFIG_SYS
	LOADVEC	SCS$CONNECT
	LOADVEC	SCS$DEALL_CDT
	LOADVEC	SCS$DEALL_RSPID
	LOADVEC	SCS$DISCONNECT
	LOADVEC	SCS$ENTER
	LOADVEC	SCS$LISTEN
	LOADVEC	SCS$LOCLOOKUP
	LOADVEC	SCS$REMOVE
	LOADVEC	IOC$THREADCRB
	LOADVEC	SCS$RESUMEWAITR
	LOADVEC	SCS$UNSTALLUCB
	LOADVEC	SCS$LKP_RDTCDRP
	LOADVEC	SCS$LKP_RDTWAIT

;
; End of list
;
	.IF	NDF,PRMSW
	.NLIST				; Don't clutter vector listing
	.IFF				; For linking with SCS
	.LONG	-1			; End of vectors
	.page
	.SBTTL	INITIALIZATION CODE
;+
; This code is called once upon the loading of SCS.  It initializes any
; piece of SCS that needs it.  It then deallocated itself to pool.
;-

INIT_BEGIN:
	SUBL	#12, SP			; Get some scratch area
	MOVL	SP, R6			; Set a pointer
	BSBB	SEQ_NO			; Get a sequence number
	BSBW	INIT_RDT		; Do the Request Desc
	BLBC	R0, 10$
;	BSBB	SEQ_NO			; Get a sequence number
	ADDW2	#^X10F3, 1(R6)		; Premute the low byte
	BSBW	INIT_CDL		; Do the Connect Desc
	ADDL	#12, SP			; Release the scratch area
	BLBC	R0, 10$			; Check for error
	LISTEN	MSGADR=W^SCS$DIRECTORY,-
		ERRADR=B^10$,-
		LPRNAM=B^DIRNAME,-
		PRINFO=B^DIRINFO 	; Put our name in directory-leave
					; (MUST BE AFTER INIT OF CDT)
	BLBS	R0, 20$			; Check for error
10$:	RSB

20$:	MOVAL	SCS_START, R0		; Set R0--> start of code
	MOVZWL	#<CODE_HEADER-SCS_START>,R1 ; Set the size of just the init code
	MOVL	G^EXE$GL_NONPAGED+4,R3	; List head
	JSB	G^EXE$DEALLOCATE	; Just the smile on the Cheshire cat...
	MOVL	#1,R0			; Set success
	RSB

;
DIRNAME:.ASCII	/SCS$DIRECTORY   /
DIRINFO:.ASCII	/What city, plez?/
;
; Calculate a randon sequence number from the system clock
;
SEQ_NO:	MFPR	#PR$_TODR,(R6)		; Grab system time
	MOVZWL	(R6), R0		; Get low 16 bits
	MOVZWL	2(R6), R1		; Get another 16 bits
	MULL2	R0, R1			; Multiply them
	MOVZWL	1(R6), R0		; Add in a fudge
	ADDL3	R0, R1, (R6)		; Store away for later
	BEQL	SEQ_NO			; Zero is unacceptable
	RSB
;
; Allocate and initialize the Connection Descriptor List
;
INIT_CDL:
	MOVZWL	@#SCS$GW_CDTCNT, R4	; Pick up number of CDT's to alloc
	MOVZWL	#CDT$C_LENGTH+15, R7	; Get size
	BICB	#15,R7			; Round up
	MULL3	R7, R4, R1		; Get total amount of space
	MOVL	#CDL$C_LENGTH, R5	; Fixed portion of CDL
	MOVAL	(R5)[R4], R5		; Get size of CDL
	ADDL2	R5, R1			; Get total size
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0, 20$			; Error - no memory
;
; R1  =  Size of allocated block
; R2 --> Allocated block
; R4  =  #CDT's to allocated
; R5  =  Size of CDL
; R7  =  Size of CDT(Rounded up)
;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save reg
	MOVC5	#0, (SP), #0, R1, (R2)	; Clear it all out
	POPR	#^M<R0,R1,R2,R3,R4,R5>
	MOVAL	CDL$C_LENGTH(R2), -
		@#SCS$GL_CDL		; Set pointer to CDL in system space
	MOVAB	(R2)[R5], R1		; Get pointer to first CDT
	MOVL	R4, (R2)+		; Set maximum connection index
	MOVL	R1, (R2)+		; Set first free CDT
	MOVW	R5, (R2)+		; Set size of CDL
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_CDL@8>,(R2)+	; Set type and subtype
	CLRL	(R2)+			; Clear reserved area
	CLRL	R5			; Initialize index
10$:	MOVL	R1, (R2)+		; Set address 	
	MOVAB	(R1)[R7], R3		; Get address of next CDT
	MOVL	R3, CDT$L_LINK(R1)	; Set it into link field
	MOVW	R7, CDT$W_SIZE(R1)	; Set size field
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_CDT@8>, -
		 CDT$B_TYPE(R1)		; Set type and subtype
	MOVW	R5, CDT$L_LCONID(R1)	; Set index piece of CONID
	MOVW	1(R6),CDT$L_LCONID+2(R1); Set sequence piece of CONID
	CLRL	CDT$W_STATE(R1)		; Set state to virgin
	MOVAB	CDT$L_WAITQFL(R1), -
		CDT$L_WAITQFL(R1)	; Set up initial cond
	MOVAB	CDT$L_WAITQFL(R1), -
		CDT$L_WAITQBL(R1)	; Set up initial cond
	MOVAB	CDT$L_CRWAITQFL(R1), -
		CDT$L_CRWAITQFL(R1)	; Set up initial cond
	MOVAB	CDT$L_CRWAITQFL(R1), -
		CDT$L_CRWAITQBL(R1)	; Set up initial cond
	MOVL	R3, R1			; Get next CDT
	AOBLSS	R4, R5,10$		; Loop until all done
	CLRL	-CDT$C_LENGTH(R1)	; Zero out final next pointer
	MOVL	#1, R0
20$:	RSB
;
; Allocate and initialize the Request Descriptor Table
;
INIT_RDT:
	ASSUME	RD$C_LENGTH EQ 8
	MOVZWL	@#SCS$GW_RDTCNT, R4	; Pick up number of RDTE's
	MOVL	#RDT$C_LENGTH, R1	; Fixed portion
	MOVAQ	(R1)[R4], R1		; Total space needed
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0, 20$			; No space, error
	MOVAB	RDT$C_LENGTH(R2), R3	; Set past RDT
	MOVL	R3, @#SCS$GL_RDT	; Set pointer to RDT in system space
	MOVL	R2, R5			; Save it
	MOVL	R5, (R2)+		; Set initial condition
	MOVL	R5, (R2)+		; Ditto
	MOVW	R1, (R2)+		; Set size field
	MOVW	#DYN$C_SCS!-
		<DYN$C_SCS_RDT@8>,(R2)+	; Set type & subtype
	MOVQ	R3, (R2)+		; Set first free RDTE & max RSPID index
	CLRL	(R2)+			; Clear out reserved field
	MOVAB	RD$C_LENGTH(R3), R3	; Set R3 point to next RDTE
10$:	MOVAQ	(R3)+, (R2)+		; Set next free RDTE link
	CLRW	(R2)+			; Set state to FREE
	MOVW	1(R6), (R2)+		; Set in sequence number
	SOBGTR	R4, 10$			; Loop until done
	CLRL	-RD$C_LENGTH(R2)	; Zero out final next pointer
	MOVL	#1, R0
20$:	RSB
	LC=.
	.=<LC+15>&-16			; Align on 16 byte boundary
;
; Put a standard 12 byte self-identifying header on this piece.
;
CODE_HEADER:
	.LONG	0,0
	.WORD	<SCS_END-CODE_HEADER>	; Length
	.BYTE	DYN$C_LOADCODE
	.BYTE	DYN$C_LC_SCS
	.page
	.SBTTL	SCS$ACCEPT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ACCEPT
;
; INPUTS:
;
;	R3 = Address of listening CDT
;	 0(SP) = Input address			MSGADR
;	 4(SP) = [Datagram input address]	DGADR
;	 8(SP) = Error address			ERRADR
;	12(SP) = Initial credit value		INITCR
;	14(SP) = Minimum send credit value	MINSCR
;	16(SP) = Initial DG credit value	INITDG
;	18(SP) = [Block transfer priority]	BLKPRI
;	20(SP) = Address of connect data	CONDAT
;	24(SP) = Address of auxilary structure	AUXSTR
;	28(SP) = [Bad response packet address]	BADRSP
;	32(SP) = Return address
;
; OUTPUTS:
;
;	R0 = Status
;	R2 = Address of listening CDT
;	R3 = Address of CDT allocated
;	R4 = Address of PDT for listening
;	R1,R2 Destroyed
;	R5   Preserved
;
;--

SCS$ACCEPT:
	MOVL	R3, R2			; Transfer listen CDT ptr
	BSBB	SCS$ALLOC_CDT		; Allocate a CDT
	BLBC	R0, 10$			; None, clean up and leave
	ASSUME	CDT$L_MSGINPUT+4 EQ CDT$L_DGINPUT
	MOVQ	(SP)+,CDT$L_MSGINPUT(R3); Get both MSGINPUT and DGINPUT
	POPL	CDT$L_ERRADDR(R3)	; Set address of error routine
	MOVL	CDT$L_PDT(R2), R4	; Pick up PDT addr from listen
	MOVZBL	#PDT$L_ACCEPT, R1	; Offset in PDT to use
	BRW	PDT_JMP			; Finish in port dependent code

10$:	ADDL	#8*4, SP		; Clean args off stack
	RSB
	.page
	.SBTTL	SCS$ALLOC_CDT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ALLOC_CDT
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL if success
;	   = SS$_INSFCDT if no CDT's available
;	R1 = CONID
;	R3 = Pointer to CDT if successful
;	   = 0 otherwize
;	R2,R4,R5 preserved
;
;--

SCS$ALLOC_CDT:
	MOVZWL	#SS$_INSFCDT, R0	; Assume failure
	MOVL	@#SCS$GL_CDL, R1	; Pick up pointer to list
	MOVL	CDL$L_FREECDT(R1), R3	; Find first free one
	BEQL	10$			; None free, leave with error
	MOVL	CDT$L_LINK(R3), -
		CDL$L_FREECDT(R1)	; Set to next free
	MOVL	CDT$L_LCONID(R3), R1	; Get conid for return to caller
	MOVL	#1,R0			; Set success
10$:	RSB
	.page
	.SBTTL	SCS$ALLOC_RSPID
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ALLOC_RSPID
;
; INPUTS:
;
;	R5 = Pointer to context block (usually CDRP)
;
; OUTPUTS:
;
;	R1 = RSPID
;	R2 = Pointer to RDTE
;	R0,R3,R4 preserved
;
;	RSPID stored in CDRP	(* What if not a CDRP input??? *)
;
; SIDE EFFECTS:
;
;	If no RSPID available, process is put on wait queue, and control
;	returned to caller's caller.
;
;--

SCS$ALLOC_RSPID:
	MOVL	@#SCS$GL_RDT, R1	; Pick up list head
	MOVL	RDT$L_FREERD(R1), R2	; Find first free one
	BEQL	10$			; None available
	MOVL	RD$L_LINK(R2), -
		RDT$L_FREERD(R1)	; Update free list
	SUBL3	R1, R2, R1		; Form offset
	ASHL	#13, R1, R1		; Turn into slot number
	MOVW	RD$W_SEQNUM(R2), R1	; Insert sequence number
	ROTL	#16, R1, R1		; Reverse to correct order
	MOVL	R1, CDRP$L_RSPID(R5)	; Store in contex block
	MOVL	R5, RD$L_CDRP(R2)	; Fill in context block addr
	INCW	RD$W_STATE(R2)		; Set state to IN-USE
	RSB

10$:	MOVQ	R3, CDRP$L_FR3(R5)	; Save R3,R4 in context block
	POPL	CDRP$L_FPC(R5)		; ... and PC
	INSQUE	CDRP$L_FQFL(R5), -	; Insert this context block
		@RDT$L_WAITBL(R1)	;   on RDT wait queue
	MOVL	CDRP$L_RWCPTR(R5), R0	; Pick up any counter
	BEQL	20$			; None
	INCW	(R0)			; Bump the number of resources
20$:	RSB				; Return to caller's caller
	.page
	.SBTTL	SCS$CONFIG_PTH
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	CONFIG_PATH searches  the  path  blocks  on  all  system
;	blocks for one with a matching station address.  If none
;	is found, error is returned.  Otherwise, most of the  PB
;	is returned in the caller's output array plus the system
;	ID of the remote system on this  path  and  the  station
;	address  of  the  next  path  to this remote system.  If
;	there are no more paths, the remote station ID  returned
;	is -1.
;
;	A fork process interested in discovering all paths to  a
;	particular  system  first  issues  a  CONFIG_SYS call to
;	learn the station address  of  the  first  path  to  the
;	system.    The   fork  process  then  calls  CONFIG_PATH
;	repeatedly  until  a  next  station  address  of  -1  is
;	returned.
;
; CALLING SEQUENCE:
;
;	BSBW	CONFIG_PTH
;
; INPUTS:
;
;	R1 = Address of station address
;	R2 = Address of output buffer to return path information
;		0 if no output desired
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHNODE if failure to find station address
;	   = 1 if success
;	R1 = Address of path block found (if R0 = success)
;	R2,R3,R4,R5 preserved
;
;--

SCS$CONFIG_PTH:
	PUSHR	#^M<R2,R3,R4>		; Save registers and output buf. ptr.
	MOVAL	@#SCS$GQ_CONFIG, R0	; Pick up pointer to database
	MOVL	R0, R2			; Hold starting point
10$:	MOVL	(R0), R0		; Get next block in list
	CMPL	R0, R2			; Back where we started (empty) ?
	BEQL	50$			; Yes, leave now
;
; Got a system block, now search for a path block
;
	MOVAL	SB$L_PBFL(R0), R3	; No, have a sys block - find 1st path
	MOVL	R3, R4			; Hold starting point
20$:	MOVL	(R3), R3		; Get next block in list
	CMPL	R3, R4			; Back where we started (empty) ?
	BEQL	10$			; Yes, try another system
	CMPL	(R1), PB$B_RSTATION(R3)	; No, have a pth - check for ID match
	BNEQ	20$			; No match on first 32 bits, try again
	CMPW	4(R1), PB$B_RSTATION+4(R3) ; Check high order
	BNEQ	20$			; No match on next 16 bits, try again
;
; Found a path block whose station address matches - return the info.
;
	MOVL	(SP),R2			; Recover addr to store info
	BEQL	40$			; None, done store anything
	MOVAL	PB$B_RSTATION(R3), R1	; R1 covers info in PB
	MOVQ	(R1)+, (R2)+		; Transfer 8 bytes
	MOVQ	(R1)+, (R2)+		; Transfer 8 bytes
	MOVQ	(R1)+, (R2)+		; Transfer 8 bytes
	MOVL	(R1), (R2)+		; Transfer 4 bytes
	MNEGL	#1, (R2)+		; Set reserved address to
	MNEGL	#1, (R2)+		; to indicate no next path.
	MOVL	(R3), R1		; Get next path block
	CMPL	R1, R4			; Is there a next?
	BEQL	30$			; No
	MOVQ	PB$B_RSTATION(R1), -8(R2) ; Yes, transfer its station address
	CLRW	-2(R2)			; Clear out reserved field
30$:	MOVQ	SB$B_SYSTEMID(R0), (R2)	; Transfer associated system ID
	CLRW	6(R2)			; Clear out reserved field
40$:	MOVL	#1, R0			; Set for success
	BRB	60$			; Clean up

50$:	MOVZWL	#SS$_NOSUCHNODE, R0	; Set for failure
60$:	POPL	R2			; Restore R2
	MOVL	R3, R1			; Transfer path block pointer
	MOVQ	(SP)+, R3		; Restore R3,R4
	RSB				; Leave
	.page
	.SBTTL	SCS$CONFIG_SYS
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	CONFIG_SYS searches the list of System Blocks  until  it
;	finds  one  with  a system ID matching the specified ID.
;	If no match is found,  error  is  returned.   Otherwise,
;	most  of  the SB is returned to the caller together with
;	the ID of the next system in the list.
;
;	A fork process interested in finding out about  all  the
;	systems  in  the  configuration simply issues successive
;	CONFIG_SYS  calls  on  the  next  system  ID  until  the
;	returned  next  system ID = 0.  To get information about
;	the first system, specify system ID of 0.   There  is  a
;	possibility  that  the configuration will change between
;	calls.
;
; CALLING SEQUENCE:
;
;	BSBW	CONFIG_SYS
;
; INPUTS:
;
;	R1 = Address of system id to search for
;	R2 = Address of output buffer to return system information
;		0 if none desired
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHNODE if system id not found
;	R1 = Address of system block found (if R0 = success)
;	R2,R3,R4,R5  Preserved
;
;--

SCS$CONFIG_SYS:
	PUSHR	#^M<R2,R3>		; Save reg. and output buffer ptr.
	MOVAL	@#SCS$GQ_CONFIG, R0	; Pick up pointer to database
	MOVL	R0, R2			; Hold starting point
10$:	MOVL	(R0), R0		; Get next block in list
	CMPL	R0, R2			; Back where we started (empty) ?
	BEQL	60$			; Yes, leave now
	TSTL	(R1)			; Is this possibly the magic 0 value?
	BNEQ	20$			; No, continue
	TSTW	4(R1)			; Yes, try the high 16 bits
	BEQL	30$			; Yes, it is 0 - just get the first one
20$:	CMPL	(R1), SB$B_SYSTEMID(R0)	; Nonzero value - check for a match
	BNEQ	10$			; No match - try again
	CMPW	4(R1), SB$B_SYSTEMID+4(R0) ; Lo 32 bits match - try high 16 bit
	BNEQ	10$			; No match - try again
;
; Found a matching system block - transfer the information
;
30$:	MOVL	(SP),R3			; Recover pointer to output array
	BEQL	50$			; None, don't bother to transfer
	MOVAL	SB$B_SYSTEMID(R0), R1	; Set R1 to cover info in system blk
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVL	(R1), (R3)+		; Move 4 bytes
	CLRQ	(R3)+			; Clear out 1st path station addr
	MOVL	SB$L_PBFL(R0), R1	; Get 1st path block
	BEQL	40$			; None there
	CMPL	R1, (R1)		; Is there really one?
	BEQL	40$			; No, skip on
	MOVQ	PB$B_RSTATION(R1), -8(R3) ; Yes, move in station id
	CLRW	-2(R3)			; Clear out reserved word
40$:	CLRQ	(R3)			; Clear out next system id
	MOVL	SB$L_FLINK(R0), R1	; Get next system block
	CMPL	R1, R2			; Is there really one?
	BEQL	50$			; No, skip on
	MOVQ	SB$B_SYSTEMID(R1), (R3)	; Yes, move in system id
	CLRW	6(R3)			; Clear out reserved word
50$:	MOVL	R0, R1			; Recover system block address
	MOVL	#1, R0			; Set success
	BRB	70$

60$:	MOVZWL	#SS$_NOSUCHNODE, R0	; Set failure
70$:	MOVQ	(SP)+, R2		; Clean stack
	RSB
	.page
	.SBTTL	SCS$CONNECT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$CONNECT
;
; INPUTS:
;
;	 0(SP) = Input address				MSGADR
;	 4(SP) = [Datagram input address]		DGADR
;	 8(SP) = Error address				ERRADR
;	12(SP) = Address of remote system ID		RSYSID
;	16(SP) = [Address of remote station addr]	RSTADR
;	20(SP) = Address of remote process name		RPRNAM
;	24(SP) = Address of local process name		LPRNAM
;	28(SP) = Initial credit value			INITCR
;	30(SP) = Minimum send credit value		MINSCR
;	32(SP) = [Initial datagram credit value]	INITDG
;	34(SP) = [Block transfer priority]		BLKPRI
;	36(SP) = [Address of connect data]		CONDAT
;	40(SP) = [Address of auxilary structure]	AUXSTR
;	44(SP) = [Bad response packet address]		BADRSP
;	48(SP) = Return address
;
; OUTPUTS:
;
;	R0 = Status
;	R3 = Address of CDT allocated if success
;	   = 0 if error status
;	R4 = Address of PDT for this station address
;	R1,R2 Destroyed
;	R5  Preserved
;
;	CDT fields filled in
;
;--

	.ENABLE lsb
SCS$CONNECT:
	BSBW	SCS$ALLOC_CDT		; Allocate a CDT
	BLBS	R0, 5$			; Okay
	BRW	140$			; None, clean up and leave
	ASSUME	CDT$L_MSGINPUT+4 EQ CDT$L_DGINPUT
5$:	MOVQ	(SP)+,CDT$L_MSGINPUT(R3); Get both MSGINPUT and DGINPUT
	POPL	CDT$L_ERRADDR(R3)	; Set address of error routine
;
; Now obtain the remote system id and use it to search the system
;  blocks for the correct one.  If found, return the PDT for the next 
;  path block and update that field.
;
	POPL	R1			; Pick up addr of rem system id
	CLRL	R2			; Don't want any info block
	BSBW	SCS$CONFIG_SYS		; Get the pointer to system block
	BLBS	R0, 10$			; Found it, continue
	TSTL	(SP)+			; Get rid of rem station addr
	BRB	90$			; Clean up stack and leave
;
; From the system block pick up the path block.  If REMOTE STATION not
; specified, find the next available path.  Check to see that it is open.
;
10$:	POPL	R4			; See if rem station addr specified
	BNEQ	70$			; Yes, use it
	MOVL	SB$L_PBCONNX(R1), R4	; Get the next path block to use
	MOVAL	SB$L_PBFL(R1), R0	; Hold path block list head
	MOVL	R4, R2			; Save original pointer
20$:	CMPW	PB$W_STATE(R4),#PB$C_OPEN ; Is it good?
	BEQL	50$			; Yes
30$:	MOVL	PB$L_FLINK(R4), R4	; No, try next block
	CMPL	R4, R2			; Back to start?
	BNEQ	40$			; No, try another
	MOVZWL	#SS$_UNREACHABLE, R0	; Yes, no good path
	BRB	90$			; Error out

40$:	CMPL	R4, R0			; Is it list head? (system block)
	BEQL	30$			; Yes, get another block
	BRB	20$			; No, try it

50$:	MOVL	PB$L_FLINK(R4), R2	; Try to find the next next block
	CMPL	R2, R0			; Is it list head?
	BNEQ	60$			; No, use it
	MOVL	PB$L_FLINK(R2), R2	; Yes, get the first in list
60$:	MOVL	R2, SB$L_PBCONNX(R1)	; Update next path block entry
	BRB	100$
;
; Remote station address specified, get the exact path.  Check to see 
; that it is open.
;
70$:	MOVL	R4, R1			; Set up input
	CLRL	R2			; No info to move
	BSBW	SCS$CONFIG_PTH		; Find it
	MOVL	R1, R4			; Transfer to correct register	
	BLBC	R0, 90$			; Error, leave
80$:	CMPW	PB$W_STATE(R4),#PB$C_OPEN ; Is it good?
	BEQL	100$			; Yes
	MOVZWL	#SS$_UNREACHABLE, R0	; No, no good path
90$:	BSBW	SCS$DEALL_CDT1		; Bad id, get rid of the CDT
	ADDL	#<2*4>, SP		; Get rid of process names
	BRB	150$			; Leave

100$:	MOVL	PB$B_RSTATION(R4), -	; Move in 32 bits of Remote Sta Id
		CDT$B_RSTATION(R3)	;    into the CDT
	MOVW	PB$B_RSTATION+4(R4), -	; Another 16 bits
		CDT$B_RSTATION+4(R3)
	MOVL	R4, CDT$L_PB(R3)	; Store the pointer to Path Block
	MOVL	PB$L_PDT(R4), R4	; Recover PDT entry
	MOVL	R4, CDT$L_PDT(R3)	; Store the PDT
	MOVZBL	#PDT$L_CONNECT, R1	; Offset in PDT to jump to
	ASSUME	CDT$L_RPROCNAM+4 EQ CDT$L_LPROCNAM
	MOVQ	(SP)+,CDT$L_RPROCNAM(R3); Get both local & remote process names
;
; Now take care of the credit fields
;
	ASSUME	CDT$W_MINSEND EQ CDT$W_INITLREC+2
	ASSUME	CDT$W_DGREC EQ CDT$W_MINSEND+2
	ASSUME	CDT$B_PRIORITY EQ CDT$W_DGREC+2
PDT_JMP:MOVQ	(SP)+,CDT$W_INITLREC(R3); Pick up initial rec, min send, dgrec,pro
	POPL	CDT$L_CONDAT(R3)	; Transfer connection data
	BNEQ	110$			; Something there
	MOVAB	B^BLANK,CDT$L_CONDAT(R3); Else give 'em blanks
	ASSUME	CDT$L_AUXSTRUC+4 EQ CDT$L_BADRSP
110$:	MOVQ	(SP)+,CDT$L_AUXSTRUC(R3); Pick up aux struc addr & bad resp addr
	ADDL2	R4,R1			; Pick up address from PDT
	JMP	@(R1)+			; Finish in port dependent code

140$:	ADDL	#7*4, SP		; Clean args off stack
150$:	ADDL	#5*4, SP
	RSB

BLANK:	.ASCII/                /
	.DISABLE lsb
	.page
	.SBTTL	SCS$DEALL_CDT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$DEALL_CDT
;
; INPUTS:
;
;	R3 = Pointer to CDT
;
; OUTPUTS:
;
;	R1 trashed
;	R3 cleared
;	R0,R2,R4,R5  preserved
;
; COMPLETION CODES:
;
;	NONE (always succedes)
;
;--

SCS$DEALL_CDT:				; Unlink from PB first
	PUSHL	R2			; Save a register
	MOVL	CDT$L_PB(R3), R1	; Pick up Path block
	MOVAL	PB$L_CDTLST-CDT$L_CDTLST(R1), R1 ; Point to head of list
10$:	MOVL	CDT$L_CDTLST(R1), R2	; Get next block
	BEQL	30$			; There is none	
	CMPL	R2, R3			; Are we next block?
	BEQL	20$			; Yes
	MOVL	R2, R1			; No, shift pointer
	BRB	10$			; And try again

20$:	MOVL	CDT$L_CDTLST(R3), -
		CDT$L_CDTLST(R1)	; Put our next link in last block
	CLRL	CDT$L_CDTLST(R3)	; Clear out link
30$:	POPL	R2			; Restore a register

SCS$DEALL_CDT1:				; Deallocate w/o unlinking
	MOVL	@#SCS$GL_CDL, R1	; Pick up list head
	MOVL	CDL$L_FREECDT(R1), -
		CDT$L_LINK(R3)		; Insert in chain
	MOVL	R3, CDL$L_FREECDT(R1)	; Set this block as first free
10$:	INCW	CDT$L_LCONID+2(R3)	; Bump sequence number
	BEQL	10$			; Zero not allowed
	ASSUME	CDT$W_STATE+2 EQ CDT$W_BLKSTATE
	CLRL	CDT$W_STATE(R3)		; Set to CLOSED
	CLRL	R3			; Eliminate any chance of spurious CDT
	RSB
	.page
	.SBTTL	SCS$DEALL_RSPID
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Check validity of the value in the CDRP$L_RSPID field. Increment
;	the RDTE sequence number.  Set the state to unallocated. Dequeue
;	next waiter for an RDTE and start him up; if none, just return
;	after linking RDTE to free list.
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$DEALL_RSPID
;
; INPUTS:
;
;	R5 --> CDRP
;	SCS$GL_RDT
;
; OUTPUTS:
;	R0,R1,R2  Destroyed
;	R3,R4,R5  Preserved
;
;--

SCS$DEALL_RSPID:
	MOVL	@#SCS$GL_RDT, R0	; Pick up list head
	MOVL	CDRP$L_RSPID(R5),R1	; Is there anything there?
	BEQL	20$			; No, bugcheck
	MOVZWL	R1, R2			; Pick up index portion
	CMPL	R2, RDT$L_MAXRDIDX(R0)	; Check it against max
	BGTRU	20$			; Too big, bugcheck
	ASSUME	RD$C_LENGTH EQ 8
	MOVAQ	(R0)[R2], R2		; Point at entry
	CMPW	RD$W_SEQNUM(R2), -
		CDRP$L_RSPID+2(R5)	; Compare sequence numbers
	BNEQ	20$			; No match ,bugcheck
	CLRL	CDRP$L_RSPID(R5)	; Clear it out
5$:	INCW	RD$W_SEQNUM(R2)		; Bump the sequence number
	BEQL	5$			; Zero not allowed
	REMQUE	@RDT$L_WAITFL(R0), -(SP); Grab any waiting process
	BVS	10$			; There is none
;
; There is a stalled process waiting for a RSPID, resume it.
;
	MOVL	(SP), R0		; Pick up pointer to context
	MOVL	R5, (SP)		; Save current context
	PUSHL	R4			; Ditto
	PUSHL	R3
	MOVL	R0, R5			; Transfer context block ptr
	MOVL	R1, CDRP$L_RSPID(R5)	; Transfer old RSPID
8$:	INCW	CDRP$L_RSPID+2(R5)	; Bump sequence number
	BEQL	8$			; Zero not allowed
	MOVL	R5, RD$L_CDRP(R2)	; Store his CDRP in the RDT
	BSBW	SCS$RESUMEWAITR		; Resume the waiter
	POPL	R3			; Restore
	MOVQ	(SP)+, R4		; Ditto
	RSB				; That's all

10$:	TSTL	(SP)+			; Get rid of trash on stack
	CLRW	RD$W_STATE(R2)		; Set state as free
	MOVL	RDT$L_FREERD(R0), -
		RD$L_LINK(R2)		; Insert in chain
	MOVL	R2, RDT$L_FREERD(R0)	; Set this one as first free
	RSB

20$:	BUG_CHECK  INVRSPID,FATAL	; "Invalid RSPID" bugcheck
	.page
	.SBTTL	SCS$DIRECTORY
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$DIRECTORY
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

SCS$DIRECTORY:
	ACCEPT	MSGADR=B^30$,-
		ERRADR=B^SCS$DISCONNECT,- ; If error, disconnect.
		INITCR=#1		  ; We'll accept anything
	RSB

30$:	MOVAB	4(R2), R1		; Pick up procname
	BSBW	SCS$LOCLOOKUP		; Look it up
	MOVW	R0, (R2)		; Set status
	MOVAB	<16+4>(R2), R2		; Set to info
	MOVQ	(R1)+, (R2)+		; Transfer first 8 bytes
	MOVQ	(R1), (R2)		; ... and sec 8
	MOVQ	R2,-(SP)		; Save address of message and CDT
	MOVZWL	#CDRP$C_LENGTH, R1	; Size of block needed
	BSBW	SCS_ALONONPAGED		; Allocate it
	MOVL	R2, R5			; Transfer address
	MOVQ	(SP)+, R2		; Restore registers
	MOVW	R1, CDRP$W_CDRPSIZE(R5)	; Set up block
	MOVZBW	#DYN$C_CDRP, -
		CDRP$B_CD_TYPE(R5)	; Set type
	MOVAL	CDRP$L_SAVD_RTN(R5), R0	; Set a pointer
	CLRL	(R0)+			; Just to be safe
	MOVL	R2, (R0)+		; Set address of buffer
	CLRL	(R0)+			; Indicate we are turning around
	MOVL	R3, (R0)+		; Set in pointer
	CLRL	(R0)+			; Just to be safe
	RECYCL_MSG_BUF			; We are going to recycle the buffer
	SEND_MSG_BUF			; Send message and term thread
	MOVL	R5, R0			; Set pointer to head of block
	BRW	SCS_DEALNONPAGD		; Get rid of the block
	.page
	.SBTTL	SCS$DISCONNECT
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; INPUTS:
;
;	R3 -->	CDT
;	R4 -->	PDT
;
; IMPLICIT INPUTS:
;
;	CDT$W_STATE
;
; OUTPUTS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	If state was LISTEN, then directory entry removed and CDT deallocated.
;
;--

SCS$DISCONNECT:
	ASSUME	CDT$C_CLOSED EQ 0
	TSTW	CDT$W_STATE(R3)		; Is state CLOSED?
	BNEQ	10$			; No
	MOVZWL	#SS$_ALRDYCLOSED,R0	; Yes, issue qualified success
	RSB

10$:	CMPW	CDT$W_STATE(R3), - 	; Is state LISTEN?
		#CDT$C_LISTEN
	BNEQ	20$			; No
	BRW	SCS$REMOVE		; Yes, remove the entry and exit

20$:	MOVL	CDT$L_PDT(R3),R4	; Pick up the PDT address
	JMP	@PDT$L_DCONNECT(R4)	; Let port driver handle other states
	.page
	.SBTTL	SCS$ENTER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$ENTER
;
; INPUTS:
;
;	R0 = Address of process name (16 byte string)
;	R1 = Address of process info (16 byte string)
;	R2 = CONID
;
;	SCS$GQ_DIRECT
;
; OUTPUTS:
;
;	R0 = SS$_INSFMEM if no pool for directory block
;	   = SS$_NORMAL if success
;	R1,R2  destroyed
;	R3,R4,R5  preserved
;
; SIDE EFFECTS:
;
;	NONE
;
;--

SCS$ENTER:
	PUSHR	#^M<R0,R1,R2,R3>	; Save registers and arguments.
	MOVL	#SDIR$C_LENGTH, R1	; Size of a directory entry
	BSBW	SCS_ALONONPAGED		; Allocate it
	BLBC	R0, 40$			; None, error out
	MOVAB	SDIR$W_SIZE(R2), R3	; Set pointer to size field
	MOVW	R1, (R3)+		; Set size field
	MOVW	#DYN$C_SCS!<DYN$C_SCS_DIR@8>, (R3)+ ; Size type and subtype
	POPL	R1			; Get pointer to process name
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVQ	(R1), (R3)+		; Move 8 bytes
	POPL	R1			; Get pointer to process info
	BEQL	10$			; None present
	MOVQ	(R1)+, (R3)+		; Move 8 bytes
	MOVQ	(R1), (R3)+		; Move 8 bytes
	BRB	20$

10$:	CLRQ	(R3)+			; Clear it out
	CLRQ	(R3)+			; Ditto
20$:	POPL	(R3)			; Set in CONID
	MOVL	@#SCS$GQ_DIRECT+4, R3	; End of queue
	INSQUE	(R2), (R3)		; Insert at end
30$:	POPL	R3			; Restore register
	RSB

40$:	ADDL	#3*4, SP		; Clean up stack
	BRB	30$			; ... and out
	.page
	.SBTTL	SCS$LISTEN
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$LISTEN
;
; INPUTS:
;
;	00(SP) = Address to call with CONNECT_REQ msg		MSGADR
;	04(SP) = Address to call with error in VC		ERRADR
;	08(SP) = Address of listening process name		LPRNAM
;	0C(SP) = Address of listening process information	PRINFO
;	10(SP) = Return address
;
; OUTPUTS:
;
;	R0 = SS$_INSFCDT if could not allocate CDT
;	   = SS$_INSFMEM if could not allocate pool for directory entry
;	   = SS$_NORMAL if success
;	R1,R2 destroyed
;	R3 = Pointer to CDT if success
;	   = 0 if failure
;	R4,R5 preserved
;
;	CDT$L_INPUT	Address to call process with CONNECT_REQ msgs
;	CDT$L_LCONID	Local connection id for CDT in R3
;	CDT$W_STATE	LISTENING
;
; SIDE EFFECTS:
;
;	Directory entry made if successful, CDT state set to LISTEN
;
;--

SCS$LISTEN:
	BSBW	SCS$ALLOC_CDT		; Grab a CDT
	BLBC	R0, 10$			; None, error out
	MOVL	R1, R2			; Shift CONID around
	POPL	CDT$L_MSGINPUT(R3)	; Fill in with address
	POPL	CDT$L_ERRADDR(R3)	; Ditto for errors
	MOVQ	(SP)+, R0		; Pick up arguments
	BSBW	SCS$ENTER		; Make a directory entry
	BLBC	R0, 20$			; None, error out
	MOVW	#CDT$C_LISTEN, -	; Set state to LISTENing
		CDT$W_STATE(R3)
	RSB

10$:	ADDL	#4*4, SP		; Clean up arguments
	RSB

20$:	BSBW	SCS$DEALL_CDT1		; Get rid of the CDT
	ADDL	#3*4, SP		; Clean up arguments
	RSB
	.page
	.SBTTL	SCS$LOCLOOKUP
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; INPUTS:
;
;	R1 = Addr of local process name to look up
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHOBJ if listener could not be found
;	   = SS$_NORMAL if listener found
;	R1 = Addr of entry if found
;	R2   Preserved
;	R3 = Addr of CDT for local process, if success
;	   = 0 if failure
;	R4,R5 Preserved
;
;--

SCS$LOCLOOKUP:
	PUSHL	R5			; Save a register
	MOVL	R1, R5			; Copy addr of proc name
	PUSHL	R4			; Save another reg
	PUSHL	R2			; ... and another
	MOVAL	@#SCS$GQ_DIRECT, R4	; Get head of directory list
	PUSHL	R4			; Save a copy
10$:	MOVL	(R4), R4		; Next entry
	CMPL	R4, (SP)		; End of the line?
	BEQL	30$			; Yes, leave - not found
	CMPC3	#16, (R5), -
		SDIR$B_PROCNAM(R4)	; Names match?
	BNEQ	10$			; No, try again
	MOVL	SDIR$L_CONID(R4), R5	; Yes, pick up CONID
	BEQL	30$			; Zero is error
	MOVZWL	R5, R2			; Isolate index
	MOVL	@#SCS$GL_CDL, R3	; Pick up pointer to CDL
	MOVL	(R3)[R2], R3		; Obtain pointer to selected CDT
	CMPL	R5, CDT$L_LCONID(R3)	; CONID's match?
	BNEQ	30$			; No, failure
	MOVL	#1, R0			; Yes, success
	MOVL	R4, R1			; Return pointer to entry
20$:	TSTL	(SP)+			; Get rid of temp
	POPL	R2			; Recover R2
	MOVQ	(SP)+, R4		; Restore registers
	RSB

30$:	MOVZWL	#SS$_NOSUCHOBJ, R0	; Could not find listener *** TEMP ****
	CLRL	R3			; No chance of spurious CDT
	BRB	20$			;  and out
	.page
	.SBTTL	SCS$REMOVE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	BSBW	SCS$REMOVE
;
; INPUTS:
;
;	R3 = CDT address
;
; OUTPUTS:
;
;	R0 = SS$_NOSUCHOBJ if could not find entry
;	   = SS$_NORMAL if successful
;	R1,R2 destroyed
;	R3 = 0 if successful
;	   = CDT if failure
;	R4,R5 preserved
;
; SIDE EFFECTS:
;
;	Directory entry removed from directory.
;
;--

SCS$REMOVE:
	MOVZWL	#SS$_NOSUCHOBJ, R0	; Assume failure
	MOVAL	@#SCS$GQ_DIRECT, R2	; Get pointer to directory head
	MOVL	R2, R1			; Copy
10$:	MOVL	(R2), R2		; Get next entry
	CMPL	R1, R2			; End of the line?
	BEQL	20$			; Yes, leave can't find entry
	CMPL	CDT$L_LCONID(R3), -
		SDIR$L_CONID(R2)	; Match CONID?
	BNEQ	10$			; No, try next one
	REMQUE	(R2), R0		; Yes, remove it
	PUSHL	R3			; Save CDT addr
	BSBW	SCS_DEALNONPAGD		; Release the pool space
	POPL	R3			; Restore CDT
	MOVL	#1, R0			; Set for success
	BRW	SCS$DEALL_CDT1		; Get rid of CDT and return

20$:	RSB				; Leave
	.page
	.SBTTL	IOC$THREADCRB

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine will thread a CRB onto the duetime chain headed by
;	IOC$CRBTMOUT.
;
; CALLING SEQUENCE:
;
;	JSB	IOC$THREADCRB
;
; INPUTS:
;
;	R3 -->	CRB
;
; OUTPUTS:
;
;	NONE
;
;--

IOC$THREADCRB:
	PUSHL	R0			; Save a register
	MOVAL	@#IOC$GL_CRBTMOUT, R0	; Pointer to list head
10$:	TSTL	(R0)			; End of the line?
	BEQL	20$			; Yes, go add new one
	MOVL	(R0), R0		; No, get next block
	BRB	10$			; Try, try again

20$:	MOVAL	CRB$L_TIMELINK(R3),(R0)	; Link the new block in
	POPL	R0			; Restore register
	RSB				; Leave

;
; Misc routines
;

SCS_ALONONPAGED:
	JSB	@#EXE$ALONONPAGED	; Allocate the pool
	BLBS	R0, 10$			; Skip out if success
	MOVZWL	#SS$_INSFMEM, R0	; Set a reconizible error code
10$:	RSB				; Leave

SCS_DEALNONPAGD:
	JMP	@#COM$DRVDEALMEM	; Deallocated
	.page
	.SBTTL	SCS$RESUMEWAITR
;++
;
; FUNCTIONAL DESCRIPTION:
;
; 	Global SCS routine to resume a thread that had been
;	waiting on a resource wait queue.  This routine resumes the thread
;	and upon return from the thread, if the CDRP associated with the
;	resumed thread had a RWAITCNT, then we attempt to start any stalled
;	IRP's that may have been queued to the UCB while we were waiting.
;
; INPUTS:
;
;	R5 => CDRP of thread to resume
;
; OUTPUTS:
;
;	Thread resumed and IRP's started up when appropriate.
;
;	Note all registers R0 - R5 may be modified.
;
;--

SCS$RESUMEWAITR:			; Here we will start driver thread that
					;  was waiting for resource.

;
; We divide the CDRP thread to be restarted into two classes:  Those which
;	do NOT have a RWAITCNT and those which do.  The code path for those
;	without is very simple and appears directly below.  The more complex
;	case of CDRP's with a RWAITCNT begins at label THREAD_HAS_RWAITCNT.
;

	MOVL	CDRP$L_RWCPTR(R5),R3	; R3 => UCB$L_RWAITCNT or R3 = 0.
	BNEQ	THREAD_HAS_RWAITCNT	; NEQ implies R3 => UCB$L_RWAITCNT.
	MOVQ	CDRP$L_FR3(R5),R3	; Restore register context to thread.
	JSB	@CDRP$L_FPC(R5)		; Call back driver thread.
	RSB				; Return to caller.

THREAD_HAS_RWAITCNT:			; Here we have R3 =>  UCB$L_RWAITCNT.
	DECW	(R3)			; One less CDRP waiting for resources.
	PUSHL	CDRP$L_UCB(R5)		; Save this CDRP'S UCB address on stack.
	MOVQ	CDRP$L_FR3(R5),R3	; Restore context of waiting IRP.
	JSB	@CDRP$L_FPC(R5)		; Call back driver thread.
	POPL	R5			; R5 => UCB.

;
; Here we have experienced return from a resumed thread that maintains a
;	UCB$W_RWAITCNT.  Now we see if we can start up any IRP's that may have
;	backed on this UCB.  These would be new IRP's that had not yet gotten
;	into STARTIO.
;
; NOTE - This entrypoint SCS$UNSTALLUCB may be called independently to
;	unstall UCB's that may have had non-zero RWAITCNT's for other
;	reasons.
;

SCS$UNSTALLUCB:
10$:	TSTW	UCB$W_RWAITCNT(R5)	; Can we startup backed up IRP's?
	BNEQ	20$			; NEQ implies NO, so branch around.
	REMQUE	@UCB$L_IOQFL(R5),R3	; Remove 1st (if any) IRP from queue.
	BVS	20$			; VS implies no backed up IRP's.
	PUSHL	R5			; Remember UCB address on stack.
	BICW	#UCB$M_CANCEL!-
		 UCB$M_TIMOUT,-
		UCB$W_STS(R5)		; Clear cancel and time out

	ASSUME	DDT$L_START	EQ	0
	MOVL	@UCB$L_DDT(R5),R1	; R1 => Start_io routine.
	JSB	(R1)			;START I/O OPERATION
	POPL	R5			; Restore R5 => UCB of interest.
	BRB	10$			; Loop back to start more backed up IRP's.

20$:	RSB
	.PAGE
	.SBTTL	SCS$LKP_RDTCDRP

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Search RDT for CDRPs with CDT address matching the one in R3
;	upon entry.  For each CDRP found, call user-supplied action 
;	routine.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$LKP_RDTCDRP
;
; INPUTS:
;
;	R0 -->  Addr of action routine
;	R3 -->	Addr of CDT
;
; OUTPUTS:
;
;	R0 -->	status code
;		success ==> RDT contains no CDRPs with matching CDT
;		failure ==> RDT contains one or more CDRPs with matching CDT
;	R1	not altered or preserved by this routine; may be used as a 
;		communication mechanism between action routine and caller of 
;		this routine
;	R2 - R5	preserved
;
; ACTION ROUTINE INPUTS:
;
;	R1 -->	unchanged from value set by this routine's caller
;	R3 -->	Addr of CDT
;	R4 -->	unchanged from value set by this routine's caller
;	R5 -->	Addr of CDRP
;
; ACTION ROUTINE OUTPUTS:
;
;	R0	scratch
;	R1	value to be returned to this routine's caller
;	R2	scratch
;	R3	Addr of CDT; MUST be preserved
;	R4 - R5	scratch
;
;	N.B. More likely than not R4 is a PDT address which also must be
;	preserved.  However, this routine makes no such assumption.
;
; STACK USAGE:
;
;	This routine manipulates the stack in a rather odd mannor.  Therefore, 
;	the following map of the stack, as it is at the time of the JSB to the 
;	action routine, is provided to describe how the stack is used.
;
;	!---------------------------------------------------------------!
;	!			Saved index R0				! :(SP)
;	!---------------------------------------------------------------!
;	!		      Saved list base R2			!
;	!---------------------------------------------------------------!
;	! r0		    Action routine address			!
;	!---------------------------------------------------------------!
;	! r1		       "found-one" flag			     R0 !
;	!---------------------------------------------------------------!
;	! r2			Saved register 2		     R2 !
;	!---------------------------------------------------------------!
;	! r4			Saved register 4		     R4 !
;	!---------------------------------------------------------------!
;	! r5			Saved register 5		     R5 !
;	!---------------------------------------------------------------!
;	  ^							      ^
;	  |-as saved by PUSHR			  as restored by POPR-|
;
;--

SCS$LKP_RDTCDRP:
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save registers, make place for saved
	MOVL	#1, 4(SP)		; "found-one" flag, & init. none found.
	MOVZWL	@#SCS$GW_RDTCNT, R0	; Pick up number of entries.
	MOVL	@#SCS$GL_RDT, R2	; Pick up pointer to list.
	PUSHL	R2			; Save that on the stack.
	ASSUME	RD$C_LENGTH EQ 8
10$:	MOVAQ	B^-8(R2)[R0], R5	; Pick up next entry.
	TSTW	RD$W_STATE(R5)		; Is it in use?
	BEQL	20$			; No, try another.
	MOVL	RD$L_CDRP(R5), R5	; Pick up CDRP pointer.
	BEQL	20$			; None, try another.
	CMPL	CDRP$L_CDT(R5), R3	; CDT's match?
	BNEQ	20$			; No, try some other.
	CLRL	8(SP)			; Raise "found-one" flag.
	PUSHL	R0			; Save list index.
	JSB	@8(SP)			; Call action routine.
	POPL	R0			; Restore list index.
	MOVL	(SP), R2		; Restore list base address.
20$:	SOBGTR	R0, 10$			; Loop until done.
	MOVAB	8(SP), SP		; Cleanup the stack.
	POPR	#^M<R0,R2,R4,R5>	; Restore saved "found-one" flag and
	RSB				; other preserved registers.
	.page
	.SBTTL	SCS$LKP_RDTWAIT

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Search RSPID wait queue for next CDRP with CDRP$L_CDT that 
;	matches CDT specified in R3.  For each CDRP found, call user-
;	supplied action routine.
;
; CALLING SEQUENCE:
;
;	JSB	SCS$LKP_RDTWAIT
;
; INPUTS:
;
;	R0 -->  Addr of action routine
;	R3 -->	Addr of CDT
;
; OUTPUTS:
;
;	R0 -->	status code
;		success ==> RDT contains no CDRPs with matching CDT
;		failure ==> RDT contains one or more CDRPs with matching CDT
;	R1	not altered or preserved by this routine; may be used as a 
;		communication mechanism between action routine and caller of 
;		this routine
;	R2 - R5	preserved
;
; ACTION ROUTINE INPUTS:
;
;	R1 -->	unchanged from value set by this routine's caller
;	R3 -->	Addr of CDT
;	R4 -->	unchanged from value set by this routine's caller
;	R5 -->	Addr of CDRP
;
; ACTION ROUTINE OUTPUTS:
;
;	R0	scratch
;	R1	value to be returned to this routine's caller
;	R2	scratch
;	R3	Addr of CDT; MUST be preserved
;	R4 - R5	scratch
;
;	N.B. More likely than not R4 is a PDT address which also must be
;	preserved.  However, this routine makes no such assumption.
;
;   STACK USAGE:
;	This routine manipulates the stack in a rather odd mannor.  Therefore, 
;	the following map of the stack, as it is at the time of the JSB to the 
;	action routine, is provided to describe how the stack is used.
;
;	!---------------------------------------------------------------!
;	!		  Saved next entry address R5			! :(SP)
;	!---------------------------------------------------------------!
;	!		   Saved end of list address			!
;	!---------------------------------------------------------------!
;	! r0		    Action routine address			!
;	!---------------------------------------------------------------!
;	! r1		       "found-one" flag			     R0 !
;	!---------------------------------------------------------------!
;	! r2			Saved register 2		     R2 !
;	!---------------------------------------------------------------!
;	! r4			Saved register 4		     R4 !
;	!---------------------------------------------------------------!
;	! r5			Saved register 5		     R5 !
;	!---------------------------------------------------------------!
;	  ^							      ^
;	  |-as saved by PUSHR			  as restored by POPR-|
;
;--

SCS$LKP_RDTWAIT:
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save registers, make place for saved
	MOVL	#1, 4(SP)		; "found-one" flag, & init. none found.
	MOVL	@#SCS$GL_RDT, R5	; Pick up pointer to list.
	MOVAL	RDT$L_WAITFL(R5), R5	; Point at wait queue head.
	PUSHL	R5			; Save end of queue information.
30$:	MOVL	(R5), R5		; Pick up next entry.
33$:	CMPL	R5, (SP)		; End of queue?
	BEQL	60$			; Yes, quit.
	CMPL	CDRP$L_CDT(R5), R3	; CDT's match?
	BNEQ	30$			; No, try again.
	CLRL	8(SP)			; Raise "found-one" flag.
	PUSHL	(R5)			; Save next entry address.
	JSB	@8(SP)			; Call action routine.
	POPL	R5			; Restore address of next entry.
	BRB	33$			; Since R5 already has the address
					; of the next entry, skip the queue
					; traversal step of this loop.
60$:	MOVAB	8(SP), SP		; Cleanup the stack.
	POPR	#^M<R0,R2,R4,R5>	; Restore saved "found-one" flag and
	RSB				; other preserved registers.

	LC=.
	.=<LC+15>&-16			; Align on 16 byte boundary
SCS_END:
	.ENDC				; End of conditional code
	.END
