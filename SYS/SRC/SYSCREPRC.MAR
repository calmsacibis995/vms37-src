	.TITLE	SYSCREPRC CREATE PROCESS SYSTEM SERVICE
	.IDENT	'V03-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT: SYSCREPRC IMPLEMENTS THE CREATE PROCESS SYSTEM SERVICE.
;
; ENVIRONMENT: KERNEL MODE
;
; AUTHOR: R. HUSTVEDT	, CREATION DATE: 29-NOV-76
;
; MODIFIED BY:
;
;	V03-001	STJ0236		Steven T. Jeffreys	17-Mar-1982
;		Modify the process quota list scanner so that it does
;		not give up until a zero byte is found.
;
;	V02-018	TMH0018		Tim Halvorsen		08-Jan-1982
;		Pass current message flags to subprocess via PQB.
;
;	V02-017	ACG0251		Andrew C. Goldstein,	29-Dec-1981  21:56
;		Get default file protection from creator or SYSGEN parameter
;
;	V02-016	LJK0101		Lawrence J. Kenah	14-Dec-1981
;		Require DETACH privilege in order to specify the BATCH or
;		NETWRK status flag to $CREPRC.
;
;	V02-015	LJK0094		Lawrence J. Kenah	1-Dec-1981
;		Treat elapsed CPU time and CPU time limit as unsigned
;		quantities.
;
;	V02-014	TCM0001		Trudy C. Matthews	26-Aug-1981
;		Fix bug in CPU time limit quota that allowed processes
;		with limited quota to create processes with infinite time
;		limit quota.
;
;	V02-013	LJK0046		Lawrence J. Kenah	19-Aug-1981
;		Move largest allowed default directory string into PQB.
;
;	V02-012	HRJ0025		Herb Jacobs		27-Jul-1981
;		Perform initial swap space allocation for process.
;
;	V02-011	SRB0029		Steve Beckhardt		17-Jul-1981
;		Added code to initialize lock queue header
;
;	V02-010	SRB0026		Steve Beckhardt		16-Jun-1981
;		Added ASSUME macros to check values of status flags
;		against those defined by $PRCDEF macro.
;
;	V02-009	HRJ0020		Herb Jacobs		27-Apr-1981
;		Added WSEXTENT quota and support for disable working set adjust.
;
;	V02-008	SRB0014		Steve Beckhardt		9-Apr-1981
;		Added code for enqueue quota.
;
;	V02-007	CNH0033		Chris Hume		18-Apr-1980
;		Fix WSQUOTA minimization.  (Values produced were one too low.)
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				; DEFINE JOB INFORMATION BLOCK
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFNDEF				; DEFINE PFN CONSTANTS
	$PHDDEF				; DEFINE PHD OFFESTS
	$PQBDEF				; DEFINE PROCESS QUOTA BLOCK
	$PQLDEF				; DEFINE PROCESS QUOTA LIST CODES
	$PRCDEF				; DEFINE $CREPRC STATUS FLAGS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRIDEF				; DEFINE PRIORITY INCREMENT CLASSES
	$PRVDEF				; DEFINE PRIVILEGE BITS
	$SSDEF				; DEFINE STATUS CODES
;
; MACROS:
;

; MACRO TO CREATE STSFLG MAPPING AND PRIVILEGE CHECK TABLES
;	STSFLAG	STSBIT [,PRV]

	.MACRO	STSFLAG	STSBIT,PRV
	.IF	B,PRV
	.BYTE	-1
	.IFF
	.BYTE	PRV$V_'STSBIT
	.ENDC
	.BYTE	PCB$V_'STSBIT
	.ENDM	STSFLAG

;
; MACRO TO CALL STRING MOVING AND VERIFICATION ROUTINE
;
	.MACRO	MOVSTRING LIM=15,SRC,DST
	BSBW	MOVSTR			; CALL MOVE SUBROUTINE
	.BYTE	LIM			; COUNT LIMIT
	.BYTE	SRC@-2			; SOURCE OFFSET FROM AP
	.BYTE	PQB$T_'DST		; DESTINATION OFFSET IN PQB
	.ENDM	MOVSTRING	

;
; EQUATED SYMBOLS:
;

PIDADR=4				; PID ADDRESS
IMAGE=8					; IMAGE NAME
INPUT=12				; INPUT LOGICAL NAME DESCRIPTOR
OUTPUT=16				; OUTPUT LOGICAL NAME DESCRIPTOR
ERROR=20				; ERROR LOGICAL NAME DESCRIPTOR
PRVADR=24				; PRIVILEGE MASK ADDRESS
QUOTA=28				; QUOTA BUFFER POINTER
PRCNAM=32				; PROCESS NAME DESCRIPTOR
BASPRI=36				; BASE PRIORITY
UIC=40					; UIC
MBXUNT=44				; MAILBOX UNIT NUMBER
STSFLG=48				; STATUS FLAG MASK

PQL_V_DEDUCT=0				; DEDUCTIBILE QUOTA FLAG

;
; OWN STORAGE:
;
	.LIST	MEB			; LIST MACRO GENERATED CODE

	.PSECT	Y$EXEPAGED,BYTE		; PAGEABLE PSECT
USRNAM:	.ASCII	/SYSTEM/		; DEFAULT USER NAME
UNAMSZ=.-USRNAM				; STRING LENGTH

	ASSUME	PRC$V_SSRWAIT  EQ  0
	ASSUME	PRC$V_SSFEXCU  EQ  1
	ASSUME	PRC$V_PSWAPM   EQ  2
	ASSUME	PRC$V_NOACNT   EQ  3
	ASSUME	PRC$V_BATCH    EQ  4
	ASSUME	PRC$V_HIBER    EQ  5
	ASSUME	PRC$V_LOGIN    EQ  6
	ASSUME	PRC$V_NETWRK   EQ  7
	ASSUME	PRC$V_DISAWS   EQ  8

STSFLGTBL:				; TRANSLATION TABLE FOR STATUS FLAG BITS
	STSFLAG	SSRWAIT			; BIT 0 => RESOURCE WAIT
	STSFLAG	SSFEXCU			; BIT 1 => SYSTEM SERVICE FAIL EXCEPTION
					;	   FOR USER MODE.
	STSFLAG	PSWAPM,PRV		; BIT 2 => PROCESS SWAP MODE
	STSFLAG	NOACNT,PRV		; BIT 3 => NO ACCOUNTING MESSAGE
PRV$V_BATCH=PRV$V_DETACH		; 
	STSFLAG	BATCH,PRV		; BIT 4 => BATCH
	STSFLAG	HIBER			; BIT 5 => HIBERNATE BEFORE CALLING 
					; INITIAL IMAGE IN PROCSTRT
PRV$V_LOGIN=PRV$V_DETACH		; 
	STSFLAG	LOGIN,PRV		; BIT 6 => LOGIN WITHOUT READING AUTH FILE
PRV$V_NETWRK=PRV$V_DETACH		; 
	STSFLAG	NETWRK,PRV		; BIT 7
	STSFLAG	DISAWS			; BIT 8 => DISABLE WORKING SET ADJUST
STSFLGCNT=<.-STSFLGTBL>@-1		; NUMBER OF STATUS FLAGS

	.PAGE
	.SBTTL	EXE$CREPRC - CREATE PROCESS SYSTEM SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$CREPRC CREATES A NEW PROCESS ACCORDING TO THE 
;	SUPPLIED PARAMETERS.  THE NEW PROCESS MAY BE EITHER A SUB-PROCESS
;	OR AN INDEPENDENT, DETACHED PROCESS.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$CREPRC
;
; INPUT PARAMETERS:
;	PIDADR(AP) - ADDRESS AT WHICH TO RETURN PID OF CREATED PROCESS
;	IMAGE(AP)  - ADDRESS OF IMAGE NAME STRING DESCRIPTOR
;	INPUT(AP)  - ADDRESS OF INPUT NAME STRING DESCRIPTOR
;	OUTPUT(AP) - ADDRESS OF OUTPUT NAME STRING DESCRIPTOR
;	ERROR(AP)  - ADDRESS OF ERROR LOGICAL NAME STRING DESCRIPTOR
;	PRVADR(AP) - ADDRESS OF PRIVILEGE MASK FOR CREATED PROCESS
;	QUOTA(AP)  - POINTER TO QUOTA BUFFER
;	PRCNAM(AP) - ADDRESS OF PROCESS NAME STRING DESCRIPTOR
;	BASPRI(AP) - BASE PRIORITY FOR CREATED PROCESS
;	UIC(AP)    - UIC FOR CREATED PROCESS(0 => SUB-PROCESS)
;	MBXUNT(AP) - MAILBOX UNIT NUMBER FOR TERMINATION MESSAGES
;	STSFLG(AP) - STATUS FLAG SETTINGS FOR CREATED PROCESS
;	R4 - ADDRESS OF CURRENT PROCESS CONTROL BLOCK
;
;			BIT	MEANING
;			---	-------
;			 0	RESOURCE WAIT DISABLE
;			 1	SYSTEM SERVICE FAIL EXCEPTION ENABLE
;			 2	PROCESS SWAP MODE
;			 3	ACCOUNTING MESSAGE DISABLE
;			 4	BATCH INDICATOR
;			 5	HIBERNATE BEFORE CALLING INITIAL IMAGE
;			 6	BYPASS LOGIN VERIFICATION FOR DETACHED
;				PROCESS.
;			 7	NETWORK INDICATOR
;			 8	DISABLE WORKING SET ADJUSTMENT
;
;
; OUTPUT PARAMETERS:
;	R0  -  COMPLETION STATUS CODE
;	@PIDADR(AP) - PROCESS ID (PID) OF CREATED PROCESS
;
; COMPLETION CODES:
;	SS$_NORMAL   -   SUCCESSFUL COMPLETION
;	SS$_ACCVIO   -   ACCESS VIOLATION
;	SS$_DUPLNAM  -   DUPLICATE PROCESS NAME
;	SS$_EXQUOTA  -   EXCEEDED QUOTA
;	SS$_INSFMEM  -   INSUFFICIENT MEMORY AVAILABLE
;	SS$_IVLOGNAM -   INVALID LOGICAL NAME
;	SS$_IVQUOTAL -   INVALID QUOTA LIST
;	SS$_IVSTSFLG -   INVALID STATUS FLAG ARGUMENT
;	SS$_NOPRIV   -   NO PRIVILEGE FOR SPECIFIED OPERATION
;
; SIDE EFFECTS:
;	IF NO ERRORS ARE DETECTED, A NEW PROCESS WILL HAVE BEEN ACTIVATED
;	AND MARKED NON-RESIDENT.  THE INITIAL INSWAP FOR THIS PROCESS
;	WILL BE FROM THE SHELL PROCESS.  EXECUTION FOR THIS PROCESS
;	BEGINS IN THE ROUTINE EXE$PROCSTRT WHICH WILL MOVE THE INFORMATION
;	FROM THE PROCESS QUOTA BLOCK TO THE APPROPRIATE LOCATIONS
;	IN THE PROCESS CONTEXT.  CONTROL WILL THEN BE GIVEN TO THE
;	SPECIFIED IMAGE.
;
;--

EXE$CREPRC::				; CREATE PROCESS SYSTEM SERVICE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; SAVE ALL REGISTERS
	PUSHL	PIDADR(AP)		; SAVE PID RETURN ADDRESS
	BEQL	10$			; NONE, NO PROBE
	IFNOWRT	#4,@(SP),20$		; CHECK FOR WRITABLE
10$:	MOVL	UIC(AP),R11		; FETCH UIC FOR CREATED PROCESS
	BEQL	30$			; CREATING SUB-PROCESS
	IFPRIV	DETACH,30$		; MAY THIS PROCESS CREATE DETACHED?
	MOVZWL	#SS$_NOPRIV,R0		; NO, SET ERROR CODE
	RET				; RETURN
20$:	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR CODE FOR ACCESS VIOLATION
	RET				; RETURN
30$:	BBS	#31,SP,35$		; BR IF TINY PROCESS
	MOVAB	-64(SP),SP		; ALLOCATE SPACE FOR DISK STRING
	PUSHAB	1(SP)			; SET ADDRESS IN DESCRIPTOR
	PUSHL	#63			; AND COUNT
	MOVL	SP,R0			; SAVE POINTER TO DESCRIPTOR
	MOVAL	-(SP),R1		; ALLOCATE SIZE RETURN SPACE
	$TRNLOG_S	LOGNAM=EXE$GQ_SYSDISK,-; TRANSLATE CURRENT LOGICAL NAME DISK
			RSLLEN=(R1),- 	; SAVE LENGTH TEMPORARILY
			RSLBUF=(R0)	; POINT TO BUFFER DESCRIPTOR
	POPR	#^M<R0,R1,R2>		; GET SIZE OF STRING AND CLEAN STACK
	CVTWB	R0,(SP)			; AND MAKE ASCIC STRING
35$:	BSBW	EXE$ALLOCPCB		; ALLOCATE PCB, WAIT IF NECESSARY
	BLBS	R0,40$			; CONTINUE IF ALLOCATED
	RET				; OTHERWISE RETURN ERROR CODE
40$:	MOVL	R2,R10			; SAVE ADDRESS OF NEW PCB
	BSBW	EXE$ALLOCPQB		; ALLOCATE PROCESS QUOTA BUFFER
	BLBS	R0,50$			; CONTINUE IF ALLOCATED
	BRW	ABRT2			; OTHERWISE ABORT AND RETURN PCB
50$:	MOVL	R2,R9			; SAVE ADDRESS OF QUOTA BUFFER
;
;	INITIALIZE NEW PCB		
;
	MOVC5	#0,(SP),#0,#<PCB$C_LENGTH-12>,12(R10)	; CLEAR PCB
	MOVL	SCH$GL_CURPCB,R4	; RESTORE CREATOR PCB ADDRESS
	MOVL	PCB$L_JIB(R4),PCB$L_JIB(R10); ASSUME AS JIB ADDRESS FOR NEW PROCESS
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	54$			; NO, THEN SHARING JIB
	BSBW	EXE$ALLOCJIB		; ALLOCATE JIB FOR MASTER PROCESS
	BLBS	R0,52$			; BR IF SPACE AVAILABLE
	CLRL	PCB$L_JIB(R10)		; PREVENT JIB DELETION
	BRW	ABORT			; ELSE ABORT CREATE
52$:	CLRQ	(R2)			; CLEAR TOP OF JIB
	MOVL	R2,PCB$L_JIB(R10)	; SAVE POINTER TO JIB
	MOVC5	#0,(SP),#0,#<JIB$C_LENGTH-12>,12(R2) ; CLEAR REMAINDER OF JIB
	BRB	56$			;
54$:	MOVL	PCB$L_JIB(R10),R2	; GET JIB ADDRESS
	INCW	JIB$W_PRCCNT(R2)	; ADD ANOTHER SUBPROCESS
	SUBL	#SWP$C_SHELLPFIL,JIB$L_PGFLCNT(R2); CHARGE FOR SHELL PAGES
	BLSS	55$			; BR IF OUT OF PAGE FILE QUOTA
	CMPW	JIB$W_PRCCNT(R2),JIB$W_PRCLIM(R2) ; OVER LIMIT?
	BLEQ	56$			; NO, CONTINUE
55$:	MOVZWL	#SS$_EXQUOTA,R0		; SET ERROR STATUS
	BRW	ABORT			; YES ABORT
56$:					;
	MOVAL	PCB$L_ASTQFL(R10),PCB$L_ASTQFL(R10)	; SET UP AST Q HEADER
	MOVAL	PCB$L_ASTQFL(R10),PCB$L_ASTQBL(R10)	;
	MOVB	#^X0F,PCB$B_ASTEN(R10)			; SET ALL AST ENABLES
	MOVAL	PCB$L_LOCKQFL(R10),PCB$L_LOCKQFL(R10)	; SET UP LOCK Q HEADER
	MOVAL	PCB$L_LOCKQFL(R10),PCB$L_LOCKQBL(R10)
	MOVAB	PCB$Q_PRIV(R10),PCB$L_ARB(R10)	; SET ADDRESS OF ARB
	MOVW	MBXUNT(AP),PCB$W_TMBU(R10)		; TERMINATION MAILBOX UNIT
	MOVW	SWP$GL_SHELLSIZ,PCB$W_PPGCNT(R10)	; AND PROCESS PAGE COUNT
;
;	INITIALIZE QUOTA BUFFER
;
	MOVC5	#0,(SP),#0,#<PQB$C_LENGTH-12>,12(R9)	; CLEAR QUOTA BUFFER
	MOVC5	#UNAMSZ,USRNAM,#32,#12,PQB$T_USERNAME(R9); ASSUME SYSTEM USER NAME
	MOVSTRING	LIM=15,-	; MOVE PROCESS NAME TO PQB TO VALIDATE
		SRC=PRCNAM,-		; FROM PROCESS NAME DESCRIPTOR
		DST=IMAGE		; TO IMAGE SLOT IN PQB
	MOVZBL	PQB$T_IMAGE(R9),R6	; FETCH STRING LENGTH FROM BUFFER
	BEQL	60$			; NO PROCESS NAME, NULL STRING
	INCL	R6			; INCLUDE COUNT BYTE
	MOVC3	R6,PQB$T_IMAGE(R9),PCB$T_LNAME(R10)	; SET INTO NEW PCB
	CLRQ	PQB$T_IMAGE(R9)		; CLEAR IMAGE NAME LENGTH
60$:	MOVL	SCH$GL_CURPCB,R4	; RESTORE PCB ADDRESS
	MOVQ	@PCB$L_PHD(R4),R0	; GET PRIVILEGE MASK
	MOVQ	R0,R2			; ASSUME SAME PRIVILEGES
	MOVL	PRVADR(AP),R7		; FETCH ADDRESS OF PRIVILEGE MASK
	BEQL	70$			; NONE SPECIFIED
	IFNORD	#8,(R7),125$		; ERROR IF NOT READABLE
	MOVQ	(R7),R2			; FETCH NEW PRIVILEGE MASK
	IFPRIV	SETPRV,70$		; SKIP MINIMIZATION IF SETPRV
	MCOML	R0,R0			; INVERT FOR BIT CLR
	MCOML	R1,R1			;
	BICL	R0,R2			; MINIMIZE PRIVILEGES
	BICL	R1,R3			; IF CALLER IS NOT PRIVILEGED ENOUGH
70$:	MOVQ	R2,PQB$Q_PRVMSK(R9)	; SET PRIVILEGES IN BUFFER
	EXTZV	#0,#5,BASPRI(AP),R0	; FETCH DESIRED BASE PRIORITY
	SUBL3	R0,#31,R0		; CONVERT TO INTERNAL PRIORITY
	IFPRIV	SETPRI,100$		; SKIP MINIMIZATION IF PRIVILEGE
	CMPB	R0,PCB$B_PRIB(R4)	; OTHERWISE MINIMIZE WITH CALLERS BASE
	BGEQU	100$			; GOOD VALUE, USE IT
	MOVB	PCB$B_PRIB(R4),R0	; NO, USE CALLERS BASE PRIORITY
100$:	MOVB	R0,PCB$B_PRIB(R10)	; SET IN NEW PCB
	MOVB	R0,PCB$B_PRI(R10)	; AS BOTH CURRENT AND BASE PRIORITY
	MOVL	R11,PCB$L_UIC(R10)	; STORE UIC FOR NEW PROCESS
	BNEQ	110$			; BR IF IT WAS SPECIFIED
	MOVL	PCB$L_UIC(R4),PCB$L_UIC(R10)	; OTHERWISE USE UIC OF CREATOR
	MOVL	PCB$L_PID(R4),PCB$L_OWNER(R10)	; AND INDICATE SUBPROCESS
110$:	MOVZWL	SCH$GL_MAXPIX,R7	; INITIALIZE INDEX FOR NAME CHECK
	TSTL	R6			; ANY LOGICAL NAME FOR NEW PROCESS?
	BEQL	140$			; NO, SKIP SEARCH
120$:	MOVL	@SCH$GL_PCBVEC[R7],R8	; FETCH A PCB ADDRESS
	CMPW	PCB$W_GRP(R8),PCB$W_GRP(R10)	; SAME GROUP?
	BNEQ	130$			; NO, TRY ANOTHER
	CMPC3	R6,PCB$T_LNAME(R10),PCB$T_LNAME(R8)	; COMPARE NAMES
	BNEQ	130$			; NO MATCH, CONTINUE
	MOVZWL	#SS$_DUPLNAM,R0		; SET DUPLICATE NAME CODE
	BRW	ABORT			; AND ABORT CREATION
125$:	BRW	ACCVIO			; GIVE ACCESS VIOLATION AND ABORT
130$:	SOBGTR	R7,120$			; CONTINUE SEARCH
140$:	MOVSTRING	LIM=63,-	; MOV IMAGE NAME TO BUFFER
			SRC=IMAGE,-	; FROM IMAGE STRING DESCRIPTOR
			DST=IMAGE	; TO PQB$T_IMAGE
	MOVSTRING	LIM=63,-	; MOVE INPUT LOGICAL NAME TO BUFFER
			SRC=INPUT,-	; FROM INPUT STRING DESCRIPTOR
			DST=INPUT	; TO PQB$T_INPUT
	MOVSTRING	LIM=63,-	; MOVE OUTPUT LOGICAL NAME TO BUFFER
			SRC=OUTPUT,-	; FROM OUTPUT STRING DESCRIPTOR
			DST=OUTPUT	; TO PQB$T_OUTPUT
	MOVSTRING	LIM=63,-	; MOVE ERROR LOGICAL NAME TO BUFFER
			SRC=ERROR,-	; FROM ERROR STRING DESCRIPTOR
			DST=ERROR	; TO PQB$T_ERROR

	MOVW	SYS$GW_FILEPROT,PQB$W_FILEPROT(R9) ; SET SYSTEM FILE PROTECTION
	MOVB	#^B1111,PQB$B_MSGMASK(R9) ; DEFAULT MESSAGE FLAGS = ALL OF THEM
	BBS	#31,SP,145$		; IF SYSTEM SPACE STACK
					; THEN NO P1 SPACE DATA BASE AVAILABLE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	#64,24(SP),PQB$T_DISK(R9)		; MOVE SYS$DISK LOGICAL NAME
	MOVC3	#12,@#CTL$T_USERNAME,PQB$T_USERNAME(R9)	; PASS USER NAME
	MOVQ	@#CTL$T_ACCOUNT,PQB$T_ACCOUNT(R9)	; AND ACCOUNT
	MOVC3	#PQB$C_MAXDIRLEN,-
		@#PIO$GT_DDSTRING,PQB$T_DDSTRING(R9) ; DEFAULT DIRECTORY
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	MOVAB	64(SP),SP		; CLEAN STRING FROM STACK
	MOVW	@#PIO$GW_DFPROT,PQB$W_FILEPROT(R9) ; USE CREATOR'S FILE PROTECTION
	MOVB	@#CTL$GB_MSGMASK,PQB$B_MSGMASK(R9) ; USE CREATOR'S MESSAGE FLAGS
;
;	ESTABLISH STATUS FLAG SETTINGS FOR PROCESS
;
145$:	MOVL	STSFLG(AP),R8		; GET STATUS FLAG ARGUMENT
	EXTZV	#STSFLGCNT,#<32-STSFLGCNT>,R8,R0	; TEST MBZ FIELD
	BEQL	150$			; CORRECT IF ZERO
	MOVZWL	#SS$_IVSTSFLG,R0	; ERROR, INVALID STATUS FLAG ARG
	BRW	ABORT			; ABORT CREATION
150$:	CLRL	R7			; INITIALIZE INDEX FOR SCAN
160$:	FFS	R7,#STSFLGCNT,R8,R7	; FIND AN ACTIVE STATUS FLAG
	BEQL	190$			; NONE, FINISHED WITH SCAN
	MOVAW	STSFLGTBL[R7],R1	; POINT TO TRANSLATION ENTRY
	CVTBL	(R1)+,R0		; GET PRIVILEGE BIT NUMBER  TO CHECK
	BLSS	170$			; NEGATIVE MEANS NOT PRIVILEGED
	BBS	R0,PQB$Q_PRVMSK(R9),170$; NEW PROCESS MUST HAVE PRIVILEGE
	MOVZWL	#SS$_NOPRIV,R0		; INDICATE NO PRIVILEGE ERROR
	BRW	ABORT			; AND ABORT PROCESS CREATION
170$:	MOVZBL	(R1),R0			; GET BIT NUMBER IN STS
	BBSS	R0,PCB$L_STS(R10),180$	; SET STSFLG IN NEW PCB
180$:	INCL	R7			; NEXT BIT
	BRB	160$			; CONTINUE SCAN
190$:					; DONE WITH STSFLG
	.PAGE
	.SBTTL	ESTABLISH QUOTAS FOR NEW PROCESS
;-------------------------------------------------------------------
;
;	PROCESS QUOTA BLOCK
;
;-------------------------------------------------------------------

;
;	THE PROCESS QUOTA LIST, IF SUPPLIED, HAS THE FOLLOWING STRUCTURE
;	EACH QUOTA IS INTRODUCED AND IDENTIFIED BY A CODE BYTE, PQL$_?????,
;	WHICH IS FOLLOWED BY A LONGWORD CONTAINING THE QUOTA VALUE.
;
;	THE QUOTA VALUES SUPPLIED ARE MAXIMIZED WITH THE REQUIRED MINIMUM
;	VALUES AND REPLACE THE DEFAULT VALUE FOR EACH SPECIFIED QUOTA.
;	ONLY IF THE PROCESS CREATION IS SUCCESSFUL ARE THE DEDUCTIBLE
;	QUOTAS SUBTRACTED FROM THOSE OF A PROCESS CREATING A DETACHED PROCESS.
;
;	IF DUPLICATE QUOTA ENTRIES ARE FOUND, THE LAST ONE ENCOUNTERED IS
;	THE ONE THAT IS USED.
;

QUOTALIST:				; 
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE REGISTERS FOR MOVC
	MOVC3	#<<PQL$_LENGTH-1>*4>,-	; COPY DEFAULTS TO PQB
		PQL$AL_DEFAULT+4,-	; AS ASSUMED VALUES FOR 
		PQB$L_ASTLM(R9)		; QUOTAS
	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE REGISTERS
	MOVL	PCB$L_PHD(R4),R5	; FOR SWAPPER POINT TO REAL PHD SINCE NO
	CMPL	PCB$L_PID(R4),SCH$GL_SWPPID	; IS IT THE SWAPPER
	BEQL	5$			; YES, USE PCB POINTER TO PHD
	MOVL	@#CTL$GL_PHD,R5		; GET POINTER TO PHD WINDOW IN 
					; CONTROL REGION FOR WINDOW
5$:	MOVL	QUOTA(AP),R7		; GET POINTER TO QUOTA LIST
	BEQL	NOQLIST			; NONE SPECIFIED
10$:	IFNORD	#1,(R7),30$		; CHECK FOR ACCESSIBILITY
	MOVZBL	(R7)+,R6		; GET CODE
	ASSUME	PQL$_LISTEND EQ 0	;
	BEQL	NOQLIST			; DONE IF PQL$_ENDLIST
	IFNORD	#4,(R7),30$		; CHECK QUOTA FOR ACCESSIBILITY
	CMPW	R6,#PQL$_LENGTH		; CHECK FOR LEGAL QUOTA NUMBER
	BGEQ	20$			; INVALID IF GEQ
	MOVL	(R7)+,PQB$L_ASTLM-4(R9)[R6] ; MERGE INTO PQB QUOTA LIST
	BRB	10$			; GO GET NEXT QUOTA SPECIFIED
20$:	MOVZWL	#SS$_IVQUOTAL,R0	; INVALID QUOTA LIST
	BRW	ABORT			; SIGNAL ERROR CONDITION AND ABORT CREATE
30$:	BRW	ACCVIO			; ABORT WITH ACCESS VIOLATION
NOQLIST:				; DONE MERGING QUOTAS SPECIFIED
	MOVAL	PQL$AL_MIN+<4*PQL$_LENGTH>,R6	; SET POINTER TO BASE OF MIN VALUES
	MOVAL	<PQB$L_ASTLM+<4*<PQL$_LENGTH-1>>>(R9),R3 ; SET BASE OF QUOTA VALUES
	MOVZWL	#<PQL$_LENGTH-1>,R8	; SET COUNT FOR SCAN
	MOVL	PCB$L_JIB(R10),R7	; GET ADDRESS OF JOB INFORMATION BLOCK
10$:	CMPL	-(R3),-(R6)		; CHECK AGAINST MINIMUM ALLOWABLE VALUE
	BGEQ	20$			; BR IF ABOVE MINIMUM
	MOVL	(R6),(R3)		; FORCE TO MINIMUM
20$:	
	MOVL	(R3),R0			; GET QUOTA REQUEST VALUE
	BSBB	40$			; PROCESS QUOTA
	SOBGTR	R8,10$			; LOOP FOR ALL QUOTAS
	JMP	ACTIVATE		; GO TO NONPAGED PSECT

40$:	CASE	R8,LIMIT=#1,<-		; SWITCH ON TYPE OF QUOTA
		QASTLM,-		; 1 => AST LIMIT
		QBIOLM,-		; 2 => BUFFERED I/O LIMIT
		QBYTLM,-		; 3 => BUFIO BYTE COUNT LIMIT
		QCPULM,-		; 4 => CPU TIME LIMIT
		QDIOLM,-		; 5 => DIRECT I/O LIMIT
		QFILLM,-		; 6 => OPEN FILE LIMIT
		QPGFLQUOTA,-		; 7 => PAGING FILE QUOTA
		QPRCLM,-		; 8 => SUB-PROCESS LIMIT
		QTQELM,-		; 9 => TIMER QUEUE ENTRY LIMIT
		QWSQUOTA,-		;10 => WORKING SET QUOTA
		QWSDEFAULT,-		;11 => WORKING SET DEFAULT
		QENQLM,-		;12 => ENQUEUE LIMIT
		QWSEXTENT-		;13 => WORKING SET EXTENT
		>; 
	RSB				; 

QASTLM:					; AST LIMIT
	CMPW	R0,PHD$W_ASTLM(R5)	; CHECK FOR IN LIMIT
	BLEQU	10$			; YES, CONTINUE
	TSTL	R11			; DETACHED CREATE?
	BNEQ	10$			; YES, ALLOW ANYTHING
	CVTWL	PHD$W_ASTLM(R5),R0	; NO, LIMIT TO MAXIMUM
10$:	CVTLW	R0,PCB$W_ASTCNT(R10)	; SET AS WORKING AST COUNT
	RSB				; NEXT QUOTA

QBIOLM:					; BUFFERED I/O LIMIT
	CMPW	R0,PCB$W_BIOLM(R4)	; CHECK FOR IN LIMIT
	BLEQU	10$			; YES, CONTINUE
	TSTL	R11			; DETACHED CREATE?
	BNEQ	10$			; YES ALLOW ANYTHING
	CVTWL	PCB$W_BIOLM(R4),R0	; NO, LIMIT TO CURRENT VALUE
10$:	CVTLW	R0,PCB$W_BIOLM(R10)	; SET LIMIT
	CVTLW	R0,PCB$W_BIOCNT(R10)	; AND WORKING COUNT
	RSB				; NEXT QUOTA

QBYTLM:					; BUFFERED I/O BYTE LIMIT
	TSTL	R11			; DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	MOVL	R0,JIB$L_BYTLM(R7)	; SET IN JIB OF MASTER PROCESS
	MOVL	R0,JIB$L_BYTCNT(R7)	; BOTH LIMIT AND COUNT VALUES
10$:	RSB				; NEXT QUOTA

QCPULM:					; CPU TIME LIMIT
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BNEQ	20$			; YES, ALLOW ANYTHING
	MOVL	PHD$L_CPULIM(R5),R1	; GET CURRENT PROCESS LIMIT
	BEQL	20$			; NO LIMIT ON CURRENT PROCESS
	SUBL	PHD$L_CPUTIM(R5),R1	; DETERMINE REMAINING LIMIT
	BLEQU	10$			; BRANCH IF WILL EXCEED LIMIT
	TSTL	R0			; IS REQUESTED VALUE INFINITY?
	BNEQ	5$			; NO, GO SEE IF REQUEST CAN BE FILLED
	INCL	R1			; IF REQUESTING INFINITY, GIVE
	ASHL	#-1,R1,R0		; HALF OF THE CREATOR'S CPU TIME
5$:	CMPL	R0,R1			; CHECK FOR IN LIMIT
	BLSSU	20$			; YES, CONTINUE
10$:	BSBW	OVERCHECK		; CHECK FOR LEGAL TO EXCEED
20$:	RSB				; NEXT QUOTA

QDIOLM:					; DIRECT I/O LIMIT
	CMPW	R0,PCB$W_DIOLM(R4)	; CHECK FOR IN LIMIT
	BLEQU	10$			; YES, CONTINUE
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BNEQ	10$			; YES, ALLOW ANYTHING
	CVTWL	PCB$W_DIOLM(R4),R0	; ELSE LIMIT TO CURRENT VALUE
10$:	CVTLW	R0,PCB$W_DIOLM(R10)	; SET LIMIT
	CVTLW	R0,PCB$W_DIOCNT(R10)	; AND SET WORKING COUNT
	RSB				;

QFILLM:					; OPEN FILE LIMIT
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	MOVW	R0,JIB$W_FILCNT(R7)	; SET FILE COUNT FOR MASTER PROCESS
	MOVW	R0,JIB$W_FILLM(R7)	; AND LIMIT VALUE
10$:	RSB				; NEXT QUOTA

QPGFLQUOTA:				; PAGE FILE QUOTA
	TSTL	R11			; DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	MOVL	R0,JIB$L_PGFLQUOTA(R7)	; SET PAGE FILE QUOTA
	MOVL	R0,JIB$L_PGFLCNT(R7)	; AND COUNT
10$:	RSB				; NEXT QUOTA

QPRCLM:					; SUBPROCESS QUOTA
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT

	MOVW	R0,JIB$W_PRCLIM(R7)	; AND LIMIT
10$:	RSB				; NEXT QUOTA

QTQELM:					; TIMER QUEUE ENTRY QUOTA
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	MOVW	R0,JIB$W_TQCNT(R7)	; SET TIMER QUEUE QUOTA FOR JOB
	MOVW	R0,JIB$W_TQLM(R7)	; AND LIMIT VALUE
10$:	RSB				; NEXT QUOTA

QWSQUOTA:				; WORKING SET QUOTA
	BSBB	MAXWSCNT		; LIMIT TO MAX WORKING SET COUNT
	ADDW	PHD$W_WSLIST(R5),R0	; ADD BASE OF WORKING SET LIST
	CMPW	R0,PHD$W_WSQUOTA(R5)	; CHECK FOR IN LIMIT
	BLSSU	10$			; YES,CONTINUE
	TSTL	R11			; ARE WE CREATING A DETACHED PROCESS?
	BNEQ	10$			; YES, USE AS IS
	ADDW3	#1,PHD$W_WSQUOTA(R5),R0	; ELSE FORCE TO CORRECT MAXIMUM
10$:	SUBW3	PHD$W_WSLIST(R5),R0,(R3); REMOVE BIAS
	RSB				; NEXT QUOTA

QWSEXTENT:				; WORKING SET EXTENT
	BSBB	MAXWSCNT		; LIMIT TO MAX WORKING SET COUNT
	CMPL	R0,PQB$L_WSQUOTA(R9)	; CHECK AGAINST QUOTA
	BGEQU	5$			; MORE, USE AS IS
	MOVL	PQB$L_WSQUOTA(R9),R0	; MAXIMIZE WITH WSQUOTA
5$:	ADDW	PHD$W_WSLIST(R5),R0	; ADD BASE OF WORKING SET LIST
	CMPW	R0,PHD$W_WSEXTENT(R5)	; CHECK FOR IN LIMIT
	BLSSU	10$			; YES,CONTINUE
	TSTL	R11			; ARE WE CREATING A DETACHED PROCESS?
	BNEQ	10$			; YES, USE AS IS
	ADDW3	#1,PHD$W_WSEXTENT(R5),R0; ELSE FORCE TO CORRECT MAXIMUM
10$:	SUBW3	PHD$W_WSLIST(R5),R0,(R3); REMOVE BIAS
	RSB				; NEXT QUOTA

QWSDEFAULT:				; WORKING SET LIST DEFAULT
	BSBB	MAXWSCNT		; LIMIT TO MAXIMUM WORKING SET COUNT
	CMPL	R0,PQB$L_WSQUOTA(R9)	; CHECK AGAINST QUOTA
	BLEQU	10$			; LESS, USE AS IS
	MOVL	PQB$L_WSQUOTA(R9),(R3)	; MINIMIZE WITH WSQUOTA
10$:	RSB				; NEXT QUOTA


MAXWSCNT:				; LIMIT WSQUOTA OR DEFAULT TO MAXIMUL SIZE
	CMPW	R0,SGN$GL_MAXWSCNT	; COMPARE WITH MAXIMUM WS LIST LENGTH
	BLEQ	10$			; BR IF WITHIN LEGAL RANGE
	MOVW	SGN$GL_MAXWSCNT,R0	; FORCE TO LEGAL VALUE
10$:	RSB				;

QENQLM:					; ENQUEUE QUOTA
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	MOVW	R0,JIB$W_ENQCNT(R7)	; SET ENQUEUE QUOTA FOR JOB
	MOVW	R0,JIB$W_ENQLM(R7)	; AND LIMIT VALUE
10$:	RSB				; NEXT QUOTA

	.PAGE
	.SBTTL	OVERCHECK - CHECK FOR LEGAL TO EXCEED QUOTA
;++
; FUNCTIONAL DESCRIPTION:
;	OVERCHECK CHECKS TO SEE IF THE PROCESS BEING CREATED IS A DETATCHED
;	PROCESS.   IF A DETATCHED PROCESS IS BEING CREATED, CONTROL RETURNS 
;	INLINE.  OTHERWISE THE CREATE IS ABORTED BY BRANCHING TO ABORT 
;	WITH THE STATUS CODE SS$_NOQUOTA.
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;	R5 - ADDRESS OF PHD FOR CURRENT PROCESS (WINDOW IN P1 SPACE)
;	R9 - ADDRESS OF PROCESS QUOTA BLOCK
;	R10- ADDRESS OF PCB FOR NEW PROCESS
;	R11- UIC FOR CREATED PROCESS (0 => SUBPROCESS)
;
;--

OVERCHECK:				;
	TSTL	R11			; CHECK FOR SUBPROCESS CREATE
	BNEQ	10$			; YES, IGNORE OVER LIMIT
	MOVZWL	#SS$_EXQUOTA,R0		; SET ERROR STATUS CODE
	BRW	ABORT			; NO, ABORT CREATE
10$:	RSB				; RETURN
	.PAGE
	.SBTTL	ACTIVATE NEW PROCESS
;
;	ACTIVATE NEW PROCESS
;

ACTIVATE:				;
	MOVL	R9,PCB$L_PQB(R10)	; POINT NEW PCB TO PROCESS QUOTA BLOCK
	MOVL	R10,R4			; PCB ADDRESS OF NEW PROCESS
	MOVL	R4,(R10)		; BUILD QUEUE HEADER
	MOVL	R4,4(R10)		; FOR PCB
	DSBINT	W^SYNCHIPL		; BLOCK SYSTEM EVENT REPORTING
	JSB	G^MMG$CALCSWAPSIZE	; GET THE SIZE IN R2 OF MINIMUM SWAP AREA
	CLRQ	R0			; INDICATE NO CURRENT SPACE
	JSB	G^MMG$ALLOCSWPAREA	; ALLOCATE INITIAL SWAP SPACE
	BLSS	25$			; BRANCH IF NO SWAP SPACE AVAILABLE
	MNEGL	R0,PCB$L_WSSWP(R4)	; INSERT SWAP FILE TYPE VBN/INDEX
	MOVL	R2,PQB$L_SWAPSIZE(R9)	; SAVE MAXIMUM ALLOWABLE SWAP SIZE
	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	MOVL	SCH$GL_CURPCB,R6	; GET PCB ADDRESS OF CREATOR
	MOVL	PCB$L_PHD(R6),R5	; AND EXTRACT HEADER ADDRESS
	MOVZWL	SCH$GL_MAXPIX,R7	; INITIALIZE INDEX FOR PIX SEARCH
	MOVAL	SCH$GL_NULLPCB,R8	; REFERENCE PCB ADDRESS (NULL PROCESS)
20$:	CMPL	R8,@SCH$GL_PCBVEC[R7]	; FIND NON-ZERO PIX POINTING TO NULLPCB
	BEQL	30$			; GOT ONE, FREE SLOT
	SOBGTR	R7,20$			; OCCUPIED, TRY ANOTHER
22$:	MOVL	R2,R1			; SET SIZE OF AREA TO DEALLOCATE
	EXTZV	#24,#8,R0,R3		; GET PAGE FILE ALLOCATION IN
	EXTZV	#0,#24,R0,R0		; GET VBN OF ALLOCATION
	MOVL	@L^MMG$GL_PAGSWPVC[R3],R3 ; GET ADDR OF PAGE FILE CONTROL BLOCK
	JSB	G^MMG$DEALLOCPAGFIL	; FREE UP THE SPACE
25$:	BRW	60$			; NO FREE SLOTS AVAILABLE
30$:	CMPW	SCH$GW_PROCLIM,SCH$GW_PROCCNT ; CHECK FOR MAX PROCESSES
	BLEQ	22$			; BR IF YES AND ABORT CREATE
	INCW	SCH$GW_PROCCNT		; COUNT THIS PROCESS
	MOVAW	@SCH$GL_SEQVEC[R7],R0	; GET ADDRESS OF SEQUENCE NUMBER FOR SLOT
	INCW	(R0)			; NEXT SEQUENCE NUMBER FOR THIS PROCESS
	BGEQ	35$			; BR IF IN RANGE (POSITIVE PID)
	CLRW	(R0)			; ELSE, RESET SEQUENCE NUMBER
35$:	MOVW	(R0),PCB$L_PID+2(R10)	; SET SEQUENCE NUMBER
	MOVW	R7,PCB$L_PID(R10)	; AND PIX TO FORM COMPLETE PID
	MOVL	R10,@SCH$GL_PCBVEC[R7]	; SET POINTER TO PCB IN VECTOR OF PCBS
	TSTL	R11			; DETACHED CREATE?
	BEQL	38$			; BR IF NOT
	MOVL	PCB$L_JIB(R10),R0	; GET JIB ADDRESS
	MOVL	PCB$L_PID(R10),JIB$L_MPID(R0)	; AND SET ROOT PID FOR PROCESS TREE
38$:					;
	BSBW	SCH$CHSE		; MAKE PROCESS EXECUTABLE, NON-RESIDENT
	TSTL	R11			; TEST FOR DETACHED CREATE
	BNEQ	40$			; BR IF CREATING DETACHED PROCESS
	INCW	PCB$W_PRCCNT(R6)	; OTHERWISE ACCOUNT FOR SUB-PROCESS
	TSTL	PHD$L_CPULIM(R5)	; CHECK FOR NO CPU LIMIT
	BEQL	40$			; NO LIMIT, DONT DEDUCT
	SUBL	PQB$L_CPULM(R9),PHD$L_CPULIM(R5); DEDUCT CPU TIME LIMIT
40$:					;
	MOVL	4(SP),R0		; GET PID RETURN VALUE ADDRESS
	BEQL	55$			; NONE
	BLSS	70$			; SYSTEM SPACE ADDRESS
42$:	ENBINT				; RESTORE IPL
45$:	MOVL	PCB$L_PID(R10),(R0)	; RETURN PID OF CREATED PROCESS
50$:	MOVZWL	#SS$_NORMAL,R0		; SET NORMAL COMPLETION STATUS
	RET				; AND RETURN TO CALLER
55$:	ENBINT				; RESTORE IPL
	BRB	50$			; AND EXIT

60$:	ENBINT				; ENABLE SYSTEM EVENT REPORTING
	MOVZWL	#SS$_NOSLOT,R0		; SET ERROR CODE FOR NO SLOT AVAILABLE
	BRB	ABORT			; ABORT CREATION, EXCEEDED QUOTA
70$:	CMPL	R0,MMG$GL_NPAGEDYN	; CHECK FOR IN NONPAGED POOL
	BLSSU	42$			; NO, DROP IPL TO STORE PID
	CMPL	R0,EXE$GL_INTSTK	; HIGH LIMIT
	BGEQU	42$			; OUT OF POOL OR INTERRUPT STACK
	MOVL	PCB$L_PID(R10),(R0)	; STORE PID OF CREATED PROCESS
	ENBINT				; RESTORE IPL
	BRB	50$			; AND RETURN SUCCESS
SYNCHIPL:				; MARKER FOR END OF NONPAGABLE AREA
	.LONG	IPL$_SYNCH		; IPL TO BLOCK EVENT REPORTING
	.PAGE
	.SBTTL	ABORT PROCESS CREATION
;
;	ABORT PROCESS CREATION AFTER DETECTING ANY ERROR
;


ABRT2:					; ABORT WITH PCB ONLY
	CLRL	R9			; INDICATE NO PQB ALLOCATED
ABORT:					; ABORT WITH BOTH PCB AND PQB ALLOCATED
	MOVL	R0,R7			; SAVE STATUS CODE
	TSTL	R11			; IS THIS A DETACHED PROCESS CREATE?
	BEQL	10$			; BR IF NOT
	MOVL	PCB$L_JIB(R10),R0	; GET JIB ADDRESS FOR RELEASE
	BEQL	10$			; BR IF NONE
	BSBW	EXE$DEANONPAGED		; DEALLOCATE JIB
	BRB	20$			; 
10$:	MOVL	SCH$GL_CURPCB,R4	; GET PCB ADDRESS FOR SURE
	MOVL	PCB$L_JIB(R4),R2	; FETCH JIB ADDRESS
	ADDL	#SWP$C_SHELLPFIL,JIB$L_PGFLCNT(R2); RETURN PAGE FILE QUOTA
					; FOR SHELL PAGES
	DECW	JIB$W_PRCCNT(R2)	; CORRECT SUBPROCESS COUNT
20$:					;
	MOVL	R10,R0			; ADDRESS OF NEW PCB
	BSBW	EXE$DEANONPAGED		; DEALLOCATE QUOTA BUFFER
	MOVL	R9,R0			; ADDRESS OF PQB IF ANY
	BEQL	30$			; BR IF NONE ALLOCATED
	BSBW	EXE$DEANONPAGED		; DEALLOCATE QUOTA BLOCK
30$:	MOVL	R7,R0			; RESTORE STATUS CODE
	RET				; AND RETURN TO CALLER
	.PAGE
	.SBTTL	MOVSTR - STRING COPY SUBROUTINE
;+
; FUNCTIONAL DESCRIPTION: 
;	MOVSTR VALIDATES AND COPIES A STRING FROM THE ARGUMENT LIST
;	TO THE PROCESS QUOTA BUFFER.  IF ANY ERROR IS DETECTED, THE
;	SERVICE CALL IS EXITED VIA A RET INSTRUCTION WITH R0 CONTAINING
;	THE ERROR STATUS CODE.
;
; CALLING SEQUENCE:
;	BSB	MOVSTR
;	.BYTE	<MAXIMUM_STRING_LENGTH>
;	.BYTE	<AP_OFFSET_TO_SOURCE_DESCRIPTOR>
;	.BYTE	<PQB_OFFSET_OF_DESTINATION>
;
; INPUT PARAMETERS:
;	R9 - PQB BASE ADDRESS
;	@(SP) - MAXIMUM STRING LENGTH
;	@(SP)+1 - AP OFFSET TO SOURCE STRING DESCRIPTOR
;	@(SP)+2 - PQB OFFSET FOR DESTINATION COUNTED STRING
;
; OUTPUT PARAMETERS:
;	SPECIFIED AREA IN PQB RECEIVES SOURCE STRING
;
; COMPLETION CODES:
;	SS$_ACCVIO  -  ACCESS VIOLATION FETCHING DESCRIPTOR OR STRING
;	SS$_IVLOGNAM - INVALID LOGICAL NAME (COUNT OUT OF RANGE)
;
;-

MOVSTR:					; MOVE STRING TO PQB
	MOVL	(SP),R5			; GET BASE OF PARAMETERS
	ADDL	#3,(SP)			; INCREMENT RETURN ADDRESS
	PUSHR	#^M<R4,R5,R6,R7,R8>	; SAVE REGISTERS
	MOVZBL	(R5)+,R8		; GET STRING LIMIT
	MOVZBL	(R5)+,R3		; GET ARGLIST OFFSET
	MOVL	(AP)[R3],R2		; FETCH DESCRIPTOR ADDRESS
	BEQL	MOVEXIT			; NONE, EXIT
	IFNORD	#8,(R2),ACCVIO		; MUST BE ABLE TO READ DESCRIPTOR
	MOVQ	(R2),R6			; FETCH DESCRIPTOR
	TSTW	R6			; CHECK FOR NULL COUNT
	BEQL	MOVEXIT			; YES, NULL STRING
	CMPW	R6,R8			; CHECK UPPER LIMIT ON STRING 
	BLEQU	10$			; BR IF WITHIN LIMIT
	MOVZWL	#SS$_IVLOGNAM,R0	; SET ERROR CODE
	BRW	ABORT			; AND ABORT CREATE
10$:	IFNORD	R6,(R7),ACCVIO		; CHECK ACCESSIBILITY
	MOVZBL	(R5),R3			; GET PQB OFFSET
	MOVAB	(R9)[R3],R3		; COMPUTE ADDRESS IN PQB
	MOVB	R6,(R3)+		; SET COUNT FOR STRING
	MOVC3	R6,(R7),(R3)		; COPY STRING TO BUFFER
MOVEXIT:				;
	POPR	#^M<R4,R5,R6,R7,R8>	; RESTORE REGISTERS
	RSB				; AND RETURN

ACCVIO:	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR CODE
	BRW	ABORT			;

	.PAGE
	.END
