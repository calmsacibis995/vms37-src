	.TITLE	WRTMFYPAG - WRITE MODIFIED PAGES
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:
;
; ABSTRACT:
;
; ENVIRONMENT:
;
; AUTHOR: PETER H. LIPMAN	, CREATION DATE: 3-JAN-77
;
; MODIFIED BY:
;
;	V02-020	HRJ0055		Herb Jacobs		02-Mar-1982
;		Fix deadlock caused by inconsistent MFYCNT check.
;
;	V02-019	HRJ0052		Herb Jacobs		08-Feb-1982
;		Add graceful degradation page file allocation strategy.
;
;	V02-018	HRJ0051		Herb Jacobs		01-Feb-1982
;		Report resource MPWBUSY when modified page writer turns off.
;
;	V02-017	HRJ0041		Herb Jacobs		17-Jan-1982
;		Disable data gathering for clusters.  Shorten name of modified
;		page list empty resource.
;
;	V02-016	WMC0037		Wayne M Cardoza		17-Dec-1981
;		Support the RSN$_MPLIST_EMPTY resource when the modified page
;		list becomes empty.
;
;	V02-015	HRJ0038		Herb Jacobs		11-Dec-1981
;		Support allocations in a fragmented page file.
;
;	V02-014	HRJ0034		Herb Jacobs		15-Nov-1981
;		Add information gathering code.
;
;	V02-013	HRJ0028		Herb Jacobs		24-Aug-1981
;		Handle new failure return from mmg$allocpagfil.
;
;	V02-012	HRJ0025		Herb Jacobs		31-Jul-1981
;		Remove deallocate of old backing store VBN's, since
;		modified list never contains them anymore.
;
;	V02-011	HRJ0023		Herb Jacobs		01-Jul-1981
;		Update to use new pagefile allocate and deallocate
;		routines and put in an end cluster threshold.
;
;	V02-010	LJK0030		Lawrence J. Kenah	26-May-1981
;		Replace all PFN references to FLINK and BLINK with
;		the PFN_REFERENCE macro to support large physical
;		memory configurations.
;
;	V02-001	LJK0029		Lawrence J. Kenah	18-May-1981
;		Make listheads for three physical page lists longwords instead 
;		of words and change all references to these listheads.
;
;	X0309	PHL0002		Peter H. Lipman		23-Jan-1981
;		If fail to allocate page file, then BUGCHECK.
;		There are no pages on the modified page list that
;		do not have at least a reservation.  Because this
;		allocate is done before the deallocate, Page File 
;		Control Block initialization code in SYSINIT and SYSGEN
;		has been fixed to have one less reservable page than
;		allocatable page.
;
;	X0308	RIH0056		R. I. HUSTVEDT 29-JAN-1980
;		Notify SWAPPER at the end of modify page writing.
;		Also, use parameter for I/O priority.
;
;	X0307	RIH24218	R. I. HUSTVEDT	4-JUN-1979
;		Make PTESCAN checks rigorous to avoid boudary problems.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$CADEF				;CONDITIONAL ASSEMBLY DEFINITIONS
	$IRPDEF				;I/O REQUEST PACKET DEFINITIONS
	$IPLDEF				;PROCESSOR PRIORITY LEVELS
	$OPDEF				;DEFINE OPCODE EQUIVALENT VALUES
	$PCBDEF				;PROCESS CONTROL BLOCK DEFINITIONS
	$PFLDEF				;PAGE FILE CONTROL BLOCK DEFINITIONS
	$PFNDEF				;PAGE FRAME NUMBER DATA BASE DEFINITIONS
	$PHDDEF				;PROCESS HEADER DEFINITIONS
	$PRDEF				;PROCESSOR REGISTER DEFINITIONS
	$PRIDEF				;PRIORITY INCREMENT CLASS DEFINITIONS
	$PTEDEF				;PAGE TABLE ENTRY DEFINITIONS
	$SECDEF				;SECTION TABLE ENTRY DEFINITIONS
	$VADEF				;VIRTUAL ADDRESS FIELD DEFINITIONS
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	$VIELD	MPW,0,<-
		<SUCCESS,,M>,-		;SUCCESSFUL COMPLETION BIT
		<BADPAG,,M>,-		;THIS PAGE HAD A WRITE ERROR
		<NOTDONE,,M> -		;THESE PAGES WERE NOT WRITTEN
		>
;
; OWN STORAGE:
;
	.PSECT	$$$210,LONG
	.ALIGN	LONG
MPW$AL_PTE::
	.LONG	0			;ADDRESS OF PAGE TABLE ENTRY ARRAY
MPW$AW_PHVINDEX::
	.LONG	0			;ADDRESS OF PROCESS HEADER VECTOR INDEX ARRAY
MPW$GL_BADPAGTOTAL::
	.LONG	0			;TOTAL PAGES EVER PUT ON BAD PAGE LIST

	.IF EQ	1
	.PSECT	$$$075,LONG
	.ALIGN	LONG
MPW$A_PGFLCLUSTERS::
	.REPT	121
	.LONG	0
	.ENDR
MPW$A_SECTCLUSTERS::
	.REPT	121
	.LONG	0
	.ENDR

	.LONG	0			;BACKWARD FAILURE COUNT
MPW$L_BACKUPFAIL::
	.LONG	0			;UNUSED
	.LONG	0			;FORWARD FAILURE COUNT
MPW$L_COUNT::
	.LONG	0
	.ENDC
;
; **********************************************************************
;
; **************** THIS ENTIRE MODULE MUST BE RESIDENT *****************
;
	.PSECT	$MMGCOD
;
; **********************************************************************
;

	.SBTTL	MODIFIED PAGE WRITE COMPLETION AST
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS A KERNEL MODE AST WHICH DOES THE CLEANUP OPERATIONS
; TO COMPLETE THE WRITING OF THE MODIFIED PAGES.  IT ALSO STARTS
; THE NEXT MODIFIED PAGE WRITE IF THERE IS ANY TO DO.
;
; CALLING SEQUENCE:
;
;	BSBW	WRITEDONE
;
; INPUT PARAMETERS:
;
;	IPL = ASTDEL
;	R5 = AST CONTROL BLOCK = I/O REQUEST PACKET
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R4, R5 ALTERED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

WRITEDONE:
	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP> ;PRESERVE NON-VOLATILE REGISTERS
	DSBINT	#IPL$_SYNCH		;INTERLOCK FOR PFN DATA BASE MANIPULATION
					;SAVE CALLED IPL ON STACK
	EXTZV	#VA$V_VPN,#<16-VA$V_VPN>,- ;GET ORIGINAL PAGE COUNT
		IRP$W_OBCNT(R5),R10
	MOVL	IRP$L_IOST1(R5),R11	;GET ERROR STATUS AND TRANSFERRED BYTE COUNT
	BICL	#<MPW$M_BADPAG ! MPW$M_NOTDONE>,R11 ;CLEAR FLAGS
	MOVL	R5,R0			;I/O REQUEST PACKET ADDRESS
	BSBW	EXE$DEANONPAGED		;DEALLOCATE THE PACKET
	CLRL	R6			;INIT PTE INDEX
	EXTZV	#<16+VA$V_VPN>,#<16-VA$V_VPN>,R11,R7 ;TRANSFERRED PAGE COUNT
	BEQL	90$			;BRANCH IF NO PAGES SUCCESSFULLY TRANSFERRED
20$:	MOVL	@W^MPW$AL_PTE[R6],R0	;GET PAGE FRAME NUMBER OF NEXT PAGE
	CVTWL	@W^MPW$AW_PHVINDEX[R6],R4 ;AND THE CORRESPONDING PROCESS 
					;HEADER VECTOR INDEX
	BGEQ	22$			;BRANCH IF NOT SWAPVBN WRITE
	EXTZV	#0,#15,R4,R4		;FIX UP THE PHV INDEX
	BRB	25$			;AND IN THE CASE OF A WRITE ERROR
					;DO NOT JAM ON THE MODIFY BIT
22$:	BITL	#<MPW$M_BADPAG ! MPW$M_NOTDONE>,R11 ;NOT SUCCESSFULLY TRANSFERRED?
	BEQL	25$			;BRANCH IF THIS PAGE IS OK
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ;NOTE PAGE STILL MODIFIED
25$:	MOVB	@W^PFN$AB_TYPE[R0],R8	;PAGE TYPE AND RPTEVT BIT
	CMPZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,- ;PROCESS PAGE TABLE?
		R8,#PFN$C_PPGTBL
	BNEQ	40$			;BRANCH IF NOT
	MOVL	R4,R1			;PROCESS HEADER VECTOR INDEX
	BSBW	MMG$DECPHDREF1		;ONE LESS PROCESS HEADER REF
					;AT PAGE WRITE COMPLETION
40$:	DECREF	GTR=60$			;ONE LESS REFERENCE
	BBC	#MPW$V_BADPAG,R11,50$	;BRANCH IF NOT PAGE WRITE ERROR PAGE
	MOVZBL	#PFN$C_BADPAGLST,R2	;PLACE THIS PAGE
	BSBW	MMG$INSPFNT		;ON THE BAD PAGE LIST
	INCL	MPW$GL_BADPAGTOTAL	;COUNT IT
	BRB	60$
50$:	BSBW	MMG$RELPFN		;RELEASE THE PAGE
60$:	CVTWL	@W^PHV$GL_PIXBAS[R4],R4	;CALCULATE PCB ADDRESS FROM PHV INDEX
	BLSS	80$			;BRANCH IF PCB IS GONE
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	;FETCH PCB ADR
	BBSC	#PCB$V_SWPVBN,PCB$L_STS(R4),70$ ;DONE WITH SWPVBN WRITE IF ANY
;
; IF DELPAG IS WAITING FOR THIS WRITE COMPLETION, THE RPTEVT BIT IS SET
;
70$:	BBC	#PFN$V_RPTEVT,R8,80$	;BRANCH IF NO REPORT EVENT REQUESTED
	MOVZBL	#PRI$_IOCOM,R2		;I/O COMPLETE PRIORITY CLASS
	RPTEVT	PFCOM			;REPORT PAGE FAULT COMPLETE
80$:	AOBLSS	R7,R6,20$		;LOOP THROUGH ALL PAGES
90$:	BLBS	R11,100$		;BRANCH IF PAGE WRITE HAD NO ERROR
	INCL	R7			;ONE MORE PAGE FOR THE ERROR PAGE
	BBCS	#MPW$V_BADPAG,R11,20$	;BRANCH IF HAVEN'T PROCESSED THE ERROR PAGE
;
; NOW PROCESS THE UNWRITTEN PAGES IF ANY
;
	MOVL	R10,R7			;RESET LIMIT TO ORIGINAL PAGE COUNT
	DECL	R6			;IN ORDER TO EXECUTE THE LOOP 0 OR MORE TIMES
	MOVB	#<MPW$M_SUCCESS ! MPW$M_NOTDONE>,R11 ;COMPLETE THE PAGES NOT TRANSFERRED
	BRB	80$
100$:	SETIPL	(SP)			;BACK TO CALLED IPL
	PUSHL	#0			;NO I/O PACKET ALLOCATED YET
	CMPL	W^SCH$GL_MFYCNT,W^SCH$GL_MFYLOLIM ;ENOUGH PAGES ON MODIFY LIST
					;TO TRY FOR ANOTHER CLUSTER?
	BGTRU	GET_NXT_CLUSTER		;BRANCH IF YES
	BRB	NOMOREPAGES		;NO, ALL DONE FOR NOW

	.SBTTL	WRTMFYPAG - WRITE MODIFIED PAGES
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE GATHERS A CLUSTER OF PAGES OF LIKE KIND FROM THE
; MODIFIED PAGE LIST, AND WRITES THEM BACK TO THEIR BACKING STORE ADDRESSES.
; FOR PAGING FILE PAGES, THE ADDRESSES ARE REALLOCATED AS A CONTIGUOUS BLOCK
; AND THE PAGES ARE WRITTEN BACK IN ONE OPERATION.
;
; CALLING SEQUENCE:
;
;	BSBW	MMG$WRTMFYPAG
;
; INPUT PARAMETERS:
;
;	IPL = 0
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R4, R5 ALTERED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; NEED TO ALLOCATE AN I/O PACKET AND WAIT IF NONE AVAILABLE
; ***** IT IS ASSUMED THAT THIS PROCESS IS RUNNING WITH RESOURCE WAIT ENABLED
;
GET_IRP:
	BSBW	EXE$ALLOCIRP		;ALLOCATE AN I/O REQUEST PACKET
	BLBS	R0,GOT_IRP		;BRANCH IF GOT ONE, MAY HAVE WAITED
	BUG_CHECK MPWALCIRP,FATAL	;FAILED TO ALLOCATE I/O REQUEST PACKET

NOMOREPAGES:
	MOVL	W^SCH$GL_MFYLIMSV,W^SCH$GL_MFYLIM ;RE-ENABLE LIMIT CHECK
	MOVL	W^SCH$GL_MFYLOSV,W^SCH$GL_MFYLOLIM ;RESTORE LOW LIMIT
	MOVL	W^SCH$GL_CURPCB,R0	;GET PCB ADDRESS
	BBSS	#PCB$V_WAKEPEN,PCB$L_STS(R0),NOSPACE ;SET WAKE PENDING TO FORCE
					;SWAP SCHEDULE RE-EVALUATION
NOSPACE:
	BBCCI	S^#SCH$V_MPW,W^SCH$GB_SIP,10$ ;MODIFIED PAGE WRITER INACTIVE
10$:	MOVZBL	#RSN$_MPWBUSY,R0	;SET RESOURCE WAIT THAT IS SATISFIED
	BSBW	SCH$RAVAIL		;DECLARE MODIFIED PAGE WRITER DONE
	TSTL	W^SCH$GL_MFYCNT		;IS LIST EMPTY
	BNEQ	5$
	MOVZBL	#RSN$_MPLEMPTY,R0	;SET RESOURCE WAIT THAT IS SATISFIED
	BSBW	SCH$RAVAIL		;DECLARE MODIFIED LIST EMPTY
5$:	MOVL	(SP)+,R0		;UNUSED I/O PACKET TO RELEASE?
	BEQL	20$			;BRANCH IF NOT
	MOVZBL	#IRP$C_LENGTH,IRP$W_SIZE(R0) ;SET SIZE OF PACKET
	BSBW	EXE$DEANONPAGED		;DEALLOCATE THE I/O REQUEST PACKET
20$:	ENBINT				;RESTORE CALLER'S IPL
	POPR	#^M<R6,R7,R8,R9,R10,R11,AP> ;RESTORE NON-VOLATILE REGISTERS
	RSB				;AND RETURN

MMG$WRTMFYPAG::
	CMPZV	#PTE$V_PFN,#PTE$S_PFN,W^SCH$GL_MFYLIM,- ;ENOUGH PAGES ON MODIFIED
		W^SCH$GL_MFYCNT		;PAGE LIST TO CONSIDER WRITING?
	BLEQ	20$			;BRANCH IF YES
10$:	RSB				;NO, NOTHING TO DO FOR NOW
20$:	BBSSI	S^#SCH$V_MPW,W^SCH$GB_SIP,10$ ;DO NOTHING IF ALREADY ACTIVE
;
; FIRST ENTRY TO MODIFIED PAGE WRITER
;
	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP> ;SAVE NON-VOLATILE REGISTERS
	CLRQ	-(SP)			;SAVED IPL = 0, NO IRP ALLOCATED
;
; SEE IF THERE ARE ANY MORE PAGES TO BE WRITTEN
; 0(SP) = SAVED I/O REQUEST PACKET ADDRESS OR ZERO IF NONE ALLOCATED YET
; 4(SP) = CALLERS IPL
; IPL = ASTDEL OR LOWER
;
GET_NXT_CLUSTER:
	MOVL	W^SCH$GL_CURPCB,R4	;GET PCB ADDRESS OF THIS PROCESS
;
; ***** NOTE THAT PCB$W_DIOCNT(R4) IS ASSUMED GREATER THAN 0
; ***** SIMULTANEOUS I/O REQUESTS WILL INVALIDATE THIS ASSUMPTION
;
	REMQUE	@W^IOC$GL_IRPFL,R2	;GET AN I/O REQUEST PACKET
	BVS	GET_IRP			;BRANCH IF NONE ON SIDE LIST
GOT_IRP:
	MOVL	R2,(SP)			;SAVE IRP ADDRESS
	SETIPL	#IPL$_SYNCH		;RAISE TO SYNCH FOR THE DURATION
	MOVL	W^PFN$AL_MFYLSTHD,R0	;FIRST PFN IN MODIFIED PAGE LIST
GET_PAGE_TYPE:
	BEQL	NOMOREPAGES		;BRANCH IF LIST IS EMPTY
	BSBW	GETPFNCTX		;SET UP TO PROCESS THIS PFN
	CLRL	R6			;INIT INDEX TO PTE ARRAY
	CASE	R1,<-			;DISPATCH ON BACKING STORE TYPE
		PAGEFILE,-		;PAGING FILE PAGE
		SECTION,-		;SECTION PAGE (PROCESS OR GLOBAL)
		BADBAKADR,-		;GLOBAL BACKING STORE ADDRESS
		SWPVBN  >		;SWPVBN, WRITE BACK TO SWAP FILE
BADBAKADR:
	BUG_CHECK IVBAKADIO,FATAL	;INVALID BACKING STORE ADDRESS FOR I/O
;
; NO PAGE FILE VBN'S AVAILABLE IN THIS PAGE FILE
;
NO_PAGEFILE:
	POPR	#^M<R0,R3,R4,R5,R6,R7>	;RECOVER REGISTERS FROM STACK
	BRW	NOSPACE			;EXIT, IF NO SPACE TO WRITE STUFF
NEXT_MFYPAG:
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_FLINK[R0],R0>,-	;CHAIN TO NEXT PAGE
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BRB	GET_PAGE_TYPE		;AND PROCESS IT
;
; PAGE FILE PAGE, GATHER A CLUSTER FROM THE SAME PAGE FILE
;
PAGEFILE:
	EXTZV	#PFN$V_PGFLX,#PFN$S_PGFLX,R2,R7 ;PAGE FILE INDEX
	PUSHR	#^M<R0,R3,R4,R5,R6,R7>	;SAVE PFN,SVAPTE,PCB,PHD,PTE INDEX,FILE
	CLRQ	R0			;NOTHING TO FREE
	MOVL	@W^MMG$GL_PAGSWPVC[R7],R3 ;GET PAGE FILE CONTROL BLOCK ADDRESS
	MOVZBL	PFL$B_ALLOCSIZ(R3),R2	;DESIRED CLUSTER SIZE
5$:	BSBW	MMG$ALLOCPAGFIL1	;ALLOCATE A CLUSTER
	BNEQ	20$			;BRANCH IF WE HAVE ALLOCATION
	SUBL	#16,R2			;ALLOCATION FAILED, TRY SMALLER CLUSTER
	BLEQ	10$			;BRANCH IF ALREADY AT MINIMUM
	MOVB	R2,PFL$B_ALLOCSIZ(R3)	;SET NEW SIZE TO ATTEMPT FROM NOW ON
	CLRL	PFL$L_STARTBYTE(R3)	;START AT BEGINNING OF MAP
	BRB	5$			;TRY AGAIN

10$:	BSBW	MMG$ALLOCPAGFIL2	;ALLOCATE SPACE, ANY AMOUNT OK
	BEQL	NO_PAGEFILE		;BRANCH IF NONE, NO WRITING CAN BE DONE
20$:	MOVL	R2,R11			;SAVE NUMBER OF PAGES ALLOCATED
	MOVL	R0,R8			;AND THE STARTING PAGE FILE VBN
	POPR	#^M<R0,R3,R4,R5,R6,R7>	;RECOVER PFN, SVAPTE
	MOVL	R11,R9			;NUMBER OF PAGEFILE PAGES ALLOCATED
;
; AT THIS POINT THE REGISTERS CONTAIN THE FOLLOWING VALUES:
;	R0  = PFN
;	R3  = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4  = PCB ADDRESS FOR THE PROCESS IN WHICH THIS CODE IS RUNNING
;	R5  = PHD ADDRESS OF THE PROCESS WHICH OWNS THE MODIFIED PAGE
;	R6  = INDEX TO NEXT ENTRY TO USE IN PTE AND PHVINDEX ARRAYS
;	R7  = PAGE FILE INDEX
;	R8  = NEXT PAGE FILE VBN TO USE
;	R9  = NUMBER OF PAGE FILE VBN'S NOT YET USED IN THE CLUSTER ALLOCATED
;	R11 = NUMBER OF PAGE FILE VBN'S ALLOCATED IN THE CLUSTER
;
PAGFILCLUSTER:
	PUSHL	R11			;SAVE COUNT OF ALLOCATED PAGE FILE
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_BLINK[R0],-(SP) >,-	;REMEMBER WHERE TO RESTART SCAN OF LIST
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
;	CLRL	MPW$L_COUNT		;INIT COUNT OF CLUSTER TO 0
	BSBW	PTESCAN			;TRY TO GET ADJACENT PAGES TO THIS ONE
;	MOVL	MPW$L_COUNT,R0		;GET THE COUNT
;	INCL	MPW$A_PGFLCLUSTERS[R0]	;BUMP THE COUNT

;
; DONE WITH THIS CLUSTER OF PAGE TABLE ENTRIES
; IF MORE PAGE FILE VBN'S ARE LEFT, SCAN MODIFIED LIST FOR MORE PAGES
; IN SAME PAGE FILE.
; 0(SP) = SAVED PFN (OR 0) TO LINK FORWARD FROM
; 4(SP) = NUMBER OF PAGE FILE VBN'S ALLOCATED
;
	POPR	#^M<R0,R11>		;R0 = SAVED PFN TO LINK FORWARD
					;R11 = NUMBER OF PAGE FILE VBN'S ALLOCATED
	SUBL3	R6,R11,R9		;NO. OF PAGE FILE VBN'S NOT USED
; DISABLE THE FOLLOWING BECAUSE THIS MIGHT RETURN A SMALL ALLOCATION WITHOUT
; WRITING ANY PAGES AT ALL.
;	CMPW	R9,W^MPW$GW_MINLIM	;ARE WE AT THRESHOLD TO SHUT OFF CLUSTER
	BLEQ	100$			;BRANCH IF USED ALL THAT WE SHOULD
	TSTL	R0			;PFN 0 IS LIST HEAD
	BNEQ	70$			;GET FLINK AS NEXT CANDIDATE
	MOVL	W^PFN$AL_MFYLSTHD,R0	;NEXT CANDIDATE FROM FRONT OF LIST
	BRB	75$
70$:		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_FLINK[R0],R0>,-	;CHAIN TO NEXT PFN IN LIST
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
75$:	BEQL	100$			;BRANCH IF END OF LIST
80$:	BSBW	GETPFNCTX		;SET UP TO PROCESS THIS PFN
	TSTL	R1			;PAGE FILE VBN?
	BNEQ	70$			;BRANCH IF NOT
	CMPZV	#PFN$V_PGFLX,#PFN$S_PGFLX,R2,R7 ;SAME PAGE FILE INDEX?
	BNEQ	70$			;BRANCH IF NOT
	BRW	PAGFILCLUSTER		;FIND ANOTHER PTE CLUSTER
;
; SET UP TO WRITE THIS CLUSTER OF PAGES
;
100$:	SUBL3	R6,R8,R11		;FORM AND SAVE FIRST PAGE FILE VBN
	MOVL	@W^MMG$GL_PAGSWPVC[R7],R3 ;ADDRESS OF PAGE FILE CONTROL BLOCK
	MOVL	R9,R1			;ANY PAGE FILE VBN'S TO DEALLOCATE?
	BEQL	140$			;BRANCH IF THEY WERE ALL USED
	MOVL	R8,R0			;SET VBN NUMBER OR AREA TO DEALLOCATE
;
; THERE ARE R1 PAGES OF PAGE FILE ALLOCATED BUT NOT USED STARTING WITH VBN R0.
; MUST RETURN THEM TO THE PAGE FILE
;
	BSBW	MMG$DEALLOCPAGFIL	;FREE THE PAGES IN THE FILE
;
; NOW SET UP TO DO THE CALL TO BUILDPKT
;	R3 = PAGE FILE CONTROL BLOCK ADDRESS
;	R6  = NO. OF PAGES TO TRANSFER
;	R7  = PAGE FILE INDEX
;	R11 = STARTING PAGEFILE VBN
;
	ASSUME	SEC$L_VBN EQ PFL$L_VBN
	ASSUME	SEC$L_WINDOW EQ PFL$L_WINDOW
140$:	ADDL3	R11,PFL$L_VBN(R3),R0	;FORM VBN IN PAGE FILE
	MOVL	PFL$L_WINDOW(R3),R2	;WINDOW ADDRESS
;
; 0(SP) = ADDRESS OF I/O REQUEST PACKET
; 4(SP) = CALLER'S IPL
; R0 = VBN IN FILE TO WRITE
; R2 = ADDRESS OF WINDOW FOR FILE
; R4 = PROCESS CONTROL BLOCK ADDRESS FOR THE PROCESS IN WHICH THIS CODE IS RUNNING
; R6 = NUMBER OF PAGES TO WRITE
;
MPW_BLDPKT:
	ASHL	#9,R6,R1		;NUMBER OF BYTES TO WRITE
	MOVAL	@W^MPW$AL_PTE,R3	;SVAPTE FOR TRANSFER
	MOVL	(SP)+,R5		;GET I/O PACKET ADDRESS
	MOVAL	W^WRITEDONE,IRP$L_ASTPRM(R5) ;ADDRESS OF KERNEL MODE AST
					;FOR WRITE COMPLETION PROCESSING
	SUBB3	W^MPW$GB_PRIO,#31,IRP$B_PRI(R5)	;SET PRIORITY FOR TRANSFER
	BSBW	EXE$BLDPKTSWPW		;BUILD AND QUEUE THE I/O REQUEST PACKET
;
; R4 NO LONGER HAS PCB ADDRESS IN IT
;
	ENBINT				;BACK TO CALLED IPL

	.IF	GT,CA$_MEASURE
	ADDL	R6,W^PMS$GL_PWRITES	;COUNT THE PAGES WRITTEN
	INCL	W^PMS$GL_PWRITIO	;AND THE NUMBER OF WRITE REQUESTS
	.ENDC

	POPR	#^M<R6,R7,R8,R9,R10,R11,AP> ;RESTORE NON-VOLATILE REGISTERS
	RSB
;
; SECTION PAGE - TRY TO FORM A CLUSTER OF THESE
;

	.ENABL	LSB

SECTION:
	MOVL	R2,R7			;BACKING STORE ADDRESS
	MOVZWL	W^MPW$GW_MPWPFC,R9	;MAXIMUM NUMBER OF PAGES TO CLUSTER
;	CLRL	MPW$L_COUNT		;INIT COUNT OF CLUSTER TO 0
	BSBW	PTESCAN			;LOOK AT ADJACENT PTE'S FOR A CLUSTER TO WRITE
;	MOVL	MPW$L_COUNT,R0		;GET THE COUNT
;	INCL	MPW$A_SECTCLUSTERS[R0]	;BUMP THE COUNT
	MOVL	@W^MPW$AL_PTE,R0	;GET STARTING PAGE NUMBER
	MOVL	@W^PFN$AL_BAK[R0],R2	;GET ITS BACKING STORE ADDRESS
	MOVL	@W^PFN$AL_PTE[R0],R3	;AND ITS PAGE TABLE ENTRY ADDRESS
;
; R5 = PROCESS HEADER ADR ASSOCIATED WITH THIS SVAPTE FROM ORIGINAL GETPFNCTX CALL
;
10$:	BSBW	MMG$INIBLDPKT		;TRANSLATE BACKING STORE TO VBN AND WINDOW
	BRB	MPW_BLDPKT		;GO QUEUE THE REQUEST
;
; THIS PAGE IS A SWPVBN PAGE AND IS TO BE WRITTEN BACK TO THE SWAP FILE
; RATHER THAN ITS NORMAL BACKING STORE ADDRESS
;
SWPVBN:
	BBS	S^#SCH$V_SIP,W^SCH$GB_SIP,40$ ;DON'T PROCESS SWAP VBN'S
					;IF SWAPPER IS ACTIVE
	MOVZWL	PHD$W_PHVINDEX(R5),R1	;GET PROCESS HEADER VECTOR INDEX
	CVTWL	@W^PHV$GL_PIXBAS[R1],R1	;GET PROCESS INDEX
	BLSS	PROCESS_GONE		;BRANCH IF PROCESS IS NO LONGER AROUND
	MOVL	@W^SCH$GL_PCBVEC[R1],R7	;GET PCB ADDRESS
	MOVZWL	PCB$W_APTCNT(R7),R9	;FORM VBN IN SWAP SLOT
	ADDL	R2,R9			;R2 HAD THE SWAP VBN
	ADDL	PCB$L_WSSWP(R7),R9	;FORM SWAP FILE BACKING STORE ADDRESS
	CLRW	@W^PFN$AW_SWPVBN[R0]	;ALL DONE WITH THE SWPVBN FIELD
	BBSS	#PCB$V_SWPVBN,PCB$L_STS(R7),20$ ;NOTE SWPVBN WRITE IN PROGRESS
20$:	MOVL	R3,AP			;STARTING PTE RANGE
	MOVL	R3,R10			;ENDING PTE RANGE
	MNEGL	#1,R7			;SET PTE$V_TYP0
	BSBW	SCAN_DONE		;PUT JUST THIS PAGE IN MPW PTE ARRAY
;
; R9, R10 ASSUMED PRESERVED
;
	MOVQ	R9,R2			;R2 = BACKING STORE ADR, R3 = SVAPTE
	BBCS	#15,@W^MPW$AW_PHVINDEX,10$ ;INDICATE SWAP VBN PAGE WRITE
	BRB	10$			;SET UP FOR BUILDPKT
;
; DO NOT PROCESS THIS MODIFIED PAGE WITH SWPVBN SET SINCE SWAPPER IS ACTIVE
;
40$:	BRW	NEXT_MFYPAG		;SKIP THIS MODIFIED PAGE

	.DSABL	LSB
;
; PROCESS WAS DELETED AND SWAP VBN WAS SET IN PFN DATA BASE
;
PROCESS_GONE:
	BUG_CHECK PROCGONE,FATAL	;PROCESS NOT IN SYSTEM

	.SBTTL	GETPFNCTX
;
; CALLING SEQUENCE:
;
;	BSBW	GETPFNCTX
;
; INPUTS:
;
;	R0 = PFN
;
; OUTPUTS:
;
;	R0 = PFN (PRESERVED)
;	R1 = TYPE OF BACKING STORE ADDRESS
;	   = 0 IF PAGING FILE
;	   = 1 IF SECTION ADDRESS
; 	   = 2 IF ILLEGAL
;	   = 3 IF SWPVBN
;	   = 4 IF NOT A PAGE ON THE MODIFIED PAGE LIST (CHKNXTPTE)
;	R2 = BACKING STORE ADDRESS OR SWPVBN
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4 = PRESERVED
;	R5 = PROCESS HEADER ADDRESS
;
GETPFNCTX:
	MOVL	@W^PFN$AL_PTE[R0],R3	;SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
	EXTZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,@W^PFN$AB_TYPE[R0],R1 ;PAGE TYPE

	ASSUME	PFN$C_PROCESS EQ 0
	ASSUME	PFN$C_SYSTEM  EQ 1
	ASSUME	PFN$C_GLOBAL  EQ 2
	ASSUME	PFN$C_GBLWRT  EQ 3
	ASSUME	PFN$C_PPGTBL  EQ 4
	ASSUME	PFN$C_GPGTBL  EQ 5

	CASE	R1,<-
		PROCESS,-		;PROCESS PAGE
		SYSPHD,-		;SYSTEM PAGE
		BADTYP,-		;GLOBAL READ ONLY
		SYSPHD,-		;GLOBAL WRITABLE
		PHDR,-			;PROCESS PAGE TABLE
		SYSPHD-			;GLOBAL PAGE TABLE
	>
BADTYP:	BUG_CHECK BADPAGTYPE,FATAL	;BAD PAGE TYPE

SYSPHD:
	MOVAL	@W^MMG$GL_SYSPHD,R5	;ADDRESS OF SYSTEM HEADER
	BRB	GOTPHDR			;JOIN THE COMMON CODE

PHDR:
	SUBL3	W^SWP$GL_BALSPT,R3,R5	;NO. OF BYTES INTO SPT BEYOND BALSET BASE
	ASHL	#7,R5,R5		;NO. OF SPT ENTRIES * 512
	BRB	GETPHDR			;GET PROCESS HEADER ADDRESS

PROCESS:
	SUBL3	W^SWP$GL_BALBASE,R3,R5	;NO. OF BYTES BEYOND FIRST BAL SET PAGE
GETPHDR:
	DIVL	SWP$GL_BSLOTSZ,R5	;FORM PROCESS HEADER INDEX
	ASHL	#-9,R5,R5		;DIVIDE BY PAGE SIZE
	MULL	SWP$GL_BSLOTSZ,R5	;CONVERT PROCESS INDEX
	ROTL	#9,R5,R5		;MULL BY BYTES PER PAGE
	ADDL	W^SWP$GL_BALBASE,R5	;TO PROCESS HEADER ADDRESS
GOTPHDR:
	MOVZWL	@W^PFN$AW_SWPVBN[R0],R2	;IS SWPVBN SET?
	BNEQ	40$			;BRANCH IF YES
	MOVL	@W^PFN$AL_BAK[R0],R2	;GET BACKING STORE ADDRESS

	ASSUME	PFN$V_GBLBAK EQ PTE$V_TYP0+1
	EXTZV	#PTE$V_TYP0,#2,R2,R1	;GET BACKING STORE ADDRESS TYPE
	RSB
40$:
	ASSUME	PFN$C_PROCESS EQ 0
	BITB	#PFN$M_PAGTYP,@W^PFN$AB_TYPE[R0] ;REQUIRE SWPVBN PAGE TO BE PROCESS PAGE
	BNEQ	60$			;BRANCH IF NOT, ERROR
	MOVL	#3,R1			;CODE FOR SWPVBN BACKING DESTINATION
	RSB
60$:	BUG_CHECK BADSWPVBN,FATAL	;SWAP VBN ONLY FOR PROCESS PAGES

	.SBTTL	PTESCAN - SCAN ADJACENT PTE'S
;
; PTESCAN, ROUTINE TO SCAN ADJACENT PAGE TABLE ENTRIES FOR TRANSITION
; PAGES THAT ARE ON THE MODIFIED PAGE LIST AND HAVE THE APPROPRIATE
; BACKING STORE ADDRESS FOR CLUSTERING.
; A SCAN IS MADE BACKWARDS FROM THE SVAPTE AND THEN FORWARDS.
;
; CALLING SEQUENCE:
;
;	BSBW	PTESCAN
;
; INPUTS:
;
;	R3 = SVAPTE TO START SCANNING FROM
;	R5 = PROCESS HEADER ADDRESS ASSOCIATED WITH THAT SVAPTE
;	R6 = INDEX TO NEXT AVAILABLE SLOT IN MODIFIED PAGE WRITER
;	     PTE AND PHVINDEX ARRAYS
;	R7 = PAGE FILE INDEX IF PAGE FILE PAGE, TYP0 BIT CLEAR
;	   = SECTION BACKING STORE ADDRESS IF TYP0 BIT SET
;	R8 = PAGE FILE VBN TO USE IF SCANNING FOR PAGE FILE PAGES
;	R9 = MAXIMUM NUMBER OF PAGES TO FIND
;
; OUTPUTS:
;
;	R6 UPDATED TO POINT TO NEXT SLOT NOT USED
;	R8 = FIRST PAGE FILE VBN NOT USED
;	R4,R5,R7 PRESERVED
;	R0,R1,R2,R3 SCRATCHED
;	R9,R10,R11,AP SCRATCHED
;
CHK_ACCESS:
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;INDEX INTO SYSTEM PAGE TABLE
	TSTL	@W^MMG$GL_SPTBASE[R1]	;IS THIS PAGE OF PAGE TABLE ENTRIES VALID
	BGEQ	SCAN_FORWARD		;BRANCH IF NOT
	BRB	SCAN_NEXT1
PTESCAN:
	MOVL	R3,AP			;SAVE SVAPTE
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;KEEP PAGE NUMBER OF SVAPTE
	MNEGL	#4,R11			;GOING BACKWARDS LOOKING AT PTE'S
	BRB	SCAN_AGAIN		;LOOK AT NEXT PAGE TABLE ENTRY
;
; NOTE THAT R1 = PAGE NUMBER OF AN ACCESSABLE PTE
;
SCAN_NEXT:
	ADDL3	R10,R11,R3		;FORM NEXT SVAPTE TO CHECK
	CMPZV	#VA$V_VPN,#VA$S_VPN,R3,R1 ;PTE IN SAME PAGE?
	BNEQ	CHK_ACCESS		;BRANCH IF NOT, CHECK ACCESSABILITY
SCAN_NEXT1:
	BICL3	#^C<PTE$M_VALID !-
		PTE$M_TYP1 ! PTE$M_TYP0 !-
		PTE$M_PGFLVB>,(R3),R0	;GET PFN IF TRANSITION PAGE
	BEQL	SCAN_FORWARD		;BRANCH IF DEMAND ZERO PAGE
	ASHL	#-PTE$V_TYP0,R0,R2	;VALID, TYP1, TYP0 ALL ZERO?
	BNEQ	SCAN_FORWARD		;BRANCH IF NOT TRANSITION PAGE
	CMPL	R0,W^MMG$GL_MAXPFN	;IS THIS A LEGAL PFN?
	BGTR	SCAN_FORWARD		;NO (ALSO REJECTS WINDOW PAGES)
	CMPZV	#PFN$V_LOC,#PFN$S_LOC,-	;SEE IF ON MODIFIED PAGE LIST
		@W^PFN$AB_STATE[R0],#PFN$C_MFYPAGLST
	BNEQ	SCAN_FORWARD		;BRANCH IF NOT ON MODIFIED PAGE LIST
	TSTW	@W^PFN$AW_SWPVBN[R0]	;IF SWAP VBN PAGE,
	BNEQ	SCAN_FORWARD		;DON'T USE IT
	CMPL	R3,@W^PFN$AL_PTE[R0]	;CHECK FOR SPURIOUS MATCH
	BNEQ	SCAN_FORWARD		;BRANCH IF SPURIOUS
	MOVL	@W^PFN$AL_BAK[R0],R2	;GET BACKING STORE ADDRESS
	BBS	#PTE$V_TYP0,R7,60$	;BRANCH IF SECTION ADDRESS
;
; PAGE FILE PAGE, REQUIRE ANOTHER PAGE FILE PAGE WITH SAME PAGE FILE INDEX
;
	BBS	#PTE$V_TYP0,R2,SCAN_FORWARD ;BRANCH IF SECTION PAGE
	CMPZV	#PFN$V_PGFLX,#PFN$S_PGFLX,R2,R7 ;SAME PAGE FILE INDEX?
	BEQL	SCAN_AGAIN		;BRANCH IF YES
	BRB	SCAN_FORWARD		;NOT SAME PAGE FILE
;
; SECTION PAGE, MUST CHECK FOR SECTION BACKING STORE TYPE AND SAME BACKING STORE
;
60$:	CMPL	R2,R7			;SAME SECTION?
	BNEQ	SCAN_FORWARD		;BRANCH IF NOT
SCAN_AGAIN:
	MOVL	R3,R10			;ADDRESS OF LAST PTE CHECKED
	SOBGTR	R9,SCAN_NEXT		;BRANCH IF MORE PAGE FILE VBN'S TO USE
;	INCL	L^MPW$L_BACKUPFAIL(R11)	;COUNT FAILURE FOR EITHER DIRECTION
	BRB	SCAN_DONE		;ALLOCATED PAGE FILE EXHAUSTED,
					;WRITE THE CLUSTER
;
; PTE SCAN CANNOT PROCEED IN CURRENT DIRECTION, SWITCH TO SCAN FORWARD
; IF NOT ALREADY SCANNING FORWARD
;
SCAN_FORWARD:
	MNEGL	R11,R11			;SWITCH DIRECTION OF PTE SCAN
	BLSS	SCAN_DONE		;PTE SCAN COMPLETE IF ALREADY SCANNED FORWARD
	MOVL	AP,R3			;GET STARTING PTE ADDRESS
	MOVL	R10,AP			;RECORD THIS AS STARTING PTE ADDRESS
					;SINCE IT IS LEQU THAN STARTING PTE
	MOVL	R3,R10			;START FORWARD FROM ORIGINAL START PTE
	BRB	SCAN_NEXT		;CONTINUE THE PTE SCAN
;
; AP = SVAPTE, R10 IS THE OTHER SVAPTE, NOT NECESSARILY IN ORDER
; R7 = PAGE FILE INDEX OR SECTION BACKING STORE ADDRESS
;	IF PTE$V_TYP0 IS SET, NO BACKING STORE MANIPULATION
; R9 PRESERVED FROM HERE ON
; R10 PRESERVED FROM HERE ON IF AP LEQU R10
;
SCAN_DONE:
	CMPL	AP,R10			;GET PTE ADDRESSES IN ORDER
	BLEQU	40$			;BRANCH IF R10 IS TOP OF RANGE
	MOVL	R10,R0			;SAVE BOTTOM OF RANGE
	MOVL	AP,R10			;HIGH END OF RANGE
	MOVL	R0,AP			;LOW END OF RANGE
;
; AP = FIRST PTE ADDRESS, R10 = LAST PTE ADDRESS INCLUSIVE
;	ALL PFN'S IN THESE PTE'S ARE ON THE MODIFIED PAGE LIST AND
;	ARE FROM THE SAME PAGE FILE OR SECTION
;
40$:	BICL3	#^C<PTE$M_PFN>,(AP)+,R11 ;GET PAGE FRAME NUMBER
	MOVL	R11,@W^MPW$AL_PTE[R6]	;STORE PFN IN PTE ARRAY
	MOVW	PHD$W_PHVINDEX(R5),@W^MPW$AW_PHVINDEX[R6] ;STORE THE ASSOCIATED
	INCL	R6			;NEXT PTE INDEX
					;PROCESS HEADER VECTOR INDEX
;	INCL	MPW$L_COUNT		;COUNT PAGES IN THIS CLUSTER
	BBS	#PTE$V_TYP0,R7,65$	;BRANCH IF SECTION PAGE
	BITL	#PFN$M_BAK,@W^PFN$AL_BAK[R11] ;NO BACKING STORE?
	BNEQ	100$			;BRANCH IF THERE IS ONE, BUGCHECK
	ASHL	#PFN$V_PGFLX,R7,R2	;PAGE FILE INDEX TO ITS BACKING STORE FIELD
	BISL3	R2,R8,@W^PFN$AL_BAK[R11] ;AND RECORD IT IN THE BACKING STORE ADR
	INCL	R8			;NEXT PAGE FILE VBN
65$:	MOVL	R11,R0			;PFN TO CONVENTIONAL REGISTER
	MOVZBL	#PFN$C_MFYPAGLST,R2	;INDEX TO MODIFIED PAGE LIST
	BSBW	MMG$REMPFN		;REMOVE PAGE FROM MODIFIED PAGE LIST
	BICB3	#<PFN$M_MODIFY ! PFN$M_LOC>,- ;SHUT OFF MODIFY BIT
		@W^PFN$AB_STATE[R0],R1
	BISB3	#PFN$C_WRTINPROG,R1,@W^PFN$AB_STATE[R0] ;SET WRITE IN PROGRESS
	INCW	@W^PFN$AW_REFCNT[R0]	;AND COUNT AN I/O REFERENCE
	CMPZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,- ;IF PROCESS PAGE TABLE PAGE
		@W^PFN$AB_TYPE[R0],#PFN$C_PPGTBL
	BNEQ	80$
	MOVZWL	PHD$W_PHVINDEX(R5),R1	;THEN MUST COUNT A PROCESS HEADER REF
	INCW	@W^PHV$GL_REFCBAS[R1]
80$:	CMPL	AP,R10			;DONE LAST PTE IN RANGE?
	BLEQU	40$			;BRANCH IF MORE TO DO
	RSB

100$:	BUG_CHECK MODRELNBAK,FATAL	;BACKING STORE VBN FOR MODIFIED PAGE

	.END
