	.TITLE	ERRORLOG - ERROR LOG SUPPORT ROUTINES
	.IDENT	'V03-001'
 
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 7-MAR-77
;
; ERROR LOG SUPPORT ROUTINES
;
; MODIFIED BY:
;
;	V03-001	RLRV3A1		Robert L. Rappaport	23-Mar-1982
;		Log UCB$W_STS in ERL$LOGSTATUS.  Also correct two bugs
;		in ERL$LOGSTATUS.
;
;	V02-020	RLREMB3		Robert L. Rappaport	5-Feb-1982
;		Record device name (copied from DDB) in ERL$LOGMESSAGE
;		message header.
;
;	V02-019	LJK0115		Lawrence J. Kenah	20-Jan-1982
;		Repair broken word displacements.
;
;	V02-018	RLREMB2		Robert L. Rappaport	13-Jan-1982
;		More minor corrections to ERL$LOGMESSAGE.
;
;	V02-017	RLREMB1		Robert L. Rappaport	4-Jan-1982
;		Minor corrections to ERL$LOGMESSAGE.
;
;	V02-016	NPK2011		N. Kronenberg		31-Dec-1981
;		Fixed computation of nexus # on unexpected adapter 
;		interrupt.  Fixed unexpected interrupt to dismiss
;		DR32 interrupt in special way since DR32 does not
;		conform to SBI adapter conventions.
;
;	V02-015	SPF0045		Steve Forgey		28-Dec-1981
;		Use allocation interlock flag to synchronize with ERRFMT
;		copying buffer.
;
;	V02-014	ROW0056		Ralph O. Weber		9-DEC-1981
;		Do not set erorr-log-in-progress flag until error log buffer 
;		is successfully allocated.
;
;	V02-013	RLREMB		Robert L. Rappaport	18-Nov-1981
;		Added two new entrypoints: ERL$LOGSTATUS and ERL$LOGMESSAGE.
;		The latter is called to log an error log messsage created
;		by an intelligent mass storage controller.  The former
;		is called to log the software status corresponding to
;		a logged message.
;
;	V02-012	RLR0001		Robert L. Rappaport	17-Nov-1981
;		Correct bug in new ERL$DEVICEATTN.
;
;	V02-011	RLRDVATN	Robert L. Rappaport	28-Oct-1981
;		Added new entrypoint ERL$DEVICEATTN, called when
;		asynchronous errors, unrelated to current I/O operations,
;		occur.  Also added a number of ASSUMEs.
;
;	V02-010	STJ0134		Steven T. Jeffreys	23-Oct-1981
;		Do not increment device error count if error logging
;		is inhibited or disabled.  Also some general speed
;		and cleanliness enhancements.
;
;	V02-009	LMK0002		Len Kawell		02-Sep-1981
;		Fix a truncation error.
;
;	V02-008 ROW0001		Ralph O. Weber		27-JUL-1981
;		Get DDT address from UCB instead of DDB.
;
;	V02-007	KDM0057		Kathleen D. Morse	15-Jul-1981
;		Add SID to error log buffer message format and make header
;		information be negative values off front of message.
;
;	V02-006	TCM0001		Trudy C. Matthews	8-May-1981
;		Change reference of RPB$B_CONFREG to EXE$GL_CONFREG.
;		Change reference of MMG$AL_SBICONF to MMG$GL_SBICONF.
;
;	V02-005	CAS0004		C. A. Samuelson		30-Dec-1980
;		Add counter for SCB Nexus 0 and SCB Vector 0 interrupts.
;		Change unexpected interrupt service so machine checks aren't
;		logged.  Make ERL$VEC vectors long word alligned.
;
;
;-
	.PAGE
;
; MACRO LIBRARY CALLS
;
 
	$CDRPDEF			;DEFINE CDRP OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$EMBDEF	<DV,SU,TS,UI,SP,LM>	;ERROR LOG MESSAGE BUFFERS OFFSETS
	$ERLDEF				;DEFINE ERROR ALLOCATION BUFFER OFFSETS
	$FCBDEF				;DEFINE FCB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION VALUES
	$IRPDEF				;DEFINE IRP OFFSETS
	$MCHKDEF			;DEFINE MACHINE CHECK RECOVERY MASK BITS
	$MSCPDEF			;DEFINE MSCP OFFSETS
	$NDTDEF				;DEFINE NEXUS DEVICE TYPE CODES
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$UCBDEF				;DEFINE UCB OFFSETS
	$WCBDEF				;DEFINE WCB OFFSETS
 
					;***
;DEBUG=1				;***IF DEFINED, ENABLE UNEXPECTED
					;*** INTERRUPT IDENTIFIES VECTOR #

;
; LOCAL MACROS
;

;
; MACRO TO DEFINE AN INTERRUPT SERVICE ROUTINE LABEL FOR UNEXPECTED  INTERRUPTS
;
	.MACRO	ISRDEF,VNUM
	.ALIGN	LONG			; Make all vectors long word alligned
ERL$VEC'VNUM::				;INTERRUPT SERVICE LABEL
	.IF	DF,DEBUG		;***IF DEBUGGING
	BSBW	ERL$UNEXP		;***CALL INTERRUPT SERVICE
	.BYTE	<VNUM>/2		;***IDENTIFY VECTOR OFFSET INTO SCB
	.ENDC
	.ENDM	ISRDEF
;
; MACRO TO DEFINE THE INTERRUPT SERVICE ROUTINE LABELS FOR AN ADAPTER
;
	.MACRO	ADPISR,SLOT
VECTOR = SLOT * 4 + 256
	.REPT	4
	ISRDEF	\VECTOR
VECTOR = VECTOR + <16 * 4>
	.ENDR
	.IF	NDF,DEBUG		;IF NOT DEBUGGING
	BSBB	ADP_HANDLER		;CALL INTERRUPT SERVICE
	.ENDC
	.ENDM	ADPISR
;
; LOCAL SYMBOLS
;

;
; MAXIMUM NUMBER OF MESSAGES BEFORE WAKE OF FORMAT PROCESS
;
 
MAXMSG=10				;
 
;
; MAXIMUM TIME IN SECONDS BEFORE WAKE OF FORMAT PROCESS
;
 
MAXTIM=30				;
 
;
; LOCAL DATA
;
 
	.PSECT	$$$260,QUAD,WRT
;
;	WARNING!!!  The next two bytes must be adjacent and word aligned
;
	.ALIGN	WORD
BUF1:	.BYTE	0			;COUNT OF BUSY MESSAGES IN BUFFER
	.BYTE	0			;COUNT OF COMPLETED MESSAGES IN BUFFER
	.BYTE	0			;BUFFER INDICATOR
	.BYTE	0			;BUFFER CONTROL FLAGS
	.LONG	10$			;ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER
	.LONG	20$			;ADDRESS OF END OF BUFFER + 1
10$:	.BLKB	512-ERL$C_LENGTH	;ACTUAL BUFFER AREA
20$:					;REF LABEL
;
;	WARNING!!!  The next two bytes must be adjacent and word aligned
;
	.ALIGN	WORD
BUF2:	.BYTE	0			;COUNT OF BUSY MESSAGES IN BUFFER
	.BYTE	0			;COUNT OF COMPLETED MESSAGES IN BUFFER
	.BYTE	1			;BUFFER INDICATOR
	.BYTE	0			;BUFFER CONTROL FLAGS
	.LONG	10$			;ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER
	.LONG	20$			;ADDRESS OF END OF BUFFER + 1
10$:	.BLKB	512-ERL$C_LENGTH	;ACTUAL BUFFER AREA
20$:					;REF LABEL
 
;
; GLOBAL DATA
;
; ERROR LOG DATA BASE
;
 
ERL$AL_BUFADDR::			;ALLOCATION BUFFER ADDRESS ARRAY
	.LONG	BUF1			;ADDRESS OF BUFFER 1 DESCRIPTOR
	.LONG	BUF2			;ADDRESS OF BUFFER 2 DESCRIPTOR
ERL$GB_BUFIND::				;CURRENT ALLOCATION BUFFER INDICATOR
	.BYTE	0			;
ERL$GB_BUFFLAG::			;BUFFER STATUS FLAGS
	.BYTE	0			;
ERL$GB_BUFPTR::				;FORMAT PROCESS BUFFER INDICATOR
	.BYTE	0			;
ERL$GB_BUFTIM::				;FORMAT PROCESS WAKEUP TIMER
	.BYTE	MAXTIM			;
ERL$GL_ERLPID::				;PROCESS ID OF ERROR LOG PROCESS
	.LONG	0			;
ERL$GL_SEQUENCE::			;UNIVERSAL ERROR SEQUENCE NUMBER
	.LONG	0			;
	.PAGE
	.SBTTL	UNEXPECTED INTERRUPT SERVICE

;+
; ERL$VEC'VNUM - INTERRUPT SERVICE FOR SCB VECTOR VNUM.
; ERL$UNEXP - GENERAL UNEXPECTED INTERRUPT SERVICE
;
; THESE INTERRUPT SERVICE ROUTINES ARE EXECUTED FOR UNUSED SCB VECTORS.
;
; IF DEBUG IS DEFINED, EACH INTERRUPT SERVICE CALLS ERL$UNEXP WITH
; THE <VECTOR OFFSET>/2 INTO THE SCB AS A 1 BYTE ARGUMENT.
;
; IF DEBUG IS NOT DEFINED, ALL CPU INTERRUPT SERVICE ROUTINES COLLAPSE TO
; GLOBAL LABELS EQUAL TO ERL$UNEXP AND ALL ADAPTER INTERRUPT SERVICE
; ROUTINES CALL A ROUTINE THAT SAVES THE ADAPTER TYPE, TRIES TO DISABLE
; FURTHER INTERRUPTS, AND LOGS THE INTERRUPT.
;
; THERE ARE ENOUGH INTERRUPT SERVICE ROUTINES FOR THE ARCHITECTURAL PAGE 
; OF THE SCB, I.E., 128 ROUTINES.
;
; INPUTS:
;
;	(SP) = PC AT INTERRUPT
;	4(SP) = PSL AT INTERRUPT
;
; OUTPUTS:
;
;	ERROR IS LOGGED, OR PROCESSOR BUGCHECKS.
;-
	.PSECT	$AEXENONPAGED,LONG
;
; UNEXPECTED ADAPTER INTERRUPT HANDLER: IF DEBUG IS DISABLED, SAVE THE
; ADAPTER TYPE, ATTEMPT TO DISABLE FURTHER INTERRUPTS FROM THE ADAPTER,
; AND LOG THE INTERRUPT.  IF DEBUG IS ENABLED, BUGCHECK AS FOR CPU INTERRUPTS.
;
	.ALIGN	LONG
ADP_UNEXP:
	NEXUS = 0			;FIRST ADAPTER = 0
	.REPT	16			;ISR'S FOR 16 ADAPTERS ONLY
	ADPISR	\NEXUS			;DEFINE ERL$INT'VNUM LABELS AND ISRS
	NEXUS = NEXUS + 1		;NEXT ADAPTER
	.ENDR				;
ADP_HANDLER:
	SUBL	#ADP_UNEXP+2,(SP)	;COMPUTE ADAPTER OFFSET
	DIVL	#4,(SP)			;COMPUTE ADAPTER SLOT/TR NUMBER
	PUSHR	#^M<R0,R1,R2,R3,R4>	;SAVE REGISTERS
	MOVL	5*4(SP),R3		;RETRIEVE SLOT NUMBER
	MOVL	@MMG$GL_SBICONF[R3],R4	;GET ADDRESS OF ADAPTER REGISTERS
 
	$PRTCTINI B^5$,#<MCHK$M_NEXM!MCHK$M_LOG>
 
	CLRL	4(R4)			;DISABLE ADAPTER INTERRUPTS (HOPEFULLY)
	MOVL	(R4),R1			;GET ADAPTER CONFIGURATION REG CONTENTS
	CMPB	R1,#NDT$_DR32		;IS THIS A DR32?
	BNEQ	1$			;BRANCH IF NOT
	MOVL	#^X500,(R4)		;ELSE CLEAR INTERRUPTS IN SPECIAL WAY
1$:	MOVL	(R4),R4			;GET THE ADAPTER'S CONFIGURATION REG
 
	$PRTCTEND 5$
	BLBC	R0,100$			;IF R0 LBC, THEN NO ADPATER PRESENT
 
	TSTB	@EXE$GL_CONFREG[R3]	;ALREADY CONFIGURED?
	BNEQ	10$			;IF NEQ, YES
	MOVB	R4,@EXE$GL_CONFREG[R3]	;SAVE THE ADAPTER TYPE
10$:
	MOVL	#EMB$C_UI_LENGTH,R1	;SET SIZE OF MESSAGE TO ALLOCATE
	BSBW	ERL$ALLOCEMB		;ALLOCATE AN ERROR LOG BUFFER
	BLBC	R0,20$			;BRANCH IF NONE AVAILABLE
	MOVW	#EMB$C_UI,EMB$W_UI_ENTRY(R2) ;SET MESSAGE TYPE
	MOVL	R3,EMB$L_UI_TR(R2)	;SET SLOT/TR NUMBER
	MOVL	R4,EMB$L_UI_CSR(R2)	;SET CONFIGURATION REGISTER VALUE
	BSBW	ERL$RELEASEMB		;RELEASE BUFFER
20$:	POPR	#^M<R0,R1,R2,R3,R4>	;RESTORE REGISTERS
	ADDL	#4,SP			;REMOVE SLOT NUMBER
	REI				;
 
100$:	CLRL	R4			;FLAG NO ADAPTER PRESETN
	BRB	10$			;JOIN COMMON CODE
 
;
; UNEXPECTED CPU INTERRUPT HANDLER:  IF DEBUG IS ENABLED, BUGCHECK WITH 
; <VECTOR OFFSET>/2 INTO SCB AS TOP BYTE ON STACK. IF DEBUG IS DISABLED,
; JUST BUGCHECK.
;
	.ALIGN	LONG
CPU_UNEXP:
	VNUM=000			;FIRST VECTOR = 0
	.REPT	64			;ISR'S FOR CPU INTERRUPTS ONLY
	ISRDEF	\VNUM			;DEFINE ERL$INT'VNUM LABEL AND ISR
	VNUM=VNUM+4			;NEXT VECTOR
	.ENDR				;

ERL$UNEXP::				;
	.IF	DF,DEBUG		;***IF VECTOR ID ENABLED,...
	MOVZBL	@(SP),(SP)		;***OVERLAY RETURN WITH VECTOR OFFSET
	MULL	#2,(SP)			;***CONVERT ARG TO VECTOR OFFSET
	.IFTF
	BUG_CHECK UNXINTEXC		;BUGCHECK
	.IFT
	TSTL	(SP)+			;***CLEAN STACK
	.ENDC				;
	REI				;RETURN FROM INTERRUPT

;
; Vector entry for counting unexpected interrupts, rather than logging
; them.  Used on 11/780 for passive release on the DW780 and for the
; CVTP microcode bug.
;
	.ALIGN	LONG

ERL$VEC_RETURN::
	INCL	IO$GL_SCB_INT0		; Increment counter
	REI				; And return


	.PAGE
	.SBTTL	LOG DEVICE ERRORS
;+
; ERL$DEVICERR - LOG DEVICE CONTROLLER AND/OR DRIVE ERROR
; ERL$DEVICTMO - LOG DEVICE TIMEOUT ERROR
;
; THIS ROUTINE IS CALLED TO LOG A DEVICE TIMEOUT OR DEVICE CONTROLLER
; AND/OR DRIVE ERROR.
;
; INPUTS:
;
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF AN ERROR LOG ENTRY IS NOT ALREADY IN PROGRESS ON THE UNIT, ERROR
;	LOGGING IS ENABLED FOR THE UNIT, AND THE CURRENT REQUEST DOES NOT
;	INHIBIT ERROR LOGGING, THEN AN ERROR MESSAGE BUFFER IS ALLOCATED AND
;	FILLED IN WITH PERTINENT REQUEST INFORMATION FOLLOWED BY A DUMP OF
;	THE DEVICE REGISTERS.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL.
;-
 
	.PSECT	WIONONPAGED
	.ENABL	LSB
ERL$DEVICERR::				;LOG DEVICE CONTROLLER AND/OR DRIVE ERROR
	PUSHL	#EMB$C_DE		;SET FOR DEVICE ERROR
	BRB	10$			;
ERL$DEVICTMO::				;LOG DEVICE TIMEOUT ERROR
	MOVZWL	#EMB$C_DT,-(SP)		;SET FOR DEVICE TIMEOUT
10$:	BBC	#DEV$V_ELG,UCB$L_DEVCHAR(R5),40$ ;IF CLR, ERROR LOG DISABLED
	BBS	#IO$V_INHERLOG,UCB$W_FUNC(R5),40$ ;IF SET, ERROR LOG INHIBITED
	INCW	UCB$W_ERRCNT(R5)	;INCREMENT NUMBER OF DEVICE ERRORS
	BBS	#UCB$V_ERLOGIP,UCB$W_STS(R5),40$ ;IF SET, ERROR IN PROGRESS
	PUSHR	#^M<R0,R1,R2,R3,R6>	;SAVE REGISTERS
	MOVL	UCB$L_DDB(R5),R3	;GET ADDRESS OF DDB
	MOVL	UCB$L_DDT(R5),R6	;GET ADDRESS OF DDT (from UCB not DDB)
	MOVZWL	DDT$W_ERRORBUF(R6),R1	;GET SIZE OF ERROR LOG BUFFER IN BYTES
	BSBW	ERL$ALLOCEMB		;ALLOCATE ERROR MESSAGE BUFFER
	BLBC	R0,30$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,UCB$L_EMB(R5)	;SAVE ADDRESS OF ERROR MESSAGE BUFFER
	BISW	#UCB$M_ERLOGIP,UCB$W_STS(R5) ;SIGNAL ERROR LOGGING IN PROGRESS
	MOVW	5*4(SP),EMB$W_DV_ENTRY(R2) ;INSERT ENTRY TYPE
	ADDL	#EMB$B_DV_CLASS,R2	;POINT TO DEVICE CLASS

	ASSUME	EMB$B_DV_TYPE	EQ	EMB$B_DV_CLASS+1
	MOVW	UCB$B_DEVCLASS(R5),(R2)+ ;INSERT DEVICE CLASS AND TYPE
	MOVL	UCB$L_IRP(R5),R1	;GET ADDRESS OF I/O PACKET

	ASSUME	EMB$L_DV_RQPID	EQ	EMB$B_DV_TYPE+1
	MOVL	IRP$L_PID(R1),(R2)+	;INSERT REQUESTER PROCESS ID

	ASSUME	EMB$W_DV_BOFF	EQ	EMB$L_DV_RQPID+4
	ASSUME	EMB$W_DV_BCNT	EQ	EMB$W_DV_BOFF+2
	MOVL	IRP$W_BOFF(R1),(R2)+	;INSERT TRANSFER PARAMETERS

	ASSUME	EMB$L_DV_MEDIA	EQ	EMB$W_DV_BCNT+2
	MOVL	UCB$L_MEDIA(R5),(R2)+	;INSERT SIZE OF DISK

	ASSUME	EMB$W_DV_UNIT	EQ	EMB$L_DV_MEDIA+4
	MOVW	UCB$W_UNIT(R5),(R2)+	;INSERT UNIT NUMBER

	ASSUME	EMB$W_DV_ERRCNT	EQ	EMB$W_DV_UNIT+2
	MOVW	UCB$W_ERRCNT(R5),(R2)+	;INSERT NUMBER OF DEVICE ERRORS

	ASSUME	EMB$L_DV_OPCNT	EQ	EMB$W_DV_ERRCNT+2
	MOVL	UCB$L_OPCNT(R5),(R2)+	;INSERT OPERATIONS COMPLETED

	ASSUME	EMB$L_DV_OWNUIC	EQ	EMB$L_DV_OPCNT+4
	MOVL	UCB$L_OWNUIC(R5),(R2)+	;INSERT VOLUME OWNER UIC

	ASSUME	EMB$L_DV_CHAR	EQ	EMB$L_DV_OWNUIC+4
	MOVL	UCB$L_DEVCHAR(R5),(R2)+	;INSERT DEVICE CHARACTERISTICS

	ASSUME	EMB$B_DV_SLAVE	EQ	EMB$L_DV_CHAR+4
	MOVZBW	UCB$B_SLAVE(R5),(R2)+	;INSERT SLAVE UNIT NUMBER

	ASSUME	EMB$W_DV_FUNC	EQ	EMB$B_DV_SLAVE+2
	MOVW	IRP$W_FUNC(R1),(R2)+	;INSERT FUNCTION VALUE

	ASSUME	EMB$T_DV_NAME	EQ	EMB$W_DV_FUNC+2
	MOVAL	DDB$T_NAME(R3),R1	;GET ADDRESS OF DEVICE NAME
	MOVZBL	(R1),R3			;GET NUMBER OF CHARACTERS TO MOVE
	ADDL3	#EMB$L_DV_REGSAV-EMB$T_DV_NAME,R2,R0 ;CALCULATE ADDRESS OF REGISTERS
20$:	MOVB	(R1)+,(R2)+		;MOVE DEVICE NAME TO BUFFER
	SOBGEQ	R3,20$			;ANY MORE CHARACTERS TO MOVE?
	JSB	@DDT$L_REGDUMP(R6)	;CALL REGISTER DUMP ROUTINE
30$:	POPR	#^M<R0,R1,R2,R3,R6>	;RESTORE REGISTERS
40$:	ADDL2	#4,SP			;REMOVE ENTRY TYPE FROM STACK
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	LOG ASYCHRONOUS DEVICE ATTENTIONS

;+
; ERL$DEVICEATTN - Log asychronous device attention interrupts that are
;	not related to the current I/O operation that may be in progress.
;
; INPUTS:
;
;	R5 => UCB
;
; OUTPUTS:
;
;	If error logging is enabled for the device, an error log buffer
;	is allocated, filled in and released.  There may be an error log
;	in progress for the current device, but this is not taken into
;	account since the current attention interrupt is not related to
;	the I/O that may be in progress.
;
;-

ERL$DEVICEATTN::

	PUSHR	#^M<R0,R1,R2,R3,R6>	; Save registers.
	MOVL	UCB$L_DDT(R5),R6	; Get address of DDT.
	MOVZWL	DDT$W_ERRORBUF(R6),R1	; R1=size of error log buffer in bytes.
	INCW	UCB$W_ERRCNT(R5)	; Increment number of device errors.
	BBC	#DEV$V_ELG,-
		UCB$L_DEVCHAR(R5),30$	; If clr, error log disabled.
	BSBW	ERL$ALLOCEMB		; Allocate error message buffer.
	BLBC	R0,30$			; If LBC allocation failure.
	PUSHL	R2			; Save address of allocated buffer.
	MOVW	#EMB$C_DA,-
		EMB$W_DV_ENTRY(R2)	; Insert entry type.
	MOVW	UCB$W_STS(R5),-		; Save device status in buffer.
		EMB$W_DV_STS(R2)
	CLRQ	EMB$Q_DV_IOSB(R2)	; Clear irrelevant field.

	ADDL	#EMB$B_DV_CLASS,R2	; R2 => device class field.

	ASSUME	EMB$B_DV_TYPE	EQ	EMB$B_DV_CLASS+1
	MOVW	UCB$B_DEVCLASS(R5),(R2)+ ; Insert device class and type.

	ASSUME	EMB$L_DV_RQPID	EQ	EMB$B_DV_TYPE+1
	ASSUME	EMB$W_DV_BOFF	EQ	EMB$L_DV_RQPID+4
	ASSUME	EMB$W_DV_BCNT	EQ	EMB$W_DV_BOFF+2
	CLRQ	(R2)+			; Clear PID, BOFF and BCNT.

	ASSUME	EMB$L_DV_MEDIA	EQ	EMB$W_DV_BCNT+2
	MOVL	UCB$L_MEDIA(R5),(R2)+	; Insert size of disk.

	ASSUME	EMB$W_DV_UNIT	EQ	EMB$L_DV_MEDIA+4
	MOVW	UCB$W_UNIT(R5),(R2)+	; Insert unit number.

	ASSUME	EMB$W_DV_ERRCNT	EQ	EMB$W_DV_UNIT+2
	MOVW	UCB$W_ERRCNT(R5),(R2)+	; Insert number of device errors.

	ASSUME	EMB$L_DV_OPCNT	EQ	EMB$W_DV_ERRCNT+2
	MOVL	UCB$L_OPCNT(R5),(R2)+	; Insert operations completed.

	ASSUME	EMB$L_DV_OWNUIC	EQ	EMB$L_DV_OPCNT+4
	MOVL	UCB$L_OWNUIC(R5),(R2)+	; Insert volume owner uic.

	ASSUME	EMB$L_DV_CHAR	EQ	EMB$L_DV_OWNUIC+4
	MOVL	UCB$L_DEVCHAR(R5),(R2)+	; Insert device characteristics.

	ASSUME	EMB$B_DV_SLAVE	EQ	EMB$L_DV_CHAR+4
	MOVZBW	UCB$B_SLAVE(R5),(R2)+	; Insert slave unit number.

	ASSUME	EMB$W_DV_FUNC	EQ	EMB$B_DV_SLAVE+2
	CLRW	(R2)+			; Clear irrelevant function value.

	ASSUME	EMB$T_DV_NAME	EQ	EMB$W_DV_FUNC+2
	MOVL	UCB$L_DDB(R5),R3	; R3 => DDB.
	MOVAL	DDB$T_NAME(R3),R1	; R1 => device name.
	MOVZBL	(R1),R3			; R3 = # characters to move.
	ADDL3	#EMB$L_DV_REGSAV-EMB$T_DV_NAME,R2,R0
					; Calculate address of registers.
20$:	MOVB	(R1)+,(R2)+		; Move device name to buffer.
	SOBGEQ	R3,20$			; Any more characters to move?
	MOVL	DDT$L_REGDUMP(R6),R1	; R1 => register dump routine.
	JSB	(R1)			; Call register dump routine.
	POPL	R2			; Restore address of allocated buffer.
	BSBW	ERL$RELEASEMB		; Release this error log buffer.
30$:	POPR	#^M<R0,R1,R2,R3,R6>	; Restore registers.
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	LOG SOFTWARE STATUS

;+
; ERL$LOGSTATUS - Log software status corresponding to a logged message.
;
; INPUTS:
;	R0-R1 contain final I/O status
;	R2 => MSCP end message
;	R3 => UCB
;	R5 => CDRP
;
; OUTPUTS:
;	An error log message (format EMBSPDEF) is allocated and filled in.
;	All registers are preserved.
;-

ERL$LOGSTATUS::

	INCW	UCB$W_ERRCNT(R3)	; Increment number of device errors.
	BBC	#DEV$V_ELG,-		; If clear, error log disabled.
		UCB$L_DEVCHAR(R3),20$

	MOVQ	R0,-(SP)		; Save R0, R1, R2.
	PUSHL	R2
	MOVZWL	#EMB$K_SP_LENGTH,R1	; R1 contains length of buffer to alloc
	BSBW	ERL$ALLOCEMB		; Allocate error message buffer.
	BLBC	R0,10$			; LBC implies allocation failure.

	MOVW	#EMB$C_SP,-		; Indicate type of error log buffer.
		EMB$W_SP_ENTRY(R2)
	MOVAB	EMB$B_SP_CLASS(R2),R0	; R0 => where to begin filling.

	ASSUME	UCB$B_DEVTYPE	EQ	UCB$B_DEVCLASS+1
	ASSUME	EMB$B_SP_TYPE	EQ	EMB$B_SP_CLASS+1
	MOVW	UCB$B_DEVCLASS(R3),(R0)+; Move Device type and class.

	ASSUME	EMB$W_SP_BOFF	EQ	EMB$B_SP_TYPE+1
	MOVW	CDRP$W_BOFF(R5),(R0)+	; Copy BOFF.

	ASSUME	EMB$L_SP_BCNT	EQ	EMB$W_SP_BOFF+2
	MOVL	CDRP$L_BCNT(R5),(R0)+	; Also byte count.

	ASSUME	EMB$L_SP_MEDIA	EQ	EMB$L_SP_BCNT+4
	MOVL	CDRP$L_MEDIA(R5),(R0)+	; Move media address (LBN).

	ASSUME	EMB$L_SP_RQPID	EQ	EMB$L_SP_MEDIA+4
	MOVL	CDRP$L_PID(R5),(R0)+	; Copy requesting PID.

	ASSUME	EMB$Q_SP_IOSB	EQ	EMB$L_SP_RQPID+4
	MOVQ	4(SP),(R0)+		; Copy saved I/O status to buffer.

	ASSUME	EMB$W_SP_FUNC	EQ	EMB$Q_SP_IOSB+8
	MOVW	CDRP$W_FUNC(R5),(R0)+	; Copy I/O function code.

	ASSUME	EMB$W_SP_UNIT	EQ	EMB$W_SP_FUNC+2
	MOVW	UCB$W_UNIT(R3),(R0)+	; Copy unit number.

	ASSUME	EMB$L_SP_OPCNT	EQ	EMB$W_SP_UNIT+2
	MOVL	UCB$L_OPCNT(R3),(R0)+	; Copy cummulative operation count.

	ASSUME	EMB$W_SP_ERRCNT	EQ	EMB$L_SP_OPCNT+4
	MOVW	UCB$W_ERRCNT(R3),(R0)+	; And also cummulative error count.

	ASSUME	EMB$W_SP_UCBSTS	EQ	EMB$W_SP_ERRCNT+2
	MOVW	UCB$W_STS(R3),(R0)+	; Copy UCB STS field.

	ASSUME	EMB$L_SP_OWNUIC	EQ	EMB$W_SP_UCBSTS+2
	MOVL	UCB$L_OWNUIC(R3),(R0)+	; Copy device owner UIC.

	ASSUME	EMB$L_SP_CHAR	EQ	EMB$L_SP_OWNUIC+4
	MOVL	UCB$L_DEVCHAR(R3),(R0)+	; Copy device characteristics.

	ASSUME	EMB$L_SP_CMDREF	EQ	EMB$L_SP_CHAR+4
	MOVL	(SP),R1			; R1 => MSCP end message.
	MOVL	MSCP$L_CMD_REF(R1),(R0)+; Copy command reference number (RSPID).

	ASSUME	EMB$T_SP_DEVNAM	EQ	EMB$L_SP_CMDREF+4
	MOVL	UCB$L_DDB(R3),R1	; R1 => DDB.
	MOVQ	DDB$T_NAME(R1),(R0)+	; Copy device name (max of 16
	MOVQ	DDB$T_NAME+8(R1),(R0)+	;  characters.

	BSBW	ERL$RELEASEMB		; Release filled in error buffer.
10$:
	POPL	R2			; Restore registers R2, R1, R0.
	MOVQ	(SP)+,R0
20$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	LOG DRIVER MESSAGE

;+
; ERL$LOGMESSAGE - Subroutine to allocate a message buffer, fill in a
;	standard header, and then copy caller specified test to the rest
;	of the buffer.
;
; INPUTS:
;	R0 =  Code specifying message sub type.
;	R1 =  length of caller specified text
;	R2 => caller text
;	R3 => UCB
;
; OUTPUTS:
;	Message allocated and filled.  All registers preserved.
;-

ERL$LOGMESSAGE::

	INCW	UCB$W_ERRCNT(R3)	; Increment total number of errors.
	BBC	#DEV$V_ELG,-		; Clear means error logging inhibited.
		UCB$L_DEVCHAR(R3),20$

	MOVQ	R0,-(SP)		; Save registers R0-R5.
	MOVQ	R2,-(SP)
	MOVQ	R4,-(SP)
	ADDL	#EMB$K_LM_LENGTH,R1	; Add message header to caller's length.
	BSBW	ERL$ALLOCEMB		; Allocate buffer.
	BLBC	R0,10$			; LBC means allocation failure.

	PUSHL	R2			; Save address of buffer.
	MOVW	#EMB$C_LM,-		; Indicate type of error log buffer.
		EMB$W_LM_ENTRY(R2)

	ASSUME	UCB$B_DEVTYPE	EQ	UCB$B_DEVCLASS+1
	ASSUME	EMB$B_LM_TYPE	EQ	EMB$B_LM_CLASS+1
	MOVW	UCB$B_DEVCLASS(R3),-	; Begin to fill in buffer.  Copy
		EMB$B_LM_CLASS(R2)	;  Device type and class.

	MOVW	UCB$W_UNIT(R3),-	; Also copy device unit number.
		EMB$W_LM_UNIT(R2)
	MOVL	UCB$L_DDB(R3),R1	; R1 => DDB.
	MOVQ	DDB$T_NAME(R1),-	; Copy device name (max of 16
		EMB$T_LM_DEVNAM(R2)	;  characters).
	MOVQ	DDB$T_NAME+8(R1),-
		EMB$T_LM_DEVNAM+8(R2)
	MOVW	20(SP),EMB$W_LM_MSGTYP(R2)	 ; Copy message subtype.
	MOVL	12(SP),R1			 ; R1 => caller's text.
	MOVC3	24(SP),(R1),EMB$W_LM_MSGTYP+2(R2); Copy caller's text.
	POPL	R2				 ; R2 => allocated buffer.
	BSBW	ERL$RELEASEMB			 ; Release buffer.
10$:
	MOVQ	(SP)+,R4		; Restore Registers R0-R5.
	MOVQ	(SP)+,R2
	MOVQ	(SP)+,R0
20$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	BUILD STARTUP AND POWERFAIL MESSAGES
;+
; ERL$COLDSTART - LOG COLDSTART (SYSTEMBOOT)
;
; THIS ROUTINE IS CALLED BY SYSINIT AFTER CORRECTLY SETTING THE SYSTEM
; TIME TO LOG THE BOOTING OF THE SYSTEM.
;
; ERL$WARMSTART - LOG WARMSTART (POWER RECOVERY)
;
; THIS ROUTINE IS CALLED BY POWERFAIL AFTER CORRECTING THE SYSTEM TIME
; TO LOG THE POWER FAIL AND RECOVERY.
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;
; AN ERROR LOG BUFFER IS ALLOCATED AND FILLED WITH THE APPROPRIATE MESSAGE
; IF POSSIBLE AND THE ERROR LOG PROCESS AWAKENED IF NECESSARY.
;-
	.ENABL	LSB
ERL$COLDSTART::				;
	MOVZWL	#EMB$C_CS,R3		;SET TYPE OF MESSAGE TO COLDSTART
	BRB	10$			;
ERL$WARMSTART::				;
	MOVZWL	#EMB$C_WS,R3		;SET TYPE OF MESSAGE TO WARMSTART
10$:	MOVZWL	#EMB$C_SU_LENGTH,R1	;SET SIZE OF MESSAGE TO ALLOCATE
	BSBB	ERL$ALLOCEMB		;ALLOCATE AN ERROR LOG BUFFER
	BLBC	R0,20$			;BRANCH IF NONE AVAILABLE
	MFPR	#PR$_TODR,EMB$L_SU_DAYTIM(R2) ;LOG TIME OF DAY CLOCK
	MOVW	R3,EMB$W_SU_ENTRY(R2)	;SET MESSAGE TYPE
	BSBW	ERL$RELEASEMB		;RELEASE BUFFER
20$:	RSB				;
	.DSABL	LSB			;
	.PAGE
	.SBTTL	ALLOCATE ERROR MESSAGE BUFFER
;+
; ERL$ALLOCEMB - ALLOCATE ERROR MESSAGE BUFFER
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN ERROR LOG MESSAGE BUFFER AND
; INITIALIZE ITS HEADER.
;
; INPUTS:
;
;	R1 = SIZE OF MESSAGE BUFFER REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES AN ALLOCATION FAILURE.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL ALLOCATION WITH:
;
;		R1 = ERROR SEQUENCE NUMBER.
;		R2 = ADDRESS OF ALLOCATED ERROR MESSAGE BUFFER.
;
;	IN EITHER CASE THE UNIVERSAL ERROR SEQUENCE NUMBER IS INCREMENTED
;	AND STORED IN THE BUFFER AT THE STANDARD PLACE, ALONG WITH THE TIME.
;	AND THE ERROR LOG PROCESS MAY BE AWAKENED IF AN ERROR ALLOCATION
;	BUFFER IS FOUND TO BE FULL.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
ERL$ALLOCEMB::				;ALLOCATE ERROR MESSAGE BUFFER
	DSBINT				;DISABLE ALL INTERRUPTS
	ADDL	#EMB$K_LENGTH,R1	; Add in size of header for message
	MOVZBL	ERL$GB_BUFIND,R0	;GET CURRENT ALLOCATION BUFFER INDICATOR
	MOVL	ERL$AL_BUFADDR[R0],R0	;GET ADDRESS OF ALLOCATION BUFFER DESCRIPTOR
	BBS	#ERL$V_LOCK,ERL$B_FLAGS(R0),15$; IF SET, BUFFER BEING COPIED
10$:	MOVL	ERL$L_NEXT(R0),R2	;GET ADDRESS OF NEXT AVAILABLE SPACE
	ADDL3	R1,R2,ERL$L_NEXT(R0)	;CALCULATE ADDRESS OF NEXT AVAILABLE SPACE
	CMPL	ERL$L_END(R0),ERL$L_NEXT(R0) ;ENTRY FIT WITHIN BUFFER?
	BGEQU	20$			;IF GEQU YES
	BISB	#ERL$M_TIMER,ERL$GB_BUFFLAG ;SET TIMER ACTIVE
	MOVB	#1,ERL$GB_BUFTIM	;FORCE ERROR LOG PROCESS WAKE
15$:	MOVL	ERL$L_END(R0),ERL$L_NEXT(R0) ;INDICATE THAT BUFFER IS FULL
	XORB	#1,ERL$GB_BUFIND	;SWITCH TO ALTERNATE BUFFER
	MOVZBL	ERL$GB_BUFIND,R0	;GET NEW BUFFER INDICATOR
	MOVL	ERL$AL_BUFADDR[R0],R0	;GET ADDRESS OF ALLOCATION BUFFER DESCRIPTOR
	BBS	#ERL$V_LOCK,ERL$B_FLAGS(R0),17$; IF SET, BUFFER BEING COPIED
	ADDL3	R1,ERL$L_NEXT(R0),R2	;CALCULATE ADDRESS OF NEXT AVAILABLE SPACE
	CMPL	ERL$L_END(R0),R2	;ENTRY FIT WITHIN BUFFER?
	BGEQU	10$			;IF GEQU YES
17$:	MOVL	ERL$L_END(R0),ERL$L_NEXT(R0) ;INDICATE THAT BUFFER IS FULL
	CLRL	R0			;INDICATE ALLOCATION FAILURE
	BRB	30$			;
20$:	ADDL	#EMB$K_LENGTH,R2	; Point past the message header
	MFPR	#PR$_SID,EMB$L_HD_SID(R2)	; Set system ID into message
	MOVZWL	R1,EMB$W_SIZE(R2)	; Set size in message header
	MOVB	ERL$B_BUFIND(R0),EMB$B_BUFIND(R2) ;SET RESPECTIVE BUFFER INDICATOR
	INCB	ERL$B_BUSY(R0)		;INCREMENT MESSAGE BUSY COUNT
	MOVL	ERL$GL_SEQUENCE,R1	;GET CURRENT ERROR SEQUENCE NUMBER
	MOVQ	EXE$GQ_SYSTIME,EMB$Q_DV_TIME(R2) ;INSERT CURRENT TIME
	MOVW	R1,EMB$W_DV_ERRSEQ(R2)	;INSERT ERROR SEQUENCE NUMBER
	MOVL	#1,R0			;SET SUCCESS INDICATOR
30$:	INCL	ERL$GL_SEQUENCE		;INCREMENT UNIVERSAL ERROR SEQUENCE NUMBER
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
	.PAGE
	.SBTTL	RELEASE ERROR MESSAGE BUFFER
;+
; ERL$RELEASEMB - RELEASE ERROR MESSAGE BUFFER
;
; THIS ROUTINE IS CALLED TO RELEASE AN ERROR MESSAGE BUFFER FOR PROCESSING
; BY THE ERROR LOG PROCESS.
;
; INPUTS:
;
;	R2 = ADDRESS OF ERROR MESSAGE BUFFER.
;
; OUTPUTS:
;
;	THE COMPLETED ERROR MESSAGE COUNT IS INCREMENTED IN THE RESPECTIVE
;	ALLOCATION BUFFER HEADER, THE MESSAGE IS SET VALID, AND THE BUSY
;	MESSAGE COUNT IS DECREMENTED IN THE RESPECTIVE ALLOCATION BUFFER
;	HEADER.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
ERL$RELEASEMB::				;RELEASE ERROR MESSAGE BUFFER
	INCB	EMB$B_VALID(R2)		;SET MESSAGE BUFFER VALID
	MOVZBL	EMB$B_BUFIND(R2),R0	;GET BUFFER INDICATOR OF ALLOCATION BUFFER
	MOVL	ERL$AL_BUFADDR[R0],R0	;GET ADDRESS OF ALLOCATION BUFFER DESCRIPTOR
	ADAWI	#^XFF,ERL$B_BUSY(R0)	;ADJUST BUSY AND COMPLETED MESSAGE COUNT
	BBCS	#ERL$V_TIMER,ERL$GB_BUFFLAG,10$ ;IF CLR, NO TIMER RUNNING
	CMPB	#MAXMSG,ERL$B_MSGCNT(R0) ;MAXIMUM NUMBER OF MESSAGES EXCEEDED?
	BGTRU	10$			;IF GTRU NO
	MOVB	#1,ERL$GB_BUFTIM	;FORCE ERROR LOG PROCESS WAKE
10$:	RSB				;
	.PAGE
	.SBTTL	WAKE ERROR LOG FORMAT PROCESS
;+
; ERL$WAKE - WAKE ERROR LOG FORMAT PROCESS
;
; THIS ROUTINE IS CALLED ONCE A SECOND WHEN THE ERROR BUFFER TIMER IS ACTIVE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE ERROR BUFFER TIMER IS DECREMENTED AND IF THE RESULT IS ZERO THE
;	ERROR LOG FORMAT PROCESS IS AWAKENED.
;-
 
ERL$WAKE::				;WAKE ERROR LOG FORMAT PROCESS
	DECB	ERL$GB_BUFTIM		;DECREMENT TIMER
	BNEQ	10$			;
	BICB	#ERL$M_TIMER,ERL$GB_BUFFLAG ;CLEAR TIMER ACTIVE FLAG
	MOVB	#MAXTIM,ERL$GB_BUFTIM	;RESET TIMER VALUE
	MOVL	ERL$GL_ERLPID,R1	;GET ERROR LOG PROCESS ID
	BSBW	SCH$WAKE		;WAKE ERROR LOG PROCESS
10$:	RSB				;
 
	.END
	
