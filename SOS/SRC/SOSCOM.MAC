	.TITLE	SOSCOM - COMMON ROUTINES
	.IDENT	/V03000/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	23-FEB-76
;
; MODIFIED BY:
;
;	020705	PHL0705		Peter H. Lipman		26-Jun-1981
;		OVRTYP routine now tests whether the "cursor up"
;		string has anything in it, rather than if TTSCP is
;		set.  This allows for scope rubout to work for Foreign
;		terminals for which SOS has not "cursor up" and
;		"erase to end of line" control strings.
;
;	020704	PHL0704		Peter H. Lipman		25-Jun-1980
;
;	Move RESETSP out of SOSERR into this module
;
	.MCALL	FDOF$L,FCSBT$,QIOSY$
	FDOF$L
	FCSBT$
	QIOSY$
	.MCALL	DIR$,WSIG$S,QIOW$

	.IF	NDF,R$$STS
	.MCALL	ENCP$S,DSCP$S,TTSYM$,ASTX$S,CLEF$S
	TTSYM$
	.ENDC

	DATA$	COM

	.IF	NDF,R$$STS
TTATDT::QIOW$	IO.DET,TIOLUN,1,,IOSTS,,<CTLC,,CTLC>
TYPDPB::QIOW$	IO.WVB,TIOLUN,1,,,,<TTOBUF,,0,,,>
				;IN SOSINI IF RUNNING 11D OR IAS
	.ENDC

	CODE$	COM

; ROOT STARTUP CODE
;
START:	JMP	START1			;WILL INIT SP FOR RSTS
START2::JMP	SOSGO			;0(SP)=#EXIT
EXIT::	JMP	EXIT1

	.ENABL	LSB
ILLLTL::MOV	#14.,-(SP)		;LINE TOO LONG
	BR	10$
ILLRO::	MOV	#18.,-(SP)		;ILLEGAL FOR READ ONLY FILE
	BR	10$
ILLNSL::MOV	#8.,-(SP)		;NO SUCH LINE
	BR	10$
ILLCMD::MOV	#7,-(SP)		;ILLEGAL SYNTAX OF COMMAND
10$:	CLR	-(SP)			;LEAVE SPACE FOR RETURN PC
	.DSABL	LSB
;
; CMDABO(ERRCOD) - ABORT THE COMMAND
;
CMDABO::MOV	#2,4(SP)		;CLOBBER STACK LOC BEFORE PARAM
;
; SOSERR(ERRTYP,ERRCOD)
;
SOSERR::JMP	SOSRRR			;ROOT ERROR DISPATCHER
LISTN1::JSR	PC,.GCML1		;CALL GCML FROM ROOT
	ROL	-(SP)			;SAVE CARRY ACROSS AUTOLOAD
	JMP	LISTN2			;AND RELOAD LISTEN
LISTN3::JSR	PC,GCMLER		;PROCESS GET COMMAND LINE ERROR
	JMP	LISTN4			;AND RELOAD LISTEN
FCFATL::JMP	FCFAT1			;FCS FATAL ERROR

	.SBTTL	TTY I/O ROUTINES - PRINT & TYPE
;
; PRINT <CR><LF> UNLESS ALREADY PRINTED DUE TO IAS ALTMODE ECHOING
;
ENTRY	IAS033
	BIT	#SYSIAS!SYS11D,SYSTEM	;UNLESS <ALT> WAS ECHOED A "$<CR>"
	BEQ	TYPECR			;OUTPUT <CR><LF>
	RTS	PC			;ELSE RETURN
;
; PRINT A STRING AND APPEND CR, LF
;
ENTRY	EMSG				;EMSG(PLIT "MSG"))
ENTRY	PRINTC				;PRINTC(PLIT "MSG")
	MOV	2(SP),R0		;MESSAGE POINTER
	JSR	PC,PRTR0		;PRINT IT
;
; TYPE A CR, LF
;
ENTRY	TYPECR				;TYPECR()
	MOV	#CRLF,R0		;ADD LINE TERM
	BR	PRTR0

;
; PRINT "IN LINE" MESSAGE
;	JSR	R1,PRTINL
;	.WORD	MSGADR			;ADDRESS OF PLIT
;
PRTINL::MOV	(R1)+,R0		;ADDRESS OF MESSAGE
	JSR	PC,PRTR0		;PRINT IT
	RTS	R1			;AND RETURN

;
; PRINT A MESSAGE GIVEN THE ADDRESS OF A BLISS PLIT
;	2(SP) = ADDRESS OF STRING, WORD ALIGNED
;	THE WORD PRECEEDING THE STRING CONTAINS ITS SIZE IN WORDS
;		IF THE ACTUAL STRING SIZE WAS ODD, THE TRAILING BYTE IS 0
;
;
ENTRY	PRINT				;PRINT(PLIT "MSG")
	MOV	2(SP),R0		;R0=ADR
PRTR0:	MOV	R1,-(SP)
	MOV	-2(R0),R1		;R1=LEN
	ASL	R1			;BYTE LENGTH
	BR	TYPIT

ENTRY	PRINTZ				;PRINTZ(ADR OF ASCIZ STRING)
	MOV	2(SP),R0		;POINTER TO DATA
PRTZ1:	MOV	R1,-(SP)		;SAVE A REG FOR LEN
	MOV	R0,R1			;COPY ADDRESS
5$:
	.IF	NDF,R$$STS
	TSTB	(R1)+			;LOOK FOR END

	.IFF	;RSTS ONLY
	BITB	#177,(R1)+		;LOOK FOR END
	.ENDC

	BNE	5$			;OF THE STRING
	SUB	R0,R1			;COMPUTE LENGTH
	BR	TYPIT			;GO WRITE THE STRING


;
; PRINT A NUMBER IN DECIMAL USING SPECIFIED MINIMUM FIELD WIDTH
;	2(SP) = FIELD WIDTH IN BYTES
;	4(SP) = VALUE TO CONVERT TO DECIMAL AND PRINT
;
ENTRY	PRINTN				;PRINTN(NUMBER,CHAR COUNT)
	MOV	4(SP),-(SP)		;SAME TWO PARAMS
	MOV	4(SP),-(SP)		;GO TO CNVDEC
	JSR	PC,CNVDEC		;CONVERT TO DECIMAL, RETURN ADR IN R0
	CMP	(SP)+,(SP)+
	BR	PRTZ1			;PRINT ASCIZ STRING (ADR IN R0)

;
; TYPE A STRING GIVEN ADDRESS AND BYTE COUNT
;	2(SP) = ADDRESS OF STRING
;	4(SP) = SIZE IN BYTES
;
ENTRY	TYPSTR				;TYPSTR(BYTE COUNT, ADDRESS)
	MOV	R1,-(SP)
	MOV	4(SP),R0		;ADR OF STRING
	MOV	6(SP),R1		;SIZE IN BYTES
	BR	TYPIT

;
; TYPE A CHARACTER
;	2(SP) = CHARACTER TO TYPE
;
ENTRY	TYPE				;TYPE("*")
	MOV	SP,R0			;GEN POINTER TO CHAR
	MOV	R1,-(SP)
	TST	(R0)+			;CHAR TO TYPE
	MOV	#1,R1			;LENGTH

;
; R0 = ADDRESS OF STRING, R1 = BYTE COUNT
; 0(SP) = SAVED R1
;
TYPIT:
	.IF	DF,R$$STS
	MOV	R2,-(SP)		;SAVE A REG
	MOV	TTOCTL,R2		;POINT TO OUTPT BUFFER
5$:	MOVB	(R0),(R2)+		;COPY A CHARACTER
	INC	TTOCTL+2		;INC LENGTH IN BUFFER
	CMPB	(R0)+,#12		;LINE TERMINATOR?
	BEQ	7$
	CMP	R2,#TTOEND		;OUT OF BUFFER SPACE?
	BHI	7$			;BRANCH IF YES
	SOB	R1,5$			;DO NEXT CHARACTER
	BR	10$

7$:	MOV	#XRB+XRBLK,R2		;POINT TO XRB
	CLR	(R2)			;XRBLK=0
	CLR	-(R2)			;XRCI=0 (CHANNEL)
	MOV	#TTOBUF,-(R2)		;XRLOC=ADDRESS
	MOV	TTOCTL+2,-(R2)		;XRBC=LENGTH
	MOV	TTOCTL+2,-(R2)		;XRLEN=LENGTH ALSO
	.WRITE
	JSR	PC,IOCHK		;CHECK FOR TERMINAL ERROR

	MOV	#TTOBUF,R2		;POINT TO OUTPT BUFFER
	CLR	TTOCTL+2		;ZERO LEN LEFT
	SOB	R1,5$			;NEXT CHAR IN MESSAGE
10$:	MOV	R2,TTOCTL		;NEXT AVAIL OUTPT LOC
	MOV	(SP)+,R2		;RESTORE REGISTERS
	MOV	(SP)+,R1		;AND
	RTS	PC			;EXIT

	.IFF	;RSX ONLY
	MOV	R2,-(SP)		;SAVE SOME REGISTERS
	MOV	R3,-(SP)		;
	MOV	#TTOCTL,R3		;ADR OF OUTPUT BUF ADR AND SIZE
	MOV	(R3)+,R2		;ADR TO STORE NEXT CHAR
					;POINT R3 AT OUTPUT COUNT
20$:	CMPB	#33,(R0)		;IF ALTMODE
	BNE	30$
	MOVB	ALTCHR,(R2)+		;OUTPUT SPECIFIED ALTMODE CHAR
	BR	40$
30$:	MOVB	(R0),(R2)		;MOVE CHAR TO OUTPUT BUFFER
	BICB	#200,(R2)+		;AND CLEAR THE PARITY BIT
					;USED TO PASS THROUGH ESCAPE SEQUENCES
40$:	INC	(R3)			;COUNT CHARS IN BUFFER
	CMPB	#15,(R0)+		;IF CR, FLUSH BUFFER
	BEQ	90$
	CMP	R2,#TTOEND		;IF BUFFER FULL, FLUSH IT
	BHI	100$
50$:	SOB	R1,20$			;GET NEXT CHAR TO OUTPUT
	MOV	R2,-(R3)		;NEXT AVAIL OUTPT LOC
	MOV	(SP)+,R3		;RESTORE SAVED REGISTERS
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	RTS	PC			;AND EXIT
;
; THE FOLLOWING CALL CHECKS FOR A QI/O ERROR AND ONLY
; RETURNS IN LINE IF IT WAS AN "OUT OF NODE POOL" ERROR
; IN THAT CASE IT WILL HAVE DONE A WAIT FOR SIGNIFICANT EVENT
;
85$:	JSR	PC,QIOERR
90$:	CMP	(R3),#1			;DON'T OUTPUT JUST A CR
	BLE	50$
100$:	MOV	(R3),TYPDPB+Q.IOPL+2	;CHAR COUNT TO DPB
	MOVB	#3,TYPDPB		;SET QIOW DIRECTIVE CODE
	DIR$	#TYPDPB			;ISSUE THE QI/O TO WRITE
	BCS	85$			;BRANCH IF ERROR
	MOVB	-(R2),TTOBUF		;ASSUMING LAST IS CR, COPY TO FRONT
	MOV	#TTOBUF,R2		;POINT TO OUTPUT BUFFER
	CLR	(R3)			;RESET COUNT
	CMPB	#15,(R2)		;DID THIS OUTPUT END IN CR?
	BNE	50$			;BRANCH IF NOT
	INC	R2			;YES, INCLUDE ANOTHER AT FRONT
	INC	(R3)			;SO THAT PROMPTS WILL START WITH CR, LF
	BR	50$			;GET MORE CHARACTERS IF ANY
	.ENDC

;
; INITIALIZE TTY OUTPUT BUFFER WITH A CR, LF PAIR
; CALLED FOR RSX11M WHEN AN INPUT LINE IS ENDED (OR REPORTEDLY
; ENDED) WITH A CR.
;
INITCR::MOV	CRLF,TTOBUF
	MOV	#2,TTOCTL+2		;SAY 2 CHARS IN BUFFER
	MOV	#TTOBUF+2,TTOCTL
	RTS	PC
;
; OVER TYPE THE COMMAND LINE IF THIS TERMINAL IS A SCOPE
;
ENTRY	OVRTYP
	TST	TTCUP			;IF CURSOR UP STRING EXISTS
	BEQ	20$
	JSR	R1,PRTINL		;UP CURSOR
	.WORD	TTCUP
	JSR	R1,PRTINL		;AND ERASE TO END OF LINE
	.WORD	TTERL
	MOV	#15,-(SP)		;SEND <CR> TO FIX TT DRIVER'S
	JSR	PC,TYPE			;HORIZONTAL POSITION
	TST	(SP)+
20$:	RTS	PC

	.SBTTL 	TTY I/O ROUTINES

	CODE$	COM

	.ENABL	LSB

ENTRY	ENABCP				;ENABLE CHECKPOINTING

	.IF	NDF,R$$STS
	BIT	#SYS11M!SYS11S,SYSTEM	;IF 11M, OR 11S
	BEQ	10$
	ENCP$S				;ENABLE CHECKPOINTING
	RTS	PC
	.ENDC

ENTRY	DSABCP			;DISABLE CHECPOINTING

	.IF	NDF,R$$STS
	BIT	#SYS11M!SYS11S,SYSTEM	;IF 11M, OR 11S
	BEQ	10$
	DSCP$S				;DISABLE CHECKPOINTING
	.ENDC

10$:	RTS	PC			;AND RETURN

	.DSABL	LSB

ENTRY	NOCTLO				;NOCTLO()

	.IF	DF,R$$STS
	.TTRST				;RESET CONTROL O EFFECT
	RTS	PC

	.IFF	
	JSR	PC,DTACH1		;DETACH, ATTACH SEQUENCE
	JMP	ATACH1			;WILL RESET CONTROL O EFFECT
	.ENDC

	.SBTTL	SUBROUTINES AND MISC STUFF

	.IF	DF,R$$STS
IOCHK::	TST	IOSTS			;CHECK FOR ANY I/O ERROR
	BNE	1$			;TOO BAD.
	RTS	PC
1$:	JMP	IOFATL			;FATAL I/O ERROR

	.IFF

QIOERR::CMP	#IE.UPN,@#$DSW		;IF OUT OF NODE POOL
	BEQ	20$			;THEN WAIT AND TRY AGAIN
	MOV	@#$DSW,IOSTS		;STORE ERR CODE IN CENTRAL PLACE
	JMP	IOFATL			;FATAL I/O ERROR
20$:
$ALERR::				;RETRY ALL AUTOLOAD ERRORS
WAITND::				;WAIT FOR NODE POOL AND RETURN
	WSIG$S				;WAIT A BIT
	RTS	PC			;AND RETURN FOR ANOTHER TRY
;
; ATTACH AND DETACH TERMINAL
;
	.ENABL	LSB
ATTACH::TSTB	TTATDT+Q.IOFN		;ATTACH ALREADY DONE?
	BNE	30$			;BRANCH IF YES
ATACH1::MOV	#IO.ATT!TF.AST,TTATDT+Q.IOFN ;SET ATTACH FUNCTION
	BR	10$
DETACH::BIT	#SYS11M!SYS11S!SYSMPL,SYSTEM ;NOP UNLESS 11M, 11S, OR MPLUS
	BEQ	30$
DTACH1::MOV	#IO.DET,TTATDT+Q.IOFN	;SET DETACH FUNCTION
10$:	DIR$	#TTATDT			;ISSUE ATTACH/DETACH
	CLRB	TTATDT+Q.IOFN+1		;NOT DOING ATT/DET
30$:	RTS	PC

	.DSABL	LSB

	.ENDC

FCSDON::MOVB	F.ERR(R0),R0		;RETURN ERROR CODE
	BLE	10$			;IT WAS ERROR
	CLR	R0			;BUT POSITIVE IS OK
10$:	RTS	PC			;RETURN

	.SBTTL	SOSCMD - CALL SOS COMMAND DISPATCHER

ENTRY	SOSCMD
	JSR	R1,$SAV5		;SET UP COMMAND ABORT STACK FRAME
	MOV	SPSAV2,-(SP)		;SAVE PREVIOUS ABORT FRAME POINTER
	MOV	#40$,-(SP)		;RETURN POINT FOR COMMAND ABORT
	MOV	SP,SPSAV2		;SET ABORT FRAME POINTER
	MOV	<9.*2>(SP),-(SP)	;COPY SOSCMD ARGUMENT
10$:	JSR	PC,SOSCM1		;CALL THE COMMAND DISPATCHER
	TST	(SP)			;IF NEGATIVE PARAMETER
	BLT	20$			;THEN RETURN TO CALLER
	CMP	#-1,R0			;OTHERWISE LOOP UNTIL -1 RETURN
	BNE	10$
20$:	CMP	(SP)+,(SP)+		;CLEAN OFF 2 WORDS
40$:	MOV	(SP)+,SPSAV2		;RESTORE SAVED ABORT FRAME POINTER
	RTS	PC			;RESTORE REGISTERS AND RETURN

ENTRY	RESETSP				;RESETSP(NEWSP)
	MOV	2(SP),SP		;JAM NEW STACK FRAME
	CLR	R0			;SET THE RETURN STATUS
	RTS	PC			;AND RETURN TO IT

	.PSECT	FTLMSG,RO,D,GBL,REL,CON

	.GLOBL	ERMSGA,ERMSGB

	PLIT	ERMSGA,</Error reading input file/>
	PLIT	ERMSGB,</Unable to PUT to output file/>

	.SBTTL	RSX TRAP HANDLING ROUTINES AND SST VECTOR

	.IF	DF,R$$STS

	DATA$	COM

SSTVEC::.WORD	IOCHK			;TRAP TO 4
	.WORD 0,0,0			
	.WORD	IOCHK			;TRAP TO 10
	.WORD	0,0,0
	.ENDC

	CODE$	COM
CTLC::
	.IF	DF,R$$STS
	INC	CTLCFL			;SET FLAG - WE SAW ONE
	MOV	R1,-(SP)		;SAVE A REG
	MOV	2(SP),R1		;GET OLD PC
	CMP	-2(R1),(PC)+		;WAS IT A .READ
	.READ				;THAT WE WERE DOING
	BNE	5$			;NO.
	CMPB	XRB+XRCI,#8.		;ON KB: CHANNEL?
	BNE	5$			;NO.
	MOV	XRB+XRLOC,R1		;BUFFER POINTER
	MOVB	#15,(R1)+		;FUDGE A LINE
	MOVB	#12,(R1)+
	MOV	#2,XRB+XRBC		;LENGTH WAS 2
5$:	MOV	(SP)+,R1		;RESTORE R1
	RTI				;AND RETURN

	.IFF
	BIC	#177600,(SP)		;ISOLATE THE UNSOLICITED CHARACTER
	CMP	#'C-100,(SP)+		;WAS IT CONTROL C?
	BNE	10$			;BRANCH IF NOT
;
; IF A SUBSEQUENT ^C IS ENTERED BEFORE THE NEXT CALL TO GCML,
; IT WILL BE INTERCEPTED BY THE COMMAND RECEIVER.
;
	TSTB	TTATDT+Q.IOFN+1		;IN THE ATT/DET WINDOW?
	BNE	8$			;YES, DON'T INTERFERE
	MOV	@#$DSW,-(SP)		;DON'T ALLOW THIS TO DESTROY
					;THE DIRECTIVE STATUS WORD
	JSR	PC,DTACH1		;DETACH THE TERMINAL
	MOV	(SP)+,@#$DSW		;RESTORE DIRECTIVE STATUS
8$:	INC	CTLCFL			;YES, SET CONTROL C FLAG
10$:	ASTX$S				;EXIT THE AST

	.ENDC

;
; CKCTLC - CHECK FOR CONTROL C AND RESET IT.
;	R0 GTR 0 IF CONTROL C WAS HIT
;	R0 LEQ 0 IF CONTROL C WAS NOT HIT
;
ENTRY	CKCTLC				;CKCTLC()
	MOV	CTLCFL,R0		;RETURN CONTOL C FLAG IN R0

	.IF	NDF,R$$STS		;RSX ONLY
	BEQ	5$			;BRANCH IF NOT SET

	.IFF	;RSTS ONLY
	MOV	#CTLC,24		;RE-ENABLE CONTROL C

	.IFTF	;RSX AND RSTS
	CLR	CTLCFL			;RESET IT
	RTS	PC			;AND RETURN

	.IFT	;RSX ONLY
5$:	BIT	#SYSIAS,SYSTEM		;IF THIS IS IAS
	BEQ	10$
	CLEF$S	#2			;TEST AND SET ^C EVENT
	MOV	@#$DSW,R0		;R0 > 0 IF ^C OCCURRED
10$:	RTS	PC
	.ENDC	;R$$STS


	.END	START
