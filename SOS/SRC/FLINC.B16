MODULE FLINC (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!


!	03	29-JUL-77	BILL MARSHALL
!
!	FIXED INSERT USING ^ OR * ON EMPTY PAGE TO PROMPT
!		WITH LINE NUMBER /START INSTEA OF 0 OR 65535.
!
!	06	27-JUL-78	P. H. LIPMAN
!
!	CORRECTED THE ABOVE FIX TO APPLY TO AN EMPTY FILE AS WELL
!
!	07	16-FEB-79	P. H. LIPMAN
!
!	CORRECT THE PROBLEM THAT AN "I." COMMAND BETWEEN LINES
!	5 AND 10 PROMPTED FOR LINES 7 AND THEN FOR 9 INSTEAD OF
!	STOPPING WITH JUST 1 LINE.  IF USING A SMALLER INCREMENT
!	THAN THE DEFAULT, THEN FORCE DEFAULT THE NUMBER OF LINES TO 1.
!

!
!	FLINC - COMPUTE THE INCREMENT FOR INSERT
!
!	THIS ROUTINE TAKES AN INSERTION POINT IN THE FILE,
!	AND EITHER AN INCREMENT OR NUMBER OF LINES, AND
!	COMPUTE THE OTHER.  IT ALSO RETURNS THE STARTING
!	AND LAST LINE NUMBERS FOR THE INSERTION.
!
!	PARAMETERS -
!		RANGE - INSERTION POINT IN R[0],R[1]
!		SLIN - NAME OF STARTING LINE VARIABLE
!		LLIN - NAME OF LAST LINE VARIABLE
!		INC - NAME OF INCREMENT VARIABLE
!		NL - NAME OF NUMBER OF LINES VARIABLE
!		   IF INC & NL BOTH ZERO (UNSPECIFIED), DEFAULT
!			IF FOR NL=1;
!
!	RETURNS -
!		IN RANGE - LINE/PAGE VALUES RETURNED FOR BOTH
!			THE PRECEEDING AND SUCEEDING LINES
!		IN SLIN - FIRST LINE NUMBER TO ASK FOR
!		IN LLIN - LAST LINE THAT CAN BE INSERTED
!		IN INC - INCREMENT TOUSE
!		IN NL - NUMBER OF LINES TO INSERT
!		VALUE RETURNED - BUFFER ADDRESS TO USE FOR
!			CALLS TO INSLINE
!
!
!	V02.02	09-JUN-76	WTM
!	V02.01	19-MAR-76	WTM


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	FIND,		! FIND LOCATION IN BUFFER
	NXTLINE,	! BUMP UP ONE LINE IN BUFFER
	DIVU;		! DO UNSIGNED DIVIDE FOR LINE NOS


GBLROUTINE (FLINC(RANGE,SLIN,LLIN,INC,NL))=
BEGIN
MAP
    RANGE: REF VECTOR[,WORD];
LOCAL
    ADR,
    ADR2,
    NINCS;
ADR=FIND(.RANGE,0);
NINCS=(IF ..NL GTRU 0 THEN ..NL ELSE 1);
IF .ADR NEQ 0 THEN
	BEGIN
	RANGE[1]=.LINLIN(.ADR);
	ADR2=NXTLINE(.ADR,1);
	.SLIN=.LINLIN(.ADR);
	IF .LINLEN(.ADR2) EQL 0 THEN
		.LLIN=.SOSFLG[MAXLN]
	ELSE
		IF .LINPAG(.ADR) NEQ .LINPAG(.ADR2) THEN
			.LLIN=.SOSFLG[MAXLN]
		ELSE
			.LLIN=.LINLIN(.ADR2)-1;
	END
ELSE
BEGIN
	IF .RANGE[1] EQL 0 OR .RANGE[1] EQL INF THEN
		RANGE[1]=.SOSFLG[STARTN];
	IF (ADR=FIND(.RANGE,-1)) EQL 0 THEN
		BEGIN
		ADR2=NXTLINE(.ADR,1);
		IF .LINLEN(.ADR2) NEQ 0 THEN
			IF .LINPAG(.ADR2) EQL .RANGE[0] THEN
				.LLIN=.LINLIN(.ADR2)-1
			ELSE
				.LLIN=.SOSFLG[MAXLN]
		ELSE
			.LLIN=.SOSFLG[MAXLN];
		.SLIN=.RANGE[1];
		NINCS=(IF .NINCS-1 GTRU 0 THEN .NINCS-1 ELSE 0);
		END
	ELSE
	!	MIDDLE OF FILE, LINE DOESN'T EXIST
		BEGIN
		.SLIN=.RANGE[1];
		ADR2=NXTLINE(.ADR,1);
		IF .LINLEN(.ADR2) EQL 0 THEN
			.LLIN=.SOSFLG[MAXLN]
		ELSE
			IF .LINPAG(.ADR) NEQ .LINPAG(.ADR2)
			    AND .LINPAG(.ADR2) NEQ .RANGE[0] THEN
				.LLIN=.SOSFLG[MAXLN]
			ELSE
				.LLIN=.LINLIN(.ADR2)-1;
		NINCS=(IF .NINCS-1 GTRU 0 THEN .NINCS-1 ELSE 0);
		ADR=0;
		END;
END;
IF ..INC EQL 0 THEN
	BEGIN
	.INC=DIVU(..LLIN-..SLIN+1,.NINCS+1);
	IF ..INC GEQU .SOSFLG[ISTEP] THEN .INC=.SOSFLG[ISTEP]
	ELSE IF ..NL EQL 0 THEN .NL=..NL+1;
	END
ELSE
	IF .ADR NEQ 0 THEN
		IF ..SLIN LSS 0 AND ..SLIN+..INC GEQ 0 OR
			..SLIN+..INC GTRU ..LLIN THEN
			.INC=0;
IF ..NL EQL 0 AND ..INC NEQ 0 THEN
	BEGIN
	.NL=1+DIVU(..LLIN-..SLIN,..INC);
	IF .ADR NEQ 0 THEN
		.NL=..NL-1;
	END;
IF .ADR NEQ 0 THEN
	.SLIN=..SLIN+..INC;
RANGE[2]=.LINPAG(.ADR2);
RANGE[3]=.LINLIN(.ADR2);
RETURN .ADR2;
END;

END ELUDOM
