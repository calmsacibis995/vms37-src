MODULE CMDN (
	IDENT = 'V03-001'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!	V03-001	PHL42050	Peter H. Lipman		8-Mar-1982
!		CMDN was not incrementing the /SAVE counter.
!

!
!	CMDN - NUMBER COMMAND
!
!
!	V02.02	09-JUN-76	WTM
!	V02.01	19-MAR-76	WTM
!


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	RDCMD,		! READ IN COMMAND
	ILLCMD,		! ILLEGAL - BAD COMMAND
	ILLRO,		! ILLEGAL - READ ONLY
	CMDABO,		! COMMAND ABORT
	SCAN,		! COMMAND SCANNER
	GETRNG,		! PARSER RANGE
	FINDR,		! FINDLINE IN RANGE
	PRVLINE,	! BACK UP ONE LINE
	NXTLINE,	! FORWARD ONE LINE
	SETDOT,		! POSITION .
	PSTRNG;		! TEST IF DONE


GBLNVROUTINE (CMDN)=
	BEGIN		! NUMBER COMMAND
	LOCAL
	    ADR,
	    ADR2;
	LOCAL
	    INC,
	    STATN,
	    PAGE,
	    DEC;
	LOCAL
	    NAOPT,
	    NPOPT;
	RDCMD();
	BADIFRO;
	NAOPT=NPOPT=0;
	IF .SCTYP EQL SCALPH THEN
		BEGIN
		IF .SCSYM[0] EQL 'A' THEN
			NAOPT=1
		ELSE
		IF .SCSYM[0] EQL 'P' THEN
			NPOPT=1
		ELSE
			BADCOMMAND;
		SCSTRT=CMDBUF+1;
		SCAN();
		END;
	IF .SCTYP EQL SCNUM THEN
		BEGIN
		INC=.SCSYM;
		IF .INC EQL 0 THEN
			CMDABO(BADSTP);
		SCAN();
		END
	ELSE
		BEGIN
		INC=.SOSFLG[ISTEP];
		END;
	IF .SCTYP NEQ SCEOF AND .SCSYM NEQ ', ' THEN
		BADCOMMAND;
	IF .SCTYP EQL SCEOF THEN
		BEGIN
		RANGE[4]=0;
		STATN=.INC;
		END

	ELSE
		BEGIN
		SCAN();
		GETRNG(RANGE);
		IF .SCTYP NEQ SCEOF AND .SCSYM NEQ ', ' THEN
			BADCOMMAND;
		IF .SCSYM EQL ', ' THEN
			BEGIN
			SCAN();
			IF .SCTYP EQL SCNUM THEN
				BEGIN
				STATN = .SCSYM;
				SCAN();
				END
			ELSE
				BADCOMMAND;
			IF .SCTYP NEQ SCEOF THEN
				BADCOMMAND;
			END
		ELSE 
			STATN=.INC;
		END;
	IF .RANGE[4] EQL 0 THEN
		BEGIN
		RANGE[0]=0;
		RANGE[1]=0;
		RANGE[2]=.PAGHIG;
		RANGE[3]=INF;
		END;
	ADR=FINDR(RANGE);
	PAGE = .LINPAG(.ADR);
	IF .NAOPT NEQ 0 THEN
		BEGIN
		STATN=.LINLIN(.ADR);
		IF .STATN+.INC LSSU .STATN OR .STATN+.INC GTRU .SOSFLG[MAXLN]
			THEN CMDABO(BADSTP);
		STATN=.STATN+.INC;
		END;
	ADR2=PRVLINE(.ADR,1);
	IF .ADR2 NEQ 0 AND .NAOPT EQL 0 THEN
		IF .PAGE EQL .LINPAG(.ADR2) THEN
			IF .LINLIN(.ADR2) GEQU .STATN THEN
				CMDABO(ORDER);
	CMDCNT=.CMDCNT+1;
	ADR = NXTLINE(.ADR2,1);
	DO	BEGIN
		LINLIN(.ADR)=.STATN;
		SETDOT(.ADR);
		IF .ADR EQL .BUFFIR THEN
			BUFPG1+2=.STATN;
		BUFCHG=.BUFCHG+1;
		ADR=NXTLINE(.ADR,1);
		IF PSTRNG(.ADR,RANGE) THEN EXITLOOP;
		IF .NAOPT NEQ 0 THEN
			STATN=.LINLIN(.ADR);
		IF .LINPAG(.ADR) GTRU .PAGE AND .NAOPT EQL 0 AND .NPOPT EQL 0 THEN
			STATN=.SOSFLG[STARTN]
		ELSE
		IF .STATN+.INC LSSU .STATN OR .STATN+.INC GTRU .SOSFLG[MAXLN]
			THEN CMDABO(BADSTP)	! OVERFLOW
		ELSE
		STATN=.STATN+.INC;
		PAGE=.LINPAG(.ADR);
		END	WHILE 1;
	IF .LINPAG(.ADR) EQL .PAGE THEN
		IF .STATN GEQU .LINLIN(.ADR) THEN
			CMDABO(ORDER);
	END;


END ELUDOM
