	.TITLE	SOSCLS - PRTFIL, RDFNM, WRTFNM
	.IDENT	/V03001/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	23-FEB-76
;
; MODIFIED BY:
;
;	V03001	PHL35743	Peter H. Lipman		2-Mar-1982
;
;		Get the entire directory path for file names by reading
;	the directory back links in RDFNM and iterating through calls
;	to RDFNM in NAMFIL.
;		Change the interface to NAMFIL adding a third parameter
;	specifying the last+1 byte of the buffer.
;		If the default directory string has been truncated look
;	up the directory string using RDFNM.
;		NAMFIL is totally rewritten to build the name backwards
;	in the supplied buffer.
;		RDFNM is only used by this module, remove the global
;	definition of the name.  It now reads the directory back link
;	into the FID field of the input FNB, and the structure level
;	into N.NEXT+7 destroying 8 bytes at N.NEXT.
;
;	020705	PHL0705		Peter H. Lipman		21-Nov-1980
;
;		Add the ability to read and write the file protection
;	so that the file protection can be preserved when producing
;	a new version of an existing file.
;
	.MCALL	FDOF$L,FCSBT$,QIOSY$
	FDOF$L
	FCSBT$
	QIOSY$
	.MCALL	ALUN$S,DIR$,WTSE$S,QIO$,NMBLK$

	DATA$	CLS
;
; QIOSYM MESSAGE FILE NAME
;
QIOMSG::NMBLK$	QIOSYM,MSG


	.PSECT	DIRSEC	RW,D
;
; EXTEND THIS SECTION FOR VAX/VMS
;
DIRSTR::
	.BYTE	-1,0			;MINIMUM DIRECTORY STRING

	.PSECT	DIRSED	RW,D

DIREND::				;LAST + 1 BYTE OF DIR STRING

	CODE$	CLS

;
; CALL GET ERROR MESSAGE AND RETURN
;
GERRM1::
	JSR	PC,.GERRM
	ROL	-(SP)			;SAVE CARRY BIT
	JMP	GERRM2

	.SBTTL	PRTFIL - PRINT THE NAME OF AN OPEN FILE
;
; PRTFIL(FDB ADR, FLAGS)
;	2(SP) = FLAGS
;		BIT 0 (1) - PRINT (NO CHANGES)
;		BIT 1 (2) - ENCLOSE NAME IN BRACKETS [...]
;		BIT 2 (4) - DO NOT RETURN CARRIAGE AFTER NAME
;	4(SP) = FDB ADDRESS
;
ENTRY	PRTFIL
	CLR	-(SP)		; GET A SCRATCH WORD ON STACK
	BITB	4(SP),#2	; BRACKETS WANTED?
	BEQ	10$		; NO
	MOV	#'[,(SP)
	JSR	PC,TYPE		; TYPE LEADING BRACKET
10$:	MOV	6(SP),-(SP)	; FDB POINTER
	MOV	TTOCTL,-(SP)	; DIRECT TO TTY OUTPUT BUFFER
	MOV	#TTOEND,-(SP)	; ADR OF END OF BUFFER
	JSR	PC,NAMFIL	; GENERATE FILE NAME
	ADD	R0,TTOCTL	; COMPUTE NEW TTY OUTPUT BUFFER
	ADD	R0,TTOCTL+2	; POINTERS
	ADD	#6,SP		; CLEAN OFF 3 PARAM WORDS
	BITB	4(SP),#2	; CLOSING BRACKET?
	BEQ	20$		; NO
	MOV	#'],(SP)
	JSR	PC,TYPE
20$:	BIT	4(SP),#1	; PRINT (NO CHANGES)?
	BEQ	30$		; NO
	MOV	#NOCHG,(SP)
	JSR	PC,PRINT
30$:	BIT	4(SP),#4	; RETURN CARRIAGE?
	BNE	40$		; NO IF SET
	JSR	PC,TYPECR
40$:	TST	(SP)+
	RTS	PC		; RETURN TO CALLER

;
; NAMFIL( FDB-ADR, OUTBUF-FIRST-ADR, OUTBUF-LAST+1-ADR)
;
;	GENERATES A NAME FOR FILE WITH THE CORRESPONDING FDB,
;	AND PUTS IT INTO A STRING STARTING AT THE DESIGNATED
;	LOCATION. THE LENGTH OF THE STRING GENERATED IS RETURNED
;	AS THE VALUE OF THE ROUTINE (IN R0)
;
ENTRY	NAMFIL			;MAIN ENTRY POINT
	JSR	R1,$SAV5		;SAVE REGS
;
; FORM THE FILE NAME BACKWARDS IN THE BUFFER
;
	MOV	16(SP),R0		;ADDRESS OF LAST + 1 BYTE OF BUF
	MOV	22(SP),R5		;FDB ADDRESS
;
; START WITH FILE VERSION NUMBER IF PRESENT
;
	.IF	NDF,R$$STS		;NO VERSION NUMBER FOR RSTS
	MOV	F.FNB+N.FVER(R5),R1	;GET THE FILE VERSION NUMBER
	BEQ	20$			;BRANCH IF NONE
	JSR	PC,CBVER		;CONVERT VERSION TO ASCII
					;OCTAL OR DECIMAL ACCORDING TO SYSTEM
	MOVB	#';,-(R0)		;PUT IN VERSION DELIMITER
	.ENDC	;R$$STS

;
; GET THE FILE TYPE
;
20$:	MOV	R5,R3			;POINT TO FILE TYPE
	ADD	#F.FNB+N.FTYP,R3	;
	JSR	PC,C5TA1		;CONVERT ONE WORD OF RAD50 TO ASCII
	TST	-(R3)			;NULL TYPE?
	BEQ	25$			;BRANCH IF YES, NO DOT
	MOVB	#'.,-(R0)		;FILE TYPE DELIMITER
;
; GET THE FILE NAME
;
25$:	SUB	#6,R3			;BACK OVER FILE NAME

	.IF	DF,R$$STS
	MOV	#6,R4			;6 CHAR FILE NAMES FOR RSTS
	.IFF
	MOV	#9.,R4			;9 CHAR FILE NAMES FOR RSX/VMS
	.ENDC	;R$$STS

	JSR	PC,C5TA			;CONVERT RAD50 TO ASCII
;
; FORM DIRECTORY STRING
;
	CMP	R0,16(SP)		;IF NO FILE SPEC,
	BEQ	150$			;THEN NO DIRECTORY EITHER

	.IF	NDF,R$$STS		;NOT FOR RSTS
	BIT	#NB.DIR,F.FNB+N.STAT(R5) ;EXPLICIT DIRECTORY GIVEN?
	BNE	80$			;BRANCH IF YES
;
; USE DEFAULT DIRECTORY STRING
;
	MOV	#DIRSTR,R2		;USE COPY OF DEFAULT DIR STRING
	MOVB	(R2)+,R1		;UNLESS IT HASN'T BEEN INITIALIZED
	BGE	50$			;NEGATIVE IF RSX
40$:	JSR	PC,.RDFDR		;READ DEFAULT DIRECTORY
50$:	TST	R1			;TEST FOR NULL STRING
	BLE	80$			;BRANCH IF NO DIRECTORY STRING
;
; R1 = SIZE OF DEFAULT DIRECTORY STRING
; R2 = ADDRESS OF DEFAULT DIRECTORY STRING
;
	ADD	R1,R2			;FORM ADR OF LAST + 1 BYTE
	MOV	R0,R3			;USE SCRATCH COPY OF BUF PTR
70$:	MOVB	-(R2),-(R3)		;MOVE DEFAULT DIR STRING INTO BUFFER
	CMP	20(SP),R3		;OVERFLOW OFF FRONT OF BUFFER?
	BHIS	80$			;BRANCH IF YES, GET WHAT FITS
	SOB	R1,70$
	MOV	R3,R0			;MAKE BUF PTR CURRENT
	BR	150$
;
; MUST RECOVER DIRECTORY NAME USING DIRECTORY ID
;

	ASSUME	N.DVNM EQ N.DID+6
	ASSUME	N.UNIT EQ N.DVNM+2
80$:	MOV	#TMPFNB+N.UNIT+2,R1	;USE TEMP FILE NAME BLOCK
	MOV	R5,R3			;POINT BEYOND UNIT IN FDB
	ADD	#F.FNB+N.UNIT+2,R3	;
	MOV	-(R3),-(R1)		;UNIT NUMBER
	MOV	-(R3),-(R1)		;DEVICE NAME
	MOV	#TMPFNB+N.FID+6,R1	;POINT BEYOND FILE ID
	MOV	-(R3),-(R1)		;3RD WORD OF DID TO FID
	MOV	-(R3),-(R1)		;2ND WORD OF DID TO FID
	MOV	-(R3),-(R1)		;1ST WORD OF DID TO FID
					;R1 = TMPFNB ADDRESS
	MOVB	#'],-(R0)		;PUT IN CLOSE BRACKET
100$:	JSR	PC,RDFNM		;READ FILE NAME FOR THIS DIR
					;AND BACK LINK FOR PREVIOUS ONE
					;AND STRUCTURE LEVEL
	BCS	120$			;BRANCH IF ERROR
	MOV	#TMPFNB+N.FNAM,R3	;ADR OF FILE NAME IN RAD50
	MOV	#9.,R4			;CONVERT UP TO 9 CHARS OF DIR NAME
	MOV	20(SP),R1		;STARTING ADR OF BUFFER
	ADD	#12.,R1			;ADJUST FOR THIS DIR NAME, [?. + 9 CHARS
	CMP	R0,R1			;SEE IF THIS DIR NAME WILL FIT
	BLOS	120$			;BRANCH IF NOT, QUIT
	JSR	PC,C5TA			;CONVERT RAD50 TO ASCII
	BIT	#SYSCME,SYSTEM		;IF NOT VMS,
	BEQ	130$			;THEN ONLY ONE DIRECTORY LEVEL
	MOV	#TMPFNB,R1		;RECOVER ADR OF TEMP FNB
	TSTB	5(R1)			;HIGH BITS OF FID NON-ZERO
	BNE	110$			;THEN NOT MFD OR ZERO
	CMP	(R1),#4			;IF MFD,
	BEQ	130$			;THEN NO MORE DIR LEVELS
	BHI	110$			;IF BIGGER, THEN GET NEXT DIR LEVEL
					;LESS THAN 4, ASSUME 0
	DECB	N.NEXT+7(R1)		;IF STRUCTURE LEVEL 1
	BEQ	130$			;THEN NO MULTI-LEVEL DIRECTORIES
	BR	115$			;OTHERWISE INDICATE UNKNOWN DIR NAME
110$:	MOVB	#'.,-(R0)		;PUT IN DIR LEVEL DELIMITER
	BR	100$
115$:	MOVB	#'.,-(R0)		;
120$:	MOVB	#'?,-(R0)		;INDICATE INCOMPLETE DIRECTORY NAME
	BR	140$
;
; LAST DIRECTORY NAME INSERTED, CHECK FOR [GGG,MMM] FORMAT
;
130$:	CMPB	#'],6(R0)		;EXACTLY 6 CHARS OF DIR NAME?
	BNE	140$			;BRANCH IF NOT
	TST	R4			;ALL OCTAL DIGITS?
	BNE	140$			;BRANCH IF C5TA SAID NO
	ADD	#3,R0			;POSITION TO FIRST CHAR OF MEMBER
	JSR	PC,FIXPPN		;TAKE OFF LEAD ZEROES
	MOVB	#',,-(R0)		;PUT IN COMMA
	MOV	#TMPFNB+N.FNAM,R3	;GROUP NUMBER IN RAD50
	JSR	PC,C5TA1		;RECONVERT TO ASCII
	JSR	PC,FIXPPN		;TAKE OFF LEAD ZEROES
;
; DIRECTORY STRING COMPLETE, PUT IN OPEN BRACKET
;
140$:	MOVB	#'[,-(R0)		;STORE OPEN BRACKET

	.IFF				;RSTS ONLY
	MOV	F.FNB+N.DID(R5),R1	;WAS A UIC SUPPLIED?
	BEQ	150$			;IF NOT, DON'T PRINT [0,0]
	MOVB	#'],-(R0)		;PUT IN TRAILING BRACKET
	BIC	#^C<377>,R1		;ISOLATE PROG NUMBER
	JSR	PC,CBDEC		;CONVERT BINARY TO DECIMAL STRING
	MOVB	#',,-(R0)		;PUT IN THE COMMA
	CLR	R1			;ZERO THE HIGH BYTE
	BISB	F.FNB+N.DID+1(R5),R1	;AND FETCH PROJ NUMBER
	JSR	PC,CBDEC		;CONVERT BINARY TO DECIMAL STRING
	MOVB	#'[,-(R0)		;PUT IN LEADING BRACKET
	.ENDC	;R$$STS
;
; FORM DEVICE NAME
;
150$:	MOV	F.FNB+N.DVNM(R5),R3	;GET THE 2 BYTES OF DEVICE NAME
	BEQ	200$			;NONE IF 0

	.IF	NDF,R$$STS		;NOT FOR RSTS
	MOV	R0,R1			;CALCULATE SPACE LEFT
	SUB	20(SP),R1		;IN NAME BUFFER
	CMP	R1,#6			;ENOUGH FOR DDCUU:
	BLT	200$			;BRANCH IF NOT, SKIP DEVICE
	.ENDC	;R$$STS

	MOVB	#':,-(R0)		;PUT IN DEVICE TERMINATOR
	CLR	R1			;FORM ONE BYTE
	BISB	F.FNB+N.UNIT(R5),R1	;UNIT NUMBER

	.IF	DF,R$$STS		;RSTS ONLY
	TSTB	F.FNB+N.UNIT+1(R5)	;EXPLICIT UNIT?
	BNE	170$			;BRANCH IF NOT
	CMP	R3,#"SY			;IF SYSTEM DEVICE
	BEQ	170$			;NEVER A UNIT
	.ENDC	;R$$STS

	CLR	R4			;ASSUME NO CONTROLLER LETTER
	BIT	#SYSCME,SYSTEM		;IF VMS
	BEQ	160$			;
	MOV	R1,R4			;FORM CONTROLLER LETTER FOR VMS

	.IF	DF,R$$EIS
	ASH	#-4,R4			;HIGH 4 BITS
	.IFF
	ASR	R4
	ASR	R4
	ASR	R4
	ASR	R4
	.ENDC	;R$$EIS

	ADD	#'A,R4			;FORM CONTROLLER LETTER
	BIC	#^C<17>,R1		;CLEAR OUT CONTROLLER PORTION
160$:	JSR	PC,CBDEC		;CONVERT UNIT TO DECIMAL STRING
	MOVB	R4,-(R0)		;PUT IN CONTROLLER LETTER
	BNE	170$			;BRANCH IF PRESENT
	INC	R0			;OTHERWISE, REMOVE IT
170$:	MOVB	F.FNB+N.DVNM+1(R5),-(R0) ;PUT IN DEVICE NAME
	MOVB	R3,-(R0)		;
;
; NOW MOVE STRING UP TO FRONT OF BUFFER
;
200$:	MOV	R0,R1			;SOURCE ADR IN R1
	MOV	16(SP),R0		;CALCULATE SIZE IN R0
	SUB	R1,R0			;
	BEQ	220$			;BRANCH IF STRING IS EMPTY
	MOV	20(SP),R2		;DESTINATION ADR = FIRST ADR IN BUF
	MOV	R0,R3			;SCRATCH SIZE IN R3
210$:	MOVB	(R1)+,(R2)+		;MOVE THE NAME TO THE FRONT
	SOB	R3,210$			;OF THE BUFFER
220$:	RTS	PC

;
; CONVERT RAD50 TO ASCII AND SUPRESS BLANKS
;
; INPUTS:
;
;	R0 = ADDRESS OF END + 1 OF BUFFER - STORING BACKWARDS
;	R3 = POINTER TO FIRST RAD50 WORD TO CONVERT
;	R4 = NUMBER OF BYTES OF ASCII TO BE GENERATED
;	     3 * NUMBER OF RAD50 WORDS TO BE CONVERTED
;
; OUTPUTS:
;
;	R0 = UPDATED BUFFER POINTER
;	R3 = ADR OF LAST RAD50 WORD CONVERTED
;	R4 = 0 IF ALL CHARACTER IN NAME ARE OCTAL DIGITS
;	R1,R2 SCRATCH
;
C5TA1:	MOV	#3,R4			;ONE WORD = 3 BYTES OF ASCII
C5TA:	MOV	R4,-(SP)		;SAVE SIZE OF STRING
	SUB	R4,R0			;MAKE ROOM FOR CONVERTED STRING
20$:	MOV	(R3)+,R1		;GET NEXT RAD50 WORD
	JSR	PC,$C5TA		;CONVERT TO ASCII
	SUB	#3,R4			;3 CHARACTERS DONE, ANY MORE?
	BGT	20$			;BRANCH IF YES, DO THE NEXT WORD
;
; NOTE R4 = 0
;
	MOV	(SP)+,R2		;RECOVER SIZE OF STRING
	MOV	R0,R1			;SOURCE AND DESTINATION THE SAME
30$:	MOVB	-(R1),-(R0)		;MOVE NEXT BYTE FROM SRC TO DST
	CMPB	(R0),#'7		;OCTAL DIGIT OR BLANK?
	BGT	50$			;BRANCH IF NOT
	CMPB	#' ,(R0)		;BLANK?
	BNE	60$			;BRANCH IF OCTAL DIGIT
40$:	INC	R0			;DROP BLANKS
	BR	60$
50$:	INC	R4			;COUNT NON-OCTAL DIGITS
60$:	SOB	R2,30$			;LOOP THROUGH ALL CHARACTERS
	RTS	PC
;
; CONVERT BINARY TO DECIMAL, VERSION TO DECIMAL OR OCTAL
;
; INPUTS:
;
;	R0 = ADDRESS TO STORE STRING BACKWARDS
;	R1 = BINARY VALUE TO CONVERT
;
; OUTPUTS:
;
;	R0 UPDATED POINTER
;	R1 SCRATCH
;
	.ENABL	LSB

	.IF	NDF,R$$STS		;NO VERSION NUMBERS FOR RSTS
CBVER:	MOV	R1,-(SP)		;STACK VALUE TO CONVERT
	BIT	#SYSCME,SYSTEM		;CONVERT VERSION NUMBER
	BNE	10$			;DECIMAL FOR VMS, OCTAL FOR RSX
	MOV	#8.,-(SP)		;CONVERT BINARY TO OCTAL
	BR	20$
	.ENDC	;R$$STS

CBDEC:	MOV	R1,-(SP)		;STACK BINARY VALUE TO CONVERT
10$:	MOV	#10.,-(SP)		;CONVERT BINARY TO DECIMAL
20$:	MOV	R0,R1			;USE BUFFER POINTER IN R1
30$:	JSR	PC,MODU			;GET REMAINDER TO R0
	ADD	#'0,R0			;FORM ASCII DIGIT
	MOVB	R0,-(R1)		;PUT IT IN BUFFER
	JSR	PC,DIVU			;GET QUOTIENT
	MOV	R0,2(SP)		;STORE NEW DIVIDEND
	BNE	30$			;BRANCH IF MORE DIGITS
	MOV	R1,R0			;RESTORE UPDATED BUFFER POINTER
	CMP	(SP)+,(SP)+
	RTS	PC
	.DSABL	LSB
;
; FIXPPN - STRIP OFF LEAD ZEROES FROM PROJECT OR PROGRAMMER NUMBER
;
; INPUTS:
;
;	R0 = POINTER TO FIRST OF 3 DIGITS OF PROJECT OR PROGRAMMER NUMBER
;	     0, ONE, OR TWO LEAD ZEROES ARE TO BE STRIPPED.
;
; OUTPUTS:
;
;	R0 = POINTER TO FIRST CHARACTER OF PROJECT OR PROGRAMMER NUMBER
;
FIXPPN:	CMPB	(R0)+,#'0		;LEAD CHAR A ZERO?
	BNE	20$			;BRANCH IF NO, DO NOT STRIP IT OFF
	CMPB	(R0)+,#'0		;NEXT ONE ZERO TOO?
	BEQ	30$			;BRANCH IF YES, STRIPPED 2
20$:	DEC	R0			;DON'T STRIP THIS CHARACTER
30$:	RTS	PC


	.WORD	NOCHGL+1/2
NOCHG:	.ASCII	/   (NO CHANGES)/
NOCHGL	=	.-NOCHG
	.EVEN


	.SBTTL	READ/WRITE ATTRIBUTES FROM/TO HEADER

	.IF	NDF,R$$STS

	DATA$	CLS
;
RWATT:	QIO$	,7,1,,IOSTS,,<,ATTLST>
ATTLST:	.WORD	0,0			;FIRST ATTRIBUTE
	.WORD	0,0			;SECOND ATTRIBUTE - DIR BACK LINK
	.BYTE	-10.,8.			;READ HEADER THROUGH STRUCTURE LEVEL
	.WORD	0
	.WORD	0			;END OF ATTRIBUTE LIST

	CODE$	CLS
;
; FIX FILE PROTECTION AFTER FINAL CLOSE.  IF THE FILE PROTECTION OF
; THE INPUT FILE WAS BEING PRESERVED AND IT DID NOT INCLUDE ALL
; ACCESS TO THE OWNER, THEN IT IS TIME TO FIX THE PROTECTION AND
; RESTRICT THE OWNER'S ACCESS.
;
ENTRY	FIXPRO			; FIXPRO (FDB)
	MOV	R1,-(SP)		;SAVE A REGISTER
	MOV	FILPRO,R1		;CURRENT VALUE OF FILE PROTECTION
	CMP	R1,#-1			;IF NO ACCESS TO ANYONE
	BEQ	20$			;THEN REALLY USING DEFAULT PROTECTION
	BIT	#360,R1			;ALL PRIVILEGE TO OWNER?
	BEQ	20$			;BRANCH IF YES
	MOV	4(SP),R1		;FDB ADDRESS
	ADD	#F.FNB,R1		;FNB ADDRESS
	JSR	PC,WRTPRO		;FIX THE FILE PROTECTION
	BCC	20$			;BRANCH IF OK
	MOVB	IOSTS,R0		;ERROR STATUS IF ERROR
	BR	30$
20$:	CLR	R0			;SUCCESS STATUS
30$:	MOV	(SP)+,R1		;RECOVER SAVED REGISTER
	RTS	PC
;
; READ FILE NAME FROM FILE HEADER AND FOR VMS ONLY, DO THE FOLLOWING:
;	READ THE DIRECTORY BACK LINK INTO THE FID FIELD
;	READ ONE BYTE STRUCTURE LEVEL INTO N.NEXT+7, SCRATCH 8 BYTES AT N.NEXT
; WRITE FILE NAME TO FILE HEADER
; READ FILE PROTECTION FROM FILE HEADER
; WRITE FILE PROTECTION TO FILE HEADER
;
; INPUTS:
;	R1=FNB TO WRITE FROM OR READ INTO.
;		WHETHER READING OR WRITING, THE FILE ID, DEVICE, AND UNIT
;		ARE REQUIRED.
; OUTPUTS:
;	C=0 IF OK, C=1 IF ERROR, IOSTS = ERROR CODE
;	ALL REGISTERS PRESERVED
;
	.ENABL	LSB
RDPRO::	MOV	#<<-HA.PRO&377>+<256.*2>>,-(SP) ;READ FILE PROTECTION
	MOV	#IO.RAT,-(SP)		;READ ATTRIBUTES FUNCTION
	BR	RWPRO			;JOIN COMMON READ/WRITE PROTECTION
WRTPRO::MOV	#<HA.PRO+<256.*2>>,-(SP) ;WRITE FILE PROTECTION
	MOV	#IO.WAT,-(SP)		;WRITE ATTRIBUTES FUNCTION
RWPRO:	MOV	#FILPRO,ATTLST+2	;ADDRESS TO READ/WRITE PROTECTION
	CLR	-(SP)			;ONLY ONE ATTRIBUTE FOR RWPRO
	BR	10$
RDFNM:	MOV	#<<-HA.NAM&377>+<256.*10.>>,-(SP) ;READ FILE NAME
	MOV	#IO.RAT,-(SP)		;READ ATTRIBUTES FUNCTION
	CLR	-(SP)			;ONLY ONE ATTRIBUTE FOR RSX
	BIT	#SYSCME,SYSTEM		;IF VMS
	BEQ	RWFNM
	MOV	#<<-28.&377>+<256.*6>>,(SP) ;READ DIRECTORY BACKLINK TOO
	MOV	R1,ATTLST+6		;ADR TO READ DIR BACK LINK
	MOV	R1,ATTLST+12		;SET ADR FOR 8 BYTES OF FILE HEADER
	ADD	#N.NEXT,ATTLST+12	;STORE OVER N.NEXT AND DID.
					;STRUCTURE LEVEL WILL BE N.NEXT+7
	BR	RWFNM			;JOIN COMMON READ/WRITE FILE NAME
WRTFNM::MOV	#<HA.NAM+<256.*10.>>,-(SP) ;WRITE FILE NAME
	MOV	#IO.WAT,-(SP)		;WRITE ATTRIBUTES FUNCTION
	CLR	-(SP)			;ONLY ONE ATTRIBUTE FOR WRTFNM
RWFNM:	MOV	R1,ATTLST+2		;ADDRESS TO READ/WRITE NAME
	ADD	#N.FNAM,ATTLST+2
10$:	MOV	R1,RWATT+Q.IOPL		;ADDRESS OF FILE ID
	MOV	(SP)+,ATTLST+4		;2ND ATTRIBUTE OR 0
	MOV	(SP)+,RWATT+Q.IOFN	;READ/WRITE ATTRIBUTES FUNCTION CODE
	MOV	(SP)+,ATTLST		;ATTRIBUTE CODE AND SIZE
	ALUN$S	#7,N.DVNM(R1),N.UNIT(R1)
	BCS	34$
20$:	DIR$	#RWATT
	BCC	30$
	JSR	PC,QIOERR
	BR	20$			;TRY AGAIN, SINCE OUT OF NODES
30$:	WTSE$S	#1
	BCC	36$
34$:	MOV	@#$DSW,IOSTS		;SAVE DIRECTIVE STATUS ERROR
36$:	TSTB	IOSTS
	BPL	40$
	SEC
40$:	RTS	PC
	.DSABL	LSB
	.ENDC
;
	.END
