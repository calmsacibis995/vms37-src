	.TITLE	SOSSW - SWITCH PROCESSING
	.IDENT	/V03000/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	23-FEB-76
;
; MODIFIED BY:
;
;	020702	PHL0702		Peter H. Lipman		21-May-1980
;
;			Implement =TERM
;
	.MCALL	CSI$
	CSI$
	.MCALL	CSI$1,CSI$2,CCML$

	.SBTTL	SWITCH AND GIVE COMMAND ROUTINES

	CODE$	SW

ENTRY	SWITCH
	JSR	R1,$SAV3
	MOV	SOSFLG,R3		;GET COPY OF FLAGS SO THAT
					;CERTAIN CHANGES CAN BE TESTED
	JSR	PC,LODSWT		;LOAD THE SWITCH TABLE
	MOV	TTICTL,R1		;NEXT INPUT LOCATION
	MOV	TTICTL+2,R2		;LENGTH LEFT IN BUF
	MOVB	#'/,-(R1)		;FUDGE A / IN BUF
	CLR	TTICTL+2		;FORCE READ ON NEXT LISTEN
	CLR	GIVWRD			;/HELP AND =HELP ARE EQUIVALENT
	CLR	HELPAG			;INIT HELP STARTING PAGE
	CLR	OPTNAM			;CLEAR ANY OLD VALUE FOR /OPT:X
					;OR ANY OLD VALUE FOR /TERM:X
	CLR	ALTSWT			;NO /ALT, /MAT, OR /TERM SEEN YET
	MOV	#"$?,ALTSTR		;DEFAULT CHARS FOR /ALT AND /MAT
	CSI$1	#CSIBLK,R1,R2		;SCAN COMMAND STRING
	BCS	SWBAD			;SOMETHING VERY BAD
	BITB	#CS.EQU!CS.MOR!CS.DVF!CS.DIF!CS.NMF,C.STAT(R0)
	BNE	SWBAD			;ONLY SWITCHES AND VALUES
	MOV	#SWTAB,C.SWAD(R0)	;DISALLOW READONLY SWITCH
	CSI$2	R0,OUTPUT		;PROCESS SWITCHES
	BCS	40$			;INVALID SWITCH FOUND, RESTORE SWITCHES
	MOV	SOSFLG,R2		;GET NEW FLAGS
	XOR	R3,R2			;R2 = CHANGED BITS
	BIT	#RONLY,R2		;WAS RONLY SET (ONLY POSSIBLE CHANGE)
	BEQ	12$			;BRANCH IF NOT
	CMP	FILUSE,#2		;ONLY LEGAL IF SINGLE FILE CASE
	BNE	40$			;BRANCH IF CANNOT SET RONLY
	TST	CMDCNT			;ALSO, NO COMMANDS THAT CHANGED FILE
	BNE	40$			;BRANCH IF CANNOT SET RONLY
	JSR	PC,SETSY0		;SET DEFAULT DEV, DIR TO SY0
	MOV	#FILEOUT,-(SP)		;OK TO SET RONLY
	JSR	PC,CLSDEL		;MUST CLOSE AND DELETE FILEOUT
	TST	(SP)+			;CLEAN OFF THE PARAMETER
	CLR	BUF+BUFCHG		;NO BUFFER CHANGES MADE
	INC	FILUSE			;DO NOT BACKUP THE FILE
					;FILUSE MUST HAVE BEEN =2, NOW =3
12$:	BIT	#NOLINS,R2		;TRY TO CHANGE NOLINS?
	BEQ	15$			;BRANCH IF NOT
	BIT	#NOLINS,R3		;MUST NOT CLEAR NOLINS
	BNE	40$			;BRANCH IF TRIED TO
15$:	MOV	GIVWRD,R2		;REALLY A "=" COMMAND?
	BNE	GCALL			;BRANCH IF YES
	BIT	#NOOPT,C.MKW1+CSIBLK	;/OPTION?
	BEQ	20$			;BRANCH IF NO
	MOV	#INITSW,R1		;"SWITCH.INI" CODE AVAILABLE?
	BEQ	20$			;BRANCH IF NOT
	CCML$	#GCMLB			;CLOSE CMD FILE, FOR BUFFER SPACE
	JSR	PC,(R1)			;GO READ SWITCH.INI

20$:	JSR	PC,SWSET		;FINISH SETTING SWITCHES
30$:	RTS	PC			;RETURN ALL OK

40$:	MOV	R3,SOSFLG		;RESTORE PREVIOUS FLAGS
SWBAD:	MOV	#4,-(SP)		;CODE FOR BAD SWITCH NAME
	JSR	PC,CMDABO		;ABORT THE COMMAND

ENTRY	GIVE
	JSR	R1,$SAV3		;SAVE SOME REGS
	JSR	PC,LODSWT		;LOAD THE SWITCH TABLE
	MOV	TTICTL,R1		;POINTER TO INPUT TEXT
	MOV	TTICTL+2,R2		;LENGTH OF INPUT
	MOVB	#'/,-(R1)		;FUDGE A /
	CLR	TTICTL+2		;NEXT LISTEN IS READ
	MOV	SOSFLG,R3		;SAVE CURRENT FLAG
	CSI$1	#CSIBLK,R1,R2		;SCAN IT FIRST
	BCS	SWBAD
	CLR	CSIBLK+C.MKW1		;CLEAR SWITCH WORDS
	CLR	SOSFLG
	CLR	GIVWRD
	CLR	GIVW2
	CLR	ALTSWT			;NO /ALT OR /MAT SEEN YET
	CSI$2	#CSIBLK,OUTPUT,#GIVTBL	;PROCESS AS SWITCHES
	MOV	SOSFLG,CSIBLK+C.MKW2	;SAVE FLAG CHANGES
	MOV	R3,SOSFLG		;RESTORE FLAGS FIRST
	BCS	SWBAD			;BAD SWITCH
;	CHECK FOR A ROUTINE TO CALL
	MOV	GIVWRD,R2		;SECOND FLAG WORD
	BIS	ALTSWT,R2		;/ALT IS 1, /MAT IS 2
					;OTHERS START AT 3,
					;ONLY ONE CAN BE REQUESTED
	BEQ	GVALUE			;WAS NOT ONE OF THEM
GCALL:	ASL	R2
	CMP	R2,#GIVT2L		;WITHIN RANGE
	BGT	SWBAD			;NO
	MOV	GIVT2-2(R2),R2		;ADDRESS OF ROUTINE
	JSR	PC,(R2)
	RTS	PC			;DONE
;
;	CHECK FOR VALUE TO DISPLAY
;
GVALUE:	MOV	GIVW2,R2		;FIRST FLAG WORD
	BEQ	20$			;NOT ONE OF THEM
	CMP	R2,#SOSFLL		;WITHIN RANGE?
	BGT	SWBAD			;NO
	MOV	#GIVM1,-(SP)		;START OF MSG
	JSR	PC,PRINT
	ASL	R2			;INDEX SOSFLG VALUES
	MOV	SOSFLG(R2),(SP)		;GET VALUE
	MOV	#1,-(SP)		;AT LEAST ONE DIGIT
	JSR	PC,PRINTN		;TELL VALUE
	JSR	PC,TYPECR		;THEN RETURN LINE
	CMP	(SP)+,(SP)+
	RTS	PC
;
;	CHECK SOSFLG BIT VALUE
;
20$:	COM	R3			;THIS
	BIC	R3,CSIBLK+C.MKW1	;  SHOULD
	CMP	CSIBLK+C.MKW1,CSIBLK+C.MKW2; TEST
	BEQ	25$			;      SWITCH
	MOV	#GIVOFF,-(SP)		;SWITCH IS OFF
	BR	PRTRET
25$:	MOV	#GIVON,-(SP)		;SWITCH IS ON
	BR	PRTRET

	.ENABL	LSB
GIVALT:	MOVB	ALTCHR,-(SP)		;GET ALTMODE CHARACTER IF ANY
	BR	10$
GIVMAT:	MOVB	MATCHR,-(SP)		;GET MATCH CHARACTER IF ANY
10$:	BNE	30$			;BRANCH IF CHARACTER ENABLED
	MOV	#GIVM2,(SP)		;SAY NOT ENABLED
PRTRET:	JSR	PC,PRINTC		;PRINT MSG ON TOP OF STACK
	BR	50$
30$:	MOV	#GIVM1,-(SP)		;"VALUE IS: "
	JSR	PC,PRINT
	TST	(SP)+
	JSR	PC,TYPE			;TYPE THE CHARACTER
	BR	40$

GIVID::	MOV	#MSGIN,-(SP)		;TYPE THE SOS IDENT MESSAGE
	JSR	PC,PRINT

	.IF	DF,R$$STS
	MOV	#FIRQB+FQFUN,R0		;THEN SYSTEM NAME
	MOVB	#ERRFQ,(R0)+
	CLRB	(R0)+
	CALFIP
	MOV	#FIRQB+FQERNO,(SP)	;SYSTEM NAME MESSAGE
	JSR	PC,PRINTZ
	.ENDC

40$:	JSR	PC,TYPECR		;RETURN THE CARRIAGE
50$:	TST	(SP)+
	RTS	PC

GIVHLP:	MOV	HELPAG,-(SP)		;STARTING PAGE NUMBER
	JSR	PC,CMDHDO		;OPEN AND TYPE THE HELP FILE
	BR	50$			;CLEAN UP AND EXIT

GIVTRM:	MOV	#TRMNAM,-(SP)		;ADDRESS OF TERMINAL NAME STRING
	JSR	PC,PRINTZ		;PRINT ASCIZ STRING
	BR	40$

	.DSABL	LSB

	.WORD	GIVM1L+1/2
GIVM1:	.ASCII	/Value is: /
GIVM1L	=	.-GIVM1
	.EVEN
	.WORD	GIVM2L+1/2
GIVM2:	.ASCII	/Character is disabled/
GIVM2L	=	.-GIVM2
	.EVEN

	.WORD	GIVOFL+1/2
GIVOFF:	.ASCII	/Switch is off/
GIVOFL	=	.-GIVOFF
	.EVEN

	.WORD	GIVONL+1/2
GIVON:	.ASCII	/Switch is on/
GIVONL	=	.-GIVON
	.EVEN

	GLOBAL	<GIVDOT,GERROR,GIVLOC,GIVSTR,GIVBIG,GIVNAM>

; SPECIAL COMMAND DISPATCH TABLE
GIVT2:	.WORD	GIVALT
	.WORD	GIVMAT
	.WORD	GIVDOT
	.WORD	GIVTRM
	.WORD	GIVLOC
	.WORD	GIVSTR
	.WORD	GIVBIG
	.WORD	GIVNAM
	.WORD	GIVID
	.WORD	GIVHLP
	.WORD	GERROR

	.IF	DF,R$$DBG
	.WORD	GIVEVT			;***** GIVE EVENT BUFFER (DEBUG)
	.ENDC

GIVT2L	=	.-GIVT2		;LENGTH OF TABLE


	.END
