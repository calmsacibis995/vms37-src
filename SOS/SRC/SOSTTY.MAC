	.TITLE	SOSTTY - TERMINAL I/O - LISTEN
	.IDENT	/V03000/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	19-AUG-76
;
; MODIFIED BY
;
;	020705	PHL34845	Peter H. Lipman		30-Jan-1981
;
;		VMS top level command files become an infinte source
;	of EOF's.  After too many in a row are seen turn them into <^C>.
;	This eliminates infinite input loops.
;
;	020705	PHL33878	Peter H. Lipman		12-Nov-1980
;
;		Implement new LISTEN flag to force input to the
;	terminal even if input is normally coming from an indirect
;	file.  This allows SUBSTITUTE Decide mode to get its input
;	from the terminal.
;
	.MCALL	FDOF$L,FCSBT$,QIOSY$,GCMLD$
	FDOF$L
	FCSBT$
	QIOSY$
	GCMLD$

	G.CDEP=G.ERR+10.		;CURRENT DEPTH FOR EOF RECOVERY
	G.DFNB=G.ERR+26			;DEFAULT NAME BLOCK FOR EOF RECOVERY

	.MCALL	QIOW$,DIR$

	DATA$	TTY

	.IF	NDF,R$$STS
TTYDPB:	QIOW$	IO.RAL!IO.RNE,TIOLUN,7,,IOSTS,,<TTIBUF,1,,,,>
	.ENDC


	.SBTTL	TTY I/O ROUTINES - LISTEN
;	
;	FLAG WORD PASSED TO LISTEN ROUTINE
;
;	BIT VALUE	MEANING
;	  1		IF OFF, READ NO ECHO, PASS ALL
;	  2		RAISE LOWER CASE TO UPPER
;	  4		INDIRECT COMMAND OK
;	 10		READ WITH SPECIAL TERMINATORS
;	 20		DO NOT ABORT ON ^C, JUST RETURN ^C AS DATA.
;	 40		CALLED FROM INSERT MODE, DO NOT QUEUE ANOTHER READ
;			IF FIRST ENDED WITH COUNT EXHAUSTED.
;			INSTEAD RETURN A 177 CHARACTER.
;			THIS WILL TRIGGER ALTER INSERT MODE.
;	100		EVEN IF INPUT IS COMING FROM A COMMAND FILE
;			SATISFY THIS REQUEST FROM THE TERMINAL.
;			ONLY IMPLEMENTED FOR NON-ECHOING CASE.
;

	CODE$	TTY

	.ENABL	LSB

ENTRY	LISTEN
	MOV	2(SP),R0		;COPY ECHO FLAG
	BIT	#NOLOW,SOSFLG		;ALLOWING LOWER CASE?
	BEQ	5$			;BRANCH IF YES
	BIS	#2,R0			;NO, RAISE LOWER TO UPPER
5$:	MOV	R1,-(SP)		;SAVE SOME REGS
	MOV	R2,-(SP)		;
	MOV	R0,-(SP)		;SAVE THE ECHO FLAG
10$:	MOV	#TTICTL,R1		;CHANNEL ENTRY FOR TTY
	TST	2(R1)			;ANYTHING THERE ALREADY
	BGT	66$			;YES.  USE IT
	MOVB	#-1,NOECHO		;ASSUME ALL CHARACTERS ECHOED
	BIT	#1,(SP)			;SHOULD WE ECHO NEW CHAR
	BNE	80$			;YES.  DO NORMAL READ
	BIT	#100,(SP)		;FORCING TO THE TERMINAL?
	BNE	12$			;BRANCH IF YES
	BITB	#FD.TTY,GCMLB+F.RCTL	;IF COMMANDS FROM A FILE
	BEQ	80$			;THEN DO NORMAL READ
12$:
;
; VAX/VMS MAKES TOP LEVEL COMMAND FILE (SYS$INPUT) LOOK LIKE A TERMINAL
; EXCEPT THAT A "GET TERMINAL SUPPORT" FOR IT RETURNS A ZERO.  IF
; RSTFLG IS 0 AND THIS IS THE TOP LEVEL COMMAND FILE, THEN READ ALL
; COMMANDS A LINE AT A TIME.
;
	.IF	DF,R$$STS		;RSTS ONLY
	.IFF				;RSX ONLY
	TSTB	TOPTTY			;IF TOP LEVEL COMMAND FILE IS NOT A TTY
	BNE	15$
	TSTB	GCMLB+G.CDEP		;AND CURRENT DEPTH IS LEQ 0
	BLE	80$			;THEN READ LINE AT A TIME
15$:

	.IFT				;RSTS ONLY
	CLRB	NOECHO			;NO CHARACTERS HAVE BEEN ECHOED
	.TTDDT				;SWITCH INTO DDT SUBMODE
	.TTNCH				;AND DO NOT ECHO
	MOV	#XRB,R2			;POINT TO XRB
	MOV	TTOCTL+2,(R2)		;PROMPT STRING LENGTH
	BEQ	30$			;NOTHING TO PROMPT
	TST	(R2)+
	MOV	TTOCTL+2,(R2)+		;XRBC AND XRLEN
	MOV	#TTOBUF,(R2)+
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+			;XRCI, XRBLK,XRTIME
	.WRITE
	MOV	#TTOBUF,TTOCTL
	CLR	TTOCTL+2
	MOV	#XRB,R2			;RESET XRB POINTER
30$:	MOV	#2,(R2)+		;XRLEN=200
	CLR	(R2)+			;XRBC=0
	MOV	#TTIBUF,(R1)		;RESET BUFFER ADDRESS
	MOV	(R1),(R2)+		;XRPTR
	CLR	(R2)+			;XRCI
	CLR	(R2)+			;XRBLK
	CLR	(R2)+			;XRTIME
	.READ
	.TTECH				;TURN ON ECHOING
	TST	CTLCFL			;WAS A CTL-C HIT
	BEQ	34$
	CLR	CTLCFL			;YES, TURN IT OFF
	JMP	190$			;AND REPORT IT
34$:	CMPB	IOSTS,#EOF		;WAS A CTL-Z HIT?
	BNE	35$			;NO
	MOV	#1,2(R1)		;YES, COUNT = 1
	MOVB	#32,@(R1)		;STORE CONTROL Z
	JMP	170$
35$:	JSR	PC,IOCHK
	MOV	XRB+XRBC,R2		;GUESS AT LENGTH GOOD
	CMPB	TTIBUF,#015		;UNLESS CR CHARACTER
	BNE	37$
	DEC	R2			;STRIP LF WITH IT
37$:
	MOV	R2,2(R1)		;RESET CURRENT COUNT

	.IFF				;RSX ONLY
	MOV	TTOCTL+2,TYPDPB+Q.IOPL+2 ;SET SIZE OF PROMPT IF ANY
	BEQ	50$			;BRANCH IF NO PROMPT
40$:	MOVB	#1,TYPDPB		;SET QIO (NO WAIT) DIRECTIVE CODE
	DIR$	#TYPDPB			;QUEUE THE PROMPT
	BCC	45$			;BRANCH IF OK
	JSR	PC,QIOERR		;HANDLE "OUT OF NODES"
	BR	40$			;TRY AGAIN, ALREADY WAITED
45$:	CLR	TTOCTL+2		;NOTE THAT BUFFER IS EMPTY
	MOV	#TTOBUF,TTOCTL
;
; (SP) = FLAGS WORD
;
50$:	MOV	#IO.RST,TTYDPB+Q.IOFN	;ASSUME READ WITH SPECIAL TERM
	MOV	#TTISIZ,TTYDPB+Q.IOPL+2 ;OF 80. BYTES
	BIT	#10,(SP)		;READ WITH SPECIAL TERMINATORS?
	BNE	52$			;BRANCH IF IT IS
	BISB	RAISLC,(SP)		;RAISE LC IF DESIRED
	MOV	#IO.RAL!IO.RNE,TTYDPB+Q.IOFN ;READ NOECHO PASS ALL
	MOV	#1,TTYDPB+Q.IOPL+2	;OF 1 BYTE
	CLRB	NOECHO			;CHARACTER WILL NOT HAVE BEEN ECHOED
52$:	DIR$	#TTYDPB			;ISSUE THE QIO AND WAIT
	BCC	60$			;BRANCH IF ALL IS WELL
	JSR	PC,QIOERR		;IF OUT OF NODES, WAIT
	BR	50$			;AND RETRY
60$:	TSTB	IOSTS			;ANY ERROR?
	BLE	68$			;BRANCH IF YES, TREAT LIKE CONTROL C ABORT
	MOV	IOSTS+2,R2		;GET NO. OF BYTES READ
					;NOT INCLUDING TERMINATOR IF ANY
	MOV	#TTIBUF,(R1)+		;RESET POINTER TO BUFFER
	MOV	R2,(R1)			;AND COUNT OF CHARACTERS
	ADD	-(R1),R2		;POINT AT END OF INPUT BUFFER
	MOVB	IOSTS+1,(R2)		;STORE TERMINATOR IF ANY
	BEQ	62$			;BRANCH IF NONE
	INC	2(R1)			;COUNT THE TERMINATOR
	INC	R2			;POINT AT END OF INPUT BUFFER
;
; THE TERMINATOR NEEDS TO BE ECHOED BY THE CALLER
;
	NEGB	NOECHO			;IF IT WAS -1, MAKE IT 1
					;ALL BUT LAST CHARACTER WERE ECHOED
62$:	MOVB	-(R2),R0		;LAST DATA BYTE
	BIC	#177600,R0		;CLEAR OUT PARITY BIT
	CMPB	#'C-100,R0		;CHECK FOR CONTROL C
	BEQ	68$			;BRANCH IF CONTROL C SEEN
	SUB	#175,R0			;OLD "TTY" ALTMODE?
	BLT	74$			;BRANCH IF NEITHER ONE
	BITB	#2,RAISLC		;TERM DRIVER CONVERTING LC TO UC?
	BEQ	74$			;BRANCH IF NOT
	DEC	R0			;IF 175 OR 176, THEN OLD ALTMODE
	BGT	74$			;BRANCH IF NOT AN OLD ALTMODE
	MOVB	#33,(R2)		;REPLACE OLD ALTMODE WITH CORRECT CODE

	.IFTF				;RSX AND RSTS BOTH
66$:	JMP	170$			;GO GET CHARACTER

	.IFF				;RSX ONLY
68$:	JMP	190$			;CONTROL C SEEN
74$:	JMP	168$			;PROCESS NORMAL CHARACTER
	.ENDC
80$:
	.IF	NDF,R$$STS
	CLRB	GCMLB+F.RATT		;IN ORDER TO TELL IF OPEN HAPPENS IN GCML
	JSR	PC,ATTACH		;IN CASE WE DETACHED SOMEWHERE
	.ENDC

	BIT	#4,(SP)			;IND CMD FILE OK?
	BEQ	90$			;NO.
	BISB	#GE.IND!GE.COM,GCMLB+G.MODE

	.IF	DF,R$$STS
	.TTRST				;RESET ^O EFFECTS
	.ENDC

	BR	100$
90$:	BICB	#GE.IND!GE.COM,GCMLB+G.MODE
100$:	MOV	#TTOCTL,R0		;ADR OF OUTPUT BUF ADR AND SIZE
	MOV	#TTOBUF,(R0)		;RESET STARTING BUF ADR
	MOV	(R0)+,GCMLB+G.PSDS+2	;SET PROMPT ADDRESS
	MOV	(R0),GCMLB+G.PSDS	;AND SIZE
	BNE	110$			;BRANCH IF NOT NULL PROMPT
	INC	GCMLB+G.PSDS		;1 BYTE OF NULL REQUIRED
	CLRB	@-2(R0)			;STORE NULL BYTE
110$:	CLR	(R0)			;RESET OUTPUT BUFFER SIZE
	MOV	#GCMLB,R0
	JMP	LISTN1			;ISSUE GCML CALL FROM ROOT
LISTN2::
	MOV	R1,R2			;ADR OF INPUT DESCRIPTOR

	.IF	DF,R$$STS
	BITB	#FD.TTY,GCMLB+F.RCTL	;INPUT FROM TERMINAL?
	BEQ	114$			;BRANCH IF NOT
	MOV	GCMLB+F.BDB,R0		;GET I/O STATUS BLOCK ADDRESS
	BEQ	112$			;BRANCH IF NO IOSB
	MOV	2(R0),GCMLB+G.CMLD	;SET CORRECT COMMAND LINE SIZE
112$:	MOV	GCMLB+F.NREC,R0		;AND ADDRESS NO MATTER HOW BIG THE LINE
114$:
	.IFF	;RSX ONLY
	MOV	GCMLB+G.CMLD+2,R0	;GET INPUT BUFFER ADDRESS
	.ENDC

	MOV	R0,(R2)+		;STORE INPUT BUFFER ADDRESS
	ROR	(SP)+			;RECOVER CARRY FROM GCML
	BCC	150$			;BRANCH IF GOOD COMMAND LINE
	CMPB	#GE.EOF,GCMLB+G.ERR	;END OF FILE?
	BNE	120$			;BRANCH IF NOT
	DECB	GCMLB+G.CDEP		;FORCE CURRENT DEPTH TO INIT VALUE
	CLR	GCMLB+G.DFNB+N.DVNM	;LIKEWISE FOR DEFAULT DEVICE
	CLR	GCMLB+G.DFNB+N.UNIT	;AND DEFAULT UNIT
	CLR	(R2)			;ZERO BYTE COUNT (INC LATER)
	MOVB	#'Z-100,(R0)		;STORE A CONTROL Z
	BIT	#4,(SP)			;IS THIS A COMMAND LINE?

	.IF	DF,R$$STS		;RSTS ONLY
	BEQ	165$			;BRANCH IF NOT

	.IFF	;RSX ONLY
	BNE	118$			;BRANCH IF IT IS
	TSTB	TOPTTY			;IF TOP LEVEL COMMAND IS NOT A TTY
	BNE	165$			;BRANCH IF IT IS A TTY
	DECB	EOFCNT			;TOO MANY ADJACENT EOF'S
					;TOP LEVEL VMS CMD FILE
					;IS AN INFINITE SOURCE OF EOF'S
	BGT	165$			;BRANCH IF NOT TOO MANY
	BLT	116$			;BRANCH IF EVEN <^C> FAILED
	JMP	190$			;YES, TURN INTO <^C>
116$:	JMP	EXIT			;JUST KILL IT, NOTHING ELSE WILL WORK
118$:
	.ENDC

	MOV	#<15*400+'E>,(R0)+	;FORM AN "E" COMMAND
	INC	(R2)			;COUNT ONE OF THE CHARACTERS
	BR	161$
120$:
	.IF	DF,R$$STS
	BITB	#FD.TTY,GCMLB+F.RCTL	;ERROR FROM TERMINAL?
	BEQ	130$			;BRANCH IF NOT
	CMPB	GCMLB+F.ERR,#IE.RBG	;IF RECORD WAS TOO BIG
	BNE	130$
	CMPB	@GCMLB+F.BDB,#IS.SUC	;BUT IT WAS ACTUALLY SUCCESSFUL
	BNE	130$			
	MOV	GCMLB+G.CMLD,(R2)	;THEN SET THE BYTE COUNT TRANSFERRED
	CMP	@GCMLB+F.BDB,#IS.SUC	;IF ANY NON-ZERO TERMINATOR
	BEQ	152$			;THEN CHECK IT
	BR	168$			;OTHERWISE DON'T INCLUDE IT

	.IFF	;RSX ONLY
	CMPB	#IE.RBG,GCMLB+G.ERR	;THIS ERROR RETURNED FOR CMD LINE
					;ENDED BY BYTE COUNT EXHAUSTED
	BNE	130$			;BRANCH IF OTHER ERROR
	MOV	GCMLB+F.BDB,R0		;GET I/O STATUS BLOCK ADR
	CMP	#IS.SUC,(R0)+		;SUCCESSFUL COMPLETION?
	BNE	130$			;BRANCH IF NOT
	MOV	(R0),(R2)		;GET SIZE OF DATA READ
	BIT	#40,(SP)		;INSERT MODE?
	BEQ	168$			;BRANCH IF NOT
	MOV	(R2),R0			;YES, CALCULATE ADR OF END OF BUFFER
	ADD	(R1),R0			;ADD ADDRESS TO BYTE COUNT
	MOVB	#177,(R0)		;RUB WILL TRIGGER ALTER INSERT MODE
	BR	165$			;AND GO PROCESS THE LINE

	.IFTF	;RSX AND RSTS
130$:	JMP	LISTN3			;REPORT OTHER GCML ERROR
	.ENDC				;WILL RETURN TO LISTN4 BELOW
;
; COMMAND LINE WAS SUCCESSFULLY READ
;
150$:	MOV	GCMLB+G.CMLD,(R2)	;LEN OF COMMAND
152$:	ADD	(R2),R0			;ADR OF LAST+1 CHARACTER

	MOVB	#15,(R0)		;ASSUME CR TERMINATOR FOR INDIRECT FILES
	.IF	NDF,R$$STS		; RSX ONLY
	TSTB	GCMLB+F.RATT		;IF GCML DETACH MAY HAVE OCCURRED
	BEQ	155$
	JSR	PC,ATACH1		;REATTACH THE TERMINAL
155$:
	.ENDC

	BITB	#FD.TTY,GCMLB+F.RCTL	;IF NOT TTY, TERMINATOR AT END OF RECORD
	BEQ	161$
	MOV	@GCMLB+F.BDB,-(SP)	;1(SP) GETS TERMINATOR BYTE
	SWAB	(SP)
	MOVB	(SP)+,(R0)		;STORE TERMINATOR AT END OF BUFFER
	CMPB	#33,(R0)		;ALTMODE?

	.IF	DF,R$$STS
	BEQ	165$
	CMPB	#12,(R0)		;LF TERMINATOR?
	BNE	160$			;BRANCH IF NOT
	JSR	PC,INITCR		;OUTPUT CR,LF
	BR	165$

	.IFF	;RSX ONLY
	BNE	160$			;BRANCH IF NOT
	MOV	#TTOCTL,R0		;ADDRESS OF OUT BUF ADR AND SIZE
	MOVB	ALTECO,@(R0)+		;ECHO "$" IF NECESSARY
	BEQ	165$			;BRANCH IF NO ECHO REQUIRED
	INC	(R0)			;COUNT THE CHARACTER
	INC	-(R0)			;ADJUST BUFFER POINTER
	BR	165$
	.ENDC	;R$$STS

160$:	CMPB	#15,(R0)		;CR TERMINATOR?
	BNE	165$			;BRANCH IF NOT
161$:	JSR	PC,INITCR		;SET UP TO ECHO CR, LF
	BIT	#4,(SP)			;COMMAND LINE?
	BEQ	165$			;BRANCH IF NOT
	TST	(R2)			;EMPTY LINE, ENDED WITH CR?
	BEQ	162$			;BRANCH IF YES, RETURN LF
	CMPB	#12,-(R0)		;LAST CHAR = LF
	BEQ	168$			;BRANCH IF YES, DON'T ADD CR
	BR	165$			;NO, APPEND THE CR
162$:	MOVB	#12,(R0)		;RETURN LF FOR EMPTY CMD LINE ENDED WITH CR
165$:	INC	(R2)			;ADD IN LINE TERMINATOR
168$:	JSR	PC,CKCTLC		;CHECK FOR CONTROL C
	TST	R0			;CONTROL C HERE?
	BGT	190$			;YES.  KILL CMD
170$:	MOVB	@(R1)+,R0		;COPY NEXT CHAR IN BUFFER
	DEC	(R1)			;DECR LEN LEFT

	.IF	NDF,R$$STS
	BGT	175$			;BRANCH IF NOT LAST CHARACTER
;
; NOECHO = -1 IF ALL CHARACTERS INCLUDING THE LAST WERE ECHOED BY DRIVER
;	 = +1 IF ALL BUT THE LAST CHARACTER WERE ECHOED BY THE DRIVER
;	 = 0 IF CALLING ROUTINE IS SUPPOSED TO ECHO THE CHARACTER RETURNED
;
	TSTB	NOECHO			;IF TERMINATOR NOT ALREADY ECHOED
	BLT	175$
	CLRB	NOECHO			;ECHO TERMINATOR IN ALTER INSERT
					;EVEN IF READING WITH SPECIAL TERM
175$:
	.ENDC

	INC	-(R1)			;INC POINTER
	BIC	#-177-1,R0		;CLEAR PARITY BIT
	BNE	178$			;BRANCH IF NOT NULL
	JMP	10$			;IGNORE NULLS
178$:	BIT	#2,(SP)			;UPPER CASE?
	BEQ	180$			;NO.  LEAVE AS IS
	CMP	R0,#'A+40		;LOWER 
	BLT	180$			;CASE 
	CMP	R0,#'Z+40		;LETTER
	BGT	180$			;??
	BIC	#40,R0			;CAPITALIZE IT
180$:
	BIT	#1,(SP)			; ALTER MODE??
	BEQ	200$			;SKIP BELL TEST IF ALTER
	CMP	R0,#7			;IS CHAR A BELL?
	BNE	200$			;NO.
	CMPB	@(R1),#7		;DOUBLE BELL?
	BNE	200$			;NO.
190$:
	.IF	NDF,R$$STS		;RSX
	BIT	#SYSCME,SYSTEM		;IF VAX/VMS CME
	BNE	195$			;THEN NO CRLF REQUIRED
	JSR	PC,INITCR		;CR, LF MSG IN RESPONSE TO ^C
	.ENDC
LISTN4::
195$:	CLR	2(R1)			;KILL REST OF LINE
	BIT	#20,(SP)		; LISTEN TO ^C TRAPS??
	BNE	198$			; NO.. PASS THEM TO CALLER
	MOV	#-1,-(SP)		;NO MESSAGE
	JSR	PC,CMDABO		;ABORT THE COMMAND
198$:	MOV	#3,R0			;RETURN CONTROL C
200$:	TST	(SP)+			; DUMP FLAG PARAMETER
	MOV	(SP)+,R2		;RESTORE
	MOV	(SP)+,R1		;THE SAVED REGS
	RTS	PC			;AND RETURN

	.DSABL	LSB

	.END
