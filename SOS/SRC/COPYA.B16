MODULE COPYA (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!
!	04	10-SEP-77	PETER H. LIPMAN
!
!	REMOVED LOGICAL UNIT NUMBER FROM OPEN SUBROUTINE CALL
!	CHANGED OPEN CALL TO OPN1ST TO ALLOW FOR STREAM MODE FILE
!	ADDED CALL TO BUFINIT AFTER OPN1ST SINCE ALLOCATING
!		THE STREAM BUFFER MIGHT SHRINK THE TEXT BUFFER.
!

!
!	COPYA - PHASE 1 OF COPY/TRANSFER COMMAND
!
!	THIS ROUTINE PARSES QHE FIRST PART OF THE COMMAND
!	AND SETS UP THE ALTERNATE INPUT FILE AND BUFFER.
!	ON EXIT, COPTRN WILL CALL THE COMMAND HANDLER IF /S
!	WAS GIVEN, OTHERWISE, COPYB WILL BE CALLED TO
!	COMPLETE THE COPY
!
!

!	V02.02	09-JUN-76	WTM
!	V02.01	21-MAR-76	WTM


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	GETDOT,		! FIND CURRENT LOC
	GETLNP,		! PARSE LINE/PAGE
	FLINC,		! FIND PREV/NEXT LIN
	COPYXX,		! SETUP OLD FILE STATE
	COPDEF,		! FOR TRANSFER
	COPERR,		! ERRORS IN COPY
	ILLRO,		! ILLEGAL - READ ONLY
	OPN1ST,		! OPEN THE COPY FILE, POSSIBLY STREAM MODE
	BUFINIT,	! INIT THE TEXT BUFFER
	GETLINE,	! READ IN FIRST LINE
	FIND,		! LOCATE LINE IN BUFFER
	SCANFILE,	! PARSE FILE NAME
	SCAN,		! COMMAND SCANNER
	RDCMD,		! INPUT A COMMAND LINE
	SETDOT;		! LOCATE CURRENT POSITION

EXTERNAL
    FILECOP,				! FDB FOR COPY INPUT
    SLIN,				! COPY GLOBALS
    LLIN,		
    COPHIG,
    COPFLG,
    COPLPG: VECTOR[5];		! RANGE SAVE AREA

GBLROUTINE (COPYA(CMD))=

BEGIN
LOCAL
    INC,
    NL,
    ADR;
OWN
    LAFT: VECTOR[2];
RDCMD();
BADIFRO;
INC=NL=0;
GETDOT(COPLPG);
GETLNP(COPLPG);
FLINC(COPLPG,SLIN,LLIN,INC,NL);
ADR=FIND(COPLPG,-1);
IF .ADR NEQ 0 THEN
	IF .LINPAG(.ADR) EQL .COPLPG[0] THEN
		COPLPG[4]=0
	ELSE
		COPLPG[4]=1
ELSE
	COPLPG[4]=1;			!  VALUE 1 SAYS DEST AT START OF A PAGE
IF .ADR EQL 0 THEN
	LAFT[0]=LAFT[1]=0
ELSE
	BEGIN
	LAFT[0]=.LINPAG(.ADR);
	LAFT[1]=.LINLIN(.ADR);
	END;
COPYXX(LAFT);
IF .SCSYM EQL ', ' THEN
	BEGIN
	COPDEF(FILECOP,.BUFILE);
	SCAN();
	END
ELSE
	BEGIN
	LOCAL
	    PTR1,
	    PTR2,
	    CHR,
	    I;
	LOCAL
	    BKT;
	IF .SCSYM NEQ '= ' AND .SCSYM NEQ '_ ' AND
		.SCSYM NEQ '< ' THEN COPERR(BADCMD);
	I=SCANFILE(FILECOP);
	IF .I NEQ 0 THEN COPERR(BADFIL);
	SCAN(); IF .SCSYM EQL ', ' THEN SCAN();
	.CMD='C';
	END;
IF OPN1ST(FILECOP) NEQ 0 THEN COPERR(BADFIL);
BUFINIT();
COPFLG=.SOSFLG;
SOSFLG=(.SOSFLG OR RONLY) AND NOT (NOLINS OR BASIC);
PAGHIG=INF;
GETLINE(FILECOP);
IF .SCSYM EQL '/ ' AND
	(.(.SCSTRT)<0,8> EQL 'S' OR .(.SCSTRT)<0,8> EQL 'C') THEN
	BEGIN
	SETDOT(0);
	RETURN 1;
	END
ELSE
	RETURN 0
END;

END ELUDOM
