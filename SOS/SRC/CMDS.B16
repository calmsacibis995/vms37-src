MODULE CMDS (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!



!	03	29-JUL-77	BILL MARSHALL
!
!	REMOVED OVERLAY KLUDGES - CHXLIN
!	ADDED CALLS TO GET TEMP BUFFER SPACE FOR NEW LINE BUILD
!		INSTEAD OF USING 'NEWLIN' (TO SQUEEZE OVERLAY)
!	ADDED CODE TO SUPPORT NEGATE SWITCH IN FIND COMMAND
!
!	05	24-FEB-78	PETER H. LIPMAN
!
!		FIXED THE PROBLEM THAT SUBSTITUTE COMMANDS WERE NOT
!	BEING COUNTED AGAINST THE SAVE COUNT.
!
!	07	6-SEP-78	PETER H. LIPMAN
!
!	IF ACTUALLY DID A SUBSTITUTION AND PRINTED THE LINE,
!		RECORD THAT "." WAS JUST PRINTED.
!

!
!	CMDS - SUBSTITUTE COMMAND
!
!
!	V02.02	09-JUN-76	WTM
!	V02.01	19-MAR-76	WTM
!


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	GETSTR,		! READ IN STRINGS
	CMDABO,		! ABORT THE COMMAND
	ILLCMD,		! BAD COMMAND ERROR
	ILLRO,		! ILLEGAL FOR READ ONLY FILE
	RDCMD,		! READ IN COMMAND
	GETDOT,		! FIND CURRENT SPOT
	GETRNG,		! PARSER RANGE SPEC
	FINDR,		! FIND LINE IN RNGE
	SCAN,		! COMMAND SCANNER
	SEARCH,		! STRING FINDER
	PRINT,		! PRINT MESSAGE
	LISTEN,		! GET CONFORMTION
	TYPE,		! TYPE BCK CONFIRM
	CHLINE,		! UPDATE LINE IN BUFFER
	NXTLINE,	! POINT TO NEXT LINE
	PRVLINE,	! BACK UP ONE LINE
	CMDSDO,		! DO A SUBSTITUTION
	ALTER,		! ALTER THE NEW LINE
	GETBUF,		! GET BUFFER SPACE FOR NEW LINE
	RLSBUF,		! RELEASE BUFFER
	PSTRNG;		! TELL WHEN DONE

EXTERNAL
    S1STRNG: BYTE,			! STRINGS TO FIND
    S2STRNG: BYTE;			! TO SUB IN

EXTERNAL
    SRANGE: VECTOR[,WORD],		! RANGE FOR SUB
    SRRET: VECTOR[,WORD],		! SEARCH RETURN AREA
    S1STRLST: VECTOR[,WORD],		! SUBSTITUTE 'FIND' STRING LIST
    S2STRLST: VECTOR[,WORD],		! SUBSTITUTE 'SUB' STRING LIST
    S1STRSIZ,				! MAX LENGTHS OF SUB
    S2STRSIZ,				! STRINGS
    CMDSQN,				! SEQUENCE NUMBER FOR THE CURRENT COMMAND
    PRTSQN,				! SEQUENCE NUMBER OF LAST CMD TO PRINT "."
    BUFPTR;				! PTR TO NEW LINE BUILD AREA

GBLNVROUTINE (CMDS)=
	BEGIN		!  SUBSTITUTE COMMAND
	LOCAL
	    ADR,
	    I,
	    J,
	    TEMPR: VECTOR[2];
	OWN
	    SINGLE,
	    FDSWT;

	SOSFLG[SUBS]=0;
	SINGLE=1;
	FDSWT=0;
	S1STRLST+2 = S1STRNG;
	I=GETSTR(0,6,S1STRLST+2,S1STRNG,S1STRSIZ,PLIT ('S*'));
	IF .I GTR 0 THEN
		BEGIN
		LOCAL
		    K;
		INCR J FROM 0 TO .I DO
			BEGIN
			S2STRLST+2+2*.J = S2STRNG;
			K=GETSTR(.J,.I,S2STRLST+2,S2STRNG,S2STRSIZ,PLIT ('S*'));
			IF .K GTR 0 THEN EXITLOOP ELSE
				BEGIN
				S2STRLST+2+2*.J=0;
				IF .K EQL 0 THEN
					BEGIN
					K = .K + 1;
					EXITLOOP;
					END
					ELSE PRINT (PLIT ('S*'));
				END;
			END;
		S1STRLST=.I;
		S2STRLST=.K;
		END;
	BADIFRO;
	IF .I GEQ 0 THEN
		BEGIN
		RDCMD();
		SOSFLG[FSFLG]=.SOSFLG[FSFLG] AND NOT
			(SNOPT OR SDOPT OR SEOPT);
		IF (.SOSFLG AND DECIDE) NEQ 0 THEN
			SOSFLG[FSFLG]=.SOSFLG[FSFLG] OR SDOPT;
		IF (.SOSFLG AND EXACT) NEQ 0 THEN
			SOSFLG[FSFLG]=.SOSFLG[FSFLG] OR SEOPT;
		IF .SCTYP EQL SCEOF OR .SCSYM EQL ', ' THEN
			BEGIN
			GETDOT(SRANGE);
			SRANGE[2]=.PAGHIG;
			SRANGE[3]=INF;
			END
		ELSE
			BEGIN
			SINGLE=0;
			GETRNG(SRANGE);
			END;
		WHILE .SCSYM EQL ', ' DO
			BEGIN
			SCAN();
			IF .SCSYM EQL 'N ' THEN SOSFLG[FSFLG]=.SOSFLG[FSFLG] OR SNOPT ELSE
			IF .SCSYM EQL 'D ' THEN SOSFLG[FSFLG]=.SOSFLG[FSFLG] OR SDOPT ELSE
			IF .SCSYM EQL 'E ' THEN SOSFLG[FSFLG]=.SOSFLG[FSFLG] OR SEOPT ELSE
			BADCOMMAND;
			SCAN();
			END;
		IF .SCTYP NEQ SCEOF THEN BADCOMMAND;
		END
	ELSE
		BEGIN
		GETDOT(TEMPR);
		J=0;
		IF (.SRANGE[0] EQL .TEMPR[0]) AND (.SRANGE[1] EQL .TEMPR[1])
			THEN J=.J+1;
		SRANGE[0]=.TEMPR[0];
		SRANGE[1]=.TEMPR[1]+.J;
		END;
	IF .S1STRLST EQL 0 OR .S2STRLST EQL 0 THEN
		CMDABO(BADISS);
	ADR=FINDR(SRANGE);
	SOSFLG[FSFLG]=.SOSFLG[FSFLG] AND NOT (EMATCH OR NOMATCH);
	IF (.SOSFLG[FSFLG] AND SEOPT) NEQ 0 THEN
		SOSFLG[FSFLG]=.SOSFLG[FSFLG] OR EMATCH;
	GETBUF(512);
	DO	BEGIN
		LOCAL
		    J,
		    ANS,
		    SUBCNT;
		J=SEARCH(.ADR,0,S1STRLST,SRANGE,SRRET);
		IF .J LSS 0 THEN CMDABO(BADISS) ELSE
		IF .J EQL 0 THEN
			IF .FDSWT THEN EXITLOOP
				ELSE CMDABO(BADSNF);
		ADR=.SRRET[0];
		NXTLINE(.ADR,1);
		ANS=CMDSDO(.J,.ADR,SUBCNT);
		IF .ANS EQL -2 THEN EXITLOOP;
		IF .ANS EQL -3 THEN
			ADR=ALTER(PRVLINE(CHLINE(.BUFPTR,.ADR),1),0,0,0)
		ELSE
		IF .ANS EQL 0 THEN
			ADR=CHLINE(.BUFPTR,.ADR)
		ELSE
			IF .ADR NEQ -1 THEN
				ADR=NXTLINE(.ADR,1);
		IF .ANS NEQ -1 THEN SOSFLG[SUBS]=.SOSFLG[SUBS]+.SUBCNT;
		FDSWT=1;
		END UNTIL (PSTRNG(.ADR,SRANGE) OR .SINGLE);
	IF .SOSFLG[SUBS] NEQ 0 THEN
		BEGIN
		CMDCNT=.CMDCNT+1;
		IF (.SOSFLG[FSFLG] AND (SNOPT OR SDOPT)) EQL 0
			THEN PRTSQN=.CMDSQN;
		END;
	RLSBUF();
	END;


END ELUDOM
