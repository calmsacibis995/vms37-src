MODULE COPYBB (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!	020705	PHL37691	Peter H. Lipman		14-May-1981
!		If a page mark is automatically inserted because there
!		is not enough room to fit the lines, the range of lines
!		to be deleted (if T command) can end up with the wrong
!		page number and not get deleted.  The check to see if 
!		the page number in the range needed to be adjusted
!		did not correctly check that the range to be deleted
!		was after the insert point.  The adjustment in page
!		number should only be done in that case.
!
!		If this is a transfer command and the insert point is
!		totally contained in the range to be moved and then
!		deleted, then treat it as a bad range.  At its most
!		functional, this is a renumber command, an expensive one
!		at that.
!

!
!	COPYB - PHASE 2 COPY/TRANSFER
!
!	THIS PHASE ACTUALLY DOES THE COPY OR
!	TRANSFER, AFTER THE RANGE OF LINES IS KNOWN.
!

!	V02.02	09-JUN-76	WTM
!	V02.01	21-MAR-76	WTM


REQUIRE 'SRC$:SOSREQ.B16';


EXROUTINE
	FIND,		! FIND PLACE IN FILE
	PSTRNG,		! SEE WH
	NXTLINE,	! UP ONE LINE
	DIVU,		! UNSIGNED DIVISION ROUTINE
	COPERR,		! COPY ERROR ROUTINE
	PRINT,		! PRINT PLIT MESSAGE
	PRINTN,		! PRINT NUMBER
	SCAN,		! COMMAND SCANNER
	COPYXY,		! SETUP BUFFER AREAS
	COPYXZ,		! CLEAN UP BUFFERS
	PRVLINE;	! BACK UP ONE LINE

EXTERNAL
    SLIN,				! COPY GLOBAL VARIABLES
    LLIN,
    COPFLG,
    COPHIG,
    COPERF,				! ERROR RECOVERY FLAG
    COPLPG: VECTOR[5];
EXTERNAL
    EXTFLG: BYTE;			! SET THIS FLAG IF OUTPUT FILE MAY NEED TO BE EXTENDED

GBLNVROUTINE (COPYBB(STADR,CMD))=
BEGIN

LOCAL
    ADR,
    INC1,
    INC2,
    NL1,
    NL2,
    SINC1,
    SINC2,
    PGMOD1,
    PGMOD2,
    DIFPAG;

ADR=.STADR;
IF PSTRNG(.ADR,RANGE) THEN COPERR(BADNLR);
IF .SCSYM NEQ ', ' AND .SCTYP NEQ SCEOF THEN COPERR(BADCMD);
NL1=NL2=SINC1=SINC2=0;
PGMOD1=PGMOD2=1;
!
! DIFPAG = 0 IF DESTINATION OF COPY IS NOT AT THE END OF A PAGE
!	 = 0 IF DESTINATION IS AT END OF FILE
!	 = DIFFERENCE IN PAGE NUMBERS IF IT IS AT THE END
!
DIFPAG=.COPLPG[2]-.COPLPG[0];
IF .COPLPG[2] GEQU INF-1 THEN DIFPAG=0;
IF .RANGE[1] NEQ 0 OR .RANGE[3] NEQ INF THEN
	BEGIN
	IF .RANGE[1] NEQ 0 THEN
		BEGIN
		LOCAL
		    ENDR;
		RANGE[0]=.LINPAG(.ADR);
		DO	BEGIN
			NL1=.NL1+1;
			ADR=NXTLINE(.ADR,1);
			ENDR=PSTRNG(.ADR,RANGE);
			END UNTIL .ENDR OR .RANGE[0] NEQ .LINPAG(.ADR);
		IF .RANGE[0] NEQ .LINPAG(.ADR) AND .RANGE[3] EQL INF OR NOT .ENDR THEN
			LLIN=.SOSFLG[MAXLN];
		INC1=DIVU(.LLIN-.COPLPG[1]+1,
			.NL1+(IF .SLIN NEQ .COPLPG[1] THEN 1 ELSE 0));
		IF .SCSYM EQL ', ' THEN
			BEGIN
			SCAN();
			IF .SCTYP NEQ SCNUM THEN COPERR(BADCMD);
			SINC1=.SCSYM;
			SCAN();
			END;
		IF .INC1 GTRU 0 THEN
			IF .SINC1 LSSU .INC1 AND .SINC1 GTRU 0 THEN
				INC1=.SINC1
			ELSE
				BEGIN
				IF .SOSFLG[ISTEP] LSSU .INC1 THEN
					INC1=.SOSFLG[ISTEP];
				PRINT(PLIT ('INC1='));
				PRINTN(.INC1,1);
				PRINT(PLIT (%STRING(%CHAR(13),%CHAR(10))));
				END
		ELSE
			BEGIN
			PRINT(PLIT ('INC1=ORDER   '));
			IF .SINC1 GTRU 0 AND .COPLPG[1]+.SINC1 LSSU .LLIN THEN
				INC1=.SINC1
			ELSE
			IF .COPLPG[1]+.SOSFLG[ISTEP] LSSU .LLIN THEN
				INC1=.SOSFLG[ISTEP]
			ELSE
				INC1=1;
			PRINTN(.INC1,1);
			PRINT(PLIT (%STRING('  and P/M inserted',%CHAR(13),%CHAR(10))));
			IF .ENDR AND .RANGE[3] NEQ INF THEN
				PGMOD2=.PGMOD2+1;
			END;
		BEGIN
		    LOCAL
			TMP;
		    TMP=DIVU(.LLIN-.COPLPG[1],.INC1)+(IF .SLIN NEQ .COPLPG[1] THEN 0 ELSE 1);
		    IF .TMP LSS .NL1 THEN NL1=.TMP;
		END;
		IF .SLIN NEQ .COPLPG[1] THEN
			SLIN=.COPLPG[1]+.INC1;
		PGMOD1=0;
		END;
	IF .RANGE[2] EQL -2 THEN RANGE[3]=.RANGE[3]+1;
	IF .RANGE[3] NEQ INF THEN
		BEGIN
		LOCAL
		    PGSAV;
		PGSAV=0;
		UNTIL PSTRNG(.ADR,RANGE) DO
			BEGIN
			IF .LINPAG(.ADR) NEQ .PGSAV THEN
				BEGIN
				PGSAV=.LINPAG(.ADR);
				NL2=0;
				END;
			NL2=.NL2+1;
			ADR=NXTLINE(.ADR,1);
			END;
		ADR=PRVLINE(.ADR,1);
		IF .LINPAG(.ADR) NEQ .RANGE[2] AND .RANGE[2] NEQ -2 THEN
			BEGIN
			RANGE[3]=INF;
			RANGE[2]=.LINPAG(.ADR);
			NL2=0;
			END
		ELSE
			BEGIN
			RANGE[3]=.LINLIN(.ADR);
			RANGE[2]=.LINPAG(.ADR);
			END;
		IF .PGSAV EQL 0 THEN
			PGMOD2=.PGMOD2-1;
		END;
	IF .NL2 GTRU 0 THEN
		BEGIN
		IF .DIFPAG NEQ 0 OR .COPLPG[2] GEQU INF-1 THEN NL2=0
		ELSE IF .COPLPG[3] LSSU .NL2+1 THEN
			BEGIN
			PRINT(PLIT (%STRING('INC2=ORDER  P/M inserted',%CHAR(13),%CHAR(10))));
			NL2=0;
			END
		ELSE
			BEGIN
			IF .SCSYM EQL ', ' THEN
				BEGIN
				SCAN();
				IF .SCTYP NEQ SCNUM THEN COPERR(BADCMD);
				SINC2=.SCSYM;
				SCAN();
				END;
			INC2=DIVU(.COPLPG[3],.NL2+1);
			IF .SINC2 GTRU 0 AND .SINC2 LSSU .INC2 THEN
				INC2=.SINC2
			ELSE
				BEGIN
				IF .INC2 GTRU .SOSFLG[ISTEP] THEN
					INC2=.SOSFLG[ISTEP];
				PRINT(PLIT ('INC2='));
				PRINTN(.INC2,1);
				PRINT(PLIT (%STRING(%CHAR(13),%CHAR(10))));
				SINC2=.INC2;
				END;
			PGMOD2=0;
			END;
		END;
	END;
IF .COPLPG[4] EQL 1 THEN	! IF PGMK ALREADY EXISTS THERE
	PGMOD1=0;		! DON'T PUT ANOTHER
IF .DIFPAG NEQ 0 THEN		! IF COPYING TO END OF A PAGE
	PGMOD2=.DIFPAG;		! LAST PAGE FIXUP VALUE
BEGIN
	LOCAL
	    NPAG,
	    PGMOD,
	    LSTLIN,
	    LSTPAG;
	ADR=FIND(RANGE,1);
	RANGE[0]=.LINPAG(.ADR);		!PUT REAL LINE AND PAGE IN
	RANGE[1]=.LINLIN(.ADR);		!RANGE FOR DELETE IF T CMD
!
! If the point of the insert is contained in the range to be moved,
! and if this is a Transfer, then refuse to do it at all.  The only
! functionality lost is that of an expensive renumber.
!
	IF .CMD EQL 'T'
	    AND	LGEQ(COPLPG[0],RANGE[0])
	    AND
	    (	LGTR(RANGE[2],COPLPG[2])
		OR
		( LEQL(RANGE[2],COPLPG[2]) AND .COPLPG[3] NEQ INF )
	    )
		THEN COPERR(BADNLR);
	PGMOD=.PGMOD1-.LINPAG(.ADR)+.COPLPG[0];
	COPYXY(.ADR);
	ADR=.BUFFIR;
	DO	BEGIN
		LSTLIN=.LINLIN(.ADR);	!SAVE THE LINE AND PAGE NUMBER
		LSTPAG=.LINPAG(.ADR);	!OF THE LAST LINE IN THE RANGE
		NPAG=.LINPAG(.ADR)+.PGMOD;
		IF .LINPAG(.ADR) EQL .RANGE[0] AND .NL1 GTRU 0 THEN
			BEGIN
			LINLIN(.ADR)=.SLIN;
			SLIN=.SLIN+.INC1;
			NL1=.NL1-1;
			IF .NL1 EQL 0 THEN
				IF .LINPAG(.ADR) EQL .LINPAG(NXTLINE(.ADR,1)) THEN
					PGMOD=.PGMOD+1;
			END;
		IF .LINPAG(.ADR) EQL .RANGE[2] AND .NL2 GTRU 0 THEN
			BEGIN
			LINLIN(.ADR)=.SINC2;
			SINC2=.SINC2+.INC2;
			END;
		LINPAG(.ADR)=.NPAG;
		ADR=NXTLINE(.ADR,1);
		EXTFLG=.EXTFLG OR 1;	!OUTPUT FILE MAY NEED TO BE EXTENDED
		END  UNTIL PSTRNG(.ADR,RANGE);
	RANGE[2]=.LSTPAG;		!FIX END OF RANGE TO BE
	RANGE[3]=.LSTLIN;		!THE ACTUAL LINE AND PAGE
					!IN CASE THIS IS A TRANSFER
	NPAG=.NPAG+.PGMOD2;
	COPYXZ(.ADR,.NPAG);
	IF LGEQ(RANGE[0],COPLPG[2]) THEN
		BEGIN
		RANGE[0]=.RANGE[0]-.COPLPG[2]+.NPAG;
		RANGE[2]=.RANGE[2]-.COPLPG[2]+.NPAG;
		END;
	END;
BUFCHG=.BUFCHG+1;
END;

END ELUDOM
