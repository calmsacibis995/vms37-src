	.TITLE	SOSINI - INITIALIZATION  CODE
	.IDENT	/V03001/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	23-FEB-76
;
; MODIFIED BY:
;
;	V03001	PHL44458	Peter H. Lipman		3-Mar-1982
;
;		Save the default directory string before it is
;	altered by a parse of an explicit directory.
;
;	020705	PHL0705		Peter H. Lipman		25-Oct-1980
;
;		Combine open logic for new file into create routine in SOSOPN
;		If editing an existing file, preserve the file protection.
;
;	020702	PHL0702		Peter H. Lipman		12-May-1980
;
;		For RSTS use OPNCOM rather than .OPFNB directly 
;	to open the output file.  It makes SY print correctly.
;
	.MCALL	FDOF$L,FCSBT$,IOERR$,FSROF$
	FDOF$L
	FCSBT$
	IOERR$
	FSROF$	DEF$L

	.MCALL	FINIT$,OFNB$,CLOSE$
	.MCALL	GCML$,CSI$1,EXTK$S

	.SBTTL	INIT - SOS INITIALIZATION FOR BLISS

	CODE$	INI

;
; FAKE A HELP COMMAND, EXECUTE IT AND EXIT
;
INIHLP:
	MOV	#"H:,R3			;COMMAND AND DELIMITER
	MOV	HELPAG,R4		;NUMBER TO CONVERT TO DECIMAL STRING
	JSR	PC,BLDCMD		;BUILD A COMMAND
	MOV	#-1,-(SP)		;SOSCMD(-1)
	JSR	PC,SOSCMD		;EXECUTE THE HELP COMMAND
					;AND FALL THROUGH TO EXIT

EXIT2:	JMP	EXIT


ENTRY	INIT				;INIT ENTRY POINT
	JSR	R1,$SAV5		;SAVE ALL REGS
	FINIT$				;INIT FCS
	CLR	PAGLOW			;INIT THESE GLOBALS
	MOV	#177777,PAGHIG		;LOWEST AND HIGHEST PAGES
	MOV	#FILUSE,R5		;SHORTEN REFERENCES TO FILUSE
	MOV	#FILEIN,R4		;LIKEWISE FOR FILEIN
	JSR	PC,INIFLG		;INIT SOSFLG PARAMETERS

	.IF	NDF,R$$STS
	JSR	PC,ATACH1		;ATTACH THE TERMINAL
	.ENDC

	GCML$	#GCMLB,#INIPR,#INIPRL	;GET COMMAND
	BCC	50$			;BRANCH IF SUCCESSFUL
	CMPB	#GE.EOF,GCMLB+G.ERR	;IF EOF
	BEQ	EXIT2			;THEN EXIT QUIETLY
	JSR	PC,GCMLER		;ANALYZE THE ERROR
	BR	EXIT2			;EXIT AFTER REPORTING ERROR
50$:	JSR	PC,.GCML4		;READ THROUGH MCR LINE EOF

	.IF	NDF,R$$STS
	JSR	PC,ATACH1		;REATTTACH AFTER GCML
	.ENDC

	JSR	PC,CKCTLC		;CHECK AND CLEAR ^C
	TST	R0			;CONTROL C SEEN?
	BGT	EXIT2			;BRANCH IF YES, EXIT QUIETLY

	TST	GCMLB+G.CMLD		;EMPTY LINE?
	BEQ	EXIT2			;EXIT IF YES
	JSR	PC,SETSY0		;SET DEFAULT DEVICE AND UNIT
					;AND LOAD THE SWITCH TABLES
	JSR	PC,CSI1			;SCAN THE COMMAND LINE
	MOV	C.CMLD(R0),GCMLB+G.CMLD ;GET DESCRIPTOR FOR
	MOV	C.CMLD+2(R0),GCMLB+G.CMLD+2 ;POSSIBLY BLANK COMPRESSED LINE
	CLR	OPTNAM			;INITIALLY NO OPTION STRING
	CLR	R1			;INIT "NO SWITCHES SEEN YET"
	JSR	PC,CSI2OU		;PROCESS OUTPUT FILE SWITCHES
	BITB	#CS.EQU,C.STAT(R0)	;INPUT SECIFIER TOO?
	BEQ	120$			;BRANCH IF NO
	JSR	PC,CSI2IN		;PROCESS INPUT SWITCHES
120$:	CMP	#VALHEL,GIVWRD		;HELP SWITCH SPECIFIED?
	BEQ	INIHLP			;INITIAL HELP REQUEST
	MOV	R1,C.MKW1(R0)		;OR OF ALL SWITCHES SEEN
	JSR	PC,SWSET		;COMPLETE SETTING OF SWITCHES SEEN
	MOV	BUF+BUFLEN,R1		;BUFFER SPACE AVAILABLE
	MOV	SOSFLG+<BUFSZ*2>,R0	;USER SPECIFIED BUFFER EXTENSION
	BNE	160$			;BRANCH IF SPECIFIED
	CMP	R1,#MINBF		;ALREADY HAVE ENOUGH BUFFER SPACE?
					;FROM INS OR RUN /INC=DECIMAL BYTES
	BHIS	180$			;BRANCH IF YES
	MOV	#DFLTBF,R0		;USE DEFAULT BUFFER SIZE
					;TASK BUILD PARAMETER
160$:	MOV	R0,BUF+BUFLEN		;USE EXACTLY WHAT IS DESIRED
	ADD	#77,R0			;ROUND UP
	BIC	#77,R0			;TO NEAREST MULTIPLE OF 64. BYTE BLOCKS
;
; R0 = NO. OF BYTES DESIRED, R1 = NO. OF BYTES ALREADY AVAILABLE
;
	BIC	#77,R1			;CHOP TO NEAREST 64 BYTES
	SUB	R1,R0			;NUMBER OF BYTES TO ADD (SUB)

	.IF	DF,R$$EIS		;EXTENDED INSTRUCTION SET
	ROR	R0			;MAKE SURE SIGN BIT IS 0
	ASH	#-5,R0			;TOTAL OF 6 BITS RIGHT

	.IFF	;R$$EIS
	.REPT	6
	ROR	R0
	.ENDR
	.ENDC	;R$$EIS

	EXTK$S	R0			;EXTEND (CONTRACT) TASK
	BCC	180$			;BRANCH IF SUCCESSFUL
	JSR	R1,PRTINL		;PRINT MESSAGE
	.WORD	NOBUF			;NO TEXT BUFFER SPACE
	BR	EXIT2			;AND EXIT
180$:	MOV	SOSFLG,-(SP)		;SAVE THE FLAG WORD
	JSR	PC,INIFLG		;AND REINIT
	BIT	#NOOPT,(SP)+		;UNLESS EXPLICIT /NOOPTION
	BNE	200$
	MOV	#INITSW,R0		;DO SWITCH.INI SCAN
	BEQ	200$			;IF CODE IS PRESENT
	JSR	PC,(R0)
	JSR	PC,SWSET		;COMPLETE ANY SWITCH SETTINGS
200$:	JSR	PC,CSI1			;SET UP TO RESCAN THE COMMAND LINE
	BITB	#CS.EQU,C.STAT(R0)	;WAS IT FILE=FILE?
	BEQ	250$			;NO. JUST FILE<CR>
	JSR	PC,CSI2IN		;GET INPUT FILE
	MOV	R4,R0			;FDB POINTER
	JSR	PC,MOVFIL		;SAVE AND PARSE FILE
	MOV	#FILELST+F.FNAM,R0	;TEMP NAME BLOCK
	MOV	#FILEIN+F.FNAM,R1	;INPUT FILE NAME AND TYPE
	MOV	(R1)+,(R0)+		;COPY THE FILE NAME
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+		;AND THE FILE TYPE
	MOV	#FILEOUT,-(SP)		;OUTPUT FDB POINTER
	MOV	#4,(R5)			;FILE STATUS FILE=FILE
	BR	260$

250$:	MOV	R4,-(SP)		;INPUT FILE FDB ADDRESS
	MOV	#2,(R5)			;FILE STATUS IS SINGLE FILE GIVEN
260$:	JSR	PC,CSI2OU		;GET ONLY FILE GIVEN
	MOV	(SP),R0			;FDB POINTER FOR PARSE
	JSR	PC,MOVFIL		;SETUP FDB
	MOV	(SP)+,R0		;GET INPUT/OUTPUT FDB ADDRESS
	BIT	#RONLY,SOSFLG		;IF FILE IS READ ONLY
	BNE	280$			;THEN KEEP SY0 AS DEFAULT
	JSR	PC,STDFDV		;SET DEFAULT DEVICE
280$:	CMP	(R5),#2			;IF SINGLE FILE GIVEN
	BNE	300$
	MOV	#FILEOUT,-(SP)		;THEN SET PARAMS FOR DEFAULT
	MOV	#^RTM1,-(SP)		;OF OUTPUT FILE
	JSR	PC,SETFIL		;SET IT UP
	CMP	(SP)+,(SP)+		;POP 2

300$:	MOV	#512.,F.OVBS(R4)	;BUFFER SIZE
	MOV	R4,-(SP)		;PARAMETER TO OPEN
	JSR	PC,OPN1ST		;OPEN INPUT FILE
					;SET UP FOR STREAM MODE IF
					;INTERNAL CARRIAGE CONTROL
	ROL	R0			;SET C BIT ACCORDING TO SIGN OF R0
	MOV	(SP)+,R0		;RECOVER FDB ADDRESS
	BCC	390$			;DID IT?
	CMPB	F.ERR+FILEIN,#IE.NSF	;NO SUCH FILE
	BNE	380$			;NO   BAD ERROR
	CMP	#2,(R5)			;SINGLE FILE GIVEN?
	BEQ	360$			;BRANCH IF YES, TRY CREATING IT
340$:	JSR	R5,ERR
	.WORD	ERMSG3			;INPUT FILE DOES NOT EXIST
360$:	BIT	#RONLY,SOSFLG		;WAS IT SPEC READONLY?
	BNE	340$			;BRANCH IF YES, DOESN'T EXIST
	MOV	#FILEOUT,R0		;SET UP FOR INPUT OF
	JSR	PC,MOVFIL		;THE GIVEN FILE
	MOV	#1,(R5)
	BR	440$
380$:	JSR	R5,FERR
	.WORD	ERMSG4			;INPUT FILE OPEN ERR

390$:	JSR	PC,INIDIR		;INIT DEFAULT DIRECTORY STRING
	BIT	#RONLY,SOSFLG		;IF READ ONLY MODE
	BNE	510$			;DON'T OPEN OUTPUT FILE

	.IF	DF,R$$STS
	CMP	(R5),#2			; IF A SINGLE FILE IS BEING
	BNE	420$			; EDITED, AND IT IS
	MOV	#FILEIN+F.FNB,R0	; UNDER A DIFFERENT ACCOUNT,
					; RSTS MUST MAKE IT FILE=FILE
	TST	N.DID(R0)		;  --DEFAULT ACCOUNT?
	BEQ	420$			;    YES - OK
	MOV	@#.FSRPT,R1	
	CMP	N.DID(R0),A.DFUI(R1)	;  --SPECIFIED AS OURSELVES?
	BEQ	420$			;     ALSO OK
	MOV	#FILEOUT+F.FNB,R1	; CHANGE INPUT SPEC TO
	MOV	#S.FNB/2,R2		; FORM  <FILE>=<FILE>
410$:	MOV	(R0)+,(R1)+
	SOB	R2,410$			;  (FILUSE=4)
	MOV	#FILEOUT+F.FNB,R0
	CLR	N.FID(R0)		; CLEAR FILEID FIELD
	CLR	N.FID+2(R0)		; FOR NEW OPEN
	CLR	N.FID+4(R0)
	CLR	N.FVER(R0)		; VERSION NUMBER FOR NEW FILE
	CLR	N.DID(R0)		; PUT IT IN OUR DIRECTORY IN RSTS
	MOV	#4,(R5)			; SET NEW FILE STATUS VALUE
420$:
	CMPB	#R.STRM,FILEIN+F.RTYP	;IS IT STREAM INPUT?
	BEQ	440$			;YES..OUTPUT SAME THEN
	BIT	#RMSFIL,CSIBLK+C.MKW1	;/RMS OR /-RMS GIVEN?
	BNE	440$			;YES..LEAVE AS STATED
	BIS	#RMSFIL,SOSFLG		;UNSPEC - DEFAULT TO RMS OUTPUT

	.IFF	;RSX ONLY
	CMP	(R5),#2			;IF SINGLE FILE GIVEN
	BNE	440$
	MOV	#FILEIN+F.FNB,R1	;FILE NAME BLOCK OF INPUT FILE
	JSR	PC,RDPRO		;READ FILE PROTECTION
	.ENDC

440$:	MOV	R4,BUF+BUFILE		;ADDRESS OF INPUT FDB FOR CRTF1
	MOV	#FILEOUT,-(SP)		;ADDRESS OF FDB TO OPEN
	JSR	PC,CRTF1		;CREATE A NEW FILE
	ROL	R0			;SET C BIT ACCORDING TO SIGN OF R0
	MOV	(SP)+,R0		;RECOVER FDB ADDRESS
	BCC	500$			;BRANCH IF OPENED OK
	CLOSE$	R4			;ERROR - CLOSE INPUT
	CMPB	F.ERR+FILEOUT,#IE.DUP	;ALREADY EXIST?
	BNE	450$			;NO.  BAD ONE
	JSR	R5,ERR
	.WORD	ERMSG5			;OUTPUT FILE EXISTS
450$:	MOV	#FILEOUT,R0		;RECOVER OUTPUT FDB ADDRESS

	.IF	NDF,R$$STS
	CMPB	F.ERR(R0),#IE.PRI	;IF PRIVILEGE VIOLATION
	BNE	470$
	JSR	R5,FERR
	.WORD	ERMS15			;DEVICE OR DIRECTORY WRITE PROTECTED
470$:
	.ENDC

	JSR	PC,CRTER1		;ERROR CREATING OUTPUT FILE
	JMP	EXIT2			;FATAL EXIT

500$:	JSR	PC,INIDIR		;INIT DEFAULT DIRECTORY STRING
510$:	MOV	#BUF,-(SP)		;NOW INITIALIZE BUFFER
	JSR	PC,BUFINIT
	BITB	#FD.REC!FD.SQD,FILEIN+F.RCTL   ;SEQUENTIAL?
	BEQ	520$			;NO  NO PROBLEM
	INC	BUF+BUFCHG		;INSURE NO WRAP IN FILE
520$:	CMP	#2,(R5)			;SINGLE FILE?
	BNE	550$
	BIT	#RONLY!NOBAK,SOSFLG	;EITHER OF THESE OPTIONS?
	BEQ	600$
	INC	(R5)			;YES - FILUSE = 3, DO NOT BACKUP
550$:	CMP	(R5),#1			;INPUT A FILE?
	BNE	600$
	JSR	PC,ENDFILE		;ENDFILE ROUTINE, 0(SP) = #BUF
	MOV	#MINP,(SP)		;SET INPUT MESSAGE
	MOV	#FILEOUT,R4		;FDB POINTER
	BR	700$
600$:					;0(SP) = #BUF
	MOV	R4,-(SP)
	JSR	PC,GETLINE		;READ FIRST LINE
	CMP	(SP)+,(SP)+		;POP 2
	BIT	#RONLY,SOSFLG		;READONLY FILE?
	BEQ	650$
	MOV	#MREA,-(SP)
	BR	700$
;
; AT THIS POINT R4 CONTAINS FILEIN UNLESS INPUTTING A NEW FILE
; IN WHICH CASE IT CONTAINS FILEOUT
;
650$:	MOV	#MEDI,-(SP)		;EDIT MESSAGE
700$:	JSR	PC,PRINT
	CLR	(SP)			;SET . SOMEWHERE
	JSR	PC,SETDOT
	MOV	R4,(SP)			;FDB POINTER
	CMP	(R5),#4			; WAS IT FILE=FILE?
	BNE	720$			; NO - ONLY ONE FILE TO PRINT
	MOV	#4,-(SP)		; JUST FILE NAME
	JSR	PC,PRTFIL		; NO CR-LF
	MOV	#MSGAS,(SP)		;  " AS "
	JSR	PC,PRINT
	TST	(SP)+
	MOV	#FILEOUT,(SP)		; NEW FILE BEING CREATED
720$:	CLR	-(SP)			; FILENAME WITH CR-LF
	JSR	PC,PRTFIL
	TST	(SP)+			;POP 1

	MOV	#FILETMP,(SP)		;FDB FOR DFLT NAME
	MOV	#^RTM2,-(SP)		;EXTENSION
	JSR	PC,SETFIL
	CMP	(SP)+,(SP)+		;POP 2

	BICB	#GE.CLO,GCMLB+G.MODE	;LEAVE COMMAND FILE OPEN

	MOV	BUF+BUFLEN,SOSFLG+<BUFSZ*2> ;PUT BUFFER SIZE WHERE IT CAN BE SEEN

	CLR	R0
	CMP	(R5),#1
	BNE	750$
	MOV	#"I;,R3			;FORM INSERT COMMAND
	MOV	SOSFLG+<2*ISTEP>,R4	;"I;(STEP)"
	JSR	PC,BLDCMD		;BUILD THE COMMAND LINE
	MOV	#1,ILIN			;STARTING PAGE NUMBER
	MOV	SOSFLG+<2*STARTN>,ILIN+2 ;STARTING LINE NUMBER
	MOV	#-1,R0			;PASS THROUGH TO SOSCMD
750$:
	MOV	SPSAV1,SPSAV2		;INIT ABORT STACK VALUE
	RTS	PC			;EDIT OR READ; VALUE 0


;
; SET DEFAULT DEVICE FROM FDB IN R0
;
	.ENABL	LSB
STDFDV:	BITB	#FD.REC!FD.SQD,F.RCTL(R0) ;IF SEQUENTIAL DEVICE
	BNE	20$			;THEN ERROR

	.IF	DF,R$$STS
	MOV	F.DVNM(R0),DFDEV
	MOV	F.UNIT(R0),DFUNIT

	.IFF
	MOV	#DFDIR,R1		;ADR TO STORE DFLT DIRECTORY AND DEVICE
	MOV	F.FNB+N.DID(R0),(R1)+	;STORE THE DIRECTORY ID
	MOV	F.FNB+N.DID+2(R0),(R1)+
	MOV	F.FNB+N.DID+4(R0),(R1)+
	MOV	F.DVNM(R0),(R1)+	;STORE DEFAULT DEVICE
	MOV	F.UNIT(R0),(R1)+	;AND UNIT
	.ENDC

	RTS	PC
20$:	MOV	#ERMS10,-(SP)
	CMP	#4,FILUSE		;IF THIS IS OUTPUT FILE SPEC
	BEQ	30$			;SAY "RANDOM DEVICE REQUIRED"
	MOV	#ERMS11,(SP)		;ELSE "EXPLICIT OUTPUT FILE REQUIRED"
	BR	30$
;
; PRINT ERROR AND TRY AGAIN
;	JSR	R5,ERR
;	.WORD	ERMSG1
;  OR
;	JSR	R5,FERR			;FDB ERROR PRINT, R0 = FDB ADR
;	.WORD	ERMSG1
;
FERR:	MOV	(R5),-(SP)		;STORE MESSAGE ADDRESS
FERR1:	MOV	R0,-(SP)		;PUSH FDB ADDRESS
	JSR	PC,LDINER		;LOAD INIT ERROR MESSAGES
	JSR	PC,FDBERR		;REPORT FDB ERROR
	BR	FERR2

ERR:	MOV	(R5),-(SP)		;PUSH ERROR MSG POINTER
30$:	JSR	PC,LDINER		;LOAD INIT ERROR MESSAGES
	JSR	PC,PRINTC		;PRINT IT
FERR2:	JMP	EXIT2			;EXIT AFTER ERROR MSG

MOVFIL:	BITB	#CS.WLD!CS.MOR,C.STAT+CSIBLK ;FILE SPEC ERRORS?
	BNE	ILLSPC
	BITB	#CS.DVF!CS.NMF,C.STAT+CSIBLK ;WAS FILE GIVEN?
	BEQ	ILLSPC			;NO, ERROR
	MOV	#CSIBLK+C.DSDS,R2	;ADDRESS OF STRING DESCRIPTORS
	MOV	#FILELST+F.FNB,R3	;TEMP NAME BLOCK
	JSR	PC,PARSE2		;PARSE THE NAME
	BCS	40$			;BRANCH IF PARSE ERROR

	.IF	DF,R$$STS
	CMP	F.FNB+N.FTYP(R0),(PC)+	;CHECK FOR A 
	.RAD50	/BAS/			;BASIC+ FILE
	BNE	32$			;NO
	BIT	#BASIC,CSIBLK+C.MKW1	;WAS /BAS OR /-BAS
	BNE	32$			;GIVEN?  IF SO, CONTINUE
	BIT	#BASIC,SOSFLG		;WAS IT /BAS?
	BNE	32$			;YES.  GOOD
	BIS	#BASIC,SOSFLG		;NO.  ASSUME IT
	MOV	#ERMS12,-(SP)		;MESSAGE
	JSR	PC,LDINER		;LOAD INIT ERROR MESSAGES
	JSR	PC,PRINTC
	TST	(SP)+
	BR	39$			;DONE WITH CHECKS
32$:	CMP	F.FNB+N.FTYP(R0),(PC)+	;CHECK FOR A
	.RAD50	/BAK/			;BACKUP FILE
	BNE	34$
	BIT	#NOBAK,SOSFLG		;EDIT ONLY IF /NOBAK
	BNE	34$
	MOV	#ERMS13,-(SP)
	BR	30$			;ELSE GIVE ERROR
	.ENDC

34$:	CMP	F.FNB+N.FNAM(R0),(PC)+	;LAST CHECK
	.RAD50	/SOS/			;IS FOR SOS TEMP FILE
	BNE	36$
	MOV	R0,-(SP)		;MUST CHECK LAST 3
	MOV	#FILETMP,-(SP)
	MOV	(PC)+,-(SP)
	.RAD50	/TMP/
	JSR	PC,SETFIL
	CMP	(SP)+,(SP)+
	MOV	(SP)+,R0
	CMP	F.FNB+N.FNAM+2(R0),FILETMP+F.FNB+N.FNAM+2
	BNE	36$			;NOT OUR JOB FILES
	MOV	#ERMS14,-(SP)		;SET ERROR MESSAGE
	BR	30$			;ERROR

36$:

39$:	RTS	PC	
40$:	MOV	#ERMSG8,-(SP)		;NO SUCH DIRECTORY
	CMPB	#IE.NSF,F.ERR(R0)	;IF NO SUCH FILE FROM PARSE
	BEQ	30$

	.IF	NDF,R$$STS
	MOV	#ERMSG9,(SP)		;DEVICE NOT MOUNTED
	CMPB	#IE.PRI,F.ERR(R0)	;IF PRIVILEGE VIOLATION FROM PARSE
	BEQ	30$
	.ENDC

	MOV	#ERMSG7,(SP)		;OTHER ERROR FROM PARSE
	BR	FERR1
	.DSABL	LSB

ILLSPC:	JSR	R5,ERR			;ILLEGAL FILE SPECIFICATION
	.WORD	ERMSG7
;
; GET NEXT INPUT OR OUTPUT SPEC FROM THE COMMAND LINE
;	RETURNS IN LINE IF SUCCESSFUL
;	ISSUES ERROR AND EXITS SOS IF ERROR
;
; INPUTS:
;
;	R1 = INITIAL VALUE FOR "SWITCHES FOUND SO FAR"
;	     WILL ONLY BE USED TO OR INTO, SO CAN BE GARBAGE
;
; OUTPUTS:
;
;	R0 = CSI CONTROL BLOCK ADDRESS
;	R1 = R1 ! CSIBLK+C.MKW1
;
	.ENABL	LSB

CSI2IN:	MOVB	#CS.INP,-(SP)		;GET NEXT INPUT SPECIFIER
	BR	10$
CSI2OU:	MOVB	#CS.OUT,-(SP)		;GET NEXT OUTPUT SPECIFIER
10$:	MOV	#CSIBLK,R0		;CSI CONTROL BLOCK ADDRESS
	MOV	#ISWTAB,C.SWAD(R0)	;SWITCH TABLE ADDRESS
20$:	MOVB	(SP),(R0)		;SET IN/OUT SPECIFIER
	JSR	PC,.CSI2		;GET THE NEXT FILE SPECIFIER
	BCS	60$			;BRANCH IF ERROR
	BIS	C.MKW1(R0),R1		;KEEP TRACK OF ALL SWITCHES SEEN

	.IF	NDF,R$$STS		;RSX ONLY
	BIT	#SYSCME,SYSTEM		;IF VAX/VMS
	BEQ	40$
	BITB	#CS.MOR,C.STAT(R0)	;MORE THAN ONE SPEC ALLOWED
	BEQ	40$
	BITB	#CS.DVF!CS.DIF!CS.NMF,C.STAT(R0) ;BUT MUST BE ONLY SWITCHES
	BEQ	20$			;GET THE NEXT SPEC WITH A FILE
	BR	ILLSPC			;ILLEGAL FILE SPECIFICATION
	.ENDC

40$:	TST	(SP)+			;CLEAN OFF 1 WORD, PRESERVE CARRY
	RTS	PC			;AND RETURN
60$:	JSR	R5,ERR			;CSI$2 ERROR
	.WORD	ERMSG2

	.DSABL	LSB
;
; CALL CSI$1 WITH LINE DESCRIBED BY GET COMMAND LINE CONTROL BLOCK
;	RETURNS IN LINE IF SUCCESSFUL
;	ISSUES ERROR AND EXITS SOS IF ERROR
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 = CSI CONTROL BLOCK ADDRESS
;
CSI1:	CSI$1	#CSIBLK,GCMLB+G.CMLD+2,GCMLB+G.CMLD
	BCS	10$
	RTS	PC
10$:	JSR	R5,ERR			;CSI$1 ERROR
	.WORD	ERMSG1
;
; INITIALIZE DEFAULT DIRECTORY STRING
;
;	R0 = FDB ADDRESS OF FILE JUST OPENED
;
INIDIR:

	.IF	NDF,R$$STS		;NOT RSTS
	JSR	R1,$SAV4
	BIT	#SYSCME,SYSTEM		;IF VMS, SAVE DEFAULT DIRECTORY STRING
	BEQ	20$			;BRANCH IF NOT
	BIT	#NB.DIR,F.FNB+N.STAT(R0) ;IF EXPLICIT DIRECTORY
	BNE	20$			;THEN NO DEFAULT DIR STRING
	JSR	PC,.RDFDR		;READ DEFAULT DIRECTORY STRING
	MOV	#DIRSTR,R3		;PLACE TO SAVE IT
	TSTB	(R3)			;ALREADY BEEN SAVED?
	BGT	20$			;BRANCH IF YES
	CLRB	(R3)+			;NO DEFAULT DIRECTORY
	MOV	R1,R4			;SAVE BYTE COUNT
10$:	MOVB	(R2)+,(R3)+		;MOVE THE STRING
	CMP	R3,#DIREND		;OVERFLOW DIR STRING?
	BHIS	20$			;BRANCH IF YES
	SOB	R1,10$
	CMPB	-(R3),#']		;COMPLETE?
	BNE	20$
	MOVB	R4,DIRSTR		;YES, SET BYTE COUNT
	.ENDC	;R$$STS

20$:	RTS	PC

INIFLG:	JSR	R1,$SAV2		;SAVE R1,R2
	MOV	#SOSFLG,R1
	MOV	#SOSIFL,R2
	MOV	#SOSFLL,R0
5$:	MOV	(R2)+,(R1)+		;INIT SOSFLG VALUES
	SOB	R0,5$
	RTS	PC

;
; R3 = COMMAND CHARACTER AND SEPARATOR
; R4 = NUMBER TO CONVERT TO DECIMAL STRING
;
BLDCMD:	MOV	#TTIBUF,R1		;ADDRESS TO BUILD HELP COMMAND
	MOV	#TTICTL,R2		;ADR OF ADR AND SIZE OF INPUT STRING
	MOV	R1,(R2)			;SET ADDRESS OF INPUT STRING
	MOV	R3,(R1)+		;COMMAND AND DELIMITER
	MOV	R4,-(SP)		;NUMBER TO CONVERT TO DECIMAL STRING
	MOV	#1,-(SP)		;MINIMUM OF 1 CHARACTER
	JSR	PC,CNVDEC		;CONVERT TO DECIMAL STRING
					;ADDRESS OF STRING IN R0
10$:	MOVB	(R0)+,(R1)+		;MOVE ASCIZ STRING
	BNE	10$			;BRANCH IF MORE TO MOVE
20$:	MOVB	#15,-1(R1)		;CR INSTEAD OF TRAILING NULL
	SUB	(R2)+,R1		;BYTE COUNT OF STRING
	MOV	R1,(R2)			;STORE COUNT OF INPUT STRING
	CMP	(SP)+,(SP)+		;CLEAN OFF 2 WORDS
	RTS	PC			;AND RETURN

SOSIFL::.WORD	0,100.,0,65533.,16.,0,100.
LINPPG::.WORD	55.,1,1,100.,0,0
	.IF	DF,R$$STS
	.WORD	-1

	.IFF
	.WORD	0			;INITIAL PRINTER UNIT
	.ENDC

	.WORD	0			;BUFFER SIZE

INIPR:
	.IF	DF,R$$STS
	.ASCII	/File: /

	.IFF
	.ASCII	<15><12>/File: /
	.ENDC
INIPRL	=	.-INIPR			;INITIAL PROMPT STRING
	.EVEN

	PLIT	NOBUF,</Not enough text buffer space available/<15><12>>
	PLIT	MINP,</Input: />
	PLIT	MREA,</Read: />
	PLIT	MEDI,</Edit: />
	PLIT	MSGAS,</ as />

	.END
