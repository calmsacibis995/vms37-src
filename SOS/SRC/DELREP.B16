MODULE DELREP (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!


!	03	29-JUL-77	BILL MARSHALL
!
!	FIXED =BIG WHEN LAST PAGE WAS DELETED
!
!	06.10	8-FEB-79	PETER H. LIPMAN
!
!	DELETE ACROSS PAGE BOUNDARIES REWRITTEN
!	BREAK OUT INSERT/REPLACE SCANNER
!
!	06.11	20-APR-79	PETER H. LIPMAN
!
!	FIX BUG IN "R.;!10" INTRODUCED IN 06.10 ABOVE
!

!
!	DELREP
!
!	THIS ROUTINE IS THE COMMON DELETE/REPLACE COMMAND
!	HANDLERS.  IT PROCESSED THE PARAMETERS, WHICH ARE
!	COMMON TO BOTH, AND DELETES THE SPECIFIED LINES.
!	IF CALLED VIA REPLAE, IT THEN CALLS 'INSERT' TO
!	READ IN NEW LINES IN THEIR PLACE.
!
!	PARAMETERS -
!		TYP - TYPE OF CALL - 0 IF DELETE, 1 REPLACE.
!		BUF - ADDRESS OF BUFFER HEADER
!
!	RETURNS -
!		NONE
!
!
!	V02.02	09-JUN-76	WTM
!	V02.01	19-MAR-76	WTM


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	RDCMD,		! READ INPUT COMMAND
	GETRNG,		! PARSE RANGE
	TYPECR,		! TYPE <CR><LF>
	PRINTC,		! PRINT MESSAGE WITH TRAILING <CR><LF>
	PRINT,		! WARNING MESSAGE PRINTS
	LISTEN,		! ARE YOU SURE? QUESTIONS
	TYPE,		! ANSWERS TO ABOVE
	FINDR,		! LOCATE FIRST LINE IN RANGE
	DELLINE,	! DELETE LINE IN BUFFER
	PSTRNG,		! TEST FOR DONE
	SETDOT,		! UPDATE CURRENT DOT LOC
	GETDOT,		! GET CURRENT DOT LOC
	FIND,		! FIND A LINE IN BUFFER
	NXTLINE,	! NEXT FUNCTION
	PRVLINE,	! BACKUP FUNCTION
	MODPGS,		! MODIFY PAGE NUM,BERS
	PRINTN,		! PRINT NUMERIC VALUE
	IRSCAN;		! INSERT/REPLACE SCANNER


EXTERNAL
    CMD,		! COMMAND CHARACTER
    ILIN: VECTOR[3];	! SAVED INSERT LINE NUMBER

GBLROUTINE (DELREP)=
BEGIN
LOCAL
    ADR,
    CHAR,
    I,
    CT,
    LLIN,
    J,
    MODP,
    LPAG,
    CNFMSG;
LOCAL
    PRVADR,
    PREVP: VECTOR[2],
    NEXTP: VECTOR[2];
CNFMSG = 0;			! NO CONFIRMATION REQUEST YET
RDCMD();
GETRNG(RANGE);
IRSCAN(I,J);
IF (.I EQL 0) AND (.J EQL 0) THEN I=.SOSFLG[ISTEP];
IF .RANGE[2] EQL -2 AND (.SOSFLG AND EXPERT) EQL 0 THEN
	BEGIN
	ADR=FIND(RANGE,1);
	IF .RANGE[3] GTR 1 THEN
		ADR=NXTLINE(.ADR,.RANGE[3]-1);
	IF .LINLEN(.ADR) EQL 0 THEN
		ADR=PRVLINE(.ADR,1);
	RANGE[2]=.LINPAG(.ADR);
	RANGE[3]=.LINLIN(.ADR);
	END;
!
! IF A SECOND PAGE NUMBER WAS SPECIFIED AND IT IS DIFFERENT FROM THE
! FIRST, THEN NOTE THAT THE DELETE WILL CROSS A PAGE BOUNDARY.
!
IF (.RANGE[4] AND 8) NEQ 0 AND .RANGE[0] NEQ .RANGE[2] THEN
	CNFMSG = PLIT (%STRING('across pages','?',' Y or N:'))
ELSE IF (.RANGE[4] AND 7) EQL 2 THEN 	! IF NO FIRST LINE NUMBER
	BEGIN
	CNFMSG = PLIT (%STRING('entire page','?',' Y or N:'));
	RANGE[1]=0;
	RANGE[2]=.RANGE[0];
	RANGE[3]=INF;
	END;
IF .CNFMSG NEQ 0 AND ((.SOSFLG AND EXPERT) EQL 0) THEN
	DO BEGIN
	PRINT (IF .CMD EQL 'R'
		THEN PLIT ('Replace ')
		ELSE PLIT ('Delete '));
	PRINT (.CNFMSG);
	CHAR = LISTEN(0);
	TYPE(.CHAR);			! ECHO WHAT WAS TYPED
	CHAR = .CHAR AND NOT %O'040';	! FORCE TO UPPER CASE
	TYPECR();
	IF .CHAR EQL 'N' THEN RETURN 0;
	IF .CHAR EQL 'Y' THEN EXITLOOP;
	END WHILE 1;
PRVADR=PRVLINE(FINDR(RANGE),1);
ADR=NXTLINE(.PRVADR,1);
RANGE[0]=.LINPAG(.ADR);
RANGE[1]=.LINLIN(.ADR);
CT=0;
DO	BEGIN
	LLIN=.LINLIN(.ADR);
	SETDOT(.ADR);
	LPAG=.LINPAG(.ADR);
	NXTLINE(.ADR,1);
	ADR=DELLINE(.ADR);
	CT=.CT+1;
	END  UNTIL PSTRNG(.ADR,RANGE);
IF .PRVADR EQL 0 THEN			! IF AT BEGINNING OF FILE
	BEGIN
	PREVP[1]=.SOSFLG[MAXLN];	! PREVIOUS LINE IS LAST LINE
	PREVP[0]=0;			! OF NON-EXISTENT PAGE 0
	END
ELSE	BEGIN
	PREVP[1]=.LINLIN(.PRVADR);
	PREVP[0]=.LINPAG(.PRVADR);
	END;
IF .PREVP[0] LSSU .RANGE[0] THEN 	! IF PREVIOUS LINE
	BEGIN				! IS ON A DIFFERENT PAGE
	PREVP[0]=.RANGE[0]-1;		! FORCE IT TO THE
	PREVP[1]=.SOSFLG[MAXLN];	! IMMEDIATELY PRECEEDING PAGE
	END;
NEXTP[1]=.LINLIN(.ADR);
NEXTP[0]=.LINPAG(.ADR);
IF .NEXTP[0] GTRU .LPAG THEN		! IF NEXT LINE IS ON A DIFFERENT
	BEGIN				! PAGE OR IS THE END OF FILE
	NEXTP[1]=0;			! THEN USE FIRST LINE
	NEXTP[0]=.LPAG+1;		! OF THE NEXT PAGE
	END;
MODP=.NEXTP[0]-.PREVP[0]-1;
!
! IF PAGES CAN BE CONCATENATED AND THE LINES WILL NOT BE OUT OF ORDER,
! THEN DO SO UNLESS THIS IS A REPLACE COMMAND.  MUST LEAVE ROOM TO ADD
! THE NEW LINES.  LIKEWISE DON'T COLLAPSE OUT AN ENTIRE PAGE IF REPLACE.
! IF NO EXPLICIT CROSS PAGE DELETION, DON'T MERGE PAGES.
!
IF .LPAG GTRU .RANGE[0]
	AND .NEXTP[1] GTRU .PREVP[1]
	AND .CMD NEQ 'R'
		THEN MODP=.MODP+1;
IF .RANGE[0] GTRU .PREVP[0] AND .CMD EQL 'R'
	THEN MODP=.MODP-1;
IF .MODP GTR 0 THEN
	BEGIN
	IF .LINLEN(.ADR) NEQ 0 THEN MODPGS(.ADR,-.MODP);
!
! MERGING OF PAGES MAKES IT IMPOSSIBLE TO PRESERVE DOT AS THE LAST LINE
! DELETED.  MAKE SURE THAT DOT IS SET BETWEEN THE PREVIOUS AND NEXT LINES.
!
	SETDOT(.PRVADR);
	IF .CURLIN GEQU .SOSFLG[MAXLN] THEN
		BEGIN			! IF ALREADY AT MAXIMUM LINE
		CURLIN=0;		! USE FIRST LINE
		CURPAG=.CURPAG+1;	! OF NEXT PAGE
		END;			! MUST BE ROOM, DID A DELETE
	    BEGIN
		LOCAL
		    TMP;
		IF .CURPAG LSSU .LINPAG(.ADR)
			THEN TMP=.SOSFLG[MAXLN]+1
			ELSE TMP=.LINLIN(.ADR);
		TMP=(.TMP-.CURLIN)/2;
		IF .TMP GTRU .SOSFLG[ISTEP] THEN
			TMP=.SOSFLG[ISTEP];
		CURLIN=.CURLIN+.TMP;
	    END;
!
! IF THE PREVIOUS INSERT POINT WAS EITHER IN OR BEYOND THE DELETED
! AREA THE CONTEXT MUST BE ADJUSTED TO KEEP IT LOGICALLY WHERE IT WAS.
!
	IF .ILIN[0] NEQ 0 THEN
		IF LGTR(ILIN,PREVP) THEN
			IF LGEQ(ILIN,NEXTP)
				THEN ILIN[0]=.ILIN[0]-.MODP
				ELSE GETDOT(ILIN);
	END;
!
! IF THE NEXT LINE IS THE END OF FILE, THEN THE HIGHEST PAGE NUMBER
! MAY NEED TO BE ADJUSTED.  USE THE PAGE NUMBER FROM PRVADR WHICH
! HAS ALREADY BEEN PLACED IN PREVP[0].  IF THIS IS ZERO, THEN
! THE FILE IS NOW TOTALLY EMPTY.
!
IF .LINLEN(.ADR) EQL 0 THEN
	IF (PAGHIG=.PREVP[0]) EQL 0 THEN
		PAGHIG=.PAGHIG+1;
IF NOT ((.SOSFLG AND EXPERT) NEQ 0) THEN
	BEGIN
	TYPECR();
	PRINTN(.CT,1);
	PRINT(PLIT (' Line(s) deleted ('));
	PRINTN(.RANGE[1],5);
	TYPE('/');
	PRINTN(.RANGE[0],1);
	IF .CT GTR 1 THEN
		BEGIN
		TYPE(':');
		PRINTN(.LLIN,5);
		IF .RANGE[0] NEQ .LPAG THEN
			BEGIN
			TYPE('/');
			PRINTN(.LPAG,1);
			END;
		END;
	PRINTC(PLIT (').'));
	END;
IF .CMD EQL 'R' THEN
	BEGIN
!
! IF REPLACING ENTIRE PAGE, THEN START NUMBERING FROM "STARTN"
!
	IF .RANGE[0] LSSU .LINPAG(.ADR)
		AND .RANGE[0] GTRU .PREVP[0] THEN
		RANGE[1]=.SOSFLG[STARTN];
	CURPAG=.RANGE[0];
	CURLIN=.RANGE[1];
	RANGE[2]=.I;
	RANGE[3]=.J;
	END;
CURLPG=.CURPAG;
CMDCNT=.CMDCNT+1;
RETURN 1;
END;


END ELUDOM
