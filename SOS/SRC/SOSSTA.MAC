	.TITLE	SOSSTA - SOS STARTUP CODE
	.IDENT	/V03000/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	23-FEB-76
;
; MODIFIED BY:
;
;	020705	PHL0705		Peter H. Lipman		25-Jun-1981
;		UNKNOWN terminal now uses null control strings but
;		does CRT rubout correctly.
;
;	020705	PHL35580	Peter H . Lipman	21-Mar-1981
;		If TTILUN (TI: = SYS$INPUT) is really a terminal, don't
;	insist on getting the terminal characteristics from TTYLUN
;	(CO: = SYS$COMMAND).
;
;	020705	PHL32059	Peter H. Lipman		25-Oct-1980
;
;		Make default for UNKNOWN or FT1 - FT8 be hard copy.
;
;	020703	PHL0703		Peter H. Lipman		5-Jun-1980
;
;		RSTS exit should use EXIT$S rather than .EXIT
;
;	020701	PHL0701		Peter H. Lipman		27-Apr-1980
;
;		Add customer default CRT by defining a non-zero 
;	CRTCOD if terminal is not a scope, disable future /TERM:
;
	.MCALL	GCMLD$
	GCMLD$

	.MCALL	GTSK$S,GPRT$S,GLUN$S,EXIT$S
	.MCALL	CLOSE$

	.IF	NDF,R$$STS
	.MCALL	QIOSY$,TTSYM$,DIR$,QIOW$
	QIOSY$
	TTSYM$

	DATA$	STA
TTINI:	QIOW$	IO.GTS,TIOLUN,7,,IOSTS,,<TTIBUF,6,,,,>

	.ENDC

	.SBTTL	MAIN STARTUP AND INITIALZATION

	CODE$	STA

START1::
	.IF	DF,R$$STS		;RSTS ONLY
	MOV	#JOBNUM,R1		;ADR OF 2 WORDS, JOBNUM, SOSTNM
	CLR	(R1)			;INIT BOTH BYTES OF JOBNUM
	MOVB	FIRQB+FQJOB,(R1)	;SAVE JOB NUMBER
	ASR	(R1)			;REAL JOB NUM
	MOV	(R1)+,-(SP)		;PUSH JOB NUMBER, R1 POINTS TO SOSTNM
	MOV	#2,-(SP)		;CONVERT 2 DIGITS
	JSR	PC,CNVDEC		;OF JOB NUMBER TO ASCII STRING
	MOVB	(R0)+,(R1)+		;STORE 2 DIGITS IN SOSTNM
	MOVB	(R0),(R1)
	CMP	(SP)+,(SP)+		;CLEAN THE STACK

	MOV	#7.,20			;SET UP LENGTH OF SST VECTOR
	MOV	#SSTVEC,16		;AND POINTER TO IT
	MOV	#CTLC,24		;^C TRAP HANDLER
	CLR	TTOCTL+2		;INIT TTY OUTPUTTERS
	MOV	#TTOBUF,TTOCTL		;BUFFER POINTERS

	MOV	#FIRQB+FQFUN,R1		; SET POINTER TO FIRQB
	MOVB	#UU.TRM,(R1)+		; GET/SET TERM. CHARACTERISTICS
	MOV	#-1,(R1)+		; FOR KB:
12$:	CLR	(R1)+			; CLEAR FIRQB FOR GET CALL
	CMP	R1,#FIRQB+FQBSIZ	; END OF FIRQB ?
	BNE	12$			; NO, KEEP GOING
	.UUO				; DO YOUR THING
	MOVB	FIRQB+6,TTSIZE		; GET THE WIDTH + 1
	DECB	TTSIZE			; AND MAKE IT WIDTH + 0
	MOVB	FIRQB+14,TTSCP		; GET RSTS SCOPE FLAG
	BICB	#376,TTSCP		; CONVERT TO OUR FORMAT

	.IFF	;RSX ONLY

	.IFTF	;RSX AND RSTS
	MOV	#BUF,R0			;ADDRESS OF BUFFER ADR AND SIZE
	MOV	.TOPAD,(R0)+		;STORE BASE ADDR OF BUFFER
	GPRT$S	,#TTIBUF		;GET PARTITION PARAMETERS
	MOV	@#$DSW,(R0)		;BASE ADDRESS OF PARTITION
					;FOR UNMAPPED 11M OR 11S
	GTSK$S	#TTIBUF			;GET TASK PARAMETERS
	ADD	TTIBUF+G.TSTS,(R0)	;FORM HIGHEST VIRTUAL ADR
	SUB	-2(R0),(R0)		;NO. OF BYTES OF BUFFER SPACE
	.IFF	;RSX ONLY
;
; ESTABLISH WHICH RSX SYSTEM THIS IS
;
	MOV	TTIBUF+28.,R0		;GET RSX SYSTEM CODE
	BIC	#177760,R0		;STARTING AT 0 THEY ARE
					;11D,11M,11S,IAS,RSTS,CME,MPL
	MOV	#1,R5			;FORM A BIT NO. FROM THE ENCODED VALUE
10$:	DEC	R0			;SHIFT 0 OR MORE TIMES
	BLT	20$			;BRANCH IF DONE
	ASL	R5			;SHIFT IT ONE BIT
	BR	10$			;SEE IF DONE YEST

20$:	MOV	R5,SYSTEM		;RECORD SYSTEM FLAG
	GLUN$S	#TIOLUN,#TTIBUF		;READ THE LUN INFO FOR TI:
	MOV	TTIBUF+G.LUCW+6,TTSIZE	;BUFFER SIZE (SCREEN WIDTH)
	MOV	#TTIBUF+G.LUNU,R0	;ADDRESS OF TERMINAL NUMBER
	CLR	R1			;ZERO EXTEND THE BYTE
	BISB	(R0)+,R1		;AND LEAVE R0 READY TO FORM 3 BYTE
					;ASCII TERMINAL NUMBER
	BIT	#SYSCME,R5		;IF RSX CME
	BNE	40$			;FORM CONTROLLER LETTER AND DECIMAL UNIT
	MOV	#3,R3			;OVERWRITING FIRST 3 BYTES OF TTIBUF
30$:	MOV	R1,R2			;GET NEXT OCTAL DIGIT
	BIC	#^C<7>,R2		;LOW 3 BITS
	ADD	#'0,R2			;FORM ASCII
	MOVB	R2,-(R0)		;AND STORE IT

	.IF	DF,R$$EIS		;11 EXTENDED INSTRUCTION SET
	ASH	#-3,R1			;DIVIDE BY 8

	.IFF	;NO EIS AVAILABLE
	ASR	R1			;DIVIDE
	ASR	R1			;  BY
	ASR	R1			;    8
	.ENDC	;R$$EIS

	SOB	R3,30$			;ONCE FOR EACH DIGIT
	BR	60$
40$:	MOV	R1,R2			;COPY THE UNIT NUMBER
	BIC	#^C<17>,R2		;4 BITS = 16. UNITS PER CONTROLLER
	MOV	#'0,R3			;ASSUME UNIT LESS THAN 10.
	CMP	R2,#9.			;IS IT?
	BLE	50$			;BRANCH IF YES
	INC	R3			;FIX UP HIGH DIGIT
	SUB	#10.,R2			;AND FORM LOW DIGIT
50$:	ADD	#'0,R2			;MAKE INTO ASCII DIGIT
	MOVB	R2,-(R0)		;STORE UNIT NUMBER, LOW CHARACTER
	MOVB	R3,-(R0)		;HIGH CHARACTER

	.IF	DF,R$$EIS		;11 EXTENDED INSTRUCTION SET
	ASH	#-4,R1			;FORM CONTROLLER NO. FROM HIGH 4 BITS

	.IFF	;NO EIS AVAILABLE
	ASR	R1			;FORM CONTROLLER
	ASR	R1			; FROM THE HIGH
	ASR	R1			;  4 BITS OF THE
	ASR	R1			;   UNIT NUMBER
	.ENDC	;R$$EIS

	ADD	#'A,R1			;CONTROLLERS START AT "A"
	MOVB	R1,-(R0)		;STORE CONTROLLER CHARACTER
60$:	JSR	PC,$CAT5		;CONVERT 3 CHAR ASCII STRING
					;POINTED AT BY R0 TO RAD50 WORD
	MOV	R1,SOSTNM		;IN R1 AND SAVE IN SOSTNM

	BIT	#SYS11M!SYS11S!SYSMPL,R5 ;ECHO ALTMODE FOR 11M, 11S, OR MPLUS
	BNE	70$			;BRANCH IF 11M OR 11S
	CLRB	ALTECO			;PATCH ALTMODE ECHO
70$:	BIT	#SYSCME,SYSTEM		;IF VAX/VMS
	BEQ	75$
	JSR	PC,TTQIO		;GET TERMINAL SUPPORT FOR SYS$INPUT
					;TIOLUN IS ASSIGNED TO TI:
	MOVB	TTIBUF,TOPTTY		;NON-ZERO IF TOP LEVEL COMMAND
					;FILE IS A TERMINAL, ZERO IF NOT
	BNE	76$			;BRANCH IF IT IS A TERMINAL
	MOVB	#TTYLUN,TTINI+Q.IOLU	;GET CHARACTERISTICS FOR REAL TERMINAL
					;TTYLUN IS ASSIGNED TO CO: = SYS$COMMAND
75$:	JSR	PC,TTQIO		;GET TERMINAL SUPPORT
76$:	BCS	90$			;BRANCH IF NO INFORMATION AVAILABLE
	BIT	#F1.RST,TTIBUF		;READ WITH SPECIAL TERMINATORS?
	BEQ	80$			;BRANCH IF NOT AVAILABLE
	MOVB	#10,RSTFLG		;ENABLE READ WITH SPECIAL TERMINATORS
80$:	MOV	#SF.GMC,TTINI+Q.IOFN	;GET MULTIPLE CHARACTERISTICS
	MOV	#TTIBUF+12,R1		;BUFFER ADR FOR DESIRED CHARACTERISTICS
	MOVB	TTSIZE,-(R1)		;DEFAULT TERM WIDTH TO BUF SIZE FROM GLUN
	MOVB	#TC.WID,-(R1)		;GET TERMINAL WIDTH (IAS/11D ONLY)
	MOV	#<TC.SMP ! 400>,-(R1)	;"LOWER CASE INPUT" FOR 11D/IAS
	BIT	#SYS11D!SYSIAS,R5	;ASSUME VALUE IS "TRUE"
	BEQ	82$			;IF NOT 11D/IAS
	MOV	#TC.SMP,(R1)		;OTHERWISE ASSUME "FALSE"
	ADD	#4,TTINI+Q.IOPL+2	;AND READ 2 MORE CHARACTERISTICS
82$:	MOV	#TC.SMR,-(R1)		;"LOWER CASE TERMINAL" CODE
	MOV	#TC.TTP,-(R1)		;READ TERMINAL TYPE CODE
	MOV	#TC.SCP,-(R1)		;SEE IF TERMINAL IS A SCOPE
	JSR	PC,TTQIO		;READ TERMINAL CHARACTERISTICS
	BCS	90$			;BRANCH IF CANNOT GET CHARACTERISTICS
	INC	R1			;POSTION BUFFER POINTER TO SCOPE BIT
	MOVB	(R1)+,TTSCP		;SAVE SCOPE BIT (1 IF SCOPE)
	INC	R1			;POSITION BUFFER POINTER TO TERMINAL TYPE
	MOVB	(R1)+,R2		;SAVE TERMINAL TYPE
	MOV	(R1)+,R0		;ACCUMULATE THE LOWER CASE BITS
	ADD	(R1)+,R0		;TO SEE IF BOTH ARE SET
	CMP	#<TC.SMP+TC.SMR+1000>,R0 ;IF EQUAL, THEN BOTH BITS WERE SET
	BEQ	86$			;BRANCH IF DRIVER NOT CONVERTING LC TO UC
	MOVB	#2,RAISLC		;ALTER MODE MUST CONVERT TOO
86$:	CLR	TTSIZE			;FORM TERMINAL WIDTH IN R0
	MOVB	1(R1),TTSIZE

	.IFTF	;RSX AND RSTS
90$:	MOVB	#GE.COM!GE.IND!GE.CLO!GE.LC,GCMLB+G.MODE ;INIT GCML MODE

	.IFF	;RSX ONLY
	MOV	#IASINI,R0		;SEE IF SPECIAL IAS INIT ROUTINE
	BEQ	91$			;IS PRESENT TO CALL
	JSR	PC,(R0)			;AND CALL IT IF IT IS
91$:	MOV	#TTATDT+Q.IOPL+4,R0	;ADR OF 3RD PARAM IN ATTACH
	BIT	#SYS11D!SYSIAS,R5	;IF IAS OR 11D
	BNE	92$
	MOV	#IO.RTT,TTINI+Q.IOFN	;TRY READ WITH TERMINATOR TABLE
	CLR	TTINI+Q.IOPL+2		;WITH A EMPTY READ BUFFER
	JSR	PC,TTQIO
	CMPB	IOSTS,#IE.IFC		;IF ILLEGAL FUNCTION
	BEQ	92$			;THEN OLD TERM DRIVER
	CMP	-(R0),-(R0)		;POINT AT PARAM ONE
92$:	CLR	(R0)			;CLEAR EITHER PARAM 1 OR 3

	.IFTF	;RSX AND RSTS
;
; R2 = TERMINAL TYPE CODE, NOT FOR RSTS
;    = 0 FOR UNKNOWN
;    = T.VT05 FOR VT05
;    = T.VT50, T.VT52, T.VT55, T.VT61 FOR VT5X
;    = T.V100 FOR VT100
;
	TSTB	TTSCP			;IF NOT SCOPE
	BNE	93$			;BRANCH IF IT IS A SCOPE
	CLR	TRMVEC			;DISABLE /TERM
	BR	97$			;AND SKIP THE CONTROL STRING INIT
93$:	MOV	#CRTCOD,R0		;GET DEFAULT CRT IF DEFINED
	BGT	96$			;BRANCH IF NON-STANDARD DEFAULT

	.IFF	;RSX ONLY
	TST	R2			;UNKNOWN TERMINAL TYPE?
	BEQ	97$			;BR IF YES, DO SCOPE RUBOUT
					;USE NULL TTERL, TTCUP
94$:
	CMP	R2,#T.VT05		;IS THIS A VT05?, NONE WITH LOWER VALUE
	BLE	95$			;BRANCH IF YES
	CMP	R2,#T.V100		;ALL CODES LSS ARE VT5X STYLE
	BLT	96$
	INC	R0			;ASSUME VT100

	.IFT	;RSTS ONLY
	CMP	TTSIZE,#72.		;IF 72 WIDE OR NARROWER
	BLE	95$			;THEN ASSUME VT05
	INCB	FIRQB+12		;IF NOT XON/XOFF
	BNE	96$			;THEN VT5X
	INC	R0			;OTHERWISE VT100

	.IFTF	;RSX AND RSTS
95$:	INC	R0			;OTHERWISE USE THE SECOND (VT05)
;
; R0=0 FOR VT5X, 1 FOR VT05, 2 FOR VT100
;
96$:	JSR	PC,TRMMOV		;SET THE SCOPE CONTROL STRINGS
97$:

	.IFF	;RSX ONLY
	JSR	PC,INITCR		;FORCE INITIAL CRLF

	.IFT	;RSTS ONLY
	JSR	PC,LODSWT		;MAKE SURE INIT MESSAGE IS PRESENT
	JSR	PC,GIVID		;PRINT IDENTIFICATION
	.ENDC	;R$$STS

	MOV	#.ERRBF,NEWLNA		;USE ERROR OUTPUT BUFFER AS NEWLIN
	CMP	#<NEWLNE-NEWLIN>,#516.	;UNLESS NEWLIN BUFFER WAS SPECIFIED
	BLT	100$			;BY EXTENDING THE NEWLIN PSECT
	MOV	#NEWLIN,NEWLNA		;TO AT LEAST 516. BYTES, THEN USE IT
100$:	CLR	FSTRLST			;ZERO THE FIND
	CLR	S1STRLST		; AND SUBSTITUTE
	CLR	S2STRLST		;  LISTS
	MOV	#EXIT,-(SP)		;LAST RETURN IS TO THE EXIT LOGIC
	MOV	SP,SPSAV1		;SET DISASTER STACK POINTER
					;SPSAV2, THE ABORT STACK POINTER
					;IS SET AT END OF SOSINI CODE
	JMP	START2

	.IF	NDF,R$$STS
TTQIO:	DIR$	#TTINI			;ISSUE THE QIO AND WAIT
	BCC	10$			;BRANCH IF NO DIRECTIVE ERROR
	CMP	#IE.UPN,@#$DSW		;NODE POOL EXHAUSTED?
	BNE	20$			;BRANCH IF SOME OTHER ERROR
	JSR	PC,WAITND		;WAIT A BIT
	BR	TTQIO			;AND TRY AGAIN
10$:	TSTB	IOSTS			;SUCCESSFUL?
	BGT	30$			;BRANCH IF YES
20$:	SEC				;INDICATE ERROR
30$:	RTS	PC			;AND RETURN
	.ENDC	;R$$STS


EXIT1::
	.IF	DF,R$$STS
	MOV	#FIRQB+FQFIL,R4		;DO RESET OF ALL
	CLR	(R4)			;CHANNELS AGAIN
	MOVB	#RSTFQ,-(R4)
	CALFIP
	JSR	PC,IOCHK

	.TTRST				;RESET ANY CTL O EFFECTS
	.TTECH				;MAKE SURE WE ARE ECHOING

	.IFF
	CLOSE$	#FILEOUT		;CLOSE THESE JUST IN CASE
	CLOSE$	#FILETMP
	JSR	PC,DTACH1		;DETACH TERMINAL (FOR 11D, IAS)

	.IFTF	;RSX AND RSTS
	EXIT$S				;AND EXIT
	.ENDC



	.END
