MODULE CMDSDO (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!	020705	PHL33878	Peter H. Lipman		12-Nov-1980
!		Force decide mode reads to go to the terminal
!	020703	PHL0703		Peter H. Lipman		2-Jun-1980
!
!		The pattern ?*?* or ?*0?* was inserting a null in the
!	text.  Fix the bounds checking for arbval.  Also allow
!	?" to mean the last one when it goes off the end.  Thus
!	it is the "next" string, but it sticks on the last one.
!

!	CMDSDO - ACTUALLY DO A SUBSTITUTION FOR THE S COMMAND
!
!
!
!	V02.02	09-JUN-76	WTM
!	V02.01G	31-MAY-76	WTM
!


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	CMDABO,		! ABORT COMMAND WITH ERROR CODE
	ILLLTL,		! LINE TOO LONG ERROR
	PRTLIN,		! PRINT A LINE
	SEARCH,		! FIND A STRING
	PRINT,		! PRINT A PLIT
	LISTEN,		! READ A CHAR FROM TTY
	TYPE,		! ECHO TO TTY
	TYPECR,		! TYPE <CR><LF>
	SETDOT,		! MOVE CURRENT LOC
	BFFSR1,		! GET ENOUGH SPACE FOR DECIDE MODE QUERY
	BFFSR2,		! RELEASE THAT GOTTEN ABOVE
	GETDOT;		! FIND CURRENT LOC


EXTERNAL 	
    ARBCNT,				! NUMBER OF TEXT STRINGS FOUND
    ARBTXT,				! DESCRIPTORS OF PARTIAL MATCH STRINGS
    SRANGE: VECTOR,			! RANGE FOR SUB
    SRRET: VECTOR,			! SEARCH RETURN AREA
    S1STRLST: VECTOR,			! SUBSTITUTE 'FIND' STRING LIST
    S2STRLST: VECTOR,			! SUBSTITUTE 'SUB' STRING LIST
    BUFPTR;				! PTR TO NEW LINE BUILD AREA

GBLROUTINE (CMDSDO(J,ADR,SUBADR))=
BEGIN		! DO A SUBSTITUTION
LOCAL
    LLEN,
    LOFF,
    NEWR: VECTOR[4],
    ANS,
    ARBLST;
LOCAL
    I;
LOFF=ANS=.SUBADR=0;
NEWR[2]=-2;
NEWR[3]=0;
LLEN=8;
	BEGIN
	REGISTER
	    PTR1,
	    PTR2,
	    WCT;
	PTR1=.BUFPTR;
	PTR2=.ADR;
	WCT=4;
	DO	BEGIN
		.PTR1=..PTR2;
		PTR1=.PTR1+2;
		PTR2=.PTR2+2;
		END UNTIL (WCT=.WCT-1) EQL 0;
	WHILE .J GTR 0 DO
		BEGIN
		IF .J GTR .S2STRLST THEN
			I=.S2STRLST ELSE
			I=.J;
		.SUBADR=..SUBADR+1;
		ARBLST=0;
		WCT=.SRRET[1]-.LOFF;
		LLEN=.LLEN+.WCT;
		IF .LLEN GTR 500 THEN LINETOOLONG;
		IF .WCT GTR 0 THEN DO BEGIN
			(.PTR1)<0,8>=.(.PTR2)<0,8>;
			PTR1=.PTR1+1;
			PTR2=.PTR2+1;
			END UNTIL (WCT=.WCT-1) EQL 0;
		J=.PTR2;
		PTR2=.(S2STRLST+2*.I);
		IF .PTR2 NEQ 0 THEN DO BEGIN
			LOCAL
			    ARBVAL;
			ARBVAL=0;
			IF .(.PTR2)<0,8> EQL %CHAR(15) THEN
				BEGIN
				PTR2=.PTR2+1;
				UNTIL .(.PTR2)<0,8> EQL %CHAR(15) DO
					BEGIN
					IF .(.PTR2)<0,8> EQL 0 THEN 
						CMDABO(BADISS);
					ARBVAL=.ARBVAL*10+.(.PTR2)<0,8>-'0';
					PTR2=.PTR2+1;
					END;
				IF .ARBVAL EQL 0 OR .ARBVAL GTRU .ARBCNT THEN CMDABO(BADISS);
				END
			ELSE
			IF .(.PTR2)<0,8> EQL %CHAR(2) THEN
				BEGIN
				ARBVAL=.ARBLST;
				IF .ARBVAL LSSU .ARBCNT THEN ARBVAL=.ARBVAL+1;
				END
			ELSE
				(.PTR1)<0,8>=.(.PTR2)<0,8>;
			IF .ARBVAL GTR 0 THEN
				BEGIN
				LOCAL
				    PTR2;
				PTR2=.(ARBTXT-4+4*.ARBVAL);
				DECR XX FROM .(ARBTXT-2+4*.ARBVAL) TO 1 DO
					BEGIN
					(.PTR1)<0,8>=.(.PTR2)<0,8>;
					PTR1=.PTR1+1;
					PTR2=.PTR2+1;
					IF (LLEN=.LLEN+1) GTR 500 THEN LINETOOLONG;
					END;
				ARBLST=.ARBVAL;
				LLEN=.LLEN-1;
				PTR1=.PTR1-1;
				END;
			IF .(.PTR2)<0,8> EQL 0
				THEN EXITLOOP;
			IF (LLEN=.LLEN+1) GTR 500 THEN LINETOOLONG;
			PTR1=.PTR1+1;
			PTR2=.PTR2+1;
			END WHILE 1;
		LOFF=.SRRET[1]+.SRRET[2];
		PTR2=.J+.SRRET[2];
		IF .SRRET[2] EQL 0 THEN
			J=0 ELSE
			J=SEARCH(.ADR,.LOFF,S1STRLST,NEWR,SRRET);
		END;
	DO	BEGIN
		(.PTR1)<0,8>=.(.PTR2)<0,8>;
		PTR1=.PTR1+1;
		IF .(.PTR2)<0,8> EQL 0 THEN
			EXITLOOP;
		IF (LLEN=.LLEN+1) GTR 500 THEN LINETOOLONG;
		PTR2=.PTR2+1;
		END WHILE 1;
	(.PTR1)<0,8>=0;
	END;
LINLEN(.BUFPTR)=((.LLEN+2) AND NOT 1)/2;
IF (.SOSFLG[FSFLG] AND SNOPT) EQL 0 OR (.SOSFLG[FSFLG] AND SDOPT) NEQ 0
	THEN PRTLIN(.BUFPTR,15);
IF (.SOSFLG[FSFLG] AND SDOPT) NEQ 0 THEN
	BEGIN
	BFFSR1();
	DO	BEGIN
		PRINT(PLIT ('D*'));
		ANS=LISTEN(%O'100' + %O'20');
		IF .ANS EQL %CHAR(3) THEN ANS=-2	! CTLC MEANS QUIT
		ELSE
			BEGIN
			TYPE(.ANS);
			TYPECR();
			END;
		IF .ANS GEQ %O'0141' AND .ANS LEQ %O'0172'
			THEN ANS = .ANS - %O'040';
		SELECT .ANS OF
			SET
		      [' ']: ANS=0;
		      ['A']: ANS=-3;
		      ['E']: ANS=-2;
		      ['Q']: ANS=-2;
		      ['Y']: ANS=0;
		      ['N']: ANS=-1;
		      ['G']: (ANS=0;SOSFLG[FSFLG]=.SOSFLG[FSFLG] AND NOT SDOPT);
		      [%O'033']: ANS=-1;
		      [%O'0177']: ANS=-1;
			TES;
		END UNTIL .ANS LEQ 0;
	BFFSR2();
	END;
SETDOT(.ADR);
GETDOT(SRANGE);
RETURN .ANS;
END;


END ELUDOM
