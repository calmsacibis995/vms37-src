	.TITLE	SOSOPN - OPEN AND SCANFILE ROUTINES
	.IDENT	/V03001/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	19-AUG-76
;
; MODIFIED BY:
;
;	V03001	PHL3001		Peter H. Lipman		10-Mar-1982
;		Make new stream format record types work.  Convert to
;	fixed length 512 byte records and force stream mode input.
;
;	020705	PHL33340	Peter H. Lipman		3-Dec-1980
;
;		Make new entry point WRTEOF which is invoked after the
;	last put to FILEOUT.  If the file is empty at this point,
;	force the writing of VBN 1 with a bad record size to guarantee
;	that on a subsequent open SOS will not try to read the old
;	background data.
;
;	020705	PHL0705		Peter H. Lipman		25-Oct-1980
;
;		Make CRTF1 entry point global and use it from SOSINI
;	consolidating the logic for preserving the input file carriage
;	control and choosing an initial file size.
;		Set up default file protection to preserve the original
;	file protection if making a new version of an existing file.
;
;	020702	PHL0702		Peter H. Lipman		14-May-1980
;
;		RSTS specific conditional in REOPEN is wrong,
;	fix it to use the common CLSZRO entry point in SOSRST, 
;	the RSTS specific module.
;		Make CLOSE entry point strictly non-RSTS and 
;	put the RSTS specific close routine in SOSRST
;		OPEN routines need a common fix up record attributes 
;	routine to take care of non record attribute  RSTS files.  
;	Define one in SOSRST and call it from OPN1ST and OPNCOM.
;		If fail to delete .BAK file for RSTS, need a 
;	clear diagnostic message about not producing a new 
;	backup copy and need error return to BLISS caller.  
;	ERASE now returns R0=0 for success, non zero for error.
;
	.MCALL	FDOF$L,FCSBT$,QIOSY$
	FDOF$L
	FCSBT$
	QIOSY$

	FD.WRT=1			;FCS INTERNAL DIRTY BUFFER BIT

	.MCALL	NMBLK$,OFNB$,OFNB$R,CLOSE$,QIO$,EXTK$S
	.MCALL	CCML$,CSI$1,CSI$2

	DATA$	OPN
TMPFNB::NMBLK$

	.SBTTL	VARIOUS FILE NAME UTILITY ROUTINES

	CODE$	OPN

	.ENABL	LSB
ENTRY	SCANFILE			;FILE STRING SCANNER
	JSR	R1,$SAV4		;NEED 4 REGS
	MOV	14(SP),R3		;SAVE FDB ADDRESS
	CLR	R2			;BRACKET FLAG CLEARED
	MOV	SCSTRT,R1		;STARR OF FILE NAME
10$:	MOV	#SCTAB,R4		;SPECIAL CHAR TABLE
	MOV	#SCTABE-SCTAB/4,R0	;NUMBER OF ENTRIES
20$:	CMPB	(R1),(R4)		;SPECIAL CHAR?
	BNE	30$			;NO  NOT THIS ONE
	JMP	@2(R4)			;PROCESS SPECIAL ONE
30$:	CMP	(R4)+,(R4)+		;POINT TO NEXT ENTRY
	SOB	R0,20$			;TEST FOR IT
40$:	INC	R1			;INCLUDE THIS CHARACTER
	BR	10$

50$:	CLR	R2			;  9  ]  CHARACTERS
	BR	40$
60$:	TST	R2			;COMMA    END OF NO
	BEQ	80$			;BRACKETS
	BR	40$			;OTHERWISE, FILE CHAR
70$:	INC	R2			;(   [  CHARACTERS
	BR	40$			

80$:	MOV	SCSTRT,R2		;FILENAME START
	MOV	R1,SCSTRT		;NEXT CHAR AFTER IT
	SUB	R2,R1			;COMPUTE LENGTH OF NAME
	CSI$1	#CSIBLK,R2,R1		;SYNTAX CHECK NAME
	BCS	100$			;ERROR
	CSI$2	R0,OUTPUT		;GET THE FILE
	BCS	100$			;ERROR
	BITB	#CS.WLD!CS.MOR!CS.EQU,C.STAT(R0) ;ONE SPEC, NO WILD CARDS
	BNE	100$
	BITB	#CS.DVF!CS.NMF,C.STAT(R0) ;DEVICE OR FILE NAME MUST BE SPECIFIED
	BEQ	100$
	MOV	R3,R0			;FDB POINTER
	MOV	#CSIBLK+C.DSDS,R2	;DS DESCRIPTOR
	JSR	PC,PARSE		;PARSE THE NAME
	BCS	100$			;BRANCH IF ERROR
	CLR	R0			;SET GOOD RETURN
	RTS	PC
100$:	MOV	#-1,R0			;SET ERROR IN FILE
	RTS	PC

SCTAB:	.WORD	15,80$		;SPECIAL CHARACTER TABLE IN FIELNAMES
	.WORD	'[,70$
	.WORD	'(,70$
	.WORD	'],50$
	.WORD	'),50$
	.WORD	',,60$
	.WORD	'/,80$
SCTABE	=	.		;END OF TABLE MARKER
	.DSABL	LSB

	.SBTTL	FILE UTILITY ROUTINES--OPEN, REOPEN

;
; SWITCH FROM OUTPUT TO INPUT ON THE SPECIFIED FDB
;	2(SP) = FDB ADDRESS
;
ENTRY	CLSOPN
	MOV	2(SP),R0		;FDB ADDRESS

	.IF	NDF,R$$STS		;RSX ONLY
	MOV	F.FNB(R0),-(SP)		;SAVE FILE ID FOR FAST REOPEN

	.IFTF	;RSX AND RSTS
	MOV	R0,-(SP)		;FDB ADR PARAM TO CLOSE
	JSR	PC,CLOSE		;CLOSE(FDBADR)
	MOV	(SP)+,R0		;RECOVER FDB ADDRESS

	.IFT	;RSX ONLY
	MOV	(SP)+,F.FNB(R0)		;RESTORE THE FILE ID
	.ENDC	;R$$STS
;
; OPEN FILE FOR READ
;	2(SP) = FDB ADDRESS
;
ENTRY	OPEN				;OPEN A FILE FOR READING
	MOV	2(SP),R0		;FDB ADDRESS
	MOVB	#FO.RD,F.FACC(R0)	;SET FILE ACCESS
	BIT	#RONLY,SOSFLG		;IF FILE IS BEING OPENED READ ONLY
	BEQ	10$
	MOVB	#FO.RD!FA.SHR,F.FACC(R0) ;THEN OPEN FOR SHARED READ
10$:	CLR	SVSTRM			;NO GET STREAM CONTEXT
	BICB	#3,STRMIN		;NO STREAM INPUT
	BR	OPENX			;AND RETURN

;
; OPEN NEW FILE FOR WRITING
;	2(SP) = FDB ADDRESS
;	BUF+BUFILE = FDB ADDRESS OF INPUT FILE IF ANY
;
ENTRY	CRTFIL				;OPEN A NEW FILE FOR OUTPUT
	MOV	2(SP),-(SP)		;COPY FDB ADDRESS
	JSR	PC,CRTF1		;CALL INTERNAL CREATE FILE ROUTINE
	TST	R0			;WAS IT SUCCESSFUL?
	BGE	10$			;BRANCH IF YES
	JMP	CRTERR			;CREATE FILE FATAL ERROR
10$:	TST	(SP)+			;CLEAN OFF STACK
	RTS	PC			;AND RETURN
;
; 2(SP) = FDB ADDRESS TO OPEN FOR OUTPUT
;
CRTF1::	MOV	R1,-(SP)		;SAVE A REGISTER
	MOV	@#.FSRPT,R1		;ADDRESS OF FCS IMPURE AREA
	ADD	#A.FIPR,R1		;LOC TO STORE DESIRED FILE PROTECTION
	MOV	R1,-(SP)		;SAVE THIS ADDRESS
	MOV	FILPRO,R0		;DESIRED FILE PROTECTION
	CMP	R0,#-1			;NO ACCESS TO ANYONE?
	BEQ	2$			;BRANCH IF YES, DEFAULT PROTECTION
	BIC	#360,R0			;FORCE ALL ACCESS TO OWNER
	MOV	R0,(R1)			;SET LOC FOR DESIRED PROT
2$:	MOV	6(SP),R0		;GET FDB ADDRESS
	MOVB	#FO.WRT!FA.NSP,F.FACC(R0) ;SET FILE ACCESS
	MOVB	#FD.CR,F.RATT(R0)	;INITIALLY CR, LF IMPLIED
	MOVB	#R.VAR,F.RTYP(R0)	;FIRST PUT WILL DETERMINE
	CLRB	SEQBAS			;  THE RECORD TYPE
	MOV	BUF+BUFILE,R1		;INPUT FILE FDB ADDRESS
	TST	F.BDB(R1)		;INPUT FILE OPEN?
	BEQ	10$			;BRANCH IF NOT
	BITB	#FD.FTN,F.RATT(R1)	;IF FORTRAN CARRIAGE CONTROL
	BEQ	4$
	MOVB	F.RATT(R1),F.RATT(R0)	;USE IT FOR OUTPUT AS WELL
;
; USE INPUT FILE SIZE FOR INITIAL ALLOCATION OF OUTPUT FILE
;
4$:	BITB	#FD.REC!FD.SQD,F.RCTL(R1) ;IF RECORD OR SEQUENTIAL DEVICE
	BNE	10$			;THEN NO USEFUL FILE SIZE IS PRESENT
	MOV	F.EFBK+2(R1),F.CNTG(R0)	;USE END OF FILE VBN
	BLT	10$			;IF NEGATIVE, VERY LARGE
	NEG	F.CNTG(R0)		;NEGATIVE FOR NON-CONTIGUOUS ALLOCATION
10$:	MOV	R0,-(SP)		;PUSH THE FDB ADDRESS
	JSR	PC,OPENX
	TST	(SP)+			;CLEAN OFF FDB ADDRESS
	MOV	#-1,@(SP)+		;RESTORE DEFAULT PROTECTION
	MOV	(SP)+,R1		;RESTORE SAVED R1
	RTS	PC			;AND RETURN TO CALLER
;
; 2(SP) = FDB ADDRESS TO OPEN
;
OPENX:
	CCML$	#GCMLB			;CLOSE CMD FILE, AVOID FSR FRAGMENTATION
	MOV	2(SP),R0		;RESTORE FDB ADDRESS
	JSR	PC,OPNCOM		;OPEN THE FILE
OPENX1:	JMP	FCSDON			;RETURN COMPLETION CODE

;
; REOPEN THE SPECIFIED FDB, USED FOR OUTPUT FILES AS WELL AS INPUT FILES
;	NOTE THAT ALL OUTPUT FILES THAT ARE REOPENED MUST BE ON A RANDOM
;	ACCESS DEVICE SO THAT .POINT CAN BE ISSUED.  THE SEQUENTIAL 
;	DEVICE PATH ONLY WORKS FOR INPUT FILES.
;

	.ENABL	LSB

ENTRY	REOPNW				;RE-OPEN AN OUTPUT FILE
					;TO BE REWRITTEN FROM THE BEGINNING
	MOV	2(SP),R0		;FDB ADDRESS
	CLRB	SEQBAS			;FIRST PUT DECIDES THE RECORD TYPE
	MOVB	#R.VAR,F.RTYP(R0)	;DEFAULT TO VARIABLE LENGTH

	.IF	DF,R$$STS
	MOVB	#FO.UPD,F.FACC(R0)	;FIX FILE ACCESS
	.ENDC	;R$$STS

	CLR	F.VBN(R0)		;RESET TO VBN 1
	MOV	#1,F.VBN+2(R0)		;AVOIDING A WRITE AND A READ
	BR	10$

ENTRY	REOPEN				;RE-OPEN AN INPUT FILE
	MOV	2(SP),R0		;FDB ADDRESS
	CLR	SVSTRM			;NO STREAM INPUT CONTEXT
	BIT	#RONLY,SOSFLG		;IF READ-ONLY
	BNE	10$			;THEN REMEMBER STREAM INPUT
	BICB	#3,STRMIN

	.IF	DF,R$$STS
	JSR	PC,CLSZRO		;TAKE CARE OF RSTS CLOSE PROBLEMS
	.ENDC	;R$$STS

10$:	BITB	#FD.SQD,F.RCTL(R0)	;IF BLOCK SEQUENTIAL DEVICE
	BEQ	POINT
	JMP	CLSOPN			;THEN MUST CLOSE AND REOPEN

POINT:	JSR	R1,$SAV3		;OTHERWISE JUST REWIND FILE
	CLR	R1			;BY POINTING BACK TO
	MOV	#1,R2			;VIRTUAL BLOCK 1
	CLR	R3			;BYTE 0
	JSR	PC,.POINT		;REPOSITION THE FILE
	BCC	OPENX1			;BRANCH IF SUCCESSFUL
	CMPB	#IE.EOF,F.ERR(R0)	;EOF IS OK TOO
	BEQ	OPENX1
	JMP	PNTERR			;OTHERWISE REPORT FATAL POSITIONING ERR

	.DSABL	LSB

OPNCOM::
	.IF	DF,R$$STS		;RSTS ONLY
	MOV	F.DVNM(R0),-(SP)	;SAVE GENERIC DEVICE
	MOV	F.UNIT(R0),-(SP)	;AND UNIT
	OFNB$				;OPEN BY FILE NAME BLOCK
	MOV	(SP)+,F.UNIT(R0)	;RESTORE GENERIC UNIT
	MOV	(SP)+,F.DVNM(R0)	;AND DEVICE NAME
	BCS	5$			;BRANCH IF FAILED TO OPEN
	JSR	PC,FIXATT		;FIX UP RECORD ATTRIBUTES
	CLC				;SUCCESSFUL OPEN
5$:	RTS	PC

	.IFF	;RSX ONLY
10$:	OFNB$				;OPEN BY FILE NAME BLOCK
	BCC	30$			;BRANCH IF SUCCESSFUL
	CMPB	#IE.NOD,F.ERR(R0)	;NO NODES FROM FCP?
	BNE	20$			;BRANCH IF OTHER ERROR
	JSR	PC,WAITND		;WAIT FOR A BIT
	BR	10$			;AND TRY AGAIN
20$:	SEC
30$:	RTS	PC
	.ENDC	;R$$STS

;
; OPEN FILE FOR READING THE FIRST TIME
;	WILL ALLOCATE A STREAM BUFFER IF INTERNAL CARRIAGE CONTROL
;	WILL FIX UP END OF FILE IF FILE WAS NOT CLOSED PROPERLY
;
;	2(SP) = FDB ADDRESS
;
ENTRY	OPN1ST
	MOV	R1,-(SP)		;SAVE A REGISTER
	MOV	4(SP),R0		;FDB ADDRESS
	SUB	#<5*2>,SP		;MAKE ROOM FOR STATISTICS BLOCK

	.IF	NDF,R$$STS
	MOV	SP,F.STBK(R0)		;REQUEST STATISTICS BLOCK ON OPEN
	.ENDC	;R$$STS

	MOV	SP,R1			;SAVE STATISTICS BLOCK ADDRESS
	MOV	R0,-(SP)
	JSR	PC,OPEN			;NORMAL OPEN FOR READ
	TST	R0			;SEE IF IT SUCCEEDED
	BNE	40$			;BRANCH IF IT DIDN'T
	MOV	(SP),R0			;RECOVER FDB ADDRESS
	TST	F.EFBK(R0)		;IF EFBK INDICATES EMPTY FILE
	BNE	10$			;BRANCH IF NOT EMPTY
	CMP	F.EFBK+2(R0),#1
	BHI	10$			;BRANCH IF NOT EMPTY
	BLO	5$			;BRANCH IF EMPTY
	TST	F.FFBY(R0)
	BNE	10$			;BRANCH IF NOT EMPTY
;
; FILE IS EMPTY, SET EOF TO END OF ALLOCATED SPACE
;
5$:	CMP	(R1)+,(R1)+		;POINT TO FILE SIZE IN STAT BLOCK

	.IF	DF,R$$STS
	CLR	(R1)			;FAKE A LARGE FILE SIZE
	MOV	#-2,2(R1)		;RSTS DOESN'T RETURN A STAT BLOCK
	.ENDC	;R$$STS

	MOV	(R1)+,F.HIBK(R0)
	MOV	(R1)+,F.HIBK+2(R0)	;SIZE OF FILE
	CMP	-(R1),-(R1)		;IF BOTH WORDS OF FILE SIZE ARE EQUAL
	BNE	7$
	TST	(R1)			;AND ZERO, THEN FILE IS ACTUALLY EMPTY
	BEQ	30$
7$:	MOV	(R1)+,F.EFBK(R0)
	MOV	(R1),F.EFBK+2(R0)	;END OF FILE

	.IF	NDF,R$$STS
	ADD	#1,F.EFBK+2(R0)		;LAST+1 BLOCK, BYTE 0
	ADC	F.EFBK(R0)

	.IFF	;RSTS ONLY
	MOV	#1000,F.FFBY(R0)	;LAST BLOCK BYTE 512.
	.ENDC	;R$$STS

	CLR	F.VBN+2(R0)		;FORCE THE READING
	JSR	PC,POINT		;  OF THE FIRST VBN
	MOV	(SP),R0			;RECOVER FDB ADDRESS

	.IF	NDF,R$$STS
	CMPB	F.RTYP(R0),#R.STM	;NEW STREAM FORMATS?
	BGE	10$			;BRANCH IF YES
	BITB	#FD.PRN,F.RATT(R0)	;IF PRINT FILE CARRIAGE CONTROL
	BNE	30$			;RECORD TYPE AND CARRIAGE CONTROL ARE OK

	.IFTF	;RSX AND RSTS
	MOVB	#FD.CR,F.RATT(R0)	;ASSUME STANDARD CARRIAGE CONTROL
	MOV	F.NREC(R0),R1		;POINTER TO FIRST RECORD

	.IFF	;RSTS ONLY
	MOVB	#R.STM,F.RTYP(R0)	;SEE IF FILE IS STREAM MODE
	CMP	(R1),#512.		;IF FIRST 2 BYTES ARE NOT A
	BHI	10$			;BYTE COUNT, ASSUME STREAM MODE
	.ENDC	;R$$STS

	MOVB	#R.VAR,F.RTYP(R0)	;ASSUME VARIABLE LENGTH RECORDS
	CMP	(R1)+,#2		;IF RECORD SIZE IS UNDER 2
	BLT	10$			;CANNOT BE R.SEQ
	JSR	PC,CHKCHR		;SEE IF FIRST 2 DATA BYTES
	JSR	PC,CHKCHR		;COULD BE TEXT, IF NOT, R.SEQ
10$:
	.IF	NDF,R$$STS
	MOVB	F.RTYP(R0),R1		;FETCH THE RECORD TYPE
	SUB	#R.STM-1,R1		;STREAM, STREAM_LF, OR STREAM_CR?
	BLE	11$			;BRANCH IF FIXED, VARIABLE, OR VFC
	MOVB	#R.FIX,F.RTYP(R0)	;SET NEW STREAM TYPES TO FIXED LENGTH
	MOV	#256.,F.RSIZ(R0)	; 256 BYTE RECORDS
	CLRB	F.RATT(R0)		;ALL CARRIAGE CONTROL IS IMBEDDED
	BR	16$			;GO FORCE STREAM MODE PROCESSING
11$:
	.IFF
	JSR	PC,FIXATT		;FIX UP RECORD ATTRIBUTES
	CMPB	#R.STM,F.RTYP(R0)	;IF RSTS STREAM MODE, SKIP THIS
	BEQ	30$
	.ENDC

	BITB	#FD.PRN!FD.FTN!FD.CR,F.RATT(R0) ;INTERNAL CARRIAGE CONTROL?
	BEQ	15$			;BRANCH IF YES
	CMPB	#R.VAR,F.RTYP(R0)	;VARIABLE LENGTH RECORD FILE
	BNE	30$
	MOV	F.NREC(R0),R1		;WITH FF AS FIRST CHAR OF 1ST RECORD
	CMP	(R1)+,#1
	BLE	30$
	CMPB	(R1),#14
	BNE	30$
15$:	MOV	#1,R1			;STREAM FORMAT INDICATOR
16$:	BISB	R1,STRMIN		;SET STREAM FILE CODE - LOW 2 BITS
					; 1 = STREAM
					; 2 = STREAM_LF
					; 3 = STREAM_CR
	MOV	STRMBF,R1		;YES, STREAM BUFFER ALREADY ALLOCATED?
	BNE	25$			;BRANCH IF YES
;
; MUST ALLOCATE A 512 BYTE STREAM BUFFER
;
	MOV	BUF+BUFLEN,R1		;SIZE OF TEXT BUFFER
	EXTK$S	#8.			;TRY EXTENDING TASK BY 8 64 BYTE BLOCKS
	BCC	20$			;BRANCH IF SUCCESSFUL
	SUB	#512.,R1		;TRY TO TAKE A BUFFER AWAY FROM TEXT BUFFER
	CMP	R1,#MINBF		;ENOUGH LEFT TO RUN?
	BLO	60$			;BRANCH IF NOT, SAY CANNOT OPEN
	MOV	R1,BUF+BUFLEN		;SET SMALLER SIZE
	MOV	R1,SOSFLG+<BUFSZ*2>	;SET SIZE FOR =BUF
20$:	ADD	BUF,R1			;FORM ADDRESS OF STREAM BUFFER
	MOV	R1,STRMBF		;AND STORE IT
25$:	MOV	R1,F.URBD+2(R0)		;RECORD BUFFER ADDRESS
	MOV	#510.,F.URBD(R0)	;AND SIZE
30$:	CLR	R0			;INDICATE SUCCESSFUL OPEN
40$:	ADD	#<6*2>,SP		;CLEAN FDB ADR, STATBLK OFF STACK
	MOV	(SP)+,R1		;RESTORE SAVED REGISTER
	RTS	PC			;AND RETURN

60$:	CLOSE$	R0			;CLOSE THE FILE
	MOVB	#IE.NBF,F.ERR(R0)	;INDICATE NOT ENOUGH BUFFER SPACE
	MOVB	#IE.NBF,R0
	BR	40$			;AND RETURN THROUGH COMMON EXIT
;
; IF CHAR POINTED TO BY R1 IS NOT A TEXT CHARACTER, SET R.SEQ RECORD TYPE
;
CHKCHR:	CMPB	(R1),#7
	BLT	10$			;BRANCH IF NEG OR LSS "BELL"
	CMPB	(R1),#40
	BGE	20$			;BRANCH IF NOT A CONTROL CHAR
	CMPB	(R1),#15
	BLE	20$			;BRANCH IF FORMAT CHAR OR BELL
10$:	MOVB	#R.SEQ,F.RTYP(R0)	;SET SEQUENCED RECORD TYPE
20$:	TSTB	(R1)+
	RTS	PC

;
; WRTEOF - WRITE END OF FILE
;	THIS ROUTINE IS CALLED AFTER THE LAST PUT TO THE OUTPUT FILE.
;
ENTRY	WRTEOF				;WRTEOF()
	TSTB	SEQBAS			;IF NO RECORDS PUT TO THIS FILE
	BNE	20$
	TST	F.HIBK+2+FILEOUT	;AND IF SOME BLOCKS WERE ALLOCATED
	BEQ	20$
	MOV	#1,F.EFBK+2+FILEOUT	;FORCE EOF TO INDICATE THAT
	CLR	F.FFBY+FILEOUT		;THE FILE IS EMPTY
	MOV	#-1,@F.NREC+FILEOUT	;STORE A BAD RECORD SIZE
	BISB	#FD.WRT,F.BKP1+FILEOUT	;INDICATE THAT THE BUFFER IS DIRTY
20$:	RTS	PC

	.IF	NDF,R$$STS		;RSTS VERSION IN SOSRST
ENTRY	CLOSE			;CLOSE A FILE
	MOV	2(SP),R0		;FDB ADDRESS
	CLOSE$				;CLOSE THE FDB
	BCC	CLSRET
	JMP	CLSERR			;REPORT CLOSE ERROR
	.ENDC	;R$$STS

ENTRY	COPDEF				;COPY FILE NAME BLOCK
	JSR	R1,$SAV2		;FROM ONE FDB TO ANOTHER
	MOV	10(SP),R1		;FROM FDB POINTER
	MOV	12(SP),R2		;TO FDB
	ADD	#F.FNB,R2
;
; R1=FDB ADDRESS, SAVE FNB PORTION OF THIS FDB
; R2=FNB ADDRESS TO SAVE IT IN
; OUTPUT RO,R1,R2 ALTERED
;
SAVFNB::ADD	#F.FNB,R1
	MOV	#S.FNBW,R0		;WORDS IN LENGTH
5$:	MOV	(R1)+,(R2)+		;COPY IT
	SOB	R0,5$
CLSRET:	RTS	PC			;THEN RETURN

;
; SWAP THE CONTENTS OF THE SPECIFIED FDB'S
;
ENTRY	SWPFDB
	JSR	R1,$SAV3		;SAVE SOME REGISTERS
	MOV	12(SP),R1		;LOAD THE
	MOV	14(SP),R2		;  FDB ADDRESSES
	MOV	#S.FDB/2,R0		;NUMBER OF WORDS TO SWAP
10$:	MOV	(R1),R3
	MOV	(R2),(R1)+
	MOV	R3,(R2)+
	SOB	R0,10$			;SWAP THEM
	RTS	PC			;AND RETURN

	.SBTTL	FILE UTILTY ROUTINES -- CLSDEL, ERASE

	.ENABL	LSB

ENTRY	CLSDEL				;CLOSE AND DELETE THE FILE
	MOV	2(SP),R0		;FDB ADDRESS OF FILE
					;MUST NOT BE FILEBAK
	TST	F.BDB(R0)		;IS FILE OPEN
	BEQ	60$			;BRANCH IF NO, SKIP CLOSE, SKIP DELETE
	CLOSE$	R0			;CLOSE THE FILE
					;AND FALL THROUGH TO DELETE

ENTRY	ERASE
	MOV	2(SP),R0		;FDB ADDRESS FOR DELETE
10$:	CMP	R0,#-1			;DELETE .BAK FILE?

	.IF	DF,R$$STS
	BNE	40$			;NO.  NORMAL ONE
	MOV	#FILELST,-(SP)		;USE FILELST FOR TEMP
	MOV	#FILEIN,-(SP)
	JSR	PC,COPDEF		;NAME BLOCK
	MOV	#FILELST,R0		;SET FDB PTR IN R0
	MOV	BAKBAK,F.FNB+N.FTYP(R0)	;SET .BAK EXTENSION
	CMP	(SP)+,(SP)+		;POP 2
40$:
	.IFF	;R$$STS
	BEQ	60$			;DELETE ".BAK" IS NOP FOR RSX
	TST	F.FVER(R0)		;ZERO VERSION MEANS TROUBLE
	BEQ	60$			;DELETE ZERO VERSION NOT ALLOWED
	.ENDC	;R$$STS

50$:	JSR	PC,.DLFNB		;DELETE THE FILE
	BCC	60$			;BRANCH IF OK

	.IF	DF,R$$STS
	CMP	2(SP),#-1		;ERROR FOR THE ".BAK" FILE?
	BNE	55$			;BRANCH IF NOT, REPORT THE ERROR
	CMPB	#IE.NSF,F.ERR(R0)	;"NO SUCH FILE" IS REALLY OK
	BEQ	60$			;BRANCH IF IT WAS
	JSR	PC,BAKERR		;REPORT FAILURE TO DELETE .BAK
	BR	58$
	.ENDC	;R$$STS

55$:	JSR	PC,DELERR		;PRINT DELETE ERROR
58$:	MOV	PC,R0			;NON-ZERO RETURN FOR ERROR
	RTS	PC
60$:	CLR	R0			;SUCCESSFUL RETURN
	RTS	PC

	.DSABL	LSB


	.END
