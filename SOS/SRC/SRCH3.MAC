	.TITLE	SRCH3   -  STRING SEARCH ROUTINES
	.IDENT	/V03001/

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; MODIFIED BY:
;
;	V03001	PHL42023	Peter H. Lipman		8-Mar-1982
;		Searching for "any number of occurrences of x"
;	followed by "not x" was incorrectly failing to match.
;
;
	.GLOBL	SEARCH,NXTLINE,PSTRNG
	.GLOBL	$SAV5,SOSFLG,EMATCH,SEPARATOR,MATCHR

	CODE$	SRCH
TABLE:	.BYTE	1,3,1,1,1,7,3,1,1,1,1,1,1,1,3,1
	.BYTE	3,1,1,1,3,1,7,3,3,1,1,1,3,3,7,1
	.BYTE	1,1,1,1,10,1,1,1,1,1,1,1,1,1,10,1
	.BYTE	0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
	.BYTE	1,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
	.BYTE	20,20,20,20,20,20,20,20,20,20,20,1,1,1,1,10
	.BYTE	1,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
	.BYTE	20,20,20,20,20,20,20,20,20,20,20,1,3,1,1,1

	DATA$	SRCH

CNBOT:
	.=.+<5*6>			;SPACE FOR ^N STACK
				; 5 ENTRIES, 6 BYTES EACH
CNSTK:				;LABEL DEFINED

STRFST:	.WORD	0
STRLST:	.WORD	0		;ADDRESS OF LAST STRING
TXTAD:	.WORD	0		;CURRENT TEXT START ADR
NFLG:	.WORD	0		;^N FAIL FLAG
LINAD:	.WORD	0		;CURRENT LINE ADDRESS
ARBPTR:				; POINTER TO ARB ENTRY CURRENT
ARBCNT::.WORD	0		; COUNT OF ENTRIES IN ARB TABLE
ARBTXT::.BLKW	2*50.		; POINTERS TO ARBITRARY TEXT IN LINE
				;  2 WORDS/ENTRY, ROOM FOR 50 ENTRIES

	CODE$	SRCH

SPCTBL:	.WORD	0	; 0	NULL - RESERVED FOR END OF SEARCH STRING
	.WORD	LLET	; ^A	ANY LETTER
	.WORD	0	;RESERVED - NEXT STRING IN S COMMAND
	.WORD	0	; ^C
	.WORD	0	; ^D
	.WORD	LNOT	; ^E	NEGATE NEXT POSITION
	.WORD	LUPC	; ^F	UPPER CASE LETTER
	.WORD	0	; ^G BELL
	.WORD	0	; ^H 
	.WORD	0	; ^I TAB
	.WORD	0	; ^J LF
	.WORD	0	; ^K FF
	.WORD	0	; ^L VT
	.WORD	0	; ^M CR
	.WORD	LARBIT	; ^N	ANY NUMBER OF
	.WORD	0	;RESERVED - NEXT STRING IN S COMMAND
	.WORD	LDEC	; ^P	DECIMAL DIGIT
	.WORD	0	; ^Q
	.WORD	0	; ^R
	.WORD	0	; ^S
	.WORD	LANY	; ^T	MATCH ANY CHARACTER
	.WORD	0	; ^U
	.WORD	L1ARB	; ^V	AT LEAST ONE OF
	.WORD	LLCL	; ^W	LOWER CASE LETTER
	.WORD	LALP	; ^X	ALPHANUMERIC
	.WORD	0	; ^Y
	.WORD	0	; ^Z
	.WORD	0	; 
	.WORD	LSPC	; 34	SPACE OR TAB
	.WORD	LEOL	; 35	EITHER END OF LINE
	.WORD	LQUOT	; 36	^^ QUOTE NEXT CHARACTER


	CODE$	SRCH

SEARCH:
	JSR	R1,$SAV5	;SAVE ALL REGISTERS
	MOV	#CNSTK,R5	;INIT STACK POINTER TO NULL
	MOV	26(SP),R2	;ADDRESS OF FIRST LINE
	MOV	R2,LINAD	;SAVE IT
	ADD	24(SP),R2	;OFFSET TO START LOOKING AT
	ADD	#10,R2		;TEXT START OFFSET
	MOV	R2,TXTAD	;ADR TO LOOK AT
	MOV	22(SP),R3	;STRING ADDRESSES
	MOV	(R3),R0		;NUMBER OF STRINGS
	ASL	R0
	ADD	R0,R3		;ADR OF LAST STRING
	MOV	2(R3),STRLST	;TEXT ADR LAST STRING
	MOV	22(SP),R3	;START OF STRINGS AGAIN
	TST	(R3)+		;FIRST PIOINTER
	MOV	R3,STRFST	;SAVE FIRST POINTER ADR

STLIN:	MOV	STRFST,R3	;INIT STRING POINTER
NXSTR:	MOV	(R3)+,R4	;THIS STRING TEXT ADDRESS
	MOV	TXTAD,R2	;TEXT TO START COMPARING
	CMP	R4,STRLST	;END OF STRINGS?
	BEQ	FAIL		;YES.  NO MATCH ON THIS PLACE
	TSTB	(R4)		; NULL STRING AFTER FIRST IS TO
	BEQ	NXSTR		; BE IGNORED - NO ERROR
	CLR	R0		;POSITIVE MATCH TO START
	CLR	NFLG		;NOT A ^N YET
	MOV	#ARBTXT,ARBPTR	; POINTER TO ARBITRARY TEXT PTRS

REQCHR:	MOVB	(R4)+,R1	;CHAR IN SEARCH STRING
	BNE	TSTSPC		; CHECK IT IF CHAR THERE
	JMP	ERRISS		; BAD IF NONE
TSTSPC:	TSTB	MATCHR		;ARE SPECIAL MATCH CHARACTERS ENABLED?
	BEQ	TSTCHR		;BRANCH IF NOT
	BITB	#2,TABLE(R1)	;SPECIAL CHARACTER?
	BEQ	TSTCHR		;NO..TEST FOR SIMPLE MATCH
	JMP	SPCCHR		; TRY SPECIAL CHARACTER ROUTINE
TSTCHR:	CMPB	(R2),R1		;CHAR MATCH?
	BEQ	SAME		;YES.  A MATCH
	BITB	#20,TABLE(R1)	;A LETTER?
	BEQ	DIFF1		;NO.  NO MATCH
	BIT	#EMATCH,SOSFLG+<FSFLG*2> ;A NON-EXACT MATCH OK?
	BNE	DIFF1		;NO.  DIFFERENT
	BIT	#40,R1		;UPPER OR LOWER
	BNE	CHLC		;CHARACTER IN LOWER CASE
	BIS	#40,R1		;IF UPPER, MAKE LOWER
	BR	TSTLC
CHLC:	BIC	#40,R1		;MAKE UPPER IF LOWER
TSTLC:	CMPB	(R2),R1		;TEST ALTERNATE CASE
	BEQ	SAME		;TREAT AS SAME IF OK
DIFF1:	TSTB	(R2)		;IF END OF LINE
	BEQ	NOMAT		;THEN SKIP NEGATIVE TEST
DIFF:	TST	R0		;DID WE WANT POS OR NEG
	BMI	MATCHA		;WANTED NON-MATCHA..OK
NOMAT:	CMP	R5,#CNSTK	;A ^N PENDING?
	BEQ	NXSTR		;NO.  STRING FAILED
	INC	NFLG		;SET ^N FLAG FOR MATCH
	CLR	R0		;RESET POS/NEG INDICATOR
	MOV	(R5)+,ARBPTR	; RESTORE POINTER TO STRINGS
	MOV	(R5)+,R2	;RESTORE THESE TWO
	MOV	(R5)+,R4	;POINTERS TO TEXT
	BR	REQCHR		;TRY ANOTHER OF THE ^N CHAR

MATCHA:	TSTB	(R2)		; IF END OF LINE,
	BEQ	NOTN		; THEN DON'T ENTER ANOTHER ARBITRARY STRING
	MOV	ARBPTR,R1	; MATCH AN ARBITRARY CONSTRUCT
	MOV	R2,(R1)+	; SAVE STRING DESCRIPTOR IN TABLE
	MOV	#1,(R1)+	; SINGLE CHAR MATCHED HERE
	MOV	R1,ARBPTR	; NEXT ENTRY POINTER
	BR	MATCH		; CHAR WAS A MATCH

SAME:	TST	R0		;WANT NEG MATCH?
	BMI	NOMAT		;YES.  NOT SAME THEN
MATCH:	TST	NFLG		;A ^N PENDING
	BEQ	NOTN	
	SUB	#6,R5		;UNDO THE THREE POPS
	INC	2(R5)		;AND INC THE TEXT POINTER
	MOV	(R5),R1		; ARBPTR FOR THIS ^N (+4)
	INC	-2(R1)		; LENGTH OF STRING JUST INCREASED
	MOV	R1,ARBPTR	; RESTART TABLE AFTER ^N POINT AGAIN
NOTN:	CLR	NFLG		;CLEAR ^N FLAG
	CLR	R0		;AND POS/NEG INDICATOR
	TSTB	(R2)		;ANY MORE TEXT IN LINE
	BEQ	EOL		;NO.
	INC	R2		;INCREMENT TEXT POINTER
EOL:	MOVB	(R4)+,R1	;NEXT SEARCH STRING CHAR
	BNE	TSTSPC		;NOT AT END..TEST FOR IT

;	MATCH FOUND...RETURN INFO ON IT

FOUND:
	BIT	#NOMATC,SOSFLG+<2*FSFLG>	; NEGATIVE MATCH WANTED?
	BNE	RTFAIL			; IF SO, THIS LINE DOESN'T MATCH

RTSUC:
	MOV	16(SP),R1	;POINTER TO RETURN AREA
	MOV	LINAD,(R1)+	;LINE ADDRESS
	MOV	TXTAD,(R1)	;COMPUTE OFFSET
	SUB	LINAD,(R1)	;TO START OF
	SUB	#10,(R1)+	;MATCHING STRING
	MOV	R2,(R1)		;TEXT LENGTH
	SUB	TXTAD,(R1)	;OF MATCHING SYTRING
	MOV	ARBPTR,R0	; COMPUTE THE NUMBER OF
	SUB	#ARBTXT,R0	; TEXT SUBSTRINGS WE FOUND
	ASR	R0
	ASR	R0
	MOV	R0,ARBCNT	; MAX VALUE FOR ?* <N> ?*
	MOV	R3,R0		;COMPUTE THE NUMBER
	SUB	STRFST,R0	;OF THE MATCHING STRING
	ASR	R0
	RTS	PC		;RETURN TO BLIS CODE

FAIL:	TSTB	(R2)		;AT END OF LINE?
	BEQ	NXLIN		;YES. GET NEW ONE
	INC	TXTAD		;INC POINTER TO TEXT
JSTLIN:	JMP	STLIN

NXLIN:
	BIT	#NOMATC,SOSFLG+<2*FSFLG>	; NEGATIVE MATCH WANTED?
	BNE	RTSUC			; IF SO, THIS LINE IS IT

RTFAIL:
	MOV	LINAD,-(SP)	;GET ADDRESS OF
	MOV	#1,-(SP)	;NEXT LINE IN BUFFER
	JSR	PC,NXTLINE
	MOV	R0,LINAD	;SAVE LINE POINTER
	MOV	R0,2(SP)	;SEE IF PAST OUR RANGE
	MOV	24(SP),(SP)	;RANGE POINTER
	ADD	#10,R0		;SET TEXT POINTER
	MOV	R0,TXTAD
	JSR	PC,PSTRNG	;CHECK LIMITS
	CMP	(SP)+,(SP)+	;POP TWO
	TST	R0		;TEST RANGE
	BEQ	JSTLIN		; BR IF OK TO CONTINUE

;	END OF LINE OR RANGE, NO MATCH FOUND

	CLR	R0		;RETURN 0 FOR NO STRING
	RTS	PC		;RETURN

ERRISS:	MOV	#-1,R0		;ERROR INDICATOR
	RTS	PC



SPCCHR:	CMP	R1,#174		; SPECIAL SPECIAL CHAR?
	BEQ	LSEP		; YES .. SEPARATOR REQEST
	ASL	R1		; ALL OTHERS USE JUMP TABLE
	JMP	@SPCTBL(R1)	; GO TO IT!!!


LLET:			; ^A ?! ANY LETTER
	MOVB	(R2),R1		; CHAR IN TEXT
	BITB	TABLE(R1),#20	; IS IT A LETTER?
	BR	NEQSAM		; IF NEQ, THEN SAME ELSE DIFF

LNOT:			; ^E ?% NOT OF NEXT CHARACTER
	COM	R0		; SET FLAG
	JMP	REQCHR		; MUST HAVE ANOTHER AFTER IT

LUPC:			; ^F ?& UPPER CASE LETTER
	MOVB	(R2),R1		; GET CHAR TO MATCH
	BITB	TABLE(R1),#20	; IS IT A LETTER?
	BEQ	LDIFF		; NO
	BIT	R1,#40		; CHECK CASE
	BR	EQLSAM		; IF OFF (EQL) THEN MATCH ELSE DIFF

LARBIT:			; ^N ?) ANY NUMBER OF
L1ARB:			; ^V ?1 AT LEAST 1 OF
	CMP	R5,#CNBOT	; TOO MANY ALREADY?
	BEQ	ERRISS		; YES - STACK OVERFLOW
	MOV	R4,-(R5)	; PUSH POINTER TO STRING MATCH CHAR
	MOV	R2,-(R5)	; AND POINTER INTO TEXT LINE
	MOV	ARBPTR,R1	; NEXT ENTRY IN TABLE
	MOV	R2,(R1)+	; START OF MATCHING STRING
	CLR	(R1)+		; LEN IS ZERO SO FAR
	MOV	R1,-(R5)	; SAVE POINTER TO TABLE ENTRY
	MOV	R1,ARBPTR	; ALSO FOR NEXT GUY
	CMPB	-1(R4),#'V-100	; WAS IT "1 OR MORE" 
	BNE	10$		; NO..0 OK
	JMP	NOMAT		; FORCE AT LEAST ONE
10$:	MOVB	(R4)+,R1	; PASS OVER THE CHAR WE MATCH
	BEQ	ERRISS		; MUST BE ONE THERE
	BITB	TABLE(R1),#4	; PASS OVERABLE?
	BNE	10$		; YES.
	JMP	REQCHR		; MUST HAVE ANOTHER AFTER THIS


LALP:			; ^X ?9 ALPHANUMERIC
	MOVB	(R2),R1		; CHAR TO TEST
	BITB	TABLE(R1),#20	; A LETTER?
	BNE	SPCSAM		; YES..DEFINITELY OK

LDEC:			; ^P ?+ DECIMAL DIGIT
	CMPB	(R2),#'0	; CHECK RANGE
	BLT	LDIFF
	CMPB	(R2),#'9
	BGT	LDIFF
SPCSAM:
	TST	R0			; WANTED AN INVERS MATCH?
	BMI	LNOMAT			; YES..NOT A MATCH THEN
LMATA:	JMP	MATCHA			; WAS A MATCH, INCLUDE IN TABLE
LNOMAT:	JMP	NOMAT			; NOT A MATCH

;
; CHARACTERS ARE DIFFERENT, BUT IF LOOKING FOR A MISMATCH AND THIS IS
; THE END OF THE LINE, THEN THESE INDEED MISMATCH. I.E. END OF LINE
; DOES NOT MATCH: (?%?/ NOT ANY, ?%?: NOT A SEPARATOR)
;
LDIFF1:	JMP	DIFF1

LANY:			; ^T ?/ ANY CHARACTER
	TST	R0		; MATCHING?
	BPL	10$
	TSTB	(R4)		; ^E^T MUST BE AT END
	BNE	ERRISS
10$:	TSTB	(R2)		; ONLY THING NOT MATCHING IS EOL
NEQSAM:	BNE	SPCSAM		; IF NOT EQUAL, THEN SAME, ELSE DIFF
;
; CHARACTERS ARE DIFFERENT.  IF LOOKING FOR A MISMATCH AND THIS IS
; THE END OF THE LINE, THEN THESE DO MATCH, I.E. EOL MATCHES:
; ?%! NOT ALPHA EITHER CASE, ?%& NOT UPPER CASE ALPHA,
; ?%9 NOT ALPHANUMERIC, ?%+ NOT NUMERIC, ?%2 NOT LOWER CASE ALPHA
; ?%< NOT SPACE OR TAB
;
LDIFF:	JMP	DIFF			; CHARACTERS ARE DIFFERENT

LLCL:			; ^W ?2 LOWER CASE LETTER
	MOVB	(R2),R1		; CHAR TO TEST
	BITB	TABLE(R1),#20	; A LETTER?
	BEQ	LDIFF		; NO
	BIT	#40,R1		; CORRECT CASE?
	BR	NEQSAM		; IF NEQ THEN SAME ELSE DIFF

LSPC:			; ^\ ?< SPACE OR TAB
	CMPB	(R2),#11
	BEQ	SPCSAM
	CMPB	(R2),#40
EQLSAM:	BEQ	SPCSAM
	BR	LDIFF

LEOL:			; ^] ?> EITHER END OF LINE
	TSTB	(R4)		; LAST CHAR OF SEARCH STRING?
	BNE	10$		; BRANCH IF NOT, SEE IF BEGIN OF LINE
	TSTB	(R2)		; END OF LINE?
	BR	EQLSAM		; MATCH IF EQL
10$:	MOV	R2,R1		; CHECK FOR BEGINNING OF LINE
	SUB	LINAD,R1	; COMPUTE OFFSET FROM START
	CMP	R1,#10		; TEXT OFFSET?
	BNE	LDIFF1		; NOT SAME, NOT BEGIN OF LINE
	TST	R0		; WANTED AN INVERSE MATCH?
	BMI	LMATA		; BRANCH IF YES, TREAT (R2) AS THE CHAR
				; MATCHING "NOT BOL"
	JMP	EOL		; DON'T INC LINE TEXT POINTER
LQUOT:			; ^^ ?7 QUOTE NEXT CHARACTER
	MOVB	(R4)+,R1	; GET NEXT CHARACTER
	BEQ	ERRISS		; MUST BE ONE
	JMP	TSTCHR		; TEST IT DIRECTLY

LSEP:			; VERTICAL BAR  ?: SEPARATOR
	MOVB	(R2),R1		; CHAR TO TEST
	BITB	TABLE(R1),#1	; A SURE SEP?
	BNE	SPCSAM
	BITB	TABLE(R1),#10	; A MAYBE SEP?
	BEQ	LDIFF1		; NOT EVEN THAT
	BIT	#SEPARATOR,SOSFLG	; /SEPARATOR SET?
	BEQ	LDIFF1
	BR	SPCSAM

	.END
