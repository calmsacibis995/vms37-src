	.TITLE	SOSREC - RECORD I/O
	.IDENT	/V03001/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	23-FEB-76
;
; MODIFIED BY:
;
;	V03001	PHL3001		Peter H. Lipman		11-Mar-1982
;
;			Implement the new standard stream format and 
;		the new VAX stream formats STREAM_LF and STREAM_CR.
;
;	020703	PHL0703		Peter H. Lipman		11-Jun-1980
;
;			Remove RSTS code for zeroing the word in front 
;		of the record being put.  The FCS bug that required 
;		that kludge is fixed in RSTS V7.0
;			Fix RSTS PUT code to specially handle records 
;		terminated by <LF>
;
	.MCALL	FDOF$L,FCSBT$,IOERR$
	FDOF$L
	FCSBT$
	IOERR$

	.MCALL	GET$S,PUT$S

	.SBTTL	GET - READ NEXT LINE TO SOS BUFFER

	CODE$	REC

ENTRY	GET
	MOV	12(SP),R0		;ADDRESS OF FDB
	BITB	#3,STRMIN		;STREAM INPUT?

	.IF	DF,R$$STS
	BEQ	2$			;BRANCH IF NOT
	JMP	GSTRM			;YES, PROCESS STREAM INPUT

	.IFF	;RSX ONLY
	BNE	GSTRM			;BRANCH IF YES

	.IFTF	;RSX AND RSTS
2$:	MOV	R1,-(SP)		;SAVE SOME REGISTERS
	MOV	R2,-(SP)

	.IFT	;RSTS ONLY
	TSTB	FFLAST			;LAST RECORD END IN FF
	BEQ	5$			;BRANCH IF NOT
	CLRB	FFLAST			;YES, RESET THE FLAG
4$:	INC	@14(SP)			;CHANGE THE PAGE NUMBER
	MOV	10(SP),@12(SP)		;NEW STARTING LINE NUMBER

	.IFTF	;RSX AND RSTS
5$:	GET$S	,20(SP),#512.		;GET NEXT RECORD
	BCC	10$			;GOT IT OK
7$:	MOV	#-1,R2			;SET EOF IND
	CMPB	#IE.EOF,F.ERR(R0)	;WAS IT EOF?
	BNE	8$			;NO
	JMP	70$			;YES.  EXIT NOW
8$:	CMPB	#IE.RBG,F.ERR(R0)	;LINE TOO LONG?
	BEQ	9$			;YES. CAN RECOVER
	JMP	80$			;NO  BAD ONE
9$:
	.IFT	;RSTS ONLY
	MOV	20(SP),R1		;BUFFER AREA FOR LINE
	MOVB	#15,511.(R1)		;SET TERM CHAR
	MOV	#511.,F.NRBD(R0)	;SET LINE LENGTH
	MOV	20(SP),F.NRBD+2(R0)	;AND LINE POINTER

	.IFTF	;RSX AND RSTS
10$:
	.IFT	;RSTS ONLY
	CMPB	F.RTYP(R0),#R.STRM	;STREAM INPUT FILE?
	BNE	30$			;NO..READ RMS FILE
	MOV	F.NRBD(R0),R2		;RECORD LENGTH
	BEQ	25$			; ZERO LENGTH RECORD
	MOV	F.NRBD+2(R0),R1		;BUFFER ADDRESS
	CMP	R2,#1			;IS IT A FORM FEED?
	BNE	15$
	CMPB	(R1),#14
	BEQ	4$			;SET NEW PAGE, GET NEXT RECORD
15$:	ADD	R1,R2			;POINT TO END OF RCD
	CMPB	-(R2),#14		;TERM ON FORM FED?
	BNE	18$			;NO.
	INCB	FFLAST			;SET FLAG FOR NEXT GET
	DEC	F.NRBD(R0)		;DROP FF CHAR
	BR	25$
18$:	CMPB	(R2)+,#12		;SPECIAL CASE OF LF
	BNE	25$			;IN BASIC FILES
	BIT	SOSFLG,#BASIC		;
	BEQ	23$
	MOVB	#15,(R2)+		;INTO THE RECORD
23$:	MOV	#512.,R1		;COMPUTE NEW MAX LEN
	ADD	20(SP),R1		;AS END OF ORIGINAL BUFFER
	SUB	R2,R1			;MINUS START OF THE NEXT SEGMENT
	GET$S	,R2,R1			;READ CONTINUATION LINE
	BCS	7$			;ERROR...HOW??
	BR	10$			;GO PROCESS LINE SEGMENT

25$:	MOV	F.NRBD(R0),R2		;RECORD LENGTH
	MOV	F.NRBD+2(R0),R1		;ADDRESS
	SUB	20(SP),R1		;LEN BEFORE SEGMENT READ
	ADD	R1,R2			;ACTUAL LINE LENGTH
					;(DIFF ONLY FOR BASIC)

	BIT	#1,@6(SP)		;SHOULD WE SEARCH?
	BNE	65$			;NO..ASSUME NO LINE NUMBER
	BR	50$
	.ENDC
30$:
	MOV	F.NRBD+2(R0),R1		;R1=RECORD ADDRESS
	MOV	F.NRBD(R0),R2		;R2=RECORD SIZE
	BEQ	45$			;BRANCH IF NULL RECORD
;
; IS THIS RECORD A PAGE MARK, 1 BYTE RECORD  WITH A FF?
;
	CMPB	(R1),#14		;FORM FEED?
	BNE	45$			;BRANCH IF NOT
	CMP	R2,#1			;ONE BYTE RECORD?

	.IF	DF,R$$STS
	BEQ	4$			;SET NEW PAGE, GET NEXT RECORD

	.IFF	;RSX ONLY
	BNE	45$			;BRANCH IF NOT
	INC	@14(SP)			;NEXT PAGE NUMBER
	MOV	10(SP),@12(SP)		;NEW STARTING LINE NUMBER
	BR	5$			;GET NEXT RECORD
	.ENDC

45$:	BIT	#1,@6(SP)		;SHOULD WE SCAN FOR LINE?
	BNE	65$			;NO--NOT IF SET
	CMPB	#R.SEQ,F.RTYP(R0)	;IF SEQUENCED RECORDS
	BNE	50$

	.IF	NDF,R$$STS
	BITB	#FD.PRN,F.RATT(R0)	;IF PRINT FILE FORMAT
	BNE	50$			;THEN F.SEQN IS CARRIAGE CONTROL INFO
	.ENDC

	MOV	F.SEQN(R0),@12(SP)	;STORE THE RECORD'S SEQUENCE NO.
	BR	65$
50$:
	.IF	NDF,R$$STS
	CMP	F.RCNM+2(R0),#2		;WILL BE 2 AFTER FIRST GET
	BHI	51$			;BRANCH IF NOT FIRST RECORD
	BIT	#BASIC,SOSFLG		;IF BASIC MODE, SEE IF BASIC LINE #'S
	BEQ	52$			;BRANCH IF NOT, SAY UNSEQUENCED
51$:
	.ENDC

	MOV	20(SP),R1		;POINT TO START OF TEXT
	CMPB	(R1),#'0		;IS FIRST CHAR A DIGIT?
	BLO	52$			;NO
	CMPB	(R1),#'9		;...
	BLE	54$			;GOOD LINE NUMBER
52$:	BIS	#2,@6(SP)		;WELL--WE TRIED
	BR	65$			;SET TEXT LEN AND RETURN
54$:	MOV	R3,-(SP)		;SAVE MORE REGS
	MOV	R4,-(SP)
	CLR	R3
55$:	MOVB	(R1)+,R4		;COPY DIGIT
	DEC	R2			;DEC LENGTH OF RECORD
	SUB	#'0,R4			;MAKE BINARY
	ASL	R3			;MULT PREV BY 10
	MOV	R3,-(SP)

	.IF	DF,R$$EIS
	ASH	#2,R3	

	.IFF
	ASL	R3
	ASL	R3
	.ENDC

	ADD	(SP)+,R3		
	ADD	R4,R3			;ACCUM THIS DIGIT
	CMPB	(R1),#'0		;NEXT CHAR ALSO DIGIT?
	BLO	57$
	CMPB	(R1),#'9
	BLE	55$			;PROCESS DIGIT
57$:	CMPB	(R1),#11		;FOLLOWING TAB?
	BNE	58$			;NO.. DATA STARTS HERE
	INC	R1			;UP POINTER PST IT
	DEC	R2			;CHOP OFF OF LENGTH
58$:	MOV	R3,@16(SP)		;SAVE THE LINE NUMBER
	MOV	24(SP),R3		;START OF TEXT AREA
	MOV	R2,R4			;LENGTH AGAIN
	BEQ	60$
59$:	MOVB	(R1)+,(R3)+		;COPY BYTE OF DATA
	SOB	R4,59$			;SHIFT LINE DOWN
60$:	MOV	(SP)+,R4
	MOV	(SP)+,R3

65$:	MOV	20(SP),R1		;TEXT START ADR
	ADD	R2,R1			;END OF LINE
	CLRB	(R1)+			;NULL PAD IT
	CLRB	(R1)+			;GUARANTEE ONE
	ADD	#2,R2			;COMPUTE AN EVEN
	BIC	#1,R2			;LENGTH OF RECORD
70$:	MOV	R2,R0			;RETURN LENGTH OF LINE
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	RTS	PC			;RETURN

80$:
	DEC	R2			;-2 FOR GET ERROR
	BR	70$			;RETURN

	.SBTTL	GSTRM - STREAM ORIENTED GET

GSTRM:	JSR	R1,$SAV5
	MOV	30(SP),R4		;ADDRESS TO PUT RECORD
	MOV	R4,R3			;INIT NEXT ADR TO STORE IN
	CLR	R5			;SAY NO <CR> SEEN YET
	BR	90$			;GO GET THE NEXT RECORD
;
; THE FOLLOWING REGISTER CONVENTIONS ARE USED
; R0 - FDB ADDRESS
; R1 - ADDRESS OF NEXT INPUT BYTE
; R2 - NUMBER OF BYTES OF INPUT RECORD LEFT TO PROCESS
; R3 - ADDRESS TO STORE NEXT OUTPUT BYTE
; R4 - ADDRESS OF BEGINNING OF OUTPUT BUFFER
; R5 - CARRIAGE RETURN FLAG
;      0 IF PREVIOUS CHARACTER WAS NOT A CR
;      1 IF PREVIOUS CHARACTER WAS A CR
;
; THE LOW 2 BITS OF STRMIN HAVE THE FOLLOWING MEANING
;
;	01 - STREAM FORMAT
;	10 - STREAM_LF
;	11 - STREAM_CR
;
10$:	MOVB	(R1)+,(R3)		;STORE NEXT BYTE OF RECORD
	BEQ	68$			;IGNORE NULLS
	CMPB	(R3),#15		;IS IT A CR OR TERMINATOR?
	BGT	70$			;BRANCH IF NOT A SPECIAL CHARACTER
	CMPB	(R3),#12		;LINE FEED?
	BLT	70$			;BRANCH IF NOT A TERMINATOR
	BITB	#2,STRMIN		;STREAM_LF OR STREAM_CR FORMAT?
	BEQ	40$			;BRANCH IF NOT, NORMAL STREAM FORMAT
	BITB	#1,STRMIN		;YES, WHICH IS IT?
	BEQ	20$			;BRANCH IF STREAM_LF
;
; STREAM_CR FORMAT, <CR> AND <FF> TERMINATE, ALL ELSE IS DATA
;
	CMPB	(R3),#15		;IS THIS A <CR>?
	BR	30$
;
; STREAM_LF FORMAT, <LF> AND <FF> TERMINATE, ALL ELSE IS DATA
;
20$:	CMPB	(R3),#12		;IS THIS A <LF>?
30$:	BNE	35$			;BRANCH IF NOT TERMINATOR
	TST	R5			;<FF> BEFORE TERMINATOR?
	BEQ	120$			;BRANCH IF NOT
	BR	68$			;YES, <FF><CR> OR <FF><LF> = PAGE MARK
35$:	CMPB	(R3),#14		;<FF>?
	BNE	70$			;BRANCH IF DATA CHARACTER
	CMP	R3,R4			;ANY DATA PRECEEDING THE <FF>?
	BNE	60$			;BRANCH IF YES
	MOV	#1,R5			;INDICATE "PREV CHAR = <FF>"
	BR	58$			;AND CHANGE PAGE NUMBER
;
; STREAM FORMAT, 
;	<CR><LF> TERMINATES RECORD AND IS STRIPPED
;	<LF> OR <VT> TERMINATE RECORD AND ARE RETAINED.
;	<FF> TERMINATES RECORD AND BECOMES A PAGE MARK.
;
40$:	CMPB	(R3),#14		;<FF>?
	BGT	65$			;BRANCH IF <CR>
	BEQ	55$			;BRANCH IF <FF>
;
; <LF> OR <VT>
;
	CMPB	(R3),#12		;<LF>?
	BNE	45$			;BRANCH IF <VT>
	TST	R5			;LF PRECEEDED BY <CR>?
	BEQ	45$			;BR IF NOT, TREAT LIKE <VT>
	DEC	R3			;INC FOR <LF> NOT DONE YET
					;STRIP OFF <CR>
	BR	120$			;AND TERMINATE THE RECORD
45$:	INC	R3			;LEAVE <LF> OR <VT> IN TEXT
	BR	120$			;AND TERMINATE THE RECORD
;
; FOUND A FF
;
55$:	CMP	R3,R4			;ANY DATA PRECEEDING THE FF
	BNE	60$			;BRANCH IF YES
;
; FORM FEED IS FIRST CHARACTER
;
58$:	INC	@24(SP)			;CHANGE PAGE NUMBER
	MOV	20(SP),@22(SP)		;SET NEW STARTING LINE NUMBER
	BR	85$			;CONTINUE GETTING A RECORD
;
; DATA RECORD FOLLOWED BY FF
;
60$:	DEC	R1			;LEAVE FF IN THE INPUT STREAM
					;FOR NEXT RECORD TO FIND
	BR	120$			;AND PROCESS THE POSSIBLY NULL RECORD
;
; CARRIAGE RETURN SEEN
;
65$:	MOV	#1,R5			;INDICATE CR SEEN
	BR	80$
;
; CHARACTER IS NOT A CR, LF, OR FF
;
68$:	DEC	R3			;SKIP NULLS
70$:	CLR	R5			;NO CR SEEN
80$:	INC	R3			;COUNT OUTPUT CHARACTER
85$:	SOB	R2,10$			;PROCESS NEXT INPUT CHARACTER IF ANY
;
; INPUT SIDE EXHAUSTED, BUT DONOT HAVE A COMPLETE RECORD ON THE OUTPUT SIDE
;
90$:	MOV	R4,R2			;BEGINNING ADDRESS OF OUTPUT BUFFER
	ADD	#512.,R2		;ADR OF LAST+1 BYTE OF BUFFER
	SUB	R3,R2			;NUMBER OF BYTES REMAINING IN BUF
	CMP	R2,#2			;ENOUGH ROOM FOR ANOTHER GET?
	BLE	130$			;NO, CALL THIS RECORD COMPLETE
;
; R3 = RECORD BUFFER ADDRESS, R2 = RECORD BUFFER SIZE
; GET THE NEXT RECORD
;
100$:	JSR	PC,DOGET		;GET THE NEXT RECORD
;
; R1 = ADDRESS OF NEXT BYTE IN THE INPUT STREAM
; R2 = NUMBER OF BYTES IN THIS RECORD
; R3 = ADDRESS OF NEXT OUTPUT BYTE TO BE STORED
;
	TST	R2			;CHECK FOR END OF FILE OR NULL RECORD
	BGT	10$			;BRANCH IF MORE DATA IN INPUT STREAM
	BEQ	90$			;BRANCH IF NULL RECORD, GET ANOTHER
;
; END OF FILE, MUST COMPLETE LAST RECORD IF ANY
;
	CMP	R3,R4			;ANY DATA IN OUTPUT RECORD BUFFER
	BGT	110$			;BRANCH IF YES
	MOV	R2,R0			;RETURN -1 FOR EOF
	BR	140$
;
; EOF FORCING OUT THE LAST PARTIAL RECORD
;
110$:	SUB	R5,R3			;IF PRECEEDING CHAR WAS CR, STRIP IT
	BR	130$			;AND PROCESS THE FINAL RECORD
;
; OUTPUT RECORD IS COMPLETE, NOTE WHETHER ANY INPUT LEFT FOR NEXT TIME
;
120$:	SUB	F.NRBD+2(R0),R1		;NUMBER OF BYTES PROCESSED IN RECORD
	CMP	F.NRBD(R0),R1		;ANY LEFT FOR LATER?
	BLE	130$			;BRANCH IF NOT
	INC	R1			;SAVE COUNT+1 SO ZERO WILL WORK
	MOV	R1,SVSTRM		;NOTE HOW MANY BYTES ALREADY USED
;
; STORE TWO TRAILING NULLS AND RETURN SIZE AS EVEN NUMBER
;
130$:	BIS	#2,@16(SP)		;INDICATE NO LINE NUMBERS
	CLRB	(R3)+			;END RECORD WITH NULLS
	CLRB	(R3)+
	SUB	R4,R3			;SIZE OF RECORD
	BIC	#1,R3			;MAKE IT EVEN
	MOV	R3,R0			;RETURN VALUE IS THE RECORD SIZE
140$:	RTS	PC			;RETURN TO CALLER

;
; THIS ROUTINE GETS THE NEXT BYTES IN THE INPUT STREAM TO BE PROCESSED.
; IF ANY BYTES WERE LEFT IN THE LAST RECORD, THEY WILL BE READ FROM THE
; STREAM BUFFER BEFORE THE NEXT GET IS ISSUED.
;
; INPUTS:
;	R0 = FDB ADDRESS
;	R2 = SIZE OF REMAINING SPACE IN OUTPUT BUFFER
;
; OUTPUTS:
;
;	R0,R3,R4,R5 PRESERVED
;	R1 = ADDRESS OF NEXT BYTE IN INPUT STREAM TO PROCESS
;	R2 = NUMBER OF BYTES IN THE STREAM, OR -1 IF EOF
;
;
; THE SAVED CONTEXT FOR THE ROUTINE IS
;	SVSTRM - NUMBER OF BYTES (+1) ALREADY PROCESSED IN THE RECORD.
;		= 0 IF NO MORE BYTES IN STREAM BUFFER, DO ANOTHER GET
;		> 0 MEANS SKIP THAT MANY BYTES (-1) IN STREAM BUFFER
;		< 0 MEANS GET THE RECORD AGAIN AND SKIP THAT MANY BYTES (-1)
;			THIS IS FOR A REOPENED INPUT FILE WHEN COPYFS
;			CLOSES AND REOPENS THE INPUT FILE.
;		 THIS IS FOLLOWED BY 3 WORDS OF .POINT INFORMATION
;

DOGET:	MOV	R4,-(SP)		;SAVE SOME REGISTERS
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	#SVSTRM,R4		;ADDRESS OF CONTEXT AREA
	MOV	(R4)+,R3		;ANYTHING LEFT IN PREVIOUS RECORD?
	BGT	40$			;BRANCH IF YES, IT'S IN THE STREAM BUF
	MOV	#SVSTRM+6,R4		;ADR OF LAST .MARK PARAMETER
	MOV	F.NREC(R0),(R4)		;ADR OF NEXT RECORD
	ADD	F.VBSZ(R0),(R4)		;  FORM BYTE OFFSET
	SUB	F.EOBB(R0),(R4)		;    IN BLOCK
	MOV	F.VBN+2(R0),-(R4)	;LOW VBN BITS
	MOV	F.VBN(R0),-(R4)		;HIGH VBN BITS
	GET$S	R0			;GET THE RECORD
	BCS	80$			;BRANCH IF ERROR, CHECK EOF
40$:	MOV	F.NRBD(R0),R2		;SIZE OF RECORD
	MOV	F.NRBD+2(R0),R1		;ADDRESS OF RECORD
	BITB	#FD.CR,F.RATT(R0)	;IF IMPLICIT CR, LF, MUST ADD THEM
	BEQ	45$
	TST	R3			;IF RECORD PREVIOUSLY READ
	BGT	45$			; THEN ALREADY ADDED CR, LF
	ADD	R1,R2			;OTHERWISE, TACK THEM ON
	MOVB	#15,(R2)+		;  TO THE END
	MOVB	#12,(R2)+		;    OF THE RECORD
	SUB	R1,R2			;GET THE ADJUSTED SIZE
	MOV	R2,F.NRBD(R0)		;AND RECORD IT IN THE FDB
45$:	MOV	(SP)+,R3		;ROOM LEFT IN OUTPUT BUFFER
	MOV	-(R4),-(SP)		;COUNT OF BYTES ALREADY PROCESSED
	BGE	48$			;IF NEGATIVE
	NEG	(SP)			;MAKE IT POSITIVE NOW
48$:	BEQ	50$			;BRANCH IF NONE PROCESSED ALREADY
	DEC	(SP)			;REMOVE BIAS, FORM ACTUAL COUNT
50$:	CLR	(R4)			;ASSUME ALL BYTES WILL BE PROCESSED
	ADD	(SP),R1			;SKIP BYTES ALREADY PROCESSED IF ANY
	SUB	(SP)+,R2		;ADJUST BYTE COUNT AS WELL
	CMP	R2,R3			;IF LARGER RECORD THAN CAN FIT
	BLE	60$
	MOV	R3,R2			;PROCESS ONLY WHAT WILL FIT (OR LESS)
	MOV	R3,(R4)			;AND SAY THAT SOME WILL BE LEFT
60$:	MOV	(SP)+,R3		;RESTORE SAVED REGISTER
	MOV	(SP)+,R4
	RTS	PC			;AND RETURN
;
; ERROR FROM GET
;
80$:	CMPB	#IE.RBG,F.ERR(R0)	;IF RECORD TOO BIG, TRUNCATE IT
	BEQ	40$
90$:	TST	(SP)+			;CLEAN THE STACK
	MOV	#-1,R2			;EOF RETURN INDICATOR
	CMPB	#IE.EOF,F.ERR(R0)	;END OF FILE?
	BEQ	60$			;BRANCH IF EOF
	DEC	R2			;GET ERROR CODE
	BR	60$			;AND RETURN

	.DSABL	LSB

	.SBTTL	PUT - WRITE A RECORD TO OUTPUT FILE

ENTRY	PUT
	JSR	R1,$SAV3		;SAVE 3 REGS
	MOV	16(SP),-(SP)		;FDB POINTER
	MOV	#EXTEND,R0		;SEE IF EXTEND ROUTINE IS DEFINED
	BEQ	2$			;BRANCH IF IT IS NOT
	JSR	PC,(R0)			;EXTEND FILE IF NECESSARY
2$:
	MOV	(SP)+,R1		;FDB ADDRESS TO R1
	MOV	14(SP),R2		;LINE ADDRESS
	MOV	12(SP),R3		;PAGE # ADDRESS
;
; THE SEQBAS FLAG IS USED TO DISTINGUISH BETWEEN THE TWO TYPES
; OF RSX SEQUENCED FILES, THE STANDARD FCS SEQUENCED
; RECORD FILE WITH BINARY SEQUENCE #'S STORED AS
; A WORD, AND THE BASIC FORMAT WITH ASCII SEQUENCE #'S.
; THE /BASIC SWITCH CHOOSES THE BASIC FORMAT, BUT IF SET
; AFTER THE FIRST PUT IS DONE, THEN A RECOPY HAS TO BE
; REQUESTED TO GUARANTEE THAT THE EVENTUAL OUTPUT WILL BE
; IN THE RIGHT FORMAT.  THAT'S THE FUNCTION OF THE REQCPY
; BIT.  IT'S SET WHEN A /BASIC OR /NOBASIC SWITCH IS GIVEN
; AND RESET WHEN THE FIRST PUT IS DONE.  IT FORCES
; CERTAIN COMMANDS LIKE "E" TO PERFORM ANOTHER COPY.
;
	MOVB	SEQBAS,R0		;GET FLAGS WORD
	BNE	5$			;BRANCH IF FLAGS INITED
	BIC	#REQCPY,SOSFLG		;NO NEED TO FORCE COPY
;
; FIRST PUT TO FILE, INIT THE FLAGS
;
	MOVB	2(R2),R0		;GET THE UNSEQUENCE FLAG
	JSR	PC,SETPUT		;RETURN FLAGS, SET RECORD TYPE
	MOVB	R0,SEQBAS		;STORE FLAGS FOR SUBSEQUENT PUT'S
5$:
;
; R0 = FLAGS FOR PUT, R1 = FDB ADDRESS, R2 = LINE ADDRESS, R3 = PAGE # ADDRESS
;
PUTLS1::
	TSTB	(R2)			;EOF LINE?
	BEQ	40$			;YES.  DO NOT PUT IT

10$:	CMP	(R3),4(R2)		;PAGE NUMBER CHANGE?
	BHIS	15$			;NO.  NO FF

;	PT OUT A PAGE MARK IN FILE

	MOV	#-1,F.SEQN(R1)		;STORE FF SEQUENCE NO.
	MOV	#FFREC,F.NRBD+2(R1)	;ADDRESS OF FORM FEED RECORD
	MOV	#1,F.NRBD(R1)		;SIZE OF FORM FEED RECORD
	MOV	R0,-(SP)		;SAVE FLAGS AROUND THE PUT
	JSR	PC,DOPUT1		;PUT THE FORM FEED RECORD
	MOV	(SP)+,R0		;RESTORE FLAGS
12$:	INC	(R3)			;INC PAGE NUM FOR OUTPUT
	BR	10$			;SEE IF MORE NEEDED
15$:	BIT	#NOSEQF,R0		;UNSEQ THIS LINE?
	BNE	30$			;YES IF BIT IS ON

;	WRITE A SEQUENCED RECORD TO OUTPUT FILE


	.IF	NDF,R$$STS
	BIT	#BASICF,R0		;PUT IN BASIC MODE?
	BEQ	28$			;BRANCH IF NOT
	.IFF
	BIT	#RMSF,R0		;IS RSX STYLE FILE,
	BNE	28$			;DO RSX STYLE PUT
	.ENDC

21$:	TST	(R2)+			;POINT AT FLAGS WORD
	MOV	(R2),-(SP)		;SAVE 3 WORD
	MOV	2(R2),-(SP)		;AS LINE NUMBER
	MOV	4(R2),-(SP)		;BUILD AREA
;			NOTE LAST WAS THE LINE NUMBER!!
	MOV	#5,-(SP)		;LEN OF ASCII STRING
	JSR	PC,CNVDEC		;MAKE IT ASCII
	MOV	(SP)+,R3		;BYTE COUNT
22$:	MOVB	(R0)+,(R2)+		;COPY LINE NUMBER INTO
	SOB	R3,22$			;LINE FLAG AREA
	MOVB	#11,(R2)+		;TAB AFTER LINE NUMBER
	SUB	#6,R2			;POINT TO START OF RECORD
	MOV	R2,R0			;FORM LINE ADDRESS
	TST	-(R0)			;IN R0
	JSR	PC,DOPUT		;FIND END OF RECORD AND DO PUT
	MOV	(SP)+,4(R2)		;RESTORE LINE FLAG
	MOV	(SP)+,2(R2)		;AREAS
	MOV	(SP)+,(R2)
	BR	40$			;SET AND EXIT
;
; WRITE AN RSX SEQUENCED RECORD
;
28$:	MOV	6(R2),F.SEQN(R1)	;STORE SEQUENCE NO. IN FDB

;	WRITE AN UNSEQUENCED RECORD TO OUTPUT FILE

30$:	MOV	R2,R0			;LINE ADDRESS
	ADD	#10,R2			;ADDRESS OF RECORD
	JSR	PC,DOPUT		;FIND END OF RECORD, DO PUT
40$:	CLR	R0			;SET GOOD RETURN CODE
	RTS	PC			;AND RETURN
;
; R0 = ADR OF LINE HEADER, R1 = FDB ADR, R2 = ADR OF BEGINNING OF RECORD
; PRESERVES R2
;
	.ENABL	LSB
DOPUT:	CLR	R3			;SIZE IN WORDS OF THIS LINE
	BISB	(R0),R3			;WITHOUT SIGN EXTENSION
	ASL	R3			;BYTE COUNT
	ADD	R0,R3			;ADDRESS OF LAST+1 BYTE
;
; THE TEXT IS GUARANTEED TO HAVE ONE TRAILING NULL BYTE, BUT NOT
; NECESSARILY 2 BYTES IF ENDED ON WORD BOUNDARY.  THEREFORE SKIP
; THE LAST BYTE ENTIRELY SINCE IT IS EITHER A NULL OR A POSSIBLY
; GARBAGED CHARACTER AFTER THE NULL.
;
	DEC	R3
10$:	TSTB	-(R3)			;PEEL OFF THE TRAILING NULL(S)
	BEQ	10$			;BRANCH IF MORE TO DO
	INC	R3			;POINT AT LAST + 1 CHARACTER
	SUB	R2,R3			;FORM BYTE COUNT OF RECORD
	BGE	20$			;BRANCH IF BYTE COUNT OK
15$:	CLR	R3			;FORCE A NULL RECORD
20$:	MOV	R2,F.NRBD+2(R1)		;SET RECORD ADDRESS
	MOV	R3,F.NRBD(R1)		;AND SIZE IN FDB
;
; R1 = FDB ADDRESS, RECORD ADDRESS AND SIZE ARE IN FDB
;
DOPUT1:	PUT$S	R1			;PUT THE RECORD TO THE FILE
	BCC	40$			;BRANCH IF NO ERROR
	CMP	R1,#FILELST		;ERROR ON LISTING FILE FDB?
	BEQ	60$			;YES, PUTLST MUST HANDLE THESE
	MOV	#ERMSGB,-(SP)		;ERROR MESSAGE
	JMP	FCFATL			;FCS FATAL ERROR
40$:
	.IF	DF,R$$STS
	CMPB	#R.STRM,F.RTYP(R1)	;IF RSTS STREAM ASCII FORMAT
	BNE	60$
	MOV	F.NRBD(R1),R0		;GET SIZE OF RECORD JUST PUT
	BEQ	60$			;BRANCH IF NULL RECORD
	ADD	F.NRBD+2(R1),R0		;FORM POINTER TO LAST + 1 BYTE
	CMPB	-(R0),#12		;DID RECORD TERMINATE WITH <LF>
	BEQ	15$			;BRANCH IF YES, PUT A NULL RECORD
	.ENDC	;R$$STS

60$:	RTS	PC			;RETURN
	.DSABL	LSB
;
; FIRST PUT TO OUTPUT FILE, SET UP RECORD TYPE AND RETURN
; PUT FLAGS IN R0
;
; INPUT:
;	R0 = UNSEQUENCE FLAG
;	R1 = FDB ADDRESS
; OUTPUT:
;	R0 = FLAGS
;		NOSEQF - NO SEQUENCE NUMBERS IF SET
;		BASICF - BASIC STYLE SEQUENCE #'S IF SET AND SEQUENCING
;		RMSF   - RSX STYLE FILE IN RSTS
;
SETPUT::MOV	R0,-(SP)		;SAVE UNSEQUENCE FLAG
	MOV	#BASICF!1,R0		;SEE IF BASIC MODE SHOULD BE SET
	BIT	#BASIC,SOSFLG		;/BASIC SET?
	.IF	NDF,R$$STS
	BNE	40$			;BRANCH IF YES
	.IFF
	BEQ	10$			;NOT SET
	MOVB	#R.STRM,F.RTYP(R1)	;/BASIC MODE IS STREAM
	BR	40$			;NOW EXIT
10$:
	.ENDC

	MOV	#1,R0			;NON-ZERO, NO FLAGS SET
	.IF	DF,R$$STS
	BIT	#RMSFIL,SOSFLG		;RSX STYLE FILE OUTPUT?
	BNE	15$			;YES..COMMON CODE WITH RSX
	MOVB	#R.STRM,F.RTYP(R1)	;RSTS STREAM FILE
	BIS	(SP),R0			;COPY UNSEQ FLAG
	BR	40$			;NOW EXIT
15$:	BIS	#RMSF,R0		;NOTE RSX STYLE FILE
	.ENDC
	BIT	#NOSEQF,(SP)		;STRIP SEQUENCE NUMBERS?
	BNE	20$			;BRANCH IF YES
	MOVB	#R.SEQ,F.RTYP(R1)	;NO. SEQUENCED RECORD TYPE
	BR	40$
20$:	BIS	#NOSEQF,R0		;STRIP SEQUENCE NUMBERS
40$:	TST	(SP)+			;CLEAN OFF THE STACK
	RTS	PC			;AND RETURN


	.END
