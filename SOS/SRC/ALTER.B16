MODULE ALTER (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!	020705	PHL0705		Peter H. Lipman		19-Oct-1980
!
!		Output control characters in a readable form
!		Suppress nulls in text when altering the line.
!		INSFLG is a global for all alter mode code
!


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	ALTPLINE,	! PRINT ALTER MODE LINE NUMBER
	TYPE,		! TYPE OUT A CHARACTER
	CHLINE,		! CHANGE A LINE IN BUFFER
	INSLINE,	! INSERT A LINE INTO BUFFER
	NXTLINE,	! FORWARD ONE LINE
	PRVLINE,	! BACK UP ONE
	DIVU,		! DO UNSIGNED DIVIDE
	LISTEN,		! READ A CHAR FROM TERMINAL
	TYPECR,		! TYPE CR, LF ON TERMINAL
	CTRLR,		! RETYPE THE LINE FOR CONTROL R
	ALTINS,		! INSERT SINGLE CHARACTER IN LINE
	INSCHARS,	! INSERT CHARACTERS 'I' COMMAND
	SETDOT,		! SET CURRENT LOCATION
	ALTSHIFT,
	ALTDEL,
	ALTPRT,
	ALTEWORD,
	ALTECHR,
	ALTTYPEC,
	ALTLST;

EXTERNAL
    NEWLNA: REF VECTOR[,BYTE];		! POINTER TO NEW LINE BUFFER
EXTERNAL
    ALTCHR: BYTE;		! ADR OF CHAR WHICH WHEN INPUT
EXTERNAL
    TTSCP: BYTE;		! GTR 0 IF TERMINAL IS A SCOPE
				! IS REPLACED BY ALTMODE
GLOBAL
    NCHR: M1TO1;
GLOBAL
    OLINPT: REF VECTOR[,BYTE];
GLOBAL
    NSLSH,				! COUNT OF "\" CURRENTLY OUTPUT
    FSLSH,				! FLAG INDICATING THAT A \...\ HAS BEEN OUTPUT
    HSLSH,				! HORIZONTAL POSITION OF END OF \...\
    HORPOS,				! HORIZONTAL POSITION (FOR SCOPE RUBOUT)
    VERPOS;				! VERTICAL POSITION (FOR SCOPE RUBOUT)
EXTERNAL
    CMDSQN,				! COMMAND SEQUENCE NUMBER FOR THIS COMMAND
    PRTSQN;				! LAST PRINT COMMAND SEQUENCE NUMBER

NVROUTINE (ENDLIN(LIN))=
BEGIN
LOCAL
    J,
    PTR1,
    PTR2;
(.NCHR[-1]+1)<0,8>=(.NCHR[-1]+2)<0,8>=0;
PTR1=.NEWLNA;
PTR2=.LIN+2;
.PTR1=(.NCHR[-1]-.NEWLNA+3)^-1;
PTR1=.PTR1+2;
DECR J FROM 3 TO 1 DO
	BEGIN
	.PTR1=..PTR2;
	PTR1=.PTR1+2;
	PTR2=.PTR2+2;
	END;
SETDOT(.NEWLNA);
END;

GBLROUTINE (ALTER(LIN,ICNT,PRECMD,INSADR))=
!
! LIN	 = ADDRESS OF LINE TO ALTER
! ICNT	 = INITIAL COUNT OF CHARACTERS TO POSITION OVER
! PRECMD = PLIT CONTAINING INITIAL COMMANDS TO EXECUTE
! INSADR = 0 IF ALTER MODE
!	 = ADDRESS OF 2 WORD ARRAY FOR INSERT MODE
!	   INSADR[0] = ADDRESS OF LINE TO INSERT BEFORE
!		USED AS BOTH AN INPUT AND AN OUTPUT
!	   INSADR[1] = DEFAULT INCREMENT TO USE FOR LINE BREAKING
!
BEGIN
LOCAL
    DIRECT,
    N,
    CMD,
    CHAR,
    I,
    NGIV,
    PREPTR;
GLOBAL
    INSFLG;			!INSERT FLAG BITS
!
!		IF INSFLG IS NON ZERO THEN THIS IS AN INSERT OF A NEW
!	LINE RATHER THAN AN ALTER OF AN EXISTING LINE.
!		IF INSFLG IS NEGATIVE, THEN IN INSERT MODE ON THE
!	LINE BEING INSERTED
!		IF INSFLG IS POSITIVE, THEN IN ALTER MODE ON THE
!	LINE BEING INSERTED
!
! THE BITS HAVE THE FOLLOWING MEANINGS:
!
!	BIT 0	= 0 IF READING CHARACTER AT A TIME OR WITH SPECIAL TERMINATORS
!		= 1 IF READING LINE AT A TIME, ALL ECHOING BY TERM DRIVER
!	BIT 13	= 0 IF NOT BREAKING LINE IN ALTER INSERT LOGIC (#020000)
!		= 1 IF BREAKING THE LINE IN ALTER INSERT
!	BIT 14  = 0 IF CALLED FROM ALTER COMMAND (#040000)
!		= 1 IF CALLED FROM INSERT COMMAND
!	BIT 15  = 0 IF ALTER INSERT MODE (#0100000)
!		= 1 IF CALLED FROM INSERT COMMAND.
!		  CLEARED BY <^A><ESC> SEQUENCE IN INSCHARS ROUTINE
!
MAP
    LIN: REF VECTOR[,BYTE];
MAP
    INSADR: REF VECTOR;
PREPTR=CMD=0;
IF (INSFLG=.INSADR) NEQ 0 THEN INSFLG=%O'0140001';
!
! START AGAIN HERE FOR ^U AND FOR LINE BREAK LOGIC
!
DO  BEGIN
NSLSH=0;
IF (.INSFLG AND %O'020000') EQL 0 THEN
	BEGIN
	REGISTER
	    PTR1	: REF VECTOR [,BYTE],
	    PTR2	: REF VECTOR [,BYTE];
	LOCAL
	    LNG;
	PTR2=LINTXT(.LIN);
	LNG=2*.LINLEN(.LIN)-LINTXT(0);
	PTR1=.NEWLNA+516-.LNG;
	NCHR[-1]=NEWLNA[7];
	NCHR[1]=.PTR1;
	DECR I FROM .LNG TO 1 DO
		BEGIN
		PTR1[0]=.PTR2[0];
		PTR2=.PTR2+1;
		IF .PTR1[0] NEQ 0 THEN PTR1=.PTR1+1;
		END;
	END
ELSE INSFLG=.INSFLG AND NOT %O'020000';
ALTPLINE(.LIN);
OLINPT=.LIN;
.NEWLNA+6=0;
ALTSHIFT(.ICNT,1);
I=(DO	BEGIN
	DIRECT=1;
	IF .CMD NEQ 'I' THEN
		BEGIN
		N=0;NGIV=0;
		CMD=ALTLST(.PRECMD,PREPTR);
		END;
	IF .CMD EQL '-' THEN
		BEGIN
		DIRECT=-.DIRECT;
		CMD=ALTLST(.PRECMD,PREPTR);
		END;
	WHILE .CMD GEQ '0' AND .CMD LEQ '9' DO
		BEGIN
		N=.N*10+.CMD-'0';
		IF .N LSS 0 THEN
			BEGIN
			TYPE(%CHAR(7));
			N=%O'077777';
			END;
		CMD=ALTLST(.PRECMD,PREPTR);
		NGIV=1;
		END;
	IF .NGIV EQL 0 THEN N=1;
	IF .DIRECT LSS 0 THEN N=-.N;

!
! DISPATCH ON THE COMMAND CHARACTER
!
	IF .CMD EQL ' ' THEN
!
! <SP> - SPACE - POSITION OVER THE NEXT/PREVIOUS N CHARACTERS
!
		ALTSHIFT(.N,1)

	ELSE IF .CMD EQL %O'177' OR .CMD EQL %O'10' THEN
!
! <DE> - DELETE (RUBOUT)
! <BS> - BACK SPACE
!	DELETE THE PREVIOUS/NEXT N CHARACTERS
!
		ALTSHIFT(-.N,1)

	ELSE IF .CMD EQL %CHAR(13) OR .CMD EQL %CHAR(10) THEN
!
! <CR> - CARRIAGE RETURN
! <LF> - LINE FEED
!	 FINISH ALTER MODE FOR THIS LINE, PRINT THE REST OF THE LINE
!
		EXITLOOP 1

	ELSE IF .CMD EQL 'C' THEN
!
! 'C' - CHANGE THE NEXT/PREVIOUS N CHARACTERS
!
		BEGIN
		ALTDEL(.N,.N LSS 0);
		IF .N LSS 0 THEN N = -.N;
		UNTIL (N=.N-1) LSS 0 DO
			BEGIN
			CHAR=LISTEN(0);
			IF .CHAR EQL %CHAR(13) OR .CHAR EQL %CHAR(10) OR .CHAR EQL %O'033'
				THEN EXITLOOP;
			IF .CHAR<0,8> EQL .ALTCHR<0,8> THEN CHAR = %O'033';
			IF .CHAR EQL %O'177' OR .CHAR EQL %O'10' THEN N=.N+1 ELSE ALTINS(.CHAR);
			END;
		IF .CHAR EQL %CHAR(13) THEN EXITLOOP 1;
		END

	ELSE IF .CMD EQL 'D' THEN
!
! 'D' - DELETE THE NEXT/PREVIOUS N CHARACTERS
!
		ALTDEL(.N,1)

	ELSE IF .CMD EQL 'I' OR .CMD EQL 'R' OR .CMD EQL 'J' THEN
!
! 'I' - INSERT TEXT AFTER THE CURRENT CHARACTER
!	+nI MEANS INSERT AFTER CURRENT CHARACTER, USE n AS A
!	DEFAULT LINE INCREMENT WHEN INSERTING <LF>'S
!	-nI MEANS INSERT BEFORE CURRENT CHARACTER, USE n AS A
!	DEFAULT LINE INCREMENT WHEN INSERTING <LF>'S
! 'R' - REPLACE THE NEXT/PREVIOUS N CHARACTERS WITH INSERTED TEXT
! 'J' - SPLIT THE LINE AFTER THE CURRENT CHARACTER MAKING A NEW
!	LINE OF THE REMAINDER
!
		BEGIN
		LOCAL
		    J,
		    INC;
		IF .CMD EQL 'R' THEN
			BEGIN
			ALTDEL(.N,1);
			N=0;
			CMD='I';
			END
		ELSE IF .CMD EQL 'I' AND .N LSS 0 THEN ALTSHIFT(-1,1);
		IF .N LSS 0 THEN N=-.N;
		IF .NGIV EQL 0 THEN N=0;
		J = (DO	BEGIN
			LOCAL
			    J;
			J=4;		! ASSUME THIS IS 'J' COMMAND
			IF .CMD EQL 'I' THEN J=INSCHARS(INSFLG);
!
! J = 0 IF ^U FROM INSERT MODE
! J = 4 IF <LF> FROM ALTER INSERT MODE OR 'J' COMMAND FROM ALTER MODE
!	THE VALUES INBETWEEN ARE NOT RETURNED BY INSCHARS.
!	IN THE CASE OF THE ^U OR THE BREAK OF THE LINE, THE ALTER
!	ROUTINE IS ESSENTIALLY STARTED AGAIN FROM THE TOP.  THE
!	'I' COMMAND (IF IT WAS AN 'I' OR 'R' COMMAND) IS
!	REMEMBERED AND RE-EXECUTED, SO WE GET BACK INTO
!	ALTER INSERT MODE.  NOTE THAT THE VALUE N IS ALSO
!	REMEMBERED.
!
			IF .J GTRU 4 THEN
				BEGIN
				CMD=0;
				EXITLOOP .J;
				END
			ELSE IF .J EQL 4 THEN
				BEGIN
				LOCAL
				    NL,
				    TMPN;
				TMPN=.N;
				IF .INSFLG EQL 0 THEN INC=NXTLINE(.LIN,1)
				ELSE	BEGIN
					INC=.INSADR[0];
					IF .TMPN EQL 0 THEN TMPN=.INSADR[1];
					END;
				IF .LINPAG(.INC) NEQ .LINPAG(.LIN) THEN
					NL=.SOSFLG[MAXLN]
				ELSE
					NL=.LINLIN(.INC)-1;
				IF .LINLIN(.LIN) + .TMPN LEQU .NL AND .TMPN NEQ 0
					THEN	INC = .TMPN
					ELSE	BEGIN
						INC=DIVU(.NL-.LINLIN(.LIN)+1,2);
						IF .INC GTRU .SOSFLG[ISTEP] THEN
							INC=.SOSFLG[ISTEP];
						END;
				IF .INC EQL 0 THEN
					BEGIN
					TYPE (%CHAR(7));
					IF .CMD EQL 'J' THEN EXITLOOP %O'077777';
					END
				ELSE EXITLOOP .J;
				END
			ELSE EXITLOOP .J;
			END WHILE 1);
		IF .J EQL 4 THEN	! 'J' OR <LF> IN INSERT MODE
			BEGIN
			LOCAL
			    REFLIN;
			ENDLIN(.LIN);
			LINLIN(.LIN)=.LINLIN(.LIN)+.INC;
			IF .INSFLG EQL 0 THEN REFLIN=LIN
			ELSE	BEGIN
				REFLIN=.INSADR;
				INSFLG=.INSFLG OR %O'020000';
				J=0;
				END;
			.REFLIN=INSLINE(.NEWLNA,..REFLIN);
			NCHR[-1]=NEWLNA[7];
			END;
		IF .J LSS %O'077777' THEN EXITLOOP .J;
		END

	ELSE IF .CMD EQL 'E' THEN
!
! 'E' - END THE ALTERATION, DO NOT PRINT THE REST OF THE LINE
!
		EXITLOOP 2

	ELSE IF .CMD EQL 'S' THEN
!
! 'S' - SKIP FORWARD/BACKWARD TO THE NTH OCCURRENCE OF THE NEXT CHARACTER TYPED
!
		ALTSHIFT(ALTECHR(.DIRECT,.N),1)

	ELSE IF .CMD EQL 'K' THEN
!
! 'K' - DELETE THE NEXT/PREVIOUS N "WORDS"
!
		ALTDEL(ALTECHR(.DIRECT,.N),1)

	ELSE IF .CMD EQL %CHAR(21) THEN
!
! <^U> - CONTROL U - RESTART THE ALTERING OF THIS LINE DISCARDING EDITS
!
		EXITLOOP 0

	ELSE IF .CMD EQL 'W' THEN
!
! 'W' - POSITION OVER THE NEXT/PREVIOUS N "WORDS"
!
		ALTSHIFT(ALTEWORD(.DIRECT,.N),1)

	ELSE IF .CMD EQL 'X' THEN
!
! 'X' - DELETE THE NEXT/PREVIOUS N "WORDS"
!
		ALTDEL(ALTEWORD(.DIRECT,.N),1)

	ELSE IF .CMD EQL 'L' THEN
!
! 'L' - PRINT THE REMAINDER OF THE LINE AND POSITION TO THE BEGINNING
!
		ALTPRT(0)
	
	ELSE IF .CMD EQL 'P' THEN
!
! 'P' - PRINT THE REMAINDER OF THE LINE AND THEN REPOSITION TO THE
!	CURRENT POSITION REPRINTING THE BEGINNING OF THE LINE.
!
		ALTPRT(.NCHR[-1]-NEWLNA[7])

	ELSE IF .CMD EQL %CHAR(18) THEN
!
! <^R> - CONTROL R - RETYPE THE LINE UP TO THE CURRENT POSITION
!
		CTRLR()

	ELSE IF .CMD EQL '>' OR .CMD EQL '<' OR .CMD EQL '^' THEN
!
! '>' - CHANGE UPPER CASE TO LOWER CASE FOR THE NEXT/PREVIOUS N CHARACTERS
! '<' - CHANGE LOWER CASE TO UPPER CASE FOR THE NEXT/PREVIOUS N CHARACTERS
! '^' - SWITCH ALPHABETIC CASE OF THE NEXT/PREVIOUS N CHARACTERS
!
		BEGIN LOCAL
			J,
			CHR;
		IF .N GTR 0 THEN J=0 ELSE J=1;
		DO	BEGIN
			CHR=.(.NCHR[.DIRECT])<0,8>;
			IF .CHR EQL 0 THEN EXITLOOP;
			IF .CHR GEQ %O'101' AND .CHR LEQ %O'132' THEN
				BEGIN
				IF .CMD NEQ '<' THEN CHR=.CHR OR %O'40';
				END
			ELSE
			IF .CHR GEQ %O'141' AND .CHR LEQ %O'172' THEN
				BEGIN
				IF .CMD NEQ '>' THEN CHR=.CHR AND NOT %O'40';
				END;
			NCHR[-.DIRECT]=.NCHR[-.DIRECT]+.DIRECT;
			(.NCHR[-.DIRECT])<0,8>=.CHR;
			NCHR[.DIRECT]=.NCHR[.DIRECT]+.DIRECT;
			ALTTYPEC(.CHR,.J);
			END UNTIL (N=.N-.DIRECT) EQL 0;
		END

	ELSE IF .CMD EQL %CHAR(9) THEN
!
! <TA> - TAB, POSITION TO THE END/BEGINNING OF THE LINE
!
		ALTSHIFT(.N*510,1)

	ELSE IF .CMD EQL 'B' THEN
!
! 'B' - POSITION TO THE BEGINNING OF THE LINE WITHOUT PRINTING THE REST OF THE LINE
!
		BEGIN
		ALTSHIFT(512,0);
		ALTPRT(0);
		END

	ELSE IF .CMD EQL 'Q' THEN
!
! 'Q' - QUIT ALTER MODE LEAVING THE LINE UNCHANGED
!
		EXITLOOP -1

	ELSE IF .CMD EQL %CHAR(19) THEN
!
! <^S> - CONTROL S - UNDOCUMENTED INTERNAL INTERFACE.
!	 POSITION TO END OF LINE WITHOUT PRINTING.
!	 USED BY THE EXTEND COMMAND WITH THE ",N" OPTION.
!
		BEGIN
		FSLSH=.FSLSH+1;
		HSLSH=.HORPOS;
		ALTSHIFT(510,0);
		END

	ELSE IF .CMD NEQ %O'033' AND .CMD NEQ 0 THEN
!
! <ES> - ESCAPE, ALTMODE, OR SELECT
!	 ONLY RESETS N (THE REPEAT COUNT) TO 0.
!
		TYPE(%CHAR(7));	! RING BELL IF ERROR

	END WHILE 1);

!
! THE FOLLOWING EXITLOOP VALUES ARE DEFINED:
!
!	-1 = QUIT, EXIT WITHOUT CHANGING OR INSERTING A LINE - 'Q' FROM
!	     ALTER MODE, '<ESC>' WITH EMPTY LINE FROM INSERT MODE
!	 0 = START OVER AGAIN, DISCARDING ALL CHANGES - '<^U>'
!	     BREAK LINE IN INSERT MODE
!	 1 = NORMAL EXIT, PRINTING REST OF LINE IF ANY - '<CR>'
!	 2 = NORMAL EXIT, NO PRINTING OF REST OF LINE - 'E'
!	 4 = BREAK THE LINE BY CHANGING THE OLD LINE INTO THE END PIECE
!	     AND THEN RESTARTING THE ALTER AS IF ^U WAS HIT.
!	 6 = INSERT MODE, LINE ENDED IN <ESC>
!	 8 = INSERT MODE, LINE ENDED IN <CR>
!	     AND <CR><LF> WAS ALREADY ECHOED.
!
IF .I GTR 0 THEN
	BEGIN
	ALTSHIFT(510,.I AND 1);
	ALTTYPEC(%O'200',0);
	IF (.I EQL 1 OR .I GEQ 6)	! IF PRINTED END OF LINE AND IF
	    AND (.FSLSH EQL 0)		! THERE ARE NO \...\ SEQUENCES
	    THEN PRTSQN=.CMDSQN;	! NOTE THIS LINE WAS PRINTED
	END;

IF .I LEQ 6 THEN TYPECR();
IF .I LSS 0 THEN RETURN .I;
IF .I GTR 0 THEN
	BEGIN
	LOCAL
	    J;
	ENDLIN(.LIN);
	IF .INSFLG EQL 0 THEN J=CHLINE(.NEWLNA,.LIN)
	ELSE J=INSADR[0]=INSLINE(.NEWLNA,.INSADR[0]);
	IF .I EQL 6 THEN RETURN 0;
	IF .I NEQ 4 THEN RETURN .J ELSE LIN=PRVLINE(.J,1);
	END;
END WHILE 1;
RETURN 0;
END;

END ELUDOM
