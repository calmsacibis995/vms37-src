	.TITLE	SWINI - SWITCH INITIAILIZATION
	.IDENT	/V03000/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; PETER H. LIPMAN	27-FEB-76
;
	.MCALL	CSI$,FDOF$L,FCSBT$,IOERR$
	CSI$
	FDOF$L
	FCSBT$
	IOERR$

	.MCALL	FDBDF$,NMBLK$,FDRC$R,FDOP$R,OFNB$R,GET$S,CLOSE$
	.MCALL	CALL,RETURN,CSI$1,CSI$2

	PLIT$	SWIN

SWFNM:	NMBLK$	SWITCH,INI,,SY,0

	DATA$	SWIN

SWFDB:	FDBDF$

;
; INPUT:
;	R0=CSI CONTROL BLOCK
;	(R0) = LUN TO USE IN OPENING THE FILE
;	C.SWAD(R0) = SWITCH TABLE ADDRESS
;	C.DEVD(R0) = SIZE OF PROGRAM NMAE STRING OR 0 IF ASCIZ
;	C.DEVD+2(R0) = ADR PF PROGRAM NAME STRING
;	C.DIRD(R0) = SIZE OF OPTION NAME SRRING OR 0 IF ASCIZ
;	C.DIRD+2(R0) = ADR OF OPTION NAME STRING , 0 IF NO OPTION NAME
;
; OUTPUT:
;	C=0 IF OK, C=1 IF ERROR
;	IF C=0
;	C.FILD, C.FILD+2 = 0
;	IF C=1
;	C.FILD, C.FILD+2 = SIZE, ADR OF BAD RECORD IN SWITCH.INI
;	OR
;	C.FILD = 0, C.FILD+2 = F.ERR FROM FCS
;

	CODE$	SWIN

.SWINI::JSR	R5,.SAVR1
	MOV	R0,R5		;R5=CSI BLOCK ADR
	MOV	C.SWAD(R0),-(SP) ;SAVE THIS , CSI1 CLEARS IT
	CLR	-(SP)		;INIT C.MKW1 SAVE WORD
	CLR	-(SP)		;INIT C.MKW2 SAVE WORD
	CLR	R2		;OPTION NAME SIZE IF NO OPTION
	MOV	C.DIRD+2(R5),R1 ;OPTION NAME ADR
	BEQ	20$		;BRANCH IF NO OPTION SPECIFIED
	MOV	C.DIRD(R5),R2	;OPTION SIZE
	BNE	20$		;IF NON ZERO
	CALL	GETSIZ		;OTHERWISE, GET SIZE
20$:	MOV	R2,-(SP)	;SAVE OPTION NAME SIZE
	MOV	R1,-(SP)	;AND ADDRESS
	MOV	C.DEVD+2(R5),R1 ;ADR OF PROGRAM NAME
	MOV	C.DEVD(R5),R2	;AND SIZE
	BNE	30$
	CALL	GETSIZ		;0 SIZE MEANS ASCIZ, GET SIZE
30$:	MOV	R2,-(SP)	;SAVE SIZE, POSSIBLY 0
	MOV	R1,-(SP)	;AND ADR OF PROG NAME
	MOV	C.CMLD+2(R5),R1	;ADR OF RECORD BUFFER
	MOV	C.CMLD(R5),R2	;SIZE OF RECORD BUFFER
	MOVB	#'/,(R1)+	;INIT WITH LEAD "/"
	DEC	R2		;AND ADJUST SIZE
	FDRC$R	#SWFDB,,R1,R2	;SET UP RECORD BUFFER
	FDOP$R	R0,(R5)		;AND LUN
	MOV	#SWFDB+F.FNB,R1
	CLR	R2
	MOV	#SWFNM,R3
	CALL	.PARSE
	BCS	CHKNSF
	OFNB$R	R0		;OPEN SWITCH.INI
	BCS	CHKNSF
50$:	GET$S	#SWFDB		;GET THE NEXT RECORD
	BCS	CHKEOF		;IF ERROR, THEN DONE
	MOV	F.NRBD+2(R0),R1	;ADR OF RECORD
	MOV	F.NRBD(R0),R2	;AND ITS SIZE
	BEQ	50$		;ALLOW NULL RECORDS
	DEC	R1		;INCLUDE THE "PLANTED" /
	INC	R2
	CSI$1	R5,R1,R2	;CHECK THE LINE'S SYNTAX
	BCS	BADLIN		;BRANCH IF NO GOOD
	BITB	#CS.EQU!CS.MOR!CS.DVF!CS.DIF!CS.NMF,C.STAT(R0)
	BNE	BADLIN		;ONLY SWITCHES AND VALUES ALLOWED
	INC	R1		;POINT TO 1ST CHAR OF PROG NAME
	MOV	C.CMLD(R5),R2	;GET POSSIBLY COMPACTED SIZE
	DEC	R2		;AND ACCOUNT FOR THE /
	MOV	R2,SWFDB+F.NRBD	;FIX RECORD SIZE FOR ERROR CASE
	MOV	(SP),R3		;ADR AND SIZE OF PROG NAME
	MOV	2(SP),R4
	CALL	COMPARE		;IS THIS LINE FOR THIS PROGRAM?
	BNE	50$		;BRANCH IF NO, TRY ANOTHER
	MOV	4(SP),R3	;ADDRESS OF OPTION NAME
	MOV	6(SP),R4	;SIZE OF OPTION NAME
	BEQ	80$		;BRANCH IF NO OPTION STRING
	CMPB	#':,(R1)+	;REQUIRE THE ":" AND SKIP IT
	BNE	50$		;NO ":", NO THE RIGHT OPTION
	DEC	R2
	CALL	COMPARE		;SEE IF THE OPTION MATCHES
	BNE	50$		;BRANCH IF OPTION MISMATCH
80$:	CMPB	#'/,(R1)	;MUST BE "/", NOT ":"
	BNE	50$		;IF NOT, THEN NO MATCH
	CSI$1	R0,R1,R2	;REINIT FOR CSI2 ON THE REST
	BCS	BADLIN		;THIS SHOULDN'T HAPPEN
	CSI$2	R0,OUTPUT,14(SP) ;PROCESS THE SWITCHES
	BCS	BADLIN
	BIS	C.MKW1(R0),12(SP) ;COLLECT MASK WORDS
	BIS	C.MKW2(R0),10(SP) ;FROM MULTIPLE RECORDS
	BR	50$

CHKEOF:	CMPB	#IE.EOF,F.ERR(R0)	;END OF FILE?
	BEQ	SUCCES
	BR	FCSERR
CHKNSF:	CMPB	#IE.NSF,F.ERR(R0) ;NO SUCH FILE?
	BEQ	SUCCES
FCSERR:	MOV	F.ERR(R0),R2	;ERROR CODE IN R2
	CLR	R1		;0 IN R1
	BR	FAILUR
BADLIN:	MOV	SWFDB+F.NRBD+2,R2 ;RECORD ADDRESS
	MOV	SWFDB+F.NRBD,R1	;AND SIZE
FAILURE:	SEC
	BR	EXIT
SUCCES:	CLR	R1
	CLR	R2
EXIT:	MOV	R1,C.FILD(R5)
	MOV	R2,C.FILD+2(R5)
	ROR	14(SP)		;SAVE C IN SAVED C.SWAD
	CLOSE$	#SWFDB
	MOV	R5,R0
	BIT	(SP)+,(SP)+
	BIT	(SP)+,(SP)+
	MOV	(SP)+,C.MKW2(R0) ;RETURN COMBINED MASKS
	MOV	(SP)+,C.MKW1(R0) ;FROM MULTIPLE RECORDS
	ROL	(SP)+		;POP THE SAVED C BIT
	RETURN

; COMPARE STRINGS - MATCH STRING 1 WITH BEGINNING OF STRING2
; INPUTS:
;	R3=ADR, R4 = SIZE OF STRING 1
;	R1 = ADR, R2 = SIZE OF STRING2
;
; OUTPUTS:
;	Z=1 IF EQUAL, Z = 0 IF NOT
;	R1, R2 UPDATED TO POINT AT FIRST CHARACTER NOT COMPARED
;
COMPARE:CMP	R2,R4		;STRING2 MUST BE AT LEAST
	BLT	20$		;AS BIG AS STRING1
10$:	MOVB	(R1)+,-(SP)	;SET UP TO COMPARE
	MOVB	(R3)+,1(SP)	;THE CHARACTERS
	BIC	#20040,(SP)	;WITHOUT THE CASE BITS
	CMPB	1(SP),(SP)+	;DO THEY MATCH?
	BNE	20$		;BRANCH IF NOT
	DEC	R2
	DEC	R4		;Z SET IF THIS FALLS THROUGH
	BGT	10$
20$:	RETURN

; GET SIZE OF ASCIZ STRING
;
; INPUTS:
;	R1 = STRING ADDRESS
; OUTPUTS:
;	R1 PRESERVED
; R2 = SIZE OF STRING
;
GETSIZ:	MOV	R1,R2
10$:	TSTB	(R2)+		;SEARCH FOR FIRST ZERO BYTE
	BNE	10$
	SUB	R1,R2
	DEC	R2		;CALCULATE SIZE
	RETURN			;AND RETURN


	.END
