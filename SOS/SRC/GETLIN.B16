MODULE GETLIN (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!	020705	PHL37691	Peter H. Lipman		14-May-1981
!		Adjust PAGHIG if "lines out of order" "page mark inserted"
!

!
!	GETLINE
!
!	THIS ROUTINE READS THE NEXT LINE FROM THE INPUT
!	FILE INTO THE BUFFER SPECIFIED.  IT DETERMINES THE
!	READ-IN ADDRESS BY USING THE LAST LINE ADDRESS+LENGTH
!	OF THE LAST LINE, EXCEPT WHEN THIS LEAVES TOO LITTLE
!	SPACE AT THE END OF THE BUFFER, IN WHICH CASE
!	IT CYCLES AROUND TO THE START OF THE BUFFER.  IN THIS WAY
!	THE BUFFER IS MANAGED AS A CIRCULAR POOL OF STORAGE.
!	THE NEXT LINE IS READ VIA A CALL TO 'GET', WHICH
!	READS THE TEXT FROM THE FILE DEVICE.   ON AN END-OF-
!	FILE, A DUMMY RECORD IS PLACED IN THE BUFFER, HAVING
!	ZERO DECLARED LENGTH.  THE LINE IS LINKED INTO THE
!	BUFFER AREA, WITH A LENGTH OF PREVIOUS LINE FIELD TO
!	ENABLE BACKWARDS SCANNING.  THE POINTER TO THE LAST
!	RECORD IN THE BUFFER IS SET TO THIS NEW RECORD.
!
!	THE LINE NUMBER IS EXTRACTED FROM THE TEXT BY A
!	SEQUENTIAL SCAN OF THE FIRST CHARACTERS.
!	IF GIVEN, IT IS SAVED IN THE LINE HEADER.  IF NO LINE
!	NUMBER EXISTS ON THE RECORD, AN ASSUMED LINE NUMBER IS
!	GENERATED AS ONE GREATER THAN THE PREVIOUS ONE,
!	AND THE LINE IS FLAGGED AS NOT HAVING A LINE NUMBER.
!
!	THE SEQUENCE OF THE LINES IS CHECKED, AND A WARNING
!	MESSAGE IS GIVEN IF TWO CONSECUTIVE LINES ARE OUT OF
!	SEQUENCE. 
!	THE AMOUNT OF FREE SPACE IS UPDATED, AND SOME RECORDS
!	WRITTEN TO THE OUTPUT FILE IS THE BUFFER IS TOO FULL.
!
!	PARAMETERS -
!		FILE - ADDRESS OF FILE DESCRIPTOR
!
!	RETURNS -
!		BUFFER FIELDS UPDATED
!		VALUE RETURNED IS ADDRESS OF LINE JUST READ,
!			OR -EOF IF AN END OF FILE.
!
!
!	V02.02	09-JUN-76	WTM
!	V02.01	19-MAR-76	WTM


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	GET,		! TO ACCESS FILE'S NEXT LINE
	FDBERR,		! REPORT ERROR FROM GET
	DUMP,		! IF BUFFER NOT OVERCROWDED
	ENDFILE,	! TO END FILE
	PRTLN,		! PRINT LINE NO FOR LTL
	PRINTN,		! PRINT NUMERIC VALUE
	PRINT;		! MESSAGE LTL;NOLINES

EXTERNAL
    ERMSGA,				! ERROR MESSAGE FOR GET ERROR
    FILUSE,				! CURRENT STATE OF FILES
    FILEIN,				! PRIMARY INPUT FDB
    FILECOP;				! COPY MODE INPUT FDB

GBLROUTINE (GETLINE(FILE))=

BEGIN
LOCAL
    ADR,
    I,
    PRVL,
    SCANFL;
BUFILE=.FILE;
PRVL=.BUFLST;
ADR=.PRVL+.(.PRVL)<0,8>*2;    !AVAIL SP AFTER LAST LINE
IF .ADR GTRU .BUFADR+.BUFLEN-FREETOP THEN
	BEGIN
	ADR=.BUFSTRT;
	BUFWRP=.BUFWRP+1;
	SETFLG(.PRVL,FLGWRP);
	END;
LINPAG(.ADR)=.BUFPG2;
LINLIN(.ADR)=(.(BUFPG2+2)+.SOSFLG[STEPN]);
IF (.SOSFLG AND NOLINS) NEQ 0 AND ((.FILE EQL FILEIN AND
	.FILUSE LSS 5) OR .FILE EQL FILECOP) THEN
		SCANFL=1
	ELSE
		SCANFL=0;
I=GET(LINTXT(.ADR),.FILE,LINPAG(.ADR),LINLIN(.ADR),.SOSFLG[STARTN],SCANFL);
IF .I LSS 0 THEN
	BEGIN
		!  	FAKE AN END OF FILE RECORD
	ENDFILE(.BUF);
	IF .I+1 LSS 0 THEN FDBERR(ERMSGA,.FILE);
	RETURN .BUFLST;
	END
ELSE
	LINLEN(.ADR)=(.I+8)/2;
LINPRV(.ADR)=.LINLEN(.PRVL);
BUFLST=.ADR;
IF .LINPAG(.ADR) NEQ .BUFPG2 THEN
	(BUFPG2+2)=0;
LINFLG(.ADR)=0;
IF .I GTR 502 THEN
	BEGIN
	PRINT(PLIT (%STRING('Line is too long',%CHAR(13),%CHAR(10))));
	PRTLN(.LINLIN(.ADR),.LINPAG(.ADR));
	PRINT(PLIT (%STRING(' Truncated.',%CHAR(13),%CHAR(10))));
	I=502;
	(LINTXT(.ADR)+.I-2)<8,8>=0;
	LINLEN(.ADR)=%O'377';
	END;
IF (.SOSFLG AND NOLINS) EQL 0 AND (.SCANFL AND 2) NEQ 0 THEN
	BEGIN
	IF NOT READONLY THEN
		BUFCHG=.BUFCHG+1;
	PRINT(PLIT (%STRING('Input assumed unsequenced',%CHAR(13),%CHAR(10))));
	SOSFLG=.SOSFLG OR NOLINS;
	END;
IF .BUFPG2 EQL .LINPAG(.ADR) AND .(BUFPG2+2) GEQU .LINLIN(.ADR) THEN
	BEGIN
	LINPAG(.ADR)=.LINPAG(.ADR)+1;
	IF .PAGHIG LSSU INF-1 THEN
		PAGHIG=.PAGHIG+1;
	IF (.SOSFLG AND NOLINS) NEQ 0 THEN
		LINLIN(.ADR)=.SOSFLG[STARTN];
	IF NOT READONLY THEN
		BEGIN
		BUFCHG=.BUFCHG+1;
		PRINT(PLIT (%STRING('Lines out of order.',%CHAR(13),%CHAR(10))));
		PRINT(PLIT ('P/M inserted for page '));
		PRINTN(.LINPAG(.ADR),1);
		PRINT(PLIT (%STRING('.',%CHAR(13),%CHAR(10))));
		END;
	END;
BUFPG2=.LINPAG(.ADR);
BUFPG2+2=.LINLIN(.ADR);
IF .BUFFIR EQL .BUFLST THEN
	BEGIN
	BUFPG1=.BUFPG2;
	BUFPG1+2=.(BUFPG2+2);
	END;
!	UPDATE FREE SPACE AND CALL DUMP IF NEEDED
IF .ADR LSSU .BUFFIR THEN	!READ INTO MIDDLE
	BUFFR1=.BUFFR1-(.I+8)
	ELSE
	BUFFR2=.BUFFR2-(.I+8);
IF NEEDSP THEN ADR=DUMP(.ADR);
RETURN .ADR;
END;


END ELUDOM
