MODULE ALTINS (
	IDENT = 'V03-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WILLIAM T. MARSHALL	19-MAR-76
!
! MODIFIED BY:
!
!	020705	PHL0705		Peter H. Lipman		19-Oct-1980
!
!		Eliminate use of ECHOCTL internal routine and use
!	ALTTYPEC since it will now do the job.
!		ALTUPDPOS no longer takes a repeat count.
!		INSCHARS uses INSFLG globally instead of accepting its
!	address as a parameter.
!


REQUIRE 'SRC$:SOSREQ.B16';

EXROUTINE
	LISTEN,		! READ CHAR(S) FROM TERMINAL OR INDIRECT FILE
	TYPE,		! TYPE A CHAR ON TTY
	PRINT,		! PRINT A MESSAGE
	CTRLR,		! RETYPE THE LINE
	ILLLTL,		! LINE TOO LONG ERROR MESSAGE
	ALTDEL,
	ALTPRT,
	ALTRTYPE,
	ALTTYPEC,
	ALTUPDPOS;

EXTERNAL
    NEWLNA: REF VECTOR[,BYTE];
EXTERNAL
    NCHR: M1TO1;
EXTERNAL
    OLINPT: REF VECTOR[,BYTE];
EXTERNAL
    INSFLG,				! ALTER/INSERT FLAGS
    NSLSH,				! COUNT OF "\" CURRENTLY PRINTED
    FSLSH,				! FLAG INDICATING THAT \...\ WAS OUTPUT
    HSLSH,				! LOCATION OF \...\ THAT WAS OUTPUT
    HORPOS,				! CURRENT HORIZONTAL POSITION OF CURSOR
    VERPOS,				! CURRENT VERTICAL POSITION OF CURSOR
    RSTFLG;				! LISTEN FLAG USED FOR READ WITH SPECIAL TERMINATORS
EXTERNAL
    NOECHO;
EXTERNAL
    ALTCHR: BYTE;

GBLNVROUTINE (ALTINS(CHAR))=
!
! INSERT SPECIFIED CHARACTER INTO LINE, UPDATING THE CURSOR POSITION
! AND ECHOING THE CHARACTER AS APPROPRIATE
!
BEGIN
(NCHR[-1]=.NCHR[-1]+1)<0,8>=.CHAR AND %O'0177';
IF .NOECHO<0,8> EQL 0 THEN
	ALTTYPEC(.CHAR,0)
ELSE	ALTUPDPOS(.CHAR,0);
IF .NCHR[1]-.NCHR[-1] LEQ 6 THEN LINETOOLONG;
END;

GBLROUTINE (INSCHARS)=
!
!	INSFLG IS A GLOBAL CONTAINING THE INSERT FLAG BITS.  IF ANY BITS
! ARE NON ZERO THEN THIS IS AN INSERT MODE CALL.  IF ALL ARE ZERO THEN
! THIS IS AN ALTER MODE CALL.  THE BITS HAVE THE FOLLOWING MEANINGS:
!	BIT 0	= 0 IF READING CHARACTER AT A TIME OR WITH SPECIAL TERMINATORS
!		= 1 IF READING LINE AT A TIME, ALL ECHOING BY TERM DRIVER
!	BIT 14  = 0 IF CALLED FROM ALTER COMMAND (READ ONLY BIT)
!		= 1 IF CALLED FROM INSERT COMMAND
!	BIT 15  = 0 IF ALTER INSERT MODE
!		= 1 IF CALLED FROM INSERT COMMAND.  (CLEARED BY <^A>)
!
BEGIN
LOCAL
    LSNFLG,
    CHAR;
DO	BEGIN
	IF .INSFLG<0,8> NEQ 0 THEN LSNFLG=%O'041'
	ELSE	BEGIN
		IF .NSLSH NEQ 0 OR .HORPOS EQL 0
			THEN LSNFLG=0
			ELSE LSNFLG=.RSTFLG<0,8>;
		END;
	CHAR=LISTEN(.LSNFLG);
	IF .INSFLG LSS 0 THEN
		BEGIN
		IF .CHAR EQL %CHAR(1) THEN	!SEE IF <^A><ESC>
			BEGIN
			CHAR=LISTEN(.LSNFLG);
			IF .CHAR NEQ %O'033' THEN ALTINS(%CHAR(1))
!
! <^A><ESC> IN INSERT MAKES THE TRANSITION TO ALTER MODE
! WITH THE CURSOR POSITIONED AT THE BEGINNING OF THE LINE
!
			ELSE	BEGIN
				IF .INSFLG<0,8> EQL 0 THEN TYPE('$');
				INSFLG=.INSFLG AND NOT %O'0100001';
				ALTPRT(0);
				END;
			END;
		IF .CHAR EQL %CHAR(26) THEN CHAR=%O'033'	!TURN <^Z> INTO <ESC>
		ELSE IF .CHAR EQL %CHAR(21) THEN	!<^U> ?
			BEGIN
			ALTTYPEC('U'-64,0);
			INSFLG=.INSFLG OR 1;
			RETURN 0;
			END;
		END;
	IF .CHAR EQL %CHAR(13) THEN		!<CR> ?
		BEGIN
		IF .INSFLG<0,8> EQL 0 THEN RETURN 1
		ELSE RETURN 8;
		END;
	IF .CHAR EQL %O'033' THEN		!<ESC> ?
		BEGIN
		IF .INSFLG GEQ 0 THEN RETURN %O'077777'
		ELSE	BEGIN
			IF .INSFLG<0,8> EQL 0 THEN ALTTYPEC('$',0);
			IF .NCHR[-1] EQL NEWLNA[7] THEN RETURN -1 ELSE RETURN 6;
			END;
		END;
	IF .CHAR<0,8> EQL .ALTCHR<0,8> THEN ALTINS(%O'033')
	ELSE IF .CHAR EQL %CHAR(10) THEN
	    BEGIN		!<LF>
	    IF .INSFLG LSS 0 THEN
		BEGIN		! <LF> IN INSERT MODE
		ALTINS(.CHAR);
		IF (.SOSFLG AND BASIC) NEQ 0 THEN ALTINS(%CHAR(13));
		END
	    ELSE RETURN 4;
	    END
	ELSE IF .CHAR EQL %CHAR(18) THEN
		BEGIN		!<^R>
		IF .INSFLG LSS 0 THEN
			BEGIN
			ALTTYPEC('R'-64,0);
			ALTRTYPE((.NCHR[-1]-NEWLNA[7]),0);
			END
		ELSE	CTRLR();
		END
	ELSE IF .CHAR EQL %O'0177' THEN
		BEGIN		!<DEL>
		IF .INSFLG<0,8> NEQ 0 THEN INSFLG<0,8>=0
		ELSE ALTDEL(-1,IF .INSFLG LSS 0 THEN 7 ELSE 5);
		END
	ELSE ALTINS(.CHAR);
	END WHILE 1;
RETURN 0;		! UNREACHABLE RETURN TO SATISFY BLISS-16
END;

END ELUDOM
