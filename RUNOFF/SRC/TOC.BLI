%TITLE 'Table of Contents formatter program'
MODULE TOCOOO (		!
		MAIN = TOC
		%BLISS36[, ENVIRONMENT (TOPS10), VERSION='2(1)' ]
		,IDENT = 'V03-000'
%BLISS32[,
	ADDRESSING_MODE(EXTERNAL=LONG_RELATIVE,NONEXTERNAL=LONG_RELATIVE)
	]
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
! FACILITY: RUNOFF document formatter
!
! ABSTRACT: Read and process a RUNOFF binary table of contents file.
!
!
! ENVIRONMENT: Transportable
!
! AUTHOR: R.W.Friday	 CREATION DATE: May, 1979
!
! MODIFIED BY:	K. A. Dawson
!
!	2.0-002	REM00014	Ray Marshall	9-December-1981
!		Made $XPO_INPUT device handling more forgiving.  On
!		  encountering and end-of-file, the current and all successive
!		  questions will take the default and no more questions will
!		  be asked.  If the EOF is given to the "Specify input file:"
!		  query, we now gracefully exit without doing any processing.
!
!	2.0-001	REM00013	Ray Marshall	3-December-1981
!		Change output of .SKIP directives in the .RNT file to .BLANK
!		  directives.  This is to be compatible with "Doc-Prep"
!		  conventions.
!		Modified CQCHAR_C such that ALL flag characters except "."
!		  are now quoted.  See note in CQCHAR_C about the CONTROL flag.
!		Added code to enclose the .RNT file between a .LIST/.END LIST
!		  pair.  This preserves and restores the user's context as best
!		  we can for now.
!
!	2.0	REM00012	R. E. Marshall	26-August-1981
!		Version 2.0 for release with VMS V3A.  No logic changes.
!
!	02601	REM00011	R. E. Marshall	22-April-1981
!		For Version 1.26a 
!		Updated version # for release using XPORT V1.0.
!		Modified prompts adding defaults:  Possible answers between []s
!						   Defaults between ()s
!
!	02600 	KAD00010	K. A. Dawson	15-October-1980
!		For- Version 1(24a)
!		Renamed variable BTC_FORMAT to TOC_FORMAT. Changed
!	        its value to 3. Added support for unnumbered heads, and for
!		not printing dots/page-number past a certain level. Fixed a
!		miscounting bug in keep-emphasis (NQCHAR_NC). Version 1.25:
!		changed version number only for release.
!
!
!
!--
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    CQCHAR_C : NOVALUE,
    ENDWRD : NOVALUE,
    OUTSEC : NOVALUE,
    OUTTXT : NOVALUE;
!
! INCLUDE FILES:
!
REQUIRE 'REQ:PAGEN.REQ';

REQUIRE 'REQ:TOCRTY.REQ';

LIBRARY 'NXPORT:XPORT';

!
! MACROS:
!
MACRO
    !Don't quote the character, and it doesn't count visually.
    NQCHAR_NC (X) =
	BEGIN
	CH$WCHAR_A(X, LINE_POINTER);
	INT_LINE_LENGTH = .INT_LINE_LENGTH + 1;
	END	%,

    !Don't quote the character, and it does count visually.
    NQCHAR_C (X) =
	BEGIN
	NQCHAR_NC (X);
	EXT_LINE_LENGTH = .EXT_LINE_LENGTH + 1;
	END	%,

    !Quote the character; it doesn't count visually.
    QCHAR_NC (X) =
	BEGIN
	NQCHAR_NC (%C'_');
	NQCHAR_NC (X);
	END	%,

    !Quote the character; it does count visually.
    QCHAR_C (X) =
	BEGIN
	NQCHAR_NC (%C'_');
	NQCHAR_C (X);
	END	%;

MACRO
    !Special macro to keep track of the backspace control character.
    BACKSPACE (X) =
	BEGIN
	QCHAR_NC (X);
	EXT_LINE_LENGTH = .EXT_LINE_LENGTH - 1;
	END	%;

MACRO
    !Clear the text lines being built up.
    CLR_RNO_LINE (_) =
	BEGIN
	LINE_POINTER = CH$PTR (RNO_LINE);
	INT_LINE_LENGTH = 0;
	EXT_LINE_LENGTH = 0;
	END	%;

MACRO
    !Write line to file, and clear all counters, etc.
    OUTNJ (_) =
	BEGIN
	$XPO_PUT (IOB = TOCOOB,
		  STRING = (.INT_LINE_LENGTH,
			    CH$PTR(RNO_LINE)) );
	CLR_RNO_LINE ();
	END	%;

MACRO
    !Insert specified character sequence into file, as is.
    DO_RNO (CMD) =
	$XPO_PUT (IOB = TOCOOB,
		 STRING = (CMD)  )  %;

MACRO
    !Generate RUNOFF code to skip a line.
    GCSKIP (_) =
	DO_RNO('.BLANK') %;

!
! EQUATED SYMBOLS:
!
LITERAL
    RINTES = %O'34' : UNSIGNED (8);

!This literal defines which .BTC format is appropriate for this program.
LITERAL
    TOC_FORMAT = 3;

LITERAL
    TRUE = 1,
    FALSE = 0;

LITERAL
    PAGE_WIDTH = 70,				!The user of the resulting .RNT file is suppose to use
						!this page width when he gives it to RUNOFF.
    HL1_START = 16,				!For .HL1s and chapter/appendix titles, start text after this column.
    STANDARD_INDENT = 8;			!Assume a .LM8 command before the start of this file.

!
! OWN STORAGE:
!
OWN
    TOCIOB : $XPO_IOB (),			!IOB for binary index file.
    TTIIOB : $XPO_IOB (),			!Terminal input.
    TOCOOB : $XPO_IOB (),			!IOB for the resulting .RNT file
    TTOIOB : $XPO_IOB ();			!Terminal output.

OWN
    LAST_HL,					!Highest "n" from .HL n for which corresponding TOC entry is wanted.
    LAST_NUM_HL,				!Highest "n" for page numbers are wanted.
    LEVEL_INDENT,				!Controls text indentation after header levels
    LEAVE_EMPHASIS,				!Controls whether underlining/bold info. in headings
						!/chapt./appendixes is passed through to TOC (kad).
    NUMBER_HEADS,				!Controls whether headings are numbered or not (V1.24, kad).
    HL_COUNT,					!Maximum number of header levels
    TEXT_LENGTH,				!Length of input text.
    TEXT : VECTOR [CH$ALLOCATION(1000)],	!Input text.
    HL_N,					!"n" from latest .HL n command
    HLLIST : VECTOR [100],			!Header level counters
    HLDSP : VECTOR [100],			!Header level display characteristics
    LAST_TEXT_TYPE : INITIAL (-1),		!Used for remembering .BLANKs, etc
    MAJOR_CODE,
    MINOR_CODE,
    STATUS,
    RUNNING_COUNT : INITIAL (FALSE),		!TRUE if running pages wanted instead of "normal" page number.
    PAGEN : PAGE_DEFINITION;			!Current page number.

OWN						!Storage for building up lines
    LINE_POINTER,				!CH$PTR along line being built up
    INT_LINE_LENGTH,				!Number of characters needed to represent text
    EXT_LINE_LENGTH,				!Number of resulting print positions
    RNO_LINE : VECTOR [CH$ALLOCATION (1000)];	!Buffer in which line is being built up.

OWN						!Storage for remembering words.
    WORD_PTR,					!CH$PTR to start of current word.
    WORD_EXT_LENGTH,				!Number of print positions in current word.
    WORD_INT_LENGTH;				!Number of characters needed to represent current word.

OWN						!Storage for a converted page number
    PAGE_LENGTH,				!Number of characters in the converted page number.
    PAGE_TEXT : VECTOR [CH$ALLOCATION (50)],	!The text (lots of room)
    PAGE_PTR;					!A CH$PTR (working pointer)

OWN						!Storage for building up a section number
    SECTION_LENGTH,				!Number of characters in the converted section number
    SECTION_TEXT : VECTOR [CH$ALLOCATION (50)],	!The text (lots of room)
    SECTION_PTR;				!A CH$PTR (working pointer)

OWN
    CONFUSE_COUNT : INITIAL (0),		!Vers. 1.24a -- count of number of CONFUSED messages.
    MAX_RIGHT,					!Used by ENDWRD for controlling filling lines.
    WRAP,					!Wrap long lines around to here.
    INDENT;					!Assume this standard indentation before the text.

!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
    PACBAS,
    PACPAG,
    PACSEC,
    PACXXX;


%sbttl 'TOC -- '
GLOBAL ROUTINE TOC =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TOC reads a binary table of contents file, as generated by RUNOFF
!	and uses it to generate a .RNT file.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	Implicit is the order in which records are written, and
!	the format of the file.
!	The format of the file is adequately documented by the code.  It will not be
!	further explained.
!	The order of information in the file is not obvious, although its use shows what
!	is available when.  Briefly, there is an entry in the file (MAJ_PAGE) for every
!	page in the document, regardless of whether or not that page is mentioned in the
!	table of contents.  Further, the page number is guaranteed to occur before you
!	get some text associated with that page.  So, if header level text is found,
!	the page number is already correct.  Similarily, header level numbers and
!	display information are always written before the header level text to which
!	it is applicable.  Note that the header level information is *not* reset in the
!	file at the start of a chapter; you have to wait for the next header level number
!	record to be input to be sure where you are.
!	The page number and header level information is as valid for text from the
!	.SEND command as it is for text from a .HL command.
!	Note also, that underlining and bolding information is ignored for header levels
!	but not for .SEND text.  That's because you may have headers underlined and/or bolded
!	in your document, but you probably don't want that information in the table of contents too.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    LOCAL
	RETURN_CODE;			!Return codes from $XPO_ operations

    $XPO_IOB_INIT (IOB = TOCIOB);		!Initialize input IOB
    $XPO_IOB_INIT (IOB = TOCOOB);		!Initialize output IOB
    $XPO_IOB_INIT (IOB = TTIIOB);		!Initialize terminal input IOB.
    $XPO_IOB_INIT (IOB = TTOIOB);		!Initialize terminal output IOB

    $XPO_OPEN (IOB = TTIIOB,			!Open terminal input IOB.
		FILE_SPEC = $XPO_INPUT,
		OPTIONS = INPUT);

    $XPO_OPEN (IOB = TTOIOB,			!Open terminal output IOB
		FILE_SPEC = $XPO_OUTPUT,
		OPTIONS = OUTPUT,
		ATTRIBUTES = RECORD);
    
    !Identify version of program.
%IF
    %BLISS(BLISS36)
%THEN
    $XPO_PUT (IOB = TTOIOB,
	      STRING = ('TOC, version 2(2)')	);
%ELSE
    $XPO_PUT (IOB = TTOIOB,
	      STRING = ('TOC, Version V2.0-002')	);
%FI

    !Get name of input file (.BTC file)

    $XPO_PUT (IOB = TTOIOB,
		STRING = ('Specify input file: ')   );

    IF
	(RETURN_CODE = $XPO_GET (IOB = TTIIOB))	!Read name of file.
		EQL XPO$_END_FILE
    THEN
	RETURN 1;	! On END-OF-FILE, exit from TOC

    $XPO_OPEN (IOB = TOCIOB,			!Open input IOB
		FILE_SPEC = TTIIOB [IOB$T_STRING],
		DEFAULT = ('.BTC'),
		OPTIONS = INPUT,
		ATTRIBUTES = BINARY);

    $XPO_OPEN (IOB = TOCOOB,			!Open output file
		FILE_SPEC = ('.RNT'),
		RELATED = TOCIOB [IOB$T_RESULTANT],
		OPTIONS = OUTPUT);

    !If previous read from $XPO_INPUT did not give an end-of-file,
    IF .RETURN_CODE NEQ XPO$_END_FILE  THEN
	BEGIN
	!Find out how header levels are to be arranged.
	$XPO_PUT (IOB = TTOIOB,
		  STRING = ('Varying header-level indents? [Y/N] (N)')  );

	RETURN_CODE = $XPO_GET (IOB = TTIIOB)	!Get user's response
	END;

    !First assume varying indentation not wanted.
    LEVEL_INDENT = FALSE;

    !Interpret response

    !Look at just first character of response.
    !Indeed, recognize "Y" and "y" as meaning YES, but all
    !other responses at being NO.
    IF
	.RETURN_CODE NEQ XPO$_END_FILE
		AND
	.TTIIOB [IOB$H_STRING] GTR 0
    THEN
	BEGIN
	LOCAL X;
	X = CH$RCHAR (.TTIIOB [IOB$A_STRING]);
	IF
	    (.X EQL %C'Y')
	    OR (.X EQL %C'y')
	THEN
	    LEVEL_INDENT = TRUE
	END;

    !If previous read from $XPO_INPUT did not give an end-of-file,
    IF .RETURN_CODE NEQ XPO$_END_FILE  THEN
	BEGIN
	!Determine if user wants running page numbers or normal page numbers.
	$XPO_PUT (IOB = TTOIOB, STRING = ('Running page counter? [Y/N] (N)') );

	RETURN_CODE = $XPO_GET (IOB = TTIIOB)		!Get user's response
	END;

    !Establish default:
    RUNNING_COUNT = FALSE;

    !Interpret response

    !Look at just first character of response.
    !Indeed, recognize "Y" and "y" as meaning YES, but all
    !other responses at being NO.
    IF
	.RETURN_CODE NEQ XPO$_END_FILE
		AND
	.TTIIOB [IOB$H_STRING] GTR 0
    THEN
	BEGIN
	LOCAL X;
	X = CH$RCHAR (.TTIIOB [IOB$A_STRING]);
	IF
	    (.X EQL %C'Y')
	    OR (.X EQL %C'y')
	THEN
	    RUNNING_COUNT = TRUE
	END;

    !Establish as default that all headers are to go into the TOC.
    LAST_HL = 99;

    !Get the deepest header level wanted.
    INCR J FROM 1 TO 3 DO				!Give user three tries to input a valid depth.
	BEGIN
	LOCAL
	    DEPTH,				!Deepest header level wanted.
	    PTR;				!A working CH$PTR.

	!If previous read from $XPO_INPUT did not give an end-of-file,
	IF .RETURN_CODE NEQ XPO$_END_FILE  THEN
	    BEGIN
	    !Ask user for deepest header level wanted.
	    $XPO_PUT (IOB = TTOIOB,
		  STRING = ('Specify deepest header level to include: [#] (99)'));
	
	    !Get user's response.  An empty line means the default is ok.
	    RETURN_CODE = $XPO_GET (IOB = TTIIOB)
	    END;
	
	!Validate user's response.
	IF
	    (.RETURN_CODE EQL XPO$_END_FILE)
			OR
	    (.TTIIOB [IOB$H_STRING] EQL 0)
	THEN
	    EXITLOOP;			!User hit RETURN, so use the default.

	!User gave a response, so validate it.
	DEPTH = 0;
	PTR = .TTIIOB [IOB$A_STRING];		!Copy the CH$PTR to the data.
	INCR I FROM 1 TO .TTIIOB [IOB$H_STRING] DO
	    BEGIN
	    LOCAL
		X;				!Temporary copy of current character.
	    X = CH$RCHAR_A (PTR);		!Get character.
	    !Validate this character.
	    IF
		(.X GEQ %C'0')
		AND (.X LEQ %C'9')
	    THEN
		DEPTH = 10*.DEPTH + (.X - %C'0') !Convert to decimal and add to current DEPTH.
	    ELSE
		BEGIN
		$XPO_PUT (IOB =TTOIOB,
			  STRING = ('[Illegal character.]'));
		DEPTH = -1;
		EXITLOOP
		END
	    END;
	
	!The scan character loop is exited with either syntactically
	!valid DEPTH, or a value of -1 for a bad character.
	!Validate the DEPTH given by the user.
	IF
	    .DEPTH GEQ 0
	THEN
	    !This is a really valid DEPTH.
	    !Pass it on for to the rest of the program.
	    BEGIN
	    LAST_HL = .DEPTH;
	    EXITLOOP				!This gets out of the 3-loop.
	    END
	END;

	IF
	    (.RETURN_CODE NEQ XPO$_END_FILE)
		AND
	    (.LAST_HL EQL 99)		!User input illegal character 3 times.
	THEN				!Take default and tell him.
	    BEGIN
	    $XPO_PUT (IOB =TTOIOB,
		      STRING = ('[All header levels will be included.]'));
	    $XPO_PUT (IOB =TTOIOB, STRING = (' '));
	    END;


    !Establish as default that page numbers are to be given for all headers.
    LAST_NUM_HL = 99;

    !Get the deepest header level for which page numbers are wanted.
    INCR J FROM 1 TO 3 DO			!Give user three tries to input a valid depth.
	BEGIN
	LOCAL
	    DEPTH,				!Deepest numbered level wanted.
	    PTR;				!A working CH$PTR.

	!If previous read from $XPO_INPUT did not give an end-of-file,
	IF .RETURN_CODE NEQ XPO$_END_FILE  THEN
	    BEGIN
	    !Ask user for deepest numbered level wanted.
	    $XPO_PUT (IOB = TTOIOB,
		  STRING = ('Specify deepest header level for which to print'));
	    $XPO_PUT (IOB = TTOIOB,
		  STRING = (' trailing dots and page number: [#] (99)'));
	
	    !Get user's response.  An empty line means the default is ok.
	    RETURN_CODE = $XPO_GET (IOB = TTIIOB)
	    END;
	
	!Validate user's response.
	IF
	    (.RETURN_CODE EQL XPO$_END_FILE)
			OR
	    (.TTIIOB [IOB$H_STRING] EQL 0)
	THEN
	    EXITLOOP;			!User hit RETURN, so use the default.

	!User gave a response, so validate it.
	DEPTH = 0;
	PTR = .TTIIOB [IOB$A_STRING];		!Copy the CH$PTR to the data.
	INCR I FROM 1 TO .TTIIOB [IOB$H_STRING] DO
	    BEGIN
	    LOCAL
		X;			!Temporary copy of current character.
	    X = CH$RCHAR_A (PTR);		!Get character.
	    !Validate this character.
	    IF
		(.X GEQ %C'0')
		AND (.X LEQ %C'9')
	    THEN
		DEPTH = 10*.DEPTH + (.X - %C'0') !Convert to decimal and add to current DEPTH.
	    ELSE
		BEGIN
		$XPO_PUT (IOB =TTOIOB,
			  STRING = ('[Illegal character.]'));
		DEPTH = -1;
		EXITLOOP
		END
	    END;
	
	!The scan character loop is exited with either syntactically
	!valid DEPTH, or a value of -1 for a bad character.
	!Validate the DEPTH given by the user.
	IF
	    .DEPTH GEQ 0
	THEN
	    !This is a really valid DEPTH.
	    !Pass it on for to the rest of the program.
	    BEGIN
	    LAST_NUM_HL = .DEPTH;
	    EXITLOOP				!This gets out of the 3-loop.
	    END
	END;

	IF
	    (.RETURN_CODE NEQ XPO$_END_FILE)
			  AND
	    (.LAST_NUM_HL EQL 99)	!User input illegal character 3 times.
	THEN				!Take default and tell him.
	    BEGIN
	    $XPO_PUT (IOB =TTOIOB,
		      STRING = ('[Page numbers will be given for all header levels.]'));
	    $XPO_PUT (IOB =TTOIOB, STRING = (' '));
	    END;

    !If previous read from $XPO_INPUT did not give an end-of-file,
    IF .RETURN_CODE NEQ XPO$_END_FILE  THEN
	BEGIN
	!Determine whether user wants emphasis (underlining/bold) carried over into the .RNT file.
	$XPO_PUT (IOB = TTOIOB, STRING = ('Keep chapter/header underlining and bolding? [Y/N] (N)')	);

	RETURN_CODE = $XPO_GET (IOB = TTIIOB)		!Get user's response
	END;

    !Initially assume emphasis will be stripped out.
    LEAVE_EMPHASIS = FALSE;

    !Interpret response

    !Look at just first character of response.
    !Indeed, recognize "Y" and "y" as meaning YES, but all
    !other responses as being NO.
    IF
	.RETURN_CODE NEQ XPO$_END_FILE
		    AND
	.TTIIOB [IOB$H_STRING] GTR 0
    THEN
	BEGIN
	LOCAL X;
	X = CH$RCHAR (.TTIIOB [IOB$A_STRING]);
	IF
	    (.X EQL %C'Y')
	    OR (.X EQL %C'y')
	THEN
	    LEAVE_EMPHASIS = TRUE
	END;

    !If previous read from $XPO_INPUT did not give an end-of-file,
    IF .RETURN_CODE NEQ XPO$_END_FILE  THEN
	BEGIN
	!Determine whether user wants numbered heads or unnumbered heads.
	$XPO_PUT (IOB = TTOIOB, STRING = ('Do you want headers numbered? [Y/N] (Y)')	);

	RETURN_CODE = $XPO_GET (IOB = TTIIOB)		!Get user's response
	END;

    !Initially assume numbered heads.
    NUMBER_HEADS = TRUE;

    !Interpret response

    !Look at just first character of response.
    !Indeed, recognize "N" and "n" as meaning NO, but all
    !other responses as being YES.
    IF
	.RETURN_CODE NEQ XPO$_END_FILE
		    AND
	.TTIIOB [IOB$H_STRING] GTR 0
    THEN
	BEGIN
	LOCAL X;
	X = CH$RCHAR (.TTIIOB [IOB$A_STRING]);
	IF
	    (.X EQL %C'N')
	    OR (.X EQL %C'n')
	THEN
	    NUMBER_HEADS = FALSE
	END;

    !Initialize counters.
    CLR_RNO_LINE ();

    !Preserve user's current environment as best we can at present.
    DO_RNO('.LIST');

    !Generate our required RUNOFF environment
    DO_RNO('.NF.NJ');

!!    !These additional directives were used to generate a "standard" RUNOFF
!!    !environment.  They are currently no longer used.
!!    DO_RNO('.NO FLAGS ALL');
!!    DO_RNO('.NO FLAG UPPER');
!!    DO_RNO('.NO FLAG LOWER');
!!    DO_RNO('.NO FLAG CAPITALIZE');
!!    DO_RNO('.NO FLAG INDEX');
!!    DO_RNO('.NO FLAG SPACE');
!!    DO_RNO('.NO FLAG ENDFOOTNOTE');
!!    DO_RNO('.NO FLAG PERIOD');
!!    DO_RNO('.NO FLAG SUBSTITUTE');
!!    DO_RNO('.NO FLAG HYPHENATE');
!!    DO_RNO('.NO FLAG BREAK');
!!    DO_RNO('.FLAG QUOTE _');
!!    DO_RNO('.FLAG UNDERLINE &');
!!    DO_RNO('.FLAG BOLD *');
!!    DO_RNO('.FLAG OVERSTRIKE %');
!!    DO_RNO('.FLAGS ALL');
    IF
	.LAST_HL NEQ 0
    THEN
	DO_RNO('.PS,70.LM8')
    ELSE
	DO_RNO('.PS,70');
    IF
	.LEAVE_EMPHASIS EQL TRUE
    THEN
	DO_RNO('.FLAGS BOLD');

    !Read record-groups until end of file.  Process each record group
    !in turn.  Return at end-of-file.
    WHILE TRUE DO
	BEGIN

	!Get major and minor codes.
	STATUS = $XPO_GET ( IOB = TOCIOB,
			    FULLWORDS = 2);

	IF!
	    .STATUS NEQ XPO$_NORMAL
	THEN
	!No record-group descriptor, and therefore no record-group.
	!I.e., end-of-file.
	    EXITLOOP;

	!Separate out the record descriptor and the format descriptor.
	BEGIN
	BIND
	    CODES = .TOCIOB [IOB$A_DATA] : VECTOR;

	MAJOR_CODE = .CODES [0];
	MINOR_CODE = .CODES [1];

	!Code for debugging here.
%IF %VARIANT
%THEN
	BEGIN
	LOCAL
	    CODE_LENGTH,
	    CODE_TEXT : VECTOR [CH$ALLOCATION(20)],
	    CODE_PTR;

	CODE_PTR = CH$PTR(CODE_TEXT);
	CODE_LENGTH = PACBAS (.MAJOR_CODE, CODE_PTR, 8);
	$XPO_PUT (IOB = TTOIOB, STRING = ('MAJOR CODE'));
	$XPO_PUT (IOB = TTOIOB, STRING = (.CODE_LENGTH, CH$PTR(CODE_TEXT)) );

	CODE_PTR = CH$PTR(CODE_TEXT);
	CODE_LENGTH = PACBAS (.MINOR_CODE, CODE_PTR, 8);
	$XPO_PUT (IOB = TTOIOB, STRING = ('MINOR CODE'));
	$XPO_PUT (IOB = TTOIOB, STRING = (.CODE_LENGTH, CH$PTR(CODE_TEXT)) );
	END;
%FI
	END;

	SELECTONE TRUE OF
	SET
	[.MAJOR_CODE EQL MAJ_NEW_TOC] :
		BEGIN
%IF %VARIANT
%THEN
			$XPO_PUT (IOB = TTOIOB,
				  STRING = (8,
					    CH$PTR(UPLIT('SEQUENCE'))) );
%FI

		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!Make sure this file is in the format expected.
		IF				!
		    .MINOR_CODE NEQ TOC_FORMAT
		THEN
		    !Warn the user that something's mucked up!!
		    $XPO_PUT (IOB = TTOIOB,
			      STRING = (37,
					CH$PTR(UPLIT('INCOMPATIBLE VERSIONS OF DSR AND TOC.'))) );

		END;


	[(.MAJOR_CODE EQL MAJ_RUNOFF) AND (.MINOR_CODE EQL MIN_PAGE)] :
		!Process a page number.
		BEGIN
%IF %VARIANT
%THEN
			  $XPO_PUT ( IOB =TTOIOB,
				     STRING = (4,
						CH$PTR(UPLIT('PAGE'))) );
%FI
		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!Read a page number.
		$XPO_GET (IOB = TOCIOB,
			  FULLWORDS = PAGE_SCT_SIZE);

		BEGIN
		!Copy page number to where it's safe.
		BIND
			PAGE_REF = .TOCIOB [IOB$A_DATA] : VECTOR [PAGE_SCT_SIZE];
		MAP
			PAGEN : VECTOR [PAGE_SCT_SIZE];

		INCR I FROM 1 TO PAGE_SCT_SIZE DO
			PAGEN [.I - 1] = .PAGE_REF [.I - 1];
		END;

		END;


	[(.MAJOR_CODE EQL MAJ_RUNOFF) AND (.MINOR_CODE EQL MIN_INDEX)] :
		!Make an entry in the table of contents for the index
		BEGIN
		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!Reset the .BLANK information
		LAST_TEXT_TYPE = MIN_INDEX;

		DO_RNO ('.BLANK');
		IF
		    .LAST_HL NEQ 0
		THEN
		    DO_RNO ('.I-8;Index')
		ELSE
		    DO_RNO ('Index');
		DO_RNO ('.BLANK');
		END;


	[(.MAJOR_CODE EQL MAJ_RUNOFF) AND (.MINOR_CODE EQL MIN_HL_INF)] :
		!Read header level counters and display descriptors
		BEGIN
%IF %VARIANT
%THEN
			$XPO_PUT (IOB = TTOIOB,
				  STRING = (7,
					    CH$PTR(UPLIT('HL_INFO'))) );
%FI
		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!First get count of header level counters.
		$XPO_GET (IOB = TOCIOB, FULLWORDS = 1);
		HL_COUNT = .(.TOCIOB [IOB$A_DATA]);
		
		!Next, get the "n" value for this ".HL n" command
		$XPO_GET (IOB = TOCIOB, FULLWORDS = 1);
		HL_N = .(.TOCIOB [IOB$A_DATA]);

		!Now read the complete set of header level counters, not all of which are important
		$XPO_GET (IOB = TOCIOB, FULLWORDS = .HL_COUNT);
		!Copy the header level counters to a safe place
		BEGIN
		BIND
		    X = .TOCIOB [IOB$A_DATA] : VECTOR;

		INCR I FROM 1 TO .HL_COUNT DO
		    HLLIST [.I - 1] = .X [.I - 1];
		END;

		!Finally, read the header level display descriptors.
		$XPO_GET (IOB = TOCIOB, FULLWORDS = .HL_COUNT);
		!Copy the header level descriptors to a safe place
		BEGIN
		BIND
		    X = .TOCIOB [IOB$A_DATA] : VECTOR;

		INCR I FROM 1 TO .HL_COUNT DO
		    HLDSP [.I - 1] = .X [.I - 1];
		END;

		END;


	[(.MAJOR_CODE EQL MAJ_RUNOFF) AND
           (.MINOR_CODE EQL MIN_HL_TXT OR .MINOR_CODE EQL MIN_HL_TXT_U)] :
		!Process the text part of a header level.
		BEGIN
		LOCAL
		    NEEDED_FILL;
%IF %VARIANT
%THEN
			$XPO_PUT (IOB = TTOIOB,
				  STRING = (7,
					    CH$PTR(UPLIT('HL_TEXT'))) );
%FI

		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!First read the number of characters needed to represent the header level
		$XPO_GET ( IOB = TOCIOB, FULLWORDS = 1);
		TEXT_LENGTH = .(.TOCIOB [IOB$A_DATA]);	!Save text length.
		
		!Generate a table of contents entry only if the header level
		!has some text associated with it
		IF					!
		    .TEXT_LENGTH GTR 0
		THEN
		    !The header level does have text associated with it
		    BEGIN

		    !Now actually read the header level text
		    $XPO_GET ( IOB = TOCIOB, FULLWORDS = CH$ALLOCATION (.TEXT_LENGTH));

		    !Generate the associated TOC text only if this header level
		    !is within the depth specified by the user.
		    IF
			.HL_N LEQ .LAST_HL
		    THEN
			!OK.  The user wants to include this header level in the table of contents.
			BEGIN
			!Copy text from input buffer to a save area.
			CH$MOVE (.TEXT_LENGTH, CH$PTR(.TOCIOB [IOB$A_DATA]), CH$PTR (TEXT));

			!.HEADER LEVEL text just changes the .BLANK information.  It doesn't use it
			LAST_TEXT_TYPE = MIN_HL_TXT;
	
			!Initialize output line.
			CLR_RNO_LINE ();

			!All header level entries are generated under the assumption of
			!a .LM8 command in the file.  Therefore, even though no text has been
			!generated yet we have to act as if 8 characters have been taken up.
			EXT_LINE_LENGTH = STANDARD_INDENT;

			!Set standard indentation in front of this header level line
			INDENT = STANDARD_INDENT;

			!Generate the header level numbers if the header is
			! numbered. If unnumbered, just put out the text.
			OUTSEC ();

			!Set up line-wrap point
			WRAP = .EXT_LINE_LENGTH;

			!Generate the page number so as to get its length.
			!This is needed so that the proper number of dots can be supplied.
			PAGE_PTR = CH$PTR (PAGE_TEXT);
			IF
			    .RUNNING_COUNT
			THEN
			    !Use the running page counter instead of a real page number.
			    PAGE_LENGTH = PACBAS (.PAGEN [SCT_RUN_PAGE], PAGE_PTR, 10)
			ELSE
			    !Supply the usual page number.
			    PAGE_LENGTH = PACPAG (PAGEN, PAGE_PTR);

			!Set limit beyond which words must be wrapped
			MAX_RIGHT = PAGE_WIDTH - .PAGE_LENGTH - 1;

			!Scan text and put it onto the line.
			IF	!
			    .LEAVE_EMPHASIS EQL TRUE
			THEN	!TRUE => keep any bolding / underlining
			    OUTTXT (.TEXT_LENGTH, CH$PTR(TEXT), TRUE)
			ELSE	!FALSE => throw away any bolding / underlining 
			    OUTTXT (.TEXT_LENGTH, CH$PTR(TEXT), FALSE);

			!If we're leaving header emphasis, add "\&\*".
			IF	!
			    .LEAVE_EMPHASIS EQL TRUE
			THEN	!TRUE => keep any bolding / underlining
			    BEGIN
			    NQCHAR_NC(%C'\');
			    NQCHAR_NC(%C'&');
			    NQCHAR_NC(%C'\');
			    NQCHAR_NC(%C'*');
			    END;

			IF
			    .HL_N LEQ .LAST_NUM_HL
			THEN
			    !OK. User wants this header to show dots and page number.
			    BEGIN
			    !Insert a sequence of alternating dots and spaces out to where the
			    !page number will go.
			    !First force a space to follow the last text character.
			    IF
				.EXT_LINE_LENGTH LSS .MAX_RIGHT
			    THEN
				!The position of the last character of the text
				!is not inside where the page number goes.
				NQCHAR_C(%C' ');
			    !Compute how much fill is needed.  We always terminate in such a way
			    !that one space will be preceed the page number.
			    NEEDED_FILL = .MAX_RIGHT;

			    !Now start inserting the dot-space sequence
			    INCR I FROM (.EXT_LINE_LENGTH + 1) TO .NEEDED_FILL DO
			    !Insert a space for odd columns, a dot for even ones.
			    IF
				.I
			    THEN
				NQCHAR_C(%C' ')
			    ELSE
				NQCHAR_C(%C'.');
			
			    !Insert a space following the sequence so there's
			    ! no dot just before the page number.
			    NQCHAR_C(%C' ');

			    !Before putting the page number through the standard text processor,
			    !set the wrap point in case the page number doesn't fit.  
			    WRAP = PAGE_WIDTH - .PAGE_LENGTH;

			    !Allow the page number to cause the line to be
			    ! filled out to the full page width.
			    MAX_RIGHT = PAGE_WIDTH;

			    !Finally, insert the generated page number onto the line
			    !FALSE is a meaningless parameter in this case.  Note that the text
			    !representing the page number could simply have been copied in.  We're
			    !going through the trouble of scanning it however, because OUTTXT takes
			    !care of wrapping long lines around, and this could be one.
			    OUTTXT (.PAGE_LENGTH, CH$PTR(PAGE_TEXT), FALSE);
			    END;

			!Now actually put this line of text into the file
			OUTNJ ();

			END
		    END

		END;


	[(.MAJOR_CODE EQL MAJ_RUNOFF) AND ((.MINOR_CODE EQL MIN_CHAPT) OR (.MINOR_CODE EQL MIN_APPEND))] :
		!Process the start of a chapter or appendix
		BEGIN

		LOCAL
		    PTR;
%IF %VARIANT
%THEN
			$XPO_PUT (IOB = TTOIOB,
				  STRING = (12,
					    CH$PTR(UPLIT('CHAPT/APPEND'))) );
%FI

		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!Clear the text buffer
		CLR_RNO_LINE ();

		!Standard skipping before chapter/appendix entries
		IF
		    .LAST_HL NEQ 0
	 	THEN
		DO_RNO ('.TEST PAGE 5');	!Space for skipping, title, and one .HL
		!The "pre-chapter" skip depends on what went into the .RNT file last.
		IF
		    .LAST_HL NEQ 0
	 	THEN
		    IF
			.LAST_TEXT_TYPE NEQ MIN_CHAPT
		    THEN
			DO_RNO ('.SK2.I-8')
		    ELSE
			DO_RNO ('.SK1.I-8');

		!Now reset the .BLANK information
		LAST_TEXT_TYPE = MIN_CHAPT;

		!Although the initial line of a chapter or appendix title starts flush
		!left, continuation lines get the standard indentation.
		INDENT = STANDARD_INDENT;

		!Allow text to be output right out to the full page width
		MAX_RIGHT = PAGE_WIDTH;

		!Insert the word CHAPTER or APPENDIX
		IF
		    .MINOR_CODE EQL MIN_CHAPT
		THEN
		    !This is the start of a chapter
		    BEGIN
		    SECTION_PTR = CH$PTR ( UPLIT('CHAPTER '));
		    SECTION_LENGTH = 8;
		    END
		ELSE
		    !This is the start of an appendix
		    BEGIN
		    SECTION_PTR = CH$PTR ( UPLIT('APPENDIX '));
		    SECTION_LENGTH = 9;
		    END;

		!Copy the word CHAPTER/APPENDIX to the buffer
		INCR I FROM 1 TO .SECTION_LENGTH DO
		    NQCHAR_C ( CH$RCHAR_A(SECTION_PTR) );
		
		!Convert the "number" of this chapter/appendix to its visual form.
		SECTION_PTR = CH$PTR (SECTION_TEXT);
		SECTION_LENGTH = PACSEC (PAGEN, SECTION_PTR);

		!Copy the converted chapter/appendix number into the buffer
		SECTION_PTR = CH$PTR (SECTION_TEXT);
		INCR I FROM 1 TO .SECTION_LENGTH DO
		    NQCHAR_C ( CH$RCHAR_A(SECTION_PTR) );

		!Determine the number of characters in the chapter/appendix title.
		$XPO_GET ( IOB = TOCIOB, FULLWORDS = 1);
		TEXT_LENGTH = .(.TOCIOB [IOB$A_DATA]);	!Save text length.
		
		!The following processing is necessary only if the chapter/appendix
		!has a title.
		IF					!
		    .TEXT_LENGTH GTR 0
		THEN
		    !The chapter/appendix does have a title.
		    BEGIN

		    !Now actually read the text
		    $XPO_GET ( IOB = TOCIOB, FULLWORDS = CH$ALLOCATION (.TEXT_LENGTH));
		    !Copy text from input buffer to a save area.
		    CH$MOVE (.TEXT_LENGTH, CH$PTR(.TOCIOB [IOB$A_DATA]), CH$PTR (TEXT));

		    !Insert spaces so the first character of the chapter lines up with
		    !the first character of a .HL1 item
		    INCR I FROM .EXT_LINE_LENGTH + 1 TO HL1_START DO
			NQCHAR_C (%C' ');
		    !Be sure that long chapter titles get wrapped around correctly
		    WRAP = .EXT_LINE_LENGTH;
    
		    !Scan text and put it onto the line.
			IF	!
			    .LEAVE_EMPHASIS EQL TRUE
			THEN	!TRUE => keep any bolding / underlining
			    OUTTXT (.TEXT_LENGTH, CH$PTR(TEXT), TRUE)
			ELSE	!FALSE => throw away any bolding / underlining 
			    OUTTXT (.TEXT_LENGTH, CH$PTR(TEXT), FALSE);

		    !If we're leaving header emphasis, add "\&\*".
			IF	!
			    .LEAVE_EMPHASIS EQL TRUE
			THEN	!TRUE => keep any bolding / underlining
			    BEGIN
			    NQCHAR_NC(%C'\');
			    NQCHAR_NC(%C'&');
			    NQCHAR_NC(%C'\');
			    NQCHAR_NC(%C'*');
			    END;

		    END;

		!Now actually put this line of text into the file
		OUTNJ ();
		
		!Standard skipping after starting chapter/appendix entry
		DO_RNO ('.BLANK');

		END;


	[.MAJOR_CODE EQL MAJ_SEND] :
		!Process text given on a .SEND command
		!NOTE:  When the user said .SEND TOC n,text the value of "n"
		!	was written to the file too.  It is now available as
		!	the value saved in MINOR_CODE.  If the user didn't
		!	specify n, then 0 was passed.
		!	RUNOFF also parsed the text, taking care of various flags.
		!	The *parsed* form is what is being processed, not the "raw" input.
		!	This sample code
		!	shows how to process the text, with the result that it's
		!	inserted directly into the .RNT file.

		!NOTE:	This program attaches no meaning to the value of n; in fact, it
		!	ignores it.  Therefore anyone who modifies this program is free
		!	to attach his own personal meaning.  However, to avoid confusion,
		!	the following values/meanings are recommended.
		!	0	Should continue to work as shown here
		!	1	Figure captions
		!	2	Table captions
		!	3	Example caption
		BEGIN

		LOCAL
		    PTR;
%IF %VARIANT
%THEN
			$XPO_PUT (IOB = TTOIOB,
				  STRING = (4,
					    CH$PTR(UPLIT('SEND'))) );
%FI

		!Reset count of CONFUSED messages.
		CONFUSE_COUNT = 0;
		!Clear the text buffer
		CLR_RNO_LINE ();

		!A .SEND TOC command destroys .BLANK information.
		LAST_TEXT_TYPE = -1;

		!Assume standard indentation
		INDENT = STANDARD_INDENT;

		!Wrap around long text to indentation point
		WRAP = STANDARD_INDENT;

		!Allow text to extend to the full page width.
		MAX_RIGHT = PAGE_WIDTH;

		!Determine the number of characters specified on the .SEND command
		$XPO_GET ( IOB = TOCIOB, FULLWORDS = 1);
		TEXT_LENGTH = .(.TOCIOB [IOB$A_DATA]);	!Save text length.
		
		!If there was text given process it.
		IF					!
		    .TEXT_LENGTH GTR 0
		THEN
		    !There was text given.
		    BEGIN

		    !Now actually read the text
		    $XPO_GET ( IOB = TOCIOB, FULLWORDS = CH$ALLOCATION (.TEXT_LENGTH));
		    !Copy text from input buffer to a save area.
		    CH$MOVE (.TEXT_LENGTH, CH$PTR(.TOCIOB [IOB$A_DATA]), CH$PTR (TEXT));

		    !Because of the standard indentation, we've already filled through column 8
		    !even though nothing has been output as yet.
		    EXT_LINE_LENGTH = STANDARD_INDENT;
    
		    !Scan text and put it onto the line.
			IF	!
			    .LEAVE_EMPHASIS EQL TRUE
			THEN	!TRUE => keep any bolding / underlining
			    OUTTXT (.TEXT_LENGTH, CH$PTR(TEXT), TRUE)
			ELSE	!FALSE => throw away any bolding / underlining 
			    OUTTXT (.TEXT_LENGTH, CH$PTR(TEXT), FALSE);

		    !Output this line of text into the table of contents
		    OUTNJ ();

		    END;

		END;


	[OTHERWISE]	: BEGIN
			  CONFUSE_COUNT = .CONFUSE_COUNT + 1;
			  IF 
				.CONFUSE_COUNT LEQ 5 
			  THEN
				$XPO_PUT (IOB = TTOIOB,
				    STRING = (8,
				      CH$PTR(UPLIT('CONFUSED')))  );
!			  EXITLOOP;
			  END;
	TES;
	END;

!!    !Turn off overstriking, so that only the standard flags are still on
!!    DO_RNO ('.NO FLAG OVERSTRIKE');

!!    !Restore left margin so remainder of document is correct
!!    DO_RNO ('.LEFT MARGIN 0');

    !If we're keeping header emphasis, turn off the bold flag.
    IF    !
        .LEAVE_EMPHASIS EQL TRUE
    THEN    !TRUE => keep any bolding / underlining
    DO_RNO ('.NO FLAGS BOLD');

    !Restore what we can of the user's environment as it was before it started
    !processing the .RNT file.  This is the best we can do at present.
    DO_RNO('.END LIST 0');

    !Finished processing file.
    $XPO_CLOSE (IOB = TOCIOB);			!Close input file
    $XPO_CLOSE (IOB = TOCOOB);			!Close output file


    $XPO_PUT (IOB = TTOIOB,			!Tell user we're done.
		STRING = (8,
			   CH$PTR(UPLIT('FINISHED'))) );

    $XPO_CLOSE (IOB = TTOIOB);			!Close the terminal for output.
    $XPO_CLOSE (IOB = TTIIOB);			!Close the terminal for input.

    RETURN 1					!Successful completion (by definition)

    END;			!End of TOC

ROUTINE OUTSEC : NOVALUE = 		!

!++
! FUNCTIONAL DESCRIPTION:
!
!	OUTSEC generates a section number of the form 1.2.3.....
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	HL_WIDTH;				!Number of columns reserved for header level.

    SECTION_LENGTH = 0;
    SECTION_PTR = CH$PTR (SECTION_TEXT);

    IF 						!
	.PAGEN [SCT_TYP] NEQ 0
    THEN
    !This is a document divided into sections.
	BEGIN
	SECTION_LENGTH = PACSEC (PAGEN, SECTION_PTR);

	INCR I FROM 1 TO .HL_N DO
	    BEGIN
	    CH$WCHAR_A (%C'.', SECTION_PTR);
	    SECTION_LENGTH = .SECTION_LENGTH + 1;
	    SECTION_LENGTH = .SECTION_LENGTH + PACXXX (.HLLIST [.I - 1], SECTION_PTR, .HLDSP [.I - 1]);
	    END;

	END
    ELSE
    !Not a document divided into sections.
	BEGIN

	IF 					!
	    .HL_N EQL 1
	THEN
	!Special case for .HEADER LEVEL 1
	    BEGIN
	    SECTION_LENGTH = PACXXX (.HLLIST [0], SECTION_PTR, .HLDSP [0]);
	    CH$WCHAR_A (%C'.', SECTION_PTR);
	    CH$WCHAR_A (%C'0', SECTION_PTR);
	    SECTION_LENGTH = .SECTION_LENGTH + 2;
	    !Move section into the line being built
	    SECTION_PTR = CH$PTR (SECTION_TEXT);
	    INCR I FROM 1 TO .SECTION_LENGTH DO
		!Don't write the number if user said heads are unnumbered.
		IF
		   .NUMBER_HEADS
		THEN
		    NQCHAR_C ( CH$RCHAR_A(SECTION_PTR) )
		ELSE
		    NQCHAR_C (%C' ');
	    !Pad this .HL1 out to the alignment point
	    INCR I FROM (.EXT_LINE_LENGTH + 1) TO HL1_START DO
		NQCHAR_C (%C' ');
	    RETURN;
	    END;

	!Not a .HEADER LEVEL 1

	INCR I FROM 1 TO .HL_N DO
	    BEGIN
	    SECTION_LENGTH = .SECTION_LENGTH + PACXXX (.HLLIST [.I - 1], SECTION_PTR, .HLDSP [.I - 1]);
	    CH$WCHAR_A (%C'.', SECTION_PTR);
	    SECTION_LENGTH = .SECTION_LENGTH + 1;
	    END;

	!Always get an extra dot, so uncount it.
	SECTION_LENGTH = .SECTION_LENGTH - 1;
	END;

    !Now copy the converted section number into the line that's being built up.
    SECTION_PTR = CH$PTR (SECTION_TEXT);
    INCR I FROM 1 TO .SECTION_LENGTH DO
  	!Don't write the number if user said heads are unnumbered.
	IF
	   .NUMBER_HEADS
	THEN
	    NQCHAR_C ( CH$RCHAR_A(SECTION_PTR) )
	ELSE
	    NQCHAR_C (%C' ');

    !Compute the width of the region into which the header level number was supposed to fit.
    IF
	NOT .LEVEL_INDENT
    THEN
	!User said NO to varying indent question.
	!In this case, use simple indentation style.
	IF						!
	    .HL_N EQL 1
	THEN
	    !For .HL1s
	    HL_WIDTH = HL1_START
	ELSE
	    !Not .HL1
	    HL_WIDTH = HL1_START + 2
    ELSE
	!User replied YES to varying indentation question.
	!Indent two columns for every level numbered.
	HL_WIDTH = HL1_START + 2*(.HL_N - 1);

    !Pad out this .HL number to fill the columns allocated.
    INCR I FROM (.EXT_LINE_LENGTH + 1) TO .HL_WIDTH DO
	NQCHAR_C (%C' ');

    END;					!End of OUTSEC


%sbttl 'CQCHAR_C -- quote RUNOFF flag characters'
ROUTINE CQCHAR_C (X) :NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	The purpose of this routine is to dress up the RUNOFF input
!	file a bit that is generated by this module.  Basically, it
!	ensures that only special characters get output prefixed with
!	the QUOTE flag.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    IF!
	(.X LSS %C' ')		!Control character?
	OR (.X GTR %O'176')
    THEN			!Yup, it's a control character.
	    IF
		(.X NEQ %O'10')	  !Backspace?
	    THEN
		QCHAR_NC(.X)	  !Nope, just a normal control character
	    ELSE
		BACKSPACE(.X)	  !Yup, it's a backspace.
    ELSE			!Nope, not a control character.
	    IF			  !Is it one of the following RUNOFF flags????
		   (.X EQL %C'_') ! ACCEPT flag
		OR (.X EQL %C'*') ! BOLD flag
		OR (.X EQL %C'|') ! BREAK flag
		OR (.X EQL %C'<') ! CAPITALIZE flag
		OR (.X EQL %C'!') ! COMMENT flag
		OR (.X EQL %C'=') ! HYPHENATE flag
		OR (.X EQL %C'>') ! INDEX & SUBINDEX flag
		OR (.X EQL %C'\') ! LOWERCASE flag
		OR (.X EQL %C'%') ! OVERSTRIKE flag
		OR (.X EQL %C'+') ! PERIOD flag
		OR (.X EQL %C'#') ! SPACE flag
		OR (.X EQL %C'$') ! SUBSTITUTE flag
		OR (.X EQL %C'&') ! UNDERLINE flag
		OR (.X EQL %C'^') ! UPPERCASE flag
!NOTE:  Not quoting a '.' means the user can use .SEND TOC to insert runoff
!	commands into the .RNT file.
!!!		OR (.X EQL %C'.') ! CONTROL flag
	    THEN		   !Yup, it's a RUNOFF flag.
		IF	!
		    (.MAJOR_CODE NEQ MAJ_SEND)	!Is this entry from SEND TOC?
		THEN
		    QCHAR_C(.X)		!No, it's from HL/CH/AX -- quote it.
		ELSE
		    NQCHAR_C(.X)	!Yes, it's from SEND TOC -- don't quote it.
	    ELSE
		!Check for end-of-word, so lines can be wrapped
		IF			!
		    .X EQL %C' '
		THEN
		    !It's a space ending a word.
		    ENDWRD (TRUE)
		ELSE
		    !Not a space
		    NQCHAR_C(.X);


    END;			!End of CQCHAR_C

ROUTINE ENDWRD (SPACE) : NOVALUE = 		!

!++
! FUNCTIONAL DESCRIPTION:
!
!	ENDWRD is called when a space is about to be output.  It makes sure that the word that
!	the space ends fits on the the line.  If it doesn't, it wraps the line.
!
! FORMAL PARAMETERS:
!
!	If SPACE is TRUE, a space is generated to terminate the word.
!
! IMPLICIT INPUTS:
!
!	MAX_RIGHT indicates how far to the right this word can extend.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    !If the last word fits on the line just remember the current status
    !and the a pointer to where the next word starts.
    IF						!
	.EXT_LINE_LENGTH LEQ .MAX_RIGHT
    THEN
	!The last word fits
	BEGIN
	!See if user wants a terminating space generated
	IF					!
	    .SPACE
	THEN
	    !Yup, user wants a space generated.  Generate one.
	    NQCHAR_C (%C' ');
	!Remember current lengths and location.  They will be used when
	!an "offending" word gets picked up.
	WORD_EXT_LENGTH = .EXT_LINE_LENGTH;
	WORD_INT_LENGTH = .INT_LINE_LENGTH;
	WORD_PTR = .LINE_POINTER;
	RETURN;
	END;

    !The word that this space terminates does not fit.  Wrap the line.

    !First determine the length of the word just ended.
    !Note that WORD_xxxxx was set at the beginning of the word that this space terminates,
    !while the normal counters have been updated ever since.
    WORD_EXT_LENGTH = .EXT_LINE_LENGTH - .WORD_EXT_LENGTH;		!External length
    WORD_INT_LENGTH = .INT_LINE_LENGTH - .WORD_INT_LENGTH;		!Internal representation.

    !Now adjust the current line lengths before outputting the line
    EXT_LINE_LENGTH = .EXT_LINE_LENGTH - .WORD_EXT_LENGTH;		!External length
    INT_LINE_LENGTH = .INT_LINE_LENGTH - .WORD_INT_LENGTH;		!Internal representation.

    !Before outputting the line that is to be wrapped, make sure that at least two
    !lines are still available on the page.  This avoids having the first part of
    !the text on one page and the last part of it on another page.
    DO_RNO ('.TEST PAGE 2');

    !And now output the line, up to but not including the word that this space terminates.
    OUTNJ ();

    !Add sufficient spaces to align the wrapped word with the first character of the line that
    !was just terminated.
    INCR I FROM 1 TO (.WRAP - .INDENT) DO
	NQCHAR_C (%C' ');
    !Adjust the external line length.  It really represents .INDENT additional characters.
    EXT_LINE_LENGTH = .EXT_LINE_LENGTH + .INDENT;

    !At this point the word that would have overflowed the line is sitting out in limbo.
    !But, we know its length and where it is.  Move it to the left so that it's aligned properly.
    INCR I FROM 1 TO .WORD_INT_LENGTH DO
	CH$WCHAR_A ( CH$RCHAR_A(WORD_PTR), LINE_POINTER );

    !And finally, update the counters that were bypassed in the move
    EXT_LINE_LENGTH = .EXT_LINE_LENGTH + .WORD_EXT_LENGTH;
    INT_LINE_LENGTH = .INT_LINE_LENGTH + .WORD_INT_LENGTH;

    !Before finishing, generate a space to terminate this word, if desired
    IF								!
	.SPACE
    THEN
	!Yup, a space is wanted
	NQCHAR_C (%C' ');

    !Remember current lengths for use the next time around.
    WORD_EXT_LENGTH = .EXT_LINE_LENGTH;
    WORD_INT_LENGTH = .INT_LINE_LENGTH;
    !Remember the start of this word for the next time around.
    WORD_PTR = .LINE_POINTER;
    !NOTE:  Remembering the status just saved could be done by calling ENDWRD recursively.  BUT
    !	   that wouldn't work well if the line consisted of a single huge word.  At least this way
    !	   forces it out.

    END;					!End of ENDWRD

ROUTINE OUTTXT (TEXT_LENGTH, TEXT_PTR, BLDUND) : NOVALUE =	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	Scans a line of text from the table of contents file and
!	puts the resulting text into the RNT output file
!
! FORMAL PARAMETERS:
!
!	TEXT_LENGTH is the number of characters to be scanned
!	TEXT_PTR is a CH$PTR to the start of the text.
!	BLDUND determines whether or not bolding and/or underlining information
!	should be used, if it's present.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	PTR;

    PTR = .TEXT_PTR;

    !Remember status at start of current word.
    WORD_PTR = .LINE_POINTER;
    WORD_EXT_LENGTH = .EXT_LINE_LENGTH;
    WORD_INT_LENGTH = .INT_LINE_LENGTH;

    !Now scan the text, translating underlining, etc, back to standard flag sequences.
    INCR I FROM 1 TO .TEXT_LENGTH DO
	BEGIN
	LOCAL
	    CHAR;

	CHAR = CH$RCHAR_A(PTR);

	!Detect and process escape sequences.
	IF					!
	    .CHAR NEQ RINTES
	THEN
	    !Not an escape sequence.  But check to see if it's still special.
	    CQCHAR_C (.CHAR)
	ELSE
	    !An escape sequence has been found.
	    BEGIN
	    LOCAL
		OPERATION,
		OPERAND;

	    !Fetch the operation code
	    OPERATION = CH$RCHAR_A(PTR);
	    !Fetch the operand
	    OPERAND = CH$RCHAR_A(PTR);
	    !Count off these two characters, to keep the loop counter correct
	    I = .I + 2;

	    !Now check for overstriking
	    IF
		.OPERATION EQL %C'O'
	    THEN
		!Yup, found overstriking.
		!Overstriking is *always* done
		BEGIN
!!		!Conditionally quote the operand.  That's because the overstrike flag
!!		!doesn't check, and we're reversing the character sequence here.
!!		CQCHAR_C (.OPERAND);
!!The following is a bug fix.
		!Always quote the operand.  That's because the overstrike flag
		!doesn't check, and we're reversion the character sequence here.
		QCHAR_NC (.OPERAND);
!!End of bug fix
		!Output the overstrike flag.  Note that it does not count visually.
		!An implication here is that the character to be overstruck will
		!eventually be found somewhere down the line.
		NQCHAR_NC (%C'%');
		END
	    ELSE
		!Something other than overstriking.
		!Throw it away, unless .BLDUND is TRUE.
		IF				!
		    .BLDUND
		THEN
		    !Use the information
		    BEGIN
		    IF
			.OPERATION EQL %C'U'
		    THEN
			!Underlining
			NQCHAR_NC (%C'&')		!Output an underline flag
		    ELSE
			IF
			    .OPERATION EQL %C'B'
			THEN
			    !Bolding
			    NQCHAR_NC (%C'*')		!Output a bold flag
		    END
	    END
	END;

    !Terminate the word just put on the line
    ENDWRD (FALSE);

    END;			!End of OUTTXT

END						!End of module
ELUDOM

