MODULE HLOOOO (					!
		IDENT = '019'
%BLISS32[,
	ADDRESSING_MODE(EXTERNAL=LONG_RELATIVE,NONEXTERNAL=LONG_RELATIVE)
	]
		) =
BEGIN
!
!			  COPYRIGHT (c) 1981 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!
!++
! FACILITY: RUNOFF document formatter
!
! ABSTRACT: Processes .HEADER LEVEL and .SET LEVEL commands
!
!
! ENVIRONMENT: Transportable
!
! AUTHOR: R.W.Friday	 CREATION DATE: August, 1978
!
! MODIFIED BY:
!
!	019	KAD000019	K. A. Dawson	2 April 1982
!		Fixed bug: any .HL sent to the TOC while the left margin was
!		  greater than 0 added extra space on the left of TOC entry.
!
!	018	KAD000018	K. A. Dawson	29 January 1982
!		Fixed bug: a run-in header with no text lost 3 characters
!		  from the MRA, and could cause an access violation
!
!	017	KAD000017	K. A. Dawson	28 October 1981
!		Fixed bug: a run-in header ending with a space caused a
!		  program crash with a register-dump.
!	
!	016	REM000016	Ray Marshall	22-October-1981
!		Justification was set to the gender of the AUTOJUSTIFICATION
!		  flag.  I changed it to fit the following truth table:
!
!		   justification  |  autojustify  ||  Just. after .hl
!		   ---------------+---------------++-------------------
!			off	  |	off	  ||	    off
!		   ---------------+---------------++-------------------
!			off	  |	on	  ||	    on
!		   ---------------+---------------++-------------------
!			on	  |	off	  ||	    on
!		   ---------------+---------------++-------------------
!			on	  |	on	  ||	    on
!		   ---------------+---------------++-------------------
!
!	015	REM000015	Ray Marshall	19-October-1981
!		Filled in revision history as best I could from the five
!		  generations in the STEP library.  I also got several helpful
!		  inputs from Keith Dawson.
!
!	014	KAD000014	K. A. Dawson	7 October 1981
!		Make long HL's wrap to text margin, but send entire long header
!		  to TOC (if requested).  Truncate autosubtitle generated from
!		  long 	header and append "..." to it.
!
!	013	REM000013	Ray Marshall	25-August-1981
!		Reformat revision history.
!		Update copyright
!
!	012	RWF000012	Rich Friday	26-January-1981
!		For VERSION 1(124) 1(126a), New .SET LEVEL command.
!
!	011	KAD000011	Keith Dawson	21-October-1980
!		Added REQ: logical to point to the require files in the REQUIRE
!		  statements.
!		Added support for the .[NO ]AUTOJUSTIFY directive.
!
!	010	KAD000010	Keith Dawson	27-August-1980		
!	 	Protective coding to put out at most 75 spaces following the
!		  header number.
!		Honor zero-skip specified in .STHL (do not skip if 0).
!		Added comments and did final implementation of parameters 4
!		  through 9 to .STHL directive.
!		Added many blank lines to improve readability.
!		Moved control from literals HEADLC, HEADLT,... to HLC require
!		  file and added HLC_ prefix to the names.
!		*** Some of this work appears to have been done by Rich Friday.
!
!		************************************************************
!		*							   *
!		* As there is no record of versions 007, 008, and 009	   *
!		* available,  we must assume that the changes made are all *
!		* folded into the above history entry.  (REM 19-Oct-1981)  *
!		*							   *
!		************************************************************
!
!	006	RWF00006	Rich Friday	June-1980
!		Initial version inserted into STEP library.  (I presume this
!		  version was generated by Rich and was inserted in the library
!		  by Keith.  I know of no previous history available.  /  REM)
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    OUTSEC : NOVALUE,
    CASE_RULES : NOVALUE;
!
! INCLUDE FILES:
!

REQUIRE 'REQ:BOOL.REQ';

REQUIRE 'REQ:CLIST.REQ';

REQUIRE 'REQ:FSPACK.REQ';

REQUIRE 'REQ:GCA.REQ';

REQUIRE 'REQ:HCT.REQ';

REQUIRE 'REQ:HLC.REQ';

REQUIRE 'REQ:NBITS.REQ';

REQUIRE 'REQ:NUMPRM.REQ';

REQUIRE 'REQ:PAGEN.REQ';

REQUIRE 'REQ:PDT.REQ';

REQUIRE 'REQ:PHDEF.REQ';

REQUIRE 'REQ:RUNHAN.REQ';

REQUIRE 'REQ:SCA.REQ';

REQUIRE 'REQ:SETCAS.REQ';

REQUIRE 'REQ:TOCRTY.REQ';

REQUIRE 'REQ:TSF.REQ';

!
! MACROS:
!
!
! EQUATED SYMBOLS:
!

EXTERNAL LITERAL
    RINTES : UNSIGNED (8);

EXTERNAL LITERAL
    S_FMRA;				!Allocated length for footnote MRA.
!
! OWN STORAGE:
!
!
! EXTERNAL REFERENCES:
!

EXTERNAL
    FOOMRA : FIXED_STRING,
    FOOTSF : VECTOR [TSF_SIZE],
    FS01 : FIXED_STRING,
    GCA : GCA_DEFINITION,
    HCT : HCT_DEFINITION,
    HLC : HLC_DEFINITION,
    HLLIST : COUNTED_LIST,
    HLDSP : VECTOR,
    IRA : FIXED_STRING,
    MRA : REF FIXED_STRING,
    NUMPRM : NUMPRM_DEFINE,
    NPAGEN : PAGE_DEFINITION,
    PAGEN : PAGE_DEFINITION,
    PDT : REF PDT_DEFINITION,
    PHAN : PHAN_DEFINITION,
    SBTMRA : FIXED_STRING,
    SBTTSF : VECTOR,
    SCA : SCA_DEFINITION,
    TSF : TSF_DEFINITION,
    TTABLE : COUNTED_LIST;

EXTERNAL
    KHAR;

EXTERNAL LITERAL 				!Error messages
    RNFINM;

EXTERNAL ROUTINE
    ENDCHR,
    ENDWRD,
    ERMA,
    GCSKIP,
    GTPC,
    OUTNJ,
    OUTCRG,
    PACXXX,
    PACSEC,
    PUTHLI,
    PUTTPG,
    PUTTXT,
    SCANT,
    SETCAS,
    SKPSEP,
    TITLES;


GLOBAL ROUTINE HL (HANDLER_CODE) : NOVALUE = 	!

!++
! FUNCTIONAL DESCRIPTION:
!
!	See the ABSTRACT, above.
!
! FORMAL PARAMETERS:
!
!	HANDLER_CODE says whether it's .HL or .SET LEVEL
!
! IMPLICIT INPUTS:
!
!	NUMPRM contains a number as processed by GETNUM.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	GEN_CHAR,
	HOLD_LST_SP,
	HOLD_MRA,
	HOLD_TSF,
	HOLD_WRD_PNTR,
	SCA_HOLD : VECTOR [SCA_SIZE];

    SELECT .HANDLER_CODE OF
	SET

	[H_HEADER_LEVEL] :
	    BEGIN
	    GTPC (.HLC_HEADLT + .HLC_HEADLB + (.SCA_SPACING*.PDT_TP));	!See if enough space on page.
	
	    !Now, force the paper to be positioned as it should.
	    !The reason for forcing it, rather than allowing it to happen
	    !the "normal" way, is that the user may have said something such
	    !as ".NUMBER INDEX", which, by definition, does not take effect
	    !in the middle of a page.  By forcing the paper to be positioned,
	    !.HEADER LEVELs that would be forced onto the next page
	    !anyway can get influenced by commands such as just mentioned.
	    OUTCRG ();

	    IF 						!
		NOT .SCA_SECT_EMPTY
		AND (.HLC_HEADLB GTR 0)		!Do not skip if user said 0 space in a previous .STHL command.
	    THEN
		GCSKIP (MAX (1, .HLC_HEADLB - (.SCA_SPACING - 1)));	!Normal spacing added automatically.
	
	    END;

	[ALWAYS] :				!For both .HL and .SET LEVEL
	    BEGIN

	    !Process the number given as a parameter on the .HL or .SET LEVEL command
	    IF 						!
		.NUM_SIGN NEQ 0
	    THEN
	    !Process a relative header level.
		NUM_VALUE = .HLLIST [CL_INDEX] + .NUM_VALUE
	    ELSE

		IF 					!
		    .NUM_LENGTH EQL 0
		THEN
		    !Continue on at same level.
		    NUM_VALUE = .HLLIST [CL_INDEX];

	    IF 						!Validate resultant header level.
		(.NUM_VALUE LEQ 0)			!
		OR (.NUM_VALUE GTR .HLLIST [CL_MAX_INDEX])
	    THEN
	    !Illegal header number.
		BEGIN
		ERMA (RNFINM, FALSE);
		NUM_VALUE = .HLLIST [CL_INDEX];		!Stay at current level.
		END;
	
	    END;

	[H_HEADER_LEVEL] :
	    BEGIN

	    !Bump counter at specified level.
	    HLLIST [.NUM_VALUE] = .HLLIST [.NUM_VALUE] + 1;

	    !Zero all higher numbered counters.
	    INCR I FROM (.NUM_VALUE + 1) TO .HLLIST [CL_MAX_INDEX] DO
		HLLIST [.I] = 0;

	    END;

	[ALWAYS] :					!For both .HL and .SET LEVEL
	    BEGIN

	    !Now set desired level.
	    HLLIST [CL_INDEX] = .NUM_VALUE;

	    END;

	[H_SET_LEVEL] : RETURN;

	TES;

    !What follows is done only for the .HL command

    !If at the top of any page, output the page number. This is being done
    !being done because of problems with the the design of RUNOFF.  NEWPAG
    !won't output the page number until this header level text forces a
    !title to be generated, which may be too late in this case. 
    IF
	.GCA_BTC
	AND .PHAN_TOP_PAGE
    THEN
	IF
	    .PHAN_TOP_FIRST
	THEN
	    PUTTPG (PAGEN)
	ELSE
	    PUTTPG (NPAGEN);

    !If creating a binary table of contents file, write out the
    !header level information.
    IF
	.GCA_BTC
    THEN
	!Yup, user is generating a table of contents.
	PUTHLI ();

    !Save scanning information
    INCR I FROM 0 TO SCA_SIZE - 1 DO
	SCA_HOLD [.I] = .SCA [.I];

!+
! If either (1) this head will become an autosubtitle or (2) user is creating a
! .BTC file, then we must scan the text twice. The first time we scan it at full
! width, 150 characters, for subtitle and/or TOC. If the subtitle actually runs
! wider than the current right margin, however, we truncate it and append "...".
!-
    IF
	!An autosubtitle?
	(.GCA_AUTOSUBT GEQ .HLLIST [CL_INDEX]) AND .HCT_SUBTITLE
	OR
	!Doing TOC?
	.GCA_BTC
    THEN	
	BEGIN
	LOCAL
	    HOLD_RM,
	    IRA_HOLD : VECTOR [10],
	    HOLD_KHAR;

	!Save IRA and KHAR.
	INCR I FROM 0 TO 10 - 1 DO
	    IRA_HOLD [.I] = .IRA [.I];
	HOLD_KHAR = .KHAR;
	HOLD_RM = .SCA_RM;

	SCA_PRESCAN = TRUE;		!A ';' terminates this command.
	SCA_RSKIPS = TRUE;		!Ignore multiple spaces and tabs.
	SCA_FILL = FALSE;
	SCA_JUSTIFY = FALSE;
	!Set right margin big to catch long headers.
	SCA_RM = 150;
	SCA_LM = 0;			!Fix LM.neq.0 bug in TOC (ident 019).
	SCA_DO_IND = FALSE;		!Ignore indexing for subtitle/TOC scan.
	
	!If the user said .AUTOSUBTITLE n and this is a HEADER LEVEL of n or less,
	!and subtitles are wanted, the subtitle has to be modified.  The method
	!is to temporarily leave the current MRA/TSF alone and switch to those
	!for the subtitle. The routine TITLES, which normally processes
	!titles/subtitles, contains the necessary logic. 
	IF
	    (.GCA_AUTOSUBT GEQ .HLLIST [CL_INDEX]) AND .HCT_SUBTITLE
	THEN
	    !Collect header level in subtitle buffer
	    BEGIN
	    LOCAL
		HOLD_NBITS;

	    !Skip leading spaces and tabs, and a (possible) leading comma.
	    SKPSEP (IRA);

	    !Set up case rules for the heading.
	    CASE_RULES ();

	    !Use TITLES to get the subtitle.
	    TITLES (-1);

	    !Temporarily switch back to the subtitle TSF
	    HOLD_TSF = .TSF;
	    TSF = SBTTSF;

	    !Carry over underlining/bolding, etc, as specified.
	    TSF_NBITS = .TSF_NBITS AND .HLC_CO_NBITS;

	    !Return to the actual TSF
	    TSF = .HOLD_TSF;

	    !If user called for BTC, write header text from subtitle MRA to .BTC file.
	    IF
		!Doing TOC?
		.GCA_BTC
	    THEN
		PUTTXT (.FS_LENGTH(SBTMRA), .FS_START(SBTMRA), MAJ_RUNOFF,
			IF
			    .HLC_NO_NUMBER LEQ .HLLIST [CL_INDEX]	!Distinguish num. / unnum. hls.
			THEN
			    MIN_HL_TXT_U				!Unnumbered header level
			ELSE
			    MIN_HL_TXT);				!Numbered header level

	    END							!End of autosubtitle processing.
	ELSE
	    !Just going to TOC, and is not an auto-subtitle.
	    BEGIN

	    !Switch to the Footnote TSF and MRA (which are not otherwise used in headers) to
	    !collect the header information for the TOC.

	    HOLD_MRA = .MRA;
	    MRA = FOOMRA;
	    HOLD_TSF = .TSF;
	    TSF = FOOTSF;

	    !Before initializing the text descriptors, it is necessary to explicitly
	    !reset the maximum length of the footnote MRA. It is clobbered if any 
	    !footnotes have been processed so far. See the comments in FNONLY around
	    !line 1545 for the detailed justification.
	    FS_MAXSIZE (MRA) = S_FMRA;

    	    !Now initialize the text descriptors.
	    FS_INIT (MRA);
	    INCR I FROM 0 TO TSF_SIZE - 1 DO
		TSF [.I] = 0;

	    !Skip leading spaces and tabs, and a (possible) leading comma.
	    SKPSEP (IRA);

	    !Set up case rules for the heading.
	    CASE_RULES ();

	    !Scan 150-wide into footnote MRA.
	    SCANT ();
	    ENDWRD (FALSE, FALSE, FALSE);

	    !Write header text to .BTC file.
	    PUTTXT (.FS_LENGTH(FOOMRA), .FS_START(FOOMRA), MAJ_RUNOFF,
		IF
		    .HLC_NO_NUMBER LEQ .HLLIST [CL_INDEX]	!Distinguish num. / unnum. hls.
		THEN
		    MIN_HL_TXT_U				!Unnumbered header level
		ELSE
		    MIN_HL_TXT);				!Numbered header level

	    !Switch TSF and MRA back.
	    MRA = .HOLD_MRA;
	    TSF = .HOLD_TSF;
	    END;						!End of TOC-only processing.

	!Restore IRA and KHAR.
	INCR I FROM 0 TO 10 - 1 DO
	    IRA [.I] = .IRA_HOLD [.I];
	KHAR = .HOLD_KHAR;

	END;						!End of subtitle-or-TOC processing
!
    INCR I FROM 0 TO SCA_SIZE - 1 DO
	SCA [.I] = .SCA_HOLD [.I];
    SCA_FILL = TRUE;		!Fill the header even if not filling text.
    SCA_PRESCAN = TRUE;		!A ';' terminates this command.
    SCA_RSKIPS = TRUE;		!Ignore multiple spaces and tabs.

    !Generate the number for the header level if not turned off.
    IF
	.HLC_NO_NUMBER GTR .HLLIST [CL_INDEX]
    THEN
	!User didn't turn off the numbering, so generate the header level number.
	BEGIN
	!Generate the header number in standard format.
	OUTSEC ();

	!Put the header number into the output buffer.
	FS_NEXT (FS01) = .FS_START (FS01);
	INCR I FROM 1 TO .FS_LENGTH (FS01) DO
	    BEGIN
	    LOCAL
		TEMP_CHAR;
	    FS_RCHAR (FS01, TEMP_CHAR);
	    ENDCHR (.TEMP_CHAR);
	    END;

	!Insert spaces after the number. Do not put out more than 75 spaces 
	!regardless of what the user said.
	INCR I FROM 1 TO (MIN (.HLC_HEADSP, 75)) DO
	ENDCHR (%C' ');

	!Using ENDCHR, the section number was built up like a word.  Now
	!end that word, without a trailing space or justification mark.
	ENDWRD (FALSE, FALSE, FALSE);

	END;			!End of code to generate header level numbers.

    !Remember number of characters generated for use later.
    GEN_CHAR = .TSF_INT_HL;

    !Set left margin beyond the number just put out.
    SCA_LM = .TSF_EXT_HL;

    !Skip leading spaces and tabs, and a (possible) leading comma.
    SKPSEP (IRA);

    !Set up case rules for the heading.
    CASE_RULES ();

    !Tell SCANT that the first character of the header is the first
    !character of a word. (ENDCHR turned this stuff off before.)
    SCA_FC_CASE = TRUE;
    SCA_FC = FALSE;

    SCANT ();				!Go get it

    !SCA_WRD_CPEND equals rintes IFF there was a trailing space/tab
    !after the text.  In such a case ENDWRD has already been called.
    !Calling it again would have the effect of forcing an additional
    !space out into TSF/MRA.
    IF 					!
	.SCA_WRD_CPEND NEQ RINTES
    THEN
	ENDWRD (FALSE, FALSE, FALSE)
    ELSE
	IF 					!
	    .SCA_WRD_LST_UND EQL 0
	    AND				! This fixes null-text-on-
	    .SCA_WRD_LST_SP GTR 0	! run-in-header bug.
	THEN
	    !Chop off trailing spaces/tabs.  When doing so, also back up
	    !intra-line pointer and counter appropriately. If justification
	    !was in effect, also cancel the justification mark that got writ-
	    !ten onto the MRA.
	    !Note that trailing spaces that are underlined are not discarded. 
	    BEGIN
	    LOCAL
		CHARS_TO_DROP;
	    CHARS_TO_DROP = .SCA_WRD_LST_SP +
		( IF
		    .SCA_JUSTIFY 
		THEN  3 
		ELSE  0
		) ;
	    FS_LENGTH (MRA) = .FS_LENGTH (MRA) - .CHARS_TO_DROP;
	    FS_NEXT (MRA) = CH$PLUS (.FS_NEXT (MRA), -.CHARS_TO_DROP);
	    SCA_WRD_LST_SP = 0;
	    END;

    !Restore previous scanner rules and set standard rules. Usually, it
    !suffices to restore the previous scanner rules, and that's all. That
    !works because after ENDWRD is called there is nothing left in the SCA
    !that needs to be remembered. Simply restoring the SCA is then
    !equivalent to a type of block structure. However, there is one case
    !when the pointer to the *next* word needs to be carried over; that is
    !when the text of the header lever is too long for the current line,
    !and it's a "runon" header. In that case, if the pointer is not carried
    !over, generating the '-' after the text will not work, and will
    !actually cause an internal logic error (RNFILE) when ENDWRD eventually
    !gets called by some other routine, later. 
    HOLD_WRD_PNTR = .SCA_WRD_PNTR;		!Remember start of next word.
    HOLD_LST_SP = .SCA_WRD_LST_SP;		!Remember last-space info.
    INCR I FROM 0 TO SCA_SIZE - 1 DO
	SCA [.I] = .SCA_HOLD [.I];
    SCA_WRD_PNTR = .HOLD_WRD_PNTR;		!Restore start of next word.
    SCA_WRD_LST_SP = .HOLD_LST_SP;		!Restore last-space info.

    !Set proper case conversion for remainder of section.
    SETCAS (.GCA_CASE);

    SCA_FILL = TRUE;				!Duplicate this crock.
    SCA_JUSTIFY = (.GCA_AUTOJUST OR .SCA_JUSTIFY); !Turn on justification unless user said .NO AUTOJUSTIFY.
    SCA_CROCK = .GCA_AUTOJUST;			!...

    !Differentiate between header levels that are on a single line, and
    !those for which a '-' has to be generated with following text
    !running on.
    IF 						!
	.HLC_RUNON GTR .HLLIST [CL_INDEX]
    THEN
    !Not a 'run-on' header level
	BEGIN
	!If this header is to be centered, compute amount to shift it.
	IF
	    .HLLIST[CL_INDEX] GEQ .HLC_CENTER
	THEN
	    !This header is to be centered
	    TSF_ADJUST = (.GCA_LWIDTH - .TSF_EXT_HL)/2;

	OUTNJ ();				!Force out the header.
	!Do not skip lines if user specified 0 space in a previous .STHL command.
	IF			!
	    .HLC_HEADLC GTR 0
	THEN
	    !OK to skip line(s).
	    GCSKIP (MAX (1, .HLC_HEADLC - (.SCA_SPACING - 1)));
	SCA_SECT_EMPTY = TRUE;			!This section is empty right now.
	RETURN;
	END
    ELSE
    !This is a 'run-on' header level
	BEGIN
	IF 					!
	    .GEN_CHAR NEQ .TSF_INT_HL
	THEN
	!There was some text after the section number, so generate the '-'.
	    BEGIN
	    ENDCHR (%C' ');
	    ENDCHR (%C'-');
	    ENDWRD (TRUE, FALSE, FALSE);
	    END;

	RETURN;
	END;

    END;					!End of HL

GLOBAL ROUTINE OUTSEC : NOVALUE = 		!

!++
! FUNCTIONAL DESCRIPTION:
!
!	OUTSEC generates a section number of the form 1.2.3.....
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    FS_INIT (FS01);

    IF 						!
	.PAGEN [SCT_TYP] NEQ 0
    THEN
    !This is a document divided into sections.
	BEGIN
	FS_LENGTH (FS01) = PACSEC (PAGEN, FS_NEXT (FS01));

	INCR I FROM 1 TO .HLLIST [CL_INDEX] DO
	    BEGIN
	    FS_WCHAR (FS01, %C'.');
	    FS_LENGTH (FS01) = .FS_LENGTH (FS01) + PACXXX (.HLLIST [.I], FS_NEXT (FS01), .HLDSP [.I - 1]);
	    END;

	END
    ELSE
    !Not a document divided into sections.
	BEGIN

	IF 					!
	    .HLLIST [CL_INDEX] EQL 1
	THEN
	!Special case for .HEADER LEVEL 1
	    BEGIN
	    FS_LENGTH (FS01) = PACXXX (.HLLIST [1], FS_NEXT (FS01), .HLDSP [0]);
	    FS_WCHAR (FS01, %C'.');
	    FS_WCHAR (FS01, %C'0');
	    RETURN;
	    END;

	!Not a .HEADER LEVEL 1

	INCR I FROM 1 TO .HLLIST [CL_INDEX] DO
	    BEGIN
	    FS_LENGTH (FS01) = .FS_LENGTH (FS01) + PACXXX (.HLLIST [.I], FS_NEXT (FS01), .HLDSP [.I - 1]);
	    FS_WCHAR (FS01, %C'.');
	    END;

	!Always get an extra dot, so remove it.
	FS_LENGTH (FS01) = .FS_LENGTH (FS01) - 1;
	CH$PLUS (FS_NEXT (FS01), -1);
	END;

    END;					!End of OUTSEC

ROUTINE CASE_RULES : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CASE_RULES sets up case rules for the heading. The routine
!	simply collects in one place a common sequence of code; it
!	exists because the header text is scanned twice by HL: once for
!	subtitle and/or TOC, and again for the header text.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    !Initially assume no case change wanted.
    SETCAS (LEAVE_CASE);

    !Take care of capitalization of first character of each word.
    IF
	(.HLC_CAP GEQ .HLLIST [CL_INDEX])
    THEN
	SETCAS (FIRST_CAPS);

    !Forcing all letters to upper case has precedence over leaving other
    !letters alone.
    IF
	(.HLC_UPPER GEQ .HLLIST [CL_INDEX])
    THEN
	!Force entire header level to upper case.
	SETCAS (FORCE_UPPER);

    END;					!End of CASE_RULES

END						!End of module
ELUDOM
