	.TITLE	HLDMAIN - HLD MAINLINE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: DECNET HOST LOADER (HLD)
;
; ABSTRACT:
;
;	HLD IS A COMPONENT OF DECNET/VAX-11. IT PROVIDES ACCESS TO
;	RSX11S TASK IMAGES STORED ON A VAX SYSTEM.
;
; ENVIRONMENT:
;
;	THE HLD IMAGE EXECUTES IN THE CONTEXT OF A PROCESS CREATED BY
;	NETACP. IT RUNS IN USER MODE AND REQUIRES NETWORK PRIVILEGE.
;
; AUTHOR: SCOTT G. DAVIS,	CREATION DATE: 10-MAY-79
;
; MODIFICATIONS:
;
;--
;
; MACROS:
;
;	NONE
	.PAGE
	.SBTTL	HLD$START - MAINLINE
	.PSECT	HLD$CODE	NOSHR,EXE,RD,NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
;	HLD$START IS RESPONSIBLE FOR HLD INITIALIZATION AND TERMINATION.
;
; CALLING SEQUENCE:
;
;	HLD IS INITIATED BY NETACP.
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	LOGICAL NAME 'SYS$NET'
;
;--

	.ENTRY	HLD$START,^M<>		; ENTRY POINT FROM EXECUTIVE

;
; OPEN THE PRINT FILE
;

	MOVAB	W^HLD$PRTFAB,R0		; SET TO OPEN FILE
	BSBW	HLD$RMS_OPEN		; DO IT
	MOVAB	W^HLD$PRTRAB,R0		; SET TO CONNECT REACORD STREAM
	BSBW	HLD$RMS_CONNECT		; DO IT
;
; CREATE A CONTROL/INFORMATION PATH TO NETACP IN PREPARATION FOR
; NON-TRANSPARENT NETWORK I/O. ALSO ASSOCIATE A MAILBOX WITH THE
; CHANNEL.
;

	$ASSIGN_S DEVNAM=W^HLD$GQ_LNKNAM- ; "NET0:" REFERS TO NETACP
		CHAN=W^HLD$GW_LNKCHN	; STORE CHANNEL #
	CHECK_SS			; CHECK STATUS CODE

;
; TRANSLATE THE LOGICAL NAME 'SYS$NET'. ITS EQUIVALENCE STRING IS
; SET-UP BY NETACP TO BE THE ENTIRE NETWORK CONNECT BLOCK (NCB) WHICH
; IS REQUIRED TO GAIN NON-TRANSPARENT ACCESS TO THE NETWORK.
;

	MOVAQ	W^HLD$GQ_NCBDESC,R7	; GET ADDRESS OF NCB DESCRIPTOR
	MOVZBL	#64,(R7)		; STORE BUFFER SIZE
	MOVAB	W^HLD$GT_NCBBUF,4(R7)	; STORE BUFFER ADDRESS
	$TRNLOG_S LOGNAM=W^HLD$GQ_SYSNAM- ; ADDRESS OF LOGICAL NAME DESCRIPTOR
		RSLLEN=(R7)-		; UPDATE SIZE IN NCB DESCRIPTOR
		RSLBUF=(R7)		; PUT EQUIVALENCE STRING IN NCB
	CHECK_SS			; CHECK STATUS CODE

;++
; THE GENERAL FORMAT OF THE EQUIVALENCE STRING DERIVED FROM SYS$NET IS:
;
;	nodespec::"objecttype=taskid/netacp_string"
;	userdata (before close ") consists of:
;		4 bytes of rad50 task name
;		1 word of partition address (0=>mapped)
;		1 word of partition size (in bytes or 32.-word blocks)
;		1 byte of lun (general purpose) flag - 0=no,1=>lun fixing
;		1 byte of function code (-1=overlay,0=read, 1=chkread, 2=chkwrt)
;		2 words of VBN if overlay request

; On return, the optional data consists of:
;		1 word of transfer size
;		1 byte of no. of luns to fix
;
; THE FOLLOWING WILL BE OUTPUT TO THE PRINT FILE:
;
;	nodespec::"objecttype=taskid"
;
; THE FOLLOWING WILL BE PUT INTO THE NCB FOR A CONNECT ACCEPT
;
;	nodespec::"objecttype=taskid/next_two_bytes"
; userdata consists of actual transfer size in place of partition size
;--

	LOCC	#^A\:\,(R7),@4(R7)	; FIND NODE DELIMITER
	BEQL	20$			; IF EQL NOT FOUND
	SUBW3	R0,(R7),W^HLD$GQ_NODEDESC ; STORE NAME LENGTH
	MOVL	R7,W^HLD$GL_IOPARAM2	; ADDRESS OF NCB DESCRIPTOR
	LOCC	#^A\/\,R0,(R1)		; FIND TASKID DELIMITER
	BNEQ	30$			; BRANCH IF SLASH FOUND
20$:
	MOVZWL	#SS$_IVDEVNAM,R0	; MAKE THIS THE EXIT ERROR STATUS
	BRB	HLD$EXIT_TO_VMS		; FATAL ERROR!!
;
; RESPOND TO THE CONNECT INITIATE WITH A CONNECT CONFIRM (WITHOUT USERDATA)
; TO COMPLETE THE LOGICAL LINK.
;

30$:
	ADDL	#3,R1			; SKIP "/" AND 2 RESERVED BYTES
;
; NOW VERIFY THE CONNECT AND CHECK THE DATA FILE
;
	BSBW	HLD$GET_FILE		; SCAN HLD.DAT
	BSBW	HLD$OPEN_TSKFIL		; OPEN AND PROCESS THE TASK FILE
;
;	CONFIRM THE LOGICAL LINK
;
	BSBW	HLD$NET_IO		; CONFIRM THE LINK
;
; Now fix it so that HLD waits for disconnect if transfer is to host.
;
	$SETEF_S	EFN=#2		; Set event flag as default
	CMPW	W^HLD$GW_SAVEFUNC,S^#IO$_READVBLK ; Am I reading?
	BNEQ	40$			; If NEQ no
;
; Issue a phony QIO which will terminate when the link is broken
;
	$QIO_S	-			; ISSUE THE REQUEST
		CHAN=	W^HLD$GW_LNKCHN- ;
		FUNC=	S^#IO$_WRITEVBLK -; Do a write
		EFN=	#2-		;
		P1=	.-
		P2=	#0
40$:
;
; NOW DO THE ACTUAL TASK TRANSFER
;
	MOVAB	W^HLD$AB_BUFFER,W^HLD$GL_IOPARAM1 ; SET BUFFER ADDRESS
	MOVW	W^HLD$GW_SAVEFUNC,W^HLD$GW_IOFUNC ; SET UP TRANSFER FUNCTION
	BSBB	DO_IO			; DO THE TRANSFER
	MOVQ	R6,R8			; SET UP FOR LUN BLOCK TRANSFER
	MOVL	#2,W^HLD$GL_TSKBKT	; Set up VBN of LUN block(s)
	BSBB	DO_IO			; SEND THEM, MAYBE
;
; Now wait, if necessary
;
	$WAITFR_S	EFN=#2
	CLRL	R0			; Force "SYSTEM NORMAL" to the log file

HLD$EXIT_TO_VMS::			;
	PUSHL	R0			; SAVE EXIT STATUS CODE
	BSBW	HLD$PRINT		; PRINT RESULTS
	$EXIT_S	(SP)+			; EXIT TO VMS
.PAGE
;++
;
; DO_IO - CALL I/O ROUTINES TO DO REAL TRANSFER WORK
;
; INPUTS:
;	R8 - NO. OF INTEGRAL BLOCKS TO TRANSFER
;	R9 - SIZE IN BYTES OF BLOCK AFTER LAST INTEGRAL BLOCK OR 0
;
;--

DO_IO:
	MOVZWL	W^HLD$GW_IOLEN,W^HLD$GL_IOPARAM2 ; LENGTH OF ALL BUT LAST TRANSFER
	BRB	50$			; CHECK THE "NO FULL BLOCK" CASE
40$:
	BSBB	55$			; CALL THE I/O ROUTINES
50$:	SOBGEQ	R8,40$			; LOOP


	MOVW	R9,W^HLD$GL_IOPARAM2	; SIZE OF LAST TRANSFER
	BEQL	60$			; IF EQL NOTHING
55$:
	JSB	@W^HLD$GL_IOROUT_1	; DO 1ST KIND OF I/O
	JSB	@W^HLD$GL_IOROUT_2	; DO 2ND KIND OF I/O
	INCL	W^HLD$GL_TSKBKT		; ADVANCE THE BLOCK NO.
60$:
	RSB				; DONE

	.END	HLD$START
