	.TITLE	HLDFILE - HLD FILE I/O
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: DECNET HOST LOADER (HLD)
;
; ABSTRACT:
;
;	HLD IS A COMPONENT OF DECNET/VAX-11. IT PROVIDES ACCESS TO
;	RSX11S TASK IMAGES STORED ON A VAX SYSTEM.
;
; ENVIRONMENT:
;
;	THE HLD IMAGE EXECUTES IN THE CONTEXT OF A PROCESS CREATED BY
;	NETACP. IT RUNS IN USER MODE AND REQUIRES NETWORK PRIVILEGE.
;
; AUTHOR: SCOTT G. DAVIS,	CREATION DATE: 23-MAY-79
;
; MODIFICATIONS:
;
;--
;
; INCLUDE FILES
;
	$HLDDEF
;
; MACROS:
;
;	NONE
	.PAGE
;
; LOCAL DATA
;
	.PSECT	HLD$PURE	NOSHR,NOEXE,RD,NOWRT,LONG

FIRST_RECORD:	.ASCID	/HLDTB$/	; THIS SHOULD MATCH THE 1ST REC IN HLD.DAT
TASK_FLAG:	.ASCID	/HTASK$/	; FOR TASK ENTRIES
NODE_FLAG:	.ASCID	/HNODE$/	; FOR NODE ENTRIES
END_FLAG:	.ASCID	/.END/		; FOR END-OF-FILE
MAP_STRING:	.ASCID	/MAP/		; FOR TASK TYPE MATCH
UNM_STRING:	.ASCID	/UNM/		; DITTO
LUN_STRING:	.ASCID	/LUN/		; DITTO
	.PAGE
	.PSECT	HLD$CODE	NOSHR,EXE,RD,NOWRT

;++
; FUNCTIONAL DESCRIPTION:
;
; HLD$GET_FILE OPENS SYS$SYSTEM:HLD.DAT AND SCANS IT FOR THE
; REQUIRED TASK.
;
; INPUTS:
;
;	R1 - POINTS TO OPTIONAL DATA FIELD
;
; OUTPUTS:
;
;	R11 - POINTS TO OPTDATA FIELD AFTER TASK NAME
;	HLD$GW_SAVEFUNC - SAVES I/O FUNCTION FOR TRANSFER
;
;--

	.ENABLE	LOCAL_BLOCK

HLD$GET_FILE::				; ENTRY POINT
;
; VALIDATE THE CONNECT PARAMETERS
;
	MOVB	(R1),R6			; Get no. of bytes of userdata
	MOVB	#3,(R1)+		; 3 bytes going back
	PUSHL	R1			; Save base of OPTDATA
	BSBW	HLD$C5TA		; DECODE THE TASK NAME
	POPL	R11			; Restore base of OPTDATA
	MOVAB	W^HLD$GT_INVALID,W^HLD$GT_OPER ; ASSUME INVALID REQUEST
	CMPB	B^HLD$B_LUN_FLAG(R11),#1 ; FIELD IN RANGE?
	BGTRU	90$			; IF GTRU NO
	MOVZBL	B^HLD$B_REQUEST(R11),R2	; GET THE REQUEST
	CMPB	R6,#14			; RIGHT AMOUNT OF USERDATA?
	BNEQ	90$			; IF NEQ NO - INVALID CONNECT
	INCB	R2			; NORMALIZE
	BEQL	5$			; IF EQL OVERLAY REQUEST
	CMPB	R2,#3			; FIELD IN RANGE (-1 TO +2)?
	BGTRU	90$			; IF GTRU NO
	BNEQ	5$			; IF NEQ NOT CHECKPOINT WRITE
	MOVAB	W^HLD$NET_IO,W^HLD$GL_IOROUT_1 ; FIRST, GET NET DATA
	MOVAB	W^HLD$DISK_WRITE,W^HLD$GL_IOROUT_2 ; THEN DO DISK OPERATION
	MOVW	S^#IO$_READVBLK,W^HLD$GW_SAVEFUNC ; NETWORK DOES READ
5$:
	MOVL	W^HLD$AT_REQ_TYPE[R2],W^HLD$GT_OPER ; SAVE PTR TO NAME OF REQUEST
;
; NOW OPEN HLD.DAT AND SCAN IT FOR WHAT IS NEEDED
;
	MOVAB	W^HLD$DATFAB,R0		; SET TO OPEN FILE
	BSBW	HLD$RMS_OPEN		; DO IT
	MOVAB	W^HLD$DATRAB,R0		; SET TO CONNECT record STREAM
	BSBW	HLD$RMS_CONNECT		; DO IT
;
; PROCESS THE RECORDS
;
	BSBW	GET_RECORD		; GET THE FIRST RECORD
	MOVAB	W^FIRST_RECORD,R8	; SET TO MATCH
	BSBW	MATCH_STRING		; IS STRING RIGHT?
	BLBC	R0,105$			; IF LBC NO
;
; SCAN FOR GENERAL PURPOSE TASKS
;
TRY_NEXT_TASK:
	BSBW	FIND_TASK		; HAVE A RECORD WITH "HTASK$"?
	BLBC	R0,100$			; IF LBC NO - SCAN FOR NODE NAMES
;
; LOOK AT THE GENERAL PURPOSE TASKS FOR A POSSIBLE MATCH
;
	BSBW	MATCH_TASK		; TRY TO MATCH THE TASK NAME
	BLBC	R0,TRY_NEXT_TASK	; IF LBC NOT FOUND - LOOP
	TSTB	B^HLD$B_LUN_FLAG(R11)	; CAN SLD HANDLE GENERAL-PURPOSE TASKS?
	BEQL	100$			; If EQL no - try for named nodes
	INCB	W^HLD$GB_LUNFLAG	; General purpose tasks require lun-fixing
	CMPB	B^HLD$B_REQUEST(R11),#2	; Is this a checkpoint operation?
	BLSSU	OPEN_TASK		; If LSSU no - proceed
90$:
;
; ILLEGAL CONNECT REQUESTED
;
	BRW	EXIT_TO_VMS		; GO TO COMMON CODE
;
; SCAN FOR NODE NAME MATCH
;
100$:
	CLRB	W^HLD$GB_GPFLAG		; This is not a general purpose task
	BSBW	RESCAN_RECORD		; START AGAIN
	BSBW	FIND_NODE		; FIND "HNODE$"
	BLBS	R0,110$			; IF LBS OK
105$:	BRW	FORMAT_ERROR		; FILE FORMAT ERROR
110$:
	BSBW	NEXT_FIELD		; GET TO THE NAME
	MOVAB	W^HLD$GQ_NODEDESC,R8	; POINT TO NODE DESCRIPTOR
	BSBW	MATCH_STRING		; SEE IF THERE IS A MATCH
	BLBS	R0,150$			; TRY FOR TASK NAME
120$:
	BSBW	GET_RECORD		; READ NEXT HLD.DAT RECORD
	BSBW	FIND_NODE		; SEARCH FOR A HNODE$ RECORD
	BLBS	R0,110$			; IF LBS FOUND
	BSBW	RESCAN_RECORD		; START AGAIN
	MOVAB	W^END_FLAG,R8		; SEE IF AT END OF FILE
	BSBW	MATCH_STRING		; MATCH WITH ".END"
	BLBS	R0,160$			; IF LBS MATCH - COULDN'T FIND MATCH
	BRB	120$			; TRY FOR HNODE$
;
; NODE FOUND - TRY FOR TASK MATCH
;
150$:
	BSBW	FIND_TASK		; LOOK FOR "HTASK$"
	BLBS	R0,170$			; IF LBS PROCEED
160$:	BRW	SEARCH_FAILURE		; COULDN'T FIND WHAT I WANTED
170$:
	BSBW	MATCH_TASK		; IS THIS THE RIGHT TASK?
	BLBC	R0,150$			; IF LBC NO - TRY FOR ANOTHER

	.DISABLE	LOCAL_BLOCK

;
; TASK FOUND - GET READY TO OPEN UP THE FILE
;
OPEN_TASK:
	INCL	R1			; MOVE PAST COMMA
	BSBW	NEXT_FIELD		; DO IT
	CMPB	(R1)+,#^A/</		; IS THIS THE RIGHT DELIMITER
	BNEQ	20$			; IF NEQ ERROR
	MOVL	R1,W^HLD$GL_TSKFNA	; PRESERVE PTR TO FILESPEC
	LOCC	#^A?>?,#63,(R1)		; FIND THE TERMINATOR
	BEQL	SYNTAX_ERROR		; IF EQL NOT FOUND
	SUBB3	R0,#63,W^HLD$GB_TSKFNS	; GET LTH OF FILESPEC
	INCL	R1			; MOVE PAST ">"
	BSBW	NEXT_FIELD		; FIND NEXT FIELD
	TSTW	R0			; WAS THE RECORD EATEN?
	BEQL	DONE			; If EQL yes
	CMPB	(R1)+,#^A","		; NEXT DELIMITER OK?
20$:	BNEQ	SYNTAX_ERROR		; IF NEQ NO
	BSBW	NEXT_FIELD		; MOVE TO NEXT FIELD
	MOVAB	W^MAP_STRING,R8		; SET TO FIND FILE TYPE
	PUSHL	R1			; SAVE THE POINTER FOR A LIMITED RESCAN
	BSBW	MATCH_STRING		; TRY MATCH
	BLBS	R0,35$			; IF LBS "MAP"
	MOVL	(SP),R1			; RESTORE PTR
	MOVAB	W^UNM_STRING,R8		; TRY "UNM"
	BSBW	MATCH_STRING		; DO IT
	BLBC	R0,80$			; If LBC not "UNM"
	INCB	W^HLD$GB_MAPFLAG	; SET "UNM"
35$:
	TSTB	W^HLD$GB_GPFLAG		; Is this a general-purpose task?
	BEQL	FORMAT_ERROR		; If EQL no - can't mix types
	TSTB	W^HLD$GB_MAPFLAG	; Mapped task?
	BEQL	60$			; If EQL yes
	TSTW	B^HLD$W_PART_ADDR(R11)	; Mapped task requested?
	BEQL	70$			; If EQL yes, but this ain't it
	BRB	100$			; Finish in common code
60$:
	TSTW	B^HLD$W_PART_ADDR(R11)	; Mapped task requested?
	BEQL	100$			; If EQL yes - proceed
70$:
	TSTL	(SP)+			; Clean up the stack
	BRW	TRY_NEXT_TASK		; Keep looking for task
80$:
	MOVL	(SP),R1			; RESTORE PTR
	MOVAB	W^LUN_STRING,R8		; TRY "LUN"
	BSBW	MATCH_STRING		; MATCH?
	BLBC	R0,SYNTAX_ERROR		; IF LBC NO
	INCB	W^HLD$GB_LUNFLAG	; SET "LUN"
100$:
	TSTL	(SP)+			; CLEAN UP STACK

DONE:
	$CLOSE	FAB=W^HLD$DATFAB	; CLOSE THE DATA FILE
	RSB				; DONE

FORMAT_ERROR:
	MOVL	#HLD$C_ERR_FORMT,R6	; FORMAT ERROR
	BRB	COMMON_EXIT		; GO TO COMMON EXIT

SYNTAX_ERROR:
	MOVL	#HLD$C_ERR_SYNTX,R6	; SYNTAX ERROR
	BRB	COMMON_EXIT		; GO TO COMMON CODE
SEARCH_FAILURE:
	MOVL	#HLD$C_ERR_SERCH,R6	; FILE NOT FOUND
COMMON_EXIT:
	MOVB	R6,W^HLD$GB_ERRORFLG	; SAVE THE ERROR CODE
EXIT_TO_VMS:
	MOVL	S^#SS$_NORMAL,R0	; No more messages in LOG
	BRW	HLD$EXIT_TO_VMS
.PAGE
;++
;
;	GET_RECORD - THIS ROUTINE GETS A RECORD FROM THE OPEN FILE AND RETURNS
; THE LENGTH AND ADDRESS OF THE RECORD.
;
;	RESCAN_RECORD - THIS ROUTINE RESETS TO THE BEGINNING OF THE
; CURRENT RECORD.
;
; NEXT_FIELD - THIS ROUTINE IGNORES BLANKS AND TABS
;
; INPUTS:
;
;	HLD$DATRAB (GET_RECORD, RESCAN_RECORD)
;	R0,R1 - DESCRIPTOR OF REMAINDER OF RECORD (NEXT_FIELD)
;
; OUTPUTS:
;
;	R0 - REMAINING CHARACTERS IN RECORD
;	R1 - POINTER TO FIRST NON-BLANK, NON-TAB CHARACTER IN RECORD
;
;--

GET_RECORD:
	$GET	RAB=W^HLD$DATRAB	; GET THE FIRST RECORD
	CHECK_RMS			; SEE IF OK
	TSTL	R1			; END-OF-FILE?
	BEQL	FORMAT_ERROR		; IF EQL YES - JUST GO AWAY

RESCAN_RECORD:
	MOVZWL	W^HLD$GW_DATRSZ,R0	; SET UP RECORD LENGTH
	MOVL	W^HLD$GL_DATRBF,R1	; SET UP RECORD POINTER
	ADDL3	R0,R1,W^HLD$GL_RECEND	; POINT TO END OF RECORD
					; FALL THROUGH TO FIND 1ST 
					; INTERESTING CHARACTER
NEXT_FIELD:
	SUBL3	R1,W^HLD$GL_RECEND,R0	; COMPUTE CHARS LEFT IN RECORD
10$:
	CMPB	(R1),#^X20		; BLANK?
	BEQL	15$			; IF EQL YES
	CMPB	(R1),#^X9		; TAB?
	BNEQ	20$			; IF NEQ NO - DONE
15$:
	INCL	R1			; MOVE THE POINTER
	DECL	R0			; ANOTHER CHARACTER EATEN
	BNEQ	10$			; IF NEQ MORE CHARS IN RECORD
20$:
	RSB				; DONE
	.PAGE
;++
;
; FIND_TASK - FIND A RECORD WITH A TASK DESCRIPTOR IN IT (HTASK$)
;
; OUTPUTS:
;	R0 - LBS=>SUCCESS, LBC=>FAILURE
;
;--

FIND_TASK:
	BSBB	GET_RECORD		; FETCH A RECORD
	MOVAB	W^TASK_FLAG,R8		; SET TO MATCH "HTASK$"
					; FALL THROUGH TO TRY FOR MATCH AND RETURN

;++
;
; MATCH_STRING - MATCH A STRING EXACTLY
;
; INPUTS:
;	R1 - POINTER TO ONE STRING
;	R8 - ADDRESS OF DESCRIPTOR OF STRING TO MATCH
;	HLD$GL_RECEND - FOR COMPUTING MAX NO. OF CHARS THAT CAN BE LEFT
;
; OUTPUTS:
;	R0 - LBS=>SUCCESS, LBC=>FAILURE
;
;--

MATCH_STRING:
	SUBL3	R1,W^HLD$GL_RECEND,R0	; COMPUTE MAX NO. OF CHARS LEFT
	CMPW	R0,(R8)			; ENOUGH TO MATCH?
	BLSSU	100$			; IF LSSU NO
	CMPC3	(R8),(R1),@4(R8)	; MATCH?
	BNEQ	100$			; IF NEQ NO
	INCL	R0			; SUCCESS
	RSB				; DONE
100$:
	CLRL	R0			; FAILURE
	RSB				; DONE


;++
;
; FIND_NODE - FIND A RECORD WITH A NODE DESCRIPTOR IN IT (HNODE$)
;
; OUTPUTS:
;	R0 - LBS=>SUCCESS, LBC=>FAILURE
;
;--

FIND_NODE:
	MOVAB	W^NODE_FLAG,R8		; SET TO MATCH "HNODE$"
	BRB	MATCH_STRING		; TRY FOR MATCH AND RETURN
	
;++
;
; MATCH_TASK - THIS ROUTINE MATCHES THE REQUESTED NAME WITH ONE IN THE FILE
;
; OUTPUTS:
;	R0 - LBS=>SUCCESS, LBC=>FAILURE
;
;--

MATCH_TASK:
	BSBB	NEXT_FIELD		; FIND START OF TASK NAME
	PUSHL	R1			; SAVE POINTER
	LOCC	#^A/,/,#7,(R1)		; FIND THE DELIMITER
	POPR	#^M<R1>			; RESTORE POINTER
	BNEQ	10$			; IF NEQ FOUND
	BRW	SYNTAX_ERROR		; SYNTAX ERROR
10$:
	SUBW3	R0,#7,R0		; COMPUTE LENGTH OF NAME IN RECORD
	CMPW	R0,#6			; TOO BIG?
	BGTRU	100$			; IF GTRU YES
	CMPC5	#6,W^HLD$AT_TSKBUF+1,#^X20,R0,(R1) ; TRY TO MATCH TASK NAME
	BNEQ	100$			; IF NEQ FAILED
	INCL	R0			; INDICATE SUCCESS
	MOVL	R3,R1			; RESTORE POINTER
	RSB				; DONE
100$:
	CLRL	R0			; INDICATE FAILURE
	RSB				; RETURN

	.END
