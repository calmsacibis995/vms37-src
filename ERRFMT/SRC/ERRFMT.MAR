	.TITLE	ERRFMT 
	.IDENT	'V03-003'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:  ERROR LOG FORMAT PROGRAM
;
; ABSTRACT:  THIS PROGRAM EMPTIES THE ERROR LOG BUFFERS AND CREATES
;		A FILE, ERRLOG.SYS, IN A FORMAT ACCEPTABLE TO SYE.

;
;
; ENVIRONMENT:
;
; AUTHOR:  KATHLEEN D. MORSE,		CREATION DATE:  29-JUN-1977
;
; MODIFIED BY:
;
;	V03-003	ROW0080		Ralph O. Weber		08-APR-1982
;		Move DEVFAO control string so that it is not in the middle 
;		of the "ERROR ACCESSING ERROR LOG FILE" message text.
;
;	V03-002	STJ0251		Steven T. Jeffreys	01-Apr-1982
;		Do not send mount/dismount notification messages to
;		OPCOM depending on the appropriate sysgen parameter.
;
;	V03-001	STJ0228		Steven T. Jeffreys	19-Mar-1982
;		Use full device name when calling $GETDVI.
;
;	V02-012	LMP0014		L. Mark Pilant,		16-Mar-1982  11:15
;		Fix a problem with the setting of the desired operator
;		bits.  Also, fix a problem with using EFN 0 with GETDVI.
;
;	V02-011	LMP0007		L. Mark Pilant		13-Jan-1982   9:55
;		Notify the appropriate operators when volume mount and
;		dismount messages area seen.
;
;	V02-010	SPF0045		Steve Forgey		28-Dec-1981
;		Synchronize buffer copy with allocation interlock flag.
;
;	V02-009	PHL0013		Peter H. Lipman		21-Aug-1981
;		Change the output file specification for the error log file
;		to use the new system wide logical name SYS$ERRORLOG whic
;		is the [SYSERR] directory on the system disk.
;
;	V02-008	TCM0003		Trudy C. Matthews	6-Aug-1981
;		Change message sent to oerator's terminal when ERRFMT
;		deletes itself.
;
;	V02-007	KDM0059		Kathleen D. Morse	22-Jul-1981
;		Fix new file error log message.
;
;	V02-006	KDM0057		Kathleen D. Morse	15-Jul-1981
;		Add SID to error log buffer message format and make the
;		header fields be negative offsets from the message text.
;
;	V02-005	TCM0002		Trudy C. Matthews	13-Jul-1981
;		Document use of @SYS$SYSTEM:STARTUP ERRFMT instead of
;		@SYS$MANAGER:ERFSTART to re-start ERRFMT process after it
;		deletes itself.
;
;
;	V02-004	STJ0024		Steven T. Jeffreys	01-Feb-1981
;		Fixed bugs in mailbox write logic.
;
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$DCDEF				; DEFICE DEVICE CLASS TYPES
	$DIBDEF				; DEVICE INFORMATION BUFFER
	$DVIDEF				; $GETDVI MESSAGE CODES
	$EMBETDEF			; ERROR MESSAGE ENTRY TYPES
	$EMBDEF				; DEFINE ERROR MESSAGE BUFFER HEADER
	$EMBTSDEF			; DEFINE TIME STAMP DEFINTIONS
	$ERFHDDEF			; ERROR FORMAT HEADER DEFINITIONS
	$ERFTSDEF			; ERROR FORMAT TIME STAMP DEFINTIONS
	$ERFVMDEF			; ERROR FORMAT VOLUME MOUNT DEFINITIONS
	$ERLDEF				; SYSTEM ERROR LOGING DEFINTIONS
	$OPCDEF				; OPERATOR MESSAGE DEFINITIONS
	$PCBDEF				; PROCESS CONTROL BLOCK DEFINITIONS

ERM$C_FORMAT = 2			; FORMAT NUMBER FOR VAX
ERF$C_LOOP_CNT = 255			; TIMES TO WAIT FOR BUFFER
ERF$K_DLTA_STMP = <60*10>		; TIME STAMP DELTA IN SECS
ERF$K_CLK_TICK = -<10*1000*1000>	; CONVERSION TO CLOCK TICKS/SEC

;
; OWN STORAGE:
;

	.PSECT	DATA,RD,WRT,NOEXE,PAGE

INBUF:	.BLKB	512			; INPUT BUFFER
OUTFAB:	$FAB	-			; RECORD ACCESS BLOCK
		FAC=<PUT,UPD>,-		; PUT AND UPDATE FILE ACCESS
		FNA=OUTNAM,-		; FILE NAME ADDRESS
		FNS=OUTNAMSZ,-		; LENGTH OF FILE NAME
		ORG=SEQ,-		; SEQUENTIAL ORGANIZATION
		MRS=0			; MAX RECORD SIZE UNSPECIFIED

OUTRAB:	$RAB	-			; RECORD ACCESS BLOCK
		ROP=EOF,-		; OPEN TO END OF FILE
		FAB=OUTFAB		; FILE ACCESS BLOCK ADDR

LASTENTRY:	.BYTE 0			; ENTRY TYPE OF LAST RECORD WRITTEN
SID:		.LONG	0		; SYSTEM ID #
ERF$W_MBXCHN:	.WORD	0		; DIAGNOSTIC MAILBOX CHANNEL
ERF$W_MBXSIZ:	.WORD	0		; DIAGNOSTIC MAILBOX SIZE
ERF$W_MBXUNT:	.WORD	0		; PREVIOUS DIAG MBX UNIT #

DEVFAO:	.ASCID	/_!AC!UW:/		; $FAO control string to format device

;
; MESSAGE SENT TO OPERATOR UPON FAILURE TO WRITE TO ERROR LOG FILE.
;
OPRMSG_DSC:
OPRMSG_LEN:
	.LONG	OPRMSG_END-OPRMSG	; SIZE OF OPERATOR MESSAGE BUFFER
	.LONG	OPRMSG			; ADDRESS OF OPERATOR MESSAGE BUFFER
R0MSG_DSC:
	.LONG	R0MSG_END-R0MSG
	.LONG	R0MSG
OPRMSG:
	.LONG	OPC$_RQ_RQST!-		; TYPE OF MESSAGE
		<<OPC$M_NM_CENTRL@8>>	; OPERATOR TO INFORM
	.LONG	0			; NOBODY TO RESPOND TO
	.ASCII	/ERRFMT - ERROR ACCESSING ERROR LOG FILE/<13><10>
OPRMSG_END:

R0MSG:
	.BLKB	256			; HOLDS TRANSLATED STATUS MESSAGE.
R0MSG_END:
R0MSG_LEN:				; HOLDS TRANSLATED MESSAGE LENGTH.
	.LONG	0
;
; MESSAGE SENT TO OPERATOR WHEN WE'VE FAILED TOO MANY TIMES TO WRITE
; TO ERROR LOG FILE.
;
BYEMSG_DSC:				; MESSAGE DESCRIPTOR
BYEMSG_LEN:
	.LONG	BYEMSG_END-BYEMSG	; LENGTH
	.LONG	BYEMSG			; ADDRESS

BYEMSG:					; MESSAGE
	.LONG	OPC$_RQ_RQST! -		; TYPE OF MESSAGE
		<<OPC$M_NM_CENTRL@8>>	; OPERATOR TO INFORM
	.LONG	0			; NOBODY TO RESPOND TO
	.ASCII	/ERRFMT - DELETING ERRFMT PROCESS/<13><10>
	.ASCII	/ERROR LOG FILE UNWRITABLE/<13><10>
	.ASCII	/TO RESTART ERRFMT PROCESS, USE "@SYS$SYSTEM:STARTUP ERRFMT"/
BYEMSG_END:
;
; MOUNT AND DISMOUNT MESSAGE STRINGS
;
MOUNT_FAO:
	.LONG	MOUNT_END-MOUNT_MSG	; LENGTH OF CONTROL STRING
	.ADDRESS	MOUNT_MSG	; ADDRESS OF CONTROL STRING
MOUNT_MSG:
	.LONG	OPC$_RQ_RQST		; TYPE OF MESSAGE (OPERATOR T.B.S.)
	.LONG	0			; NOBODY TO REPLY TO
	.ASCII	\Volume "!AD"!ASmounted, on physical device !AS\
MOUNT_END:

MOUNT_DSC:
	.LONG	128			; MAX SIZE OF THE MESSAGE
	.ADDRESS	MOUNT_BUF	; ADDRESS OF THE MESSAGE BUFFER
MOUNT_BUF:
	.BLKB	128			; STORAGE FOR FORMATTED MESSAGE
MOUNT_MNT:
	.ASCID	\ \			; FOR VOLUME MOUNTED MESSAGE
MOUNT_DMT:
	.ASCID	\ dis\			; FOR VOLUME DISMOUNTED MESSAGE
;
; ERROR COUNTERS
;
ERF$B_ERRCNT:				; COUNT ERRORS IN WRITING TO
	.BYTE	0			; ERRORLOG FILE
ERF$B_MAXERRCNT:			; MAXIMUM # ERRORS BEFORE DELETING
	.BYTE	20			; THIS PROCESS
 
;
; PURE DATA - KEPT IN CODE PSECT FOR LOCALITY
;
 
	.PSECT	CODE,RD,NOWRT,EXE
 
;
; ARGUMENT LIST FOR FILE CREATE TIME STAMP ENTRY
;
FILCRE:		.LONG	1		; ONE ARGUMENT
		.LONG	EMB$K_NF	; NEW FILE TYPE MESSAGE
 
ERF$Q_DELTA:				; TIME BETWEEM TIME MARKS
 
; ***	.LONG	ERF$K_CLK_TICK*ERF$K_DLTA_STMP&^X0FFFFFFFF
 
		.LONG	^X09A5F4400	; LOW 1/2 OF DELTA TIME
 
; ***	.LONG	ERF$K_CLK_TICK*ERF$K_DLTA_STMP@-32
 
		.LONG	^X0FFFFFFFE	; HIGH 1/2 OF DELTA TIME
 
ERF$Q_WAIT:	.LONG	-<10*1000*500>	; # OF 10 MILLISEC INTERVALS
		.LONG	-1		; TO WAIT FOR BUFFER COMPLETION
OUTNAM:	.ASCII	\SYS$ERRORLOG:ERRLOG.SYS\ ; OUTPUT FILE NAME
OUTNAMSZ = . - OUTNAM			; LENGTH OF OUTPUT NAME

	.SBTTL	ERRFMT 
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS PROGRAM IS AWAKENED FROM HIBERNATION BY THE ERROR LOGGER
;	WHENEVER AN ERROR LOG BUFFER BECOMES FULL.  THE ERROR FORMAT
;	PROGRAM READS THE FULL BUFFER AND THEN RELEASES IT FOR RE-USE BY
;	THE ERROR LOGGER PROGRAM.  THE DATA JUST READ IS RE-ORGANIZED
;	AND WRITTEN TO A FILE CALLED "ERRLOG.SYS" IN A FORMAT ACCEPTABLE
;	TO SYE.
;
;	THE ERROR FORMAT PROGRAM ALSO PLACES TIME STAMP ENTRIES INTO THE
;	ERROR LOG BUFFER.  THESE TIME STAMPS ARE PLACED INTO THE BUFFER
;	AT REGULAR INTERVALS.  HOWEVER, SEQUENTIAL TIME STAMPS ARE NOT
;	WRITTEN INTO THE FILE, "ERRLOG.SYS".
;
;	THE FILE, "ERRLOG.SYS", IS UPDATED, OR A NEW VERSION CREATED IF
;	THE MOST RECENT VERSION IS BEING ACCESSED OR DOES NOT EXIST.
;
;--

	.PSECT	CODE,RD,NOWRT,EXE
	.ENABL	LSB
	.ENTRY	ERF$START,0		;
	$CMKRNL_S	W^ERF$INIT	; INITIALIZE THE ERR FORMATER
PRCBUF: $CMKRNL_S	W^ERF$GETBUF	; GET THE FULL ERROR LOG BUFFER
	BLBS	R0,PRCNXT		; BR IF MESSAGE(S) TO PROCESS
	$CLOSE	FAB=W^OUTFAB		; CLOSE THE OUTPUT
	$HIBER_S			; WAIT FOR SOMETHING TO DO
	BRB	PRCBUF			;
;
; PROCESS NEXT MESSAGE - COME HERE WHEN A BUFFER HAS BEEN COPIED FROM
; THE SYSTEM INTO THE LOCAL BUFFER.  IF THE FILE IS NOT OPEN,
; OPEN THE OUTPUT FILE OR CREATE ONE IF MOST RECENT IS BEING ACCESSED.
;
PRCNXT:	CLRL	R3			; R3=0 => OPEN EXISTING FILE
					; R3~=0 => CREATE NEW ERRLOG FILE
PRCNXT1:
	MOVAB	W^INBUF,R8		; GET ADDR OF FIRST MSG
	ADDB3	ERL$B_BUSY(R8),ERL$B_MSGCNT(R8),R6 ; GET COUNT OF MESSAGES
	BEQL	PRCBUF			; BR IF NO MESSAGES TO PROCESS
	ADDL	#ERL$C_LENGTH,R8	; POINT TO START OF MESSAGES
	MOVAB	W^OUTFAB,R2		; SET ADDRESS OF FAB
	TSTW	FAB$W_IFI(R2)		; IS THE FILE OPEN?
	BNEQ	NXTMSG			; BR IF ALREADY OPEN
	CLRL	FAB$L_ALQ(R2)		; CLEAR ALLOCATION 
	TSTL	R3			; OPEN OR CREATE ERRLOG.SYS?
	BNEQ	5$			; BR TO CREATE NEW FILE
	$OPEN	FAB=(R2)		; OPEN MOST RECENT VERSION
	BLBS	R0,10$			; BRANCH ON SUCCESS
	INCL	R3			; SIGNAL CREATING NEW FILE
5$:
	$CREATE	FAB=(R2)		; CREATE NEW VERSION
	BLBS	R0,10$			; BRANCH ON SUCCESS
	BRW	WRITE_FAILURE		; NOTIFY OPERATOR OF CREATE FAILURE
10$:	MOVAB	W^OUTRAB,R9		; SET ADDRESS OF OUTPUT RAB
	CLRW	RAB$W_ISI(R9)		; PERFORM A FAST DISCONNECT
	$CONNECT RAB=(R9)		; CONNECT RAB TO FAB
	BLBS	R0,12$			; BRANCH ON SUCCESS
	BRW	WRITE_FAILURE		; ELSE BRANCH ON FAILURE
12$:
	TSTL	R3			; WAS A NEW FILE JUST CREATED?
	BEQL	NXTMSG			; BR IF NOT NEW FILE
	CLRL	R3			; SIGNAL SUCCESSFUL FILE CREATION
					; AND INITIALIZATION
	SUBL	#EMB$K_HD_LENGTH,SP	; ALLOCATE A BUFFER (ONLY HEADER INFO)
	MOVL	SP,R2			; COPY ADDRESS OF BUFFER
	MOVL	R2,RAB$L_RBF(R9)	; SET BUFFER ADDRESS IN RAB
	MOVW	#EMB$K_HD_LENGTH,RAB$W_RSZ(R9) ; AND SET LENGTH FOR $PUT
	MOVL	W^SID,EMB$L_HD_SID(R2)	; SET SYSTEM IDENT
	MOVW	#EMB$K_NF,EMB$W_HD_ENTRY(R2) ; SET ENTRY TYPE
	MOVQ	EMB$Q_HD_TIME+EMB$K_LENGTH(R8),- ; COPY TIME AND DATE FROM
		EMB$Q_HD_TIME(R2)	; FIRST ENTRY IN THE ERROR LOG BUFFER
	CLRW	EMB$W_HD_ERRSEQ(R2)	; SET ERROR SEQUENCE NUMBER OF ZERO
	$PUT	RAB=(R9)		; WRITE FILE CREATED MARK
	BLBS	R0,15$			; BR IF SUCCESSFUL
	BRW	WRITE_FAILURE		; ELSE BRANCH ON FAILURE
15$:
	ADDL	#ERF$K_TS_LENGTH,SP	; CLEAR THE STACK
;
; PROCESS A MESSAGE IN THE ERROR BUFFER.
;
;	R6 = NUMBER OF MESSAGES IN THE BUFFER
;	R7 = IS USED TO HOLD THE FORMATTED RECORD
;	R8 = THE START OF THE NEXT MESSAGE IN THE LOCAL BUFFER
;	R9 = ADDRESS OF THE OUTPUT RAB
;
NXTMSG:	DECB	R6			; IS THERE ANOTHER MSG?
	BGEQ	30$			; BRANCH TO FORMAT ANOTHER MSG
20$:	BRW	PRCBUF			; TRY FOR ANOTHER BUFFER
	ASSUME	EMB$W_HD_ENTRY	EQ ERF$W_HD_ENTRY
	ASSUME	EMB$Q_HD_TIME	EQ ERF$Q_HD_TIME
	ASSUME	EMB$W_HD_ERRSEQ	EQ ERF$W_HD_ERRSEQ
30$:	ADDL	#EMB$K_LENGTH,R8	; POINT PAST MESSAGE HEADER
	MOVZWL	EMB$W_SIZE(R8),R1	; GET SIZE OF MESSAGE TEXT
	SUBL	#EMB$K_LENGTH,R1	; SUBTRACT SIZE OF MESSAGE HEADER
	MOVW	R1,RAB$W_RSZ(R9)	; AND SET INTO RAB
	MOVAL	(R8),RAB$L_RBF(R9)	; AND THE ADDRESS OF THE BUFFER
	TSTB	EMB$B_VALID(R8)		; IS RECORD VALID?
	BNEQ	40$			; BRANCH ON YES
	BISB	#ERF$M_HD_INVALD,ERF$W_HD_ENTRY(R8) ; FLAG INVALID BUFFER
40$:	MOVL	R8,R7			; COPY START OF CURRENT RECORD
	ADDL	R1,R8			; ADVANCE TO NEXT RECORD
 
	.DSABL	LSB
;
; OUTPUT ERROR MESSAGE.  R1=SIZE.
;
MSGOUT:	CMPB	W^LASTENTRY,#EMB$C_TS	; LAST REC = TIME STAMP?
	BNEQ	10$			; BRANCH ON NO
	CMPB	ERF$W_HD_ENTRY(R7),#EMB$C_TS ; THIS REC = TIME STAMP?
	BNEQ	10$			; BRANCH ON NO
	MOVB	#RAB$C_RFA,RAB$B_RAC(R9) ; SET RANDOM FILE ACCESS
	$FIND	RAB=(R9)		; FIND LAST RECORD WRITTEN
	BLBC	R0,WRITE_FAILURE	; BR IF ERROR
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R9) ; SET TO SEQUENTIAL ACCESS
	$UPDATE	RAB=(R9)		; UPDATE LAST RECORD
	BLBC	R0,WRITE_FAILURE	; BR IF ERROR
	BRW	MBX			; BRANCH TO MAILBOX PROCESSING
10$:	MOVB	ERF$W_HD_ENTRY(R7),W^LASTENTRY ; SAVE MSG ENTRY TYPE
	CMPB	ERF$W_HD_ENTRY(R7),#EMB$C_VM	; VOLUME MOUNTED?
	BEQL	20$			; XFER IF SO
	CMPB	ERF$W_HD_ENTRY(R7),#EMB$C_VD	; OR VOLUME DISMOUNTED?
	BNEQ	30$			; XFER IF NOT
20$:	PUSHL	R7			; ELSE SAVE ADDRESS OF THE BUFFER
	CALLS	#1,ERF$MOUNT		; GO FORM OPERATOR MESSAGE AND SEND IT
30$:	$PUT	RAB=(R9)		; OUTPUT MSG
	BLBS	R0,MBX			; BR IF SUCCESSFUL $PUT
;
; COME HERE IF AN ACCESS TO THE ERRORLOG FILE FAILED.
;
WRITE_FAILURE:
	$GETMSG_S -			; TRANSLATE REASON FOR FAILURE
		MSGID=R0, -
		MSGLEN=W^R0MSG_LEN, -
		BUFADR=W^R0MSG_DSC
	MOVL	W^OPRMSG_LEN,R4		; SAVE BASIC MESSAGE LENGTH
	ADDL2	W^R0MSG_LEN,W^OPRMSG_LEN; COMBINE OPRMSG WITH STATUS MSG
	$SNDOPR_S -			; INFORM OPERATOR OF ERROR IN
		MSGBUF=W^OPRMSG_DSC	; WRITING ERRORLOG FILE
	MOVL	R4,W^OPRMSG_LEN		; RESTORE BASIC MESSAGE LENGTH
	$CLOSE	FAB=W^OUTFAB		; CLOSE FILE AS CAN'T WRITE TO IT
	ACBB	W^ERF$B_MAXERRCNT,#1, -	; INC ERROR COUNT AND BRANCH IF ITS
		W^ERF$B_ERRCNT,10$	; <= MAX ERROR COUNT.
	$SNDOPR_S -			; ELSE NOTIFY OPERATOR THAT THIS
		MSGBUF=W^BYEMSG_DSC	; PROCESS WILL BE DELETED.
	BRB	MBX			; BRANCH TO MAILBOX PROCESSING
10$:					; ERROR COUNT <= MAX ERROR COUNT
	INCL	R3			; SIGNAL ACCESS FAILURE
	MOVAB	W^OUTFAB,R2		; MUST CREATE NEW FILE
	CLRW	FAB$W_IFI(R2)		; CLEAR INDICATOR TO OPEN NEW FILE
	$FAB_STORE -			; REINITIALIZE FAB
		FAB=(R2), -
		ORG=SEQ, -		; SEQUENTIAL ORGANIZATION
		MRS=#0, -		; NO MAX ON RECORD SIZE
		RFM=VAR			; VARIABLE LENGTH RECORDS
	BRW	PRCNXT1			; GO TRY TO OPEN A NEW FILE
MBX:					; MAILBOX MESSAGES
	MOVL	SP,R11			; MARK THE STACK
	MOVZWL	W^ERF$W_MBXCHN,R0	; MBX CHANNEL ALREADY?
	BEQL	30$			; BRANCH ON NONE
	CMPW	G^EXE$GQ_ERLMBX,W^ERF$W_MBXUNT ; SAME AS LAST TIME?
	BEQL	50$			; YES, GO MAIL THE MSG
	$DASSGN_S	CHAN=R0		; NO, DEASSIGN OLD CHANNEL
	CLRW	W^ERF$W_MBXCHN		; CLEAR OLD CHANNEL
30$:
	MOVZWL	G^EXE$GQ_ERLMBX,R0	; GET NEW MAIL BOX UNIT
	MOVW	R0,W^ERF$W_MBXUNT	; SET NEW UNIT TO USE
	BEQL	40$			; BRANCH IF NONE
	SUBL	#32-4,SP		; ALLOCATE BUFFER IN THE STACK
	MOVL	SP,R2			; MARK START OF MAIL BOX UNIT
	PUSHL	#^A/_MBA/		; SET PROTOTYPE NAME
	PUSHL	SP			; SET START OF BUFFER
	BSBW	100$			; SET UNIT OF MAILBOX
	SUBL3	(SP),R2,-(SP)		; FIND LENGTH OF NAME
	MOVL	SP,R2			; SAVE POINTER TO NAME
	$ASSIGN_S	DEVNAM=(R2),-	; ASSIGN A CHANNEL TO
			CHAN=W^ERF$W_MBXCHN; THE DIAGNOSTIC MAILBOX
	BLBS	R0,45$			; BRANCH ON SUCCESS
40$:	BRW	65$			; SKIP THE QIO IF FAILED
45$:
	MOVL	#32,(SP)		; RESET LENGTH OF BUFFER
	$GETCHN_S	CHAN=W^ERF$W_MBXCHN,-; GET SIZE OF MAILBOX
			PRIBUF=(R2)	; I.E., THE MAXIMUM MSG SIZE
	MOVL	4(R2),R2		; GET ADDRESS OF DEV CHAR BUFFER
	MOVW	DIB$W_DEVBUFSIZ(R2),W^ERF$W_MBXSIZ ; GET MAILBOX SIZE
50$:	MOVZWL	RAB$W_RSZ(R9),R0	; GET SIZE OF MESSAGE
	CMPW	R0,W^ERF$W_MBXSIZ	; MSG TOO LARGE?
	BLEQU	55$			; BRANCH ON OK
	MOVW	W^ERF$W_MBXSIZ,R0	; TRUNCATE MSG
55$:	$QIO_S	CHAN=W^ERF$W_MBXCHN,-	; CHANNEL FOR DIAG MBX
		FUNC=#<IO$_WRITEVBLK!IO$M_NOW>,- ; DONT WAIT FOR SUCCESS
		P1=(R7),-		; ADDR OF ERROR MSG
		P2=R0			; SIZE OF MSG
	CMPB	W^ERF$B_ERRCNT, -	; HAVE WE EXCEEDED THE ERROR
		W^ERF$B_MAXERRCNT	; THRESHHOLD?
	BLEQ	65$			; BRANCH IF NO
	MOVZWL	W^BYEMSG_LEN,R0		; GET LENGTH OF GOODBYE MESSAGE
	CMPW	R0,ERF$W_MBXSIZ		; MESSAGE TOO LARGE?
	BLEQU	60$			; BRANCH ON OK
	MOVW	W^ERF$W_MBXSIZ,R0	; TRUNCATE MESSAGE
60$:
	$QIO_S -			; NOTIFY MAILBOX THAT PROCESS IS
		CHAN=W^ERF$W_MBXCHN, -	; BEING DELETED.
		FUNC=#<IO$_WRITEVBLK!IO$M_NOW>, -
		P1=W^BYEMSG, -
		P2=R0
65$:	MOVL	R11,SP			; RESET THE STACK POINTER
	CMPB	W^ERF$B_ERRCNT, -	; HAVE WE EXCEEDED THE ERROR
		W^ERF$B_MAXERRCNT	; THRESHHOLD?
	BGTR	70$			; BRANCH IF YES
	BRW	NXTMSG			; ELSE GO PROCESS NEXT MESSAGE
;
; IF ERRCNT > MAXERRCNT, DELETE THIS PROCESS TO PREVENT INFINITE LOOPING.
; THE ERRFMT PROCESS CAN BE RESTARTED VIA AN OPERATOR COMMAND FILE.
;
70$:	$DELPRC_S			; DELETE THIS PROCESS

;
; LOCAL SUBROUTINE TO CONVERT BINARY TO ASCII AND STORE RESULT
; IN BUFFER POINTED TO BY R2
;
 
100$:	CLRL	R1			; ZERO HI 1/2 OF QUAD WORD
110$:	EDIV	#10,R0,R0,-(SP)		; GET NEXT DIGIT
	ADDL	#^A/0/,(SP)		; FIND THE DIGIT IN ASCII
	TSTL	R0			; ANY THING LEFT
	BEQL	120$			; BR IF NO MORE TO CONVERT
	BSBB	110$			; GET NEXT DIGIT
120$:	CVTLB	(SP)+,(R2)+		; STORE A BYTE
	RSB				;
	.PAGE
	.SBTTL	ERRFMT KERNAL MODE INIT
;++
;
; ERF$INIT - INITIALIZE THE ERROR FORMAT PROGRAM
;
; THIS ROUTINE IS ENTERED AT KERNAL MODE TO DELETE A PRVIOUS COPY
; OF THIS PROCESS IF ONE EXISTS, TEHREBY PERMITTING ONLINE REPLACEMENT
; OF THE ERROR FORMAT PROGRAM, AS WELL AS EASE OF TESTING. ALSO, THE
; KERNAL MODE TIMER AST FOR TIME STAMPING THE ERROR LOG IS STARTED.
;--
;
	.ENABL	LSB
	.ENTRY	ERF$INIT,^M<R2,R3>	;
	MOVAL	ERL$GL_ERLPID,R2	; GET ADDRESS OF CURRENT PID
	MOVL	G^SCH$GL_CURPCB,R3	; GET CURRENT PCB
	TSTL	(R2)			; PID EGUAL ZERO?
	BEQL	10$			; BR IF YES - NO PREVIOUS ERRFMT
	CMPL	PCB$L_PID(R3),(R2)	; MAKE SURE IT IS THIS PROCESS
	BEQL	10$			; BR IF SAME PROCESS
	$DELPRC_S PIDADR=(R2)		; DELETE OLD ERRFMT
10$:	MOVL	PCB$L_PID(R3),(R2)	; SET THE PID FOR THIS PROCESS
	MFPR	#PR$_SID,W^SID		; GET SYS ID REGISTER
	BRB	30$			;
	.PAGE
	.SBTTL	TIME STAMP ROUTINE
 
;++
;
; ERF$TIMSTMP - TIME STAMP
;
; THIS ROUTINE IS ENTERED PERIODICALLY TO ENTER A TIME STAMP INTO
; THE ERROR MESSAGE BUFFER.  THEY ARE REMOVED ALONG WITH ANY OTHER
; ENTRIES MADE BY THE MAIN LINE OF THIS PROGRAM.
;
; THIS ROUTINE HAS NO INPUTS AND ONLY OUTPUT IS THE ENTRY OF THE
; TIME STAMP IN THE ERROR LOG BUFFER.  IF A BUFFER CAN NOT BE
; ALLOCATED, THAT TIME STAMP IS LOST.
;--

	.ENTRY	ERF$TIMSTMP,0		; TIME STAMP ROUTINE
	MOVZBL	#EMB$C_TS_LENGTH,R1	; GET LENGTH OF MSG
	JSB	ERL$ALLOCEMB		; GO GET A MSG BLOCK
	BLBC	R0,30$			; BRANCH ON NO BLOCK
	MOVW	#EMB$K_TS,EMB$W_HD_ENTRY(R2) ; SET ENTRY TYPE
	JSB	ERL$RELEASEMB		; RELEASE BLOCK
30$:	$SETIMR_S	-		; SET A TIMER FOR TIME STAMPS
		DAYTIM=ERF$Q_DELTA,-	; TIMER DELTA TIME
		ASTADR=ERF$TIMSTMP,-	; THE TIME STAMP ENTRY
		REQIDT=#EMB$K_TS	; AST PARAMETER IS MESSAGE TYPE
	RET
 
	.DSABL	LSB
	.PAGE
	.SBTTL	VOLUME MOUNT/DISMOUNT MESSAGE ROUTINE

;++
;
; ERF$MOUNT - MOUNT STATUS MESSAGE
;
; THIS ROUTINE IS PASSED THE ADDRESS OF THE MESSAGE. FROM THE MESSAGE, IT
; BUILDS A MESSAGE FOR THE OPERATOR INDICATING THE MOUNT STATUS (MOUNTED OR
; DISMOUNTED) AND SENDS IT TO THE APPROPRIATE OPERATOR. TAPE MOUNTS GO TO
; THE 'TAPES' OPERATOR, DISK MOUNTS GO TO THE 'DISKS' OPERATOR, AND ANY OTHER
; MESSAGES GO TO THE 'DEVICES' OPERATOR FOR HANDLING.
;
;--

	.ENTRY	ERF$MOUNT,^M<R2,R3,R4,R5,R6,R8,R9,R10>
;
; DETERMINE IF A MESSAGE SHOULD BE SENT.
	MOVL	G^EXE$GL_MSGFLAGS,R1		; GET SYSTEM MESSAGE FLAGS
	CMPB	EMB$W_HD_ENTRY(R7),#EMB$C_VM	; IS THIS A MOUNT NOTIFICATION?
	BNEQ	20$				; BRANCH IF NOT
	BBS	#EXE$V_MOUNTMSG,R1,SNDMSG	; BR IF MOUNT NOTIFICATION DESIRED
10$:	RET					; OTHERWISE RETURN (NO STATUS)
20$:	BBC	#EXE$V_DISMOUMSG,R1,10$		; BR IF DISMOUNT NOTIFICATION NOT DESIRED
		
;
; BUILD A BUFFER DESCRIPTOR AND USE IT TO HOLD THE FORMATTED DEVICE NAME.
;
SNDMSG:	SUBL2	#28,SP			; MAKE ROOM FOR DESCRIPTOR AND BUFFER
	MOVL	SP,R6			; COPY DESCRIPTOR ADDRESS
	MOVL	#20,(R6)+		; SET DEVICE NAME BUFFER LENGTH
	MOVAL	4(R6),(R6)+		; SET DEVICE NAME BUFFER ADDRESS
	MOVL	SP,R6			; RESET DESCRIPTOR ADDRESS
	MOVAB	ERF$B_VM_NAMLNG(R7),R8	; GET ADDRESS OF DEVICE ASCIC STRING
	MOVZWL	ERF$W_VM_UNIT(R7),R9	; GET DEVICE UNIT NUMBER
	$FAO_S	DEVFAO,(R6),(R6),R8,R9	; FORMAT THE DEVICE NAME
;
; BUILD A $GETDVI ITEM LIST ON THE STACK AND
; CALL $GETDVI TO DETERMINE THE DEVICE CLASS.
;
	CLRQ	-(SP)			; MAKE ROOM ON THE STACK FOR THE
	CLRQ	-(SP)			; $GETDVI ITEM LIST
	MOVL	SP,R8			; SAVE ADDRESS FOR LATER
	MOVL	#<DVI$_DEVCLASS@16>!4,(R8)	; SET ITEM CODE AND BUFFER SIZE
	CLRL	-(SP)			; MAKE ROOM FOR THE DEVICE CLASS
	MOVL	SP,4(R8)		; NOTE THE STORAGE ADDRESS
					; NO RETURN LENGTH NEEDED
	$GETDVI_S	EFN=#6,-	; GET THE NEEDED DEVICE INFO
			DEVNAM=(R6),-
			ITMLST=(R8)
	$WAITFR_S	EFN=#6		; WAIT UNTIL COMPLETE
	POPL	R1			; GET THE DEVICE CLASS
	MOVZWL	#<OPC$M_NM_DISKS@8>!OPC$_RQ_RQST,R0	; SET FOR DISK OPERATOR
	CMPB	R1,#DC$_DISK		; WAS IT A DISK DEVICE?
	BEQL	10$			; XFER IF SO
	MOVZWL	#<OPC$M_NM_TAPES@8>!OPC$_RQ_RQST,R0	; ELSE SET FOR TAPE
	CMPB	R1,#DC$_TAPE		; WAS IT A TAPE DEVICE?
	BEQL	10$			; XFER IF SO
	MOVZWL	#<OPC$M_NM_DEVICE@8>!OPC$_RQ_RQST,R0	; ELSE UNKNOWN.
10$:	MOVL	R0,MOUNT_MSG		; SET OPERATOR NAME
;
; FORMAT THE OPERATOR MESSAGE AND SEND IT TO OPCOM.
;
	MOVW	#128,MOUNT_DSC		; RESET DESCRIPTOR SIZE
	PUSHL	R6			; SET DEVICE NAME DESCRIPTOR
	PUSHAB	MOUNT_MNT		; SET FOR MOUNT MESSAGE
	CMPB	EMB$W_HD_ENTRY(R7),#EMB$C_VM	; RIGHT?
	BEQL	40$			; XFER IF SO
	MOVAB	MOUNT_DMT,(SP)		; ELSE SET FOR DISMOUNT MESSAGE
40$:	PUSHAB	ERF$T_VM_LABEL(R7)	; ADDRESS OF VOLUME LABEL
	PUSHL	#12			; SIZE OF THE LABEL
	$FAO_S	MOUNT_FAO,MOUNT_DSC,MOUNT_DSC	;FORMAT THE MESSAGE
	$SNDOPR_S	MSGBUF=MOUNT_DSC	; SEND THE MESSAGE
	RET				; RETURN WHEN DONE
	.PAGE
	.SBTTL	GET ERROR LOG BUFFER
;++
;
; ERF$GETBUF - GET ERROR LOG BUFFER
;
; THIS ROUTINE IS CALLED IN KERNAL MODE TO GET A BUFFER OF ERROR
; MESSAGES FORM THE ERROR LOG FACILITY. IF THE BUFFER HAS BUSY
; MESSAGES, THIS PROCESS WAITS FOR A WHILE.  IF THE MESSAGE DOES
; NOT GO UNBUSY IN A REASONABLE TIME, THE BUFFER IS TAKEN IN ITS
; INDETERMINATE FORM.
;
; RETURN OF R0 = FALSE INDICATES NO BUFFERS WERE READY,
;	TRUE INDICATES A BUFFER WAS OBTAINED.
;--
	.ENTRY	ERF$GETBUF,^M<R2,R3,R4,R5,R6,R7,R10>; ENTRY POINT MASK
	MOVZBL	#ERF$C_LOOP_CNT,R10	; SET A LOOP COUNT
	MOVZBL	ERL$GB_BUFPTR,R4	; GET BUFFER POINTER
	MOVL	ERL$AL_BUFADDR[R4],R6	; GET BUFFER ADDRESS
	MOVAB	W^INBUF,R7		; GET ADDR OF STORAGE BUF
	BBSSI	#ERL$V_LOCK,ERL$B_FLAGS(R6),20$; INHIBIT ALLOCATIONS
20$:	TSTB	ERL$B_BUSY(R6)		; IS BUFFER CHANGING?
	BEQL	30$			; BR IF NO
	DECL	R10			; IS WAIT TIME UP FOR THIS BUFFER?
	BEQL	30$			; BR IF YES
	$SETIMR_S	#2,ERF$Q_WAIT	; WAIT FOR A BIT
	$WAITFR_S	#2		; FOR THE MESSAGES TO COMPLETE
	BRB	20$			; CHECK THE BUFFER AGAIN
30$:	MOVZBL	#ERF$C_LOOP_CNT,R10	; SET A LOOP COUNT
35$:	MOVC3	#512,(R6),(R7)		; COPY BUFFER
	CMPC3	#512,(R6),(R7)		; DID BUFFER CHANGE ?
	BEQL	40$			; IF EQL, OK
	DECL	R10			; IS WAIT TIME UP FOR THIS BUFFER?
	BEQL	40$			; BR IF YES
	$SETIMR_S	#2,ERF$Q_WAIT	; WAIT FOR A BIT
	$WAITFR_S	#2		; FOR THE MESSAGES TO COMPLETE
	BRB	35$			; CHECK THE BUFFER AGAIN
40$:	DSBINT				; DISABLE INTERRUPTS
	CLRW	ERL$B_BUSY(R6)		; CLEAR MESSAGE AND BUSY COUNTS
	CMPL	ERL$L_NEXT(R6),ERL$L_END(R6) ; WAS BUFFER FULL?
	BNEQU	50$			; IF NEQU NO
	XORB	#1,ERL$GB_BUFPTR	; INDICATE NEXT BUFFER TO READ
50$:	MOVAB	ERL$C_LENGTH(R6),ERL$L_NEXT(R6) ; SET ALL BUFFER FREE
	BBCCI	#ERL$V_LOCK,ERL$B_FLAGS(R6),60$; ENABLE ALLOCATIONS
60$:	ENBINT				; ENABLE INTERRUPTS
	MOVZBL	W^INBUF+ERL$B_MSGCNT,R0	; ANY COMPLETED MESSAGES?
	BEQL	70$			; IF EQL NO MESSAGES
	MOVL	#1,R0			; SET SUCESSFUL INDICATION
70$:	RET				; RETURN
 
	.END	ERF$START
