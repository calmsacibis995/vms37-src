	.TITLE	TMDRIVER - TM03-TE16/TU77 MAGTAPE DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 20-JUN-77
;
; MODIFIED BY:
;
;	V02-027	RLRAVAIL	Robert L. Rappaport		28-Dec-1981
;		Added support for IO$_AVAILABLE function which is in effect
;		a REWIND (NOWAIT) that also clears the UCB$M_VALID bit in
;		UCB$W_STS.
;		Also added code to correct hardware glitch. If at label
;		RETREG, we are in PE mode and if the saved CC register
;		indicates that all 9 tracks were bad, then we set the
;		MT_ER_M_INC bit in the UCB$W_MT_ER.
;
;	V02-026	RLR40574	Robert L. Rappaport		10-Sep-1981
;		Correct error in read reverse retry logic that crashes
;		the system.  Change a BGTR instruction to BGTRU.
;		Error introduced by earlier correction to read (and writecheck)
;		reverse error retry logic.  Error only manifests itself if
;		the record that requires a retry is apparently larger than
;		32K bytes in length so that its length expressed as a 16
;		bit integer looks like a negative number.
;
;	V02-025	RLRHANG		Robert L. Rappaport		19-Aug-1981
;		Allow Interrupt Service Routine to DRIVE CLEAR rewinding
;		tape drives.  This software change issued in conjunction
;		with hardware ECO that allows DRIVE CLEAR to be issued to
;		a drive that has PIP asserted.
;
;	V02-024	RLR38840	Robert L. Rappaport		7-July-1981
;		1.  Allow reads of records of less than 14 bytes in Phase
;		     Encoded (PE) mode (1600 BPI).
;		2.  Also do NOT clear Volume Valid on timeouts on READS done at
;		     BOT.  This eliminates old problem where INIT fails on new
;		     tapes (without ID burst) with a SS$_VOLINV.
;
;	V02-023	RLR37408	Robert L. Rappaport		4-May-1981
;		Corrected user identified bug in READ error retry logic
;		when error occurred on very first record of tape.
;
;	V02-022	RLRPWRCN	Robert L. Rappaport		31-Mar-1981
;		Added code to allow IO$_CANCEL to succeed if current
;		operation is stalled while the DRIVER is repositioning
;		the tape following POWERFAIL recovery.
;	V02-021	RLR0012		Robert L. Rappaport		28-Feb-1981
;		Took steps in TM_SAVDRVSTS and TM_REGDUMP to save contents
;		of MT_CC register and record it in the ERRORLOG buffer.
;		Before, DRIVE CLEAR in TM_SAVDRVSTS cleared contents before
;		we could read it.
;
;	V02-020	RLR35662	Robert L. Rappaport		12-Feb-1981
;		Fixed two error recovery bugs; first wherein internal
;		spacing incorrectly spaced over two records due to low
;		frame count value and second where system crashed on
;		reverse writecheck due to attempt to shift buffer when
;		frame count was larger than original BCNT.  Also removed
;		multiply named bit fields in MT_ER definition and inserted
;		explicit equivalence statements for each of these.  This
;		is due to new VIELD macro expansion.
;
;	V02-019	RLR0011		Robert L. Rappaport		11-Nov-1980
;		Increased maximum timeout values for all spacing functions
;		to 12 minutes to account for the possibility of a long
;		file occupying the entire tape on a 45 ips drive.
;
;	V02-018	RLR0010		Robert L. Rappaport		22-Sept-1980
;		Fixed bug in forward spacing when tape is at logical BOT
;		but not at physical BOT (i.e. between BOT and the first
;		record.
;
;	V02-017	RLR0009		Robert L. Rappaport		6-June-1980
;		Added code in CANCELIO to abort any operation waiting
;		for a REWIND in progress to terminate.
;
;	V02-016	RLR0008		Robert L. Rappaport		20-May-1980
;		Added UCB$L_MT_ORGPOS field to UCB into order to be able
;		to record the value of UCB$L_MT_RECORD at STARTIO time.
;		In POWERFAIL recovery, we restore position to this value
;		so that we may restart correctly functions such as
;		SPACERECORD and SPACEFILE.
;
;	V02-015	RLR0007		Robert L. Rappaport		7-May-1980
;		In POWERFAIL, added code to try to issue hardware
;		REWIND before asking operator to rewind drive
;
;	V02-014	RLR0006		Robert L. Rappaport		18-April-1980
;		Inhibit logging a device error when the only error
;		incurred in an I/O operation is a direct result of the
;		media on the device being OFF-LINE.
;
;
; TM03-TE16/TU77 MAGTAPE DRIVER
;
; MACRO LIBRARY CALLS
;

	$ADPDEF				;DEFINE ADP OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS BITS
	$DPTDEF				;DEFINE DPT OFFSETS
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$MBADEF				;DEFINE MBA REGISTER OFFSETS
	$MTDEF				;DEFINE MAGTAPE STATUS BITS
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE INTERRUPT DISPATCH VECTOR OFFSETS
	$WCBDEF				;DEFINE WCB OFFSETS

;
; LOCAL MACROS
;
; CHECK FOR FATAL OR RETRIABLE ERROR
;

	.MACRO	CHECK_ERROR
		BSBW	CHECK_ERROR
	.ENDM	CHECK_ERROR

;
; EXECUTE FUNCTION AND BRANCH ON RETRIABLE ERROR CONDITION
;

	.MACRO	EXFUNC BDST,FCODE
		.IF NB	FCODE
		MOVZBL	#CD'FCODE,R0
		.ENDC
		BSBW	FEX
		.WORD	BDST-.-2
	.ENDM	EXFUNC

;
; GENERATE FUNCTION TABLE ENTRY AND CASE TABLE INDEX SYMBOL
;

	.MACRO	GENF FCODE
		CD'FCODE=.-FTAB
		.BYTE	FCODE!MT_CS1_M_GO
	.ENDM	GENF

;
; GENERATE ERROR MASK TABLE ENTRY
;

	.MACRO	MASK LIST
$.$=0
	.IRP	X,<LIST>
$.$=$.$!MT_ER_M_'X
	.ENDM
	.WORD	$.$
	.ENDM	MASK

;
; TEST IF ANY RETRIES REMAINING
;

	.MACRO	TESTR BDST
		BSBW	TESTR
		.WORD	BDST-.-2
	.ENDM	TESTR

;
; LOCAL SYMBOLS
;
; TE16/TU77 MASSBUS REGISTER OFFSETS
;

	$DEFINI	MT

$DEF	MT_CS1		.BLKL	1	;DRIVE CONTROL REGISTER
	_VIELD	MT_CS1,0,<-		; DRIVE CONTROL REGISTER BIT DEFINITIONS
		<GO,,M>,-		; GO BIT
		<FCODE,5>-		; FUNCTION CODE
	>				;
$DEF	MT_DS		.BLKL	1	;DRIVE STATUS REGISTER
	_VIELD	MT_DS,0,<-		; DRIVE STATUS REGISTER BIT DEFINITIONS
		<SLA,,M>,-		; SLAVE ATTENTION
		<BOT,,M>,-		; BEGINNING OF TAPE
		<TM,,M>,-		; TAPE MARK
		<IDB,,M>,-		; IDENTIFICATION BURST
		<SDWN,,M>,-		; SLOWING DOWN
		<PES,,M>,-		; PHASE ENCODED
		<SSC,,M>,-		; SLAVE STATUS CHANGE
		<DRY,,M>,-		; DRIVE READY
		<DPR,,M>,-		; DRIVE PRESENT
		<,1>,-			; RESERVED BIT
		<EOT,,M>,-		; END OF TAPE
		<WRL,,M>,-		; DRIVE WRITE LOCKED
		<MOL,,M>,-		; MEDIUM ONLINE
		<PIP,,M>,-		; POSITIONING IN PROGRESS
		<ERR,,M>,-		; COMPOSIT ERROR
		<ATA,,M>-		; ATTENTION ACTIVE
	>				;
$DEF	MT_ER		.BLKL	1	;ERROR REGISTER
	_VIELD	MT_ER,0,<-		; ERROR REGISTER BIT DEFINITIONS
		<ILF,,M>,-		; ILLEGAL FUNCTION
		<ILR,,M>,-		; ILLEGAL REGISTER
		<RMR,,M>,-		; REGISTER MODIFY REFUSED
		<CPAR,,M>,-		; CONTROL BUS PARITY ERROR
		<FMT,,M>,-		; FORMAT ERROR
		<DPAR,,M>,-		; DATA BUS PARITY ERROR
		<VPE,,M>,-		; VERTICLE PARITY ERROR (NRZI)
		<LRC,,M>,-		; LONGITUDINAL PARITY ERROR (NRZI)
		<NSG,,M>,-		; NONSTANDARD GAP
		<FCE,,M>,-		; FRAME COUNT ERROR
		<ITM,,M>,-		; ILLEGAL TAPE MARK
		<NEF,,M>,-		; NONEXECUTABLE FUNCTION
		<DTE,,M>,-		; DRIVE TIMING ERROR
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<UNS,,M>,-		; DRIVE UNSAFE
		<CRC,,M>,-		; CRC ERROR (NRZI)
	>				;
; Explicitly define alternate names for some bits in MT_ER.

MT_ER_M_INC=MT_ER_M_VPE
MT_ER_V_INC=MT_ER_V_VPE
MT_ER_M_PEF=MT_ER_M_LRC
MT_ER_V_PEF=MT_ER_V_LRC
MT_ER_M_CS=MT_ER_M_ITM
MT_ER_V_CS=MT_ER_V_ITM
MT_ER_M_COR=MT_ER_M_CRC
MT_ER_V_COR=MT_ER_V_CRC

$DEF	MT_MR		.BLKL	1	;MAINTENANCE REGISTER
$DEF	MT_AS		.BLKL	1	;ATTENTION SUMMARY REGISTER
$DEF	MT_FC		.BLKL	1	;FRAME COUNT REGISTER
$DEF	MT_DT		.BLKL	1	;DRIVE TYPE REGISTER
	_VIELD	MT_DT,0,<-		; DRIVE TYPE REGISTER FIELD DEFINITIONS
		<DTN,9>,-		; DRIVE TYPE NUMBER
		<,1>,-			; RESERVED BIT
		<SPR,,M>,-		; SLAVE PRESENT
		<DRQ,,M>,-		; DRIVE REQUEST REQUIRED (ALWAYS 0)
		<7CH,,M>,-		; 7-CHANNEL TAPE (ALWAYS 0)
		<MOH,,M>,-		; MOVING HEAD (ALWAYS 0)
		<TAP,,M>,-		; TAPE DRIVE (ALWAYS 1)
	>				;
$DEF	MT_CC		.BLKL	1	;CHECK CHARACTER REGISTER
$DEF	MT_SN		.BLKL	1	;SERIAL NUMBER REGISTER
$DEF	MT_TC		.BLKL	1	;MAGTAPE CONTROL REGISTER
	_VIELD	MT_TC,0,<-		; TAPE CONTROL REGISTER FIELD DEFFINITIONS
		<SSEL,3>,-		; SLAVE SELECT
		<EPAR,1,M>,-		; EVEN PARITY
		<FSEL,4,M>,-		; FORMAT SELECT
		<DEN,3,M>,-		; DENSITY
		<,1>,-			; RESERVED BIT
		<EABO,,M>,-		; ENABLE ABORT ON TRANSFER ERROR
		<TCW,,M>,-		; TAPE CONTROL WRITE
		<FCS,,M>,-		; FRAME COUNT STATUS
		<ACCL,,M>,-		; ACCELERATOR
	>				;

	$DEFEND	MT

;
; DEFINE DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
;

	$DEFINI	UCB,GLOBAL

	$VIELD	UCB,0,<-		;DEVICE DEPENDENT STATUS BITS
		<MT_REWIND,,M>,-	; REWIND IN PROGRESS
		<MT_PRVMOL,,M>,-	; PREVIOUS MEDIUM ONLINE STATE
		<MT_PWRFL,,M>,-		; Currently in Powerfail recovery
		<MT_CNCLP,,M>,-		; Cancel Pending(looked at in Powerfail)
		>			;

.=UCB$L_DPC+4				;

$DEF	UCB$L_MT_SR	.BLKL	1	;SAVED MBA STATUS REGISTER
$DEF	UCB$W_MT_DS	.BLKW	1	;SAVED DRIVE STATUS REGISTER
$DEF	UCB$W_MT_ER	.BLKW	1	;SAVED DRIVE ERROR REGISTER
$DEF	UCB$W_MT_FC	.BLKW	1	;SAVED DRIVE FRAME COUNT REGISTER
$DEF	UCB$W_MT_SPACNT	.BLKW	1	;CURRENT SPACING COUNT
$DEF	UCB$W_MT_CS1	.BLKW	1	;SAVED DRIVE CONTROL REGISTER
$DEF	UCB$W_MT_TC_SAV	.BLKW	1	;SAVED TAPE CONTROL REGISTER
$DEF	UCB$L_MT_RECORD	.BLKL	1	;CURRENT TAPE POSITION
$DEF	UCB$W_MT_FORCNT	.BLKW	1	;FORWARD SPACE COUNT DURING RETRY
$DEF	UCB$W_MT_TC	.BLKW	1	;TAPE CONTROL REGISTER CONTENTS
$DEF	UCB$L_MT_PREVTM	.BLKL	1	; Position of previous TAPEMARK, used
					;  in forward SKIPFILE and SPACEFILE
					;  operations in detecting consecutive
					;  TAPEMARKs
$DEF	UCB$L_MT_ORGPOS	.BLKL	1	; Here store value of UCB$L_MT_RECORD
					;  at STARTIO time.
$DEF	UCB$W_MT_CC_SAV	.BLKW	1	; Space to save controller register.
			.BLKW	1	; RESERVED for now.
UCB$K_MT_LENGTH=.			; Length of MT UCB.

	$DEFEND	UCB

;
; MAXIMUM SPACING ON READ AND WRITECHECK ERRORS
;

ERR_SPACING=5				;FIVE RECORDS

;
; HARDWARE FUNCTION CODES
;

F_NOP=0*2				;NO OPERATION
F_PACKACK=0*2				;PACK ACKNOWLEDGE
F_SENSECHAR=0*2				;SENSE TAPE CHARACTERISTICS
F_SETCHAR=0*2				;SET TAPE CHARACTERISTICS
F_UNLOAD=1*2				;UNLOAD DRIVE
F_REWIND=3*2				;REWIND
F_DRVCLR=4*2				;DRIVE CLEAR
F_READPRESET=8*2			;READ IN PRESET
F_ERASE=10*2				;ERASE TAPE
F_WRITEMARK=11*2			;WRITE TAPE MARK
F_SPCFILFOR=12*2			;SPACE FILE FORWARD
F_SPCFILREV=13*2			;SPACE FILE REVERSE
F_SPCRECFOR=12*2			;SPACE RECORD FORWARD
F_SPCRECREV=13*2			;SPACE RECORD REVERSE
F_INTSPCFOR=20*2			;INTERNAL SPACE RECORD FORWARD
F_INTSPCREV=23*2			;INTERNAL SPACE RECORD REVERSE
F_WRITECHECK=20*2			;WRITE CHECK DATA FORWARD
F_WRITECHECKR=23*2			;WRITE CHECK DATA REVERSE
F_WRITE=24*2				;WRITE DATA FORWARD
F_WRITEDATA=24*2			;WRITE DATA FORWARD
F_READDATA=28*2				;READ DATA FORWARD
F_READDATAR=31*2			;READ DATA REVERSE

;
; MINIMUM RECORD SIZE
;

MIN_RECORD=14				;FOURTEEN BYTES

;
; HARWARE DENSITY DEFINITIONS
;

NRZI=3					;800 BPI
PE=4					;PHASE ENCODED

;
; ERROR COUNT THRESHOLD BEFORE ALTERNATE RECOVERY ATTEMPTED
;

THRESHOLD=8				;EIGHT RETRIES BEFORE ALTERNATE METHOD

;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;

	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=TM_END,-		;END OF DRIVER
		FLAGS=DPT$M_SUBCNTRL,-	;INDICATE SUBCONTROLLER
		ADAPTER=MBA,-		;ADAPTER TYPE
		UCBSIZE=UCB$K_MT_LENGTH,- ;UCB SIZE
		NAME=TMDRIVER		;DRIVER NAME
	DPT_STORE INIT			;CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\MTA\> ;DEFAULT ACP NAME
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING ENABLED
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_SDI-		; SINGLE DIRECTORY DEVICE
		!DEV$M_SQD>		; SEQUENTIAL DEVICE
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TAPE ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,2048 ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,W,<^X3C0> ;DEFAULT TAPE PARAMETERS
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTCNT,B,16	;ERROR RETRY COUNT
	DPT_STORE UCB,UCB$B_ERTMAX,B,16	;MAX ERROR RETRY COUNT
	DPT_STORE UCB,UCB$W_MT_TC,W,<^X3C0> ;DEFAULT TAPE PARAMETERS
	DPT_STORE REINIT		;CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,TM$INT ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,TM_TXXX_INIT ;UNIT INIT
	DPT_STORE DDB,DDB$L_DDT,D,TM$DDT ;DDT ADDRESS
	DPT_STORE END			;
	.MDELETE DPT_STORE

;
; DRIVER DISPATCH TABLE
;

	DDTAB	TM,-			;DRIVER DISPATCH TABLE
		TM_STARTIO,-		;START I/O OPERATION
		TM_UNSOLNT,-		;UNSOLICITED INTERRUPT
		TM_FUNCTABLE,-		;FUNCTION DECISION TABLE
		TM_CANCELIO,-		;CANCEL I/O ENTRY POINT
		TM_REGDUMP,-		;REGISTER DUMP ROUTINE
		<<MT_TC+4+MBA$L_BCR+4+8>+<<3+5+1>*4>>,- ;DIAGNOSTIC BUFFER SIZE
		<<MT_TC+4+MBA$L_BCR+4+8>+<1*4>+<EMB$L_DV_REGSAV>> ;ERROR BUFFER SIZE

;
; DENSITY CODE TRANSLATION TABLE
;
;	DENSITY CODES ARE TRANSLATED BY TAKING THE FIVE BIT ENCODED DENSITY
;	VALUE, MULTIPLYING BY FOUR TO FORM THE STARTING BIT NUMBER, AND THEN
;	EXTRACTING THE APPROPRIATE DENSITY CODE FROM THE TRANSLATION TABLE.
;

DENSITY:				;
	.LONG	^X33343333		;DENSITY CODES 0-7
	.LONG	^X33333333		;DENSITY CODES 8-15
	.LONG	^X33333333		;DENSITY CODES 16-23
	.LONG	^X33333333		;DENSITY CODES 24-31

;
; TXXX DRIVE TYPE DESCRIPTOR TABLE
;

TM_DTDESC:				;
	.WORD	^X29			;TE16 45 IPS
	.BYTE	DT$_TE16		;
TM_DTDESCLEN=.-TM_DTDESC		;LENGTH OF DRIVE TYPE DESCRIPTOR
	.WORD	^X2A			;TU45 45 IPS
	.BYTE	DT$_TU45		;
	.WORD	^X2C			;TU77 125 IPS
	.BYTE	DT$_TU77		;
	.WORD	0			;END OF TABLE
	.BLKB	TM_DTDESCLEN		;SPARE DRIVE TYPE SLOT

;
; HARDWARE I/O FUNCTION CODE TABLE
;

FTAB:					;
	GENF	F_NOP			;NO OPERATION
	GENF	F_UNLOAD		;UNLOAD VOLUME
	GENF	F_SPCFILFOR		;SPACE FILE FORWARD
	GENF	F_REWIND		;REWIND
	GENF	F_DRVCLR		;DRIVE CLEAR
	GENF	F_SPCFILREV		;SPACE FILE REVERSE
	GENF	F_ERASE			;ERASE TAPE
	GENF	F_SPCRECREV		;SPACE RECORD REVERSE
	GENF	F_PACKACK		;PACK ACKNOWLEDGE
	GENF	F_SPCRECFOR		;SPACE RECORD FORWARD
	GENF	F_WRITECHECK		;WRITE CHECK FORWARD
	GENF	F_WRITEDATA		;WRITE DATA FORWARD
	GENF	F_READDATA		;READ DATA FORWARD
	GENF	F_WRITECHECKR		;WRITE CHECK REVERSE
	GENF	F_WRITE			;WRITE DATA FORWARD
	GENF	F_READDATAR		;READ DATA REVERSE
	GENF	F_READPRESET		;READ IN PRESET
	GENF	F_SETCHAR		;SET TAPE CHARACTERISTICS
	GENF	F_SENSECHAR		;SENSE TAPE CHARACTERISTICS
	GENF	F_WRITEMARK		;WRITE TAPE MARK
	GENF	F_INTSPCFOR		;INTERNAL SPACE RECORD FORWARD
	GENF	F_INTSPCREV		;INTERNAL SPACE RECORD REVERSE

;
; FORMAT CODE TRANSLATION TABLE
;
;	FORMAT CODES ARE TRANSLATED BY TAKING THE FOUR BIT ENCODED FORMAT VALUE,
;	MULTIPLYING BY FOUR TO FORM THE STARTING BIT NUMBER, AND THEN EXTRACTING
;	THE APPROPRIATE FORMAT CODE FROM THE TRANSLATION TABLE.
;

FORMAT:					;
	.LONG	^XCCCCCCCC		;FORMAT CODES 0-7
	.LONG	^XCEDCCCCC		;FORMAT CODES 8-15

;
; FUNCTION TIME OUT TABLE
;

TIME_OUT:				;
	.LONG	0			;NO OPERATION
	.LONG	6			;UNLOAD VOLUME
	.LONG	60*12			; Space File Forward
	.LONG	60*7			;REWIND
	.LONG	0			;DRIVE CLEAR
	.LONG	60*12			; Space File Reverse
	.LONG	6			;ERASE TAPE
	.LONG	60*12			; Space Record Reverse
	.LONG	0			;PACK ACKNOWLEDGE
	.LONG	60*12			; Space Record Forward
	.LONG	12			;WRITE CHECK DATA FORWARD
	.LONG	12			;WRITE DATA FORWARD
	.LONG	12			;READ DATA FORWARD
	.LONG	12			;WRITE CHECK DATA REVERSE
	.LONG	12			;WRITE DATA FORWARD
	.LONG	12			;READ DATA REVERSE
	.LONG	60*7			;READ IN PRESET
	.LONG	0			;SET TAPE CHARACTERISTICS
	.LONG	0			;SENSE TAPE CHARACTERISITCS
	.LONG	6			;WRITE TAPE MARK
	.LONG	12			;INTERNAL SPACE RECORD FORWARD
	.LONG	12			;INTERNAL SPACE RECORD REVERSE

;
; DON'T CARE ERROR MASK TABLE
;
; THIS TABLE CONTAINS A MASK OF THE ERROR BITS THAT ARE TO BE IGNORED FOR EACH
; FUNCTION WHEN EXAMINING THE DRIVE ERROR REGISTER.
;

XTAB:					;
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;NO-OP
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;UNLOAD
	MASK	<FMT,DPAR,INC,PEF,NSG,CS,DTE,COR> ;SPACE FILE FORWARD
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;REWIND
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,NEF,DTE,OPI,COR> ;DRIVE CLEAR
	MASK	<FMT,DPAR,INC,PEF,NSG,CS,DTE,COR> ;SPACE FILE REVERSE
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,DTE,OPI,COR> ;ERASE
	MASK	<FMT,DPAR,INC,PEF,NSG,CS,DTE,COR> ;SPACE RECORD REVERSE
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;PACK ACKNOWLEDGE
	MASK	<FMT,DPAR,INC,PEF,NSG,CS,DTE,COR> ;SPACE RECORD FORWARD
	MASK	<DPAR>			;WRITE CHECK FORWARD
	MASK	<>			;WRITE DATA FORWARD
	MASK	<DPAR>			;READ DATA FORWARD
	MASK	<DPAR>			;WRITE CHECK REVERSE
	MASK	<>			;WRITE DATA FORWARD
	MASK	<DPAR>			;READ DATA REVERSE
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;READIN PRESET
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;SET CHARACTERISTICS
	MASK	<FMT,DPAR,INC,PEF,NSG,FCE,CS,DTE,OPI,COR> ;SENSE CHARACTERISTICS
	MASK	<FMT,DPAR,FCE,DTE,COR>	;WRITE TAPE MARK
	MASK	<DPAR,INC,PEF,FCE,CS,DTE,COR> ;INTERNAL SPACE RECORD FORWARD
	MASK	<DPAR,INC,PEF,FCE,CS,DTE,COR> ;INTERNAL SPACE RECORD REVERSE
	.PAGE
	.SBTTL	TE16/TU77 FUNCTION DECISION TABLE
;+
; TE16/TU77 FUNCTION DECISION TABLE
;-

TM_FUNCTABLE:				;FUNCTION DECISION TABLE
	FUNCTAB	,-			;LEGAL FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SPACERECORD,-		;SPACE RECORDS
		 RECAL,-		;RECALIBRATE (REWIND)
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SPACEFILE,-		;SPACE FILE
		 WRITECHECK,-		;WRITE CHECK FORWARD
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 READPBLK,-		;READ PHYSICAL BLOCK
		 WRITEMARK,-		;WRITE TAPE MARK
		 AVAILABLE,-		;AVAILABLE (REWIND/NOWAIT CLEAR VALID)
		 READLBLK,-		;READ LOGICAL BLOCK
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 SENSEMODE,-		;SENSE TAPE MODE
		 SETMODE,-		;SET MODE
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND SET OFFLINE
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE,-		;SKIP FILES
		 WRITEOF,-		;WRITE END OF FILE
		 READVBLK,-		;READ VIRTUAL BLOCK
		 WRITEVBLK,-		;WRITE VIRTUAL BLOCK
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	,-			;BUFFERED I/O FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 SPACERECORD,-		;SPACE RECORDS
		 RECAL,-		;RECALIBRATE (REWIND)
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE CHARACTERISTICS
		 SETCHAR,-		;SET CHARACTERISTICS
		 SPACEFILE,-		;SPACE FILES
		 WRITEMARK,-		;WRITE TAPE MARK
		 SENSEMODE,-		;SENSE MODE
		 SETMODE,-		;SET MODE
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND UNLOAD
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE,-		;SKIP FILES
		 WRITEOF,-		;WRITE END OF FILE
		 ACCESS,-		;ACCESS FILE AND/OR FIND DIRECTORY ENTRY
		 ACPCONTROL,-		;ACP CONTROL FUNCTION
		 CREATE,-		;CREATE FILE AND/OR CREATE DIRECTORY ENTRY
		 DEACCESS,-		;DEACCESS FILE
		 DELETE,-		;DELETE FILE AND/OR DIRECTORY ENTRY
		 MODIFY,-		;MODIFY FILE ATTRIBUTES
		 MOUNT>			;MOUNT VOLUME
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READLBLK,-		;READ LOGICAL BLOCK FORWARD
		 READPBLK,-		;READ PHYSICAL BLOCK FORWARD
		 READVBLK>		;READ VIRTUAL BLOCK
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITECHECK,-		;WRITE CHECK FORWARD
		 WRITELBLK,-		;WRITE LOGICAL BLOCK
		 WRITEPBLK,-		;WRITE PHYSICAL BLOCK
		 WRITEVBLK>		;WRITE VIRTUAL BLOCK
	FUNCTAB	+ACP$ACCESS,<ACCESS,CREATE> ;ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS> ;DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;ACP CONTROL FUNCTION
		 DELETE,-		;DELETE FILE OR DIRECTORY ENTRY
		 MODIFY>		;MODIFY FILE ATTRIBUTES
	FUNCTAB	+ACP$MOUNT,<MOUNT>	;MOUNT VOLUME
	FUNCTAB	+MT$CHECK_ACCESS,-	;MAGTAPE CHECK ACCESS FUNCTIONS
		<ERASETAPE,-		;ERASE TAPE
		 WRITEMARK,-		;WRITE TAPE MARK
		 WRITEOF>		;WRITE END OF FILE
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			;NO OPERATION
		 UNLOAD,-		;UNLOAD VOLUME
		 RECAL,-		;RECALIBRATE (REWIND)
		 REWIND,-		;REWIND
		 REWINDOFF,-		;REWIND AND SET OFFLINE
		 DRVCLR,-		;DRIVE CLEAR
		 READPRESET,-		;READ IN PRESET
		 PACKACK,-		;PACK ACKNOWLEDGE
		 ERASETAPE,-		;ERASE TAPE
		 SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		 SENSEMODE,-		;SENSE TAPE MODE
		 WRITEMARK,-		;WRITE TAPE MARK
		 AVAILABLE,-		;AVAILABLE (REWIND/NOWAIT CLEAR VALID)
		 WRITEOF>		;WRITE END OF FILE
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTIONS
		<SPACERECORD,-		;SPACE RECORDS
		 SPACEFILE,-		;SPACE FILES
		 SKIPRECORD,-		;SKIP RECORDS
		 SKIPFILE>		;SKIP FILES
	FUNCTAB	+EXE$SETMODE,-		;SET TAPE CHARACTERISTICS
		<SETCHAR,-		;
		 SETMODE>		;
	.PAGE
	.SBTTL	CANCEL I/O ON CHANNEL
;+
; TM_CANCELIO - CANCEL I/O ON CHANNEL
;
; THIS ROUTINE IS CALLED WHEN THE LAST CHANNEL ASSIGNED TO A DEVICE IS DEASSIGNED,
; THE DEVICE IS DEALLOCATED, AND WHEN THE CANCEL I/O ON CHANNEL SYSTEM SERVICE IS
; EXECUTED.
;
; INPUTS:
;
;	R2 = NEGATIVE CHANNEL NUMBER.
;	R3 = ADDRESS OF CURRENT I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = DEVICE UCB ADDRESS.
;
; OUTPUTS:
;
;	IF THE DEVICE IS CURRENTLY BUSY, DOING A REWIND, AND IN A WAITFOR INTERRUPT
;	STATE, THEN THE REWIND FUNCTION IS CANCELLED.
;-

TM_CANCELIO:				;CANCEL I/O ON CHANNEL
	JSB	G^IOC$CANCELIO		;TEST IF FUNCTION SHOULD BE CANCELLED
	BBC	#UCB$V_CANCEL,UCB$W_STS(R5),30$ ;IF CLR, NO CANCEL PENDING
	DSBINT				;DISABLE INTERRUPTS
	BBC	#UCB$V_MT_PWRFL,-	; See if currently repositioning tape
		UCB$W_DEVSTS(R5),5$	;  due to POWERFAIL.  If NOT, branch around
	BISW	#UCB$M_MT_CNCLP,-	; If SO, set CANCEL PENDING flag on.
		UCB$W_DEVSTS(R5)	;  This bit is needed only if the driver
					;   thread in POWERFAIL is currently
					;   not waiting for an interrupt.  That
					;   would imply that the driver thread
					;   is on a resource wait queue and
					;   would have to abort the operation
					;   itself.

	BITW	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; Interrupt or timeout expected?
	BEQL	20$			; If NOT, branch around and let CANCEL
					;  PENDING flag advise repositioning
					;  thread of the need to ABORT operation.

	BICW	#UCB$M_MT_PWRFL!UCB$M_MT_CNCLP,-
		UCB$W_DEVSTS(R5)	; Here we are awaiting interrupt; so
					;  we can safely kill the driver thread.

	MOVL	UCB$L_CRB(R5),R0	; R0 => CRB.
	ASSUME	IDB$L_CSR  EQ  0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0	; R0 => TM03 CSR.

	PUSHL	MT_TC(R0)			; Save currently selected drive.
	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R0)	; Select this drive.
	MOVL	MT_DS(R0),R1			; Get this drive's status.
	POPL	MT_TC(R0)			; Restore selected drive.

	BBS	#MT_DS_V_PIP,R1,13$	; Branch if tape is moving and thereby
					;  assume that it is rewinding.
	BICW	#UCB$M_MT_REWIND,-	; Else since it is not moving, clear
		UCB$W_DEVSTS(R5)	;  rewind in progress flag and
	BRB	16$			; Branch around.
5$:
	CMPB	#CDF_REWIND,UCB$B_CEX(R5) ;REWIND IN PROGRESS?
	BEQL	10$			;IF EQL YES
	CMPB	#CDF_READPRESET,UCB$B_CEX(R5) ;READIN PRESET?
	BEQL	10$			; If EQL yes.
	BBC	#UCB$V_MT_REWIND,-	; Is a REWIND in progress?
		UCB$W_DEVSTS(R5),20$	;  If NOT, branch around.
10$:	BITW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;INTERRUPT OR TIMEOUT EXPECTED?
	BEQL	20$			;IF EQL NO
13$:
	BISW	#UCB$M_MT_REWIND,UCB$W_DEVSTS(R5) ;SET REWIND IN PROGRESS
16$:
	BICW	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; Clear interrupt and timeout expected
					;  and thereby kill driver thread.
	SETIPL	UCB$B_FIPL(R5)		;LOWER TO FORK LEVEL
	MOVZWL	#SS$_ABORT,R0		;SET ABORT STATUS
	PUSHL	R4			;SAVE CURRENT PROCESS PCB ADDRESS
	BSBW	STSXIT			;FINISH I/O OPERATION
	POPL	R4			;RESTORE CURRENT PROCESS PCB ADDRESS
20$:	ENBINT				;LOWER TO FORK LEVEL
30$:	RSB				;
	.PAGE
	.SBTTL	START I/O OPERATION
;+
; TM_STARTIO - START I/O OPERATION ON DEVICE UNIT
;
; THIS ENTRY POINT IS ENTERED TO START AN I/O OPERATION ON A DEVICE UNIT.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O PACKET.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	FUNCTION DEPENDENT PARAMETERS ARE STORED IN THE DEVICE UCB, THE ERROR
;	RETRY COUNT IS RESET, AND THE FUNCTION IS EXECUTED. AT FUNCTION COMPLETION
;	THE OPERATION IS TERMINATED THROUGH REQUEST COMPLETE.
;-

TM_STARTIO:				;START I/O OPERATION
	MOVL	UCB$L_MT_RECORD(R5),-	; Remember tape position at STARTIO.
		UCB$L_MT_ORGPOS(R5)
	MOVB	UCB$B_ERTMAX(R5),UCB$B_ERTCNT(R5) ;INITIALIZE ERROR RETRY COUNT
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5) ;SAVE FUNCTION CODE AND MODIFIERS
	MNEGW	#1,UCB$W_MT_SPACNT(R5)	;SET DEFAULT SPACING COUNT
	MOVL	IRP$L_MEDIA(R3),R0	;GET PARAMETER LONGWORD

;
; MOVE FUNCTION DEPENDENT PARAMETERS TO UCB
;

	EXTZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;EXTRACT I/O FUNCTION CODE
		IRP$W_FUNC(R3),R1	;
	CMPL	#IO$_SPACEFILE,R1	;SPACE FILE FUNCTION?
	BEQL	10$			;IF EQL YES
	CMPL	#IO$_SPACERECORD,R1	;SPACE RECORD FUNCTION?
	BEQL	20$			;IF EQL YES
	CMPL	#IO$_SETCHAR,R1		;SET CHARACTERISTICS FUNCTION?
	BEQL	50$			;IF EQL YES
	CMPL	#IO$_AVAILABLE,R1	;AVAILABLE function?
	BEQL	75$			;IF EQL YES
	CMPL	#IO$_READPBLK+1,R1	;DISJOINT FUNCTION CODE?
	BGTRU	100$			;IF GTRU NO
	CASE	R1,<-			;DISPATCH LOGICAL FUNCTIONS
		70$,-			;REWIND AND SET OFFLINE
		60$,-			;SET MODE
		80$,-			;REWIND
		10$,-			;SKIP FILE
		20$,-			;SKIP RECORD
		90$,-			;SENSE TAPE MODE
		90$,-			;WRITE EOF
		>,LIMIT=#IO$_REWINDOFF ;
	SUBW	#IO$_READPRESET-IO$_READPBLK-4,R1 ;CONVERT TO DENSE FUNCTION CODE
	BRB	110$			;

;
; SPACE FILE FUNCTION - SET SPACE COUNT AND PROPER FUNCTION
;

10$:	MOVZBL	#CDF_SPCFILFOR,R1	;SET FOR SPACE FILE FORWARD
	INCW	UCB$W_MT_SPACNT(R5)	;SET DEFAULT SPACING COUNT TO LARGEST VALUE
	TSTW	R0			;SPACE FILE FORWARD?
	BGTR	40$			;IF GTR YES
	MOVZBL	#CDF_SPCFILREV,R1	;SET FOR SPACE FILE REVERSE
	BRB	30$			;

;
; SPACE RECORD FUNCTION - SET SPACE COUNT AND PROPER FUNCTION
;

20$:	MOVZBL	#CDF_SPCRECFOR,R1	;SET FOR SPACE RECORD FORWARD
	MNEGW	R0,UCB$W_MT_SPACNT(R5)	;SET SPACING COUNT
	BLSS	40$			;IF LSS SPACE FORWARD FUNCTION
	MOVZBL	#CDF_SPCRECREV,R1	;SET FOR SPACE RECORD REVERSE
	MOVW	R0,UCB$W_MT_SPACNT(R5)	;SET SPACING COUNT
30$:	MNEGW	R0,R0			;CONVERT TO POSITIVE COUNT
40$:	MOVW	R0,UCB$W_BOFF(R5)	;SET SPACE COUNT
	MOVW	R0,UCB$W_BCNT(R5)	;SET SPACE COUNT
	BNEQ	110$			;IF NEQ SPACING REQUIRED
	MOVZBL	#CDF_NOP,R1		;SET FOR NO OPERATION
	BRB	110$			;

;
; SET CHARACTERISTICS FUNCTION - STORE NEW TAPE CHARACTERISTICS
;

50$:	MOVW	IRP$L_MEDIA(R3),UCB$B_DEVCLASS(R5) ;SET NEW DEVICE CLASS AND TYPE

;
; SET MODE FUNCTION - STORE NEW TAPE MODE
;

60$:	MOVW	IRP$L_MEDIA+2(R3),UCB$W_DEVBUFSIZ(R5) ;SET NEW DEFAULT BUFFER SIZE
	MOVW	IRP$L_MEDIA+4(R3),UCB$W_BOFF(R5) ;SAVE NEW TAPE CONTROL PARAMETERS
	MOVZBL	#CDF_SETCHAR,R1		;SET FUNCTION DISPATCH INDEX
	BRB	110$			;

;
; LOGICAL REWIND AND SET TAPE OFFLINE - CONVERT TO UNLOAD FUNCTION
;

70$:	MOVZBL	#CDF_UNLOAD,R1		;SET FOR UNLOAD FUNCTION
	BRB	110$			;

;
; AVAILABLE FUNCTION - Equivalent of REWIND(NOWAIT) and clear of UCB$M_VALID.
;

75$:
	MOVW	#IO$_REWIND!IO$M_NOWAIT,-; Simulate a REWIND NOWAIT.
		UCB$W_FUNC(R5)
	BICW	#UCB$M_VALID,-		 ; And clear valid bit.
		UCB$W_STS(R5)		 ;  and fall thru to rewind logic.

;
; LOGICAL REWIND FUNCTION - CONVERT TO PHYSICAL FUNCTION
;

80$:	MOVZBL	#CDF_REWIND,R1		;SET FOR REWIND FUNCTION
	BRB	110$			;

;
; LOGICAL WRITE EOF OR SENSE MODE FUNCTION - CONVERT TO PHYSICAL FUNCTION
;

90$:	SUBW	#IO$_SENSEMODE-IO$_READPBLK-6,R1 ;CONVERT TO PHYSICAL FUNCTION
	BRB	110$			;

;
; DENSE FUNCTION CODE - CHECK FOR READ, WRITE, OR WRITECHECK FUNCTION
;

100$:	CMPL	#IO$_WRITECHECK,R1	;DATA TRANSFER FUNCTION?
	BGTRU	110$			;IF GTRU NO
	BBC	#IO$V_REVERSE,UCB$W_FUNC(R5),110$ ;IF CLR, NOT REVERSE FUNCTION
	ADDW	#CDF_WRITECHECKR-CDF_WRITECHECK,R1 ;CONVERT TO REVERSE FUNCTION

;
; FINISH PREPROCESSING
;

110$:	MOVB	R1,UCB$B_FEX(R5)	;SAVE FUNCTION DISPATCH INDEX

;
; CENTRAL FUNCTION DISPATCH
;

FDISPATCH:				;FUNCTION DISPATCH
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	BBS	#IRP$V_PHYSIO,IRP$W_STS(R3),10$ ;IF SET, PHYSICAL I/O FUNCTION
	BBS	#UCB$V_VALID,UCB$W_STS(R5),10$ ;IF SET, VOLUME SOFTWARE VALID
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	RESETXFR		;

;
; UNIT IS SOFTWARE VALID OR FUNCTION IS PHYSICAL I/O
;

10$:	REQPCHAN			;REQUEST PRIMARY I/O CHANNEL
	MOVL	R4,R3			;SAVE ADDRESS OF TM03/DRIVE REGISTERS
	MOVL	UCB$L_CRB(R5),R4	;GET ADDRESS OF CRB
	MOVL	CRB$L_LINK(R4),R4	;GET ADDRESS OF SECONDARY CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4 ;GET ADDRESS OF MBA CSR
20$:	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),30$ ;IF SET, POWER FAILED
	BBC	#UCB$V_MT_REWIND,UCB$W_DEVSTS(R5),30$ ;IF CLR, NO REWIND IN PROGRESS
	WFIKPCH	TIMEOUT,#60*7		;WAITFOR REWIND TO COMPLETE
	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R3) ;SELECT DRIVE
	MOVL	MT_DS(R3),R2		;READ DRIVE STATUS
	BBS	#MT_DS_V_PIP,R2,20$	;IF SET, POSITIONING IN PROGRESS
	BBC	#MT_DS_V_BOT,R2,20$	;IF CLR, NOT AT BEGINNING OF TAPE
	IOFORK				;CREATE FORK PROCESS
	SAVIPL				;SAVE CURRENT IPL
30$:	ENBINT				;ENABLE INTERRUPTS
	MOVZBL	UCB$B_FEX(R5),R0	;GET DISPATCH FUNCTION CODE
	CASE	R0,<-			;DISPATCH TO FUNCTION HANDLING ROUTINE
		NOP,-			;NO OPERATION
		UNLOAD,-		;UNLOAD VOLUME
		SPCFILFOR,-		;SPACE FILE FORWARD
		REWIND,-		;REWIND
		DRVCLR,-		;DRIVE CLEAR
		SPCFILREV,-		;SPACE FILE REVERSE
		ERASE,-			;ERASE TAPE
		SPCRECREV,-		;SPACE RECORD REVERSE
		PACKACK,-		;PACK ACKNOWLEDGE
		SPCRECFOR,-		;SPACE RECORD FORWARD
		WRITECHECK,-		;WRITE CHECK FORWARD
		WRITEDATA,-		;WRITE DATA FORWARD
		READDATA,-		;READ DATA FORWARD
		WRITECHECKR,-		;WRITE CHECK REVERSE
		WRITEDATA,-		;WRITE DATA FORWARD
		READDATAR,-		;READ DATA REVERSE
		READPRESET,-		;READ IN PRESET
		SETCHAR,-		;SET TAPE CHARACTERISTICS
		SENSECHAR,-		;SENSE TAPE CHARACTERISTICS
		>			;
	.PAGE
	.SBTTL	WRITE TAPE MARK FUNCTION
;
; WRITE TAPE MARK FUNCTION
;

WRITEMARK:				;WRITE TAPE MARK
5$:	EXFUNC	10$,F_WRITEMARK		;EXECUTE FUNCTION
	INCL	UCB$L_MT_RECORD(R5)	;UPDATE TAPE POSITION
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BRW	FUNCXT			;

;
; FUNCTION ENDED IN AN ERROR
;
; THE ERROR COULD BE A NONFATAL CONTROLLER OR DRIVE ERROR. FATAL ERRORS TERMINATE
; THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL CONTROLLER ERRORS ARE:
;
;	ERCONF	= ERROR CONFIRMATION.
;	ISTO	= INTERFACE SEQUENCE TIMEOUT.
;	PGE	= PROGRAMMING ERROR.
;	NED	= NONEXISTENT DRIVE.
;	RDTO	= READ DATA TIMEOUT.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION.
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	FMT	= FORMAT.
;	DPAR	= DATA BUS PARITY.
;	FCE	= FRAME COUNT.
;	DTE	= DRIVE TIMING.
;	COR/CRC	= CORRECTABLE OR CHECK CHARACTER ERROR.
;
; NOTE THAT IT IS ASSUMED THAT MASSBUS EXCEPTION (MBEXC) WILL OCCUR ONLY IN
; COMBINATION WITH ANOTHER DRIVE OR CONTROLLER ERROR.
;

10$:	TESTR	20$			;TEST REMAINING RETRIES
	REQSCHAN			;REQUEST SECONDARY CHANNEL
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	RELSCHAN			;RELEASE SECONDARY CHANNEL
20$:	BBS	#IO$V_INHEXTGAP,UCB$W_FUNC(R5),30$ ;IF SET, NO EXTENDED GAPS
	EXFUNC	DOUBLE,F_ERASE		;WRITE EXTENDED INTER-RECORD GAP
30$:	BRB	5$			;
	.PAGE
	.SBTTL	ERASE TAPE FUNCTION
;
; ERASE TAPE FUNCTION
;

ERASE:					;ERASE TAPE
	EXFUNC	10$			;EXECUTE FUNCTION
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION
	CLRW	UCB$W_MT_FC(R5)		;CLEAR FRAME COUNT
	BRW	FUNCXT			;

;
; FUNCTION ENDED IN AN ERROR
;
; THE ERROR COULD BE A NONFATAL CONTROLLER OR DRIVE ERROR. FATAL ERRORS TERMINATE
; THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL CONTROLLER ERRORS ARE:
;
;	ERCONF	= ERROR CONFIRMATION.
;	ISTO	= INTERFACE SEQUENCE TIMEOUT.
;	PGE	= PROGRAMMING ERROR.
;	NED	= NONEXISTENT DRIVE.
;	RDTO	= READ DATA TIMEOUT.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION.
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	FMT	= FORMAT.
;	DPAR	= DATA BUS PARITY.
;	INC/VPE	= INCORRECTABLE OR VERTICLE PARITY ERROR.
;	PEF/LRC	= FORMAT (PE) OR LONGITUDINAL PARITY ERROR.
;	NSG	= NONSTANDARD GAP.
;	FCE	= FRAME COUNT.
;	DTE	= DRIVE TIMING.
;	OPI	= OPERATION INCOMPLETE.
;	COR/CRC	= CORRECTABLE OR CHECK CHARACTER ERROR.
;

10$:	TSTL	UCB$L_MT_RECORD(R5)	;ANY RECORDS ON TAPE?
	BNEQ	20$			;IF NEQ YES
	EXFUNC	DOUBLE,F_REWIND		;REWIND TAPE
	BRB	30$			;
20$:	REQSCHAN			;REQUEST SECONDARY CHANNEL
	EXFUNC	DOUBLE,F_INTSPCREV	;BACK SPACE RECORD
	EXFUNC	DOUBLE,F_INTSPCFOR	;SPACE RECORD FORWARD
	RELSCHAN			;RELEASE SECONDARY CHANNEL
30$:	BRW	RETRY			;
	.PAGE
	.SBTTL	HOUSEKEEPING FUNCTIONS
;
; HOUSEKEEPING FUNCTIONS INCLUDE:
;
;	PACK ACKNOWLEDGE,
;	NO OPERATION,
;	DRIVE CLEAR,
;	SENSE TAPE CHARACTERISTICS, AND
;	SET TAPE CHARACTERISTICS.
;
; IF THE FUNCTION ENDS IN A NONFATAL DRIVE ERROR IT IS RETRIED. FATAL ERRORS
; TERMINATE THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION (EXCEPT FOR DRIVE CLEAR).
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	FMT	= FORMAT.
;	DPAR	= DATA BUS PARITY.
;	INC/VPE	= INCORRECTABLE OR VERTICLE PARITY ERROR.
;	PEF/LRC	= FORMAT (PE) OR LONGITUDINAL PARITY ERROR.
;	NSG	= NONSTANDARD GAP.
;	FCE	= FRAME COUNT.
;	CS/ITM	= CORRECTABLE SKEW OR INVALID TAPE MARK.
;	DTE	= DRIVE TIMING.
;	OPI	= OPERATION INCOMPLETE.
;	COR/CRC	= CORRECTABLE OR CHECK CHARACTER ERROR.
;
; ADDITIONAL IGNORED DRIVE ERRORS FOR DRIVE CLEAR ARE:
;
;	NEF	= NONEXECUTABLE FUNCTION.
;
; PACK ACKNOWLEDGE
;

	.ENABL	LSB
PACKACK:				;PACK ACKNOWLEDGE
	EXFUNC	RETRY			;EXECUTE FUNCTION
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME SOFTWARE VALID
	BRB	30$			;

;
; NO OPERATION, SENSE CHARACTERISTICS, AND DRIVE CLEAR.
;

NOP:					;NO OPERATION
SENSECHAR:				;SENSE CHARACTERISTICS
DRVCLR:					;DRIVE CLEAR
	EXFUNC	RETRY			;EXECUTE HOUSEKEEPING FUNCTION
	BRB	30$			;

;
; SET TAPE CHARACTERISTICS
;

SETCHAR:				;SET TAPE CHARACTERISTICS
	EXFUNC	RETRY			;EXECUTE FUNCTION
	EXTZV	#MT$V_DENSITY,#MT$S_DENSITY,- ;EXTRACT DENSITY CODE
		UCB$W_BOFF(R5),R0	;
	MULL	#4,R0			;CALCULATE BIT NUMBER
	EXTZV	R0,#4,DENSITY,R0	;EXTRACT DENSITY CODE
	EXTZV	#MT$V_FORMAT,#MT$S_FORMAT,- ;EXTRACT FORMAT CODE
		UCB$W_BOFF(R5),R1	;
	MULL	#4,R1			;CALCULATE BIT NUMBER
	EXTZV	R1,#4,FORMAT,R1		;EXTRACT FORMAT CODE
	MOVZWL	#MT$M_FORMAT,R3		;SET INITIAL MASK WORD
	BBC	#MT_DS_V_BOT,R2,10$	;IF CLR, TAPE NOT AT BEGINNING

;
; TAPE DENSITY CAN ONLY BE SET WHEN THE SELECTED DRIVE IS AT BEGINNING OF TAPE
;

	INSV	R0,#MT_TC_V_DEN,-	;SET NEW DENSITY
		#MT_TC_S_DEN,UCB$W_MT_TC(R5) ;
	BISW	#MT$M_DENSITY,R3	;SET DENSITY MASK BITS
10$:	BICW	#MT_TC_M_EPAR,UCB$W_MT_TC(R5) ;CLEAR EVEN PARITY
	BICW	#MT$M_PARITY,UCB$L_DEVDEPEND(R5) ;CLEAR EVEN PARITY
	BBS	#MT_TC_V_DEN+2,UCB$W_MT_TC(R5),20$ ;IF SET, PHASE ENCODED TAPE

;
; TAPE PARITY CAN ONLY BE SET IF NRZI FORMATTED TAPE IS BEING READ OR WRITTEN
;

	BBC	#MT$V_PARITY,UCB$W_BOFF(R5),20$ ;IF CLR, ODD PARITY
	BISW	#MT_TC_M_EPAR,UCB$W_MT_TC(R5) ;SET EVEN PARITY
	BISW	#MT$M_PARITY,R3		;SET PARITY MASK BIT
20$:	INSV	R1,#MT_TC_V_FSEL,-	;SET NEW FORMAT
		#MT_TC_S_FSEL,UCB$W_MT_TC(R5) ;
	BICW	R3,UCB$L_DEVDEPEND(R5)	;CLEAR OLD FIELD VALUES
	MCOML	R3,R3			;COMPLEMENT MASK
	BICW	R3,UCB$W_BOFF(R5)	;CLEAR FIELDS NOT BE BE INSERTED
	BISW	UCB$W_BOFF(R5),UCB$L_DEVDEPEND(R5) ;INSERT NEW FIELD VALUES
30$:	CLRW	UCB$W_MT_FC(R5)		;CLEAR SAVED FRAME COUNT REGISTER
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION
	BRW	FUNCXT			;
	.DSABL	LSB
	.PAGE
	.SBTTL	REWIND AND UNLOAD FUNCTIONS
;
; REWIND AND UNLOAD FUNCTIONS INCLUDE:
;
;	READIN PRESET,
;	REWIND, AND
;	UNLOAD.
;
; IF THE FUNCTION ENDS WITH A NONFATAL DRIVE ERRORS IT IS RETRIED. FATAL ERRORS
; TERMINATE THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION.
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	FMT	= FORMAT.
;	DPAR	= DATA BUS PARITY.
;	INC/VPE	= INCORRECTABLE OR VERTICLE PARITY ERROR.
;	PEF/LRC	= FORMAT (PE) OR LONGITUDINAL PARITY ERROR.
;	NSG	= NONSTANDARD GAP.
;	FCE	= FRAME COUNT.
;	CS/ITM	= CORRECTABLE SKEW OR INVALID TAPE MARK.
;	DTE	= DRIVE TIMING.
;	OPI	= OPERATION INCOMPLETE.
;	COR/CRC	= CORRECTABLE OR CHECK CHARACTER ERROR.
;

READPRESET:				;READ IN PRESET
	TSTW	UCB$W_UNIT(R5)		;UNIT ZERO?
	BEQL	REWIND			;IF EQL YES
	MOVZBL	#CDF_REWIND,R0		;CONVERT FUNCTION TO REWIND

;
; UNLOAD AND REWIND FUNCTIONS
;

REWIND:					;REWIND TO BEGINNING OF TAPE
UNLOAD:					;UNLOAD VOLUME
	CLRL	UCB$L_MT_RECORD(R5)	; Since we will REWIND, the current
					;  position is of no interest.
					; This insures that UCB$L_MT_RECORD will
					;  be correct if we do a REWIND nowait.
	CLRL	UCB$L_MT_ORGPOS(R5)	; With REWIND the original position
					;  is of no interest.  If we should
					;  get a POWERFAIL this will reset us
					;  to BOT before retrying.
	EXFUNC	LOSTPOS			;EXECUTE FUNCTION
	CLRW	UCB$W_MT_FC(R5)		;CLEAR SAVED FRAME COUNT REGISTER
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BBS	#MT_DS_V_MOL,R2,10$	;IF SET, MEDIUM ONLINE
	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME SOFTWARE INVALID
10$:	BRW	FUNCXT			;
	.PAGE
	.SBTTL	SPACING FUNCTIONS
;
; SPACING FUNCTIONS INCLUDE:
;
;	SPACE FILE FORWARD,
;	SPACE FILE REVERSE,
;	SPACE RECORD FORWARD, AND
;	SPACE RECORD REVERSE.
;
; ALL ARE IMPLEMENTED VIA THE SPACE RECORD FUNCTIONS.
;
; A SPACING FUNCTION CAN END WITH A NONFATAL DRIVE ERROR. FATAL ERRORS TERMINATE
; THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION (FORWARD FUNCTIONS).
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; NONFATAL DRIVE ERRORS ARE:
;
;	CPAR	= CONTROL BUS PARITY.
;	FCE	= FRAME COUNT.
;	NEF	= NONEXECUTABLE FUNCTION (REVERSE FUNCTIONS INTO BEGINNING OF TAPE).
;	OPI	= OPERATION INCOMPLETE (REVERSE FUNCTIONS INTO BEGINNING OF TAPE).
;
; IGNORED DRIVE ERRORS ARE:
;
;	FMT	= FORMAT.
;	DPAR	= DATA BUS PARITY.
;	INC/VPE	= INCORRECTABLE OR VERTICLE PARITY ERROR.
;	PEF/LRC	= FORMAT (PE) OR LONGITUDINAL PARITY ERROR.
;	NSG	= NONSTANDARD GAP.
;	CS/ITM	= CORRECTABLE SKEW OR INVALID TAPE MARK.
;	DTE	= DRIVE TIMING.
;	COR/CRC	= CORRECTABLE OR CHECK CHARACTER ERROR.
;
; SPACE FILE FORWARD
;
;	SPACING FILES IS ACCOMPLISHED BY SPACING A VERY LARGE NUMBER OF RECORDS.
;	IF THE RECORD SPACING OPERATION COMPLETES WITHOUT ERROR, THEN THE RECORD
;	COUNT IS INCREASED BY 65,536 AND THE SPACING OPERATION IS CONTINUED.
;
;	SEVERAL SPECIAL CONDITIONS CAN ARISE DURING A SPACE FILE FORWARD:
;
;		1. A CONTROL BUS PARITY ERROR OCCURS.
;
;			THE OPERATION IS MERELY RETRIED SINCE TAPE MOTION COULD
;			NOT HAVE OCCURED.
;
;		2. AN END OF TAPE IS ENCOUNTERED WITHOUT AN END OF FILE.
;
;			THE OPERATION IS CONTINUED SINCE END OF TAPE WHILE FILE
;			SKIPPING DOES NOT TERMINATE THE OPERATION.
;
;		3. AN END OF FILE IS ENCOUNTERED.
;
;			THE FILE SKIP COUNT IS DECREMENTED AND IF NONZERO, THE
;			OPERATION IS CONTINUED.
;
;	UNLESS A HARD ERROR IS ENCOUNTERED, NORMAL COMPLETION IS ALWAYS RETURNED
;	FOR A SKIP FILE FORWARD FUNCTION.
;
;	AS RECORDS ARE SKIPPED FORWARD ON THE TAPE, THE CURRENT TAPE POSITION IS
;	MAINTAINED BY ADDING THE NUMBER OF RECORDS AND TAPE MARKS SKIPPED OVER.
;

SPCFILFOR:				;SPACE FILE FORWARD
;
; Before proceeding with the SKIP function, we backspace one tape position
;	(be it record or TAPEMARK) and then forward space one position to
;	determine if we are currently positioned immediately after a
;	TAPEMARK.  If so we record the current position in UCB$L_MT_PREVTM.
;	If we are not currently at a TAPEMARK, we move negative 2 to
;	UCB$L_MT_PREVTM.
;

	MNEGL	#2,R0				; Initialize R0 = -2.
	ASHL	#31-MT_DS_V_BOT,MT_DS(R3),R2	; See if at BOT.
	BLSS	4$				; LSS implies at BOT.
	TSTL	UCB$L_MT_RECORD(R5)	; If NOT at physical BOT see if at logical
					;  BOT.
	BEQL	4$			; EQL implies logical BOT.

	MOVW	UCB$W_MT_SPACNT(R5),-	; Copy spacing parameter to safe
		UCB$L_MT_PREVTM(R5)	;  keeping place.
	MNEGW	#1,UCB$W_MT_SPACNT(R5)	; Indicate that we will backspace 1 position.
	EXFUNC	1$,F_SPCRECREV		; Backspace 1 tape position.
1$:	CHECK_ERROR
	DECL	UCB$L_MT_RECORD(R5)	; Update tape position marker.

	MNEGW	#1,UCB$W_MT_SPACNT(R5)	; Now we will forward space 1 position.
	EXFUNC	2$,F_SPCRECFOR		; Forward space 1 tape position.
2$:	CHECK_ERROR
	INCL	UCB$L_MT_RECORD(R5)	; Update tape position marker.
	MNEGL	#2,R0			; R0 = -2 which would imply that we are
					;  not immediately past a TAPEMARK.
	BBC	#MT_DS_V_TM,R2,3$	; And if we are NOT at TAPEMARK, branch.
	MOVL	UCB$L_MT_RECORD(R5),R0	; Else R0 = current tape position.
3$:
	MOVW	UCB$L_MT_PREVTM(R5),-	; Restore previous value to
		UCB$W_MT_SPACNT(R5)	;  UCB$W_MT_SPACNT.
4$:	MOVL	R0,UCB$L_MT_PREVTM(R5)	; Initialize previous TAPEMARK indicator.
5$:	EXFUNC	10$,F_SPCFILFOR		;EXECUTE FUNCTION
	INCW	UCB$L_MT_RECORD+2(R5)	;UPDATE TAPE POSITION
	BRB	5$			;
10$:	CHECK_ERROR			;CHECK FOR FATAL OF RETRIABLE ERROR
	MOVZWL	UCB$W_MT_FC(R5),R0	;GET NUMBER OF RECORDS SKIPPED OVER
	ADDL	R0,UCB$L_MT_RECORD(R5)	;UPDATE TAPE POSITION
	BBC	#MT_DS_V_TM,R2,5$	;IF CLR, TAPE MARK NOT ENCOUNTERED
	DECW	UCB$W_BOFF(R5)		;DECREMENT NUMBER OF FILES TO SKIP
	SUBL3	UCB$L_MT_PREVTM(R5),-
		UCB$L_MT_RECORD(R5),R0	; R0 = distance between last 2 TAPEMARKs
	MOVL	UCB$L_MT_RECORD(R5),-
		UCB$L_MT_PREVTM(R5)	; Remember position of this TAPEMARK
	BBC	#DEV$V_MNT,-
		UCB$L_DEVCHAR(R5),20$	; If NOT mounted, go test for EOV.
	BBC	#DEV$V_FOR,-
		UCB$L_DEVCHAR(R5),30$	; If mounted NOT foreign (i.e. the ACP
					;  is involved) branch around test EOV.

20$:	; If here volume is either NOT mounted or mounted FOREIGN.

	DECL	R0			; See if last 2 TAPEMARKs adjacent
	BEQL	40$			; EQL implies adjacent TAPEMARKs

30$:	; If here either ANSI mounted tape or EOV test failed.

	TSTW	UCB$W_BOFF(R5)		; See if we have more TAPEMARKs to skip
	BNEQ	5$			;IF NEQ MORE TO GO
	BRW	NORXIT			;
40$:	BRW	SETEOV			; Branch around to return ENDOFVOLUME status

;
; SPACE FILE REVERSE
;
;	SPACING FILES IS ACCOMPLISHED BY SPACING A VERY LARGE NUMBER OF RECORDS.
;	IF THE RECORD SPACING OPERATION COMPLETES WITHOUT ERROR, THE THE RECORD
;	COUNT IS REDUCED BY 65,536 AND THE SPACING OPERATION IS CONTINUED.
;
;	SEVERAL SPECIAL CONDITIONS CAN ARISE DURING A SPACE FILE REVERSE:
;
;		1. A CONTROL BUS PARITY ERROR OCCURS.
;
;			THE OPERATION IS MERELY RETRIED SINCE TAPE MOTION COULD
;			NOT HAVE OCCURED.
;
;		2. AN END OF TAPE IS ENCOUNTERED WITHOUT AN END OF FILE.
;
;			THE OPERATION IS CONTINUED SINCE END OF TAPE WHILE FILE
;			SKIPPING DOES NOT TERMINATE THE OPERATION.
;
;		3. A BEGINNING OF TAPE IS ENCOUNTERED.
;
;			THE OPERATION IS IMMEDIATELY TERMINATED.
;
;		4. AN END OF FILE IS ENCOUNTERED.
;
;			THE FILE SKIP COUNT IS DECREMENTED AND IF NONZERO, THE
;			OPERATION IS CONTINUED.
;
;	UNLESS A HARD ERROR IS ENCOUNTERED, NORMAL COMPLETION IS ALWAYS RETURNED
;	FOR A SKIP FILE REVERSE OPERATION.
;
;	AS RECORDS ARE SKIPPED BACKWARDS ON THE TAPE, THE CURRENT TAPE POSITION
;	IS MAINTAINED BY SUBTRACTING THE NUMBER RECORDS AND TAPE MARKS SKIPPED
;	OVER.
;

SPCFILREV:				;SPACE FILE REVERSE
	EXFUNC	10$,F_SPCFILREV		;EXECUTE FUNCTION
	DECW	UCB$L_MT_RECORD+2(R5)	;UPDATE RECORD POSITION
	BRB	SPCFILREV		;
10$:	CHECK_ERROR			;CHECK FOR FATAL OR RETRIABLE ERROR
	MOVZWL	UCB$W_MT_FC(R5),R0	;GET NUMBER OF RECORDS SKIPPED OVER
	SUBL	R0,UCB$L_MT_RECORD(R5)	;UPDATE TAPE POSITION
	BITW	#MT_DS_M_BOT!MT_DS_M_TM,R2 ;NOT AT BOT AND NO TAPE MARK ENCOUNTERED?
	BEQL	SPCFILREV		;IF EQL YES
	BBS	#MT_DS_V_BOT,R2,20$	;IF SET, BEGINNING OF TAPE
	DECW	UCB$W_BOFF(R5)		;ANY MORE FILES TO SKIP?
	BNEQ	SPCFILREV		;IF NEQ YES
20$:	BRW	NORXIT			;

;
; SPACE RECORD FORWARD
;
;	SEVERAL SPECIAL CONDITIONS CAN ARISE DURING A SPACE FORWARD:
;
;		1. A CONTROL BUS PARITY ERROR OCCURS.
;
;			THE OPERATION IS MERELY RETRIED SINCE TAPE MOTION COULD
;			NOT HAVE OCCURED.
;
;		2. AN END OF TAPE IS ENCOUNTERED WITHOUT AN END OF FILE.
;
;			THE OPERATION IS TERMINATED WITH A FINAL STATUS OF END OF
;			TAPE.
;
;		3. AN END OF FILE IS ENCOUNTERED.
;
;			THE OPERATION IS TERMINATED WITH A FINAL STATUS OF END OF
;			FILE.
;
;	UNLESS A HARD ERROR IS ENCOUNTERED, THE CURRENT TAPE POSITION IS MAINTAINED
;	BY ADDING THE TOTAL NUMBER OF RECORDS SKIPPED OVER.
;

SPCRECFOR:				;SPACE RECORD FORWARD
;
; Before proceeding with the SKIP function, we backspace one tape position
;	(be it record or TAPEMARK) and then forward space one position to
;	determine if we are currently positioned immediately after a
;	TAPEMARK.  If so we record the current position in UCB$L_MT_PREVTM.
;	If we are not currently at a TAPEMARK, we move negative 2 to
;	UCB$L_MT_PREVTM.
;

	MNEGL	#2,R0				; Initialize R0 = -2.
	ASHL	#31-MT_DS_V_BOT,MT_DS(R3),R2	; See if at BOT.
	BLSS	4$				; LSS implies at BOT.
	TSTL	UCB$L_MT_RECORD(R5)	; If NOT at physical BOT see if at logical
					;  BOT.
	BEQL	4$			; EQL implies logical BOT.

	MOVW	UCB$W_MT_SPACNT(R5),-	; Copy spacing parameter to safe
		UCB$L_MT_PREVTM(R5)	;  keeping place.
	MNEGW	#1,UCB$W_MT_SPACNT(R5)	; Indicate that we will backspace 1 position.
	EXFUNC	1$,F_SPCRECREV		; Backspace 1 tape position.
1$:	CHECK_ERROR
	DECL	UCB$L_MT_RECORD(R5)	; Update tape position marker.

	MNEGW	#1,UCB$W_MT_SPACNT(R5)	; Now we will forward space 1 position.
	EXFUNC	2$,F_SPCRECFOR		; Forward space 1 tape position.
2$:	CHECK_ERROR
	INCL	UCB$L_MT_RECORD(R5)	; Update tape position marker.
	MNEGL	#2,R0			; R0 = -2 which would imply that we are
					;  not immediately past a TAPEMARK.
	BBC	#MT_DS_V_TM,R2,3$	; And if we are NOT at TAPEMARK, branch.
	MOVL	UCB$L_MT_RECORD(R5),R0	; Else R0 = current tape position.
3$:
	MOVW	UCB$L_MT_PREVTM(R5),-	; Restore previous value to
		UCB$W_MT_SPACNT(R5)	;  UCB$W_MT_SPACNT.
4$:	MOVL	R0,UCB$L_MT_PREVTM(R5)	; Initialize previous TAPEMARK indicator.
	EXFUNC	10$,F_SPCRECFOR		;SPACE RECORD FORWARD
	BRB	20$			;
10$:	CHECK_ERROR			;CHECK FOR FATAL OR RETRIABLE ERROR
20$:	CLRL	R0			;CLEAR UPPER HALF OF REGISTER
	ADDW3	UCB$W_MT_FC(R5),UCB$W_BOFF(R5),R0 ;CALCULATE RECORDS SKIPPED
	ADDL	R0,UCB$L_MT_RECORD(R5)	;UPDATE TAPE POSITION
	MNEGW	UCB$W_MT_FC(R5),UCB$W_BOFF(R5) ;SET REMAINING RECORD SKIP COUNT
	BBC	#MT_DS_V_TM,R2,NORXIT	; If NOT at TAPEMARK, goto normal exit.
	BBC	#DEV$V_MNT,-		; If NOT mounted and at TAPEMARK,
		UCB$L_DEVCHAR(R5),30$	;  go test if at ENDOFVOLUME.
	BBC	#DEV$V_FOR,-		; If mounted ANSI (i.e NOT foreign),
		UCB$L_DEVCHAR(R5),SETEOF;  go to set EOF status.

30$: ; If here we are at TAPEMARK and the volume is either NOT mounted or
;		mounted foreign.

	SUBL3	UCB$L_MT_PREVTM(R5),-	; Calculate the distance between last
		UCB$L_MT_RECORD(R5),R0	;  two TAPEMARKs.
	DECL	R0			; See if last 2 TAPEMARKs adjacent.
	BEQL	SETEOV			; EQL implies ENDOFVOLUME.
	BRB	SETEOF			; If NOT EOV, then EOF.

;
; SPACE RECORD REVERSE
;
;	SEVERAL SPECIAL CONDITIONS CAN ARISE DURING A SPACE RECORD REVERSE:
;
;		1. A CONTROL BUS PARITY ERROR.
;
;			THE OPERATION IS MERELY RETRIED SINCE TAPE MOTION COULD
;			NOT HAVE OCCURED.
;
;		2. A BEGINNING OF TAPE IS ENCOUNTERED.
;
;			THE OPERATION IS TERMINATED WITH A FINAL STATUS OF END OF
;			FILE.
;
;		3. AN END OF TAPE IS ENCOUNTERED WITHOUT AN END OF FILE.
;
;			THE OPERATION IS CONTINUED SINCE AN END OF TAPE WHILE
;			SKIPPING RECORDS BACKWARDS DOES NOT TERMINATE THE OPER-
;			ATION.
;
;		4. AN END OF FILE IS ENCOUNTERED.
;
;			THE OPERATION IS TERMINATED WITH A FINAL STATUS OF END OF
;			FILE.
;
;	UNLESS A HARD ERROR IS ENCOUNTERED, THE CURRENT TAPE POSITION IS MAINTAINED
;	BY SUBTRACTING THE TOTAL NUMBER OF RECORDS SKIPPED OVER.
;

SPCRECREV:				;SPACE RECORD REVERSE
	EXFUNC	10$,F_SPCRECREV		;EXECUTE FUNCTION
	BRB	20$			;
10$:	CHECK_ERROR			;CHECK FOR FATAL OR RETRIABLE ERROR
20$:	CLRL	R0			;CLEAR UPPER HALF OF REGISTER
	ADDW3	UCB$W_MT_FC(R5),UCB$W_BOFF(R5),R0 ;CALCULATE RECORD SKIP COUNT
	SUBL	R0,UCB$L_MT_RECORD(R5)	;UPDATE TAPE POSITION
	MNEGW	UCB$W_MT_FC(R5),UCB$W_BOFF(R5) ;SET REMAINING RECORD SKIP COUNT
	MOVW	UCB$W_MT_FC(R5),UCB$W_MT_SPACNT(R5) ;RESET SPACING COUNT
	BBS	#MT_DS_V_TM,R2,SETEOF	;IF SET, END OF FILE ENCOUNTERED
	BEQL	NORXIT			;IF EQL ALL RECORDS SPACED OVER
	BBS	#MT_DS_V_BOT,R2,SETEOF	;IF SET, BEGINNING OF TAPE ENCOUNTERED
	BBS	#MT_DS_V_EOT,R2,SPCRECREV ;IF SET, AT END OF TAPE

;
; NORMAL SPACING FUNCTION EXIT
;

	.ENABL	LSB
NORXIT:	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BRB	10$			;

;
; Backspace over 2nd TAPEMARK and set ENDOFVOLUME return status
;

SETEOV:
	MNEGW	#1,UCB$W_MT_SPACNT(R5)	; Don't space back more than 1 tape position.
	EXFUNC	2$,F_SPCFILREV		; Backspace one tape position to
					;  position us between the two TAPEMARKs.
2$:	CHECK_ERROR			; Check for normal spacing errors.
	BBC	#MT_DS_V_TM,R2,4$	; If NOT at TAPEMARK, branch back to error.
	DECL	UCB$L_MT_RECORD(R5)	; Update position in UCB.
	INCW	UCB$W_BOFF(R5)		; Add one to total of files or
					;  records left to skip.
	MOVZWL	#SS$_ENDOFVOLUME,R0	; Set ENDOFVOLUME status
	BRB	10$			; Branch around to return
4$:	BRW	DOUBLE			; If not at a TAPEMARK, then error.

;
; SET EOF OF FILE STATUS
;

SETEOF:	MOVZWL	#SS$_ENDOFFILE,R0	;SET END OF FILE STATUS
10$:	SUBW3	UCB$W_BOFF(R5),UCB$W_BCNT(R5),- ;CALCULATE TOTAL NUMBER OF FILES
		UCB$W_MT_FC(R5)		;OR RECORDS SKIPPED OVER
	BRW	FUNCXT			;
	.DSABL	LSB
	.PAGE
	.SBTTL	READ DATA FORWARD AND WRITECHECK DATA FORWARD FUNCTIONS
;
; READ DATA FORWARD AND WRITECHECK DATA FORWARD FUNCTIONS
;

WRITECHECK:				;WRITE CHECK FORWARD
	BICW	#IO$M_DATACHECK,UCB$W_FUNC(R5) ;CLEAR DATA CHECK REQUEST
READDATA:				;READ DATA FORWARD
	REQSCHAN			;REQUEST SECONDARY I/O CHANNEL
5$:	MOVZBL	UCB$B_FEX(R5),R0	;RETRIEVE FUNCTION INDEX
	EXFUNC	20$			;EXECUTE FUNCTION
	BBS	#MT_DS_V_PES,-		; If at 1600 BPI, branch around test
		UCB$W_MT_DS(R5),10$	;  for minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;MINIMUM RECORD READ?
	BGTRU	5$			;IF GTRU NO
10$:	BBC	#IO$V_DATACHECK,UCB$W_FUNC(R5),50$ ;IF CLR, NO DATA CHECK
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	EXFUNC	20$,F_WRITECHECK	;WRITE CHECK DATA
	BRB	50$			;

;
; FUNCTION ENDED IN AN ERROR
;
; THE ERROR COULD BE A NONFATAL CONTROLLER OR DRIVE ERROR. FATAL ERRORS TERMINATE
; THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL CONTROLLER ERRORS ARE:
;
;	ERCONF	= ERROR CONFIRMATION.
;	ISTO	= INTERFACE SEQUENCE TIMEOUT.
;	PGE	= PROGRAMMING ERROR.
;	NED	= NONEXISTENT DRIVE.
;	RDTO	= READ DATA TIMEOUT.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION.
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	DPAR	= DATA BUS PARITY.
;
; NOTE THAT IT IS ASSUMED THAT MASSBUS EXCEPTION (MBEXC) WILL OCCUR ONLY IN
; COMBINATION WITH ANOTHER DRIVE OR CONTROLLER ERROR.
;

20$:	BITL	#MBA$M_SR_DLT!-		;DATA LATE OR,
		MBA$M_SR_INVMAP!-	;INVALID MAP REGISTER OR,
		MBA$M_SR_MAPPE!-	;MAP PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_MXF!-		;MISSED TRANSFER OR,
		MBA$M_SR_RDS,R1		;READ DATA SUBSTITUTE?
	BNEQ	80$			;IF NEQ YES
	BBS	#MT_DS_V_TM,R2,30$	;IF SET, TAPE MARK DETECTED
	BITW	#MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK UPPER BYTE?
	BNEQ	80$			;IF NEQ YES
30$:	BITW	#MT_ER_M_CPAR!-		;CONTROL BUS PARITY ERROR OR,
		MT_ER_M_DTE!-		;DRIVE TIMING ERROR OR,
		MT_ER_M_FMT!-		;FORMAT ERROR OR,
		MT_ER_M_INC!-		;INCORRECTABLE ERROR (PE) OR,
		MT_ER_M_LRC!-		;LONGITUDINAL PARITY ERROR (NRZI) OR,
		MT_ER_M_NSG!-		;NONSTANDARD GAP OR,
		MT_ER_M_OPI!-		;OPERATION INCOMPLETE OR,
		MT_ER_M_PEF!-		;FORMAT ERROR (PE) OR,
		MT_ER_M_VPE,R0		;VERTICLE PARITY ERROR (NRZI)?
	BNEQ	70$			;IF NEQ YES
	BBS	#MT_DS_V_PES,R2,40$	;IF SET, PHASE ENCODED TAPE
	BITW	#MT_ER_M_CRC!MT_ER_M_ITM,R0 ;CRC OR INVALID TAPE MARK?
	BNEQ	80$			;IF NEQ YES

;
; FRAME COUNT ERROR
;
; IF THE RECORD CONTAINED MORE BYTES THAN THE SPECIFIED BUFFER, THEN A DATA OVERRUN
; ERROR IS RETURNED. ELSE A CHECK IS MADE FOR END OF FILE AND IMPLICIT WRITECHECK.
;

40$:	MOVZWL	#SS$_DATAOVERUN,R0	;SET DATA OVER RUN STATUS
	CMPW	UCB$W_MT_FC(R5),UCB$W_BCNT(R5) ;DATA OVER RUN?
	BGTRU	60$			;IF GTR YES
	MOVZWL	#SS$_ENDOFFILE,R0	;ASSUME END OF FILE
	BBS	#MT_DS_V_TM,R2,60$	;IF SET, TAPE MARK ENCOUNTERED
	BBS	#MT_DS_V_PES,R2,45$	; If at 1600, branch around test of
					;  minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;MINIMUM RECORD READ?
	BGTRU	5$			;IF GTRU NO
45$:
	CMPB	#CDF_READDATA,UCB$B_CEX(R5) ;LAST FUNCTION READ DATA?
	BEQL	10$			;IF EQL YES
50$:	MOVZWL	#SS$_DATAOVERUN,R0	;SET DATA OVER RUN STATUS
	CMPW	UCB$W_MT_FC(R5),UCB$W_BCNT(R5) ;DATA OVER RUN?
	BGTRU	60$			;IF GTR YES
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
60$:	INCL	UCB$L_MT_RECORD(R5)	;INCREMENT RECORD POSITION
	BRW	FUNCXT			;

;
; RECOVERABLE CONTROLLER OR DRIVE ERROR
;
; A CHECK IS MADE TO DETERMINE IF OPERATION INCOMPLETE IS THE ONLY ERROR AND THAT
; THE TRANSFERED BYTE COUNT WAS ZERO. IF THIS CHECK IS SATISFIED, THEN BLANK TAPE
; IS BEING READ AND THE FATAL ERROR EXIT IS TAKEN.
;
; A CHECK IS MADE TO DETERMINE IF ANY RETRIES REMAIN. IF THE NUMBER OF RETRIES IS
; EXHAUSTED, THEN AN ERROR IS RETURNED. ELSE RECOVERY IS ATTEMPTED. THE METHOD USED
; DEPENDS ON THE PREVIOUS NUMBER OF RETRIES.
;
; IF THE PREVIOUSLY ATTEMPTED RETRIES HAVE EXCEEDED A THRESHOLD, THEN THE TAPE IS
; BACKSPACED THE ERROR BACKSPACE COUNT, FORWARD SPACED THAT NUMBER MINUS ONE, AND
; THE OPERATION IS REPEATED.
;
; IF THE PREVIOULY ATTEMPTED RETRIES HAVE NOT EXCEEDED THE THRESHOLD, THEN THE TAPE
; IS BACKSPACED ONE RECORD AND THE OPERATION IS RETRIED.
;

70$:	BITW	#^C<MT_ER_M_OPI>,R0	;OPERATION INCOMPLETE ONLY ERROR?
	BNEQ	80$			;IF NEQ NO
	TSTW	UCB$W_MT_FC(R5)		;TRANSFERED BYTE COUNT ZERO?
	BEQL	140$			;IF EQL YES
80$:	TESTR	130$			;TEST REMAINING RETRIES
	CMPB	#THRESHOLD,UCB$B_ERTCNT(R5) ;TIME TO USE ALTERNATE RECOVERY?
	BLEQU	120$			;IF LEQU NO
	CMPL	#ERR_SPACING,UCB$L_MT_RECORD(R5) ;ENOUGH RECORDS WRITTEN ON TAPE?
	BLEQU	90$			;IF LEQU YES
	RELSCHAN			;RELEASE SECONDARY CHANNEL
	EXFUNC	DOUBLE,F_REWIND		;REWIND TAPE
	REQPCHAN			;REQUEST PRIMARY CHANNEL
	MOVL	R4,R3			;SET ADDRESS OF DRIVE CONTROL REGISTER
	REQSCHAN			;REQUEST SECONDARY CHANNEL
	MOVW	UCB$L_MT_RECORD(R5),UCB$W_MT_FORCNT(R5) ;SET PROPER RECORD COUNT
	BNEQ	110$			; NEQ implies that we were not originally
					;  at BOT, so we space forward to where
					;  were.
	BRB	130$			; Else if we were at BOT we branch around.
90$:	MOVW	#ERR_SPACING,UCB$W_MT_FORCNT(R5) ;SET RECORD COUNT
100$:	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	DECW	UCB$W_MT_FORCNT(R5)	;ANY MORE RECORDS TO SPACE?
	BGTR	100$			;IF GTR YES
	MOVW	#ERR_SPACING-1,UCB$W_MT_FORCNT(R5) ;SET FORWARD SPACING COUNT
110$:	EXFUNC	DOUBLE,F_INTSPCFOR	;SPACE RECORD FORWARD
	DECW	UCB$W_MT_FORCNT(R5)	;ANY MORE RECORDS TO SPACE OVER?
	BGTR	110$			;IF GTR YES
	BRB	130$			;
120$:	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
130$:	BRW	5$			;
140$:	BRW	FATALERR		;
	.PAGE
	.SBTTL	READ DATA REVERSE AND WRITECHECK DATA REVERSE FUNCTIONS
;
; READ DATA REVERSE AND WRITECHECK DATA REVERSE FUNCTIONS
;

WRITECHECKR:				;WRITE CHECK REVERSE
	BICW	#IO$M_DATACHECK,UCB$W_FUNC(R5) ;CLEAR DATA CHECK REQUEST
READDATAR:				;READ DATA REVERSE
	REQSCHAN			;REQUEST SECONDARY I/O CHANNEL
5$:	MOVZBL	UCB$B_FEX(R5),R0	;RETRIEVE FUNCTION INDEX
	EXFUNC	20$			;EXECUTE FUNCTION
	BBS	#MT_DS_V_PES,-		; If at 1600 BPI, branch around test
		UCB$W_MT_DS(R5),10$	;  for minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;MINIMUM RECORD READ?
	BGTRU	5$			;IF GTRU NO
10$:	BBC	#IO$V_DATACHECK,UCB$W_FUNC(R5),50$ ;IF CLR, NO DATA CHECK
	EXFUNC	DOUBLE,F_INTSPCFOR	;SPACE RECORD FORWARD
	EXFUNC	20$,F_WRITECHECKR	;WRITE CHECK DATA REVERSE
	BRB	50$			;

;
; FUNCTION ENDED IN AN ERROR
;
; THE ERROR COULD BE A NONFATAL CONTROLLER OR DRIVE ERROR. FATAL ERRORS TERMINATE
; THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL CONTROLLER ERRORS ARE:
;
;	ERCONF	= ERROR CONFIRMATION.
;	ISTO	= INTERFACE SEQUENCE TIMEOUT.
;	PGE	= PROGRAMMING ERROR.
;	NED	= NONEXISTENT DRIVE.
;	RDTO	= READ DATA TIMEOUT.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	DPAR	= DATA BUS PARITY.
;
; NOTE THAT IT IS ASSUMED THAT MASSBUS EXCEPTION (MBEXC) WILL OCCUR ONLY IN
; COMBINATION WITH ANOTHER DRIVE OR CONTROLLER ERROR.
;

20$:	BITL	#MBA$M_SR_DLT!-		;DATA LATE OR,
		MBA$M_SR_INVMAP!-	;INVALID MAP REGISTER OR,
		MBA$M_SR_MAPPE!-	;MAP PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_MXF!-		;MISSED TRANSFER OR,
		MBA$M_SR_RDS,R1		;READ DATA SUBSTITUTE OR,
	BNEQ	70$			;IF NEQ YES
	BBS	#MT_DS_V_TM,R2,30$	;IF SET, TAPE MARK DETECTED
	BITW	#MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK UPPER BYTE?
	BNEQ	70$			;IF NEQ YES
30$:	BITW	#MT_ER_M_CPAR!-		;CONTROL BUS PARITY ERROR OR,
		MT_ER_M_DTE!-		;DRIVE TIMING ERROR OR,
		MT_ER_M_FMT!-		;FORMAT ERROR OR,
		MT_ER_M_INC!-		;INCORRECTABLE ERROR (PE) OR,
		MT_ER_M_LRC!-		;LONGITUDINAL PARITY ERROR (NRZI) OR,
		MT_ER_M_NSG!-		;NONSTANDARD GAP OR,
		MT_ER_M_OPI!-		;OPERATION INCOMPLETE OR,
		MT_ER_M_PEF!-		;FORMAT ERROR (PE) OR,
		MT_ER_M_VPE,R0		;VERTICLE PARITY ERROR (NRZI)?
	BNEQ	70$			;IF NEQ YES
	BBS	#MT_DS_V_PES,R2,40$	;IF SET, PHASE ENCODED TAPE
	BITW	#MT_ER_M_CRC!MT_ER_M_ITM,R0 ;CRC OR INVALID TAPE MARK?
	BNEQ	70$			;IF NEQ YES

;
; FRAME COUNT OR NONEXECUTABLE FUNCTION
;
; IF THE RECORD CONTAINED MORE BYTES THAN THE SPECIFIED BUFFER, THEN A DATA OVERRUN
; IS RETURNED. ELSE A CHECK IS MADE FOR END OF FILE, BEGINNING OF TAPE, AND
; IMPLICIT WRITECHECK.
;

40$:	MOVZWL	#SS$_DATAOVERUN,R0	;SET DATA OVER RUN STATUS
	CMPW	UCB$W_MT_FC(R5),UCB$W_BCNT(R5) ;DATA OVER RUN?
	BGTRU	60$			;IF GTR YES
	MOVZWL	#SS$_ENDOFFILE,R0	;SET END OF FILE STATUS
	BBS	#MT_DS_V_TM,R2,60$	;IF SET, TAPE MARK ENCOUNTERED
	BBS	#MT_DS_V_BOT,R2,60$	;IF SET, BEGINNING OF TAPE
	BBS	#MT_DS_V_PES,R2,45$	; If at 1600, branch around test of
					;  minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;MINIMUM RECORD READ?
	BGTRU	5$			;IF GTRU NO
45$:
	CMPB	#CDF_READDATAR,UCB$B_CEX(R5) ;LAST FUNCTION READ DATA?
	BEQL	10$			;IF EQL YES
50$:	MOVZWL	#SS$_DATAOVERUN,R0	;SET DATA OVER RUN STATUS
	CMPW	UCB$W_MT_FC(R5),UCB$W_BCNT(R5) ;DATA OVER RUN?
	BGTRU	60$			;IF GTR YES
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
60$:	DECL	UCB$L_MT_RECORD(R5)	;DECREMENT TAPE POSITION
	BRW	FUNCXT			;

;
; FUNCTION ENDED IN A RETRIABLE ERROR
;

70$:	TESTR	130$			;TEST FOR RETRIES
	CMPB	#THRESHOLD,UCB$B_ERTCNT(R5) ;TIME TO USE ALTERNATE RECOVERY?
	BLEQU	90$			;IF LEQU NO
	MOVW	#ERR_SPACING,UCB$W_MT_FORCNT(R5) ;SET FORWARD SPACING COUNT
80$:	EXFUNC	DOUBLE,F_INTSPCFOR	;SPACE RECORD FORWARD
	DECW	UCB$W_MT_FORCNT(R5)	;ANY MORE RECORDS TO SPACE?
	BGTR	80$			;IF GTR YES
	MOVW	#ERR_SPACING,UCB$W_MT_FORCNT(R5) ;SET REVERSE SPACE COUNT
85$:	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	DECW	UCB$W_MT_FORCNT(R5)	;ANY MORE RECORDS TO SPACE?
	BGTR	85$			;IF GTR YES
90$:	CMPB	#CDF_WRITECHECKR,UCB$B_CEX(R5) ;WRITE CHECK REVERSE?
	BEQL	120$			;IF EQL YES
	CMPW	UCB$W_MT_FC(R5),-	; See if record size > BCNT.  If so
		UCB$W_BCNT(R5)		;  then we cannot read forward and
					;  accomodate the record equally.
	BGTRU	120$			; GTR implies yes record > BCNT.
	ADDW	UCB$W_BCNT(R5),-	; Here we will try to read forward so
		UCB$W_BOFF(R5)		;  effectively relocate the buffer to a
	SUBW	UCB$W_MT_FC(R5),-	;  higher offset if the record is
		UCB$W_BOFF(R5)		;  smaller than the BCNT (buffersize).
	MOVW	UCB$W_MT_FC(R5),-	; Here we set the byte count to the
		UCB$W_BCNT(R5)		;  real record size.
	EXFUNC	100$,F_READDATA		;READ DATA FORWARD
100$:	BITL	#MBA$M_SR_DLT!-		;DATA LATE OR,
		MBA$M_SR_INVMAP!-	;INVALID MAP REGISTER OR,
		MBA$M_SR_MAPPE!-	;MAP PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_MXF!-		;MISSED TRANSFER OR,
		MBA$M_SR_NED!-		;NONEXISTENT DISK OR,
		MBA$M_SR_RDS,R1		;READ DATA SUBSTITUTE.
	BNEQ	110$			;IF NEQ YES
	BITW	#MT_ER_M_CPAR!-		;CONTROL BUS PARITY ERROR, OR
		MT_ER_M_DTE!-		;DRIVE TIMING ERROR ,OR
		MT_ER_M_FCE!-		;FRAME COUNT ERROR OR,
		MT_ER_M_FMT!-		;FORMAT ERROR OR,
		MT_ER_M_ITM!-		;INVALID TAPE MARK OR,
		MT_ER_M_NSG!-		;NONSTANDARD GAP OR,
		MT_ER_M_OPI,R0		;OPERATION INCOMPLETE.
	BNEQ	110$			;IF NEQ YES
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	EXFUNC	110$,F_READDATA		;READ DATA FORWARD
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	BRW	10$			;
110$:	INCB	UCB$B_ERTCNT(R5)	;BIAS ERROR RETRY COUNT
	TESTR	120$			;TEST FOR TAPE MOVEMENT
	BRB	130$			;
120$:	EXFUNC	DOUBLE,F_INTSPCFOR	;SPACE RECORD FORWARD
130$:
	MOVL	UCB$L_IRP(R5),R0	; Restore original transfer parameters
					;  in case they have been altered above.
	ASSUME	IRP$W_BOFF+2 EQ IRP$W_BCNT
	ASSUME	UCB$W_BOFF+2 EQ UCB$W_BCNT

	MOVL	IRP$W_BOFF(R0),-	; Restore transfer parameters.
		UCB$W_BOFF(R5)
	BRW	5$			; Go back and try again.
	.PAGE
	.SBTTL	WRITE DATA FORWARD FUNCTION
;
; WRITE DATA FORWARD FUNCTION
;

WRITEDATA:				;WRITE DATA FORWARD
	REQSCHAN			;REQUEST SECONDARY CHANNEL
5$:	EXFUNC	20$,F_WRITEDATA		;EXECUTE FUNCTION
	BBC	#IO$V_DATACHECK,UCB$W_FUNC(R5),10$ ;IF CLR, NO DATA CHECK
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	EXFUNC	50$,F_WRITECHECK	;WRITE CHECK DATA
10$:	MOVW	UCB$W_BCNT(R5),UCB$W_MT_FC(R5) ;SET TRANSFER BYTE COUNT
	INCL	UCB$L_MT_RECORD(R5)	;INCREMENT TAPE POSITION
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BRW	FUNCXT			;

;
; WRITE FUNCTION ENDED IN AN ERROR
;
; THE ERROR COULD BE A NONFATAL CONTROLLER OR DRIVE ERROR. FATAL ERRORS TERMINATE
; THE FUNCTION IN THE FUNCTION EXECUTOR.
;
; FATAL CONTROLLER ERRORS ARE:
;
;	ERCONF	= ERROR CONFIRMATION.
;	ISTO	= INTERFACE SEQUENCE TIMEOUT.
;	PGE	= PROGRAMMING ERROR.
;	NED	= NONEXISTENT DRIVE.
;	RDTO	= READ DATA TIMEOUT.
;
; FATAL DRIVE ERRORS ARE:
;
;	ILF	= ILLEGAL FUNCTION.
;	ILR	= ILLEGAL REGISTER.
;	NEF	= NONEXECUTABLE FUNCTION.
;	RMR	= REGISTER MODIFY REFUSE.
;	UNS	= UNSAFE.
;
; IGNORED DRIVE ERRORS ARE:
;
;	NONE.
;

20$:	BISW	#IO$M_DATACHECK,UCB$W_FUNC(R5) ;FORCE DATA CHECK
	ADDW	UCB$W_BCNT(R5),UCB$W_MT_FC(R5) ;CALCULATE ACTUAL BYTES TRANSFERED
	TESTR	30$			;TEST REMAINING RETRIES
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
30$:	BBS	#IO$V_INHEXTGAP,UCB$W_FUNC(R5),40$ ;IF SET, NO EXTENDED GAP
	RELSCHAN			;RELEASE SECONDARY CHANNEL
	EXFUNC	DOUBLE,F_ERASE		;ERASE TAPE
	REQSCHAN			;REQUEST SECONDARY CHANNEL
40$:	BRB	5$			;

;
; WRITECHECK FUNCTION ENDED IN ERROR
;
; THE WRITECHECK ERROR IS NOT COUNTED AGAINST THE RETRY COUNT, BUT RATHER THE
; TAPE IS REPOSITIONED AND THE WRITE IS RETRIED.
;

50$:	ADDW	UCB$W_BCNT(R5),UCB$W_MT_FC(R5) ;CALCULATE TRANSFERED BYTE COUNT
	INCB	UCB$B_ERTCNT(R5)	;BIAS ERROR RETRY COUNT
	TESTR	5$			;TEST REMAINING RETRIES
	EXFUNC	DOUBLE,F_INTSPCREV	;SPACE RECORD REVERSE
	BRB	5$			;
	.PAGE
	.SBTTL	CHECK FOR FATAL OR RETRIABLE SPACING ERROR
;
; CHECK_ERROR - CHECK FOR FATAL OR RETRIABLE SPACING ERROR
;
; THIS ROUTINE IS CALLED FROM THE SPACE FILE FORWARD, SPACE RECORD FORWARD, SPACE
; FILE REVERSE, AND SPACE RECORD REVERSE FUNCTION ROUTINES TO TEST WHETHER A
; SPACING ERROR IS FATAL AND WHETHER ANY RETRIES REMAIN.
;
; INPUTS:
;
;	R0 = DRIVE ERROR REGISTER.
;	R1 = MBA STATUS REGISTER.
;	R2 = DRIVE STATUS REGISTER.
;
;	UCB$B_CEX(R5) = FUNCTION INDEX OF LAST FUNCTION EXECUTED.
;	UCB$B_ERTCNT(R5) = NUMBER OF ERROR RETRIES REMAINING.
;	UCB$W_BCNT(R5) = ORIGINAL SPACING COUNT.
;	UCB$W_BOFF(R5) = REMAINING SPACING COUNT.
;
; OUTPUTS:
;
;	IF ONLY A FRAME COUNT ERROR OCCURED, OR THE FUNCTION WAS A REVERSE DIRECTION
;	FUNCTION AND A CONTROL BUS PARITY ERROR DID NOT OCCUR, THEN AN IMMEDIATE
;	RETURN TO THE CALLER IS EXECUTED. ELSE THE REMAINING RETRY COUNT IS DE-
;	CREMENTED, AND IF THE RESULT IS ZERO, THEN THE FUNCTION IS TERMINATED VIA
;	THE DOUBLE ERROR EXIT. ELSE THE FUNCTION IS REDISPATCHED.
;

CHECK_ERROR:				;
	POPL	R1			;REMOVE RETURN ADDRESS FROM STACK
	BITW	#^C<MT_ER_M_FCE>,R0	;RETRIABLE OR FATAL ERROR?
	BEQL	20$			;IF EQL NO

;
; RETRIABLE OR FATAL DRIVE ERROR
;
;	CPAR	= CONTROL BUS PARITY ERROR.
;	NEF	= NONEXECUTABLE FUNCTION.
;	OPI	= OPERATION INCOMPLETE.
;

	BBS	#MT_ER_V_CPAR,R0,40$	;IF SET, CONTROL BUS PARITY ERROR

;
; ERROR WAS EITHER A NONEXECUTABLE FUNCTION OR OPERATION INCOMPLETE
;

	CMPB	#CDF_SPCFILREV,UCB$B_CEX(R5) ;SPACE FILE REVERSE?
	BEQL	10$			;IF EQL YES
	CMPB	#CDF_SPCRECREV,UCB$B_CEX(R5) ;SPACE RECORD REVERSE?
	BNEQ	30$			;IF NEQ NO
10$:	BBC	#MT_DS_V_BOT,R2,30$	;IF CLR, NOT AT BEGINNING OF TAPE
20$:	JMP	(R1)			;

;
; FORCE FATAL ERROR ON NONEXECUTABLE FUNCTION OR OPERATION INCOMPLETE FOR A FORWARD
; DIRECTION FUNCTION, OR A REVERSE DIRECTION FUNCTION THAT DID NOT END UP AT BEGINNING
; OF TAPE.
;

30$:	MOVB	#1,UCB$B_ERTCNT(R5)	;SET RETRY COUNT TO ONE

;
; ERROR WAS A CONTROL BUS PARITY ERROR OR A NONEXECUTABLE FUNCTION OR OPERATION
; INCOMPLETE IN COMBINATION WITH A REVERSE DIRECTION FUNCTION
;

40$:	SUBW3	UCB$W_BOFF(R5),UCB$W_BCNT(R5),- ;CALCULATE TOTAL SPACE COUNT
		UCB$W_MT_FC(R5)		;
	JSB	G^ERL$DEVICERR		;LOG DEVICE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES REMAINING?
	BEQL	DOUBLE			;IF EQL NO
	BRW	FDISPATCH		;
	.PAGE
	.SBTTL	TEST FOR REMAINING RETRIES
;
; TESTR - TEST FOR REMAINING RETRIES
;
; THIS ROUTINE IS CALLED FROM THE READ DATA, READ DATA REVERSE, WRITECHECK,
; WRITECHECK REVERSE, WRITE DATA, AND WRITE TAPE MARK FUNCTION ROUTINES TO
; TEST FOR REMAINING RETRIES.
;
; INPUTS:
;
;	R0 = DRIVE ERROR REGISTER.
;	R1 = MBA STATUS REGISTER.
;	R2 = DRIVE STATUS REGISTER.
;
;	UCB$B_CEX(R5) = FUNCTION INDEX OF LAST FUNCTION EXECUTED.
;	UCB$B_ERTCNT(R5) = NUMBER OF ERROR RETRIES REMAINING.
;	UCB$L_MT_RECORD(R5) = CURRENT TAPE POSITION BEFORE FUNCTION EXECUTION.
;	UCB$W_MT_DS(R5) = SAVED DRIVE STATUS REGISTER.
;	UCB$W_FUNC(R5) = ORIGINAL FUNCTION WORD.
;	UCB$W_MT_FC(R5) = NUMBER OF BYTES THAT WERE READ OR WRITTEN TO/FROM TAPE.
;
;	@(SP) = SIGNED BRANCH DISPLACEMENT TO CONDITIONAL EXIT POINT.
;
; OUTPUTS:
;
;	THE REMAINING RETRY COUNT IS DECREMENTED AND IF THE RESULT IS ZERO, THEN
;	THE FUNCTION IS TERMINATED WITH AN ERROR VIA THE FATAL ERROR EXIT AFTER
;	HAVING ADJUSTED THE CURRENT TAPE POSITION. ELSE THE CONDITIONAL BRANCH
;	EXIT IS TAKEN IF NO TAPE MOVEMENT OCCURED.
;

TESTR:					;
	JSB	G^ERL$DEVICERR		;LOG DEVICE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES REMAINING?
	BEQL	20$			;IF EQL NO
	BBS	#MT_DS_V_PES,-		; If at 1600 BPI, branch around test
		UCB$W_MT_DS(R5),10$	;  for minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;ANY TAPE MOVEMENT?
	BLEQU	10$			;IF LEQU YES
	BBS	#MT_DS_V_TM,UCB$W_MT_DS(R5),10$ ;IF SET, TAPE MARK DETECTED
	CVTWL	@(SP),-(SP)		;GET DISPLACEMENT VALUE
	ADDL	(SP)+,(SP)		;CALCULATE BRANCH ADDRESS
10$:	ADDL	#2,(SP)			;
	RSB				;

;
; ERROR RETRIES EXHAUSTED
;
; CHECK FOR TAPE MOVEMENT, ADJUST TAPE POSITION AS APPROPRIATE, AND TAKE FATAL
; ERROR EXIT.
;

20$:	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	BBS	#MT_DS_V_TM,UCB$W_MT_DS(R5),30$ ;IF SET, TAPE MARK DETECTED
	BBS	#MT_DS_V_PES,-		; If at 1600 BPI, branch around test
		UCB$W_MT_DS(R5),30$	;  for minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;ANY TAPE MOVEMENT?
	BGTRU	40$			;IF GTRU NO
30$:	DECL	UCB$L_MT_RECORD(R5)	;ASSUME REVERSE TAPE OPERATION
	CMPB	#CDF_READDATAR,UCB$B_CEX(R5) ;READ DATA REVERSE?
	BEQL	40$			;IF EQL YES
	CMPB	#CDF_WRITECHECKR,UCB$B_CEX(R5) ;WRITE CHECK REVERSE?
	BEQL	40$			;IF EQL YES
	ADDL	#2,UCB$L_MT_RECORD(R5)	;ADJUST FOR FORWARD TAPE OPERATION
40$:	BRW	FATALERR		;
	.PAGE
	.SBTTL	TAPE POSITION LOST
;
; TAPE POSITION LOST
;

LOSTPOS:				;
	BISW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;SET TAPE POSITION LOST

;
; TEST FOR RETRY
;

RETRY:					;TEST FOR RETRY
	JSB	G^ERL$DEVICERR		;LOG DEVICE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES REMAINING?
	BEQL	FATALERR		;IF EQL NO
	BRW	FDISPATCH		;

;
; DOUBLE ERROR WHILE TRYING TO REPOSITION TAPE - TAPE POSITION LOST
;

DOUBLE:					;
	BISW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;SET LOST POSITION STATUS

;
; FATAL CONTROLLER/DRIVE ERROR, ERROR RETRY COUNT EXHAUSTED, ERROR RETRY
; INHIBITED, OR FINAL OFFSET TRIED
;

FATALERR:				;FATAL ERROR - SET STATUS
	MOVL	R0,R3			;COPY ERROR STATUS REGISTER
	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BBC	#MT_DS_V_MOL,R2,FUNCXT	;IF CLR, MEDIUM OFFLINE
	BBC	#MT_ER_V_NEF,R3,10$	;IF CLR, EXECUTABLE FUNCTION
	MOVZWL	#SS$_WRITLCK,R0		;SET WRITE LOCK ERROR STATUS
	BBS	#MT_DS_V_WRL,R2,FUNCXT	;IF SET, DRIVE HARDWARE WRITE LOCKED
10$:	MOVZWL	#SS$_UNSAFE,R0		;SET DRIVE UNSAFE STATUS
	BBS	#MT_ER_V_UNS,R3,FUNCXT	;IF SET, DRIVE UNSAFE
	MOVZWL	#SS$_OPINCOMPL,R0	;SET OPERATION INCOMPLETE STATUS
	BBS	#MT_ER_V_OPI,R3,FUNCXT	;IF SET, OPERATION INCOMPLETE
	MOVZWL	#SS$_FORMAT,R0		;SET FORMAT ERROR STATUS
	BBS	#MT_ER_V_FMT,R3,FUNCXT	;IF SET, FORMAT ERROR
	MOVZWL	#SS$_DRVERR,R0		;SET DRIVE ERROR STATUS
	BITW	#MT_ER_M_DTE!-		;DRIVE TIMING ERROR OR,
		MT_ER_M_ILF!-		;ILLEGAL FUNCTION OR,
		MT_ER_M_ILR!-		;ILLEGAL REGISTER OR,
		MT_ER_M_NEF!-		;NON-EXECUTABLE FUNCTION OR,
		MT_ER_M_RMR,R3		;REGISTER MODIFY REFUSE
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_PARITY,R0		;SET PARITY ERROR STATUS
	BITW	#MT_ER_M_CRC!-		;CRC ERROR OR,
		MT_ER_M_CPAR!-		;CONTROL BUS PARITY ERROR OR,
		MT_ER_M_COR!-		;CORRECTABLE DATA ERROR (PE) OR,
		MT_ER_M_CS!-		;CORRECTABLE SKEW (PE) OR,
		MT_ER_M_DPAR!-		;DATA PARITY ERROR OR,
		MT_ER_M_INC!-		;INCORRECTABLE ERROR (PE) OR,
		MT_ER_M_ITM!-		;INVALID TAPE MARK OR,
		MT_ER_M_LRC!-		;LONGITUDINAL PARITY ERROR (NRZI) OR,
		MT_ER_M_NSG!-		;NONSTANDARD GAP OR,
		MT_ER_M_PEF!-		;FORMAT ERROR (PE) OR,
		MT_ER_M_VPE,R3		;VERTICLE PARITY ERROR (NRZI)?
	BNEQ	FUNCXT			;IF NEQ YES
	BITL	#MBA$M_SR_MAPPE!-	;MAP PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_RDS,R1		;READ DATA SUBSTITUTE?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_DATACHECK,R0	;SET DATA CHECK ERROR STATUS
	BITW	#MBA$M_SR_WCKLWR!-	;WRITE CHECK ERROR LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK ERROR UPPER BYTE?
	BNEQ	FUNCXT			;IF NEQ YES
	MOVZWL	#SS$_NONEXDRV,R0	;SET NONEXISTENT DRIVE STATUS
	BBS	#MBA$V_SR_NED,R1,FUNCXT	;IF SET, NONEXISTENT DRIVE
	MOVZWL	#SS$_CTRLERR,R0		;SET CONTROLLER ERROR STATUS
	.PAGE
	.SBTTL	FUNCTION COMPLETION COMMON EXIT
;
; FUNCTION COMPLETION COMMON EXIT
;
; THIS ROUTINE IS JUMPED TO AT THE END OF ALL MAGTAPE OPERATIONS.
;
; INPUTS:
;
;	R0 = FINAL I/O COMPLETION STATUS.
;	R2 = DRIVE STATUS REGISTER.
;
;	UCB$B_FEX(R5) = FUNCTION EXECUTION INDEX.
;
; OUTPUTS:
;
;	THE FINAL DRIVE STATUS IS TESTED AND THE FOLLOWING STATUS BITS ARE SET
;	IN THE SECOND WORD OF THE DEVICE DEPENDENT CHARACTERISTICS LONGWORD.
;
;		MT$M_BOT = SET IF TAPE IS AT BEGINNING OF TAPE AT END OF FUNCTION.
;		MT$M_EOF = SET IF A VALID TAPE MARK WAS DETECTED DURING THE TAPE
;			OPERATION.
;		MT$M_EOT = SET IF AN END OF TAPE CONDITION WAS PRESENT AT THE END
;			OF THE TAPE OPERATION AND THE FUNCTION WAS A READ DATA
;			FORWARD, WRITECHECK DATA FORWARD, WRITE DATA FORWARD, OR
;			SPACE RECORD FORWARD FUNCTION.
;		MT$M_HWL = SET IF THE SLAVE DRIVE HAS A TAPE MOUNTED THAT DOES NOT
;			CONTAIN A WRITE RING.
;

FUNCXT:					;FUNCTION EXIT
	MOVZBL	UCB$B_FEX(R5),R1	;GET FUNCTION DISPATCH INDEX
	BICW	#<MT$M_BOT!-		;CLEAR BEGINNING OF TAPE AND,
		MT$M_EOF!-		;END OF FILE AND,
		MT$M_EOT!-		;END OF TAPE AND,
		MT$M_HWL>@-16,UCB$L_DEVDEPEND+2(R5) ;HARDWARE WRITE LOCK
	BBC	#MT_DS_V_BOT,R2,10$	;IF CLR, NOT AT BEGINNING OF TAPE
	BISW	#<MT$M_BOT@-16>,UCB$L_DEVDEPEND+2(R5) ;SET BEGINNING OF TAPE
	BICW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;CLEAR TAPE POSITION LOST
	CLRL	UCB$L_MT_RECORD(R5)	;CLEAR TAPE POSITION
10$:	BBC	#MT_DS_V_TM,R2,30$	;IF CLR, NO TAPE MARK DETECTED
	BISW	#<MT$M_EOF@-16>,UCB$L_DEVDEPEND+2(R5) ;SET END OF FILE
	CMPB	#CDF_WRITECHECK,R1	;DATA TRANSFER FUNCTION?
	BGTRU	30$			;IF GTRU NO
	CMPB	#CDF_WRITEMARK,R1	;WRITE TAPE MARK FUNCTION?
	BEQL	20$			;IF EQL YES
	CMPB	#CDF_READPRESET,R1	;DATA TRANSFER FUNCTION?
	BLEQU	30$			;IF LEQU NO
20$:	CLRW	UCB$W_MT_FC(R5)		;CLEAR FRAME COUNT
	CMPW	#SS$_DATACHECK,R0	;WRITE CHECK ERROR?
	BNEQ	30$			;IF NEQ NO
	MOVZWL	#SS$_ENDOFFILE,R0	;SET END OF FILE STATUS
30$:	BBC	#MT_DS_V_EOT,R2,40$	;IF CLR, NOT AT END OF TAPE
	CMPB	#CDF_SPCFILREV,R1	;SPACE FILE REVERSE?
	BEQL	40$			;IF EQL YES
	CMPB	#CDF_SPCRECREV,R1	;SPACE RECORD REVERSE?
	BEQL	40$			;IF EQL YES
	CMPB	#CDF_WRITECHECKR,R1	;WRITE CHECK REVERSE?
	BEQL	40$			;IF EQL YES
	CMPB	#CDF_READDATAR,R1	;READ DATA REVERSE?
	BEQL	40$			;IF EQL YES
	BISW	#<MT$M_EOT@-16>,UCB$L_DEVDEPEND+2(R5) ;SET END OF TAPE
	BLBC	R0,40$			;IF LBC ALREADY RETURNING ERROR
	MOVZWL	#SS$_ENDOFTAPE,R0	;SET END OF TAPE STATUS
40$:	BBC	#MT_DS_V_WRL,R2,50$	;IF CLR, NOT HARDWARE WRITE LOCKED
	BISW	#<MT$M_HWL@-16>,UCB$L_DEVDEPEND+2(R5) ;SET HARDWARE WRITE LOCKED
50$:	PUSHL	R0			;SAVE FINAL STATUS
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	MOVW	UCB$W_MT_FC(R5),2(SP)	;SET BYTES TRANSFERED OR RECORDS/FILES SKIPPED
	BLBS	(SP),70$		;IF LBS SUCCESSFUL COMPLETION
	MOVL	UCB$L_IRP(R5),R4	;GET ADDRESS OF CURRENT I/O PACKET
	BBC	#IRP$V_VIRTUAL,IRP$W_STS(R4),70$ ;IF CLR, NOT VIRTUAL FUNCTION
	MOVL	IRP$L_WIND(R4),R4	;GET ADDRESS OF WINDOW BLOCK
	CLRW	WCB$W_NMAP(R4)		;CLEAR NUMBER OF MAPPING POINTERS
	MOVL	UCB$L_VCB(R5),R4	;GET ADDRESS OF VCB LISTHEAD
	MOVAB	UCB$L_IOQFL(R5),R2	;GET ADDRESS OF I/O QUEUE
	MOVL	R2,R3			;SET ADDRESS OF PREVIOUS ENTRY
60$:	MOVL	(R3),R3			;GET ADDRESS OF NEXT ENTRY
	CMPL	R3,R2			;END OF LIST?
	BEQL	70$			;IF EQL YES
	BBC	#IRP$V_VIRTUAL,IRP$W_STS(R3),60$ ;IF CLR, NOT VIRTUAL FUNCTION
	MOVL	4(R3),R3		;RETRIEVE ADDRESS OF PREVIOUS ENTRY
	REMQUE	@(R3),R1		;REMOVE ENTRY FROM DRIVER QUEUE
	INSQUE	(R1),@4(R4)		;INSERT ENTRY IN BLOCKED I/O LIST
	BRB	60$			;
70$:	POPL	R0			;RETRIEVE FINAL STATUS
STSXIT:	MOVL	UCB$L_DEVDEPEND(R5),R1	;SET MAGTAPE STATUS AND CHARACTERISTICS
	REQCOM				;COMPLETE REQUEST
	.PAGE
	.SBTTL	TM03-TE16/TU77 HARDWARE FUNCTION EXECUTION
;
; FEX - TM03-TE16/TU77 HARDWARE FUNCTION EXECUTION
;
; THIS ROUTINE IS CALLED VIA A BSB WITH A WORD IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE BEEN
; SET UP IN THE UCB BEFORE THE CALL. THE APPROPRIATE PARAMETERS ARE LOADED
; INTO DEVICE REGISTERS AND THE FUNCTION IS INITIATED. IF THE FUNCTION IS AN
; IMMEDIATE FUNCTION CONTROL RETURNS IMMEDIATELY. ELSE THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTER-
; RUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
;
; INPUTS:
;
;	R0 = FUNCTION TABLE DISPATCH INDEX.
;	R3 = ADDRESS OF DRIVE CONTROL STATUS REGISTER 1.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A WORD WHICH CONTAINS
;	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE.
;
; OUTPUTS:
;
;	THERE ARE FOUR EXITS FROM THIS ROUTINE:
;
;	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
;		OR THE OPERATION TIMES OUT. IT IS A JUMP TO THE APPROPRIATE
;		ERROR ROUTINE.
;
;	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
;		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS
;		INHIBITED. IT IS A JUMP TO THE FATAL ERROR EXIT ROUTINE.
;
;	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
;		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NOT INHIBITED.
;		IT CONSISTS OF TAKING THE ERROR BRANCH EXIT.
;
;	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERROR OCCURS
;		DURING THE OPERATION. IT CONSISTS OF A RETURN INLINE.
;
;	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
;
;	IN ALL CASES FINAL DRIVE AND CONTROLLER REGISTERS ARE RETURNED VIA
;	THE GENERAL REGISTERS R0, R1, AND R2, AND THE UCB.
;
;	R0 = DRIVE ERROR REGISTER.
;	R1 = MBA STATUS REGISTER.
;	R2 = DRIVE STATUS REGISTER.
;
;	UCB$W_MT_FC(R5) = FRAME COUNT REGISTER.
;

FEX:					;FUNCTION EXECUTOR
	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVB	R0,UCB$B_CEX(R5)	;SAVE CASE INDEX
RESTART:				;RESTART FUNCTION
	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R3) ;SELECT DRIVE AND SET CHARACTERISTICS
	MOVZBL	#F_DRVCLR!1,MT_CS1(R3)	;CLEAR DRIVE
	CASE	R0,<-			;DISPATCH TO PROPER FUNCTION ROUTINE
		IMMED,-			;NO OPERATION
		POSIT,-			;UNLOAD VOLUME
		POSIT,-			;SPACE FILE FORWARD
		RECAL,-			;REWIND
		IMMED,-			;DRIVE CLEAR
		POSIT,-			;SPACE FILE REVERSE
		POSIT,-			;ERASE TAPE
		POSIT,-			;SPACE RECORD REVERSE
		IMMED,-			;NO OPERATION
		POSIT,-			;SPACE RECORD FORWARD
		XFER,-			;WRITE CHECK FORWARD
		XFER,-			;WRITE DATA FORWARD
		XFER,-			;READ DATA FORWARD
		XFER,-			;WRITECHECK REVERSE
		XFER,-			;WRITE DATA FORWARD
		XFER,-			;READ DATA REVERSE
		RECAL,-			;READ IN PRESET
		IMMED,-			;SET TAPE CHARACTERISTICS
		IMMED,-			;SENSE CHARACTERISTICS
		POSIT,-			;WRITE TAPE MARK
		>			;

;
; INTERNAL SPACING FUNCTIONS
;
;	SPACE RECORD FORWARD, AND
;	SPACE RECORD REVERSE.
;
; THESE FUNCTIONS ARE EXECUTED TO EFFECT SPACING OPERATIONS DURING THE ERROR
; RECOVERY OF WRITE TAPE MARK, ERASE TAPE, AND ALL DATA TRANSFER FUNCTIONS.
; WRITE CHECK AND WRITE CHECK REVERSE FUNCTIONS ARE USED TO ACTUALLY POSITION
; THE TAPE. IF A NOISE RECORD IS ENCOUNTERED, IT IS IGNORED.
;

INTSPC:					;INTERNAL SPACE FUNCTIONS
	BSBW	TM_SETINTSPC		;SETUP FOR INTERNAL SPACE FUNCTION
	MOVZBL	UCB$B_CEX(R5),R0	;RETRIEVE FUNCTION INDEX
	CMPB	#CDF_INTSPCREV,R0	;SPACE RECORD REVERSE?
	BNEQ	10$			;IF NEQ NO
	MOVZWL	#511,MBA$L_VAR(R4)	;ADJUST VIRTUAL ADDRESS REGISTER
10$:	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),20$ ;IF SET, POWER FAILED
	MOVZBL	FTAB[R0],MT_CS1(R3)	;EXECUTE FUNCTION
	WFIKPCH	RETREG,TIME_OUT[R0]	;WAIT FOR INTERRUPT AND KEEP CHANNEL
	MOVL	MBA$L_SR(R4),UCB$L_MT_SR(R5) ;SAVE FINAL MBA STATUS
	BSBW	TM_SAVDRVSTS		;SAVE DRIVE STATUS
	IOFORK				;CREATE FORK PROCESS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),30$ ;IF SET, POWER FAILED
	BICL	#MBA$M_SR_ATTN!-	;CLEAR ATTENTION AND,
		MBA$M_SR_DLT!-		;DATA LATE AND,
		MBA$M_SR_DTABT!-	;DATA TRANSFER ABORT AND,
		MBA$M_SR_DTCOMP!-	;DATA TRANSFER COMPLETE AND,
		MBA$M_SR_MBEXC!-	;MASSBUSS EXCEPTION AND,
		MBA$M_SR_MXF!-		;MISSED TRANSFER AND,
		MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER AND,
		MBA$M_SR_WCKUPR,UCB$L_MT_SR(R5) ;WRITE CHECK UPPER
	BNEQ	30$			;IF NEQ FATAL SPACING ERROR
	MOVZBL	UCB$B_CEX(R5),R0	;GET FUNCTION INDEX
	BICW	XTAB[R0],UCB$W_MT_ER(R5) ;CLEAR EXTRANEOUS DRIVE ERROR BITS
	BNEQ	30$			;IF NEQ FATAL SPACING ERROR
	BBS	#MT_DS_V_TM,UCB$W_MT_DS(R5),30$ ;IF SET, TAPE MARK ENCOUNTERED
	BBS	#MT_DS_V_PES,-		; If at 1600 BPI, branch around test
		UCB$W_MT_DS(R5),30$	;  for minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;MINIMUM RECORD READ?
	BLEQU	30$			;IF LEQU YES
	BRW	RESTART			;RESTART FUNCTION
20$:	BRW	ENBXIT			;
30$:	BRW	RETREG			;

;
; POSITIONING FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		SPACE FILE FORWARD,
;		SPACE FILE REVERSE,
;		ERASE TAPE,
;		SPACE RECORD REVERSE,
;		SPACE RECORD FORWARD,
;		UNLOAD, AND
;		WRITE TAPE MARK.
;
; THE FUNCTION IS INITIATED AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTERRUPT
; OCCURS FINAL DEVICE REGISTERS ARE RETURNED TO THE CALLER.
;

POSIT:					;POSITIONING FUNCTION EXECUTION
	DSBINT				;DISABLE ALL INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBEXT ;IF SET, POWER HAS FAILED
	CVTWL	UCB$W_MT_SPACNT(R5),MT_FC(R3) ;LOAD FRAME COUNT REGISTER
	MOVZBL	FTAB[R0],MT_CS1(R3)	;EXECUTE FUNCTION
	WFIKPCH	RETREG,TIME_OUT[R0]	;WAITFOR INTERRUPT AND KEEP CHANNEL
	BRW	DRVREG			;

;
; IMMEDIATE FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		NO OPERATION, AND
;		DRIVE CLEAR.
;
; THESE FUNCTIONS ARE EXECUTED IMMEDIATELY AND THE FINAL DEVICE REGISTERS
; ARE RETURNED TO THE CALLER.
;

IMMED:					;IMMEDIATE FUNCTION EXECUTION
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBEXT ;IF SET, POWER HAS FAILED
	MOVZBL	FTAB[R0],MT_CS1(R3)	;EXECUTE FUNCTION
ENBEXT:					;
	BRW	ENBXIT			;

;
; RECALIBRATE FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		READ IN PRESET, AND
;		REWIND.
;
; THE FUNCTION IS INITIATED AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTERRUPT
; OCCURS A TEST IS MADE TO SEE IF POSITIONING IS STILL IN PROGRESS. IF POSITIONING
; IS STILL IN PROGRESS, THEN ANOTHER WAITFOR INTERRUPT IS EXECUTED. ELSE FINAL DRIVE
; REGISTERS ARE RETURNED TO THE CALLED.
;

RECAL:					;RECALIBRATE FUNCTION EXECUTION
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBEXT ;IF SET, POWER HAS FAILED
	MOVZBL	FTAB[R0],MT_CS1(R3)	;EXECUTE FUNCTION
	WFIKPCH	RETREG,#60*7		;WAITFOR INTERRUPT
	ASHL	#31-MT_DS_V_PIP,MT_DS(R3),R2 ;POSITIONING IN PROGRESS?
	BGEQ	10$			;IF GEQ NO
	IOFORK				;CREATE FORK PROCESS
	DSBINT				;DISABLE INTERRUPTS
	ASHL	#31-MT_DS_V_PIP,MT_DS(R3),R2 ;POSITIONING IN PROGRESS?
	BGEQ	ENBEXT			;IF GEQ NO
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBEXT ;IF SET, POWER HAS FAILED
	BBS	#IO$V_NOWAIT,UCB$W_FUNC(R5),20$ ;IF SET, NO WAIT FOR REWIND
	WFIRLCH	RETREG,#60*7		;WAITFOR FINAL INTERRUPT
10$:	BRW	DRVREG			;
20$:	BISW	#UCB$M_MT_REWIND,UCB$W_DEVSTS(R5) ;SET REWIND IN PROGRESS
	CVTLW	MT_DS(R3),UCB$W_MT_DS(R5) ;SAVE DRIVE STATUS
	CLRW	UCB$W_MT_ER(R5)		;CLEAR SAVED ERROR STATUS
	ENBINT				;ENABLE INTERRUPTS
	BRW	RETREG			;

;
; TRANSFER FUNCTION EXECUTION
;
;	FUNCTIONS INCLUDE:
;
;		WRITE CHECK,
;		WRITE DATA,
;		READ DATA,
;		READ DATA REVERSE, AND
;		WRITECHECK DATA REVERSE.
;
; THE MAP REGISTERS, BYTE COUNT REGISTER, AND VIRTUAL ADDRESS REGISTERS ARE LOADED.
; THE FUNCTION IS INITIATED AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE INTERRUPT
; OCCURS FINAL DEVICE REGISTERS ARE RETURNED TO THE CALLER.
;

XFER:					;TRANSFER FUNCTION EXECUTION
	MCOML	#0,MBA$L_SR(R4)		;CLEAR MASSBUS ADAPTER ERRORS
	LOADMBA				;LOAD MAP, BYTE COUNT, AND VIRTUAL ADDRESS
	MOVZBL	UCB$B_CEX(R5),R0	;RETRIEVE FUNCTION TABLE INDEX
	CMPB	#CDF_READDATAR,R0	;READ DATA REVERSE?
	BEQL	10$			;IF EQL YES
	CMPB	#CDF_WRITECHECKR,R0	;WRITE CHECK DATA REVERSE?
	BNEQ	20$			;IF NEQ NO
10$:	MOVZWL	UCB$W_BCNT(R5),R1	;GET TRANSFER BYTE COUNT
	DECL	R1			;REDUCE BYTE COUNT BY ONE
	ADDL	R1,MBA$L_VAR(R4)	;CALCULATE ENDING ADDRESS OF BUFFER
20$:	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),ENBXIT ;IF SET, POWER FAILED
	MOVL	MBA$L_BCR(R4),MT_FC(R3)	;LOAD FRAME COUNT REGISTER
	MOVZBL	FTAB[R0],MT_CS1(R3)	;INITIATE FUNCTION
	WFIKPCH	RETREG,TIME_OUT[R0]	;WAITFOR INTERRUPT AND KEEP CHANNEL
	MOVL	MBA$L_SR(R4),UCB$L_MT_SR(R5) ;SAVE FINAL CONTROLLER STATUS
	INSV	#MT$K_NRZI_800,#MT$V_DENSITY,- ;SET CORRECT DENSITY CODE
		#MT$S_DENSITY,UCB$L_DEVDEPEND(R5) ;
	INSV	#3,#MT_TC_V_DEN,-	;
		#MT_TC_S_DEN,UCB$W_MT_TC(R5) ;
	BITL	#MT_DS_M_PES,MT_DS(R3)	;NRZI ENCODED TAPE?
	BEQL	DRVREG			;IF EQL YES
	INSV	#MT$K_PE_1600,#MT$V_DENSITY,- ;SWITCH TO PHASE ENCODED TAPE
		#MT$S_DENSITY,UCB$L_DEVDEPEND(R5) ;
	INSV	#4,#MT_TC_V_DEN,-	;
		#MT_TC_S_DEN,UCB$W_MT_TC(R5) ;
	BICW	#MT$M_PARITY,UCB$L_DEVDEPEND(R5) ;CLEAR EVEN PARITY
	BICW	#MT_TC_M_EPAR,UCB$W_MT_TC(R5) ;
DRVREG:					;SAVE DRIVE REGISTERS
	BSBW	TM_SAVDRVSTS		;SAVE DRIVE STATUS
	IOFORK				;CREATE FORK PROCESS
	BRB	RETREG			;

;
; ENABLE INTERRUPTS
;

ENBXIT:					;
	CVTLW	MT_ER(R3),UCB$W_MT_ER(R5) ;SAVE ERROR STATUS REGISTER
	CVTLW	MT_DS(R3),UCB$W_MT_DS(R5) ;SAVE DRIVE STATUS REGISTER
	CVTLW	MT_TC(R3),UCB$W_MT_TC_SAV(R5) ;SAVE TAPE CONTROL REGISTER
	CVTLW	MT_CS1(R3),UCB$W_MT_CS1(R5) ;SAVE DRIVE CONTROL REGISTER
	ENBINT				;ENABLE INTERRUPTS

;
; RETURN REGISTERS
;

	.ENABL	LSB
RETREG:					;RETURN FINAL DEVICE REGISTERS
	BBC	#MT_DS_V_PES,-		; If NOT at 1600 BPI, branch around
		UCB$W_MT_DS(R5),0$	;  dead track test.
	CMPZV	#0,#9,-			; Test for all 9 tracks dead.
		UCB$W_MT_CC_SAV(R5),-
		#^X<1FF>
	BNEQ	0$			; NEQ means all 9 tracks not dead.
	BISW	#MT_ER_M_INC,-		; Correct hardware glitch that doesn't
		UCB$W_MT_ER(R5)		;  set INC bit when all tracks dead.
0$:
	MOVZBL	UCB$B_CEX(R5),R1	;GET CURRENT FUNCTION INDEX
	BICW3	XTAB[R1],UCB$W_MT_ER(R5),R0 ;GET FINAL DRIVE ERROR STATUS
	MOVL	UCB$L_MT_SR(R5),R1	;RETRIEVE FINAL CONTROLLER STATUS
	MOVZWL	UCB$W_MT_DS(R5),R2	;RETRIEVE CONTENTS OF DRIVE STATUS REGISTER
	BITW	#UCB$M_POWER!-		;POWER FAIL OR DEVICE TIMEOUT?
		UCB$M_TIMOUT,UCB$W_STS(R5) ;
	BEQL	1$			; EQL implies NO special condition.
	BRW	70$			; NEQ implies YES - SPECIAL CONDITION
1$:
	CMPB	#CDF_WRITECHECK,UCB$B_CEX(R5) ;DRIVE RELATED FUNCTION?
	BGTRU	10$			;IF GTRU YES
	CMPB	#CDF_INTSPCFOR,UCB$B_CEX(R5) ;INTERNAL SPACE FUNCTION?
	BLEQ	5$			;IF LEQ YES
	CMPB	#CDF_READPRESET,UCB$B_CEX(R5) ;DRIVE RELATED FUNCTION?
	BLEQU	10$			;IF LEQU YES

;
; CONTROLLER RELATED FUNCTION
;

5$:	BITL	#MBA$M_ERROR,R1		;ANY CONTROLLER ERRORS?
	BEQL	50$			;IF EQL NO
	BITL	#MBA$M_SR_ERCONF!-	;ERROR CONFIRMATION OR,
		MBA$M_SR_ISTO!-		;INTERFACE SEQUENCE TIMEOUT OR,
		MBA$M_SR_PGE!-		;PROGRAMMING ERROR OR,
		MBA$M_SR_NED!-		;NONEXISTENT DRIVE, OR
		MBA$M_SR_RDTO,R1	;READ TIMEOUT?
	BNEQ	60$			;IF NEQ YES - FATAL CONTROLLER ERROR
	BITL	#MBA$M_SR_DLT!-		;DATA LATE OR,
		MBA$M_SR_INVMAP!-	;INVALID MAP REGISTER OR,
		MBA$M_SR_MAPPE!-	;MAP REGISTER PARITY ERROR OR,
		MBA$M_SR_MCPE!-		;MASSBUS CONTROL PARITY ERROR OR,
		MBA$M_SR_SPE!-		;MBA SILO PARITY ERROR OR,
		MBA$M_SR_MDPE!-		;MASSBUS DATA PARITY ERROR OR,
		MBA$M_SR_MXF!-		;MISSED TRANSFER OR,
		MBA$M_SR_RDS!-		;READ DATA SUBSTITUTE OR,
		MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER BYTE OR,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK UPPER BYTE?
	BNEQ	20$			;IF NEQ YES - RETRIABLE CONTROLLER ERROR

;
; DRIVE RELATED FUNCTION
;

10$:	CLRL	R1			;CLEAR CONTENTS OF STATUS REGISTER
	TSTW	R0			;ANY DRIVE ERRORS?
	BEQL	50$			;IF EQL NO
20$:	BITW	#MT_ER_M_ILF!-		;ILLEGAL FUNCTION OR,
		MT_ER_M_ILR!-		;ILLEGAL REGISTER OR,
		MT_ER_M_RMR!-		;REGISTER MODIFY REFUSE OR,
		MT_ER_M_UNS,R0		;DRIVE UNSAFE
	BNEQ	60$			;IF NEQ YES - FATAL DRIVE ERROR
	BBC	#MT_ER_V_NEF,R0,40$	;IF CLR, NOT NONEXECUTABLE FUNCTION
	CMPB	#CDF_READDATAR,UCB$B_CEX(R5) ;READ DATA REVERSE?
	BEQL	30$			;IF EQL YES
	CMPB	#CDF_SPCFILREV,UCB$B_CEX(R5) ;SPACE FILE REVERSE?
	BEQL	30$			;IF EQL YES
	CMPB	#CDF_SPCRECREV,UCB$B_CEX(R5) ;SPACE RECORD REVERSE?
	BEQL	30$			;IF EQL YES
	CMPB	#CDF_WRITECHECKR,UCB$B_CEX(R5) ;WRITECHECK REVERSE?
	BNEQ	60$			;IF NEQ NO
30$:	CLRW	UCB$W_MT_FC(R5)		;CLEAR SAVED FRAME COUNT REGISTER

;
; RETRIABLE ERROR EXIT
;

40$:	CVTWL	@UCB$L_DPC(R5),-(SP)	;GET BRANCH DISPLACEMENT
	ADDL	(SP)+,UCB$L_DPC(R5)	;CALCULATE RETURN ADDRESS - 2
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),60$ ;IF SET, RETRY INHIBITED
50$:	ADDL	#2,UCB$L_DPC(R5)	;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER

;
; FATAL CONTROLLER OR DRIVE ERROR
;	Here we log a device error (unless the only error is that the media
;		on the device is OFF-LINE) and then we branch to FATALERR.
;

60$:
	BBS	#MT_DS_V_MOL,R2,63$	; Branch to log error if media ON-LINE.
	CMPW	#MT_ER_M_UNS,R0		; Drive is OFF-LINE. See if ONLY error
					;  is UNSAFE.  If so, this implies
					;  ONLY error is that media is OFF-LINE.
	BEQL	66$			; Branch around logging of error if
					;  ONLY off-line.
63$:
	JSB	G^ERL$DEVICERR		; Log Device Error.
66$:
	BRW	FATALERR		;

;
; SPECIAL CONDITION ( POWER FAILURE OR DEVICE TIME OUT)
;

70$:	BICW	#UCB$M_MT_REWIND,UCB$W_DEVSTS(R5) ;CLEAR REWIND IN PROGRESS
	BISW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;SET POSITION LOST
	BBSC	#UCB$V_POWER,UCB$W_STS(R5),100$ ;IF SET, POWER FAILURE

;
; DEVICE TIME OUT
;

	BSBW	TM_SAVDRVSTS		; Save drive registers in UCB for ERROR LOGGING
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIME OUT
	MOVL	UCB$L_CRB(R5),R3	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R3),R3	;GET ADDRESS OF SECONDARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R3),R3 ;GET ADDRESS OF SECONDARY IDB
	CMPL	R5,IDB$L_OWNER(R3)	;DEVICE OWN CONTROLLER?
	BNEQ	80$			;IF NEQ NO
	DSBINT				;DISABLE INTERRUPTS
	MOVL	#MBA$M_CR_ABORT!MBA$M_CR_IE,- ;ABORT THE DATA TRANSFER
		MBA$L_CR(R4)		;
	WFIKPCH	75$,#15			;WAIT FOR ABORT AND KEEP CHANNEL
	IOFORK				;CREATE FORK PROCESS
75$:					;
	MOVL	#MBA$M_CR_INIT,MBA$L_CR(R4) ;INITIALIZE ENTIRE MBA
	MOVL	#MBA$M_CR_IE,MBA$L_CR(R4) ;ENABLE MBA INTERRUPTS
80$:	SETIPL	UCB$B_FIPL(R5)		;LOWER IPL TO DEVICE FORK LEVEL
	TSTL	UCB$L_MT_RECORD(R5)	; Timeouts on READS at BOT are due to
					;  lack of an ID burst that should NOT
					;  cause a CLEAR of UCB$M_VALID.
	BNEQ	90$			; If NOT at BOT than branch around.
	CMPB	#CDF_READDATA,-		; See if last function was a READ.
		UCB$B_CEX(R5)
	BEQL	TIMEOUT			; If YES, branch around clearing of
					;  volume valid bit.
90$:	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME SOFTWARE INVALID
TIMEOUT:				;
	MOVZWL	#SS$_TIMEOUT,R0		;SET FINAL COMPLETION STATUS

;
; RESET TRANSFER BYTE COUNT TO ZERO
;

RESETXFR:				;
	CLRW	UCB$W_MT_FC(R5)		;CLEAR SAVED FRAME COUNT
	CLRL	R2			;CLEAR DRIVE STATUS
	BRW	FUNCXT			;

;
; POWER FAILURE
;

99$:	BRW	200$			; Branch around to ABORT powerfail.
100$:	BBC	#UCB$V_VALID,UCB$W_STS(R5),90$ ;IF CLR, VOLUME SOFTWARE INVALID
	BISW	#UCB$M_MT_PWRFL,-	; Set flag that we are in REPOSITIONING
		UCB$W_DEVSTS(R5)	;  logic.  This is looked at in CANCEL.
102$:
	RELCHAN				;RELEASE ALL CHANNELS

;
; Try to initiate REWIND of the drive by issuing a hardware rewind command.
;

	REQPCHAN			; R4 => TM03 CSR.
	BBS	#UCB$V_MT_CNCLP,-	; See if IO$_CANCEL occurred while we
		UCB$W_DEVSTS(R5),99$	;  were in resource wait. If SO, branch.

	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R4) ;SELECT DRIVE
	MOVZBL	#F_DRVCLR!1,MT_CS1(R4)	;CLEAR DRIVE
	DSBINT
	BBSC	#UCB$V_POWER,-		; If another POWERFAIL, clear bit and
		UCB$W_STS(R5),104$	;  branch around.
	MOVZBL	#F_REWIND!MT_CS1_M_GO,-	; Initiate REWIND command, if the
		MT_CS1(R4)		;  hardware accepts it.
	WFIKPCH	103$,#2			; Wait for interrupt or for short
					;  timeout.  If we timeout before the
					;  rewind is completed the following
					;  wait loop will take care of this.

	IOFORK
103$:	SETIPL	UCB$B_FIPL(R5)		; Lower to FORK level in case we had
					;  the timeout.
	RELCHAN				; Release the channel.
	BRB	105$			; Branch around to await arrival at BOT.

104$:	ENBINT				; If we had another POWERFAIL,
	BRB	100$			;  branch back to try again.

;
; WAIT FOR UNIT TO BE REWOUND AND REACH BEGINNING OF TAPE
;

105$:	CLRB	UCB$B_CEX(R5)		;CLEAR MESSAGE TIME COUNTER
110$:	DSBINT				;DISABLE INTERRUPTS
	WFIKPCH	115$,#2			;WAITFOR INTERRUPT OR TIME OUT
	IOFORK				;CREATE FORK PROCESS
115$:	SETIPL	UCB$B_FIPL(R5)		;LOWER IPL TO FORK LEVEL
	REQPCHAN			;REQUEST PRIMARY CHANNEL
	BBS	#UCB$V_MT_CNCLP,-	; See if IO$_CANCEL occurred while we
		UCB$W_DEVSTS(R5),99$	;  were in resource wait. If SO, branch.

	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R4) ;SELECT DRIVE
	PUSHL	MT_DS(R4)		;SAVE DRIVE STATUS
	RELCHAN				;RELEASE ALL CHANNELS
	POPL	R2			;RETRIEVE SAVED DRIVE STATUS
	BBSC	#UCB$V_POWER,UCB$W_STS(R5),122$ ;IF SET, ANOTHER POWER FAILURE
	BBS	#MT_DS_V_PIP,R2,105$	;IF SET, POSITIONING IN PROGRESS
	BBC	#MT_DS_V_MOL,R2,120$	;IF CLR, MEDIUM OFFLINE
	BBS	#MT_DS_V_BOT,R2,125$	;IF SET, AT BEGINNING OF TAPE
120$:	ACBB	#15,#1,UCB$B_CEX(R5),110$ ;TIME TO OUTPUT MESSAGE?
	MOVZBL	#MSG$_DEVOFFLIN,R4	;SET MESSAGE NUMBER
	MOVAB	G^SYS$GL_OPRMBX,R3	;GET ADDRESS OF OPERATOR MAILBOX
	JSB	G^EXE$SNDEVMSG		;SEND MESSAGE TO OPERATOR
	BRB	105$			;

122$:	BRW	100$			; Branch back after another POWERFAIL.

;
; MEDIUM ONLINE AND UNIT POSITIONED TO BEGINNING OF TAPE
;

125$:
	MOVL	UCB$L_MT_ORGPOS(R5),-	; Force reposition to ORIGINAL value
		UCB$L_MT_RECORD(R5)	;  of UCB$L_MT_RECORD.

	MOVL	UCB$L_MT_RECORD(R5),UCB$L_SVAPTE(R5) ;SAVE TAPE POSITION
	CLRL	UCB$L_MT_RECORD(R5)	;CLEAR CURRENT POSITION
	REQPCHAN			;REQUEST PRIMARY CHANNEL
	BBS	#UCB$V_MT_CNCLP,-	; See if IO$_CANCEL occurred while we
		UCB$W_DEVSTS(R5),133$	;  were in resource wait. If SO, branch.

	MOVL	R4,R3			;SET ADDRESS OF DRIVE CONTROL REGISTER
130$:	REQSCHAN			;REQUEST SECONDARY CHANNEL
	BBC	#UCB$V_MT_CNCLP,-	; See if IO$_CANCEL occurred while we
		UCB$W_DEVSTS(R5),136$	;  were in resource wait. If NOT, branch.
133$:	BRW	200$			; If SO, branch around to abort operation.
136$:
	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R3) ;SET TAPE CONTROL PARAMETERS
	MOVZBL	#F_DRVCLR!1,MT_CS1(R3)	;CLEAR DRIVE
	CMPL	UCB$L_MT_RECORD(R5),UCB$L_SVAPTE(R5) ;TAPE CORRECTLY POSITIONED?
	BNEQ	138$			; NEQ implies NO, not yet done.
	BRW	180$			; Else branch to end.
138$:
	BSBW	TM_SETINTSPC		;SETUP MBA FOR INTERNAL SPACE FUNCTION
	DSBINT				;DISABLE INTERRUPTS
	BBS	#UCB$V_POWER,UCB$W_STS(R5),160$ ;IF SET, ANOTHER POWER FAILURE
	MOVZBL	#F_WRITECHECK!1,MT_CS1(R3) ;EXECUTE FUNCTION
	WFIKPCH	140$,#12		;WAIT FOR FUNCTION TO COMPLETE
	MOVL	MBA$L_SR(R4),UCB$L_MT_SR(R5) ;SAVE FINAL MBA STATUS
	BSBW	TM_SAVDRVSTS		;SAVE DRIVE STATUS
	IOFORK				;CREATE FORK PROCESS
140$:	SETIPL	UCB$B_FIPL(R5)		;LOWER IPL TO FORK LEVEL
	BBS	#UCB$V_POWER,UCB$W_STS(R5),170$ ;IF SET, ANOTHER POWER FAILURE
	BBS	#UCB$V_TIMOUT,UCB$W_STS(R5),155$ ;IF SET, DEVICE TIME OUT
	RELSCHAN			;RELEASE SECONDARY CHANNEL
	BICW3	XTAB+<CDF_INTSPCFOR*2>,UCB$W_MT_ER(R5),R0 ;GET DRIVE ERROR STATUS
	MOVL	UCB$L_MT_SR(R5),R1	;GET FINAL MBA STATUS
	MOVZWL	UCB$W_MT_DS(R5),R2	;GET FINAL DRIVE STATUS
	BICL	#MBA$M_SR_DLT!-		;CLEAR DATA LATE AND,
		MBA$M_SR_ATTN!-		;ATTENTION AND,
		MBA$M_SR_DTABT!-	;DATA TRANSFER ABORT AND,
		MBA$M_SR_DTCOMP!-	;DATA TRANSFER COMPLETE AND,
		MBA$M_SR_MBEXC!-	;MASSBUS EXCEPTION AND,
		MBA$M_SR_MXF!-		;MISSED TRANSFER AND,
		MBA$M_SR_WCKLWR!-	;WRITE CHECK LOWER AND,
		MBA$M_SR_WCKUPR,R1	;WRITE CHECK UPPER
	BNEQ	190$			;IF NEQ FATAL SPACING ERROR
	TSTW	R0			;ANY FATAL DRIVE ERRORS?
	BNEQ	190$			;IF NEQ YES
	BBS	#MT_DS_V_TM,R2,150$	;IF SET, TAPE MARK ENCOUNTERED
	BBS	#MT_DS_V_PES,R2,150$	; If at 1600 BPI, branch around test
					;  for minimum length record.
	CMPW	#MIN_RECORD,UCB$W_MT_FC(R5) ;MINIMUM RECORD READ?
	BLEQU	150$			; LEQ implies yes, minimum record read.
	BRW	130$			; Else branch back to read next.
150$:	INCL	UCB$L_MT_RECORD(R5)	;UPDATE CURRENT TAPE POSITION
	BRW	130$			;
155$:	BRW	90$			;

;
; POWER FAILURE DURING REPOSITIONING OF TAPE
;

160$:	ENBINT				;ENABLE INTERRUPTS
170$:	MOVL	UCB$L_SVAPTE(R5),UCB$L_MT_RECORD(R5) ;RESTORE TAPE POSITION
	BRW	102$			;

;
; TAPE SUCCESSFULLY REPOSITIONED - RESTART FUNCTION
;

180$:	RELCHAN				;RELEASE ALL CHANNELS
	BICW	#UCB$M_MT_PWRFL,-	; Clear flag signalling that we are
		UCB$W_DEVSTS(R5)	;  repositioning.
	BICW	#<MT$M_LOST@-16>,UCB$L_DEVDEPEND+2(R5) ;CLEAR LOST POSITION
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME VALID
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;RESTORE TRANSFER PARAMETERS
	BRW	TM_STARTIO		;

;
; FATAL SPACING ERROR DURING REPOSITIONING OF TAPE
;

190$:	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME SOFTWARE INVALID
	BICW	#UCB$M_MT_PWRFL,-	; Clear flag signalling that we are
		UCB$W_DEVSTS(R5)	;  repositioning.
	CLRW	UCB$W_MT_FC(R5)		;CLEAR SAVED FRAME COUNT
	BRW	FATALERR		;
200$:
	BICW	#UCB$M_MT_PWRFL!UCB$M_MT_CNCLP,-
		UCB$W_DEVSTS(R5)	; Clear flag signalling that we are
					;  repositioning AND that CANCEL was
					;  signalled.
	BICW	#UCB$M_VALID,-
		UCB$W_STS(R5)		; Set volume software invalid.
	CLRW	UCB$W_MT_FC(R5)		; Clear saved frame count
	MOVL	#SS$_ABORT,R0		; Set abort status.
	CLRL	R2			; Passed to FUNCXT.
	BRW	FUNCXT			;
	.DSABL	LSB
	.PAGE
	.SBTTL	TE16/TU77 CLASSIFY DRIVE TYPE AND SET PARAMETERS
;
; TM_DTYPE - TE16/TU77 CLASSIFY DRIVE TYPE AND SET PARAMETERS
;
; THIS ROUTINE IS CALLED WHEN AN UNSOLICITED INTERRUPT OCCURS ON A DRIVE, DURING
; SYSTEM INITIALIZATION, AND AT POWER RECOVERY TO DETERMINE THE DRIVE TYPE AND
; SET UNIT PARAMETERS.
;
; INPUTS:
;
;	R3 = ADDRESS OF TM03 DRIVE CONTROL REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE DRIVE STATUS REGISTER IS INTERROGATED AND UNIT PARAMETERS ARE SET.
;

TM_DTYPE:				;CLASSIFY DRIVE TYPE AND SET PARAMETERS
	PUSHL	MT_DT(R3)		;READ DRIVE TYPE REGISTER
	BICW	#^C<^X1FF>,(SP)		;CLEAR EXTRANEOUS BITS
	MOVAB	TM_DTDESC,R2		;GET ADDRESS OF DESCRIPTOR TABLE
10$:	CMPW	(SP),(R2)+		;DRIVE TYPE MATCH?
	BEQL	20$			;IF EQL YES
	ADDL	#TM_DTDESCLEN-2,R2	;ADVANCE TO NEXT ENTRY
	TSTW	(R2)			;END OF TABLE?
	BNEQ	10$			;IF NEQ NO
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT OFFLINE
	SUBL	#TM_DTDESCLEN-2,R2	;BACK UP TO LAST DRIVE DESCRIPTOR
20$:	MOVB	(R2),UCB$B_DEVTYPE(R5)	;SET DRIVE TYPE
	TSTL	(SP)+			;REMOVE DRIVE TYPE FROM STACK
	RSB				;
	.PAGE
	.SBTTL	TM03-TE16/TU77 REGISTER DUMP ROUTINE
;
; TM_REGDUMP - TM03-TE16/TU77 REGISTER DUMP ROUTINE
;
; THIS ROUTINE IS CALLED TO SAVE THE CONTROLLER AND DRIVE REGISTERS IN A
; SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR LOGGING ROUTINE AND
; FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
;
; INPUTS:
;
;	R0 = ADDRESS OF REGISTER SAVE BUFFER.
;	R4 = ADDRESS OF ADAPTER CONFIGURATION REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE CONTROLLER AND DRIVE REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
;

TM_REGDUMP:				;TM03-TE16/TU77 REGISTER DUMP ROUTINE
	MOVL	#<MT_TC+4+MBA$L_BCR+4+8>/4,(R0)+ ;INSERT NUMBER OF DEVICE REGISTERS
	MOVL	MBA$L_CSR(R4),(R0)+	;SAVE CONFIGURATION REGISTER
	MOVL	MBA$L_CR(R4),(R0)+	;SAVE CONTROL REGISTER
	MOVL	UCB$L_MT_SR(R5),(R0)+	;SAVE STATUS REGISTER
	MOVL	MBA$L_VAR(R4),(R0)+	;SAVE VIRTUAL ADDRESS REGISTER
	MOVL	MBA$L_BCR(R4),(R0)+	;SAVE BYTE COUNT REGISTER
	EXTZV	#9,#8,-8(R0),R1		;GET FINAL MAP REGISTER NUMBER
	MOVL	MBA$L_MAP(R4)[R1],(R0)+	;SAVE FINAL MAP REGISTER CONTENTS
	CLRL	(R0)+			;ASSUME NO PREVIOUS MAP REGISTER
	DECL	R1			;CALCULATE PREVIOUS MAP REGISTER NUMBER
	BLSS	10$			;IF LSS NONE
	MOVL	MBA$L_MAP(R4)[R1],-4(R0) ;SAVE PREVIOUS MAP REGISTER CONTENTS
10$:	MOVZBL	#<MT_TC>/4-3,R1		;SET NUMBER OF DRIVE REGISTERS TO SAVE
	MOVL	UCB$L_CRB(R5),R2	;GET ADDRESS OF PRIMARY CRB
	ADDL3	#3*4,@CRB$L_INTD+VEC$L_IDB(R2),R2 ;GET ADDRESS OF TM03-TE16/TU77 REGISTERS
	MOVZWL	UCB$W_MT_CS1(R5),(R0)+	;SAVE DRIVE CONTROL REGISTER
	MOVZWL	UCB$W_MT_DS(R5),(R0)+	;SAVE DRIVE STATUS REGISTER
	MOVZWL	UCB$W_MT_ER(R5),(R0)+	;SAVE DRIVE ERROR REGISTER
20$:	MOVL	(R2)+,(R0)+		;SAVE DRIVE REGISTER
	SOBGTR	R1,20$			;ANY MORE TO SAVE?
	MOVZWL	UCB$W_MT_CC_SAV(R5),-	; Move previously saved register
		MT_CC-MT_TC(R0)		;  contents back to where it should go.
	MOVZWL	UCB$W_MT_TC_SAV(R5),(R0)+ ;SAVE TAPE CONTROL REGISTER
	RSB				;
	.PAGE
	.SBTTL	TM03-TE16/TU77 TAPE DRIVE INITIALIZATION
;
; TM_TXXX_INIT - TM03-TE16/TU77 TAPE DRIVE INITIALIZATION
;
; THIS ROUTINE IS CALLED AT SYSTEM INITIALIZATION AND AT POWER RECOVERY TO SET
; DRIVE PARAMETERS.
;
; INPUTS:
;
;	R3 = ADDRESS OF TM03 DRIVE CONTROL REGISTER.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	UNIT PARAMETERS ARE ESTABLISHED.
;

TM_TXXX_INIT:				;TE16/TU77 TAPE DRIVE INITIALIZATION
	SUBL3	R4,R3,R2		;CALCULATE OFFSET TO DRIVE CONTROL REGISTER
	MOVAB	-MBA$L_ERB(R2),R2	;SUBTRACT OUT EXTERNAL REGISTER BASE
	DIVW3	#1@7,R2,UCB$B_SLAVE(R5)	;SET ADAPTER DRIVE NUMBER
	MULB3	#1@7/4,UCB$B_SLAVE(R5),UCB$B_SLAVE+1(R5) ;SET DRIVE OFFSET CONSTANT
	INSV	UCB$W_UNIT(R5),#0,#3,UCB$W_MT_TC(R5) ;INSERT UNIT NUMBER
	MOVZBL	#F_DRVCLR!1,MT_CS1(R3)	;CLEAR DRIVE
	MOVZWL	UCB$W_STS(R5),-(SP)	;SAVE CURRENT UNIT STATUS
	PUSHL	MBA$L_SR(R4)		;READ MBA STATUS REGISTER
	BICW	#UCB$M_MT_PRVMOL,UCB$W_DEVSTS(R5) ;CLEAR PREVIOUS MOL STATE
	BICW	#UCB$M_ONLINE!UCB$M_VALID,UCB$W_STS(R5) ;SET UNIT OFFLINE/INVALID
	BBS	#MBA$V_SR_NED,(SP),30$	;IF SET, NONEXISTENT TM03
	MOVZWL	UCB$W_MT_TC(R5),MT_TC(R3) ;SELECT SLAVE DRIVE
	BICL3	#^C<^XFE00>,MT_DT(R3),R2 ;ISOLATE HIGH PART OF DRIVE TYPE
	CMPW	#^XC400,R2		;TAPE DRIVE AND SLAVE PRESENT?
	BNEQ	20$			;IF NEQ NO
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	BSBW	TM_DTYPE		;CLASSIFY DRIVE TYPE
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),20$ ;IF CLR, UNKNOWN DRIVE TYPE
	ASHL	#31-MT_DS_V_MOL,MT_DS(R3),R2 ;MEDIUM CURRENTLY ONLINE?
	BGEQ	15$			;IF GEQ NO
	BISW	#UCB$M_MT_PRVMOL,UCB$W_DEVSTS(R5) ;SET PREVIOUS MOL STATE
15$:	BBC	#UCB$V_VALID,4(SP),20$	;IF CLR, VOLUME SOFTWARE INVALID
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME SOFTWARE VALID
20$:	MOVZBL	#F_DRVCLR!1,MT_CS1(R3)	;CLEAR DRIVE
30$:	BISL3	(SP)+,(SP)+,MBA$L_SR(R4) ;CLEAR MBA STATUS
	RSB				;
	.PAGE
	.SBTTL	TM03-TE16/TU77 UNSOLICITED INTERRUPT PROCESSING
;
; TM_UNSOLNT - TM03-TE16/TU77 UNSOLICITED INTERRUPT PROCESSING
;
; THIS ROUTINE IS CALLED WHEN AN UNSOLICITED INTERRUPT IS RECEIVED FOR A SLAVE
; DRIVE.
;
; INPUTS:
;
;	R4 = ADDRESS OF TM03 DRIVE CONTROL REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE UNIT STATUS AND DRIVE TYPE IS ESTABLISHED.
;

TM_UNSOLNT:				;UNSOLICITED INTERRUPT PROCESSING
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT OFFLINE
	BICL3	#^C<^XFE00>,MT_DT(R4),R2 ;ISOLATE HIGH PART OF DRIVE TYPE
	CMPW	#^XC400,R2		;TAPE DRIVE AND SLAVE PRESENT?
	BNEQ	10$			;IF NEQ NO
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5) ;SET UNIT ONLINE
	MOVL	R4,R3			;SET ADDRESS OF TM03 DRIVE CONTROL REGISTER
	BSBW	TM_DTYPE		;CLASSIFY DRIVE TYPE
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),10$ ;IF CLR, UNKNOWN DRIVE TYPE
	BBC	#DEV$V_MNT,UCB$L_DEVCHAR(R5),5$ ;BRANCH IF NOT MOUNTED
	BBC	#DEV$V_FOR,UCB$L_DEVCHAR(R5),5$ ;BRANCH IF NOT FOREIGN
					;TAPE IS MOUNTED FOREIGN, SO...
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;SET VOLUME VALID
	BRB	20$
5$:	BBS	#UCB$V_POWER,UCB$W_STS(R5),20$ ;IF SET, POWER FAILURE
10$:	BICW	#UCB$M_VALID,UCB$W_STS(R5) ;CLEAR VOLUME SOFTWARE VALID
20$:	MOVZBL	#F_DRVCLR!1,MT_CS1(R4)	;CLEAR DRIVE
	RSB				;
	.PAGE
	.SBTTL	TM03-TE16/TU77 DRIVE STATUS SAVE ROUTINE
;
; TM_SAVDRVSTS - TM03-TE16/TU77 DRIVE STATUS SAVE ROUTINE
;
; THIS ROUTINE IS CALLED FROM DEVICE INTERRUPT LEVEL TO SAVE FINAL DRIVE REGISTERS
; AND THEN CLEAR THE DRIVE.
;
; INPUTS:
;
;	R3 = ADDRESS OF DRIVE CONTROL STATUS REGISTER 1.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE FINAL DRIVE REGISTERS ARE SAVED AND THE DRIVE IS CLEARED.
;

TM_SAVDRVSTS:				;SAVE DRIVE STATUS
	CVTLW	MT_FC(R3),UCB$W_MT_FC(R5) ;SAVE FRAME COUNT REGISTER
	CVTLW	MT_ER(R3),UCB$W_MT_ER(R5) ;SAVE ERROR STATUS REGISTER
	CVTLW	MT_DS(R3),UCB$W_MT_DS(R5) ;SAVE DRIVE STATUS REGISTER
	CVTLW	MT_TC(R3),UCB$W_MT_TC_SAV(R5) ;SAVE TAPE CONTROL REGISTER
	CVTLW	MT_CS1(R3),UCB$W_MT_CS1(R5) ;SAVE DRIVE CONTROL REGISTER
	CVTLW	MT_CC(R3),UCB$W_MT_CC_SAV(R5)	; Save Check Character Register.
	MOVZBL	#F_DRVCLR!1,MT_CS1(R3)	;CLEAR DRIVE
	RSB				;
	.PAGE
	.SBTTL	TM03-TE16/TU77 SETUP MBA FOR INTERNAL SPACING FUNCTION
;
; TM_SETINTSPC - TM03-TE16/TU77 SETUP MBA FOR INTERNAL SPACING FUNCTION
;
; THIS ROUTINE IS CALLED TO SETUP THE MBA REGISTERS FOR AN INTERNAL SPACING
; FUNCTION THAT USES THE INTERRUPT STACK AS A WRITECHECK BUFFER.
;
; INPUTS:
;
;	R3 = ADDRESS OF DRIVE CONTROL STATUS REGISTER 1.
;	R4 = ADDRESS OF MBA CONFIGURATION STATUS REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	THE MBA MAP REGISTERS, BYTE COUNT REGISTER, AND VIRTUAL ADDRESS REGISTER
;	IS LOADED WITH VALUES THAT MAP ONE PAGE OF THE INTERRUPT STACK.
;

TM_SETINTSPC:				;SETUP MBA FOR INTERNAL SPACING FUNCTION
	MOVQ	UCB$L_SVAPTE(R5),-(SP)	;SAVE CURRENT TRANSFER PARAMETERS
	CLRW	UCB$W_BOFF(R5)		;CLEAR BYTE OFFSET IN PAGE
	MOVW	#512,UCB$W_BCNT(R5)	;SET TRANSFER BYTE COUNT
	MOVL	G^MMG$GL_SPTBASE,R0	;GET BASE ADDRESS OF SYSTEM PAGE TABLE
	MOVAB	TM$DDT,R1		;GET STARTING ADDRESS OF DRIVER
	EXTZV	S^#VA$V_VPN,S^#VA$S_VPN,R1,R1 ;EXTRACT SYSTEM VIRTUAL PAGE NUMBER
	MOVAL	(R0)[R1],UCB$L_SVAPTE(R5) ;SET STARTING PTE ADDRESS
	MCOML	#0,MBA$L_SR(R4)		;CLEAR MBA STATUS REGISTER
	LOADMBA				;LOAD MBA MAPPING REGISTERS
	MOVQ	(SP)+,UCB$L_SVAPTE(R5)	;RESTORE CURRENT TRANSFER PARAMETERS
	RSB				;
	.PAGE
	.SBTTL	TM03-TE16/TU77 SLAVE CONTROLLER INTERRUPT DISPATCHER
;+
; TM$INT - TM03-TE16/TU77 SLAVE CONTROLLER INTERRUPT DISPATCHER
;
; THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT OCCURS ON A
; TM03-TE16/TU77 SLAVE CONTROLLER. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = ADDRESS OF IDB ADDRESS.
;	04(SP) = SAVED R2.
;	08(SP) = SAVED R3.
;	12(SP) = SAVED R4.
;	16(SP) = SAVED R5.
;	20(SP) = INTERRUPT PC.
;	24(SP) = INTERRUPT PSL.
;
; INTERRUPT DISPATCHING OCCURS AS FOLLOWS:
;
;	IF THE INTERRUPTING CONTROLLER IS CURRENTLY OWNED AND THE OWNER UNIT IS
;	EXPECTING AN INTERRUPT, THEN THAT UNIT IS DISPATCHED FIRST. ALL OTHER
;	UNITS ARE DISPATCHED BY SELECTING THE CORRESPONDING SLAVE DRIVE, READING
;	ITS STATUS, AND DISPATCHING IF AN ATTENTION CONDITION EXISTS. AS EACH UNIT
;	IS FOUND, A TEST IS MADE TO DETERMINE IF AN INTERRUPT IS EXPECTED ON THE
;	UNIT. IF YES, THEN THE DRIVER IS CALLED AT ITS INTERRUPT RETURN ADDRESS.
;	ELSE THE DRIVER IS CALLED AT ITS UNSOLICITED INTERRUPT ADDRESS. AS EACH
;	CALL TO THE DRIVER RETURNS, THE NEXT SLAVE UNIT IS SELECTED AND AN ATTEMPT
;	IS MADE TO DISPATCH THAT UNIT. WHEN ALL UNITS HAVE BEEN SELECTED AND NO
;	ATTENTION CONDITIONS REMAIN, THE INTERRUPT IS DISMISSED.
;-

TM$INT::				;TM03-TE16/TU77 SLAVE CONTROLLER INTERRUPT DISPATHCER
	MOVL	@(SP),R3		;GET ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;GET ADDRESS OF TM03-TE16/TU77 REGISTERS
; Here we clear the attention summary bit corresponding to the MASSBUS port
;	number of this TM03.  To do this we obtain a pointer to the MBA-CSR
;	indirectly thru the IDB=>ADP.  With the TM03-CSR address in hand,
;	we subtract to determine the distance of the TM03-CSR to the base
;	of the MBA external registers.  This difference divided by 128
;	(or right shifted by 7) gives the port number of interest.
;	Writing a 1 into the corresponding bit position of the attention
;	summary register clears the bit. NOTE- this addition was made
;	necessary by the addition of TM78 support in the MASSBUS interrupt
;	dispatcher (MBAINTDSP).  In effect all Device Drivers for MASSBUS
;	multi-device controllers now have the responsibility of clearing
;	their attention bit.

	ASSUME	ADP$L_CSR  EQ  0
	MOVL	@IDB$L_ADP(R3),R5	; R5 => MBA-CSR
	MOVAB	MBA$L_ERB(R5),R2	; R2 => BASE OF MBA EXTERNAL REGISTERS
	SUBL3	R2,R4,R2		; R2 = DISTANCE OF TM03-CSR FROM BASE
	ASHL	#-7,R2,R2		; R2 = MBA PORT NUMBER.
	ASHL	R2,#1,MBA$L_AS(R5)	; CLEAR ATTENTION SUMMARY BIT.
	PUSHL	MT_TC(R4)		;SAVE CONTENTS OF TAPE CONTROL REGISTER
	MOVL	IDB$L_OWNER(R3),R5	;GET OWNER UCB ADDRESS
	BEQL	10$			;IF EQL NONE
	BBCC	#UCB$V_INT,UCB$W_STS(R5),10$ ;IF CLR, INTERRUPT NOT EXPECTED
	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER
10$:	CLRL	R2			;SET STARTING UNIT NUMBER
20$:	MOVL	@4(SP),R3		;RETRIEVE ADDRESS OF IDB
	MOVL	IDB$L_CSR(R3),R4	;RETRIEVE ADDRESS OF TM03-TE16/TU77 REGISTERS
	MOVL	R2,MT_TC(R4)		;SELECT NEXT SLAVE UNIT
	MOVL	IDB$L_UCBLST(R3)[R2],R5	;GET ADDRESS OF UCB
	BEQL	60$			;IF EQL NONE
	MOVL	MT_DS(R4),R3		;READ SLAVE DRIVE STATUS
 
;+
; POLL STATUS FOR ATTENTION CONDITIONS
;
; THE SEQUENCE IN WHICH ATTENTION CONDITIONS ARE POLLED IS CRITICAL.
; DUE TO AN ERROR IN THE TE-16 DRIVE DESIGN, THE ATTEMPT TO RESET AN
; ATTENTION CONDITION WITH DRIVE-CLEAR, WHILE REWINDING, RESULTS IN
; AN RMR ERROR (REGISTER MODIFICATION REFUSED). SINCE ALL ERRORS ARE
; CLEARED WITH DRIVE-CLEAR, RMR IS REASSERTED SWAMPING THE SYSTEM
; WITH INTERRUPTS UNTIL THE REWIND COMPLETES.
;
; TO AVOID THIS CONDITION, NO ATTENTION CONDITIONS ARE SERVICED IF
; PIP IS SET FOR THE DRIVE. THIS HAS THE EFFECT OF BLOCKING INTERR-
; UPTS FROM OTHER DRIVES BUT IS PREFERRABLE TO LOCKING UP THE ENTIRE
; SYSTEM. THE CORRECT REMEDY IS TO FIX THE PROBLEM IN THE DRIVE ELEC-
; TRONICS BY BLOCKING ALL ATTENTION CONDITIONS UNTIL REWIND IS DONE
; (AS FOR THE TU-77). UNDER THESE CONDITIONS, PIP SHOULD NEVER OCCUR
; IN CONJUNCTION WITH OTHER ATTENTION CONDITIONS.
;
;-
 
	BBS	#MT_DS_V_SLA,R3,30$	;IF SET, SLAVE TRANSITION TO ONLINE
	BBC	#MT_DS_V_MOL,R3,40$	;IF CLR, MEDIUM OFFLINE
	BBS	#MT_DS_V_PIP,R3,70$	;IF SET POSITIONING IN PROGRESS
	BBC	#MT_DS_V_BOT,R3,70$	;IF CLR, NOT AT BEGINNING OF TAPE
	BICW	#UCB$M_MT_REWIND,UCB$W_DEVSTS(R5) ;CLEAR REWIND IN PROGRESS
	BBCC	#UCB$V_INT,UCB$W_STS(R5),60$ ;IF CLR, INTERRUPT NOT EXPECTED
	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVER CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER
	BRB	10$			;
30$:	BISW	#UCB$M_MT_PRVMOL,UCB$W_DEVSTS(R5) ;SET PREVIOUS MOL STATE
	BICW	#UCB$M_MT_REWIND,UCB$W_DEVSTS(R5) ;CLEAR REWIND IN PROGRESS
	BSBW	TM_UNSOLNT		;CALL UNSOLICITED INTERRUPT ENTRY
	BRB	10$			;
40$:	BBCC	#UCB$V_MT_PRVMOL,UCB$W_DEVSTS(R5),70$ ;IF CLR, PREVIOUSLY OFFLINE
	BICW	#UCB$M_MT_REWIND,UCB$W_DEVSTS(R5) ;CLEAR REWIND IN PROGRESS
	MOVZWL	UCB$W_STS(R5),-(SP)	;SAVE CURRENT DRIVE STATUS
	BSBW	TM_UNSOLNT		;CALL UNSOLICITED INTERRUPT ENTRY
	BBC	#UCB$V_VALID,(SP),45$	;DON'T RESET VOLUME VALID IF FLAG WAS CLEAR
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ;RESET SOFTWARE VOLUME VALID
45$:	ADDL	#4,SP			;CLEAN THE STACK
	BRB	10$			;
60$:	MOVZBL	#F_DRVCLR!1,MT_CS1(R4)	;CLEAR DRIVE
70$:	AOBLEQ	#7,R2,20$		;ANY MORE SLAVE UNITS TO SCAN?
	ASHL	#31-MT_DS_V_SSC,MT_DS(R4),R2 ;ANY SLAVE CHANGE STATUS
	BLSS	10$			;IF LSS YES
	POPL	MT_TC(R4)		;RESTORE CONTENTS OF TAPE CONTROL REGISTER
	ADDL	#4,SP			;CLEAN STACK
	MOVQ	(SP)+,R2		;RESTORE REGISTERS
	MOVQ	(SP)+,R4		;
	REI				;
TM_END:					;ADDRESS OF LAST LOCATION IN DRIVER

	.END
