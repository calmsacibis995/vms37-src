	.TITLE	SHODEV - DISPLAY DEVICE DATABASE TOPOLOGY
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; Facility:  System generation and initialization
;
; Abstract: This module contains routines to show the device database
;	topology.
;
; Environment:
;
; Author:  Len Kawell, Creation date:  14-JUL-1978
;
; Modification History:
;
;	V02-006	JLV0136		Jake VanNoy		31-Dec-1981
;		Added SHOW/DRIVER command. Remove WRITE_OUT and replace
;		with calls to RIO$OUTPUT_LINE.
;
;	V02-005	JLV0040		Jake VanNoy		13-Jul-1981
;		Added G^ to LIB$ calls.
;
;	V04	JLV0002		Jake VanNoy		9-Feb-1981
;		Changed psects to allow paged and non-paged segments
;		is SYSGEN image. Add SHOW/CONFIGURATION and 
;		CONFIGURE.
;
;	V03	SRB0001		Steve Beckhardt	26-Sep-1979
;		Fixed bug in BOO$SHODEV_ALL
;
;	V02	LMK0001		Len Kawell	29-DEC-1978
;		Fixup error handling.
;
;--

;
; LOCAL MACROS
;
	.MACRO	STRING_DESC STRING,?L1,?L2
	.LONG	L2-L1
	.LONG	L1
L1:
	.ASCII	\STRING\
L2:
	.ENDM	STRING_DESC

;
; EXTERNAL SYMBOLS
;
	$DPTDEF				;DRIVER PROLOGUE DEFINTIONS
	$DDBDEF				;DDB DEFINITIONS
	$UCBDEF				;UCB DEFINITIONS
	$CRBDEF				;CRB DEFINITIONS
	$VECDEF				;INTERRUPT VECTOR DEFINITIONS
	$TPADEF				;TPARSE DEFINTIONS
;
; EQUATED VALUES:
;
	CR=13				; CHARACTER CODE FOR CARRIAGE RETURN
	LF=10				; CHARACTER CODE FOR LINEFEED
;
; OWN STORAGE
;
	.PSECT	PAGED_DATA	rd,wrt,noexe,quad

HEADER:					;PAGE HEADER
	.ASCII	<CR><LF>
	.ASCII	/__Driver___/
	.ASCII	/__Start__/
	.ASCII	/__End___/
HEADER2:
	.ASCII	/_Dev_/
	.ASCII	/__DDB____/
	.ASCII	/__CRB____/
	.ASCII	/__IDB____/
	.ASCII	/_Unit/
	.ASCII	/__UCB____/
HEADER_LEN=.-HEADER
HEADER_LEN2=HEADER2-HEADER

DRIVER_FAO:				;DRIVER FAO DESCRIPTOR
	STRING_DESC	<!10AC !XL !XL>
DDB_FAO:				;DDB FAO DESCRIPTOR
	STRING_DESC	<!3(_)     !AC !XL !XL !XL>
UCB_FAO:				;UCB FAO DESCRIPTOR
	STRING_DESC	<!7(_)    !4UB !XL>

OUTBUF_DESC:				;OUTPUT BUFFER DESCRIPTOR
	.LONG	OUTBUF_LEN
	.LONG	OUTBUF



OUTBUF_SIZE:				;OUTPUT BUFFER SIZE
	.BLKL	1
OUTBUF:					;OUTPUT BUFFER
	.BLKB	128
OUTBUF_LEN=.-OUTBUF
	.PAGE
	.SBTTL	DISPLAY DEVICE DATABASE TOPOLOGY
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine displays the names and addresses of one or all the
;	drivers, DDBs, CRBs, IDBs, and UCBs.
;
; CALLING SEQUENCE:
;
;	CALL BOO$SHODEV(PARMBLK) ;Called as a TPARSE action routine
;				 ; TPA$L_TOKENPTR(AP) is driver name descriptor
;
;	CALL BOO$SHODEV_ALL(PARMBLK) ;Called as a TPARSE action routine
;
;	SHOW/DEVICE is called with 0 in TPA$L_PARAM(AP)
;	SHOW/DRIVER is called with 1 in TPA$L_PARAM(AP)
;
;--
	.PSECT	PAGED_CODE	rd,nowrt,exe,long
	.ENABL	LSB
BOO$SHODEV_ALL::
	.WORD	0
	CLRL	TPA$L_TOKENCNT(AP)	;MAKE ANYTHING MATCH
	BRB	10$

BOO$SHODEV::
	.WORD	0
10$:	$CMEXEC_S W^DEVTOP_DISP,(AP)	;DO IT ALL IN EXEC MODE
	BLBS	R0,20$			;BR IF SUCCESS
	PUSHL	R0			;SET ERROR ARG
	CALLS	#1,G^LIB$SIGNAL		;SIGNAL THE ERROR
20$:	MOVL	#1,R0			;SET SUCCESS FOR PARSER
	RET

	.DSABL	LSB


;
; DISPLAY THE HEADER
;
DEVTOP_DISP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVC	#HEADER_LEN,W^HEADER,-
		W^RIO$AB_BUFFER		   	;PUT HEADER IN OUTPUT BUFFER
	MOVZBW	#HEADER_LEN,W^RIO$GW_OUTLEN	;SET SIZE OF STRING
	BLBC	TPA$L_PARAM(AP),10$	   	;BRANCH IF SHOW/DEVICE
	MOVZBW	#HEADER_LEN2,W^RIO$GW_OUTLEN	;SET SIZE OF STRING FOR SHOW/DRIVER

10$:	BSBW	RIO$OUTPUT_LINE			;WRITE IT TO OUTPUT DEVICE
;
; DISPLAY THE DRIVER INFO
;
	MOVL	G^IOC$GL_DPTLIST,R11	;GET ADDR OF FIRST DRIVER

DISP_DRIV:
	CMPC	TPA$L_TOKENCNT(AP),@TPA$L_TOKENPTR(AP),- ;NAMES MATCH?
		DPT$T_NAME+1(R11)
	BEQL	10$			;BR IF YES
	BRW	NEXT_DRIV		;ELSE CHECK NEXT DRIVER

10$:	MOVZWL	DPT$W_SIZE(R11),R0	;GET SIZE OF DRIVER
	ADDL2	R11,R0			;SET ADDR OF END OF DRIVER
	MOVAL	DPT$T_NAME(R11),R1	;SET ADDR OF DRIVER NAME

	$FAO_S	CTRSTR = W^DRIVER_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = R1,-
		P2     = R11,-
		P3     = R0

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE
	BLBC	TPA$L_PARAM(AP),20$	;BRANCH IF SHOW/DEVICE
	BRW	NEXT_DRIV		;SHOW/DRIVER - END OF DISPLAY
;
; DISPLAY THE DEVICE INFO
;
20$:	MOVAB	DPT$T_NAME(R11),R7	;GET ADDR OF DRIVER NAME
	MOVZBL	(R7)+,R6		;GET SIZE OF DRIVER NAME
	MOVL	G^IOC$GL_DEVLIST,R10	;GET ADDR OF FIRST DDB
DISP_DDB:
	MOVAL	DDB$T_DRVNAME(R10),R1	;GET ADDR OF DRIVER NAME
	MOVZBL	(R1)+,R0		;GET SIZE OF DRIVER NAME
	CMPC5	R0,(R1),#0,R6,(R7)	;DOES DRIVER NAME MATCH?
	BEQL	10$			;BR IF YES
	BRW	NEXT_DDB		;ELSE - GET ADDR OF NEXT DDB
10$:	MOVL	DDB$L_UCB(R10),R9	;GET ADDR OF FIRST UCB
	MOVL	UCB$L_CRB(R9),R0	;GET ADDR OF CRB

	MOVAL	DDB$T_NAME(R10),R1
	$FAO_S	CTRSTR = W^DDB_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = R1,-
		P2     = R10,-
		P3     = R0,-
		P4     = CRB$L_INTD+VEC$L_IDB(R0) ;SET ADDR OF IDB

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE
;
; DISPLAY THE UCB INFO
;
DISP_UCB:

	$FAO_S	CTRSTR = W^UCB_FAO,-
		OUTBUF = W^RIO$AB_OUTBUF,-
		OUTLEN = W^RIO$GW_OUTLEN,-
		P1     = UCB$W_UNIT(R9),-
		P2     = R9

	BSBW	RIO$OUTPUT_LINE		;WRITE IT TO OUTPUT DEVICE
;
; FIGURE OUT WHAT TO DISPLAY NEXT
;
	MOVL	UCB$L_LINK(R9),R9	;GET ADDR OF NEXT UCB
	BNEQ	DISP_UCB		;BR IF THERE IS ONE
NEXT_DDB:				;FIND NEXT DDB
	MOVL	DDB$L_LINK(R10),R10	;GET ADDR OF NEXT DDB
	BNEQ	DISP_DDB		;BR IF THERE IS ONE
NEXT_DRIV:				;FIND NEXT DRIVER
	MOVL	DPT$L_FLINK(R11),R11	;GET ADDR OF NEXT DRIVER
	CMPL	R11,#IOC$GL_DPTLIST	;END OF DRIVER LIST?
	BEQL	10$			;BR IF YES
	BRW	DISP_DRIV		;ELSE - DISPLAY NEXT DRIVER
	
10$:
	MOVL	#1,R0			;SET SUCCESS
	RET

	.END
