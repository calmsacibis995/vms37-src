	.TITLE	LOADER - LOAD A DRIVER AND/OR DEVICE CONTROL BLOCKS
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSGEN
;
; ABSTRACT:	LOAD A DRIVER AND/OR DEVICE CONTROL BLOCKS
;
;
; ENVIRONMENT:	USER MODE PRIVILEGED CODE
;
; AUTHOR:	LEN KAWELL, CREATION DATE:16-JUN-1978
;
; MODIFICATION HISTORY:
;	
;	V02-025	JLV0181		Jake VanNoy		12-FEB-1982
;		Fix to CAS0033 that broke autoconfigure of more than
;		17 DZ11's.
;
;	V02-024	JLV0163		Jake VanNoy		19-Jan-1982
;		Redid iogen$loader logic to allow UDA autoconfigure.
;
;	V02-023	JLV0146		Jake VanNoy		4-Jan-1982
;		Change IOC$RELOC_DDT_FDT to IOC$RELOC_DDT.
;
;	V02-022	JLV132		Jake VanNoy		31-Dec-1981
;		Add code to allow new CI type drivers.
;
;	V02-021	ROW0035		Ralph O. Weber		26-OCT-1981
;		Change usage of DDT$L_UNITINIT in LOAD_DB to assume that the 
;		cell contains a system virtual address.
;
;	V02-020 CAS0033		C. A. Samuelson		14-Sep-1981
;		Add support for 2nd TU58 on 11/730 Console.
;
;	V02-019	JLV0084		Jake VanNoy		11-Sep-1981
;		Relocate driver on every UCB create, rather than
;		on CRB create.
;
;	V02-018	JLV0057		Jake VanNoy		30-Jul-1981
;		Added zeroing of UCB$W_IRPSIZE in UCB initialization.
;
;	V02-017 JLV0048		Jake VanNoy		16-Jul-1981
;		Added call to IOC$RELOC_DDT_FDT. Add initialization
;		of UCB$L_DDT field.
;
;	V02-016	JLV0022		Jake VanNoy		10-Jun-1981
;		Added call to SGN$GET_DEVICE. Added a check to make
;		sure that MAXUNITS too large doesn't overflow a word
;		size.
;
;	V15	JLV0005		Jake VanNoy		30-Mar-1981
;		Fix a bug in DB_ERROR code path to correct clearing
;		UCB_BLINK when it doesn't exist (under the MAXUNITS
;		error.) Set up driver preloading. Store ACF$W_CVECTOR 
;		in IDB$B_VECTOR (for DMF32).
;
;	V14	JLV003		Jake VanNoy		26-Feb-1981
;		Fix bug in CONNECT TTcn: that initializes TT_STATE
;		field to unit number.
;
;	V13	JLV0002		Jake VanNoy		9-Feb-1981
;		Changed psects to allow paged and non-paged segments
;		is SYSGEN image. Add SHOW/CONFIGURATION and 
;		CONFIGURE.
;
;	V12	TCM0001		Trudy C Matthews	18-Sep-1980
;		Changed references to routine IOGEN$TEST_CSR to reference
;		EXE$TEST_CSR instead.
;
;	V11	NPK002		N. KRONENBERG 	8-JAN-1980
;		CORRECTED BUG IN CHECK FOR VECTOR IN USE.
;
;	V10	ADE0004		A.ELDRIDGE	14-OCT-1979
;		ZEROED THE IDB$L_CSR,IDB$L_ADP, AND VEC$L_ADP FIELDS
;		FOR SOFTWARE ONLY DEVICES.
;
;	V09	SRB0002		STEVE BECKHARDT	7-SEP-1979
;		ADDED SUPPORT FOR UNIT INITIALIZATION ROUTINE SPECIFIED IN DDT.
;
;	V08	SRB0001		STEVE BECKHARDT	4-SEP-1979
;		ADDED SUPPORT FOR CONNECTING CONSOLE BLOCK STORAGE
;		DEVICE.
;
;	V07	ADE003		A.ELDRIDGE	6-AUG-1979
;		ADDED SUPPORT FOR SOFTWARE ONLY DEVICES
;
;	V06	LMK0004		LEN KAWELL	17-JUL-1979
;		ADDED CAPABILITY TO OVERRIDE MAXIMUM UNITS WITH SYSGEN
;		CONNECT OPTION.
;
;	V05	LMK0003		LEN KAWELL	09-JUL-1979
;		CHANGED MAXIMUM UNITS PER IDB FROM THE CONSTANT 8
;		TO A VALUE CONTAINED IN THE DRIVER PROLOGUE TABLE.
;
;	V04	LMK0002		LEN KAWELL	18-JUN-1979
;		ADDED LOADING OF MULTI-PORT MEMORY DEVICE DRIVERS.
;
;	V03	NPKCOMET	N. KRONENBERG	18-APR-1979
;		CHANGED SETTING OF INTERRUPT VECTORS AND TESTS FOR
;		NON-EXISTENT CSR'S TO CALL CPU-DEPENDENT SUBROUTINES
;		IN LOADERSUB.
;	V02	LMK0001		LEN KAWELL	29-DEC-1978
;		ADDED NOPRIV ERROR CHECKING.
;--
	.PAGE
	.SBTTL	DECLARATIONS


;
; INCLUDE FILES:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

	$SYSGMSGDEF			;DEFINE SYSGEN MESSAGES
	$IPLDEF				;DEFINE SYSTEM IPL'S
	$DYNDEF				;DEFINE DYNAMIC MEMORY TYPES
	$DDBDEF				;DEFINE DEVICE DATA BLOCK
	$UCBDEF				;DEFINE UNIT CONTROL BLOCK
	$CRBDEF				;DEFINE CHANNEL CONTROL BLOCK
	$VECDEF				;DEVICE INTERRUPT VECTOR 
	$IDBDEF				;DEFINE INTERRUPT DISPATCH BLOCK
	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$DPTDEF				;DEFINE DRIVER PROLOGUE TABLE
	$ACFDEF				;DEFINE AUTO-CONFIGURE ARG LIST
	$PTEDEF				;DEFINE PAGE TABLE ENTRIES
	$UBADEF				;DEFINE UNIBUS ADAPTER
	$DDTDEF				;DEFINE DDT

;
; OWN STORAGE:
;

	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

IOGEN$GL_DPT::			;ADDRESS OF DRIVER PROLOGUE TABLE
	.BLKL	1
LOAD_FLAGS:				;CONTROL BLOCKS CREATED FLAGS
	.BLKB	1
	_VIELD	LOAD,0,<-		; FLAG DEFINTIONS
		<DDB,,M>,-		;  DDB CREATED
		<CRB,,M>,-		;  CRB CREATED
		<IDB,,M>,-		;  IDB CREATED
		<UCB,,M>,-		;  UCB CREATED
		>
DDB_BLINK:				;DDB BACKWARD LINK
	.BLKL	1
UCB_BLINK:				;UCB BACKWARD LINK
	.BLKL	1

	.PSECT	NONPAGED_CODE	rd,nowrt,exe,long

MBINT_DISP:				;MBA INTERRUPT DISPATCHER MODEL
	PUSHR	#^M<R2,R3,R4,R5>
	JSB	@#0

INT_DISP:				;GENERAL INTERRUPT DISPATCHER MODEL
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	JSB	@#0

	.PAGE
	.SBTTL	LOADER - LOAD A DEVICE DRIVER/DATABASE

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine will load a device driver, a device driver and
;	database, or just a single unit into an already existing
;	database.
;
; CALLING SEQUENCE:
;
;	CALL IOGEN$LOADER(ACF_LIST)
;
; INPUT PARAMETERS:
;
;	ACF_LIST -
;
;	ACF$L_ADAPTER(AP) = ADDRESS OF ADAPTER CONTROL BLOCK
;	ACF$L_CONFIGREG(AP) = ADDRESS OF CONFIGURATION STATUS REGISTER
;	ACF$W_AVECTOR(AP) = OFFSET TO ADAPTER INTERRUPT VECTOR (SCB)
;	ACF$B_AUNIT(AP) = ADAPTER UNIT NUMBER
;	ACF$B_AFLAG(AP) = ADAPTER GENERATION CONTROL FLAGS
;	ACF$L_CONTRLREG(AP) = ADDRESS OF CONTROL REGISTER
;	ACF$W_CVECTOR(AP) = OFFSET TO CONTROLLER INTERRUPT VECTOR (TABLE)
;	ACF$B_CUNIT(AP) = CONTROLLER UNIT NUMBER
;	ACF$B_CNUMVEC(AP) = NUMBER OF CONTROLLER VECTORS
;	ACF$L_DEVNAME(AP) = ADDRESS OF DEVICE NAME COUNTED STRING
;	ACF$L_DRVNAME(AP) = ADDRESS OF DRIVER NAME COUNTED STRING
 
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	DRIVER AND/OR DATABASE LOADED
;
; COMPLETION CODES:
;
;	R0 = STATUS OF OPERATION
;
; SIDE EFFECTS:
;
;	NONE
;
;--

.Entry	IOGEN$LOADER,0
;
; See if driver needs to be loaded
;
	BBS	#ACF$V_RELOAD,ACF$B_AFLAG(AP),10$ ;BR IF RELOAD REQUESTED
	$CMKRNL_S W^CHECK_DRV,(AP)	;CHECK IF DRIVER LOADED
	CMPW	R0,#SS$_NOPRIV		;NO PRIVILEGE?
	BEQLU	40$			;BR IF YES
	BLBS	R0,20$			;BR IF DRIVER LOADED

10$:	PUSHL	ACF$L_DRVNAME(AP)	;SET ADDR OF DRIVER NAME
	CALLS	#1,IOGEN$LOADDRIV	;LOAD THE DRIVER

; Note that the errors from this call are suppressed if this is a load driver
; call only (If ACF$V_NOLOAD_DB is set). This is because the subsequent
; call from AUTOCONFIGURE takes this same code path and will report the
; error at that time. Unsupported devices do not print out the error message.

20$:	BBS	#ACF$V_NOLOAD_DB,-
		ACF$B_AFLAG(AP),30$	;EXIT IF LOAD DRIVER CALL ONLY

	BLBC	R0,50$			;BR IF ERROR LOADING DRIVER

	TSTL	ACF$L_DEVNAME(AP)	;DEVICE NAME SPECIFIED?
	BEQL	30$			;BR IF NOT - DON'T LOAD DATABASE
	$CMKRNL_S W^LOAD_DB,(AP)	;LOAD THE DATABASE
	BRB	40$			; EXIT WITH STATUS

30$:	MOVL	#1,R0
40$:	RET

;
; Error occured loading driver
;
50$:	BBC	#ACF$V_SUPPORT,-
		ACF$B_AFLAG(AP),40$	;BRANCH IF SUPPORTED DEVICE
	BRB	30$			;ALWAYS SUCCESS FOR UNSUPPORTED


	.PAGE
	.SBTTL	CHECK_DRV - CHECK IF DRIVER ALREADY LOADED
;++
;
; Local kernel mode routine to check if the driver is already loaded.
;
;--
CHECK_DRV:
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	BSBW	IOGEN$LOCK_IODB		;LOCK THE I/O DATABASE
	MOVL	ACF$L_DRVNAME(AP),R5	;GET ADDR OF DRIVER NAME
	MOVZBL	(R5)+,R4		;GET SIZE OF DRIVER NAME
	MOVAB	G^IOC$GL_DPTLIST,R6	;GET ADDR OF DPT LIST
	MOVL	R6,R7			;SAVE IT
10$:
	CLRL	R0			;ASSUME NOT LOADED
	MOVL	DPT$L_FLINK(R6),R6	;GET ADDR OF NEXT DRIVER PROLOGUE
	CMPL	R6,R7			;END OF LIST?
	BEQL	20$			;BR IF YES
	MOVAB	DPT$T_NAME(R6),R1	;GET ADDR OF DRIVER NAME
	MOVZBL	(R1)+,R0		;GET SIZE OF DRIVER NAME
	CMPC5	R0,(R1),#0,R4,(R5)	;COMPARE DRIVER NAMES
	BNEQ	10$			;BR IF NOT EQUAL
	MOVL	R6,W^IOGEN$GL_DPT	;SET ADDR OF DRIVER PROLOGUE
	MOVL	#1,R0			;SET SUCCESS
20$:
	PUSHL	R0			;SAVE STATUS
	BSBW	IOGEN$UNLK_IODB		;UNLOCK THE I/O DATABASE
	POPL	R0			;RESTORE THE STATUS
	RET

	.PAGE
	.SBTTL	LOAD_DB - LOAD THE DATABASE
;++
;
; Local kernel mode routine to load the UCB and if not loaded yet,
; the DDB, CRB, and IDB.
;
;--
LOAD_DB:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CLRB	W^LOAD_FLAGS		;CLEAR LOADER FLAGS
	MOVL	W^IOGEN$GL_DPT,R11	;GET ADDR OF DRIVER PROLOGUE
	BSBW	IOGEN$LOCK_IODB		;LOCK THE I/O DATABASE
	SETIPL	#IPL$_SYNCH		;SYNCHRONIZE I/O DATABASE ACCESS
;
; CHECK IF DEVICE DATABASE ALREADY LOADED
;
	MOVZBL	ACF$B_CUNIT(AP),-(SP)	; Push unit number
	PUSHL	ACF$L_DEVNAME(AP)	; Push device name address
	BSBW	SGN$GET_DEVICE		; Get device addresses if they exist
	ADDL2	#8,SP			; Pop input off stack

	MOVL	W^SGN$GL_DDB,R10	; Address of DDB
	BEQL	CREATE_DDB		; Branch if it doesn't exist

	TSTL	W^SGN$GL_UCB		; Is there a UCB for this unit ?
	BEQL	10$			; Branch if no
	BRW	DB_EXIT			; Branch to common exit point

10$:	MOVL	W^SGN$GL_IDB,R8		; Address of IDB
	MOVL	W^SGN$GL_CRB,R9		; Address of CRB
	BRW	CREATE_UCB		; Create UCB for this unit

;
; CREATE THE DDB
;
CREATE_DDB:
	MOVL	W^SGN$GL_LASTDDB,R10	;Get address of last DDB in list
	MOVZBL	#DDB$K_LENGTH,R1	;GET SIZE OF DDB
	BSBW	IOGEN$ALLOBLOCK		;CREATE THE DDB
	BLBS	R0,10$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
10$:	BISB	#LOAD_M_DDB,W^LOAD_FLAGS ;SET DDB LOADED FLAG
	MOVAL	DDB$L_LINK(R10),W^DDB_BLINK ;SAVE DDB BACKWARD LINK
	MOVL	R2,DDB$L_LINK(R10)	;SET LINK TO THIS DDB
	MOVL	R2,R10			;GET ADDR OF DDB
	MOVW	R1,DDB$W_SIZE(R10)	;SET SIZE
	MOVB	#DYN$C_DDB,DDB$B_TYPE(R10) ;SET TYPE
	INCB	DPT$B_REFC(R11)		;INCREMENT DPT REFERENCE COUNT
	MOVZBL	@ACF$L_DEVNAME(AP),R0	;GET SIZE OF DEVICE NAME
	INCL	R0			;ADD 1 BYTE FOR COUNT
	MOVC	R0,@ACF$L_DEVNAME(AP),DDB$T_NAME(R10) ;SET DEVICE NAME
	MOVZBL	@ACF$L_DRVNAME(AP),R0	;GET SIZE OF DRIVER NAME
	INCL	R0			;ADD 1 BYTE FOR COUNT
	MOVC	R0,@ACF$L_DRVNAME(AP),DDB$T_DRVNAME(R10) ;SET DRIVER NAME
;
; CHECK IF CRB/IDB NEED TO BE CREATED
;
	MOVL	ACF$L_ADAPTER(AP),R9	; CONTAINS ADDR. OF CRB IF CRBBLT FLAG IS SET
	BBS	#ACF$V_CRBBLT,-
		ACF$B_AFLAG(AP),20$ 		; BR. IF CRB & IDB ARE BUILT
	BBS	#DPT$V_SUBCNTRL,-
		DPT$B_FLAGS(R11),CREATE_CRB 	; BR IF SUBCONTROLLER

	CMPB	#AT$_MBA,DPT$B_ADPTYPE(R11) 	; MBA ADAPTER?
	BEQL	15$				; BRANCH IF YES
	CMPB	#AT$_DR,DPT$B_ADPTYPE(R11) 	; DR ADAPTER?
	BEQL	15$				; BRANCH IF YES
	CMPB	#AT$_CI,DPT$B_ADPTYPE(R11)	; CI ADAPTER ?
	BEQL	15$				; BRANCH IF YES
	BRB	CREATE_CRB			; BRANCH IF OTHER
;
; USE EXISTING CRB (IF ONE EXISTS)
;
15$:	MOVL	ACF$L_ADAPTER(AP),R0		; GET ADDR OF ADP
	MOVL	ADP$L_CRB(R0),R9		; GET ADDR OF EXISTING CRB
	BEQL	CREATE_CRB			; BRANCH IF NONE
20$:	MOVL	CRB$L_INTD+VEC$L_IDB(R9),R8	; GET ADDR. OF IDB
	BRW	CREATE_UCB			; CREATE A NEW UCB
;
; CREATE CRB
;
CREATE_CRB:
	MOVZBL	ACF$B_CNUMVEC(AP),R1	;GET NUMBER OF INT VECTORS
	DECL	R1			;ONE IS ALWAYS ASSUMED
	MULW	#VEC$K_LENGTH,R1	;COMPUTE SIZE OF EXTRA DISPATCHERS
	ADDW	#CRB$K_LENGTH,R1	;COMPUTE TOTAL SIZE OF CRB
	BSBW	IOGEN$ALLOBLOCK		;ALLOCATE THE CRB
	BLBS	R0,10$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
10$:	BISB	#LOAD_M_CRB,W^LOAD_FLAGS ;SET CRB LOADED FLAG
	MOVL	R2,R9			;GET ADDR OF CRB
	MOVL	R9,SGN$GL_CRB		; *** SAVE FOR ACF$UDA IN AUTOCONFG
	MOVW	R1,CRB$W_SIZE(R9)	;SET SIZE
	MOVB	#DYN$C_CRB,CRB$B_TYPE(R9) ;SET TYPE
	MOVAL	CRB$L_WQFL(R9),CRB$L_WQFL(R9) ;SET WAIT QUEUE LISTHEAD
	MOVAL	CRB$L_WQFL(R9),CRB$L_WQBL(R9) ;...
	BBC	#DPT$V_SUBCNTRL,DPT$B_FLAGS(R11),CREATE_IDB ;BR IF NOT SUBCONTROLLER
	MOVL	ACF$L_ADAPTER(AP),R0	;GET ADDR OF ADAPTER CONTROL BLOCK
	MOVL	ADP$L_CRB(R0),R1	;GET ADDR OF SECONDARY CRB
	MOVL	R1,CRB$L_LINK(R9)	;SET ADDR OF SECONDARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R2 ;GET ADDR OF SECONDARY IDB
	MOVZBL	ACF$B_AUNIT(AP),R3	;GET ADAPTER UNIT NUMBER
	MOVAB	CRB$L_INTD+1(R9),IDB$L_UCBLST(R2)[R3] ;SET ADDR OF DISPATCHER
;
; CREATE IDB
;
CREATE_IDB:
	MOVZBL	#IDB$K_LENGTH-<8*4>,R1	;GET STANDARD LENGTH OF IDB
					;(LESS NORMAL 8 UNITS)
	MOVZWL	DPT$W_MAXUNITS(R11),R4	;GET MAXIMUM NUMBER OF UNITS
	TSTW	ACF$W_MAXUNITS(AP)	;WAS A VALUE SPECIFIED AT CONNECT?
	BEQL	5$			;BR IF NO
	MOVW	ACF$W_MAXUNITS(AP),R4	;USE THE SPECIFIED VALUE INSTEAD
5$:	MOVAL	(R1)[R4],R1		;COMPUTE TOTAL SIZE NEEDED
	CVTLW	R1,R1			;IS MAXUNITS TOO LARGE ?
	BVC	7$			;BRANCH IF NO
	MOVL	#SYSG$_MAXTOOBIG,R0	;SET ERROR
	BRW	DB_ERROR		;BRANCH TO ERROR
7$:	BSBW	IOGEN$ALLOBLOCK		;ALLOCATE THE IDB
	BLBS	R0,10$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
10$:	BISB	#LOAD_M_IDB,W^LOAD_FLAGS ;SET IDB LOADED FLAG
	MOVL	R2,R8			;GET ADDR OF IDB
	MOVW	R1,IDB$W_SIZE(R8)	;SET SIZE
	MOVB	#DYN$C_IDB,IDB$B_TYPE(R8) ;SET TYPE
	MOVW	R4,IDB$W_UNITS(R8)	    ;SET MAXIMUM UNITS
	CMPB	#AT$_NULL,DPT$B_ADPTYPE(R11);NULL ADAPTER ?
	BNEQ	30$			    ;IF NOT, BRANCH
	MOVL	R8,CRB$L_INTD+VEC$L_IDB(R9) ;STORE IDB POINTER IN CRB
	CLRL	CRB$L_INTD+VEC$L_ADP(R9)    ;NULLIFY ADP POINTER
	CLRL	IDB$L_ADP(R8)		    ;NULLIFY ADP POINTER
	CLRL	IDB$L_CSR(R8)		    ;NULLIFY CSR POINTER
	MOVL	W^INT_DISP,-		;STORE INTERRUPT DISPATCHER CODE
		CRB$L_INTD+VEC$Q_DISPATCH(R9)
	BRW	CREATE_UCB		;CONTINUE

30$:
	MOVL	ACF$L_ADAPTER(AP),IDB$L_ADP(R8) ;SET ADDR OF ADP
	MOVL	ACF$L_CONTRLREG(AP),IDB$L_CSR(R8) ;SET ADDR OF CSR

; Vector is now saved in IDB. The two least significant bits are always
; zero, so the nine bit field is taken as bits 2 through 9 and placed
; in a byte field. IDB$B_VECTOR is the field, and is currently not filled
; in for a system booted from a UNIBUS boot device (e.g. an RK07).
	
	extzv	#2,#7,acf$w_cvector(ap),r1	; Get right shifted vector
	movb	r1,idb$b_vector(r8)		; Place in IDB

;
; CREATE INTERRUPT VECTOR DISPATCHER(S)
;
CREATE_VEC:
	CVTWL	ACF$W_CVECTOR(AP),R6	;GET VECTOR TABLE OFFSET
	BGTR	5$			;BR IF VECTOR SPECIFIED
	MOVL	#SYSG$_INVVEC,R0	;SET INVALID VECTOR ERROR
	BRW	DB_ERROR		;...EXIT
5$:	MOVZBL	ACF$B_CNUMVEC(AP),R5	;GET NUMBER OF INTERRUPT VECTORS
	MOVAL	CRB$L_INTD(R9),R4	;GET ADDR OF FIRST DISPATCHER
10$:	MOVL	W^MBINT_DISP,VEC$Q_DISPATCH(R4) ;ASSUME MBA DEVICE:  SET
						;  "PUSHR #^M<R2,R3,R4,R5>"
					; AND "JSB @#"
	MOVL	ACF$L_ADAPTER(AP),VEC$L_ADP(R4) ;SET ADDR OF ADP
	MOVL	R8,VEC$L_IDB(R4)	;SET ADDR OF IDB
	BBC	#ACF$V_SCBVEC,-		;BR IF NOT VECTORING DIRECTLY
		ACF$B_AFLAG(AP),13$	;FROM SCB
	ADDL3	MMG$A_SYSPARAM+<EXE$GL_SCB-EXE$A_SYSPARAM>,-  ;USE SYS.EXE
		R6,R0			;COPY OF SCB ADDR TO GET ADDRESS
					;OF VECTOR IN SCB
	MOVAB	VEC$Q_DISPATCH+1(R4),-	;CONNECT DISPATCHER TO VECTOR
		(R0)			;THE +1 MEANS USE THE INTERRUPT STACK
	MOVL	W^INT_DISP,VEC$Q_DISPATCH(R4)	;STORE DISPATCHER CODE
	BRB	30$

13$:	MOVL	ACF$L_ADAPTER(AP),R0	;GET ADDR OF ADP
	ADDL3	ADP$L_VECTOR(R0),R6,R0	;GET ADDR OF VECTOR TABLE ENTRY
	CMPB	#AT$_UBA,DPT$B_ADPTYPE(R11) ;UBA DEVICE?
	BEQL	15$			;BR IF YES
	CMPB	#AT$_MPM,DPT$B_ADPTYPE(R11) ;MULTI-PORT MEMORY DEVICE?
	BNEQ	30$			;BR IF NOT
	MOVAB	VEC$Q_DISPATCH+2(R4),(R0) ;CONNECT DISPATCHER
	BRB	30$			;
15$:
	BICL3	#3,(R0),R1		;GET CURRENT VECTOR CONTENT
					; EXCLUDING STACK SPECIFICATION
	CMPL	R1,#UBA$UNEXINT		;IS VECTOR IN USE?
	BEQL	20$			;BR IF NOT
	MOVL	#SYSG$_VECINUSE,R0	;SET ERROR STATUS
	BRW	DB_ERROR		;...EXIT
20$:
	BSBW	IOGEN$CONN_VEC		;CONNECT UB DEVICE VECTOR
30$:	ADDL	#4,R6			;INCREMENT VECTOR OFFSET
	ADDL	#VEC$K_LENGTH,R4	;INCREMENT DISPATCH ADDR
	SOBGTR	R5,10$			;DECREMENT VECTOR COUNT - BR IF MORE
;
; CREATE A UCB
;
CREATE_UCB:
	CLRL	R7			;SET NO UCB
	MOVZWL	DPT$W_UCBSIZE(R11),R1	;GET SIZE OF UCB
	BNEQ	2$			;BRANCH IF NON-NULL
	BRW	INIT_DB			;BRANCH IF NO UCB FOR THIS DRIVER

2$:	BSBW	IOGEN$ALLOBLOCK		;ALLOCATE THE UCB
	BLBS	R0,5$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
5$:	BISB	#LOAD_M_UCB,W^LOAD_FLAGS ;SET UCB LOADED FLAG
	MOVL	R2,R7			;GET ADDR OF UCB
	MOVW	R1,UCB$W_SIZE(R7)	;SET SIZE
	MOVB	#DYN$C_UCB,UCB$B_TYPE(R7) ;SET TYPE
	MOVAL	UCB$L_ASTQFL(R7),UCB$L_ASTQFL(R7) ;SET AST QUEUE LISTHEAD
	MOVAL	UCB$L_ASTQFL(R7),UCB$L_ASTQBL(R7) ;...
	MOVL	R9,UCB$L_CRB(R7)	;SET ADDR OF CRB
	INCW	CRB$W_REFC(R9)		;INCREMENT CRB REFERENCE COUNT
	MOVZBL	ACF$B_CUNIT(AP),R0	;GET CONTROLLER UNIT NUMBER
	CMPW	R0,IDB$W_UNITS(R8)	;MAXIMUM UNITS EXCEEDED?
	BLSSU	8$			;BR IF NOT
	MOVL	#SYSG$_MAXUNITS,R0	;SET MAXIMUM UNITS EXCEEDED
	BRW	DB_ERROR		;...EXIT
8$:
	MOVL	R7,IDB$L_UCBLST(R8)[R0]	;SET ADDR OF UCB IN IDB
	MOVL	R10,UCB$L_DDB(R7)	;SET ADDR OF DDB
	MOVAL	UCB$L_IOQFL(R7),UCB$L_IOQFL(R7) ;SET I/O QUEUE LISTHEAD
	MOVAL	UCB$L_IOQFL(R7),UCB$L_IOQBL(R7) ;...
	MOVZBW	ACF$B_CUNIT(AP),UCB$W_UNIT(R7) ;SET UNIT NUMBER
	MOVL	CRB$L_INTD+VEC$L_IDB(R9),R1 ;IDB ADDRESS
	MOVL	IDB$L_ADP(R1),R1	;ADP ADDRESS
	BEQL	9$			;PHYSICAL DEVICE IF NON-ZERO
	CMPW	#AT$_MBA,ADP$W_ADPTYPE(R1) ;IS IT A MASSBUS
	BNEQ	9$			;BRANCH IF NOT
	MOVB	ACF$B_AUNIT(AP),UCB$B_SLAVE(R7) ;SET SLAVE CNTRLER NUMBER

9$:	MOVAL	DDB$L_UCB(R10),R1	;GET ADDR OF ADDR OF FIRST UCB
	MOVL	(R1),R0			;GET ADDR OF FIRST UCB
	BEQL	20$			;BR IF NONE
10$:	MOVAL	UCB$L_LINK(R0),R1	;GET ADDR OF ADDR OF NEXT UCB
	MOVL	(R1),R0			;GET ADDR OF NEXT UCB
	BNEQ	10$			;BR IF IT EXISTS
20$:	MOVL	R1,W^UCB_BLINK		;SAVE UCB BACKWARD LINK
	MOVL	R7,(R1)			;SET FORWARD LINK TO UCB

	BBC	#DPT$V_SVP,DPT$B_FLAGS(R11),INIT_DB ;BR IF NO SYS PAGE REQUIRED
	MOVAB	MMG$A_SYSPARAM,R2	;GET ADDR OF SYS PARAMS
	MOVL	BOO$GL_SPTFREL-EXE$A_SYSPARAM(R2),R0 ;GET NEXT FREE SPT ENTRY
	CMPL	R0,BOO$GL_SPTFREH-EXE$A_SYSPARAM(R2) ;SPT FULL?
	BLEQU	30$			;BR IF NO
	MOVL	#SYSG$_SPTFULL,R0	;SET ERROR STATUS
	BRW	DB_ERROR		;...EXIT
30$:	INCL	BOO$GL_SPTFREL-EXE$A_SYSPARAM(R2) ;INCREMENT NEXT FREE  POINTER
	MOVL	MMG$GL_SPTBASE-EXE$A_SYSPARAM(R2),R1 ;GET ADDR OF SPT
	MOVL	#<PTE$M_VALID!PTE$C_KW!PTE$M_PFN>,(R1)[R0] ;VALIDATE THIS ENTRY
	MOVL	R0,UCB$L_SVPN(R7)	;SET SYS PAGE NUMBER IN UCB
;
; INITIALIZE ALL THE CONTROL BLOCKS
;
INIT_DB:
	MOVL	R11,R4			;SET ADDR OF DRIVER PROLOGUE
	MOVL	R7,R5			;SET ADDR OF UCB
	JSB	G^IOC$INITDRV		;INIT THE CONTROL BLOCKS
	BLBS	R0,INIT_CNTRL		;BR IF SUCCESS
	MOVL	#SYSG$_INVDPTINI,R0	;SET ERROR STATUS
	BRW	DB_ERROR		;...EXIT
;
; CALL THE CONTROLLER AND DRIVE INITIALIZATION ROUTINES
;
INIT_CNTRL:

	DSBINT				;DISABLE INTERRUPTS
	BBC	#LOAD_V_CRB,W^LOAD_FLAGS,INIT_UNIT ;BR IF CRB NOT JUST CREATED
	MOVL	R10,R6			;SET ADDR OF DDB
	BSBW	IOGEN$CNTRL_INI		;INITIALIZE THE CONTROLLER

INIT_UNIT:
;
; Relocate the DDT and FDT to SYSTEM VIRTUAL ADDRESSES.
;
	PUSHL	R11			;SAVE DPT ADDRESS
	MOVL	R10,R11			;SET ADDRESS OF DDB
	JSB	G^IOC$RELOC_DDT		;RELOCATE DDT and FDT
	POPL	R11			;RESTORE DPT
;
; SET ADDRESS OF DDT IN UCB (DDB$L_DDT initialized by IOC$INITDRV above)
;
	TSTL	R7			;CHECK FOR UCB
	BEQL	30$			;BRANCH IF NONE CREATED ABOVE
	MOVL	DDB$L_DDT(R10),UCB$L_DDT(R7)
	MOVL	R7,R5			;GET ADDR OF UCB
	MOVL	IDB$L_CSR(R8),R4	;GET ADDR OF CSR
	BGEQ	20$			;NO CSR(S)
	MOVL	R4,R3			;ASSUME ONLY ONE CSR
	MOVL	CRB$L_LINK(R9),R0	;GET ADDR OF SECONDARY CRB
	BEQL	10$			;BR IF NONE
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0 ;GET ADDR OF SECONDARY IDB
	MOVL	IDB$L_CSR(R0),R4	;GET SECONDARY CSR ADDR
10$:	CMPB	#AT$_UBA,DPT$B_ADPTYPE(R11) ;UBA DEVICE?
	BNEQ	20$			;BR IF NOT
	MOVL	ACF$L_ADAPTER(AP),R6	;GET ADDR OF ADP
	MOVL	ADP$L_CSR(R6),R6	;GET ADDR OF UBA CSR
	MOVL	R4,R0			;GET COPY OF CSR ADDR
	JSB	G^EXE$TEST_CSR		; CHECK FOR NONEXISTENT CSR
	BLBS	R0,20$			;BRANCH IF CSR EXISTS
	BICW	#UCB$M_ONLINE,UCB$W_STS(R7) ;SET DEVICE OFFLINE
	BRB	30$			;
20$:	MOVL	DDB$L_DDT(R10),R0	; GET ADDRESS OF DDT
	MOVL	DDT$L_UNITINIT(R0),R1	; OBTAIN ADDRESS OF UNIT INIT.
	CMPL	R1,#IOC$RETURN		; IF EQUAL TO IOC$RETURN THEN
	BNEQ	27$			; UNIT INIT WASN'T SPECIFIED
	MOVL	CRB$L_INTD+VEC$L_UNITINIT(R9),R1  ; SO GET IT FROM CRB
	BEQL	30$			; NOT SPECIFIED IN CRB EITHER
27$:	JSB	(R1)			; CALL UNIT INITIALIZATION
	MOVL	R10,R6			;SET UP ADDR OF DDB
30$:
	ENBINT				;RE-ENABLE INTERRUPTS
;
; Increment current unit number
; Loop through Create UCB code once for each unit
;
	TSTB	ACF$B_NUMUNIT(AP)	; TEST NO. OF UNITS TO CONFIGURE
	BEQL	DB_EXIT			; EXIT IF ZERO
	DECB	ACF$B_NUMUNIT(AP)	; DECREMENT NO. OF UNITS TO CONFIGURE
	BLEQ	DB_EXIT			; ALL DONE!
	INCB	ACF$B_CUNIT(AP)		; MOVE TO NEXT UNIT NO.
	BRW	CREATE_UCB		; AND LOOP

;
; OPERATION COMPLETED - UNLOCK I/O DATABASE AND EXIT
;
DB_EXIT:
	BSBW	IOGEN$UNLK_IODB		;UNLOCK I/O DATABASE
					; AND LOWER IPL
	MOVL	#1,R0			;SET SUCCESS
	RET				;...EXIT

	.PAGE
	.SBTTL	DB_ERROR - ERROR LOADING DATABASE
;++
;
; DB_ERROR - LOCAL ROUTINE TO UNLOAD A PARTIALLY LOADED DATABASE
;
;	This routine checks the loading flags (LOAD_FLAGS) and
;	unload and unlinks any control blocks that were just created.
;
; INPUTS:
;
;	LOAD_FLAGS = FLAGS INDICATING CONTROL BLOCKS THAT HAVE JUST
;		     BEEN CREATED
;
; OUTPUTS:
;
;	R0 = ERROR STATUS THAT CAUSED UNLOADING
;
;--
DB_ERROR:
	PUSHL	R0			;SAVE ERROR STATUS
;
; UCB UNLOADING
;
	BBC	#LOAD_V_UCB,W^LOAD_FLAGS,20$ ;BR IF UCB NOT CREATED
	CMPL	#SYSG$_MAXUNITS,R0	;WAS IT A MAXUNITS ERROR?
	BEQL	5$			;IF SO, NO BLINK
	CLRL	@W^UCB_BLINK		;CLEAR POINTER TO UCB
5$:	DECW	CRB$W_REFC(R9)		;DECREMENT CRB REFERENCE COUNT
	MOVZBL	ACF$B_CUNIT(AP),R0	;GET CONTROLLER UNIT NUMBER
	CLRL	IDB$L_UCBLST(R8)[R0]	;CLEAR IDB POINTER TO UCB
	MOVL	R7,R0			;SET ADDR OF UCB
	BSBB	10$			;DEALLOCATE THE UCB
	BRB	20$			;
;
; LOCAL SUBROUTINE TO DEALLOCATE A CONTROL BLOCK
;
; 	INPUT - R0 = ADDRESS OF BLOCK TO DEALLOCATE
;
10$:	JSB	G^EXE$DEANONPAGED	;DEALLOCATE TO NON-PAGED POOL
	RSB

;
; IDB UNLOADING
;
20$:	BBC	#LOAD_V_IDB,W^LOAD_FLAGS,30$ ;BR IF IDB NOT CREATED
	MOVL	R8,R0			;SET ADDR OF IDB
	BSBB	10$			;DEALLOCATE THE IDB
;
; CRB UNLOADING
;
30$:	BBC	#LOAD_V_CRB,W^LOAD_FLAGS,50$ ;BR IF CRB NOT CREATED
	BBC	#DPT$V_SUBCNTRL,DPT$B_FLAGS(R11),40$ ;BR IF NOT SUBCONTROLLER
	MOVL	CRB$L_LINK(R9),R1	;GET ADDR OF SECONDARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R1 ;GET ADDR OF SECONDARY IDB
	MOVZBL	ACF$B_AUNIT(AP),R0	;GET ADAPTER UNIT NUMBER
	CLRL	IDB$L_UCBLST(R1)[R0]	;CLEAR DISPATCHER POINTER
40$:	MOVL	R9,R0			;SET ADDR OF CRB
	BSBB	10$			;DEALLOCATE THE CRB
;
; DDB UNLOADING
;
50$:	BBC	#LOAD_V_DDB,W^LOAD_FLAGS,60$ ;BR IF DDB NOT CREATED
	DECB	DPT$B_REFC(R11)		;DECREMENT DPT REFERENCE COUNT
	CLRL	@W^DDB_BLINK		;CLEAR LINK TO THE DDB
	MOVL	R10,R0			;SET ADDR OF DDB
	BSBB	10$			;DEALLOCATE THE DDB
60$:
	BSBW	IOGEN$UNLK_IODB		;UNLOCK THE I/O DATABASE
					; AND LOWER IPL
	POPL	R0			;RESTORE STATUS
	RET				;...EXIT

	.END
