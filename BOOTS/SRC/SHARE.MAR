	.TITLE	SHARE	SHARED MEMORY INITIALIZATION
	.IDENT	'V03-004'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSGEN
;
; ABSTRACT:	THIS MODULE INITIALIZES AND CONNECTS THE PROCESSOR TO
;		A PORT OF A MULTI-PORT (SHARED) MEMORY.
;
;
; ENVIRONMENT:  NATIVE/USER MODE, PRIVILEGED
;
; AUTHOR:	LEN KAWELL, CREATION DATE: 19-DEC-1978
;
; MODIFICATION HISTORY:
;
;	V03-004	KDM0100		Kathleen D. Morse	13-Apr-1982
;		Initialize all unused bytes of the shared memory
;		global section bitmap page to zero, so that the
;		bitmap scan routine works correctly.
;
;	V03-003	KDM0097		Kathleen D. Morse	11-Apr-1982
;		Force an MA780 inter-processor interrupt after
;		completion of the SHARE command so that any pending
;		PRQs will be processed immediately.
;
;	V03-002	KDM0093		Kathleen D. Morse	9-Apr-1982
;		Add memory descriptor to RPB for MA780 if it does not
;		exist because memory must have been powered on after
;		the system booted.
;
;	V03-001	KDM0092		Kathleen D. Morse	6-Apr-1982
;		Make sure that MA780 is not being used for local
;		memory before performing SHARE command.
;
;	V02-017	KDM0072		Kathleen D. Morse	5-Jan-1982
;		Correct share memory common event block initialization.
;
;	V02-016	JLV0115		Jake VanNoy		12-Nov-1981
;		Fix return status in GEN$SHR_POOLS.
;
;	V02-015	JLV0029		Jake VanNoy		16-Jun-1981
;		Added G^ to LIB$ routines.
;
;	V02-014	TCM0001		Trudy C. Matthews	8-May-1981
;		Changed reference to RPB$B_CONFREG array to reference
;		EXE$GL_CONFREG array instead.
;
;	V13	JLV0002		Jake VanNoy		9-Feb-1981
;		Changed psects to allow paged and non-paged segments
;		is SYSGEN image. Add SHOW/CONFIGURATION and 
;		CONFIGURE.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
; 

;
; MACROS:
;

;
; PUT_OUTPUT - MACRO TO FORMAT AND PUT A MESSAGE TO SYS$OUTPUT
;
	.MACRO	PUT_OUTPUT MSG,ARG1,ARG2,ARG3,ARG4,ARG5,ARG6,ARG7,ARG8
	.SAVE	LSB
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
$$DESC=.
	.ASCID	\MSG\
	.RESTORE

	.IF NB ARG1			; IF FORMATTING NEEDED
	MOVAB	-128(SP),SP		; ALLOCATE FORMAT BUFFER
	PUSHL	SP			; CREATE BUFFER DESCRIPTOR
	PUSHL	#128			; ...
	MOVL	SP,R0			; GET ADDR OF DESCRIPTOR
	$FAO_S	$$DESC,(R0),(R0),-	; FORMAT THE OUTPUT
		ARG1,ARG2,ARG3,ARG4,ARG5,ARG6,ARG7,ARG8
	PUSHL	SP			; SET ADDR OF BUFFER DESC
	CALLS	#1,G^LIB$PUT_OUTPUT	; OUTPUT THE FORMATTED TEXT
	MOVAB	128+8(SP),SP		; DEALLOCATE BUFFER AND DESC
	
	.IFF
	PUSHAQ	$$DESC			; SET ADDR OF TEXT DESC
	CALLS	#1,G^LIB$PUT_OUTPUT	; OUTPUT THE TEXT
	.ENDC

	.ENDM	PUT_OUTPUT

;
; EQUATED SYMBOLS:
;

INITLOCK_TIMOUT	= 15*10*1000*1000	; INITIALIZATION LOCK TIMEOUT TIME
INITPOLL_TIMOUT	= 5*10*1000*1000	; INITIALIZATION POLL TIMEOUT TIME

;
; SYSTEM DEFINITIONS
;
	$ACBDEF				; AST CONTROL BLOCKS
	$ACFDEF				; CONFIGURATION CONTROL BLOCK
	$ADPDEF				; NEXUS ADAPTER CONTROL BLOCKS
	$CEBDEF				; COMMON EVENT FLAG BLOCKS
	$DYNDEF				; DYNAMIC DATA STRUCTURE TYPE CODES
	$GSDDEF				; GLOBAL SECTION DESCRIPTOR
	$IPLDEF				; INTERRUPT PRIORITY LEVELS
	$MBXDEF				; MAILBOX CONTROL BLOCK
	$MPMDEF				; MULTIPORT MEMORY ADAPTER
	$NDTDEF				; NEXUS DEVICE TYPES
	$PRDEF				; PROCESSOR REGISTERS
	$PRQDEF				; INTER-PROCESSOR REQUESTS
	$PTEDEF				; PAGE TABLE ENTRIES
	$RPBDEF				; RESTART PARAMETER BLOCK
	$RSNDEF				; RESOURCE NUMBERS
	$SHBDEF				; SHARED MEMORY CONTROL BLOCK
	$SHDDEF				; SHARED MEMORY DATAPAGE
	$SSDEF				; SYSTEM ERROR CODES
	$STSDEF				; STATUS CODES
	$SYSGMSGDEF			; SYSGEN MESSAGES
	$TPADEF				; TPARSE 
	$VADEF				; VIRTUAL ADDRESSES

;
; OWN STORAGE:
;
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

SHR_VALUES:				; START OF QUALIFIER VALUES
SHR_Q_MEMNAME:				; MEMORY NAME DESCRIPTOR
	.BLKL	2
SHR_W_UNIT:				; MEMORY UNIT #
	.BLKW	1
SHR_W_GBLCNT:				; GLOBAL SECTION COUNT
	.BLKW	1
SHR_W_MBXCNT:				; MAILBOX COUNT
	.BLKW	1
SHR_W_CEFCNT:				; COMMON EVENT FLAG CLUSTER COUNT
	.BLKW	1
SHR_W_GBLQUO:				; GLOBAL SECTION QUOTA FOR PORT
	.BLKW	1
SHR_W_MBXQUO:				; MAILBOX QUOTA  FOR PORT
	.BLKW	1
SHR_W_CEFQUO:				; COM EVT FLAG CLUSTER QUOTA FOR PORT
	.BLKW	1
SHR_L_POOLBCNT:				; POOL BLOCK COUNT
	.BLKL	1
SHR_L_POOLBSIZ:				; POOL BLOCK SIZE
	.BLKL	1
SHR_L_PRQCNT:				; INTER-PROCESSOR REQUEST COUNT
	.BLKL	1
SHR_L_START:				; STARTING PFN
	.BLKL	1
SHR_B_OPTIONS:				; COMMAND OPTIONS
	.BLKB	1
	_VIELD	SHR_OPT,0,<-		;  OPTION DEFINITIONS
		<INIT,,M>,-		;   INITIALIZE MEMORY
		>


SHR_L_MEMSIZE:				; SIZE OF SHARED MEMORY (PAGES)
	.BLKL	1

SHR_L_MEMPFN:				; STARTING PFN OF MEMORY
	.BLKL	1

SHR_L_GSDSIZE:				; SIZE OF A GLOBAL SECTION DESC
	.BLKL	1

SHR_L_CEFSIZE:				; SIZE OF SHMCEB, MASTER COMM EVT BLOCK
	.BLKL	1

SHR_L_DATAPAGE:				; ADDRESS OF DATAPAGE
	.BLKL	1

SHR_L_SHDPTE:				; ADDRESS OF DATAPAGE PTE
	.BLKL	1

SHR_L_ADP:				; ADPATER CONTROL BLOCK ADDRESS
	.BLKL	1

SHR_T_MBDEVNAME:			; MAILBOX DEVICE NAME
	.ASCIC	/MBB/

	.PSECT	NONPAGED_CODE	rd,nowrt,exe,long ; PURE data section

SHR_T_MBDRVNAME:			; MAILBOX DRIVER NAME
	.ASCIC	/MBXDRIVER/		

;
; AUTODIN-II POLYNOMIAL TABLE
;

AUTODIN:
	.LONG	^O00000000000,^O03555610144,^O07333420310,^O04666230254
	.LONG	^O16667040620,^O15332650764,^O11554460530,^O12001270474
	.LONG	^O35556101440,^O36003711504,^O32665521750,^O31330331614
	.LONG	^O23331141260,^O20664751324,^O24002561170,^O27557371034

	.PAGE
	.SBTTL	SHARE COMMAND QUALIFIER ACTION ROUTINES
;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE TPARSE ACTION ROUTINES STORE THE SHARE COMMAND QUALIFIER
;	VALUES AND CHECK THEIR VALIDITY.
;
;
; CALLING SEQUENCE:
;
;	CALLED AS A TPARSE ACTION ROUTINE.
;	(SEE THE RUN-TIME LIBRARY MANUAL FOR DETAILS)
;
; INPUTS:
;
;	STANDARD TPARSE PARAMETER BLOCK.
;
; OUTPUTS:
;
;	VALUES STORED FOR FUTURE USE BY SHARE COMMAND PROCESSING.
;
;	IF A VALUE IS INVALID, FAILURE IS RETURNED TO PRODUCE A SYNTAX
;	ERROR AND STOP PROCESSING.
;
;
;--
	.PSECT	NONPAGED_CODE	rd,nowrt,exe,long
	.DEFAULT DISPLACEMENT WORD	; DEFAULT PC DISPLACEMENT


GEN$SHR_RESET::				; RESET QUALIFIER VALUES
	.WORD	0			; ENTRY MASK
	MOVW	#32,SHR_W_GBLCNT	; SET DEFAULT GSD COUNT
	MOVW	#32,SHR_W_MBXCNT	; SET DEFAULT MAILBOX COUNT
	MOVW	#32,SHR_W_CEFCNT	; SET DEFAULT COM EV FLG CLUSTER COUNT
	MOVW	#32767,SHR_W_GBLQUO	; SET DEFAULT GSD QUOTA FOR PORT
	MOVW	#32767,SHR_W_MBXQUO	; SET DEFAULT MBX QUOTA FOR PORT
	MOVW	#32767,SHR_W_CEFQUO	; SET DEFAULT CEF QUOTA FOR PORT
	MOVZWL	#128,SHR_L_POOLBSIZ	; SET DEFAULT POOL BLOCK SIZE
	MOVZWL	#128,SHR_L_POOLBCNT	; SET DEFAULT POOL BLOCK COUNT
	MOVZWL	#64,SHR_L_PRQCNT	; SET DEFAULT PRQ COUNT
	CLRL	SHR_L_START		; SET DEFAULT STARTING PFN
	CLRB	SHR_B_OPTIONS		; RESET ALL OPTIONS
	MOVL	#1,R0			; SET SUCCESS
	RET				; RETURN

GEN$SHR_MEMNAME::			; SET THE MEMORY NAME
	.WORD	0			; ENTRY MASK
	CMPW	TPA$L_TOKENCNT(AP),#15	; IS NAME TOO LONG?
	BGEQU	10$			; BRANCH IF YES
	MOVQ	TPA$L_TOKENCNT(AP),SHR_Q_MEMNAME ; SET MEMORY NAME DESC
	RET				; EXIT
10$:
	CLRL	R0			; SET FAILURE
	RET				; EXIT

GEN$SHR_UNIT::				; SET MEMORY UNIT #
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_UNIT ; SET MEMORY UNIT #
	RET				; EXIT

GEN$SHR_GBLCNT::			; SET GLOBAL SECTION COUNT
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_GBLCNT ; SET GLOBAL SECTION CNT
	BNEQ	10$			; BRANCH IF AT LEAST 1
	MOVW	#1,SHR_W_GBLCNT		; SET MINIMUM OF 1
10$:
	RET				; EXIT

GEN$SHR_MBXCNT::			; SET MAILBOX COUNT
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_MBXCNT ; SET MAILBOX COUNT
	BNEQ	10$			; BRANCH IF AT LEAST 1
	MOVW	#1,SHR_W_MBXCNT		; SET MINIMUM OF 1
10$:
	RET				; EXIT

GEN$SHR_CEFCNT::			; SET COMMON EVENT FLAG CLUSTER COUNT
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_CEFCNT ; SET COM EVT FLAG CLUSTER COUNT
	BNEQ	10$			; BRANCH IF AT LEAST 1
	MOVW	#1,SHR_W_CEFCNT		; SET MINIMUM OF 1
10$:
	RET				; EXIT

GEN$SHR_GBLMAX::			; SET PORT MAX GLOBAL SECTIONS
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_GBLQUO ; SET PORT MAX 
	RET				; EXIT

GEN$SHR_MBXMAX::			; SET PORT MAX MAILBOXES
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_MBXQUO ; SET PORT MAX
	RET				; EXIT

GEN$SHR_CEFMAX::			; SET PORT MAX COM EVT FLG CLUSTERS
	.WORD	0			; ENTRY MASK
	MOVW	TPA$L_NUMBER(AP),SHR_W_CEFQUO ; SET PORT MAX
	RET				; EXIT

GEN$SHR_POOLC::				; SET POOL BLOCK COUNT
	.WORD	0			; ENTRY MASK
	MOVL	TPA$L_NUMBER(AP),SHR_L_POOLBCNT ; SET POOL BLOCK COUNT
	BNEQ	10$			; BRANCH IF NOT = 0
	MOVL	#1,SHR_L_POOLBCNT	; SET MINIMUM OF 1
10$:
	RET				; EXIT

GEN$SHR_POOLS::				; SET POOL BLOCK SIZE
	.WORD	0			; ENTRY MASK
	MOVAL	SHR_L_POOLBSIZ,R0	; GET ADDR OF SIZE BUFFER
	MOVL	TPA$L_NUMBER(AP),(R0)	; SET SPECIFIED POOL BLOCK SIZE
	MOVL	#<ACB$L_KAST+4>,R1	; GET MINIMUM SIZE (SIZE OF ACB)
	CMPL	(R0),R1			; IS SPECIFIED SIZE BIG ENOUGH?
	BGEQU	10$			; BRANCH IF YES
	MOVL	R1,R0			; ELSE, SET SIZE TO MINIMUM
10$:
	ADDL	#^B111,(R0)		; ROUND UP FOR QUADWORD ALIGNMENT
	BICL	#^B111,(R0)		; ...
	MOVL	#SS$_NORMAL,R0		; RETURN SUCCESS
	RET				; EXIT

GEN$SHR_PRQCNT::			; SET INTER-PROCESSOR REQUEST BLOCK COUNT
	.WORD	0			; ENTRY MASK
	MOVL	TPA$L_NUMBER(AP),SHR_L_PRQCNT ; SET PRQ COUNT
	BNEQ	10$			; BRANCH IF NOT = 0
	MOVL	#1,SHR_L_PRQCNT		; SET MINIMUM OF 1
10$:
	RET

GEN$SHR_START::				; SET START OF MEMORY
	.WORD	0			; ENTRY MASK
	MOVL	TPA$L_NUMBER(AP),SHR_L_START ; SET START OF MEMORY PFN
	RET				; EXIT

GEN$SHR_INIT::				; SET INIT OPTION
	.WORD	0			; ENTRY MASK
	BISB	#SHR_OPT_M_INIT,SHR_B_OPTIONS ; SET INIT OPTION
	RET				; EXIT

	.PAGE
	.SBTTL	SHARE COMMAND MAIN ACTION ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS IS THE MAIN SHARE COMMAND ACTION ROUTINE.  IT PERFORMS
;	ALL THE REAL WORK OF INITIALIZING AND/OR CONNECTING TO A SHARED
;	MEMORY.
;
;
; CALLING SEQUENCE:
;
;	CALLED AS A TPARSE ACTION ROUTINE.
;	(SEE THE RUN-TIME LIBRARY MANUAL FOR DETAILS)
;
; INPUTS:
;
;	STANDARD TPARSE PARAMETER BLOCK.
;
;	QUALIFIER VALUES ASSUMED TO BE STORED BY PREVIOUS ACTION
;	ROUTINES.
;
; OUTPUTS:
;
;	PROCESSOR CONNECTED TO THE SHARED MEMORY.  IF /INIT IS SPECIFIED,
;	THE MEMORY AND DATASTRUCTURES ARE ALSO INITIALIZED.
;
;--

GEN$SHARE::				; MAIN SHARE ACTION ROUTINE
	.WORD	0			; ENTRY MASK

	$CMKRNL_S SHARE			; DO IT IN KERNEL MODE
	BLBC	R0,10$			; BRANCH IF FAILURE
	$CMEXEC_S SHOW_STRUCT		; SHOW THE STRUCTURES
	BLBC	R0,10$			; BRANCH IF FAILURE
	CALLS	#0,LOADMBDRIVER		; LOAD THE MAILBOX DRIVER
	BLBC	R0,10$			; BRANCH IF FAILURE
	RET				; EXIT

10$:
	INSV	#STS$K_ERROR,-		; CONVERT STATUS TO ERROR
		#STS$V_SEVERITY,#STS$S_SEVERITY,R0
	PUSHL	R0			; SET ERROR
	CALLS	#1,G^LIB$SIGNAL		; SIGNAL THE ERROR
	MOVL	#STS$K_SUCCESS,R0	; SET SUCCESS FOR PARSER
	RET				; EXIT

	.PAGE
	.SBTTL	SHARE KERNEL ROUTINE
;++
;
; SHARE - KERNEL ROUTINE TO INIT AND CONNECT TO A SHARED MEMORY
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S SHARE
;
; INPUTS:
;
;	SHARE COMMAND QUALIFIER VALUES STORED.
;
; OUPUTS:
;
;	R0 = SUCCESS OR FAILURE STATUS.
;
;	IF SUCCESS, MEMORY DATA STRUCTURES INITIALIZED (IF SO SPECIFIED)
;	AND MEMORY CONNECTED VIA THE SHARED MEMORY CONTROL BLOCK (SHB).
;
;--
SHARE:					; KERNEL ROUTINE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; ENTRY MASK
;
; MAKE SURE THAT MA780 IS NOT BEING USED FOR MAIN MEMORY.
;
	MOVL	#SYSG$_SHMDBLUSE,R0	; ASSUME ERROR
	MOVL	G^EXE$GL_RPB,R4		; GET ADDRESS OF RPB
	BITL	#<RPB$M_MPM ! RPB$M_USEMPM>,RPB$L_BOOTR5(R4) ; USED AS MAIN MEM?
	BNEQ	ERR_EXIT		; BRAND ON ERROR, IS USED AS MAIN MEM
;
; FIRST MAKE SURE THAT THE ADAPTER IS INITIALIZED AND CONNECTED
;
	CLRL	R4			; INIT ADAPTER NUMBER
	MOVL	G^EXE$GL_NUMNEXUS,R7	; GET ADDRESS OF NUMBER OF NEXUSES
	MOVL	G^EXE$GL_CONFREG,R5	; GET ADDRESS OF CONFREG ARRAY
10$:	MOVZBL	(R5)[R4],R2		; GET ADAPTER TYPE CODE
	BEQL	30$			; BRANCH IF NONE
	CMPB	R2,#NDT$_MPM0		; IS ADAPTER A MULTI-PORT MEMORY?
	BLSSU	30$			; BRANCH IF NOT
	CMPB	R2,#NDT$_MPM3		; IS ADAPTER A MULTI-PORT MEMORY?
	BGTRU	30$			; BRANCH IF NOT
	MOVL	G^IOC$GL_ADPLIST,R3	; GET ADDRESS OF FIRST ADAPTER BLOCK
20$:	CMPW	ADP$W_TR(R3),R4		; IS THIS THE BLOCK FOR THE MEMORY?
	BEQL	30$			; BRANCH IF YES - NO NEED TO CREATE ONE
	MOVL	ADP$L_LINK(R3),R3	; GET ADDRESS OF NEXT BLOCK
	BNEQ	20$			; BRANCH IF THERE IS ONE
	JSB	G^INI$MPMADP		; ELSE, CREATE AN ADAPTER CONTROL BLOCK
30$:
	AOBLSS	R7,R4,10$		; INCREMENT ADAPTER NUMBER AND LOOP
;
; FIND THE SPECIFIED SHARED MEMORY UNIT AND GET ITS ADDRESS
;
FIND_UNIT:
	MOVL	G^IOC$GL_ADPLIST,R6	; GET ADDR OF FIRST ADAPTER BLOCK
	BEQL	30$			; BRANCH IF NONE
10$:					; ADAPTER SEARCH LOOP
	CMPB	#AT$_MPM,ADP$W_ADPTYPE(R6) ; IS ADAPTER A MULTI-PORT?
	BNEQ	20$			; BRANCH IF NOT
	MOVL	ADP$L_CSR(R6),R4	; GET CSR OF ADAPTER
	MOVL	MPM$L_MR(R4),R1		; GET MAINTENENCE VALUE
	EXTZV	#MPM$V_MR_UNIT,-	; GET UNIT NUMBER
		#MPM$S_MR_UNIT,R1,R0	;
	CMPW	R0,SHR_W_UNIT		; IS IT DESIRED UNIT NUMBER?
	BEQLU	INIT			; BRANCH IF YES
20$:
	MOVL	ADP$L_LINK(R6),R6	; GET ADDR OF NEXT ADAPTER BLOCK
	BNEQ	10$			; BRANCH IF ONE EXISTS
30$:
	MOVL	#SYSG$_NOSUCHMEM,R0	; SET FAILURE
ERR_EXIT:
	RET				; EXIT
;
; SUBROUTINE USED BY INI$MPMADP TO ALLOCATE NON-PAGED POOL AND EXIT ROUTINE
; CALL IF FAILURE
;
INI$ALONONPAGED::			;
	BSBW	IOGEN$ALLOBLOCK		; ALLOCATE A BLOCK
	BLBC	R0,10$			; BRANCH IF FAILURE
	RSB				; ELSE, OK
10$:	RET				; EXIT ROUTINE WITH STATUS
;
; INITIALIZE AND/OR CONNECT SHARED MEMORY
;
INIT:
	MOVL	R6,SHR_L_ADP		; SAVE ADP BLOCK ADDRESS
	BSBW	CREATE_SHB		; CREATE SHARED MEM CONTROL BLCK
	BLBC	R0,EXIT			; BRANCH IF ERROR
	SETIPL	#IPL$_HWCLK-1		; SYNCHRONIZE LOCAL ACCESSORS
	BSBW	MAP_DATAPAGE		; MAP THE DATAPAGE
	BLBC	R0,EXIT			; BRANCH IF ERROR
	BSBW	LOCK_DATAPAGE		; LOCK THE DATAPAGE
	BBC	#SHR_OPT_V_INIT,-	; BRANCH IF /INIT NOT SPECIFIED
		SHR_B_OPTIONS,CONNECT	;
	BSBW	CHECK_INIT		; CHECK IF OK TO INITIALIZE
	BLBC	R0,CONNECT		; BRANCH IF NOT
	BSBW	INIT_DATAPAGE		; INITIALIZE THE DATAPAGE
	BLBC	R0,UNLOCK_EXIT		; BRANCH IF ERROR
	BSBW	MAP_STRUCTURES		; MAP THE OTHER DATA STRUCTURES
	BLBC	R0,UNLOCK_EXIT		; BRANCH IF ERROR
	BSBW	INIT_STRUCTURES		; INIT THE OTHER DATA STRUCTURES
	BLBC	R0,UNLOCK_EXIT		; BRANCH IF ERROR
	BRB	CONNECTED		; INIT COMPLETED SUCCESSFULLY
;
; JUST CONNECT TO SHARED MEMORY
;
CONNECT:				; CONNECT TO SHARED MEMORY
	BBS	#SHB$V_CONNECT,-	; BRANCH IF ALREADY CONNECTED
		SHB$B_FLAGS(R5),UNLOCK_EXIT
	BSBW	MAP_STRUCTURES		; MAP THE OTHER DATA STRUCTURES
	BLBC	R0,UNLOCK_EXIT		; BRANCH IF ERROR
	BSBW	CONNECT_MEM		; CONNECT TO DATA STRUCTURES
	BLBC	R0,UNLOCK_EXIT		; BRANCH IF ERROR
CONNECTED:				; CONNECTED SUCCESSFULLY
	BISB	#SHB$M_CONNECT,SHB$B_FLAGS(R5) ; SET MEMORY CONNECTED
	DSBINT				; LOCK OUT INTERRUPTS
	MOVL	SHB$L_ADP(R5),R4	; GET ADDRESS OF ADP FOR THIS MA780
	MOVZBL	SHB$B_PORT(R5),R5	; GET OWN PORT NUMBER
	JSB	G^MA$REQUEST		; FORCE INTERRUPT ON OWN PORT TO
	ENBINT				;  IMMEDIATELY PROCESS DANGLING PRQS
UNLOCK_EXIT:				; UNLOCK DATAPAGE AND EXIT
	BSBW	UNLOCK_DATAPAGE		; UNLOCK DATAPAGE
EXIT:					; EXIT KERNEL ROUTINE
	SETIPL	#0			; RESTORE NORMAL IPL
	RET				; RETURN

	.PAGE
	.SBTTL	CREATE SHARED MEMORY CONTROL BLOCK
;++
;
; CREATE_SHB - CREATE SHARED MEMORY CONTROL BLOCK
;
; THIS ROUTINE IS CALLED TO CREATE A SHARED MEMORY CONTROL BLOCK
; IN THE PROCESSOR'S LOCAL MEMORY POOL.
;
; INPUTS:
;
;	R4 = ADDRESS OF NEXUS CSR
;	R6 = ADAPTER CONTROL BLOCK ADDRESS
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE STATUS
;	R5 = ADDRESS OF SHARED MEMORY CONTROL BLOCK
;
;	IF SHB FOR MEMORY DID NOT EXIST, IT IS CREATED AND LINKED
;	INTO SHB LIST (EXE$GL_SHBLIST).
;--
CREATE_SHB:				; CREATE SHB
;
; CHECK IF SHARED MEMORY CONTROL BLOCK FOR THIS MEMORY ALREADY EXISTS.
;
	ASSUME	SHB$L_LINK EQ 0
	MOVAL	G^EXE$GL_SHBLIST,R5	; GET ADDR OF SHB LIST
10$:
	TSTL	SHB$L_LINK(R5)		; IS THERE A NEXT SHB?
	BEQL	20$			; BRANCH IF NOT
	MOVL	SHB$L_LINK(R5),R5	; GET ADDR OF NEXT SHB
	CMPB	SHB$B_NEXUS(R5),-	; IS THIS THE NEXUS?
		ADP$W_TR(R6)		;
	BNEQ	10$			; BRANCH IF NOT - TRY NEXT ONE
	BRB	30$			; ELSE - ALREADY EXISTS
;
; CREATE A SHARED MEMORY CONTROL BLOCK FOR THIS MEMORY PORT
;
20$:					;
	MOVZBL	#SHB$K_LENGTH,R1	; SET SIZE OF SHB
	BSBW	IOGEN$ALLOBLOCK		; ALLOCATE THE SHB
	BLBC	R0,40$			; BRANCH IF FAILURE
	MOVL	R2,SHB$L_LINK(R5)	; SET FORWARD LINK TO SHB
	MOVL	R2,R5			; SET ADDR OF SHB
					; UNITIALIZED FIELDS ARE ZERO!
	MOVW	R1,SHB$W_SIZE(R5)	; SET SIZE OF SHB IN SHB
	MOVB	#DYN$C_SHB,SHB$B_TYPE(R5) ; SET TYPE OF SHB IN SHB
	MOVL	R5,ADP$L_SHB(R6)	; SET LINK TO SHB IN ADP
	MOVL	R6,SHB$L_ADP(R5)	; SET LINK TO ADP IN SHB
	MOVB	ADP$W_TR(R6),SHB$B_NEXUS(R5) ; SET NEXUS NUMBER
	MOVL	MPM$L_CSR(R4),R0	; GET CSR
	EXTZV	#MPM$V_CSR_PORT,-	; GET PORT NUMBER
		#MPM$S_CSR_PORT,R0,R0
	MOVB	R0,SHB$B_PORT(R5)	; SET PORT NUMBER
30$:
	MOVL	#1,R0			; SET SUCCESS
40$:
	RSB				; RETURN

	.PAGE
	.SBTTL	MAP THE DATAPAGE
;++
;
; MAP_DATAPAGE - MAP SHARED MEMORY DATAPAGE (LAST PAGE IN MEMORY)
;
; THIS ROUTINE IS CALLED TO MAP THE SHARED MEMORY DATAPAGE INTO
; THE SYSTEM VIRTUAL ADDRESS SPACE.
;
; INPUTS:
;
;	R4 = ADDR OF NEXUS CSR
;	R5 = ADDR OF SHARED MEMORY CONTROL BLOCK (SHB)
;
;	IPL MUST BE IPL$_SYNCH.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE STATUS.
;	R6 = ADDR OF DATAPAGE
;
;--
MAP_DATAPAGE:				; MAP THE DATAPAGE
	MOVL	MPM$L_INV(R4),R7	; GET INVALIDATION REG VALUE
	EXTZV	#MPM$V_INV_STADR,#MPM$S_INV_STADR,- ;GET STARTING SBI
		R7,R0			;LONGWORD ADDR<26:16> OF MEMORY
	ASHL	#16+2-VA$V_VPN,R0,R0	; CONVERT TO A PFN
	MOVL	R0,SHR_L_MEMPFN		; SAVE MEMORY STARTING PFN
	EXTZV	#MPM$V_INV_MEMSZ,#MPM$S_INV_MEMSZ,- ; GET MEMORY SIZE IN
		R7,R7			; 256KB BOARD INCREMENTS
	INCL	R7			; (0 = 1 BOARD)
	MULL	#<256*1024>/512,R7	; CONVERT TO PAGES
	MOVL	R7,SHR_L_MEMSIZE	; SAVE MEMORY SIZE
	ADDL	R0,R7			; COMPUTE PFN OF LAST PAGE
	DECL	R7			; ...

	MOVL	SHB$L_DATAPAGE(R5),R6	; DATAPAGE ALREADY MAPPED?
	BNEQ	20$			; BRANCH IF YES
	ASSUME	SHD$K_LENGTH LE 512  	; ASSUME 1 PAGE
	MOVL	#1,R1			; SET NUMBER PAGES
	JSB	G^IOC$ALLOSPT		; ALLOCATE A SPT ENTRY
	BLBS	R0,10$			; BRANCH IF SUCCESS
	MOVL	#SYSG$_SPTFULL,R0	; SET FAILURE STATUS
	RSB				; EXIT
10$:
	ASHL	#VA$V_VPN,R2,R6		; CONVERT VPN TO VA
	BISL	#VA$M_SYSTEM,R6		; ADD SYSTEM SPACE TO VA
	MOVL	R6,SHB$L_DATAPAGE(R5)	;  AND SAVE IN SHB
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R7,- ; FILL-IN DATAPAGE SPT
		(R3)[R2]		; ENTRY AND SET VALID
20$:
	MOVL	G^EXE$GL_RPB,R0		; GET ADDRESS OF RPB
	ADDL	#RPB$L_MEMDSC,R0	; POINT TO FIRST MEMORY DESCRIPTOR
30$:
	CMPB	3(R0),SHB$B_NEXUS(R5)	; DOES MA780 TR NUMBER MATCH THIS DSC?
	BEQL	40$			; BR IF FOUND THE MEMORY DESCRIPTOR
	ADDL	#8,R0			; POINT TO NEXT DESCRIPTOR
	TSTL	(R0)			; IS THERE ANOTHER MEMORY TO CHECK?
	BNEQ	30$			; BR IF THERE IS ANOTHER VALID DSC
;
; NO MEMORY DESCRIPTOR WAS FOUND FOR THIS MA780.  THEREFORE, IT WAS
; PROBABLY POWERED UP AFTER THE SYSTEM WAS BOOTED.  A MEMORY DESCRIPTOR
; IN THE RPB MUST BE CREATED SO THAT THE MA780 PAGES WILL GET WRITTEN
; TO THE DUMP FILE DURING A BUGCHECK.
;
	MOVL	SHR_L_MEMSIZE,(R0)+	; SET # OF PAGES OF MEMORY
	MOVB	SHB$B_NEXUS(R5),-1(R0)	; SET TR # OF MEMORY
	MOVL	SHR_L_MEMPFN,(R0)	; SET STARTING PHYS ADR OF MEMORY
40$:
	MOVL	#1,R0			; SET SUCCESS
	MOVL	R6,SHR_L_DATAPAGE	; SAVE ADDRESS OF DATAPAGE
	RSB				; RETURN

	.PAGE
	.SBTTL	LOCK/UNLOCK THE DATAPAGE
;++
;
; LOCK_DATAPAGE - LOCK THE DATAPAGE FOR INITIALIZATION/CONNECTION
; UNLOCK_DATAPAGE - UNLOCK THE DATAPAGE
;
; THE INIT FLAG IS CLEAR WHEN IT IS LOCKED FOR INITIALIZATION.  THIS IS
; BECAUSE THE MEMORY IS INITIALIZED TO ALL 1'S WHEN IT IS POWERED ON AND
; THE COMPLETE TIMEOUT WOULD HAVE TO ELAPSE EVERYTIME A NEWLY POWERED-ON
; MEMORY WAS INITIALIZED.  TO AVOID THIS, THE SENSE OF THE LOCK IS
; REVERSED.
;
; INPUTS:
;
;	R5 = ADDRESS OF SHARED MEMORY CONTROL BLOCK (SHB)
;	R6 = ADDRESS OF DATAPAGE
;
;	IPL LESS THAN IPL$_HWCLK SO TIME CAN BE UPDATED.
;
; OUTPUTS:
;	THE INIT FLAG IS CLEARED OR SET, INDICATING A PORT IS CURRENTLY
;	INITIALIZING/CONNECTING OR DONE INITIALIZING CONNECTING, RESPECTIVELY.
;
LOCK_DATAPAGE:				; LOCK DATAPAGE INIT LOCK
	MOVQ	G^EXE$GQ_SYSTIME,R0	; GET CURRENT SYSTEM TIME
	ADDL	#INITLOCK_TIMOUT,R0	; COMPUTE TIMEOUT TIME
	ADWC	#0,R1			; ...
10$:	BBCCI	#SHD$V_INITLCK,SHD$B_FLAGS(R6),20$
	BRB	30$
20$:	CMPL	R1,G^EXE$GQ_SYSTIME+4	; TIMEOUT?
	BGTRU	10$			; IF GTRU, NO
	CMPL	R0,G^EXE$GQ_SYSTIME	; TIMEOUT?
	BGTRU	10$			; IF GTRU, NO
30$:
	MOVB	SHB$B_PORT(R5),SHD$B_INITLCK(R6) ; SET LOCKING PORT NUMBER
	RSB				;

UNLOCK_DATAPAGE:			; UNLOCK THE DATAPAGE INIT LOCK
	BBSSI	#SHD$V_INITLCK,SHD$B_FLAGS(R6),10$
10$:
	RSB

	.PAGE
	.SBTTL	CHECK IF MEMORY CAN BE INITIALIZED
;++
;
; CHECK_INIT - CHECK IF MEMORY CAN BE INITIALIZED
;
; THIS ROUTINE IS CALLED TO CHECK THAT NO OTHER PORTS ARE USING THE
; THE MEMORY AND IT IS ALRIGHT TO INTIALIZE IT.
;
; INPUTS:
;
;	R4 = ADDR OF NEXUS CSR
;	R5 = ADDR OF SHB
;	R6 = ADDR OF DATAPAGE (SHD)
;
; OUTPUTS:
;
;	R0 = SUCCESS IF MEMORY CAN BE INITIALIZED.
;
;	THIS PORT'S REFERENCE COUNT TO THE MEMORY IS CHECKED, IF IT IS NON-ZERO,
;	THE MEMORY CAN'T BE INITIALIZED.
;
;	THE OTHER PORTS ARE POLLED TO SEE IF THEY ARE CONNECTED TO THE MEMORY
;	BY CLEARING A POLLING MASK AND INTERRUPTING ALL THE PORTS.  IF A PORT
;	IS CONNECTED, IT WILL SET ITS POLLING FLAG, INDICATING THE MEMORY
;	SHOULD NOT BE INITIALIZED.  IF THE TIMEOUT EXPIRES AND NO PORT HAS
;	SET A POLLING FLAG, IT IS OK TO INITIALIZE.
;
;--
CHECK_INIT:				; CHECK IF MEMORY CAN BE INITED
	TSTL	SHB$L_REFCNT(R5)	; ANY REFERENCES TO MEMORY?
	BNEQ	NO_INIT			; BRANCH IF YES
;
; POLL OTHER PORTS TO SEE IF THEY ARE CONNECTED TO THE MEMORY
;
POLL:
	PUSHR	#^M<R4,R5,R6>		; SAVE REGISTERS
	CLRW	SHD$W_POLL(R6)		; CLEAR POLLING FLAGS
	MOVL	SHB$L_ADP(R5),R4	; SET ADDRESS OF ADAPTER CONTROL BLOCK
	CLRL	R5			; INIT PORT NUMBER
5$:	JSB	G^MA$REQUEST		; WAKEUP THE PROCESSOR AT THE PORT
	AOBLSS	#MPM$C_PORTS,R5,5$	; INCREMENT PORT NUMBER AND LOOP
	POPR	#^M<R4,R5,R6>		; RESTORE REGISTERS

	MOVQ	G^EXE$GQ_SYSTIME,R0	; GET CURRENT SYSTEM TIME
	ADDL	#INITPOLL_TIMOUT,R0	; COMPUTE TIMEOUT TIME
	ADWC	#0,R1			; ...
10$:	TSTW	SHD$W_POLL(R6)		; ANY PORT ACTIVE?
	BNEQ	NO_INIT			; IF NEQ, YES - CAN'T INITIALIZE
20$:	CMPL	R1,G^EXE$GQ_SYSTIME+4	; TIMEOUT?
	BGTRU	10$			; IF GTRU, NO
	CMPL	R0,G^EXE$GQ_SYSTIME	; TIMEOUT?
	BGTRU	10$			; IF GTRU, NO
30$:
	MOVL	#1,R0			; OK TO INITIALIZE
	RSB				; RETURN

NO_INIT:				; NOT OK TO INITIALIZE
	CLRL	R0			; SET FAILURE
	RSB				; RETURN

	.PAGE
	.SBTTL	INITIALIZE THE DATAPAGE
;++
;
; INIT_DATAPAGE - INITIALIZE THE DATAPAGE
;
; THIS ROUTINE IS CALLED TO INTIALIZE THE SHARED MEMORY DATAPAGE
; FIELDS AND ALLOCATE THE OTHER DATA STRUCTURES.
;
; INPUTS:
;
;	R4 = ADDR OF NEXUS CSR
;	R5 = ADDR OF SHB
;	R6 = ADDR OF DATAPAGE (SHD)
;	SHR_VALUES = LIST OF SHARE COMMAND QUALIFIER VALUES
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE STATUS.
;
;	SHARED MEMORY DATAPAGE IS INITIALIZED.
;
;	DURING INITIALIZATION, THE OTHER DATASTRUCTURES ARE ALLOCATED
;	SO THAT THE APPEAR IN THE FOLLOWING ORDER IN VIRTUAL MEMORY:
;
;		+-----------------------+
;		|       DATAPAGE	|
;		+-----------------------+
;		\     PER PORT PAGES	\
;		+-----------------------+
;		|	PRQ'S		|
;		+-----------------------+
;		|	GSD'S		|
;		+-----------------------+
;		|	MBX'S		|
;		+-----------------------+
;		|	CEF'S		|
;		+-----------------------+
;		|	POOL		|
;		+-----------------------+
;		|	BITMAP		|
;		+-----------------------+
;		|			|
;		\ GLOBAL SECTION PAGES	\
;		|			|
;		+-----------------------+
;
;	*** NOTE: THE ORDER OF THESE STRUCTURES IS ASSUMED ****
;--
INIT_DATAPAGE:				; INITIALIZE THE DATAPAGE
	MOVB	#SHD$M_INITLCK,-	; CLEAR THE FLAGS BUT KEEP
		SHD$B_FLAGS(R6)		;  THE LOCK SET
	MOVB	SHR_Q_MEMNAME,-		; SET MEMORY NAME SIZE
		SHD$T_NAME(R6)		;
	PUSHR	#^M<R4,R5>		; SAVE MOVC REGISTERS
	MOVC5	SHR_Q_MEMNAME,@SHR_Q_MEMNAME+4,- ; SET MEMORY NAME STRING
		#0,#15,SHD$T_NAME+1(R6)	; ZERO-FILLED TO 15 TEXT BYTES
	POPR	#^M<R4,R5>		; RESTORE MOVC REGISTERS
	MOVQ	G^EXE$GQ_SYSTIME,-	; SET INITIALIZATION TIME
		SHD$Q_INITTIME(R6)	;
	CLRL	R0			;INIT PORT NUMBER
	ASSUME	<SHD$Q_PRQWRK & ^B111> EQ 0 ; LIST HEADS MUST BE QUADWORD ALIGNED
10$:	CLRQ	SHD$Q_PRQWRK(R6)[R0]	;INIT PORT'S REQUEST WORK QUEUE
	AOBLSS	#MPM$C_PORTS,R0,10$	;INCREMENT PORT NUMBER AND LOOP
	CLRW	SHD$W_PRQWAIT(R6)	;INIT PRQ WAIT FLAGS
	CLRW	SHD$W_RESSUM(R6)	;INIT RESOURCE REPORT SUMMARY FLAGS
	CLRL	R0			;SET STARTING RESOURCE NUMBER
15$:	CLRW	SHD$W_RESAVAIL(R6)[R0]	;INIT RESOURCE AVAILABLE FLAGS
	CLRW	SHD$W_RESWAIT(R6)[R0]	;INIT RESOURCE WAIT FLAGS
	AOBLSS	#RSN$_MAX,R0,15$	;INCREMENT RESOURCE NUMBER AND LOOP
	MOVB	#MPM$C_PORTS,SHD$B_PORTS(R6) ; SET NUMBER OF PORTS
	MOVL	SHR_L_START,-		; SET RELATIVE PFN
		SHD$L_GSPFN(R6)		;  OF 1ST GLOBAL PAGE
	ADDL3	SHD$L_GSPFN(R6),-	; SET PFN OF 1ST GLOBAL PAGE
		SHR_L_MEMPFN,SHB$L_BASGSPFN(R5)
	MOVW	SHR_W_GBLCNT,SHD$W_GSDMAX(R6) ; SET GLOBAL SECTION DESC COUNT
	MOVW	SHR_W_MBXCNT,SHD$W_MBXMAX(R6) ; SET MAILBOX COUNT
	MOVW	SHR_W_CEFCNT,SHD$W_CEFMAX(R6) ; SET COMMON EVT FLAG CLUST COUNT
	MOVZBL	SHB$B_PORT(R5),R0	; GET THIS PORT'S PORT NUMBER
	MOVW	SHR_W_GBLQUO,SHD$W_GSDQUOTA(R6)[R0] ; SET THIS PORT'S GSD QUOTA
	MOVW	SHR_W_MBXQUO,SHD$W_MBXQUOTA(R6)[R0] ; SET THIS PORT'S MBX QUOTA
	MOVW	SHR_W_CEFQUO,SHD$W_CEFQUOTA(R6)[R0] ; SET THIS PORT'S CEF QUOTA
;
; FILL-IN DATAPAGE RELATIVE ADDRESSES OF OTHER DATA STRUCTURES AND
; AND KEEP A TOTAL OF THE NUMBER OF PAGES NEEDED FOR THE STUCTURES.
;
	MOVZWL	#511,R0			; GET SIZE OF PAGE - 1
	MOVZWL	#512,R1			; GET SIZE OF A PAGE
	MOVL	#1,R3			; INIT RELATIVE PAGE POINTER
	ADDL	#MPM$C_PORTS,R3		; RESERVE PER PORT PAGES
	ASHL	#VA$V_VPN,R3,-		; SET RELATIVE ADDR OF PRQ FREE LIST
		SHD$Q_PRQ(R6)		;
	MULL3	#PRQ$C_MINLENGTH,-	; COMPUTE NUMBER BYTES FOR PRQ'S
		SHR_L_PRQCNT,R2		;
	ADDL	R0,R2			; ROUND-UP TO A PAGE
	DIVL	R1,R2			; CONVERT TO PAGES
	ADDL	R2,R3			; COMPUTE RELATIVE PAGE OF GSD'S
	ASHL	#VA$V_VPN,R3,-		; SET RELATIVE ADDR OF GSD TABLE
		SHD$L_GSDPTR(R6)	;
	MOVZWL	SHR_W_GBLCNT,R2		; GET NUMBER OF GSD'S
	ADDL3	#GSD$K_SHMGSDLNG,-	; COMPUTE SIZE OF GSD'S
		#<MPM$C_PORTS*4>,SHR_L_GSDSIZE ; (LONGWORD REFCNT/PORT)
	MULL	SHR_L_GSDSIZE,R2	; COMPUTE NUMBER BYTES NEEDED
	ADDL	R0,R2			; ROUND-UP TO A PAGE
	DIVL	R1,R2			; CONVERT TO PAGES
	ADDL	R2,R3			; COMPUTE RELATIVE PAGE OF MBX'S
	ASHL	#VA$V_VPN,R3,-		; SET RELATIVE ADDR OF MBX TABLE
		SHD$L_MBXPTR(R6)	;
	MOVZWL	SHR_W_MBXCNT,R2		; GET NUMBER OF MAILBOXES
	MULL	#MBX$K_LENGTH,R2	; COMPUTE NUMBER BYTES NEEDED
	ADDL	R0,R2			; ROUND-UP TO A PAGE
	DIVL	R1,R2			; CONVERT TO PAGES
	ADDL	R2,R3			; COMPUTE RELATIVE PAGE OF CEF TABLE
	ASHL	#VA$V_VPN,R3,-		; SET RELATIVE ADDR OF CEF TABLE
		SHD$L_CEFPTR(R6)	;
	MOVZWL	SHR_W_CEFCNT,R2		; GET NUMBER OF COM EVT FLAG BLOCKS
	ADDL3	#CEB$C_LENGTH,-		; COMPUTE SIZE OF SHMCEB
		#<MPM$C_PORTS*6>,SHR_L_CEFSIZE ; (WORD REFCNT+SLAVE VA/PORT)
	MULL	SHR_L_CEFSIZE,R2	; COMPUTE NUMBER BYTES NEEDED
	ADDL	R0,R2			; ROUND-UP TO A PAGE
	DIVL	R1,R2			; CONVERT TO PAGES
	ADDL	R2,R3			; COMPUTE RELATIVE PAGE OF POOL
	ASHL	#VA$V_VPN,R3,-		; SET RELATIVE ADDR OF POOL
		SHD$Q_POOL(R6)		;
	MULL3	SHR_L_POOLBCNT,-	; COMPUTE SIZE OF POOL IN BYTES
		SHR_L_POOLBSIZ,R2	;
	ADDL	R0,R2			; ROUND-UP TO A PAGE
	DIVL	R1,R2			; CONVERT TO PAGES
	ADDL	R2,R3			; COMPUTE RELATIVE PAGE OF BITMAP
	ASHL	#VA$V_VPN,R3,-		; SET RELATIVE ADDR OF BITMAP
		SHD$L_GSBITMAP(R6)	;
;
; COMPUTE NUMBER PAGES LEFT FOR GLOBAL SECTIONS AND SIZE OF BITMAP
; TO REPRESENT GLOBAL SECTION PAGES.
;
	SUBL3	SHD$L_GSPFN(R6),-	; GET MEMORY SIZE
		SHR_L_MEMSIZE,R0	;  LESS RESERVED AREA
	SUBL	R3,R0			; COMPUTE NUMBER GLOBAL SECTION
					; PAGES THAT WILL BE AVAILABLE
	BLEQ	20$			; BRANCH IF THERE ARE NONE
	ADDL3	#<512*8>-1,R0,R1	; ROUND-UP TO NUMBER PER
					;  PAGE OF BITMAP
	DIVL	#<512*8>,R1		; COMPUTE NUMBER PAGES FOR BITMAP
	SUBL3	R1,R0,SHD$L_GSPAGCNT(R6) ; SET NUMBER GLOBAL PAGES AVAIL
					;  LESS NUMBER BITMAP PAGES
	BLEQ	20$			; BRANCH IF NONE
	BSBW	DATAPAGE_CRC		; COMPUTE DATAPAGE CRC
	MOVL	R0,SHD$L_CRC(R6)	; SET CRC
	MOVL	#1,R0			; SET SUCCESS
	RSB				; RETURN

20$:
	MOVL	#SYSG$_BADPARAM,R0	; SET FAILURE
	RSB				; RETURN

	.PAGE
	.SBTTL	MAP THE OTHER DATA STRUCTURES
;++
;
; MAP_STRUCTURES - MAP THE OTHER DATA STRUCTURES
;
; THIS ROUTINE IS CALLED TO MAP THE OTHER DATA STRUCTURES INTO
; SYSTEM VIRTUAL ADDRESS SPACE.
;
; INPUTS:
;
;	R4 = ADDR OF CSR NEXUS
;	R5 = ADDR OF SHB
;	R6 = ADDR OF DATAPAGE (SHD)
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE STATUS.
;
;	THE OTHER SHARED MEMORY DATA STRUCTURES (POOL, MAILBOXES,
;	GLOBAL SECTION DESCRIPTORS, GLOBAL SECTION BITMAP) ARE
;	MAPPED IN SYSTEM SPACE.  THE RELATIVE ADDRESSES IN THE 
;	DATAPAGE CAN NOW BE USED TO ACCESS THE STRUCTURES.
;
;	NOTE: THE PAGES ARE MAPPED SO THAT THE HIGHEST NUMBERED PFN
;	HAS THE LOWEST VIRTUAL ADDRESS.
;
;--
MAP_STRUCTURES:				; MAP THE OTHER STRUCTURES
	ASHL	#-VA$V_VPN,-		; GET NUMBER OF PAGES TO MAP
		SHD$L_GSBITMAP(R6),R1	; (BITMAP IS LAST STRUCTURE)
	JSB	G^IOC$ALLOSPT		; ALLOCATE SYS PAGE TABLE ENTRIES
	BLBS	R0,10$			; BRANCH IF SUCCESS
	MOVL	#SYSG$_SPTFULL,R0	; SET FAILURE STATUS
	RSB				; RETURN
10$:
	EXTZV	#VA$V_VPN,#VA$S_VPN,R6,R0 ; GET VPN OF DATAPAGE
	MOVAL	(R3)[R0],SHR_L_SHDPTE	; SAVE ADDR OF DATAPAGE PTE
	MOVL	(R3)[R0],R0		; GET PTE OF DATAPAGE (LAST PAGE)
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0 ; GET PFN OF DATAPAGE
20$:					; MAPPING LOOP
	DECL	R0			; DECREMENT PFN
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,- ; SET PTE VALID, KERNEL WRITEABLE
		R0,(R3)[R2]		;  AND ENTER PFN
	INCL	R2			; INCREMENT VPN
	SOBGTR	R1,20$			; DECREMENT PAGE COUNT AND LOOP

	ADDL3	SHD$L_GSBITMAP(R6),R6,-	; SET ADDR OF END OF POOL
		SHB$L_POOLEND(R5)	;  (BITMAP ASSUMED TO FOLLOW POOL)
	MOVL	#1,R0			; SET SUCCESS
	RSB				; RETURN

	.PAGE
	.SBTTL	INITIALIZE THE OTHER DATA STRUCTURES
;++
;
; INIT_STRUCTURES - INITIALIZE THE OTHER DATA STRUCTURES
;
; THIS ROUTINE IS CALLED TO INTIALIZE THE OTHER DATA STRUCTURES IN
; THE SHARED MEMORY.
;
; INPUTS:
;
;	R4 = ADDR OF NEXUS CSR
;	R5 = ADDR OF SHB
;	R6 = ADDR OF DATAPAGE (SHD)
;
; OUTPUTS:
;
;	THE OTHER SHARED MEMORY DATA STRUCTURES (POOL, MAILBOXES,
;	GLOBAL SECTION DESCRIPTORS, GLOBAL SECTION BITMAP) ARE
;	INITIALIZED FOR USE.
;--
INIT_STRUCTURES:			; INITIALIZE THE STRUCTURES
;
; INITIALIZE THE GLOBAL SECTION DESCRIPTOR TABLE
;
	ADDL3	SHD$L_GSDPTR(R6),R6,R7	; GET ADDR OF 1ST GSD
	MOVZWL	SHD$W_GSDMAX(R6),R8	; GET COUNT OF GSD'S
10$:					; INIT LOOP
	ASSUME GSD$L_GSDBL EQ <GSD$L_GSDFL + 4>
	CLRQ	GSD$L_GSDFL(R7)		; INIT FORWARD/BACKWARD LINKS
	MOVB	SHD$B_PORTS(R6),-	; SET # OF PORTS
		GSD$B_PROCCNT(R7)	;
	MOVZBW	#DYN$C_SHMGSD,-		; SET STRUCTURE TYPE AND
		GSD$B_TYPE(R7)		;   CLEAR UNUSED BYTE
	MOVW	SHR_L_GSDSIZE,-		; SET STRUCTURE SIZE
		GSD$W_SIZE(R7)		;
	CLRB	GSD$B_LOCK(R7)		; CLEAR LOCK
	CLRB	GSD$B_DELETPORT(R7)	; CLEAR ANY DELETES PENDING
	MOVZBL	GSD$B_PROCCNT(R7),R0	; GET # OF PROCESSOR REF CNTS
	MOVAL	GSD$L_PTECNT1(R7),R1	; GET ADR OF FIRST REF CNT
20$:	CLRL	(R1)+			; CLEAR ONE REF COUNT
	SOBGTR	R0,20$			; REPEAT FOR EACH PROCESSOR REF COUNT
	ADDL	SHR_L_GSDSIZE,R7	; INCREMENT GSD POINTER
	SOBGTR	R8,10$			; DECREMENT GSD COUNTER AND LOOP
;
; INITIALIZE THE GLOBAL SECTION BITMAP BY PERFORMING A GROSS READ/WRITE
; TEST ON EACH PAGE.  IF IT PASSES THE TEST, IT IS MARKED AVAILABLE
; IN THE BITMAP.  IF IT DOESN'T PASS THE  TEST, IT IS MARKED UNAVAILABLE.
;
; *** NOTE: TO MAP THE PAGES, THE DATAPAGE IS UNMAPPED ***
;
INIT_BITMAP:				; INITIALIZE THE BITMAP
	PUSHL	R4			; SAVE REGISTER
	ADDL3	SHD$L_GSBITMAP(R6),R6,R7 ; GET ADDR OF BITMAP
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS DESTROYED BY MOVC
	MOVC5	#0,(R6),#0,#512,(R7)	; ZERO-FILL THE BITMAP PAGE
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS CLOBBERED BY MOVC
	MOVL	SHR_L_SHDPTE,R8		; GET ADDR OF DATAPAGE PTE
	PUSHL	(R8)			; SAVE DATAPAGE PTE
	MOVL	SHD$L_GSPAGCNT(R6),R9	; GET NUMBER OF GLOBAL PAGES
	MOVL	SHB$L_BASGSPFN(R5),R10	; GET PFN OF 1ST GLOBAL PAGE
	CLRL	R11			; INIT CURRENT RELATIVE PAGE NUMBER
10$:
	INSV	R10,#PTE$V_PFN,#PTE$S_PFN,(R8) ; MAP THE PAGE TO TEST
	MOVL	R6,R3			; GET A COPY OF VIRTUAL ADDRESS OF PAGE
	ASHL	#VA$V_VPN,R10,R4	; COMPUTE PHYSICAL ADDRESS OF PAGE
	INVALID	R3			; INVALIDATE VIRTUAL ADDRESS TRANSLATION
	BSBW	IOGEN$TEST_MEM		; TEST THE PAGE
	BLBC	R0,20$			; BR IF BAD PAGE
	BBSS	R11,(R7),30$		; SET PAGE OK
	BRB	30$			;
20$:
	BBCC	R11,(R7),30$		; SET PAGE BAD
30$:
	INCL	R10			; INCREMENT PFN
	AOBLSS	R9,R11,10$		; INCREMENT CURRENT PAGE NUMBER AND LOOP
	POPL	(R8)			; RESTORE DATAPAGE PTE (REMAP)
	INVALID	R6			; INVALIDATE VIRTUAL ADDRESS TRANSLATION
	POPL	R4			; RESTORE REGISTER
	JSB	G^MA$INITIAL		; CLEAR ANY PORT ERRORS
;
; INITIALIZE THE POOL
;
INIT_POOL:				; INITIALIZE THE POOL
	ADDL3	SHD$Q_POOL(R6),R6,R0	; GET ADDR OF FIRST BLOCK
	CLRQ	SHD$Q_POOL(R6)		; SET QUEUE EMPTY
	MOVL	SHR_L_POOLBCNT,R1	; GET NUMBER OF BLOCKS
	MOVL	SHR_L_POOLBSIZ,R2	; GET BLOCK SIZE
10$:
	INSQHI	(R0),SHD$Q_POOL(R6)	; INSERT BLOCK IN LIST
	MOVW	R2,ACB$W_SIZE(R0)	; SET SIZE OF BLOCK IN BLOCK
	ADDL	R2,R0			; INCREMENT BLOCK POINTER
	SOBGTR	R1,10$			; DECREMENT BLOCK COUNT AND LOOP
;
; INTIALIZE THE FREE INTER-PROCESSOR REQUEST BLOCK QUEUE
;
INIT_PRQ:				; INITIALIZE FREE PRQ QUEUE
	ADDL3	SHD$Q_PRQ(R6),R6,R0	; GET ADDR OF FIRST BLOCK
	CLRQ	SHD$Q_PRQ(R6)		; SET QUEUE EMPTY
	MOVL	SHR_L_PRQCNT,R1		; GET NUMBER OF BLOCKS
10$:
	INSQTI	(R0),SHD$Q_PRQ(R6)	; INSERT BLOCK IN LIST
	ADDL	#PRQ$C_MINLENGTH,R0	; INCREMENT BLOCK POINTER
	SOBGTR	R1,10$			; DECREMENT BLOCK COUNT AND LOOP

;
; INITIALIZE THE MAILBOX TABLE
;
INIT_MAILBOXES:				; INITIALIZE THE MAILBOXES
	ADDL3	SHD$L_MBXPTR(R6),R6,R7	; GET ADDR OF 1ST MAILBOX
	MOVZWL	SHD$W_MBXMAX(R6),R8	; GET NUMBER TO INIT
	CLRL	R0			; INIT INITIALIZED COUNT
10$:
	CLRB	MBX$B_FLAGS(R7)		; CLEAR ALL FLAGS
	ADDW3	#1,R0,MBX$W_UNIT(R7)	; SET UNIT NUMBER
					; (FROM 1 TO N, AS 0 IS RESERVED)
	ADDL	#MBX$K_LENGTH,R7	; INCREMENT MAILBOX POINTER
	AOBLSS	R8,R0,10$		; INCREMENT COUNT AND LOOP

;
; INITIALIZE THE COMMON EVENT FLAG TABLE
;
INIT_CEF:
	ADDL3	SHD$L_CEFPTR(R6),R6,R7	; GET ADR OF 1ST SHMCEB IN TABLE
	MOVZWL	SHD$W_CEFMAX(R6),R8	; GET NUMBER OF ENTRIES TO INIT
10$:
	ASSUME CEB$L_CEBBL EQ <CEB$L_CEBFL+4>
	CLRQ	CEB$L_CEBFL(R7)		; INIT FLAGS
	MOVB	SHD$B_PORTS(R6),CEB$B_PROCCNT(R7) ; SET # OF PROCESSORS
	MOVZBW	#DYN$C_SHMCEB,CEB$B_TYPE(R7) ; SET TYPE OF DATA STRUCTURE
	MOVW	SHR_L_CEFSIZE,CEB$W_SIZE(R7) ; SET SIZE OF SHMCEB
	CLRB	CEB$B_LOCK(R7)		; CLEAR OWNER OF CEB LOCK
	CLRB	CEB$B_DELETPORT(R7)	; CLEAR DELETOR OF CEB
	MOVZBL	CEB$B_PROCCNT(R7),R0	; GET # OF PROCESSORS MAX
	MOVAL	CEB$L_VASLAVE1(R7)[R0],R1 ; GET ADR OF FIRST PROC REF COUNT
	MOVAL	CEB$L_VASLAVE1(R7),R2	; GET ADR OF FIRST SLAVE CEB VA
20$:	CLRL	(R2)+			; CLEAR THE VA OF SLAVE CEB FOR PROC
	CLRW	(R1)+			; CLEAR REF COUNT FOR THIS PROCESSOR
	SOBGTR	R0,20$			; REPEAT FOR EACH PROCESSOR
	ADDL	SHR_L_CEFSIZE,R7	; GET NEXT SHMCEB IN TABLE
	SOBGTR	R8,10$			; INIT EACH SHMCEB IN TABLE

	MOVL	#1,R0			; SET SUCCESS
	RSB

	.PAGE
	.SBTTL	CONNECT TO OTHER DATA STRUCTURES
;++
;
; CONNECT_MEM - CONNECT TO OTHER SHARED MEMORY DATA STRUCTURES
;
; THIS ROUTINE IS CALLED TO JUST CONNECT THIS PORT TO AN ALREADY
; INTIALIZED SHARED MEMORY.
;
; INPUTS:
;
;	R4 = ADDR OF NEXUS CSR
;	R5 = ADDR OF SHB
;	R6 = ADDR OF DATAPAGE (SHD)
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE STATUS.
;
;	THE DATAPAGE IS FIRST TESTED TO BE SURE THAT IT IS INITIALIZED.
;	IF IT HAS BEEN INITIALIZED, THEN THE EXISTING DATA STRUCTURES
;	(MAILBOXES, GLOBAL SECTION DESCRIPTORS) ARE SCANNED FOR
;	ONES THAT ARE MARKED FOR DELETE.  IF THE STRUCTURE HAD
;	REFERENCES ONLY FROM THIS PORT, THEN THE STRUCTURE IS DELETED.
;
;--
CONNECT_MEM:				; CONNECT DATA STRUCTURES
	BSBW	DATAPAGE_CRC		; COMPUTE DATAPAGE CRC
	CMPL	R0,SHD$L_CRC(R6)	; CRC COMPARE?
	BEQL	10$			; BRANCH IF YES
	MOVL	#SYSG$_BADCHKSUM,R0	; SET FAILURE
	RSB				; RETURN
10$:
	MOVZBL	SHD$T_NAME(R6),R0	; GET SIZE OF MEMORY NAME
	CMPC5	R0,SHD$T_NAME+1(R6),-	; IS NAME THE ONE SPECIFIED?
		#0,SHR_Q_MEMNAME,@SHR_Q_MEMNAME+4
	BEQLU	20$			; BRANCH IF YES
	MOVL	#SYSG$_INCMEMNAM,R0	; SET FAILURE
	RSB				; RETURN

20$:
	ADDL3	SHD$L_GSPFN(R6),-	; SET PFN OF 1ST GLOBAL PAGE
		SHR_L_MEMPFN,SHB$L_BASGSPFN(R5)
	MOVW	SHD$W_MBXMAX(R6),SHR_W_MBXCNT ; SAVE NUMBER OF MAILBOXES
	MOVZBL	SHB$B_PORT(R5),R0	; GET THIS PORT'S PORT NUMBER
	MOVW	SHR_W_GBLQUO,SHD$W_GSDQUOTA(R6)[R0] ; SET THIS PORT'S GSD QUOTA
	MOVW	SHR_W_MBXQUO,SHD$W_MBXQUOTA(R6)[R0] ; SET THIS PORT'S MBX QUOTA
	MOVW	SHR_W_CEFQUO,SHD$W_CEFQUOTA(R6)[R0] ; SET THIS PORT'S CEF QUOTA
;
; RE-INITIALIZE THE REFERENCE COUNTS FOR THIS PORT IN THE GSD TABLE.
; ALSO, IF THIS PORT CREATED ANY OF THE SECTIONS, SET THE CREATOR TO -1
; TO PROHIBIT USE OF NON-EXISTANT SECTION TABLE.  THIS DOES NOT ATTEMPT
; TO RELEASE ANY GLOBAL SECTIONS NOT IN USE BY OTHER PORTS OR GLOBAL SECTIONS
; WHICH WERE ONLY PARTIALLY CREATED BY THIS PORT.
;
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE REGISTERS
	ADDL3	SHD$L_GSDPTR(R6),R6,R0	; GET ADR OF FIRST GSD IN TABLE
	MOVZWL	SHD$W_GSDMAX(R6),R1	; GET COUNT OF GSD'S IN TABLE
	BLEQ	190$			; BR IF NO TABLE TO INIT
	MOVZBL	SHB$B_PORT(R5),R2	; GET PORT # FOR THIS PROCESSOR
	MOVZWL	GSD$W_SIZE(R0),R3	; GET SIZE OF ONE GSD IN BYTES
110$:	CLRL	GSD$L_PTECNT1(R0)[R2]	; INITIALIZE THE REF CNT FOR THIS PORT
	BBC	#GSD$V_VALID,GSD$L_GSDFL(R0),120$ ; BR IF SECTION NOT IN USE
	CMPB	R2,GSD$B_CREATPORT(R0)	; DID THIS PORT CREATE THE SECTION?
	BNEQ	120$			; BR IF IT IS NOT THE CREATOR
	MCOMB	#0,GSD$B_CREATPORT(R0)	; MAKE THIS NOT THE CREATOR
	CLRW	GSD$W_GSTX(R0)		; SET NO SECTION TABLE ENTRY
120$:	ADDL2	R3,R0			; GET ADR OF NEXT GSD
	SOBGTR	R1,110$			; REPEAT FOR EACH GSD IN TABLE
190$:	POPR	#^M<R0,R1,R2,R3>	; RESTORE REGISTERS

;
; RE-INITIALIZE THE REFERENCE FLAGS FOR THIS PORT IN THE MAILBOXES.
; THIS DOES NOT RELEASE ANY MAILBOXES THAT ARE NOT IN USE BY OTHER PORTS.
;
200$:
	ADDL3	SHD$L_MBXPTR(R6),R6,R0	; GET ADDR OF FIRST MAILBOX
	MOVZWL	SHD$W_MBXMAX(R6),R1	; GET COUNT OF MAILBOXES IN TABLE
	MOVZBL	SHB$B_PORT(R5),R2	; GET PORT # FOR THIS PROCESSOR
210$:
	BBCCI	R2,MBX$W_REF(R0),220$	; CLEAR PORT FLAG
220$:	ADDL	#MBX$K_LENGTH,R0	; INCREMENT MAILBOX POINTER
	SOBGTR	R1,210$			; DECREMENT COUNT AND LOOP
;
; RE-INITIALIZE THE REFERENCE COUNTS FOR THIS PORT IN THE CEF TABLE.
; THIS DOES NOT RELEASE ANY COMMON EVENT FLAG CLUSTERS THAT ARE NOT IN
; USE BY OTHER PORTS.
;
300$:	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	;SAVE REGISTERS
	ADDL3	SHD$L_CEFPTR(R6),R6,R0	; GET ADDR OF FIRST CEB IN TABLE
	MOVZWL	SHD$W_CEFMAX(R6),R1	; GET COUNT OF CEB'S IN TABLE
	BLEQ	390$			; BR IF NO CEF TABLE
	MOVZBL	SHB$B_PORT(R5),R2	; GET PORT # FOR THIS PROCESSOR
	MOVZWL	CEB$W_SIZE(R0),R3	; GET SIZE OF ONE CEB IN BYTES
	MOVZBL	CEB$B_PROCCNT(R0),R4	; GET # OF PROCESSOR PORTS ALLOWED
	ASHL	#2,R4,R4		; GET # OF BYTES OF SLAVE VA'S
310$:	CLRL	CEB$L_VASLAVE1(R0)[R2]	; INDICATE NO SLAVE ENTRY FOR THIS PORT
	ADDL3	R4,R0,R5		; COMPUTE ADR OF CEB PLUS SLAVEVA BYTES
	CLRW	CEB$L_VASLAVE1(R5)[R2]	; CLEAR REFERENCE COUNT FOR PORT
	ADDL2	R3,R0			; GET ADR OF NEXT CEB IN TABLE
	SOBGTR	R1,310$			; LOOP TO INIT NEXT CEB
390$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS

	MOVL	#1,R0			; SET SUCCESS
	RSB				; RETURN

	.PAGE
	.SBTTL	COMPUTE DATPAGE CRC
;++
;
; DATAPAGE_CRC - COMPUTE DATPAGE CONTSTANT FIELD'S CRC
;
; THIS ROUTINE IS CALLED TO COMPUTE THE CRC OF THE CONSTANT FIELDS
; IN THE SHARED MEMORY DATAPAGE.  THE CRC IS USED TO DETERMINE IF
; THE DATAPAGE IS INTACT.
;
; INPUTS:
;
;	R6 = ADDR OF DATAPAGE
;
; OUTPUTS:
;
;	R0 = CRC OF DATAPAGE CONTSTANT FIELDS
;--
DATAPAGE_CRC:				; COMPUTE CRC OF DATAPAGE
	ASSUME	SHD$L_MBXPTR EQ 0	; ASSUME MBX POINTER IS FIRST
	CRC	AUTODIN,#0,-		; COMPUTE CRC OF DATAPAGE
		#<SHD$L_CRC-SHD$L_MBXPTR>,SHD$L_MBXPTR(R6)
	RSB				; RETURN
	.PAGE
	.SBTTL	LOAD SHARED MEMORY MAILBOX DRIVER
;++
;
; LOADMBDRIVER - LOAD SHARED MEMORY MAILBOX DRIVER
;
; THIS ROUTINE IS CALLED TO LOAD THE MAILBOX DRIVER AND CONNECT A TEMPLATE
; MAILBOX UCB TO THE SHARED MEMORY.  THE TEMPLATE IS USED TO CREATE THE USER
; GENERATED MAILBOX UCB'S BY THE $CREMBX SYSTEM SERVICE.
;
; INPUTS:
;
;	SHR_L_ADP = ADDRESS OF ADAPTER CONTROL BLOCK
;
; OUTPUTS:
;
;	SHARED MEMORY MAILBOX DRIVER LOADED, DDB, UCB 0, IDB, AND CRB CREATED
;	AND CONNECTED TO I/O DATABASE.
;--
LOADMBDRIVER:				; LOAD MAILBOX DRIVER
	.WORD	^M<R2,R3,R4,R5,R6>	; 
	MOVAB	-ACF$K_LENGTH(SP),SP	; ALLOCATE CONFIG CONTROL BLOCK
	MOVL	SP,R6			; GET ADDRESS OF BLOCK
	MOVL	SHR_L_ADP,ACF$L_ADAPTER(R6) ; SET ADDRESS OF ADP
	CLRB	ACF$B_AUNIT(R6)		; SET UNIT #0
	CLRB	ACF$B_AFLAG(R6)		; SET NO FLAGS
	CLRL	ACF$L_CONTRLREG(R6)	; SET NO CONTROL REGISTER ADDR
	MOVW	#PRQ$C_MAILBOX*4,ACF$W_CVECTOR(R6) ; SET MAILBOX VECTOR NUMBER
	CLRB	ACF$B_CUNIT(R6)		; SET UNIT #0
	MOVB	#1,ACF$B_CNUMVEC(R6)	; SET ONE VECTOR
	MOVAB	SHR_T_MBDEVNAME,ACF$L_DEVNAME(R6) ; SET ADDRESS OF DEVICE NAME
	ADDB3	#^A/B/,SHR_W_UNIT,SHR_T_MBDEVNAME+3 ; COMPUTE "CONTROLLER" NAME
	MOVAB	SHR_T_MBDRVNAME,ACF$L_DRVNAME(R6) ; SET ADDRESS OF DRIVER NAME
	MOVW	SHR_W_MBXCNT,ACF$W_MAXUNITS(R6) ; SET MAXIMUM NUMBER UNITS
	CALLG	(R6),IOGEN$LOADER	; LOAD THE DRIVER AND CONNECT UCB0
	RET				; 

	.PAGE
	.SBTTL	SHOW THE DATA STRUCTURES
;++
;
; SHOW_STRUCT - SHOW THE DATA STRUCTURES
;
; CALLING SEQUENCE:
;
;	$CMEXEC_S SHOW_STRUCT
;
; INPUTS:
;
;	SHR_L_DATAPAGE = ADDRESS OF SHARED MEMORY DATAPAGE
;
; OUPUTS:
;
;	USEFUL INFORMATION ABOUT THE DATA STRUCTURES IS DISPLAYED
;	ON SYS$OUTPUT.
;--
SHOW_STRUCT:				; SHOW THE DATA STRUCTURES
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; ENTRY MASK
	MOVL	SHR_L_DATAPAGE,R6	; GET ADDR OF DATAPAGE
	PUT_OUTPUT <DATAPAGE:  !XL>,R6
	ADDL3	SHD$L_GSDPTR(R6),R6,R7	; GET ADDR OF GSD TABLE
	PUT_OUTPUT <GSD TABLE: !XL>,R7
	ADDL3	SHD$L_MBXPTR(R6),R6,R7	; GET ADDR OF MBX TABLE
	PUT_OUTPUT <MBX TABLE: !XL>,R7
	ADDL3	SHD$L_CEFPTR(R6),R6,R7	; GET ADDR OF CEF TABLE
	PUT_OUTPUT <CEF TABLE: !XL>,R7
	ADDL3	SHD$L_GSBITMAP(R6),R6,R7 ; GET ADDR OF BITMAP
	PUT_OUTPUT <BITMAP:    !XL>,R7
	ADDL3	SHD$Q_PRQ(R6),R6,R7	; GET ADDR OF PRQ LIST
	PUT_OUTPUT <PRQ LIST:  !XL>,R7

	RET				; RETURN

	.END
