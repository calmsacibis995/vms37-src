	.TITLE	SYSBOOT - VMS Secondary Bootstrap Routine
	.IDENT	'V03-009'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
;
; Facility:  System bootstrapping and initialization
;
; Abstract: 
;
;
; Environment:
;	Mode=Kernel ,  Memory Management OFF
;	IS=1 ,  IPL=31
;
; Author:  RICHARD I. HUSTVEDT, Creation date:  28-APR-1978
;
; Modification History:
;
;	V03-009	KDM0098		Kathleen D. Morse	12-Apr-1982
;		Since CONSOL.SYS;4 does not contain the fix needed
;		for the modification in V03-008, the temporary code
;		is being put back in.
;
;	V03-008	KDM0091		Kathleen D. Morse	5-Apr-1982
;		Remove temporary code, that was due to a bug in the
;		11/780 console.
;
;	V03-007	PHL0042		Peter H. Lipman		03-Apr-1982
;		Boot Control Block checksum is now delayed until INIT
;		It includes the entire fixed portion and all the maps
;		through the map for the dump/page file.  SYSBOOT leaves
;		the number of bytes to checksum in BOO$L_CHECKSUM for INIT
;
;	V03-006	KTA0092		Kerbey T. Altmann	02-Mar-1982
;		Do not do KTA0090 unless VMB version >= 8.
;
;	V03-005	KTA0091		Kerbey T. Altmann	31-Mar-1982
;		Add check to insure CI ucode not overwritten.
;
;	V03-004	RIH0096		Richard I. Hustvedt	30-Mar-1982
;		Fix initialization of PHD$B_PAGFIL in system process header.
;
;	V03-003	MLJ0084		Martin L. Jack		30-Mar-1982
;		Fix broken word displacement.
;
;	V03-002	KTA0090		Kerbey T. Altmann	26-Mar-1982
;		Update the microcode cell in bootvector with the virtual
;		address of where the ucode is in pool. Fix the TR 0
;		interrupt code (CAS0005).
;
;	V03-001	PHL0040		Peter H. Lipman		17-Mar-1982
;		If SYSDUMP.DMP is not found, use PAGEFILE.SYS instead.
;		Thus dumps can be placed at the front of the page file.
;
;	V02-058	RIH0084		Richard I. Hustvedt 	18-Jan-1981
;		Implement small request packet list.  Change required 
;		microcode version for Nebula.  Remove halt if version number
;		check fails.
; 
;	V02-057	RIH0083		Richard I. Hustvedt	1-Jan-1981
;		Implement automatic non-paged pool extension parameters.
;
;	V02-056	KTA0060		Kerbey T. Altmann	31-Dec-1981
;		Add check for TBCHK proc reg, set a bit in EXE$GL_DEFFLAGS
;		if so.  Fix the check for WCS version on 780's.
;
;	V02-055	JLV0129		Jake VanNoy		30-Dec-1981
;		Shuffle code to allow reading of parameters before opening
;		TTDRIVER. This is to allow changing parameter TTY_CLASSNAME.
;		Add SHOW/TTY to help text.
;
;	V02-054	LJK0095		Lawrence J. Kenah	9-Dec-1981
;		Boundary between nonpaged and pageable exec routines is now
;		in a global cell because the boundary can change if the size
;		of the nonpaged patch area increases. 
;
;	V02-053	LJK0091		Lawrence J. Kenah	20-Nov-1981
;		Make size of PFN data base depend on the amount of physical
;		memory present.
;
;	V02-052	TCM0008		Trudy C. Matthews	04-Nov-1981
;		Change minimum required microcode revision level to 48
;		(decimal) for the 11/730 processor.  Change minimum
;		required microcode revision level to 62 (decimal) for the
;		11/750 processor.
;
;	V02-051	KTA0036		Kerbey T. Altmann	07-Oct-1981
;		Add support for loadable ucode for boot devices and
;		loading of SCS code.
;
;	V02-050	TCM0007		Trudy C. Matthews	26-Aug-1981
;		Correct bug that caused systems booted from Release 1 VMB
;		to not initialize RPB$B_BOOTNDT field.
;
;	V02-049	KTA0032		Kerbey T. Altmann	26-Aug-1981
;		Correct problem with KTA0028.
;
;	V02-048	HRJ0028		Herb Jacobs		23-Aug-1981
;		Use new symbol definition for end of SYS.EXE due to move
;		of SHELL into paged exec.
;
;	V02-047	PHL0012		Peter H. Lipman		02-Aug-1981
;		Allow PFN BITMAP to be in high memory when it is very large.
;		Do  not  assume  that  the  "bottom"  of  SYSBOOT is the PFN
;		BITMAP.  If it was moved to high memory then the  bottom  is
;		actually the stack.
;
;		Formalize the VMB argument list.   Use  descriptor  for  PFN
;		BITMAP from the argument list if it is present.  Use the low
;		and high PFN values from VMB if present.

;		Rewrite the OVERLAY_VMB logic so that it will use  the  space
;		occupied  by VMB if sufficient, and it will use the space at
;		the end of SYSBOOT if not.
;
;		Use the SCB from VMB to avoid allocating another page
;		at the end of SYSBOOT.
;
;	V02-046	TCM0006		Trudy C. Matthews	30-Jul-1981
;		Change all "7ZZ"s to "730"s.
;
;	V02-045	KTA0028		Kerbey T. Altmann	30-Jul-1981
;		Fill in CPUDATA with information on the CPU: the
;		SID on all processors and the FPLA/PCS/WCS rev level
;		on the 11/780.
;
;	V02-044	JLV0027		Jake VanNoy		12-Jun-1981
;		Removed dummy labels for SYSGEN commands that aren't
;		in SYSBOOT. Moved them to SYSBOOCMD.
;
;	V02-043	PHL0010		Peter H. Lipman		15-May-1981
;		Assume VMB starts 1 page after the RPB rather than
;		at ^X200 of the current 64kb block of memory.
;
;		Use new $BOODEF macro to get Boot Control Block offsets
;
;		QIO_RWVB added too much resident code.  Add a map for
;		the non-resident BUGCHECK code and another for SYSPARAM
;		so that less code need be in the system at all.  A single
;		QI/O read logical in the resident bugcheck code can
;		bring in at least the first page, then it can
;		read the rest.  Likewise a very simple loop in reading
;		or writing SYSPARAM will work fine and is cheaper than
;		a general QIO_RWVB routine.
;
;		Remove code requiring contiguous SYS.EXE.
;
;	V02-042	HRJ0020		Herb Jacobs		10-May-1981
;		Fill in cells PHD$W_WSSIZE, PHD$W_WSEXTENT, PHD$W_WSAUTHEXT
;		for system PHD.
;
;	V02-041	TCM0005		Trudy C. Matthews	05-May-1981
;		Add code to fill in RPB$B_BOOTNDT field if the version
;		of VMB that we're booting from didn't already.
;
;	V02-040	PHL0009		Peter H. Lipman		28-Apr-1981
;		Start to allow SYS.EXE to be non-contiguous.
;
;		If the file name in the RPB does not have a top level
;		system directory in it, and the VMB is an old one, then
;		assume that TOPSYS is SYS0.  If SYS.EXE cannot be found,
;		then see if the boot can be completed with TOPSYS null.
;
;	V02-039	PHL0008		Peter H. Lipman		13-Apr-1981
;		Allow the following files to be non-contiguous
;			INILOA.EXE - loadable init code
;			SYSLOAxxx.EXE - loadable CPU-dependent code
;			TTDRIVER.EXE - terminal driver
;			xxDRIVER.EXE - system disk driver
;
;		Avoid rereading the 1st block (with the prologue) by
;		cacheing it in memory and moving it when it is time to
;		read the rest.
;
;		Fix error in CLRQ loop count in PFN data base clear loop.
;
;	V02-038	PHL0007		Peter H. Lipman		20-Mar-1981
;		Add FIL$OPENFILE cacheing and the general argument
;		list from VMB in AP.  Allocate IRP list, LRP list,
;		Allocate and move the boot driver.  Allocate and read
;		the system disk driver, TTDRIVER, SYSLOA7XX, INILOA.
;		Much of the above code was moved from INIT to SYSBOOT.
;
;	V02-037	KTA0011		Kerbey T. Altmann	10-Mar-1981
;		Change number of arguments to FIL$OPENFILE to agree
;		with new version.
;
;	V02-036 JLV0003		JAKE VANNOY		28-FEB-1981
;		ADDED MORE SYMBOLS FOR SYSGEN. (BOO$USER, BOO$RESET_SAVE,
;		BOO$SET_TR).
;
;	V02-035	JLV0002		Jake VanNoy		9-Feb-1981
;		Added BOO$... dummy entry points for CONFIGURE
;		and SHOW/CONFIGURATION.
;
;	V02-034	TCM0004		Trudy C. Matthews	28-Jan-1981
;		Add code to lookup INILOA.EXE, a new loadable initialization
;		module, and pass relevant information on to INIT.
;
;	V02-033	TCM0003		Trudy C. Matthews	19-Jan-1981
;		Add bootstrap parameter block that SYSBOOT can use to pass
;		data to INIT.  The data storage is defined by BOOPARAM.MAR,
;	 	and linked both with SYSBOOT and with INIT.  Add code to
;		SYSBOOT to move its copy of the bootstrap parameter block into
;		INIT's copy before transferring control to INIT.
;		Also, remove copy of CPUDISP macro (now defined in SYSMAR).
;
;	V02-032	CAS0005		C. A. Samuelson		30-Dec-1980
;		Add code to point SCB vector 0 and NEXUS vector 0
;		to separate routine in ERRORLOG for 11/780.  SCB vector
;		0 interrupts are cuased by a CVTP u-code bug.  NEXUS
;		vector 0 interrupts are caused by DW780 passive releases.
;
;	V02-031	RIH0003		Richard I. Hustvedt	3-Dec-1980
;		Change SGN$GW_MAXGPGCT to SGN$GL_MAXGPGCT.
;
;	V02-030	SPF0001		Stev Forgey		01-Oct-1980
;		Accept old parameter files that contain obsolete
;		parameters.  If the file is not a parameter file,
;		then issue only one error message.
;
;	V02-029 PHL0001		Peter H. Lipman		20-SEP-1980
;		Make the system default page file boot time rather than
;		assembly time initialized.
;
;	V02-028	WMC0001		Wayne Cardoza
;		Make the system service vectors non-paged.
;
;
;--

;
; Include files:
;
	$BOODEF				; Define Boot Control Block Offsets
	$BQODEF				; Define Boot qio offsets
	$BTDDEF				; Define Boot devices
	$DPTDEF				; Define Driver Prologue Definitions
	$DYNDEF				; Define dynamic pool codes
	$FH2DEF				; Define level 2 file header offsets
	$IHDDEF				; Define Image Header offsets
	$IO750DEF			; Define 11/750 I/O space
	$IODEF				; Define I/O function code values
	$IRPDEF				; Define I/O request packet offsets
	$NDTDEF				; Define nexus device type codes
	$PHDDEF				; Define process header offsets
	$PRDEF				; Define process register numbers
	$PTEDEF				; Define page table entry fields
	$RPBDEF				; Define restart parameter block offsets
	$SECDEF				; Define process section block
	$TPADEF				; Define TPARSE offsets
	$VADEF				; Define fields in virtual address
	$VMBARGDEF			; Define VMB argument list offsets
	$WCBDEF				; Define Window Control Block offsets
	$WSLDEF				; Define Working Set lis entry
					;***
DEBUG=1					;***
					;***

;
; Macros:
;
	.MACRO	ERROR,STR		; 
	BSBW	ERROUT			; Output error string
	.ASCIZ	STR			;
	.ENDM	ERROR			;

	.MACRO	MSG,STR			;
	BSBW	BOO$FACMSG		; Output message
	.ASCIZ	\'STR'\			;
	.ENDM	MSG			;

;
;	Macro to output prompt string and read response into BOO$GT_COMBUF
;
	.MACRO	PROMPT,STR		;
	BSBW	PROMPT			;
	.ASCIZ	STR			;
	.ENDM	PROMPT			;

;
; Equated Symbols:
;
;
	IOSIZE = 127			; Do I/O in very large chunks
	MAXPGS = 16384			; Allow for 8Mb of memory
	DEBUG  = 1			; Assemble DEBUG code
	CR     = 13			; Character code for carriage return
	LF     = 10			; Character code for line feed

	RP_DT  = 24			; Offset to drive type register for massbus
	RTRV_PAG_CNT = 3		; Retrieval pointer page count
					; 1 for SYS.EXE
					; 1 for SYSDUMP.DMP
					; 1 for the other small files

	FPLA_VLOC = ^O155		; Offset to FPLA version number location
	FPLA = ^X0C			; FPLA version number
	PCS_VLOC  = ^O152		; Offset to PCS version number location
	PCS = ^X01			; PCS version number
	WCSP_VLOC = ^O153		; Offset to WCS primary version location
	WCSP = ^X0C			; WCS primary version number
	WCSS_VLOC = ^O154		; Offset to WCS secondary version location
	WCSS = ^X12			; WCS secondary version

	HWREV_750=0			; Minimum req'd hardware ECO level
	MICREV_750=62			; Minimum req'd microcode rev level

	HWREV_730=0			; Minimum req'd hardware ECO level
	MICREV_730=51			; Minimum req'd microcode rev level


;
; Offsets into Statistics Blocks kept for each file that is looked up
;
	$OFFSET	0,POSITIVE,<-
	STAT_L_VBN,-			; Starting VBN (after header)
	STAT_L_BYTECNT,-		; Size in bytes of image
	STAT_L_SYSVA,-			; Base relative adr of pool adr
	STAT_L_NAME,-			; Base relative adr of ASCIC file name
	STAT_L_MAP,-			; Address of virtual to logical map
	STAT_L_VBN2ADR,-		; Buf Adr containing VBN 2
	<STAT_C_SIZE,0> -		; Size of STAT block
	>
;
; Own Storage:
;
	.PSECT	__Z99BOOT,PAGE
BOOTHIGH:				;
	.PSECT	$$$$00BOOT,LONG		;
	.PAGE
	.SBTTL	Secondary Bootstrap Main Routine
;++
;
; Functional Description:
;
; Calling Sequence:
;	JMP	EXE$SYSBOOT
;
; Input Parameters:
;	R10 - Base address of secondary bootstrap
;	R11 - Pointer to Restart Parameter Block
;	AP  - Argument list from VMB (Version 5 or later)
;	SP  - Stack pointer
;	PR$_SCBB - System Control Block Base (SCB)
;
;	Memory layout at start of secondary bootstrap:
;
;	+-----------------------------------------+ :BASE
;	!					  !
;	!	Restart Parameter Block (RPB)	  !
;	!					  !
;	+-----------------------------------------+ :BASE+^X200
;	!					  !
;	!	  Primary Bootstrap Code	  !
;	!	(up to the end of drivers only)	  !
;	!					  !
;	+-----------------------------------------+ :PR$_SCBB
;	!					  !
;	!	   System Control Block		  !
;	!					  !
;	+-----------------------------------------+ :PFNMAP
;	!					  !
;	!	    Small PFN Bitmap		  !
;	!					  !
;	+-----------------------------------------+ :PFNMAP+X (X=^X200/400/600
;	!					  !	or 800 as determ by VMB)
;	!	     Bootstrap Stack		  !
;	!		(3 pages)		  !
;	+-----------------------------------------+ :(SP)
;	!					  !
;	!	 Secondary Bootstrap Code	  !
;	!					  !
;	+-----------------------------------------+
;
;	The PFN bitmap passed in by VMB describes all the memory that
; has been tested and proven usable.  Some of that memory is actively in
; use and must not be allocated and overwritten by this SYSBOOT code.
; For example the portion of memory in which this code is currently
; running has not been marked as "in use."  Allocation of memory
; is done from high PFN to low.  It is expected that we will not get
; to the pages we are running in, and thus having them appear usable
; means that they don't have to be set usable before transferring 
; control to INIT.
;	There are 3 other regions of memory that have the same attribute.
; The first is the FIL$OPENFILE cache.  If memory allocation overlaps
; this cache, it will automatically be disabled.  The second region
; is the combination CI microcode and page table.  If memory allocation
; overlaps this area, a fatal error halt is taken, as the infomation
; contained therein is essential to system operation. The third region
; is the large PFN bitmap.  This region is only created for memories
; in excess of 8mb, and it is positioned at 2mb.  It is assumed that
; none of the allocation logic will get down to this point for such
; a large memory, and thus this is not a problem.
;	There are 3 points at which SYSBOOT is interested in regions
; which are in use, but marked allocatable.  The first point
; is when SYSBOOT artificially limits the size of memory to the
; physical page count SYSGEN parameter (near label HAVEPRM).
;	The second place is when SYSBOOT is trying to allocate a
; contiguous run of pages for the SPT (near label ALLOCSPT).
;	The final place is in the routine ALLOCPFN which allocates
; a PFN.
;
; Output Parameters:
;
;--

EXE$SYSBOOT::				; Secondary bootstrap start address
	MOVL	R11,W^BOO$GL_RPBBASE	; Save base of RPB
;
; Get pointer to SCB used by primary bootstrap and fill with pointers to
; exception handlers for secondary bootstrap.
;
	MFPR	#PR$_SCBB,R8		; Address of VMB's SCB
	MOVAL	^X200(R8),R8		; Fill SCB back to front
	MOVAL	W^BOOT_FAULT+1,R6	; Unexpected fault handler vector
10$:	MOVL	R6,-(R8)		; Store a vector
	BITW	#^X1FF,R8		; Check for page boundary
	BNEQ	10$			; Need another vector
	MOVAB	W^UNEXP_MCHK,4(R8)	; Machine checks are not expected
;
; If debug code is included, connect debugger to BPT and TBIT exception
; vectors, then execute a BPT instruction to give control to the debugger.
;
	.IF	DF,DEBUG		;
	MOVAB	W^XDELBPT,^X2C(R8)	; Set BPT exception vector to debugger
	MOVAB	W^XDELTBIT,^X28(R8)	;  and TBIT vector also
	MOVAB	B^INI$BRK,W^XDELIBRK	; Make correct break address in brk table
	BBC	#RPB$V_BOOBPT,RPB$L_BOOTR5(R11),NOBRK	; Check for bootstrap BPT
INI$BRK::				;
	BPT				; Breakpoint initially, changed to NOP
NOBRK:					; No bootstrap break point
	.ENDC				;

	MOVAL	L^BOOTHIGH,W^BOO$GL_FREEMEM ; Save pointer to free memory
	MOVL	R10,W^SYSBOOT_BASE	; Save base address of this code
	ASHL	#3,RPB$Q_PFNMAP(R11),W^MEM_HI_PFN ; Record highest PFN
					; if VMB didn't pass it in.
	MOVQ	RPB$Q_PFNMAP(R11),W^SMALL_PFNMAP ; Save descriptor for backward
					; compatible (max 8mb) PFN bitmap
;
; Save VMB version number so that various code paths can check it
; A zero in VMB_VERSION means that we were started by the release 1 VMB
;
	MOVL	RPB$L_IOVEC(R11),R0	; Address of I/O vectors
	XORW3	BQO$W_VERSION(R0),-
		BQO$W_VERCHECK(R0),R1	; If we have a version #, the
	INCW	R1			; version and its complement are there
	BNEQ	BOOTNDT_TST		; Branch if release 1 VMB
	MOVZWL	BQO$W_VERSION(R0),-
		W^VMB_VERSION		; Save the VMB version number
;
; Determine if VMB has already set up RPB$B_BOOTNDT field.
;
BOOTNDT_TST:
	CMPL	W^VMB_VERSION,#6	; Did VMB set up the BOOTNDT field?
	BGEQ	END_BOOTNDT_TST		; Version 6 or later -- yes.
	MOVL	RPB$L_BOOTR1(R11),R1	; Get index to boot adapter.
	MOVB	RPB$B_CONFREG(R11)[R1],-; Get boot adapter's nexus device
		RPB$B_BOOTNDT(R11)	; type from RPB$B_CONFREG array.
END_BOOTNDT_TST:
;
; Determine if VMB has passed in an argument list in AP
;
	CMPL	W^VMB_VERSION,#5	; Is there an argument list in AP?
	BLSS	ADD_CACHE		; Branch if not
;
; The argument count field of the argument list describes what
; is present in the argument list.
;
	MOVQ	VMB$Q_FILECACHE(AP),- 	; No additional test
		W^FIL$GQ_CACHE		;  is needed for file cache
	CMPW	#VMB$Q_PFNMAP/4,(AP)	; Are the PFNMAP, LO and HI
					; PFN arguments present?
	BGTR	5$			; Branch if not
	MOVQ	VMB$Q_PFNMAP(AP),-	; Yes, update RPB
		RPB$Q_PFNMAP(R11)	;  descriptor for PFN bitmap
	ASSUME	VMB$L_HI_PFN EQ VMB$L_LO_PFN+4
	MOVQ	VMB$L_LO_PFN(AP),-
		W^MEM_LO_PFN		; Record the low and hi PFN's
	CMPW	#VMB$L_FLAGS/4,(AP)	; Are the UCODE thru FLAGS args present?
	BGTR	5$			; Branch if not
	MOVQ	VMB$Q_UCODE(AP),-	; Yes, move the descriptor
		W^UCODE_LEN
	MOVL	VMB$B_SYSTEMID(AP),-	;  and the system id
		W^BOO$GB_SYSTEMID
	MOVW	VMB$B_SYSTEMID+4(AP),-
		W^BOO$GB_SYSTEMID+4
	MOVL	VMB$L_FLAGS(AP),-
		W^VMB_FLAGS 		;  and the flags
	CMPB	#VMB$L_CI_HIPFN/4,(AP)	; Is the CI_HIPFN arg present?
	BGTR	5$			; Branch if not
	MOVL	VMB$L_CI_HIPFN(AP),-
		W^CI_HI_PFN		; Yes, copy it
5$:
;
; Get the top level system directory name (if present) out of the name
; of the secondary bootstrap stored by VMB in the RPB.
;
	MOVAB	RPB$T_FILE(R11),R7	; Address of bootstrap name
	MOVZBL	(R7)+,R6		; R6 = size, R7 = adr of string
	LOCC	#^A/]/,R6,(R7)		; Find the directory portion
	BNEQ	10$			; of the name string
	LOCC	#^A/>/,R6,(R7)		; Alternate syntax?
	BEQL	END_LOOKUP		; Branch if no directory present
10$:	INCL	R7			; Step over the open bracket
	SUBL	R7,R1			; Count in directory string
	LOCC	#^A/./,R1,(R7)		; Any top level directory?
	BEQL	END_LOOKUP		; Branch if not
	SUBL	R7,R1			; Size of top level dir name
	CMPL	R1,#9			; Size of name ok?
	BGTR	END_LOOKUP		; Branch if not
	MOVAB	W^FIL$GT_TOPSYS,R3	; Location to store ASCIC string
	MOVB	R1,(R3)+		; Store string size
	MOVC3	R1,(R7),(R3)		; And store the directory name
	BRB	END_LOOKUP
;
; VMB version does not have the FIL$OPENFILE cache
;
ADD_CACHE:
	BSBW	BOO$CACHE_INIT		; Otherwise init our own cache
END_LOOKUP:
	MOVQ	RPB$Q_PFNMAP(R11),R0	; Get descriptor for PFN bitmap
	CMPL	R1,SP			; Is this the small bitmap?
	BLSS	10$			; Branch if yes
	MOVAB	-(R1)[R0],R0		; Address of last byte inclusive
	ASHL	#-9,R0,W^PFNMAP_HI_PFN	; Save highest PFN
10$:
;
; With the latest version of VMB, essentially all the code is already
; gone.  This secondary bootstrap was read in over nearly all the VMB
; code.  So the following code, which used to lay some data over VMB's
; code, now simply places it at the end of SYSBOOT.  Even with old
; versions of VMB this still works since the sum of the 2 bootstraps
; and their data still does not exceed 64kb.
;
OVERLAY_VMB:
	ASSUME	BOO$C_LENGTH&3 EQ 0	; Integral number of long words
	ROTL	#9,#RTRV_PAG_CNT+<<BOO$C_LENGTH-64+511>@-9>,R2
					; If front of Boot Control Block is
					; larger than 64 bytes add a page
	MOVL	W^BOO$GL_FREEMEM,R3	; Place BOOTCB and retrieval pointers
					; at the end of SYSBOOT
	ADDL3	R2,R3,R6		; Note where next free page is
	MOVL	R3,W^BOOTCB		; Address of boot control block
	MOVAL	BOO$C_LENGTH(R3),R3	; First address in rtrv buffer
	MOVAB	-BOO$C_LENGTH(R2),R2	; Size of rtrv buffer
	MOVQ	R2,W^RTRV_BUF_DSC	; Set retrieval buffer descriptor
;
; Allocate space to keep the first block beyond the image header for
; each of the drivers and loadable code.  They must be read in to find
; the size of the driver.  This avoids reading them a second time.
;
	ROTL	#9,S^#<LOAD_IMAGE_CNT+1>,R5 ; No. of bytes needed
	MOVQ	R5,W^VBN2_BUF_DSC	; Save descriptor of buffer space
	ADDL3	R5,R6,W^BOO$GL_FREEMEM	; Note where next free page is

;****************************************************************************
;*	DEALLOCATE ANY PAGES SPECIFIED BY BAD PAGE FILE
;*
;****************************************************************************

;
; Get CPU type and check if valid.
;

CHK_CPU_TYPE:				; Get and check CPU type
	MFPR	#PR$_SID,R0		; Read SID
	ASHL	#-PR$V_SID_TYPE,R0,R0	; Right justify type
	BEQL	10$			; Branch if type=0 (illegal)
	CMPB	R0,#PR$_SID_TYPMAX	; Type exceeds maximum?
	BLEQU	20$			; Branch if not (legal)
;***
;***The following 4 instructions are present to allow
;***11/780's with uninitialized sid's to run.
;***
	CMPB	R0,#-1			; CPU type=-1?
	BNEQ	10$			; branch if not
	MNEGB	R0,R0			; if so, set CPU type to 11/780
	BRB	20$			;  and continue
;***
10$:	MSG	<-F-Unknown processor>
	HALT				; *****Fatal Error*****
20$:	MOVB	R0,W^EXE$GB_CPUTYPE	; Save CPU TYPE in SYSPARAM
	MOVB	R0,W^CPUTYPE		; Save it in a safe place too

CHKVERSION:				; Check for minimum FPLA/WCS/PCS version
					;
	CPUDISP	<CHKVERS_780,-		; *Dispatch on CPU type*
		CHKVERS_750,-		; 
		CHKVERS_730>

CHKVERS_750:				; For 11/750, check SID
	MOVZBL	#HWREV_750, R2		; R2 <- hardware ECO level
	MOVZBL	#MICREV_750, R3		; R3 <- microcode version
	BRB	CHECK_SID

CHKVERS_730:				; For 11/730, check SID
	MOVZBL	#HWREV_730,R2		; R2 <- hardware ECO level
	MOVZBL	#MICREV_730,R3		; R3 <- microcode version
CHECK_SID:
	MFPR	#PR$_SID,R1		; Get SID
	CMPB	R1, R2			; Current ECO level high enough?
	BLSSU	10$			; Branch if not
	ASHL	#-8,R1,R1		; Position microcode version
	CMPB	R1, R3			; Current microcode version high enough?
	BLSSU	10$			; Branch if not
	BRW	CHKVERS_END		; Else versions ok
10$:	MSG	<-W-ECO or microcode version less than minimum required for VMS.>
	BRB	BOO_HALT1		; Allow continue command to override
					;
CHKVERS_780:				; For 11/780, continue with check
	MOVAB	W^VERSVECT,R5		; Get address of version vector
	MOVAB	W^CPUDATA,R6		; Pointer to extra data
10$:	MOVZBL	(R5)+,R1		; Get offset to version code
	BEQL	30$			; Zero if end of list
20$:	BSBW	GETCONLOC		; Ask console for value
	MOVB	R0,(R6)+		; Store it away
	BRB	10$			; Loop

30$:	MOVAB	W^VERSNUM+4,R5		; Set to end of required values
	CMPW	-(R6),-(R5)		; Check WCS version against required value
	BLSSU	40$			; Continue for all versions
	CMPB	-(R6),-(R5)		; Check PCS
	BLSSU	40$
	CMPB	-(R6),-(R5)		; Check FPLA
	BGEQU	CHKVERS_END		; All okay
40$:	MSG	<-W-FPLA,PCS or WCS version less than minimum required for VMS.>
BOO_HALT1:				;
;
;		Halt removed to leave warning message only.
;
CHKVERS_END:				; *End of CPU-dependent code*
					;
GETCURRENT:				; Read current parameter values
	MOVAB	W^SYS_STAT,R2		; Address of SYSTEM statistics block
5$:	BSBW	IMAGE_OPEN		; Locate SYS.EXE
	BLBS	R0,15$			; Branch if successful
;
; If we were looking for SYS.EXE in SYS0.DIR, then try to boot from
; SYSEXE.DIR in the MFD for compatibility with Release 2 format system disks
;
	TSTB	W^FIL$GT_TOPSYS		; Try this second lookup once only
	BEQL	10$			; Branch if no TOPSYS in use
	CLRB	W^FIL$GT_TOPSYS		; Disable TOPSYS
	CMPB	#^A/0/,W^FIL$GT_TOPSYS+4 ; Trying to boot from [SYS0.SYSEXE]?
	BEQL	5$			; Yes, try again from [SYSEXE]
10$:	MSG	<-F-Unable to locate SYS.EXE>
	HALT				; ***** Fatal Error *****
15$:	MOVL	#1,R3			; Virtual block 1 is image header
	MOVL	W^SYS_STAT+STAT_L_MAP,R4 ; Virtual to logical block map
	MOVL	W^BOO$GL_FREEMEM,R6	; Set buffer address
	ROTL	#9,#1,R9		; Read only header
	BSBW	READ_VIRTUAL		; Read image header
	BLBS	R0,50$			; Branch if successful
	BRW	READ_SYS_ERR		; Error reading SYS.EXE - fatal
50$:	MOVL	R6,R3			; Set base address
	ROTL	#<32-9>,W^SYS_STAT+STAT_L_BYTECNT,R2 ; No. of pages in file
	BSBW	BOO$IMAGE_ATT		; Get image attributes
;
; R1 = count of image header blocks
; R2 = last VBN in image - excluding symbol table and patch text
; R4 = preserved = virtual to logical map
;
	ADDL3	#1,R1,R3		; Starting VBN of image beyond hdr
	MOVL	R3,W^SYS_STAT+STAT_L_VBN ; Save in stat block
	SUBL	R1,R2			; Blocks in image excluding image header
					; symbol table, and patch text
	ASHL	#9,R2,W^SYS_STAT+STAT_L_BYTECNT ; Save byte count of image file
	MOVL	W^BOOTCB,R10		; Address of boot control block
	SUBL3	R10,R4,BOO$L_SYS_MAP(R10) ; Save virtual to logical map
	MOVL	R3,BOO$L_SYS_VBN(R10)	; Save starting VBN of SYS
	MOVL	R2,BOO$L_SYS_SIZE(R10)	; and its size from that VBN
					; to the end of executable image
;
; Add enough space to map for SYS.EXE to convert it into a Window
; Control Block in INIT.
;
	MOVQ	W^RTRV_BUF_DSC,R6	; R6 = size, R7 = address of
					; retrieval buffer
	ASHL	#-3,(R4),R0		; Number of retrieval pointers
	MULL	#6,R0			; 6 bytes each for WCB
;
; Note that SYS.EXE is smaller than 65K blocks and thus each retrieval
; pointer must be less than 65K blocks.  So 1 retrieval pointer cannot
; result in more than one window control block pointer.
;
	ADDL	#WCB$W_P1_COUNT,R0	; Size required for WCB
	ADDL3	#4,(R4),R1		; Size taken up by map right now
	SUBL	R1,R0			; Additional bytes needed to
					; convert into a Window Control Block
	BLEQ	60$			; Branch if already big enough
	ADDL	#3,R0			; Round up to long word boundary
	BICL	#3,R0			;
	SUBL	R0,R6			; Reserve the additional space
	ADDL	R0,R7			;
60$:
;
; Make separate virtual to logical maps for SYSPARAM and for the
; non-resident portion of BUGCHECK.  This reduces the amount of
; code needed in the system to deal with these portions of SYS.EXE
; that are no longer required to be contiguous.
;
	ADDL	#<MMG$A_SYSPARAM-^X80000000>@-9,R3 ; VBN of SYSPARAM
	MOVL	S^#<<BOO$C_SYSPARSZ+511>@-9>,R5 ; Number of blocks in SYSPARAM
	SUBL3	R10,R7,BOO$L_PARAM_MAP(R10) ; Offset to map for SYSPARAM
	BSBW	BOO$SETMAP		; Set virtual to logical map for
					; SYSPARAM portion of SYS.EXE
	MOVL	W^SYS_STAT+STAT_L_MAP,R4 ; Get map for SYS again
	MOVZWL	#<BUG$A_PAGED-^X80000000>@-9,R3 ; Starting VBN of paged
	ADDL	W^SYS_STAT+STAT_L_VBN,R3 ; BUGCHECK code
	MOVL	S^#<BUG$A_PAGEDEND-BUG$A_PAGED+511>@-9,R5
					; Blocks of paged BUGCHECK code
	SUBL3	R10,R7,BOO$L_BUG_MAP(R10) ; Offset to map for BUGCHECK code
	BSBW	BOO$SETMAP		; Set virtual to logical map for
					; BUGCHECK portion of SYS.EXE
	MOVQ	R6,W^RTRV_BUF_DSC	; Record space used in rtrv ptr buf
;
; Now read in SYSPARAM
;
	MOVAB	W^EXE$A_SYSPARAM,R6	; Set buffer address
	MOVL	#1,R3			; VBN 1 relative to SYSPARAM map
	ADDL3	R10,BOO$L_PARAM_MAP(R10),R4 ; Map for SYSPARAM
	MOVL	#<<BOO$C_SYSPARSZ+511>&^C511>,R9 ; Size of SYSPARAM in bytes
	BSBW	READ_VIRTUAL		; Read current parameters
	MOVB	W^CPUTYPE,W^EXE$GB_CPUTYPE ; Restore CPU type to sys params
	BLBS	R0,LOOKUPSYSDUMP	; Branch if ok
	BRW	READ_SYS_ERR		; Error reading SYS.EXE - fatal
;
; Now open SYSDUMP.DMP and record its retrieval pointers in the
; boot control block.
;
LOOKUPSYSDUMP:
	MOVL	#1,BOO$L_DMP_VBN(R10)	; Set dump file starting VBN

	ASSUME	BOO$L_DMP_MAP EQ BOO$L_DMP_SIZE+4
	CLRQ	BOO$L_DMP_SIZE(R10)	; Zero size and map in case no dump file
	MOVAB	W^SYSDUMP_STAT,R2	; Adr of SYSDUMP stat block
	CLRL	W^EXE$GW_PGFL_FID	; No file id for page file
	CLRW	W^EXE$GW_PGFL_FID+4	;
	BBCC	S^#EXE$V_PAGFILDMP,W^EXE$GL_DEFFLAGS,10$ ; Assume dump is
					; not going to be in the page file
10$:	MOVAL	@#BOO$GT_SYSDUMP,STAT_L_NAME(R2) ; Look up SYSDUMP.DMP
	BSBW	IMAGE_OPEN		; Locate SYSDUMP.DMP
	BLBS	R0,20$			; Branch if found
	MOVAB	@#BOO$GT_PAGEFILE,STAT_L_NAME(R2) ; Didn't find SYSDUMP.DMP
	BSBW	IMAGE_OPEN		; Lookup PAGEFILE.SYS instead
	BLBC	R0,60$			; Branch if this failed too
	MOVL	FH2$W_FID_NUM(R1),W^EXE$GW_PGFL_FID ; Save the file id
	MOVW	FH2$W_FID_RVN(R1),W^EXE$GW_PGFL_FID+4 ; for the page file
	BBSS	S^#EXE$V_PAGFILDMP,W^EXE$GL_DEFFLAGS,20$ ; Note dump file
					; is at the front of the page file
20$:	ROTL	#<32-9>,STAT_L_BYTECNT(R2),- ; Record size of file
		BOO$L_DMP_SIZE(R10)	; in blocks
	SUBL3	R10,STAT_L_MAP(R2),BOO$L_DMP_MAP(R10) ; Offset to SYSDUMP map

;
; Now calculate the size of nonpaged pool needed for the bootstrap
; system disk driver.  This includes the BOOTCB (boot control block)
; and any possible ucode file needed.
;
60$:	MOVQ	W^RTRV_BUF_DSC,R6	; Get size and adr of what remains
					; of the retrieval pointer buffer
					; R7 = end of BOOTCB
	SUBL3	R10,R7,R0		; BOOTCB size
	MOVW	R0,BOO$W_SIZE(R10)	; Save size in BOOTCB
	MOVZWL	R0,BOO$L_CHECKSUM(R10)	; Save size to checksum for INIT
	MOVW	#<DYN$C_BOOTCB@8!DYN$C_INIT>,-
		BOO$B_TYPE(R10)		; Set type and subtype
	ADDL2	W^UCODE_LEN,R0		; Add in any possible ucode file size
	ADDL3	RPB$L_IOVECSZ(R11),R0,-	; Save size with Boot Driver added
		W^BOODRV_STAT+STAT_L_BYTECNT
					; in Boot Driver statistics block
	CLRQ	(R7)+			; Since allocation will be rounded
	CLRQ	(R7)+			; up to 16 byte boundary, clean out
					; any left over garbage
	SUBL	#16,R6			; and allocate an additional 16 bytes
	MOVQ	R6,W^RTRV_BUF_DSC	; of retrieval buffer space
;
; The boot device driver file will be opened and read to obtain
; the driver size.  This will be passed to the EXEC initialization.
; Determining the name of the boot driver file is done differently,
; depending on the version of VMB being used.
;
LOOKUPDRIVER:
	TSTL	W^VMB_VERSION		; Release 2 or later VMB?
	BEQL	2$			; Branch if not
	MOVL	RPB$L_IOVEC(R11),R0	; Get address of I/O vectors
	MOVAB	@BQO$L_DRIVRNAME(R0)[R0],R4 ; Yes, get addr. of driver name list
	BRB	20$

;
; The type of boot device will be determined and the proper driver file 
; will be looked up and read to obtain the proper driver size. This will
; be passed to the exec initialization.  If the type of boot
; device does not correspond to one of the standard disk devices, then
; the driver name will be set to UNKDRIVER.EXE and a fatal error message
; given if the driver file is not found.
;
2$:
	MOVL	RPB$L_ADPPHY(R11),R5	; Get physical address of bus adapter
	CMPB	RPB$B_DEVTYP(R11),-	; Booting from console block
		#BTD$K_CONSOLE		; storage device?
	BNEQ	5$			; No
	MOVAB	W^DDNAME,R4		; Yes, assume TU58
	CPUDISP	<4$,-			; 11/780 floppy
		20$,-			; 11/750 TU58
		20$,-			; 11/730 TU58
		>
4$:	MOVAB	W^DXNAME,R4		; Console RX01 driver name
	BRB	20$

5$:	CASE	RPB$B_DEVTYP(R11),<-	; Case on boot device type
		10$,-			; MASSBUS device
		9$,-			; RK06/7
		8$,-			; RL02
		>,LIMIT=#BTD$K_MB,TYPE=B
	BRB	12$			; Unknown device

8$:	MOVAB	W^DLNAME,R4		; RL02 driver name
	BRB	20$
9$:	MOVAB	W^DMNAME,R4		; RK06/7 driver name
	BRB	20$			;
10$:	MOVAB	^X400(R5),R5		; Compute address of device registers
	INSV	RPB$W_UNIT(R11),#7,#3,R5; For boot device
	MOVL	RP_DT(R5),R0		; Read device type number
	MOVAB	W^DBNAME,R4		; Assume RP04/RP05/RP06 (DBDRIVER)
	CMPB	R0,#^X12		; Is drive type = RP04/5/6
	BLEQ	20$			; Branch if yes
	CMPB	#^X14,R0		; Is device RM03?
	BEQL	15$			; Yes
	CMPB	#^X16,R0		; IS DEVICE = RM80?
	BEQL	15$			; IF EQL, YES
	CMPB	#^X17,R0		; IS DEVICE = RM05?
	BEQL	15$			; IF EQL, YES
	CMPB	#^X22,R0		; IS DEVICE = RP07?
	BEQL	15$			; Yes
12$:	MOVAB	W^UNKNAME,R4		; Use driver for unknown devices
	BRB	20$			;
15$:	MOVAB	W^DRNAME,R4		; Use DRDRIVER for RM03/RP07
20$:	CMPL	W^VMB_VERSION,#3	; Did this VMB set up the MEMDSC in RPB?
	BGEQ	25$			; Branch if it did
	BSBW	ADD_RPB_MEMDSC		; PUT MEMDSC IN RPB
25$:	SUBL3	W^SYSBOOT_BASE,R4,-	; Save base relative address
		W^DSKDRV_STAT+STAT_L_NAME ;  of driver name
	CMPL	W^VMB_VERSION,#7	; Version 7 or greater?
	BLSS	30$			; No, leave now
	MOVL	RPB$L_IOVEC(R11),R0	; Get address of I/O vectors
	MOVL	BQO$L_AUXDRNAME(R0),R4	; Get addr. of aux driver name list
	BEQL	30$			; None, leave
	ADDL2	R0,R4			; Get absolute address
	SUBL3	W^SYSBOOT_BASE,R4,-	; Save base relative address
		W^PRTDRV_STAT+STAT_L_NAME ;  of driver name
30$:
;
; Derive the name of the image containing  loadabe CPU-dependent
; code.  Image names supported thus far:
;
;	SYSLOA780.EXE	if CPU_TYPE has PR$_SID_TYP780.
;	SYSLOA750.EXE	if CPU_TYPE has PR$_SID_TYP750.
;	SYSLOA730.EXE	if CPU_TYPE has PR$_SID_TYP730.
;
;
	MOVZBL	W^EXE$GB_CPUTYPE,R0	; Get CPU type code
	MOVAL	W^MODEL_TABLE-4[R0],R6	; Get addr of model list
	MOVC3	#3,(R6),W^NAME_XXX	; Copy model name into XXX
					;  field of SYSLOAXXX.EXE
;
; Conditionally look up loadable SCS code (SCSLOA.EXE).
;
	ASSUME	VMB$V_LOAD_SCS EQ 0
	BLBS	W^VMB_FLAGS,40$		; Look it up
	CLRL	W^SCSLOA_STAT+STAT_L_NAME ; Set for no lookup
40$:
;
; If this is a conversational bootstrap, then prompt terminal for command
; input to specify a starting set of parameters and any modifications 
; desired.  In the event that a conversational boot was not selected and
; there is no current parameter set, the defaults will be used anyway.
;
	BBC	#RPB$V_CONV,RPB$L_BOOTR5(R11),NOCONVER
					; Branch if not conversational
	PUSHL	#0			; Indicate no command echo
	CALLS	#1,W^BOO$GETPARAM	; Prompt for parameters
	MOVB	W^CPUTYPE,W^EXE$GB_CPUTYPE ; Restore CPU type to sys params
NOCONVER:
;
; Check for the presence of the TBCHK processor register.
;
	BBCC	S^#EXE$V_TBCHK,-	; Clear it out befor we check
		W^EXE$GL_DEFFLAGS,43$
43$:	MFPR	#PR$_SCBB,R8		; Pick up address of SCCB
	PUSHL	^X18(R8)		; Save RESERVED OPERAND slot
	MOVL	SP,R7			; Save stack
	MOVAB	B^44$,^X18(R8)		; Put in new handler
	MTPR	R0,#PR$_TBCHK		; Try to write it
	BBSS	S^#EXE$V_TBCHK,-
		W^EXE$GL_DEFFLAGS,44$	; It worked so set the bit
	BRB	44$
	.ALIGN	LONG			; Vectors must be on longword boundary
44$:	MOVL	R7,SP			; Restore stack
	POPL	^X18(R8)		; Restore RESERVED OPERAND
	MOVW	W^TTY$GW_CLASSNAM,TTNAME+1 ; Set ttdriver 2 letter prefix
;
; Look up the various images that need to be loaded. If there is a name,
; then open the image, derive and store the VBN of the first VBN past
; the image header and size (bytes) of the image excluding the image header.
;
	MOVAB	W^DSKDRV_STAT,R2	; Get adr of first stat block
	MOVL	S^#LOAD_IMAGE_CNT,R5	; Number of them to do
50$:	TSTL	STAT_L_NAME(R2)		; Is there a name?
	BEQL	60$			; No, do not do anything
	BSBW	IMAGE_INIT		; Open image, read 1st block beyond hdr
	MOVZWL	DPT$W_SIZE(R6),-
		STAT_L_BYTECNT(R2)	; Number of bytes in load image.
60$:	ADDL	#STAT_C_SIZE,R2		; Step to next driver
	SOBGTR	R5,50$			; Do them all
;
; All lookups are now complete, truncate the FIL$OPENFILE cache
;
LOOKUP_ALL_DONE:
	CALLS	#0,FIL$CACHE_TRUNC	; Truncate the FIL$OPENFILE cache
	MOVQ	W^FIL$GQ_CACHE,R0	; Get size and address
	MOVAB	-(R1)[R0],R0		; Form last byte inclusive
	ASHL	#-9,R0,W^CACHE_HI_PFN	; Save last PFN in FIL$OPENFILE cache
HAVEPRM:				; All parameter values have been acquired
;
; Acquire some useful information about the hardware/WCS we are running on.
;
	MFPR	#PR$_SID,W^EXE$GB_CPUDATA	; Grab the full SID
	MOVQ	W^CPUDATA,W^EXE$GB_CPUDATA+4	; ... and some extra
;
;	Use only specified number of physical pages to permit the testing
;	of small memory configurations without actually reconfiguring hardware.
;
	MOVQ	RPB$Q_PFNMAP(R11),R0	; Get descriptor for PFN bitmap
	MULL	#8,R0			; Scale byte count to bit count
	MOVL	W^MMG$GL_PHYPGCNT,R2	; Get count of pages to use
	CLRQ	R3			; Initialize bit pointer
					; R4 = 0, have not discarded
					; an otherwise usable PFN yet
10$:	BBC	R3,(R1),20$		; Skip over empty pages
	DECL	R2			; Count a present page
	BGEQ	20$			; Continue if count not exhausted
	BBSS	#0,R4,15$		; Branch if not first discarded PFN
	CMPL	R3,W^PFNMAP_HI_PFN	; Discarding bitmap pages?
	BGTR	12$			; Branch if not
	MOVQ	W^SMALL_PFNMAP,RPB$Q_PFNMAP(R11) ; Use the small bitmap
	CLRL	W^PFNMAP_HI_PFN		; This is in the pre-tested 64kb
12$:	CMPL	R3,W^CACHE_HI_PFN	; Discarding FIL$OPENFILE cache?
	BGTR	15$			; Branch if not
	CLRQ	W^FIL$GQ_CACHE		; Yes, disable it
	CLRL	W^CACHE_HI_PFN
15$:	CMPL	R3,W^CI_HI_PFN		; Bumped into the CI micro code?
	BGTR	17$			; Branch if not
	BRW	BUMP_CI			; Yes, give error message

17$:	BBCC	R3,(R1),20$		; Remove all pages once count exhausted
20$:	AOBLSS	R0,R3,10$		; Scan entire bitmap

;
;	COMPUTE VALUES FOR SHELL PROCESS FROM SYSGEN PARAMETERS
;
SHELLSIZE:				;
	ASHL	#2,W^SGN$GL_MAXVPGCT,R2	; 4*VIRTUALPAGE COUNT=BYTES OF PGTBL
	MOVAB	511(R2),R2		; ROUND UP TO PAGE BOUNDARY	
	ASHL	#-9,R2,R2		; DIVIDE BY 512 TO GET COUNT OF PAGES
	MOVL	R2,W^SGN$GL_PTPAGCNT	; SAVE COUNT OF PAGE TABLES
;
;	COMPUTE SIZE OF WSL PART OF PHD
;
	MULL3	#WSL$C_LENGTH,W^SGN$GL_MAXWSCNT,R3; SIZE OF WSLIST
	MULL3	#WSL$C_LENGTH,W^PQL$GDWSDEFAULT,R1; SIZE OF DEFAULT WSLIST
	SUBL3	R1,R3,R1			; FIND EMPTY BYTE COUNT
	MOVAB	<PHD$C_LENGTH+511>(R3),R3	; ADD FIXED SIZE AND ROUNDING
	MULW3	#SEC$C_LENGTH,W^SGN$GW_MAXPSTCT,R0; GUARANTEED SECTION SPACE
	MOVZWL	R0,R0			; ZERO EXTEND TO LONGWORD
	ADDL	R0,R3			; ADD TO FIXED AND WSL
	ASHL	#-9,R3,R3		; GET PAGE COUNT
	ASHL	#-9,R1,R1		; AND EMPTY PAGE COUNT
	SUBW3	R1,R3,W^SWP$GW_WSLPTE	; COUNT OF FIXED +WSL PAGES
	MOVW	R1,W^SWP$GW_EMPTPTE	; COUNT OF EMPTY PTE
	MOVL	R3,R0			; COUNT OF ALL WSL+FIXED PAGES
	ASHL	#9,R3,R3		; BACK TO BYTE COUNT
	MOVAB	511(R3),R3		; ADD PAGE ROUNDING FACTOR
	ADDL	R2,R0			; GET TOTAL HEADER PAGE COUNT
	MULL	#8,R0			; WSLX+BAK+LCK+VAL = 2+4+1+1
10$:	ADDL	R0,R3			; HEADER BYTE COUNT
	ASHL	#-9,R0,R0		; CONVERT ADDED BYTES TO PAGES
	MULL	#8,R0			; ADDED PAGES BACK TO ADDED BYTES
	BNEQ	10$			; REPEAT IF SIGNIFICANT
	ASHL	#-9,R3,R3		; GET TOTAL PAGE COUNT
	MOVL	R3,W^SGN$GL_PHDPAGCT	; SAVE TOTAL
	ASHL	#9,R3,R0		; GET BYTE COUNT FOR PHD
	SUBL3	R0,-			;
		#<^X80000000-<<<128*<SWP$C_DBGPTCNT+SWP$C_SHLP1PT>>-
		-SWP$C_SHLFPTE>@9>>,-	;
		W^MMG$GL_CTLBASVA	; SET CONTROL REGION BASE VA
	MOVL	W^MMG$GL_CTLBASVA,W^SWP$GL_PHDBASVA; AND SWAPPER VERSION
	SUBL3	R1,R3,W^SGN$GL_PHDAPCNT	; TOTAL ALLOCATED PAGES FOR SHELL PHD
	MOVW	R3,W^SWP$GW_BAKPTE	; SET AS TOTAL BAK PTE
	SUBW	W^SWP$GW_WSLPTE,W^SWP$GW_BAKPTE	;
	SUBW	R1,W^SWP$GW_BAKPTE	; SUBTRACT WSL AND EMPTY  TO GET BAK
	ASHL	#7,R3,W^SGN$GL_PHDLWCNT	; COUNT OF LONGWORDS IN PHD
	ADDL3	R2,R3,R0		; TOTAL PAGES
	ASHL	#7,R0,W^SGN$GL_P1LWCNT	; LW COUNT TO P1PT END
	ADDL3	#<127-SWP$C_SHLFPTE>,W^SGN$GL_PHDPAGCT,R4	; COMPUTE TOTAL
	ASHL	#-7,R4,R4		; COUNT OF EXTENSION PAGES
	ADDL	S^#SWP$C_SHLP1PT,R4	; TOTAL SHELL P1 PAGE TABLES
	MOVL	R4,W^SWP$GB_SHLP1PT	; SAVE RESULT
	ADDL	S^#SWP$C_KSTACK,R4	; ADD STACK
	ADDL	W^SGN$GL_PHDAPCNT,R4	; ADD ACTUAL PHD PAGE COUNT
	ADDL	S^#SWP$C_NDYN+1,R4	; VECTOR PAGE + DYNAMIC PAGES
	MOVL	R4,W^SWP$GL_SHELLSIZ	; SAVE SHELL SIZE TOTAL
;
;	Check  maximum and default process working set values to ensure
;	that they are at least large enough to contain the process header
;	plus the specified fluid working set.
;
	MOVZBL	W^SWP$GB_SHLP1PT,-(SP)	; GET COUNT OF MANDATORY PAGE TABLES
	MOVZWL	W^SGN$GW_MINWSCNT,R0	; GET MINIMUM FLUID WORKING SET
	ADDL	R0,R0			; DOUBLE FLUID REQUIREMENT
	ADDL	W^SGN$GL_PHDPAGCT,R0	; ADD MIN PROCESS HEADER SIZE
	ADDL	(SP)+,R0		; ADD COUNT OF NECESSARY PAGE TABLES
	ADDL	S^#SWP$C_KSTACK+1,R0	; ADD KERNEL STACK AND VECTOR PAGE
	CMPL	R0,W^SGN$GL_MAXWSCNT	; MUST BE LESS THAN THE TOTAL WORKING SET
	BLEQ	20$			; CONTINUE IF SO
	MOVL	R0,W^SGN$GL_MAXWSCNT	; FORCE TO  AT LEAST MINIMUM VALUE
	MSG	<-W-Maximum WS raised to PHD+MINWSCNT>
	BRW	HAVEPRM			; RECYCLE TO RECOMPUTE SIZES
20$:	CMPL	R0,PQL$GDWSDEFAULT	; MUST ALSO HAVE LARGE ENOUGH DEFAULT
	BLEQ	30$			; CONTINUE IF SO
	MOVL	R0,W^PQL$GDWSDEFAULT	; FORCE DEFAULT TO PROPER VALUE
	MOVL	R0,W^PQL$GMWSDEFAULT	; ALSO MINIMUM DEFAULT
	MOVL	R0,W^PQL$GDWSQUOTA	; AND WS QUOTA
	MOVL	R0,W^PQL$GMWSQUOTA	; AND MINIMUM QUOTA
	MSG	<-W-WS default and quota raised to PHD+MINWSCNT>
	BRW	HAVEPRM			; REPEAT CALCULATION
30$:					;
	MOVL	W^SGN$GL_MAXWSCNT,R0	; GET MAXIMUM SIZE OF WS
	CMPL	R0,W^PQL$GDWSQUOTA	; DEFAULT MUST BE LESS THAN MAX
	BGEQ	40$			; YES, CONTINUE
	MOVL	R0,W^PQL$GDWSQUOTA	; LIMIT DEFAULT TO MAXIMUM
	BRW	HAVEPRM			; RECYCLE THROUGH CALCULATIONS
40$:	CMPL	R0,W^PQL$GMWSQUOTA	; SAME FOR MINIMUM DEFAULT WS
	BGEQ	50$			; OK, CONTINUE
	MOVL	R0,W^PQL$GMWSQUOTA	; LIMIT TO MAXIMUM
	BRW	HAVEPRM			; RECYCLE THROUGH CALCULATIONS
50$:	CMPL	W^PQL$GDWSQUOTA,W^PQL$GDWSDEFAULT ; DEFAULT MUST BE LEQ QUOTA
	BGEQ	60$			; YES, CONTINUE
	MOVL	W^PQL$GDWSQUOTA,W^PQL$GDWSDEFAULT; LIMIT DEFAULT TO QUOTA
	BRW	HAVEPRM			; RECYCLE THROUG CALCULATIONS
60$:	CMPL	W^PQL$GMWSQUOTA,W^PQL$GMWSDEFAULT; SAME FOR MINIMUMS
	BGEQ	70$			; OK, CONTINUE
	MOVL	W^PQL$GMWSQUOTA,W^PQL$GMWSDEFAULT; LIMIT TO QUOTA
	BRW	HAVEPRM			; RECYCLE THROUGH CALCULATIONS
70$:					;
	ADDL3	W^SGN$GL_PHDPAGCT,W^SGN$GL_PTPAGCNT,R4	; GET TOTAL BALANCE SLOT PAGES
	MOVL	R4,W^SWP$GL_BSLOTSZ	; SAVE SIZE OF BALANCE SLOT IN PAGES
	MULL	W^SGN$GL_BALSETCT,R4	; TOTAL PAGE REQ FOR BALANCE SLOTS
NPAGE_SPT:
	BICL	#^X1FF,W^SGN$GL_NPAGEDYN	; ROUND DOWN TO PAGE BOUND
	BICL	#^X1FF,W^SGN$GL_NPAGEVIR	; ROUND DOWN TO PAGE BOUND
	CMPL	W^SGN$GL_NPAGEVIR,W^SGN$GL_NPAGEDYN ; MAXIMIZE WITH DYN VALUE
	BGEQ	10$			; BR IF VIR SUFFICIENT
	MOVL	W^SGN$GL_NPAGEDYN,W^SGN$GL_NPAGEVIR ; USE LARGER VALUE
10$:	BICL	#^X1FF,W^SGN$GL_PAGEDYN	; ROUND DOWN TO PAGE BOUND
	ADDL3	W^SGN$GL_PAGEDYN,W^SGN$GL_NPAGEVIR,R0 ; TOTAL POOL BYTES
	ASHL	#-9,R0,R0		; CONVERT TO PAGE COUNT
	ADDL	R0,R4			; TOTAL DYNAMIC SPT SO FAR
IRP_SPT:
	CMPL	W^SGN$GL_IRPCNTV,W^SGN$GL_IRPCNT ; CHECK I/O PACKET COUNT
	BGEQ	10$			; MAXIMIZE WITH IRPCNT
	MOVL	W^SGN$GL_IRPCNT,W^SGN$GL_IRPCNTV ; USE COUNT
10$:	MULL3	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,-
		W^SGN$GL_IRPCNTV,R1	 ; CALCULATE TOTAL BYTES
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO SPT TOTAL

;
; NOW ESTABLISH THE SPT REQUIRED FOR THE LRP LIST
;
LRP_SPT:
	CMPL	#<<IRP$C_LENGTH+^XF>&<^C<^XF>>>,-
		W^SGN$GL_LRPSIZE	; IS PACKET SIZE TOO SMALL ?
	BLEQ	30$			; IF LEQ, NO

	ASSUME	IRP$C_LENGTH LE <^XF0>
	MOVZBL	#<<IRP$C_LENGTH+^XF>&<^C<^XF>>>,-
		W^SGN$GL_LRPSIZE 	; FORCE SIZE TO MINIMUM
30$:	ADDL3	#64,W^SGN$GL_LRPSIZE,R1	; COMPUTE NEW LRP SIZE
	BICL3	#^XF,R1,W^BOO$GL_LRPSIZE
	CMPL	W^SGN$GL_LRPCNTV,W^SGN$GL_LRPCNT ; CHECK I/O PACKET COUNT
	BGEQ	40$			; MAXIMIZE WITH LRPCNT
	MOVL	W^SGN$GL_LRPCNT,W^SGN$GL_LRPCNTV ; USE COUNT
40$:	MULL3	W^BOO$GL_LRPSIZE,W^SGN$GL_LRPCNTV,R1	; CALCULATE TOTAL BYTES
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO SPT TOTAL
;
; ALLOCATE SPT FOR THE SMALL PACKET LIST
;
SRP_SPR:ADDL	#^XF,W^SGN$GL_SRPSIZE	; ROUND UP TO 16 BYTE BOUNDARY
	BICL	#^XF,W^SGN$GL_SRPSIZE	; 
	CMPL	W^SGN$GL_SRPCNTV,W^SGN$GL_SRPCNT ; CHECK I/O PACKET COUNT
	BGEQ	40$			; MAXIMIZE WITH SRPCNT
	MOVL	W^SGN$GL_SRPCNT,W^SGN$GL_SRPCNTV ; USE COUNT
40$:	MULL3	W^SGN$GL_SRPSIZE,W^SGN$GL_SRPCNTV,R1	; CALCULATE TOTAL BYTES
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO SPT TOTAL
PFN_SPT:
	TSTW	RPB$L_PFNCNT+2(R11)	; MORE THAN 32 MBYTES PRESENT?
	BNEQ	80$			; BRANCH IF YES
	MULL3	#PFN$C_WORD_LEN,RPB$L_PFNCNT(R11),R1; BYTES FOR PFN DATA BASE
	BRB	90$			; JOIN COMMON CODE
80$:	MULL3	#PFN$C_LONG_LEN,RPB$L_PFNCNT(R11),R1; BYTES FOR PFN DATA BASE
90$:	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO TOTAL SPT SIZE
	ADDL	W^SGN$GL_SPTREQ,R4	; ADD REQUESTED EXTRA PAGES
	ADDL	W^EXE$GL_RTIMESPT,R4	; Add SPTs requested for use by
					; realtime processes using
					; connect to interrupt.
	ADDL	#MMG$C_SPTSKEL,R4	; ADD SIZE OF SPT SKELETON
	MOVZWL	W^SGN$GW_SYSDWSCT,R0	; GET SIZE OF SYSTEM WORKING SET
	MULL	#WSL$C_LENGTH,R0 	; BYTE SIZE OF WORKING SET
	MOVAB	<PHD$C_LENGTH+511>(R0),R0 ; SYSPHD WITH WORKING SET LIST
	MULW3	#SEC$C_LENGTH,W^SGN$GW_GBLSECNT,R1; BYTES FOR GLOBAL SECTIONS
	MOVZWL	R1,R1			; ZERO EXTEND WORD
	ADDL	R1,R0			; TOTAL SYSTEM HEADER BYTES
	ASHL	#-9,R0,R0		; CONVERT TO PAGES
	MOVL	R0,W^BOO$GL_SYSPHDPG	; SAVE SYSPHD PAGE COUNT
	ADDL	R0,R4			; ADD TO SPT REQUIREMENT
	MOVZWL	W^SGN$GW_ISPPGCT,R0	; PAGES OF INTERRUPT STACK
	ADDL	R0,R4			; ADD TO SPT REQUIREMENT
	ASHL	#2,W^SGN$GL_MAXGPGCT,R1	; REQUESTED NUMBER OF GLOBAL PAGES
					; TO SIZE OF GLOBAL PAGE TABLE
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUNDARY
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	MOVL	R1,W^BOO$GL_GPTPGCT	; SAVE COUNT OF GLOBAL PAGE TABLES
	ADDL	R1,R4			; ADD TO SPT TOTAL
SIZ_SCB:				; COMPUTE # PAGES FOR SCB
	MOVZBL	#1,R0			; ASSUME 1 PAGE SCB
					;
	CPUDISP	<SIZ_SCB_780,-		; *DISPATCH ON CPU TYPE*
		SIZ_SCB_750,-		;
		SIZ_SCB_730>

SIZ_SCB_730:
	INCL	R0			; SCB ALWAYS 2 PAGES (1 UNIBUS)
	BRB	SIZ_SCB_END
					;
SIZ_SCB_750:				; 11/750:
	INCL	R0			; ASSUME 2 PAGE SCB (1 UNIBUS)
	TSTB	RPB$B_CONFREG+IO750$C_SL_UB1(R11) ; SECOND UNIBUS CONFIGURED?
	BEQL	SIZ_SCB_END		; BRANCH IF NOT
	INCL	R0			; ELSE 3 PAGE SCB
					;
SIZ_SCB_780:				; (FOR 11/780, PAGE COUNT=1)
					;
SIZ_SCB_END:				; *END OF CPU-DEPENDENT CODE*
					;
	MOVL	R0,W^SCBPAGCT		; SAVE SCB SIZE IN PAGES
	ADDL	R0,R4			; ADD SCB PAGES TO SPT TOTAL
	ASHL	#9,R0,W^SCBBYTCT	; SAVE SCB SIZE IN BYTES
	MOVAB	127(R4),R4		; ROUND TO PAGE BOUND
	ASHL	#-7,R4,R1		; CONVERT TO PAGES
	ADDL	R1,R4			; ADD PAGES OF SPT TO MAP
	ASHL	#-7,R4,R4		; PAGE COUNT FOR SPT ALLOCATION
	MOVL	R4,W^BOO$GL_SPTPAGCT	; SAVE COUNT OF PAGES
ALLOCSPT:				; ALLOCATE SPACE FOR SYSPHD AND SPT
	.ENABLE LSB
	ADDL3	R4,W^BOO$GL_SYSPHDPG,R8	; TOTAL SIZE OF PHD+SPT
	ADDL	W^SCBPAGCT,R8		;  PLUS SCB
	MOVL	RPB$Q_PFNMAP+4(R11),R7	; GET ADDRESS FOR PFNMAP
	MOVL	W^MEM_HI_PFN,R6		; GET HIGHEST PFN+1 IN MEMORY
10$:	DECL	R6			; POINT TO NEXT/HIGHEST PAGE
	BGTR	20$			; CONTINUE IF PAGES AVAILABLE
15$:	MSG	<-F-Unable to allocate SPT+PHD+SCB.>
	HALT				; *** FATAL ERROR ***

20$:	BBC	R6,(R7),10$		; FIND HIGHEST PAGE NUMBER
	TSTL	W^BOO$GL_NEXTPFN	; HAVE WE MARKED IT?
	BNEQ	25$			; YES
	MOVL	R6,W^BOO$GL_NEXTPFN	; SAVE HIGH WATER MARK
25$:	CLRL	R0			; INIT COUNT OF CONTIGUOUS PAGES
	BRB	35$			;
30$:	DECL	R6			; NEXT PAGE (LOWER)
	BBC	R6,(R7),10$		; SKIP IF NO FIT
35$:	INCL	R0			; BUMP COUNT OF PAGES
	CMPL	R0,R8			; CHECK FOR FIT
	BLSS	30$			; NOT YET
	SUBL	R0,RPB$L_PFNCNT(R11)	; ACCOUNT FOR PAGES REMOVED
	MOVL	R6,R1			; COPY LOWEST PAGE NUMBER
40$:	BBCC	R1,(R7),50$		; MARK PAGE ALLOCATED
	INCL	R1			; NEXT PAGE
50$:	SOBGTR	R0,40$			; ALLOCATE THEM ALL
;
;	R6 - PFN FOR START OF SCB
;	R7 - BASE OF PFNMAP
;	R8 - SIZE OF SYSPHD+SPT+SCB IN PAGES
;	R4 - SPT SIZE IN PAGES
;
	ASHL	#9,R6,R9		; COMPUTE PHYSICAL ADDRESS OF SCB
	CMPL	R9,W^BOO$GL_FREEMEM	; CHECK FOR OVERLAP WITH SYSBOOT
	BLSS	15$			; CONTINUE IF OK
	CMPL	R6,W^PFNMAP_HI_PFN	; RAN INTO PFN BITMAP?
	BLEQ	15$			; BRANCH IF YES
	CMPL	R6,W^CACHE_HI_PFN	; RAN INTO FIL$OPENFILE CACHE?
	BGTR	55$			; BRANCH IF NOT
	CLRQ	W^FIL$GQ_CACHE		; YES, DISABLE IT
	CLRL	W^CACHE_HI_PFN
55$:	CMPL	R6,W^CI_HI_PFN		; RAN INTO CI MICROCODE?
	BGTR	57$			; BRANCH IF NOT
BUMP_CI:MSG	<-F-PFN allocation overwrites CI ucode.>
	HALT

57$:	MOVL	R9,R0			; GET A WORKING COPY OF ADDRESS
	ASHL	#5,R8,R1		; GET COUNT OF DOUBLE QUADWORDS
60$:	CLRQ	(R0)+			; CLEAR A
	CLRQ	(R0)+			;  DOUBLE QUADWORD
	SOBGTR	R1,60$			; CLEAR THEM ALL
	.DISABLE LSB
INIT_SCB:				; INITIALIZE SYSTEM SCB
	MOVL	R9,W^SCBPHADDR		; SAVE PHYSICAL ADDR OF SCB
	MOVC3	#512,W^SCB$AL_BASE,(R9)	; COPY ARCHITECTURAL PART
					;  OF SCB (1 PG) FROM TEMPLATE
					;  TO SYSTEM COPY. (RETURNS
					;  SCB ADDR+512 IN R3.)
	SUBL3	#512,W^SCBBYTCT,R0	; GET # BYTES REMAINING IN SCB
	BLEQ	20$			; BRANCH IF NONE
	ASHL	#-2,R0,R0		; CONVERT # BYTES TO LONGWDS
10$:	MOVL	#ERL$UNEXP+1,(R3)+	; SET NEXT VECTOR TO UNEXPECTED INT
	SOBGTR	R0,10$			; BRANCH IF MORE VECTORS
;
; CPU specific code for 11/780.  Point SCB vector 0 interrupts and NEXUS
; vector 0 interrupts to separate routine in module ERRORLOG.
;

20$:	CPUDISP	<SCB_VEC_780,-		; Dispatch on CPU type
		SCB_VEC_750,-
		SCB_VEC_730>

SCB_VEC_780:
	MOVAL	@#ERL$VEC_RETURN+1,(R9)	; Set address of routine in SCB
					; vector 0 location.  Leave
					; interrupt stack bit clear.
	MOVL	(R9),^X100(R9)		; Set address in SCB NEXUS 0 vector
	MOVL	(R9),^X140(R9) 		; For all four NEXUS IPL's
	MOVL	(R9),^X180(R9)
	MOVL	(R9),^X1C0(R9)
	DECL	(R9)			; Restore the interrupt stack bit

SCB_VEC_750:
SCB_VEC_730:				; Do nothing for 11/750 and 11/730

; End of CPU dependent code

INIT_SYSPHD:				; INITIALIZE SYSTEM PHD
	ADDL	W^SCBBYTCT,R9		; STEP PAST SCB TO PHD
	MOVC3	#PHD$C_LENGTH,W^BOO$A_SYSPHD,(R9)	; COPY PHD TO REAL PLACE
	MOVW	W^SGN$GW_SYSDWSCT,R0	; GET SIZE OF SYSTEM WORKING SET
	MOVW	R0,PHD$W_WSSIZE(R9)	; SET SYSTEM WORKING SET SIZE
	ADDW	PHD$W_WSNEXT(R9),R0	; GET POINTER TO WORKING SET
	MOVW	R0,PHD$W_WSLAST(R9)	; SET END OF SYSTEM WORKING SET LIST
	MOVW	R0,PHD$W_WSQUOTA(R9)	; SET QUOTA VALUES
	MOVW	R0,PHD$W_WSAUTH(R9)	; FOR CONSISTENCY
	MOVW	R0,PHD$W_DFWSCNT(R9)	; SAKE
	MOVW	R0,PHD$W_WSEXTENT(R9)	; ...
	MOVW	R0,PHD$W_WSAUTHEXT(R9)	; ...
	MOVW	W^SGN$GL_BALSETCT,PHD$W_PHVINDEX(R9)	; SET HEADER NUMBER
	ADDB3	#1,W^SGN$GW_SWPFILES,PHD$B_PAGFIL(R9) ; SET SYSTEM PAGING FILE
	ASHL	#7,W^BOO$GL_SPTPAGCT,PHD$L_P0LRASTL(R9)	; SET SPT LENGTH	
	MOVL	PHD$L_P0LRASTL(R9),W^MMG$GL_SPTLEN	; AND SAVE FOR REFERENCE
	ASHL	#9,W^BOO$GL_SYSPHDPG,R1	; BYTE OFFSET TO SPT
	ADDL3	R1,R9,W^MMG$GL_SBR	; SAVE PHYSICAL ADDRESS OF SPT
	ASHL	#9,W^BOO$GL_SYSPHDPG,PHD$L_PSTBASOFF(R9); SAVE AS BYTE OFFSET
	ASHL	#9,PHD$L_P0LRASTL(R9),R0; COMPUTE MAX SYSTEM ADDRESS+1
	ASHL	#VA$V_SYSTEM,#1,R2	; SYSTEM MASK
	BISL3	R2,R0,PHD$L_FREP0VA(R9)	; SAVE AS MAX ADDRESS
	BISL3	R2,R0,W^MMG$GL_FRESVA	;
	BISL3	R2,R0,W^MMG$GL_MAXSYSVA	;
	BISL3	R2,R0,W^MMG$GL_MAXGPTE	;
	MOVL	R9,W^BOO$GL_SYSPHD	; SAVE PHYSICAL PHD ADDRESS
	SUBL3	W^BOO$GL_GPTPGCT,PHD$L_P0LRASTL(R9),R1	; VPN OF GPT
	ASHL	#9,R1,R0		; CONVERT TO BYTE ADDRESS
	BISL3	R2,R0,W^MMG$GL_GPTE	; BASE OF GLOBAL PAGE TABLE ENTRIES
	SUBL	W^BOO$GL_SPTPAGCT,R1	; VPN OF SPT
	ASHL	#9,R1,R0		; BYTE ADDRESS
	BISL3	R2,R0,W^MMG$GL_GPTBASE	; SAVE AS GPT BASE
	BISL3	R2,R0,W^MMG$GL_SPTBASE	; AND SPT BASE
	BISL3	R2,R0,PHD$L_P0BR(R9)	; AND VIRTUAL SBR
	SUBL	W^BOO$GL_SYSPHDPG,R1	; VPN OF SYSPHD
	ASHL	#9,R1,R0		; BYTE ADDRESS
	BISL3	R2,R0,W^MMG$GL_SYSPHD	; SAVE VIRTUAL POINTER TO PHD
	ASHL	#9,W^BOO$GL_SYSPHDPG,W^MMG$GL_SYSPHDLN	; BYTES IN SYSTEM PHD
	MULL3	W^SWP$GL_BSLOTSZ,W^SGN$GL_BALSETCT,R0	; BALANCE SET MAP SIZE
	SUBL3	R0,R1,R0		; VPN OF BAL BASE
	MOVAL	@W^MMG$GL_SPTBASE[R0],W^SWP$GL_BALSPT	; SET BASE OF BALANCE MAP
	ASHL	#9,R0,R0		; CONVERT VPN TO VA
	BISL3	R2,R0,W^SWP$GL_BALBASE	; SAVE VA BASE OF BALANCE SLOTS
	SUBL	W^SCBBYTCT,R0		; COMPUTE VA OF SCB
	BISL3	R2,R0,EXE$GL_SCB	; SAVE SYSTEM SPACE VA OF SCB
	MOVAB	-512(R0),R0		; SKIP ONE PAGE FOR ERROR DETECTION
	BISL3	R2,R0,W^EXE$GL_INTSTK	; SET BASE OF INTERRUPT STACK
	MOVAL	@W^MMG$GL_SBR[R1],R3	; POINTER TO SPTE
	SUBL3	W^SCBPAGCT,R8,R0	; GET # PAGES IN PHD+SPT ONLY
	ADDL	W^SCBPAGCT,R6		; GET PFN OF START OF SYS PHD
10$:	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R6,(R3)+	; MAP A PAGE
	INCL	R6			; NEXT PFN
	SOBGTR	R0,10$			; MAP ENTIRE SYSPHD+SPT
	MOVL	W^BOO$GL_GPTPGCT,R0	; COUNT OF GLOBAL PAGE TABLE PAGES
20$:	MOVL	#PTE$C_URKW,(R3)+	; FILL THEM AS DEMAND ZERO
	SOBGTR	R0,20$			;
MAPSCB:					; MAP SCB
	EXTZV	#VA$V_VPN,#VA$S_VPN,-	; GET VPN OF
		W^EXE$GL_SCB,R1		; SCB
	MOVAL	@W^MMG$GL_SBR[R1],R3	; GET ADDR OF SPTE TO FILL
	MOVL	W^SCBPAGCT,R1		; GET # PAGES OF SCB
	ASHL	#-9,W^SCBPHADDR,R0	; GET PFN OF START OF SCB
10$:	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,- ; MAP NEXT SPTE
		R0,(R3)+
	INCL	R0			; STEP TO NEXT PFN
	SOBGTR	R1,10$			; MAP WHOLE SCB
MAPISTK:				; MAP INTERRUPT STACK
	EXTZV	#VA$V_VPN,#VA$S_VPN,W^EXE$GL_INTSTK,R1	; GET VPN FOR INT STK
	MOVAL	@W^MMG$GL_SBR[R1],R3	; SVASPT + 4
	MOVZWL	W^SGN$GW_ISPPGCT,R1	; GET PAGE COUNT FOR INTERRUPT STACK
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ENTIRE INTERRUPT STACK
	MOVZWL	W^SGN$GW_ISPPGCT,R1	; GET SIZE OF INTERRUPT STACK
	INCL	R1			; SKIP ONE PAGE FOR ERROR DETECTION
	TSTL	-(R3)			; ALSO BUMP SPT POINTER DOWN
	ASHL	#9,R1,R1		; CONVERT TO BYTES
	SUBL3	R1,W^EXE$GL_INTSTK,R1	; FORM ADDRESS OF BASE
;
; NOW ESTABLISH THE SIZE AND BASE ADDRESS OF THE SMALL REQUEST PACKET
; LOOK ASIDE LIST
;
ALLOC_SRP:
	MOVL	W^SGN$GL_SRPCNT,W^BOO$GL_SRPCNT	; COUNT OF SRP'S TO INITIALIZE
	MULL3	W^SGN$GL_SRPSIZE,W^SGN$GL_SRPCNT,R2 ; CALCULATE TOTAL BYTES
	MOVAB	511(R2),R2		; ROUND TO PAGE
	BICL	#^X1FF,R2		; BOUNDARY
	MULL3	W^SGN$GL_SRPSIZE,W^SGN$GL_SRPCNTV,R0; CALCULATE VIRTUAL BYTES
	MOVAB	511(R0),R0		; AND ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R0		;
	SUBL3	R0,R1,-
		W^BOO$GL_SRPSPLIT	; LOOKASIDE LIST SPLIT ADDRESS
	ADDL3	R2,W^BOO$GL_SRPSPLIT,-
		W^MMG$GL_SRPNEXT	; NEXT PAGE TO ALLOCATE FOR SRP AREA
	SUBL	R2,R0			; COMPUTE SIZE OF GAP
	ASHL	#-7,R0,R0		; CONVERT TO 4*PAGES
	SUBL	R0,R3			; SKIP SPT ENTRIES FOR GAP
	ASHL	#-9,R2,R1		; COMPUTE PAGE COUNT TO ALLOCATE
	BEQL	20$			; BR IF NONE
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ACTIVE SRP AREA
20$:
ALLOC_IRP:
	MOVL	W^SGN$GL_IRPCNT,R2	; USE COUNT
	MOVL	R2,W^BOO$GL_IRPCNT	; COUNT OF IRP'S TO INITIALIZE
	MULL	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,R2 ; CALCULATE TOTAL BYTES
	MOVAB	511(R2),R2		; ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R2		; SIZE OF ALLOCATED IRP AREA
	MULL3	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,-
		W^SGN$GL_IRPCNTV,R0	; CALCULATE TOTAL BYTES
	MOVAB	511(R0),R0		; ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R0		; VIRTUAL SIZE OF IRP AREA

	SUBL3	R0,W^BOO$GL_SRPSPLIT,R1	; BASE ADDRESS OF IRP AREA
	MOVL	R1,W^BOO$GL_SPLITADR	; LOOKASIDE LIST SPLIT ADDRESS
	ADDL3	R1,R2,W^MMG$GL_IRPNEXT	; SET ADDRESS FOR NEXT ALLOCATION
	SUBL	R2,R0			; COMPUTE SIZE OF GAP
	ASHL	#-7,R0,R0		; CONVERT TO PAGES*4
	SUBL	R0,R3			; SKIP SPT ENTRIES FOR GAP
	ASHL	#-9,R2,R1		; CONVERT ACTIVE ARE TO PAGE COUNT
	BEQL	20$			; BR IF NONE
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ACTIVE IRP AREA
20$:					;
;
; NOW ESTABLISH THE SIZE AND BASE ADDRESS OF THE LARGE REQUEST PACKET
; LOOK ASIDE LIST
;
ALLOC_LRP:
	DIVL3	#5,W^BOO$GL_LRPSIZE,R1	; COMPUTE LRP SIZE - 20%
	SUBL3	R1,W^BOO$GL_LRPSIZE,R1
	BICL3	#^XF,R1,W^BOO$GL_LRPMIN
	MOVL	W^SGN$GL_LRPCNT,W^BOO$GL_LRPCNT	; COUNT OF LRP'S TO INITIALIZE
	MULL3	W^BOO$GL_LRPSIZE,W^SGN$GL_LRPCNT,R2 ; CALCULATE TOTAL BYTES
	MOVAB	511(R2),R2		; ROUND TO PAGE
	BICL	#^X1FF,R2		; BOUNDARY
	MULL3	W^BOO$GL_LRPSIZE,W^SGN$GL_LRPCNTV,R0; CALCULATE VIRTUAL BYTES
	MOVAB	511(R0),R0		; AND ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R0		;
	SUBL3	R0,W^BOO$GL_SPLITADR,-
		W^BOO$GL_LRPSPLIT	; LOOKASIDE LIST SPLIT ADDRESS
	ADDL3	R2,W^BOO$GL_LRPSPLIT,-
		W^MMG$GL_LRPNEXT	; NEXT PAGE TO ALLOCATE FOR LRP AREA
	SUBL	R2,R0			; COMPUTE SIZE OF GAP
	ASHL	#-7,R0,R0		; CONVERT TO 4*PAGES
	SUBL	R0,R3			; SKIP SPT ENTRIES FOR GAP
	ASHL	#-9,R2,R1		; COMPUTE PAGE COUNT TO ALLOCATE
	BEQL	20$			; BR IF NONE
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ACTIVE LRP AREA
20$:					;
MAPNPAGDYN:				; MAP NON-PAGED DYNAMIC POOL
	MOVL	W^BOO$GL_LRPSPLIT,R1	; GET ADDRESS OF PREVIOUS AREA
	SUBL3	W^SGN$GL_NPAGEVIR,W^SGN$GL_NPAGEDYN,R0 ; GET NEG SIZE OF GAP
	SUBL	W^SGN$GL_NPAGEVIR,R1	; AND COMPUTE BASE OF POOL
	MOVL	R1,W^MMG$GL_NPAGEDYN	; SAVE VA OF BASE
	ADDL3	R1,W^SGN$GL_NPAGEDYN,W^MMG$GL_NPAGNEXT	; SET VA OF NEXT PAGE
	SUBL3	W^SGN$GL_PAGEDYN,R1,W^MMG$GL_PAGEDYN	; COMPUTE BASE OF PAGED POOL
	ASHL	#-9,R0,R0		; CONVERT GAP TO PAGE COUNT
	MOVAL	(R3)[R0],R3		; ADVANCE SPT POINTER PAST GAP
	MOVL	W^SGN$GL_NPAGEDYN,R1	; GET BYTES OF POOL
	ASHL	#-9,R1,R1		; AND CONVERT TO PAGE COUNT
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,-(R3); FILL A VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ALL POOL PAGES
;
; PREALLOCATE THE TOP OF POOL AND PLACE THE FIL$OPENFILE CACHE UP THERE
; START BY ESTBALISHING THE SIZE AND BASE ADDRESS OF THE IRP LOOKASIDE LIST
;
	MOVAL	W^BOO$GL_NPAGEDYN,R0	; ADDRESS OF POOL SIZE WITH
	MOVL	W^SGN$GL_NPAGEDYN,(R0)	; INIT TO SIZE OF NON-PAGED POOL
					; PREALLOCATED PIECES TAKEN OUT
;
; Now allocate pool for:
;	Boot Driver for System Disk
;	 and any ucode needed for it
;	System Disk Driver
;	Port Driver (if any)
;	Terminal Driver - TTDRIVER.EXE
;	CPU dependent code - SYSLOA.EXE
;	SCS loadable code - SCSLOA.EXE
;
ALLOC_DRIVERS:
	MOVAL	W^BOODRV_STAT,R2	; STAT BLOCK FOR BOOT DRIVER
	MOVL	S^#ALLOC_POOL_CNT,R4	; NO. OF DRIVERS TO ALLOCATE SPACE FOR
10$:	BSBW	ALLOC_POOL
	ADDL	#STAT_C_SIZE,R2		; POINT TO NEXT STAT BLOCK
	SOBGTR	R4,10$			; ALLOCATE SPACE FOR NEXT DRIVER
;
; The following code calculates the amount of space needed to map
; INILOA.EXE and the FIL$OPENFILE cache.  If they are both deemed
; to fit with enough left over, then the FIL$OPENFILE cache
; is allocated next and the space for INILOA.EXE last.  This is
; because INILOA will be released by INIT and the cache will be
; released sometime later by SYSINIT.
;
ALLOC_FILCACHE:
	MOVL	W^FIL$GQ_CACHE,R3	; GET SIZE IN R3
	BEQL	80$			; BRANCH IF DISABLED
	ADDL	#^XF,R3			; ROUND TO QUAD WORD
	BICL	#^XF,R3			; FOR POOL ALLOCATION
;
; IF THE FIL$OPENFILE CACHE IS LARGE WITH RESPECT TO THE AMOUNT OF
; SPACE THAT IS LEFT IN THE POOL, THEN SIMPLY DISABLE IT.
;
	SUBL3	W^INILOA_STAT+STAT_L_BYTECNT,(R0),R5 ; SPACE AFTER INILOA
	DIVL	#2,R5			; 50% OF THE SPACE LEFT
	CMPL	R3,R5			; CACHE TOO BIG?
	BLEQ	70$			; BRANCH IF NOT
50$:	CLRL	R3			; DISABLE THE FILE CACHE
70$:	TSTL	R3			; IS THE CACHE ENABLED?
	BEQL	80$			; BRANCH IF NOT
	SUBL	R3,(R0)			; ALLOCATE FIL$OPENFILE CACHE
	ADDL3	(R0),W^MMG$GL_NPAGEDYN,R4 ; ADDRESS OF FILE CACHE IN POOL
	MOVQ	R3,W^BOO$GQ_FILCACHE	; SET SIZE AND ADDRESS OF FILE CACHE
80$:
ALLOC_INILOA:
	MOVAL	W^INILOA_STAT,R2	; STATISTICS BLOCK FOR LOADABLE INIT CODE
	BSBW	ALLOC_POOL
	MOVL	R1,W^BOO$GQ_INILOA+4	; SAVE SIZE FOR INIT TO DEALLOCATE
;
;	There are two separate dependencies on the FIL$OPENFILE cache
; being allocated as the next higher address after INILOA.  First the
; initial pool fragmentation is eliminated by the orderly deallocation
; of these 2 pieces, INILOA by INIT and the FIL$OPENFILE cache by SYSINIT.
; Second, the code at MOVEFILECACHE below depends on being able to
; disable the FIL$OPENFILE cache by clearing the descriptor and adding
; its size to the length of INILOA for deallocation by the INIT code.
;
; At this point non-paged pool look like this:
;
;	+-----------------------------------------+
;	!                                         !  :MMG$GL_NPAGEDYN
;	!                                         !
;	!	       Available Pool		  !
;	!                                         !
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!               INILOA.EXE                !  :BOO$GQ_INILOA
;	!                                         !   (deallocated by INIT)
;	+-----------------------------------------+
;	!                                         !
;	!           FIL$OPENFILE Cache            !  :BOO$GQ_CACHE
;	!                                         !   (deallocated by SYSINIT)
;	+-----------------------------------------+
;	!					  !
;	!		SCSLOA.EXE		  !  :BOO$GL_SCSLOA
;	!		(if loaded)		  !
;	!					  !
;	+-----------------------------------------+
;	!                                         !
;	!             SYSLOAxxx.EXE               !  :BOO$GL_SYSLOA
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!              TTDRIVER.EXE               !  :BOO$GL_TRMDRV 
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!              PxDRIVER.EXE               !  :BOO$GL_PRTDRV
;	!		(if loaded)		  !
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!            System Disk Driver           !  :BOO$GL_DSKDRV
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!                 BOOTCB                  !  :BOO$GL_BOOTCB
;	!          Bootstrap Disk Driver          !  :RPB$L_IOVEC(RPB_ADR)
;	!	       Microcode file		  !  :BOO$GL_UCODE
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           LRP Look-aside List           !  :BOO$GL_LRPSPLIT
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           IRP Look-aside List           !  :BOO$GL_SPLITADR
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           SRP Look-aside List           !  :BOO$GL_SRPSPLIT
;	!                                         !
;	+-----------------------------------------+
;
;	MOVE SKELETON SPT TO ACTUAL LOCATION
;
	MOVC3	#<MMG$C_SPTSKEL@2>,-	;
		W^MMG$AL_SYSPAGTB,-	;
		@W^MMG$GL_SBR		;
MAPRESEXEC:				; MAP RESIDENT EXEC
	EXTZV	#VA$V_VPN,#VA$S_VPN,W^MMG$GL_PGDCOD,R1	; GET START OF PAGED EXEC
	MOVAL	@W^MMG$GL_SBR[R1],R3	; GET SVASPT
	SUBL2	#<<MMG$A_ENDVEC-^X80000000>@-9>,R1	; CONVERT TO PAGE COUNT
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BICL	#PTE$M_PFN,-(R3)	; CLEAR PFN FIELD
	BISL	R0,(R3)			; ATTEMPT SIMPLE MERGE OF PAGE
	BLSS	20$			; SUCCESS
	BISL3	#<PTE$C_URKW!PTE$M_VALID>,R0,(R3); MAP A VALID PAGE
20$:	SOBGTR	R1,10$			; MAP ALL RESIDENT EXEC
MAPPFNDAT:				; MAP PFN DATA BASE
	MOVL	W^MEM_LO_PFN,W^MMG$GL_MINPFN	; INITIALIZE SMALLEST PFN
	clrl	w^mmg$gl_minpfn		; *************** TEMP ***************
	ADDL3	#2,W^BOO$GL_NEXTPFN,R3	; START WITH CURRENT TOP PFN + FUDGE
	MOVL	R3,W^MMG$GL_MAXPFN	; MAKE FIRST CUT AT PFN DATA BASE SIZE
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=3$
		MOVB	#PFN$C_LONG_LEN,W^PFN$GB_LENGTH
	PFN_DISP_ELSE			ELSE_CODE=3$,COMMON_CODE=6$
		MOVB	#PFN$C_WORD_LEN,W^PFN$GB_LENGTH
	PFN_DISP_ENDIF			COMMON_CODE=6$
	MNEGL	W^MMG$GL_MINPFN,R4	; R4 CONTAINS NEGATIVE OF BASE PFN NUMBER
	ADDL2	R4,R3			; R3 NOW CONTAINS PFN COUNT
	MOVZBL	W^PFN$GB_LENGTH,R5	; R5 CONTAINS NUMBER OF BYTES PER PAGE
	MULL3	R5,R3,R2		; COMPUTE BYTES OF PFN DATA BASE NEEDED
	MOVAB	511(R2),R2		; ROUND UP TO PAGE BOUND
	ASHL	#-9,R2,R0		; AND CONVERT TO PAGES
10$:	MULL	R5,R0			; GET BYTES OF PFN DATA
	SUBL	R0,R2			; REMOVE FROM REQUIREMENT
	ASHL	#-9,R0,R0		; GET PAGES REMOVED
	BNEQ	10$			; BR IF WHOLE PAGES REMOVED
	ASHL	#-9,R2,R2		; CONVERT TO PAGE COUNT
	SUBL	R2,R3			; SUBTRACT PAGES OF PFN DATA
	MULL	R5,R3			; COMPUTE BYTE OF PFN DATA
	MOVAB	511(R3),R2		; ROUND TO NEXT PAGE
	ASHL	#-9,R2,R1		; COMPUTE PAGES OF PFN DATA BASE
	ASHL	#9,R1,R2		; BACK TO BYTES
	DIVL3	R5,R2,R3		; COMPUTE NUMBER OF ENTRIES
	SUBL3	R2,W^MMG$GL_PAGEDYN,R2	; SUBTRACT FROM PAGEDYN TO GET PFN BASE
	MOVL	R2,W^PFN$AL_PTE		; SAVE AS BASE OF FIRST W^PFN ARRAY
	MOVAL	@W^PFN$AL_PTE[R3],W^PFN$AL_BAK	; ADD SIZE * PAGE COUNT
	MOVAL	@W^PFN$AL_BAK[R3],W^PFN$AW_REFCNT	; FOR EACH OF THE W^PFN ARRAYS
	MOVAW	@W^PFN$AW_REFCNT[R3],W^PFN$Ax_FLINK;
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=20$
		MOVAL	@W^PFN$Ax_FLINK[R3],W^PFN$Ax_BLINK	; TO GET ADDRESS OF NEXT
		MOVAL	@W^PFN$Ax_BLINK[R3],W^PFN$AW_SWPVBN; ARRAY BASE
	PFN_DISP_ELSE			ELSE_CODE=20$,COMMON_CODE=25$
		MOVAW	@W^PFN$Ax_FLINK[R3],W^PFN$Ax_BLINK	; TO GET ADDRESS OF NEXT
		MOVAW	@W^PFN$Ax_BLINK[R3],W^PFN$AW_SWPVBN; ARRAY BASE
	PFN_DISP_ENDIF			COMMON_CODE=25$
	MOVAW	@W^PFN$AW_SWPVBN[R3],W^PFN$AB_STATE;
	MOVAB	@W^PFN$AB_STATE[R3],W^PFN$AB_TYPE	;
;
; RESET BASE OF EACH ARRAY TO ACCOUNT FOR NONZERO MINPFN.
; R4 CONTAINS THE NEGATIVE OF THE SMALLEST PFN IN THE PFN DATA BASE.
;
	MOVAL	@W^PFN$AL_PTE[R4],W^PFN$AL_PTE
	MOVAL	@W^PFN$AL_BAK[R4],W^PFN$AL_BAK
	MOVAW	@W^PFN$AW_REFCNT[R4],W^PFN$AW_REFCNT
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=30$
		MOVAL	@W^PFN$Ax_FLINK[R4],W^PFN$Ax_FLINK
		MOVAL	@W^PFN$Ax_BLINK[R4],W^PFN$Ax_BLINK
	PFN_DISP_ELSE			ELSE_CODE=30$,COMMON_CODE=35$
		MOVAW	@W^PFN$Ax_FLINK[R4],W^PFN$Ax_FLINK
		MOVAW	@W^PFN$Ax_BLINK[R4],W^PFN$Ax_BLINK
	PFN_DISP_ENDIF			COMMON_CODE=35$
	MOVAW	@W^PFN$AW_SWPVBN[R4],W^PFN$AW_SWPVBN
	MOVAB	@W^PFN$AB_STATE[R4],W^PFN$AB_STATE
	MOVAB	@W^PFN$AB_TYPE[R4],W^PFN$AB_TYPE
	PUSHL	R2			; SAVE PFN DATA AREA BASE ADDRESS
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R2	; COMPUTE STARTING PAGE NUMBER
	MOVAL	@W^MMG$GL_SBR[R2],R3	; AND CONVERT TO SVAPTE
	MOVAL	(R3)[R1],R3		; POINTING TO HIGH VPN+1
40$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_URKW!PTE$M_VALID>,R0,-(R3); MAP A VALID ENTRY
	ASHL	#9,R0,R0		; CONVERT TO PHYSICAL ADDRESS
	MOVZWL	#512/8,R2		; SET COUNT TO CLEAR
45$:	CLRQ	(R0)+			; CLEAR A QUAD
	SOBGTR	R2,45$			; CLEAR ENTIRE PAGE
	SOBGTR	R1,40$			; DO ALL OF THE PFN DATA BASE PAGES
	POPR	#^M<R2>			; RESTORE BASE ADDRESS
MAPRPB:					;
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R2 ; FREE HIGH VPN+1
	DECL	R2			; VPN FOR RPB
	ASHL	#-9,R11,R0		; PFN FOR FPB
	BBCC	R0,@RPB$Q_PFNMAP+4(R11),10$	; MARK RPB ALLOCATED
10$:	BISL3	#<PTE$C_URKW!PTE$M_VALID>,R0,@MMG$GL_SBR[R2]	; MAP PAGE
	DECL	RPB$L_PFNCNT(R11)	; ONE LESS AVAILABLE PAGE
	ASHL	#9,R2,R0		; CONVERT VPN TO VA
	BISL3	#^X80000000,R0,W^EXE$GL_RPB	; SAVE VA OF RPB
	MOVAB	-(R2),W^BOO$GL_SPTFREH	; SAVE FOR SUBSEQUENT USE
	MOVZWL	#MMG$C_SPTSKEL,W^BOO$GL_SPTFREL	; SAVE LOW VPN ALSO
	MOVL	W^BOO$GL_NEXTPFN,W^MMG$GL_MAXPFN ; SAVE MAX PFN VALUE
MAPPAGED:				; MAP POTENTIALLY PAGED EXEC
	MOVL	#<<MMG$A_SYS_END-^X80000000>@-9>,R3	; VPN+1 OF END OF EXEC
	BBS	S^#EXE$V_SYSPAGING,W^EXE$GL_DEFFLAGS,10$ ; SKIP IF PAGING
	EXTZV	#VA$V_VPN,#VA$S_VPN,W^MMG$GL_PGDCOD,R1	; GET START OF PAGED EXEC
	SUBL3	R1,R3,R1		; PAGE COUNT OF PAGED EXEC + XDELTA+INIT
	BRB	20$			; JOIN COMMON CODE
10$:	MOVZWL	#<<MMG$A_SYS_END-MMG$AL_PGDCODEN>@-9>,R1; COUNT OF XDELTA+INIT
20$:	MOVAL	@W^MMG$GL_SBR[R3],R3	; SVAPTE+4
30$:	BSBW	ALLOCPFN		; ALLOCATE A PHYSICAL PAGE
	BISL3	#<PTE$C_URKW!PTE$M_VALID>,R0,-(R3); MAP A VALID PAGE
	SOBGTR	R1,30$			; MAP ALL POTENTIALLY PAGED EXEC
MAPVECTORS:				;
	MOVL	#<<MMG$A_ENDVEC-^X80000000>@-9>,R1; START VPN+1
	MOVAL	@W^MMG$GL_SBR[R1],R3	; SVAPTE+4
10$:	BSBW	ALLOCPFN	;ALLOCATE A PAGE
	BISL3	#<PTE$C_URKW!PTE$M_VALID>,R0,-(R3); MAP A VALID PAGE
	SOBGTR	R1,10$		; MAP ALL VECTOR PAGES
;
;
;	SET MAP INFORMATION FOR BOOT DRIVER
;
INITBOOTDRV:				;
	MOVZWL	#<<MMG$A_SYS_END-^X80000000>@-9>,R9	; SET NUMBER OF PAGES
	MOVL	R9,BOO$GL_SPTFREL	; SAVE NEXT FREE SPT ENTRY
	MOVL	RPB$L_IOVEC(R11),R4	; GET POINTER TO I/O VECTOR
	PUSHL	R11			; ADDRESS OF RPB
	PUSHAL	@#MMG$A_SYS_END		; VA FOR I/O WINDOW
	PUSHL	W^MMG$GL_SBR		; PHYSICAL ADDRESS OF SPT
	CALLS	#3,@BQO$L_MAP(R4)[R4]	; CALL BOO$MAP
;
; Mapping information has now been provided to permit the bootstrap
; I/O driver to read the EXEC into non-contiguous physical pages.
;
; Assuming system paging is enabled (SYSPAGING = 1), the EXEC is read
; in two pieces.  The first contains all the resident code, the second
; contains XDELTA, INIT, and the BUGCHECK code.  The pages of BUGCHECK
; messages are not read in any longer, though they were in release 2.
; When SYSPAGING = 0, the entire system is read in (including the paged
; code) and in this case too, the read stops short of bringing in the
; BUGCHECK messages.  The BUGCHECK code is still required because the
; salutation put out by INIT uses the CONSOLIO code in BUGCHECK.  There
; may or may not be other needs for this code.
;
READ_SYS:
	MOVL	#<<<BUG$T_MESSAGES+511>&^C511>-^X80000000>,R9
					; NUMBER OF BYTES OF SYS TO READ
	MOVL	W^SYS_STAT+STAT_L_MAP,R4 ; VIRTUAL TO LOGICAL MAP
	MOVL	W^SYS_STAT+STAT_L_VBN,R3 ; STARTING VBN IN IMAGE
	ASHL	#VA$V_SYSTEM,#1,R6	; SET ADDRESS OF "BUFFER"
	BBC	S^#EXE$V_SYSPAGING,W^EXE$GL_DEFFLAGS,20$ ; SINGLE READ IF NOT PAGING
	SUBL3	#^X80000000,W^MMG$GL_PGDCOD,R9	; SET NUMBER OF BYTES
	BSBW	READ_VIRTUAL		; READ NONPAGED EXEC CODE
	BLBC	R0,READ_SYS_ERR		; BRANCH IF ERROR
	MOVAL	@#MMG$AL_PGDCODEN,R6	; SET NEW BUFFER ADDRESS
	MOVL	#<<<BUG$T_MESSAGES+511>&^C511>-MMG$AL_PGDCODEN>,R9
					; SET SIZE OF INIT
	ADDL3	W^SYS_STAT+STAT_L_VBN,-	; COMPUTE VBN FOR INIT
		#<<MMG$AL_PGDCODEN-^X80000000>@-9>,R3
20$:					;
	BSBW	READ_VIRTUAL		; READ EXEC IMAGE
	BLBS	R0,READ_DRIVERS		; BRANCH IF SUCCESSFULLY READ
;
; Error reading SYS.EXE - fatal
;
READ_SYS_ERR:
	MOVAL	W^BOO$GT_SYS,R1		; APPEND "SYS.EXE"
	BSBW	BOO$TYPE_ASCIC		; TO THE READ ERROR MESSAGE
	HALT				; ***** FATAL ERROR *****
;
; Read the drivers and other loadable pieces of code into their
; allocated slots in non-paged pool.
;
READ_DRIVERS:
	MOVAL	W^DSKDRV_STAT,R2	; SYSTEM DISK DRIVER STAT BLOCK
	MOVL	S^#LOAD_IMAGE_CNT,R5	; NO. OF LOAD IMAGES TO READ
10$:	BSBW	LOAD_CODE		; LOAD THIS IMAGE INTO POOL
	ADDL	#STAT_C_SIZE,R2		; ADDRESS OF NEXT STAT BLOCK
	SOBGTR	R5,10$			; LOAD NEXT IMAGE
;
; EXEC image has now been read. The correct copy of SYSPARAM
; information will now be moved into the system image.
;
MOVSYSPARAM:
	MOVL	#BOO$C_SYSPARSZ,R6	; Size of SYSPARAM in bytes
	MOVL	#MMG$A_SYSPARAM,R7	; Get System VA of SYSPARAM
	MOVAL	W^EXE$A_SYSPARAM,R1	; Address of SYSBOOT copy
	BSBW	MOVEMAPPED		; Move SYSBOOT copy into sys copy.
;
; Move the FIL$OPENFILE cache into its allocated place in non-paged pool.
; If this cache was allocated space in pool, but before it could be
; safely moved into pool, its pages were allocated and potentially
; written into, then we must disable the cache here.  To do that
; we clear the desriptor for the FIL$OPENFILE cache and
; tack on its size to the INILOA piece.  This is assumed to be allocated
; just before the FIL$OPENFILE cache and the size field of the INILOA 
; descriptor is only used for deallocating the INILOA piece after INIT
; has executed that portion of the initialization code.
;
MOVFILECACHE:
	MOVQ	W^BOO$GQ_FILCACHE,R6	; R6 = size, R7 = pool address
	BEQL	5$			; Branch if no cache enabled
	CMPL	W^BOO$GL_NEXTPFN,W^CACHE_HI_PFN ; Alloc over FIL$OPENFILE cache?
	BGEQ	2$			; Branch if not
	CLRQ	W^BOO$GQ_FILCACHE	; No FIL$OPENFILE cache
	ADDL	R6,W^BOO$GQ_INILOA+4	; Deallocate this with INILOA
	BRB	5$
2$:	CMPL	W^BOO$GL_NEXTPFN,-	; Alloc over the CI ucode?
		W^CI_HI_PFN
	BGEQ	3$			; Branch if not
	BRW	BUMP_CI			; Yes, fatal error

3$:	MOVL	W^FIL$GQ_CACHE+4,R1	; Physical location of cache
	BSBW	MOVEMAPPED		; Move the cache
;
; If a top level system directory is in use, move its name for INIT
;
5$:	TSTB	W^FIL$GT_TOPSYS		; Is there a TOPSYS directory?
	BEQL	10$			; Branch if not
	MOVC3	#10,W^FIL$GT_TOPSYS,W^BOO$GT_TOPSYS ; Yes, make a copy for INIT
10$:
;
; Move the Boot Control Block to its place in non-paged pool.  Finish
; initializing it and the system disk boot driver for use in INIT. 
; This boot control block contains retrieval pointer virtual to logical
; maps for SYS.EXE and SYSDUMP.DMP.  After moving the boot control block,
; the boot driver, and its associated microcode file - if any - , are
; moved adjacent to it.  The space allocated for the boot control block
; includes the space for the boot driver and the microcode.  This code
; moves the 3 pieces into one area of pool.  BOO$W_SIZE of the Boot
; Control Block contains the size without the boot driver.  BOODRV_STAT
; + STAT_L_BYTECNT contains the size with the boot driver and microcode.
;
MOVBOODRIVER:
	MOVL	W^BOOTCB,R1		; Physical adr of boot control block
	MOVL	W^BOO$GL_BOOTCB,R7	; Pool adr to put boot control block
	ADDL	R7,BOO$L_SYS_MAP(R1)	; Relocate adr of virtual to logical
	TSTL	BOO$L_DMP_SIZE(R1)	; If dump file is empty
	BEQL	5$			; then leave map address 0
	ADDL	R7,BOO$L_DMP_MAP(R1)	; maps for SYS and SYSDUMP
5$:	ADDL	R7,BOO$L_PARAM_MAP(R1)	; and for SYSPARAM
	ADDL	R7,BOO$L_BUG_MAP(R1)	; and for non-resident BUGCHECK
	MOVZWL	BOO$W_SIZE(R1),R6	; Size of BOOTCB not including boot driver
	MOVQ	W^UCODE_LEN,-(SP)	; Save room for ucode file
	PUSHAB	(R7)[R6]		; Save SYS virtual adr to put boot driver
	MOVL	W^BOODRV_STAT+STAT_L_BYTECNT,R0 ; Size of BOOTCB + boot driver
	MOVW	R0,BOO$W_SIZE(R1)	; Set size of BOOTCB+driver+ucode
	SUBL2	W^UCODE_LEN,R0		; Size of driver+BOOTCB
	SUBL3	R6,R0,-(SP)		; Save size of boot driver to move
	ADDL3	(SP),4(SP),12(SP)	; Set sys virtual adr of ucode
	BSBW	MOVEMAPPED		; Move BOOTCB to pool
	MOVQ	(SP)+,R6		; R6 = Size of boot driver to move
					; R7 = SYS virtual adr to put it
	MOVL	RPB$L_IOVEC(R11),R1	; Physical address of boot driver
	MOVL	R7,RPB$L_IOVEC(R11)	; Set new SYS virtual adr of boot driver
	MOVL	R7,R8			; Save it away for later
	BSBW	MOVEMAPPED		; Move the boot driver adjacent to BOOTCB
	MOVL	W^MMG$GL_SPTBASE,-	; Set SPT virtual address as
		RPB$L_SVASPT(R11)	;  adr of SYS page table for BOOTDRIVR
	MOVQ	(SP)+,R6		; R6 = Size of ucode to move
					; R7 = SYS virtual adr to put it
	MOVL	W^UCODE_ADR,R1		; Physical address of ucode
	BEQL	10$			; There isn't any
	MOVL	R7,W^BOO$GL_UCODE	; Stuff the virtual adr away
	BSBW	MOVEMAPPED		; Move the ucode adjacent to boot driver
	CMPW	W^VMB_VERSION,#8	; If the version is >= 8
	BLSSU	10$			;  then update the cell
	MOVAL	W^BOO$GL_UCODE,R1	; Pick up physical addr of cell w/VA
	MOVL	#4,R6			; 4 bytes to move
	MOVAL	BQO$L_UCODE(R8),R7	; VA of where to stick it
	BSBW	MOVEMAPPED		; Move the VA
10$:
;
; Move the copy of BOOPARAM that SYSBOOT has filled with data 
; into INIT's copy of BOOPARAM.
;
MOVBOOPARAM:
	MOVL	#BOO$C_BOOPARSZ,R6	; Size of BOOPARAM in bytes
	MOVL	#EXE$A_BOOPARAM,R7	; Get System VA of BOOPARAM
	MOVAL	W^BOO$A_BOOPARAM,R1	; Address of SYSBOOT copy
	BSBW	MOVEMAPPED		; Move SYSBOOT copy into SYS copy.
;
; Now locate INIT and transfer control to it
;
	MOVL	#<<EXE$INIT-^X80000000>@-9>,R3	; VPN OF INIT
	MOVL	@W^MMG$GL_SBR[R3],R0	; GET PHYSICAL PAGE NUMBER
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R3 ; ISOLATE PFN AND SAVE IN R3
	ASHL	#9,R3,R0		; CONVERT TO PHYS ADDRESS
	MOVL	#EXE$INIT,R1		; VIRTUAL ADDRESS OF INIT
	INSV	R1,#0,#9,R0		; INSERT BYTE OFFSET TO GET PHYSICAL
	MTPR	W^MMG$GL_SBR,#PR$_SBR	; SET SYSTEM BASE REGISTER
	MTPR	W^MMG$GL_SPTLEN,#PR$_SLR; AND LENGTH REGISTER
	ADDL	#2,R3			; P0 LENGTH=PFN+1+1
	MTPR	R3,#PR$_P0LR		; SET P0 LENGTH TO PFN OF EXE$INIT
	SUBL3	R0,#<EXE$INIT-^X80000000>,R2	; DELTA PFN-VPN
	ASHL	#-9,R2,R2		; CONVERT TO PAGE COUNT
	MOVAL	@W^MMG$GL_SPTBASE[R2],R1; COMPUTE BASE FOR P0 PT
	MTPR	R1,#PR$_P0BR		; AND SET AS BASE REGISTER
	INVALID				; INVALIDATE TRANSLATION BUFFER
	JMP	(R0)			; TRANSFER TO INIT
;
;	R0 = PHYSICAL ADDRESS OF EXE$INIT
;	R1 = ** UNDEFINED **
;	R2 = ** UNDEFINED **
;	R3 = ** UNDEFINED **
;	R4 = ** UNDEFINED **
;	R5 = ** UNDEFINED **
;	R6 = ** UNDEFINED **
;	R7 = ** UNDEFINED **
;	R8 = ** UNDEFINED **
;	R9 = ** UNDEFINED **
;	R10 = ** UNDEFINED **
;	R11 = PHYSICAL ADDRESS OF RESTART PARAMETER BLOCK (RPB)
;	AP = ** UNDEFINED **
;	FP = ** UNDEFINED **
;	SP = PHYSICAL ADDRESS OF A 3 PAGE STACK
;	PR$_SBR/PR$_SLR - SET TO DESCRIBE SPT
;	PR$_P0BR/PR$_P0LR - SET TO MAP EXE$INIT VIRTUAL = REAL
;

	.SBTTL	ADD MEMORY DESCRIPTORS TO RPB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS EXECUTED OR NOT DEPENDING UPON WHAT VERSION OF
;	VMB BUILT THE RESTART PARAMETER BLOCK.  VERSION 1 AND 2 OF VMB
;	DO NOT INCLUDE THE PAGE COUNT, TR NUMBER, AND BASE PFN TO DESCRIBE
;	EACH MEMORY ON THE SYSTEM.  VERSION 3 AND SUBSEQUENT VERSIONS INCLUDE
;	THIS INFORMATION.  THIS INFORMATION IS USED BY BUG CHECK IN DUMPING
;	MEMORY TO THE SYSTEM DUMP FILE.  THIS ROUTINE ADDS A MEMORY
;	DESCRIPTOR TO THE RPB.  THIS DESCRIPTOR IS BUILT USING THE
;	ASSUMPTIONS THAT PRE-RELEASE 2.0 BUG CHECKS USED, I.E., THAT
;	MEMORY STARTS AT PFN 0 AND IS BOUNDED AT THE OTHER END BY THE
;	SYSTEM PAGE TABLE.
;
; CALLING SEQUENCE:
;
;	BSBW	ADD_RPB_MEMDSC
;
; INPUT PARAMETERS:
;
;	R11 - ADR OF REBOOT PARAMETER BLOCK
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	PR$_SBR AND PR$SLR ARE USED TO DETERMINE THE SIZE OF MEMORY.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	A MEMORY DESCRIPTOR IS ADDED TO THE RPB IF ONE IS NOT INCLUDED.
;--

ADD_RPB_MEMDSC:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAB	RPB$L_MEMDSC(R11),R4	; GET ADR OF FIRST MEMORY DESCRIPTOR
	MFPR	#PR$_SBR,R3		; GET PHYSICAL ADR OF SYS PAGE TBL
	MFPR	#PR$_SLR,R2		; GET LENGTH OF SPT IN BYTES
	MOVAL	(R3)[R2],R2		; GET # OF BYTES OF MEMORY TOTAL
	ASHL	#-9,R2,(R4)+		; SET # OF PAGES (NO TR #) INTO MEMDSC
	MOVC5	#0,(R11),#0, -		; SET THE BASE PFN TO 0 AND FILL THE
		#<<RPB$C_LENGTH-RPB$L_MEMDSC>-4>,(R4) ; OTHER MEMDSC'S WITH 0'S
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				;
	.PAGE
	.SBTTL	IMAGE_OPEN - Look up image file
;
; Input parameters:
;	R2		= Statistics block for file to open
;	STAT_L_NAME(R2)	= base relative adr of ASCIC file name
;
; Output parameters:
;	R0 = Status
;	R1 = Address of file header buffer
;	R7,R8,R9 altered
;	R2-R5 preserved
;	STAT_L_MAP(R2)	   = Data to map virtual block to logical block
;	STAT_L_BYTECNT(R2) = Size of file in bytes
;
IMAGE_OPEN:
	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Address of ASCIC name string
	MOVZBL	(R1)+,R0		; R0 = size, R1 = address
	MOVQ	R0,-(SP)		; Save file name descriptor
	MOVL	SP,R7			; Address of file name descriptor
	MOVAL	W^RTRV_BUF_DSC,R9	; Address of rtrv ptr buffer descriptor
	MOVQ	(R9),R0			; R0 = size, R1 = address of buffer
	CMPL	R0,#3*4			; At least 3 long words required
					; to express a contiguous file
	BLSS	110$			; Branch if out of space, fatal
	MOVAL	(R1)+,R8		; R8 = loc to store byte count returned
					; R1 = R1 + 4
	MNEGL	#4,(R8)			; Init count returned for error path
	SUBL	#4,R0			; Account for byte count long word
	MOVQ	R0,(R9)			; Size and address of buffer
					; to store retrieval pointers in
	BSBW	FILOPEN			; Call FIL$OPENFILE
	ADDL	#8,SP			; Clean off name descriptor
	SUBL	(R8),(R9)+		; Allocate retrieval pointers used
	BLSS	110$			; Branch if not enough space
	ADDL	(R8),(R9)		; Update next available address
	BLBC	R0,20$			; Leave bytecnt 0 if error
	ASHL	#9,W^BOO$GQ_STATBLK+4,STAT_L_BYTECNT(R2) ; Size of file in bytes
	MOVL	R8,STAT_L_MAP(R2)	; Save adr of virtual to logical map
20$:	RSB				; Otherwise return with status in R0
;
; Not enough space for retrieval pointers, the boot time files were
; far more fragmented than was planned for.  Only SYS.EXE is big
; enough to cause such a problem.  All the drivers are so small that
; a few pointers each is adequate.
;
110$:	MSG	<-F-Boot time files have too many non-contiguous pieces>
	HALT				; ***** Fatal error *****
	.PAGE
	.SBTTL	IMAGE_INIT - Look up and start read of image file
;
; Input parameters:
;	R2		= Statistics block for file to open
;	STAT_L_NAME(R2)	= base relative adr of ASCIC file name
;
; Output parameters:
;	Returns to caller only if successful.
;	On error, prints diagnostic and halts
;	R0,R1,R3,R4,R7,R8,R9 altered
;	R2,R5 preserved
;	R6		= Adr of first block read in past image header
;	STAT_L_MAP(R2)	= Data to map virtual block to logical block
;	STAT_L_VBN(R2)	= Starting VBN in image after image header block(s)
;	STAT_L_VBN2ADR(R2) = Address of 1st block after image header block(s)
;
IMAGE_INIT:
	BSBW	IMAGE_OPEN		; Open the file
	BLBC	R0,90$			; Branch if failed to find file
;
; Read 2 blocks on the assumption that the image header will only take
; up the first block.  This is essentially always correct.
;
	ADDL3	W^VBN2_BUF_DSC,W^VBN2_BUF_DSC+4,R6 ; Adr of last+1 byte of
					; block buffer for reading and saving
					; the 1st block after image header
	MOVAB	-1024(R6),R6		; Back off 2 pages, first is image
					; header, 2nd is first block after
	SUBL	#512,W^VBN2_BUF_DSC	; Record another page used
	ROTL	#9,#2,R9		; Set to read 2 VBN's
	MOVL	#1,R3			; Starting with VBN 1
	MOVL	STAT_L_MAP(R2),R4	; Adr of virtual to logical map
	BSBW	READ_VIRTUAL		; Read the desired VBN's
	BLBC	R0,100$			; Branch if read error
	MOVZBL	IHD$B_HDRBLKCNT(R6),R3	; Get # header blks
	INCL	R3			; Starting VBN of image
	MOVL	R3,STAT_L_VBN(R2)	; Save for reading image later
	MOVAB	512(R6),R6		; Address of VBN 2
	CMPL	R3,#2			; One image header block?
	BEQL	20$			; Branch if yes, the norm
;
; Lost a good bet, now read one block after the image header blocks
;
	ROTL	#9,#1,R9		; Set up to read one block
	BSBW	READ_VIRTUAL		; Read the desired VBN
	BLBC	R0,100$			; Branch if read error
20$:	MOVL	R6,STAT_L_VBN2ADR(R2)	; Note where VBN2 was read
	RSB
;
; Failed to open file
;
90$:	MSG	<-E-Unable to locate file >
;
; Error opening or reading the file, error message already given,
; add on the file name to complete the diagnostic
;
100$:	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Address of ASCIC file name
	BSBW	BOO$TYPE_ASCIC		; Type the name
	HALT				; ***** Fatal Error *****
	.PAGE
	.SBTTL	BOO$FILOPEN - Lookup a specified file
;
; Input Parameters:
;	R7 - Address of file name descriptor
;
; Output Parameters:
;	R0 - Status, if error, message (without file name) already typed
;	R8 - Starting LBN of file
;	R9 - Size of file in blocks
;
BOO$FILOPEN::				; File open Routine
	CLRQ	R8			; No retrieval pointer info needed
	BSBB	FILOPEN			; Call FIL$OPENFILE
	BLBS	R0,10$			; Branch if successful
	MSG	<-E-Unable to locate file > ; Report the failure
	BRB	20$
10$:	MOVQ	W^BOO$GQ_STATBLK,R8	; Get file statistics, LBN/Size in blocks
	TSTL	R8			; Check for contiguous
	BNEQ	30$			; Yes, continue
	MSG	<-E-File not contiguous > ; Give error
20$:	CLRL	R0			; Indicate error
30$:	RSB				; Return to caller
;
; Inputs:
;	R7 - Address of file name descriptor
;	R8 - Address to return byte of retrieval pointer data stored
;	     0 if not used
;	R9 - Address of descriptor of retrieval pointer buffer
;	     0 if not used
;
; Outputs:
;	R0 - Status
;	R1 - Address of file header buffer
;	All other registers preserved
;	BOO$GQ_STATBLK     = Starting LBN if contiguous, 0 if not
;	BOO$GQ_STATBLK + 4 = Size of file in blocks
;
FILOPEN:
	MOVAL	-(SP),R0		; Save pointer to phony channel
	MOVQ	R8,-(SP)		; Push adr of rtrv buf descriptor
					; Push adr to return byte count stored
	PUSHAQ	W^BOO$GQ_STATBLK	; Address of file statistics block
	PUSHL	W^BOO$GL_FREEMEM	; file header buffer
	ADDL3	#512,(SP),-(SP)		; Index file header buffer
	PUSHAL	(R7)			; Address of file name descriptor
	PUSHAL	(R0)			; Address of phony channel
	CALLS	#7,W^FIL$OPENFILE	; Call FILEREAD to locate file
	MOVL	W^BOO$GL_FREEMEM,R1	; Return address of file header
	ADDL2	#4,SP			; Clean off phony channel
	RSB				;  and return
	.PAGE
	.SBTTL	ALLOCPFN - Allocate physical page
;
; Output parameters:
;	R0 - PFN of allocated page
;
ALLOCPFN:				;
	MOVL	W^BOO$GL_NEXTPFN,R0	; Get PFN to start scan
	BNEQ	20$			; Branch if not null
10$:	ASHL	#3,RPB$Q_PFNMAP(R11),R0	; Else start at end of map
15$:	DECL	R0			; Next/first PFN
	BLEQ	30$			; Branch if none left
20$:	BBCC	R0,@RPB$Q_PFNMAP+4(R11),15$	; Allocate it if possible
	SUBL3	#1,R0,W^BOO$GL_NEXTPFN	; Save pointer for next time
	DECL	RPB$L_PFNCNT(R11)	; Account for page removed
	RSB				;  and return
30$:	MSG	<-F-Unable to allocate physical memory>
	HALT				; **** FATAL ERROR ****
;
; Functional Description:
;	DALLOCPFN marks the specified page available in the PFN bitmap
;	but does not reposition the scan pointer.
;
; Calling Sequence:
;	BSBW	DALLOCPFN
; Input Parameters:
;	R0 - PFN
;
DALLOCPFN:				; Deallocate pfn
	BBSS	R0,@RPB$Q_PFNMAP+4(R11),10$	; Mark it available
10$:	RSB				; And return
	.PAGE
	.SBTTL	LOAD_CODE - load the code from the specified file

;++
; Functional Description:
;	Given a statistics block for a file, load the file into pool
;	The first block after the image header was previously read
;	in to determine the size of the image.  This buffer was
;	saved to avoid reading it again.  Move this page and
;	read the rest.
;
; Inputs:
;	STAT_L_VBN2ADR(R2) = Address of 1st block after image header
;			     It was already read in, just move this page
;	STAT_L_VBN(R2)	   = Starting virtual block number to read
;	STAT_L_BYTECNT(R2) = Number of bytes in image
;	STAT_L_MAP(R2)	   = Mapping information to map VBN to LBN
;	STAT_L_SYSVA(R2)   = Base relative address of pool address
;	STAT_L_NAME(R2)	   = Base relative address of name for error msg
;
; Outputs:
;	Returns in line only if successful
;	Types diagnostic and halts if error
;	R0,R1,R3,R4,R6,R9 altered
;	All other registers preserved
;--

LOAD_CODE:
	PUSHL	R7
	MOVL	STAT_L_VBN2ADR(R2),R1	; Adr of 1st block after image hdr
	ADDL3	W^SYSBOOT_BASE,STAT_L_SYSVA(R2),R7 ; Adr of pool adr for image
	MOVL	(R7),R7			; Adr in pool to move 1st page of image
	PUSHAB	512(R7)			; Adr in pool to read into
	ROTL	#9,#1,R6		; Move 1 page or less
	CMPL	R6,STAT_L_BYTECNT(R2)	; Image less than a page?
	BLEQ	10$			; Branch if not
	MOVL	STAT_L_BYTECNT(R2),R6	; Yes, use the image size
10$:	SUBL3	R6,STAT_L_BYTECNT(R2),R9 ; Byte count left to be read
	PUSHR	#^M<R2,R4,R5>
	BSBW	MOVEMAPPED		; Move the 1st image block after the
					; image hdr, avoid reading it again
	POPR	#^M<R2,R4,R5,R6,R7>	; R6 = Adr to read into
	ADDL3	#1,STAT_L_VBN(R2),R3	; Starting VBN to read
	TSTL	R9			; Anything left to read?
	BGTR	20$			; Branch if yes
	RSB				; Move was all that was needed
20$:	MOVL	STAT_L_MAP(R2),R4	; Adr of virtual to logical map
	BSBB	READ_VIRTUAL		; Read the specified VBN's
	BLBC	R0,30$			; Branch if failed to read them
	RSB
30$:	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Adr of ASCIC file name
	BSBW	BOO$TYPE_ASCIC		; Append the file name to error msg
	HALT				; ***** Fatal Error *****
	.PAGE
	.SBTTL	BOO$SETMAP - Set up Virtual to Logical Map
;++
; Functional Description:
;	This routine produces a virtual to logical map for a specified
;	virtual segment of a file.  Give a desired virtual block and
;	block count and a map of the file, it produces a new map for 
;	just that segment.
;
; Calling Sequence:
;	BSBW	BOO$SETMAP
;
; Inputs:
;	R3 = Desired VBN
;	R4 = Virtual to logical map
;	R5 = Desired number of blocks to map
;	R6 = Size in bytes of region to store the map being created
;	R7 = Address of region to store the map being created
;
; Outputs:
;	R0,R1,R2,R3,R5 altered
;	R4 preserved
;	R6,R7 updated to reflect space used
;	others preserved
;--
BOO$SETMAP:
	PUSHL	R4			; Save input map
	PUSHAL	(R7)+			; Save Adr of output byte count
					; R7 points to first rtrv ptr to store
	BSBB	BOO$MAPVBN		; Find starting LBN
	TSTL	R0			; If EOF, then done
	BEQL	60$
20$:	CMPL	R0,R5			; More block mapped than needed?
	BLEQ	40$			; Branch if not
	MOVL	R5,R0			; Yes, just use what is needed
40$:	MOVQ	R0,(R7)+		; Store this retrieval pointer
	SUBL	R0,R5			; Count blocks mapped
	BLEQ	60$			; Branch if all done
	MOVQ	(R4)+,R0		; Get next retrieval pointer
	SOBGTR	R2,20$			; If there are any more
60$:	POPR	#^M<R2,R4>		; R2 = Adr of byte count field
					; R4 = saved input map
	SUBL3	R2,R7,R0		; No. of bytes used
	SUBL	R0,R6			; Adjust size of buffer remaining
	SUBL3	#4,R0,(R2)		; No. of bytes of retrieval pointers
	RSB
	.PAGE
	.SBTTL	BOO$MAPVBN - Map Virtual to Logical Block
;++
; Functional Description:
;	Map the specified virtual block to its associated logical block
;
; Calling Sequence:
;	BSBW	BOO$MAPVBN
;
; Inputs:
;	R3 = Virtual Block Number
;	R4 = Address of virtual to logical map
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;
; Outputs:
;	R0 = Number of contiguous blocks starting at LBN in R1
;	R1 = Starting LBN for the specified VBN
;	R2 = number of retrieval pointers (quad words) not yet used in the map
;	R3 = VBN preserved
;	R4 = pointer to first retrieval pointer not yet used in map
;	all other registers preserved
;--
BOO$MAPVBN:
	PUSHL	R3			; Save desired VBN
	ASHL	#-3,(R4)+,R2		; Get count of quad words
					; Point at first retrieval pointer
10$:	MOVQ	(R4)+,R0		; R0 = block count, R1 = LBN
	CMPL	R3,R0			; Desired VBN in this rtrv ptr?
	BLEQ	20$			; Branch if yes
	SUBL	R0,R3			; Pass over that many VBN's
	SOBGTR	R2,10$			; Try the next retrieval pointer
	CLRQ	R0			; EOF, no blocks mapped
	BRB	30$
20$:	DECL	R3			; Make VBN base 0
	SUBL	R3,R0			; No. of blocks left
	ADDL	R3,R1			; Starting LBN for desired VBN
30$:	POPR	#^M<R3>			; Recover desired VBN
	RSB
	.PAGE
	.SBTTL	BOO$READFILE - Routine to read specified piece of file
;++
; Functional Description:
;	BOO$READFILE reads the specified piece of the file
;
; Calling Sequence:
;	BSBW	BOO$READFILE
;
; Inputs:
;	R6 - Buffer address (updated)
;	R8 - Logical block number (updated)
;	R9 - Blocks in file (updated)
;
; Outputs:
;	R0 - Status, diagnostic issued (without file name) if error
;	R1,R6-R9 altered
;	R2-R5 preserved
;--
BOO$READFILE::				;
	MOVQ	R10,-(SP)		; Save additional registers
	MOVZWL	#IO$_READLBLK,R10	; Read function
	MOVL	W^BOO$GL_RPBBASE,R11	; RPB address
	ASHL	#9,R9,R9		; Form byte count to transfer
	BSBW	QIO_RWLB		; Read the specified blocks
	ASHL	#-9,R9,R9		; Pages not transferred
	MOVQ	(SP)+,R10		; Restore additional registers
	BRB	READ_COMPLETE		; Use common exit path
	.PAGE
	.SBTTL	READ_VIRTUAL - Read specified virtual blocks of a file
;++
; Functional Description:
;	This routine maps the specified virtual blocks to logical blocks
;	and reads the desired number of bytes into the specified location
;	in memory.
;
; Inputs:
;	R3 = Virtual Block Number
;	R4 = Mapping info for virtual to logical mapping:
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;	R6 = Buffer Address to read into
;	     if system bit is set, then the system map is used
;	R9 = Byte count to read (quad word aligned)
;
; Outputs:
;	R0 = Status, diagnostic issued if error (without file name)
;	R1 altered
;	All other registers preserved
;
;--

READ_VIRTUAL:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	W^BOO$GL_RPBBASE,R11	; Address of RPB
	MOVZWL	#IO$_READLBLK,R10	; Read logical block function
	BSBB	BOO$MAPVBN		; Convert starting VBN to LBN
	TSTL	R0			; End of file?
	BNEQ	40$			; Branch if not
	BRB	60$			; Yes, report the error
30$:	MOVQ	(R4)+,R0		; Get the next rtrv ptr
;
; R0 = number of blocks that can be read in this portion
; R1 = starting LBN to read from
;
40$:	PUSHL	R9			; Save desired byte count
	ASHL	#9,R0,R0		; # of bytes that can be read
	CMPL	R9,R0			; If fewer are needed
	BLEQ	50$			; Then read the smaller number
	MOVL	R0,R9			; Otherwise read all we can
50$:	SUBL	R9,(SP)			; Note how much is left to be read
	MOVL	R1,R8			; Starting LBN of read request
	BSBB	QIO_RWLB		; Read or write the file
	MOVL	(SP)+,R9		; Recover byte left to be read
	BLEQ	90$			; Branch if all done
	BLBC	R0,90$			; Branch if read error
	SOBGTR	R2,30$			; Get the next retrieval pointer
60$:	MOVZWL	#SS$_ENDOFFILE,R0	; Indicate EOF error
90$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; R0 = status from read
;
READ_COMPLETE:
	BLBS	R0,30$			; Branch if read successful
	CMPW	#SS$_ENDOFFILE,R0	; If it is an EOF error
	BNEQ	10$
	MSG	<-E-End of file error reading > ; Report EOF error
	BRB	20$
10$:	MSG	<-E-I/O error reading file > ; Otherwise catchall error
20$:	CLRL	R0			; Indicate error occurred
30$:	RSB
	.PAGE
	.SBTTL	QIO_RWLB - Read or Write Logical Block
;++
; Functional Description:
;	This routine reads/writes the specified logical block numbers
;	from/to the boot disk.
;
; Calling Sequence:
;	BSBW	QIO_RWLB
;
; Inputs:
;	R6  = Buffer address (updated)
;	R8  = Logical block number (updated)
;	R9  = Byte count to transfer (up to 31 bits)
;	R10 = #IO$_READLBLK or #IO$_WRITELBLK
;	R11 = RPB address
; Outputs:
;	R0 = Status
;	R1,R6-R9 altered
;	All other registers preserved
;--
QIO_RWLB:
10$:	MOVZWL	#IOSIZE*512,R7		; Assume maximum transfer
	CMPL	R7,R9			; Minimize with file size
	BLEQ	20$			; Smaller than remaining file size
	MOVL	R9,R7			; Set to remaining file size
20$:	PUSHL	R11			; Base of RPB
	EXTZV	#VA$V_SYSTEM,#1,R6,-(SP) ; Set mode to virtual if system space
	PUSHR	#^M<R6,R7,R8,R10>	; R/W, LBN, size in bytes, buffer adr
	MOVL	RPB$L_IOVEC(R11),R0	; GET POINTER TO I/O VECTOR
	CALLS	#6,@BQO$L_QIO(R0)[R0]	; Perform read
;
; R0 = status of transfer, if successful, see if there is any more to do.
;
	BLBC	R0,30$			; Branch if error
	ASHL	#-9,R7,R1		; Block count
	ADDL	R1,R8			; Starting LBN for next piece
	ADDL	R7,R6			; Starting Buf Adr for next piece
	SUBL	R7,R9			; Count bytes tranferred
	BGTR	10$			; Branch if another transfer to do
30$:	RSB
	.PAGE
	.SBTTL	BOO$USEFILE - Use parameter file
;++
; Functional description:
;	BOO$USEFILE reads the specified file in response to the USE
;	command and merges all of the values specified in that file into
;	the working copy of the parameter values.  This is accomplished
;	by looking up each value specified and merging the associated 
;	value.
;
; Calling sequence:
;	CALLG	arglist,BOO$USEFILE
;
; Input Parameters:
;	TPA$L_TOKENCNT(AP) - Length of file name string
;	TPA$L_TOKENPTR(AP) - Address fo file name string
; Output Parameters:
;	R0 - Completion status code
;
;--
BOO$USEFILE::				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>	; Entry mask
	MOVAB	TPA$L_TOKENCNT(AP),R7	; Set address of file name descriptor
	BSBW	BOO$FILOPEN		; Open specified file
	BLBS	R0,20$			; Continue if success
10$:	MOVZWL	#1,R0			; Force success
	RET				;
20$:	MOVL	W^BOO$GL_FREEMEM,R6	; Set address of parameter buffer
	BSBW	BOO$READFILE		; Read file content into parameter buffer
	BLBC	R0,10$			; Exit if error
	ADDL3	#32,W^BOO$GL_FREEMEM,R8	; Init pointer to parameter buffer
	MOVC3	#32,@W^BOO$GL_FREEMEM,EXE$GT_STARTUP	; Set name of startup file
	CLRL	W^VALID_PAR_FILE	; Initialize valid parameter file flag
30$:	TSTL	(R8)			; Check for end of list
	BEQL	DONE			; Branch if yes
	MOVZBL	(R8),TPA$L_TOKENCNT(AP)	; Set token count for search
	MOVAB	1(R8),TPA$L_TOKENPTR(AP); And address of string
	ADDL	#16,R8			; Advance to value
	MOVL	(R8)+,TPA$L_NUMBER(AP)	; Set number 
	CALLG	(AP),W^BOO$SEARCH	; Search for parameter
	BLBC	R0,30$			; Next parameter if not found
	MOVL	#1,W^VALID_PAR_FILE	; Indicate valid parameter file
	CALLG	(AP),W^BOO$SETVALUE	; Set value of parameter
	BRW	30$			; Continue with next parameter
DONE:	BLBS	W^VALID_PAR_FILE,10$	; If LBS, valid parameter file
	MSG	<-E-Not a parameter file>
10$:	MOVZWL	#1,R0			; Return success
	RET				;

	.SBTTL	GETCONLOC - Routine to read console information location
;++
; Functional Description:
;	GETCONLOC is used to access the locations in console memory containing
;	values such as WCS and FPLA version numbers.
;
; Input Parameters:
;	R1 - Location code
;
; Output Parameters:
;	R0 - Value contained in console cell
;--
GETCONLOC:				;
	MOVAB	^X300(R1),R1		; Set code to read console memory
10$:	MFPR	#PR$_TXCS,R0		; Get transmit status register
	BBC	#7,R0,10$		; Wait for done
	MTPR	R1,#PR$_TXDB		; Request data from console
20$:	MFPR	#PR$_TXCS,R0		; Read transmit status register
	BBC	#7,R0,20$		; Wait for done
30$:	MFPR	#PR$_RXCS,R0		; Get receiver status
	BBC	#7,R0,30$		; And wait for done
	MFPR	#PR$_RXDB,R0		; Now read data value
	CMPZV	#8,#4,R0,#3		; Is this a valid response?
;	BNEQ	10$			; No, try again
	NOP				;****** TEMP
	NOP				;****** TEMP
	MOVZBL	R0,R0			; Zero extend data
	RSB				;
VERSVECT:				; Vector of version offsets
	.BYTE	FPLA_VLOC		; FPLA Version offset
	.BYTE	PCS_VLOC		; PCS Version offset
	.BYTE	WCSS_VLOC		; WCS Secondary version offset
	.BYTE	WCSP_VLOC		; WCS Primary version offset
VERSVECLEN=.-VERSVECT
	.BYTE	0			; End of list
VERSNUM:				; Vector of required version numbers
	.BYTE	FPLA			; FPLA minimum
	.BYTE	PCS			; PCS minimum
	.BYTE	WCSS			; WCS Secondary minimum
	.BYTE	WCSP			; WCS Primary minimum
	.PAGE
	.SBTTL	MOVEMAPPED - MOVE FROM PHYSICAL TO MAPPED MEMORY
;++
; Functional Description:
;	MOVEMAPPED moves the specified number of bytes from the
;	given physical address to a specified system virtual address
;
;	R1 = physical address to move data from
;	R6 = number of bytes to move
;	R7 = system virtual address to move them to
;
; Output Parameters:
;	R0 - R7 altered
;
;--
MOVEMAPPED:
	MOVQ	R8,-(SP)
	EXTZV	#VA$V_BYTE,#VA$S_BYTE,R7,R8 ; STARTING BYTE OFFSET
	EXTZV	#VA$V_VPN,#VA$S_VPN,R7,R7 ; GET VIRTUAL PAGE NUMBER
	MOVAL	@MMG$GL_SBR[R7],R7	; GET SPT ENTRY ADDRESS
	CLRL	R0			; BACKGROUND THIS FOR INSV IN LOOP
					; MOVC WILL ZERO IT EACH TIME
	BRB	20$
10$:	CLRL	R8			; NO BYTE OFFSET
20$:	INSV	(R7)+,#VA$V_VPN,#PTE$S_PFN,R0 ; DESTINATION PAGE ADDRESS
	SUBL3	R8,#512,R9		; NO. OF BYTES TO MOVE
	CMPL	R9,R6			; DON'T MOVE MORE THAN IS LEFT
	BLEQ	30$			; BRANCH IF MORE TO DO
	MOVL	R6,R9			; OTHERWISE USE WHAT IS LEFT
30$:	MOVC3	R9,(R1),(R0)[R8]	; MOVE THE NEXT PIECE
	SUBL	R9,R6			; COUNT BYTES MOVED
	BGTR	10$			; BRANCH IF MORE TO MOVE
	MOVQ	(SP)+,R8		; RESTORE SAVED REGISTERS
	RSB				; OTHERWISE RETURN
	.PAGE
	.SBTTL	ALLOC_POOL - Allocate Pool From the top
;++
; Functional Description:
;	This routine allocates the requested amount of pool from
;	the current top of non-paged pool and returns its address
;
; Calling Sequence:
;	BSBW	ALLOC_POOL
;
; Inputs:
;	R0		   = Address of remaining size of pool
;	STAT_L_BYTECNT(R2) = Number of bytes to allocate
;	STAT_L_SYSVA(R2)   = Base relative address of location to 
;			     store allocated address
;	STAT_L_NAME(R2)    = Base relative adr of ASCIC name of file for error msg
;
; Outputs:
;	R0,R2 preserved
;	R1 = rounded up byte count allocated
;	STAT_L_BYTECNT(R2) = rounded up byte count allocated
;	Returns to caller only if pool is successfully allocated
;	If there is not enough room a diagnostic is issued
;	and a HALT is executed.
;--

ALLOC_POOL:
	ADDL3	#^XF,STAT_L_BYTECNT(R2),R1 ; Round desired size up
	BICL	#^XF,R1			; to quad boundary
	BEQL	10$			; None needed
	MOVL	R1,STAT_L_BYTECNT(R2)	; Save allocated size
	SUBL	R1,(R0)			; Allocate the pool
	BLSS	20$			; Branch if no pool left
	ADDL3	W^SYSBOOT_BASE,STAT_L_SYSVA(R2),-(SP) ; Adr to store pool adr
	ADDL3	(R0),W^MMG$GL_NPAGEDYN,@(SP)+ ; Set adr allocated
10$:	RSB

20$:	MSG	<-F-Not enough non-paged pool to map >
	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Adr of file name (ASCIC)
	BSBW	BOO$TYPE_ASCIC		; Type the name
	HALT				; ***** Fatal Error *****
	.PAGE
	.SBTTL	BOO$FACMSG - Output facility error message
;++
; Functional Description:
;	BOO$FACMSG outputs an error message preceded by a new line
;	and facility name string.
;
; Calling Sequence:
;	BSBW	BOO$FACMSG
;	.ASCIZ	message-text
;++
BOO$FACMSG::				;
	BSBW	BOO$MSGOUT		; Output prefix message
	.ASCII	<CR><LF>		; With a new line first
	.ASCIZ	/%SYSBOOT/		; Then facility name
	BRW	BOO$MSGOUT		; And finally the meat of the message

	.PAGE
	.SBTTL	BOO$TYPE_ASCIC - Type a counted ASCII string
;++
; Functional Description:
;	This routine accepts a string descriptor and types the message
;	on the console terminal
;
; Calling Sequence:
;	BSBW	BOO$TYPE_ASCIC
;
; Inputs:
;	R1 = Address of ASCIC string
;
; Outputs:
;	R0,R1 altered
;	All other registers preserved
;--

BOO$TYPE_ASCIC:
	MOVZBL	(R1)+,R0		; R0 = Size, R1 = Address of string
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	W^BOO$GL_FREEMEM,R3	; Address of scratch storage
	CLRQ	-(SP)			; No read for PROMPTREAD call
	PUSHL	R3			; Address of ASCIZ string
	MOVC3	R0,(R1),(R3)		; Move the string to scratch storage
	CLRB	(R3)+			; and make it ASCIZ
	CALLS	#3,W^BOO$READPROMPT	; Type the string
	POPR	#^M<R2,R3,R4,R5>	; Recover saved registers
	RSB
	.PAGE
	.SBTTL	Unexpected Machine Check Handler
;
;	Unexpected Machine Check Handler
;
	.ALIGN	LONG			; Exception handlers must be longword aligned
	.IF	DF,DEBUG		;
EXE$ACVIOLAT::				; Access violation vector 
EXE$BREAK::				; Breakpoint vector
EXE$ROPRAND::				; Reserved operand vector
EXE$TBIT::				; TBIT vector
MMG$PAGEFAULT::				; Pagefault exception vector
	.ENDC				;
BOOT_FAULT:				;
	MSG	<-F-Unexpected Exception>; Output error message

	.ALIGN	LONG			;
UNEXP_MCHK:				;
	MSG	<-F-Unexpected Machine Check>; Output error message

	.IF	DF,DEBUG		;
INI$RDONLY::				; Dummy change protection routines
INI$WRITABLE::				;
	RSB				;
EXE$GL_FLAGS::				; Dummy
XDS$GT_WORD_PFN::
	.LONG	0			;
	.ENDC				;
	.PAGE
	.SBTTL	PROMPT - Routine to prompt console for input
;
; Calling Sequence:
;	BSBW	PROMPT
;	.ASCIZ	/prompt string/
;
; Ouput Parameters:
;	COMBUF - Filled with ASCIC string representing reply.
;		 Reply does not include terminator.
;
;
PROMPT:					;
	MOVL	(SP),R0			; Get prompt string pointer
	PUSHAB	W^BOO$GT_COMBUF		; Set buffer address
	MOVZBL	#BOO$C_COMBUFSZ,-(SP)	;  and size for read.
	PUSHL	R0			; Set address of prompt string
	CALLS	#3,W^BOO$READPROMPT	; Prompt and read response
	LOCC	#0,#256,@(SP)		; Find end of string
	JMP	1(R1)			; and return

;
; DUMMY SYS$FAO LINKAGE TO EXE$FAO
;
SYS$FAO::				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; ALL REGISTERS
	BRW	EXE$FAO+2		; ENTER FAO 

	.PAGE
	.SBTTL	BOO$GIVEHELP - Print Help information
;
; 	Print Help Information
;
BOO$GIVEHELP::	.WORD	^M<R2,R3,R4,R5>	;
	CLRQ	-(SP)			; Null input buffer
	PUSHAB	B^HELPMSG		; Set address of help message
	CALLS	#3,W^BOO$READPROMPT	; Write help message
	MOVL	#1,R0			; Return success
	RET				;


HELPMSG:				; ASCIZ Help message string
	.ASCII	/Major SYSBOOT Commands are:/<CR><LF><LF>
	.ASCII	/	CONTINUE - Continue with boot process/<CR><LF>
	.ASCII	/	EXIT	 - Continue with boot process/<CR><LF>
	.ASCII	/	SET	 - Set parameter value/<CR><LF>
	.ASCII	/	    SET parameter_name value/<CR><LF>
	.ASCII	\	    SET /STARTUP file_spec\<CR><LF>
	.ASCII	/	SHOW	 - Show parameter value(s)/<CR><LF>
	.ASCII	/	    SHOW parameter_name/<CR><LF>
	.ASCII	\		/ACP 	- Show ACP parameters\<CR><LF>
	.ASCII	\		/ALL 	- Show ALL parameters\<CR><LF>
	.ASCII	\		/GEN 	- Show generative parameters\<CR><LF>
	.ASCII	\		/MAJOR 	- Show MAJOR parameters\<CR><LF>
	.ASCII	\		/NAMES 	- Show parameter names\<CR><LF>
	.ASCII	\		/PQL 	- Show Process Quota List values\<CR><LF>
	.ASCII	\		/RMS 	- Show RMS parameters\<CR><LF>
	.ASCII	\		/SCS	- Show SCS parameters\<CR><LF>
	.ASCII	\		/STARTUP - Show Startup command file name\<CR><LF>
	.ASCII	\		/SYS 	- Show SYSTEM parameters\<CR><LF>
	.ASCII	\		/TTY 	- Show terminal parameters\<CR><LF>
	.ASCII	/	USE	 - Set parameter file name /<CR><LF>
	.ASCII	\	    USE file_spec.PAR \<CR><LF>
	.ASCII	/		Reserved filespecs are:/<CR><LF>
	.ASCII	/			DEFAULT - Use permanent defaults/<CR><LF>
	.ASCIZ	/			CURRENT - Use current values/<CR><LF>

	.SBTTL	Miscellaneous constants and temps
FIL$GQ_CACHE::
	.BLKQ	1			; FIL$OPENFILE cache descriptor
FIL$GT_TOPSYS::
	.ASCIC	/SYS0/			; Default top level system dir name
	.BLKB	10-<.-FIL$GT_TOPSYS>	; Fill to 10 bytes
BOO$GT_SYSDUMP:				;
	.ASCIC	/SYSDUMP.DMP/		; Name of dump file
BOO$GT_PAGEFILE:			;
	.ASCIC	/PAGEFILE.SYS/		; Name of page file

BOO$GT_SYS::				;
	.ASCIC	/SYS.EXE/		; Name of system image
BOO$GL_FREEMEM::			; Base of free memory after boot image
	.LONG	0			;
BOO$GT_PROMPT::				; Prompt string
	.ASCIZ	<CR><LF>%SYSBOOT>  %	;
BOO$GL_GPTPGCT::			; Count of global page table pages
	.LONG	0			;
BOO$GL_NEXTPFN::			; Starting index for PFN scan
	.LONG	0			;
BOO$GL_SPTPAGCT::			; Count of pages allocated for SPT
	.LONG	0			;
BOO$GQ_STATBLK::			; Statistics block for file open
	.LONG	0,0			;
BOO$GL_SYSPHD::				; Physical address of system header
	.LONG	0			;
BOO$GL_SYSPHDPG::			; Count of pages for system PHD
	.LONG	0			;
INILOA_NAME:
	.ASCIC	/INILOA.EXE/		; Name of loaded initialization code.
TTNAME:	.ASCIC	/TTDRIVER.EXE/		; NAME OF TERMINAL SERVICE CODE

DBNAME:	.ASCIC	/DBDRIVER.EXE/		; Name of RP06 Driver
DMNAME:	.ASCIC	/DMDRIVER.EXE/		; Name of RK07 Driver
DRNAME:	.ASCIC	/DRDRIVER.EXE/		; Name of RM03/RP07 Driver
DLNAME:	.ASCIC	/DLDRIVER.EXE/		; Name of RL01/RL02 driver
DXNAME:	.ASCIC	/DXDRIVER.EXE/		; Name of console RX01 driver
DDNAME:	.ASCIC	/DDDRIVER.EXE/		; Name of console TU58 driver
UNKNAME:.ASCIC	/UNKDRIVER.EXE/		; Name of Driver for unknown devices

;
; DATA FOR LOADABLE CPU-DEPENDENT CODE:
;

NAME_SYSLOA:				; FILENAME OF LOADABLE
	.ASCIC	/SYSLOAXXX.EXE/		;  CPU-DEPENDENT IMAGE
NAME_XXX=NAME_SYSLOA+1+6		; ADDR OF XXX FIELD IN
					;  IMAGE FILENAME
MODEL_TABLE:				; TABLE OF LONGWDS:  EACH LONGWD
					;  HAS 3 CHAR MODEL NUMBER+ 1 SPACE
MODEL_780:				; VAX 11/780:
	.ASCII	/780 /
MODEL_750:				; VAX 11/750:
	.ASCII	/750 /
MODEL_730:				; VAX 11/730:
	.ASCII	/730 /
NAME_SCSLOA:				; Filename of loadable
	.ASCIC	/SCSLOA.EXE/		;  SCS code image
;
; MISC. LOCAL STORAGE:
;

	.ALIGN	LONG
SCBPAGCT:				; # pages for system SCB
	.LONG	0			;
SCBBYTCT:				; # bytes for system SCB
	.LONG	0			;
SCBPHADDR:				; Physical address of SCB
	.LONG	0			;
VALID_PAR_FILE:				; Valid parameter file flag
	.LONG	0
VMB_VERSION:
	.LONG	0			; VMB version number
SYSBOOT_BASE:
	.LONG	0			; Base address of SYSBOOT
BOO$GL_RPBBASE::
	.BLKL	1			; Base address of RPB
CPUTYPE:
	.LONG	0			; Copy of cpu type not in SYSPARAMS
ASSUME	VERSVECLEN LE 8			; The following space must be large
					;  enough to accomodate all of the
CPUDATA:				;  VERVECT info
	.LONG	0,0			; Copy of cpu data not in SYSPARAMS
RTRV_BUF_DSC:				; Size and address of buffer for
	.BLKQ	1			; retrieval pointer information
VBN2_BUF_DSC:				; Size and address of buffer for
	.BLKQ	1			; 2nd block of each driver
BOOTCB:
	.LONG	0			; Address of boot control block
					; Contains BOOTDRIVR, QIO_RWVB,
					; maps for SYS and SYSDUMP
MEM_LO_PFN:				; Lowest PFN found by VMB (inclusive)
	.BLKQ	1
	MEM_HI_PFN = MEM_LO_PFN+4	; Highest PFN found by VMB (exclusive)
CACHE_HI_PFN:
	.BLKL	1			; Highest PFN in FIL$OPENFILE cache
PFNMAP_HI_PFN:
	.BLKL	1			; Highest PFN in PFN bitmap pages
SMALL_PFNMAP::				; Saved descriptor for backwards
	.BLKQ	1			; compatible 8mb (max) PFN bitmap
UCODE_LEN:				; Length of loadable ucode
	.LONG	0
UCODE_ADR:				; Physical addr of it
	.LONG	0
;
; Following two cells must be contiguous!!
;
VMB_FLAGS:				; Flags passed from VMB
	.LONG	0
CI_HI_PFN:
	.LONG	0			; Highest PFN for CI support
;
; Statistics Blocks for various files that are placed in non-paged pool
; ***** Do Not Reorder or separate these Statistics Blocks *****
;
SYS_STAT:
	.BLKQ	1			; Starting VBN, size in bytes
	.LONG	1@20			; not used
	.LONG	BOO$GT_SYS		; Adr of ASCIC name of system image
	.BLKB	STAT_C_SIZE-16
SYSDUMP_STAT:
	.BLKQ	1			; Starting VBN, size in bytes
	.LONG	1@20			; not used
	.LONG	0			; Adr of ASCIC name of dump file
					; now filled in at run time
	.BLKB	STAT_C_SIZE-16
BOODRV_STAT:
	.BLKL	1			; VBN (not used)
	.BLKL	1			; Size in bytes of boot driver
	.LONG	BOO$GL_BOOTCB		; Adr to store adr of boot driver
	.LONG	BOODRV_MAP_ERR		; Adr of ASCIC string for alloc err msg
	.BLKB	STAT_C_SIZE-16
DSKDRV_STAT:
	.BLKQ	1			; VBN and size in bytes of disk driver
	.LONG	BOO$GL_DSKDRV		; Adr to store adr of disk driver
	.LONG	0			; Adr of ASCIC name of disk driver
	.BLKB	STAT_C_SIZE-16
PRTDRV_STAT:
	.BLKQ	1			; VBN and size in bytes of port driver
	.LONG	BOO$GL_PRTDRV		; Adr to store adr of port driver
	.LONG	0			; Adr of ASCIC name of port driver
	.BLKB	STAT_C_SIZE-16
TRMDRV_STAT:
	.BLKQ	1			; VBN and size in bytes of terminal driver
	.LONG	BOO$GL_TRMDRV		; Adr to store adr of terminal driver
	.LONG	TTNAME			; Adr of ASCIC name of terminal driver
	.BLKB	STAT_C_SIZE-16
SYSLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of CPU dependent code
	.LONG	BOO$GL_SYSLOA		; Adr to store adr of CPU dependent code
	.LONG	NAME_SYSLOA		; Adr of ASCIC name of CPU dependent code
	.BLKB	STAT_C_SIZE-16
SCSLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of SCS code
	.LONG	BOO$GL_SCSLOA		; Adr to store adr of SCS code
	.LONG	NAME_SCSLOA		; Adr of ASCIC name of SCS code
	.BLKB	STAT_C_SIZE-16
ALLOC_POOL_CNT = <.-BOODRV_STAT>/STAT_C_SIZE	; Things to alloc real pool for
INILOA_STAT:
	.BLKQ	1			; VBN and size in bytes of loaded init code
	.LONG	BOO$GQ_INILOA		; Adr to store adr of loaded init code
	.LONG	INILOA_NAME		; Adr of ASCIC name of loaded init code
	.BLKB	STAT_C_SIZE-16

LOAD_IMAGE_CNT = <.-DSKDRV_STAT>/STAT_C_SIZE	; Images to load

BOODRV_MAP_ERR:
	.ASCIC	/BOOTDRIVR/


	.END				; 
