	.TITLE	DQBTDRIVR - RB730:RB02/RB80 BOOT DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	BOOTS
;
; ABSTRACT:
;	This module contains the bootstrap device driver for
;	the RB02 and RB80 disks on the RB730 controller.
;
; ENVIRONMENT:	IPL 31, kernel mode, code must be PIC
;
; AUTHOR:  Greg Robert,	CREATION DATE:  09-Jun-1981
;
; NOTE: The RB730 controller is supported by host microcode which is
;	activated each time a device register is accessed, and for
;	each block transferred.  Because of this, registers must be
;	handled in strict accordance with the RB730 software specification.
;	The following special registers protocols are significant:
;
;		DAR --	When the DAR is loaded some drive functions
;			are initiated.  Consequently the function code
;			must be loaded into the CSR (with CRDY set)
;			prior to loading the DAR for seeks and transfers.
;			For data transfers, the BAR and BCR must also
;			be loaded prior to loading the DAR.
;
;		MPR --	The microcode keeps an internal disk address
;			register for computing cylinder differance words
;			for RB02 seek commands.  If this internal register
;			falls out of sync with the actual disk address
;			it can be reset by executing a "read header" command.
;			Note that the header must actually be read (thru
;			the MPR) in order to effect the reset.
;
; MODIFIED BY:
;
;	V202	GRR2002		Gregory R. Robert	30-Nov-1981
;		Added ECC correction logic.  The code was modelled after
;		the equivalent routines in DMBTDRIVR and MBBTDRIVR.
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$BTDDEF				; Boot device types
	$IODEF				; I/O function codes
	$PRDEF				; Processor Register definitions
	$RPBDEF				; RPB offsets
	$SSDEF				; Status codes
	$UBADEF				; UBA definitions
	$UBIDEF				; 11/750 UBA definitions

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
 
MODE = 20				; MAPPING MODE OFF ARGUEMENT POINTER

; 
; RB730:/RB02/RB80 REGISTER OFFSETS FROM CSR ADDRESS
; 
	$DEFINI	RB			; START OF REGISTER DEFINITIONS

$DEF	RB_CS		.BLKL	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	RB_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<DRDY,,M>,-		; DRIVE READY
		<FCODE,3>,-		; FUNCTION CODE
		<,2>,-			; RESERVED BITS
		<IE,,M>,-		; INTERRUPT ENABLE
		<CRDY,,M>,-		; CONTROLLER READY
		<DS,2>,-		; DRIVE SELECT
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<DCK,,M>,-		; DATA CRC OR HEADER CRC OR DATA ECC
		<DLT,,M>,-		; DATA LATE OR HEADER NOT FOUND
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<DE,,M>,-		; DRIVE ERROR
		<CE,,M>,-		; COMPOSITE ERROR
		<ATN,4>,-		; DRIVE ATTENTION BITS
		<ECS,2>,-		; ECC STATUS
		<SSEI,,M>,-		; SKIP SECTOR ERROR INHIBIT
		<SSE,,M>,-		; SKIP SECTOR ERROR
		<IR,,M>,-		; IDC INTERRUPT REQUEST
		<MTN,,M>,-		; MAINTENANCE MODE
		<TYP,,M>,-		; DRIVE TYPE 1=RB80, 0=RB02
		<ASSI,,M>,-		; AUTOMATIC SKIP SECTOR INHIBIT
		<TOI,,M>,-		; TIME OUT INHIBIT (U-DIAG'S)
		<FMT,,M>,-		; R80 FORMAT CONTROL
		<,2>-			; RESERVED BITS
	>				;END CSR BIT DEFINITIONS

$DEF	RB_BA		.BLKL	1	;BUS ADDRESS REGISTER (BAR)

$DEF	RB_BC		.BLKL	1	;BYTE COUNT REGISTER (BCR)

$DEF	RB_DA		.BLKL	1	;DISK ADDRESS REGISTER (DAR)
	_VIELD	RB_DA,0,<-		;START OF DAR BIT DEFINITIONS
		<SEC,8>,-		; SECTOR
		<TRK,8>,-		; TRACK
		<CYL,16>-		; CYLINDER
	>				;END OF DAR BIT DEFINITIONS

$DEF	RB_MP		.BLKL	1	;MULTIPURPOSE REGISTER (MPR)
	_VIELD	RB_MP,0,<-		;RB02 STATUS WORD DEFINITIONS
		<STA,3>,-		; DRIVE STATE
		<BH,,M>,-		; BRUSH HOME
		<HO,,M>,-		; HEADS OUT
		<CO,,M>,-		; COVER OPEN
		<HS,,M>,-		; HEAD SELECT
		<,1>,-			; RESERVED
		<DSE,,M>,-		; DRIVE SELECT ERROR
		<VC,,M>,-		; VOLUME CHECK
		<WGE,,M>,-		; WRITE GATE ERROR
		<SPE,,M>,-		; SPIN ERROR
		<SKTO,,M>,-		; SEEK TIME OUT
		<WL,,M>,-		; WRITE LOCK
		<CHE,,M>,-		; CURRENT HEAD ERROR
		<WDE,,M>-		; WRITE DATA ERROR
	>				;
	_VIELD	RB_MP,0,<-		;GET STATUS COMMAND DEFINITIONS
		<MRK,,M>,-		; MARK (ALWAYS 1)
		<STS,,M>,-		; GET STATUS
		<,1>,-			; RESERVED
		<RST,,M>,-		; RESET
	>
	_VIELD	RB_MP,0,<-		;RB80 STATUS WORD DEFINITIONS
		<SEC,5>,-		; CURRENT RB80 SECTOR
		<,3>,-			; RESERVED
		<FLT,,M>,-		; DRIVE FAULT
		<PLGV,,M>,-		; PLUG VALID
		<SKE,,M>,-		; SEEK ERROR
		<ONCY,,M>,-		; ON CYLINDER
		<DRDY,,M>,-		; DRIVE READY
		<WTP,,M>,-		; WRITE PROTECT
		<,2>,-			; RESERVED
	>				;END MPR BIT DEFINITIONS

$DEF	RB_EC1		.BLKL	1	;ECC POSITION REGISTER (EPOR)
	_VIELD	RB_EC1,0,<-		;START OF EC1 BIT DEFINITIONS
		<POS,13>,-		; STARTING BIT POSITION OF ECC ERROR
		<,21>-			; RESERVED
	>				;END EC1 BIT DEFINITIONS

$DEF	RB_EC2		.BLKL	1	;ECC PATTERN REGISTER (EPAR)
	_VIELD	RB_EC2,0,<-		;START OF EC2 BIT DEFINITIONS
		<PAT,11>,-		; PATTERN OF ECC ERROR BURST
		<,21>-			; RESERVED
	>				;END EC2 BIT DEFINITIONS

$DEF	RB_CMD		.BLKL	1	;AUXILLARY COMMAND REGISTER
	_VIELD	RB_CMD,0,<-		;START OF CMD BIT DEFINITIONS
		<INIT,32>,-		; SUBSYSTEM CLEAR <-- -1
	>				;END CMD BIT DEFINITIONS

	$DEFEND	RB			;END RB730:RB80/RB02 REGISTER DEFS

; 
; HARDWARE FUNCTION CODES
; 

F_NOP=0*2				;NO OPERATION
F_SEEK=3*2				;SEEK CYLINDER
F_READHEAD=4*2				;READ HEADER
F_WRITECHECK=1*2			;WRITE CHECK
F_WRITEDATA=5*2				;WRITE DATA
F_READDATA=6*2				;READ DATA
F_GETSTATUS=2*2				;GET STATUS

;
; OWN STORAGE:
;


;
; Boot driver table entry
;

	$BOOT_DRIVER	CPUTYPE = PR$_SID_TYP730,- ; Must be VAX 11/730
			DEVTYPE = BTD$K_DQ,-	; Device type (DQ)
			SIZE = DQ_DRVSIZ,-	; Driver size
			ADDR = DQ_DRIVER,-	; Driver address
			DRIVRNAME = DQNAME	; Driver file name

	.SBTTL	RB730:RB02/RB80 Bootstrap driver code

;++
;
; Inputs:
;
;	R3	- base address of adapter's register space
;	R5	- LBN FOR CURRENT PIECE OF TRANSFER
;	R6	- contains 0
;	R7	- address of device's CSR
;	R8	- SIZE OF TRANSFER IN BYTES
;	R9	- address of the RPB
;	R10	- starting address of transfer (byte offset in first
;		  page ORed with starting map register number)
;
;	FUNC(AP)- I/O operation (IO$_READLBLK or IO$_WRITELBLK only)
;	BUF(AP) - Buffer address
;	SIZE(AP)- Size of transfer
;	MODE(AP)- Transfer mapping mode
;
; Implicit inputs:
;
;	RPB$W_UNIT	- RPB field containing boot device unit number
;
; Outputs:
;
;	R0 - status code
;
;		SS$_NORMAL	- successful transfer
;		SS$_CTRLERR	- fatal controller error
;
;	R3 - must be preserved
;
;	This routine destroys R1, R2, R4, R5, R6.
;
; 
; Register useage during this routine:
;
;	R0 - scratch
;	R1 - byte count for current transfer / scratch
;	R2 - scratch
;	R3 - adaptor base address
;	R4 - unit number
;	R5 - logical block number for current transfer
;	R6 - disk address for current transfer / scratch
;	R7 - device CSR
;	R8 - remaining byte count
;--

BUF = 4
SIZE = 8
FUNC = 16

DQ_DRIVER:

;
; COMPUTE ADDRESS OF DEVICE CSR
;
	MOVAL	^X200(R3),R7		; COMPUTE CORRECT DEVICE CSR

;
; POSITION AND STORE THE UNIT NUMBER IN R4 FOR GLOBAL USE
;
	CLRL	R4			; CLEAR R4
	INSV	RPB$W_UNIT(R9),#8,#2,R4	; GET UNIT NUMBER

;
; RESET DRIVE AND GET STATUS
;
10$:	MNEGL	#1,RB_CMD(R7)		; INITIALIZE SUBSYSTEM
	MOVL	#RB_MP_M_STS-		; PUT GET STATUS
		!RB_MP_M_RST-		; ... AND WITH RESET
		!RB_MP_M_MRK,-		; ... AND MARK BIT
		RB_MP(R7)		; ... INTO DAR
	BISL3	R4,-			; MERGE UNIT NUMBER
		#F_GETSTATUS,-		; ... AND FUNCTION
		RB_CS(R7)		; ... INTO CSR
	BSBW	READY			; WAIT FOR DRIVE AND CONTROLLER READY
	MOVL	RB_MP(R7),R0		; FETCH STATUS WORD
	BITL	#RB_CS_M_TYP,RB_CS(R7)	; IS THIS AN RB80?
	BNEQ	20$			; BRANCH IF SO

;
; CHECK RB02 STATUS
;
	CMPZV	#0,#5,R0,-		; TEST BITS 04:00 OF STATUS FOR
		#RB_MP_M_HO-		; ... HEADS OUT
		!RB_MP_M_BH-		; ... BRUSHES HOME
		!5			; ... SEEK LINEAR MODE (READY TO GO)
	BNEQ	10$			; LOOP IF NOT READY

;
; READ A HEADER TO MAKE SURE MICROCODE IS SYNCRONIZED WITH CURRENT
; DISK POSITION
;
	BISL3	R4,-			; MERGE UNIT NUMBER
		#F_READHEAD,-		; ... AND FUNCTION
		RB_CS(R7)		; ... INTO CSR
	BSBW	READY			; WAIT FOR DRIVE AND CONTROLLER READY
	CMPL	RB_MP(R7),RB_MP(R7)	; READ THE HEADER (UCODE DOESN'T LOOK
					; ...AT IT UNLESS WE ACCESS IT)
	BRB	200$			; CONTINUE IN COMMON


;
; CHECK RB80 STATUS
;
20$:	CMPZV	#8,#5,R0,-		; TEST BITS 08:12 OF STATUS FOR
		#<RB_MP_M_DRDY-		; ...DRIVE READY
		!RB_MP_M_ONCY-		; ...ON CYLINDER
		!RB_MP_M_PLGV>-		; ...PLUG VALID
		@-8			; ...SHIFT TO LOW BYTE
	BNEQ	10$			; IF NOT, BRANCH TO WAIT FOR IT


;
; NOW CONVERT LOGICAL TO PHYSICAL -- THE COMPUTED DISK ADDRESS HAS THE
; FORM OF A LONG WORD WITH LOW BYTE=SECTOR, NEXT BYTE=TRACK, AND HIGH
; WORD = CYLINDER.
;
;		I)	CYLINDER = LBN / BLOCKS_PER_CYLINDER
;	       II)	TRACK = REMAINDER(I) / BLOCKS_PER_TRACK
;	      III)	RB02_SECTOR = REMAINDER(II) * 2
;	       IV)	RB80_SECTOR = REMAINDER(II)
;

200$:	CLRL	R1			; CLEAR HIGH PART OF DIVIDEND
	CLRL	R6			; CLEAR HIGH PART OF DIVIDEND
	BITL	#RB_CS_M_TYP,RB_CS(R7)	; IS THIS AN RB80?
	BNEQ	220$			; BRANCH IF SO

;
;COMPUTE RB02 DISK ADDRESS
;
	EDIV	#40/2*2,R5,R2,R0	; R2 = DESIRED CYL, R0 = REMAINING BLKS
	EDIV	#40/2,R0,R0,R6		; R0 = DESIRED TRK, R6 = REMAINING BLKS
	MULL	#2,R6			; 2 SECTORS PER BLOCK
	SUBL3	R6,#40,R1		; R1 = 256 BYTE SECTORS LEFT ON SURFACE
	BRB	230$			; CONTINUE IN COMMON

;
;COMPUTE RB80 DISK ADDRESS INSTEAD
;
220$:	EDIV	#31*14,R5,R2,R0		; R2 = DESIRED CYL, R0 = REMAINING BLKS
	EDIV	#31,R0,R0,R6		; R0 = DESIRED TRK, R6 = REMAINING BLKS
	SUBL3	R6,#31,R1		; R1 = 512 BYTE SECTORS LEFT ON SURFACE
	MULL	#2,R1			; R1 = 256 BYTE SECTORS LEFT ON SURFACE

;
;IF FINAL TRANSFER USE REMAINING BYTE COUNT, ELSE USE REMMAINDER OF TRACK
;
230$:	MULL	#256,R1			; R1 = BYTES LEFT ON SURFACE
	CMPL	R8,R1			; ARE ADDITIONAL TRANSFERS REQUIRED?
	BGTRU	240$			; BRANCH IF ANSWER YES
	MOVL	R8,R1			; SET BYTE COUNT FOR FINAL TRANSFER

;
;FORM FULL DISK ADDRESS (CYL, TRK, SEC)
;
240$:	INSV	R2,#16,#16,R6		; MOVE CYLINDER INTO HIGH WORD
	INSV	R0,#8,#8,R6		; MOVE TRACK INTO SECOND BYTE

;
; PERFORM SEEK -- NOTE: FOR RB730 SEEKS AND TRANSFERS, THE COMMAND
; MUST BE LOADED INTO THE CSR WITH CONTROLLER READY BIT SET, BEFORE
; WRITING TO THE DISK ADDRESS REGISTER !!!
;
	BISL3	R4, -			; MERGE UNIT NUMBER
		#F_SEEK-		; ... FUNCTION AND
		!RB_CS_M_CRDY,-		; ... SUPPRESS EXECUTION
		RB_CS(R7)		; ... INTO CSR
	MOVL	R6,RB_DA(R7)		; LOAD DISK ADDRESS IN DAR
	BICL	#RB_CS_M_CRDY,RB_CS(R7)	; INITIATE THE FUNCTION
	BSBW	READY			; WAIT FOR CONTROLLER AND DRIVE READY
	BBC	#RB_CS_V_CE,R0,300$	; BRANCH IF NO ERRORS
	BRW	900$			; EXIT


; 
; SEEK IS COMPLETE -- EXECUTE TRANSFER FUNCTION
;
300$:	MOVZBL	#F_READDATA-		; ASSUME READ FUNCTION
		!RB_CS_M_CRDY,R2	; ... WITH CONTROLLER READY
	CMPL	FUNC(AP),#IO$_WRITELBLK	; IS IT A WRITE FUNCTION?
	BNEQ	350$			; BRANCH IF NOT
	MOVZBL	#F_WRITEDATA-		; SET WRITE FUNCTION CODE
		!RB_CS_M_CRDY,R2	; ... WITH CONTROLLER READY

;
; NOTE: THE DEVICE REGISTERS MUST BE LOADED IN THE PRESCRIBED ORDER!
; 	1) FUNCTION CODE LOADED INTO CSR WITH CRDY SET
;	2) BYTE COUNT AND MEMORY ADDRESS (THESE TWO ARE REVERSABLE)
;	3) DISK ADDRESS (FIRST HARDWARE SILO LOADED AT THIS TIME)
;	4) CRDY CLEARED (SECOND SILO LOADED, XFER BEGINS)
;
350$:	BISL3	R4,R2,-			; MERGE UNIT NUMBER AND FUNCTION
		RB_CS(R7)		;...INTO CSR
	MNEGL	R1,RB_BC(R7)		; SET NEG TRANSFER BYTE COUNT
	MOVL	R10,RB_BA(R7)		; SET BUFFER ADDRESS
	MOVL	R6,RB_DA(R7)		; SET DESIRED DISK ADDRESS
	BICL	#RB_CS_M_CRDY,RB_CS(R7)	; INITIATE THE FUNCTION
	BSBW	READY			; WAIT FOR CONTROLLER AND DRIVE READY
	MOVL	RB_BA(R7),R10		; UPDATE BUFFER ADDRESS
	ADDL	RB_BC(R7),R1		; COMPUTE ACTUAL BYTES TRANSFERRED
	SUBL	R1,R8			; UPDATE BYTES LEFT TO TRANSFER
	ASHL	#-9,R1,R2		; CONVERT TO PAGE COUNT
	ADDL	R2,R5			; UPDATE LOGICAL BLOCK NUMBER
	BBC	#RB_CS_V_CE,R0,500$	; BRANCH IF NO ERRORS

;
; CHECK FOR ECC ERROR -- TO BE ELIGIBLE FOR CORRECTION THE FOLLOWING MUST APPLY
;
;	THE OPERATION MUST BE A READ DATA
;	THE ERROR MUST BE A DATA CHECK
;	THE ERROR MUST BE A CORRECTABLE ECC ERROR
;	THE TRANSFER MODE MATCHES THE MAP-ENABLED POSITION, I.E.,
;		TRANSFER IS VIRTUAL, AND MAPPING IS ENABLED, OR V.V.
;	SOME DATA WAS TRANSFERRED
;	NO OTHER ERRORS OCCURED
;

	CMPZV	#RB_CS_V_FCODE,-	;WAS THIS A READ DATA OPERATION?
		#RB_CS_S_FCODE,R0,-	;...
		#<F_READDATA @ -1>	;...
	BNEQ	900$			;BRANCH IF NOT
	BBC	#RB_CS_V_TYP,R0,900$	;BRANCH IF RB02
	BITW	#RB_CS_M_DE-		;DRIVE ERROR
		!RB_CS_M_NXM-		;...OR NON EXISTENT MEMORY
		!RB_CS_M_DLT-		;...OR DATA LATE
		!RB_CS_M_OPI,-		;...OR OPERATION INCOMPLETE (HDR CRC)
		R0			;...
	BNEQ	900$			;BRANCH IF SO
	BBC	#RB_CS_V_DCK,R0,900$	;BRANCH IF NOT A DATACHECK
	CMPZV	#RB_CS_V_ECS,-		;COMPARE ECC STATUS BITS (START)
		#RB_CS_S_ECS,-		;...(SIZE)
		R0,-			;...(FROM)
		#^B11			;...TO BINARY 11 (BOTH SET)
	BNEQ	900$			;BRANCH IF NOT CORRECTABLE
	MFPR	#PR$_MAPEN,R0		; GET MAP ENABLE STATE
	CMPL	R0,MODE(AP)		; SAME AS I/O MODE
	BNEQ	900$			; NO, CANT DO SIMPLE ECC

;
; Appears to be a correctable data check. Attempt the correction.
; Register useage: R0=Position, R1=Width, R2=Buffer offset to error sector
;
	MOVL	RB_EC1(R7),R0		; FETCH ECC POSITION REGISTER
	DECL	R0			; MAKE POSITION 1 ORIGIN
	MOVAB	512(R8),R1		; BYTES REMAINING PLUS ERROR SECTOR
	SUBL3	R1,SIZE(AP),R2		; BUFFER OFFSET TO ERROR SECTOR
	MULL	#8,R1			; CONVERT BYTE COUNT TO BIT COUNT
	SUBL	R0,R1			; COMPUTE CORRECTION FIELD WIDTH
	BLEQ	500$			; BR IF NO CORRECTION NEEDED
	CMPL	R1,#RB_EC2_S_PAT	; MINIMUM OF 11 AND BUFFER REMAINING
	BLEQ	480$			; KEEP MINIMUM VALUE
	MOVL	#RB_EC2_S_PAT,R1	; USE MAXIMUM FIELD PATTERN WIDTH
480$:	EXTZV	R0,R1,@BUF(AP)[R2],-(SP); GET FIELD TO BE CORRECTED
	XORL	RB_EC2(R7),(SP)		; APPLY CORRECTION CODE
	INSV	(SP)+,R0,R1,@BUF(AP)[R2]; AND RESTORE IN BUFFER

500$:	TSTL	R8			; MORE TO TRANSFER?
	BLEQ	600$			; BRANCH IF DONE
	BRW	200$			; CONTINUE TRANSFER

; 
; TRANSFER COMPLETE - RETURN
; 
600$:	MOVZWL	SIZE(AP),R1		; SET TOTAL BYTES TRANSFERRED
	BNEQ	610$			; BRANCH IF ORIGINAL SIZE WAS TRANSFERRED
	MOVL	#^X8000,R1		; ELSE SIZE WAS FORCED TO 64K
610$:	MOVZWL	#SS$_NORMAL,R0		; SET COMPLETION CODE
	RSB				; AND RETURN

; 
; RETRY ERROR
; 

900$:	MOVZWL	SIZE(AP),R8		; RESTORE BYTE SIZE OF TRANSFER IN R8
	BNEQ	910$			; BRANCH IF SIZE WAS LEGAL
	MOVL	#8000,R8		; ELSE FORCE TO 64K SIZE
910$:	EXTZV	#0,#9,BUF(AP),R10	; RESTORE BYTE OFFSET IN R10
	MOVZWL	#SS$_CTRLERR,R0		; SET FATAL CONTROLLER ERROR
	RSB				; AND ATTEMPT RETRY


;
; SUBROUTINE TO WAIT FOR CONTROLLER AND DRIVE READY OR ERROR
;
 
READY:
	MOVL	RB_CS(R7),R0		; FETCH CSR
	BBS	#RB_CS_V_CE,R0,10$	; EXIT IF ERROR
	BBC	#RB_CS_V_CRDY,R0,READY	; LOOP UNTIL CONTROLLER READY
	BBC	#RB_CS_V_DRDY,R0,READY	; LOOP UNTIL DRIVE READY
10$:	RSB				;

DQNAME:	.ASCIC	/DQDRIVER.EXE/		; Driver file name

DQ_DRVSIZ=.-DQ_DRIVER

	.END
