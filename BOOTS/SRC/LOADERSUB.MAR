	.TITLE	LOADERSUB - LOADER SUBROUTINES
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	I/O DATABASE GENERATOR
;
; ABSTRACT:	LOADER SUBROUTINES
;
;
; ENVIRONMENT:	USER MODE PRIVILEGED CODE
;
; AUTHOR:	LEN KAWELL, CREATION DATE:16-JUN-716
;
; MODIFIED BY:
;
;	V03-014	JLV0164		Jake VanNoy		29-Jan-1982
;		More CI/UDA related work on IOGEN$CNTRL_INI
;
;	V03-013	JLV0133		Jake VanNoy		31-Dec-1981
;		Add CONNECT /SYSID support.
;
;	V12	CAS0032		C. A. Samuelson		14-Sep-1981
;		Add support for 2nd TU58 on 11/730
;
;	V11	TCM0003		Trudy C. Matthews	29-Jul-1981
;		Changed all "7ZZ"s to "730"s.
;
;	V10	JLV0002		Jake VanNoy		9-Feb-1981
;		Changed psects to allow paged and non-paged segments
;		is SYSGEN image. Add SHOW/CONFIGURATION and 
;		CONFIGURE.
;
;	V09	TCM0002		Trudy C Matthews		18-Sep-1980
;		Deleted routine IOGEN$TEST_CSR.  Changed all references to
;		IOGEN$TEST_CSR to call EXE$TEST_CSR instead.
;
;	V08	NPK002		N. KRONENBERG		8-JAN-1980
;		FIXED IOGEN$CONNVEC TO SPECIFY INTERRUPTS HANDLED
;		ON INTERRUPT STACK FOR 11/750, 11/730.
;
;	V07	ADE001		A.ELDRIDGE		10-OCT-1979
;		FIXED IOGEN$CNTRL_INIT TO CALL THE DRIVER'S CONTROL
;		INITIALIZATION ROUTINE IF ITS ADAPTER TYPE IS "NULL"
;
;	V06	SRB0002		STEVE BECKHARDT		24-SEP-1979
;		FIXED SEVERAL "BRANCH OUT OF RANGES" INTRODUCED BY
;		THE ADDITION OF A NEW MODULE.  THESE WERE CAUSING
;		LINKER TRUNCATION ERRORS.
;
;	V05	SRB0001		STEVE BECKHARDT		5-SEP-1979
;		ADDED SUBROUTINE IOGEN$CONSOLE WHICH CONTAINS
;		CPU DEPENDENT CODE FOR CONNECTING THE CONSOLE BLOCK
;		STORAGE DEVICE.  ALSO FIXED BIG IN IOGEN$TEST_MEM.
;
;	V04	TCM0001		Trudy C. Matthews	06-AUG-1979
;		ADDED NEBULA-SPECIFIC PATHS THROUGH CPU-DEPENDENT
;		SUBROUTINES
;
;	V03	LMK0001		LEN KAWELL	24-JUL-1979
;		ADDED SUBROUTINE IOGEN$TEST_MEM TO TEST A PAGE OF MEMORY.
;		THIS ROUTINE IS CPU DEPENDENT.
;
;	V02	NPKCOMET	N. KRONENBERG	18-APR-1979
;		ADDED SUBROUTINES IOGEN$TEST_CSR AND IOGEN$CONN_VEC.
;		ALL CPU-DEPENDENCIES FOR SYSGEN, LOAD, AND AUTOCONFIG
;		ARE LOCALIZED IN THESE SUBROUTINES.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS


;
; INCLUDE FILES:
;

;
; MACROS:
;
;
; CPU TYPE DISPATCH MACRO:
;
;	THE ADDRESSES IN THE ADDRESS LIST ARE:
;		-ADDRESS OF CODE FOR CPU TYPE=1 (11/780)
;		-ADDRESS OF CODE FOR CPU TYPE=2 (11/750)
;		-ADDRESS OF CODE FOR CPU TYPE=3 (11/730)
;		-ADDRESS OF CODE FOR CPU TYPE=4	(?)
;		-ETC.
;
;	CPUDISP IS INVOKED TO HANDLE CPU DIFFERENCES IN LINE.  WHEN THE
;	NEXT CPU IS ADDED, ALL OCCURRENCES OF CPUDISP MUST BE EXPANDED
;	TO HANDLE THREE CPU SPECIFIC PATHS.
;
	.MACRO	CPUDISP,ADDRLIST
	CASE	MMG$A_SYSPARAM+<EXE$GB_CPUTYPE-EXE$A_SYSPARAM>,-
		<ADDRLIST>,LIMIT=#PR$_SID_TYP780,TYPE=B
	.ENDM	CPUDISP

;
; EQUATED SYMBOLS:
;

	$DYNDEF				;DEFINE DYNAMIC MEMORY BLOCK TYPES
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$UCBDEF				;DEFINE UCB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$VECDEF				;DEFINE CRB DISPATCHER OFFSETS
	$UBADEF				;DEFINE UBA REGISTERS
	$ADPDEF				;DEFINE ADP OFFSETS
	$DPTDEF				;DEFINE DPT OFFSETS
	$ACFDEF				;DEFINE ACF OFFSETS

;
; OWN STORAGE:
;

.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

UBINT_DISP:				;1ST INSTRUCTION IN INTERRUPT
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; DISPATCH BLOCK FOR UNIBUS DEVICE.

	.PAGE
	.SBTTL	IOGEN$LOCK_IODB/IOGEN$UNLK_IODB
;++
; IOGEN$LOCK_IODB - LOCK THE SYSTEM I/O DATABASE FOR WRITE
; IOGEN$UNLK_IODB - UNLOCK THE SYSTEM I/O DATABASE
;
; FUNCTIONAL DESCRIPTION:
;
;	LOCK - GETS THE I/O DATABASE MUTEX FOR WRITE
;	UNLOCK - RETURNS THE I/O DATABASE MUTEX AND RETURNS IPL TO 1.
;
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	I/O DATABASE LOCKED AND IPL RAISED OR UNLOCKED AND IPL LOWERED
;--

.PSECT	NONPAGED_CODE	rd,nowrt,exe,long

IOGEN$LOCK_IODB::
	MOVAL	G^IOC$GL_MUTEX,R0	; GET I/O DATA BASE MUTEX
	MOVL	G^SCH$GL_CURPCB,R4	; GET OWN PCB ADDRESS
	JSB	G^SCH$LOCKW		; AND LOCK IT
	RSB

IOGEN$UNLK_IODB::
	MOVAL	G^IOC$GL_MUTEX,R0	; GET I/O DATA BASE MUTEX
	MOVL	G^SCH$GL_CURPCB,R4	; AND OWN PCB ADDRESS
	JSB	G^SCH$UNLOCK		; AND UNLOCK IT
	SETIPL	#0			; ALSO LOWER IPL
	RSB
	.PAGE
	.SBTTL	IOGEN$ALLOBLOCK
;++
;
; IOGEN$ALLOBLOCK - ALLOCATE CONTROL BLOCKS
;
;	ALLOCATES A BLOCK OF MEMORY FROM THE NON-PAGED POOL AND
;	ZEROS IT.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK DESIRED
;
; OUTPUTS:
;
;	R0 = STATUS OF ALLOCATION
;	R1 = SIZE OF ALLOCATED BLOCK
;	R2 = ADDRESS OF ALLOCATED BLOCK
;
;--
IOGEN$ALLOBLOCK::
	PUSHR	#^M<R3,R4,R5>		;SAVE REGISTERS
	JSB	G^EXE$ALONONPAGED	;ALLOCATE NON-PAGED POOL
	BLBS	R0,10$			;BR IF SUCCESS
	MOVZWL	#SS$_INSFMEM,R0		;SET ERROR STATUS
	POPR	#^M<R3,R4,R5>		;RESTORE REGISTERS
	RSB				;RETURN
10$:
	PUSHR	#^M<R0,R1,R2>		;SAVE REGISTERS
20$:	MOVC5	#0,20$,#0,R1,(R2)	;ZERO THE BUFFER
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE REGISTERS
	RSB				;RETURN

	.PAGE
	.SBTTL	IOGEN$CNTRL_INI
;++
;
; IOGEN$CNTRL_INI - INITIALIZE THE DEVICE CONTROLLER
;
; INPUTS - R6 = ADDR OF DDB
;	   R11 = ADDR OF DRIVER PROLOGUE TABLE
;
;--
IOGEN$CNTRL_INI::
	CMPB	#AT$_UBA,DPT$B_ADPTYPE(R11) 	;UBA DEVICE?
	BEQL	30$				;BRANCH IF SO
	CMPB	#AT$_NULL,DPT$B_ADPTYPE(R11) 	;NULL (SOFTWARE ONLY) ADAPTER
	BEQL	30$				;BRANCH IF SO
	CMPB	#AT$_CI,DPT$B_ADPTYPE(R11) 	;CI ADAPTER
	BNEQ	100$				;BRANCH IF NOT
30$:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;SAVE REGISTERS
	MOVL	DDB$L_UCB(R6),R0	;GET ADDR OF FIRST UCB

	MOVL	UCB$L_CRB(R0),R8	;GET ADDR OF CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R8),R5 ;SET ADDR OF IDB
	MOVL	IDB$L_CSR(R5),R0	;GET ADDR OF CSR
	BGEQ	70$			;NO CSR
	PUSHR	#^M<R6>			;SAVE DDB ADDRESS
	MOVL	IDB$L_ADP(R5),R6	;GET ADDR OF ADP
	MOVL	ADP$L_CSR(R6),R6	;GET ADAPTER CONFIG REG ADDR
	JSB	G^EXE$TEST_CSR		;TEST IF DEVICE IS PRESENT
	POPR	#^M<R6>			;RESTORE DDB ADDR
	BLBC	R0,90$			;BRANCH IF NON-EXISTENT CSR
70$:	MOVL	IDB$L_CSR(R5),R4	;GET DEVICE CSR ADDR
	BNEQ	80$			;BRANCH IF IDB FILLED IN
	MOVL	ACF$L_CONTRLREG(AP),R4	;USE ACF BLOCK CSR

80$:	MOVL	CRB$L_INTD+VEC$L_INITIAL(R8),R0 ;GET ADDR OF INIT ROUTINE
	BEQL	90$			;BR IF NONE

; R4 = ADDR OF CSR or ADDR OF SYSID QUADWORD
; R5 = ADDR OF IDB
; R6 = ADDR OF DDB
; R8 = ADDR OF CRB

	JSB	(R0)			;INIT CONTROLLER
90$:
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;RESTORE REGISTERS
100$:	
	RSB

	.PAGE
	.SBTTL	IOGEN$CONN_VEC
;++
;
; IOGEN$CONN_VEC - CONNECT A UNIBUS INTERRUPT DISPATCHER TO A VECTOR
;
; THIS SUBROUTINE IS CPU-DEPENDENT.  THE FOLLOWING CPU'S ARE SUPPORTED:
;
;	11/780	-CONNECT VEC$Q_DISPATCH+2 (JSB @#) TO VECTOR
;	11/750	-CONNECT VEC$Q_DISPATCH (PUSHR) TO VECTOR
;	11/730	-CONNECT VEC$Q_DISPATCH (PUSHR) TO VECTOR
;
; FOR ALL CPU'S, PUSHR #^M<R2,R3,R4,R5> IN THE INTERRUPT DISPATCH BLOCK
; IS CHANGED TO PUSHR #^M<R0,R1,R2,R3,R4,R5>.
;
; INPUTS:
;
;	R0 = ADDRESS OF VECTOR TO CONNECT
;	R4 = ADDRESS OF INTERRUPT DISPATCH BLOCK IN CRB
;
; OUTPUTS:
;
;	ALL REGISTERS PRESERVED
;--

IOGEN$CONN_VEC::			;
	MOVW	UBINT_DISP,VEC$Q_DISPATCH(R4) ;CHANGE PUSHR TO PUSH R0-R5
	MOVAB	VEC$Q_DISPATCH(R4),(R0)	;CONNECT PUSHR TO VECTOR
					;
					;
	CPUDISP	<VEC_780,-		;*DISPATCH ON CPU TYPE*
		VEC_750,-		;
		VEC_730>		;
					;
VEC_780:				;FOR 11/780:
	ADDL	#2,(R0)			;STEP VECTOR TO VEC$Q_DISPATCH+2
	BRB	VEC_END			;
					;
VEC_750:				;11/750:
VEC_730:				;11/730:
	INCL	(R0)			;SET L.O. BIT TO INDICATE THAT
					; INTERRUPT HANDLED ON INT STACK
					;
VEC_END:				;*END OF CPU-DEPENDENT CODE*
					;
					;
	RSB				;DONE
	.PAGE
	.SBTTL IOGEN$TEST_MEM
;++
;
; IOGEN$TEST_MEM - TEST A PAGE OF MEMORY
;
; THIS TEST IS CPU-DEPENDENT.  THE FOLLOWINT CPU'S ARE SUPPORTED:
;
;	11/780	-TEST A PAGE OF MEMORY A QUADWORD AT A TIME USING THE
;		 PR$_SBIQC PROCESSOR REGISTER.  THIS CAN ALSO "FIX"
;		 SOME RDS ERRORS TO BE CRD ERRORS.  IF A HARD RDS 
;		 ERROR OCCURS, A MACHINE CHECK WILL RESULT AND THE
;		 PAGE WILL BE CONSIDERED BAD.
;
;	11/750	-TEST A PAGE OF MEMORY A QUADWORD AT A TIME USING THE
;		 MOVQ INSTRUCTION.  IF A UNCORRECTABLE ECC ERROR OCCURS,
;		 A MACHINE CHECK WILL RESULT AND THE PAGE WILL BE
;		 CONSIDERED BAD.
;
; THIS SUBROUTINE SHOULD BE CALLED VIA BRANCH TO SUBROUTINE AT IPL 31.
;
; INPUTS :
;
;	R3 = VIRTUAL ADDRESS OF FIRST BYTE OF PAGE.
;	R4 = PHYSICAL ADDRESS OF FIRST BYTE OF PAGE.
;
; OUTPUTS:
;
;	R0 = LOW BIT SET FOR GOOD PAGE.
;	     LOW BIT CLEAR FOR BAD PAGE.
;	R3 = R3 + 512.
;	R4 = R4 + 512.
;	OTHER REGISTERS PRESERVED.
;--
IOGEN$TEST_MEM::			;
	PUSHR	#^M<R1,R2>		;SAVE REGISTERS
	MOVL	MMG$A_SYSPARAM+<EXE$GL_SCB-EXE$A_SYSPARAM>,R1
					; GET SYS.EXE COPY OF SCB ADDR
	PUSHL	4(R1)			;SAVE CURRENT MACHINE CHECK HANDLER
	MOVL	SP,R2			;MARK STACK POSITION
					;
					;
	CPUDISP	<SET_MMCHK_780,-	;*DISPATCH ON CPU TYPE*
		SET_MMCHK_750>		;
					;
SET_MMCHK_750:				;FOR 11/750:
	MOVAL	MMCHK_750,4(R1)		;CONNECT 11/750 MCHECK HANDLER
	BRB	SET_MMCHK_END		;
					;
SET_MMCHK_780:				;FOR 11/780:
	MOVAL	MMCHK_780,4(R1)		;CONNECT 11/780 MCHECK HANDLER 
					;
SET_MMCHK_END:				;*END OF CPU-DEPENDENT CODE*
					;
	MOVZBL	#<512/8>,R0		;SET LOOP COUNTER FOR 64 QUADWORDS
					;
TEST_MEM_LOOP:				;
					;
	CPUDISP	<CLR_Q_780,-		;*DISPATCH ON CPU TYPE*
		CLR_Q_750>		;
					;
CLR_Q_780:				;FOR 11/780:
	MTPR	R4,#PR$_SBIQC		;CLEAR A QUADWORD
	ADDL	#8,R4			;INCREMENT PHYSICAL ADDRESS
	BRB	CLR_Q_END		;
					;
CLR_Q_750:				;FOR 11/750:
	CLRQ	(R3)			;CLEAR A QUADWORD
					;
CLR_Q_END:				;*END OF CPU-DEPENDENT CODE*
	CMPL	(R3)+,(R3)+		;READ BOTH LONGWORDS, AND ADVANCE TO
					;TO NEXT QUADWORD
	SOBGTR	R0,TEST_MEM_LOOP	;DECREMENT QUADWORD COUNTER AND LOOP
					;
	MOVZBL	#1,R0			;SET STATUS TO SUCCESS
	BRW	TEST_MEM_DONE		;JOIN COMMON EXIT

;
; LOCAL MACHINE CHECK HANDLER FOR 11/750:
;

	.ALIGN	LONG
MMCHK_750:				;
	MTPR	#^XF,#PR$_MCESR		;CLEAR ANY MEMORY ERROR
	BRB	BAD_MEM			;

;
; LOCAL MACHINE CHECK HANDLER FOR 11/780:
;

	.ALIGN	LONG
MMCHK_780:				;
	MTPR	#0,#PR$_SBIFS		;CLEAR ANY MEMORY ERROR
BAD_MEM:				;WRITING/READING MEMORY CAUSED MCHECK
	MOVL	R2,SP			;CLEAR MCHECK LOGOUT STACK
	CLRL	R0			;SET STATUS TO FAILURE
TEST_MEM_DONE:				;PREPARE FOR EXIT
	POPL	4(R1)			;RESTORE OLD MCHECK HANDLER
	POPR	#^M<R1,R2>		;RESTORE REGISTERS
	RSB				;

	.PAGE
	.SBTTL	IOGEN$CONSOLE
;++
;
; IOGEN$CONSOLE - SET UP FOR CONNECTING CONSOLE BLOCK STORAGE DEVICE
;
; THIS SUBROUTINE IS CPU DEPENDENT.  THE FOLLOWING CPU'S ARE SUPPORTED:
;
;	11/780	-DRIVER NAME IS DXDRIVER.  SET IDB BUILT FLAG IN
;		 BOO$GL_CONFLAGS BECAUSE CONSOLE FLOPPY SHARES A
;		 CRB AND IDB WITH THE CONSOLE TERMINAL (OPA0:).
;
;	11/750	-DRIVER NAME IS DDDRIVER.  SET THE SCB VECTOR FLAG IN
;		 BOO$GL_CONFLAGS BECAUSE CONSOLE TU58 INTERRUPTS
;		 THROUGH THE SCB INSTEAD OF THE UBA.
;
;	11/730	- SAME AS 11/750
;
; INPUTS:
;	
;	NONE
;
; OUTPUTS:
;
;	THE FOLLOWING GLOBAL LOCATIONS MAY BE MODIFIED:
;
;		BOO$GL_CONDRV
;		BOO$GL_CONFLAGS
;		BOO$GL_CONCRB
;		BOO$GL_CONVECT
;		BOO$GL_CONUNITS
;--

IOGEN$CONSOLE::
	CPUDISP	<CONSOLE_780,-		;*DISPATCH ON CPU TYPE*
		 CONSOLE_750,-
		 CONSOLE_730,-			;FOR 11/730:
		>

CONSOLE_780:					;FOR 11/780:
	MOVAB	W^BOO$GT_DXNAME,W^BOO$GL_CONDRV	; POINT TO DRIVERNAME
	MOVB	#ACF$M_CRBBLT,W^BOO$GL_CONFLAGS	; SET CRB BUILT FLAG
	MOVAB	G^OPA$CRB,W^BOO$GL_CONCRB	; STORE CRB ADDRESS
	BRB	CONSOLE_END

CONSOLE_730:				; For 11/730
	MOVL	#2,W^BOO$GL_CONNUMU	; Set number of TU58 units to 2
	MOVL	#3,W^BOO$GL_CONUNITS	; Set max units (OPA0 is 1st unit)
CONSOLE_750:					;FOR 11/750:
	MOVAB	W^BOO$GT_DDNAME,W^BOO$GL_CONDRV	; POINT TO DRIVERNAME
	MOVB	#ACF$M_SCBVEC,W^BOO$GL_CONFLAGS	; SET SCB VECTOR FLAG
	MOVZBL	#^XF0,W^BOO$GL_CONVECT		; SET SCB VECTOR OFFSET

CONSOLE_END:				;*END OF CPU DEPENDENT CODE*

	RSB
	.END
