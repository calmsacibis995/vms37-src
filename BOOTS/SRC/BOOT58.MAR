	.TITLE	BOOT58 - Bootstrap command processor
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	Bootstrap command processing module
;
; ENVIRONMENT:
;
;	Runs at IPL 31, kernel mode, memory management is OFF, IS=1
;	(running on interrupt stack), and code must be PIC.
;
; ABSTRACT:
;
;	This module gains control from the boot block 0 code. The module
;	processes commands entered interactively from the console
;	terminal, or commands contained in command procedure files on
;	the boot device.
;
; AUTHOR:
;
;	Carol Peters	22 March 1979
;
; MODIFIED BY:
;
;	Steve Jeffreys	04-DEC-1979
;		- Added documentation for indirect command file processing.
;		- Echo command line for indirect command files.
;		- Added HELP command.
;		- Added BOOT command.
;		- Fixed D/I command.
;		- Added /B size qualifier.
;		- Make START command invalidate the Translation Buffer
;		  before JMPing to the new image.
;--

	.SBTTL	Declarations

;
; Macros
;

	$DSCDEF				; String descriptor definitions
	$PRDEF				; Processor registers
	$RPBDEF				; RPB definitions
	$SSDEF				; Status code definitions
	$TPADEF				; TPARSE field definitions

;
; Macro to print messages to terminal.
;

	.MACRO	MSG,STR
	BSBW	BOO$FACMSG
	.ASCIZ	\'STR'\
	.ENDM	MSG

;
; Equated symbols:
;

	CAR_RETURN	= 13		; ASCII carriage return code.
	FORM_FEED	= 12		; ASCII form feed code.
	VERTICAL_TAB	= 11		; ASCII vertical tab.
	LINE_FEED	= 10		; ASCII linefeed code.
	NULL		= 0		; ASCII null character code.

	SADEBUG		= 1		; Include XDELTA in image.
	SAENVIRON	= 1		; Operating standalone.
	TSDEBUG		= 0		; Include DEBUG in image.

	_VIELD	CMD,0,<-		; Command details bit defs.
		<LOADCMD,,M>,-		; Load command.
		<STARTCMD,,M>,-		; Start command.
		<EXAMCMD,,M>,-		; Examine command.
		<DEPOSCMD,,M>,-		; Deposit command.
		<HELPCMD,,M>,-		; Help command.
		<BOOTCMD,,M>,-		; Boot command.
		<CMDFILCMD,,M>,-	; Indirect command file.
		<INDIRECT,,M>,-		; Processing indirect file.
		<PHYSICAL,,M>,-		; Physical address.
		<GENERAL,,M>,-		; General register.
		<INTERNAL,,M>,-		; Internal processor register.
		<LONG,,M>,-		; Longword length field.
		<WORD,,M>,-		; Word length field.
		<BYTE,,M>,-		; Byte length field.
		<NULLDEV,,M>,-		; Null boot device
		>

	NUM_OF_CMDS	= 7		; # of commands 
	MAX_PROC_REG	= ^X3F		; Highest processor register.

	SAVED_R0	= 0		; Offset to registers saved on
	SAVED_R1	= 1		; stack.
	SAVED_R2	= 2
	SAVED_R3	= 3
	SAVED_R4	= 4
	SAVED_R5	= 5
	SAVED_R6	= 6
	SAVED_R7	= 7
	SAVED_R8	= 8
	SAVED_R9	= 9
	SAVED_R10	= 10
	SAVED_R11	= 11
	SAVED_AP	= 12
	SAVED_FP	= 13
	SAVED_SP	= 14
	SAVED_PC	= 15

;
; BOOT58 resides in the upper quarter of the 64K bytes of good memory
; available during bootstrap operations. The BOOT58 location allows
; VMB to be loaded at <base of memory + ^X200> as usual, and also
; permits the diagnostic supervisor to be loaded at
; <base of memory + ^XE000>. If BOOT58 grows in size, it may be
; necessary to lower its address.
;

	BOOT58_OFFSET	= ^XC000	; Offset to BOOT58 from start
					; of good memory.

;
; Own storage.
;

	.PSECT	BOOT58_DATA,LONG	; Data PSECT.

PARAM_BLOCK:				; Parser parameter block.
	.BLKB	TPA$K_LENGTH0

GOODMEM_BASE:				; Base address of good memory.
	.LONG	0

FIRST_FREE_BYTE:			; Address of first free byte
	.LONG	0			; past BOOT58.

COMMAND_FLAGS:				; Mask describing details of
	.LONG	0			; current and previous commands.

CURRENT_ADDRESS:			; Address field of this EXAMINE
	.LONG	0			; or DEPOSIT command.

LAST_ADDRESS:				; Address field of last EXAMINE
	.LONG	0			; or DEPOSIT command.

LAST_VALUE:				; Last value displayed.
	.LONG	0

SAVED_VALUE:				; Holds a value.
	.LONG	0

REGISTER_TABLE:				; Address of register values.
	.LONG	0

HOLD_DEPOSIT:				; Value to be deposited in
	.LONG	0			; DEPOSIT command.

START_ADDRESS:				; Address given in START or
	.LONG	0			; LOAD command.

FILE_DESCRIP:				; Descriptor of file spec.
	.LONG	0,0

HELP_FILE_SPEC:				; Help file name string.
	.ASCII	/CONSOL.HLP/

HELP_FILE_DESCRIP:			; File descripter for HELP file.
	.LONG	10			; 	File spec length
	.LONG	0			;	File spec address

DEFBOO_SPEC:				; Default boot command file spec
	.ASCII /DEFBOO.CMD/		;

DEFBOO_DESCRIP:				; Default boot command file descripter
	.LONG	10			;  	File spec length
	.LONG	0			;	File spec address

BOOTFILE_SPEC:				; Boot command file spec
	.ASCII /XXXBOO.CMD/		;

BOOTFILE_DESCRIP:			; Boot command file descripter
	.LONG	10			;	File spec length
	.LONG	0			;	File spec address

DEV_SPEC:				; Device spec
	.BLKB	5			; 	Allow only 5 characters

DEV_DESCRIP:				; Device descripter
	.LONG	0			;	Device spec length
	.LONG	0			;	Device spec address

UNIT_NUMBER:				; Boot device unit number
	.LONG	0			;	Values 0..9

FILE_SPEC:				; Address of file specification.
	.BLKB	64

COMMAND_BUFFER:				; Command buffer.
	.BLKB	200

CMD_BUFFER_SIZE	= .-COMMAND_BUFFER-4	; Length of command buffer.
					; (Allow 4 bytes for LINE_TERM)

COMMAND_STRING:				; Command string buffer.
DIREC_BUFFER:				; RT-11 directory buffer.
	.BLKB	1024

CMD_STRING_SIZE	= .-COMMAND_STRING	; Length of command string.

IND_CMDBUFFER:				; Indirect command file buffer.
	.BLKB	512

IND_CMDBUF_PTR:				; Pointer to next byte to read
	.LONG	0			; in indirect command buffer.

IND_W_BLKS_LEFT:			; number of blocks left to read
	.WORD	0			; in command file

IND_W_NEXT_LBN:				; Next LBN to read from indirect
	.WORD	0			; command file.

SAVED_STATUS:				; Temp storage of exit status
	.BLKW	1

IN_COMMAND_FILE:			; Used as boolean
	.BLKB	1

PROMPT_STRING:				; BOOT58's prompt string.
	.ASCIZ	<CAR_RETURN><LINE_FEED>/BOOT58>/

LINE_TERM:				; Line terminator for lines to be echoed.
	.ASCIZ	<CAR_RETURN><LINE_FEED><NULL>

OUTPUT_BUFFER:				; FAO output buffer.
	.BLKB	40

OUTBUF_LENGTH	= .-OUTPUT_BUFFER	; Length of FAO output buffer.

W_FAO_OUT_LEN:				; Location to hold length of
	.WORD	0			; FAO output string.

LONG_PHY_FORMAT:			; FAO control string.
	.ASCII	%!/!_P  !8XL  !8XL%	; Display a hex longword.

FORMAT_LENGTH	= .-LONG_PHY_FORMAT	; Length of FAO format string.

OUTPUT_FORMAT:				; String in which to store a
	.BLKB	FORMAT_LENGTH		; dynamic output format.

B_ERROR_OUT:				; Error message already output
	.BYTE	0			; for this command.

B_ENVIRON_SAFE:				; Flag saying that an exception
	.BYTE	0			; occurred during parse.

L_OLD_STACKP:				; Location to save stack
	.LONG	0			; pointer in case of exceptions.

DRIVER_SUBROUT::			; Holds address of device ROM
	.LONG	0			; driver subroutine.

;
; Declarations for the aid of XDELTA.
;

	.PSECT	__Z99BOOT,Page		; PSECT that always links at end
					; of this program.

BOOTHIGH:				; Symbol to mark the start of
					; the first page after the code
					; in this module.

	.IF	NE,SADEBUG		; If XDELTA is included,
EXE$MCHKVEC	== BOOTHIGH+4		; define a symbol used by XDELTA
	.ENDC				; to locate the SCB.

	.SBTTL	Parse tables
;
; The following documenation is taken from the help file that is printed
; by BOOT58 via the HELP command.
;

;++
; GENERAL:
;
; <location>	::= <value> ! <register>
;
; <value>	::= <number> ! <shorthand>
;
; <number>	::= Any nonnegative HEXADECIMAL number.
;
; <register>	::= 0..F
;
; <shorthand>	::= Any one of the following:
;			"*" - use LAST <location> specified
;			"+" - use (LAST <location>) + 1
;			"-" - use (LAST <location>) - 1
;			"@" - use contents of (LAST <location>) 
;
; <loc_qual>	::= Any one of the following:
;			"/P" - physical memory address
;			"/G" - general register
;			"/I" - internal processor register
;
; <size_qual>	::= Any one of the following:
;			"/L" - size = longword
;			"/W" - size = word
;			"/B" - size = byte
;
; <devspec>	::= A device spec of the form: DDCU, where
;			DD = Generic device type (eg. DB)
;			C  = controller designator (A ! B)
;			U  = unit number (0..9)
;
; <filespec>	::= A legal RT-11 filename of the form: NAME.TYP, where
;			NAME = any alphanumeric string of not more than 6 chars.
;			TYP  = any alphanumeric string of not more than 3 chars.
;			       a null TYP is acceptable.
;
; BOOT58 COMMANDS:
;
; BOOT [<devspec>]
;
;	Boot from the device specified.  If no device is specified, boot from
;	the default boot device.  This command cannot be used within an indirect
;	command  file.
;
;
; DEPOSIT [<loc_qual><size_qual>] <location> <value>
;
;	Deposit <value> at the location specifed by <location>.
;	The <location> is interpreted according to the qualifiers.
;
;
; EXAMINE [<loc_qual><size_qual>] <location>
;
;	Display the contents of <location>, where <location> is interpreted
;	according to the qualifiers.
;
;
; HELP
;
;	Print this text at the console.  This command cannot be used within
;	an indirect command file.
;
; LOAD <filespec>[/START:<value>]
;
;	Load a file from the boot device into memory starting at the address
;	specified <number>.  If no starting location is specified, load the
;	file beginning at the first free location in memory.
;
;
; START <value>
;
;	JMP to <value>.
;
;
; NOTE:
;
;	All BOOT58 commands may be abbreviated to the least amount of 
;	significant characters.  Since the first character of each command
;	is unique, this means all commands may be abbreviated to the one
;	character.  For example, the BOOT command may be entered as "B".
;
;	Some processor registers are either read or write only.  Attempting
;	the wrong operation (ie. E/I <write_only_reg>) on such a register
;	will yield unpredictable results.
;--


	$INIT_STATE -			; Start of TPARSE state table.
		BOOT58_TABLE,KEY_TABLE	; Name of state and keyword
					; table.

;
; Define a command line.
;

	$STATE
	$TRAN	!VALID_COMMAND,-	; Accept valid command.
		TPA$_EXIT,-
		EXECUTE_COMMAND
	$TRAN	TPA$_EOS,TPA$_EXIT	; Accept null command.

;
; Parse a valid command, which is a syntactically-correct command
; followed immediately by end of line.
;

	$STATE	VALID_COMMAND		; Accept valid command.
	$TRAN	!LOADCMD,,SET_LOAD_FLAG	; Set flag for load command.
	$TRAN	!STARTCMD,,-		; Set flag for start command.
		SET_START_FLAG
	$TRAN	!EXAMINECMD,,-		; Set flag for examine command.
		SET_EXAM_FLAG
	$TRAN	!DEPOSITCMD,,-		; Set flag for deposit command.
		SET_DEPOS_FLAG
	$TRAN	!HELPCMD,,SET_HELP_FLAG	; Set flag for help command.
	$TRAN	!BOOTCMD,,SET_BOOT_FLAG	; Set flag for boot command.
	$TRAN	!CMDFILE,,-		; Set flag for indirect command
		SET_CMDFIL_FLAG		; file.
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT	; End command with end of line.

;
; Load command.
;

	$STATE	LOADCMD			; Command that loads a file
					; into memory.
	$TRAN	'LOAD'			; Command verb.
	$STATE
	$TRAN	!FILESPEC,,MOV_FILESPEC	; Parse file specification.
	$STATE	
	$TRAN	!LOAD_QUAL,TPA$_EXIT	; Optional start address.
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	; Null start address.

;
; Start command.
;

	$STATE	STARTCMD		; Command that starts executing
					; code at a given address.
	$TRAN	'START'			; Command verb.
	$STATE
	$TRAN	!EXPLICIT_VALUE,-	; Starting address.
		TPA$_EXIT,SET_STARTADDR

;
; Examine command.
;

	$STATE	EXAMINECMD		; Command that displays the
					; contents of some location.
	$TRAN	'EXAMINE'		; Command verb.
	$STATE
	$TRAN	!EXADEP_QUAL		; Parse qualifiers
	$STATE
	$TRAN	!ANY_VALUE,TPA$_EXIT,-	; Examine special location.
		EXADEP_ADDR

;
; Deposit command.
;

	$STATE	DEPOSITCMD		; Command to deposit data in
					; a word or longword location.
	$TRAN	'DEPOSIT'		; Command verb.
	$STATE
	$TRAN	!EXADEP_QUAL		; Parse qualifiers
	$STATE
	$TRAN	!EXPLICIT_VALUE,,-	; Specify special location
		EXADEP_ADDR
	$STATE
	$TRAN	!EXPLICIT_VALUE,-	; Specify data to be deposited.
		TPA$_EXIT,DEPOSIT_VALUE

;
; Examine and deposit qualifiers.
;

	$STATE	EXADEP_QUAL		; Qualifiers.
	$TRAN	!LOC_QUAL		; Location qualifiers
	$TRAN	TPA$_LAMBDA		; Allow null location qualifier
	$STATE
	$TRAN	!SIZE_QUAL,TPA$_EXIT	; Size qualifiers

;
; Location qualifers.
;
	$STATE	LOC_QUAL
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE
	$TRAN	'G',TPA$_EXIT,SET_GENERAL
	$TRAN	'I',TPA$_EXIT,SET_INTERNAL
	$TRAN	'P',TPA$_EXIT,SET_PHYSICAL

;
; Size qualifiers
;
	$STATE	SIZE_QUAL
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE
	$TRAN	'L',TPA$_EXIT,SET_LONG
	$TRAN	'W',TPA$_EXIT,SET_WORD
	$TRAN	'B',TPA$_EXIT,SET_BYTE
;
; Numeric value.
;

	$STATE	NUMBER			; Accept a hexadecimal value.
	$TRAN	TPA$_HEX,TPA$_EXIT
	$TRAN	'@',TPA$_EXIT,-		; Accept an at sign meaning
		USE_LAST_VALUE		; last value displayed.

;
; Special location for an examine command.
;

	$STATE	ANY_VALUE		; Accept a special character
					; indicating a location.
	$TRAN	!EXPLICIT_VALUE,-	; Accept a deposit location.
		TPA$_EXIT
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,-	; Or accept a null examine
		USE_NEXT_ADDR		; location, meaning "next".

;
; Special location for an examine or deposit command.
;

	$STATE	EXPLICIT_VALUE		; Accept "*", "+", or "P".
	$TRAN	!NUMBER,TPA$_EXIT	; Accept any number.
	$TRAN	'*',TPA$_EXIT,-		; Use location used in last
		USE_LAST_ADDR		; examine or deposit command.
	$TRAN	'+',TPA$_EXIT,-		; Use next sequential location
		USE_NEXT_ADDR		; a word or longword from last
					; location.
	$TRAN	'-',TPA$_EXIT,-		; Use previous address
		USE_PREVIOUS

;
; Parse a file specification for the LOAD command and for indirect
; files.
;

	$STATE	FILESPEC		; Untangle a file specification.
	$TRAN	TPA$_STRING		; Parse a file name.
	$STATE
	$TRAN	'.'			; Starts with a dot.
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	; Accept null file type.
	$STATE
	$TRAN	TPA$_STRING,TPA$_EXIT	; Ends in a normal string.
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	; Can be null file type too.

;
; Load qualifier.
;

	$STATE	LOAD_QUAL		; Process /START qualifier.
	$TRAN	'/'			; Starts with a slash.
	$STATE
	$TRAN	'START'			; Then the word 'START'.
	$STATE
	$TRAN	':'			; Then a colon.
	$STATE
	$TRAN	!EXPLICIT_VALUE,-	; Then a start address.
		TPA$_EXIT,SET_STARTADDR
;
; Help command.
;
	$STATE	HELPCMD			; Print help text at console
	$TRAN	'HELP'			; Command verb
	$STATE	
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	; No text expected after 'HELP'

;
; Boot command.
;
	$STATE	BOOTCMD			; Boot from default boot file
	$TRAN	'BOOT'			; Command verb
	$STATE
	$TRAN	!DEVSPEC,TPA$_EXIT,SAV_DEVSPEC	; Parse device spec 
	$TRAN	TPA$_EOS,TPA$_EXIT,-	; Accept null device spec
		,CMD_M_NULLDEV,COMMAND_FLAGS

;
; Device spec.
;
	$STATE	DEVSPEC			; 3 character device spec
	$TRAN	!DEVICE_TYPE		; Get the generic device type
	$STATE	
	$TRAN	!CONTROLLER		; Get the controller designater
	$STATE
	$TRAN	TPA$_DECIMAL,,,,UNIT_NUMBER ; Get unit number
	$STATE
	$TRAN	':',TPA$_EXIT		; Parse optional colon
	$TRAN	TPA$_LAMBDA,TPA$_EXIT


;
; Device types.
;
	$STATE	DEVICE_TYPE		; Parse the 2 char generic device type
	$TRAN	TPA$_ALPHA		; Get first char
	$STATE
	$TRAN	TPA$_ALPHA,TPA$_EXIT	; Get second char


;
; Parse the 1 char contoller designator.
;
	$STATE	CONTROLLER		; Parse a controller spec
	$TRAN	'A',TPA$_EXIT
	$TRAN	'B',TPA$_EXIT




;
; Indirect command files.
;

	$STATE	CMDFILE			; Locate and execute a command
					; file.
	$TRAN	'@'			; Starts with at sign.
	$STATE
	$TRAN	!FILESPEC,TPA$_EXIT,-	; A file specification must
		MOV_FILESPEC		; follow.

	$END_STATE			; End of syntax tables.

;
; Declare a code PSECT that will always link at the start of the image.
;

	.PSECT	$$$$00BOOT,LONG

	.SHOW	EXPANSIONS

	.DEFAULT DISPLACEMENT, WORD

	.SBTTL	SETUP_BOOT58 - Set up boot environment

;++
; Functional description:
;
;	When this program gains control, no SCB or RPB exists. This
;	routine identifies space for an SCB in the first free page
;	of memory following this program. The routine fills each 
;	longword in the SCB with the address of a fault handler.
;	Then the routine loads the SCB address into the SCBB processor
;	register.
;
;	If the user requested XDELTA via a software boot control flag,
;	the routine then loads 2 SCB longwords with XDELTA handlers,
;	and creates the first entry in the XDELTA breakpoint table.
;
;	If the boot flag requested an initial breakpoint, the routine
;	then executes a BPT instruction, which passes control to
;	XDELTA.
;
;	This routine then calls BOOT58 -- the command processor -- to
;	accept and process commands from the console terminal.
;
; Inputs:
;
;	R5	- software boot control flags
;
;		Bit	Meaning
;		---	-------
;
;		 5	RPB$V_BOOBPT.
;			Bootstrap breakpoint. Stops BOOT58 in XDELTA
;			before accepting commands.
;
;	R6	- address of device ROM driver subroutine
;
;	SP	- <base_address + ^X200> of 64kb of good memory
;
; Implicit inputs:
;
;	BOOT_FAULT	- address of a fault handler
;	BOOTHIGH	- address of the first free byte beyond BOOT58
;			  code and data
;
;	When SETUP_BOOT58 gains control, physical memory looks like
;	the diagram below:
;
;	SP-^X200:	+--------------------------------------+
;			|             boot block 0             |
;	SP:		+--------------------------------------+
;			|                                      |
;			|                unused                |
;			|                                      |
;	SP+^XBE00:	+--------------------------------------+
;			|       Primary bootstrap (BOOT58)     |
;	BOOTHIGH:	+--------------------------------------+
;			|                                      |
;			|                unused                |
;			|                                      |
;			+--------------------------------------+
;
; Implicit outputs:
;
;	DRIVER_SUBROUT	- address of the driver subroutine
;	START_ADDRESS	- <base of good memory + ^X200>
;	GOODMEM_BASE	- base address of 64K bytes of good memory
;	FIRST_FREE_BYTE	- address of first free byte past BOOT58
;	PR$_SCBB	- address of an SCB filled with handler address
;
;	When SETUP_BOOT58 exits to the BOOT58 command processor,
;	physical memory looks like the diagram below:
;
;	base+0:		+--------------------------------------+
;			|              boot block 0            |
;	base+^X200:	+--------------------------------------+
;			|                                      |
;			|                 unused               |
;			|                                      |
;	base+^XC000:	+--------------------------------------+
;			|                                      |
;			|                 BOOT58               |
;			|                                      |
;	BOOTHIGH:	+--------------------------------------+
;			|                 stack                |
;	SP:		+--------------------------------------+
;
;--

	.IF	NE,SAENVIRON		; If operating standalone,
					; include this routine.

SETUP_BOOT58:				; Prepare a boot environment.

;
; Save the contents of R6. This is the address of the device ROM driver
; subroutine. BOOT58 needs this later to read files from the TU58
; device.
;

	MOVL	R6,DRIVER_SUBROUT	; Save driver address.

;
; The BOOT58 program is loaded at ^XC000 bytes past the start of good
; memory. This permits VMB or other primary bootstraps to be loaded at
; the familiar ^X200 offset. Adjust SP for now to create SCB and stack.
; Save address of the base of good memory, and default start address.
;

	MOVL	SP,START_ADDRESS	; Save original SP as user's
					; default load address.
	MOVAB	-^X200(SP),GOODMEM_BASE	; Save base of good memory too.
	ADDL2	#<BOOT58_OFFSET-^X200>,-; Offset SP to address start of
		SP			; BOOT58 code.

;
; Reserve space for a System Control Block (SCB) immediately after the
; BOOT58 code. Write the address of a machine check fault handler in
; all vectors in the SCB. This handler is used during bootstrapping
; except when the bootstrap code specifically writes a different
; handler address in one of the SCB vectors.
;
; The low bit set in the address of the fault handler causes the
; handler to execute on the interrupt stack.
;

	MOVAB	BOOT_FAULT+1,R6		; Get the address of a handler.
	MOVAB	BOOTHIGH+^X200,R7	; Get the address of the first
					; byte past the SCB.

FILL_SCB:				; Fill the SCB.
	MOVL	R6,-(R7)		; Write 1 vector.
	BITW	#^X1FF,R7		; Check for page boundary.
	BNEQ	FILL_SCB		; Not yet. Write another vector.
	MTPR	R7,#PR$_SCBB		; SCB full. Write SCB address
					; into processor register.

;
; Create a stack, and save the address of the first free byte past the
; space used by BOOT58 and its supporting environment.
;

	MOVAB	<4*^X200>(R7),SP	; Create a 3 page stack.
	MOVL	SP,FIRST_FREE_BYTE	; Save address of 1st byte of
					; free physical memory.

;
; If XDELTA is linked into this program, set up 2 XDELTA handlers in
; the SCB -- for breakpoint and trace trap. Then initialize the XDELTA
; breakpoint table, and, if requested, execute a breakpoint before
; proceeding with the bootstrap.
;

	.IF	NE,SADEBUG		; If XDELTA is linked, do next.
	MOVAB	XDELBPT,^X2C(R7)	; Plug BPT handler.
	MOVAB	XDELTBIT,^X28(R7)	; Plug trace trap handler.
	MOVAB	INI$BRK,XDELIBRK	; Store initial breakpoint.
	BBC	#RPB$V_BOOBPT,R5,-	; If no breakpoint is wanted,
		NOBRK			; just continue in BOOT58.

;
; Initial breakpoint. Registers usage is as follows:
;
;	R0-R5	- unchanged
;	R6	- address (+1) of a bootstrap fault handler
;	R7	- address of the SCB
;	R8-R11	- unchanged
;	AP-FP	- unchanged
;	SP	- address of a 3-page stack
;

INI$BRK::				; Breakpoint
	BPT				; Stop in XDELTA.

NOBRK:					; Proceed with BOOT58.
	.ENDC				; End of XDELTA conditional.

;
; The environment is okay. Now call the command processor.
;

	CALLS	#0,BOOT58		; Accept and process commands.
	HALT				; For now, just halt on return.

	.ENDC				; End of standalone conditional.

	.SBTTL	BOOT58 - Process bootstrap commands

;++
; Functional description:
;
;	The command processor saves current register values, sets a
;	command options longword to a default state, and then accepts
;	commands until a START command transfers control to some other
;	program, or the user types <control-P> to return control to the
;	CONSOLE program.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- a location to hold the default or modified
;			  command options.
;	PARAM_BLOCK	- address of the TPARSE parameter block. Fields
;			  of interest are the following:
;
;		TPA$L_COUNT	- # of longwords in block
;		TPA$L_OPTIONS	- TPARSE flag bits
;
;				  TPA$M_BLANKS - treat blanks explicitly
;						 instead of invisibly
;				  TPA$M_ABBREV - permit abbreviations
;
;		TPA$L_STRINGCNT	- # characters remaining in input string
;		TPA$L_STRINGPTR	- address of remainder of input string
;		TPA$L_TOKENCNT	- # characters in current token
;		TPA$L_TOKENPTR	- address of current token
;		TPA$L_CHAR	- character matched by a single
;				  character symbol type
;		TPA$L_NUMBER	- binary value of a numeric token
;		TPA$L_PARAM	- 32-bit parameter from state transition
;
;	TPA$K_LENGTH0	- # bytes in TPARSE parameter block
;	COMMAND_STRING	- buffer for input string
;	COMMAND_BUFFER	- buffer for a single line of input
;	CMD_BUFFER_SIZE	- length of buffer for single line of input
;	BOO$GQ_CMDESC	- string descriptor for RMS input
;	KEY_TABLE	- address of TPARSE keyword table
;	BOOT58_TABLE	- address of TPARSE state table
;
; Outputs:
;
;	R0-FP	- original or user-modified values
;
;--

	.ENTRY	BOOT58,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

;
; Save R1-PC on the stack. Store the stack address
; of saved R0 in own storage.
;

	MOVL	SP,CURRENT_ADDRESS	; Save SP in own storage.
	PUSHL	#0			; Then push a 0 to represent the
	PUSHL	CURRENT_ADDRESS		; original PC, and push SP.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,-	; Save all the other registers
		R6,R7,R8,R9,R10,R11,-	; on the stack too.
		AP,FP>
	MOVL	SP,REGISTER_TABLE	; Save address of saved register
					; values.

;
; Initialize the mask that describes default address interpretation
; and value display mode.
;

	CLRL	COMMAND_FLAGS		; Initialize command settings.
	BISL	#CMD_M_PHYSICAL,-	; Set to interpret addresses
		COMMAND_FLAGS		; as physical.
	MOVL	SP,L_OLD_STACKP		; Save current stack pointer to
					; allow restoration on
					; exceptions.
	MOVB	#1,B_ENVIRON_SAFE	; Note that environment is
					; initialized.

	MOVAL	HELP_FILE_SPEC,-	; Set up help fie descripter
		HELP_FILE_DESCRIP+4	;
	MOVAL	DEFBOO_SPEC,-		; Set up defalut boot command file spec
		DEFBOO_DESCRIP+4	;
	MOVAL	BOOTFILE_SPEC,-		; Set up optional boot command file spec
		BOOTFILE_DESCRIP+4	;

READ_COMMAND:				; Main command processing loop.
	MOVAB	PARAM_BLOCK,R7		; Get parameter block address.

;
; Initialize string buffer address and length in the TPARSE parameter
; block. Then transfer a 1 to n line command into the string buffer.
;

	CLRL	TPA$L_STRINGCNT(R7)	; Initialize string length.
	MOVAB	COMMAND_STRING,-	; Initialize string buffer
		TPA$L_STRINGPTR(R7)	; address.

;
; Check for non-interactive input: if taking commands from an indirect
; file, the file is in memory. Call a routine to get the next record.
;

READ_A_LINE:				; Process one line.
	BBC	#CMD_V_INDIRECT,-	; If processing interactive
		COMMAND_FLAGS,10$	; commands, branch.
	JSB	GET_A_RECORD		; For indirect, get a record.
	BLBC	R0,20$			; Branch if error
;
; Put out a <cr><lf>.
;
	CLRQ	-(SP)			; Create a null descrptor
	PUSHAB	LINE_TERM		; Address of <cr><lf>
	CALLS	#0,BOO$READPROMPT	; "Print" the <cr><lf>
	BLBC	R0,20$			; Branch if error
;
; Echo the command line to the console.  A special ASCIZ string is put
; on the end of the buffer to cause a <cr><lf> after printing the line.
;
	MOVZBL	(R2),R1			; Restore R1 (overwritten by BOO$READPROMPT)
	MOVAB	COMMAND_BUFFER+1,R4	; Get address of first char
	ADDL3	R1,R4,R0		; Calculate address of last char
	MOVL	LINE_TERM,(R0)		; Put line term past last char
	CLRQ	-(SP)			; Create null descripter
	PUSHL	R4			; Push address of first char
	CALLS	#3,BOO$READPROMPT	; Echo command line
	BRB	20$			; Go check for success.

;
; Interactive input from console terminal:
;
; Load an input buffer address, length in bytes, and address of a prompt
; string onto the stack. Then call a subroutine to prompt for and read
; an input line from the terminal. If the read fails, return to the
; caller with an error status code.
;

10$:					; Interactive input.
	MOVAB	COMMAND_BUFFER,R2	; Get address of command buffer.
	PUSHL	R2			; Push address on stack.
	MOVZBL	#CMD_BUFFER_SIZE,-(SP)	; Push buffer size on stack.
	PUSHAB	PROMPT_STRING		; Push prompt address on stack.

;
; If debugging with DEBUG in a timesharing environment, set up an
; RMS input descriptor for BOO$READPROMPT.
;

	.IF	NE,TSDEBUG
	CLRL	BOO$GQ_CMDESC		; Zero the # chars in buffer.
	.ENDC

	CALLS	#3,BOO$READPROMPT	; Prompt for and read an input
					; line.

20$:					; Check for error on input.
	BLBS	R0,GOT_A_LINE		; Branch on success.
	RET				; Return to caller on failure.

;
; The command buffer holds an input line. Calculate the 1st free byte
; in the output buffer. One character at a time, copy the characters
; in the input buffer into the output buffer.
;

GOT_A_LINE:				; Process an input line.
	ADDL3	TPA$L_STRINGPTR(R7),-	; Add start of output buffer to
		TPA$L_STRINGCNT(R7),R3	; to count of characters in that
					; buffer to point to free byte.
	MOVZBL	(R2)+,R0		; Get length of input line.
	BEQL	READ_A_LINE		; If null line, get another.
	MOVL	R2,R1			; Need input buffer address in
					; R1 for a LOCC instruction.

;
; Pick up one character at a time. If a hyphen, this may be a
; continuation line; branch to special handler. If an exclamation
; point, this is a comment; skip characters until end of comment.
; Otherwise, increment the character count, store the characters in
; the output buffer, decrement the count of input characters left,
; and, if count is nonzero, loop through here again.
;

GET_A_CHARACTER:			; Loop to read characters.
	MOVZBL	(R1)+,R2		; Get a character.
;	CMPB	#^A/-/,R2		; Might this be continuation?
;	BEQL	HYPHEN_IN_LINE		; Yes. Go process it.
	CMPB	#^A/!/,R2		; Is this a comment?
	BEQL	BYPASS_COMMENT		; Yes. Go bypass it.

;
; Normal character. Increment count in TPARSE parameter block, and
; write character to output buffer. Then loop for next character
; unless input line exhausted.
;

	INCL	TPA$L_STRINGCNT(R7)	; Increment character count.
	MOVB	R2,(R3)+		; Write output character.

MORE_CHARS:				; See if more characters.
	SOBGTR	R0,GET_A_CHARACTER	; Decrement character count,
					; branch if line not finished.
	BRB	PARSE_COMMAND		; Command all collected. Go
					; parse the command.

;
; Comment character: skip all characters until another exclamation
; point or end of line. A second exclamation point ends the comment,
; and normal character processing can resume. End of line indicates
; that the entire command is in, and the line can be parsed. Note that
; the LOCC instruction updates R1 and R0 appropriately.
;

BYPASS_COMMENT:				; Skip a comment.
	DECL	R0			; Decrement character count
					; for the comment mark.
	LOCC	#^A/!/,R0,1(R1)		; Look for another "!".
	BEQL	PARSE_COMMAND		; None exists. Go parse command.
	INCL	R1			; Found one. Move to next char.
	BRB	MORE_CHARS		; Continue getting characters.

;
; Line continuation character: save current output buffer pointer and
; length for now. Scan characters after the hyphen. If all blanks until
; a comment character or end of line, this is really a continuation
; character. Otherwise, this is just a hyphen (with some other syntactic
; value).
;

HYPHEN_IN_LINE:				; See why a hyphen is here.
	MOVL	R3,R4			; Save output buffer pointer.
	MOVL	TPA$L_STRINGCNT(R7),R5	; Save output char. count.
	MOVB	R2,(R3)+		; Write hyphen into output
					; string.
	INCL	TPA$L_STRINGCNT(R7)	; And count the character.
	BRB	NEXT_CHAR		; See if more characters.

;
; Another character in line. If blank, keep looking. If comment, skip
; over the comment, and then keep looking. If anything but a blank,
; assume the hyphen was NOT a line continuation, and resume normal
; character processing.
;

LOOK_FOR_BLANK:				; Check for blank or "!".
	MOVZBL	(R1)+,R2		; Get next character.
	MOVB	R2,(R3)+		; Store in output string.
	INCL	TPA$L_STRINGCNT(R7)	; Increment output count.
	CMPB	#^A/ /,R2		; Is character a blank?
	BEQL	NEXT_CHAR		; Yes. Move to next char.
	CMPB	#^A/	/,R2		; Is character a tab?
	BEQL	NEXT_CHAR		; Yes. Move to next char.
	CMPB	#^A/!/,R2		; Is character an "!"?
	BEQL	SKIP_COMMENT		; Yes. Move past the comment.
	BRB	MORE_CHARS		; No. This is not a line
					; continuation.

;
; Keep hunting for blank, non-blank, exclamation point, or end of line.
; If character count is exhausted, fall through.
;

NEXT_CHAR:				; See if more characters.
	SOBGTR	R0,LOOK_FOR_BLANK	; If a character, look at it.

;
; Found end of line. Restore the TPARSE parameter block command buffer
; pointer and command character count to their state before the hyphen
; was found. Then go on to read another line.
;

END_OF_LINE:				; Found end of line.
	MOVL	R4,R3			; Restore saved pointer to
	MOVL	R5,TPA$L_STRINGCNT(R7)	; command string and count.
	BRW	READ_A_LINE		; Read another line.

;
; After a hyphen, found a comment delimiter. Search for a comment
; ending delimiter. If find one, go on looking for a blank or non-blank
; to interpret the hyphen. If end of line, just restore command
; pointers and read next line.
;

SKIP_COMMENT:				; Skip command after hyphen.
	DECL	R0			; Ignore the exclamation point.
	LOCC	#^A/!/,R0,1(R1)		; Is there another "!"?
	BEQL	END_OF_LINE		; No. End of line. Go to next.
	INCL	R1			; Yes. Move past it.
	BRB	NEXT_CHAR		; And keep looking for blank.

;
; Parse: initialize parsing state. Push the address of the keyword
; table, the state table, and the TPARSE parameter block onto the
; stack, and call TPARSE.
;

PARSE_COMMAND:				; Command is all here. Parse it.
	MOVL	#TPA$K_COUNT0,-		; ???
		TPA$L_COUNT(R7)
	BISL	#TPA$M_ABBREV,-		; Permit abbreviations in the
		TPA$L_OPTIONS(R7)	; command keywords.
	PUSHAB	KEY_TABLE		; Pass address of keyword table,
	PUSHAB	BOOT58_TABLE		; state table, and
	PUSHL	R7			; TPARSE parameter block.
	CALLS	#3,LIB$TPARSE		; Parse the command.
	BLBS	B_ERROR_OUT,-		; If error message already
		CLEAR_ERRBIT		; output, get next command.
	BLBS	R0,NEXT_COMMAND		; If success, get another.
	MSG	<-E-Syntax error>	; Output error message.

CLEAR_ERRBIT:				; Clear flag.
	CLRB	B_ERROR_OUT		; Clear error output flag.

;
; Branch back through the command loop.
;

NEXT_COMMAND:				; Process another command.
;
; Make sure the command flag was cleared.  The INSV instruction
; will clear all the bits in COMMAND_FLAGS that indicate that a
; command is awaiting execution.
;
	CLRL	R0			; Generate 32 bits of 0's
	INSV	R0,-			; Source
		#CMD_V_LOADCMD,-	; Starting position
		#NUM_OF_CMDS,-		; Length
		COMMAND_FLAGS		; Destination
	BRW	READ_COMMAND

	.SBTTL	GET_A_RECORD - Extracts an RT-11 format record

;++
; Functional description:
;
;	One block of the command file is in memory. A pointer indicates
;	the next byte to be read. This routine collects a record by
;	reading a character a time from memory. If end of block is
;	reached, this routine reads in the next block (if any).
;
;	At end of file, this routine turns off the indirect command
;	file processing flag, and returns a success status code. The
;	outer parser will process the null command and then prompt
;	for further interactive input.
;
;	RT-11 test files are in ASCII stream format. The format is as
;	follows:
;
;		no character count associated with the record
;		the record begins with the ASCII text
;		a record ends in a FF, LF, or VT
;		bytes containing CR or null are ignored
;
; Implicit inputs:
;
;	IND_CMDBUF_PTR	- contains address of next byte to read
;	IND_CMDBUFFER	- starting buffer address of command file buffer
;	512		- number of bytes in command file buffer
;	IND_W_NEXT_LBN	- next LBN in the command file
;	IND_W_BLKS_LEFT	- blocks left to read from the command file
;
; Outputs:
;
;	This routine preserves registers R5-R11.
;
; Implicit outputs:
;
;	COMMAND_BUFFER	- byte 0 is the record size in bytes
;			  bytes 1-n are the ASCII text of the record
;			  buffer contains no FFs, LFs, CRs, or VTs
;
;	The static variables that point to the indirect command file
;	and its data are updated. These variables are:
;
;		IND_CMDBUF_PTR
;		IND_CMDBUFFER
;		IND_W_NEXT_LBN
;		IND_W_BLKS_LEFT
;
;--

GET_A_RECORD:				; Collect 1 record.
	CLRL	R1			; Clear character count.
	MOVL	IND_CMDBUF_PTR,R3	; Get source address.
	MOVAB	COMMAND_BUFFER+1,R2	; Get destination address.
	MOVAB	IND_CMDBUFFER+512,R4	; Get address of 1 byte past end
					; of buffer.

GET_CHAR:				; Read 1 character.
	CMPL	R3,R4			; Are we at the end of buffer?
	BLSSU	20$			; No. Branch to get character.
	TSTW	IND_W_BLKS_LEFT		; Any blocks left to read?
	BLEQ	END_OF_FILE		; No. Process end of file.
	PUSHR	#^M<R1,R2>		; Save R1 and R2
	PUSHAB	IND_CMDBUFFER		; Send address of buffer for a
	PUSHL	IND_W_NEXT_LBN		; block, and an LBN.
	INCW	IND_W_NEXT_LBN		; Increment next block number.
	DECW	IND_W_BLKS_LEFT		; Decrement blocks left.
	CALLS	#2,FIL$READ_LBN		; Read a block.
	POPR	#^M<R1,R2>		; Restore R1 and R2
	BLBS	R0,10$			; Branch on success.
	MSG	<-E-Cannot read file>
	BRB	EXIT_GETRECORD		; Return with the error.

10$:					; New block of file in memory.
	MOVAL	IND_CMDBUFFER,-		; Set up buffer pointer.
		IND_CMDBUF_PTR
	MOVL	IND_CMDBUF_PTR,R3	; Set up in register too.

;
; Register usage below is as follows:
;
;	R0	- holds a character
;	R1	- count of characters collected so far
;	R2	- address of next free byte in output buffer
;	R3	- address of next byte to read
;

20$:					; Buffer is okay. Get a char.
	MOVZBL	(R3)+,R0		; Get a character.
	BEQL	GET_CHAR		; Skip nulls.
	CMPB	R0,#CAR_RETURN		; Carriage return?
	BEQL	GET_CHAR		; Skip them too.
	CMPB	R0,#LINE_FEED		; Line feed?
	BEQL	END_OF_RECORD		; Yes. Branch.
	CMPB	R0,#VERTICAL_TAB	; Vertical tab?
	BEQL	END_OF_RECORD		; Yes. Branch.
	CMPB	R0,#FORM_FEED		; Form feed?
	BEQL	END_OF_RECORD		; Yes. Branch.
	INCL	R1			; Increment character count.
	MOVB	R0,(R2)+		; Save the character.
	BRB	GET_CHAR		; Get the next character.

;
; End of file has been reached. Turn off the indirect command file
; processing flag, and return with success to caller.
;

END_OF_FILE:				; End of command file.
	BICB	#CMD_M_INDIRECT,-	; Clear command file flag in
		COMMAND_FLAGS		; command flag longword.

END_OF_RECORD:				; End of record seen.
	MOVB	R1,COMMAND_BUFFER	; Store record count.
	MOVAB	COMMAND_BUFFER,R2	; Restore output buffer address
					; in a register.
	MOVL	R3,IND_CMDBUF_PTR	; Update buffer pointer.

RETURN_RECORD:				; Successful record collection.
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.

EXIT_GETRECORD:				; Restore registers and return.
	RSB				; Return.

	.SBTTL	Output message routines

;++
; BOO$FACMSG	- Output facility-specific error message
;
; Functional description:
;
;	Calls BOO$MSGOUT to output an error message preceded by a
;	new line and facility name string.
;
; Inputs:
;
;	0(SP)	- address of an ASCIZ message text
;
; Outputs:
;
;	This routine preserves all registers.
;
;--

BOO$FACMSG::
	BSBW	BOO$MSGOUT		; First output facility name.
	.ASCII	<CAR_RETURN><LINE_FEED>	; New line.
	.ASCIZ	/%BOOT58/		; Facility name.
	BRW	BOO$MSGOUT		; Now output message.

;++
;
; BOO$MSGOUT	- Output message on terminal
;
; Functional description:
;
;	Outputs a message on the console terminal.
;
; Inputs:
;
;	0(SP)	- the address of an ASCIZ message string
;
; Outputs:
;
;	B_ERROR_OUT	- has low bit set to indicate that a message
;			  has been output to the terminal
;
;--

BOO$MSGOUT:				; Display message on terminal.
	CLRQ	-(SP)			; Create a null descriptor.
	PUSHL	8(SP)			; Pass as address of buffer.
	CALLS	#3,BOO$READPROMPT	; Output message.
	LOCC	#0,#64000,@(SP)+	; Look for zero at end of ASCIZ
					; message string.
	MOVB	#1,B_ERROR_OUT		; Set a flag saying message has
					; been sent to terminal.
	JMP	1(R1)			; Return to caller.

	.SBTTL	EXECUTE_COMMAND - Execute a single command

;++
; Functional description:
;
;	Determines from the COMMAND_FLAGS settings what command is to
;	be executed. Executes that command, clears the flag bit, and
;	returns.
;
; Inputs:
;
;	AP points to the TPARSE parameter block, which is to be passed
;	along intact to the command-specific action routine.
;
;	COMMAND_FLAGS indicates by a bit setting which command is to
;	be executed.
;
; Outputs:
;
;	R0	- return status from the command execution routine
;
;	This routine BRWs to the relevant routine, and that routine
;	returns to EXECUTE_COMMAND's caller.
;
;--

	.ENTRY	EXECUTE_COMMAND,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	FFS	#CMD_V_LOADCMD,-	; Get the command bit.
		#CMD_V_CMDFILCMD,-
		COMMAND_FLAGS,R0
	BBCC	R0,COMMAND_FLAGS,10$	; Clear the bit.

10$:
	CASE	R0,TYPE=B,<-		; Case on the command.
		LOAD_FILE,-		; Load a file.\
		START_PROGRAM,-		; Start a program.
		EXAMINE_LOC,-		; Examine a location.\
		DEPOSIT_DATA,-		; Deposit data.
		PRINT_HELP,-		; Print help text at console.
		BOOT_UP,-		; Boot the system
		EXECUTE_FILE>		; Execute a command file.

;
; If none of the above, report a fatal error.
;

	MSG	<-F-Parsing error>	; Report parsing error.
	HALT				; Just halt.

	.SBTTL	SET_LOAD_FLAG - Sets the LOAD command flag.

;++
; Functional description:
;
;	Sets the CMD_M_LOADCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_LOADCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_LOAD_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_LOADCMD,-	; Set the LOAD command flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	SET_START_FLAG - Sets the START command flag.

;++
; Functional description:
;
;	Sets the CMD_M_STARTCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_STARTCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_START_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_STARTCMD,-	; Set the START command flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	SET_EXAM_FLAG - Sets the EXAMINE command flag.

;++
; Functional description:
;
;	Sets the CMD_M_EXAMCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_EXAMCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_EXAM_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_EXAMCMD,-	; Set the EXAMINE command flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	SET_DEPOS_FLAG - Sets the DEPOSIT command flag.

;++
; Functional description:
;
;	Sets the CMD_M_DEPOSCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_DEPOSCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_DEPOS_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_DEPOSCMD,-	; Set the DEPOSIT command flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	SET_HELP_FLAG - Sets the HELP command flag.

;++
; Functional description:
;
;	Sets the CMD_M_HELPCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_HELPCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_HELP_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_HELPCMD,-	; Set the HELP command flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	SET_BOOT_FLAG - Sets the BOOT flag.

;++
; Functional description:
;
;	Sets the CMD_M_BOOTCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_BOOTCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_BOOT_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_BOOTCMD,-	; Set the BOOT COMMAND flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	SET_CMDFIL_FLAG - Sets the COMMAND FILE flag.

;++
; Functional description:
;
;	Sets the CMD_M_CMDFILCMD in COMMAND_FLAGS.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Outputs:
;
;	R0	- contains SS$_NORMAL
;
;	CMD_M_CMDFILCMD is set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_CMDFIL_FLAG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISL	#CMD_M_CMDFILCMD,-	; Set the COMMAND FILE flag.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Set success status code.
	RET

	.SBTTL	MOV_FILESPEC - Pick up file specification

;++
; Functional description:
;
;	Moves the full file specification from the input string into
;	a buffer that can be read by the file handling utilities.
;
; Implicit inputs:
;
;	AP points to the TPARSE parameter block, containing:
;
;	TPA$L_TOKENCNT	- number of characters in file specification
;	TPA$L_TOKENPTR	- address of the file specification
;
; Implicit outputs:
;
;	FILE_SPEC	- holds the file specification from the input
;			  command.
;	FILE_DESCRIP	- the 1st word of this quadword holds the
;			  length of the file specification string;
;			  the 2nd longword holds the address of the
;			  file specification string.
;
;--

	.ENTRY	MOV_FILESPEC,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	TPA$L_TOKENPTR(AP),R0	; Get address of input file
					; specification string.
	MOVC3	TPA$L_TOKENCNT(AP),-	; Move file specification
		(R0),FILE_SPEC		; string into own storage.
	MOVAL	FILE_DESCRIP,R1		; Get address of descriptor.
	MOVL	TPA$L_TOKENCNT(AP),-	; Load length field.
		DSC$W_LENGTH(R1)
	MOVAL	FILE_SPEC,-		; Load address field.
		DSC$A_POINTER(R1)
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	SAV_DEVSPEC - Pick up device specification

;++
; Functional description:
;
;	Moves a device specification from the input string into
;	a buffer that can be read by the file handling utilities.
;
; Implicit inputs:
;
;	AP points to the TPARSE parameter block, containing:
;
;	TPA$L_TOKENCNT	- number of characters in file specification
;	TPA$L_TOKENPTR	- address of the file specification
;
; Implicit outputs:
;
;	DEV_SPEC	- holds the device specification from the input
;			  command.
;	DEV_DESCRIP	- the 1st word of this quadword holds the
;			  length of the device specification string;
;			  the 2nd longword holds the address of the
;			  device specification string.
;
;--

	.ENTRY	SAV_DEVSPEC,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	TPA$L_TOKENPTR(AP),R0	; Get address of input file
					; specification string.
	MOVC3	TPA$L_TOKENCNT(AP),-	; Move device specification
		(R0),DEV_SPEC		; string into own storage.
	MOVAL	DEV_DESCRIP,R1		; Get address of descriptor.
	MOVL	TPA$L_TOKENCNT(AP),-	; Load length field.
		DSC$W_LENGTH(R1)
	MOVAL	DEV_SPEC,-		; Load address field.
		DSC$A_POINTER(R1)
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	LOAD_FILE - Load file into memory

;++
; Functional description:
;
;	Opens a file and loads it into memory at the specified or
;	default physical address.
;
; Implicit inputs:
;
;	START_ADDRESS	- address in which to load the file
;	FILE_DESCRIP	- string descriptor of the file
;	CHANNEL_NUMBER	- address into which to store a channel number
;
;	GOODMEM_BASE	- base address of 64K bytes of good memory
;	FIRST_FREE_BYTE	- address of first free byte past BOOT58 space;
;			  this address is past BOOT58, BOOT58's SCB, and
;			  3-page stack.
;
;--

LOAD_FILE:
	CLRQ	-(SP)			; Clear space for a file
	PUSHL	SP			; statistics block. Push address
					; on the stack for a call.
	PUSHAL	DIREC_BUFFER		; Send address of a buffer for
					; RT-11 directory segments.
	PUSHAL	FILE_DESCRIP		; Send descriptor of file.
	CALLS	#3,RTF$OPENFILE		; Look up the file.
	BLBS	R0,READ_FILE		; Branch on successful lookup.
	MSG	<-E-Unable to locate file>
	RET				; And return.

;
; Now read the file into memory, a block at a time. Store the number of
; blocks left to read in R3. The statistics block filled by RTF$OPENFILE
; contains the following:
;
;	+--------------------------+
;	|   starting LBN of file   |
;	+--------------------------+
;	| number of blocks in file |
;	+--------------------------+
;

READ_FILE:				; Read in the file.
	MOVL	4(SP),R3		; Get number of blocks in file.
	MOVL	GOODMEM_BASE,R4		; Get base of good memory.
	CMPL	START_ADDRESS,R4	; Is the start address in good
	BLSSU	20$			; memory? Branch if not.
	CMPL	START_ADDRESS,-		; Is the start address below
		BOOT58_OFFSET(R4)	; the start of BOOT58 code?
	BGEQU	10$			; No. See if it's past BOOT58.
	ASHL	#9,R3,R5		; Get number of bytes in file.
	ADDL2	START_ADDRESS,R5	; Get final load address + 1.
	CMPL	R5,BOOT58_OFFSET(R4)	; Breaking into BOOT58?
	BLEQU	30$			; No. Go load the code.
	BRB	20$			; Yes. Report no fit error.

10$:					; See if loading past BOOT58.
	CMPL	START_ADDRESS,-		; Is the start address past
		FIRST_FREE_BYTE		; BOOT58's memory usage?
	BGEQU	30$			; Yes. Branch to load code.

20$:					; Invalid start address.
	MSG	<-E-Memory in use, choose a different address>
	RET				; And return.

30$:					; Load the program.
	PUSHL	START_ADDRESS		; Address to receive file.
	PUSHL	4(SP)			; LBN to read.
	PUSHL	#2			; Number of arguments.

READ_BLOCK:				; Read one block.
	CALLG	(SP),FIL$READ_LBN	; Read one block.
	BLBS	R0,NEXT_BLOCK		; Branch on successful read.
	MSG	<-E-Cannot read file>
	RET				; Return with error status.

NEXT_BLOCK:				; Is there another block to go?
	SOBGTR	R3,10$			; Branch forward if more blocks.
	RET				; Otherwise, return with status.

10$:
	INCL	4(SP)			; Increment LBN to read by 1.
	ADDL	#^X200,8(SP)		; Increase memory address by one
					; page.
	BRB	READ_BLOCK		; Read another block.

	.SBTTL	SET_STARTADDR - Sets a START address

;++
; SET_STARTADDR
;
; Functional description:
;
;	Loads the start address specified in a LOAD or START command
;	into own storage.
;
; Inputs:
;
;	AP points to the TPARSE parameter block, containing:
;
;	TPA$L_NUMBER	- the starting address
;
; Outputs:
;
;	R1-R11 are preserved.
;
; Implicit outputs:
;
;	START_ADDRESS	- the start address value
;
;--

	.ENTRY	SET_STARTADDR,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	TPA$L_NUMBER(AP),-	; Move the specified address
		START_ADDRESS		; into own storage.
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	START_PROGRAM - Start at start address

;++
; Functional description:
;
;	Restores saved or user-modified registers from the stack. Then
;	transfers control to the address specified in this START command
;	or in the last LOAD command.
;
; Implicit inputs:
;
;	REGISTER_TABLE	- address of saved R0-SP
;	START_ADDRESS	- holds the start address
;
;--

START_PROGRAM:
	MOVL	REGISTER_TABLE,SP	; Call the register table the
					; stack top once again.
	POPR	#^M<R0,R1,R2,R3,R4,R5,-	; Restore registers R0-FP.
		R6,R7,R8,R9,R10,R11,-
		AP,FP>
	MOVL	(SP)+,SP		; Restore saved stack top.
	JMP	@START_ADDRESS		; Transfer control to start
					; address.

	.SBTTL	SET_BYTE - Set byte display mode

;++
; Functional description:
;
;	Sets display and deposit length mode to byte.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Implicit outputs:
;
;	CMD_M_BYTE	- set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_BYTE,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>


	BICL	#<CMD_M_LONG!-		; Clear longword mode.
		CMD_M_WORD>,-		; Clear word mode.
		COMMAND_FLAGS
	BISL	#CMD_M_BYTE,-		; Set to word mode.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	SET_WORD - Set word display mode

;++
; Functional description:
;
;	Sets display and deposit length mode to word.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Implicit outputs:
;
;	CMD_M_WORD	- set in COMMAND_FLAGS
;
;--

	.ENTRY	SET_WORD,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>


	BICL	#<CMD_M_LONG!-		; Clear longword mode.
		CMD_M_BYTE>,-		; Clear byte mode.
		COMMAND_FLAGS
	BISL	#CMD_M_WORD,-		; Set to word mode.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	SET_LONG - Set longword display mode

;++
; Functional description:
;
;	Cancels word mode for displays and deposits.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Implicit outputs:
;
;	CMD_M_WORD	- cleared in COMMAND_FLAGS
;
;--

	.ENTRY	SET_LONG,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BICL	#<CMD_M_WORD!-		; Clear word mode.
		CMD_M_BYTE>,-		; Clear byte mode.
		COMMAND_FLAGS
	BISL	#CMD_M_LONG,-		; Set long mode.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	SET_PHYSICAL - Set physical address mode

;++
; Functional description:
;
;	Sets address interpretation mode to physical.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Implicit outputs:
;
;	CMD_M_PHYSICAL	- set in COMMAND_FLAGS
;	CMD_M_GENERAL	- cleared in COMMAND_FLAGS
;	CMD_M_INTERNAL	- cleared in COMMAND_FLAGS
;
;--

	.ENTRY	SET_PHYSICAL,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BICL	#<CMD_M_GENERAL!-	; Clear general, internal
		CMD_M_INTERNAL>,-	; address modes.
		COMMAND_FLAGS
	BISL	#CMD_M_PHYSICAL,-	; Set physical address mode.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	SET_GENERAL - Set general register mode

;++
; Functional description:
;
;	Sets address interpretation mode to GENERAL.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Implicit outputs:
;
;	CMD_M_GENERAL	- set in COMMAND_FLAGS
;	CMD_M_PHYSICAL	- cleared in COMMAND_FLAGS
;	CMD_M_INTERNAL	- cleared in COMMAND_FLAGS
;
;--

	.ENTRY	SET_GENERAL,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BICL	#<CMD_M_PHYSICAL!-	; Clear physical, internal
		CMD_M_INTERNAL>,-	; address modes.
		COMMAND_FLAGS
	BISL	#CMD_M_GENERAL,-	; Set GENERAL address mode.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	SET_INTERNAL - Set internal processor register mode

;++
; Functional description:
;
;	Sets address interpretation mode to INTERNAL.
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- holds command interpretation flags
;
; Implicit outputs:
;
;	CMD_M_INTERNAL	- set in COMMAND_FLAGS
;	CMD_M_PHYSICAL	- cleared in COMMAND_FLAGS
;	CMD_M_GENERAL	- cleared in COMMAND_FLAGS
;
;--

	.ENTRY	SET_INTERNAL,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BICL	#<CMD_M_PHYSICAL!-	; Clear physical, general
		CMD_M_GENERAL>,-	; address modes.
		COMMAND_FLAGS
	BISL	#CMD_M_INTERNAL,-	; Set INTERNAL address mode.
		COMMAND_FLAGS
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET


	.SBTTL	EXADEP_ADDR - Pick up address argument

;++
; Functional description:
;
;	Stores the address argument of an EXAMINE or DEPOSIT command
;	in own storage.
;
; Inputs:
;
;	AP points to the TPARSE parameter block, containing:
;
;	TPA$L_NUMBER	- the numeric address specified
;
; Implicit inputs:
;
;	COMMAND_FLAGS	- tells whether the value in CURRENT_ADDRESS
;			  is to be interpreted as:
;
;			  CMD_M_PHYSICAL - a physical address
;			  CMD_M_GENERAL  - a general register number
;			  CMD_M_INTERNAL - an internal processor
;					   register number
;
; Outputs:
;
;	R1-R11 are preserved.
;
; Implicit outputs:
;
;	CURRENT_ADDRESS	- holds address value
;
;--

	.ENTRY	EXADEP_ADDR,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	TPA$L_NUMBER(AP),R0	; Get numeric argument.
	BBS	#CMD_V_PHYSICAL,-	; If physical address, no
		COMMAND_FLAGS,-		; modifications necessary.
		SAVE_ADDRESS
	BBS	#CMD_V_INTERNAL,-	; If internal processor
		COMMAND_FLAGS,-		; register, go interpret it.
		PROC_REGISTER

;
; This is a general register number. If a valid specification, change
; the address to an address in the general register table.
;

	TSTL	R0			; Register must be positive.
	BLSS	BAD_REGISTER		; Otherwise report error.
	CMPL	R0,#SAVED_PC		; Must also be between R0-PC.
	BGTR	BAD_REGISTER		; If not, report error.
	MOVAL	@REGISTER_TABLE[R0],-	; Store address of register
		CURRENT_ADDRESS		; storage location.
	BRB	ADDRESS_SAVED		; Return.

;
; This is an internal processor register. If a valid specification,
; get the processor register's value and store it in own storage.
; Save the own storage address in CURRENT_ADDRESS.
;

PROC_REGISTER:				; Read a processor register.
	TSTL	R0			; Register must be positive.
	BLSS	BAD_REGISTER		; Otherwise report error.
	CMPL	R0,#^X3F		; Must also be within a certain
	BGTR	BAD_REGISTER		; range. Branch if not.

;
; Address is in R0. Save it.
;

SAVE_ADDRESS:				; Store physical address.
	MOVL	R0,CURRENT_ADDRESS	; Store address in own storage.

ADDRESS_SAVED:				; Return.
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

;
; Bad address specification.
;

BAD_REGISTER:
	MSG	<-E-No such register>
	CLRL	R0			; Return error status
	RET

	.SBTTL	USE_LAST_ADDR - Repeat same address argument

;++
; Functional description:
;
;	Stores the last address used in a previous EXAMINE or DEPOSIT
;	command in the address field of the current command.
;
; Inputs:
;
;	AP points to the TPARSE parameter block.
;
; Implicit inputs:
;
;	LAST_ADDRESS	- the address field of the last EXAMINE or
;			  DEPOSIT command.
;
; Outputs:
;
;	R1-R11 are preserved.
;
; Implicit outputs:
;
;	The TPA$L_NUMBER field of the TPARSE parameter block holds the
;	address value to be used.
;
;--

	.ENTRY	USE_LAST_ADDR,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BBC	#CMD_V_GENERAL,-	; Branch if not general register
		COMMAND_FLAGS,10$	;
	MOVAL	REGISTER_TABLE,R2	; Get base addr of register table
	SUBL	R2,LAST_ADDRESS		; Sub. base to give reg #
10$:	MOVL	LAST_ADDRESS,-		; Move the last address used
		TPA$L_NUMBER(AP)	; into the parameter block.
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	USE_NEXT_ADDR - Increment address argument

;++
; Functional description:
;
;	For physical address mode, adds the current size mode (byte, word
;	or longword, i.e., 1, 2 or 4) to the last address examined or
;	deposited. For registers, adds 1 to the register number stored
;	in LAST_ADDRESS.
;
;
; Inputs:
;
;	AP points to the TPARSE parameter block.
;
; Implicit inputs:
;
;	LAST_ADDRESS	- argument of last EXAMINE or DEPOSIT command
;	CMD_M_WORD	- if set in COMMAND_FLAGS, indicates that the
;			  current length mode is WORD
;
; Outputs:
;
;	 R1-R11 are preserved.
;
; Implicit outputs:
;
;	TPA$L_NUMBER field of the TPARSE parameter block holds the
;	computed address.
;
;--

	.ENTRY	USE_NEXT_ADDR,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	LAST_ADDRESS,R1		; Get last address used.
	BBC	#CMD_V_PHYSICAL,-	; If a register, go check
		COMMAND_FLAGS,-		; for boundary conditions.
		CHECK_REG_MAX
	ADDL	#4,R1			; Assume longword mode.
	BBS	#CMD_V_LONG,-		; If longword mode is set,
		COMMAND_FLAGS,-		; just branch out to store the
		SAVE_NEW_ADDR		; new address in the block.
	SUBL	#2,R1			; Adjust to word length.
	BBS	#CMD_V_WORD,-		; If word mode is set,
		COMMAND_FLAGS,-		; just branch out to store the
		SAVE_NEW_ADDR		; new address in the block.
	SUBL	#1,R1			; Adjust to byte mode.
	BRB	SAVE_NEW_ADDR		; And go store it.

CHECK_REG_MAX:				; Check for maximum register #.
	ADDL	#1,R1			; Increment register number.
	MOVL	#SAVED_PC,R2		; Assume this is a general reg.
	BBS	#CMD_V_GENERAL,-	; If general register, branch
		COMMAND_FLAGS,-		; to compare new value with
		COMPARE_REG_NUM		; maximum register number.
	MOVL	#MAX_PROC_REG,R2	; Internal register. Get maximum
					; value.

COMPARE_REG_NUM:			; Check for number too large.
	CMPL	R1,R2			; New number beyond maximum?
	BGTR	BAD_ADDRESS		; Yes. Report error.

SAVE_NEW_ADDR:				; Store the new address in the
	MOVL	R1,TPA$L_NUMBER(AP)	; TPARSE parameter block.
	RET				; Return to caller.

BAD_ADDRESS:
	MSG	<-E-Invalid address specification>
	CLRL	R0			; Return error status
	RET

	.SBTTL	USE_PREVIOUS   - decrement address arguement

;++
; Functional description:
;
;	For PHYSICAL address mode, decrement the LAST_ADDRESS
;	according to the size mode.  If in register mode, decrement
;	the register number by 1.
;
; Inputs:
;
;	AP points to the TPARSE parameter block.
;
; Implicit inputs:
;
;	LAST_ADDRESS	- last address EXAMINEd or DISPLAYed.
;	COMMAND_FLAS	- determines address and size modes.
;
; Outputs:
;
;	None.
;
; Implicit outputs:
;
;	TPA$_NUMBER holds the new address.
;
;--

	.ENTRY	USE_PREVIOUS,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	LAST_ADDRESS,R1		; Get last address used
	SUBL	#1,R1			; Assume register mode
	BBC	#CMD_V_PHYSICAL,-	; Branch if register mode
		COMMAND_FLAGS,-		;
		TEST_MIN_ADDR		;
	SUBL	#3,R1			; Assume longword size
	BBS	#CMD_V_LONG,-		; Branch if longword size
		COMMAND_FLAGS,-		;
		TEST_MIN_ADDR		;
	ADDL	#2,R1			; Adjust to word size
	BBS	#CMD_V_WORD,-		; Branch if word size
		COMMAND_FLAGS,-		;
		TEST_MIN_ADDR		;
	ADDL	#1,R1			; Adjust to byte size

TEST_MIN_ADDR:
;
; The new address in R1 must be greater than zero for all cases.
;
	TSTL	R1			; Is R1 < 0
	BLSS	BAD_ADDR		; Branch if yes
	MOVL	R1,TPA$L_NUMBER(AP)	; Save new address
	MOVZWL	#SS$_NORMAL,R0		; Return success status
	RET

BAD_ADDR:
	MSG	<-E-INVALID ADDRESS SPECIFICATION>
	CLRL	R0			; Return error status
	RET

	.SBTTL	USE_LAST_VALUE - Process "@"

;++
; Functional description:
;
;	Retrieve the last value displayed or deposited in the last
;	EXAMINE or DEPOSIT command.  Sets address mode to PHYSICAL.
;
; Inputs:
;
;	AP points to the TPARSE parameter block.
;
; Outputs:
;
;	R1-R11 are preserved.
;
; Implicit outputs:
;
;	TPA$L_NUMBER field of the TPARSE parameter block holds the
;	last value displayed or deposited.
;
;--

	.ENTRY	USE_LAST_VALUE,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	LAST_VALUE,-		; Put last value displayed in
		TPA$L_NUMBER(AP)	; the parameter block.
	CALLS	#0,SET_PHYSICAL		; Set address mode physical
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	EXAMINE_LOC - Display a location

;++
; Functional description:
;
;	Displays the contents of a location on the terminal.
;
; Implicit inputs:
;
;	CURRENT_ADDRESS	- the address to be examined
;	W_FAO_OUT_LEN	- address of a word to receive the length of
;			  the output string from FAO
;	LONG_PHY_FORMAT	- address of an FAO formatting string that
;			  displays a hex longword
;	OUTPUT_FORMAT	- a writable buffer to receive an output format
;			  built on the fly in this routine.
;
; Outputs:
;
;	R2-R11 are preserved.
;
; Implicit outputs:
;
;	LAST_ADDRESS	- receives the address examined; if /G, value
;			  stored is the register #, not the address
;			  within the register table.
;	LAST_VALUE	- receives the value displayed.
;
;--

EXAMINE_LOC:
	PUSHAB	OUTPUT_FORMAT		; Push format buffer address
					; on the stack.
	MOVC3	#FORMAT_LENGTH,-	; Move default format string
		LONG_PHY_FORMAT,-	; into format buffer.
		OUTPUT_FORMAT
	MOVAB	OUTPUT_FORMAT,R0	; Get address of format string.
	BBC	#CMD_V_WORD,-		; If not displaying a word,
		COMMAND_FLAGS,5$	; branch.
	MOVL	#^A/!4XW/,13(R0)	; Replace value field format.
5$:	BBC	#CMD_V_BYTE,-		; If not displaying a byte,
		COMMAND_FLAGS,10$	; Branch
	MOVL	#^A/!4XB/,13(R0)	; Replace value field format.
10$:
	BBC	#CMD_V_GENERAL,-	; If not general register
		COMMAND_FLAGS,20$	; mode, branch.
	MOVB	#^A/G/,4(R0)		; Replace "P" with "G".

20$:
	BBC	#CMD_V_INTERNAL,-	; If not internal processor
		COMMAND_FLAGS,30$	; register mode, branch.
	MOVB	#^A/I/,4(R0)		; Replace "P" with "I".

30$:					; Put descriptors on stack.
	MOVZBL	#FORMAT_LENGTH,-(SP)	; Push format length.
	PUSHAB	OUTPUT_BUFFER		; Push buffer address on stack.
	MOVZBL	#OUTBUF_LENGTH,-(SP)	; Push length too.
	MOVL	SP,R0			; Save address of descriptors.

;
; Push FAO arguments on stack preparatory to a CALL. In the CALL,
; specify an extra 4 arguments so that the return from the CALL cleans
; up the descriptors on the stack.
;

	MOVL	CURRENT_ADDRESS,R2	; Get address to examine.
	BBC	#CMD_V_INTERNAL,-	; If not a processor register,
		COMMAND_FLAGS,-		; branch.
		EXTRACT_VALUE
	MFPR	R2,R3			; Read the processor register.
	BRB	PUSH_VALUE		; And proceed.

;
; Just a normal physical address in R2 (either specified by user or
; derived for a general register).
;

EXTRACT_VALUE:				; Get value to display from
	MOVL	(R2),R3			; the physical address.

PUSH_VALUE:				; Put value on stack.
	PUSHL	R3			; Display value.

;
; For a general register, display the register offset, not the address
; within the saved register table.
;

	BBC	#CMD_V_GENERAL,-	; If not a general register,
		COMMAND_FLAGS,-		; branch.
		PUSH_ADDRESS
	SUBL3	REGISTER_TABLE,R2,R4	; Compute offset to register.
	DIVL	#4,R4			; Derive register number.
	PUSHL	R4			; Put register number on stack.
	BRB	FINISH_STACK		; And proceed.

PUSH_ADDRESS:				; Push a plain physical address.
	PUSHL	R2			; Display address of value.

FINISH_STACK:				; Complete stack setup.
	PUSHAQ	(R0)+			; Send output buffer descriptor.
	PUSHAW	W_FAO_OUT_LEN		; Send location for out length.
	PUSHAQ	(R0)			; Send format string descriptor.
	CALLS	#9,SYS$FAO		; Format the output string.

;
; Write the output string onto the console terminal by calling the
; read with prompt routine with a null read buffer address. This prints
; the prompt string and returns.
;

	MOVZWL	W_FAO_OUT_LEN,R0	; Get length of output string.
	CLRB	OUTPUT_BUFFER[R0]	; Write a null at end of string.
	CLRQ	-(SP)			; Don't ask for a read.
	PUSHAB	OUTPUT_BUFFER		; Push buffer address on stack.
	CALLS	#3,BOO$READPROMPT	; Output string.

;
; Store current address in LAST_ADDRESS so that NEXT and LAST work
; properly. For /G, only store the register number as LAST_ADDRESS.
; Also store the value displayed. Register setup now is as follows:
;
;	R2	- current address
;	R3	- value displayed
;	R4	- general register number (if any)
;

	BBC	#CMD_V_GENERAL,-	; If not a general register,
		COMMAND_FLAGS,-		; just store the address as is.
		STORE_ADDRESS
	MOVL	R4,R2			; Get register number.

STORE_ADDRESS:
	MOVL	R2,LAST_ADDRESS		; Store address away.
	MOVL	R3,LAST_VALUE		; Save the value displayed.
	RET				; Return to caller with status
					; code from FAO.

	.SBTTL	DEPOSIT_VALUE - Pick up data value

;++
; Functional description:
;
;	Loads the value to be deposited from a DEPOSIT command into
;	own storage.
;
; Inputs:
;
;	AP points to the TPARSE parameter block, containing:
;
;	TPA$L_NUMBER	- the value to be deposited.
;
; Outputs:
;
;	R2-R11 are preserved.
;
; Implicit outputs:
;
;	HOLD_DEPOSIT	- holds value from DEPOSIT command.
;
;--

	.ENTRY	DEPOSIT_VALUE,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	TPA$L_NUMBER(AP),R1	; Get value to be deposited.
	BBC	#CMD_V_WORD,-		; Branch if not word mode
		COMMAND_FLAGS,10$	; 
	MOVZWL	R1,R1			; Save a word.
10$:	BBC	#CMD_V_BYTE,-		; Branch if not byte mode
		COMMAND_FLAGS,20$	;
	MOVZBL	R1,R1			; Save a byte.
20$:	MOVL	R1,HOLD_DEPOSIT		; Save the value.
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	DEPOSIT_DATA - Store a value in memory

;++
; Functional description:
;
;	Deposits a longword or a word of data into a specified location.
;
; Implicit inputs:
;
;	CURRENT_ADDRESS	- contains the destination address
;	HOLD_DEPOSIT	- contains the value to be deposited
;
; Outputs:
;
;	R1-R11 are preserved.
;
; Implicit outputs:
;
;	LAST_ADDRESS	- holds destination address
;	LAST_VALUE	- holds value deposited
;
;--

DEPOSIT_DATA:
	BBC	#CMD_V_INTERNAL,-	; Branch if not using IPR's
		COMMAND_FLAGS,10$	;
	MTPR	HOLD_DEPOSIT,-		; Deposit data in IPR
		CURRENT_ADDRESS		;
	BRB	20$			; Rejoin common code
10$:	MOVL	HOLD_DEPOSIT,-		; Deposit the value into the
		@CURRENT_ADDRESS	; specified address.
20$:	MOVL	CURRENT_ADDRESS,-	; Save destination address.
		LAST_ADDRESS
	MOVL	HOLD_DEPOSIT,-		; Save value deposited.
		LAST_VALUE
	MOVZWL	#SS$_NORMAL,R0		; Return success status code.
	RET

	.SBTTL	EXECUTE_FILE - Process command file

;++
; Functional description:
;
;	Opens the specified file and reads the first block into a
;	buffer. Sets a bit in the command flags longword to indicate
;	that an indirect file is being processed. The bit is used to
;	prevent indirect command file nesting.
;
; Implicit inputs:
;
;	IND_CMDBUFFER	- buffer in which to load a block of the file
;	FILE_DESCRIP	- string descriptor of the file
;
;	CMD_M_INDIRECT	- bit set in COMMAND_FLAGS if commands are
;			  already being processed from an indirect
;			  command file
;
; Outputs:
;
;	CMD_M_INDIRECT	- bit set in COMMAND_FLAGS to prevent command
;			  file nesting
;	IND_CMDBUF_PTR	- pointer to next byte in indirect command file
;			  buffer
;	IND_W_NEXT_LBN	- (1 word) next LBN to read from command file
;	IND_W_BLKS_LEFT	- (1 word) number of blocks left to read in
;			  command file
;
;--

EXECUTE_FILE:
	BBC	#CMD_V_INDIRECT,-	; If an indirect file is NOT
		COMMAND_FLAGS,10$	; being processed, proceed ok.
	MSG	<-E-Nested command files are not permitted>
	BRW	EXIT_NOW		; Return

10$:					; Accept command file.
	CLRQ	-(SP)			; Clear space for a file
	PUSHL	SP			; statistics block. Push address
					; on the stack for a call.
	PUSHAL	DIREC_BUFFER		; Send address of a buffer for
					; RT-11 directory segments.
	PUSHAL	FILE_DESCRIP		; Send descriptor of file.
	CALLS	#3,RTF$OPENFILE		; Look up the file.
	BLBS	R0,READ_CMD_BLOCK	; On successful read, branch.
	MSG	<-E-Unable to locate file>
	BRB	EXIT_NOW		; Return

;
; Now read the first block of the file into memory. Store
;
;	the number of blocks left to read,
;	the next LBN to read,
;	a pointer to the start of the buffer of command data
;
; in own storage for later reference by the routine that extracts
; command records from the file blocks.
;

READ_CMD_BLOCK:				; Read one block.
	SUBW3	#1,4(SP),-		; Store # blocks minus 1.
		IND_W_BLKS_LEFT
	ADDW3	#1,(SP),IND_W_NEXT_LBN	; Store second LBN in file.
	MOVAB	IND_CMDBUFFER,-		; Save a pointer to the
		IND_CMDBUF_PTR		; buffer.
	PUSHAL	IND_CMDBUFFER		; Address to receive the block.
	PUSHL	4(SP)			; Number of LBN to read.
	CALLS	#2,FIL$READ_LBN		; Read 1 LBN.
	BLBS	R0,NORMAL_RETURN	; Branch on successful read.
	MSG	<-E-Cannot read file>

	BRB	EXIT_NOW		; Return

NORMAL_RETURN:				; Block is in the buffer.
	BISL	#CMD_M_INDIRECT,-	; Set indirect command file
		COMMAND_FLAGS		; bit in command flag longword.

EXIT_NOW:				; Return via RET
	RET


	.SBTTL PRINT_HELP - Print an RT-11 HELP file at the console.

;++
; Functional description:
;
;	Locate and open an RT-11 format file on the boot device, and
;	print that file at the console.
;
; Implicit inputs:
;
;	CMD_M_INDIRECT	- This bit is set if we are in a command file.
;	FILE_DESCRIP	- File descripter of file to be printed.
;
; Outputs:
;
;	None.
;
; NOTE:
;
;	HELP cannot be used from within an indirect command file.
;	This is because the number and size of the variables that
;	would have to be saved to allow this is prohibitive.  
;
;--
PRINT_HELP:				; Print a file
	BBC	#CMD_V_INDIRECT,-	; Are we in a command file?
		COMMAND_FLAGS,10$	; Branch if not
	MSG	<-E-HELP cannot be used w/i a command file>
	BRB	EXIT_PRINT_HELP		; Exit now
;
; Set up the help-file file descripter.
;
10$:	MOVQ	HELP_FILE_DESCRIP,-	;
		FILE_DESCRIP		;
;
; Call OPEN_FILE to locate and open the file.  This will also read
; the first LBN of the file into memory and set CMD_V_INDIRECT.
;
	CALLS	#0,OPEN_FILE		; Open help file
;
; Now print the file one record at a time.  When the EOF is detected,
; CMD_V_INDIRECT will be cleared.
;
NEXT_RECORD:				; Get and print next record.
	BBC	#CMD_V_INDIRECT,-	; Branch if EOF
		COMMAND_FLAGS,-		;
		EXIT_PRINT_HELP		;
	JSB	GET_A_RECORD		; Get a record from the file
	BLBC	R0,EXIT_PRINT_HELP	; Branch if error
	;
	; Print the record at the console.  A special ASCIZ string is
	; put on the end of the buffer to cause a CRLF at the end of the
	; record.
	;
	MOVAB	COMMAND_BUFFER+1,R4	; Get address of fisrt char
	ADDL3	R1,R4,R0		; Get address of last char
	MOVL	LINE_TERM,(R0)		; Put line term past last char
	CLRQ	-(SP)			; Create null descripter
	PUSHL	R4			; Push address of first char
	CALLS	#3,BOO$READPROMPT	; Print the record.
	BLBC	R0,EXIT_PRINT_HELP	; Branch if error.
	BRB	NEXT_RECORD		; Process next record.

EXIT_PRINT_HELP:
	RET				; Return

	.SBTTL	BOOT_UP - Boot the system
;++
; Functional description:
;
;	Boot the system using one of several generalized indirect
;	command files.  The correct file is determined by the
;	device specified in the BOOT command.  If no device is
;	specified, boot using the default boot file, DEFBOO.CMD.
;
;	If a boot device was specified, it must be of the form
;	DDCU:, where DD is the generic device type, C is the controller
;	designator, and U is the unit number.  The correct boot file
;	is DDCBOO.CMD and the unit number must be deposited in R3
;	before executing the boot file.
;
;	Note that the BOOT command cannot be used w/i a command file.
;	This is because the overhead in allowing it is prohibitive.
;
; Inputs:
;
;	COMMAND_FLAGS	- Various flags of intrest
;	DEV_DESCRIP	- Descripter of the DDCU: string
;	UNIT_NUMBER	- Unit number of the boot device
;	DEFBOO_DESCRIP	- Descripter of the default boot file
;
; Outputs:
;
;	R0 		- Return status
;
;--
BOOT_UP:				; Boot the system
	BBC	#CMD_V_INDIRECT,-	; Are we in a command file
		COMMAND_FLAGS,10$	; Branch if yes
	MSG	<-E-BOOT cannot be used w/i a command file>
	BRB	50$			; Exit now
;
; Decide whether to use the default command file or a special one.
;
10$:	BBC	#CMD_V_NULLDEV,-	; Was a boot device specified?
		COMMAND_FLAGS,20$	; Branch if not
	MOVQ	DEFBOO_DESCRIP,-	; Set up boot file descripter
		FILE_DESCRIP		;
	BRB	30$			; Open the file
;
; Set up the boot file spec for a special boot file.
; Only the first 3 characters of the device spec are needed.
;
20$:	MOVC3	#3,-			; Length
		@DEV_DESCRIP+4,-	; Source
		@BOOTFILE_DESCRIP+4	; Destination
	MOVQ	BOOTFILE_DESCRIP,-	; Set up input for OPEN_FILE
		FILE_DESCRIP		;
;
; Locate and open the boot file.
;
30$:	CALLS	#0,OPEN_FILE		; Open the file
	BLBC	R0,50$			; Branch if error
;
; If the file was opened successfully and a special boot file 
; was requested, put the unit number in R3.
;
	BBSC	#CMD_V_NULLDEV,-	; Was a special boot file requested?
		COMMAND_FLAGS,40$	; Branch if not
	MOVZBL	#SAVED_R3,R0		; Get index of saved R3 w/i table
	MOVL	UNIT_NUMBER,-		; Put unit number in saved R3
		@REGISTER_TABLE[R0]	;
40$:	MOVZWL	#SS$_NORMAL,R0		; Put return status in R0
50$:	RET				; Return

	
	.SBTTL	OPEN_FILE - Locate and open an Rt-11 file.
;++
;
; This routine codes around a messy procedure interface.
; This is only a dummy routine that branches to EXECUTE_FILE
; and allows it to return to OPEN_FILE's caller via a RET.
;
;--

	.ENTRY	OPEN_FILE,^M<>
	BRW	EXECUTE_FILE

	.SBTTL	Stand alone I/O support

;++
;
; SYS$FAO	- formats an output string
;
; Functional description:
;
;	Calls the system service directly instead of through a vector.
;
;--

	.ENTRY	SYS$FAO,-
		^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BRW	EXE$FAO+2		; Branch past entry mask.

	.SBTTL	XDELTA Definitions and a fault handler

;
; Define handlers needed by XDELTA.
;

	.ALIGN	LONG			; All handlers longword-aligned.

	.IF	NE,SADEBUG		; If XDELTA is included...

EXE$ACVIOLAT::				; Access violation vector.
EXE$BREAK::				; BPB vector.
EXE$ROPRAND::				; Reserved operand vector.
EXE$TBIT::				; Trace trap vector.
EXE$GB_CPUTYPE::			; Defines CPU to be an 11/750
	.LONG	PR$_SID_TYP750		;
MMG$PAGEFAULT::				; Pagefault exception vector.

	.ENDC				; End of XDELTA conditional.

;
; Fault handler for unexpected exception conditions during BOOT58.
;

BOOT_FAULT:				; Handler for most of SCB.

	.IF	NE,SADEBUG		; If XDELTA included...
	JSB	INI$BRK			; Call XDELTA
	.ENDC				; End conditional

	MSG	</-F-Unexpected Exception/>
	BLBC	B_ENVIRON_SAFE,10$	; Branch forward if this is
					; a fatal exception.
	MOVL	L_OLD_STACKP,SP		; Restore SP.
	BRW	READ_COMMAND		; Go try again.

10$:					; Fatal exception.
	HALT				; Halt processor.

;
; Labels required for XDELTA.
;

	.IF	NE,SADEBUG		; If XDELTA is included...

INI$RDONLY::				; Dummy change protection
INI$WRITABLE::				; routines.
	RSB				; Just return.

EXE$GL_FLAGS::				; Dummy flags longword.
EXE$GL_SCB::				; Dummy SCB address pointer.
EXE$V_SIMULATOR	== 0			; This is not a simulator.

PFN$AB_STATE::
PFN$AB_TYPE::
PFN$AL_BAK::
PFN$AL_PTE::
PFN$AW_BLINK::
PFN$AW_FLINK::
PFN$AW_REFCNT::
PFN$AW_SWPVBN::

SYS$IOBASE::
SCH$GL_CURPCB::
SCH$GL_PCBVEC::

XDS$INIT::
	.LONG	0

	.ENDC				; End of XDELTA conditional.

;
; Labels required for RMSCONIO.
;

	.IF	NE,TSDEBUG		; If DEBUG is being linked...

BOO$AB_PRMBUF::
BOO$A_PRMBLK::
BOO$GQ_CMDESC::				; String descriptor for READ.
	.LONG	0,RMS_BUFFER		; Input buffer for RMS read.

RMS_BUFFER:				; Input buffer for RMS.
	.BYTE	100

RMS_BUF_LENGTH	= .-RMS_BUFFER		; Length of RMS buffer.

	.ENDC

	.SBTTL	Declarations that must appear at the end

;
; If XDELTA is linked, align end of BOOT58 on a page boundary.
;

	.IF	NE,SADEBUG
	.ALIGN	LONG
	.ENDC

	.NOSHOW	EXPANSIONS

	.END	BOOT58			; Transfer address.
