	.TITLE	VMB - VMS Primary Bootstrap Routine
	.IDENT	'V03-003'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	Bootstrap module for VAX 11/780, 11/750, and 11/730 hardware
;
; ENVIRONMENT:
;
;	Runs at IPL 31, kernel mode, memory management is OFF, IS=1
;	(running on interrupt stack), and code must be PIC.
;
; ABSTRACT:
;
;	This module contains the primary bootstrap code. The main
;	routine -- START_BOOT -- gains control from CONSOLE, boot block
;	0 code, or from BOOT58. The code creates a System Control
;	Block (SCB), initializes XDELTA if requested, initializes the
;	Restart Parameter Block (RPB), creates a PFN bit map describing
;	all of physical memory, reads in a secondary bootstrap program,
;	and transfers control to that bootstrap.
;
; AUTHOR:
;
;	RICHARD I. HUSTVEDT, Creation date:	18-OCT-1977
;
; MODIFIED BY:
;
;	V03-003	KTA0091		Kerbey T. Altmann	30-Mar-1982
;		Add code to dynamically find memory for microcode and
;		pseudo-page table for CI bootdriver.
;
;	V03-002	MLJ0084		Martin L. Jack		29-Mar-1982
;		Reinsert special case for VAX-11/750, because now booting
;		standalone system directly from first volume.
;
;	V03-001	KDM0078		Kathleen D. Morse	15-Mar-1982
;		Add RPB$V_FINDMEM flag and logic, that allows the
;		11/782 installation to use MA780 memory instead of
;		MS780 memory.
;
;	V02-034	KTA0074		Kerbey T. Altmann	05-Feb-1982
;		Further refine KTA0049 for yet another "feature'
;		of the many UBA implementations.
;
;	V02-033	KTA0070		Kerbey T. Altmann	26-Jan-1982
;		Refine KTA0049 to fix timing glitch.
;
;	V02-032	KTA0049		Kerbey T. Altmann	21-Nov-1981
;		Enhance INIT_ADP to find any possible UNIBUS memory 
;		on the boot adapter and disable corresponding UMR's.
;
;	V02-031	PRD0005		Paul R. DeStefano	30-oct-81
;		Changed notation of 7VV support
;
;	V02-030	KTA0035		Kerbey T. Altmann	02-Oct-1981
;		Add support for reading microcode files from the console
;		media for devices that will be used to continue the boot.
;		(e.g. CI780 to boot off HSC50)
;
;	V02-028	MLJ0034		Martin L. Jack		27-Aug-1981
;		Improve wording of volume switch prompt.  Avoid issuing prompt
;		on VAX-11/750, because media is already mounted.
;
;	V02-027	PHL0012		Peter H. Lipman		04-Aug-1981
;		Finish allowing the PFN bitmap to be very large.
;		Make one large contiguous bitmap out of it and pass
;		its address and size in the argument list rather than
;		in the RPB.  The RPB still points at the 4 page (8mb)
;		bitmap, and that bitmap is valid.
;
;		Almost all of VMB is now in PSECT YBTMEM.  VMB now
;		overlays almost all of itself when it reads in the
;		secondary boot.
;
;	V02-026	TCM0003		Trudy C. Matthews	31-Jul-1981
;		Change all "7ZZ"s to "730"s.
;
;	V02-025	LJK0030		Lawrence J. Kenah	31-Jul-1981
;		Change names of dummy global symbols included for
;		sake of XDELTA so that names conform to new symbols
;		required for large physical memory configurations.
;
;	V02-024	PHL0011		Peter H. Lipman		19-Jun-1981
;		Change the memory test design so that it no longer
;		requires a preallocated, preinitialized, contiguous
;		bit map to describe the pages that have been found
;		and appear to be good.
;
;		Fix error in "ERROUT" logic which used R11 after
;		destroying it.
;
;		Eliminate the CPU dependent MAX_PGS parameter.
;
;		Zero only the memory descriptors in the RPB rather than
;		the remainder of it starting with the memory descriptors
;
;	V02-023	PHL0010		Peter H. Lipman		2-Jun-1981
;		If defaulting secondary boot file (SYSBOOT, DIAGBOOT)
;		try to find it in top level system directory, SYS0
;		unless another explicit top level system directory
;		was specified.  For backward compatibility, though,
;		retry on "No such file" error with no TOPSYS directory.
;
;		Increase the maximum memory (MAXPGS) for a 750 
;		from 4096 to 16384 (NMK)
;
;	V02-022	TCM0002		Trudy C. Matthews	3-Jun-1981
;		Change maximum amount of memory possible on a Nebula to
;		5 Mb (= 10240 pages).
;
;	V02-021	TCM0001		Trudy C. Matthews	8-May-1981
;		Add a new RPB field: RPB$B_BOOTNDT, to store nexus device
;		type of boot adapter.
;
;	V02-020	CAS0017		C. A. Samuelson		20-Apr-1981
;		Add support for (11/7VV).
;		Moved processor memory test loops to separate modules.
;
;	V02-019	RNH0001		Richard N. Holstein	13-Apr-1981
;		Restore a line accidentally deleted by SLP in edit V02-017.
;		Update packet read, "-1431,1432...", should be, "-1432,1432".
;
;	V02-018	PHL0007		Peter H. Lipman		19-Mar-1981
;		Use new FIL$OPENFILE cache and pass it on to the
;		secondary boot so that it may make use of what has
;		already been cached.
;
;	V02-017	KTA0011		Kerbey T. Altmann	06-Mar-1981
;		Correct the number of arguments in the call to
;		FIL$OPENFILE to agree with new version.
;
;	V02-016	CAS0002		C. A. SAMUELSON		23-JUL-1980
;		Store HALT PSL in RPB correctly on reboot
;
;	V02-015	KDM0017		KATHLEEN D. MORSE	16-JUL-1980
;		Add two new boot flags:  RPB$V_MPM - to use only MA780
;		memory (multi-processor boot), and RPB$V_USEMPM - to
;		use MA780 memory as though it was local memory.
;
;	V02-014	KDM0008		KATHLEEN D. MORSE	13-MAY-1980
;		Fix TR number extraction for RPB memory descriptor.
;
;	V02-013	KDM0007		KATHLEEN D. MORSE	2-MAY-1980
;		Correct RPB memory descriptors for interleaved memory.
;		Also, test interleaved memory pages only once.
;
;--

	.SBTTL	Declarations

	.DEFAULT DISPLACEMENT, WORD

;
; Macros to describe VMS data structures
;

	$BQODEF				; Boot QIO offsets
	$BTDDEF				; Boot device definitions
	$DMPDEF				; System dump file header definitions
	$IHDDEF				; Image header definitions
	$IODEF				; I/O function codes
	$IO750DEF			; 11/750 definitions
	$IO780DEF			; 11/780 definitions
	$IO730DEF			; 11/730 definitions
	$IO7VVDEF			; 11/7VV definitions
	$MBADEF				; MASSBUS adapter registers
	$NDTDEF				; Nexus device types
	$PRDEF				; Processor registers
	$RPBDEF				; Restart parameter block
	$SSDEF				; System status codes
	$UBADEF				; UNIBUS adapter registers
	$UBIDEF				; 11/750 UNIBUS adapter
	$VADEF				; Virtual address fields
	$VMBARGDEF			; Define VMB argument list offsets

 ; 
 ; Field definitions of the CPU-specific data block used by VMB.EXE 
 ; 
  
	$DEFINI	CPU,GLOBAL

 $DEF	CPU_W_SAVE_CSRS		 	; Routine to save CSRs. 
 			.BLKW	1 
 $DEF	CPU_W_CHECKMEM		 	; Routine to test memory. 
 			.BLKW	1 
 $DEF	CPU_W_INIT_ADAP		 	; Routine to initialize
 			.BLKW	1 	; adapters.

 	$DEFEND	CPU

;
; Macros
;

	.MACRO	ERROR,STR		; Outputs an error string to the
	BSBW	ERROUT			; console terminal.
	.ASCIZ	STR
	.ENDM	ERROR

;
; Generate a word-relative address.
;

	.MACRO	RELADR	ADDRESS,BASE
	.WORD	ADDRESS-BASE
	.ENDM	RELADR

;
; Turns a CPU identification code into the relative address of a table.
;

	.MACRO	CPU_IDENT LABEL,TABLE
	RELADR	CPU_DATA_'TABLE',LABEL
	.ENDM	CPU_IDENT
		
;
; Defines a table of data that is CPU-specific, and PIC.
;

	.MACRO	CPU_DEF	LABEL
CPU_DATA_'LABEL':			; Name of table.
	RELADR	SAVE_CSR_'LABEL',CPU_DATA_'LABEL'
					; Routine to compute CSRs.
	RELADR	CHECKMEM_'LABEL',CPU_DATA_'LABEL'
					; Routine to test memory.
	RELADR	INIT_ADP_'LABEL',CPU_DATA_'LABEL'
					; Routine to init adapters.
	.ENDM	CPU_DEF


;
; Branch to a new PSECT
;

	.MACRO	BRW_PSECT LABEL,PSECT=<$$$$00BOOT,LONG>
	.SHOW	EXPANSIONS

	BRW	LABEL
;
; ***** Change Program Section
;
	.PSECT	PSECT

LABEL:
	.NOSHOW	EXPANSIONS
	.ENDM	BRW_PSECT

;
; Set new PSECT
;

	.MACRO	SET_PSECT PSECT=<$$$$00BOOT,LONG>
	.SHOW	EXPANSIONS
;
; ***** Change Program Section
;
	.PSECT	PSECT

	.NOSHOW	EXPANSIONS
	.ENDM	SET_PSECT

;
; Build a table of memory size and ranges
;
	.MACRO	MEM_TABLE,MEM_SIZE,START
	.LONG	MEM_SIZE-<MEM_SIZE/10>
	.WORD	START
	.ENDM	MEM_TABLE

;
; Equated symbols
;

	IO_SIZE		= 127		; Maximum # blocks in one read
	DEBUG		= 1		; Assemble DEBUG code
	CR		= 13		; ASCII code for carriage return
	LF		= 10		; ASCII code for line feed
	BITMAP_PAG_CNT	= 4		; Number of pre-allocated
	STACK_PAG_CNT	= 3		; Number of stack pages to allocate
					; PFN bitmap pages

;
; Static storage
;

	.PSECT	__Z99BOOT,PAGE		; PSECT that always links at end
					; of bootstrap.
BOOTHIGH::				; Symbol to mark the start of
					; the first page after the code
					; in this module.
	.PSECT	BOOTDRIV_9,PAGE		; PSECT at end of drivers
OVERLAY_START:				; Start overlaying VMB here

	.IF	DF,DEBUG		; If debugging code included,
EXE$MCHKVEC	== BOOTHIGH+4		; define a symbol used by XDELTA
	.ENDC				; to locate the SCB.

;
; Declare a code PSECT that will always link at the start of the image.
;

	SET_PSECT			; Use default PSECT

	.SBTTL	START_BOOT, Primary bootstrap routine

;++
; Functional description:
;
;	VMB is loaded into physical memory and gains control via a JMP
;	instruction from CONSOLE, boot block 0 on the boot device, or
;	BOOT58. VMB gains control in the routine START_BOOT.
;
;	VMB begins by creating and initializing an SCB. If the software
;	bootstrap control flags specified a bootstrap breakpoint, VMB
;	then executes a BPT instruction that transfers control to
;	XDELTA.
;
;	After the XDELTA breakpoint, VMB initializes a system data
;	structure, i.e., a restart parameter block (RPB) that allows
;	a system reboot after a power failure or crash. The RPB holds
;	the bootstrap input registers, the boot device's CSR and bus
;	configuration register (CR), the address of the RPB itself, and
;	pointers to a primitive device driver.
;
;	VMB, the primary bootstrap, also identifies all physical memory
;	in the configuration by creating a bit map in which each bit
;	represents one page of physical memory. In the process of
;	testing all memory, VMB determines which NEXUSes on the system
;	bus are attached to adapters. For every adapter present, VMB
;	records the adapter type in the RPB.
;
;	Finally, VMB chooses a secondary bootstrap image -- either by
;	default, by boot flag settings, or by soliciting a file
;	specification from the user. VMB uses a minimal driver for the
;	bootstrap device to load the secondary image into memory, and
;	transfers control to that bootstrap.
;
;	The secondary bootstrap -- usually SYSBOOT.EXE -- uses the 
;	minimal driver from VMB for reading and writing to and from the
;	bootstrap device. Thus, SYSBOOT is device-independent.
;
;	VMB has CPU dependencies such as system bus addresses, memory
;	controller registers, and bus adapter register formats.
;	Therefore, VMB consists of common code that applies to all VAX
;	implementations, and CPU-specific code that applies to one
;	hardware implementation only. The current version supports the
;	following CPUs:
;
;		11/780	(STAR)
;		11/750	(COMET)
;		11/730	(NEBULA)
;		11/7VV
;
; Inputs:
;
;	R0	- <07:00> boot device type code (RPB$B_DEVTYP)
;
;			0	MASSBUS device (RM02/3,RP04/5/6/7,RM80)
;			1	RK06/7
;			2	RL01/2
;			3	IDC(almost an RA80) on 11/730
;			17	UDA-50
;			32	HSC on CI
;			64	Console block storage device
;
;		- <15:08> reserved for future expansion
;
;		- <31:16> device class dependent (RPB$W_R0UBVEC)
;
;			UNIBUS  - optional vector address; 0 implies
;					use the default vector
;
;			MASSBUS - not used
;
;	R1	- boot device's bus address
;
;			11/780 &
;			11/730	- <31:04> MBZ
;				  <03:00> TR number of adapter
;
;			11/750	- <31:24> MBZ
;				  <23:00> address of the I/O page for the
;					  boot device's adapter
;
;			11/7VV  - <31:06> MBZ
;				  <05:04> A-bus Adapter number
;				  <03:00> TR number of the adapter
;	R2	- UNIBUS:
;
;			<31:18> MBZ
;			<17:00> UNIBUS address of the device's CSR
;
;		- MASSBUS:
;
;			<31:04> MBZ
;			<03:00> adapter's controller/formatter number
;
;		- CI:
;			<31:08> MBZ
;			<07:00> HSC port number (station address)
;
;	R3	- boot device unit number
;
;	R4	- logical block number to boot from if bit 3 is set in R5
;			(not supported on 11/750)
;
;	R5	- software boot control flags
;
;		Bit	Meaning
;		---	-------
;
;		 0	RPB$V_CONV.
;			Conversational boot. At various points in the
;			system boot procedure, the bootstrap code
;			solicits parameters and other input from the
;			console terminal. If the DIAG is also on, then
;			the diagnostic supervisor should enter "MENU"
;			mode and prompt user for devices to test.
;
;		 1	RPB$V_DEBUG.
;			Debug. If this flag is set, VMS maps the code
;			for the XDELTA debugger into the system page
;			tables of the running system.
;
;		 2	RPB$V_INIBPT.
;			Initial breakpoint. If RPB$V_DEBUG is set, VMS
;			executes a BPT instruction immediately after
;			enabling mapping.
;
;		 3	RPB$V_BBLOCK.
;			Secondary boot from boot block. Secondary
;			bootstrap is a single 512-byte block, whose
;			LBN is specified in R4.
;
;		 4	RPB$V_DIAG.
;			Diagnostic boot. Secondary bootstrap is image
;			called [SYSMAINT]DIAGBOOT.EXE.
;
;		 5	RPB$V_BOOBPT.
;			Bootstrap breakpoint. Stops the primary
;			and secondary bootstraps with a breakpoint
;			instruction before testing memory.
;
;		 6	RPB$V_HEADER.
;			Image header. Takes the transfer address of the
;			secondary bootstrap image from that file's
;			image header. If RPB$V_HEADER is not set, 
;			transfers control to the first byte of the
;			secondary boot file.
;
;		 7	RPB$V_NOTEST.
;			Memory test inhibit. Sets a bit in the PFN bit
;			map for each page of memory present. Does not
;			test the memory.
;
;		 8	RPB$V_SOLICT.
;			File name. VMB prompts for the name of a
;			secondary bootstrap file.
;
;		 9	RPB$V_HALT.
;		 	Halt before transfer. Executes a HALT
;			instruction before transferring control to the
;			secondary bootstrap.
;
;		10	RPB$V_NOPFND.
;			No PFN deletion (not implemented; intended to
;			tell VMB not to read a file from the boot device
;			that identifies bad or reserved memory pages,
;			so that VMB does not mark these pages as valid
;			in the PFN bitmap).
;
;		11	RPB$V_MPM.
;			Specifies that multi-port memory is to be used
;			for the total exec memory requirement.  No local
;			memory is to be used.  This is for tightly-coupled
;			multi-processing.  If the DIAG is also on, then
;			the diagnostic supervisor enters "AUTOTEST" mode.
;
;		12	RPB$V_USEMPM.
;			Specifies that multi-port memory should be used in
;			addition to local memory, as though both were one
;			single pool of pages.
;
;		13	RPB$V_MEMTEST
;			Specifies that a more extensive algorithm be used
;			when testing main memory for hardware uncorrectable
;			(RDS) errors.
;
;		14	RPB$V_FINDMEM
;			Requests use of MA780 memory if MS780 is insufficient
;			for booting.  Used for 11/782 installations.
;
;		<31:28>	RPB$V_TOPSYS
;			Specifies the top level directory number for system
;			disks with multiple systems
;
;	The hardware or the CONSOLE program sets up the next 3 registers
;	after a system crash or power failure:
;
;	R10	- halt PC
;	R11	- halt PSL
;	AP	- halt code
;
;	SP	- <base_address + ^X200> of 64kb of good memory
;
; Implicit inputs:
;
;	When VMB gains control, physical memory looks like the diagram
;	below:
;
;	SP-^X200:	+--------------------------------------+
;			|     Restart Parameter Block (RPB)    |
;	SP:		+--------------------------------------+
;			|       Primary bootstrap (VMB)        |
;			+--------------------------------------+
;
; Outputs:
;
;	R10	- base address of region containing secondary bootstrap
;	R11	- address of restart parameter block
;	SP	- current stack pointer
;	PR$_SCBB- system control block address
;
; Implicit outputs:
;
;	When VMB transfers control to the secondary bootstrap, physical
;	memory is laid out as in the diagram below:
;
;	RPB$L_BASE:	+--------------------------------------+
;			|     Restart Parameter Block (RPB)    |
;	base+^X200:	+--------------------------------------+
;			|       Primary bootstrap (VMB)        |
;	PR$_SCBB:	+--------------------------------------+
;			|      System control block (SCB)      |
;			+--------------------------------------+
;			|             PFN Bitmap               |
;	PFNMAP+^X800:	+--------------------------------------+
;			|               Stack                  |
;	SP:		+--------------------------------------+
;			|     Secondary bootstrap (SYSBOOT)    |
;			+--------------------------------------+
;
; The design for the PFN bitmap has been extended to handle more than
; 4 pages of bitmap = 8mb of memory.  Bitmaps that do not fit in the
; 4 page reserved area are now allocated contiguous good pages in
; higher memory.  Assuming that the pages are actually good, the
; bitmap is placed at the RPB address + 1mb.  If a page in that area is
; bad, then the next contiguous run of pages that is big enough is
; where the bitmap will be placed.  For backward compatibility, the
; RPB$Q_PFNMAP descriptor in the RPB points at the pre-allocated
; 4 page bitmap, which is correct for the low 8mb of memory.  The
; real descriptor for the bitmap is passed in the argument list.
;
;--

START_BOOT::				; Start of primary bootstrap.

;
; Reserve space for a System Control Block (SCB) immediately after the
; VMB code. Write the address of a machine check fault handler in all
; vectors in the SCB. This handler is used during bootstrapping except
; when the bootstrap code specifically writes a different handler
; address in one of the SCB vectors.
;
; The low bit set in the address of the fault handler causes the handler
; to execute on the interrupt stack.
;

	CLRL	CONTINUE_INDEX		; Indicate initial execution of VMB
	BRW	START_BOOT_1		; Continue in other psect
	SET_PSECT <YBTMEM,LONG>

START_BOOT_1::				; Entry point for re-execution of VMB

	MOVAB	BOOT_FAULT+1,R6		; Get the address of a handler.
	MOVAB	BOOTHIGH+^X200,R7	; Get the address of the first
					; byte past the SCB.

;
; Register usage in the loop below is as follows:
;
;	R6	- address (+1) of a machine check handler
;	R7	- address of 1 byte past a longword of SCB
;

FILL_SCB:				; Fill SCB vectors.
	MOVL	R6,-(R7)		; Write 1 vector.
	BITW	#^X1FF,R7		; Check for page boundary.
	BNEQ	FILL_SCB		; Need to write another vector.

;
; Write the address of the SCB into the SCB processor register.
;

	MTPR	R7,#PR$_SCBB		; Load SCB processor register.

;
; Read the system identification processor register to discover which
; kind of VAX is to be booted.
;

	MFPR	#PR$_SID,R8		; Read the CPU identification
					; processor register.
	ASHL	#-PR$V_SID_TYPE,R8,R8	; Get CPU identification code.
	BEQL	FATAL_ERROR		; Invalid processor code.
	CMPB	R8,#PR$_SID_TYPMAX	; Greater than known codes?
	BLEQU	SAVE_PROCID		; No. Branch to save code.

;
; Error return from VMB. Output a message on the console terminal,
; and halt.
;

FATAL_ERROR:				; Not a known processor.
	ERROR	</%BOOT-F-Unknown processor/>

;
; Processor is of known type. Store type code for later use by BOOTDRIVR
; and XDELTA.
;

SAVE_PROCID:				; Store processor code.
	MOVB	R8,EXE$GB_CPUTYPE	; Save processor code globally.

;
; If the DEBUG flag is defined (meaning that XDELTA has been linked
; with this primary bootstrap), set up 2 XDELTA handlers in the SCB --
; one for breakpoints and one for tbit traps. Then initialize the
; XDELTA breakpoint table, allocate 3 pages of stack, and, if requested,
; execute a breakpoint before proceeding with the bootstrap.
;

	.IF	DF,DEBUG		; If debugging is going on,
	MOVAB	XDELBPT,^X2C(R7)	; Set up BPT handler.
	MOVAB	XDELTBIT,^X28(R7)	; Set up TBIT handler.
	MOVAB	INI$BRK,XDELIBRK	; Store the initial breakpoint.
	MOVL	SP,R6			; Save current top of stack.
	MOVAB	<<STACK_PAG_CNT+1>*^X200>(R7),SP ; Create a stack,
					; add 1 page for the SCB
	BBC	#RPB$V_BOOBPT,R5,-	; If no BPT was requested in the
		NOBRK			; boot flags, just proceed.

;
; Initial breakpoint.
;
; Current register status is as follows:
;
;	R0-R5	- initial VMB input values
;	R6	- SP value at start of VMB
;	R7	- address of the SCB
;	R8	- processor identification code
;	R9-FP	- initial VMB input values
;	SP	- address of a 3-page stack
;
; Code following the breakpoint is going to restore SP to its original
; value. If you want to modify SP in XDELTA, modify R8 instead.
;

INI$BRK::				; Debugging breakpoint.
	BPT				; Stop in XDELTA.

NOBRK:					; Proceed with bootstrapping.
	MOVL	R6,SP			; Restore SP's original value.

	.ENDC				; End of debug conditional.


	.SBTTL	Initialize RPB

;++
;
; The next section of VMB writes the restart parameters into the RPB.
; These parameters include
;
;	the VMB input registers
;	the base address of the RPB
;	the boot device's CSR
;	the boot device adapter's configuration register (CR)
;	the address of the PFN bitmap
;	the address and length of the bootstrap device driver
;
; Current register settings are as follows:
;
;	R0-R5	- unchanged from time that VMB gained control
;	R7	- address of the SCB
;	R8	- processor identification code
;	R9-FP	- unchanged from time that VMB gained control
;	SP	- SP value from time that VMB gained control
;	
;--

;
; Store the boot parameters in the RPB, as well as the RPB starting
; address. CONSOLE-controlled restart code looks for the starting
; address contained within itself as a clue to VMS restartability.
;

	MOVL	R11,R6			; Save Halt PSL temporarily
	MOVAB	-^X200(SP),R11		; Calculate base address of RPB.
	MOVL	R11,BOO$GL_RPBBASE	; Save address for callback.
	MOVL	R11,RPB$L_BASE(R11)	; Save address in RPB.
	MOVQ	R0,RPB$L_BOOTR0(R11)	; Save boot registers R0-R1.
	MOVQ	R2,RPB$L_BOOTR2(R11)	; Save boot registers R2-R3.
	MOVQ	R4,RPB$L_BOOTR4(R11)	; Save boot registers R4-R5.
	MOVL	R10,RPB$L_HALTPC(R11)	; Save Halt PC in RPB
	MOVL	R6,RPB$L_HALTPSL(R11)	; Save Halt PSL in RPB
	MOVAL	BOO$AL_VECTOR,-		; Save address of boot device
		RPB$L_IOVEC(R11)	; driver
	CLRL	RPB$L_IOVECSZ(R11)	; Correct size of boot-driver wil be
					; set by the first call to BOO$QIO
	MOVL	AP,RPB$L_HALTCODE(R11)	; Save the halt code.
	MNEGL	#1,RPB$L_ADPPHY(R11)	; Initialize adapter physical address
	MNEGL	#1,RPB$L_CSRPHY(R11)	; Initialize CSR physical address

;
; Move device characteristics from the input registers into the RPB.
;

	MOVW	R3,RPB$W_UNIT(R11)	; Save the device unit number.
	MOVB	R0,RPB$B_DEVTYP(R11)	; Save the device type.

;
; From this point on AP contains the address of the Secondary Boot
; argument list.
;

	MOVAL	SECOND_PARAM,AP		; Address of Secondary Boot arg list

;
; Calculate the address of the CPU-specific table. CPU_CODES is a list
; of offsets from start of CPU_CODES to start of a CPU-specific data
; table.
;

	MOVZWL	CPU_CODES[R8],R8	; For a CPU, get offset to CPU
					; data from CPU-list table.
	MOVAB	CPU_CODES[R8],R8	; Add offset to address of
					; CPU-list table.

;
; Reserve space for an PFN bitmap that will desecribe all of physical
; memory. Store the address and size of the PFN bitmap in the RPB.
;

	MOVAB	^X200(R7),R10		; Get base of free memory (1
					; page past SCB base address).
	MOVAB	RPB$Q_PFNMAP+4(R11),R9	; Get pointer to RPB bitmap
					; address field.
	MOVL	R10,(R9)		; Store PFN bitmap address.
	MOVAB	BITMAP_PAG_CNT*512(R10),R10 ; Reserve pre-allocated bitmap pages
	SUBL3	(R9),R10,-(R9)		; Store bitmap size in RPB.

;
; Allocate the stack again. The previous allocation was just for use
; in XDELTA.
;

	MOVAB	<STACK_PAG_CNT*^X200>(R10),SP ; Create an stack.
	MOVL	SP,R10			; Adjust pointer to 1st unused
					; byte of free memory.

;
; Now continue execution of VMB in the appropriate place, based on
; whether this is the first execution of VMB (normal boot procedure)
; or whether this is a recursive execution of VMB (as requested via
; RPB$V_FINDMEM flag).
;
	MOVAB	CONTINUE_TBL,R6		; Get adr of continuation code adrs
	MOVL	CONTINUE_INDEX,R0	; Get continuation index code
	CVTWL	(R6)[R0],R0		; Calculate address of appropriate code
	JMP	(R6)[R0]		; Continue executing where left off

;
; Table of continuation addresses for continuation of
; algorithm that uses MA780 memory instead of MS780 memory
; for booting.  (Requested via RPB$V_FINDMEM flag.)  Each
; entry in this table points to the code at which execution
; continues after VMB has been moved into memory on a different
; memory controller.  This is to allow the physical addresses
; of memory to be altered by VMB.
;
CONTINUE_TBL:				; Table of continuation addresses
	RELADR	NORMAL_PATH,CONTINUE_TBL ; Path for normal VMB execution
	RELADR	CONT1_PATH,CONTINUE_TBL	; Continuation of VMB in MA780 memory
	RELADR	CONT2_PATH,CONTINUE_TBL	; Continuation of VMB in MS780 memory

CONTINUE_INDEX::			; Index into continuation table
	.LONG	0			; Normal VMB path index is 0
NORMAL_PATH:

	.SBTTL	Locate and test memory

;++
;
; The next section of the primary bootstrap program determines and
; records the size and pattern of available memory in a PFN bitmap.
; It does this by calling a processor specific subroutine linked with VMB.
; Each subroutine handles the sizing of memory and the testing of the
; pages.  A common routine (BOO$TEST_MEM) is called to allocate and
; initialize bitmap segments, and loop through the page testing.
; When the sizing and testing are complete, the resulting bitmap is
; neither contiguous nor necessarily dense.  There could be ranges of
; PFN's that are simply not present and will of course be assumed 
; to be bad.  At this point a contiguous chunk of memory is allocated
; and a clean, dense, contiguous bitmap is formed from the pieces.
;
; Current register settings are the following:
;
;	R0-R6	- scratch
;	R7	- address of the SCB
;	R8	- address of the CPU-specific table
;	R9	- address of RPB$Q_PFNMAP
;	R10	- address of 1st byte of unused good memory
;	R11	- address of the RPB
;	AP	- address of secondary boot argument list
;	FP	- scratch
;	SP	- address of a 3 page stack
;
; In previous versions of VMB, the RPB CONFREG field was filled in with
; a code indexed by TR number which identifies the adapter type of each
; NEXUS.  This is still done for 11/780 and 11/750 for backward compatibility
; of VMB.  For 11/730 and 11/7VV, the CONFREG array is filled in by INITADP
; at a later stage of bootstrapping.
;
;--

LOC_TEST_MEM:

;
; No assembly time initialization is allowed in VMB because the
; ERROR logic allows it to restart.
;
	CLRL	VMB$L_HI_PFN(AP)	; Init BITMAP data for
	ROTL	#21,#1,VMB$L_LO_PFN(AP)	; highest and lowest PFN
	CLRL	BITMAP_HI_INDX		; Highest bitmap page index
	ROTL	#<32-9>,R11,R0		; Base PFN for large bitmaps
	MOVAL	4096(R0),BITMAP_BAS_PFN ; is 2mb beyond RPB
;
; Initialize the pre-allocated PFN bitmap pages to zero.  There is
; at least one such page to hold the bitmap for the pre-tested
; block of memory in which we are running.  The size of this 
; pre-allocated bitmap is an integral number of pages.
;

	MOVL	4(R9),R6		; Get base of PFN bitmap.
	MOVC5	#0,(R6),#0,(R9),(R6)	; Set bitmap to all zeroes.
	MOVC5	#0,(R6),#0, -		; Zero fill the memory descriptors in
		#<RPB$C_MEMDSCSIZ*RPB$C_NMEMDSC>,RPB$L_MEMDSC(R11) ; the RPB
	CLRL	RPB$L_PFNCNT(R11)	; Init the count of good pages
	MOVL	R10,BITMAP_VEC_PTR	; Address of vector of bitmap addresses
	MOVC5	#0,(R10),#-1,#512*4,(R10) ; Init bitmap address vector.
;
; A side effect of the above MOVC5 is that R1 = R10
;
	MOVL	R3,R10			; Next free address (page bounded)
	MOVL	4(R9),R3		; Address of pre-allocated bitmap
	MOVL	#BITMAP_PAG_CNT,R2	; Number of pages of pre-alloc bitmap
10$:	MOVL	R3,(R1)+		; Store address of bitmap page
	MOVAL	^X200(R3),R3		; Next pre-allocated bitmap page
	SOBGTR	R2,10$			; Loop through pre-allocated page(s)

;
; Allow the bitmap page containing the RPB to be above the pre-allocated
; (8mb max) PFN bitmap.
;
	ASHL	#-<9+12>,R11,R0		; Bitmap index for RPB
	TSTL	@BITMAP_VEC_PTR[R0]	; Need a bitmap page for this
					; portion of the PFN bitmap?
	BGEQ	20$			; Branch if not
	MOVL	R10,@BITMAP_VEC_PTR[R0] ; Use one more pre-tested page
	MOVC5	#0,(R10),#0,#512,(R10)	; as the bitmap page
	MOVL	R3,R10			; Keep track of next free address
20$:
;
; In the 11/780 and 11/750 CPU implementations, the memory test routines
; check up to 16 slots (positions)  on the system bus for adapters or memory
; controllers. The 16-byte field RPB$B_CONFREG in the RPB stores each
; type of adapter/controller as the bootstrap finds it. Set up registers
; to facilitate this loop in the CPU-specific routines.
; In the 11/730 and 11/7VV, the CONFREG field is not filled in by VMB, but
; initialized in INITADP at a later stage of bootstrapping.  The difference
; is to maintain backward compatibility of VMB for currently supported systems.
;

	MOVAB	RPB$B_CONFREG(R11),R5	; Point to start of
					; configuration field.

;
; Now call the CPU-specific routine to locate and test memory.
;

	PUSHR	#^M<R9,R10,AP>		; Save some registers
	CVTWL	CPU_W_CHECKMEM(R8),R0	; Calculate address of a
	JSB	(R8)[R0]		; CPU-specific memory test
					; routine and call it.
	POPR	#^M<R9,R10,AP>		; Restore saved registers
	CMPL	BITMAP_HI_INDX,#BITMAP_PAG_CNT-1 ; All bitmap pre-allocated?
	BGTR	ALLOC_BITMAP		; Branch if not
	ADDL3	#1,BITMAP_HI_INDX,R0	; Actual number of the pre-allocated
					; bitmap pages that were used
	ASHL	#9,R0,RPB$Q_PFNMAP(R11)	; Record possibly smaller descriptor
	BRW	BITMAP_IS_OK		; Yes, don't need to move it

;
; Need to allocate a contiguous PFN bitmap and move the scattered 
; bitmap pages into it.
;
; The starting point for trying to allocate is 4096 pages (2mb) after
; the RPB.  The only pages that can be in use here that appear to be
; good and usable are the bitmap pages themselves when they are
; allocated as the first good PFN in a given bitmap page.
;

ALLOC_BITMAP:
	SUBL3	#1,BITMAP_BAS_PFN,R2	; Desired location for bitmap
	CLRL	R5			; Init "first alloc failure" flag
	BRB	45$
10$:	AOBLSS	VMB$L_HI_PFN(AP),R2,20$	; Calculate the next PFN
	ERROR	</%BOOT-F-Failed to allocate PFN bitmap/>
20$:	EXTZV	#0,#12,R2,R0		; Bitmap page relative PFN
	EXTZV	#12,#9,R2,R1		; Index to bitmap page
	MOVL	@BITMAP_VEC_PTR[R1],R1	; Address of bitmap page
	BGEQ	30$			; Branch if present
	BISW	#^XFFF,R2		; Skip this entire bitmap page
	BRB	40$
30$:	BBC	R0,(R1),40$		; Branch if page is bad
	ASHL	#9,R2,R0		; Address from PFN
	CMPL	R0,R1			; Same as bitmap page adr?
	BNEQ	50$			; Branch if not, its ok
					; Otherwise treat as a bad page
40$:	BBSS	#0,R5,45$		; Branch if not first alloc failure
	ADDL3	BITMAP_HI_INDX,R4,R2	; Skip the entire "pre-planned"
					; allocation area.  Some bitmap pages
					; may be in it, but in the wrong place
45$:	ADDL3	#1,R2,R4		; Reset start point of search
	ADDL3	#1,BITMAP_HI_INDX,R3	; Reset no. of pages to look for
50$:	SOBGEQ	R3,10$			; Next page in contiguous cluster

;
; Now move all the bitmap pages into the contiguous space just found
;

MOVE_BITMAP:
	ASHL	#9,R4,R3		; Starting adr of new bitmap
	MOVL	R3,4(R9)		; Record base adr of PFN bitmap
	MOVL	BITMAP_VEC_PTR,R6	; Adr of array of bitmap page adrs
10$:	MOVL	(R6)+,R1		; Adr of next bitmap page
	BGEQ	20$			; Branch if page is allocated
	MOVC5	#0,(R3),#0,#512,(R3)	; No good pages in this 2mb
	BRB	50$
20$:	CMPL	R1,R3			; No move needed?
	BNEQ	30$			; Branch if must move the page
	MOVAL	512(R3),R3		; Just adjust the bitmap adr
	BRB	50$
30$:	MOVC3	#512,(R1),(R3)		; Move the bitmap page
50$:	SOBGEQ	BITMAP_HI_INDX,10$	; Loop through all bitmap pages
	SUBL3	4(R9),R3,(R9)		; Store size of PFN bitmap
BITMAP_IS_OK:
	MOVL	BITMAP_VEC_PTR,R10	; Reset first free byte pointer

;
; Check for the presence of a CI port on the SBI.  If present try to locate
; the appropriate microcode file on the console medium (CI780.BIN).  If found,
; then load it into memory.  If not found and not booting from it, merely issue
; a warning message and continue on - presumably some human will correct the
; situation later.  If not found and booting, then give an error and HALT!
;

	.ENABLE LSB
	BSBW	BOO$CACHE_ALLOC		; Allocate the FILEREAD cache
	MOVZBL	RPB$B_DEVTYP(R11),R2	; Hold the device type
	LOCC	S^#NDT$_CI,#16,-
		RPB$B_CONFREG(R11)	; Look for the CI780
	BNEQ	10$			; CI port on the system, skip on
	CMPB	#BTD$K_HSCCI,R2		; Booting off the HSC/CI?
	BEQL	5$			; Yes, error
	BRW	50$			; No, just leave quietly

5$:	ERROR	</%BOOT-F-No such device/>

10$:	MOVB	#BTD$K_CONSOLE,-	; Temp set for reading from console
		RPB$B_DEVTYP(R11)	;  the ucode file
	MOVAB	UCODE_FILE,R1		; Pick up name for ucode file
	MOVZBL	(R1)+,R0		; Size to R0
	MOVQ	R0,-(SP)		; Form descriptor
	PUSHAQ	UCODE_STAT		; Temp area for the stat block
	PUSHL	R10			; Start of memory buffer area
	PUSHAQ	8(SP)			; File descriptor
	CALLS	#5,RTF$OPENFILE		; Look it up on the console medium
	BLBS	R0,30$			; Success, try to read it in
	CMPB	#BTD$K_HSCCI,R2		; Booting off the CI?
	BNEQ	20$			; No, leave severity
	MOVB	#^A/F/,UCODE_SEVER	; Yes, change to FATAL
20$:	CLRQ	-(SP)			; Null input buffer descriptor
	PUSHAB	UCODE_FAIL		; Error text
	CALLS	#3,BOO$READPROMPT	; Report the problem
	CMPB	#BTD$K_HSCCI,R2		; Booting off the CI?
	BNEQ	25$			; No, finish the boot anyway
	HALT				; Yes, **** FATAL ERROR ****

25$:	BRW	40$
;
; Found the CI and the CI ucode.  Now determine the place in memory to read
; the code into as well as put the page table.  The search starts at place
; indicated in the following table and stops just short of the FILEREAD
; cache (which is why the cache-init was done earlier).  If not enough
; memory can be found, halt with a message.
;
; NOTE:	If this table is changed, a corresponding table near the label
;	MEM_CACHE_TABLE needs to be checked for consistency.
;
MEM_TAB:
;		   SIZE,START
;		   ---- -----
	MEM_TABLE  8192,512		; More than 4 megabyte
	MEM_TABLE  2048,256		; More than 1 megabyte
	MEM_TABLE  1024,256		; More than 512k bytes
	MEM_TABLE     0,  0		;

30$:	PUSHL	R2			; Save old devtype
	MOVL	RPB$L_PFNCNT(R11),R1	; Maximum memory
	MOVAB	MEM_TAB,R3		; Addr of table
32$:	MOVL	(R3)+,R4		; Get the next table entry
	BEQL	34$			; Memory too small
	MOVZWL	(R3)+,R0		; Starting page number
	CMPL	R1,R4			; More memory than this entry?
	BLSS	32$			; Branch if not, get next entry
	MOVAB	127(R1),R1		; Set to round up
	ASHL	#-7,R1,R1		; Number of pages of page table needed
	ADDL	UCODE_STAT+4,R1		; Add in the ucode length
	MOVL	R1,R4			; Will not settle for less
	ASHL	#9,VMB$Q_FILECACHE+4(AP),R5; Start addr of FILEREAD cache
	BNEQ	33$			; Okay, if somethere there, else ..
	ASHL	#7,RPB$L_PFNCNT(R11),R5	; Use 1/4 of max as limit	
;
; Attempt to allocate the pages necessary: A page table to encompass all of
; physical memory and the full microcode file.  The entire size must fit
; at a lower address than the FILEREAD cache, since this allocation cannot
; be either stepped on or deallocated until INIT time.
;
33$:	BSBW	BOO$ALLOC_PAGES		; Grab the pages
	BGEQ	35$			; Success
34$:	ERROR	</%BOOT-F-Insufficient memory for CI/>

35$:	ADDL3	R2,R3,VMB$L_CI_HIPFN(AP); Set the highest PFN used
	ASHL	#9,R3,R6		; Address to read into
	PUSHL	R8			; Save register
	MOVQ	UCODE_STAT,R8		; Starting LBN and size
	ASHL	#9,R9,VMB$Q_UCODE(AP)	; Store size away
	MOVL	R6,VMB$Q_UCODE+4(AP)	; Store address away
	BSBW	READFILE		; Read it in
	POPL	R8			; Restore
	POPL	R2			; Restore old devtype
	BBSS	S^#VMB$V_LOAD_SCS,-	; Tell SYSBOOT to load SCS code
		VMB$L_FLAGS(AP),40$
40$:	MOVB	R2,RPB$B_DEVTYP(R11)	; Restore the 'real' boot device
50$:	MOVL	RPB$L_IOVEC(R11),R0	; Pick up vector address
	MOVL	R11,R9			; Transfer RPB address
	JSB	@BQO$L_MOVE(R0)[R0]	; Move the boot driver
	.DISABLE LSB

;
; Initialize the boot device's bus adapter.  If not console, call a
; CPU-specific subroutine to convert this data into the physical
; addresses of the adapter's configuration register (CR) and the
; device's control/status register (CSR). Store the addresses in the
; RPB.
;

ADPINIT:				; Initialize adapter.
	CMPB	RPB$B_DEVTYP(R11),-	; Skip over if booting from
		#BTD$K_CONSOLE		; console block storage device
	BEQL	15$
	MOVQ	RPB$L_BOOTR1(R11),R1	; Pick up original R1/R2
	CVTWL	CPU_W_SAVE_CSRS(R8),R5	; Calculate address of a
	JSB	(R8)[R5]		; CPU-specific routine to
					; calculate and save boot device
					; and adapter's CSRs in RPB.
	CMPB	RPB$B_DEVTYP(R11),-	; Skip over if booting from
		#BTD$K_HSCCI		;  HSC/CI adapter
	BEQL	10$
	MOVL	RPB$L_ADPPHY(R11),R0	; Get ADP CSR address.
	CVTWL	CPU_W_INIT_ADAP(R8),R1	; Calculate address of a
	JSB	(R8)[R1]		; CPU-specific adapter init.
					; routine and call it.
10$:	MOVL	RPB$L_IOVEC(R11),R0	; Pick up vector address
	MOVL	VMB$Q_UCODE+4(AP),-
		BQO$L_UCODE(R0)		; Transfer the ucode address
	MOVL	BQO$L_UNIT_INIT(R0),R1	; Pick up any possible routine
	BEQL	15$			; None
	CALLG	(AP),(R0)[R1]		; Do any necessary unit init
	BLBS	R0,15$			; All is well
	ERROR	</%BOOT-F-Failed to initialize device/>

15$:

;
; The adapter initialization routines exit with RSB instructions. Thus,
; control returns here, and proceeds to obtain the secondary bootstrap
; specification as described on the next page.
;

	.SBTTL	Identify and read in the secondary boot image

;++
;
; Current register settings are the following:
;
;	R0-R6	- scratch
;	R7	- address of the SCB
;	R8	- address of the CPU-specific table
;	R9	- scratch
;	R10	- address of the 1st byte of unused memory
;	R11	- address of the RPB
;	AP	- address of secondary boot parameter list
;	SP	- address of a 3 page stack
;
; Registers R0-R6 and R9 are available as scratch registers.
;
; The next 2 paragraphs refer to an 11/780-specific function. The
; function is historical; not implemented on later processors:
;
; The primary bootstrap now looks at a software bootstrap flag --
; RPB$V_BBLOCK. If the flag is set, the secondary bootstrap is a single
; block from the boot device. The LBN is stored in RPB$L_BOOTR4.
; Set up size of secondary bootstrap, transfer address, memory address,
; and LBN fields so that subsequent code can read the boot block into
; memory and transfer control to the code contained therein.
;
; If the RPB$V_BBLOCK flag is not set, the primary bootstrap must load
; a secondary bootstrap file specified by an ASCII file specification.
;
; If another boot flag -- RPB$V_SOLICT -- is set, the primary bootstrap
; asks the console user to type in a file specification.
;
; If the boot flag is not set, the bootstrap just selects a standard
; secondary bootstrap from the boot device. The bootstrap then calls I/O
; subroutines that locate the file, copy it into memory above the stack,
; and transfer control to the image's transfer address.
;
;--

;
; If we are booting from the console block storage device, it is 
; necessary to switch the media to the system floppy or cartridge.
; Type a message on console and wait for carriage return.
;

	CMPB	G^EXE$GB_CPUTYPE,#PR$_SID_TYP750 ; Booting on 750?
	BEQL	20$			; Br if yes to avoid prompt
	CMPB	RPB$B_DEVTYP(R11),-	; Booting from console block
		#BTD$K_CONSOLE		; storage device?
	BNEQ	20$			; No
	PUSHAB	INPBUF			; Push address of input buffer
	PUSHL	#2			; Push size of buffer
	PUSHAB	SWITCHPROMPT		; Push address of prompt string
	CALLS	#3,BOO$READPROMPT	; Prompt and wait for <ret>

;
; The next code paragraph is historical: refers only to the 11/780:
; If the boot block flag is set, prepare I/O input registers.
;

20$:	BBC	#RPB$V_BBLOCK,-		; If the boot from boot block
		RPB$L_BOOTR5(R11),-	; flag is not set, proceed to
		TEST_SOLICIT		; test the solicit bit.
	MOVL	#2,R5			; block to go, and transfer
					; address from start of block.
	MOVL	RPB$L_BOOTR4(R11),R8	; Get boot block LBN.
	MOVL	#1,R9			; Set block size to 1 block.
	BRW	READIN_BOOT		; Proceed to read in block.

;
; If the "solicit for secondary bootstrap file" flag is not set,
; just use a predefined file specification.
;

TEST_SOLICIT:				; Check for solicit.
	BBC	#RPB$V_SOLICT,-		; If "solicit" flag is not
		RPB$L_BOOTR5(R11),-	; set, just use a default file
		DEFAULT_SECOND		; specification.

;
; To solicit a file name, call a device-independent subroutine that
; writes a prompt string to the console terminal, and then reads the
; user typed file name. All device specifications are ignored.
;

	PUSHAB	RPB$T_FILE(R11)		; Set address of input buffer.
	PUSHL	#39			; Set maximum character count.
	PUSHAB	NAMEPROMPT		; Set address of prompt string.
	CALLS	#3,BOO$READPROMPT	; Prompt and read string.
	MOVL	#1,R9			; No retry if this file is not found
	BRB	FILEBOOT		; Go try to read the file.

;
; If the solicit boot flag was not set, use a default file name string.
; Usually, this file name is [SYSEXE]SYSBOOT.EXE. However, if the
; diagnostic boot flag is set, the file name is [SYSMAINT]DIAGBOOT.EXE.
;

DEFAULT_SECOND:				; Use default file name.
	MOVAB	VMSFILE,R7		; Assume SYSBOOT.EXE.
	BBC	#RPB$V_DIAG,-		; If the diagnostic flag is not
		RPB$L_BOOTR5(R11),-	; set, SYSBOOT is correct.
		COPY_NAME
	MOVAB	DIAGFILE,R7		; Otherwise, use predefined
					; name of diagnostic boot.

;
; Copy the file name to the RPB.
;

COPY_NAME:				; Copy file name.
	MOVZBL	(R7),R0			; Size of name string
	INCL	R0			; Include the byte count character
	MOVC3	R0,(R7),RPB$T_FILE(R11)	; Move name into RPB
	EXTZV	#RPB$V_TOPSYS,#RPB$S_TOPSYS,-
		RPB$L_BOOTR5(R11),R9 	; Value of 0-F means top level
					; system directory "SYS0" - "SYSF"
	CMPL	R9,#9			; 0 - 9 ?
	BLEQ	10$			; Branch if yes
	ADDL	#<<^A/A/>-<^A/9/>-1>,R9	; Add bias to make A - F
10$:	ADDB	R9,RPB$T_FILE+5(R11)	; Form "SYSn"

;
; Call a device-independent routine, FIL$OPENFILE to locate the named
; file on the disk.
;
; Registers set up are the following:
;
;	R10	- address of 1st byte of unused memory
;	R11	- address of the RPB
;


FILEBOOT:				; Locate the file.
	BSBW	BOO$CACHE_OPEN		; Open the FILEREAD cache
10$:	PUSHAB	RPB$T_FILE+1(R11)	; Address of file name string.
	MOVZBL	RPB$T_FILE(R11),-(SP)	; Character count of file name.
	MOVAL	-(SP),R6		; Allocate scratch for channel
					; and get adr of scratch storage
	PUSHAL	RPB$L_FILLBN(R11)	; RPB fields that receive file
					; statistics during OPEN.
	PUSHAL	(R10)			; File header buffer at end of
					; memory.
	PUSHAL	^X200(R10)		; Index file header buffer at
					; end of memory.
	PUSHAL	4(R6)			; Address in file name desc.
	PUSHAL	(R6)			; Address of phony channel.
	CALLS	#5,FIL$OPENFILE		; Call FILREAD to locate file.
	ADDL2	#12,SP			; Clean up scratch space
	BLBS	R0,FILE_CONTIG		; Branch on success.

;
; File was not found.  If looking up default secondary boot file in
; SYS0 top level system directory, try the lookup with a null TOPSYS.
;

	CMPW	R0,#SS$_NOSUCHFILE	; If not "no such file"
	BNEQ	30$			; then don't consider a second try
	TSTL	R9			; If TOPSYS is not "SYS0"
	BNEQ	30$			; then don't consider a second try
	INCL	R9			; Only one extra try
	MOVZBL	(R7)+,R0		; Default string byte count
	SUBL	#6,R0			; Discard "[SYS0."
	ADDB3	#1,R0,RPB$T_FILE(R11)	; Store shorter byte count
					; Include the "["
	MOVC3	R0,6(R7),RPB$T_FILE+2(R11) ; From just after "[SYS0."
					; to just after "["
	BRB	10$			; Try again with a null TOPSYS
30$:

;
; File was not found. Report an error.
;

	CMPW	#SS$_NOSUCHDEV,R0	; "No such device" error?
	BNEQ	FILOPN_ERR		; Branch if not.
	BRW	NOSUCHDEV		; Report "no such device" error.

FILOPN_ERR:				; Report unknown error.
	ERROR	</%BOOT-F-Unable to locate BOOT file/>
					; Output error message.

;
; File was located successfully. Make sure that the file is contiguous.
; The file statistics block is the following:
;
;	+----------------------+
;	|     starting LBN     | (0 if file not contiguous)
;	+----------------------+
;	|    size in blocks    |
;	+----------------------+
;

	ASSUME	RPB$L_FILSIZ EQ RPB$L_FILLBN+4

FILE_CONTIG:				; Test for contiguity.
	MOVQ	RPB$L_FILLBN(R11),R8	; Get file statistics.
	TSTL	R8			; Contiguous file?
	BNEQ	READ_HEADER		; Yes, continue.
	ERROR	</%BOOT-F-Bootfile not contiguous/>
					; Output error message.

;
; If the software boot control flags indicate that that transfer
; address of the secondary bootstrap is stored in the image file's
; header block, read that header block. Otherwise, assume that the
; transfer address is simply the 1st byte in the image file.
;

READ_HEADER:				; Read header if necessary.
	CLRL	R5			; Assume no transfer address.
	BBC	#RPB$V_HEADER,-		; If no header requested,
		RPB$L_BOOTR5(R11),-	; then just branch past header
		READIN_BOOT		; reading code.
	MOVL	R10,R6			; Start of free memory
	MOVL	#1,R9			; Header is always only 1 block.
	BSBW	READFILE		; Read header block.
	MOVQ	RPB$L_FILLBN(R11),R8	; R8 = 1st LBN, R9 = block count
	MOVQ	R9,R2			; R2 = block count, R3 = hdr adr
	BSBW	BOO$IMAGE_ATT		; Get image attributes
;
; R1 = image header block count
; R2 = size of file in blocks excluding symbol table and patch text
;
	MOVL	R1,RPB$B_HDRPGCNT(R11)	; Store image header block count
	SUBL3	R1,R2,R9		; Blocks in image after header block(s)
	ADDL	R1,R8			; LBN of first block beyond headr block(s)
	MOVZWL	IHD$W_ACTIVOFF(R10),R1	; Get offset to image
					; activation data in header.
	ADDL	R10,R1			; Form transfer vector address.
	MOVL	(R1),R5			; Get transfer address.

;
; Now read in the file. If the file is too large for the remaining
; memory space, see if the required additional pages are usable.
; If they are, use them.  If not issue a fatal diagnostic and HALT.
;
; Registers set up now are the following:
;
;	R5	- transfer address
;	R8	- starting LBN of file (after header)
;	R9	- size of file in blocks
;	R10	- address of 1st byte in free memory
;	R11	- address of the RPB
;	AP	- secondary boot argument list
;

READIN_BOOT:

	BRW_PSECT READIN_BOOT_1

;
; The following code disables XDELTA and sets up to read the secondary
; bootstrap in over most of VMB.  The picture of memory is still
; preserved for backwards compatibility.  Only the size of the primary
; boot is smaller.
;

	MOVAL	OVERLAY_START,R7	; End of all drivers, page aligned
	MOVQ	RPB$Q_PFNMAP(R11),R0	; Descriptor for PFN bitmap
	MOVQ	R0,R2			; Save a copy
	ROTL	#9,#BITMAP_PAG_CNT,R1	; Max pre-allocated byte count
	CMPL	R0,R1			; Use the smaller for the
	BLEQ	20$			; backward compatible
	MOVL	R1,R0			; maximum 8mb bitmap
20$:	MOVAL	^X200(R7),R1		; backward compatible bitmap
	MOVQ	R0,RPB$Q_PFNMAP(R11)	; Store new descriptor for small bitmap
	CMPL	R3,SP			; If this is a large bitmap,
	BGTR	30$			; then it is above VMB
	MOVQ	R0,R2			; Otherwise use the new
30$:	MOVQ	R2,VMB$Q_PFNMAP(AP)	; descriptor of the small bitmap
	MOVAL	^X200(R0),R0		; Additional page of SCB to move
	PUSHL	R5			; Preserve this from MOVC
	INCL	MUST_HALT		; Disable restart from ERROUT
	MOVC3	R0,BOOTHIGH,(R7)	; Move the SCB and pre-allocated bitmap
	POPR	#^M<R5>			; Restore image start offset
	MOVAB	<STACK_PAG_CNT*^X200>(R3),SP ; Move stack adjacent to bitmap
	MOVL	SP,R10			; First free address above VMB
	MOVL	R10,R6			; Buffer for read

;
; Will the desired number of blocks fit in the space remaining in the
; pre-tested 64kb of memory?  If not, check that the additional pages
; required are usable.  If they are, then read it all, otherwise quit.
;

CHECK_BOOT_FIT:
	ROTL	#<32-9>,R11,R0		; PFN for RPB
	MOVAL	127(R0),R0		; Last PFN guaranteed to be good
	ROTL	#<32-9>,R10,R1		; Starting PFN for read
	ADDL	R9,R1			; Last+1 PFN needed to be good
	BRB	30$			; Zero or more iterations
10$:	BBC	R0,@VMB$Q_PFNMAP+4(AP),SECOND_TOO_BIG ; Branch if cannot
					; read the entire secondary boot
30$:	AOBLSS	R1,R0,10$		; Check the next page

;
; Disable XDELTA, no debugging from here on.  The following read will
; overwrite the XDELTA code.
;

	MOVAB	BOOT_FAULT+1,^X28(R7)	; Shut off XDELTA TBIT handler and
	MOVAB	BOOT_FAULT+1,^X2C(R7)	; BPT handler in new copy of SCB
	MTPR	R7,#PR$_SCBB		; Set new SCB address
;
; Now read the secondary boot code into memory
;

	BSBB	READFILE		; Read.

;
; The secondary bootstrap is now in memory. If the software boot control
; flags asked for a HALT before the secondary bootstrap gains control,
; execute a HALT instruction. Otherwise, transfer control to the new
; bootstrap image.
;

	BBC	#RPB$V_HALT,-		; If boot flags don't call for
		RPB$L_BOOTR5(R11),-	; halt, just transfer to new
		START_SECOND		; bootstrap image.
	HALT				; Otherwise, HALT.

START_SECOND:				; Transfer to secondary boot.
	JMP	(R5)[R10]		; Execute JUMP.

;
; Secondary bootstrap does not fit in the pre-tested 64kb and
; one or more of the required adjacent pages is not usable.
;

SECOND_TOO_BIG:
	ERROR	</%BOOT-F-Boot file too big/>


;
; No such device error reporting.
;

NOSUCHDEV:				; "No such device" I/O error.
	ERROR	</%BOOT-F-Nonexistent drive/>
					; Output error message.

	.SBTTL	READFILE, Reads bootstrap file in large chunks

;++
;
; Functional description:
;
;	Calls the device-independent bootstrap QIO routine to read
;	a file. Divides the file into pieces as large as possible, so
;	that the read is a small number (like 1) of DMA transfers.
;
; Inputs:
;
;	R6	- buffer address
;	R8	- logical block number (LBN)
;	R9	- number of blocks in file
;
; Implicit inputs:
;
;	IO_SIZE	- largest number of blocks possible in single transfer
;
; Outputs:
;
;	Registers R1-R4, and R5 must be preserved.
;
;	R6	- buffer address updated past last byte read
;	R8	- LBN updated to block after last block read
;	R9	- blocks in file (reduced to number not read)
;
; Implicit outputs:
;
;--

READFILE:				; Read file into memory.
	MOVZBL	#IO_SIZE,R7		; Assume maximum transfer size.
	CMPL	R7,R9			; Minimize with file size.
	BLEQ	10$			; Branch if file larger than
					; maximum transfer size.
	MOVL	R9,R7			; Set to remaining file size.

10$:					; Push arguments for QIO.
	PUSHL	R11			; Push phony channel number.
	PUSHL	#0			; Physical read mode.
	PUSHL	#IO$_READLBLK		; Read logical block function.
	PUSHL	R8			; Starting LBN.
	ROTL	#9,R7,-(SP)		; Transfer size in bytes.
	PUSHL	R6			; Buffer address
	ADDL	4(SP),R6		; Update buffer address.
	ADDL	R7,R8			; Update LBN.
	CALLS	#6,BOO$QIO		; Call a bootstrap QIO routine.
	BLBS	R0,20$			; Continue on success.
	CMPW	#SS$_NOSUCHDEV,R0	; "No such device" error?
	BEQL	NOSUCHDEV		; Branch if yes.
	ERROR	<\%BOOT-F-I/O error reading boot file\>
					; Output error message.

20$:					; Read more file if any left.
	SUBL	R7,R9			; Decrement blocks remaining.
	BGTR	READFILE		; Continue if not done.
	RSB				; Return to caller when done.

;
; Entry point for reading a single logical block from a device.  Needed
; by the RT file open routine.
;

	SET_PSECT <YFILEREAD,BYTE>

	.ENTRY	FIL$READ_LBN,^M<R6,R7,R8,R9>


	MOVL	8(AP),R6		; The buffer address
	MOVL	4(AP),R8		; The LBN to grab
	MOVL	#1,R9			; One block only
	BSBW	READFILE		; Do it
	RET				; Leave

	.SBTTL	CPU-specific Tables.

	SET_PSECT <YBTMEM,LONG>

;
; Map CPU identification codes to CPU-specific data tables.
;

CPU_CODES:				; CPU identification table.
	.WORD	0			; Code 0 is not valid.
	CPU_IDENT-			; Identify 11/780 (code 1).
		LABEL=CPU_CODES,-	; Name of table.
		TABLE=780		; Table address.

	CPU_IDENT,-			; Identify 11/750 (code 2).
		LABEL=CPU_CODES,-	; Name of table.
		TABLE=750		; Table address.

	CPU_IDENT,-			; Identify 11/730 (code 3)
		LABEL=CPU_CODES,-	; Name of table.
		TABLE=730		; Table address

	CPU_IDENT,-			; Identify 11/7VV (code 4)
		LABEL=CPU_CODES,-	; Name of table
		TABLE=7VV		; Table address

;
; Tables of CPU-specific information.
;

	CPU_DEF	LABEL=780		; 11/780 CPU-specific table.

	CPU_DEF	LABEL=750		; 11/750 CPU-specific table.

	CPU_DEF	LABEL=730		; 11/730 CPU-specific table.

	CPU_DEF	LABEL=7VV

	.SBTTL	Test memory

;++
;
; Functional description:
;
;	This routine tests a given range of PFN's and builds one or
;	more bitmap pages.  Each bitmap page address is recorded in
;	the corresponding long word in the bitmap page address array.
;
; Calling Sequence:
;
;	JSB	BOO$TEST_MEM
;
; Inputs:
;
;	R2 = address of page test routine
;	R3 = number of pages to test
;	R9 = starting page number
;	R11 = address of Restart Parameter Block
;	BITMAP_VEC_PTR - contains the base address of the bitmap
;		page address array.
;	SECOND_PARAM - is the address of the Secondary Boot parameter
;		list.  The lowest and highest PFN's seen are to be
;		recorded here.
;
; Outputs:
;
;	R0,R1,R2,R3,R6,R9 altered
;	others preserved
;
;	Store address of newly allocated bitmap page(s) in the vector
;		pointed to by BITMAP_VEC_PTR and indexed by the
;		high 9 bits of the PFN's covered by the bitmap page.
;	Record the lowest (inclusive) and highest (exclusive) PFN's 
;		seen in the offsets VMB$L_LO_PFN and VMB$L_HI_PFN
;		of the Secondary Boot Parameter list (SECOND_PARAM).
;	Record the highest bitmap page index used in the vector of
;		bitmap page addresses (BITMAP_HI_INDX).
;
;--

;
; Scratch storage offset definitions
;
	$OFFSET	0,NEGATIVE,<-
	NXT_PFN,-		; Starting PFN for next segment of bitmap
	NXT_PAGCNT,-		; Page count remaining
	PRETST_PFN,-		; Pre-tested starting PFN
	PRETST_CNT,-		; Pre-tested page count
	PAGTST,-		; Address of page test routine
	<SCRATCH_SIZE,0>-	; Size of scratch area
	>

BOO$TEST_MEM::
	PUSHR	#^M<R4,R5,R7,R8,R10,FP,AP>
	MOVAL	SECOND_PARAM,AP		; Point at Secondary Boot Parameter list
	MOVL	SP,FP			; Use FP as a local pointer
	SUBL	#-SCRATCH_SIZE,SP	; Reserve local storage
	ROTL	#<32-9>,R11,PRETST_PFN(FP) ; Set start of pre-tested pages
	ROTL	#7,#1,PRETST_CNT(FP)	; 128 pre-tested pages
	MOVL	R2,PAGTST(FP)		; Save address of page test routine
	ADDL3	R3,R9,R0		; Last + 1 PFN
	CMPL	R0,VMB$L_HI_PFN(AP)	; Higher than last highest?
	BLEQ	10$			; Branch if not
	MOVL	R0,VMB$L_HI_PFN(AP)	; Yes, record the highest value
10$:	CMPL	R9,VMB$L_LO_PFN(AP)	; Is the starting PFN smaller than
					; the currently recorded smallest?
	BGEQ	20$			; Branch if not
	MOVL	R9,VMB$L_LO_PFN(AP)	; Yes, record the smallest one seen
20$:
NEXT_BITMAP:
	EXTZV	#0,#12,R9,R2		; No. of pages from beginning
					; of bitmap page (4096 bits/page)
	ADDL	R2,R3			; Page count is larger by that amount
	MOVL	R3,R1			; Save this page count
	ROTL	#12,#1,R0		; Max of 4096 pages per bitmap page
	CMPL	R3,R0			; More than a bitmap's worth?
	BLEQ	10$			; Branch if not
	MOVL	R0,R3			; Yes, use the max
10$:	SUBL3	R3,R1,NXT_PAGCNT(FP)	; No. of pages left for next iteration
	SUBL	R2,R3			; Actual no. of pages to test
	ADDL	R9,R3			; Last + 1 PFN to be tested
	MOVL	R3,NXT_PFN(FP)		; Save for next iteration if any
	ASHL	#-12,R9,R10		; Index to bitmap page address array
	CMPL	R10,BITMAP_HI_INDX	; Is this the highest index seen?
	BLEQ	20$			; Branch if not
	MOVL	R10,BITMAP_HI_INDX	; Keep track of the highest index
20$:	MCOML	#0,R6			; Bitmap page address not set yet
	BBS	#RPB$V_NOTEST,RPB$L_BOOTR5(R11),- ; If not testing memory
		INIT_BITMAP		; then fill in bit map as all good

;
; Test each page for gross errors unless RPB$V_NOTEST is set. For each
; page available and good (if tested), set the corresponding bit in
; the PFN bitmap.
;

MEM_LOOP:				; Test one controller's worth.
	CMPL	R9,PRETST_PFN(FP)	; Is this a the next pre-tested page?
	BNEQ	TEST_PAGE		; Branch if not, go test it

;
; Just handle these pre-tested pages one at a time.  There are only
; 128 of them, and handling them as a unit means they are restricted 
; to being in the same bitmap segment.  It is required that they be
; in one controller, but this further breakdown into 4096 page units
; which fit into a one page bitmap is artificial.
;

	INCL	PRETST_PFN(FP)		; Yes, step to next PFN
	SOBGTR	PRETST_CNT(FP),GOOD_PAGE ; Count these pages
					; Treat it as good, don't retest
	MCOML	#0,PRETST_PFN(FP)	; No, more pre-tested pages left
	BRB	GOOD_PAGE		; Last pre-tested page is good too
TEST_PAGE:
	ASHL	#9,R9,R0		; Convert page # to physical address
	ROTL	#6,#1,R1		; Loop counter for 64 quadwords.
	JSB	@PAGTST(FP)		; Test this page
GOOD_PAGE:				; Good page here.
	TSTL	R6			; Is the bitmap set up yet?
	BLSS	INIT_BITMAP		; Branch if no, must init one
COUNT_PAGE:
	BBSS	R9,(R6),NEXT_PAGE	; Set bit in bitmap; do next page
	INCL	RPB$L_PFNCNT(R11)	; Increment good page count.

;
; If more pages remain in this bitmap segment, continue looping.
;

NEXT_PAGE:				; Do next page, if any.
	AOBLSS	R3,R9,MEM_LOOP	; Process next page if any
CHK_NEXT_BITMAP:
	MOVL	NXT_PFN(FP),R9		; Starting PFN for next bitmap segment
	MOVL	NXT_PAGCNT(FP),R3	; Another bitmap segment to do?
	BNEQ	NEXT_BITMAP		; Branch if yes
	MOVL	FP,SP			; Clean off local storage
	POPR	#^M<R4,R5,R7,R8,R10,FP,AP> ; Recover saved registers
	RSB				; and return
;
; Handler that gains control when a page has gross memory errors.
; Entered via a BRW from the actual machine specific handler after it
; has done the machine specific thing necessary to clear the condition
;

BOO$PAGE_MCHECK::			; Skip current page.
	SUBL3	#-SCRATCH_SIZE,FP,SP	; Restore stack pointer.
	BRB	NEXT_PAGE		; And get the next page
;
; Allocate and initialize a page of bitmap for this bitmap segment
;
INIT_BITMAP:
	MOVL	@BITMAP_VEC_PTR[R10],R6 ; Is bitmap page allocated?
	BGEQ	GOT_BITMAP		; Branch if yes
	ADDL3	R10,BITMAP_BAS_PFN,R2	; Desired PFN for this bitmap page
	EXTZV	#0,#12,R2,R0		; Bitmap page relative PFN
	EXTZV	#12,#9,R2,R1		; Index to bitmap page
	MOVL	@BITMAP_VEC_PTR[R1],R1	; Address of bitmap page
	BLSS	20$			; Branch if entire bitmap page not there
	BBC	R0,(R1),20$		; Branch if desired page was bad
					; or not yet tested
	ASHL	#9,R2,R6		; Form bitmap adr from PFN
	BRB	30$
20$:	ASHL	#9,R9,R6		; Use first good page mapped by this
					; bitmap to hold this bitmap page
30$:	PUSHL	R3			; Save last PFN to be tested
	MOVC5	#0,(R6),#0,#512,(R6)	; Init all PFN's bad
	POPR	#^M<R3>			; Restore last PFN to be tested
	MOVL	R6,@BITMAP_VEC_PTR[R10] ; Record adr of bitmap page
GOT_BITMAP:
	ASHL	#-3,R9,R0		; Form byte offset from the beginning
	BICW	#^X1FF,R0		; of the bitmap to PFN 0
	SUBL	R0,R6			; so that BBSS PFN,(R6) will work
	BBC	#RPB$V_NOTEST,RPB$L_BOOTR5(R11),- ; Branch if testing memory
		COUNT_PAGE
;
; Set bits for pages which are not to be tested, but assumed good.
;
	SUBL3	R9,R3,R2		; Count of pages to mark good
	ADDL	R2,RPB$L_PFNCNT(R11)	; Add them in as good pages
	MOVL	#32,R0			; Set 32 bits per iteration
	BICL3	#31,R2,R1		; Even no. of longwords worth
	MOVAB	-(R1)[R9],R1		; R1=R1-1+R9 = last PFN inclusive
					; for 32 at a time loop
20$:	INSV	#-1,R9,R0,(R6)		; Mark these pages good
	ACBL	R1,R0,R9,20$		; R9=R9+R0, If R9 LEQ R1 then GOTO 20$
	EXTZV	#0,#5,R2,R0		; No. of bits remaining to be set
	BEQL	30$			; Branch if all bits are set
	CLRL	R2			; Stop the next time around
	BRB	20$			; Set the remaining bits
30$:	BRW	CHK_NEXT_BITMAP

	.SBTTL	SAVE_CSRS, CPU-specific routines

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	determines from input registers the addresses of the boot
;	device's CSR and the attached adapter's CSR, and stores these
;	addresses in the RPB.
;
; Inputs:
;
;	R1	- address of the boot device's adapter
;
;			11/780	- <31:4> MBZ
;				  <3:0> TR number
;			11/750	- <31:24> MBZ
;				  <23:0> address of the I/O page for the
;					 boot device's adapter
;
;	R2	- UNIBUS:
;
;			<31:18> MBZ
;			<17:3> UNIBUS address of the device's CSR
;			<2:0> MBZ
;
;	R2	- MASSBUS or CI:
;
;			not used
;
;	R11	- address of the Restart Parameter Block
;
; Implicit inputs:
;
;	The boot device may be located on any UNIBUS, MASSBUS, or CI  adapter.
;
; Outputs:
;
;	R8, R11, and SP must be preserved.
;
; Implicit outputs:
;
;	The RPB fields RPB$L_ADPPHY and RPB$L_CSRPHY contain the
;	addresses of the adapter's register space and the boot device's
;	register space respectively. For CI or MASSBUS devices, these values
;	are identical.
;
;--

	.SBTTL	SAVE_CSR_780, Save CSRs for 11/780
	.SBTTL	SAVE_CSR_730, Save CSRs for 11/730
	.SBTTL	SAVE_CSR_7VV, Save CSRs for 11/7VV

;++
;
; SAVE_CSR_780, Save CSRs for 11/780
; SAVE_CSR_730, Save CSRs for 11/730
; SAVE_CSR_7VV, Save CSRs for 11/7VV
;
; Implicit inputs:
;
;	R1 contains the system bus address in the form of a TR number
;	because TR numbers map to fixed physical addresses.
;
;	Bus adapters on the 780 start at address IO780$AL_IOBASE for TR 0,
;	and increment by ^X2000 each subsequent adapter. UNIBUS address
;	space for the first UNIBUS in the configuration starts at
;	IO780$AL_UB0SP. The second through fourth UNIBUS start 64kb after
;	the previous UNIBUS. UNIBUS device CSRs are in the last 64kb of
;	the UNIBUS address space.
;
;	The I/O space layout for the 11/730 is the same as that
;	described above for the 11/780 except that the base of
;	TR 0 register space is IO730$AL_IOBASE and UNIBUS 0 space
;	starts at IO730$AL_UB0SP.  Also, only one UNIBUS will ever
;	be configured on an 11/730.
;
;	The I/O space on the 11/7VV allows for multiple (2) SBIA's.
;	The offsets for NEXUS within an SBI are the same as on the 11/780.
;	For the 11/7VV, R1 can have a value from 1 to 16, with bits 4 and 5
;	indicating which A-bus adapter hosts the system bus.
;
; Outputs:
;
;	R5-R11 and AP-SP are preserved.
;
;--

SAVE_CSR_780:				; Save CSRs for the 11/780
	MOVAL	@#IO780$AL_IOBASE,R3	; Get adapter 0 space.
	MOVAL	@#IO780$AL_UB0SP,R4	; Get UB 0 space
	BRB	SAVE_CSR_COMMON		; Join common code

SAVE_CSR_730:				; Save CSRs for the 11/730.
	MOVAL	@#IO730$AL_IOBASE,R3	; Get adapter 0 space
	MOVAL	@#IO730$AL_UB0SP,R4	; Get UB0 space
	BRB	SAVE_CSR_COMMON		; Join common code

SAVE_CSR_7VV:
	MOVAL	@#IO7VV$AL_IOA0,R3	; Assume start of 1st SBIA
	EXTZV	#RPB$V_ABUS,#RPB$S_ABUS,R1,R4	; Get A-bus adapter number
	INSV	R4,#25,#RPB$S_ABUS,R3	; Insert to make physical address ********
	MOVAL	@#IO7VV$AL_UB0SP,R4	; Get adapter 0 and UB 0 space


SAVE_CSR_COMMON:			; Common code from here on

;
; Compute and save adapter configuration register address:
;

	ROTL	#13,R1,R0		; Convert TR # to adapter
	ADDL	R3,R0			; configuration address
	MOVL	R0,RPB$L_ADPPHY(R11)	; Store in RPB
	MOVL	R0,RPB$L_CSRPHY(R11)	; Store in device CSR too in
					; case this is a MASSBUS or CI device.

;
; Read the configuration register to determine whether the adapter is
; for a UNIBUS, MASSBUS, or CI. Bits <31:3> of the configuration register
; identify the adapter type.
;

	MOVL	(R0),R3			; Read the adapter's CR.
	MOVB	R3,RPB$B_BOOTNDT(R11)	; Save boot adapter's nexus device type.
	BICL3	#3,R3,R0		; Clear the bits representing
					; a UBA number to obtain the
					; canonical adapter type.
	CMPB	#NDT$_UB0,R0		; Is this a UNIBUS adapter?
	BEQL	UBA_ADAPTER		; Yes. Go compute device's CSR.
	RSB				; RPB$L_CSRPHY already set for 
					; MASSBUS or CI, so return.

UBA_ADAPTER:				; Compute UNIBUS device's CSR.
	BISL3	R4,R2,-			; Add UNIBUS CSR value to
		RPB$L_CSRPHY(R11)	; base of all UNIBUS address
					; space.
	CLRL	R0			; Get start of this ub space
	INSV	R3,#18,#2,R0		; relative to UB0 space.
	ADDL	R0,RPB$L_CSRPHY(R11)	; Adjust CSR address to this UB space.
	RSB				; Return.

	.SBTTL	SAVE_CSR_750, Save CSRs for 11/750

;
;*****
; Add code to accept a slot number between 0 and 15 in R1.
;*****
;

;++
;
; SAVE_CSR_750, Save CSRs for 11/750
;
; Implicit inputs:
;
;	For a MASSBUS boot device, R1 contains a 24-bit address of the
;	MASSBUS adapter's address space. The MBAs start at fixed
;	addresses that correspond to NEXUS slots 20-23:
;
;		MBA0	^XF28000, slot 20	IO750$AL_MBBASE
;		MBA1	^XF2A000, slot 21	IO750$AL_MBBASE+^X2000
;		MBA2	^XF2C000, slot 22	IO750$AL_MBBASE+^X4000
;		MBA3	^XF2E000, slot 23	IO750$AL_MBBASE+^X6000
;
; 	For a UNIBUS boot device, R1 contains a 24-bit address of the
;	boot device UNIBUS' I/O page. The I/O pages start at fixed
;	addresses that correspond to UNIBUS adapters also at fixed
;	addresses that correspond to NEXUS slots 24-25:
;
;		UNIBUS 0 I/O page	^XFFE000,
;		  IO750$AL_UBBASE, UBI0	^XF30000, slot 24
;
;		UNIBUS 1 I/O page	^XFBE000,
;		  IO750$AL_UBBASE+^X2000,
;		  		   UBI1	^XF32000, slot 25
;
;	UNIBUS address space:
;
;		UBI0	^XFC0000:^XFFFFFF	IO750$AL_UB0SP
;		UBI1	^XF80000:^XFBFFFF	IO750$AL_UB0SP+^X40000
;
;	The routine reduces the adapter's physical address to a slot
;	number from 0-15, and stores the number in the RPB for later
;	use by INIT.
;
; Outputs:
;
;	R1-R11 and AP-SP are preserved.
;
; Implicit outputs:
;
;	This routine derives the slot number (less 16) for the boot
;	device's adapter and loads the number into RPB$L_BOOTR1. Later
;	INIT uses the value in RPB$L_BOOTR1 as an index into the RPB
;	CONFREG field to find the adapter type of the boot device.
;
;--

SAVE_CSR_750:				; Save CSRs for the 11/750.
	CMPL	R1,#IO750$AL_UBBASE	; Is this a MASSBUS adapter?
	BGEQU	DERIVE_UBIADDR		; No. Go derive UBI address.
	MOVB	#NDT$_MB, -		; Save boot adapter's nexus device
		RPB$B_BOOTNDT(R11)	; type.
	MOVL	R1,RPB$L_ADPPHY(R11)	; Yes, store MBA's CR in RPB.
	MOVL	R1,RPB$L_CSRPHY(R11)	; And store in RPB$L_CSRPHY too.
	BRB	DERIVE_SLOTNUM		; Branch to derive slot number.

DERIVE_UBIADDR:				; Reduce R1 to UBI address.
	CMPL	R1,#IO750$AL_UB0SP	; Is this UNIBUS 1 or UNIBUS 0?
	BGTRU	10$			; UNIBUS 0. Go load addresses.
	MOVB	#NDT$_UB1, -		; Save boot adapter's nexus device
		RPB$B_BOOTNDT(R11)	; type.
	ADDL3	#IO750$AL_UBBASE,-	; UNIBUS 1. Load the ADPPHY
		#IO750$AL_PERNEX,-	; field with UBI1 address.
		RPB$L_ADPPHY(R11)
	BISL3	#<IO750$AL_UB0SP-	; Create and store away the
		-^X40000+^O760000>,R2,-	; boot device's CSR address.
		RPB$L_CSRPHY(R11)
	BRB	GET_UBI_ADDR		; Branch to common UBI code.

10$:					; UNIBUS 0. Load addresses.
	MOVB	#NDT$_UB0, -		; Save boot adapter's nexus device
		RPB$B_BOOTNDT(R11)	; type.
	MOVL	#IO750$AL_UBBASE,-	; Store address of 1st UNIBUS
		RPB$L_ADPPHY(R11)	; adapter.
	BISL3	#<IO750$AL_UB0SP-	; Calculate and load the full
		+^O760000>,R2,-		; CSR address into RPB.
		RPB$L_CSRPHY(R11)

GET_UBI_ADDR:				; Obtain UBI address.
	MOVL	RPB$L_ADPPHY(R11),R1	; Get address of associated UBI.

DERIVE_SLOTNUM:				; Derive and save slot number.
	SUBL3	#IO750$AL_IOBASE,R1,R0	; Get adapter's offset from base
					; of I/O space.
	DIVL	#IO750$AL_PERNEX,R0	; Divide by size of one adapter.
	MOVL	R0,RPB$L_BOOTR1(R11)	; Save the slot number.
	RSB				; Return to caller.

	.SBTTL	INIT_ADAP, CPU-specific adapter initialization routine

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	initializes the adapter for the boot device, if the adapter
;	requires such an initialization.
;
; Inputs:
;
;	R0	- physical address of the adapter
;	R1-R6	- scratch
;	R7	- address of the SCB
;	R8	- address of the CPU-specific table
;	R9	- scratch
;	R10	- address of the 1st unused byte of good memory
;	R11	- address of the RPB
;
; Implicit inputs:
;
;	If the value in R0 is identical to the value in RPB$L_CSRPHY,
;	the adapter is for a UNIBUS. Otherwise, the adapter is for a
;	MASSBUS.
;
; Outputs:
;
;	R7-R8, R10-R11, and SP must be preserved.
;
; Implicit outputs:
;
;	The boot device's adapter is initialized.
;
;--

	.SBTTL	INIT_ADP_780, Initialize 11/780 boot device adapter
	.SBTTL	INIT_ADP_7VV, Initialize 11/7VV boot device adapter

;++
;
; INIT_ADP_780, Initialize boot device adapter on the 11/780
; INIT_ADP_7VV, Initialize boot device adapter on the 11/7VV
;
; Implicit inputs:
;
;	Both the UNIBUS and MASSBUS adapters must be initialized for
;	the 11/780 and 11/7VV.  The initialization bit is in the same position
;	in both the UNIBUS and MASSBUS adapter configuration register.
;
;	This routine sets the initialization bit in the CR; then loops
;	to wait for initialization completion for the UNIBUS; assumes
;	immediate completion for the MASSBUS.
;
;--

INIT_ADP_780:				; Initialize 11/780 adapters.
INIT_ADP_7VV:
	MOVL	#MBA$M_CR_INIT,-	; Set the initialize bit. Bit
		MBA$L_CR(R0)		; # is same for MBA and UBA.
	CMPL	R0,RPB$L_CSRPHY(R11)	; Is ADP CSR address = device
					; CSR address?
	BNEQU	WAIT_UBA		; No. This is a UBA.
	RSB				; Yes. MBA. Return, no wait.

;
; For a UNIBUS adapter, must wait for a CSR bit to be written by the
; adapter before knowing that initialization is complete.
;

WAIT_UBA:				; Wait for the UBA.
	.enable lsb
	BITL	#UBA$M_CSR_UBIC,-	; Did the adapter set the init
		UBA$L_CSR(R0)		; complete bit?
	BEQL	WAIT_UBA		; No, wait longer.

;
; Now check for any UNIBUS memory that may be on the adapter. If found
; disable the corresponding map registers.
;

	PUSHL	4(R7)			; Save machine check vector
	MOVAL	B^MCHK_780,4(R7)	; Replace with a temporary
	MOVL	SP,R6			; Save stack pointer
	BICL3	#^X0003FFFF,-
		RPB$L_CSRPHY(R11),R1	; Get the start of UNIBUS space
	MOVL	R1,R2			; Copy
	MOVAB	^X3C000(R2),R3		; Last 8KB of memory
	MOVL	#^X7C000000,UBA$L_CR(R0); Disable all UNIBUS map regs
10$:	TSTW	(R2)			; See if anything responds
	MOVL	UBA$L_SR(R0),UBA$L_SR(R0) ; Clear and read status
	BNEQ	20$			; Nothing there, try higher
15$:	BSBW	LOG_MEM			; Something responds, log it
20$:	ACBL	R3,#^X2000,R2,10$	; Continue thru the entire space
	ASHL	#22,BOO$GL_UMR_DIS,-	; Div by 16 and shift left 26 bits
		UBA$L_CR(R0)		; Disable the UMR's
	POPL	4(R7)			; Restore machine check vector
	RSB				; Initialization complete.

	.ALIGN	LONG
MCHK_780:
	MTPR	#0,#PR$_SBIFS		; Clear the fault
	MOVL	4(SP),R4		; Pick up summary parameter
	MOVL	R6,SP			; Clear off frame
	CMPB	R4,#5			; Is it Read Data Substitute?
	BEQL	15$			; Yes, then it is a read w/bad parity
	BRB	20$			; No, its nonexitent
	.disable lsb

	.SBTTL	INIT_ADP_750, Initialize boot device 11/750 adapter
	.SBTTL	INIT_ADP_730, Initialize boot device 11/730 adapter

;++
;
; INIT_ADP_750, Initialize boot device adapter on the 11/750
; INIT_ADP_730, Initialize boot device adapter on the 11/730
;
; Implicit inputs:
;
;	The massbus is initialized by setting the init bit in the 
;	MBA adapter control register.  The unibus is initialized by
;	setting the UB reset IPR.  (On the 11/730 the adapter of
;	the boot device will always be a unibus.)
;
;--
	MCK_BER = ^X24			; Offset into machine check frame
					;  for Bus Error Register
	NEX	= 3			; Bit position for non-existent mem

INIT_ADP_750:				; Initialize 11/750 adapters.
INIT_ADP_730:				; Initialize the 11/730 adapters.
	.ENABLE LSB
	CMPL	R0,RPB$L_CSRPHY(R11)	; Is ADP CSR addr = device CSR addr?
	BNEQ	10$			; No, must be UNIBUS
	MOVL	#MBA$M_CR_INIT,-	; Set the initialize bit
		MBA$L_CR(R0)		;
	RSB				; Done

10$:	MTPR	#0,#PR$_UBRESET		; Reset the UNIBUS adapter.

;
; Now check for any UNIBUS memory that may be on the adapter. If found
; disable the corresponding map registers.
;

	MOVZWL	#496,R1			; Pick up number to disable
	MOVAL	UBA$L_MAP(R0),R2	; Address of first
20$:	CLRL	(R2)+			; Invalidate it
	SOBGTR	R1,20$			; Loop until done
	PUSHL	4(R7)			; Save machine check vector
	MOVAL	B^MCHK_750,4(R7)	; Replace with a temporary
	MOVL	SP,R6			; Save stack pointer
	BICL3	#^X0003FFFF,-
		RPB$L_CSRPHY(R11),R1	; Get the start of UNIBUS space
	MOVL	R1,R2			; Copy
	MOVAB	^X3C000(R2),R3		; Last 8KB of memory
30$:	TSTW	(R2)			; See if anything responds
40$:	BSBB	LOG_MEM			; Something responds, log it
50$:	ACBL	R3,#^X2000,R2,30$	; Continue thru the entire space
	POPL	4(R7)			; Restore old machine check handler
	RSB				; Done

	.ALIGN	LONG
MCHK_750:				; Temporary machine check handler
	MTPR	#^XF,#PR$_MCESR		; Reset machine check
	MOVL	#<1@NEX>,R4		; Set up
	CMPL	(SP),#^X0C		; Is this a 730 frame?
	BEQL	60$			; Yes, no further check
	MOVL	MCK_BER(SP),R4		; Save Bus error register
60$:	MOVL	R6,SP			; Clear machine check stack frame
	BBS	#NEX,R4,50$		; Branch if non-existent memory
	BRB	40$			; Other possibility is parity error
	.DISABLE LSB			;  on UNIBUS memory

LOG_MEM:CMPL	R1,R2			; First time in?
	BEQL	10$			; Yes, skip next test
	TSTL	BOO$GL_UMR_DIS		; Any registers already disabled?
	BEQL	UNI_MEM_ERR		; No, memory not start at 0
10$:	ADDL2	#16,BOO$GL_UMR_DIS	; Up the count of registers to disable
	RSB

UNI_MEM_ERR:
	ERROR	</%BOOT-F-UNIBUS memory does not start at 0/>

	.SBTTL	Strings used in File I/O

VMSFILE:				; Name of standard secondary
	.ASCIC	/[SYS0.SYSEXE]SYSBOOT.EXE/ ; bootstrap image file.

DIAGFILE:				; Name of standard diagnostic
	.ASCIC	/[SYS0.SYSMAINT]DIAGBOOT.EXE/ ; secondary bootstrap image.

NAMEPROMPT:				; Prompt string for secondary
	.ASCIZ	<CR><LF>/Bootfile:/	; boot file name.

DEVPROMPT:				; Prompt string for secondary
	.ASCIZ	<CR><LF>/Boot device name (ddcu):/
					; device mnemonic.

SWITCHPROMPT:				; Prompt string for switching
					; console media
	.ASCII	<CR><LF>/Please mount first standalone system diskette /
	.ASCIZ	/or cartridge and press return/

UCODE_FILE:
	.ASCIC	/CI780.BIN/		; Name of the binary file

UCODE_FAIL:
	.ASCIZ	<CR><LF>/%BOOT-W-Unable to locate CI ucode file/<CR><LF>
UCODE_SEVER = UCODE_FAIL+8		; Severity code

	.SBTTL	Unexpected machine check handler, DEBUG labels

	SET_PSECT			; Back to default PSECT

;
; Define handlers needed by XDELTA.
;

	.ALIGN	LONG			; All handlers longword-aligned.

	.IF	DF,DEBUG		; If debugging,

EXE$ACVIOLAT::				; Access violation vector.
EXE$BREAK::				; BPT vector.
EXE$ROPRAND::				; Reserved operand vector.
EXE$TBIT::				; Trace trap vector.
MMG$PAGEFAULT::				; Pagefault exception vector.

	.ENDC				; End of debugging conditional.

;
; Fault handler for unexpected exception conditions during bootstrap.
;

BOOT_FAULT:				; Handler for most of SCB.
	ERROR	</%BOOT-F-Unexpected Exception/>
					; Output error message.

	.ALIGN	LONG			; All handlers longword-aligned.

;
; Machine check handler.
;

UNEXP_MCHK::
	ERROR	</%BOOT-F-Unexpected Machine Check/>
					; Output error message.

;
; Labels required by XDELTA.
;

	.IF	DF,DEBUG		; If debugging, define labels.

INI$RDONLY::				; Dummy change protection
INI$WRITABLE::				; routines.
	RSB				; Just return.

EXE$GL_FLAGS::				; Dummy flags longword.
EXE$GL_SCB::				; Dummy SCB address pointer.
EXE$V_SIMULATOR	== 0			; This is not a simulator.

PFN$AB_STATE::
PFN$AB_TYPE::
PFN$AL_BAK::
PFN$AL_PTE::
PFN$Ax_BLINK::
PFN$Ax_FLINK::
PFN$AW_REFCNT::
PFN$AW_SWPVBN::

SYS$IOBASE::
SCH$GL_CURPCB::
SCH$GL_PCBVEC::

XDS$GT_WORD_PFN::
	.LONG	0

	.ENDC

	.SBTTL	Error message subroutine

;++
;
; Functional description:
;
;	This routine outputs a descriptive error message to the
;	console terminal. Then the routine restores the original
;	register settings from the time that the primary bootstrap
;	gained control, and executes a HALT instruction.
;
; Inputs:
;
;	SP	- points to address of message text
;
; Implicit inputs:
;
;	The RPB contains the contents of the original boot registers,
;	and the original stack pointer.
;
; Outputs:
;
;	Registers R0-R6, R10-R11, and AP are restored from the RPB.
;
; Implicit outputs:
;
;	When the HALT instruction executes, the console terminal reports
;	a halt and prompts the user for input.
;
;--

ERROUT::				; Report an error and HALT.
	MOVL	(SP)+,R8		; Get pointer to message text.
	CLRQ	-(SP)			; Null input buffer and size
					; arguments.
	PUSHL	R8			; Address of prompt string.
	CALLS	#3,BOO$READPROMPT	; Report the error.
	MOVL	BOO$GL_RPBBASE,R11	; Get the RPB address.
	MOVL	SP,R9			; Save old SP
	MOVL	RPB$L_BASE(R11),SP	; Set SP to base of memory.
	MOVAB	^X200(SP),SP		; Set SP to 1st page past RPB.
	MOVQ	RPB$L_BOOTR0(R11),R0	; Restore R0-R1.
	MOVQ	RPB$L_BOOTR2(R11),R2	; Restore R2-R3.
	MOVQ	RPB$L_BOOTR4(R11),R4	; Restore R4-R5.
	MOVL	RPB$L_HALTCODE(R11),AP	; Restore halt code.
	MOVQ	RPB$L_HALTPC(R11),R10	; Restore halt PC and PSL.
ERRHLT:
	HALT				; Halt the processor.

;
; If the user types CONTINUE to the console program, try to restart
; the bootstrap process.
;

	BLBS	MUST_HALT,ERRHLT	; Branch if cannot retart
	BRW	START_BOOT		; Restart the boot.

	.SBTTL	Declarations located at end of bootstrap

	.ALIGN	LONG
;
; Parameter list handed from primary boot to secondary boot
; The first location contains the argument count.  It is intended
; that the secondary boot will know what is in the list based on
; the argument count and the VMB version number.  This means that
; new information should be placed at new offsets even if older
; stuff becomes obsolete.  The VMB version number can be used to
; totally change the argument meanings if necessary.
;
SECOND_PARAM:
	FIL$GQ_CACHE	== .+VMB$Q_FILECACHE ; FILEREAD cache descriptor
	BOO$GB_SYSTEMID	== .+VMB$B_SYSTEMID  ; SCS system id
	.LONG	<VMB$C_ARGBYTCNT-4>/4	; Size of argument list
	.BLKB	VMB$C_ARGBYTCNT-4	; Reserve space for the arguments

BITMAP_VEC_PTR:
	.BLKL	1			; Address of bitmap page array
BITMAP_HI_INDX:				; Highest index to
	.BLKL	1			; bitmap page address array
BITMAP_BAS_PFN:				; Starting PFN for PFN bitmap
	.BLKL	1			; when it is bigger than the 
					; pre-allocated bitmap
INPBUF:	.LONG	0			; Dummy input buffer
BOO$GL_RPBBASE::
	.BLKL	1			; RPB base address
MUST_HALT:
	.LONG	0			; If LBS, ERROUT should not restart
					; rather it must halt.
UCODE_STAT:
	.LONG	0,0			; Statistics block for ucode file

;
; If debugging flag is set, align end of bootstrap on a longword
; boundary.
;

	.IF	DF,DEBUG
	.ALIGN	LONG
	.ENDC

	.END	START_BOOT
