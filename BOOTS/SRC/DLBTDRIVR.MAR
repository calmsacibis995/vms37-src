	.TITLE	DLBTDRIVR - RL01/2 BOOT DRIVER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	BOOTS
;
; ABSTRACT:
;	This module contains the bootstrap device driver for
;	the RL01/2  disks.
;
; ENVIRONMENT:	IPL 31, kernel mode, code must be PIC
;
; AUTHOR:  Steve Beckhardt,	CREATION DATE:  31-Oct-1979
;  (Original author:  Charlie Franks)
;
; MODIFIED BY:
;
;	02-03	GRR2003		G. R. Robert		11-JUN-1981
;		Fixed get status code to test status bits properly
;
;	02-02	CAS0001		C.A. Samuelson		30-Apr-1980
;		Change interface to BOOTDRIVR for purge of UBA datapath
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$BTDDEF				; Boot device types
	$IODEF				; I/O function codes
	$RPBDEF				; RPB offsets
	$SSDEF				; Status codes
	$UBADEF				; UBA definitions
	$UBIDEF				; 11/750 UBA definitions

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
; 
; RL11/RL02 CONTROLLER REGISTER OFFSETS
; 

	$DEFINI	RL			;START OF REGISTER DEFINITIONS

$DEF	RL_CS		.BLKW	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	RL_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<DRDY,,M>,-		; DRIVER READY
		<FCODE,3>,-		; FUNCTION CODE
		<XBA,2>,-		; BUS ADDRESS EXTENSION BITS
		<IE,,M>,-		; INTERRUPT ENABLE
		<CRDY,,M>,-		; CONTROLLER READY
		<DS,2>,-		; DRIVE SELECT
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<CRC,,M>,-		; DATA CRC OR HEADER CRC
		<DLT,,M>,-		; DATA LATE OR HEADER NOT FOUND
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<DE,,M>,-		; DRIVE ERROR
		<CE,,M>-		; COMPOSITE ERROR
	>				;END CSR BIT DEFINITIONS

$DEF	RL_BA		.BLKW	1	;BUS ADDRESS REGISTER (BAR)

$DEF	RL_DA		.BLKW	1	;DISK ADDRESS REGISTER (DAR)
	_VIELD	RL_DA,0,<-		;START OF DAR BIT DEFINITIONS
		<MRK,,M>,-		; MARK (ALWAYS 1)
		<STS,,M>,-		; GET STATUS
		<,1>,-			; RESERVED BIT
		<RST,,M>,-		; RESET
		<,12>-			; RESERVED BITS
	>				;END OF DAR BIT DEFINITIONS

$DEF	RL_MP		.BLKW	1	;MULTIPURPOSE REGISTER (MPR)
	_VIELD	RL_MP,0,<-		;START OF MPR BIT DEFINITIONS
		<STA,3>,-		; DRIVE STATE
		<BH,,M>,-		; BRUSH HOME
		<HO,,M>,-		; HEADS OUT
		<CO,,M>,-		; COVER OPEN
		<HS,,M>,-		; HEAD SELECT
		<TYP,,M>,-		; DRIVE TYPE
		<DSE,,M>,-		; DRIVE SELECT ERROR
		<VC,,M>,-		; VOLUME CHECK
		<WGE,,M>,-		; WRITE GATE ERROR
		<SPE,,M>,-		; SPIN ERROR
		<SKTO,,M>,-		; SEEK TIME OUT
		<WL,,M>,-		; WRITE LOCK
		<CHE,,M>,-		; CURRENT HEAD ERROR
		<WDE,,M>-		; WRITE DATA ERROR
	>				;END OF MPR BIT DEFINITIONS

	$DEFEND	RL			;END RL11/RL02 REGISTER DEFINITIONS


;
; OWN STORAGE:
;

;
; Boot driver table entry
;

	$BOOT_DRIVER	DEVTYPE = BTD$K_DL,-	; Device type (DL)
			SIZE = DL_DRVSIZ,-	; Driver size
			ADDR = DL_DRIVER,-	; Driver address
			DRIVRNAME = DLNAME	; Driver file name

	.SBTTL	RL01/2 Bootstrap driver code

;++
;
; Inputs:
;
;	R3	- base address of adapter's register space
;	R5	- LBN FOR CURRENT PIECE OF TRANSFER
;	R6	- contains 0
;	R7	- address of device's CSR
;	R8	- SIZE OF TRANSFER IN BYTES
;	R9	- address of the RPB
;	R10	- starting address of transfer (byte offset in first
;		  page ORed with starting map register number)
;
;	FUNC(AP)- I/O operation (IO$_READLBLK or IO$_WRITELBLK only)
;	BUF(AP) - Buffer address
;	SIZE(AP)- Size of transfer
;
; Implicit inputs:
;
;	RPB$W_UNIT	- RPB field containing boot device unit number
;
; Outputs:
;
;	R0 - status code
;
;		SS$_NORMAL	- successful transfer
;		SS$_CTRLERR	- fatal controller error
;
;	R3 - must be preserved
;
;	This routine destroys R1, R2, R4, R5, R6. Within the
;	routine, register usage is as follows:

;--

BUF = 4
SIZE = 8
FUNC = 16

DL_DRIVER:

;
; RESET DRIVE AND WAIT FOR IT TO SPIN UP.
;

	CLRL	R0			; CLEAR R0
	INSV	RPB$W_UNIT(R9),#8,#2,R0	; GET UNIT NUMBER
	MOVW	#RL_DA_M_RST!-		; PUT RESET & GET STATUS IN DAR
		RL_DA_M_STS!-
		RL_DA_M_MRK,RL_DA(R7)
10$:	BISW3	#4,R0,RL_CS(R7)		; EXECUTE DRIVE RESET
	BSBW	READY			; WAIT FOR CONTROLLER READY
	MOVZWL	RL_MP(R7),R6		; FETCH STATUS WORD
	CMPZV	#0,#5,R6,-		; TEST STATUS BITS 04:00
		#RL_MP_M_HO!-		; HEADS,BRUSHES,STATE OK?
		RL_MP_M_BH!5		; ... (5 = SEEK LINEAR MODE STATE)
	BNEQ	10$			; BRANCH IF NOT: WAIT FOR DRIVE TO SPIN UP
	BITW	#RL_CS_M_DRDY,RL_CS(R7)	; IS DRIVE READY?
	BEQL	10$			; IF NOT, BRANCH TO WAIT FOR DRIVE READY

;
; FIND CURRENT DISK ADDRESS, CALCULATE CYLINDER DIFFERENCE, AND SEEK
; DESIRED CYLINDER
;

20$:	BISW3	#8,R0,RL_CS(R7)		; EXECUTE READ HEADER
	BSBW	READY			; WAIT FOR CONTROLLER READY
	BGEQ	30$			; BRANCH IF NO ERROR READING HEADER
	BRW	100$			; OTHERWISE, BRANCH TO ERROR HANDLING
30$:	BICW3	#^O77,RL_MP(R7),R1	; GET CURRENT CYL & SURFACE

;
; NOW CONVERT LOGICAL TO PHYSICAL
;

	MULL	#2,R5			; CONVERT LOGICAL BLOCKS TO SECTORS
	CLRL	R6			; CLEAR HIGH PART OF DIVIDEND
	EDIV	#80,R5,R6,R4		; R6 = DESIRED CYL = LBN/(SECTORS/CYL)
					; R4 = REMAINING SECTORS
	CLRL	R5			; CLEAR HIGH PART OF DIVIDEND
	EDIV	#40,R4,R5,R4		; R5 = DESIRED SURFACE = R5/(SECT/SUR)
					; R4 = DESIRED SECTOR
	ASHL	#7,R6,R6		; SHIFT DESIRED CYLINDER INTO R6<15:7>
	INSV	R5,#6,#1,R6		; INSERT DESIRED SURFACE BIT INTO R6<6>
	CMPW	R6,R1			; IS A SEEK NEEDED?
	BEQL	50$			; BRANCH IF NOT.

;
; NEED TO PERFORM A SEEK.
;

	BICW	#^O177,R1		; ISOLATE CURRENT CYLINDER IN R1
35$:	BICW3	#^O177,R6,R2		; ISOLATE DESIRED CYLINDER IN R2
	SUBW	R2,R1			; SUBTRACT DESIRED FROM ACTUAL
	BEQL	40$			; BRANCH IF CURRENT = DESIRED CYLINDER
	BCC	40$			; BRANCH IF CURRENT >= DESIRED CYLINDER
	MNEGW	R1,R1			; ACTUAL<DESIRED, MAKE POSITIVE DIFF
	BISW	#4,R1			; SET SIGN FOR MOVE TO CENTER OF DISK
40$:	INSV	R5,#4,#1,R1		; INSERT SURFACE BIT IN R1<4>
	BISW3	#RL_DA_M_MRK,R1,-	; SET MARKER AND LOAD DIFFERENCE
		RL_DA(R7)		; WORD.
	BISW3	#6,R0,RL_CS(R7)		; EXECUTE SEEK FUNCTION
	BSBW	READY			; WAIT FOR CONTROLLER READY OR ERROR
	BGEQ	50$			; BRANCH IF NO ERROR DURING SEEK
	BRW	100$			; OTHERWISE, BRANCH DUE TO ERROR

; 
; SEEK, IF ANY, IS COMPLETE. EXECUTE TRANSFER FUNCTION
; 

50$:	INSV	R4,#0,#6,R6		; MERGE SECTOR WITH CYLINDER AND SURFACE
					; CYL=R6<15:7> SUR=R6<6> SEC=R6<5:0>
	MOVW	R6,RL_DA(R7)		; SET DESIRED DISK ADDRESS
	MOVW	R10,RL_BA(R7)		; SET BUFFER ADDRESS
	MOVW	R8,R2			; GET WORKING COPY OF BYTES LEFT TO XFER
					; AND ASSUME THIS IS LAST TRANSFER
	SUBW3	R4,#40,R1		; R1 = SECTORS LEFT ON SURFACE
	MULW	#256,R1			; CONVERT TO BYTES LEFT ON SURFACE
	CMPW	R2,R1			; ARE ADDITIONAL TRANSFERS REQUIRED?
	BLEQU	60$			; BRANCH IF ANSWER IS NO.
	MOVW	R1,R2			; SET BYTE COUNT FOR THIS TRANSFER
60$:	DIVW	#2,R2			; CALCULATE TRANSFER WORD COUNT
	MNEGW	R2,RL_MP(R7)		; SET NEG TRANSFER WORD COUNT
	MOVW	#^XC,R1			; ASSUME READ FUNCTION
	CMPL	FUNC(AP),#IO$_WRITELBLK	; IS IT A WRITE FUNCTION?
	BNEQ	70$			; BRANCH IF NOT
	MOVW	#^XA,R1			; SET WRITE FUNCTION CODE
70$:	BISW3	R0,R1,RL_CS(R7)		; MERGE UNIT # WITH FUNCTION AND EXECUTE
	BSBW	READY			; WAIT FOR CONTROLLER READY OR ERROR
	BLSS	100$			; BRANCH ON ERROR
80$:	MULW	#2,R2			; FIND BYTES TRANSFERRED THIS TIME
	SUBW	R2,R8			; UPDATE BYTES LEFT TO TRANSFER
	BEQL	90$			; BRANCH IF TRANSFER IS COMPLETE

; 
; UPDATE PARAMETERS FOR NEXT TRANSFER
; 

	BICW3	#^O177,RL_DA(R7),R1	; UPDATE CURRENT CYLINDER IN R1<15:7>
	BISW3	#^O77,RL_DA(R7),R6	; SET SECTOR BITS TO 1'S AND -
	INCW	R6			; UPDATE DESIRED DISK ADDRESS IN R6
	EXTZV	#6,#1,R6,R5		; UPDATE DESIRED SURFACE IN R5
	CLRL	R4			; UPDATE DESIRED SECTOR IN R4
	MOVW	RL_BA(R7),R10		; UPDATE DESIRED BUFFER ADDRESS
	BRW	35$			; LOOP FOR NEXT TRANSFER

; 
; TRANSFER COMPLETE - RETURN
; 

90$:	MOVZWL	SIZE(AP),R1		; SET TOTAL BYTES TRANSFERRED
	BNEQ	95$			; BRANCH IF ORIGINAL SIZE WAS TRANSFERRED
	MOVL	#^X8000,R1		; ELSE SIZE WAS FORCED TO 64K
95$:	MOVZWL	#SS$_NORMAL,R0		; SET COMPLETION CODE
	RSB				; AND RETURN

; 
; RETRY ERROR
; 

100$:	MOVZWL	SIZE(AP),R8		; RESTORE BYTE SIZE OF TRANSFER IN R8
	BNEQ	110$			; BRANCH IF SIZE WAS LEGAL
	MOVL	#8000,R8		; ELSE FORCE TO 64K SIZE
110$:	EXTZV	#0,#9,BUF(AP),R10	; RESTORE BYTE OFFSET IN R10
	MOVZWL	#SS$_CTRLERR,R0		; SET FATAL CONTROLLER ERROR
	RSB				; AND ATTEMPT RETRY


;
; SUBROUTINE TO WAIT FOR CONTROLLER READY OR ERROR
;
 
READY:					;
	BITW	#^X8080,(R7)		;CONTROLLER READY OR ERROR?
	BEQL	READY			;IF EQL NO
	RSB				;

DLNAME:	.ASCIC	/DLDRIVER.EXE/		; Driver file name

DL_DRVSIZ=.-DL_DRIVER

	.END
