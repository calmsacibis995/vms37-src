	.TITLE	AUTOCONFG - AUTO CONFIGURATION OF DEVICE DATA BASE
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 19-JUN-78
;
; AUTO CONFIGURATION OF DEVICE DATA BASE
;
; MODIFIED BY:
;
;	V03-002	JLV0203		Jake VanNoy		29-MAR-1982
;		Change DMF in UBADEV to COMBO to prevent ACF$INC_CHAR
;		from matching it with RK611's (DM). The code in 
;		CHECK_OTHERS is not robust enough, changes in the
;		UNIBUS table may cause other problems.
;		Change UNA driver name to XEDRIVER.
;
;	V03-001	JLV0197		Jake VanNoy		17-MAR-1982
;		Change the vector modulus from 4 (octal) to 10 (octal)
;		for the DC11 and TU58, and from 10 to 4 for the DR11B.
;		Remove two of the four CSR's for the DX11. Change the
;		name of the DUP11 driver to "NODRIVER" so that we won't
;		load any driver instead of loading the wrong driver.
;		Add two Q bus devices - DMV11 and DPV11. Correct offsets
;		for the KMS11 and add the PCL11 as XP. Add patch space
;		to end of UBATABLE. Change floating CSR algorithm bug.
;		Make ACF$INC_CHAR smarter so that it gets device names
;		correct for all subsequent UNIBUS's.
;
;	V02-024	JLV0184		Jake VanNoy		12-FEB-1982
;		Change BOO$GL_SYSID to BOO$GQ_SYSID, add KMS11 to end of
;		floating list. Add dualporting logic.
;
;	V23	JLV0168		Jake VanNoy		25-Jan-1982
;		Make RK611 action routine the ACF$ADD_UNITS routine.
;		Remove RK611 and RX211 specific routines.
;
;	V22	JLV0162		Jake VanNoy		19-Jan-1982
;		Enhance UDA autoconfigure.
;
;	V21	JLV0076		Jake VanNoy		29-Aug-1981
;		Some finalizing of COMBO autoconfigure. Deactivated the
;		TTZ,TTAA,... for terminal names because AME wasn't
;		changed yet. Added UNA, UDA and ISB11 to UNIBUS
;		autoconfigure.
;
;	V20	JLV0033		Jake VanNoy		6-Jul-1981
;		Call deliver routine with unit number in R5. Add 
;		autoconfigure of CI bus and IDC unibus device.
;
;	V19	JLV0022		Jake VanNoy		10-Jun-1981
;		Changed TU58 from CSR 774000 to 776500 (formerly the KL11),
;		and restored the DC11 to 774000 with device name OM.
;
;	V18	JLV0019		Jake VanNoy		20-May-1981
;		Fixed bugs in DMF32 controller action routine.
;
;	V17	JLV0010		Jake VanNoy		30-Mar-1981
;		Due to the fact that user written drivers can now be loaded
;		by autoconfigure, it is important to adhere to Digital 
;		standards for device names now, even unsupported devices 
;		that were previously ignored by SYSGEN except for address 
;		calculations.
;			Changed following UNIBUS device names:
;		DC11 to TU58,
;		KL11 to DL11A, 
;		DMB11 from DMBA to YMA,
;		DR11C from DR1CA to OAA (O for Obsolete),
;		DN11 from DNA to OBA,
;		DT11 from DTA to OCA,
;		DX11 from DXA to ODA,
;		GT40 from GTA to OEA,
;		KW11W from KWWA to OFA,
;		LK11 from LKA to OGA,
;		LPP11 from LPPA to OHA,
;		VMV21 from VMV21A to OIA,
;		VMV31 from VMV31A to OJA,
;		DWR70 from DWRA to OKA,
;		KW11C from KWCA to OLA, (end of obsolete names)
;		DJ11 from DJA to YJA,
;		DH11 from DHA to YHA,
;		DV11 from DVA to XVA,
;		RX11 floating space was changed to assume RX211's.
;
;		Added DZ11 to generic device action routine (ACF$ADD_UNITS)
;		in a move towards complete generalization of this routine and 
;		moving this function to the drivers. DPT$L_DELIVER features
;		were added to "pre-load" a driver and then call it to
;		"deliver" units to AUTOCONFIGURE. AUTO ALL /USER was made
;		the default action and error messages about unfound drivers
;		are suppressed if the device is unsupported. 
;		Added /LOG qualifier to AUTO ALL as well as generic
;		adapter names (UB0, etc.) can now be used in place of 
;		nexus numbers.
;
;	V16	JLV0009		Jake VanNoy		4-May-1981
;		Changed DPT$DFLTUNITS to DPT$DEFUNITS.
;
;	V15	JLV0003		Jake VanNoy		27-Feb-1981
;		Added /USER support to autoconfigure. Changed UBADEV
;		macro to include the reset controller letter and
;		documented data structures created by the macro.
;		Added UBT$x_x offsets. Added Combo (DMF32) autoconfigure.
;		Took out IOC$CTRLBRESET. Added ACF$INC_CHAR (also called
;		by CONFIGURE module). Changed terminal naming sequence
;		to TTA,TTB,...TTZ,TTAA,TTAB,...
;
;	V14	JLV0002		Jake VanNoy		9-Feb-1981
;		Changed psects to allow paged and non-paged segments
;		is SYSGEN image. Add SHOW/CONFIGURATION and CONFIGURE.
;		Requires new item in UBATABLE and changes offsets.
;
;	V13	JLV0001		Jake VanNoy		29-SEP-1980
;		Corrected AUTOCONFG to accept RK07 unit 7 and replaced
;		fixed CSR addresses for DT11.
;
;	V12	TCM0001		Trudy C Matthews	18-Sep-1980
;		Substitute EXE$TEST_CSR for all references to IOGEN$TEST_CSR.
;
;	V11	RLR0002		ROBERT RAPPAPORT	8-MARCH-1980
;		CORRECTED MINOR GLITCHES IN TM78/TU78 AUTOCONFIGURE.
;
;	V10	NPK0003		N. KRONENBERG 		14-JAN-1980
;		CORRECTED DR11B; ADDED DEVICES WITH FLOATING CSR'S
;		AND NOSUPPORT:  KMC, LPP, VMV21, VMV31, DWR70,
;		 KW11-C, RX01'S (AFTER THE FIRST.)
;		ADDED SUPPORT FOR DMP11.
;
;	V09	NPK0002		N. KRONENBERG		5-DEC-1979
;		ADDED SUBROUTINE IOC$CTRLBRESET.
;		ADDED MULTIPLE RL02, TS11 CONTROLLERS. CHANGED
;		LPA11'S AFTER THE FIRST FROM FIXED TO FLOATING.
;		ADDED DR11W'S.
;
;	V08	RLR0001		ROBERT RAPPAPORT	31-OCT-1979
; 		ADDED RP07 TO MBA CONFIGURATION CONTROL TABLE.
; 
;	V07	RLRTU78		ROBERT RAPPAPORT	27-SEP-1979
;		ADD CODE TO CONFIGURE TM78/TU78
;
; 	V06	CHF0001		CHARLIE FRANKS		07-SEP-1979
; 		ADDED RM05 AND RM80 TO MBA CONFIGURATION CONTROL TABLE.
; 
;	V05	LMK0002		LEN KAWELL		30-JUL-1979, 21-SEP-1979
;		CHANGED SECOND LINE PRINTER CSR FROM 774004 TO 764004 AND
;		ADDED THREE MORE LINE PRINTERS AT 764014, 764024, AND 764034.
;
;	V04	LMK0001		LEN KAWELL		03-JUL-1979,27-SEP-1979
;		ADD CODE TO CONFIGURE RL11/RL02, TS11/TS04, RX211/RX02.
;
;		ADD INCREMENT OF DEVICE NAME IF MORE THAN 16 CONTROLLERS OF
;		SAME DEVICE NAME ARE FOUND.  THIS IS TO ALLOW COMPATABILITY
;		MODE (FCS) ACCESS TO MORE THAN 8 DZ-11'S.
;
;	V03	NPKCOMET	N. KRONENBERG		18-APR-1979
;		CHANGED NON-EXISTENT CSR TESTS TO CALL SUBROUTINE
;		IOGEN$TEST_CSR.
;
;	02	SRB0001		STEVE BECKHARDT		21-FEB-1979	14:50
;		ADD CODE TO CONFIGURE DR32
;
;	V1.1	NPK0001		N. KRONENBERG	19-JUL-1979
;		(ECO02) FIX FLOATING VECTOR ALIGNMENT ON A NUMBER
;		OF CONTROLLERS; FIX PR611, PP611, DX11, DV11 CSR
;		SPACING.
;
;	V1.2	SPR25236	N. KRONENBERG	4-SEP-1979
;		(ECO04) CHANGE NUMBER OF VECTORS ALLOCATED FOR THE
;		DV11 FROM 4 TO 3.
;
; MACRO LIBRARY CALLS
;
 
	$ACFDEF				;DEFINE ACF OFFSETS
	$ADPDEF				;DEFINE ADP OFFSETS
	$DCDEF				;DEFINE DEVICE CLASSES AND TYPES
	$MBADEF				;DEFINE MBA REGISTER OFFSETS
	$UBADEF				;DEFINE UBA REGISTER OFFSETS
 	$DPTDEF				;DEFINE DPT REGISTER OFFSETS

	$CRBDEF
	$VECDEF	

;
; LOCAL MACROS
;
; FULSH INSTRUCTION BUFFER AND DELAY
;
	.MACRO	FREEIB
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
		NOP
	.ENDM	FREEIB

;
; GENERATE ADAPTER TYPE CONTROL TABLE ENTRY
;
;	ADAPTER TYPE
;
 
	.MACRO	ADAPTER TYPE
		.WORD	0
		.IRP	X,<UBA,MBA,DR,CI>
		.IF IDN	<X>,<TYPE>
		.=.-2
	$$$=.
		.WORD	AT$_'TYPE
		.LONG	ACF$'TYPE
	ADAPTERLEN=.-$$$
		.MEXIT
		.ENDC
		.ENDM
	.ENDM	ADAPTER
 
;
; GENERATE MBA DEVICE DESCRIPTOR
;
;	MBADEV	DEVNAME,DRVNAME,TYPES
;
 
	.MACRO	MBADEV	DEVNAME,DRVNAME,TYPES
		.PSECT	ACF$DEVNAME
	$DEVNAME$=.
		.ASCIC	\DEVNAME\
	$$$=.
		.PSECT	ACF$RESET
		.ADDRESS $$$
		.PSECT	ACF$DRVNAME
	$DRVNAME$=.
		.ASCIC	\DRVNAME\
		.PSECT	ACF$DEVDESC
	$DEVDESC$=.
		.LONG	$DEVNAME$
		.LONG	$DRVNAME$
		.IRP	X,<TYPES>
		.WORD	X
		.ENDM
		.WORD	0
		.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
		.LONG	$DEVDESC$
	.ENDM	MBADEV
 
;
; GENERATE DR DEVICE DESCRIPTOR
;
;	DRDEV	DEVNAME,DRVNAME
;

	.MACRO	DRDEV	DEVNAME,DRVNAME
		.PSECT	ACF$DEVNAME
	$DEVNAME$=.
		.ASCIC	\DEVNAME\
	$$$=.
		.PSECT	ACF$RESET
		.ADDRESS $$$
		.PSECT	ACF$DRVNAME
	$DRVNAME$=.
		.ASCIC	\DRVNAME\
		.PSECT	ACF$DEVDESC
	$DEVDESC$=.
		.LONG	$DEVNAME$
		.LONG	$DRVNAME$
		.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
		.LONG	$DEVDESC$
	.ENDM	DRDEV
.page
;
; GENERATE UBA DEVICE DESCRIPTOR
;

;+
;
; The UBADEV macro generates the following data structures:
;
; The first part is the same for fixed,fixed / fixed,floating / or
;	floating,floating
;
;	stucture:				for example:
;
;	+-------------------------------+
;	! address of devname		! 0	---> "3LPA" (ascic string)
;	+-------------------------------+
;	! address of drvname		! 4	---> "8LPDRIVER"
;	+-------------------------------+
;	! address of rtnname (device)	! 8	---> "4LP11"
;	+-------------------------------+
;	! address of action routine	! 12	---> ACF$LP11:
;	+-------------------------------+
;	  initial controller 	!letter ! 16	"A" as in lp"A" (For IOC$RESET)
;			+-------+-------+
;	  numvec	! #	! 17		#1
;		+---------------+		
;	  	!unused	! 18
;	+-------+-------+	
;	! flags ! 19				m = 001 for fixed,fixed,support
;	+-------+
;
; And now, the structure changes based on vector and CSR assignment:
;
;	Fixed CSR, Fixed vector:
;
;	+---------------+
;	! first CSR	! 20
;	+---------------+
;	! first vector	!
;	+---------------+
;	! 2nd CSR	!
;	+---------------+
;	! 2nd vector	!
;	+---------------+
;		.
;		.
;		.
;	+---------------+
;	! last CSR	!
;	+---------------+
;	! last vector	!
;	+---------------+
;	! 	0	!		zero word marks end of list
;	+---------------+
;
;
;	Fixed CSR, Floating vector:
;
;	+---------------+
;	! vector mask	! 20
;	+---------------+
;	! first CSR	!
;	+---------------+
;	! 2nd CSR	!
;	+---------------+
;		.
;		.
;		.
;	+---------------+
;	! last CSR	!
;	+---------------+
;	! 	0	!		zero word marks end of list
;	+---------------+
;	
;
;	Floating CSR, Floating vector:
;
;	+---------------+
;	! vector mask	! 20
;	+---------------+
;	! CSR mask	!
;	+---------------+
;	 (no zero word)
;	
;-

	.MACRO	UBADEV DEVNAME,CONTROLLER,DRVNAME,ROUTINE,NUMVECT,CSRTYPE,-
			VECTYPE,REGISTER,VECTOR,SUPPORT=SUPPORTED
		.PSECT	ACF$DEVNAME
	$DEVNAME$=.
		.ASCIC	\DEVNAME'CONTROLLER'\
		.PSECT	ACF$DRVNAME
	$DRVNAME$=.
		.ASCIC	\DRVNAME\
		.PSECT	ACF$RTNNAME
	$RTNNAME$=.
		.ASCIC	\ROUTINE\
		.PSECT	ACF$DEVDESC
	$DEVDESC$=.
		.LONG	$DEVNAME$
		.LONG	$DRVNAME$
		.LONG	$RTNNAME$
	UBA_M_SUPPORT=1
	UBA_V_SUPPORT=0
	$$$=UBA_M_SUPPORT
		.IF DIF	<SUPPORT>,<SUPPORTED>
	$$$=0
		.ENDC
		.LONG	ACF$'ROUTINE
		.BYTE	^A/CONTROLLER/
		.BYTE	NUMVECT
		.BYTE	0		; Unused
	UBA_M_FLOATCSR=2
	UBA_V_FLOATCSR=1
	UBA_M_FLOATVEC=4
	UBA_V_FLOATVEC=2
		.IIF IDN <VECTYPE>,<FLOAT>, $$$=$$$!UBA_M_FLOATVEC
		.IF IDN	<CSRTYPE>,<FLOAT>
		.BYTE	$$$!UBA_M_FLOATCSR
		.IF IDN	<VECTYPE>,<FLOAT>
		.WORD	VECTOR-1
		.ENDC
		.WORD	REGISTER-1
		.IFF
		.BYTE	$$$
		.IF IDN	<VECTYPE>,<FLOAT>
		.WORD	VECTOR-1
		.ENDC
		.WORD	0
		.IRP	X,<REGISTER>
		.=.-2
		.WORD	X,0
		.ENDM
		.ENDC
		.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
ACF$AL_'DEVNAME''CONTROLLER':	.LONG	$DEVDESC$ 
	.ENDM	UBADEV
.PAGE
.SBTTL	COMBODEV MACRO

	
;+
;
; The COMBODEV macro is similar to the UBADEV macro. It is used to define
; Unibus devices when more than one device appears on a single board (like
; the DMF32). 
;
;-

.MACRO	COMBODEV DEVNAME,DRVNAME,NUMVECT,VEC_OFFSET,CSR_OFFSET,-
		 MASK,SUPPORT=SUPPORTED

	.PSECT	ACF$DEVNAME
$DEVNAME$=.
	.ASCIC	\DEVNAME\

$$$=.
	.PSECT	ACF$RESET
	.ADDRESS $$$

	.PSECT	ACF$DRVNAME
$DRVNAME$=.
	.ASCIC	\DRVNAME\

	.PSECT	ACF$DEVDESC
$DEVDESC$=.
	.WORD	MASK
	.LONG	$DEVNAME$
	.LONG	$DRVNAME$
	.BYTE	NUMVECT
	.WORD	VEC_OFFSET
	.LONG	CSR_OFFSET

	$$$ = UBA_M_SUPPORT
	.IF DIF <SUPPORT>,<SUPPORTED>
	    $$$ = 0
	.ENDC
	.BYTE	$$$

	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
	.LONG	$DEVDESC$ 

	.ENDM	COMBODEV
 
;
; GLOBAL SYMBOLS
;
.SBTTL	LOCAL offsets
;
; UBATABLE definitions
;

UBT$L_DEVNAME	==	0
UBT$L_DRVNAME	==	4
UBT$L_RTNNAME	==	8
UBT$L_ROUTINE	==	12
UBT$B_LETTER	==	16
UBT$B_NUMVEC	==	17
UBT$B_UNUSED	==	18
UBT$B_FLAGS	==	19
UBT$W_REMAINDER	==	20
 
;
; LOCAL SYMBOLS
;

;
; DMF32 OFFSETS
;

DMF$V_IDENT = 12
DMF$S_IDENT =  4

;
; MBA DRIVE REGISTER OFFSET DEFINITIONS
;
 
MBA_DS=4				;DRIVE STATUS REGISTER
MBA_DT=24				;DRIVE TYPE REGISTER

;
; TM03 TAPE CONTROLLER REGISTER DEFINITIONS
;

TM03_TC=36				; TAPE CONTROL REGISTER

;
; TM78 TAPE CONTROLLER REGISTER AND COMMAND DEFINITIONS
;

TM78_AB=16				; ATTENTION BIT REGISTER
TM78_DS=28				; DEVICE STATUS REGISTER
TM78_NDTA=44				; NON-DATA TRANSFER INTERRUPT STATUS REG
TM78_NDT0=48				; NON-DATA TRANSFER COMMAND REG #0
TM78_ID=68				; INTERNAL DATA REGISTER
TM78_M_TMCLR=^X4000			; BIT MASK FOR TMCLR BIT IN ID REGISTER
TM78_M_TMRDY=^X8000			; BIT MASK FOR TMRDY BIT IN ID REGISTER
TM78_SENSE_GO=9				; SENSE COMMAND AND GO BIT


;
; RL11 CONTROLLER REGISTER DEFINITIONS
;

RL_CS=0					;CONTROL STATUS REGISTER
RL_CS_M_OPI=^X400			; OPERATION INCOMPLETE
RL_DA=4					;DISK ADDRESS REGISTER
RL_DA_M_MRK=1				; MARK
RL_DA_M_STS=2				; GET STATUS
RL_DA_M_RST=8				; RESET DRIVE

;
; UBA I/O PAGE OFFSET DEFINITION
;
 
UBA_IOBASE=8*512			;
 
;
; LOCAL DATA
;
.PAGE
.SBTTL	AUTOCONFIGURATION TABLES
;
; ADAPTER TYPE CONTROL TABLE
;
 
	.LIST	MEB
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
ACF$AB_ADPTYPE:				;
	ADAPTER MBA			;MASSBUS ADAPTER
	ADAPTER	UBA			;UNIBUS ADAPTER
	ADAPTER	DR			; DR32 ADAPTER
	ADAPTER CI			; CI ADAPTER
	ADAPTER	NULL			;
 
;
; CONTROLLER DESIGNATOR RESET POINTER TABLE
;
 
	.PSECT	ACF$RESET
ACF$AL_RESET:				;TABLE BEGINNING
 
;
; MASSBUS ADAPTER CONFIGURATION CONTROL TABLE
;
 
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad		;
ACF$AB_MBATABLE:			;
	MBADEV	DBA,DBDRIVER,<<^X10>,<^X11>,<^X12>> ;RP0X
	MBADEV	DRA,DRDRIVER,<<^X14>,<^X16>,<^X17>,<^X22>>  ;RM0X
	MBADEV	MTA,TMDRIVER,<<^XC028>>	; TM03 CONTOLLER SPECIFIC DATA
	MBADEV	MFA,TFDRIVER,<<^XC040>>	; TM78
	.LONG	0			;
 
;
; DR32 ADAPTER CONFIGURATION CONTROL TABLE
;

	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad
ACF$AB_DRTABLE:
	DRDEV	XFA,XFDRIVER

;
; CI ADAPTER CONFIGURATION CONTROL TABLE (uses DRDEV macro)
;

ACF$AB_CITABLE:
	DRDEV	PAA,PADRIVER

;
; ADDRESS OF UBA DEVICE GENERATION ROUTINE AND RETURN
;
 
ACF$L_RETURN:				;
	.BLKL	1			;
ACF$L_RETURN2:				; Alternate 
	.BLKL	1			;
ACF$L_ROUTINE:				;
	.BLKL	1			;
ACF$L_DELIVER_UNIT:			;
	.BLKL	1			; 
ACF$L_ACF_SAVE:				; Save area for ACF block
	.BLKB	ACF$C_LENGTH		;
ACF$T_DUDRIVER:				; DUDRIVER text
	.ASCIC	/DUDRIVER/		;

ACF$T_DUx:				; DUx device name
	.ASCIC	/DUA/			; 
$$$=.					; Set DUA up for resetting to A
	.PSECT	ACF$RESET		;
	.ADDRESS $$$			;
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

;
; REGISTER SAVE AREA
;
 
ACF$L_R0SAVE:				;
	.BLKL	1			;
ACF$L_R1SAVE:				;
	.BLKL	1			;
ACF$L_R2SAVE:				;
	.BLKL	1			;
ACF$L_R3SAVE:				
	.BLKL	1			;
ACF$L_R4SAVE:				;
	.BLKL	1			;
ACF$L_R5SAVE:				
	.BLKL	1			;
ACF$L_R2R3SAVE:
	.BLKL	2
 
;
; UNIBUS ADAPTER CONFIGURATION CONTROL TABLE
;
;	NOTE: ALL FLOATING ADDRESS ENTRIES MUST BE IN PRIORITY ORDER.
;

.NLIST MEB	; Cut down listing size

ACF$AB_UBATABLE::			;
	UBADEV	CR,A,CRDRIVER,CR11,1,FIXED,FIXED,<<^O17160,^O230>> ;
	UBADEV	DM,A,DMDRIVER,RK611,1,FIXED,FIXED,<<^O17440,^O210>> ;
	UBADEV	LP,A,LPDRIVER,LP11,1,FIXED,FIXED,<-
		<^O17514,^O200>,-
		<^O04004,^O170>,-
		<^O04014,^O174>,-
		<^O04024,^O270>,-
		<^O04034,^O274>>
	UBADEV	DL,A,DLDRIVER,RL11,1,FIXED,FIXED,<<^O14400,^O160>> ;
	UBADEV	MS,A,TSDRIVER,TS11,1,FIXED,FIXED,<<^O12520,^O224>> ;
;
; NOTE:  THE CSR AND VECTOR ASSIGNED TO THE RX02 COINCIDES WITH
; THE RX01.  ANY DEVICE AT THIS CSR IS ASSUMED TO BE AN RX02.
;
	UBADEV	DY,A,DYDRIVER,RX211,1,FIXED,FIXED,<<^O17170,^O264>> ;
	UBADEV	DQ,A,DQDRIVER,RB730,1,FIXED,FIXED,<<^O15606,^O250>> ;
	UBADEV	PU,A,PUDRIVER,UDA  ,1,FIXED,FIXED,<<^O12150,^O154>>
	UBADEV	OM,A,OMDRIVER,DC11,2,FIXED,FLOAT,<-
		<^O14000>,<^O14010>,<^O14020>,<^O14030>,-
		<^O14040>,<^O14050>,<^O14060>,<^O14070>,-
		<^O14100>,<^O14110>,<^O14120>,<^O14130>,-
		<^O14140>,<^O14150>,<^O14160>,<^O14170>,-
		<^O14200>,<^O14210>,<^O14220>,<^O14230>,-
		<^O14240>,<^O14250>,<^O14260>,<^O14270>,-
		<^O14300>,<^O14310>,<^O14320>,<^O14330>,-
		<^O14340>,<^O14350>,<^O14360>,<^O14370>>,8,NOSUPPORT
	UBADEV	DD,A,DDDRIVER,TU58,2,FIXED,FLOAT,<-
		<^O16500>,<^O16510>,<^O16520>,<^O16530>,-
		<^O16540>,<^O16550>,<^O16560>,<^O16570>,-
		<^O16600>,<^O16610>,<^O16620>,<^O16630>,-
		<^O16640>,<^O16650>,<^O16660>,<^O16670>>,8
	UBADEV	OB,A,OBDRIVER,DN11,1,FIXED,FLOAT,<-
		<^O15200>,<^O15210>,<^O15220>,<^O15230>,-
		<^O15240>,<^O15250>,<^O15260>,<^O15270>,-
		<^O15300>,<^O15310>,<^O15320>,<^O15330>,-
		<^O15340>,<^O15350>,<^O15360>,<^O15370>>,4,NOSUPPORT
	UBADEV	YM,A,YMDRIVER,DM11B,1,FIXED,FLOAT,<-
		<^O10500>,<^O10510>,<^O10520>,<^O10530>,-
		<^O10540>,<^O10550>,<^O10560>,<^O10570>,-
		<^O10600>,<^O10610>,<^O10620>,<^O10630>,-
		<^O10640>,<^O10650>,<^O10660>,<^O10670>>,4,NOSUPPORT
	UBADEV	OA,A,OADRIVER,DR11C,2,FIXED,FLOAT,<-
		<^O7600>,<^O7570>,<^O7560>,<^O7550>,-
		<^O7540>,<^O7530>,<^O7520>,<^O7510>,-
		<^O7500>,<^O7470>,<^O7460>,<^O7450>,-
		<^O7440>,<^O7430>,<^O7420>,<^O7410>>,8,NOSUPPORT
	UBADEV	PR,A,PRDRIVER,PR611,1,FIXED,FLOAT,<-
		<^O12600>,<^O12604>,<^O12610>,<^O12614>,-
		<^O12620>,<^O12624>,<^O12630>,<^O12634>>,8,NOSUPPORT
	UBADEV	PP,A,PPDRIVER,PP611,1,FIXED,FLOAT,<-
		<^O12700>,<^O12704>,<^O12710>,<^O12714>,-
		<^O12720>,<^O12724>,<^O12730>,<^O12734>>,8,NOSUPPORT
	UBADEV	OC,A,OCDRIVER,DT11,2,FIXED,FLOAT,<-
		<^O17420>,<^O17422>,<^O17424>,<^O17426>,-
		<^O17430>,<^O17432>,<^O17434>,<^O17436>>,8,NOSUPPORT
	UBADEV	OD,A,ODDRIVER,DX11,2,FIXED,FLOAT,<-
		<^O16200>,<^O16240>>,8,NOSUPPORT
	UBADEV	YL,A,YLDRIVER,DL11C,2,FIXED,FLOAT,<-
		<^O15610>,<^O15620>,<^O15630>,<^O15640>,-
		<^O15650>,<^O15660>,<^O15670>,<^O15700>,-
		<^O15710>,<^O15720>,<^O15730>,<^O15740>,-
		<^O15750>,<^O15760>,<^O15770>,<^O16000>,-
		<^O16010>,<^O16020>,<^O16030>,<^O16040>,-
		<^O16050>,<^O16060>,<^O16070>,<^O16100>,-
		<^O16110>,<^O16120>,<^O16130>,<^O16140>,-
		<^O16150>,<^O16160>,<^O16170>>,8,NOSUPPORT
	UBADEV	YJ,A,YJDRIVER,DJ11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	YH,A,YHDRIVER,DH11,2,FLOAT,FLOAT,16,8,NOSUPPORT
	UBADEV	OE,A,OEDRIVER,GT40,4,FIXED,FLOAT,<<^O12000>,<^O12010>>,8,NOSUPPORT
	UBADEV	LS,A,LSDRIVER,LPS11,6,FIXED,FLOAT,<<^O10400>>,8,NOSUPPORT
	UBADEV	XQ,A,XQDRIVER,DQ11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	OF,A,OFDRIVER,KW11W,2,FIXED,FLOAT,<<^O12400>>,8,NOSUPPORT
	UBADEV	XU,A,XUDRIVER,DU11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	XW,A,NODRIVER,DUP11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	XV,A,XVDRIVER,DV11,3,FIXED,FLOAT,<-
		<^O15000>,<^O15040>,<^O15100>,<^O15140>>,8,NOSUPPORT
	UBADEV	OG,A,OGDRIVER,LK11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	XM,A,XMDRIVER,DMC11,2,FLOAT,FLOAT,8,8
	UBADEV	TTA,A,DZDRIVER,DZ11,2,FLOAT,FLOAT,8,8
	UBADEV	XK,A,XKDRIVER,KMC11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	OH,A,OHDRIVER,LPP11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	OI,A,OIDRIVER,VMV21,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	OJ,A,OJDRIVER,VMV31,2,FLOAT,FLOAT,16,8,NOSUPPORT
	UBADEV	OK,A,OKDRIVER,DWR70,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	DL,B,DLDRIVER,RL11,1,FLOAT,FLOAT,8,4
	UBADEV	MS,B,TSDRIVER,TS11,1,FIXED,FLOAT,<-
		<^O12524>,<^O12530>,<^O12534>>,4
	UBADEV	LA,A,LADRIVER,LPA11,2,FIXED,FLOAT,<-
		<^O10460>>,8
	UBADEV	LA,B,LADRIVER,LPA11,2,FLOAT,FLOAT,16,8
	UBADEV	OL,A,OLDRIVER,KW11C,2,FLOAT,FLOAT,8,8,NOSUPPORT
;
; RESERVED FLOATING CSR:  SHOULD NEVER BE OCCUPIED BY A 
; PHYSICAL DEVICE SINCE IT IS RESERVED.
;
	UBADEV	RSV,A,RSVDRIVER,RSV,1,FLOAT,FLOAT,8,8,NOSUPPORT
;
; RX02'S AFTER THE FIRST:  (NOTE:  POSITION OF FIRST RX01 COINCIDES WITH
; RX02 AND IS ALWAYS ASSUMED BY AUTOCONFIG TO BE RX02.)
;
	UBADEV	DY,B,DYDRIVER,RX211,1,FLOAT,FLOAT,8,4
	UBADEV	XA,A,XADRIVER,DR11W,1,FLOAT,FLOAT,8,4
;
; THE FIRST DR11B HAS FIXED CSR AND VECTOR AND NO SUPPORT; IT
; THEREFORE HAS NO EFFECT ON AUTOCONFIGURATION.
; THE SECOND DR11B HAS FIXED CSR AND FLOATING VECTOR.
; DR11B'S AFTER THE SECOND HAVE BOTH FLOATING CSR AND VECTOR.
;
	UBADEV	XB,A,XBDRIVER,DR11B,1,FIXED,FIXED,<<^O12410,^O124>>,-
		0,NOSUPPORT ; "0" is a placeholder here
	UBADEV	XB,B,XBDRIVER,DR11B,1,FIXED,FLOAT,<<^O12430>>,4,NOSUPPORT
	UBADEV	XB,C,XBDRIVER,DR11B,1,FLOAT,FLOAT,8,4,NOSUPPORT

	UBADEV	XD,A,XDDRIVER,DMP11,2,FLOAT,FLOAT,8,8
	UBADEV	ON,A,ONDRIVER,DPV11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	IS,A,ISDRIVER,ISB11,2,FLOAT,FLOAT,8,8,NOSUPPORT
	UBADEV	OO,A,OODRIVER,DMV11,2,FLOAT,FLOAT,16,8,NOSUPPORT
	UBADEV	UN,A,XEDRIVER,UNA  ,1,FLOAT,FLOAT,8,4,NOSUPPORT
	UBADEV	PU,B,PUDRIVER,UDA  ,1,FLOAT,FLOAT,4,4
	UBADEV COMBO,A,**DRIVER,DMF32,8,FLOAT,FLOAT,32,4
	UBADEV	XS,A,XSDRIVER,KMS11,3,FLOAT,FLOAT,16,8,NOSUPPORT
	UBADEV	XP,A,XPDRIVER,PCL11,2,FIXED,FLOAT,<<^O04200>,<^O04240>,-
		<^O04300>,<^O04340>>,8,NOSUPPORT

	.LONG	0		; END OF LIST

	.BLKL	20		; PATCH SPACE

ACF$AB_DMF32_TABLE:

;	COMBODEV DEVNAME,DRVNAME,NUMVECT,VEC_OFFSET,CSR_OFFSET,
;		 MASK,SUPPORT=SUPPORTED

	COMBODEV XGA, XGDRIVER,    2,  0,  4, 4		; Sync
	COMBODEV TXA, YCDRIVER,    2, 16, 12, 8		; Async
	COMBODEV XIA, XIDRIVER,    2,  8, 24, 1		; DR
	COMBODEV LCA, LCDRIVER,    1, 24, 20, 2		; LP

	.LONG	0 			; END OF LIST

;
; CONTROLLER DESIGNATOR RESET POINTER TABLE END
;
 
	.PSECT	ACF$RESET
	.LONG	0		;
 
;
; UBA VECTOR AND CSR BASE OFFSETS
;
 
	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

ACF$AL_CSR:	.BLKL	1
ACF$AW_VECTOR:	.BLKW	1
ACF$AW_SAVEVEC:	.BLKW	1
ACF$AB_NUMVEC:	.BLKB	1

ACF$W_CSRBASE:				;
	.BLKW	1			;
ACF$W_VECBASE:				;
	.BLKW	1			;
	.NLIST	MEB
	.PAGE
	.SBTTL	AUTO CONFIGURATION OF DEVICE DATA BASE
;+
; IOC$AUTOCONFIG - AUTO CONFIGURATION OF DEVICE DATA BASE
;
; THIS ROUTINE IS CALLED TO AUTO CONFIGURE THE DEVICE DATA BASE FOR A SINGLE ADAPTER.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;-
 
	.PSECT	NONPAGED_CODE	rd,nowrt,exe,long

IOC$AUTOCONFIG::		;AUTO CONFIGURE DEVICE DATA BASE
	MOVAB	W^ACF$AB_ADPTYPE,R0	;GET ADDRESS OF ADAPTER TABLE
10$:	CMPW	(R0)+,ADP$W_ADPTYPE(R8)	;ADAPTER TYPE MATCH?
	BEQL	20$		;IF EQL YES
	ADDL	#ADAPTERLEN-2,R0	;ADVANCE TO NEXT ENTRY
	TSTW	(R0)		;ANY MORE ENTRIES IN TABLE?
	BNEQ	10$		;IF NEQ YES
	CLRL	R0		;INDICATE NO ADAPTER
	RSB			;
 
;
; ADAPTER TYPE MATCH - INITIALIZE CONFIGURATION BLOCK AND DISPATCH TO ADAPTER CODE
;
 
20$:	MOVL	R8,ACF$L_ADAPTER(R7)	;SET ADDRESS OF ADAPTER CONTROL BLOCK
	MOVL	R6,ACF$L_CONFIGREG(R7)	;SET ADDRESS OF CONFIGURATION STATUS REGISTER
	MULW3	#4,ADP$W_TR(R8),R1	;CALCULATE OFFSET IN DEVICE VECTOR AREA
	ADDW3	#^X100,R1,ACF$W_AVECTOR(R7) ;INSERT ADAPTER VECTOR OFFSET
	JMP	@(R0)+		;DISPATCH TO PROPER ROUTINE
	.PAGE
	.SBTTL	ACF$MBA - MASSBUS ADAPTER AUTO CONFIGURATION
;
; ACF$MBA - MASSBUS ADAPTER AUTO CONFIGURATION
;
; THIS ROUTINE IS CALLED TO AUTO CONFIGURE A MASSBUS ADAPTER.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A SCAN IS MADE FOR EACH OF THE POSSIBLE DRIVE TYPES THAT CAN BE ATTACHED
;	TO THE ADAPTER. AS EACH DRIVE TYPE IS ENCOUNTERED, A CO-ROUTINE CALL IS
;	MADE TO THE CALLER DELIVERING THE DEVICE UNIT DESCRIPTOR.
;
 
	.ENABL	LSB
ACF$MBA:				;AUTO CONFIGURE MASSBUS ADAPTER
	MOVB	#1,ACF$B_CNUMVEC(R7)	;SET NUMBER OF CONTROLLER VECTORS
	MOVW	ACF$W_AVECTOR(R7),ACF$W_CVECTOR(R7) ;SET CONTROLLER VECTOR OFFSET
	MOVAB	W^ACF$AB_MBATABLE,R5	;GET ADDRESS OF MBA DRIVER DESCRIPTOR TABLE
10$:	MOVL	(R5)+,R4		;GET ADDRESS OF NEXT DRIVER DESCRIPTOR
	BNEQ	20$			;IF NEQ ANOTHER ENTRY TO PROCESS
	CLRL	R0			;SET END OF SCAN INDICATOR
	RSB				;
 
;
; SCAN MBA UNITS FOR DEVICE TYPE MATCH
;
 
20$:	MOVL	(R4)+,ACF$L_DEVNAME(R7)	;SET ADDRESS OF DEVICE NAME STRING
	MOVL	(R4)+,ACF$L_DRVNAME(R7)	;SET ADDRESS OF DRIVER NAME STRING
	CLRL	R3			;CLEAR DRIVE OFFSET CONSTANT
30$:	MOVAB	(R4),R2			;GET STARTING ADDRESS OF DRIVE TYPE TABLE
	MOVL	MBA$L_ERB+MBA_DT(R6)[R3],R1 ;READ DRIVE TYPE REGISTER
	BICW	#^C<^XC1FF>,R1		;CLEAR EXTRANEOUS BITS
	MOVL	MBA$L_SR(R6),R0		;READ MBA STATUS REGISTER
	MOVL	R0,MBA$L_SR(R6)		;CLEAR MBA STATUS REGISTER
	BBS	#MBA$V_SR_NED,R0,50$	;IF SET, NONEXISTENT DRIVE
	BBC	#15,R1,40$		;IF CLR, NOT TAPE DEVICE
	BICW	#^C<^XC1F8>,R1		; FOR TAPE, RETAIN CONTROLLER
					; SPECIFIC INFORMATION ONLY.
40$:	CMPW	R1,(R2)+		;DRIVE TYPE MATCH?
	BEQL	60$			;IF EQL YES
	TSTW	(R2)			;ANY MORE ENTRIES IN TABLE?
	BNEQ	40$			;IF NEQ YES
	BRW	56$			;GO LOOK FOR MORE UNITS

50$:	MULL3	#100000,G^EXE$GL_TENUSEC,R0 ;INIT LOOP COUNT;
	CLRL	MBA$L_ERB+MBA_DS(R6)[R3]; ATTEMPT TO SEIZE THE PORT
52$:	MOVL	MBA$L_ERB+MBA_DT(R6)[R3],R1 ; READ DRIVE TYPE REGISTER
	BEQL	54$			; IF EQL, THEN NO PORT
	MOVZBL	#^X0B,MBA$L_ERB(R6)[R3]	; RELEASE THE PORT
	MOVL	MBA$L_SR(R6),R0		;READ MBA STATUS REGISTER
	MOVL	R0,MBA$L_SR(R6)		;CLEAR MBA STATUS REGISTER
	BICW	#^C<^XC1FF>,R1		; CLEAR EXTRANEOUS BITS
	BRB	40$			; GO LOOK FOR DRIVER TYPE MATCH
54$:	FREEIB
	MOVL	MBA$L_SR(R6),R1		;READ MBA STATUS REGISTER
	MOVL	R1,MBA$L_SR(R6)		;CLEAR MBA STATUS REGISTER
	SOBGTR	R0,52$			;IF GTR, TRY TO READ DT REGISTER AGAIN

56$:	ACBW	#^X80/4*7,#^X80/4,R3,30$ ;ANY MORE UNITS TO EXAMINE?
	BRW	10$			;YES 

;
; MBA DRIVE TYPE/DEVICE TYPE MATCH - DELIVER ALL UNITS TO CALLER
;
 
60$:	BBS	#15,R1,ACF$MBATAPE	;IF SET, TAPE DEVICE
 
;
; DEVICE IS A DISK
;
 
ACF$MBADISK:				;
	MOVL	R6,ACF$L_CONTRLREG(R7)	;SET ADDRESS OF CONTROL STATUS REGISTER
	MOVL	ACF$L_DEVNAME(R7),R1	;GET ADDRESS OF DEVICE NAME STRING
	MOVZBL	(R1),R2			;GET LENGTH OF STRING IN BYTES
	ADDB3	ADP$B_NUMBER(R8),#^A/A/,(R1)[R2] ;CALCULATE LAST BYTE OF DEVICE NAME
 
;
; CONSTRUCT UNIT DATA BASE AND DELIVER TO CALLER
;
 
70$:	DIVL3	#^X80/4,R3,R0		;CALCULATE ADAPTER DRIVE NUMBER
	MOVB	R0,ACF$B_AUNIT(R7)	;SET ADAPTER UNIT NUMBER
	MOVB	R0,ACF$B_CUNIT(R7)	;SET CONTROLLER UNIT NUMBER
	MOVQ	R3,W^ACF$L_R3SAVE	;SAVE REGISTERS
	MOVL	R5,W^ACF$L_R5SAVE	;
	MOVL	#1,R0			;SET SUCCESS INDICATOR
	JSB	@(SP)+			;DELIVER UNIT TO CALLER
	MOVQ	W^ACF$L_R3SAVE,R3	;RESTORE REGISTERS
	MOVL	W^ACF$L_R5SAVE,R5	;
	BRB	56$			;BRANCH TO TEST FOR MORE DRIVES
 
;
; DEVICE IS A TAPE
;
 
ACF$MBATAPE:				;
	CMPW	#^XC040,R1		; TEST CONTROLLER TYPE
	BEQL	130$			; BRANCH IF TM78
	DIVL3	#^X80/4,R3,R0		;CALCULATE ADAPTER UNIT NUMBER
	MOVB	R0,ACF$B_AUNIT(R7)	;SET ADAPTER UNIT NUMBER
	MOVQ	R3,W^ACF$L_R3SAVE	;SAVE REGISTERS
	MOVL	R5,W^ACF$L_R5SAVE	;
	MOVAL	MBA$L_ERB(R6)[R3],R2	;GET ADDRESS OF DRIVE CONTROL REGISTER
	MOVL	R2,ACF$L_CONTRLREG(R7)	;SET ADDRESS OF DRIVE CONTROL REGISTER
	CLRL	R1			;CLEAR STARTING SLAVE DRIVE NUMBER
 
;
; CONSTRUCT UNIT DATA BASE AND DELIVER TO CALLER
;
 
110$:	MOVL	R1,TM03_TC(R2)		; SELECT SLAVE DRIVE
	BICL3	#^C<^XFE00>,MBA_DT(R2),R0 ;CLEAR EXTRANEOUS BITS
	CMPW	#^XC400,R0		;SLAVE TAPE DRIVE AND PRESENT?
	BNEQ	120$			;IF NEQ NO
	MOVQ	R1,W^ACF$L_R1SAVE	;SAVE REGISTERS
	MOVB	R1,ACF$B_CUNIT(R7)	;SET CONTROLLER UNIT NUMBER
	MOVL	#1,R0			;SET SUCCESS INDICATOR
	JSB	@(SP)+			;DELIVER UNIT TO CALLER
	MOVQ	W^ACF$L_R1SAVE,R1	;RESTORE REGISTERS
120$:	AOBLEQ	#7,R1,110$		;ANY MORE SLAVES TO PROCESS?
	MOVL	ACF$L_DEVNAME(R7),R2	;GET ADDRESS OF DEVICE NAME STRING
	MOVZBL	(R2),R1			;GET LENGHT OF STRING IN BYTES
	INCB	(R2)[R1]		;INCREMENT CONTROLLER DESIGNATION
	MOVQ	W^ACF$L_R3SAVE,R3	;RESTORE REGISTERS
	MOVL	W^ACF$L_R5SAVE,R5	;
	BRW	56$			;

;
; TM78 SPECIFIC CODE
;

130$:	DIVL3	#^X80/4,R3,R0		;CALCULATE ADAPTER UNIT NUMBER
	MOVB	R0,ACF$B_AUNIT(R7)	;SET ADAPTER UNIT NUMBER
	MOVQ	R3,W^ACF$L_R3SAVE	;SAVE REGISTERS
	MOVL	R5,W^ACF$L_R5SAVE	;
	MOVAL	MBA$L_ERB(R6)[R3],R2	;GET ADDRESS OF DRIVE CONTROL REGISTER
	MOVL	R2,ACF$L_CONTRLREG(R7)	;SET ADDRESS OF DRIVE CONTROL REGISTER

;
; Initialize TM78 controller.
;

	BISL	#TM78_M_TMCLR,TM78_ID(R2); Reset TM78 controller to initial state.
	MOVZBL	#250,R1			 ; Set a counter.
140$:	SOBGTR	R1,140$			 ; Waste a little time while TMCLR starts.
	MOVL	#2000000,R1		 ; Set counter to wait for TMCLR to end.
150$:	MOVL	TM78_ID(R2),R0		 ; Read TM78 register.
	BITL	#TM78_M_TMRDY,R0	 ; See if TMCLR done yet.
	BNEQ	160$			 ; NEQ implies that TMCLR is done.
	SOBGTR	R1,150$			 ; Else loop back and test again.
	BRW	220$			 ; If we fall thru, TM78 did not come READY.
160$:
	CLRL	R1			;CLEAR STARTING SLAVE DRIVE NUMBER
 
;
; CONSTRUCT UNIT DATA BASE AND DELIVER TO CALLER
;
 
170$:	MOVZBL	ACF$B_AUNIT(R7),R0	; Pickup which MASSBUS device we are.
	ASHL	R0,#1,R0		; Shift to appropriate attention bit.
	CLRL	TM78_DS(R2)			; Clear any old device info.
	MOVL	R0,TM78_AB(R2)			; Clear attention bit.
	PUSHL	R1				; Save drive number.
	MOVZBL	#250,R1			 	; Set a counter.
180$:	SOBGTR	R1,180$			 	; Waste time while ATTN bit clears
	MOVL	(SP),R1				; Restore drive number.
	MOVL	#TM78_SENSE_GO,TM78_NDT0(R2)[R1]; Set sense command.
	MOVL	#2000000,R1			; Set count to prevent hang.
190$:
	PUSHL	MBA$L_SR(R6)		; Copy MBA status register to stack.
	BITL	#MBA$M_SR_ATTN,(SP)+	; Test for MBA attention bit on
					;  in MBA status register.
	BNEQ	200$			; NEQ implies MBA attention came on.
	SOBGTR	R1,190$			; Loop waiting for MBA attention bit.
200$:					; If here, either MBA attention bit came
					;  on or the loop gave out.
	POPL	R1			; Restore drive number.
	BITL	R0,TM78_AB(R2)		; Assure TM78 attention bit set.
	BEQL	210$			; EQL implies NO attention which
					;  means the device doesn't respond so
					;  let's ignore it.
	PUSHL	TM78_DS(R2)		; Copy device status register to stack.
	PUSHL	TM78_NDTA(R2)		; Copy interrupt status data to stack.
	MOVL	R0,TM78_AB(R2)		; Clear attention bit.
	POPL	R0			; R0 = interrupt status.
	MOVW	R0,2(SP)		; Copy to high word of TOP OF STACK.
	POPL	R0			; R0 = drive status in low word,
					;  interrupt status in high word.

	CMPZV	#16,#6,R0,#1		; See if we got back DONE status.
	BNEQ	210$			; If not, then device is NO GOOD.

	BBC	#14,R0,210$		; Branch if drive not present.
	MOVQ	R1,W^ACF$L_R1SAVE	;SAVE REGISTERS
	MOVB	R1,ACF$B_CUNIT(R7)	;SET CONTROLLER UNIT NUMBER
	MOVL	#1,R0			;SET SUCCESS INDICATOR
	JSB	@(SP)+			;DELIVER UNIT TO CALLER
	MOVQ	W^ACF$L_R1SAVE,R1	;RESTORE REGISTERS
210$:	AOBLEQ	#3,R1,170$		;ANY MORE SLAVES TO PROCESS?
220$:
	MOVL	ACF$L_DEVNAME(R7),R2	;GET ADDRESS OF DEVICE NAME STRING
	MOVZBL	(R2),R1			;GET LENGTH OF STRING IN BYTES
	INCB	(R2)[R1]		;INCREMENT CONTROLLER DESIGNATION
	MOVQ	W^ACF$L_R3SAVE,R3	;RESTORE REGISTERS
	MOVL	W^ACF$L_R5SAVE,R5	;
	BRW	56$			;
	.DSABL	LSB
	.PAGE
	.SBTTL	ACF$DR - DR32 ADAPTER AUTO CONFIGURATION
;
; ACF$DR - DR32 ADAPTER AUTO CONFIGURATION
;
; THIS ROUTINE IS CALLED TO AUTO CONFIGURE A DR32 ADAPTER.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A CO-ROUTINE CALL IS MADE TO THE CALLER DELIVERING THE DEVICE
;	UNIT DESCRIPTOR.
;

ACF$DR:					;AUTO CONFIGURE DR32 ADAPTER
	MOVB	#1,ACF$B_CNUMVEC(R7)	;SET NUMBER OF CONTROLLER VECTORS
	MOVW	ACF$W_AVECTOR(R7),ACF$W_CVECTOR(R7) ;SET CNTRLR VECTOR OFFSET
	MOVL	R6,ACF$L_CONTRLREG(R7)	;SET ADDRESS OF CONTROL STATUS REGISTER
	MOVL	W^ACF$AB_DRTABLE,R4	;GET ADDRESS OF DRIVER DESCRIPTOR
	MOVL	(R4)+,R1		;GET ADDRESS OF DEVICE NAME STRING
	MOVL	R1,ACF$L_DEVNAME(R7)	;SET ADDRESS OF DEVICE NAME STRING
	MOVL	(R4),ACF$L_DRVNAME(R7)	;SET ADDRESS OF DRIVER NAME STRING
	MOVZBL	(R1),R2			;GET LENGTH OF DEV. NAME STRING IN BYTES
	ADDB3	ADP$B_NUMBER(R8),#^A/A/,(R1)[R2] ;CALCULATE AND STORE LAST
					;BYTE OF DEVICE NAME
	CLRB	ACF$B_AUNIT(R7)		;SET ADAPTER UNIT NUMBER = 0
	CLRB	ACF$B_CUNIT(R7)		;SET CONTROLLER UNIT NUMBER = 0
	MOVL	#1,R0			;SET SUCCESS INDICATOR
	JSB	@(SP)+			;DELIVER UNIT TO CALLER
	CLRL	R0			;SET END OF SCAN INDICATOR
	RSB
	.PAGE
	.SBTTL	ACF$CI - CI ADAPTER AUTO CONFIGURATION
;
; ACF$CI - CI ADAPTER AUTO CONFIGURATION
;
; THIS ROUTINE IS CALLED TO AUTO CONFIGURE A CI ADAPTER.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A CO-ROUTINE CALL IS MADE TO THE CALLER DELIVERING THE DEVICE
;	UNIT DESCRIPTOR.
;

ACF$CI:					;AUTO CONFIGURE CI ADAPTER
	MOVB	#1,ACF$B_CNUMVEC(R7)	;SET NUMBER OF CONTROLLER VECTORS
	MOVW	ACF$W_AVECTOR(R7),ACF$W_CVECTOR(R7) ;SET CNTRLR VECTOR OFFSET
	MOVL	R6,ACF$L_CONTRLREG(R7)	;SET ADDRESS OF CONTROL STATUS REGISTER
	MOVL	W^ACF$AB_CITABLE,R4	;GET ADDRESS OF DRIVER DESCRIPTOR
	MOVL	(R4)+,R1		;GET ADDRESS OF DEVICE NAME STRING
	MOVL	R1,ACF$L_DEVNAME(R7)	;SET ADDRESS OF DEVICE NAME STRING
	MOVL	(R4),ACF$L_DRVNAME(R7)	;SET ADDRESS OF DRIVER NAME STRING
	MOVZBL	(R1),R2			;GET LENGTH OF DEV. NAME STRING IN BYTES
	ADDB3	ADP$B_NUMBER(R8),#^A/A/,(R1)[R2] ;CALCULATE AND STORE LAST
					;BYTE OF DEVICE NAME
	CLRB	ACF$B_AUNIT(R7)		;SET ADAPTER UNIT NUMBER = 0
	CLRB	ACF$B_CUNIT(R7)		;SET CONTROLLER UNIT NUMBER = 0
	MOVL	#1,R0			;SET SUCCESS INDICATOR
	JSB	@(SP)+			;DELIVER UNIT TO CALLER
	CLRL	R0			;SET END OF SCAN INDICATOR
	RSB

	.PAGE
	.SBTTL	ACF$UBA - UNIBUS ADAPTER AUTO CONFIGURATION
;
; ACF$UBA - UNIBUS ADAPTER AUTO CONFIGURATION
;
; THIS ROUTINE IS CALLED TO AUTO CONFIGURE A UNIBUS ADAPTER.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION CONTROL REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A SCAN IS MADE FOR EACH OF THE POSSIBLE DEVICES THAT CAN BE ATTACHED TO
;	THE ADAPTER. AS EACH DEVICE IS ENCOUNTERED, A CO-ROUTINE CALL IS MADE TO 
;	THE CALLER DELIVERING THE DEVICE UNIT DESCRIPTOR.
;
 
	.ENABL	LSB
ACF$UBA:				;AUTO CONFIGURE UNIBUS ADAPTER
	CLRB	ACF$B_AUNIT(R7)		;CLEAR ADAPTER UNIT NUMBER
	MOVW	#^O10,W^ACF$W_CSRBASE	;SET INITIAL CSR BASE OFFSET
	MOVW	#^O300,W^ACF$W_VECBASE	;SET INITIAL VECTOR BASE OFFSET
	MOVAB	W^ACF$AB_UBATABLE,R5	;GET ADDRESS OF UBA DRIVER DESCRIPTOR TABLE
10$:	MOVL	(R5)+,R4		;GET ADDRESS OF NEXT DRIVER DESCRIPTOR
	BNEQ	20$			;IF NEQ ANOTHER ENTRY TO PROCESS
	CLRL	R0			;SET END OF SCAN INDICATOR
	RSB				;
 
;
; SCAN UBA DEVICE
;
 
20$:	CLRL	IOGEN$GL_DPT		; Clear formerly loaded driver
	MOVL	UBT$L_DEVNAME(R4),ACF$L_DEVNAME(R7) ;SET ADDRESS OF DEVICE NAME STRING
	MOVL	UBT$L_DRVNAME(R4),ACF$L_DRVNAME(R7) ;SET ADDRESS OF DRIVER NAME STRING
	MOVL	UBT$L_ROUTINE(R4),W^ACF$L_ROUTINE ;SET ADDRESS OF DEVICE GENERATION ROUTINE
	MOVB	UBT$B_NUMVEC(R4),ACF$B_CNUMVEC(R7) ;SET NUMBER OF CONTROLLER INTERRUPT VECTORS
	MOVAB	UBT$B_FLAGS(R4),R3		;COPY ADDRESS OF FLAG BYTE

; The supported characteristic remains only to suppress the error
; message in IOGEN$LOADER that driver wasn't found.

	BISB2	#ACF$M_SUPPORT,ACF$B_AFLAG(R7) 	; ASSUME NOSUPPORT
	BBC	#UBA_V_SUPPORT,(R3),23$		; BRANCH IF NOSUPPORT
	BICB2	#ACF$M_SUPPORT,ACF$B_AFLAG(R7) 	; SET SUPPORTED

23$:	MOVAB	UBT$W_REMAINDER(R4),R4	;ADDRESS OF VARIABLE BLOCK
	BBC	#UBA_V_FLOATVEC,(R3),25$ ;IF CLR, NO FLOATING VECTOR ASSIGNMENT
	MOVZWL	(R4),R1			;GET VECTOR MODULO MASK
	ADDW	W^ACF$W_VECBASE,R1	;ROUND UP TO NEXT VECTOR
	BICW	(R4)+,R1		;TRUNCATE TO ACTUAL VECTOR OFFSET
	MOVW	R1,W^ACF$AW_SAVEVEC	;SAVE FOR CHECK LATER
25$:	BBC	#UBA_V_FLOATCSR,(R3),ACF$UBAFIXED ;IF CLR, FIXED CSR
	BRW	ACF$UBAFLOATING		;
 
;
; FIXED CSR DEVICE
;
 
ACF$UBAFIXED:				;
30$:	MOVZWL	(R4)+,R2		;GET CSR OFFSET
	BEQL	37$			;IF EQL NO MORE TO PROCESS
	MOVAB	UBA_IOBASE(R6)[R2],R2	;GET ADDRESS OF CSR
	MOVL	R2,ACF$L_CONTRLREG(R7)	;SET ADDRESS OF CONTROL REGISTER
	BBS	#UBA_V_FLOATVEC,(R3),31$ ;IF SET, FLOATING VECTOR ASSIGNMENT
	MOVZWL	(R4)+,R1		;GET ACTUAL VECTOR ADDRESS
31$:	MOVW	R1,ACF$W_CVECTOR(R7)	;SET ADDRESS OF INTERRUPT VECTOR
	MOVL	R2,R0			;GET COPY OF CSR
	JSB	G^EXE$TEST_CSR		;CHECK DEVICE CSR
	BLBC	R0,30$			;BRANCH IF CSR NON-EXISTENT
	MOVQ	R1,W^ACF$L_R1SAVE	;SAVE REGISTERS
	MOVQ	R3,W^ACF$L_R3SAVE	;
	MOVL	R5,W^ACF$L_R5SAVE	;
	JSB	LOAD_DRIVER		;LOAD DRIVER
	JSB	@W^ACF$L_ROUTINE	;CALL GENERATION ROUTINE
	MOVL	ACF$L_DEVNAME(R7),R1	;GET ADDRESS OF DEVICE NAME STRING
	BSBW	ACF$INC_CHAR		;INCREMENT CONTROLLER	
	MOVQ	W^ACF$L_R1SAVE,R1	;RESTORE REGISTERS
	MOVQ	W^ACF$L_R3SAVE,R3	;
	MOVL	W^ACF$L_R5SAVE,R5	;
35$:	BBC	#UBA_V_FLOATVEC,(R3),30$ ;IF CLR, FIXED VECTOR ASSIGNMENT
	MOVZBL	ACF$B_CNUMVEC(R7),R0	;GET NUMBER OF CONTROLLER INTERRUPT VECTORS
	MOVAL	(R1)[R0],R1		;CALCULATE ADDRESS OF NEXT VECTOR
	BRB	30$			;
37$:	BBC	#UBA_V_FLOATVEC,(R3)+,39$ ;IF CLR, NO FLOATING VECTOR ASSIGNMENT
	CMPW	W^ACF$AW_SAVEVEC,R1	;ANY VECTORS ASSIGNED?
	BEQL	39$			;IF EQL NO
	MOVW	R1,W^ACF$W_VECBASE	;SET NEW VECTOR BASE ADDRESS
39$:	BRW	10$			;
 
;
; FLOATING VECTOR/CSR DEVICE
;
 
ACF$UBAFLOATING:			;
	MOVZWL	W^ACF$W_CSRBASE,R2	;GET BASE CSR OFFSET
	ADDW	(R4),R2			;ROUND TO NEXT CSR
	BICW	(R4),R2			;TRUNCATE BACK TO CSR OFFSET
	MOVAB	UBA_IOBASE(R6)[R2],R0	;GET ACTUAL CSR ADDRESS
	JSB	G^EXE$TEST_CSR		;CHECK FOR NON-EXISTENT CSR
	BLBS	R0,38$			; branch if csr there
	BRW	60$			;BRANCH IF CSR NON-EXISTENT
38$:	MOVW	R2,W^ACF$W_CSRBASE	;SET NEW BASE CSR OFFSET
40$:	MOVAB	UBA_IOBASE(R6)[R2],R0	;GET ACTUAL CSR ADDRESS
	JSB	G^EXE$TEST_CSR		;CHECK FOR NON-EXISTENT CSR
	BLBC	R0,60$			;BRANCH IF CSR NON-EXISTENT
	MOVAB	UBA_IOBASE(R6)[R2],-	;SET ADDRESS OF 
		ACF$L_CONTRLREG(R7)	; CONTROL REGISTER
	MOVW	R1,ACF$W_CVECTOR(R7)	;SET ADDRESS OF INTERRUPT VECTOR
	MOVQ	R1,W^ACF$L_R1SAVE	;SAVE REGISTERS
	MOVQ	R3,W^ACF$L_R3SAVE	;
	MOVL	R5,W^ACF$L_R5SAVE	;
	JSB	LOAD_DRIVER		;LOAD DRIVER
	JSB	@W^ACF$L_ROUTINE	;CALL DEVICE GENERATION ROUTINE
	MOVL	ACF$L_DEVNAME(R7),R1	;GET ADDRESS OF DEVICE NAME STRING
	BSBW	ACF$INC_CHAR		;INCREMENT CONTROLLER	

	MOVQ	W^ACF$L_R1SAVE,R1	;RESTORE REGISTERS
	MOVQ	W^ACF$L_R3SAVE,R3	;
	MOVL	W^ACF$L_R5SAVE,R5	;
50$:	BBC	#UBA_V_FLOATVEC,(R3),40$ ;IF CLR, FIXED VECTOR ASSIGNMENT
	MOVZBL	ACF$B_CNUMVEC(R7),R0	;GET NUMBER OF CONTROLLER INTERRUPT VECTORS
	MOVAL	(R1)[R0],R1		;CALCULATE ADDRESS OF NEXT VECTOR
	ADDW	(R4),R2			;CALCULATE ADDRESS OF NEXT CSR
	INCL	R2			;
	BRB	40$			;
60$:	MOVW	R1,W^ACF$W_VECBASE	;SAVE NEW VECTOR OFFSET
	MOVW	R2,W^ACF$W_CSRBASE	;SAVE NEW CSR OFFSET
	ADDW	#2,W^ACF$W_CSRBASE	;ADVANCE PAST ONE REGISTER BLOCK
	BRW	10$			;
	.DSABL	LSB
	.PAGE
	.SBTTL  LOAD_DRIVER - Co-routine callback to load driver

;+
;
; Driver is preloaded before action routine is called if action routine
; is ACF$ADD_UNITS.
;
;
;	R7 - Address of ACF block
;
;-

LOAD_DRIVER:

	CMPL	#ACF$ADD_UNITS,W^ACF$L_ROUTINE	; Is this a generic routine device?
	BEQL	10$				; No - Exit
	RSB					; Return 

10$:	BBSS	#ACF$V_NOLOAD_DB,ACF$B_AFLAG(R7),20$ ; Don't load data base
20$:	MOVL	#1,R0				; Set success
	POPL	W^ACF$L_RETURN			; Save return back to AUTOCONFIGURE
	JSB	@(SP)+				; Co-routine back to sysgen
						; to load driver only
	BBCC	#ACF$V_NOLOAD_DB,ACF$B_AFLAG(R7),30$ ; Clear NOLOAD bit
30$:	JMP	@W^ACF$L_RETURN			; Return to caller

	.PAGE
	.SBTTL	ACF$ADD_UNITS - GENERIC ROUTINE FOR DEVICE GENERATION
;
; ACF$CR11 - CR11 CARD READER
; ACF$LP11 - LP11 LINE PRINTER
; ACF$LPA11 - LPA11 LABORATORY I/O SUBSYSTEM, CONTROLLER A
; ACF$LPA11B - LPA11 LABORATORY I/O SUBSYSTEM, CONTROLLER B
; ACF$DMC11 - DMC11 SYNCHRONOUS COMMUNICATIONS
; ACF$TS11 - TS11 MAGTAPE, CONTROLLER A
; ACF$TS11B - TS11 MAGTAPE, CONTROLLER B
;
; THIS ROUTINE IS CALLED AS AN ACTION ROUTINE FROM THE UBA DEVICE SCAN TO GENERATE
; A SINGLE UNIT DATA BASE.
;
; IT IS ALSO CALLED AS AN ACTION ROUTINE FOR UNSUPPORTED DEVICES.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A CO-ROUTINE CALL IS MADE TO THE ORIGINAL CALLER DELIVERING THE DEVICE UNIT
;	DESCRIPTOR.
;

; Unsupported:

ACF$DH11:
ACF$DJ11:
ACF$DC11:
ACF$DM11B:
ACF$DN11:
ACF$DQ11:
ACF$DR11B:
ACF$DR11C:
ACF$DT11:
ACF$DU11:
ACF$DUP11:
ACF$DV11:
ACF$DWR70:
ACF$DX11:
ACF$GT40:
ACF$DL11C:
ACF$KMC11:
ACF$KW11C:
ACF$KW11W:
ACF$LK11:
ACF$LPP11:
ACF$LPS11:
ACF$PP611:
ACF$PR611:
ACF$RSV:
ACF$RX11:
ACF$VMV21:
ACF$VMV31:
ACF$DMV11:
ACF$DPV11:
ACF$ISB11:
ACF$UNA:
ACF$KMS11:
ACF$PCL11:

; Supported:
 
ACF$CR11:				;
ACF$LP11:				;
ACF$TU58:				;
ACF$RB730:				;
ACF$LPA11:				;
ACF$DMC11:				;
ACF$TS11:				;
ACF$DR11W:				;
ACF$DMP11:				;
ACF$DZ11:				;
ACF$RK611:				;
ACF$RX211:				;

ACF$ADD_UNITS:

	POPL	W^ACF$L_RETURN		; Save return address
	CLRL	W^ACF$L_DELIVER_UNIT	; Deliver unit routine in driver
	MOVL	W^IOGEN$GL_DPT,R1	; DPT of driver just loaded
	BEQL	5$			; Branch if none

	MOVW	DPT$W_DELIVER(R1),W^ACF$L_DELIVER_UNIT
	BEQL	5$			; No driver-specified routine
	ADDL2	R1,W^ACF$L_DELIVER_UNIT ; Set address of driver action routine

5$:	CLRL	R5			; Set starting unit number

10$:	MOVB	R5,ACF$B_CUNIT(R7)	; Next unit number
	MOVL	W^ACF$L_DELIVER_UNIT,R1	; Is there a driver routine?
	BEQL	20$			; Branch if not
;
; GET IDB IF IT EXISTS
;
	PUSHL	R1
	MOVZBL	ACF$B_CUNIT(R7),-(SP)	; Push unit number
	PUSHL	ACF$L_DEVNAME(R7)	; Push device name address
	BSBW	SGN$GET_DEVICE		; Get device addresses if they exist
	ADDL2	#8,SP			; Pop input off stack
	MOVL	SGN$GL_IDB,R3		; SET ADDRESS
	POPL	R1

	MOVL	#1,R0			; Set success for driver
	MOVL	ACF$L_CONTRLREG(R7),R4	; Set CSR address for driver
	JSB	(R1)			; Call driver to deliver unit #n
	MOVB	R5,ACF$B_CUNIT(R7)	; Save Unit # returned by driver
	BLBC	R0,30$			; Branch if driver returns no

20$:	MOVL	#1,R0			; Set success indicator
	JSB	@(SP)+			; Deliver unit to caller

30$:	MOVL	W^IOGEN$GL_DPT,R1	; Address of DPT
	BEQL	40$			; Driver not found
	MOVZWL	DPT$W_DEFUNITS(R1),R1	; Number of driver specified units
					; Unit number (R5) can change in DELIVER
	MOVZBL	ACF$B_CUNIT(R7),R5	; Set unit number
	AOBLSS	R1,R5,10$ 		; Any more units to process?

40$:	JMP	@W^ACF$L_RETURN		; Return to caller

	.PAGE
	.SBTTL	UDA MULTIPLE UNIT DEVICE GENERATOR
;
; ACF$UDA - UDA DISK CONTROLLER
;
; THIS ROUTINE IS CALLED AS AN ACTION ROUTINE FROM THE UBA DEVICE SCAN TO GENERATE
; THE DATA BASE FOR A SINGLE UDA.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A CO-ROUTINE CALL IS MADE TO THE ORIGINAL CALLER DELIVERING EACH DEVICE
;	UNIT DESCRIPTOR.
;

ACF$UDA:

	POPL	W^ACF$L_RETURN2			;SAVE RETURN ADDRESS
;
; First load PUDRIVER and create units normally.
;
	BSBB	ACF$ADD_UNITS
	
;
; Now, load PUDRIVER and its associated database.
;

	MOVC3	#ACF$C_LENGTH,-
		(R7),ACF$L_ACF_SAVE	; Save ACF block
;
; Create SYSID
;	
	MOVL	ACF$L_CONTRLREG(R7),R0	; Create SYSID, first longword
	MOVZWL	ADP$W_TR(R8),R1		; second longword
	BISL	#^X8000,R1		; Set high bit in first word
	MOVAQ	BOO$GQ_CONSYSID,R2	; get address of SYSID quadword
	MOVQ	R0,(R2)			; Set SYSID
	MOVL	R2,ACF$L_CONTRLREG(R7)	; Set in CSR field

	MOVAL	ACF$T_DUx,-
		ACF$L_DEVNAME(R7)	; Set device name
	MOVAL	ACF$T_DUDRIVER,-
		ACF$L_DRVNAME(R7)	; Set driver name

	MOVB	#ACF$M_SUPPORT,-
		ACF$B_AFLAG(R7)		; Clear configuration flag, set supported
	CLRB	ACF$B_NUMUNIT(R7)	; Clear number of units
	CLRB	ACF$B_CUNIT(R7)		; Clear unit number
	CLRW	ACF$W_MAXUNITS(R7)	; Clear maxunits	
	MOVB	#1,ACF$B_CNUMVEC(R7)	; Set cnumvec to 1

;
; Deliver DUx
;
	CLRL	SGN$GL_CRB		; Clear CRB pointer
	MOVL	#1,R0			; Set success
	JSB	@(SP)+			;

	MOVL	SGN$GL_CRB,R1		; *** temp ?
	BEQL	10$
	MOVL	ACF$L_ADAPTER(R7),-	; Fill in ADP address in CRB
		CRB$L_INTD+VEC$L_ADP(R1)

;
; Increment device name
;
10$:
	MOVL	ACF$L_DEVNAME(R7),R1	; Set address 
	BSBW	ACF$INC_CHAR		; Do the increment

	MOVC3	#ACF$C_LENGTH,-
		ACF$L_ACF_SAVE,(R7)	; Restore ACF block
	JMP	@W^ACF$L_RETURN2	; Return

	.PAGE
	.SBTTL	RL11 MULTIPLE UNIT GENERATOR
;
; ACF$RL11 - RL11 DISK CONTROLLER
;
; THIS ROUTINE IS CALLED AS AN ACTION ROUTINE FROM THE UBA DEVICE SCAN TO GENERATE
; THE DATE BASE FOR A SINGLE RL11.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A CO-ROUTINE CALL IS MADE TO THE ORIGINAL CALLER DELIVERING EACH DEVICE
;	UNIT DESCRIPTOR.
;

ACF$RL11:					;
	POPL	W^ACF$L_RETURN			;SAVE RETURN ADDRESS
	CLRL	R0				;SET STARTING UNIT NUMBER
70$:	MOVB	R0,ACF$B_CUNIT(R7)		;SET CONTROLLER UNIT NUMBER
	MOVL	ACF$L_CONTRLREG(R7),R1		;GET ADDRESS OF DEVICE CSR
	BSBB	130$				;WAIT FOR CONTROLLER READY
	MOVW	#RL_DA_M_MRK!RL_DA_M_STS!-	;SET GET STATUS BITS
		RL_DA_M_RST,RL_DA(R1)		;
	ASHL	#8,R0,R3			;MOVE UNIT NUMBER TO POSITION
	BISW3	#4,R3,RL_CS(R1)			;SELECT DRIVE AND GET STATUS
	BSBB	130$				;WAIT FOR CONTROLLER READY
	BITW	#RL_CS_M_OPI,RL_CS(R1)		;OPERATION COMPLETE?
	BNEQ	80$				;IF NEQ NO - NONEXISTENT DRIVE
	MOVL	R0,W^ACF$L_R0SAVE		;SAVE REGISTER
	MOVL	#1,R0				;SET SUCCESS INDICATOR
	JSB	@(SP)+				;DELIVER UNIT TO CALLER
	MOVL	W^ACF$L_R0SAVE,R0		;RESTORE REGISTER
80$:	AOBLEQ	#3,R0,70$			;ANY MORE UNITS TO PROCESS?
	JMP	@W^ACF$L_RETURN			;ALL DONE

130$:	MOVL	#2*500*1000*20,R2		; * should be TIMEWAIT
140$:	TSTB	RL_CS(R1)			; Controller ready?
	BGEQ	150$				; branch if not
	RSB					; Continue
150$:	SOBGTR	R2,140$				; Loop
	TSTL	(SP)+				; Get rid of return PC
	JMP	@W^ACF$L_RETURN			; error - exit

	.PAGE
	.SBTTL	DMF32 MULTIPLE DEVICE GENERATOR
;
; ACF$DMF32 - DMF32 MULTIPLE DEVICE COMBO BOARD
;
; THIS ROUTINE IS CALLED AS AN ACTION ROUTINE FROM THE UBA DEVICE SCAN TO GENERATE
; THE DATA BASE FOR THE DMF32, WHICH INCLUDES A SYNC LINE, ASYNC LINE (DZ TYPE),
; A LP LINE, AND A DR11C LINE. A MAXIMUM OF 3  OF THESE DEVICES CAN BE ON THE
; BOARD AT ONE TIME, BUT VARIOUS COMBINATIONS OF THE FOUR IS POSSIBLE.
;
; INPUTS:
;
;	R6 = ADDRESS OF CONFIGURATION STATUS REGISTER.
;	R7 = ADDRESS OF CONFIGURATION CONTROL BLOCK.
;	R8 = ADDRESS OF ADAPTER CONTROL BLOCK.
;
; OUTPUTS:
;
;	A CO-ROUTINE CALL IS MADE TO THE ORIGINAL CALLER DELIVERING EACH DEVICE
;	UNIT DESCRIPTOR.
;

ACF$DMF32:
	POPL	W^ACF$L_RETURN		;SAVE RETURN ADDRESS
	MOVAB	ACF$AB_DMF32_TABLE,R2	;ADDRESS OF DESCRIPTOR TABLE
	MOVL	ACF$L_CONTRLREG(R7),ACF$AL_CSR  ;SAVE CSR BASE
	MOVW	ACF$W_CVECTOR(R7),ACF$AW_VECTOR ;SAVE VECTOR BASE
	MOVB	ACF$B_CNUMVEC(R7),ACF$AB_NUMVEC ;SAVE NUMVEC

; READ THE DMF32 IDENT REGISTER TO GET BITMASK OF DEVICES PRESENT

	MOVW	@ACF$L_CONTRLREG(R7),R3
	EXTZV	#DMF$V_IDENT,#DMF$S_IDENT,R3,R3
	
10$:	MOVL	(R2)+,R4		;NEXT DEVICE
	BNEQ	20$			;BRANCH IF NOT END OF LIST
	MOVL	ACF$AL_COMBOA,R4	;ADDRESS OF UBADEV TABLE FOR DMF32
	MOVL	UBT$L_DEVNAME(R4),ACF$L_DEVNAME(R7) ;RESTORE DEVICE NAME
	MOVB	ACF$AB_NUMVEC,ACF$B_CNUMVEC(R7)	    ;RESTORE NUMVEC

	JMP	@W^ACF$L_RETURN		;RETURN
	
20$:	BITW	(R4)+,R3		;IS THIS DEVICE ON BOARD?
	BEQL	10$			;BRANCH IF NOT

	MOVL	(R4)+,ACF$L_DEVNAME(R7)	;DEVICE NAME
	MOVL	(R4)+,ACF$L_DRVNAME(R7)	;DRIVER NAME
	MOVB	(R4)+,ACF$B_CNUMVEC(R7)	;NUMBER OF VECTORS
	ADDW3	(R4)+,ACF$AW_VECTOR,ACF$W_CVECTOR(R7) ;ADDRESS OF VECTOR
	ADDL3	(R4)+,ACF$AL_CSR,ACF$L_CONTRLREG(R7) ;ADDRESS OF CSR

	BISB2	#ACF$M_SUPPORT,ACF$B_AFLAG(R7) 	; ASSUME NOSUPPORT
	BBC	#UBA_V_SUPPORT,(R4)+,30$	; BRANCH IF NOSUPPORT
	BICB2	#ACF$M_SUPPORT,ACF$B_AFLAG(R7) 	; SET SUPPORTED

30$:	MOVQ	R2,W^ACF$L_R2R3SAVE	;SAVE R2,R3

	CLRL	R0			;CLEAR COUNT
40$:	MOVB	R0,ACF$B_CUNIT(R7)	;SET UNIT NUMBER
	MOVL	R0,W^ACF$L_R0SAVE	;SAVE
	MOVL	#1,R0			;SET SUCCESS INDICATOR

	JSB	@(SP)+			;DELIVER UNIT TO CALLER

	MOVL	ACF$L_DEVNAME(R7),R2	;SET ADDR OF DEVICE NAME
	CMPW	#^A/TX/,1(R2)		;COMPARE TO TERMINAL NAME
	BNEQ	50$			;BRANCH IF NOT EQUAL
	MOVL	W^ACF$L_R0SAVE,R0	;RESTORE R0
	AOBLEQ	#7,R0,40$		;LOOP

50$:	MOVL	ACF$L_DEVNAME(R7),R1	;SET ADDR OF DEVICE NAME
	BSBW	ACF$INC_CHAR		;INCREMENT CONTROLER

	MOVQ	W^ACF$L_R2R3SAVE,R2	;RESTORE REGISTERS
	BRW	10$			;LOOP

	.PAGE
	.SBTTL	AUTO CONFIGURATION DEVICE DATA BASE RESET
;+
; IOC$AUTORESET - AUTO CONFIGURATION DEVICE DATA BASE RESET
;
; THIS ROUTINE IS CALLED TO RESET THE AUTO CONFIGURATION DEVICE DATA BASE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE CONTROLLER DESIGNATORS ARE ALL RESET TO 'A', WITH
;	THE EXCEPTION OF A FEW DEVICES IN UBATABLE THAT ARE RESET
;	TO THE LETTER STORED IN THAT TABLE.
;
;-
 
IOC$AUTORESET::				;AUTO CONFIGURATION DEVICE DATA BASE RESET
	MOVAB	ACF$AL_RESET,R0		;GET ADDRESS OF RESET POINTER TABLE
10$:	MOVL	(R0)+,R1		;GET ADDRESS OF NEXT CONTROLLER DESIGNATOR
	BEQL	20$			;IF EQL END OF TABLE
	MOVB	#^A/A/,-(R1)		;RESET CONTROLLER DESIGNATOR
	BRB	10$			;LOOP

20$:	MOVQ 	R2,-(SP)		;SAVE R2,R3
	MOVAB	ACF$AB_UBATABLE,R0	;BASE ADDRESS OF TABLE

30$:	MOVL	(R0)+,R1		;NEXT ELEMENT IN TABLE
	BEQL	40$			;END OF LIST
	MOVL	UBT$L_DEVNAME(R1),R2	;ADDRESS OF NAME TO RESET
	MOVZBL	(R2),R3			;EXPAND LENGTH
	MOVB	UBT$B_LETTER(R1),(R3)[R2] ;RESET CONTROLLER LETTER
	BRB	30$			;LOOP

40$:	MOVL	ACF$AL_TTAA,R2		;SPECIAL CASE TT
	MOVL	UBT$L_DEVNAME(R2),R2	;ADDRESS OF DEVICE NAME
	MOVB	#3,(R2)+		;SET COUNT AT 3
	MOVL	#^A/TTA /,(R2)		;MOVE IN CORRECT FIELD
	MOVQ	(SP)+,R2		;RESTORE R2,R3
	RSB				;RETURN
.PAGE
.SBTTL ROUTINE INC_CHAR

;+
; 
; Routine to increment device name last character 
; 
; CALLING SEQUENCE:
;
; 	BSBx ACF$INC_CHAR (called from AUTOCONFG and CONFIG)
;	
; INPUT:
;
;	R1 - Address of device name ascic string
;
; OUTPUT: 
;
;  	Device name with last character incremented
;
;	For TTcn: (*** NOT ACTIVATED YET ***)
;		Controller is incremented until TTZ and then goes
;		to TTAA,TTAB,...TTAZ,TTBA,...
;
;	For all other:
;		DDA,...,DDP,DEA,...,DEP - wraps at P because its the
;		16th letter of the alphabet. (For RSX compatability).
;		
;	TT devices (WILL BE) special cased in the AME. 
;
;	R0 does not return status
;  
;-
   
ACF$INC_CHAR::

	MOVZBL	(R1),R0			; Get length from first byte 
;
; The following line of code can be nop'ed out to activate the TTAA, etc
; for terminals.
;
	BRB	5$
	CMPW	1(R1),#^A/TT/		; Terminal ?
	BEQL	20$			; yes - special case code

5$:	INCB	(R0)[R1]		; Increment the last character 
	CMPB	(R0)[R1],#^A/Q/		; Is this the 17th controller ?
	BLSSU	10$			; No, branch 
	INCB	-1(R0)[R1]		; Increment last char of device name
	MOVB	#^A/A/,(R0)[R1]		; Move /A/ to last 
10$: 	BRB	CHECK_OTHERS		; Branch

20$:	CMPB	(R0)[R1],#^A/Z/		; Ready to wrap ?
	BEQL	30$			; Branch if yes
	INCB	(R0)[R1]		; Increment last character
	RSB				; Return

30$:	CMPB	#3,(R1)			; Still TTx ?
	BNEQ	40$			; Branch if not
	MOVB	#4,(R1)			; Set up longer name
	MOVW	#^A/AA/,3(R1)		; Move in "AA"
	RSB				; Return

40$:	INCB	3(R1)			; Increment first controller letter
	MOVB	#^A/A/,4(R1)		; Reset last character
	RSB

CHECK_OTHERS:

;
; Check through the table for devices that have more than one entry.
; An example is LPA11, which is entered under LAA and LAB. If we've
; just incremented LAB to LAC, then we want to set the LAA to LAC as
; well in case a LPA11 is found on a subsequent UNIBUS.
;

	PUSHR	#^M<R2,R3,R4,R5>	; Save some registers
	MOVW	1(R1),R2		; Get two characters into register
	MOVAB	ACF$AB_UBATABLE,R3	; Address of table

10$:	MOVL	(R3)+,R4		; UBT block address
	BEQL	20$			; Exit on zero, match not found
	MOVL	UBT$L_DEVNAME(R4),R4	; Get the address of the device string
	CMPL	R1,R4			; Compare the addresses
	BEQL	10$			; Make sure it's not the same
	CMPW	R2,1(R4)		; Compare names
	BNEQ	10$			; Branch if no match
;
; A match has been found
;
	INCL	R0			; Include byte count in size
	MOVC3	R0,(R1),(R4)		; Move string

20$:	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB


	.END
