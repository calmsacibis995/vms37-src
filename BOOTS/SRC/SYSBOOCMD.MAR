	.IF	NDF,CMDSW
	.TITLE	SYSBOOCMD - Command parsing for SYSBOOT
	.IFF
	.TITLE	SYSGENCMD - Command parsing for SYSGEN
	.ENDC
	.IDENT	'V03-001'
	.DEFAULT DISPLACEMENT,LONG
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; Facility:  System generation and initialization
;
; Abstract: SYSBOOCMD is the interpreter for parameter modification
;	    commands both at bootstrap time and as part of the sysgen utility
;	    SYSGEN.
;
; Environment:
;
;	Both SYSGEN and SYSBOOT environments.
;
;	*********************************
;
;	WARNING: SYSBOOT code must be PIC
;
;	*********************************
;
; Author:  RICHARD I. HUSTVEDT, Creation date:  4-MAY-1978
;
; Modified by:
;
;	V03-001	JLV0196		Jake VanNoy		17-MAR-1982
;		Add new parsing for CREATE. Add PRM$M_SCS, PRM$M_TTY
;		and PRM$M_SYSGEN to SHOW/ALL mask. Change BOO$SEARCH
;		to return no such parameter if a search for a zero
;		length parameter is passed in.
;
;	V02-041	JLV0186		Jake VanNoy		16-FEB-1982
;		Add BOO$CONSYSID_LOW and BOO$CONSYSID_HIGH labels to 
;		SYSBOOCMD assembly swicthed code to prevent linker
;		undefined symbols.
;
;	V02-040	JLV0183		Jake VanNoy		12-FEB-1982
;		Add SYSIDLOW, SYSIDHIGH syntax.
;
;	V02-039	TMH0039		Tim Halvorsen		10-Feb-1982
;		Use longword relative addressing to fix truncation errors.
;
;	V02-038	JLV0171		Jake VanNoy		25-Jan-1982
;		Minor fixup to WRITE CURRENT/ACTIVE tparse.
;
;	V02-037	JLV0153		Jake VanNoy		6-Jan-1981
;		Add a few symbols to SYSBOOCMD conditional code
;		to prevent undefined symbol errors.
;
;	V02-036	JLV0148		Jake VanNoy		4-Jan-1981
;		Move BOO$GT_ACTIVE and related symbols to module SYSGEN
;		so that they will be defined in STASYSGEN.
;
;	V02-035	JLV0137		Jake VanNoy		31-Dec-1981
;		Add param field to SHOW/DEVICE and SHOW/DRIVER.
;		Add RIO$Output_Line to SYSBOOCMD code, use this
;		routine for all output. Clean up some of the TPARSE
;		problems (USE CUR.PAR now uses a file, not CURRENT).
;		File spec parsing was moved to an action routine
;		rather than doing it with TPARSE. 
;		SET/OUTPUT=filespec and SHOW/UNIBUS were added. 
;		CONNECT /SYSID was added. Calls to BOO$MSGOUT were
;		removed from SYSGENCMD. Move BOO$MSGOUT to SYSBOOCMD
;		code only and add RIO$OUTPUT_LINE in SYSBOOCMD
;		condidtional code. Add "Parameters in use" message
;		to SHOW/parameter.
;
;	V02-034	JLV0119		Jake VanNoy		12-Nov-1981
;		Add BOO$V_INPUT and BOO$V_OUTPUT. Add equivalence
;		for SHARE /POOLBCNT and /POOLBCOUNT as well as
;		/PRQCNT and /PRQCOUNT.
;
;	V02-033	JLV0110		Jake VanNoy		30-Oct-1981
;		Add parameter name to SYSGEN set to min/max messages.
;		Add G^ to SCR$ references.
;
;	V02-032	ROW0019		Ralph O. Weber		19-AUG-1981
;		Change W^EXE$GT_STARTUP reference in BOO$SETSTART to L^.
;
;	V02-031	MIR0014		Michael I. Rosenblum	17-Aug-1981
;		Fixed reference to PRM$W changed to PRM$L.
;
;	V02-030	MIR0010		Michael I Rosenblum
;		Added SHOW/HEX command.
;
;	V02-029	MIR0006		Michael I Rosenblum	06-Aug-1981
;		Cleaned up show commands using TPARSE parameter
;		added SHOW/SCS. Also addes screen clearing and
;		the use of scrolling regions on the show commands.
;
;	V02-028	JLV0058		Jake VanNoy		31-Jul-1981
;		Added SHOW/TTY for terminal parameters.
;
;	V02-027	JLV0042		Jake VanNoy		13-Jul-1981
;		Added G^ to LIB$ calls. Fixed truncation error.
;
;	V02-26	JLV0023		Jake VanNoy		10-Jun-1981
;		Return SYSGENCMD to SYSBOOCMD and add assembly switches
;		to produce SYSGENCMD.OBJ and SYSBOOCMD.OBJ. Moved
;		null Tparse action routines from SYSBOOT to this module.
;		Took out CMD_L_OPTIONS and related bit defintions and
;		replaced them as needed in BOO$GL_CMDOPT. Added "Dynamic"
;		to SHOW parameter.
;
;	V02-25	JLV0015		Jake VanNoy		7-May-1981
;		Make SYSGENCMD separate from SYSBOOCMD.  
;		Made SAVE into syntax SHOW/CONFIG/COMMAND_FILE.
; 		Added show /driver synonym. Added SHOW/ADAPTER and
; 		generic adapter names (UB0, etc.) Begin clean up of 
;		error reporting.
;
;	V0224	JLV0003		Jake VanNoy		9-Feb-1981
;		Added /EXCLUDE to correspond with /SELECT in AUTO ALL.
;		Also added /USER qualifier to load user written drivers.
;		Added SAVE command. Added BOO$V_ definitions for 
;		BOO$GL_CMDOPT. Expanded SHARE/INIT to SHARE/INITIALIZE.
;
;	V0223	JLV0002		Jake VanNoy		9-Feb-1981
;		Changed psects to allow paged and non-paged segments
;		is SYSGEN image. Add SHOW/CONFIGURATION and 
;		CONFIGURE. PSECTs in SYSBOOCMD were not changed
;		because of its inclusion in SYSBOOT. Psect SYSBOOCMD
;		is included in the paged cluster in the link phase.
;
;	V0222	SPF0003		Steve Forgey		24-Oct-1980
;		Fix bug in TPARSE state table for CMD_M_USEFILE.
;
;	V0221	SPF0002		Steve Forgey		15-Oct-1980
;		Continued to change W^ references to BOO$READPROMPT
;		to L^ references.
;
;	V0220	SPF0001		Steve Forgey		02-Oct-1980
;		Accept old parameter files that contain obsolete
;		parameters.  If the file is not a parameter file,
;		then issue only one error message.
;
;	V0219	TCM0001		Trudy C Matthews		19-Sep-1980
;		Changed ^W reference to BOO$READPROMT to ^L reference.
;
;	V0218	LMK0003		Len Kawell		28-Feb-1980
;		Add non-contigous CREATE command qualifier.
;
;	V0217	CAS0018		C. A. Samuelson		18-Feb-1980
;		Cleaned up support for second page and swap filles
;
;	V0216	NPK0001		N. Kronenberg		4-Feb-1980
;		Changed two ^W references to ^L references.
;
;	V0215	SRB0002		Steve Beckhardt		28-Nov-1979
;		Added USE ACTIVE, WRITE ACTIVE, WRITE CURRENT, and
;		W/DYNAMIC commands.
;
;	V0214	SRB0001		Steve Beckhardt		31-Aug-1979
;		Added CONNECT CONSOLE command.
;
;	V0213	ADE0004		A.ELDRIDGE		6-AUG-1979
;		Added support for software only devices.
;
;	V0212	LMK0002		Len Kawell		17-JUL-1979
;		Add /MAXUNITS qualifier to CONNECT command and /PRQCOUNT
;		qualifier to SHARE command.
;
;	V0211	KDM0034		Kathleen D. Morse	25-JUN-1979
;		Add shared memory common event flag qualifiers to SHARE 
;		command.
;
;	V10	LMK0001		Len Kawell		10-JAN-1979
;		Add SHARE command parsing.
;--

;
; Include files:
;
	$PRMDEF				; Parameter descriptor definitions
	$SSDEF				; System messages
	$SYSGMSGDEF			; Sysgen messages	
	$TPADEF				; Define TPARSE symbols

;
; MACROS:
;
;
; Macro to print message
;
;	MSG	message_text
;
	.MACRO	MSG,STR			;
	BSBW	BOO$FACMSG		;
	.ASCIZ	\'STR'\			;
	.ENDM	MSG			;

;
; Equated Symbols:
;
	CR=13				; Character value for carriage return
	FF=12				; Character value for form feed
	LF=10				; Character value for line feed
	BUFFER_SIZE=256
 
	$DEFINI $BOODEF,GLOBAL

	$VIELD	BOO,0,<-		; Used in BOO$GL_CMDOPT
		<NOCHECK   ,,M>,-
		<NORESET   ,,M>,-
		<SAVE      ,,M>,-
		<USER      ,,M>,-
		<PAGEFILE  ,,M>,-
		<NONCONTIG ,,M>,-
		<SELECT    ,,M>,-
		<EXCLUDE   ,,M>,-
		<CONT	   ,,M>,-
		<DEFAULT   ,,M>,-
		<USEFILE   ,,M>,-
		<DISHEX	   ,,M>,-
		<AUTOLOG   ,,M>,-
		<OUTPUT    ,,M>,-
		<INPUT     ,,M>,-
		<SETOUTPUT ,,M>,-
		<TERMINAL  ,,M>,-
		<CONTIG    ,,M>-
		>

	$DEFEND
	.PAGE
	.SBTTL	PARSE TABLES
;
;	DEFINE COMMAND SYNTAX
;

	$INIT_STATE	STATE1,KEYTBL	;
	$STATE				;
	$TRAN	!ADPCMD,TPA$_EXIT,BOO$CONADP	; Set adapter TR number
	$TRAN	!DISABLCMD,TPA$_EXIT	; Disable option command
	$TRAN	!CONECTCMD,TPA$_EXIT,BOO$CONNECT ; Connect command
	$TRAN	!CREATECMD,TPA$_EXIT,BOO$CREATE	; Create dump/page/swap file
	$TRAN	!ENABLCMD,TPA$_EXIT	; Enable option command
	$TRAN	'HELP',TPA$_EXIT,BOO$GIVEHELP	; Help command
	$TRAN	!INSTALCMD,TPA$_EXIT,BOO$INSTALL; Install swap/page file
	$TRAN	!LOADCMD,TPA$_EXIT,BOO$LOAD	; Load driver
	$TRAN	!RELOADCMD,TPA$_EXIT,BOO$RELOAD	; Reload driver
	$TRAN	!SETCMD,TPA$_EXIT	; Set specific value

	$TRAN	!SHARECMD,TPA$_EXIT,GEN$SHARE ; Share command
	$TRAN	!SHOCMD,TPA$_EXIT	; Show values
	$TRAN	!USECMD,TPA$_EXIT	; Set background values
	$TRAN	!WRTCMD,TPA$_EXIT	; Write parameter file
	$TRAN	'CONTINUE',TPA$_EXIT,,BOO$M_CONT,BOO$GL_CMDOPT	; Continue command
	$TRAN	'EXIT',TPA$_EXIT,,BOO$M_CONT,BOO$GL_CMDOPT	; Same as continue
	$TRAN	!AUTOCONFIG,TPA$_EXIT	; Auto-configure command
	$TRAN	!CONFIGCMD,TPA$_EXIT,BOO$CONFIGURE
	$TRAN	TPA$_EOS,TPA$_EXIT	; END OF LINE

;
; Adapter command
;
	$STATE	ADPCMD			; Command to set adapter TR number
	$TRAN	'ADAPTER',,BOO$RESET_ADAP ; Command verb
	$STATE				;
	$TRAN	!NUMBER,TPA$_EXIT	; Numeric value
	$TRAN	!ADAP_STR,TPA$_EXIT	; Generic Name

;
; Autoconfigure command
;
	$STATE	AUTOCONFIG		; Auto configure command
	$TRAN	'AUTOCONFIGURE',,BOO$RESETLIST	; Command verb
	$STATE				;
	$TRAN	'ALL',CONFIGALL		; Configure all
	$TRAN	!NUMBER			; Configure one TR number
	$TRAN	!ADAP_STR2		; Generic Name
	$STATE				;
	$TRAN	!AUTOOPT,TPA$_EXIT,BOO$CONFIGONE	;

	$STATE	CONFIGALL		;
	$TRAN	!AUTOOPT,TPA$_EXIT,BOO$CONFIGALL	;

	$STATE	AUTOOPT			; Select option
	$TRAN	'/'			; Switch introducer
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	; Else not specified
	$STATE				;
	$TRAN	'LOG',AUTOOPT,,BOO$M_AUTOLOG,BOO$GL_CMDOPT ; LOG DEVICES
	$TRAN	'SELECT' ,,,BOO$M_SELECT,BOO$GL_CMDOPT 	     ; Option name
	$TRAN	'EXCLUDE',,,BOO$M_EXCLUDE,BOO$GL_CMDOPT
					; Reverse sense of select
	$STATE				;
	$TRAN	!SEPARATOR		; : or =
	$STATE				;
	$TRAN	'('			; Allow parentheses
	$TRAN	TPA$_LAMBDA		; But make it optional

	$STATE	SELECTLIST		; Device selectlist
	$TRAN	TPA$_SYMBOL,,BOO$MAKLIST	; Select string
	$TRAN	')',AUTOOPT		; End ')'
	$TRAN	TPA$_LAMBDA,AUTOOPT	; Else end of list
	$STATE				;
	$TRAN	<','>,SELECTLIST	; Another option in list
	$TRAN	TPA$_LAMBDA,SELECTLIST	; Else end

;
; CONFIGURE command
;

	$STATE	CONFIGCMD
	$TRAN	'CONFIGURE',,BOO$RESET_IO ; Reset IO and AUTORESET of devices names
	$STATE	
	$TRAN	!CONFIG_LIST
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	
	$STATE	CONFIG_LIST
	$TRAN	!CONFIG_OPT,CONFIG_LIST
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	
	$STATE	CONFIG_OPT
	$TRAN	'/'
	$STATE
	$TRAN	!INPUT,TPA$_EXIT
	$TRAN	!OUTPUT,TPA$_EXIT
	$TRAN	!RESET,TPA$_EXIT

	$STATE	INPUT
	$TRAN	'INPUT'
	$STATE
	$TRAN	!SEPARATOR
	$STATE
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$INPUT_FILE

	$STATE	OUTPUT
	$TRAN	'OUTPUT'
	$STATE
	$TRAN	!SEPARATOR
	$STATE
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$OUTPUT_FILE

	$STATE	RESET
	$TRAN	'RESET',TPA$_EXIT		; No action,this is the default
	$TRAN	'NORESET',TPA$_EXIT,BOO$NO_RESET ; Turn reset off this call


;
; Create command - Create contiguous file for paging, swapping or system dump
;
	$STATE	CREATECMD		;
	$TRAN	'CREATE'		; Command verb
	$STATE	CREOPT			; Create options
	$TRAN	'/',CREATE_QUAL		;
	$TRAN	!FILESPEC,CREOPT,BOO$SETFILNAM; Set name of file
	$TRAN	TPA$_EOS,TPA$_EXIT	;

	$STATE	CREATE_QUAL		;
	$TRAN	'CONTIGUOUS',CREOPT,BOO$CRECONTIG    ; Contiguous 
	$TRAN	'NOCONTIGUOUS',CREOPT,BOO$CRENCONTIG ; Set non-contiguous
	$TRAN	'SIZE'			; Get the allocation size
	$STATE				;
	$TRAN	!VALUE,CREOPT,BOO$FILESIZE ; Set file size
;
; Connect command - Connect specified device and load driver if required
;
	$STATE	CONECTCMD		; 
	$TRAN	'CONNECT',,BOO$CONRESET	; Command verb
	$STATE				;
	$TRAN	'CONSOLE',,BOO$CONSOLE	; Connect console
	$TRAN	TPA$_SYMBOL,,BOO$DEVNAME; Device name
	$STATE	CONOPT			;
	$TRAN	!CONECTOPT,CONOPT	; Connect option
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	;
;
; Disable command
;
	$STATE	DISABLCMD		; Disable command
	$TRAN	'DISABLE'		; Command verb
	$STATE				;
	$TRAN	'CHECKS',TPA$_EXIT,BOO$NOCHECK	; Disable value checking
;
;	Recognize ENABLE command
;
	$STATE	ENABLCMD		; ENABLE command
	$TRAN	'ENABLE'		; Command verb
	$STATE				;
	$TRAN	'CHECKS',TPA$_EXIT,BOO$CHECK	;
;
;	Recognize INSTALL command
;
	$STATE	INSTALCMD		;
	$TRAN	'INSTALL'		;
	$STATE				;
	$TRAN	!FILESPEC,,BOO$SETFILNAM;
	$STATE	INS1			;
	$TRAN	'/'			; Switch introducer
	$STATE
	$TRAN	'PAGEFILE',TPA$_EXIT,BOO$SETPGFL
	$TRAN	'SWAPFILE',TPA$_EXIT
;
;	Recognize LOAD command
;
	$STATE	LOADCMD			;
	$TRAN	'LOAD',LOAD1,BOO$CONRESET; Command verb
;
;	Recognize RELOAD command
;
	$STATE	RELOADCMD		;
	$TRAN	'RELOAD',LOAD1,BOO$CONRESET; Command verb
;
;	Recognize SET Command
;
	$STATE	SETCMD			; SET command
	$TRAN	'SET'			; Command verb
	$STATE				;
	$TRAN	'/',SETSPEC		; 
	$TRAN	'.',,BOO$DOT		; Use last name
	$TRAN	TPA$_SYMBOL,,BOO$SEARCH	; Lookup and verify symbol name
	$STATE				;
	$TRAN	!NUMBER,TPA$_EXIT,BOO$SETVALUE	; Verify and set value
	$TRAN	'DEFAULT',TPA$_EXIT,BOO$SETDEF	; Set to default value
	$STATE	SETSPEC			;
	$TRAN	'STARTUP'		; Set startup file name
	$TRAN	!SETOUTPUT,TPA$_EXIT	; Set output filespec
	$STATE				;
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$SETSTART	;

	$STATE	SETOUTPUT
	$TRAN	'OUTPUT'
	$STATE
	$TRAN	!SEPARATOR		; = or :
	$TRAN	TPA$_LAMBDA		; Or null
	$STATE
	$TRAN	!FILESPEC
	$STATE	
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SET_OUTPUT
;
; Share command - Initialize and/or connect to a shared memory
;
	$STATE	SHARECMD
	$TRAN	'SHARE',,GEN$SHR_RESET	; Command verb
	$STATE	SHARECMDOPT
	$TRAN	!SHAREOPT,SHARECMDOPT	; Command options
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	'M'			; Multiport memory "MPMx"
	$STATE				;
	$TRAN	'P'			;
	$STATE				;
	$TRAN	'M'			;
	$STATE				;
	$TRAN	TPA$_DECIMAL,,GEN$SHR_UNIT ; Memory unit #
	$STATE				;
	$TRAN	TPA$_SYMBOL,,GEN$SHR_MEMNAME ; Memory name
	$STATE	SHROPT			;
	$TRAN	!SHAREOPT,SHROPT	; Share options
	$TRAN	TPA$_EOS,TPA$_EXIT	;

;
;	Recognize SHOW Command
;
	$STATE	SHOCMD			; SHOW command
	$TRAN	'SHOW'			; Command verb
	$STATE	SHOSWITCH		;
	$TRAN	'/'			;
	$TRAN	'.',SHOWONE,BOO$DOT	; SHOW .
	$TRAN	TPA$_SYMBOL,SHOWONE,BOO$SEARCH	; Lookup and verify symbol name
	$STATE				;
	$TRAN	'HEX',SHOSWITCH,,BOO$M_DISHEX,BOO$GL_CMDOPT
	$TRAN	'ADAPTER',TPA$_EXIT,BOO$SHOW_ADAPTER ; SHOW/ADAPTER
	$TRAN	'ACP',HEXQUAL2,,,,PRM$M_ACP; SHOW/ACP
	$TRAN	'ALL',HEXQUAL2,,,, -
<PRM$M_SYS!PRM$M_ACP!PRM$M_JBC!PRM$M_PQL!PRM$M_RMS!PRM$M_SCS!PRM$M_SYSGEN!PRM$M_TTY>; SHOW/ALL
	$TRAN	'RMS',HEXQUAL2,,,,<PRM$M_RMS>; SHOW/RMS
	$TRAN	'SCS',HEXQUAL2,,,,<PRM$M_SCS>; SHOW/SCS
	$TRAN	'SPECIAL',HEXQUAL2,,,,<PRM$M_SPECIAL>; SHOW/SPECIAL
	$TRAN	'SYS',HEXQUAL2,,,,<PRM$M_SYS>; SHOW/SYS
	$TRAN	'GEN',HEXQUAL2,,,,<PRM$M_SYSGEN>; SHOW/GEN (Sysgen Parameters)
	$TRAN	'JOB',HEXQUAL2,,,,<PRM$M_JBC>; SHOW/JOB (Job controller)
	$TRAN	'PQL',HEXQUAL2,,,,<PRM$M_PQL>; SHOW/PQL (Process quota list)
	$TRAN	'TTY',HEXQUAL2,,,,<PRM$M_TTY>; SHOW/TTY
	$TRAN	'NAMES',TPA$_EXIT,BOO$SHONAMES	; SHOW/NAMES show parameter names
	$TRAN	'MAJOR',HEXQUAL2,,,,<PRM$M_MAJOR>	; SHOW/MAJOR show major parameters
	$TRAN	'DYNAMIC',HEXQUAL2,,,,<PRM$M_DYNAMIC>; SHOW/DYNAMIC show dyn. params.
	$TRAN	'STARTUP',TPA$_EXIT,BOO$SHOSTART     ; SHO/STARTUP Show startup file name
	$TRAN	'CONFIGURATION',SHOWCON,BOO$RESET_IO ; SHOW/CONFIGURATION
	$TRAN	!SHOW_UNIBUS,TPA$_EXIT		; /UNIBUS
	$TRAN	!DEV_OR_DRIV,TPA$_EXIT		; /DEVICES and /DRIVER
	
	$STATE	SHOWONE			; SHOW value_name
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,BOO$SHOVALUE	;

	$STATE	HEXQUAL2
	$TRAN	!HEXQUAL,TPA$_EXIT,BOO$SHOALL

	$STATE	HEXQUAL
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA,TPA$_EXIT
	$STATE
	$TRAN	'HEX',TPA$_EXIT,,BOO$M_DISHEX,BOO$GL_CMDOPT

	$STATE	DEV_OR_DRIV
	$TRAN	'DEVICES',,,,,0		; SHO/DEVICES[=devname]
	$TRAN	'DRIVER',,,,,1		; SHO/DRIVER [=devname]
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SHODEV_ALL	; SHOW ALL
	$TRAN	!SEPARATOR		;
	$TRAN	TPA$_LAMBDA
	$STATE				;
	$TRAN	TPA$_STRING,TPA$_EXIT,BOO$SHODEV	; SHOW SPECIFIC DEVICE

	$STATE	SHOWCON
	$TRAN	!SHOWCON_LOOP,TPA$_EXIT,BOO$SHOCONFIG
	
	$STATE	SHOWCON_LOOP
	$TRAN	!SHOWCONOPT,SHOWCON_LOOP
	$TRAN	TPA$_EOS,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,TPA$_FAIL
	
	$STATE	SHOWCONOPT
	$TRAN	'/'
	$STATE
	$TRAN	'COMMAND_FILE',TPA$_EXIT,BOO$RESET_COMMAND ; Set command file spec
	$TRAN	!OUTPUT,TPA$_EXIT
	$TRAN	!ADAPTER,TPA$_EXIT,BOO$SET_TR
;
; SHOW /UNIBUS [/ADAPTER=n]
;
	$STATE	SHOW_UNIBUS
	$TRAN	'UNIBUS',,,,,0
	$STATE
	$TRAN	'/'
	$TRAN	TPA$_LAMBDA
	$STATE
	$TRAN	!ADAPTER,,BOO$SET_TR,,,1
	$TRAN	TPA$_LAMBDA
	$STATE	
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$SHOW_UNIBUS

	$STATE	ADAPTER			; Set adapter number
	$TRAN	'ADAPTER',,BOO$RESET_ADAP
	$STATE	
	$TRAN	!SEPARATOR
	$STATE
	$TRAN	!NUMBER,TPA$_EXIT
	$TRAN	TPA$_LAMBDA,ADAP_STR

	$STATE	ADAP_STR2
	$TRAN	TPA$_LAMBDA,ADAP_STR,BOO$RESET_ADAP

	$STATE	ADAP_STR
	$TRAN	TPA$_ALPHA,ADAP_STR,BOO$ADAP_LETTER 	; One letter at a time
	$TRAN	TPA$_DECIMAL,TPA$_EXIT,BOO$ADAPTER_NAME	; Take number as end

;	
; Recognize USE command
;
	$STATE	USECMD			;
	$TRAN	'USE',,,BOO$M_USEFILE,BOO$GL_CMDOPT ;
	$STATE				;
	$TRAN	!USECUR			; 
	$TRAN	!USEACT			;
	$TRAN	!USEDEF			;
	$TRAN	!FILESPEC,,BOO$USEFILE	;
	$STATE				;
	$TRAN	TPA$_LAMBDA,TPA$_EXIT	;

	$STATE	USECUR			; USE CURRENT
	$TRAN	'CURRENT'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$USECUR

	$STATE	USEACT			; USE ACTIVE
	$TRAN	'ACTIVE'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$USEACT

	$STATE	USEDEF			; USE DEFAULT
	$TRAN	'DEFAULT'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,,BOO$M_DEFAULT,BOO$GL_CMDOPT	;

;
; 	Recognize WRITE Command
;
	$STATE	WRTCMD			;
	$TRAN	'WRITE'			; Command verb
	$STATE				;
	$TRAN	!WRTCUR,TPA$_EXIT	; 
	$TRAN	!WRTACT,TPA$_EXIT	;
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$WRTFILE	;

	$STATE	WRTCUR			; WRITE CURRENT
	$TRAN	'CURRENT'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$WRTCUR

	$STATE	WRTACT			; WRITE ACTIVE
	$TRAN	'ACTIVE'
	$STATE
	$TRAN	TPA$_EOS,TPA$_EXIT,BOO$WRTACT
;
; File Specification
;
	$STATE	FILESPEC		; GENERAL FILE SPEC CHECK
	$TRAN	TPA$_LAMBDA,TPA$_EXIT,BOO$FILESPEC

;
; RECOGNIZE NUMBER
;
	$STATE NUMBER			;
	$TRAN	TPA$_DECIMAL,TPA$_EXIT	; DECIMAL NUMBER
	$TRAN	'%'			; BASE PREFIX
	$STATE				;
	$TRAN	'X',HEXNUM		; HEX BASE DESIGNATOR
	$TRAN	'O'			; OCTAL NUMBER
	$STATE				; 
	$TRAN	TPA$_OCTAL,TPA$_EXIT	; INTRODUCED OCTAL NUMBER
	$STATE	HEXNUM			; INTRODUCED HEX NUMBER
	$TRAN	TPA$_HEX,TPA$_EXIT	; HEX NUMBER

;
; RECOGNIZE SWITCH/VALUE SEPARATOR
;
	$STATE	SEPARATOR		;
	$TRAN	'=',TPA$_EXIT		;
	$TRAN	':',TPA$_EXIT		;
;
; RECOGNIZE CONNECT OPTIONS
;
	$STATE	CONECTOPT		;
	$TRAN	'/'			; Switch introducer
	$STATE				;
	$TRAN	!ADAPTER,TPA$_EXIT,BOO$CONADP		; Adapter number
	$TRAN	'NOADAPTER',TPA$_EXIT,BOO$CONNLADP 	; Use null adapter
	$TRAN	!CONCREG,TPA$_EXIT,BOO$CONCREG		; Control register (UBA)
	$TRAN	!CONCVECTOR,TPA$_EXIT,BOO$CONCVEC	; Vector (UBA)
	$TRAN	!CONCNUMVEC,TPA$_EXIT,BOO$CONCNUM	; Number of vectors
	$TRAN	!CONAUNIT,TPA$_EXIT,BOO$CONAUNIT	; Adapter unit
	$TRAN	!CONUNITS,TPA$_EXIT,BOO$CONUNITS	; Maximum units
	$TRAN	!CONSYSID_LO,TPA$_EXIT,BOO$CONSYSID_LOW	 ; System ID (low)
	$TRAN	!CONSYSID_HI,TPA$_EXIT,BOO$CONSYSID_HIGH ; System ID (high)
	$TRAN	'DRIVERNAME'		;
	$STATE				;
	$TRAN	!SEPARATOR		;
	$STATE	LOAD1			;
	$TRAN	!FILESPEC,TPA$_EXIT,BOO$CONDRVNAM	; Driver name

	$STATE	CONCREG			; Control register address
	$TRAN	'CONTROLREGISTER',VALUE	;
	$TRAN	'CSR',VALUE		; Synonym

	$STATE	CONCVECTOR		; Control vector address
	$TRAN	'VECTOR',VALUE		; 

	$STATE	CONCNUMVEC		; Number of vectors
	$TRAN	'NUMVEC',VALUE		;

	$STATE	CONUNITS		; Maximum units
	$TRAN	'MAXUNITS',VALUE	;

	$STATE	CONSYSID_LO		; System id
	$TRAN	'SYSIDLOW',VALUE	;

	$STATE	CONSYSID_HI		; System id
	$TRAN	'SYSIDHIGH',VALUE	;

	$STATE	CONAUNIT		; Adapter unit number
	$TRAN	'ADPUNIT',VALUE		;
	$TRAN	':',TPA$_EXIT		;
;
; Recognize Share command options
;
	$STATE	SHAREOPT		;
	$TRAN	'/'			; Switch introducer
	$STATE				;
	$TRAN	!SHRGBLCNT,TPA$_EXIT,GEN$SHR_GBLCNT ; Global Section count
	$TRAN	!SHRMBXCNT,TPA$_EXIT,GEN$SHR_MBXCNT ; Mailbox count
	$TRAN	!SHRCEFCNT,TPA$_EXIT,GEN$SHR_CEFCNT ; Com Event Flags Clustr Cnt
	$TRAN	!SHRGBLMAX,TPA$_EXIT,GEN$SHR_GBLMAX ; Port max Global Sections
	$TRAN	!SHRMBXMAX,TPA$_EXIT,GEN$SHR_MBXMAX ; Port max mailboxes
	$TRAN	!SHRCEFMAX,TPA$_EXIT,GEN$SHR_CEFMAX ; Port max Com Event Flags
	$TRAN	!POOLCNT,TPA$_EXIT,GEN$SHR_POOLC ; Count of pool blocks
	$TRAN	!POOLSIZE,TPA$_EXIT,GEN$SHR_POOLS ; Size of pool blocks
	$TRAN	!PRQCNT,TPA$_EXIT,GEN$SHR_PRQCNT ; Count of PRQ blocks

	$TRAN	!SHRSTART,TPA$_EXIT,GEN$SHR_START ; Start of useable mem.
	$TRAN	'INITIALIZE',TPA$_EXIT,GEN$SHR_INIT ; Initialize

	$STATE	SHRGBLCNT		; Global section count
	$TRAN	'GBLSECTIONS',VALUE	; 

	$STATE	SHRMBXCNT		; Mailbox count
	$TRAN	'MAILBOXES',VALUE	;

	$STATE	SHRCEFCNT		; Common event flag cluster count
	$TRAN	'CEFCLUSTERS',VALUE	; 

	$STATE	SHRGBLMAX		; Port maximum Global Sections
	$TRAN	'MAXGBLSECTIONS',VALUE	;

	$STATE	SHRMBXMAX		; Port maximum Mailboxes
	$TRAN	'MAXMAILBOXES',VALUE	;

	$STATE	SHRCEFMAX		; Port maximum Common Ev Flag Clusters
	$TRAN	'MAXCEFCLUSTERS',VALUE	;

	$STATE	POOLCNT			; Total pool blocks count
	$TRAN	'POOLBCOUNT',VALUE	;
	$TRAN	'POOLBCNT',VALUE	;

	$STATE	POOLSIZE		; Pool block size
	$TRAN	'POOLBSIZE',VALUE	;

	$STATE	PRQCNT			; Total PRQ blocks count
	$TRAN	'PRQCOUNT',VALUE	;
	$TRAN	'PRQCNT',VALUE	;

	$STATE	SHRSTART		; Starting relative PFN
	$TRAN	'START',VALUE		;

;
; Get a numeric qualifier value
;
	$STATE	VALUE			; Get value for option
	$TRAN	!SEPARATOR		;
	$STATE				;
	$TRAN	!NUMBER,TPA$_EXIT	;

	$END_STATE
;

; Own Storage:
;

.Psect NONPAGED_DATA,	noexe,rd,wrt,quad

BOO$GL_CMDOPT::				; Command options
	.LONG	BOO$M_TERMINAL		; Default is all off, except for terminal

	.PSECT	SYSBOOCMD,LONG

PARMBLK:				; TPARSE parameter block
	.BLKB	TPA$K_LENGTH0		;
BOO$GL_DOT::				; Last parameter address
	.LONG	0			;
BOO$GQ_FILDESC::			; File name descriptor
	.LONG	0,0			; 
BOO$GT_FILNAME::			; File name buffer
	.BLKB	64			;
BOO$GT_COMBUF::				; Command Line Buffer
	.BLKB	200			;
BOO$C_COMBUFSZ==.-BOO$GT_COMBUF		; Size of command buffer
BOO$GT_COMSTR::				; Command string 
	.BLKB	1024			; 
BOO$C_COMSTRLEN==.-BOO$GT_COMSTR	; Length of command string buffer
BOO$GT_SYSNAME::			; System name string
	.ASCIC	\SYS$SYSTEM:SYS.EXE\	; Name of sytem image

BOO$T_DYNAMIC:		.ascic	/Dynamic/
BOO$T_NODYNAMIC:	.ascic	//

CTRLSTR:	.ASCID	@  !15AC!4(10SL)  !12AC !AC@

HEXSTR:		.ASCID	@  !15AC!4(10XL)  !12AC !AC@

NCTRLSTR:	.ASCID	@  !#(17AC) @

SCTRLSTR:	.ASCID	@  Startup command file = !AC@

CTR_PARINUSE:	.ASCID	@!/  Parameters in use: !AC@

SDVHDR:
	.ASCII	\  Parameter Name    Current   Default   Minimum   Maximum\
	.ASCII	\  Unit         Dynamic\
	.ASCII	<CR><LF>		; 
	.ASCII	\  --------------    -------   -------   -------   -------\
	.ASCII	\  ----         -------\
SDVHDRLEN=.-SDVHDR

.IF	NDF,CMDSW			; SYSBOOCMD definitions for RIO$OUTPUT_LINE

RIO$AB_OUTBUF::		.long	BUFFER_SIZE
			.long	RIO$AB_BUFFER
RIO$AB_BUFFER::		.blkb	BUFFER_SIZE
RIO$GW_OUTLEN::		.word	0

BOO$GB_FILELEN:		.byte	0
BOO$GL_FILEADDR:	.long	0
BOO$GT_CURRENT:	
BOO$GT_DEFAULT:
BOO$GL_PARINUSE:	.long	0
		
.ENDC
	.PAGE
	.SBTTL	
;++
;
; Functional Description:
;
;
; Calling Sequence:
;	NONE
;
; Input Parameters:
;	NONE
;
; Implicit Inputs:
;	NONE
;
; Output Parameters:
;	NONE
;
; Implicit Outputs:
;	NONE
;
; Side Effects:
;	NONE
;
;--
	.LIST	MEB			; Show macro expansions


BOO$GETPARAM::	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Save all registers

	.IF	NDF,CMDSW	; SYSBOOCMD only
;
; Make descriptors PIC (only needed in SYSBOOCMD)
;

	MOVAB	CTRLSTR+8,CTRLSTR+4	; Set address in descriptor
	MOVAB	HEXSTR+8,HEXSTR+4	; Set address in descriptor
	MOVAB	NCTRLSTR+8,NCTRLSTR+4	; Set address in descriptor
	MOVAB	SCTRLSTR+8,SCTRLSTR+4	; Set address in descriptor
	MOVAB	RIO$AB_BUFFER,-
		RIO$AB_OUTBUF+4		; Set address in descriptor

	.ENDC

READCMD:				;
	MOVAL	PARMBLK,R7		; Get address of parameter block
	CLRL	TPA$L_STRINGCNT(R7)	; Initialize string length
	MOVAB	BOO$GT_COMSTR,TPA$L_STRINGPTR(R7)	; And address
READLINE:				;
	MOVAB	BOO$GT_COMBUF,R2	; Set address of buffer
	PUSHL	R2			; Set buffer address into argument list
	MOVZBL	#BOO$C_COMBUFSZ,-(SP)	;  and maximum size for read
	PUSHAB	BOO$GT_PROMPT		; Address of prompt string
	CALLS	#3,L^BOO$READPROMPT	; Prompt for and accept command
	BLBS	R0,5$			; Exit if end of file.
	RET				;

; Upcase input

5$:	MOVL	R2,R0			; Set address of string
	MOVZBL	(R0)+,R1		; Get address and count
7$:	CMPB	(R0),#^A/a/		; Lower case possible ?
	BLSSU	8$			; No, Branch
	CMPB	(R0),#^A/z/		; Lower case possible ?
	BGTRU	8$			; No, Branch
	BICB2	#^X20,(R0)		; Clear bit, make character upper case
8$:	INCL	R0			; Increment pointer
	SOBGTR	R1,7$			; Loop

	BLBC	4(AP),10$		; Skip echo if no verify
	CLRQ	-(SP)			; Null buffer for read
	PUSHAB	1(R2)			; Set address of output string
	MOVZBL	(R2),R0			; Get length of string
	MOVAB	1(R2)[R0],R0		; Point past string
	MOVB	#CR,(R0)+		; Set CR
	CLRB	(R0)			; Mark end of string
	CALLS	#3,L^BOO$READPROMPT	; Output buffer string
10$:	ADDL3	TPA$L_STRINGPTR(R7),TPA$L_STRINGCNT(R7),R3 ; Get current pointer
	MOVZBL	(R2)+,R0		; Get length of input line
	BEQL	READLINE		; Ignore null input
	MOVL	R2,R1			; Move to LOCC address register
30$:	MOVZBL	(R1)+,R2		; Get a character
	CMPB	#^A/-/,R2		; Is this a possible continuation?
	BEQL	50$			; Branch if yes
	CMPB	#^A/!/,R2		; Is this the start of a comment?
	BEQL	40$			; Branch if yes
	INCL	TPA$L_STRINGCNT(R7)	; Bump characters in command string
	MOVB	R2,(R3)+		; Copy character to command string
35$:	SOBGTR	R0,30$			; Continue for all characters in put
	BRB	PARSE			; Done, parse command
40$:	DECL	R0			; One less character
	LOCC	#^A/!/,R0,1(R1)		; Scan remaining string for !
	BEQL	PARSE			; None end of line first
	INCL	R1			; Advance to next character
	BRB	35$			; Continue with line scan
50$:	MOVL	R3,R4			; Save string insertion pointer
	MOVL	TPA$L_STRINGCNT(R7),R5	; and current length
	MOVB	R2,(R3)+		; Copy to buffer anyway
	INCL	TPA$L_STRINGCNT(R7)	; Advance counter
	BRB	65$			; And check for end of string
60$:	MOVZBL	(R1)+,R2		; Get another character
	MOVB	R2,(R3)+		; Copy to buffer
	INCL	TPA$L_STRINGCNT(R7)	; Bump string count
	CMPB	#^A/ /,R2		; Blank?
	BEQL	65$			; Yes, still might be a continuation
	CMPB	#^A/!/,R2		; Is this a comment?
	BEQL	80$			; Branch if yes
	BRB	35$			; Not a continuation
65$:	SOBGTR	R0,60$			; Continue to end of line
70$:	MOVL	R4,R3			; Drop everything after continuation
	MOVL	R5,TPA$L_STRINGCNT(R7)	; By restoring count
	BRW	READLINE		; Read another line
80$:	DECL	R0			; One less character
	LOCC	#^A/!/,R0,1(R1)		; Scan for end of comment
	BEQL	70$			; None
	INCL	R1			; Skip trailing !
	BRB	65$			; and continue scan for end of line
PARSE:	MOVL	#TPA$K_COUNT0,TPA$L_COUNT(R7)	; Init count field
	BISL	#TPA$M_ABBREV,TPA$L_OPTIONS(R7)	; Permit abbreviations
	BICL2	#^C<BOO$M_NOCHECK!-
		BOO$M_SETOUTPUT!-
		BOO$M_TERMINAL>,-
		BOO$GL_CMDOPT 		; Clear all options but specified
	CLRB	TPA$B_CHAR(R7)		; Last character parsed
	PUSHAB	KEYTBL			; Pass address of key table
	PUSHAB	STATE1			;  and state table
	PUSHL	R7			; Set address of parameter block
	CALLS	#3,G^LIB$TPARSE		; Parse input
	BLBS	R0,20$			; Branch if no syntax error
	BBS	#31,R0,15$		; Branch if error already given

.IF	NDF,CMDSW		; SYSBOOCMD 

	MSG	<-E-Syntax error>	; SYSBOOT error message

.IFF				; SYSGENCMD

	CMPL	#LIB$_SYNTAXERR,R0	; Tparse Syntax error ?
	BEQLU	10$			; Branch if yes
	TSTL	R0			; Zero ?
	BEQL	10$			; Branch if yes
	PUSHL	R0			; Push REAL error code
	CALLS	#1,G^LIB$SIGNAL		; Signal Error
	BRB	30$			; Continue

; Heuristically determine where syntax error occured

10$:	MOVZBL	TPA$B_CHAR(R7),R4	; Was there a character parsed ?
	BNEQ	12$			; Branch if yes
	MOVQ	TPA$L_STRINGCNT(R7),-(SP) ; Push entire read-in string
	BRB	14$			; Branch

12$:	SUBL3	TPA$L_TOKENCNT(R7),TPA$L_STRINGCNT(R7),R2 ; Length
	ADDL3	TPA$L_TOKENCNT(R7),TPA$L_STRINGPTR(R7),R3 ; Address
	CMPB	#^A'/',R4		; Was it a qualifier error ?
	BEQL	13$			; No
	MOVQ	R2,-(SP)		
	BRB	14$

13$:	LOCC	TPA$B_CHAR(R7),R2,(R3)  ; Find it then
	MOVQ	R0,-(SP)		; Push length and address
14$:	PUSHL	#2			; Number of FAO params
	PUSHL	#SYSG$_SYNTAX		; Error message
	CALLS	#4,G^LIB$SIGNAL		; Signal the error

.ENDC	

15$:	BRB	30$			; and get another command
20$:	MOVL	BOO$GL_CMDOPT,R6	; Get command option flags
	BBS	#BOO$V_CONT,R6,EXIT	; Exit if continue flag
	BBC	#BOO$V_DEFAULT,R6,30$	; Read another command if Help
;
; The Default values for system parameters are selected and must be copied to 
; the current system parameter area.
;
	MOVC3	#EXE$C_SYSPARSZ,-
		BOO$A_SYSPARAM,-
		EXE$A_SYSPARAM		; Copy defaults
	MOVAL	BOO$GT_DEFAULT,-
		BOO$GL_PARINUSE		; Set default in use
30$:	BRW	READCMD			; Read more commands

EXIT:	MOVL	#1,R0			; Return success
	RET				;

	.PAGE
	.SBTTL	BOO$FILESPEC - Parse file spec
;+
;
; CALLING SEQUENCE:
; 
;	called as a TPARSE action routine
;
; INPUT:
;
;	The tparse parameter block (AP)
;
; OUTPUT:
;
;	A possible file spec is found.
;
; SIDE EFFECTS:
;
;	The tparse parameter block is updated.
;
;-

.Entry	BOO$FILESPEC, ^M<R2,R3,R4,R5,R6,R7>

	MOVL	TPA$L_STRINGPTR(AP),R2	; Get address of current parse
	MOVL	R2,TPA$L_TOKENPTR(AP)	; Set token pointer
	MOVL	R2,BOO$GL_FILEADDR	; Set file spec pointer
	MOVL	TPA$L_STRINGCNT(AP),R3	; Remainder of parse string length
	BEQL	100$			; Error if zero

	LOCC	#^A/ /,R3,(R2)		; is there a blank?
	BNEQ	50$			; Branch if yes
	LOCC	#^A@/@,R3,(R2)		; is there a slash?

50$:	MOVL	R0,TPA$L_STRINGCNT(AP)	; Remaining length
	MOVL	R1,TPA$L_STRINGPTR(AP)	; Address of blank or slash
	SUBL2	R2,R1			; Calculate length
	MOVL	R1,TPA$L_TOKENCNT(AP)	; Set length of file spec
	MOVB	R1,BOO$GB_FILELEN	; Set length of file spec	
60$:	MOVL	#SS$_NORMAL,R0		; Set success
	BRB	110$			; Exit

100$:	MOVL	#LIB$_SYNTAXERR,R0
110$:	RET

	.PAGE
	.SBTTL	BOO$USECUR - Use parameters from current image
BOO$USECUR:				; Set to current system values
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>;
	MOVAB	BOO$GT_SYSNAME,R0	; Get address of system file name
	MOVAB	BOO$GQ_FILDESC,R7	; Address of file name descriptor
	MOVZBL	(R0)+,(R7)		; Set length in descriptor
	MOVL	R0,4(R7)		;  and set address
	BSBW	BOO$FILOPEN		; Open file
	BLBC	R0,10$			;  Exit if error
	MOVZBL	#<<EXE$C_SYSPARSZ+511>@-9>,R9	; Set size of read
	ADDL	#<<MMG$A_SYSPARAM-^X80000000+512>@-9>,R8 ; Point to parameters
	MOVAB	EXE$A_SYSPARAM,R6	; Set buffer address
	BSBW	BOO$READFILE		; Read parameters from current system
	MOVAL	BOO$GT_CURRENT,-
		BOO$GL_PARINUSE		; Set parameters in use
10$:	MOVL	#1,R0			; Return success
	RET				;

	.PAGE			;
	.SBTTL	BOO$SHOWV - Routine to show one parameter value
;
; Input Parameters:
;	R4 - Pointer to PRM block to be displayed.
;
; Output Parameters:
;	Content of parameter block is displayed by calling RIO$OUTPUT_LINE
;
BOO$SHOWV:				;
	MOVL	(R4),R0			; Get address of value
	MOVAB	BOO$A_SYSPARAM[R0],R0	; Add current base address
	SUBL	#BOO$A_SYSPARAM,R0	;  and subtract link-time value
	BSBB	GETDATA			; Get data item according to size

	PUSHAL	BOO$T_NODYNAMIC		; Assume not dynamic
	BBC	#PRM$V_DYNAMIC,PRM$L_FLAGS(R4),20$ ; Branch if not
	MOVAL	BOO$T_DYNAMIC,(SP)	; Change to dynamic string
	
20$:	PUSHAB	PRM$T_UNIT(R4)		; Stack address of unit name string
	PUSHL	PRM$L_MAX(R4)		; Stack maximum value
	PUSHL	PRM$L_MIN(R4)		;  and minimum value
	PUSHL	PRM$L_DEFAULT(R4)	; Default value
	BITW	#PRM$M_NEG,PRM$L_FLAGS(R4)	; check for negated value
	BEQL	30$			; Branch if not
	MNEGL	(SP),(SP)		; Make absolute value
30$:	PUSHL	R1			; Current value
	PUSHAB	PRM$T_NAME(R4)		; Stack address of parameter name
	PUSHAQ	RIO$AB_OUTBUF		; Stack address of buffer descriptor
	PUSHAL	RIO$GW_OUTLEN		; Set address of loc to receive size

	BBS	#BOO$V_DISHEX,-
		BOO$GL_CMDOPT,40$	; Branch if Hex
	PUSHAQ	CTRLSTR			; Control string for decimal
	BRB	50$			; Skip
40$:	PUSHAQ	HEXSTR			; Control string for hex

50$:	CALLS	#10,SYS$FAO		; Format value for output
	BLBC	R0,60$

	BSBW	RIO$OUTPUT_LINE		; Output the line
60$:	RSB				; and return

GETDATA:				;
	MOVZBL	PRM$B_POS(R4),R1	; GET SIZE OF DATUM
	EXTZV	R1,PRM$B_SIZE(R4),(R0),R1	; GET DATUM
	BITW	#PRM$M_NEG,PRM$L_FLAGS(R4)	; CHECK FOR NEGATED VALUE
	BEQL	10$			; NO
	MOVZBL	PRM$B_POS(R4),R1	; GET POSITION AGAIN
	EXTV	R1,PRM$B_SIZE(R4),(R0),R1	; CONVERT TO SIGNED NUMBER
	MNEGL	R1,R1			; ABSOLUTE VALUE
10$:	RSB				;

;
;	Show names of parameters
;
BOO$SHONAMES:			;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;
	MOVAB	BOO$A_PRMBLK,R6		; Set base of parameter blocks

10$:	MOVL	#5,R7			; Init argument count
	TSTL	(R6)			; At end of list?
	BEQL	90$			; Yes, finished
	MOVAL	PRM$T_NAME(R6),R1	; Set parameter name address
	MOVAB	PRM$C_LENGTH(R6),R6	; Next parameter block
	TSTL	(R6)			; At end of list?
	BEQL	70$			; yes
	MOVAL	PRM$T_NAME(R6),R2	; Set second address
	INCL	R7			; Advance argument count
	MOVAB	PRM$C_LENGTH(R6),R6	; Next argument
	TSTL	(R6)			; At end of list ?
	BEQL	70$			; yes
	MOVAL	PRM$T_NAME(R6),R3	; Set third address
	INCL	R7			; Another argument
	MOVAB	PRM$C_LENGTH(R6),R6	; Next parameter block
	TSTL	(R6)			; At end of list?
	BEQL	70$			; Yes
	INCL	R7			; another argument
	MOVAB	PRM$T_NAME(R6),R4	; Set fourth address
	MOVAL	PRM$C_LENGTH(R6),R6	; Next parameter block
70$:	PUSHR	#^M<R1,R2,R3,R4>	; Stack args
	SUBL3	#4,R7,-(SP)		; Set number of strings on line
	PUSHAQ	RIO$AB_OUTBUF		; Stack address of buffer descriptor
	PUSHAL	RIO$GW_OUTLEN		; Set address of loc to receive size
	PUSHAQ	NCTRLSTR		; Stack address of control string descr
	CALLS	R7,SYS$FAO		; Format value for output
	BLBC	R0,100$

	BSBW	RIO$OUTPUT_LINE		; Output line
	BRB	10$			; Loop

90$:	MOVL	#1,R0			; Success status
100$:	RET				; Return

;
; Show name of Startup command file
;
BOO$SHOSTART:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;
	
	MOVAB	L^EXE$GT_STARTUP,R0	; Set address of string
	$FAO_S	-
		CTRSTR	= SCTRLSTR,-	    ; Stack address of control string descr
		OUTLEN	= RIO$GW_OUTLEN,-   ; Set address of loc to receive size
		OUTBUF  = RIO$AB_OUTBUF,-   ; Stack address of buffer descriptor
		P1 	= R0 		    ; Set address of startup string
	BLBC	R0,10$

	BSBW	RIO$OUTPUT_LINE
10$:	RET				;

	.PAGE
	.SBTTL	BOO$NOCHECK - Disable value checking
;
; Disable Value Checking and Limiting
;
BOO$NOCHECK:	.WORD	0		;
	BBCS	#BOO$V_NOCHECK,BOO$GL_CMDOPT,10$ ; Set value check inhibit
10$:	MOVL	#1,R0			; Return success
	RET				;
	.PAGE
	.SBTTL	BOO$NOCHECK - Disable value checking

;
; ENABLE VALUE CHECKING AND LIMITING
;
BOO$CHECK:				;
	.WORD	0			; Null entry mask
	BBCC	#BOO$V_NOCHECK,BOO$GL_CMDOPT,10$ ; Clear check flag
10$:	MOVL	#1,R0			; Return with success
	RET				;

	.PAGE
	.SBTTL	BOO$SEARCH - Lookup parameter name
;
; Input Parameters:
;	TPA$L_TOKENCNT(AP) - Count of characters in token
;	TPA$L_TOKENPTR(AP) - Address of token
;
; Output Parameters:
;	TPA$L_PARAM(AP) - Address of PRM block for specified parameter
;			  name if found.
;	R0	- 0 => Name not found
;		  1 => Name found
;
BOO$SEARCH::	.WORD	^M<R2,R3,R4,R5>	;

	BBC	#BOO$V_USEFILE, -
		BOO$GL_CMDOPT,5$	; Skip count check if not USE <file>

	CMPB	#3,TPA$L_TOKENCNT(AP)	; Check for count of characters
	BGEQ	50$			; Exit if if not > 3

5$:	MOVAB	BOO$A_PRMBLK,R4		; Set base of parameter blocks
10$:	TSTL	(R4)			; Check for end of list
	BNEQ	30$			; Not yet
	BRB	50$			; Symbol not found error
30$:	MOVAB	PRM$T_NAME(R4),R5	; Get pointer to name string
	CMPB	TPA$L_TOKENCNT(AP),(R5)+; Check for too many characters
	BGTR	35$			; Yes, cant be a match
	CMPC3	TPA$L_TOKENCNT(AP),-	;
		@TPA$L_TOKENPTR(AP),(R5); Is this a match?
	BEQL	40$			; Yes, return PRM pointer
35$:	MOVAB	PRM$C_LENGTH(R4),R4	; Advance to nex parameter descriptor
	BRB	10$			; and try another
40$:	MOVL	R4,TPA$L_PARAM(AP)	; Return address of parameter block
	MOVL	R4,BOO$GL_DOT		; And save as dot
	MOVL	#1,R0			; Indicate success
	RET				;  and return
50$:	BBS	#BOO$V_USEFILE,BOO$GL_CMDOPT,60$; No message on 'USE filename'

.IF	NDF,CMDSW			; SYSBOOCMD 
	MSG	<-E-No such parameter>
.IFF					; SYSGENCMD
	PUSHL	#SYSG$_NOPARAM		; Set message
	CALLS	#1,G^LIB$SIGNAL		; Signal
.ENDC

60$:	MNEGL	#2,R0			; Give unique error code
	RET

;
; BOO$DOT - Use last parameter name if any
;
BOO$DOT:.WORD	0			; Null entry mask
	MOVL	BOO$GL_DOT,TPA$L_PARAM(AP)	; Get dot address
	BNEQ	10$			; Have pointer
	CLRL	R0			; Give error status
10$:	RET				;
	.PAGE
	.SBTTL	BOO$SETVALUE - Store parameter value
;
; Input Parameters:
;	TPA$L_PARAM - Address of parameter descriptor
;	TPA$L_NUMBER- Value to be checked and stored
;
; Output Parameters:
;	If value is within bounds set by parameter descriptor, the
;	value is moved to the address specified by the parameter descriptor
;	R0 - Completion status 0 => value out of allowable range
;			       1 => legal value successfully stored
;
BOO$SETVALUE::				;
	.WORD	^M<R4>			; Entry mask
	MOVL	TPA$L_PARAM(AP),R4	; Get pointer to parameter descriptor
	PUSHL	#1			; Assume good value
	BBS	#BOO$V_NOCHECK,BOO$GL_CMDOPT,30$ ; Should values be checked
	MOVL	PRM$L_MIN(R4),R0	; Get minimum allowable value
	BLSS	20$			; No minimum
	CMPL	TPA$L_NUMBER(AP),R0	; Check input value
	BGEQU	20$			; Branch if above minimum
	MOVL	R0,TPA$L_NUMBER(AP)	; Use minimum value
	MNEGL	#2,(SP)			; Note bad value
20$:	MOVL	PRM$L_MAX(R4),R0	; Get maximum allowable value
	BLSS	30$			; Branch if no maximum
	CMPL	R0,TPA$L_NUMBER(AP)	; Check for maximum
	BGEQU	30$			; Continue if value legal
	MOVL	R0,TPA$L_NUMBER(AP)	; Limit to max value
	CLRL	(SP)			; Indicate error
30$:	MOVL	TPA$L_PARAM(AP),R0	; Get address at which to store
	MOVL	PRM$L_ADDR(R0),R0	; 
	MOVAB	BOO$A_SYSPARAM[R0],R0	; Add present base of parameters
	SUBL	#BOO$A_SYSPARAM,R0	; And subtract link-time base
	BITW	#PRM$M_NEG,PRM$L_FLAGS(R4)	; Check for negative
	BEQL	35$			; No
	MNEGL	TPA$L_NUMBER(AP),TPA$L_NUMBER(AP)	; Complement
35$:	MOVZBL	PRM$B_POS(R4),R1	; Get position
	INSV	TPA$L_NUMBER(AP),R1,PRM$B_SIZE(R4),(R0); Set value in field
40$:	MOVL	(SP)+,R0		; Get completion status
	BLSS	60$			; Low value limit
	BLBS	R0,50$			; Success, return

.IF	NDF,CMDSW		; SYSBOOCMD 

	MSG	<-W-Value set to maximum>
50$:	RET				; and return
60$:	MSG	<-W-Value set to minimum>
	RET				;

.IFF				; SYSGENCMD

	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_SETMAX		; Error status
	BRB	70$
50$:	RET

60$:	PUSHAB	PRM$T_NAME(R4)		; Address of parameter name
	PUSHL	#1			; Number of FAO param's
	PUSHL	#SYSG$_SETMIN		; Error status
70$:	CALLS	#3,G^LIB$SIGNAL		; Signal
	MOVL	#SS$_NORMAL,R0		; Set success
	RET				; and return

.ENDC

;
; Set to default value
;
BOO$SETDEF:				;
	.WORD	^M<R4>			;
	MOVL	TPA$L_PARAM(AP),R4	; Get address of parameter block
	MOVL	PRM$L_DEFAULT(R4),TPA$L_NUMBER(AP)	; Set default as value
	BRW	BOO$SETVALUE+2		; 
	.PAGE
	.SBTTL	BOO$SHOVALUE - Action routine to show single value
;
; Input Parameters:
;	TPA$L_PARAMETER(AP) - Address of parameter block
;
BOO$SHOVALUE:				;
	.WORD	^M<R2,R3,R4>		;
	MOVL	TPA$L_PARAM(AP),R4	; Get address of parameter block
	BSBW	BOO$SHOWV		; Show value
	RET				; Return with BOO$SHOWV status

	.PAGE				
	.SBTTL	BOO$SHOALL - Action routine to show all parameter values
;
; Input Parameters:
; 	(AP)		Pointer to the TPARSE table
;	TPA$L_PARAM(AP)	The mask of acceptable types
; Output Parameters:
;	All parameters except special parameters are displayed.
;
BOO$SHOALL:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;

.IF	DF,CMDSW			; SYSGEN ONLY
	
	BBC	#BOO$V_TERMINAL,-
		BOO$GL_CMDOPT,5$	; If terminal,
	CLRQ	-(SP)			;  clear the whole screen
	CALLS	#2,G^SCR$ERASE_PAGE	
5$:
;
; Format "Parameters in use message" 
;
	$FAO_S	CTRSTR = CTR_PARINUSE,-
		OUTLEN = RIO$GW_OUTLEN,-
		OUTBUF = RIO$AB_OUTBUF,-
		P1 = BOO$GL_PARINUSE
	BSBW	RIO$OUTPUT_LINE

.ENDC

	MOVC3	#SDVHDRLEN,-
		SDVHDR,RIO$AB_BUFFER	 ; Move in string
	MOVW	#SDVHDRLEN,RIO$GW_OUTLEN ; Set length
	BSBW	RIO$OUTPUT_LINE		 ; Output line

.IF	DF,CMDSW			; SYSGEN ONLY
	BBC	#BOO$V_TERMINAL,-
		BOO$GL_CMDOPT,7$	; If terminal,
	PUSHL	#24			;  use only 24 lines
	PUSHL	#5			;  and scroll only the bottom portion
	CALLS	#2,G^SCR$SET_SCROLL	;  and setup a scrolling region
7$:
.ENDC

	MOVAB	BOO$A_PRMBLK,R4		; Set starting parameter block address
	MOVL	TPA$L_PARAM(AP),R5	; Set mask of acceptable types
;
; Loop through all parameters
;
10$:	TSTL	(R4)			; Check for end of list
	BEQL	50$			;  yes, done
	BITW	R5,PRM$L_FLAGS(R4)	; Is this one to output?
	BEQL	40$			; No, try another
	BBC	#PRM$V_SPECIAL,-	; Yes, is it a special parameter?
		PRM$L_FLAGS(R4),30$	; Branch if not
	BBC	#PRM$V_SPECIAL,R5,40$	; It's special - branch if unasked for
30$:
	BSBW	BOO$SHOWV		; Display values
40$:	MOVAB	PRM$C_LENGTH(R4),R4	; Next parameter block
	BRB	10$			;
50$:

.IF	DF,CMDSW
	BBC	#BOO$V_TERMINAL,-
		BOO$GL_CMDOPT,60$	; If terminal,
	PUSHL	#24			;  Use only 24 lines
	PUSHL	#1			;  and scroll only the bottom portion
	CALLS	#2,G^SCR$SET_SCROLL	;  and setup a scrolling region
60$:
.ENDC
	RET				;
	.PAGE				;
;
; Set name of startup command file
;
BOO$SETSTART:				;
	.WORD	^M<R2,R3,R4,R5,R6,R7>	;
	MOVAB	L^EXE$GT_STARTUP,R6	; Point to slot for startup file name
	CLRL	R0			; Assume error
	CMPB	#31,TPA$L_TOKENCNT(AP)	; Check for fit
	BGEQ	10$			; Continue if legal size
	RET				;
10$:	MOVB	TPA$L_TOKENCNT(AP),(R6)+; Set count for string
	MOVC3	TPA$L_TOKENCNT(AP),@TPA$L_TOKENPTR(AP),(R6)	; Set file name
	MOVZWL	#1,R0			; Return success indication
	RET				;

	.PAGE
	.IF	NDF,CMDSW		; SYSBOOCMD ONLY

	.SBTTL	BOO$MSGOUT - Output message
;
; Calling Sequence:
;	BSBW	BOO$MSGOUT
;	.ASCIZ	message_string
;
BOO$MSGOUT::				;
	CLRQ	-(SP)			; Null read buffer
	PUSHL	8(SP)			; Address of string
	CALLS	#3,L^BOO$READPROMPT	; Output string
	LOCC	#0,#64000,@(SP)+	; Find end of string
	MOVL	#1,R0			; Set success code
	JMP	1(R1)			; Return to caller

;+
; This routine is in RMSCONIO for SYSGEN, is used here to map SYSBOOT
; calls to this routine into calls to BOO$READPROMPT.
;
; Inputs:
;	RIO$GW_OUTLEN - length of string to output
;	RIO$AB_BUFFER - buffer to output
;-

RIO$OUTPUT_LINE::

	MOVQ	R1,-(SP)		; Save R1,R2
	MOVZWL	RIO$GW_OUTLEN,R1	; Set length
	MOVAB	RIO$AB_BUFFER,R2	; Set address
	MOVAB	(R2)[R1],R1		; Set address of end of string
	MOVL	#^X00000A0D,(R1)	; Set CR, LF, zero byte at end
	
	CLRQ	-(SP)			; Null read buffer
	PUSHL	R2			; Address of string
	CALLS	#3,L^BOO$READPROMPT	; Output string

	MOVQ	(SP)+,R1		; Restore R1,R2
	RSB				; Return

	.PAGE
	.SBTTL	DUMMY COMMAND ROUTINES FOR COMMANDS NOT IN SYSBOOT
GEN$SHR_RESET::				; Dummy SHARE command routines
GEN$SHR_MEMNAME::			;
GEN$SHR_UNIT::				;
GEN$SHR_GBLCNT::			;
GEN$SHR_MBXCNT::			;
GEN$SHR_GBLMAX::			;
GEN$SHR_MBXMAX::			;
GEN$SHR_POOLC::				;
GEN$SHR_POOLS::				;
GEN$SHR_START::				;
GEN$SHR_INIT::				;
GEN$SHARE::				;
GEN$SHR_CEFCNT::			;
GEN$SHR_CEFMAX::			;
GEN$SHR_PRQCNT::			;
BOO$CONFIGURE::				; CONFIGURE command
BOO$RESET_SAVE::
BOO$USER::
BOO$SET_TR::
BOO$SHOCONFIG::				; SHOW/CONFIGURATION
BOO$RESET_IO::				; 
BOO$INPUT_FILE::			; for /INPUT =
BOO$OUTPUT_FILE::			; for /OUTPUT =
BOO$NO_RESET::				; Don't reset CONFIGURE names
BOO$CONUNITS::				;
BOO$CONNLADP::				;
BOO$CONSOLE::				;
BOO$USEACT::				;
BOO$WRTCUR::				;
BOO$WRTACT::				;
BOO$CRECONTIG::				;
BOO$CRENCONTIG::			;
BOO$CONFIGALL::				; Dummy autoconfigure command
BOO$CONFIGONE::				; Dummy autoconfigure one adapter
BOO$CONADP::				; 
BOO$CONAUNIT::				;
BOO$CONCNUM::				;
BOO$CONCREG::				;
BOO$CONCVEC::				;
BOO$CONDRVNAM::				;
BOO$CONNECT::				;
BOO$CONRESET::				;
BOO$CREATE::				;
BOO$DEVNAME::				;
BOO$FILESIZE::				;
BOO$INSRESET::				;
BOO$INSTALL::				;
BOO$LOAD::				;
BOO$MAKLIST::				;
BOO$RELOAD::				;
BOO$REMOVE::				;
BOO$RESETLIST::				;
BOO$SETADP::				;
BOO$SETFILNAM::				;
BOO$SETPGFL::				;
BOO$SETSFTX::				;
BOO$SHODEV_ALL::			;
BOO$SHODEV::				;
BOO$WRTFILE::
BOO$ADAPTER_NAME::
BOO$ADAP_LETTER::
BOO$RESET_ADAP::
BOO$RESET_COMMAND::
BOO$SHOW_ADAPTER::
BOO$SHOW_UNIBUS::
BOO$SET_OUTPUT::
BOO$CONSYSID_LOW::
BOO$CONSYSID_HIGH::

	.WORD	0		; Null entry mask
	CLRL	R0			;
	RET				;

	.ENDC	; End of SYSBOOT conditional code

	.END				;
