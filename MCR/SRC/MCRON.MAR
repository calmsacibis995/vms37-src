	.TITLE	MCRON - ON ERROR MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 20-MAY-77
;
; Modified by:
;
;
;	V001	MAJ0001		Melanie Johnson	4-Jan-82
;		Use WRK_L_MARKPTR(FP) rather than R6 to mark buffer position
;		for error reporting.
;
;		Implement .ONERR as ON WARNING THEN GOTO
;
; ON ERROR MCR COMMAND EXECUTION
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
 
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
LEVELTBL:				;SEVERIY LEVEL TABLE
	.ASCII	<2>/ERRO/		;ERROR
	.ASCII	<4>/SEVE/		;SEVERE ERROR
	.ASCII	<0>/WARN/		;WARNING
LEVELEND:				;
	.PAGE
	.SBTTL	ON ERROR
;+
; MCR$ON - ON ERROR
;
; MCR$ONERR - .ONERR
; THIS ROUTINE IS CALLED AS  AN INTERNAL COMMAND TO EXECUTE THE ON MCR COMMAND.
;
; INPUTS:
;
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE ON CLAUSE IS PARSED AND THE CORRESPONDING ERROR LEVEL IS COMPUTED.
;	STORAGE IS ALLOCATED FOR THE THEN CLAUSE AND IT IS COPIED FOR SUBSEQUENT
;	REFERENCE WHEN AN ON CONDITION ACTUALLY EXISTS.
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO ESTABLISH ON CONDITION PARAMETERS.
;
;		R0 = MCR$_ONERR - INVALID ERROR LEVEL SPECIFIED.
;		R0 = MCR$_ONLEVL - ON CONDITION CAN NOT BE ESTABLISHED AT CURRENT
;			COMMAND LEVEL.
;		R0 = MCR$ONOVF - NO ROOM FOR ON CONDITION COMMAND TEXT.
;		R0 = MCR$_PARMDEL - INVALID PARAMETER DELIMITER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$NORMAL - NORMAL COMPLETION.
;-
 
	.ENABL	LSB
;
MCR$ONERR::
	SETBIT	WRK_V_ONERR,WRK_W_FLAGS(FP) ; Mark as .ONERR
	BSBW	MCR$MARK		; Save command buffer backup parameter
	CLRL	R10			; Error level is WARNING
	BRB	55$
;
MCR$ON::				;ON ERROR
	CLRBIT	WRK_V_ONERR,WRK_W_FLAGS(FP) ; Mark as ON severity THEN
	BSBW	MCR$MARK		;SAVE COMMAND BUFFER BACKUP PARAMETER
	SETCHAR				;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BSBW	90$			;CHECK FOR BLANK TERMINATOR
	BSBW	80$			;MOVE TERMINATOR, GET TOKEN, AND CHECK
	CMPL	#4,R1			;ERROR LEVEL LONGER THAN 4 CHARACTERS
	BGEQ	10$			;IF GEQ NO
	MOVL	#4,R1			;SET LENGTH OF ERROR LEVEL TO 4
10$:	MOVAB	LEVELTBL,R5		;GET ADDRESS OF ERROR LEVEL NAME TABLE
	MOVL	#<LEVELEND-LEVELTBL>/5,R7 ;SET LOOP COUNT
20$:	MOVQ	R1,R3			;COPY ERROR LEVEL NAME PARAMETERS
	MOVZBL	(R5)+,R10		;SAVE ERROR LEVEL NUMBER
	MOVL	R5,R0			;SET ADDRESS OF ERROR LEVEL NAME
	TSTL	(R5)+			;POINT TO NEXT ENTRY IN TABLE
30$:	CMPB	(R0)+,(R4)+		;CHARACTERS MATCH?
	BNEQ	40$			;IF NEQ NO
	SOBGTR	R3,30$			;ANY MORE CHARACTERS TO COMPARE?
	BRB	50$			;
40$:	SOBGTR	R7,20$			;ANY MORE ENTRIES TO COMPARE?
	STATUS	ONERR			;SET INVALID ERROR LEVEL SPECIFIED STATUS
	RSB				;
 
;
; LEGAL ERROR LEVEL - PARSE THEN CLAUSE
;
 
50$:	BSBW	MCR$MARK		;SAVE COMMAND BUFFER BACKUP PARAMETER
	BSBB	80$			;MOVE TERMINATOR, GET TOKEN, AND CHECK
55$:
	MOVAB	1(R9),WRK_L_MARKPTR(FP)	;SET ADDRESS OF START OF THEN CLAUSE
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) ;DISABLE "@" FILE RECOGNITION
60$:	MOVCHAR				;MOVE CHARACTER TO COMMAND BUFFER
	BNEQ	60$			;IF NEQ MORE TO GO
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;ENABLE "@" FILE RECOGNITION
	SUBL	WRK_L_MARKPTR(FP),R9	;CALCULATE LENGTH OF THEN CLAUSE
	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(FP) ;SET COMMAND IN PROGRESS
	BBC	#WRK_V_ONERR, -		; Branch if not a .ONERR
		WRK_W_FLAGS(FP),65$
	ADDL2	#6,R9			; Include size of '.GOTO '
65$:
	CMPB	#INPBUFSIZ,R9		;ON COMMAND TEXT TOO LARGE FOR INPUT BUFFER?
	BLSSU	130$			;IF LSSU YES
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),70$ ;IF SET, NONINTERACTIVE JOB
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL NONZERO?
	BEQL	110$			;IF EQL NO
70$:	DISABLE				;DISABLE CONTROL Y/C AST'S
	CLRQ	(SP)+			;REMOVE RETURN INFORMATION FROM STACK
	BSBB	MCR$ONRESET		;RESET ON ERROR PARAMETERS
	ADDL3	#8,R9,R1		;ADD BYTE FOR LENGTH AND ROUND TO QUADWORD
	BSBW	MCR$ALLDYNMEM		;ALLOCATE THE MEMORY
	BLBC	R0,120$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,PRC_L_ONERROR(R11)	;SAVE ADDRESS OF ON ERROR TEXT BUFFER
	MOVB	R1,(R2)+		;SAVE LENGTH OF ON TEXT BUFFER
	BBC	#WRK_V_ONERR, -		; Branch if not a .ONERR
		WRK_W_FLAGS(FP),75$
	MOVL	#^A/.GOT/,(R2)+		; Copy '.GOTO ' into text buffer
	MOVW	#^A/O /,(R2)+
	SUBL	#6,R9			; Remove size of '.GOTO '
75$:
	MOVC	R9,@WRK_L_MARKPTR(FP),(R2) ;MOVE TEXT TO ON ERROR BUFFER
	MOVW	R10,PRC_W_ONLEVEL(R11)	;SAVE ON ERROR LEVEL
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;
 
;
; MOVE TERMINATOR, GET TOKEN, AND CHECK FOR BLANK TERMINATOR
;
 
80$:	MOVTOKN				;MOVE TERMINATOR AND GET TOKEN
90$:	CMPB	#^A/ /,R0		;BLANK TERMINATOR?
	BNEQ	100$			;IF NEQ NO
	RSB				;
100$:	TSTL	(SP)+			;CLEAN STACK
	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER
	RSB				;
 
;
; INVALID ON CONDITION LEVEL
;
 
110$:	STATUS	ONLEVL			;SET INVALID ON CONDITION LEVEL STATUS
	RSB				;
 
;
; NO ROOM TO ALLOCATE ON COMMAND TEXT
;
 
120$:	STATUS	ONOVF			;SET NO ROOM FOR COMMAND TEXT STATUS
	RSB				;
 
;
; ON COMMAND TEXT TOO LARGE FOR INPUT BUFFER
;
 
130$:	STATUS	ONCOMD			;SET ON COMMAND TO COMPLEX STATUS
	RSB				;
;
	.DSABL	LSB
	.PAGE
	.SBTTL	RESET ON ERROR PARAMETERS
;+
; MCR$ONRESET - RESET ON ERROR PARAMETERS
;
; THIS ROUTINE IS CALLED TO RESET THE ON ERROR PARAMETERS TO THEIR DEFAULT
; VALUES.
;
; INPUTS:
;
;	NONE.
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED.
;
; OUTPUTS:
;
;	IF AN ON ERROR COMMAND BUFFER IS CURRENTLY ALLOCATED, THEN IT IS RETURNED
;	TO THE DYNAMIC STORAGE REGION. THE ON ERROR LEVEL IS SET TO 'ERROR' AND
;	THE ON ERROR COMMAND TEXT POINTER IS CLEARED.
;-
 
MCR$ONRESET::				;RESET ON ERROR PARAMETERS
	MOVL	PRC_L_ONERROR(R11),R0	;GET ADDRESS OF ON ERROR COMMAND TEXT
	BEQL	10$			;IF EQL NONE
	MOVZBL	(R0),R1			;GET LENGTH OF ON ERROR COMMAND TEXT
	BSBW	MCR$DEADYNMEM		;DEALLOCTE THE MEMORY
10$:	CLRL	PRC_L_ONERROR(R11)	;CLEAR ADDRESS OF ON ERROR TEXT
	MOVW	#2,PRC_W_ONLEVEL(R11)	;RESET ON ERROR LEVEL TO ERROR
	RSB				;
 
	.END
