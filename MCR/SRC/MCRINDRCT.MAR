	.TITLE	MCRINDRCT - INDIRECT FILE MANIPULATION ROUTINES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 2-MAY-77
;
; INDIRECT FILE MANIPULATION ROUTINES
;
; MODIFIED BY:
;
;	V3.001	MAJ0002		Melanie Johnson	08-Apr-1982
;		The fixup for R10 (relocation to go with new WRK block)
;		was mimicing the fixup for R9 and as a result, both were
;		wrong.  Corrected this.  Also, set R8=0 before calling PROCFILE
;		to indicate not in regular parsing - not device only.
;		Initialize $STATUS and $SEVERITY to 1 before setting up the
;		context of a new indirect file level in MCR$STACKIND.
;
;	V003	RAS0074		Ron Schaefer	 2-Mar-1982
;		Preserve concealed device name for indirect PPF files.
;
;	V002	MAJ0001		Melanie Johnson	30-Dec-81
;		Use WRK_L_MARKPTR(FP) for the command buffer display
;		pointer instead of R6
;
;	V001	TMH0001		Tim Halvorsen	01-Jun-1981
;		Break into several routines so that CLI initialization
;		can stack procedures using these subroutines.
;---
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFCMDBLK			;DEFINE COMMAND BLOCK OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	DEFSYMTBL			;DEFINE SYMBOL TABLE OFFSET AND VALUES
	IDFDEF				;DEFINE INDIRECT FRAME OFFSETS
	PRDDEF				;PROCESS RMS DATA
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$FABDEF				;DEFINE FAB OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$NAMDEF				;DEFINE NAM OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
 
;
; LOCAL SYMBOLS
;
 
SYMBOLS=8				;MAXIMUM NUMBER OF INDIRECT FILE SYMBOLS
 
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
INPFILE:				;INPUT FILE DEFAULT NAME STRING
	.ASCII	/.CMD/			;
INPUTNAM:				;'INPUT' LOGICAL NAME TEXT
	.ASCII	<9>/SYS$INPUT/		;
OUTFILE:				;OUTPUT FILE DEFAULT NAME STRING
	.ASCII	/.LIS/			;
OUTPUTNAM:				;'OUTPUT' LOGICAL NAME TEXT
	.ASCII	<10>/SYS$OUTPUT/	;
COMMAN:					; COMMAN symbol name
	.ASCIC	/COMMAN/

	.SBTTL	CHAIN TO NEXT INDIRECT FILE
;+
; MCR$CHAIN - CHAIN TO NEXT INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO UNSTACK THE CURRENT INDIRECT LEVEL, THEN STACK
; THE NEW AND PROCEED WITH THE EXECUTION OF THE NEW FILE AT SAME INDIRECT
; LEVEL AS WHEN ENTERED.
;
; INPUTS:
;
;	THE INPUT FILE SPEC IS NEXT ON THE COMMAND LINE.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE SPECIFICATION IS CLEARED FORM THE INDIRECT
;	FILE STACK AND THE NEXT INDIRECT FILE IS PROCESSED.
;
;	R0 LOW BIT CLEAR INDICATES INDIRECT FILE PROCESSING FAILURE.
;
;		R0 = MCR$_ATLAST - INDIRECT FILE SPECIFICATION NOT LAST ITEM ON
;			COMMAND LINE.
;		R0 = MCR$_DEFOVF - ATTEMPT TO DEFINE MORE THAN EIGHT PARAMETERS.
;		R0 = MCR$_IVINDF - INDIRECT FILES NOT ALLOWED AT CONTROL Y LEVEL.
;		R0 = MCR$_STKOVF - INDIRECT FILE INTERNAL STACK OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
MCR$CHAIN::				; CHAIN TO NEXT INDIRECT FILE
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ; INDIRECT LEVEL ZERO
	BEQL	10$			; BR IF YES - DO NOT UNSTACK
	DISABLE				; DISABLE CONTROL Y/C AST'S
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,AP> ; SAVE REGISTERS
	BSBW	UNSTACK			; REMOVE ONE LEVEL OF INDIRECT
	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,AP> ; RESTORE SAVED REGISTERS
	ENABLE				; ALLOW AST'S
10$:	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ; FLAG PROCESSING INDIRECT FILE
	STACKIND			; STACK THE NEXT
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ; RESET THE FLAG
	BLBC	R0,20$			; BR IF OPEN WORKED OK
	BRW	MCR$RESTART		; PROCESS THE NEW COMMAND FILE
20$:	RSB				; RETURN WITH ERROR

	.SBTTL	STACK INDIRECT FILE
;+
; MCR$STACKIND - STACK INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO STACK THE CURRENT INDIRECT FILE LEVEL AND TO PARSE
; AND OPEN THE NEXT INDIRECT FILE.
;
; INPUTS:
;
;	IT IS ASSUMED THAT THE INDIRECT FILE PROCESSING FLAG IS SET.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE SPECIFICATION IS SAVED ON THE INDIRECT FILE
;	STACK AND THE NEXT INDIRECT FILE IS PROCESSED.
;
;	R0 LOW BIT CLEAR INDICATES INDIRECT FILE PROCESSING FAILURE.
;
;		R0 = MCR$_ATLAST - INDIRECT FILE SPECIFICATION NOT LAST ITEM ON
;			COMMAND LINE.
;		R0 = MCR$_DEFOVF - ATTEMPT TO DEFINE MORE THAN EIGHT PARAMETERS.
;		R0 = MCR$_STKOVF - INDIRECT FILE INTERNAL STACK OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
 
MCR$STACKIND::				;STACK INDIRECT FILE
	BSBW	SETIND			;SETUP INDIRECT FILE PROCESSING
	CLRBIT	CMD_V_NOSTAT,WRK_B_CMDFLG(FP) ;ALLOW STATUS TO BE SET
	MOVZWL	#SS$_NORMAL,R0		;INITIALIZE STATUS TO SUCCESS
	BSBW	MCR$SET_STATUS		;TO PREVENT SPURIOUS .ONERR PROBLEMS
	MOVAB	-<<SYMBOLS+3>*8>(SP),SP	; Allocate space for 10 symbol descriptors
	CLRL	-(SP)			;CLEAR COUNT OF GENERATED SYMBOLS
	DECL	WRK_L_CHARPTR(FP)	;BACK UP TO AT SIGN
10$:	BSBW	MCR$MARK		;SAVE DISPLAY PARAMETER
	CLRL	R8			;SET FLAG TO INDICATE NOT DEVICE ONLY
	PROCFILE			;PROCESS FILE SPECIFICATION
	BLBC	R0,29$			;IF LBC PARSE FAILURE
	TSTL	(SP)			; Has file name descriptor been saved?
	BNEQ	15$			; Yes if NEQ, this is /OUTPUT file name
	BSBW	MCR$MARKEDTOKEN		; Calculate size of file name
	DECL	R1			; and store in R1
	ADDL	#1,R2			; Form address of file name
	MOVAB	4(SP),R8		; Set symbol descriptor storage address
	MOVQ	R1,(R8)+		; Store P0 value
	INCL	(SP)			; and increment count
15$:	SETCHAR				;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;SLASH?
	BNEQ	30$			;IF NEQ NO
	MOVTOKN				;MOVE TERMINATOR AND GET NEXT TOKEN
	CMPB	(R2),#^A/D/		;IS QUALIFIER DELETE?
	BEQL	22$			;BR IF YES
	CMPB	(R2),#^A/O/		;HOW ABOUT OUTPUT?
	BNEQ	28$			;BR IF UNRECOGNIZED
	CMPB	#^A/=/,R0		;EQUAL SIGN TERMINATOR?
	BEQL	10$			;IF EQL YES
	CMPB	#^A/:/,R0		;COLON TERMINATOR?
	BEQL	10$			;IF EQL YES
	STATUS	IVVALU			;SET INVALID VALUE SYNTAX
20$:	BRB	29$			;
22$:	SETBIT	#15,WRK_W_LOCFLG(FP)	;REMEMBER DELETE OPTION
	BRB	15$			;SCAN FOR ANOTHER OPTION
28$:	STATUS	IVKEYW			;UNRECOGNIZED QUALIFIER
29$:	ERRMSG				;PRINT ERROR MESSAGE AND EXIT
	BRW	INDXIT
 
;
; FILE SPECIFICATIONS PARSED - PARSE SYMBOL DEFINITIONS
;
 
30$:	MOVL	R9,R2			;MARK START OF PARAMETER STRING
	MOVCHAR				;LOOK AT PRECEEDING TERMINATOR
	BEQL	RAISE			;BR IF END OF LINE IS THE FIRST BYTE
	CMPB	#^A/ /,R0		;WAS IT A BLANK
	BNEQ	50$			;BR IF NO-IT COUNTS IN THE STRING
	INCL	R2			;ADJ POINTER OVER THE SPACE
50$:	MOVCHAR				;COPY A CHARACTER FROM INPUT BUUFER
	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(FP),50$ ;LOOP IF IN A QUOTED STRING
	BEQL	60$			;BR IF END OF LINE
	CMPB	#^A/ /,R0		;IS THIS A TERMINATOR
	BNEQ	50$			;BR IF NO - KEEP LOOKING FOR TERMINATOR
60$:	SUBL3	R2,R9,R1		;FIND LENGTH OF SYMBOL
	DECL	R1			;REMOVE COUNT FOR TERMINATOR
	BEQL	RAISE			;IF NULL STRING - NO MORE SYMBOLS
	CMPB	#^A/"/,(R2)		;SYMBOL START WITH A QUOTE
	BNEQ	70$			;IF NO - LEAVE THE SYMBOL ALONE
	BSBW	MCR$COMPRESS		;ELSE REMOVE THE QUOTE PAIRS
70$:	MOVQ	R1,(R8)+		;STORE SYMBOL DESCRIPTOR
	MOVL	R9,R2			;SET START OF NEXT SYMBOL
	AOBLEQ	#SYMBOLS,(SP),50$	; Any more normal symbol definitions?
75$:
	MOVCHAR				; Remaining characters form P9
	BNEQ	75$			; Get characters until end of line
	SUBL3	R2,R9,R1		; Compute length of characters
	MOVQ	R1,(R8)+		; Store descriptor
	INCL	(SP)			; and increment count

;
; RUN DOWN ANY IMAGE CURRENTLY RUNNING
;
RAISE:	PUSHL	R10			;SAVE POINTER INTO COMMAND WORK AREA
	BSBW	MCR$RUNDOWN		;RUN DOWN IMAGE AND INDIRECT LEVELS
	BICW	#<PRC_M_PAUSE!PRC_M_YLEVEL>,- ;CLEAR PAUSE AND ^Y LEVEL
		PRC_W_FLAGS(R11)	; IN PROCESS FLAGS WORD
	SUBL3	(SP)+,WRK_L_RSLNXT(FP),R0 ;CALCULATE LENGTH OF MOVE
	ADDL	R0,<<<SYMBOLS+3>*8>+4+<8*4>>(SP) ; Relocate saved buffer pointer
	ADDL	R0,<<<SYMBOLS+3>*8>+4+<9*4>>(SP) ; Relocate saved descriptor pointer
1$:	REMQUE	@PRC_Q_LABEL(R11),R3	;REMOVE PREVIOUS LABEL TABLE ENTRY
	BVS	2$			;BR WHEN NO MORE
	DEALLOCSYM			;DEALLOCATE THE SYMBOL
	BRB	1$			;TRY AGAIN
;
; STACK COMMAND PROCEDUE
;
2$:	MOVL	<<<SYMBOLS+3>*8>+4+<9*4>>(SP),R10 ;RETRIEVE PTR TO NEXT TOKEN
	GETDVAL				;GET INPUT FILESPEC DESCRIPTOR
	MOVQ	R1,-(SP)		;SAVE INPUT FILESPEC
	CLRL	R4			;ASSUME NO OUTPUT FILE
	GETDVAL				;GET OUTPUT FILESPEC DESCRIPTOR
	BLBC	R0,65$			;IF NONE, PASS IN NULL FILESPEC
	MOVQ	R1,R4			;SET OUTPUT FILESPEC ARGUMENT
65$:	MOVQ	(SP)+,R2		;SET INPUT FILESPEC ARGUMENT
	BSBW	MCR$PUSHPROC		;PUSH PROCEDURE ONTO INDIRECT STACK
	BLBC	R0,80$			;BRANCH IF ERROR DETECTED
;
; IF DELETE OPTION REQUESTED, MARK TO DELETE INPUT FILE ON CLOSE
;
	BBCC	#15,WRK_W_LOCFLG(FP),5$	;BR IF NO DELETE OPTION REQUESTED
	SETBIT	#MCR_V_DELINP,PRC_W_CLIFLAG(R11) ;MARK FILE FOR DELETE ON CLOSE
;
; CREATE SYMBOLS <COMMAN> AND P1-P8
;
5$:	MOVAB	(SP),R8			;GET ADDRESS OF NUMBER OF SYMBOL DEFINITIONS
	MOVL	(R8),R10		;GET NUMBER OF SYMBOL DEFINITIONS
	MOVAB	PRC_L_CLIWRK0(R11),R2	; Set address of 4 byte string buffer
	CLRL	R3			; Set for zero suppression
	MOVZBL	#8,R1			; Set for octal radix
	MOVL	R10,R0			; and supply the number
	BSBW	MCR$CNVNUM		; Convert length to ascii
	CLRB	(R2)+			; Mark end of number
	MOVZWL	#^A\P/\,(R8)+		; Set generated symbol prototype
	MOVL	#SYMBOLS+2,R7		; Max number of symbols to generate
	MOVQ	(R8),R1			; Get first descriptor
	LOCC	#0,#CMDBUFSIZ,(R2)	; Search for end of line
	SUBL2	R2,R1			; Compute length of string
	MOVAB	COMMAN,R4		; Get address of symbol name
	MOVZBL	(R4)+,R3		; and form descriptor
	MOVAB	PRC_Q_LOCAL(R11),R5	; Get local symbol listhead address
	ALLOCSYM			; Allocate symbol
	BLBC	R0,80$			; Error of LBC
50$:	CLRL	R1			;ASSUME NO MORE SYMBOLS DEFINED
	DECL	R10			;IS THERE ANY MORE TO DEFINE
	BLSS	60$			;BR IF NO - DEFINE AS NULL STRING
	MOVQ	(R8)+,R1		;GET VALUE DESCRIPTOR
60$:	INCB	1(SP)			;INCREMENT SYMBOL NUMBER
	MOVL	#2,R3			;SET LENGTH OF SYMBOL NAME
	MOVAB	(SP),R4			;SET ADDRESS OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;GET ADDRESS OF LOCAL SYMBOL TABLE LISTHEAD
	ALLOCSYM			;ALLOCATE AND INSERT SYMBOL TABLE ENTRY
	BLBC	R0,80$			;IF LBC ALLOCATION FAILURE
	SOBGTR	R7,50$			;ANY MORE SYMBOL TO PROCESS?
70$:	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	BRB	INDXIT			;
 
;
; OPEN, CONNECT, OR SYMBOL ALLOCATION FAILURE
;
 
80$:	ERRMSG				;OUTPUT ERROR MESSAGE

INDXIT:	MOVAB	<<SYMBOLS+3>*8>+4(SP),SP ; Deallocate symbol descriptor storage
	PUSHL	R0			;SAVE FINAL STATUS
	BRW	STKXIT			;

	.SBTTL	PUSH PROCEDURE ONTO INDIRECT STACK
;+
; MCR$PUSHPROC - PUSH PROCEDURE ONTO INDIRECT STACK
;
; THIS ROUTINE IS CALLED TO INITIALIZE A NEW INDIRECT FRAME
; ON THE INDIRECT PROCEDURE STACK.
;
; INPUTS:
;
;	R2/R3 = DESCRIPTOR OF INPUT FILESPEC
;	R4/R5 = DESCRIPTOR OF OUTPUT FILESPEC
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0 = STATUS (NOT SIGNALED)
;-

MCR$PUSHPROC::
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,AP>	;SAVE REGISTERS
	MOVL	PRC_L_STACKPT(R11),R6	;GET CURRENT INDIRECT STACK POINTER
	MOVAB	-IDF_K_LENGTH(R6),R8	;CALCULATE NEW INDIRECT STACK POINTER
	CMPL	R8,PRC_L_STACKLM(R11)	;INDIRECT STACK OVERFLOW?
	BGTRU	2$			;IF GTRU NO
	STATUS	STKOVF			;SET INDIRECT STACK OVERFLOW
80$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,AP> ;RESTORE REGISTERS
	RSB
;
; The new indirect file frame is formed on the stack and linked to
; previous frames.  Any incomplete .GOSUBs and .BEGINs from the current
; indirect file have left information on the stack which will be
; between the new and current indirect file frames.  The stack overflow
; check has already performed at this point
;
2$:	INCL	PRC_L_INDEPTH(R11)	;COUNT INDRECT LEVEL CHANGES
	MOVL	R8,PRC_L_STACKPT(R11)	; Set new stack pointer
	MOVL	PRC_L_IDFLNK(R11),R6	; Get address of current indirect frame
	MOVL	R6,IDF_L_LNK(R8)	; Link new frame into top of
	MOVAL	IDF_L_LNK(R8), -	; indirect file frame list
		PRC_L_IDFLNK(R11)
;
; R6 = Pointer to current stack frame
; R8 = Pointer to new stack frame
;
	MOVL	PRC_L_INDFAB(R11),AP	;GET ADDRESS OF INDIRECT FAB
	MOVW	PRC_W_CLIFLAG(R11),IDF_W_FLAG(R6) ;SAVE COMMAND LEVEL FLAGS
	MOVW	#MCR_M_LOWER,PRC_W_CLIFLAG(R11)	;SET FLAG TO DEFAULT STATE
	MOVQ	PRC_Q_LOCAL(R11),IDF_Q_LOCAL(R6) ;SAVE LOCAL SYMBOL TABLE LISTHEAD
	MOVQ	PRC_Q_LABEL(R11),IDF_Q_LABEL(R6) ;SAVE LABEL SYMBOL TABLE LISTHEAD
	MOVW	PRC_W_ONLEVEL(R11),IDF_W_ONLEVEL(R6) ;SAVE ON ERROR LEVEL NUMBER
	MOVL	PRC_L_ONERROR(R11),IDF_L_ONERROR(R6) ;SAVE ON ERROR COMMAND TEXT
	MOVL	PRC_L_SUBLNK(R11), - 	; Save subroutine frame list
		IDF_L_SUBLNK(R6)
	MOVL	PRC_L_BLKLNK(R11), -	; block list pointer,
		IDF_L_BLKLNK(R6)
	MOVB	PRC_B_NESTLEVEL(R11), -	; nesting level
		IDF_B_NESTLEVEL(R6)
	MOVL	PRC_W_BEGINRFA+0(R11), -; Begin position (3 words)
		IDF_W_BEGINRFA+0(R6)
	MOVW	PRC_W_BEGINRFA+4(R11), -
		IDF_W_BEGINRFA+4(R6)
	CLRL	PRC_L_SUBLNK(R11)	; Initialise subroutine and block lists
	CLRL	PRC_L_BLKLNK(R11)	; for a new indirect file
	MOVAB	PRC_Q_LABEL(R11),R0	;GET ADDRESS OF LABEL TABLE LISTHEAD
	MOVL	R0,(R0)			;SET ADDRESS OF LISTHEAD AS FORWARD LINK
	MOVL	(R0)+,(R0)+		;SET ADDRESS OF LISTHEAD AS BACKWARD LINK
	MOVL	R0,(R0)			;SET ADDRESS OF LISTHEAD AS FORWARD LINK
	MOVL	(R0)+,(R0)+		;SET ADDRESS OF LISTHEAD AS BACKWARD LINK
	CLRL	PRC_L_ONERROR(R11)	;CLEAR ADDRESS OF ON ERROR COMMAND TEXT
	MOVW	#2@8!8,PRC_W_ONLEVEL(R11) ;RESET ON ERROR LEVEL TO ERROR
;
; PROPAGATE THE OUTPUT STREAM TO THE NEW INDIRECT FRAME, SO THAT IN CASE
; NO OUTPUT FILESPEC IS SPECIFIED FOR THE NEW PROCEDURE, THE SAME OUTPUT
; FILE IS USED.
;
	ASSUME	IDF_W_OUTISI EQ IDF_W_OUTIFI+2
	MOVL	IDF_W_OUTIFI(R6),IDF_W_OUTIFI(R8) ;SAVE PREVIOUS INTERNAL FILE INDEX
	MOVL	IDF_L_OUTRABCTX(R6),IDF_L_OUTRABCTX(R8) ;SAME FOR RAB CONTEXT
	MOVC	#16,IDF_T_OUTDVI(R6),IDF_T_OUTDVI(R8) ;SAVE PREVIOUS DEVICE NAME
;
; CLOSE INPUT FILE FROM PREVIOUS INDIRECT LEVEL AND REMEMBER THE CURRENT
; POSITION IN THE FILE, SO THAT ON RETURN, WE CAN RESET THE POSITION.
;
	MOVL	PRC_L_INDINPRAB(R11),R0	;SET CURRENT INDIRECT RAB POINTER
	CMPL	R0,PRC_L_INPRAB(R11)	;IS THIS THE PRIMARY INPUT STREAM?
	BEQL	10$			;BR IF YES-THAT NEVER GETS CLOSED
	MOVC	#6,RAB$W_RFA(R0),IDF_W_INPRFA(R6) ;SAVE PLACE IN FILE
	SETBIT	MCR_V_OPNINP,IDF_W_FLAG(R6) ;MARK OPEN REQUIRED ON UNSTACK
	MOVW	IDF_W_INPIFI(R6),FAB$W_IFI(AP) ;SET INTERNAL FILE IDENTIFICATION
	$CLOSE	FAB=(AP)		;
;
; OPEN INPUT PROCEDURE FILE
;
10$:	MNEGW	#1,IDF_W_INPIFI(R8)	;SET ILLEGAL INPUT FILE INTERNAL INDEX
	MOVQ	4(SP),R1		;GET INPUT FILESPEC (R2/R3 ON ENTRY)
	MOVB	R1,FAB$B_FNS(AP)	;SET SIZE OF FILE NAME STRING
	MOVL	R2,FAB$L_FNA(AP)	;SET ADDRESS OF FILE NAME STRING
	MOVB	#4,FAB$B_DNS(AP)	;SET SIZE OF DEFAULT NAME STRING
	MOVAB	INPFILE,FAB$L_DNA(AP)	;SET ADDRESS OF DEFAULT NAME STRING
	MOVB	#FAB$M_GET,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVL	#FAB$M_INP!FAB$M_PPF!-	;SET FILE OPEN OPTIONS
		FAB$M_SQO,FAB$L_FOP(AP)	;
	CLRW	FAB$W_IFI(AP)		;CLEAR INTERNAL FILE INDEX
	$OPEN	FAB=(AP)		;OPEN INDIRECT INPUT FILE
	BLBC	R0,20$			;IF LBC OPEN FAILURE
	MOVL	FAB$L_NAM(AP),R7	;GET ADDRESS OF INDIRECT NAME BLOCK
	MOVW	FAB$W_IFI(AP),IDF_W_INPIFI(R8) ;SAVE INPUT FILE INTERNAL INDEX
	MOVAB	PRD_G_ALTINPRAB(AP),R6	;GET ALTERNATE INPUT RAB
	MOVL	FAB$L_DEV(AP),RAB$L_CTX(R6) ;SAVE DEVICE CHARACTERISTICS
	MOVL	RAB$L_CTX(R6),IDF_L_INPRABCTX(R8) ;AND A COPY IN THE STACK FRAME
	BBC	#NAM$V_CNCL_DEV,-	;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),15$
	MOVZBL	NAM$T_DVI(R7),R0	;GET LENGTH OF DEVICE NAME
	CMPB	R0,#<NAM$C_DVI-2>	;IS THERE ROOM FOR EXTRA "_"?
	BGTRU	15$			;IF GTRU, THEN NO	
	MOVC	R0,NAM$T_DVI+1(R7),-	;SHIFT STRING OVER ONE CHARACTER
		NAM$T_DVI+2(R7)
	INCB	NAM$T_DVI(R7)		;INCREMENT THE LENGTH
15$:	MOVC	#28,NAM$T_DVI(R7),-	;COPY DEVICE,FILE AND DIRECTORY ID'S
		IDF_T_INPDVI(R8)	;INTO INDIRECT STACK FRAME
	MOVL	AP,RAB$L_FAB(R6)	;LINK FAB TO RAB
	$CONNECT RAB=(R6)		;CONNECT TO NEW INPUT
20$:	BLBC	R0,30$			;IF LBC CONNECT FAILURE
	CLRBIT	RAB$M_PPF_IND,RAB$W_ISI(R6) ;MAKE SURE INDIRECT FLAG IS CLEAR
	MOVL	R6,PRC_L_INDINPRAB(R11)	;SET INDIRECT INPUT RAB
;
; CREATE OUTPUT FILE, IF SPECIFIED
;
	MOVQ	12(SP),R1		;GET OUTPUT FILESPEC (R4/R5 ON ENTRY)
	TSTL	R1			;OUTPUT FILE SPECIFIED?
	BNEQ	22$
	BRW	40$			;BRANCH IF NOT
22$:	MOVB	R1,FAB$B_FNS(AP)	;SET SIZE OF FILENAME STRING
	MOVL	R2,FAB$L_FNA(AP)	;SET ADDRESS OF FILE NAME STRING
	MOVAB	OUTFILE,FAB$L_DNA(AP)	;SET ADDRESS OF DEFAULT NAME STRING
	MOVB	#FAB$M_PUT,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVL	#FAB$M_PPF!FAB$M_SQO,FAB$L_FOP(AP) ;SET FILE OPEN OPTIONS
	MOVB	#FAB$C_SEQ,FAB$B_ORG(AP) ;SET FILE ORGANIZATION TYPE
	MOVB	#FAB$M_PRN,FAB$B_RAT(AP) ;SET RECORD ATTRIBUTE TYPE TO PRINT
	MOVB	#FAB$C_VFC,FAB$B_RFM(AP) ;SET RECORD FORMAT TYPE-FIXED CONTROL
	CLRW	FAB$W_IFI(AP)		;CLEAR INTERNAL FILE INDEX
	$CREATE	FAB=(AP)		;CREATE NEW OUTPUT FILE
	BLBC	R0,30$			;IF LBC CREATION FAILURE
	MOVW	FAB$W_IFI(AP),IDF_W_OUTIFI(R8) ;SAVE OUTPUT FILE INTERNAL INDEX
	MOVAB	PRD_G_ALTOUTRAB(AP),R2	;GET ALTERNATE OUTPUT RAB ADDRESS
	MOVL	FAB$L_DEV(AP),RAB$L_CTX(R2) ;SAVE DEVICE CHARACTERISTICS HERE
	MOVL	RAB$L_CTX(R2),IDF_L_OUTRABCTX(R8) ;AND HERE AS WELL
	MOVAB	(R2),PRC_L_INDOUTRAB(R11) ;SET ADDRESS OF OUTPUT RAB
	CLRW	RAB$W_ISI(R2) 		;CLEAR INTERNAL STREAM INDEX
	MOVL	AP,RAB$L_FAB(R2)	;LINK FAB TO RAB
	$CONNECT RAB=(R2)		;CONNECT TO OUTPUT
30$:	BLBC	R0,50$			;IF LBS CONNECT FAILURE
	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,- ;SET TO USE IMPLIED
		#RAB$S_PPF_RAT,RAB$W_ISI(R2) ;CR/LF FOR OUTPUT
	MOVW	RAB$W_ISI(R2),IDF_W_OUTISI(R8) ;COPY OUTPUT ISI TO STACK FRAME
	BBC	#NAM$V_CNCL_DEV,-	;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),18$
	MOVZBL	NAM$T_DVI(R7),R0	;GET LENGTH OF DEVICE NAME
	CMPB	R0,#<NAM$C_DVI-2>	;IS THERE ROOM FOR EXTRA "_"?
	BGTRU	18$			;IF GTRU, THEN NO	
	MOVC	R0,NAM$T_DVI+1(R7),-	;SHIFT STRING OVER ONE CHARACTER
		NAM$T_DVI+2(R7)
	INCB	NAM$T_DVI(R7)		;INCREMENT THE LENGTH
18$:	MOVC	#16,NAM$T_DVI(R7),IDF_T_OUTDVI(R8) ;SAVE DEVICE IDENTIFICATION
40$:	BSBW	CREATE			;CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
	STATUS	NORMAL			;EXIT WITH SUCCESS
	BRW	80$

;
; OPEN OR CONNECT FAILURE
;

50$:	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	BSBW	UNSTACK			;UNSTACK INDIRECT LEVEL
	POPL	R0			;RESTORE ERROR STATUS
	BRW	80$			;EXIT WITH ERROR

	.SBTTL	UNSTACK INDIRECT FILE SPECIFICATION
;+
; MCR$UNSTACK - UNSTACK INDIRECT FILE SPECIFICATION
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT INDIRECT FILE AND TO UNSTACK THE
; PREVIOUS SPECIFICATION. ALSO, ANY DATA FILES THAT ARE OPEN ARE CLOSED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE IS CLOSED AND ALL LOCAL SYMBOLS FOR THE LEVEL
;	ARE DEALLOCATED. THE PREVIOUS INDIRECT FILE IS THEN UNSTACKED AND REOPENED.
;
;	R0 LOW BIT CLEAR INDICATES UNSUCCESSFUL COMPLETION.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
 
MCR$UNSTACK::				;UNSTACK INDIRECT FILE SPECIFICATION
	BSBB	SETIND			;SETUP INDIRECT FILE PROCESSING
	PUSHL	#SS$_NORMAL		;ASSUME NORMAL COMPLETION
	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),10$ ;IF CLR, NO GOTO IN PROGRESS
	CLRBIT	PRC_V_GOEOF,PRC_W_FLAGS(R11) ; REMOVE RESIDUAL FLAG IF PRESENT
	BSBW	MCR$DEALGOTO		;DEALLOCATE THE SPACE
	STATUS	USGOTO			;SET UNSATISFIED GOTO STATUS
	MOVL	R0,(SP)			;SET COMPLETION STATUS
	ERRMSG				;OUTPUT ERROR MESSAGE
10$:	BSBB	UNSTACK			;UNSTACK NEXT INDIRECT FILE
	BBS	#PRC_V_MODE, -		;BRANCH IF NOT INTERACTIVE
		PRC_W_FLAGS(R11),STKXIT	; (I.E. BATCH) JOB
	CMPL	PRC_L_INDINPRAB(R11),-	;IS CURRENT INDIRECT LEVEL
		PRC_L_INPRAB(R11)	;EQUAL LEVEL 0?
	BNEQ	STKXIT			;BR IF NO
	MOVAL	PRC_L_CLIWRK4+4(R11),R7	;POINT AT LAST DATA FILE SLOT
	MOVL	#4,R8			;SET NUMBER OF FILES TO CHECK
20$:	TSTL	-(R7)			;FILE OPEN?
	BEQL	30$			;BR IF NO
	BSBW	MCR$CLSFIL		;CLOSE THE FILE IF OPEN
30$:	SOBGTR	R8,20$			;CHECK ALL FILES?
	MOVAQ	PRC_Q_GLOBAL(R11),R4	;GET START OF GLOBAL SYMBOL TABLE
	MOVL	R4,R5			;MAKE A COPY
40$:	MOVL	(R4),R3			;GET NEXT ENTRY
	CMPL	R3,R5			;GET BACK TO THE BEGINNING
	BEQL	60$			;BR IF YES
	CMPB	SYM_B_TYPE(R3),#SYM_K_PERM ;PERMANENT SYMBOL?
	BNEQ	50$			;BR IF NO
	MOVL	R3,R4			;SET CURRENT AS PREVIOUS
	BRB	40$			;DEALLOCATE NEXT
50$:	REMQUE	(R3),R3			;REMOVE ITEM FROM THE LIST
	DEALLOCSYM			;DEALLOCATE THE SYMBOL
	BRB	40$			;
60$:					;REFERENCE
STKXIT:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,AP> ;RESTORE REGISTERS
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BBS	#WRK_V_COMMAND,R1,10$	;BR IF COMMAND WAS SET ON ENTRY
	BICW	#WRK_M_COMMAND,WRK_W_FLAGS(FP) ;CLEAR COMMAND IN PROGRESS
10$:	RSB				;
 
SETIND:	POPR	#^M<R0>			;GET RETURN OUT OF STACK
	DISABLE				;DISABLE CONTROL Y/C AST'S
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,AP> ;SAVE REGISTERS
	PUSHL	WRK_W_FLAGS(FP)		;SAVE PREVIOUS FLAGS
	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(FP) ;SET COMMAND IN PROGRESS
	JMP	(R0)			;RETURN

	.SBTTL	UNSTACK NEXT INDIRECT FILE
;
; UNSTACK - UNSTACK NEXT INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT INDIRECT FILE AND UNSTACK THE
; CONTEXT INFORMATION FOR THE PREVIOUS LEVEL INDIRECT FILE.
;
; Any block or subroutine frames created by the current indirect file
; will be removed when the stackpointer is moved back to the previous
; indirect file frame.  The previous block context is restored by the
; action of deleting all local symbols and labels, and by reseting the
; nesting level from the value stored in the previous indirect frame.  It
; is not necessary to remove nested blocks on a block by block basis.
 
UNSTACK:				;UNSTACK INDIRECT FILE
	MOVL	PRC_L_INDFAB(R11),AP	;GET ADDRESS OF INDIRECT FAB
	MOVL	PRC_L_IDFLNK(R11),R8	; Get address of current indirect frame
	MOVL	IDF_L_LNK(R8),R6	; and previous indirect frame
	MOVW	IDF_W_INPIFI(R8),FAB$W_IFI(AP) ; Restore internal file index
	BBC	#MCR_V_DELINP,PRC_W_CLIFLAG(R11),15$ ;BR IF NO DELETE REQUESTED
	MOVL	FAB$L_NAM(AP),R7	;GET THE NAME BLOCK
	MOVC	#28,IDF_T_INPDVI(R8),-	;COPY INPUT FILE, DIRECTORY AND DEVICE
		NAM$T_DVI(R7)		;ID'S INTO NAME BLOCK FIELDS
	BISL	#<FAB$M_DLT!FAB$M_NAM>,-;MARK FILE FOR DELETE BY NAME BLOCK
		FAB$L_FOP(AP)		;WHEN CLOSED BY RMS
15$:	$CLOSE	FAB=(AP)		;CLOSE INDIRECT INPUT FILE
	CLRL	FAB$L_FOP(AP)		;REMOVE DELETE BIT FOR SURE
	CMPW	IDF_W_OUTIFI(R8),-	;SEE IF THE OUTPUT FILE CHANGED
		IDF_W_OUTIFI(R6)	; FROM PREVIOUS COMMAND LEVEL
	BEQL	20$			;BR IF NO
	MOVW	IDF_W_OUTIFI(R8),FAB$W_IFI(AP) ;RESTORE INTERNAL FILE INDEX
	$CLOSE	FAB=(AP)		;CLOSE INDIRECT OUTPUT FILE
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET POINTER TO INDIRECT OUTPUT RAB
	MOVW	IDF_W_OUTISI(R6), -	; GET ISI FROM PREVIOUS OUTPUT
		RAB$W_ISI(R0)		;AND SET INTO RAB
	MOVL	IDF_L_OUTRABCTX(R6), -	; RESTORE STACKED CONTEXT
		RAB$L_CTX(R0)		;VALUE FROM PREVIOUS STACK FRAME
	MOVL	PRC_L_OUTRAB(R11),R1	;GET DIRECT OUTPUT RAB
	CMPW	RAB$W_ISI(R0),RAB$W_ISI(R1) ;IS OUTPUT NESTED AT ALL?
	BNEQ	20$			;BR IF YES
	MOVL	R1,PRC_L_INDOUTRAB(R11)	;SET INDIRECT OUTPUT AND OUTPUT THE SAME
20$:	REMQUE	@PRC_Q_LOCAL(R11),R3	;REMOVE NEXT ENTRY FROM LOCAL SYMBOL TABLE
	BVC	30$			;IF VC ENTRY REMOVED
	REMQUE	@PRC_Q_LABEL(R11),R3	;REMOVE NEXT ENTRY FROM LOCAL LABEL TABLE
	BVS	40$			;IF VS TABLE EMPTY
30$:	DEALLOCSYM			;DEALLOCATE SYMBOL ENTRY
	BRB	20$			;
40$:	ONRESET				;RESET ON ERROR PARAMETERS
	MOVL	R6,PRC_L_IDFLNK(R11)	; Unlink frame from indirect list
	MOVAB	IDF_K_LENGTH(R8), -	; Remove current indirect frame from
		PRC_L_STACKPT(R11)	; stack and reset stack pointer
	MOVL	R6,R8			; Point to previous indirect frame
	MOVW	IDF_W_FLAG(R8),PRC_W_CLIFLAG(R11) ;RESET COMMAND FLAGS
	MOVL	PRC_L_INPRAB(R11),-	;ASSUME RETURNING TO LEVEL ZERO AND-
		PRC_L_INDINPRAB(R11)	;SET INPUT AS INDIRECT INPUT ALSO
	BBC	#MCR_V_OPNINP,IDF_W_FLAG(R8),50$ ;BR IF GOING TO LEVEL 0
	MOVAB	PRD_G_ALTINPRAB(AP),R6	;GET THE ALTERNATE INPUT RAB
	MOVL	R6,PRC_L_INDINPRAB(R11)	;SET THAT IS INDIRECT INPUT RAB
	MOVL	IDF_L_INPRABCTX(R8),-	;RESTORE STACKED DEVICE CHARACTERISTICS-
		RAB$L_CTX(R6)		;VALUE FROM STACK FRAME
	MOVL	FAB$L_NAM(AP),R7	;ADDRESS OF NAME BLOCK
	MOVC	#28,IDF_T_INPDVI(R8),-	;COPY PREVIOUS INPUT DEVICE,FILE AND-
		NAM$T_DVI(R7)		;DIRECTORY ID'S INTO NAME BLOCK
	MOVB	#FAB$M_GET,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVL	#FAB$M_INP!FAB$M_PPF!-	;SET FILE OPEN OPTIONS
		FAB$M_NAM!FAB$M_SQO,FAB$L_FOP(AP) ;
	CLRW	FAB$W_IFI(AP)		;MAKE SURE PREVIOUS CLOSE WORKED
	CLRB	FAB$B_FNS(AP)		;REMOVE ANY RESIDUAL FILE NAME
	$OPEN	FAB=(AP)		;OPEN PREVIOUS INPUT
	CLRBIT	FAB$V_NAM,FAB$L_FOP(AP)	;REMOVE OPEN BY NAME BLOCK FLAG
	CLRW	RAB$W_ISI(R6)		;ZERO PREVIOUS INTERNAL SEQUENCE NUMBER
	$CONNECT RAB=(R6)		;CONNECT TO PREVIOUS INPUT
	MOVW	IDF_W_INPRFA+4(R8),RAB$W_RFA4(R6) ;COPY RECORD FILE ADDRESS FROM
	MOVL	IDF_W_INPRFA(R8),RAB$W_RFA(R6) ;FROM INDIRECT STACK TO RAB
	BEQL	50$			;BR IF PREVIOUS FILE AT TOP_OF_FILE
	MOVB	#RAB$C_RFA,RAB$B_RAC(R6) ;SET ACCESS MODE TO RECORD FILE ADR
	MOVAB	-INPBUFSIZ(SP),SP	;ALLOCATE A SCRATCH LINE BUFFER
	MOVAB	(SP),RAB$L_UBF(R6)	;SET ADDRESS OF RECORD BUFFER
	$GET	RAB=(R6)		;GET THE PREVIOUS INDIRECT COMMAND
	MOVAB	INPBUFSIZ(SP),SP	;CLEAR TEMP BUFFER FROM THE STACK
	ASSUME	RAB$C_SEQ EQ 0
	CLRB	RAB$B_RAC(R6)		;SET ACCESS TO SEQUENTIAL
50$:	MOVQ	IDF_Q_LOCAL(R8),PRC_Q_LOCAL(R11) ;RESTORE LOCAL SYMBOL TABLE LISTHEAD
	MOVQ	IDF_Q_LABEL(R8),PRC_Q_LABEL(R11) ;RESTORE LOCAL LABEL TABLE LISTHEAD
	MOVW	IDF_W_ONLEVEL(R8),PRC_W_ONLEVEL(R11) ;RESTORE ON ERROR LEVEL NUMBER
	MOVL	IDF_L_ONERROR(R8),PRC_L_ONERROR(R11) ;RESTORE ADDRESS OF COMMAND TEXT
	MOVL	IDF_L_SUBLNK(R8),PRC_L_SUBLNK(R11) ; Restore subroutine list,
	MOVL	IDF_L_BLKLNK(R8),PRC_L_BLKLNK(R11) ; block list,
	MOVB	IDF_B_NESTLEVEL(R8), -		   ; nesting level,
		PRC_B_NESTLEVEL(R11)
	MOVL	IDF_W_BEGINRFA+0(R8), -		   ; Begin RFA (3 words)
		PRC_W_BEGINRFA+0(R11)
	MOVW	IDF_W_BEGINRFA+4(R8), -
		PRC_W_BEGINRFA+4(R11)

	.SBTTL	CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
;
; CREATE - CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
;
; THIS ROUTINE IS CALLED TO CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
; BASE ON THE CURRENT INDIRECT FILE DEPTH.
;
 
CREATE:					;
	MOVL	PRC_L_INDINPRAB(R11),R0	;GET INDIRECT INPUT RAB ADDRESS
	MOVAB	IDF_T_INPDVI(R8),R6	;GET ADDRESS OF INPUT DEVICE IDENTIFICATION
	BICW3	#FAB$M_PPF_IND,-	;REMOVE INDIRECT BIT IF SET AND-
		IDF_W_INPIFI(R8),R7	;GET INPUT FILE INTERNAL INDEX
	MOVAB	INPUTNAM,R10		;GET ADDRESS OF INPUT LOGICAL NAME
	BSBB	10$			;CREATE 'INPUT' LOGICAL NAME
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET INDIRECT OUTPUT RAB ADDRESS
	MOVAB	IDF_T_OUTDVI(R8),R6	;GET ADDRESS OF OUTPUT DEVICE IDENTIFICATION
	BICW3	#FAB$M_PPF_IND,-	;REMOVE INDIRECT BIT IF SET AND-
		IDF_W_OUTIFI(R8),R7	;GET OUTPUT FILE INTERNAL STREAM INDEX
	MOVAB	OUTPUTNAM,R10		;GET ADDRESS OF OUTPUT LOGICAL NAME
10$:	SUBL	#16,SP			;ALLOCATE SPACE TO STORE DEVICE NAME
	MOVZBL	(R6)+,R0		;GET LENGTH OF DEVICE NAME
	MOVC	R0,(R6),(SP)		;COPY DEVICE IDENTIFICATION
	MOVB	#^A/:/,(R3)		;APPEND THE :
	MOVZBL	#27,-(SP)		;INSERT ESCAPE AND TYPE ZERO
	MOVW	R7,2(SP)		;INSERT INTERNAL FILE INDEX
	PUSHAB	(SP)			;BUILD DESCRIPTOR FOR EQUIVALENCE NAME
	MOVZBL	-(R6),R0		;GET LENGTH OF DEVICE IDENTIFICATION
	PUSHAB	5(R0)			;SET LENGTH OF LOGICAL NAME
	MOVL	SP,R0			;SAVE ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	MOVZBL	(R10)+,R9		;GET LENGTH OF LOGICAL NAME
	MOVQ	R9,-(SP)		;BUILD LOGICAL NAME DESCRIPTOR
	MOVL	SP,R1			;SAVE ADDRESS OF LOGICAL NAME DESCRIPTOR
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	$CRELOG_S #LOG$C_PROCESS,(R1),(R0),#PSL$C_SUPER ;CREATE LOGICAL NAME
	BRB	30$			;
20$:	$DELLOG_S #LOG$C_PROCESS,(R1),#PSL$C_SUPER ;DELETE LOGICAL NAME
30$:	ADDL	#36,SP			;CLEAN STACK
	RSB				;
 
	.END
