	.TITLE	MCRSYMBOL - SYMBOL TABLE MANIPULATION ROUTINES
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 22-DEC-1977
;
; SYMBOL TABLE MANIPULATION ROUTINES
;
; MODIFIED BY:
;
;	V001	MAJ0001		Melanie Johnson		29-Jul-81
;			Use $SEVERITY rather than $STATUS for <EXSTAT>
;
;	V002	MAJ0002		Melanie Johnson		04-Aug-81
;			Change FILSPC and FILERR from the WRK data
;			structure to the PRC data structure.
;
;---
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			; DEFINE WORK AREA OFFSETS
	DEFERRCOD			; DEFINE ERROR/STATUS VALUES
	DEFSYMTBL			; DEFINE SYMBOL ENTRY OFFSETS
 
;
; LOCAL MACROS
;
; MACRO TO GENERATE AN ENTRY IN THE SPECIAL SYMBOL TABLE
;
 
	.MACRO	SPCSYM	NAME
	.SAVE
	.PSECT	MCR$ZDATA
	.ASCIC	\NAME\
	.RESTORE
	.WORD	<NAME-SPCDISP>
	.ENDM
 
;
; MACRO TO END THE LIST OF SPECIAL SYMBOLS
;
 
	.MACRO	SPCTRM
	.SAVE
	.PSECT	MCR$ZDATA
	.BYTE	0
	.RESTORE
	.ENDM
 
;
; LOCAL DATA
;
	.PSECT	MCR$ZCODE,RD,NOWRT,BYTE
 
TRUE:	.ASCII	\TF\			; Value of TRUE then FALSE
LOGICAL:.BYTE	SYM_K_LOGICAL		; SYMBOL TABLE ENTRY TYPE OF LOGICAL
DECNUM:	.BYTE	SYM_K_DECIMAL		; AND FOR DECIMAL NUMBER
OCTNUM:	.BYTE	SYM_K_OCTAL		; and for octal number
STRING:	.BYTE	SYM_K_STRING		; AND FOR STRING
HEXDEC:	.BYTE	SYM_K_HEXDEC		; and for hexidecimal number
;
XDATE:	.BYTE	11,0			; Parameters for date and time
XTIME:	.BYTE	8,1			; buffer size, conversion indicator
 
	.PSECT	MCR$ZDATA,RD,NOWRT,BYTE	; START OF SYMBOL NAME TABLE
SPCLTBL:				;
	.PAGE
	.SBTTL	ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE
;+
; MCR$ALLOCSYM  - ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE
; MCR$ALLOCSYMD - ALLOCATE AND INSERT ENTRY IN SYMBOL TABLE - DISABLE ASTS
;
; THIS ROUTINE IS CALLED TO ALLOCATE AND INSERT A SYMBOL ENTRY IN EITHER THE
; LOCAL OR GLOBAL SYMBOL TABLE.
;
; INPUTS:
;
;	R1 <0:15> = LENGTH OF SYMBOL VALUE.
;	R1 <16:23> = TYPE OF SYMBOL
;	R2 = ADDRESS OF SYMBOL VALUE.
;	R3 = LENGTH OF SYMBOL NAME.
;	R4 = ADDRESS OF SYMBOL NAME.
;	R5 = ADDRESS OF SYMBOL TABLE LISTHEAD.
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED
;	WHEN ENTERED AT MCR$ALLOCSYM.
;
; OUTPUTS:
;
;	THE SPECIFIED SYMBOL TABLE IS SEARCHED FOR THE SPECIFIED ENTRY, AND
;	IF FOUND, THE OLD ENTRY IS DEALLOCATED. A SYMBOL TABLE ENTRY IS THEN
;	ALLOCATED, FILLED WITH THE SYMBOL AND VALUE INFORMATION, AND THEN
;	INSERTED IN THE SPECIFIED SYMBOL TABLE.
;
;	R0 LOW BIT CLEAR INDICATES ALLOCATION FAILURE WITH:
;
;		R0 = MCR$_SYMOVF - NO ROOM FOR SYMBOL DEFINITIONS.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R1 = ADDRESS OF ALLOCATED SYMBOL ENTRY.
;-
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$ALLOCSYMD::				; ALLOCATE AND INSERT SYAMBOL AFTER DISABLE
	DISABLE				; DISABLE CONTROL/Y ASTS
	CLRQ	(SP)+			; CLEAR RETURN ARGUMENTS
MCR$ALLOCSYM::				; ALLOCATE AND INSERT SYMBOL IN TABLE
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE SYMBOL ENTRY PARAMETERS
	MOVL	R5,R0			; SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVQ	R3,R1			; SET SYMBOL PARAMETERS
	MOVAL	PRC_Q_GLOBAL(R11),R3	; Get address of global symbol list head
	CMPL	R3,R5			; Allocating symbol onto this list?
	BEQL	4$			; Yes if EQL
	BSBW	MCR$SEARCHTLVL		; Search for symbol at current nesting
	BRB	6$			; level only
4$:
	BSBW	MCR$SEARCHT		; SEARCH FOR SYMBOL
6$:
	BLBC	R0,10$			; IF LBC NO MATCH FOUND
	CMPB	SYM_B_TYPE(R3),#SYM_K_PERM ; PERMANENT SYMBOL?
	BEQL	20$			; IF EQL YES - REFUSE TO REALLOCATE
	BSBB	MCR$DEALLOCSYM		; DEALLOCATE SYMBOL ENTRY
10$:	ADDL3	(SP),8(SP),R1		; CALCULATE LENGTH OF SYMBOL STRINGS
	MOVZWL	R1,R1			; CLEAR SYMBOL TYPE FROM THE LENGTH
	MOVAB	SYM_T_SYMBOL+2+7(R1),R1	; ADD IN FIXED OVERHEAD AND ROUND
	BSBB	MCR$ALLDYNMEM		; ALLOCATE DYNAMIC MEMORY
	BLBS	R0,16$			; BR IF ALLOCATION WORKED OK
	REMQUE	@PRC_Q_LABEL+4(R11),R3	; REMOVE A LABEL TABLE ENTRY
	BVS	20$			; IF V=1, NO ENTRIES IN LABEL TABLE
	BSBB	MCR$DEALLOCSYM		; DEALLOCATE THE LABEL ENTRY
	BRB	10$			; TRY AGAIN TO ALLOCATE THE SYMBOL
16$:	MOVL	R1,SYM_W_SIZE(R2)	; SET SIZE OF ALLOCATED BLOCK
	PUSHL	R2			; SAVE ADDRESS OF ALLOCATED BLOCK
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RETRIEVE SYMBOL PARAMETERS
	PUSHL	R0			; SAVE ADDRESS OF ALLOCATED BLOCK
	INSQUE	SYM_L_FL(R0),(R5)	; INSERT ENTRY IN SYMBOL TABLE
	EXTZV	#16,#8,R1,SYM_B_TYPE(R0); INSERT TYPE OF SYMBOL INTO ENTRY
	MOVB	PRC_B_NESTLEVEL(R11), -	; Insert current nesting level
		SYM_B_NESTLEVEL(R0)	; into entry
	PUSHR	#^M<R1,R2>		; SAVE VALUE PARAMETERS
	MOVB	R3,SYM_T_SYMBOL(R0)	; INSERT LENGTH OF SYMBOL
	MOVC	R3,(R4),SYM_T_SYMBOL+1(R0) ; INSERT SYMBOL NAME
	POPR	#^M<R1,R2>		; RETRIEVE VALUE PARAMETERS
	MOVB	R1,(R3)+		; INSERT LENGTH OF VALUE
	MOVC	R1,(R2),(R3)		; INSERT VALUE
	POPR	#^M<R1>			; RETRIEVE ADDRESS OF SYMBOL ENTRY
	INCL	R0			; SET SUCCESS INDICATOR
	RSB				; 
20$:	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE SYMBOL PARAMETERS
	RSB				; 
;+
; MCR$ALLDYNMEM - DISPATCH TO MEMORY ALLOCATION SUBROUTINE
;
; ENTER HERE TO DISPATCH TO THE MEMORY ALLOCATION ROUTINE
;
; INPUT:
;
;	R1 = SIZE OF BLOCK PLUS ROUND UP FACTOR OF 7
;
; OUTPUTS:
;
;	R1 = SIZE OF BLOCK ALLOCATED
;	R2 = ADDRESS OF BLOCK
;	R3 IS DESTROYED
;-
MCR$ALLDYNMEM::				;  ALLOCATE DYNAMIC MEMORY
	MOVAB	PRC_Q_ALLOCREG(R11),R3	; GET ADDRESS OF ALLOCATION LISTHEAD
	BICL	#7,R1			; TRUNCATE TO QUADWORD MULTIPLE
	JSB	@#EXE$ALLOCATE		; ALLOCATE SYMBOL TABLE ENTRY
	BLBS	R0,20$			; BR IF NO ERROR
	STATUS	SYMOVF			; SET ERROR
20$:	RSB				;
	.PAGE
	.SBTTL	DEALLOCATE SYMBOL TABLE ENTRY
;+
; MCR$DEALLOCSYM - DEALLOCATE SYMBOL TABLE ENTRY
; MCR$DEADYNMEM  - DEALLOCATE DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO REMOVE A SYMBOL FROM ITS TABLE AND/OR
; DEALLOCATE DYNAMIC MEMORY USED.
;
; INPUTS TO DEALLOCSYM:
;
;	R3 = ADDRESS OF SYMBOL ENTRY.
;
; INPUTS TO DEALDYNMEM:
;
;	R0 = ADDRESS OF BLOCK TO DEALLOCATE
;	R1 = SIZE OF BLOCK
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED.
;
; OUTPUTS:
;
;	THE SYMBOL IS REMOVED FROM ITS TABLE AND/OR ITS STORAGE IS DEALLOCATED.
;-
 
MCR$DEALLOCSYM::			; DEALLOCATE SYMBOL TABLE ENTRY
	REMQUE	SYM_L_FL(R3),R0		; REMOVE SYMBOL ENTRY FROM ITS TABLE
	MOVZWL	SYM_W_SIZE(R0),R1	; GET SIZE OF BLOCK TO DEALLOCATE
MCR$DEADYNMEM::				; DEALLOCATE DYNAMIC MEMORY
	MOVAB	PRC_Q_ALLOCREG(R11),R3	; GET ADDRESS OF ALLOCATION LISTHEAD
	JMP	@#EXE$DEALLOCATE	; DEALLOCATE SYMBOL ENTRY STORAGE
	.PAGE
	.SBTTL	SEARCH FOR SYMBOL ENTRY
;+
; MCR$SEARCH - SEARCH FOR SYMBOL ENTRY
;
; THIS ROUTINE IS CALLED TO SEARCH THE LOCAL AND GLOBAL SYMBOL TABLES FOR
; AN ENTRY.
;
; INPUTS:
;
;	R1 = LENGTH OF SYMBOL.
;	R2 = ADDRESS OF SYMBOL.
;
; OUTPUTS:
;
;	THE LOCAL FOLLOWED BY THE GLOBAL SYMBOL TABLE IS SEARCH FOR A SYMBOL
;	MATCH.
;
;	R0 LOW BIT CLEAR INDICATES A SEARCH FAILURE WITH:
;
;		R1 = ZERO.
;
;	R0 LOW BIT SET INDICATES A SYMBOL MATCH WITH:
;
;		R1 = LENGTH OF SYMBOL VALUE.
;		R2 = ADDRESS OF SYMBOL VALUE.
;		R3 = ADDRESS OF SYMBOL ENTRY.
;-
 
MCR$SEARCH::				; SEARCH FOR SYMBOL ENTRY
	CMPB	(R2),#^A/</		; IS THIS A SPECIAL SYMBOL
	BEQL	MCR$SPCLSYMB		; BR IF YES
	MOVAB	PRC_Q_LOCAL(R11),R0	; SET ADDRESS OF LOCAL SYMBOL TABLE LISTHEAD
	BSBB	MCR$SEARCHT		; SEARCH LOCAL SYMBOL TABLE FOR ENTRY
	BLBS	R0,10$			; IF LBS MATCH FOUND
	MOVAB	PRC_Q_GLOBAL(R11),R0	; SET ADDRESS OF GLOBAL SYMBOL TABLE LISTHEAD
	BSBB	MCR$SEARCHT		; SEARCH GLOBAL SYMBOL TABLE FOR ENTRY
	CLRL	R1			; ASSUME NO MATCH FOUND
	BLBC	R0,20$			; IF LBC NO MATCH FOUND
10$:	MOVZBL	SYM_T_SYMBOL(R3),R2	; GET LENGTH OF SYMBOL
	MOVAB	SYM_T_SYMBOL+1(R3)[R2],R2 ; GET ADDRESS OF VALUE LENGTH
	MOVZBL	(R2)+,R1		; GET LENGTH OF VALUE
20$:	RSB				; 
	.PAGE
	.SBTTL	SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY
;+
; MCR$SEARCHT - SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY IGNORING
;		NESTING LEVEL
;
; MCR$SEARCHTLVL - SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY AT CURRENT
;		   NESTING LEVEL ONLY
;
; THIS ROUTINE IS CALLED TO SEARCH A SPECIFIC SYMBOL TABLE FOR AN ENTRY.
;
; INPUTS:
;
;	R0 = ADDRESS OF SYMBOL TABLE LISTHEAD.
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R1 = LENGTH OF SYMBOL NAME.
;		R2 = ADDRESS OF SYMBOL NAME.
;
;	R0 LOW BIT SET INDICATES SYMBOL FOUND WITH:
;
;		R1 = LENGTH OF SYMBOL NAME.
;		R2 = ADDRESS OF SYMBOL NAME.
;		R3 = ADDRESS OF SYMBOL ENTRY.
;-
 
	.ENABLE	LSB
;
MCR$SEARCHTLVL::
	MOVB	#1,-(SP)		; Set current level only flag
	BRB	5$			; Branch to common code
MCR$SEARCHT::				; SEARCH SPECIFIC SYMBOL TABLE FOR ENTRY
	CLRB	-(SP)			; Set any level flag
5$:
	MOVL	R0,R3			; COPY ADDRESS OF SYMBOL TABLE LISTHEAD
10$:	MOVL	SYM_L_FL(R3),R3		; GET ADDRESS OF NEXT ENTRY
	CMPL	R0,R3			; END OF TABLE?
	BEQL	20$			; IF EQL YES
	BLBC	(SP),15$		; Branch if ignoring nesting level
	CMPB	SYM_B_NESTLEVEL(R3), -	; Was symbol defined at current
		PRC_B_NESTLEVEL(R11)	; nesting level?
	BNEQ	10$			; No if NEQ
15$:
	MOVAB	SYM_T_SYMBOL(R3),R4	; GET ADDRESS OF SYMBOL LENGTH
	CMPB	R1,(R4)+		; SYMBOL LENGTH MATCH?
	BNEQ	10$			; IF NEQ NO
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE SEARCH PARAMETERS
	CMPC	R1,(R2),(R4)		; SYMBOLS MATCH?
	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE SEARCH PARAMETERS
	BNEQ	10$			; IF NEQ NO
	INCL	R0			; SET SUCCESS INDICATOR
	BRB	30$
20$:	STATUS	UNDSYM			; SET SYMBOL UNDEFINED
30$:
	INCL	SP			; Clear flag from stack
	RSB				;
;
	.DSABL	LSB
	.PAGE
	.SBTTL	SEARCH FOR SPECIAL SYMBOL
;+
; MCR$SPCLSYMB - SEARCH FOR SPECIAL SYMBOL
;
; THIS ROUTINE IS CALLED TO SEARCH THE SPECIAL SYMBOL TABLE FOR AN ENTRY.
;
; INPUTS:
;
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;	R0 LOW BIT SET INDICATES SYMBOL FOUND WITH:
;
;		R1 = LENGTH OF SYMBOL VALUE.
;		R2 = ADDRESS OF SYMBOL VALUE.
;		R3 = ADDRESS OF DUMMY SYMBOL ENTRY.
;-
MCR$SPCLSYMB::				; SEARCH SPECIAL SYMBOL
	INCL	R2			; ADJUST PAST "<"
	SUBL	#2,R1			; ADJUST COUNT FOR "<>"
	MOVAB	W^SPCLTBL,R5		; SET ADDRESS OF TABLE
	BSBW	MCR$SRCTBL		; SEARCH FOR THE ENTRY
	CASEW	R4,#1,S^#<<<SPCEND-SPCDISP>/2>-1> ; DECODE SYMBOL NAME
SPCDISP:SPCSYM	MAPPED			; IS SYSTEM MAPPED
	SPCSYM	ALTMOD			; ALTMODE TERMINATOR
	SPCSYM	ESCAPE			; ESCAPE TERMINATOR, SYNONYM FOR ALTMODE
	SPCSYM	DEFAUL			; LAST RESPONCE DEFAULTED
	SPCSYM	RAD50			; LAST ANSWER ONLY RAD50 CHARS
	SPCSYM	ALPHAN			; LAST ANSWER ONLY ALPHA/NUMERIC
	SPCSYM	MEMSIZ			; SIZE OF MEMORY
	SPCSYM	SYUNIT			; UNIT FOR SYSTEM DEVICE
	SPCSYM	STRLEN			; LENGTH OF LAST STRING TESTED
	SPCSYM	SYDISK			; NAME OF SYSTEM DISK
	SPCSYM	UIC			; CURRENT UIC (DIRECTORY)
	SPCSYM	SYSUIC			; SYSTEM UIC
	SPCSYM	LIBUIC			; Library UIC
	SPCSYM	EXSTAT			; Exit status
	SPCSYM	DATE			; Current date
	SPCSYM	TIME			; Current time
	SPCSYM	SYSTEM			; System code
	SPCSYM	EOF			; .READ end-of-file flag
	SPCSYM	FILERR			; File error code
	SPCSYM	FILSPC			; Current file specification
	SPCSYM	CLI			; Current CLI
	SPCSYM	RSX11D			; RSX11D flag
SPCEND:	SPCTRM				; TERMINATE THE TABLE
	STATUS	INVKEY			; INDICATE UNRECOGNIZED KEY
	RSB				; RETURN WITH STATUS
 
;
; PROCESS INQUIRY ABOUT LOGIACL FLAGS
;
RSX11D:	BSBB	TRUFLS			; Is system RSX11D?
	.BYTE	0			; Always false
;
MAPPED:BSBB	TRUFLS			; IS SYSTEM MAPPED?
	.BYTE	-1			; ALWAYS TRUE
 
ALTMOD:					; LAST ASK AND WITH ALTMODE?
ESCAPE:	BSBB	TRUFLS			; SAME AS ESCAPE
	.BYTE	MCR_V_ESCAPE		; BIT TO TEST TO FIND OUT
 
DEFAUL:	BSBB	TRUFLS			; LAST ANSWER DEFAULTED?
	.BYTE	MCR_V_DEFALT		; BIT TO TEST TO TELL
 
RAD50:	BSBB	TRUFLS			; LAST STRING TEST RAD50 CHARS
	.BYTE	MCR_V_RAD50		; BIT TO TEST TO TELL
 
ALPHAN:	BSBB	TRUFLS			; LAST STRING TEST ALPHA/NUMERIC CHARS
	.BYTE	MCR_V_ALPHAN		; BIT TO TEST TO TELL

EOF:	BSBB	TRUFLS			; Last .READ detected end-of-file
	.BYTE	MCR_V_EOF		; Bit to test to tell
 
TRUFLS:	MOVAB	LOGICAL-SYM_B_TYPE,R3	; SET DUMMY SYMBOL TABLE ENTRY
	MOVAB	TRUE,R2			; ASSUME ANSWER IS TRUE
	MOVL	#1,R1			; ALWAYS 1 BYTE LONG
	CVTBL	@(SP)+,R0		; GET THE BIT TO TEST
	BLSS	10$			; BR IF ALWAYS TRUE
	BBS	R0,PRC_W_CLIFLAG(R11),10$ ; BR IF FLAG IS SET TRUE
	INCL	R2			; CHANGE VALUE TO FALSE
10$:	STATUS	NORMAL			;
	RSB				;
 
;
; PROCESS INQUIRY ABOUT NUMERIC SYMBOLS
;
	.ENABL	LSB
 
MEMSIZ:	BSBB	10$			; RETURN NUMBER
	.ASCIC	/32/			; Size of memory
 
SYUNIT:	BSBB	10$			; THE UNIT NUMBER FOR SYSTEM DISK
	.ASCIC	/0/			; ALWAYS ZERO
 
SYSTEM:
	BSBB	10$			; The host system code
	.ASCIC	/5/			; Always 5 for VAX/VMS

10$:	MOVAB	DECNUM-SYM_B_TYPE,R3	; SET DUMMY SYMBOL TABLE ENTRY
	BRB	30$			;
 
EXSTAT:
	PUSHL	PRC_L_SEVERITY(R11)	; get address of severity symbol value
	DECL	(SP)			; Adjust address to point to value size
	MOVAB	HEXDEC-SYM_B_TYPE,R3	; Set dummy symbol table entry
	BRB	30$

SYDISK:	BSBB	20$			; SET NAME OF SYSTEM DISK
	.ASCIC	/SY/			; NAME IS ALWAYS "SY"
 
UIC:	PUSHAB	@#PIO$GT_DDSTRING	; ADDRESS OF THE STRING
	BRB	20$			;
 
LIBUIC:
SYSUIC:	BSBB	20$			; RETURN SYSTEM UIC
	.ASCIC	/[1,54]/		; ALWAYS [1,54]

CLI:	BSBB	20$			; Always MCR cli
	.ASCIC	/MCR/
 
20$:	MOVAB	STRING-SYM_B_TYPE,R3	; SET DUMMY SYMBOL TABLE ENTRY
30$:	POPR	#^M<R2>			; ADDRESS OF COUNTED STRING
	MOVZBL	(R2)+,R1		; CONVERT TO STRING DESCRIPTOR
	BRB	50$			; GET OUT
 
DATE:
	MOVAB	XDATE,R2		; Get address of <DATE> parameters
	BRB	DATETIME
;
TIME:
	MOVAB	XTIME,R2		; Get address of <TIME> parameters
DATETIME:
	PUSHAB	WRK_T_DATETIME-DATETIMESIZ(FP) ; Form output buffer descriptor on stack
	MOVZBL	(R2)+,-(SP)		; Size of output buffer
	$ASCTIM_S ,8(SP),,(R2)		; Convert time
	MOVQ	(SP)+,R1		; Set R1 = length of symbol value and
					; R2 = address of symbol value
	BRB	33$
;
FILSPC:
	CLRL	R1			; Initialise length of symbol
	MOVL	PRC_L_FILSPC(R11),R2	; Get address of file name
	BEQL	33$			; If EQL then none
	MOVZBL	(R2)+,R1		; Set R1 = length and R2 = address
33$:
	MOVAB	STRING-SYM_B_TYPE,R3	; Set dummy symbol table entry
	BRB	50$			; Get out
 
;
; Request for file error status
;

FILERR:	MOVAB	PRC_L_FILERR(R11),R2	; Set address of string
	MOVAB	DECNUM-SYM_B_TYPE,R3	; and dummy symbol table entry
	BRB	35$
;
; REQUEST FOR STRING LENGTH FROM LAST TEST OR ASKS
;
 
STRLEN:	MOVAB	PRC_L_CLIWRK0(R11),R2	; SET ADDRESS OF STRING
	MOVAB	OCTNUM-SYM_B_TYPE,R3	; Set dummy symbol table entry
35$:
	CLRL	R1			; START WITH INDEX OF ZERO
40$:	TSTB	(R1)+[R2]		; End of string?
	BNEQ	40$			; BR IF NO
	DECL	R1			; Exclude terminator from count
50$:	STATUS	NORMAL			; SET GOOD STATUS
	RSB				; RETURN
 
	.END
