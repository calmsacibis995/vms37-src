	.TITLE	MCRPRCQUA - PROCESS QUALIFIER SPECIFICATION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 3-JAN-1978
;
; Modified by:
;
;	V003	MAJ0003		Melanie Johnson	02-Mar-1982
;		Allow negated qualifiers to have a value.
;		(For SET NOCONTROL=Y)
;
;	V002	MAJ0002		Melanie Johnson	03-Feb-81
;		Check entity block flag MCROPTDLM for special-casing of
;		SET /UIC=uic command which contains an optional equal sign.
;
;	V001	MAJ0001		Melanie Johnson		04-Nov-81
;		Change to use the command tables (built for DCL) defined
;		by the structures in CLIDEF.MDL.
;
; PROCESS QUALIFIER SPECIFICATION
;
; MACRO LIBRARY CALLS
;

	VECDEF				; DEFINE VECTOR AT FRONT OF TABLES
	CMDDEF				; DEFINE COMMAND DESCRIPTOR BLOCK
	DEFCMDWRK			; DEFINE PROCESS & COMMAND WORK AREAS
	DEFERRCOD			; DEFINE ERROR/STATUS VALUES
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	ENTDEF				; DEFINE ENTITIY DESCRIPTOR BLOCK
	CHGDEF				; DEFINE CHANGE LIST FORMAT
	.PAGE
	.SBTTL	PROCESS QUALIFIER SPCIFICATION
;+
; MCR$PROCQUAL - PROCESS QUALIFIER SPECIFICATION
;
; THIS ROUTINE IS CALLED TO PARSE A QUALIFIER SPECIFICATION AND EMIT A
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF KEYWORD (PARAMETER VS. COMMAND OR PARAMETER QUALIFIER)
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO PARSE QUALIFIER SPECIFICATION.
;
;		R0 = MCR$_ABKEYW - AMBIGUOUS KEYWORD IN QUALIFIER.
;		R0 = MCR$_IMCHNG - MULTIPLE ATTEMPT TO CHANGE IMAGE NAME.
;		R0 = MCR$_IVKEYW - INVALID KEYWORD IN QUALIFIER.
;		R0 = MCR$_IVQLOC - INVALID QUALIFIER LOCATION.
;		R0 = MCR$_IVVALU - INVALID QUALIFIER VALUE SYNTAX.
;		R0 = MCR$_NOKEYW - NO KEYWORD IN QUALIFIER.
;		R0 = MCR$_NOQUAL - NO QUALIFIERS ALLOWED ON COMMAND.
;		R0 = MCR$_NOVALU - NO VALUE ALLOWED ON QUALIFIER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL PARSE WITH THE QUALIFIER
;		DESCRIPTOR EMITTED AND THE QUALIFIER SPECIFICATION COPIED
;		TO THE COMMAND BUFFER.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$PROCQUAL::				; PROCESS QUALIFIER SPECIFICATION
	PUSHR	#^M<R3,R6,R7,R8>	; SAVE REGISTERS
	BISW	#WRK_M_QUAL,WRK_W_FLAGS(FP) ; SET QUALIFIER PROCESSING IN PROGRESS
	PUSHAB	1(R9)			; SAVE STARTING ADDRESS OF QUALIFIER
	CLRL	-(SP)			; CLEAR KEYWORD NEGATION FLAG
5$:	MOVCHAR				; MOVE TERMINATOR
	BSBW	MCR$MARK		; MARK CURRENT POSITION IN BUFFER
	GETOKEN				; GET QUALIFIER NAME
	BNEQ	10$			; BR IF TOKEN FOUND
	CMPB	R0,#^A/-/		; QUALIFIER START WITH NEGATE SIGN
	BNEQ	90$			; BR IF NO
	INCL	(SP)			; SET THE NEGATED FLAG
	BRB	5$			; TRY AGAIN
10$:	MOVL	R1,AP			; SAVE ORIGINAL TOKEN SIZE
	CMPL	#4,R1			; KEYWORD LESS THAN 5 CHARACTERS?
	BGEQ	20$			; IF GEQ YES
	MOVL	#4,R1			; SET TO ONLY COMPARE 4 CHARACTERS
20$:	CLRQ	R6			; CLEAR INITIAL OFFSET AND QUALIFIER NUMBER
	CLRQ	-(SP)			; SET NULL AS QUALIFIER FOUND
	STATUS	NOQUAL			; ASSUME NO QUALIFIERS ALLOWED ON COMMAND
	MOVL	WRK_L_QUABLK(FP),R8	; GET ADDRESS OF QUALIFIER DESCRIPTORS
	BEQL	85$			; IF EQL NONE
30$:	ADDL	R6,R8			; GET ADDRESS OF NEXT QUALIFIER DESCRIPTOR
	CVTWL	ENT_W_NAME(R8),R0	; GET OFFSET TO ASCIC QUALIFIER NAME
	MOVAB	1(R8)[R0],R0		; FIND ADDRESS OF QUALIFIER KEY TEXT
	MOVQ	R1,R3			; COPY QUALIFIER STRING DESCRIPTOR
60$:	CMPB	#^A/ /,(R0)		; END OF QUALIFER TEXT?
	BEQL	65$			; BR IF YES
	CMPB	(R0)+,(R4)+		; IS THIS THE QUALIFIER WERE LOOKIN FOR?
	BNEQ	70$			; BR IF DEFINITELY NOT!
	SOBGTR	R3,60$			; BR IF MORE TO CHECK
65$:	STATUS	ABKEYW			; ASSUME AMBIGUOUS
	TSTL	4(SP)			; FIND MATCH BEFORE?
	BNEQ	85$			; BR IF AMBIGUOUS
	MOVQ	R7,(SP)			; SAVE MATCHED QUALIFIER ADDRESS
70$:	INCL	R7			; INCREMENT QUALIFIER NUMBER
	CVTBL	ENT_B_NEXT(R8),R6	; GET OFFSET TO NEXT QUALIFIER DESCRIPTOR
	BNEQ	30$			; IF NEQ TRY AGAIN
 
;
; ALL QUALIFERS HAVE BEEN CHECK WITHOUT AMBIGUITY
;	NOW SEE IF ANY MATCHED
;
	MOVQ	(SP)+,R7		; RESTORE MATCHED QUALIFER ADDRESS
	BNEQ	110$			; BR IF ONE WAS FOUND
 
;
; QUALIFIER DESCRIPTOR TABLE EXHAUSTED - TRY NEGATION
;
 
	XORL	#1,(SP)			; COMPLEMENT NEGATION FLAG
	SUBL3	#2,AP,R1		; REDUCE CHARACTER COUNT
	BLEQ	80$			; IF LEQ NO MATCH POSSIBLE
	CMPW	#^A/NO/,(R2)+		; KEYWORD START WITH 'NO'?
	BEQL	10$			; IF EQL YES
 
;
; INVALID KEYWORD IN QUALIFIER
;
 
80$:	STATUS	IVKEYW			; SET INVALID KEYWORD STATUS
	BRB	100$			; ERROR EXIT

85$:	CLRQ	(SP)+			; CLEAN MATCHED QUALIFIER ADDR OFF STACK
	BRB	100$			; ERROR EXIT

88$:	STATUS	INVQUAL			; INVALID QUALIFIER FOR MCR
	BRB	100$			; TAKE ERROR EXIT

;
; NO KEYWORD IN QUALIFIER
;
 
90$:	STATUS	NOKEYW			; SET NO KEYWORD STATUS
100$:	BRW	390$			; 
 
;
; VALID KEYWORD MATCH FOUND - CHECK VALIDITY
;
 
110$:	INCL	R7			; ADJUST TO ACTUAL QUALIFIER NUMBER
	BBS	#ENT_V_MCRIGNORE,ENT_L_FLAGS(R8),88$ ; IS THIS A DCL-ONLY QUALIFIER?
	STATUS	IVQLOC			; ASSUME INVALID QUALIFIER LOCATION
	BBS	#WRK_V_VERB,WRK_W_FLAGS(FP),120$ ; IF SET, PROCESSING VERB
	BBS	#ENT_V_PARM,ENT_L_FLAGS(R8),125$ ; IF SET, ALLOWED ON PARAMETERS
120$:	BBC	#ENT_V_VERB,ENT_L_FLAGS(R8),100$ ; IF CLR, NOT ALLOWED ON VERBS

;
; PROCESS CHANGE LIST IF ANY
;
125$:	CVTWL	ENT_W_SYNTAX(R8),R6	; GET OFFSET TO CHANGE LIST
	BNEQ	130$			; IF NEQ, BRANCH AND PROCESS CHANGE LIST
	BRW	155$			; NO CHANGE LIST - TAKE A LONG LEAP
130$:	ADDL	R8,R6			; GET ADDRESS OF CHANGE LIST
	TSTB	WRK_B_CMDOPT(FP)	; FIRST SYNTAX CHANGE SO FAR?
	BNEQ	131$			; ONLY RECORD THE FIRST CHANGE MADE
	MOVB	R7,WRK_B_CMDOPT(FP)	; SAVE QUAL # INDUCING THE FIRST CHANGE
					; FOR GETOPT CALLBACK (SET/SHOW)
131$:	BBC	#CHG_V_IMAGE,CHG_B_FLAGS(R6),145$ ; BRANCH IF NO IMAGE CHANGE
	CVTWL	CHG_W_IMAGE(R6),R0	; GET OFFSET TO ASCIC IMAGE NAME
	BEQL	145$			; IF EQL NO CHANGE
	BGEQ	132$			; BRANCH IF OFFSET
	MNEGL	R0,R0			; GET INDEX INTO IMAGE NAME TABLE
	BRB	135$			;
132$:	ADDL	R6,R0			; GET ADDRESS OF ASCIC IMAGE NAME
135$:	MOVL	R0,WRK_L_IMAGE(FP)	; SET INDEX NUMBER OF NEW IMAGE NAME

145$:	BBC	#CHG_V_PARMS,CHG_B_FLAGS(R6),147$ ; BRANCH IF NO PARAMETER CHANGE
	EXTZV	#CHG_V_MINPARM,#CHG_S_MINPARM,- ; GET NEW PARAMETER LIMITS
		CHG_B_PARMCNT(R6),WRK_L_MINPARM(FP) ; INTO WORK AREA
	EXTZV	#CHG_V_MAXPARM,#CHG_S_MAXPARM,- ; GET NEW PARAMETER LIMITS
		CHG_B_PARMCNT(R6),WRK_L_MAXPARM(FP) ; INTO WORK AREA
	CVTWL	CHG_W_PARMS(R6),R0	; GET OFFSET TO NEW PARAMETER LIST
	BEQL	147$			; IF NONE, LEAVE PROPTR AS IS
	ADDL	R6,R0			; GET ADDRESS OF PARAMETER LIST
	MOVL	R0,WRK_L_PROPTR(FP)	; RESET ADDRESS OF PARAMETER LIST
147$:	BBC	#CHG_V_QUALS,CHG_B_FLAGS(R6),150$ ; BRANCH IF NOT QUAL CHANGE
	CVTWL	CHG_W_QUALS(R6),R0	; GET OFFSET TO NEW QUALIFIER LIST
	BEQL	150$			; IF EQL NONE
	ADDL	R6,R0			; GET ADDRESS OF QUALIFIER LIST
	MOVL	R0,WRK_L_QUABLK(FP)	; RESET ADDRESS OF QUALIFIER LIST
	 
;
; INVALIDATE ALL QUALIFIERS IN THE TOKEN ARRAY, INCLUDING THE QUALIFIER
; WE ARE CURRENTLY PROCESSING, SO THAT ALL QUALIFIERS IN THE PREVIOUS
; SYNTAX ARE NO LONGER ACCESSIBLE.  THIS IS DONE TO PREVENT PREVIOUS
; QUALIFIERS FROM BEING CONFUSED WITH THE CURRENT QUALIFIER NUMBERING
; SCHEME NOW AFTER WE HAVE CHANGED TO A NEW SYNTAX LIST.  THE INVALIDATION
; OF OLD QUALIFIERS IS DONW BY ZEROING THE QUALIFIER NUMBER IN THE TOKEN
; ARRAY, ESSENTIALLY TO RECORD THAT A QUALIFIER WAS DETECTED IN THAT
; POSITION, BUT THAT IT DOESN'T REPRESENT ANY QUALIFIER IN THE CURRENT
; QUALIFIER LIST.
;
	CLRL	R7			; INVALIDATE THIS QUAL #
	MOVAB	WRK_G_RESULT-PTR_C_LENGTH(FP),R0 ; GET ADDRESS OF TOKEN ARRAY
148$:	ADDL	#PTR_C_LENGTH,R0	; SKIP TO NEXT ENTRY
	CMPL	R0,WRK_L_RSLNXT(FP)	; REACHED LAST ENTRY STORED?
	BGEQU	150$			; BRANCH IF SO
	ASSUME	PTR_K_COMDQUAL EQ 0
	ASSUME	PTR_K_PARMQUAL EQ 1
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,(R0),#PTR_K_PARMQUAL ; QUALIFIER?
	BGTRU	148$			; SKIP IF NOT
	INSV	#0,#PTR_V_VALUE,#PTR_S_VALUE,(R0) ; ZERO QUAL # (INVALIDATE IT)
	BRB	148$			; LOOP UNTIL ALL QUALIFIERS INVALIDATED

;
; KEYWORD VALID - CHECK NEGATION AND GENERATE QUALIFIER DESCRIPTOR
;

150$:	CMPB	#PTR_K_PARAMETR,8(SP)	; JUST PROCESSED A CHG LIST - OPTION?
	BNEQ	155$			; IF NEQ NO
	SETCHAR				; LOOK AT NEXT CHARACTER
	CMPB	#^A/=/,R0		; IS IT '='? (AS IN SET /UIC= )
	BEQL	152$			; IF EQL YES
	CMPB	#^A/:/,R0		; COULD IT BE COLON?
	BNEQ	155$			; IF NEQ NO
152$:	BBC	#ENT_V_MCROPTDLM,ENT_L_FLAGS(R8),155$ ;BR IF THIS EQUAL/COLON NOT OPTIONAL
	MOVL	WRK_L_CHARPTR(FP),R0	; GET CURRENT INPUT BUFF. CHAR. PTR.
	MOVB	#^A/ /,1(R0)		; CHANGE COLON OR EQUAL SIGN TO BLANK
155$:	BLBC	(SP),160$		; IF LBC QUALIFIER NOT NEGATED
	STATUS	NOTNEG			; ASSUME QUALIFIER NOT NEGATABLE
	BBC	#ENT_V_NEG,ENT_L_FLAGS(R8),200$ ; IF CLR, NOT NEGATABLE
160$:	MOVZBL	#PTR_K_COMDQUAL,R5	; ASSUME COMMAND QUALIFIER
	BBS	#WRK_V_VERB,WRK_W_FLAGS(FP),170$ ; IF SET, PROCESSING VERB
	BBC	#ENT_V_PARM,ENT_L_FLAGS(R8),170$ ; IF CLR, COMMAND QUALIFIER
	MOVZBL	#PTR_K_PARMQUAL,R5	; SET TYPE TO PARAMETER QUALIFIER
170$:	MOVL	(SP),R6			; COPY NEGATION FLAG
	PUSHL	R8			; SAVE ADDRESS OF ENTITY DESCRIPTOR
	MOVL	WRK_L_MARKPTR(FP),R8	; RETRIEVE STARTING ADDRESS OF QUALIFIER
	GENDESCR			; GENERATE RESULT PARSE DESCRIPTOR
 	POPL	R8			; RESTORE ADDRESS OF ENTITY DESCRIPTOR
;
; CHECK FOR VALUE
;

	CMPB	#PTR_K_PARAMETR,8(SP)	; CHECK R3 STORED ON STACK - OPTION?
	BNEQ	171$			; IF NEQ, NO
	BBC	#ENT_V_VAL,ENT_L_FLAGS(R8),175$ ; BR IF NO VALUES GO ON THIS OPTION
171$:	SETCHAR				; PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/=/,R0		; VALUE SPECIFIED?
	BEQL	180$			; IF EQL YES
172$:	CMPB	#^A/:/,R0		; VALUE SPECIFIED?
	BEQL	180$			; IF EQL YES
	BLBS	(SP),175$		; OK IF QUALIFIER NEGATED AND NO VALUE
	STATUS	VALREQ			; ASSUME VALUE REQUIRED
	BBS	#ENT_V_VALREQ,ENT_L_FLAGS(R8),355$ ; IF SET, VALUE REQUIRED
175$:	BRW	380$			; 
180$:	STATUS	NOVALU			; ASSUME NO VALUE ALLOWED
200$:	BBC	#ENT_V_VAL,ENT_L_FLAGS(R8),390$ ; IF CLR, VALUE NOT ALLOWED

;
; PROCESS QUALIFIER VALUE
;
 
	MNEGL	#2,R5			; SET VALUE COUNT FOR NORMAL CASE
	MOVCHAR				; COPY TERMINATOR INTO COMMAND BUFFER
	SETNBLK				; SKIP LEADING BLANKS
	CMPB	R0,#^A'('		; START OF VALUE LIST?
	BEQL	240$			; BR IF YES
	DECL	R9			; BACK UP EXPANSION BUFFER PTR TO RESTORE EQUAL SIGN
	MOVB	(R9),@WRK_L_CHARPTR(FP)	; WRITE EQUAL SIGN BACK INTO INPUT BUFFER
	DECL	WRK_L_CHARPTR(FP)	; BACK UP INPUT BUFFER POINTER
	BRB	250$			; AND PARSE THE SINGLE VALUE
240$:	INCL	R5			; SET TOKEN TYPE
250$:	MOVZBL	#PTR_K_QUALVALU,R3	; COPY BYTE OF DATA INTO COMMADN BUFFER
	BSBW	MCR$PARSE_VALUE		; PARSE VALUE STRING
	BLBC	R0,390$			; BRANCH IF ERROR DETECTED
	INCL	R5			; COUNT UP THE VALUES SEEN
	BLSS	380$			; BR IF SINGLE VALUE QUALIFIER
	SETCHAR				; PEEK AT THE NEXT CHARACTER
	CMPB	R0,#^A','		; MORE VALUES COMING?
	BEQL	250$			; BR IF YES TO PROCESS VALUES
	CMPB	R0,#^A')'		; IS THIS END OF VALUE LIST
	BNEQ	350$			; IF NO-ITS AN ERROR
	MOVCHAR				; COPY RIGHT PARENTHESIS DELIMITER
	TESTBLANK			; THROW AWAY INSIGNIFICANT TRAILING BLANKS
	BSBW	MCR$GENTERM		; SET ACTUAL TERMINATOR INSTEAD OF RPAREN
	TSTL	R5			;REALLY GET MORE THAN ONE VALUE
	BEQL	380$			;BR IF NO-PARENS WERE NOP
	STATUS	ONEVAL			;ASSUME ONLY ONE VALUE ALLOWED
	BBC	#ENT_V_LIST,ENT_L_FLAGS(R8),390$ ;BR IF ERROR
320$:	BRB	380$			;CONTINUE

;
; INVALID QUALIFIER VALUE SYNTAX
;
 
350$:	STATUS	IVVALU			;SET INVALID SYNTAX
355$:	BRB	390$			;
 
;
; SINGLE VALUE QUALIFIER
;
 
380$:	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION
390$:	CLRQ	(SP)+			;CLEAN STACK
	BICW	#WRK_M_QUAL,WRK_W_FLAGS(FP) ;CLEAR QUALIFIER PROCESSING IN PROGRESS
	POPR	#^M<R3,R6,R7,R8>		;RESTORE REGISTERS
	RSB				;
 



;
; NEED TO TRANSLATE DCL$MARKEDTOKEN
;

	.SBTTL	PARSE VALUE STRING
;+
; MCR$PARSE_VALUE - PARSE A SINGLE VALUE IN A VALUE LIST
;
; THIS ROUTINE IS CALLED TO SCAN A SINGLE VALUE AND STORE
; THE TOKEN DESCRIPTOR WHICH DESCRIBES IT.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	FP = ADDRESS OF COMMAND WORK AREA
;
;	CHARACTER POINTER POINTS TO DELIMITER JUST BEFORE THE VALUE STRING
;
; OUTPUTS:
;
;	R0 = STATUS
;
;	INSIGNIFICANT BLANKS ARE THROWN AWAY FOLLOWING THE VALUE.
;	CHARACTER POINTER POINTS TO DELIMITER JUST AFTER THE VALUE STRING.
;
;	ONE (OR TWO) TOKEN DESCRIPTORS ARE OUTPUT DEPENDING ON WHETHER
;	THE SYNTAX WAS 'VALUE' OR 'KEYWORD=VALUE'.
;-

MCR$PARSE_VALUE::
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	BBS	#ENT_V_FILE,ENT_L_FLAGS(R8),5$	;BR IF VALUE IS A FILE SPEC
	MOVZBL	ENT_B_VALTYPE(R8),R0	;GET VALUE TYPE
	CMPB	R0,#ENT_C_INFILE	;INPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_C_OUTFILE	;OUTPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_C_NODE		;NODE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_DEVICE	;DEVICE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_DIR		;DIRECTORY SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_UIC		;UIC SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_C_RESTOFLINE	;REST OF LINE AS VALUE STRING?
	BNEQ	10$			;BRANCH IF NOT
;
; PROCESS VALUE TYPED AS "RESTOFLINE"
;
	MOVCHAR				;COPY TERMINATOR INTO EXPANSION BUFFER
	SETNBLK				;SKIP LEADING BLANKS
	BSBW	MCR$MARK		;MARK START OF VALUE STRING
8$:	MOVCHAR				;COPY NEXT CHARACTER
	BNEQ	8$			;LOOP UNTIL END OF LINE
	BSBW	MCR$MARKEDTOKEN		;GET DESCRIPTOR OF MARKED TOKEN
	DECL	R1			;SUBTRACT OUT EOL CHARACTER
	BRB	60$			;STORE THE TOKEN AND EXIT
;
; PROCESS VALUE TYPED AS INFILE, OUTFILE, NODE, DEVICE, DIR OR UIC
;
5$:	PROCFILE			;PARSE THE FILE SPEC
	BRB	90$
;
; PROCESS VALUE TYPED AS STRING (UNTYPED)
;
10$:	MOVCHAR				;COPY TERMINATOR INTO EXPANSION BUFFER
	SETNBLK				;SKIP LEADING BLANKS
	BSBW	MCR$MARK		;SAVE START OF VALUE STRING
20$:	GTBTOKEN			;COPY TOKEN INTO EXPANSION BUFFER
	TSTW	ENT_W_KEYWORDS(R8)	;DOES VALUE TAKE KEYWORDS?
	BEQL	30$			;IF NOT, IGNORE EMBEDDED '=:'
	CMPB	R0,#^A'='		;VALUE SEPARATOR?
	BEQL	50$			;BR IF YES
	CMPB	R0,#^A':'		;CHECK IF END OF KEY AND START OF VALUE
	BEQL	50$			;BR IF YES
30$:	LOCC	R0,S^#370$-360$,B^360$	;CHECK FOR VALUE STRING TERMINATOR
	BNEQ	50$			;BR IF TERMINATOR FOUND
	MOVCHAR				;COPY CHARACTER WHICH STOPPED GETOKEN
	BRB	20$			;KEEP GETTING TOKENS UNTIL END OF VALUE
50$:	BSBW	MCR$MARKEDTOKEN		;GET DESCRIPTOR OF VALUE STRING
	BEQL	80$			;ERROR IF NO VALUE
	BSBW	MCR$COMPRESS		;COMPRESS QUOTED STRING
60$:	MOVL	(SP),R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6			;CLEAR FLAGS
	MOVQ	R1,R7			;SET LENGTH OF VALUE
	GENDESCR			;GENERATE RESULT PARSE DESCRIPTOR
	SETCHAR				;GET TERMINATOR CHARACTER
	CMPB	R0,#^A'='		;IS THIS KEYWORD=VALUE CONSTRUCT?
	BEQL	10$			;BR IF YES
	CMPB	R0,#^A':'		;CHECK FOR ALTERNATE SYNTAX
	BEQL	10$			;BR IF YES-GET THE VALUE PART
	TESTBLANK			;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	MCR$GENTERM		;AND SET TERMINATOR IN LAST TOKEN
	MOVL	#1,R0			;SET SUCCESSFUL
90$:	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

80$:	STATUS	IVVALU			;SET INVALID SYNTAX
	BRB	90$
 
;
; VALID TERMINATOR LIST FOR VALUE STRINGS
;
360$:	.ASCII	\ +,/()\<0>		; SPACE,PLUS,COMMA,SLASH,PARENS AND EOL
370$:

	.END
