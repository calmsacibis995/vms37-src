	.TITLE	MCRCHAR - CHARACTER MANIPULATION ROUTINES
	.IDENT	'V03-004'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 28-MAR-77
;
; Modified by:
;
;	V03.04	MAJ0011		Melanie Johnson	20-Apr-1982
;		When a successful $GET occurs after retries on RSA error, make
;		sure the command doesn't get swallowed.
;
;	V03.03	MAJ0010		Melanie Johnson	29-Mar-1982
;		Do several retries on record stream active error from RMS
;		to allow enough time for previous I/O to complete before
;		canceling the RMS I/O.
;
;	V03.02	MAJ0009		Melanie Johnson	24-Mar-1982
;		Add the routines MCR$BACKUPMOVE and MCR$BACKUPCHAR as part
;		of a fix for the MOUNT and INITIALIZE command.
;
;	V03.01	MAJ0008		Melanie Johnson	05-Mar-1982
;		Fix MCR$GTBTOKEN so that the EOL terminator won't overwrite the
;		last character before EOL in the input buffer.  Also, check for
;		and skip over insignificant blanks when getting the next token.
;
;	V02.07	MAJ0007		Melanie Johnson	13-Nov-81
;		Add the routines MCR$COMPRESS, MCR$MARK, and MCR$MARKEDTOKEN.
;
;	V02.06	MAJ0006		Melanie Johnson	11-Nov-81
;		Fix so that full-line comments may be echoed without enabling
;		substitution capability.
;
;	V02.05	MAJ0005		Melanie Johnson	05-Oct-81
;		Limit the number of substitutions in one line to 1000 to
;		prevent the occurrence of infinite recursive substitution.
;
;	V02.04	MAJ0004		Melanie Johnson	25-Aug-81
;		Don't allow continuation of full-line comments. (Fix the bug that
;		allows full-line comments in a .GOTO section to be 
;		continued, and hence to wipe out the label which follows.)
;		Cause partial-line comments (following or imbedded in commands)
;		to be continued if they contain a dash which precedes the EOL.
;
;	V01.03	RN0018		R. Newland	 3-Jan-1980
;		Perform a WAIT before doing the get from command input
;		stream so that the cancel of I/O at control Y ast level
;		has a chance to complete.
;
;	V01.03	RN0014		R. Newland	16-Dec-1979
;		Allow forward conversion of tabs to spaces to be suppressed,
;		and allow continuation lines to be suppressed.
;		SPR 11-27205
;
;	V01.02	RN0006		R. Newland	21-Jun-1979
;		 (1) Allow ON conditions if .ASK and an I/O error
;		occurs (e.g. BREAK key).
;
;		 (2) Change return sequence to LOGINOUT image on end of file
;		to call MCR$ABORT which makes things look like a LOGOUT
;		command was encountered. See also COMMAND and MESSAGE.
;
;		(3) Cause an .ASK to receive EOF from RMS if the data
;		entered began with a $ and was from a process permanent
;		(i.e. BATCH) file to be consistent with reading of SYS$INPUT.
;
;	V01.01	RN0003		R. Newland	12-May-1979
;		! in numeric expression is taken as a comment delimiter
;		if immediately preceded by a blank
;
; CHARACTER MANIPULATION ROUTINES
.PAGE
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	DEFSYMTBL			;DEFINE SYMBOL TABLE OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
; 
; LOCAL DEFINITIONS
;
	LOC_V_FULCOM	=	8	;BIT TO INDICATE A COMMENT FOUND IN A .GOTO SECTION
	LOC_V_PRTCOM	=	7	;BIT TO INDICATE A PARTIAL-LINE COMMENT ON A COMMAND LINE

	LOC_M_PRTCOM	=	^X80	;MASK CORRESPONDING TO LOC_V_PRTCOM

; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$HYPHEN::				;HYPHEN STRING
	.ASCII	/-/<0>			;
REPROMPT:				;CONTINUATION PROMPT STRING
	.ASCIC	/>_/			;
TERMCLASS:				;ITEM TERMINATOR STRING
	.ASCII	\),+/: \		;
TERMTAB:				;TERMINATOR TABLE
	.ASCII	D:/+,-()]>?&\=^!D<0>	;
BLANKTAB:				;SIGNIFICANT BLANK SEPARATOR
	.ASCII	\@*'[<.; \		;
ENDTERM:				;REF LABEL
	.PAGE
	.SBTTL	COMPRESS QUOTED STRING IN COMMAND BUFFER
;+
; MCR$COMPRESS - COMPRESS QUOTED STRING IN COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO COMPRESS A QUOTED STRING WHICH IS
; THE LAST TOKEN IN THE COMMAND BUFFER.  THE QUOTES ARE REMOVED
; FROM THE STRING AND THE COMMAND BUFFER POINTER IS RESET TO THE
; NEW END OF THE STRING.
;
; INPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF COMPRESSED STRING.
;	R2 = ADDRESS OF COMPRESSED STRING.
;
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER - POINTS TO THE END
;	     OF THE COMPRESSED STRING
;-
 
MCR$COMPRESS::
	BSBW	MCR$COMPSTRING		;COMPRESS STRING IN PLACE
	ADDL3	R1,R2,R9		;RESET POINTER JUST PAST NEW STRING
	RSB


	.SBTTL	MARK POSITION IN COMMAND BUFFER
;+
; MCR$MARK - MARK CURRENT POSITION IN COMMAND BUFFER
;
; MARK THE CURRENT POSITION OF THE SEGMENT BEING PARSED
; SO THAT IF ANY ERROR OCCURS LATER, THE SEGMENT CAN BE
; SHOWN IN THE ERROR MESSAGE.  THE MARKED POSITION IS
; ALSO USED TO OBTAIN THE LENGTH AND ADDRESS OF THE STRING
; MOVED INTO THE COMMAND BUFFER SINCE THE LAST MARK.
;
; INPUTS:
;
;	R9  = CURRENT POINTER INTO COMMAND BUFFER
;	FP  = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	WRK_L_MARKPTR = POSITION OF SEGMENT NOW BEING PARSED
;---
MCR$MARK::
	MOVL	R9,WRK_L_MARKPTR(FP)	;COPY CURRENT COMMAND BUFFER ADDRESS
	RSB


	.SBTTL	GET DESCRIPTOR OF COMMAND BUFFER STRING
;+
; MCR$MARKEDTOKEN - GET DESCRIPTOR OF MARKED COMMAND BUFFER STRING
;
; THIS ROUTINE IS CALLED TO OBTAIN THE LENGTH AND ADDRESS OF THE
; STRING COMPOSED OF ALL CHARACTERS WRITTEN INTO THE COMMAND BUFFER
; SINCE THE LAST CALL TO MCR$MARK.
;
; INPUTS:
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER
;	FP = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1 = LENGTH OF STRING
;	R2 = ADDRESS OF STRING
;	Z SET IF R1=0
;-
MCR$MARKEDTOKEN::
	MOVL	WRK_L_MARKPTR(FP),R2	;GET ADDRESS OF STRING
	SUBL3	R2,R9,R1		;COMPUTE LENGTH OF STRING
	RSB


	.SBTTL	LOCATE STRING BY INDEX NUMBER
;+
; MCR$LOCATE - LOCATE STRING BY INDEX NUMBER
;
; THIS ROUTINE IS CALLED TO LOCATE A STRING IN A CHARACTER ARRAY 
; OF COUNTED STRINGS BY INDEX.
;
; INPUTS:
;
;	R2 = ADDRESS OF CHARACTER ARRAY.
;	R3 = STRING INDEX NUMBER.
;
; OUTPUTS:
;
;	R1 = LENGTH OF STRING.
;	R2 = ADDRESS OF STRING.
;-
 
MCR$LOCATE::				;LOCATE STRING BY INDEX NUMBER
	CLRL	R1			;CLEAR INITIAL LENGTH
10$:	ADDL	R1,R2			;POINT TO NEXT ENTRY IN TABLE
	MOVZBL	(R2)+,R1		;GET COUNT AND ADDRESS
	SOBGEQ	R3,10$			;ANY MORE STRINGS TO SKIP OVER?
	RSB				;
	.PAGE
	.SBTTL	GENERATE RESULT PARSE DESCRIPTOR
;+
; MCR$GENDESCR - GENERATE RESULT PARSE DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO GENERATE A LONGWORD DESCRIPTOR FOR A RESULT PARSE
; ITEM.
;
; INPUTS:
;
;	R5 = ITEM TYPE.
;	R6 = ITEM FLAGS.
;	R7 = ITEM VALUE.
;	R8 = STARTING ADDRESS OF ITEM.
;	R9 = ADDRESS OF TERMINATOR CHARACTER IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;
; OUTPUTS:
;
;	THE SPECIFIED FIELDS ARE PACKED TOGETHER TO FORM A RESULT PARSE
;	DESCRIPTOR LONGWORD AND THE RESULTANT VALUE IS STORED IN THE RESULT
;	PARSE TABLE.
;-
 
MCR$GENDESCR::				;GENERATE RESULT PARSE DESCRIPTOR
	PUSHAB	WRK_L_RSLNXT(FP)	;GET ENDING ADDRESS OF RESULT BUFFER
	CMPL	(SP)+,R10		;ROOM FOR ANOTHER DESCRIPTOR?
	BGTRU	10$			;OK IF GTRU
	ERRMSG	RSLOVF			;OUTPUT ERROR MESSAGE
	BRW	ERROR			;
10$:	INSV	R7,#PTR_V_VALUE,#PTR_S_VALUE,- ;INSERT VALUE FIELD
		PTR_L_DESCR(R10)	;
	PUSHAB	WRK_AB_BUFFER(FP)	;GET STARTING ADDRESS OF COMMAND BUFFER
	SUBL3	(SP)+,R8,R0		;CALCULATE OFFSET TO ITEM
	INSV	R0,#PTR_V_OFFSET,#PTR_S_OFFSET,- ;INSERT OFFSET TO ITEM
		PTR_L_DESCR(R10)	;
	INSV	R6,#PTR_V_FLAGS,#PTR_S_FLAGS,- ;INSERT ITEM FLAGS
		PTR_L_DESCR(R10)	;
	INSV	R5,#PTR_V_TYPE,#PTR_S_TYPE,- ;INSERT ITEM TYPE
		PTR_L_DESCR(R10)	;
	TSTL	(R10)+			;POINT TO NEXT ITEM IN BUFFER
	MOVL	R10,WRK_L_RSLNXT(FP)	;SAVE ADDRESS OF THIS DESCRIPTOR
	MOVL	(R9),R0			;PUT TERMINATOR CHAR IN R0 FOR MCR$GENTERM


	.SBTTL	SET TERMINATOR CLASS IN LAST DESCRIPTOR
;+
; MCR$GENTERM - SET TERMINATOR CLASS IN PREVIOUS TOKEN DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO SET THE TERMINATOR CLASS IN THE TOKEN
; DESCRIPTOR MOST RECENTLY STORED VIA DCL$GENDESCR.
;
; INPUTS:
;
;	R0 = TERMINATOR CHARACTER
;
; OUTPUTS:
;
;	NONE
;-

MCR$GENTERM::
	CMPB	R0,#^A'='		;EQUAL TERMINATOR?
	BEQL	20$			;IF YES, SET CLASS=COLON
	CMPB	R0,#^A'('		;LEFT PARENTHESIS?
	BEQL	30$			;IF YES, SET CLASS
	LOCC	R0,#TERMTAB-TERMCLASS,TERMCLASS ;SEARCH FOR TERMINATOR IN TABLE
	BNEQ	50$			;IF FOUND - USE INDEX # AS CLASS
	ASSUME	PTR_K_BLANK EQ 1
	INCL	R0			;SET TERMINATOR CLASS TO BLANK
	BRB	50$
20$:	MOVZBL	#PTR_K_COLON,R0		;SET TERMINATOR CLASS TO COLON
	BRB	50$
30$:	MOVZBL	#PTR_K_LPAREN,R0	;SET TERMINATOR CLASS TO LPAREN
50$:	INSV	R0,#PTR_V_TERM,#PTR_S_TERM,- ;INSERT TERMINATOR CLASS NUMBER
		-PTR_C_LENGTH(R10)	;IN LAST TOKEN DESCRIPTOR STORED
	RSB


	.PAGE
	.SBTTL	GET NEXT NONBLANK CHARACTER FROM INPUT BUFFER
;+
; MCR$GETNBLK - GET NEXT NONBLANK CHARACTER FROM INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE NEXT NONBLANK CHARACTER FROM THE INPUT
; BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CHARACTERS ARE OBTAINED FROM THE INPUT BUFFER UNTIL A NONBLANK
;	CHARACTER IS ENCOUNTERED.
;
;	R0 = NONBLANK CHARACTER.
;-
 
MCR$GETNBLK::				;GET NEXT NONBLANK CHARACTER
	BSBB	MCR$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
	BRW	MCR$GETCHAR		;RETURN NEXT CHARACTER TO CALLER
	.PAGE
	.SBTTL	MOVE CHARACTER TO COMMAND BUFFER AND GET BLANK TOKEN
;+
; MCR$MOVBTOKN - MOVE CHARACTER TO COMMAND BUFFER AND GET BLANK TOKEN
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED OPERATION OF MOVING THE NEXT
; CHARACTER TO THE COMMAND BUFFER AND THEN OBTAINING THE NEXT BLANK TOKEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS MOVED TO THE COMMAND BUFFER AND THEN THE NEXT
;	BLANK TOKEN IS OBTAINED.
;-
 
MCR$MOVBTOKN::				;MOVE CHARACTER AND GET TOKEN
	BSBW	MCR$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BRB	MCR$GTBTOKEN		;GET NEXT BLANK TOKEN
	.PAGE
	.SBTTL	MOVE CHARACTER TO COMMAND BUFFER AND GET TOKEN
;+
; MCR$MOVTOKN - MOVE CHARACTER TO COMMAND BUFFER AND GET TOKEN
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED OPERATION OF MOVING THE NEXT
; CHARACTER TO THE COMMAND BUFFER AND THEN OBTAINING THE NEXT TOKEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS MOVED TO THE COMMAND BUFFER AND THEN THE NEXT
;	TOKEN IS OBTAINED.
;-
 
MCR$MOVTOKN::				;MOVE CHARACTER AND GET TOKEN
	BSBW	MCR$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	.PAGE
	.SBTTL	GETOKEN - GET TOKEN FROM INPUT BUFFER
;+
; MCR$GETOKEN - GET TOKEN FROM INPUT BUFFER WITH INSIGNIFICANT LEADING BLANKS
; MCR$GTBTOKEN - GET TOKEN FROM INPUT BUFFER WITH SIGNIFICANT LEADING BLANKS
;
; THIS ROUTINE IS CALLED TO SCAN THE INPUT BUFFER UNTIL A DELIMITER IS FOUND.
; WHILE THE BUFFER IS BEING SCANNED, THE RESULTANT TOKEN IS COPIED INTO THE
; COMMAND BUFFER. WHEN A TERMINATOR IS RECOGNIZED, THE DESCRIPTOR FOR THE
; TOKEN IS RETURNED TO THE CALLER ALONG WITH THE TERMINATOR.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 = TERMINATOR CHARACTER.
;	R1 = LENGTH OF OUTPUT TOKEN.
;	R2 = ADDRESS OF OUTPUT TOKEN.
;
;	Z = 1 IF NO TOKEN IS BEING RETURNED.
;	Z = 0 IF A TOKEN IS BEING RETURNED.
;-

MCR$GETOKEN::				;GET TOKEN FROM INPUT BUFFER
	BSBB	MCR$SETNBLK		;POINT TO NEXT NONBLANK CHARACTER
MCR$GTBTOKEN::				;GET TOKEN FROM INPUT BUFFER
	SUBL3	FP,R9,R2		;FIND OFFSET TO START OF TOKEN IN BUUFER
10$:	BSBW	MCR$MOVCHAR		;MOVE CHARACTER TO COMMAND BUFFER
	BBS	#WRK_V_QUOTE,WRK_W_FLAGS(FP),10$ ;IF SET, QUOTE IN PROGRESS
	BBS	#WRK_V_STAR,WRK_W_FLAGS(FP),20$ ;IF SET, ASTERISK IS TERMINATOR
	CMPB	#^A/*/,R0		;ASTERISK?
	BEQL	10$			;IF EQL YES
20$:	LOCC	R0,#ENDTERM-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BEQL	10$			;IF EQL TERMINATOR NOT FOUND
	DECL	R9			;BACK UP TO TERMINATOR
	MOVZBL	(R1),R0			;RETRIEVE TERMINATOR
	BNEQ	25$			;BR IF NOT EOL
	INCL	WRK_L_CHARPTR(FP)	;DON'T OVERWRITE THE LAST CHAR BEFORE EOL
	BRB	30$			;BR TO RESTORE EOL IN BUFFER
25$:	CMPB	#^A/ /,R0		;WAS TERMINATOR A BLANK?
	BNEQ	30$			;IF NEQ, NO
	MOVL	WRK_L_CHARPTR(FP),R1	;GET CURRENT INPUT BUFFER POINTER
	LOCC	1(R1),#BLANKTAB-TERMTAB,TERMTAB ;SEARCH FOR ANOTHER TERMINATOR
	BNEQ	10$			;IF NEQ, BLANK WAS INSIGNIFICANT
	MOVZBL	#^A/ /,R0		;RESET SIGNIFICANT BLANK AS TERMINATOR
30$:	MOVB	R0,@WRK_L_CHARPTR(FP)	;RESTORE TERMINATOR IN INPUT BUFFER
	DECL	WRK_L_CHARPTR(FP)	;BACK UP TO TERMINATOR IN INPUT BUFFER
	ADDL	FP,R2			;FIND START OF TOKEN IN BUFFER
	SUBL3	R2,R9,R1		;CALCULATE LENGTH OF ITEM
	RSB				;
	.PAGE
	.SBTTL	FORCE NONBLANK CHARACTER
;+
; MCR$FORNBLK - FORCE NONBLANK CHARACTER
;
; THIS ROUTINE IS CALLED TO FORCE AN INPUT AND THEN SET THE CHARACTER POINTER
; TO THE NEXT NONBLANK CHARACTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER POINTER IS SET TO POINT TO A STRING CONTAINING
;	A HYPHEN FOLLOWED BY AN END OF LINE. A SET NONBLANK OPERATION IS
;	THEN PERFORMED.
;-
 
MCR$FORNBLK::				;FORCE NONBLANK CHARACTER
	MOVAB	MCR$HYPHEN-1,WRK_L_CHARPTR(FP) ;SET TO FORCE INPUT ON NEXT GET
	.PAGE
	.SBTTL	POINT TO NEXT NONBLANK CHARACTER IN INPUT BUFFER
;+
; MCR$SETNBLK - POINT TO NEXT NONBLANK CHARACTER IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO SET THE INPUT BUFFER POINTER TO THE NEXT NONBLANK
; CHARACTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CHARACTERS ARE OBTAINED FROM THE INPUT BUFFER UNTIL A NONBLANK CHAR-
;	ACTER IS ENCOUNTERED AND THE INPUT BUFFER POINTER IS RETURNED TO ITS
;	POSITION BEFORE THE LAST GET CHARACTER OPERATION.
;
;	R0 = NONBLANK CHARACTER.
;-
 
	.ENABL	LSB
MCR$SETNBLK::				;POINT TO NEXT NONBLANK CHARACTER
	BSBB	MCR$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	20$			;IF EQL END OF LINE
	CMPB	#^A/ /,R0		;BLANK?
	BEQL	MCR$SETNBLK		;IF EQL YES
	BRB	10$			;
	.PAGE
	.SBTTL	PEEK AT NEXT CHARACTER IN INPUT BUFFER
;+
; MCR$SETCHAR - PEEK AT NEXT CHARACTER IN INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE NEXT CHARACTER IN THE INPUT BUFFER
; WITHOUT MOVING THE BUFFER POINTER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS OBTAINED FROM THE INPUT BUFFER AND THE CHARACTER
;	POINTER IS RETURNED TO ITS POSITION BEFORE THE GET CHARACTER OPERATION.
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER.
;+
 
MCR$SETCHAR::				;PEEK AT NEXT CHARACTER
	BSBB	MCR$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	BEQL	20$			;IF EQL END OF LINE
10$:	BICW	#WRK_M_QUOTE,WRK_W_FLAGS(FP) ;TURN OFF QUOTATION FLAG
	DECL	WRK_L_CHARPTR(FP)	;BACK UP INPUT BUFFER POINTER
20$:	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	TEST FOR SIGNIFICANT BLANK
;+
; MCR$TESTBLANK - TEST FOR SIGNIFICANT BLANK
;
; THIS ROUTINE IS CALLED TO TEST IF THE NEXT CHARACTER IN THE INPUT BUFFER IS
; A SIGNIFICANT BLANK.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF THE NEXT CHARACTER IN THE INPUT BUFFER IS A BLANK AND IT IS NOT
;	SIGNIFICANT, THEN IT IS REMOVED FROM THE INPUT STREAM.
;-
 
MCR$TESTBLANK::				;TEST FOR SIGNIFICANT BLANK
	BSBB	MCR$MOVCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	10$			;IF NEQ NO
	BSBB	MCR$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	LOCC	R0,#BLANKTAB-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BEQL	10$			;BR IF BLANK IS SIGNIFICANT
	MOVB	(R1),-1(R9)		;PUT REAL TERMINATOR OVER BLANK
	INCL	WRK_L_CHARPTR(FP)	;ADJUST POINTER FOR THE BLANK
10$:	MOVB	-(R9),R0		;GET TERMINATOR FROM PARSE BUFFER
	BEQL	20$			;BR IF END OF LINE-NO NEED TO RESTORE
	DECL	WRK_L_CHARPTR(FP)	;BACK UP INPUT BUFFER POINTER
	MOVB	R0,@WRK_L_CHARPTR(FP)	;RESTORE TERMINATOR IN INPUT BUFFER
20$:	RSB				;
	.PAGE
	.SBTTL	BACKUP CHARACTER FROM EXPANSION TO INPUT BUFFER
;+
; MCR$BACKUPMOVE - BACKUP ONE CHARACTER FROM EXPANSION TO INPUT BUFFER
;
; THIS ROUTINE RESTORES THE CHARACTER MOST RECENTLY WRITTEN INTO THE EXPANSION
; BUFFER BACK INTO THE INPUT BUFFER AND RESETS THE POINTERS.  THIS EFFECTIVELY
; TAKES BACK THE MOST RECENT "MOVCHAR".
;
; INPUTS:
;
;	R9 = EXPANSION (COMMAND) BUFFER POINTER
;
; OUTPUTS:
;
;	THE CHARACTER IS COPIED BACK INTO THE INPUT BUFFER AND THE POINTERS
;	ARE RESET.
;-
MCR$BACKUPMOVE::
	MOVB	-(R9),R0	;BACK UP EXPANSION BUFFER POINTER AND GET CHAR.


	.SBTTL	BACKUP CHARACTER TO INPUT BUFFER
;+
; MCR$BACKUPCHAR - BACKUP ONE CHARACTER TO INPUT BUFFER
;
; THIS ROUTINE WRITES A GIVEN CHARACTER BACK INTO THE INPUT BUFFER (AT THE
; BEGINNING) AND RESETS THE INPUT POINTER.
;
; INPUTS:
;
;	R0 = CHARACTER TO BE WRITTEN
;	FP = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	THE CHARACTER IS APPENDED TO THE FRONT OF THE INPUT BUFFER
;	AND THE POINTERS ARE RESET.
;-
MCR$BACKUPCHAR::
	MOVB	R0,@WRK_L_CHARPTR(FP)	;WRITE CHARACTER INTO INPUT BUFFER
	DECL	WRK_L_CHARPTR(FP)	;BACK UP INPUT BUFFER POINTER
	RSB
	.PAGE
	.SBTTL	MOVE CHARACTER AND SET NON BLANK
;+
; MCR$MOVNCHR - MOVE CHARACTER AND SET NON-BLANK
;
; THIS ROUTINE IS CALLED TO PERFORM THE COMBINED FUNCTION OF MOVE
; CHARACTER TO COMMAND BUFFER AND SET NON-BLANK.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE CURRENT CHARACTER IS COPIED TO THE COMMAND BUFFER AND
;	INTERVENING BLANKS ARE SKIPPED.
;-
 
MCR$MOVNCHR::				;
	PUSHAB	MCR$SETNBLK		; PLACE TO GO AFTER MOVE
					; FALL INTO MOVE CHARACTER
	.PAGE
	.SBTTL	MOVE CHARACTER TO COMMAND BUFFER
;+
; MCR$MOVCHAR - MOVE CHARACTER TO COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO MOVE A CHARACTER FROM THE INPUT BUFFER TO THE
; COMMAND BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS OBTAINED FROM THE INPUT BUFFER AND WRITTEN INTO
;	THE COMMAND BUFFER.
;
;	R0 = CHARACTER MOVED.
;-
 
MCR$MOVCHAR::				;MOVE CHARACTER TO COMMAND BUFFER
	BSBB	MCR$GETCHAR		;GET NEXT CHARACTER FROM INPUT BUFFER
	.PAGE
	.SBTTL	PUT CHARACTER IN COMMAND BUFFER
;+
; MCR$PUTCHAR - PUT CHARACTER IN COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO WRITE A CHARACTER INTO THE COMMAND BUFFER.
;
; INPUTS:
;
;	R0 = CHARACTER TO BE WRITTEN IN COMMAND BUFFER.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;
; OUTPUTS:
;
;	THE SPECIFIED CHARACTER IS WRITTEN INTO THE COMMAND BUFFER AFTER
;	HAVING CHECKED FOR BUFFER OVERFLOW.
;
;	R0 = CHARACTER WRITTEN.
;-
 
MCR$PUTCHAR::				;PUT CHARACTER IN COMMAND BUFFER
	PUSHAB	WRK_AB_BUFFER+CMDBUFSIZ(FP) ;GET ENDING ADDRESS OF COMMAND BUFFER
	CMPL	(SP)+,R9		;ROOM FOR ANOTHER CHARACTER?
	BLEQU	10$			;IF LEQU NO
	MOVB	R0,(R9)+		;STORE CHARACTER IN COMMAND BUFFER
	RSB				;
10$:	BSBW	MCR$MARK		;SET FOR NO ERROR SEGMENT
	ERRMSG	BUFOVF			;OUTPUT ERROR MESSAGE
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;CLEAR INDIRECT IN PROGRESS
	BRW	ERROR			;
	.PAGE
;+
; MCR$MOVTERM - MOVE TERMINATING CHARACTER
;
; THIS ROUTINE IS CALLED TO MOVE THE TERMINATOR INTO THE COMMAND BUFFER
; AND VERIFY THAT IT IS A SPECFIC CHARACTER.
;
; INPUTS:
;
;	CHARACTER IS FIRST BYTE AFTER JSB/BSB INSTRUCTION
;
; OUTPUTS:
;
;	THE TERMINATOR IS MOVED AND IT IS COMPAIRED WITH THE
;	THE EXPECTED TERMINATOR
;
;	R0 CONTAINS THE CHARACTER MOVED
;-
 
MCR$MOVTERM::				; MOVE TERMINATOR
	BSBB	MCR$MOVCHAR		; MOVE THE TERMINATOR
	PUSHL	(SP)			; COPY RETURN PC
	INCL	4(SP)			; ADJUST RETURN ADDRESS
	CMPB	R0,@(SP)+		; CHECK FOR THE PROPER CHARACTER
	RSB				; RETURN WITH CONDITION CODES SET
	.PAGE
	.SBTTL	GET - GET CHARACTER FROM INPUT BUFFER
;+
; MCR$GETCHAR - GET CHARACTER FROM INPUT BUFFER
;
; THIS ROUTINE IS CALLED TO GET THE NEXT CHARACTER FROM THE INPUT BUFFER.
; IT HANDLES INDIRECT FILES, QUOTES, CONTINUATION, AND BLANK SUPPRESSION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE NEXT CHARACTER IS READ FROM THE INPUT BUFFER AND RETURNED TO THE
;	CALLER.
;
;	R0 = CHARACTER READ.
;-
 
	.ENABL	LSB
MCR$GETCHAR::				;GET NEXT CHARACTER FROM INPUT BUFFER
	PUSHL	R1			;SAVE REGISTER
	BICW	#LOC_M_PRTCOM,WRK_W_LOCFLG(FP) ;Clear partial-line comment flag
NEXTCHAR:				;GET NEXT CHARACTER
	INCL	WRK_L_CHARPTR(FP)	;UPDATE INPUT BUFFER POINTER
10$:	MOVL	WRK_L_CHARPTR(FP),R1	;GET CURRENT CHARACTER POINTER
	MOVZBL	(R1)+,R0		;GET NEXT CHARACTER FROM INPUT BUFFER
	BNEQ	12$			; If NEQ not end of line
	BRW	80$			; It's end of line
12$:
	BBS	#LOC_V_PRTCOM,WRK_W_LOCFLG(FP),14$ ;If we're in a comment, branch
	CMPB	#^A/"/,R0		;QUOTE?
	BNEQ	13$			;IF NEQ NO
	BRW	60$			;EQ, IN QUOTE - BRANCH (Needed a word for branch displ.)
13$:	BBC	#WRK_V_QUOTE,WRK_W_FLAGS(FP),14$ ;Not in quoted string?
	BRW	65$			;We're in a quoted string
14$:	CMPB	#^A/!/,R0		;EXCLAMATION?
	BNEQ	15$			;If NEQ, no
	XORW	#LOC_M_PRTCOM,WRK_W_LOCFLG(FP) ;Toggle partial-line-comment flag
	BRB	NEXTCHAR		;Ignore the begin. or ending exclam. in a comment
15$:
	BBS	#WRK_V_NOCONT,WRK_W_FLAGS(FP),16$ ; Branch if no continuation
	CMPB	#^A/-/,R0		;HYPHEN?
	BEQL	50$			;IF EQL YES
16$:
	BBS	#LOC_V_PRTCOM,WRK_W_LOCFLG(FP),NEXTCHAR ;Ignore comments
	CMPB	#^A/ /,R0		;BLANK?
	BEQL	20$			;IF EQL YES
	CMPB	#^A/@/,R0		;AT SIGN?
	BNEQ	17$			; If NEQ no
	BRW	100$			; Process indirect file
17$:
	CMPB	#^A/	/,R0		;TAB?
	BEQL	19$			;IF EQL YES
	BRW	90$			;IF NEQ NO (Needed full word for branch)
19$:	MOVZBL	#^A/ /,R0		;SET CHARACTER TO A BLANK
20$:	MOVB	R0,@WRK_L_CHARPTR(FP)	;STORE BLANK IN INPUT BUFFER
	BBS	#WRK_V_TABS,WRK_W_FLAGS(FP),40$ ; Branch if no forward conversion
	CMPB	#^A/ /,(R1)+		;NEXT CHARACTER A BLANK?
	BEQL	30$			;IF EQL YES
	CMPB	#^A/	/,-1(R1)	;NEXT CHARACTER A TAB?
	BNEQ	40$			;IF NEQ NO
30$:	INCL	WRK_L_CHARPTR(FP)	;INCREMENT CHARACTER POINTER
	BRB	20$			;
40$:	TSTB	-(R1)			;NEXT CHARACTER END OF LINE?
	BEQL	70$			;IF EQL YES
	CMPB	#^A/!/,(R1)		;NEXT CHARACTER EXCLAMATION?
	BNEQ	45$			;IF NEQ NO
	XORW	#LOC_M_PRTCOM,WRK_W_LOCFLG(FP) ;Toggle partial-line-comment flag
	INCL	WRK_L_CHARPTR(FP)	;Eliminate the exclamation pt.
	BRW	NEXTCHAR		;Ignore comments
45$:	BBS	#WRK_V_NOCONT,WRK_W_FLAGS(FP),EXITCHAR ; Branch if no continuation
	CMPB	#^A/-/,(R1)+		;HYPHEN?
	BNEQ	EXITCHAR		;IF NEQ NO
	SETBIT	WRK_V_TRAILSPC,WRK_W_FLAGS(FP) ;INDICATE TRAILING SPACES SEEN
50$:	TSTB	(R1)			;NEXT CHARACTER END OF LINE?
	BNEQ	55$			;IF NEQ, NO
	BBS	#LOC_V_FULCOM,WRK_W_LOCFLG(FP),75$ ; Branch if in a .GOTO and in a comment
	BRW	INPUT			; Otherwise allow continuation
55$:	CLRBIT	WRK_V_TRAILSPC,WRK_W_FLAGS(FP) ;CLEAR TRAILING SPACE FLAG
	BBC	#LOC_V_PRTCOM,WRK_W_LOCFLG(FP),EXITCHAR ; Exit unless in part-line comment
	BRW	NEXTCHAR		; Throw away partial-line comments
60$:	XORW	#WRK_M_QUOTE,WRK_W_FLAGS(FP) ;INVERT QUOTE FLAG
65$:	BRB	EXITCHAR		;
70$:	BBC	#WRK_V_STAR,WRK_W_FLAGS(FP),75$ ; Branch if not in an expression
	CMPB	-2(R1),#^A/ /		; Was preceeding character a blank?
	BNEQ	EXITCHAR		; No if NEQ so not end of expression
75$:
	CLRB	-(R1)			;SET END OF LINE IN BUFFER
	BRW	10$			;
80$:	BICW	#WRK_M_QUOTE,WRK_W_FLAGS(FP) ;CLEAR QUOTE IN PROGRESS
	DECL	WRK_L_CHARPTR(FP)	;BACK UP INPUT BUFFER POINTER
90$:	CMPB	#^A/a/,R0		;LOWER CASE LETTER?
	BGTRU	EXITCHAR		;IF GTRU NO
	CMPB	#^A/z/,R0		;LOWER CASE LETTER?
	BLSSU	EXITCHAR		;IF LSSU NO
	BICB	#^X20,R0		;CONVERT TO LOWER CASE
EXITCHAR:				;EXIT WITH CHARACTER
	POPL	R1			;RESTORE REGISTER
	TSTB	R0			;SET CONDITION CODES BASED ON CHARACTER
	RSB				;
100$:	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),EXITCHAR ;IF SET, IN GOTO
	BBSS	#PRC_V_IND,PRC_W_FLAGS(R11),EXITCHAR ;IF SET, ALREADY IN @ FILE
	STACKIND			;STACK CURRENT INDIRECT FILE SPECIFICATION
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;CLEAR INDIRECT FILE IN PROGRESS
	BLBS	R0,INPUT		;IF LBS SUCCESS
	.DSABL	LSB
 
;
; ERROR EXIT
;
 
ERROR:	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	FLUSH				;FLUSH INPUT BUFFER
	POPR	#^M<R0>			;RESTORE ERROR/STATUS VALUE
	BRW	STATUS			;
 
;
; CONTINUATION SPECIFIED - READ IN NEXT LINE
;
 
INPUT:					;INPUT NEXT RECORD
	PUSHR	#^M<R2,R3,R4>		;SAVE REGISTERS
REINP:	BBS	#WRK_V_ASK,WRK_W_FLAGS(FP),10$ ;IF SET, QUERY IN PROGRESS
	MOVL	PRC_L_INDINPRAB(R11),R4	;GET ADDRESS OF LEVEL N RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
10$:	MOVL	PRC_L_INPRAB(R11),R4	;GET ADDRESS OF LEVEL 0 RAB
;
; SET UP PROMPT STRING
;
20$:	MOVL	WRK_L_PROMPT(FP),R2	;GET ADDRESS OF PROMPT STRING
	MOVZBL	(R2)+,R1		;SET ADDRESS IN R2, R1=LENGTH
	MOVAB	-MSGBUFSIZ(SP),SP	;ALLOCATE SPACE FOR PROMPT STRING
	MOVL	SP,R0			;SAVE ADDRESS OF PROMPT STRING STORAGE
	MOVL	R0,RAB$L_PBF(R4)	;SET ADDRESS OF PROMPT STRING
	ADDB3	#2,R1,RAB$B_PSZ(R4)	;SET LENGTH OF PROMPT STRING
	MOVW	#<10@8>+13,(R0)+	;INSERT CARRIAGE RETURN/LINE FEED PAIR
30$:	MOVB	(R2)+,(R0)+		;MOVE CHARACTER TO PROMPT BUFFER
	SOBGTR	R1,30$			;ANY MORE TO MOVE?
; 
; READ THE NEXT RECORD OF INPUT
;
	BSBW	MCR$GETINPUT		;READ A LINE OF INPUT
	BLBC	R0,100$			;IF LBC I/O ERROR
35$:	MOVAB	MSGBUFSIZ(SP),SP	;DEALLOCATE PROMPT STRING STORAGE
	PUSHL	R2			;SAVE STARTING ADDRESS OF BUFFER
; 
; CHECK FOR SPECIAL CHARACTERS (COMMENT OR DOLLAR SIGN)
;
50$:	LOCC	(R2)+,#6,B^90$		;CHECK FOR SPECIAL CHARS
	BEQL	60$			;IF EQL NO MATCH
	SUBL	#3,R0			;BLANK OR TAB?
	BLSS	50$			;IF LSS YES
	BEQL	60$			;IF EQL END OF LINE
	DECL	R0			;DOLLAR SIGN OR COMMENT?
	BEQL	55$			;BR IF END OF LINE
	TSTL	(SP)+			;CLEAR ACTUAL START OF LINE
	DECL	R2			;BACKUP TO COMMENT DELIMITER
	CLRL	R4			;FLAG COMMENT LINE
	BRB	65$			;ELSE PRINT THE COMMENT LINE
55$:	BBCS	#31,R3,50$		;BR IF FIRST DOLLAR SIGN SEEN
60$:	POPR	#^M<R2>			;RESTORE LINE BUFFER ADDRESS
62$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),70$ ;IF CLR, NO LINE VERIFICATION
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),70$ ;IF SET, AT CONTROL Y/C LEVEL
	CMPL	R4,PRC_L_INDOUTRAB(R11)	;READ FROM OUTPUT?
	BEQL	70$			;IF EQL YES, DON'T RE-ECHO
65$:	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),70$ ;IF SET, FORWARD GOTO
	CMPB	(R2),#^A/!/		;COULD THIS BE A CONTINUED COMMENT?
	BNEQ	68$			;IF NEQ NO, SO ECHO THE COMMENT LINE
	BBS	#LOC_V_PRTCOM,WRK_W_LOCFLG(FP),70$ ;IF CONTINUED COMMENT, DON'T echo
68$:	MOVB	#13,-(R2)		;INSERT CARRIAGE RETURN IN BUFFER
	LOCC	#0,#INPBUFSIZ,(R2)	;FIND END OF LINE
	SUBL	R2,R1			;AND FROM THAT THE LENGTH OF LINE
	MSGOUT				;OUTPUT INPUT LINE
	BBC	#30,R4,95$		;BR IF RAB ADDRESS IS GONE
;
; IF THE PREVIOUS RECORD ENDED WITH TRAILING SPACES OR TABS, INSERT A
; SPACE AT THE FRONT OF THE CURRENT INPUT BUFFER SO THAT PARAMETERS ARE
; DELIMITED CORRECTLY.
;
70$:	BBCC	#WRK_V_TRAILSPC,WRK_W_FLAGS(FP),80$ ;IF CLR, NO TRAILING SPACE SEEN
	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;INSERT BLANK AT FRONT OF BUFFER
	DECL	WRK_L_CHARPTR(FP)	;BACKUP POINTER TO LEADING SPACE
80$:	POPR	#^M<R2,R3,R4>		;RESTORE REGISTERS
	MOVAB	REPROMPT,WRK_L_PROMPT(FP) ;SET FOR CONTINUATION PROMPT
	BRW	NEXTCHAR		;
 
90$:	.ASCII	/;!$/<0>/ 	/	;SPECIAL CHARACTERS

95$:	BRW	REINP			;READ THE NEXT LINE

;
; INPUT I/O ERROR
;
;	****	NOTE: R2, R3, AND R4 ARE STILL ON THE STACK    ****
;
 
100$:	CMPL	#RMS$_RSA,R0		;ERROR RECORD STREAM ACTIVE
	BNEQ	110$			;IF NO CHECK FOR END_OF_FILE
;
; WE DON'T WANT TO HAVE TO CANCEL AN RMS I/O UNLESS NECESSARY.
; RETRY SEVERAL (1000) TIMES TO ALLOW CURRENT WRITE I/O TO COMPLETE.
; THIS AVOIDS SPURIOUS WRITE ABORT MESSAGES FROM USER PROGRAMS CAUSED
; BY CANCELING AN RMS I/O OPERATION.
;
	MOVZWL	#1000,R2		;INITIALIZE RETRY COUNT
	BBC	#WRK_V_ASK,WRK_W_FLAGS(FP),105$ ;SKIP IF NOT ASKING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R4) ;SET INDIRECT PPF
105$:	$GET	RAB=(R4)		;SEE IF THE WAITING GAVE RMS ENOUGH TIME
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R4) ;CLEAR INDIRECT PPF
	BLBC	R0,107$			;STILL GETTING THE ERROR, TRY AGAIN
	MOVAB	WRK_AB_BUFFER+CMDBUFSIZ+2(FP),R2 ;GET ADDRESS OF INPUT BUFFER
	BSBW	MCR$PREPLINE		;WE'VE GOT THE RECORD! PERFORM SUBST., ETC.
	BRW	35$			;FINISH LINE PREPARATION AS FOR NORMAL $GET
107$:	CMPL	R0,#RMS$_RSA		;RECORD STREAM STILL ACTIVE?
	BNEQ	110$			;IF NEQ NO
	SOBGTR	R2,105$			;RETRY UNTIL STREAM BECOMES INACTIVE
	$CANCEL_S PRC_W_INPCHAN(R11)	;IF STILL ACTIVE, STOP THE IO ON THAT CHANNEL
	$WAIT	RAB=(R4)		;WAIT FOR I/O TO COMPLETE
	MOVAB	MSGBUFSIZ(SP),SP	;DEALLOCATE PROMPT STRING STORAGE
	BRB	150$			;TRY TO READ AGAIN
;
; IF WE ARE AT END OF FILE, TERMINATE THE CURRENT PROCEDURE LEVEL AND 
; READ THE NEXT RECORD FORM THE PREVIOUS PROCEDURE LEVEL.
;
110$:	MOVAB	MSGBUFSIZ(SP),SP	;DEALLOCATE PROMPT STRING STORAGE
	CMPL	#RMS$_EOF,R0		;END OF FILE?
	BNEQ	170$			;IF NEQ NO
115$:	CLRB	(R2)			;SET END OF LINE INDICATOR
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),135$ ;IF SET, AT CONTROL Y/C LEVEL
	BBS	#WRK_V_ASK,WRK_W_FLAGS(FP),135$ ;BR IF DOING AN ASK
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),130$ ;BR IF NOT IN A GOTO
	BBCS	#PRC_V_GOEOF,PRC_W_FLAGS(R11),140$ ; BR IF FIRST EOF ENCOUNTERED
130$:	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BEQL	147$			;IF EQL, YES
	UNSTACK				;UNSTACK INDIRECT FILE
	BLBC	R0,STATUS		;IF LBC UNSTACK ERROR
	BRB	150$			;
135$:	BRW	70$			;CHECK/FIX DELIMITING AND GO ON TO NEXT CHAR.
140$:	$REWIND	RAB=@PRC_L_INDINPRAB(R11) ;REWIND THE INPUT FILE
145$:	BRW	REINP			;READ THE NEXT LINE
147$:	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),150$ ;BR IF INTERACTIVE JOB
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),180$ ;BR IF NO GOTO INPROGRESS
	STATUS	USGOTO			;SET ERROR 
	BRB	170$			;
 
;
; NOW CHECK IF UNSTACK HAS OCCURED WITH INDIRECT FILE RECOGNITION DISABLED.
; IF SO, THIS IS A FLUSH OF A COMMAND WITH "-" AS THE LAST CHARACTER.
; IN THIS CASE, AN EOL MUST BE RETURNED.
;
 
150$:	BBC	#PRC_V_IND,PRC_W_FLAGS(R11),145$ ; BR IF NOT DOING A FLUSH
	BRW	70$			;EXIT WITH EOL
170$:	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(FP) ;INDICATE COMMAND IN PROGRESS
	ERRMSG				;OUTPUT ERROR MESSAGE
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),STATUS ;IF SET, AT CONTROL Y/C LEVEL
	BBS	#WRK_V_ASK,WRK_W_FLAGS(FP),STATUS ; SKIP IF IN ASK
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BNEQ	190$			;IF NEQ NO
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),STATUS ;IF CLR, INTERACTIVE JOB
180$:	BRW	MCR$ABORT		;LOG OUT BATCH JOB
190$:	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	UNSTACK				;UNSTACK INDIRECT FILE
	POPR	#^M<R0>			;RESTORE ERROR/STATUS VALUE
STATUS:	SET_STATUS			;SET COMPLETION STATUS
	BRW	MCR$RESTART		;
	.PAGE
	.SBTTL	GET INPUT DATA
;+
; MCR$GETINPUT - GET INPUT DATA
;
; THIS ROUTINE IS CALLED TO READ A LINE OF DATA INTO THE INPUT BUFFER
;
; INPUTS:
;
;	R4 = RAB TO USE IN THE READ
;
; OUTPUT:
;
;	R0 = STATUS OF THE READ
;	R2 = ADDRESS OF THE START OF THE LINE
;	WRK_L_CHARPTR IS SET TO POINT 1 BEFORE THE FIRST CHARACTER READ.
;	THE LINE IS TERMINATED WITH A ZERO.
;-
MCR$GETINPUT::
	MOVZBW	#INPBUFSIZ,RAB$W_USZ(R4) ;SET SIZE OF INPUT BUFFER
	MOVAB	WRK_AB_BUFFER+CMDBUFSIZ+2(FP),R2 ;GET ADDRESS OF INPUT BUFFER
	MOVL	R2,RAB$L_UBF(R4)	;SET ADDRESS OF INPUT BUFFER
	MOVAB	-1(R2),WRK_L_CHARPTR(FP) ;SET POINTER FOR GET CHARACTER
	DISABLE				;DISABLE CONTROL Y/C AST'S
	BBC	#WRK_V_ASK,WRK_W_FLAGS(FP),10$ ;SKIP IF NOT ASKING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)	;SET INDIRECT PPF
10$:
	$GET	RAB=(R4)		;GET NEXT RECORD FROM INPUT FILE
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R4)	;CLEAR INDIRECT PPF
	ENABLE				;ENABLE CONTROL Y/C AST'S
;
; WE HAVE OBTAINED THE NEXT RECORD FROM THE INPUT FILE.  NOW WE MUST CLEAN UP
; AND CHECK FOR POSSIBLE SUBSTITUTION IN THIS LINE.
;
MCR$PREPLINE::
	MOVZWL	RAB$W_RSZ(R4),R3	;GET LENGTH OF INPUT RECORD
	BLBC	R0,30$			;BR IF IO ERROR
	CLRB	(R2)[R3]		;SET EOL INDICATOR
	BBC	#MCR_V_STRSUB,PRC_W_CLIFLAG(R11),30$ ;BR IF SUBSTITUTION DISABLED
	LOCC	#^A/'/,R3,(R2)		;LINE HAVE POSSIBLE STRING SUBSTITUTION?
	BEQL	20$			;IF EQL NO
	BSBB	EXPAND			;EXPAND LINE IF APPROPRIATE
	RSB
20$:	STATUS	NORMAL			;
30$:	RSB				;RETURN WITH STATUS
	.PAGE
	.SBTTL	EXPAND INPUT LINE
;
; SUBROUTINE TO EXPAND INPUT LINE BY EXECUTING ALL STRING SUBSTITUTION COMMANDS
;
 
EXPAND:					;EXPAND INPUT LINE
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,AP> ;SAVE REGISTERS
	CLRL	-(SP)			;INITIALIZE SUBST. DEPTH COUNTER
	MOVL	R2,R10			;COPY ADDRESS OF INPUT BUFFER
10$:	MOVZBL	(R10)+,R0		;GET NEXT CHARACTER FROM INPUT LINE
	CMPB	#^A/'/,R0		;STRING SUBSTITUTION COMMAND?
	BNEQ	70$			;IF NEQ NO
	CMPB	(R10),#^A/'/		;IS THIS A REQUEST FOR A HYPHEN
	BNEQ	20$			;BR IF SUBSTITUTION COMMAND
	MOVZBL	(R10)+,R0		;GET THE HYPHEN
	BRB	70$			;INSERT THAT IN THE BUFFER
20$:	PUSHL	R9			;SAVE PLACE IN COMMAND BUFFER
	GETXSYM				;GET EXPANSION SYMBOL
	BEQL	50$			;IF EQL ZERO LENGTH SYMBOL
	MOVQ	R1,R6			;SAVE STRING PARAMETERS
	SEARCH				;SEARCH FOR SYMBOL
	BLBS	R0,30$			;IF LBS SYMBOL DEFINITION FOUND
	BSBW	MCR$LEXIF		;EVALUATE LEXICAL FUNCTION
30$:	CMPW	#^A/.'/,(R10)		;CONDITIONAL DECIMAL POINT COMING
	BNEQ	35$			;BR IF NO
	MOVB	(R10)+,(R10)+		;COPY DOT OVER SINGLE QUOTE
	CMPB	#SYM_K_DECIMAL,SYM_B_TYPE(R3) ;SYMBOL TYPED AS DECIMAL
	BNEQ	35$			;BR IF NO
	DECL	R10			;BACK OVER DOT TO LEAVE IT IN OUTPUT
35$:	CMPB	#^A/'/,(R10)		;SYMBOL TERMINATED BY SINGLE QUOTE
	BNEQ	40$			;IF NOT EQL THEN NO
	INCL	R10			;SKIP TRAILING QUOTE
40$:	SUBL	R1,R10			;CALCULATE ADDRESS TO COPY STRING
	MOVC	R1,(R2),(R10)		;CONCATENATE STRING TO INPUT BUFFER
50$:	POPL	R9			;RETRIEVE ADDRESS IN COMMAND BUFFER
	ACBW	#999.,#1,(SP),10$	;CHECK FOR A MAX. OF 1000 SUBSTITUIONS
	BRB	80$			;CLEANUP FOR EXIT WITH ERROR STATUS
70$:	PUTCHAR				;PUT CHARACTER IN COMMAND BUFFER
	BNEQ	10$			;IF NEQ MORE CHARACTERS TO SCAN
80$:	POPL	R4			;TAKE THE ITERATION COUNTER OFF THE STACK
	MOVL	5*4(SP),R7		;GET STARTING ADDRESS OF EXPANDED LINE
	SUBL	R7,R9			;CALCULATE LENGTH OF EXPANDED LINE
	MOVAB	WRK_AB_BUFFER+CMDBUFSIZ+INPBUFSIZ(FP),R8 ;FIND END OF BUFFERS
	SUBL	R9,R8			;COMPUTE ADDRESS TO MOVE LINE TO
	PUSHL	R4			;PUT SUBST. COUNT BACK ON STACK TO PRESERVE
	MOVC	R9,(R7),(R8)		;MOVE EXPANDED LINE TO END OF INPUT BUFFER
	CMPL	#1000.,(SP)+		;REACHED THE SUBST. LIMIT?
	BGTR	90$			;IF NEQ NO
	STATUS	EXPSYN			;PREVENTING INFINTE LOOPING RECURSIVE SUBST.
	BRB	100$			;
90$:	STATUS 	NORMAL			;
100$:	MOVQ	R8,R2			;SET INPUT LINE PARAMETERS
	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,AP> ;RESTORE REGISTERS
	MOVAB	-1(R2),WRK_L_CHARPTR(FP) ;SET ADDRESS OF EXPANDED INPUT LINE
	RSB				;
	.PAGE
	.SBTTL	GET EXPANSION SYMBOL
;+
; MCR$GETXSYM - GET EXPANSION SYMBOL
;
; THIS ROUTINE IS CALLED TO ISOLATE THE NEXT SYMBOL DURING A LINE EXPANSION.
;
; INPUTS:
;
;	R9 = ADDRESS OF NEXT CHARACTER IN OUTPUT BUFFER.
;	R10 = ADDRESS OF NEXT CHARACTER IN INPUT BUFFER.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EXPANSION SYMBOL.
;	R2 = ADDRESS OF EXPANSION SYMBOL.
;	R9 AND R10 UPDATED AS APPROPRIATE.
;
;	CONDITION CODES SET BASED ON LENGTH OF SYMBOL.
;-
 
MCR$GETXSYM::				;GET EXPANSION SYMBOL
	MOVL	R9,R2			;COPY STARTING ADDRESS OF SYMBOL
10$:	LOCC	(R10),#ENDTERM-TERMTAB,TERMTAB ;SEARCH FOR TERMINATOR
	BEQL	20$			;BR IF NO TERMINATOR
	CMPB	#^A/</,(R10)		;START OF SPECIAL SYMBOL
	BEQL	30$			;BR IF YES
	CMPB	#^A/>/,(R10)		;END OF SPECIAL SYMBOL
	BNEQ	60$			;BR IF REAL END OF SYMBOL
20$:	CMPB	#^A/	/,(R10)		;TAB CHARACTER?
	BEQL	60$			;IF EQL YES
30$:	MOVZBL	(R10)+,R0		;GET CHARACTER FROM INPUT BUFFER
	BEQL	50$			;IF EQL END OF LINE
	CMPB	#^A/a/,R0		;LOWER CASE LETTER?
	BGTRU	40$			;IF GTRU NO
	CMPB	#^A/z/,R0		;LOWER CASE LETTER?
	BLSSU	40$			;IF LSSU NO
	BICB	#^X20,R0		;CONVERT TO UPPER CASE
40$:	PUTCHAR				;PUT CHARACTER IN COMMAND BUFFER
	BRB	10$			;
50$:	DECL	R10			;BACK UP TO TERMINATOR
60$:	SUBL3	R2,R9,R1		;CALCULATE LENGTH OF SYMBOL
	RSB				;
 
	.END
