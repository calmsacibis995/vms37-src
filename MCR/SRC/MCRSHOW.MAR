	.TITLE	MCRSHOW - SHOW INFORMATION MCR COMMAND EXECUTION
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 15-APR-77
;
; Modified by:
;
;	V03.01	MAJ0001		Melanie Johnson	17-Mar-1982
;		Properly delimit the continued ASCIC string, FAO_STRING, to
;		work with the fixed assembler.
;
;	V01.01	RN0019		R. Newland	 6-Jan-1980
;		Remove SHOW LOGICAL which is now an external image,
;		Add SHOW QUOTA command.
; MODIFIED BY B. WALTHER 3-DEC-1977
;
; SHOW INFORMATION MCR COMMAND EXECUTION
;
;	SHOW DAYTIME
;	SHOW DEFAULT DIRECTORY AND DEVICE
;	SHOW LOGICAL NAME EQUIVALENCES
;	SHOW PROTECTION
;	SHOW STATUS
;	SHOW DISK QUOTA AND USAGE

;
; MACRO LIBRARY CALLS
;
 
	$CLIDEFQUALSHOW			;DEFINE SHOW QUALIFIER NUMBERS
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	DEFSYMTBL			;DEFINE SYMBOL ENTRY OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$JPIDEF				;GET JOB PROCESS INFORMATION DEFINITIONS
;
; Define system structures used
;
	$DQFDEF				; format of disk quota file record
	$FIBDEF				; format of FIB (ACP interface block)
 
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
ACCESS:					;ALLOWED ACCESS DESIGNATORS
	.ASCII	/RWED/			;
FORMATMSG:				;TABLE DISPLAY CONTROL STRING
	.ASCII	/  !AS = !AS   !AC/	;
FORMATEND:				;
NOACCESS:				;NO ACCESS ALLOWED DESIGNATOR
	.ASCII	/NO ACCESS/		;
NOACCESSEND:				;
PROTECTMSG:				;DEFAULT PROTECTION CONTROL STRING
	.ASCII	/  SYSTEM=!AD, OWNER=!AD, GROUP=!AD, WORLD=!AD/ ;
PROTECTEND:				;
STATUS_MSG:				;
	.ASCII	-			;
	&  Status on  !%D!_ Elapsed CPU :!%D&;
	.ASCII	-			;
	&!/  Buff. I/O :  !5UW!_Cur. ws. :   !5UW!_Open files :     !5UW&;
	.ASCII	-			;
	&!/  Dir. I/O :   !5UW!_Phys. Mem. : !5UW!_Page Faults :!9UL&;
STATUS_END:				;
LOG_NAME_TABLE:				;OFFSETS TO TEXT STRINGS
	.BYTE	TEXT_T_NULLSTR-LOG_NAME_TABLE;
	.BYTE	TEXT_T_SYSTEM-LOG_NAME_TABLE;
	.BYTE	TEXT_T_GROUP-LOG_NAME_TABLE;
	.BYTE	TEXT_T_PROCESS-LOG_NAME_TABLE;
TEXT_T_SYSTEM:				;
	.ASCIC	/(system)/		;
TEXT_T_GROUP:				;
	.ASCIC	/(group)/		;
TEXT_T_PROCESS:				;
	.ASCIC	/(process)/		;
TEXT_T_NULLSTR:				;
	.LONG	0			;NULL STRING
JPI_CODES:				;LIST OF JPI ITEM CODES
FAO_CPUTIM=<.-JPI_CODES>*2		;FOR SHOW STATUS
	.WORD	JPI$_CPUTIM		;
	.WORD	JPI$_BUFIO		;
FAO_WSSIZE=<.-JPI_CODES>*2		;
	.WORD	JPI$_WSSIZE		;
	FAO_FILLM=<.-JPI_CODES>*2	;
	.WORD	JPI$_FILLM		;
	.WORD	JPI$_DIRIO		;
FAO_GPGCNT=<.-JPI_CODES>*2		;
	.WORD	JPI$_GPGCNT		;
	.WORD	JPI$_PAGEFLTS		;
FAO_FILCNT=<.-JPI_CODES>*2		;
FAO_Q_CPU=FAO_FILCNT			;USE THIS LOCATION TWICE
	.WORD	JPI$_FILCNT		;
FAO_PPGCNT=<.-JPI_CODES>*2		;
	.WORD	JPI$_PPGCNT		;
JPI_ARGS = <.-JPI_CODES>/2		;COMPUTE NUMBER OF JPI CODES
	.PAGE
	.SBTTL	SHOW DEFAULT
;+
; MCR$SHOWDEF - SHOW DEFAULT DEVICE AND DIRECTORY
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW 
; DEFAULT DEVICE AND DIRECTORY MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT DIRECTORY IS WRITTEN TO THE OUTPUT STREAM.
;-
 
MCR$SHOWDEF::				;SHOW DEVICE AND DIRECTORY INFORMATION
	ADDL	#2,4(R8)		;MAKE ROOM FOR LEADING SPACES
	MOVAB	W^MCR$T_DSKNAM,R1	;ADDRESS OF DISK NAME COUNTED STRING
	MOVZBL	(R1)+,R0		;GET QUAD WORD DESCRIPTOR
	PUSHR	#^M<R0,R1>		;PUT QUAD WORD DESCRIPTOR IN STACK
	CLRQ	-(SP)			;FIRST TWO ARGS ARE ZERO
	CLRL	-(SP)			;ALSO THIRD IS ZERO
	PUSHAQ	(R8)			;ADDRESS OF BUFFER DESCRIPTOR
	PUSHAW	(R8)			;PLACE TO RESTORE LENGTH
	PUSHAQ	20(SP)			;ADDRESS OF DESCRIPTOR IN STACK
	CALLS	#8,@#SYS$TRNLOG		;TRANSLATE AND CLEAR THE STACK
	ADDL3	(R8)+,(R8),R2		; FIND FIRST BYTE AFTER DEVICE NAME
	MOVAB	@#PIO$GT_DDSTRING,R1	;GET ADDRESS OF DEFAULT DIRECTORY STRING
	MOVZBL	(R1)+,R0		;GET LENGTH OF DEFAULT DIRECTORY STRING
	MOVC	R0,(R1),(R2)		;INSERT DEFAULT DIRECTORY STRING
	MOVL	(R8),R2			;POINT AT START OF DEVICE NAME
	MOVW	#^A/  /,-(R2)		;INSERT LEADER FOR NEATNESS
	SUBL3	R2,R3,R1		;FIND LENGTH OF STRING
	BRW	EXTMSG			;
	.PAGE
	.SBTTL	SHOW LOGICAL NAME EQUIVALENCES
;+
; MCR$SHOWLOG  - SHOW LOGICAL NAME EQUIVALENCES
;;
; MCR$SHOWTRAN - SHOW LOGICAL NAME TRANSLATION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW LOGICAL
; NAME EQUIVALENCES MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME EQUIVALENCE OR ALL LOGICAL NAME EQUIVALENCES
;	FROM THE PROCESS LOGICAL NAME TABLE ARE WRITTEN TO THE OUTPUT STREAM.
;-
 
MCR$SHOWTRAN::				;SHOW THE TRANSLATION FOR A NAME
	TSTL	(R10)+			;SKIP OPTION NAME
	GETDVAL				;SEPARATE DESCRIPTOR
	COMPSTRING			;REMOVE QUOTES IF THERE
	CLRL	-(R9)			;RESERVE LOCATION FOR RESULTANT TABLE
	MOVQ	R1,-(R9)		;SAVE STRING DESCRIPTOR
	ADDL3	#60,4(R8),-(R9)		;BUILD EQUIVALENCE NAME DESCRIPTOR
	MOVZBL	#LOG$C_NAMLENGTH-1,-(R9) ;
	$TRNLOG_S 8(R9),(R9),(R9),16(R9),,R0;TRANSLATE LOGICAL NAME IN SPECIFIED TABLE
	CMPL	R0,#SS$_NORMAL		;TEST FOR SUCCESSFUL TRANSLATION
	BEQLU	10$			;BRANCH IF SUCCESS
	CLRW	(R9)			;ELSE CLEAR BYTE COUNT OF RESULTANT STRING
	BRW	DISPITEM		;AND GO DISPLAY ITEM
10$:	MOVZBL	16(R9),R3		;GET RESULTANT TABLE
	INCL	R3			;INDEX INTO TEXT TABLE
	BRW	DISPTRANS		;DISPLAY ITEM
	.PAGE
	.SBTTL	SHOW PROTECTION
;+
; MCR$SHOWPROT - SHOW PROTECTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW PROTECTION
; MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT PROTECTION IS CONVERTED TO ASCII AND WRITTEN TO
;	THE OUTPUT STREAM.
;-
 
MCR$SHOWPROT::				;SHOW PROTECTION INFORMATION
	MOVZWL	@#PIO$GW_DFPROT,R0	;GET DEFAULT PROTECTION
	MOVZBL	#12,R7			;SET OUTER LOOP INDEX
10$:	CLRL	-(SP)			;ALLOCATE SPACE FOR ACCESS DESIGNATORS
	MOVAB	NOACCESS,-(R9)		;ASSUME NO ACCESS ALLOWED
	MOVZBL	#NOACCESSEND-NOACCESS,-(R9) ;
	EXTZV	R7,#4,R0,R1		;EXTRACT NEXT PROTECTION FIELD
	MCOML	R1,R2			;COMPLEMENT PROTECTION FIELD
	BITL	#^XF,R2			;ALL ACCESS DENIED?
	BEQL	40$			;IF EQL YES
	CLRL	R6			;CLEAR INNER LOOP INDEX
	MOVAB	(SP),4(R9)		;SET ADDRESS OF ACCESS DESIGNATORS
	CLRL	(R9)			;CLEAR COUNT OF ACCESS DESIGNATORS
20$:	BBS	R6,R1,30$		;IF SET, ACCESS DENIED
	MOVB	ACCESS[R6],@(R9)[SP]	;INSERT ACCESS DESIGNATOR
	INCL	(R9)			;INCREMENT COUNT OF ACCESS DESIGNATORS
30$:	AOBLSS	#4,R6,20$		;ANY MORE TO CHECK?
40$:	ACBB	#0,#-4,R7,10$		;ANY MORE FIELDS TO CHECK?
	PUSHAB	PROTECTMSG		;BUILD FORMAT CONTROL STRING DESCRIPTOR
	PUSHL	#PROTECTEND-PROTECTMSG	;
	MOVL	SP,R0			;COPY ADDRESS OF CONTROL STRING DESCRIPTOR
	$FAOL_S	(R0),(R8),(R8),(R9)	;FORMAT PROTECTION MESSAGE
	MOVQ	(R8),R1			;RETRIEVE OUTPUT MESSAGE PARAMETERS
	ADDL	#6*4,SP			;CLEAN STACK
	BRW	EXTMSG			;
	.PAGE
	.SBTTL	SHOW SYMBOL TABLE ENTRIES
;+
; MCR$SHOWSYMBOL - SHOW SYMBOL TABLE ENTRIES
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW SYMBOL
; TABLE ENTRIES MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED SYMBOL TABLE ENTRY OR ALL SYMBOL TABLE ENTRIES FROM
;	EITHER THE LOCAL OR GLOBAL SYMBOL TABLE ARE WRITTEN TO THE OUTPUT
;	STREAM.
;-
 
MCR$SHOWSYMBL::				;SHOW SYMBOL TABLE ENTRIES
	TSTL	(R10)+			;SKIP PAST OPTION DESCRIPTOR
10$:	MOVZBL	#PRC_Q_LOCAL-PRC_Q_GLOBAL,R7 ;SET OFFSET TO LOCAL SYMBOL TABLE
20$:	GETDVAL				;GET NEXT DESCRIPTOR VALUE
	CMPB	#PTR_K_PARAMETR,R5	;PARAMETER?
	BEQL	40$			;IF EQL YES
	CMPB	#PTR_K_ENDLINE,R5	;END OF LINE?
	BEQL	30$			;IF EQL YES
	CMPB	#CLI$K_SHSY_ALL,R1	;'ALL' QUALIFIER?
	BEQL	20$			;IF EQL YES
	CLRL	R7			;SET OFFSET TO GLOBAL SYMBOL TABLE
	CMPB	#CLI$K_SHSY_GLOB,R1	;'GLOBAL' QUALIFIER?
	BEQL	20$			;IF EQL YES
	BRB	10$			;
 
;
; DISPLAY ALL SYMBOL ENTRIES
;
 
30$:	MOVAB	PRC_Q_GLOBAL(R11)[R7],R10 ;GET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVZBL	#SYM_T_SYMBOL,R7	;SET OFFSET TO SYMBOL NAME
	BRB	DISPLIST		;DISPLAY LIST
 
;
; DISPLAY SPECIFIED SYMBOL VALUE
;
 
40$:	COMPSTRING			;COMPRESS STRING AND BUILD DESCRIPTOR
	MOVQ	R1,-(R9)		;SAVE SYMBOL ENTRY DESCRIPTOR
	CLRQ	-(R9)			;ASSUME SYMBOL NOT DEFINED
	MOVAB	PRC_Q_GLOBAL(R11)[R7],R0 ;GET ADDRESS OF SYMBOL TABLE LISTHEAD
	SEARCHT				;SEARCH SPECIFIC SYMBOL TABLE
	BLBC	R0,DISPITEM		;IF LBC SEARCH FAILURE
	MOVZBL	SYM_T_SYMBOL(R3),R2	;GET LENGTH OF SYMBOL
	MOVAB	SYM_T_SYMBOL+1(R3)[R2],R2 ;GET ADDRESS OF VALUE LENGTH
	MOVZBL	(R2)+,R1		;GET LENGTH OF VALUE
	MOVQ	R1,(R9)			;SAVE VALUE DESCRIPTOR
	BRB	DISPITEM		;DISPLAY ITEM
	.PAGE
	.SBTTL	DISPLAY LIST
;
; DISPLIST - DISPLAY LIST OF ENTRIES
;
; THIS ROUTINE DISPLAYS A LIST OF LOGICAL OR SYMBOL NAMES.
;
 
DISPLIST:				;DISPLAY LIST
	MOVL	R10,AP			;COPY ADDRESS OF NAME TABLE LISTHEAD
10$:	MOVL	(R10),R10		;GET ADDRESS OF NEXT ENTRY
	CMPL	R10,AP			;END OF TABLE?
	BEQL	20$			;IF EQL YES
	MOVAB	1(R10)[R7],-(R9)	;BUILD NAME DESCRIPTOR
	MOVZBL	(R10)[R7],-(R9)		;
	ADDL3	(R9),4(R9),-(R9)	;BUILD VALUE OR EQUIVALENCE NAME DESCRIPTOR
	MOVZBL	@(R9),-(R9)		;
	INCL	4(R9)			;
	BSBB	DISPITEM		;FORMAT AND OUTPUT ENTRY
	ADDL	#24,R9			;ADJUST SCRATCH STACK POINTER
	MOVZBL	#MSGBUFSIZ,(R8)		;RESET SCRATCH BUFFER DESCRIPTOR SIZE
	BRB	10$			;
20$:	RSB				;
	.PAGE
	.SBTTL	DISPLAY ITEM
;
; DISPITEM - DISPLAY ITEM
;
; THIS ROUTINE IS CALLED TO DISPLAY A LOGICAL OR SYMBOL NAME.
;
; DISPTRANS - DISPLAY TRANSLATION 
;
;  INPUT:  R3 = INDEX INTO LOGICAL NAME TABLE TEXT TABLE
;
 
DISPITEM:				;DISPLAY ITEM
	CLRL	R3			;MAKE SURE WE POINT TO NULL STRING
DISPTRANS:
	MOVAB	LOG_NAME_TABLE,R4	;GET ADDRESS OF TEXT TABLE
	ADDL2	R4,R3			;POINT TO CORRECT ENTRY
	MOVZBL	(R3),R3			;AND GET OFFSET TO TEXT
	ADDL2	R4,R3			;COMPUTE POINTER TO TEXT
	MOVAB	(R9),R4			;GET ADDRESS OF VALUE DESCRIPTOR
	TSTL	(R4)			;ZERO LENGTH VALUE?
	BEQL	20$			;IF EQL YES
	CMPB	#27,@4(R4)		;FIRST CHARACTER ESCAPE?
	BNEQ	20$			;IF NEQ NO
	SUBL	#4,(R4)			;REDUCE LENGTH OF VALUE BY HEADER
	BGEQ	10$			;IF GEQ OKAY
	CLRL	(R4)			;CLEAR VALUE LENGTH
10$:	ADDL	#4,4(R4)		;POINT PAST VALUE HEADER
20$:	MOVAB	8(R9),R5		;GET ADDRESS OF NAME DESCRIPTOR
	MOVAB	FORMATMSG,-(R9)		;BUILD FORMAT CONTROL STRING DESCRIPTOR
	MOVZBL	#FORMATEND-FORMATMSG,-(R9) ;
	$FAO_S	(R9),(R8),(R8),R5,R4,R3
					;FORMAT OUTPUT MESSAGE
	MOVQ	(R8),R1			;GET OUTPUT MESSAGE PARAMETERS
	BRW	EXTMSG			;OUTPUT MESSAGE
	.PAGE
	.SBTTL	SHOW STATUS
;+
;
; MCR$SHOWSTAT - SHOW STATUS
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW STATUS
; MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	 VALUES CHARACTERIZING THE CURRENT PROCESS'S STATUS
;	ARE FORMATTED AND WRITTEN TO THE OUTPUT STREAM.
; SIDE EFFECTS:
;
;	THIS ROUTINE IS USING THE COMMAND BUFFER INSTEAD OF THE SCRATCH BUFFER
;	(THE LATTER IS USED AS SCRATCH STACK)
;-
 
MCR$SHOWSTAT::

;
; BUILD DESCRIPTOR TO COMMAND BUFFER
;

	PUSHL	R8			;SAVE DESCRIPTOR TO SCRATCH BUFFER
	MOVL	4(R8),R8		;BUILD DESCRIPTOR TO COMMAND BUFFER
					;IN SCRATCH BUFFER
	MOVL	#CMDBUFSIZ,(R8)		;LENGTH OF BUFFER
	MOVAL	WRK_AB_BUFFER(FP),4(R8)	;POINTER TO START OF COMMAND BUFFER

;
; INITIALIZE POINTERS AND INDEXES
;

 	MOVL	4(R8),R0		;POINTER TO SCRATCH BUFFER
	CLRL	R1			;INDEX INTO JPI RESULTANT LIST
	SUBL2	#JPI_ARGS*4,R9		;ALLOCATE JPI RESULTANT LIST

;
; CONSTRUCT LIST OF JPI ITEM DESCRIPTOR BLOCKS IN SCRATCH BUFFER
;

10$:	MOVW	#4,(R0)			;LENGTH OF RESULT (=LONGWORD)
	MOVW	JPI_CODES[R1],2(R0)	;JPI CODE
	MOVAL	(R9)[R1],4(R0)		;POINTER TO RESULT BUFFER (=LONGWORD)
	CLRL	8(R0)			;NO NEED FOR RESULTANT LENGTH
	ADDL2	#12,R0			;POINT TO NEXT ITEM DESCRIPTOR 
	AOBLEQ	#JPI_ARGS-1,R1,10$	;REPEAT FOR EACH ITEM IN LIST
	CLRL	(R0)			;END ITEM LIST
;
; GET JOB PROCESS PARAMETERS
;

	$GETJPI_S	ITMLST=@4(R8)	;

;
; PERFORM SOME ARITHMETIC ON VALUES OBTAINED
;

	SUBL2	FAO_FILCNT(R9),FAO_FILLM(R9);COMPUTE COUNT OF OPEN FILES
	ADDL2	FAO_PPGCNT(R9),FAO_GPGCNT(R9);COMPUTE TOTAL PHYSICAL MEMORY OCCUPIED
	EMUL	#-100000,FAO_CPUTIM(R9),#0,FAO_Q_CPU(R9)
					;CALCULATE TIME IN 100NS UNITS
	MOVAL	FAO_Q_CPU(R9),FAO_CPUTIM(R9);REPLACE BY POINTER TO QUADWORD
	CLRL	-(R9)			;INSERT SYSTEM TIME AND DATE AT TOP

;
; FORMAT AND PRINT INFORMATION
;

	PUSHAB	W^STATUS_MSG		;FAO MESSAGE TEXT
	PUSHL	#STATUS_END-STATUS_MSG	;LENGTH OF MESSAGE
	MOVL	SP,R0			;
	$FAOL_S	(R0),(R8),(R8),(R9)	;BUILD MESSAGE IN SCRATCH BUFFER
	MOVQ	(R8),R1			;DESCRIPTOR OF MESSAGE
	ADDL	#2*4,SP			;CLEAN STACK
	POPR	#^M<R8>			;RESTORE SCRATCH BUFFER DESCRIPTOR
	BRW	EXTMSG			;GO OUTPUT MESSAGE

	.PAGE
	.SBTTL	SHOW DAYTIME
;+
; MCR$SHOWTIME - SHOW DAYTIME
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW DAYTIME
; MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT TIME AND DATE ARE CONVERTED TO ASCII AND WRITTEN TO THE
;	OUTPUT STREAM.
;-
 
MCR$SHOWTIME::				;SHOW TIME AND DATE INFORMATION
	MOVL	4(R8),R2		;GET ADDRESS OF SCRATCH BUFFER
	MOVW	#^A/  /,(R2)		;INSERT LEADING BLANKS
	ADDL	#2,4(R8)		;POINT PAST LEADING BLANKS
	$ASCTIM_S ,(R8)			;CONVERT CURRENT TIME TO ASCII
	MOVZWL	#22,R1			;SET LENGTH OF OUTPUT MESSAGE
EXTMSG:	MSGOUT				;OUTPUT MESSAGE TEXT
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;

	.SBTTL	SHOW DISK QUOTA
;++
;
; Functional Description:
;
;
;	This routine assigns a channel to the specified disk and examines
;	this quota file entry belonging to the process' UIC, and outputs
;	the formatted result to SYS$OUTPUT.
;
; Calling Sequence:
;	JSB
;
; Input Parameters:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; Implicit Inputs:
;	none
;
; Output Parameters:
;	none
;
; Implicit Outputs:
;	none
;
; Routines Called:
;	none
;
; Routine Value:
;	none
;
; Signals:
;	none
;
; Side Effects:
;	none
;
;--

;
; Local stack usage
;
	.PSECT	MCR$ABS,ABS

UIC_LIST:	.BLKL	3		; GETJPI item list to read UIC
					; RE-USED FOR TRANSLATING SYS$DISK
IO_STATUS:	.BLKQ	1		; I/O status block
FIB:		.BLKB	FIB$C_LENGTH	; FIB for ACP function
FIB_DESC:	.BLKQ	1		; descriptor for FIB
RECORD_DESC:	.BLKQ	1		; quota record buffer descriptor
					; re-use for FAO string descriptor
QUOTA_RECORD:	.BLKB	DQF$C_LENGTH	; quota record buffer
DEVNAM_DESC:	.BLKQ	1		; device name descriptor
CHANNEL:	.BLKL	1		; channel number
IMPURE_SIZE:

;
; FAO control strings
;
	.PSECT	MCR$ZCODE

					; NOTE - ONLY SINGLE BYTE UIC FIELDS

FAO_STRING:	.ASCIC	'  User [!OB,!OB] has !SL blocks used, !SL !AC,' -
'!/  of !SL authorized and permitted overdraft' -
'of !SL blocks on !AS'
AVAIL:	.ASCIC	/available/
OVER:	.ASCIC	/OVERDRAWN/

MCR$SHOWQUOTA::
	MOVAB	-IMPURE_SIZE(R9),R9		;ALLOCATE LOCAL STACK STORAGE
	MOVC5	#0,(R9),#0,#IMPURE_SIZE,(R9)	;INITIALLY ZERO
	MOVL	#DQF$C_LENGTH,RECORD_DESC(R9)	;SET QUOTA RECORD
	MOVAB	QUOTA_RECORD(R9),RECORD_DESC+4(R9) ;DESCRIPTOR
	MOVL	#FIB$C_LENGTH,FIB_DESC(R9)	;AND DESCRIPTOR FOR ACP
	MOVAB	FIB(R9),FIB_DESC+4(R9)		;FUNCTION
	CLRL	-(SP)				;ASSUME NO UIC SPECIFIED
10$:
	GETDVAL				;GET NEXT RESULT PARSE DESCRIPTOR
20$:
	CMPB	#PTR_K_ENDLINE,R5	;END OF LINE?
	BEQL	100$			;IF EQL YES
	CMPB	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	10$			;IF NEQ NO, IGNORE IT
	CMPB	#CLI$K_SHQO_DISK,R1	;DISK QUALIFIER?
	BNEQ	40$			;IF NEQ NO
	GETDVAL				;ATTEMPT TO GET VALUE
	CMPB	#PTR_K_QUALVALU,R5	;IS IT A VALUE DESCRIPTOR
	BNEQ	20$			;IF NEQ NO
	MOVQ	R1,DEVNAM_DESC(R9)	;STORE DEVICE DESCRIPTOR
	BRB	10$			;AND GO AGAIN
40$:
	CMPB	#CLI$K_SHQO_USER,R1	;USER QUALIFIER?
	BNEQ	10$			;IF NEQ NO, IGNORE IT
	GETDVAL				;ATTEMPT TO GET VALUE
	CMPB	#PTR_K_QUALVALU,R5	;QUALIFIER VALUE?
	BNEQ	20$			;GO TRY SOMETHING ELSE
	INCL	(SP)			;FLAG UIC WAS SPECIFIED
	MOVL	R2,R5			;SAVE ADDRESS OF UIC STRING
	CMPB	#^A/[/,(R5)		;LEADING DELIMITER BRACKET?
	BNEQ	70$			;IF NEQ NO
	BSBW	MCR$CVTUIC		;CONVERT GROUP NUMBER
	CMPB	#^A/,/,(R5)		;FOLLOWED BY COMMA?
	BNEQ	70$			;IF NEQ NO
	MOVW	R0,QUOTA_RECORD+DQF$L_UIC+2(R9);SAVE GROUP NUMBER
	BSBW	MCR$CVTUIC		;CONVERT MEMBER NUMBER
	CMPB	#^A/]/,(R5)		;TRAILING BRACKET?
	BEQL	80$			;IF EQL YES
70$:
	TSTL	(SP)+			;CLEAN INDICATOR FROM STACK
	STATUS	INVUIC			;UIC SYNTAX ERROR
	BRW	99$			;EXIT WITH ERROR
80$:
	MOVW	R0,QUOTA_RECORD+DQF$L_UIC(R9);SAVE UIC MEMBER NUMBER
	BRW	10$			;GO FOR ANOTHER RESULT PARSE PIECE
100$:
	TSTL	(SP)+			;WAS UIC SPECIFIED?
	BNEQ	110$			;IF NEQ YES
	MOVL	#4+<JPI$_UIC@16>,UIC_LIST(R9);SET UP GETJPI FOR
	MOVAB	QUOTA_RECORD+DQF$L_UIC(R9),UIC_LIST+4(R9) ;FOR GETTING UIC
	$GETJPI_S	ITMLST = UIC_LIST(R9);GET THIS PROCESS UIC
110$:
	MOVAB	DEVNAM_DESC(R9),R2	;GET ADDRESS OF DEVICE DESCRIPTOR
	TSTW	(R2)			;DEVICE SPECIFIED?
	BNEQ	115$			;IF NEQ YES
	MOVL	#12,(R2)		;SET 12 CHARACTER DESCRIPTOR
	MOVAB	UIC_LIST(R9),4(R2)	;FOR TRANS. OF SYS$DISK
	MOVAB	W^MCR$T_DSKNAM,R1	;ADDRESS OF DISK NAME COUNTED STRING
	MOVZBL	(R1)+,R0		;GET QUAD WORD DESCRIPTOR
	PUSHR	#^M<R0,R1>		;PUT QUAD WORD DESCRIPTOR IN STACK
	CLRQ	-(SP)			;FIRST TWO ARGS ARE ZERO
	CLRL	-(SP)			;ALSO THIRD IS ZERO
	PUSHAQ	(R2)			;ADDRESS OF BUFFER DESCRIPTOR
	PUSHAW	(R2)			;PLACE TO RESTORE LENGTH
	PUSHAQ	20(SP)			;ADDRESS OF DESCRIPTOR IN STACK
	CALLS	#8,@#SYS$TRNLOG		;TRANSLATE AND CLEAR THE STACK
	BLBS	R0,115$			;IF LBS SUCCESSFUL
	BRW	99$			;ELSE EXIT WITH ERROR
115$:
	ADDL3	(R2),4(R2),R3		;GET ADDRESS OF LAST CHARACTER
	CMPB	#^A/:/,-(R3)		;OF DEVICE. IS IT COLON?
	BNEQ	117$			;IF NEQ NO
	DECL	(R2)			;DISCOUNT TRAILING COLON
117$:
	$ASSIGN_S	DEVNAM = (R2),-	;ASSIGN A CHANNEL TO SPECIFIED
			CHAN   = CHANNEL(R9)	;DEVICE
	BLBS	R0,120$			;IF LBS SUCCESSFUL
	BRW	99$			;ELSE EXIT WITH ERROR
120$:
					; issue ACP function to read quota record
	MOVW	#FIB$C_EXA_QUOTA,FIB+FIB$W_CNTRLFUNC(R9)
	MOVAB	RECORD_DESC(R9),R0
	$QIOW_S		CHAN   = CHANNEL(R9),-
			FUNC   = #IO$_ACPCONTROL,-
			IOSB   = IO_STATUS(R9),-
			P1     = FIB_DESC(R9),-
			P2     = R0,-
			P4     = R0
	BLBC	R0,98$
	MOVZWL	IO_STATUS(R9),R0	;get I/O status and check it
	BLBC	R0,98$
	MOVAB	DEVNAM_DESC(R9),R0	;get address of dev. name descriptor
	MOVAB	FAO_STRING,R1		;point to FAO string
	MOVZBL	(R1)+,RECORD_DESC(R9)	;set its length
	MOVL	R1,RECORD_DESC+4(R9)		;and address
	MOVL	QUOTA_RECORD+DQF$L_USAGE(R9),R1	;GET BLOCKS IN USE
	MOVL	QUOTA_RECORD+DQF$L_PERMQUOTA(R9),R2 ;AND PERMANENT QUOTA
	MOVAB	AVAIL,R4			;ASSUME NOT OVERDRAWN
	SUBL3	R1,R2,R3			;COMPUTE NUMBER REMAINING
	BGEQ	130$				;IF GEQ THEN NOT OVERDRAWN
	MNEGL	R3,R3				;MAKE OVERDRAFT POSITIVE
	MOVAB	OVER,R4				;SET KEYWORD ADDRESS
130$:
	MOVL	QUOTA_RECORD+DQF$L_OVERDRAFT(R9),R5 ;get overdraft limit
					;call FAO to build the message
	$FAO_S	CTRSTR = RECORD_DESC(R9),-
		OUTLEN = (R8),-
		OUTBUF = (R8),-
		P1     = QUOTA_RECORD+DQF$L_UIC+2(R9),-
		P2     = QUOTA_RECORD+DQF$L_UIC(R9),-
		P3     = R1,-			;BLOCKS USED
		P4     = R3,-			;BLOCKS REMAINING OR OVERDRAWN
		P5     = R4,-			;"available" OR "OVERDRAWN"
		P6     = R2,-			;AUTHORIZED QUOTA
		P7     = R5,-			;AUTHORIZED OVERDRAFT
		P8     = R0			;DEVICE NAME

	BSBB	98$			;deassign the channel
	MOVQ	(R8),R1			;get string descriptor
	BRW	EXTMSG			;output and exit
98$:	PUSHL	R0			;save return status
	$DASSGN_S	CHAN = CHANNEL(R9)
	MOVL	(SP)+,R0		;restore return status
99$:
	RSB
 
	.END
