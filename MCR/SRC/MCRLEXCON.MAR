	.TITLE	MCRLEXCON - LEXICAL FUNCTION PARSE AND EXECUTION SUPPORT ROUTINES
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 3-FEB-78
;
; Modified by:
;
;
;	V01.03	RN0019		R. Newland	 6-Jan-1980
;		Allow argument to F$VERIFY() to set/clear the verifiaction
;		flag, i.e. a "test and set".
;
;	V01.02	RN0018		R. Newland	 3-Jan-1980
;		Add F$MESSAGE function and suppress F$LOGICAL and
;		F$MESSAGE error messages if processing a goto.
;
;	V01.01	RN0010		R. Newland	21-Oct-1979
;		Translate process permanent logical names correctly by
;		ignoring first four characters if first character is ESC.
;		SPR 11-26673
;
; LEXICAL FUNCTION PARSE AND EXECUTION SUPPORT ROUTINES
;
;	DEFAULT DIRECTORY
;	EXTRACT SUBSTRING
;	LOCATE SUBSTRING
;	LOGICAL NAME TRANSLATION
;	JOB MODE
;	PROCESS NAME
;	STRING LENGTH
;	TIME
;	USER IDENTIFICATION CODE
;	VERIFY MODE
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	$JPIDEF				;DEFINE JOB/PROCESS INFORMATION ID'S
 
;
; LOCAL MACROS
;
; GENERATE LEXICAL FUNCTION DEFINITION TABLE
;
 
	.MACRO	GENLXF NAME,NUM
	.NCHR	$ZZ$,NAME
$XX$=128
	.IRPC	$YY$,<NAME>
	.BYTE	^A/$YY$/!$XX$
$XX$=0
	.ENDM
	.REPT	4-$ZZ$
	.ASCII	/ /
	.ENDM
	.BYTE	NUM
	.ENDM	GENLXF
 
;
; LOCAL SYMBLS
;
; PARAMETER OFFSET DEFINITIONS
;
 
P1=4					;STACK OFFSET TO PARAMETER 1
P2=12					;STACK OFFSET TO PARAMETER 2
P3=20					;STACK OFFSET TO PARAMETER 3
 
;
; LOCAL DATA
;
; LEXICAL FUNCTION DEFINITION TABLE
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
LXFUNTABLE:				;LEXICAL FUNCTION DEFINITION TABLE
	GENLXF	DIRE,0			;DEFAULT DIRECTORY
	GENLXF	EXTR,3			;EXTRACT SUBSTRING FROM STRING
	GENLXF	LENG,1			;STRING LENGTH
	GENLXF	LOCA,2			;LOCATE SUBSTRING
	GENLXF	LOGI,1			;LOGICAL NAME TRANSLATION
	GENLXF	MESS,1			;GET MESSAGE
	GENLXF	MODE,0			;JOB MODE
	GENLXF	PROC,0			;PROCESS NAME
	GENLXF	TIME,0			;TIME OF DAY
	GENLXF	USER,0			;USER IDENTIFICATION CODE
	GENLXF	VERI,1			;VERIFY MODE
LXFUNTABLEN=.-LXFUNTABLE		;LENGTH OF LEXICAL FUNCTION TABLE
 
;
; RESULTANT RETURN STRINGS FOR STATE AND MODE RETURN VALUES
;
 
BATCH:					;BATCH MODE
	.ASCIC	/BATCH/			;
TRUE:	.ASCII	\1\			;BOOLEAN VARIABLE TRUE
FALSE:	.ASCII	\0\			;BOOLEAN VARIABLE FALSE
INTERACTIVE:				;INTERACTIVE MODE
	.ASCIC	/INTERACTIVE/		;
 
;
; TRUE/FALSE BOOLEAN VARIABLE STARTING CHARACTERS
;
 
TRUFLS:					;
	.ASCII	/FTNY/			;
	.PAGE
	.SBTTL	LEXICAL FUNCTION DISPATCHER
;+
; MCR$LEXIF - LEXICAL FUNCTION DISPATCH ROUTINE
;
; THIS ROUTINE IS CALLED WHEN A STRING SUBSTITUTION IS SPECIFIED AND THE STRING
; IS CURRENTLY UNDEFINED.
;
; INPUTS:
;
;	R6 = LENGTH OF SYMBOL NAME.
;	R7 = ADDRESS OF SYMBOL NAME.
;	R9 = ADDRESS OF NEXT CHARACTER IN COMMAND BUFFER
;	R10 = ADDRESS OF NEXT CHARACTER IN INPUT BUFFER.
;
; OUTPUTS:
;
;	THE SYMBOL NAME IS MATCHED WITH THE LEXICAL FUNCTION TABLE. IF NO MATCH
;	OCCURS, THEN A NULL STRING IS RETURNED FOR SUBSTITUTION IN THE ORIGINAL
;	COMMAND LINE. IF A MATCH OCCURS, THEN THE APPROPRIATE LEXICAL FUNCTION
;	IS EVALUATED AND THE RESULTANT STRING IS RETURNED.
;
;	R1 = LENGTH OF RESULT STRING.
;	R2 = ADDRESS OF RESULT STRING.
;	R9 AND R10 ARE UPDATED AS APPROPRIATE.
;-
 
MCR$LEXIF::				;LEXICAL FUNCTION DISPATCH
	MOVL	SP,AP			;MARK STACK ADDRESS
	PUSHL	R10			;SAVE CURRENT ADDRESS IN INPUT BUFFER
	BSBW	SKIP_SPACES		;SKIP TRAILING BLANKS AND TABS
	CMPL	#6,R6			;SPECIFIED NAME LONGER THAN 6 CHARACTERS?
	BGTRU	10$			;IF GTRU NO
	MOVL	#6,R6			;REDUCE LENGTH TO 6 CHARACTERS
10$:	MOVZBL	(R10)+,R0		;GET TERMINAL CHARACTER
	PUTCHAR				;PUT CHARACTER IN COMMAND BUFFER
	CMPW	#^A/F$/,(R7)+		;POSSIBLY LEXICAL FUNCTION NAME?
	BNEQ	15$			;IF NEQ NO
	CMPB	#^A/(/,R0		;POSSIBLY LEXICAL FUNCTION?
15$:	BNEQ	60$			;IF NEQ NO
	SUBL	#2,R6			;REDUCE LENGTH OF FUNCTION NAME
	BLEQ	60$			;IF LEQ NOT LEXICAL FUNCTION NAME
	BISB	#128,(R7)		;SET FORCE MATCH FLAG
	MATCHC	R6,(R7),#LXFUNTABLEN,LXFUNTABLE ;SEARCH FOR FUNCTION NAME MATCH
	BNEQ	70$			;IF NEQ NO MATCH FOUND
	ADDL	R6,R2			;CALCULATE BYTES REMAINING INCLUDING SUBSTRING
	DIVL3	#5,R2,R8		;CALCULATE COMPLETE TABLE ENTRY NUMBER
	MATCHC	R6,(R7),#9,(R3)		;SCAN FOR DUPLICATE MATCH
	BEQL	80$			;IF EQL DUPLICATE MATCH FOUND
	SUBL3	R8,#LXFUNTABLEN/5,R8	;CALCULATE REAL FUNCTION INDEX
	MULL3	#5,R8,R7		;CALCULATE BYTE OFFSET IN FUNCTION TABLE
	MOVZBL	LXFUNTABLE+4[R7],R7	;GET NUMBER OF FUNCTION ARGUMENTS
20$:	BSBW	SKIP_SPACES		;SKIP LEADING BLANKS AND TABS
	DECL	R7			;ANY MORE ARGUMENTS TO PROCESS?
	BLSS	50$			;IF LSS NO
	MOVQ	R9,-(SP)		;SAVE CURRENT BUFFER POINTERS
	GETXSYM				;GET ARGUMENT SYMBOL OR LITERAL
	BEQL	40$			;IF EQL NULL STRING
	MOVZBL	(R2),R6			;SAVE STRING CHARACTER OF STRING
	COMPSTRING			;COMPRESS STRING
	CMPB	#^A/"/,R6		;STRING LITERAL?
	BEQL	40$			;IF EQL YES
	CMPB	#^A/%/,(R2)		;NUMERIC RADIX OPERATOR?
	BEQL	40$			;IF EQL YES
	CMPB	#^A/0/,(R2)		;POSSIBLY NUMERIC LITERAL?
	BGTRU	30$			;IF GTRU NO
	CMPB	#^A/9/,(R2)		;POSSIBLY NUMERIC LITERAL?
	BGEQU	40$			;IF GEQU YES
30$:	SEARCH				;SEARCH SYMBOL TABLE FOR SYMBOL
40$:	MOVQ	R1,(SP)			;SAVE STRING DESCRIPTOR
	BSBW	SKIP_SPACES		;SKIP TRAILING SPACES
	TSTL	R7			;LAST PARAMETER TO PROCESS?
	BEQL	50$			;IF EQL YES
	CMPB	#^A/,/,(R10)+		;TRAILING COMMA?
	BEQL	20$			;IF EQL YES
	BRB	100$			;
50$:	CMPB	#^A/)/,(R10)+		;TRAILING RIGHT PARENTHESIS?
	BNEQ	100$			;IF NEQ NO
	CMPB	#^A/'/,(R10)+		;TRAILING QUOTE?
	BEQL	55$			;BR IF YES
	DECL	R10			;BACKUP TO TERMINATOR
55$:	BSBB	DISPATCH		;DISPATCH FUNCTION
	MOVL	AP,SP			;REMOVE ALL TEMPORARIES FROM STACK
	RSB				;
 
;
; FUNCTION NOT TERMINATED WITH LEFT PARENTHESIS, DOES NOT CONTAIN AT LEAST TWO
; CHARACTERS, OR DOES NOT START WITH THE CHARACTERS "F$".
;
 
60$:	POPL	R10			;RESTORE INPUT BUFFER POINTER
	CLRL	R1			;RETURN NULL STRING
	RSB				;
 
;
; INVALID FUNCTION NAME
;
 
70$:	STATUS	IVFNAM			;SET INVALID FUNCTION NAME STATUS
	BRB	90$			;
 
;
; AMBIGUOUS FUNCTION NAME
;
 
80$:	STATUS	ABFNAM			;SET AMBIGUOUS FUNCTION NAME STATUS
90$:	MOVAW	-(R7),R6		;SET STARTING ADDRESS OF FUNCTION NAME
	BRB	110$			;
 
;
; INVALID SYMBOL DELIMITER
;
 
100$:	STATUS	SYMDEL			;SET INVALID SYMBOL DELIMITER STATUS
	MOVL	R10,R9			;SET ADDRESS OF NEXT CHARACTER IN BUFFER
	MOVAB	-(R9),R6		;SET ADDRESS OF INVALID DELIMITER
	TSTB	(R6)			;EOL?
	BNEQ	110$			;BR IF NO
	DECL	R10			;BACKUP TO END OF LINE
 
;
; UNDEFINED SYMBOL
;
 
110$:	BRW	ERROR_EXIT		;
 
;
; DISPATCH TO PROPER LEXICAL FUNCTION ROUTINE
;
 
DISPATCH:				;
	CASE	R8,<-			;
		F$DIRECTORY,-		;DEFAULT DIRECTORY
		F$EXTRACT,-		;EXTRACT SUBSTRING FROM STRING
		F$LENGTH,-		;STRING LENGTH
		F$LOCATE,-		;LOCATE SUBSTRING
		F$LOGICAL,-		;LOGICAL NAME TRANSLATION
		F$MESSAGE,-		;GET MESSAGE
		F$MODE,-		;JOB MODE
		F$PROCESS,-		;PROCESS NAME
		F$TIME,-		;CURRENT TIME AND DATE
		F$USER,-		;USER IDENTIFICATION
		F$VERIFY,-		;VERIFY MODE
		>			;
	CLRL	R1			;RETURN NULL STRING
	RSB				;
	.PAGE
	.SBTTL	RETURN DEFAULT DIRECTORY NAME STRING
;+
; F$DIRECTORY - RETURN DEFAULT DIRECTORY NAME STRING
;
; THIS LEXICAL FUNCTION RETURNS THE ADDRESS AND LENGTH OF THE CURRENT DEFAULT
; DIRECTORY STRING.
;
;	F$DIRECTORY ()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF DEFAULT DIRECTORY STRING.
;	R2 = ADDRESS OF DEFAULT DIRECTORY STRING.
;-
 
F$DIRECTORY:				;RETURN DEFAULT DIRECTORY STRING
	MOVAB	@#PIO$GT_DDSTRING,R2	;GET ADDRESS OF DEFAULT DIRECTORY STRING
	MOVZBL	(R2)+,R1		;GET LENGTH OF DEFAULT DIRECTORY STRING
	RSB				;
	.PAGE
	.SBTTL	EXTRACT SUBSTRING FROM STRING
;+
; F$EXTRACT - EXTRACT SUBSTRING FROM STRING
;
; THIS LEXICAL FUNCTION EXTRACTS A SUBSTRING FROM AN ARGUMENT STRING AND RETURNS
; ITS DESCRIPTOR.
;
;	F$EXTRACT ( POSITION, SIZE, STRING )
;
; INPUTS:
;
;	P1(SP) = LENGTH OF STRING.
;	P1+4(SP) = ADDRESS OF STRING.
;	P2(SP) = LENGTH OF SIZE STRING.
;	P2+4(SP) = ADDRESS OF SIZE STRING.
;	P3(SP) = LENGTH OF POSITION STRING.
;	P3+4(SP) = ADDRESS OF POSITION STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EXTRACTED SUBSTRING.
;	R2 = ADDRESS OF EXTRACTED SUBSTRING.
;-
 
F$EXTRACT:				;
	MOVQ	P3(SP),R2		;GET POSITION SUBSTRING PARAMETERS
	BSBW	CATB			;CONVERT NUMERIC PARAMETER
	MOVL	R1,R8			;SAVE STARTING POSITION OF SUBSTRING
	CLRL	R1			;ASSUME NULL SUBSTRING
	CMPL	R8,P1(SP)		;STARTING POSITION BEYOND END OF STRING
	BGEQU	10$			;IF GTRU YES
	MOVQ	P2(SP),R2		;GET SIZE STRING PARAMETERS
	BSBW	CATB			;CONVERT NUMERIC PARAMETER
	ADDL3	R8,P1+4(SP),R2		;CALCULATE STARTING ADDRESS OF SUBSTRING
	SUBL	R8,P1(SP)		;REDUCE APPARENT STRING LENGTH BY POSITION
	SUBL	R1,P1(SP)		;REDUCE STRING BY LENGTH OF SUBSTRING
	BGEQU	10$			;IF GEQU STRING LENGTH SUFFICIENT
	ADDL	P1(SP),R1		;CALCULATE ACTUAL LENGTH OF SUBSTRING
10$:	RSB				;
	.PAGE
	.SBTTL	RETURN LENGTH OF STRING
;+
; F$LENGTH - RETURN LENGTH OF STRING
;
; THIS LEXICAL FUNCTION RETURNS THE LENGTH OF ITS ARGUMENT AS A DECIMAL STRING.
;
;	F$LENGTH ( STRING )
;
; INPUTS:
;
;	P1(SP) = LENGTH OF ARGUMENT STRING.
;	P1+4(SP) = ADDRESS OF ARGUMENT STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED STRING LENGTH.
;	R2 = ADDRESS OF CONVERTED STRING LENGTH.
;-
 
	.ENABL	LSB
F$LENGTH:				;RETURN LENGTH OF STRING
	MOVL	P1(SP),R1		;GET VALUE TO BE CONVERTED
	BRB	20$			;
	.PAGE
	.SBTTL	LOCATE SUBSTRING IN STRING
;+
; F$LOCATE - LOCATE SUBSTRING IN STRING
;
; THIS LEXICAL FUNCTION RETURNS THE STARTING POSITION OF A SUBSTRING IN ANOTHER
; STRING. IF THE SUBSTRING IS NOT CONTAINED IN THE SPECIFIED STRING, THEN THE
; LENGTH OF THE SPECIFIED STRING IS RETURNED.
;
;	F$LOCATE ( SUBSTRING, STRING )
;
; INPUTS:
;
;	P1(SP) = LENGTH OF STRING.
;	P1+4(SP) = ADDRESS OF STRING.
;	P2(SP) = LENGTH OF SUBSTRING.
;	P2+4(SP) = ADDRESS OF SUBSTRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED POSITION STRING.
;	R2 = ADDRESS OF CONVERTED POSITION STRING.
;-
 
F$LOCATE:				;LOCATE SUBSTRING IN STRING
	MATCHC	P2(SP),@P2+4(SP),P1(SP),@P1+4(SP) ;SEARCH FOR SUBSTRING MATCH
	BNEQ	10$			;IF NEQ NO MATCH FOUND
	SUBL	P2(SP),R3		;CALCULATE STARTING ADDRESS OF SUBSTRING
10$:	SUBL3	P1+4(SP),R3,R1		;CALCULATE STARTING POSITION OF SUBSTRING
20$:	PUSHL	R9			;SAVE STARTING ADDRESS OF CONVERTED VALUE
	MOVZBL	#^A/%/,R0		;GET RADIX ESCAPE CHARACTER
	PUTCHAR				;PUT CHARACTER IN COMMAND BUFFER
	MOVZBL	#^A/D/,R0		;GET DECIMAL RADIX CHARACTER
	PUTCHAR				;PUT CHARACTER IN COMMAND BUFFER
	MOVL	R1,R0			;SET NUMBER TO BE CONVERTED
	BSBW	CBTA_DEC		;CONVERT TO ASCII DECIMAL
	POPL	R2			;RETRIEVE STARTING ADDRESS OF STRING
	SUBL3	R2,R9,R1		;CALUCLATE LENGTH OF CONVERTED VALUE
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	LOGICAL NAME TRANSLATION
;+
; F$LOGICAL - LOGICAL NAME TRANSLATION
;
; THIS LEXICAL FUNCTION OBTAINS THE TRANSLATION FOR A SPECIFED LOGICAL NAME AND
; RETURN THE EQUIVALENCE NAME.
;
;	F$LOGICAL ( LOGICAL_NAME )
;
; INPUTS:
;
;	P1(SP) = LENGTH OF LOGICAL NAME STRING.
;	P1+4(SP) = ADDRESS OF LOGICAL NAME STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF EQUIVALENCE STRING.
;	R2 = ADDRESS OF EQUIVALENCE STRING.
;-
	.ENABL	LSB
 
F$LOGICAL:				;LOGICAL NAME TRANSLATION
	MOVAB	P1(SP),R0		;GET ADDRESS OF LOGICAL NAME DESCRIPTOR
	PUSHL	R9			;BUILD EQUIVALENCE NAME DESCRIPTOR
	SUBL3	R9,R10,-(SP)		;
	MOVL	SP,R1			;SET ADDRESS OF EQUIVALENCE NAME DESCRIPTOR
	$TRNLOG_S (R0),(R1),(R1)	;TRANSLATE LOGICAL NAME
	MOVQ	(SP)+,R1		;RETRIEVE EQUIVALENCE NAME PARAMETERS
	BLBC	R0,20$			;IF LBC TRANSLATION FAILURE
	CMPW	#SS$_NOTRAN,R0		;DID TRANSLATION ACTUALLY OCCUR?
	BEQL	5$			; No if EQL
	TSTL	R1			; Is value length zero?
	BEQL	10$			; Yes if EQL
	CMPB	(R2),#27		; Is first character an ESC?
	BNEQ	10$			; No if NEQ
	ADDL2	#4,R2			; Yes: point past 4 byte header and
	SUBL2	#4,R1			; reduce equivalence string length by 4
	BGEQ	10$			; If GEQ still OK
5$:	CLRL	R1			; Set to return null string
10$:	RSB				;
 
;
; LOGICAL NAME TRANSLATION FAILURE
;
 
20$:
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),5$ ; Return null string if GOTO
	ADDL3	R6,P1(SP),R9		;CALCULATE ENDING ADDRESS OF LOGICAL NAME
	BRW	ERROR_EXIT		;

	.SBTTL	GET MESSAGE TEXT
;+
; F$MESSAGE - GET MESSAGE TEXT
;
; THIS LEXICAL FUNCTION OBTAINS THE MESSAGE TEXT ASSOCIATED WITH A MESSAGE CODE.
;
;	F$MESSAGE ( CODE )
;
; INPUTS:
;
;	P1(SP) = LENGTH OF MESSAGE CODE NAME STRING.
;	P1+4(SP) = ADDRESS OF MESSAGE CODE NAME STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF MESSAGE TEXT STRING.
;	R2 = ADDRESS OF MESSAGE TEXT STRING.
;-
 
F$MESSAGE:				;GET MESSAGE TEXT
	MOVQ	P1(SP),R2		;GET MESSAGE CODE NAME STRING PARAMETERS
	BSBW	CATB			;CONVERT NUMERIC PARAMETER
	PUSHL	R9			;BUILD MESSAGE BUFFER DESCRIPTOR
	SUBL3	R9,R10,-(SP)		;
	MOVL	SP,R2			;SET ADDRESS OF MESSAGE BUFFER DESCRIPTOR
	$GETMSG_S R1,(R2),(R2),#15	;GET MESSAGE TEXT
	MOVQ	(SP)+,R1		;RETRIEVE MESSAGE TEXT PARAMETERS
	CMPW	S^#SS$_NORMAL,R0	;SUCCESSFUL COMPLETION?
	BNEQ	20$			;IF NEQ NO
	RSB				;
 
	.DSABL	LSB
	.PAGE
	.SBTTL	RETURN JOB MODE
;+
; F$MODE - RETURN JOB MODE
;
; THIS LEXICAL FUNCTION RETURNS A STRING THAT IS EITHER "INTERACTIVE" OR "BATCH"
; DEPENDENT ON THE JOB MODE.
;
;	F$MODE ()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF JOB MODE DESCRIPTION STRING.
;	R2 = ADDRESS OF JOB MODE DESCRIPTION STRING.
;-
 
F$MODE:					;RETURN JOB MODE
	MOVAB	INTERACTIVE,R2		;ASSUME INTERACTIVE JOB
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),10$ ;IF CLR, INTERACTIVE JOB
	MOVAB	BATCH,R2		;GET ADDRESS OF BATCH STRING
10$:	MOVZBL	(R2)+,R1		;GET LENGTH OF STRING
	RSB				;
	.PAGE
	.SBTTL	RETURN PROCESS NAME
;+
; F$PROCESS - RETURN PROCESS NAME
;
; THIS LEXICAL FUNCTION OBTAINS THE CURRENT PROCESS NAME AND RETURN A DESCRIPTOR
; FOR IT.
;
;	F$PROCESS ()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF PROCESS NAME.
;	R2 = ADDRESS OF PROCESS NAME.
;-
 
	.ENABL	LSB
F$PROCESS:				;RETURN PROCESS NAME
	CLRL	-(SP)			;CLEAR LENGTH AND ITEM ID OF LAST ITEM
	PUSHAB	-12(SP)			;PUSH ADDRESS TO STORE LENGTH
	PUSHL	R9			;PUSH ADDRESS OF OUTPUT BUFFER
	SUBL3	R9,R10,-(SP)		;CALCULATE LENGTH OF OUTPUT BUFFER
	CMPL	#15,(SP)		;BUFFER BIG ENOUGH TO HOLD PROCESS NAME?
	BGTRU	10$			;IF GTRU NO
	MOVW	#JPI$_PRCNAM,2(SP)	;SET PROCESS NAME IDENTIFICATION
	MOVL	SP,R0			;SET ADDRESS OF ITEM LIST
	$GETJPI_S ITMLST=(R0)		;GET PROCESS NAME
	CLRW	2(SP)			;CLEAR ITEM IDENTIFICATION
	BLBC	R0,30$			;IF LBC SERVICE FAILURE
	POPR	#^M<R1,R2,R3,R4>	;RETRIEVE PROCESS NAME PARAMETERS
	RSB				;
10$:	BRB	20$			;
	.PAGE
	.SBTTL	RETURN CURRENT TIME AND DATE
;+
; F$TIME - RETURN CURRENT TIME AND DATE
;
; THIS LEXICAL FUNCTION OBTAINS THE CURRENT TIME AND DATE AND RETURNS A STRING
; DESCRIPTOR FOR IT.
;
;	F$TIME ()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF TIME AND DATE STRING.
;	R2 = ADDRESS OF TIME AND DATE STRING.
;-
 
F$TIME:					;RETURN TIME AND DATE
	PUSHL	R9			;BUILD TIME BUFFER DESCRIPTOR
	SUBL3	R9,R10,-(SP)		;
	CMPL	#23,(SP)		;TIME BUFFER LARGE ENOUGH?
	BGTRU	20$			;IF GTRU NO
	MOVL	SP,R0			;SET ADDRESS OF TIME BUFFER DESCRIPTOR
	$ASCTIM_S (R0),(R0)		;GET CURRENT TIME
	MOVQ	(SP)+,R1		;RETRIEVE TIME BUFFER PARAMETERS
	BLBC	R0,30$			;IF LBC CONVERSION FAILURE
	RSB				;
	.PAGE
	.SBTTL	RETURN USER IDENTIFICATION CODE
;+
; F$USER - RETURN USER IDENTIFICATION CODE
;
; THIS LEXICAL FUNCTION FUNCTION CONVERTS THE USER IDENTIFICATION CODE TO AN
; ASCII STRING AND RETURNS A DESCRIPTOR FOR IT.
;
;	F$USER ()
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R1 = LENGTH OF USER IDENTIFICATION CODE.
;	R2 = ADDRESS OF USER IDENTIFICATION CODE.
;-
 
F$USER:					;RETURN USER IDENTIFICATION CODE
	PUSHL	R9			;SAVE POSITION IN OUTPUT BUFFER
	MOVB	#^A/[/,R0		;GET LEFT BRACKET
	PUTCHAR				;PUT CHARACTER IN OUTPUT BUFFER
	CLRQ	-(SP)			;CLEAR LAST ITEM AND LENGTH ADDRESS
	PUSHAB	-8(SP)			;PUSH ADDRESS TO STORE USER IDENTIFICATION
	PUSHL	#JPI$_UIC@16+4		;SET PARAMETER ID AND LENGTH
	MOVL	SP,R0			;SET ADDRESS OF TIME LIST
	$GETJPI_S ITMLST=(R0)		;GET USER IDENTIFICATION CODE
	BLBC	R0,30$			;IF LBC SERVICE FAILURE
	MOVZWL	2(SP),R0		;GET GROUP CODE
	BSBW	CBTA_OCT		;CONVERT GROUP CODE TO ASCII
	MOVZBL	#^A/,/,R0		;SET SEPARATOR CHARACTER
	PUTCHAR				;PUT CHARACTER IN COMMAND BUFFER
	MOVZWL	(SP),R0			;GET MEMBER CODE
	BSBW	CBTA_OCT		;CONVERT MEMBER CODE TO ASCII
	ADDL	#4*4,SP			;REMOVE ITEM LIST FROM STACK
	MOVB	#^A/]/,R0		;GET RIGHT BRACKET
	PUTCHAR				;PUT CHARACTER IN OUTPUT BUFFER
	POPL	R2			;RETRIEVE ADDRESS OF USER IDENTIFICATION CODE
	SUBL3	R2,R9,R1		;CALCULATE LENGTH OF RESULTANT STRING
	RSB				;
 
;
; BUFFER OVERFLOW
;
 
20$:	STATUS	BUFOVF			;SET BUFFER OVERFLOW STATUS
30$:	MOVL	R9,R6			;SET FOR NO SEGMENT DISPLAY
	BRW	ERROR_EXIT		;
	.DSABL	LSB
	.PAGE
	.SBTTL	RETURN VERIFY MODE
;+
; F$VERIFY - RETURN VERIFY MODE
;
; THIS LEXICAL FUNCTION RETURNS A BOOLEAN VARIABLE THAT DESCRIBES THE CURRENT
; STATE OF THE VERIFY MODE AND, IN ADDITION, WILL SET OR CLEAR VERIFICATION
; IF A NON-NULL ARGUMENT IS SPECIFIED AND IT'S NOT DURING A GOTO SCAN.
;
;	F$VERIFY ()	-OR-	F$VERIFY ( NEW_VERIFY_MODE )
;
; INPUTS:
;
;	P1(SP) = LENGTH OF VERIFY MODE SET STRING.
;	P1+4(SP) = ADDRESS OF VERIFY MODE SET STRING.
;
; OUTPUTS:
;
;	R1 = LENGTH OF BOOLEAN RESULT STRING.
;	R2 = ADDRESS OF BOOLEAN RESULT STRING.
;-
 
F$VERIFY:				;RETURN VERIFY MODE
	MOVAB	TRUE,R8			;ASSUME VERIFY IS CURRENTLY ON
	BBS	#PRC_V_VERIFY,PRC_W_FLAGS(R11),10$ ;BR IF ON
	MOVAB	FALSE,R8		;GET ADDRESS OF FALSE STRING DESCRIPTOR
10$:	MOVQ	P1(SP),R2		;GET DESCRIPTOR OF THE ARGUMENT
	TSTL	R2			;A NON-NULL ARGUMENT?
	BEQL	30$			;NOPE, IT'S NULL, NO CHANGES
	BSBB	CATB			;YEP, CONVERT ARGUMENT TO BINARY
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),30$ ;NO CHANGES MADE IF GOTO
	BBSC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),20$ ;TURN OFF VERIFICATION
20$:	BLBC	R1,30$			;LEAVE VERIFY OFF IF LBC
	BBCS	#PRC_V_VERIFY,PRC_W_FLAGS(R11),30$ ;ELSE TURN ON VERIFICATION
30$:	MOVL	R8,R2			;SET ADDRESS OF RESULT STRING
	MOVZBL	#1,R1			;SET LENGTH OF RESULT STRING
	RSB				;
	.PAGE
	.SBTTL	LOCAL SUBROUTINES
;+
; CATB - CONVERT ASCII VALUE TO BINARY
;
; THIS ROUTINE CONVERTS AN ASCII VALUE TO A BINARY VALUE. IF ALL CHARACTERS ARE
; NOT CONVERTED, THEN A SPECIAL CHECK IS MADE FOR BOOLEAN VARIABLES.
;
; INPUTS:
;
;	R2 = LENGTH OF STRING TO BE CONVERTED.
;	R3 = ADDRESS OF STRING TO BE CONVERTED.
;
; OUTPUTS:
;
;	R1 = CONVERTED VALUE.
;-
 
CATB:					;CONVERT ASCII TO BINARY
	MOVQ	R2,-(SP)		;SAVE STRING PARAMETERS
	CNVNUMDEC			;CONVERT DECIMAL NUMBER
	BEQL	10$			;IF EQL SUCCESSFUL CONVERSION
	MOVQ	(SP),R2			;RETRIEVE STRING PARAMETERS
	LOCC	(R3),#4,TRUFLS		;SEARCH FOR BOOLEAN VARIABLE MATCH
	BEQL	20$			;IF EQL ERROR
	BICL3	#6,R0,R1		;CONVERT COUNT TO BOOLEAN VALUE
10$:	MOVQ	(SP)+,R2		;RETRIEVE STRING PARAMETERS
	RSB				;
 
;
; INVALID STRING CHARACTER
;
 
20$:	MOVQ	(SP)+,R5		;RETRIEVE STRING PARAMETERS
	ADDL3	R5,R6,R9		;SET ENDING ADDRESS OF DISPLAY SEGMENT
	STATUS	IVCHAR			;SET INVALID CHARACTER STATUS
	BRB	ERROR_EXIT		;
 
;
; CBTA_DEC - CONVERT BINARY TO ASCII BASE TEN
; CBTA_OCT - CONVERT BINARY TO ASCII BASE EIGHT
;
; THESE ROUTINES ARE CALLED TO CONVERT A BINARY NUMBER TO A LEFT JUSTIFIED, ZERO
; SUPRESSED, ASCII STRING.
;
; INPUTS:
;
;	R0 = NUMBER TO BE CONVERTED.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED VALUE.
;	R2 = ADDRESS OF CONVERTED VALUE.
;-
 
	.ENABL	LSB
CBTA_OCT:				;CONVERT BINARY TO ASCII BASE EIGHT
	MOVZBL	#8,R3			;SET CONVERSION RADIX
	BRB	10$			;
CBTA_DEC:				;CONVERT BINARY TO ASCII BASE TEN
	MOVZBL	#10,R3			;SET CONVERSION RADIX
10$:	MOVL	R9,R2			;SAVE STARTING ADDRESS OF CONVERSION STRING
20$:	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R3,R0,R0,R1		;ISOLATE NEXT DIGIT
	ADDL3	#^A/0/,R1,-(SP)		;CONVERT DIGIT TO ASCII AND SAVE
	TSTL	R0			;ANY MORE DIGITS TO CONVERT?
	BEQL	30$			;IF EQL NO
	BSBB	20$			;CONVERT NEXT DIGIT
30$:	POPL	R0			;RETRIEVE NEXT CHARACTER
	PUTCHAR				;PUT CHARACTER IN OUTPUT BUFFER
	SUBL3	R2,R9,R1		;CALCULATE LENGTH OF RESULTANT STRING
	RSB				;
	.DSABL	LSB
 
;
; SKIP_SPACES - SKIP BLANKS AND TABS
;
; THIS ROUTINE SKIPS OVER BLANKS AND TABS IN THE INPUT BUFFER UPDATING THE INPUT
; BUFFER POINTER AS APPROPRIATE.
;
; INPUTS:
;
;	R10 = INPUT BUFFER POINTER.
;
; OUTPUTS:
;
;	R10 = ADDRESS OF NEXT NONBLANK, NONTAB CHARACTER IN THE INPUT BUFFER.
;-
 
	.ENABL	LSB
10$:	INCL	R10			;ADVANCE TO NEXT CHARACTER
SKIP_SPACES:				;
	CMPB	#^A/ /,(R10)		;NEXT CHARACTER A BLANK?
	BEQL	10$			;IF EQL YES
	CMPB	#^A/	/,(R10)		;NEXT CHARACTER A TAB?
	BEQL	10$			;IF EQL YES
	RSB				;
	.DSABL	LSB
 
;
; ERROR EXIT FROM LEXICAL FUNCTION STRING EXPANSION
;
 
ERROR_EXIT:				;
	MOVAB	-(R10),WRK_L_CHARPTR(FP) ;SET CHARACTER POINTER FOR ERROR MESSAGE
	ERRMSG				;OUTPUT ERROR MESSAGE
	PUSHL	R0			;SAVE FINAL STATUS
	FLUSH				;FLUSH COMMAND
	POPL	R0			;RETRIEVE FINAL STATUS
	SET_STATUS			;SET COMMAND STATUS
	BRW	MCR$RESTART		;
 
	.END
