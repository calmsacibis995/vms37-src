	.TITLE	MCRCOMD - PROCESS NEXT COMMAND
	.IDENT	'V03-003'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 7-DEC-1977
;
; PROCESS NEXT COMMAND
;
; MODIFIED BY:
;	
;	V3.003	MAJ0010		Melanie Johnson	08-Apr-1982
;		Allocate the WRK block before using it in MCR$RESTART.
;		Initialize WRK_L_RSLNXT(FP) - end of token pointer - to
;		the beginning of the token array to prevent ACCVIO.
;
;	V3.002	MAJ0009		Melanie Johnson	24-Mar-1982
;		Allow ':' to be a parameter delimiter to allow the label to
;		appear immediately after the device spec. for the MOUNT and
;		INITIALIZE commands.  This will provide RSX and V2.x compatibility.
;
;	V3.001	MAJ0008		Melanie Johnson	18-Mar-1982
;		Check for commands explicitly defined as foreign (to fix HELP).
;		Remove enforced use of a blank before the slash in option
;		commands being specified as if the options were qualifiers.
;		(This will fix SET /UIC which was broken by the removal of
;		insignificant blanks by MCR$GETOKEN/MCR$GTBTOKEN.)
;
;	V007	MAJ0007		Melanie Johnson	10-Feb-1982
;		Allow MCR-ized commands to contain mulitple command verb
;		qualifiers.
;
;	V006	MAJ0006		Melanie Johnson	17-Nov-81
;		Convert to using the new command tables (new MDL structures).
;
;	V005	MAJ0005		Melanie Johnson	20-Aug-81
;		In MCR$FLUSH, check to see if we're in a .GOTO section
;		and set a flag if we're also in a comment so that
;		full-line comments won't be continued and hence, won't
;		wipe out the label which follows.
;
;	V004	MAJ0004		Melanie Johnson 07-Aug-81
;		Move initialization of <FILSPC> and <FILERR> out of
;		here so they won't be re-initialized on the next
;		command after a .TESTFILE.
;
;	V003	TMH0003		Tim Halvorsen	01-Jun-1981
;		Rewrite terminal hangup to take advantage of normal
;		external image execution path, so that it sets up
;		the scratch stack and buffer descriptor.
;
;	V002	TMH0002		Tim Halvorsen	16-Dec-1980
;		Move initialiation of <FILSPC> and <FILERR> from CLI
;		initialization here, where WRK is allocated.
;
;	V001	TMH0001		Tim Halvorsen	24-Nov-1980
;		Reset NOSTAT bit on and clear all other command parsing
;		flags before parsing each line; so that indirect directives
;		do not reset <EXSTAT> unless an error occurs. SPR #33721
;		Clear NOSTAT bit on foreign commands.
;---
;
; MACRO LIBRARY CALLS
;
 
	$CLIMSGDEF			;DEFINE CLI MESSAGE CODES
	CMDDEF				;DEFINE COMMAND BLOCK OFFSETS
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFPROBLK			;DEFINE PROMPT DESCRIPTOR BLOCK OFFSETS
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	DEFSYMTBL			;DEFINE SYMBOL ENTRY OFFSETS
	DEFOPIMCR			; Result parse work definitions
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
 	VECDEF				;DEFINE TABLE VECTOR
	ENTDEF				;DEFINE ENTITY DESCRIPTOR BLOCK

;
; LOCAL DEFINITIONS
;
	LOC_V_FULCOM	=	8	;FLAG TO INDICATE COMMENT FOUND IN A .GOTO SECTION

;
; GLOBAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$T_PROMPT::				;PRIMARY PROMPT
	.ASCIC	\> \			;

	.SBTTL	PROCESS NEXT COMMAND
;+
; MCR$RESTART - PROCESS NEXT COMMAND
;
; THIS ROUTINE IS THE CENTRAL COMMAND PARSE AND DISPATCH ROUTINE FOR THE
; STARLET MCRS COMMAND LANGUAGE INTERPRETER. IT INITIALIZES FOR THE NEXT
; COMMAND, READS AND PARSES THE COMMAND FOR SYNTACTIC CORRECTNESS, AND THEN
; EXECUTES THE APPROPRIATE IMAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	COMMAND IS READ, PARSED, AND AN IMAGE IS ACTIVATED.
;-
 
	.ENABL	LSB			;
1$:	BRW	MCR$ABORT		;LOG PROCESS OUT
MCR$RESTART::				;RESTART ENTRY POINT
	MOVAB	WRK_K_LENGTH-16(FP),SP	;ALLOCATE COMMAND IMPURE AREA
					; (2ND ALLOCATION BELOW IS SAFE)
	MOVAB	W^MCR$HYPHEN-1,WRK_L_CHARPTR(FP) ;SET TO FORCE INPUT ON NEXT GET
 
;
; PARSE COMMAND AND BUILD RESULT TABLE
;
 
MCR$CMDSTART::				;COMMAND PROCESSING ENTRY POINT
	MOVAB	W^MCR$CONDHAND,(FP)	;ESTABLISH CONDITION HANDLER
	MOVAB	WRK_K_LENGTH-16(FP),SP	;ALLOCATE COMMAND IMPURE AREA
	CLRB	WRK_B_VERBTYP(FP)	;INIT VERB CLASS TO NONE!
	CLRBIT	MCR_V_FORCMD,PRC_W_CLIFLAG(R11) ;REOMVE FOREIGN COMMAND FLAG
	MOVAB	MCR$T_PROMPT,WRK_L_PROMPT(FP) ;SET ADDRESS OF DEFAULT PROMPT
	ASSUME	WRK_W_FLAGS EQ WRK_W_LOCFLG+2 
	MOVAB	WRK_G_RESULT(FP),WRK_L_RSLNXT(FP) ;INIT. ADDRESS OF LAST TOKEN
	CLRL	WRK_W_LOCFLG(FP)	;RESET COMMAND FLAGS
	MOVB	#CMD_M_NOSTAT,WRK_B_CMDFLG(FP) ;DEFAULT FOR ".XXX" IS NOSTAT
	CLRBIT	PRC_V_RUNDEF,PRC_B_FLAGS2(R11) ;CLEAR IMAGE RUN DEFAULT FLAG
	BICW	#PRC_M_DISABL!-		;CLEAR COMMAND INTERPRETER CONTROL Y/C
		PRC_M_IND,PRC_W_FLAGS(R11) ;CLEAR INDIRECT FILE IN PROGRESS
	BBCC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),10$ ;BR IF NO CONTROL Y/C REQUESTED
	MOVL	PRC_L_ONCTLY(R11),R1	;GET ADDRESS OF ACTION COMMAND
	BEQL	5$			;BR IF NO ACTION OUTSTANDING
	MOVZBL	(R1)+,R0		;GET THE ADDRESS AND COUNT
	MOVC	R0,(R1),WRK_G_INPBUF(FP) ;MOVE COMMAND INTO BUFFER
	MOVAB	WRK_G_INPBUF-1(FP),WRK_L_CHARPTR(FP) ;SET POINTER BEFORE RECORD
	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),10$ ;BR IF NOT IN A GOTO
	BSBW	MCR$DEALGOTO		;DEALLOCATE THE CONTROL BLOCK
	BRB	10$
5$:	BISW	#PRC_M_YLEVEL,PRC_W_FLAGS(R11) ;SET CONTROL Y/C LEVEL
	
10$:	BBS	#PRC_V_HANGUP,PRC_W_FLAGS(R11),1$ ;BR IF HANGUP PENDING
	MOVAB	WRK_AB_BUFFER+2(FP),R9	;SET ADDRESS OF COMMAND BUFFER
	MOVAB	WRK_AG_RESULT(FP),R10	;SET ADDRESS OF RESULT PARSE TABLE
	SETNBLK				;POINT TO NEXT NONBLANK CHARACTER
	BEQL	MCR$RESTART		;IF EQL NULL LINE
20$:	CMPB	#^A/$/,R0		;DOLLAR SIGN?
	BNEQ	30$			;BR IF NO-PROCESS THE COMMAND
	INCL	WRK_L_CHARPTR(FP)	;SKIP THE DOLLAR SIGN
	PUSHL	PRC_L_INDEPTH(R11)	;SAVE CURRENT INDIRECT LEVEL
	SETNBLK				;POINT AT NEXT NON-BLANK CHARACTER
	BEQL	49$			;IF NULL LINE, THEN RESTART
	CMPL	PRC_L_INDEPTH(R11),(SP)+ ;INDIRECT LEVEL CHANGE?
	BNEQ	20$			;IF YES-LOOK FOR LEADING DOLLAR SIGN
30$:	BSBW	MCR$MARK		;SET ERROR PRINT POINTER
	CMPB	R0,#^A/./		;IS THIS AN INDIRECT COMMAND OR LABEL?
	BEQL	50$			;BR IF YES
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),40$ ;BR IF AT CONTROL Y LEVEL
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),60$ ;BR IF IN A GOTO
	CMPB	R0,#^A\/\		;LOGICAL EOF?
	BEQL	45$			;BR IF YES
40$:	BRW	COMMAND			;PROCESS COMMAND
45$:	FLUSH				;REST OF COMMAND IS IGNORED
	BSBW	MCR$STOPIND		; Effect a .STOP
49$:	BRW	MCR$RESTART		;READ IN NEXT COMMAND
50$:
	SETBIT	WRK_V_TABS,WRK_W_FLAGS(FP) ; Suppress forward conversion of tabs
	MOVTOKN				; Get the token for the indirect command
	CLRBIT	WRK_V_TABS,WRK_W_FLAGS(FP) ; Allow forward conversion of tabs
	TSTL	R1			; Test token length
	BEQL	65$			;BR IF NULL INDIRECT COMMAND
	CMPB	#^A/:/,R0		;LABEL TERMINATOR?
	BEQL	70$			;BR IF FOUND A LABEL
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),67$ ;BR IF NOT IN A GOTO
	BSBW	MCR$INDCMDSCAN		; Process indirect command
	BRB	EXIT1
60$:	FLUSH				;FLUSH THE COMMAND
	BRW	MCR$RESTART		;START WITH A NEW COMMAND
65$:	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),60$ ;BR IF IN A FORWARD GOTO
	CMPB	R0,#^A/;/		;"DOTTED" COMMENT
	BEQL	60$			;IF YES - JUST FLUSH IT
	BRW	NOCOMD			;
67$:	BSBW	MCR$INDCMD		;PROCESS MCR INDIRECT COMMAND
EXIT1:	BRW	ERROR_EXIT		;
 
;
; LABEL ENCOUNTERED
;
 
70$:	MOVNCHR				;MOVE COLON TO THE COMMAND BUFFER
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),START1 ;IF SET, CONTROL Y/C LEVEL
	MOVL	PRC_L_INDINPRAB(R11),R7	;GET CURRENT INDIRECT INPUT RAB
	BBC	#DEV$V_RND,RAB$L_CTX(R7),START1 ;IF CLR, NOT RANDOM DEVICE
	MOVQ	R1,R7			;PUT LABEL DESCRIPTOR IN SAFE REGISTERS
	TSTB	R0			;CHECK IF NEXT CHARACTER IS EOL
	BNEQ	80$			;BR IF NO - MAKE NO LABEL TABLE ENTRY
	BBS	#PRC_V_GOTO,PRC_W_FLAGS(R11),80$ ;BR IF IN GOTO
	MOVAB	PRC_Q_LABEL(R11),R5	;GET ADDRESS OF LABEL TABLE LISTHEAD
	MOVQ	R7,R3			;SET LABEL NAME PARAMETERS
	MOVL	PRC_L_INDINPRAB(R11),R2	;GET ADDRESS OF INDIRECT RAB
	MOVAB	RAB$W_RFA(R2),R2	;SET ADDRESS OF RECORD FILE ADDRESS
	MOVZBL	#6,R1			;SET LENGTH OF RECORD FILE ADDRESS
	DISABLE				;DISABLE CONTROL Y/C AST'S
	ALLOCSYM			;ALLOCATE AND INSERT LABEL IN TABLE
	BLBC	R0,EXIT1		;IF LBC ALLOCATION FAILURE
80$:	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),START1 ;IF CLR, NO GOTO
	MOVL	PRC_L_SYMBOL(R11),R3	;GET ADDRESS OF GOTO LABEL NAME
	MOVB	(R3)+,R0		; Get label level
	CMPB	PRC_B_FWDSCAN(R11), -	; Is forward scan for a .GOTO
		#PRC_K_GOTO
	BNEQ	90$			; No if NEQ, level is not significant
	CMPB	R0,PRC_B_NESTLEVEL(R11)	; Was label defined at current level?
	BNEQ	START1			; No if NEQ
90$:
	CMPB	(R3)+,R7		;LABEL LENGTHS MATCH?
	BNEQ	START1			;IF NEQ NO
	CMPC	R7,(R8),(R3)		;LABELS HAVE SAME NAME?
	BNEQ	START1			;IF NEQ NO
	BICW	#PRC_M_GOTO!PRC_M_GOEOF,- ;CLEAR GOTO IN PROGRESS AND EOF
		PRC_W_FLAGS(R11)	;ENCOUNTERED DURING SEARCH FLAGS
	MOVL	PRC_L_INDINPRAB(R11),R2	;GET THE INDIRECT INPUT RAB
	MOVB	#RAB$C_RFA,RAB$B_RAC(R2);SET ACCESS TO "RECORD FILE ADDRESS"
	$FIND	RAB=(R2)		;POSITION TO CURRENT RECORD
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R2);RESET ACCESS TO SEQUENTIAL
	BSBW	MCR$DEALGOTO		;DEALLOCATE THE GOTO LABEL
	BRW	MCR$RESTART		;READ THE NEXT COMMAND LINE
START1:	BRW	MCR$CMDSTART		;START THE COMMAND OVER
	.DSABL	LSB
 
;
; FOREIGN COMMAND VERB
;
 
FORCMD:	PUSHR	#^M<R1,R2,R8>		;SAVE FILENAME DESCRIPTOR
	BSBW	PROCFORN		;PROCESS FOREIGN COMMAND
	POPR	#^M<R1,R2,R8>		;RESTORE FILENAME DESCRIPTOR PARAMETERS
	MOVB	#CLI$K_VERB_FORE,WRK_B_VERBTYP(FP) ;SET COMMADN GENERIC TYPE
	CLRB	WRK_B_CMDFLG(FP)	;CLEAR COMMAND FLAGS (CLEAR NOSTAT)
	SETBIT	MCR_V_FORCMD,PRC_W_CLIFLAG(R11) ;FLAG DOING FOREIGN COMMAND
	BBS	#CMD_V_FOREIGN,CMD_B_FLAGS(R8),BUILD_IMAGE ;IF EXPLICIT FOREIGN CMD, BUILD IMAGE
	BRW	EXECEXT			;IMPLICIT FOREIGN COMMAND

;
; NO COMMAND VERB
;
 
NOCOMD:	CMPB	R0,#^A/;/		;COMMENT COMMAND
	BNEQ	10$			;IF NO ITS AN ERROR
	BRW	COMNT			;LIST THE COMMENT
10$:	STATUS	NOCOMD			;SET NO COMMAND STATUS
COMDERR:BRW	ERROR_EXIT
 
 
;
; STANDARD COMMAND VERB
;
 
COMMAND:BSBW	MCR$MARK		;MARK CURRENT POSITION FOR ERROR REPORTING
	GETOKEN				;GET COMMAND VERB TOKEN
	BEQL	NOCOMD			;IF EQL NONE
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),1$ ;BR IF NOT A ^Y LEVEL
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;NO INDIRECT FILES BEYOND VERB
1$:	BSBW	SEARCH_VERB		;SEARCH VERB TABLE
	STATUS	IVVERB,R3		;CONSTRUCT "FOREIGN COMMAND" STATUS
	CMPL	R0,R3			;FOREIGN COMMAND?
	BEQL	FORCMD			;BRANCH IF FOREIGN COMMAND
	BLBC	R0,COMDERR		;REPORT ANY OTHER ERRORS FROM SEARCH
	BBS	#CMD_V_FOREIGN,CMD_B_FLAGS(R8),FORCMD ;SPECIFIED AS A FOREIGN COMMAND?
	BBC	#CMD_V_IMMED,CMD_B_FLAGS(R8),10$ ;BR IF NORMAL
	EXTZV	#0,#7,WRK_L_IMAGE(FP),R3 ;GET INTERNAL IMAGE INDEX
	BRW	IMMED
 
;
; Check for MCR-style parsing vs. DCL-style parsing
;
 
10$:	BBS	#CMD_V_MCRPARSE,CMD_B_FLAGS(R8),15$ ;BR IF MCR-TYPE COMMAND
	BSBW	MCR$PARSE_DCL		;PARSE A DCL-TYPE COMMAND
	BRB	20$
15$:	BSBW	MCR$PARSE_MCR		;PARSE A MCR-TYPE COMMAND
20$:	BLBS	R0,BUILD_IMAGE		;BR IF NO ERROR
 
ERREXT:	BRW	ERROR_EXIT		;

;
; COMMENT COMMAND - PRINT THE LINE IF IT HAS NOT BEEN PRINTED
;
 
COMNT:	BBS	#PRC_V_VERIFY,PRC_W_FLAGS(R11),175$ ;BR IF ALREADY VERIFIED
	MOVL	WRK_L_CHARPTR(FP),R2	;GET START OF INPUT LINE
	LOCC	#0,#INPBUFSIZ,(R2)+	;FIND THE END OF LINE
	SUBL	R2,R1			;GET COUNT OF BYTES TO THE END
	MSGOUT				;PRINT THE COMMENT
175$:	BRW	RSTRT			;
 
;
; BUILD IMAGE NAME DESCRIPTOR
;
 

BUILD_IMAGE:
	MOVL	WRK_L_IMAGE(FP),R3	;GET IMAGE NAME INDEX NUMBER
	BBC	#30,R3,200$		;BR IF THIS IS NOT A USER IMAGE
	MOVL	R3,R2			;ADDRESS OF IMAGE NAME COUNTED STRING
	MOVZBL	(R2)+,R1		;GET COUNT TO R1, ADDRESS TO R2
	BRB	EXECEXT			;GO AND EXECUTE
200$:	BBSC	#7,R3,EXECINT		;IF SET, INTERNAL COMMAND
	DECL	R3			;CONVERT TO RELATIVE IMAGE NAME INDEX
	MOVL	PRC_L_TAB_VEC(R11),R2	;GET ADDRESS OF DATA BASE VECTOR
	ADDL	VEC_L_IMAGETBL(R2),R2	;AND GET ADDRESS OF IMAGE TABLE
	LOCATE				;LOCATE IMAGE NAME STRING
 
;
; EXECUTE EXTERNAL COMMAND
;
 
EXECEXT:				;EXECUTE EXTERNAL COMMAND
	MOVZBL	#IMG_K_EXTIMAGE&^X7F,R3	;SET EXTERNAL IMAGE COMMAND INDEX
 
;
; EXECUTE INTERNAL COMMAND
;
 
EXECINT:				;EXECUTE INTERNAL COMMAND
	PUSHR	#^M<R1,R2,R3>		;SAVE IMAGE NAME PARAMETERS
	MOVZBL	#PTR_K_ENDLINE,R5	;SET ITEM TYPE TO END OF LINE
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#1,R7			;SET LENGTH OF ITEM
	MOVL	R9,R8			;SET STARTING ADDRESS OF ITEM
	GENDESCR			;GENERATE RESULT PARSE DESCRIPTOR
	BITW	#<PRC_M_VERIFY!PRC_M_YLEVEL>,-	;IF COMMAND WAS VERIFIED,
		PRC_W_FLAGS(R11)		;OR IF AT CONTROL Y LEVEL
	BNEQ	5$				;THEN DON'T PRINT AGAIN
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;IF INPUT IS THE SAME AS
	BEQL	5$			;INDIRECT INPUT, THEN DON'T RE-PRINT
	MOVAB	WRK_AB_BUFFER+2(FP),R2	;GET START OF COMMAND BUFFER
	MOVW	#^A/> /,-(R2)		;SET PROPER PREFIX
	SUBL3	R2,R9,R1		;FIND LENGTH OF COMMAND
	MSGOUT				;PRINT THE COMMAND
5$:	POPR	#^M<R1,R2,R3>		;RESTORE IMAGE NAME PARAMETERS
	MOVL	R10,WRK_L_RSLNXT(FP)	;SAVE ADDRESS OF NEXT PARSE TABLE ENTRY
	BBC	#7,WRK_L_IMAGE(FP),70$	;IF CLR, EXTERNAL IMAGE
	MOVAB	WRK_AG_RESULT(FP),R7	;GET ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVL	R7,R8			;COPY ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVAB	-RSLBUFSIZ(SP),SP	;ALLOCATE TEMPORARY DESCRIPTOR ARRAY
	MOVL	SP,R9			;SAVE ADDRESS OF TEMPORARY DESCRIPTOR ARRAY
10$:	CMPL	R7,WRK_L_RSLNXT(FP)	;END OF RESULT DESCRIPTOR ARRAY?
	BEQL	30$			;IF EQL YES
	MOVL	(R7)+,(R9)		;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;COMMAND QUALIFIER?
		(R9),#PTR_K_COMDQUAL	;
	BNEQ	10$			;IF NEQ NO
	CLRL	-4(R7)			;CLEAR COMMAND QUALIFIER DESCRIPTOR
	TSTL	(R9)+			;POINT TO NEXT ITEM IN TEMPORARY ARRAY
20$:	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;QUALIFIER VALUE?
		(R7),#PTR_K_QUALVALU	;
	BNEQ	10$			;IF NEQ NO
	MOVL	(R7),(R9)+		;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	CLRL	(R7)+			;CLEAR QUALIFIER VALUE DESCRIPTOR
	BRB	20$			;
30$:	MOVL	R7,R10			;COPY ADDRESS OF LAST DESCRIPTOR + 4
40$:	CMPL	R7,R8			;ANY MORE DESCRIPTORS TO EXAMINE?
	BEQL	50$			;IF EQL NO
	MOVL	-(R7),R6		;GET DESCRIPTOR
	BEQL	40$			;IF EQL NONE
	MOVL	R6,-(R10)		;MOVE DESCRIPTOR TO NEW POSITION
	BRB	40$			;
50$:	CMPL	R9,SP			;ANY MORE TEMPORARY DESCRIPTORS?
	BEQL	60$			;IF EQL NO
	MOVL	-(R9),-(R10)		;MOVE DESCRIPTOR TO NEW POSITION
	BRB	50$			;
60$:	MOVAB	RSLBUFSIZ(SP),SP	;DEALLOCATE TEMPORARY DESCRIPTOR ARRAY
70$:	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(FP) ;SET COMMAND EXECUTION IN PROGRESS
	MOVL	SP,R9			;SET ADDRESS OF SCRATCH STACK
	MOVAB	-MSGBUFSIZ*2(SP),SP	;ALLOCATE MESSAGE BUFFER ON STACK
	PUSHAB	(SP)			;BUILD SCRATCH BUFFER DESCRIPTOR
	MOVZWL	#MSGBUFSIZ*2,-(SP)	;SET SIZE OF BUFFER
	MOVL	SP,R8			;SET ADDRESS OF SCRATCH BUFFER DESCRIPTOR
	MOVAB	WRK_AG_RESULT(FP),R10	;SET ADDRESS OF RESULT PARSE DESCRIPTOR TABLE
 
;
; INTERNAL COMMAND PARAMETERS:
;
;	R1 = LENGTH OF IMAGE FILENAME (IF ANY).
;	R2 = ADDRESS OF IMAGE FILENAME (IF ANY).
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; IMMEDIATE COMMAND PARAMETERS:
;
;	R6 = COMMAND BUFFER POINTER BACKUP PARAMETER.
;	R7 = RESULT PARSE TABLE POINTER BACKUP PARAMETER.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
 
IMMED:					;IMMEDIATE COMMAND EXECUTION
	BSBW	MCR$INTIMAGE		;EXECUTE INTERNAL IMAGE
ERROR_EXIT:				;ERROR EXIT
	BLBS	R0,10$			;IF LBS SUCCESSFUL COMPLETION
	ERRMSG				;OUTPUT SYSTEM ERROR MESSAGE
10$:	SET_STATUS			;SET COMPLETION STATUS
RSTRT:	BSBW	MCR$FLUSH		;FLUSH COMMAND BUFFER
	BRW	MCR$RESTART		;

;
; DEFINE INTERNAL ROUTINES
;

	.MACRO	INTIMAGE IMAGE
IMG_K_'IMAGE = $INTIMAGE$		;DEFINE INTERNAL IMAGE SYMBOL
$INTIMAGE$=$INTIMAGE$+1
	.WORD	MCR$'IMAGE'-INTIMAGEBASE
	.ENDM	INTIMAGE

MCR$INTIMAGE::				;ADDRESS OF INTERNAL IMAGE CASE TABLE
	CASEB	R3,#0,#<INTIMAGETOP-INTIMAGEBASE>/2-1
INTIMAGEBASE:				;BASE ADDRESS OF CASE TABLE
	.LIST	MEB
	MCRINTIMG			;GENERATE INTERNAL IMAGE CASE TABLE
	.NLIST	MEB
INTIMAGETOP:				;TOP ADDRESS OF CASE TABLE
	MOVZWL	#SS$_ILLSER,R0		;SET SERVICE ERROR
	RSB				;


	.SBTTL	CALL LOGINOUT TO ABORT THE PROCESS
;----
;	MCR$ABORT
;
;	Control is transferred here to abort the process by calling
;	the LOGINOUT image.  Care is taken to setup the result
;	parse descriptors so that LOGINOUT can use result parsing
;	as if LOGOUT was given as a command line.
;
;   Inputs:
;
;	None
;----

MCR$ABORT::
	MOVAB	WRK_AG_RESULT(FP),R10	; SETUP POINTER TO RESULT ARRAY
	MOVAB	WRK_AB_BUFFER(FP),R2	; GET ADDRESS OF EXPANSION BUFFER
	MOVL	R2,R9			; RESET EXPANSION BUFFER POINTER
	MOVL	#^A'LOGO',(R2)		; STORE VERB INTO BUFFER
	MOVL	#4,R1			; SET LENGTH OF VERB
	MOVZBL	#IMG_K_LOGOUT,WRK_L_IMAGE(FP) ; SET ROUTINE IN CASE NOT FOUND
	BSBW	SEARCH_VERB		; LOCATE COMMAND DEFINITION FOR
					; LOGOUT CLI INTERFACE (IGNORE ERRORS)
	BRW	BUILD_IMAGE		; PROCESS LOGOUT COMMAND

	.SBTTL	CHECK FOR CONTROL Y/C AST PENDING
;+
; MCR$CHECK_AST - CHECK FOR CONTROL Y/C AST PENDING
;
; THIS ROUTINE IS CALLED TO CHECK FOR A PENDING CONTROL Y/C AST.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF A CONTROL Y/C AST IS PENDING, THEN CONTROL IS TRANSFERED TO THE COMMAND
;	RESTART ENTRY POINT. OTHERWISE CONTROL IS RETURNED TO THE CALLER.
;-
 
	.ENABL	LSB
MCR$CHECK_AST::				;CHECK FOR PENDING CONTROL Y/C AST
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),50$ ;IF CLR, NO PENDING AST
10$:	BRW	MCR$RESTART		;

	.SBTTL	ENABLE/DISABLE CONTROL Y/C AST'S
;+
; MCR$DISABLE - DISABLE CONTROL Y/C AST'S
;
; THIS ROUTINE IS CALLED TO DISABLE/ENABLE CONTROL Y/C AST'S.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	CONTROL Y/C AST'S ARE DISABLED, THE PREVIOUS ENABLE STATE IS SAVED, AND
;	A CO-ROUTINE CALL IS MADE BACK TO THE CALLER. WHEN CONTROL RETURNS, THE
;	AST STATE IS RESTORED TO ITS VALUE BEFORE THE DISABLE.
;
;	ALL REGISTERS ARE PRESERVED ACROSS CALL
;-
 
MCR$DISABLE::				;DISABLE CONTROL Y/C AST'S
	PUSHL	(SP)			;COPY RETURN ADDRESS
	MOVZWL	PRC_W_FLAGS(R11),4(SP)	;SAVE PREVIOUS DISABLE STATE
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	JSB	@(SP)+			;CALL THE CALLER BACK
	BBS	#PRC_V_DISABL,4(SP),40$	;IF SET, AST'S PREVIOUSLY DISABLED
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF SET, AT CONTROL Y/C LEVEL
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BNEQ	30$			;IF NEQ NO
20$:	BBS	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),10$ ;IF SET, CONTROL Y/C REQUEST
30$:	BICW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;ENABLE CONTROL Y/C AST'S
40$:	POPL	(SP)			;REMOVE PREVIOUS STATE FROM STACK
50$:	RSB				;
	.DSABL	LSB

	.SBTTL	FLUSH COMMAND BUFFER
;+
; MCR$FLUSH - FLUSH COMMAND BUFFER
;
; THIS ROUTINE IS CALLED TO READ CHARACTERS FROM THE COMMAND BUFFER UNTIL AN
; END OF LINE IS ENCOUNTERED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	INDIRECT FILE RECOGNITION IS DISABLED AND CHARACTERS ARE READ FROM THE
;	INPUT BUFFER UNTIL AN END OF LINE IS ENCOUNTERED.
;-
 
MCR$FLUSH::				;FLUSH COMMAND BUFFER
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF AT ^Y LEVEL DON'T FLUSH
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),5$	;IF NOT IN A .GOTO SECTION, BRANCH
	CMPB	R0,#^A/;/		;In a .GOTO section - also in a comment?
	BNEQ	5$			;If NEQ, no
	SETBIT	LOC_V_FULCOM,WRK_W_LOCFLG(FP) ;Set comment-in-a-.GOTO-section flag
5$:	MOVL	PRC_L_INDINPRAB(R11),R0	;GET CURRENT INPUT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R0),20$ ;LIKEWISE FOR TERMINALS
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
10$:	GETCHAR				;GET CHARACTER FROM INPUT BUFFER
	BNEQ	10$			;IF NEQ NOT END OF LINE
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE RECOGNITION
20$:	RSB				;


	.ENABLE	LSB
	.SBTTL	PARSE A DCL-TYPE COMMAND
;+
; MCR$PARSE_DCL - PARSE A DCL-TYPE COMMAND
;
; THIS ROUTINE IS CALLED TO PARSE A COMMAND THAT MIMICS A DCL COMMAND
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 CONTAINS THE STATUS OF THE PARSE
;-

MCR$PARSE_DCL::

	SETBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;SET VERB PROCESSING FLAG
;
; TREAT FIRST VERB QULIFIER AS A KEYWORD IF P1 ACTUALLY TAKES A KEYWORD
; (E.G. SET/TERMINAL -> SET TERMINAL)
;
	SETCHAR				;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BEQL	10$			;IF EQL QUALIFIER OR OPTION
	CMPB	#^A/ /,R0		;NEXT CHARACTER A SPACE?
	BNEQ	PARSE_PARMS		;IF NOT (NEQ), INVALID PARAMETER DELIMITER
	SETNBLK				;GET NEXT NON-BLANK CHARACTER
	CMPB	#^A\/\,R0		;QUALIFIER OR POSSIBLE OPTION?
	BNEQ	20$			;IF NEQ NO
10$:	MOVL	WRK_L_PROPTR(FP),R1	;GET ADDRESS OF P1 DESCRIPTOR
	BEQL	PARSE_QUAL		;BR IF NO PROMPT DESCRIPTOR
	TSTW	ENT_W_KEYWORDS(R1)	;DOES P1 TAKE A KEYWORD VALUE (OPTION?)
	BEQL	PARSE_QUAL		;IF NOT, PROCESS AS QUALIFIER
	MOVL	WRK_L_CHARPTR(FP),R0	;GET CURRENT CHARACTER POINTER
	MOVB	#^A/ /,1(R0)		;SET QUALIFIER SLASH TO A BLANK
	BRB	PARSE_PARMS		;PROCESS AS PARAMETER

20$:	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;REPLACE BLANK BEFORE PARAMETER AS DELIMITER
	DECL	WRK_L_CHARPTR(FP)	;BACK UP INPUT BUFFER PTR TO THE BLANK
	BRB	PARSE_PARMS		;PROCESS THIS PARAMETER

PARSE_QUAL:
	SETCHAR				;PEEK AT NEXT CHAR. IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	BSBW	MCR$MARK		;SAVE DISPLAY PARAMETER
	MOVZBL	#PTR_K_COMDQUAL,R3	;SET CLASSIFICATION TO COMMAND QUALIFIER
	PROCQUAL			;PROCESS QUALIFIER
	BLBS	R0,PARSE_QUAL		;IF LBS SUCCESSFUL COMPLETION
	BRW	ERROR_EXIT		;

;
; PROCESS COMMAND PARAMETERS
;

PARSE_PARMS:
	CLRBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;CLEAR VERB PROCESSING
150$:	MOVL	WRK_L_PROPTR(FP),R8	;GET ADDRESS OF P1 DESCRIPTOR
	MOVL	WRK_L_PARMCNT(FP),R0	;GET PARAMETER # BEING PARSED
	BEQL	155$			;BRANCH IF NO LOOP NEEDED
152$:	MOVZBL	ENT_B_NEXT(R8),R1	;GET OFFSET TO NEXT DESCRIPTOR
	ADDL	R1,R8			;SKIP TO NEXT ENTITY DESCRIPTOR
	SOBGTR	R0,152$			;LOOP UNTIL PARAMETER FOUND
155$:	BSBW	MCR$MARK		;MARK CURRENT PARSE POSITION
	SETCHAR				;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BNEQ	158$			;IF NEQ, NOT END OF LINE
	BRW	245$			;EOL
158$:	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	230$			;IF NEQ NO
160$:	BSBW	MCR$MARK		;MARK CURRENT PARSE POSITION
	TSTL	WRK_L_MAXPARM(FP)	;PARAMETERS ALLOWED ON THIS COMMAND?
	BEQL	200$			;BR IF NONE ALLOWED
	MOVZBL	#PTR_K_PARAMETR,R3	;SET CLASSIFICATION FOR OPTION DETECTION
	TSTW	ENT_W_KEYWORDS(R8)	;DOES PARAMETER TAKE KEYWORD VALUE?
	BNEQ	180$			;IF SO, PROCESS AS QUALIFIER
	BSBW	MCR$PARSE_VALUE		;PROCESS PARAMETER VALUE
170$:	BLBC	R0,215$			;IF LBC PARSE ERROR
	SETCHAR				;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/:/,R0		;COLON (MOUNT, INIT COMMANDS DELIMITER)?
	BNEQ	175$			;IF NEQ NO
	MOVCHAR				;MOVE THE COLON INTO THE BUFFER
	SETCHAR				;LOOK AT THE NEXT CHARACTER
	CMPB	#^A\/\,R0		;QUALIFIER FOLOWING THE DEVICE SPEC?
	BEQL	178$			;IF EQL YES
	BSBW	MCR$BACKUPMOVE		;BACKUP TO THE COLON AGAIN
	BRB	190$			;AND CONTINUE PARSING
175$:	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	190$			;IF NEQ NO
178$:	MOVZBL	#PTR_K_PARMQUAL,R3	;SET CLASSIFICATION OF QUALIFIER
180$:	PROCQUAL			;PROCESS QUALIFIER SPECIFICATION
	BRB	170$			;
190$:	CMPB	#^A/,/,R0		;MULTIPLE PARAMETERS?
	BEQL	210$			;IF EQL YES
	CMPB	#^A/+/,R0		;CONCATENATED PARAMETERS?
	BEQL	220$			;IF EQL YES
	TSTW	ENT_W_KEYWORDS(R8)	;DOES PARAMETER TAKE KEYWORD VALUE?
	BNEQ	150$			;IF SO, PARAMETER TREATED AS QUALIFIER
	INCL	WRK_L_PARMCNT(FP)	;INCREMENT COUNT OF PARAMETERS
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MAXPARM(FP) ;MAXIMUM PARAMETERS EXCEEDED?
	BGTR	200$			;BR IF YES
	BRB	150$			;
 
;
; MAXIMUM PARAMETER COUNT EXCEEDED
;
 
200$:	STATUS	MAXPARM			;ASSUME MAXIMUM PARAMETERS EXCEEDED
	BRB	250$			;
 
;
; PARAMETER LIST SPECIFIED
;
 
210$:	BBS	#ENT_V_LIST,ENT_L_FLAGS(R8),160$ ;IF SET, LISTS ALLOWED
	STATUS	NOLIST			;SET NO LISTS ALLOWED STATUS
215$:	BRB	250$			;
 
;
; PARAMETER CONCATENATION SPECIFIED
;
 
220$:	BBS	#ENT_V_CONCAT,ENT_L_FLAGS(R8),160$ ;IF SET, CONCATENATION ALLOWED
	STATUS	NOCCAT			;SET NO CONCATENATION ALLOWED STATUS
	BRB	250$			;
 
;
; INVALID PARAMETER DELIMITER
;
 
230$:	PUSHR	#^M<R0,R1,R8>		;SAVE REGISTERS
	MOVL	WRK_L_PROPTR(FP),R8	;GET P1 DESCRIPTOR AGAIN
	MOVL	WRK_L_PARMCNT(FP),R0	;GET CURRENT PARAMETER NUMBER
	DECL	R0			;BACK UP TO THE LAST PARAM BEFORE THIS ONE
	BEQL	240$			;IF EQL, WE WANT TO CHECK THE 1ST PARAM.
235$:	MOVZBL	ENT_B_NEXT(R8),R1	;GET NEXT DESCRIPTOR OFFSET
	ADDL	R1,R8			;LINK TO NEXT ENTITY DESCRIPTOR
	SOBGTR	R0,235$			;LOOP UNTIL WE FIND THE PARAM WE WANT
240$:	CMPB	#ENT_C_DEVICE,ENT_B_VALTYPE(R8) ;WAS PREVIOUS PARAM A DEVICE?
	BNEQ	242$			;IF NEQ NO (DELIMITER OTHER THAN BLANK ILLEGAL)
	POPR	#^M<R0,R1,R8>		;RESTORE RO=CHAR PTR, R8=CURRENT ENT. DESCR.
	CMPB	#^A/:/,R0		;COLON IS A VALID DELIMITER HERE
	BNEQ	243$			;IF NEQ, INVALID DELIMITER
	BRW	160$			;CONTINUE PARSING
242$:	POPR	#^M<R0,R1,R8>		;CLEAN STACK UP
243$:	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
	BRB	250$

245$:	STATUS 	NORMAL
250$:	RSB
	

	.ENABLE LSB
	.SBTTL	PARSE MCR-TYPE COMMANDS
;+
; MCR$PARSE_MCR - PARSE MCR-TYPE COMMANDS
;
; THIS ROUTINE IS CALLED TO PARSE A COMMAND OF THE FORM:
;
;	OUTPUT[/QUALIFIERS] = INPUT(S)[/QUALIFIERS]
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 CONTAINS THE STATUS OF THE PARSE
;-

MCR$PARSE_MCR::

;
; PROCESS COMMAND PARAMETERS
;
 
	CLRBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;CLEAR VERB PROCESSING
	TESTBLANK			;PEEK AT NEXT CHARACTER
5$:	MOVZBL	#PTR_K_COMDQUAL,R3	;ASSUME WE'LL FIND A COMMAND QUALIFIER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	10$			;IF NEQ NO
	PROCQUAL			;PROCESS COMMAND QUALIFIER
	TESTBLANK			;PEEK AT NEXT CHARACTER
	BNEQ	5$			;LOOK FOR MORE COMMAND QUALIFIERS
10$: 	MOVL	WRK_L_PROPTR(FP),R8	;GET PARAMETER LIST PTR.
	TSTB	@WRK_L_PAROUT(FP)	;CHECK NUMBER OF OUTPUTS
	BEQL	60$			;NONE IF EQL
	CMPB	R0,#^A/,/		;PARAMETER LIST SEPARATOR
	BEQL	55$			; Yes if EQL
	CMPB	R0,#^A/=/		; Null output list?
	BNEQ	60$			;BR IF NO
55$:
	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;SET A NULL PARAMETER
	DECL	WRK_L_CHARPTR(FP)	;BACK UP TO GET SPACE NEXT
	BBS	#ENT_V_VALREQ,ENT_L_FLAGS(R8),105$ ;ERROR IF PARM SHOULDN'T BE NULL
	BRB	70$			;PROCESS NULL FILE SPEC
60$:	BSBW	MCR$MARK		;SAVE ADDRESS INCASE ERROR
	TESTBLANK			;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BEQL	102$			;IF EQL END OF LINE
	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	63$			;BR IF NO
	TSTL	WRK_L_PARMCNT(FP)	;LOOKING AT FIRST PARAMETER?
	BEQL	70$			;BR IF YES
	BRB	65$			;ELSE LINK TO NEXT PARAM. DESCRIP. AND CHECK PARAM.
63$:	CMPB	#^A/=/,R0		;IS INPUT/OUTPUT SEPARATOR
	BNEQ	120$			;IF NEQ NO
	BBSS	#WRK_V_EQUAL,WRK_W_FLAGS(FP),120$ ;BR IF SECOND EQUAL SIGN
65$:	MOVZBL	ENT_B_NEXT(R8),R1	;GET OFFSET TO NEXT PARAM. DESCRIPTOR
	BEQL	140$			;RAN OUT OF DESCRIPTORS BEFORE LAST PARM
	ADDL	R1,R8			;LINK TO NEXT PARAMETER DESCRIPTOR
70$:	BSBW	MCR$MARK		;SAVE DISPLAY PARAMETER
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MAXPARM(FP) ;TOO MANY PARAMETERS?
	BGEQ	140$			;BR IF YES
	BRB	PARMQUAL		;PROCESS THIS PARM AND ITS CORRESPONDING QUALS.
80$:	INCL	WRK_L_PARMCNT(FP)	;COUNT NUMBER OF PARAMETERS SEEN
	CMPB	#^A/,/,R0		;MULTIPLE PARAMETERS?
	BEQL	110$			;IF EQL YES
	CMPB	R0,#^A/+/		; Multiple parameters?
	BEQL	115$			; If EQL yes
	CMPB	@WRK_L_PAROUT(FP),WRK_L_PARMCNT(FP) ;HAVE WE PARSED ALL THE OUTPUTS?
	BEQL	60$			;BR IF YES
 	BLSS	100$
;
; Checking for and setting errors
;

	MOVL	WRK_L_PARMCNT(FP),R3	;SET UP A COUNTER TO FIND INPUT PARMS
;
; check to see if the remaining outputs are required
;
90$:	MOVZBL	ENT_B_NEXT(R8),R1	;GET OFFSET OF NEXT PARAM DESCRIPTOR
	BEQL	130$			;IF EQL, ERROR IN COMMAND TABLES
	ADDL	R1,R8			;LINK TO NEXT PARMETER DESCRIPTOR
	INCL	R3			;COUNTING PARMS IN LINKED LIST
	CMPB	R3,@WRK_L_PAROUT(FP)	;HAVE WE LOOKED AT ALL LEFTOVER OUTPUTS?
	BEQL	60$			;IF GTR, YES - GO PARSE THE INPUTS
	BBS	#ENT_V_VALREQ,ENT_L_FLAGS(R8),105$ ;IF MISSING PARM IS REQ'D - ERROR
	BRB	90$


100$: 	; end of input parsing - do some cleanup checks 
	TESTBLANK			;LOOK AT NEXT CHARACTER IN INPUT BUFFER
	BNEQ	140$			;IF NOT EOL, TOO MANY PARAM.'S
102$:	BRB	145$			;EOL - AND AWAY WE GO!

105$:	STATUS	INSFPRM			;MISSING A PARAMETER(S)
	BRB	150$

110$:	BBS	#ENT_V_LIST,ENT_L_FLAGS(R8),65$	;BR IF LISTS ALLOWED
	STATUS	NOLIST
	BRB	150$

115$:	BBS	#ENT_V_CONCAT,ENT_L_FLAGS(R8),65$ ;BR IF CONCATENATION ALLOWED
	STATUS	NOCCAT
	BRB	150$

120$:	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
	BRB	150$

130$:	STATUS	BADSTRLVL		;COMMAND TABLES ARE MESSED UP
	BRB	150$

140$:	STATUS	MAXPARM			;TOO MANY PARAMETERS
	BRB	150$

145$:	STATUS	NORMAL			;END OF LINE
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MINPARM(FP) ;ENOUGH PARAMETERS?
	BLSS	105$			;BR IF NO
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MAXPARM(FP) ;TOO MANY PARAMETERS?
	BGTR	140$			;BR IF YES

150$:	RSB


PARMQUAL:
	PROCFILE			;PROCESS FILE SPECIFICATION
200$:	BLBC	R0,150$			;IF LBC PARSE ERROR
	SETCHAR				;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BEQL	210$			;IF EQL YES
	BRW	80$			;GO BACK TO SEE IF THERE ARE MORE PARAMETERS
210$:	CLRBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;MAKE SURE VERB FLAG IS OFF
	MOVZBL	#PTR_K_PARMQUAL,R3	;THIS WILL BE A PARAMETER QUALIFIER
	PROCQUAL			;PROCESS QUALIFIER SPECIFICATION
	BRB	200$			;

	.DISABLE LSB

	.SBTTL	SEARCH VERB TABLE
;---
; SEARCH_VERB - SEARCH VERB TABLE AND OBTAIN VERB INFORMATION
;
; THIS ROUTINE SEARCHES THE VERB TABLE FOR A SPECIFIED STRING.
; IF FOUND, THE VERB ATTRIBUTES ARE STORED IN THE COMMAND WORK AREA.
;
; INPUTS:
;
;	R1 = LENGTH OF VERB TOKEN
;	R2 = ADDRESS OF VERB TOKEN
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R1 AND R2 ARE PRESERVED.
;	THE COMMAND WORK AREA IS INITIALIZED IF VERB FOUND.
;---

SEARCH_VERB:
	PUSHR	#^M<R1,R2,R6,R7>	;SAVE REGISTERS
	MOVQ	R1,R4			;SAVE COMMAND VERB DESCRIPTOR
	CMPL	#4,R4			;COMMAND VERB LESS THAN 5 CHARACTERS?
	BGEQ	20$			;IF GEQ YES
	MOVL	#4,R4			;SET TO SCAN ONLY 4 CHARACTERS
20$:	BISB	#^X80,(R5)		;SET HIGH ORDER BIT TO FORCE COMMAND MATCH
	MOVL	PRC_L_TAB_VEC(R11),R8	;GET ADDRESS OF DATA BASE VECTOR
	ADDL3	VEC_L_COMDPTR(R8),R8,R7	;SET BASE OF POINTER IN PROMPT BUFFER
	SUBL3	VEC_L_VERBTBL(R8),-	;COMPUTE LENGTH OF MCR VERB
		VEC_L_VERBEND(R8),R0	;TABLE (IN BYTES)
	DIVL3	#4,R0,R6		; ... IN VERBS (4 BYTES PER VERB)
	ADDL3	VEC_L_VERBTBL(R8),R8,R1	;COMPUTE ADDRESS OF VERB TABLE
	MATCHC	R4,(R5),R0,(R1)		;SCAN FOR VERB MATCH
	BEQL	25$			;BR IF VERB MATCH
	ADDL3	VEC_L_USERPTR(R8),R8,R7	;SET BASE ADDRESS OF USER PROMPT BUFFER
	SUBL3	VEC_L_USRCMD(R8),-	;COMPUTE LENGTH OF USER VERB
		VEC_L_USREND(R8),R0	;TABLE (IN BYTES)
	DIVL3	#4,R0,R6		; ... IN VERBS
	ADDL3	VEC_L_USRCMD(R8),R8,R1	;COMPUTE ADDRESS OF USER VERB TABLE
	MATCHC	R4,(R5),R0,(R1)		;SCAN FOR VERB MATCH
	BEQL	25$			;BRANCH IF MATCH FOUND
	STATUS	IVVERB			;INVALID VERB
	BRW	90$
25$:	MOVL	R8,R1			;SAVE ADDRESS OF TABLES VECTOR
	ADDL	R4,R2			;CALCULATE BYTES REMAINING INCLUDING SUBSTRING
	DIVL3	#4,R2,R8		;CALCULATE COMPLEMENT COMMAND INDEX
	SUBW3	R8,R6,R8		;CALCULATE VERB INDEX
	CMPB	VEC_B_STRLVL(R1),#5	;STRUCTURE LEVEL 5?
	BGEQ	27$			;BRANCH IF 5 OR GREATER
	STATUS	BADSTRLVL		;NOT USING THE CORRECT TABLE STRUCTURE
	BRB	90$
27$:	MOVAL	(R7)[R8],R0		;GET ADDRESS OF CMD BLOCK OFFSET
	MOVL	(R0)+,R8		;GET DISPLACEMENT TO COMMAND BLOCK
	ADDL	R0,R8			;CALCULATE ADDRESS OF COMMAND BLOCK
	BBS	#CMD_V_ABREV,CMD_B_FLAGS(R8),30$ ;IF SET, NON UNIQUE ACCEPTABLE
	SUBL	R4,R3			;BACKUP TO START OF VERB ENTRY FOUND
	CMPC5	R4,(R5),#^A' ',#4,(R3)	;EXACT MATCH?
	BEQL	30$			;IF EXACT MATCH, IGNORE AMBIGUITY
	MATCHC	R4,(R5),#7,(R3)		;SCAN FOR DUPLICATE MATCH
	BNEQ	30$			;IF NEQ UNIQUE MATCH
	STATUS	ABVERB			;AMBIGUOUS COMMAND VERB
	BRB	90$
;
; VERB MATCH FOUND - EXTRACT ATTRIBUTES FROM COMMAND DESCRIPTOR BLOCK
;
30$:	MOVB	CMD_B_VERBTYP(R8),WRK_B_VERBTYP(FP)	;SET VERB GENERIC TYPE
	EXTZV	#CMD_V_MINPARM,-	;EXTRACT MINIMUM NUMBER OF PARAMETERS
		#CMD_S_MINPARM,CMD_B_PARMCNT(R8),WRK_L_MINPARM(FP)
	EXTZV	#CMD_V_MAXPARM,-	;EXTRACT MAXIMUM NUMBER OF PARAMETERS
		#CMD_S_MAXPARM,CMD_B_PARMCNT(R8),WRK_L_MAXPARM(FP)
	CVTWL	CMD_W_IMAGE(R8),R0	;GET OFFSET TO IMAGE NAME
	BGEQ	35$			;BRANCH IF POSITIVE
	MNEGL	R0,R0			;GET INDEX INTO IMAGE NAME TABLE
	BRB	38$
35$:	BSBB	CONVERT_SRO		;GET ADDRESS OF IMAGE NAME
38$:	MOVL	R0,WRK_L_IMAGE(FP)	;ADDRESS OF USER IMAGE
	CVTWL	CMD_W_QUALS(R8),R0	;GET OFFSET TO FIRST QUALIFIER DESC
	BSBB	CONVERT_SRO		;GET ADDRESS OF QUALIFIER DESCRIPTORS
	MOVL	R0,WRK_L_QUABLK(FP)	;SET ADDRESS QUALIFIER DESCRIPTORS
	CVTWL	CMD_W_PARMS(R8),R0	;GET OFFSET TO FIRST POSITIONAL ENTITY
	BSBB	CONVERT_SRO		;GET ADDRESS OF PARAMETER DESCRIPTORS
	MOVL	R0,WRK_L_PROPTR(FP)	;SAVE ADDRESS OF PARAMETER DESCRIPTORS
	CVTWL	CMD_W_OUTPUTS(R8),R0	;GET OFFSET TO OUTPUT LIST
	BSBB	CONVERT_SRO		;GET ADDRESS OF OUTPUT LIST
	MOVL	R0,WRK_L_PAROUT(FP)	;SAVE ADDRESS OF OUTPUT LIST
	CLRL	WRK_L_PARMCNT(FP)	;CLEAR COUNT OF PARAMETERS
	CLRB	WRK_B_CMDOPT(FP)	;CLEAR ENTITY # CAUSING SYNTAX CHANGE
	MOVL	#1,R0			;SUCCESSFUL
90$:	BICB	#^X80,(R5)		;CLEAR TOP BIT OF 1ST CHAR IN LINE
	POPR	#^M<R1,R2,R6,R7>		;RESTORE REGISTERS
	RSB
 
;
; CALCULATE ADDRESS FROM SELF-RELATIVE DISPLACEMENT
;
 
CONVERT_SRO::
	TSTL	R0			;CHECK DISPLACEMENT
	BEQL	110$			;IF EQL NONE
	ADDL	R8,R0			;CALCULATE ACTUAL ADDRESS
110$:	RSB				;

	.SBTTL	PROCESS FOREIGN COMMAND
;
; SUBROUTINE TO PROCESS FOREIGN COMMAND AND BUILD RESULT PARSE DESCRIPTOR
;
 
PROCFORN:				;PROCESS FOREIGN COMMAND
	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;MAKE SURE THERE IS A SPACE
	DECL	WRK_L_CHARPTR(FP)	;BACKUP POINTER TO GET SPACE
	MOVAB	1(R9),R8		;SET START OF LINE AFTER SPACE
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE INTERPRETATION
10$:	MOVCHAR				;MOVE CHARACTER TO COMMAND BUFFER
	BNEQ	10$			;IF NEQ NOT END OF FILE
	DECL	R9			;BACK UP TO TERMINATOR
	SUBL3	R8,R9,R7		;CALCULATE LENGTH OF COMMAND LINE
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#PTR_K_PARAMETR,R5	;SET ITEM TYPE TO PARAMETER
	GENDESCR			;GENERATE RESULT PARSE TABLE DESCRIPTOR
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE INTERPRETATION
	RSB				;
 
	.END
