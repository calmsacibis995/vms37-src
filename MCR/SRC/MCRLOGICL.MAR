	.TITLE	MCRLOGICL - LOGICAL NAME MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 4-JAN-1978
;
; Modified:
;
;	V002	MAJ0002		Melanie Johnson 22-Feb-82
;		Check token length rather than PTR_V_EQUAL (equal sign
;		seen bit) to determine when to deassign.
;
;	V001	MAJ0001		Melanie Johnson	04-Jan-82
;		Reference PTR_V_EQUAL as a bit in PTR_L_DESCR(R10). It is no
;		longer bit 0.
;
; LOGICAL NAME MCR COMMAND EXECUTION
;
;	ALLOCATE DEVICE
;	ASSIGN/DEASSIGN LOGICAL NAME
;	DEALLOCATE DEVICE
;	DEFINE LOGICAL NAME
;
; MACRO LIBRARY CALLS
;
 
	$CLIDEFQUALDEAL			; DEFINE DEALLOCATE QUALIFIER NUMBERS
	DEFCMDWRK			; DEFINE WORK AREA OFFSETS
	DEFERRCOD			; DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$LOGDEF				; DEFINE LOG OFFSETS
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				; DEFINE SYSTEM STATUS VALUES
	CLI$K_ASN_TERM==3
	CLI$K_ASN_GROU==2
	CLI$K_ASN_GBL ==1
 
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
ALLOCATE:				; ALLOCATE TEXT
	.ASCII	/ ALLOCATED/		; 
A:					; 
SUPERSEDE:				; LOGICAL NAME SUPERSEDED MESSAGE
	.ASCII	/  PREVIOUS LOGICAL NAME ASSIGNMENT REPLACED/ ; 
B:					; 
	.PAGE
	.SBTTL	ALLOCATE DEVICE
;+
; MCR$ALLOCATE - ALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ALLOCATE MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS ALLOCATED AND ASSIGNED THE SPECIFIED LOGICAL
;	NAME. IF THE LOGICAL NAME WAS PREVIOUSLY ASSIGNED, THEN A MESSAGE TO
;	THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
	.ENABL	LSB
MCR$ALLOCATE::				; ALLOCATE DEVICE
	BSBW	GETDEV			; GET DEVICE NAME TO ALLOCATE
	$ALLOC_S (R9),(R8),(R8)		; ALLOCATE DEVICE
	BLBC	R0,50$			; IF LBC ALLOCATION FAILURE
	MOVQ	(R8),-(R9)		; SAVE DEVICE NAME DESCRIPTOR
	ADDL3	(R8)+,(R8),R0		; CALCULATE ADDRESS TO APPEND TEXT
	MOVC	#A-ALLOCATE,ALLOCATE,(R0) ; APPEND TEXT TO DEVICE NAME
	MOVL	(R8),R2			; GET STARTING ADDRESS OF DEVICE NAME
	MOVW	#^A/  /,-(R2)		; INSERT 2 LEADING SPACES
	SUBL3	R2,R3,R1		; CALCULATE LENGTH OF MESSAGE
	MSGOUT				; OUTPUT ALLOCATION MESSAGE
	BSBW	GETDEV			; GET LOGICAL NAME
	BLBC	R0,40$			; BR IF NAME IS HERE
	MOVZBL	#LOG$C_PROCESS,R7	; SET TABLE NUMBER
	BRB	30$			; ELSE EXIT
	.PAGE
	.SBTTL	ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;+
; MCR$ASSIGN - ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ASSIGN MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. IF A PREVIOUS LOGICAL ASSIGNMENT IS SUPERSEDED, THEN A
;	MESSAGE TO THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
MCR$ASSIGN::				; ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
	MOVZBL	#LOG$C_PROCESS,R7	; SET TABLE NUMBER
	BSBB	100$			; SET TABLE NUMBER
	CMPB	R5,#PTR_K_PARAMETR	; IS NEXT DESCRIPTOR FOR A PARAMETER?
	BGTR	65$			; BR IF EOL IS NEXT
	TSTB	R1			; CHECK RETURNED TOKEN LENGTH
	BEQL	60$			; BR TO DEASSIGN IF EQUIV. NAME IS NULL (EQL)
	COMPSTRING			; REMOVE QUOTES
	MOVQ	R1,-(R9)		; SAVE DESCRIPTOR FOR NAME
	BSBB	100$			; CHECK FOR QUALIFIERS
	CMPB	R5,#PTR_K_PARAMETR	; CHECK FOR REQUIRED PARAMETER
	BNEQ	80$			; BR IF SYNTAX ERROR
	BSBW	SETNAM			; SET LOGICAL NAME
	BSBB	100$			; CHECK FOR QUALIFIERS
30$:	$CRELOG_S R7,(R9),8(R9),#PSL$C_SUPER ; CREATE LOGICAL NAME IN SPECIFIED TABLE
	CMPW	#SS$_SUPERSEDE,R0	; PREVIOUS ASSIGNMENT SUPERSEDED?
	BNEQ	50$			; IF NEQ NO
	MOVZBL	#B-SUPERSEDE,R1		; GET LENGTH OF SUPERSEDE MESSAGE
	MOVAB	SUPERSEDE,R2		; GET ADDRESS OF SUPERSEDE MESSAGE
	MSGOUT				; OUTPUT MESSAGE
40$:	STATUS	NORMAL			; SET NORMAL COMPLETION
50$:	RSB				; 
60$:	BSBB	100$			; GET LOGICAL NAME TO DELETE
	CMPB	R5,#PTR_K_PARAMETR	; IS THE NEXT TOKEN A PARAMETER?
	BGTR	65$			; BR IF EOL (DELETE ALL)
	TSTB	R1			; CHECK FOR EXPLICIT NULL LOGICAL NAME
	BEQL	65$			; BR IF EQL TO TREAT AS REQUEST TO DELETE ALL
	BSBW	SETNAM			; SET LOGICAL NAME TO DELETE
	BSBB	100$			; CHECK FOR QUALIFERS
	$DELLOG_S R7,(R9),#PSL$C_SUPER	; DELETE LOGICAL NAMES
	BRB	70$			;
65$:	BBC	#WRK_V_EQUAL,WRK_W_FLAGS(FP),80$ ; BR IF NO "=" SEEN
	CLRL	R9			; NO PARAMETERS - DELETE ALL
	$DELLOG_S R7,,#PSL$C_SUPER	; DELETE ALL LOGICAL NAMES ENTERED BY USER
70$:	RSB				;
 
;
; COMMAND HAS INVALID SYNTAX
;
 
80$:	STATUS	INSFPRM			; TELL ERROR
	RSB				;
100$:	GETDVAL				; TAKE RESULT DESCRIPTOR APART
	CMPL	R5,#PTR_K_PARMQUAL	; IS THIS FOR A QUALIFIER
	BGTR	110$			; BR IF NO
	MOVAB	LOG$C_SYSTEM-1(R1),R7	; GET THE TABLE NUMBER
	BRB	100$			; LOOK FOR MORE
110$:	RSB
	.DSABL	LSB
	.PAGE
	.SBTTL	DEALLOCATE DEVICE
;+
; MCR$DEALLOCATE - DEALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEALLOCATE
; MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS DEALLOCATED OR ALL DEVICES ARE DEALLOCATED.
;-
 
MCR$DEALLOCAT::				; DEALLOCATE DEVICE
	BSBB	GETDEV			; GET DEVICE NAME TO DEALLOCATE
	BLBS	R0,10$			; BR IF DEVICE NAME HERE
	CLRL	R9			; DEALLOCATE ALL
10$:	$DALLOC_S (R9)			; DEALLOCATE DEVICE
	RSB				; 
 
;+
; GETDEV - GET DEVICE NAME
;
; COMMON ROUTINE TO GET A DEVICE NAME AND REMOVE COLON IF PRESENT
;
; INPUTS:	SAME AS DEASSIGN AND DEALLOCATE
;-
 
GETDEV:	GETDVAL				; GET NEXT DESCRIPTOR VALUES
	CLRL	R0			; ASSUME NOT A PARAMETER
	CMPB	R5,#PTR_K_PARAMETR	; ITEM TYPE PARAMETER?
	BNEQ	20$			; BR IF NO
	BSBB	SETNAM			; SET THE NAME
	STATUS	NORMAL			; SET GOOD STATUS
20$:	RSB				;
 
;
; LOCAL ROUTINE TO SET THE DEVICE NAME DESCRIPTOR
;
 
SETNAM:	COMPSTRING			; REMOVE QUOTES
	CMPB	-(R1)[R2],#^A/:/	; NAME END WITH COLON
	BEQL	10$			; BR IF YES
	INCL	R1			; NO - PUT IT BACK
10$:	MOVQ	R1,-(R9)		; SAVE DEVICE NAME DESCRIPTOR
	RSB
 
	.END
