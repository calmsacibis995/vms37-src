	.TITLE	MCRSTAMNT - ARITHMETIC ASSIGNMENT AND STRING EQUATE PROCESSING
	.IDENT	'V03-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 7-DEC-1977
;
; ARITHMETIC ASSIGNMENT AND STRING EQUATE STATEMENT PROCESSING
;
; Modified by:
;
;	V3.001	MAJ0001		Melanie Johnson	07-Apr-1982
;		Fix .SETN to allow left parenthesis, '(', to be a valid
;		symbol delimeter since MCR$GETOKEN will strip the blank
;		between the symbol and the numeric expression beginning
;		with left parenthesis.
;
;	 V2.001	TMH0001		Tim Halvorsen	28-May-1981
;		Do not perform any range/type checking if ESCAPE key kit
;		in .ASK, but store a null string/zero in the symbol and
;		set the <ESCAPE> flag.
;---
 
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			; DEFINE WORK AREA OFFSETS
	DEFERRCOD			; DEFINE ERROR/STATUS CODES
	DEFSYMTBL			; DEFINE SYMBOL TABLE OFFSETS
	$RABDEF				;
 
;
; LOCAL DEFINITIONS
;
 
	WRK_L_LOLIM	= WRK_L_MAXPARM	; OVERLAY WORK DEFINITIONS
	WRK_L_HILIM	= WRK_L_MINPARM	; MAXIMUM VALUE FOR RESPONCE
	WRK_L_DEFAULT	= WRK_L_QUABLK	; DEFAULLT VALUE FOR NULL RESPONCE
	WRK_L_PRMTEND	= WRK_L_IMAGE	; END OF PROMPT STRING IN CMD BUFFER
;
; DEFINE LOCAL FLAGS
;
 
	_VIELD	ASK,0,<-		;
		<LOGICAL,,M>,-		; ASKING FOR A LOGICAL VALUE
		<NUMERIC,,M>,-		; ASKING FOR A NUMERIC
		<LIMITS,,M>,-		; LIMITS WERE SPECIFIED
		>
;
; LOCAL DATA
;
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
 
RADIXC:	.ASCII	\HDO\			; RADIX INDICATOR CHARACTERS
	.PAGE
	.SBTTL	ASK COMMAND 
;+
; MCR$ASK - ASK COMMAND
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ASK
;	MCR COMMAND.
;
; INPUTS:
;
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;
;	R0 LOW BIT CLEAR INDICATES COMMAND FAILURE
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
 
 
MCR$ASKN::				; ASK FOR A VALUE
	SETBIT	ASK_V_NUMERIC,WRK_W_LOCFLG(FP) ; FLAG AS DOING VALUE
MCR$ASKS::				; ASK STRING COMMAND
	CLRL	WRK_L_DEFAULT(FP)	; INIT DEFAULT TO ZERO
	SETNBLK				; LOOK AT NEXT CHARACTER IN INPUT STREAM
	CMPB	R0,#^A/[/		; IS THE LIMIT SPECIFICATION COMMING
	BNEQ	GETPMT			; BR IF NO - GET THE PROMPT STRING
	MOVNCHR				; MOVE BRAKET AND LOOK AT NEXT CHARACTER
	CMPB	R0,#^A/:/		; NULL LIMIT FIELD
	BNEQ	10$			; BR IF VALUE FOLLOWS
	MOVNCHR				; COPY THE COLON TO THE COMMADN BUFFER
	BRB	20$			; CHECK FOR DEFAULT VALUE
10$:	BSBW	GETVAL			; GET THE LO LIMIT VALUE
	BLBC	R0,60$			; BR IF ERROR EVALUATING LIMIT
	MOVL	R1,WRK_L_LOLIM(FP)	; SAVE THE LIMIT VALUE
	MOVTERM	<:>			; MOVE THE TERMINATOR
	BNEQ	40$			; BR IF NOT CORRECT
	SETBIT	ASK_V_LIMITS,WRK_W_LOCFLG(FP) ; FLAG LIMITS SEEN
	BSBW	GETVAL			; NOW GET UPPER LIMIT
	BLBC	R0,60$			; BR IF ERROR EVALUATING EXPRESSION
	STATUS	NUMBER			; ASSUME VALUE INVALID
	CMPL	R1,WRK_L_LOLIM(FP)	; UPPER LIMIT GREATER THAN LOWER LIMIT
	BLSS	60$			; BR if no - that will never work
	MOVL	R1,WRK_L_HILIM(FP)	; SAVE UPPER LIMIT
20$:	MOVTERM	<:>			; COPY TERMINATOR TO COMMAND BUFFER
	BNEQ	40$			; BR IF NO - MAYBE NO DEFAULT VALUE
	BSBW	GETVAL			; GET THE VALUE
	BLBC	R0,60$			; BR IF ERROR EVALUATING DEFAULT VALUE
	MOVL	R1,WRK_L_DEFAULT(FP)	; SET DEFAULT VALUE
	MOVCHAR				; COPY THE TERMINATOR TO COMMAND BUFFER
40$:	CMPB	R0,#^A/]/		; WAS IT CORRECT
	BEQL	GETPMT			; BR IF YES - GET THE PROMPT
50$:	STATUS	SYMDEL			; INVALID DELIMITER
60$:	RSB				;
 
MCR$ASK::				; ASK FOR TRUE OF FALSE
	CLRL	WRK_L_DEFAULT(FP)	; INIT DEFAULT TO ZERO
	BISW	#<ASK_M_NUMERIC!ASK_M_LOGICAL>,- ; INDICTE VALUE TO BE
		WRK_W_LOCFLG(FP)	; LOGICAL - WHICH IS NUMERIC!
GETPMT:	BSBW	MCR$SYMNAM		; GET THE SYMBOL NAME
	MOVAB	(R9)+,WRK_L_PROMPT(FP)	; SAVE START OF PROMPT STRING
	MOVW	#^A/>*/,(R9)+		; SET PROMPT PREFIX
	SETBIT	WRK_V_NOCONT,WRK_W_FLAGS(FP) ; Don't allow continuation lines
10$:	MOVCHAR				; COPY A BYTE INTO THE COMMAND BUFFER
	BNEQ	10$			; BR IF NOT EOL
	CLRBIT	WRK_V_NOCONT,WRK_W_FLAGS(FP) ; Allow continuation lines
	DECL	R9			; BACK OVER EOL MARKER
40$:	BBS	#ASK_V_LOGICAL,WRK_W_LOCFLG(FP),70$ ; BR IF GETTING LOGIACL
	MOVB	#^A/ /,(R9)+		; SEPARATE
	MOVW	#^A/[S/,(R9)+		; SET PROTOTYPE SUFFIX
	BBC	#ASK_V_NUMERIC,WRK_W_LOCFLG(FP),50$ ; BR IF ASKING FOR STRING
	MOVAB	RADIXC,R1		; SET ADDRESS OF RADIX CHARACTERS
	CMPB	WRK_B_CURADX(FP),#10	; CHECK RADIX VALUE
	BEQL	44$			; BR IF DECIMAL
	BGTRU	46$			; BR IF HEX
	INCL	R1			; ADVANCE POINTER
44$:	INCL	R1			; ETC
46$:	MOVB	(R1),-1(R9)		; SET RADIX INDIACTION CHARACTER
50$:	BBC	#ASK_V_LIMITS,WRK_W_LOCFLG(FP),55$ ; BR IF NO LIMITS SUPPLIED
	MOVB	#^A/ /,(R9)+		; INSERT A SEPARATOR
	MOVW	#^A/R:/,(R9)+		; SET RANGE PREFIX
	MOVL	WRK_L_LOLIM(FP),R0	; GET THE LO LIMIT
	BSBW	PUTVAL			; PUT THAT IN THE PROMPT
	MOVB	#^A/-/,(R9)+		; SEPARATE LO AND HI
	MOVL	WRK_L_HILIM(FP),R0	; GET THE TOP VALUE
	BSBW	PUTVAL			; ADD THAT TO PROMPT
55$:	MOVL	WRK_L_DEFAULT(FP),R0	; NOW GET DEFAULT VALUE
	BEQL	60$			; BR IF NO DEFAULT HERE
	MOVW	#^A/ D/,(R9)+		; SHOW DEFAULT
	MOVB	#^A/:/,(R9)+		; INSERT SEPARATOR
	BSBW	PUTVAL			; INSERT THAT VALUE IN PROMPT
60$:	MOVW	#^A/]:/,(R9)+		; ADD FINAL SUFFIX
	BRB	80$			;
70$:	MOVQ	#^A\? [Y/N]:\,(R9)+	; INSERT LOGICAL QUERY SUFFIX
80$:	SUBL3	WRK_L_PROMPT(FP),R9,R0	; FIND FINAL LENGTH OF PROMPT
	MOVB	R0,@WRK_L_PROMPT(FP)	; SET COUNT OF THE STRING
	MOVZBL	#^A/ /,R0		; FINALLY A SPACE
	PUTCHAR				; INSERT AND CHECK FOR BUFFER OVERFLOW
	BISW	#<WRK_M_ASK!WRK_M_COMMAND>,- ; FLAG QUERY AND COMMAND
		WRK_W_FLAGS(FP)		; IN PROGESS NOW
	MOVL	R9,WRK_L_PRMTEND(FP)	; SAVE END OF PROMT STRING
100$:	PUSHL	WRK_L_PROMPT(FP)	; SAVE THE PROMPT STRING
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ; Disable indirect recognition
	FORNBLK				; MAKE AN INPUT HAPPEN
	POPL	WRK_L_PROMPT(FP)	; RESET PROMPT INCASE RE-READ ON ERROR
	CLRBIT	MCR_V_ESCAPE,PRC_W_CLIFLAG(R11) ; Clear <ESCAPE> flag
	BBC	#ASK_V_NUMERIC,WRK_W_LOCFLG(FP),110$ ; Branch if .ASKS
	BBS	#ASK_V_LOGICAL,WRK_W_LOCFLG(FP),110$ ; Branch if .ASK
	CLRBIT	MCR_V_DEFALT,PRC_W_CLIFLAG(R11) ; .ASKN so clear <DEFAUL> flag
110$:
	MOVL	PRC_L_INPRAB(R11),R1	; Get the input RAB just used
	CMPB	RAB$L_STV(R1),#^X1B	; Was terminator ESC?
	BNEQ	120$			; No if NEQ
	BBC	#MCR_V_ESCTRM, -	; Branch if ESCAPE has not been enabled
		PRC_W_CLIFLAG(R11),115$
	SETNBLK				; Look at first character in the line
	BEQL	117$			; Branch if null line
115$:
	STATUS	INVRSP			; Set bad responce status
	BRB	310$
117$:
	SETBIT	MCR_V_ESCAPE,PRC_W_CLIFLAG(R11) ; Set <ESCAPE> flag
	CLRL	R1			; NULL STRING OR NUMERIC ZERO
	BRW	320$			; SKIP CHECKING, AND STORE VALUE

120$:	BBC	#ASK_V_NUMERIC,WRK_W_LOCFLG(FP),200$ ; BR IF STRING VALUE
	TSTB	R0			; EMPTY LINE?
	BNEQ	130$			; BR IF NO
	MOVL	WRK_L_DEFAULT(FP),R1	; SET DEFUALT VALUE
	BBS	#ASK_V_LOGICAL,WRK_W_LOCFLG(FP),150$ ; Branch if logical (.ASK)
	SETBIT	MCR_V_DEFALT,PRC_W_CLIFLAG(R11) ; MARK THAT ANSWER WAS DEFAULTED
	BRB	150$			;
130$:	BBC	#ASK_V_LOGICAL,WRK_W_LOCFLG(FP),140$ ; BR IF NUMERIC QUERY
	CLRL	R1			; ASSUME ANSWER IS NO
	CMPB	R0,#^A/N/		; ASSUME CORRECTLY?
	BEQL	150$			; BR IF YES
	INCL	R1			; SET VALUE TO TRUE
	CMPB	R0,#^A/Y/		; CHECK FOR POSITIVE RESPONCE
	BEQL	150$			; BR IF YES
140$:	BSBW	GETNUMVAL		; GET VALUE OF THE EXPRESSION
	BLBC	R0,310$			; BR IF ERROR CONVERTING VALUE
150$:	BRB	300$			;
 
;
; ASSIGNMENT IS FOR STRING VALUE
;
 
200$:	MOVL	R9,R2			; COPY CURRENT PLACE IN COMMAND BUFFER
	BBC	#MCR_V_LOWER,PRC_W_CLIFLAG(R11),210$ ; BR IF NO LOWER CASE
	SETBIT	WRK_V_QUOTE,WRK_W_FLAGS(FP) ; SET "IN QUOTED STRING" FLAG
210$:	MOVCHAR				; COPY A CHARACTER TO COMMAND BUFFER
	BNEQ	210$			; BR BACK IF NOT END OF LINE
	SUBL3	R2,R9,R1		; FIND LENGTH OF SYMBOL TEXT
	DECL	R1			; SUBTRACT OUT EOL
	BEQL	300$			; IF EQL NULL STRING VALUE
	PUSHR	#^M<R3,R4,R5>		; SAVE SYMBOL PARAMETERS
	COMPSTRING			; COMPRESS QUOTED STRING
	ADDL3	R1,R2,R9		; RESET COMMAND BUFFER POINTER
	POPR	#^M<R3,R4,R5>		; RETRIEVE SYMBOL PARAMETERS
300$:	BBC	#ASK_V_LIMITS,WRK_W_LOCFLG(FP),320$ ; BR IF NO LIMITS SET
	STATUS	INVRSP			; ASSUME BAD VALUE RESPONCE
	CMPL	R1,WRK_L_LOLIM(FP)	; VALUE IN RANGE
	BLSSU	310$			; BR IF NO
	CMPL	R1,WRK_L_HILIM(FP)	; NOW CHECK UPPER LIMIT
	BLEQU	320$			; BR IF VALUE IS OK
310$:	ERRMSG				; TELL THE BAD NEWS
	MOVL	WRK_L_PRMTEND(FP),R9	; RESET POINTER INTO CMD BUFFER
	BRW	100$			; READ THE LINE AGAIN
320$:	BBC	#ASK_V_NUMERIC,WRK_W_LOCFLG(FP),350$ ; BR IF STRING VALUE
	BRW	MCR$SETSYMVAL		; DEFINE A SYMBOL AS VALUE
350$:	BSBW	MCR$TESTSTRING		; CHECK FOR ALPHA-NUMERIC AND RAD50
	BRW	MCR$ALLOCSYMD		; ALLOCATE AND INSERT SYMBOL IN TABLE
 
;
; LOCAL SUBROUTINE TO CONVERT A BINARY VALUE INTO ASCII AND STORE
; THE RESULT IN THE PROMPT STRING.
;
 
PUTVAL:	PUSHL	R3			; SAVE A WORK REGISTER
	CLRL	R3			; SET FOR ZERO SUPPRESS
	MOVZBL	WRK_B_CURADX(FP),R1	; GET THE CURRENT RADIX
	MOVL	R9,R2			; SET ADDRESS TO STORE STRING
	BSBW	MCR$CNVNUM		; COVERT TO ASCII
	MOVL	R2,R9			; SET FINAL ERROR
	POPR	#^M<R3>			; RESTORE REGISTER
	RSB
	.PAGE
	.SBTTL	TEST STRING
;+
; MCR$TESTSTRING - TEST IF A STRING CONTAINS ALPHA-NUMERIC AND RAD50 CHARS
;
; THIS SUBROUTINE IS CALLED TO CHECK A STRING TO CONTAIN ONLY
; ALPHABETIC AND NUMERIC AND/OR ONLY RAD50 CHARACTERS.
;
; INPUT:
;
;	R1 = LENGTH OF STRING
;	R2 = ADDRESS OF STRING
;
; OUTPUT:
;
;	PROCESS LEVEL FLAGS ARE SET IF THE STRING PASSES EITHER OF BOTH TESTS.
;-
 
MCR$TESTSTRING::			;
	PUSHR	#^M<R1,R2,R3>		; SAVE STRING DESCRIPTOR AND WORK REG
	BISW	#<MCR_M_ALPHAN!MCR_M_RAD50>,- ; SET FLAGS THAT THE STRING
		PRC_W_CLIFLAG(R11)	; WAS ONLY RAD50 OR ALPHA/NUMERIC
	TSTL	R1			; STRING LENGTH 0
	BEQL	60$			; BR IF NOTHING TO CHECK
10$:	MOVZBL	(R2)+,R0		; GET THE CHARACTER
	CMPB	R0,#^A/A/		; CHECK FOR LO LIMIT OF ALPHA
	BLSSU	20$			; BR IF CAN'T BE ALPHA
	CMPB	R0,#^A/Z/		; CHECK FOR HI LIMIT
	BLEQU	40$			; BR IF IT IS ALPHA
20$:	CMPB	R0,#^A/0/		; CHECK FOR LO LIMIT OF NUMERIC
	BLSSU	30$			; BR IF NOT ALPHA/NUMERIC
	CMPB	R0,#^A/9/		; CHECK HI LIMIT OF ALPHA
	BLEQU	40$			; BR IF IT IS NUMERIC
30$:	CLRBIT	MCR_V_ALPHAN,PRC_W_CLIFLAG(R11) ; CLEAR ALPHA/NUMERIC FLAG
	CMPB	R0,#^A/./		; CHECK FOR SPECIAL RAD50 CHARACTER
	BEQL	40$			; BR IF YES
	CMPB	R0,#^A/$/		; CHECK FOR OTHER RAD50 CHAR
	BEQL	40$			; BR IF RAD50
	CLRBIT	MCR_V_RAD50,PRC_W_CLIFLAG(R11) ; CLEAR RAD50 FLAG
	BRB	60$			; ALL DONE
40$:	SOBGTR	R1,10$			; BR IF MORE CHARACTERS TO CHECK
60$:	MOVAB	PRC_L_CLIWRK0(R11),R2	; SET ADDRESS OF 4 BYTE STRING BUFFER
	CLRL	R3			; SET FOR ZERO SUPPRESSION
	MOVZBL	#8,R1			; Set octal radix
	MOVL	(SP),R0			; AND THE NUMBER
	BSBW	MCR$CNVNUM		; CONVERT LENGTH TO ASCIC
	CLRB	(R2)+			; Mark end of number
	POPR	#^M<R1,R2,R3>		; RESTORE STRING DESCRIPTOR AND R3
	RSB				;
	.PAGE
	.SBTTL	TEST SYMBOL
;+
; MCR$TEST - TEST A SYMBOL FOR LENGTH,ALPHANUMERIC AND RAD50
;
; THIS ROUTINE IS CALLED TO EXPAND A STRING SYMBOL AND TEST IT IN
; THE SAME FASHION AS WHEN A STRING IS READ IN RESPONCE TO AN ASKS.
;
; INPUTS:
;
;	THE STRING SYMBOL IS NEXT ON THE COMMAND LINE
;
; OUTPUTS:
;
;	THE STRING IS EXPANEDED AND TESTED
;-
 
MCR$TEST::				; TEST A STRING
	BSBW	MCR$EVLSTRING		; EXPAND THE STRING
	BLBC	R0,10$			; BR IF ERROR
	BSBB	MCR$TESTSTRING		; TEST THE STRING
	STATUS	NORMAL			; SET STATUS TO NORMAL
10$:	RSB				;
	.PAGE
	.SBTTL	EVALUATE ARITHMETIC ASSIGNMENT STATEMENT
;+
; MCR$EVALUATE - EVALUATE ARITHMETIC ASSIGNMENT STATEMENT
;
; THIS ROUTINE IS CALLED TO PROCESS AN ARITHMETIC ASSIGNMENT STATEMENT.
;
; INPUTS:
;
;	R1 = LENGTH OF SYMBOL NAME.
;	R2 = ADDRESS OF SYMBOL NAME.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES EXPRESSION ANALYSIS OR ASSIGNMENT FAILURE.
;
;		R0 = MCR$_COMPLX - EXPRESSION TOO COMPLEX.
;		R0 = MCR$_EXPSYN - EXPRESSION SYNTAX ERROR.
;		R0 = MCR$_IVCHAR - INVALID NUMERIC CHARACTER.
;		R0 = MCR$_IVOPER - INVALID EXPRESSION OPERATOR.
;		R0 = MCR$_IVSYMB - INVALID SYMBOL CHARACTER.
;		R0 = MCR$_SYMDEL - INVALID SYMBOL DELIMITER.
;		R0 = MCR$_SYMOVF - SYMBOL TABLE OVERFLOW.
;		R0 = MCR$_UNDSYM - UNDEFINED SYMBOL.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENABL	LSB
MCR$SETT::				; DEFINE A VARIABLE AS TRUE
	MOVL	#1,R7			; SET A TRUE VALUE
	BRB	10$			; JOIN COMMON CODE
MCR$SETF::				; DEFINE A VARIABLE AS FALSE
	CLRL	R7			; GET VALUE
10$:	BSBW	MCR$SYMNAM		; GET THE SYMBOL NAME
	MOVL	R7,R1			; SET THE VALUE
	SETBIT	ASK_V_LOGICAL,WRK_W_LOCFLG(FP) ; INDICATE DOING LOGICAL VALUE
	BRB	MCR$SETSYMVAL		; DEFINE THE SYMBOL
MCR$SETN::				; SET A NUMERIC VALUE TO A SYMBOL
	BSBW	MCR$SYMNAM		; GET SYMBOL NAME AND CHECK SYNTAX
	BSBW	GETNUMVAL		; GET NUMERIC VALUE FROM COMMAND LINE
	BLBC	R0,70$			; IF LBC EXPRESSION ANALYSIS ERROR
					; JOIN MCR$SETSYMVAL
	.PAGE
	.SBTTL	SET SYMBOL VALUE
;+
; MCR$SETSYMVAL - SET A SYMBOL VALUE
;
; THIS ROUTINE IS CALLED TO DEFINE A NUMERIC SYMBOL.
;
; INPUTS:
;
;	R1 = NUMERIC VALUE FOR SYMBOL
;	R3 = LENGTH OF SYMBOL NAME
;	R4 = ADDRESS OF SYMBOL NAME
;	R5 = TABLE ADDRESS TO ENTER THE SYMBOL
;
;	WRK_B_CURADX = THE RADIX USED WHEN CONVERING THE NUMBER TO BINARY
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO ALLOCATE THE SYMBOL
;	R0 LOW BIT SET INDICATES SYMBOL ENTRY WAS MADE
;
;	THE SYMBOL IS ENTERED WITH PROPER TYPE ACCORDING TO ITS
;	DEFINITION.  IN ADDITION, DECIMAL SYMBOLS ARE STORED WITH
;	A TRAILING "DOT".  HEX SYMBOLS WITH PRECEEDING "%X".
;-
MCR$SETSYMVAL::				; DEFINE A SYMBOL VALUE
	SUBL	#16,SP			; MAKE A BUFFER FOR THE VALUE
	MOVL	SP,R2			; SET ADDRESS OF THE BUFFER
	BBC	#ASK_V_LOGICAL,WRK_W_LOCFLG(FP),16$ ; BR IF NOT A LOGICAL
	MOVZBL	#SYM_K_LOGICAL,R0	; SET SYMBOL TYPE
	MOVW	#^A/F/,(R2)		; ASSUME VALUE IS FALSE
	BLBC	R1,14$			; BR IF IT IS FALSE
	ADDB	#^A/T/-^A/F/,(R2)	; ADJUST VALUE TO TRUE
14$:	MOVZBL	#1,R1			; SET LENGTH OF SYMBOL
	BRB	60$			;
16$:	MOVL	R1,R0			; SET THE VALUE TO CONVERT
	MOVZBL	WRK_B_CURADX(FP),R1	; SET RADIX FOR CONVERSION
	PUSHL	R3			; SAVE THE SYMBOL SIZE 
	CLRL	R3			; SET TO CONVERT ZERO SUPPRESSED
	BSBW	MCR$CNVNUM		; CONVERT NUMBER TO ASCII
	POPR	#^M<R3>			; RESTORE SYMBOL SIZE
	SUBL3	SP,R2,R1		; FIND LENGTH OF THE VALUE STRING
	MOVL	SP,R2			; SET ADDRESS OF VALUE STRING
	MOVZBL	#SYM_K_OCTAL,R0		; ASSUME OCTAL SYMBOL
	ASSUME	SYM_K_OCTAL+1 EQ SYM_K_DECIMAL
	ASSUME	SYM_K_OCTAL+2 EQ SYM_K_HEXDEC
	CMPB	WRK_B_CURADX(FP),#10.	; CHECK RADIX
	BLSS	60$			; BR IF OCTAL
	BEQL	50$			; BR IF DECIAML
	INCL	R0			; SET PROPER SYMBOL VALUE
50$:	INCL	R0			; ETC
60$:	INSV	R0,#16,#8,R1		; INSERT SYMBOL TYPE
	ALLOCSYMD			; ALLOCATE AND INSERT SYMBOL IN TABLE
	ADDL	#16,SP			; REMOVE CONVERTED VALUE FROM STACK
	BLBC	R0,70$			; BR IF ERROR INSERTING IN TABLE
	STATUS	NORMAL			; SET NORMAL COMPLETION STATUS
70$:	RSB				; 
 
	.DSABL	LSB
	.PAGE
	.SBTTL	INCREMENT/DECREMENT A SYMBOL VALUE
;+
; MCR$INC - INCREMENT THE CURRENT VALUE OF A SYMBOL BY 1
; MCR$DEC - DECREMENT THE CURRENT VALUE OF A SYMBOL BY 1
;
; THIS ROUTINE IS CALLED TO PROCESS THE INDIRECT COMMANDS .INC AND .DEC
;
; THE SYMBOL IS PARSED, THEN THE SYMBOL TABLE IS SEARCHED.  IF THE
; SYMBOL IS NOT FOUND, AND ERROR RETURN IS TAKEN. IF FOUND THE
; SYMBOLS VALUE IS CHANGED AND THE SYMBOL REDEFINED.
;
; INPUTS:
;
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SYMBOL ALLOCATION FAILURE.
;
;		R0 = MCR$_INSYMB - INVALID SYMBOL CHARACTER.
;		R0 = MCR$_SYMDEL - INVALID SYMBOL DELIMITER.
;		R0 = MCR$_SYMOVF - SYMBOL TABLE OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL ALLOCATION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
MCR$DEC::				; SUBTRACT 1 FROM SYMBOL
	BISW	#1,WRK_W_LOCFLG(FP)	; FLAG DOING A DECREMENT
MCR$INC::				; ADD 1 TO SYMBOL
	BSBW	MCR$SYMNAM		; PARSE THE SYMBOL NAME
	MOVQ	R3,R7			; SAVE THE DESCRIPTOR
	SEARCH				; LOOK FOR THE SYMBOL
	BLBC	R0,20$			; BR IF SYMBOL NOT FOUND
	ASSUME	PRC_K_HEX EQ 0
	ASSUME	PRC_K_DEC EQ 1
	ASSUME	PRC_K_OCT EQ 2
	ASSUME	SYM_K_OCTAL  LT SYM_K_DECIMAL
	ASSUME	SYM_K_HEXDEC GT SYM_K_DECIMAL
	CLRL	R0			; ASSUME SYMBOL IS HEX
	CMPB	SYM_B_TYPE(R3),#SYM_K_DECIMAL ; CHECK AGAINST MID VALUE
	BEQL	2$			; BR IF DECIMAL
	BGTRU	4$			; BR IF SYMBOL IS HEX
	INCL	R0			; ADJUST CONVERSION RADIX
2$:	INCL	R0			; ETC
4$:	MOVQ	R1,R2			; SET DESCRIPTOR OF STRING FOR CONVERT
	MOVL	R0,R1			; SET RADIX INDICATOR
	BSBW	MCR$CNVASCBIN		; CONVERT ASCII TO BINARY
	BNEQ	10$			; BR IF CONVERSION ERROR
	MOVB	R2,WRK_B_CURADX(FP)	; SET CURRENT RADIX FOR SYMBOL
	MOVQ	R7,R3			; RESET SYMBOL DESCRIPTOR
	INCL	R1			; ADD 1 TO VALUE
	BBCC	#0,WRK_W_LOCFLG(FP),5$	; BR IF COMMAND WAS INC
	SUBL	#2,R1			; UNDO INC AND DO DEC
5$:	BRW	MCR$SETSYMVAL		; REDEFINE THE SYMBOL
10$:	STATUS	IVCHAR			; SET ERROR
20$:	RSB				;
	.PAGE
	.SBTTL	PROCESS STRING EQUATE STATEMENT
;+
; MCR$SETS - PROCESS STRING EQUATE STATEMENT
;
; THIS ROUTINE IS CALLED TO PROCESS A STRING EQUATE STATEMENT.
;
; INPUTS:
;
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SYMBOL ALLOCATION FAILURE.
;
;		R0 = MCR$_INSYMB - INVALID SYMBOL CHARACTER.
;		R0 = MCR$_SYMDEL - INVALID SYMBOL DELIMITER.
;		R0 = MCR$_SYMOVF - SYMBOL TABLE OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL ALLOCATION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
	.ENABL	LSB
 
MCR$SETS::				; PROCESS STRING EQUATE STATEMENT
	BSBW	MCR$SYMNAM		; GET SYMBOL AND CHECK SYNTAX
	PUSHR	#^M<R3,R4,R5>		; SAVE SYMBOL PARAMETERS
	SETBIT	WRK_V_NOCONT,WRK_W_FLAGS(FP) ; Don't allow continuation lines
	BSBB	MCR$EVLSTRING		; EVALUATE STRING EXPRESSION
	CLRBIT	WRK_V_NOCONT,WRK_W_FLAGS(FP) ; Allow continuation lines
	POPR	#^M<R3,R4,R5>		; RESTORE SYMBOL VALUES
	BLBC	R0,25$			; BR IF ERROR ON STRING EXPANSION
	BRW	MCR$ALLOCSYMD		; CREATE THE SYMBOL
	.PAGE
	.SBTTL	EVALUATE STRING EXPRESSION
;+
; MCR$EVLSTRING - EVALUATE STRING EXPRESSION
;
; EXPAND A STRING EXPRESSION TO ITS EQUIVALENT STRING
;
; INPUTS:
;
;	THE COMMAND IS PARSED UP TO THE POINT OF THE EXPRESSION
;
; OUTPUT:
;
;	THE EXPANDED STRING IS IN THE COMMAND BUFFER
;	R1 = SIZE OF THE STRING
;	R2 = ADDRESS OF THE STRING
;
;	REGISTER R0 TO R5 ARE USED
;-
 
MCR$EVLSTRING::				;
	MOVL	R9,WRK_L_LOLIM(FP)	; SAVE START OF STRING
10$:	BSBW	MCR$MARK		; MARK CURRENT PLACE IN COMMAND BUFFER
	MOVL	R9,WRK_L_HILIM(FP)	; ALSO IN WORK AREA
	GETOKEN				; GET NEXT TOKEN FOR COMMAND LINE
	BNEQ	15$			; If NEQ then token found
	CMPB	R0,#^A/</		; Is this a special symbol?
	BNEQ	80$			; No if NEQ
	MOVTOKN				; Get symbol name
	BEQL	100$			; If EQL symbol name was null
	MOVTERM	>			; Get and check terminator
	BNEQ	100$			; If NEQ terminator was not correct
	DECL	R2			; Back up pointer to leading bracket
	ADDL	#2,R1			; Adjust length for enclosing brackets
	BRB	20$			; Search for symbol
15$:
	CMPB	(R2),#^A/"/		; STRING LITERAL?
	BNEQ	20$			; BR IF NO
	COMPSTRING			; REMOVE QUOTES
	BRB	60$			;
20$:	SEARCH				; SEARCH FOR THE SYMBOL
	BLBC	R0,25$			; BR IF SEARCH FAILED
	SETCHAR				; PEEK AT NEXT CHARACTER
	CMPB	R0,#^A/[/		; VALUE FOLLOWING
	BNEQ	60$			; BR IF NO SUBSTRING
	MOVQ	R1,R3			; COPY STRING LIMITS TO SAFE REGISTERS
	MOVCHAR				; COPY THAT CHARACTER TO BUFFER
	BSBW	GETVAL			; GET THE VALUE OF LOWER LIMIT
	BLBC	R0,90$			; BR IF ERROR EVALUATING EXPRESSION
	MOVTERM	<:>			; MOVE THE TERMINATOR
	BNEQ	30$			; BR IF BAD TERMINATOR
	SUBL3	#1,R1,R5		; SAVE INDEX TO FIRST CHARACTER
	BSBW	GETVAL			; GET UPPER LIMIT OF STRING
25$:	BLBC	R0,90$			; BR IF ERROR EVALUATING EXPRESSION
	MOVTERM	<]>			; MOVE THE EXPRESSION TERMINATOR
30$:	BNEQ	100$			; BR IF SYNTAX ERROR
	CMPL	R1,R3			; CHECK UPPER LIMIT AGAINST SIZE
	BLSS	40$			; BR IF LIMIT IN RANGE
	MOVL	R3,R1			; USE THE SIZE AS UPPER LIMIT
40$:	SUBL	R5,R1			; FIND NUMBER OF CHARACTERS
	BGTR	50$			; BR IF VALID SIZE
	CLRL	R1			; ELSE USE ZERO
50$:	ADDL3	R5,R4,R2		; GET STARTING BYTE OF SUBSTRING
60$:	MOVC	R1,(R2),@WRK_L_HILIM(FP) ; PUT STRING IN INPUT BUFFER
	MOVL	R3,R9			; SET END OF INPUT BUFFER
	SETNBLK				; LOOK AT NEXT CHARACTER
	CMPB	#^A/+/,R0		; CONCATONATE STRINGS
	BNEQ	80$			; BR IF NO - ALL DONE
	INCL	WRK_L_CHARPTR(FP)	; SKIP THE PLUS SIGN
	BRW	10$			; Get next symbol
80$:	MOVL	WRK_L_LOLIM(FP),R2	; SET START OF FINAL VALUE
	SUBL3	R2,R9,R1		; GET FINAL LENGTH
	STATUS	NORMAL			;
90$:	RSB				;
 
;
; INVALID DELIMITER
;
100$:	STATUS	SYMDEL			; SYMBOL DELIMITER
	RSB
 
	.DSABL	LSB
	.PAGE
	.SBTTL	GET A SYMBOL NAME AND CHECK STARTING CHARACTER
;+
; MCR$SYMNAM - GET AND CHECK SYMBOL NAME
;
; THIS ROUTINE READS THE NEXT TOKEN FROM THE COMMAND LINE,
; THEN CHECKS THAT THE CHARACTER POINTED TO BY R2 IS VALID
; FIRST CHARACTER FOR A SYMBOL.
;
; INPUTS:
;
;	COMMAND IS PARSED UP TO THE POINT THE SYMBOL STARTS
;
; OUTPUT:
;
;	TOP LEVEL RETURN IS MADE IF SYMBOL IS INVALID WITH ERROR CODE.
;
;	IF THE SYMBOL HAS PROPER SYNTAX R3,R5 IS THE DESCRIPTOR FOR
;	THE SYMBOL AND R5 IS THE PROPER LIST HEAD (GLOBAL OR LOCAL).
;-
 
 
MCR$SYMNAM::				; GET AND CHECK SYMBOL NAME
	BSBW	MCR$MARK		; SET ERROR STRING POINTER
	GETOKEN				; MOVE TERMIATOR AND GET TOKEN
	BEQL	50$			; BR IF NO TOKEN
	MOVQ	R1,R3			; COPY SYMBOL DESCRIPTOR
	SETCHAR				; PEEK AT THE TERMINATOR
	CMPB	R0,#^A/(/		; NUMERIC EXPRESSION DELIMITED WITH L. PAREN?
	BEQL	10$			; BR IF EQL - VALID DELIMITER
	MOVCHAR				; MOVE SYMBOL TERMINATOR TO BUFFER
	BEQL	10$			; END OF LINE IS VALID TERMINATOR
	CMPB	R0,#^A/ /		; TERMINATE WITH A SPACE?
	BNEQ	60$			; IF NEQ NO, INVALID DELIMITER
10$:	MOVAQ	PRC_Q_GLOBAL(R11),R5	; GET ADDRESS OF GLOBAL LIST HEADER
	BBS	#MCR_V_GLOBAL,PRC_W_CLIFLAG(R11),15$ ; BR IF GLOBALS DIABLED
	MOVAQ	PRC_Q_LOCAL(R11),R5	; SET LOCAL TABLE IF NO GLOBALS
15$:	CMPB	(R2),#^A/$/		; NOW TRY FOR DOLLAR SIGN
	BEQL	20$			; BR IF THAT MATCHES
	MOVAQ	PRC_Q_LOCAL(R11),R5	; SYMBOL MUST BE LOCAL IF VALID
	CMPB	(R2),#^A/A/		; CHECK LOW LIMIT FOR ALPHA
	BLSSU	50$			; BR IF FAILED
	CMPB	(R2),#^A/Z/		; NOW CHECK HI LIMIT
	BLEQU	20$			; BR IF VALID CHARACTER
	CMPB	(R2),#^A/_/		; TRY PSEUDO ALPHA
	BNEQ	50$			; BR IF NOT VALID
20$:	RSB				; RETURN WITH SYMBOL
 
;
; SYMBOL NAME IS IMPROPERLY FORMED
;
 
50$:	STATUS	IVSYMB			; INVALID SYMBOL
	BRB	70$			;
 
;
; SYMBOL IMPROPERLY DELIMITED
;
 
60$:	STATUS	SYMDEL			; SET ERROR CONDITION
70$:	TSTL	(SP)+			; CLEAR ONE LEVEL OF RETURN
	RSB				;
	.PAGE
	.SBTTL	GET A NUMERIC VALUE AND VERIFY LAST ON LINE
;+
; GETNUMVAL - GET NUMERIC VALUE
;
; THIS ROUTINE IS CALLED TO EVALUATE THE EXPRESSION ON A COMMAND
; AND VERIFY THAT THE SYMBOL IS THE EXPRESSION IS THE LAST THING
; ON THE COMMAND LINE.
;
; INPUTS:
;
;	COMMAND IS PARSED UP TO THE POINT OF THE EXPRESSION
;
; OUTPUT:
;
;	R0 IS SET TO THE STATUS OF THE OPERATION
;	R1 IS SET TO THE VALUE IF EXPRESSION EVALUATED CORRECTLY
;
;	REGISTERS R3,R4,R5 ARE PRESERVED.
;-
	.ENABL	LSB
 
GETNUMVAL:				;
	BSBB	GETVAL			;
	BLBC	R0,10$			; BR IF EXPRESSION FAILED TO EVALUATE
	BISW	#WRK_M_COMMAND,WRK_W_FLAGS(FP) ;SET COMMAND EXECUTION IN PROGRESS
	TESTBLANK			; PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BEQL	40$			; BR IF EOL IS NEXT
	CMPB	R0,#^A/;/		; IS THE REST A COMMENT?
	BEQL	40$			; BR IF YES
	STATUS	SYMDEL			; SET INVALID SYMBOL DELIMITER
10$:	RSB				;
 
;
; LCOAL SUBROUTINE TO EVALUTE AN EXPRESSION WHILE SAVING THE
; CURRENT SYMBOL LENGTH,ADDRESS AND TABLE LIST HEAD.
;
 
GETVAL:	BSBW	MCR$MARK		; SET ERROR LIMIT POINTER
	CLRL	R1			; ASSUME HEX RADIX
	CMPB	WRK_B_CURADX(FP),#10	; CHECK AGAINST MIDDLE VALUE
	BEQL	20$			; BR IF DECIMAL
	BGTRU	30$			; BR IF HEX
	INCL	R1			; SET RADIX INDICATOR TO
20$:	INCL	R1			; PROPER VALUE
30$:	BSBW	MCR$EXPRADIX		; CONVERT TO BINARY
	BLBC	R0,50$			; BR IF THERE WAS AN ERROR
	BSBW	MCR$MARK		; RESET ERROR POINTER
40$:	STATUS	NORMAL			; INSURE GOOD STATUS
50$:	RSB
 
	.DSABL	LSB
 
	.END
