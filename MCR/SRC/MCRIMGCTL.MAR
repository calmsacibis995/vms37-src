	.TITLE	MCRIMGCTL - IMAGE CONTROL MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; AUTHOR:
;
; D. N. CUTLER 4-APR-77
;
; MODIFIED BY:
;
;
;	V01.04	RN0023		R. Newland	15-Feb-1980
;		Reset "execute only" and "privileged" image bits
;
;	V01.03	RN0018		R. Newland	 3-Jan-1980
;		Also clear compatability mode bit in PSL before exiting
;		the rundown image.
;
;	V01.02	RN0014		R. Newland	17-Dec-1979
;		In STOP command perform image rundown before indirect file
;		unstack.  This ensures that any user access mode and supervisor
;		access mode process logical names with the same name are
;		all deleted.  SPR 11-27203
;
;	V01.01	RN0006		R. Newland	25-Jun-1979
;		(1) Perform quote compression on STOP command.
;
;		(2) Clear first part done and trace pending bits in
;		PSL before exiting the rundown image.
;
; IMAGE CONTROL MCR COMMAND EXECUTION
;
;	CONTINUE IMAGE EXECUTION
;	DEBUG IMAGE EXECUTION
;	STOP IMAGE EXECUTION
.PAGE
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
;
; LOCAL DATA
;
; HEX CONVERSION TABLE
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
HEXTAB:	.ASCII	/FEDCBA9876543210/	;
	.PAGE
	.SBTTL	CONTINUE IMAGE EXECUTION
;+
; MCR$CONTINUE - CONTINUE IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE CONTINUE MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	IF A PREVIOUS IMAGE WAS INTERRUPTED VIA A CONTROL Y AST, THEN THE
;	CURRENT COMMAND CONTEXT IS REMOVED FROM THE STACK AND CONTROL IS
;	RETURNED TO THE IMAGE. OTHERWISE THIS COMMAND IS A NOPERATION.
;-
 
	.ENABL	LSB
MCR$CONTINUE::				;CONTINUE IMAGE EXECUTION
	CLRBIT	PRC_V_PAUSE,PRC_W_FLAGS(R11) ;REMOVE PAUSE STATE
	BSBW	TESTMODE		;TEST PREVIOUS MODE
10$:	RET				;
	.PAGE
	.SBTTL	DEBUG IMAGE EXECUTION
;+
; MCR$DEBUG - DEBUG IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEBUG MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	IF A PREVIOUS IMAGE WAS INTERRUPTED VIA A CONTROL Y AST, THEN A
;	DEBUG EXCEPTION IS GENERATED FOR THE IMAGE. OTHERWISE THIS COMMAND
;	IS A NOPERATION.
;-
 
MCR$DEBUG::				;DEBUG IMAGE EXECUTION
	BSBW	TESTMODE		;TEST PREVIOUS MODE
	MOVAB	B^20$,16(FP)		;RESET AST RETURN ADDRESS
	ASHL	#PSL$V_PRVMOD,#<PSL$C_SUPER@2>! - ;CONSTRUCT PROPER PSL
		PSL$C_USER,-(SP)	;
	PUSHAB	10$			;SET PC
	REI				;
 
;
; CONTROL IS REGAINED AT THIS POINT WITH:
;
;	00(SP) = NUMBER OF AST ARGUMENTS (ALWAYS 5).
;	04(SP) = AST PARAMETER.
;	08(SP) = SAVED R0.
;	12(SP) = SAVED R1.
;	16(SP) = IMAGE PC.
;	20(SP) = IMAGE PSL.
;
 
20$:	ADDL	#8,SP			;REMOVE NUMBER OF ARGUMENTS AND PARAMETER
	POPR	#^M<R0,R1>		;RESTORE SAVED REGISTERS
	MOVZWL	#SS$_DEBUG,-(SP)	;SET EXCEPTION NAME
	PUSHL	#3			;SET NUMBER OF EXCEPTION ARGUMENTS
	JMP	@#EXE$REFLECT		;REFLECT EXCEPTION
	.DSABL	LSB
	.PAGE
	.SBTTL	STOP IMAGE EXECUTION
;+
; MCR$STOP - STOP IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE STOP MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	IF A PROCESS NAME OR IDENTIFICATION IS SPECIFIED, THEN THAT PROCESS IS
;	DELETED.
;
;	IF THE JOB IS A NONINTERACTIVE JOB, THEN THE JOB IS LOGGED OFF THE SYSTEM
;	WITH A STATUS OF NORMAL COMPLETION. OTHERWISE ALL INDIRECT FILE LEVELS ARE
;	UNSTACKED AND A TEST IS MADE TO DETERMINE IF AN IMAGE WAS INTERRUPTED VIA
;	A CONTROL C/Y. IF A PREVIOUS IMAGE WAS INTERRUPTED, THEN THE CONTEXT OF THE
;	RUN COMMAND THAT INITIATED IMAGE EXECUTION IS REMOVED FROM THE STACK AND
;	RMS-32 IS CALLED TO CLOSE ALL OPEN IMAGE FILES. OTHERWISE NO OPERATION IS
;	PERFORMED.
;-
 
MCR$STOP::				;STOP IMAGE EXECUTION
	GETDVAL				;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	40$			;IF NEQ NO
	CLRBIT	PRC_V_PAUSE,PRC_W_FLAGS(R11) ;REMOVE PAUSE FLAG
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),10$ ; If set, noninteractice mode
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11)	; Disable control-Y ast
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ; If CLR, not at control Y/C level
	BBC	#PSL$V_CURMOD,@PRC_L_SAVAP(R11),10$ ; If CLR, prev. mode supervisor
	MOVQ	WRK_L_SAVAP(FP),PRC_L_SAVAP(R11) ; Restore argument and frame pointer
	MOVL	WRK_L_SAVFP(FP),FP	;RESTORE SAVED FRAME POINTER
	SHUTDOWN			;CLOSE FILES OF PREVIOUS IMAGE
	$RUNDWN_S #PSL$C_USER		;RUN DOWN PREVIOUS IMAGE
	BICB	#PRC_M_EXEONLY,PRC_B_FLAGS2(R11) ;RESET "EXECUTE ONLY" AND
10$:
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ; Indirect level zero?
	BEQL	20$			; If EQL yes
	UNSTACK				; Unstack indirect level
	BRB	10$
20$:
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),30$ ; If set, nointerative level
	RSB				;
30$:	BRW	MCR$LOGOUT		;LOG PROCESS OUT
 
;
; DELETE PROCESS
;
 
40$:	CLRL	-(R9)			;CLEAR PROCESS IDENTIFICATION
	MOVL	R8,R7			;COPY ADDRESS OF SCRATCH DESCRIPTOR
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER SPECIFIED?
	BNEQ	70$			;IF NEQ NO
	GETDVAL				;GET VALUE PARAMETERS
	MOVQ	R1,R2			;SAVE VALUE PARAMETERS
50$:	DECL	R2			;ANY MORE CHARACTERS TO CONVERT?
	BLSS	60$			;IF LSS NO
	LOCC	(R3)+,#16,HEXTAB	;SEARCH FOR HEX CHARACTER MATCH
	BEQL	80$			;IF EQL VALUE SYNTAX ERROR
	MULL	#16,(R9)		;SCALE ACCUMULATED RESULT
	ADDL	R0,(R9)			;ADD IN NEXT DIGIT
	DECL	(R9)			;SUBTRACT OUT CHARACTER COUNT
	BRB	50$			;
60$:	GETDVAL				;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	70$			;IF NEQ NO
	CLRL	R7			;CLEAR DESCRIPTOR ADDRESS
70$:	COMPSTRING			; COMPRESS QUOTES
	MOVQ	R1,(R8)			; SAVE PROCESS NAME PARAMETERS
	$DELPRC_S (R9),(R7)		;DELETE PROCESS
	RSB				;
80$:	STATUS	IVVALU			;SET INVALID VALUE SYNTAX STATUS
	RSB				;
	.PAGE
	.SBTTL	TEST PREVIOUS MODE
;
; SUBROUTINE TO TEST PREVIOUS MODE AND DISABLE CONTROL Y AST
;
 
TESTMODE:				;TEST PREVIOUS MODE
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y AST
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
	BBC	#PSL$V_CURMOD,@PRC_L_SAVAP(R11),10$ ;IF CLR, PREVIOUS MODE SUPERVISOR
	MOVQ	WRK_L_SAVAP(FP),PRC_L_SAVAP(R11) ;RESTORE ARGUMENT AND FRAME POINTERS
	RSB				;
 
;
; PREVIOUS MODE SUPERVISOR
;
 
10$:	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	STATUS	NORMAL			;SET COMPLETION STATUS
	RSB				;
	.PAGE
	.SBTTL	RUN DOWN IMAGE AND INDIRECT LEVELS
;+
; MCR$RUNDOWN - RUN DOWN IMAGE AND INDIRECT LEVELS
;
; THIS SUBROUTINE IS CALLED TO CHECK WHETHER INDIRECT LEVELS SHOULD BE RUN DOWN
; AND TO CLOSE RMS-32 FILES AND RUN DOWN THE PREVIOUS IMAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF THE CURRENT LEVEL IS CONTROL Y/C, THEN ALL INDIRECT FILES ARE UNSTACKED.
;	IF THE PREVIOUS MODE WAS USER, THEN THE USER IMAGE EXIT HANDLERS ARE
;	EXECUTED. THE PREVIOUS IMAGE IS ALWAYS RUNDOWN.
;-
 
MCR$RUNDOWN::				;RUN DOWN IMAGE AND INDIRECT LEVELS
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	BBS	#PRC_V_PAUSE,PRC_W_FLAGS(R11),20$ ;DON'T UNSTACK IF PAUSED
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
	MOVL	PRC_L_SAVAP(R11),R0	;GET ADDRESS OF PREVIOUS PSL
	BBC	#PSL$V_CURMOD,(R0),10$	;IF CLR, PREVIOUS MODE SUPERVISOR
	BICB	#<PSL$M_FPD!PSL$M_TP!PSL$M_CM>@-24,- ; CLEAR FIRST PART DONE
					3(R0)	;TRACE PENDING COMPAT MODE IN PSL
	PUSHAB	B^10$			;SET EXIT HANDLER RETURN ADDRESS
	MOVAB	@#EXE$EXIT_IMAGE,-(R0)	;RESET USER RETURN ADDRESS
	MOVZWL	#SS$_CLIFRCEXT,-8(R0)	;SET EXIT CAUSE INTO SAVED R0
	SUBL3	FP,SP,WRK_L_SAVSP(FP)	;SAVE RELATIVE ADDRESS OF TOP OF STACK
	MOVQ	WRK_L_SAVAP(FP),R8	;RETRIEVE PREVIOUS ARGUMENT AND FRAME POINTERS
	MOVQ	R8,PRC_L_SAVAP(R11)	;SAVE IN PROCESS WORK AREA
	SUBL	FP,WRK_L_RSLNXT(FP)	;CONVERT PARSE POINTER TO RELATIVE ADDRESS
	MOVAB	8(R0),R7		;GET ADDRESS OF END OF ARGUMENT LIST + 4
	SUBL	FP,R7			;CALCULATE LENGTH OF CALL FRAME AND ARGLIST
	SUBL	R7,SP			;CALCULATE NEW TOP OF STACK ADDRESS
	MOVC	R7,(FP),(SP)		;MOVE CALL FRAME AND ARGUMENT LIST
	SUBL3	SP,FP,R7		;CALCULATE LENGTH OF COMMAND BUFFER AND ARGLISTS
	SUBL3	R7,R9,FP		;CALCULATE NEW TOP OF STACK ADDRESS
	MOVC	R7,(SP),(FP)		;COLLAPSE STACK REMOVING FIRST COMMAND CONTEXT
	ADDL	R9,WRK_L_SAVSP(R9)	;CALCULATE NEW COMMAND STACK POINTER
	ADDL	R9,WRK_L_RSLNXT(R9)	;CONVERT PARSE POINTER TO REAL ADDRESS
	RET				;
10$:	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	UNSTACK				;UNSTACK INDIRECT LEVEL
	BRB	10$			;
20$:	$RUNDWN_S #PSL$C_USER		;RUN DOWN PREVIOUS IMAGE
	RSB				;
	.PAGE
	.SBTTL	SHUT DOWN IMAGE
;+
; MCR$SHUTDOWN - SHUT DOWM IMAGE
;
; THIS ROUTINE IS CALLED TO CLOSE ALL FILES OPENED BY THE JUST EXECUTED IMAGE
; AND TO CLOSE THE IMAGE ACTIVATION FILE.
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	ALL FILES OPENED BY THE JUST EXECUTED IMAGE ARE CLOSED BY CALLING RMS-32,
;	DATA RECORDS ARE SKIPPED IN THE INPUT STREAM, AND THE IMAGE FILE IS CLOSED.
;
;		R2 = NUMBER OF DATA RECORDS SKIPPED IN THE INPUT STREAM.
;-
 
MCR$SHUTDOWN::				;SHUT DOWN IMAGE
	ALLOCBUF			;ALLOCATE BUFFER AND DESCRIPTOR
10$:	MOVZBL	#MSGBUFSIZ,(R2)		;RESET SIZE OF MESSAGE BUFFER
	PUSHL	#0			;RUNDOWN ONLY USER LEVEL FILES
	PUSHAB	(R2)			;SET ADDRESS OF MESSAGE BUFFER DESCRIPTOR
	CALLS	#2,@#SYS$RMSRUNDWN	;RUNDOWN RMS-32 FILES
	BLBC	R0,10$			;IF RUNDOWN FAILURE CONTINUE WITH NEXT FILE
	MOVAB	MSGBUFSIZ+8(SP),SP	;DEALLOCATE MESSAGE BUFFER AND DESCRIPTOR
	CLRL	R2			;CLEAR COUNT OF RECORDS SKIPPED
	MOVL	PRC_L_INDINPRAB(R11),R3	;GET ADDRESS OF INDIRECT RAB
	BBS	#DEV$V_TRM,RAB$L_CTX(R3),30$ ;IF SET, DEVICE IS TERMINAL
	BBC	#MCR_V_DOLLARS,PRC_W_CLIFLAG(R11),30$ ;BR IF DOLLARS NOT ENABLED
	BISW	#RAB$M_PPF_IND,RAB$W_ISI(R3) ;CONVERT TO NONPRIVILEGED ISI
20$:	INCL	R2			;INCREMENT NUMBER OF RECORDS SKIPPED
	$GET	RAB=(R3)		;GET NEXT RECORD FROM INDIRECT FILE
	BLBS	R0,20$			;IF LBS SUCCESS
	DECL	R2			;ADJUST FOR LAST RECORD
	BICW	#RAB$M_PPF_IND,RAB$W_ISI(R3) ;CONVERT BACK TO PRIVILEGED ISI
30$:	RSB				;
 
	.END
;
