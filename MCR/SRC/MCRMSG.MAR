	.TITLE	MCRMSG - MESSAGE OUTPUT ROUTINES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 28-MAR-77
;
; MODIFIED BY:
;
;	V03.01	MAJ0002		Melanie Johnson	03-Mar-1982
;		Fix buffer text reporting by putting the text pointer and
;		length into the correct registers before calling MCR$ERROUT.
;
;	V02.04	MAJ0001		Melanie Johnson	22-Dec-81
;		Use WRK_L_MARKPTR(FP) instead of R6 to mark buffer position for
;		error reporting.
;
;	V01.03	RN0030		R. Newland	20-Mar-1980
;	Fix error introduced by earlier modification which caused
;	'CLI' to be shown as facility name rather than 'MCR'.
;
;	V01.02	RN0024		R. Newland	18-Feb-1980
;	Use $PUTMSG rather than $GETMSG so that process message flag
;	default is used,
;	avoid use of PUTMSG action routine and let PUTMSG output
;	the error directly with control Y/C ast's inhibited.  Add
;	routine DCL$PUTMSG to provide facility for signaling errors
;	of multiple lines or with fao arguments.
;
;	V01.01	RN0008		R. Newland	25-Jun-1979
;	Make STATUS=0 display using system facility, not MCR.
;
; MESSAGE OUTPUT ROUTINES
.PAGE
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	$IODEF				;DEFINE I/O FUNCTION CODES
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS LONGWORD VALUES
	$SFDEF				; Define call frame
	.PAGE
	.SBTTL	OUTPUT ERROR MESSAGE
;+
; MCR$ERRORMSG - OUTPUT ERROR MESSAGE
;
; THIS ROUTINE IS CALLED TO OUTPUT AN ERROR MESSAGE AND DISPLAY THE SEGMENT
; OF THE COMMAND LINE THAT IS IN ERROR.
;
; INPUTS:
;
;	R0 = ERROR NUMBER.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE APPROPRIATE ERROR MESSAGE IS DISPLAYED ALONG WITH THE SEGMENT OF
;	THE COMMAND LINE IN ERROR AND THE BACK UP PARAMETERS ARE RESTORED
;	TO REGISTERS R9 AND R10.
;
;	R0 IS PRESERVED ACROSS CALL.
;-
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$ERRORMSG::				;OUTPUT ERROR MESSAGE
	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	MNEGL	R0,R1			; Command interpreter error?
	BLEQ	10$			; If leq NO
	MULL3	#4,R1,R0		; Shift message number to correct place
	BISL	#<CLI$_ABKEYW&<STS$M_FAC_NO!STS$M_FAC_SP>>,R0 ; Insert facnum
10$:	BBS	#STS$V_INHIB_MSG,R0,60$ ; Br if no message desired
	PUSHL	#0			; Create putmsg vector (fao count)
	PUSHL	R0			; Set status code
	PUSHL	#2			; # args on PUTMSG vector
	MOVL	SP,R0			; Address of the buffer descriptor
	BSBB	MCR$PUTMSG		; Signal PUTMSG vector at (R0)
	ADDL	#3*4,SP			; Pop everything up to buffer and desc.
;
;	Output offending text if error in command line
;
	BBS	#WRK_V_COMMAND,WRK_W_FLAGS(FP),60$ ; BR if command in execution
	MOVAB	-MSGBUFSIZ(SP),SP	; Allocate space to store message
	MOVL	SP,R3			;COMMAND PARSE-PRINT SEGMENT IN ERROR
	MOVAB	MSGBUFSIZ(R3),R0	;POINT AT START AND END OF BUFFER
	MOVW	#^A/  /,(R3)+		;PUT SEPARATOR IN BUFFER
	MOVB	#^A/\/,(R3)+		;AND DELIMIT THE BAD PART OF THE COMMAND
	BSBW	MCR$MARKEDTOKEN		;GET ADDRESS AND LENGTH OF ERROR SEG.
	BRB	25$			;CHECK IF POINTER IS IN COMMAND
20$:	MOVB	(R2)+,(R3)+		;COPY ERROR SEGMENT
25$:	CMPL	R2,R9			;END OF ERROR SEGMENT
	BLSSU	20$			;BR IF NO
	MOVB	#^A/\/,(R3)+		;SET TRAILING SEPARATOR
	ADDL3	#1,WRK_L_CHARPTR(FP),R2	;POINT AT NEXT BYTE IN INPUT
30$:	CMPL	R3,R0			;ANY ROOM FOR MORE DATA
	BGEQU	40$			;BR IF NO MORE ROOM
	MOVB	(R2)+,(R3)+		;STORE A BYTE
	BNEQ	30$			;BR IF NOT END_OF_LINE
	DECL	R3			;BACK OVER EOL
40$:	MOVL	SP,R2			;START OF THE LINE BUFFER
	SUBL3	R2,R3,R1		;FIND LENGTH OF LINE
	BSBB	MCR$ERROUT		;OUTPUT ERROR MESSAGE
	MOVAB	MSGBUFSIZ(SP),SP	; Clear message buffer from stack
60$:
	POPR	#^M<R0>			; Reset status value
	RSB				;
	.PAGE
	.SBTTL	PUTMSG OUTPUT ROUTINE
;---
;
;	THIS ROUTINE OUTPUTS A GIVEN PUTMSG MESSAGE VECTOR
;
; INPUTS:
;
;	FP = ADDRESS OF COMMAND WORK AREA
;	R11 = ADDRESS OF PROCESS WORK AREA
;	R0 = ADDRESS OF PUTMSG VECTOR
;
; OUTPUTS:
;
;	NONE
;---
MCR$PUTMSG::
	DISABLE			; Disable control Y/C ast's
	PUSHL	#^A'MCR'	; Facility name
	PUSHL	SP		; Make string descriptor of name
	PUSHL	#3
	PUSHL	SP		; Set address of FACNAM
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,4(R0),-
		#<CLI$_ABKEYW&STS$M_FAC_NO>@-STS$V_FAC_NO
	BEQL	10$		; Branch if our facility
	CLRL	(SP)		; If not our facility, zero FACNAM parameter
10$:
	PUSHL	#0		; No action routine
	PUSHL	R0		; R0 = address of message vector
	CALLS	#6,G^SYS$PUTMSG	; Write the message to SYS$ERROR, OUTPUT
	ENABLE			; Re-enable control/Y ast's
	BBC	#WRK_V_COMMAND,WRK_W_FLAGS(FP),90$ ; Branch if no image active
	CHECK_AST		; Check for pending ast
90$:	RSB
	.PAGE
	.SBTTL	ERROR FILE MESSAGE OUTPUT
;+
; MCR$ERROUT - ERROR FILE MESSAGE OUTPUT
;
; THIS ROUTINE IS CALLED TO OUTPUT A MESSAGE TO THE ERROR FILE.
;
; INPUTS:
;
;	R1 = LENGTH OF MESSAGE.
;	R2 = ADDRESS OF MESSAGE.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE MESSAGE IS WRITTEN TO THE ERROR FILE AND CONTROL IS RETURNED
;	TO THE CALLER.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
MCR$ERROUT::				;ERROR CHANNEL MESSAGE OUTPUT
	MOVL	PRC_L_ERRRAB(R11),R0	;SET ADDRESS OF ERROR FILE RAB
	PUSHR	#^M<R1,R2>		;SAVE MESSAGE PARAMETERS
	BSBB	20$			;OUTPUT ERROR MESSAGE
	POPR	#^M<R1,R2>		;RESTORE MESSAGE PARAMETERS
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),30$ ;BR IF AT CONTROL Y LEVEL
	CMPL	PRC_L_ERRRAB(R11),-	;CHECK IF ERROR AND OUTPUT ARE
		PRC_L_INDOUTRAB(R11)	;THE SAME FILE (OR DEVICE).
	BEQL	30$			;IF EQL YES, DON'T REPRINT MESSAGE
					;ELSE JOIN MESSAGE OUTPUT
	.PAGE
	.SBTTL	OUTPUT FILE MESSAGE OUTPUT
;+
; MCR$MSGOUT - OUTPUT FILE MESSAGE OUTPUT
;
; THSI ROUTINE IS CALLED TO OUTPUT A MESSAGE TO THE OUTPUT FILE.
;
; INPUTS:
;
;	R1 = LENGTH OF MESSAGE.
;	R2 = ADDRESS OF MESSAGE.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE MESSAGE IS WRITTEN TO THE OUTPUT FILE AND CONTROL IS RETURNED
;	TO THE CALLER.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
MCR$MSGOUT::				;MESSAGE OUTPUT
	MOVL	PRC_L_INDOUTRAB(R11),R0	;GET ADDRESS OF INDIRECT OUTPUT RAB
	BBC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;BR IF NOT IN CONTROL Y
	MOVL	PRC_L_OUTRAB(R11),R0	;SET ADDRESS OF OUTPUT FILE RAB
20$:	DISABLE				;DISABLE CONTROL Y/C AST'S
	MOVW	R1,RAB$W_RSZ(R0)	;SET SIZE OF OUTPUT RECORD
	MOVL	R2,RAB$L_RBF(R0)	;SET ADDRESS OF OUTPUT RECORD
	$PUT	RAB=(R0)		;OUTPUT RECORD
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BBC	#WRK_V_COMMAND,WRK_W_FLAGS(FP),30$ ;IF CLR, NO COMMAND EXECUTION
	CHECK_AST			;CHECK FOR PENDING AST
30$:	RSB				;
	.DSABL	LSB
 
	.END
