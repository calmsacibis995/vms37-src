	.TITLE	MCRGOTO - GOTO MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 22-DEC-1977
;
; Modified by:
;
;	V01.01	RN0001		R. Newland	25-Feb-1979
;		New indirect commands for RSX-11M V3.2 compatibility.
;
;	V01.02	RN0020		R. Newland	15-Jan-1980
;		Do not ignore goto if at CTRL/Y level.  If label is not
;		in label table the cli is put into forward goto mode but
;		on return to the COMMAND module the CTRL/Y prompt will be
;		issued before searching the file for the label.
;		SPR 11-27200
;
; GOTO/GOSUB MCR COMMAND EXECUTION
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			; DEFINE WORK AREA OFFSETS
	DEFERRCOD			; DEFINE ERROR/STATUS VALUES
	DEFSYMTBL			; DEFINE SYMBOL ENTRY OFFSETS
	$DEVDEF				; DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				; DEFINE RAB OFFSETS
	SUBDEF				; Define suboutine frame offsets
	.PAGE
	.SBTTL	GOSUB LABEL
;+
; MCR$GOSUB - GOSUB LABEL
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE GOSUB LABEL MCR
; COMMAND.
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LABEL IS SEARCHED FOR IN THE CURRENT LABEL TABLE, AND IF
;	FOUND, A RANDOM FIND IS EXECUTED TO POSITION THE INPUT FILE FOR SUBSE-
;	QUENT GET OPERATIONS. OTHERWISE A LABEL TABLE ENTRY IS CONSTRUCTED AND
;	APPROPRIATE STATE INFORMATION IS SET UP SO THAT A FORWARD GOSUB SEARCH
;	IS EXECUTED.
;-
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
MCR$GOSUB::				; GO TO A COMMMAND SUBROUTINE
	BSBB	SETGO			; SET UP THE GOTO
	SUBL3	#SUB_K_BLN, -		; Allocate space on stack for
		PRC_L_STACKPT(R11),R0	; subroutine frame
	CMPL	R0,PRC_L_STACKLM(R11)	; DID STACK OVERFLOW
	BLEQU	10$			; BR IF YES
	MOVL	R0,PRC_L_STACKPT(R11)	; SET NEW STACK POINTER
	MOVL	PRC_L_SUBLNK(R11), -	; Link new stack frame into
		SUB_L_LNK(R0)		; stack frame list
	MOVAL	SUB_L_LNK(R0),PRC_L_SUBLNK(R11)
	MOVL	PRC_L_BLKLNK(R11), -	; Save cuurent block frame pointer
		SUB_L_BLKLNK(R0)
	CLRL	PRC_L_BLKLNK(R11)	; and reset for new subroutine
	MOVL	PRC_L_INDINPRAB(R11),R3	; GET INPUT RAB
	MOVL	RAB$W_RFA+0(R3), -	; Save Record File Address
		SUB_W_RFA+0(R0)
	MOVW	RAB$W_RFA+4(R3), -	; (3 words)
		SUB_W_RFA+4(R0)
	MOVB	#PRC_K_GOSUB,PRC_B_FWDSCAN(R11) ; Mark as .GOSUB forward scan
	BRB	MCR$POSITION		; POSITION THE FILE TO LABEL
10$:	STATUS	STKOVF			; INDICATE NO SPACE FOR RETURN
	RSB				; 
;
; LOCAL SUBROUTINE TO SET UP FOR GOTO/GOSUB
;
	.ENABL	LSB			;
 
SETGO:
	MOVL	PRC_L_INDINPRAB(R11),R0	;GET ADDRESS OF CURRENT INPUT RAB
	BBC	#DEV$V_RND,RAB$L_CTX(R0),5$ ; IF CLR, NOT RANDOM ACCESS DEVICE
	GETOKEN				; GET SYMBOL NAME
	DISABLE				; DISABLE CONTROL Y/C AST'S
	CLRQ	(SP)+			; REMOVE RETURN INFORMATION FROM STACK
	RSB
5$:	TSTL	(SP)+			; CLEAR LOCAL SUBROUTINE
	BRB	10$			; RETURN
	.PAGE
	.SBTTL	GOTO LABEL
;+
; MCR$GOTO - GOTO LABEL
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE GOTO LABEL MCR
; COMMAND.
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LABEL IS SEARCHED FOR IN THE CURRENT LABEL TABLE, AND IF
;	FOUND, A RANDOM FIND IS EXECUTED TO POSITION THE INPUT FILE FOR SUBSE-
;	QUENT GET OPERATIONS. OTHERWISE A LABEL TABLE ENTRY IS CONSTRUCTED AND
;	APPROPRIATE STATE INFORMATION IS SET UP SO THAT A FORWARD GOTO SEARCH
;	IS EXECUTED.
;-
 
MCR$GOTO::				; GOTO LABEL
	BSBB	SETGO			; SET UP FOR GOTO
	MOVB	#PRC_K_GOTO,PRC_B_FWDSCAN(R11) ; Mark as a .GOTO forward scan
	MOVB	PRC_B_NESTLEVEL(R11), -	; Save nesting level for
		WRK_B_SCANLEVEL(FP)	; label search
	TSTL	PRC_L_BLKLNK(R11)	; Within a begin-end block?
	BEQL	2$			; No if EQL
	PUSHR	#^M<R1,R2>		; Save R1 and R2
	MOVL	PRC_L_INDINPRAB(R11),R8	; Reposition to beginning of block
	MOVC3	#6,PRC_W_BEGINRFA(R11),-; Copy record file address into RAB
		RAB$W_RFA(R8)
	BSB	FIND			; Position file
	POPR	#^M<R1,R2>		; Restore R1 and R2
2$:
					; FALL INTO POSITION
	.PAGE
	.SBTTL	POSITION FILE TO GOTO LABEL
;+
; MCR$POSITION - POSITION FILE TO GOTO LABEL
;
; THIS ROUTINE IS CALLED TO SEARCH THE LABEL TABLE FOR A GOTO LABEL, AND IF
; FOUND POSITION THE CURRENT COMMAND FILE TO THE LABEL.
; If a .GOTO only labels at the current block nesting level are considered.
;
; INPUTS:
;
;	R1 = LENGTH OF GOTO LABEL.
;	R2 = ADDRESS OF GOTO LABEL.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
;	IT IS ASSUMED THAT CONTROL Y/C AST'S ARE DISABLED.
;
; OUTPUTS:
;
;	THE LABEL TABLE IS SEARCHED FOR THE SPECIFIED GOTO LABEL. IF THE LABEL
;	IS FOUND, THEN THE CURRENT COMMAND FILE IS POSITIONED TO THAT POINT.
;	OTHERWISE A NEW LABEL TABLE ENTRY IS MADE AND A POINTER TO THE GOTO
;	LABEL IS ESTABLISHED IN THE PROCESS WORK AREA.
;-
 
MCR$POSITION::				; POSITION FILE TO GOTO LABEL
	MOVAB	PRC_Q_LABEL(R11),R0	; GET ADDRESS OF LABEL TABLE LISTHEAD
	CMPB	PRC_B_FWDSCAN(R11), -	; Is search for a .GOSUB?
		#PRC_K_GOSUB
	BEQL	4$			; Yes if EQL
	SEARCHTLVL			; Search at current nesting level only
	BRB	6$
4$:
	SEARCHT				; SEARCH TABLE FOR LABEL
6$:
	BLBS	R0,30$			; IF LBS LABEL ENTRY FOUND
	MOVQ	R1,R4			; SAVE SAVE AND ADDRESS OF LABEL
	ADDL	#3+7,R1			; Add in nestlevel, label size, block
					; size and round up factor
	BSBW	MCR$ALLDYNMEM		; ALLOCATE DYNAMIC MEMORY
	BLBC	R0,20$			; BR IF FAILED
	MOVB	R1,(R2)+		; SAVE SIZE OF BLOCK IN BLOCK
	MOVAB	(R2),PRC_L_SYMBOL(R11)	; SAVE TARGET FOR GOTO
	MOVB	PRC_B_NESTLEVEL(R11),(R2)+ ; Save current nesting level
	MOVB	R4,(R2)+		; SET SIZE OF LABEL STRING
	MOVC	R4,(R5),(R2)		; FILL IN LABEL NAME
	BISW	#PRC_M_GOTO,PRC_W_FLAGS(R11) ; SET FORWARD GOTO IN PROGRESS
10$:	STATUS	NORMAL			; SET NORMAL COMPLETION
20$:	RSB				; 
 
;
; LABEL ALREADY DEFINED - POINT TO PROPER RECORD
;
 
30$:	MOVL	PRC_L_INDINPRAB(R11),R8	; GET ADDRESS OF INDIRECT FILE RAB
	MOVC	#6,SYM_T_SYMBOL+2(R3)[R1],RAB$W_RFA(R8) ; RESTORE RECORD FILE ADDRESS
FIND:	MOVB	#RAB$C_RFA,RAB$B_RAC(R8) ; SET ACCESS MODE FOR RANDOM FIND
	$FIND	RAB=(R8)		; FIND RECORD THAT HAS LABEL
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R8) ; RESET TO SEQUENTIAL ACCESS MODE
	RSB				; 
	.DSABL	LSB
	.PAGE
	.SBTTL	DEALLOCTE GOTO CONTROL BLOCK
;+
; MCR$DEALGOTO-DEALLOCATE GOTO CONTROL BLOCK
;
; THIS ROUTINE IS CALLED TO DEALLOCATE AN OUTSTANDING GOTO CONTROL
; BLOCK WHEN IT IS SATISFIED OR AN END OF FILE IS REACHED WITHOUT
; FINDING THE LABEL.
;
;-
MCR$DEALGOTO::				; 
	MOVL	PRC_L_SYMBOL(R11),R0	; ADDRESS OF GOTO CONTROL BLOCK
	MOVZBL	-(R0),R1		; GET LENGTH AND POINT AT START OF BLOCK
	BRW	MCR$DEADYNMEM		; DEALLOCATE THE BLOCK
	.PAGE
	.SBTTL	RETURN FROM SUBROUTINE
;+
; MCR$RETURN - RETURN FROM SUBROUTINE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE RETURN MCR
; COMMAND.
; Any begin-end blocks created in the subroutine will be deallocated
; and the previous block context restored.
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE MOST RECENT SUBROUTINE CALL IS POPPED FROM THE INDIRECT STACK
;	AND A RETURN TO THAT POINT IS MADE.
;-
MCR$RETURN::				; RETURN FORM SUBROUTINE
	TSTL	PRC_L_BLKLNK(R11)	; Any begin-end blocks to deallocate?
	BEQL	10$			; No if EQL, at end of list
	BSBW	MCR$END			; Deallocate block
	BRB	MCR$RETURN		; and go back for next
10$:
	MOVL	PRC_L_SUBLNK(R11),R0	; Get subroutine frame address
	BEQL	20$			; Error if EQL, .RETURN without .GOSUB
	MOVL	SUB_L_LNK(R0), -	; Unlink subroutine frame from
		PRC_L_SUBLNK(R11)	; subroutine frame list
	MOVL	SUB_L_BLKLNK(R0), -	; Reset block frame list for
		PRC_L_BLKLNK(R11)	; next subroutine
	MOVL	PRC_L_INDINPRAB(R11),R8	; GET THE CURRENT INPUT RAB
	MOVL	SUB_W_RFA+0(R0), -	; Restore record file address
		RAB$W_RFA+0(R8)
	MOVW	SUB_W_RFA+4(R0), -	; (3 words)
		RAB$W_RFA+4(R8)
	MOVAB	SUB_K_BLN(R0), -	; Remove subroutine frame from stack
		PRC_L_STACKPT(R11)	; and reset stack pointer
	BSBB	FIND			; POSITION
	FORNBLK				; READ THE SUBOUTINE CALL LINE
	STATUS	NORMAL			; SET GOOD RETURN
	RSB				;
20$:	STATUS	BADRET			; BAD RETURN
	RSB
 
	.END
