	.TITLE	MCRHANDLE - CONDITION AND CONTROL Y AST HANDLER ROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; CONDITION AND CONTROL Y AST HANDLER ROUTINES
;
; D. N. CUTLER 29-MAR-77
;
; MODIFIED BY:
;
;	V003	ROW0051		Ralph O. Weber	25-NOV-1981
;		Make defining symbols an invalid callback service.  Add 
;		callback support for enabling/disabling out-of-band 
;		characters.  Although only CTRL-Y will be supported, the 
;		callback will appear the same as that for DCL.  Also added 
;		call to CLI$GET_PRC at beginning of callback processing to 
;		load address of process work area into R11.
;
;	V002	TMH0002		Tim Halvorsen	01-Jun-1981
;		Change method of obtaining PRC address.
;
;	V001	TMH0001		Tim Halvorsen	16-Dec-1980
;		Make condition handler resignal.  CLI initialization
;		simply sets EXE$CATCH_ALL as the handler in the top-most
;		frame so that errors are reported.  This enables the
;		debugger to catch exceptions.
;---

;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS CODES
	$CLISERVDEF			;CLI SERVICE CODES
	$CHFDEF				;DEFINE CONDITION ARGLIST OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES

	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT

	.SBTTL	CHANGE MODE TO SUPERVISOR HANDLER
;+
; MCR$CHANGE_MODE - CHANGE MODE TO SUPERVISOR HANDLER
;
; THIS ROUTINE IS ENTERED WHEN A CHANGE MODE TO SUPERVISOR INSTRUCTION IS
; EXECTED BY THE RESULT PARSER IN USER MODE OR THE CLI PROPER IN SUPER MODE.
;
; INPUTS:
;
;	 (SP) = CHANGE MODE ARGUMENT
;	4(SP) = PC AFTER CHANGE MODE INSTRUCTION
;	8(SP) = PSL OF CHANGE MODE INSTRUCTION
;
; OUTPUTS:
;
;	A CHECK IS MADE TO SEE IF THE
;	PREVIOUS MODE WAS USER OR SUPERVISOR.
;
;	PREVIOUS MODE USER:
;
;		THIS IS REQUEST FOR SERVICE FROM THE RUNNING IMAGE.
;		THE REQUEST IS DECODED AND PROCESSED, THE RETURN
;		IS MADE TO THE POINT OF CALL WITH STATUS OF REQUEST.
;
;	PREVIOUS MODE SUPERVISOR:
;
;		THIS IS RESERVED FOR COMMAND PROCESSING ERRORS.
;-
 
MCR$CHANGE_MODE::			;HANDLE CHANGE MODE TO SUPERVISOR
	BBS	#PSL$V_CURMOD,8(SP),10$	;BR IF CHANGE MODE FROM USER
 
;
; CHANGE MODE FROM SUPER
;
 
	BRW	MCR$RESTART		;*** NYI ***
 
;
; BUILD A FRAME THAT LOOKS LIKE AN AST FRAME, EXCEPT THAT IN PLACE OF
; THE SAVE R1 IS THE CHANGE MODE ARGUMENT, AND ZERO FOR SAVED R0 AND
; THE AST ARGUMENT.
;
 
10$:	BSBW	CLI$GET_PRC		;Get address of CLI process work area.
	CLRQ	-(SP)			;DUMMY SAVED R0 AND AST ARGUMENT
	PUSHL	#5			;NUMBER OF ARGUMENTS IN AST ROUTINE
	CALLG	(SP),B^30$		;CREATE A CALL FRAME IN SUPER MODE
	ADDL	#<4*4>,SP		;CLEAR ARGUMENTS AND ARG COUNT
	REI				;RETURN TO USER
 
30$:	.WORD	0			;REGISTERS SAVED BY RESULT PARSER
	CASE	12(AP),-		;DECODE USER REQUEST
		LIMIT = #CLI$K_PAUSE,-	;LOW LIMIT OF REQUEST
		TYPE = W,<-		;CASE ON 16 BIT VALUE
		PAUSE,-			;REQUEST IS PAUSE
		INVREQ,-		; DEFINE IN LOCAL TABLE (unsupported)
		INVREQ,-		; DEFINE IN GLOBAL TABLE (unsupported)
		CHAIN,-			;IMAGE TO LATER INVOKE
		COMMAND,-		;COMMAND LINE TO LATER PROCESS
		CREALOG,-		;CREATE PROCESS LOGICAL NAME
		DELELOG,-		;DELETE PROCESS LOGICAL NAME
		DISACTRLY,-		;DISABLE CONTROL Y
		ENABCTRLY,-		;RE-ENABLE CONTROL Y
		INVREQ,-		; GET A SYMBOL VALUE (unsupported)
		INVREQ,-		; DELETE A LOCAL SYMBOL (unsupported)
		INVREQ,-		; DELETE A GLOBAL SYMBOL (unsupported)
		DISAOOB,-		;DISABLE OUT-OF-BAND CHARACTER(S)
		ENABOOB,-		;RE-ENABLE OUT-OF-BAND CHARACTER(S)
		>			;
 
INVREQ:	MOVL	#CLI$_INVREQTYP,R0	;SET ERROR CODE
	RET				;
 
PAUSE:	BSBW	CLI$GET_PRC		;GET ADDRESS OF PROCESS WORK AREA
	MOVL	PRC_L_INPRAB(R11),R0	;GET PROCESS INPUT RAB
	BBC	#DEV$V_TRM,RAB$L_CTX(R0),INVREQ ;CAN'T PAUSE IF NOT INTERACTIVE
	BRW	IMGPAUSE		;SET UP IMAGE PAUSE

;
; DEFINE A SYMBOL FOR THE PROCESS (unsupported)
;
;
;	.ENABL	LSB
;
;DEFLOC: MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF THE SYMBOL TABLE
;	BRB	10$
;DEFGBL: MOVAB	PRC_Q_GLOBAL(R11),R5	;SET ADDRESS OF GLOBAL SYMBOL TABLE
;10$:	MOVQ	4(R9),R3		;SET SYMBOL NAME DESCRIPTOR
;	MOVQ	12(R9),R1		;AND SYMBOL VALUE
;	BSBW	MCR$ALLOCSYM		;CREATE THE SYMBOL
;	RET
;
;	.DSABL	LSB

DISACTRLY:				;DISABLE CONTROL Y
	BISW	#PRC_M_NOCTLY,PRC_W_FLAGS(R11)
DIS1:	MOVL	#1,R0			;SET SUCCESS
DIS2:	RET
ENABCTRLY:				;RE-ENABLE CONTROL Y
	BICW	#PRC_M_NOCTLY,PRC_W_FLAGS(R11)
	BRB	DIS1			;SET SUCCESS AND EXIT

CTRLY_MASK=^X2000000

DISAOOB:
	BSBB	CHECK_OOB		;Do out-of-band simulation.
	BRB	DISACTRLY		;Do disable CTRL-Y.
ENABOOB:
	BSBB	CHECK_OOB		;Do out-of-band simulation.
	BRB	ENABCTRLY		;Do enable CTRL-Y.
CHECK_OOB:
	CLRL	8(R9)			;Assume CTRL-Y currently disabled.
	BITW	#PRC_M_NOCTLY, PRC_W_FLAGS(R11) ;Test for CTRL-Y disabled,
	BNEQ	10$			;and branch if it is.
	BISL	#CTRLY_MASK, 8(R9)	;Else signal CTRL-Y is enabled.
10$:	BITL	#^C<CTRLY_MASK>, 4(R9)	;Check for legal mask.
	BNEQ	20$			;Branch if not legal.
	BITL	#CTRLY_MASK, 4(R9)	;Check for nothing to do, and if
	BEQL	DIS1			;nothing exit w/o doing anything.
	RSB				;Otherwise, return & proceed.
20$:	MOVL	#CLI$_BADCTLMSK, R0	;Signal illegal mask value,
	RET				;and give up.

	.ENABL	LSB
CHAIN:					;ACCEPT IMAGE NAME FOR LATER
	MOVZBL	#PRC_M_CHAIN,R5		;SET THE BIT MASK FOR CHAIN'S
	MOVAQ	PRC_Q_IMAGENAME(R11),R6	; AND GET POINTER TO THE DESCRIPTOR
	BRB	10$			;GO JOIN THE COMMON CODE

COMMAND:				;ACCEPT COMMAND LINE FOR LATER
	MOVZBL	#PRC_M_CMD,R5		;SET THE BIT MASK FOR COMMAND LINE'S
	MOVAQ	PRC_Q_COMMAND(R11),R6	; AND GET POINTER TO THE DESCRIPTOR
10$:	BICB	R5,PRC_B_FLAGS2(R11)	;TURN THE FEATURE OFF INITIALLY
	MOVW	8(R9),2(R6)		;SET NEW SIZE FROM CALLING DESC
	BSBB	MCR$ALLDEACMD		;GO DEALLOCATE/RE-ALLOCATE SPACE
	BLBC	R0,DIS2			;EXIT NOW IF FAILURE...
	TSTL	R1			;ANY NEW SIZE?
	BEQL	DIS1			;NOPE, GO SET SUCCESS AND EXIT
	BISB	R5,PRC_B_FLAGS2(R11)	;YEP, SO TRUN (BACK) ON THE FEATURE
	MOVQ	R1,(R6)			;LOAD DESCRIPTOR
	MOVB	#^A/ /,(R2)+		;LOAD AN INITIAL SPACE
	MOVC	8(R9),@12(R9),(R2)	; THEN MOVE IN THE STRING
	CLRB	(R3)			;  AND ENSURE IT'S TERMINATED
	BRB	DIS1			;SET SUCCESS AND EXIT
	.DSABL	LSB
;+
; MCR$ALLDEACMD - DEALLOCATE/RE-ALLOCATE CHAIN/COMMAND STRING STORAGE
;
; INPUTS:
;
;	R6 -> DESC W/ NEW SIZE @ 2(R6)
;
; OUTPUTS:
;
;	R0 =  STATUS
;	R1 =  NEW SIZE
;	R2 -> NEW BLOCK
;	R3,R4 = UNDEFINED
;-
MCR$ALLDEACMD::				;DEALLOCATE/RE-ALLOCATE CHAIN/COMMAND
	DISABLE				;DISABLE CONTROL/Y & C AST'S
	MOVZWL	(R6),R1			;GET CURRENT ALLOCATED SIZE
	BEQL	10$			;NONE
	MOVL	4(R6),R0		;SOME, GET POINTER TO BLOCK TO RETURN
	BSBW	MCR$DEADYNMEM		; AND GO RETURN IT
	CLRW	(R6)			;  THEN SAY IT'S NOW NULL
10$:	MOVL	#1,R0			;PRESET SUCCESS STATUS
	MOVZWL	2(R6),R1		;GET NEW DESCRIPTOR'S SIZE
	BEQL	20$			;ZERO LENGTH, JUST EXIT STATUS=SUCCESS
	CLRL	(R6)			;REAL LENGTH, BUT DON'T KEEP SAYING SO
	MOVL	#CLI$_ILLVAL,R0		;PRE-SET ERROR CODE
	CMPW	#CMDBUFSIZ-20,R1	;DOES TEXT FIT WITH ROOM TO SPARE?
	BLEQU	20$			;BRANCH IF NOT
	ADDL	#7+1+1,R1		;DO ROUND UP'S (QUAD+LEADING+TRAILING)
	BSBW	MCR$ALLDYNMEM		;GET THE DYNAMIC MEMORY SPACE
20$:	JSB	@(SP)+			;CO-ROUTINE RETURN TO ENABLE C/Y&C
	RSB				;EXIT

CREALOG:				;CREATE A PROCESS LOGICAL NAME
	$CRELOG_S #2,4(R9),12(R9),#PSL$C_SUPER	;PERFORM SERVICE IN SUPER MODE
	RET				;RETURN STATUS OF SERVICE DIRECTLY
DELELOG:				;DELETE PROCESS LOGICAL NAME
	$DELLOG_S #2,4(R9),#PSL$C_SUPER	;REMOVE LOGICAL NAME FROM TABLE
	RET				;RETURN STATUS OF SERVICE DIRECTLY

	.SBTTL	CONTROL Y AST HANDLER
;+
; MCR$CONTRLY - CONTROL Y AST HANDLER
;
; THIS ROUTINE IS CALLED WHEN A CONTROL Y AST OCCURS WHILE RUNNING IN USER
; OR SUPERVISOR MODE.
;
; INPUTS:
;
;	AP = ADDRESS OF AST ARGUMENT LIST.
;
; OUTPUTS:
;
;	THE CONTROL Y AST IS RE-ENABLED AND A CHECK IS MADE TO SEE IF THE
;	PREVIOUS MODE WAS USER OR SUPERVISOR.
;
;	PREVIOUS MODE USER:
;
;		A COMMAND WORK AREA IS ALLOCATED ON THE STACK, THE PROCESS
;		SAVED ARGUMENT AND FRAME POINTERS ARE MOVED TO THE COMMAND
;		WORK AREA, THE CURRENT ARGUMENT AND FRAME POINTERS ARE SAVED
;		IN THE PROCESS SAVE AREA, AST'S ARE ENABLED, AND THE COMMAND
;		INTERPRETER RESTART POINT IS JUMPED TO.
;
;	PREVIOUS MODE SUPERVISOR:
;
;		IF CONTROL Y AST'S ARE CURRENTLY SOFTWARE DISABLED, THEN THE
;		AST IS DISMISSED IMMEDIATELY. OTHERWISE THE SAVED PROCESS
;		ARGUMENT AND FRAME POINTERS ARE RESTORED, AST'S ARE ENABLED,
;		AND THE COMMAND INTERPRETER RESTART POINT IS JUMPED TO.
;-
 
	.ENABL	LSB
	.ENTRY	MCR$CONTRLY,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BSBW	CLI$GET_PRC		;GET ADDRESS OF PROCESS WORK AREA
	CMPW	#SS$_HANGUP,4(AP)	;TERMINAL LINE HANGUP?
	BNEQ	10$			;IF NEQ NO
	BISW	#PRC_M_HANGUP,PRC_W_FLAGS(R11) ;SET HANGUP PENDING
	BRB	15$			;
10$:	BSBW	MCR$ENBCONTRLY		; Re-enable control Y ast
	BBS	#PRC_V_NOCTLY,PRC_W_FLAGS(R11),35$ ;BR IF MUST IGNORE
15$:	BBS	#PSL$V_CURMOD,20(AP),60$ ;IF SET, PREVIOUS MODE USER
	PUSHAB	W^MCR$LOW_LIMIT		;GET ADDRESS OF LOWER ADDRESS LIMIT
	CMPL	(SP)+,16(AP)		;ADDRESS WITHIN LIMITS?
	BGTRU	20$			;IF GTRU NO
	PUSHAB	W^MCR$HIGH_LIMIT	;GET ADDRESS OF HIGH ADDRESS LIMIT
	CMPL	(SP)+,16(AP)		;ADDRESS WITHIN LIMITS?
	BGTRU	50$			;IF GTRU YES
20$:	BBS	#PRC_V_DISABL,PRC_W_FLAGS(R11),30$ ;IF SET, CONTROL Y/C AST'S DISABLED
	BBS	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),40$ ;IF SET, AT CONTROL Y/C LEVEL
	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BEQL	40$			;IF EQL YES
30$:	BISW	#PRC_M_CNTRLY,PRC_W_FLAGS(R11) ;SET CONTROL Y/C REQUEST
35$:	RET				;
 
;
; PREVIOUS MODE SUPERVISOR
;
 
40$:	MOVL	PRC_L_SAVFP(R11),FP	;RESTORE SAVED FRAME POINTER
	BRB	70$			;
 
;
; SUPERVISOR MODE CONTROL Y/C WHILE ACTIVATING IMAGE
;
 
50$:	MOVL	PRC_L_SAVFP(R11),FP	;RESTORE SAVED FRAME POINTER
 
;
; CREATE DUMMY CONTROL Y/C AST FRAME
;
 
MCR$SCNTRLY::				;SUPERVISOR CONTROL Y/C
	SUBL3	#5*4,WRK_L_SAVSP(FP),SP	;ALLOCATE DUMMY AST ARGUMENT LIST
	PUSHL	#5			;SET NUMBER OF ARGUMENTS
	MOVL	SP,AP			;SET ARGUMENT POINTER
	PUSHAB	B^80$			;SET RETURN ADDRESS
	MOVQ	AP,-(SP)		;SAVE ARGUMENT AND FRAME POINTERS
	CLRQ	-(SP)			;CLEAR PSW, MASK, AND HANDLER ADDRESS
	MOVL	SP,FP			;SET NEW FRAME POINTER
 
;
; PREVIOUS MODE USER
;
 
IMGPAUSE:				;ENTER HERE FOR PAUSE
60$:	MOVAB	WRK_K_LENGTH(FP),SP	;ALLOCATE COMMAND WORK AREA
	MOVQ	PRC_L_SAVAP(R11),WRK_L_SAVAP(FP) ;SAVE ARGUMENT AND FRAME POINTERS
	ADDL	#20,AP			;POINT TO SAVED PSL
	MOVQ	AP,PRC_L_SAVAP(R11)	;SAVE CURRENT ARGUMENT AND FRAME POINTERS
70$:	BISW	#PRC_M_YLEVEL,PRC_W_FLAGS(R11) ;SET CONTROL Y/C LEVEL
	CHMK	#0			;ENABLE AST'S
	BBC	#PRC_V_PRIV,PRC_B_FLAGS2(R11),75$ ; Branch if not privileged image
	BSBW	MCR$RUNDOWN		; Run the privileged image down
75$:
	BRW	MCR$RESTART		;
 
;
; CONTINUE AFTER SIMULATED CONTROL Y/C AST FROM USER MODE
;
 
80$:	ADDL	#4*4,SP			;REMOVE DUMMY AST ARGUMENTS
	REI				;
	.DSABL	LSB

	.SBTTL	ENABLE CONTROL Y AST
;+
; MCR$ENBCONTRLY - ENABLE CONTROL Y AST
;
; THIS ROUTINE IS CALLED TO ENABLE CONTROL Y AST'S ON THE INPUT CHANNEL.
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R0 = FINAL REQUEST STATUS.
;-
 
MCR$ENBCONTRLY::			;ENABLE CONTROL Y AST
	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),10$ ;IF SET, NOT INTERACTIVE JOB
	MOVL	PRC_L_INPRAB(R11),R0	;GET ADDRESS OF INPUT RAB
	BBC	#DEV$V_TRM,RAB$L_CTX(R0),10$ ;IF CLR, 'INPUT' NOT FROM TERMINAL
	$QIOW_S	#31,-			;EVENT FLAG
		PRC_W_INPCHAN(R11),-	;INPUT CHANNEL
		#IO$_SETMODE!IO$M_CTRLYAST,,,,- ;FUNCTION CODE
		W^MCR$CONTRLY,,-	;AST ROUTINE ADDRESS
		#PSL$C_SUPER		;ENABLE MODE
10$:	RSB				;

	.SBTTL	COMMAND INTERPRETER CONDITION HANDLER
;+
; MCR$CONDHAND - COMMAND INTERPRETER CONDITION HANDLER
;
; THIS ROUTINE IS CALLED AS THE RESULT OF AN EXCEPTION CONDITION THAT OCCURS
; WHILE EXECUTING IN THE COMMAND INTERPRETER.
;
; INPUTS:
;
;	CHF$L_MCHARGLST(AP) = ADDRESS OF MECHANISM ARGUMENTS.
;
; OUTPUTS:
;
;	ANY EXIT HANDLERS ARE CANCELLED AND THE CONDITION IS RESIGNALLED.
;-
 
	.ENTRY	MCR$CONDHAND,^M<>
	$CANEXH_S			;CANCEL ANY EXIT HANDLERS
	CLRL	R0			;RESIGNAL THE CONDITION
	RET
 
	.END
