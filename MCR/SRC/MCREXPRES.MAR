	.TITLE	MCREXPRES - EXPRESSION ANALYSIS
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 7-DEC-1977
;
; Modified by:
;
;	V01.02	RN0014		R. Newland	16-Dec-1979
;		Set precedence of ! and & operators to the same as
;		+, -, * and / so expressions are evaluated from left to right.
;		SPR 11-27205
;
;
;	V01.01	RN0001		R. Newland	21-Jun-1979
;		Correct expression syntax errors occuring if 3
;		operators in sequence.
;
; EXPRESSION ANALYSIS
.PAGE
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS CODES
	DEFSYMTBL			;DEFINE SYMBOL TABLE VALUES
 
;
; LOCAL MACROS
;
; GENERATE OPERATOR/OPERAND TABLE AND SYMBOL NAMES
;
 
	.MACRO	GENOP NAME,INDEX,TYPE,PREC,CHAR,?L1,?L2,?L3,?L4
OPI_K_'NAME=INDEX
	.IF IDN	<TYPE>,<OPERATOR>
OPP_K_'NAME=PREC
	.IF DIF	<NAME>,<SOS>
	.IF DIF	<NAME>,<EOS>
	.IF DIF	<NAME>,<STORE>
L1:	.BYTE	L4-L1
	.BYTE	L3-L2
	.IF NB	<CHAR>
L2:	.ASCII	\CHAR\
	.IFF
L2:	.ASCII	/NAME/
	.ENDC
L3:	.BYTE	OPP_K_'NAME
L4:	.BYTE	OPI_K_'NAME
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDM	GENOP
 
;
; LOCAL SYMBOLS
;
; DEFINE STACK ITEM OFFSETS
;
 
	$DEFINI	STK
 
$DEF	STK_W_TYPE	.BLKW	1	;STACK ITEM TYPE
$DEF	STK_W_PREC			;OPERATOR PRECEDENCE
$DEF	STK_W_SIZE	.BLKW	1	;SIZE OF OPERAND VALUE IN BYTES
$DEF	STK_L_ADDR	.BLKL	1	;ADDRESS OF OPERAND VALUE
$DEF	STK_K_LENGTH			;LENGTH OF STACK ITEM
 
	$DEFEND	STK
 
;
; LOCAL DATA
;
; OPERATOR TABLE
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
OPTAB:	GENOP	SOS,28,OPERATOR,0	;START OF STATEMENT
	GENOP	EOS,30,OPERATOR,1	;END OF STATEMENT
	GENOP	LPAREN,32,OPERATOR,2,<(> ;LEFT PARENTHESIS
	GENOP	RPAREN,34,OPERATOR,3,<)> ;RIGHT PARENTHESIS
	GENOP	STORE,36,OPERATOR,0	;STORE RESULT
	GENOP	AND,0,OPERATOR,8,<&>	;BOOLEAN AND
	GENOP	NOT,2,OPERATOR,6	;BOOLEAN NOT
	GENOP	OR,4,OPERATOR,8,<!>	;BOOLEAN OR
	GENOP	ADD,6,OPERATOR,8,<+>	;INTEGER ADD
	GENOP	SUB,8,OPERATOR,8,<->	;INTEGER SUBTRACT
	GENOP	MUL,10,OPERATOR,8,<*>	;INTEGER MULTIPLY
	GENOP	DIV,12,OPERATOR,8,</>	;INTEGER DIVIDE
	GENOP	NEG,14,SPECIAL		;INTEGER NEGATE
	GENOP	SYMBOL,50,OPERAND	;SYMBOL TABLE OPERAND
	GENOP	STRING,50,OPERAND	;STRING SYMBOL OPERAND
	GENOP	OCTNUM,52,OPERAND	;OCTAL NUMBER SYMBOL OPERAND
	GENOP	DECNUM,54,OPERAND	;DECIMAL NUMBER SYMBOL OPERAND
	GENOP	HEXNUM,56,OPERAND	;HEX NUMBER SYMBOL OPERAND
	GENOP	LITERAL,58,OPERAND	;LITERAL OPERAND
	GENOP	STACK,60,OPERAND	;STACK OPERAND
	.BYTE	0			;TABLE TERMINATOR BYTE

;
; SPECIAL CASE DEFINITION OF PRECEDENCE OF INTEGER NEGATE
;

OPP_K_NEG=OPP_K_DIV+1			;ONE GREATER THAN HIGEST ARITHMETIC
 
;
; 'TRUE' AND 'FALSE'  VALUES
;
 
TRUE:	.ASCII	\TRUE\			;
FALSE:	.ASCII	\FALSE\			;
TRUFLS:	.ASCII	/FTNY/			; NOTE-ORDER IS ASSUMMED ELSEWHERE
 
;
; SYMTYP - THIS TABLE IS USED TO CONVERT A SYMBOL TABLE ENTRY TYPE
;	   TO IS PROPER OPERAND TYPE. NOTE THAT IS TABLE IS ORDER
;	   BY SYMBOL TYPE, IE: SYM_K_XXX.
;
 
	ASSUME	SYM_K_STRING  EQ 0	; CHECK FOR ASSUMED SYMBOL TYPE
	ASSUME	SYM_K_PERM    EQ 1	; CHECK FOR ASSUMED SYMBOL TYPE
	ASSUME	SYM_K_LOGICAL EQ 2	; CHECK FOR ASSUMED SYMBOL TYPE
	ASSUME	SYM_K_OCTAL   EQ 3	; CHECK FOR ASSUMED SYMBOL TYPE
	ASSUME	SYM_K_DECIMAL EQ 4	; CHECK FOR ASSUMED SYMBOL TYPE
	ASSUME	SYM_K_HEXDEC  EQ 5	; CHECK FOR ASSUMED SYMBOL TYPE
SYMTYP:	.BYTE	OPI_K_STRING		; SYMBOL TYPE 0 = STRING
	.BYTE	OPI_K_DECNUM		; SYMBOL TYPE 1 = DECIMAL NUMBER (PERMANENT)
	.BYTE	OPI_K_OCTNUM		; SYMBOL TYPE 2 = LOGICAL
	.BYTE	OPI_K_OCTNUM		; SYMBOL TYPE 3 = OCTAL NUMBER
	.BYTE	OPI_K_DECNUM		; SYMBOL TYPE 4 = DECIMAL NUMBER
	.BYTE	OPI_K_HEXNUM		; SYMBOL TYPE 5 = HEX NUMBER
	.PAGE
	.SBTTL	EXPRESSION ANALYSIS
;+
; MCR$EXPRESS - EXPRESSION ANALYSIS
;
; THIS ROUTINE IS CALLED TO ANALYZE AN EXPRESSION AND RETURN AN ARITHMETIC RESULT.
;
; INPUTS:
;
;	R6 = COMMAND BUFFER DISPLAY PARAMETER.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR IF EXPRESSION ERROR.
;
;		R0 = MCR$_COMPLX - EXPRESSION TOO COMPLEX.
;		R0 = MCR$_EXPSYN - EXPRESSION SYNTAX ERROR.
;		R0 = MCR$_IVCHAR - INVALID CHARACTER IN NUMERIC STRING.
;		R0 = MCR$_IVOPER - INVALID EXPRESSION OPERATOR.
;		R0 = MCR$_UNDSYM - UNDEFINED SYMBOL.
;
;			R6 = COMMAND BUFFER POINTER BACKUP PARAMETER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL EVALUATION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;
;			R1 = FINAL EXPRESSION VALUE.
;-
 
MCR$EXPRESS::				;ANALYZE EXPRESSION
	MOVB	#PRC_K_OCT,R1		;SET TO DEFAULT OCTAL RADIX
MCR$EXPRADIX::				;ALTERNATE ENTRY-RADIX SET EXTERNAL
	PUSHR	#^M<R3,R4,R5,R7,R8>	;SAVE SOME REGISTERS
	MOVB	R1,PRC_B_DEFRADIX(R11)	;SET THE RADIX FOR LATER
	MOVAL	WRK_AG_RESULT(FP),R10	;RESET PARSE STACK
	SETBIT	WRK_V_STAR,WRK_W_FLAGS(FP) ;SET ASTERISK TERMINATOR FLAG
	MOVL	SP,AP			;SAVE INITIAL STACK ADDRESS
	MOVL	SP,R8			;SET ADDRESS OF PARSE STACK
	MOVAB	-MSGBUFSIZ(SP),SP	;ALLOCATE SPACE FOR PARSE STACK
	MOVL	#<OPP_K_SOS>@16+OPI_K_SOS,-(R8) ;INITIALIZE PARSE STACK
	MOVQ	(R8),-(R8)		;DUPLICATE FIRST ITEM FOR ERROR CHECK
 
;
; PARSE NEXT ITEM
;
 
10$:	GETSSYM				;GET NEXT SYMBOL FORM INPUT BUFFER
	BLBC	R0,52$			;GET NEXT SYMBOL FROM INPUT BUFFER
	CMPW	STK_W_TYPE(R8),#OPI_K_SYMBOL ;TOS A SYMBOL
	BLSS	80$			;IF LSS NO, GO PARSE A SYMBOL
 
;
; PROCESS OPERATOR
;
 
30$:	MOVAB	OPTAB,R0		;GET ADDRESS OF OPERATOR TABLE
40$:	MOVL	R0,R5			;RETRIEVE ADDRESS OF NEXT OPERATOR ENTRY
	MOVZBL	(R5)+,R0		;GET OFFSET TO NEXT OPERATOR ENTRY
	BEQL	51$			;IF EQL END OF TABLE
	ADDL	R5,R0			;CALCULATE ADDRESS OF NEXT ENTRY
	CMPB	R1,(R5)+		;LENGTH OF NAMES MATCH?
	BNEQ	40$			;IF NEQ NO
	MOVQ	R1,R3			;COPY OPERATOR DESCRIPTOR
50$:	CMPB	(R4)+,(R5)+		;CHARACTERS MATCH?
	BNEQ	40$			;IF NEQ NO
	SOBGTR	R3,50$			;ANY MORE CHARACTERS TO MATCH?
	MOVZBL	(R5)+,R1		;GET OPERATOR PRECEDENCE VALUE
	MOVZBL	(R5),R3			;GET OPERATOR INDEX VALUE
	CMPL	#OPI_K_LPAREN,R3	;LEFT PARENTHESIS?
	BNEQ	53$			;IF NEQ NO
	CMPW	#OPI_K_SYMBOL,STK_W_TYPE(R8) ;TOP OF STACK OPERAND?
	BGTR	60$			;IF GTR NO
	BRB	67$
51$:	BRW	220$
52$:	BRB	200$

;
; ATTEMPT REDUCTION OF EXPRESSION BEFORE STACKING THIS OPERATOR.
;	1. IGNORE UNARY PLUS
;	2. CONVERT UNARY MINUS TO NEGATE OPERATOR
;	3. ADD FOLLOWED BY SUB BECOMES SUB ON TOP OF STACK
;	4. SUB FOLLOWED BY SUB BECOMES ADD ON TOP OF STACK
;	5. DETECT ILLEGAL SEQUENCE OF OPERATORS
;

53$:						;
	CMPW	#OPI_K_SYMBOL,STK_W_TYPE(R8)	;TOS AN OPERATOR?
	BLEQ	66$				;IF LEQ NO
	CMPW	#OPI_K_ADD,R3			;THIS A UNARY PLUS?
	BEQL	10$				;IF EQL YES, IGNORE IT
	CMPW	#OPI_K_SUB,R3			;THIS A UNARY MIUS?
	BNEQ	65$				;IF NEQ NO
	CMPW	#OPI_K_ADD,STK_W_TYPE(R8)	;TOS A PLUS
	BNEQ	57$				;IF NEQ NO
	ADDL	#STK_K_LENGTH,R8		;REMOVE PLUS FROM TOS
	BRB	60$				;GO STACK THIS MINUS
57$:						;
	CMPW	#OPI_K_SUB,STK_W_TYPE(R8)	;TOS A MINUS?
	BEQL	63$				;IF EQL YES
	MOVW	#OPI_K_NEG,R3			;CONVERT THIS TO NEGATE
	MOVW	#OPP_K_NEG,R1			;...
60$:	BRW	270$			;
 
63$:						;SEQUENCE IS MINUS MINUS
	MOVW	#OPI_K_ADD,STK_W_TYPE(R8)	;SO CHANGE TOS TO ADD
	BRW	10$				;AND IGNORE THIS MINUS
65$:						;TOS IS AN OPERATOR AND THIS IS
	CMPW	#OPI_K_NOT,R3			;NOT LPAREN, ADD OR SUB. ONLY LEGAL
	BNEQ	67$				;IS BOOLEAN NOT. IF NEQ IT IS NOT
	BRW	270$				;GO STACK NOT OPERATOR
66$:	BRW	240$				;
67$:						;
	BRW	370$				;GO REPORT SYNTAX ERROR
;
; PROCESS OPERAND OR SINGLE CHARACTER OPERATOR
;
 
80$:	MOVZBL	#OPI_K_LITERAL,R3	;ASSUME LITERAL VALUE
	CMPB	#^A/#/,(R2)		;OCTAL NUMBER
	BEQL	140$			;BR IF YES
	CMPB	#^A/%/,(R2)		;NUMERIC RADIX OPERATOR?
	BEQL	140$			;BR IF YES-ITS A NUMBER
	CMPB	(R2),#^A/0/		;CAN THIS BE A NUMERIC CONSTANT?
	BLSSU	100$			;BR IF NO
	CMPB	(R2),#^A/9/		;NUMERIC CONSTANT?
	BGTRU	100$			;IF GTRU NO
	SETCHAR				;PEEK AT NEXT CHARACTER
	CMPB	R0,#^A/./		;INDICATE A DECIMAL NUMBER?
	BNEQ	140$			;BR IF NO
	MOVCHAR				;COPY CHARATER TO COMMAND BUFFER
	INCL	R1			;ADJ SYMBOL LENGTH
	BRB	140$			;
100$:	SEARCH				;SEARCH OPERAND TABLE FOR A MATCH
	BLBC	R0,150$			;IF LBC SEARCH FAILURE
	MOVZBL	SYM_B_TYPE(R3),R3	;GET SYMBOL TYPE
	MOVZBL	SYMTYP[R3],R3		;COVNERT TO OPERAND TYPE
140$:	BRB	270$			;
150$:	BRW	380$			;
 
;
; ZERO LENGTH TOKEN - MUST BE OPERATOR SYMBOL
;
 
200$:	CMPB	R0,#^A/@/		;TERMINATE ON INDIRECT FILE
	BEQL	230$			;IF YES -END OF EXPRESSION BY DEFAULT
	MOVL	R9,R2			;SET ADDRESS OF START OF SYMBOL
	MOVCHAR				;MOVE TERMINATOR TO COMMAND BUFFER
	BEQL	230$			;IF EQL END OF LINE
	MOVL	#1,R1			;SET LENGTH OF STRING
	BRW	30$			;
 
;
; END OF STATEMENT
;
 
220$:	SUBL	R1,R9			;BACK TOKEN OUT OF PARSE BUFFER
	SUBL3	R1,WRK_L_CHARPTR(FP),R0	;BACK UP INPUT BUFFER
	MOVAB	(R0)+,WRK_L_CHARPTR(FP)	;SET TO POINT AT PRVIOUS CHARACTER
	MOVC	R1,(R2),(R0)		;REPLACE TOKEN IN INPUT BUFFER
230$:	MOVZBL	#OPP_K_EOS,R1		;SET END OF STATEMENT PRECEDENCE VALUE
	MOVZBL	#OPI_K_EOS,R3		;SET END OF STATEMENT OPERATOR INDEX
 
;
; COMPARE OPERATOR PRECEDENCE VALUE WITH OPERATOR IN NEXT TO LAST ITEM ON STACK
;
 
240$:	CMPW	#OPI_K_SYMBOL,STK_W_TYPE+STK_K_LENGTH(R8) ;PREVIOUS ITEM OPERATOR?
	BLEQ	250$			;IF LEQ NO
	CMPW	STK_W_PREC+STK_K_LENGTH(R8),R1 ;STACK OPERATOR HIGHER PRECEDENCE?
	BGEQ	300$			;IF GEQ YES
250$:	CMPL	#OPI_K_RPAREN,R3	;CURRENT OPERATOR RIGHT PARENTHESIS?
	BNEQ	260$			;IF NEQ NO
	CMPW	#OPI_K_NOT,STK_W_TYPE+STK_K_LENGTH(R8)	;OPERATOR BOOLEAN NOT?
	BEQL	300$					;IF EQL YES
	CMPW	#OPI_K_NEG,STK_W_TYPE+STK_K_LENGTH(R8)	;OPERATOR NEGATE?
	BEQL	300$					;IF EQL YES
	CMPW	#OPI_K_LPAREN,STK_W_TYPE+STK_K_LENGTH(R8) ;OPERATOR LEFT PAREN?
	BNEQ	370$			;IF NEQ NO
	MOVQ	(R8)+,(R8)		;REMOVE LEFT PARENTHESIS FROM STACK
	BRB	280$			;
260$:	CMPL	#OPI_K_EOS,R3		;END OF STATEMENT OPERATOR?
	BEQL	390$			;IF EQL YES
270$:	MOVL	R2,-(R8)		;STACK NEW ITEM
	MOVW	R1,-(R8)		;
	MOVW	R3,-(R8)		;
	CMPL	R8,SP			;PARSE STACK OVERFLOW?
	BLEQU	360$			;IF LEQU YES
280$:	BRW	10$			;
 
;
; UNSTACK TRIAD FROM PARSE STACK
;
 
300$:	PUSHR	#^M<R1,R3>		;SAVE OPERATOR PARAMETERS
	CMPW	#OPI_K_SYMBOL,STK_W_TYPE(R8) ;TOP ITEM ON STACK OPERAND?
	BGTR	370$			;IF GTR NO
	MOVQ	(R8)+,R4		;REMOVE RIGHT HAND OPERAND FROM STACK
	MOVQ	(R8)+,R2		;REMOVE OPERATOR FROM STACK
	CMPW	#OPI_K_NOT,R2		;BOOLEAN NOT?
	BEQL	340$			;IF EQL YES
	CMPW	#OPI_K_SYMBOL,STK_W_TYPE(R8) ;TOP ITEM ON STACK OPERAND?
	BLEQ	330$			;IF LEQ YES
	CMPW	#OPI_K_NEG,R2		;OPERATOR UNARY MINUS?
	BNEQ	370$			;IF NEQ NO
	BRB	340$			;
330$:	MOVQ	(R8)+,R0		;REMOVE LEFT HAND OPERAND FROM STACK
340$:	MOVAB	(R10),-(R8)		;PUSH ADDRESS OF STACK OPERAND
	MOVZBL	#OPI_K_STACK,-(R8)	;PUSH OPERAND INDEX VALUE
	MOVAB	WRK_L_RSLNXT-20(FP),-(SP) ;GET NEW TOP OF TRIAD STACK ADDRESS
	CMPL	R10,(SP)+		;TRIAD STACK OVERFLOW?
	BGTRU	360$			;IF GTRU YES
	MOVQ	R4,(R10)+		;PUSH RIGHT HAND OPERAND
	MOVZWL	R2,(R10)+		;PUSH OPERATOR INDEX
	MOVQ	R0,(R10)+		;PUSH LEFT HAND OPERAND
350$:	POPR	#^M<R1,R3>		;RETRIEVE OPERATOR PARAMETERS
	BRW	240$			;
 
;
; EXPRESION TOO COMPLEX
;
 
360$:	STATUS	COMPLX			;SET COMPLEX EXPRESSION STATUS
	BRB	380$			;
 
;
; EXPRESSION SYNTAX ERROR
;
 
370$:	STATUS	EXPSYN			;SET EXPRESSION SYNTAX ERROR STATUS
380$:	MOVL	AP,SP			;CLEAN STACK
	BRW	EXPEXT			;
 
;
; END OF STATEMENT - CHECK FOR VALID PARSE
;
 
390$:	CMPW	#OPI_K_SYMBOL,STK_W_TYPE(R8) ;TOP ITEM ON STACK OPERAND?
	BGTR	370$			;IF GTR NO
	MOVAB	WRK_L_RSLNXT-12(FP),-(SP) ;GET NEW TOP OF TRIAD STACK ADDRESS
	CMPL	R10,(SP)+		;TRIAD STACK OVERFLOW?
	BGTRU	360$			;IF GTRU YES
	MOVQ	(R8)+,(R10)+		;MOVE RIGHT HAND OPERAND TO TRIAD STACK
	CMPW	#OPI_K_SOS,STK_W_TYPE(R8) ;TOP OF STACK START OF STATEMENT?
	BNEQ	370$			;IF NEQ NO
	MOVZBL	#OPI_K_STORE,(R10)	;INSERT STORE OPERATOR
	MOVL	AP,SP			;CLEAN STACK
 
;
; EVALUATE IF EXPRESSION
;
 
EVALUATE:				;EVALUATE IF EXPRESSION
	MOVAB	WRK_AG_RESULT(FP),R10	;GET STARTING ADDRESS OF TRIAD STACK
10$:	MOVL	R10,AP			;SAVE ADDRESS TO STORE TRIAD RESULT
	CLRL	R6			;ASSUME OPERATION RESULT IS FALSE
	BSBB	FETCH			;FETCH RIGHT HAND OPERAND PARAMETERS
	MOVL	(R10)+,R5		;FETCH OPERATOR INDEX
	BSBB	NUMERIC			;CONVERT RIGHT HAND OPERAND TO NUMERIC
	MOVL	R1,R7			;SAVE RIGHT HAND OPERAND VALUE
	CMPL	#OPI_K_STORE,R5		;STORE OPERATOR?
	BEQL	40$			;IF EQL YES
	BSBB	FETCH			;FETCH LEFT HAND OPERAND PARAMETERS
	CMPL	#OPI_K_NOT,R5		;BOOLEAN NOT OPERATOR?
	BEQL	30$			;IF EQL YES
	CMPL	#OPI_K_NEG,R5		;INTEGER NEGATION?
	BEQL	30$			;IF EQL YES
	BSBB	NUMERIC			;CONVERT LEFT HAND OPERAND TO NUMERIC
	CMPL	R1,R7			;COMPARE RIGHT AND LEFT HAND OPERANDS
30$:	JSB	W^DISPATCH[R5]		;EXECUTE OPERATOR SPECIFIC ROUTINE
	MOVL	R6,(AP)			;STORE OPERATION RESULT
	BRB	10$			;
 
;
; STORE RESULT OPERATOR
;
 
40$:	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
EXPEXT:	CLRBIT	WRK_V_STAR,WRK_W_FLAGS(FP) ;SET NORMAL TERMINATION MODE
	POPR	#^M<R3,R4,R5,R7,R8>	; RESTORE REGISTERS
	RSB				;
	.PAGE
	.SBTTL	FETCH NEXT OPERAND FROM TRIAD STACK
;
; FETCH - FETCH NEXT OPERAND FROM TRIAD STACK
;
 
FETCH:	MOVZWL	(R10)+,R0		;GET TYPE OF OPERAND
	MOVZWL	(R10)+,R1		;GET LENGTH OF OPERAND
	MOVL	(R10)+,R2		;GET ADDRESS OF OPERAND
	RSB				;
	.PAGE
	.SBTTL	CONVERT OPERAND PARAMETERS TO NUMERIC VALUE
;
; NUMERIC - CONVERT OPERAND PARAMETERS TO NUMERIC VALUE
;
 
NUMERIC:				;NUMERIC OPERAND
	CMPL	#OPI_K_STACK,R0		;STACK OPERAND?
	BEQL	30$			;IF EQL YES
	TSTL	R1			;ZERO LENGTH STRING?
	BEQL	40$			;BR IF YES - RETURN THE ZERO
	MOVQ	R1,R2			;SET DESCRIPTOR FOR STRING
	MOVZBL	PRC_B_DEFRADIX(R11),R1	;SET RADIX INDICATOR
	CMPL	R0,#OPI_K_LITERAL	;OPERAND A LITERAL?
	BEQL	20$			;BR IF YES - USE DEFAULT RADIX
	CLRL	R1			;SET RADIX TO HEX
	CMPL	R0,#OPI_K_DECNUM	;CHECK RADIX OF SYMBOL
	BGTRU	20$			;BR IF HEX
	BEQL	15$			;BR IF DECIMAL
	INCL	R1			;ADJUST RADIX INDICATOR
15$:	INCL	R1			;ETC
20$:	PUSHL	R3			;SAVE START OF SYMBOL
	BSBW	MCR$CNVASCBIN		;CONVERT NUMBER
	CMPB	R2,#8			;RADIX USED THE "DEFAULT"
	BEQL	25$			;IF YES, DON'T CHANGE CURRENT
	MOVB	R2,WRK_B_CURADX(FP)	;SAVE RADIX USED FOR CONVERSION
25$:	POPR	#^M<R2>			;RESTORE START OF SYMBOL
	TSTL	R0			;ANY UNCONVERTED DIGITS
	BEQL	40$			;BR IF NO ERROR
	BRB	80$			;CHECK FOR TRUE/FALSE
30$:	MOVL	(R2),R1			;GET STACK OPERAND
40$:	STATUS	NORMAL			;
	RSB				;
 
;
; INVALID CHARACTER IN STRING-CHECK FOR BEGINNING LETTER "TFYN"
;
 
80$:	LOCC	(R2),#4,TRUFLS		;CHECK FOR SPECIAL CHARACTERS
	BEQL	85$			;RETURN ERROR IF NO MATCH
	BICL3	#6,R0,R1		;CONVERT COUNT TO 0 OR 1
	BRB	40$			;
85$:	MOVAB	1(R3),R9		;SET END OF ERROR SEGMENT
	MOVL	R2,R6			;AND START OF ERROR SEGMENT
	TSTL	(SP)+			;CLEAN STACK OF PREVIOUS CALLER
	STATUS	IVCHAR			;INVALID CHARACTER
	BRB	EXPEXT			;EXIT EXPRESSION ANALYSIS
	.PAGE
	.SBTTL	DISPATCH OPERATOR FUNCTION
;
; DISPATCH OPERATOR FUNCTION
;
 
DISPATCH:				;
	BRB	AND			;BOOLEAN AND
	BRB	NOT			;BOOLEAN NOT
	BRB	OR			;BOOLEAN OR
	BRB	ADD			;INTEGER ADD
	BRB	SUB			;INTEGER SUBTRACT
	BRB	MUL			;INTEGER MULTIPLY
	BRB	DIV			;INTEGER DIVIDE
	BRB	NEG			;INTEGER NEGATION
 
;
; BOOLEAN AND
;
 
AND:	MCOML	R1,R1			;COMPLEMENT LEFT HAND OPERAND
	BICL3	R1,R7,R6		;FORM BOOLEAN AND FUNCTION
	RSB				;
 
;
; BOOLEAN NOT
;
 
NOT:	MCOML	R7,R6			;FORM BOOLEAN NOT FUNCTION
	RSB				;
 
;
; BOOLEAN OR
;
 
OR:	BISL3	R1,R7,R6		;FORM BOOLEAN OR FUNCTION
	RSB				;
 
;
; INTEGER ADD
;
 
ADD:	ADDL3	R1,R7,R6		;FORM ARITHMETIC SUM
	RSB				;
 
;
; INTEGER SUBTRACT
;
 
SUB:	SUBL3	R7,R1,R6		;FORM ARITHMETIC DIFFERENCE
	RSB				;
 
;
; INTEGER MULTIPLY
;
 
MUL:	MULL3	R1,R7,R6		;FORM ARITHMETIC PRODUCT
	RSB				;
 
;
; INTEGER DIVIDE
;
 
DIV:	MOVL	R7,R6			;DIVIDE BY ZERO ATTEMPT?
	BNEQ	20$			;BR IF NO
	SETBIT	#31,R6			;MAKE RESULT THE HIGHEST NEG NUMBER
	TSTL	R1			;SOURCE NEGATIVE?
	BLSS	10$			;BR IF YES
	MCOML	R6,R6			;MAKE THE LARGEST POSITIVE NUMBER
10$:	RSB				;
20$:	DIVL3	R7,R1,R6		;FORM ARITHMETIC QUOTIENT
	RSB				;
 
;
; INTEGER NEGATION
;
 
NEG:	MNEGL	R7,R6			;NEGATE OPERAND
	RSB				;
 
	.END
