	.TITLE	MCRSET - SET PARAMETER MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 17-APR-77
;
; Modified by:
;
;	V002	MAJ0002		Melanie Johnson	02-Mar-1982
;		Allow SET [NO]CONTROL=Y, but print error message if the
;		value is anything other than Y.
;
;	V001	MAJ0001	Melanie Johnson	16-Oct-81
;		Warn user that account UIC has not been changed by SET /UIC
;		if the process doesn't have the CMKRNL privilege.
;
;
; SET PARAMETER MCR COMMAND EXECUTION
;
;	SET DIRECTORY
;	SET PROTECTION
;	SET USER IDENTIFICATION CODE
;	SET VERIFY MODE
;
; MACRO LIBRARY CALLS
;
 
	$CLIDEFQUALSET			;DEFINE SET QUALIFER NUMBERS
	$CLIMSGDEF			;DEFINE CLI RELATED ERRORS
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFPTRDSC			;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$LOGDEF				;LOGICAL NAME DEFINITIONS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
 
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
ACCESS:					;ACCESS PROTECTION CODES
	.ASCII	/DEWR/			;
CLASS:					;PROTECTION CLASSES
	.ASCII	/WGOS/			;
MCR$T_DSKNAM::				;STRING FOR DEFAULT DEVICE
	.ASCIC	/SYS$DISK/		;THE NAME
	.PAGE
	.SBTTL	SET USER IDENTIFICATION CODE
;+
; MCR$SETUIC - SET USER IDENTIFICATION CODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET USER
; IDENTIFICATION CODE MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT USER IDENTIFICATION CODE IS ESTABLISHED,
;	THEN THE CURRENT DEFAULT DIRECTORY IS CHANGED TO MATCH.
;-
 
MCR$SETUIC::				;SET USER IDENTIFICATION CODE
	BSBB	MCR$SETDEFALT		;SET DEFAULT DIRECTORY AND/OR DEVICE
	BLBC	R0,20$			;IF LBC ERROR SETTING DIRECTORY
					; NOTE: R4,R5=DESCRIPTOR FOR DIRECTORY
	BBS	#PRV$V_CMKRNL,-		;CHECK IF THIS USER IS ALLOWED TO
		@#CTL$GQ_PROCPRIV,10$	;CHANGE MODE TO KERNAL, IF NOT
	STATUS	INSPRIV			;WARN THE USER THAT ACCT. UIC WILL NOT
	BRB	20$			;BE CHANGED AND LEAVE

10$:	BSBB	CVTUIC			;CONVERT GROUP NUMBER
	CMPB	#^A/,/,(R5)		;END WITH A COMMA?
	BNEQ	30$			;IF NEQ NO
	MOVW	R0,-(R9)		;SAVE GROUP NUMBER
	BSBB	CVTUIC			;CONVERT MEMBER NUMBER
	MOVW	R0,-(R9)		;SAVE MEMBER NUMBER
	$CMKRNL_S B^SETUIC,(R9)		;SET USER IDENTIFICATION CODE
20$:	RSB				;
30$:	STATUS	INVUIC			;SET INVALID UIC SYNTAX
	RSB				;
 
;
; CONVERT UIC COMPONENT
;
 
MCR$CVTUIC::
CVTUIC:	CLRQ	R0			;CLEAR ACCUMULATION AND CHARACTER
10$:	INCL	R5			;POINT TO NEXT CHARACTER
	SUBB3	#^A/0/,(R5),R1		;GET NEXT CHARACTER
	BLSS	20$			;IF LSS NOT DIGIT
	CMPL	#8,R1			;OCTAL DIGIT?
	BLEQ	20$			;IF LEQ NO
	MOVAQ	(R1)[R0],R0		;ACCUMULATE RESULT
	BRB	10$			;
20$:	RSB				;
 
;
; SET USER IDENTIFICATION CODE
;
 
SETUIC:	.WORD	0			;ENTRY MASK
	MOVL	@#SCH$GL_CURPCB,R0	;GET CURRENT PROCESS PCB ADDRESS
	MOVL	(AP),PCB$L_UIC(R0)	;SET USER IDENTIFICATION CODE
	STATUS	NORMAL			;
	RET				;
 
	.PAGE
	.SBTTL	SET DEFAULT DEVICE AND/OR DIRECTORY
;+
; MCR$SETDEFALT - SET DEFAULT DEVICE AND/OR DIRECTORY
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET DEFAULT
; MCRS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	A LOGICAL NAME IS ASSIGNED FOR DISK THE DEVICE NAME ENTER.
;	THE CURRENT DEFAULT DIRECTORY IS ESTABLISHED.
;	EITHER FIELD IS OPTIONAL, ADDITIONAL INFORMATION IS IGNORED.
;	*** NOTE *** R4,R5 = STRING DESCRITPOR FOR DIRECTORY FOR SET UIC.
;-
 
MCR$SETDEFALT::				;SET DEFAULT DEVICE AND/OR DIRECTORY
	TSTL	(R10)+			; SKIP OPTION DESCRIPTOR
	GETDVAL				;GET THE VALUE OF TOKEN DESCRIPTOR
	MOVQ	R1,-(R9)		;PUSH DESCRIPTOR INTO SCRATCH STACK
	PUSHL	R2			;ADDRESS OF STRING IN BUFFER
	PUSHL	#63			;MAXIMUM STRING TO RETURN
	MOVL	SP,R0			;GET ADDRESS OF OUTPUT DESCRIPTOR
	$TRNLOG_S (R9),(R0),(R0)	;TRANSLATE THE NAME
	MOVQ	(SP)+,R4		;RESET RESULTANT STRING DESCRIPTOR
	CLRB	(R5)[R4]		;MARK END OF STRING
	LOCC	#^A/:/,R4,(R5)		;LOOK FOR DEVICE NAME DELIMITER
	BEQL	50$			;BR IF NO DEVICE HERE
	CMPB	(R1)+,(R1)		;IS THIS A NODE NAME?
	BNEQ	20$			;BR IF ONLY DEVICE
	MOVAB	1(R1),R3		;SET ADDRESS OF END OF NODE STRING
	SUBL	#2,R0			;AND LENGTH OF REMAINDER
	LOCC	#^A/:/,R0,(R3)		;SEE IF DEVICE NAME IS HERE
	BEQL	10$			;BR IF NONE-JUST USE NODE
	MOVAB	1(R1),R3		;SET END OF DEVICE NAME
10$:	MOVL	R3,R1			;SET END OF EQUIVALENCE NAME FOR DISK
20$:	MOVL	R1,R5			;SET START OF DIRECTORY STRING
	SUBL	R2,R1			;FIND LENGTH OF DEVICE NAME
	SUBL	R1,R4			;ADJUST DIRECTORY STRING LENGTH
	MOVAB	MCR$T_DSKNAM,R7		;ADDRESS OF DEVICE NAME COUNTED STRING
	MOVZBL	(R7)+,R6		;GET LENGTH AND ADDRESS OF FIRST BYTE
	SUBL3	R6,R1,-(SP)		;FIND DIFFERENCE IN NAME STRING SIZES
	DECL	(SP)+			;CHECK IF 1 BYTE DIFFERENCE(THE COLON!)
	BNEQ	30$			;BR IF NO-CAN'T BE THE SPECIAL NAME
	PUSHR	#^M<R1,R2,R3>		;SAVE REGISTERS TO BE USED
	CMPC3	R6,(R2),(R7)		;CHECK FOR RESERVED SYSTEM NAME
	POPR	#^M<R1,R2,R3>		;RESTORE VALUES
	BEQL	50$			;BR IF NO DEVICE NAME ASSIGNMENT NEEDED
30$:	PUSHR	#^M<R1,R2,R6,R7>	;DESCRIPTORS FOR LOGICAL AND EQUIVALENCE NAME
	PUSHL	#0			;ACCESS MODE IS DEFAULTED
	PUSHAQ	4(SP)			;ADDRESS OF EQUIVALENCE NAME DESCRITPOR
	PUSHAQ	16(SP)			;DESCRIPTOR OF NAME TO RELATE WITH
	PUSHL	#LOG$C_PROCESS		;TABLE NUMBER
	CALLS	#8,@#SYS$CRELOG		;CLEAR DESCRIPTOR ON RETURN
	BLBC	R0,62$			;BR IF ERROR CREATING NAME
50$:	TSTL	R4			;ANY DIRECTORY FIELD
	BEQL	99$			;BR IF NO
	CMPB	R4,#2			;NULL DIRECTORY STRING?
	BLEQ	61$			;BR IF YES-NULL NOT VALID DEFAULT
	LOCC	(R5),#2,B^100$		;VALID DIRECTORY STARTING CHARACTER
	BEQL	61$			;BR IF NO
	CMPB	2(R1),-1(R5)[R4]	;CHECK THAT END IS END OF THE DIRECTORY
	BNEQ	61$			;ELSE INVALID SPECIFICATION
	CMPB	#^A/./,1(R5)		;IS THIS A PASTE DIRECTORY OPERATION?
	BNEQ	80$			;BR IF NO-SET THIS AS DEFAULT
	MOVAB	@#PIO$GT_DDSTRING,R3	;POINT AT CURRENT DEFAULT
	MOVZBL	(R3)+,R2		;GET LENGTH, POINT AT FIRST BYTE
	LOCC	#^A/,/,R2,(R3)		;CHECK FOR CONFLICTING SYNTAX
	BEQL	63$			;BR IF NO COMMA HERE-ALL IS AOK
61$:	STATUS	DIRECT			;SET ERROR CAUSE
62$:	BRB	99$			;
63$:	MOVL	4(R8),R1		;GET POINTER INTO SCRATCH BUFFER
	MOVB	(R5)+,(R1)+		;INSERT DIRECTORY DELIMITER
	DECL	R4			;ADJUST LENGTH FOR BYTE MOVED
	INCL	R3			;SKIP PREVIOS DELIMITER
	SUBL	#2,R2			;ADJUST LENGTH FOR NO DELIMITERS
65$:	MOVB	(R3)+,(R1)+		;INSERT PREVIOUS DEFAULT
	SOBGTR	R2,65$			;BR IF NOT DONE
70$:	MOVB	(R5)+,(R1)+		;PASTE NEW AT END OF OLD
	SOBGTR	R4,70$			;BR IF MORE TO MOVE
	MOVL	4(R8),R5		;SET START OF NEW STRING
	SUBL3	R5,R1,R4		;FIND THE NEW LENGTH
80$:	PUSHR	#^M<R4,R5>		;DESCRIPTOR FOR DIRECTORY NAME
	CLRQ	-(SP)			;SET 2 OPTIONAL ARGS TO BE NULL
	PUSHAB	8(SP)			;ADDRESS OF DIRECTORY STRING
	CALLS	#5,@#SYS$SETDDIR	;SET THE DEFAULT DIRECTORY
	BLBC	R0,99$			;BR IF ERROR FROM RMS
90$:	STATUS	NORMAL			;ASSUME ALL IS AOK
99$:	RSB				;
100$:	.ASCII	\[<]>\			; DIRECTORY DELIMITORS
	.PAGE
	.SBTTL	SET PROTECTION
;+
; MCR$SETPROT - SET PROTECTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET PROTECTION
; MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT PROTECTION IS ESTABLISHED.
;-
 
MCR$SETPROT::				;SET PROTECTION
	MOVZWL	@#PIO$GW_DFPROT,R9	;GET DEFAULT PROTECTION VALUE
	TSTL	(R10)+			;SKIP PAST OPTION DESCRIPTOR
10$:	GETDVAL				;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_QUALVALU,R5	;QUALIFIER VALUE?
	BNEQ	40$			;IF NEQ NO
	LOCC	(R2),#4,CLASS		;LOCATE PROTECTION CLASS
	BEQL	60$			;IF EQL INVALID CLASS
	DECL	R0			;CALCULATE STARTING BIT NUMBER
	MULL3	#4,R0,R8		;
	INSV	#^XF,R8,#4,R9		;START WITH NO ACCESS
	CMPB	#PTR_K_COLON,R4		;PROTECTION VALUE SPECIFIED?
	BNEQ	10$			;IF NEQ NO
	GETDVAL				;GET PROTECTION VALUE DESCRIPTOR
	MOVL	R1,R7			;SAVE LENGTH OF VALUE STRING
20$:	LOCC	(R2)+,#4,ACCESS		;LOCATE PROTECTION CODE
	BEQL	50$			;IF EQL INVALID PROTECTION CODE
	DECL	R0			;CALCULATE RELATIVE BIT NUMBER IN FIELD
	ADDL	R8,R0			;CALCULATE ACTUAL BIT NUMBER
	BBCC	R0,R9,30$		;ALLOW SPECIFIED ACCESS
30$:	SOBGTR	R7,20$			;ANY MORE TO SCAN?
	BRB	10$			;
40$:	PUSHL	R9			;SET NEW DEFAULT PROTECTION ARGUMENT
	CLRL	-(SP)			;ZERO ADDRESS OF RETURN DESCRIPTOR
	PUSHAL	4(SP)			;ADDRESS OF NEW PROTECTION
	CALLS	#3,@#SYS$SETDFPROT	;SET DEFAULT PROTECTION
	RSB				;
50$:	STATUS	IVPROT			;SET INVALID PROCTECTION CODE
	RSB				;
60$:	STATUS	INVKEY			;SET INVALID KEYWORD
	RSB				;
	.PAGE
	.SBTTL	SET VERIFY MODE
;+
; MCR$SETVERIFY - SET VERIFY MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET VERIFY
; MODE MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE VERIFY MODE IS ESTABLISHED.
;-
 
MCR$SETVERIFY::				;SET VERIFY MODE
	BISW	#PRC_M_VERIFY,PRC_W_FLAGS(R11) ;ASSUME VERIFICATION IS SPECIFIED
	GETDVAL				;GET OPTION DESCRIPTOR
	BLBC	R3,10$			;IF LBC VERIFICATION SPECIFIED
	BICW	#PRC_M_VERIFY,PRC_W_FLAGS(R11) ;DISABLE VERIFICATION
10$:	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;
	.PAGE
	.SBTTL	SET ON MODE
;+
; MCR$SETON - SET ON MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET ON
; MODE MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE ON MODE IS ESTABLISHED.
;-
 
MCR$SETON::				;SET ON MODE
	GETDVAL				;GET THE DESCRIPTOR FOR "ON"
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	MOVAB	PRC_W_ONLEVEL(R11),R1	;GET ADDRESS OF ON LEVEL CODE
	CMPB	#8,(R1)			;CHECK "ON" LEVEL FOR RESERVED LEVEL
	BLBS	R3,20$			;BR IF OPTION WAS NEGATED (NOON)
	BLSS	10$			;BR IF "ON" ALREADY ACTIVE
	MOVB	1(R1),(R1)		;RESET TO SAVED VALUE
10$:	RSB				;
20$:	BEQL	30$			;BR IF "ON" ALREADY AT RESEVED LEVEL
	MOVB	(R1),1(R1)		;SAVE PREVIOUS "ON" LEVEL
	MOVB	#8,(R1)			;SET TO RESERVED LEVEL
30$:	RSB				;END OF NOON HANDLING

	.PAGE
	.SBTTL	SET CONTROL ENABLE/DISABLE
;+
; MCR$SETCTLY - SET CONTROL Y ENABLE MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET CONTROL_Y
; OR SET CONTROL=Y MODE MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	CONTROL Y'S ARE ENABLED OR DISABLED FOR THIS PROCESS.
;-
 
MCR$SETCTLY::				;SET CONTROL Y MODE
	GETDVAL				;GET OPTION DESCRIPTOR
	MOVL	R3,R6			;SAVE [NO] STATUS FOR FUTURE USE

10$:	GETDVAL				;GET FIRST LETTER
	BLBC	R0,70$			;IF ABSENT, THEN ASSUME Y
	CMPB	R5,#PTR_K_QUALVALU	;MAKE SURE IT IS A QUALIFIER VALUE
	BNEQ	10$			;IF NOT GET NEXT VALUE
	BRB	30$			;VALIDATE QUALIFIER VALUE


30$:	CMPB	#1,R1			;IS PARAMETER A SINGLE LETTER?
	BNEQ	90$			;RETURN ERROR IF NOT
	CMPB	#^A/Y/,(R2)		;IS IT A "Y"?
	BNEQ	90$			;RETURN ERROR IF NOT
40$:	GETDVAL				;GET NEXT PARAMETER
	BLBC	R0,70$			;EXIT LOOP IF ALL HAVE BEEN INSPECTED
	CMPB	R5,#PTR_K_QUALVALU	;MAKE SURE IT IS A QUALIFIER VALUE
	BNEQ	40$			;IF NOT GET NEXT VALUE
	BRB	30$			;VALIDATE QUALIFIER VALUE
	
70$:	BICL	#PRC_M_NOCTLY,PRC_W_FLAGS(R11) ;ASSUME ENABLE SPECIFIED
	BLBC	R6,80$			;IF LBC, THEN ENABLE SPECIFED
	BISL	#PRC_M_NOCTLY,PRC_W_FLAGS(R11)  ;CLEAR CTRL/Y BIT IN MASK
	
80$:	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;

90$:	STATUS	INVKEY			;SET ERROR STATUS
	RSB				;
 

	.END
 

	.END
 
