	.TITLE	MCRIMGEXE - IMAGE EXECUTION MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; IMAGE EXECUTION MCR COMMAND EXECUTION
;
;	EXTERNAL COMMAND EXECUTE
;	RUN IMAGE
;
; D. N. CUTLER 4-APR-77
;
; Modified by:
;
;	V02-005	LJK0062		Lawrence J. Kenah	10-Sep-1981
;		Add call to perform activation time address relocation.
;
;	V001	TMH0001		Tim Halvorsen	01-Jun-1981
;		Change method of locating PRC area.  Remove code
;		in MCR$LOGOUT to setup the scratch stack and buffer
;		descriptor since it is now done in MCR$ABORT as well
;		as normal command dispatching.  Remove code which
;		deletes all logical names from the supervisor mode
;		logical name table, as these names may want to be
;		passed from one job step to another, and it allows
;		execution of a test version of LOGINOUT on logout.
;--

;
; MACRO LIBRARY CALLS
;
 
	$PPDDEF				;PROCESS PERMANENT DATA STORAGE
	DEFCMDWRK			;DEFINE WORK AREA OFFSETS
	DEFERRCOD			;DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			;RESULT PARSE DESCRIPTORS
	$CHFDEF				;DEFINE CONDITION ARGLIST OFFSETS
	$IHDDEF				;IMAGE HEADER DESCRIPTOR DEFINTITIONS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$CLIDEF				;DEFINE COMMAND INTERPRETER VALUES
 
	$IFDDEF				;IMAGE FILE DESCRIPTOR DEFINITIONS
	$NAMDEF				;DEFINE NAME BLOCK OFFSETS
	$STSDEF				;DEFINE STATUS LONG WORD VALUES
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
EXTDEFAULT:				;EXTERNAL COMMAND IMAGE DEFAULT STRING
	.BYTE	20$-10$			;LENGTH OF STRING
10$:	.ASCII	/SYS$SYSTEM:.EXE/		;
20$:					;REF LABEL
RUNDEFAULT:				;RUN COMMAND IMAGE DEFAULT STRING
	.BYTE	20$-10$			;LENGTH OF STRING
10$:	.ASCII	/.EXE/			;
20$:					;REF LABEL
LOGOUTIMG:				;FILENAME TEXT STRING FOR LOGOUT
	.ASCIC	\LOGINOUT\		;LOGIN/OUT IMAGE NAME
 
;
; NAMES FOR INDIRECT COMMAND FILE AND THE TERMINAL
;
 
SYSINP:	.ASCII	\SYS$INPUT\		;
	SYSINPSIZ = . - SYSINP
 
SYSCMD:	.ASCII	\SYS$COMMAND:\		;
	SYSCMDSIZ = . - SYSCMD
SYSPRINT:				;DEFAULT QUEUE LOGICAL NAME
	.ASCII	\SYS$PRINT\		;
SYSPRTSIZ = . - SYSPRINT		;SIZE OF THAT STRING

	.SBTTL	RUN IMAGE
;+
; MCR$RUN - RUN IMAGE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE RUN MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFED IMAGE IS INITIATED.
;-
 
MCR$RUN::				;RUN IMAGE
	BICW	#<PRC_M_DBGQUAL!PRC_M_DBGTRUE>,- ;CLEAR DEBUG QUALIFIER SEEN,
		PRC_W_FLAGS(R11)	;AND DEBUG QUALIFIER TRUE FLAGS.
	CLRQ	-(SP)			;MAKE A SCRATCH BUFFER
10$:	GETDVAL				;GET NEXT DESCRIPTOR VALUES
	CMPB	R5,#PTR_K_ENDLINE	;IS THIS THE END OF THE PARAMETERS?
	BEQL	30$			;BR IF YES
	CMPB	R5,#PTR_K_PARAMETR	;IS THIS THE FILE TO RUN?
	BEQL	20$			;BR IF YES
	BISW	#<PRC_M_DBGQUAL!PRC_M_DBGTRUE>,- ;SET DEBUG QAULIFIER SEEN
		PRC_W_FLAGS(R11)	;AND ASSUME QUALIFIER TRUE
	BLBC	R3,10$			;BR IF NOT NEQATED
	CLRBIT	PRC_V_DBGTRUE,PRC_W_FLAGS(R11) ;SET STATE TO FALSE
	BRB	10$			;
20$:	MOVQ	R1,(SP)			;SAVE FILE SPECIFICATION DESCRIPTOR
	BRB	10$			;LOOK FOR MORE
30$:	POPR	#^M<R1,R2>		;GET FILE SPEC OF FILE TO RUN
	MOVAB	RUNDEFAULT,R3		;GET ADDRESS OF RUN DEFAULT NAME STRING
	BRB	FORCEXIT		;

	.SBTTL	LOGOUT PROCESS
;+
; MCR$LOGOUT - LOGOUT THE PROCESS
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE LOGOUT 
; COMMAND OR TO EFFECT A LOGOUT WHEN END_OF_FILE OCCURS FOR A DETACED JOB.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE LOGOUT IMAGE IS INITIATED.
;-
 
MCR$LOGOUT::				;LOGOUT OFF THE PROCESS
;
; RUN DOWN ANY PROCEDURES OR IMAGES STILL ACTIVE
;
10$:	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	UNSTACK				;UNSTACK INDIRECT LEVEL
	BRB	10$			;
;
; ACTIVATE LOGOUT IMAGE
;
20$:	MOVL	PRC_L_LSTSTATUS(R11),-	;PASS FINAL JOB STATUS TO LOGOUT
		G^CTL$AG_CLIDATA+PPD$L_LSTSTATUS
	MOVAB	LOGOUTIMG,R2		;START OF THE COUNTED STRING
	MOVZBL	(R2)+,R1		;SET LENGTH
					;FALL INTO IMAGE EXECUTE

	.SBTTL	EXTERNAL COMMAND EXECUTION
;+
; MCR$EXTIMAGE - EXTERNAL COMMAND EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO INITIATE EXECUTION OF AN
; EXTERNAL IMAGE.
;
; INPUTS:
;
;	R1 = LENGTH OF IMAGE FILE SPECIFICATION.
;	R2 = ADDRESS OF IMAGE FILE SPECIFICATION.
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFED IMAGE IS INITIATED.
;-
 
MCR$EXTIMAGE::				;EXTERNAL COMMAND EXECUTION
	MOVAB	EXTDEFAULT,R3		;GET ADDRESS OF DEFAULT NAME STRING
	BICW	#<PRC_M_DBGQUAL!PRC_M_DBGTRUE>,- ;CLEAR DEBUG QUALIFIER SEEN,
		PRC_W_FLAGS(R11)	;AND DEBUG QUALIFIER TRUE FLAGS.

	.SBTTL	FORCE IMAGE EXIT
;
; FORCE IMAGE EXIT IF ONE IS ACTIVE
;
; INPUTS:
;
;	R1 = LENGTH OF IMAGE FILE SPECIFICATION
;	R2 = ADDRESS OF IMAGE FILE SPECIFICATION
;	R3 = ADDRESS OF COUNTED ASCII STRING FOR DEFAULT FILE NAME
;
 
FORCEXIT:				;FORCE IMAGE EXIT
	PUSHR	#^M<R1,R2,R3>		;SAVE NAME STRING PARAMETERS
	BSBW	MCR$RUNDOWN		;RUN DOWN PREVIOUS IMAGE AND INDIRECT LEVELS
	POPR	#^M<R1,R2,R3>		;RESTORE NAME STRING PARAMETERS

	.SBTTL	INITIATE IMAGE
;
; INITIATE AN IMAGE BY ENTERING USER MODE AND THEN SETTING UP THE INITIAL CALL
; FRAMES AND ESTABLISHING A CATCH-ALL CONDITION HANDLER.
;
; INPUTS:
;
;	R1 = LENGTH OF IMAGE FILE SPECIFICATION
;	R2 = ADDRESS OF IMAGE FILE SPECIFICATION
;	R3 = ADDRESS OF COUNTED ASCII STRING FOR DEFAULT FILE NAME
;
 
	.ENABL	LSB
INITIATE:				;INITIATE IMAGE
	BBSS	#PRC_V_EXIT,PRC_W_FLAGS(R11),10$ ;IF SET, EXIT HANDLER ESTABLISHED
	MOVAB	W^MCR$EXITHAND,PRC_L_EXTHND(R11) ;SET ADDRESS OF EXIT HANDLER
	MOVAB	PRC_L_EXTCOD(R11),PRC_L_EXTPRM(R11) ;SET ADDRESS OF REASON FOR EXIT
	PUSHL	R1			;REMEMBER LENGTH OF IMAGE FILE SPEC
	$DCLEXH_S PRC_L_EXTBLK(R11)	;DECLARE EXIT HANDLER
	MOVL	(SP)+,R1		;RESTORE LENGTH OF IMAGE FILE SPEC
	BLBS	R0,10$			;BRANCH IF SUCCESSFUL
	RSB				;RETURN IF ERROR
 
;
; SET UP IMAGE ADDRESS SPACE
;
 
10$:	MOVAL	@#MMG$IMGHDRBUF,R5	;ADDRESS TO RETURN IMAGE HEADER INFO
	MOVQ	R1,-(SP)		;PUT IMAGE NAME DSC ON STACK
	MOVL	SP,R1			;GET ADR OF FILNAM STRING DESCRIPTOR
	MOVZBL	(R3)+,R2		;GET SIZE OF DEFAULT NAME STRING
	MOVQ	R2,-(SP)		;PUT DEFAULT NAME DSC ON STACK
	MOVL	SP,R0			;GET ADR OF DFLTNAM STRING DESCRIPTOR
	$IMGACT_S -			;ACTIVATE THE IMAGE
		NAME=(R1),-		;ADDRESS OF FILE NAME DESCRIPTOR
		DFLNAM=(R0),-		;ADDRESS OF DEFAULT NAME DESCRIPTOR
		HDRBUF=(R5)		;ADDRESS OF IMAGE HEADER BUFFER
	BLBC	R0,11$			;BRANCH IF ACTIVATION ERROR
	ADDL	#16,SP			;CLEAN OFF IMGACT DESCRIPTORS
	BRW	30$			;AND GO ACTIVATE THE IMAGE
11$:	CLRQ	(SP)			;SET UP NULL RESULT NAME DESCRIPTOR
	MOVL	R0,R3			;SAVE STATUS
	$RUNDWN_S #PSL$C_USER		;RUN DOWN IMAGE
	CLRL	R4			;INIT NULL STV FROM FAB
	MOVL	8(R5),R5		;FAB ADDRESS OF ERROR IF ANY
	BEQL	14$			;BRANCH IF NONE PRESENT
	MOVL	FAB$L_FNA(R5),R2	;ORIGINAL FILE NAME ADDRESS
	BEQL	14$			;BRANCH IF FAB IS EMPTY
	MOVZBL	FAB$B_FNS(R5),R1	;SIZE OF ORIGINAL FILE NAME STRING
	MOVQ	R1,8(SP)		;USE THIS FOR ORIGINAL FILE NAME
	MOVL	FAB$L_STV(R5),R4	;GET FAB'S STV FIELD
	MOVL	FAB$L_NAM(R5),R0	;GET ADDRESS OF NAME BLOCK
	MOVL	NAM$L_RSA(R0),R2	;ADDRESS OF NAME STRING
	MOVZBL	NAM$B_RSL(R0),R1	;SIZE OF RESULT NAME STRING IF ANY
	BNEQ	12$			;BRANCH IF IT EXISTS
	MOVZBL	NAM$B_ESL(R0),R1	;EXPANDED NAME STRING SIZE IF ANY
	BEQL	14$			;BRANCH IF NO NAME TO OUTPUT
12$:	MOVQ	R1,(SP)			;RESULT/EXPANDED NAME STRING
14$:	MOVL	SP,R5			;R5 IS ADR OF NAME DESCRIPTORS
;
; 0(SP) = DESCRIPTOR FOR RESULT/EXPANDED FILE NAME
; 8(SP) = DESCRIPTOR FOR ORIGINAL FILE NAME
;
	MOVL	#CLI$_IMGNAME,R2	;ERROR CODE FOR 2ND MSG
	CMPL	#RMS$_FNF,R3		;IF ORIGINAL ERR IS FILE NOT FOUND
	BNEQ	16$
	CLRL	R3			;THEN 3RD MSG IS NULL
	MOVL	#CLI$_IMAGEFNF,R2	;AND 2ND IS "IMAGE FILE NOT FOUND"
;
; NOW BUILD THE PUTMSG ARGUMENT
;
16$:	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,R3,#1 ;IF THIS IS AN RMS ERROR CODE
	BNEQ	17$
	PUSHL	R4			;THEN USE SAVED STV FROM FAB
17$:	PUSHL	R3			;ERROR CODE FOR 3RD MSG
	TSTL	(R5)			;IF NO RESULT NAME STRING
	BNEQ	18$
	CMPL	#CLI$_IMGNAME,R2		;THEN SKIP THE IMAGE NAME MESSAGE
	BEQL	182$
18$:	PUSHAQ	(R5)			;ADR OF DESCRIPTOR FOR RSLT NAME
	PUSHL	#1			;ONE FAO ARGUMENT
	PUSHL	R2			;ERR CODE FOR 2ND MSG
182$:	PUSHAQ	8(R5)			;ADR OF DESCRIPTOR FOR ORIG NAME
	PUSHL	#1			;ONE FAO ARGUMENT
	PUSHL	#<SHR$_ACTIMAGE ! -	;ERR CODE FOR 1ST MSG
		<CLI$_IMGNAME & STS$M_FAC_NO>>
	SUBL3	SP,R5,-(SP)		;FORM SIZE OF ARG LIST IN BYTES
	DIVL	#4,(SP)			;ARG LIST SIZE IN LONG WORDS
;
; NOW OUTPUT THE ERROR MESSAGES
;
	MOVL	SP,R0			;ADDRESS OF PUTMSG PARAMETERS
	BSBW	MCR$PUTMSG		;CALL THE PUTMSG FACILITY
	ADDL3	#16,R5,SP		;POP ALL INFO OFF STACK
	MOVL	R3,R0			;GET ERROR CODE TO RETURN
	BNEQ	19$			;BRANCH IF THIS IS THE ONE
	MOVL	R2,R0			;ONLY 2 MESSAGES, USE THE 2ND
19$:	BBSS	#STS$V_INHIB_MSG,R0,20$	;INHIBIT ERROR MESSAGE OUTPUT
	BLBS	R0,30$			;BRANCH IF IT SUCCEEDED
	PUSHL	R0			;SAVE ERROR CODE
	$RUNDWN_S	#PSL$C_USER	;RUNDOWN ABORTED IMAGE
	POPL	R0			;GET ERROR CODE BACK
	CMPL	#RMS$_FNF,R0		;IMAGE FILE NOT FOUND?
	BNEQ	20$			;IF NEQ NO
	MOVL	#CLI$_IMGFNF,R0		;SET IMAGE FILE NOT FOUND
20$:	RSB				;RETURN WITH STATUS CODE IN R0
 
;
; RAISE ACCESS LEVEL TO USER
;
 
30$:
	MOVL	(R5),R1			;GET ADDRESS OF IMAGE HEADER
	CMPL	S^#SS$_NORMAL,R0	;IF OTHER THAN NORMAL COMPLETION
	BEQL	35$
	CMPL	#SS$_SYSVERDIF,R0	;"SYSTEM VERSION MISMATCH"?
	BNEQ	32$			;BRANCH IF NOT, JUST REPORT IT
	CMPW	#IHD$L_SYSVER,IHD$W_ACTIVOFF(R1) ;IF RELEASE 1 IMAGE
					;WITH NO SYSVER STORED IN HEADER
	BGEQ	35$			;THEN AVOID ISSUING SPURIOUS WARNING
32$:	PUSHR	#^M<R1,R5>		;SAVE REGISTERS REQUIRED BELOW
	BSBW	MCR$ERRORMSG		;PRINT ALTERNATE SUCCESS MESSAGE
	POPR	#^M<R1,R5>		;RESTORE SAVED REGISTERS
35$:
	MOVL	#CLI$_NOTFR,R0		;ASSUME NO TRANSFER ADDRESS
	BBS	#IHD$V_LNKNOTFR,-	;BRANCH IF NO TRANSFER ADDRESS
		IHD$L_LNKFLAGS(R1),20$	; AND RETURN WITH CODE IN R0
	MOVL	4(R5),R0		;IMAGE FILE DESCRIPTOR BLOCK ADDRESS

	ASSUME	IFD$V_EXEONLY+1 EQ IFD$V_PRIV
	ASSUME	PRC_V_EXEONLY+1 EQ PRC_V_PRIV
	EXTZV	#IFD$V_EXEONLY,#2,IFD$W_FLAGS(R0),R0 ;GET "EXECUTE ONLY"
					;AND "PRIVILEGED IMAGE BITS"
	INSV	R0,#PRC_V_EXEONLY,#2,PRC_B_FLAGS2(R11) ;SAVE IN PROCESS FLAGS
	MOVL	SP,WRK_L_SAVSP(FP)	;SAVE CURRENT STACK POINTER
	ASHL	#PSL$V_PRVMOD,#PSL$C_USER@2+PSL$C_USER,-(SP) ;SET USER PSL
	PUSHAB	B^50$			;SET USER PC
MCR$LOW_LIMIT::				;LOW LIMIT OF CONTROL Y/C ADDRESS RANGE
	BBC	#PRC_V_CNTRLY,PRC_W_FLAGS(R11),40$ ;IF CLR, NO AST PENDING
	BRW	MCR$SCNTRLY		;
40$:	REI				;ENTER USER MODE
MCR$HIGH_LIMIT::			;HIGH LIMIT OF CONTROL Y/C ADDRESS RANGE
 
;
; BUILD TOP LEVEL CALL FRAME
;
 
50$:	CLRQ	AP			;CLEAR INITIAL ARGUMENT AND FRAME POINTERS
	CALLS	#0,B^60$		;CONSTRUCT TOP LEVEL CALL FRAME
 
;
; ESTABLISH CATCH-ALL CONDITION HANDLER AND CALL IMAGE
;
 
60$:	.WORD	0			;ENTRY MASK
	MOVAB	@#EXE$CATCH_ALL,(FP)	;ESTABLISH CATCH-ALL HANDLER
	$SETEXV_S #2,@#EXE$CATCH_ALL	;ESTABLISH LAST CHANCE HANDLER
	$IMGFIX_S			;PERFORM ADDRESS RELOCATION
	BLBC	R0,110$
	BBS	#PRC_V_PAUSE,PRC_W_FLAGS(R11),62$ ;IF PAUSED ASSIGN INPUT TO CMD
	BBC	#MCR_V_FORCMD,PRC_W_CLIFLAG(R11),65$ ; BR IF NOT DOING FOREIGN CMD
62$:	PUSHAB	SYSCMD			;ADDRESS OF EQUIVALENCE STRING
	PUSHL	#SYSCMDSIZ		;ITS LENGTH
	PUSHAB	SYSINP			;ADDRESS OF LOGICAL NAME
	PUSHL	#SYSINPSIZ		;AND ITS SIZE
	MOVL	SP,R0			;ADDRESS OF DESCRIPTORS
	$CRELOG_S #2,(R0),8(R0)		;EQUATE INPUT TO COMMAND
	ADDL	#16,(SP)		;CLEAR THE DESCRIPTORS
65$:	MOVQ	@#MMG$IMGHDRBUF,R4	;GET IMAGE HEADER DESCRIPTOR
 
	ASSUME	CLI$V_DEBUG   EQ 0
	ASSUME	CLI$V_DBGTRU  EQ 1
	ASSUME	PRC_V_DBGTRUE EQ PRC_V_DBGQUAL+1
 
	EXTZV	#PRC_V_DBGQUAL,#2,-	;BUILD PROTOTYPE CLI OPTIONS VALUE BY
		PRC_W_FLAGS(R11),-(SP)	;GETTING THE DEBUG QUALIFIER AND STATE
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R11),70$ ;BR IF NOT A BATCH JOB
	SETBIT	CLI$V_BATCH,(SP)	;OR IN THE BATCH BIT IF THIS IS BATCH
70$:	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),80$ ;BR IF VERIFY IS CLEAR
	SETBIT	CLI$V_VERIFY,(SP)	;PROPOGATE VERIFY IF TRUE
80$:	CMPL	PRC_L_INPRAB(R11),PRC_L_INDINPRAB(R11) ;INDIRECT LEVEL ZERO?
	BEQL	90$			;IF EQL YES
	SETBIT	CLI$V_INDIRECT,(SP)	;PASS INDIRECT NON ZERO FLAG
90$:	BITB	#<CLI$M_INDIRECT!CLI$M_BATCH>,(SP) ;COMMANDS COMING FROM FILE?
	BEQL	100$			;BR IF TERMINAL JOB
	BBC	#CLI$V_VERIFY,(SP),100$	;BR IF VERIFY NOT REQUESTED
	SETBIT	CLI$V_VFYINP,(SP)	;INDICATE INPUT VERIFY IS NEEDED
100$:	PUSHL	IHD$L_LNKFLAGS(R4)	;PASS LINKTIME OPTION FLAGS
	MOVQ	R4,-(SP)		;NEXT TWO PARAMETERS IN USER FRAME
	PUSHAB	W^MCR$UTLSERV		;SET ADDRESS OF UTILITY ROUTINE DISPATCHER
	MOVZWL	IHD$W_ACTIVOFF(R4),R0	;OFFSET TO ACTIVATION DATA (TRANSFER VECTORS)
	ADDL	R4,R0			;ADDRESS OF TRANSFER VECTOR ARRAY
	PUSHAL	(R0)			;ADDRESS OF TRANSFER VECTOR ARRAY
	CALLS	#6,@(R0)+		;CALL IMAGE ENTRY POINT
110$:	JMP	G^EXE$EXIT_IMAGE	;
	.DSABL	LSB

	.SBTTL	ALLOCATE BUFFER AND BUILD DESCRIPTOR
;+
; MCR$ALLOCBUF - ALLOCATE BUFFER AND BUILD DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO ALLOCATE A MESSAGE BUFFER ON THE STACK AND BUILD
; A BUFFER DESCRIPTOR FOR THE BUFFER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	A MESSAGE BUFFER IS ALLOCATED ON THE STACK.
;
;	R2 = ADDRESS OF BUFFER DESCRIPTOR.
;
;	REGISTERS R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
MCR$ALLOCBUF::				;ALLOCATE BUFFER AND BUILD DESCRIPTOR
	POPR	#^M<R0>			;SAVE RETURN ADDRESS
	MOVAB	-MSGBUFSIZ(SP),SP	;ALLOCATE SPACE TO STORE FORMAT STRING
	PUSHAB	(SP)			;BUILD OUTPUT BUFFER DESCRIPTOR
	MOVZBL	#MSGBUFSIZ,-(SP)	;
	MOVL	SP,R2			;COPY ADDRESS OF OUTPUT BUFFER DESCRIPTOR
	JMP	(R0)			;

	.SBTTL	COMMAND INTERPRETER EXIT HANDLER
;+
; MCR$EXITHAND - COMMAND INTERPRETER EXIT HANDLER
;
; THIS ROUTINE IS ENTERED WHEN A PREVIOUSLY INITIATED IMAGE EXITS. ITS FUNC-
; TION IS TO CLEAN UP THE STACK, SHUTDOWN THE IMAGE, AND RETURN CONTROL TO THE
; ADDRESS SPECIFIED BY THE TOP LONGWORD OF THE STACK.
;
; INPUTS:
;
;	@4(AP) = REASON FOR EXIT.
;
; OUTPUTS:
;
;	THE SAVED FRAME POINTER IS RESTORED, THE STACK IS CLEANED UP, IMAGE
;	SHUT DOWN IS PERFORMED,  AND CONTROL IS RETURNED TO THE ADDRESS SPECIFIED
;	BY THE TOP LONGWORD OF THE STACK.
;
;	R0 = REASON FOR EXIT.
;-
 
	.ENTRY	MCR$EXITHAND,^M<>

	BSBW	CLI$GET_PRC		;GET ADDRESS OF PROCESS WORK AREA
	BICW	#PRC_M_EXIT,PRC_W_FLAGS(R11) ;CLEAR EXIT HANDLER ESTABLISHED
	MOVL	PRC_L_SAVFP(R11),FP	;RESTORE SAVED FRAME POINTER
	SHUTDOWN			;SHUT DOWN IMAGE
	TSTL	R2			;ANY DATA RECORDS SKIPPED?
	BEQL	10$			;IF EQL NO
	STATUS	SKPDAT			;SET SKIPPED DATA STATUS
	ERRMSG				;OUTPUT ERROR MESSAGE
10$:	BBS	#PRC_V_DBGTRUE,PRC_W_FLAGS(R11),20$ ;BR IF DEBUG WAS REQUESTED
	$RUNDWN_S  #PSL$C_USER		;RUN DOWN THE IMAGE
	BICB	#<PRC_M_EXEONLY ! PRC_M_PRIV>,PRC_B_FLAGS2(R11)
					;RESET "EXECUTE ONLY" AND
					;"PRIVILEGED" IMAGE BITS
20$:	MOVL	@4(AP),R0		;RETRIEVE REASON FOR EXIT
	MOVL	WRK_L_SAVSP(FP),SP	;RESTORE SAVED STACK POINTER
	RSB				;
 
	.END
