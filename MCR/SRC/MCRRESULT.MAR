	.TITLE	MCRRESULT	RESULT PARSE MAIN ROUTINE
	.IDENT	'V03-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:	STARLET MCR CLI
;
; ABSTRACT:	RESULT PARSE MAIN ROUTINE
;
; ENVIRONMENT:	NATIVE MODE USER CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE:  13-APR-77
;
; MODIFIED BY:
;
;	V3.002	MAJ0004		Melanie Johnson	21-Apr-1982
;		Add MCR$GETLINE routine to pass the entire command line
;		for use by the AME in the $GMCR directive.
;
;	V3.001	MAJ0003		Melanie Johnson	16-Mar-1982
;		Signal NOCLINT error and stop rather than passing status
;		when an attempt is made to call a CLINT routine.
;
;	V009	MAJ0002		Melanie Johnson	09-Feb-1982
;		Leave CLINT commented out for V3A and return the
;		fatal error status, NOCLINT, if an attempt is made
;		to call a routine in the CLINT.
;
;	V008	MAJ0001		Melanie Johnson	05-Jan-1982
;		Merge MCRRESULT and RPDCL to allow MCRRESULT to
;		reference the new command table structures and CLINT.
;
;	V007	TMH0007		Tim Halvorsen	02-Nov-1981
;		Fix access violation when handling a defaulted
;		qualifier classified as output, when there are
;		no parameters on the line.  This only happens
;		for a compiler like BASIC, which doesn't require
;		a source file parameter.
;
;	V006	PCG0001		Peter George	30-Oct-1981
;		Add CLINT callback dispatch table.
;		Add dispatch to GETLINE utility.
;
;	V005	TMH0005		Tim Halvorsen	25-Aug-1981
;		Change GETOPT to obtain option qualifier number
;		from WRK_B_CMDOPT, rather than from the first
;		qualifier in the token array.  This is because
;		old qualifier numbers are no longer kept in the
;		token array (they are zeroed) to prevent confusion.
;
;	V004	TMH0004		Tim Halvorsen	27-Apr-1981
;		Make use of routine to get address of PRC.
;
;	V003	TMH0003		Tim Halvorsen	03-Apr-1981
;		Change method of determining whether we are a
;		batch job or not.
;
;	V002	TMH0002		Tim Halvorsen	08-Jul-1980
;		Use new MDL structures.
;
;	V001	TMH0001		Tim Halvorsen	06-May-1980
;		Fix backward scan for parameter on input/output qualifier
;		so that it doesn't run off the front of the parameter limit
;		table if there are none.
;		Return default values (if any) on input/output qualifiers
;		in the request descriptor block.
;		Remove references to OPI and make maximum number of inputs
;		or outputs 8.
;		Return token descriptor of zero on errors when r5=0.
;		Fix GETCMD so that it looks for the first token on the line
;		rather than starting at the first verb qualifier (which may
;		be the last qualifier on the line).
;--

	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
	DEFCMDWRK			; DEFINE COMMAND WORK AREA
	CMDDEF				; DEFINE COMMAND DESCRIPTOR DEFINITIONS
	ENTDEF				; DEFINE ENTITY DESCRIPTOR
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	RPWDEF				; RESULT PARSE WORK DEFINITIONS
	PLMDEF				; PARAMETER LIMIT DEFINITIONS
	$CLIDEF				; CLI DEFINITIONS
	$CLIVERBDEF			; VERB TYPE CODES
	$CLIMSGDEF			; CLI MESSAGE DEFINITIONS

;
; UTILITY CALL PARAMETER OFFSETS
;
	RQDESC	=	4		; OFFSET TO REQUEST DESCRIPTOR
	RQWORK	=	8		; OFFSET TO WORK BLOCK
	RQBITS	=	12		; OFFSET TO BIT ARRAY ADDRESS
;
; INTERNAL ERROR BIT - DON'T USE R5 AS RESULT DESCRIPTOR INDEX
;
	INTERROR = 31			; BIT 31 FLAGS INTERNAL ERROR

	.PSECT	MCR$ZCODE	BYTE,RD,NOWRT

	.SBTTL	RESULT PARSE INITIAL ENTRY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS IS THE ENTRY POINT USED FOR ALL UTILITY SEVICE
;	CALL BACK REQUEST FOR SERVICE.
;
; CALLING SEQUENCE:
;
;	CALL	MCR$UTILSERV
;
; INPUT PARAMETERS:
;
;	RQDESC(AP) IS THE ADDRESS OF THE REQUEST DESCRIPTOR
;	RQWORK(AP) IS THE ADDRESS OF A WORK AREA FOR RESULT PARSE DATA
;	RQBITS(AP) IS THE ADDRESS OF A BIT ARRAY FOR INPUT/OUTPUT 
;		PARAMETER DEFINITION REQUESTS
;
; OUTPUT PARAMETERS:
;
;	THE FUNCTION IS PERFORMED, OR AN ERROR IS RETURNED
;
; COMPLETION CODES:
;
;	R0 = SUCCESS/FAILURE DEPENDING ON RESULT OF SEARCH
;
;--
	.ENTRY	MCR$UTLSERV,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
 
	MOVL	RQDESC(AP),R9		; ADDRESS OF THE REQUEST DESCRIPTOR
	CMPZV	#CLI$V_PRITYP,#CLI$S_PRITYP,-	; THIS IS A REQUEST FOR A CLINT SERVICE
		CLI$B_RQTYPE(R9),#CLI$K_CLINT
	BNEQ	3$			; BRANCH IF NO
	BRW	CLINT
3$:	CMPB	#CLI$K_CLISERV,CLI$B_RQTYPE(R9) ; THIS IS A REQUEST FOR A CLI SERVICE
	BNEQ	5$			; BR IF NO
	CHMS	CLI$W_SERVCOD(R9)	; THIS MUST BE DONE IN SUPER MODE
	BRB	RET0			; RETURN TO REQUESTOR
5$:	MOVL	RQWORK(AP),R10		; GET ADDRESS OF WORK AREA
	IFNORD	#4,RPW_L_MCRWRK(R10),10$ ; CHECK IF WORK AREA IS ACCESSABLE
	MOVL	RPW_L_MCRWRK(R10),R11	; IF YES-GET THE WORK AREA
10$:	CLRB	CLI$B_RQSTAT(R9)	; INITIAL RETURN STATUS FLAGS
	CLRQ	CLI$Q_RQDESC(R9)	; AND ZERO THE PARAMETER DESCRIPTOR
;
; FROM THIS POINT ON, R5 MUST ALWAYS CONTAIN THE TOKEN DESCRIPTOR
; OF THE CURRENT TOKEN BEING PARSED SO THAT ERROR REPORTING WORKS.
;
	MOVL	#1,R5			; SET DEFAULT RESULT PARSE INDEX
	CALLG	(AP),B^RSLTPRS		; CALL FOR ERROR FRAME
	BISL	#<CLI$_ABKEYW&^X0FFF0000>,R0 ; INCLUDE SUBSYSTEM NUMBER
	BLBS	R0,RET0			; BR IF NO ERRORS
;
; CALL ERROR ACTION ROUTINE WITH ERROR.  IF THE TOP BIT OF R0 IS SET,
; THEN R2/R3 CONTAIN THE DESCRIPTOR OF THE TOKEN IN ERROR.  IF R5 IS
; NON-ZERO, IT CONTAINS THE TOKEN INDEX OF THE TOKEN IN ERROR.
;
CALERR:	BBSC	#INTERROR,R0,10$	; BR IF THIS IS A INTERNAL ERROR
	CLRQ	R2			; PRESET TOKEN DESCRIPTOR TO NULL
	TSTL	R5			; IS TOKEN INDEX VALID?
	BLEQ	10$			; IF NOT, THEN RETURN NULL DESCRIPTOR
	GETEXTDESC			; TAKE APART DESCRIPTOR(POINT OF ERROR)
	PUSHL	R3			; SAVE POINT OF ERROR
	INCL	R5			; ADVANCE TO NEXT
	GETEXTDESC			; TAKE THAT APART
	MOVL	R3,R2			; COPY ENDING ADDRESS OF ERROR
	POPR	#^M<R3>			; GET POINT OF ERROR BACK
	SUBL	R3,R2			; FIND LENGTH OF ERROR SEGMENT
	DECL	R3			; BACKUP TO PRECEEDING TERMAINATOR
	CMPB	#PTR_K_ENDLINE,R1	; WAS ERROR AT END-OF-LINE?
	BNEQ	10$			; BR IF NO-ALL IS CORRECT
	INCL	R2			; ADJUST LENGTH FOR LAST LAST BYTE IN TOKEN
10$:	MOVQ	R2,CLI$Q_RQDESC(R9)	; SET IN DESCRIPTOR
	PUSHL	CLI$A_ERRACT(R9)	; GET USER ERROR ROUTINE ADDRESS/OFFSET
	BEQL	RET0			; BR IF NO ERROR ROUTINE
	BBS	#CLI$V_ABSADR+<CLI$B_RQFLGS*8>,(R9),20$ ; BR IF ADR IS ABSOLUTE
	ADDL	R9,(SP)			; FIND REAL ADDRESS OF ROUTINE
20$:	MOVL	(R10),R11		; SET USER CONTEXT WORD
	PUSHL	R11			; AND PASS IN ARGUMENT LIST
	BISL	#<CLI$_ABKEYW&^X0FFF0000>,R0 ; INCLUDE SUBSYSTEM NUMBER
	PUSHL	R0			; ERROR CODE IS SECOND ARGUMENT INPUT,
	PUSHL	R9			; REQUEST DESCRIPTOR IS FIRST ARGUMENT 
	CALLS	#3,@12(SP)		; GIVE THE USER CHANCE TO HANDLE ERROR
RET0:	RET				; GO BACK FROM CALL BACK
 
;
; RESULT PARSE DISPATCHER
;
 
RSLTPRS:.WORD	0			; REGISTERS ALREADY SAVED!
	EXTZV	#CLI$V_PRITYP,#CLI$S_PRITYP,- ; EXTRACT THE PRIMARY REQUEST
		CLI$B_RQTYPE(R9),R1	; FROM THE REQUEST DESCRIPTOR
	BEQL	10$			; BR IF REQUEST IS UTILITY TYPE
	EXTZV	#CLI$V_SUBTYP,#CLI$S_SUBTYP,- ; GET THE PARAMETER NUMBER
		CLI$B_RQTYPE(R9),R0	; OR SUB TYPE FOR RESULT
	CASE	R1,-			; DISPATCH ON REQUEST TYPE
		LIMIT=#CLI$K_INPSPEC,<-	;STARTING WTIH INPUT SPECIFICATION
		SETQUAL,-		; REQUEST FOR INPUT DEFINTION
		SETQUAL,-		; REQUEST FOR OUTPUT DEFINTION
		CMPPRM,-		; COMPLETED WITH PARAMETER SET
		MCR$VALCNV,-		; REQUEST FOR VALUE CONVERSION
		>
					; FALL THROUGH ON UTILITY OR ERROR
10$:	CASE	CLI$B_RQTYPE(R9),-	; DECODE UTILITY REQUEST
		LIMIT=#CLI$K_INITPRS,-	; LOW VALUE FOR CASE
		TYPE=B,<-		; TYPE OF CASE IS BYTE
		MCR$RPINIT,-		; INIT RESULT PARSE
		MCR$GETCMD,-		; GET COMMAND LINE DESCRIPTOR
		SETQUAL,-		; SET QUALIFER STATE
		MCR$GETOPT,-		; GET COMMAND OPTION
		MCR$GETLINE,-		; GET COMMAND LINE
		MCR$GETLINE,-		; ** CLISERV SPACE HOLDER **
		>
	SETSTAT	INVREQTYP		; INVALID REQUEST TYPE
	RET				; DONE WITH THIS COMMAND

;
; NOTE WHEN DISPATCHING  TO THESE BLISS ROUTINES, THE REGISTER MASK IS BEING
; SKIPPED OVER.  THEREFORE, ALL REGISTERS MUST BE PUSHED BEFORE DISPATCHING.
;
;*************Temporarily comment CLINT sections out************************
;
;CLINT:	CASE	CLI$B_RQTYPE(R9),-	; DECODE CLINT REQUEST
;		LIMIT=#CLI$K_PRESENT,-	; LOW VALUE FOR CASE
;		TYPE=B,<-		; TYPE OF CASE IS BYTE
;		MCR$PRESENT+2,-		; DETERMINE IF ENTITY PRESENT
;		MCR$GETVALUE+2,-	; GET VALUE OF ENTITY
;		MCR$ENDPARSE+2,-	; CLEAN UP AFTER PARSING COMMAND LINE
;		MCR$ENDPARSE+2,-	; PLACE HOLDER - NO ROUTINE
;		MCR$DISPATCH+2,-	; DISPATCH TO ACTION ROUTINE
;		>
;	RET				; DONE WITH THIS COMMAND
;
CLINT:	PUSHL	#CLI$_NOCLINT		; CLINT NOT IMPLEMENTED MESSAGE
	CALLS	#1,LIB$STOP		; SIGNAL IT & DIE!
	RET

	.SBTTL	ENDPRM CALLBACK
;---
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN ALL QUALIFIERS AND
;	VALUES HAVE BEEN RETRIEVED FOR A GIVEN PARAMETER.
;	A CHECK IS MADE TO ENSURE THAT ALL QUALIFIERS
;	PRESENT ON THE COMMAND LINE HAVE BEEN PROCESSED
;	BY THE UTILITY.
;
; INPUTS:
;
;	R0 = PARAMETER NUMBER TO BE TERMINATED
;	R9 = ADDRESS OF REQUEST DESCRIPTOR BLOCK
;	R10 = ADDRESS OF IMAGE LOCAL WORK AREA
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUTS:
;
;	THE REQUEST IS PROCESSED.
;---
CMPPRM:
	MOVAL	RPW_G_PRMLIM(R10)[R0],R6 ; SET ADDRESS OF PROPER LIMIT DESC
	MOVQ	#1,-(SP)		; SET SUCCESS PLUS A ZERO LONG WORD
	MOVL	SP,R8			; MARK POINT OF ERROR PARAMETERS
					; NOTE: R5 WAS ZEROED IN INITIAL ENTRY
10$:	CMPB	R5,RPW_B_STRPARM(R10)	; IS INDEX AT END COMD QUALIFIER AREA?
	BNEQ	20$			; BR IF NO
	MOVZBL	PLM_B_FSTDESC(R6),R5	; ELSE SET START OF PARAMETER AREA
	BEQL	80$			; BR IF PARAMETER IS NON-EXISTANT
20$:	CMPB	R5,PLM_B_LSTDESC(R6)	; IS INDEX OUT OF CURRENT PARAMETER?
	BGTRU	50$			; BR IF ALL DONE
	GETEXTDESC			; GET AND EXTRACT DESCRITPTOR
	ASSUME	PTR_K_PARMQUAL EQ 1	;
	ASSUME	PTR_K_COMDQUAL EQ 0	;
	CMPB	R1,#PTR_K_PARMQUAL	; ANY KIND OF QUALIFIER?
	BGTRU	40$			; IF NO BR AND CONTINUE SEARCH
	BBS	R5,RPW_G_BITS(R10),40$	; BR IF THE QUALIFIER HAS BEEN SEEN
	SETSTAT	UNPROQUAL
	CALLG	(AP),B^100$		; PROCESS ERROR CALL BACK
40$:	INCL	R5			; ADD 1 TO BUFFER INDEX
	BRB	10$			; KEEP LOOKING
50$:	MOVZBL	PLM_B_NXTDESC(R6),R5	; NEXT DESCRIPTOR TO PROCESS
	BEQL	80$			; BR IF NO PARAMETER PRESENT
	CMPB	R5,PLM_B_LSTDESC(R6)	; ALL BEEN PROCESSED
	BGTRU	55$			; BR IF YES
	SETSTAT	UNPROPARM		; UNPROCESSED PARAMETERS
	CALLG	(AP),B^100$		; GENERATE AN ERROR
55$:	MOVZBL	PLM_B_LSTDESC(R6),R5	; INDEX TO LAST DESCRIPTOR
	INCB	R5			; SET TO NEXT DESCRIPTOR INDEX
	CMPB	R5,PLM_B_TRMDESC(R6)	; IS THIS THE TERMINATOR DESCRIPTOR?
	BGEQU	80$			; BR IF YES-NOTHING MORE TO DO!
	MOVB	R5,PLM_B_NXTDESC(R6)	; SET THAT AS NEXT FOR NEXT CALLBACK
60$:	GETPARM				; FIND THE NEXT PARAMETER
	BLBC	R0,70$			; BR IF NONE REMAIN
	CMPB	R3,#PTR_K_BLANK		; CHECK IF END OF PARAMETER LIST
	BEQL	70$			; BR IF YES-SET NEW LIMIT TO HERE
	CMPB	R3,#PTR_K_COMMA		; HOW ABOUT LIST SEPARATOR?
	BNEQ	60$			; KEEP LOOKING
70$:	SUBB3	#1,R5,PLM_B_LSTDESC(R6)	; SET NEW LAST
	BISB	#CLI$M_MOREINP,-	; SET FLAG THAT MORE INPUT EXISTS
		CLI$B_RQSTAT(R9)	; INDICATE MORE DATA TO COME
	MOVB	PLM_B_NXTDESC(R6),-	; SET PREVIOUS NEXT AS
		PLM_B_FSTDESC(R6)	; AS FIRST IN THIS PARAMETER
80$:	POPR	#^M<R0,R5>		; GET STATUS AND POINT OF ERROR(IF ONE)
90$:	RET
; 
; THIS ROUTINE IS CALLED TO FACILITATE MULTIPLE ERROR
; ACTION CALLS WHEN PROCESSING THE END OF A PARAMETER SET
;
100$:	.WORD	^M<R5,R11>		; SAVE REGISTERS 5 AND 11
	PUSHR	#^M<R0,R5>		; SET ERROR AND PLACE IN THE LINE
	MOVL	(R8),R0			; GET PRVIOUS ERROR
	MOVL	4(R8),R5		; GET PREVIOUS PLACE
	MOVQ	(SP)+,(R8)		; SET THE NEW AS NEXT TO DO
	BLBS	R0,90$			; BR IF FIRST TIME THROUGH
	BRW	CALERR			; GO CALL THE UTILITY WITH ERROR

	.SBTTL	INPUT(N),OUTPUT(N),GETQUAL CALLBACKS
;---
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE HANDLES THE INPUT, OUTPUT AND GETQUAL
;	CALLBACKS TO SUPPLY AN INPUT/OUTPUT PARAMETER OR
;	PROCESS ALL QUALIFIERS ASSOCIATED WITH A GIVEN
;	PARAMETER OR VERB.
;
; INPUTS:
;
;	R0 = INPUT OR OUTPUT NUMBER (IF INPUT/OUTPUT REQUEST)
;	R9 = ADDRESS OF REQUEST DESCRIPTOR BLOCK
;	R10 = ADDRESS OF IMAGE LOCAL WORK AREA
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUTS:
;
;	THE REQUEST IS PROCESSED.
;---
SETQUAL:
	MOVL	RQBITS(AP),R8		; GET USERS BIT ARRAY
;
; RESET ALL STATUS FLAGS AND DESCRIPTORS FOR ALL QUALIFIER BLOCKS
; LINKED TO THE CALLING REQUEST DESCRIPTOR BLOCK
;
	PUSHAL	W^SCANQUAL		; SET INITIAL ADDRESS FOR QUALIFER SCAN
10$:	JSB	@(SP)+			; CO-ROUTINE LINK TO SCAN QUALIFIERS
	BLBC	R0,20$			; BR WHEN ALL ARE SCANNED
	CLRB	CLI$B_QDSTAT(R7)	; RESET ALL STATUS FLAGS
	CLRQ	CLI$Q_QDVALDESC(R7)	; SET VALUE DESCRIPTOR TO ZERO
	BRB	10$			; TRY FOR NEXT
;
; IF GETQUAL REQUEST, THEN FOR EACH QUALIFIER DESCRIPTOR BLOCK LINKED
; TO THIS REQUEST DESCRIPTOR, PROCESS THE COMMAND QUALIFIER (IF PRESENT).
;
20$:	CMPB	CLI$B_RQTYPE(R9),#CLI$K_GETQUAL ; IS THIS REQUEST FOR QUALIFER 
	BNEQ	25$			; DEFINTION ONLY- BR IF NO
	MOVB	WRK_B_VERBTYP(R11),-	; SET COMMAND GENERIC VERB TYPE INTO
		CLI$B_RQSTAT(R9)	; REQUEST DESCRIPTOR STATUS BYTE
	PROCMDQUAL			; FIND COMMAND QUALIFIER
	BRB	40$			; TAKE ACTION
;
; IF INPUT(N) OR OUTPUT(N) REQUEST, THEN FIND THE PARAMETER OR QUALIFIER
; DESCRIBING THE INPUT OR OUTPUT AND PROCESS IT.
;
25$:	BSBW	PROCIO			; PROCESS INPUT/OUTPUT DESCRIPTION
	MOVZBL	CLI$B_BITNUM(R9),R2	; GET THE PARAMETER PRESENT FLAG BIT
	BBS	#CLI$V_PARMPRS,-	; BR IF THE PARAMETER IS PRESENT
		CLI$B_RQSTAT(R9),30$	;
	CLRBIT	R2,(R8)			; INDICATE PARAMETER ABSENT
	SETSTAT	REQPRMABS		; SET REQUIRED PARAMETER ABSENT
	BBS	#CLI$V_PARMREQ,-	; BR IF PARAMETER IS REQUIRED
		CLI$B_RQFLGS(R9),140$	; 
	MOVL	CLI$A_ABSACT(R9),R1	; GET PARAMETER ABSENT ACTION ADDRESS
	BRB	120$			; JOIN COMMON ROUTINE
30$:	SETBIT	R2,(R8)			; SET PARAMETER PRESENT FLAG
;
; INITIALIZE 4 COROUTINE START ADDRESSES FOR THE FOLLOWING
; 4 PASSES THROUGH ALL OF THE QUALIFIER DESCRIPTOR BLOCKS LINKED
; TO THE REQUEST DESCRIPTOR.
;
40$:	PUSHAB	W^SCANQUAL		; SET INITIAL COROUTINE ADDRESS
	PUSHL	(SP)			; COPY COROUTINE INITIAL ADDRESS
	PUSHL	(SP)			; THREE MORE TIMES FOR
	PUSHL	(SP)			; SUBSEQUENT SCANS OF QUALIFIERS
;
; MARK ALL QUALIFIERS WITH DEFTRUE AS BEING PRESENT
;
45$:	JSB	@(SP)+			; GET NEXT QUALIFIER DESCRIPTOR
	BLBC	R0,50$			; BR WHEN SCAN IS DONE
	BBS	#CLI$V_QUALEXP,CLI$B_QDSTAT(R7),45$ ; LOOP IF FOUND EXPLICITLY
	MOVZBL	CLI$B_QDCODE(R7),R1	; GET THE INDEX INTO THE TABLE
	GETPARMQUAL			; FIND THE ASSOCIATED STRUCTURE
	BBC	#ENT_V_DEFTRUE,ENT_L_FLAGS(R2),45$ ; BR IF NOT DEFAULTED TRUE
	BISB	#CLI$M_QUALTRU,CLI$B_QDSTAT(R7) ; MARK QUALIFIER TRUE
	BSBW	MCR$SETDEFVAL		; SET UP THE DEFAULT VALUE IF THERE
	BRB	45$			; LOOK AT NEXT
;
; FOR ALL QUALIFIERS NOT PRESENT, CLEAR THE ASSOCIATED BIT IN THE BIT MASK
;
50$:	JSB	@(SP)+			; GET NEXT DESCRIPTOR
	BLBC	R0,60$			; BR WHEN NO MORE
	BBS	#CLI$V_QUALTRU,CLI$B_QDSTAT(R7),50$ ; BR IF TRUE
	BSBW	MCR$CLRSETLST		; CLEAR THE BITS
	BRB	50$			; LOOK FOR MORE FALSSE QUALIFIERS
;
; FOR ALL QUALIFIERS PRESENT, TEST/SET THE ASSOCIATED BIT IN THE BIT MASK
;
60$:	JSB	@(SP)+			; GET NEXT QUALIFIER DESCRIPTOR
	BLBC	R0,100$			; BR WHEN NO MORE
	BBC	#CLI$V_QUALTRU,CLI$B_QDSTAT(R7),60$ ; BR IF FALSE
	PUSHAB	B^60$			; SUBROUTINE RETURN ADDRESS
	BBC	#CLI$V_QUALEXP,CLI$B_QDSTAT(R7),70$ ; BR IF NOT EXPLICITLY FOUND
	BRW	MCR$TSTSETLST		; TEST THEN SET SET LIST, ETC.
70$:	BRW	MCR$SETSETLST		; ONLY SET THE SET LIST FOR DEFAULTS
;
; FOR ALL QUALIFIERS, CALL THE ASSOCIATED ACTION ROUTINE (IF ANY)
;
100$:	JSB	@(SP)+			; GET NEXT QUALIFIER DESCRIPTOR
	BLBC	R0,110$			; BR WHEN NO MORE QUALIFIERS
	BBS	#CLI$V_ALLOCCUR+<CLI$B_QDFLGS*8>,- ; IF ALL OCCURANCES IS SET
		(R7),100$		; CALL BACK ALREADY BEEN DONE
	BSBB	QUALACT			; TAKE QUALIFIER ACTION
	BRB	100$			; TRY FOR NEXT
;
; CALL THE PARAMETER PRESENT/ABSENT ACTION ROUTINE (IF ANY)
;
110$:	MOVL	CLI$A_PRSACT(R9),R1	; PRESENT ACTION ADDRESS OFFSET
120$:	BEQL	130$			; BR IF NO PARAMETER ACTION
	MOVL	R9,R0			; SET ADDRESS OF ARGUMENT TO CALL WITH
	BSBB	CALLBAK			; ISSUE CALL BACK
130$:	SETSTAT	SUCCESS			; SET GOOD RETURN
140$:	RET				; BACK TO DISPATCHER

	.SBTTL	ACTION CALLBACK SUBROUTINE
;---
;
; FUNCTIONAL DESCRIPTION:
;
;	CALL THE USER'S ACTION ROUTINE IF SPECIFIED.
;
; INPUTS:
;
;	R7 = ADDRESS OF QUALIFIER DESCRIPTOR BLOCK
;	R10 = ADDRESS OF IMAGE LOCAL WORK AREA
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
;---
	.ENABL	LSB
 
QUALACT:BBC	#CLI$V_QDEXPA,CLI$B_QDFLGS(R7),5$ ; BR IF ACTION ALWAYS DESIRED
	BBC	#CLI$V_QUALEXP,CLI$B_QDSTAT(R7),40$ ; IF NOT EXPLICIT
5$:	MOVL	CLI$A_FLSACT(R7),R1	; ASSUME QUALIFIER IS FALSE
	BBC	#CLI$V_QUALTRU,-	; BR IF THAT ASSUMPTION
		CLI$B_QDSTAT(R7),10$	; WAS CORRECT
	MOVL	CLI$A_TRUACT(R7),R1	; GET TRUE ACTION ADDRESS OFFSET
10$:	BEQL	40$			; BR IF NO ACTION ROUTINE
	MOVL	R7,R0			; ARGUMENT FOR CALL BACK

;
; ENTER HERE WITH R0 SET TO ACTION ROUTINE ADDRESS
;

CALLBAK:BBS	#CLI$V_ABSADR+<CLI$B_RQFLGS*8>,(R9),20$ ; BR IF ADR IS ABSOLUTE
	ADDL	R0,R1			; RELOCATE ADDRESS
20$:	MOVL	(R10),R11		; SET USER CONTEXT WORD
	PUSHL	R11			; PASS USER CONTEXT WORD
	PUSHAB	MCR$UTLSERV		; GIVE THE ACTION ROUTINE CALL BACK ADR
	PUSHAB	(R0)			; PASS CALLERS STRUCTURE AS ARGUMENT
	CALLS	#3,(R1)			; CALL THE ACTION ROUTINE
	MOVL	RPW_L_MCRWRK(R10),R11	; RESET THE COMMAND WORK ADDRESS
40$:	RSB				; RETURN TO MY CALLER
 
	.DSABL	LSB

	.SBTTL	SCAN QUALIFIER DESCRIPTOR LIST
;---
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS CO-ROUTINE IS USED TO SCAN THE UTILITY'S QUALIFIER
;	DESCRIPTOR BLOCKS LINKED TO THE CURRENT REQUEST DESCRIPTOR.
;	THE CALLER IS CALLED BACK ONCE FOR EACH QUALIFIER DESCRIPTOR
;	BLOCK UNTIL R0 IS RETURNED FALSE.
;
; INPUTS:
;
;	R9 = ADDRESS OF REQUEST DESCRIPTOR BLOCK
;
; OUTPUTS:
;
;	R7 = ADDRESS OF QUALIFIER DESCRIPTOR BLOCK
;	R0 = TRUE IF STILL MORE TO GO,
;	     FALSE IF NO MORE LEFT
;---
SCANQUAL:				; SCAN QUALIFIERS
	MOVL	CLI$A_QUALST(R9),R7	; GET OFFSET TO QUALIFIER LIST
	BEQL	20$			; BR IF NONE AT ALL
	BBS	#CLI$V_ABSADR+<CLI$B_RQFLGS*8>,(R9),10$ ; BR IF ADR IS ABSOLUTE
	ADDL	R9,R7			; ADJUST ADDRESS TO ABSOLUTE
10$:	SETSTAT	NORMAL			; ASSUME MORE QUALIFIERS TO PROCESS
	TSTB	(R7)			; END OF LIST
	BEQL	20$			; BR IF END OF LIST
	JSB	@(SP)+			; RETURN WITH A DESCRIPTOR
	MOVZBL	CLI$B_QDBLKSIZ(R7),R0	; GET SIZE OF DESCRIPTOR
	ADDL	R0,R7			; ADVANCE TO NEXT BLOCK
	BRB	10$			; CK IF MORE
20$:	SETSTAT	INVQUAL			; RETURN AN ERROR
RSB0:	RSB				; RETURN TO CALLER

	.SBTTL	PROCESS AN INPUT/OUTPUT REQUEST
;---
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS A GIVEN INPUT OR
;	OUTPUT FOR THE UTILITY.  THE INPUT OR OUTPUT MAY BE
;	SPECIFIED EITHER BY A PARAMETER OR QUALIFIER, DEPENDING
;	ON THE COMMAND DEFINITION.
;
; INPUTS:
;
;	R9 = ADDRESS OF REQUEST DESCRIPTOR BLOCK 
;	R10 = ADDRESS OF IMAGE LOCAL WORK AREA
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUTS:
;
;	PARMPRS BIT IS SET IF INPUT/OUTPUT IS PRESENT.
;	QUADWORD DESCRIPTOR DESCRIBES INPUT/OUTPUT SPECIFICATION.
;---
PROCIO:
	EXTZV	#CLI$V_SUBTYP,#CLI$S_SUBTYP,- ; AND THE SUB TYPE VIELD
		CLI$B_RQTYPE(R9),R0	; INTO R0
	CMPZV	#CLI$V_PRITYP,#CLI$S_PRITYP,-; CHECK THE PRIMARY REQUEST TYPE TO
		CLI$B_RQTYPE(R9),#CLI$K_OUTSPEC ; SEE IF REQUEST IS FOR OUTPUT
	BEQL	OUTPUT			; BR IF REQUEST IS FOR OUTPUT
	BRW	INPUT			; ELSE PROCESS INPUT
;
; PROCESS REQUEST FOR AN OUTPUT SPECIFICATION
;
OUTPUT:					; REQUEST ID FOR OUTPUT SPEC
	MOVL	WRK_L_PAROUT(R11),R1	; SET POINTER TO OUTPUT PARSE TABLE
	BEQL	RSB0			; BR IF NO TABLE
	CMPB	R0,(R1)+		; REQUEST IN RANGE?
	BGEQU	RSB0			; BR IF NO
;
; IF THE OUTPUT PARSE INDICATOR IS NEGATIVE, THEN SIMPLY USE
; IT AS THE NEGATED PARAMETER NUMBER BY INDEXING INTO THE PARAMETER
; LIMIT TABLE.
;
	CVTBL	(R1)[R0],R1		; GET OUTPUT PARSE INDICATOR
	CMPB	R1,#CMD_C_MAXQUALS	; PARAMETER OR QUALIFIER?
	BLSSU	10$			; BR IF OUTPUT IS DEFINED BY QUALIFIER
	BRW	95$			; ELSE IT IS A FORMAL PARAMETER
;
; LOCATE THE QUALIFIER DESCRIPTOR WHICH DESCRIBES THIS OUTPUT
;
10$:	GETQUALDESC			; FIND DESCRIPTOR FOR QUALIFIER #(R1)
;
; IF THE QUALIFIER IS DEFAULTED TRUE, SET THE OUTPUT PRESENT AND DEFAULTED.
; NOTE THAT THE PARMPRS AND PARMDEF FLAGS HAVE ALREADY BEEN PRESET FALSE.
;
	BBS	#ENT_V_DEFTRUE,ENT_L_FLAGS(R2),25$ ; BR IF DEFAULTED TRUE
	BBC	#ENT_V_BATDEF,ENT_L_FLAGS(R2),30$ ; BR IF NOT BATCH DEFAULTED
	PUSHL	R11			; SAVE WRK ADDRESS
	BSBW	CLI$GET_PRC		; GET ADDRESS OF PRC IN R11
	MOVL	R11,R0			; MOVE INTO R0
	POPL	R11			; RESTORE WRK ADDRESS
	BBC	#PRC_V_MODE,PRC_W_FLAGS(R0),30$ ;BRANCH IF NOT BATCH JOB
25$:	BISB	#CLI$M_PARMPRS!CLI$M_PARMDEF,-; SET PARAMETER PRESENT & DEFAULT
		CLI$B_RQSTAT(R9) 	; IN REQUEST STATUS BYTE
;
; IF THERE IS A DEFAULT VALUE ASSOCIATED WITH THIS QUALIFIER, THEN
; RETURN ITS DESCRIPTOR IN THE REQUEST DESCRIPTOR BLOCK.  OF COURSE,
; THIS IMPLIES THAT THE VALUE DESCRIPTOR SHOULD ONLY BE USED IF THE
; PARMPRS BIT IS SET SINCE THE VALUE WILL ALWAYS BE THERE EVEN THOUGH
; THE QUALIFIER IS NOT.
;
30$:	CVTWL	ENT_W_DEFVAL(R2),R0	; GET OFFSET TO DEFAULT VALUE
	BEQL	35$			; BRANCH IF NONE
	ADDL	R2,R0			; CALCULATE ADDRESS OF COUNTED STRING
	MOVZBL	(R0)+,CLI$Q_RQDESC(R9)	; STORE LENGTH INTO VALUE DESCRIPTOR
	MOVL	R0,CLI$Q_RQDESC+4(R9)	; AND ADDRESS
;
; LOCATE THE LAST OCCURRENCE OF THE QUALIFIER ON THE COMMAND LINE
;
35$:	CLRL	-(SP)			; MAKE SPACE FOR PARAMETER LIMIT DESC
	CLRQ	-(SP)			; SET VALUES FOR QUALIFER TO ZERO
	PUSHAB	W^MCR$FNDCMDQUAL	; SET COROUTINE ADDRESS
40$:	JSB	@(SP)+			; COROUTINE LINK
	BLBC	R0,50$			; BR IF NO MORE COMMADN QUALIFIERS
	CMPB	(R4),R1			; IS THIS THE QUALIFIER FOR THIS OUTPUT?
	BNEQ	40$			; BR IF NO
	MOVQ	R4,4(SP)		; SAVE DESCRIPTOR ADDRESS AND INDEX
	MOVL	R6,12(SP)		; SAVE PARAMETER LIMIT DESCRIPTOR
	SETBIT	R5,RPW_G_BITS(R10)	; INDICATE THAT QUALIFIER WAS USED
	BRB	40$			; LOOK FOR ANOTHER OCCURANCE
;
; SET THE PARMPRS AND PARMDEF FLAGS DEPENDING ON WHETHER THE
; QUALIFIER WAS FOUND AND WHETHER IT IS NEGATED.
;
50$:	MOVQ	(SP)+,R4		; RETREIVE PARAMETERS FOR LAST OCCURANCE
	MOVL	(SP)+,R6		; RESET PARAMETER LIMIT DESCRIPTOR
	BEQL	80$			; BR IF NOT IN COMMAND EXPLICITLY
	BICB	#CLI$M_PARMPRS!CLI$M_PARMDEF,-; CLR PARAMETER PRESENT & DEFAULT
		CLI$B_RQSTAT(R9) 	; IN REQUEST STATUS BYTE
	BBS	#PTR_V_NEGATE,(R4),80$ ; BR IF ASSUMED CORRECTLY
	BISB	#CLI$M_PARMPRS,CLI$B_RQSTAT(R9) ; SET EXPLICITLY PRESENT
;
; IF THERE IS A VALUE ON THE QUALIFIER, USE THAT VALUE
;
	TSTL	(R4)+			; ADVANCE POINTER TO NEXT DESCRIPTOR
	EXTRSLDESC			; TAKE DESCRIPTOR APART
	CMPB	R1,#PTR_K_QUALVALU	; IS THIS A QUALIFIER VALUE?
	BEQL	70$			; BR IF FILENAME HERE AS QUALIFIER VALUE
;
; USE THE FILE SPECIFICATION ON THE PARAMETER FOR THIS QUALIFIER
; REMOVING THE FILE TYPE AND VERSION
;
60$:	DECL	R5			; BACKUP IN RESULT PARSE DECSRIPTOR
	BLEQ	80$			; BRANCH IF NO PREVIOUS PARAMETERS
	CMPB	R5,PLM_B_FSTDESC(R6)	; IS THIS IN THE CURRENT PARAMETER
	BLSS	80$			; BR IF NO - NO MORE TO CHECK
	GETEXTDESC			; TAKE THAT DESCRIPTOR APART
	CMPB	R1,#PTR_K_PARAMETR	; WAS THIS A PARAMETER?
	BNEQ	60$			; BR IF NO
	LOCC	#^A/]/,R2,(R3)		; IS THERE A DIRECTORY SPEC HERE
	BNEQ	65$			; BR IF YES
	LOCC	#^A/>/,R2,(R3)		; CHECK FOR ALTERNATE SYNTAX
	BNEQ	65$			; BR IF THAT TYPE IS HERE
	MOVQ	R2,R0			; SET LIMITS FOR SEARCH FOR TYPE
65$:	LOCC	#^A/./,R0,(R1)		; TRY TO FIND TYPE FIELD
	SUBL	R0,R2			; ADJUST LENGTH FOR FILE TYPE
70$:	MOVQ	R2,CLI$Q_RQDESC(R9)	; SET RETURNED VALUE FOR NAME
;
; IF THE INPUT/OUTPUT WAS FOUND, THEN PROCESS ALL QUALIFIERS
; ASSOCIATED WITH THE PARAMETER ON WHICH IT WAS FOUND.
;
80$:	BBC	#CLI$V_PARMPRS,CLI$B_RQSTAT(R9),90$ ; BR IF PARAMETER NOT HERE
	PROCMDQUAL			; PROCESS COMMAND QUALIFIERS
;
; IF THE STRING DESCRIPTOR IS STILL NOT BEEN FILLED DESCRIBING
; THE OUTPUT SPECIFICATION, THEN TAKE THE PARAMETER MINUS THE
; FILE TYPE AND VERSION AND USE IT.
;
	BBS	#CLI$V_EXPNAM,CLI$B_RQFLGS(R9),90$ ; BR IF EXPLICIT NAMES ONLY
	TSTW	CLI$W_RQSIZE(R9)	; NAME FOUND FOR THIS PARAMETER?
	BNEQ	90$			; BR IF YES
	MOVAL	RPW_G_PRMLIM(R10),R6	; POINT AT FIRST LIMIT DESCRIPTOR
	MOVZBL	PLM_B_FSTDESC(R6),R5	; INDEX TO FIRST PARAMETER
	BEQL	90$			; BRANCH IF NO PARAMETER PRESENT
	SETDESCADR			; SET ADDRESS OF DESCRIPTOR IN R4
	EXTRSLDESC			; TAKE THE DESCRIPTOR A PART
	LOCC	#^A/]/,R2,(R3)		; LOOK FOR A DIRECTORY SPEC
	BNEQ	84$			; BR IF FOUND A DIRECTORY
	LOCC	#^A/>/,R2,(R3)		; IF NO LOOK FOR THE OTHER DIRECTORY END
	BNEQ	84$			; BR IF THAT DIRECTORY WAS FOUND
	LOCC	#^A/:/,R2,(R3)		; NOW LOOK FOR DEVICE NAME
	BEQL	86$			; BR IF NO DEVICE NAME HERE
	CLRQ	-(SP)			; MAKE A QUADWORD BUFFER
82$:	MOVQ	R0,(SP)			; SAVE LAST COLON WAS FOUND
	INCL	R1			; ADVANCE ADDRESS OVER THAT COLON
	DECL	R0			; SUBTRACT 1 FROM COUNT FOR THE COLON
	LOCC	#^A/:/,R0,(R1)		; LOOK FOR MORE COLONS
	BNEQ	82$			; BR IF MORE COLONS HERE
	POPR	#^M<R0,R1>		; GET ADDRESS OF LENGTH FOR LAST COLON
84$:	MOVAB	-1(R0),R2		; SET LENGTH MINUS THE TERMINATOR
	MOVAB	1(R1),R3		; AND ADDRESS BEYOND THE TERMINATOR
86$:	LOCC	#^A/./,R2,(R3)		; LOOK FOR A TYPE FIELD
	BNEQ	88$			; BR IF TYPE FIELD PRESENT
	LOCC	#^A/;/,R2,(R3)		; NOW LOOK FOR EXPLICIT VERSION
88$:	SUBL	R0,R2			; ALSO REMOVE THAT IF FOUND
	MOVQ	R2,CLI$Q_RQDESC(R9)	; SET SIZE AND ADDRESS OF DESCRIPTOR
90$:	RSB				; RETURN TO DISPATCHER

;
; COME HERE WHEN OUTPUT IS DEFINED BY A NEGATED PARAMETER NUMBER
;

95$:	MCOML	R1,R0			; GET POSITIVE OUTPUT NUMBER - 1
					; BASED AT ZERO (P1=0)

;
; COME HERE WHEN INPUT IS REQUESTED (MUST BE A PARAMETER)
;

INPUT:	MOVAL	RPW_G_PRMLIM(R10)[R0],R6; GET ADDRESS OF PARAMETER LIMIT ENTRY

;
; RETURN THE VALUE OF THE PARAMETER DESCRIBED BY THE PARAMETER
; LIMIT MARKER POINTED TO BY R6.  ALSO, PROCESS ALL QUALIFIERS
; ASSOCIATED WITH THE PARAMETER.
;

	EXTNXTDESC			; TAKE NEXT DESCRIPTOR APART
	BLBC	R0,90$			; ALL DONE
	MOVQ	R2,CLI$Q_RQDESC(R9)	; SAVE ADDRESS OF PARAMETER
	BISB	#CLI$M_PARMPRS,-	; SET FLAG THAT PARAMETER IS PRESENT
		CLI$B_RQSTAT(R9)	; IN USERS REQUEST STATUS BYTE
	PUSHL	R6			; SAVE PARAMETER DESCRIPTOR POINTER
	PROCMDQUAL			; TAKE CARE OF COMMAND QUALIFIERS
	POPL	R6			; RESTORE PARM LIMIT DESCRITPTOR POINTER
10$:	EXTNXTDESC			; TAKE THE NEXT DESCRIPTOR APART
	BLBC	R0,90$			; BR IF NO MORE
	CMPB	R1,#PTR_K_PARMQUAL	; IS THIS A PARAMETER QUALIFIER
	BNEQ	30$			; BR IF NO
	PUSHAB	SCANQUAL		; SET INITIAL COROUTINE ADDRESS
20$:	JSB	@(SP)+			; GET NEXT DESCRIPTOR
	BLBC	R0,RET1			; NO FIND IS AN ERROR
	CMPB	(R4),CLI$B_QDCODE(R7)	; IS THIS THE QUALIFIER DESCRIPTOR?
	BNEQ	20$			; IF NO LOOK AT NEXT
	TSTL	(SP)+			; CLEAR COROUTINE ADDRESS
	BSBW	MCR$HANDLQUAL		; SET UP QUALIFER RESULT PARSE DATA
	BRB	10$			; CHECK FOR MORE
30$:	CMPB	R1,#PTR_K_PARAMETR	; THE NEXT PARAMETER
	BNEQ	10$			; BR IF NO
	DECB	PLM_B_NXTDESC(R6)	; BACK UP INDEX FOR NEXT RESULT PARSE
	CMPB	PLM_B_NXTDESC(R6),-	; CHECK IF NEXT IS LEQ LAST,
		PLM_B_LSTDESC(R6)	; IN THE CURRENT PARAMETER
	BGTRU	90$			; IF GTRU, NO MORE ELEMEMTS IN THIS SET
	BISB	#CLI$M_CONCATINP,-	; SET FLAG TO SAY CONCATONATED INPUT
		CLI$B_RQSTAT(R9)	; LIST IS NO EXHAUSTED.
90$:	RSB				; BACK TO I/O PROCESSOR
RET1:	RET

	.SBTTL	VALUE CONVERSION ROUTINES
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE UTILITY HAS REQUESTED
;	A QUALIFIER VALUE CONVERSION.
;
; CALLING SEQUENCE:
;
;	ENTERED VIA A CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R9 = ADDRESS OF REQUEST DESCRIPTOR FOR VALUE CONVERSION
;	R10 = ADDRESS OF IMAGE LOCAL WORK AREA
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	VALUE IS CONVERTED AND STRING DESCRIPTOR IN QUALFIER DESCRIPTOR
;	IS UPDATED TO DESCRIBE THE REMAINING VALUE-IF ANY.
;
; COMPLETION CODES:
;
;	MCR$NORMAL FOR SUCCESSFUL CONVERSION
;	MCR$VALCNVERR FOR CONVERSION ERROR
;	MCR$NOVALUE IF VALUE NOT PRESENT
;
;--
 
MCR$VALCNV:				; REQUEST FOR VALUE CONVERSION
	MOVL	12(AP),R7		; GET QUALIFIER DESCRIPTOR
	SETINTR	NOVALUE			; ASSUME NO VALUE PRESENT
	MOVQ	CLI$Q_QDVALDESC(R7),R2	; COPY QUALIFIER VALUE STRING DESCRITOR
	BEQL	40$			; BR IF NO VALUE
	CLRQ	-(SP)			; ASSUME NOT CONVERTING DEFAULT VALUE
	MOVL	R3,R5			; COPY ADDRESS OF STRING
	MOVAL	WRK_G_BUFFER(R11),R4	; BASE ADDRESS OF BUFFER
	SUBL	R4,R5			; FIND BYTE OFFSET INTO BUFFER
	MOVAL	WRK_G_RESULT(R11),R4	; RESULT PARSE BUFFER
	MOVAL	-4(R4),R1		; SET INDEX BASE INTO RESULT BUFFER
10$:	CMPZV	#PTR_V_OFFSET,#PTR_S_OFFSET,-
		(R4),R5			; IS THIS THE DESCRIPTOR?
	BNEQ	20$			; BR IF FOUND THE DESCRIPTOR
	SUBL3	R1,R4,R5		; FIND BYTE OFFSET TO DESCRIPTOR
	DIVL	#4,R5			; NOW LONGWORD INDEX INTO RESULT BUFFER
	EXTRSLDESC			; TAKE RESULT DESCRIPTOR APART
	BRB	30$			; PROCESS THE REQUEST WITH USER VALUE
20$:	TSTL	(R4)+			; ADVANCE TO NEXT DESCRIPTOR
	CMPL	R4,WRK_L_RSLNXT(R11)	; IS THIS THE LAST DESCRIPTOR?
	BLSSU	10$			; BR IF NO
	SETBIT	#31,(SP)		; SET FLAG FOR INTERNAL VALUE
	LOCC	#^A/,/,R2,(R3)		; CHECK FOR MULTIPLE VALUES
	BEQL	30$			; BR IF LAST VALUE VALUES
	SUBL	R0,R2			; FIND LENGTH OF CURRENT VALUE
	SUBW3	#1,R0,(SP)		; SET REMAINING LENTH
	ADDL3	R2,R3,4(SP)		; FIND ADDRESS OF COMMA
	INCL	4(SP)			; PLUS 1 TO START OF REAL VALUE
30$:	CASE	CLI$B_RQTYPE(R9),-	; DECODE REQUEST TYPE
		TYPE=B,-		; CASE ON A BYTE
		LIMIT=#CLI$K_NUMERVAL,<-; LOWEST REQUEST FOR VALUE LEGAL
		50$,-			; NUMERIC CONVERSION
		100$,-			; ASCII VALUE
		>
	SETSTAT	INVREQTYP		; INCORRECT VALUE
40$:	RET				; EXIT CONVERSION
50$:	BSBW	MCR$CNVNUMDEC		; CONVERT NUMERIC-DEFAULT RADIX=DECIMAL
	BNEQ	70$			; IF NOT EQUAL - CONVERSION ERROR
	MOVL	R1,CLI$L_RQVALU(R9)	; SET RESULTANT VALUE
	BRB	120$			; EXIT CONVERSION
70$:	SETSTAT	VALCNVERR		; SET ERROR
	CLRW	(SP)			; ZERO ANY BYTE COUNT HERE IF ANY
	BISL	(SP),R0			; INCLUDE INTERNAL BIT IF THERE
	RET				; RETURN TO DISPATCHER
 
;
; REQUEST ASCII STRING VALUE
;
 
100$:	MOVQ	R2,CLI$Q_RQDESC(R9)	; SET ADDRESS AND SIZE OUTPUT VALUE
	CMPB	#^A/:/,(R2)[R3]		; CHECK FOR KEY VALUE
	BEQL	120$			; BR IF NONE LEFT IN MATCH
	BISB	#CLI$M_KEYVALU,CLI$B_RQSTAT(R9) ; INDICATE SUBVALUE FOLLOWING
120$:	MOVQ	(SP)+,CLI$Q_QDVALDESC(R7) ; GET DEFAULT VALUE INFORMATION BACK
	BBSC	#31,CLI$Q_QDVALDESC(R7),140$ ; BR IF DOING DEFAULT VALUE
	BSBW	MCR$SETQUALVAL		; SET UP DESCRIPTOR FOR REMAINING VALUE
140$:	MOVQ	CLI$Q_QDVALDESC(R7),R2	; GET REMAINING VALUE
	BEQL	150$			; BR IF THERE IS NONE
	BISB	#CLI$M_MOREVALS,CLI$B_RQSTAT(R9) ; SET FLAG TO INDICATE MORE
	SETINTR	ILLVAL			; ASSUME THAT NO MORE ALLOWED
	BBS	#CLI$V_LASTVAL,CLI$B_RQFLGS(R9),RET2 ; BR IF ERROR
150$:	SETSTAT	SUCCESS			; INDICATE GOOD STATUS
RET2:	RET				; ALL DONE

	.SBTTL	PROCESS BIT LISTS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES ARE CALLED TO PROCESS THE BIT LISTS SUPPLIED
;	WITH A PARAMETER QUALIFIER. THERE ARE 3 LISTS, THE TEST,SET
;	AND CLEAR LISTS.  THE TEST LIST IS INTENDED TO DETECT CONFLICTING
;	QUALIFIERS AND IS TESTED ONLY WHEN THE QUALIFIER IS FOUND
;	EXPLICITLY TRUE IN THE COMMAND.  THE SET LIST IS SET WHEN THE
;	QUALIFIER IS FOUND TO BE TRUE,CLEARED WHEN THE QUALIFIER IS
;	FOUND TO BE FALSE. THE CLEAR LIST INDICATES A SET OF BITS THAT 
;	SHOULD BE CLEARED IF THE QUALFIER IS TRUE.  THIS PERMITS
;	THE PRESENTS OF A QUALIFIER TO OVERRIDE THE PRESENTS OF
;	ANOTHER.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	MCR$SETSETLST		; SET THE SET LIST, CLEAR THE CLEAR LIST
;	BSB/JSB	MCR$CLRSETLST		; CLEAR THE SET LIST, SET THE CLEAR LIST
;	BSB/JSB	MCR$TSTSETLST		; TEST THE TEST LIST, THEN DO SETSETLST
;
; INPUT PARAMETERS:
;
;	R7 CONTAINS THE ADDRESS OF THE PROPER QUALIFIER DESCRIPTOR
;	R8 = ADDRESS OF UTILITY BIT ARRAY
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R10 = ADDRESS OF WORK BLOCK
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	THE BITS ARE SET/CLEARED
;
; SIDE EFFECTS:
;
;	TOP LEVEL ERROR IS ISSUED IF BIT TEST FAILURE
;--
	.ENABL	LSB
 
MCR$TSTSETLST::				; TEST THE TEST LIST, THEN DO SET LIST
	MOVAB	CLI$C_QDBITS(R7),R2	; GET ADDRESS OF BIT TEST LIST
	BBC	#CLI$V_QDUSRV,CLI$B_QDFLGS(R7),5$ ; BR IF NO USER CONTEX VALUE
	TSTL	(R2)+			; SKIP OVER THE USERS VALUE
5$:	MOVZBL	(R2)+,R1		; GET COUNT OF BITS TO TEST
	BEQL	MCR$SETSETLST		; GO SET THE BITS
10$:	MOVZBL	(R2)+,R3		; GET BIT NUMBER
	BBS	R3,(R8),100$		; TAKE ERROR EXIT
	SOBGTR	R1,10$			; BR IF MORE TO DO
 
MCR$SETSETLST::				; SET THE SET LIST
	MOVL	#1,R0			; SET A TRUE INDICATOR
	BSBB	50$			; PROCESS SET LIST
	CLRL	R0			; NOW A FALSE
	BRB	60$			; AND DO CLEAR LIST
 
MCR$CLRSETLST::				; CLEAR THE SET LIST
	CLRL	R0			; GET A FALSE
;	BSBB	50$			; CLEAR THE SET LIST
;	INCL	R0			; NOW TRUE
;	BRB	60$			; SET THE CLEAR LIST
 
50$:	MOVAB	CLI$C_QDBITS(R7),R2	; GET ADDRESS OF TEST LIST
	BBC	#CLI$V_QDUSRV,CLI$B_QDFLGS(R7),55$ ; BR IF NO USER VALUE PRESENT
	TSTL	(R2)+			; SKIP USER CONTEX LONGWORD
55$:	MOVZBL	(R2)+,R1		; GET COUNT OF TEST LIST
	ADDL	R1,R2			; AND SKIP OVER THE LIST
60$:	MOVZBL	(R2)+,R1		; GET COUNT OF SET LIST
	BEQL	90$			; BR IF NONE
70$:	MOVZBL	(R2)+,R3		; GET A BIT
	SETBIT	R3,(R8)			; SET THE BIT
	BLBS	R0,80$			; BR IF THAT WAS THE CORRECT ACTION
	CLRBIT	R3,(R8)			; ELSE CLEAR IT
80$:	SOBGTR	R1,70$			; DO ALL BITS
90$:	RSB				; RETURN
;
; COME HERE WHEN A CONFLICTING QUALIFIER IS FOUND.
; SET ERROR RETURN STRING INFO TO POINT AT THE QUALIFIER
;
 
100$:	CLRL	R5			; INIT FOR SEARCH
110$:	INCL	R5			; INCREASE INDEX BY 1
	GETEXTDESC			; THAT THE DESCRIPTOR APART
	ASSUME	PTR_K_COMDQUAL EQ 0	;
	ASSUME	PTR_K_PARMQUAL EQ 1	;
	CMPL	R1,#PTR_K_PARMQUAL	; IS THIS A QUALIFIER
	BGTRU	110$			; BR IF NO
	CMPB	CLI$B_QDCODE(R7),R2	; IS IT THE ONE THAT CONFLICTED?
	BNEQ	110$			; BR IF NO
	SETSTAT	CONFQUAL		; SET ERROR TO CONFLICTING QUALIFERS
	RET				; REPORT THE ERROR
 
	.DSABL	LSB

	.SBTTL	PROCESS ALL QUALIFIERS IN QUALIFIER LIST
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A PARAMETER HAS BEEN FOUND PRESENT
;	IN THE COMMAND. THIS ROUTINE SEARCHED FOR ANY COMMAND QUALIFIERS
;	PRESENT ITN THE RANGE OF THE COMMAND, WHERE THE RANGE OF THE
;	COMMAND IS DEFINED AS ON THE VERB, OR WITHIN THE CURRENT LIMITS
;	OF ANY COMMAND PARAMETERS.  ONLY QUALIFIERS EXPLICITLY REQUESTED
;	ARE PROCESSED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	MCR$PROCMDQUAL
;
; INPUT PARAMETERS:
;
;	R8 = ADDRESS OF UTILITY BIT ARRAY
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R10 = ADDRESS OF WORK BLOCK
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	ALL QUALIFIERS SPECIFIED BY THE UTILITY, AND PRESENT ARE PROCESSED.
;
;--
 
MCR$PROCMDQUAL::			; PROCESS COMMAND QUALIFIERS
	PUSHAB	W^MCR$FNDCMDQUAL	; INIT COROUTINE
10$:	JSB	@(SP)+			; FIND NEXT QUALIFIER IN COMMAND
	BLBC	R0,80$			; BR IF NO MORE
	PUSHAB	W^SCANQUAL		; SCAN THE UTILITIES QUALIFIERS
20$:	JSB	@(SP)+			; FIND NEXT QUALIFIER DESCRIPTOR BLOCK
	BLBC	R0,10$			; BR IF NO MORE UTILITY DESCRIPTORS
	CMPB	CLI$B_QDCODE(R7),(R4)	; MATCH UTILITY CODE?
	BNEQ	20$			; BR IF NO-CKECK UTILITIES NEXT DESCPTR
	TSTL	(SP)+			; CLR QUAL DESC SCAN COROUTINE
	PUSHR	#^M<R4,R5,R6>		; SAVE INFO USED BY COROUTINE
	BBS	#CLI$V_ALLOCCUR+<CLI$B_QDFLGS*8>,- ; BR IF UTILITY WANTS TO SEE
		(R7),60$		; ALL OCCURANCES OF THIS QUALIFIER
	SETBIT	R5,RPW_G_BITS(R10)	; INDICATE QUALIFIER PROCESSED
	PUSHL	12(SP)			; COPY COROUTINE ADDRESS
30$:	JSB	@(SP)+			; CONTINUE SCAN FOR THIS QUALIFIER
	BLBC	R0,40$			; BR IF NO MORE OCCURANCES
	CMPB	CLI$B_QDCODE(R7),(R4)	; IS THIS THE SAME QUALIFIER?
	BNEQ	30$			; IF NO LOOK SOME MORE
	POPR	#^M<R0,R4,R5,R6>	; POP RETURN ADDRESS PLUS PARAMETERS
	BRB	10$			; PROCESS THIS WHEN WE FIND IT AGAIN
40$:	MOVQ	(SP),R4			; SET THE VALUE OF QUALIFIER DESCRIPTOR
60$:	BSBB	MCR$HANDLQUAL		; HANDLE THE QUALIFIER
	POPR	#^M<R4,R5,R6>		; RESTORE INFO USED BY COROUTINE
	BBC	#CLI$V_ALLOCCUR+<CLI$B_RQFLGS*8>,(R7),10$ ; DOING ALL OCCURANCES
	BSBW	QUALACT			; IF YES TAKE ACTION AT THIS TIME
	BRB	10$			; LOOK FOR MORE
80$:	RSB				;

	.SBTTL	PROCESS QUALIFIER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS A QUALIFIER FOUND IN THE
;	COMMAND LINE, AND SET ALL UTILITY STRUCTURES CORRECTLY.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	MCR$HANDLQUAL
;
; INPUT PARAMETERS:
;
;	R4 CONTAINS THE ADDRESS OF THE RESULT PARSE DESCRIPTOR FOR THE QUALIFIER
;	R5 IS INDEX TO THE RESULT DESCRIPTOR FOR THE QUALFIER
;	R7 CONTAINS THE ADDRESS OF THE UTILITY QUALIFIER DESCRIPTOR
;
; IMPLICIT INPUTS:
;
;	R8 = ADDRESS OF UTILITY BIT ARRAY
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R10 = ADDRESS OF WORK BLOCK
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	UTILITY QUALIFER DATA STRUTURE IS SET PROPERLY
;
;--
	.ENABL	LSB

MCR$HANDLQUAL::				; PROCESS A QUALIFIER
	CLRQ	CLI$Q_QDVALDESC(R7)	; SET VALUE TO NONE
	SETBIT	R5,RPW_G_BITS(R10)	; COUNT THIS QUALIFIER AS PROCESSED
	BISB	#CLI$M_QUALEXP,-	; SET FLAG TO INDICATE QUALIFIER WAS
		CLI$B_QDSTAT(R7)	; EXPLICITLY FOUND
	BICB	#CLI$M_QUALTRU,CLI$B_QDSTAT(R7) ; AND SET STATE TO FALSE
	BBS	#PTR_V_NEGATE,-		; BR IF THE ASSUMED STATE,FALSE,
		PTR_L_DESCR(R4),40$	; BR IF ASSUMED CORRECTLY
	BISB	#CLI$M_QUALTRU,-	; ASSUMED INCORRECTLY, SET STATE OF
		CLI$B_QDSTAT(R7)	; QUALIFIER TO TRUE
	CMPZV	#PTR_V_TERM,#PTR_S_TERM,- ; TERMINATOR VIELD LIMITS
		PTR_L_DESCR(R4),#PTR_K_COLON ; EXPLICIT VALUE GIVEN?
	BEQL	MCR$SETQUALVAL		; BR IF YES, SET USER SPECIFIED VALUE
	CMPZV	#PTR_V_TERM,#PTR_S_TERM,- ; TERMINATOR VIELD LIMITS
		PTR_L_DESCR(R4),#PTR_K_LPAREN ; EXPLICIT VALUE GIVEN?
	BNEQ	70$			; BR IF N0, SET DEFAULT IF THERE IS ONE
; DROP THRU TO RETURN EXPLICIT OR DEFAULT VALUE (IF ANY)

	.SBTTL	RETURN EXPLICIT QUALIFIER VALUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SET THE STRING LIMITS OF
;	A EXPLICIT VALUE ENTERED VIA THE COMMAND STREAM.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	MCR$SETQUALVAL
;
; INPUT PARAMETERS:
;
;	R5 IS INDEX TO THE RESULT DESCRIPTOR FOR THE QUALFIER OR LAST VALUE
;	R7 CONTAINS THE ADDRESS OF THE UTILITY QUALIFIER DESCRIPTOR
;
; IMPLICIT INPUTS:
;
;	R8 = ADDRESS OF UTILITY BIT ARRAY
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R10 = ADDRESS OF WORK BLOCK
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	UTILITY QUALIFER DATA STRUTURE IS SET PROPERLY
;
;---
MCR$SETQUALVAL:				; SET QUALIFIER VALUE ONLY
	CLRQ	CLI$Q_QDVALDESC(R7)	; ASSUME NO VALUE PRESENT
	INCL	R5			; ADV INDEX TO NEXT RESULT DESCRIPTOR
	GETEXTDESC			; TAKE THAT 1 APART
	CMPB	R1,#PTR_K_QUALVALU	; WAS THIS A VALUE?
	BNEQ	40$			; BR IF NO
	PUSHR	#^M<R2,R3>		; SET CURRENT LIMIT VALUES
	BRB	20$			; JOIN COMMON LOOP
10$:	INCL	R5			; ADD 1 TO INDEX INTO RESULT BUFFER
	GETEXTDESC			; TAKE THE DESCRIPTOR APART
	CMPB	R1,#PTR_K_QUALVALU	; LAST VALUE IN LIST?
	BNEQ	30$			; BR IF YES-EXIT THE LOOP
20$:	ADDL3	R2,R3,(SP)		; FIND END OF LAST VALUE
	BRB	10$			; LOOK FOR MORE
30$:	POPR	#^M<R2,R3>		; GET VALUE LIMITS BACK
	SUBL	R3,R2			; CHANGE TO LENGTH
	MOVQ	R2,CLI$Q_QDVALDESC(R7)	; SET VALUE
40$:	RSB				; PROCESS BIT LISTS-RETURN FROM THERE
 
70$:	CMPB	(R9),#CLI$K_GETOPT	; IS THIS AN OPTIONS PARSE
	BEQL	80$			; BR IF SO - NO DEFAULT VALUES THEN
	MOVZBL	(R4),R1			; GET QUALIFIER NUMBER
	GETPARMQUAL			; LOCATE ASSOCIATED QUALIFER BLOCK
; DROP THRU TO RETURN THE QUALIFIER DEFAULT VALUE (IF ANY)

	.SBTTL	RETURN QUALIFIER DEFAULT VALUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SET THE STRING LIMITS FOR
;	A DEFAULT VALUE ASSOCIATED WITH A QUALIFER THAT IS TRUE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	MCR$SETDEFVAL
;
; INPUT PARAMETERS:
;
;	R2 CONTAINS THE ADDRESS OF MCR INTERNAL QUALIFER DESCRIPTOR
;	R7 CONTAINS THE ADDRESS OF THE UTILITY QUALIFIER DESCRIPTOR
;
; IMPLICIT INPUTS:
;
;	R8 = ADDRESS OF UTILITY BIT ARRAY
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R10 = ADDRESS OF WORK BLOCK
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	UTILITY QUALIFER DATA STRUTURE IS SET PROPERLY
;
;---
MCR$SETDEFVAL:				; RETURN QUALIFER DEFAULT VALUE
	CVTWL	ENT_W_DEFVAL(R2),R0	; GET OFFSET TO DEFAULT VALUE STRING
	BEQL	80$			; BR IF NO DEFAULT VALUE
	ADDL	R2,R0			; FIND REAL ADDRESS OF DEFAULT VALUE
	MOVZBW	(R0)+,CLI$W_QDVALSIZ(R7) ; SET SIZE OF VALUE STRING
	MOVL	R0,CLI$A_QDVALADR(R7)	; AND THE ADDRESS OF THE STRING
80$:	RSB				; RETURN FROM DEFAULT VALUE PROCESSING
 
	.DSABL	LSB

	.SBTTL	GET OPTION VALUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	AN OPTION IS A MCR COMMAND PARAMETER THAT IS MADE TO
;	APPEAR AS A QUALIFIER.  THIS ROUTINE IS CALLED BY
;	AN IMAGE THAT HAS SEVERAL OPTIONS TO PROCESS AND WOULD
;	LIKE TO BE TOLD WHICH IT IS TO DO.  OPTIONS APPEAR IN
;	THE RESULT PARSE BUFFER AS THE FIRST ENTRY AND AS
;	PARAMETER QUALIFIER.  THE ONLY OUTPUT OF THIS ROUTINE
;	IS THE EXECUTION OF THE ACTION ROUTINE FOR THE OPTION.
;	FAILURE TO SPECIFY ACTION ROUTINES FOR OPTIONS RESULTS
;	IN CAUSING THIS CALL BACK TO BE A NO-OP.
;
; CALLING SEQUENCE:
;
;	ENTERED VIA A CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R9 = ADDRESS OF REQUEST DESCRIPTOR FOR VALUE CONVERSION
;	R10 = ADDRESS OF IMAGE LOCAL WORK AREA
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	THE OPTION QUALIFER ACTION ROUTINE IS EXECUTED FOR THE QUALIFIER
;	THAT MATCHES THE CODE.
;
; COMPLETION CODES:
;
;	MCR$INVQUAL IF NO MATCH ON THE QUALIFIER CODE
;	    ELSE AS SET BY THE OPTION ACTION ROUTINE.
;
;--
MCR$GETOPT:				; FIND COMMAND OPTION
	SETSTAT	<NOOPTPRS>		; ASSUME NO OPTION PRESENT
	TSTB	WRK_B_CMDOPT(R11)	; TEST QUALIFIER NUMBER CAUSING CHANGE
	BEQL	20$			; IF ZERO-THIS COMMAND HAS NO OPTIONS
	MOVAB	WRK_G_RESULT(R11),R4	; SET ADDRESS OF FIRST TOKEN DESCRIPTOR
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- ; CHECK THAT QUALIFIER TYPE IS
		PTR_L_DESCR(R4),#PTR_K_PARMQUAL ; PARAMETER QUALIFIER
	BGTRU	20$			; IF NOT, THIS COMMAND HAS NO OPTIONS
	PUSHAB	SCANQUAL		; SET COROUTINE TO SCAN INPUT QUALIFERS
10$:	JSB	@(SP)+			; GET CALLERS NEXT QUALIFIER DESCRIPTOR
	BLBC	R0,20$			; BR IF NOT FOUND
	CMPB	WRK_B_CMDOPT(R11),CLI$B_QDCODE(R7) ; IS THIS THE QUALIFIER HE WANTED?
	BNEQ	10$			; BR IF NO-KEEP LOOKING
	BSBW	MCR$HANDLQUAL		; SET USERS STRUCTURE
	BSBW	QUALACT			; TAKE PROPER ACTION
20$:	RET				; RETURN TO DISPATCHER

	.SBTTL	GET COMMAND DESCRIPTION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SET A DESCRIPTOR FOR THE COMMAND
;	THAT WAS JUST PROCESSED BY MCR.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS ENTERED BY A CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	THE REQUEST DESCRIPTOR IS SET TO CONTAIN A QUADWORD DESCRIPTOR
;	THE THE FINAL COMMAND IN THE BUFFER.
;
; IMPLICIT OUTPUTS:
;
;	THE INTERNAL ERROR MECHANISM IS USED TO RETURN THE RESULTANT
;	COMMAND LINE DESCRIPTOR WHEN COMMAND IS A RUN
;
; COMPLETION CODES:
;
;	SUCCESS IN ALL CASES EXCEPT WHEN COMMAND IS A "RUN".  IN THIS
;	WAY, A UTILITY MAY DETERMIN THAT IS WAS INVOKED VIA A COMMAND,
;	IE: LINK ALPHA, OR BY A "RUN FILESPEC".
;
;--
MCR$GETCMD::				; GET COMMAND LINE
	BSBW	MCR$GETMCRWRK		; SET WORK AREA POINTER
	MOVB	WRK_B_VERBTYP(R11),CLI$B_RQSTAT(R9); GET VERB TYPE FOR CALLER
	CLRL	R5			; START AT FIRST TOKEN
	BSBW	MCR$SETDESCADR		; SET ADDRESS OF TOKEN DESCRIPTOR
	MOVL	WRK_L_RSLNXT(R11),R2	; GET ADDRESS OF NEXT FREE DESCRIPTOR
	EXTZV	#PTR_V_OFFSET,#PTR_S_OFFSET,-4(R2),R2 ; GET OFFSET TO EOL
	MOVL	R2,R3			; PRESET FIRST TOKEN TO EOL
10$:	ADDL	#4,R4			; SKIP TO NEXT TOKEN
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,(R4),#PTR_K_ENDLINE ; END OF LINE?
	BEQL	20$			; BRANCH IF DONE
	CMPZV	#PTR_V_OFFSET,#PTR_S_OFFSET,(R4),R3 ; FIRST TOKEN IN COMMAND?
	BGEQU	10$			; BRANCH IF NOT
	EXTZV	#PTR_V_OFFSET,#PTR_S_OFFSET,(R4),R3 ; SET OFFSET TO FIRST TOKEN
	BRB	10$			; PRECEEDS FIRST, SET IT AS NEW FIRST
20$:	SUBL	R3,R2			; FIND LENGTH OF COMMAND
	MOVAB	WRK_G_BUFFER(R11)[R3],R3 ; GET ADDRESS OF FIRST TOKEN
	CMPB	#^A\/\,-1(R3)		; COMMAND TERMINATOR A SLASH?
	BNEQ	30$			; IF NOT-THEN DON'T INCLUE IT
	INCL	R2			; ADD 1 TO COUNT
	DECL	R3			; BACK UP ADDRESS TO TERMINATOR
30$:	MOVQ	R2,CLI$Q_RQDESC(R9)	; SET RESULT IN CALLER DATA BLOCK
	MOVL	#1@31,R0		; SET INTERNAL ERROR BIT
	CMPB	#CLI$K_VERB_RUN,CLI$B_RQSTAT(R9) ; WAS COMMAND A RUN?
	BEQL	90$			; IF YES - THERE IS NO COMMAND LINE
	STATUS	NORMAL			; SET GOOD STATUS
90$:	RET				; RETURN TO DISPATCHER
 

	.SBTTL	GET COMMAND LINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OBTAIN THE COMPLETE COMMAND LINE,
;	INCLUDING THE VERB.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS ENTERED BY A CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R9 = ADDRESS OF REQUEST DESCRIPTOR
;	R11 = ADDRESS OF PASS 1 PARSE WORK AREA
;
; OUTPUT PARAMETERS:
;
;	THE REQUEST DESCRIPTOR IS SET TO CONTAIN A QUADWORD DESCRIPTOR
;	OF THE FINAL COMMAND IN THE BUFFER.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SUCCESS, EXCEPT WHEN COMMAND WAS A "RUN"
;
; SIDE EFFECTS:
;
;	NONE
;
;--


MCR$GETLINE::				; GET COMMAND LINE
	BSBW	MCR$GETMCRWRK		; SET WORK AREA POINTER
	MOVB	WRK_B_VERBTYP(R11),CLI$B_RQSTAT(R9); GET VERB TYPE FOR CALLER
	MOVAB	WRK_AB_BUFFER+2(R11),R3	; START OF COMMAND BUFFER
	LOCC	#0,#CMDBUFSIZ,(R3)	; FIND END OF THE COMMAND (LOOK FOR EOL)
	SUBL3	R3,R1,R2		; FIND THE LENGTH OF THE COMMAND
	MOVQ	R2,CLI$Q_RQDESC(R9)	; SET RESULT IN CALLER DATA BLOCK
	MOVL	#1@31,R0		; SET INTERNAL ERROR BIT
	CMPB	#CLI$K_VERB_RUN,CLI$B_RQSTAT(R9) ; WAS COMMAND A RUN?
	BEQL	30$			; IF YES - THERE IS NO COMMAND LINE
10$:	CMPB	(R3),#^A' '		; LEADING SPACE?
	BEQL	20$			; BRANCH IF YES
	CMPB	(R3),#^A/$/		; DOLLAR SIGN
	BNEQ	25$			; BR IF NOT
20$:	INCL	R3			; SKIP ANY LEADING SPACES OR A DOLLAR SIGN
	SOBGTR	R2,10$			; CHECK ENTIRE COMMAND LINE
25$:	MOVQ	R2,CLI$Q_RQDESC(R9)	; STORE LINE WITH VERB STRIPPED
	SETSTAT	SUCCESS			; SET THE STATUS TO SUCESS
30$:	RET				; RETURN TO DISPATCHER
 
	.END
