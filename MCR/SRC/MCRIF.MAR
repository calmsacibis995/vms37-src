	.TITLE	MCRIF - IF MCR COMMAND EXECUTION
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; IF MCR COMMAND EXECUTION
;
; W. H. BROWN 20-DEC-1977
;
; Modified by:
;
;	V001	TMH0001		Tim Halvorsen	29-Apr-1981
;		Allow MCR special symbols in .IFDF and .IFNDF
;---
 
;
; LOCAL MACROS
;
; MACRO TO GENERATE AN ENTRY IN THE IF COMMAND DISPATCHER
;
	.MACRO	IFCOMD	NAME
	.SAVE
	.PSECT	MCR$ZDATA
	.ASCIC	\NAME\
	.RESTORE
	.WORD	<NAME-IFDISP>
	.ENDM
 
;
; MACRO TO GENERATE END OF IF COMMAND DISPATCHER
;
 
	.MACRO	IFTERM
	.SAVE
	.PSECT	MCR$ZDATA
	.BYTE	0
	.RESTORE
	.ENDM
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			; DEFINE WORK AREA OFFSETS
	DEFERRCOD			; DEFINE ERROR/STATUS CODES
	DEFSYMTBL			; DEFINE SYMBOL TABLE OFFSETS
 
;
; LOCAL DEFINITONS
;
	_VIELD	IF,0,<-			; IF COMMAND LOCAL BITS
		OPFLAG,-		; OPERATION MUST BE .IFXXX
		FALSE,-			; CONDITION IS TRUE IF EXPRESSION FALSE
		NUMIF,-			; IF STATMENT IS NUMERIC
		>
 
;
; DEFINE WORK AREA OFFSETS
;
	WRK_B_CUROP	= WRK_L_QUABLK	; RESULT OF CURRENT OPERATION
	WRK_B_PRVOP	= WRK_B_CUROP+1	; RESULT OF PREVIOUS OPERATION
	WRK_B_IFCOND	= WRK_B_PRVOP+1	; SAVED CONDITION FOR IF STATEMENT
	
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZDATA,BYTE,RD,NOWRT
IFTABL:					; DEFINE START OF IF COMMAND TABLE
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
 
IFCHRS:	.ASCIC	/=></			; IF RELATIONAL CHARS
IFCEND:
 
;
; RELATIONAL TABLES - ONE EACH FOR GRAHPIC FORM OF RELATIONAL OPERATORS
;	AND ALPHA FORM.  THERE ORDER MUST BE THE SAME AND SUBSTRINGS
;	OF OTHERS ONES MUST BE LATER IN THE TABLE.
;
 
ALPHAREL:				; ALPHA RELATIONAL TABLE
	.ASCIC	/EQ/			;
	.ASCIC	/GE/			;
	.ASCIC	/LE/			;
	.ASCIC	/NE/			;
	.ASCIC	/LT/			;
	.ASCIC	/GT/			;
	.BYTE	0			; END OF TABLE
 
GRAPHREL:				; GRAPHIC REALTIONAL OPERATORS
	.ASCIC	/=/			;
	.ASCIC	/>=/			;
	.ASCIC	/<=/			;
	.ASCIC	/<>/			;
	.ASCIC	/</			;
	.ASCIC	/>/			;
	.BYTE	0
	.PAGE
	.SBTTL	IF COMMAND 
;+
; MCR$IF - IF COMMAND
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE IF MCR COMMAND.
;
; INPUTS:
;
;	R6 = COMMAND BUFFER DISPLAY PARAMETER.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE IF CLAUSE IS EVALUATED AND IF THE RESULTANT VALUE IS TRUE, THE
;	THEN CLAUSE IS EXECUTED BY RETURNING CONTROL TO THE COMMAND EXECUTION
;	ENTRY POINT. OTHERWISE CONTROL IS RETURNED VIA THE RETURN ADDRESS.
;
;	R0 LOW BIT CLEAR INDICATES EXPRESSION EVALUATION FAILURE.
;
;		R0 = MCR$_COMPLX - EXPRESSION TOO COMPLEX.
;		R0 = MCR$_EXPSYN - EXPRESSION SYNTAX ERROR.
;		R0 = MCR$_IVCHAR - INVALID CHARACTER IN NUMERIC STRING.
;		R0 = MCR$_IVOPER - INVALID EXPRESSION OPERATOR.
;		R0 = MCR$_UNDSYM - UNDEFINED SYMBOL.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
	.ENABL	LSB
MCR$IF::				; IF COMMAND
	MOVW	#1,WRK_B_CUROP(FP)	; SET CURRENT OP TO TRUE, PREVIOUS FALSE
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE INDIRECT FILE RECOGNITION
10$:	MOVAB	W^IFTABL,R5		; SET ADDRESS OF TABLE TO SERCH
	BSBW	MCR$SRCTBL		; LOOK UP THE COMMAND
	BLBC	R0,30$			; BR IF NOT AN "IF" COMMAND
	MOVL	R9,R6			; SET ERROR DISPLAY REGISTER
	BSBB	20$			; CASE ON SELECTED COMMAND
	BLBC	R0,60$			; BR IF ERROR EVALUATING IF
	MOVL	R9,R6			; SET ERROR REPORTING POINTER
	SETNBLK				; PEEK AT NEXT NON-BLANK CHARACTER
	TSTB	R0			; EOL?
	BEQL	SYNERR			; BR IF YES - THATS A SYNTAX ERROR
	CMPB	R0,#^A/./		; START OF ANOTHER INDIRECT COMMAND
	BNEQ	40$			; BR IF NO
	MOVCHAR				; COPY DOT TO COMMAND BUFFER
	GETOKEN				; GET THE COMMAND NAME
	BEQL	SYNERR			; BR IF BAD SYNTAX
	BRB	10$			; SEE IF COMMAND IS FOR "IF"
20$:	CASEW	R4,#1,S^#<<<IFEND-IFDISP>/2>-1> ; DECODE OPERATION
IFDISP:	IFCOMD	IFT			;
	IFCOMD	IFF			;
	IFCOMD	IFDF			;
	IFCOMD	IFNDF			;
	IFCOMD	IFACT			;
	IFCOMD	IFNACT			;
	IFCOMD	IFINS			;
	IFCOMD	IFNINS			;
	IFCOMD	IFLOA			;
	IFCOMD	IFNLOA			;
	IFCOMD	IF
	IFCOMD	OR
	IFCOMD	AND
IFEND:	IFTERM
 
30$:	INCL	R1			; ADD 1 TO LENGTH OF TOKEN
	DECL	R2			; BACK UP ADDRESS TO "."
	SUBL	R1,R9			; BACK TOKEN OUT OF PARSE BUFFER
	SUBL3	R1,WRK_L_CHARPTR(FP),R0	; BACK UP CHARACTER POINTER
	MOVAB	(R0)+,WRK_L_CHARPTR(FP); RESET CHARATER POINTER
	MOVC	R1,(R2),(R0)		; COPY COMMAND BACK INTO INPUT
40$:	BBCC	#IF_V_OPFLAG,WRK_W_LOCFLG(FP),SYNERR ; BR IF COMMAND SYNTAX
	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE INDIRECT FILE RECOGNITION
	BISB	WRK_B_PRVOP(FP),WRK_B_CUROP(FP) ; OR PRVIOUS WITH CURRENT
	BEQL	50$			; BR IF CONDITION FALSE
 
;
; EXECUTE THEN CLAUSE OF IF COMMAND
;
 
	BRW	MCR$CMDSTART		; 
 
;
; BYPASS THEN CLAUSE OF IF COMMAND
;
 
50$:	STATUS	NORMAL			; SET NORMAL COMPLETION STATUS
	RSB
 
SYNERR:	STATUS	EXPSYN			; SET ERROR
60$:	RSB				; 
 
;
; TESTS WHICH ARE ALWAYS FALSE
;
 
IFACT:					; IF TASK ACTIVE
IFNINS:					; IF TASK NOT INSTALLED
IFNLOA:					; IF DRIVER NOT LOADED
	SETBIT	IF_V_FALSE,WRK_W_LOCFLG(FP) ; FLAG RESULT FALSE
 
;
; TESTS WHICH ARE ALWAYS TRUE
;
 
IFNACT:					; IF TASK IDLE
IFINS:					; IF TASK INSTALLED
IFLOA:					; IF DRIVER IS LOADED
	GETOKEN				; GET THE NAME
61$:
	BNEQ	65$			; BR IF VALID TOKEN
	CMPB	R0,#^A/ /		; Terminated by a space?
	BEQL	70$			; Yes if EQL
	CMPB	R0,#^A/./		; A LEADING DOT FOR TASK NAMES?
	BNEQ	SYNERR			; BR IF NO TOKEN
62$:
	MOVCHAR				; COPY DOT TO COMMAND BUFFER
	GTBTOKEN			; Get next token with significant
	BRB	61$			; leading blanks
65$:	CMPB	R0,#^A/./		; A trailing dot for task names?
	BEQL	62$			; A dot if EQL
	CMPB	R0,#^A/:/		; Name end with a colon?
	BNEQ	70$			; BR IF NO
	MOVCHAR				; MOVE COLON TO COMMAND BUFFER
70$:	BRB	EXPTRU			; PROCESS THE EXPRESSION
;
; TEST FOR SYMBOL BEING DEFINED OR NOT
;
 
IFNDF:	SETBIT	IF_V_FALSE,WRK_W_LOCFLG(FP) ; FLAG TEST IS TRUE IF FALSE
IFDF:	BSBW	MCR$GETSSYM		; GET SYMBOL NAME
	BEQL	SYNERR			; BR IF ERROR GETTING SYMBOL NAME
	SEARCH				; LLOK FOR SYMBOL
	BLBC	R0,EXPFLS		; BR IF NOT FOUND
	BRB	EXPTRU			; EXPRESSION IS TRUE IF FOUND
 
;
; IFT/IFF COMMAND
;
IFF:	SETBIT	IF_V_FALSE,WRK_W_LOCFLG(FP) ; INDICATE LOOKING FOR A FALSE
IFT:	BSBW	EVALSYM			; EVALUATE SYMBOL VALUE
	BEQL	SYNERR			; BR IF STRING SYMBOL
	BLBS	R1,EXPTRU		; BR IF EXPRESSION WAS TRUE
EXPFLS:	BBSC	#IF_V_FALSE,WRK_W_LOCFLG(FP),TRUE ; BR IF FALSE = TRUE
	BRB	FALSE			;
 
EXPTRU:	BBCC	#IF_V_FALSE,WRK_W_LOCFLG(FP),TRUE ; BR IF TRUE = TRUE
 
FALSE:	CLRB	WRK_B_CUROP(FP)		; INDICATE CURRENT IS FALSE
TRUE:	SETBIT	IF_V_OPFLAG,WRK_W_LOCFLG(FP) ; FLAG OPERATION DONE
	STATUS	NORMAL			;
	RSB				;
	.DSABL	LSB
OR:	BISB	WRK_B_CUROP(FP),WRK_B_PRVOP(FP) ; OR CURRENT WITH PREVIOUS
	MOVB	#1,WRK_B_CUROP(FP)	; SET CURRENT OPERATION TO TRUE
AND:	BBCC	#IF_V_OPFLAG,WRK_W_LOCFLG(FP),SYNERR
	RSB				;
 
	.DSABL	LSB
;
; IF EXP1 REL EXP2 COMMAND
;
 
	.ENABL	LSB
IF:	BSBW	EVALSYM			; GET VALUE FOR FIRST SYMBOL
	BEQL	30$			; BR IF STRING SYMBOL
	MOVL	R1,R7			; SAVE LEFT HAND OPERAND
	SETBIT	#IF_V_NUMIF,WRK_W_LOCFLG(FP) ; FLAG DOING NUMERIC IF
30$:	MOVAB	ALPHAREL,R5		; ASSUME ALPHA REALTIONAL
	MOVL	R9,R6			; SET ERROR PRINT OUT POINTER
	GETOKEN				; GET THE NEXT TOKEN
	BNEQ	60$			; BR IF TOKEN OBTAINED
	MOVL	R9,R2			; COPY POINT IN COMMAND BUFFER
40$:	LOCC	R0,#<IFCEND-IFCHRS>,IFCHRS ; IS THE ON OF THE RELATIONAL CHARS
	BEQL	50$			; BR IF NO
	MOVCHAR				; YES - COPY IT TO THE COMMAND BUFFER
	SETCHAR				; LOOK AT THE NEXT CHARACTER
	BRB	40$			; BR AND CHAECK IT
50$:	SUBL3	R2,R9,R1		; FIND LENGTH OF RELATIONAL
	BEQL	65$			; BR IF NO RELATIONAL
	MOVAB	GRAPHREL,R5		; SET LIST OF GRAPHIC RELATIONAL
60$:	BSBW	MCR$SRCTBL		; SEARCH FOR OPERATOR
	BLBC	R0,65$			; BR IF SYNTAX ERROR
	MULB3	#2,R4,WRK_B_IFCOND(FP)	; SAVE CONDITION TO TEST
	MOVL	R9,R6			; SET ERROR PRINT OUT POINTER
	BBC	#IF_V_NUMIF,WRK_W_LOCFLG(FP),70$ ; BR IF NOT DOING NUMERIC
	EXPRESS				; EVALUATE EXPRESSION
	BRB	80$			;
65$:	BRW	SYNERR			; REPORT SYNTAX ERROR
70$:	BSBW	MCR$EVLSTRING		; EVALUTE A STRING OPERAND
80$:	BLBC	R0,150$			; ERROR EVALUATING EXPRESSION
	MOVZBL	WRK_B_IFCOND(FP),R4	; GET THE CONDITION TO TEST
	CLRL	R5			; INIT RESULT FALSE
	BBCC	#IF_V_NUMIF,WRK_W_LOCFLG(FP),90$ ; BR IF STRING COMPAIR
	CMPL	R7,R1			; COMPAIR THE OPERATORS
	BRB	100$			;
90$:	CMPC5	R7,(R8),#^A/ /,R1,(R2)	;
100$:	JSB	B^120$-2[R4]		; DECODE TEST
	BLBC	R5,110$			; BR IF RESULT IS FALSE
	BRW	TRUE			; INDICATE TRUE
110$:	BRW	FALSE			; 
 
120$:	BRB	EQL			;
	BRB	GEQ			;
	BRB	LEQ			;
	BRB	NEQ			;
	BRB	LSS			;
 
GTR:	BGTR	SETRUE			; BR IF GTR AND SET TRUE
150$:	RSB				; ELSE RETURN WITH FALSE
 
EQL:	BEQL	SETRUE			; BR IF EQL AND SET TRUE
	RSB				; ELSE RETURN WITH FALSE
 
GEQ:	BGEQ	SETRUE			; BR IF GEQ AND SET TRUE
	RSB				; ELSE RETURN WITH FALSE
 
LEQ:	BLEQ	SETRUE			; BR IF LEQ AND SET TRUE
	RSB				; ELSE RETURN WITH FALSE
 
NEQ:	BNEQ	SETRUE			; BR IF NEQ AND SET TRUE
	RSB				; ELSE RETURN WITH FALSE
 
LSS:	BLSS	SETRUE			; BR IF LSS AND SET TRUE
	RSB				; ELSE RETURN WITH FALSE
 
SETRUE:	INCL	R5			; SET THE RESULT TRUE
	RSB
 
	.DSABL	LSB
	.PAGE
 
;
; EVALSYM - LOCAL SUBROUTIEN TO EVALUATE A SYMBOL
;
; THIS ROUTINE IS CALLED TO PARSE THE NEXT SYMBOL FROM THE COMMAND LINE,
; AND LOCATE IT IN THE SYMBOL TABLE.  IF THE SYMBOL IS UNDEFINED,
; ERROR STATUS IS RETURNED TO THE IF COMMAND DISPATCHER, OR RETURN WITH
; "Z" BIT SET INDICATES A STRING SYMBOL. OTHERWISE, THE NUMERIC VALUE OF
; THE SYMBOL IS DETERMINED AND RETURNED.
;
; INPUTS:
;
; OUTPUTS:
;
;	R7,R8 IS THE DESCRIPTOR OF THE SYMBOLS VALUE STRING
;
; FOR STRING VARIABLES:
;
;	"Z" CONDITION CODE = TRUE
;
; FOR NUMERIC SYMBOLS:
;
;	R1 IS THE VALUE
;
	.ENABL	LSB
;
; FORM TABLE FOR SYMBOL CONVERSION RADIX
;
	ASSUME	SYM_K_PERM    EQ 1	; PERMANENT SYMBOL
	ASSUME	SYM_K_LOGICAL EQ 2	; LOGICAL VALUE
	ASSUME	SYM_K_OCTAL   EQ 3	; OCTAL VALUE
	ASSUME	SYM_K_DECIMAL EQ 4	; DECIMAL NUMERIC VALUE
	ASSUME	SYM_K_HEXDEC  EQ 5	; HEXIDECIMAL VALUE
10$:	.BYTE	PRC_K_DEC		; PERMANENT SYMBOLS HAVE DECIMAL RADIX
	.BYTE	PRC_K_OCT		; LOGICALS ARE OCTAL
	.BYTE	PRC_K_OCT		; OCTAL NUMERIC VALUES
	.BYTE	PRC_K_DEC		; DECIMAL NUMERIC VALUES
	.BYTE	PRC_K_HEX		; HEXIDECIMAL NUMERIC VALUES
EVALSYM:BSBB	MCR$GETSSYM		; ISOLATE SYMBOL NAME
	BLBC	R0,50$			; BR IF ERROR IN SYMBOL NAME
	SEARCH				; LOOK UP SYMBOL IN TABLE
	BLBC	R0,50$			; BR IF NO SUCH SYMBOL
	MOVQ	R1,R7			; SAVE DESCRIPTOR FOR SYMBOL VALUE
	ASSUME	SYM_K_STRING EQ 0	;
	MOVZBL	SYM_B_TYPE(R3),R0	; GET SYMBOL TYPE FIELD
	BEQL	30$			; BR IF STRING SYMBOL
	CLRL	R1			; ASSUME LOGICAL FALSE
	CMPB	#^A/F/,(R2)		; IS SYMBOL LOGICAL FLASE?
	BEQL	20$			; BR IF YES
	INCL	R1			; SET TO LOGICAL TRUE
	CMPB	#^A/T/,(R2)		; IS IT TRUE?
	BEQL	20$			; BR IF YES
	MOVQ	R7,R2			; SET DESCRIPTOR FOR STRING TO R2,R3
	MOVZBL	10$-1[R0],R1		; GET SYMBOL RADIX INDICATOR
	BSBW	MCR$CNVASCBIN		; CONVERT NUMERIC SYMBOL TO BINARY
20$:	MOVZBL	#1,R0			; SET SUCCESS AND CLEAR "Z" BIT
30$:	RSB
;
; ERROR ON SYMBOL - RETURN ERROR TO "IF" DISPATCHER
;
50$:	TSTL	(SP)+			; CLEAR INTERMEDIATE RETURN ADDRESS
	RSB				; RETURN TO DISPATCHER
	.DSABL	LSB
	.PAGE
	.SBTTL	GET SPECIAL SYMBOL
;+
; MCR$GETSSYM - GET SPECIAL SYMBOL
;
; THIS ROUTINE IS CALLED TO PARSE THE NEXT SYMBOL FROM THE COMMAND
; AND RETURN IT TO ITS CALLER. THE SYMBOL MAY BE ANY VALID TOKEN,
; OR A SPECIAL SYMBOL SYMBOL OF THE FORM "<SYMBOL>".
;
; INPUTS:
;
;	R6 = COMMAND BUFFER DISPLAY PARAMETER.
;	R9 = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SYMBOL SYNTAX ERROR
;
;		R0 = MCR$_SYMDEL - SYMBOL DELIMITER
;
;	R0 LOW BIT SET INDICATES SUCCESS
;
;		R1 = LENGTH OF SYMBOL
;		R2 = STARTING ADDRESS OF SYMBOL
;-
 
MCR$GETSSYM::				; GET SPECIAL SYMBOL
	MOVL	R9,R6			; SET ERROR PRINT POINTER
	GETOKEN				; GET THE NEXT TOKEN FROM THE COMMAND
	BNEQ	10$			; BR IF TOKEN FOUND OK
	CMPB	R0,#^A/</		; START OF SPECIAL SYMBOL
	BNEQ	20$			; BR IF NO - SYNTAX ERROR
	MOVTOKN				; MOVE CHARACTER AND GET TOKEN
	BEQL	20$			; BR IF BAD SYNTAX
	MOVTERM	>			; MOVE THE TERMINATOR TO COMMAND BUFFER
	BNEQ	20$			; BR IF BAD SYNTAX
	DECL	R2			; BACK UP POINTER TO LEADING BRACKET
	ADDL	#2,R1			; ADJUST LENGTH FOR BRACKETS
10$:	STATUS	NORMAL			; GOOD RETURN
	RSB				;
20$:	STATUS	SYMDEL			; SET ERROR
	RSB				; RETURN THAT
 
	.END
