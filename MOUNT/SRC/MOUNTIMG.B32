MODULE MOUNTIMG (
		MAIN = PARSE_COMMAND,
		ADDRESSING_MODE (EXTERNAL = GENERAL),
		LANGUAGE (BLISS32),
		IDENT = 'V03-001'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  MOUNT Utility Structure Level 1
!
! ABSTRACT:
!
!	This module contains the data base and utilities used to acquire the
!	MOUNT command line from the CLI parser.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  29-Sep-1977  16:58
!
! MODIFIED BY:
!
!	V03-001	STJ0239		Steven T. Jeffreys,	17-Mar-1982
!		Relax the parsing restrictions on the device name
!		as specified in the /PROCESSOR=SAME:<device name>
!		qualifier.  Specifically, if no ":" is specified in
!		the device name, put one there.
!
!	V02-016	STJ0226		Steven T. Jeffreys,	17-Feb-1982
!		Do not set the inhibit bit in the final status code.
!		This effectively undoes edit #14.
!
!	V02-015	STJ0213		Steven T. Jeffreys,	11-Feb-1982
!		Add support for the /COMMENT qualifier.
!
!	V02-014	STJ0201		Steven T. Jeffreys,	04-Feb-1982
!		Set the inhibit bit in the final status code.
!
!	V02-013	STJ0187		Steven T. Jeffreys,	25-Jan-1982
!		Changed MNT$V_MOUNTVER to MNT$V_NOMNTVER.
!
!	V02-012	STJ0172		Steven T. Jeffreys,	08-Jan-1982
!		Changed $MOUNT interface to use *new* item list format.
!
!	V02-011	STJ0162		Steven T. Jeffreys,	04-Jan-1982
!		Added support for the /OVERRIDE=LOCK, /NOCACHE, /MOUNTVER,
!		and /MESSAGE qualifiers.
!
!	V02-010	STJ0153		Steven T. Jeffreys,	02-Jan-1981
!		Extensive rewrite to support the $MOUNT system service.
!
!	V02-009	STJ0147		Steven T. jeffreys,	01-Dec-1981
!		Fixed TPARSE table for /PROCESSOR= option.
!
!	V02-008	STJ0137		Steven T. Jeffreys,	02-Nov-1981
!		Convert the command line parser to a separate image,
!		which will parse the command line and then call the
!		$MOUNT system service to complete the mount.
!
!	V02-007	STJ0036		Steven T. Jeffreys,	11-May-1981
!		Added support for /ASSIST qualifier.
!
!	V02-006	ACG0167		Andrew C. Goldstein,	18-Apr-1980  13:38
!		Previous revision history moved to MOUNT.REV
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:MOUDEF.B32';
REQUIRE 'LIBD$:[VMSLIB.OBJ]MOUNTMSG.B32';
REQUIRE	'LIBD$:[VMSLIB.OBJ]INITMSG.REQ';
LIBRARY 'SYS$LIBRARY:CLIMAC.L32';
LIBRARY 'SYS$LIBRARY:TPAMAC.L32';

!+
!
! Impure data area. This area contains the MOUNT parameters extracted from
! the command line by the associated parsing routines.
!
!-


OWN
	MOUNT_OPTIONS	: BITVECTOR [64], ! option flags
	PROTECTION,			! value of /PROTECTION switch
	OWNER_UIC,			! value of /OWNER_UIC switch
	USER_UIC,			! value of /USER_UIC switch
	EXTENSION,			! value of /EXTENSION switch
	WINDOW,				! value of /WINDOW switch
	DENSITY,			! value of /DENSITY switch
	ACCESSED,			! value of /ACCESSED switch
	BLOCKSIZE,			! value of /BLOCK switch
	RECORDSZ,			! value of /RECORD switch
	FID_CACHE,			! space to allocate for file ID cache
	EXT_CACHE,			! space to allocate for extent cache
	QUO_CACHE,			! space to allocate for quota cache
	DEVICE_COUNT,			! number of devices specified
	LABEL_COUNT,			! number of volume labels specified
	VID_STRING	: VECTOR [2],	! descriptor of VISUAL_ID string
	COMMENT_STRING	: VECTOR [2],	! descriptor of COMMENT string
	ACP_STRING	: VECTOR [2],	! descriptor of ACP device or name string
	LOG_NAME	: VECTOR [2],	! descriptor of logical name string
	STRUCT_NAME	: VECTOR [2],	! descriptor of volume set name
					! (value of /BIND qualifier)
	DRIVE_COUNT	: VECTOR [DEVMAX], ! value of /DRIVES switch
	DEVICE_STRING	: VECTOR [DEVMAX*2], ! descriptors of device name strings
	LABEL_STRING	: VECTOR [LABMAX*2], ! descriptors of volume label strings
	!
	! The following are the cells that contain the actual parameter values.
	!
	MOUNT_FLAGS	: BBLOCK [4],	! Mount options
	PARSE_IMP_END	: VECTOR [0];	! end of data area

LITERAL
	PARSE_IMP_LEN	= PARSE_IMP_END - MOUNT_OPTIONS,! Length of impure area
	ITEM_SIZE	= 12,				! Size of each paramter item
	NUMBER_OF_ITEMS	= 18,				! Just like the name says...
	ITEM_LIST_SIZE	= ((ITEM_SIZE * DEVMAX) *2) + (NUMBER_OF_ITEMS * ITEM_SIZE) + 4;



!
! Assorted impure data.
!

OWN
	EXT_LIMIT	: INITIAL (-1),		! limit of disk free space to cache
	CLI_WORK_AREA	: BBLOCK [CLI$K_WORKAREA],
	TPARSE_BLOCK	: BBLOCK [TPA$K_LENGTH0]
			  INITIAL (TPA$K_COUNT0, TPA$M_BLANKS OR TPA$M_ABBREV),
	UIC;

!+
!
! Request descriptors to the CLI parser. Labels are deemed sufficiently
! obvious to make cluttering the code with comments unnecessary.
!
!-

FORWARD ROUTINE
	MAIN_HANDLER,
	BUILD_LIST	: NOVALUE,
	PARSE_ERROR	: NOVALUE,
	DENSITY_ACT	: NOVALUE,
	BIND_ACT	: NOVALUE,
	VID_ACT		: NOVALUE,
	COMMENT_ACT	: NOVALUE,
	BLOCK_ACT	: NOVALUE,
	SHARE_ACT	: NOVALUE,
	NOLABEL_ACT,
	EBCDIC_ACT	: NOVALUE,
	PROTECTION_ACT	: NOVALUE,
	DATACHECK_ACT	: NOVALUE,
	OWNER_UIC_ACT	: NOVALUE,
	USER_UIC_ACT	: NOVALUE,
	OVERRIDE_ACT	: NOVALUE,
	CACHE_ACT	: NOVALUE,
	NOCACHE_ACT	: NOVALUE,
	EXTENSION_ACT	: NOVALUE,
	WINDOW_ACT	: NOVALUE,
	ACCESSED_ACT	: NOVALUE,
	PROCESSOR_ACT	: NOVALUE,
	DEVICE_ACT	: NOVALUE,
	LABEL_ACT	: NOVALUE,
	LOG_NAME_ACT	: NOVALUE,
	DRIVES_ACT	: NOVALUE,
	RECORD_ACT	: NOVALUE;

$CLIQUALCODES (MOUNT,
	DENSITY,
	VISUAL_IDENT,
	COMMENT,
	SHARE,
	GROUP,
	SYSTEM,
	WRITE,
	UNLOCK,
	FOREIGN,
	LABEL,
	BLOCK,
	EBCDIC,
	QUOTA,
	HDR3,
	PROTECTION,
	DATACHECK,
	OWNER_UIC,
	USER_UIC,
	OVERRIDE,
	CACHE,
	EXTENSION,
	WINDOW,
	ACCESSED,
	PROCESSOR,
	DRIVES,
	BIND,
	RECO,
	MESSAGE,
	MOUNT_VERIFICATION,
	ASSIST
	);

! CLI request and qualifier descriptor blocks. Note that the ordering of
! the qualifier descriptors is critical because of interrelated bit list
! processing. Note also that correct operation of this parser is critically
! dependent on the advertised order of CLI processing: first establish the
! state of all qualifiers, using explicit and default data, then setting and
! clearing the bit set and clear lists, then testing the bit test lists, and
! finally calling all of the action routines. Within each step, the qualifiers
! are processed in the order listed.
!

OWN
	INIT_PARSE	: $CLIREQDESC (RQTYPE = INITPRS,
				RQFLGS = ABSADR,
				ERRACT = PARSE_ERROR
			),
	END_PARAM1	: $CLIREQDESC (RQTYPE = ENDPRM1,
				RQFLGS = ABSADR,
				ERRACT = PARSE_ERROR
			),
	END_PARAM2	: $CLIREQDESC (RQTYPE = ENDPRM2,
				RQFLGS = ABSADR,
				ERRACT = PARSE_ERROR
			),
	END_PARAM3	: $CLIREQDESC (RQTYPE = ENDPRM3,
				RQFLGS = ABSADR,
				ERRACT = PARSE_ERROR
			),

	DENSITY_Q	: $CLIQUALDESC (
				QDCODE = DENSITY,
				SETLST = OPT_DENSITY,
				TRUACT = DENSITY_ACT
			),
	BIND_Q		: $CLIQUALDESC (
				QDCODE = BIND,
				SETLST = OPT_BIND,
				TRUACT = BIND_ACT
			),
	VID_Q		: $CLIQUALDESC (
				QDCODE = VISUAL_IDENT,
				TRUACT = VID_ACT
			),
	COMMENT_Q	: $CLIQUALDESC (
				QDCODE = COMMENT,
				TRUACT = COMMENT_ACT
			),
	OVERRIDE_Q	: $CLIQUALDESC (
				QDCODE = OVERRIDE,
				TRUACT = OVERRIDE_ACT
			),
	CACHE_Q	: $CLIQUALDESC (
				QDCODE = CACHE,
				TRUACT = CACHE_ACT,
				FLSACT = NOCACHE_ACT
			),
	SHARE_Q		: $CLIQUALDESC (
				QDCODE = SHARE,
				SETLST = OPT_SHARE,
				CLRLST = OPT_NOSHARE,
				FLSACT = SHARE_ACT
			),
	GROUP_Q		: $CLIQUALDESC (
				QDCODE = GROUP,
				SETLST = OPT_GROUP,
				TSTLST = OPT_SHARE
			),
	SYSTEM_Q	: $CLIQUALDESC (
				QDCODE = SYSTEM,
				SETLST = OPT_SYSTEM,
				TSTLST = (OPT_SHARE, OPT_GROUP)
			),
	WRITE_Q		: $CLIQUALDESC (
				QDCODE = WRITE,
				SETLST = OPT_WRITE
			),
	LABEL_Q		: $CLIQUALDESC (
				QDCODE = LABEL,
				CLRLST = OPT_NOLABEL,
				FLSACT = NOLABEL_ACT
			),
	FOREIGN_Q	: $CLIQUALDESC (
				QDCODE = FOREIGN,
				SETLST = OPT_FOREIGN,
				TSTLST = (OPT_NOLABEL, OPT_BIND),
				TRUACT = NOLABEL_ACT
			),
	UNLOCK_Q	: $CLIQUALDESC (
				QDCODE = UNLOCK,
				SETLST = OPT_UNLOCK,
				TSTLST = (OPT_FOREIGN, OPT_SHARE, OPT_GROUP, OPT_SYSTEM)
			),
	BLOCK_Q		: $CLIQUALDESC (
				QDCODE = BLOCK,
				SETLST = OPT_BLOCK,
				TRUACT = BLOCK_ACT
			),
	REC_Q		: $CLIQUALDESC (
				QDCODE = RECO,
				SETLST = OPT_RECORDSZ,
				TRUACT = RECORD_ACT
			),
	EBCDIC_Q	: $CLIQUALDESC (
				QDCODE = EBCDIC,
				TSTLST = OPT_FOREIGN,
				TRUACT = EBCDIC_ACT
			),
	QUOTA_Q		: $CLIQUALDESC (
				QDCODE = QUOTA,
				CLRLST = OPT_NOQUOTA,
				TSTLST = OPT_FOREIGN
			),
	HDR3_Q		: $CLIQUALDESC (
				QDCODE = HDR3,
				CLRLST = OPT_NOHDR3,
				TSTLST = OPT_FOREIGN
			),
	PROTECTION_Q	: $CLIQUALDESC (
				QDCODE = PROTECTION,
				SETLST = OPT_PROTECTION,
				TRUACT = PROTECTION_ACT
			),
	DATACHECK_Q	: $CLIQUALDESC (
				QDCODE = DATACHECK,
				TRUACT = DATACHECK_ACT
			),
	OWNER_UIC_Q	: $CLIQUALDESC (
				QDCODE = OWNER_UIC,
				SETLST = OPT_OWNER_UIC,
				TRUACT = OWNER_UIC_ACT
			),
	USER_UIC_Q	: $CLIQUALDESC (
				QDCODE = USER_UIC,
				SETLST = OPT_USER_UIC,
				TRUACT = USER_UIC_ACT
			),
	EXTENSION_Q	: $CLIQUALDESC (
				QDCODE = EXTENSION,
				SETLST = OPT_EXTENSION,
				TSTLST = OPT_FOREIGN,
				TRUACT = EXTENSION_ACT
			),
	WINDOW_Q	: $CLIQUALDESC (
				QDCODE = WINDOW,
				SETLST = OPT_WINDOW,
				TSTLST = OPT_FOREIGN,
				TRUACT = WINDOW_ACT
			),
	ACCESSED_Q	: $CLIQUALDESC (
				QDCODE = ACCESSED,
				SETLST = OPT_ACCESSED,
				TSTLST = OPT_FOREIGN,
				TRUACT = ACCESSED_ACT
			),
	PROCESSOR_Q	: $CLIQUALDESC (
				QDCODE = PROCESSOR,
				TSTLST = OPT_FOREIGN,
				TRUACT = PROCESSOR_ACT
			),
	DRIVES_Q	: $CLIQUALDESC (
				QDCODE = DRIVES,
				TRUACT = DRIVES_ACT
			),
	ASSIST_Q	: $CLIQUALDESC (
				QDCODE = ASSIST,
				SETLST = OPT_ASSIST
			),
	MESSAGE_Q	: $CLIQUALDESC (
				QDCODE = MESSAGE,
				SETLST = OPT_MESSAGE
			),
	MOUNTVER_Q	: $CLIQUALDESC (
				QDCODE = MOUNTVER,
				SETLST = OPT_MOUNTVER
			),
	QUAL_END	: $CLIQUALEND,


	GET_QUAL	: $CLIREQDESC (RQTYPE = GETQUAL,
				RQFLGS = ABSADR,
				QUALST = DENSITY_Q,
				ERRACT = PARSE_ERROR
			),
	GET_DEVICE	: $CLIREQDESC (RQTYPE = INPUT1,
				RQFLGS = (ABSADR, PARMREQ),
				BITNUM = OPT_DEVICE,
				QUALST = DRIVES_Q,
				PRSACT = DEVICE_ACT,
				ERRACT = PARSE_ERROR
			),
	GET_LABEL	: $CLIREQDESC (RQTYPE = INPUT2,
				RQFLGS = (ABSADR, PARMREQ),
				BITNUM = OPT_LABEL,
				PRSACT = LABEL_ACT,
				ERRACT = PARSE_ERROR
			),
	GET_LOG_NAME	: $CLIREQDESC (RQTYPE = INPUT3,
				RQFLGS = ABSADR,
				BITNUM = OPT_LOG_NAME,
				PRSACT = LOG_NAME_ACT,
				ERRACT = PARSE_ERROR
			),
	CONVERT_NUMBER	: $CLIREQDESC (RQTYPE = NUMERVAL,
				RQFLGS = (ABSADR, LASTVAL),
				ERRACT = PARSE_ERROR
			);

GLOBAL ROUTINE PARSE_COMMAND (START_ADDRESS, CLI_CALLBACK) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses the MOUNT command line by calling the CLI
!	result parse routines, and leaves the results in the global data
!	area.
!
!
! CALLING SEQUENCE:
!	MOUNT_PARSE (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: program start address
!	ARG2: address of CLI service routine
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	parser impure area on preceding pages
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	ZERO		: LONG,				! A constant 0
	ITEM_LIST	: BBLOCK [ITEM_LIST_SIZE],	! Storage for item list
	END_OF_LIST	: LONG,				! Pointer to end of item list
	STATUS		: LONG;

! Enable the main condition handler.  The handler will ensure that
! the return status will have the MOUNT facility code.
!

ENABLE	MAIN_HANDLER;

! Initialize result parsing.
!
ZERO = 0;
END_OF_LIST = ITEM_LIST;
MOUNT_OPTIONS = MOUNT_OPTIONS+4 = 0;
MOUNT_OPTIONS[OPT_MESSAGE] = 1;
MOUNT_OPTIONS[OPT_NOSHARE] = 1;
MOUNT_OPTIONS[OPT_NOLABEL] = 1;
MOUNT_OPTIONS[OPT_NOQUOTA] = 1;
MOUNT_OPTIONS[OPT_NOHDR3] = 1;

(.CLI_CALLBACK) (INIT_PARSE, CLI_WORK_AREA);

! Parse command qualifiers. (Most of the action routines are called during
! this call.)
!

(.CLI_CALLBACK) (GET_QUAL, CLI_WORK_AREA, MOUNT_OPTIONS);

! Now acquire device names.
!

DO (.CLI_CALLBACK) (GET_DEVICE, CLI_WORK_AREA, MOUNT_OPTIONS)
WHILE .GET_DEVICE[CLI$V_CONCATINP];

(.CLI_CALLBACK) (END_PARAM1, CLI_WORK_AREA);

! Now acquire volume names.
!

DO (.CLI_CALLBACK) (GET_LABEL, CLI_WORK_AREA, MOUNT_OPTIONS)
WHILE .GET_LABEL[CLI$V_CONCATINP];

(.CLI_CALLBACK) (END_PARAM2, CLI_WORK_AREA);

! Finally get optional logical name.
!

(.CLI_CALLBACK) (GET_LOG_NAME, CLI_WORK_AREA, MOUNT_OPTIONS);

(.CLI_CALLBACK) (END_PARAM3, CLI_WORK_AREA);

! Do post parsing fixups.
!

IF NOT .MOUNT_OPTIONS[OPT_LABEL]	! if no label given
THEN
    BEGIN				! construct null label string
    LABEL_STRING[0] = 0;
    LABEL_STRING[1] = LABEL_STRING[1];
    END;

IF .MOUNT_OPTIONS[OPT_OVR_ID]
AND NOT .MOUNT_OPTIONS[OPT_NOSHARE]
THEN ERR_EXIT (MOUN$_CONFQUAL);

!
! Create a counted list of the addresses of all device name descriptors. 
!
INCR J FROM 0 TO .DEVICE_COUNT-1 DO	! Process the DEVICE parameter
    BUILD_LIST (MNT$_DEVNAM, .DEVICE_STRING [.J*2], .DEVICE_STRING [(.J*2)+1], END_OF_LIST);

!
! Create a counted list of the addresses of all volume name descriptors.
!
INCR J FROM 0 TO .LABEL_COUNT-1 DO	! Process the LABEL parameter
    BUILD_LIST (MNT$_VOLNAM, .LABEL_STRING [.J*2], .LABEL_STRING [(.J*2)+1], END_OF_LIST);

!
! Set up the parameter addresses for all specified parameters.
!
IF .MOUNT_OPTIONS [OPT_LOG_NAME]	! Process the LOGNAM parameter
THEN
    BUILD_LIST (MNT$_LOGNAM, .LOG_NAME [0], .LOG_NAME [1], END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_ACCESSED]	! Process the /ACCESSED qualifier
THEN
    BUILD_LIST (MNT$_ACCESSED, 4, ACCESSED, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_UNIQUEACP]	! Process the /PROCESSOR qualifier
OR .MOUNT_OPTIONS [OPT_SAMEACP]
OR .MOUNT_OPTIONS [OPT_FILEACP]
THEN
    BUILD_LIST (MNT$_PROCESSOR, .ACP_STRING [0], .ACP_STRING [1], END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_BIND]		! Process the /BIND qualifier
THEN
    BUILD_LIST (MNT$_VOLSET, .STRUCT_NAME [0], .STRUCT_NAME [1], END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_BLOCKSIZE]	! Process the /BLOCKSIZE qualifier
THEN
    BUILD_LIST (MNT$_BLOCKSIZE, 4, BLOCKSIZE, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_DENSITY]		! Process the /DENSITY qualifier
THEN
    BEGIN
    IF .MOUNT_OPTIONS [OPT_DENS_800]
    THEN
	DENSITY = 800
    ELSE
	IF .MOUNT_OPTIONS [OPT_DENS_1600]
	THEN
	    DENSITY = 1600
	ELSE
	    DENSITY = 6250;
    BUILD_LIST (MNT$_DENSITY, 4, DENSITY, END_OF_LIST);
    END;


IF .EXT_CACHE GTR 0			! Process the /CACHE=([NO]EXTENT) qualifier
THEN
    BEGIN
    BUILD_LIST (MNT$_EXTENT, 4, EXT_CACHE, END_OF_LIST);
    END;
IF .MOUNT_OPTIONS [OPT_NOEXT_C]
THEN
    BUILD_LIST (MNT$_EXTENT, 4, ZERO, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_NOFID_C]		! Process the /CACHE=([NO]FILE_ID) qualifier
THEN
    FID_CACHE = 1;
IF .FID_CACHE GTR 0
THEN
    BUILD_LIST (MNT$_FILEID, 4, FID_CACHE, END_OF_LIST);

IF .EXT_LIMIT GTR -1			! Process the /CACHE=(LIMIT) qualifier
THEN
    BUILD_LIST (MNT$_LIMIT, 4, EXT_LIMIT, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_OWNER_UIC]	! Process the /OWNER_UIC qualifier
THEN
    BUILD_LIST (MNT$_OWNER, 4, OWNER_UIC, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_PROTECTION]	! Process the /PROTECTION qualifer
THEN
    BUILD_LIST (MNT$_VPROT, 4, PROTECTION, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_NOQUO_C]		! Process the /CACHE=([NO]QUOTA) qualifier
THEN
    BUILD_LIST (MNT$_QUOTA, 4, ZERO, END_OF_LIST);
IF .QUO_CACHE GTR 0
THEN
    BUILD_LIST (MNT$_QUOTA, 4, QUO_CACHE, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_RECORDSZ]	! Process the /RECORDSIZE qualifier
THEN
BUILD_LIST (MNT$_RECORDSIZ, 4, RECORDSZ, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_WINDOW]		! Process the /WINDOWS qualifier
THEN
    BUILD_LIST (MNT$_WINDOW, 4, WINDOW, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_EXTENSION]	! Process the /EXTENSION qualifier
THEN
    BUILD_LIST (MNT$_EXTENSION, 4, EXTENSION, END_OF_LIST);

IF .MOUNT_OPTIONS [OPT_COMMENT]		! Process the /COMMENT qualifier
THEN
    BUILD_LIST (MNT$_COMMENT, .COMMENT_STRING [0], .COMMENT_STRING [1], END_OF_LIST);

!
! Set the MOUNT flags according to their counterparts in MOUNT_OPTIONS.
!
MOUNT_FLAGS [MNT$V_NODISKQ]	= .MOUNT_OPTIONS [OPT_NOQUOTA];
MOUNT_FLAGS [MNT$V_NOHDR3]	= .MOUNT_OPTIONS [OPT_NOHDR3];
MOUNT_FLAGS [MNT$V_SHARE]	= .MOUNT_OPTIONS [OPT_SHARE];
MOUNT_FLAGS [MNT$V_NOWRITE]	= NOT .MOUNT_OPTIONS [OPT_WRITE];
MOUNT_FLAGS [MNT$V_MESSAGE]	= .MOUNT_OPTIONS [OPT_MESSAGE];
MOUNT_FLAGS [MNT$V_NOMNTVER]	= NOT .MOUNT_OPTIONS [OPT_MOUNTVER];
MOUNT_FLAGS [MNT$V_OVR_LOCK]	= .MOUNT_OPTIONS [OPT_OVR_LOCK];
MOUNT_FLAGS [MNT$V_NOCACHE]	= .MOUNT_OPTIONS [OPT_NOCACHE];
MOUNT_FLAGS [MNT$V_READCHECK]	= .MOUNT_OPTIONS [OPT_READCHECK];
MOUNT_FLAGS [MNT$V_WRITECHECK]	= .MOUNT_OPTIONS [OPT_WRITECHECK];
MOUNT_FLAGS [MNT$V_WRITETHRU]	= .MOUNT_OPTIONS [OPT_WTHRU];
MOUNT_FLAGS [MNT$V_NOASSIST]	= NOT .MOUNT_OPTIONS [OPT_ASSIST];
MOUNT_FLAGS [MNT$V_FOREIGN]	= (.MOUNT_OPTIONS [OPT_FOREIGN] OR .MOUNT_OPTIONS [OPT_NOLABEL]);
MOUNT_FLAGS [MNT$V_GROUP]	= .MOUNT_OPTIONS [OPT_GROUP];
MOUNT_FLAGS [MNT$V_SYSTEM]	= .MOUNT_OPTIONS [OPT_SYSTEM];
MOUNT_FLAGS [MNT$V_OVR_EXP]	= .MOUNT_OPTIONS [OPT_OVR_EXP];
MOUNT_FLAGS [MNT$V_OVR_IDENT]	= .MOUNT_OPTIONS [OPT_OVR_ID];
MOUNT_FLAGS [MNT$V_OVR_ACCESS]	= .MOUNT_OPTIONS [OPT_OVR_ACC];

!
! Build an item list entry for mount flags, then terminate the item
! list with a zero value.
!
BUILD_LIST (MNT$_FLAGS, 4, MOUNT_FLAGS, END_OF_LIST);
.END_OF_LIST = 0;

!
! Now that all the parameters have been parsed, call the $MOUNT system service.
! Note the informational messages may be issued from mount via a $PUTMSG and
! a status value from the call will be returned as well.
!
STATUS = $MOUNT (ITMLST = ITEM_LIST);		! Mount the volume(s)

RETURN (.STATUS)				! Return status of $MOUNT call

END;						! end of routine PARSE_COMMAND

ROUTINE BUILD_LIST (ITEM_CODE, ITEM_LENGTH, ITEM_ADDRESS, LIST_PTR) : NOVALUE =

!++
! Functional description:
!
!	This routine will build an item list entry from the input parameters.
!
! Input:
!
!	ITEM_ADDRESS	: Address of item
!	ITEM_CODE	: Item code value
!	ITEM_LENGTH	: Length of item (in bytes)
!	LIST_PTR	: Address of a pointer to the end of the list
!	
!
! Implicit Input:
!
!	The list is assumed to be long enough.
!
! Output:
!
!	LIST		: points to new end of list
!
! Implict output:
!
!	None.
!
! Side effects:
!
!	None.
!
! Routine value:
!
!	None.
!--

BEGIN						! Start of BUILD_ENTRY

LOCAL
	LIST		: REF BBLOCK;

MACRO
	LENGTH		=  0, 0, 16, 0%,
	CODE		=  2, 0, 16, 0%,
	ADDRESS		=  4, 0, 32, 0%,
	UNUSED		=  8, 0, 32, 0%;

LIST = ..LIST_PTR;				! Get address of start of entry
LIST [LENGTH] = .ITEM_LENGTH;			! Set the item length
LIST [CODE] = .ITEM_CODE;			! Set the item code
LIST [ADDRESS] = .ITEM_ADDRESS;			! Set the item address
LIST [UNUSED] = 0;				! Clear the unused portion
.LIST_PTR = .LIST + ITEM_SIZE;			! Set new end of list

END;						! End of BUILD_ENTRY

ROUTINE MAIN_HANDLER (SIGNAL, MECHANISM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the main level condition handler for the MOUNT
!	utility. It undoes anything that MOUNT has done so far and returns
!	the condition code as status to MOUNT's	caller (i.e., the CLI).
!
!
! CALLING SEQUENCE:
!	MAIN_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal array
!	ARG2: address of mechanism array
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	stack unwound, control passed to CLI
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal array
	MECHANISM	: REF BBLOCK;	! mechanism array


! Force the facility code to be mount and resignal the
! error to be printed by the catch all handler.
!

IF .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] EQL 0
OR .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] EQL INIT$_FACILITY
THEN BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] = MOUN$_FACILITY;

RETURN SS$_RESIGNAL;

END;					! end of routine MAIN_HANDLER

!+
!
! Parameter and qualifier action routines. Each routine is named corresponding
! to its associated parameter of qualifier. Each routine does whatever
! conversion is necessary and stores the parameter or qualifier value in
! the appropriate location in the output area.
!
!-


!
! CLI error action routine. This routine is called on all CLI errors.
! It simply signalls the error back to main level.
!
ROUTINE PARSE_ERROR (REQ_DESC, ERROR_CODE) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

SIGNAL_STOP (.ERROR_CODE);

END;					! end of routine PARSE_ERROR

!
! Get device name
!
ROUTINE DEVICE_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

! Clear the parameter required bit for succeeding calls. Count the device
! and enter the name descriptor into the device list.
!

REQ_DESC[CLI$V_PARMREQ] = 0;

IF .DEVICE_COUNT GEQ DEVMAX THEN ERR_EXIT (MOUN$_MAXDEV);
DEVICE_STRING[.DEVICE_COUNT*2] = .REQ_DESC[CLI$W_RQSIZE];
DEVICE_STRING[.DEVICE_COUNT*2+1] = .REQ_DESC[CLI$A_RQADDR];
DEVICE_COUNT = .DEVICE_COUNT + 1;

END;					! end of routine DEVICE_ACT

!
! Get volume label
!
ROUTINE LABEL_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

! Clear the parameter required bit for succeeding calls. Count the label
! and enter the name descriptor into the label list.
!

REQ_DESC[CLI$V_PARMREQ] = 0;

IF .LABEL_COUNT GEQ LABMAX THEN ERR_EXIT (MOUN$_MAXLAB);
LABEL_STRING[.LABEL_COUNT*2] = .REQ_DESC[CLI$W_RQSIZE];
LABEL_STRING[.LABEL_COUNT*2+1] = .REQ_DESC[CLI$A_RQADDR];
LABEL_COUNT = .LABEL_COUNT + 1;

END;					! end of routine LABEL_ACT

!
! Get logical name
!
ROUTINE LOG_NAME_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	P;				! string scan pointer

! Simply copy the logical name descriptor.
!

LOG_NAME[0] = .REQ_DESC[CLI$W_RQSIZE];
LOG_NAME[1] = .REQ_DESC[CLI$A_RQADDR];

! Scan for a trailing or embedded colon. If found, use string preceding
! the colon.
!

P = CH$FIND_CH (.LOG_NAME[0], .LOG_NAME[1], ':');
IF NOT CH$FAIL (.P)
THEN LOG_NAME[0] = .P - .LOG_NAME[1];

IF .REQ_DESC[CLI$W_RQSIZE] GTR LOG$C_NAMLENGTH-1
THEN ERR_EXIT (MOUN$_LOGNAME);

END;					! end of routine LOG_NAME_ACT

!
! Set magtape density
!
ROUTINE DENSITY_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	DENSITY_STB	: VECTOR [0],	! state table address
	DENSITY_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the density string (setting the DENS_1600 bit if so).
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, DENSITY_STB, DENSITY_KTB)
THEN ERR_EXIT (MOUN$_BADDENS);

END;					! end of routine DENSITY_ACT

!
! Get structure name string
!
ROUTINE BIND_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

! Simply save away the descriptor.
!

STRUCT_NAME[0] = .REQ_DESC[CLI$W_QDVALSIZ];
STRUCT_NAME[1] = .REQ_DESC[CLI$A_QDVALADR];

END;					! end of routine BIND_ACT

!
! Get visual-ID string
!
ROUTINE VID_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

! Simply save away the descriptor.
!

IF .REQ_DESC[CLI$W_QDVALSIZ] NEQ 0
THEN
    BEGIN
    MOUNT_OPTIONS[OPT_VID] = 1;
    VID_STRING[0] = .REQ_DESC[CLI$W_QDVALSIZ];
    VID_STRING[1] = .REQ_DESC[CLI$A_QDVALADR];
    END;

END;					! end of routine VID_ACT

!
! Get comment string
!
ROUTINE COMMENT_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

! Simply save away the descriptor.
!

IF .REQ_DESC[CLI$W_QDVALSIZ] NEQ 0
THEN
    BEGIN
    MOUNT_OPTIONS[OPT_COMMENT] = 1;
    COMMENT_STRING[0] = .REQ_DESC[CLI$W_QDVALSIZ];
    COMMENT_STRING[1] = .REQ_DESC[CLI$A_QDVALADR];
    END;

END;					! end of routine COMMENT_ACT

ROUTINE BLOCK_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! If there is a value, convert it to the numerical blocksize.
!

IF .REQ_DESC[CLI$W_QDVALSIZ] NEQ 0
THEN
    BEGIN
    STATUS = (.CLI_CALLBACK) (CONVERT_NUMBER, CLI_WORK_AREA, .REQ_DESC);
    IF NOT .STATUS THEN ERR_EXIT (.STATUS);
    IF .CONVERT_NUMBER[CLI$L_RQVALU] GTRU 65534
    THEN ERR_EXIT(MOUN$_SZTOOBIG);
    MOUNT_OPTIONS[OPT_BLOCKSIZE] = 1;
    BLOCKSIZE = .CONVERT_NUMBER[CLI$L_RQVALU];
    END;

END;					! end of routine BLOCK_ACT

ROUTINE RECORD_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! If there is a value, convert it to the numerical record size.
!

IF .REQ_DESC[CLI$W_QDVALSIZ] NEQ 0
THEN
    BEGIN
    STATUS = (.CLI_CALLBACK) (CONVERT_NUMBER, CLI_WORK_AREA, .REQ_DESC);
    IF NOT .STATUS THEN ERR_EXIT (.STATUS);
    IF .CONVERT_NUMBER[CLI$L_RQVALU] GTRU 65534
    THEN ERR_EXIT(MOUN$_SZTOOBIG);
    MOUNT_OPTIONS[OPT_RECORDSZ] = 1;
    RECORDSZ = .CONVERT_NUMBER[CLI$L_RQVALU];
    END;

END;					! end of routine RECORD_ACT

ROUTINE SHARE_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! This does bit fixups and validation on the /SHARE - /NOSHARE qualifier that
! are not possible with the CLI bitlist processing.
!

IF .MOUNT_OPTIONS[OPT_GROUP] OR .MOUNT_OPTIONS[OPT_SYSTEM]
THEN
    BEGIN
    IF .REQ_DESC[CLI$V_QUALEXP]
    THEN ERR_EXIT (MOUN$_CONFQUAL)
    ELSE MOUNT_OPTIONS[OPT_NOSHARE] = 0;
    END;

END;					! end of routine SHARE_ACT

ROUTINE NOLABEL_ACT (REQ_DESC, CLI_CALLBACK) =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! If a device is being mounted /FOREIGN or /OVER:ID or /NOLABEL and /NOSHARE,
! the volume label is optional.
!

IF .MOUNT_OPTIONS[OPT_NOSHARE]
THEN GET_LABEL[CLI$V_PARMREQ] = 0;
RETURN 1;

END;					! end of routine NOLABEL_ACT

!
! Set EBCDIC mode
!
ROUTINE EBCDIC_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	EBCDIC_STB	: VECTOR [0],	! state table address
	EBCDIC_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the options string, setting the appropriate bits.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, EBCDIC_STB, EBCDIC_KTB)
THEN ERR_EXIT (MOUN$_BADEBC);

END;					! end of routine EBCDIC_ACT

ROUTINE EXTENSION_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! Convert the value string to its numerical value.
!

STATUS = (.CLI_CALLBACK) (CONVERT_NUMBER, CLI_WORK_AREA, .REQ_DESC);
IF NOT .STATUS THEN ERR_EXIT (.STATUS);
EXTENSION = .CONVERT_NUMBER[CLI$L_RQVALU];

END;					! end of routine EXTENSION_ACT

ROUTINE WINDOW_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! Convert the value string to its numerical value.
!

STATUS = (.CLI_CALLBACK) (CONVERT_NUMBER, CLI_WORK_AREA, .REQ_DESC);
IF NOT .STATUS THEN ERR_EXIT (.STATUS);
WINDOW = .CONVERT_NUMBER[CLI$L_RQVALU];

END;					! end of routine WINDOW_ACT

ROUTINE ACCESSED_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! Convert the value string to its numerical value.
!

STATUS = (.CLI_CALLBACK) (CONVERT_NUMBER, CLI_WORK_AREA, .REQ_DESC);
IF NOT .STATUS THEN ERR_EXIT (.STATUS);
ACCESSED = .CONVERT_NUMBER[CLI$L_RQVALU];

END;					! end of routine ACCESSED_ACT

ROUTINE PROTECTION_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	PROTECTION_STB	: VECTOR [0],	! state table address
	PROTECTION_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the switch value string (storing the binary protection).
! Complement thereafter, since the parser produces the complement.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, PROTECTION_STB, PROTECTION_KTB)
THEN ERR_EXIT (MOUN$_BADPRO);

PROTECTION<0,16> = NOT .PROTECTION<0,16>;

END;					! end of routine PROTECTION_ACT

ROUTINE DATACHECK_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	DATACHECK_STB	: VECTOR [0],	! state table address
	DATACHECK_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the DATACHECK options string.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, DATACHECK_STB, DATACHECK_KTB)
THEN ERR_EXIT (MOUN$_BADDATCHK);

END;					! end of routine DATACHECK_ACT

ROUTINE OWNER_UIC_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	UIC_STB		: VECTOR [0],	! state table address
	UIC_KTB		: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the UIC string and store it in the owner UIC longword.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, UIC_STB, UIC_KTB)
THEN ERR_EXIT (MOUN$_BADUIC);
OWNER_UIC = .UIC;

END;					! end of routine OWNER_UIC_ACT

ROUTINE USER_UIC_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	UIC_STB		: VECTOR [0],	! state table address
	UIC_KTB		: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the UIC string and store it in the user UIC longword.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, UIC_STB, UIC_KTB)
THEN ERR_EXIT (MOUN$_BADUIC);
USER_UIC = .UIC;

END;					! end of routine USER_UIC_ACT

ROUTINE OVERRIDE_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	OVERRIDE_STB	: VECTOR [0],	! state table address
	OVERRIDE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the OVERRIDE string and set appropriate flags.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, OVERRIDE_STB, OVERRIDE_KTB)
THEN ERR_EXIT (MOUN$_BADOVR);

IF .MOUNT_OPTIONS[OPT_OVR_ID]
THEN GET_LABEL[CLI$V_PARMREQ] = 0;

END;					! end of routine OVERRIDE_ACT

ROUTINE CACHE_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	CACHE_STB	: VECTOR [0],	! state table address
	CACHE_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the cache control options and set appropriate flags.
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, CACHE_STB, CACHE_KTB)
THEN ERR_EXIT (MOUN$_BADCACHE);

IF .MOUNT_OPTIONS[OPT_OVR_ID]
THEN GET_LABEL[CLI$V_PARMREQ] = 0;

END;					! end of routine CACHE_ACT

ROUTINE NOCACHE_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

! This routine sets all of the cache inhibit options if the /NOCACHE
! qualifier was explicit.
!

IF .REQ_DESC[CLI$V_QUALEXP]
THEN
    BEGIN
    MOUNT_OPTIONS[OPT_NOCACHE] = 1;
    MOUNT_OPTIONS[OPT_WTHRU] = 1;
    MOUNT_OPTIONS[OPT_NOEXT_C] = 1;
    MOUNT_OPTIONS[OPT_NOFID_C] = 1;
    MOUNT_OPTIONS[OPT_NOQUO_C] = 1;
    END;

END;					! end of routine NOCACHE_ACT

ROUTINE PROCESSOR_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

EXTERNAL
	PROCESSOR_STB	: VECTOR [0],	! state table address
	PROCESSOR_KTB	: VECTOR [0];	! keyword table address

EXTERNAL ROUTINE
	LIB$TPARSE;

! Parse the PROCESSOR switch options (leaving values and bits set).
!

TPARSE_BLOCK[TPA$L_STRINGCNT] = .REQ_DESC[CLI$W_QDVALSIZ];
TPARSE_BLOCK[TPA$L_STRINGPTR] = .REQ_DESC[CLI$A_QDVALADR];
IF NOT LIB$TPARSE (TPARSE_BLOCK, PROCESSOR_STB, PROCESSOR_KTB)
THEN ERR_EXIT (MOUN$_BADACP);

END;					! end of routine PROCESSOR_ACT

ROUTINE DRIVES_ACT (REQ_DESC, CLI_CALLBACK) : NOVALUE =
BEGIN

MAP
	REQ_DESC	: REF BBLOCK;

LOCAL
	STATUS;

! Convert the value string to its numerical value.
!

STATUS = (.CLI_CALLBACK) (CONVERT_NUMBER, CLI_WORK_AREA, .REQ_DESC);
IF NOT .STATUS THEN ERR_EXIT (.STATUS);
MOUNT_OPTIONS[OPT_DRIVES] = 1;
DRIVE_COUNT[.DEVICE_COUNT] = .CONVERT_NUMBER[CLI$L_RQVALU];

END;					! end of routine DRIVES_ACT

!+
!
! TPARSE action routines for the following TPARSE tables.
!
!-

!
! Store UIC group number
!
ROUTINE GET_UIC_GROUP =
BEGIN

TPARSE_ARGS (CONTEXT);

UIC<16,16> = .CONTEXT[TPA$L_NUMBER];
RETURN 1;

END;					! end of routine GET_UIC_GROUP

!
! Store UIC member number
!
ROUTINE GET_UIC_MEMBER =
BEGIN

TPARSE_ARGS (CONTEXT);

UIC<0,16> = .CONTEXT[TPA$L_NUMBER];
RETURN 1;

END;					! end of routine GET_UIC_MEMBER

!
! Store ACP string (either device name or file name).
!
ROUTINE GET_ACP_NAME =
BEGIN

TPARSE_ARGS (CONTEXT);

IF .CONTEXT[TPA$L_TOKENCNT] GTR 20
THEN ERR_EXIT (MOUN$_ACPNAME);

ACP_STRING[0] = .CONTEXT[TPA$L_TOKENCNT];
ACP_STRING[1] = .CONTEXT[TPA$L_TOKENPTR];
RETURN 1;

END;					! end of routine GET_ACP_NAME

!
! Store ACP string as specified by the :SAME option.
! Append a ":" to the device name.
!
ROUTINE GET_SAME_ACP =
BEGIN

OWN
	SAME_ACP	: VECTOR [21,BYTE];

TPARSE_ARGS (CONTEXT);

IF .CONTEXT[TPA$L_TOKENCNT] GTR 20
THEN ERR_EXIT (MOUN$_ACPNAME);

! Copy device name to internal storage, and append a colon to it.
!
CH$MOVE (.CONTEXT[TPA$L_TOKENCNT], .CONTEXT[TPA$L_TOKENPTR], SAME_ACP);
SAME_ACP [.CONTEXT [TPA$L_TOKENCNT]] = %ASCII ':';
ACP_STRING[0] = .CONTEXT[TPA$L_TOKENCNT] + 1;
ACP_STRING[1] = SAME_ACP;
RETURN 1;

END;					! end of routine GET_SAME_ACP

!+
!
! TPARSE state tables to parse the various qualifier value strings.
!
!-

!
! Parse magtape density (either "800" or "1600").
!
$INIT_STATE (DENSITY_STB, DENSITY_KTB);

$STATE	(,
	('6250'),
	('1600',,, 1^(OPT_DENS_1600 - 32), MOUNT_OPTIONS + 4),
	('800',,, 1^OPT_DENS_800, MOUNT_OPTIONS)
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse EBCDIC options: LABELS, DATA, both, or neither (implying both).
!
$INIT_STATE (EBCDIC_STB, EBCDIC_KTB);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT,, 1^OPT_EBC_DATA OR 1^OPT_EBC_LABELS, MOUNT_OPTIONS),
	(TPA$_LAMBDA)
	);

$STATE	(EBCOPT,
	('DATA',,, 1^OPT_EBC_DATA, MOUNT_OPTIONS),
	('LABELS',,, 1^OPT_EBC_LABELS, MOUNT_OPTIONS)
	);

$STATE	(,
	(',', EBCOPT),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse data check options, of the form [READ][,WRITE]. Default is write.
!
$INIT_STATE (DATACHECK_STB, DATACHECK_KTB);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT,, 1^(OPT_WRITECHECK-32), MOUNT_OPTIONS+4),
	(TPA$_LAMBDA)
	);

$STATE	(CHECKOPT,
	('READ',,, 1^(OPT_READCHECK-32), MOUNT_OPTIONS+4),
	('WRITE',,, 1^(OPT_WRITECHECK-32), MOUNT_OPTIONS+4)
	);

$STATE	(,
	(',', CHECKOPT),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse protection string "(SYSTEM:RWED,OWNER:RWED,GROUP:RWED,WORLD:RWED)"
!
$INIT_STATE (PROTECTION_STB, PROTECTION_KTB);

$STATE	(NEXTPRO,
	('SYSTEM', SYPR,, %X'000F0000', PROTECTION),
	('OWNER',  OWPR,, %X'00F00000', PROTECTION),
	('GROUP',  GRPR,, %X'0F000000', PROTECTION),
	('WORLD',  WOPR,, %X'F0000000', PROTECTION)
	);

$STATE	(SYPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(SYPR0,
	('R', SYPR0,, %X'0001', PROTECTION),
	('W', SYPR0,, %X'0002', PROTECTION),
	('E', SYPR0,, %X'0004', PROTECTION),
	('P', SYPR0,, %X'0004', PROTECTION),
	('D', SYPR0,, %X'0008', PROTECTION),
	('L', SYPR0,, %X'0008', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(OWPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(OWPR0,
	('R', OWPR0,, %X'0010', PROTECTION),
	('W', OWPR0,, %X'0020', PROTECTION),
	('E', OWPR0,, %X'0040', PROTECTION),
	('P', OWPR0,, %X'0040', PROTECTION),
	('D', OWPR0,, %X'0080', PROTECTION),
	('L', OWPR0,, %X'0080', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(GRPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(GRPR0,
	('R', GRPR0,, %X'0100', PROTECTION),
	('W', GRPR0,, %X'0200', PROTECTION),
	('E', GRPR0,, %X'0400', PROTECTION),
	('P', GRPR0,, %X'0400', PROTECTION),
	('D', GRPR0,, %X'0800', PROTECTION),
	('L', GRPR0,, %X'0800', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(WOPR,
	(':'),
	('='),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(WOPR0,
	('R', WOPR0,, %X'1000', PROTECTION),
	('W', WOPR0,, %X'2000', PROTECTION),
	('E', WOPR0,, %X'4000', PROTECTION),
	('P', WOPR0,, %X'4000', PROTECTION),
	('D', WOPR0,, %X'8000', PROTECTION),
	('L', WOPR0,, %X'8000', PROTECTION),
	(TPA$_LAMBDA, ENDPRO)
	);

$STATE	(ENDPRO,
	(',', NEXTPRO),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse UIC string and store binary value.
!
$INIT_STATE (UIC_STB, UIC_KTB);

$STATE	(,
	('['),
	('<')
	);

$STATE	(,
	(TPA$_OCTAL,, GET_UIC_GROUP)
	);

$STATE	(,
	(',')
	);

$STATE	(,
	(TPA$_OCTAL,, GET_UIC_MEMBER)
	);

$STATE	(,
	(']'),
	('>')
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse OVERRIDE options (ACCESSIBILITY, EXPIRATION, SETIDENTIFICATION, IDENTIFICATION).
!
$INIT_STATE (OVERRIDE_STB, OVERRIDE_KTB);

$STATE	(NEXTOVR,
	('ACCESSIBILITY',,,1^(OPT_OVR_ACC-32), MOUNT_OPTIONS+4),
	('EXPIRATION',,, 1^OPT_OVR_EXP, MOUNT_OPTIONS),
	('SETIDENTIFICATION',,, 1^OPT_OVR_SETID, MOUNT_OPTIONS),
	('LOCK',,,1^(OPT_OVR_LOCK-32), MOUNT_OPTIONS+4),
	('IDENTIFICATION',, NOLABEL_ACT, 1^OPT_OVR_ID, MOUNT_OPTIONS)
	);

$STATE	(,
	(',',NEXTOVR),
	(TPA$_EOS, TPA$_EXIT)
	);

!
! Parse CACHE options (EXTENT=n, LIMIT=n, FILE_ID=n, QUOTA=n, NOEXTENT,
! NOFILE_ID, NOQUOTA, and WRITETHROUGH).
!
$INIT_STATE (CACHE_STB, CACHE_KTB);

$STATE	(NEXT_CACHE,
	('EXTENT',	CACHE_EXT,,	1^(OPT_CACHE-32), MOUNT_OPTIONS+4),
	('FILE_ID',	CACHE_FID,,	1^(OPT_CACHE-32), MOUNT_OPTIONS+4),
	('LIMIT',	LIMIT_EXT),
	('NOEXTENT',,,			1^(OPT_NOEXT_C-32), MOUNT_OPTIONS+4),
	('NOFILE_ID',,,			1^(OPT_NOFID_C-32), MOUNT_OPTIONS+4),
	('NOQUOTA',,,			1^(OPT_NOQUO_C-32), MOUNT_OPTIONS+4),
	('NOWRITETHROUGH'),
	('QUOTA',	CACHE_QUO,,	1^(OPT_CACHE-32), MOUNT_OPTIONS+4),
	('WRITETHROUGH',,,		1^(OPT_WTHRU-32), MOUNT_OPTIONS+4)
	);

$STATE	(END_CACHE,
	(',', NEXT_CACHE),
	(TPA$_EOS, TPA$_EXIT)
	);

$STATE	(CACHE_EXT,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	EXT_CACHE)
	);


$STATE	(CACHE_FID,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	FID_CACHE)
	);


$STATE	(CACHE_QUO,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	QUO_CACHE)
	);

$STATE	(LIMIT_EXT,
	(':'),
	('=')
	);

$STATE	(,
	(TPA$_DECIMAL,	END_CACHE,,,	EXT_LIMIT)
	);
!
! Parse PROCESSOR options, set bits and store name.
!
$INIT_STATE (PROCESSOR_STB, PROCESSOR_KTB);

$STATE	(,
	('UNIQUE',, GET_ACP_NAME, 1^OPT_UNIQUEACP, MOUNT_OPTIONS),
	('SAME', SAMEPROC,, 1^OPT_SAMEACP, MOUNT_OPTIONS),
	((FILENAME),, GET_ACP_NAME, 1^OPT_FILEACP, MOUNT_OPTIONS)
	);

$STATE	(ENDPROC,
	(TPA$_EOS, TPA$_EXIT)
	);

$STATE	(SAMEPROC,
	(':'),
	('=')
	);

$STATE	(,
	((DEVICENAME),, GET_ACP_NAME),
	(TPA$_SYMBOL,, GET_SAME_ACP)
	);

$STATE	(,
	(TPA$_LAMBDA, TPA$_EXIT)
	);

$STATE	(FILENAME,
	(TPA$_SYMBOL, FILENAME),
	('.', FILENAME),
	(';', FILENAME),
	(TPA$_LAMBDA, TPA$_EXIT)
	);

$STATE	(DEVICENAME,
	(TPA$_SYMBOL)
	);

$STATE	(,
	(':')
	);

$STATE	(,
	(TPA$_EOS, TPA$_EXIT)
	);

END
ELUDOM
