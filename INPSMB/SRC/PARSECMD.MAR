	.TITLE	PARSECMD - INPUT SYMBIONT COMMAND PARSER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; FACILITY:  VAX/VMS INPUT SYMBIONT
;
; ABSTRACT:	THIS MODULE CONTAINS THE COMMAND PARSER FOR THE JOB,
;		PASSWORD, AND EOJ CARDS.
;
;
; ENVIRONMENT:	USER MODE
;
;
; AUTHOR:	LEN KAWELL, CREATION DATE: 8-MAR-78
;
; MODIFIED BY:
;
;	V02-002	MLJ0071		Martin L. Jack,	17-Jan-1982  21:56
;		Incorporate standard queue name translation.  Translate null
;		parameter to a one-byte hex FF.  A corresponding change in DCL
;		turns this back into a null parameter.
;
;	V02-001	MSH0001		Maryann S. Hinden	20-NOV-1981
;		Make references to library routines external.
;--

;
; INCLUDE FILES:
;
;	[INPSMB.SRC]PREFIX.MAR
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	$JBCMSGDEF			;JOB CONTROLLER MESSAGES
	$TPADEF				;TPARSE DEFINTIONS
	$SMRDEF				;SYMBIONT MANAGER MESSAGES
	$SHRDEF				;SHARED MESSAGES
	$UAFDEF				;USER ACCESS FILE DEFINITIONS
COMMA	= ^A\,\				;LITERAL COMMA

;
; OWN STORAGE:
;

	IMPURE_DATA

;
; TPARSE PARAMETER BLOCK
;
TPARSE_BLOCK:
	.LONG	TPA$K_COUNT0		;PARAMETER COUNT
	.LONG	TPA$M_ABBREV		;ALLOW ABBREVIATIONS
	.BLKL	TPA$K_LENGTH0-8		;REMAINDER SET AT RUNTIME

;
; TEMPORARY TOKEN DESCRIPTOR
;
TOKEN_DESC:
	.BLKQ	1
QUEUE_DESC:
	.BLKQ	1			; Descriptor for queue name

	PURE_SECTION

;
; DEFAULT QUEUE NAME
;
DEF_QUEUE:
	.ASCID	\SYS$BATCH\

;
; DEFAULT JOB NAME
;
DEF_JOBNAME:
	STRING_DESC	<INPBATCH>

;
; EOJ/JOB STRING TABLE
;
EOJ_TABLE:				; *** NOTE: ORDER IS SIGNIFICANT
	.ASCII	/EOJ/
	.ASCII	/JOB/

	.PAGE
	.SBTTL	JOB CARD PARSER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	PARSES THE JOB CARD USING LIB$TPARSE
;
; CALLING SEQUENCE:
;
;	BSBW	INP$PARSE_JOB
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS ADDRESS OF INPUT
;	R7 CONTAINS BYTE COUNT
;
; IMPLICIT INPUTS:
;
;	R11 CONTAINS ADDRESS OF INP$G_DATA
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	VARIOUS DATA STRUCTURES SETUP FROM JOB CARD FIELDS
;
; COMPLETION CODES
;
;	R0 CONTAINS - LIB$_NORMAL IF SYNTAX OK
;
; SIDE EFFECTS:
;
;	IF SYNTAX ERROR - ERROR SIGNALED
;
;--

	PURE_SECTION

	.ENABL	LSB

INP$PARSE_JOB::
	CLRW	ID_L_FLAGS(R11)		;CLEAR ALL THE JOB CARD FLAGS
	MOVQ	W^DEF_QUEUE,W^QUEUE_DESC ; Set descriptor for default queue
	MOVQ	W^DEF_JOBNAME,ID_Q_JOBNM_DESC(R11) ;SET DEFAULT JOB NAME
	MOVL	#8,ID_Q_ACCNT_DESC(R11)	;SET DEFAULT ACCOUNT
	MOVAL	W^UAF$T_ACCOUNT+INP$T_UAFBUF,-
		ID_Q_ACCNT_DESC+4(R11)

	MOVQ	R6,W^TPA$L_STRINGCNT+TPARSE_BLOCK ;SET STRING SIZE & ADDRESS
	MOVAL	W^SM_T_OPTIONS+INP$G_SYMMSG,R0	;GET OPTIONS LIST ADDRESS
	MOVW	#SMO$K_JOBPRI,(R0)+	;SET PRIORITY INITIALLY TO ZERO
	MOVL	R0,ID_L_OPT_PTR(R11)	;SAVE OPTION LIST POINTER
	PUSHAL	W^JOB_KEY		;SET KEY TABLE ADDRESS
	PUSHAL	W^JOB_STATE		;SET STATE TABLE ADDRESS
	PUSHAL	W^TPARSE_BLOCK		;SET PARAMETER BLOCK ADDRESS
	CALLS	#3,G^LIB$TPARSE		;ATTEMPT TO PARSE JOB CARD
	PUSHAB	W^SM_T_QUEUE+INP$G_SYMMSG ; Point to output area
	PUSHAQ	W^QUEUE_DESC		; Point to queue name
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	BLBS	R0,5$			;BR IF CONVERTED OK
	PUSHAQ	W^QUEUE_DESC		;ADDR OF TIME DESCRIPTOR
	PUSHL	#1			;1 FAO ARGUMENT
	PUSHL	#SHR$_BADQNAME!<4@16>	;CONDITON CODE
	CALLS	#3,G^LIB$SIGNAL		;SIGNAL THE ERROR
;
; PARSING COMPLETE, CHECK FOR ERRORS AND OPTIONS
;
5$:	BBC	#FLAG_V_NAME,ID_L_FLAGS(R11),JOB_EXIT ;BR IF NOT A $JOB CARD
	BLBS	R0,10$			;BR IF NO SYNTAX ERRORS
	PUSHAL	W^TPA$L_TOKENCNT+TPARSE_BLOCK ;ADDRESS OF TOKEN DESC
	PUSHL	#1			;1 FAO ARGUMENT
	PUSHL	#JBC$_JOBCRD		;SYNTAX ERROR MESSAGE
	CALLS	#3,G^LIB$SIGNAL		;SIGNAL THE ERROR
10$:	BBS	#FLAG_V_NODEL,ID_L_FLAGS(R11),JOB_EXIT ;BR IF NO DELETE
	MOVB	#SMO$K_DELETE,@ID_L_OPT_PTR(R11) ;SET DELETE
	INCL	ID_L_OPT_PTR(R11)	;INCREMENT LIST POINTER

JOB_EXIT:
	RSB				;RETURN

	.DSABL	LSB
	.PAGE
	.SBTTL	JOB CARD PARSING STATE TABLE

	.ENABL	LSB

	$INIT_STATE JOB_STATE,JOB_KEY
;
; CHECK THAT IT'S A $JOB CARD
;
	$STATE
	$TRAN	'$'
	$STATE
	$TRAN	'JOB',,GET_JOB_CONT,FLAG_M_JOB,ID_L_FLAGS+INP$G_DATA
;
; GET USER NAME
;
	$STATE
	$TRAN	TPA$_SYMBOL,MAIN,SET_USERNAME,-
		FLAG_M_NAME,ID_L_FLAGS+INP$G_DATA,12
;
; MAIN - CHECK FOR OPTIONS
;
	$STATE	MAIN
	$TRAN	'/'
	$TRAN	TPA$_EOS,TPA$_EXIT
;
; OPTION PROCESSING
;
	$STATE	OPTIONS
	$TRAN	'ACCOUNT',PARSE_ACCOUNT
	$TRAN	'AFTER',PARSE_TIME
	$TRAN	'DELETE',MAIN
	$TRAN	'NAME',PARSE_JOBNAME
	$TRAN	'NODELETE',MAIN,,FLAG_M_NODEL,ID_L_FLAGS+INP$G_DATA
	$TRAN	'NOTRAILING_BLANKS',MAIN,,-
		FLAG_M_NOTRAIL,ID_L_FLAGS+INP$G_DATA
	$TRAN	'PARAMETERS',PARSE_PARAM
	$TRAN	'PRIORITY',PARSE_PRIOR
	$TRAN	'QUEUE',PARSE_QUEUE
	$TRAN	'TRAILING_BLANKS',MAIN
	$TRAN	'CPUTIME',PARSE_CPUL
	$TRAN	'WSDEFAULT',PARSE_WSDE
	$TRAN	'WSQUOTA',PARSE_WSQU
;
; PARSE ACCOUNT NAME
;
	$STATE	PARSE_ACCOUNT
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_SYMBOL,MAIN,CHECK_SIZE,,-
		ID_Q_ACCNT_DESC+INP$G_DATA,8
;
; PARSE AFTER TIME
;
	$STATE	PARSE_TIME
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_STRING,,BLANKS_ON,,TOKEN_DESC

	$STATE	SCAN_TIME
	$TRAN	TPA$_BLANK,MAIN,SET_TIME
	$TRAN	'/',OPTIONS,SET_TIME
	$TRAN	TPA$_EOS,TPA$_EXIT,SET_TIME
	$TRAN	TPA$_ANY,SCAN_TIME
;
; PARSE JOB NAME
;
	$STATE	PARSE_JOBNAME
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_STRING,MAIN,CHECK_SIZE,,-
		ID_Q_JOBNM_DESC+INP$G_DATA,8
;
; PARSE THE PARAMETERS
;
	$STATE	PARSE_PARAM
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	'(',PARAM_LIST,START_PARAM
	$TRAN	!GET_PARAM,MAIN,SET_1PARAM

	$STATE	PARAM_LIST
	$TRAN	!GET_PARAM,,SET_PARAM
	$STATE
	$TRAN	COMMA,PARAM_LIST
	$TRAN	')',MAIN,END_PARAM
;
; SUB-EXPRESSION TO GET A PARAMETER
;
	$STATE	GET_PARAM
	$TRAN	'"',,BLANKS_ON
	$TRAN	TPA$_SYMBOL,TPA$_EXIT
	$STATE
	$TRAN	'"',TPA$_EXIT
	$TRAN	TPA$_ANY

	$STATE	SCAN_PARAM
	$TRAN	!LIT_QUOTE,SCAN_PARAM
	$TRAN	'"',TPA$_EXIT
	$TRAN	TPA$_ANY,SCAN_PARAM
;
; SUB-EXPRESSION TO CHECK FOR A LITERAL QUOTE ("")
;
	$STATE	LIT_QUOTE
	$TRAN	'"'
	$STATE
	$TRAN	'"',TPA$_EXIT,ZAP_QUOTE
;
; PARSE QUEUE PRIORITY
;
	$STATE	PARSE_PRIOR
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_DECIMAL,MAIN,SET_PRIOR
;
; PARSE QUEUE NAME
;
	$STATE	PARSE_QUEUE
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	TPA$_SYMBOL,MAIN,SET_QUEUE,,,16
;
; PARSE CPU TIME LIMIT
;
	$STATE	PARSE_CPUL
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	'NONE',MAIN,SET_NOCPUL
	$TRAN	'INFINITE',MAIN,SET_INFIN
	$TRAN	TPA$_STRING,,BLANKS_ON,,TOKEN_DESC
	$STATE	SCAN_CPUL
	$TRAN	TPA$_BLANK,MAIN,SET_CPUL
	$TRAN	'/',OPTIONS,SET_CPUL
	$TRAN	TPA$_EOS,TPA$_EXIT,SET_CPUL
	$TRAN	TPA$_ANY,SCAN_CPUL
;
; PARSE WORKING SET DEFAULT
;
	$STATE	PARSE_WSDE
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	'NONE',MAIN,SET_NOWSDE
	$TRAN	TPA$_DECIMAL,MAIN,SET_WSDE
;
; PARSE WORKING SET QUOTA
;
	$STATE	PARSE_WSQU
	$TRAN	':'
	$TRAN	'='
	$STATE
	$TRAN	'NONE',MAIN,SET_NOWSQU
	$TRAN	TPA$_DECIMAL,MAIN,SET_WSQU

	$END_STATE

	.DSABL	LSB

	PURE_SECTION
;
; SET USERNAME
;
SET_USERNAME:
	.WORD	0
	MOVQ	TPA$L_TOKENCNT(AP),W^ID_Q_UNAME_DESC+INP$G_DATA ;SET DESCRIPTOR
	CALLG	(AP),W^CHECK_SIZE	;CHECK NAME STRING SIZE
	BLBC	R0,10$			;BR IF TOO LONG
	$CMKRNL_S W^INP$SET_UNAME,-	;CHANGE TO KERNAL TO SET NAME
		  W^ID_Q_UNAME_DESC+INP$G_DATA
	MOVL	#1,R0			;SET STATUS TO SUCCESS
10$:	RET				;RETURN

;
; SET QUEUE NAME
;
SET_QUEUE:
	.WORD	^M<R2,R3,R4,R5>
	MOVQ	TPA$L_TOKENCNT(AP),-	; Save descriptor for queue name
		W^QUEUE_DESC
	MOVL	#1,R0			;SET SUCCESS
10$:	RET				;RETURN
;
; SET THE PRIORITY
;
SET_PRIOR:
	.WORD	0
	MOVB	TPA$L_NUMBER(AP),W^SM_T_OPTIONS+INP$G_SYMMSG+1 ;SET PRIORITY
	RET
;
; SET THE AFTER TIME
;
SET_TIME:	
	.WORD	^M<R3,R4>
	CLRBIT	TPA$V_BLANKS,TPA$L_OPTIONS(AP) ;TURN OFF BLANKS
	SUBL3	W^TOKEN_DESC+4,TPA$L_TOKENPTR(AP),- ;COMPUTE STRING LENGTH
		W^TOKEN_DESC
	CLRQ	-(SP)			;CREATE A QUAD WORD BUFFER
	PUSHAQ	(SP)			;1ST ARG IS ADDR OF TIME BUFFER
	PUSHAQ	W^TOKEN_DESC		;2ND ARG IS ADDR OF INPUT DESC
	CALLS	#2,G^LIB$CVT_TIME	;CONVERT THE TIME
	BLBS	R0,10$			;BR IF CONVERTED OK
	PUSHAQ	W^TOKEN_DESC		;ADDR OF TIME DESCRIPTOR
	PUSHL	#1			;1 FAO ARGUMENT
	PUSHL	#SHR$_BADTIME!<4@16>	;CONDITON CODE
	CALLS	#3,G^LIB$SIGNAL		;SIGNAL THE ERROR
	BRB	20$			;QUIT
10$:	MOVL	#9,R4			;9 BYTES FOR THIS OPTION
	BSBW	OPTION_ROOM		;CHECK FOR ROOM IN MESSAGE BUFFER
	MOVB	#SMO$K_RLSTIM,(R3)+	;SET OPTION CODE IN MESSAGE
	MOVQ	(SP)+,(R3)+		;SET TIME VALUE IN MESSAGE
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA ;RE-SET OPTION POINTER
20$:	RET
;
; ROUTINE TO SET START OF PARAMETERS IN MESSAGE BUFFER
;
START_PARAM:
	.WORD	^M<R4,R3>
	MOVL	#1,R4			;1 BYTE TO BE ENTERED IN BUFFER
	BSBW	OPTION_ROOM		;CHECK FOR ROOM IN BUFFER
	MOVB	#SMO$K_PARAMS,(R3)+	;SET OPTION CODE IN BUFFER
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA ;SAVE POINTER
	RET
;
; ROUTINE TO SET A PARAMETER IN MESSAGE BUFFER
;
SET_PARAM:
	.WORD	^M<R2,R3,R4,R5>
	CLRBIT	TPA$V_BLANKS,TPA$L_OPTIONS(AP) ;TURN OFF EXPLICIT BLANKS
	MOVL	TPA$L_TOKENCNT(AP),R4	;GET BYTE COUNT
	MOVL	TPA$L_TOKENPTR(AP),R5	;GET POINTER
	CMPB	#^A\"\,(R5)		;IS IT A QUOTED PARAMETER?
	BNEQU	10$			;BR IF NOT
	SUBL	#2,R4			;LESS 2 BYTES FOR 2 QUOTES
	INCL	R5			;START AT FIRTS BYTE AFTER QUOTE
10$:	TSTL	R4			;NULL PARAMETER?
	BNEQ	20$			;BR IF NOT
	MOVL	#1,R4			;1 BYTE FOR NULL
	MOVAL	W^30$,R5		;MAKE NULL A HEX FF
20$:	BSBW	OPTION_ROOM		;CHECK FOR ROOM IN OPTION BUFFER
	MOVB	R4,(R3)+		;SET BYTE COUNT IN MESSAGE
	MOVC3	R4,(R5),(R3)		;PUT PARAMETER IN MESSAGE BUFFER
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA ;SAVE POINTER
	MOVL	#1,R0			;SET STATUS OK
	RET

30$:	.BYTE	^XFF			;NULL PARAMETER
;
; ROUTINE TO SET END OF PARAMETER LIST
;
END_PARAM:
	.WORD	^M<R4,R3>
	MOVL	#1,R4			;1 BYTE TO BE PUT IN BUFFER
	BSBW	OPTION_ROOM		;CHECK FOR ROOM IN BUFFER
	CLRB	(R3)+			;SET END OF PARAMETER LIST FLAG
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA ;SAVE POINTER
	RET
;
; ROUTINE TO PUT ONE PARAMETER IN MESSAGE BUFFER
;
SET_1PARAM:
	.WORD	0
	CALLG	(AP),W^START_PARAM	;START PARAMETER LIST
	CALLG	(AP),W^SET_PARAM	;SET PARAMETER IN LIST
	CALLG	(AP),W^END_PARAM	;END PARAMETER LIST
	RET
;
; ROUTINE TO ZAP THE EXTRA QUOTE IN A LITERAL QUOTE
;
ZAP_QUOTE:
	.WORD	^M<R2,R3,R4,R5>
	MOVC3	TPA$L_STRINGCNT(AP),@TPA$L_STRINGPTR(AP),- ;KILL LAST QUOTE
		@TPA$L_TOKENPTR(AP)
	MOVB	#^A\ \,(R3)		;BLANK DUPLICATE LAST CHARACTER
	DECL	TPA$L_STRINGPTR(AP)	;BACKUP POINTER
	MOVL	#1,R0			;SET STATUS OK
	RET



;
; TURN ON EXPLICIT BLANK PROCESSING
;
BLANKS_ON:
	.WORD	0
	SETBIT	TPA$V_BLANKS,TPA$L_OPTIONS(AP)
	RET

;
; CHECK A TOKEN'S SIZE
;
CHECK_SIZE:
	.WORD	0
	CMPL	TPA$L_TOKENCNT(AP),TPA$L_PARAM(AP) ;IS IT TOO BIG?
	BLEQ	10$			;BR IT NO
	CLRL	R0			;ELSE, SET FAILURE
10$:	RET				;RETURN
;
; ROUTINE TO SET CPU TIME LIMIT
;
SET_CPUL:
	.WORD	^M<R3,R4>
	CLRBIT	TPA$V_BLANKS,TPA$L_OPTIONS(AP)	; TURN OFF BLANKS
	SUBL3	W^TOKEN_DESC+4,TPA$L_TOKENPTR(AP),-
		W^TOKEN_DESC		; COMPUTE STRING LENGTH
	CLRQ	-(SP)			; CREATE QUAD WORD BUFFER
	PUSHAQ	(SP)			; ADDR OF TIME BUFFER
	PUSHAQ	W^TOKEN_DESC		; ADDR OF INPUT DESCRIPTOR
	CALLS	#2,G^LIB$CVT_DTIME	; CONVERT TO BINARY
	BLBC	R0,20$			; BR IF ERROR CONVERTING
	EDIV	#-20*10*1000,(SP),R1,R0	; CONVERT TO LONG WORD
	BVS	20$			; BR IF WON'T FIT
	ASHL	#1,R1,R1		; MAKE UNSIGNED VALUE
	TSTL	R0			; TEST IF ANY REMAINDER FROM EDIV
	BEQL	5$			; BR IF NONE
	INCL	R1			; INCREMENT TIME
5$:	PUSHL	R1			; SAVE TIME
	MOVL	#5,R4			; NO. OF BYTES TO PUT IN MESSAGE
	BSBW	OPTION_ROOM		; CHECK IF FITS - NO RETURN IF NOT
	MOVB	#SMO$K_CPULIM,(R3)+	; MOVE OPTION CODE TO MESSAGE
	MOVL	(SP)+,(R3)+		; MOVE TIME VALUE TO MESSAGE
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA	; SAVE POINTER
	MOVL	#1,R0			; SET STATUS IS OK
	BRB	30$			; RETURN
20$:	PUSHAQ	W^TOKEN_DESC		; ADDR INPUT DESCRIPTOR
	PUSHL	#1			; ONE FAO ARGUMENT
	PUSHL	#SHR$_BADTIME!<4@16>	; CONDITON CODE
	CALLS	#3,G^LIB$SIGNAL		; SIGNAL THE ERROR
30$:	MOVQ	(SP)+,R3		; REMOVE BUFFER FROM STACK
	RET
;
; SET NO CPU LIMIT
;
		.ENABL	LSB
SET_NOCPUL:
	.WORD	^M<R3,R4>
	MOVL	#1,R4			; NO. OF BYTES THIS OPTION
	BSBW	OPTION_ROOM		; CHECK IF WILL FIT IN MESSAGE
	MOVB	#SMO$K_NOCPULM,(R3)+	; STORE OPTION BYTE IN MESSAGE
	BRB	10$			; GO UPDATE POINTER AND RETURN
;
; SET CPU LIMIT TO INFINITE
;
SET_INFIN:
	.WORD	^M<R3,R4>
	MOVL	#5,R4			; NO. OF BYTES IN THIS OPTION
	BSBW	OPTION_ROOM		; CHECK IF WILL FIT IN MESSAGE
	MOVB	#SMO$K_CPULIM,(R3)+	; STORE OPTION FLAG
	CLRL	(R3)+			; SET TIME = 0 = INFINITE
10$:	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA	; UPDATE POINTER
	RET
		.DSABL	LSB
;
; SET NO WORKING SET DEFAULT
;
		.ENABL	LSB
SET_NOWSDE:
	.WORD	^M<R2,R3,R4>
	BSBB	10$			; BR TO COMMON ROUTINE
	.BYTE	SMO$K_WSDEFLT		; OPTION FLAG
;
; SET NO WORKING SET QUOTA
;
SET_NOWSQU:
	.WORD	^M<R2,R3,R4>
	BSBB	10$			; BR TO COMMON ROUTINE
	.BYTE	SMO$K_WSQUOTA		; OPTION FLAG
;
; PARSE WORKING SET LIMIT AND QUOTA
;
SET_WSDE:
	.WORD	^M<R2,R3,R4>
	BSBB	COM_CODE		; BR TO COMMON CODE
	.BYTE	SMO$K_WSDEFLT		; OPTION FLAG

SET_WSQU:
	.WORD	^M<R2,R3,R4>
	BSBB	COM_CODE		; BR TO COMMON CODE
	.BYTE	SMO$K_WSQUOTA		; OPTION FLAG

COM_CODE:
	MOVL	TPA$L_NUMBER(AP),R2	; GET VALUE
	BEQL	10$			; BR IF 0 - SAME AS "NONE"
	BITL	#^X0FFFF0000,R2		; CHECK IF VALID VALUE
	BEQL	5$			; BR IF OK

	PUSHL	#SHR$_VALERR!<4@16>	; CONDITION CODE
	CALLS	#1,G^LIB$SIGNAL		; SIGNAL THE ERROR

5$:	MOVL	#3,R4			; NO. OF BYTES THIS OPTION
	BSBW	OPTION_ROOM		; CHECK IF WILL FIT IN MESSAGE
	MOVB	@(SP)+,(R3)+		; STORE OPTION FLAG IN MESSAGE
	MOVW	R2,(R3)+		; STORE VALUE IN MESSAGE
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA	; UPDATE POINTER
	RET				; RETURN
10$:	MOVZBL	#SMO$K_NOWSQUO,R2	; ASSUME NO WORKING SET QUOTA
	CMPB	@(SP)+,#SMO$K_WSQUOTA	; CHECK ASSUMPTION
	BEQL	15$			; BR IF CORRECT
	MOVZBL	#SMO$K_NOWSDFT,R2	; SET NO WORKING SET DEFAULT
15$:	MOVL	#1,R4			; NO. OF BYTES THIS OPTION
	BSBW	OPTION_ROOM		; CHECK IF WILL FIT IN MESSAGE
	MOVB	R2,(R3)+		; STORE OPTION IN MESSAGE
	MOVL	R3,W^ID_L_OPT_PTR+INP$G_DATA	; UPDATE POINTER
	RET				; RETURN

		.DSABL	LSB


;
; ROUTINE TO READ ALL THE JOB CARD CONTINUATIONS INTO JOB CARD BUFFER
;
GET_JOB_CONT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R11>
	MOVAL	W^INP$G_DATA,R11	;SET ADDRESS OF DATA VECTOR
	MOVL	TPA$L_STRINGCNT(AP),R6	;GET BYTE COUNT FOR 1ST CARD
	MOVL	TPA$L_STRINGPTR(AP),R7	;GET ADDRESS OF 1ST CARD
	ADDL3	R6,R7,R8		;COMPUTE ADDRESS OF BYTE AFTER LAST
	CLRL	TPA$L_STRINGCNT(AP)	;RE-INIT STRING DESCRIPTOR
	MOVAL	W^ID_T_JOB_CARD(R11),-	; TO POINT TO JOB CARD BUFFER
		TPA$L_STRINGPTR(AP)

10$:	CMPB	#^A\ \,-(R8)		;IS LAST CHARACTER A BLANK?
	BNEQU	20$			;BR IF NOT
	SOBGTR	R6,10$			;DECREMENT BYTE COUNT & CHECK AGAIN
	BRB	50$			;BLANK CARD - EXIT

20$:	ADDL3	TPA$L_STRINGCNT(AP),-	;COMPUTE END OF CURRENT STRING
		TPA$L_STRINGPTR(AP),R0
	ADDL3	R6,R0,R1		;COMPUTE STRINGPTR AFTER THIS CARD
	MOVAL	ID_T_JOB_CARD+INP$K_JOBCRDSZ(R11),R2 ;ADDR OF END OF BUFFER
	CMPL	R1,R2			;IS THERE ROOM IN THE BUFFER?
	BGTRU	50$			;BR IF NO - TRUNCATE IT
	MOVC3	R6,(R7),(R0)		;ADD THIS CARD TO THE BUFFER
	ADDL	R6,TPA$L_STRINGCNT(AP)	;COMPUTE NEW BYTE COUNT

	CMPB	#^A\-\,(R8)		;IS LAST CHARACTER A HYPHEN
	BNEQU	50$			;BR IF NOT - ALL DONE
	DECL	TPA$L_STRINGCNT(AP)	;FORGET HYPHEN
	BSBW	INP$GETCARD		;GET NEXT CARD
	BLBC	R0,50$			;BR IF ERROR GETTING IT
	ADDL3	R6,R7,R8		;GET ADDRESS OF BYTE AFTER LAST
	BRB	10$			;LOOK FOR END OF THIS CARD

50$:	MOVL	#1,R0			;SET STATUS TO SUCCESS
	RET


;
; SUBROUTINE TO CHECK FOR ROOM IN THE OPTION BUFFER
;
;	ON ENTRY - R4 = NUMBER OF BYTES TO PUT IN BUFFER
;
;	ON EXIT - IF ROOM: R3 = POINTER TO NEXT BYTE OF BUFFER
;		  IF NO ROOM: R0 = FAILURE AND ACTION ROUTINE EXITS
;
OPTION_ROOM:
	MOVL	W^ID_L_OPT_PTR+INP$G_DATA,R3 ;GET OPTION LIST POINTER
	ADDL3	R4,R3,R1		;COMPUTE LAST BYTE OF ENTRY
	CMPL	R1,#SM_T_OPTIONS+INP$G_SYMMSG- ;IS THERE ROOM?
		+ INP$K_OPTBUFSZ
	BLSSU	10$			;BR IF YES (+1 BYTE FOR DELETE FLAG)
	CLRL	R0			;ELSE - SET FAILURE
	RET				;EXIT ACTION ROUTINE
10$:	RSB				;RETURN TO ACTION ROUTINE
	.PAGE
	.SBTTL	PASSWORD CARD PARSER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	PARSES THE PASSWORD CARD USING LIB$TPARSE
;
; CALLING SEQUENCE:
;
;	BSBW	INP$PARSE_PASS
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS ADDRESS OF INPUT
;	R7 CONTAINS BYTE COUNT
;
; IMPLICIT INPUTS:
;
;	R11 CONTAINS ADDRESS OF INP$G_DATA
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	ID_Q_PASSW_DESC(R11) CONTAINS DESCRIPTOR FOR PASSWORD
;
; COMPLETION CODES
;
;	R0 CONTAINS - LIB$_NORMAL IF SYNTAX OK
;
; SIDE EFFECTS:
;
;	IF SYNTAX ERROR - ERROR SIGNALED
;
;--

	PURE_SECTION

	.ENABL	LSB

INP$PARSE_PASS::

	MOVQ	R6,W^TPA$L_STRINGCNT+TPARSE_BLOCK ;SET STRING SIZE & ADDRESS
	PUSHAL	W^PASS_KEY		;SET KEY TABLE ADDRESS
	PUSHAL	W^PASS_STATE		;SET STATE TABLE ADDRESS
	PUSHAL	W^TPARSE_BLOCK		;SET PARAMETER BLOCK ADDRESS
	CALLS	#3,G^LIB$TPARSE		;ATTEMPT TO PARSE PASSWORD CARD
	BLBS	R0,10$			;BR IF PARSED OK
	PUSHAL	W^TPA$L_TOKENCNT+TPARSE_BLOCK ;ADDRESS OF TOKEN DESC
	PUSHL	#1			;1 FAO PARAMETER
	PUSHL	#JBC$_PASSCRD		;CONDITION CODE
	CALLS	#3,G^LIB$SIGNAL		;SIGNAL THE ERROR
10$:
	RSB				;RETURN

	.DSABL	LSB

;
; $PASSWORD CARD STATE TABLE
;

	.ENABL	LSB

	$INIT_STATE	PASS_STATE,PASS_KEY

	$STATE
	$TRAN	'$'
	$STATE
	$TRAN	'PASSWORD'
	$STATE
	$TRAN	TPA$_SYMBOL,TPA$_EXIT,SET_PASSWORD,,,31

	$END_STATE

	.DSABL	LSB

	PURE_SECTION

;
; ACTION ROUTINE TO SET PASSWORD
;
SET_PASSWORD:
	.WORD	^M<R2,R3,R4,R5>		;ENTRY MASK
	CALLG	(AP),CHECK_SIZE		;CHECK STRING SIZE
	BLBC	R0,10$			;BR IF TOO BIG
	MOVQ	TPA$L_TOKENCNT(AP),W^ID_Q_PASSW_DESC+INP$G_DATA ;SET DESCRIPTOR
	MOVC3	TPA$L_TOKENCNT(AP),@TPA$L_TOKENPTR(AP),- ;SAVE PASSWORD
		ID_T_PASSWORD(R11)
	MOVL	#1,R0			;SET SUCCESS
10$:	RET				;RETURN

	.PAGE
	.SBTTL	EOJ CARD PARSER
;++
;
; INP$EOJ - SCANS BUFFER FOR "$EOJ"
; INP$EOJ_JOB - SCANS BUFFER FOR "$EOJ" OR "$JOB"
;
; FUNCTIONAL DESCRIPTION:
;
;	SCANS CURRENT BUFFER FOR "$EOJ" AND/OR "$JOB"
;
; CALLING SEQUENCE:
;
;	BSBW	INP$EOJ
;	BSBW	INP$EOJ_JOB
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS ADDRESS OF INPUT
;	R7 CONTAINS BYTE COUNT
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES
;	R0 CONTAINS - 1 IF $EOJ OR $JOB CARD
;		      0 IF NOT
;
; SIDE EFFECTS:
;	NONE
;
;--

	PURE_SECTION

	.ENABL	LSB

INP$EOJ::
	PUSHR	#^M<R2,R3,R4,R5,R8,R9>	;SAVE REGISTERS
	MOVL	#1,R8			;ONLY LOOK FOR $EOJ
	BRB	10$

INP$EOJ_JOB::
	PUSHR	#^M<R2,R3,R4,R5,R8,R9>	;SAVE REGISTERS
	MOVL	#2,R8			;LOOK FOR BOTH $EOJ AND $JOB
10$:	SKPC	#^A\ \,R6,(R7)		;SKIP ANY LEADING BLANKS
	BEQL	30$			;BR IF THAT'S ALL THERE IS
	CMPB	#^A\$\,(R1)+		;IS CHARACTER A "$"?
	BNEQU	30$			;BR IF NOT - ALL DONE
	DECL	R0			;ONE LESS CHAR TO CHECK
	BEQL	30$			;BR IF NONE LEFT
	SKPC	#^A\ \,R0,(R1)		;SKIP ANY BLANKS
	BEQL	30$			;BR IF THAT'S ALL THERE IS
	MOVQ	R0,R4			;SAVE DESCRIPTOR IN SAFE REGS
	MOVAL	W^EOJ_TABLE,R9		;SET ADDR OF EOJ/JOB TABLE
20$:	CMPC3	#3,(R5),(R9)		;DOES STRING MATCH?
	BEQL	40$			;BR IF YES
	ADDL	#3,R9			;SET POINTER TO NEXT STRING
	SOBGTR	R8,20$			;DEC COUNT AND BR IF MORE
30$:	CLRL	R0			;STRING IS NOT "$EOJ" OR "$JOB"
	BRB	50$			;EXIT
40$:	MOVL	#1,R0			;STRING IS "$EOJ" OR "$JOB"
50$:	POPR	#^M<R2,R3,R4,R5,R8,R9>	;RESTORE REGISTERS
	RSB				;RETURN
	.DSABL	LSB

	.END
