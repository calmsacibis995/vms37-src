	.TITLE	HANDLER - INPUT SYMBIONT CONDITION HANDLER
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; FACILITY:  VAX/VMS INPUT SYMBIONT
;
; ABSTRACT:	THIS MODULE CONTAINS THE ERROR CONDITION HANDLER
;
;
; ENVIRONMENT:	USER MODE
;
;
; AUTHOR:	LEN KAWELL, CREATION DATE: 15-MAR-78
;
; MODIFIED BY:
;
;	V02-002	MLJ35403		Martin L. Jack,	17-Jan-1982  21:49
;		Incorporate standard queue name translation.
;
;	V02-001	GWF0110		Gary W. Fowler		7-Oct-1981
;		Change to write .ERR file to SYS$MANAGER
;
;--

;
; INCLUDE FILES:
;
;	[INPSMB.SRC]PREFIX.MAR
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	$FABDEF				;FILE ACCESS BLOCK DEFINITIONS
	$RABDEF				;RECORD ACCESS BLOCK DEFINITIONS
	$NAMDEF				;NAME BLOCK DEFINTIONS
	$CHFDEF				;CONDITION HANDLER DEFINTIONS
	$OPCDEF				;OPCOM MESSAGE DEFINITIONS
	$SMRDEF				;SEND SYMBIONT MANGR DEFINITIONS

;
; OWN STORAGE:
;

	PURE_SECTION

;
; INPUT SYMBIONT FACILITY NAME STRING
;
FACILITY:
	STRING_DESC <INPSMB>

;
; PRINT QUEUE NAME
;
PRINT_QUEUE:
	.ASCID	/SYS$PRINT/

;
; SYMBIONT MANAGER MESSAGE DESCRIPTOR
;
SYMMSG_DESC:
	.LONG	SM_K_SIZE		;SIZE OF MESSAGE
	.LONG	INP$G_SYMMSG		;ADDRESS OF MESSAGE

;
; ERROR FILE NAME
;
ERR_FILE:
	.ASCIC	/SYS$MANAGER:INPBATCH.ERR/
JOB_NAME:
	.ASCIC	/INPBATCH.ERR/
	IMPURE_DATA

;
; OPCOM MESSAGE BUFFER
;
OPCOM_MSG_DESC:
	.LONG	OPC$L_MS_TEXT+80	;LENGTH OF BUFFER
	.LONG	OPCOM_MSG		;ADDRESS OF BUFFER
OPCOM_MSG:
	.BYTE	OPC$_RQ_RQST		;REQUEST TYPE
	.WORD	OPC$M_NM_CENTRL!-	;OPERATORS TO BE NOTIFIED
		OPC$M_NM_DEVICE!-	;
		OPC$M_NM_CARDS		;
	.BYTE	0
	.LONG	0			;NO REQUEST ID
	.BLKB	128			;MESSAGE BUFFER

	.PAGE
	.SBTTL	CONDITION HANDLER
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	CALLS SYS$PUTMSG TO GET THE ERROR MESSAGE TEXT, WHICH CALLS
;	THE ACTION ROUTINE WHICH WILL OUTPUT THE ERROR MESSAGE TO:
;
;		1) OPCOM - IF A JOB CARD HAS NOT BEEN READ YET, THE
;			ERROR MESSAGE GOES TO THE OPERATOR TERMINALS
;
;		2) [SYSMGR]INPBATCH.ERR - IF A JOB CARD HAS BEEN READ,
;			BUT THE OUPUT FILE HASN'T BEEN CREATED YET, THE
;			ERROR MESSAGE WILL BE WRITTEN TO THIS FILE
;
;		3) [user's dir]INPBATCH.COM - IF THE OUTPUT COMMAND
;			FILE WAS CREATED, THE ERROR MESSAGE WILL BE
;			WRITTEN TO THIS FILE
;
;	IF THE MESSAGE(S) WERE WRITTEN TO A FILE, IT IS ENTERED IN THE
;	SYS$PRINT QUEUE TO BE PRINTED WITH THE USER'S NAME.  THE CALL
;	FRAMES ARE THEN UNWOUND AND THE IMAGE RESTARTED AT INP$GET_JOB.
;
; CALLING SEQUENCE:
;
;	CALLED AS A CONDITION HANDLER
;
; INPUT PARAMETERS:
;
;	STANDARD CONDITION HANDLER PARAMETERS
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	ERROR MESSAGES SENT EITHER TO OPERATOR OR USER
;
; ROUTINE VALUE:
;
;	NONE
;
; SIDE EFFECTS:
;
;	CALL FRAMES UNWOUND AND PROCESS RESTARTED AT INP$GET_JOB
;
;--
	PURE_SECTION

INP$HANDLER::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAL	W^INP$G_FAB,R9		;GET ADDRESS OF FAB
	MOVAL	W^INP$G_RAB,R10		;GET ADDRESS OF RAB
	MOVAL	W^INP$G_DATA,R11	;GET ADDRESS OF GLOBAL DATA
;
; DECIDE WHERE THE MESSAGE(S) SHOULD BE PUT
;
	BBC	#FLAG_V_NAME,ID_L_FLAGS(R11),PUTMSG ;BR IF NO $JOB YET
	BBC	#FLAG_V_CREATED,ID_L_FLAGS(R11),10$ ;BR IF COMMAND FILE NOT CREATED
;
; MESSAGES WILL BE PUT IN COMMAND FILE
;
	TSTW	FAB$W_IFI(R9)		;IS FILE STILL OPEN?
	BNEQ	PUTMSG			;BR IF YES
	MOVB	#FAB$M_PUT,FAB$B_FAC(R9) ;ALLOW $PUT FILE ACCESS
	$OPEN	(R9)			;RE-OPEN THE FILE
	BLBC	R0,10$			;BR IF ERROR
	SETBIT	RAB$V_EOF,RAB$L_ROP(R10);POSITION FILE AT END-OF-FILE
	$CONNECT (R10)			;CONNECT THE RAB
	CLRBIT	RAB$V_EOF,RAB$L_ROP(R10);CLEAR EOF FLAG
	BRB	PUTMSG			;BR - PUT THE MESSAGE(S)
;
; MESSAGE(S) WILL BE PUT IN SPECIAL ERROR FILE
;
10$:	$CMKRNL_S W^INP$SET_ACCNT,W^SYS_ACCNT ;RESTORE UIC/ACCOUNT
	CLRB	FAB$B_DNS(R9)		;RESTORE DEFAULT TO SYMBIONT'S
	MOVB	W^ERR_FILE,FAB$B_FNS(R9);SET FILE NAME SIZE
	MOVAL	W^ERR_FILE+1,FAB$L_FNA(R9) ;SET FILE NAME ADDRESS
	CLRL	W^NAM$L_ESA+INP$G_NAM	;LEAVE PREVIOUS NAME STRING
	$CREATE (R9)			;CREATE THE ERROR FILE
	BLBC	R0,PUTMSG		;BR IF ERROR - JUST SEND TO OP
	$CONNECT (R10)			;CONNECT THE RAB
;
; CALL SYS$PUTMSG TO OUTPUT THE MESSAGE(S)
;
PUTMSG:
	SUBW	#2,@CHF$L_SIGARGLST(AP)	;DON'T PASS PC AND PSL
	PUSHAL	FACILITY		;ADDR OF FACILITY NAME DESC
	PUSHAL	W^ACTION		;ADDR OF ACTION ROUTINE
	PUSHL	CHF$L_SIGARGLST(AP)	;ADDR OF SIGNAL ARGS
	CALLS	#3,SYS$PUTMSG		;GET THE MESSAGES
	ADDW	#2,@CHF$L_SIGARGLST(AP)	;RESTORE CORRECT ARG COUNT
;
; IF MESSAGE(S) WERE PUT IN A FILE, CLOSE AND QUEUE IT FOR PRINTING
;
	TSTW	FAB$W_IFI(R9)		;IS A FILE OPEN?
	BEQL	UNWIND			;BR IF NOT
	$DISCONNECT (R10)		;DISCONNECT THE RAB
	$CLOSE	(R9)			;CLOSE THE FILE
	MOVAL	W^INP$G_SYMMSG,R6	;GET ADDR OF SYMBIONT MESSAGE
	MOVW	#SMR$K_ENTER,SM_W_REQUEST(R6) ;SET REQUEST TYPE
	PUSHAB	SM_T_QUEUE(R6)		; Point to result area
	PUSHAQ	W^PRINT_QUEUE		; Point to descriptor for SYS$PRINT
	CALLS	#2,G^TRAN_QUEUE		; Translate queue name
	ASSUME	NAM$W_FID EQ NAM$T_DVI+16
	ASSUME	NAM$W_DID EQ NAM$W_FID+6
	MOVC3	#16+6+6,W^NAM$T_DVI+INP$G_NAM,- ;SET DEVICE, FILE ID, DIR
		SM_T_DEVNAME(R6)
	MOVC3	#16,W^JOB_NAME,SM_T_FILENAME(R6) ;SET JOB NAME
	MOVB	#SMO$K_DELETE,SM_T_OPTIONS(R6) ;SET TO DELETE AFTER PRNT
	$SNDSMB_S SYMMSG_DESC		;QUEUE IT FOR PRINTING

;
; UNWIND CALL FRAMES AND RESTART AT INP$GET_JOB
;
UNWIND:
	MOVL	CHF$L_MCHARGLST(AP),R2	;GET ADDRESS OF MECHANISM ARRAY
	TSTL	CHF$L_MCH_DEPTH(R2)	;AT ESTABLISHER DEPTH?
	BNEQ	10$			;BR IF NOT
	MOVL	CHF$L_SIGARGLST(AP),R2	;GET ADDRESS OF SIGNAL ARRAY
	SUBL3	#1,CHF$L_SIG_ARGS(R2),R3;SAVED PC IS SECOND TO LAST ARG
	MOVAL	W^INP$GET_JOB,(R2)[R3]	;SET NEW PC
	MOVZWL	#SS$_CONTINUE,R0	;CONTINUE AT NEW PC
	RET
10$:
	PUSHAL	W^INP$GET_JOB		;NEW PC
	PUSHAL	CHF$L_MCH_DEPTH(R2)	;NUMBER FRAMES TO UNWIND
	CALLS	#2,SYS$UNWIND		;INIT CALL FRAME TO UNWIND
	RET				;...UNWIND AND RESTART AT NEW PC

;
; SYS$PUTMSG ACTION ROUTINE
;
ACTION:
	.WORD	^M<R2,R3,R4,R5>
	MOVL	4(AP),R2		;GET ADDR OF MESSAGE DESCRIPTOR
	TSTW	W^FAB$W_IFI+INP$G_FAB	;IS A FILE OPEN?
	BEQL	10$			;BF IF NOT
	MOVAL	W^INP$G_RAB,R1		;GET ADDR OF RAB
	MOVW	(R2),RAB$W_RSZ(R1)	;SET RECORD SIZE
	MOVL	4(R2),RAB$L_RBF(R1)	;SET RECORD ADDRESS
	$PUT	(R1)			;PUT THE MESSAGE IN THE FILE
	BLBS	R0,20$			;BR IF NO ERROR
10$:
	MOVC5	(R2),@4(R2),#0,-	;PUT MESSAGE IN OPCOM BUFF
		#128,W^OPCOM_MSG+OPC$L_MS_TEXT
	$SNDOPR_S W^OPCOM_MSG_DESC	;SEND THE MESSAGE TO THE OPS
20$:	CLRL	R0			;DON'T PUT MESSAGES ELSEWHERE
	RET				;RETURN TO SYS$PUTMSG

	.END
