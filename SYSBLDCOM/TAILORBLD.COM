$	IF F$MODE () .NES. "INTERACTIVE" THEN SET NOVERIFY
$	ON ERROR THEN GOTO RUNDOWN
$	ON CONTROL_Y THEN GOTO ERROR_CONTROL_Y
$
$ !++
$ ! TAILORBLD.COM - Build the tailoring files from VMSKITBLD.DAT
$ !
$ ! AUTHOR:	Greg Robert		22-Dec-1981
$ !
$ ! ABSTRACT:	This command procedure reads VMSKITBLD.DAT and produces
$ !		an output file for each file category encountered.
$ !
$ ! INPUT:	P1 = Input data file -- defaults to SYS$UPDATE:VMSKITBLD.DAT
$ !		P2 = Output device and directory -- current default if not spec
$ !
$ ! DESCRIPTION:
$ !--
$
$	!
$	! Initialize local data
$	!
$
$	DISPLAY		= "WRITE SYS$OUTPUT"
$	TRUE		= "TRUE"
$	FALSE		= "FALSE"
$	SPACE		= " "
$	SLASH		= "/"
$	COMMA		= ","
$	EQUAL		= "="
$	L_PAREN		= "("
$	R_PAREN		= ")"
$	SIZE		= 0
$	REST		= 9999
$	DIRNAME		= "NOSUCHDIRECTORY"
$	GROUP_LIST_1	= ",BLISSREQ,DECNET,DEVELOP,EDTCAI,EXAMPLES"
$	GROUP_LIST_2	= ",FILETOOLS,HELP,LIBRARY,MANAGER,MISCTOOLS,OBSOLETE"
$	GROUP_LIST_3	= ",QUEUES,REQUIRED,RSX,TEXTTOOLS,UETP,UNKNOWN"
$	GROUP_LIST	= GROUP_LIST_1 + GROUP_LIST_2 + GROUP_LIST_3
$	LAST_GROUP	= ""
$
$	!
$	! Open the data file.
$	!
$
$ OPEN_DATA_FILE:
$	IF P1 .EQS. "" THEN P1 = "SYS$UPDATE:"
$	FILENAME = F$PARSE (P1, "VMSKITBLD.DAT")
$	IF F$SEARCH (FILENAME) .EQS. "" THEN GOTO ERROR_NOSUCHFILE
$	OPEN /READ DATAFILE 'FILENAME' /ERROR=ERROR_OPENIN
$	WORKFILENAME = F$PARSE (P2, "SYS$SCRATCH:TAILORBLD.TMP")
$	FILENAME = WORKFILENAME
$	OPEN /WRITE WORKFILE 'FILENAME' /ERROR=ERROR_OPENOUT
$
$	!
$	! Get the next data line from the file, discard comments
$	! and execution lines.  Parse the filename, operation,
$	! file group, and saveset.
$	!
$
$ GET_DATA_LINE:
$	READ DATAFILE DATA /END=SORT_IT
$	X = F$EXTRACT (0, 1, DATA)
$	IF X .EQS. "$" .OR. X .EQS. "!" THEN GOTO GET_DATA_LINE
$	FILENAME = F$EXTRACT (0, F$LOCATE (COMMA, DATA), DATA)
$	IF FILENAME .EQS. "" THEN GOTO GET_DATA_LINE
$	X = F$EXTRACT (F$LOCATE ("OP=", DATA)+3, REST, DATA)
$	OPERATION = F$EXTRACT (0, F$LOCATE (COMMA, X), X)
$	IF OPERATION .EQS. "CREATE" THEN GOTO GET_DATA_LINE
$	GROUP = F$EXTRACT (F$LOCATE ("CAT=", DATA)+4, REST, DATA)
$	GROUP := 'GROUP
$	IF F$EXTRACT (0, 1, GROUP) .NES. L_PAREN -
	   THEN GROUP = F$EXTRACT (0, F$LOCATE (COMMA, GROUP), GROUP)
$	IF F$EXTRACT (0, 1, GROUP) .EQS. L_PAREN -
	   THEN GROUP = F$EXTRACT (1, F$LOCATE (R_PAREN, GROUP) - 1, GROUP)
$	SAVESET = F$EXTRACT (F$LOCATE ("SET=", DATA)+4, REST, DATA)
$	SAVESET = F$EXTRACT (0, F$LOCATE (COMMA, SAVESET), SAVESET)
$	IF SAVESET .EQS. "" THEN SAVESET = "LIB"
$	IF SAVESET .EQS. "REQ" .AND. GROUP .EQS. "" THEN GROUP = "REQUIRED"
$	IF GROUP .EQS. "" THEN GROUP = "UNKNOWN"
$	IF OPERATION .NES. "SET" THEN GOTO WRITE_FILE
$	DIRNAME = FILENAME
$	GOTO GET_DATA_LINE
$
$ WRITE_FILE:
$	IF OPERATION .EQS. "CONTIG" .AND. SAVESET .NES. "REQ" THEN -
		DISPLAY "TAILOR-W-CONTIGNOTREQ, Contiguous file not in req saveset -- ''DATA'"
$ MULTI_GROUP:
$	XGROUP = F$EXTRACT (0, F$LOCATE (COMMA, GROUP), GROUP)
$	GROUP = F$EXTRACT (F$LOCATE (COMMA, GROUP) + 1, REST, GROUP)
$	X = F$FAO ("!20AS[!AS]!AS", XGROUP, DIRNAME, FILENAME)
$	WRITE WORKFILE X
$	IF GROUP .NES. "" THEN GOTO MULTI_GROUP
$	GOTO GET_DATA_LINE
$
$ SORT_IT:
$	CLOSE WORKFILE
$	SORT 'WORKFILENAME' 'WORKFILENAME' /KEY=(POSITION:1, SIZE:100)
$	FILENAME = WORKFILENAME
$	OPEN /READ WORKFILE 'FILENAME' /ERROR=ERROR_OPENIN
$	IF P2 .EQS. "" THEN P2 = "SYS$DISK:[]"
$
$ WORKFILE_LOOP:
$	READ WORKFILE DATA /END_OF_FILE=RUNDOWN
$	GROUP := 'F$EXTRACT (0, 9, DATA)
$	FILENAME = F$PARSE (P2, ".TLR", GROUP)
$	IF FILENAME .EQS. LAST_GROUP THEN GOTO WRITE_GROUPFILE
$	LAST_GROUP = FILENAME
$
$	IF F$LOGICAL ("GROUPFILE") .NES. "" THEN CLOSE GROUPFILE
$	X = F$LOCATE (COMMA+GROUP, GROUP_LIST)
$	IF X .EQ. F$LENGTH (GROUP_LIST) THEN -
		DISPLAY "TAILOR-W-UNRECGRP, Unrecognized group -- ''GROUP'"
$	Y = F$EXTRACT (X+1, REST, GROUP_LIST)
$	IF F$LOCATE (COMMA+GROUP, Y) .NE. F$LENGTH (Y) THEN -
		DISPLAY "WARNING: Ambiguous group -- ''GROUP'"
$	OPEN /WRITE GROUPFILE 'FILENAME' /ERROR=ERROR_OPENOUT
$
$ WRITE_GROUPFILE:
$	WRITE GROUPFILE "''F$EXTRACT (20, REST, DATA)'"
$	GOTO WORKFILE_LOOP
$
$ RUNDOWN:
$	IF F$LOGICAL ("DATAFILE") .NES. "" THEN CLOSE DATAFILE
$	IF F$LOGICAL ("WORKFILE") .NES. "" THEN CLOSE WORKFILE
$	IF F$LOGICAL ("GROUPFILE") .NES. "" THEN CLOSE GROUPFILE
$	IF "''WORKFILENAME'" .EQS. "" THEN WORKFILENAME = ""
$	IF F$SEARCH (WORKFILENAME) .NES. "" THEN DELETE 'WORKFILENAME'*
$	X = F$PARSE (P2, "SYS$UPDATE:*.TLR") - ";"
$	IF X .EQS. "" THEN EXIT
$	PURGE 'X
$	EXIT
$
$	!
$	! Error messages
$	!
$
$ ERROR_CONTROL_Y:
$	DISPLAY "Function aborted by control Y"
$	GOTO RUNDOWN
$
$ ERROR_NOSUCHFILE:
$	DISPLAY "File ""''FILENAME'"" not found."
$	GOTO RUNDOWN
$
$ ERROR_OPENIN:
$	DISPLAY "''F$MESSAGE ($STATUS)'"
$	DISPLAY "Error opening ''FILENAME' as input"
$	GOTO RUNDOWN
$
$ ERROR_OPENOUT:
$	DISPLAY "''F$MESSAGE ($STATUS)'"
$	DISPLAY "Error opening ''FILENAME' as output"
$	GOTO RUNDOWN
