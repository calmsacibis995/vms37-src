	.TITLE	LPA$BUFFER
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	LPA-11 PROCEDURE LIBRARY
;
; ABSTRACT:
;	THIS MODULE CONTAINS THE ROUTINES WHICH MANIPULATE BUFFERS
;	AS PART OF THE LPA-11 PROCEDURE LIBRARY.  THIS INCLUDES THE
;	AST ROUTINES.
;
; ENVIRONMENT:	USER MODE, SHARED OR NON-SHARED LIBRARY
;
; AUTHOR:  STEVE BECKHARDT,	CREATION DATE:  28-AUG-78
;
; MODIFIED BY:
;
;	V03-001	SBL3001		Steven B. Lionel	30-March-1982
;		Change module name to LPA$BUFFER.
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

;
; OWN STORAGE:
;

	.PSECT	_LPA$CODE,PIC,SHR,EXE,NOWRT,LONG


LPA$BFSTART::				; START OF BUFFER ROUTINES (MAY BE
					; USED TO LOCK THESE ROUTINES INTO
					; THE PROCESS'S WORKING SET).

	.SBTTL	LPA$IBFSTS - GET BUFFER STATUS
;++
; FUNCTIONAL DESCRIPTION
;
;	THIS ROUTINE RETURNS THE STATUS OF EACH OF THE BUFFERS.
;	THE STATUS IS DEFINED AS WHICH QUEUE THE BUFFER IS ON.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;
; INPUT PARAMETERS:
;
;	IBUF(AP)		ADDRESS OF IBUF ARRAY
;	ISTAT(AP)		ADDRESS OF LONGWORD ARRAY WITH AS MANY
;				ELEMENTS AS THERE ARE BUFFERS INVOLVED 
;				IN THE SWEEP
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	ISTAT(AP)		ADDRESS OF LONGWORD ARRAY WITH AS MANY
;				ELEMENTS AS THERE ARE BUFFERS INVOLVED
;				IN THE SWEEP.  EACH ELEMENT IS FILLED WITH
;				THE STATUS OF THE CORRESPONDING BUFFER.
;				THE STATUS CODES ARE AS FOLLOWS:
;
;					2	BUFFER IS ON DEVICE QUEUE
;					1	BUFFER IS ON USER QUEUE
;					0	BUFFER IS NOT ON ANY QUEUE
;				       -1	BUFFER IS ON INUSE QUEUE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$IBFSTS,^M<R2,R3,R4,R6>

	MOVL	4(AP),R6		; GET ADDRESS OF IBUF ARRAY
	MOVL	8(AP),R4		; GET ADDRESS OF ISTAT ARRAY

	EXTZV	#0,#3,IBF$L_CMDTBL+CMT$B_VBFRMASK(R6),R0  ; GET HIGHEST BUF. #

	; INITIALIZE ALL ENTRIES IN ISTAT ARRAY TO 0
10$:	CLRL	(R4)[R0]
	SOBGEQ	R0,10$

	; *** TURN OFF ASTS ***
	$SETAST_S	#0

	; STORE STATUS FOR ALL BUFFERS ON THE DEVICE QUEUE
	MOVL	#2,R3			; STATUS = 2
	MOVAL	IBF$L_DEVQFL(R6),R2	; ADDRESS OF DEVICE QUEUE
	BSBB	FOLLOWQ			; FOLLOW THE QUEUE

	; STORE STATUS FOR ALL BUFFERS ON THE USER QUEUE
	DECL	R3			; STATUS = 1
	MOVAL	IBF$L_USRQFL(R6),R2	; ADDRESS OF USER QUEUE
	BSBB	FOLLOWQ			; FOLLOW THE QUEUE

	; STORE STATUS FOR ALL BUFFERS ON THE INUSE QUEUE
	MNEGL	#1,R3			; STATUS = -1
	MOVAL	IBF$L_INUQFL(R6),R2	; ADDRESS OF INUSE QUEUE
	BSBB	FOLLOWQ			; FOLLOW THE QUEUE

	; *** TURN ON ASTS ***
	$SETAST_S	#1
	RET


	;
	; LOCAL SUBROUTINE TO FOLLOW QUEUE AND STORE STATUS IN ISTAT ARRAY
	;
	;	INPUT:	R2 CONTAINS ADDRESS OF QUEUE HEAD
	;		R3 CONTAINS STATUS TO STORE IN ISTAT ARRAY
	;
FOLLOWQ:
	MOVL	R2,R1			; COPY ADDRESS OF QUEUE HEAD

10$:	MOVL	(R1),R1			; GET ADDRESS OF NEXT LINK
	CMPL	R1,R2			; BACK TO QUEUE HEAD YET?
	BEQL	20$			; YES, DONE
	BSBW	CVTADINDX		; NO, CONVERT ADDRESS TO BUFFER INDEX
	MOVL	R3,(R4)[R0]		; STORE STATUS IN CORRESPONING ENTRY
	BRB	10$			; OF ISTAT AND BRANCH BACK FOR NEXT ONE
20$:	RSB

	.SBTTL	LPA$IGTBUF - GET A BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY THE USER'S PROGRAM TO GET A BUFFER
;	FROM THE HEAD OF THE USER QUEUE.  UNLIKE LPA$IWTBUF, THIS ROUTINE
;	RETURNS IMMEDIATELY IF THE QUEUE IS EMPTY.  THIS ROUTINE IS INTENDED
;	TO BE CALLED FROM THE USER'S COMPLETION ROUTINE (WHICH IS CALLED BY
;	THE AST HANDLERS).  THIS ROUTINE SHOULD BE CALLED IF THE USER
;	IS SYNCHRONIZING WITH A COMPLETION ROUTINE, RATHER THAN WITH EVENT
;	FLAGS.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;	MAY ALSO BE CALLED AS A FUNCTION
;
; INPUT PARAMETERS:
;
;	IBUF(AP)		ADDRESS OF IBUF ARRAY
;	IBUFNO(AP)		ADDRESS OF LONGWORD WHICH RECEIVES BUFFER
;				INDEX OR -1 WHICH INDICATES NO BUFFER IN QUEUE
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	IBUFNO(AP)		ADDRESS OF LONGWORD WHICH RECEIVES BUFFER
;				INDEX OR -1 WHICH INDICATES NO BUFFER IN QUEUE
;
; IMPLICIT OUTPUTS:
;
;	OFFSET IBF$Q_IOST IN THE IBUF ARRAY CONTAINS ADDITIONAL STATUS
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$IGTBUF,^M<R6>

	MOVL	4(AP),R6		; GET ADDRESS OF IBUF ARRAY

	; REMOVE BUFFER FROM HEAD OF USER QUEUE
	REMQUE	@IBF$L_USRQFL(R6),R1	; R1 GETS ADDRESS OF LINK
	BVS	10$			; NO ENTRY IN QUEUE
	BSBW	CVTADINDX		; CONVERT ADDRESS TO INDEX IN R0
	CLRW	IBF$Q_IOST(R6)		; CLEAR STATUS
	MOVW	IBF$L_LBUF(R6),IBF$Q_IOST+2(R6)	; STORE BUFFER LENGTH
	BRB	20$

10$:	; USER QUEUE IS EMPTY - RETURN REAL I/O STATUS
	MOVQ	IBF$Q_IOSB(R6),IBF$Q_IOST(R6)
	MNEGL	#1,R0			; RETURN -1

20$:	CMPB	(AP),#2			; IBUFNO SUPPLIED?
	BLSSU	40$			; NO
	MOVL	8(AP),R1		; GET ADDRESS
	BEQL	40$			; DEFAULTED
	MOVL	R0,(R1)			; STORE INDEX
40$:	RET				; INDEX IS IN R0 FOR FUNCTION CALL

	.SBTTL	LPA$INXTBF - SET NEXT BUFFER
	.SBTTL	LPA$RMVBUF - REMOVE BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	LPA$INXTBF CHANGES THE ORDER OF BUFFERS IN THE DEVICE QUEUE
;	BY INSERTING THE INDICATED BUFFER AT THE HEAD OF THE QUEUE.
;	NOTE THAT THE BUFFER MUST ALREADY BE ON THE DEVICE QUEUE.
;	LPA$RMVBUF REMOVES A BUFFER FROM THE DEVICE QUEUE.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;	THESE ROUTINES MAY ALSO BE CALLED AS FUNCTIONS
;
; INPUT PARAMETERS:
;
;	IBUF(AP)		ADDRESS OF IBUF ARRAY
;	IBUFNO(AP)		ADDRESS OF LONGWORD WHICH CONTAINS INDEX
;				OF BUFFER TO BE REMOVED OR MADE NEXT
;	IND(AP)			ADDRESS OF LONGWORD TO RECEIVE RETURN STATUS
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	IND(AP)			ADDRESS OF LONGWORD TO RECEIVE RETURN STATUS
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	0	INDICATES THAT THE SPECIFIED BUFFER WAS NOT IN THE DEVICE QUEUE
;	1	INDICATES THAT THE SPECIFIED BUFFER WAS REMOVED OR MADE NEXT
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$INXTBF,^M<R2,R3,R4,R6>
	MOVL	#1,R4			; INDICATES WHICH CALL
	BRB	COMMON

	.ENTRY	LPA$RMVBUF,^M<R2,R3,R4,R6>
	CLRL	R4			; INDICATES WHICH CALL


COMMON:	MOVL	4(AP),R6		; GET ADDRESS OF IBUF ARRAY
	CLRL	R2			; RETURN CODE

	MOVL	@8(AP),R3		; GET BUFFER INDEX
	MOVAQ	IBF$Q_BFRLNKS(R6)[R3],R3; CONVERT TO ADDRESS

	; *** TURN OFF ASTS ***
	$SETAST_S	#0

	MOVAL	IBF$L_DEVQFL(R6),R1	; GET ADDRESS OF DEVICE QUEUE HEAD
	MOVL	R1,R0

10$:	; GET NEXT LINK IN QUEUE
	MOVL	(R0),R0
	CMPL	R0,R1			; BACK TO QUEUE HEAD YET?
	BEQL	30$			; YES, BUFFER NOT ON QUEUE

	CMPL	R0,R3			; IS THIS THE BUFFER?
	BNEQ	10$			; NO

	; HAVE BUFFER.  ADDRESS IS IN R0.  REMOVE FROM QUEUE
	REMQUE	(R0),R0

	; IF LPA$INXTBF WAS ENTRY, THEN INSERT BUFFER AT HEAD OF QUEUE.
	BLBC	R4,20$			; BR. IF LPA$RMVBUF WAS ENTRY
	INSQUE	(R0),IBF$L_DEVQFL(R6)	; INSERT AT HEAD OF DEVICE QUEUE

20$:	INCL	R2			; INDICATE SUCCESS

30$:	;*** TURN ON ASTS ***
	$SETAST_S	#1

	MOVL	R2,R0			; RETURN STATUS
	CMPB	(AP),#3			; IND SPECIFIED?
	BLSSU	40$			; NO
	MOVL	12(AP),R1		; GET ADDRESS OF IND
	BEQL	40$			; DEFAULTED
	MOVL	R0,(R1)			; STORE STATUS
40$:	RET

	.SBTTL	LPA$IWTBUF - WAIT FOR A BUFFER
;++
;FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY THE USER'S PROGRAM TO GET A BUFFER
;	FROM THE HEAD OF THE USER QUEUE.  HOWEVER, UNLIKE LPA$IGTBUF,
;	THIS ROUTINE WAITS FOR ONE IF THE QUEUE IS EMPTY.  THIS ROUTINE
;	SHOULD BE USED IF THE USER IS SYNCHRONIZING WITH EVENT FLAGS
;	RATHER THAN WITH A COMPLETION ROUTINE.  THIS ROUTINE DOES THE FOLLOWING:
;		1)  REMOVES A BUFFER FROM THE HEAD OF THE USER QUEUE.
;		    IF THERE IS ONE, IT RETURNS WITH THE BUFFER INDEX.
;		2)  OTHERWISE, THE EVENT FLAG IS CLEARED.
;		3)  ANOTHER ATTEMPT IS MADE TO REMOVE A BUFFER FROM THE
;		    HEAD OF THE USER QUEUE.  IF THERE IS ONE, IT IS RETURNED.
;		4)  OTHERWISE, THE I/O STATUS BLOCK IS CHECKED TO SEE IF THE
;		    SWEEP IS STILL IN PROGRESS.  IF NOT, THE STATUS IS RETURNED.
;		5)  OTHERWISE, WE WAIT FOR THE EVENT FLAG AND THEN GO TO STEP 1.
;	NOTE THAT STEP 1 IS ONLY AN OPTIMIZATION:  IT SAVES CLEARING THE
;	EVENT FLAG IF A BUFFER IS ALREADY AVAILABLE.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;	MAY ALSO BE CALLED AS A FUNCTION
;
; INPUT PARAMETERS:
;
;	IBUF(AP)		ADDRESS OF IBUF ARRAY
;	IEFN(AP)		UNUSED (PRESENT FOR COMPATIBILITY ONLY)
;	IBUFNO(AP)		ADDRESS OF A LONGWORD WHICH RECEIVES BUFFER
;				INDEX OR -1 IF THERE ARE NO BUFFERS AND THE
;				SWEEP HAS STOPPED.
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	IBUFNO(AP)		ADDRESS OF A LONGWORD WHICH RECEIVES BUFFER
;				INDEX OR -1 IF THERE ARE NO BUFFERS AND THE
;				SWEEP HAS STOPPED.
;
; IMPLICIT OUTPUTS:
;
;	OFFSET IBF$Q_IOST IN THE IBUF ARRAY CONTAINS ADDITIONAL STATUS
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$IWTBUF,^M<R2,R6>

	MOVL	4(AP),R6		; GET ADDRESS OF IBUF ARRAY
	MOVZBL	IBF$B_EFN(R6),R2	; GET EVENT FLAG BEING USED

10$:	; REMOVE BUFFER FROM HEAD OF USER QUEUE
	REMQUE	@IBF$L_USRQFL(R6),R1	; ADDRESS IN R1
	BVC	70$			; HAVE ONE

30$:	; USER QUEUE IS EMPTY.  CLEAR EVENT FLAG
	$CLREF_S	R2		; CLEAR EVENT FLAG
	BLBC	R0,40$			; ERROR

	; TRY AGAIN TO REMOVE A BUFFER FROM HEAD OF USER QUEUE
	REMQUE	@IBF$L_USRQFL(R6),R1	; ADDRESS IN R1
	BVC	70$			; HAVE ONE

	; QUEUE IS STILL EMPTY.  CHECK FOR ERROR OR DONE BEFORE WAITING
	TSTW	IBF$Q_IOSB(R6)		; CHECK I/O STATUS BLOCK
	BNEQ	50$			; ERROR OR DONE

	$WAITFR_S	R2		; SWEEP IS STILL ON SO WAIT
	BLBS	R0,10$			; TRY AGAIN

40$:	; ERROR IN CLEARING OR WAITING FOR EVENT FLAG
	MOVL	R0,IBF$Q_IOST(R6)	; RETURN ERROR CODE IN I/O STATUS
	BRB	60$

50$:	; SWEEP FINISHED NORMALLY OR WITH ERROR.  RETURN I/O STATUS BLOCK
	MOVQ	IBF$Q_IOSB(R6),IBF$Q_IOST(R6)

60$:	MNEGL	#1,R0			; RETURN -1 INSTEAD OF INDEX
	BRB	80$

70$:	; HAVE A BUFFER ADDRESS IN R1.  CONVERT TO INDEX IN R0
	BSBW	CVTADINDX
	CLRW	IBF$Q_IOST(R6)		; RETURN 0 STATUS
	MOVW	IBF$L_LBUF(R6),IBF$Q_IOST+2(R6)	; RETURN BUFFER LENGTH

80$:	CMPB	(AP),#3			; IBUFNO SPECIFIED?
	BLSSU	90$			; NO
	MOVL	12(AP),R1		; GET ADDRESS OF IBUFNO
	BEQL	90$			; DEFAULTED
	MOVL	R0,(R1)			; STORE INDEX IN IBUFNO
90$:	RET				; INDEX IN R0 FOR FUNCTION CALL

	.SBTTL	LPA$RLSBUF - RELEASE BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED BY THE USER'S PROGRAM TO RELEASE A BUFFER
;	(OR BUFFERS) ONTO THE DEVICE QUEUE.  IT WORKS AS FOLLOWS:
;		1)  EACH BUFFER INDEX IS CONVERTED TO AN ADDRESS
;		2)  IF THE USW IS NOT CURRENTLY SET WITH A NEXT BUFFER INDEX
;		    THEN IT IS LOADED WITH THIS BUFFER'S INDEX AND THE BUFFER
;		    IS INSERTED ON THE TAIL OF THE INUSE QUEUE.
;		3)  OTHERWISE, THE BUFFER IS INSERTED ON THE TAIL OF THE
;		    DEVICE QUEUE.
;	IF BUFFER OVERRUN IS NON-FATAL, THEN BUFFER 0 IS HANDLED AS A
;	SPECIAL CASE.  INSTEAD OF BEING INSERTED ON THE DEVICE QUEUE,
;	A FLAG IS SET.  IF THIS FLAG IS NOT SET WHEN BUFFER OVERRUN OCCURS
;	THEN THE LPA-11 HAS USED BUFFER 0 BEFORE IT HAS BEEN RELEASED.
;	THIS IS RETURNED AS A DOUBLE BUFFER OVERRUN ERROR.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;
; INPUT PARAMETERS:
;
;	IBUF(AP)		ADDRESS OF IBUF ARRAY
;	IND(AP)			ADDRESS OF LONGWORD TO STORE RETURN STATUS
;	N0(AP)			ADDRESS OF LONGWORD CONTAINING BUFFER INDEX
;	  .
;	  .
;	N7(AP)			ADDRESS OF LONGWORD CONTAINING BUFFER INDEX
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	IND(AP)			ADDRESS OF LONGWORD TO RECEIVE RETURN STATUS
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	0		INDICATES ILLEGAL BUFFER NUMBER, INCORRECT # OF ARGS,
;			OR DOUBLE BUFFER OVERRUN OCCURED (THE LAST CASE CAN
;			ONLY OCCUR IF BUFFER OVERRUN IS NON-FATAL AND BUFFER 0
;			WAS RELEASED).
;	1		INDICATES BUFFER(S) SUCCESSFULLY RELEASED
;
; SIDE EFFECTS:
;
; VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$RLSBUF,^M<R2,R3,R4,R6>

	CLRL	R2			; RETURN CODE
	MOVZBL	(AP),R3			; GET # OF ARGUMENTS
	MOVL	4(AP),R6		; GET ADDRESS OF IBUF
	MOVAL	12(AP),R4		; POINT TO FIRST BUFFER INDEX ARG
	SUBL	#3,R3			; GET # OF BUFFERS TO RELEASE
	CMPL	R3,#7			; COMPARE WITH MAXIMUM
	BGTRU	60$			; TOO MANY OR TOO FEW ARGS SUPPLIED

20$:	; RELEASE NEXT BUFFER
	MOVL	@(R4)+,R0		; GET INDEX
	BNEQ	25$			; NOT BUFFER 0

	; HAVE BUFFER 0.  IS OVERRUN NOT FATAL?
	BBC	#LA$V_BFROVRN,IBF$L_CMDTBL(R6),25$	; BR. IF NO

	; BUFFER OVERRUN IS NOT FATAL AND THIS IS BUFFER 0.
	BISW	#FLG_M_BFR0RLSD,IBF$W_FLAGS(R6)	; SET BUFFER 0 RELEASED FLAG
	BBCC	#FLG_V_DBFROVRN,IBF$W_FLAGS(R6),50$  ; BR. IF NO DBL BFR OVRN
	BRB	60$			; DOUBLE BUFFER OVERRUN OCCURRED

25$:	; VERIFY BUFFER # IS WITHIN RANGE
	CMPZV	#0,#3,-			; COMPARE WITH HIGHEST BUFFER # ALLOWED
		IBF$L_CMDTBL+CMT$B_VBFRMASK(R6),R0
	BLSSU	60$			; SUPPLIED INDEX IS TOO HIGH - ERROR
	MOVAQ	IBF$Q_BFRLNKS(R6)[R0],R1; GET ADDRESS OF BUFFER LINK

	; SHOULD WE RELEASE THIS BUFFER ONTO DEVICE QUEUE OR ONTO
	; INUSE QUEUE AND LOAD USW
	BBSS 	#FLG_V_USWSET,IBF$W_FLAGS(R6),30$  ; BR. IF USW IS ALREADY SET
	BBS	#14,IBF$W_USW(R6),30$	; BR. IF REQUEST IS BEING STOPPED

	; INSERT ONTO TAIL OF INUSE QUEUE AND LOAD USW
	INSQUE	(R1),@IBF$L_INUQBL(R6)	; INSERT ONTO TAIL OF INUSE QUEUE
	MOVB	R0,IBF$W_USW+1(R6)	; LOAD NEXT BFR INDEX AND CLEAR DONE BIT
	BRB	50$

30$:	; INSERT BUFFER ONTO TAIL OF DEVICE QUEUE
	INSQUE	(R1),@IBF$L_DEVQBL(R6)

50$:	SOBGEQ	R3,20$			; DO NEXT ONE
	INCL	R2			; INDICATE SUCCESS

60$:	MOVL	8(AP),R0		; GET ADDRESS OF IND
	BEQL	70$			; DEFAULTED
	MOVL	R2,(R0)			; STORE RETURN STATUS
70$:	RET

	.SBTTL	LPA$$BFRAST - BUFFER FULL/EMPTY AST HANDLER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE AST HANDLER FOR NORMAL BUFFER FULL OR 
;	EMPTY ASTS.  PRIMARILY IT DOES THE FOLLOWING:
;		1)  REMOVE A BUFFER FROM HEAD OF DEVICE QUEUE
;		2)  LOAD THAT BUFFER'S INDEX INTO THE USW
;		3)  INSERT THAT BUFFER INTO TAIL OF INUSE QUEUE
;		4)  REMOVE A BUFFER FROM HEAD OF INUSE QUEUE
;		5)  INSERT THAT BUFFER INTO TAIL OF USER QUEUE
;
; CALLING SEQUENCE:
;
;	CALLS/G
;
; INPUT PARAMETERS:
;
;	IBUF(AP)	ADDRESS OF IBUF ARRAY (AST PARAMETER)
;	8(AP)		SAVED R0 (UNUSED)
;	12(AP)		SAVED R1 (UNUSED)
;	16(AP)		SAVED PC (UNUSED)
;	20(AP)		SAVED PSL (UNUSED)
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$$BFRAST,^M<R6>

	MOVL	4(AP),R6		; GET ADDRESS OF IBUF

	BBS	#14,IBF$W_USW(R6),40$		; BR. IF STOP BIT SET IN USW
	BBC	#FLG_V_CNTBFRS,IBF$W_FLAGS(R6),10$ ; BR. IF NOT COUNTING BUFFERS
	SOBGTR	IBF$L_NBUF(R6),10$	; BR. IF WE HAVEN'T FINISHED NBUF BFRS

	; NBUF BUFFERS HAVE BEEN FILLED OR EMPTIED.  STOP SWEEP
	MOVB	#^X40,IBF$W_USW+1(R6)	; SET STOP BIT IN USW
	BRB	40$

10$:	; REMOVE BFR FROM DEV. Q, LOAD INTO USW, AND INSERT INTO INUSE Q.
	REMQUE	@IBF$L_DEVQFL(R6),R1	; REMOVE FROM HEAD OF DEVICE QUEUE
	BVC	20$			; HAVE ONE
	BICW	#FLG_M_USWSET,IBF$W_FLAGS(R6)  ; NONE IN Q. CLEAR BIT FOR RLSBUF
	BRB	40$
20$:	BSBW	CVTADINDX		; CONVERT ADDRESS IN R1 TO INDEX IN R0
	MOVB	R0,IBF$W_USW+1(R6)	; LOAD USW (THIS ALSO CLEARS DONE BIT)
	INSQUE	(R1),@IBF$L_INUQBL(R6)	; INSERT IN TAIL OF INUSE QUEUE

40$:	; IF THIS IS THE FIRST AST (REQUEST STARTED) DON'T PUT A BUFFER
	; ON THE USER QUEUE
	BBCS	#FLG_V_SWPSTRTD,IBF$W_FLAGS(R6),80$  ; BR. IF FIRST TIME THROUGH

	; NOW REMOVE FROM HEAD OF INUSE QUEUE, INSERT ON TAIL OF USER QUEUE
	; AND CALL USER'S COMPLETION ROUTINE IF ONE WAS SPECIFIED.
	BSBW	GIVUSRBFR		; DOES IT ALL

80$:	RET

	.SBTTL	LPA$$OVRAST - BFR OVER/UNDERRUN AST HANDLER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE AST HANDLER FOR BUFFER OVER/UNDERRUN ASTS.
;	PRIMARILY, IT DOES THE FOLLOWING:
;		1)  REMOVE A BUFFER FROM HEAD OF INUSE QUEUE
;		2)  INSERT THAT BUFFER INTO TAIL OF USER QUEUE
;		3)  IF BUFFER 0 HAS BEEN RELEASED, THEN IT IS INSERTED INTO
;		    THE HEAD (!) OF THE INUSE QUEUE.  OTHERWISE, THE
;		    DOUBLE BUFFER OVERRUN BIT IS SET.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;
; INPUT PARAMETERS:
;
;	IBUF(AP)	ADDRESS OF IBUF ARRAY (AST PARAMETER)
;	8(AP)		SAVED R0 (UNUSED)
;	12(AP)		SAVED R1 (UNUSED)
;	16(AP)		SAVED PC (UNUSED)
;	20(AP)		SAVED PSL (UNUSED)
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;--

	.ENTRY	LPA$$OVRAST,^M<R6>

	MOVL	4(AP),R6		; GET ADDRESS OF IBUF

	; REMOVE HEAD OF INUSE QUEUE, INSERT ON TAIL OF USER QUEUE,
	; AND CALL USER'S COMPLETION ROUTINE IF ONE WAS SPECIFIED.
	BSBW	GIVUSRBFR		; DOES IT ALL

	; MAKE SURE BUFFER 0 HAS BEEN RELEASED.
	BBSC	#FLG_V_BFR0RLSD,IBF$W_FLAGS(R6),10$	; BR. IF IT HAS BEEN
	BISW	#FLG_M_DBFROVRN,IBF$W_FLAGS(R6)		; DBL BFR OVRN OCCURRED
	BRB	20$

10$:	; INSERT BUFFER 0 INTO HEAD OF INUSE QUEUE
	INSQUE	IBF$Q_BFRLNKS(R6),IBF$L_INUQFL(R6)

20$:	BBC	#FLG_V_CNTBFRS,IBF$W_FLAGS(R6),30$  ; BR. IF NOT COUNTING BFRS
	SOBGTR	IBF$L_NBUF(R6),30$	; BR. IF WE HAVEN'T FINISHED NBUF BFRS
	MOVB	#^X40,IBF$W_USW+1(R6)	; SET STOP BIT IN USW

30$:	RET

	.SBTTL	LPA$$CMPLTAST - QIO COMPLETE AST HANDLER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS THE QIO COMPLETE AST HANDLER.  PRIMARILY, IT DOES
;	THE FOLLOWING:
;	1)  UNDER CERTAIN CONDITIONS THERE IS AN EXTRA BUFFER TO BE PLACED
;	    ON THE USER QUEUE.  IF THERE IS, A BUFFER IS REMOVED FROM THE
;	    HEAD OF THE INUSE QUEUE AND INSERTED ON THE TAIL OF THE USER QUEUE.
;	2)  IF THE USER SPECIFIED A COMPLETION ROUTINE, IT IS CALLED.
;	3)  THE CHANNEL IS DEASSIGNED.
;
; CALLING SEQUENCE:
;
;	CALLS/G
;
; INPUT PARAMETERS:
;
;	IBUF(AP)	ADDRESS OF IBUF ARRAY (AST PARAMETER)
;	8(AP)		SAVED R0 (UNUSED)
;	12(AP)		SAVED R1 (UNUSED)
;	16(AP)		SAVED PC (UNUSED)
;	20(AP)		SAVED PSL (UNUSED)
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

	.ENTRY	LPA$$CMPLTAST,^M<R6>

	MOVL	4(AP),R6		; GET ADDRESS OF IBUF

	; WE HAVE AN EXTRA BUFFER IF THE STATUS IS NORMAL, BUFFER OVERRUN,
	; OR NON-FATAL ERROR COUNT EXCEEDED (SAME AS BUFFER OVERRUN).
	CMPW	IBF$Q_IOSB(R6),S^#SS$_NORMAL	; NORMAL STATUS?
	BEQL	20$			; YES
	CMPW	IBF$Q_IOSB(R6),#SS$_DEVREQERR	; REQUEST ERROR?
	BNEQ	40$			; NO, SO IT CAN'T BE EITHER OTHER ERROR
	CMPB	IBF$Q_IOSB+5(R6),#BFROVRN	;BUFFER OVER/UNDERRUN?
	BEQL	20$			; YES
	CMPB	IBF$Q_IOSB+5(R6),#NFECEX	; NON-FATAL ERROR COUNT EXC.?
	BNEQ	40$			; NO

20$:	; HAVE AN EXTRA BUFFER TO PLACE ON USER QUEUE.  REMOVE FROM HEAD
	; OF INUSE QUEUE, INSERT ON TAIL OF USER QUEUE, AND CALL USER'S
	; COMPLETION ROUTINE IF ONE WAS SPECIFIED.
	BSBW	GIVUSRBFR		; DOES IT ALL

40$:	; NOW CALL USER'S COMPLETION ROUTINE (POSSIBLY FOR THE SECOND TIME)
	; IF ONE WAS SPECIFIED.
	MOVL	IBF$L_COMPLADDR(R6),R0	; GET ADDRESS OF ROUTINE
	BEQL	50$			; NONE SPECIFIED
	CALLS	#0,(R0)			; CALL IT

50$:	; DEASSIGN CHANNEL
	$DASSGN_S	IBF$W_CHAN(R6)

	RET

	.SBTTL	CVTADINDX - CONVERT ADDRESS TO INDEX
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CONVERTS A BUFFER LINK ADDRESS TO A BUFFER INDEX
;
; CALLING SEQUENCE:
;
;	BSBW/B
;
; INPUT PARAMETERS:
;
;	R1	ADDRESS OF BUFFER LINK
;	R6	ADDRESS OF IBUF ARRAY
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0	CONTAINS BUFFER INDEX
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

CVTADINDX:
	MOVAB	IBF$Q_BFRLNKS(R6),R0	; GET ADDRESS OF START OF BUFFER LINKS
	SUBL3	R0,R1,R0		; SUBTRACT THAT FROM GIVEN BFR LINK ADDR
	DIVL	#8,R0			; DIVIDE BY 8 TO CONVERT TO INDEX
	RSB

	.SBTTL	GIVUSRBFR - GIVE USER BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE REMOVES A BUFFER FROM THE HEAD OF THE INUSE QUEUE,
;	INSERTS IT ON THE TAIL OF THE USER QUEUE, AND CALLS THE USER'S
;	COMPLETION ROUTINE, IF ONE WAS SPECIFIED.
;
; CALLING SEQUENCE:
;
;	BSBW/B
;
; INPUT PARAMETERS:
;
;	R6	ADDRESS OF IBUF ARRAY
;
; IMPLICIT INPUTS:
;
;	VARIOUS FIELDS IN THE IBUF ARRAY
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0,R1 ARE NOT PRESERVED
;	VARIOUS FIELDS IN THE IBUF ARRAY ARE MODIFIED
;
;--

GIVUSRBFR:
	; REMOVE BUFFER FROM HEAD OF INUSE QUEUE
	REMQUE	@IBF$L_INUQFL(R6),R0	; R0 CONTAINS ADDRESS
	BVS	20$			; QUEUE IS EMPTY - SHOULD NEVER HAPPEN!

	; INSERT BUFFER ON TAIL OF USER QUEUE
	INSQUE	(R0),@IBF$L_USRQBL(R6)

	; CALL USER'S COMPLETION ROUTINE IF ONE WAS SPECIFIED
	MOVL	IBF$L_COMPLADDR(R6),R0	; GET ADDRESS OF COMPLETION ROUTINE
	BEQL	20$			; NONE SPECIFIED
	CALLS	#0,(R0)			; CALL IT
20$:	RSB



LPA$BFEND::				; END OF BUFFER ROUTINES (MAY BE USED
					; TO LOCK THESE ROUTINES INTO THE
					; PROCESS'S WORKING SET).


	.END

