
	.TITLE	JBCSYMAN2 - SYMBIONT MANAGER MAIN ROUTINE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARTLET JOB CONTROLLER
;
; ABSTRACT:	SYMBIONT MANAGER MAIN ROUTINE
;
; ENVIRONMENT:	USER MODE, NON-PRIVLEDGED CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE:14-JAN-77
;
; MODIFIED BY:
;
;	V03-001	MLJ0082		Martin L. Jack,	15-Mar-1982  15:37
;		Check for ASSIGN/MERGE to same queue and return an error.
;
;	V02-007	MLJ0075		Martin L. Jack,	31-Jan-1982  21:52
;		Clear notify bit for a RMVJOB on an open job to avoid a
;		spurious broadcast message.
;
;	V02-006	LMP0008		L. Mark Pilant		22-Jan-1982  14:35
;		Modify RMVJOB to understand that if a job is being deleted
;		that contains spooled files, it should also delete the
;		spooled files.
;
;	V02-005	GWF0097		Gary W. Fowler		31-Jul-1981
;		Change call to queue search routine so all queues will be
;		searched on a SET QUEUE/RELEASE command.
;
;	V02-004	GWF0066		Gary W. Fowler		30-Jun-1981
;		Add support for /REQUEUE option.
;
;	V02-003	GWF0028		Gary W. Fowler		17-Apr-1981
;		Set status in job header when job is removed from a queue.
;
;	V02-002	GWF0002		Gary W. Fowler		29-Nov-1979
;		Add support for multiple symbiont types.
;
;	V02-001	-
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	$FIBDEF
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
;
; OWN STORAGE:
;
	IMPURE_DATA
;
JBC$W_RMVCHAN:
	.BLKW	1			; CHANNEL USED WHEN DELETING SPOOLED FILE
JBC$W_RMVIOSB:
	.BLKW	4			; I/O STATUS BLOCK FROM ACP DELETE CALL
JBC$Q_RMVDEV:
	.BLKQ	1			; DESCRIPTOR FOR SPOOLED FILE DEVICE
JBC$Q_RMVFIB:
	.LONG	FIB$C_ACCDATA		; FIB DESCRIPTOR
	.ADDRESS	JBC$B_RMVFIB
JBC$B_RMVFIB:
	.BLKB	FIB$C_ACCDATA		; STORAGE FOR VERY SHORT FIB

	.SBTTL	MERGE QUEUE CONTENTS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO HAVE THE CONTENTS OF A QUEUE
;	REMOVED AND MERGED INTO ANOTHER QUEUE.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT THE NAME OF THE QUEUE TO MERGE FROM
;	R6 CONTAINS THE ADDRESS OF THE QUEUE TO MERGE TO.
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	QUEUES ARE MERGED INTO 1, THE SOURCE QUEUE IS EMPTY.
;--
	PURE_SECTION
 
SYM$MERGE::				; MERGE A QUEUE WITH ANOTHER
	PUSHL	R6			; SAVE QUEUE TO MERGE INTO
	BSBW	SYM$FINDQUEUE		; LOOK FOR THE QUEUE TO MERGE FROM
	MOVL	R6,R8			; SET ADDRESS OF QUEUE TO MERGE FROM
	POPL	R6			; GET THE TARGET QUEUE BACK
	BLBC	R0,90$			; EXIT IF TARGET QUEUE IS NOT HERE
	CMPL	R6,R8			; Same queue?
	BEQL	100$			; Br if yes
10$:	MOVL	SMQ$L_HOLDLST(R8),R7	; GET FIRST RECORD IN HOLD LIST
	BEQL	20$			; BR IF NONE
	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB
	MOVL	SJH$L_NEXTJOB(R7),-	; CLOSE UP THE LIST OF HOLD LIST
		SMQ$L_HOLDLST(R8)	; ENTRIES FOR MERGE FROM QUEUE
	SYM_QUECHANGE			; FLAG CHANGE IN THE QUEUE
	SUBL3	R10,R6,R0		; FIND INDEX TO THIS QUEUE
	MOVW	R0,SJH$W_QINDEX(R7)	; SET NEW QUEUE INDEX
	BSBW	SYM$JOBINSQUE		; INSERT THIS JOB IN THE QUEUE
	BRB	10$			; CONTINUE TILL HOLD LIST IS EMPTY
20$:	PUSHAL	W^SYM$FINDQUEJOB	; SET ADDRESS FOR FIRST CO-ROUTINE CALL
30$:	MOVL	R6,R7			; SAVE ADDRESS OF QUEUE TO MERGE TO
	MOVL	R8,R6			; SET ADDRESS OF QUEUE TO REMOVE FROM
40$:	CLRL	R0			; INHIBIT DEQUEUING OF JOBS
	JSB	@(SP)+			; GET NEXT JOB FROM THE LIST
	BLBC	R0,80$			; BR IF THERE ARE NO MORE
	SUBL3	R10,R7,R1		; FIND OFFSET TO QUEUE HEADER
	MOVW	R1,SJH$W_QINDEX(R2)	; SET INDEX OF QUEUE TO JOB IS GOING TO
	TSTL	R4			; CHECK IF THIS JOB WAS IN A PRINT QUEUE
	BLEQ	40$			; BR IF NOT IN PRINT QUEUE
	JSB	@(SP)+			; RETURN AND REQUEST REMOVAL OF JOB
	MOVL	R2,R7			; SET JOB ADDRESS IN STANDARD REGISTER
	BSBW	SYM$JOBINSQUE		; QUEUE THE JOB TO THE NEW DEVICE
					; NOTE:R6 IS SET TO ADDRESS OF QUEUE
					; HEADER INTO WHICH THE JOB WAS MERGED.
	BRB	30$			; REQUEST SEARCH FOR NEXT
80$:	SETSTAT	NORMAL			; SET GOOD FINAL STATUS
90$:	RET				; BACK TO TOP LEVEL
100$:	SETSTAT	SMINVOPR		; Error if merge queue to self
	RET				; Return

	.SBTTL	REDIRECT QUEUE CONTENTS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO HAVE THE CONTENTS OF A QUEUE
;	REDIRECTED TO ANOTHER QUEUE FOR PROCESSING.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT THE NAME OF THE QUEUE TO REDIRECT TO
;	R6 CONTAINS THE ADDRESS OF THE QUEUE TO BE REDIRECTED.
;
;	IF THE TARGET QUEUE NAME IS NULL, THIS IS A REDIRECT OF
;	A QUEUE BACK TO ITSELF.
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	THE REDIRECTION IS EFFECTED IF THE OPERATION IS PROPERLY REQUESTED.
;--
	PURE_SECTION
 
SYM$REDIRECT::				; REDIRECT A QUEUE
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),50$ ; BR IF BATCH QUEUE-CAN'T DO!
	TSTB	(R5)			; IS SECOND NAME NULL?
	BEQL	20$			; BR IF YES-GO UNDO A REDIRECT
	BBS	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),50$ ; ONE LEVEL OF REDIRECTION
	MOVL	R6,R8			; SAVE ADDRESS OF TARGET QUEUE
	BSBW	SYM$FINDQUEUE		; LOCATE THE OTHER QUEUE
	BLBC	R0,40$			; BR IF SEARCH FOR QUEUE FAILED
	CMPL	R6,R8			; TRYING TO REDIRECT QUEUE TO ITSELF?
	BEQL	50$			; BR IF YES-THAT IS NOT ALLOWED
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),50$ ; BR IF BATCH QUEUE-CAN'T DO!
	BSBB	60$			; CHECK THAT QUEUE IS STOPPED
	SUBL3	R10,R8,SMQ$L_ASNSCT(R6) ; SET INDEX TO ACTUAL QUEUE TO USE
	SETBIT	SMQ$V_REDIRECT,SMQ$B_CHAR(R6) ; MARK QUEUE REDIRECTED
	RET				;
;
; SECOND QUEUE NAME IS NULL - UNDO REDIRECT
;
20$:	BSBB	60$			; VERIFY QUEUE IS STOPPED
	BBCC	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),50$ ; BR IF NOT REDIRECTED
40$:	RET				;
 
50$:	SETSTAT	SMINVOPR		; SET STATUS INVALID OPERATION
	RET				;
;
; LOCAL SUBROUTINE TO VERIFY THAT THE TARGET QUEUE IS STOPPED
;
 
60$:	TSTL	SMQ$L_CURRENT(R6)	; JOB RUNNING?
	BNEQ	70$			; BR IF JOB IS PRINTING
	BBC	#SMQ$V_STOPPED,SMQ$B_FLAGS(R6),70$ ; QUEUE STOPPED EXPLICITLY
	RSB				;
70$:	SETSTAT	QUENOSTOP		; ASSUME QUEUE IS NOT STOPPED
	RET				;

	.SBTTL	JUSTIFY PRINT FORMS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE OUTPUTS AN ADVANCE TO TOP-OF-FORM
;	REQUEST FOR THE DEVICE ASSOCIATED WITH THE SPECIFIED
;	QUEUE.  THIS IS ITENDED TO PERMIT FORMS ALIGNMENT.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE QUEUE HEADER FOR DEVICE FOR
;	   WHICH TOP-OF-FORM SHOULD BE REQUESTED.
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE FINAL STATUS OF THE REQUEST.
;
; SIDE EFFECTS:		NONE
;--
 
SYM$JUSTIFY::				; JUSTIFY THE FORMS
	RET				; NOP FOR NOW

	.SBTTL	STOP PRINTING OF DEVICE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN A REQUEST HAS BEEN MADE TO STOP
;	PRINTING ON A DEVICE.  THE QUEUE IS MARKED STOPPED AND ANY
;	FILES QUEUED TO THAT SPECIFIC DEVICE ARE INSERTED IN THE
;	DEVICE HOLD QUEUE.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE PROPER DEVICE QUEUE
;	R9 HAS ADDRESS OF SYMBIONT MANAGER MESSAGE
;
; IMPLICIT INPUTS:
;
;	R10 HAS ADDRESS OF THE QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	IF THE QUEUE EXISTS IT IS STOPPED
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE FINAL STATUS OF THE REQUEST.
;
; SIDE EFFECTS:		NONE
;--

SYM$STOP::
	BBSS	#SMQ$V_STOPPED,-	; DON'T STOP WHATS STOPPED
		SMQ$B_FLAGS(R6),40$	;
	PUSHAB	W^SYM$FINDACTJOB	; INITIALIZE COROUTINE ADRESSS
10$:	JSB	@(SP)+			; COROUTINE LINKAGE TO SEARCH QUEUE
	BLBC	R0,30$			; BR IF NO MORE FOUND
	JSB	@(SP)+			; ASK TO REMOVE THIS JOB
	MOVL	SMQ$L_HOLDLST(R6),-	; COPY PREVIOUS FIRST FILE IN HOLD LIST
		SJH$L_NEXTJOB(R2)	; AS NEXT JOB AFTER ONE JUST DEQUEUED
	SUBL3	R10,R2,SMQ$L_HOLDLST(R6) ; SET THIS FILE AS FIRST IN HOLD LIST
	BRB	10$			; SEE IF GOT ONE
30$:	BITB	#<SMQ$M_DETJOB!SMQ$M_GENDEV>,- ; CK IF QUEUE IS JOB OR GENERIC
		SMQ$B_FLAGS(R6)		; DEVICE QUEUE.
	BNEQ	40$			; BR IF EITHER-NO SYMBIONT INVOLVED
	BBS	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),40$ ; LIKEWISE IF REDIRECTED
	CLRL	R0			; SET REQUEST TO DEALLOCATE
	BSBB	SYM$ALLODEAL		; ALLOCATE/DEALLOCATE DEVICE
	SETBIT	#JBC_V_SYMINIREQ,-	; SET FLAG TO INITIATE A SYMBIONT, THAT
		JCD_W_FLAGS(R11)	; CAUSE A DELETE IF A SYMBIONT IS IDLE
	MOVL	SMQ$L_PNMTAB(R6),R0	; GET POINTER TO SYMB. NAME TABLE
	DECB	CURPDEV(R0)		; DECR. NO. OF DEVICES USING THIS SYMB.
	DECB	JCD_B_CURPDEV(R11)	; COUNT DOWN NUMBER OF ACTIVE DEVICES
40$:	SETSTAT	NORMAL			; SET SUCESSFUL STATUS
	RET

	.SBTTL	ALLOCATE/DEALOCATE A DEVICE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ALLOCATE OR DEALLOCATE A DEVICE
;	FOR WHICH A QUEUE HAS BEEN STARTED OR STOPPED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$ALLODEAL			;
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE PROPER DEVICE QUEUE
;	R0 IS ALLOCATE/DEALLOCATE FLAG WHERE TRUE=ALLOCATE
;
; IMPLICIT INPUTS:
;
;	R10 HAS ADDRESS OF THE QUEUE FILE
;
; OUTPUT PARAMETERS:		NONE
;
; COMPLETION CODES:
;
;	R0 CONTAINS THE FINAL STATUS OF THE SYSTEM SERVICE
;
; SIDE EFFECTS:
;
;	R2,R3 ARE USED BY THIS ROUTINE
;
;--

SYM$ALLODEAL::					;
	MOVAB	SMQ$T_NAME(R6),R3	; ADDRESS OF THE DEVICE NAME
	MOVZBL	(R3),R2			; GET LENGTH OF DEVICE NAME
	MOVB	#^A/_/,(R3)		; DISABLE LOGICAL NAME SUBSTITUTION
	PUSHR	#^M<R2,R3>		; FORM DESCRIPTOR FOR DEVICE NAME
	INCL	(SP)			; ADJUST LENGTH FOR THE UNDER SCORE
	MOVL	SP,R1			; ADDRESS OF NAME DESCRIPTOR
	BLBC	R0,10$			; BR IF REQUEST IS DEALLOCATE
	$ALLOC_S  DEVNAM=(R1)		; ALLOCATE THE DEVICE
	BRB	20$			;
10$:	$DALLOC_S DEVNAM=(R1)		; DEALLOCATE THE DEVICE
20$:	CLRQ	(SP)+			; REMOVE DEVICE NAME DESCRIPTOR
	MOVB	R2,(R3)			; RESET DEVICE NAME STRING LENGTH
	RSB

	.SBTTL	ALTER JOB CHARACTERISTICS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN A REQUEST HAS BEEN MADE TO
;	CHANGE SOME OF THE CHARACTERISTICS FOR A CURRENTLY QUEUED
;	JOB.  THE JOB IS DEQUEUED,AND THEN OPTIONS ARE PROCESSED
;	AS THOUGH THE JOB WAS JUST QUEUED, THEN THE JOB IS RE-
;	QUEUED BASED ON ITS NEW CHARACTERISTICS.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT THE RECORD NUMBER FOR THE JOB HEADER TO RELEASE
;	R6 CONTAINS THE ADDRESS OF THE ASSOCIATED DEVICE QUEUE HEADER
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	THE JOB CHARATERISTICS ARE CHANGED AND THE JOB IS REQUEUED
;
; COMPLETION CODES:
;
;	R0 = NORMAL IF JOB IS FOUND AND ALTERED CORRECTLY
;	   = NOPRIV IF REQUESTOR CANT DO WHAT HE WANTS
;	   = NOSUCHJOB IF JOB NOT FOUND
;	   = SMINVOPT IF OPTION SPECIFIED THAT IS INCORRECT
;
; SIDE EFFECTS:
;
;	IF AN INVALID OPTION IS DETECTED, THE PROCESSING OF THE REQUEST
;	STOPS AT THAT POINT, ANS JOB IS RE-QUEUED IN ITS STATE AT THE 
;	TIME THE ERROR WAS DETECTED.
;
;--
 
SYM$ALTER::				; ALTER JOB CHARACTERISTICS
	BSBW	SYM$GETCLSJOB		; TRY TO FIND THE JOB-NO RETURN ON ERROR
	ADDL3	R10,SJH$L_RECLINK(R7),R8 ; SET ADDRESS OF FIRST RECORD IN JOB
	MOVW	SJH$W_QINDEX(R7),-	; ASSUME JOB WILL BE PUT BACK
		SJH$W_REQINDX(R7)	; IN SAME QUEUE
	BSBW	SYM$CNVOPTENT		; PROCESS OPTIONS AS THOUGH IT WAS ENTER
	PUSHL	R0			; SAVE STATUS OF OPTION PROCESSING
	MOVW	SJH$W_REQINDX(R7),-	; QUEUE INDEX OF QUEUE TO
		SJH$W_QINDEX(R7)	; PLACE JOB IN
	BSBW	SYM$JOBINSQUE		; RE-QUEUEU THE JOB
	POPR	#^M<R0>			; RESTORE STATUS
	RET				; RETURN WITH THE STATUS

	.SBTTL	REMOVE JOB FORM QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO REMOVE A JOB FROM THE QUEUE
;	AND RELEASE THE QUEUE SPACE TO THE FREE LIST
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT THE RECORD NUMBER FOR THE JOB HEADER TO RELEASE
;	R6 CONTAINS THE ADDRESS OF THE ASSOCIATED DEVICE QUEUE HEADER
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	THE JOB IS REMOVED FROM THE QUEUE AND THE RECORDS ARE FREED.
;
;
; COMPLETION CODES:
;
;	R0 = NORMAL IF JOB IS SUCESSFULLY DEQUEUED AND RELEASED
;
; SIDE EFFECTS:		NONE
;--
 
SYM$RMVJOB::				; REMOVE JOB FROM QUEUE
	MOVL	SMQ$L_CURRENT(R6),R7	; GET THE INDEX TO CURRENT JOB
10$:	BEQL	30$			; BR IF NOT A CURRENT JOB
	ADDL	R10,R7			; FIND ADDRESS OF JOB
	CMPW	(R5),SJH$W_JOBSEQ(R7)	; IS THIS THE JOB TO REMOVE?
	BEQL	50$			; XFER IF SO...SYMBIONT WILL DELETE FILE
20$:	MOVL	SJH$L_NEXTJOB(R7),R7	; FOLLOW THE LINK TO NEXT JOB
	BRB	10$			; AND CHECK IF THAT IS THE ONE
30$:	PUSHL	R6			; SAVE ADDRESS OF QUEUE HEADER
	MOVAL	SQH$K_SIZE(R10),R6	; POINT AT FIRST QUEUE
	MOVZBL	SQH$B_MAXQUE(R10),R4	; SET COUNT OF QUEUES TO SEARCH
40$:	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),70$ ; BR IF QUEUE NOT IN USE
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),70$ ; DO NOT CHECK BATCH QUEUES
	MOVL	SMQ$L_CURRENT(R6),R7	; GET ADDRESS OF CURRENT JOB
	BEQL	70$			; BR IF NO SUCH JOB
	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB HEADER
	CMPW	(R5),SJH$W_JOBSEQ(R7)	; IS THIS THE JOB WERE LOOKING FOR
	BNEQ	70$			; XFER IF NOT...TRY THE NEXT JOB
50$:	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),60$ ; DO NOT ADVANCE BATCH QUEUES
	TSTW	(R5)+			; ADVANCE POINTER PAST ENTRY NUMBER
60$:	BRW	SYM$ABORT		; PROCESS ABORT
70$:	ADDL	#SMQ$K_SIZE,R6		; POINT AT NEXT QUEUE
	SOBGTR	R4,40$			; CHECK NEXT IF THERE IS MORE
	POPL	R6			; GET ORIGINAL QUEUE BACK
80$:	BSBW	SYM$FINDOPENJOB		; LOOK FOR AN OPEN JOB
	BLBC	R0,90$			; BR IF NOT OPEN
	BICB2	#SJH$M_NOTIFY,SJH$B_FLAGS(R7) ; Clear notify bit
	MOVL	SJH$L_NEXTJOB(R7),(R2)	; CLOSE THE LIST
	SYM_QUECHANGE			; TELL THAT THE QUEUE CHANGED
	BRB	100$			; EXIT
90$:	BSBW	SYM$GETCLSJOB		; REMOVE THE JOB FROM THE QUEUE
100$:	MOVL	#JBC$_JOBABORT,R0	; SET STATUS FOR BATCH SYNC
	MOVL	R0,SJH$L_FINALSTS(R7)	; SET STATUS IN JOB HEADER
	MOVL	SJH$L_RECLINK(R7),R0	; GET OFFSET TO QUEUE RECORD
	BEQL	105$			; XFER IF NONE
	ADDL2	R10,R0			; ELSE CALC ACTUAL ADDRESS
	TSTW	SQR$W_DIRNUM(R0)	; DIRECTORY-ID GIVEN?
	BEQL	110$			; XFER IF NOT...DELETE SPOOLED FILE
105$:	BRW	140$			; ELSE SKIP...PRINT SYMBIONT WILL DELETE
110$:	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6>	; ELSE SAVE MOVC/WORK REGS
	MOVL	R0,R6			; SAVE QUEUE RECORD ADDRESS FOR LATER
	MOVAB	JBC$B_RMVFIB,R5		; SET ADDRESS OF THE DELETE FIB
	MOVW	SQR$W_FILNUM(R6),FIB$W_FID_NUM(R5)	; SET FILE-ID
	MOVW	SQR$W_FILSEQ(R6),FIB$W_FID_SEQ(R5)
	MOVW	SQR$W_RELVOL(R6),FIB$W_FID_RVN(R5)
	MOVAB	JBC$Q_RMVDEV,R4		; SET ADDRESS OF DEVICE DESCRIPTOR
	MOVAB	SQR$T_VOLNAM(R6),R0	; SET ADDRESS OF COUNTED STRING
	MOVZBL	(R0)+,(R4)		; SET SIZE OF DESCRIPTOR
	MOVL	R0,4(R4)		; SAVE ADDRESS PORTION
	$ASSIGN_S	DEVNAM=(R4),-	; ASSIGN A CHANNEL TO THE DEVICE
			CHAN=JBC$W_RMVCHAN
	BLBC	R0,120$			; XFER IF ANY ERRORS
	$QIOW_S	CHAN=JBC$W_RMVCHAN,-	; ELSE DELETE THE FILE
		FUNC=#IO$_DELETE!IO$M_DELETE,-
		IOSB=JBC$W_RMVIOSB,-
		P1=JBC$Q_RMVFIB
	BLBC	R0,120$			; XFER IF ANY QIO ERRORS
	MOVZWL	JBC$W_RMVIOSB,R0	; ELSE GET ACP STATUS
	BLBS	R0,130$			; XFER IF FILE DELETED
120$:	BISB2	#1@SJH$V_HOLD,SJH$B_FLAGS(R7)	; MARK THE JOB AS HELD
	RET				; RETURN WITHOUT DELETING THE JOB
130$:	$DASSGN_S	CHAN=JBC$W_RMVCHAN	; DEASSIGN THE CHANNEL
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6>	;RESTORE MOVC/WORK REGS
140$:	BSBW	SYM$FREEJOB		; RELEASE THE RECORDS
	SETSTAT	NORMAL			; SET GOOD STATUS
	RET				; BACK TO THE TOP

	.SBTTL	RELEASE HELD JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN A REQUEST IS RECIEVED TO
;	RELEASE A JOB THAT WAS PREVIOUSLY PUT ON INDEFINITE
;	HOLD. THE HOLD LIST FOR THE SPECIFIED QUEUE IS SEARCHED
;	FOR THE SPECIFIED JOB, AND IF NOT FOUND, RETURNS ERROR.
;	IF FOUND, AND THE USER HAS PROPER PRIVILEGE TO RELEASE 
;	THE JOB, THE HOLD BIT IS SET, AND THE JOB IS RE-QUEUED.
;	NOTE THAT IF THE JOB HAD ALSO BEEN GIVEN A HOLD TIME
;	WHEN IT WAS ORIGINALLY QUEUED, THIS REQUEST WILL FAIL,
; 	SINCE THAT JOB WILL BE IN THE CLOCK QUEUE AND WILL NOT
;	BE FOUND WHEN THE HOLD QUEUE IS SEARCHED.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT THE RECORD NUMBER FOR THE JOB HEADER TO RELEASE
;	R6 CONTAINS THE ADDRESS OF THE ASSOCIATED DEVICE QUEUE HEADER
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	IF JOB IS FOUND AND NO PRIVILEGES CHECK FAILS, THE JOB IS
;	REMOVED FROM THE HOLD STATE AND RE-QUEUED.
;
; COMPLETION CODES:
;
;	R0 = NORMAL IF JOB RELEASED FROM HOLD OK
;	   = NOSUCHJOB IF JOB INDICATED NOT ON HOLD
;	   = NOPRIV IF PRIVILEGE VIOLATION OCCURS
;
; SIDE EFFECTS:		NONE
;--
 
SYM$RELEASE::				; RELEASE THE JOB
	BSBW	SYM$GETCLSJOB		; GET THE JOB FORM THE HOLD QUEUE
	BLBC	R0,50$			; BR IF NO JOB FOUND
	BICB	#<1@SJH$V_HOLD>,-	; CLEAR HOLD THIS JOB FLAG
		SJH$B_FLAGS(R7)		; IN JOB HEADER RECORD
	BSBW	SYM$JOBINSQUE		; INSERT THE JOB IN THE QUEUE
	SETSTAT	NORMAL			; SET SUCESSFUL STATUS
50$:	RET				; RETURN WITH STATUS
	.END				;
