	.TITLE	JBCSYMAN3 - SYMBIONT MANAGER MAIN ROUTINE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARTLET JOB CONTROLLER
;
; ABSTRACT:	SYMBIONT MANAGER MAIN ROUTINE
;
; ENVIRONMENT:	USER MODE, NON-PRIVLEDGED CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE:14-JAN-77
;
; MODIFIED BY:
;
;	V03-001	MLJ0086		Martin L. Jack,	4-Apr-1982  1:59
;		If a process opens a job when it has an open job, free the
;		previous job rather than queuing it.  (This occurs when a user
;		CTRL/Y's out of a PRINT command and issues another.)
;
;	V02-006	LMP0007		L. Mark Pilant		20-Jan-1982  14:25
;		Allow syncing with a batch job if the process which previously
;		had been syncing has gone away (for what ever reason).
;
;	V02-005	GWF0078		Gary W. Fowler		16-Jul-1981
;		Change job name to ASCIC string.
;
;	V02-004	GWF0038		Gary W. Fowler		08-May-1981
;		Modify to include file size.
;		
;	V02-003	GWF0003		Gary W. Fowler		06-Apr-1981
;		Add calls to routine to deallocate records for queue name and
;		log file name.  Modify to set proper bits in flags word passed
;		to LOGINOUT.
;
;	V02-002	GWF0002		Gary W. Fowler		23-Aug-1979
;		Changed error messages when queue named in SYNC command is not
;		a batch queue and when two processes attempt to SYNC with the 
;		same job.
;
;	V02-001	-
;
;
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	$DVIDEF				; DEFINE $GETDVI ITEM CODES
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
;
; OWN STORAGE:
;
;	NONE

	.SBTTL	CREATE PRINT JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE CREATES A PRINT JOB FOR THE REQUESTING
;	PROCESS.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 CONTAIN THE ADDRESS OF THE PROPER DEVICE QUEUE
;	R9 HAS SYMBIONT MANAGER MESSAGE
;
; IMPLICIT INPUTS:
;
;	R10 HAS BASE ADDRESS OF THE QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	THE JOB IS CREATED AND INSERTED IN THE OPEN JOB LIST
;
; COMPLETION CODES:
;
;	R0 CONTAINS STATUS
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION

SYM$CREJOB::
	BSBW	SYM$FINDOPENJOB		; FIND OPEN JOB FOR THE REQUESTOR
	BLBC	R0,40$			; BR IF JOB NOT FOUND
	MOVL	SJH$L_NEXTJOB(R7),(R2)	; CLOSE THE LIST
	SYM_QUECHANGE			; CHANGE QUEUE FILE SEQUENCE
	BSBW	SYM$FREEJOB		; RELEASE THE JOB
40$:	BSBW	SYM$INIPRTJOBHD		; SET UP JOB HEADER
	BSBW	SYM$CNVOPTJOB		; PROCESS USER SUPPLIED OPTIONS
	BLBS	R0,20$			; BR IF NO ERROR
	PUSHL	R0			; SAVE ERROR CODE
	PUSHL	SJH$L_QNMLNK(R7)	; LINK TO QUEUE NAME
	CALLS	#1,SYM$RIDXTRA		; DEALLOCATE IF THERE
	PUSHL	SJH$L_LOGLNK(R7)	; LINK TO QUEUE NAME OF LOG FILE
	CALLS	#1,SYM$RIDXTRA		; DEALLOCATE IF THERE
	MOVL	R7,R0			; SET ADDRESS OF JOB HEADER
	BSBW	SYM$DEARECORD		; RELEASE IT TO FREE LIST
	POPR	#^M<R0>			; RESTORE ERROR
	BRB	90$			; TAKE COMMON EXIT
20$:	MOVL	SQH$L_OPENJOB(R10),SJH$L_NEXTJOB(R7) ; SET PRVIOUS FIRST AS NEXT
	SUBL3	R10,R7,SQH$L_OPENJOB(R10) ; SET NEW JOB AS CURRENT FIRST
	BBC	#SJH$V_NOSPOOL,-	; CHECK NOSPOOL BIT
		SJH$L_GQNMFLG(R7),80$	; IN FLAGS WORD - BR IF CLEAR
	BBS	#SJH$V_NODELET,-	; CHECK NODELETE BIT
		SJH$L_GQNMFLG(R7),80$	; IN FLAGS WORD
	SETBIT	SJH$V_DELCLOS,SJH$L_GQNMFLG(R7); NOSPOOL/DELETE - LOGINOUT DEL IT
80$:	BBC	#SJH$V_NOLOG,-		; CHECK NO LOG BIT
		SJH$L_GQNMFLG(R7),90$	; IN FLAGS WORD
	SETBIT	SJH$V_NOSPOOL,-		; NOLOG IMPLIES
		SJH$L_GQNMFLG(R7)	;  NOSPOOL
90$:	RET				; BACK TO SYMBIONT MANAGER DISPATCHER

	.SBTTL	CLOSE A PRINT JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CLOSE AN OPEN PRINT JOB, CAUSING
;	THE JOB TO BE PLACED INTO ONE OF THE SYMBIONT QUEUES
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R9 CONTAINS THE ADDRESS OF THE SYMBIONT MANAGER MESSAGE
;
; IMPLICIT INPUTS:
;
;	R10 HAS THE BASE ADDRESS OF THE SYMBIONT MANAGER QUEUE
;
; OUTPUT PARAMETERS:
;
;	THE JOB IS REMOVED FOR THE OPEN JOB LIST AND INSERTED INTO
;	ONE OF THE SYMBIONT QUEUES IF IT EXISTS AND IS NON-EMPTY
;
; IMPLICIT OUTPUTS:
;
;	JOB HEADER IS RELEASED IF THE JOB CONTAINS NO RECORDS
;
; COMPLETION CODES:
;
;	R0 CONTAINS THE FINAL STATUS OF THE REQUESTS
;
; SIDE EFFECTS:		NONE
;--

SYM$CLSJOB::
	BSBW	SYM$FINDOPENJOB		; FIND OPEN JOB FOR THE REQUESTOR
	BLBC	R0,40$			; BR IF JOB NOT FOUND
	MOVL	SJH$L_NEXTJOB(R7),(R2)	; CLOSE THE LIST
	SYM_QUECHANGE			; CHANGE QUEUE FILE SEQUENCE
	TSTL	SJH$L_RECLINK(R7)	; EMPTY JOB?
	BNEQ	20$			; BR IF JOB IS OK
	BSBW	SYM$FREEJOB		; RELEASE THE JOB
	SETSTAT	SMZEROJOB		; SET ERROR
	BRB	40$			; JOIN COMMON EXIT
20$:	BSBW	SYM$JOBINSQUE		; INSERT JOB IN THE QUEUE
	SETSTAT	NORMAL			; SET SUCESSFUL STATUS
40$:	RET

	.SBTTL	ADD FILE TO PRINT JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ADD A FILE TO THE OPEN JOB
;	FOR THE SPECIFIED PROCESS
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R9 CONTAINS THE ADDRESS OF THE SYMBIONT MANAGER MESSAGE
;	WITH THE INFORMATION ABOUT THE FILE TO ADD.
;
; IMPLICIT INPUTS:
;
;	R10 CONTAINS THE BASE ADDRESS OF THE SYMBIONT MANAGER QUEUE
;
; OUTPUT PARAMETERS:
;
;	THE RECORD IS ADDED TO THE JOB
;
; COMPLETION CODES:
;
;	R0 CONTAINS THE FINAL STATUS OF THE REQUEST
;
; SIDE EFFECTS:		NONE
;--

SYM$ADDFIL::
	BSBW	SYM$FINDOPENJOB		; LOCATE THE JOB-RET ISSUED ON ERROR
	BLBC	R0,50$			; BR IF ERROR FINDING JOB
	BSBW	SYM$INIPRTREC		; SET UP THE RECORD
	BLBC	R0,50$			; BR IF ERROR SETTING RECORD DESCRIPTOR
	BSBW	SYM$CNVOPTENT		; PROCESS OPTIONS SAME AS ENTER FILE
	BLBS	R0,10$			; BR IF NO ERROR
	PUSHL	R0			; SAVE THE ERROR
	MOVL	R8,R0			; SET RECORD TO DEALLOCATE
	BSBW	SYM$DEARECORD		; RELEASE THE RECORD
	POPR	#^M<R0>			; RESTORE THE ERROR CODE
	BRB	50$			; GO BACK
10$:	MOVL	R7,R2			; COPY JOB HEADER FOR SEARCH OF JOB
20$:	MOVL	R2,R1			; SAVE LAST RECORD ADDRESS
	MOVL	SQR$L_RECLINK(R1),R2	; FOLLOW THE LINKS
	BEQL	30$			; BR IF RUN OUT OF LINKS
	ADDL	R10,R2			; FIND REAL ADDRESS OF THIS RECORD
	BRB	20$			; LOOK AGAIN
30$:	SUBL3	R10,R8,SQR$L_RECLINK(R1) ; LINK NEW RECORD AT END OF LIST
	MOVZBL	SQR$B_COPYCNT(R8),R0	; GET NUMBER OF COPIES OF THIS FILE
	MULL2	R0,SQR$L_FILESIZ(R8)	; MULTIPLY BY FILE SIZE
	SETSTAT	NORMAL			; SET SUCESSFUL STATUS
50$:	RET				; RETURN TO SYMBIONT MANAGER DISPATCHER

	.SBTTL	ENTER FILE IN PRINT QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTER WHEN A PROCESS HAS REQUESTED
;	THAT A FILE BE PRINTED.  THIS RESULTS IN THE CREATION
;	OF A PRINT JOB WITH A SINGLE ENTRY.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 HAS THE ADDRESS OF THE PROPER DEVICE QUEUE
;	R9 HAS THE ADDRESS OF THE MESSAGE
;
; IMPLICIT INPUTS:
;
;	R10 HAS THE ADDRESS OF THE PRINT QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	THE JOB IS CREATED AND INSERTED INTO ONE OF THE QUEUES
;	DEPENDING UPON THE DATA SPECIFIED IN THE REQUEST.
;	IF THERE IS AN ERROR DETECTED WHILE PROCESSING THE
;	REQUEST, NO ENTRY IS MADE.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 CONTAINS SUCESS OF FAILURE STATUS
;
; SIDE EFFECTS:
;
;	NONE
;
;--

SYM$ENTER::
	BSBW	SYM$INIPRTJOBHD		; SET UP COMMON PART OF PRINT JOB HEADER
	BSBW	SYM$INIPRTREC		; SET UP PRINT RECORD
	BLBC	R0,20$			; BR IF THERE WAS AN ERROR
	SUBL3	R10,R8,SJH$L_RECLINK(R7) ; LINK FILE INTO ITS JOB
	BSBW	SYM$CNVOPTENT		; CONVERT OPTION CODES
	BLBC	R0,20$			; BR IF ERROR PROCESSING OPTIONS
	MOVZBL	SQR$B_COPYCNT(R8),R0	; GET NUMBER OF COPIES OF THIS FILE
	MULL2	R0,SQR$L_FILESIZ(R8)	; MULTIPLY BY FILE SIZE
	BSBW	SYM$JOBINSQUE		; INSERT THE JOB INTO SOME QUEUE
	SETSTAT	NORMAL			; SET SUCESSFULL STATUS
	BRB	90$			; CLEAR OUT OF HERE
;
; AN ERROR WAS ENCOUNTERED WHILE PROCESSING OPTIONS
;	MUST DEALLOCATE JOB AND FILE RECORDS
;
20$:	PUSHL	R0			; SAVE ERROR CODE
	MOVL	R7,R0			; SET JOB HEADER ADDRESS
	BSBW	SYM$FREEJOB		; RELEASE THE RECORDS
	POPR	#^M<R0>			; RESTORE ERROR CODE
90$:	RET				; RETURN TO TOP LEVEL

	.SBTTL	SYNCRONIZE WITH A BATCH JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ESTABLISH A MAILBOX TO RECIEVE
;	A MESSAGE WHEN A BATCH JOB TERMINATES.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE ENTRY NUMBER FOLLOWED BY JOB NAME
;	R9 CONTAINS THE ADDRESS OF THE SYMBIONT MANAGER MESSAGE
;	R10 CONTAINS THE BASE ADDRESS OF THE SYMBIONT MANAGER QUEUE
;
; OUTPUT PARAMETERS:
;
;	THE MAILBOX IS SET TO RECIEVE THE MESSAGE
;
; COMPLETION CODES:
;
;	R0 CONTAINS THE FINAL STATUS OF THE REQUEST
;
; SIDE EFFECTS:		NONE
;--
SYM$SYNCJOB::				;
	SETSTAT	ILLQUENAM		; ASSUME NOT A BATCH QUEUE
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),5$ ; BR IF A BATCH QUEUE
	RET				; ELSE RETURN NOW WITH ERROR
5$:	MOVL	SMQ$L_CURRENT(R6),R7	; GET OFFSET TO FIRST ACTIVE JOB
	BSBB	10$			; SEARCH FOR TARGET JOB
	PUSHAB	B^20$			; NEXT PLACE IF NOT IN HOLD LIST
	MOVL	SMQ$L_HOLDLST(R6),R7	; GET OFFSET TO FIRST HOLD LIST ENTRY
10$:	BEQL	15$			; BR IF EMPTY LIST
	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB HEADER
	BSBW	100$			; COMPARE WITH TARGET JOB
	BEQL	50$			; BR IF FOUND THE JOB
	MOVL	SJH$L_NEXTJOB(R7),R7	; GET OFFSET TO NEXT JOB
	BNEQ	10$			; CHECK THIS ONE OUT
15$:	RSB				;
20$:	BSBW	SYM$FINDCLSJOB		; FIND A CLOSED JOB FOR THIS QUEUE
30$:	BLBC	R0,60$			; BR IF NO SUCH JOB
	MOVL	R2,R7			; SET ADDRESS OF JOB HEADER
	BSBB	100$			; COMPAIR
	BEQL	40$			; BR IF FOUND
	CLRL	R0			; DON'T DEQUE THE JOB
	JSB	@(SP)+			; GET THE NEXT JOB IN THE QUEUE
	BRB	30$			;
40$:	TSTL	(SP)+			; CLEAR CO-ROUTINE LINK ADDRESS
50$:	TSTW	SJH$W_MBCHAN(R7)	; SOMEONE ALREADY WAITING?
	BEQL	55$			; XFER IF NOT
	PUSHR	#^M<R2,R3,R4>		; SAVE WORK REGS
	CLRQ	-(SP)			; MAKE ROOM FOR $GETDVI ITEM LIST
	CLRQ	-(SP)
	MOVL	SP,R2			; SAVE ADDRESS FOR LATER
	CLRL	-(SP)			; MAKE ROOM FOR THE $GETDVI RETURN DATA
	MOVL	SP,R3			; SAVE ADDRESS FOR LATER
	CLRQ	-(SP)			; MAKE ROOM FOR $GETDVI I/O STATUS BLOCK
	MOVL	SP,R4			; SAVE ADDRESS FOR LATER
	MOVL	#<DVI$_REFCNT@16>!4,(R2)	; SET ITEM CODE AND BUFFER SIZE (MIN=4)
	MOVL	R3,4(R2)		; SAVE RETURN BUFFER ADDRESS
	$GETDVI_S	EFN=#2,-	; GET REFERENCE COUNT OF MAILBOX
			CHAN=SJH$W_MBCHAN(R7),-
			ITMLST=(R2),-
			IOSB=(R4)
	$WAITFR_S	EFN=#2		; WAIT UNTIL $GETDVI COMPLETE
	MOVZWL	(R4),R0			; GET $GETDVI STATUS
	MOVL	(R3),R1			; GET REFERENCE COUNT
	ADDL2	#14,SP			; CLEAN THE STACK
	POPR	#^M<R2,R3,R4>		; RESTORE WORK REGS
	BLBC	R0,60$			; XFER IF IN ERROR
	CMPL	R1,#1			; SYNCING PROCESS GONE?
	BGTR	70$			; XFER IF NOT...GIVE AN ERROR
	$DASSGN_S	CHAN=SJH$W_MBCHAN(R7)	; ELSE DEASSIGN FINAL CHANNEL
55$:	MOVW	JCD_W_TMPCHAN(R11),-	; GET CHANNEL OF MAILBOX FOR RESPONCE
		SJH$W_MBCHAN(R7)	; AND SAVE IT IN THE BATCH JOB HEADER
	CLRW	JCD_W_TMPCHAN(R11)	; DISABLE IMMEADIATE RESPONCE
	SETSTAT	NORMAL			; ALL IS WELL
60$:	RET				;
 
70$:	SETSTAT	TRMMBXUSE		; MAILBOX ALREADY IN USE
	RET				;
 
100$:	TSTW	(R5)			; LOOKING FOR JOB BY ENTRY
	BEQL	110$			; BR IF NO
	CMPW	(R5),SJH$W_JOBSEQ(R7)	; COMAPIR JOB ID'S
	RSB				; RETURN WITH CONDITION CODES SET
110$:	PUSHR	#^M<R2,R3>		; SAVE REGISTERS USED BY INSTRUCTION
	CMPC	#12,SJH$T_USERNAM(R7),SMR$T_USERNAM(R9) ; SAME USER?
	BNEQ	120$			; BR IF NO - JOB CAN'T MATCH
	MOVZBL	SJH$T_JOBNAME(R7),R0	; GET LENGTH OF JOB NAME
	INCL	R0			; INCLUDE COUNT BYTE
	CMPC	R0,SJH$T_JOBNAME(R7),2(R5) ; CHECK FOR JOB NAME MATCH
120$:	POPR	#^M<R2,R3>		; RESTORE REGISTERS USED BY INSDTRUCTION
	RSB				;
 
	.END
