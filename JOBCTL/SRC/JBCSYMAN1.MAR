	.TITLE	JBCSYMAN1 - SYMBIONT MANAGER MAIN ROUTINE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARTLET JOB CONTROLLER
;
; ABSTRACT:	SYMBIONT MANAGER MAIN ROUTINE
;
; ENVIRONMENT:	USER MODE, NON-PRIVLEDGED CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE:14-JAN-77
;
; MODIFIED BY:
;
;	V02-011	MLJ0081		Martin L. Jack,	1-Mar-1982  20:00
;		Add an ASSUME that LP$V_LOWER = TT$V_LOWER.
;		Delete unreferenced global symbols.
;
;	V02-010	GWF0112		Gary W. Fowler		29-Oct-1981
;		Add support for WS extent
;
;	V02-009	GWF0070		Gary W. Fowler		01-Jul-1981
;		Avoid putting symbiont on service queue if state is not
;		suspend
;
;	V02-008	GWF0057		Gary W. Fowler		11-Jun-1981
;		Add processing of new requeue options
;
;	V02-007	GWF0048		Gary W. Fowler		18-May-1981
;		Change message code issued to symbiont when requeue command is
;		sent to MSG$_REQUE.
;
;	V02-006	GWF0027		Gary W. Fowler		17-Apr-1981
;		Set status as JBC$_JOBABORT if job is removed because queue
;		is deleted or initialized.
;
;	V02-005	GWF0005		Gary W. Fowler		31-Mar-1980
;		In SYM$START, ignore check of paused bit if batch queue because
;		SMQ$M_CREPND=SMQ$M_PAUSED.
;
;	V02-004	GWF0004		Gary W. Fowler		27-Feb-1980
;		Modified SYM$ABORT to remove batch job from queue if $DELPRC
;		fails.
;
;	V02-003	GWF0003		Gary W. Fowler		27-Nov-1979
;		Added support for multiple symbiont types
;
;	V02-002	GWF0002		Gary W. Fowler		2-OCT-1979
;		Modified SYM$INITIALIZE to clear flags and quota values when a
;		queue is initialized.  Modified SYM$INITIALIZE and SYM$START by
;		adding a call to a routine to adjust quota values.
;
;	V02-001	-
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
	JBCSCTDEF			; SYMBIONT CONTROL TABLE DEFINITIONS
	$MSGDEF				;
	$DEVDEF				; DEFINE DEVICE DEFINTIONS
	$LPDEF				; DEFINE LINEPRINTER BITS
	$TTDEF				; Define terminal bits
;
; OWN STORAGE:
;
	IMPURE_DATA
SYM_T_DEFNAM:
	.ASCIC	/PRTSMB/		; DEFAULT SYMBIONT IMAGE NAME

	.SBTTL	INITIALIZE DEVICE QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CREATES A QUEUE FOR THE DEVICE SPECIFIED
; IF THE QUEUE ALREADY EXISTS, IT IS INITIALIZED EMPTY AND STOPPED
;
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R0 IS SET FROM THE RESULT OF ATTEMPT TO FIND THE DEVICE QUEUE
;	R5 POINTS AT DEVICE NAME IF NOT FOUND,JUST PAST IT IF FOUND
;	R6 CONTAINS DEVICE QUEUE ADDRESS IN QUEUE FILE
;	R9 CONTAINS ADDRESS OF SYMBIONT MANAGER MESSAGE PACKET
;
;
; OUTPUT PARAMETERS:
;
;	THE QUEUE IS INITIALIZED, IF IT EXISTED, IT IS EMPTIED.
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE STATUS OF THE REQUEST
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION
 
	.ENABL	LSB

SYM$INITIALIZE::
	BLBC	R0,10$			; BR IF NO SUCH QUEUE
	PUSHL	R5			; SAVE POINTER TO OPTIONS DATA
	BSBB	100$			; DELETE THE QUEUE
	POPR	#^M<R5>			; RESTORE OPTION POINTER
	BRB	30$			; JOIN COMMON CODE
10$:	MOVAL	SQH$K_SIZE-SMQ$K_SIZE(R10),R6 ; SET ADDRESS FOR HEADER SEARCH
	SETSTAT	NOQUEHDR		; ASSUME NO QUEUE HEADERS AVAILIABLE
	CMPB	SQH$B_NUMQUE(R10),-	; CHECK THE NUMBER OF ACTIVE QUEUES
		SQH$B_MAXQUE(R10)	; AGAINST THE MAXIMUM ALLOWED
	BGEQU	90$			; BR IF NO MORE SPACE FOR QUEUES
20$:	ADDL	#SMQ$K_SIZE,R6		; ADVANCE TO NEXT
	BBS	#SMQ$V_INUSE,-		; BR IF THE QUEUE HEADER IS
		SMQ$B_FLAGS(R6),20$	; IN USE AND CHECK THE NEXT
	MOVC3	#16,(R5),SMQ$T_NAME(R6)	; SET NAME IN QUEUE
	MOVL	R1,R5			; SET MESSAGE DATA POINTER TO NEXT BYTE
30$:	ASSUME	SMQ$B_FLAGS+1 EQ SMQ$B_FORMS
	ASSUME	SMQ$B_FLAGS+1 EQ SMQ$B_JOBCNT
	ASSUME	SMQ$B_FLAGS+2 EQ SMQ$B_CHAR
	ASSUME	SMQ$B_FLAGS+3 EQ SMQ$B_JOBLIM
	CLRL	SMQ$B_FORMS(R6)		; ZERO FLAGS,FORMS,CHAR,AND COUNTS
	INCB	SMQ$B_JOBLIM(R6)	; SET DEFAULT JOB LIMIT
	CLRW	SMQ$W_QUOFLG(R6)	; SET NO QUOTAS PRESENT
	CLRW	SMQ$W_WSQUTA(R6)	; CLEAR WS QUOTA
	CLRW	SMQ$W_WSDFLT(R6)	; CLEAR WS DEFAULT
	CLRW	SMQ$W_WSEXTNT(R6)	; CLEAR WS EXTENT
	CLRL	SMQ$L_MCPULM(R6)	; CLEAR MAX CPU TIME LIMIT
	CLRL	SMQ$L_DCPULM(R6)	; CLEAR DEF CPU TIME LIMIT
	CLRB	SMQ$T_SMBNAME(R6)	; SET NO SYMBIONT PRESENT
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGS. CLOBBERED BY MOVC
	MOVC5	#0,(R6),#0,#16,SMQ$T_DQCHAR(R6)	; INIT CHARACTERISTICS
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGS.
	BSBW	SYM$CNVOPTINI		; PROCESS OPTIONS FOR INIT QUEUE
	BLBC	R0,90$			; BR IF BAD OPTION
	BISB	#<SMQ$M_INUSE!SMQ$M_STOPPED>,- ;INITIALIZE QUEUE IN USE
		SMQ$B_FLAGS(R6)		; AND STOPPED.
	INCB	SQH$B_NUMQUE(R10)	; KEEP COUNT OF NUMBER OF QUEUES IN USE
	BSBW	ADJ_QUOTAS		; ADJUST QUOTAS IF NECESSARY
	SETSTAT	NORMAL			; INIT OF QUEUE WAS SUCESSFUL
90$:	RET				; BACK TO THE TOP

	.SBTTL	DELETE DEVICE QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO REMOVE AN EXISTING DEVICE QUEUE
;	FROM THE SYMBIONT MANAGER QUEUE FILE, OF RESET THE QUEUE
;	HEADER PRIOR TO AN INIT OF AN EXISTING QUEUE.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE QUEUE TO DELETE
;
; IMPLICIT INPUTS:
;
;	R10 HAS ADDRESS OF SYMBIONT MANAGER QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	THE QUEUE IS DELETED AS LONG AS OPERATION WAS REQUESTED PROPERLY.
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE FINAL STATUS OF THE REQUEST
;
; SIDE EFFECTS:		NONE
;--


SYM$DELETEQUE::				; DELETE THE DEVICE QUEUE
	BSBB	100$			; EXECUTE COMMON CODE
99$:	RET				; RETURN TO SYMBIONT MANAGER

;
; COMMON SUBROUTINE FOR INIT OF EXISTING QUEUE AND DELETE
;

100$:	SETSTAT	QUENOSTOP		; ASSUME DELETE REQUEST ON RUNNING QUEUE
	TSTL	SMQ$L_CURRENT(R6)	; STILL PRINTING A JOB?
	BNEQ	99$			; BR IF YES-CAN'T DELETE TILL DONE
	BBC	#SMQ$V_STOPPED,SMQ$B_FLAGS(R6),99$ ; BR IF QUEUE IS STOPPED
110$:	MOVL	SMQ$L_HOLDLST(R6),R7	; GET NEXT JOB FROM HOLD LIST
	BEQL	120$			; BR IF NONE
	ADDL	R10,R7			; CHANGE OFFSET TO REAL ADDRESS
	MOVL	SJH$L_NEXTJOB(R7),SMQ$L_HOLDLST(R6) ; CLOSE UP HOLD LIST
	MOVL	#JBC$_JOBABORT,SJH$L_FINALSTS(R7) ; SET STATUS
	BSBW	SYM$FREEJOB		; RELEASE THE JOB RECORDS
	BRB	110$			; TRY AGAIN
;
; NOW SEARCH FOR A JOBS IN THIS QUEUE
;
;	NOTE: THE COROUTINE USES R2-R4 AND MUST NOT BE CHANGED
;
120$:	BSBW	SYM$FINDQUEJOB		; INIT THE COROUTINE
130$:	BLBC	R0,180$			; BR IF NO MORE JOBS IN THIS QUEUE
	JSB	@(SP)+			; ALWAYS REMOVE RECORDS
	MOVL	R2,R7			; COPY RECORD ADDRESS
	MOVL	#JBC$_JOBABORT,SJH$L_FINALSTS(R7) ; SET STATUS
	BSBW	SYM$FREEJOB		; RELEASE ALL RECORDS IN JOB
	JSB	@(SP)+			; RETURN FOR NEXT JOB
	BRB	130$			; SEE IF ANYTHING FOUND
180$:	CLRW	SMQ$B_FLAGS(R6)		; ZERO FLAGS AND FORMS TYPE BYTES
	DECB	SQH$B_NUMQUE(R10)	; REDUCE NUMBER OF ACTIVE QUEUES
	SETSTAT	NORMAL			; SET GOOD STATUS
	RSB				; RETURN TO CALLER

	.DSABL	LSB

	.SBTTL	START QUEUEING FOR DEVICE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS IS ROUTINE IS CALLED TO ENABLE DEQUEUEING FOR A SPECIFIC
;	DEVICE QUEUE,OR RESUME PRINTING IF THE OPERATION HAD BEEN SUSPENDED
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE PROPER DEVICE QUEUE ADDRESS
;	R9 CONTAINS THE SYMBIONT MANAGER MESSAGE
;	R10 HAS BASE ADDRESS OF PRINT QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	DEQUEUEING IS ENABLED, AND FILES THAT CAN BE PRINTED ARE
;	REMOVED FORM THE HOLD QUEUE AND INSERTED INTO THE PRINT QUEUE.
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE FINAL STATUS OF THE REQUEST.
;
; SIDE EFFECTS:		NONE
;--
	.ENABL	LSB

SYM$START::
	SETSTAT	SMINVOPR		; ASSUME ERROR
	BBS	#SMQ$V_DETJOB,-
		SMQ$B_FLAGS(R6),10$	; IGNORE PAUSED BIT IF BATCH QUEUE
	BBC	#SMQ$V_PAUSED,-		; IF DEVICE SHOULDE NOT BE PAUSED
		SMQ$B_FLAGS(R6),10$	; AND PROCESS START REQUEST
	BRW	110$			; DEVICE IS PAUSED-RESUME
10$:	BBC	#SMQ$V_STOPPED,-	; IF DEVICE IS NOT STOPPED
		SMQ$B_FLAGS(R6),20$	; THEN THIS REQUEST IS AN ERROR
	BSBW	SYM$CNVOPTINI		; PROCESS OPTIONS AS START/INIT
	BLBC	R0,20$			; BR IF THERE WAS AN ERROR
	BSBW	ADJ_QUOTAS		; ADJUST QUOTAS IF NECESSARY
	BITB	#<SMQ$M_DETJOB!SMQ$M_GENDEV>,- ; CK IF QUEUE IS DEFINED TO BE
		SMQ$B_FLAGS(R6)		; EITHER GENERIC OR BATCH
	BNEQ	60$			; BR IF YES-DON'T CHARACTERISTICS
	BBS	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),60$ ; BR IF QUEUE REDIRECTED
	MOVAB	SMQ$T_NAME(R6),R0	; SET ADDRESS OF DEVICE NAME
	BSBW	SYM$GETDEVCHAR		; GET THE DEVICE CHARACTERISTICS
20$:	BLBS	R0,21$			; BR IF ERROR GETTING DEVICE INFO
	BRW	100$			; BR IF ERROR GETTING DEVICE INFO
21$:	SETSTAT	ILLDEVTYP		; ASSUME DEVICE IS ILLEGAL
	BBS	#DEV$V_CCL,(R2),22$	; BR IF NOT CARRAIGE CONTROL DEVICE
	BRW	100$			; BR IF NOT CARRIAGE CONTROL DEV
22$:	BICB	#SMQ$M_TRMDEV,SMQ$B_CHAR(R6) ; ASSUME DEVICE IS NOT A TERMINAL
	BBC	#DEV$V_TRM,(R2),30$	; BR IF DEVICE IS NOT A TERMINAL
	BISB	#SMQ$M_TRMDEV,SMQ$B_CHAR(R6) ; SET FLAG IN QUEUE HEADER
30$:	BBC	#DEV$V_GEN,(R2),40$	; BR IF DEVICE IS NOT GENERIC DEVICE
	BISB	#SMQ$M_GENDEV,SMQ$B_FLAGS(R6) ; SET FLAG IF DEVICE IS GENERIC
40$:	BBC	#LP$V_LOWER,8(R2),50$	; BR IF NOT A LOWER CASE PRINTER
	ASSUME	TT$V_LOWER EQ LP$V_LOWER ; Same test works for terminals
	SETBIT	SMQ$V_LOWER,SMQ$B_CHAR(R6) ; SET BIT TO FLAG LOWER CASE PRINTER
50$:	MOVL	#1,R0			; SET REQUEST TYPE TO ALLOCATE
	BSBW	SYM$ALLODEAL		; ALLOCATE/DEALLOCATE DEVICE ROUTINE
	BLBC	R0,100$			; BR IF ALLOCATE FAILED
60$:	BICB	#SMQ$M_STOPPED,-	; RESET THE STOPPED FLAG
		SMQ$B_FLAGS(R6)		; IN FLAGS BYTE
	MOVAL	SMQ$L_HOLDLST(R6),R4	; SET UP TO SCAN HOLD LIST
70$:	MOVL	(R4),R7			; GET OFFSET TO NEXT JOB
	BEQL	90$			; BR WHEN NO MORE FILES TO CHECK
	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB HEADER
	BBS	#SJH$V_HOLD,-		; IF HOLD FLAG IS SET FOR THIS JOB
		SJH$B_FLAGS(R7),80$	; THEN THIS JOB STAYS IN THE HOLD LIST
	IF_FORM_DIF	80$		; BR IF FORMS DON'T MATCH
	MOVL	SJH$L_NEXTJOB(R7),(R4)	; REMOVE THIS JOB FORM HOLD LIST
	SYM_QUECHANGE			; INDICATE QUEUE CHANGED
	BSBW	SYM$JOBINSQUE		; INSERT THIS IN PRINT QUEUE
	BRB	70$			; TRY NEXT
80$:	MOVAL	SJH$L_NEXTJOB(R7),R4	; SET R4 TO POINT AT LINK
	BRB	70$			; TRY FOR NEXT
90$:	BBS	#SMQ$V_GENDEV,SMQ$B_FLAGS(R6),130$ ; BR IF GENERIC DEVICE QUEUE
	MOVZBL	#JBC_V_CREJOBREQ,R0	; GET FLAG BIT THAT CREATE OF JOB NEEDED
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),140$  ; BR IF JOB QUEUE
	BBS	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),95$ ; BR IF QUEUE IS REDIRECTED
	BSBW	CHECK_SYMB		; CHECK IF SYMBIONT NAME SUPPLIED
	BSBW	SYM$CREPRTSYM		; CREATE A SYMBIONT IF NEEDED
95$:	SETSTAT	NORMAL			; SET TRUE STATUS
100$:	RET				; RETURN TO SYMBIONT MANAGER

;
; PROCESS RESTART OF PAUSED DEVICE
;

110$:	BSBW	SYM$CNVOPTRES		; PROCESS OPTIONS FOR RESTART
	BLBC	R0,100$			; BR IF ERROR PROCCESSING OPTIONS
	BICB	#<1@SMQ$V_PAUSED>,-	; REMOVED PAUSED FLAG
		SMQ$B_FLAGS(R6)		; FROM QUEUE FLAGS BYTE
	TSTL	SMQ$L_CURRENT(R6)	; IS THERE A JOB DEQUEUED?
	BEQL	130$			; BR IF NO-TRY TO DEQUEUE ONE
	MOVL	R1,R0			; SET RESUME MESSAGE FROM OPTIONS IN R0
	MOVL	SMQ$L_ASNSCT(R6),R5	; GET ASSIGNED SYMBIONT CONTROL TABLE
	CMPB	SCT_B_STATE(R5),#SCT_K_SUSPND ; IS THE SYMBIONT SUSPENDED?
	BNEQ	150$			; BR IF NO-RETURN
	MOVB	#SCT_K_DEQFIL,SCT_B_STATE(R5) ; SET STATE FOR NEXT DEQUEUE
	BRW	220$			; SEND RESUME MESSAGE
130$:	MOVZBL	#JBC_V_SYMINIREQ,R0	; GET FLAG TO SET
140$:	SETBIT	R0,JCD_W_FLAGS(R11)	; SET PROPER FLAG
150$:	SETSTAT	NORMAL			;
	RET				; RETURN TO DISPATCHER
	.PAGE
	.SBTTL	ABORT CURRENT JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL SEND A MESSAGE TO A SYMBIONT INSTRUCTING
;	THE SYMBIONT TO TERMINATE IS PRINTING ITS CURRENT FILE
;
; CALLING SEQUENCE:
;
;	ENTERED FROM SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE ASSOCIATED DEVICE QUEUE HEADER
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	SYMBIONT IS INSTRUCTED TO STOP PRINTING
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE FINAL STATUS OF THE REQUEST.
;
; SIDE EFFECTS:		NONE
;--

SYM$ABORT::				; ABORT THE CURRENT JOB
	MOVL	SMQ$L_CURRENT(R6),R7	; GET OFFSET TO CURRENT JOB
160$:	BNEQ	161$			; BR IF HAVE CURRENT JOB
	BRW	200$			; BR IF NO CURRENT JOB
161$:	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB HEADER
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),190$ ; BR IF PRINT QUEUE
	CMPW	(R5),SJH$W_JOBSEQ(R7)	; SEQUENCE NUMBER MATCH?
	BEQL	170$			; BR IF YES-FOUND THE JOB
	MOVL	SJH$L_NEXTJOB(R7),R7	; GET INDEX OF NEXT JOB
	BRB	160$			; CHECK THIS ONE OUT
170$:	BSBW	SYM$CKREQPRV		; CHECK IF THIS GUY CAN ABORT THIS JOB
	$DELPRC_S PIDADR=SJH$L_PROCID(R7) ; DELETE THE JOB
	BLBC	R0,180$			; BR IF SERVICE WAS UNSUCCESSFUL
	SETBIT	SJH$V_JOBABORT,SJH$B_FLAGS(R7) ; REMEMBER ABORT WAS DONE
	BRB	185$			; BR TO RETURN
;
; Delete process has failed - try to remove job from queue
;
180$:	MOVL	SJH$L_PROCID(R7),R1	; GET PID OF JOB
	BSBW	SYM$FINDETJOB		; SEARCH FOR JOB
	BLBC	R0,185$			; IF LOW CLEAR - SEARCH FAILED
	MOVL	SJH$L_NEXTJOB(R7),(R5)	; REMOVE LINK TO JOB
	MOVL	#JBC$_JOBABORT,R0	; SET STATUS OF JOB
	MOVL	R0,SJH$L_FINALSTS(R7)	; SET STATUS IN HEADER RECORD
	BSBW	SYM$FREEJOB		; CLEAN UP - RELEASE RECORDS
	DECB	SMQ$B_JOBCNT(R6)	; DECR. COUNT OF CURRENT JOBS
	SETBIT	JBC_V_CREJOBREQ,JCD_W_FLAGS(R11)
	CLRBIT	SMQ$V_CREPND,SMQ$B_FLAGS(R6)
					; CLEAR CREATE PENDING BIT
					; SET TO TRY TO START ANOTHER JOB
	SYM_QUECHANGE			; INDICATE QUEUE HAS CHANGED
	$CMKRNL_S	B^189$		; COUNT DOWN NO. OF BATCH JOBS
	SETSTAT	NORMAL			; INDICATE SUCCESS
185$:	RET
 
189$:	.WORD	0
	DECW	@#SYS$GW_BJOBCNT	; DECREMENT COUNT
	RET

190$:	BSBW	SYM$CKREQPRV		; VERIFY THAT THE REQUESTOR CAN DO THIS
	MOVW	SJH$W_QINDEX(R7),-	; ASSUME JOB WILL BE
		SJH$W_REQINDX(R7)	; REQUEUED TO SAME QUEUE
	MOVB	#1,SJH$B_REQPRIO(R7)	; ASSUME JOB WILL BE QUEUED AT PRIO 1
	BSBW	SYM$CNVOPTABO		; CHECK FOR ABORT OPTIONS
	BLBC	R0,205$			; BR IF INVALID OPTION
	MOVZBL	SJH$B_REQOPT(R7),R1	; GET OPTION_CODE
	BLBC	R1,195$			; IF LBC - THEN NO REQUEUE SPECIFED
	BSBB	SYM$SNDASNSYM		; SEND MESSAGE TO SYMBIONT
	.BYTE	SCT_K_REQUE		; NEXT STATE FOR SYMBIONT
	.BYTE	MSG$_REQUE		; MESSAGE FOR SYMBIONT
195$:	MOVL	#JBC$_JOBABORT,-	; SET STATUS AS
		SJH$L_FINALSTS(R7)	; JOB ABORTED
	BSBB	SYM$SNDASNSYM		; SENT TO ASSIGNED SYMBIONT
	.BYTE	SCT_K_ABOREQ		; NEXT STATE
	.BYTE	MSG$_ABOOPR		; MESSAGE CODE
200$:	SETSTAT	NOSUCHJOB		; BR IF NO JOB PRINTING ON DEVICE
205$:	RET				;
	.PAGE
	.SBTTL	PAUSE OPERATION ON QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN IS IS NECESSARY TO SUSPEND
;	THE OPERATION OF A SPECIFIC QUEUE FOR A WHILE
;
; CALLING SEQUENCE:
;
;	ENTERED FROM THE SYMBIONT MANAGER DISPATCHER VIA CASE FOLLOWING A CALL
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT NEXT BYTE TO PROCESS IN THE MESSAGE
;	R6 CONTAINS THE ADDRESS OF THE ASSOCIATED QUEUE HEADER
;	R9 CONTAINS THE ADDRESS OF THE SYMBIONT MANAGER MESSAGE
;
; IMPLICIT INPUTS:
;
;	R10 HAS THE BASE ADDRESS OF THE PRINT QUEUE FILE
;	R11 HAS THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:
;
;	R0 IS RETURN WITH THE FINAL STATUS OF THE REQUEST.
;
; SIDE EFFECTS:		NONE
;--

SYM$PAUSE::				; SUSPEND OPERATION ON A QUEUE
	BITB	#SMQ$M_GENDEV!SMQ$M_DETJOB,SMQ$B_FLAGS(R6) ; CK IF QUEUE CAN BE PAUSED
	BNEQ	210$			; BR IF NO - TRY A STOP
	BBS	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),210$ ; ALSO STOP REDIRECTED QUEUES
	BBSS	#SMQ$V_PAUSED,	-	; SET PAUSED FLAG - AND BR IF ALREADY-
		SMQ$B_FLAGS(R6),230$	; PAUSED
	BSBB	SYM$SNDASNSYM		; SEND MESSAGE TO ASSIGNED SYMBIONT
	.BYTE	SCT_K_SUSPND		; NEXT STATE IS SUSPENDED
	.BYTE	MSG$_SUSOPR		; MESSAGE CODE
210$:	BRW	SYM$STOP		; 
	.PAGE
	.SBTTL	SEND TO ASSIGNED SYMBIONT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SEND A MESSAGE TO THE SYMBIONT CURRENTLY
;	ASSIGNED TO THE DEVICE WHOSE QUEUE HEADER IS IN R6, AND TO
;	SET THE STATE OF THE SYMBIONT IN ACCORDANCE WITH THE MESSAGE.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$SNDASNSYM		;
;
; INPUT PARAMETERS:
;
;	NEW STATE FOLLOWED BY MESSAGE CODE IN LINE AFTER CALL
;	R6 CONTAINS THE PROPER DEVICE QUEUE ADDRESS
;	R10 HAS BASE ADDRESS OF PRINT QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	MESSAGE IS SENT, THE STATE IS SET, AND A RETURN IS TAKEN
;	TO SYMBIONT MANAGER DISPATCHER.
;
; COMPLETION CODES:
;
;	R0 IS SET WITH RESULTANT STATUS
;
; SIDE EFFECTS:		NONE
;--

SYM$SNDASNSYM:				; SEND TO ASSIGNED SYMBIONT
	TSTL	SMQ$L_CURRENT(R6)	; ANYTHING GOING?
	BEQL	230$			; BR IF NO
	MOVL	SMQ$L_ASNSCT(R6),R5	; SET ADR OF ASSIGNED SYMBIONT CONTROL
	POPR	#^M<R0>			; GET ADDRESS OF MESSAGE
	MOVB	(R0)+,SCT_B_STATE(R5)	; SET STATE OF SYMBIONT
	MOVZBL	(R0),R0			; GET MESSAGE CODE
220$:	BSBW	SYM$SND2SMB		; SEND THAT TO THE SYMBIONT
230$:	SETSTAT	NORMAL			; STATUS OF OPERATION
240$:	RET				; BACK TO THE DISPATCHER
	.DSABL	LSB

	.SBTTL	ADJ_QUOTAS - ADJUST QUOTAS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ADJUST THE WORKING SET QUOTAS AND CPU
;	TIME LIMITS.  THE WORKING SET VALUES ARE ADJUSTED TO BE CONSISTENT
;	WITH ONE ANOTHER.
;
;	IF BOTH A DEFAULT CPU TIME LIMIT AND A MAXIMUM CPU TIME LIMIT ARE
;	PRESENT IN THE QUEUE HEADER AND THE DEFAULT VALUE IS GREATER
;	THAN THE MAXIMUM VALUE, THEN THE DEFAULT IS SET EQUAL TO THE
;	MAXIMUM.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	ADJ_QUOTAS
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE STARTING ADDRESS OF THE QUEUE HEADER
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS
;
;	NONE
;--
	.ENABL	LSB

ADJ_QUOTAS:				; ADJUST QUOTAS
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),45$	; BR IF NOT A BATCH QUEUE
	TSTW	SMQ$W_QUOFLG(R6)	; ANY QUOTAS PRESENT
	BEQL	45$			; BR IF NONE
	BBC	#SMQ$V_MCPULM,SMQ$W_QUOFLG(R6),15$	; BR IF NO MAX CPU LIMIT
	BBC	#SMQ$V_DCPULM,SMQ$W_QUOFLG(R6),15$	; BR IF NO DEF. CPU LIMIT

	MOVL	SMQ$L_MCPULM(R6),R0	; GET MAX CPU LIMIT
	MOVL	SMQ$L_DCPULM(R6),R1	; GET DEF CPU LIMIT
	DECL	R0			; SET TO MAX UNSIGNED IF INFINITE
	DECL	R1			; SET TO MAX UNSIGNED IF INFINITE
	CMPL	R0,R1			; COMPARE
	BGTRU	15$			; BR IF MAX .GT. DEF.
	MOVL	SMQ$L_MCPULM(R6),SMQ$L_DCPULM(R6)	; LOWER DEF TO MAX

15$:	TSTW	SMQ$W_WSEXTNT(R6)	; WS EXTENT SPECIFIED?
	BEQL	25$			; IF EQ THEN NO
	TSTW	SMQ$W_WSQUTA(R6)	; WS QUOTA SPECIFIED?
	BEQL	25$			; IF EQ THEN NO
	CMPW	SMQ$W_WSEXTNT(R6),SMQ$W_WSQUTA(R6) ; BOTH PRESENT-COMPARE
	BGTRU	25$			; IF EXTENT GT QUOTA THEN OK
	MOVW	SMQ$W_WSEXTNT(R6),SMQ$W_WSQUTA(R6) ; MINIMIZE QUOTA WITH EXTENT
25$:	TSTW	SMQ$W_WSQUTA(R6)	; QUOTA PRESENT?
	BEQL	35$			; IF EQ THEN NO
	TSTW	SMQ$W_WSDFLT(R6)	; WS DEFAULT PRESENT
	BEQL	35$			; IF EQ THEN NO
	CMPW	SMQ$W_WSQUTA(R6),SMQ$W_WSDFLT(R6) ; BOTH PRESENT-COMPARE
	BGTRU	35$			; IF QUOTA GT DEFAULT THEN OK
	MOVW	SMQ$W_WSQUTA(R6),SMQ$W_WSDFLT(R6) ; MINIMIZE DEFAULT WITH QUOTA
35$:	TSTW	SMQ$W_WSEXTNT(R6)	; EXTENT PRESENT?
	BEQL	45$			; IF EQ THEN NO
	TSTW	SMQ$W_WSDFLT(R6)	; DEFAULT PRESENT?
	BEQL	45$			; IF EQ THEN NO
	CMPW	SMQ$W_WSEXTNT(R6),SMQ$W_WSDFLT(R6) ; BOTH PRESENT-COMPARE
	BGTRU	45$			; IF EXTENT GT DEFAULT THEN OK
	MOVW	SMQ$W_WSEXTNT(R6),SMQ$W_WSDFLT(R6) ; MINIMIZE DEFAULT WITH EXTENT

45$:	RSB				; RETURN
	.DSABL	LSB

	.PAGE
	.SBTTL	CHECK SYMBIONT NAME
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS USED TO CHECK IF AN IMAGE NAME FOR A SYMBIONT
;	HAS BEEN SUPPLIED BY THE USER.  IF NOT, THE DEFAULT IMAGE NAME
;	PRTSMB.EXE IS SUPPLIED.  THE IMAGE IS MOVED TO THE SYMBIONT NAME
;	TABLE IF AN EMPTY ENTRY EXISTS.  IF NOT, AN ERROR TYPE IS SET
;	AND A RET IS ISSUED TO RETURN TO TOP LEVEL.  FINALLY A POINTER
;	TO THE SYMBIONT NAME TABLE IS PLACED IN THE QUEUE HEADER
;
; CALLING SEQUENCE:
;
;	CALLED FROM SYM$START USING A BSB
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE QUEUE HEADER
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; COMPLETION CODES:
;
;	SYMNTBFUL IF AN EMPTY ENTRY IN SYMBIONT NAME TABLE IS NEEDED
;	AND NONE IS TO BE FOUND.
;
; SIDE EFFECTS:
;
;	NONE
;__
CHECK_SYMB:
	TSTB	SMQ$T_SMBNAME(R6)	; ANY SYMBIONT NAME SUPPLIED?
	BNEQ	90$			; BR IF ONE SUPPLIED
	MOVZBL	SYM_T_DEFNAM,R0		; GET LENGTH OF DEFAULT NAME
	INCL	R0			; INCREMENT TO INCLUDE LENGTH
	MOVC5	R0,SYM_T_DEFNAM,#^A/ /,-	; GIVE IT A DEFAULT NAME
		#SYM_K_NAMSIZ,SMQ$T_SMBNAME(R6)
90$:	CALLS	#0,SEARC_NAME		; SEARCH FOR NAME OF SYMBIONT
	BLBC	R0,91$			; BR IF NOT FOUND
	MOVL	R1,-(SP)		; SAVE TABLE ADDR
	BRB	93$			; GO PUT POINTER IN QUEUE HEADER
91$:	BSBW	FIND_EMPTY		; SEARCH FOR EMPTY ENTRY
	BLBS	R0,92$			; BR IF FOUND
	SETSTAT	SYMNTBFUL		; SET ERROR TYPE
	RET				; RETURN TO TOP LEVEL
92$:	MOVL	R1,-(SP)		; SAVE TABLE ADDR
	MOVC3	#SYM_K_NAMSIZ,SMQ$T_SMBNAME(R6),(R1)
93$:	MOVL	(SP)+,R1		; RESTORE TABLE ADDR
	MOVL	R1,SMQ$L_PNMTAB(R6)	; SAVE IN QUE HEADER
	INCB	CURPDEV(R1)		; COUNT DEVICES USING SYMBIONT
	RSB				; RETURN
	.END				;
