
	.TITLE	JBCQUESRC - SEARCH QUEUE SUBROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARLET JOB CONTROLLER/SYMBIONT MANAGER
;
; ABSTRACT:	ROUTINES TO SEARCH THE SYMBIONT MANAGER QUEUES
;
; ENVIRONMENT:	NON-PRIVLEDGED USER MODE CODE
;
; AUTHOR: W. H. BROWN, CREATION DATE: 13-JAN-77
;
; MODIFIED BY:
;
;	, : VERSION
; 01	- 
;--
	.SBTTL	DECLARATIONS
 
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
;
; OWN STORAGE:		NONE
;


	.SBTTL	FIND DEVICE QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	ROUTINE TO LOCATE A SPECIFIC DEVICE QUEUE
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$FINDEVQUE
;
; INPUT PARAMETERS:
;
;	R5  POINTS AT NAME OF DESIRED QUEUE AS A COUNTED STRING
;	R10 CONTAINS THE BASE ADDRESS OF THE QUEUE HEADER
;
; OUTPUT PARAMETERS:
;
;	R6  CONTAINS THE ADDRESS OF THE QUEUE HEADER IF FOUND
;
; IMPLICIT OUTPUTS:
;
;	R5 IS ADVANCE OVER DEVICE NAME IF QUEUE IS FOUND
;	TOP LEVEL RETURN IS MADE IF DEVICE NAME HAS ILLEGAL FORMAT
;
; COMPLETION CODES:
;
;	R0 = NORMAL IF SEARCH WAS SUCESSFUL
;	   = ILLQUENAMIF DEVICE STRING INVALID(TOP LEVLEL RETURN ISSUED)
;	   = NOSUCHQUE IF QUEUE NOT HERE
;
; SIDE EFFECTS:
;
;	REQISTER R0 THRU R4 ARE USED
;
;--
	PURE_SECTION


SYM$FINDQUEUE::
	MOVZBL	(R5),R0			; GET LENGTH OF USER SUPPLIED NAME
	CMPB	(R0)[R5],#^A/:/		; NAME END WITH A COLON?
	BNEQ	10$			; BR IF NO
	DECB	(R5)			; REMOVE COLON FROM THE NAME
10$:	SETSTAT	ILLQUENAM		; ASSUME BAD NAME
	CMPB	(R5),#SYM_K_QUENAM	; CHECK IF NAME TOO BIG
	BGTRU	60$			; BR IF YES
	MOVAL	<SQH$K_SIZE-SMQ$K_SIZE>(R10),R6	; SET R6 FOR DEVICE QUEUE SEARCH
	MOVZBL	SQH$B_NUMQUE(R10),R4	; GET COUNT OF DEVICE QUEUES 
	BEQL	40$			; BR IF NONE
20$:	ADDL	#SMQ$K_SIZE,R6		; ADVANCE POINTER TO NEXT QUEUE
	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),20$ ; IGNORE SLOTS NOT IN USE
	MOVZBL	(R5),R0			; GET LENGTH OF NAME STRING
	INCL	R0			; ADJ TO COMPAIR NAME AND LENGTH
	CMPC3	R0,(R5),SMQ$T_NAME(R6)	; DO THE NAMES MATCH?
	BNEQ	30$			; BR IF NO
	ADDL	#SYM_K_QUENAM+1,R5	; ADVANCE POINTER OVER QUEUE_NAME
	SETSTAT	NORMAL			; SET GOOD STATUS
	RSB				; RETURN TO CALLER
 
30$:	SOBGTR	R4,20$			; LOOK IN ALL ACTIVE QUEUES
40$:	SETSTAT	NOSUCHQUE		; SET QUEUE NOT HERE
50$:	RSB				; EXIT SEARCH
60$:	RET				; RETURN TO TOP LEVEL

	.SBTTL	FIND OPEN JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL FIND AN OPEN JOB BY PROCESS I.D.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$FINDOPENJOB		; FIND OPEN JOB FOR REQUESTING PROCESS
;	BSB/JSB	SYM$FINDPROCJOB		; FIND OPEN JOB FOR SPECIFIC PROCESS
;
; INPUT PARAMETERS:
;
; ENTER AT "SYM$FINDOPENJOB" WITH R9 CONTAINING ADDRESS OF CURRENT MESSAGE
;	AT "SYM$FINDPROCJOB" WITH R1 CONTAINING PROCESS ID OF JOB TO FIND
;	R10 CONTAINS ADDRESS OF THE SYMBIONT QUEUE SPACE
;
; OUTPUT PARAMETERS:
;
;	R2 CONTAINS THE ADDRESS OF THE LINK TO THIS JOB
;	R7 CONTAINS THE ADDRESS OF THE JOB IF FOUND
;
; COMPLETION CODES:
;
;	IF NO SUCH JOB, R0 IS SET TO NOSUCHJOB
;		ELSE NORMAL IS RETURNED
;
; SIDE EFFECTS:		R2 IS USED AS SCRATCH WORK
;--

SYM$FINDOPENJOB::			; FIND JOB FOR REQUESTING PROCESS
	MOVL	SMR$L_PROCID(R9),R1	; GET CURRENT REQUEST PROCESS I.D.
SYM$FINDPROCJOB::			; FIND A JOB FOR INDICATED PROCESS
	MOVAL	SQH$L_OPENJOB(R10),R2	; SET POINTER TO LIST HEAD
	SETSTAT	NOSUCHJOB		; ASSUME SEARCH WILL FAIL
10$:	MOVL	(R2),R7			; GET INDEX OF NEXT JOB
	BEQL	30$			; BR IF END OF LIST
	ADDL	R10,R7			; FIND ADDRESS OF THE JOB
	CMPL	R1,SJH$L_PROCID(R7)	; IS THIS THE CORRECT JOB
	BEQL	20$			; BR IF FOUND THE JOB
	CMPW	R1,SJH$L_PROCID(R7)	; NEW COPY OF THE PROCESS?
	BNEQ	15$			; BR IF NO
	MOVL	SJH$L_NEXTJOB(R7),(R2)	; CLOSE THE LIST
	SYM_QUECHANGE			; TELL THE WORLD IT CHANGED
	BSBW	SYM$FREEJOB		; RELEASE THE JOB AS FREE
	BRB	10$			; TRY AGAIN
15$:	MOVAL	SJH$L_NEXTJOB(R7),R2	; COMPUTE ADDRESS OF LINK TO NEXT JOB
	BRB	10$			; TRY AGAIN
20$:	SETSTAT	NORMAL			; SET SUCESSFUL STATUS
	MOVZWL	SJH$W_QINDEX(R7),R6	; FIND INDEX TO ASSOCIATED QUEUE
	ADDL	R10,R6			; FIND REAL ADDRESS
30$:	RSB				; RETURN WITH JOB

	.SBTTL	FIND QUEUE JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SEARCHES ALL OF THE SYMBIONT MANAGER QUEUES
;	LOOKING FOR JOBS BELONGING TO A SPECIFIC QUEUE.
;	WHEN A FILE IS FOUND A COROUTINE RETURN IS TAKEN WITH
;	R0 = TRUE.  WHEN THE LAST QUEUE HAS BEEN SEARCHED,
;	WITHOUT FINDING ANY ENTRY BELONGING TO THE SPECIFIED QUEUE
;	A RETURN FORM SUBROUTINE IS ISSUED WITH R0 = FALSE.
;
;	WHEN CONTROL IS RETURNED FROM THE COROUTINE, R0 IS SET
;	TRUE TO INDICATE THE RECORD SHOULD BE REMOVED, FALSE TO
;	INDICATE THAT THE SEARCH SHOULD BE CONTIUNED.
;
;	WHEN THE RECORD HAS BEEN REMOVED, ANOTHER COROUTINE RETURN
;	IS MADE SO THAT THE RECORD CAN BE INSERTED IN THE PROPER
;	LIST.  THIS CAN NOT BE DONE UNTIL IT HAS BEEN REMOVED
;	SO THAT THE LINK WORD WILL NOT CHANGE PRIOR TO CLOSING
;	THE LIST.
;
; CALLING SEQUENCE:
;
;	ENTER WITH JSB/BSB AT:
;
;		SYM$FINDQUEJOB---TO SEARCH AT QUEUES FOR JOBS
;		SYM$FINDACTJOB---TO SEARCH ONLY ACTIVE QUEUES
;		SYM$FINDCLSJOB---TO SEARCH ALL QUEUES EXCEPT OPEN JOB
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE QUEUE HEADER TO FINDS JOB FOR
;	R10 CONTAINS THE ADDRESS OF THE SYMBIONT QUEUE SPACE
;
; OUTPUT PARAMETERS:
;
;	ON SUCESSFUL RETURN, R2 CONTAINS THE ADDRESS OF THE JOB FOUND
;		R3 CONTAINS THE ADDRESS OF THE LINK WORD POINTING
;		TO THIS JOB.
;
; IMPLICIT OUTPUTS:
;
;	REGISTER R4 IS BEING USED BY THIS ROUTINE AND MUST BE PRESERVED
;
; COMPLETION CODES:
;
;	R0 = TRUE OR FALSE DEPENDING ON WHETHER A JOB IS FOUND OR NOT.
;
; SIDE EFFECTS:		NONE
;--

	.ENABL	LSB
SYM$FINDACTJOB::			; SEARCH ONLY ACTIVE QUEUES
	CLRL	R4			; SET SEARCH INDEX
	BRB	10$			; START SEARCH
SYM$FINDCLSJOB::			; SEARCH ALL CLOSED JOBS
	MNEGL	#1,R4			; SET QUEUE SEARCH INDICATOR
	BRB	10$			; DO THE SEARCH
SYM$FINDQUEJOB::
	MNEGL	#2,R4			; SET INDICATOR FOR WHICH QUEUE TO SEARCH
10$:	MOVAL	SQH$L_TIMQUE(R10),R3	; SEARCH TIME QUEUE
	INCL	R4			; COUNT UP QUEUES SEARCHED
	BGTR	30$			; BR IF WORKING ON PRINT QUEUES
	BEQL	50$			; BR IF TIMER QUEUE IS NEXT
	MOVAL	SQH$L_OPENJOB(R10),R3	; TIME TO SEARCH OPEN JOB QUEUE
	BRB	50$			; GO DO SEARCH
30$:	SETSTAT	NOSUCHJOB		; ASSUME ALL QUEUES HAVE BEEN SEARCHED
	CMPL	R4,#SYM_K_PRTPRI	; HAVE ALL QUEUES BEEN SEARCHED?
	BGTR	90$			; BR IF YES
	SUBL3	R4,#32,R3		; CONVERT TO DECEASING PRIORITY INDEX
	MOVAQ	SQH$Q_QUEUE(R10)[R3],R3 ; GET ADDRESS OF QUEUE THREAD WORD
50$:	SUBL3	R10,R6,R0		; FIND THE QUEUE INDEX
	MOVL	(R3),R2			; FOLLOW THE LINK
	BEQL	10$			; BR IN NONE LINKED HERE
	ADDL	R10,R2			; FIND REAL ADDRESS OF JOB
	CMPW	SJH$W_QINDEX(R2),R0	; IS THIS JOB IN THE TARGET QUEUE?
	BNEQ	80$			; BR IF NO-CONTINUE THE SEARCH
	MOVL	#1,R0			; SET FOUND 1 STATUS
	JSB	@(SP)+			; LET THE CALLER LOOK AT IT
	BLBC	R0,80$			; BR IF IT GETS LEFT IN THE LIST
	SYM_QUECHANGE			; INDICATE CHANGE IN QUEUE
	MOVL	SJH$L_NEXTJOB(R2),(R3)	; CLOSE THE JOB LIST
	BNEQ	70$			; BR IF NOT LAST JOB IN THE LIST
	TSTL	R4			; IS THIS A ACTIVE PRINT QUEUE?
	BLEQ	70$			; BR IF NO-SINGLE ENDED QUEUES ARE EASY!
;
; THE JOB BEING REMOVED IS IN THE PRINT QUEUES - HANDLE SPECIAL CASE
; OF REMOVING LAST JOB - WHICH IS A ROYAL PAIN IN THE !!!
;
	SUBL3	R4,#32,R1		; FIND DECEASING INDEX FOR QUEUE
	MOVAQ	SQH$Q_QUEUE(R10)[R1],R1 ; GET ADDRESS OF END OF LIST POINTER
	TSTL	(R1)+			; IF FORWARD POINTER ZERO-QUEUE IS EMPTY
	BEQL	70$			; BR IS IT IS - THAT IS OK
;
; THE JOB BEING REMOVED IS THE LAST IN THE ASSOCIATED LIST, WITH NO MORE
; ENTRIES IN THE QUEUE. THE LINK MUST BE SET TO JOB PRECEEDING THIS JOB.
; THE CONTENTS OF R3 IS THE ADDRESS OF THE LINK TO THIS JOB.
; IE:  JOB HEADER PLUS SJH$L_NEXTJOB.
;
	MOVAL	-SJH$L_NEXTJOB(R3),(R1)	; SUBTACT OFFSET TO JOB LIST LINK
	SUBL	R10,(R1)		; REMOVE QUEUE BASE FROM VALUE
70$:	JSB	@(SP)+			; LET THE CALLER DISPOSE OF THE RECORD
	BRB	50$			; LOOK AGAIN
80$:	MOVAL	SJH$L_NEXTJOB(R2),R3	; POINT R3 AT LINK WORD
	BRB	50$			; GO AGAIN
90$:	RSB				; BACK TO CALLER WITH FALSE

	.DSABL	LSB
	.END				;
