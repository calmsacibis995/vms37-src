	.TITLE	JBCINIT-JOB_CONTROLLER INIT ROUTINE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARLET JOB_CONTROLLER
;
; ABSTRACT:	THIS MODULE CONTAINS THE JOB_CONTROLLER INITIALIZATION
;
; ENVIRONMENT:	THIS MODULE MAKES UP PART OF THE JOB_CONTROLLER
;		SYSTEM PROCESS.
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 3-JAN-77
;
; MODIFIED BY:
;
;	V03-001	MLJ0086		Martin L. Jack,	3-Apr-1982  22:03
;		Move queue file initialization to new module JBCINIQUE.  Delete
;		unnecessary clearing of memory.  Change queue rebuild to ignore
;		print jobs that have a job count of 0; these must be left from
;		a crash.  Move setting of username to beginning.  Change job
;		number base to 1.  Do first $UPDSEC after queue rebuild rather
;		than before it.  Add an exit handler to update and delete the
;		global section.
;
;	V02-007	GWF0143		Gary W. Fowler		10-Dec-1981
;		Calculate time of next even hour and set timer to go
;		off at that hour.  Used in enforcing restricted log in
;		hours.
;
;	V02-006	SPF0039		Steve Forgey		23-Sep-1981
;		Use exec's copy of accounting flags to control accounting.
;
;	V02-005	SPF0021		Steve Forgey		28-Aug-1981
;		Initialize accounting manager flags.
;
;	V02-004	GWF0104		Gary W. Fowler		27-Aug-1981
;		Add code to create/shrink/expand queue file
;
;	V02-003	GWF0017		Gary W. Fowler		24-Feb-1981
;		Add checks for extra records linked to job header
;
;	V02-002	GWF0001		Gary W. Fowler		22-Jan-1980
;		Fix so batch jobs currently executing will not be restarted if
;		job controller aborts or system crashes.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[231,10]J/ML
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; THE QUEUE DEFINITONS
;
; OWN STORAGE:
 
	IMPURE_DATA
JBC$L_EXITBLOCK:
	.BLKL	5			; Exit handler control block

	PURE_SECTION	JBC$INIT
 
JBC$Q_MBNAME:				; JOB_CONTROLLER MAILBOX NAME
	STRING_DESC	<_MB1:>		; SPECIAL MAILBOX FOR JOB CONTROLLER

	.SBTTL	JOB_CONTROL INITIALIZATION
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SETS UP THE JOB_CONTROLLERS LOCAL DATA,
;	ASSIGNS CHANNEL FOR MESSAGE READS,
;	ISSUES A READ ON THE MAILBOX,
;	THEN ENTERS THE PROCESS MAIN LOOP.
;
; CALLING SEQUENCE:
;
;	NONE-ENTERED DIRECTLY FRON THE IMAGE ACTIVATOR
;
; INPUT PARAMETERS:	NONE
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;
;--
 
	PURE_SECTION	JBC$INIT	; INIT CODE SEGMENT
 
	.ENTRY	JBC$INIT,^M<>		;
 
	MOVAB	JBC$EXCEPTION,(FP)	; SET EXCEPTION HANDLER
	$CMKRNL_S W^SETNAM		; SET USER NAME TO JOB_CONTROL
	MOVAB	W^JBC$T_DATABLK,R11	; SET ADDRESS OF DATA BLOCK
	$DCLCMH_S	W^JBC$ERRORMSG	; SET ERROR TRAP HANDLER ADDRESS
	MOVAB	JCD_T_LINBUF(R11),-	; SET ADDRESS OF LINE BUFFER
		JCD_A_LBUFADR(R11)	; INTO BUFFER DESCRIPTOR
	MOVW	#<JCD_T_LINBFE-JCD_T_LINBUF>,- ; ALSO SET SIZE
		JCD_W_LBUFSIZ(R11)	; INTO HI 1/2 OF LENTGH LONGWORD
	$ASSIGN_S  W^JBC$Q_MBNAME,-	; ASSIGN A CHANNEL TO SPECIAL
		JCD_W_MBCHAN(R11)	; MAILBOX FOR JOB CONTROLLER INPUT
	CHECK_ERROR	MAILBOX_ASSIGN	; REPORT ERROR ASSINGING MAILBOX
 
;
; INIT WORK LIST AREA
;
 
	MOVAB	JCD_G_WORKLIST(R11),R0	; BASE ADDRESS OF WORKLIST AREA
	MOVAB	JCD_G_LISTS(R11),R1	; ENDING ADDRESS OF LIST AREA
20$:	MOVL	R0,(R0)			; POINT FLINK AT SELF
	MOVL	(R0)+,(R0)+		; POINT BLINK AT FLINK
	CMPL	R0,R1			; DONE ALL LISTS
	BLSSU	20$
 
;
; INIT FREE MESSAGE BUFFER LIST
;
 
	MOVAL	W^JBC$T_MSGBUFR,R1	; POINT AT FREE BUFFERS
40$:	INSQUE	(R1),@JCD_Q_FREEBUFR(R11) ; INSERT BUFFERS INTO FREE LIST
	MOVAL	JCM_K_SIZE(R1),R1	; ADVANCE TO NEXT BUFFER
	CMPL	R1,#JBC$T_MBUFEND	; PAST THE END?
	BLSSU	40$			; BR IF MORE TO DO
 
;
; OPEN THE ACCOUNTING FILE
;
	BSBW	JBC$OPENACNT		; SET A PLACE FOR ACCOUNTING
;
; INITIALIZE THE JOB INDICATOR
;
	MOVL	#1,JCD_W_JOBSEQ(R11)	; SET JOB TO START AT 1.
;
; GET TIME OF NEXT HOURLY AST
;
	$GETTIM_S	JCD_Q_TIME(R11)	; GET CURRENT TIME
	ASHQ	#-5,JCD_Q_TIME(R11),R2	; SCALE SO QUOTIENT WILL FIT INTO
					; A LONG WORD
	EDIV	#^X430E2340,R2,R2,R5	; DIVIDE BY NO. OF TICKS/HOUR SCALED
					; LIKE DIVIDEND
	EMUL	#^X430E2340,R2,#0,R2	; MULTIPLE BY NO. OF TICKS/HOUR
	ASHQ	#5,R2,JBC$Q_NXTAST	; SCALE BACK TO QUAD WORD SYSTEM TIME
					; NOW ADD NO. OF TICKS PER HOUR
					; TO GET TIME OF NEXT EVEN HOUR
	ADDL	JBC$Q_TICPERHR,JBC$Q_NXTAST
	ADWC	JBC$Q_TICPERHR+4,JBC$Q_NXTAST+4

; SET TIMER FOR NEXT HOUR

	$SETIMR_S	-		; SET TIMER
		ASTADR=SYM$CHKLOGINS,-	; AST ADDRESS
		DAYTIM=JBC$Q_NXTAST,-	; TIME OF DAY
		REQIDT=#JBC_K_HOURLY	; REQUEST ID

;
; Initialize queue file and global section.
;
	.ENABL	LSB
	CALLS	#0,INITQUEUE		; Initialize file
	MOVL	JBC$Q_RETADR,R10	; Get queue pointer
	MOVL	R10,JCD_A_QUEBASE(R11)	; Save in impure area
	BNEQ	10$			; Br if queue exists
	BRW	JBCGO			; Br if no to start job controller
;
; Declare an exit handler to update and delete the queue section.
;
10$:	MOVAB	W^EXIT_HANDLER,W^JBC$L_EXITBLOCK
	MOVL	#1,W^JBC$L_EXITBLOCK+8
	MOVAB	W^JBC$L_EXITBLOCK+16,W^JBC$L_EXITBLOCK+12
	$DCLEXH_S	W^JBC$L_EXITBLOCK
;
;	RECONSTRUCT THE QUEUE AS BEST AS POSSIBLE
;
	MOVC5	#0,(R10),#0,-		; ZERO OUT ALL QUEUES
		#<32*8>,SQH$Q_QUEUE(R10) ; FOR WAITING JOBS
	MOVZBL	SQH$B_MAXQUE(R10),R9	; GET MAXIMUM NUMBER OF QUEUES
	MOVAB	(R3),R6			; SET FIRST ADDRESS OF A QUEUE HEADER
20$:	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),40$ ; BR IF QUEUE IDLE
	ASSUME	SMQ$M_CREPND EQ SMQ$M_PAUSED
	BICB	#SMQ$M_PAUSED,SMQ$B_FLAGS(R6) ; CLEAR PAUSED OR CREATE PENDING
	BISB	#SMQ$M_STOPPED,SMQ$B_FLAGS(R6) ; SET QUEUE STOPPPED
	ASSUME	SMQ$L_CURRENT+4 EQ SMQ$L_HOLDLST ;
	CLRQ	SMQ$L_CURRENT(R6)	; REMOVE CURRENT AND EMPTY HOLD LIST
	INCB	SQH$B_NUMQUE(R10)	; ADD UP THE NUMBER OF QUEUES HERE
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),40$ ; BR IF NOT A DETACHED JOB
	CLRB	SMQ$B_JOBCNT(R6)	; ZERO NUMBER OF CURRENT JOBS
40$:	MOVAB	SMQ$K_SIZE(R6),R6	; ADVANCE POINTER TO NEXT HEADER
	SOBGTR	R9,20$			; COUNT DOWN NUBER TO OPERATE UPON
	MOVAB	(R6),R7			; SET STARTING ADDRESS OF QUEUE RECORDS
	SUBL3	R10,R7,SQH$L_FIRSTREC(R10) ; SET START OF RECORD SPACE IN QUEUE
	ADDL3	SQH$L_NEXTREC(R10),R10,R9 ; FIND END OF ALLOCATED QUEUE SPACE
	CMPL	R9,W^JBC$Q_RETADR+4	; IS THIS WITHIN THE QUEUE?
	BGEQ	45$			; BR IF NO - QUEUE IS A MESS
	CMPL	R9,R7			; IS IT ABOVE THE FIRST RECORD?
	BGTR	50$			; BR IF YES - LOOKS OK
45$:	MOVL	SQH$L_FIRSTREC(R10),SQH$L_NEXTREC(R10) ; SET QUEUE EMPTY
	BRB	MAPQUE			; GO MAP THE EMPTY QUEUE
50$:	MOVZWL	SJH$W_QINDEX(R7),R0	; IS THIS RECORD IN USE AS A JOB HEADER
	BEQL	80$			; IF EQL NO - CHECK NEXT
	CMPL	R0,SQH$L_FIRSTREC(R10)	; IS THIS IN THE QUEUE HEADER AREA?
	BGEQU	80$			; BR IF NO
	ADDL2	R10,R0			; Get real address
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R0),51$ ; Br if batch queue
	TSTB	SJH$B_COPYCNT(R7)	; Job copy count zero?
	BEQL	80$			; Br if yes to scrap job
51$:	CMPW	SJH$W_JOBSEQ(R7),-	; CHECK IF THIS JOB NUMBER IS -
		JCD_W_JOBSEQ(R11)	; HIGHER THAT THE NEXT TO ALLOCATE
	BLSSU	54$			; IF LSSU THEN NO, ALL IS WELL
	ADDW3	#1,SJH$W_JOBSEQ(R7),-	; SET ONE HIGHER AS NEXT TO ALLOCATE TO-
		JCD_W_JOBSEQ(R11)	; PREVENT TWO JOBS WITH SAME NUMBER.
54$:	MOVL	R7,R8			; SET JOB HEADER TO FOLLOW RECORD LINKS
	ASSUME	SJH$L_RECLINK EQ SQR$L_RECLINK ; ASSUMED RECORD LINKAGE
60$:	MOVL	SQR$L_RECLINK(R8),R0	; INDEX TO NEXT RECORD
	BEQL	70$			; BR IF NO MORE
	CMPL	R0,SQH$L_FIRSTREC(R10)	; IS THIS A VALID QUEUE RECORD?
	BLSSU	70$			; BR IF BELOW QUEUE RECORD SPACE
	CMPL	R0,SQH$L_NEXTREC(R10)	; CHECK AGAINST UPPER LIMIT
	BGTRU	70$			; BR IF NOT IN USED PORTION OF THE QUEUE
	ADDL	R10,R0			; FIND REAL ADDRESS
	TSTW	SQR$W_JOBSEQ+2(R0)	; IS THIS RECORD A JOB HEADER?
	BNEQ	70$			; BR IF THIS CANT BE JOB FILE RECORD
	CMPW	SQR$W_JOBSEQ(R0),SJH$W_JOBSEQ(R8) ; IS THIS RECORD IN THIS JOB?
	BNEQ	70$			; BR IF NO-CLOSE OUT THE JOB AS IS
	MOVL	R0,R8			; SET THIS AS NEXT RECORD
	BRB	60$			; CHECK IT OUT
70$:	CLRL	SQR$L_RECLINK(R8)	; MAKE SURE LAST LINK IS ZERO
	TSTL	SJH$L_RECLINK(R7)	; ANY RECORDS IN THIS JOB
	BEQL	80$			; BR IF NO - DON'T QUEUE THIS JOB
	BBS	#SJH$V_NOSTRT,SJH$B_FLAGS(R7),80$
					; DON'T PUT IN QUEUE IF JOB WAS RUNNING
	BSBW	SYM$JOBINSQUE		; INSERT THIS IN THE QUEUE
80$:	ACBL	R9,#SYM$K_RECSIZE,R7,50$ ; INDEX TO NEXT RECORD
 
	.DSABL	LSB
 
;
;	NOW BUILD A MAP OF RECORDS THAT ARE MISSING
;
MAPQUE:	SUBL3	SQH$L_FIRSTREC(R10),-	; FIND NUMBER OF BYTES IN USE
		SQH$L_NEXTREC(R10),R6	; IN THE QUEUE FILE RECORD SPACE
	DIVL	#SYM$K_RECSIZE,R6	; CHAGE THAT TO NUMBER OF RECORDS
	BEQL	99$			; BR IF NO RECORDS ALLOCATED
	ADDL3	#7,R6,R0		; ROUND UP TO MODULO 8
	ASHL	#-3,R0,R0		; FIND NUMBER OF BYTES TO MAP FILE
	SUBL	R0,SP			; MAKE SPACE FOR BIT MAP
	PUSHL	R0			; SAVE NUMBER OF BYTES ALLOCATED
	MOVC5	#0,(SP),#0,R0,4(SP)	; ZERO THE AREA
	CLRL	R0			; SET TO ZERO AS FIRST BIT
	MOVAB	4(SP),R5		; SET ADDRESS OF BIT ARRAY
10$:	SETBIT	R0,(R5)			; SET BITS FOR ALLOCATED RECORDS
	AOBLSS	R6,R0,10$		; SET ONE BIT FOR EACH RECORD
20$:	MOVAL	SQH$K_SIZE(R10),R6	; SET FOR START OF CHECK
	MOVZBL	SQH$B_MAXQUE(R10),R4	; GET NUMBER OF QUEUES
30$:	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),40$ ; BR IF NOT IN USE
	MOVL	SMQ$L_HOLDLST(R6),R0	; HEAD OF JOB LIST
	BEQL	40$			; BR IF NOTHING HERE
	BSBW	100$			; CHECK THAT OUT
40$:	ADDL	#SMQ$K_SIZE,R6		; ADVANCE POINTER
	SOBGTR	R4,30$			; DO ALL DEVICE QUEUES
	MOVL	SQH$L_TIMQUE(R10),R0	; GET ENTRIES IN TIME QUEUE
	BEQL	50$			; BR IF THERE ARE NONE
	BSBB	100$			; PROCESS THIS JOB LIST
50$:	MULL3	#8,(SP),R6		; FIND NUMBER OF BITS IN ARRAY
	ADDL	(SP),R5			; FIND ADDRESS OF LAST BYTE IN ARRAY+1
60$:	SUBL	#8,R6			; COUNT DOWN NUMBER OF BITS CHECKED
	BLSS	90$			; BR WHEN NO MORE
	TSTB	-(R5)			; ANY RECORDS HERE TO BE ALLOCATED
	BEQL	60$			; BR IF NO - CHECK NEXT BYTE
	MOVL	#7,R4			; SET FIRST BIT TO CHECK IN BYTE
70$:	BBCC	R4,(R5),80$		; BR IF THIS RECORD IS ALREADY ALLOCATED
	ADDL3	R4,R6,R0		; FIND RECORD NUMBER OF MISSING RECORD
	EMUL	#SYM$K_RECSIZE,R0,SQH$L_FIRSTREC(R10),R0 ; FIND BYTE OFFSET
	ADDL	R10,R0			; NOW GET THE REAL ADDRESS IN QUEUE FILE
	BSBW	SYM$DEARECORD		; PUT THE RECORD IN THE FREE LIST
80$:	SOBGEQ	R4,70$			; CHECK ALL BITS IN BYTE?
	BRB	60$			; DONE WITH THAT BYTE - CHECK NEXT
90$:	ADDL	(SP)+,SP		; CLEAR BIT BUFFER FROM STACK
99$:	BRB	JBCGO			; START THE JOB CONTROLLER
;
; LOCAL SUBROUTINE TO CLEAR ALL THE BITS ASSOCIATED WITH
; A LIST OF PRINT JOBS
;
100$:	ADDL3	R10,R0,R2		; FIND REAL ADDRESS OF JOB HEADER RECORD
	MOVL	SJH$L_PARMBLK(R2),R0	; GET JOB PARAMETER BLOCK
	BEQL	105$			; BR IF NONE
	BSBB	150$			; SET THE BIT
105$:	PUSHL	SJH$L_QNMLNK(R2)	; LINK TO QUEUE NAME
	CALLS	#1,200$			; CHECK IT OUT
	PUSHL	SJH$L_LOGLNK(R2)	; LINK TO LOG FILE NAME
	CALLS	#1,200$			; CHECK IT OUT
	SUBL3	R10,R2,R0		; RESET INDEX TO JOB HEADER
110$:	ADDL3	R10,R0,R1		; FIND REAL ADDRESS OF RECORD
	BSBB	150$			; SET THE BIT
	MOVL	SQR$L_RECLINK(R1),R0	; FOLLOW JOB LIST TO NEXT RECORD
	BNEQ	110$			; BR IF MORE FILES IN JOB
	MOVL	SJH$L_NEXTJOB(R2),R0	; GET OFFSET TO NEXT JOB
	BNEQ	100$			; DO THIS JOB
	RSB
 
150$:	SUBL	SQH$L_FIRSTREC(R10),R0	; FIND OFFSET TO RECORD
	DIVL	#SYM$K_RECSIZE,R0	; FIND RECORD NUMBER
	BBSC	R0,(R5),160$		; BR IF RECORD NOT FOUND BEFORE
	PUSHL	R1			; SAVE RECORD POINTER
	SHOW_ERROR	MULT_ALLOCATE	; TELL THAT MULTIPLE ALLOCATIONS EXIST
	POPR	#^M<R1>			;
160$:	RSB				;

200$:
	.WORD	0
	MOVL	4(AP),R0		; LINK WORD
	BEQL	300$			; IF EQL THEN NO LINK
	BSBW	150$			; GO SET BIT FOR THIS RECORD
	MOVL	4(AP),R0		; GET LINK BACK
	ADDL	R10,R0			; GET REAL ADDR.
	MOVL	SQR$L_XTRALNK(R0),R0	; GET LINK TO EXTRA RECORD
	BEQL	300$			; IF EQL THEN NO EXTRA RECORD
	BSBW	150$			; GET SET BIT FOR THIS RECORD
300$:	RET				; RETURN

 
JBCGO:
;
; DO UPDATE SECTION TO CHECKPOINT QUEUE FILE
;
	TSTL	R10			; Queue exists?
	BEQL	440$			; Br if no
	$UPDSEC_S	-
		EFN=#JBC_K_UPDFLG,-	; EVENT FLAG
		INADR=W^JBC$Q_RETADR,-	; START ADDRESS
		RETADR=W^JBC$Q_UPDADR,-	; END ADDRESS
		IOSB=W^JBC$Q_UPDIOSB,-	; IOSB ADDRESS
		UPDFLG=#1		; FLAG
	BLBS	R0,435$			; IF LBS - THEN SUCCESS
420$:	SHOW_ERROR	QUE_UPD		; DISPLAY ERROR MESSAGE
	CLRL	JCD_A_QUEBASE(R11)	; DISABLE SYMBION FUNCTIONS
	BRB	440$			; START REST OF JOB CONTROLLER
435$:	$WAITFR_S	#JBC_K_UPDFLG	; WAIT FOR UPDATE
	BLBC	R0,420$			; IF LBC - THEN ERROR
440$:	BSBW	JBC$READMB		; ISSUE INITIAL READ ON MAILBOX
	BRW	JBC$LOOP		; START THE MAIN LOOP


SETNAM:	.WORD	0			;
	MOVC5	W^JBC$Q_JBCNAM,@W^JBC$Q_JBCNAM+4,#^A/ /,- ; SET USER NAME
		#12,@#CTL$T_USERNAME	; TO JOB CONTROL FOR ERROR MESSAGES
	MOVL	#1,R0
	RET				;


JBCSYSQUE:
	.LONG	9
	.ADDRESS  5$
5$:	.ASCII	'JBCSYSQUE'

EXIT_HANDLER:
	.WORD	0
	TSTL	JBC$Q_RETADR		; Queue exists?
	BEQL	10$			; Br if no
	$UPDSEC_S -			; Update queue section to disk
		EFN=#JBC_K_UPDFLG, -
		INADR=W^JBC$Q_RETADR, -
		UPDFLG=#1
	$WAITFR_S -			; Wait for update to complete
		EFN=#JBC_K_UPDFLG	
	$DGBLSC_S -			; Delete the global section
		FLAGS=#SEC$M_SYSGBL, -
		GSDNAM=W^JBCSYSQUE
10$:	RET				; Return


	.END	JBC$INIT		;
