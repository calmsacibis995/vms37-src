	.TITLE	JBCSYMOPT - PROCESS SYMBIONT MANAGER OPTIONS
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET JOB CONTROLLER/SYMBIONT MANAGER
;
; ABSTRACT:	CONVERT SYMBIONT MANAGER REQUESTS
;
;
; ENVIRONMENT:	NATIVE NON-PRIVLEGED USER MODE CODE
;
; AUTHOR:  W.H.BROWN, CREATION DATE: 6-APR-77
;
; MODIFIED BY:
;
;	V02-017	MLJ0081		Martin L. Jack,	1-Mar-1982  16:35
;		Correct erroneous ADDB in DESTQUE routine.
;		Delete unreferenced global symbols.
;
;	V02-016	MLJ35309	Martin L. Jack,	8-Jan-1982  17:12
;		Add NODISWAP option to support START/QUEUE/NODISABLE.
;
;	V02-015	GWF0123		Gary W. Fowler		05-Nov-1981
;		Change bit setting when delete option is specified.  This
;		corrects problem of deleting files after first copy of a
;		multiple copy job.  Check for ALTPRI privilege instead of
;		OPER privilege when attempting to change job priority.
;
;	V02-014	GWF0116		Gary W. Fowler		28-Oct-1981
;		Add support for WS extent
;
;	V02-013	GWF0102		Gary W. Fowler		18-Aug-1981
;		Add parameters to parameter block starting at an offset of
;		SJH$L_NEXTJOB into the block.  This prevents the block from
;		being seen as a job header record on restart.
;
;	V02-012	GWF0079		Gary W. Fowler		16-Jul-1981
;		Change job name to ASCIC string.
;
;	V02-011	GWF0067		Gary W. Fowler		30-Jun-1981
;		Add SMO$K_DESTQUE option processing.  Fix problem in LOCATEQ
;		routine.
;
;	V02-010	GWF0060		Gary W. Fowler		11-Jun-1981
;		Add processing of destination queue and priority on /REQUE
;
;	V02-009	GWF0039		Gary W. Fowler		6-May-1981
;		Add file size and put in queue record
;
;	V02-008	GWF0036		Gary W. Fowler		21-Apr-1981
;		Add routines for NOTIFY/NONOTIFY options
;
;	V02-007	GWF0007		Gary W. Fowler		25-Feb-1981
;		Modify and add routines to allocate and put queue name and log
;		file name into records linked to job header.
;
;	V02-006	GWF0006		Gary W. Fowler		15-Feb-1980
;		Fix so if release time specified is less than current time,
;		make release time equal to current time.  This prevents jobs
;		from being placed at head of queue if so.
;
;	V02-005	GWF0005		Gary W. Fowler		03-Jan-1980
;		Fix problem of /BACKSPACE qualifier sending invalid option code
;		to print symbiont.
;
;	V02-004	GWF0004		Gary W. Fowler		30-Nov-1979
;		Add routines to process /PROCESSOR and /CHARACTERISTICS
;		qualifiers.
;
;	V02-003	GWF0003		Gary W. Fowler		05-Sep-1979
;		Added routines to process CPU time limits,working set quotas
;		and working set defaults.  Fix so record is deallocated if
;		parameter block length is exceeded.
;
;	V02-002	GWF0002		Gary W. Fowler		27-Aug-1979
;		Added error message when parameter block length is exceeded.
;
;	V02-001	-
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
; EQUATED SYMBOLS:
;
	$SMRDEF				; SYMBIONT MANAGER REQUEST CODES
	$MSGDEF				; SYSTEM WIDE MESSAGE CODES
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
	JBCSCTDEF			; SYMBIONT CONTROL TABLE DEFINITIONS
;
; OWN STORAGE:	THIS MODULE HAS NO LOCAL STORAGE
;


	.SBTTL	PROCESS OPTIONS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS ALL THE OPTIONS
;	ASSOCIATED WITH A GIVEN SYMBIONT MANAGER REQUEST.
;	THERE ARE SEVERAL MAIN SUBROTINES THAT ARE USED
;	DEPENDING UPON THE CURRENT REQUEST BEING PROCESSED
;	BY THE SYMBIONT MANAGER.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$CNVOPTINI		; CONVERT OPTIONS FOR INIT & START
;	BSB/JSB	SYM$CNVOPTENT		; CONVERT OPTIONS FOR AN ENTER
;	BSB/JSB	SYM$CNVOPTJOB		; CONVERT OPTIONS FOR JOB CREATE
;
; INPUT PARAMETERS:
;
; IN ALL CASES:		R5 HAS ADDRESS OF FIRST OPTION
; 			R10 HAS BASE OF PRINT QUEUE FILE
;			R9 HAS CURRENT SYMBIONT MANAGER RECORD
;
; AT SYM$CNVOPTINI:	R6 IS THE ADDRESS OF THE DEVICE QUEUE
;
; AT SYM$CNVOPTENT:	R7 HAS ADDRESS OF PRINT JOB HEADER RECORD
;			R8 HAS ADDRESS OF THE PRINT FILE DESCRIPTOR
;
; OUTPUT PARAMETERS:
;
;	ALL OPTIONS ARE PROCESS ADJUSTING DATA IN THE RECORDS
;	AS NECESSARY. R5 IS ADVANCED TO THE END OF THE OPTION LIST
;	AS SPECIFIED BY THE LENGTH OF THE MESSAGE, OR BY ENCOUNTERING
;	A ZERO BYTE IN THE OPTION FIELD
;
; COMPLETION CODES:
;
;	R0 WILL CONTAIN SMINVOPT IF AN INVALID OPTION IS DETECTED
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION

SYM$CNVOPTINI::				; CONVERT OPTIONS FOR INIT AND START
	BSBW	SYM$GETOPT		; PICK UP NEXT OPTION CODE
	PUSHAL	B^SYM$CNVOPTINI		; SET RETURN ADDRESS
	CASE	R0,-			; DISPATCH ON CODE
		LIMIT = #SMO$K_CURFORM,<- ; LOW VALUE FOR CASE IS THE FORMS-TYPE
		DEVQUEFORM,-		; SET DEVICE FORMS TYPE
		GENERICPRT,-		; GENERIC PRINTING ALLOWED
		NOGENERIC,-		; AND THE ONE TO INHIBIT GENERIC OUTPUT
		DETJOB,-		; THE QUEUE IS FOR DETACHED JOB QUEUING
		GENDEVQUE,-		; THE QUEUE IS FOR GENERIC DEVICE
		NOGENDEV,-		; NOT A GENERIC DEVICE
		DEFBRST,-		; DEFAULT A BURST PAGE
		NODEFBRST,-		; NO DEFAULT BURST PAGE
		DEFFLAG,-		; DEFAULT A FLAG PAGE
		NODEFFLAG,-		; NO DEFAULT FLAG
		TERMINAL,-		; QUEUE IS FOR A TERMINAL
		NOTERMINAL,-		; NOT A TERMINAL
		JOBLIMIT,-		; SET BATCH QUEUE JOB LIMIT
		INITPRI,-		; BATCH JOB INITIAL PRIORITY
		NOSWAP,-		; DISABLE SWAPING THE JOB
		MAXCPULIM,-		; MAX CPU TIME LIMIT SPECIFIED
		NOMXCPULM,-		; NO MAX CPU TIME SPECIFIED
		DEFCPULIM,-		; DEF. CPU TIME LIMIT SPECIFIED
		NODFCPULM,-		; NO DEFAULT CPU TIME SPECIFIED
		WSQUOTA,-		; WORKING SET QUOTA SPECIFIED
		NOWSQUTA,-		; NO WORKING SET QUOTA
		WSDEFLT,-		; WORKING SET DEFAULT SPECIFIED
		NOWSDFLT,-		; NO WORKING SET DEFAULT
		DEVQUECHAR,-		; SET DEVICE QUE CHARACTERISTICS
		SYMBNAM,-		; SYMBIONT NAME SPECIFIED
		WSEXTNT,-			; WS EXTENT
		NOWSEXTNT,-
		SWAP,-			; ENABLE SWAPPING THE JOB
		>
	BRW	INVOPT			; INVALID OPTION FOR THIS REQUEST
 
 
SYM$CNVOPTENT::				; CONVERT OPTIONS FOR ENTER FILE
	BSBW	SYM$GETOPT		; GET NEXT OPTION CODE INTO R0
	PUSHAL	B^SYM$CNVOPTENT		; SET RETURN FROM CASE ADDRESS
	CASE	R0,-			; DISPATCH ON OPTION TYPE
		LIMIT = #SMO$K_DELETE,-	; LOW LIMIT VALE OF CASE
		<DELETEOP,-		; DELETE FILE OPTION
		BRSTPAG,-		; PROVIDE A BURST PAGE
		NOBRST,-		; NO BURST PAGE PRINT
		FLAGPAG,-		; PRINT A FLAG PAGE
		NOFLAG,-		; DONT PRINT A FLAG
		PAGHDR,-		; ENABLE THE PAGE HEADER
		DOUBLE,-		; SPACING:2 LISTING
		NOFEED,-		; NO SYMBIONT GENERATED FORM-FEEDS
		PAGCNT,-		; A PAGE COUNT WAS SPECIFIED
		FILCOPIES,-		; NUMBER OF COPIES PER FILE
		FILESIZE,-		; FILE SIZE
		DESTQUE,-			; NEW QUEUE TO PUT JOB IN
		>
	BRB	JOBOPT			; TRY JOB OPTIONS IF THIS FAILS
 
SYM$CNVOPTJOB::				; CONVERT OPTIONS FOR JOB CREATE
	BSBW	SYM$GETOPT		; PICK UP NEXT OPTION BYTE
	PUSHAL	B^SYM$CNVOPTJOB		; SER RETURN ADDRESS
JOBOPT:	CASE	R0,-
		LIMIT = #SMO$K_RLSTIM,<- ; LOWEST VALID OPTION IS RELEASE TIME
		RLSTIME,-		; SPECIFY TIME TO HOLD JOB UNTIL
		HOLDJOB,-		; HOLD JOB INDEFINITELY
		JOBPRI,-		; SPECIFY JOB PRIORITY
		JOBCOPIES,-		; SPECIFY A COPY COUNT FOR JOB
		PRTFORMTYP,-		; SPECIFY FORM TYPE
		LOWER,-			; REQUIRE LOWER CASE PRINTER
		JOBPARM,-		; SET JOB PARAMETERS
		JOBNAME,-		; SET THE JOB NAME
		NOLOWER,-		; CLEAR LOWER CASE REQUIRED
		CPULIM,-		; CPU TIME LIMIT SPECIFIED
		NOCPULIM,-		; NO CPU TIME LIMIT
		WRKSETQUO,-		; WORKING SET QUOTA SPECIFIED
		NOWRKSTQUO,-		; NO WORKING SET QUOTA
		WRKSETDFT,-		; WORKING SET DEFAULT SPECIFIED
		NOWRKSETDF,-		; NO WORKING SET DEFAULT
		PRTCHARTYP,-		; SPECIFY PRINT CHARACTERISTICS
		LOGFSPC,-		; LOG FILE SPEC
		QLOGNAM,-		; QUEUE NAME
		KEEPLOG,-		; DON'T DELETE LOG AFTER PRINTING
		NOSPOOL,-		; DON'T SPOOL LOG FILE
		NOKEEPLOG,-		; DELETE LOG FILE
		NOLOG,-			; NO LOG FILE
		NOTIFY,-		; INFORM USER OF JOB COMPLETION
		NONOTFY,-		; DON'T INFORM USER
		WSXTNT,-		; WORKING EXTENT
		NOWSXTNT,-		; NO WORKING SET EXTENT
		>
10$:	BRB	INVOPT			; BAD OPTION VALUE
 
SYM$CNVOPTABO::				; CONVERT OPTION FOR ABORT
	CLRB	SJH$B_REQOPT(R7)	; ASSUME NO REQUEUE
10$:	BSBW	SYM$GETOPT		; GET OPTION CODE
	PUSHAB	10$			; RETURN ADDR FOR OPTION PROCESSOR
	CASE	R0,-
		LIMIT=#SMO$K_REQUEUE,<-	; LOW LIMIT FOR CASE
		REQUEIT,-		; REQUEUE SPECIFIED
		DESTQUE,-		; REQUEUE TO DIFFERENT QUEUE
		REQPRIO,-		; REQUEUE AT NEW PRIORITY
		>
	BRB	INVOPT			; BAD OPTION CODE

SYM$CNVOPTRES::				; CONVERT OPTIONS FOR RESTART
	MOVZWL	#MSG$_RESOPR,R1		; ASSUME RESTART AT CURRENT PLACE
10$:	BSBW	SYM$GETOPT		; PICK UP NEXT OPTION CODE
	PUSHAB	10$			; PUSH RETURN FROM OPTION PROCESSOR
	CASE	R0,-			; DECODE THE OPTION
		LIMIT=#SMO$K_NEXTJOB,<-	; LOW LIMIT FOR THE CASE
		RSTRTNXT,-		; RESTART AT NEXT FILE
		TOPOFILE,-		; RESTART AT THE BEGINNING
		SPACECNT,-		; SPECIFY SPACING COUNT
		>
INVOPT:	BRW	SYM_INVOPT		; ILLEGAL OPTION
;
; SPECIFIC OPTION ROUTINES
;
 
DESTQUE:				; REQUEUE TO A DIFFERENT QUEUE
	CALLS	#0,LOCATEQ		; LOCATE QUEUE SPECIFED
	BLBS	R0,10$			; IF LBS - THEN QUEUE FOUND
	BRW	ERREXT			; TAKE ERROR EXIT OUT
10$:	MOVW	R1,SJH$W_REQINDX(R7)	; SET NEW QUEUE INDEX
	MOVZBL	(R5)+,R0		; Pick up length, bump past
	ADDL2	R0,R5			; MOVE PAST QUEUE
	RSB				; RETURN

REQPRIO:
	CMPB	(R5),SMR$B_PROCPRI(R9)	; CHECK IF TRYING TO RAISE PRIOITY
	BLEQU	10$			; BR IF NO-THAT IS ALWAYS ALLOWED
	BSBW	SYM$CKALTPRV		; SEE IF THE USER HAS PRIVILEGE
	BLBS	R0,10$			; IF LBS - THEN HE DOES
	BRW	ERREXT			; TAKE ERROR EXIT OUT
10$:	MOVZBL	(R5)+,R0		; GET PRIOITY
	CMPB	R0,#SYM_K_PRTPRI	; VALID PRIORITY?
	BLEQU	20$			; IF LEQ THEN YES
	BRW	SYM_INVOPT		; INVALID OPTION
20$:	MOVB	R0,SJH$B_REQPRIO(R7)	; SET NEW PRIORITY
	RSB				; RETURN TO DISPATCHER

REQUEIT:
	MOVB	#1,SJH$B_REQOPT(R7)	; INDICATE REQUEUE IS SPECIFED
	RSB				; RETURN

RSTRTNXT:				; RESTART PRINTING AT NEXT FILE
	MOVZWL	#MSG$_ABOOPR,R1		; SET TO ABORT CURRENT OPERATION
	RSB				; RETURN TO THE DISPATCHER
 
SPACECNT:				; SPACE THE LISTING
	CVTWL	(R5)+,R0		; GET THE COUNT
	EMUL	#<1@16>,R0,R1,R0	; MERGE COUNT WITH MESSAGE
	MOVL	R0,R1			; MOVE TO PROPER REGISTER
	RSB				; BACK TO THE DISPATCHER
 
TOPOFILE:				; RESTART AT THE BEGINNING
	SETBIT	#31,R1			; SET FLAG FOR TOP OF FILE
	RSB				; AND BACK TO THE DISPATCHER
 
GENERICPRT:				; GENERIC PRINTING ON DEVICE
	CLRBIT	SMQ$V_NOGENERIC,SMQ$B_FLAGS(R6) ; ENABLE GENERIC PRINTING
	RSB				; RETURN TO DISPATCHER
 
NOGENERIC:				; DISALLOW GENERIC PRINTING ON DEVICE
	SETBIT	SMQ$V_NOGENERIC,SMQ$B_FLAGS(R6) ; DISABLE GENERIC PRINTING
	RSB				; RETURN TO DISPATCHER
DETJOB:					; QUEUE IS FOR DETACHED JOB QUEUING
	SETBIT	SMQ$V_DETJOB,SMQ$B_FLAGS(R6) ; SET PROPER FLAG
	RSB				; RETURN TO DISPATCHER
 
GENDEVQUE:				; SET FLAG THAT THIS QUEUE IS
	SETBIT	SMQ$V_GENDEV,SMQ$B_FLAGS(R6) ; FOR THE GENERIC DEVICE
	RSB				; RETURN TO DISPATCHER
 
NOGENDEV:				; CLEAR FLAG THAT THIS QUEUE IS
	CLRBIT	SMQ$V_GENDEV,SMQ$B_FLAGS(R6) ; FOR THE GENERIC DEVICE
	RSB				; RETURN TO DISPATCHER
 
DEFBRST:				; DEFAULT A BURST PAGE
	SETBIT	SMQ$V_DEFBRST,SMQ$B_CHAR(R6) ; SET FLAG
	RSB				; RETURN TO DISPATCHER
 
NODEFBRST:				; NO DEFAULT BURST PAGE
	CLRBIT	SMQ$V_DEFBRST,SMQ$B_CHAR(R6) ; CLR FLAG
	RSB				; RETURN TO DISPATCHER
 
DEFFLAG:				; DEFAULT A BURST PAGE
	SETBIT	SMQ$V_DEFFLAG,SMQ$B_CHAR(R6) ; SET FLAG
	RSB				; RETURN TO DISPATCHER
 
NODEFFLAG:				; NO DEFAULT BURST PAGE
	CLRBIT	SMQ$V_DEFFLAG,SMQ$B_CHAR(R6) ; CLR FLAG
	RSB				; RETURN TO DISPATCHER
 
TERMINAL:				; DEVICE IS A TERMINAL
	SETBIT	SMQ$V_TRMDEV,SMQ$B_CHAR(R6) ; SET FLAG
	RSB				; RETURN TO DISPATCHER
 
NOTERMINAL:				; DEVICE IS NOT A TERMINAL
	CLRBIT	SMQ$V_TRMDEV,SMQ$B_CHAR(R6) ; CLR FLAG
	RSB				; RETURN TO DISPATCHER
 
JOBLIMIT:				; SET BATCH QUEUE JOB LIMIT
	MOVB	(R5)+,SMQ$B_JOBLIM(R6)	; SET DETACHED JOB LIMIT
	RSB				; RETURN TO DISPATCHER
 
INITPRI:MOVZBL	(R5)+,R0		; JOB INITIATION PRIOITY
	INSV	R0,#SMQ$V_INIPRI,-	; SET BASE PRIORITY INTO QUEUE
		#SMQ$S_INIPRI,SMQ$B_CHAR(R6) ; INTO CHARACTERISTICS BYTE
	RSB				;
 
NOSWAP:	SETBIT	SMQ$V_NOSWAP,SMQ$B_CHAR(R6) ; DIABLE SWAPPING FOR THIS QUEUE
	RSB

SWAP:	CLRBIT	SMQ$V_NOSWAP,SMQ$B_CHAR(R6) ; ENABLE SWAPPING FOR THIS QUEUE
	RSB
 
DEVQUEFORM:				; SET DEVICE FORMS TYPE
	MOVB	(R5)+,SMQ$B_FORMS(R6)	; SET THE FORMS TYPE
	RSB				; RETURN TO DISPATCHER
 
MAXCPULIM:				; MAX CPU LIMIT SPECIFIED
	BISW	#SMQ$M_MCPULM,SMQ$W_QUOFLG(R6)	; SET OPTION PRESENT
	MOVL	(R5)+,SMQ$L_MCPULM(R6)	; PUT VALUE IN 
	RSB				; RETURN TO DISPATCHER

NOMXCPULM:				; NO MAX CPU TIME LIMIT
	BICW	#SMQ$M_MCPULM,SMQ$W_QUOFLG(R6)	; SET NOT PRESENT
	CLRL	SMQ$L_MCPULM(R6)	; CLEAR VALUE (SET TO INFINITE)
	RSB				; RETURN TO DISPATCHER

DEFCPULIM:				; DEFAULT CPU TIME LIMIT
	BISW	#SMQ$M_DCPULM,SMQ$W_QUOFLG(R6)	; SET OPTION PRESENT
	MOVL	(R5)+,SMQ$L_DCPULM(R6)	; PUT IN VALUE
	RSB				; RETURN TO DISPATCHER

NODFCPULM:				; NO DEFAULT CPU TIME LIMIT
	BICW	#SMQ$M_DCPULM,SMQ$W_QUOFLG(R6)	; SET NOT PRESENT
	CLRL	SMQ$L_DCPULM(R6)	; CLEAR VALUE (SET TO INFINITE)
	RSB				; RETURN TO DISPATCHER

WSQUOTA:				; WORKING SET QUOTA SPECIFIED
	BISW	#SMQ$M_WSQUTA,SMQ$W_QUOFLG(R6)	; SET OPTION PRESENT
	MOVW	(R5)+,SMQ$W_WSQUTA(R6)	; MOVE IN VALUE
	RSB				; RETURN TO DISPATCHER

NOWSQUTA:				; NO WORKING SET QUOTA SPECIFIED
	BICW	#SMQ$M_WSQUTA,SMQ$W_QUOFLG(R6)	; SET NOT PRESENT
	CLRW	SMQ$W_WSQUTA(R6)	; SET TO ZERO
	RSB				; RETURN TO DISPATCHER

WSDEFLT:				; WORKING SET DEFAULT SPECIFIED
	BISW	#SMQ$M_WSDFLT,SMQ$W_QUOFLG(R6)	; SET OPTION PRESENT
	MOVW	(R5)+,SMQ$W_WSDFLT(R6)	; MOVE IN VALUE
	RSB				; RETURN TO DISPATCHER

NOWSDFLT:				; NO WORKING SET DEFAULT
	BICW	#SMQ$M_WSDFLT,SMQ$W_QUOFLG(R6)	; SET NOT PRESENT
	CLRW	SMQ$W_WSDFLT(R6)	; CLEAR VALUE
	RSB				; RETURN TO DISPATCHER

WSEXTNT:				; WORKING SET EXTENT
	BISW	#SMQ$M_WSEXTNT,SMQ$W_QUOFLG(R6) ; SET OPTION PRESENT
	MOVW	(R5)+,SMQ$W_WSEXTNT(R6)	; MOVE IN VALUE
	RSB

NOWSEXTNT:				; NO WORKING SET EXTENT
	BICW	#SMQ$W_WSEXTNT,SMQ$W_QUOFLG(R6) ; SET NOT PRESENT
	CLRW	SMQ$W_WSEXTNT(R6)	; CLEAR VALUE
	RSB

SYMBNAM:				; SYMBIONT NAME SPECIFIED
	MOVZBL	(R5),R0			; GET LENGTH OF NAME
	INCL	R0			; INCLUDE BYTE COUNT IN MOVE
	CMPL	R0,#SYM_K_NAMSIZ	; TEST IF TOO LONG
	BLEQ	5$			; BR IF NOT TOO LONG
	BRW	SYM_INVOPT		; BR TO ERROR ROUTINE
5$:	MOVC5	R0,(R5),#^A/ /,-	; MOVE SYMBIONT NAME TO
		#SYM_K_NAMSIZ,SMQ$T_SMBNAME(R6)	; QUEUE HEADER
	MOVL	R1,R5			; SET POINTER TO MSG. DATA
	RSB				; RETURN

DEVQUECHAR:				; CHARACTERISTICS SPECIFIED
	MOVC3	#16,(R5),SMQ$T_DQCHAR(R6)	; MOVE CHAR. INTO SMQ
	MOVL	R1,R5			; SET POINTER INTO MESSAGE
	RSB				; GO BACK

DELETEOP:				; DELETE FILE AFTER PRINTING
	SETBIT	SQR$V_TEMPDEL,SQR$B_FLAGS(R8) ; SET FLAG TO DELETE
	RSB				; RETURN TO DISPATCHER
 
BRSTPAG:				; PRINT A BURST PAGE PRIOR TO FILE
	SETBIT	SQR$V_BRSTPAG,SQR$B_FLAGS(R8) ; SET FLAG TO PRINT BURST PAGE
	RSB				; RETURN TO DISPATCHER
 
NOBRST:
	CLRBIT	SQR$V_BRSTPAG,SQR$B_FLAGS(R8) ; CLEAR FLAG FOR BUSRT PAGE
	RSB				; RETURN TO DISPATCHER
 
FLAGPAG:				; PRINT A FLAG PAGE IN FRONT OF FILE
	SETBIT	SQR$V_FLAGPAG,SQR$B_FLAGS(R8) ; SET FLAG TO PRINT BURST PAGE
	RSB				; RETURN TO DISPATCHER
 
NOFLAG:
	CLRBIT	SQR$V_FLAGPAG,SQR$B_FLAGS(R8) ; CLEAR BIT TO PRINT FLAG PAGE
	RSB				; RETURN TO DISPATCHER
 
PAGHDR:					; TURN ON HEADER FOR PAGES
	SETBIT	SQR$V_PAGHDR,SQR$B_FLAGS(R8) ; SET FLAG IN FILE RECORD
	RSB				; RETURN TO DISPATCHER
 
DOUBLE:					; DOUBLE SPACE THE LISTING
	SETBIT	SQR$V_DOUBLE,SQR$B_FLAGS(R8) ; SET BIT FOR DOUBLE SPACING
	RSB				; RETURN TO DISPATCHER
 
NOFEED:					; NO IMPLIED FORM-FEED
	SETBIT	SQR$V_NOFEED,SQR$B_FLAGS(R8) ; SET BIT IF JOB RECORD
	RSB				; RETURN TO DISPATCHER
 
PAGCNT:					; SET MAXIMUM PAGE COUNT
	MOVW	(R5)+,SQR$W_PAGCNT(R8)	; SET USER SUPPLIED PAGE COUNT
	RSB				; RETURN TO DISPATCHER
 
FILCOPIES:				; SPECIFY COPY COUNT FOR FILE
	MOVB	(R5)+,SQR$B_COPYCNT(R8)	; SET COPY COUNT IN FILE RECORD
	RSB				; RETURN TO DISPATCHER
 
RLSTIME:				; SPECIFY TIME TO RELEASE JOB
	MOVQ	(R5)+,SJH$Q_TIME(R7)	; SET TIME TO HOLD FILE
	CMPQUAD	JCD_Q_TIME(R11),-	; COMPARE CURRENT TIME WITH
		SJH$Q_TIME(R7)		; RELEASE TIME SPECIFIED
	BLEQU	10$			; BR IF CURRENT TIME EARLIER
	MOVQ	JCD_Q_TIME(R11),-	; SET RELEASE TIME
		SJH$Q_TIME(R7)		; EQUAL TO CURRENT TIME
10$:	RSB				; RETURN TO DISPATCHER
 
FILESIZE:				; MOVE FILE SIZE INTO RECORD
	MOVL	(R5)+,SQR$L_FILESIZ(R8)	; INTO JOB RECORD
	RSB				; RETURN TO DISPATCHER

HOLDJOB:				; HOLD FILE FOR PRINTING LATER
	SETBIT	SJH$V_HOLD,SJH$B_FLAGS(R7) ; SET FLAG TO INDICATE HOLD STATE
	RSB				; RETURN TO DISPATCHER
 
LOWER:	SETBIT	SJH$V_LOWER,SJH$B_FLAGS(R7) ; SET FLAG TO INDICATE LOWER CASE-
	RSB				; PRINTING REQUIRED AND RETURN
 
NOLOWER:CLRBIT	SJH$V_LOWER,SJH$B_FLAGS(R7) ; CLEAR FLAG TO INDICATE LOWER CASE-
	RSB				; PRINTING NOT REQUIRED AND RETURN
 
PRTFORMTYP:				; SET PRINT FORM TYPE
	MOVB	(R5)+,SJH$B_FORMS(R7)	; SET PRINT FORMS
	RSB				; RETURN TO DISPATCHER

PRTCHARTYP:				; SPECIFY CHARACTERISTICS
	MOVC3	#16,(R5),SJH$T_DQCHAR(R7)	; MOVE CHAR. INTO SJH
	MOVL	R1,R5			; SET POINTER INTO MESSAGE
	RSB				; RETURN
 
JOBCOPIES:				; SPECIFY COPY COUNT FOR ENTIRE JOB
	MOVB	(R5)+,SJH$B_COPYCNT(R7)	; SET COUNT IN JOB HEADER
	RSB				; RETURN TO DISPATCHER
 
QLOGNAM:				; SPECIFY QUEUE NAME
	CALLS	#0,LOCATEQ		; SEARCH FOR QUEUE SPECIFIED
	BLBS	R0,10$			; IF LBS - THEN FOUND IT
	BRW	ERREXT			; TAKE ERROR EXIT
10$:	PUSHAL	SJH$L_QNMLNK(R7)	; ADDR. OF LINK
	CALLS	#1,ALLOPUT		; ALLOCATE AND PUT QUEUE NAME
	BLBS	R0,70$			; IF LBS THEN SUCCESS
	BRW	ERREXT			; BRANCH TO ERROR ROUTINE
70$:	SETBIT	SJH$V_QNMPRES,SJH$L_GQNMFLG(R7) ; SET BIT INDICATING PRESENT
	CLRBIT	SJH$V_NOSPOOL,SJH$L_GQNMFLG(R7) ; CLEAR NO SPOOL BIT
	RSB				; RETURN

LOGFSPC:				; SPECIFY LOG FILE
	PUSHAL	SJH$L_LOGLNK(R7)	; ADDR. OF LINK WORD
	CALLS	#1,ALLOPUT		; ALLOCATE AND PUT IN RECORD
	BLBS	R0,10$			; IF LBS THEN SUCCESS
	BRW	ERREXT			; BRANCH TO ERROR ROUTINE IF FAILURE
10$:	SETBIT	SJH$V_LFSPRES,SJH$L_GQNMFLG(R7) ; SET BIT INDICATING PRESENT
	CLRBIT	SJH$V_NOLOG,SJH$L_GQNMFLG(R7) ; CLEAR NO LOG BIT
	RSB				; RETURN
;
; LOCAL ROUTINE TO ALLOCATE AND PUT DATA INTO EXTRA RECORDS
;
ALLOPUT:
	.WORD	0
	BSBW	SYM$ALLRECORD		; ALLOCATE RECORD FOR QUEUE NAME
	BLBS	R0,5$			; IF LBS THEN RECORD ALLOCATED OK
	BRW	45$			; BRANCH TO ERROR EXIT
5$:	MOVL	R2,R8			; SAVE ADDR. OF ALLOCATED RECORD
	SUBL3	R10,R8,@4(AP)		; LINK RECORD TO JOB HEADER
	CLRW	SQR$W_RECID(R8)		; CLEAR RECORD ID
	CLRL	SQR$L_XTRALNK(R8)	; CLEAR LINK TO EXTRA RECORD
	CLRL	-(SP)			; CLEAR FLAG
	MOVZBL	(R5),R0			; GET LENGTH OF QUEUE NAME
	INCL	R0			; INCLUDE COUNT BYTE IN LENGTH
	CMPB	R0,#SYM_K_MAXQLEN	; TOO LONG TO FIT IN ONE RECORD?
	BLEQU	15$			; IF LEQ THEN WILL FIT IN ONE RECORD
	MOVL	R0,(SP)			; SAVE TOTAL LENGTH
	MOVL	#SYM_K_MAXQLEN,R0	; SET LENGTH TO MAX IN ONE RECORD
15$:	MOVC3	R0,(R5),SQR$L_DATALOC(R8)	; MOVE QUEUE NAME
	MOVL	R1,R5			; SAVE ADDR. OF NEXT BYTE IN MESSAGE
	MOVL	(SP)+,R3		; GET NO. OF BYTE REMAINING
	BEQL	35$			; IF EQL THEN NO MORE TO MOVE
	BSBW	SYM$ALLRECORD		; GET ANOTHER RECORD
	BLBS	R0,25$			; IF LBS THEN ALLOCATE OK
	PUSHL	R0			; SAVE ERROR CODE
	MOVL	R8,R0			; GET ADDR. OF RECORD ALREADY ALLOCATED
	BSBW	SYM$DEARECORD		; DEALLOCATE IT
	POPR	#^M<R0>			; RESTORE ERROR CODE TO R0
	BRB	45$			; BR TO ERROR EXIT
25$:	SUBL3	R10,R2,SQR$L_XTRALNK(R8); LINK TO ORIGINAL RECORD
	CLRW	SQR$W_RECID(R2)		; CLEAR RECORD ID
	CLRL	SQR$L_XTRALNK(R2)	; CLEAR LINK WORD
	SUBL	#SYM_K_MAXQLEN,R3	; AMOUNT ALREADY MOVED
	MOVC3	R3,(R5),SQR$L_DATALOC(R2)	; MOVE REST OF NAME TO EXTRA
	MOVL	R1,R5			; SAVE ADDR OF NEXT BYTE IN MESSAGE
35$:	MOVZBL	#1,R0			; SET SUCCESS
45$:	RET				; RETURN

NOSPOOL:				; DON'T SPOOL LOG FILE
	SETBIT	SJH$V_NOSPOOL,-		; SET BIT IN
		SJH$L_GQNMFLG(R7)	; FLAGS WORD

; RSB missing here is intentional

KEEPLOG:				; DON'T DELETE LOG FILE
	SETBIT	SJH$V_NODELET,-		; SET BIT IN
		SJH$L_GQNMFLG(R7)	; FLAGS WORD
	RSB				; RETURN

NOKEEPLOG:
	CLRBIT	SJH$V_NODELET,-		; 
		SJH$L_GQNMFLG(R7)
	RSB

NOLOG:
	SETBIT	SJH$V_NOLOG,-
		SJH$L_GQNMFLG(R7)
	RSB

NOTIFY:					; INFORM USER OF JOB COMPLETION
	SETBIT	SJH$V_NOTIFY,-		; SET BIT IN
		SJH$B_FLAGS(R7)		; IN FLAGS BYTE
	RSB
NONOTFY:				; DON'T INFORM USER
	CLRBIT	SJH$V_NOTIFY,-		; CLEAR BIT IN
		SJH$B_FLAGS(R7)		; IN FLAGS BYTE
	RSB

JOBNAME:MOVZBL	(R5),R0			; GET LENGTH OF NAME STRING
	INCL	R0			; INCLUDE COUNT BYTE
	CMPL	R0,#JBC_NAM_LEN		; NAME TO LONG?
	BLEQ	5$			; BR IF NOT
	BRW	SYM_INVOPT		; BR TO ERROR ROUTINE
5$:	MOVC5	R0,(R5),#^A/ /,-	; MOVE NAME INTO
		#JBC_NAM_LEN,SJH$T_JOBNAME(R7) ; HEADER RECORD
	MOVL	R1,R5			; SET INPUT POINTER
	RSB				;
 
JOBPARM:BSBW	SYM$ALLRECORD		; ALLOCATE A RECORD FROM THE QUEUE
	BLBS	R0,5$			; BR IF RECORD AVALIABLE
	BRW	ERREXT			; BR TO ERROR ROUTINE
5$:	SUBL3	R10,R2,SJH$L_PARMBLK(R7) ; LINK THIS STRUCTURE TO JOB HEADER
	MOVL	R2,R4			; SAVE RECORD ADDR.
	MOVAB	SYM$K_RECSIZE-1(R2),R1	; FIND END OF RECORD
	ASSUME	SJH$L_NEXTJOB EQ SJH$W_QINDEX+2
	MOVAB	SJH$L_NEXTJOB(R2),R2	; SET OFFSET INTO RECORD TO BEGIN MOVE
10$:	MOVZBL	(R5)+,R0		; GET LENGTH OF STRING
	BEQL	30$			; BR WHEN DONE
	MOVB	R0,(R2)+		; STORE STRING COUNT
20$:	CMPL	R2,R1			; FILL UP THE RECORD
	BLSSU	25$			; BR IF BLOCK LEN. NOT EXCEEDED
	MOVL	R4,R0			; SET RECORD ADDR.
	BSBW	SYM$DEARECORD		; DEALLOCATE THE RECORD
	BRW	SYM_BLKEXD		; REPORT BLOCK EXCEEDED
25$:	MOVB	(R5)+,(R2)+		; COPY STRING
	SOBGTR	R0,20$			; MOVE ENTIRE STRING
	BRB	10$			; LOOP FOR NEXT STRING
30$:	RSB				; RETURN TO DISPATCHER
 
JOBPRI:	CMPB	(R5),SMR$B_PROCPRI(R9)	; CHECK IF TRYING TO RAISE PRIOITY
	BLEQU	10$			; BR IF NO-THAT IS ALWAYS ALLOWED
	BSBW	SYM$CKALTPRV		; SEE IF THE USER HAS PRIVILEGE
	BLBC	R0,ERREXT		; TAKE ERROR EXIT IF NO
10$:	MOVZBL	(R5)+,R0		; GET PRIOITY
	CMPB	R0,#SYM_K_PRTPRI	; VALID PRIORITY?
	BGTRU	SYM_INVOPT		; BR IF INVALID OPTION
	MOVB	R0,SJH$B_PRTPRI(R7)	; SET NEW PRIORITY
	RSB				; RETURN TO DISPATCHER

CPULIM:					; CPU TIME LIMIT SPECIFIED
	BISW	#SJH$M_CPULIM,SJH$W_QUOFLG(R7)	; SET OPTION PRESENT
	MOVL	(R5)+,SJH$L_CPULIM(R7)	; MOVE IN VALUE
	RSB				; RETURN TO DISPATCHER

NOCPULIM:				; NO CPU TIME LIMIT
	BICW	#SJH$M_CPULIM,SJH$W_QUOFLG(R7)	; SET NOT PRESENT
	CLRL	SJH$L_CPULIM(R7)	; CLEAR VALUE (SET TO INFINITE)
	RSB				; RETURN TO DISPATCHER

WRKSETQUO:				; WORKING SET QUOTA SPECIFIED
	BISW	#SJH$M_WSQUTA,SJH$W_QUOFLG(R7)	; SET OPTION PRESENT
	MOVW	(R5)+,SJH$W_WSQUTA(R7)	; MOVE IN VALUE
	RSB				; RETURN TO DISPATCHER

NOWRKSTQUO:				; NO WORKING SET QUOTA SPECIFIED
	BICW	#SJH$M_WSQUTA,SJH$W_QUOFLG(R7)	; SET NOT PRESENT
	CLRW	SJH$W_WSQUTA(R7)	; CLEAR VALUE
	RSB				; RETURN TO DISPATCHER

WRKSETDFT:				; WORKING SET DEFAULT SPECIFIED
	BISW	#SJH$M_WSDFLT,SJH$W_QUOFLG(R7)	; SET OPTION PRESENT
	MOVW	(R5)+,SJH$W_WSDFLT(R7)	; MOVE IN VALUE
	RSB				; RETURN TO DISPATCHER

NOWRKSETDF:				; NO WORK SET DEFAULT SPECIFIED
	BICW	#SJH$M_WSDFLT,SJH$W_QUOFLG(R7)	; SET NOT PRESENT
	CLRW	SJH$W_WSDFLT(R7)	; CLEAR VALUE
	RSB				; RETURN TO DISPATCHER

WSXTNT:					; WORKING SET EXTENT
	BISW	#SJH$M_WSXTNT,SJH$W_QUOFLG(R7)	; SET OPTION PRESENT
	MOVW	(R5)+,SJH$W_WSEXTNT(R7)	; MOVE IN VALUE
	RSB

NOWSXTNT:				; NO WORKING SET EXTENT
	BICW	#SJH$M_WSXTNT,SJH$W_QUOFLG(R7)	; SET NOT PRESENT
	CLRW	SJH$W_WSEXTNT(R7)	; CLEAR VALUE
	RSB

;
; SUBROUTINE TO GET THE NEXT OPTION CODE INTO R0
;
;	FIRST A CHECK IS MADE THAT R5 IS STILL POINTING
;	INSIDE THE VALID DATA AREA OF MESSAGE.  IF R5 IS BEYOND
;	THE END OF THE MESSAGE DATA, AN OPTION WAS SPECIFIED THAT
;	HAD AN INCORRECT PARAMETER OR NONE.
;
;	IF R5 IS EXACTLY AT THE END, SUCESSFUL STATUS IS SET AND
;	RETURN 2 LEVELS(IE: BACK TO REAL CALLER OF CONVERT OPTIONS)
;
SYM$GETOPT:				; GET NEXT OPTION BYTE
	CMPL	R5,-JCM_T_MSGDATA(R9)	; CHECK FOR BUFFER OVER RUN
	BGTRU	SYM_INVOPT		; SET ERROR
	MOVZBL	(R5)+,R0		; PICK UP OPTION BYTE
	BEQL	10$			; IF ITS ZERO THAT STOPS THE SHOW
	CMPL	R5,-JCM_T_MSGDATA(R9)	; CHECK AGAINST END OF DATA INDICATOR
	BLEQU	20$			; BR IF CODE IS VALID
10$:	TSTL	(SP)+			; CLEAR 1 LEVEL OF RETURN
	SETSTAT	NORMAL			; SET FINAL STATUS
20$:	RSB				; RETURN TO SOME PLACE
					; JOIN INVALID OPTION
;
; AN ILLEGAL OPTION HAS BEEN SPECIFIED
;
SYM_INVOPT:
	SETSTAT	SMINVOPT		; SET ERROR CAUSE
	BRB	ERREXT
SYM_BLKEXD:
	SETSTAT	PARLENEXD		; SET ERROR CAUSE
ERREXT:	TSTL	(SP)+			; CLEAR RETURN TO DISPATCHER
	RSB				; RETURN TO ORIGINAL CALLER

;
; SUBROUTINE TO LOCATE QUEUE NAME IN MESSAGE
;
;	INPUTS
;		R5  contains pointer to ascii counted string of queue name
;		R10 contains base address of queue file
;
;	OUTPUTS
;		R0 low bit set if queue is found, low bit clear otherwise
;		R1 contains the index to the queue if found
;
;
LOCATEQ:
	.WORD	^M<R2,R3,R4,R5,R6,R8>
	MOVZBL	(R5),R8			; GET LENGTH OF QUEUE NAME
	CMPB	(R8)[R5],#^A/:/		; NAME END WITH A COLON
	BNEQ	10$			; IF NEQ - THEN NO
	DECB	R8			; REMOVE COLON FROM NAME
10$:	SETSTAT	ILLDESQUE		; ASSUME ILLEGAL QUEUE NAME
	CMPB	R8,#<2*SYM_K_MAXQLEN>	; NAME TOO LONG?
	BGTRU	70$			; IF GTR - THEN YES
	MOVAL	<SQH$K_SIZE-SMQ$K_SIZE>(R10),R6 ; POINT R6 AT QUEUES
	MOVZBL	SQH$B_NUMQUE(R10),R4	; GET NUMBER OF QUEUES
	BEQL	40$			; IF EQL - THEN NO QUEUES
20$:	ADDL	#SMQ$K_SIZE,R6		; ADVANCE R6 TO QUEUE
	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),20$ ; BR IF QUEUE NOT IN USE
	CMPB	SMQ$T_NAME(R6),R8	; LENGTH OF NAME THE SAME?
	BNEQU	30$			; IF NEQ THEN NO - CAN'T MATCH
	CMPC3	R8,1(R5),SMQ$T_NAME+1(R6) ; COMPARE QUEUE NAMES
	BEQL	60$			; IF EQL - THEN NAMES MATCH
30$:	SOBGTR	R4,20$			; LOOK AT ALL QUEUES
40$:	SETSTAT	NODESTQUE		; SET ERROR CODE INTO R0
	BRB	70$			; RETURN
60$:	SUBL3	R10,R6,R1		; SET QINDEX INTO R1
	SETSTAT	NORMAL			; INDICATE QUEUE FOUND
70$:	RET

	.END
