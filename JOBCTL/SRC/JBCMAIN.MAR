	.TITLE	JBCMAIN-JOB_CONTROLLER MAIN ROUTINE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARLET JOB_CONTROLLER
;
; ABSTRACT:	THIS MODULE CONTAINS THE JOB_CONTROLLER
;		ROOT SEGMENT, PURE AND IMPURE DATA AREAS.
;
; ENVIRONMENT:	THIS MODULE MAKES UP PART OF THE JOB_CONTROLLER
;		SYSTEM PROCESS.
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 3-JAN-77
;
; MODIFIED BY:
;
;	V03-001	MLJ0082		Martin L. Jack,	15-Mar-1982  15:28
;		Start detached processes under [1,4], not [10,40].  Avoid
;		overwriting symbiont error status with success.
;
;	V02-014	MLJ0081		Martin L. Jack,	1-Mar-1982  16:32
;		Correct off-by-one in interactive job vector overflow test.
;
;	V02-013	MLJ43853	Martin L. Jack,	15-Feb-1982  14:09
;		If a job completion message is received from a symbiont that is
;		believed to be suspended, change its state to idle.  This case
;		arises when a suspend crosses in the mail with the completion
;		message.
;
;	V02-012	MLJ0076		Martin L. Jack,	6-Feb-1982  11:52
;		Force queue file update on every change.  Delete unreferenced
;		global symbols.
;
;	V02-011	MLJ0075		Martin L. Jack,	31-Jan-1982  23:37
;		Increase interactive job bit array to handle 1024 processes.
;
;	V02-010	MLJ0067		Martin L. Jack,	18-Jan-1982  17:57
;		Correct typo in message.
;
;	V02-009	GWF0144		Gary W. Fowler		10-Dec-1981
;		Add support for enforcing restricted log in hours.
;
;	V02-008	PHL0017		Peter H. Lipman		21-Sep-1981
;		Use concealed terminal name only if SYSGEN parameter
;		CONCEAL_DEVICES (EXE$V_CONCEALED in EXE$GL_FLAGS) is set.
;
;	V02-007	PHL0016		Peter H. Lipman		13-Sep-1981
;		When creating a process in response to unsolicited
;		input from a terminal, set INPUT, OUPUT, and ERROR
;		to be "__TTA0:" which tells RMS to hide the
;		device name.  A $CREATE for SYS$OUTPUT will return
;		SYS$OUTPUT: in the Result Name String instead of
;		_TTA0:.  The NAM$T_DVI field will have "__TTA0"
;
;	V02-006	SPF0023		Steve Forgey		28-Jul-1981
;		Add new accounting message type handling
; 01	- 
;
; 02	Gary Fowler		1-Nov-1979
;	Add call to routine to deallocate device when symbiont done
;	message is received.
;
; 03	Gary Fowler		29-Nov-1979
;	Add support for multiple symbiont types.
;
; 04	Gary Fowler		21-Mar-1980
;	Add R6 to register save mask in mailbox ast routine
;
; 05	Gary Fowler		2-Jul-1981
;	Change to add items to tail of work list
;
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; EQUATED SYMBOLS:
;
	$ACMDEF				; ACCOUNTING MESSAGE DEFINITIONS
	$MSGDEF				; SYSTEM WIDE MESSAGE CODES
	$STSDEF				; STATUS FIELD DEFINITIONS
	$PCBDEF				; PCB DEFINITIONS
	$IPLDEF				; IPL DEFINITIONS
	$JIBDEF				; JIB DEFINITIONS
	$SSDEF				; STATUS CODES
	$PSLDEF				; PSL DEFINITIONS
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCSCTDEF			; SYMBIONT CONTROL TABLE DEFINITIONS
	$SMQDEF				; DEFINE QUEUE HEADER OFFSETS
;
;
; OWN STORAGE:
;
	PURE_SECTION
 
JBC$Q_JBCNAM::				; THE NAME OF THE PROCESS
	STRING_DESC <JOB_CONTROL>
 
JBC$Q_LOGIN::				; NAME OF INITIAL IMAGE TO ACTIVATE
	STRING_DESC	<SYS$SYSTEM:LOGINOUT.EXE> ; INITIAL IMAGE TO EXECUTE
 
JBC$Q_INPSMB:				; CARD READER INPUT SYMBIONT
	STRING_DESC	<SYS$SYSTEM:INPSMB.EXE>	;
 
JBC$Q_PRIVMASK::	.LONG	-1,-1	; NEW PROCESS PRIVLEDGE MASK
 
JBC$Q_TICPERHR::
	.LONG	^X061C46800		; NO. OF TICKS PER HOUR
	.LONG	^X08
JBC$Q_NXTMINS:				; DELTA TIME OF 2 MINUTES
	.LONG	^X0B8797400
	.LONG	-1
;
; DEFINE PSECT TO BOUND ALL OF THE WRITABLE SECTIONS
;
	IMPURE_DATA	JBC$$RWDTOP
JBC$RWDTOP::				; START OF ALL READ/WRITE DATA
	IMPURE_DATA	JBC__RWDEND
JBC$RWDEND::				; END OF ALL WRITABLE DATA
;
; ALLOCATE SPACE FOR MESSAGE BUFFERS
; THESE BUFFERS ARE MAINTAINED IN A SEPARATE PROGRAM SECTION
; TO PERMIT AN EXTEND SECTION TO ADD BUFFER SPACE
;
	IMPURE_DATA	JBC$RWDMSGBFR	; READ/WRITE DATA-MESSAGE BUFFERS
 
JBC$T_MSGBUFR::				; SPACE FOR MESSAGE BUFFERS
 
	.BLKB	<JCM_K_SIZE*-		; SIZE OF BUFFER TIMES
		JBC_K_MAXBUFR>		; NUMBER TO ALLOCATE
 
	IMPURE_DATA	JBC$RWDMSGBFS	;
JBC$T_MBUFEND::				; END OF MESSAGE BUFFER SPACE
 
;
; ALLOCATE THE SYMBIONT CONTROL TABLES
; THESE TABLES ARE MAINTAINED IN A SPARATE PROGRAM SECITON
; TO PERMIT AN EXTEND SECTION TO ADD TABLE SPACE
;
	IMPURE_DATA	JBC$RWDSYMCTL
 
SYM$G_SYMCTLTBL::			; SYMBIONT CONTROL TABLE AREA
 
	.BLKB	<SYM_K_MAXSYMB-		; ALLOCATE A BLOCK FOR EVERY SYMBIONT
		* SCT_K_SIZE>		; BY THE SIZE OF THE BLOCK
 
	IMPURE_DATA	JBC$RWDSYMCTM	;
SYM$G_SYMCTLTBE::			; END OF TABLE SPACE
 
;
; DEFINE AREA FOR INTERACTIVE JOB BIT ARRAY
;
 
	IMPURE_DATA	JBC$RWDINTJOB	;
 
JBC$G_INTJOBFLG::			; INTERACTIVE JOB FLAG BIT ARRAY
	.BLKB	<1024/8>		; ALLOCATE ENOUGH FOR 1024 PROCESSES
 
	IMPURE_DATA	JBC$RWDINTJOC	;
JBC$G_INTJOBEND::			;
 
	IMPURE_DATA
 
;
; ALLOCATE THE JOB CONTROLLER'S DATA BLOCK
;
 
JBC$T_DATABLK == . + <JCD_T_INDEX0-JCD_T_START> ; FIND OFFSET TO INDEX ZERO IN BLOCK
 
	.BLKB	JCD_K_SIZE		; ALLOCATE SPACE FOR THE BLOCK
 
 
;
; AREA FOR PARAMETERS FROM CREATE/MAP GLOBAL SECTION FOR THE PRINT QUEUE
;
 
JBC$Q_INADR::	.BLKQ	1		; INPUT ADDRESS TO MAP SECTION
 
JBC$Q_RETADR::	.BLKQ	1		; RETURN ADDRESS FROM MAP SECTION
 
JBC$Q_UPDADR::	.BLKQ	1		; ADDRESSES UPDATED
 
JBC$Q_UPDIOSB::	.BLKQ	1		; IO STATUS FOR SECTION UPDATE

JBC$Q_NXTAST::	.BLKQ	1		; TIME FOR NEXT HOURLY AST
 
JBC$B_QUEWRT::	.BYTE	0		; FLAG FOR QUEUE UPDATING
JBC$B_SYMWAIT::	.BYTE	0		; COUNT OF NO. SYMBIONTS IN WAITLIST

;%%%%%
;	FOLLOWING LOCATIONS ASSUMED TO BE AJACENT

JOB_L_COUNT:
		.LONG	4		; ARGUMENT COUNT
JOB_L_PCBINDEX:
		.LONG	0		; INDEX INTO PCB VECTOR
JOB_L_HOUR:
		.LONG	0		; HOUR OF DAY
JOB_L_DAY:
		.LONG	0		; DAY OF WEEK
JOB_L_MODE:
		.LONG	0		; ACCESS MODE FOR AST

;%%%%%

JOB_L_SAVEMODE:
		.LONG	0		; SAVE ACCESS MODE FOR LOOP

JOB_L_POSSIBLE:
		.LONG	0
; 
; PROTOTYPE NAME FOR CONSTRUCTION OF MAILBOX RESPONCE DEVICE NAMES
;
 
JBC$T_MBOXNAME::
	.BYTE	0			; COUNT GOES HERE
	.ASCII	\_MB\			; NAME WITH "_"TO PREVENT SUBSTITUTION
JBC$T_MBOXUNIT::			; THE UNIT NUMBER GOES HERE
	.BLKB	5			; BIGGEST UNIT IS 65K

	.SBTTL	JOB_CONTROL INITIALIZATION
;++
; FUNCTIONAL DESCRIPTION:
;
;	JOB CONTROL MAIN LOOP IS ACTIVATED BY THE AST ROUTINE.
;	ALL OF THE POSSIBLE WORK LISTS ARE SCANNED TO DETERMIN
;	WHAT FUNCTIONS ARE TO BE DONE.  THE LIST ARE ORDERED BY
;	THEIR IMPORTANCE AND ARE ALWAYS CHECKED FROM THE TOP.
;
; CALLING SEQUENCE:
;
;	NONE-ENTERED DIRECTLY FROM THE INITIALIZATION ROUTINE.
;
; INPUT PARAMETERS:	NONE
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION			; START CODE SEGMENT
 
JBC$LOOP::				;
	BBCC	#JBC_V_CREJOBREQ,-	; BR IF CREATE DETCHED (BATCH)
		JCD_W_FLAGS(R11),20$	; JOB IS NOT REQUIRED
	BSBW	JBC$STADET		; TRY TO START ONE IF YES
	CLRB	W^JBC$B_QUEWRT		; Force queue file update
20$:	BBCC	#JBC_V_MBREADREQ,-	; BR IF THERE IS NO REQUIREMENT FOR
		JCD_W_FLAGS(R11),30$	; A MAILBOX READ
	BSBW	JBC$READMB		; ELSE ISSUE A READ REQUEST
30$:	BBCC	#JBC_V_SYMINIREQ,-	; CHECK IF SYMBIONT SERVICE FLAG IS
		JCD_W_FLAGS(R11),40$	; SET AND CLEAR IT,BR IF NO
	MOVZBL	JBC$B_SYMWAIT,-(SP)	; SAVE COUNT OF NO. IN LIST
31$:	DECL	(SP)			; DECR. COUNT
	BLSS	35$			; BR IF LOOKED AT ALL OF THEM
	REMQUE	@JCD_Q_SYMBWAIT(R11),R2	; GET SYMBIONT THAT IS WAITING
	BVS	35$			; BR IF NONE WAITING
	DECB	JBC$B_SYMWAIT		; DECR. NO. OF SYMBIONTS WAITING
	BSBW	JBC$SYMBSERV		; GO SERVICE SYMBIONT
	BRB	31$			; GO SEE IF ANOTHER
35$:	ADDL	#4,SP			; REMOVE COUNTER FROM STACK
40$:	BBCC	#JBC_V_MBREADREQ,-	; CHECK FOR AN OUTSTANDING NEED FOR
		JCD_W_FLAGS(R11),50$	; A MAIL BOX READ
	BSBW	JBC$READMB		; READ THE MAILBOX
50$:	BBCC	#JBC_V_SRVCKLOGIN,-	; CHECK IF TIME TO CHECK LOGIN
		JCD_W_FLAGS(R11),60$	; FLAGS FOR JOBS
	BSBW	SYM$HOURLY		; GO CHECK
60$:	BBSS	#0,W^JBC$B_QUEWRT,70$	; Br if not time to write the queue
	BSBW	JBC$VFYUPDQUE		; VERIFY AND UPDATE THE QUEUE
70$:					; 
 
	.ENABL	LSB
 
	$HIBER_S			; SLEEP
 
;
; SCAN WORK LISTS FOR SOMETHING TO DO
;
 
10$:	$GETTIM_S  JCD_Q_TIME(R11)	; GET THE TIME OF DAY
	BBCC	#JBC_V_SRVTIMQUE,JCD_W_FLAGS(R11),15$ ; BR IF NO TIME WORK
	BSBW	SYM$SRVTIMER		; REMOVE TIME ENTRIES
	CLRB	W^JBC$B_QUEWRT		; Force queue file update
15$:	CLRL	R0			; SET INDEX FOR FIRST WORK LIST
20$:	MOVAQ	JCD_G_WORKLIST(R11)[R0],R1 ; FIND ADDRESS OF QUEUE
	REMQUE	@(R1)+,R2		; REMOVE ITEM FROM LIST
	BVC	30$			; BR IF REMOVED SOMETHING
	INCL	R0			; NOTHING IN QUEUE-ADD 1 TO INDEX
	CMPL	R0,S^#<<JCD_G_WLEND-JCD_G_WORKLIST>/8> ; CHECK AGAINST LIMIT
	BLSSU	20$			; BR IF MORE TO CHECK
	BRW	JBC$LOOP		; WAIT SOME MORE
 
;
; ITEM REMOVED FROM WORK LIST-CALL ASSOCIATED ROUTINE
;
 
30$:	MOVZWL	JCM_Q_IOSB+2(R2),(R2)	; SET LENGTH OF TRANSFER
	ADDL	#JCM_T_MSGDATA,(R2)	; FIND END OF VALID DATA
	ADDL	R2,(R2)			; THAT POINTS AT END OF RECORD
	CLRL	4(R2)			; ZERO RETURNED ARGUMENT
	MOVL	JCD_A_QUEBASE(R11),R10	; SET BASE ADDRESS OF SYSTEM QUEUE
	BSBB	40$			; SET SUBROUTINE RETURN FOR CASE
	BRB	10$			; LOOP FROM THE TOP
40$:	CASE	R0,<-
		JBC$SYMBSERV,-		; SYMBIONT SERVICE REQUIRED
		JBC$SYMBMAN,-		; MESSAGE FOR SYMBIONT MANAGER
		JBC$PRCDEL,-		; PROCESS/IMAGE DELETE/PURGE MESSAGES
		JBC$SNDACC,-		; MESSAGE FOR ACCOUNTING MANAGER
		JBC$SYSFUN,-		; SYSTEM FUNCTION
	>
 
	.DSABL	LSB

;+
; SYMBIONT AND ACCOUNTING MANAGER DISPATCHER
;
; THIS ROUTINE PERFORMS THE COMMON PROCESSING FOR THE SEND SERVICE
; PROCESSING AND RESPONCE.  THIS INCLUDES  ASSIGNING THE RESPONCE
; MAILBOX, THEN SENDING THE RESPONCE WHEN PROCESSING IS DONE.
;-
	.ENABL	LSB
JBC$SYSFUN:				; SYSTEM FUNCTION MESSAGE
	PUSHAB	W^ACM$SYSFUN		; ENTRY TO ACCOUNTING MANAGER
	BRB	10$
JBC$SNDACC:				; ACCOUNTING MANAGER REQUEST
	PUSHAB	W^ACM$SNDACC		; ENTRY TO ACCOUNTING MANAGER
	BRB	10$			;
 
JBC$SYMBMAN:				; SYMBIONT MANAGER SEVICE
	PUSHAB	W^SYM$SYMBMAN		; ENTRY TO SYMBIONT MANAGER
	CLRB	W^JBC$B_QUEWRT		; Force queue file update
10$:	ADDL3	#JCM_T_MSGDATA,R2,R9	; POINT R9 AT MESSAGE DATA
	ASSUME	ACM$W_MAILBOX EQ SMR$W_MAILBOX
	MOVZWL	SMR$W_MAILBOX(R9),R0	; GET MAIL BOX UNIT
	BEQL	20$			; BR IF NONE HERE
	MOVAW	JCD_W_TMPCHAN(R11),R1	; CHANNEL RETURN ADDRESS
	BSBW	JBC$ASSIGNMB		; ASSIGN THE MAILBOX
20$:	JSB	@(SP)+			; ENTER PROPER MANAGER
	BLBS	R0,30$			; BR IF STATUS IS GOOD
	MNEGL	R0,R1			; INVERT ERROR CODE
	BLSS	40$			; BR IF ERROR FROM THE SYSTEM
	ASHL	#2,R1,R0		; SET REAL ERROR MESSAGE CODE
	BISW	#<STS$M_FAC_SP!-	; SET FACILITY SPECIFIC AND-
		STS$K_ERROR>,R0		; AND "ERROR" SEVERITY INTO VALUE
30$:	INSV	#<JBC$_NORMAL@-STS$V_FAC_NO>,- ; AND JOBCTL FACILITY CODE
		#STS$V_FAC_NO,#STS$S_FAC_NO,R0 ; INTO RETURN VALUE
40$:	MOVAB	@JCD_A_LBUFADR(R11),R3	; SET POINTER TO RESPONCE MESSAGE BUFFER
	MOVW	R2,(R3)+		; STORE MESSAGE TYPE
	MOVW	-<JCM_T_MSGDATA-4>(R9),(R3)+ ; STORE RESPONCE DATA
	MOVL	R0,(R3)+		; SET FINAL STATUS
	INSQUE	-JCM_T_MSGDATA(R9),-	; RELEASE MESSAGE BUFFER TO
		@JCD_Q_FREEBUFR+4(R11)	; END OF THE FREE MESSAGE BUFFER LIST
	TSTW	JCD_W_TMPCHAN(R11)	; ANY RESPONCE MAILBOX?
	BEQL	50$			; BR IF NO - DON'T SEND RESPONCE
	BSBB	JBC$SNDRESP		; SEND RESPONCE TO REQUESTOR
	$DASSGN_S JCD_W_TMPCHAN(R11)	; RELEASE THE CHANNEL
	CHECK_ERROR	DASSGN_MB	; WATCH FOR ERROR DEASSIGNING MAILBOX
	CLRW	JCD_W_TMPCHAN(R11)	; CLEAR CHANNEL NUMBER FOR NEXT TIME
50$:	RSB				; RETURN TO DISPATCHER
 
	.DSABL	LSB			;

 
;+
; JBC$SNDRESP - SEND RESPONCE
;
; 	THIS SUBROUTINE IS CALLED TO SEND A MESSAGE TO THE REQUESTING
;	PROCESS VIA THE SUPPLIED MAILBOX.
;
; INPUTS:	R3 IS END OF MESSAGE IN JBC LINE BUFFER
;
;-
 
JBC$SNDRESP::				;
	SUBL3	JCD_A_LBUFADR(R11),R3,R1 ; FIND LENGTH
	$QIO_S	EFN = #0,-		; WRITE MAILBOX, EVENT FLAG IS 0
		CHAN = JCD_W_TMPCHAN(R11),-; CHANNEL NUMBER
		FUNC = #<IO$_WRITEVBLK!IO$M_NOW>,- ; OPERATION IS WRITE-NOW!
		P1 = @JCD_A_LBUFADR(R11),- ; BUFFER ADDRESS
		P2 = R1			; LENGTH
	RSB				;

	.SBTTL	READ MAILBOX
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ISSUE A READ ON
;	THE SYSTEM PERMANENT MAILBOX USED FOR
;	COMMUNICTION TO THE JOB CONTROLLER.
;
; CALLING SEQUENCE:
;
;	BSB	JBC$READMB
;
; INPUT PARAMETERS:
;
;	LOCATION "JBC$Q_FREEBUFR" CONTAINS A LIST
;	OF BUFFERS AVAILIABLE FOR READING THE
;	MAILBOX.
;
; OUTPUT PARAMETERS:
;
;	BUFFER IS ALLOCATED AND READ IS ISSUED
;	IF BUFFER ALLOCATION FAILS, FLAG IS SET
;	SO THAT READ CAN BE RE-ATTEMPTED AT SOME
;	LATER TIME.
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;
;--

JBC$READMB::				; READ JOB CONTROLLER'S MAIL BOX
	REMQUE	@JCD_Q_FREEBUFR(R11),R2	; ALLOCATE A BUFFER FOR READ
	BVS	90$			; BR IF ALLOCATION FAILED
	$QIO_S	#0,-			; EVENTFLAG IS 0
		JCD_W_MBCHAN(R11),-	; CHANNEL IS MAILBOX
		#IO$_READVBLK,-		; FUNCTION IS READ
		JCM_Q_IOSB(R2),-	; IO STATUS BLOCK IN PACKET
		W^JBC$MBAST,-		; ADDRESS OF AST ROUTINE
		R2,-			; AST PARM IS MESSAGE PACKET
		JCM_T_MSGDATA(R2),-	; BUFFER AREA OF PACKER
		#JCM_K_SIZE-JCM_T_MSGDATA ; SIZE OF MESSAGE DATA AREA
	BLBS	R0,99$			; BR IF OPERATION A SUCCESS
	INSQUE	(R2),@JCD_Q_FREEBUFR+4(R11) ; REALLOCATE THE BUFFER FOR LATER
	SHOW_ERROR  MAILBOX_READ	; REPORT ERROR
90$:	SETBIT	JBC_V_MBREADREQ,-	; SET FLAG TO INDICATE READ NEEDS
		JCD_W_FLAGS(R11)	; TO BE ISSUED
99$:	RSB				; ALL DONE


	.SBTTL	JBC MAILBOX READ AST
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN A MESSAGE HAS BEEN
;	DELIVERED THRU THE JOB CONTROLLERS MAILBOX.
;	THE AST PARAMETER IS THE ADDRESS OF THE JOB CONTROLLER
;	MESSAGE BUFFER, THAT IS THE ADDRESS OF THE QWAD WORD LIST
;	HEADER, WHICH IS FOLLOWED BY A QUAD WORD I/O STATUS BLOCK.
;	THIS IS THEN FOLLOWED BY THE DATA.  IN ALL CASES THE FIRST
;	WORD IN THE DATA IS MESSAGE TYPE IDENTIFIER FOLLOWED BY
;	THE ACTUAL DATA ASSOCIATED WITH THE MESSAGE.
;	THIS ROUTINE ENTERS A SPECFIC ROUTINE DEPENDING ON THE
;	THE MESSAGE TYPE.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS ENTERED FROM THE SYSTEM AST
;	DELIVERY ROUTINE USING THE CALLG INSTRUCTION.
;
; INPUT PARAMETERS:
;
;	AN ARQUMENT BLOCK WITH THE FIRST ARGUMENT THE
;	ADDRESS OF THE MESSAGE BUFFER INTO WHICH THE
;	MESSAGE HAS BEEN DELIVERED.
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--

JBC$MBAST:				; AST ENTRY POINT
	.WORD	^M<R2,R3,R4,R5,R6,R11>	; REGISTER SAVE MASK
	MOVAB	W^JBC$T_DATABLK,R11	; SET WORKING DATA BLOCK ADDRESS
	MOVL	4(AP),R5		; GET MESSAGE PACKET ADDRESS
	MOVZWL	JCM_Q_IOSB+2(R5),R4	; PICK UP MESSAGE BYTE COUNT
	ADDL	#JCM_T_MSGDATA,R5	; POINT REGISTER AT DATA AREA
	CVTWL	(R5)+,R0		; GET MESSAGE TYPE FROM PACKET
	PUSHAL	B^100$			; SET RETURN FROM MESSAGE PROCESSING ROUTINE
	CASE	R0,-			; DECODE MESSAGE TYPE
		LIMIT = #MSG$_TRMUNSOLIC,-;BASE VALUE FOR CASE
		<JBC$TTUNSOLIN,-	; TERMINAL UNSOLICTED DATA
		JBC$CRUNSOLIN,-		; CARD READER UNSOLICTED INPUT
		JBC$DELETPRC,-		; DELETE PROCESS
		JBC$SNDSYMAN,-		; SEND TO SYMBIONT MANAGER
		10$,-			; RESERVED CODE
		10$,-			; RESERVED CODE
		10$,-			; RESERVED CODE
		JBC$SYMBINIT,-		; SYMBIONT INIT COMPLETE
		JBC$SYMBDONE,-		; SYMBIONT HAS COMPLETED JOB
		JBC$SNDACMAN,-		; SEND MESSAGE TO ACCOUNTING MANAGER
		JBC$PURGEPRC,-		; PURGE PROCESS
		JBC$DELETIMG,-		; DELETE IMAGE
		JBC$PURGEIMG,-		; PURGE IMAGE
		JBC$SYSFUNC,-		; SYSTEM FUNCTION
	>
10$:	SHOW_ERROR	INVALID_MESG	; BAD MESSAGE RECEIVED
	BRB	110$			; DEALLOCATE THE MESSAGE BUFFER
100$:	BLBC	R0,120$			; BR IF MESSAGE BUFFER STILL IN USE
110$:	INSQUE	@4(AP),@JCD_Q_FREEBUFR+4(R11) ; RELEASE CURRENT BUFFER IF FREE
120$:	BSBW	JBC$READMB		; RESTART I/O ON MAILBOX
	RET				; DISMISS AST
 
;
; MESSAGE IS SYMBIONT DONE
;
;	ADJUST STATE FOR SYMBIONT TO READY FOR NEXT FILE
;	INSERT ITS TABLE IN SEVICE LIST
;	SET THE MAIN LINE SYNC FLAG
;
JBC$SYMBDONE:				; SYMBIONT IS COMPLETE
	PUSHL	R5			; SAVE MESSAGE BUFFER ADDRESS
	MOVL	<JCM_Q_IOSB+4-<JCM_T_MSGDATA+2>>(R5),R1 ; GET SENDER'S ID
	BSBW	SYM$FINDSYMCTL		; LOCATE THE SYMBIONT CONTROL TABLE
	POPR	#^M<R1>			; POP BUFFER ADDRESS TO WORK REGISTER
	CMPB	#SCT_K_SUSPND,SCT_B_STATE(R5) ; Suspend issued?
	BNEQ	5$			; Br if no
	MOVB	#SCT_K_DEQFIL,SCT_B_STATE(R5) ; Mark as idle
5$:	MOVZWL	(R1)+,R0		; Pick up job status
	BLBS	R0,6$			; Br if successful
	MOVW	R0,SCT_W_JOBSTAT(R5)	; Save error status for mainline
6$:	ADDL	(R1)+,SCT_L_GETCNT(R5)	; ACCUMULATE ACCOUNTING
	ADDL	(R1)+,SCT_L_QIOCNT(R5)	; INFORMATION ON GET'S ,QIO'S
	MOVZWL	(R1)+,R0		; GET PAGES AS A LONG WORD
	ADDL	R0,SCT_L_PAGCNT(R5)	; AND ACCOUNT FOR PAGES

	MOVZWL	SCT_W_QINDEX(R5),R6	; POINT R6 AT QUEUE HEADER
	ADDL	JBC$Q_RETADR,R6			; GET ACTUAL ADDR
	BBC	#SMQ$V_STOPPED,SMQ$B_FLAGS(R6),10$	; BR QUE NOT STOPPED
	CLRL	R0			; SET TO DEALLOCATE DEVICE
	BSBW	SYM$ALLODEAL		; GO DEALLOCATE DEVICE
10$:	BRB	SYMBEXIT		; EXIT SYMBIONT SERVICE AST
;
; MESSAGE IS A SYMBIONT HAS INITED.
;	SAVE THE MAILBOX UNIT IN THE SYMBIONT CONTROL TABLE
;	AND INSERT TABLE IN SYMBIONT SERVICE LIST
;	SET THE SYNCRONIZING EVENT FLAG TO GET THE MAIN STARTED.
;
JBC$SYMBINIT:				;
	PUSHL	(R5)			; SAVE MAILBOX UNIT NUMBER
	MOVL	<JCM_Q_IOSB+4-<JCM_T_MSGDATA+2>>(R5),R1 ; PICK UP SENDER ID
	BSBW	SYM$FINDSYMCTL		; LOOK FOR SYMBIONT CONTROL TABLE
	CVTLW	(SP)+,SCT_W_MBCHAN(R5)	; STORE MAILBOX UNIT IN CONTROL TABLE
SYMBEXIT:				; COMMON EXIT FOR SYMBIONT SERVICE
	INSQUE	(R5),@JCD_Q_SYMBSRV+4(R11) ; PUT THIS SYMBIONT IN SERVICE QUEUE
	PUSHL	#1			; SET STATUS TO AST DISPATCHER
	BRB	JBC$SYNCMAIN		; SYNCRONIZE WITH MAINLINE
 
;******************************************************************************
;
;	INSERT MESSAGES IN THE PROPER QUEUE
;	AND SET THE SYNCRONIZING FLAG FOR THE MAIN LINE
;	THIS MESSAGE IS PROCESSED AT THAT LEVEL
;
;******************************************************************************
 
JBC$SNDACMAN:				; SEND MESSAGE TO ACCOUNTING MANAGER
	MOVAQ	JCD_Q_ACNTFIL(R11),R0	; GET ADDRESS OF PROPER QUEUE
	BRB	JBC$INSWORKLIST		; INSERT IN WORK LIST AND START THE MAIN
 
JBC$SNDSYMAN:				; MESSAGE IS FOR THE SYMBIONT MANAGER
	MOVAQ	JCD_Q_SYMBMAN(R11),R0	; SET PROPER LIST HEADER
	BRB	JBC$INSWORKLIST		; INSERT THIS IN WORK LIST

JBC$SYSFUNC:				; SYSTEM FUNCTION HAS OCCURRED
	MOVAQ	JCD_Q_SYSFUNC(R11),R0	; SET PROPER LIST HEADER
	BRB	JBC$INSWORKLIST		; INSERT THIS IN WORK LIST

JBC$PURGEIMG:				; IMAGE PURGE HAS OCCURRED
JBC$DELETIMG:				; IMAGE DELETE HAS OCCURRED
JBC$PURGEPRC:				; PROCESS PURGE HAS OCCURRED
JBC$DELETPRC:				; PROCESS DELETE HAS OCCURRED
	MOVAQ	JCD_Q_PROCDEL(R11),R0	; SET LIST ADDRESS
	BRB	JBC$INSWORKLIST		; INSERT THIS IN WORK LIST

;
; INSERT IN WORK LIST
;	
JBC$INSWORKLIST:			;
	PUSHL	#0			; GET RETURN STATUS FLAG
	INSQUE	@4(AP),@4(R0)		; INSERT RECORD IN LIST
JBC$SYNCMAIN:				; SET MAIN-LINE SYNC FLAG
	$WAKE_S				; WAKE UP THE MAINLINE LOOP
	POPR	#^M<R0>			; GET RETURN STATUS
	RSB				; RETURN TO AST DISPATCHER

	.PAGE
	.SBTTL	TERMINAL/CARD_READER UNSOLICTED DATA
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTER BY THE AST DISPATCHER WHEN THE
;	MESSAGE RECEIVED INDICATES THAT UNSOLICTED INPUT HAS
;	BEEN RECEIVED FROM A UN-ASSIGNED UNIT RECORD DEVICE.  THIS 
;	ROUTINE ISSUES A REQUEST TO CREATE A PROCESS WITH ITS
;	DEVICES "INPUT" AND "OUTPUT" ASSIGNED TO THE ASSOCIATED
;	DEVICE. IN ORDER TO PERFORM THIS, THE DEVICE NAME STRING
;	IN THE MESSAGE BUFFER.  THE FIRST 2 LONGWORDS (LIST LINKS)
;	ARE USED TO CREATE THE STRING DESCRIPTOR, AND NAME STRING
;	IS BUILT USING THE CONTROLLER NAME AS IS AND ADDING
;	THE UNIT NUMBER ON THE END, CONVERTING FROM BINARY TO
;	ASCII.
;
; CALLING SEQUENCE:
;
;	BSB	JBC$TTUNSOLIN		; FOR TERMINALS
;	BSB	JBC$CRUNSOLIN		; FOR CARD READRERS
;
; INPUT PARAMETERS:
;
;	R5 POINTS BEYOND THE MESSAGE TYPE CODE IN THE MESSAGE BUFFER.
;	THAT IS, POINTS AT A WORD CONTAINING THE BINARY UNIT NUMBER
;	FOR THE TERMINAL. THIS IS FOLLOWED BY THE CONTROLLER NAME
;	AS A COUNTED ASCII STRING.
;
; IMPLICIT INPUTS:
;
;	REGISTERED R0 TO R5 HAVE BEEN SAVED AND MAY BE
;	USED AS NEEDED BY THIS ROUTINE.
;
; OUTPUT PARAMETERS:
;
;	R0 IS RETURNED TRUE TO INDICATE BUFFER IS FREE
;	AND, THEREFORE, MAY BE REUSED.
;
; IMPLICIT OUTPUTS:
;
;	A PROCESS IS CREATED RUNNING THE LOGIN OR THE INPUT SYMBIONT IMAGE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;
;--
	.ENABL	LSB

JBC$TTUNSOLIN:				; TERMINAL UNSOLICETED INPUT
	MOVAQ	W^JBC$Q_LOGIN,R3	; SET IMAGE NAME TO START
	EXTZV	S^#EXE$V_CONCEALED,#1,-	; USE "CONCEALED DEVICE NAME" FLAG
		G^EXE$GL_FLAGS,R4	;
	BSBB	PROCRE			; PERFORM A PROCESS CREATE
	BLBC	R0,50$			; BR IF COULDN'T CREATE ONE
	MOVZWL	R1,R0			; GET PROCESS INDEX
	CMPW	R0,#<JBC$G_INTJOBEND-JBC$G_INTJOBFLG>*8 ; INDEX WITHIN BIT ARRAY
	BGEQU	50$			; IF NO - DON'T COUNT INTERACTIVE JOB
	BBSS	R0,W^JBC$G_INTJOBFLG,50$; SET FLAG AND BR IF SET, DON,T BUMP CNT
	$CMKRNL_S B^20$			; ADD 1 TO COUNT OF INTERACTIVE JOBS
	BRB	50$			;
20$:	.WORD	0			; KERNAL ACCESS MODE ENTRY MASK
	INCW	@#SYS$GW_IJOBCNT	; COUNT NUMBER OF INTERACTIVE JOBS
	RET				;
 
JBC$CRUNSOLIN:				; CARD READER UNSOLICETED INPUT
	MOVAQ	JBC$Q_INPSMB,R3		; SET ADDRESS OF IMAGE TO ACTIVATE FIRST
	CLRL	R4			; DON'T USE CONCEALED DEVICE FOR CR
	BSBB	PROCRE			; CREATE THE PROCESS
50$:	MOVL	#1,R0			; SET RELASE THE BUFFER FLAG
	RSB				; RETURN TO AST DISPATCHER
 
	.DSABL	LSB
	.PAGE
 
;
; LOCAL SUBROUTINE TO CREATE A PROCESS FOR UNSOLICITED INPUT
;
; INPUTS:
;
;	R3 = DESCRIPTOR FOR PROCESS NAME
;	R4 = 1 IF INPUT, OUTPUT, AND ERROR ARE SUPPOSED TO BE
;		CONCEALED DEVICE NAMES LIKE "__TTA0:"
;	   = 0 IF NOT USING CONCEALED DEVICE NAMES.
;
 
PROCRE:	MOVZWL	(R5)+,R0		; PICK UP BINARY UNIT NUMBER
	MOVZBL	(R5)+,R2		; GET LENGTH OF CONTROLLER NAME
	ADDL	R5,R2			; ADDRESS OF END OF CONTROLLER NAME
	BSBW	JBC$BIN2ASC		; CONVERT UNIT TO ASCII
	MOVB	#^A/:/,(R2)+		; TERMINATE DEVICE NAME WITH COLON
	MOVB	#^A/_/,-(R5)		; PUT UNDERSCORE AS FIRST CHAR IN NAME
	PUSHAB	(R5)			; PUSH ADR OF "_" NAME
	SUBL3	R5,R2,-(SP)		; LENGTH OF "_" NAME
	MOVB	#^A/_/,-(R5)		; PUT SECOND "_" ON FRONT
	PUSHAB	(R5)			; PUSH ADR OF "__" NAME
	SUBL3	R5,R2,-(SP)		; LENGTH OF "__" NAME
	PUSHL	R4			; 1 IF USING CONCEALED DEVICE FOR INPUT
					; OUTPUT AND ERRROR, 0 IF NOT
;
; 0(SP)  = CONCEALED DEVICE FLAG
; 4(SP)  = DESCRIPTOR FOR "__" NAME, CONCEALED DEVICE NAME
; 12(SP) = DESCRIPTOR FOR "_" NAME, PROCESS NAME
;
	MOVAL	12(SP),R5		; ADDRESS OF PROCESS NAME DESCRIPTOR
	MOVL	R5,R4			; ASSUME NOT USING CONCEALED DEVICE NAME
	BLBC	(SP),10$		; BRANCH IF NOT USING CONCEALED DEV NAMES
	MOVAL	4(SP),R4		; GET CONCEALED DEVICE NAME DESCRIPTOR
;
; 0(SP) IS AN UNITITIALIZED SCRATCH LONG WORD
;
10$:	MOVAL	(SP),R0			; GET THE ADDRESS OF SCRATCH CELL
	MOVZBL	@#SYS$GB_DEFPRI,R1	; SET SYSTEM DEFINED PRIORITY
	$CREPRC_S	-		; CREATE A PROCESS
		INPUT=	(R4),-		; DEIVICE INPUT IS TERMINAL
		OUTPUT=	(R4),-		; LIKEWISE FOR THE DEVICE OUTPUT
		ERROR=	(R4),-		; AND ALSO DEVICE ERROR
		BASPRI=	R1,-		; INITIAL PRIORITY OF JOB
		PIDADR= (R0),-		; PLACE TO STORE PROCESS ID
		PRCNAM=	(R5),-		; ESTABLISH PROCESS NAME SAME AS DEVICE
		IMAGE=	(R3),-		; IMAGE TO RUN
		PRVADR=	W^JBC$Q_PRIVMASK,-; PROCESS DEFAULT PRIVILEGE
		UIC=#<1@16+4>		; UIC IS [1,4]
	BLBS	R0,60$			; BR IF ALL IS OK
	CLRL	R5			; ASSUME DUPLICATE PROCESS NAME
	CMPW	R0,#SS$_DUPLNAM		; IS ERROR DUPLICATE NAME
	BEQL	10$			; BR IF YES, TRY TO CREATE WITH NO NAME
	SHOW_ERROR	CREATE_PROC	; REPORT THE ERROR
	MOVAB	(SP),R2			; GET ADDRESS OF SCRATCH WORD
	$ASSIGN_S (R4),(R2)		; ASSIGN A CHANNEL TO THE DEVICE
	BLBC	R0,60$			; BR IF THIS FAILED
	$QIO_S	CHAN=(R2),-		; WRITE MESSAGE TO TERMINAL
		FUNC=#IO$_WRITEVBLK,-	; WRITE THE DATA
		ASTADR=B^TTMSGAST,-	; AST WHEN WRITE IS DONE
		ASTPRM=(R2),-		; CHANNEL NUMBER IS AST PARAMETER
		P1=B^100$,-		; ADDRESS OF MESSAGE STRING
		P2=S^#<110$-100$>,-	; LENGTH OF MESSAGE
		P4=#32			; NORMAL CARRAIGE CONTROL
	BLBS	R0,50$			; BR IF QIO WAS ACCEPTED
	$DASSGN_S (R2)			; ELSE DEASSIGN TO RE-ENABLE UNSOL INPUT
50$:	CLRL	R0			; R0=LBC=PROCESS CREATE ERROR
60$:	POPR	#^M<R1>			; CLEAR SCRATCH WORD OR GET PROCESS ID
	ADDL	#16,SP			; CLEAN OFF TWO STRING DESCRIPTORS
	RSB				;
 
100$:	.ASCII	\%JBC-W-PRCREAT, process create error\
110$:
 
TTMSGAST:
	.WORD	0			; AST ENTRY POINT
	$DASSGN_S 4(AP)			; DEASSIGN THE CHANNEL
	RET				;

;
; LOCAL ROUTINE TO HANDLE HOURLY AST PROCESSING
;
SYM$HOURLY:
	CLRL	JOB_L_POSSIBLE		; CLEAR COUNT OF POSSIBLE PROCESSES
	MOVZBL	#2,JOB_L_PCBINDEX	; SET INDEX IN PCB VECTOR
10$:	MOVL	JOB_L_SAVEMODE,-	; SET ACCESS MODE
		JOB_L_MODE		; FOR AST DELIVERY
	$CMKRNL_S	-		; CALL KERNEL ROUT. TO CHECK A PROCESS
		ROUTIN=CHK_HRDAY_BITS,-	; ADDRESS OF ROUTINE
		ARGLST=JOB_L_COUNT	; ADDRESS OF ARGUEMENT LIST
	BLBC	R0,60$			; IF LBC THEN CONTINUE
	INCL	JOB_L_POSSIBLE		; INCREMENT COUNT
60$:	AOBLEQ	G^SCH$GL_MAXPIX,-
		JOB_L_PCBINDEX,10$	; LOOP THRU ALL
	TSTL	JOB_L_POSSIBLE		; FIND ANY TO BE DELETED?
	BEQL	100$			; IF EQL THEN NO
	DECL	JOB_L_SAVEMODE		; DECREMENT AST ACCESS MODE
	BLSS	100$			; IF LSS THEN DONE THEM ALL

	$SETIMR_S	-		; SET TIMER FOR CHECK IN A FEW MINUTES
		ASTADR=SYM$CHKLOGINS,-	; AST ADDRESS
		DAYTIM=JBC$Q_NXTMINS,-	; N MINUTES LATER
		REQIDT=#JBC_K_MINUTES	; INDICATE NOT AN HOURLY AST
100$:	RSB				; RETURN



	.SBTTL	TIMER AST ROUTINE FOR ENFORCING HOURLY LOGIN RESTRICTIONS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED AS A RESULT OF A TIMER AST INDICATING IT IS
;	TIME TO CHECK FOR PROCESSES BEING LOGGED IN AT A RESTRICTED HOUR.
;	IT IS ENTERED EVERY HOUR ON THE HOUR TO BEGIN THE CHECK.  IF THE
;	CHECK PERFORMED ON THE HOUR INDICATES DELETION OF A PROCESS, THIS
;	ROUTINE IS THEN ENTERED EVERY N MINUTES TO INITIATE AST DELIVERY TO
;	THE PROCESSES IN EACH OF THE 4 ACCESS MODES.
;
;	IF IT IS AN HOURLY AST, THIS ROUTINE OBTAINS THE HOUR NUMBER AND THE
;	DAY NUMBER.  IT CALCULATES THE TIME FOR THE NEXT HOURLY AST AND ISSUES
;	A SET TIMER REQUEST FOR THAT TIME.  IT SETS A BIT INDICATING TO THE
;	MAINLINE CODE THAT IT IS TIME TO PERFORM A CHECK.  IT THEN SETS THE
;	INITIAL ACCESS MODE TO 3 (USER MODE) AND ISSUES A WAKE TO START THE
;	MAINLINE CODE.	
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS ENTERED FROM THE SYSTEM AST DELIVERY MECHANISM
;
; INPUT PARAMETERS:
;
;	4(AP)	AST PARAMETER
;		= JBC_K_HOURLY	indicates AST delivered on the hour
;		= JBC_K_MINUTES	indicates secondary AST
;
; OUTPUT PARAMETERS:
;
;	JOB_L_SAVEMODE is set to 3 indicating user mode AST delivered first
;	JOB_L_DAY      is set to day number
;	JOB_L_HOUR     is set to hour number
;	JBC$Q_NXTAST   is set to time for next hourly AST
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:
;
;	SET TIMER REQUEST SET FOR NEXT HOUR
;	WAKE ISSUED FOR MAINLINE
;--
 
	.ENTRY	SYM$CHKLOGINS,^M<>
	CMPL	4(AP),#JBC_K_HOURLY	; IS IT THE HOURLY AST?
	BNEQ	100$			; IF NEQ THEN NO
	PUSHAB	JOB_L_DAY		; ADDR TO GET DAY NUMBER
	CLRL	-(SP)			; 0 TO INDICATE USE CURRENT TIME
	CALLS	#2,LIB$DAY_OF_WEEK	; GET DAY NUMBER
	PUSHAB	JOB_L_HOUR		; ADDR TO GET HOUR NUMBER
	CLRL	-(SP)			; 0 TO INDICATE USE CURRENT TIME
	CALLS	#2,LIB$HOUR_OF_DAY	; GET HOUR NUMBER
	ADDL	JBC$Q_TICPERHR,-
		JBC$Q_NXTAST		; CALCUATE TIME FOR NEXT
	ADWC	JBC$Q_TICPERHR+4,-	; AST DELIVERY
		JBC$Q_NXTAST+4
	MOVL	#PSL$C_USER,-
		JOB_L_SAVEMODE		; SET STARTING ACCESS MODE TO USER
	$SETIMR_S	-		; SET TIMER
		ASTADR=SYM$CHKLOGINS,-	; AST ADDRESS
		DAYTIM=JBC$Q_NXTAST,-	; TIME FOR AST DELIVERY
		REQIDT=#JBC_K_HOURLY	; AST PARAMETER INDICATING HOURLY AST
100$:	BISW	#JBC_M_SRVCKLOGIN,-	; SET FLAG INDICATING TIME
		JBC$T_DATABLK+JCD_W_FLAGS ; TO CHECK LOGGED IN JOBS
	$WAKE_S				; WAKE THE MAINLINE
	RET				; DISMISS AST


	.SBTTL	KERNEL ROUTINE FOR PROCESS CHECKING
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED TO PERFORM CHECKS TO DETERMINE IF A PROCESS IS
;	LOGGED IN AT A RESTRICTED HOUR.  A PCB ADDRESS IS OBTAINED FROM THE PCB
;	VECTOR AND THE NECESSARY CHECKS ARE PERFORMED.  IF A PROCESS IS TO BE
;	DELETED, A ROUTINE IN THE EXEC IS CALLED TO QUEUE AN AST TO THE PROCESS
;	IN QUESTION.  PART OF THIS ROUTINE RUNS AT IPL SYNCH.
;
; CALLING SEQUENCE:
;
;	THIS ROUTINE IS ENTERED VIA A $CMKRNL CALL
;
; INPUT PARAMETERS:
;
;	4(AP) INDEX INTO PCB VECTOR
;	8(AP) HOUR OF THE DAY
;      12(AP) DAY OF THE WEEK
;      16(AP) ACCESS MODE OF THE AST TO QUEUE TO THE PROCESS
;
;	Note that the address containing the access mode of the AST must
;	be an address on the kernel stack or in a page that is locked in
;	memory.  This address is used as an input parameter to SCH$FORCEDEXIT
;	and it must not page fault when accessing this location.
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:
;
;	R0 = SS$_NORMAL IF AST QUEUED TO PROCESS
;	R0 = 0 IF NO AST QUEUED
;
; SIDE EFFECTS:
;
;	AN AST CAN BE QUEUED TO THE PROCESS BEING CHECKED
;--

CHK_HRDAY_BITS:
	.WORD	^M<R2,R3,R4,R5,R6,R7>

	ASSUME	JOB_L_PCBINDEX EQ JOB_L_COUNT+4
	ASSUME	JOB_L_HOUR     EQ JOB_L_PCBINDEX+4
	ASSUME	JOB_L_DAY      EQ JOB_L_HOUR+4
	ASSUME	JOB_L_MODE     EQ JOB_L_DAY+4
	ASSUME	JOB_L_SAVEMODE EQ JOB_L_MODE+4

	MOVAL	4(AP),R0		; GET ADDR OF ARGUMENT LIST
	MOVL	(R0)+,R2		; SET PCB INDEX
	MOVL	(R0)+,R7		; SET HOUR OF DAY
	MOVL	(R0)+,R6		; DAY OF WEEK
	MOVL	(R0)+,-(SP)		; SET ACCESS MODE FOR AST DELIVERY
					; ON STACK TO AVOID PAGE FAULT WHEN
					; ACCESSING
	TSTL	R7			; IS IT MIDNITE? TIME TO CLEAR OVERIDE
	BNEQ	10$			; IF NEQ THEN NOT MIDNITE
	CMPL	(SP),#PSL$C_USER	; FIRST TIME THRU AT MIDNIGHT?
	BNEQ	10$			; IF NEQ THEN NOT FIRST TIME THRU
	BBCC	S^#EXE$V_EXPLICITS,-	; CLEAR OPERATOR OVERRIDE
		G^EXE$GL_FLAGS,10$	; FOR DAYTYPE BIT
;%%%%
XX_BEGIN = .
10$:	SETIPL	LOCKIPL			; RAISE TO SYNCH
	MOVL	@SCH$GL_PCBVEC[R2],R4	; GET PCB ADDRESS
	MOVAL	G^SCH$GL_NULLPCB,R0	; GET ADDRESS OF NULL PCB
	CMPL	R0,R4			; IF PROCESS NULL PROCESS?
	BEQL	80$			; IF EQL THEN YES
	TSTL	PCB$L_OWNER(R4)		; IS IT A SUB-PROCESS?
	BNEQ	80$			; IF NEQ THEN YES
	BBS	#PCB$V_NETWRK,-
		PCB$L_STS(R4),80$	; BR IF NETWORK PROCESS
	MOVL	PCB$L_JIB(R4),R5	; GET ADDRESS OF JIB
	BEQL	80$			; BR IF JIB ADDRESS IS ZERO
	MOVAB	G^EXE$GL_FLAGS,R1	; OPERATOR OVERRIDE FLAGS
	EXTZV	R6,#1,JIB$B_DAYTYPES(R5),R0 ; GET BIT FOR PRIM/SEC DAY
	BBC	S^#EXE$V_EXPLICITS,(R1),20$  ; BR IF NO OPERATOR OVERRIED
	EXTZV	S^#EXE$V_EXPLICITP,#1,(R1),R0 ; USE OPERATOR OVERRIDE
20$:	BLBC	R0,40$			; IF LBC THEN PRIMARY DAY
	BBS	R7,JIB$L_ODAYHOURS(R5),60$ ; IF BIT SET THEN GET RID OF PROCESS
	BLBS	R0,80$			; IF LBS THEN IGNORE THIS PROCESS
40$:	BBC	R7,JIB$L_PDAYHOURS(R5),80$ ; CHECK PRIMARY HOUR - IF CLEAR OK
60$:	MOVZWL	#SS$_FORCEDEXIT,R3	; SET EXIT STATUS
	MOVAB	(SP),R0			; SET MODE FOR AST
	JSB	G^SCH$FORCEDEXIT	; QUEUE AST TO PROCESS
	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS
	BRB	90$			; BR TO LOWER IPL AND RETURN
80$:	CLRL	R0			; SET FAILURE
90$:	SETIPL	#0			; LOWER IPL BACK TO 0
	RET				; RETURN
LOCKIPL:
	.LONG	IPL$_SYNCH		; IPL SYNCH
;%%%%
XX_END:
	ASSUME	<XX_END - XX_BEGIN> LE 512

	.END
