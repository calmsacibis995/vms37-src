	.TITLE	JBCPRACNT - PROCESS ACCOUNTING MODULE
	.IDENT	'V03-004'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	STARLET JOB_CONTROLLER
;
; ABSTRACT:	THIS MODULE CONTAINS THE JOB_CONTROLLER ACCOUNT
;		FILE MAINTAINANCE ROUTINES.
;
; ENVIRONMENT:	THIS MODULE MAKES UP PART OF THE JOB_CONTROLLER
;		SYSTEM PROCESS.
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 5-JAN-78
;
; MODIFIED BY:
;
;	V03-004	SPF0109		Steve Forgey		05-Apr-1982
;		Additional fixes to SPF0107.
;
;	V03-003	KDM0086		Kathleen D. Morse	02-Apr-1982
;		Replace reference to EXE$GQ_SYSTIME to $GETTIM, so
;		that code works correctly on an 11/782.
;
;	V03-002	SPF0107		Steve Forgey	31-Mar-1982
;		Include remote node information in logfail records.  Require
;		a null account name AND a username of "SYSTEM" for SYSINIT
;		records.
;
;	V03-001	MLJ0083		Martin L. Jack,	21-Mar-1982  8:58
;		Avoid issuing an error if SET ACCOUNTING/ENABLE and /DISABLE
;		are already in effect; they are not documented this way.
;
;	V02-013 SPF0078		Steve Forgey	05-Feb-1982
;		Create a new accounting file if $CREATEIF fails with a
;		"file not found" status.
;
;	V02-012	SPF0068		Steve Forgey	22-Jan-1982
;		Get queue info for SNDACC functions.
;
;	V02-011	MLJ0067		Martin L. Jack,	17-Jan-1982  23:15
;		Change open of accounting file to use filename ACCOUNTNG and
;		default filename so that a logical name can redirect the file.
;
;	V02-010	SPF0060		Steve Forgey	13-Jan-1981
;		Fix remote node data in print job records.
;
;	V02-009	SPF0058		Steve Forgey	04-Jan-1981
;		Record accounting file name in file records.
;
;	V02-008	SPF0045		Steve Forgey	08-Dec-1981
;		Add remote node information processing.
;
;	V02-007	SPF0043		Steve Forgey	02-Oct-1981
;		Add record/packet version number to ACR$W_TYPE.
;
;	V02-006	SPF0038		Steve Forgey	23-Sep-1981
;		Fix selective enable/disable bug.
;
;	V02-005	SPF0028		Steve Forgey	15-Sep-1981
;		Change queue name from blank filled string to counted ASCII.
;
;	V02-004	SPF0027		Steve Forgey	14-Sep-1981
;		Fix record type bug.
;
;	V02-003	SPF0012		Steve Forgey	28-Jul-1981
;		Add support for new accounting message and record formats.
;
;	V02-002	SPF0001		Steven Forgey	27-Feb-1981
;		Don't create a new accounting file if device is full.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; THE QUEUE DEFINITONS
	$ACCDEF
	$ACMDEF				; ACCOUNTING MESSAGE DEFINITIONS
	$ACRDEF				; ACCOUNTING RECORD DEFINITIONS
	$MSGDEF				; SYSTEM WIDE MESSAGE CODES
	$PCBDEF				; PROCESS CONTROL BLOCK DEFINITIONS
	$RMSDEF				; RMS DEFINITIONS

	MAX_REC_SIZ == 1024		; MAXIMUM ACCOUNTING RECORD SIZE
;
; OWN STORAGE:
 
	IMPURE_DATA
 
JBC$G_ACNTFAB::	.ADDRESS	FAB0	; THE ACCOUNTING FAB
		.ADDRESS	FAB1

FAB0:		
	$FAB	FAC=PUT,-		; FILE ACCESS IS WRITE
		FNA=ACNTNM,-		; FILE NAME STRING
		FNS=ACNTSZ,-		; LENGTH OF THE STRING
		DNA=ACNTDF,-		; FILE NAME STRING
		DNS=ACNDSZ,-		; LENGTH OF THE STRING
		FOP=<CIF>,-		; CREATE IF NOT PRESENT
		DEQ=25,-		; ALLOCATE 25 BLOCKS ON EACH EXTEND
		ORG=SEQ,-		; FILE IS SEQUENTIAL
		RFM=VAR,-		; VARIABLE LENGTH RECORDS
		NAM=NAM0, -		; NAME BLOCK ADDRESS
		SHR=<GET,UPI>		; SHARE GETS WITH USER INTERLOCK
 					;

NAM0:					; FILE NAME BLOCK
	$NAM	RSA=NAME0, -
		RSS=NAM$C_MAXRSS
NAME0:
	.BLKB	NAM$C_MAXRSS

FAB1:		
	$FAB	FAC=PUT,-		; FILE ACCESS IS WRITE
		FNA=ACNTNM,-		; FILE NAME STRING
		FNS=ACNTSZ,-		; LENGTH OF THE STRING
		DNA=ACNTDF,-		; FILE NAME STRING
		DNS=ACNDSZ,-		; LENGTH OF THE STRING
		FOP=<CIF>,-		; CREATE IF NOT PRESENT
		DEQ=25,-		; ALLOCATE 25 BLOCKS ON EACH EXTEND
		ORG=SEQ,-		; FILE IS SEQUENTIAL
		RFM=VAR,-		; VARIABLE LENGTH RECORDS
		NAM=NAM1, -		; NAME BLOCK ADDRESS
		SHR=<GET,UPI>		; SHARE GETS WITH USER INTERLOCK

NAM1:					; FILE NAME BLOCK
	$NAM	RSA=NAME1, -		
		RSS=NAM$C_MAXRSS
NAME1:
	.BLKB	NAM$C_MAXRSS

JBC$G_ACNTRAB::	.ADDRESS	RAB0	; ACCOUNTING RAB
		.ADDRESS	RAB1
RAB0:
	$RAB	FAB=FAB0,-		; ASSOCIATED FAB
		MBC=1,-			; MULTI-BLOCK COUNT IS ONE
		MBF=2,-			; TWO BUFFERS
		RAC=SEQ,-		; ACCESS IS SEQUENTIAL
		ROP=<EOF,WBH>		; CONNECT TO EOF AND WRITE BEHIND
					;
RAB1:
	$RAB	FAB=FAB1,-		; ASSOCIATED FAB
		MBC=1,-			; MULTI-BLOCK COUNT IS ONE
		MBF=2,-			; TWO BUFFERS
		RAC=SEQ,-		; ACCESS IS SEQUENTIAL
		ROP=<EOF,WBH>		; CONNECT TO EOF AND WRITE BEHIND
					;
	PURE_SECTION
 
 
ACNTNM:	.ASCII	\ACCOUNTNG\
ACNTSZ = . - ACNTNM
ACNTDF:	.ASCII	\SYS$MANAGER:.DAT\
ACNDSZ = . - ACNTDF
SYSTEM_NAME:	.ASCII	/SYSTEM      / 
;
; OPRREQ - THIS WORD CONTAINS A BIT SET FOR ALL REQUESTS WHICH REQUIRE
;	OPERATOR PRIVILEGE.
;
 
OPRREQ:	.LONG	<1@ACC$K_NEWFILE>!-	; OPEN A NEW FILE
		<1@ACC$K_ENABACC>!-	; ENABLE ACCOUNTING
		<1@ACC$K_DISAACC>!-	; DISABLE ACCOUNTING
		<1@ACC$K_ENABSEL>!-	; ENABLE SELECTIVE ACCOUNTING
		<1@ACC$K_DISASEL>	; DISABLE SELECTIVE ACCOUNTING

	.SBTTL	ACCOUNT FILE MAINTAINANCE ROUTINES
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO WRITE THE ACCOUNTING FILE.
;
; CALLING SEQUENCE:
;
;	BSBW	ACM$WRITEACNT
;
; INPUT PARAMETERS:
;
;	R7= RECORD ADDRESS
;
; IMPLICIT INPUTS:
;
;	THE ACCOUNT FILE IS OPEN IF ACCOUNTING IS ENABLED.
;
; OUTPUT PARAMETERS:
;
;	R2 = ADDRESS OF ACCOUNT FILE RAB
;
; COMPLETION CODES:
;
;	R0 LOW BIT CLEAR INDICATES THE FILE WAS NOT WRITTEN.
;
; SIDE EFFECTS:
;
;	A NEW COPY OF THE ACCOUNTING FILE MAY BE OPENNED
;	IF THERE IS AN ERROR DETECTED WRITING THE FILE.
;
;--
 
	PURE_SECTION

ACM$WRITEACNT::				; WRITE AN ACCOUNTING RECORD 
	MOVAB	@W^JBC$G_ACNTFAB,R2	; GET FAB ADDRESS
	TSTW	FAB$W_IFI(R2)		; FILE OPENED?
	BNEQ	1$
	BRW	40$			; BR IF NO
1$:	MOVAB	@W^JBC$G_ACNTRAB,R2	; GET RAB ADDRESS
	MOVW	ACR$W_LENGTH(R7),RAB$W_RSZ(R2) ; SET RECORD SIZE IN RAB
	MOVL	R7,RAB$L_RBF(R2)	; SET RECORD BUFFER ADDRESS
	CLRL	R0			; ASSUME NO ACCOUNTING
	EXTZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),R1; GET RECORD TYPE
	MOVL	@#EXE$GL_ACMFLAGS,R3	; ACCOUNTING CONTROL FLAGS
	MOVL	#1,R0			; ASSUME ENABLED
	CASE	R1, -			; DISPATCH ON RECORD TYPE
		LIMIT=#ACR$K_PRCDEL, -
		< -
		100$, -			; PROCESS DELETE
		110$, -			; PROCESS PURGE
		120$, -			; IMAGE DELETE
		130$, -			; IMAGE PURGE
		20$, -			; SYSINIT
		20$, -			; SETTIME
		140$, -			; LOGFAIL
		150$, -			; PRINT JOB
		160$, -			; USER DATA
		20$, -			; ENABLE ACC
		20$, -			; DISABLE ACC
		20$, -			; ALTACM
		20$, -			; FILE_FL
		20$, -			; FILE_BL
		>
10$:
	CLRL	R0
20$:
	BLBC	R0,40$			; IF LBC, THIS TYPE DISABLED
	BBCC	#RAB$V_ASY,RAB$L_ROP(R2),30$ ; IF BS, WAIT & SET SYNCH MODE FOR NEXT
	$WAIT	RAB=(R2)		; WAIT FOR PREVIOUS IO TO STOP
	BLBC	R0,60$			; BR IF ERROR ON FILE
30$:	$PUT	RAB=(R2)		; WRITE THE RECORD
	BLBC	R0,60$			; BR IF ERROR WRITING THE FILE
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_IMGDEL ; IMAGE ?
	BEQL	40$			; IF EQL, YES.  DON'T FLUSH
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_IMGPUR ; IMAGE ?
	BEQL	40$			; IF EQL, YES.  DON'T FLUSH
	BBSS	#RAB$V_ASY,RAB$L_ROP(R2),35$ ; FLUSHES ARE ASYNCHRONOUS
35$:	$FLUSH	RAB=(R2)		; WRITE DIRTY RECORDS TO THE FILE
	BLBC	R0,60$			; BR IF ERROR
40$:	RSB				;

;
; ERROR WRITING THE FILE - TRY TO OPEN A NEW COPY
;
 
60$:	CMPL	#RMS$_FUL,RAB$L_STS(R2)	; DEVICE FULL ?
	BEQL	70$			; IF EQL, YES
	SHOW_ERROR ACNT_FIL_RIT		;
	BSBB	JBC$OPENACNT		; OPEN A NEW ACCOUNTING FILE
	BRW	ACM$WRITEACNT		; WRITE THE RECORD AGAIN
70$:	SHOW_ERROR ACNT_FIL_RIT
	RSB				; LEAVE CURRENT FILE OPEN
80$:	BRW	10$
90$:	BRW	20$

100$:
110$:	BBS	#ACM$V_PROCESS,R3,131$
	BRB	80$
120$:
130$:	BBC	#ACM$V_IMAGE,R3,80$
131$:	EXTZV	#ACR$V_SUBTYPE,#ACR$S_SUBTYPE,ACR$W_TYPE(R7),R1; GET PROCESS TYPE
	CASE	R1, -			; DISPATCH ON PROCESS TYPE
		LIMIT=#ACR$K_INTERACTIVE, -
		< -
		132$, -				; INTERACTIVE
		133$, -				; SUBPROCESS
		134$, -				; DETACHED
		135$, -				; BATCH
		136$, -				; NETWORK
		>
	BRB	80$
132$:	BBS	#ACM$V_INTERACTIVE,R3,90$
	BRB	80$
133$:	BBS	#ACM$V_SUBPROCESS,R3,90$
	BRB	80$
134$:	BBS	#ACM$V_DETACHED,R3,90$
	BRB	80$
135$:	BBS	#ACM$V_BATCH,R3,90$
	BRB	80$
136$:	BBS	#ACM$V_NETWORK,R3,90$
	BRB	80$
140$:	BBS	#ACM$V_LOGFAIL,R3,90$
	BRB	80$
150$:	BBS	#ACM$V_PRINT,R3,90$
	BRB	80$
160$:	BBS	#ACM$V_USER_DATA,R3,90$
	BRB	80$

	.SBTTL	ACCOUNT FILE OPEN ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO OPEN AN ACCOUNTING FILE.
;	IF THERE IS ALREADY ONE OPEN IT IS CLOSED AND A NEW
;	COPY IS CREATED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	JBC$OPENACNT		;
;
; INPUT PARAMETERS:	NONE
;
; OUTPUT PARAMETERS:
;
;	R2 = ADDRESS OF ACCOUNT FILE RAB
;
; COMPLETION CODES:
;
;	R0 LOW BIT CLEAR INDICATES THE FILE WAS NOT OPENED.
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION
 
JBC$OPENACNT::				; OPEN THE ACCOUNTING FILE
	PUSHR	#^M<R1,R3,R4,R5,R6,R7>
	MOVAB	@W^JBC$G_ACNTFAB,R2	; GET CURRENT FAB ADDRESS
	MOVAB	@W^JBC$G_ACNTFAB+4,R4	; GET NEW FAB ADDRESS
	MOVAB	@W^JBC$G_ACNTRAB,R3	; GET CURRENT RAB ADDRESS
	MOVAB	@W^JBC$G_ACNTRAB+4,R5	; GET NEW RAB ADDRESS
	SETBIT	FAB$V_CIF,FAB$L_FOP(R4)	; ASSUME OPEN PREVIOUS IS DESIRED
	MOVZWL	FAB$W_IFI(R2),R7	; IS FILE OPEN?
	BEQL	10$			; BR IF FILE NOT OPEN
5$:	CLRBIT	FAB$V_CIF,FAB$L_FOP(R4)	; IF ALREADY OPEN - CREATE A NEW
10$:	CLRL	FAB$L_ALQ(R4)		; SET FOR NO INITIAL ALLOCATION
	$CREATE	FAB=R4			; CREATE OR OPEN THE FILE
	CLRW	RAB$W_ISI(R5)		; MAKE SURE DISCONNECT IS DONE
	BLBS	R0,14$			; BR IF SUCCESS
	CMPL	#RMS$_FNF,R0		; FILE NOT FOUND ERROR ?
	BEQL	5$			; IF EQL, YES.  CREATE A NEW FILE
	BRB	40$			; OTHER CREATE ERROR
14$:	MOVL	R0,R6			; SAVE $CREATE STATUS
	$CONNECT RAB=R5			; CONNECT TO OUTPUT STREAM
	BLBC	R0,40$			; SHOW ERROR
	BBC	#FAB$V_CIF,FAB$L_FOP(R4),15$; IF BC, NEW FILE CREATED
	CMPL	#RMS$_CREATED,R6	; WAS A NEW FILE CREATED ?
	BNEQ	30$			; IF NEQ, NO
15$:
	TSTW	FAB$W_IFI(R2)		; OLD FILE OPEN ?
	BEQL	30$			; IF EQL, NO
	BSBW	ACM$FILEFL		; WRITE FORWARD LINKAGE RECORD
	BBCC	#RAB$V_ASY,RAB$L_ROP(R3),20$; ASYNCH OPERATION ?
	$WAIT	RAB=(R3)
20$:
	$CLOSE	FAB=R2			; CLOSE THE CURRENT FILE
	CLRW	FAB$W_IFI(R2)		; ENSURE DISCONNECT
30$:
	MOVAB	(R2),W^JBC$G_ACNTFAB+4	; SWITCH FABS
	MOVAB	(R4),W^JBC$G_ACNTFAB
	MOVAB	(R3),W^JBC$G_ACNTRAB+4	; SWITCH RABS
	MOVAB	(R5),W^JBC$G_ACNTRAB
	TSTL	R7			; WAS OLD FILE OPEN ?
	BEQL	35$			; IF EQL, NO
	BSBW	ACM$FILEBL		; WRITE BACKWARD LINKAGE RECORD
35$:	MOVAB	(R5),R2			; RETURN NEW RAB ADDRESS IN R2
	POPR	#^M<R1,R3,R4,R5,R6,R7>
	RSB
40$:	PUSHR	#^M<R2,R3,R4,R5>
	SHOW_ERROR  ACNT_FIL_OPN	; ERROR ON ACCOUNTING FILE
	POPR	#^M<R2,R3,R4,R5>
	BRB	30$

	.SBTTL	PROCESS/IMAGE ACCOUNTING RECORDS

;++
; ACM$PROCESS
;
;	This routine builds and writes all process/image accounting records.
;
; INPUTS:
;	R6 = ACCOUNTING MESSAGE ADDRESS
;
;	IF PCB$V_BATCH IS SET IN ACM$L_STS THEN
;		R4 = SMQ ADDRESS
;		R5 = SJH ADDRESS
;
;--

ACM$PROCESS::
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	SUBL2	#MAX_REC_SIZ,SP			; ALLOCATE RECORD BUFFER SPACE
	MOVL	SP,R7				; BUFFER ADDRESS
	PUSHAL	20$				; RETURN ADDRESS
	CASE	ACM$W_TYPE(R6),-		; DETERMINE MESSAGE TYPE
		LIMIT=#MSG$_DELPROC, -
		<DEL_PROCESS, -			; (3)DELETE PROCESS MESSAGE
		10$, -				; (4)ILLEGAL MESSAGE TYPE
		10$, -				; (5)
		10$, -				; (6)
		10$, -				; (7)
		10$, -				; (8)
		10$, -				; (9)
		10$, -				; (A)
		PUR_PROCESS, -			; (B)PURGE PROCESS MESSAGE
		DEL_IMAGE, -			; (C)DELETE IMAGE MESSAGE
		PUR_IMAGE, -			; (D)PURGE IMAGE MESSAGE
		>
10$:
	SHOW_ERROR	INVALID_MESG		; BAD MESSAGE RECEIVED
20$:
	ADDL2	#MAX_REC_SIZ,SP			; DEALLOCATE RECORD BUFFER
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	RSB

	.ENABLE LSB

DEL_PROCESS:				; DELETE PROCESS
	MOVZBL	#ACR$K_PRCDEL,R0		; ASSUME PROCESS DELETE
	BISL3	ACM$T_ACCOUNT(R6),ACM$T_ACCOUNT+4(R6),R1; ACCOUNT NAME NULL ?
	BNEQ	PROCESS				; IF NEQ, NO
	MOVQ	#ACR$K_LOGFAIL,R0		; ASSUME TYPE = LOGFAIL,NO SUBTYPE
	TSTB	ACM$T_TERMINAL(R6)		; INTERACTIVE PROCESS ?
	BNEQ	LOGFAIL				; IF NEQ, YES.  LOGIN FAILURE.
	CMPC3	#12,SYSTEM_NAME,ACM$T_USERNAME(R6); USERNAME EQUAL "SYSTEM"
	BEQL	1$				; IF EQL, YES
	MOVZBL	#ACR$K_PRCDEL,R0		; TYPE = PROCESS DELETE
	BRB	PROCESS
1$:	BSBW	ACM$SYSINIT			; SYSTEM INITIALIZATION MESSAGE
	RSB

PUR_PROCESS:				; PURGE PROCESS
	MOVZBL	#ACR$K_PRCPUR,R0		; RECORD TYPE
	BRB	PROCESS

DEL_IMAGE:				; DELETE IMAGE
	MOVZBL	#ACR$K_IMGDEL,R0		; RECORD TYPE
	BRB	IMAGE

PUR_IMAGE:				; PURGE IMAGE
	MOVZBL	#ACR$K_IMGPUR,R0		; RECORD TYPE
	BRB	IMAGE

LOGFAIL:
	BRW	50$				; JOIN COMMON CODE

PROCESS:
IMAGE:
	TSTB	ACM$T_TERMINAL(R6)		; INTERACTIVE PROCESS ?
	BEQL	10$				; IF EQL, NO
	MOVZBL	#ACR$K_INTERACTIVE,R1		; RECORD SUBTYPE
	BRB	50$
10$:
	BBC	#PCB$V_BATCH,ACM$L_STS(R6),20$	; BATCH PROCESS ?
	MOVZBL	#ACR$K_BATCH,R1			; RECORD SUBTYPE
	BRB	50$
20$:
	BBC	#PCB$V_NETWRK,ACM$L_STS(R6),30$	; NETWORK PROCESS ?
	MOVZBL	#ACR$K_NETWORK,R1		; RECORD SUBTYPE
	BRB	50$
30$:
	TSTL	ACM$L_OWNER(R6)			; SUBPROCESS ?
	BEQL	40$				; IF EQL, NO
	MOVZBL	#ACR$K_SUBPROCESS,R1		; RECORD SUBTYPE
	BRB	50$
40$:
	MOVZBL	#ACR$K_DETACHED,R1		; RECORD SUBTYPE
50$:
	MOVQ	ACM$Q_SYSTIME(R6),R2		; EVENT TIME
	BSBW	ACM$RECORD			; BUILD RECORD HEADER
	BSBW	ACM$ID				; ADD IDENTIFICATION PACKET
	BSBW	ACM$RESOURCE			; ADD RESOURCE PACKET
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_IMGDEL; IMAGE ?
	BEQL	60$				; IF EQL, YES
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_IMGPUR; IMAGE ?
	BNEQ	70$				; IF NEQ, NO
60$:
	BSBW	ACM$IMAGENAME			; ADD IMAGE NAME PACKET
70$:
	BSBW	ACM$WRITEACNT			; WRITE ACCOUNTING RECORD
	RSB

	.DISABLE LSB

	.SBTTL	RECORD HEADER

;++
; ACM$RECORD
;
;	This routine builds the record header.
;
; INPUTS:
;	R0 = RECORD TYPE
;	R1 = RECORD SUBTYPE
;	(R2,R3) = EVENT TIME
;	R7 = ACCOUNTING RECORD ADDRESS
;
;--

ACM$RECORD::
	CLRW	ACR$W_TYPE(R7)			; CLEAR ALL RECORD TYPE BITS
	INSV	R0,#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7); RECORD TYPE
	INSV	R1,#ACR$V_SUBTYPE,#ACR$S_SUBTYPE,ACR$W_TYPE(R7); RECORD SUBTYPE
	INSV	#ACR$K_CURVER,#ACR$V_VERSION,#ACR$S_VERSION,ACR$W_TYPE(R7)
	MOVW	#ACR$K_HDRLEN,ACR$W_LENGTH(R7); RECORD HEADER LENGTH
	MOVQ	R2,ACR$Q_SYSTIME(R7)		; EVENT TIME
	RSB
	

	.SBTTL	PACKET HEADER

;++
; ACM$PACKET
;
;	This routine builds the packet header.
;
; INPUTS:
;	R0 = PACKET TYPE
;	R1 = PACKET SUBTYPE
;	R7 = ACCOUNTING RECORD ADDRESS
;
; OUTPUTS:
;	R8 = PACKET ADDRESS
;
;--

ACM$PACKET::
	MOVZWL	ACR$W_LENGTH(R7),R8		; CURRENT RECORD LENGTH
	ADDL2	R7,R8				; CURRENT PACKET ADDRESS
	CLRW	ACR$W_TYPE(R8)			; CLEAR ALL PACKET TYPE BITS
	BISW2	#ACR$M_PACKET,ACR$W_TYPE(R8)	; SET PACKET FLAG
	INSV	R0,#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R8); PACKET TYPE
	INSV	R1,#ACR$V_SUBTYPE,#ACR$S_SUBTYPE,ACR$W_TYPE(R8); PACKET SUBTYPE
	INSV	#ACR$K_CURVER,#ACR$V_VERSION,#ACR$S_VERSION,ACR$W_TYPE(R8)
	CLRW	ACR$W_LENGTH(R8)		; CLEAR PACKET LENGTH
	RSB

	.SBTTL	IDENTIFICATION PACKET

;++
; ACM$ID
;
;	This routine builds the user identification packet.
;
; INPUTS:
;	R4 = SMQ ADDRESS (0 => NONE)
;	R5 = SJH ADDRESS (0 => NONE)
;	R6 = ACCOUNTING MESSAGE ADDRESS
;	R7 = ACCOUNTING RECORD ADDRESS
;
;--

ACM$ID::
	MOVQ	R4,-(SP)			; SAVE SMQ AND SJH ADDRESSES
	MOVQ	#ACR$K_ID,R0			; TYPE = ID, NO SUBTYPE
	BSBW	ACM$PACKET			; BUILD PACKET HEADER
	MOVL	ACM$L_PID(R6),ACR$L_PID(R8)	; PROCESS ID
	MOVL	ACM$L_OWNER(R6),ACR$L_OWNER(R8)	; OWNER PID (0 => NONE)
	MOVL	ACM$L_UIC(R6),ACR$L_UIC(R8)	; PROCESS UIC
	MOVQ	ACM$Q_PRVMSK(R6),ACR$Q_PRIV(R8)	; PROCESS PRIV
	MOVB	ACM$B_PROCPRI(R6),ACR$B_PRI(R8)	; PROCESS PRIORITY
	CLRB	ACR$B_PRI+1(R8)			; CLEAR SPARE BYTE
	MOVAB	ACR$K_IDVAR(R8),R3		; VARIABLE LENGTH STORAGE AREA
	SUBL3	R8,R3,R0			; USERNAME OFFSET
	CVTLW	R0,ACR$W_USERNAME(R8)
	LOCC	#^A/ /,#12,ACM$T_USERNAME(R6)	; FIND END OF STRING
	SUBL3	R0,#12,R0			; USERNAME LENGTH
	MOVB	R0,(R3)+
	MOVC3	R0,ACM$T_USERNAME(R6),(R3)	; COPY USERNAME
	BISL3	ACM$T_ACCOUNT(R6),ACM$T_ACCOUNT+4(R6),R0; ACCOUNT NAME NULL ?
	BNEQ	5$				; IF NEQ, NO
	CLRW	ACR$W_ACCOUNT(R8)		; NO ACCOUNT NAME
	BRB	10$
5$:
	SUBL3	R8,R3,R0			; ACCOUNT OFFSET
	CVTLW	R0,ACR$W_ACCOUNT(R8)
	LOCC	#^A/ /,#8,ACM$T_ACCOUNT(R6)	; FIND END OF STRING
	SUBL3	R0,#8,R0			; ACCOUNT NAME LENGTH
	MOVB	R0,(R3)+
	MOVC3	R0,ACM$T_ACCOUNT(R6),(R3)	; COPY ACCOUNT NAME
10$:
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_PRCDEL; PROCESS ?
	BEQL	11$				; IF EQL, YES
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_LOGFAIL; LOGFAIL ?
	BEQL	11$				; IF EQL, YES
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_IMGDEL; IMAGE ?
	BEQL	11$				; IF EQL, YES
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_PRCPUR; PROCESS ?
	BEQL	11$				; IF EQL, YES
	CMPZV	#ACR$V_TYPE,#ACR$S_TYPE,ACR$W_TYPE(R7),#ACR$K_IMGPUR; IMAGE ?
	BEQL	11$				; IF EQL, YES
	CLRW	ACR$W_NODEADDR(R8)		; NO REMOTE NODE INFO PRESENT
	CLRW	ACR$W_NODENAME(R8)
	CLRW	ACR$W_REMOTEID(R8)
	BRB	20$
11$:
	CLRW	ACR$W_NODEADDR(R8)		; ASSUME NO NODE ADDRESS
	MOVZWL	ACM$W_NODEADDR(R6),R1		; REMOTE NODE ADDRESS OFFSET
	BEQL	12$				; IF EQL, NO NODE ADDRESS
	ADDL2	R6,R1				; POINT TO NODE ADDRESS STRING
	MOVZBL	(R1),R0				; GET NODE ADDRESS LENGTH
	BEQL	12$				; IF EQL, NO NODE ADDRESS
	INCL	R0				; ADD BYTE COUNT BYTE
	SUBL3	R8,R3,R2			; NODE ADDRESS OFFSET
	CVTLW	R2,ACR$W_NODEADDR(R8)
	MOVC3	R0,(R1),(R3)			; COPY NODE ADDRESS
12$:
	CLRW	ACR$W_NODENAME(R8)		; ASSUME NO NODE NAME
	MOVZWL	ACM$W_NODENAME(R6),R1		; REMOTE NODE NAME OFFSET
	BEQL	15$				; IF EQL, NO NODE NAME
	ADDL2	R6,R1				; POINT TO NODE NAME STRING
	MOVZBL	(R1),R0				; GET NODE NAME LENGTH
	BEQL	15$				; IF EQL, NO NODE NAME
	INCL	R0				; ADD BYTE COUNT BYTE
	SUBL3	R8,R3,R2			; NODE NAME OFFSET
	CVTLW	R2,ACR$W_NODENAME(R8)
	MOVC3	R0,(R1),(R3)			; COPY NODE NAME
15$:
	CLRW	ACR$W_REMOTEID(R8)		; ASSUME NO REMOTE ID
	MOVZWL	ACM$W_REMOTEID(R6),R1		; REMOTE ID OFFSET
	BEQL	20$				; IF EQL, NO REMOTE ID
	ADDL2	R6,R1				; POINT TO REMOTE ID STRING
	MOVZBL	(R1),R0				; GET REMOTE ID LENGTH
	BEQL	20$				; IF EQL, NO REMOTE ID
	INCL	R0				; ADD BYTE COUNT BYTE
	SUBL3	R8,R3,R2			; REMOTE ID OFFSET
	CVTLW	R2,ACR$W_REMOTEID(R8)
	MOVC3	R0,(R1),(R3)			; COPY REMOTE ID
20$:
	MOVZBL	ACM$T_TERMINAL(R6),R0		; GET TERMINAL STRING LENGTH
	BEQL	30$				; IF EQL, NO TERMINAL NAME
	INCL	R0				; ADD BYTE COUNT BYTE
	SUBL3	R8,R3,R1			; TERMINAL NAME OFFSET
	CVTLW	R1,ACR$W_TERMINAL(R8)
	MOVC3	R0,ACM$T_TERMINAL(R6),(R3)	; COPY TERMINAL NAME
	BRB	40$
30$:
	CLRW	ACR$W_TERMINAL(R8)		; NO TERMINAL NAME
40$:
	BBC	#PCB$V_BATCH,ACM$L_STS(R6),50$	; IF BC, NOT A BATCH OR PRINT JOB
	MOVL	4(SP),R5			; GET SJH ADDRESS
	MOVZWL	SJH$W_JOBSEQ(R5),ACR$L_JOBID(R8); COPYJOB ID
	MOVZBL	SJH$T_JOBNAME(R5),R0		; JOB NAME LENGTH
	INCL	R0				; ADD BYTE COUNT BYTE
	SUBL3	R8,R3,R1			; JOB NAME OFFSET
	MOVW	R1,ACR$W_JOBNAME(R8)
	MOVC3	R0,SJH$T_JOBNAME(R5),(R3)	; COPY JOBNAME
	MOVL	(SP),R5				; GET SMQ ADDRESS
	MOVZBL	SMQ$T_NAME(R5),R0		; QUEUE NAME LENGTH
	INCL	R0				; ADD BYTE COUNT BYTE
	SUBL3	R8,R3,R1			; QUEUE NAME OFFSET
	MOVW	R1,ACR$W_QUEUE(R8)
	MOVC3	R0,SMQ$T_NAME(R5),(R3)		; COPY QUEUE NAME
	BRB	60$
50$:
	CLRL	ACR$L_JOBID(R8)			; NO JOB ID, JOB NAME, OR QUEUE
	CLRW	ACR$W_JOBNAME(R8)
	CLRW	ACR$W_QUEUE(R8)
60$:
	SUBL3	R8,R3,R0			; PACKET LENGTH
	MOVW	R0,ACR$W_LENGTH(R8)
	SUBL2	R7,R3				; RECORD LENGTH
	MOVW	R3,ACR$W_LENGTH(R7)
	MOVQ	(SP)+,R4			; RESTORE SMQ AND SJH ADDRESSES
	RSB	

	.SBTTL	RESOURCE PACKET

;++
; ACM$RESOURCE
;
;	This routine builds the resource usage packet.
;
; INPUTS:
;	R6 = ACCOUNTING MESSAGE ADDRESS
;	R7 = ACCOUNTING RECORD ADDRESS
;
;--

ACM$RESOURCE:
	MOVQ	#ACR$K_RESOURCE,R0		; TYPE = RESOURCE, NO SUBTYPE
	BSBW	ACM$PACKET			; BUILD PACKET HEADER
	MOVC3	#<ACM$L_VOLUMES+4-ACM$Q_LOGIN>,ACM$Q_LOGIN(R6),ACR$Q_LOGIN(R8)
	SUBL3	R8,R3,R0			; PACKET LENGTH
	MOVW	R0,ACR$W_LENGTH(R8)
	SUBL2	R7,R3				; RECORD LENGTH
	MOVW	R3,ACR$W_LENGTH(R7)
	RSB	

	.SBTTL	IMAGENAME PACKET

;++
; ACM$IMAGENAME
;
;	This routine builds the image name packet.
;
; INPUTS:
;	R6 = ACCOUNTING MESSAGE ADDRESS
;	R7 = ACCOUNTING RECORD ADDRESS
;
;--

ACM$IMAGENAME:
	MOVQ	#ACR$K_IMAGENAME,R0		; TYPE = IMAGENAME, NO SUBTYPE
	BSBW	ACM$PACKET			; BUILD PACKET HEADER
	MOVZWL	ACM$W_IMAGENAME(R6),R1		; IMAGE NAME OFFSET
	ADDL2	R6,R1				; IMAGE NAME ADDRESS
	MOVZBL	(R1),R0				; IMAGE NAME LENGTH
	INCL	R0				; ADD BYTE COUNT BYTE
	MOVC3	R0,(R1),ACR$T_IMAGENAME(R8); COPY IMAGE NAME
	SUBL3	R8,R3,R0			; PACKET LENGTH
	MOVW	R0,ACR$W_LENGTH(R8)
	SUBL2	R7,R3				; RECORD LENGTH
	MOVW	R3,ACR$W_LENGTH(R7)
	RSB	

	.SBTTL	USER DATA PACKET

;++
; ACM$USER_DATA
;
;	This routine builds the user data packet.
;
; INPUTS:
;	R6 = ACCOUNTING MESSAGE ADDRESS
;	R7 = ACCOUNTING RECORD ADDRESS
;
;--

ACM$USER_DATA:
	MOVQ	#ACR$K_USER_DATA,R0		; TYPE = USER_DATA, NO SUBTYPE
	BSBW	ACM$PACKET			; BUILD PACKET HEADER
	MOVZWL	ACM$W_MSGLEN(R6),R0		; GET TOTAL MESSAGE LENGTH
	SUBL2	#ACM$T_DATA,R0			; GET USER DATA LENGTH
	CVTLB	R0,ACR$T_USER_DATA(R8)		; STORE USER DATA LENGTH
	MOVC3	R0,ACM$T_DATA(R6),ACR$T_USER_DATA+1(R8); COPY USER DATA
	SUBL3	R8,R3,R0			; PACKET LENGTH
	MOVW	R0,ACR$W_LENGTH(R8)
	SUBL2	R7,R3				; RECORD LENGTH
	MOVW	R3,ACR$W_LENGTH(R7)
	RSB	

	.SBTTL	FILE NAME FORWARD LINK

;++
; ACM$FILEFL
;
;	This routine builds the accounting file forward linkage record.
;
; INPUTS:
;	NONE
;
;--

ACM$FILEFL:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	SUBL2	#MAX_REC_SIZ,SP			; ALLOCATE RECORD BUFFER
	MOVL	SP,R7				; RECORD ADDRESS
	CLRQ	-(SP)				; TEMPORARY STORAGE FOR SYS TIME
	$GETTIM_S TIMADR=(SP)			; GET SYSTEM TIME
	MOVQ	(SP)+,R2			; SET SYSTEM TIME
	MOVQ	#ACR$K_FILE_FL,R0		; TYPE = FILE_FL, NO SUBTYPE
	BSBW	ACM$RECORD			; BUILD RECORD HEADER
	MOVQ	#ACR$K_FILENAME,R0		; TYPE = FILENAME, NO SUBTYPE
	BSBW	ACM$PACKET			; BUILD PACKET HEADER
	MOVAB	@W^JBC$G_ACNTFAB+4,R6		; NEW FAB ADDRESS
	BRB	FILE				; JOIN COMMON CODE

	.SBTTL	FILE NAME BACKWARD LINK

;++
; ACM$FILEBL
;
;	This routine builds the accounting file backward linkage record.
;
; INPUTS:
;	NONE
;
;--

ACM$FILEBL:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	SUBL2	#MAX_REC_SIZ,SP			; ALLOCATE RECORD BUFFER
	MOVL	SP,R7				; RECORD ADDRESS
	MOVQ	#ACR$K_FILE_BL,R0		; TYPE = FILE_BL, NO SUBTYPE
	MOVQ	@#EXE$GQ_SYSTIME,R2		; SYSTEM TIME
	BSBW	ACM$RECORD			; BUILD RECORD HEADER
	MOVQ	#ACR$K_FILENAME,R0		; TYPE = FILENAME, NO SUBTYPE
	BSBW	ACM$PACKET			; BUILD PACKET HEADER
	MOVAB	@W^JBC$G_ACNTFAB+4,R6		; OLD FAB ADDRESS (AFTER SWITCH)
FILE:
	MOVAB	ACR$T_FILENAME(R8),R3		; FILENAME ADDRESS
	MOVL	FAB$L_NAM(R6),R6		; NAME BLOCK ADDRESS
	MOVZBL	NAM$B_RSL(R6),R0		; STRING LENGTH
	CVTLB	R0,(R3)+			; STORE STRING LENGTH
	MOVC3	R0,@NAM$L_RSA(R6),(R3)		; COPY STRING TO BUFFER
	SUBL3	R8,R3,R1			; PACKET LENGTH
	MOVW	R1,ACR$W_LENGTH(R8)
	SUBL2	R7,R3				; RECORD LENGTH
	MOVW	R3,ACR$W_LENGTH(R7)
	BSBW	ACM$WRITEACNT			; WRITE ACCOUNTING RECORD
	ADDL2	#MAX_REC_SIZ,SP			; DEALLOCATE BUFFER
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	RSB

	.SBTTL	SYSTEM INITIALIZATION

;++
; ACM$SYSINIT
;
;	This routine builds the system initialization accounting record.
;
; INPUTS:
;	R6 = MESSAGE ADDRESS
;	R7 = RECORD ADDRESS
;
;--

ACM$SYSINIT:
	MOVQ	#ACR$K_SYSINIT,R0		; TYPE = SYSINIT, NO SUBTYPE
	MOVQ	ACM$Q_SYSTIME(R6),R2		; EVENT TIME
	BSBW	ACM$RECORD			; BUILD RECORD HEADER
	BSBW	ACM$ID				; BUILD ID PACKET
	BSBW	ACM$RESOURCE			; BUILD RESOURCE USAGE PACKET
	BSBW	ACM$WRITEACNT			; WRITE ACCOUNTING RECORD
	RSB

;++
;
;--
ACM$SYSFUN::
	SETSTAT	ACMINVOP			; ASSUME INVALID OPERATION
	MOVZWL	#MSG$_ACCRSP,R2			; MESSAGE TYPE FOR RESPONSE
	RSB					; RETURN TO MESSAGE DISPATCHER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS THE SEND MESSAGE
;	TO ACCOUNTING MANAGER REQUEST.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	ACM$SNDACC		;
;
; INPUT PARAMETERS:
;
;	R9 CONTAINS THE ADDRESS OF THE MESSAGE TO PROCESS
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:
;
;	R0 CONTAINS THE STATUS OF THE REQUEST
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION
 
ACM$SNDACC::				;
	MOVZWL	ACM$W_USERREQ(R9),R7	; GET THE REQUEST TYPE CODE
	BBC	R7,OPRREQ,10$		; BR IF OPERATOR PRIVILEGE NOT NEEDED
	BSBW	SYM$CKOPRPRV		; VERIFY REQUESTOR HAS PRIVILEGE
	BLBC	R0,30$			; BR IF NO
10$:	SETSTAT	ACMINVOP		; ASSUME INVALID OPERATION
	BSBB	20$			; EXECUTE THE REQUEST
	MOVZWL	#MSG$_ACCRSP,R2		; SET MESSAGE TYPE FOR RESPONCE
	RSB				; RETURN TO MESSAGE DISPATCHER
20$:	CASE	R7, -			; DECODE REQUEST
		LIMIT=#ACC$K_INSMESG, -
		< -
		ACM$SENDMSG,-		; SEND A MESSAGE TO THE ACCOUNTING FILE
		ACM$NEWFILE,-		; OPEN A NEW FILE
		ACM$ENABACC,-		; ENABLE ACCOUNTING
		ACM$DISAACC,-		; DISABLE ACCOUNTING
		ACM$SELENAB,-		; SELECTIVE ENABLE
		ACM$SELDISA,-		; SELECTIVE DISABLE
		>
30$:		RSB
	.PAGE
;+
; ACM$SENDMSG - SNED MESSAGE TO THE ACCOUNTING FILE
;
; THIS ROUTINE IS ENTERED WHEN A USER REQUESTS TO HAVE A MESSAGE INSERTED
; INTO THE ACCOUNTING FILE.
;
;-
 
ACM$SENDMSG:
	MOVL	R9,R6			; MESSAGE ADDRESS
	SUBL2	#MAX_REC_SIZ,SP		; ALLOCATE BUFFER SPACE
	MOVL	SP,R7			; BUFFER ADDRESS
	MOVQ	#ACR$K_USER,R0		; TYPE = USER, NO SUBTYPE
	MOVQ	ACM$Q_SYSTIME(R6),R2	; EVENT TIME
	BSBW	ACM$RECORD		; BUILD RECORD HEADER
	PUSHR	#^M<R6,R7,R8>
	BBCC	#PCB$V_BATCH,ACM$L_STS(R9),10$; IF BC, NOT A BATCH JOB
	TSTL	R10			; QUEUE EXIST ?
	BEQL	10$			; IF EQL, NO
	MOVL	ACM$L_PID(R6),R1	; PROCESS ID
	BSBW	SYM$FINDETJOB		; FIND BATCH JOB
	BLBC	R0,10$			; IF LBC, JOB NOT FOUND
	MOVQ	R6,R4			; COPY SMQ AND SJH ADDRESSES
	BBSS	#PCB$V_BATCH,ACM$L_STS(R9),10$; SET BATCH INDICATOR
10$:	POPR	#^M<R6,R7,R8>
	BSBW	ACM$ID			; ADD IDENTIFICATION PACKET
	BSBW	ACM$USER_DATA		; ADD USER DATA PACKET
	BSBW	ACM$WRITEACNT		; WRITE ACCOUNTING RECORD
	ADDL2	#MAX_REC_SIZ,SP		; DEALLOCATE BUFFER SPACE
	MOVL	#1,R0			; RETURN SUCCESS
	RSB
	.PAGE
 
;+
; ACM$NEWFILE - OPEN A NEW ACCOUNTING FILE
;
;	THE CURRENT ACCOUNTING FILE IS CLOSED AND A NEW ONE IS
;	OPENED.  IF ACCOUNTING WAS DISABLED, IT IS RE-ENABLED.
;-
ACM$NEWFILE:				;
	BSBB	ACM$ENABACC		; MAKE SURE ACCOUNTING IS ENABLED
	BRW	JBC$OPENACNT		; THEN OPEN A NEW FILE
 
;+
; ACM$ENABACC - ENABLE ACCOUNTING
;
;	ACCOUNTING IS ENABLED.  IF IT ALREADY WAS ENABLED, THIS FUNCTION IS
;	A NO-OP.
;-
	.ENABL	LSB
 
ACM$ENABACC:				;
	MOVAB	@W^JBC$G_ACNTFAB,R2	; ACCOUNT FILE FAB ADDRESS
	TSTW	FAB$W_IFI(R2)		; IS ACCOUNTING ENABLED?
	BNEQ	15$			; BR IF YES
	BRW	JBC$OPENACNT		; OPEN THE ACCOUNTING FILE
 
;+
; ACM$DISAACC - DISABLE ACCOUNTING
;
;	THE ACCOUNTING FILE IS CLOSED, THEREBY DISABLING ACCOUNTING
;	UNTIL A REQUEST TO ENABLE IS RECIEVED.
;-
 
ACM$DISAACC:				;
	MOVAB	@W^JBC$G_ACNTFAB,R2	; ACCOUNT FILE FAB ADDRESS
	TSTW	FAB$W_IFI(R2)		; IS ACCOUNTING ENABLED?
	BEQL	15$			; IF EQUAL NO
	$CLOSE	FAB=R2			; CLOSE THE ACCOUNTING FILE
	CLRW	FAB$W_IFI(R2)		; FAST DISCONNECT
10$:	RSB				; RETURN STATUS OF CLOSE
15$:	SETSTAT	NORMAL			; Return with success
	RSB
 
	.DSABL	LSB

 
;+
; ACM$SELENAB - SELECTIVE ENABLE OF ACCOUNTING TYPES
; ACM$SELDISA - SELECTIVE DISABLE OF ACCOUNTING TYPES
;
;	THESE REQEST TAKE A ZERO TERMINATED STRING OF ACCOUNTING
;	TYPE BYTES TO ENABLE OR DISABLE.  IF ANY BYTE IS INVALID
;	NOTHING IS DONE.
;-
	.ENABL	LSB
 
ACM$SELENAB:				;
	MOVL	#1,R1			; SET ENABLE FLAG
	BRB	10$			;
ACM$SELDISA:				;
	CLRL	R1			; SET DIABALE FLAG
10$:	MOVAB	ACM$T_DATA(R9),R4	; POINT A BIT LIST
	CLRL	R5			; ZERO INITIAL MASK
20$:	MOVZBL	(R4)+,R2		; GET THE BIT NUMBER
	BEQL	30$			; BR ON END OF LIST
	CASE	R2, -
		LIMIT=#ACC$K_PRCTRM, -
		< -
		100$, -			; (1) GENERAL PROCESS ACCOUNTING
		110$, -			; (2) BATCH ACCOUNTING
		120$, -			; (3) INTERACTIVE
		130$, -			; (4) LOGFAIL ACCOUNTING
		140$, -			; (5) IMAGE ACCOUNTING
		150$, -			; (6) SUBPROCESS ACCOUNTING
		160$, -			; (7) DETACHED PROCESS ACCOUNTING
		170$, -			; (8) NETWORK PROCESS ACCOUNTING
		50$, -			; (9) NONEXISTENT CODE
		50$, -			; (A) NONEXISTENT CODE
		50$, -			; (B) NONEXISTENT CODE
		50$, -			; (C) NONEXISTENT CODE
		50$, -			; (D) NONEXISTENT CODE
		50$, -			; (E) NONEXISTENT CODE
		50$, -			; (F) NONEXISTENT CODE
		180$, -			; (10) PRINT JOB ACCOUNTING
		190$, -			; (11) USER MESSAGE ACCOUNTING
		>
	BRB	50$
30$:	MOVAB	200$,R0			; ASSUME ENABLE FUNCTION
	BLBS	R1,40$			; IF LBS, ENABLE FUNCTION
	MOVAB	300$,R0			; DISABLE FUNCTION
40$:
	PUSHL	R5			; STORE FLAGS
	MOVAB	(SP),R5			; ARGUMENT POINTER
	$CMKRNL_S	ROUTIN=(R0),ARGLST=(R5); WRITE EXEC FLAGS
	POPL	R5
	SETSTAT	NORMAL			; LIST IS AOK - RETURN GOOD STATUS
50$:	RSB

60$:	BRB	20$

100$:	BBSS	#ACM$V_SUBPROCESS,R5,102$; GENERAL PROCESS ACCOUNTING
102$:	BBSS	#ACM$V_DETACHED,R5,104$
104$:	BBCS	#ACM$V_NETWORK,R5,60$
	BRB	60$

110$:	BBCS	#ACM$V_BATCH,R5,60$	; BATCH PROCESS ACCOUNTING
	BRB	60$

120$:	BBCS	#ACM$V_INTERACTIVE,R5,60$; INTERACTIVE PROCESS ACCOUNTING
	BRB	60$

130$:	BBCS	#ACM$V_LOGFAIL,R5,60$	; LOGIN FAILURE ACCOUNTING
	BRB	60$

140$:	BBCS	#ACM$V_IMAGE,R5,60$	; IMAGE ACCOUNTING
	BRB	60$

150$:	BBCS	#ACM$V_SUBPROCESS,R5,60$; SUBPROCESS ACCOUNTING
	BRB	60$

160$:	BBCS	#ACM$V_DETACHED,R5,60$	; DETACHED PROCESS ACCOUNTING
	BRB	60$

170$:	BBCS	#ACM$V_NETWORK,R5,60$	; NETWORK PROCESS ACCOUNTING
	BRB	60$

180$:	BBCS	#ACM$V_PRINT,R5,60$	; PRINT JOB ACCOUNTING
	BRB	60$

190$:	BBCS	#ACM$V_USER_DATA,R5,60$	; USER MESSAGE ACCOUNTING
	BRB	60$

200$:
	.WORD	0
	BISL2	(AP),@#EXE$GL_ACMFLAGS
	RET
300$:
	.WORD	0
	BICL2	(AP),@#EXE$GL_ACMFLAGS
	RET
	.END
