	.TITLE	JBCSYMSUB - SYMBIONT MANAGER SUBROUTINES
	.IDENT	'V03-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET JOB CONTROLLER/SYMBIONT MANAGER
;
; ABSTRACT:	GENERAL SYMBIONT MANAGER ROUTINES
;
;
; ENVIRONMENT:	NATIVE NON-PRIVLEGED USER MODE CODE
;
; AUTHOR:  W.H.BROWN, CREATION DATE: 3-MAR-77
;
; MODIFIED BY:
;
;	V03-002	MLJ0088		Martin L. Jack,	15-Apr-1982  8:27
;		Correct problem with redirected queues introduced by V02-007.
;
;	V03-001	MLJ45274	Martin L. Jack,	10-Apr-1982  23:17
;		Use PID from message rather than sender PID in SJH record.
;
;	V02-007	GWF0142		Gary W. Fowler		28-Dec-1981
;		Avoid doing forms,characteristic, and lower testing if queue
;		is re-directed.
;
;	V02-006	GWF0081		Gary W. Fowler		16-Jul-1981
;		Change job name to ASCIC string.
;
;	V02-005	GWF0030		Gary W. Fowler		17-Apr-1981
;		Set status as jbc$_openjob in routine SYM$INIPRTJOBHD.
;
;	V02-004	GWF0004		Gary W. Fowler		25-Feb-1981
;		Clear flags and extra link words when allocating records.
;
;	V02-003	GWF0003		Gary W. Fowler		06-Dec-1979
;		Added check of dequeueing characteristics to SYM$CMPFORMS.
;
;	V02-002	GWF0002		Gary W. Fowler		29-Jun-1979
;		Added calls to SYM$CKREQPRV to check for world or group
;		privileges.
;
;	V02-001	- 
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
;
; OWN STORAGE:		THIS MODULE HAS NO LOCAL STORAGE
;


	.SBTTL	INIT PRINT JOB HEADER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SET UP THE DATA AREA IN THE
;	PRINT JOB HEADER RECORD.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$INIPRTJOBHD
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE ACCOCIATED DEVICE QUEUE DESCRIPTOR
;	R9 CONTAINS THE ADDRESS OF SYMBIONT MANAGER RECORD
;
; OUTPUT PARAMETERS:
;
;	R7 CONTAINS THE ADDRESS OF THE RECORD
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION			; PSECT FOR THIS MODULE
SYM$INIPRTJOBHD::
	BSBW	SYM$ALLRECORD		; GET A RECORD FOR THE FILE
	BLBC	R0,50$			; BR IF NON TO BE ALLOCATED
	MOVL	R2,R7			; SET RECORD ADDRESS TO PROPER REGISTER
	MOVAW	JCD_W_JOBSEQ(R11),R1	; GET ADDRESS OF JOB SEQUENCE NUMBER
	CMPW	(R1),#9999		; NUMBER BIG ENOUGH?
	BLSSU	10$			; BR IF NUMBER IS OK
	MOVZBW	#100,(R1)		; SET TO A REASONABLE NUMBER
10$:	MOVW	(R1),-JCM_T_MSGDATA+4(R9) ; SET JOB ID FOR RESPONCE
	MOVW	(R1),SJH$W_JOBSEQ(R7)	; SET JOB ID IN HEADER RECORD
	INCW	(R1)			; ADD 1 TO NUMBER
	SUBL3	R10,R6,R0		; FIND INDEX TO DEIVCE QUEUE
	MOVW	R0,SJH$W_QINDEX(R7)	; SAVE INDEX TO ASSOCIATED QUEUE
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),20$ ; BR IF THIS IS BATCH QUEUE
	MOVB	#1,SJH$B_COPYCNT(R7)	; DEFAULT TO 1 COPY FOR PRINT JOBS
20$:	MOVB	SMR$B_PROCPRI(R9),SJH$B_PRTPRI(R7) ; SET PRIORITY
	MOVL	SMR$L_PID(R9),SJH$L_PROCID(R7) ; SET PROCESS ID OF OWNER
	MOVL	SMR$L_UIC(R9),SJH$L_UIC(R7) ; STORE REQUESTORS UIC
	MOVQ	SMR$T_USERNAM(R9),SJH$T_USERNAM(R7) ; NOW USER NAME
	MOVL	SMR$T_USERNAM+8(R9),SJH$T_USERNAM+8(R7) ; NAME OF THE USER
	MOVQ	SMR$Q_ACNTNAM(R9),SJH$Q_ACNTNAM(R7) ; SET CHARGE ACCOUNT
	MOVQ	JCD_Q_TIME(R11),SJH$Q_TIME(R7) ; SAVE CURRENT TIME
	MOVL	#JBC$_OPENJOB,SJH$L_FINALSTS(R7) ; SET STATUS AS OPEN JOB
	CLRL	SJH$L_GQNMFLG(R7)	; CLEAR FLAGS WORD
	CLRL	SJH$L_QNMLNK(R7)	; LINK TO QUE NAME
	CLRL	SJH$L_LOGLNK(R7)	; LINK TO LOG FILE NAME
40$:	RSB				; RETURN TO CALLER
50$:	RET				; RETURN TO TOP LEVEL
 
 

	.SBTTL	INITIAL A PRINT FILE RECORD
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SET UP THE STANDARD PART OF A
;	PRINT JOB RECORD
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$INIPRTREC
;
; INPUT PARAMETERS:
;
;	R9 CONTAINS THE ADDRESS OF THE MESSAGE TO SYMBIONT MANAGER
;	R5 POINTS AT THE ADDRESS OF THE THE DEVICE NAME FOR THE FILE
;
; IMPLICIT INPUTS:
;
;	R7  HAS ADDRESS OF THE ASSOCIATED PRINT JOB HEADER
;	R10 HAS ADDRESS OF THE SYSTEM PRINT QUEUE GLOBAL SECTION
;
; OUTPUT PARAMETERS:
;
;	R8 CONTAINS THE ADDRESS OF THE INITIALIZE RECORD
;
; COMPLETION CODES:
;
;	R0 CONTAINS THE STATUS CODE FOR SUCESS OR FAILURE
;
; SIDE EFFECTS:		NONE
;--

SYM$INIPRTREC::
	BSBW	SYM$ALLRECORD		; GET A RECORD
	BLBC	R0,90$			; BR IF ALLOCATION FAILED
	MOVL	R2,R8			; COPY ADDRESS OF RECORD
	ASSUME	SQR$W_JOBSEQ+2 EQ SQR$W_RECID
	MOVZWL	SJH$W_JOBSEQ(R7),SQR$W_JOBSEQ(R8) ; SET JOB AND AND CLEAR RECID
	MOVC3	#16+6+6,(R5),SQR$T_VOLNAM(R8) ; SET DEVICE NAME AND FILE ID
	CMPB	(R1),#SYM_K_MAXFILNAM	; NOW CHECK FILENAME FOR LEGAL LENGTH
	BGTRU	70$			; BR IF TO BIG
	MOVC3	#SYM_K_MAXFILNAM+1,(R1),SQR$T_FILNAM(R8) ; SET FILE NAME INTO QUEUE RECORD
	MOVL	R1,R5			; SET ADDRESS OF NEXT BYTE IN MESSAGE
	MOVB	#1,SQR$B_COPYCNT(R8)	; SET COPY COUNT TO 1
	TSTL	SJH$L_RECLINK(R7)	; IS THIS FIRST JOB IN LIST?
	BNEQ	20$			; BR IF NO
	INSV	SMQ$B_CHAR(R6),-	; GET DEFAULTS FOR FLAG AND BURST PAGE
		#SQR$V_FLAGPAG,#2,-	; AND INSERT INTO RECORD
		SQR$B_FLAGS(R8)		; FLAGS AREA.
	TSTB	SJH$T_JOBNAME(R7)	; DOES THIS JOB HAVE A NAME
	BNEQ	20$			; BR IF YES
	MOVAB	SQR$T_FILNAM(R8),R3	; POINT AT FILE NAME
	MOVZBL	(R3)+,R2		; GET LENGTH OF NAME
	LOCC	#^A/./,R2,(R3)		; LOCATE START OF FILE TYPE
	SUBL	R0,R2			; ADJUST LENGTH TO ONLY FILENAME
	PUSHL	R5			; SAVE MESSAGE BUFFER POINTER
	MOVZBL	R2,SJH$T_JOBNAME(R7)	; SET LENGTH OF JOB NAME
	MOVC5	R2,(R3),#^A/ /,-	; MOVE DEFAULT NAME
		#JBC_NAM_LEN-1,SJH$T_JOBNAME+1(R7) ; INTO HEADER
	POPR	#^M<R5>			; RESTORE TEXT BUFFER POINTER
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),20$ ; BR IF QUEUE IS FOR A DEVICE
	ASSUME	SQR$B_COPYCNT EQ SQR$B_FLAGS+1 ; CHECK FOR ASSUMED ADJACENCY
	CLRW	SQR$B_FLAGS(R8)		; BATCH JOBS GET ZEROS IN THESE ENTRIES
20$:	SETSTAT	NORMAL			; SET SUCESSFUL STATUS
	RSB				; EXIT
;
; ERROR INITING RECORD-IT MUST BE RELEASED
;
60$:	SETSTAT	ILLDEVNAM,-(SP)		; SAVE ERROR CODE
	BRB	80$			; JOIN COMMON CODE
70$:	SETSTAT	ILLFILNAM,-(SP)		; SAVE ERROR CODE
80$:	MOVL	R8,R0			; SET RECORD ADDRESS
	BSBW	SYM$DEARECORD		; DEALLOCATE THE RECORD
	POPR	#^M<R0>			; RESET ERROR CODE
90$:	RSB				; RETURN TO CALLER

	.SBTTL	GET SYMBIONT MANAGER CLOSED JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO LOCATE AND REMOVE A SPECIFIC JOB
;	FOR THE PRINT QUEUE. THE JOB MUST BE CLOSED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$GETCLEJOB		; GET THE SPECIFIED CLOSED JOB
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF A WORD CONTAINING THE JOB RECORD NUMBER
;	R6 CONTAINS THE QUEUE HEADER TO WHICH THE JOB IS QUEUED
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE SYMBIONT MANAGER RECORD ADDRESS
;	R10 HAS THE BASE ADDRESS OF THE PRINT QUEUE FILE
;	R11 HAS THE JOB CONTROLLER DATA BLOCK ADDRESS
;
; OUTPUT PARAMETERS:
;
;	R7 CONTAINS THE ADDRESS OF THE JOB IN THE QUEUE SPACE
;
; IMPLICIT OUTPUTS:
;
;	IF FOUND, THE JOB IS DEQUEUED FOR THE QUEUE INWHICH IT WAS FOUND
;
; COMPLETION CODES:
;
;	R0 = NORMAL IF JOB FOUND AND DEQUEUED SUCESSFUL, OR
;	   = NOPRIV, IF THE REQUESTOR WAS NOT ALLOWED TO DEQUE THIS JOB,
;	   = NOSUCHJOB, IF THE SPECIFIED JOB WAS NOT QUEUED TO THE DEVICE.
;
; SIDE EFFECTS:
;
;	TOP LEVEL RETURN IS MADE ON ANY ERROR WITH THE PROPER CODE
;
;--
 
SYM$GETCLSJOB::				; GET THE SPECIFIED (CLOSED) JOB
	BSBB	SYM$GETHLDJOB		; FIRST CHECK THE HOLDING LIST
	BLBS	R0,40$			; BR IF FOUND IN THAT QUEUE
	PUSHAB	W^SYM$FINDCLSJOB	; INIT COROUTINE SEARCH FOR CLOSED JOBS
10$:	JSB	@(SP)+			; CONTINUE SEARCH FOR CLOSED JOBS
	BLBC	R0,50$			; BR IF CAN'T FIND THE JOB
	CLRL	R0			; ASSUME THIS JOB IS NOT WANTED
	CMPW	SJH$W_JOBSEQ(R2),(R5)	; IS THIS THE JOB WE'RE LOOKING FOR?
	BNEQ	10$			; IF NO - KEEP LOOKING
	MOVL	R2,R7			; COPY JOB HEADER TO STANDSRD PLACE
	BSBW	SYM$CKREQPRV		; DO PRIVILEGE CHECK-NO RETURN ON ERROR
	JSB	@(SP)+			; DEQUEUE THE JOB
	TSTL	(SP)+			; CLEAR CO-ROUTINE RETURN
	TSTW	(R5)+			; ADVANCE POINTER PAST JOB ID NUMBER
40$:	RSB				; AND RETURN TO CALLER
50$:	RET				; BACK TO THE TOP WITH ERROR

	.SBTTL	GET HOLD QUEUE JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SEARCH THE HOLD QUEUE FOR THE SPECIFIED
;	DEVICE FOR THE INDICATED JOB, AND DEQUEUE THE JOB IF FOUND.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$GETHLDJOB		; GET HOLDING LIST JOB
;
; INPUT PARAMETERS:
;
;	R5 POINTS AT THE JOB HEADER RECORD NUMBERIN THE REQUEST MESSAGE
;	R6 CONTAINS THE ADDRESS OF QUEUE HEADER TO SEARCH
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	R7 HAS THE ADDRESS OF THE RECORD DESIRED IN THE QUEUE FILE
;
; IMPLICIT OUTPUTS:
;
;	IF FOUND, THE RECORD IS REMOVED FROM THE HOLD LIST
;
; COMPLETION CODES:
;
;	R0 = SUCESS IF RECORD FOUND AND DEQUEUED
;	   = NOSUCHJOB IF NOT FOUND
;
; SIDE EFFECTS:
;
;	R5 IS ADVANCE OF RECORD NUMBER IN MESSAGE BUFFER
;	TOP LEVEL RET MADE IF PRIVILEGE VIOLATION
;
;--
 
SYM$GETHLDJOB::				; FIND JOB IN HOLDING LIST
	MOVAL	SMQ$L_HOLDLST(R6),R2	; SET ADDRESS OF LINK WORD
	SETSTAT	NOSUCHJOB		; SET ERROR CODE IN CASE NOT FOUND
10$:	MOVL	(R2),R7			; GET OFFSET TO JOB
	BEQL	50$			; BR IF NO MORE JOBS
	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB IN QUEUE
	CMPW	SJH$W_JOBSEQ(R7),(R5)	; IS THIS THE JOB WE ARE LOOKING FOR?
	BEQL	20$			; BR IF YES
	MOVAB	SJH$L_NEXTJOB(R7),R2	; SET ADDRESS OF JOB THREAD WORD
	BRB	10$			; LOOK AGAIN
20$:	BSBW	SYM$CKREQPRV		; CHECK IF REQUESTOR HAS PRIVILEGE
	SYM_QUECHANGE			; PRIVILEGE CHECKED OK!-FLAG A CHANGE
	MOVL	SJH$L_NEXTJOB(R7),(R2)	; CLOSE THE LIST AROUND JOB FOUND
	TSTW	(R5)+			; ADVANCE POINTER PAST JOB ID NUMBER
50$:	RSB				; BACK TO CALLER


	.SBTTL	CHECK FORMS FOR MATCH
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CHECK IF THE
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$CMPFORMS		; COMPAIR FORMS TYPE
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE HEADER OF THE QUEUE
;	R7 HAS PRINT JOB TO CHECK FORMS AGAINST HEADER
;
; IMPLICIT INPUTS:
;
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	R0 IS TRUE OR FALSE DEPENDING ON THE FORMS TYPE COMPAIRISON
;
; COMPLETION CODES:
;
;	R0 IS SET TO TRUE OR FALSE
;
; SIDE EFFECTS:		NONE
;--
 
SYM$CMPFORMS::				; COMPAIR FORMS TYPE
	PUSHL	R6			; Save SMQ pointer
	CLRL	R0			; ASSUME NO MATCH
	BITB	#<SMQ$M_GENDEV!SMQ$M_DETJOB>,- ; CHECK IF QUEUE IS FOR BATCH,
		SMQ$B_FLAGS(R6)		; OR GENERIC DEVICE
	BNEQ	20$			; BR IF EITHER-FORMS MATCH IMPLIED
	BBC	#SMQ$V_REDIRECT,-	; Br if queue is not redirected
		SMQ$B_CHAR(R6),5$
	ADDL3	SMQ$L_ASNSCT(R6),R10,R6	; Test against target of redirect
5$:	BBC	#SJH$V_LOWER,SJH$B_FLAGS(R7),10$ ; BR IF NO LOWER CASE REQUIRED
	BBC	#SMQ$V_LOWER,SMQ$B_CHAR(R6),30$  ; BR IF NOT A LOWER CASE DEVICE
10$:	CMPB	SJH$B_FORMS(R7),SMQ$B_FORMS(R6) ; ARE FORMS THE SAME?
	BNEQ	30$			; BR IF NO MATCH
	BICL3	SMQ$T_DQCHAR(R6),-	; CHECK 1ST 32
		SJH$T_DQCHAR(R7),R0
	BNEQU	15$			; BR IF NO COMPARE
	BICL3	SMQ$T_DQCHAR+4(R6),-	; CHECK NEXT 32
		SJH$T_DQCHAR+4(R7),R0
	BNEQU	15$
	BICL3	SMQ$T_DQCHAR+8(R6),-	; CHECK NEXT 32
		SJH$T_DQCHAR+8(R7),R0
	BNEQU	15$			; BR IF NO COMPARE
	BICL3	SMQ$T_DQCHAR+12(R6),-	; CHECK LAST 32
		SJH$T_DQCHAR+12(R7),R0
	BEQLU	20$			; BR TO SET TRUE RESULTS
15$:	CLRL	R0			; SET FALSE RESULTS
	BRB	30$			; RETURN
20$:	INCL	R0			; SET TRUE RESULT
30$:	POPL	R6			; Restore SMQ pointer
	RSB				; ALL DONE

	.SBTTL	CHECK REQUESTORS PRIVILEGE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CHECK IF THE REQUESTING
;	PROCESS HAS PRIVILEGE TO MANINPULATE A SPECIFIED
;	PRINT JOB.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$CKREQPRV		; CHECK THE REQUESTORS PRIVILEGE
;
; INPUT PARAMETERS:
;
;	R7 CONTAINS THE ADDRESS OF THE JOB THAT THE REQUESTOR WANTS TO DIDLE
;	R9 CONTAINS THE ADDRESS OF THE SYMBIONT MANAGER MESSAGE
;
; IMPLICIT INPUTS:
;
;	R9 HAS THE ADDRESS OF THE SYMBIONT MANAGER RECORD
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS THE ADDRESS OF THE JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:
;
;	R0 IS SET TO NORMAL IF RETURN TO CALLER
;
; SIDE EFFECTS:
;
;	TOP LEVEL RETURN MADE WITH NOPRIV IF PRIVILEGE VIOLATION OCCURRED
;
;--
 
SYM$CKREQPRV::				; CHECK FOR REQUESTORS PRIVILEGE
	BSBW	SYM$CKOPRPRV		; FIRST SEE IF REQUESTOR IS OPERATOR
	BLBS	R0,10$			; IF YES-HE CAN DO WHAT HE WANTS
	BSBW	SYM$CKWLDPRV		; CHECK IF REQUESTOR HAS WORLD PRIV.
	BLBS	R0,10$			; BR IF YES - HE CAN DO IT
	CMPL	SMR$L_UIC(R9),-
		SJH$L_UIC(R7)		; SAME USER THAT QUEUED THE JOB?
	BEQL	10$			; BR IF YES - HE CAN DO IT
	CMPW	SMR$L_UIC+2(R9),-	; IS THE REQUESTOR IN THE SAME GROUP
		SJH$L_UIC+2(R7)		; AS THE USER THAT QUEUED THE JOB?
	BNEQ	50$			; BR IF NO-RETURN NO PRIV
	BSBW	SYM$CKGRPPRV		; SAME GROUP - GROUP PRIV?
	BLBC	R0,50$			; BR IF NO - HE CAN'T DO IT
10$:	SETSTAT	NORMAL			; RETURN SUCESS STATUS
	RSB				; TO THE CALLER
50$:	RET				; RETURN NOPRIVILEGE STATUS TO TOP

	.SBTTL	GET DEVICE CHARACTERISTICS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALL TO GET THE DEVICE CHARACTERISTICS
;	FOR SOME DEVICE.  A CHANNEL IS ASSIGNED TO THE DEVICE
;	AND A "GET DEVICE CHARACTERISTICS" SYSTEM SERVICE
;	REQUEST IS ISSUED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$GETDEVCHAR
;
; INPUT PARAMETERS:
;
;	R0 CONTAINS THE ADDRESS OF A COUNTED ASCII STRING
;	OF THE DEVICE NAME
;
; OUTPUT PARAMETERS:
;
;	R2 HAS ADDRESS OF BUFFER WITH DEVICE CHARACTERISTICS
;
; COMPLETION CODES:
;
;	AS RETURNED FOR THE SYSTEM SERVICE
;
; SIDE EFFECTS:		NONE
;--
SYM$GETDEVCHAR::
	SUBL	#20,SP			; ALLOCATE SPACE FOR DEVICE NAME
	MOVL	SP,R2			; COPY START OF BUFFER
	PUSHAB	(R2)			; PUSH FIRST HALF OF DESCRIPTOR
	MOVZBL	(R0)+,R1		; GET DEVICE NAME LENGTH
	PUSHAB	2(R1)			; SET FINAL LENGTH OF DEVICE NAME
	MOVB	#^A/_/,(R2)+		; SET NO TRANSLATION FLAG
10$:	MOVB	(R0)+,(R2)+		; COPY DEVICE NAME INTO BUFFER
	SOBGTR	R1,10$			; COPY ENTIRE NAME
	MOVB	#^A/:/,(R2)+		; TERMINATE WITH A COLON
	MOVAL	JCD_Q_LBUFDES+4(R11),R1	; POINT AT SECOND 1/2 OF BUFFER DESC
	MOVL	(R1),R2			; SAVE ADDRESS OF THE BUFFER
	MOVW	-(R1),-(R1)		; RESET BUFFER LENGTH
	MOVL	SP,R0			; SAVE ADDRESS OF DEVICE NAME DESC
	$GETDEV_S (R0),,,(R1),(R1)	; ASK FOR ONLY SECONDARY DEVICE
	ADDL	#20+8,SP		; CLEAR BUFFER AND DESCRIPTOR
	RSB				;
 
	.END				;
