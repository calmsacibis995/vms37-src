	.TITLE	JBCQUEMAN - QUEUE MANAGEMENT ROUTINES
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET JOB CONTROLLER/SYMBIONT MANAGER
;
; ABSTRACT:	SYMBIONT MANAGER QUEUE MANAGEMENT ROUTINES
;
; ENVIRONMENT:	NATIVE NON-PRIVLEGED USER MODE CODE
;
; AUTHOR:  	W.H.BROWN, CREATION DATE: 3-MAR-77
;
; MODIFIED BY:
;
;	V03-001	MLJ0086		Martin L. Jack,	4-Apr-1982  3:54
;		Remove unreferenced globals.
;
;	V02-009	MLJ0075		Martin L. Jack,	31-Jan-1982  21:56
;		Correct typos in messages.
;
;	V02-008	GWF0098		Gary W. Fowler		03-Aug-1981
;		Add up file size when job is placed in queue.
;
;	V02-007	GWF0076		Gary W. Fowler		16-Jul-1981
;		Change job name to ASCIC string.
;
;	V02-006	GWF0062		Gary W. Fowler		29-Jun-1981
;		Fix problem of allocating a queue record that lies beyond the
;		end of allocated queue space.
;
;	V02-005	GWF0031		Gary W. Fowler		17-Apr-1981
;		Set status as JBC$_CLSJOB when added to queue.  Add call to
;		SYM$NOTIFY to inform logged on user that job has terminated.
;
;	V02-004	GWF0020		Gary W. Fowler		24-Feb-1981
;		Add routine and calls to it to deallocate extra records linked
;		to job header record.
;
;	V02-003	GWF0002		Gary W. Fowler		18-Mar-1980
;		Change branch instruction so submit order will be preserved
;		when a group of jobs are submitted with the same after time.
;
;	V02-002	GWF0001		Gary W. Fowler		2-Nov-1979
;		Force update of queue file when a job is inserted or removed
;		from the queue.
;
;	V02-001	-
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
	$MSGDEF				; DEFINE SYSTEM WIDE MESSAGE CODES
;
; OWN STORAGE:
;
	IMPURE_DATA
JBC$Q_USERDESC:
	.BLKQ	1			; DESCRIPTOR FOR USER NAME
JBC$Q_JOBDESC:
	.BLKQ	1			; DESCRIPTOR FOR JOB NAME
JBC$Q_BATDESC:
	.ASCID	/Batch job/		; DESCRIPTOR FOR BATCH
JBC$Q_PRNDESC:
	.ASCID	/Print job/		; DESCRIPTOR FOR PRINT

	.SBTTL	RECORD ALLOCATE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ALLOCATE A RECORD FROM THE QUEUE
;
; CALLING SEQUENCE:
;
;	BSB	SYM$ALLRECORD		; ALLOCATE A RECORD
;
; INPUT PARAMETERS:
;
;	R10 HAS BASE OF SYSTEM QUEUE SPACE
;
; OUTPUT PARAMETERS:
;
;	R2 HAS ADDRESS OF RECORD ALLOCATED
;
; COMPLETION CODES:
;
;	R0 IS 1 IF RECORD IS SUCESSFULLY ALLOCATED,ELSE 0
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION

SYM$ALLRECORD::
	MOVZBL	#SYM$K_RECSIZE,R1	; GET SIZE OF RECORD
	MOVL	(R10),R2		; GET INDEX TO FIRST RECORD IN FREE LIST
	BNEQ	10$			; BR IF RECORD IN FREE LIST
	SETSTAT	NOQUESPACE		; SET ERROR CODE
	CMPL	SQH$L_NEXTREC(R10),SQH$L_LASTREC(R10) ; HAVE ALL RECORDS BEEN ALOCATED?
	BGEQU	30$			; BR IF NO MORE-RETURN FAILURE STATUS
	ADDL3	SQH$L_NEXTREC(R10),R10,R2 ; FIND ADDRESS OF NEXT FREE RECORD
	ADDL	R1,SQH$L_NEXTREC(R10)	; UPDATE POINTER TO NEXT RECORD
	CMPL	SQH$L_NEXTREC(R10),-	; COMPARE ADDRESS OF ALLOCATED RECORD
		SQH$L_LASTREC(R10)	; TO END OF QUEUE SPACE
	BLSSU	20$			; IF LSS THEN OK
	SUBL2	R1,SQH$L_NEXTREC(R10)	; RESTORE LAST RECORD ADDRESS
	BRB	30$			; RETURN WITH ERROR
10$:	ADDL	R10,R2			; FIX UP TO REAL ADDRESS
	MOVL	(R2),(R10)		; CLOSE UP LIST
20$:	PUSHR	#^M<R2,R3,R4,R5>	; SAVE IMPORTANT REGISTERS
	MOVC5	#0,(R2),#0,R1,(R2)	; ZERO THE BUFFER
	POPR	#^M<R2,R3,R4,R5>	; RESTORE SAVED REGISTERS
	SETSTAT	NORMAL		; INDICATE RECORD ALLOCATED
30$:	RSB				;

	.SBTTL	RECORD DEALLOCATE
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A RECORD TO THE QUEUE
;
; CALLING SEQUENCE:
;
;	BSB	SYM$DEARECORD		; DEALLOCATE A RECORD
;
; INPUT PARAMETERS:
;
;	R0 IS ADDRESS TO RECORD TO RELEASE
;	R10 HAS BASE OF SYSTEM QUEUE SPACE
;
; OUTPUT PARAMETERS:	NONE
;
; IMPLICIT OUTPUTS:
;
;	RECORD IS RELEASED, MAKING IT AVAILIABLE FOR REUSE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:
;
;	R1 IS MODIFIED
;
;--

SYM$DEARECORD::
	MOVL	#SYM$K_RECSIZE/8,R1	; NUMBER OF QUAD WORDS
10$:	CLRQ	(R0)+			; ZERO CONTENTS
	SOBGTR	R1,10$			; CLEAR THE ENTIRE RECORD
	MOVAL	-SYM$K_RECSIZE(R0),R0	; RESET ADDRESS TO TOP OF RECORD
	MOVL	(R10),(R0)		; BUT OLD FIRST AS SECOND
	SUBL3	R10,R0,(R10)		; STORE INDEX TO FIRST FREE RECORD
	RSB				; ALL DONE

	.SBTTL	FREE A JOB AND CLEANUP AFTER THE JOB AS NECESSARY
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO FREE ALL RECORDS ASSOCIATED WITH A
;	PRINT OR BATCH JOB AFTER SENDING THE FINAL STATUS OF THE JOB TO
;	A WAITING PROCESS, IF ANY.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$FREEJOB
;
; INPUT PARAMETERS:
;
;	FOR FREEJOB:
;
;	R0 IS BATCH JOB FINAL STATUS
;	R7 IS THE ADDRESS OF THE JOB HEADRER
;	R10 CONTAINS THE ADDRESS OF THE PRINT QUEUE HEADER
;
;	FOR FREEPRTJOB:
;
;	R0 IS ADDRESS OF JOB TO RELEASE
;
; OUTPUT PARAMETERS:
;
;	IF THERE IS A MAILBOX CHANNEL ASSIGNED, A RESPONCE IS SENT WITH
;	THE FINAL STATUS, THE JOB ID AND NAME.
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
	.ENABL	LSB
SYM$FREEJOB::				;
	CLRB	JBC$B_QUEWRT		; FORCE UPDATE OF QUEUE FILE
	MOVZWL	SJH$W_QINDEX(R7),R6	; GET OFFSET TO QUEUE
	ADDL	R10,R6			;FIND OFFSET IN THE QUEUE
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),30$ ; BR IF NOT A BATCH QUEUE
	PUSHL	JCD_W_TMPCHAN(R11)	; SAVE CURRENT MAILBOX IF ANY
	MOVW	SJH$W_MBCHAN(R7),-	; COPY SYNC MAILBOX CHANNEL
		JCD_W_TMPCHAN(R11)	; TO THE WORK AREA
	BEQL	10$			; BR IF NO ONE IS WAITING FOR THIS JOB
	MOVAB	@JCD_A_LBUFADR(R11),R3	; POINT AT LINE BUFFER
	MOVZBW	#MSG$_SMBRSP,(R3)+	; SET MESSAGE TYPE
	MOVW	SJH$W_JOBSEQ(R7),(R3)+	; SET JOB ID FIELD
	MOVL	R0,(R3)+		; INSERT FINAL STATUS
	MOVZBL	SJH$T_JOBNAME(R7),R0	; GET LENGTH OF JOB NAME
	INCL	R0			; INCLUDE COUNT BYTE
	MOVC3	R0,SJH$T_JOBNAME(R7),(R3) ; MOVE JOB NAME TO MESSAGE
	BSBW	JBC$SNDRESP		; SEND THAT TO REQUESTING PROCESS
	$DASSGN_S JCD_W_TMPCHAN(R11)	; RELEASE THAT CHANNEL
10$:	CVTLW	(SP)+,JCD_W_TMPCHAN(R11); RESTORE PREVIOUS CHANNEL NUMBER
	MOVL	SJH$L_PARMBLK(R7),R0	; FIND ASSOCIATED PARAMETER BLOCK
	BEQL	30$			; BR IF NO PARAMETER BLOCK
	ADDL	R10,R0			; FIND THE REAL ADDRESS OF PARAM BLOCK
	BSBW	SYM$DEARECORD		; RELEASE THE RECORD
30$:	PUSHL	SJH$L_QNMLNK(R7)	; ADDR OF LINK TO QUEUE NAME RECORD
	CALLS	#1,SYM$RIDXTRA		; GET RID OF THIS RECORD IF ANY
	PUSHL	SJH$L_LOGLNK(R7)	; LINK TO LOG FILE NAME IF ANY
	CALLS	#1,SYM$RIDXTRA		; GET RID OF IT IF ANY
	CMPL	#JBC$_OPENJOB,-		; CHECK IF STATUS INDICATES
		SJH$L_FINALSTS(R7)	; JOB IS AN OPEN JOB
	BEQL	37$			; IF EQL - THEN YES, DON'T ANNOUNCE
	BBC	#SJH$V_NOTIFY,-		; IF LBC - THEN DON'T
		SJH$B_FLAGS(R7),37$	;  INFORM USER JOB IS COMPLETE
	MOVZBL	#12,JBC$Q_USERDESC	; SET LENGTH OF USER NAME IN DESCRIPTOR
	MOVAB	SJH$T_USERNAM(R7),-	; SET ADDR. OF USER NAME
		JBC$Q_USERDESC+4	;  IN DESCRIPTOR
	MOVZBL	SJH$T_JOBNAME(R7),JBC$Q_JOBDESC ; SET LENGTH OF JOB NAME
	MOVAB	SJH$T_JOBNAME+1(R7),-	; SET ADDR. OF JOB NAME
		JBC$Q_JOBDESC+4		;  IN DESCRIPTOR
	PUSHAQ	JBC$Q_PRNDESC		; ASSUME JOB IS A PRINT JOB - SET DESCR
	BBC	#SMQ$V_DETJOB,-		; IF BIT CLEAR - THEN
		SMQ$B_FLAGS(R6),35$	;  JOB IS INDEED A PRINT JOB
	MOVAQ	JBC$Q_BATDESC,(SP)	; JOB IS A BATCH JOB
35$:	PUSHL	SJH$L_FINALSTS(R7)	; JOB STATUS
	MOVZWL	SJH$W_JOBSEQ(R7),-(SP)	; JOB SEQUENCE NO.
	PUSHAQ	JBC$Q_JOBDESC		; DESCRIPTOR OF JOB NAME
	PUSHAQ	JBC$Q_USERDESC		; DESCRIPTOR OF USER NAME
	CALLS	#5,SYM$NOTIFY		; ISSUE COMPLETION MESSAGE
37$:	SUBL3	R10,R7,R0		; SET OFFSET TO FIRST RECORD IN JOB
40$:	ADDL	R10,R0			; FIND REAL ADDRESS OF RECORD
	PUSHL	SJH$L_RECLINK(R0)	; SAVE ADDRESS OF NEXT RECORD
	BSBW	SYM$DEARECORD		; RELEASE THE RECORD
	MOVL	(SP)+,R0		; GET NEXT RECORD
	BNEQ	40$			; BR WHEN MORE TO DO
	RSB				; RETURN TO CALLER
	.DSABL	LSB

	.SBTTL	DEALLOCATE EXTRA RECORDS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO DEALLOCATE RECORDS FOR THE QUEUE NAME OF THE
;	LOG FILE AND THE LOG FILE SPECIFICATION.  THESE RECORDS ARE LINKED TO
;	THE JOB HEADER RECORD.
;
; CALLING SEQUENCE:
;
;	CALLS	#1,RIDXTRA
;
; INPUT PARAMETERS:
;
;	4(AP) CONTAINS THE CONTENTS OF THE APPROPRIATE LINK WORD
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;--
SYM$RIDXTRA::
	.WORD	0
	MOVL	4(AP),R0		; LINK TO RECORD
	BEQL	40$			; IF EQL THEN NO EXTRA RECORDS
	ADDL3	R10,R0,R0		; GET REAL ADDR.
	MOVL	SQR$L_XTRALNK(R0),R0	; GET LINK TO EXTRA RECORD
	BEQL	30$			; BR IF NONE
	ADDL2	R10,R0			; GET REAL ADDR. OF RECORD 
	BSBW	SYM$DEARECORD		; GO DEALLOCATE THAT RECORD
30$:	MOVL	4(AP),R0		; GET LINK TO QUEUE NAME FOR LOG FILE
	ADDL3	R10,R0,R0		; GET REAL ADDRESS
	BSBW	SYM$DEARECORD		; GO DEALLOCATE THAT ONE
40$:	RET

	.SBTTL	INSERT JOB IN QUEUE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO INSERT A PRINT JOB INTO
;	ONE OF THE POSSIBLE LISTS.  IF THE JOB IS READY TO
;	BE PRINT, THEN IT IS INSERTED IN THE PROPER PRINT
;	QUEUE DEPENDING UPON ITS PRIORITY. ELSE IS IS
;	INSERTED INTO THE HOLD LIST FOR THE DEVICE TO
;	TO WHICH IT WAS QUEUED.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$JOBINSQUE
;
; INPUT PARAMETERS:
;
;	R7 CONTAINS THE JOB HEADER
;
; IMPLICIT INPUTS:
;
;	R10 CONTAINS THE ADDRESS OF THE SYMBIONT QUEUE FILE
;
; OUTPUT PARAMETERS:
;
;	THE JOB IS INSERTED INTO EITHER:
;
;		1) THE TIME QUEUE IF THE HOLD TIME IS SPECIFIED
;		2) THE HOLD QUEUE FOR THE ASSOCIATED DEVICE IF HOLD FLAG ON
;		3) ONE OF THE ACTIVE PRINT QUEUES DEPENDING ON THE PRIORITY
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:
;
;	REGISTERS R0 AND R1 ARE MODIFIED
;	REGISTER R6 IS SET TO THE DEVICE QUEUE HEADER ADDRESS
;
;--
	.ENABL	LSB

SYM$JOBINSQUE::
	CLRB	W^JBC$B_QUEWRT		; FORCE UDPATE OF QUEUE FILE
	CLRL	SJH$L_NEXTJOB(R7)	; ZERO LINK INCASE THIS ENDS UP LAST
	CLRL	SJH$L_FILESIZ(R7)	; ZERO FILE SIZE
	MOVL	R7,R1			; GET LINK TO FILE RECORD
5$:	MOVL	R1,R0			; SAVE IT
	MOVL	SQR$L_RECLINK(R0),R1	; GET LINK TO NEXT RECORD
	BEQL	10$			; IF EQL THEN DONE THEM ALL
	ADDL	R10,R1			; CHANGE TO REAL ADDRESS
	ADDL	SQR$L_FILESIZ(R1),-	; ADD SIZE OF THIS FILE
		SJH$L_FILESIZ(R7)	; TO TOTAL SIZE OF JOB
	BRB	5$			; LOOP THRU ALL FILE RECORDS
10$:	MOVZBL	SJH$B_COPYCNT(R7),R0	; NUMBER OF JOB COPIES
	MULL2	R0,SJH$L_FILESIZ(R7)	; MULTIPLY BY TOTAL FILE SIZE
	MOVL	#JBC$_CLSJOB,SJH$L_FINALSTS(R7) ; SET STATUS AS CLOSED
	CMPQUAD	SJH$Q_TIME(R7),-	; CHECK IF HOLD TIME FOR THE NEW JOB
		JCD_Q_TIME(R11)		; IS GREATER THAN THE CURRENT TIME
	BLEQU	SYM$INSACTQUE		; INSERT IN ACTIVE QUEUE
	MOVL	SQH$L_TIMQUE(R10),R1	; PICK UP OFFSET TO HEAD OF TIMER QUEUE
	BEQL	20$			; BR IF QUEUE IS EMPTY-INSERT THIS FIRST
	ADDL3	R10,R1,R0		; FIND REAL ADDRESS OF FIRST JOB
	CMPQUAD	SJH$Q_TIME(R7),-	; CHECK IF HOLD TIME FOR NEW JOB IS
		SJH$Q_TIME(R0)		; EARLIER THAN THE CURRENT EARLIEST
	BGEQU	40$			; BR IF NEW TIME NOT EARLIEST
	MOVL	R1,SJH$L_NEXTJOB(R7)	; LINK OLD FIRST AS NEXT AFTER NEW JOB
	$CANTIM_S  REQIDT=#JBC_K_PRTIMFLAG ; CANCEL PREVIOUS TIMER
20$:	SUBL3	R10,R7,SQH$L_TIMQUE(R10) ; SET NEW AS FIRST IN TIMER QUEUE
 
SYM$SETIMER::				; EXTERNAL ENTRY TO RESET TIMER
	$SETIMR_S  -			; START TIMER
		ASTADR = SYM$TIMAST,-	; AST PROCESSING ROUTINE
		DAYTIM = SJH$Q_TIME(R7),- ; RELEASE JOB TIME IS THE TIME
		REQIDT = #JBC_K_PRTIMFLAG   ; THE REQUEST ID IS THE EVENT FLAG
	RSB				;  * EXIT * INSERT IN TIMER QUEUE
 
40$:	MOVL	R0,R1			; SAVE LAST JOB ADDRESS
	MOVL	SJH$L_NEXTJOB(R1),R0	; FIND INDEX TO NEXT
	BEQL	60$			; BR IF THE END OF THE LIST
	ADDL	R10,R0			; FIND ADDRESS OF CURRENT JOB
	CMPQUAD	SJH$Q_TIME(R7),-	; CHECK IF THE NEW JOB HOLD TIME
		SJH$Q_TIME(R0)		; IS EARLIER THAN THIS JOB
	BGEQU	40$			; BR IF NEW LATER THAN CURRENT
	MOVL	SJH$L_NEXTJOB(R1),-	; SET THIS JOB AS NEXT AFTER
		SJH$L_NEXTJOB(R7)	; THE NEW JOB
60$:	SUBL3	R10,R7,SJH$L_NEXTJOB(R1) ; POINT PREVIOS AT NEW JOB
	RSB				; * EXIT * THE MODULE
 
	.DSABL	LSB
;
; INSERT JOB IN ACTIVE QUEUE
;
 
SYM$INSACTQUE::				; INSERT FILE IN ACTIVE QUEUE
	MOVL	#JBC$_CLSJOB,SJH$L_FINALSTS(R7) ; SET STATUS AS CLOSED
	MOVZWL	SJH$W_QINDEX(R7),R6	; GET DEVICE QUEUE INDEX
	ADDL	R10,R6			; FIND REAL ADDRESS OF QUEUE HEADER
	BBS	#SMQ$V_STOPPED,-	; IF DEVICE IS NOT STARTED
		SMQ$B_FLAGS(R6),80$	; INSERT ALL JOBS IN HOLD LIST
	BBS	#SJH$V_HOLD,-		; ALSO HOLD ANY JOBS THAT HAVE
		SJH$B_FLAGS(R7),80$	; PUT ON HOLD BY THE QUEUER
	IF_FORM_DIF	80$		; BR IF FORMS DON'T MATCH
	EXTZV	#0,#5,SJH$B_PRTPRI(R7),R0 ; GET PRINT PRIORITY FOR THE JOB
	MOVB	R0,SJH$B_PRTPRI(R7)	; MAKE SURE THE PRIORITY IS VALID
	MOVAQ	SQH$Q_QUEUE(R10)[R0],R0	; FIND PROPER PRIORITY PRINT QUEUE
	TSTL	(R0)+			; ANYTHING IN QUEUE?
	BNEQ	10$			; BR IF QUEUE IS NOT EMPTY
	SUBL3	R10,R7,(R0)		; QUEUE IS EMPTY-INSERT AS FIRST
	MOVL	(R0),-(R0)		; AND LAST
	BRB	60$			; COMMON EXIT
10$:	ADDL3	R10,(R0),R1		; FIND ADDRESS OF LAST ENTRY IN QUEUE
	CMPQUAD	SJH$Q_TIME(R7),-	; CHECK IF QUEUE TIME FOR THE NEW JOB IS
		SJH$Q_TIME(R1)		; GREATER THAN THE TIME FOR OLD LAST
	BGEQU	40$			; IF SAME FOR GREATER INSERT NEW AS LAST
	MOVAL	-(R0),R0		; GET ADDRESS OF FORWARD LINK
20$:	ADDL3	(R0),R10,R1		; FIND ADDRESS OF NEXT JOB
	CMPQUAD	SJH$Q_TIME(R7),-	; CHECK IF QUEUE TIME FOR THE NEW JOB
		SJH$Q_TIME(R1)		; IS GREATER THAN THE TIME OF THIS
	BLSSU	30$			; BR IF NEW WAS QUEUED EARLIER
	MOVAL	SJH$L_NEXTJOB(R1),R0	; SET THREAD WORD ADDRESS TO NEXT JOB
	BRB	20$			; LOOK FOR OLDER ENTRY
30$:	MOVL	(R0),SJH$L_NEXTJOB(R7)	; OPEN LINK FROM PREVIOUS TO OLD NEXT
	BRB	50$			; FINSH IN COMMON CODE
40$:	SUBL3	R10,R7,SJH$L_NEXTJOB(R1) ; SET NEW AS NEXT AFTER PREVIOUS LAST
50$:	SUBL3	R10,R7,(R0)		; SET LINK TO NEW JOB
60$:	MOVZBL	#JBC_V_SYMINIREQ,R0	; SET BIT FOR PRINT QUEUES
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),70$ ; BR IF QUEUE IS PRINT QUEUE
	MOVZBL	#JBC_V_CREJOBREQ,R0	; SET BIT FOR DETACHED JOB
70$:	SETBIT	R0,JCD_W_FLAGS(R11)	; SET PROPER FLAG
	RSB				; * EXIT *
 
;
; THIS FILE IS INSERTED IN THE HOLD QUEUE.  NOTE THAT THE
; HOLD QUEUE IS ORDERED LAST IN, FIRST OUT FOR SIMPLICITY.
;
80$:	MOVL	SMQ$L_HOLDLST(R6),-	; LINK THE PREVIOUS FIRST AFTER
		SJH$L_NEXTJOB(R7) 	; THE NEW JOB
	SUBL3	R10,R7,SMQ$L_HOLDLST(R6) ; LINK NEW JOB THIS AS CURRENT FIRST
	RSB				; *** EXIT ***
 
;+
; SYM$TIMAST - TIMER AST ROUTINE
;
; THIS ROUTINE IS ENTERED WHEN THE TIME QUEUE ENTRY COMES DUE.
; A FLAG IS SET TO CAUSE THE MAIN LINE TO SERVICE THE TIME QUEUE.
;-
 
SYM$TIMAST:				;
	.WORD	0			;
	BISW	#JBC_M_SRVTIMQUE,W^JBC$T_DATABLK+JCD_W_FLAGS ; SET THE FLAG
	$WAKE_S				; START THE MAINLINE
	RET				; DISMISS THE AST
 
	.END				;
