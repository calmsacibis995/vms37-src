	.TITLE	JBCQUECHK - CHECK PRINT QUEUE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET JOB CONTROLLER/SYMBIONT MANAGER
;
; ABSTRACT:	ROUTINE TO CHECK INTEGRITY OF THE QUEUE
;
;
; ENVIRONMENT:	NATIVE NON-PRIVLEGED USER MODE CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE:
;
; MODIFIED BY:
;
;	, : VERSION
;
;	V02-002	GWF0019		Gary W. Fowler		24-Feb-1981
;		Modify to check for extra records linked to job header
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
;
; OWN STORAGE:
;
;	NONE
;

	.SBTTL	CHECK THAT THE QUEUE IS CORRECT
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CHECKS FOR LOST OR MULTIPLY ALLOCATED RECORDS
; IN THE QUEUE FILE. IF THE FILE IS OK, OR CAN BE FIXED, IT IS 
; UPDATED TO THE DISK.  IF MULTIPLY ALLOCATED RECORDS ARE FOUND,
; THE JOB CONTROLLER IS SHUT-DOWN WITH A DUMP.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	JBC$CHKUPDQUE
;
; INPUT PARAMETERS:
;
;	R10 CONTAINS THE BASE ADDRESS OF THE QUEUE
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:
;
;	A CORRUPTED QUEUE CAN CAUSE THE JOB CONTROLLER TO RESTART ITSELF
;
;--

	PURE_SECTION
 
	.ENABL	LSB

JBC$VFYUPDQUE::				; CHECK, THEN UPDATE THE QUEUE
	TSTL	R10			; ANY QUEUE HERE?
	BEQL	3$			; BR IF NO
	SUBL3	SQH$L_FIRSTREC(R10),-	; FIND NUMBER OF BYTES IN USE
		SQH$L_NEXTREC(R10),R6	; IN THE QUEUE FILE RECORD SPACE
	DIVL	#SYM$K_RECSIZE,R6	; CHAGE THAT TO NUMBER OF RECORDS
	BNEQ	5$			; BR IF THERE IS SOMETING IN THE QUEUE
3$:	RSB				; *** EXIT IF QUEUE IS EMPTY ***
5$:	ADDL3	#7,R6,R0		; ROUND UP TO MODULO 8
	ASHL	#-3,R0,R0		; FIND NUMBER OF BYTES TO MAP FILE
	SUBL	R0,SP			; MAKE SPACE FOR BIT MAP
	PUSHL	R0			; SAVE NUMBER OF BYTES ALLOCATED
	MOVC5	#0,(SP),#0,R0,4(SP)	; ZERO THE AREA
	CLRL	R0			; SET TO 0-FIRST BIT
	MOVAB	4(SP),R5		; SET ADDRESS OF BIT ARRAY
10$:	SETBIT	R0,(R5)			; SET BITS FOR ALLOCATED RECORDS
	AOBLSS	R6,R0,10$		; SET ONE BIT FOR EACH RECORD
	MOVL	(R10),R0		; RECORD IN FREE LIST
	BEQL	20$			; BR IF NONE
	BSBW	100$			; CHECK OUT THE RECORD
20$:	MOVAL	SQH$K_SIZE(R10),R6	; SET FOR START OF CHECK
	MOVZBL	SQH$B_MAXQUE(R10),R4	; GET NUMBER OF QUEUES
	CLRL	R7			; COUNT OF NUMBER FOUND TO BE ACTIVE
30$:	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),40$ ; BR IF NOT IN USE
	INCL	R7			; COUNT UP NUMBER FOUND ACTIVE
	MOVL	SMQ$L_CURRENT(R6),R0	; GET CURRENT JOB
	BEQL	35$			; BR IF NO CURRENT JOB
	BSBW	100$			; TAKE CARE OF THE ONE PRINTING
35$:	MOVL	SMQ$L_HOLDLST(R6),R0	; HEAD OF JOB LIST
	BEQL	40$			; BR IF NOTHING HERE
	BSBW	100$			; CHECK THAT OUT
40$:	ADDL	#SMQ$K_SIZE,R6		; ADVANCE POINTER
	SOBGTR	R4,30$			; DO ALL DEVICE QUEUES
	CMPB	R7,SQH$B_NUMQUE(R10)	; DOES COUNT MATCH CURRENT TOTAL?
	BEQL	45$			; BR IF YES
	SHOW_ERROR	QUEUE_COUNT	; INDICATE THERE IS A PROBLEM
45$:	MNEGL	#2,R4			; SET INDICATOR FOR QUEUE TO SEARCH
	MOVAL	SQH$L_OPENJOB(R10),R3	; ASSUME SEARCH OPEN JOB QUEUE
50$:	INCL	R4			; COUNT UP QUEUES SEARCHED
	BGTR	60$			; BR IF WORKING ON PRINT QUEUES
	BNEQ	70$			; BR IF TIME TO SEARCH OPEN JOB
	MOVAL	SQH$L_TIMQUE(R10),R3	; SEARCH TIME QUEUE
	BRB	70$			; JOIN SEARCH
60$:	CMPL	R4,#SYM_K_PRTPRI	; HAVE ALL QUEUES BEEN SEARCHED?
	BGTR	80$			; BR IF YES
	MOVAQ	SQH$Q_QUEUE-8(R10)[R4],R3 ; GET ADDRESS OF QUEUE THREAD WORD
70$:	MOVL	(R3),R0			; FOLLOW THE LINK
	BEQL	50$			; BR IN NONE LINKED HERE
	BSBB	100$			; PROCESS THIS JOB LIST
	BRB	50$			; TRY FOR NEXT
80$:	MOVL	(SP),R1			; NUMBER OF BYTES IN THE ARRAY
85$:	TSTB	(R5)+			; LOOK FOR LOST RECORDS
	BEQL	86$			; BR IF NO RECORD(S) LOST
	BRW	200$			; TAKE THIS BRANCH IF RECORD(S) LOST
86$:	SOBGTR	R1,85$			; KEEP LOOKING
90$:	ADDL	(SP)+,SP		; CLEAR WORK AREA
	$UPDSEC_S  EFN	=#JBC_K_UPDFLG,-  ; EFN TO WAIT FOR
		INADR	=W^JBC$Q_RETADR,- ; LIMITS OF THE QUEUE ARE INPUT
		RETADR	=W^JBC$Q_UPDADR,- ; ACTUAL LIMITS UPDATED
		IOSB	=W^JBC$Q_UPDIOSB,-; IO STATUS FORM UPDATE
		UPDFLG	=#1		; SINGLE WRITER OF SECTION FLAG
	BLBC	R0,95$			; BR IF ERROR WRITING SECTION
	$WAITFR_S  #JBC_K_UPDFLG	; WAIT FOR WRITE TO COMPLETE
	BLBS	R0,99$			; BR IF NO ERROR
95$:	CHMU	#63			; REPORT ERROR
99$:	RSB				;
;
; LOCAL SUBROUTINE TO CLEAR ALL THE BITS ASSOCIATED WITH
; A LIST OF PRINT JOBS
;
100$:	ADDL3	R10,R0,R2		; FIND REAL ADDRESS OF JOB HEADER RECORD
	MOVL	SJH$L_PARMBLK(R2),R0	; GET JOB PARAMETER BLOCK
	BEQL	105$			; BR IF NONE
	BSBB	150$			; SET THE BIT
105$:	PUSHL	SJH$L_QNMLNK(R2)	; LINK TO QUEUE NAME
	CALLS	#1,CHKXTRA		; CHECK IT OUT AND ACCOUNT FOR IT
	PUSHL	SJH$L_LOGLNK(R2)	; LINK TO LOG FILE NAME
	CALLS	#1,CHKXTRA		; CHECK IT OUT AND ACCOUNT FOR IT
	SUBL3	R10,R2,R0		; RESET INDEX TO JOB HEADER
110$:	ADDL3	R10,R0,R1		; FIND REAL ADDRESS OF RECORD
	BSBB	150$			; SET THE BIT
	MOVL	SQR$L_RECLINK(R1),R0	; FOLLOW JOB LIST TO NEXT RECORD
	BNEQ	110$			; BR IF MORE FILES IN JOB
	MOVL	SJH$L_NEXTJOB(R2),R0	; GET OFFSET TO NEXT JOB
	BNEQ	100$			; DO THIS JOB
	RSB
 
150$:	SUBL	SQH$L_FIRSTREC(R10),R0	; FIND OFFSET TO RECORD
	DIVL	#SYM$K_RECSIZE,R0	; FIND RECORD NUMBER
	BBSC	R0,(R5),160$		; BR IF RECORD NOT FOUND BEFORE
	SHOW_ERROR	MULT_ALLOCATE	; TELL THAT MULTIPLE ALLOCATIONS EXIST
	BRW	JBC$RESTART		; GET A GOOD COPY RUNNING
160$:	RSB				;
 
200$:	MULL3	#8,(SP),R6		; FIND NUMBER OF BITS IN ARRAY
	MOVAB	4(SP),R5		; SET ADDRESS OF FIRST BYTE IN ARRAY
	ADDL	(SP),R5			; FIND ADDRESS OF LAST BYTE IN ARRAY+1
210$:	SUBL	#8,R6			; COUNT DOWN NUMBER OF BITS CHECKED
	BLSS	280$			; BR WHEN NO MORE
	TSTB	-(R5)			; ANY RECORDS HERE TO BE ALLOCATED
	BEQL	210$			; BR IF NO - CHECK NEXT BYTE
	MOVL	#7,R4			; SET FIRST BIT TO CHECK IN BYTE
220$:	BBCC	R4,(R5),230$		; BR IF THIS RECORD IS ALREADY ALLOCATED
	ADDL3	R4,R6,R0		; FIND RECORD NUMBER OF MISSING RECORD
	EMUL	#SYM$K_RECSIZE,R0,SQH$L_FIRSTREC(R10),R0 ; FIND BYTE OFFSET
	ADDL	R10,R0			; NOW GET THE REAL ADDRESS IN QUEUE FILE
	BSBW	SYM$DEARECORD		; PUT THE RECORD IN THE FREE LIST
230$:	SOBGEQ	R4,220$			; CHECK ALL BITS IN BYTE?
	BRB	210$			; DONE WITH THAT BYTE - CHECK NEXT
280$:	SHOW_ERROR	LOST_RECORDS	; SAY RECORDS ARE MISSING
	BRW	90$			; TAKE COMMON EXIT
;
; LOCAL ROUTINE TO CHECK FOR EXTRA RECORDS LINKED TO JOB HEADER
;
CHKXTRA:
	.WORD	0
	MOVL	4(AP),R0		; LINK TO RECORD
	BEQL	300$			; BR IF NONE
	BSBW	150$			; GO SET THE BIT
	MOVL	4(AP),R0		; GET LINK BACK
	ADDL	R10,R0			; GET REAL ADDR. OF LINK
	MOVL	SQR$L_XTRALNK(R0),R0	; LINK TO EXTRA RECORD
	BEQL	300$			; BR IF NONE
	BSBW	150$			; GO SET THE BIT
300$:	RET

	.END
