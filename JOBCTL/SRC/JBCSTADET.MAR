	.TITLE	JBCSTADET - JOB CONTROLLER START DETACHED JOB
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	JOB CONTROLLER
;
; ABSTRACT:	MODULE TO START A DETCHED JOB
;
; ENVIRONMENT:	USER MODE NATIVE CODE
;
; AUTHOR:	W.H.BROWN, CREATION DATE: 9-JUN-1977
;
; MODIFIED BY:
;
;	V03-001	MLJ0082		Martin L. Jack,	15-Mar-1982  15:31
;		Start detached processes under [1,4], not [10,40].
;
;	V02-012	MLJ0076		Martin L. Jack,	8-Feb-1982  8:36
;		Correct V02-010 by adding underscore and colon to NLA0.  Move
;		TEMPDEL bit to DELETE in DJI record so that batch command files
;		get deleted properly.
;
;	V02-011	MLJ34580	Martin L. Jack,	31-Jan-1982  21:58
;		Extend DJT record to contain job name and value of /NOTIFY so
;		that the print job for a batch log can have the same name and
;		the same /NOTIFY status as the batch job.
;
;	V02-010	GWF0125		Gary W. Fowler		11-Nov-1981
;		Change generic terminal used in creation of batch process
;		from OPAO to NLA0.
;
;	V02-009	GWF0113		Gary W. Fowler		30-Oct-1981
;		Add support for WS extent.
;
;	V02-008	GWF0101		Gary W. Fowler		18-Aug-1981
;		Change offset of location of parameters within the parameter
;		block to avoid loosing them on restart.
;
;	V02-007	GWF0077		Gary W. Fowler		16-Jul-1981
;		Change job name to ASCIC string.
;
;	V02-006	GWF0021		Gary W. Fowler		24-Feb-1981
;		Modify to send queue name and/or log file name in DJI message
;
;	V02-005	GWF0013		Gary W. Fowler		23-Feb-1981
;		Clear R0 in co-routine queue search to ensure failure status
;		is indicated if queue not found
;
;	V02-004	GWF0002		Gary W. Fowler		22-Jan-1980
;		set bit in SJH so batch job won't restart after crash.
;
;	V02-003	GWF0001		Gary W. Fowler		14-Oct-1979
;		added routine to put quota values in DJI message
;
;	V02-002	RTM0001		R.T. Martin		10-May-1979
;		Fix bug in creating non-swap batch job
;
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	$MSGDEF				; SYSTEM WIDE MESSAGE CODES
	$DJIDEF
	$DJTDEF
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
	BATCH	= <1@4>			; JOB IS A BATCH JOB
	NOSWAP	= 2			; INHIBIT SWAPPING
;
; OWN STORAGE:
;
;	NONE
;

	.SBTTL	START A DETCHED JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE IS ENTERED WHEN IS APPEARS TO BE NECESSARY
;	TO INITIATE AN ADDITIONAL DETCHED (BATCH) JOB.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	JBC$STADET
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS FOR THE QUEUE FROM WHICH JOB SHOULD
;	BE STARTED.
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION
 
	.ENABL	LSB
 
JBC$STADET::				; START A DETACHED JOB
	PUSHAB	B^100$			; INIT CO-ROUTINE ADDRESS
10$:	JSB	@(SP)+			; COROUTINE LINK FOR NEXT QUEUE
	BLBC	R0,40$			; BR IF NO MORE
	BITB	#<SMQ$M_CREPND!SMQ$M_STOPPED>,-	; CHECK IF CREATE IS PENDING OR
		SMQ$B_FLAGS(R6)		; OR DEQUEUING IS STOPPED FOR THIS QUEUE
	BNEQ	10$			; IF EITHER LOOK AT NEXT
	BSBB	200$			; INIT THE JOB
	BRB	10$			; TRY FOR NEXT QUEUE
40$:	RSB				; RETURN
 
;+
; COROUTINE TO SCAN FOR DETACHED JOB QUEUES
;
; INPUTS:	NONE
;
; OUTPUTS:	R6 IS ADDRESS OF NEXT DETACHED JOB QUEUE LIST HEADER.
;
; SIDE EFFECTS:	R8 IS USED AND MUST BE PRESERVED BY CALLER.
;-
 
100$:	MOVAB	SQH$K_SIZE-SMQ$K_SIZE(R10),R6 ; POINT AT START OF QUEUE SPACE
	MOVZBL	SQH$B_MAXQUE(R10),R8	; GET NUMBER OF BUSY QUEUES
110$:	CLRL	R0			; ASSUME SEARCH WILL FAIL
	ADDL	#SMQ$K_SIZE,R6		; POINT AT NEXT QUEUE
	BBC	#SMQ$V_INUSE,SMQ$B_FLAGS(R6),130$ ; BR IF NOT IN USE
	BBC	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),130$ ; BR IF NOT DETACHED JOB
	INCL	R0			; SET SUCESSFUL FIND
	JSB	@(SP)+			; CO-ROUTINE LINK
130$:	SOBGTR	R8,110$			; TRY NEXT
	CLRL	R0			; SET FAILURE
140$:	RSB				;
 
;+
; SUBROUTINE TO INITIATE A DETACHED JOB 
;
; INPUTS:	R6 IS ADDRESS OF QUEUE HEADER
;
; OUTPUTS:	THE JOB IS STARTED
;
; SIDE EFFECTS:	R0 - R4 ARE USED
;-
 
190$:	.LONG	6,.+4			; DESCRIPTOR
	.ASCII	\_NLA0:\		; THE GENERIC TERMINAL
 
200$:	CMPB	SMQ$B_JOBCNT(R6),-	; CHECK IF CURRENT JOB COUNT AGAINST
		SMQ$B_JOBLIM(R6)	; JOB LIMIT FOR THIS QUEUE
	BGEQU	140$			; BR IF CAN'T START JOB
	BSBW	SYM$FINDACTJOB		; SEARCH FOR JOB READY TO START
	BLBC	R0,140$			; BR IF NONE TO START IN THIS QUEUE
	PUSHR	#^M<R2,R3,R4>		; SAVE CRITICAL VALUES FOR QUEUE SEARCH
	MOVL	R2,R7			; COPY JOB HEADER ADDRESS
	SUBL	#8,SP			; MAKE BUFFER FOR JOB NUMBER
	MOVAB	(SP),R2			; SET ADDRESS OF BUFFER
	PUSHL	#^A/_JOB/		; SET JOB NAME PREFIX
	MOVZWL	SJH$W_JOBSEQ(R7),R0	; GET JOB SEQUENCE NUMBER
	BSBW	JBC$BIN2ASC		; CONVERT TO ASCII STRING
	PUSHAL	(SP)			; ADDRESS OF NAME STRING
	SUBL3	(SP),R2,-(SP)		; FIND LENGTH OF NAME
	MOVAQ	(SP),R5			; SET NAME FOR OUTPUT AND RPOCESS
	MOVL	#BATCH,R2		; SET BATCH JOB FLAG
	BBC	#SMQ$V_NOSWAP,SMQ$B_CHAR(R6),210$ ; BR IF JOB SHOULD BE SWAPPED
	SETBIT	NOSWAP,R2		; OR IN THE FLAG FOR NO SWAPPING
210$:	EXTZV	#SMQ$V_INIPRI,#SMQ$S_INIPRI,-
		SMQ$B_CHAR(R6),R1	; EXTRACT INITIAL JOB PRIORITY
	BNEQ	220$			; BR IF PRIORITY SUPPLIED
	MOVZBL	@#SYS$GB_DEFPRI,R1	; SET SYSTEM DEFINED PRIORITY
220$:	$CREPRC_S	-		; CREATE A PROCESS
		INPUT=	190$,-		; DEIVICE INPUT IS TERMINAL
		OUTPUT=	(R5),-		; AND FOR THE DEVICE OUTPUT
		ERROR=	(R5),-		; ERROR EQUALS OUTPUT
		BASPRI=	R1,-		; INITIAL PRIORITY OF JOB
		STSFLG=	R2,-		; AND THE PROCESS FLAGS
		PIDADR= SJH$L_PROCID(R7),- ; PLACE TO STORE PROCESS ID
		PRCNAM=	(R5),-		; ESTABLISH PROCESS NAME=OUTPUT
		IMAGE=	W^JBC$Q_LOGIN,-	; IMAGE TO RUN IS LOGIN
		PRVADR=	W^JBC$Q_PRIVMASK,-; PROCESS DEFAULT PRIVLEDGE
		UIC=#<1@16+4>		; UIC IS [1,4]
	ADDL	#<8+4+8>,SP		; CLEAR THE STACK
	POPR	#^M<R2,R3,R4,R5>	; POP VALUES PLUS COROUTINE LINK
	BLBC	R0,240$			; FORGET IT IF CREATE FAILED
	JSB	(R5)			; RETURN TO REMOVE RECORD FROM QUEUE
	TSTL	(SP)+			; REMOVE COROUTINE LINK
	BISB	#SMQ$M_CREPND,SMQ$B_FLAGS(R6) ; INDICATE CREATE IS OUTSTANDING
	MOVL	SMQ$L_CURRENT(R6),-	; SET FIRST IN LIST OF CURRENT JOBS AS
		SJH$L_NEXTJOB(R7)	; NEXT AFTER THIS JOB IN ACTIVE LIST
	SUBL3	R10,R7,SMQ$L_CURRENT(R6) ; SET PENDING AS FIRST IN LIST
	INCB	SMQ$B_JOBCNT(R6)	; COUNT NUMBER OF JOBS RUNNING
	$CMKRNL_S B^250$		; COUNT UP BATCH JOBS
240$:	RSB				;
 
250$:	.WORD	0			; KERNAL MODE ENTRY MASK
	INCW	@#SYS$GW_BJOBCNT	;
	RET

	.SBTTL	FIND DETACHED JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO FIND THE DETACHED JOB QUEUE ENTRY
;	ASSOCIATED WITH A PARTICULAR PROCESS.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$FINDETJOB
;
; INPUT PARAMETERS:
;
;	R1 CONTAINS THE PROCESS ID
;
; OUTPUT PARAMETERS:
;
;	R1 CONTIANS NONE ZERO VALUE IF NOT FIRST JOB IN QUEUE
;	R5 CONTAINS THE LINK WORD TO THIS JOB
;	R6 CONTAINS THE QUEUE HEADER ASSOCIATED WITH THE JOB
;	R7 CONTAINS THE JOB HEADER ADDRESS
;
; IMPLICIT OUTPUTS:
;
;	'Z' IS SET IF THIS IS THE FIRST JOB IN THE QUEUE
;
; COMPLETION CODES:
;
;	R0 CONTAINS TRUE IF JOB IS FOUND, ELSE FALSE
;
; SIDE EFFECTS:
;
;	REGISTERS R0,R1,R4,R5,R6,R8 ARE USED
;--
 
SYM$FINDETJOB::				; FIND A DETACHED JOB
	PUSHL	#0			; SET FLAG OF FIRST JOB IN QUEUE
	PUSHAB	100$			; INIT COROUTINE TO FIND QUEUE
300$:	JSB	@(SP)+			; GET ADDRESS OF NEXT DETACHED QUEUE
	BLBC	R0,350$			; BR IF DIDN'T FIND JOB
	MOVAL	SMQ$L_CURRENT(R6),R5	; SET ADDRESS OF LINK WORD
	CLRL	4(SP)			; SET START ANOTHER JOB FLAG
320$:	MOVL	(R5),R7			; GET OFFSET TO NEXT JOB
	BEQL	300$			; BR IF NO MORE JOBS
	ADDL	R10,R7			; FIND REAL ADDRESS
	CMPL	R1,SJH$L_PROCID(R7)	; IS THIS THE JOB?
	BEQL	340$			; BR IF YES
	INCL	4(SP)			; CLEAR START ANOTHER FLAG
	MOVAL	SJH$L_NEXTJOB(R7),R5	; SET LINK WORD ADDRESS
	BRB	320$			; CHECK NEXT
340$:	TSTL	(SP)+			; CLEAR CO-ROUTINE RETURN ADDRESS
350$:	MOVL	(SP)+,R1		; GET FIRST JOB IN QUEUE FLAG
	RSB				; RETURN WITH 'Z' SET IF FIRST JOB
	.PAGE
	.SBTTL	NEXT FILE FOR A DETCHED JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN A DETACHED JOB INDICATES THAT IT
;	IS READY FOR ITS NEXT JOB COMMAND FILE.  A SPECIAL CASE IS
;	WHEN THIS IS THE FIRST JOB FOR THE PROCESS.
;
; CALLING SEQUENCE:
;
;	ENTERED FROM THE SYMBIONT MANAGER DISPATCHER WITH A CASE FOLLOWING A
;	CALL.
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS FOR THE QUEUE FROM WHICH JOB SHOULD
;	BE STARTED.
;
; OUTPUT PARAMETERS:	NONE
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
 
SYM$NXTJOBSTEP::			; NEXT FILE FOR DETACHED JOB
	MOVAB	@JCD_A_LBUFADR(R11),R3	; POINT AT DATA BUFFER
	MOVZWL	#MSG$_ABOOPR,(R3)+	; ASSUME OPERATION SHOULD BE ABORTED
	MOVL	SMR$L_PROCID(R9),R1	; GET PROCESS ID OF BATCH JOB
	BSBB	SYM$FINDETJOB		; FIND THE JOB
	BLBS	R0,401$			; IF LBS THEN FOUND JOB
	BRW	460$			; BR IF DIDN'T FIND IT
401$:	BNEQ	420$			; BR IF NOT FIRST JOB IN THIS QUEUE
	BBSC	#SMQ$V_CREPND,SMQ$B_FLAGS(R6),420$ ; BR IF CREATE PENDING
	INCL	R1			; FLAG NO CREATE NECESSARY
420$:	MOVL	SJH$L_RECLINK(R7),R8	; GET OFFSET TO RECORD
	BNEQ	421$			; CONTINUE WITH JOB
	BRW	470$			; TELL JOB TO EXIT
421$:	PUSHL	R1			; SAVE INITIATE NEW JOB FLAG
	ADDL	R10,R8			; FIND ADDRESS OF JOB RECORD
	MOVW	#MSG$_INIOPR,-4(R3)	; SET MESSAGE TYPE INTO BUFFER
	MOVZBW	SQR$B_FLAGS(R8),-2(R3)	; DELETE FILE FLAG
	BBCC	#SQR$V_TEMPDEL,-2(R3),422$ ; Br if not /DELETE, clear TEMPDEL
	BISB2	#SQR$M_DELETE,-2(R3)	; Set DELETE
422$:	ASSUME	SJH$L_UIC+4  EQ SJH$T_USERNAM
	ASSUME	SJH$L_UIC+16 EQ SJH$Q_ACNTNAM
	MOVC3	#<4+12+8>,SJH$L_UIC(R7),(R3) ; INSERT UIC, NAME AND ACCOUNT
	ASSUME	SQR$T_VOLNAM+16 EQ SQR$W_FILNUM
	ASSUME	SQR$T_VOLNAM+22 EQ SQR$W_DIRNUM
	ASSUME	SQR$T_VOLNAM+28 EQ SQR$T_FILNAM
	MOVC3	#<16+6+6>,-		; COPY DEVICE, FILE AND DIRECTORY ID'S -
		SQR$T_VOLNAM(R8),(R3)	; INTO SYMBIONT INIT MESSAGE
	MOVC3	#JBC_NAM_LEN,-		; MOVE JOB NAME
		SJH$T_JOBNAME(R7),(R3)	; INTO MESSAGE
	MOVL	SQR$L_RECLINK(R8),-	; REMOVE JOB FROM LIST
		SJH$L_RECLINK(R7)	;
	BSBW	PUT_QUOTAS		; PUT QUOTAS IN MESSAGE
	SYM_QUECHANGE
	CLRB	JBC$B_QUEWRT		; FORCE UPDATE OF QUEUE FILE
	BISB	#SJH$M_NOSTRT,SJH$B_FLAGS(R7)
					; SET NO RESTART BIT
430$:	MOVL	R8,R0			; COPY JOB FILE RECORD ADDRESS
	BSBW	SYM$DEARECORD		; AND GET RID OF THAT RECORD
	MOVL	SJH$L_PARMBLK(R7),R8	; GET COMMAND PARAMETERS
	BNEQ	435$			; BR IF THERE ARE SOME
	MOVC3	#SYM$K_RECSIZE,#0,(R3)	; FILL PARAMETER SPACE WITH ZEROS
	BRB	440$			; CONTINUE
435$:	ADDL	R10,R8			; FIND REAL ADDRESS
	MOVC3	#SYM$K_RECSIZE-8,-	; MOVE PARAMETERS
		SJH$L_NEXTJOB(R8),(R3)	; INTO INITIATE MESSAGE
	ASSUME	SJH$L_NEXTJOB EQ 8
	CLRQ	(R3)+			; ADJUST POINTER INTO INITIATE MESSAGE
	CLRL	SJH$L_PARMBLK(R7)	; ONLY USE IT ONCE
	MOVL	R8,R0			; ADDR. TO PROPER REGISTER
	BSBW	SYM$DEARECORD		; GET RID OF THAT RECORD
440$:	MOVL	SJH$L_GQNMFLG(R7),R0	; GET FLAGS WORD FROM JOB HEADER
	MOVL	R0,(R3)+		; PUT IN MESSAGE SENT TO LOGINOUT
	BBC	#SJH$V_LFSPRES,R0,450$	; IF BIT CLEAR THEN NO LOG FILE
	MOVL	SJH$L_LOGLNK(R7),R8	; GET LINK TO LOG FILE NAME
	ADDL	R10,R8			; MAKE INTO REAL ADDR.
	MOVZBL	SQR$L_DATALOC(R8),R1	; GET LENGTH OF LOG FILE NAME
	INCL	R1			; INCLUDE COUNT BYTE
	CLRL	-(SP)			; SET NO. OF EXTRA BYTES TO 0
	CMPB	R1,#SYM_K_MAXQLEN	; TOO LONG FOR ONE RECORD?
	BLEQU	442$			; IF LEQ THEN FITS IN ONE RECORD
	MOVL	R1,(SP)			; SAVE TOTAL NUMBER OF BYTES
	MOVL	#SYM_K_MAXQLEN,R1	; NO. OF BYTES TO MOVE
442$:	MOVC3	R1,SQR$L_DATALOC(R8),(R3) ; MOVE TO MESSAGE
	MOVL	(SP)+,R1		; GET TOTAL LENGTH BACK
	BEQL	444$			; IF EQL THEN NO MORE TO MOVE
	MOVL	SQR$L_XTRALNK(R8),R8	; GET LINK TO NEXT RECORD
	ADDL	R10,R8			; GET ACTUAL ADDRESS
	SUBL	#SYM_K_MAXQLEN,R1	; NO. OF BYTES TO MOVE
	MOVC3	R1,SQR$L_DATALOC(R8),(R3) ; MOVE TO MESSAGE
444$:	CLRB	(R3)+			; END IT WITH A ZERO
450$:	TSTL	(SP)+			; SHOULD A RESTART BE ATTEMPTED
	BNEQ	460$			; BR IF NO
	PUSHL	R3			; SAVE MESSAGE POINTER
	BSBW	200$			; TRY TO INITIATE A JOB
	POPR	#^M<R3>			; RESTORE THAT ADDRESS
460$:	BSBW	JBC$SNDRESP		; SEND RESPONCE TO BATCH PROCESSOR
	RET				;
;
; JOB IS FINISHED - SEND FLAGS AND QUEUE NAME
;
470$:	BSBW	MOVQNAM			; MOVE QUEUE NAME INTO MESSAGE
	BSBW	JBC$SNDRESP		; SEND TO LOGINOUT
	RET

	.DSABL	LSB
;
; MOVE QUEUE NAME INTO MESSAGE SENT TO LOGINOUT
;
MOVQNAM:
	MOVL	SJH$L_GQNMFLG(R7),R1	; Get flag bits
	BBC	#SJH$V_NOTIFY,SJH$B_FLAGS(R7),35$ ; Br if /NONOTIFY
	BBSS	#DJT$V_NOTIFY,R1,35$	; Set bit in message
35$:	MOVL	R1,(R3)+		; Set flag bits in message
	CLRL	R1			; Assume null queue name
	BBC	#SJH$V_QNMPRES,-	; IF BIT CLEAR THEN
		SJH$L_GQNMFLG(R7),40$	; NO QUEUE NAME TO SEND
					; BR IF NO QUEUE NAME TO SEND
	MOVL	SJH$L_QNMLNK(R7),R0	; GET LINK TO QUEUE NAME
	ADDL	R10,R0			; GET REAL ADDR. OF RECORD
	MOVZBL	SQR$L_DATALOC(R0),R1	; GET LENGTH OF QUEUE NAME
	INCL	R1			; INCLUDE COUNT BYTE IN LENGTH
40$:	MOVC5	R1,SQR$L_DATALOC(R0),-	; MOVE QUEUE NAME TO MESSAGE
		#0,#16,(R3)
	MOVZBL	SJH$T_JOBNAME(R7),R1	; Get length of job name
	INCL	R1			; Include count byte in length
	MOVC5	R1,SJH$T_JOBNAME(R7),-	; Move job name to message
		#0,#10,(R3)
	RSB
;
; PROCESS QUOTAS
;
PUT_QUOTAS:
	MOVL	R3,R1			; SAVE POINTER TO QUOTA FLAGS
	CLRW	(R3)+			; ASSUME NO QUOTAS
;
; PROCESS WORKING SET QUOTA
;
	MOVW	#^X0FFFF,R0		; SET QUOTA BIGGEST EVER
	BBC	#SMQ$V_WSQUTA,SMQ$W_QUOFLG(R6),10$	; BR IF NO QUOTA IN QD
	MOVW	SMQ$W_WSQUTA(R6),R0	; ASSUME USING VALUE IN QD
	BISW2	#DJI$M_WSQPRS!DJI$M_USEWSQ,(R1)	; SET VP & USE BITS
10$:	BBC	#SJH$V_WSQUTA,SJH$W_QUOFLG(R7),20$	; BR IF NONE IN SJH
	BISW2	#DJI$M_WSQPRS,(R1)	; SET VALUE PRESENT BIT
	CMPW	SJH$W_WSQUTA(R7),R0	; COMPARE QUOTAS
	BGTRU	20$			; BR IF OK
	MOVW	SJH$W_WSQUTA(R7),R0	; USE SMALLER OF THE TWO
20$:	MOVW	R0,(R3)+		; MOVE QUOTA INTO DJI MESSAGE
;
; PROCESS WORKING SET DEFAULT
;
	MOVW	#^X0FFFF,R0		; SET BIGGEST EVER
	BBC	#SMQ$V_WSDFLT,SMQ$W_QUOFLG(R6),30$	; BR IF NONE IN QD
	MOVW	SMQ$W_WSDFLT(R6),R0	; ASSUME USING VALUE IN QD
	BISW2	#DJI$M_WSDPRS!DJI$M_USEWSD,(R1)	; SET VP & USE BITS
30$:	BBC	#SJH$V_WSDFLT,SJH$W_QUOFLG(R7),40$	; BR IF NONE IN SJH
	BISW2	#DJI$M_WSDPRS,(R1)	; SET VALUE PRESENT BIT
	CMPW	SJH$W_WSDFLT(R7),R0	; COMPARE
	BGTRU	40$			; BR IF OK
	MOVW	SJH$W_WSDFLT(R7),R0	; USE SMALLER OF TWO
40$:	MOVW	R0,(R3)+		; SET VALUE IN DJI MESSAGE
;
; PROCESS WORKING SET EXTENT
;
	MOVW	#^X0FFFF,R0		; SET QUOTA BIGGEST EVER
	BBC	#SMQ$V_WSEXTNT,SMQ$W_QUOFLG(R6),42$	; BR IF NO EXTENT IN QD
	MOVW	SMQ$W_WSEXTNT(R6),R0	; ASSUME USING VALUE IN QD
	BISW2	#DJI$M_WSEPRS!DJI$M_USEWSE,(R1)	; SET VP & USE BITS
42$:	BBC	#SJH$V_WSXTNT,SJH$W_QUOFLG(R7),44$	; BR IF NONE IN SJH
	BISW2	#DJI$M_WSEPRS,(R1)	; SET VALUE PRESENT BIT
	CMPW	SJH$W_WSEXTNT(R7),R0	; COMPARE QUOTAS
	BGTRU	44$			; BR IF OK
	MOVW	SJH$W_WSEXTNT(R7),R0	; USE SMALLER OF THE TWO
44$:	MOVW	R0,(R3)+		; MOVE QUOTA INTO DJI MESSAGE
; PROCESS TIME LIMITS
;
	CLRL	R0			; SET ASSUMED TIME = 0
	CLRL	-(SP)			; SET ASSUMED TIME = 0
	BBC	#SJH$V_CPULIM,SJH$W_QUOFLG(R7),50$	; BR NO VALUE IN SJH
	MOVL	SJH$L_CPULIM(R7),R0	; ASSUME USING VALUE ON SUBMIT
	MOVL	R0,(SP)			; SAVE FOR MOVING TO MESSAGE
	BRB	55$			; GO CHECK FOR MAX TIME LIMIT
50$:	BBC	#SMQ$V_DCPULM,SMQ$W_QUOFLG(R6),60$	; BR IF NO DEFAULT TIME
	MOVL	SMQ$L_DCPULM(R6),R0	; ASSUME USING DEFAULT VALUE
	MOVL	R0,(SP)			; SAVE FOR MOVING TO MESSAGE
55$:	BISW2	#DJI$M_TIMPRS,(R1)	; SET VALUE AS PRESENT
60$:	BBC	#SMQ$V_MCPULM,SMQ$W_QUOFLG(R6),80$	; BR NO MAX SPECIFIED
	BISW2	#DJI$M_TIMPRS!DJI$M_USETIM,(R1)	; SET TO USE VALUE IN DJI
	MOVL	SMQ$L_MCPULM(R6),R1	; GET MAX TIME LIMIT
	DECL	R1			; SET TO MAX UNSIGNED IF INFINITE
	DECL	R0			; SET TO MAX UNSIGNED IF INFINITE
	CMPL	R1,R0			; COMPARE MAX TO DEFAULT OR SUBMIT
	BGTRU	80$			; BR IF MAX IS GREATER
	MOVL	SMQ$L_MCPULM(R6),(SP)	; GET MAX VALUE
80$:	MOVL	(SP)+,(R3)+		; SET VALUE IN MESSAGE

	RSB

	.PAGE
	.SBTTL	SEND QUEUE NAME TO LOGINOUT
;++
; FUNCTIONAL DESCRIPTION
;
;	THIS ROUTINE IS CALLED AS A RESPONSE TO A MESSAGE RECEIVED FROM
;	LOGINOUT IN THE EVENT A BATCH JOB TERMINATES WITH A FATAL ERROR STATUS
;
; CALLING SEQUENCE:
;
;	JSB/BSB SYM$SENDQUE
;
; INPUT PARAMETERS:
;
;	R1  CONTAINS THE PROCESS ID OF THE PROCESS
;	R9  CONTAINS A POINTER TO THE MESSAGE RECEIVED
;	R11 CONTAINS THE ADDRESS OF THE JOB CONTROLLER'S DATA AREA
;
; OUTPUT PARAMETERS:
;
;	QUEUE NAME TO PUT LOG FILE INTO IS SENT
;
SYM$SENDQUE::
	MOVAB	@JCD_A_LBUFADR(R11),R3	; ADDR. OF MESSAGE BUFFER
	MOVZWL	#MSG$_ABOOPR,(R3)+	; SET MESSAGE TYPE FOR DRILL
	MOVL	SMR$L_PROCID(R9),R1	; PROCESS ID TO R1
	BSBW	SYM$FINDETJOB		; SEARCH FOR THE JOB
	BLBC	R0,10$			; IF LBC - THEN JOB NOT FOUND
	BSBW	MOVQNAM			; MOVE QUEUE NAME
10$:	BSBW	JBC$SNDRESP		; SEND MESSAGE
	RET				; RETURN
	.END
