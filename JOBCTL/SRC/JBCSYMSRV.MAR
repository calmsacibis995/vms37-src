	.TITLE	JBCSYMSRV - SYMBIONT SERVICE MODULE
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	STARLET JOB CONTROLLER/SYMBIONT MANAGER
;
; ABSTRACT:	SYMBIONT SERVICE MODULE
;
;
; ENVIRONMENT:	NATIVE NON-PRIVLEGED USER MODE CODE
;
; AUTHOR:  W.H.BROWN, CREATION DATE: 15-MAR-77
;
; MODIFIED BY:
;
;	V03-001	MLJ0082		Martin L. Jack,	15-Mar-1982  20:15
;		Translate internal symbiont completion status to standard
;		system status in accounting record.
;
;	V02-015	MLJ0076		Martin L. Jack,	6-Feb-1982  12:43
;		Force queue file update on every change.  Delete unreferenced
;		global symbols.
;
;	V02-014	SPF0057		Steve Forgey		04-Jan-1981
;		Report print job priority to accounting.
;
;	V02-013	GWF0122		Gary W. Fowler		05-Nov-1981
;		Correct problem of deleting files when doing multiple copies
;		of an entire job.
;
;	V02-012	SPF0044		Steve Forgey		02-Oct-1981
;		Add record/packet version to ACR$W_TYPE.
;
;	V02-011	SPF0032		Steve Forgey		18-Sep-1981
;		Fix print job queue time bug.
;
;	V02-010	SPF0020		Steve Forgey		28-Aug-1981
;		Add new accounting logic.
;
;	V02-009	GWF0080		Gary W. Fowler		16-Jul-1981
;		Change job name to ASCIC string.
;
;	V02-008	GWF0058		Gary W. Fowler		11-Jun-1981
;		In SYM$REQUE, set new priority and queue index.
;
;	V02-007	GWF0042		Gary W. Fowler		08-May-1981
;		Modify to update file size as files in job are completed.
;
;	V02-006	GWF0029		Gary W. Fowler		17-Apr-1981
;		Save final status of print job in job header record before
;		calling routine to free job records.
;
;	V02-005	GWF0005		Gary W.Fowler		25-Feb-1981
;		Change call to SYM$FREEPRTJOB to a call to SYM$FREEJOB so any
;		extra records will be deallocated.
;
;	V02-004	GWF0004		Gary W.Fowler		30-Nov-1979
;		Added routines to find an empty entry in and search for a name
;		in the symbiont name table.  Added other support for multiple
;		symbiont types.
;
;	V02-003	GWF0003		Gary W. Fowler		29-Jun-1979
;		Fixed STOP/REQUEUE problem of leaving current job in queue.
;
;	V02-002	RTM0002		R T Martin		12-Mar-1979
;		Fix global section update problem
;
;	V02-001	- 
;--
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[235,10]J/ML
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
	JBCPARDEF			; DEFINE JOB CONTROLLER PARAMETERS
	JBCQUEDEF			; DEFINE QUEUE OFFSETS
	JBCSCTDEF			; SYMBIONT CONTROL TABLE DEFINITIONS
	$MSGDEF				; SYSTEM WIDE MESSAGE CODES
	$ACMDEF				; ACCOUNT MESSAGE DEFINITIONS
	$ACRDEF				; ACCOUNT RECORD DEFINITIONS

;
; Print job termination status
;
MOD$_SUCCESS=	1			; Success
MOD$_ABORT=	4			; Job aborted
MOD$_GETERR=	12			; $GET error on input file
MOD$_PRTERR=	20			; Output error
MOD$_OPNERR=	28			; $OPEN error on input file
;


	.SBTTL	SYMBIONT SERVICE DISPATCHER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO INITIATE SERRVICE OF AN IDLE SYMBIONT
;
; CALLING SEQUENCE:
;
;	JSB/BSB	JBC$SYMBSERV		; ENTER FROM JOB CONTROLLER
;	JSB/BSB	SYM$SYMBSERV		; ENTER WITH SCT IN R2
;
; INPUT PARAMETERS:
;
;	R2 CONTAINS THE ADDRESS OF THE SYMBIONT CONTROL TABLE
;	FOR WHICH SERVIE IS REQUIRED
;
; OUTPUT PARAMETERS:
;
;	THE SYMBIONT IS ASSIGNED ANOTHER JOB, OR IS PUT IN WORK POOL.
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
	PURE_SECTION

JBC$SYMBSERV::				; SERVICE PRINT SYMBIONT
	MOVL	R2,R5			; SET ADDRESS OF SCT
SYM$SYMBSERV:				; ALTERNATE ENTRY WITH SCT IN R5
	CLRB	W^JBC$B_QUEWRT		; Force queue file update
	CASE	SCT_B_STATE(R5),<-	; DISPATCH ON SYMBIONT STATE
		SYM$NXTSYM,-		; UNEXPECTED SYMBIONT DELETE
		SYM$SYMBINIT,-		; SYMBIONT JUST INITED
		SYM$NXTJOB,-		; JOB MUST BE DEQUEUED
		SYM$NXTFIL,-		; READY FOR NEXT FILE
		SYM$TRMJOB,-		; TERMIATE THE JOB
		SYM$ABOJOB,-		; JOB ABORT ISSUED
		SYM$REQUE,-		; REINSERT THE JOB IN THE QUEUE
		14$,-			; SUSPEND IS NOP STATE
		>-
		TYPE=B,-		; CASE BYTE
		LIMIT=#0		; LOW VALUE IN CASE
		
	SHOW_ERROR	ILL_SYM_STATE	; BAD SYMBIONT STATE
14$:	RSB				;

	.SBTTL	SYMBIONT INITIALIZATION ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS EXECUTED IN ORDER TO COMLETE THE INITIALIZATION
; OF AN OUTPUT SYMBOINT. THE SYMBIONT WAS CREATED, WAS RESPONDED 
; WITH IS MAILBOX UNIT NUMBER. THIS NUMBER WAS SAVED BY THE MESSAGE
; AST ROUTINE IN THE ASSOCIATED SYMBIONT CONTROL TABLE.
; A CHANNEL IS ASSIGNED TO THAT MAILBOX, AND THE STATE IS
; INCREMENTED BY 1, THEREFORE, INDICATING THE SYMBIONT IS
; READY TO TAKE ON A JOB. THEN DEQUEUE JOB IS ENTERED.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$SYMBINIT
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE SYMBIONT CONTROL TABLE
;
; OUTPUT PARAMETERS:
;
;	THE SYMBIONT IS INITED AND ASSIGNED A JOB IF THERE IS ONE.
;	A CHANNEL IS ASSIGNED TO THE SYMBIONT MAILBOX
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--

SYM$SYMBINIT:				; SYMBIONT INITIALIZTION COMPLETION
	MOVAW	SCT_W_MBCHAN(R5),R1	; ADDRESS TO STORE CHANNEL
	MOVW	(R1),R0			; GET THE CHANNEL SAVED IN THE AST
	BSBW	JBC$ASSIGNMB		; ASSIGN THE DEVICE
	CHECK_ERROR  ASSIGN_SYMB_MB	; REPORT ERROR IF 1 ASSIGNING MAILBOX
	INCB	SCT_B_STATE(R5)		; SET STATE TO READY FOR JOB
	BRB	SYM$NXTJOB		; FIND SOMETHING FOR THIS GUY TO DO

	.SBTTL	DEQUEUE NEXT JOB
;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS CALLED TO DEQUEUE THE NEXT JOB FOR A SYMBIONT
; TO PRINT.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$NXTJOB
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF SYMBIONT CONTROL BLOCK TO
;	PRINT THE JOB
;
; OUTPUT PARAMETERS:
;
;	THE SYMBIONT IS ASSIGNED A JOB OR IS PUT IN THE WAIT QUEUE.
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--

SYM$NXTJOB:				; DEQUE NEXT JOB FOR SYMBIONT
	MOVL	SCT_L_PNMTAB(R5),R0	; GET POINTER TO SCT
	CMPB	CURSYMB(R0),CURPDEV(R0)	; MORE SYMBIONTS THAN DEVICES?
	BLEQU	10$			; BR IF NO-TRY TO GET A JOB TO PRINT
	MOVB	#SCT_K_MRKDEL,SCT_B_STATE(R5) ; INDICATE DELETE REQUESTED
	DECB	CURSYMB(R0)		; DECR. NO. OF THESE SYMBIONTS
	MOVZWL	#MSG$_DELSMB,R0		; GET A MESSAGE
	BRW	SYM$SND2SMB		; SEND 2 BYTES TO SYMBIONT
10$:	MOVL	#SYM_K_PRTPRI,R9	; SET NUMBER OF PRINT QUEUES
20$:	DECL	R9			; COUNT DOWN PRINT QUEUE TO SEARCH
	BGEQ	40$			; BR IF MORE
	INSQUE	(R5),@JCD_Q_SYMBWAIT+4(R11) ; PUT THIS IN LIST OF IDLE SYMBIONTS
	INCB	JBC$B_SYMWAIT		; INCR. COUNT OF NO. WAITING
30$:	RSB				; RETURN TO CALLER
40$:	MOVAQ	SQH$Q_QUEUE(R10)[R9],R3	; FIND ADDRESS OF NEXT QUEUE TO CHECK
	MOVAL	(R3)+,R8		; SET ADDRESS IS LINK WORD
50$:	MOVL	(R8),R7			; FOLLOW LINK TO NEXT JOB
	BEQL	20$			; BR IF NO MORE JOBS-CHECK NEXT QUEUE
	ADDL	R10,R7			; FIND REAL ADDRESS OF JOB HEADER
	MOVZWL	SJH$W_QINDEX(R7),R6	; GET QUEUE HEADER INDEX
	ADDL	R10,R6			; FIND ADDRESS OF QUEUE HEADER
	BBS	#SMQ$V_DETJOB,SMQ$B_FLAGS(R6),100$ ; BR IF BATCH QUEUE
52$:	BBS	#SMQ$V_GENDEV,-		; BR IF DEVICE IS GENERIC
		SMQ$B_FLAGS(R6),60$	; SCAN OPEN DEVICES
	BBC	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),57$ ; BR IF QUEUE NOT REDIRECTED
	ADDL3	SMQ$L_ASNSCT(R6),R10,R6	; GET ADDRESS OF REAL QUEUE
	BITB	#<SMQ$M_STOPPED!SMQ$M_PAUSED>,SMQ$B_FLAGS(R6) ; QUEUE RUNNING?
	BEQL	52$			; BR IF YES
	BRB	100$			; ELSE TRY ANOTHER FILE
57$:	BBS	#SMQ$V_PAUSED,SMQ$B_FLAGS(R6),59$ ; BR IF PAUSED
	CMPL	SCT_L_PNMTAB(R5),-	; COMPARE SYMBIONT TYPES
		SMQ$L_PNMTAB(R6)
	BNEQU	100$			; BR IF NOT SAME LOOK AT NEXT FILE
	TSTL	SMQ$L_CURRENT(R6)	; IS THERE A FILE PRINTING?
	BEQL	110$			; BR IF DEVICE IS FREE
59$:	BRB	100$			; ELSE CHECK NEXT JOB
60$:	MOVL	R6,R2			; COPY ADDRESS OF GENERIC QUEUE HEADER
	MOVAL	SQH$K_SIZE(R10),R6	; FIND ADDRESS OF THE FIRST QUEUE
	MOVZBL	SQH$B_MAXQUE(R10),R4	; GET COUNT OF ACTIVE QUEUES
70$:	BBC	#SMQ$V_INUSE,-		; CHECK IF HEADER IS IN USE
		SMQ$B_FLAGS(R6),90$	; IF NOT LOOP TO CHECK NEXT
	TSTL	SMQ$L_CURRENT(R6)	; IS THERE A FILE PRINTING?
	BNEQ	90$			; IF BUSY TRY NEXT
	BITB	#<SMQ$M_NOGENERIC!-	; CHECK IF NO GENERIC PRINTING ALLOWED,
		SMQ$M_DETJOB!-		; OR IF QUEUE IS FOR DETACHED JOBS,
		SMQ$M_STOPPED!-		; OR THE PROCESSING IS STOPPED
		SMQ$M_PAUSED!-		; OR IT IS SUSPENDED FROM PRINTING
		SMQ$M_GENDEV>,-		; OR THIS IS A GENERIC DEVICE
		SMQ$B_FLAGS(R6)		; ASSOCIATED WITH THIS QUEUE
	BNEQ	90$			; IF ANY ARE SET-CANNOT PRINT HERE
	BBS	#SMQ$V_REDIRECT,SMQ$B_CHAR(R6),90$ ; ALSO FOR REDIRECTED QUEUES
	IF_FORM_DIF	90$		; BR IF FORMS DON'T MATCH
	CMPL	SCT_L_PNMTAB(R5),SMQ$L_PNMTAB(R6)	; COMPARE SYMBIONT TYPES
	BNEQU	90$			; BR IF NOT SAME
	BBS	#SMQ$V_TRMDEV,SMQ$B_CHAR(R6),80$ ; BR IF DEVICE IS A TERMINAL
	BBC	#SMQ$V_TRMDEV,SMQ$B_CHAR(R2),110$ ; DEQUE IF DEVICES MATCH
	BRB	90$			; ELSE TRY NEXT QUEUE
80$:	BBS	#SMQ$V_TRMDEV,SMQ$B_CHAR(R2),110$ ; DEQUE IF BITS ARE THE SAME
90$:	ADDL	#SMQ$K_SIZE,R6		; ADVANCE TO THE NEXT
	SOBGTR	R4,70$			; MORE QUEUES TO CHECK
100$:	MOVAL	SJH$L_NEXTJOB(R7),R8	; SET ADDRESS OF LINK
	BRW	50$			; CHECK NEXT JOB
110$:	MOVL	SJH$L_NEXTJOB(R7),(R8)	; CLOSE UP THE LIST
	BNEQ	120$			; BR IF NOT END OF LIST
	MOVAL	-SJH$L_NEXTJOB(R8),R0	; FIND ADDRESS OF JOB HEADER
	SUBL3	R10,R0,(R3)		; STORE INDEX IN QUEUE
120$:	SYM_QUECHANGE			; INDICATE THE QUEUE CHANGED
	CLRL	SJH$L_NEXTJOB(R7)	; CLEAR LINK-ONLY 1 JOB IN CURRENT LIST
	SUBL3	R10,R7,SMQ$L_CURRENT(R6) ; SET CURRENT PRINTING JOB IN QUEUE HEADER
	MOVL	R5,SMQ$L_ASNSCT(R6)	; SAVE ADDRESS OF ASSIGNED SYMBIONT SCT
	SUBL3	R10,R6,R0		; FIND INDEX FOR QUEUE HEADER
	MOVW	R0,SCT_W_QINDEX(R5)	; SAVE THAT FOR BACK REFERENCE
	MOVL	R7,SCT_L_CURFIL(R5)	; AND AS RECORD JUST FINISHED
	MOVW	#1,SCT_W_JOBSTAT(R5)	; Assume printing successful
	ASSUME	SCT_L_CPUTIM+4 EQ SCT_L_PAGCNT
	ASSUME	SCT_L_QIOCNT+4 EQ SCT_L_GETCNT
	CLRQ	SCT_L_CPUTIM(R5)	; ZERO CPU AND PAGE COUNTERS
	CLRQ	SCT_L_QIOCNT(R5)	; NOW QIO AND GET COUNTERS
	CLRL	SCT_L_FILESIZ(R5)	; SET CURRENT FILE SIZE TO ZERO
	INCB	SCT_B_STATE(R5)		; THAT SAYS TO PRINT NEXT RECORD
	BRB	SYM$NXTFIL		; SET UP FILE TO PRINT

	.SBTTL	INITIATE PRINTING OF NEXT FILE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO DEQUEUE A FILE FOR PRINTING
;	FROM THE CURRENT JOB ASSIGNED TO A SYMBIONT.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$NXTFIL
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE SYMBIONT CONTROL TABLE
;
; OUTPUT PARAMETERS:
;
;	THE SYMBIONT IS GIVE THE NEXT FILE IN THE JOB, OR DEASSIGN FROM THE JOB
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
 
SYM$NXTFIL:				; ASSIGN THE NEXT FILE IN JOB TO PRINT
	MOVZWL	SCT_W_QINDEX(R5),R6	; GET INDEX TO THE QUEUE
	ADDL	R10,R6			; FIND ADDRESS OF THE HEADER
	ADDL3	R10,SMQ$L_CURRENT(R6),R7 ; FIND ADDRESS OF JOB RECORD IN QUEUE
	SUBL2	SCT_L_FILESIZ(R5),-	; SUBTRACT SIZE OF FILE JUST PRINTED
		SJH$L_FILESIZ(R7)	; FROM SIZE OF TOTAL JOB
20$:	MOVL	@SCT_L_CURFIL(R5),R8	; FOLLOW LINK TO NEXT JOB
	BNEQ	40$			; BR IF THERE IS A FILE
	DECB	SJH$B_COPYCNT(R7)	; MORE COPIES OF ENTIRE JOB?
	BEQL	30$			; BR IF NO
	MOVL	R7,SCT_L_CURFIL(R5)	; SET JOB AS LAST FILE PRINTED
	BRB	20$			; LOOP
30$:	INCB	SCT_B_STATE(R5)		; SET STATE TO DONE WITH JOB
	BRB	SYM$TRMJOB		; AND GO PROCESS END OF JOB
40$:	BBS	#SMQ$V_PAUSED,SMQ$B_FLAGS(R6),50$ ; IF PAUSED DON'T DEQUEUE
	ADDL	R10,R8			; FIND ADDRESS OF FILE RECORD
	MOVL	R8,SCT_L_CURFIL(R5)	; SAVE THE CURRENT FILE
	MOVL	SQR$L_FILESIZ(R8),-	; MOVE SIZE OF FILE TO BE PRINTED
		SCT_L_FILESIZ(R5)	; INTO SYMBIONT TABLE
	MOVL	JCD_A_LBUFADR(R11),R0	; GET ADDRESS OF LINE BUFFER
	MOVZWL	#MSG$_INIOPR,(R0)+	; SET MESSAGE TYPE, AND ZERO SPARE WORD
	MOVQ	SJH$L_UIC(R7),(R0)+	; INSERT UIC AND 4 BYTES OF USER NAME
	MOVQ	SJH$T_USERNAM+4(R7),(R0)+ ; REST OF USER NAME
	MOVQ	SJH$Q_TIME(R7),(R0)+	; TIME JOB WAS QUEUED
	PUSHR	#^M<R5>			; SAVE ADDRESS OF RECORD AND SCT
	MOVC3	#SYM_K_MAXDEVNAM+1+6+6,-; COPY DEVICE AND FILE ID'S FOR
		SQR$T_VOLNAM(R8),(R0)	; FILE TO PRINT INTO SYMBIONT MESSAGE
 
	ASSUME	SQR$B_FLAGS+1 EQ SQR$B_COPYCNT
	ASSUME	SQR$B_FLAGS+2 EQ SQR$W_PAGCNT

	CMPB	#1,SJH$B_COPYCNT(R7)	; TEST NO. OF COPIES ENTIRE JOB
	BNEQ	43$			; DON'T CHECK IF NOT LAST-ONLY COPY
	BBC	#SQR$V_TEMPDEL,-	; CHECK PLACE HOLDING DELETE
		SQR$B_FLAGS(R8),43$	;  IN FLAGS BYTE
	SETBIT	SQR$V_DELETE,SQR$B_FLAGS(R8) ; SET DELETE BIT SYMBIONT WILL
					     ;  UNDERSTAND
 
43$:	MOVL	SQR$B_FLAGS(R8),(R3)+	; INSERT FLAGS,COPIES,AND PAGE COUNT
	MOVC3	#SYM_K_MAXDEVNAM+1,-	; COPY ENTIRE DEVICE NAME FIELD
		SMQ$T_NAME(R6),(R3)	; FROM QUEUE HEADER AS PRINT DEVICE
	MOVC3	#SYM_K_MAXFILNAM+1,-	; NOW MAXIMUM POSIBLE FILEMANE
		SQR$T_FILNAM(R8),(R3)	; FOR PRINT FILE INTO MESSAGE
	MOVZBL	SJH$T_JOBNAME(R7),R0	; GET LENGTH OF JOB NAME
	INCL	R0			; INCLUDE COUNT BYTE
	MOVC3	R0,SJH$T_JOBNAME(R7),(R3) ; MOVE JOB NAME INTO MESSAGE
	POPR	#^M<R5>			; RESTORE SYMBIONT CONTROL TABLE ADDRESS
	MOVL	JCD_A_LBUFADR(R11),R1	; GET BASE ADDRESS OF LINE BUFFER
	SUBL3	R1,R3,R0		; FIND NUMBER OF BYTES IN MESSAGE
	BSBW	SYM$SNDMSGSMB		; SEND MESSAGE TO SYMBIONT
50$:					; JOIN START NEXT SYMBIONT
 
;
; SEE IF THERE IS ANOTHER SYMBIONT TO START
;
 
SYM$NXTSYM:				;
	REMQUE	@JCD_Q_SYMBWAIT(R11),R5	; SEE IF ANY MORE SYMBIONTS TO START
	BVS	10$			; BR IF NO
	DECB	JBC$B_SYMWAIT		; DECR. NO. WAITING
	BRW	SYM$SYMBSERV		; IF SO TRY TO START IT
10$:	RSB				; NOTHING ELSE TO DO NOW!

	.SBTTL	TEMINATE PRINT JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN A JOB HAS BEEN COMPLETED,
;	THE ACCOUNTING RECORD MUST BE WRITTEN, THE SYMBIONT
;	AND THE DEVICE MUST BE FREED SO THAT A NEW ASSIGNMENT
;	MAY BE GIVEN TO EITHER OR BOTH.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$TMRJOB
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE SYMBIONT CONTROL TABLE
;	FOR THE SYMBIONT/JOB/QUEUE TO FREE UP.
;
; IMPLICIT INPUTS:
;
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS ADDRESS OF JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	THE SYMBIONT IS SET READY FOR ITS NEXT JOB, AND THE QUEUE
;	IS SET TO HAVE NO CURRENT JOB, THE RECORDS FOR THE JOB
;	ARE RELEASED TO THE FREE LIST.
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
	.ENABL	LSB
 
SYM$ABOJOB:				; ABORT THE JOB
	MOVW	#MOD$_ABORT,SCT_W_JOBSTAT(R5) ; Set job abort status
SYM$TRMJOB:				; TERMINATE THE JOB
	BSBW	100$			; GET CURRENT JOB VALUES
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	MOVL	R6,R4			; SMQ ADDRESS
	SUBL2	#ACM$W_USERREQ,SP	; ALLOCATE MESSAGE BUFFER
	MOVL	SP,R6			; MESSAGE BUFFER ADDRESS
	SUBL2	#MAX_REC_SIZ,SP		; ALLOCATE RECORD BUFFER
	MOVL	SP,R7			; RECORD BUFFER ADDRESS
	PUSHL	R5			; SAVE SCT ADDRESS
	MOVL	R0,R5			; SJH ADDRESS
	MOVL	SJH$L_PROCID(R5),ACM$L_PID(R6); PID
	CLRL	ACM$L_OWNER(R6)		;*****
	MOVL	SJH$L_UIC(R5),ACM$L_UIC(R6); REQUESTOR UIC
	CLRQ	ACM$Q_PRVMSK(R6)	;*****
	MOVB	SJH$B_PRTPRI(R5),ACM$B_PROCPRI(R6); REQUEST PRIORITY
	CLRQ	ACM$T_TERMINAL(R6)	;*****
	MOVQ	SJH$T_USERNAM(R5),ACM$T_USERNAME(R6); USERNAME
	MOVL	SJH$T_USERNAM+8(R5),ACM$T_USERNAME+8(R6)
	MOVQ	SJH$Q_ACNTNAM(R5),ACM$T_ACCOUNT(R6); ACCOUNT
	BBCS	#PCB$V_BATCH,ACM$L_STS(R6),10$; MAKE IT LOOK LIKE A BATCH JOB
10$:
	MOVQ	#ACR$K_PRINT,R0		; TYPE = PRINT, NO SUBTYPE
	MOVQ	JCD_Q_TIME(R11),R2	; EVENT TIME
	BSBW	ACM$RECORD		; BUILD RECORD HEADER
	BSBW	ACM$ID			; BUILD IDENTIFICATION PACKET
	MOVQ	#ACR$K_PRINT,R0		; TYPE = PRINT, NO SUBTYPE
	BSBW	ACM$PACKET		; BUILD PACKET HEADER
	MOVQ	SJH$Q_TIME(R5),ACR$Q_QUETIME(R8); QUEUE TIME
	POPL	R5			; RESTORE SCT ADDRESS
	MOVZWL	SCT_W_JOBSTAT(R5),R0	; Pick up completion status
	MOVL	#JBC$_JOBABORT!2,R1	; Assume aborted
	CMPL	R0,#MOD$_ABORT		; Test if aborted
	BEQL	20$			; Br if aborted
	MOVZWL	#SHR$_READERR!2,R1	; Assume read error
	CMPL	R0,#MOD$_GETERR		; Test if read error
	BEQL	20$			; Br if read error
	MOVZWL	#SHR$_WRITEERR!2,R1	; Assume write error
	CMPL	R0,#MOD$_PRTERR		; Test if write error
	BEQL	20$			; Br if write error
	MOVZWL	#SHR$_OPENIN!2,R1	; Assume open error
	CMPL	R0,#MOD$_OPNERR		; Test if open error
	BEQL	20$			; Br if open error
	MOVL	#1,R1			; Set successful completion
20$:	BISL3	#<4@16>,R1,ACR$L_PRINTSTS(R8) ; Set job status
	CLRQ	ACR$Q_BEGTIME(R8)	;*****
	MOVQ	SCT_L_CPUTIM(R5),ACR$L_SYMCPUTIM(R8); SYMB. CPU TIME & PAGE CNT
	MOVQ	SCT_L_QIOCNT(R5),ACR$L_QIOCNT(R8); QIO AND GET COUNTS
	MOVAB	ACR$L_GETCNT+4(R8),R1	; END OF PACKET ADDRESS
	SUBL3	R8,R1,R0		; PACKET LENGTH
	MOVW	R0,ACR$W_LENGTH(R8)
	SUBL2	R7,R1			; RECORD LENGTH
	MOVW	R1,ACR$W_LENGTH(R7)
	BSBW	ACM$WRITEACNT		; WRITE ACCOUNTING RECORD
	ADDL2	#ACM$W_USERREQ+MAX_REC_SIZ,SP; CLEAN UP STACK
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8>
	MOVL	R0,R7			; SET ADDR OF JOB HEADER
	BSBW	SYM$FREEJOB		; RELEASE THE JOB RECORDS
	MOVB	#SCT_K_DEQJOB,SCT_B_STATE(R5) ; SET SYMBOINT READY FOR NEXT JOB
	CLRB	JBC$B_QUEWRT		; force updating the global section
	BRW	SYM$NXTJOB		; TRY TO DEQUE A JOB FOR THIS SYMBIONT
 
;
; LOCAL SUBROUTINE TO GET THE CURRENT JOB OF THE PRINT SYMBIONT
;
 
100$:	MOVZWL	SCT_W_QINDEX(R5),R6	; GET OFFSET TO QUEUE
	ADDL	R10,R6			; FIND ADDRESS IN QUEUE
	ADDL3	R10,SMQ$L_CURRENT(R6),R0 ; GET REAL ADDRESS OF JOB
	CLRL	SMQ$L_CURRENT(R6)	; MARK QUEUE HAVING NO CURRENT JOB
	SYM_QUECHANGE			; TELL THE WORLD IT CHANGED
	RSB

	.SBTTL	TEMINATE PRINT JOB AND REQUEUE THE JOB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS ENTERED WHEN A JOB HAS BEEN TERMINATED,
;	BUT THE JOB SHOULD BE REQUEUED FOR RESTARTING LATER.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$REQUE
;
; INPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE SYMBIONT CONTROL TABLE
;	FOR THE SYMBIONT/JOB/QUEUE TO FREE UP.
;
; IMPLICIT INPUTS:
;
;	R10 HAS THE BASE ADDRESS OF THE QUEUE FILE
;	R11 HAS ADDRESS OF JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	THE SYMBIONT IS SET READY FOR ITS NEXT JOB, AND THE QUEUE IS
;	SET TO HAVE NO CURRENT JOB, THE JOB IS REINSERTED INTO THE QUEUE.
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
 
SYM$REQUE:				; REQUEUE THE CURRENT JOB
	BSBB	100$			; GET THE JOB AND MARK QUEUE FREE
	MOVL	R0,R7			; SET JOB NAME INTO STANDARD REGISTER
	MOVQ	JCD_Q_TIME(R11),SJH$Q_TIME(R7) ; AND CURRENT TIME AS QUEUE TIME
	MOVW	SJH$W_REQINDX(R7),-
		SJH$W_QINDEX(R7)	; SET QUEUE INDEX
	MOVB	SJH$B_REQPRIO(R7),-
		SJH$B_PRTPRI(R7)	; SET PRIORITY
	BSBW	SYM$JOBINSQUE		; INSERT THE JOB IN THE QUEUE
	MOVB	#SCT_K_DEQJOB,SCT_B_STATE(R5)	; set ready for next job
	BRW	SYM$NXTJOB		; TRY TO RESTART A SYMBIONT
	.DSABL	LSB

	.SBTTL	SEND MESSAGE TO SYMBIONT
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE PURFORMS THE QIO TO SEND DATA TO A SYMBIONT
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$SND2SMB		; SEND MESSAGE IN R0
;	BSB/JSB	SYM$SNDMSGSMB		; SEND GENERAL MESSAGE TO SYMBIONT
;
; INPUT PARAMETERS:
;
; FOR SYM$SND2SMB,	R0 IS THE MESSAGE
; FOR SYM$SNDMSGSMB,	R0 IS THE BYTE COUNT,
;			R1 IS THE BUFFER ADDRESS.
;
;	R11 HAS THE ADDRESS OF JOB CONTROLLER DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	MESSAGE IS SENT
;
; COMPLETION CODES:	NONE
;
; SIDE EFFECTS:		NONE
;--
 
SYM$SND2SMB::				; SEND R0 MESSAGE TO THE SYMBIONT
	MOVL	JCD_A_LBUFADR(R11),R1	; ADDRESS OF LINE BUFFER
	MOVL	R0,(R1)			; STORE MESSAGE IN THE BUFFER
	MOVL	#4,R0			; LENGTH OF MESSAGE TO SEND
SYM$SNDMSGSMB:				; SEND ANY MESSAGE TO SYMBIONT
	$QIO_S	#0,-			; WRITE MESSAGE TO SYMBIONT
		CHAN=SCT_W_MBCHAN(R5),- ; CHANNEL TO SYMBIONT
		FUNC=#IO$_WRITEVBLK,-	; WRITE DATA
		P1=(R1),-		; BUFFER ADDRESS IS IN R1
		P2=R0			; BYTE COUNT
	CHECK_ERROR	WRITE_SYMB_MB	; REPORT ERROR IF ENCOUNTERED
	RSB				; BACK TO CALLER

	.SBTTL	FIND SYMBIONT CONTROL TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE WILL SEARCH FOR THE SYMBIONT CONTROL TABLE
;	ASSIGNED TO A SPECIFIC SYMBIONT AND ISSUE FATAL ERROR IF NOT FOUND.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$FINDSYMCTL
;
; INPUT PARAMETERS:
;
;	R1 CONTAINS THE PROCESS ID OF TARGET SYMBIONT
;
; OUTPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE PROPER SYMBIONT CONTROL TABLE
;
; SIDE EFFECTS:
;
;	A FATAL ERROR IS ISSUED IF TABLE IS NOT FOUND
;
;--
 

SYM$FINDSYMCTL::			; FIND SYMBIONT CONTROL TABLE
	BSBB	SYM$GETSYMCTL		; FIND THE TABLE
	BLBS	R0,20$			; BR IF FOUND
	SHOW_ERROR	SCT_SEARCH_FAIL	; FATAL ERROR-NO SUCH TABLE
20$:	RSB				; RETURN WITH TABLE


	.SBTTL	GET SYMBIONT CONTROL TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS MODULE WILL SEARCH FOR THE SYMBIONT CONTROL TABLE
;	ASSIGNED TO A SPECIFIC SYMBIONT.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SYM$GETSYMCTL
;
; INPUT PARAMETERS:
;
;	R1 CONTAINS THE PROCESS ID OF TARGET SYMBIONT
;
; OUTPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE PROPER SYMBIONT CONTROL TABLE
;
; COMPLETION CODES:
;
;	R0 IS SET TRUE OR FALSE BASED ON SUCESS OF FAILURE OF SEARCH.
;
; SIDE EFFECTS:		NONE
;--
 

SYM$GETSYMCTL::				; GET SYMBIONT CONTROL TABLE
	PUSHAB	B^SYM$NXTSYMCTL		; INIT CO-ROUTINE
10$:	JSB	@(SP)+			; LOCATE NEXT TABLE
	BLBC	R0,30$			; BR IF NO MORE TABLES
	TSTB	SCT_B_STATE(R5)		; IS THIS SLOT INUSE?
	BEQL	10$			; BR IF NO - CONTINUE SEARCH
	CMPL	R1,SCT_L_PROCID(R5)	; IS THIS THE TABLE?
	BNEQ	10$			; BR IF NOT THE CORRECT TABLE
	TSTL	(SP)+			; CLEAR COROUTINE RETURN ADDRESS
30$:	RSB				; RETURN WITH STATUS

	.SBTTL	GET NEXT SYMBIONT CONTROL TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS IS A COROUTINE TO SEARCH THE SYMBIONT CONTROL
;	TABLES. IT SETS R5 TO POINT AT EACH SUCESSIVE
;	ENTRY IN THE TABLE AND RETURNS WITH SUCESSFUL
;	STATUS.  WHEN THERE ARE NO MORE TABLES, A RETURN
;	FROM SUBROUTINE IS ISSUED WITH FALSE INDICATOR.
;
; CALLING SEQUENCE:
;
;	JSB/BSB	SYM$NXTSYMCTL
;
; INPUT PARAMETERS:	NONE
;
; OUTPUT PARAMETERS:
;
;	R5 CONTAINS THE ADDRESS OF THE NEXT TABLE
;
; COMPLETION CODES:
;
;	R0 CONTAINS TRUE OR FALSE DEPENDING ON WHETHER A TABLE REMAINED
;
; SIDE EFFECTS:		NONE
;--
 
 
SYM$NXTSYMCTL::				; NEXT SYMBIONT CONTROL TABLE
	MOVAL	W^SYM$G_SYMCTLTBL,R5	; SET START OF TABLE
10$:	MOVL	#1,R0			; SET SUCESSFULL STATUS
	JSB	@(SP)+			; RETURN WITH ADDRESS
	ADDL	#SCT_K_SIZE,R5		; ADVANCE TO NEXT ENTRY
	CMPL	R5,#SYM$G_SYMCTLTBE	; END OF TABLE?
	BLSSU	10$			; BR IF NO
	CLRL	R0			; SET NO MORE TABLES FLAG
	RSB				; RETURN TOP 1 LEVEL
 
	.PAGE
	.SBTTL	FIND AN EMPTY ENTRY IN SYMBIONT NAME TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO FIND AN EMPTY ENTRY IN THE SYMBIONT
;	NAME TABLE
;
; CALLING SEQUENCE:
;
;	JSB/BSB	FIND_EMPTY
;
; INPUT PARAMETERS:
;
;	R11 CONTAINS STARTING ADDRESS OF JOB CONTROLLER'S DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	R1 CONTAINS THE ADDRESS OF AN EMPTY ENTRY
;
; COMPLETION CODES:
;
;	R0 = TRUE IF EMPTY ENTRY FOUND
;	R0 = FALSE IF ONE NOT FOUND
;
; SIDE EFFECTS:
;
;	NONE
;--

FIND_EMPTY::
	MOVAL	JCD_T_TABADD(R11),R1		; START OF SYMBIONT NAME TABLE
	CLRL	R0			; INIT COUNTER
10$:	TSTB	(R1)			; TEST LENGTH OF NAME
	BEQL	20$			; BR IF EMPTY ENTRY
	ADDL	#SYM_K_ENTSIZ,R1	; ADD SIZE OF ENTRY
	AOBLSS	#SYM_K_MAXSYMB,R0,10$	; LOOK AT NEXT ENTRY
	CLRL	R0			; SET FALSE - ENTRY NOT FOUND
	RSB				; RETURN
20$:	MOVL	#1,R0			; SET TRUE - ENTRY FOUND
	CLRB	CURSYMB(R1)		; SET NO. OF SYMBIONTS = 0
	CLRB	CURPDEV(R1)		; SET NO. OF DEVICES = 0
	RSB				; RETURN

	.PAGE
	.SBTTL	SEARCH SYMBIONT NAME TABLE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SEARCH FOR A NAME IN THE SYMBIOINT
;	NAME TABLE
;
; CALLING SEQUENCE:
;
;	CALLS	SEARC_NAME
;
; INPUT PARAMETERS:
;
;	R6 CONTAINS THE ADDRESS OF THE QUEUE HEADER
;	R11 CONTAINS THE STARTING ADDRESS OF THE JOB CONTROLLER'S DATA
;	BLOCK
;
; OUTPUT PARAMETERS:
;
;	R1 CONTAINS THE ADDRESS OF THE ENTRY CONTAINING THE MATCH
;
; COMPLETION CODES:
;
;	R0 = TRUE IF NAME IS FOUND
;	R0 = FALSE IF NAME NOT FOUND
;
; SIDE EFFECTS:
;
;	NONE
;--

SEARC_NAME::
	.WORD	^M<R2,R3,R4,R5,R7>
	MOVAL	JCD_T_TABADD(R11),R4	; START OF SYMBIONT NAME TABLE
	CLRL	R5			; CLEAR COUNTER
10$:	MOVZBL	(R4)+,R7		; GET LENGTH OF NAME
	BEQL	20$			; BR IF EMPTY ENTRY
	CMPB	R7,SMQ$T_SMBNAME(R6)	; COMPARE LENGTHS OF NAMES
	BNEQ	20$			; BR IF NOT SAME CAN NOT MATCH
	CMPC3	R7,(R4),SMQ$T_SMBNAME+1(R6)	; COMPARE NAMES
	BNEQ	20$			; BR IF NOT SAME
	MOVL	R4,R1			; COPY TABLE ADDR.
	DECL	R1			; POINT AT START OF TABLE
	MOVL	#1,R0			; SET SUCCESS
	BRB	30$			; RETURN
20$:	ADDL	#SYM_K_ENTSIZ-1,R4	; POINT AT NEXT ENTRY
	AOBLSS	#SYM_K_MAXSYMB,R5,10$	; LOOK AT NEXT ENTRY
	CLRL	R0			; SET FALSE - NAME NOT FOUND
30$:	RET
	.END
