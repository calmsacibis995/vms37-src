	.TITLE	SNAPSHOT - SNAP SHOT ROUTINE FOR PROCESS ADDRESS SPACE
	.IDENT	'V03-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 7-DEC-1977
;
; MODIFIED BY:
;
;	V02-003	MLJ0067		Martin L. Jack,	18-Jan-1982  17:58
;		Correct typos in messages.
;
;	V02-002	GWF0141		Gary W. Fowler		09-Dec-1981
;		Change psect from LIB$CODE to PURE
;
; SNAP SHOT OF PROCESS ADDRESS SPACE
;
; MACRO LIBRARY CALLS
;
 
	$FABDEF				; DEFINE FAB OFFSETS
	$RABDEF				; DEFINE RAB OFFSETS
 
;
; LOCAL SYMBOLS
;
;
; OUTPUT FORMAT BUFFER SIZE
;
 
BUFSIZ=80				; 
 
;
; LOCAL FLAG BITS
;
	_VIELD	SNP,0,<-		;
		<ZEROS,,M>,-		; IN A ZERO BUFFER
		<ACCESV,,M>,-		; IN A NON-READABLE AREA
		>
;
; LOCAL DATA
;
 
	PURE_SECTION
 
HEXTAB:	.ASCII	\0123456789ABCDEF\	; BINARY TO HEX CONVERSION
HEADER:	.ASCIZ	\ * Dump of memory locations \
ZEROS:	.ASCIZ	\ ** Intervening locations contain all zeros.\
ACCESV:	.ASCIZ	\ ** Intervening locations not accessible.\
 
FILNAM:	.ASCII	\SNAPSHOT.DAT\
FILSIZ = . - FILNAM
	.PAGE
;	.SBTTL	SNAP SHOT OUTOUT ROUTINE
;+
; LIB$SNAPSHOT - LIBRARY SNAP SHOT ROUTINE
;
; THIS ROUTINE IS CALLED TO FORMAT AND DUMP A SERIES OF ADDRESS LIMITS
; FOR THE CALLING PROCESS.
;
; INPUTS:
;
;	(AP) = COUNT OF ADDRESS LIMITS TO FOLLOW(MODULO 2)
;		FOLLOWED BY ADDRESS LIMIT PAIRS
;
; OUTPUTS:
;
;	A FILE IS OPENNED AND THE ADDRESSES WITH IN THE LIMITS SPECIFIED
;	ARE WRITTEN IN HEX AND ASCII 4 LOCATIONS PER LINE.
;	IF ALL 4 LOCATIONS ARE ZERO THE LINE IS OMMITTED.
;-
 
	.ENTRY	LIB$SNAPSHOT,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
 
	MOVAB	-FAB$C_BLN(SP),SP	; ALLOCATE SPACE FOR FAB
	MOVL	SP,R9			; SAVE ADDRESS OF FAB
	MOVAB	-RAB$C_BLN(SP),SP	; ALLOCATE SPACE FOR RAB
	MOVL	SP,R8			; SAVE ADDRESS OF RAB
	MOVAB	-BUFSIZ(SP),SP		; ALLOCATE SPACE FOR OUTPUT BUFFER
	MOVL	SP,R7			; SAVE ADDRESS OF OUTPUT BUFFER
	MOVC5	#0,(R8),#0,#RAB$C_BLN+FAB$C_BLN,(R8) ; CLEAR RAB AND FAB
	ASSUME	FAB$B_BLN EQ FAB$B_BID+1
	MOVW	#<FAB$C_BLN@8+FAB$C_BID>,FAB$B_BID(R9) ;SET FAB ID FIELDS
	MOVAB	FILNAM,FAB$L_FNA(R9)	; SET ADDRESS OF FILE NAME
	MOVB	#FILSIZ,FAB$B_FNS(R9)	; AND ITS SIZE
	MOVZBW	#BUFSIZ,FAB$W_MRS(R9)	; SET MAXIMUM RECORD SIZE
	MOVB	#FAB$M_CR,FAB$B_RAT(R9) ; SET RECORD ATTRIBUTES
	MOVB	#FAB$C_VAR,FAB$B_RFM(R9); SET VARIABLE RECORD FORMAT
	MOVB	#FAB$M_PUT,FAB$B_FAC(R9) ; SET FILE ACCESS MODE
	MOVL	#FAB$M_SQO,FAB$L_FOP(R9) ; SET FILE OPEN OPTIONS
	$CREATE	FAB=(R9)		; CREATE OUTPUT FILE
	BLBC	R0,80$			; IF LBC OPEN FAILURE
	ASSUME	RAB$B_BLN EQ RAB$B_BID+1
	MOVW	#<RAB$C_BLN@8+RAB$C_BID>,RAB$B_BID(R8) ;SET RAB ID FIELDS
	MOVAB	(R9),RAB$L_FAB(R8)	; SET ADDRESS OF FAB INTO RAB
	MOVAB	(R7),RAB$L_RBF(R8)	; SET ADDRESS OF OUTPUT BUFFER
	$CONNECT RAB=(R8)		; CONNECT RECORD STREAM
20$:	BLBC	R0,70$			; IF LBC CONNECT FAILURE
	DIVL3	#2,(AP)+,R11		; GET COUNT OF LIMIT PAIRS
	BLEQ	70$			; BR IF 1 OR LESS
50$:	MOVL	(AP)+,R4		; SET LOW LIMIT
	MOVL	(AP)+,R5		; AND HI LIMIT
	BSBB	DUMP			; LIST THE MEMORY
	SOBGTR	R11,50$			; LIST ALL LIMIT SETS
70$:	$CLOSE	FAB=(R9)		; CLOSE OUTPUT FILE
80$:	RET				; 
 
;
; LOCAL SUBROUTINE TO DUMP THE CONTENTS OF A CONTIGUOUS AREA OF
; MEMORY IN HEX AND ASCII.
;
 
DUMP:	CLRL	R3			; ZERO THE FLAGS WORD
	BSBW	PUT			; OUTPUT A NULL LINE
	MOVAB	HEADER,R1		; INITIAL MESSAGE
	BSBW	INSERT			; PUT THE TEXT INTO MESSAGE
	MOVL	R4,R2			; SET LOW LIMIT
	BSBW	CONVERT			; FORMAT LOW ADDRESS INTO MESSAGE
	MOVL	#^A/ to /,(R7)+		; NOW SEPARATOR TEXT
	MOVL	R5,R2			; NOW THE HI LIMIT
	BSBW	PUTC			; INSERT THAT AND OUTPUT THE LINE
	BSBW	PUT			; WRITE A NULL LINE
10$:	CMPL	R4,R5			; PRINT THE ENTIRE RANGE OF MEMORY
	BLSSU	20$			; BR IF NO
	RSB				;
20$:	MOVAB	(R4),R2			; GET ADDRESS OF NEXT LOCATION
	ADDL3	#16,R4,R6		; SET UPPER LIMIT OF DUMP
	IFNORD	#16,(R2),30$		; BR IF ALL 16 BYTES NOT READABLE
	SKPC	#0,#16,(R2)		; NEXT 4 LONGWORDS ZERO?
	BNEQ	40$			; BR IF NON-ZERO DATA PRESENT
	ADDL	#16,R4			; ADVANCE POINTER OVER ZERO AREA
	BBSS	#SNP_V_ZEROS,R3,10$	; LOOP IF IN A ZERO AREA ALREADY
	MOVAB	ZEROS,R1		; GET ZERO AREA MESSAGE
	BRB	35$			;
30$:	MOVAB	512(R4),R4		; ADVANCE ONTO NEXT PAGE
	BICW	#511,R4			; ROUND TO FIRST BYTE OF PAGE
	BBSS	#SNP_V_ACCESV,R3,10$	; BR IF ALREADY IN NON-READABLE AREA
	MOVAB	ACCESV,R1		; GET MESSAGE
35$:	BSBW	PUTI			; PRINT IT
	BRB	10$			; TRY NEXT
40$:	BICB	#SNP_M_ZEROS!SNP_M_ACCESV,R3 ; CLEAR ZERO AREA FLAG
	BSBB	CONVERT			; INSERT ADDRESS IN MESSAGE
	MOVW	#^A/: /,(R7)+		; SEPARATE ADDRESS FROM DATA
50$:	IFNORD	#4,(R4),60$		; BR IF LONGWORD NOT READABLE
	MOVL	(R4)+,R2		; SET DATA INTO THE MESSAGE
	BSBB	CONVERT			;
	BRB	70$			;
60$:	MOVQ	#^A/NOACCESS/,(R7)+	; INSERT MESSAGE THAT DATA NO READABLE
	ADDL	#4,R4			; ADVANCE POINTER
70$:	MOVW	#^A/  /,(R7)+		; STORE DATA SEPARATOR
	CMPL	R4,R6			; DUMP 4 LONGWORDS
	BLSSU	50$			; BR IF NO - GET SOME MORE
	SUBL	#16,R4			; BACK UP TO START OF 16 BYTE AREA
80$:	IFNORD	#1,(R4),100$		; BR IF BYTE NOT READABLE
	BICB3	#^X80,(R4)+,R0		; GET THE NEXT BYTE FROM THE AREA
	CMPB	R0,#^A/ /		; IS THE BYTE A PRINTABLE CHARACTER?
	BGEQU	90$			; BR IF YES
	MOVB	#^A/./,R0		; ELSE PRINT A DOT
90$:	BSBB	PUTB			; INSERT A BYTE INTO LISTING
	CMPL	R4,R6			; ALL 16 BYTES DONE
	BLSSU	80$			; BR IF NO
100$:	BSBB	PUT			; PRINT THE LINE
	BRW	10$			;
 
;
; CONVERT NUMBER BASE 16
;
 
CONVERT:				; 
	MOVL	#28,R1			; SET STARTING BIT NUMBER
10$:	EXTZV	R1,#4,R2,R0		; GET NEXT HEXDECIMAL DIGIT
	MOVZBL	HEXTAB[R0],R0		; CONVERT HEXDIGIT TO ASCII
	BSBB	PUTB			; PUT BYTE IN OUTPUT BUFFER
	ACBB	#0,#-4,R1,10$		; ANY MORE DIGITS TO CONVERT?
	RSB				; 
 
;
; INSERT TEXT IN OUTPUT BUFFER
;
 
	.ENABL	LSB
INSERT:	MOVZBL	(R1)+,R0		; GET NEXT BYTE FROM TEXT STRING
	BEQL	10$			; IF EQL END OF TEXT STRING
	BSBB	PUTB			; PUT BYTE IN OUTPUT BUFFER
	BRB	INSERT			; 
 
;
; PUT BYTE IN OUTPUT BUFFER
;
;	NOTE:	THIS ROUTINE ASSUMES BUFFER IS FOLLOWED BY RAB
;		IN THE CALL STACK WORK AREA.
 
PUTB:	CMPL	R7,R8			; ANY ROOM LEFT IN BUFFER?
	BGEQ	10$			; BR IF NO MORE ROOM
	MOVB	R0,(R7)+		; INSERT BYTE IN OUTPUT BUFFER
10$:	RSB				; 
	.DSABL	LSB
 
;
; CONVERT HEXDECIMAL VALUE AND OUTPUT RECORD
;
 
PUTC:	BSBB	CONVERT			; CONVERT HEXDECIMAL VALUE
	BRB	PUT			; OUTPUT RECORD
 
;
; INSERT TEXT IN OUTPUT BUFFER AND OUTPUT RECORD AND BLANK RECORD
;
 
PUTI:	BSBB	INSERT			; INSERT TEXT IN BUFFER
 
;
; OUTPUT CURRENT RECORD AND RESET RECORD PARAMETERS
;
 
PUT:	SUBL3	RAB$L_RBF(R8),R7,R0	; CALCULATE LENGTH OF OUTPUT RECORD
	MOVW	R0,RAB$W_RSZ(R8)	; SET LENGTH OF OUTPUT RECORD
	$PUT	RAB=(R8)		; OUTPUT RECORD
	MOVL	RAB$L_RBF(R8),R7	; RESET OUTPUT RECORD POINTER
	RSB				; 
	.END
