	.TITLE	NETSEND		NETWORK MAIL PROTOCOL
	.IDENT	'V03-002'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX/VMS MAIL UTILITY
;
; ABSTRACT:	SEND MAIL TO USERS ON DIFFERENT NODES.
;
;
; ENVIRONMENT:	NATIVE/USER MODE 
;
; AUTHOR:	LEN KAWELL, CREATION DATE: 22-NOV-78
;
; MODIFICATION HISTORY:
;
;	V03-002	PCA0080		Paul C. Anagnostopoulos	2-Apr-1982
;		Fix a bug in MAIL$CREATELINK that caused it to find
;		nodes names in the logical link list if they were
;		an initial substring of a node already in the list.
;
;	V03-001	PCA0001		Paul Anagnostopoulos	27-Jan-1982
;		Change method of creating logical link so it assigns
;		to the net and does an access qio.  This allows the
;		user to CTRL/Y during a timeout.
;
;	V02-002	LMK0002		Len Kawell		23-Feb-1981
;		Add stripping of NULL records from file being sent to
;		avoid confusion with the remote protocol.
;
;	V2-001	LMK0001		LEN KAWELL		17-JUN-1980
;		Fix error handling when a node exists in logical link table
;		but it cannot be reached.  Also signal an informational
;		message when a network I/O error occurs.
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

;
; MACRO TO PUT A MESSAGE TO SLAVE MAIL JOB
;
	.MACRO	SLAVEPUT LENGTH,BUFFER,?OK
	MOVZWL	LENGTH,SLAVEQIO+QIO$_P2
	MOVAB	BUFFER,SLAVEQIO+QIO$_P1
	MOVZWL	#IO$_WRITEVBLK,SLAVEQIO+QIO$_FUNC
	$QIOW_G	SLAVEQIO
	BSBW	CHK_IO_STATUS
	.ENDM	SLAVEPUT
;
; MACRO TO GET A MESSAGE FROM SLAVE MAIL JOB
;
	.MACRO	SLAVEGET LENGTH,BUFFER
	MOVZWL	LENGTH,SLAVEQIO+QIO$_P2
	MOVAB	BUFFER,SLAVEQIO+QIO$_P1
	MOVZWL	#IO$_READVBLK,SLAVEQIO+QIO$_FUNC
	$QIOW_G	SLAVEQIO
	BSBW	CHK_IO_STATUS
	.ENDM	SLAVEGET

;
; EQUATED SYMBOLS:
;

LLINK		= 4			;LOGICAL LINK LIST ENTRY ADDR
NODE		= 8			;NODE NAME DESC ADDR
ADDR		= 8			;ADDRESSEE NAME DESC ADDR ARG
RAB		= 12			;MESSAGE FILE RAB ADDR ARG

MAIL$K_INBUFFSZ	= 255			;INPUT BUFFER SIZE
NODE_LEN	= 16			;NODE NAME LENGTH

	$STSDEF				;STATUS MESSAGE DEFINITIONS
	$TPADEF				;TPARSE DEFINITIONS
	$SHRDEF				;SHARED MESSAGE DEFINITIONS

	$DEFINI	LNK			;LOGICAL LINK LIST ENTRIES
LNK_L_FLINK:	.BLKL	1		;FORWARD LINK TO NEXT ENTRY
LNK_L_BLINK:	.BLKL	1		;BACKWARD LINK TO PREVIOUS ENTRY
LNK_W_CHAN:	.BLKW	1		;CHANNEL NUMBER
LNK_T_NODE:	.BLKB	NODE_LEN	;NODE NAME (NODE::)
LNK_B_MSGSNT:	.BLKB	1		;MESSAGE ALREADY SENT FLAG
LNK_K_LENGTH:				; LENGTH OF STRUCTURE
	$DEFEND	LNK

;
; OWN STORAGE:
;
	.PSECT	$OWN$,LONG,RD,WRT,NOEXE

LLINK_LIST:				;LOGICAL LINK LISTHEAD
	.LONG	LLINK_LIST,LLINK_LIST

SLAVEQIO:				;QIO ARGUMENT LIST FOR SLAVE I/O
	$QIO	IOSB=IOSB		; MOST ARGS FILLED-IN AT RUNTIME

IOSB:					;I/O STATUS BLOCK
	.BLKQ	1

	.PSECT	$PLIT$,LONG,RD,NOWRT,NOEXE

NET:	.ASCID	/_NET:/			;FOR ASSIGNING TO THE NET

OBJECT:					;REMOTE MAIL OBJECT NAME
	.ASCII	/::"MAIL="/
OBJECT_LEN = .-OBJECT			;REMOTE MAIL OBJECT NAME LENGTH

	.PSECT	$CODE$,LONG,RD,NOWRT,EXE

	.PAGE
	.SBTTL	MAIL$CREATELINK - CREATE A LOGICAL LINK
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS PROCEDURE IS CALLED TO CREATE A LOGICAL LINK TO THE
;	SPECIFIED NODE.  FIRST, THE EXISTING LOGICAL LINK LIST IS
;	SEARCHED TO SEE IF A LINK TO THAT NODE ALREADY EXISTS.  IF
;	IT DOES, THEN THE ADDRESS OF THE LIST ENTRY IS JUST RETURNED.
;	IF A LINK DOES NOT EXIST, ONE IS ASSIGNED AND A LOGICAL LINK
;	LIST ENTRY IS CREATED, ENTERED IN THE LIST, AND THE ADDRESS
;	RETURNED.
;
; CALLING SEQUENCE:
;	CALL MAIL$NET(LLINK,NODE)
;
; INPUT PARAMETERS:
;	LLINK(AP) = ADDRESS OF LONGWORD TO RETURN ADDRESS OF LOGICAL LINK
;		LIST ENTRY.
;	NODE(AP) = ADDRESS OF NODE NAME DESCRIPTOR.
;
; IMPLICIT INPUTS:
;	LLINK_LIST = LOGICAL LINK LISTHEAD.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 = SUCCESS OR FAILURE.
;
; SIDE EFFECTS:
;	IF FAILURE, ERROR IS SIGNALED.
;
;--
	.ENTRY	MAIL$CREATELINK,-	;CREATE A LOGICAL LINK
		^M<R2,R3,R4,R5,R6,R7,R8> ;(ENTRY MASK)
;
; CHECK IF LOGICAL LINK ALREADY EXISTS
;
	MOVAL	LLINK_LIST,R6		;GET ADDR OF LISTHEAD
	MOVL	R6,R7			;SAVE A COPY OF IT
	MOVL	NODE(AP),R8		;GET ADDR OF NODE NAME DESC
10$:
	ASSUME	LNK_L_FLINK EQ 0
	MOVL	LNK_L_FLINK(R6),R6	;GET ADDRESS OF NEXT ENTRY
	CMPL	R6,R7			;END OF LIST?
	BEQL	20$			;BR IF YES
	CMPC5	(R8),@4(R8),#0,-	;NODE NAMES MATCH?
		#NODE_LEN,LNK_T_NODE(R6)
	BNEQ	10$			;BR IF NOT - TRY NEXT ONE
	MOVL	R6,@LLINK(AP)		;RETURN ADDR OF ENTRY
	MOVL	#1,R0			;SET SUCCESS
	RET				;
;
; CREATE LOGICAL LINK LIST ENTRY
;
20$:
	PUSHL	#LNK_K_LENGTH		;SET SIZE OF ENTRY TO ALLOCATE
	PUSHAL	-(SP)			;CREATE RETURN ADDR BUFFER
	PUSHAL	8(SP)			;SET ADDR OF SIZE
	CALLS	#2,G^LIB$GET_VM		;ALLOCATE LIST ENTRY
	MOVL	(SP)+,R6		;GET ADDR OF NEW ENTRY
	INSQUE	(R6),LLINK_LIST		;ENTER ENTRY IN LIST
	MOVC5	(R8),@4(R8),#0,-	;SET NODE NAME IN ENTRY
		#NODE_LEN,LNK_T_NODE(R6)
	CLRB	LNK_B_MSGSNT(R6)	;SET NO MESSAGE SENT YET
	CLRW	LNK_W_CHAN(R6)		;SET NO LOGICAL LINK YET
;
; CREATE LOGICAL LINK TO SLAVE MAIL JOB
;
	SUBL	(R8),SP			;CREATE SLAVE MAIL NAME BUFFER
	SUBL	#OBJECT_LEN,SP		; ...
	MOVL	SP,R7			;GET ADDR OF BUFFER
	MOVC	(R8),@4(R8),(R7)	;SET NODE NAME IN BUFFER
	MOVC	#OBJECT_LEN,OBJECT,(R3)	;ADD OBJECT NAME TO NODE NAME
	PUSHL	R7			;CREATE SLAVE NAME DESC
	ADDL3	#OBJECT_LEN,(R8),-(SP)	; ...
	MOVL	SP,R7			;GET ADDR OF DESC

	$ASSIGN_S DEVNAM=NET,-		;WE CREATE A LOGICAL LINK BY
		  CHAN=LNK_W_CHAN(R6)	;ASSIGNING TO THE NET AND THEN
	BLBC	R0,40$			;DOING AN ACCESS QIO.
	$QIOW_S	FUNC=#IO$_ACCESS,-	;THIS ALLOWS THE USER TO CTRL/Y
		CHAN=LNK_W_CHAN(R6),-	;IN CASE OF A TIMEOUT.
		IOSB=IOSB,-
		P2=R7
	BLBC	R0,40$
	MOVZWL	IOSB,R0
	BLBC	R0,40$

	MOVW	LNK_W_CHAN(R6),-	;SET CHANNEL NUMBER IN SLAVE QIO
		SLAVEQIO+QIO$_CHAN	;
	SLAVEPUT LENGTH=MAIL$Q_USERNAME,- ;SEND SENDER'S NAME
		 BUFFER=@MAIL$Q_USERNAME+4
	MOVL	R6,@LLINK(AP)		;RETURN ADDR OF ENTRY
	RET				;
;
; SIGNAL ERROR CREATING LOGICAL LINK
;
40$:
	PUSHL	R0			;SET STATUS
	PUSHL	R8			;SET ADDR OF NODE NAME
	PUSHL	#1			;SET FAO COUNT
	PUSHL	#MAIL$_LOGLINK		;SET MESSAGE STATUS
	CALLS	#4,G^LIB$SIGNAL		;SIGNAL THE ERROR
	RET				;RETURN

	.PAGE
	.SBTTL	MAIL$NET_ADDR - CHECK THAT A REMOTE ADDRESSEE EXISTS
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS PROCEDURE IS CALLED TO CHECK THAT A REMOTE ADDRESSEE
;	EXISTS AT THE REMOTE NODE.  TO DO THIS, IT SENDS THE
;	THE ADDRESSEE'S NAME TO THE SLAVE MAIL JOB AND WAITS FOR THE
;	RETURN STATUS.
;
; CALLING SEQUENCE:
;	CALL MAIL$NET(LLINK,ADDR)
;
; INPUT PARAMETERS:
;	LLINK(AP) = ADDRESS OF LOGICAL LINK LIST ENTRY.
;	ADDR(AP) = ADDRESSEE NAME DESCRIPTOR.
;
; IMPLICIT INPUTS:
;	LOGICAL LINK TO ADDRESSEE'S NODE.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 = SUCCESS OR FAILURE
;
; SIDE EFFECTS:
;	IF FAILURE, ERROR IS SIGNALED.
;
;--
	.ENTRY	MAIL$NET_ADDR,-		;CHECK THAT REMOTE ADDRESSEE EXISTS
		^M<R2,R3,R4>		;(ENTRY MASK)
	MOVL	LLINK(AP),R2		;GET ADDR OF LOGICAL LINK ENTRY
	MOVW	LNK_W_CHAN(R2),-	;SET CHANNEL NUMBER IN QIO
		SLAVEQIO+QIO$_CHAN	;
	BEQL	10$			;BR IF NONE - CONNECT FAILED
	MOVL	ADDR(AP),R3		;GET ADDR OF ADDRESSEE DESC
	SLAVEPUT LENGTH=(R3),- 		;SEND ADDRESSEE NAME
		 BUFFER=@4(R3)
	BSBW	CHK_SLAV_STATUS		;CHECK SLAVE'S REPLY STATUS
10$:
	RET				;

	.PAGE
	.SBTTL	MAIL$NET_SEND - SEND MAIL TO A REMOTE USER
;++
; FUNCTIONAL DESCRIPTION:
;
;	SEND MAIL TO A REMOTE USER.
;
; CALLING SEQUENCE:
;	CALL MAIL$NET_SEND(LLINK,ADDR,RAB)
;
; INPUT PARAMETERS:
;	LLINK(AP) = ADDR OF LOGICAL LINK LIST ENTRY
;	ADDR(AP) = ADDR OF ADDRESSEE DESC
;	RAB(AP) = ADDR OF MESSAGE RAB
;
; IMPLICIT INPUTS:
;	LOGICAL LINK TO ADDRESSEE'S NODE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	MAIL MESSAGE SENT TO SLAVE MAIL JOB AT ADDRESSEE'S NODE.
;
; COMPLETION CODES:
;	R0 = SUCCESS OR FAILURE
;
; SIDE EFFECTS:
;	IF FAILURE, ERROR IS SIGNALED.
;
;--
	.ENTRY	MAIL$NET_SEND,-		;SEND MAIL TO REMOTE ADDRESSEE
		^M<R2,R3,R4,R10>	;(ENTRY MASK)
	MOVL	LLINK(AP),R2		;GET ADDR OF LOGICAL LINK ENTRY
;
; SEND "TO:" AND "SUBJ:"
;
	MOVW	LNK_W_CHAN(R2),-	;SET CHANNEL NUMBER IN SLAVE QIO
		SLAVEQIO+QIO$_CHAN	;
	BNEQ	3$			;BR IF ASSIGNED
	MOVL	#1,R0			;FORCE SUCCESS
	RET				;ELSE, FORGET IT

3$:	BLBC	LNK_B_MSGSNT(R2),5$	;BR IF MESSAGE NOT SENT YET
	BRW	CHECK_SEND		;ELSE - JUST CHECK IF SET OK
5$:
	MOVB	#1,LNK_B_MSGSNT(R2)	;SET MESSAGE SENT
	PUSHL	#0			;CREATE "END-OF-ADDRESSEES" FLAG
	SLAVEPUT LENGTH=#1,-		;SEND "END-OF-ADDRESSEES" FLAG
		 BUFFER=(SP)		;
	SLAVEPUT LENGTH=MAIL$Q_TO,-	;SEND "TO:" LIST
		 BUFFER=@MAIL$Q_TO+4	;
	TSTW	MAIL$Q_SUBJ		;ZERO LENGTH SUBJECT?
	BNEQ	8$			;IF NEQ NO
	SLAVEPUT LENGTH=#0,-		;SEND ZERO LENGTH MESSAGE WITH VALID
		 BUFFER=(SP)		; BUFFER ADDRESS
	BRB	SEND_TEXT		;
8$:	SLAVEPUT LENGTH=MAIL$Q_SUBJ,-	;SEND "SUBJ:" LIST
		 BUFFER=@MAIL$Q_SUBJ+4	;
;
; SEND TEXT OF MESSAGE
;
SEND_TEXT:
	MOVL	RAB(AP),R10		;GET ADDR OF MESSAGE RAB
10$:
	$GET	(R10)			;GET A RECORD
	BLBC	R0,20$			;BR IF EOF OR ERROR
	MOVZWL	RAB$W_RSZ(R10),R3	;GET RECORD SIZE
	CMPW	R3,#1			;IS IT A ONE BYTE RECORD?
	BNEQ	15$			;BR IF NOT
	TSTB	@RAB$L_RBF(R10)		;IS RECORD A SINGLE NULL?
	BEQL	10$			;BR IF YES - SKIP IT TO AVOID CONFUSING
					;WITH "END-OF-FILE" FLAG
15$:	SLAVEPUT LENGTH=R3,-		;SEND RECORD TO SLAVE
		 BUFFER=@RAB$L_RBF(R10)	;
	BRB	10$			;SEND NEXT RECORD
20$:
	SLAVEPUT LENGTH=#1,-		;SEND "END-OF-FILE" FLAG
		 BUFFER=(SP)		;
CHECK_SEND:				;CHECK SLAVE SENT IT OK
	BSBW	CHK_SLAV_STATUS		;CHECK THAT SLAVE GOT MESSAGE OK
	RET				;RETURN

	.PAGE
	.SBTTL	CHK_SLAV_STATUS - CHECK STATUS FROM SLAVE MAIL JOB
;++
;
; CHK_SLAV_STATUS - CHECK STATUS FROM SLAVE MAIL JOB
;
;	THIS SUBROUTINE IS CALLED TO CHECK THAT THE STATUS FROM THE
;	SLAVE MAIL JOB WAS SUCCESS.
;
; INPUTS:
;
;	R2 = ADDR OF LOGICAL LINK LIST ENTRY.
;	SLAVEQIO+QIO$_CHAN = CHANNEL NUMBER OF LOGICAL LINK.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE
;
;	IF THE STATUS WAS NOT SUCCESS, THE STATUS MESSAGE WILL BE
;	SIGNALLED AND THE CALLING PROCEDURE IS EXITED.
;
;--
CHK_SLAV_STATUS:			;CHECK STATUS FROM SLAVE MAIL
	MOVAL	-(SP),R0		;CREATE STATUS BUFFER
	SLAVEGET LENGTH=#4,-		;GET STATUS VALUE FROM SLAVE
		 BUFFER=(R0)		;
	MOVL	(SP)+,R0		;GET STATUS
	BLBC	R0,10$			;BR IF NOT SUCCESS
	RSB				;RETURN
;
; GET STATUS MESSAGE(S) FROM SLAVE AND SIGNAL
;
10$:
	PUSHL	R0			;SAVE STATUS
	CLRL	R3			;SET END-OF-MESSAGES MARKER
20$:
	MOVAL	-MAIL$K_INBUFFSZ(SP),SP ;CREATE MESSAGE BUFFER
	MOVL	SP,R4			;GET ADDR OF MESSAGE BUFFER
	SLAVEGET LENGTH=#MAIL$K_INBUFFSZ,- ;GET MESSAGE FROM SLAVE
		 BUFFER=(R4)		;
	TSTB	(R4)			;END OF MESSAGES?
	BEQL	30$			;BR IF YES - SIGNAL THEM
	PUSHL	R3			;SET ADDR OF PREVIOUS MESSAGE DESC
	PUSHL	R4			;CREATE MESSAGE DESC
	MOVZWL	IOSB+2,-(SP)		;
	MOVL	SP,R3			;SET NEW PREVIOUS DESC ADDR
	BRB	20$			;GET NEXT MESSAGE
30$:
	CLRL	R4			;INIT SIGNAL ARGUMENT COUNT
40$:
	PUSHL	R3			;SET ADDR OF MESSAGE DESC
	MOVW	#1,-(SP)		;SET MESSAGE FLAGS (NO %MAIL-F-TEXT,)
	MOVW	#1,-(SP)		;SET FAO COUNT
	PUSHL	#SHR$_TEXT!-		;SET MESSAGE NAME
		<MAIL$_FACILITY @ STS$V_FAC_NO>
	ADDL	#3,R4			;INCREMENT SIGNAL ARGUMENT COUNT
	MOVL	8(R3),R3		;GET ADDR OF NEXT DESC
	BNEQ	40$			;BR IF THERE IS ONE
	CALLS	R4,G^LIB$SIGNAL		;SIGNAL THE MESSAGES
	POPL	R0			;RESTORE ORIGINAL STATUS
	RET				;EXIT CALLING PROCEDURE


	.PAGE
	.SBTTL	CHK_IO_STATUS - CHECK STATUS OF SLAVE I/O
;++
;
; CHK_IO_STATUS - CHECK STATUS OF SLAVE I/O
;
;	THIS SUBROUTINE IS CALLED TO CHECK THE STATUS OF AN
;	I/O REQUEST WITH THE SLAVE MAIL JOB.
;
; INPUTS:
;
;	R0 = $QIO STATUS
;	IOSB = $QIO I/O STATUS BLOCK
;
; OUTPUTS:
;
;	R0 = I/O STATUS
;
;	IF STATUS NOT SUCCESS, STATUS IS SIGNALLED, AND CALLING
;	PROCEDURE IS EXITED.
;--
CHK_IO_STATUS:				;CHECK SLAVE I/O STATUS
	BLBC	R0,10$			;BR IF $QIO SERVICE FAILURE
	MOVZWL	IOSB,R0			;GET I/O STATUS
	BLBC	R0,10$			;BR IF I/O FAILURE
	RSB				;RETURN
10$:
	PUSHL	R0			;SET STATUS VALUE
	MOVZWL	#SS$_PROTOCOL-STS$K_SEVERE+STS$K_ERROR,-(SP)	;SET MESSAGE
	CALLS	#2,G^LIB$SIGNAL		;SIGNAL THE ERROR
	RET				;EXIT CALLING PROCEDURE

	.PAGE
	.SBTTL	MAIL$DELETELINK - DELETE ALL THE LOGICAL LINKS
;++
; FUNCTIONAL DESCRIPTION:
;
;	DELETE ALL THE LOGICAL LINKS IN THE LOGICAL LINK LIST.
;
; CALLING SEQUENCE:
;	CALL MAIL$DELETELINK()
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	LLINK_LIST = LOGICAL LINK LISTHEAD.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	ALL LOGICAL LINKS ARE DELETED AND SLAVE MAIL JOBS ARE STOPPED.
;
;--
	.ENTRY	MAIL$DELETELINK,-	;DELETE ALL THE LOGICAL LINKS
		^M<R2>			;(ENTRY MASK)
10$:
	REMQUE	@LLINK_LIST,R2		;REMOVE NEXT ENTRY
	BVS	20$			;BR IF NONE - ALL DONE
	$DASSGN_S CHAN=LNK_W_CHAN(R2)	;DELETE THE LOGICAL LINK
	PUSHL	#LNK_K_LENGTH		;SET SIZE OF ENTRY TO DEALLOCATE
	PUSHL	R2			;SET ADDR OF ENTRY
	PUSHAL	(SP)			;SET ADDR OF ADDR OF ENTRY
	PUSHAL	8(SP)			;SET ADDR OF SIZE OF ENTRY
	CALLS	#4,G^LIB$FREE_VM	;DEALLOCATE THE LIST ENTRY
	BRB	10$			;CHECK FOR ANOTHER
20$:
	RET				;RETURN

	.END
