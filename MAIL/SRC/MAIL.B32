MODULE MAIL( %TITLE 'VAX/VMS PERSONAL MAIL UTILITY'
		MAIN = MAIL,
		IDENT = 'V03-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	Entry point to MAIL.  Dispatches according to type of
!		use: CLI command, interactive, or network slave job.
!
! 		This program was originally written as an exercise by the
!		author to learn VAX assembler coding.  The first versions
!		were based on the "PNOTES" program written by Kim Mast for
!		the University of Illinois PLATO system.
!
!		Two of the original goals of the design were simplicity of
!		use and simplicity of operation.  The latter goal suggested
!		the use of the operating system's own indexed filing system,
!		namely file directories.  
!
!		Note also that this program does not purport to be a general
!		purpose "electronic mail system" or "office automation
!		system".  It is simply a mail utility for normal users of
!		a VAX/VMS system.
!
! ENVIRONMENT:	NATIVE/USER MODE
!
! AUTHOR: Len Kawell, CREATION DATE: 20-FEB-1979
!
! MODIFIED BY:
!
!	V03-001	PCA001		Paul Anagnostopoulos	11-Jan-1982
!		Change the file spec for the editor's temporary file so
!		that it is allocated in SYS$SCRATCH.  Then people can
!		use the editor when they're defaulted to a directory
!		for which they don't have write access.
!
!	V2-004	LMK0003		Len Kawell		28-Mar-1981
!		Add SEARCH command, cleanup FILE and BACK commands.  Allow
!		aborting of message entering.  Change some of the error
!		messages.
!
!	V2-003	LMK0002		Len Kawell		27-Feb-1981
!		Add recursive translation of SYS$INPUT.  Fix problem with
!		error prompting in FORWARD command. Add QUIT command.
!
!	V2-002  PCG0001		Peter George		08-Jan-1981
!		Eliminate upward AP references that new Bliss
!		compiler dislikes by distributing global
!		BUILTIN AP declaration.
!
!	V2-001	LMK0001		Len Kawell		17-Jun-1980
!		Fix parsing of filenames to allow full filespecs.
!--

!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	MAIL,					! Main entry point
	CLI_COMMAND,				! CLI command processing
	CLI_ERROR,				! CLI callback error processing
	INTJOB,					! Interactive job processing
	NETJOB;					! Network job processing

FORWARD ROUTINE
	BLANKS_ON :NOVALUE,			! Turn explicit blanks on
	BLANKS_OFF: NOVALUE,			! Turn explicit blanks off
	BACK,					! Backup message action routine
	DELETE,					! Delete message action routine
	CONTINUE,				! Continue READ/DIRECTORY routine
	DIRECTORY,				! Directory action routine
	FILE,					! File message action routine
	FORWRD,					! Forward message action routin
	HELP,					! Help action routine
	NEXT,					! Next message action routine
	PRINT,					! Print message action routine
	READ,					! Read message action routine
	REPLY,					! Reply to message action routine
	SEARCH,					! Search command
	SEND;					! Send message action routine

FORWARD ROUTINE
	CHECK_SEND,				! Check if sending desired
	GET_SEND_MSG;				! Get and send message
!
! INCLUDE FILES:
!
	LIBRARY 'SYS$LIBRARY:LIB.L32';
	LIBRARY 'SYS$LIBRARY:TPAMAC.L32';
	LIBRARY	'SYS$LIBRARY:CLIMAC.L32';
	REQUIRE 'SRC$:MAILREQ.REQ';
	REQUIRE 'SRC$:MAILMSG.B32';
!
! MACROS:
!

!
! EQUATED SYMBOLS:
!
BUILTIN
	AP;					! Argument pointer

LITERAL
	EDIT_FLAG = 0,				! /EDIT flag
	LAST_FLAG = 1,				! /LAST flag
	FILE_FLAG = 2,				! /FILE flag
	EXIT_FLAG = 3,				! EXIT command flag
	QUIT_FLAG = 4;				! QUIT command flag
!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
	LIB$TPARSE: ADDRESSING_MODE(GENERAL),	! Table driven parser
	MAIL$HANDLE,				! Condition handler
	MAIL$ADD_ADDR,				! Add addressee to list
	MAIL$CLOSE_FILE,			! Close message file
	MAIL$CONFIRM,				! Confirm function
	MAIL$DELETE_MSG,			! Delete current message
	MAIL$DIRECTORY,				! Display summary of messages
	MAIL$EDIT,				! Edit a message
	MAIL$ENTER,				! Enter a message
	MAIL$FILE_MSG,				! File current message
	MAIL$FIND_MSG,				! Find a message
	MAIL$GETLK_USER,			! Get and lock uaf record
	MAIL$GET_INPUT,				! Get from sys$input
	MAIL$GET_MSG,				! Get record of current message
	MAIL$GET_USER,				! Get uaf record
	MAIL$HELP,				! Display help
	MAIL$INI_ADDR,				! Initalize addressee list
	MAIL$INFO_MSG,				! Get message information
	MAIL$OPEN_UAF,				! Open system uaf
	MAIL$PRINT,				! Print a message
	MAIL$PUT_OUTPUT,			! Put to sys$output
	MAIL$READ,				! Display a message
	MAIL$REWIND_MSG,			! Rewind current message
	MAIL$SEND_ADDR,				! Send message to addressee(s)
	MAIL$UPDATE_USER,			! Update uaf record
	OTS$SCOPY_DXDX:ADDRESSING_MODE(GENERAL),! String copy desc to desc
	SCR$ERASE:ADDRESSING_MODE(GENERAL),	! Screen package erase screen
	STR$CONCAT:ADDRESSING_MODE(GENERAL),	! String copy and concatenate
	SYS$CLI:ADDRESSING_MODE(ABSOLUTE);	! CLI result parse callback

EXTERNAL
	MAIL$L_MSG_NUM:	WORD,			! Current message number
	MAIL$L_MSG_RADR:LONG,			! Current message record addr
	MAIL$W_MSG_RSIZ:WORD,			! Current message record size
	MAIL$L_MSG_STS:	LONG,			! Current message status
	MAIL$Q_MSGNAME:	BLOCK[,BYTE],		! Default message file name
	MAIL$Q_MSGTYPE: BLOCK[,BYTE],		! Default message file type
	MAIL$T_UAF_BUFF:BLOCK[,BYTE];		! Uaf record buffer

!
! OWN STORAGE:
!
GLOBAL
	MAIL$Q_INPTRAN:	BLOCK[8,BYTE],		! SYS$INPUT translation 
	MAIL$G_INPCHAR: BLOCK[12,BYTE],		! Input device characteristics
	MAIL$B_NET_JOB:	BYTE,			! Network job flag
	MAIL$Q_SUBJ:	BLOCK[8,BYTE]		! Subj: descriptor
			PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
				[DSC$B_CLASS] = DSC$K_CLASS_D),
	MAIL$Q_TO:	BLOCK[8,BYTE]		! To: descriptor
			PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
				[DSC$B_CLASS] = DSC$K_CLASS_D),
	MAIL$Q_USERNAME:BLOCK[8,BYTE],		! Username descriptor
	MAIL$T_USERDEF: VECTOR[UAF$S_DEFDEV +	! User's default file name
			       UAF$S_DEFDIR + %CHARCOUNT('.XXX'),BYTE];
OWN
	CLIWORK:	BLOCK[CLI$K_WORKAREA,BYTE], ! CLI callback work area
	CLIFLAGS:	BITVECTOR[32],		! CLI flags vector
	DIR_FLAG:	LONG,			! DIRECTORY last command flag
	PROCSTS:	LONG,			! Process status
	USERNAME:	VECTOR[12,BYTE],	! Username buffer
	INPTRAN_BUFF:	VECTOR[64,BYTE],	! SYS$INPUT translation buffer
	INPTRAN_BUFF_DESC: BLOCK[8,BYTE]	! SYS$INPUT translation buffer
			INITIAL(LONG(64),	! Descriptor
			        LONG(INPTRAN_BUFF)),
	FILE_DESC:	BLOCK[8,BYTE],		! Message file descriptor
	COMMAND_DESC:	BLOCK[8,BYTE]		! Command descriptor
			PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
				[DSC$B_CLASS] = DSC$K_CLASS_D),
	TMP_ESNAM_BUF:	VECTOR[NAM$C_MAXRSS,BYTE], ! Temporary filename buffer
	TMP_ESNAM_DESC:	BLOCK[8,BYTE]		! Temporary filename descriptor
			PRESET([DSC$A_POINTER] = TMP_ESNAM_BUF),
	TMP_BUFF:	VECTOR[MAIL$K_INBUFFSZ,BYTE], ! Temporary file rec buff
	TMP_NAM:				! Temporary file name block
			$NAM(	ESA=TMP_ESNAM_BUF, !  Expanded name buffer addr
				ESS=NAM$C_MAXRSS), !  Expanded name buffer size
	TMP_FAB:				! Temporary file access block
			$FAB(	DEQ=4,		!  Default extension quantity
				DNM='.TXT',	!  Default file type
				NAM=TMP_NAM),	!  NAM block address
	TMP_RAB:				! Temporary file record access
			$RAB(	FAB=TMP_FAB,	!  FAB address
				UBF=TMP_BUFF,	!  User buffer address
				USZ=MAIL$K_INBUFFSZ), !  User buffer size
	SEARCH_STRING_BUFF: BLOCK[128,BYTE],	! Current search string buffer
	SEARCH_STRING:	BLOCK[8,BYTE]		! Current search string desc
			PRESET([DSC$A_POINTER] = SEARCH_STRING_BUFF),
	TPARSE_BLOCK:	BLOCK[TPA$K_LENGTH0,BYTE] ! Tparse parameter block
		      	INITIAL(LONG(TPA$K_COUNT0),
				LONG(TPA$M_ABBRFM)); ! (Abbrev. First Match)

BIND
	GETUSERNAME =	UPLIT(	WORD(12),	! Get username $GETJPI list
				WORD(JPI$_USERNAME),
				LONG(USERNAME),
				LONG(MAIL$Q_USERNAME),
				LONG(0)),
	GETPROCSTS =	UPLIT(	WORD(4),	! Get process status $GETJPI
				WORD(JPI$_STS),	! list
				LONG(PROCSTS),
				LONG(0),
				LONG(0)),
	INPCHAR_DESC =	UPLIT(	LONG(12),	! Input device characteristics
				LONG(MAIL$G_INPCHAR)), ! Buffer descriptor
	RETURN_MSG =	DESCRIPTOR(%CHAR(CR,LF),! Return reading message
				'Press RETURN to return to reading your mail',
				%CHAR(CR)),
	SUBJ_DESC =	DESCRIPTOR('Subj: '),	! Subj: prompt
	TMPFILE_DESC =	DESCRIPTOR('SYS$SCRATCH:MAIL.TMP')	! Temporary file name
		     :	BLOCK[,BYTE],
	TO_DESC =	DESCRIPTOR('To: '),	! To: prompt
	TOPIC_DESC = FILE_DESC;			! Help topic descriptor

!
! CLI command request descriptors.
!

$CLIQUALCODES (MAIL,SUBJ);			! Define qualifier codes

OWN
    SUBJ_CLIDESC:				! Subject qualifier
	$CLIQUALDESC(QDCODE = SUBJ),

    END_QUAL_CLIDESC:
	$CLIQUALEND,

    GETCMD_CLIDESC:				! Get command request
	$CLIREQDESC(RQTYPE = GETCMD),

    INITIAL_CLIDESC:				! CLI initialization request
	$CLIREQDESC(RQTYPE = INITPRS,
		    RQFLGS = ABSADR,
		    ERRACT = CLI_ERROR),

    INPUT_CLIDESC:				! Get input file spec
	$CLIREQDESC(RQTYPE = INPUT1,
		    RQFLGS = ABSADR,
		    ERRACT = CLI_ERROR),

    USER_CLIDESC:				! Get username spec
	$CLIREQDESC(RQTYPE = INPUT2,
		    RQFLGS = ABSADR,
		    ERRACT = CLI_ERROR),

    QUAL_CLIDESC:				! Parse all command qualifiers
	$CLIREQDESC(RQTYPE = GETQUAL,
		    RQFLGS = ABSADR,
		    ERRACT = CLI_ERROR,
		    QUALST = SUBJ_CLIDESC),

    CLEANUP_CLIDESC:				! CLI cleanup request
	$CLIREQDESC(RQTYPE = ENDPRM1,
		    RQFLGS = ABSADR,
		    ERRACT = CLI_ERROR);


!
! Internal MAIL command parsing table.
!

$INIT_STATE (COMMAND_STATE,COMMAND_KEY);
!
! Get command verb
!
!	Note: the order of the verbs is critical to allow single character
!	      abbreviations for commonly used commands (TPA$M_ABBRFM assumed).
!
	$STATE	(VERB,
		('BACK',TPA$_EXIT,BACK),
		('DELETE',DELETE_PARSE),
		('DIRECTORY',DIRECTORY_PARSE),
		('EXIT',TPA$_EXIT,,1^EXIT_FLAG,CLIFLAGS),
		('FILE',FILE_PARSE),
		('FORWARD',FORWARD_PARSE),
		('HELP',HELP_PARSE),
		('NEXT',TPA$_EXIT,NEXT),
		('PRINT',PRINT_PARSE),
		('QUIT',TPA$_EXIT,,1^QUIT_FLAG,CLIFLAGS),
		('REPLY',REPLY_PARSE),
		('READ',READ_PARSE),
		('SEND',SEND_PARSE),
		('SEARCH',SEARCH_PARSE),
		(TPA$_DECIMAL,TPA$_EXIT,READ),
		(TPA$_EOS,TPA$_EXIT,CONTINUE));
!
! Delete command parsing
!
	$STATE	(DELETE_PARSE,
		(TPA$_EOS,TPA$_EXIT,DELETE));
!
! Directory command parsing
!
	$STATE	(DIRECTORY_PARSE,
		(TPA$_EOS,TPA$_EXIT,DIRECTORY),
		((FILE_NAME),TPA$_EXIT,DIRECTORY));
!
! File command parsing
!
	$STATE	(FILE_PARSE,
		(TPA$_EOS,TPA$_EXIT,FILE),
		((FILE_NAME),TPA$_EXIT,FILE));
!
! Forward command parsing
!
	$STATE	(FORWARD_PARSE,
!		((EDIT_QUAL)),
!		(TPA$_LAMBDA));
!	$STATE	(,
		(TPA$_EOS,TPA$_EXIT,FORWRD));
!
! Help command parsing
!
	$STATE	(HELP_PARSE,
		((TOPIC_PARSE),,,,TOPIC_DESC));
	$STATE	(,
		((TOPIC_PARSE),TPA$_EXIT,HELP));
	$STATE	(TOPIC_PARSE,
		(TPA$_EOS,TPA$_EXIT),
		(TPA$_SYMBOL,TPA$_EXIT),
		('*',TPA$_EXIT),
		('/'));
	$STATE	(,
		(TPA$_SYMBOL,TPA$_EXIT));
!
! Print command parsing
!
	$STATE	(PRINT_PARSE,
		(TPA$_EOS,TPA$_EXIT,PRINT),
		('/'));
	$STATE	(,
		('QUEUE'));
	$STATE	(,
		('='),
		(':'));
	$STATE	(,
		(TPA$_SYMBOL,TPA$_EXIT,PRINT));
!
! Read command parsing
!
	$STATE	(READ_PARSE,
		(TPA$_EOS,TPA$_EXIT,READ),
		(TPA$_DECIMAL,TPA$_EXIT,READ),
		((FILE_NAME),,,,FILE_DESC));
	$STATE	(,
		(TPA$_EOS,TPA$_EXIT,READ),
		(TPA$_DECIMAL,TPA$_EXIT,READ));
!
! Reply command parsing
!
	$STATE	(REPLY_PARSE,
		((EDIT_QUAL),REPLY_PARSE),
		((LAST_QUAL),REPLY_PARSE),
		(TPA$_EOS,TPA$_EXIT,REPLY),
		((FILE_NAME),TPA$_EXIT,REPLY));
!
! Search command parsing
!
	$STATE	(SEARCH_PARSE,
		(TPA$_EOS,TPA$_EXIT,SEARCH),
		((SEARCH_STRING_PARSE),TPA$_EXIT,SEARCH));
	$STATE	(SEARCH_STRING_PARSE,
		(TPA$_EOS,TPA$_EXIT),
		(TPA$_ANY,SEARCH_STRING_PARSE));
!
! Send command parsing
!
	$STATE	(SEND_PARSE,
		((EDIT_QUAL),SEND_PARSE),
		((LAST_QUAL),SEND_PARSE),
		(TPA$_EOS,TPA$_EXIT,SEND),
		((FILE_NAME),TPA$_EXIT,SEND));
!
! EDIT qualifier sub-expression parsing
!
	$STATE	(EDIT_QUAL,
		('/'));
	$STATE	(,
		('EDIT',TPA$_EXIT,,1^EDIT_FLAG,CLIFLAGS));
!
! LAST qualifier sub-expression parsing
!
	$STATE	(LAST_QUAL,
		('/'));
	$STATE	(,
		('LAST',TPA$_EXIT,,1^LAST_FLAG,CLIFLAGS));
!
! File name sub-expression parsing
!
	$STATE	(FILE_NAME,
		(TPA$_ANY,,BLANKS_ON));
	$STATE	(FILE_LOOP,
		(TPA$_BLANK,TPA$_EXIT,BLANKS_OFF),
		(TPA$_EOS,TPA$_EXIT,BLANKS_OFF),
		('"',QUOTE_LOOP),
		(TPA$_ANY,FILE_LOOP));
	$STATE	(QUOTE_LOOP,
		('"',FILE_LOOP),
		(TPA$_ANY,QUOTE_LOOP));

ROUTINE BLANKS_ON :NOVALUE = TPARSE_BLOCK[TPA$V_BLANKS] = 1;
ROUTINE BLANKS_OFF :NOVALUE = TPARSE_BLOCK[TPA$V_BLANKS] = 0;


GLOBAL ROUTINE MAIL =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Main entry point to MAIL utility.  Determines type of use: CLI command
!	processor, interactive mail command processor, or slave process for
!	network mail processing.
!
! INPUTS:
!
!	Command language interpreter parameters.
!
! OUTPUTS:
!
!	Mail utilitity executed.
!--
BEGIN
LOCAL
	STATUS;

ENABLE MAIL$HANDLE;				! Enable condition handler
!
! Determine if process is an interactive or network job
!
IF_ERR($GETJPI(ITMLST=GETPROCSTS);,
	RETURN .STATUS;);
MAIL$B_NET_JOB = .PROCSTS<$BITPOSITION(PCB$V_NETWRK),1>;
!
! Translate SYS$INPUT or SYS$NET logical name and get device's characteristics
!
MAIL$Q_INPTRAN[DSC$A_POINTER] = INPTRAN_BUFF;
STATUS = $TRNLOG(LOGNAM=(IF .MAIL$B_NET_JOB THEN DESCRIPTOR('SYS$NET')
					    ELSE DESCRIPTOR('SYS$INPUT')),
		RSLLEN=MAIL$Q_INPTRAN,
		RSLBUF=INPTRAN_BUFF_DESC);
UNTIL .STATUS EQLU SS$_NOTRAN			! Recursively translate
DO	BEGIN
	IF CH$RCHAR(INPTRAN_BUFF) EQL ESC	! Check for RMS escape
	THEN	BEGIN				! If so, strip it off name
		MAIL$Q_INPTRAN[DSC$W_LENGTH] =  
					.MAIL$Q_INPTRAN[DSC$W_LENGTH] - 4;
		MAIL$Q_INPTRAN[DSC$A_POINTER] = 
					.MAIL$Q_INPTRAN[DSC$A_POINTER] + 4;
		EXITLOOP;
		END;
	STATUS = $TRNLOG(LOGNAM=MAIL$Q_INPTRAN,
			 RSLLEN=MAIL$Q_INPTRAN,
			 RSLBUF=INPTRAN_BUFF_DESC);
	END;
$GETDEV(DEVNAM=MAIL$Q_INPTRAN,
	PRIBUF=INPCHAR_DESC);
!
! Open the system user authorization file
!
IF_ERR(MAIL$OPEN_UAF();,RETURN .STATUS);
!
! Dispatch according to whether this is a CLI command request, an interactive
! mail utility session, or network slave job.
!
SYS$CLI(GETCMD_CLIDESC);			! Get CLI command verb
SYS$CLI(INITIAL_CLIDESC,CLIWORK);		! Initialize other callbacks
SYS$CLI(INPUT_CLIDESC,CLIWORK,CLIFLAGS);	! Get any input file
(IF .INPUT_CLIDESC[CLI$W_RQSIZE] NEQ 0		! If input and not RUN command
AND .GETCMD_CLIDESC[CLI$B_RQSTAT] NEQ CLI$K_VERB_RUN
AND .GETCMD_CLIDESC[CLI$B_RQSTAT] NEQ CLI$K_VERB_MCR
AND .GETCMD_CLIDESC[CLI$B_RQSTAT] NEQ CLI$K_VERB_FORE
THEN
	CLI_COMMAND()				! then dispatch CLI processing
ELSE
	IF .MAIL$B_NET_JOB			! Else, if network job
	THEN
		NETJOB()			! then dispatch to network job
	ELSE
		INTJOB())			! else, interactive job
OR STS$M_INHIB_MSG				! (all routines signal)
END;


ROUTINE CLI_COMMAND =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Callback the CLI for the rest of the command parameters and send
!	the specified file to the specified users.  Then return to the CLI.
!
! INPUTS:
!
!	INPUT_CLIDESC = CLI request descriptor for input filespec.
!	CLIWORK initialized by INITPRS callback request.
!
! OUTPUTS:
!
!	Input file sent to specified users.
!--
BEGIN

LOCAL
	STATUS: LONG;


!
! Get the sender's username
!
IF_ERR($GETJPI(ITMLST=GETUSERNAME);,RETURN .STATUS);
MAIL$Q_USERNAME[DSC$A_POINTER] = USERNAME;
!
! Open the input file and get the subject
!
TMP_FAB[FAB$B_FNS] = .INPUT_CLIDESC[CLI$W_RQSIZE];
TMP_FAB[FAB$L_FNA] = .INPUT_CLIDESC[CLI$A_RQADDR];
TMP_FAB[FAB$B_FAC] = FAB$M_GET;
IF_ERR( $OPEN(FAB=TMP_FAB);,
	TMP_ESNAM_DESC[DSC$W_LENGTH] = .TMP_NAM[NAM$B_ESL]; ! Set filename size
	SIGNAL(	SHR$_OPENIN OR MAIL$V_FACILITY,
		1,TMP_ESNAM_DESC,
		.STATUS,.TMP_FAB[FAB$L_STV]);,
	RETURN .STATUS);
$CONNECT(RAB=TMP_RAB);
!
! Get qualifiers
!
SYS$CLI(QUAL_CLIDESC,CLIWORK,CLIFLAGS);
MAIL$Q_SUBJ[DSC$W_LENGTH] = .SUBJ_CLIDESC[CLI$W_QDVALSIZ];
MAIL$Q_SUBJ[DSC$A_POINTER] = .SUBJ_CLIDESC[CLI$A_QDVALADR];
!
! Get the user names to send to
!
USER_CLIDESC[CLI$V_CONCATINP] = 1;
WHILE .USER_CLIDESC[CLI$V_CONCATINP] OR .USER_CLIDESC[CLI$V_MOREINP]
DO	BEGIN
	SYS$CLI(USER_CLIDESC,CLIWORK,CLIFLAGS);
	STR$CONCAT(	MAIL$Q_TO,			! Add username to list
			MAIL$Q_TO,
			USER_CLIDESC[CLI$Q_RQDESC],
			DESCRIPTOR(','));
	END;
MAIL$Q_TO[DSC$W_LENGTH] = .MAIL$Q_TO[DSC$W_LENGTH] - 1;	! Remove trailing comma
SYS$CLI(CLEANUP_CLIDESC,CLIWORK);			! Cleanup parsing
IF .MAIL$Q_TO[DSC$W_LENGTH] EQL 0			! If no users, prompt
THEN
	(MAIL$GET_INPUT(MAIL$Q_TO,TO_DESC); UPCASE(MAIL$Q_TO));
!
! Add the usernames to the addressee list and send the file to them.
!
MAIL$INI_ADDR();					! Init addressee list
STATUS = CHECK_SEND(MAIL$ADD_ADDR(MAIL$Q_TO));		! Add the addresses
IF .STATUS						! If OK, then send
THEN							! to addressees
	MAIL$SEND_ADDR(TMP_FAB,TMP_RAB);
RETURN .STATUS;						! Return the status
END;

!
! CLI callback error handler
!
ROUTINE CLI_ERROR(CLIBLOCK,ERROR)  =
BEGIN
SIGNAL_STOP(.ERROR);
RETURN (.ERROR);
END;


ROUTINE INTJOB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Get the sender's username and default directory spec, check for
!	new mail, get commands, parse them and dispatch to the command
!	action routines.
!
! INPUTS:
!
!	MAIL$Q_INPTRAN = SYS$INPUT logical name translation descriptor.
!	INPCHAR_DESC = SYS$INPUT device characteristics buffer descriptor
!
! OUTPUTS:
!
!	Commands parsed and executed.
!--
BEGIN
!
! Get the user's name
!
IF_ERR($GETJPI(ITMLST=GETUSERNAME);,RETURN .STATUS);
MAIL$Q_USERNAME[DSC$A_POINTER] = USERNAME;
!
! Get user's default device and directory names and concatenate them together
!
IF_ERR(MAIL$GET_USER(MAIL$Q_USERNAME);,RETURN .STATUS);	! Get uaf record
CH$COPY(.(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_COUNT>,	! Concatenate
	(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_STRING>,
	.(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_COUNT>,
	(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_STRING>,
	.MAIL$Q_MSGTYPE[DSC$W_LENGTH],
	.MAIL$Q_MSGTYPE[DSC$A_POINTER],
	' ',
	UAF$S_DEFDEV + UAF$S_DEFDIR + %CHARCOUNT('.XXX'),
	MAIL$T_USERDEF + 1);
MAIL$T_USERDEF<CS_COUNT> = .(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_COUNT> + ! Save total size
		      .(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_COUNT> +
		      .MAIL$Q_MSGTYPE[DSC$W_LENGTH];
!
! Check for new mail
!
IF .MAIL$T_UAF_BUFF[UAF$W_MAIL] NEQ 0
THEN
	MAIL$PUT_OUTPUT(DESCRIPTOR(%CHAR(CR,LF),
			'You have !UL new message!%S.',%CHAR(CR)),
			.MAIL$T_UAF_BUFF[UAF$W_MAIL]);
!
! Get commands and parse them
!
DO	BEGIN
	IF_ERR( MAIL$GET_INPUT(COMMAND_DESC,		! Get the command
				DESCRIPTOR(%CHAR(LF,LF),'MAIL> '));,
		IF .STATUS NEQ RMS$_EOF THEN SIGNAL(.STATUS);
		EXITLOOP);
	UPCASE(COMMAND_DESC);				! Upcase the command
	TPARSE_BLOCK[TPA$L_STRINGCNT] = .COMMAND_DESC[DSC$W_LENGTH];
	TPARSE_BLOCK[TPA$L_STRINGPTR] = .COMMAND_DESC[DSC$A_POINTER];
	TPARSE_BLOCK[TPA$L_NUMBER] = 0;			! Init file number
	FILE_DESC[DSC$W_LENGTH] = 0;			! Init file name desc
	CLIFLAGS = 0;					! Init qualifier flags
	IF_ERR( LIB$TPARSE(TPARSE_BLOCK,		! Parse the command
			   COMMAND_STATE,
			   COMMAND_KEY);,
		SIGNAL(MAIL$_INVCMD,1,TPARSE_BLOCK[TPA$L_TOKENCNT]));
	END
UNTIL .CLIFLAGS[EXIT_FLAG] OR .CLIFLAGS[QUIT_FLAG];
IF NOT .CLIFLAGS[QUIT_FLAG]				! If not QUIT command,
THEN
	MAIL$CLOSE_FILE();				! Close any open file
$CLOSE(FAB = TMP_FAB);					! Close open input file
RETURN STS$K_SUCCESS
END;


ROUTINE NETJOB =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If this is a network job, it doesn't process commands, rather it
!	is just a slave to send mail to some addressees that are at a different
!	network node than the sender.  This routine reads the sender's and
!	addressee's names from the master mail job and sends the mail to
!	the addressees.  It then just exits.
!
! INPUTS:
!
!	MAIL$Q_INPTRAN = SYS$NET logical name translation.
!
! OUTPUTS:
!
!	Mail message sent to specified addressee's.
!--
BEGIN
OWN
	DESC:	BLOCK[8,BYTE]			! Dynamic descriptor
		PRESET(	[DSC$B_DTYPE] = DSC$K_DTYPE_T,
			[DSC$B_CLASS] = DSC$K_CLASS_D);
LOCAL
	PTR,					! String pointer
	STATUS;					! Status value
!
! Get sender's name
!
MAIL$Q_USERNAME[DSC$B_DTYPE] = DSC$K_DTYPE_T;	! Create dynamic descriptor
MAIL$Q_USERNAME[DSC$B_CLASS] = DSC$K_CLASS_D;
MAIL$Q_USERNAME[DSC$A_POINTER] = 0;
IF_ERR(MAIL$GET_INPUT(MAIL$Q_USERNAME);,RETURN .STATUS);
!
! Add sender's username to the node name, creating a full sender's name
!
IF NOT CH$FAIL(PTR = CH$FIND_CH(.MAIL$Q_INPTRAN[DSC$W_LENGTH],! Find end of node name
				 .MAIL$Q_INPTRAN[DSC$A_POINTER],
				 ':'))
THEN	BEGIN
	MAIL$Q_INPTRAN[DSC$W_LENGTH] = .PTR + 2 - .MAIL$Q_INPTRAN[DSC$A_POINTER];
	STR$CONCAT(MAIL$Q_USERNAME,MAIL$Q_INPTRAN,MAIL$Q_USERNAME);
	END;
!
! Get the addressee names and enter them in addressee list
!
MAIL$INI_ADDR();				! Initialize the list
WHILE 1 DO
	BEGIN
	IF_ERR(MAIL$GET_INPUT(DESC);,		! Get addressee name
		RETURN .STATUS);
	IF CH$RCHAR(.DESC[DSC$A_POINTER]) EQL 0 ! If null name,
	THEN					! Then all done
		EXITLOOP;
	STATUS = MAIL$ADD_ADDR(DESC);		! Add addressee to list
	IF .STATUS				! If success,
	THEN
		SIGNAL(.STATUS);		! Signal the success
	END;
!
! Get the To: and Subj: lists.  There is a bit of "behind the back" error
! handling going on here.  If the master mail job decides not to send,
! the logical link will be broken and one or the other of the following
! MAIL$GET_INPUT calls will fail, causing this job to exit.
!
IF_ERR(	MAIL$GET_INPUT(MAIL$Q_TO);,
	RETURN .STATUS);
IF_ERR(	MAIL$GET_INPUT(MAIL$Q_SUBJ);,
	RETURN .STATUS);
!
! Create a temporary file to store the message text
!
TMP_FAB[FAB$V_TMD] = 1;
IF_ERR( $CREATE(FAB=TMP_FAB);,
	TMP_ESNAM_DESC[DSC$W_LENGTH] = .TMP_NAM[NAM$B_ESL]; ! Set filename size
	SIGNAL(	SHR$_OPENOUT OR MAIL$V_FACILITY,
		1,TMP_ESNAM_DESC,
		.STATUS,.TMP_FAB[FAB$L_STV]);,
	RETURN .STATUS);
$CONNECT(RAB=TMP_RAB);
!
! Get the message text and store in the temporary file
!
STATUS = MAIL$GET_INPUT(DESC);				! Get first record
UNTIL ((.DESC[DSC$W_LENGTH] EQL 1) AND			! Check for terminator
      (CH$RCHAR(.DESC[DSC$A_POINTER]) EQL 0))		! record
OR NOT .STATUS
DO	BEGIN
	TMP_RAB[RAB$W_RSZ] = .DESC[DSC$W_LENGTH];
	TMP_RAB[RAB$L_RBF] = .DESC[DSC$A_POINTER];
	$PUT(RAB = TMP_RAB);				! Put record in file
	STATUS = MAIL$GET_INPUT(DESC);			! Get next record
	END;
!
! If success, send the message
!
IF .STATUS
THEN
	MAIL$SEND_ADDR(TMP_FAB,TMP_RAB)
ELSE
	SIGNAL(.STATUS)
END;


ROUTINE BACK =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the BACK command action routine and is called to display
!	the previous message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	The message before the current message is displayed on SYS$OUTPUT.
!--
BEGIN
!
! If positioned at the first message, then signal no more messages.
!
IF (.MAIL$L_MSG_NUM - 1) EQL 0
THEN	BEGIN
	SIGNAL(MAIL$_NOMOREMSG);
	RETURN STS$K_SUCCESS;
	END;
!
! If positioned past the last message, then display the last message.
!
IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
THEN	BEGIN
	MAIL$FIND_MSG(0,0,.MAIL$L_MSG_NUM);
	MAIL$READ();
	RETURN STS$K_SUCCESS;
	END;
!
! Otherwise, just display the previous message.
!
IF MAIL$FIND_MSG(0,0,.MAIL$L_MSG_NUM - 1)
THEN
	MAIL$READ();
RETURN STS$K_SUCCESS

END;


ROUTINE CONTINUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the <RETURN> command action routine and is called to continue
!	the last display type command.  If the last command was a READ command,
!	then the READ command action routine will be called.  If the last
!	command was a DIRECTORY command and there are more messages to be
!	displayed, then the DIRECTORY routine will be called.
!
! INPUTS:
!
!	DIR_FLAG = 1 if last command was a DIRECTORY command and there are
!		    more messages to be displayed.
!
! OUTPUTS:
!
!	Appropriate action routine selected.
!--
BEGIN
IF .DIR_FLAG						! If more to display
THEN	BEGIN
	MAIL$DIRECTORY();
	IF NOT .MAIL$L_MSG_STS				! If no more messages
	THEN
		DIR_FLAG = 0;				! then clear flag
	END
ELSE
	READ();
RETURN STS$K_SUCCESS
END;


ROUTINE DELETE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the DELETE command action routine and is called to delete
!	the current message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	The current message is deleted from the file it is in.
!--
BEGIN
LOCAL
	STATUS;					! Routine status
STATUS = MAIL$DELETE_MSG();			! Delete the message
IF NOT .STATUS
THEN
	SIGNAL(.STATUS)				! Signal the failure
ELSE
	SCR$ERASE(1,1);				! Erase the screen
RETURN STS$K_SUCCESS
END;

ROUTINE DIRECTORY =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the DIRECTORY command action routine and is called to
!	display a summary of all the messages in the current file or a
!	specified file.
!
! INPUTS:
!
!	AP[TPA$L_TOKENCNT] = Size of specified file name.
!			   = Zero if current file desired.
!	AP[TPA$L_TOKENPTR] = Address of specified file name.
!
! OUTPUTS:
!
!	DIR_FLAG = 1 if more messages to display.
!
!	A summary of each message is displayed on SYS$OUTPUT.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF	BLOCK[,BYTE];			! Argument list pointer

IF MAIL$FIND_MSG(.AP[TPA$L_TOKENCNT],		! Find first message of
		 .AP[TPA$L_TOKENPTR],		! specified message file
		 1)				!
THEN
	MAIL$DIRECTORY();			! Display directory
IF .MAIL$L_MSG_STS				! If more to display,
THEN
	DIR_FLAG = 1;				! then set flag
RETURN STS$K_SUCCESS
END;


ROUTINE FILE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the FILE command action routine and is called to store
!	the current message in a specified file.
!
! INPUTS:
!
!	AP[TPA$L_TOKENCNT] = Size of specified file name size.
!	AP[TPA$L_TOKENPTR] = Address of specified file name size.
!
!	Current message context.
!
! OUTPUTS:
!
!	Current message is appended to the specified file.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF	BLOCK[,BYTE];			! Argument list pointer

!
! If no file name specified, prompt for one, otherwise use command parameter.
!
IF .AP[TPA$L_TOKENCNT] EQL 0
THEN	BEGIN
	MAIL$GET_INPUT(COMMAND_DESC,DESCRIPTOR('Filename: '));
	IF .COMMAND_DESC[DSC$W_LENGTH] EQL 0 THEN RETURN STS$K_SUCCESS;
	MAIL$FILE_MSG(.COMMAND_DESC[DSC$W_LENGTH],
		      .COMMAND_DESC[DSC$A_POINTER]);
	END
ELSE
	MAIL$FILE_MSG(.AP[TPA$L_TOKENCNT],
		      .AP[TPA$L_TOKENPTR]);
RETURN STS$K_SUCCESS
END;


ROUTINE FORWRD =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the FORWARD command action routine and is called to send
!	a copy of the current message to another user or users.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	A copy of the current message is sent to the specified user(s).
!--
BEGIN
LOCAL
	STATUS;					! Routine status
!
! Rewind current message
!
IF_ERR( MAIL$REWIND_MSG();,			! Rewind current message
	SIGNAL (.STATUS);,			! If failure, signal it
	RETURN STS$K_SUCCESS);			! and quit
!
! Create a temporary file to store the message
!
$CLOSE(FAB=TMP_FAB);				! Close any other file
TMP_FAB[FAB$L_FOP] = FAB$M_TMD;			! Temporary marked for delete
IF_ERR( $CREATE(FAB = TMP_FAB);,		! Create a temporary file
	TMP_ESNAM_DESC[DSC$W_LENGTH] = .TMP_NAM[NAM$B_ESL]; ! Set filename size
	SIGNAL(	SHR$_OPENOUT OR MAIL$V_FACILITY,
		1,TMP_ESNAM_DESC,
		.STATUS,.TMP_FAB[FAB$L_STV]);
	RETURN STS$K_SUCCESS);
$CONNECT(RAB = TMP_RAB);			! Connect record stream
!
! Copy the message text to the temporary file
!
DO	BEGIN
	TMP_RAB[RAB$W_RSZ] = .MAIL$W_MSG_RSIZ;
	TMP_RAB[RAB$L_RBF] = .MAIL$L_MSG_RADR;
	STATUS = $PUT(RAB = TMP_RAB);
	END
WHILE MAIL$GET_MSG() AND .STATUS;
IF NOT .STATUS
THEN	BEGIN
	SIGNAL(.STATUS);
	$CLOSE(FAB = TMP_FAB);
	RETURN STS$K_SUCCESS;
	END;
!
! Get the name of the new addressee(s) and send the message.
!
MAIL$GET_INPUT(MAIL$Q_TO,TO_DESC);
IF .MAIL$Q_TO[DSC$W_LENGTH] EQL 0		! If nothing entered, quit
THEN ($CLOSE(FAB = TMP_FAB); RETURN STS$K_SUCCESS);
UPCASE(MAIL$Q_TO);				! Upcase the addressee names
MAIL$INI_ADDR();				! Init addressee list
IF CHECK_SEND(MAIL$ADD_ADDR(MAIL$Q_TO))		! Add addressee(s) to list
THEN	BEGIN
	MAIL$GET_INPUT(MAIL$Q_SUBJ,SUBJ_DESC);	! Get the subject
	MAIL$SEND_ADDR(	TMP_FAB,TMP_RAB);	! Send the message
	END;
$CLOSE(FAB = TMP_FAB);				! Close the temp file
RETURN STS$K_SUCCESS
END;

ROUTINE HELP =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the HELP command action routine and is called to display
!	help for specified commands and topics.
!
! INPUTS:
!
!	TOPIC_DESC = Topic descriptor.
!	AP[TPA$L_TOKENCNT] = Size of specified subtopic.
!	AP[TPA$L_TOKENPTR] = Address of specified subtopic.
!
! OUTPUTS:
!
!	Help for specified topic is displayed on SYS$OUTPUT.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF	BLOCK[,BYTE];			! Argument list pointer

MAIL$HELP(TOPIC_DESC,AP[TPA$L_TOKENCNT]);
RETURN STS$K_SUCCESS;
END;

ROUTINE PRINT = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the PRINT command action routine and is called to queue
!	the current message for printing.
!
! INPUTS:
!
!	AP[TPA$L_TOKENCNT] = Size of specified queue name.
!			   = Zero if none specified.
!	AP[TPA$L_TOKENPTR] = Address of specified queue name.
!
!	Current message context.
!
! OUTPUTS:
!
!	Current message is added to specified queue for printing.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF	BLOCK[,BYTE];			! Argument list pointer

IF_ERR( MAIL$REWIND_MSG();,			! Rewind current message
	SIGNAL(.STATUS); RETURN STS$K_SUCCESS);
MAIL$PRINT(AP[TPA$L_TOKENCNT]);			! Queue a copy of the message
RETURN STS$K_SUCCESS;
END;

ROUTINE READ = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the READ command action routine and is called to display
!	the rest of the current message text, or if there is no more,
!	the text of the next message, or if a specific message is specified,
!	the text of the specified message.
!
! INPUTS:
!
!	AP[TPA$L_NUMBER] = Specified message number.
!	FILE_DESC = Specified message file name descriptor.
!
! OUTPUTS:
!
!	DIR_FLAG = Zero.
!
!	Specified message text is displayed on SYS$OUTPUT.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF	BLOCK[,BYTE];			! Argument list pointer

DIR_FLAG = 0;					! Clear DIRECTORY flag
!
! If there are no more records in the current message or a specific message
! is desired, find the next or specific message, respectively.
!
IF .MAIL$L_MSG_STS EQL 0
OR .MAIL$L_MSG_STS EQL MAIL$_NOTREADIN
OR .FILE_DESC[DSC$W_LENGTH] NEQ 0
OR .AP[TPA$L_NUMBER] NEQ 0
THEN	BEGIN
	IF MAIL$FIND_MSG(.FILE_DESC[DSC$W_LENGTH],
			 .FILE_DESC[DSC$A_POINTER],
			 .AP[TPA$L_NUMBER])
	THEN
		MAIL$READ()
	ELSE
		IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
		THEN
			SIGNAL(MAIL$_NOMOREMSG);
	RETURN STS$K_SUCCESS;
	END;
!
! If there aren't any more messages in the message file, start over with
! the first message in the file.
!
IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
THEN	BEGIN
	IF MAIL$FIND_MSG(0,0,1)
	THEN
		MAIL$READ();
	RETURN STS$K_SUCCESS;
	END;
!
! If there are more records in the current message, display them.  Otherwise
! there is an error.
!
IF .MAIL$L_MSG_STS
THEN
	MAIL$READ()
ELSE
	SIGNAL(.MAIL$L_MSG_STS);
RETURN STS$K_SUCCESS
END;


ROUTINE NEXT = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the NEXT command action routine and is called to display
!	the text of the next message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	Next message text is displayed on SYS$OUTPUT.
!--
BEGIN

IF MAIL$FIND_MSG(0,0,0)				! Find next message
THEN
	MAIL$READ(0,0,0)			! Display it
ELSE
	IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
	THEN
		SIGNAL(MAIL$_NOMOREMSG);
RETURN STS$K_SUCCESS
END;


ROUTINE SEARCH =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the SEARCH command action routine and is called to
!	search for a message containing the specified string.
!
! INPUTS:
!
!	AP[TPA$L_TOKENCNT] = Size of string to search for.
!	AP[TPA$L_TOKENPTR] = Address of string to search for.
!
! OUTPUTS:
!
!	A message containing the search string is displayed.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF BLOCK[,BYTE];			! Argument list pointer

LOCAL
	TEST_REC: BLOCK[8,BYTE],		! Test record descriptor
	TEST_REC_BUFF: BLOCK[MAIL$K_INBUFFSZ];	! Test record buffer

DIR_FLAG = 0;					! Clear directory flag
TEST_REC[DSC$A_POINTER] = TEST_REC_BUFF;	! Init descriptor
!
! If a string is specified, use it and reset search to first message.
!
IF .AP[TPA$L_TOKENCNT] NEQ 0
THEN	BEGIN
	SEARCH_STRING[DSC$W_LENGTH] = MIN(.AP[TPA$L_TOKENCNT],
					  %ALLOCATION(SEARCH_STRING_BUFF));
	CH$MOVE(.SEARCH_STRING[DSC$W_LENGTH],.AP[TPA$L_TOKENPTR],
		SEARCH_STRING_BUFF);
	IF_ERR( MAIL$FIND_MSG(0,0,1);,		! Start with first message
		SIGNAL(.STATUS); RETURN STS$K_SUCCESS);
	END
ELSE
	IF_ERR( MAIL$FIND_MSG(0,0,0);,		! Else, start with next message
		SIGNAL(.STATUS); RETURN STS$K_SUCCESS);
!
! Search through the messages starting with the current.
!
DO 
	DO	BEGIN
		TEST_REC[DSC$W_LENGTH] = MIN(.MAIL$W_MSG_RSIZ,MAIL$K_INBUFFSZ);
		CH$MOVE(.TEST_REC[DSC$W_LENGTH],.MAIL$L_MSG_RADR,
			TEST_REC_BUFF);
		UPCASE(TEST_REC);
		IF NOT CH$FAIL(CH$FIND_SUB(.TEST_REC[DSC$W_LENGTH],
					   .TEST_REC[DSC$A_POINTER],
					   .SEARCH_STRING[DSC$W_LENGTH],
					   .SEARCH_STRING[DSC$A_POINTER]))
		THEN	BEGIN
			MAIL$REWIND_MSG();
			MAIL$READ();
			RETURN STS$K_SUCCESS;
			END;
		END
	UNTIL NOT MAIL$GET_MSG()
UNTIL NOT MAIL$FIND_MSG(0,0,0);
SIGNAL(MAIL$_NOTFOUND,1,SEARCH_STRING);

RETURN STS$K_SUCCESS;
END;


ROUTINE REPLY =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the REPLY command action routine and is called
!	to send a message to the sender of the current message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	Message sent to sender of current message.
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF	BLOCK[,BYTE];			! Argument list pointer

!
! Get the sender and subject of the current message.  Use the sender's name
! as the addressee of the new message.
!
IF_ERR(	MAIL$INFO_MSG(	MAIL$Q_TO,
			MAIL$Q_SUBJ);,
	SIGNAL(.STATUS); RETURN STS$K_SUCCESS);
MAIL$INI_ADDR();
IF_ERR(	MAIL$ADD_ADDR(MAIL$Q_TO);,
	MAIL$REWIND_MSG(); RETURN STS$K_SUCCESS);
MAIL$PUT_OUTPUT(DESCRIPTOR('To:	!AS'),MAIL$Q_TO);
!
! If a subject was specified in the original message, add a "RE:" and use it
! as the subject of the new message.  Otherwise, just prompt for a subject.
!
IF .MAIL$Q_SUBJ[DSC$W_LENGTH] NEQ 0
THEN	BEGIN
	IF .(.MAIL$Q_SUBJ[DSC$A_POINTER]) NEQ 'RE: '   ! If not already "RE:"
	THEN	STR$CONCAT(MAIL$Q_SUBJ,
			   DESCRIPTOR('RE: '),
			   MAIL$Q_SUBJ);
	MAIL$PUT_OUTPUT(DESCRIPTOR('Subj:  !AS'),MAIL$Q_SUBJ);
	END
ELSE
	MAIL$GET_INPUT(MAIL$Q_SUBJ,SUBJ_DESC);
!
! Get the text of the new message and send it
!
GET_SEND_MSG(AP[TPA$L_TOKENCNT]);
RETURN STS$K_SUCCESS
END;


ROUTINE SEND =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the SEND command action routine and is called to
!	send a message to a user or users.
!
! INPUTS:
!
!	AP[TPA$L_TOKENCNT] = Size of name of file to send.
!			   = Zero if none specified.
!	AP[TPA$L_TOKENPTR] = Address of name of file to send.
!
! OUTPUTS:
!
!	Specified file, or SYS$INPUT if none specified, is sent the
!	the addressee(s).
!--
BEGIN

BUILTIN
	AP;					! Argument pointer

MAP
	AP: REF BLOCK[,BYTE];			! Argument list pointer
!
! Get the name of the addressee(s) and add them to the addressee list
!
MAIL$GET_INPUT(MAIL$Q_TO,TO_DESC);
IF .MAIL$Q_TO[DSC$W_LENGTH] EQL 0		! If nothing entered, quit
THEN  RETURN STS$K_SUCCESS;
UPCASE(MAIL$Q_TO);
MAIL$INI_ADDR();
IF NOT CHECK_SEND(MAIL$ADD_ADDR(MAIL$Q_TO))
THEN
	RETURN STS$K_SUCCESS;
!
! Get the subject and text of the message and send it
!
IF NOT MAIL$GET_INPUT(MAIL$Q_SUBJ,SUBJ_DESC) THEN RETURN STS$K_SUCCESS;
GET_SEND_MSG(AP[TPA$L_TOKENCNT]);

RETURN STS$K_SUCCESS
END;


ROUTINE GET_SEND_MSG(FILE_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to complete the sending of a message file.
!
! INPUTS:
!
!	FILE_DESC = Message file name descriptor.
!
!	EDIT_FLAG = 1 if message file is to be edited before sending.
!		  = 0 if message file is not to be edited before sending.
!	LAST_FLAG = 1 if last message sent is to be sent again.
!		  = 0 if new message is to be sent.
!
! OUTPUTS:
!
!	Message file is sent to all addressee(s) in addressee list.
!--
BEGIN
MAP
	FILE_DESC: REF BLOCK[,BYTE];			! File name descriptor
LOCAL
	STATUS;						! Routine status

TMP_FAB[FAB$B_FNS] = .TMPFILE_DESC[DSC$W_LENGTH];	! Set temporary file
TMP_FAB[FAB$L_FNA] = .TMPFILE_DESC[DSC$A_POINTER];	! name addr and size

!
! If the /LAST qualifier was specified and the last file is still open,
! send it.
!
IF .CLIFLAGS[LAST_FLAG] AND .TMP_FAB[FAB$W_IFI] NEQ 0	! If last file specified
THEN	BEGIN
	MAIL$SEND_ADDR(TMP_FAB,TMP_RAB);		! Send previous file
	IF MAIL$REWIND_MSG()
	THEN
		MAIL$PUT_OUTPUT(RETURN_MSG);
	RETURN STS$K_SUCCESS
	END;
!
! Close any previously sent file and, depending on whether /EDIT was
! specified, either call an editor or just prompt for the input message text.
!
$CLOSE(FAB=TMP_FAB);					! Close any other file
IF .CLIFLAGS[EDIT_FLAG]					! If editing specified
THEN	BEGIN
	STATUS = MAIL$EDIT(.FILE_DESC,TMPFILE_DESC);	! Call the editor
	TMP_FAB[FAB$L_FOP] = FAB$M_DLT; 		! Set delete on close
	IF .STATUS THEN STATUS = $OPEN(FAB = TMP_FAB);	! Open the file
	IF .STATUS THEN STATUS = $CONNECT(RAB = TMP_RAB);
	END
ELSE 
	IF .FILE_DESC[DSC$W_LENGTH] EQL 0		! If no file specified
	THEN	BEGIN
		TMP_FAB[FAB$L_FOP] = FAB$M_TMD;		! Temporary file
		STATUS = $CREATE(FAB = TMP_FAB);	! Create the file
		IF .STATUS THEN STATUS = $CONNECT(RAB = TMP_RAB);
		IF .STATUS THEN STATUS = MAIL$ENTER(TMP_RAB);
		END
	ELSE	BEGIN
		TMP_FAB[FAB$B_FNS] = .FILE_DESC[DSC$W_LENGTH];
		TMP_FAB[FAB$L_FNA] = .FILE_DESC[DSC$A_POINTER];
		TMP_FAB[FAB$L_FOP] = 0;			! Clear all options
		STATUS = $OPEN(FAB = TMP_FAB);		! Open the file
		IF .STATUS THEN STATUS = $CONNECT(RAB = TMP_RAB);
		END;
!
! If message text successfully obtained, then send it.  Otherwise signal
! the error.
!
IF .STATUS
THEN
	MAIL$SEND_ADDR(TMP_FAB,TMP_RAB)
ELSE	
	IF .STATUS EQL MAIL$_SENDABORT
	THEN
		SIGNAL(MAIL$_SENDABORT)
	ELSE	
		BEGIN
		TMP_ESNAM_DESC[DSC$W_LENGTH] = .TMP_NAM[NAM$B_ESL]; 
		SIGNAL(SHR$_OPENIN OR MAIL$V_FACILITY,
			1,TMP_ESNAM_DESC,
			.STATUS,.TMP_FAB[FAB$L_STV]);
		END;
!
! If user was previously reading a message, rewind it and display help message.
!
IF MAIL$REWIND_MSG()
THEN
	MAIL$PUT_OUTPUT(RETURN_MSG);

RETURN STS$K_SUCCESS
END;


ROUTINE CHECK_SEND(STATUS) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to check if the ADD_ADDR was completely 
!	successful and if it wasn't, the user is asked if mail should be sent 
!	to the users that were found.
!
! INPUTS:
!
!	STATUS = Status from MAIL$ADD_ADDR.
!
! OUTPUTS:
!
!	Return status = success if mail should be sent.
!		      = failure if mail should not be sent.
!--
BEGIN
MAP
	STATUS:	BLOCK[,BYTE];			! Completion status

IF .STATUS[STS$V_SEVERITY]			! If complete success, ok
THEN
	STS$K_SUCCESS
ELSE
	IF .STATUS[STS$V_SEVERITY] NEQ STS$K_WARNING
	THEN
		STS$K_ERROR			! If not partial success, error
	ELSE
		MAIL$CONFIRM(COMMAND_DESC,	! Else, ask user what to do
			DESCRIPTOR(%CHAR(LF),
				'Do you want to send anyway (Y/N)? '))
END;


END
ELUDOM
