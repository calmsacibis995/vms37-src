	.TITLE	SMBSUBR - SYMBIONT SUBROUTINES
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX/VMS PRINT SYMBIONT
;
; ABSTRACT:	GENERAL SYMBIONT SUBROUTINES
;
;
; ENVIRONMENT:	NATIVE/USER MODE NON-PRIVILEGED CODE
;
; AUTHOR:	H.B.BOSWELL + LEN KAWELL, CREATION DATE: 22-APR-77
;
; MODIFIED BY:
;
;	V02-003	MLJ42329	Martin L. Jack,	14-Jan-1982  23:04
;		Use longword instructions to set up P4.  Use !AF directive to
;		guard against bad input.  Distinguish between QIO failure and
;		timer expiration in advance to top of form.
;
; 02	Gary Fowler	6-Aug-1979
;	Fixed so /NOFEED switch deletes only FORM FEEDS generated when
;	paper is near bottom of page.  It used to delete all FORM FEEDS
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
;	[PRTSMB.SRC]SMBPRE.MAR

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
	$JBCMSGDEF			;JOB CONTROLLER MESSAGES


;
; OWN STORAGE:
;
;
; PAGE HEADER $FAO DESCRIPTOR
;
	PURE_SECTION
HEADER_DESC:
	STRING_DESC	<!AF!3(_)!17%D!2(_)Page !UL!/>

	.PAGE
	.SBTTL	TOP OF FORMS AND PAGE HEADER
;++
; FUNCTIONAL DESCRIPTION: ROUTINE TO ISSUE A TOP OF FORMS OR 
; A TOP OF FORMS AND A PAGE HEADER.
;
;
; CALLING SEQUENCE:
;
;	BSB	SMB$TOPOFORM
;	BSB	SMB$PAGEHDR
;	BSB	SMB$PAGEHDRNFF
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R11 - ADDRESS OF IMPURE DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	TOP OF FORMS OR TOP OF FORMS AND PAGE HEADER PRINTED
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	PURE_SECTION

	.ENABL	LSB

SMB$TOPOFORM::
	PUSHR	#^M<R2>			;SAVE REGISTER
	MOVAL	SD_T_TBUF(R11),R0	;SET DUMMY BUFFER ADDRESS
	CLRL	R1			;NO BUFFER LENGTH
	MOVZBL	#^A\1\,R2		;FF CARRIAGE CONTROL
	CLRB	SD_B_LTPCNT(R11)	;INIT LINES THIS PAGE COUNT
	BRB	10$

SMB$PAGEHDRNFF::
	PUSHR	#^M<R2>			;SAVE REGISTER
	MOVZBL	#^A\ \,R2		;NO FORM FEED
	BRB	5$			;

SMB$PAGEHDR::
	PUSHR	#^M<R2>			;SAVE REGISTER
	MOVZBL	#^A\1\,R2		;FF CARRIAGE CONTROL
;
; CREATE THE PAGE HEADER
;
5$:
	PUSHAL	SD_T_HDBUF(R11)		;PUSH HEADER BUFFER ADDRESS AND
	PUSHL	#SMB$K_HEADERSZ		; HEADER SIZE FOR BUFFER DESCRIPTOR
	MOVL	SP,R0			;SET ADDRESS OF DESCRIPTOR
	MOVZWL	SD_W_PAGE(R11),-(SP)	;PAGE NUMBER
	PUSHAL	SD_Q_PTIME(R11)		;PRINT TIME
	PUSHAB	SD_T_MSGDATA+SIM$T_FILNAM+1(R11) ; File name address
	MOVZBL	SD_T_MSGDATA+SIM$T_FILNAM(R11),-(SP) ; File name length
	PUSHAQ	(R0)			;OUTPUT BUFFER DESC ADDRESS
	PUSHAW	SD_W_HEAD_L(R11)	;RESULTING LENGTH RETURNED HERE
	PUSHAQ	HEADER_DESC		;FORMAT DESCRIPTOR
	CALLS	#9,@#SYS$FAO		;CALL $FAO
	MOVAL	SD_T_HDBUF(R11),R0	;SET HEADER BUFFER ADDRESS
	MOVZWL	SD_W_HEAD_L(R11),R1	;GET HEADER LENGTH
	MOVB	#2,SD_B_LTPCNT(R11)	;INIT LINE COUNT TO 2
10$:

;
; ISSUE THE SPECIAL QIO
;

	$QIOW_S	-			;PRINT THE FORM FEED AND HEADER
	EFN=#SMB$K_TOFEFN,-		;EFN
	CHAN=SD_G_QIOBLK+QIO$_CHAN(R11),- ;CHANNEL
	FUNC=#IO$_WRITELBLK,-		;FUNCTION
	IOSB=SD_Q_TOFIOSB(R11),-	;IOSB ADDRESS
	P1=(R0),-			;BUFFER ADDRESS
	P2=R1,-				;BUFFER LENGTH
	P4=R2				;CARRIAGE CONTROL
	INCL	SD_L_QIOCNT(R11)	;ADD 1 FOR FORM FEED QIO
	BBS	#SD_V_ABORT,SD_B_ERR_FLAGS(R11),30$ ;BR IF ABORTING
	BLBC	R0,25$			;BR IF ERROR
	MOVZWL	SD_Q_TOFIOSB(R11),R0	;GET I/O STATUS
	BEQL	20$			; Br if timer expired (I/O in progress)
	BLBS	R0,20$			;BR IF I/O OK
25$:	SETBIT	SD_V_PRINTERR,SD_B_ERR_FLAGS(R11) ;SET PRINT ERROR
	SIGNAL	JBC$_PRINTOUT,#0,R0	;SIGNAL THE ERROR
	BRB	30$
20$:
	MOVZBL	SD_Q_TOFIOSB+4(R11),R1	;GET # LINES PRINTED
	ADDL	R1,SD_L_LINECNT(R11)	;ADD LINE PRINTED TO TOTAL
30$:
	POPR	#^M<R2>			;RESTORE REGISTERS
	RSB				;RETURN

	.DSABL	LSB
	.PAGE
	.SBTTL	SYMBIONT PRINT LINE ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PRINT A LINE ON THE
;	OUTPUT DEVICE.
;
; CALLING SEQUENCE:
;
;	BSB/JSB SMB$WRITELINS
;	BSB/JSB SMB$WRITELINN
;	BSB/JSB	SMB$WRITELINE
;
; INPUT PARAMETERS:
;
;	R0 IS THE COUNT OF BYTES TO PRINT
;	R1 IS THE ADDRESS OF THE LINE BUFFER
;	R2 IS THE I/O STATUS INDEX
;
; IMPLICIT INPUTS:
;
;	R11 CONTAINS THE ADDRESS OF SYMBIONT IMPURE AREA
;
; OUTPUT PARAMETERS:
;
;	THE LINE IS QUEUED FOR PRINTING
;	R0 IS SET AS PER THE RESULT
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	AS SET BY THE QIO SYSTEM SERVICE
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	PURE_SECTION
 
SMB$WRITELINN::				;WRITE LINE - NORMAL CARRIAGE CONTROL
	MOVZBL	#^A/ /,SD_G_QIOBLK+QIO$_P4(R11) ;SET CARRAIGE CONTROL BYTE
SMB$WRITELINS::

	.ENABL	LSB

	BSBB	SMB$WRITELINE		;PRINT THE LINE
	BLBC	R0,20$			;BR IF ERROR - GET OUT - ERROR ALREADY SET
5$:
	$WAITFR_S	SD_G_QIOBLK+QIO$_EFN(R11) ;WAIT FOR THE I/O
	MOVL	SD_G_QIOBLK+QIO$_IOSB(R11),R1 ;GET IOSB ADDRESS
	MOVZWL	(R1),R0			;GET I/O STATUS
	BLBS	R0,10$			;BR IF SUCCESS
	BBS	#SD_V_ABORT,SD_B_ERR_FLAGS(R11),20$ ;GET OUT IF ABORTING
	SETBIT	SD_V_PRINTERR,SD_B_ERR_FLAGS(R11) ;SET PRINT ERROR
	SIGNAL	JBC$_PRINTOUT,#0,R0	;SIGNAL THE ERROR
	BRB	20$			;GET OUT
10$:
	MOVZBL	4(R1),R1		;GET # LINES PRINTED
	ADDL	R1,SD_L_LINECNT(R11)	;ADD LINES PRINTED TO TOTAL
	MOVZBL	#1,R0			;SET SUCCESS
20$:
	RSB				;RETURN

	.DSABL	LSB
	.ENABL	LSB

SMB$WRITELINE::				;WRITE A LINE TO THE PRINTER

;
; SET UP QIO PARAMETERS
;
	MOVL	R0,SD_G_QIOBLK+QIO$_P2(R11) ;SET BUFFER LENGTH
	MOVL	R1,SD_G_QIOBLK+QIO$_P1(R11) ;SET BUFFER ADDRESS
	MOVAQ	SD_Q_IOSB0(R11)[R2],SD_G_QIOBLK+QIO$_IOSB(R11) ;SET IOSB ADDRESS
	ADDL3	#SMB$K_LPEFN0,R2,SD_G_QIOBLK+QIO$_EFN(R11) ;SET EVENT FLAG NUMBER
	CLRL	R0			;ASSUME ABORT
	BBS	#SD_V_ABORT,SD_B_ERR_FLAGS(R11),60$ ;BR IF ABORT

;
; CHECK IF FORM-FEED/HEADER SHOULD BE PRINTED
;

	CMPB	#STATE$_FLAGPAGE,SD_B_STATE(R11) ;PRINTING FLAG PAGE
	BEQL	50$			;BR IF YES
	BBS	#SD_V_INTRNLCC,SD_B_GEN_FLAGS(R11),50$ ;BR IF INTERNAL CARRIAGE CONTROL
	BBSC	#SD_V_FLGPAGDONE,SD_B_GEN_FLAGS(R11),50$ ;BR IF FLAG PAGE JUST DONE
	BBS	#SD_V_FFREQ,SD_B_GEN_FLAGS(R11),20$ ;BR IF FF REQUIRED
	CMPB	SD_B_MAXLTP(R11),SD_B_LTPCNT(R11) ;IS LINE COUNT TOO BIG
	BGEQU	50$			;BR IF NO - PRINT LINE
15$:	BBS	#PQR$V_NOFEED,SD_T_MSGDATA+SIM$B_FLAGS(R11),50$ ;BR IF NO FORM FEED
20$:
	INCW	SD_W_PAGE(R11)		;INCREMENT THE PAGE NUMBER
	MOVZWL	SD_T_MSGDATA+SIM$W_PAGCNT(R11),R1 ;ANY PAGE LIMIT?
	BEQL	25$			;BR IF NO
	CMPW	SD_W_PAGE(R11),R1	;IS IT OVER THE LIMIT?
	BGTRU	60$			;BR IF YES
25$:	BBC	#PQR$V_PAGHDR,SD_T_MSGDATA+SIM$B_FLAGS(R11),30$ ;BR IF NO PAGE HEADER
	BSBW	SMB$PAGEHDR		;PRINT THE HEADER
	BRB	40$
30$:
	BSBW	SMB$TOPOFORM		;DO THE FORM FEED
40$:
	MOVQ	SD_G_RAB+RAB$W_RFA(R11),-
			SD_Q_TOP_FORMS(R11) ;SAVE THIS RFA FOR BACKING UP

;
; QUEUE THE LINE TO THE PRINTER
;
50$:
	INCL	SD_L_QIOCNT(R11)	;ADD 1 FOR THE QIO COUNT
	INCB	SD_B_LTPCNT(R11)	;ASSUME ONE LINE WILL BE PRINTED
	$QIO_G	SD_G_QIOBLK(R11)	;ISSUE THE QIO
	BLBS	R0,60$			;BR IF OK
	SETBIT	SD_V_PRINTERR,SD_B_ERR_FLAGS(R11) ;SET PRINT ERROR
	SIGNAL	JBC$_PRINTOUT,#0,R0	;SIGNAL THE ERROR
60$:
	RSB

	.DSABL	LSB
	.PAGE
	.SBTTL	SEND MESSAGE TO SYMBIONT MANAGER
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO SEND A MESSAGE TO
;	THE SYMBIONT MANAGER
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SMB$FILE_DONE
;	BSB/JSB SMB$INIT_DONE
;
; INPUT PARAMETERS:
;
;	R3 - SMB$FILE_DONE - REASON FOR TERMINATION
;	R0 - SMB$INIT_DONE - MAILBOX UNIT NUMBER
;
; IMPLICIT INPUTS:
;
;	R11 CONTAINS THE ADDRESS OF THE SYMBIONT IMPURE DATA
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R2 DESTROYED
;
;--
 
	PURE_SECTION

	.ENABL	LSB

SMB$FILE_DONE::
	MOVAL	SD_G_MSGTOMGR(R11),R0	;GET ADDRESS OF MESSAGE BUFFER
	MOVW	R3,2(R0)		;SET REASON FOR TERMINATION
	MOVL	SD_L_GETCNT(R11),4(R0)	;SET GET COUNT IN MSG
	MOVL	SD_L_QIOCNT(R11),8(R0)	;SET QIO COUNT IN MSG
	MOVZBL	SD_B_PAGELEN(R11),R1	;GET PAGE LENGTH
	MOVW	R1,14(R0)		;SET PAGE LENGTH IN MSG
	MOVL	SD_L_LINECNT(R11),R2	;GET TOTAL LINES PRINTED
	DIVL	R1,R2			;CALC NUMBER OF PAGES PRINTED
	MOVW	R2,12(R0)		;SET PAGE COUNT IN MSG
	MOVZBL	#16,R1			;SET MSG LENGTH
	MOVW	#SIM$K_SIZE,SD_W_MBREADLEN(R11) ;SET READ LENGTH FOR INIT MSG
	MOVW	#MSG$_SMBDON,R0		;SET SYMBIONT DONE MESSAGE
	BRB	10$

SMB$INIT_DONE::
	MOVW	R0,SD_G_MSGTOMGR+2(R11)	;SET MB UNIT NUMBER IN INIT DONE MSG
	MOVZWL	#MSG$_SMBINI,R0		;SET INIT DONE MESSAGE
	MOVZBL	#4,R1			;SET MSG LENGTH
10$:
	MOVW	R0,SD_G_MSGTOMGR+0(R11)	;SET MESSAGE
	$QIOW_S		-		;SEND MESSAGE TO MANAGER
	EFN=#SMB$K_MBEFN,-		;EVENT FLAG
	CHAN = SD_W_JBCCHAN(R11),-	;CHANNEL TO SYMBIONT MANAGER
	FUNC = #IO$_WRITEVBLK!IO$M_NOW,-;WRITE OPERATION
	IOSB=SD_Q_MIOSB(R11),-		;IOSB
	P1   = SD_G_MSGTOMGR(R11),-	;BUFFER
	P2   =R1			;BYTE COUNT

	BLBC	R0,20$			;BR IF ERROR
	MOVZWL	SD_Q_MIOSB(R11),R0	;GET I/O STATUS
	BLBS	R0,30$			;BR IF OK
20$:	SIGNAL	JBC$_MBWRITE,#0,R0	;SIGNAL THE ERROR
30$:	RSB


	.DSABL	LSB
	.PAGE
	.SBTTL	SET UNSOLICITED DATA AST FOR MAILBOX
;++
; FUNCTIONAL DESCRIPTION: ROUTINE TO SET MAILBOX AST
;
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SMB$SETMBAST
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R11 - ADDRESS OF IMPURE DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	MAILBOX AST SET
;
; SIDE EFFECTS:
;
;	NONE
;
;--



SMB$SETMBAST::
	$QIOW_S	-			;SET UNSOLICITED AST
	EFN=#SMB$K_MBEFN,-		;EVENT FLAG
	CHAN=SD_W_MBCHAN(R11),-		;CHANNEL
	FUNC=#IO$_SETMODE,-		;SET UNSOLICITED AST
	IOSB=SD_Q_MIOSB(R11),-		;IOSB
	P1=SMB$MBAST			;AST ADDRESS

	BLBC	R0,10$			;BR IF ERROR
	MOVZWL	SD_Q_MIOSB(R11),R0	;GET I/O STATUS
	BLBS	R0,20$			;BR IF OK
10$:	SIGNAL	JBC$_MBSETAST,#0,R0	;SIGNAL THE ERROR
20$:	RSB

	.PAGE
	.SBTTL	GET CHANNEL INFORMATION
;++
; FUNCTIONAL DESCRIPTION: ROUTINE TO GET CHANNEL INFORMATION INTO
; THE TEMP BUFFER.
;
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SMB$GETCHAN
;
; INPUT PARAMETERS:
;
;	R0 - ADDRESS OF CHANNEL
;
; IMPLICIT INPUTS:
;
;	R11 - ADDRESS OF IMPURE DATA BLOCK
;
; OUTPUT PARAMETERS:
;
;	CHANNEL INFO IN SD_G_TBUF(R11)
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



SMB$GETCHAN::
	MOVAL	SD_W_TBUFSIZ(R11),R1	;SET ADDRESS OF TEMP BUF DESC
	MOVW	(R1),-(R1)		;SET BUFFER COUNT TO SIZE OF BUF
	$GETCHN_S CHAN=(R0),SCDBUF=(R1)	;GET CHANNEL INFO
	RSB
	.PAGE
	.SBTTL	ASSIGN DEVICE
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO ASSIGN A SPECIFIED CHANNEL TO
;	A DEVICE. THE ASSIGNMENT IS DONE WITH A PRECEEDING "_"
;	TO INSURE THAT THE DEVICE ASSIGNED IS THE ONE SPECIFIED.
;
; CALLING SEQUENCE:
;
;	BSB/JSB	SMB$ASSIGNDEV
;
; INPUT PARAMETERS:
;
;	R0 IS THE ADDRESS OF THE DEVICE NAME OF THE FORM:
;
;		.WORD	UNIT_NUMBER
;		.ASCII	<COUNT>/GENERIC_NAME/
;
;	R1 CONTAINS THE ADDRESS OF LONGWORD TO STORE ASSIGNED CHANNEL NUMBER.
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	THE SPECIFIED LOCATION CONTAINS THE CHANNEL NUMBER.
;
; IMPLICIT OUTPUTS:
;
;	THE CHANNEL IS ASSINGED
;
; COMPLETION CODES:
;
;	R0 RETURNED AS SET BY THE SYSTEM SERVICE ASSIGN CHANNEL.
;
; SIDE EFFECTS:
;
;	R2 DESTROYED
;
;--
	PURE_SECTION
 
SMB$ASSIGNDEV::				;ENTER WITH JSB/BSB
	SUBL	#20,SP			;MAKE DEVICE NAME BUFFER IN STACK
	MOVL	SP,R2			;SET BUFFER POINTER
	PUSHR	#^M<R1,R2>		;PUSH BUFFER ADDRESS FOR DESCRIPTOR
					;AND SAVE CHANNEL NUMBER ADDRESS
	MOVZBL	(R0)+,R1		;GET LENGTH OF GENERIC NAME
	MOVB	#^A/_/,(R2)+		;START NAME WITH UNDERSCORE TO PREVENT
					;LOGICAL NAME TRANSLATION
10$:	MOVB	(R0)+,(R2)+		;APPEND DEVICE NAME TO UNDERSCORE
	SOBGTR	R1,10$			;MOVE ENTIRE NAME
	MOVB	#^A/:/,(R2)+		;DEVICE NAMES GET A COLON ON END
	POPR	#^M<R1>			;RESTORE CHANNEL NUMBER
	SUBL3	(SP),R2,-(SP)		;COMPUTE COUNT FOR STRING DESCRIPTOR
	MOVL	SP,R0			;GET ADDRESS OF DEVICE NAME DESCRIPTOR
	$ASSIGN_S  (R0),(R1)		;NOW ASSIGN THE CHANNEL
	ADDL	#20+8,SP		;CLEAR BUFFER & DESCRIPTOR FROM STACK
	RSB

	.END
