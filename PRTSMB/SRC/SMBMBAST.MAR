	.TITLE	SMBMBAST - SYMBIONT MAILBOX AST ROUTINE
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: VAX/VMS PRINT SYMBIONT
;
; ABSTRACT: MAILBOX AST ROUTINES
;
; ENVIRONMENT: NATIVE/USER PRIVILEGED CODE.

;
; AUTHOR:	H.B. BOSWELL + LEN KAWELL, CREATION DATE: 21-APR-77
;
; MODIFIED BY:
;
;	V02-007	MLJ43853	Martin L. Jack,	15-Feb-1982  13:26
;		Cause ABORT, REQUEUE, SUSPEND, and RESUME messages received
;		when the symbiont is idle to be ignored rather than errors.
;		This condition can arise if the job termination message has
;		been sent but not yet processed by the job controller.
;
;	V02-006	GWF0089		Gary Fowler		23-Jul-1981
;		Always use move mode
;
;	V02-005	GWF0063		Gary Fowler		29-Jun-1981
;		Set form feed required flag and set lines printed so far to one
;		greater than max lines.  This forces form feed when processing
;		START/TOP_OF_FORM.
;
;	V02-004	GWF0047		Gary Fowler		18-May-1981
;		Clear delete bit if message is a requeue command.  This
;		prevents implicitily spooled files from being deleted when
;		requeued.
;
;	V02-003	GWF0001		Gary Fowler		5-Nov-1979
;		Check if page length is 0, if it is make it equal to 1.
;		This avoids a divide by 0 error calculating number of
;		pages printed and a loop calculating number of lines
;		overflowed at end of page.
;
;	V02-002	LMK0001		Len Kawell		25-Apr-1979
;		Add error check for $connect.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS


;
; INCLUDE FILES:
;
;	[PRTSMB.SRC]SMBPRE.MAR


;
; MACROS:
;


;
; EQUATED SYMBOLS:
;
	$PCBDEF				; PROCESS CONTROL BLOCK OFFSETS
	$JBCMSGDEF			; JOB CONTROLLER MESSAGES
	$SHRDEF				; SHARED MESSAGES
;
; OWN STORAGE:
;

	.PAGE
	.SBTTL	MAILBOX AST CODE
;++
; FUNCTIONAL DESCRIPTION:
;
;
; CALLING SEQUENCE:
;
;	CALLED AT AST LEVEL WHEN SOMETHING IS PUT IN THE MAILBOX
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	MESSAGE IN THE MAILBOX

;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	SEE EACH MSG HANDLER
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--

	PURE_SECTION


SMB$MBAST::
	.WORD	^M<R2,R3,R4,R5,R9,R10,R11> ;ENTRY MASK
	MOVAL	W^SMB$G_DATA,R11	;SET IMPURE DATA BLOCK
	MOVZBL	SD_B_STATE(R11),R10	;GET CURRENT STATE
READ_MB_AGAIN:
	CMPB	#STATE$_ASNDEV,R10	;TRYING TO ASSIGN THE PRINTER
	BNEQ	10$			;BR IF NO
	BSBW	ASNDEV			;TRY IT AGAIN
10$:	BSBW	READ_MB_NOW		;READ THE MAILBOX
	BLBS	R0,CHK_MBREAD		;BR IF OK
;
; RE-ENABLE AST
;

	BSBW	SMB$SETMBAST		;REENABLE THE AST
	MOVB	R10,SD_B_STATE(R11)	;SET CURRENT STATE
	RET				;EXIT THE AST

;
; CASE TO CORRECT MESSAGE HANDLER
;

CHK_MBREAD:
	PUSHAB	READ_MB_AGAIN		; SET NORMAL RETURN ADDRESS
	CASE	SD_T_MSGDATA+SIM$W_MSGTYP(R11),<- ;DISPATCH TO MESSAGE HANDLER
		<INIT>,-		;INITIATE PRINT
		<ABORT>,-		;ABORT PRINT
		<SUSPEND>,-		;SUSPEND PRINTING
		<RESUME>,-		;RESUME PRINTING
		<EXIT>,-		;SYMBIONT EXIT
		<ABORT>,-		;SYMBIONT REQUEING FILE
		>,LIMIT=#MSG$_INIOPR	;START AT FIRST MESSAGE
	SIGNAL	JBC$_INVMSG		;SIGNAL THE ERROR
	BRB	READ_MB_AGAIN		;READ MAILBOX AGAIN

UNEXPECT:				;UNEXPECTED SYMBIONT MANAGER MSG
	SIGNAL	JBC$_UNESYMMSG		;SIGNAL THE ERROR
	BRB	READ_MB_AGAIN		;READ MAILBOX AGAIN

	.PAGE
	.SBTTL	MESSAGE HANDLER - RESUME

;
; RESUME PRINTING
;

	.ENABL	LSB

RESUME:
	CMPB	#STATE$_EOF_CLOS,R10	;ARE WE DONE
	BEQL	30$			;BR IF YES - IGNORE IT
	TSTB	R10			;ARE WE IDLE
	BEQL	30$			;BR IF YES - IGNORE IT
	CMPB	#STATE$_SUSPEND,R10	;ARE WE SUSPENDED
	BNEQ	UNEXPECT		;BR IF NO
	MOVZBL	R9,R10			;RESTORE PREVIOUS STATE
	MOVW	SD_T_MSGDATA+SIM$W_REST(R11),R0 ;GET INDICATOR
	BEQL	30$			;BR IF NO INDICATOR - JUST RESUME

;
; BACKWARD SPACE FILE
;

	CMPB	#STATE$_FLAGPAGE,R10	;PRINTING FLAG PAGE
	BEQL	30$			;BR IF YES - GET OUT
	CMPW	#^X8000,R0		;IS IT TOP OF FILE
	BNEQ	10$			;BR IF NO
7$:
	$REWIND	SD_G_RAB(R11)		;REWIND THE FILE
	BLBS	R0,20$			;BR IF OK
	BRB	12$			
10$:
	TSTL	SD_Q_TOP_FORMS(R11)	;DO WE HAVE A TOP OF FORMS YET
	BEQL	7$			;BR IF NO - REWIND
	MOVC3	#6,SD_Q_TOP_FORMS(R11),-
			SD_G_RAB+RAB$W_RFA(R11) ;SET RFA OF LAST FORM FEED
	MOVB	#RAB$C_RFA,SD_G_RAB+RAB$B_RAC(R11) ;SET RFA MODE
	$FIND	RAB=SD_G_RAB(R11)	;FIND THE FORM FEED RECORD
	BLBS	R0,15$			;BR IF $FIND OK
12$:	SETBIT	SD_V_GETERR,SD_B_ERR_FLAGS(R11) ;SET GET ERROR
	SIGNAL	SHR$_RMSERROR!<4@16>,#0,R0 ;SIGNAL THE ERROR
	RSB				;

	ASSUME	RAB$C_SEQ EQ 0

15$:
	CLRB	SD_G_RAB+RAB$B_RAC(R11)	;SET ACCESS BACK TO SEQUENTIAL
20$:
	ADDB3	#1,SD_B_MAXLTP(R11),SD_B_LTPCNT(R11) ;FORCE FORM FEED IF NECESSARY
	SETBIT	SD_V_FFREQ,SD_B_GEN_FLAGS(R11) ; SET FF REQUIRED BIT
30$:	RSB				;
 
	.DSABL	LSB			;

	.DSABL	LSB
	.PAGE
	.ENABL	LSB

SUSPEND:
	CMPB	#STATE$_EOF_CLOS,R10	;ARE WE DONE
	BEQL	20$			;BR IF YES - IGNORE IT
	TSTB	R10			;ARE WE IDLE
	BEQL	20$			;BR IF YES - IGNORE IT
	MOVZBL	R10,R9			;SAVE CURRENT STATE FOR RESUME
	MOVZBL	#STATE$_SUSPEND,R10	;SET SUSPEND STATE
	MOVZWL	#IO$_READVBLK,R0	;SET FUNCTION CODE
	BSBB	READ_MB			;READ THE MAILBOX
CHKMB1:	MOVAB	CHK_MBREAD,(SP)		; SET NEW RETURN ADDRESS
20$:	RSB				;

	.DSABL	LSB

;
; LOCAL SUBROUTINE TO READ THE MAILBOX
;
; INPUT - AT READ_MB WITH  R0 = FUNCTION CODE
;
	.ENABL	LSB
READ_MB_NOW:				; ENTER FOR READ-NOW
	MOVZWL	#IO$_READVBLK!IO$M_NOW,R0 ; SET FUNCTION OF READ WITH NO WAIT
READ_MB:
	MOVAQ	-(SP),R1		;CREATE SPACE FOR IOSB
	$QIOW_S		-		;READ THE MAILBOX
	EFN=#SMB$K_MBEFN,-		;EVENT FLAG
	CHAN=SD_W_MBCHAN(R11),-		;MAILBOX CHANNEL
	FUNC=R0,-			;FUNCTION
	IOSB=(R1),-			;I/O STATUS BLOCK
	P1=SD_T_MSGDATA(R11),-		;DATA BUFFER ADDRESS
	P2=SD_W_MBREADLEN(R11)		;READ SIZE
	MOVQ	(SP)+,R0		;GET I/O STATUS
10$:	RSB
	.PAGE
	.SBTTL	MESSAGE HANDLER - INITIATE PRINT

;
; INITIATE PRINT
;

	.ENABL	LSB
5$:	.LONG	<-1*50000000>,-1	; WAIT FIVE SECONDS

INIT:

	ASSUME	STATE$_IDLE EQ 0

	TSTB	R10			;ARE WE IDLE
	BEQL	10$			;BR IF YES
	BRW	UNEXPECT		;UNEXPECTED MESSAGE
10$:
	MOVZBL	#STATE$_ASNDEV,R10	;SET ASSIGNING DEVICE STATE
ASNDEV:	MOVW	#4,SD_W_MBREADLEN(R11)	;SET READ LENGTH TO MIMINUM
12$:	MOVAB	SD_T_MSGDATA+SIM$T_PRTNAM(R11),R0 ;POINT AT DEVICE NAME
	MOVAW	SD_G_QIOBLK+QIO$_CHAN(R11),R1 ;ADDRESS OF WORD TO STORE CHANNEL
	BSBW	SMB$ASSIGNDEV		;ASSIGN THE PRINTER
	BLBS	R0,17$			;BR IF ALL IS WELL
	BSBB	READ_MB_NOW		;SEE IF THERE IS ANY MAIL
	BLBS	R0,CHKMB1		;BR IF YES-CHECK OUT THE MESSAGE
	$SETIMR_S #SMB$K_TIMEFN,5$	;WAIT FOR A LITTLE WHILE
	$WAITFR_S #SMB$K_TIMEFN
	BRB	12$			;TRY TO ASSIGN THE PRINTER
17$:	INCL	R10			; CHANGE STATE TO OPEN
	MOVAL	SD_G_QIOBLK+QIO$_CHAN(R11),R0 ;GET ADDR OF CHANNEL
	BSBW	SMB$GETCHAN		;GET LP CHANNEL INFO
	CVTWB	SD_T_TBUF+6(R11),SD_B_PAGEWIDTH(R11) ;SET PAGE WIDTH
	MOVB	SD_T_TBUF+11(R11),SD_B_PAGELEN(R11) ;SET PAGE LENGTH
	BNEQ	35$				; BR IF NOT ZERO
	INCB	SD_B_PAGELEN(R11)		; MAKE EQUAL TO 1
35$:	SUBB3	#4,SD_T_TBUF+11(R11),-
			SD_B_MAXLTP(R11) ;SET MAX LINES THIS PAGE
	CLRL	SD_L_GETCNT(R11)	;INIT GET COUNT
	CLRL	SD_L_QIOCNT(R11)	;INIT QIO COUNT
	CLRL	SD_L_LINECNT(R11)	;INIT LINE COUNT

	ASSUME	NAM$W_FID EQ NAM$T_DVI+16
	ASSUME	NAM$W_DID EQ NAM$W_FID+6

	MOVC3	#16+6+6,SD_T_MSGDATA+SIM$T_VOLNAM(R11),- ;SET DEVICE, -
			SD_G_NAM+NAM$T_DVI(R11) ;FILE AND DIRECTORY ID'S
	$GETTIM_S	SD_Q_PTIME(R11)	;GET TIME FILE WAS PRINTED
	MOVZBL	SD_T_MSGDATA+SIM$T_FILNAM(R11),- ;CREATE FILENAME DESC
		SD_Q_FILENAME(R11)
	MOVAB	SD_T_MSGDATA+SIM$T_FILNAM+1(R11),-
		SD_Q_FILENAME+4(R11)
	BSBW	SMB$SETUIC		; SET UIC TO REQUESTORS
	MOVL	#FAB$M_NAM,SD_G_FAB+FAB$L_FOP(R11) ;OPEN BY FILE ID
						  ;(ALSO CLEAR OTHER OPTIONS)
	$OPEN	SD_G_FAB(R11)		;OPEN THE FILE
	BLBS	R0,20$			;BR IF OK
18$:
	SETBIT	SD_V_OPENERR,SD_B_ERR_FLAGS(R11) ;SET OPEN ERROR
	MOVZBL	#STATE$_EOF_CLOS,R10	;SET EOF_CLOSE STATE
	BRB	30$			;GET OUT
20$:					;
	$CONNECT	RAB=SD_G_RAB(R11);CONNECT THE RAB
	BLBS	R0,25$			;BR IF OK
	ASSUME	FAB$L_STV EQ FAB$L_STS+4
	ASSUME	RAB$L_STV EQ RAB$L_STS+4
	MOVQ	SD_G_RAB+RAB$L_STS(R11),-  ;SAVE ERROR STATUS VALUES
		SD_G_FAB+FAB$L_STS(R11)
	BRB	18$			;QUIT
25$:
	MOVAB	SD_T_SQBUF(R11),SD_G_RAB+RAB$L_RHB(R11) ;SET HEADER BUF ADDR
	CMPB	#2,SD_G_FAB+FAB$B_FSZ(R11) ;IS THE FSZ OK
	BGEQU	30$			;BR IF YES
	CLRL	SD_G_RAB+RAB$L_RHB(R11)	;DON'T GET THE RECORD HEADER
30$:	BSBB	SMB$RSTUIC		; RESTORE UIC TO DEFAULT
	CLRL	SD_Q_TOP_FORMS(R11)	;SHOW NO TOP OF FORM YET FOR RESUME
	CMPB	#FAB$C_VFC,SD_G_FAB+FAB$B_RFM(R11) ;SEQUENCE NO. OR PRINT FORMAT?
	BNEQ	WAKUP			;BR IF NOT
	BBS	#FAB$V_PRN,SD_G_FAB+FAB$B_RAT(R11),WAKUP ;BR IF PRINT FILE FORMAT
	CLRBIT	RAB$V_LOC,SD_G_RAB+RAB$L_ROP(R11) ;USE MOVE MODE
WAKUP:	SETBIT	SD_V_GOOD_WAKE,SD_B_GEN_FLAGS(R11) ;SET GOOD WAKE FOR MAIN CODE
	$WAKE_S				;WAKE THE SYMBIONT
	RSB				;
 
	.DSABL	LSB			;
 
;+
; SETUIC - SET UIC TO THAT OF THE REQUESTOR
; RSTUIC - RESET UIC TO NORMAL
;-
	.ENABL	LSB
DEFUIC:	.LONG	<^O1@16+^O4>		; DEFAULT UIC = [1,4]
 
SMB$SETUIC::				; SET UIC TO THAT OF REQUESTOR
	MOVAL	SD_T_MSGDATA+SIM$L_UIC(R11),R0 ; UIC IS HERE
	BRB	10$
SMB$RSTUIC::				; RESTORE UIC
	MOVAB	DEFUIC,R0		; DEFAULT UIC
10$:	$CMKRNL_S  B^100$,(R0)		; EXECUTE KERANL MODE ROUTINE
	RSB				;

;
; KERNAL ACCESS MODE ROUTINE TO SET SYMBIONT UIC
;
100$:	.WORD	0			; ENTRY
	MOVL	@#SCH$GL_CURPCB,R0	; GET CURRENT PROCESS CONTROL BLOCK
	MOVL	(AP),PCB$L_UIC(R0)	; SET THE UIC
	INCL	R0			; MAKE AN ODD VALUE
	RET				;
 
	.DSABL	LSB
	.PAGE
	.SBTTL	MESSAGE HANDLER - ABORT AND EXIT
;
; ABORT PRINT
;

	.ENABL	LSB

ABORT:
	CMPB	#STATE$_EOF_CLOS,R10	;ARE WE DONE
	BEQL	30$			;BR IF YES - IGNORE IT
	TSTB	R10			;ARE WE IDLE
	BEQL	30$			;BR IF YES - IGNORE IT
	SETBIT	SD_V_ABORT,SD_B_ERR_FLAGS(R11) ;SET ABORT PRINT BIT
	$CANCEL_S SD_G_QIOBLK+QIO$_CHAN(R11) ;CANCEL PRINTER I/O
	CMPW	SD_T_MSGDATA+SIM$W_MSGTYP(R11),-
		#MSG$_REQUE		; IS THIS A REQUEUE REQUEST?
	BNEQU	15$			; IF NEQ - THEN NO
	CLRBIT	PQR$V_DELETE,-		; YES - CLEAR DELETE BIT
		SD_T_MSGDATA+SIM$B_FLAGS(R11) ; IN FLAGS BYTE
15$:	CMPB	#STATE$_SUSPEND,R10	;WERE WE SUSPENDED
	BNEQ	20$			;BR IF NO
	MOVZBL	R9,R10			;RESTORE PREVIOUS STATE
20$:	CMPB	#STATE$_ASNDEV,R10	; TRYING TO ASSIGN THE PRINTER?
	BNEQ	30$			; BR IF NO
	CLRL	R10			; SET IDLE
30$:	RSB				;

	.DSABL	LSB

;
; SYMBIONT EXIT
;

	.ENABL	LSB

EXIT:
	CMPB	#STATE$_IDLE,R10	;ARE WE IDLE
	BEQL	10$			;BR IF YES
	BRW	UNEXPECT		;UNEXPECTED MESSAGE
10$:
	$DASSGN_S	SD_W_JBCCHAN(R11) ;DEASSIGN THE MGR'S MB
	BLBC	R0,20$			;BR IF ERROR
	$DASSGN_S	SD_W_MBCHAN(R11) ;DEASSIGN MY MB
	BLBS	R0,30$			;BR IF OK
20$:	SIGNAL	JBC$_MBDEAS,#0,R0	;SIGNAL THE ERROR
30$:	$DELMBX_S	SD_W_MBUNIT(R11) ;DELETE MY MB (JUST IN CASE)
	$EXIT_S				;DONE - GET OUT

	.DSABL	LSB
 
	.END
