MODULE parse (IDENT = 'V03-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  Command language editor
!
! ABSTRACT:
!
!	This facility is used to enhance the command language
!	and allow user-written commands to be available in the
!	language.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Tim Halvorsen, Feb 1980
!
! Modified by:
!
!	V018	DWT0028		David Thiel	09-Feb-1982
!		Add MCRIGNORE keyword to DEFINE SYNTAX.
!
!	V017	DWT0025		David Thiel	29-Jan-1982
!		Add MCROPTDELIM keyword to KEYWORD lists.
!		Add MCRIGNORE keyword to qualifier and parameter
!		lists.
!
!	V016	DWT0018		David Thiel	30-Dec-1981
!		Allow new line within OUTPUTS construct.
!
!	V015	DWT0015		David Thiel	24-Dec-1981
!		Add OUTPUTS DCL () support.
!		Make some errors semantic errors.
!		Eliminate parameter symbols.
!		Save user routine addresses in list rather than
!		symbol table.
!
!	V014	DWT0007		David W. Thiel	10-Dec-1981
!		Sort parameters by number.
!		Flag missing parameter and duplicated parameter errors.
!		Reorganize inputs and outputs for MCR tables.
!
!	V013	BLS0089		Benn Schreiber	19-Oct-1981
!		Add support for OUTPUTS MCR and conditional define verb
!
!	V012	TMH0012		Tim Halvorsen	25-Aug-1981
!		Accept user ROUTINE construct in DEFINE SYNTAX.
!		Change value type codes to start at 1, rather than 0.
!		Add value type $REST_OF_LINE.
!		Do not require prompts on parameters, but default it
!		to the label name.
!
!	V011	TMH0011		Tim Halvorsen	15-Apr-1981
!		Accept optional commas after DEFINE VERB verbname
!
!	V010	TMH0010		Tim Halvorsen	28-Mar-1981
!		Allow any number of verbs as synonyms by allowing
!		a list of verb , e.g. DEFINE VERB (A,B).
!
!	V009	TMH0009		Tim Halvorsen	26-Mar-1981
!		Add PREFIX construct to allow specification
!		of the default prefix used to output global
!		symbols for entitiy numbers.  This will be
!		used to support users of the old CLI interface
!		only, and will be unsupported.
!
!	V008	TMH0008		Tim Halvorsen	19-Mar-1981
!		Truncate CLI$K_ symbols to 4 characters for
!		output entities.
!		Preset module_name null at the start of each
!		input source file.
!
!	V007	TMH0007		Tim Halvorsen	12-Mar-1981
!		Add pre-defined types ($UIC, $INFILE, etc).
!
!	V006	TMH0006		Tim Halvorsen	17-Feb-1981
!		Do not request presence of command line entities
!		if we were invoked via a foreign command
!
!	V005	TMH0005		Tim Halvorsen	25-Jan-1981
!		Fix incorrectly detected syntax error when comments
!		appear at the end of the file.  Always set ENT_V_CONCAT
!		to allow concatenation of parameter values.
!
!	V004	TMH0004		Tim Halvorsen	05-Jan-1981
!		Generate longword offsets to user routines
!		if /OBJECT specified.
!
!	V003	TMH0003		Tim Halvorsen	23-Dec-1980
!		Report semantic errors via a different routine so
!		that the error appears following the proper line
!		in the listing file.
!
!	V002	TMH0002		Tim Halvorsen	13-Nov-1980
!		Add MODULE construct to express module name for
!		use with object module output.
!		Make a prelimary try at mutual exclusion lists.
!
!	V001	TMH0001		Tim Halvorsen	13-Nov-1980
!		Expand size of image name to 128 characters.
!		Remove check forcing labels to be specified on parameters.
!--

!
! Include files
!

LIBRARY 'SYS$LIBRARY:STARLET';		! VAX/VMS common definitions

LIBRARY 'SYS$LIBRARY:TPAMAC';		! TPARSE definitions

REQUIRE 'SRC$:CLEDEF.REQ';		! Utility definitions

!
! Table of contents
!

FORWARD ROUTINE
    handler,				! Condition handler for parsing
    parse_file,				! Parse input file
    get_record,				! Get next input record
    get_cont_line,			! Get continuation line and plug in
    init_verb,				! Initialize for verb definition
    store_synonym,			! Store additional verb synonyms
    init_list,				! Initialize for change list definition
    store_output,			! Store output definition
    convert_io_name,			! Convert I/O name to #
    store_group_entry,			! Store exclusion entry
    store_group,			! Store mutual exclusion group
    store_param,			! Store parameter definition
    store_qual,				! Store qualifier definition
    store_verb,				! Store verb definition
    sort_prolist : NOVALUE,		! Sort parameter list
    mcr_sort : NOVALUE,			! Reorganize parms and quals for MCR
    add_modsym,				! Make modifier a global symbol
    store_syntax,			! Store syntax list definition
    store_keyword,			! Store keyword definition
    store_type,				! Store type definition
    reference_syntax,			! Process reference to syntax list
    reference_type,			! Process reference to type list
    store_number,			! Store/check numeric qualifier value
    store_string,			! Store/check string qualifier value
    store_text,				! Save text string into named buffer
    copy_string:	NOVALUE;	! Copy string to another string buffer

!
! Misc. symbol definitions
!

LITERAL
    globals = 0,			! Global symbol table index
    syntax_lists = 1,			! Change list symbol table index
    modifiers = 2,			! Modifiers symbol table
    keyword_lists = 3,			! Syntax list symbol table index
    params = 5,				! Parameter list symbol table index
    form_feed = 12,			! Form feed character
    max_outputs = 8,			! Maximum number of outputs
    max_qual_num = 255-8,		! Maximum qualifier number
    max_excludes = 256,			! Maximum entities in exclusion groups
					! including 1 byte per group
    symbol_bufsiz = obj$c_symsiz,	! Maximum size of symbol name
    image_bufsiz = 128,			! Maximum size of image name
    qual_bufsiz = symbol_bufsiz,	! Maximum size of qualifer name
    prompt_bufsiz = 32,			! Maximum size of prompt string
    defval_bufsiz = 64,			! Maximum length of default value

    cmd_bufsiz = cmd_c_length+max_outputs+1+image_bufsiz+1, ! Max size of CMD
    parm_bufsiz = ent_k_length+prompt_bufsiz+1+defval_bufsiz+1, ! Max size of PRO plus prompt
    qua_bufsiz = ent_c_length+2*symbol_bufsiz+defval_bufsiz+1, ! Max size of QUA
					! + default value + qual name/label
    chg_bufsiz = chg_c_length+image_bufsiz+1;		! Max size of CHG

GLOBAL
    num_files:		INITIAL(0),	! Total files acceped as input
    input_record:	VECTOR[2],	! Input record descriptor
    input_linenum,			! Line number of input record
    rtn_listhead;			! User routine listhead

OWN
    tparse_block: BBLOCK[tpa$c_length0]	! TPARSE parameter block
		PRESET( [tpa$l_count]	= tpa$k_count0),

    cmd:		BBLOCK [cmd_bufsiz],	! CMD buffer
    pro:		BBLOCK [parm_bufsiz],	! PARM buffer
    qua:		BBLOCK [qua_bufsiz],	! QUA buffer
    chg:		BBLOCK [chg_bufsiz],	! CHG buffer
    exclude_size:	WORD,		! Number of bytes in exclude_list used
					! (this is updated when an entire group
					! is stored, therefore, this always
					! is the offset to the current group).
    exclude_list:	VECTOR [max_excludes,BYTE],! Exclusion groups (counted)
    output_list:	VECTOR [max_outputs+1,BYTE], ! Outputs (0 terminated)
    qual_number,			! Current qualifier number
    syntax_entry:	REF VECTOR,	! Syntax list entry address (0 if none)
    type_entry:		REF VECTOR,	! Type entry address (0 if none)

    verb_listhead,			! Listhead of verb synonyms for command
    parm_listhead,			! Listhead of defined PRO blocks
    qua_listhead,			! Listhead of defined QUA blocks
    key_listhead,			! Listhead of defined keywords (QUAs)

    line_output:	BYTE;		! True if line was output

COMPILETIME
    buffer_num = 0;			! Starting number for buffer names

MACRO
    string_buffer(name,size) =
	%ASSIGN(buffer_num,buffer_num+1)
	%NAME('buffer',%NUMBER(buffer_num)): BBLOCK [size],
	name: VECTOR [2] INITIAL(0,%NAME('buffer',%NUMBER(buffer_num)))%;
	
OWN
    string_buffer(verb_name,	symbol_bufsiz),	! Name of verb
    string_buffer(list_name,	symbol_bufsiz),	! Name of change list
    string_buffer(name,		symbol_bufsiz),	! Name of keyword
    string_buffer(prompt_name,	prompt_bufsiz),	! Parameter prompt
    string_buffer(symbol_prefix,symbol_bufsiz),	! Global symbol prefix
    string_buffer(image_name,	image_bufsiz),	! Image name
    string_buffer(routine_name,	symbol_bufsiz),	! Routine name
    string_buffer(entity_label,	symbol_bufsiz),	! Entity label (LABEL= keyword)
    string_buffer(default_value,defval_bufsiz);	! Default qualifier value

OWN
    module_name_buffer:		VECTOR [symbol_bufsiz,BYTE];

GLOBAL
    string_buffer(ident_name,	symbol_bufsiz);	! Module ident string

!
! Generate table of pre-defined types and their values
!
! The values of each type is computed from the relative position within
! this table.  The first keyword is given the value one, and so on.
! This list must be maintained in the same order as the values of the
! symbols in an entity definition block.
!

BIND
    predefined_types = UPLIT BYTE(
	%ASCIC '$INFILE',		! Input file specification
	%ASCIC '$OUTFILE',		! Output file specification
	%ASCIC '$NUMBER',		! Numeric quantity
	%ASCIC '$PRIVILEGE',		! Privilege keyword
	%ASCIC '$DATETIME',		! Date/time specification
	%ASCIC '$PROTECTION',		! File/device protection
	%ASCIC '$PROCESS',		! Process name
	%ASCIC '$INLOG',		! Input logical name
	%ASCIC '$OUTLOG',		! Output logical name
	%ASCIC '$INSYM',		! Input symbol name
	%ASCIC '$OUTSYM',		! Output symbol name
	%ASCIC '$NODE',			! Node name
	%ASCIC '$DEVICE',		! Device name
	%ASCIC '$DIRECTORY',		! Directory specification
	%ASCIC '$UIC',			! UIC specification
	%ASCIC '$REST_OF_LINE',		! Rest of the command string (HELP)
	0);				! -- End of list
    
!
! External storage
!

EXTERNAL
    clitype:		BYTE,		! CLI type from command or tables
    foreign_command:	BYTE,		! Flag indicating if foreign command
    module_name:	VECTOR [2],	! Descriptor of module name string
    input_fab:		BBLOCK,		! Input file FAB
    input_rab:		BBLOCK;		! Input file RAB

!
! External routines
!

EXTERNAL ROUTINE
    add_command,			! Add command to data base
    add_change,				! Add a change list
    add_entity_list,			! Add a entity descriptor list
    line_with_value,			! Output a line with a hex value
    echo_record,			! Output a line w/only record
    new_page,				! Cause a page eject
    syntax_error,			! Report syntax error
    semantic_error,			! Report semantic error
    add_record,				! Add data record to linked list
    find_record,			! Find record in linked list
    delete_list,			! Deallocate entire linked list
    add_symbol,				! Add symbol to symbol table
    lookup_symbol,			! Lookup symbol in symbol table
    lookup_value,			! Lookup value in symbol table
    scan_symbols,			! Scan all symbols in symbol table
    delete_symbol,			! Delete symbol in symbol table
    delete_symbols,			! Delete entire symbol table
    allocate,				! Allocate dynamic storage
    deallocate,				! Deallocate dynamic storage
    lookup_routine,			! Lookup routine name
    lookup_verb_type,			! Lookup verb type code
    rms_error,				! Signal RMS-type error
    cli$present,			! Check if command line entity present
    lib$tparse: ADDRESSING_MODE(GENERAL);	! Parsing routines

!
!	Message definition language parse tables
!

MACRO ap_setup = BUILTIN AP; MAP ap: REF BBLOCK%;
ROUTINE set_number = (ap_setup; ap [tpa$l_number] = .ap [tpa$l_param]; false);
ROUTINE get_status = (ap_setup; .ap [tpa$l_number]);

OWN
    parse_state:	INITIAL(-1);	! Internal parse state

ROUTINE set_state = (ap_setup; parse_state = .ap [tpa$l_param]; false);
ROUTINE if_state = (ap_setup; .parse_state EQL .ap [tpa$l_param]);
ROUTINE check_cli = (ap_setup; .clitype EQL .ap [tpa$l_param]);

$init_state(parse_states,parse_keys);	! Define start of parse table

!
!	Dispatch to recovery states in the event that we were
!	just interrupted by a detected error.
!

$state(,
	(tpa$_lambda,verb_keyword,if_state,,,1),
	(tpa$_lambda,syntax_keyword,if_state,,,2),
	(tpa$_lambda,type_keyword,if_state,,,3),
	(tpa$_lambda));

!
!	Parse MODULE construct which may only appear at the beginning
!	of the command definition file
!

$state(start,
	((next)));
$state(,
	('MODULE',module_stmt),
	('IDENT',ident_stmt),
	(tpa$_lambda,main));

$state(module_stmt,
	(tpa$_symbol,start,store_text,,,
		PLIT(module_name,module_name_buffer,1,symbol_bufsiz)));

$state(ident_stmt,
	((quoted_string),start,store_string,,,PLIT(ident_name,1,symbol_bufsiz)));

!
!	Dispatch to the various command parsers
!

$state(main,
	((next)));
$state(,
	(tpa$_lambda,tpa$_exit,if_state,,,4),	! If EOF, then exit parse
	(tpa$_lambda,,set_state,,,0),		! Else, reset state
	('DEFINE'));				! And check for definition

$state(define,
	((next)));
$state(,
	('VERB',verb_defn),
	('TYPE',type_defn),
	('SYNTAX',change_defn));

!
!	Return true if eol (cannot be called twice, eats !)
!

$state(eol,
	(tpa$_lambda,tpa$_exit,if_state,,,4),	! True if end of file
	('!',tpa$_exit),			! or comment
	(tpa$_eos,tpa$_exit));			! or end of line

!
!	Skip to the next token over blank lines - always return true
!

$state(next,
	('!'),
	(tpa$_eos),
	(tpa$_lambda,tpa$_exit));
$state(next_line,
	(tpa$_lambda,next,get_cont_line),	! Read next input record
	(tpa$_lambda,,set_state,,,4),		! If failed, set EOF state
	(tpa$_lambda,tpa$_exit));		! and exit

!
!	Gobble a comma (if any) and skip empty lines - always return true
!

$state(comma,	
	(',',next),
	(tpa$_lambda,next));

!
!	Parse a value which may be a quoted string, terminated
!	by either a comma, right paren or end-of-line
!

$state(quoted_string,
	('"'),
	(tpa$_lambda,gobble_noquotes));
$state(gobble_string,
	((gobble_qchar),gobble_string),
	('"',tpa$_exit));

$state(gobble_noquotes,
	((gobble_char),gobble_noquotes),
	(tpa$_lambda,tpa$_exit));

$state(gobble_char,			! Gobble anything but comma
	(',',tpa$_fail),
	(')',tpa$_fail),
	((eol),tpa$_fail),
	(tpa$_any,tpa$_exit));

$state(gobble_qchar,			! Gobble anything but double quote
	('"',tpa$_fail),
	((eol),tpa$_fail),
	(tpa$_any,tpa$_exit));

!
!	Test if the next token is a first or second level keyword
!

$state(if_keyword,
	(tpa$_lambda,tpa$_exit,if_state,,,4),	! True if end of file
	((if_keyword2)),
	(tpa$_lambda,tpa$_exit,get_status));	! Return tpa$l_number (t/f)

! Peek at next token; always return false so token is not gobbled

$state(if_keyword2,
	(tpa$_lambda,,set_number,,,true),	! Assume a keyword
	('DEFINE',tpa$_fail),			! Exit if any of these match
	('IMAGE',tpa$_fail),
	('PARAMETER',tpa$_fail),
	('QUALIFIER',tpa$_fail),
	('NOPARAMETERS',tpa$_fail),
	('NOQUALIFIERS',tpa$_fail),
	('PREFIX',tpa$_fail),
	('OUTPUTS',tpa$_fail),
	('EXCLUDE',tpa$_fail),
	('KEYWORD',tpa$_fail),
	('MCRIGNORE',tpa$_fail),
	(tpa$_lambda,,set_number,,,false));	! Indicate not a keyword

$state(check_dcl,
	('DCL'));

$state(,
	('(',tpa$_exit));

$state(check_mcr,
	('MCR'));

$state(,
	('(',tpa$_exit));

!
!	DEFINE VERB statement
!

$state(verb_defn,
	((check_dcl),verb_dcl),
	((check_mcr),verb_mcr),
	('(',list_of_verbs),
	(tpa$_symbol,,store_string,,,PLIT(verb_name,1,symbol_bufsiz)));
$state(,
	(tpa$_lambda,,set_state,,,1),
	(tpa$_lambda,end_keyword,init_verb));

$state(list_of_verbs,
	(tpa$_symbol,,store_string,,,PLIT(verb_name,1,symbol_bufsiz)));
$state(,
	(tpa$_lambda,,set_state,,,1),
	(tpa$_lambda,,init_verb));

$state(next_verb_in_list,
	((comma)));
$state(,
	(')',end_keyword0),
	(tpa$_symbol,next_verb_in_list,store_synonym));

$state(end_keyword0,
	((comma)));

$state(,
	((check_dcl),list_of_verbs),
	((check_mcr),list_of_verbs),
	(tpa$_lambda,verb_keyword));

$state(end_keyword,
	((comma)));

$state(verb_keyword,
	((next)));

$state(,
	('ROUTINE',intimage),
	('IMAGE',image),
	('PREFIX',prefix),
	('PARAMETER',parameter),
	('QUALIFIER',qualifier),
	('OUTPUTS',outputs),
	('EXCLUDE',mutex_group),
	(tpa$_lambda,main,store_verb));

$state(verb_dcl,
	(tpa$_lambda,list_of_verbs,check_cli,,,vec_c_dcl),
	((skip_verb),end_mcrdcl));

$state(verb_mcr,
	(tpa$_lambda,list_of_verbs,check_cli,,,vec_c_mcr),
	((skip_verb)));

$state(end_mcrdcl,
	(',',verb_defn),
	(tpa$_lambda,verb_keyword));

$state(skip_verb,
	(tpa$_symbol,skipverb1),
	(tpa$_lambda));

$state(skipverb1,
	(')',tpa$_exit),
	(',',skip_verb));

!
!	IMAGE keyword
!

$state(image,
	((quoted_string),end_keyword,store_string,,,PLIT(image_name,1,image_bufsiz)));

!
!	ROUTINE keyword
!

$state(intimage,
	((quoted_string),end_keyword,store_string,,,PLIT(routine_name,1,symbol_bufsiz)));


!
!	PREFIX keyword
!

$state(prefix,
	((quoted_string),end_keyword,store_string,,,PLIT(symbol_prefix,1,symbol_bufsiz)));

!
!	OUTPUTS attribute
!

$state(outputs,
	((next)));
$state(,
	('MCR',outputs_mcr),
	('DCL',outputs_dcl),
	('(',outputs2),
	(tpa$_lambda,end_keyword));
$state(outputs_mcr,
	(tpa$_lambda,mcr_outputs_list,check_cli,,,vec_c_mcr),
	(tpa$_lambda,skip_outputs));
$state(outputs_dcl,
	(tpa$_lambda,outputs_list,check_cli,,,vec_c_dcl),
	(tpa$_lambda,skip_outputs));
$state(mcr_outputs_list,
	(tpa$_lambda,,,cmd_m_mcrparse,cmd [cmd_b_flags]));
$state(outputs_list,
	((next)));
$state(,
	('('),
	(tpa$_lambda,outputs));		!Allow "outputs mcr" only
$state(,
	((next)));
$state(outputs2,
	(')',outputs),
	(tpa$_symbol,,store_output));
$state(,
	((comma),outputs2));
$state(skip_outputs,
	((next)));
$state(,
	('('),
	(tpa$_lambda,outputs));		!Allow "outputs mcr" only
$state(,
	((next)));
$state(skip_outputs2,
	(')',outputs),
	(tpa$_symbol));
$state(,
	((comma),skip_outputs2));

!
!	EXCLUDE attribute
!

$state(mutex_group,
	('('));
$state(group2,
	(')',end_keyword,store_group),
	(tpa$_symbol,,store_group_entry));
$state(,
	((comma),group2));

!
!	PARAMETER keyword
!

$state(parameter,
	((parameter_guts),end_keyword,store_param));

$state(parameter_guts,
	(tpa$_symbol,,store_string,,,PLIT(name,1,qual_bufsiz)));
$state(param2,
	((comma)));
$state(,
	('LABEL',param_name),
	('MCRIGNORE',param2,,ent_m_mcrignore, pro [ent_l_flags]),
	('PROMPT',param_prompt),
	('VALUE',param_value),
	((if_keyword),tpa$_exit));

$state(param_name,
	('='));
$state(,
	(tpa$_symbol,param2,store_string,,,PLIT(entity_label,1,symbol_bufsiz)));

$state(param_prompt,
	('='));
$state(,
	((quoted_string),param2,store_string,,,PLIT(prompt_name,0,prompt_bufsiz)));

$state(param_value,
	('(',param_value3),
	(tpa$_lambda,param2));

$state(param_value2,
	((comma)));
$state(param_value3,
	(')',param2),
	('REQUIRED',param_value2,,ent_m_valreq, pro [ent_l_flags]),
	('IMPCAT',param_value2,,ent_m_impcat, pro [ent_l_flags]),
	('DEFAULT',param_defval),
	('LIST',param_value2,,ent_m_list, pro [ent_l_flags]),
	('TYPE',param_keywords));

$state(param_defval,
	('='));
$state(,
	((quoted_string),param_value2,store_string,,,PLIT(default_value,1,defval_bufsiz)));

$state(param_keywords,
	('='));
$state(,
	(tpa$_symbol,param_value2,reference_type,,,pro));

!
!	QUALIFIER keyword
!

$state(qualifier,
	((qualifier_guts),end_keyword,store_qual));

$state(qualifier_guts,
	((check_dcl),dcl_qual),
	((check_mcr),mcr_qual),
	(tpa$_symbol,,store_string,,,PLIT(name,1,qual_bufsiz)));
$state(qual2,
	((comma)));
$state(qual3,
	('LABEL',qual_name),
	('MCRIGNORE',qual2,,ent_m_mcrignore, qua [ent_l_flags]),
	('PROMPT',qual_prompt),
	('DEFAULT',qual2,,ent_m_deftrue, qua [ent_l_flags]),
	('BATCH',qual2,,ent_m_batdef, qua [ent_l_flags]),
	('NONNEGATABLE',qual2,,ent_m_neg, qua [ent_l_flags]), ! neg = NONNEG
	('PLACEMENT',qual_placement),
	('SYNTAX',qual_change),
	('VALUE',qualifier_value,,ent_m_val, qua [ent_l_flags]),
	((if_keyword),tpa$_exit));

$state(qual_name,
	('='));
$state(,
	(tpa$_symbol,qual2,store_string,,,PLIT(entity_label,1,symbol_bufsiz)));

$state(qual_prompt,
	('='));
$state(,
	((quoted_string),qual2,store_string,,,PLIT(prompt_name,0,prompt_bufsiz)));

$state(qual_placement,
	('='));
$state(,
	('GLOBAL',qual2,,ent_m_verb, qua [ent_l_flags]),
	('LOCAL',qual2,,ent_m_parm, qua [ent_l_flags]),
	('POSITIONAL',qual2,,ent_m_verb OR ent_m_parm, qua [ent_l_flags]));

$state(qual_change,
	('='));
$state(,
	(tpa$_symbol,qual2,reference_syntax,,,syntax_entry));

!
!	Qualifier value specification
!

$state(qualifier_value,
	('(',qual_value3),
	(tpa$_lambda,qual2));

$state(qual_value2,
	((comma)));
$state(qual_value3,
	(')',qual2),
	('REQUIRED',qual_value2,,ent_m_valreq, qua [ent_l_flags]),
	('DEFAULT',qual_defval),
	('LIST',qual_value2,,ent_m_list, qua [ent_l_flags]),
	('TYPE',qual_keywords));

$state(qual_defval,
	('='));
$state(,
	((quoted_string),qual_value2,store_string,,,PLIT(default_value,1,defval_bufsiz)));

$state(qual_keywords,
	('='));
$state(,
	(tpa$_symbol,qual_value2,reference_type,,,qua));

$state(dcl_qual,
	(tpa$_lambda,special_qual,check_cli,,,vec_c_dcl),
	(tpa$_lambda,skip_qual));

$state(mcr_qual,
	(tpa$_lambda,special_qual,check_cli,,,vec_c_mcr),
	(tpa$_lambda,skip_qual));

$state(special_qual,
	(tpa$_symbol,,store_string,,,PLIT(name,1,qual_bufsiz)));

$state(,
	(')'));

$state(,
	((comma)));

$state(,
	((check_dcl),dcl_qual),
	((check_mcr),mcr_qual),
	(tpa$_lambda,qual3));

$state(skip_qual,
	(tpa$_symbol),
	(tpa$_lambda));

$state(,
	(')',qual2));

!
!	DEFINE SYNTAX statement
!

$state(change_defn,
	(tpa$_symbol,,store_string,,,PLIT(list_name,1,symbol_bufsiz)));
$state(,
	(tpa$_lambda,,set_state,,,2),
	(tpa$_lambda,,init_list));
$state(list2,
	((comma)));
$state(syntax_keyword,
	((next)));
$state(,
	('IMAGE',list_image,,chg_m_image, chg [chg_b_flags]),
	('ROUTINE',list_routine,,chg_m_image, chg [chg_b_flags]),
	('PREFIX',list_prefix),
	('PARAMETER',list_parameter,,chg_m_parms, chg [chg_b_flags]),
	('QUALIFIER',list_qualifier,,chg_m_quals, chg [chg_b_flags]),
	('NOPARAMETERS',list2,,chg_m_parms,chg [chg_b_flags]),
	('NOQUALIFIERS',list2,,chg_m_quals,chg [chg_b_flags]),
	('MCRIGNORE',list2,,chg_m_mcrignore,chg [chg_b_flags]),
	(tpa$_lambda,main,store_syntax));

$state(list_image,
	((quoted_string),list2,store_string,,,PLIT(image_name,1,image_bufsiz)));

$state(list_routine,
	((quoted_string),list2,store_string,,,PLIT(routine_name,1,symbol_bufsiz)));

$state(list_prefix,
	((quoted_string),list2,store_string,,,PLIT(symbol_prefix,1,symbol_bufsiz)));

$state(list_parameter,
	((parameter_guts),list2,store_param));

$state(list_qualifier,
	((qualifier_guts),list2,store_qual));

!
!	DEFINE TYPE statement
!

$state(type_defn,
	(tpa$_symbol,,store_string,,,PLIT(list_name,1,symbol_bufsiz)));
$state(,
	(tpa$_lambda,,set_state,,,3),
	(tpa$_lambda,,init_list));
$state(type2,
	((comma)));
$state(type_keyword,
	((next)));
$state(,
	('PREFIX',type_prefix),
	('KEYWORD'),
	(tpa$_lambda,main,store_type));
$state(,
	((keyword_guts),type2,store_keyword));

$state(type_prefix,
	((quoted_string),type2,store_string,,,PLIT(symbol_prefix,1,symbol_bufsiz)));

!
!	KEYWORD attribute
!

$state(keyword_guts,
	(tpa$_symbol,,store_string,,,PLIT(name,1,qual_bufsiz)));
$state(keyword2,
	((comma)));
$state(,
	('LABEL',keyword_name),
	('MCROPTDELIM',keyword2,,ent_m_mcroptdlm, qua [ent_l_flags]),
	('SYNTAX',keyword_change),
	('NEGATABLE',keyword2,,ent_m_neg, qua [ent_l_flags]),
	('DEFAULT',keyword2,,ent_m_deftrue, qua [ent_l_flags]),
	('VALUE',keyword_value,,ent_m_val, qua [ent_l_flags]),
	((if_keyword),tpa$_exit));

$state(keyword_name,
	('='));
$state(,
	(tpa$_symbol,keyword2,store_string,,,PLIT(entity_label,1,symbol_bufsiz)));

$state(keyword_change,
	('='));
$state(,
	(tpa$_symbol,keyword2,reference_syntax,,,syntax_entry));

!
!	Keyword value specification
!

$state(keyword_value,
	('(',keyword_value3),
	(tpa$_lambda,keyword2));

$state(keyword_value2,
	((comma)));
$state(keyword_value3,
	(')',keyword2),
	('REQUIRED',keyword_value2,,ent_m_valreq, qua [ent_l_flags]),
	('DEFAULT',keyword_defval),
	('LIST',qual_value2,,ent_m_list, qua [ent_l_flags]),
	('TYPE',keyword_keywords));

$state(keyword_defval,
	('='));
$state(,
	((quoted_string),keyword_value2,store_string,,,PLIT(default_value,1,defval_bufsiz)));

$state(keyword_keywords,
	('='));
$state(,
	(tpa$_symbol,keyword_value2,reference_type,,,qua));

SWITCHES LIST(NOOBJECT);
ROUTINE output_binary_code: NOVALUE = ;
SWITCHES LIST(OBJECT);

ROUTINE handler (signal_args, mechanism_args) =

!---
!
!	This condition handler gets control on any signaled
!	condition so that the input line can be echoed before
!	the error message is output.
!
! Inputs:
!
!	signal_args = Address of signal argument list
!	mechanism_args = Address of mechanism argument list
!
! Outputs:
!
!	None
!---

BEGIN

BUILTIN
    CALLG;				! CALLG instruction

EXTERNAL LITERAL
    cledit$_facility:	UNSIGNED(16);	! Facility number for this utility

MAP
    signal_args:	REF BBLOCK,	! Address signal argument vector
    mechanism_args:	REF BBLOCK;	! Address mechanism argument vector

BIND
    status = signal_args [chf$l_sig_name]: BBLOCK; ! Get at status fields

LOCAL
    new_args:	VECTOR [16];		! New argument list

IF .status [sts$v_fac_no] NEQ cledit$_facility ! If not our facility,
THEN
    RETURN ss$_resignal;		! then its not ours, resignal

new_args [0] = 2;			! Set number of arguments
new_args [1] = tparse_block;		! Address of TPARSE block
new_args [2] = .signal_args [chf$l_sig_name];	! Copy primary status code

IF .signal_args [chf$l_sig_args] GTR 4	! If status has FAO arguments,
THEN
    BEGIN
    new_args [0] = .new_args [0] + .signal_args [chf$l_sig_args] - 4;
    CH$MOVE(4*(.new_args [0]-2), .signal_args+12, new_args [3]);
    END;

CALLG(new_args, syntax_error);		! Report error in listing

RETURN ss$_continue;			! Continue following SIGNAL

END;

GLOBAL ROUTINE parse_file =

!---
!
!	This routine performs the parsing on the already open
!	input file of command definitions.
!
! Inputs:
!
!	None
!
! Outputs:
!
!	None
!---

BEGIN

BUILTIN
    FP;

LOCAL
    status;			! Status code

.fp = handler;			! Setup condition handler for parse

num_files = .num_files + 1;	! Increment total files parsed

input_linenum = 0;		! Zero input line number

new_page();			! Page eject on each new file

module_name [0] = 0;		! Preset module name to null string

parse_state = 0;		! Initialize parse state (no longer EOF)

WHILE get_record()		! For each input record,
DO
    BEGIN
    tparse_block [tpa$l_stringcnt] = .input_record [0];
    tparse_block [tpa$l_stringptr] = .input_record [1];

    status = lib$tparse(tparse_block,parse_states,parse_keys);
    IF NOT .status		! If syntax error detected,
    THEN
	BEGIN
	MAP status: BBLOCK;	! Get at fields
	IF NOT .status [sts$v_inhib_msg]	! If not yet signaled
	THEN
	    SIGNAL(emsg(syntax),1,tparse_block [tpa$l_tokencnt]);
	END
    ELSE
	IF NOT .line_output	! If line not yet output,
	THEN
	    echo_record();	! then echo the input record
    END;

delete_symbols(keyword_lists);	! Delete all value type definitions
delete_symbols(syntax_lists);	! Delete all syntax definitions

RETURN true;

END;

ROUTINE get_record =

!---
!
!	This routine gets the next input record and upcases
!	the record if necessary.
!
! Inputs:
!
!	input_rab = Input RAB block
!
! Outputs:
!
!	input_record = Descriptor of input record
!
!	r0 = status (already signaled if error)
!---

BEGIN

OWN
    buffer:	VECTOR [256,BYTE];	! Upcased input record

LOCAL
    status;

status = $GET (RAB = input_rab);	! Get next record

IF NOT .status			! If error detected,
THEN
    BEGIN
    IF .status NEQ rms$_eof	! If unexpected GET error,
    THEN
	rms_error(emsg(readerr),input_fab,input_rab);

    RETURN .status;		! return with status
    END;

input_linenum = .input_linenum + 1;	! Increment input line number
line_output = false;		! Mark line not yet output

IF .input_rab [rab$w_rsz] GEQ 1		! If at least 1 character,
    AND .(.input_rab [rab$l_rbf])<0,8> EQL form_feed ! and if char = FF,
THEN
    BEGIN
    new_page();			! Cause page eject
    input_rab [rab$w_rsz] = .input_rab [rab$w_rsz] - 1;
    input_rab [rab$l_rbf] = .input_rab [rab$l_rbf] + 1;
    END;

INCR i FROM 0 TO .input_rab [rab$w_rsz]-1
DO
    BEGIN
    BIND
	old = .input_rab [rab$l_rbf]: VECTOR[,BYTE];
    buffer [.i] = .old [.i];
    SELECTONEU .old [.i] OF
	SET
	['a' TO 'z']: buffer [.i] = .buffer [.i] + ('A'-'a');

	['<','"']:
		BEGIN
		LOCAL p,len;
		p = CH$FIND_CH(.input_rab [rab$w_rsz]-1-.i, old [.i+1],
			(IF .old [.i] EQL '<' THEN '>' ELSE '"'));
		IF .p NEQ 0			! If terminator found,
		THEN
		    BEGIN
		    len = .p - old [.i];	! length to skip over
		    CH$MOVE(.len, old [.i+1], buffer [.i+1]);
		    i = .i + .len;		! then skip to terminator+1
		    END;
		END;
	TES;
    END;

input_record [0] = .input_rab [rab$w_rsz];
input_record [1] = buffer;

RETURN true;

END;

ROUTINE get_cont_line =

!---
!
!	This routine is called as an action routine if
!	a dash (-) is the last token on the line before
!	a comment or end of line.  The next record is
!	retrieved and the tparse block is updated so that
!	parsing continues with the continuation line.
!
! Inputs:
!
!	ap = tparse block
!
! Outputs:
!
!	tparse block is updated
!---

BEGIN

BUILTIN
    AP;				! Address of tparse block

MAP
    AP:		REF BBLOCK;	! Address as structure

LOCAL
    count,			! Count of characters passed over
    status;			! status code

IF NOT .line_output		! If line not yet output,
THEN
    echo_record();		! then echo the input record

status = get_record();		! Get next record from input stream
IF NOT .status			! If error detected,
THEN
    RETURN .status;		! return and reject transition

ap [tpa$l_stringcnt] = .input_record [0];
ap [tpa$l_stringptr] = .input_record [1];

RETURN true;

END;

ROUTINE init_verb =

!---
!
!	This routine initializes all verb information in
!	preparation for parsing a new verb definition.
!
! Inputs:
!
!	verb_name = Descriptor of verb name
!
! Outputs:
!
!	None
!---

BEGIN

add_record(verb_listhead, .verb_name [1], .verb_name [0]); ! Add to verb list

!CH$COPY(6,UPLIT('CLI$K_'),		! Append 'CLI$K_' to
!	MIN(4,.verb_name [0]), .verb_name [1],	! to verb name to
!	1,UPLIT('_'),			! to underscore
!	0,symbol_bufsiz,.symbol_prefix [1]); ! and set default symbol prefix
!symbol_prefix [0] = 7 + MIN(4,.verb_name [0]);	! Set length of default prefix

symbol_prefix [0] = 0;			! Preset null - must explicitly ask
					! for symbols via PREFIX construct

CH$FILL(0,cmd_bufsiz,cmd);		! Zero CMD buffer
CH$FILL(0,parm_bufsiz,pro);		! Zero PRO buffer
CH$FILL(0,qua_bufsiz,qua);		! Zero QUA buffer

image_name [0] = 0;			! Set image name to null
routine_name [0] = 0;			! Set routine name to null
INCRU i FROM 0 to max_outputs DO output_list [.i] = 0; ! Zero output list
exclude_size = 0;			! Initialize exclusion list size
exclude_list [0] = 0;			! and terminate list
qual_number = 0;			! Initialize qualifier number
syntax_entry = 0;			! Reset change list entry address

RETURN true;

END;

ROUTINE store_synonym =

!---
!
!	Store a verb synonym in the synonym list.  When the command
!	is stored, the primary verb and all the synonyms will point
!	to the same command descriptor block.
!
! Inputs:
!
!	tpa$l_tokencnt = Descriptor of verb synonym name
!
! Outputs:
!
!	None
!---

BEGIN

ap_setup;

add_record(verb_listhead, .ap [tpa$l_tokenptr], .ap [tpa$l_tokencnt]);

RETURN true;

END;

ROUTINE init_list =

!---
!
!	This routine initializes all information in
!	preparation for parsing a new change list definition.
!
! Inputs:
!
!	list_name = Descriptor of change list name
!
! Outputs:
!
!	None
!---

BEGIN

!CH$COPY(6,UPLIT('CLI$K_'),		! Append 'CLI$K_' to
!	MIN(4,.list_name [0]), .list_name [1],	! to list name to
!	1,UPLIT('_'),			! to underscore
!	0,symbol_bufsiz,.symbol_prefix [1]); ! and set default symbol prefix
!symbol_prefix [0] = 7 + MIN(4,.list_name [0]);	! Set length of default prefix

symbol_prefix [0] = 0;			! Preset null - must explicitly ask
					! for symbols via PREFIX construct

CH$FILL(0,cmd_bufsiz,cmd);		! Zero CMD buffer
CH$FILL(0,parm_bufsiz,pro);		! Zero PRO buffer
CH$FILL(0,qua_bufsiz,qua);		! Zero QUA buffer
CH$FILL(0,chg_bufsiz,chg);		! Zero CHG buffer

image_name [0] = 0;			! Set image name to null
routine_name [0] = 0;			! Set routine name to null
qual_number = 0;			! Initialize qualifier number
syntax_entry = 0;			! Reset change list entry address

RETURN true;

END;

ROUTINE store_output =

!---
!
!	This routine stores a given output specification
!	in the output_list array.
!
! Inputs:
!
!	ap = Address of tparse block
!	tpa$l_tokencnt(ap) = Descriptor of input name
!
! Outputs:
!
!	output_list array is updated.
!---

BEGIN

ap_setup;

LOCAL
    qua:	REF BBLOCK;		! Address qualifier descriptor block

INCR i FROM 0 TO max_outputs-1
DO
    IF .output_list [.i] EQL 0		! If unused slot found,
    THEN
	BEGIN
	output_list [.i] = convert_io_name(ap [tpa$l_tokencnt]); ! Store I/O #
	IF .output_list [.i] LEQU max_qual_num ! If a qualifier number,
	    AND find_record(qua_listhead, .output_list [.i], qua) ! and in list
	THEN
	    qua [ent_v_file] = true;	! Indicate qual. takes filespec value
	RETURN true;
	END;

SIGNAL(emsg(toomnyout));		! Else, too many outputs

RETURN true;

END;

ROUTINE store_group_entry =

!---
!
!	This routine adds an entity the current group being
!	defined.
!
! Inputs:
!
!	tpa$l_stringcnt = Descriptor of entity name
!
! Outputs:
!
!	The entity is added to the current group list.
!---

BEGIN

ap_setup;

BIND
    group = exclude_list [.exclude_size]: VECTOR [,BYTE],
    group_size = group [0]: BYTE;

IF .group [0] GEQU max_excludes - .exclude_size ! If beyond capacity,
THEN
    BEGIN
    SIGNAL(emsg(grptoobig));		! Else, too many in group
    RETURN true;
    END;

group_size = .group_size + 1;		! Increment count of entities in list
group [.group_size] = convert_io_name(ap [tpa$l_tokencnt]);

RETURN true;

END;

ROUTINE store_group =

!---
!
!	This routine is called as an action routine to store
!	the current list of entities for the group being defined
!	and add it the list of mutual exclusion groups for this verb.
!
! Inputs:
!
!	exclude_list = counted list of entity numbers in bytes
!
! Outputs:
!
!	exclude_size is updated to include the current group.
!---

BEGIN

exclude_size = .exclude_size + .exclude_list [.exclude_size] + 1;
exclude_list [.exclude_size] = 0;	! Terminate exclude list in case
					! there are no more groups

RETURN true;

END;

ROUTINE convert_io_name (desc) =

!---
!
!	Parse a parameter (P1-8) or qualifier name into
!	the corresponding number to be placed into the
!	qualifier descriptor block.
!
! Inputs:
!
!	desc = Address of string descriptor
!
! Outputs:
!
!	routine value = value corresponding to I/O name
!---

BEGIN

MAP
    desc:	REF VECTOR;		! Address descriptor

BIND
    name = .desc [1]: VECTOR [,BYTE];	! Address string as character array

LOCAL
    status,
    value;				! Symbol value

IF .desc [0] EQL 2			! If exactly 2 characters
    AND .name [0] EQL 'P'		! and first character is 'P'
    AND .name [1] GEQ '1'		! and second is numeric
    AND .name [1] LEQ '9'
THEN
    RETURN 256-(.name [1]-'0');		! return with negated parameter #

!
!	Lookup qualifier name
!

status = lookup_symbol(modifiers, .desc, value); ! Lookup value of symbol name

IF .status				! If found
THEN
    RETURN .value;			! then return with qualifier #

SIGNAL(emsg(badioname), 1, .desc);	! Signal error
RETURN 0;				! return 0 as not valid keyword

END;

ROUTINE store_param =

!---
!
!	Process a PARAMETER specification by storing the
!	associated prompt descriptor block and prompt string
!	in the PRO list.  Also, update the min/max parameter
!	counts.
!
! Inputs:
!
!	name = Descriptor of parameter name (P1-8)
!	pro = prompt descriptor block containing flags
!	prompt_name = Descriptor of prompt string
!
! Outputs:
!
!	Entry added to PRO list
!---

BEGIN

BIND
    char = .name [1]: VECTOR [,BYTE];	! Address name as character array

LOCAL
    length;				! Length of parameter descriptor block

IF NOT (.name [0] EQL 2			! If not exactly 2 characters
    AND .char [0] EQL 'P'		! composed of a 'P'
    AND .char [1] GEQ '1'		! followed by a numeric
    AND .char [1] LEQ '9')
THEN
    BEGIN
    SIGNAL(emsg(badpname));
    RETURN true;
    END;

pro [ent_w_number] = .char [1]-'0';	! Store parameter number

! implicit for duplicated parameters
!
add_symbol(params, name, .char [1]-'0'); ! Insert name in parameter table

pro [ent_v_concat] = true;		! Always allow value concatenation

IF .pro [ent_v_impcat]			! If IMPCAT,
THEN
    pro [ent_v_list] = true;		! assume LIST also

IF .entity_label [0] EQL 0		! If no label provided,
THEN
    copy_string(name, entity_label);	! then use label Pn

IF .prompt_name [0] EQL 0		! If prompt string not specified,
THEN
    copy_string(entity_label, prompt_name); ! then use the label name

length = ent_c_length;			! Assume no extensions

pro [ent_w_label] = .length;		! Set offset to label string
(pro+.length)<0,8> = .entity_label [0];	! Copy ASCIC label string
CH$MOVE(.entity_label [0], .entity_label [1], pro+.length+1);
length = .length + .entity_label [0] + 1;

IF .prompt_name [0] NEQ 0		! If prompt string specified,
THEN
    BEGIN
    pro [ent_w_prompt] = .length;	! Prompt string follows block
    (pro+.length)<0,8> = .prompt_name [0];	! Copy prompt string size
    CH$MOVE(.prompt_name [0], .prompt_name [1], pro+.length+1);
    length = .length + .prompt_name [0] + 1;
    END;

IF .default_value [0] NEQ 0		! If default value given,
THEN
    BEGIN
    pro [ent_w_defval] = .length;	! then set offset to default value
    pro [.length,0,8,0] = .default_value [0]; ! Set length of default string
    CH$MOVE(.default_value [0], .default_value [1], pro + .length + 1);
    length = .length + .default_value [0] + 1;
    END;

IF .syntax_entry NEQ 0			! If change list given,
THEN
    pro [ent_w_syntax] = .syntax_entry;	! then store table offset to chg
					! (to be relocated later by add_command)

IF .type_entry NEQ 0			! If type given,
THEN
    pro [ent_w_keywords] = .type_entry; ! then store table offset to list
					! (to be relocated later by add_command)

pro [ent_b_size] = .length;		! Set length of block

add_record(parm_listhead, pro, .length); ! Add to end of prompt list

cmd [cmd_v_maxparm] = .cmd [cmd_v_maxparm] + 1;		! Update max params

IF .pro [ent_v_valreq]			! If required parameter,
THEN
    cmd [cmd_v_minparm] = .cmd [cmd_v_minparm] + 1;	! Update min params

IF .entity_label [0] EQL 0		! If no label provided,
THEN
    copy_string(name,entity_label);	! then use the parameter name

default_value [0] = 0;			! Init default value descriptor
entity_label [0] = 0;			! Set symbol name to null
prompt_name [0] = 0;			! Set prompt name to null
CH$FILL(0,parm_bufsiz,pro);		! Zero PRO buffer
syntax_entry = 0;
type_entry = 0;

RETURN true;

END;

ROUTINE store_qual =

!---
!
!	Process a QUALIFIER specification by storing the
!	associated qualifier descriptor block and qualifer name
!	in the QUA list.  Add symbol to symbol name to reflect
!	number assigned to the qualifier.
!
! Inputs:
!
!	name = Descriptor of qualifier name
!	qua = qualifier descriptor block
!
! Outputs:
!
!	Entry added to QUA list
!---

BEGIN

LOCAL
    status,
    length;				! Length of entire QUA block

!
!	Apply implications and defaults and check restrictions
!

IF .qua [ent_v_file] OR .qua [ent_v_list] OR .qua [ent_v_valreq]
THEN
    qua [ent_v_val] = true;		! Assume VAL if FILE,LIST,VALREQ

qua [ent_v_neg] = NOT .qua [ent_v_neg];	! set if NONNEG present, else false
					! (neg used to indicate NONNEG present)

IF .qua [ent_v_deftrue] AND .qua [ent_v_batdef] ! If both DEFTRUE and BATDEF
    OR .qua [ent_v_valreq] AND .default_value [0] NEQ 0 ! or if both VALREQ
					! and default value specified
THEN
    BEGIN
    default_value [0] = 0;		! then reset default value string
    semantic_error(emsg(confattr));	! signal conflicting attributes
    RETURN true;
    END;

IF NOT .qua [ent_v_parm]		! If PLACEMENT not explicitly specified,
THEN
    qua [ent_v_verb] = true;		! then assume PLACEMENT=GLOBAL (comdqual)

!
!	Make extensions to qualifier descriptor block for
!	optional change list, default value, and qualifier name
!

qual_number = .qual_number + 1;		! Increment qualifier number

length = ent_c_length;			! Assume length with no extensions

IF .default_value [0] NEQ 0		! If default value given,
THEN
    BEGIN
    qua [ent_w_defval] = .length;	! then set offset to default value
					! else leave it zero
    qua [.length,0,8,0] = .default_value [0]; ! Set length of default string
    CH$MOVE(.default_value [0], .default_value [1], qua + .length + 1);
    length = .length + .default_value [0] + 1;
    END;

qua [ent_w_name] = .length;		! Set offset to qualifier name
qua [.length,0,8,0] = .name [0];	! Set count of string
CH$MOVE(.name [0], .name [1], qua + .length + 1); ! Move qualifier name in
length = .length + 1 + .name [0];	! Update length of qualifier block

IF .entity_label [0] NEQ 0		! If label provided,
THEN
    BEGIN
    qua [ent_w_label] = .length;	! Set offset to label
    qua [.length,0,8,0] = .entity_label [0];	! Set string length
    CH$MOVE(.entity_label [0], .entity_label [1], qua + .length + 1);
    length = .length + 1 + .entity_label [0];	! Update block length
    END;

IF .syntax_entry NEQ 0			! If change list given,
THEN
    qua [ent_w_syntax] = .syntax_entry;	! then store table offset to chg
					! (to be relocated later by add_command)

IF .type_entry NEQ 0			! If type given,
THEN
    qua [ent_w_keywords] = .type_entry; ! then store table offset to chg
					! (to be relocated later by add_command)

qua [ent_b_size] = .length;		! Set length of qualifier block

!
!	Add qualifier descriptor block to qualifier list
!

add_record(qua_listhead,qua,.length);	! Add to end of qualifier list

!
!	Add qualifier to qualifier symbol table
!

IF .entity_label [0] EQL 0		! If no label provided,
THEN
    copy_string(name, entity_label);	! then use the qualifier name

add_symbol(modifiers, entity_label, .qual_number); ! Add to symbol table

!
!	Re-initialize parse cells
!

entity_label [0] = 0;			! Set symbol name to null
default_value [0] = 0;			! Init qualifier default descriptor
CH$FILL(0,qua_bufsiz,qua);		! Zero QUA buffer
syntax_entry = 0;
type_entry = 0;

RETURN true;

END;

ROUTINE store_verb =

!---
!
!	Create the verb in the command language data base
!	using the specifications stored away for this verb.
!
! Inputs:
!
!	cmd = Command descriptor block
!	parm_listhead = Listhead of prompt descriptor blocks
!	qua_listhead = Listhead of qualifier descriptor blocks
!	output_list = List of output specifications
!	verb_name = Descriptor of verb name
!	image_name = Default image name
!
! Outputs:
!
!	None
!---

BEGIN

LOCAL
    name_desc:	VECTOR [2],		! Descriptor returned by lookup_value
    length,				! Length of CMD block
    user_routine,			! True if user routine name given
    offset,				! Offset to stored CMD in tables
    status;

user_routine = false;			! Mark no user routine detected

delete_symbols(params);			! Delete parameter duplication check symbols

!
!	Check for conflicting attributes
!

IF .image_name [0] NEQ 0		! If image name specified,
    AND .routine_name [0] NEQ 0		! and routine name specified,
THEN
    BEGIN
    semantic_error(emsg(confattr));	! then signal conflicting attributes
    RETURN true;
    END;

!
!	If image or routine name not specified, use verb name
!
IF .image_name [0] EQL 0 AND .routine_name [0] EQL 0
THEN
    BEGIN
    image_name [0] = .verb_name [0];	! then use the verb as image name
    CH$MOVE(.image_name [0], .verb_name [1], .image_name [1]);
    END;

!
!	Delete all outputs from modifiers list, then
!	add all remaining modifier symbols to the global symbol table
!

INCR i FROM 0 TO max_outputs-1		! For each output defined,
DO
    BEGIN
    IF .output_list [.i] EQL 0		! If end of list,
    THEN
	EXITLOOP			! then get out
    ELSE IF .output_list [.i] LSSU max_qual_num
	AND lookup_value(modifiers, .output_list [.i], name_desc) ! Find the name
    THEN
	delete_symbol(modifiers, name_desc);	! Remove from modifiers, if there
    END;

scan_symbols(modifiers, add_modsym);	! Make all modifier symbols globals

delete_symbols(modifiers);		! Now delete all modifier symbols

sort_prolist ();			! Sort parameter list by parameter number

!
!	Reorganize quals and parms for MCR
!

IF .cmd [cmd_v_mcrparse]
    AND .clitype EQL vec_c_mcr
THEN
    mcr_sort ();

!
!	Complete the rest of the command descriptor block
!

length = cmd_c_length;			! Assume no extensions

IF .output_list [0] NEQ 0		! If any outputs at all
THEN
    BEGIN
    cmd [cmd_w_outputs] = .length;	! Set offset to output list
    INCRU i FROM 0 TO max_outputs	! For each output,
    DO
	BEGIN
	IF .output_list [.i] EQL 0	! If end of table,
	THEN
	    EXITLOOP;			! then done with output copy
	cmd [.length,0,8,0] = .cmd [.length,0,8,0] + 1;	! Increment # outputs
	cmd [.length+1+.i,0,8,0] = .output_list [.i];	! move output spec into cmd
	END;
    length = .length + 1 + .cmd [.length,0,8,0]; ! Update block length
    END;

IF .image_name [0] NEQ 0		! If image name specified,
THEN
    BEGIN
    cmd [cmd_w_image] = .length;	! Set offset to ASCIC image name
    CH$MOVE(1,image_name [0], cmd+.length); ! Copy size of counted string
    CH$MOVE(.image_name [0], .image_name [1], cmd+.length+1); ! and name itself
    length = .length + 1 + .image_name [0]; ! Account for length of image name
    END
ELSE IF .routine_name [0] NEQ 0		! Else if routine name specified,
THEN
    IF NOT .foreign_command		! If not invoked via foreign command,
	AND cli$present($DESCRIPTOR('OBJECT')) ! If /OBJECT present
    THEN
	BEGIN
	user_routine = true;		! Mark routine offset must be stored
	cmd [cmd_w_image] = .length;	! Point to longword offset to routine
	length = .length + 4;		! Account for longword
	END
    ELSE
	BEGIN
	status = lookup_routine(routine_name); ! Lookup internal routine name
	IF .status NEQ 0			! If found,
	THEN
	    cmd [cmd_w_image] = - .status	! then set as negative internal index
	ELSE
	    BEGIN
	    SIGNAL(emsg(nosuchrtn),1,routine_name);	! signal unknown routine
	    RETURN true;
	    END;
	END;

cmd [cmd_b_size] = .length;		! Set length into block

cmd [cmd_b_verbtyp] = lookup_verb_type(verb_name); ! Set verb type into block

IF NOT add_command(verb_listhead,cmd,qua_listhead,parm_listhead,offset)
THEN
    RETURN true;			! If error, exit

IF .user_routine			! If we must store external reference
THEN
    BEGIN

    LOCAL
	last,
	buf : VECTOR [4+1+symbol_bufsiz, BYTE];

    buf = .offset+.cmd [cmd_w_image];
    buf+4 = .routine_name [0];
    last = CH$MOVE (.routine_name [0], .routine_name [1], buf+5);
    add_record (rtn_listhead, buf, .last-buf);

    END;

delete_list(verb_listhead);		! Deallocate verb list
delete_list(qua_listhead);		! Deallocate qualifier list
delete_list(parm_listhead);		! Deallocate prompt list

RETURN true;

END;

ROUTINE sort_prolist : NOVALUE =

!---
!
!	Sort parameters by number
!
! Inputs:
!
!	None
!
! Outputs:
!
!	None
!---

BEGIN

LOCAL
    ent : REF BBLOCK,			! Address of entity descriptor block
    tmp_listhead : INITIAL (0),		! temporary list header
    pro_map :				! mark output parameters
	VECTOR [cmd_c_maxparms+1, BYTE];

INCR i FROM 0 to cmd_c_maxparms
DO
    pro_map [.i] = 0;			! initialize parameter map

! copy outputs from qualifiers list and parameters list to tmp list
!
INCR i FROM 1 TO .cmd [cmd_v_maxparm]
DO
    BEGIN
    IF find_record (parm_listhead, .i, ent)
    THEN
	pro_map [.ent [ent_w_number]] = .i;
    END;
INCR i FROM 1 TO .cmd [cmd_v_maxparm]
DO
    BEGIN
    IF .pro_map [.i] NEQ 0
    THEN
	BEGIN
	find_record (parm_listhead, .pro_map [.i], ent);
	add_record (tmp_listhead, .ent, .ent [ent_b_size]);
	END
    ELSE
	SIGNAL(emsg(missngparm), 1, .i);
    END;

! delete parameter list and make tmp list the parameter list
!
delete_list (parm_listhead);
parm_listhead = .tmp_listhead;

RETURN;

END;
 
ROUTINE mcr_sort : NOVALUE =

!---
!
!	Reorganize tables for MCR style commands
!		Remove outputs from qualifiers list
!		Reorganize parameters list to contains outputs in order and
!		then inputs in order
!
! Inputs:
!
!	None
!
! Outputs:
!
!	None
!---

BEGIN

LOCAL
    ent : REF BBLOCK,			! Address of entity descriptor block
    tmp_listhead : INITIAL (0),		! temporary list header
    pro_delete :			! mark output parameters
	BITVECTOR [cmd_c_maxparms];

INCR i FROM 0 to cmd_c_maxparms-1
DO
    pro_delete [.i] = false;

! copy outputs from qualifiers list and parameters list to tmp list
!
INCR i FROM 0 TO max_outputs-1
DO
    BEGIN

    IF .output_list [.i] EQL 0
    THEN
	EXITLOOP
    ELSE IF .output_list [.i] GEQU max_qual_num
    THEN
	 BEGIN

	! parameter - add to tmp list and mark for deletion
	!
	find_record (parm_listhead, 256-.output_list [.i], ent);
	pro_delete [256-.output_list [.i]-1] = true;
	add_record (tmp_listhead, .ent, .ent [ent_b_size]);

	END
    ELSE IF find_record (qua_listhead, .output_list [.i], ent)
    THEN
	BEGIN

	! qualifier - add to tmp list and zero original name
	!
	ent [ent_v_valreq] = false;		! adjust for differet meaning
	add_record (tmp_listhead, .ent, .ent [ent_b_size]);
	ent [ent_w_name] = 0;
	cmd [cmd_v_maxparm] = .cmd [cmd_v_maxparm] + 1;	! count as parameter

	END;

    END;

! copy remaining records from parameter list to tmp list
!
INCR i FROM 1 TO cmd_c_maxparms
DO
    BEGIN
    IF NOT .pro_delete [.i-1]
	AND find_record (parm_listhead, .i, ent)
    THEN
	add_record (tmp_listhead, .ent, .ent [ent_b_size]);
    END;

! delete parameter list and make tmp list the parameter list
!
delete_list (parm_listhead);
parm_listhead = .tmp_listhead;

RETURN;

END;

ROUTINE add_modsym (desc, value) =

!---
!
!	This routine is called as an action routine by scan_symbols
!	in order to add a modifier symbol to the global symbol table.
!
! Inputs:
!
!	desc = Address of symbol name descriptor
!	value = Value associated with symbol
!
! Outputs:
!
!	None
!---

BEGIN

MAP
    desc:	REF VECTOR;		! Address as quadword

LOCAL
    buffer:	VECTOR [symbol_bufsiz,BYTE],	! Buffer for symbol name
    bufdesc:	VECTOR [2];		! Descriptor for above buffer

CH$COPY(.symbol_prefix [0], .symbol_prefix [1],	! Append prefix to name
	MIN(4, .desc [0]), .desc [1],
	0, symbol_bufsiz, buffer);

bufdesc [0] = .symbol_prefix [0] + MIN(4, .desc [0]);
bufdesc [1] = buffer;

IF NOT .foreign_command			! If not invoked via foreign command,
    AND CLI$PRESENT($DESCRIPTOR('SYMBOLS'))	! If symbol table desired,
    AND .symbol_prefix [0] NEQ 0	! and symbol prefix non-null,
    AND .value LEQU max_qual_num	! and not a parameter (old interface
					! never refs params except by i/o #)
THEN
    BEGIN
    LOCAL cur_value;
    IF NOT (lookup_symbol(globals, bufdesc, cur_value) ! If already in symbol table,
	AND .cur_value EQL .value)	! and has the same value, allow dups
    THEN
	add_symbol(globals, bufdesc, .value); ! Add symbol to global symbol table
    END;

RETURN true;

END;

ROUTINE store_syntax =

!---
!
!	This routine stores a change list definition so
!	that it may be retrieved later in a parameter or
!	qualifier definition.
!
! Inputs:
!
!	list_name = Descriptor of change list name
!
! Outputs:
!
!	None
!
!---

BEGIN

LOCAL
    offset,				! Table offset to subqual list
    user_routine,			! True if user routine name given
    length;				! Length of block

user_routine = false;			! Assume no user routine given

delete_symbols(params);			! Delete parameter duplication check symbols

!
!	Check for conflicting attributes
!

IF .image_name [0] NEQ 0		! If image name specified,
    AND .routine_name [0] NEQ 0		! and routine name specified,
THEN
    BEGIN
    semantic_error(emsg(confattr));	! then signal conflicting attributes
    RETURN true;
    END;

IF NOT .chg [chg_v_quals]		! If no qualifier change
    AND NOT .chg [chg_v_parms]		! and no parameter change
    AND NOT .chg [chg_v_image]		! and no image or routine change
THEN
    BEGIN
    semantic_error(emsg(emptydef));	! then signal empty definition
    RETURN true;			! and exit
    END;

sort_prolist ();			! sort parameter list by number

chg [chg_b_parmcnt] = .cmd [cmd_b_parmcnt];	! Copy min/max param counts

length = chg_c_length;

IF .chg [chg_v_image]			! If image or routine name change,
THEN
    BEGIN
    IF .image_name [0] NEQ 0		! If image name specified,
    THEN
	BEGIN
	chg [chg_w_image] = .length;	! Set offset to ASCIC image name
	chg [.length,0,8,0] = .image_name [0];	! Copy size of counted string
	CH$MOVE(.image_name [0], .image_name [1], chg+.length+1); ! and name itself
	length = .length + 1 + .image_name [0]; ! Account for length of image name
	END
    ELSE IF .routine_name [0] NEQ 0		! Else if routine name specified,
    THEN
	IF NOT .foreign_command		! If not invoked via foreign command,
	    AND cli$present($DESCRIPTOR('OBJECT')) ! If /OBJECT present
	THEN
	    BEGIN
	    user_routine = true;		! Mark routine offset must be stored
	    chg [chg_w_image] = .length;	! Point to longword offset to routine
	    length = .length + 4;		! Account for longword
	    END
	ELSE
	    BEGIN
	    offset = lookup_routine(routine_name); ! Lookup internal routine name
	    IF .offset NEQ 0			! If found,
	    THEN
		chg [chg_w_image] = - .offset	! then set as negative internal index
	    ELSE IF NOT .chg [chg_v_mcrignore]
		OR .clitype NEQ vec_c_mcr
	    THEN
		BEGIN
		SIGNAL(emsg(nosuchrtn),1,routine_name);	! signal unknown routine
		RETURN true;
		END;
	    END;
    END;

chg [chg_b_size] = .length;		! Set length into block

IF NOT add_change(chg, qua_listhead, parm_listhead, offset)
THEN
    RETURN true;			! If error, exit

IF NOT add_symbol(syntax_lists, list_name, .offset) ! Add list name/address to symbol table
THEN
    RETURN true;			! If error, exit

IF .user_routine			! If we must store external reference
THEN
    BEGIN

    LOCAL
	last,
	buf : VECTOR [4+1+symbol_bufsiz, BYTE];

    buf = .offset+.chg [chg_w_image];
    buf+4 = .routine_name [0];
    last = CH$MOVE (.routine_name [0], .routine_name [1], buf+5);
    add_record (rtn_listhead, buf, .last-buf);

    END;

delete_list(qua_listhead);		! Deallocate qualifier list
delete_list(parm_listhead);		! Deallocate parameter list

scan_symbols(modifiers, add_modsym);	! Make all modifier symbols globals

delete_symbols(modifiers);		! Now delete all modifier symbols

RETURN true;

END;

ROUTINE store_keyword =

!---
!
!	Process a KEYWORD specification by storing the information
!	in a qualifier descriptor block and adding the entry to
!	the KEY list.  The list will subsequently be picked up and
!	used when the list is stored.
!
! Inputs:
!
!	name = Descriptor of qualifier name
!	qua = qualifier descriptor block
!
! Outputs:
!
!	Entry added to KEY list
!---

BEGIN

LOCAL
    status,
    length;				! Length of entire QUA block

!
!	Apply implications and defaults and check restrictions
!

IF .qua [ent_v_file] OR NOT .qua [ent_v_list] OR .qua [ent_v_valreq]
THEN
    qua [ent_v_val] = true;		! Assume VAL if FILE,LIST,VALREQ

IF .qua [ent_v_deftrue] AND .qua [ent_v_batdef] ! If both DEFTRUE and BATDEF
    OR .qua [ent_v_valreq] AND .default_value [0] NEQ 0 ! or if both VALREQ
					! and default value specified
THEN
    BEGIN
    semantic_error(emsg(confattr));	! then conflicting attributes
    RETURN true;
    END;

!
! Set the PARM bit solely because keyword lists may be processed as
! qualifier lists by CLI to handle SET/SHOW options.  This may be
! removed when this is no longer the case.
!

qua [ent_v_parm] = true;		! Make PLACEMENT=LOCAL (to option parm)

!
!	Make extensions to qualifier descriptor block for
!	optional change list, default value, and keyword name
!

length = ent_c_length;			! Assume length with no extensions

IF .default_value [0] NEQ 0		! If default value given,
THEN
    BEGIN
    qua [ent_w_defval] = .length;	! then set offset to default value
					! else leave it zero
    qua [.length,0,8,0] = .default_value [0]; ! Set length of default string
    CH$MOVE(.default_value [0], .default_value [1], qua + .length + 1);
    length = .length + .default_value [0] + 1;
    END;

qua [ent_w_name] = .length;		! Set offset to qualifier name
qua [.length,0,8,0] = .name [0];	! Set count of string
CH$MOVE(.name [0], .name [1], qua + .length + 1); ! Move qualifier name in
length = .length + 1 + .name [0];	! Update length of qualifier block

IF .entity_label [0] NEQ 0		! If label provided,
THEN
    BEGIN
    qua [ent_w_label] = .length;	! Set offset to label
    qua [.length,0,8,0] = .entity_label [0];	! Set string length
    CH$MOVE(.entity_label [0], .entity_label [1], qua + .length + 1);
    length = .length + 1 + .entity_label [0];	! Update block length
    END;

IF .syntax_entry NEQ 0			! If change list given,
THEN
    qua [ent_w_syntax] = .syntax_entry;	! then store table offset to chg
					! (to be relocated later by add_command)

IF .type_entry NEQ 0			! If type given,
THEN
    qua [ent_w_keywords] = .type_entry; ! then store table offset to chg
					! (to be relocated later by add_command)

qua [ent_b_size] = .length;		! Set length of qualifier block

!
!	Add qualifier descriptor block to keyword list
!

add_record(key_listhead,qua,.length);	! Add to end of keyword list

!
!	Add keyword number to symbol table for old interface global symbols
!

IF .entity_label [0] EQL 0		! If no label provided,
THEN
    copy_string(name, entity_label);	! then use the qualifier name

qual_number = .qual_number + 1;		! Increment keyword number
add_symbol(modifiers, entity_label, .qual_number); ! Add to symbol table

!
!	Re-initialize parse cells
!

entity_label [0] = 0;			! Set symbol name to null
default_value [0] = 0;			! Init qualifier default descriptor
CH$FILL(0,qua_bufsiz,qua);		! Zero QUA buffer
syntax_entry = 0;
type_entry = 0;

RETURN true;

END;

ROUTINE store_type =

!---
!
!	This routine stores a keyword list definition so
!	that it may be retrieved later in a parameter or
!	qualifier definition.
!
! Inputs:
!
!	list_name = Descriptor of keyword list name
!
! Outputs:
!
!	None
!
!---

BEGIN

LOCAL
    offset;				! Table offset to subqual list

IF .key_listhead EQL 0			! If no keywords,
THEN
    BEGIN
    semantic_error(emsg(emptydef));	! then issue error message
    RETURN true;			! and exit
    END;

add_entity_list(key_listhead, offset);	! Add the qualifier blocks
delete_list(key_listhead);		! Deallocate keyword list

add_symbol(keyword_lists, list_name, .offset);	! Add keyword list name

scan_symbols(modifiers, add_modsym);	! Make all modifier symbols globals

delete_symbols(modifiers);		! Now delete all modifier symbols

RETURN true;				! exit

END;

ROUTINE reference_syntax =

!---
!
!	Process a SYNTAX keyword for a value.  Lookup
!	the list name in the symbol table and store the value
!	in the specified location for later.  Only 1 reference
!	to a list is allowed.
!
! Inputs:
!
!	tpa$l_tokencnt = Descriptor of change list name
!	tpa$l_param = Address of longword to receive address
!			of the list.
!
! Outputs:
!
!	.tpa$l_param = Address of list entry
!---

BEGIN

ap_setup;

LOCAL
    status;

IF .(.ap [tpa$l_param]) NEQ 0		! If keyword already given,
THEN
    BEGIN
    SIGNAL(emsg(multchng));		! then return error
    RETURN true;
    END;

status = lookup_symbol(syntax_lists, ap [tpa$l_tokencnt], .ap [tpa$l_param]); ! Lookup name

IF NOT .status				! If list name not found
THEN
    SIGNAL(emsg(listnotfnd));		! then return error

RETURN true;

END;

ROUTINE reference_type =

!---
!
!	Process a TYPE keyword in a value specification.  Lookup
!	the list name in the symbol table and store the value
!	for later.  Only 1 reference to a type is allowed.
!
! Inputs:
!
!	tpa$l_tokencnt = Descriptor of type name
!	tpa$l_param = Address of entity descriptor block being built.
!
! Outputs:
!
!	type_entry = Address of type entry (if user-defined type)
!
!	If system-defined type, the type number is stored in the
!	entity descriptor block pointed to by tpa$l_param.
!---

BEGIN

ap_setup;

LOCAL
    ent:	REF BBLOCK,		! Address of entity descriptor block
    ptr,				! Pointer into predefined type table
    number;				! Predefined type number

IF .type_entry NEQ 0			! If type already specified,
THEN
    BEGIN
    SIGNAL(emsg(multchng));		! then return error
    RETURN true;
    END;

IF lookup_symbol(keyword_lists, ap [tpa$l_tokencnt], type_entry) ! Lookup name
THEN
    RETURN true;			! then return successful

type_entry = 0;				! Else, zero junk left by lookup_symbol

!
! If not a user-defined type, search the list of pre-defined type names
!

ent = .ap [tpa$l_param];		! Get address of entity descriptor

number = 1;				! First name is value 1
ptr = predefined_types;			! Point to beginning of table

WHILE CH$RCHAR(.ptr) NEQ 0		! Until end of table
DO
    BEGIN
    IF CH$EQL(.ap [tpa$l_tokencnt], .ap [tpa$l_tokenptr],
	CH$RCHAR(.ptr), .ptr+1, 0)	! If a match is found,
    THEN
	EXITLOOP;			! then exit the loop
    ptr = CH$RCHAR_A(ptr) + .ptr;	! Skip to next name
    number = .number + 1;		! Increment type number
    END;

IF CH$RCHAR(.ptr) NEQ 0			! If found,
THEN
    BEGIN
    ent [ent_b_valtype] = .number;	! Store predefined type number
    IF .number EQL ent_c_infile		! If filespec
	OR .number EQL ent_c_outfile
	OR .number EQL ent_c_node	! or node
	OR .number EQL ent_c_device	! or device
	OR .number EQL ent_c_dir	! or directory
	OR .number EQL ent_c_uic	! Or UIC,
    THEN
	ent [ent_v_file] = true;	! then set filespec bit as well
    RETURN true;
    END;

SIGNAL(emsg(listnotfnd));		! Return error if not found

RETURN true;

END;

ROUTINE store_number =

!---
!
!	This routine stores the numeric value of a qualifier
!	into a specified location as long as it is within
!	certain limits.  If not, a syntax error is signaled.
!
! Inputs:
!
!	tpa$l_number = Number to be stored
!	tpa$l_param = Address of a 3-longword argument list:
!			1) Address of longword to receive value
!			2) Minimum legal value (unsigned)
!			3) Maximum legal value (unsigned)
!		If 2nd and 3rd arguments are not specified, no
!			checking will be done.
!
! Outputs:
!
!	Either the number is stored or an error is signaled.
!---

BEGIN

ap_setup;

LOCAL
    args:	REF VECTOR,		! Address of argument list
    value;				! Value of expression

args = .ap [tpa$l_param]-4;		! Get address of arguments
					! (PLIT value is addr of FIRST arg)

value = .ap [tpa$l_number];		! Get value
IF .args [0] GEQ 2			! If 2nd, 3rd args specified,
THEN IF .value LSSU .args [2]		! If less than minimum
    OR .value GTRU .args [3]		! or greater than maximum,
THEN
    BEGIN
    SIGNAL(emsg(badvalue));		! then signal illegal value
    RETURN true;
    END;

.args [1] = .value;			! Store value into longword

RETURN true;

END;

ROUTINE store_string =

!---
!
!	This routine stores the string value of a qualifier
!	into a specified location as long as the length is within
!	certain limits.  If not, a syntax error is signaled.
!
! Inputs:
!
!	tpa$l_tokencnt/ptr = String to be stored
!	tpa$l_param = Address of a 3-longword argument list:
!			1) Address of descriptor were the string
!				length is stored in the first longword
!				and the second longword is the place to
!				store the string.
!			2) Minimum legal length (unsigned)
!			3) Maximum legal length (unsigned)
!
! Outputs:
!
!	Either the string is stored or an error is signaled.
!---

BEGIN

ap_setup;

BIND
    char = .ap [tpa$l_tokenptr]: VECTOR [,BYTE]; ! Access as character array

LOCAL
    args:	REF VECTOR,		! Address of argument list
    dest:	REF VECTOR,		! Address of descriptor
    ptr,				! Address of string
    length;				! Length of string

args = .ap [tpa$l_param]-4;		! Get address of arguments
					! (PLIT value is addr of FIRST arg)

length = .ap [tpa$l_tokencnt];		! Get length
ptr = .ap [tpa$l_tokenptr];		! and address of string

IF .char [0] EQL '"'			! If leading double quote
    AND .char [.length-1] EQL '"'	! and trailing double quote
THEN
    BEGIN
    length = .length - 2;		! then strip them
    ptr = .ptr + 1;
    END;

IF .args [0] GEQ 2			! If 2nd, 3rd args specified,
THEN IF .length LSSU .args [2]		! If less than minimum
    OR .length GTRU .args [3]		! or greater than maximum,
THEN
    BEGIN
    IF .length EQL 0			! If nothing specified,
    THEN
	SIGNAL(emsg(missngsym))		! signal missing symbol
    ELSE
	SIGNAL(emsg(symtoolng));	! else signal illegal value
    RETURN true;
    END;

dest = .args [1];			! Get address to store descriptor
dest [0] = .length;			! Store length into descriptor
CH$MOVE(.length, .ptr, .dest [1]);	! and move string into buffer

RETURN true;

END;

ROUTINE store_text =

!---
!
!	This routine stores the string value into a specified buffer
!	as the length is within certain limits.  If not, a syntax
!	error is signaled.  In addition, a specified descriptor is set
!	to the length of the string and the buffer address.
!
! Inputs:
!
!	tpa$l_tokencnt/ptr = String to be stored
!	tpa$l_param = Address of a 4-longword argument list:
!			1) Address of a quadword to receive a descriptor
!				of the string
!			1) Address of buffer to hold the string
!			2) Minimum legal length (unsigned)
!			3) Maximum legal length (unsigned)
!
! Outputs:
!
!	Either the string is stored or an error is signaled.
!---

BEGIN

ap_setup;

BIND
    char = .ap [tpa$l_tokenptr]: VECTOR [,BYTE]; ! Access as character array

LOCAL
    args:	REF VECTOR,		! Address of argument list
    dest:	REF VECTOR,		! Address of descriptor
    ptr,				! Address of string
    length;				! Length of string

args = .ap [tpa$l_param]-4;		! Get address of arguments
					! (PLIT value is addr of FIRST arg)

length = .ap [tpa$l_tokencnt];		! Get length
ptr = .ap [tpa$l_tokenptr];		! and address of string

IF .char [0] EQL '"'			! If leading double quote
    AND .char [.length-1] EQL '"'	! and trailing double quote
THEN
    BEGIN
    length = .length - 2;		! then strip them
    ptr = .ptr + 1;
    END;

IF .args [0] GEQ 3			! If 3rd, 4th args specified,
THEN IF .length LSSU .args [3]		! If less than minimum
    OR .length GTRU .args [4]		! or greater than maximum,
THEN
    BEGIN
    IF .length EQL 0			! If nothing specified,
    THEN
	SIGNAL(emsg(missngsym))		! signal missing symbol
    ELSE
	SIGNAL(emsg(symtoolng));	! else signal illegal value
    RETURN true;
    END;

CH$MOVE(.length, .ptr, .args [2]);	! Move string into buffer

dest = .args [1];			! Get address to store descriptor
dest [0] = .length;			! Store length into descriptor
dest [1] = .args [2];			! Store address of buffer

RETURN true;

END;

ROUTINE copy_string (source, dest): NOVALUE =

!---
!
!	Copy a string buffer to another string buffer assuming
!	each buffer is the same length.
!
! Inputs:
!
!	source = Address of source string descriptor
!	dest = Address of destination string descriptor
!
! Outputs:
!
!	The destination string gets a copy of the source.
!---

BEGIN

MAP
    source:	REF VECTOR,		! Source descriptor
    dest:	REF VECTOR;		! Destination descriptor

dest [0] = .source [0];			! Copy length of string
CH$MOVE(.source [0], .source [1], .dest [1]);	! and string too

END;

END
ELUDOM
