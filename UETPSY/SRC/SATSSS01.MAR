	.TITLE	SATSSS01 - SATS SYSTEM SERVICE TESTS  (SUCC S.C.)
	.IDENT	'V03-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SATS SYSTEM SERVICE TESTS
;
; ABSTRACT:	The SATSSS01 module tests the execution of the following
;		VMS system services:
;
;		$ASSIGN
;		$ALLOC
;		$CANCEL
;		$DASSGN
;		$DALLOC
;		$INPUT
;		$GETCHN
;		$GETDEV
;		$OUTPUT
;		$QIO
;		$QIOW
;
;
; ENVIRONMENT:	User mode image.
;		Needs CMKRNL privilege and dynamically acquires other
;		privileges, as needed.
;
; AUTHOR: Larry D. Jones,		CREATION DATE: JULY, 1979
;
; MODIFIED BY:
;
;	V03-002	RNH0001		Richard N. Holstein,	10-Dec-1981
;		Fix to deal with top level system directory architecture
;		(STP33) and to never turn on directory searching when
;		accessing our test file (STP35).
;
;	V03-001	LDJ0001		Larry D. Jones,		17-Sep-1980
;		Modified to conform to new build command procedures.
;**
;--
.PAGE
	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
	.LIBRARY /SYS$LIBRARY:STARLET.MLB/
	$ATRDEF				; attribute control block definitions
	$CCBDEF				; channel control block definitions
	$DCDEF				; device characteristics definitions
	$DEVDEF				; device definitions
	$DIBDEF				; device information block definitions
	$FIBDEF				; file information block definitions
	$PHDDEF				; process header offset definitions
	$PRVDEF				; privilege definitions
	$PSLDEF				; PSL definitions
	$SHR_MESSAGES UETP,116,<<TEXT,INFO>> ; UETP$_TEXT definition
	$SFDEF				; stack frame definitions
	$STSDEF				; STS definitions
	$UETPDEF			; UETP message definitions
;
; Equated symbols
;
WARNING		= 0			; warning severity value for msgs
SUCCESS		= 1			; success     "      "    "   "
ERROR		= 2			; error       "      "    "   "
INFO		= 3			; information "      "    "   "
SEVERE		= 4			; fatal       "      "    "   "
;
MFD_FILE_ID	= <4@16>+4		; MFD ID
;
; MACROS
;
.PAGE
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
;
TEST_MOD_NAME:
	.ASCIC	/SATSSS01/		; needed for SATSMS message
TEST_MOD_NAME_D:
	.ASCID /SATSSS01/		; module name
TEST_MOD_BEGIN:				; start end and fail messages
	.ASCIC	/begun/
TEST_MOD_SUCC:
	.ASCIC	/successful/
TEST_MOD_FAIL:
	.ASCIC	/failed/
ASSIGN:					; system service names
	.ASCIC	/ASSIGN/
ALLOC:
	.ASCIC	/ALLOC/
CANCEL:
	.ASCIC	/CANCEL/
DASSGN:
	.ASCIC	/DASSGN/
DALLOC:
	.ASCIC	/DALLOC/
INPUT:
	.ASCIC	/INPUT/
GETCHN:
	.ASCIC	/GETCHN/
GETDEV:
	.ASCIC	/GETDEV/
OUTPUT:
	.ASCIC	/OUTPUT/
QIO:
	.ASCIC	/QIO/
QIOW:
	.ASCIC	/QIOW/
DCLCMH:
	.ASCIC	/DCLCMH/
RENAST:
	.ASCID	/QIOTST.DAT;1     /	; returned name string
DISK:
	.ASCID	/SYS$DISK/		; qio device name
CS1:					; failure messages
	.ASCID	\Test !AC service name !AC step !UL failed.\
CS2:
	.ASCID	\Expected !AS = !XL received !AS = !XL\
CS3:
	.ASCID	\Expected !AS!UB = !XL received !AS!UB = !XL\
CS4:
	.ASCID	\Required channel not received.\
CS5:
	.ASCID	\Mode was !AS.\
EXP:
	.ASCID	\status\
IOEXP:
	.ASCID	\IO status\
ASTEXP:
	.ASCID	\AST param.\
DISALL:
	.ASCID	\disk alloc.\
IOCC:
	.ASCID	\# of chan's\
FILNOTMOD:
	.ASCID	\File characteristics not properly modified!\
UM:					; mode messages
	.ASCID	\user\
SM:
	.ASCID	\super\
EM:
	.ASCID	\executive\
KM:
	.ASCID	\kernel\
MBA:					; mailbox name
	.ASCID	\MBA\
EFCNAM:					; common EFC name
	.ASCID	\UETP$EF\
TEST_DATA:				; QIO test data
	A=0
	.REPT 132
	.BYTE A
	A=A+1
	.ENDR
ARGLST:
	.LONG	1			; super mode setup arg list
	.ADDRESS SUPER_MODE
MSGVEC:
	.LONG	3			; PUTMSG message vector
	.LONG	UETP$_TEXT
	.LONG	1
	.ADDRESS MESSAGEL
.PAGE
;
	.SBTTL	R/W PSECT
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
;
TPID:
	.LONG	0			; PID for this process
CURRENT_TC:
	.LONG	0			; ptr to current test case
	.ALIGN LONG			; put it on a long word boundry
REG_SAVE_AREA:
	.BLKL	15			; register save area
MOD_MSG_CODE:
	.LONG	UETP$_SATSMS		; test module message code for putmsg
TMN_ADDR:
	.ADDRESS TEST_MOD_NAME
TMD_ADDR:
	.ADDRESS TEST_MOD_BEGIN
PRVPRT:
	.BYTE	0			; protection return byte for SETPRT
PRIVMASK:
	.QUAD	0			; priv. mask
CHM_CONT:
	.LONG	0			; change mode continue address
RETADR:
	.BLKL	2			; returned address's from SETPRT
STATUS:
	.LONG	0
STAT:
	.BLKL	2			; IO status blk's
STAT1:
	.BLKL	2			
ASGN:
	$ASSIGN	MBNAM,CHAN2,PSL$C_USER,0 ; ASSIGN parameter list
ALLO:
	$ALLOC MBNAM,ML,GETBUF,PSL$C_USER ; ALLOC parameter list
CANC:
	$CANCEL	MBCHAN			; CANCEL parameter list
DASS:
	$DASSGN	0			; DASSGN parameter list
DALL:
	$DALLOC	MBNAM,PSL$C_USER	; DALLOC parameter list
GETC:
	$GETCHN	0,PL,PB,SL,SB		; GETCHN parameter list
GETD:
	$GETDEV	MBNAM,PL,PB,SL,SB	; GETDEV parameter list
QIOP:
	$QIO	31,CHAN1,IO$_READVBLK,STAT1,0,0,GETBUF+8,80,0,0,0,0 ; QIO parameter's
QIOWP:
	$QIOW	31,MBCHAN,IO$_READVBLK,STAT1,0,0,GETBUF+8,80,0,0,0,0 ; QIOW param's
MODE:
	.LONG	0			; current mode string pointer
REG:
	.ASCID	\register R\
REGNUM:
	.LONG	0			; register number
MSGL:
	.LONG	80			; buffer desc.
	.ADDRESS BUF
BUF:
	.BLKB	80
ML:
	.LONG	0			; desc. for BUF_CHECK routine
	.ADDRESS GETBUF+8
GETBUF:
	.LONG	132			; same as above
	.ADDRESS .+4
	.BLKB	132
CTRSTR:
	.LONG	132			; same as above
	.ADDRESS .+4
	.BLKB	132
ARGLST1:				; argument list for BUF_CHECK
	.ADDRESS MBA
	.BLKL	4
MESSAGEL:
	.LONG	0			; message desc.
	.ADDRESS BUF			
SERV_NAME:
	.LONG	0			; service name pointer
PRVHND1:
	.LONG	0			; previous handler address 1
MBNAM:
	.ASCID	/UETP$MB/		; logical name for mailbox
MBCHAN:
	.WORD	0			; mailbox channel number
CHAN1:
	.WORD	0			; utility channel numbers
CHAN2:
	.WORD	0
CHAN_SAVE:
	.WORD	0			; channel count save location
MSGVEC1:				; PUTMSG message vector
	.LONG	3
	.LONG	UETP$_TEXT
	.LONG	1
	.LONG	0
MB_DEV_CHAR:
	.LONG	DEV$M_SHR!DEV$M_REC!DEV$M_AVL!DEV$M_IDV!DEV$M_ODV!DEV$M_MBX ;device char.
	.BYTE	DC$_MAILBOX		; device class
	.BYTE	DT$_MBX			; device type
	.WORD	256			; buffer size
	.LONG	0			; device dependent info.
	.WORD	0,36			; unit # & device name offset
	.LONG	0			; PID
	.LONG	^X10007			; owner UIC
	.LONG	0			; volume protection & error cnt
	.LONG	0			; operation count
	.LONG	0			; volume name offset & record size
	.ASCIC	/MBA/			; device name
	MB_CHAR_SIZE=.-MB_DEV_CHAR
PL:
	.LONG	0
SL:
	.LONG	0
PB:
	.LONG	DIB$K_LENGTH
	.ADDRESS .+4
	.BLKB	DIB$K_LENGTH
SB:
	.LONG	DIB$K_LENGTH
	.ADDRESS .+4
	.BLKB	DIB$K_LENGTH
FIBDES:
	.LONG	FIBSIZE			; file information block desc.
	.ADDRESS FIB
FIB:
	.LONG	0		; ACCTL
	.BLKW	3		; FID
	.LONG	MFD_FILE_ID	; DID
	.BLKB	27			; leave room for add in fields
	FIBSIZE=.-FIB			; set FIB size
ATR:
	.WORD	ATR$S_ASCNAME,ATR$C_ASCNAME ; attributes control block
	.ADDRESS TOPSYS_DIR
	.LONG	0
FILENAME:
	.ASCID	/QIOTST.DAT;1/		; qio test file name
SYSTEST_DIR:
	.ASCID	/SYSTEST.DIR;1/		; SYSTEST directory name
DOT_DIR_SEMI:				; Concatenates with TOPSYS_DIR
	.ASCID	/.DIR;1/
DOT_DIR_SEMI_LENGTH = .-DOT_DIR_SEMI-8	; Length of ASCII string
TOPSYS:					; Logical name of any top level...
	.ASCID	/SYS$TOPSYS/		; ...system directory name
TOPSYS_DIR:				; Receives file name of top level...
	.LONG	9+DOT_DIR_SEMI_LENGTH	; ...system directory...
	.ADDRESS .+4			; ...and gets converted to...
	.BLKB	9+DOT_DIR_SEMI_LENGTH	; ...a file spec for it
.PAGE
	.PSECT	SATSSS01,RD,WRT,EXE,LONG
	.SBTTL	SATSSS01
;++
; FUNCTIONAL DESCRIPTION:
;
;	After performing some initial housekeeping, such as
; printing the module begin message and acquiring needed privileges,
; the system services are tested in each of their normal conditions.
; Detected failures are identified and  an error message is printed
; on the terminal.  Upon completion of the test a success or fail
; message is printed on the terminal.
;
; CALLING SEQUENCE:
;
;	$ RUN SATSSS01  ...  (DCL COMMAND)
;
; INPUT PARAMETERS:
;
;	none
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUT PARAMETERS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Messages to SYS$OUTPUT are the only output from SATSSS01.
;	They are of the form:
;
;		%UETP-S-SATSMS, TEST MODULE SATSSS01 BEGUN ... (BEGIN MSG)
;		%UETP-S-SATSMS, TEST MODULE SATSSS01 SUCCESSFUL ... (END MSG)
;		%UETP-E-SATSMS, TEST MODULE SATSSS01 FAILED ... (END MSG)
;		%UETP-I-TEXT, ... (VARIABLE INFORMATION ABOUT A TEST MODULE FAILURE)
;
; COMPLETION CODES:
;
;	The SATSSS01 routine terminates with a $EXIT to the
;	operating system with a status code defined by UETP$_SATSMS.
;
; SIDE EFFECTS:
;
;	none
;
;--

	TEST_START SATSSS01			; let the test begin
	$CMKRNL_S W^SETUP_SUPER,W^ARGLST ; declare CHMS handler
	ADDL2	S^#EXE$C_CMSTKSZ+16,SP	; adjust the user stack pointer
	MOVL	SP,FP			; fix the frame pointer
	CALLS	#0,W^ERLBUF_DUMP	; dump any errors that occured at kernal mode
	.SBTTL	ASSIGN AND DASSGN TESTS
;+
;
; $ASSIGN and $DASSGN tests
;
; ** NOTE **
;
; Because the only device that is reasonable to use for the ASSIGN/DASSGN
; tests is a mailbox, the MBXNAM parameter is not tested by this program.
; The only devices using this parameter are lineprinters, networks,
; and terminals and none of these things can be guaranteed available.
;
; test user mode
;
;-
	MOVAL	W^ASSIGN,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set mode
	$ASSIGN_S CHAN = W^MBCHAN,-
		DEVNAM = W^MBNAM		; see if perm MBX left over
	CMPL	R0,#SS$_NOSUCHDEV		; is it here
	BEQL	10$				; br if not
	$DELMBX_S CHAN = W^MBCHAN		; else get rid of it
	$DASSGN_S CHAN = W^MBCHAN		; drop the channel
10$:
	CALLS	#0,W^COUNT_CHAN			; get enviromental channel count
	MOVL	W^TOTAL_CHAN,W^CHAN_SAVE	; save the enviromental chan count
	PUSHL	#PSL$C_USER			; push the access mode
	CALLS	#1,W^ASSDAS_CHK			; do the assign/deassign tests
	CALLS	#0,W^ERLBUF_DUMP		; dump any errors
;+
;
; test super mode
;
;-
	NEXT_TEST
	MOVAL	W^ASSIGN,W^SERV_NAME		; set service name
	MOVAL	W^SM,W^MODE			; set the mode
	CHMS	#1				; do the super tests
	CALLS	#0,W^ERLBUF_DUMP		; dump any errors
;+
;
; test exec mode
;
;-
	NEXT_TEST
	MOVAL	W^EM,W^MODE			; set the mode
	MOVAL	W^ASSIGN,W^SERV_NAME		; set service name
	$CMEXEC_S B^10$				; get thee to exec mode
	BRW	20$
10$:
	.WORD	0
	PUSHL	#PSL$C_EXEC			; push the access mode
	CALLS	#1,W^ASSDAS_CHK			; do the assign/dassgn tests
	RET					; return to user
20$:
	CALLS	#0,W^ERLBUF_DUMP		; dump any errors
;+
;
; test kernel mode
;
;-
	NEXT_TEST
	MOVAL	W^ASSIGN,W^SERV_NAME		; set service name
	MOVAL	W^KM,W^MODE			; set the mode
	MOVAL	W^ASSIGN,W^SERV_NAME		; set service name
	$CMKRNL_S B^10$
	BRW	20$				; skip the routine
10$:
	.WORD	0
	PUSHL	#PSL$C_KERNEL			; push the access mode
	CALLS	#1,W^ASSDAS_CHK			; do the assign/dassgn tests
	
	RET					; return to user mode
20$:
	CALLS #0,W^ERLBUF_DUMP			; report any errors
	MOVAL	W^UM,W^MODE			; reset the mode

	.SBTTL	ALLOC  AND DALLOC TESTS
;+
;
; $ALLOC and $DALLOC tests
;
; test user mode
;
;-
	NEXT_TEST
	MOVAL	W^ALLOC,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set the mode
	$CREMBX_S CHAN  =W^MBCHAN,-
		  LOGNAM=W^MBNAM,-
		  PRMFLG=#1			; create an allocatable device
	$DASSGN_S CHAN=W^MBCHAN			; make it allocatable
	PUSHL	#PSL$C_USER			; push the mode
	CALLS	#1,W^ALLDAL_CHK			; check the services
	CALLS	#0,W^ERLBUF_DUMP		; dump any errors
;+
;
; test super mode
;
;-
	NEXT_TEST
	MOVAL	W^ALLOC,W^SERV_NAME		; set service name
	MOVAL	W^SM,W^MODE			; set the mode
	CHMS	#3				; do the super mode tests
;+
;
; test exec mode
;
;-
	NEXT_TEST
	MOVAL	W^ALLOC,W^SERV_NAME		; set service name
	MOVAL	W^EM,W^MODE			; set the mode
	$CMEXEC_S B^10$				; get to exec mode
	BRB	20$				; skip the routine
10$:
	.WORD	0
	PUSHL	#PSL$C_EXEC			; push the mode
	CALLS	#1,W^ALLDAL_CHK			; do the tests
	RET					; return to user mode
20$:
;+
;
; test kernel mode
;
;-
	NEXT_TEST
	MOVAL	W^ALLOC,W^SERV_NAME		; set the service name
	MOVAL	W^KM,W^MODE			; set the mode
	$CMKRNL_S B^10$				; get into kernel mode
	BRB	20$				; skip the routine
10$:
	.WORD	0
	PUSHL	#PSL$C_KERNEL			; push the mode
	CALLS	#1,W^ALLDAL_CHK			; do the tests
	RET					; return
20$:
	$ASSIGN_S DEVNAM=W^MBNAM,-
		  CHAN  =W^MBCHAN		; get the device back
	$DELMBX_S CHAN  =W^MBCHAN		; and get rid of it!
	MOVC5	#0,W^GETBUF,#0,#132,W^GETBUF+8	; clean up the buffer
.PAGE
	.SBTTL	CANCEL TESTS
;+
;
; $CANCEL tests
;
; test EF wait IO cancellation with _S form
;
;-
	NEXT_TEST
	MOVAL	W^CANCEL,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set the mode
	$CREMBX_S CHAN = W^CHAN1,-
		LOGNAM = W^MBNAM		; make a MBX
	MOVZWL	W^CHAN1,W^QIOP+QIO$_CHAN	; set the channel up
	MOVZWL	W^CHAN1,W^CANC+CANCEL$_CHAN	; in QIO and CANCEL
	$QIO_G	W^QIOP				; do a read on the MBX
	$CANCEL_S CHAN=W^CHAN1			; cancel the IO
	FAIL_CHECK SS$_NORMAL			; check for success
	$WAITFR_S EFN=#31			; wait for IO completion
	CALLS	#0,W^CAN_CHECK			; check IO status block
;+
;
; test EF wait IO cancellation with _S form
;
;-
	NEXT_TEST
	$QIO_G	W^QIOP				; do a read on the MBX
	$CANCEL_G W^CANC			; try _G
	FAIL_CHECK SS$_NORMAL			; check for success
	$WAITFR_S EFN=#31			; wait for IO completion
	CALLS	#0,W^CAN_CHECK			; check the IO status block
;+
;
; test AST wait IO cancellation with _S form
;
;-
	NEXT_TEST
	MOVAL	W^IONC,W^QIOP+QIO$_ASTADR	; set AST address
	$QIO_G	W^QIOP				; issue read on the MBX
	$CANCEL_S CHAN=W^CHAN1			; cancel it
	FAIL_CHECK SS$_NORMAL			; check success
	$HIBER_S				; wait for AST
;+
;
; test AST wait IO cancellation with _G form
;
;-
	NEXT_TEST
	$QIO_G	W^QIOP				; issue read to the MBX
	$CANCEL_G W^CANC			; cancel it
	FAIL_CHECK	SS$_NORMAL		; check for success
	$HIBER_S				; wait for AST
	MOVL	#1,W^QIOP+QIO$_P2		; reset QIO parameters
	MOVL	#IO$_READVBLK,W^QIOP+QIO$_FUNC
	CLRL	W^QIOP+QIO$_ASTADR
	$DASSGN_S CHAN = W^CHAN1		; drop the MBX
.PAGE
	.SBTTL	GETCHN TESTS
;+
;
; $GETCHN tests
;
; test _S form
;
;-
	NEXT_TEST
	MOVAL	W^GETCHN,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set the mode
	CLRL	W^STAT				; set dummy status
	CLRL	W^STAT1				; in #1 & #2
	$CREMBX_S   CHAN=W^MBCHAN,-
		  PRMFLG=#0,-
		  LOGNAM=W^MBNAM		; make a device to look at
	MOVZWL	W^MBCHAN,W^QIOP+QIO$_CHAN	; save the channel number
	$GETCHN_S CHAN  =W^MBCHAN,-
		  PRILEN=W^PL,-
		  PRIBUF=W^PB,-
		  SCDLEN=W^SL,-
		  SCDBUF=W^SB			; try the _S
	FAIL_CHECK SS$_NORMAL			; check success
	MOVW	W^PB+DIB$W_UNIT+8,-
		W^MB_DEV_CHAR+DIB$W_UNIT	; the unit # is a variable
						; and must be filled in
	MOVAL	W^PB+8,R6			; set buffer address
	MOVAL	W^MB_DEV_CHAR,R7		; set good data address
	MOVL	#MB_CHAR_SIZE,R8		; set the byte count
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; check the resulting buffer
	MOVAL	W^SB+8,R6			; set buffer address
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; check the secondary buf
	MOVC5	#0,W^PB+8,#0,W^PL,W^PB+8	; init the buffers
	MOVC5	#0,W^SB+8,#0,W^SL,W^SB+8
;+
;
; test _G form
;
;-
	NEXT_TEST
	MOVW	W^MBCHAN,W^GETC+GETCHN$_CHAN	; set the channel #
	$GETCHN_G W^GETC			; try _G form
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; check the returned buffer
	MOVAL	W^PB+8,R6			; check the primary buffer
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; for failures
	MOVC5	#0,W^PB+8,#0,W^PL,W^PB+8	; init the buffers
	MOVC5	#0,W^SB+8,#0,W^SL,W^SB+8
.PAGE
	.SBTTL	GETDEV
;+
;
; $GETDEV tests
;
;
;-
	NEXT_TEST
	MOVAL	W^GETDEV,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set the mode
	$GETDEV_S DEVNAM=W^MBNAM,-
		  PRILEN=W^PL,-
		  PRIBUF=W^PB,-
		  SCDLEN=W^SL,-
		  SCDBUF=W^SB			; try the _S
	FAIL_CHECK SS$_NORMAL			; check success
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; check the resulting buffer
	MOVAL	W^SB+8,R6			; set buffer address
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; check secondary buffer
	MOVC5	#0,W^PB+8,#0,W^PL,W^PB+8	; init the buffers
	MOVC5	#0,W^SB+8,#0,W^SL,W^SB+8
;+
;
; test _G form
;
;-
	NEXT_TEST
	$GETDEV_G W^GETD			; try _G form
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#0				; push expected IO status
	CALLS	#1,W^BUF_CHECK			; check the returned buffer
	MOVAL	W^PB+8,R6			; set the buffer address
	PUSHL	#0				; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the primary buffer
.PAGE
	.SBTTL INPUT AND OUTPUT TESTS
;+
;
; $INPUT and $OUTPUT tests
;
; try $OUTPUT with small transfer and a local EFN
;
;-
	NEXT_TEST
	MOVAL	W^OUTPUT,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set the mode
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_READVBLK,-
		P1  =W^GETBUF+8,-
		P2  =#1				; let the output finish
	$OUTPUT	CHAN=W^MBCHAN,-
		LENGTH=#1,-
		BUFFER=W^TEST_DATA,-
		IOSB=W^STAT,-
		EFN=#2				; try output,small, & local EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	MOVAL	W^GETBUF+8,R6			; set input address
	MOVAL	W^TEST_DATA,R7			; set good data address
	MOVL	#1,R8				; set the byte count
	MOVL	#1@16!SS$_NORMAL,W^STAT1	; set dummy status
	PUSHL	#1@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the results
	CLRL	W^GETBUF+8			; init the buffer
;+
;
; test $INPUT with small transfer and local EFN
;
;-
	NEXT_TEST
	MOVAL	W^INPUT,W^SERV_NAME		; set service name
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#1				; put data there to read
	$INPUT	CHAN=W^MBCHAN,-
		LENGTH=#1,-
		BUFFER=W^GETBUF+8,-
		IOSB=W^STAT,-
		EFN=#2				; try input,small, & local EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#1@16!SS$_NORMAL		; set expected IO status
	CALLS #1,W^BUF_CHECK			; check transfered data
	CLRL	W^GETBUF+8			; init the buffer
	MOVL	#132,R8				; set new byte count
;+
;
; test $OUTPUT with large transfer and common EFN
;
;-
	NEXT_TEST
	MOVAL	W^OUTPUT,W^SERV_NAME		; set service name
	$ASCEFC_S #65,W^EFCNAM			; make EFN 65
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_READVBLK,-
		P1  =W^GETBUF+8,-
		P2  =#132			; let the $OUTPUT complete
	$OUTPUT	CHAN=W^MBCHAN,-
		LENGTH=#132,-
		BUFFER=W^TEST_DATA,-
		IOSB=W^STAT,-
		EFN=#65				; try output, large with common EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	MOVL	#132@16!SS$_NORMAL,W^STAT1	; set dummy status
	PUSHL	#132@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the buffer
	MOVC5	#0,W^GETBUF+8,#0,#132,W^GETBUF+8 ; init the buffer
;+
;
; test $INPUT with large transfer and common EFN
;
;-
	NEXT_TEST
	MOVAL	W^INPUT,W^SERV_NAME		; set service name
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#132			; put data out to read
	$INPUT	CHAN=W^MBCHAN,-
		LENGTH=#132,-
		BUFFER=W^GETBUF+8,-
		IOSB=W^STAT,-
		EFN=#65				; try input, large with common EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#132@16!SS$_NORMAL		; set expected IO status
	CALLS #1,W^BUF_CHECK			; check transfered data
	MOVC5	#0,W^GETBUF+8,#0,#132,W^GETBUF+8 ; init the buffer
.PAGE
	.SBTTL	QIO TESTS
;+
;
; $QIO tests
;
; test local EFN = 3, IO$_WRITEVBLK, _S, 1 byte transfer
;
;-
	MOVL	#1,R8				; set byte count
	NEXT_TEST
	MOVAL	W^QIO,W^SERV_NAME		; set service name
	$QIO_S	EFN =#3,-
		CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEVBLK,-
		IOSB=W^STAT,-
		P1  =W^TEST_DATA,-
		P2  =#1				; try _S local bc = 1 writevblk
	FAIL_CHECK SS$_NORMAL			; check success
;+
;
; test local EFN = 31, IO$_READVBLK, _G, 1 byte transfer
;
;-
	NEXT_TEST
	CLRL	W^QIOP+QIO$_ASTADR		; disable AST's
	$QIO_G	W^QIOP				; try _G local bc = 1 readvblk
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#3			; wait for the writevblk
	$WAITFR_S EFN=#31			; wait for the readvblk
	PUSHL	#1@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the results
	CLRL	W^GETBUF+8			; init the buffer
	MOVL	#2,R8				; set byte count
;+
;
; test common EFN = 65, IO$_READLBLK, _S, 2 byte transfer
;
;-
	NEXT_TEST
	$QIO_S	EFN=#65,-
		CHAN=W^MBCHAN,-
		FUNC=#IO$_READLBLK,-
		IOSB=W^STAT,-
		P1  =W^GETBUF+8,-
		P2  =#2				; try common EFN READLBLK
	FAIL_CHECK SS$_NORMAL			; check success
;+
;
; test common EFN = 92, IO$_WRITELBLK, _G, 2 byte transfer
;
;-
	NEXT_TEST
	MOVL	#92,W^QIOP+QIO$_EFN		; set EFN
	MOVL	#IO$_WRITELBLK,W^QIOP+QIO$_FUNC	; set FUNC
	MOVAL	W^TEST_DATA,W^QIOP+QIO$_P1	; set transfer address
	MOVL	#2,W^QIOP+QIO$_P2		; set byte count
	$QIO_G	W^QIOP				; try common EFN writelblk
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#65			; wait for readlblk
	$WAITFR_S EFN=#92			; wait for writlblk
	PUSHL	#2@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check transfer
	CLRL	W^GETBUF+8			; init the buffer
	MOVL	#132,R8				; set byte count
;+
;
; test AST, IO$_WRITEPBLK, _S, 132 byte transfer
;
;-
	NEXT_TEST
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEPBLK,-
		IOSB=W^STAT,-
		ASTADR=W^AST1,-
		ASTPRM=#1,-
		P1  =W^TEST_DATA,-
		P2  =#132			; try AST writepblk
	PUSHL	R0				; save the QIO status
	$SETAST_S ENBFLG=#0			; let things get checked
	POPL	R0				; reset the QIO status
						; before the AST's start
						; to fly!
	FAIL_CHECK SS$_NORMAL			; check success
;+
;
; test AST, IO$_READPBLK, _G, byte count 132
;
;-
	NEXT_TEST
	MOVL	#IO$_READPBLK,W^QIOP+QIO$_FUNC	; set FUNC
	MOVAL	W^AST2,W^QIOP+QIO$_ASTADR	; set ASTADR
	MOVL	#2,W^QIOP+QIO$_ASTPRM		; set ASTPRM
	MOVAL	W^GETBUF+8,W^QIOP+QIO$_P1	; set read buffer adr
	MOVL	#132,W^QIOP+QIO$_P2		; set byte count
	$QIO_G	W^QIOP				; try AST delivery _G
	FAIL_CHECK SS$_NORMAL			; check success
	$SETAST_S ENBFLG=#1			; let all heck break loose
	$WAITFR_S EFN=#92			; let the dust settle
	PUSHL	#132@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check transfer
	MOVC5	#0,W^GETBUF+8,#0,#132,W^GETBUF+8 ; init the buffer
	BRW	NEXT				; skip over AST routines
;+
;
; service writelblk AST
;
;-
AST1:
	.WORD	^M<R2,R3,R4>
	NEXT_TEST
	CMPL	4(AP),#1			; right AST parameter?
	BEQL	10$				; br if yes
	PUSHL	4(AP)				; push received
	PUSHL	#1				; push expected
	PUSHAL	W^ASTEXP			; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
	RET					; return
;+
;
; test the readlblk AST
;
;-
AST2:
	.WORD	^M<R2,R3,R4>
	NEXT_TEST
	CMPL	4(AP),#2			; right AST parameter?
	BEQL	10$				; br if yes
	PUSHL	4(AP)				; push received
	PUSHL	#2				; push expected
	PUSHAL	W^ASTEXP			; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the error
10$:
	RET					; return
;+
;
; test IO$_SETMODE, _S, READATTN
;
;-
NEXT:
	NEXT_TEST
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_SETMODE!IO$M_READATTN,-
		EFN =#2,-
		P1  =W^AST3,-
		P2  =#3,-
		P3  =#PSL$C_USER		; try _S SETMODE
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#2			; let it finish
	CLRL	W^QIOP+QIO$_ASTADR		; disable AST's for this one
	CLRL	W^QIOP+QIO$_ASTPRM
	$SETAST_S ENBFLG=#0			; hold back on the reins
	$QIO_G	W^QIOP				; force the READATTN AST
	FAIL_CHECK SS$_NORMAL			; check success
	$SETAST_S ENBFLG=#1			; let it fly
	BRW	NEXT1				; skip over AST routine
;+
;
; service READATTN AST
;
;-
AST3:
	.WORD	0
	NEXT_TEST
	CMPL	4(AP),#3			; correct AST?
	BEQL	10$				; br if OK
	PUSHL	4(AP)				; push receeived
	PUSHL	#3				; push expected
	PUSHAL	W^ASTEXP			; push the string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
	MOVL	#IO$_WRITEVBLK,W^QIOP+QIO$_FUNC	; set the new mode
	$QIO_G	W^QIOP				; and eat the read pending
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#92			; wait for it to digest.
	RET					; carry on
;+
;
; test IO$_SETMODE, _G, WRTATTN
;
;-
NEXT1:
	NEXT_TEST
	MOVL	#IO$_SETMODE!IO$M_WRTATTN,-
		W^QIOP+QIO$_FUNC		; set new function
	MOVAL	W^AST4,W^QIOP+QIO$_P1		; set new P1
	MOVL	#4,W^QIOP+QIO$_P2		; set new P2
	MOVL	#PSL$C_USER,W^QIOP+QIO$_P3	; set new P3
	$QIO_G	W^QIOP				; try _G setmode
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#92			; wait for it to complete
	$SETAST_S ENBFLG=#0			; hold back on the reins
	MOVL	#IO$_WRITEVBLK,QIOP+QIO$_FUNC	; set new function
	MOVAL	W^TEST_DATA,W^QIOP+QIO$_P1	; set new P1
	$QIO_G	W^QIOP				; kick off WRTATTN AST
	FAIL_CHECK SS$_NORMAL			; check success
	$SETAST_S ENBFLG=#1			; let it fly
	BRW	NEXT2				; skip AST routine
;+
;
; service WRTATTN AST
;
;-
AST4:
	.WORD	0
	NEXT_TEST
	CMPL	4(AP),#4			; is it the right one?
	BEQL	10$				; br if it's OK
	PUSHL	4(AP)				; save received
	PUSHL	#4				; save expected
	PUSHAL	W^ASTEXP			; save string variable
	CALLS	#3,W^PRINT_FAIL			; print the error
10$:
	MOVL	#IO$_READVBLK,W^QIOP+QIO$_FUNC	; set new function code
	MOVAL	W^GETBUF+8,W^QIOP+QIO$_P1	; set new read address
	$QIO_G	W^QIOP				; eat the write pending
	FAIL_CHECK SS$_NORMAL			; check for success
	$WAITFR_S EFN=#92			; and wait for it to digest
	RET					; bail out
;+
;
; test IO$_SETCHAR, _S
;
; This function is not tested because of the lack of a device that is
; allocatable and char. setable on the minimum configuration.
;
;-
NEXT2:

;+
;
; test IO$_WRITEOF, _G
;
;-
	NEXT_TEST
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEOF,-
		EFN =#10			; issue the WRITEOF
	FAIL_CHECK SS$_NORMAL			; check success
	MOVZWL	W^MBCHAN,W^QIOP+QIO$_CHAN	; reset the channel
	MOVL	#IO$_READVBLK,W^QIOP+QIO$_FUNC	; set for the read
	MOVAL	W^GETBUF+8,W^QIOP+QIO$_P1	; set dummy address
	MOVL	#2,QIOP+QIO$_P2			; set any byte count
	$QIO_G	W^QIOP				; issue a read
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#92			; wait for completion
	CMPL	W^STAT1,#SS$_ENDOFFILE		; right status code?
	BEQL	10$				; br if OK
	PUSHL	W^STAT1				; push received
	PUSHL	#SS$_ENDOFFILE			; push expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
;+
;
; test IO$_ACCESS, _G
;
; Start testing disk files.  We first want to find the FID of [SYSTEST],
; which may be in a top level system directory.  Save that FID as the DID
; for further testing.
;
;-
	NEXT_TEST
	$ASSIGN_S W^DISK,W^CHAN1		; assign the disk channel
	$TRNLOG_S LOGNAM = W^TOPSYS,-		; See if there is...
		  RSLLEN = W^TOPSYS_DIR,-	; ...a top level...
		  RSLBUF = W^TOPSYS_DIR,-	; ...system directory...
		  DSBMSK = #6			; ...defined system-wide
	CMPW	#SS$_NOTRAN,R0			; If there's no translation...
	BEQL	10$				; ...
	TSTW	W^TOPSYS_DIR			; ...or the trans is null...
	BEQL	10$				; ...we have no top level dirs
	PUSHR	#^M<R2,R3,R4,R5,R6>		; Save these over MOVC, etc.
	MOVZWL	W^TOPSYS_DIR,R6			; Get top level dir name length
	MOVC3	W^DOT_DIR_SEMI,W^DOT_DIR_SEMI+8,- ; Form a file spec for...
		TOPSYS_DIR+8(R6)		  ; ...the dir name...
	ADDW2	W^DOT_DIR_SEMI,W^TOPSYS_DIR	  ; ...
	POPR	#^M<R2,R3,R4,R5,R6>		; Clean up after MOVC, etc.
	$QIOW_S	EFN=#16,-			; Get the top level...
		CHAN=W^CHAN1,-			; ...system directory FID
		FUNC=#IO$_ACCESS,-
		IOSB=W^STAT,-
		P1  =W^FIBDES,-
		P2  =#TOPSYS_DIR,-
		P5  =#ATR
	FAIL_CHECK SS$_NORMAL			; Check success of call...
	CMPL	#SS$_NORMAL,W^STAT		; ...and its results
	BNEQ	20$				; BR if error occurred
	PUSHR	#^M<R2,R3,R4,R5>		; Save these over MOVC, etc.
	MOVC3	#6,W^FIB+FIB$W_FID,W^FIB+FIB$W_DID ; Get the new DID...
	MOVC5	#0,#0,#0,#6,W^FIB+FIB$W_FID	; ...and reset the FID
	POPR	#^M<R2,R3,R4,R5>		; Restore after MOVC, etc.
10$:
	MOVAL	W^SYSTEST_DIR,W^ATR+4		; Point to SYSTEST dir name
	$QIO_S	EFN=#16,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_ACCESS,-
		IOSB=W^STAT,-
		P1  =W^FIBDES,-
		P2  =#SYSTEST_DIR,-
		P5  =#ATR			; access file to get DID
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#16			; wait for completion
	CMPL	W^STAT,#SS$_NORMAL		; check IO status
	BEQL	30$				; br if no error
20$:
	PUSHL	W^STAT				; push recieved
	PUSHL	#SS$_NORMAL			; push expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
30$:
	MOVC3	#6,W^FIB+FIB$W_FID,W^FIB+FIB$W_DID ; get the new DID
;+
;
; test IO$_CREATE, _S
;
; After ensuring that we have SYSPRV, set up access control and extension
; control.  Set up a test file, superseding any old one which may be present.
;
;-
	NEXT_TEST
	MODE	TO,10$,KRNL,NOREGS		; kernal mode to access PHD
	MOVL	@#CTL$GL_PHD,R9			; get process header address
	MOVAL	PHD$Q_PRIVMSK(R9),W^PRIVMASK 	; get priv mask address
	MODE	FROM,10$			; get back to user mode
	PRIV	ADD,SYSPRV			; add SYSPRV priv.
	CLRL	W^FIB+FIB$W_FID			; clear out the FID
	CLRW	W^FIB+FIB$W_FID_RVN
	MOVL	#FIB$M_WRITE!FIB$M_NOREAD!-
		 FIB$M_NOWRITE,W^FIB+FIB$L_ACCTL ; set new ACCTL
	MOVW	#FIB$M_EXTEND!FIB$M_ALCON!-
		 FIB$M_FILCON,W^FIB+FIB$W_EXCTL	; set new EXCTL
	MOVW	#FIB$M_SUPERSEDE,W^FIB+FIB$W_NMCTL ; on top of file if there
	MOVL	#15,W^FIB+FIB$L_EXSZ		; set extend size to 15
	PUSHL	#0				; push a dummy parameter
	CALLS	#1,W^REG_SAVE			; save a register snapshot
	$QIO_S	 EFN = #6,-
		CHAN = W^CHAN1,-
		FUNC = #IO$_CREATE!IO$M_CREATE!IO$M_ACCESS,-
		IOSB = W^STAT,-
		  P1 = W^FIBDES,-
		  P2 = #FILENAME		; create the file
	FAIL_CHECK SS$_NORMAL			; check for success
	$WAITFR_S EFN=#6			; wait until done
	CMPL	W^STAT+4,#15			; was it extended?
	BGEQ	20$				; br if OK
	PUSHL	W^STAT+4			; push received
	PUSHL	#15				; push expected
	PUSHAL	W^DISALL			; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
20$:
	CMPL	W^STAT,#SS$_NORMAL		; check the IO status
	BEQL	25$				; br if no errors
	PUSHL	W^STAT				; push recieved
	PUSHL	#SS$_NORMAL			; push expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
25$:
;+
;
; test IO$_MODIFY, _S
;
; Specify that our test file need not be contiguous and extend it by an
; amount equal to its original size.  Check that we've successfully modified
; the file.
;
;-
	NEXT_TEST
	BICW2	#FIB$M_FILCON,W^FIB+FIB$W_EXCTL ; remove contiguous mark
	CLRL	W^FIB+FIB$L_EXVBN		; allow the modify to work
	$QIO_S	EFN=#7,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_MODIFY,-
		IOSB=W^STAT,-
		P1  =W^FIBDES,-
		P2  =#FILENAME			; try to truncate with IO$_MODIFY
	FAIL_CHECK SS$_NORMAL
	$WAITFR_S EFN=#7			; wait for completion
	CMPL	W^STAT,#SS$_NORMAL		; check IO status
	BEQL	10$				; br if no error
	PUSHL	W^STAT				; push recieved
	PUSHL	#SS$_NORMAL			; push expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
	BISW2	#FIB$M_FILCON,W^FIB+FIB$W_EXCTL ; set a value to be over written
	$QIO_S	EFN=#5,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_ACCESS,-
		IOSB=W^STAT,-
		P1  =W^FIBDES,-
		P2  =#FILENAME
	FAIL_CHECK SS$_NORMAL			; check for success
	$WAITFR_S EFN=#5			; wait for completion
	BBC	#FIB$M_FILCON,W^FIB+FIB$W_EXCTL,20$ ; if cleared then OK
	PUSHAL W^FILNOTMOD			; push string variable
	CALLS	#1,W^PRINT_FAIL			; print the failure
20$:
;+
;
; Check that we may read and write the file with IO$_WRITEVBLK & IO$_READVBLK.
;
;-
	NEXT_TEST
	CLRL	W^STAT				; clean the IO status blk
	CLRL	W^STAT1
	$QIO_S	EFN =#9,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_WRITEVBLK,-
		IOSB=W^STAT,-
		P1  =W^TEST_DATA,-
		P2  =#132,-
		P3  =#1				; write 132 bytes to VBN 1
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#9			; wait here til done
	$QIO_S	EFN =#10,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_READVBLK,-
		IOSB=W^STAT1,-
		P1  =W^GETBUF+8,-
		P2  =#132,-
		P3  =#1				; read 132 bytes from VBN 1
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#10			; wait here til done
	MOVAL	W^GETBUF+8,R6			; set buffer address
	MOVAL	W^TEST_DATA,R7			; set good data address
	MOVL	#132,R8				; set byte count
	PUSHL	#132@16!SS$_NORMAL		; push expected status return
	CALLS	#1,W^BUF_CHECK			; check the transfer
;+
;
; test IO$_DEACCESS, _S
;
;-
	NEXT_TEST
	CLRL	W^STAT				; clear IO status blks
	CLRL	W^STAT1
	MOVC5	#0,W^GETBUF,#0,#FIB$L_LOC_ADDR-
		-FIB$L_WCC,W^FIB+FIB$L_WCC	; clear unneeded stuff in FIB
	PUSHL	#0				; push a dummy parameter
	CALLS	#1,W^REG_SAVE			; save a snapshot of regs
	$QIO_S	EFN =#5,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_DEACCESS,-
		IOSB=W^STAT1,-
		P5  =#ATR,-
		P1  =W^FIBDES			; try _S deaccess
	FAIL_CHECK SS$_NORMAL			; check success
	$WAITFR_S EFN=#5			; wait for completion
	CMPL	#SS$_NORMAL,W^STAT1		; check IO status
	BEQL	10$				; br if OK
	PUSHL	W^STAT1				; push recieved
	PUSHL	#SS$_NORMAL			; push expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
;+
;
; test IO$_DELETE, _S
;
;-
	NEXT_TEST
	CLRL	W^STAT				; init IO status
	$QIO_S	EFN =#11,-
		CHAN=W^CHAN1,-
		FUNC=#IO$_DELETE!IO$M_DELETE,-
		IOSB=W^STAT,-
		P1  =W^FIBDES,-
		P2  =#FILENAME			; delete the file
	FAIL_CHECK SS$_NORMAL			; check for success
	$WAITFR_S EFN=#11			; wait for completion
	CMPL	#SS$_NORMAL,W^STAT		; check IO status
	BEQL	10$				; br if OK
	PUSHL	W^STAT				; push recieved
	PUSHL	#SS$_NORMAL			; push expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
	$DASSGN_S CHAN=W^CHAN1			; deassign the disk
.PAGE
	.SBTTL	QIOW TESTS
;+
;
; $QIOW tests
;
; The $QIO tests check most of the functionality of the QIO services.
; The purpose of these tests is to check the differences between
; $QIO and $QIOW.
;
; test _S and local EFN
;
;-
	NEXT_TEST
	MOVAL W^QIOW,W^SERV_NAME		; set service name
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_READVBLK,-
		P1  =W^GETBUF+8,-
		P2  =#80			; set up the mailbox
	$QIOW_S	EFN =#16,-
		CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEVBLK,-
		IOSB=W^STAT,-
		P1  =W^TEST_DATA,-
		P2  =#80			; try _S with local EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	MOVAL	W^GETBUF+8,R6			; set buffer address
	MOVAL	W^TEST_DATA,R7			; set good data address
	MOVL	#80,R8				; set the byte count
	MOVL	#80@16!SS$_NORMAL,W^STAT1	; set dummy status
	PUSHL	#80@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the data
	MOVC5	#0,W^GETBUF+8,#0,#80,W^GETBUF+8	; init the buffer
;+
;
; test _G with local EFN
;
;-
	NEXT_TEST
	MOVL	W^MBCHAN,W^QIOWP+QIOW$_CHAN	; set the channel number
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#80			; set up the mailbox
	$QIOW_G	W^QIOWP				; try _G with local EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#80@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the data
	MOVC5	#0,W^GETBUF+8,#0,#80,W^GETBUF+8	; init the buffer
;+
;
; test _S with common EFN
;
;-
	NEXT_TEST
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#80			; set up mailbox
	$QIOW_S	CHAN=W^MBCHAN,-
		EFN =#65,-
		FUNC=#IO$_READVBLK,-
		P1  =W^GETBUF+8,-
		P2  =#80			; try _S with common EFC
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#80@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the data
	MOVC5	#0,W^GETBUF+8,#0,#80,W^GETBUF+8	; init the buffer
;+
;
; test _G with common EFC
;
;-
	NEXT_TEST
	MOVL	#65,W^QIOWP+QIOW$_EFN		; set EFN
	MOVL	#IO$_WRITEVBLK,W^QIOWP+QIOW$_FUNC ; set function
	MOVAL	W^TEST_DATA,W^QIOWP+QIOW$_P1	; set new P1 parameter
	$QIO_S	CHAN=W^MBCHAN,-
		FUNC=#IO$_READVBLK,-
		P1  =W^GETBUF+8,-
		P2  =#80			; set up mailbox
	$QIOW_G	W^QIOWP				; try _G with common EFN
	FAIL_CHECK SS$_NORMAL			; check for success
	PUSHL	#80@16!SS$_NORMAL		; set expected IO status
	CALLS	#1,W^BUF_CHECK			; check the data
;+
;
; reset super mode handler to the original address and
; dump any errors on the terminal that occured at AST disable time.
;
;-
CLEAN_UP:
	$DLCEFC_S W^EFCNAM			; get rid of the cluster
	$DASSGN_S CHAN=W^MBCHAN			; waste the MBXp^/^
	MOVAL	W^DCLCMH,W^SERV_NAME		; set service name
	CHMS	#2				; reset the CHMS handler
	CALLS #0,W^ERLBUF_DUMP			; dump any errors
	TEST_END

.SBTTL	ROUTINES
.SBTTL SETUP_SUPER ROUTINE
;++
;
;	Routine to declare an initial CHMS handler from user mode.
;
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S W^SETUP_SUPER,ARGLST
;
;		ARGLST = address of a pointer to a one parameter argument list containing
;			 the address of the entry mask of the CHMS handler
;
; INPUT PARAMETERS:
;
;	ARGLST
;
; IMPLICIT INPUTS
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	Declares a change mode handler for super mode which must be
;	reset to DCL in the users handler routine when the handler is
;	no longer needed.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
; ON ENTRY:
;		       ---------	       ---------
;		KSP => !   0   !	USP => !       !
;		       !   0   !	       !  USER !
;		       !   AP  !	       !       !
;		       !   FP  !	       !  CALL !
;		       !   PC  !	       !       !
;		       !   0   !	       ! FRAME !
;		       !   0   !	       !       !
;		       !   AP  !	       ---------
;		       !   FP  !
;		       !SRVEXIT!
;		       !   PC  !
;		       !  PSL  !
;		       ---------
;--
.PAGE
RETURN_PC:
	.LONG	0			; storage for user return PC
HANDLER_PC:
	.LONG	0			; storage for handler PC
;
SETUP_SUPER:
	.WORD	^M<R2,R3>	
	MFPR	#PR$_USP,R3		; get the user call frame address
	MOVL	SF$L_SAVE_PC(R3),B^RETURN_PC ; get the user return PC
	MOVL	4(AP),HANDLER_PC	; save the handler address
	MOVL	SF$L_SAVE_FP(FP),R2	; get saved FP
	ADDL	S^#EXE$C_CMSTKSZ,R2	; back over change mode stack frame
	MOVAB	B^20$,(R2)		; set return address
	INSV	#<<PSL$C_SUPER@PSL$S_CURMOD>+PSL$C_SUPER>,-
		#PSL$V_PRVMOD,-
		#PSL$S_CURMOD*2,4(R2)	; set current and previous mode to super
	MOVL	S^#SS$_NORMAL,R0	; set correct return code
	RET				; enter super mode
20$:
	CLRL	-(SP)			; set up dummy PSL
	CALLG	(SP),B^30$		; create initial call frame
30$:
	.WORD	^M<>			; entry mask
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save the registers
	$DCLCMH_S @HANDLER_PC,W^PRVHND1,#0 ; set real handler
	FAIL_CHECKNP SS$_NORMAL		; check for success
	PUSHL	#<<PSL$C_USER@PSL$V_CURMOD>-
		!<PSL$C_USER@PSL$V_PRVMOD>>; set return to user
	PUSHL	RETURN_PC		; set the return PC
	REI				; return to user mode
.PAGE
.SBTTL SUPER_MODE
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to handle the CHMS instructions.
;
; CALLING SEQUENCE:
;	CHMS	#N
;
; INPUT PARAMETERS:
;	  SP=>	CHMS parameter
;		PC
;		PSL
;
;	  The CHMS parameter can be one of the following:
;
;		1 = execute $ASSIGN and $DASSGN service tests
;		2 = execute a $DCLCMH_S to reset the CHMS handler to DCL
;		3 = execute $ALLOC and $DALLOC service tests
;
; OUTPUT PARAMETERS:
;	NONE
;--

SUPER_MODE:
	MOVL	(SP)+,R0			; get CHM parameter off the stack
	CASEB	R0,#1,#3			; do the right thing
10$:
	.WORD	20$-10$
	.WORD	A30-10$
	.WORD	A40-10$
20$:
	PUSHL	#PSL$C_SUPER			; push the mode
	CALLS	#1,W^ASSDAS_CHK			; do the tests
	BRW	A50				; get back to user mode
A30:
	MOVAL	W^DCLCMH,W^SERV_NAME		; set service name pointer
	$DCLCMH_S @PRVHND1,,#0			; reset the CHMS handler for DCL
	FAIL_CHECK SS$_NORMAL			; check for success
	BRB	A50				; get back to user mode
A40:
	PUSHL	#PSL$C_SUPER			; push the mode
	CALLS	#1,W^ALLDAL_CHK			; do the tests
A50:
	REI					; return to user mode
.PAGE
	.SBTTL BUF_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check the contents of a buffer against known good 
;	data and check the IO status return.
;
; CALLING SEQUENCE:
;	PUSHL	#EXPECTED_IOSTATUS	; set expected IO status
;	CALLS #1,W^BUF_CHECK		; check buffer
;
; INPUT PARAMETERS:
;	R6 = buffer address
;	R7 = good data address
;	R8 = byte count
;	STAT = IO status #1
;	STAT1 = IO status #2
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

BUF_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVL	R6,R9				; save a copy of the buffer address
	CMPC3	R8,(R7),(R6)			; check the buffer
	BEQL	10$				; br if good
	SUBL3	R9,R3,W^ARGLST1+8		; get buffer offset
	MOVZWL	W^PB+DIB$W_UNIT+8,W^ARGLST1+4	; get the unit number
	MOVZBL	(R1),W^ARGLST1+12		; get the good data
	MOVZBL	(R3),W^ARGLST1+16		; get the bad data
	$GETMSG_S MSGID=#UETP$_DATAER,-
		  MSGLEN=W^ML,-
		  BUFADR=W^CTRSTR,-
		  FLAGS =#1			; get the ctrstr
	$FAOL_S	W^CTRSTR,W^ML,W^GETBUF,W^ARGLST1 ; make it readable
	PUSHAL	W^ML				; push the desc. address
	CALLS #1,W^PRINT_FAIL			; print the failure
10$:
	CMPL	4(AP),W^STAT			; check status #1
	BEQL	20$				; br if OK
	PUSHL	W^STAT				; else save it
	BRB	30$				; and continue in common
20$:
	CMPL	4(AP),W^STAT1			; check IO status #2
	BEQL	40$				; br if OK
	PUSHL	W^STAT1				; else save it
30$:
	PUSHL	4(AP)				; save expected
	PUSHAL	W^IOEXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
40$:
	RET					; return
.PAGE
	.SBTTL IONC
;++
; FUNCTIONAL DESCRIPTION:
;	AST routine to service IO AST's for the CANCEL service
;
; CALLING SEQUENCE:
;	Entered via an AST
;
; INPUT PARAMETERS:
;	STAT = CANCEL status return
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

IONC:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	CALLS	#0,B^CAN_CHECK			; check the cancel
	$WAKE_S					; tell the test to wake up!
	RET					; return
	.SBTTL CAN_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check the results of a CANCELLED IO.
;
; CALLING SEQUENCE:
;	CALLS #0,W^CAN_CHECK	; check results
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

CAN_CHECK:
	.WORD^M<R2,R3,R4,R5,R6,R7,R8,R9>
	CMPW	W^STAT1,#SS$_ABORT		; check IO status blk
	BEQL	10$				; br if OK
	PUSHL	W^STAT1				; push received
	PUSHL	#SS$_ABORT			; push expected
	PUSHAL	W^EXP				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the failure
10$:
	CLRL	W^STAT				; setup for next CANCEL
	RET					; return
.PAGE
	.SBTTL	COUNT_CHAN
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to count the number of assigned channels.
;
; CALLING SEQUENCE:
;	CALLS #0,W^COUNT_CHAN	; count the number of assigned channels
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	TOTAL_CHAN = count of all assigned channels
;
;--

TOTAL_CHAN:
	.LONG	0				; assigned channel count
COUNT_CHAN:
	.WORD	^M<R2,R3,R4>
	ADDL3	CTL$GL_CCBBASE,#CCB$B_AMOD,R2	; get base and offset to test assignment
	MNEGL	#CCB$C_LENGTH,R3		; set starting channel index
	MOVZWL	@#CTL$GW_NMIOCH,R4		; get number of I/O channels
	CLRL	W^TOTAL_CHAN			; init the # of channels
10$:
	TSTB	(R2)[R3]			; is channel assigned?
	BEQL	20$				; br if not assigned
	INCL	W^TOTAL_CHAN			; else bump chan count
20$:
	SUBL2	#CCB$C_LENGTH,R3		; calc next channel index
	SOBGTR	R4,10$				; any more CCB's?
	RET					; return
	.SBTTL STORE_STEP
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to store step information in the error log buffer.
;
; CALLING SEQUENCE:
;	CALLS #0,W^STORE_STEP
;
; INPUT PARAMETERS:
;	ELBP = current errlog buffer pointer
;
; OUTPUT PARAMETERS:
;	FLAG = error logged flag
;
;--

STORE_STEP:
	.WORD	^M<R2>
	BISB2	#1,W^FLAG			; set the error logged flag
	MOVL	W^ELBP,R2			; get errlog buf pntr
	MOVL	W^SERV_NAME,(R2)+		; save the service name
	MOVL	W^CURRENT_TC,(R2)+		; save the step number
	MOVL	W^MODE,(R2)+			; save the mode
	MOVL	R2,W^ELBP			; reset the errlog buf pntr
	RET					; return
.PAGE
	.SBTTL REG_SAVE
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to save R2-R11 in the register save location.
;
; CALLING SEQUENCE:
;	PUSHL	#0		; save a dummy parameter
;	CALLS	#1,W^REG_SAVE	; save R2-R11
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

REG_SAVE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; save the registers in the program
	RET
	.SBTTL	REG_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages printed using $PUTMSG
;
;--

REG_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0			; is this the right fail code?
	BEQL	10$				; br if yes
	PUSHL	R0				; push received data
	PUSHL	4(AP)				; push expected data
	PUSHAL	W^EXP				; push the string variable
	CALLS	#3,W^PRINT_FAIL			; print the error message
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; check all but R0
	BEQL	20$				; br if O.K.
	SUBL3	#REG_SAVE_AREA,R3,R6		; calculate the register number
	DIVL2	#4,R6
	ADDB3	#^X2,R6,-(SP)			; set number past R0-R1 and save
	BICL2	#3,R1				; backup to register boundrys
	BICL2	#3,R3
	PUSHL	(R1)				; push received data
	PUSHL	(R3)				; push expected data
	PUSHAL	W^REG				; set string pntr param.
	CALLS	#4,W^PRINT_FAIL			; print the error message
20$:
	RET
	.SBTTL	PRINT_FAIL
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to report failures using $PUTMSG
;
; CALLING SEQUENCE:
; Mode  #1	PUSHL EXPECTED	Mode    #2	PUSHL REG_NUMBER
;		PUSHL RECEIVED			PUSHL EXPECTED
;		PUSHAL STRING_VAR		PUSHL RECEIVED
;		CALLS #3,W^PRINT_FAIL		PUSHAL STRING_VAR
;						CALLS #4,W^PRINT_FAIL
; Mode	#3	PUSHAL STRING_VAR
;		CALLS #1,W^PRINT_FAIL
;
; INPUT PARAMETERS:
;	listed above
;
; OUTPUT PARAMETERS:
;	an error message is printed using $PUTMSG
;
;--

PRINT_FAIL:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	W^CS1,W^MESSAGEL,W^MSGL,#TEST_MOD_NAME,W^SERV_NAME,W^CURRENT_TC
	$PUTMSG_S W^MSGVEC			; print the message
	CMPB	(AP),#4				; is this a register message?
	BEQL	10$				; br if yes
	CMPB	(AP),#1				; is this just a message?
	BEQL	20$				; br if yes
	$FAO_S	W^CS2,W^MESSAGEL,W^MSGL,4(AP),8(AP),4(AP),12(AP)
	BRB	30$				; goto output message
10$:
	$FAO_S	W^CS3,W^MESSAGEL,W^MSGL,4(AP),16(AP),8(AP),4(AP),16(AP),12(AP)
	BRB	30$				; goto output message
20$:
	MOVL	4(AP),W^MSGVEC1+12		; save string address
	$PUTMSG_S W^MSGVEC1			; print the message
	BRB	40$				; skip the other message
30$:
	$PUTMSG_S W^MSGVEC			; print the message
40$:
	CALLS	#0,W^MODE_ID			; identify the mode
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
	RET

.PAGE
	.SBTTL REG_CHECKNP
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution without printing it. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed. This routine collects the error
;	information in buffer ERLB instead of printing it.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages logged in buffer ERLB which are printed
;	using routine ERLBUF_DUMP.
;
;	Error packets are in the following form:
;
;		!-----------------!
;		!Service name pntr!
;		!-----------------!
;		!     Step #	  !
;		!-----------------!
;		!Mode name pointer!
;		!-----------------!
;		!	      !   ! long word count
;		!-----------------!
;		!\/\/\/\/\/\/\/\/\! 3-4 parameter long words
;
;--

FLAG:
	.BYTE 0			; error flags are BIT0 = 0 means no errors in the buffer
				;		  BIT0 = 1 means errors in the buffer
ELBP:
	.ADDRESS ERLB		; error log buffer pointer
ERLB:
	.BLKB	1500		; error log buffer
;
REG_CHECKNP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0	; is this the right fail code
	BEQL	10$		; br if yes
	CALLS #0,W^STORE_STEP	; store step information
	MOVL	ELBP,R2		; get the current error log pointer
	MOVB	#3,(R2)+	; save the long word count
	MOVL	R0,(R2)+	; save received status
	MOVL	4(AP),(R2)+	; save expected status
	MOVAL	W^EXP,(R2)+	; save the string variable
	CLRL	(R2)		; set the terminator
	MOVL	R2,ELBP		; reset the buffer pointer
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR ; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE ; set severity code
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA ; check all but R0 and R1
	BEQL	20$		; br if OK
	CALLS #0,W^STORE_STEP	; store step information
	MOVL	ELBP,R2		; get current error log buf pointer
	MOVB	S^#4,(R2)+	; set longword count
	SUBL3	#REG_SAVE_AREA,-
	R3,R6			; calc reg number
	DIVL2	S^#4,R6		; make it a longword count
	ADDL3	S^#2,R6,(R2)+	; correct for R0-R1 and save
	MOVL	(R1),(R2)+	; save received results
	MOVL	(R3),(R2)+	; save expected results
	MOVAL	W^REG,(R2)+	; save string variable
	CLRL	(R2)		; set the terminator
	MOVL	R2,ELBP		; reset the buffer pointer
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
20$:
	RET			; bail out
.PAGE
	.SBTTL	ERLBUF_DUMP
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check for errors in the error log buffer and
;	report any that are there.
;
; CALLING SEQUENCE:
;	CALLS #0,W^ERLBUF_DUMP
;
; INPUT PARAMETERS:
;	FLAG bit 0 = 0 for no errors logged
;	FLAG bit 0 = 1 for errors logged
;	if errors logged then buffer ERLB must contain legal format errors
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

ERLBUF_DUMP:
	.WORD	^M<R2,R3,R4>
	BLBC	FLAG,30$	; br if no errors to report
	MOVAL	ERLB,R2		; set up buffer pointer
10$:
	TSTL	(R2)		; any more errors?
	BEQL	30$		; br if not
	MOVL	(R2)+,W^SERV_NAME ; reset service name
	MOVL	(R2)+,W^CURRENT_TC ; reset step #
	MOVL	(R2)+,W^MODE	; reset the mode
	MOVZBL	(R2)+,R3	; get the longword count
	MOVL	R3,R4		; and save it
20$:
	PUSHL	(R2)+		; push a parameter
	SOBGTR	R3,20$		; and push them all
	CALLS	R4,W^PRINT_FAIL	; print the failure
	BRB	10$		; do the next one
30$:
	MOVAL	W^ERLB,W^ELBP	; reset the buffer pointer
	CLRL	W^ERLB		; set fresh terminater
	RET			; bail out
.PAGE
.PAGE
	.SBTTL	MODE_ID
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to identify the mode that an exit handler is in.
;
; CALLING SEQUENCE:
;	CALLS	#0,W^MODE_ID
;
; INPUT PARAMETERS:
;	MODE contains an address pointing to an ascii string desc.
;	of the current CPU mode.
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

MODE_ID:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	W^CS5,W^MESSAGEL,W^MSGL,MODE ; format the error message
	$PUTMSG_S W^MSGVEC		; print the mode message
	RET
;
	.SBTTL	ALLDAL_CHK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to do the $ALLOC and $DALLOC tests
;
; CALLING SEQUENCE:
;	PUSHL	#ACCESS_MODE
;	CALLS	#1,W^ALLDAL_CHK
;
; INPUT PARAMETERS:
;	4(AP) = the access mode for the test
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

ALLDAL_CHK:
	.WORD	^M<R2,R3,R4,R5>
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	$ALLOC_S DEVNAM=W^MBNAM,-
		 PHYLEN=W^ML,-
		 PHYBUF=W^GETBUF,-
		 ACMODE=4(AP)		; try _S mode
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVL	4(AP),W^ALLO+ALLOC$_ACMODE ; set the new access mode
	$ALLOC_G W^ALLO			; try _G mode
	FAIL_CHECKNP SS$_DEVALRALLOC	; check for proper failure
	MOVAL	W^DALLOC,W^SERV_NAME	; set new service name
	$DALLOC_S DEVNAM=W^MBNAM,-
		  ACMODE=4(AP)		; try _S mode
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVAL W^ALLOC,W^SERV_NAME	; set new service name
	$ALLOC_G W^ALLO			; try successful _G form
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVAL	W^DALLOC,W^SERV_NAME	; set new service name
	MOVL	4(AP),W^DALL+DALLOC$_ACMODE ; set new access mode
	$DALLOC_G W^DALL		; try _G mode
	FAIL_CHECKNP SS$_NORMAL		; check for success
	RET				; return
;
	.SBTTL	ASSDAS_CHK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to do the $ASSIGN and $DASSGN tests
;
; CALLING SEQUENCE:
;	PUSHL	#ACCESS_MODE
;	CALLS	#1,W^ASSDAS_CHK
;
; INPUT PARAMETERS:
;	4(AP) = the access mode for the test
;	CHAN_SAVE = correct number of channels
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

ASSDAS_CHK:
	.WORD	^M<R2,R3,R4,R5>
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	$CREMBX_S CHAN=W^MBCHAN,-
		  LOGNAM=W^MBNAM,-
		  PRMFLG=#0,-
		  ACMODE=#PSL$C_USER	; create temp mailbox
	$ASSIGN_S DEVNAM=W^MBNAM,-
		  CHAN  =W^CHAN1,-
		  ACMODE=4(AP)		; try _S mode
	FAIL_CHECKNP SS$_NORMAL		; check success
	MOVL	4(AP),W^ASGN+ASSIGN$_ACMODE ; set the new mode
	$ASSIGN_G W^ASGN		; try the _G form
	FAIL_CHECKNP SS$_NORMAL		; check success
	MOVAL	W^DASSGN,W^SERV_NAME	; set service name
	$DASSGN_S CHAN=W^CHAN1		; release channel
	FAIL_CHECKNP SS$_NORMAL		; check success
	MOVL	W^CHAN2,W^DASS+DASSGN$_CHAN ; set channel number
	$DASSGN_G W^DASS		; try _G form
	FAIL_CHECKNP SS$_NORMAL		; check success
	$DASSGN_S CHAN=W^MBCHAN		; get rid of the mailbox
	FAIL_CHECKNP SS$_NORMAL		; check success
	TSTW	W^CHAN1			; is there a channel #1
	BEQL	10$			; br if error
	TSTW	W^CHAN2			; is there a channel #2
	BNEQ	20$			; br if no error
10$:
	MOVAL	W^ASSIGN,W^SERV_NAME	; set service name
	CALLS	#0,W^STORE_STEP		; save the step information
	MOVL	W^ELBP,R2		; get error log buf pntr
	MOVB	#1,(R2)+		; save longword count
	MOVAL	W^CS4,(R2)+		; save string variable
	CLRL	(R2)			; set new terminator
	MOVL	R2,W^ELBP		; reset the buffer pointer
20$:
	CALLS	#0,W^COUNT_CHAN		; check the number of assigned channels
	CMPL	W^TOTAL_CHAN,W^CHAN_SAVE ; correct # of channels?
	BEQL	30$			; br if OK
	MOVAL	W^DASSGN,W^SERV_NAME	; set service name
	CALLS	#0,W^STORE_STEP		; save the step information
	MOVL	W^ELBP,R2		; get error log buf pointer
	MOVB	#3,(R2)+		; save long word count
	MOVZWL	W^TOTAL_CHAN,(R2)+	; save the received count
	MOVL	W^CHAN_SAVE,(R2)+	; save expected count
	MOVAL	W^IOCC,(R2)+		; save string variable
	CLRL	(R2)			; set a new terminator
	MOVL	R2,W^ELBP		; reset buffer pointer
30$:
	RET				; return

.PAGE
MOD_MSG_PRINT:
;
;  *****************************************************************
;  *                                                               *
;  *  PRINTS THE TEST MODULE BEGUN/SUCCESSFUL/FAILED MESSAGES      *
;  *	   (USING THE PUTMSG MACRO).                               *
;  *                                                               *
;  *****************************************************************
;
	PUTMSG	<MOD_MSG_CODE,#2,TMN_ADDR,TMD_ADDR> ; PRINT MSG
	RSB				; ... AND RETURN TO CALLER
;
CHMRTN:
; ******************************************************************
; *								   *
; *	CHANGE MODE ROUTINE. THIS ROUTINE GETS CONTROL WHENEVER    *
; *	A CMKRNL, CMEXEC, OR CMSUP SYSTEM SERVICE IS ISSUED	   *
; *	BY THE MODE MACRO ('TO' OPTION).  IT MERELY DOES 	   *
; *	A JUMP INDIRECT ON A FIELD SET UP BY MODE. IT HAS 	   *
; *	THE EFFECT OF RETURNING TO THE END OF THE MODE		   *
; *	MACRO EXPANSION.					   *
; *								   *
; ******************************************************************
;
	.WORD	0			; ENTRY MASK
	JMP	@CHM_CONT		; RETURN TO MODE MACRO IN NEW MODE
;
; *	RET INSTR WILL BE ISSUED IN EXPANSION OF 'MODE FROM, ....' MACRO
;
	.END	SATSSS01
