	.TITLE	SATSSS07 - SATS SYSTEM SERVICE TESTS  (SUCC S.C.)
	.IDENT	'V03-000'
	.DEFAULT DISPLACEMENT,WORD
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SATS SYSTEM SERVICE TESTS
;
; ABSTRACT:	The SATSSS07 module tests the execution of the following
;		VMS system services:
;
;		$CREMBX
;		$DELMBX
;
; ENVIRONMENT:	User mode image.
;		Needs TMPMBX and PRMMBX privilege.
;
; AUTHOR: Paula Tirak,			CREATION DATE: SEPTEMBER, 1979
;
; MODIFIED BY:
;
;	V03-002 FWM0001		Fred W. Matthes		13-Oct-1981
;		Added tests for failure messages (NOPRIV,ACCVIO, etc).
;
;	V03-001	LDJ0001		Larry D. Jones,		17-Sep-1980
;		Modified to conform to new build command procedures.
;**
;--
.PAGE
	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
	.LIBRARY /SYS$LIBRARY:STARLET.MLB/
	$SHR_MESSAGES UETP,116,<<TEXT,INFO>> ; UETP$_TEXT definition
	$SFDEF				; stack frame definitions
	$STSDEF				; STS definitions
	$UETPDEF			; UETP message definitions
	$DIBDEF				; device information block definitions
	$PRVDEF				; privilege name definitions 
	$DSCDEF				; string descriptor definitions
;
; Equated symbols
;
WARNING		= 0			; warning severity value for msgs
SUCCESS		= 1			; success     "      "    "   "
ERROR		= 2			; error       "      "    "   "
INFO		= 3			; information "      "    "   "
SEVERE		= 4			; fatal       "      "    "   "
MBBUF		= 1024			; MBX max. size for messages
HIMSG		= 8192
LOMSG		= 1
BUF_SIZ_S	= 256			; size for _S form
BUF_SIZ_G	=1024			; size for _G form
ENABLE		= 1			; for SETPRV calls
DISABLE		= 0			;   "      "
TEXT_BUFFER	= 256			; misc. message manipulations
;
;
; MACROS
;
.PAGE
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
;
ARGLST:
	.LONG	1
	.ADDRESS SUPER_MODE
CREMBX:
	.ASCIC	/CREMBX/
CS1:					; failure messages
	.ASCID	\Test !AC service name !AC step !UL failed.\
CS2:
	.ASCID	\Expected !AS = !XL received !AS = !XL\
CS3:
	.ASCID	\Expected !AS!UB = !XL received !AS!UB = !XL\
CS4:
	.ASCID	\Required channel not received.\
CS5:
	.ASCID	\Mode was !AS.\
NSSSF:
	.ASCID	\Non-subject system service failure of : !/!_      !AS\
DCLCMH:
	.ASCIC	/DCLCMH/
DELMBX:
	.ASCIC	/DELMBX/
EM:
	.ASCID	/EXECUTIVE/
EXP:
	.ASCID	\status\
KM:
	.ASCID	/KERNEL/
LOGNAMG:
	.ASCID	/MB_S07_G/
LOGNAMG1:
	.ASCID	/MB_S07_PG/
LOGNAMS:
	.ASCID	/MB_S07_S/
LOGNAMS1:
	.ASCID	/MB_S07_PS/
SYS_DEV:					; system disk descriptor
	.ASCID	/SYS$SYSDEVICE/
TMP_PRV_MASK:					; create temp mailbox priv
	.LONG	<1@PRV$V_TMPMBX>
	.LONG	0
PRM_PRV_MASK:					; create perm mailbox priv
	.LONG	<1@PRV$V_PRMMBX>
	.LONG	0
TMP_PRM_PRV_MASK:				; create perm & temp priv
	.LONG	<1@PRV$V_PRMMBX>!<1@PRV$V_TMPMBX>
	.LONG	0
GRP_PRV_MASK:					; GRPNAM privilege mask
	.LONG	<1@PRV$V_GRPNAM>
	.LONG	0
CHANNEL_ZERO:					; MBX channel = 0
	.WORD	0
LEN_00_DESCR:
	.WORD	0				; zero length descriptor
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.ADDRESS LOGNAMS1
LEN_64_DESCR:
	.WORD	60				; 60 char length descriptor
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.ADDRESS LEN_64_NAME
LEN_63_DESCR:
	.WORD	59				; 59 char length descriptor
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.ADDRESS LEN_64_NAME
LEN_64_NAME:
	.ASCII	/THIS_IS_A_LONG_MAILBOX_NAME_WITH/
	.ASCII	/_NUMBER0060_CHARACTERS_IN_IT/	; CREMBX prefixes MBX$
ZERO_ADDR_DESCR:				; address 0 for ACCVIO err
	.WORD	9
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.LONG	0
D_LOGIC_NAME:
	.WORD	5
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.ADDRESS LOGIC_NAME
D_EQUIV_NAME:
	.WORD	5
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.ADDRESS EQUIV_NAME
D_MBX_LOGIC_NAME:
	.WORD	9			; for prefixing 'MBX$'
	.BYTE	DSC$K_DTYPE_T
	.BYTE	DSC$K_CLASS_S
	.ADDRESS MBX_LOGIC_NAME
MBA:
	.ASCID	\MBA\
MSG1:
	.ASCID	/Created mailbox was not permanent./
MSGVEC:
	.LONG	3			; PUTMSG message vector
	.LONG	UETP$_TEXT
	.LONG	1
	.ADDRESS MESSAGEL
PROT:
	.ASCID	/PROMSK/		; protection mask for $CREMBX
SM:
	.ASCID	/SUPER/
TEST_DATA:
	A=1
	.REPT	BUF_SIZ_G/2
	.WORD	A
	A=A+1
	.ENDR
TEST_MOD_BEGIN:				; start end and fail messages
	.ASCIC	/begun/
TEST_MOD_FAIL:
	.ASCIC	/failed/
TEST_MOD_NAME:
	.ASCIC	/SATSSS07/		; needed for SATSMS message
TEST_MOD_NAME_D:
	.ASCID /SATSSS07/		; module name
TEST_MOD_SUCC:
	.ASCIC	/successful/
UM:					; mode messages
	.ASCID	\user\
.PAGE
;
	.SBTTL	R/W PSECT
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
;
;	********************************************************
;	**						      **
;	** The following 2 declaratives must be CONTIGUOUS !! **
;	**						      **
;	********************************************************
MBX_LOGIC_NAME:
	.ASCII	/MBX$/			; for $CREMBX call
LOGIC_NAME:				; for $CRELOG sys service
	.ASCII	/NAMEB/
EQUIV_NAME:
	.ASCII	/NAMEA/
CREATED_FLAG:				; signalling successful mailbox creation
	.BYTE				; for delete service
;
ARGLST1:				; argument list for BUF_CHECK
	.ADDRESS MBA
	.BLKL	4
BUF:
	.BLKB	80
BUFFER:
	.BLKB	8000
CHM_CONT:
	.LONG	0			; change mode continue address
CRE:
	$CREMBX	0,MBCHANG,0,0,0,0,0	; CREMBX paramter list
CTRSTR:
	.LONG	132			; same as above
	.ADDRESS .+4
	.BLKB	132
CURRENT_TC:
	.LONG	0			; ptr to current test case
	.ALIGN LONG			; put it on a long word boundry
DEL:
	$DELMBX	MBCHANG			; DELMBX parameter list
GETBUF:
	.LONG	132			; same as above
	.ADDRESS .+4
	.BLKB	132
MBCHAN:
	.WORD	0			; channel for the $GETCHN
MBCHANG:				; _G mailbox channel
	.WORD	0
MBCHANS:				; _S mailbox channel
	.WORD	0
MBCHAND:				; _D mailbox channel for deletions
	.WORD	0
MBCHAR:
	.LONG	DIB$K_LENGTH		; length of PROMSK for $GETCHN
	.ADDRESS .+4
MBCHR:
	.BLKB	DIB$K_LENGTH		; buffer for PROMSK in $GETCHN
MBX_BUF:
	.BLKB	BUF_SIZ_G		; buffer for QIO reads
MESSAGEL:
	.LONG	0			; message desc.
	.ADDRESS BUF			
	.ADDRESS GETBUF+8
ML:
	.LONG	0			; desc. for BUF_CHECK routine
	.ADDRESS GETBUF+8
MOD_MSG_CODE:
	.LONG	UETP$_SATSMS		; test module message code for putmsg
MODE:
	.LONG	0			; current mode string pointer
MSGL:
	.LONG	80			; buffer desc.
	.ADDRESS BUF
MSGVEC1:				; PUTMSG message vector
	.LONG	3
	.LONG	UETP$_TEXT
	.LONG	1
	.LONG	0
PB:
	.LONG	DIB$K_LENGTH
	.ADDRESS .+4
	.BLKB	DIB$K_LENGTH
PRIVMASK:
	.QUAD	0			; priv. mask
PRVHND1:
	.LONG	0			; previous handler address 1
PRVPRT:
	.BYTE	0			; protection return byte for SETPRT
REG:
	.ASCID	\register R\
REG_SAVE_AREA:
	.BLKL	15			; register save area
REGNUM:
	.LONG	0			; register number
RETADR:
	.BLKL	2			; returned address's from SETPRT
SERV_NAME:
	.LONG	0			; service name pointer
STATUS:
	.LONG	0
TMD_ADDR:
	.ADDRESS TEST_MOD_BEGIN
TMN_ADDR:
	.ADDRESS TEST_MOD_NAME
TPID:
	.LONG	0			; PID for this process
MSG1L:
	.LONG	TEXT_BUFFER		; Buffer #1 desc.
	.ADDRESS BUF1

BUF1:
	.BLKB	TEXT_BUFFER

MESSAGE1L:
	.LONG	0			; Message length
	.ADDRESS BUF1
BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER
.PAGE
	.PSECT	SATSSS07,RD,WRT,EXE,LONG
	.SBTTL	SATSSS07
;++
; FUNCTIONAL DESCRIPTION:
;
;	After performing some initial housekeeping, such as
; printing the module begin message and acquiring needed privileges,
; the system services are tested in each of their normal conditions.
; Detected failures are identified and  an error message is printed
; on the terminal.  Upon completion of the test a success or fail
; message is printed on the terminal.
;
; CALLING SEQUENCE:
;
;	$ RUN SATSSS07  ...  (DCL COMMAND)
;
; INPUT PARAMETERS:
;
;	none
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUT PARAMETERS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Messages to SYS$OUTPUT are the only output from SATSSS07.
;	They are of the form:
;
;		%UETP-S-SATSMS, TEST MODULE SATSSS07 BEGUN ... (BEGIN MSG)
;		%UETP-S-SATSMS, TEST MODULE SATSSS07 SUCCESSFUL ... (END MSG)
;		%UETP-E-SATSMS, TEST MODULE SATSSS07 FAILED ... (END MSG)
;		%UETP-I-TEXT, ... (VARIABLE INFORMATION ABOUT A TEST MODULE FAILURE)
;
; COMPLETION CODES:
;
;	The SATSSS07 routine terminates with a $EXIT to the
;	operating system with a status code defined by UETP$_SATSMS.
;
; SIDE EFFECTS:
;
;	none
;
;--

	TEST_START SATSSS07			; let the test begin
.page
	.SBTTL	CREMBX TESTS
;
;
; $CREMBX tests
;
; Test temporary mailbox.
;
;-
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set mode
	$CREMBX_S PRMFLG=#0,-
		  CHAN  =W^MBCHANS,-		; try _s form
		  MAXMSG=#MBBUF,- 		; set the max. message size
		  BUFQUO=#BUF_SIZ_S,-		; set the buffer quota
		  LOGNAM=W^LOGNAMS		; try _s form
	FAIL_CHECK SS$_NORMAL			; check success
	CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set the max. message size
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO ; set the buffer quota
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; set the lognam
	$CREMBX_G W^CRE				; try _g form
	FAIL_CHECK SS$_NORMAL			; check success
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MBX
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
;+
;
; Test permanent mailbox
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set mode
	$CREMBX_S PRMFLG=#1,-
		  CHAN  =W^MBCHANS,-
		  MAXMSG=#MBBUF,-
		  BUFQUO=#BUF_SIZ_S,-
		  LOGNAM=W^LOGNAMS1		; try _s form
	FAIL_CHECK SS$_NORMAL			; check success
	$DASSGN_S CHAN=W^MBCHANS		; deassign mailbox
	$ASSIGN_S DEVNAM=W^LOGNAMS1,-
		  CHAN  =W^MBCHANS		; try to reassign MBX
	CMPL	R0,#SS$_NORMAL			; is the MBX permanent?
	BEQL	10$				; br if yes
	BRB	20$				; print perm. MBX error
10$:
	MOVL	#1,W^CRE+CREMBX$_PRMFLG		; set prmflg for perm. MBX
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set the max. message size
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO	; set the buffer quota_G
	MOVAL	W^LOGNAMG1,W^CRE+CREMBX$_LOGNAM ; set the lognam
	$CREMBX_G W^CRE				; try _G form
	FAIL_CHECK SS$_NORMAL			; check success
	$DASSGN_S CHAN=W^MBCHANG		; deassign the channel
	$ASSIGN_S DEVNAM=W^LOGNAMG1,-
		  CHAN	=W^MBCHANG		; assign the mailbox
	CMPL	R0,#SS$_NORMAL			; is the MBX permanent?
	BEQL	30$				; br if yes
20$:
	PUSHAL	W^MSG1
	CALLS	#1,W^PRINT_FAIL			; print failure
30$:
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MBX
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
;+
;
; $DELMBX test
;
;-
	$ASSIGN_S DEVNAM=W^LOGNAMS1,-
		  CHAN	=W^MBCHANS		; reassign the mailbox_S
	MOVAL	W^DELMBX,W^SERV_NAME		; set service name
	PUSHL	#0
	CALLS	#1,W^REG_SAVE			; save the registers
	$DELMBX_S CHAN=W^MBCHANS		; delete the _S mailbox
	FAIL_CHECK SS$_NORMAL
	$ASSIGN_S DEVNAM=W^LOGNAMG1,-
		  CHAN  =W^MBCHANG		; reassign the mailbox_S
	MOVZWL	W^MBCHANG,W^DEL+DELMBX$_CHAN
	$DELMBX_G W^DEL				; delete the _G mailbox
	FAIL_CHECK SS$_NORMAL
;+
;
; Test MAXMSG low limit (1)
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set mode
	$CREMBX_S PRMFLG=#0,-
		  CHAN	=W^MBCHANS,-
		  MAXMSG=#LOMSG,-		; set the max. message size
		  BUFQUO=#BUF_SIZ_S,-		; set the buffer size
		  LOGNAM=W^LOGNAMS		; try _s form
	FAIL_CHECK SS$_NORMAL			; check success

        CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#LOMSG,W^CRE+CREMBX$_MAXMSG	; set the max. message size
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO	; set the buffer quota
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; move lognam in
	$CREMBX_G W^CRE				; try _g form
	FAIL_CHECK SS$_NORMAL			; check success
	$QIO_S	CHAN=W^MBCHANS,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#LOMSG			; write to the mailbox_S
	MOVC5	#0,W^MBX_BUF,#0,#256,W^MBX_BUF	; zero the MBX buffer
	$QIO_S	CHAN=W^MBCHANS,-
		FUNC=#IO$_READVBLK,-
		P1  =W^MBX_BUF,-
		P2  =#LOMSG			; read from the mailbox
	MOVAL	W^MBX_BUF,R6			; set the MBX buffer
	MOVAL	W^TEST_DATA,R7			; find the master data
	MOVL	#LOMSG,R8
	MOVW	W^MBCHANS,W^MBCHAN		; get the channel number
	CALLS	#0,W^BUF_CHECK			; check the data
	$DASSGN_S CHAN=W^MBCHANS		; deassign the channel
	$QIO_S	CHAN=W^MBCHANG,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#LOMSG			; write to the mailbox_G
	MOVC5	#0,W^MBX_BUF,#0,#1024,W^MBX_BUF	; zero the MBX buffer
	$QIO_S	CHAN=W^MBCHANG,-
		FUNC=#IO$_READVBLK,-
		P1  =W^MBX_BUF,-
		P2  =#LOMSG			; read from the mailbox
	MOVAL	W^MBX_BUF,R6			; set the MBX buffer
	MOVAL	W^TEST_DATA,R7			; find the master data
	MOVL	#LOMSG,R8
	MOVW	W^MBCHANG,W^MBCHAN		; get the channel number
	CALLS	#0,W^BUF_CHECK			; check the data
	$DASSGN_S CHAN=W^MBCHANG		; deassign the channel
;
; Test BUFQUO using BUFQUO = 256 using _S form
;		    BUFQUO = 512 using _G form
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set mode
	$CREMBX_S PRMFLG=#0,-
		  CHAN	=W^MBCHANS,-
		  MAXMSG=#MBBUF,-
		  BUFQUO=#BUF_SIZ_S,-
		  LOGNAM=W^LOGNAMS		; try _s
	FAIL_CHECK SS$_NORMAL			; check success
	CLRL	W^CRE+CREMBX$_PRMFLG
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set the max. message size
	MOVL	#BUF_SIZ_S*2,W^CRE+CREMBX$_BUFQUO ; set the buffer quota	
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM
	$CREMBX_G W^CRE				; try _G form
	FAIL_CHECK SS$_NORMAL			; check success
	$QIO_S	CHAN=W^MBCHANS,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#BUF_SIZ_S			; write to the mailbox_S
	MOVC5	#0,W^MBX_BUF,#0,#256,W^MBX_BUF	; zero the mailbox buffer
	$QIO_S	CHAN=W^MBCHANS,-
		FUNC=#IO$_READVBLK,-
		P1  =W^MBX_BUF,-
		P2  =#BUF_SIZ_S			; read from the mailbox_S
	MOVAL	W^MBX_BUF,R6			; set the MBX buffer
	MOVAL	W^TEST_DATA,R7			; find the master data
	MOVL	#BUF_SIZ_S,R8
	MOVW	W^MBCHANS,W^MBCHAN		; get the channel number
	CALLS	#0,W^BUF_CHECK			; check the data
	$DASSGN_S CHAN=W^MBCHANS		; deassign the channel
	MOVW	W^MBCHANS,W^MBCHAN		; get the channel number
	$QIO_S	CHAN=W^MBCHANG,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#BUF_SIZ_S*2		; write to the mailbox_G
	MOVC5	#0,W^MBX_BUF,#0,#512,W^MBX_BUF	; zero the mailbox buffer
	$QIO_S	CHAN=W^MBCHANG,-
		FUNC=#IO$_READVBLK,-
		P1  =W^MBX_BUF,-
		P2  =#BUF_SIZ_S*2		; read from the mailbox_G
	MOVAL	W^MBX_BUF,R6			; set the mailbox buffer
	MOVAL	W^TEST_DATA,R7			; find the master data
	MOVL	#BUF_SIZ_S*2,R8	
	MOVW	W^MBCHANG,W^MBCHAN		; get the channel number
	CALLS	#0,W^BUF_CHECK			; check the data
	$DASSGN_S CHAN=W^MBCHANG		; deassign the channel
;+
;
; Test PROMSK (protection mask)
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^UM,W^MODE			; set mode
	$CREMBX_S PRMFLG=#0,-
		  CHAN  =W^MBCHANS,-
		  MAXMSG=#MBBUF,-
		  BUFQUO=#BUF_SIZ_S,-
		  PROMSK=#^X3303,-
		  LOGNAM=LOGNAMS		; try _s form
	FAIL_CHECK SS$_NORMAL			; check success
	$GETCHN_S CHAN=W^MBCHANS,-
		  PRIBUF=W^MBCHAR		; get the MBX_S channel char.
	CMPW	#^X3303,W^MBCHR+DIB$W_VPROT
	BEQL	10$				; branch if O.K.
	PUSHL	W^MBCHR+DIB$W_VPROT
	PUSHL	#^X3303
	PUSHAL	W^PROT
	CALLS	#3,W^PRINT_FAIL			; print the error
10$:
	CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set max. message size
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO	; set the buffer quota
	MOVL	#^X3303,W^CRE+CREMBX$_PROMSK	; clear protection mask
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; set the lognam
	$CREMBX_G W^CRE				; try _g form
	FAIL_CHECK SS$_NORMAL			; check success
	$GETCHN_S CHAN=W^MBCHANG,-
		  PRIBUF=W^MBCHAR		; get MBX_G channel char.
	CMPW	#^X3303,W^MBCHR+DIB$W_VPROT	; CHECK PROMSK
	BEQL	20$				; BR if O.K.
	PUSHL	W^MBCHR+DIB$W_VPROT
	PUSHL	#^X3303
	PUSHAL	W^PROT
	CALLS	#3,W^PRINT_FAIL			; print the error
20$:
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MB
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
;+
;
; Test ACMODE (super mode)
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL W^SM,W^MODE			; declare super mode
	$CMKRNL_S W^SETUP_SUPER,W^ARGLST	; declare CHMS handler
	ADDL2	S^#EXE$C_CMSTKSZ+16,SP		; adjust user stack ptr.
	MOVL	SP,FP				; fix the FP
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
	CHMS	#1				; do the super tests
	CALLS	#0,W^ERLBUF_DUMP		; dump any errors
;+
;
; Test EXEC mode
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^EM,W^MODE			; declare exec mode
	$CMEXEC_S B^10$				; go to exec mode
	BRW	20$
10$:
	PUSHL	#0
	CALLS	#1,W^REG_SAVE			; save the registers
	$CREMBX_S PRMFLG=#0,-
		  CHAN	=W^MBCHANS,-
		  MAXMSG=#MBBUF,-		; set the max. message size
		  BUFQUO=#BUF_SIZ_S,-		; set the buffer quota
		  ACMODE=#PSL$C_EXEC,-		; set the access mode (super)
		  LOGNAM=W^LOGNAMS		; try _s form
	FAIL_CHECKNP SS$_NORMAL			; check success
	CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set the max. message size
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO ; set the buffer quota
	MOVL	#PSL$C_EXEC,W^CRE+CREMBX$_ACMODE ; move in ACMODE
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; set the lognam
	$CREMBX_G W^CRE				; try _G form
	FAIL_CHECKNP SS$_NORMAL			; check success
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MBX
	RET
20$:
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
;+
;
; Test KERNEL mode
;
;-
	NEXT_TEST
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	MOVAL	W^KM,W^MODE			; set mode
	$CMKRNL_S B^10$
	BRW	20$
10$:
	PUSHL	#0
	CALLS	#1,W^REG_SAVE			; save the registers
	$CREMBX_S PRMFLG=#0,-
		  CHAN	=W^MBCHANS,-
		  MAXMSG=#MBBUF,-
		  BUFQUO=#BUF_SIZ_S,-
		  ACMODE=#PSL$C_KERNEL,-
		  LOGNAM=W^LOGNAMS		; try _s form
	FAIL_CHECKNP SS$_NORMAL			; check success
	CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; get MAXMSG parameter
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO	; set the buffer quota
	MOVL	#PSL$C_KERNEL,W^CRE+CREMBX$_ACMODE ; move in ACMODE
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; set the lognam
	$CREMBX_G W^CRE				; try _g form
	FAIL_CHECKNP SS$_NORMAL			; check success
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MBX
	RET
20$:
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
;+
;
; Test USER mode
;
;-
	NEXT_TEST
	MOVAL	W^UM,W^MODE			; reset user mode
	MOVAL	W^CREMBX,W^SERV_NAME		; set service name
	$CREMBX_S PRMFLG=#0,-
		  CHAN	=W^MBCHANS,-
		  MAXMSG=#MBBUF,-
		  BUFQUO=#BUF_SIZ_S,-
		  ACMODE=#PSL$C_USER,-
		  LOGNAM=W^LOGNAMS		; try _S form
	FAIL_CHECK SS$_NORMAL			; check success
	CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set MAXMSG parameter
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO	; set the buffer quota
	MOVL	#PSL$C_EXEC,W^CRE+CREMBX$_ACMODE ; set the acmode
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; set the lognam
	$CREMBX_G W^CRE				; try _G form
	FAIL_CHECK SS$_NORMAL			; check success
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MBX
	CALLS	#0,W^ERLBUF_DUMP		; dump errors
	.SBTTL	FAIL CREMBX TESTS
;+++
;
; Test access violation for logical name
;
;---
	NEXT_TEST
	$CREMBX_S CHAN  =MBCHANS,-
		  LOGNAM=ZERO_ADDR_DESCR	; page zero		
	FAIL_CHECK SS$_ACCVIO			; check success
;+++
;
; Test access violation for channel number
;
;---
	NEXT_TEST
	$CREMBX_S CHAN  =0			; channel zero
	FAIL_CHECK SS$_ACCVIO			; check success
;+++
;
; Test invalid logical name descriptor
;
;---
	NEXT_TEST
	$CREMBX_S CHAN  =MBCHANS,-
		  LOGNAM=LEN_00_DESCR		; zero length name!
	FAIL_CHECK SS$_IVLOGNAM			; check success
;+++
;
; Test valid 63 character logical name descriptor
;		(CREMBX service prefixes 'MBX$' to the string!)
;
;---
	NEXT_TEST
	MOVB	#1,CREATED_FLAG			; assume it works
	$CREMBX_S CHAN  =MBCHAND,-
		  LOGNAM=LEN_63_DESCR		; 63 chars long	
	BLBS	R0,10$				; did it work?
	CLRB	CREATED_FLAG			; apparently not
10$:	FAIL_CHECK SS$_NORMAL			; check success
;+++
;
; Test DELMBX sys service invalid channel ( 0 )
;
;---
	NEXT_TEST
	MOVAL	DELMBX,SERV_NAME		; set service name
	$DELMBX_S CHAN = CHANNEL_ZERO
	FAIL_CHECK SS$_IVCHAN			; check int. failure
;+++
;
; Test DELMBX sys service invalid channel ( >#channels )
;
;---
	NEXT_TEST
	MOVW	MBCHAND,-(SP)			; save the channel #
	MOVW	@#CTL$GW_CHINDX,MBCHAND		; get max # channel
	ADDW2	#^X10,MBCHAND			; one nibble more
	$DELMBX_S CHAN = MBCHAND
	FAIL_CHECK SS$_IVCHAN			; check int. failure
	MOVW	(SP)+,MBCHAND			; get back the channel
;+++
;
; Test DELMBX sys service - delete one just created
;
;---
	TSTB	CREATED_FLAG			; not if it wasn't created
	BEQL	SKIP_DELETE
	NEXT_TEST
	$DELMBX_S CHAN = MBCHAND
	FAIL_CHECK SS$_NORMAL			; should be O.K.
SKIP_DELETE:
;+++
;
; Test DELMBX sys service - channel not assigned
;
;---
	NEXT_TEST
	$DASSGN_S CHAN = MBCHAND		; deassign the channel
	BLBS	R0,120$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:	$DELMBX_S CHAN = MBCHAND		; check int. failure
	FAIL_CHECK SS$_NOPRIV			; 'channel not assigned'
;+++
;
; Test DELMBX sys service - device not mailbox
;
;---
	NEXT_TEST
	$ASSIGN_S DEVNAM = SYS_DEV,-		; system disk assigned
		  CHAN = MBCHAND
	BLBS	R0,120$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:	$DELMBX_S CHAN = MBCHAND
	FAIL_CHECK SS$_DEVNOTMBX		; check int. failure
	$DASSGN_S CHAN = MBCHAND		; deassign SYS$SYSDEVICE
;+++
;
; Test no privilege for delete permanent mailbox
;
;---
	NEXT_TEST
	MOVB	#1,CREATED_FLAG			; assume it works
	$CREMBX_S PRMFLG=#1,-
		  CHAN  =MBCHAND
	BLBS	R0,120$				; Skip error report if OK
	CLRB	CREATED_FLAG			; it didn't work
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:
	TSTB	CREATED_FLAG			; was it created?
	BEQL	420$				; branch if not
	$SETPRV_S ENBFLG=#DISABLE,-		; disable perm privilege
		  PRVADR=PRM_PRV_MASK
	BLBS	R0,220$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
220$:
	$DELMBX_S CHAN=MBCHAND			; attempt deletion
	FAIL_CHECK SS$_NOPRIV			; should fail
	$SETPRV_S ENBFLG=#ENABLE,-		; re-enable perm privilege
		  PRVADR=PRM_PRV_MASK
	BLBS	R0,320$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
320$:
	$DELMBX_S CHAN=MBCHAND			; delete the mailbox
	BLBS	R0,420$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
420$:
;+++
;
; Test invalid logical name descriptor ( >63 characters )
;		(CREMBX service prefixes 'MBX$' to the string!);
;
;---
	NEXT_TEST
	MOVAL	CREMBX,SERV_NAME		; set service name
	$CREMBX_S CHAN  =MBCHANS,-
		  LOGNAM=LEN_64_DESCR		; >63 chars long	
	FAIL_CHECK SS$_IVLOGNAM			; check success
;+++
;
; Test logical name translation limit (=10)
;
;---
	NEXT_TEST
	PUSHR	#^M<R2>				; Save R2's contents
	CLRL	R2				; Set index variable
	MOVB	#^A/A/,EQUIV_NAME+4		; init equivalence name
	MOVB	#^A/B/,LOGIC_NAME+4		; init logical name
;
;	Create 9 levels of logical names ( MBX$NAMEB := NAMEA )
;		(10 translations)
;
10$:
	$CRELOG_S LOGNAM = D_MBX_LOGIC_NAME,-
		  TBLFLG = #2,-
		  EQLNAM = D_EQUIV_NAME		; Create a level of logical name
	BLBS	R0,120$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:	INCB	LOGIC_NAME+4			; Bump the logical name by one
	INCB	EQUIV_NAME+4			; Bump the equiv name by one
	AOBLSS	#9,R2,10$			; Make 9 levels
	POPR	#^M<R2>				; Restore R2
	DECB	LOGIC_NAME+4			; decrement due to loop incr
	$CREMBX_S CHAN  =MBCHANS,-
		  LOGNAM=D_LOGIC_NAME		; should be O.K.
	FAIL_CHECK SS$_NORMAL			; check success
;+++
;
; Test logical name translation too deep (>10)
;
;---
	NEXT_TEST
	INCB	LOGIC_NAME+4			; Bump the logical name by one
	$CRELOG_S LOGNAM = D_MBX_LOGIC_NAME,-
		  TBLFLG = #2,-
		  EQLNAM = D_EQUIV_NAME		; Create one more level
	BLBS	R0,120$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:	$CREMBX_S CHAN  =MBCHANS,-
		  LOGNAM=D_LOGIC_NAME		; should fail
	FAIL_CHECK SS$_TOOMANYLNAM		; check success
;+++
;
; Test no privilege for permanent mailbox
;
;---
	NEXT_TEST
	$SETPRV_S ENBFLG=#DISABLE,-
		  PRVADR=PRM_PRV_MASK		; disable perm privilege
	BLBS	R0,120$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:	$CREMBX_S PRMFLG=#1,-
		  CHAN  =MBCHANS
	FAIL_CHECK SS$_NOPRIV			; check success
;+++
;
; Test no privilege for temporary mailbox
;
;---
	NEXT_TEST
	$SETPRV_S ENBFLG=#DISABLE,-
		  PRVADR=TMP_PRV_MASK		; disable temp privilege
	BLBS	R0,120$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
120$:	$CREMBX_S CHAN  =MBCHANS
	FAIL_CHECK SS$_NOPRIV			; check success
	$SETPRV_S ENBFLG=#ENABLE,-		; re-enable privileges
		  PRVADR=TMP_PRM_PRV_MASK
	BLBS	R0,220$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
220$:

	CHMS	#2				; reset super mode handler to DCL
	TEST_END

.SBTTL	ROUTINES
.SBTTL SETUP_SUPER ROUTINE
;++
;
;	Routine to declare an initial CHMS handler from user mode.
;
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S W^SETUP_SUPER,ARGLST
;
;		ARGLST = address of a pointer to a one parameter argument list containing
;			 the address of the entry mask of the CHMS handler
;
; INPUT PARAMETERS:
;
;	ARGLST
;
; IMPLICIT INPUTS
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	Declares a change mode handler for super mode which must be
;	reset to DCL in the users handler routine when the handler is
;	no longer needed.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
; ON ENTRY:
;		       ---------	       ---------
;		KSP => !   0   !	USP => !       !
;		       !   0   !	       !  USER !
;		       !   AP  !	       !       !
;		       !   FP  !	       !  CALL !
;		       !   PC  !	       !       !
;		       !   0   !	       ! FRAME !
;		       !   0   !	       !       !
;		       !   AP  !	       ---------
;		       !   FP  !
;		       !SRVEXIT!
;		       !   PC  !
;		       !  PSL  !
;		       ---------
;--
.PAGE
RETURN_PC:
	.LONG	0			; storage for user return PC
HANDLER_PC:
	.LONG	0			; storage for handler PC
;
SETUP_SUPER:
	.WORD	^M<R2,R3>	
	MFPR	#PR$_USP,R3		; get the user call frame address
	MOVL	SF$L_SAVE_PC(R3),B^RETURN_PC ; get the user return PC
	MOVL	4(AP),HANDLER_PC	; save the handler address
	MOVL	SF$L_SAVE_FP(FP),R2	; get saved FP
	ADDL	S^#EXE$C_CMSTKSZ,R2	; back over change mode stack frame
	MOVAB	B^20$,(R2)		; set return address
	INSV	#<<PSL$C_SUPER@PSL$S_CURMOD>+PSL$C_SUPER>,-
		#PSL$V_PRVMOD,-
		#PSL$S_CURMOD*2,4(R2)	; set current and previous mode to super
	MOVL	S^#SS$_NORMAL,R0	; set correct return code
	RET				; enter super mode
20$:
	CLRL	-(SP)			; set up dummy PSL
	CALLG	(SP),B^30$		; create initial call frame
30$:
	.WORD	^M<>			; entry mask
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save the registers
	$DCLCMH_S @HANDLER_PC,W^PRVHND1,#0 ; set real handler
	FAIL_CHECKNP SS$_NORMAL		; check for success
	PUSHL	#<<PSL$C_USER@PSL$V_CURMOD>-
		!<PSL$C_USER@PSL$V_PRVMOD>>; set return to user
	PUSHL	RETURN_PC		; set the return PC
	REI				; return

.SBTTL SUPER_MODE
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to handle the CHMS instructions.
;
; CALLING SEQUENCE:
;	CHMS	#N
;
; INPUT PARAMETERS:
;	  SP=>	CHMS parameter
;		PC
;		PSL
;
;	  The CHMS parameter can be one of the following:
;
;		1 = execute $CREMBX (_S and _G form)
;		2 = execute a $DCLCMH_S to reset the CHMS handler to DCL
;
; OUTPUT PARAMETERS:
;	NONE
;--

SUPER_MODE:
	MOVL	(SP)+,R0			; get CHM parameter off the stack
	CASEB	R0,#1,#2			; do the right thing
10$:
	.WORD	20$-10$
	.WORD	A30-10$
20$:
	PUSHL	#0
	CALLS	#1,W^REG_SAVE			; save the registers
	$CREMBX_S PRMFLG=#0,-
		  CHAN  =W^MBCHANS,-
		  MAXMSG=#MBBUF,-
		  BUFQUO=#BUF_SIZ_S,-
		  ACMODE=#PSL$C_SUPER,-
		  LOGNAM=W^LOGNAMS		; try _s form
	FAIL_CHECKNP SS$_NORMAL			; check success
	CLRL	W^CRE+CREMBX$_PRMFLG		; make it temporary
	MOVL	#MBBUF,W^CRE+CREMBX$_MAXMSG	; set max. message size
	MOVL	#BUF_SIZ_G,W^CRE+CREMBX$_BUFQUO	; set the buffer quota
	MOVL	#PSL$C_SUPER,W^CRE+CREMBX$_ACMODE ; set the access mode
	MOVAL	W^LOGNAMG,W^CRE+CREMBX$_LOGNAM	; set the lognam
	$CREMBX_G W^CRE				; try _g form
	FAIL_CHECKNP SS$_NORMAL			; check success
	CALLS	#0,W^VERIFY_MBX			; read,write,verify,delete MBX
	BRB	A50				; get back to user mode
A30:
	MOVAL	W^DCLCMH,W^SERV_NAME		; set service name pointer
	$DCLCMH_S @PRVHND1,,#0			; reset the CHMS handler for DCL
	FAIL_CHECK SS$_NORMAL			; check for success
A50:
	REI					; return to user mode

	.SBTTL	ERLBUF_DUMP
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check for errors in the error log buffer and
;	report any that are there.
;
; CALLING SEQUENCE:
;	CALLS #0,W^ERLBUF_DUMP
;
; INPUT PARAMETERS:
;	FLAG bit 0 = 0 for no errors logged
;	FLAG bit 0 = 1 for errors logged
;	if errors logged then buffer ERLB must contain legal format errors
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

ERLBUF_DUMP:
	.WORD	^M<R2,R3,R4>
	BLBC	FLAG,30$	; br if no errors to report
	MOVAL	ERLB,R2		; set up buffer pointer
10$:
	TSTL	(R2)		; any more errors?
	BEQL	30$		; br if not
	MOVL	(R2)+,W^SERV_NAME ; reset service name
	MOVL	(R2)+,W^CURRENT_TC ; reset step #
	MOVL	(R2)+,W^MODE	; reset the mode
	MOVZBL	(R2)+,R3	; get the longword count
	MOVL	R3,R4		; and save it
20$:
	PUSHL	(R2)+		; push a parameter
	SOBGTR	R3,20$		; and push them all
	CALLS	R4,W^PRINT_FAIL	; print the failure
	BRB	10$		; do the next one
30$:
	MOVAL	W^ERLB,W^ELBP	; reset the buffer pointer
	CLRL	W^ERLB		; set fresh terminater
	RET			; bail out
.PAGE
	.SBTTL BUF_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check the contents of a buffer against known good 
;	data.
;
; CALLING SEQUENCE:
;	CALLS #0,W^BUF_CHECK		; check buffer
;
; INPUT PARAMETERS:
;	R6 = buffer address
;	R7 = good data address
;	R8 = byte count
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

BUF_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVL	R6,R9				; save a copy of the buffer address
	CMPC3	R8,(R7),(R6)			; check the buffer
	BEQL	10$				; br if good
	SUBL3	R9,R3,W^ARGLST1+8		; get buffer offset
	MOVZBL	(R1),W^ARGLST1+12		; get the good data
	$GETCHN_S CHAN  =W^MBCHAN,-
		  PRIBUF=W^PB			; get the unit number
	MOVZWL	W^PB+DIB$W_UNIT+8,W^ARGLST1+4	; get the unit number
	MOVZBL	(R3),W^ARGLST1+16		; get the bad data
	$GETMSG_S MSGID=#UETP$_DATAER,-
		  MSGLEN=W^ML,-
		  BUFADR=W^CTRSTR,-
		  FLAGS =#1			; get the ctrstr
	$FAOL_S	W^CTRSTR,W^ML,W^GETBUF,W^ARGLST1 ; make it readable
	CALLS	#0,W^STORE_STEP			; store error info.
	MOVL	W^ELBP,R2			; get error log buffer pointer
	MOVB	#1,(R2)+			; save longword count
	MOVAL	W^ML,(R2)+			; push desc. address
	CLRL	(R2)				; make a new terminator
	MOVL	R2,W^ELBP			; reset buffer pointer
10$:
	RET					; return
.PAGE
.SBTTL	VERIFY_MBX
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to write to a mailbox, read the data back, verify the
;	results and delete the mailbox.
;
; CALLING SEQUENCE:
;	CALLS	#1,W^VERIFY_MBX
;
; INPUT PARAMTERS
;
; OUTPUT PARAMETERS:
;	NONE
;
;--
VERIFY_MBX:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>	; entry mask
	$QIO_S	CHAN=W^MBCHANS,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#BUF_SIZ_S			; write to the mailbox_S
	MOVC5	#0,W^MBX_BUF,#0,#256,W^MBX_BUF	; zero the MBX buffer
	$QIO_S	CHAN=W^MBCHANS,-
		FUNC=#IO$_READVBLK,-
		P1  =W^MBX_BUF,-
		P2  =#BUF_SIZ_S			; read from the mailbox
	MOVAL	W^MBX_BUF,R6			; set the MBX buffer
	MOVAL 	W^TEST_DATA,R7			; find the master data
	MOVL	#BUF_SIZ_S,R8
	MOVW	W^MBCHANS,W^MBCHAN		; get the channel number
	CALLS	#0,W^BUF_CHECK			; check the data
	$DASSGN_S CHAN=W^MBCHANS		; deassign the channel
	$QIO_S	CHAN=W^MBCHANG,-
		FUNC=#IO$_WRITEVBLK,-
		P1  =W^TEST_DATA,-
		P2  =#BUF_SIZ_G 		; write to the mailbox_G
	MOVC5	#0,W^MBX_BUF,#0,#1024,W^MBX_BUF	; zero the MBX buffer
	$QIO_S	CHAN=W^MBCHANG,-
		FUNC=#IO$_READVBLK,-
		P1  =W^MBX_BUF,-
		P2  =#BUF_SIZ_G			; read from the mailbox
	MOVAL	W^MBX_BUF,R6			; set the MBX buffer
	MOVAL	W^TEST_DATA,R7			; find the master data
	MOVL	#BUF_SIZ_G,R8
	MOVW	W^MBCHANG,W^MBCHAN		; get the channel number
	CALLS	#0,W^BUF_CHECK			; check the data
	$DASSGN_S CHAN=W^MBCHANG		; deassign the channel
	RET

	.SBTTL STORE_STEP
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to store step information in the error log buffer.
;
; CALLING SEQUENCE:
;	CALLS #0,W^STORE_STEP
;
; INPUT PARAMETERS:
;	ELBP = current errlog buffer pointer
;
; OUTPUT PARAMETERS:
;	FLAG = error logged flag
;
;--

STORE_STEP:
	.WORD	^M<R2>
	BISB2	#1,W^FLAG			; set the error logged flag
	MOVL	W^ELBP,R2			; get errlog buf pntr
	MOVL	W^SERV_NAME,(R2)+		; save the service name
	MOVL	W^CURRENT_TC,(R2)+		; save the step number
	MOVL	W^MODE,(R2)+			; save the mode
	MOVL	R2,W^ELBP			; reset the errlog buf pntr
	RET					; return
.PAGE
	.SBTTL REG_SAVE
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to save R2-R11 in the register save location.
;
; CALLING SEQUENCE:
;	PUSHL	#0		; save a dummy parameter
;	CALLS	#1,W^REG_SAVE	; save R2-R11
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

REG_SAVE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; save the registers in the program
	RET

	.SBTTL	REG_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages printed using $PUTMSG
;
;--

REG_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0			; is this the right fail code?
	BEQL	10$				; br if yes
	PUSHL	R0				; push received data
	PUSHL	4(AP)				; push expected data
	PUSHAL	W^EXP				; push the string variable
	CALLS	#3,W^PRINT_FAIL			; print the error message
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; check all but R0
	BEQL	20$				; br if O.K.
	SUBL3	#REG_SAVE_AREA,R3,R6		; calculate the register number
	DIVL2	#4,R6
	ADDB3	#^X2,R6,-(SP)			; set number past R0-R1 and save
	BICL2	#3,R1				; backup to register boundrys
	BICL2	#3,R3
	PUSHL	(R1)				; push received data
	PUSHL	(R3)				; push expected data
	PUSHAL	W^REG				; set string pntr param.
	CALLS	#4,W^PRINT_FAIL			; print the error message
20$:
	RET

	.SBTTL REG_CHECKNP
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution without printing it. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed. This routine collects the error
;	information in buffer ERLB instead of printing it.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages logged in buffer ERLB which are printed
;	using routine ERLBUF_DUMP.
;
;	Error packets are in the following form:
;
;		!-----------------!
;		!Service name pntr!
;		!-----------------!
;		!     Step #	  !
;		!-----------------!
;		!Mode name pointer!
;		!-----------------!
;		!	      !   ! long word count
;		!-----------------!
;		!\/\/\/\/\/\/\/\/\! 3-4 parameter long words
;
;--

FLAG:
	.BYTE 0			; error flags are BIT0 = 0 means no errors in the buffer
				;		  BIT0 = 1 means errors in the buffer
ELBP:
	.ADDRESS ERLB		; error log buffer pointer
ERLB:
	.BLKB	1500		; error log buffer
;
REG_CHECKNP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0	; is this the right fail code
	BEQL	10$		; br if yes
	CALLS	#0,W^STORE_STEP	; store step information
	MOVL	ELBP,R2		; get the current error log pointer
	MOVB	#3,(R2)+	; save the long word count
	MOVL	R0,(R2)+	; save received status
	MOVL	4(AP),(R2)+	; save expected status
	MOVAL	W^EXP,(R2)+	; save the string variable
	CLRL	(R2)		; set the terminator
	MOVL	R2,ELBP		; reset the buffer pointer
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR ; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE ; set severity code
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA ; check all but R0 and R1
	BEQL	20$		; br if OK
	CALLS #0,W^STORE_STEP	; store step information
	MOVL	ELBP,R2		; get current error log buf pointer
	MOVB	S^#4,(R2)+	; set longword count
	SUBL3	#REG_SAVE_AREA,-
	R3,R6			; calc reg number
	DIVL2	S^#4,R6		; make it a longword count
	ADDL3	S^#2,R6,(R2)+	; correct for R0-R1 and save
	MOVL	(R1),(R2)+	; save received results
	MOVL	(R3),(R2)+	; save expected results
	MOVAL	W^REG,(R2)+	; save string variable
	CLRL	(R2)		; set the terminator
	MOVL	R2,ELBP		; reset the buffer pointer
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
20$:
	RET			; bail out

	.SBTTL NONSUB_SSE
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to report the failure of a system service which is not the
;	subject system service.
;
; CALLING SEQUENCE:
;	PUSHL	R0		; Save the failure status
;	CALLS	#1,NONSUB_SSE	; Print the failure message
;
; INPUT PARAMETERS:
;	4(AP) = Status code of failing system service
;
; OUTPUT PARAMETERS:
;	NONE
;
;--
NONSUB_SSE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	$GETMSG_S MSGID  = 4(AP),-
		  MSGLEN = BUFFER_PTR,-
		  BUFADR = BUFFER_PTR,-
		  FLAGS  = #1			; Get just the text of the message
	$FAO_S	CTRSTR = NSSSF,-
		OUTLEN = MESSAGE1L,-
		OUTBUF = MSG1L,-
		P1     = #BUFFER_PTR		; Format the failure message
	MOVW	#TEXT_BUFFER,BUFFER_PTR		; Reset the descriptor length
	PUSHAL	MESSAGE1L			; Push the string address
	CALLS	#1,PRINT_FAIL			; Print the failure
	RET
.PAGE
	.SBTTL	PRINT_FAIL
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to report failures using $PUTMSG
;
; CALLING SEQUENCE:
; Mode  #1	PUSHL EXPECTED	Mode    #2	PUSHL REG_NUMBER
;		PUSHL RECEIVED			PUSHL EXPECTED
;		PUSHAL STRING_VAR		PUSHL RECEIVED
;		CALLS #3,W^PRINT_FAIL		PUSHAL STRING_VAR
;						CALLS #4,W^PRINT_FAIL
; Mode	#3	PUSHAL STRING_VAR
;		CALLS #1,W^PRINT_FAIL
;
; INPUT PARAMETERS:
;	listed above
;
; OUTPUT PARAMETERS:
;	an error message is printed using $PUTMSG
;
;--

PRINT_FAIL:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	W^CS1,W^MESSAGEL,W^MSGL,#TEST_MOD_NAME,W^SERV_NAME,W^CURRENT_TC
	$PUTMSG_S W^MSGVEC			; print the message
	CMPB	(AP),#4				; is this a register message?
	BEQL	10$				; br if yes
	CMPB	(AP),#1				; is this just a message?
	BEQL	20$				; br if yes
	$FAO_S	W^CS2,W^MESSAGEL,W^MSGL,4(AP),8(AP),4(AP),12(AP)
	BRB	30$				; goto output message
10$:
	$FAO_S	W^CS3,W^MESSAGEL,W^MSGL,4(AP),16(AP),8(AP),4(AP),16(AP),12(AP)
	BRB	30$				; goto output message
20$:
	MOVL	4(AP),W^MSGVEC1+12		; save string address
	$PUTMSG_S W^MSGVEC1			; print the message
	BRB	40$				; skip the other message
30$:
	$PUTMSG_S W^MSGVEC			; print the message
40$:
	CALLS	#0,W^MODE_ID			; identify the mode
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
	RET
.PAGE
	.SBTTL	MODE_ID
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to identify the mode that an exit handler is in.
;
; CALLING SEQUENCE:
;	CALLS	#0,W^MODE_ID
;
; INPUT PARAMETERS:
;	MODE contains an address pointing to an ascii string desc.
;	of the current CPU mode.
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

MODE_ID:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	W^CS5,W^MESSAGEL,W^MSGL,MODE ; format the error message
	$PUTMSG_S W^MSGVEC		; print the mode message
	RET

.PAGE
MOD_MSG_PRINT:
;
;  *****************************************************************
;  *                                                               *
;  *  PRINTS THE TEST MODULE BEGUN/SUCCESSFUL/FAILED MESSAGES      *
;  *	   (USING THE PUTMSG MACRO).                               *
;  *                                                               *
;  *****************************************************************
;
	PUTMSG	<MOD_MSG_CODE,#2,TMN_ADDR,TMD_ADDR> ; PRINT MSG
	RSB				; ... AND RETURN TO CALLER
;
CHMRTN:
; ******************************************************************
; *								   *
; *	CHANGE MODE ROUTINE. THIS ROUTINE GETS CONTROL WHENEVER    *
; *	A CMKRNL, CMEXEC, OR CMSUP SYSTEM SERVICE IS ISSUED	   *
; *	BY THE MODE MACRO ('TO' OPTION).  IT MERELY DOES 	   *
; *	A JUMP INDIRECT ON A FIELD SET UP BY MODE. IT HAS 	   *
; *	THE EFFECT OF RETURNING TO THE END OF THE MODE		   *
; *	MACRO EXPANSION.					   *
; *								   *
; ******************************************************************
;
	.WORD	0			; ENTRY MASK
	JMP	@CHM_CONT		; RETURN TO MODE MACRO IN NEW MODE
;
; *	RET INSTR WILL BE ISSUED IN EXPANSION OF 'MODE FROM, ....' MACRO
;
	.END	SATSSS07
