	.TITLE UETSSMM00 VAX/VMS UETP SYSTEM SERVICE TEST
	.IDENT	'V03-002'
	.DEFAULT DISPLACEMENT,WORD
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SATS SYSTEM SERVICE TESTS
;
; ABSTRACT:	The UETSSMM00 module tests the execution of the following
;		VMS system services:
;
;		$CRMPSC
;		$DGBLSC
;		$MGBLSC
;		$UPDSEC
;
;
; ENVIRONMENT:	User, Supervisor and Executive mode image.
;		Needs SETPRV privilege and dynamically acquires other
;		privileges, as needed.  Privileges used are:
;
;		SYSGBL	SHMEM  SYSNAM PSWAPM
;		PRMGBL	PFNMAP CMEXEC
;
;--
;
; AUTHOR: Larry D. Jones,	CREATION DATE: August, 1981
;
; MODIFIED BY:
;
;	V03-002	LDJ0004		Larry D. Jones,		30-Mar-1982
;		Remove V02-002 because VMS reverted.
;
;	V03-001 LDJ0003		Larry D. Jones,		24-Mar-1982
;		Modified the PFNMAP PFN aquiring code to be more protected
;		against illegal PFN's returned from the exec.
;
;	V02-002	LDJ0002		Larry D. Jones,		18-Feb-1982
;		Modified STP11 to reflect a change in CRMPSC failure path.
;
;	V02-001	LDJ0001		Larry D. Jones,		17-Sep-1981
;		Added more tests and beefed up the error reporting and
;		detection.
;
;**

	.SBTTL	Declarations
;
; INCLUDE FILES:
;
;	SYS$LIBRARY:LIB.MLB	for general definitions
;	SHRLIB$:UETP.MLB	for UETP definitions

;
; MACROS:
;
	$CHFDEF				; Condition handler frame definitions
	$PHDDEF				; Process header definitions
	$PSLDEF				; PSL definitions
	$PRTDEF				; Protection definitions
	$PRVDEF				; Privilege bit definitions
	$PTEDEF				; Page Table Entry definitions
	$SECDEF				; Section definitions
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$UETPDEF			; UETP
;
; Equated symbols
;
	UETP$_TEXT = <<116@16>!SHR$_TEXT>
;
	EF2         = 2
	TEXT_BUFFER = 256
	SUCCESS	    = 1
	ERROR	    = 2
	EFN1        = 1
;
; MACROS
;

.PAGE
	.SBTTL	RO PSECT
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
;

TEST_MOD_NAME:
	.ASCIC	/UETSSMM00/		; Needed for SATSMS message

TEST_MOD_NAME_D:
	.ASCID /UETSSMM00/		; Module name

TEST_MOD_BEGIN:
	.ASCIC	/begun/			; Begin message

TEST_MOD_SUCC:
	.ASCIC	/successful/		; Success message

TEST_MOD_FAIL:
	.ASCIC	/failed/		; Failure message

CRMPSC:
	.ASCIC	/CRMPSC/		; System service names

DGBLSC:
	.ASCIC	/DGBLSC/

MGBLSC:
	.ASCIC	/MGBLSC/

UPDSEC:
	.ASCIC	/UPDSEC/

RMS_ERR_MSG:				; Announces an RMS error
	.ASCID	/RMS error in file !AD/
					; Failure messages
UPDSEC_FAILED:
	.ASCID	/$UPDSEC failed to modify the section file./

BAD_PFN:
	.ASCID	/Bad PFN returned by the exec. No PFNMAP testing done./
	
CS1:
	.ASCID	\Test !AC service name !AC step !UL failed.\

CS2:
	.ASCID	\Expected !AS = !XL received !AS = !XL\

CS3:
	.ASCID	\Expected !AS!UB = !XL received !AS!UB = !XL\

CS4:
	.ASCID	\Buffer offset was !XL\

CS5:
	.ASCID	\Mode was !AS.\

NSSSF:
	.ASCID	\Non-subject system service failure of : !/!_      !AS\

UM:					; CPU modes
	.ASCID	\user\

SM:
	.ASCID	\super\

EM:
	.ASCID	\executive\

KM:
	.ASCID	\kernal\

EXP:
	.ASCID	\status\

ZEROSTRING:				; Illegal length strings
	.ASCID	//

TOOLONGSTRING:
	.ASCID	/0123456789012345/

TTNAM:
	.ASCID	/TT/

REG:					; Output message variables
	.ASCID	\register R\

ADR:
	.ASCID	\address\

DATA:
	.ASCID	\data\

STATUS:
	.ASCID	\status\

MS:
	.ASCID	\mode\

MSGVEC:					; PUTMSG message vector
	.LONG	3
	.LONG	UETP$_TEXT
	.LONG	1
	.ADDRESS MESSAGEL

AN_ILLEGAL_IDENT:			; An illegal IDENT
	.QUAD	<SEC$K_MATLEQ+1>
.PAGE
;
	.SBTTL	R/W PSECT
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
;

TPID:
	.LONG	0			; PID for this process

TTCHAN:
	.WORD	0

CURRENT_TC:
	.LONG	0			; Ptr to current test case

MODE:
	.LONG	0			; Current mode string pointer

REGNUM:					; Register number
	.LONG	0

STATUS_CODE:				; Failure status code
	.LONG	0

ARG_COUNT:				; Storage for argument counts
	.LONG	0

MSGL:
	.LONG	TEXT_BUFFER		; Buffer desc.
	.ADDRESS BUF

BUF:
	.BLKB	TEXT_BUFFER

MESSAGEL:
	.LONG	0			; Message length
	.ADDRESS BUF

MSG1L:
	.LONG	TEXT_BUFFER		; Buffer #1 desc.
	.ADDRESS BUF1

BUF1:
	.BLKB	TEXT_BUFFER

MESSAGE1L:
	.LONG	0			; Message length
	.ADDRESS BUF1

SERV_NAME:
	.LONG	0			; Service name pointer

REG_SAVE_AREA:
	.BLKL	15			; Register save area

MOD_MSG_CODE:
	.LONG	UETP$_SATSMS		; Test module message code for putmsg

TMN_ADDR:
	.ADDRESS TEST_MOD_NAME

TMD_ADDR:
	.ADDRESS TEST_MOD_BEGIN

START_ADDRESS:				; Storage for buffer start address
	.LONG	0

WORK:
	.LONG	0			; Scratch long word

MSGVEC1:				; PUTMSG message vector
	.LONG	3
	.LONG	UETP$_TEXT
	.LONG	1
	.LONG	0

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS_CODE

UPD_IOSB:				; IOSB for the $UPDSEC
	.QUAD	0

CRMPSCG:				; Allocate space for _G parameters
	$CRMPSC

MGBLSCG:
	$MGBLSC

DGBLSCG:
	$DGBLSC

UPDSECG:
	$UPDSEC

AN_IDENT:				; A section identifier
	.QUAD 0

GSDNAM:					; Global section name
	.ASCID	/SSMMSEC/

PRIV_MASK:				; Privilege mask
	.QUAD	0

VBN:					; Storage for Virtual Block Number
	.LONG	0

OUTADDRESS:				; Address descriptors for sections
	.ADDRESS READ_BUF
	.ADDRESS READ_BUF

INADDRESS:
	.ADDRESS READ_BUF
	.ADDRESS READ_BUF

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

; The following two user defined symbols must remain contiguous.

LOGICAL_NAME:
	.LONG	9			; Logical name descriptors
	.ADDRESS .+4
	.ASCII	/GBL$NAME/
NAME_INC1:
	.BYTE	^A/B/

; The following two user defined symbols must remain contiguous.

EQUIV_NAME:
	.LONG	5
	.ADDRESS .+4
	.ASCII	/NAME/
NAME_INC2:
	.BYTE	^A/A/

GSD_LOGNAM:
	.ASCID	/NAMEL/


	.SBTTL RMS PSECT
	.PSECT RMS,PAGE

WRITE_BUF:				; 3 Page buffer on page boundary
	A = -1
	.REPT <512*3>/4
	.LONG A
	A = A-1
	.ENDR

	.ALIGN	PAGE

READ_BUF:
	.BLKB	512*3
	.BLKB	512			; End buffer bumper

	.ALIGN PAGE

READ_BUF1:
	.BLKB	512*3
	.BLKB	512			; End buffer bumper

	.ALIGN LONG

SECFAB:					; Section file FAB
	$FAB FNM=<UETPSECT.DAT>,-
	     FAC=<GET>,-
	     RAT=CR,-
	     FOP=UFO

FILEFAB:				; Section file creation FAB
	$FAB FNM = <UETPSECT.DAT>,-
	     FAC = <PUT,BIO>

FILERAB:				; Section file RAB
	$RAB FAB = FILEFAB,-
	     UBF = READ_BUF,-
	     USZ = 512,-
	     RBF = WRITE_BUF,-
	     RSZ = 512

.PAGE
	.SBTTL	UETSSMM00
	.PSECT	UETSSMM00,RD,WRT,EXE,LONG
;++
; FUNCTIONAL DESCRIPTION:
;
;	After performing some initial housekeeping, such as
; printing the module begin message and acquiring needed privileges,
; the system services are tested in each of their normal and failure
; conditions. Detected failures are identified and  an error message
; is printed on the terminal.  Upon completion of the test a success
; or fail message is printed on the terminal.
;
; CALLING SEQUENCE:
;
;	$ RUN UETSSMM00  ...  (DCL COMMAND)
;
; INPUT PARAMETERS:
;
;	none
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUT PARAMETERS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Messages to SYS$OUTPUT are the only output from UETSSMM00.
;	They are of the form:
;
;		%UETP-S-SATSMS, TEST MODULE UETSSMM00 BEGUN ... (BEGIN MSG)
;		%UETP-S-SATSMS, TEST MODULE UETSSMM00 SUCCESSFUL ... (END MSG)
;		%UETP-E-SATSMS, TEST MODULE UETSSMM00 FAILED ... (END MSG)
;		%UETP-I-TEXT, ... (VARIABLE INFORMATION ABOUT A TEST MODULE FAILURE)
;
; COMPLETION CODES:
;
;	The UETSSMM00 routine terminates with a $EXIT to the
;	operating system with a status code defined by UETP$_SATSMS.
;
; SIDE EFFECTS:
;
;	none
;
;--

	TEST_START UETSSMM00		; let the test begin

	.SBTTL	CRMPSC TESTS
;+
;
; $CRMPSC tests
;
; Test simplest case
;
;-

	STEP=0
	NEXT_TEST

	$DCLEXH_S DESBLK = EXIT_DESC		; Declare an exit handler
	MOVAL	UM,MODE				; Set the mode
	MOVAL	CRMPSC,SERV_NAME		; Set the service name
	$CRMPSC_S				; No inadr on non global section
	FAIL_CHECK SS$_ACCVIO
;+
;
; Test no inadr on non-permanent global section
;
;-

	NEXT_TEST

	$CRMPSC_S FLAGS = #SEC$M_GBL
	FAIL_CHECK SS$_ACCVIO
;+
;
; Test No read access on inadr
;
;-

	NEXT_TEST

	$CREATE	FAB = FILEFAB,-
		ERR = RMS_ERROR			; Create the data file
	$CONNECT RAB = FILERAB,-
		 ERR = RMS_ERROR		; Connect to the RAB
	$WRITE RAB = FILERAB,-
	       ERR = RMS_ERROR			; Write 3 pages of long word
						; unique data to the file
	$CLOSE FAB = FILEFAB,-
	       ERR = RMS_ERROR			; Close the file
	$OPEN	FAB = SECFAB,-
		ERR = RMS_ERROR			; Open the file to get a channel
	$SETPRT_S INADR = INADDRESS,-		; Set buffer protection
		  PROT  = #PRT$C_NA
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$CRMPSC_S INADR = READ_BUF,-
		  CHAN  = SECFAB+FAB$L_STV	; Try for accvio
	FAIL_CHECK SS$_ACCVIO
	$SETPRT_S INADR = INADDRESS,-		; Reset buffer protection
		  PROT  = #PRT$C_UW
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
;+
;
; Test inadr of system space address
;
;-

	NEXT_TEST

	MOVAL	^X80000000,INADDRESS		; Set a system space address
	MOVAL	^X80000000,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV
	FAIL_CHECK SS$_NOPRIV
;+
;
; Test virtual address space full
;
;-

	NEXT_TEST

	MOVAL	^X70000000,INADDRESS		; Set a P1 space address
	MOVAL	^X70000000,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV
	FAIL_CHECK SS$_VASFULL
	MOVAL	READ_BUF,INADDRESS		; Reset to P0 space address
	MOVAL	READ_BUF+^X1FF,INADDRESS+4
;+
;
; Test illegal address in retadr
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  RETADR= 1
	FAIL_CHECK SS$_ACCVIO
;+
;
; Test no write access for retadr
;
;-

	NEXT_TEST

	$SETPRT_S INADR = OUTADDRESS,-		; Set retadr protection
		  PROT  = #PRT$C_NA
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  RETADR= READ_BUF
	FAIL_CHECK SS$_ACCVIO
	$SETPRT_S INADR = OUTADDRESS,-		; Reset retadr protection
		  PROT  = #PRT$C_UW
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
;+
;
; Test no channel and no PFNMAP flag bit set
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = INADDRESS
	FAIL_CHECK SS$_IVSECFLG
;+
;
; Test chan and PFNMAP
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = INADDRESS,-
		  FLAGS = #SEC$M_PFNMAP,-
		  CHAN  = SECFAB+FAB$L_STV
	FAIL_CHECK SS$_IVSECFLG
;+
;
; Test illegal channel
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = #1
	FAIL_CHECK SS$_IVCHAN
;+
;
; Test non-file channel device
;
;-

	NEXT_TEST

	$CREMBX_S CHAN  = TTCHAN		; Make a no RND, FOD, DIR channel
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$CRMPSC_S INADR = INADDRESS,-		; Try it
		  CHAN  = TTCHAN
	FAIL_CHECK SS$_NOTFILEDEV
	$DASSGN_S CHAN  = TTCHAN		; Get rid of the mail box
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
	MOVC5	#0,READ_BUF,#0,#512+4,READ_BUF	; Clear the buffer and it's bumper
;+
;
; Create the simplest section. One page, user, temporary, P0, private, local memory,
; read only section.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-	; Create the temp P0 private read
		 INADR = INADDRESS		; local memory section
	FAIL_CHECK SS$_CREATED
	PUSHAL	INADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = INADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
;+
;
; Create the second simplest section. One page, user, temporary, P1, private, local memory,
; read only section. Introduce the use of RETADR and FLAGS.
;
;-

	NEXT_TEST

	MOVAL	-10000(SP),INADDRESS		; Put a P1 address in the inadr
	MOVAL	-10000-^X1FF(SP),INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
;+
;
; Test read/write section creation on a read only file.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT,-
		 INADR = INADDRESS
	FAIL_CHECK SS$_NOWRT
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$DASSGN_S CHAN = SECFAB+FAB$L_STV	; Deassign the read-only channel
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
	BISB2	#FAB$M_PUT,SECFAB+FAB$B_FAC	; Make the file read/write
	$OPEN	FAB = SECFAB,-
		ERR = RMS_ERROR			; Open the read/write channel
;+
;
; Create a one page user temporary P1 private local memory read/write section.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_WRT,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
;+
;
; Create a one page user temporary P0 private local memory read/write section.
;
;-

	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS		; Reset to a P0 address
	MOVAL	READ_BUF+^X1FF,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_WRT,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$DASSGN_S CHAN  = SECFAB+FAB$L_STV	; Deassign the channel to the old file
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
;+
;
; Create a three page user temporary P0 private local memory read/write section.
; INADR is specified in reverse order.
;
;-

	NEXT_TEST

	$ERASE FAB = FILEFAB,-
	       ERR = RMS_ERROR			; Delete old one page file
	MOVW	#<3*512>,FILERAB+RAB$W_RSZ	; Set 3 page size
	$CREATE FAB = FILEFAB,-
		ERR = RMS_ERROR			; Create a 3 page file
	$CONNECT RAB = FILERAB,-
		 ERR = RMS_ERROR		; Connect the RAB
	$WRITE RAB = FILERAB,-
	       ERR = RMS_ERROR			; Write 3 pages of incrementing data
	$CLOSE FAB = FILEFAB,-
	       ERR = RMS_ERROR			; Close the 3 page file
	$OPEN FAB = SECFAB,-
	      ERR = RMS_ERROR
	ADDL3	#^X400,INADDRESS+4,INADDRESS	; expand the input buffer size
	MOVAL	READ_BUF,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a three page user temporary P1 private local memory read/write section.
;
;-

	NEXT_TEST

	MOVAL	^X7F000000,INADDRESS		; Set P1 address up
	MOVAL	^X7F000000,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT!SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a two page user temporary P0 private local DZRO read/write section.
; INADR is specified in reverse order.
;
;-

	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS+4
	MOVAL	READ_BUF+<<512*2>-1>,INADDRESS
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT!SEC$M_DZRO,-
		 INADR = INADDRESS,-
		PAGCNT = #2,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#0				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	MOVC3	#<2*512>,WRITE_BUF,@<OUTADDRESS+4> ; Fix 2 DZRO pages
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a three page user temporary P1 private local DZRO read/write section.
;
;-

	NEXT_TEST

	MOVAL	^X70000000,INADDRESS
	MOVAL	^X70000000,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT!SEC$M_DZRO!SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#0				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	MOVC3	#<3*512>,WRITE_BUF,@OUTADDRESS	; Fix 3 DZRO pages
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a three page user temporary P1 private local CRF read/write section.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT!SEC$M_CRF!SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a two page user temporary P0 private local CRF read/write section.
;
;-

	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS
	MOVAL	READ_BUF+<512*2>,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT!SEC$M_CRF,-
		 INADR = INADDRESS,-
		PAGCNT = #2,-
		RETADR = OUTADDRESS
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a one page (by PAGCNT) user temporary P0 private local CRF 
; read/write section.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT!SEC$M_CRF,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #1
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a three page (by PAGCNT) user temporary P1 private local DZRO
; read/write section.
;
;-

	NEXT_TEST

	MOVAL	^X70000000,INADDRESS
	MOVAL	^X70000000,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_WRT!SEC$M_DZRO,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #3
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#0				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	MOVC3	#<3*512>,WRITE_BUF,@OUTADDRESS	; Fix 3 DZRO pages
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a three page (PAGCNT=4) user temporary P0 private local read only section.
;
;-

	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS
	MOVAL	READ_BUF+<512*4>,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #4
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a one page VBN 1 user temporary P0 private local read only section.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #1,-
		   VBN = #1
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#-1				; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a two page VBN 2 user temporary P1 private local read only section.
;
;-

	NEXT_TEST

	MOVAL	^X70000000,INADDRESS
	MOVAL	^X70000000,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #2,-
		   VBN = #2
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#<-1-128>			; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a three page VBN 3 user temporary P0 private local read only section.
;
;-

	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS
	MOVAL	READ_BUF+<512*3>,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #3,-
		   VBN = #3
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address quad word
	PUSHL	#<-1-<2*128>>			; Push start data value
	CALLS	#2,DATA_CHECK			; Check section data
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a one page VBN 4 user temporary P0 private local read only section.
;
;-

	NEXT_TEST

	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_EXPREG,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #1,-
		   VBN = #4
	FAIL_CHECK SS$_ENDOFFILE

;+
;
; Create a Supervisor section
;
;-

	NEXT_TEST

	MOVAL	SM,MODE			; Set the mode ID address

;+
;
; Create a Executive section
;
;-

	NEXT_TEST

	MOVAL	EM,MODE			; Set the mode ID address

;+
;
; Create a Kernal section
;
;-

	NEXT_TEST

	MOVAL	KM,MODE			; Set the mode ID address
	MOVAL	UM,MODE			; Set the mode ID address

;+
; Global section tests
;
; 0 length GSDNAM
;
;-

	NEXT_TEST

	$CRMPSC_S GSDNAM = ZEROSTRING,-
		   INADR = INADDRESS,-
		    CHAN = SECFAB+FAB$L_STV,-
		   FLAGS = #SEC$M_GBL
	FAIL_CHECK SS$_IVLOGNAM
;+
;
; GSDNAM too long (16 characters)
;
;-

	NEXT_TEST

	$CRMPSC_S GSDNAM = TOOLONGSTRING,-
		   INADR = INADDRESS,-
		    CHAN = SECFAB+FAB$L_STV,-
		   FLAGS = #SEC$M_GBL
	FAIL_CHECK SS$_IVLOGNAM
;+
;
; GSDNAM address unaccessable
;
;-

	NEXT_TEST

	$CRMPSC_S GSDNAM = 0,-
		   INADR = INADDRESS,-
		    CHAN = SECFAB+FAB$L_STV,-
		   FLAGS = #SEC$M_GBL
	FAIL_CHECK SS$_ACCVIO
;+
;
; Test no read access on GSDNAM
;
;-

	NEXT_TEST

	$CRMPSC_S GSDNAM = READ_BUF,-
		   INADR = INADDRESS,-
		    CHAN = SECFAB+FAB$L_STV,-
		   FLAGS = #SEC$M_GBL		; Try for accvio
	FAIL_CHECK SS$_ACCVIO
;+
;
; Test no read access on IDENT
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = OUTADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  FLAGS = #SEC$M_GBL,-
		 GSDNAM = GSDNAM,-
		  IDENT = READ_BUF
	FAIL_CHECK SS$_ACCVIO
;+
;
; Test 11 levels of logical name translation error
;
;-

	NEXT_TEST

	PUSHR	#^M<R2>				; Save it's contents
	CLRL	R2				; Set index variable
10$:
	$CRELOG_S LOGNAM = LOGICAL_NAME,-
		  TBLFLG = #2,-
		  EQLNAM = EQUIV_NAME		; Create a level of logical name
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
	INCB	NAME_INC1			; Bump the logical name by one
	INCB	NAME_INC2			; Bump the equiv name by one
	AOBLSS	#11,R2,10$			; Make 11 levels
	POPR	#^M<R2>				; Restore it
	$CRMPSC_S FLAGS = #SEC$M_GBL,-
		  INADR = INADDRESS,-
		   CHAN = SECFAB+FAB$L_STV,-
		 GSDNAM = GSD_LOGNAM
	FAIL_CHECK SS$_TOOMANYLNAM
	CLRL	R2				; Reset index variable
	DECB	NAME_INC1			; Back up to a legal name
40$:
	$DELLOG_S TBLFLG = #2,-
		  LOGNAM = LOGICAL_NAME		; Clean up process logical name table
	BLBS	R0,50$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
50$:
	DECB	NAME_INC1			; Bump the logical name
	AOBLSS	#11,R2,40$			; Eat all 11 levels
;+
;
; Test PRM GBL section creation without PRMGBL privilege
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  GSDNAM= GSDNAM,-
		  FLAGS = #SEC$M_PERM!SEC$M_GBL
	FAIL_CHECK SS$_NOPRIV
;+
;
; Create a one page user PRM GBL P0 local memory read write section.
;
;-

	NEXT_TEST

	MOVAL READ_BUF,INADDRESS		; Set the P0 address up
	MOVAL READ_BUF+512,INADDRESS+4
	INSV	#1,#PRV$V_PRMGBL,#1,PRIV_MASK	; Set the PRMGBL priv bit
	$SETPRV_S ENBFLG = #1,-
		  PRVADR = PRIV_MASK		; Get the PRMGBL priv
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  GSDNAM= GSDNAM,-
		  FLAGS = #SEC$M_GBL!SEC$M_WRT!SEC$M_PERM
	FAIL_CHECK SS$_CREATED
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	$DELTVA_S INADR  = INADDRESS		; Clean up the mess
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
;+
;
; Map to a one page user PRM GBL P0 local memory read only section.
;
;-

	NEXT_TEST

	ADDL2 #512,INADDRESS			; Set the P0 address up to
	ADDL2 #512,INADDRESS+4			; the next buffer page
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  GSDNAM= GSDNAM,-
		  FLAGS = #SEC$M_GBL
	FAIL_CHECK SS$_NORMAL
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	$DELTVA_S INADR  = INADDRESS		; Clean up the mess
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$DGBLSC_S GSDNAM = GSDNAM
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
	
;+
;
; Test negative RELPAG
;
;-

	NEXT_TEST

	$CRMPSC_S INADR = INADDRESS,-
		  FLAGS = #SEC$M_GBL!SEC$M_EXPREG,-
		   CHAN = SECFAB+FAB$L_STV,-
		 GSDNAM = GSD_LOGNAM,-
		 RELPAG = #-1
	FAIL_CHECK SS$_ENDOFFILE
;+
;
; Test RELPAG too large
;
;-

	NEXT_TEST
	$CRMPSC_S INADR = INADDRESS,-
		  FLAGS = #SEC$M_GBL!SEC$M_EXPREG,-
		   CHAN = SECFAB+FAB$L_STV,-
		 GSDNAM = GSD_LOGNAM,-
		 RELPAG = #5			; Only a three page section specified
	FAIL_CHECK SS$_ENDOFFILE
;+
;
; Test the offset definitions and the _G format of the system service.
;
;-

	NEXT_TEST
	PUSHR	#^M<R6>				; Save the register contents
	MOVAL	CRMPSCG,R6			; Save the parameter list address
	MOVAL	INADDRESS,CRMPSC$_INADR(R6) 	; Set the parameters up
	MOVAL	OUTADDRESS,CRMPSC$_RETADR(R6)
	MOVL	#PSL$C_USER,CRMPSC$_ACMODE(R6)
	MOVL	#SEC$M_EXPREG!SEC$M_GBL,-
		CRMPSC$_FLAGS(R6)
	MOVAL	GSDNAM,CRMPSC$_GSDNAM(R6)
	CLRQ	AN_IDENT
	MOVAL	AN_IDENT,CRMPSC$_IDENT(R6)
	MOVL	#1,CRMPSC$_RELPAG(R6)
	MOVL	SECFAB+FAB$L_STV,CRMPSC$_CHAN(R6)
	MOVL	#2,CRMPSC$_PAGCNT(R6)
	MOVL	#1,CRMPSC$_VBN(R6)
	MOVL	#0,CRMPSC$_PROT(R6)
	MOVL	#2,CRMPSC$_PFC(R6)
	POPR	#^M<R6>				; Restore register
	$CRMPSC_G CRMPSCG
	FAIL_CHECK SS$_CREATED			; Check the status
	PUSHAL	OUTADDRESS			; Check the data
	PUSHL	#-<<512/4>+1>
	CALLS	#2,DATA_CHECK
	$DELTVA_S INADR = OUTADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	$DGBLSC_S GSDNAM = GSDNAM
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:
;+
;
; Create a one page PRM GBL read only section in P0.
;
;-
	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS		; Set buffer address
	MOVAL	READ_BUF+511,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		   CHAN = SECFAB+FAB$L_STV,-
		 GSDNAM = GSDNAM,-
		  FLAGS = #SEC$M_GBL!SEC$M_PERM,-
		 PAGCNT = #2,-
		 RELPAG = #1			; Create the section
	FAIL_CHECK SS$_CREATED
	PUSHAL	INADDRESS			; Push address spec
	PUSHL	#-<<512/4>+1>			; Push expected data pattern
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = INADDRESS		; Leave section but remove the mapping
	BLBS	R0,10$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
10$:
	MOVAL	MGBLSC,SERV_NAME		; Set the new service name
	$MGBLSC_S GSDNAM = GSDNAM,-
		   INADR = INADDRESS		; Remap to the permanent global section
	FAIL_CHECK SS$_NORMAL			; Check the status
	PUSHAL	INADDRESS			; Push the address specifier
	PUSHL	#-1				; Push the data pattern specifier
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = INADDRESS		; Delete the mapping
	BLBS	R0,20$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
20$:
	MOVAL	DGBLSC,SERV_NAME		; Set the new service name
	$DGBLSC_S GSDNAM = GSDNAM		; Delete the section
	FAIL_CHECK SS$_NORMAL			; Check the status
	MOVAL	CRMPSC,SERV_NAME		; Set the new service name
;+
;
; Create a one page temp system global read only section in P1 space.
;
;-
	NEXT_TEST

	INSV	#1,#PRV$V_SYSGBL,#1,PRIV_MASK	; Set SYSGBL priv. bit
	INSV	#1,#PRV$V_SYSNAM,#1,PRIV_MASK	; Set SYSNAM priv. bit
	$SETPRV_S ENBFLG = #1,-
		  PRVADR = PRIV_MASK		; Get the SYSGBL and SYSNAM priv
	MOVAL	^X70000000,INADDRESS		; Set a P1 space address
	MOVL	INADDRESS,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		 RETADR = OUTADDRESS,-
		   CHAN = SECFAB+FAB$L_STV,-
		 GSDNAM = GSDNAM,-
		  FLAGS = #SEC$M_GBL!SEC$M_SYSGBL!SEC$M_EXPREG,-
		 PAGCNT = #2,-
		 RELPAG = #1			; Create the section
	FAIL_CHECK SS$_CREATED
	PUSHAL	OUTADDRESS			; Push address spec
	PUSHL	#-<<512/4>+1>			; Push expected data pattern
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = OUTADDRESS		; Leave section but remove the mapping
	BLBS	R0,10$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
10$:
;+
;
; Create a one page perm system global read only section in P0.
;
;-
	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS		; Set buffer address
	MOVAL	READ_BUF+511,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		   CHAN = SECFAB+FAB$L_STV,-
		 GSDNAM = GSDNAM,-
		  FLAGS = #SEC$M_GBL!SEC$M_PERM!SEC$M_SYSGBL,-
		 PAGCNT = #2,-
		 RELPAG = #1			; Create the section
	FAIL_CHECK SS$_CREATED
	PUSHAL	INADDRESS			; Push address spec
	PUSHL	#-<<512/4>+1>			; Push expected data pattern
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = INADDRESS		; Leave section but remove the mapping
	BLBS	R0,10$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
10$:
	MOVAL	MGBLSC,SERV_NAME		; Set the new service name
	$MGBLSC_S GSDNAM = GSDNAM,-
		   FLAGS = #SEC$M_SYSGBL,-
		   INADR = INADDRESS		; Remap to the permanent global section
	FAIL_CHECK SS$_NORMAL			; Check the status
	PUSHAL	INADDRESS			; Push the address specifier
	PUSHL	#-1				; Push the data pattern specifier
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = INADDRESS		; Delete the mapping
	BLBS	R0,20$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
20$:
	MOVAL	DGBLSC,SERV_NAME		; Set the new service name
	$DGBLSC_S GSDNAM = GSDNAM,-
		   FLAGS = #SEC$M_SYSGBL	; Delete the section
	FAIL_CHECK SS$_NORMAL			; Check the status
	MOVAL	CRMPSC,SERV_NAME		; Set the new service name
;+
;
;	PFNMAP tests
;
; Create a one page temp local memory P0 PFNMAP section
;
;-
	NEXT_TEST

	INSV	#1,#PRV$V_PFNMAP,#1,PRIV_MASK	; Set PFNMAP bit
	INSV	#1,#PRV$V_PSWAPM,#1,PRIV_MASK	; Set PSWAPM bit
	INSV	#1,#PRV$V_CMEXEC,#1,PRIV_MASK	; Set CMEXEC bit
	$SETPRV_S ENBFLG = #1,-			; Get the PFNMAP, PSWAPM and
		  PRVADR = PRIV_MASK		; CMEXEC privilege
	MOVAL	WRITE_BUF,INADDRESS		; Set up INADR
	MOVAL	WRITE_BUF+511,INADDRESS+4
	$LCKPAG_S INADR = INADDRESS		; Keep the target still
	$CMEXEC_S ROUTIN = 10$			; Get the physical address
	BRW	20$
10$:
	.WORD	^M<R2,R3,R4,R5>
	MOVL	@#CTL$GL_PHD,R5			; Set up Process Header Address
	MOVAL	PHD$L_P0BR(R5),R3		; Get base register address
	MOVAL	WRITE_BUF,R2			; Set up virtual address
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R1	; Extract the virtual page number
	MOVL	@(R3)[R1],R0			; Get the page table entry
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0	; Get the page frame number
	CMPL	G^MMG$GL_MAXPFN,R0		; Can this be right?
	BGEQU	12$				; BR if it is right
	MOVL	#SS$_BADPARAM,R0		; Signal a bad return from the exec
	BRB	14$				; and bail out of EXEC
12$:
	MOVL	R0,VBN				; Save the good PFN
	MOVL	#SS$_NORMAL,R0			; Clean exit
14$:
	RET
20$:
	BLBS	R0,25$				; BR if the PFN was aquired OK
	PUSHAL	BAD_PFN				; Report error message
	CALLS	#1,PRINT_FAIL
	JMP	NO_PFN_TEST			; Skip PFN testing
25$:
	MOVAL	READ_BUF,INADDRESS		; Set up INADR
	MOVAL	READ_BUF+511,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		  FLAGS = #SEC$M_PFNMAP,-
		    VBN = VBN,-
		 PAGCNT = #1
	FAIL_CHECK SS$_CREATED			; Check the status return
	PUSHAL	INADDRESS			; Push address of data
	PUSHL	#-1				; Push data pattern indicator
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = INADDRESS		; Delete the section
	BLBS	R0,30$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
30$:

;+
;
; Create a one page PERM local memory GBL P1 PFNMAP section
;
;-
	NEXT_TEST

	MOVAL	^X70000000,INADDRESS		; Set up INADR
	MOVAL	^X70000000,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		 RETADR = OUTADDRESS,-
		  FLAGS = #SEC$M_PFNMAP!SEC$M_GBL!SEC$M_EXPREG!SEC$M_PERM,-
		 GSDNAM = GSDNAM,-
		    VBN = VBN,-
		 PAGCNT = #1
	FAIL_CHECK SS$_CREATED			; Check the status return
	PUSHAL	OUTADDRESS			; Push address of data
	PUSHL	#-1				; Push data pattern indicator
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = OUTADDRESS		; Delete the section
	BLBS	R0,10$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
10$:
	MOVAL	DGBLSC,SERV_NAME		; Set the new service name
	$DGBLSC_S GSDNAM = GSDNAM		; Delete the section
	FAIL_CHECK SS$_NORMAL			; Check the status
	MOVAL	CRMPSC,SERV_NAME		; Set the new service name

;+
;
; Create a one page PERM local memory SYSTEM P1 PFNMAP section
;
;-
	NEXT_TEST

	MOVAL	^X70000000,INADDRESS		; Set up INADR
	MOVAL	^X70000000,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		 RETADR = OUTADDRESS,-
		  FLAGS = #SEC$M_PFNMAP!SEC$M_SYSGBL!SEC$M_EXPREG!SEC$M_PERM!SEC$M_GBL,-
		 GSDNAM = GSDNAM,-
		    VBN = VBN,-
		 PAGCNT = #1
	FAIL_CHECK SS$_CREATED			; Check the status return
	PUSHAL	OUTADDRESS			; Push address of data
	PUSHL	#-1				; Push data pattern indicator
	CALLS	#2,DATA_CHECK			; Check the data
	$DELTVA_S INADR = OUTADDRESS		; Delete the section
	BLBS	R0,10$				; Check the status return
	PUSHL	R0				; Push the error code
	CALLS	#1,NONSUB_SSE			; Report the failure
10$:
	MOVAL	DGBLSC,SERV_NAME		; Set the new service name
	$DGBLSC_S GSDNAM = GSDNAM,-
		   FLAGS = #SEC$M_SYSGBL	; Delete the section
	FAIL_CHECK SS$_NORMAL			; Check the status

NO_PFN_TEST:

	MOVAL	CRMPSC,SERV_NAME		; Set the new service name

	.SBTTL	MGBLSC TESTS
;+
;
; $MGBLSC tests
;
; Few steps exist in this section because the system code to create and map
; a section is the same code used for $MGBLSC. Only the MGBLSC unique parts
; are tested.
;
; Test simplest case
;
; Create the simplest section. One page, user, temporary, P0, global, local memory,
; read only section. This will be used as a target section to map to by the
; $MGBLSC.
;
;-

	NEXT_TEST

	MOVAL	READ_BUF,INADDRESS		; Set up inadr
	MOVAL	READ_BUF+512,INADDRESS+4
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  GSDNAM= GSDNAM,-
		  FLAGS = #SEC$M_GBL		; Create a target section
	FAIL_CHECK SS$_CREATED
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	MOVAL	UM,MODE				; Set the mode
	MOVAL	MGBLSC,SERV_NAME		; Set the service name
	MOVC5	#0,READ_BUF1,#0,#512*4,READ_BUF1 ; Init the second read buffer
	PUSHL	#0				; Push the argument
	CALLS	#1,REG_SAVE			; Save the register contents
	MOVAL READ_BUF1,INADDRESS		; Set the P0 address up
	MOVAL READ_BUF1+512,INADDRESS+4
	$MGBLSC_S GSDNAM = GSDNAM,-
		   INADR = INADDRESS
	FAIL_CHECK SS$_NORMAL
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	$DELTVA_S INADR = INADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Test mapping to a non-existant global section.
;
;-

	NEXT_TEST

	MOVB	#^A/L/,@<GSDNAM+4>		; Futs up the name
	$MGBLSC_S GSDNAM = GSDNAM,-
		   INADR = INADDRESS
	FAIL_CHECK SS$_NOSUCHSEC
	MOVB	#^A/S/,@<GSDNAM+4>		; Fix up the name

;+
;
; Test match control > SEC$K_MATLEQ
;
;-

	NEXT_TEST

	$MGBLSC_S INADR = INADDRESS,-
		 GSDNAM = GSDNAM,-
		  IDENT = AN_ILLEGAL_IDENT
	FAIL_CHECK SS$_IVSECIDCTL

;+
;
; Test match control SEC$K_MATEQU
;
;-

	NEXT_TEST

	MOVAL	DGBLSC,SERV_NAME		; Set the service name
	$DGBLSC_S GSDNAM = GSDNAM		; Delete old global section
	FAIL_CHECK SS$_NORMAL
	MOVAL	READ_BUF,INADDRESS		; Set up inadr
	MOVAL	READ_BUF+512,INADDRESS+4
	$DELTVA_S INADR = INADDRESS
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	MOVL	#^X8080000,AN_IDENT+4		; Set up an ident of MSB in
	MOVAL	CRMPSC,SERV_NAME		; Set the service name
	$CRMPSC_S INADR = INADDRESS,-
		  CHAN  = SECFAB+FAB$L_STV,-
		  GSDNAM= GSDNAM,-
		  IDENT = AN_IDENT,-
		  FLAGS = #SEC$M_GBL		; Create a target section with
						; an ident specified
	FAIL_CHECK SS$_CREATED
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	MOVAL	MGBLSC,SERV_NAME		; Set the service name
	MOVAL READ_BUF1,INADDRESS		; Set the P0 address up
	MOVAL READ_BUF1+512,INADDRESS+4
	MOVL	#SEC$K_MATEQU,AN_IDENT		; Set the match criteria
	$MGBLSC_S GSDNAM = GSDNAM,-
		   IDENT = AN_IDENT,-
		   INADR = INADDRESS
	FAIL_CHECK SS$_NORMAL
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	$DELTVA_S INADR = INADDRESS		; Clean up
	BLBS	R0,20$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
20$:

;+
;
; Test match control SEC$K_MATEQL failure to map cause of minor ident mismatch.
;
;-

	NEXT_TEST

	MOVL	#^X8040000,AN_IDENT+4		; Set up an ident with minor mismatch
	$MGBLSC_S INADR = INADDRESS,-
		 GSDNAM = GSDNAM,-
		  IDENT = AN_IDENT
	FAIL_CHECK SS$_NOSUCHSEC

;+
;
; Test match control SEC$K_MATEQL failure to map cause of major ident mismatch.
;
;-

	NEXT_TEST

	MOVL	#^X4080000,AN_IDENT+4		; Set up an ident with major
						; ident less
	$MGBLSC_S INADR = INADDRESS,-
		 GSDNAM = GSDNAM,-
		  IDENT = AN_IDENT
	FAIL_CHECK SS$_NOSUCHSEC

;+
;
; Test match control SEC$K_MATLEQ map with minor ident <.
;
;-

	NEXT_TEST

	MOVL	#SEC$K_MATLEQ,AN_IDENT		; Set the match criteria
	MOVL	#^X803FFFF,AN_IDENT+4		; Set up an ident with minor
						; ident less
	$MGBLSC_S INADR = INADDRESS,-
		 GSDNAM = GSDNAM,-
		  IDENT = AN_IDENT
	FAIL_CHECK SS$_NORMAL
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	$DELTVA_S INADR = INADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Test match control SEC$K_MATLEQ map with minor ident =.
;
;-

	NEXT_TEST

	MOVL	#^X8040000,AN_IDENT+4		; Set up an ident with minor
						; ident equal
	$MGBLSC_S INADR = INADDRESS,-
		 GSDNAM = GSDNAM,-
		  IDENT = AN_IDENT
	FAIL_CHECK SS$_NORMAL
	PUSHAL INADDRESS
	PUSHL	#-1
	CALLS	#2,DATA_CHECK			; Check the section data
	$DELTVA_S INADR = INADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
;+
;
; Test the offset definitions and the _G format of the system service.
;
;-

	NEXT_TEST
	PUSHR	#^M<R6>				; Save the register contents
	MOVAL	MGBLSCG,R6			; Save the parameter list address
	MOVAL	INADDRESS,MGBLSC$_INADR(R6) 	; Set the parameters up
	MOVAL	OUTADDRESS,MGBLSC$_RETADR(R6)
	MOVL	#PSL$C_USER,MGBLSC$_ACMODE(R6)
	MOVL	#SEC$M_GBL,-
		MGBLSC$_FLAGS(R6)
	MOVAL	GSDNAM,MGBLSC$_GSDNAM(R6)
	MOVAL	AN_IDENT,MGBLSC$_IDENT(R6)
	MOVL	#1,MGBLSC$_RELPAG(R6)
	POPR	#^M<R6>				; Restore register
	$MGBLSC_G MGBLSCG
	FAIL_CHECK SS$_NORMAL			; Check the status
	PUSHAL	INADDRESS			; Check the data
	PUSHL	#<-1-128>
	CALLS	#2,DATA_CHECK
	$DELTVA_S INADR = INADDRESS		; Clean up
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

;+
;
; Create a Supervisor section
;
;-

	NEXT_TEST

	MOVAL	SM,MODE			; Set the mode ID address

;+
;
; Create a Executive section
;
;-

	NEXT_TEST

	MOVAL	EM,MODE			; Set the mode ID address

;+
;
; Create a Kernal section
;
;-

	NEXT_TEST

	MOVAL	KM,MODE			; Set the mode ID address
	MOVAL	DGBLSC,SERV_NAME		; Set the service name
	$DGBLSC_S GSDNAM = GSDNAM		; Clean up the mess
	FAIL_CHECK SS$_NORMAL			; Check the status
	MOVAL	READ_BUF,INADDRESS		; Set up inadr
	MOVAL	READ_BUF+512,INADDRESS+4
	$DELTVA_S INADR = INADDRESS
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:

	.SBTTL	UPDSEC TESTS
;+
;
; $UPDSEC tests
;
; Test simplest case SS$_NOTMODIFIED
;
;-

	NEXT_TEST

	MOVAL	UM,MODE				; Set the mode
	MOVAL	CRMPSC,SERV_NAME		; Set the service name
	MOVAL	READ_BUF,INADDRESS		; Set the map limits
	MOVAL	READ_BUF+<512*3>-1,INADDRESS+4
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-
		 FLAGS = #SEC$M_WRT,-
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		PAGCNT = #3
	FAIL_CHECK SS$_CREATED
	MOVAL	UPDSEC,SERV_NAME		; Set the service name
	$UPDSEC_S INADR = INADDRESS,-
		 RETADR = OUTADDRESS,-
		 UPDFLG = #0
	FAIL_CHECK SS$_NOTMODIFIED
;+
;
; Test EFN with page modification
;
;-
	NEXT_TEST

	CLRL	READ_BUF + 512			; Modify a page
	$UPDSEC_S INADR = INADDRESS,-
		 RETADR = OUTADDRESS,-
		 UPDFLG = #0,-
		    EFN = #1,-
		   IOSB = UPD_IOSB
	FAIL_CHECK SS$_NORMAL
	BLBC	R0,10$				; Skip wait if failure occured
	$WAITFR_S EFN = #1			; Wait for I/O complete
	MOVZWL	UPD_IOSB,R0			; Get the return status code
	FAIL_CHECK SS$_NORMAL
	$DELTVA_S INADR = INADDRESS		; Unmap the section
	BLBS	R0,10$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
10$:
	MOVAL	CRMPSC,SERV_NAME		; Set the service name
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-	; Remap the section
		 FLAGS = #SEC$M_WRT,-
		 INADR = INADDRESS,-
		PAGCNT = #3
	FAIL_CHECK SS$_CREATED
	MOVAL	UPDSEC,SERV_NAME		; Set the service name
	TSTL	READ_BUF + 512			; Check for the modification
	BEQL	20$
	PUSHAL	UPDSEC_FAILED			; Push the failure message
	CALLS	#1,PRINT_FAIL			; And print it
20$:
;+
;
; Test ASTADR and ASTPRM arguments
;
;-
	NEXT_TEST

	MOVL	#<-1-128>,READ_BUF+512		; Modify a page
	$SETAST_S ENBFLG = #0			; Disable AST's for error checking
	$UPDSEC_S INADR = INADDRESS,-
		 RETADR = OUTADDRESS,-
		 UPDFLG = #0,-
		    EFN = #1,-
		 ASTADR = 20$,-
		 ASTPRM = #3,-
		   IOSB = UPD_IOSB
	FAIL_CHECK SS$_NORMAL
	$SETAST_S ENBFLG = #1			; OK checking done go ahead and AST
	BLBS	R0,10$				; Skip to wait if no failure occured
	BRW	50$				; Else skip the wait
10$:
	$HIBER_S				; Wait for AST
	BRW	50$				; Skip over AST routine
20$:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	PUSHL	#0				; Push a dummy parameter
	CALLS	#1,REG_SAVE			; Save the registers
	CMPL	4(AP),#3			; Did the parameter get here?
	BEQL	30$				; BR if yes
	PUSHL	4(AP)				; Push received
	PUSHL	#3				; Push expected
	PUSHAL	DATA				; Push string address
	CALLS	#3,PRINT_FAIL			; Report the failure
30$:
	MOVZWL	UPD_IOSB,R0			; Get the return status code
	FAIL_CHECK SS$_NORMAL
	$DELTVA_S INADR = INADDRESS		; Unmap the section
	BLBS	R0,40$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
40$:
	MOVAL	CRMPSC,SERV_NAME		; Set the service name
	$CRMPSC_S CHAN = SECFAB+FAB$L_STV,-	; Remap the section
		 FLAGS = #SEC$M_WRT,-
		 INADR = INADDRESS,-
		PAGCNT = #3
	FAIL_CHECK SS$_CREATED
	MOVAL	UPDSEC,SERV_NAME		; Set the service name
	PUSHAL	INADDRESS			; Check the data
	PUSHL	#-1
	CALLS	#2,DATA_CHECK
	$WAKE_S					; Carry on
	RET
50$:
;+
;
; Test the offset definitions and the _G format of the system service.
;
;-

	NEXT_TEST
	PUSHR	#^M<R6>				; Save the register contents
	MOVAL	UPDSECG,R6			; Save the parameter list address
	MOVL	#-1,READ_BUF			; Modify a page
	MOVAL	INADDRESS,UPDSEC$_INADR(R6) 	; Set the parameters up
	MOVAL	OUTADDRESS,UPDSEC$_RETADR(R6)
	MOVL	#PSL$C_USER,UPDSEC$_ACMODE(R6)
	MOVL	#1,UPDSEC$_UPDFLG(R6)
	MOVL	#EFN1,UPDSEC$_EFN(R6)
	MOVAL	UPD_IOSB,UPDSEC$_IOSB(R6)
	MOVAL	20$,UPDSEC$_ASTADR(R6)
	MOVL	#100,UPDSEC$_ASTPRM(R6)
	POPR	#^M<R6>				; Restore register
	$SETAST_S ENBFLG = #0			; Disable AST's for fail check
	$UPDSEC_G UPDSECG
	FAIL_CHECK SS$_NORMAL			; Check the status
	$SETAST_S ENBFLG = #1			; OK done checking go ahead and AST
	BLBS	R0,10$				; BR if service request OK...
	BRW	50$				; ...else skip the I/O wait
10$:
	$HIBER_S				; Wait for I/O complete
	BRW	50$				; Skip the AST routine
20$:
	.WORD	0				; AST entry point for $UPDSEC
	PUSHL	#0				; Push a dummy argument
	CALLS	#1,REG_SAVE			; Save the register contents
	CMPL	4(AP),#100			; Correct AST parmeter?
	BEQL	30$				; BR if OK
	PUSHL	4(AP)				; Push received
	PUSHL	#100				; Push expected
	PUSHAL	DATA				; Push string address
	CALLS	#3,PRINT_FAIL			; Report the failure
30$:
	BLBS	UPD_IOSB,40$			; Check IO status returned
	PUSHL	UPD_IOSB			; Push received
	PUSHL	#SS$_NORMAL			; Push expected
	PUSHAL	STATUS				; Push string address
	CALLS	#3,PRINT_FAIL			; Report the failure
40$:
	$WAKE_S					; Exit the HIBER
	RET
50$:
	$DELTVA_S INADR = INADDRESS		; Delete the address space
	BLBS	R0,60$				; Skip error report if OK
	PUSHL	R0				; Save error code
	CALLS	#1,NONSUB_SSE			; Print the failure
60$:

;+
;
; Create a Supervisor section
;
;-

	NEXT_TEST

	MOVAL	SM,MODE			; Set the mode ID address

;+
;
; Create a Executive section
;
;-

	NEXT_TEST

	MOVAL	EM,MODE			; Set the mode ID address

;+
;
; Create a Kernal section
;
;-

	NEXT_TEST

	MOVAL	KM,MODE			; Set the mode ID address


	.SBTTL	DGBLSC TESTS
;+
;
; $DGBLSC tests
;
; Few cases exist in this section because most of the cases are tested in
; the $CRMPSC section of this program.
;
; Test SS$_NOSUCHSEC
;
;-

	NEXT_TEST

	MOVAL	UM,MODE				; Set the mode
	MOVAL	DGBLSC,SERV_NAME		; Set the service name
	$DGBLSC_S GSDNAM = GSD_LOGNAM		; Try a non-existent section
	FAIL_CHECK SS$_NOSUCHSEC		; Check failure code
	TEST_END
	$EXIT_S

	.SBTTL REG_SAVE
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to save R2-R11 in the register save location.
;
; CALLING SEQUENCE:
;	PUSHL	#0		; save a dummy parameter
;	CALLS	#1,W^REG_SAVE	; save R2-R11
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

REG_SAVE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; save the registers in the program
	RET

	.SBTTL	REG_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages printed using $PUTMSG
;
;--

REG_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0			; is this the right fail code?
	BEQL	10$				; br if yes
	PUSHL	R0				; push received data
	PUSHL	4(AP)				; push expected data
	PUSHAL	W^EXP				; push the string variable
	CALLS	#3,W^PRINT_FAIL			; print the error message
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; check all but R0
	BEQL	20$				; br if O.K.
	SUBL3	#REG_SAVE_AREA,R3,R6		; calculate the register number
	DIVL2	#4,R6
	ADDB3	#^X2,R6,W^REGNUM		; put it in the string
	BICL2	#3,R1				; backup to register boundrys
	BICL2	#3,R3
	PUSHL	W^REGNUM				; push register number
	PUSHL	(R1)				; push received data
	PUSHL	(R3)				; push expected data
	PUSHAL	W^REG				; set string pntr param.
	CALLS	#4,W^PRINT_FAIL			; print the error message
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
20$:
	RET

	.SBTTL	PRINT_FAIL
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to report failures using $PUTMSG
;
; CALLING SEQUENCE:
; Mode  #1	PUSHL EXPECTED	Mode    #2	PUSHL REG_NUMBER
;		PUSHL RECEIVED			PUSHL EXPECTED
;		PUSHAL STRING_VAR		PUSHL RECEIVED
;		CALLS #3,W^PRINT_FAIL		PUSHAL STRING_VAR
;						CALLS #4,W^PRINT_FAIL
; Mode	#3	PUSHAL STRING_VAR
;		CALLS #1,W^PRINT_FAIL
;
; INPUT PARAMETERS:
;	listed above
;
; OUTPUT PARAMETERS:
;	an error message is printed using $PUTMSG
;
;--

PRINT_FAIL:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	CTRSTR = CS1,-
		OUTLEN = MESSAGEL,-
		OUTBUF = MSGL,-
		P1     = #TEST_MOD_NAME,-
		P2     = SERV_NAME,-
		P3     = CURRENT_TC
	$PUTMSG_S MSGVEC = MSGVEC		; print the message
	CMPB	(AP),#4				; is this a register message?
	BEQL	10$				; br if yes
	CMPB	(AP),#1				; is this just a message?
	BEQL	20$				; br if yes
	$FAO_S	CTRSTR = CS2,-
		OUTLEN = MESSAGEL,-
		OUTBUF = MSGL,-
		P1     = 4(AP),-
		P2     = 8(AP),-
		P3     = 4(AP),-
		P4     = 12(AP)
	BRB	30$				; goto output message
10$:
	$FAO_S	CTRSTR = CS3,-
		OUTLEN = MESSAGEL,-
		OUTBUF = MSGL,-
		P1     = 4(AP),-
		P2     = 16(AP),-
		P3     = 8(AP),-
		P4     = 4(AP),-
		P5     = 16(AP),-
		P6     = 12(AP)
	BRB	30$				; goto output message
20$:
	MOVL	4(AP),MSGVEC1+12		; save string address
	$PUTMSG_S MSGVEC = MSGVEC1		; print the message
	BRB	40$				; skip the other message
30$:
	$PUTMSG_S MSGVEC = MSGVEC		; print the message
40$:
	CALLS	#0,MODE_ID			; identify the mode
	MOVAL	TEST_MOD_FAIL,TMD_ADDR		; set failure message address
	INSV	#ERROR,#0,#3,MOD_MSG_CODE	; set severity code
	RET
.PAGE
	.SBTTL	MODE_ID
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to identify the mode that an exit handler is in.
;
; CALLING SEQUENCE:
;	CALLS	#0,W^MODE_ID
;
; INPUT PARAMETERS:
;	MODE contains an address pointing to an ascii string desc.
;	of the current CPU mode.
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

MODE_ID:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	CTRSTR = CS5,-
		OUTLEN = MESSAGEL,-
		OUTBUF = MSGL,-
		P1     = MODE 		; format the error message
	$PUTMSG_S MSGVEC = MSGVEC	; print the mode message
	RET

	.SBTTL	DATA_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check the data pattern used in the sections.
;
; CALLING SEQUENCE:
;	PUSHAL	INADR
;	PUSHL	FIRST_VALUE
;	CALLS	#2,DATA_CHECK
;
; INPUT PARAMETERS:
;	8(AP) = A quad word containing the first address and the last address
;		of the buffer to be checked.
;	4(AP) = First value which should be stored in the buffer. If this value
;		is non-zero the data pattern is assumed to be a decrementing
;		longword count pattern.  If it is zero the data is assumed to
;		be DZRO.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 = SS$_NORMAL if data was correct.
;	R0 = 0 if data was incorrect.
;
; SIDE EFFECTS:
;	Error message is printed if a failure occured.
;
;--

DATA_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	MOVL	8(AP),R3		; Get the address of the address quadword
	MOVL	4(R3),R4		; Get the ending address
	MOVL	(R3),R3			; Get the starting address
	CMPL	R3,R4			; Which order are the address in
	BLEQ	10$			; Br if inorder or equal
	MOVL	R3,R5			; Otherwise swap them around
	MOVL	R4,R3			; To get the right end data
	MOVL	R5,R4
10$:
	MOVL	R3,START_ADDRESS	; Save the lower address
	MOVL	4(AP),R2		; Get the starting data value
	BEQL	30$			; BR if data pattern of zero
	SUBL3	R3,R4,R5		; Calculate the byte difference
	DIVL2	#4,R5			; Calculate the longword difference
	SUBL3	R5,R2,R5		; Subtract the start value bias
20$:
	CMPL	(R3)+,R2		; Check the data
	BNEQ	40$			; Br if data is bad
	DECL	R2			; Do all of the longwords
	CMPL	R2,R5			; All done?
	BNEQ	20$			; BR if not
	MOVL	#SS$_NORMAL,R0		; Set success status if OK
	RET
30$:
	CMPL	(R3)+,#0		; Check for zeroed data
	BNEQ	40$			; BR if bad
	CMPL	R3,R4			; End of data to check?
	BLSS	30$			; BR if not
	RET
40$:
	PUSHL	-4(R3)			; Push bad data value
	PUSHL	R2			; Push good data value
	PUSHAL	DATA			; Push failure type name	
	CALLS	#3,PRINT_FAIL		; Report the failure
	SUBL3	START_ADDRESS,R3,R3	; Get the buffer offset
	SUBL2	#4,R3			; Compensate for auto inc
	$FAO_S	CTRSTR = CS4,-
		OUTLEN = MESSAGEL,-
		OUTBUF = MSGL,-
		P1     = R3 		; format the error message
	$PUTMSG_S MSGVEC = MSGVEC	; print the offset message
	CLRL	R0			; Set failure return
	RET


	.SBTTL NONSUB_SSE
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to report the failure of a system service which is not the
;	subject system service.
;
; CALLING SEQUENCE:
;	PUSHL	R0		; Save the failure status
;	CALLS	#1,NONSUB_SSE	; Print the failure message
;
; INPUT PARAMETERS:
;	4(AP) = Status code of failing system service
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

NONSUB_SSE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	$GETMSG_S MSGID  = 4(AP),-
		  MSGLEN = BUFFER_PTR,-
		  BUFADR = BUFFER_PTR,-
		  FLAGS  = #1			; Get just the text of the message
	$FAO_S	CTRSTR = NSSSF,-
		OUTLEN = MESSAGE1L,-
		OUTBUF = MSG1L,-
		P1     = #BUFFER_PTR		; Format the failure message
	MOVW	#TEXT_BUFFER,BUFFER_PTR		; Reset the descriptor length
	PUSHAL	MESSAGE1L			; Push the string address
	CALLS	#1,PRINT_FAIL			; Print the failure
	RET

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	The FAB or RAB associated with the RMS call.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS_CODE ; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS_CODE ; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get the file name size
	$FAO_S	CTRSTR = RMS_ERR_MSG,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; Push the string address
	CALLS	#1,PRINT_FAIL		; Print the failure
	RET

MOD_MSG_PRINT:
;
;  *****************************************************************
;  *                                                               *
;  *  PRINTS THE TEST MODULE BEGUN/SUCCESSFUL/FAILED MESSAGES      *
;  *	   (USING THE PUTMSG MACRO).                               *
;  *                                                               *
;  *****************************************************************
;
	PUTMSG	<MOD_MSG_CODE,#2,TMN_ADDR,TMD_ADDR> ; PRINT MSG
	RSB				; ... AND RETURN TO CALLER

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup on exits.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	Location STATUS_CODE contains the exit status
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Erase the UETPSECT.DAT file even if the test is aborted.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$DASSGN_S CHAN = SECFAB+FAB$L_STV	; Deassign the channel
	$ERASE  FAB = FILEFAB,-
		ERR = RMS_ERROR			; Erase the old section file
	$SETPRV_S ENBFLG = #0,-
		  PRVADR = PRIV_MASK		; Remove all temp privileges
	RET					; That's all folks!
	.END UETSSMM00
