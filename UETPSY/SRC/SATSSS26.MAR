	.TITLE	SATSSS26 - SATS SYSTEM SERVICE TESTS  (SUCC S.C.)
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SATS SYSTEM SERVICE TESTS
;
; ABSTRACT:	The SATSSS26 module tests the execution of the following
;		VMS system services:
;
;		$DCLAST
;		$SETAST
;		$CANTIM
;		$SETIMR
;		$SETPRA
;
;
; ENVIRONMENT:	User, Supervisor, Executive, and Kernal mode image.
;		Needs CMKRNL privilege and dynamically acquires other
;		privileges, as needed.
;
; AUTHOR: THOMAS L. CAFARELLA,		CREATION DATE: MMM, 1978
;	  PAUL D. FAY (DISPSERV & TESTSERV MACROS)
;
; MODIFIED BY:
;
;	V03-003	LDJ0002		Larry D. Jones,		29-Apr-1981
;		Modified to do all AST checking in non-user mode correctly.
;
;	V03-002	RNP0001		Robert N. Perron,	6-APR-1981
;		Modified to correct hang problem and correct error reporting.
;
;	V03-001	LDJ0001		Larry D. Jones,		17-Sep-1980
;		Modified to conform to new build command procedures.
;**
;--
.PAGE
	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
	$PRDEF				; processor register definitions
	$PRVDEF				; privilege definitions
	$PSLDEF				; PSL definitions
	$SFDEF				; Stack Frame definitions
	$SHR_MESSAGES UETP,116,<<TEXT,INFO>> ; UETP$_TEXT definition
	$STSDEF				; STS definitions
	$UETPDEF			; UETP message definitions
;
; Equated symbols
;
WARNING		= 0			; warning severity value for msgs
SUCCESS		= 1			; success     "      "    "   "
ERROR		= 2			; error       "      "    "   "
INFO		= 3			; information "      "    "   "
SEVERE		= 4			; fatal       "      "    "   "

.PAGE
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
;
DUMMY:					; dummy handler routine address
TEST_MOD_NAME:
	.ASCIC	/SATSSS26/		; needed for SATSMS message
TEST_MOD_NAME_D:
	.ASCID	/SATSSS26/		; module name
TEST_MOD_BEGIN:
	.ASCIC	/begun/
TEST_MOD_SUCC:
	.ASCIC	/successful/
TEST_MOD_FAIL:
	.ASCIC	/failed/
DCLCMH:
	.ASCIC	/DCLCMH/
DCLAST:
	.ASCIC	/DCLAST/
SETAST:
	.ASCIC	/SETAST/
SETIMR:
	.ASCIC	/SETIMR/
CANTIM:
	.ASCIC	/CANTIM/
SETPRA:
	.ASCIC	/SETPRA/
CS1:
	.ASCID	\Test !AC service name !AC step !UL failed.\
CS2:
	.ASCID	\Expected !AS = !XL received !AS = !XL\
CS3:
	.ASCID	\Expected !AS!UB = !XL received !AS!UB = !XL\
CS4:
	.ASCID	\Unexpected AST occured.\
CS5:
	.ASCID	\Mode was !AS.\
CS6:
	.ASCID	\Required AST did not occur.\
CS7:
	.ASCID	\Unexpected timer AST occured.\
CS8:
	.ASCID	\Unexpected AST!\
ASTPRM:
	.ASCID	\AST parameter\
EXP:
	.ASCID	\status\
ADR:
	.ASCID	\address\
MS:
	.ASCID	\mode\
UM:
	.ASCID	\user\
SM:
	.ASCID	\super\
EM:
	.ASCID	\executive\
KM:
	.ASCID	\kernel\
ARGLST:
	.LONG	1			; super mode setup arg list
	.ADDRESS SUPER_MODE
MSGVEC:					; PUTMSG message vector
	.LONG	3
	.LONG	UETP$_TEXT
	.LONG	1
	.ADDRESS MESSAGEL
ONE_SEC:
	.LONG	10*1000*1000		; one second
DELTA_5_SEC:
	.LONG	-10*1000*1000*5,-1	; 5 second delta time
DELTA_4_SEC:
	.LONG	-10*1000*1000*4,-1	; 4 second delta time
DELTA_1_SEC:
	.LONG	-10*1000*1000,-1	; 1 second delta time
.PAGE
;
	.SBTTL	R/W PSECT
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
;
TPID:
	.LONG	0			; PID for this process
CURRENT_TC:
	.LONG	0			; ptr to current test case
PENDING_TC:
	.LONG	0			; test case prior to AST delivery
	.ALIGN LONG
REG_SAVE_AREA:
	.BLKL	15			; register save area
MOD_MSG_CODE:
	.LONG	UETP$_SATSMS		; test module message code for putmsg
TMN_ADDR:
	.ADDRESS TEST_MOD_NAME
TMD_ADDR:
	.ADDRESS TEST_MOD_BEGIN
PRVPRT:
	.BYTE	0			; protection return byte for SETPRT
PRIVMASK:
	.QUAD	0			; priv. mask
CHM_CONT:
	.LONG	0			; change mode continue address
RETADR:
	.BLKL	2			; returned address's from SETPRT
DCL:
	$DCLAST	AST2,-8,PSL$C_USER	; DCLAST parameter list
SET:
	$SETAST 0			; SETAST parameter list
SET1:
	$SETIMR	0,TIME,0,5		; SETIMR parameter list
SET2:
	$SETPRA DUMMY+1,PSL$C_KERNEL	; SETPRA parameter list
CAN:
	$CANTIM	1,0			; CANTIM parameter list
MODE:
	.LONG	0			; current mode string pointer
REG:
	.ASCID	\register R\
REGNUM:
	.LONG	0			; register number
MSGL:
	.LONG	80			; buffer desc.
	.ADDRESS BUF
BUF:
	.BLKB	80
MESSAGEL:
	.LONG	0			; message length
	.ADDRESS BUF
SERV_NAME:
	.LONG	0			; service name pointer
ASTPAR1:
	.LONG	-1			; AST 1's parameter
ASTPAR2:
	.LONG	-8			; AST 2's parameter
ASTOK:
	.BYTE	0			; AST's legal flag
					; BIT0 = 0 AST's are illegal
					; BIT0 = 1 AST's are legal
PRVHND1:
	.LONG	0			; previous handler address 1
HANDLER_ADR:
	.LONG	0			; handler address storage
X_SEC:
	.LONG	0			; scratch good up to 7 sec
TIME:
	.QUAD	0			; time parameter for SETIMR & CANTIM
ID:
	.LONG	0			; timer AST flag
WORK:
	.LONG	0			; scratch long word
MSGVEC1:				; PUTMSG message vector
	.LONG	3
	.LONG	UETP$_TEXT
	.LONG	1
	.LONG	0
	.PAGE
	.PSECT	SATSSS26,RD,WRT,EXE,LONG
	.SBTTL	SATSSS26
;++
; FUNCTIONAL DESCRIPTION:
;
;	After performing some initial housekeeping, such as
; printing the module begin message and acquiring needed privileges,
; the system services are tested in each of their normal conditions.
; Detected failures are identified and  an error message is printed
; on the terminal.  Upon completion of the test a success or fail
; message is printed on the terminal.
;
; CALLING SEQUENCE:
;
;	$ RUN SATSSS26  ...  (DCL COMMAND)
;
; INPUT PARAMETERS:
;
;	none
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUT PARAMETERS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Messages to SYS$OUTPUT are the only output from SATSSS26.
;	They are of the form:
;
;		%UETP-S-SATSMS, TEST MODULE SATSSS26 BEGUN ... (BEGIN MSG)
;		%UETP-S-SATSMS, TEST MODULE SATSSS26 SUCCESSFUL ... (END MSG)
;		%UETP-E-SATSMS, TEST MODULE SATSSS26 FAILED ... (END MSG)
;		%UETP-I-TEXT, ... (VARIABLE INFORMATION ABOUT A TEST MODULE FAILURE)
;
; COMPLETION CODES:
;
;	The SATSSS26 routine terminates with a $EXIT to the
;	operating system with a status code defined by UETP$_SATSMS.
;
; SIDE EFFECTS:
;
;	none
;
;--



	TEST_START SATSSS26		; let the test begin
	$CMKRNL_S W^SETUP_SUPER,W^ARGLST ; declare CHMS handler
	ADDL2	S^#EXE$C_CMSTKSZ+16,SP	; adjust the user stack pointer
	MOVL	SP,FP			; fix the frame pointer
	CALLS	#0,W^ERLBUF_DUMP	; dump any errors that occured at kernal mode
	.SBTTL	AST TESTS
;+
;
; test for user AST's
;
;	  DECLARED ORDER
; AST ROUTINE	MODE	AST PARAM
; -------------------------------
;    AST1	USER	    -1
;    AST2	USER	    -8
;-
	MOVAL	W^UM,W^MODE		; set mode
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	$SETAST_G	W^SET		; disable user AST's
	FAIL_CHECK SS$_WASSET		; check for success
	MOVAL	W^DCLAST,W^SERV_NAME	; set service name
	$DCLAST_S W^AST1,#-1,#PSL$C_USER ; declare user AST #1
	FAIL_CHECK SS$_NORMAL		; check for success
	$DCLAST_G W^DCL			; declare user AST #2
	FAIL_CHECK SS$_NORMAL		; check for success
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	MOVB	#1,W^ASTOK		; set AST's are legal flag
	$SETAST_S #1			; two AST's for user should occur
	FAIL_CHECK SS$_NORMAL		; check for success
;+
;
; test for super AST's
;
;	  DECLARED ORDER
; AST ROUTINE	MODE	AST PARAM
; -------------------------------
;    AST1	SUPER	    -2
;    AST2	SUPER	    -7
;-
	NEXT_TEST
	MOVAL	W^SM,W^MODE		; set mode
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	CLRB	W^ASTOK			; AST's are now illegal
	CHMS	#1			; test super mode AST's
;+
;
; test for exec AST's
;
;	  DECLARED ORDER
; AST ROUTINE	MODE	AST PARAM
; -------------------------------
;    AST1	EXEC	    -3
;    AST2	EXEC	    -6
;-
	NEXT_TEST
	MOVAL	W^EM,W^MODE		; set mode
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	CLRB	W^ASTOK			; AST's are now illegal
	MODE	TO,10$,EXEC,NOREGS	; set mode to exec
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	$SETAST_G W^SET			; disable exec AST's
	FAIL_CHECKNP SS$_WASSET		; check for success
	MOVAL	W^DCLAST,W^SERV_NAME	; set service name
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	$DCLAST_S W^AST1,#-3,#PSL$C_EXEC ; declare exec AST #1
	FAIL_CHECKNP SS$_NORMAL		; check for success
	INCL	W^DCL+DCLAST$_ASTPRM	; set new parameter
	DECL	W^DCL+DCLAST$_ACMODE	; set to exec mode
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a reg snapshot
	$DCLAST_G W^DCL			; declare exec AST #2
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a reg snapshot
	MOVB	#1,W^ASTOK		; AST's are now legal
	$SETAST_S #1			; two AST's for exec should occur
	FAIL_CHECKNP SS$_WASCLR		; check for success
	MODE	FROM,10$		; set mode back
;+
;
; test for kernel AST's
;
;	  DECLARED ORDER
; AST ROUTINE	MODE	AST PARAM
; -------------------------------
;    AST1	KRNL	    -4
;    AST2	KRNL	    -5
;-
	NEXT_TEST
	MOVAL	W^KM,W^MODE		; set mode
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	MODE	TO,10$,KRNL,NOREGS	; set mode to kernel
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a reg snapshot
	$SETAST_G W^SET			; disable kernel AST's
	FAIL_CHECKNP SS$_WASSET		; check for success
	MOVAL	W^DCLAST,W^SERV_NAME	; set service name
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a reg snapshot
	$DCLAST_S W^AST1,#-4,#PSL$C_KERNEL
	FAIL_CHECKNP SS$_NORMAL		; check for success
	INCL	W^DCL+DCLAST$_ASTPRM	; set new parameter
	DECL	W^DCL+DCLAST$_ACMODE	; set to kernal mode
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	$DCLAST_G W^DCL
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVAL	W^SETAST,W^SERV_NAME	; set service name
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	MOVB	#1,W^ASTOK		; set AST's are legal flag
	$SETAST_S #1			; two AST's for kernal should occur
	FAIL_CHECKNP SS$_WASCLR		; check for success
	MODE	FROM,10$		; set mode back
	CALLS	#0,W^ERLBUF_DUMP	; dump any errors
.PAGE
	.SBTTL	SETPRA TESTS
;+
;
; SETPRA tests
;
; test user mode 
;
;-
	NEXT_TEST
	MOVAL	W^DUMMY,W^HANDLER_ADR	; set handler address
	MOVAL	W^SETPRA,W^SERV_NAME	; set service name
	MOVAL	W^UM,W^MODE		; set mode
	$SETPRA_S @W^HANDLER_ADR,#PSL$C_KERNEL ; test _S & mode maximizing
	FAIL_CHECK SS$_NORMAL		; check for success
	PUSHL	#PSL$C_USER		; set expected mode
	CALLS	#1,W^POWER_CHECK	; check effect
	INCL	W^HANDLER_ADR		; make address unique
	$SETPRA_G W^SET2		; test _G & mode maximizing
	FAIL_CHECK SS$_NORMAL		; check for success
	PUSHL	#PSL$C_USER		; set expected mode
	CALLS	#1,W^POWER_CHECK	; check effects
	INCL	W^HANDLER_ADR		; make address unique
;+
;
; test super mode
;
;-
	NEXT_TEST
	MOVAL	W^SM,W^MODE		; set mode
	CHMS	#4			; do the super tests
;+
;
; test exec mode
;
;-
	NEXT_TEST
	MOVAL	W^EM,W^MODE		; set mode
	$CMEXEC_S B^10$			; get to exec mode
	BRB	20$
10$:
	.WORD	0
	PUSHL	#0			; push a dummy
	CALLS #1,W^REG_SAVE		; save a register snapshot
	$SETPRA_S @W^HANDLER_ADR,#PSL$C_EXEC ; test _S & mode maximizing
	FAIL_CHECKNP SS$_NORMAL		; check for success
	RET				; return to user mode
20$:
	CALLS	#0,W^ERLBUF_DUMP	; dump any errors
	PUSHL	#PSL$C_EXEC		; set expected mode
	CALLS	#1,W^POWER_CHECK		; check effect
	INCL	W^HANDLER_ADR		; make address unique
	MOVL	W^HANDLER_ADR,W^SET2+SETPRA$_ASTADR ; set new address
	$CMEXEC_S B^30$			; go back to exec mode
	BRB	40$			; skip exec routine
30$:
	.WORD	0
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a reg snapshot
	$SETPRA_G W^SET2		; test _G & mode maximizing
	FAIL_CHECKNP SS$_NORMAL		; check for success
	RET				; return to user mode
40$:
	CALLS #0,W^ERLBUF_DUMP		; dump any errors
	PUSHL	#PSL$C_EXEC		; set expected mode
	CALLS	#1,W^POWER_CHECK		; check effect
	INCL	W^HANDLER_ADR		; make address unique
;+
;
; test kernal mode 
;
;-
	NEXT_TEST
	MOVAL	W^KM,W^MODE		; set mode
	$CMKRNL_S B^10$			; get to kernal mode
	BRB	20$			; skip over the routine
10$:
	.WORD	0			; entry mask
	PUSHL	#0			; push a dummy
	CALLS #1,W^REG_SAVE		; save a register snapshot
	$SETPRA_S @W^HANDLER_ADR,#PSL$C_KERNEL ; test _S form
	FAIL_CHECKNP SS$_NORMAL		; check success
	RET				; return to user mode
20$:
	CALLS #0,W^ERLBUF_DUMP		; dump any errors
	PUSHL	#PSL$C_KERNEL		; set expected mode
	CALLS	#1,W^POWER_CHECK	; check effect
	INCL	W^HANDLER_ADR		; make address unique
	MOVL	W^HANDLER_ADR,W^SET2+SETPRA$_ASTADR ; set new address
	$CMKRNL_S B^30$			; return to kernel mode
	BRB	40$			; skip over kernel routine
30$:
	.WORD	0
	$SETPRA_G W^SET2		; test _G
	FAIL_CHECKNP SS$_NORMAL		; check success
	RET				; return to user mode
40$:
	CALLS #0,W^ERLBUF_DUMP		; dump any errors
	PUSHL	#PSL$C_KERNEL		; set expected mode
	CALLS	#1,W^POWER_CHECK	; check effect

	.SBTTL	SETIMR TESTS
;+
;
; SETIMR tests
;
; test EFN #33, real time, ID=6, 6 sec, _S
;
;-
	NEXT_TEST
	MOVAL	W^UM,W^MODE		; set the mode
	MOVAL	W^SETIMR,W^SERV_NAME	; set the service name
	$GETTIM_S TIMADR=TIME		; get the current time
	MULL3	#6,W^ONE_SEC,W^X_SEC	; make 6 seconds
	ADDL2	W^X_SEC,W^TIME		; add it to the current time
	ADWC	#0,W^TIME+4		; include the carry bit if any
	$SETIMR_S EFN=#33,-
		  DAYTIM=W^TIME,-
		  REQIDT =#6		; do it
	FAIL_CHECK SS$_NORMAL		; check for success
;+
;
; test def EFN, delta time, ID=5, 5 sec, _G
;
;-
	NEXT_TEST
	MOVAL	W^DELTA_5_SEC,W^SET1+SETIMR$_DAYTIM ; set 5 sec delta
	$SETIMR_G W^SET1		; do it
	FAIL_CHECK SS$_NORMAL		; check success
;+
;
; test EFN=4, delta time, ID=4, 4 sec, _S
;
;-
	NEXT_TEST
	$SETIMR_S DAYTIM=W^DELTA_4_SEC,-
		  EFN    =#4,-
		  REQIDT =#4		; do it
	FAIL_CHECK SS$_NORMAL		; check success
;+
;
; test EFN=3, real time, ID=3, 3 sec, _G
;
;-
	NEXT_TEST
	MULL3	#3,W^ONE_SEC,W^X_SEC	; make 3 seconds
	SUBL2	W^X_SEC,W^TIME		; deduct it from 6 seconds from now
	SBWC	#0,W^TIME+4		; subtract carry if any
	MOVAL	W^TIME,W^SET1+SETIMR$_DAYTIM ; set the time
	MOVL	#3,W^SET1+SETIMR$_EFN	; set the EFN
	MOVL	#3,W^SET1+SETIMR$_REQIDT ; set the ID
	$SETIMR_G W^SET1		; do it
	FAIL_CHECK SS$_NORMAL		; check success
;+
;
; test EFN=2, ASTADR, real time, ID=2, 2 sec, _S
;
;-
	NEXT_TEST
	SUBL2	W^ONE_SEC,W^TIME	; make it 2 sec from now
	SBWC	#0,W^TIME+4		; subtract carry if any
	$SETAST_S #0			; if an error would occur it
					; it would take longer to print
					; than 2 sec and would be intr.
					; so hold back the intr.
	$SETIMR_S DAYTIM=W^TIME,-
		  EFN    =#2,-
		  ASTADR =W^AST4,-
		  REQIDT =#2		; do it
	FAIL_CHECK SS$_NORMAL		; check success
	$SETAST_S #1			; OK it's safe for intr.'s
;+
;
; test EFN=1, ASTADR, delta time, ID=1, 1 sec _G
;
;-
	NEXT_TEST
	MOVL	#1,W^SET1+SETIMR$_EFN	; set EFN
	MOVAL	W^DELTA_1_SEC,W^SET1+SETIMR$_DAYTIM ; set time
	MOVAL	W^AST3,W^SET1+SETIMR$_ASTADR ; set AST address
	MOVL	#1,W^SET1+SETIMR$_REQIDT ; set the ID
	$SETAST_S #0			; if an error would occur it
					; it would take longer to print
					; than 1 sec and would be intr.
					; so hold back the intr.
	$SETIMR_G W^SET1		; do it
	FAIL_CHECK SS$_NORMAL		; check success
	$SETAST_S #1			; OK it's safe to intr.
	BRW	NEXT_STEP		; skip the AST routines
;+
;
; At this time there should be the following TQE's to be serviced
; in the following order:
;
;	FORM	TIME	ID#	HOW SERVICED
;
;	_G	1 SEC	1	AST3
;	_S	2 SEC	2	AST4
;	_G	3 SEC	3	EFN 3
;	_S	4 SEC	4	EFN 4
;	_G	5 SEC	5	EFN 0
;	_S	6 SEC	6	EFN 0
;
; The next 6 steps will service the TQE's and check the results.
;
; test servicing of AST TQE started with ID=#1
;
;-

AST3:
	.WORD	0
	MOVL	CURRENT_TC,PENDING_TC	; save interrupted test case number
	NEXT_TEST
	MOVL	#1,W^ID			; set AST id flag
	CMPL	4(AP),#1		; correct?
	BEQL	10$			; br if yes
	PUSHL	4(AP)			; push received
	PUSHL	#1			; push expected
	PUSHAL	W^EXP			; push string variable
	CALLS	#3,W^PRINT_FAIL		; print the error
10$:
	MOVL	PENDING_TC,CURRENT_TC	; restore test case number
	RET				; return
;+
;
; test servicing of AST TQE started with ID #2
;
;-
AST4:
	.WORD	0
	MOVL	CURRENT_TC,PENDING_TC	; save interrupted test case number
	NEXT_TEST
	CMPL	W^ID,#1			; has the previous AST occured?
	BEQL	10$			; br if yes
	PUSHL	W^ID			; push received
	PUSHL	#1			; push expected
	PUSHAL	W^EXP			; push the string variable
	CALLS	#3,W^PRINT_FAIL		; print the failure
10$:
	MOVL	#2,W^ID			; set AST ID flag
	CMPL	4(AP),#2		; is this the correct one?
	BEQL	20$			; br if yes
	PUSHL	4(AP)			; push received
	PUSHL	#2			; push expected
	PUSHAL	W^EXP			; push string variable
	CALLS	#3,W^PRINT_FAIL		; print the failure
20$:
	MOVL	PENDING_TC,CURRENT_TC	; restore test case number
	RET				; return
;+
;
; test TQE with ID of 3
;
;-
NEXT_STEP:
	NEXT_TEST
	$WAITFR_S EFN=#3		; wait here for AST3, AST4, & EFN 3
	CMPL	W^ID,#2			; did both AST's occur?
	BEQL	10$			; br if yes
	PUSHL	W^ID			; push received
	PUSHL	#2			; push expected
	PUSHAL	W^EXP			; push string variable
	CALLS	#3,W^PRINT_FAIL		; print the failure
10$:
;+
;
; wait for TQE with ID of 4
;
;-
	NEXT_TEST
	$WAITFR_S EFN=#4		; wait for #4
;+
;
; wait for TQE with ID of 5
;
;-
	NEXT_TEST
	$WAITFR_S EFN=#0		; wait for #5
	$CLREF_S EFN=#0			; get ready for #6
;+
;
; wait for TQE with ID of 6

;
;-
	NEXT_TEST
	$WAITFR_S EFN=#33		; wait for #6

	.SBTTL CANTIM TESTS
;+
;
; CANTIM tests
;
; test user mode
;
;-
	NEXT_TEST
	MOVAL	W^CANTIM,W^SERV_NAME	; set the service name
	MOVAL	W^SET1,R2		; set SETIMR param. pointer
	MOVAL	W^ILEGAL_TIM,-
		B^SETIMR$_ASTADR(R2)	; set AST address
	MOVAL	W^DELTA_1_SEC,-
		B^SETIMR$_DAYTIM(R2)	; set one sec delta time
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save a register snapshot
	$SETIMR_G (R2)			; make a TQE
	$CANTIM_S REQIDT=#1		; scrap it
	FAIL_CHECK SS$_NORMAL		; check success
;+
;
; test cancelling 2 TQE's in user mode
;
;-
	NEXT_TEST
	MOVL	#1,W^ID			; set the proper ID
	$SETIMR_G (R2)			; make #1 TQE
	$SETIMR_G (R2)			; make #2 TQE
	$CANTIM_G W^CAN			; try it
	FAIL_CHECK SS$_NORMAL		; check for success
	MOVL	#3,B^SETIMR$_REQIDT(R2)	; set ID to 3
	$SETIMR_G (R2)			; set a TQE for later
	MOVL	#1,B^SETIMR$_REQIDT(R2)	; reset ID to 1
;+
;
; test super mode
;
;-
	NEXT_TEST
	MOVAL	W^SM,W^MODE		; set the mode
	CHMS	#5			; do super mode tests
;+
;
; test cancelling 1 exec TQE
;
;-
	STEP=STEP+2
	NEXT_TEST
	MOVAL	W^EM,W^MODE		; set the mode
	$CMEXEC_S B^10$			; get to EXEC mode
	BRW A20				; skip over EXEC routine
10$:
	.WORD	^M<>
	MOVL	R2,W^WORK		; save R2
	MOVAL	W^SET1,R2		; set SETIMR param pointer
	$SETIMR_G (R2)			; make a TQE
	$CANTIM_S REQIDT=#1,-
		  ACMODE=#PSL$C_EXEC	; can it
	FAIL_CHECKNP SS$_NORMAL		; check for success
;+
;
; test cancelling 2 exec TQE
;
;-
	NEXT_TEST
	$SETIMR_G (R2)			; make a TQE
	$SETIMR_G (R2)			; make another
	MOVL	#PSL$C_EXEC,-
		W^CAN+CANTIM$_ACMODE	; set the mode
	$CANTIM_G W^CAN			; can 2 at once
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVL	#3,B^SETIMR$_REQIDT(R2)	; set ID to 3
	$SETIMR_G (R2)			; set one for later
	MOVL	#1,B^SETIMR$_REQIDT(R2)	; reset ID to 1
	MOVL	W^WORK,R2		; restore R2
	RET				; return to user mode
A20:
	CALLS #0,W^ERLBUF_DUMP		; dump any errors
;+
;
; test cancelling one kernel mode TQE
;
;-
	NEXT_TEST
	MOVAL	W^KM,W^MODE		; set the mode
	MODE TO,B10,KRNL,NOREGS		; get to kernel mode
	MOVL	R2,W^WORK		; save R2
	MOVAL	W^SET1,R2		; set SETIMR param pointer
	$SETIMR_G (R2)			; make a kernel TQE
	$CANTIM_S REQIDT=#1,-
		  ACMODE=#PSL$C_KERNEL	; can it
	FAIL_CHECKNP SS$_NORMAL		; check for success
;+
;
; test cancelling 2 kernel TQE's
;
;-
	NEXT_TEST
	$SETIMR_G (R2)			; make a kernel TQE
	$SETIMR_G (R2)			; and another
	MOVL	#PSL$C_KERNEL,-
		W^CAN+CANTIM$_ACMODE	; set access mode
	$CANTIM_G W^CAN			; cancel 2 kernel TQE's
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVL	#3,SETIMR$_REQIDT(R2)	; set ID to 3
	$SETIMR_G (R2)			; make a kernel TQE
;+
;
; At this point there should be the following TQE's still
; waiting to be killed:
;
;	1	user	TQE	ID = 3
;	1	super	TQE	ID = 3
;	1	exec	TQE	ID = 3
;	1	kernel	TQE	ID = 3
;
; We will now attempt to cancel all of these TQE's with
; 1 CANTIM service.
;
;-
	NEXT_TEST
	$CANTIM_S REQIDT= #3,-
		  ACMODE= #PSL$C_KERNEL	; clean em out!
	FAIL_CHECKNP SS$_NORMAL		; check for success
	MOVL	W^WORK,R2		; restore R2
	MODE FROM,B10,NOREGS		; return to user mode
	CALLS	#0,W^ERLBUF_DUMP	; dump any errors
;+
;
; We now have to wait 1 second to see if any TQE's are still pending
; that CANTIM's should have canceled.
;
;-
	MOVAL	W^SETIMR,W^SERV_NAME	; set service name
	$SETIMR_S DAYTIM=W^DELTA_1_SEC,-
		  EFN   = #1		; wait a second for illegal TQE's
	FAIL_CHECK SS$_NORMAL		; check for success
	$WAITFR_S EFN=#1		; wait here
;+
;
; reset super mode handler to the original address and
; dump any errors on the terminal that occured at AST disable time.
;
;-
CLEAN_UP:
	MOVAL	W^DCLCMH,W^SERV_NAME	; set service name
	CHMS	#3			; reset the CHMS handler
	CALLS #0,W^ERLBUF_DUMP		; dump any errors
	TEST_END

.SBTTL	ROUTINES
.SBTTL SETUP_SUPER ROUTINE
;++
;
;	Routine to declare an initial CHMS handler from user mode.
;
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;
;	$CMKRNL_S W^SETUP_SUPER,ARGLST
;
;		ARGLST = address of a pointer to a one parameter argument list containing
;			 the address of the entry mask of the CHMS handler
;
; INPUT PARAMETERS:
;
;	ARGLST
;
; IMPLICIT INPUTS
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	Declares a change mode handler for super mode which must be
;	reset to DCL in the users handler routine when the handler is
;	no longer needed.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
; ON ENTRY:
;		       ---------	       ---------
;		KSP => !   0   !	USP => !       !
;		       !   0   !	       !  USER !
;		       !   AP  !	       !       !
;		       !   FP  !	       !  CALL !
;		       !   PC  !	       !       !
;		       !   0   !	       ! FRAME !
;		       !   0   !	       !       !
;		       !   AP  !	       ---------
;		       !   FP  !
;		       !SRVEXIT!
;		       !   PC  !
;		       !  PSL  !
;		       ---------
;--
.PAGE
RETURN_PC:
	.LONG	0			; storage for user return PC
HANDLER_PC:
	.LONG	0			; storage for handler PC
;
SETUP_SUPER:
	.WORD	^M<R2,R3>	
	MFPR	#PR$_USP,R3		; get the user call frame address
	MOVL	SF$L_SAVE_PC(R3),B^RETURN_PC ; get the user return PC
	MOVL	4(AP),HANDLER_PC	; save the handler address
	MOVL	SF$L_SAVE_FP(FP),R2	; get saved FP
	ADDL	S^#EXE$C_CMSTKSZ,R2	; back over change mode stack frame
	MOVAB	B^20$,(R2)		; set return address
	INSV	#<<PSL$C_SUPER@PSL$S_CURMOD>+PSL$C_SUPER>,-
		#PSL$V_PRVMOD,-
		#PSL$S_CURMOD*2,4(R2)	; set current and previous mode to super
	MOVL	S^#SS$_NORMAL,R0	; set correct return code
	RET				; enter super mode
20$:
	CLRL	-(SP)			; set up dummy PSL
	CALLG	(SP),B^30$		; create initial call frame
30$:
	.WORD	^M<>			; entry mask
	PUSHL	#0			; push a dummy parameter
	CALLS	#1,W^REG_SAVE		; save the registers
	$DCLCMH_S @HANDLER_PC,W^PRVHND1,#0 ; set real handler
	FAIL_CHECKNP SS$_NORMAL		; check for success
	PUSHL	#<<PSL$C_USER@PSL$V_CURMOD>-
		!<PSL$C_USER@PSL$V_PRVMOD>>; set return to user
	PUSHL	RETURN_PC		; set the return PC
	REI				; return to user mode
	.SBTTL	AST SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to service AST's for the DCLAST service tests.
;
; CALLING SEQUENCE:
;	AST delivery
;
; INPUT PARAMETERS:
;	4(AP) = AST parameter
;	ASTOK = AST flag byte
;	ASTPAR1, ASTPAR2 = expected AST parameters
;	ELBP  = error log buffer pointer
;
; OUTPUT PATAMETERS:
;	possible errors logged in the ERLB buffer
;
;--

AST1:
	.WORD	^M<R2,R3,R4>
	MOVL	W^ASTPAR1,R3		; save the parameter
	DECL	W^ASTPAR1		; set up for the next AST
	CMPL	R3,4(AP)		; is this a good AST param.?
	BEQL	C20			; br if yes
	BRB	C10			; br if no
AST2:
	.WORD	^M<R2,R3,R4>
	MOVL	W^ASTPAR2,R3		; save the parameter
	INCL	W^ASTPAR2		; set up for the next AST
	CMPL	R3,4(AP)		; is this AST param OK?
	BEQL	C20			; br if yes
C10:
	CALLS #0,W^STORE_STEP		; save the step information
	MOVL	W^ELBP,R4		; get error log pointer
	MOVB	#3,(R4)+		; save the longword count
	MOVL	4(AP),(R4)+		; save received data
	MOVL	R3,(R4)+		; save expected data
	MOVAL	W^ASTPRM,(R4)+		; save string variable
	CLRL	(R4)			; set a new terminator
	MOVL	R4,W^ELBP		; reset the buffer pointer
C20:
	BLBS	W^ASTOK,30$		; should AST have occured?
	CALLS 	#0,W^AST_FAIL		; report a failure
30$:
	RET
.PAGE
.SBTTL SUPER_MODE
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to handle the CHMS instructions.
;
; CALLING SEQUENCE:
;	CHMS	#N
;
; INPUT PARAMETERS:
;	  SP=>	CHMS parameter
;		PC
;		PSL
;
;	  The CHMS parameter can be one of the following:
;
;		1 = execute super mode AST tests
;		2 = execute a $SETAST_G to disable super mode AST's
;		3 = execute a $DCLCMH_S to reset the CHMS handler to DCL
;		4 = execute a $SETPRA_S & $SETPRA_G service
;		5 = execute the $CANTIM_S & $CANTIM_G tests
;
; OUTPUT PARAMETERS:
;	NONE
;--

SUPER_MODE:
	MOVL	(SP)+,R0		; get CHM parameter off the stack
	CASEB	R0,#1,#5		; do the right thing
10$:
	.WORD	20$-10$
	.WORD	10$-10$
	.WORD	40$-10$
	.WORD	50$-10$
	.WORD	A60-10$
20$:
	MOVAL	W^SETAST,W^SERV_NAME	; set service name pointer
	CLRL	W^SET+SETAST$_ENBFLG	; set parameter list to disable
	$SETAST_G W^SET			; disable super mode AST's
	FAIL_CHECKNP SS$_WASSET		; check for success
	MOVAL	W^DCLAST,W^SERV_NAME	; set service name pointer
	$DCLAST_S W^AST1,#-2,#PSL$C_SUPER ; declare super AST #1
	FAIL_CHECKNP SS$_NORMAL		; and check for success
	INCL	W^DCL+DCLAST$_ASTPRM	; set new parameter
	DECL	W^DCL+DCLAST$_ACMODE	; set to super mode
	$DCLAST_G W^DCL			; declare super AST #2
	FAIL_CHECKNP SS$_NORMAL		; and check for failure
	MOVAL	W^SETAST,W^SERV_NAME	; set service name pointer
	MOVB	#1,W^ASTOK		; AST's are now legal
	$SETAST_S	#1		; enable super mode AST's
	FAIL_CHECKNP SS$_WASCLR		; check for success
	BRW	A70			; carry on
40$:
	MOVAL	W^DCLCMH,W^SERV_NAME	; set service name pointer
	$DCLCMH_S @PRVHND1,,#0		; reset the CHMS handler for DCL
	FAIL_CHECK SS$_NORMAL		; check for success
	BRW	A70			; carry on
50$:
	$SETPRA_S @W^HANDLER_ADR,#PSL$C_KERNEL ; check _S and mode maximizing
	FAIL_CHECK SS$_NORMAL		; check success
	PUSHL	#PSL$C_SUPER		; set expected mode
	CALLS	#1,W^POWER_CHECK	; check effect
	INCL	W^HANDLER_ADR		; make address unique
	MOVL	W^HANDLER_ADR,W^SET2+SETPRA$_ASTADR ; set new address
	$SETPRA_G W^SET2		; check _G and mode maximizing
	FAIL_CHECK SS$_NORMAL		; check for success
	PUSHL	#PSL$C_SUPER		; set expected mode
	CALLS	#1,W^POWER_CHECK	; check effect
	INCL	W^HANDLER_ADR		; make address unique
	BRW	A70			; carry on
	STEP=34
A60:
	$SETIMR_G (R2)			; make a super TQE
	$CANTIM_S REQIDT=#1,-
		  ACMODE=#PSL$C_SUPER	; can it
	FAIL_CHECK SS$_NORMAL		; check for success
;+
;
; cancel 2 super TQE's
;
;-
	NEXT_TEST
	$SETIMR_G (R2)			; make a super TQE
	$SETIMR_G (R2)			; and another
	MOVL	#PSL$C_SUPER,-
		W^CAN+CANTIM$_ACMODE	; set the access mode
	$CANTIM_G W^CAN			; can both of them
	FAIL_CHECK SS$_NORMAL		; check for success
	MOVL	#3,SETIMR$_REQIDT(R2)	; set ID to 3
	$SETIMR_G (R2)			; set one for later
	MOVL	#1,SETIMR$_REQIDT(R2)	; reset ID to 1
	BRB	A70			; carry on
A70:
	REI				; go back to user mode
	.SBTTL REG_SAVE
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to save R2-R11 in the register save location.
;
; CALLING SEQUENCE:
;	PUSHL	#0		; save a dummy parameter
;	CALLS	#1,W^REG_SAVE	; save R2-R11
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

REG_SAVE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; save the registers in the program
	RET
	.SBTTL	REG_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages printed using $PUTMSG
;
;--

REG_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0			; is this the right fail code?
	BEQL	10$				; br if yes
	PUSHL	R0				; push received data
	PUSHL	4(AP)				; push expected data
	PUSHAL	W^EXP				; push the string variable
	CALLS	#3,W^PRINT_FAIL			; print the error message
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA	; check all but R0
	BEQL	20$				; br if O.K.
	SUBL3	#REG_SAVE_AREA,R3,R6		; calculate the register number
	DIVL2	#4,R6
	ADDB3	#^X2,R6,W^REGNUM		; put it in the string
	BICL2	#3,R1				; backup to register boundrys
	BICL2	#3,R3
	PUSHL	W^REGNUM				; push register number
	PUSHL	(R1)				; push received data
	PUSHL	(R3)				; push expected data
	PUSHAL	W^REG				; set string pntr param.
	CALLS	#4,W^PRINT_FAIL			; print the error message
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
20$:
	RET
	.SBTTL	PRINT_FAIL
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to report failures using $PUTMSG
;
; CALLING SEQUENCE:
; Mode  #1	PUSHL EXPECTED	Mode    #2	PUSHL REG_NUMBER
;		PUSHL RECEIVED			PUSHL EXPECTED
;		PUSHAL STRING_VAR		PUSHL RECEIVED
;		CALLS #3,W^PRINT_FAIL		PUSHAL STRING_VAR
;						CALLS #4,W^PRINT_FAIL
; Mode	#3	PUSHAL STRING_VAR
;		CALLS #1,W^PRINT_FAIL
;
; INPUT PARAMETERS:
;	listed above
;
; OUTPUT PARAMETERS:
;	an error message is printed using $PUTMSG
;
;--

PRINT_FAIL:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	W^CS1,W^MESSAGEL,W^MSGL,#TEST_MOD_NAME,W^SERV_NAME,W^CURRENT_TC
	$PUTMSG_S W^MSGVEC			; print the message
	CMPB	(AP),#4				; is this a register message?
	BEQL	10$				; br if yes
	CMPB	(AP),#1				; is this just a message?
	BEQL	20$				; br if yes
	$FAO_S	W^CS2,W^MESSAGEL,W^MSGL,4(AP),8(AP),4(AP),12(AP)
	BRB	30$				; goto output message
10$:
	$FAO_S	W^CS3,W^MESSAGEL,W^MSGL,4(AP),16(AP),8(AP),4(AP),16(AP),12(AP)
	BRB	30$				; goto output message
20$:
	MOVL	4(AP),W^MSGVEC1+12		; save string address
	$PUTMSG_S W^MSGVEC1			; print the message
	BRB	40$				; skip the other message
30$:
	$PUTMSG_S W^MSGVEC			; print the message
40$:
	CALLS	#0,W^MODE_ID			; identify the mode
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
	RET
.PAGE
	.SBTTL REG_CHECKNP
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to test R0 & R2-R11 for proper content after a service
;	execution without printing it. A snapshot is taken by the REG_SAVE routine at the
;	beginning of each step and this routine is executed after the
;	services have been executed. This routine collects the error
;	information in buffer ERLB instead of printing it.
;
; CALLING SEQUENCE:
;	PUSHL	#SS$_XXXXXX	; push expected R0 contents
;	CALLS	#1,W^REG_CHECK	; execute this routine
;
; INPUT PARAMETERS:
;	expected R0 contents on the stack
;
; OUTPUT PARAMETERS:
;	possible error messages logged in buffer ERLB which are printed
;	using routine ERLBUF_DUMP.
;
;	Error packets are in the following form:
;
;		!-----------------!
;		!Service name pntr!
;		!-----------------!
;		!     Step #	  !
;		!-----------------!
;		!Mode name pointer!
;		!-----------------!
;		!	      !   ! long word count
;		!-----------------!
;		!\/\/\/\/\/\/\/\/\! 3-4 parameter long words
;
;--

FLAG:
	.BYTE 0			; error flags are BIT0 = 0 means no errors in the buffer
				;		  BIT0 = 1 means errors in the buffer
ELBP:
	.ADDRESS ERLB		; error log buffer pointer
ERLB:
	.BLKB	1500		; error log buffer
;
REG_CHECKNP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CMPL	4(AP),R0	; is this the right fail code
	BEQL	10$		; br if yes
	CALLS #0,W^STORE_STEP	; store step information
	MOVL	ELBP,R2		; get the current error log pointer
	MOVB	#3,(R2)+	; save the long word count
	MOVL	R0,(R2)+	; save received status
	MOVL	4(AP),(R2)+	; save expected status
	MOVAL	W^EXP,(R2)+	; save the string variable
	CLRL	(R2)		; set the terminator
	MOVL	R2,ELBP		; reset the buffer pointer
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR ; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE ; set severity code
10$:
	CMPC3	#4*10,^X14(FP),W^REG_SAVE_AREA ; check all but R0 and R1
	BEQL	20$		; br if OK
	CALLS #0,W^STORE_STEP	; store step information
	MOVL	ELBP,R2		; get current error log buf pointer
	MOVB	S^#4,(R2)+	; set longword count
	SUBL3	#REG_SAVE_AREA,-
	R3,R6			; calc reg number
	DIVL2	S^#4,R6		; make it a longword count
	ADDL3	S^#2,R6,(R2)+	; correct for R0-R1 and save
	MOVL	(R1),(R2)+	; save received results
	MOVL	(R3),(R2)+	; save expected results
	MOVAL	W^REG,(R2)+	; save string variable
	CLRL	(R2)		; set the terminator
	MOVL	R2,ELBP		; reset the buffer pointer
	MOVAL	W^TEST_MOD_FAIL,W^TMD_ADDR	; set failure message address
	INSV	#ERROR,#0,#3,W^MOD_MSG_CODE	; set severity code
20$:
	RET			; bail out
.PAGE
	.SBTTL	ERLBUF_DUMP
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to check for errors in the error log buffer and
;	report any that are there.
;
; CALLING SEQUENCE:
;	CALLS #0,W^ERLBUF_DUMP
;
; INPUT PARAMETERS:
;	FLAG bit 0 = 0 for no errors logged
;	FLAG bit 0 = 1 for errors logged
;	if errors logged then buffer ERLB must contain legal format errors
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

ERLBUF_DUMP:
	.WORD	^M<R2,R3,R4>
	BLBC	FLAG,30$	; br if no errors to report
	MOVAL	ERLB,R2		; set up buffer pointer
10$:
	TSTL	(R2)		; any more errors?
	BEQL	30$		; br if not
	MOVL	(R2)+,W^SERV_NAME ; reset service name
	MOVL	(R2)+,W^CURRENT_TC ; reset step #
	MOVL	(R2)+,W^MODE	; reset the mode
	MOVZBL	(R2)+,R3	; get the longword count
	MOVL	R3,R4		; and save it
20$:
	PUSHL	(R2)+		; push a parameter
	SOBGTR	R3,20$		; and push them all
	CALLS	R4,W^PRINT_FAIL	; print the failure
	BRB	10$		; do the next one
30$:
	MOVAL	W^ERLB,W^ELBP	; reset the buffer pointer
	CLRL	W^ERLB		; set fresh terminater
	RET			; bail out
.PAGE
.PAGE
	.SBTTL	MODE_ID
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to identify the mode that an exit handler is in.
;
; CALLING SEQUENCE:
;	CALLS	#0,W^MODE_ID
;
; INPUT PARAMETERS:
;	MODE contains an address pointing to an ascii string desc.
;	of the current CPU mode.
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

MODE_ID:
	.WORD	^M<R2,R3,R4,R5>
	$FAO_S	W^CS5,W^MESSAGEL,W^MSGL,MODE ; format the error message
	$PUTMSG_S W^MSGVEC		; print the mode message
	RET
	.SBTTL POWER_CHECK
;++
; FUNCTIONAL DESCRIPTION:
;	Subroutine to check the effects of the SETPRA system service and
;	report any errors that might occur.
;
; CALLING SEQUENCE:
;	PUSHL	#PSL$C_????		; push expected mode
;	CALLS	#1,W^POWER_CHECK
;
; INPUT PARAMETERS:
;	4(AP) = expected access mode
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

POWER_CHECK:
	.WORD	^M<R5,R6>
	MOVAL	CTL$GL_POWERAST,R6		; set checking address
	CMPL	(R6),W^HANDLER_ADR		; is the address there?
	BEQL	10$				; br if yes
	PUSHL	(R6)				; push received data
	PUSHL	W^HANDLER_ADR			; push expected data
	PUSHAL	W^ADR				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the error
10$:
	CMPB	4(R6),4(AP)			; is the mode correct?
	BEQL	20$				; br if yes
	MOVZBL	4(R6),-(SP)			; push received data
	MOVZBL	4(AP),-(SP)			; push expected data
	PUSHAL	W^MS				; push string variable
	CALLS	#3,W^PRINT_FAIL			; print the error
20$:
	RET					; bail out
.PAGE
	.SBTTL	AST_FAIL
;++
; FUCTIONAL DESCRIPTION:
;	Subroutine to identify an AST failure.
;
; CALLING SEQUENCE:
;	CALLS #0,W^AST_FAIL
;
; INPUT PARAMETERS:
;	MODE		contains an address pointing to an ascii string desc.
;			of the current CPU mode.
;	CURRENT_TC	contains the current test case number.
;	ASTOK		contains expected or unexpected flag.
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

AST_FAIL:
	.WORD	^M<R2,R3,R4,R5>
	CALLS #0,W^STORE_STEP			; store step information
	MOVL	W^ELBP,R2			; get error log buffer pointer
	MOVB	#1,(R2)+			; save the longword count
	BBC	#1,W^ASTOK,10$			; br if unexpected exception
	MOVAL	W^CS6,(R2)+			; save the string variable
	BRB	20$				; skip other message
10$:
	MOVAL	W^CS4,(R2)+			; save the string variable
20$:
	CLRL	(R2)				; set a new terminator
	MOVL	R2,W^ELBP			; reset buffer pointer
	RET
	.SBTTL	ILEGAL_TIM
;++
; FUCTIONAL DESCRIPTION:
;	AST routine to report an illegal TQE.
;
; CALLING SEQUENCE:
;	Entered via a SETIMR AST
;
; INPUT PARAMETERS:
;	MODE		contains an address pointing to an ascii string desc.
;			of the current CPU mode.
;	CURRENT_TC	contains the current test case number.
;	ASTOK		contains expected or unexpected flag.
;
; OUTPUT PARAMETERS:
;	NONE
;
;--

ILEGAL_TIM:
	.WORD	^M<R2,R3,R4,R5>
	CALLS #0,W^STORE_STEP			; store step information
	MOVL	W^ELBP,R2			; get erl buf pntr
	MOVB	#1,(R2)+			; save the longword count
	MOVAL	W^CS7,(R2)+			; save the string variable
	CLRL	(R2)				; set a new terminator
	MOVL	R2,W^ELBP			; reset the buffer pntr
	RET
	.SBTTL STORE_STEP
;++
; FUNCTIONAL DESCRIPTION:
;	Routine to store step information in the error log buffer.
;
; CALLING SEQUENCE:
;	CALLS #0,W^STORE_STEP
;
; INPUT PARAMETERS:
;	ELBP = current errlog buffer pointer
;
; OUTPUT PARAMETERS:
;	FLAG = error logged flag
;
;--

STORE_STEP:
	.WORD	^M<R2>
	BISB2	#1,W^FLAG		; set the error logged flag
	MOVL	W^ELBP,R2		; get errlog buf pntr
	MOVL	W^SERV_NAME,(R2)+	; save the service name
	MOVL	W^CURRENT_TC,(R2)+	; save the step number
	MOVL	W^MODE,(R2)+		; save the mode
	MOVL	R2,W^ELBP		; reset the errlog buf pntr
	RET				; return
.PAGE
MOD_MSG_PRINT:
;
;  *****************************************************************
;  *                                                               *
;  *  PRINTS THE TEST MODULE BEGUN/SUCCESSFUL/FAILED MESSAGES      *
;  *	   (USING THE PUTMSG MACRO).                               *
;  *                                                               *
;  *****************************************************************
;
	PUTMSG	<MOD_MSG_CODE,#2,TMN_ADDR,TMD_ADDR> ; PRINT MSG
	RSB				; ... AND RETURN TO CALLER
;
CHMRTN:
; ******************************************************************
; *								   *
; *	CHANGE MODE ROUTINE. THIS ROUTINE GETS CONTROL WHENEVER    *
; *	A CMKRNL, CMEXEC, OR CMSUP SYSTEM SERVICE IS ISSUED	   *
; *	BY THE MODE MACRO ('TO' OPTION).  IT MERELY DOES 	   *
; *	A JUMP INDIRECT ON A FIELD SET UP BY MODE. IT HAS 	   *
; *	THE EFFECT OF RETURNING TO THE END OF THE MODE		   *
; *	MACRO EXPANSION.					   *
; *								   *
; ******************************************************************
;
	.WORD	0			; ENTRY MASK
	JMP	@CHM_CONT		; RETURN TO MODE MACRO IN NEW MODE
;
; *	RET INSTR WILL BE ISSUED IN EXPANSION OF 'MODE FROM, ....' MACRO
;
	.END	SATSSS26
