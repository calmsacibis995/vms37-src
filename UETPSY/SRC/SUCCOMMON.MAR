	.TITLE	SUCCOMMON SATS SYSTEM SERVICE TESTS   COMMON (SUCC S.C.)
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSTST (SATS SYSTEM SERVICE TESTS)
;
; ABSTRACT:
;
;		THE SUCCOMMON MODULE CONTAINS SUBROUTINES WHICH, WHEN
; LINKED WITH EACH OF THE OBJECT MODULES SATSSS__.OBJ, FORM THE TEST
; MODULES SATSSS__.EXE TO TEST SUCCESSFUL OPERATION OF THE VMS SYSTEM
; SERVICES. THE SUCCOMMON MODULE CONTAINS SEVERAL COMMON SUBROUTINES
; USED BY EACH OF THE SATSSS__ MODULES PLUS THE SUCCOMMON ROUTINE,
; WHICH DISTRIBUTES CONTROL TO ALL SUBROUTINES.
;
; ENVIRONMENT:	USER MODE IMAGE; NEEDS CMKRNL PRIVILEGE,
;		DYNAMICALLY ACQUIRES OTHER PRIVILEGES, AS NEEDED.
;
; AUTHOR: THOMAS L. CAFARELLA,		CREATION DATE: APR, 1977
;
; MODIFIED BY:
;
;	, : VERSION
; 01	- 
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$STSDEF				; DEFINE MSG CODE SYMBOLS
	$UETPDEF			; GENERATE UETP MESSAGE DEFS
	$SHR_MESSAGES UETP,116,<<TEXT,INFO>> ; DEFINE UETP$_TEXT MSG
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
WARNING		= 0			; WARNING SEVERITY VALUE
SUCCESS		== 1			; SUCCESS SEVERITY VALUE
ERROR		= 2			; ERROR SEVERITY VALUE
INFO		= 3			; INFORMATIONAL SEVERITY VALUE
SEVERE		= 4			; SEVERE (FATAL) SEVERITY VALUE
BUFFL		= 130			; LENGTH OF FAO OUTPUT BUFFER
CMPC_SAV	== ^M<R2,R3>		; REGISTER SAVE MASK FOR CMPC INSTRUCTION
R0_THRU_SP	== ^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP,SP>
;
; OWN STORAGE:
;
	.PAGE
	.PSECT	ROD_COMM,RD,NOWRT,NOEXE,LONG
ONES::		.LONG	-1,-1		; A QUADWORD OF 1 BITS
TEST_MOD_BEG:	STRING	C,<begun>	; DISPOSITION FIELD OF TEST MOD MSG
TEST_MOD_SUCC::	STRING	C,<successful>	; DISPOSITION FIELD OF TEST MOD MSG
TEST_MOD_FAIL:	STRING	C,<failed>	; DISPOSITION FIELD OF TEST MOD MSG
MSG2_CND_CTL1:	STRING	I,<!15* !AC: !AC> ; FIRST FORM OF MSG2
MSG2_CND_CTL2:	STRING	I,<!15* !AC ARGUMENT; !AC: !AS>
					; SECOND FORM OF MSG2
MSG2_CND_CTL3:	STRING	I,<!15* !AC ARGUMENT; !AC: !#(#XL)>
					; THIRD FORM OF MSG2
					; NOTE MSG3_ERR_CTL IS IN A DIFF PSECT
MSG4_ERR_CTL1:	STRING	I,<!15* !AC VALUE: !AS> 
					; FIRST FORM FOR MSG4
MSG4_ERR_CTL2:	STRING	I,<!15* !AC VALUE: !#(#XL)> 
					; 2ND FORM FOR MSG4
EXP:		STRING	C,<EXPECTED>	; COUNTED STRING FOR MSG4
REC:		STRING	C,<RECEIVED>	; COUNTED STRING FOR MSG4
APC:		STRING	C,<APPROXIMATE PC> ; COUNTED STRING FOR MSG 4
	.PAGE
	.PSECT	RWD_COMM,RD,WRT,NOEXE,LONG
REG_SAVE_AREA:	.BLKL	15		; SAVE AREA FOR ALL REGS (SANS PC)
TESTNUM::	.WORD	0		; SEQUENTIAL TEST NUMBER
CHM_CONT::	.BLKL	1		; CHANGE MODE CONTINUE ADDRESS
MOD_MSG_CODE::	.LONG	UETP$_SATSMS	; TEST MODULE MSG CODE FOR PUTMSG
TMN_ADDR:	.ADDRESS TEST_MOD_NAME	; ADDR OF TEST MOD NAME FOR FAO
TMD_ADDR::	.ADDRESS TEST_MOD_BEG	; ADDR OF T.M. DISP FIELD FOR FAO
FAO_LEN::	.BLKL	1		; ACTUAL LENGTH RETURNED BY FAO
FAO_DESC::	STRING	O,BUFFL		; BUFFER INTO WHICH FAO CREATES STRING
MSG_CTXT::	.BLKB	1		; CONTEXT VALUE FOR ITEMS IN MESSAGES
MSG_DATA1::	.BLKL	1		; INPUT PARAMETER FOR VARIOUS MSG WRITE RTNS
MSG_A::		.BLKL	1		; LONGWORD PARAMETER USED BY FAO
MSG_B::		.BLKL	1		; LONGWORD PARAMETER USED BY FAO
MSG_C:		.BLKL	1		; LONGWORD PARAMETER USED BY FAO
MSG_D:		.BLKL	1		; LONGWORD PARAMETER USED BY FAO
;
; NOTE -- FOLLOWING TWO PARAMETERS ARE INITIALIZED TO ENSURE 
;         ACCESSIBILITY WHEN FAO SYSTEM SERVICE REFERENCES
;         THEIR CONTENTS.
;
MSG_E:		.ADDRESS MSG_E		; LONGWORD PARAMETER USED BY FAO
MSG_F:		.ADDRESS MSG_F		; LONGWORD PARAMETER USED BY FAO
EXPV::		.BLKQ	1		; EXPECTED VALUE FOR VERIFY ROUTINE
RECV::		.BLKQ	1		; RECEIVED VALUE FOR VERIFY ROUTINE
PCV::		.BLKL	1		; SAVE AREA FOR PC VALUE
CFLAG::		.BYTE	0		; CONDITIONS FLAG: ZERO MEANS NO CONDS MSG
EFLAG::		.BYTE	0		; ERROR FLAG: ZERO MEANS NO ERRORS YET
CONFLICT::	.BLKB	1		; CONFLICT INDICATOR ; 0 MEANS ... 
					; ... NO CONDITION TABLE CONFLICT
	.PSECT	SUCCOMMON,RD,WRT,EXE
	.PAGE
	.SBTTL	SUCCOMMON
;++
; FUNCTIONAL DESCRIPTION:
;
;		THE SUCCOMMON ROUTINE IS ENTERED WHENEVER A SATS TEST
; MODULE IS RUN TO TEST ONE OR MORE SYSTEM SERVICE(S), EXPECTING SUCCESS
; STATUS CODES. THE BASIC FUNCTION OF THE ROUTINE IS TO CAUSE MULTIPLE
; INVOCATIONS OF THE VERIFY SUBROUTINE, WHICH ISSUES AND VERIFIES THE
; SUBJECT SYSTEM SERVICE(S). FOLLOWING THE INVOCATIONS, THE ROUTINE EXITS
; TO THE OPERATING SYSTEM WITH A STATUS CODE INDICATING SUCCESS OR FAILURE
; OF THE TEST MODULE. VERIFY IS CALLED ONCE FOR EACH COMBINATION OF
; VALUES IN THE CONDITION TABLES. THERE MAY BE FROM ONE TO FIVE CONDITION
; TABLES, WITH FROM ONE TO FIVE ENTRIES EACH. THEREFORE VERIFY MAY BE
; CALLED FROM 1 TO 3125 TIMES, DEPENDING ON THE QUANTITY AND SIZES OF
; THE CONDITION TABLES. EACH TABLE REPRESENTS A VARIABLE IN SYSTEM
; SERVICE SPECIFICATION OR SYSTEM ENVIRONMENT; A TYPICAL EXAMPLE OF
; A VARIABLE IS ONE OF THE SYSTEM SERVICE INPUT ARGUMENTS. EACH TABLE
; ENTRY (ELEMENT) REPRESENTS A VALUE FOR THE VARIABLE REPRESENTED BY
; THE TABLE. THE CURRENTLY SELECTED ELEMENT FOR EACH TABLE IS REPRESENTED
; BY A VALUE (FROM 1 TO 5) IN AN INDEX REGISTER (R2-R6 FOR CONDITION
; TABLES 1-5, RESPECTIVELY). SUCCOMMON CONTAINS A CALL TO THE VERIFY
; SUBROUTINE AT THE CENTER OF A GROUP OF NESTED LOOPS, ONE LOOP FOR EACH
; TABLE. THEREFORE, UPON EACH ENTRY TO VERIFY, REGISTERS R2-R6 CONTAIN
; VALUES REPRESENTING ONE COMBINATION OF CONDITION TABLE VALUES. AS A 
; NEW ENTRY IN EACH TABLE IS SELECTED, A CONDITION TABLE SETUP SUBROUTINE
; IS CALLED (COND1,2,3,4,5) TO ALLOW TABLE-SPECIFIC SETUP CODE TO BE
; EXECUTED; ALSO, BEFORE ENTERING THE LOOP, SUCCOMMON CALLS A SETUP
; ROUTINE (TM_SETUP) TO EXECUTE TEST-MODULE-SPECIFIC SETUP CODE,
; APPLICABLE ACROSS ALL CONDITION TABLES. EACH OF THE SETUP SUBROUTINES 
; AND THE VERIFY SUBROUTINE HAVE ASSOCIATED CLEANUP SUBROUTINES,
; EACH OF WHICH IS EXECUTED FOLLOWING VERIFY, ONCE FOR EACH EXECUTION
; OF ITS CORRESPONDING SETUP ROUTINE. THIS STRUCTURE GUARANTEES THAT
; CLEANUP (OF ACQUIRED RESOURCES, FOR EXAMPLE) IS ALWAYS PERFORMED FOR
; EACH SETUP, EVEN IN THE CASE WHERE AN ERROR PREMATURELY TERMINATES
; EXECUTION OF THE TEST MODULE. THE FIRST CALL TO VERIFY WHICH FINDS
; AN ERROR CAUSES TERMINATION OF THE TEST MODULE WITH A "TEST MODULE
; FAILED" MESSAGE.
;
; CALLING SEQUENCE:
;
;	$ RUN SATSSS__  ...  (DCL COMMAND)
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	MESSAGES TO SYS$OUTPUT ARE THE ONLY OUTPUT FROM SUCCOMMON.
;	THEY ARE OF THE FORM:
;		
;		%UETP-S-SATSMS, TEST MODULE SATSSS__ BEGUN ... (BEGIN MSG)
;		%UETP-S-SATSMS, TEST MODULE SATSSS__ SUCCESSFUL ... (END MSG)
;		%UETP-E-SATSMS, TEST MODULE SATSSS__ FAILED ... (END MSG)
;		%UETP-I-TEXT, ... (VARIABLE INFORMATION ABOUT A TEST MODULE FAILURE)
;
; COMPLETION CODES:
;
;	THE SUCCOMMON ROUTINE TERMINATES WITH A $EXIT TO THE
;	OPERATING SYSTEM WITH A STATUS CODE DEFINED BY UETP$_SATSMS.
;
; SIDE EFFECTS:
;
;	NONE
;
;--



SUCCOMMON:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
					; ENTRY MASK
	BSBW	TM_SETUP		; PERFORM TEST MODULE SETUP
	TSTB	EFLAG			; IS ERROR BEING PROCESSED ?
	BEQL	10$			; NO -- CONTINUE
	BRW	TM_CU			; YES -- PERFORM TEST MODULE CLEANUP
10$:
	CLRL	R2			; POINT TO FIRST ELEMENT IN CONDITION 1 TAB
COND1_LOOP:
	CLRB	CONFLICT		; INDICATE NO CONDITION TABLE CONFLICT
	BSBW	COND1			; EXECUTE CONDITION 1 ROUTINE
	TSTB	EFLAG			; IS AN ERROR BEING PROCESSED ?
	BEQL	10$			; NO -- CONTINUE
	BRW	COND1_CU		; YES -- PERFORM CONDITION 1 CLEANUP
10$:
	TSTB	CONFLICT		; WAS THERE A CONDITION TABLE CONFLICT ?
	BEQL	20$			; NO -- CONTINUE
	BRW	COND1_CU		; YES -- SKIP THIS ELEMENT IN CONDIT 1 TABLE
20$:
	CLRL	R3			; POINT TO FIRST ELEMENT IN CONDITION 2 TAB
COND2_LOOP:
	CLRB	CONFLICT		; INDICATE NO CONDITION TABLE CONFLICT
	BSBW	COND2			; EXECUTE CONDITION 2 ROUTINE
	TSTB	EFLAG			; IS AN ERROR BEING PROCESSED ?
	BEQL	10$			; NO -- CONTINUE
	BRW	COND2_CU		; YES -- GO PERFORM CONDITION 2 CLEANUP
10$:
	TSTB	CONFLICT		; WAS THERE A CONDITION TABLE CONFLICT ?
	BEQL	20$			; NO -- CONTINUE
	BRW	COND2_CU		; YES -- SKIP THIS ELEMENT IN CONDIT 2 TABLE
20$:
	CLRL	R4			; POINT TO FIRST ELEMENT IN CONDITION 3 TAB
COND3_LOOP:
	CLRB	CONFLICT		; INDICATE NO CONDITION TABLE CONFLICT
	BSBW	COND3			; EXECUTE CONDITION 3 ROUTINE
	TSTB	EFLAG			; IS AN ERROR BEING PROCESSED ?
	BNEQ	COND3_CU		; YES -- GO PERFORM CONDITION 3 CLEANUP
	TSTB	CONFLICT		; WAS THERE A CONDITION TABLE CONFLICT ?
	BNEQ	COND3_CU		; YES -- SKIP THIS ELEMENT IN CONDIT 3 TABLE
	CLRL	R5			; POINT TO FIRST ELEMENT IN CONDITION 4 TAB
COND4_LOOP:
	CLRB	CONFLICT		; INDICATE NO CONDITION TABLE CONFLICT
	BSBW	COND4			; EXECUTE CONDITION 4 ROUTINE
	TSTB	EFLAG			; IS AN ERROR BEING PROCESSED ?
	BNEQ	COND4_CU		; YES -- GO PERFORM CONDITION 4 CLEANUP
	TSTB	CONFLICT		; WAS THERE A CONDITION TABLE CONFLICT ?
	BNEQ	COND4_CU		; YES -- SKIP THIS ELEMENT IN CONDIT 4 TABLE
	CLRL	R6			; POINT TO FIRST ELEMENT IN CONDITION 5 TAB
COND5_LOOP:
	CLRB	CONFLICT		; INDICATE NO CONDITION TABLE CONFLICT
	BSBW	COND5			; EXECUTE CONDITION 5 ROUTINE
	TSTB	EFLAG			; IS AN ERROR BEING PROCESSED ?
	BNEQ	COND5_CU		; YES -- GO PERFORM CONDITION 5 CLEANUP
	TSTB	CONFLICT		; WAS THERE A CONDITION TABLE CONFLICT ?
	BNEQ	COND5_CU		; YES -- SKIP THIS ELEMENT IN CONDIT 5 TABLE
	BSBW	VERIFY			; ISSUE SYSTEM SERVICE AND VERIFY IT
	BSBW	VFY_CLEANUP		; PERFORM VERIFY CLEANUP
	INCW	TESTNUM			; GET NEXT TEST CASE NUMBER
COND5_CU:
	BSBW	COND5_CLEANUP		; PERFORM CONDITION 5 CLEANUP
	ACBB	COND5_H,#1,R6,COND5_LOOP ; LOOP THRU CONDITION 5 TABLE
COND4_CU:
	BSBW	COND4_CLEANUP		; PERFORM CONDITION 4 CLEANUP
	ACBB	COND4_H,#1,R5,COND4_LOOP ; LOOP THRU CONDITION 4 TABLE
COND3_CU:
	BSBW	COND3_CLEANUP		; PERFORM CONDITION 3 CLEANUP
	ACBB	COND3_H,#1,R4,COND3_LOOP ; LOOP THRU CONDITION 3 TABLE
COND2_CU:
	BSBW	COND2_CLEANUP		; PERFORM CONDITION 2 CLEANUP
	ACBB	COND2_H,#1,R3,COND2_LOOP ; LOOP THRU CONDITION 2 TABLE
COND1_CU:
	BSBW	COND1_CLEANUP		; PERFORM CONDITION 1 CLEANUP
	ACBB	COND1_H,#1,R2,COND1_LOOP ; LOOP THRU CONDITION 1 TABLE
TM_CU:
	BSBW	TM_CLEANUP		; PERFORM TEST MODULE CLEANUP
	INSV	#1,#STS$V_INHIB_MSG,#1,MOD_MSG_CODE 
					; INHIBIT PRINTING
	$EXIT_S	MOD_MSG_CODE		; EXIT TO OPERATING SYSTEM WITH MSG CODE
	.PAGE
	.SBTTL	SUBROUTINES
WRITE_MSG2::
;
;++
; **********************************************************
; *
; *	WRITE_MSG2 SUBROUTINE.  THIS ROUTINE FORMATS (USING FAO)
; *	AND PRINTS (USING PUTMSG MACRO) INFORMATION ABOUT THE
; *	CURRENT ELEMENT FOR A PARTICULAR CONDITION TABLE.
; *
; *	INPUTS:
; *		MSG_A:		A LONGWORD FIELD CONTAINING
; *				THE ADDRESS OF A COUNTED
; *				STRING FOR THE TITLE OF THIS
; *				CONDITION.
; *
; *		MSG_B:		A LONGWORD FIELD CONTAINING
; *				THE ADDRESS OF A COUNTED
; *				STRING FOR THE CURRENT TEXT
; *				ELEMENT FOR THIS CONDITION.
; *
; *		MSG_CTXT:	A BYTE FIELD CONTAINING THE
; *				CONTEXT FOR THIS CONDITION,
; *				AS DEFINED IN ITS CONDITION
; *				TABLE.
; *
; *		MSG_DATA1:	A LONGWORD FIELD CONTAINING
; *				THE ADDRESS OF THE CURRENT
; *				DATA ELEMENT FOR THIS CONDITION
; *				(ONLY FOR CONDITIONS WHICH
; *				ARE SYSTEM SERVICE ARGUMENTS).
; *
; *	OUTPUTS:
; *		CONDITION MESSAGE IS PRINTED.
; *
; ***********************************************************  
;--
;
	CMPB	MSG_CTXT,#NOTARG 	; IS THIS CONDITION A S.S. ARGUMENT ?
	BNEQU	10$			; YES -- CONTINUE
	$FAO_S	MSG2_CND_CTL1,FAO_LEN,FAO_DESC,MSG_A,MSG_B
					; NO -- SIMPLY FORMAT TEXT
	BRW	WRITE_MSG2X		; ... WRITE MSG AND EXIT
10$:
	CMPB	MSG_CTXT,#DESC		; IS THIS A STRING DESCRIPTOR ARGUMENT ?
	BNEQU	20$			; NO -- CONTINUE
	MOVL	MSG_DATA1,MSG_C		; YES -- GIVE DESCRIPTOR ADDRESS TO FAO
	$FAO_S	MSG2_CND_CTL2,FAO_LEN,FAO_DESC,MSG_A,MSG_B,MSG_C
					; FORMAT STRING ARGUMENT
	BRW	WRITE_MSG2X		; ... WRITE MSG AND EXIT
20$:
	MOVL	MSG_DATA1,MSG_E		; GET DATA ADDRESS READY FOR FAO
	CMPB	MSG_CTXT,#QUAD		; DOES THIS ARGUMENT HAVE QUAD CONTEXT ?
	BNEQU	30$			; NO -- GO PROCESS ALL OTHER CONTEXTS
	MOVZBL	#2,MSG_C		; YES -- INDICATE 2 DATA ITEMS TO FORMAT
	MOVZBL	#9,MSG_D		; ... EACH 8 BYTES LONG + A BLANK
	ADDL3	#4,MSG_E,MSG_F		; COMPUTE ADDR OF 2ND ITEM FOR FAO
	BRB	40$			; ... AND GO FORMAT MSG
30$:
	MOVZBL	#1,MSG_C		; INDICATE JUST 1 DATA ITEM TO FORMAT
	MOVZBL	MSG_CTXT,MSG_D		; GET CONTEXT READY FOR FAO
	ADDL2	MSG_D,MSG_D		; ... DOUBLE IT FOR LENGTH OF PRINTABLE DATA
40$:
	$FAO_S	MSG2_CND_CTL3,FAO_LEN,FAO_DESC,MSG_A,	-
		MSG_B,MSG_C,MSG_D,@MSG_E,@MSG_F
					; FORMAT NON-STRING ARGUMENT MSG
WRITE_MSG2X:
	BSBW	OUTPUT_MSG		; WRITE FORMATTED CONDITION MSG
	RSB				; ... AND RETURN TO CALLER
	.PAGE
WRITE_MSG3:
;
;++
; *********************************************************
; *
; *	WRITE_MSG3 SUBROUTINE.  THIS ROUTINE FORMATS AND
; *	PRINTS A GENERAL ERROR MSG.  IT IS CALLED BY CODE
; *	GENERATED IN THE EXPANSION OF THE ERR_EXIT MACRO.
; *
; *	INPUTS:
; *		TESTNUM:	A WORD FIELD CONTAINING THE
; *				CURRENT TEST CASE NUMBER.
; *		MSG_A		A LONGWORD FIELD CONTAINING
; *				THE ADDRESS OF A QUADWORD
; *				STRING DESCRIPTOR WHICH HAS
; *				TEXT DESCRIBING THE CURRENT
; *				ERROR.
; *
; *	OUTPUTS:
; *		ERROR MSG FORMATTED AND PRINTED.
; *
; **********************************************************
;--
;
	$FAO_S	MSG3_ERR_CTL,FAO_LEN,FAO_DESC,TESTNUM,MSG_A
					; FORMAT GENERAL ERROR MSG
	BSBW	OUTPUT_MSG		; ... AND WRITE IT
	RSB				; RETURN TO CALLER
	.PAGE
WRITE_MSG4:
;
;++
; *******************************************************
; *
; *	WRITE_MSG4 SUBROUTINE.  THIS ROUTINE FORMATS AND
; *	PRINTS MESSAGES CONTAINING EXPECTED AND RECEIVED
; *	VALUES FOR A DATA ITEM DISCOVERED TO BE IN ERROR
; *	BY THE VERIFY SUBROUTINE.  A MESSAGE CONTAINING
; *	THE APPROXIMATE VALUE OF PC AT THE TIME OF ERROR
; *	IS ALSO FORMATTED AND PRINTED.
; *
; *	INPUTS:
; *		MSG_CTXT:	A BYTE FIELD CONTAINING THE
; *				CONTEXT FOR THE DATA ITEM
; *				IN ERROR.
; *
; *		EXPV:		A QUADWORD FIELD CONTAINING
; *				THE EXPECTED VALUE FOR THE
; *				DATA ITEM IN ERROR.
; *
; *		RECV:		A QUADWORD FIELD CONTAINING
; *				THE RECEIVED VALUE FOR THE
; *				DATA ITEM IN ERROR.
; *
; *		PCV:		A LONGWORD FIELD CONTAINING
; *				THE VALUE OF PC AT OR SOON 
; *				AFTER THE ERROR.
; *
; *	OUTPUTS:
; *		EXPECTED/RECEIVED/PC MESSAGES FORMATTED AND PRINTED.
; *
; **************************************************************
;--
;
	MOVAL	EXP,MSG_A		; READY "EXPECTED" TEXT FOR FAO
	MOVAL	EXPV,MSG_D		; GET ADDR OF EXPECTED VALUE READY FOR FAO
	CMPB	MSG_CTXT,#DESC		; IS FAILING DATA ITEM A STRING DESCRIPTOR ?
	BNEQU	10$			; NO -- CONTINUE
	BSBW	WRITE_MSG4_1		; YES -- FORMAT & WRITE EXPECTED STRING
	MOVAL	REC,MSG_A		; READY "RECEIVED" TEXT FOR FAO
	MOVAL	RECV,MSG_D		; GET ADDR OF RECEIVED VALUE READY FOR FAO
	BSBW	WRITE_MSG4_1		; FORMAT & WRITE RECEIVED STRING
	BRB	40$			; GO DO PC MESSAGE
10$:
	CMPB	MSG_CTXT,#QUAD		; DOES FAILING DATA ITEM HAVE QUAD CONTEXT ?
	BNEQU	20$			; NO -- HANDLE ALL OTHER CONTEXTS
	MOVZBL	#2,MSG_B		; YES -- INDICATE 2 DATA ITEMS TO FAO
	MOVZBL	#9,MSG_C		; ... EACH ONE 8 BYTES LONG + A BLANK
	ADDL3	#4,MSG_D,MSG_E		; GIVE ADDRESS OF 2ND ITEM TO FAO
	BRB	30$			; ... AND GO FORMAT IT
20$:
	MOVZBL	#1,MSG_B		; INDICATE JUST 1 DATA ITEM TO FAO
	MOVZBL	MSG_CTXT,MSG_C		; GET CONTEXT READY FOR FAO
	ADDL2	MSG_C,MSG_C		; ... DOUBLE CONTEXT TO GET PRINTABLE LENGTH
30$:
	BSBW	WRITE_MSG4_2		; FORMAT & PRINT EXPECTED VALUE OF DATA
	MOVAL	REC,MSG_A		; GIVE ADDRESS OF "RECEIVED" TEXT TO FAO
	MOVAL	RECV,MSG_D		; GIVE ADDR OF RECEIVED VALUE TO FAO
	ADDL3	#4,MSG_D,MSG_E		; GIVE ADDR OF 2ND HALF OF QUAD ITEM TO FAO
	BSBW	WRITE_MSG4_2		; FORMAT & PRINT RECEIVED VALUE OF DATA
40$:
	MOVAL	APC,MSG_A		; READY "APPROXIMATE PC" TEXT FOR FAO
	MOVZBL	#1,MSG_B		; INDICATE JUST 1 DATA ITEM TO FAO
	MOVZBL	#8,MSG_C		; ... USING 8 PRINTABLE BYTES
	MOVAL	PCV,MSG_D		; GIVE ADDRESS OF PC VALUE TO FAO
	BSBW	WRITE_MSG4_2		; FORMAT & PRINT PC VALUE
WRITE_MSG4X:
	RSB				; RETURN TO CALLER
WRITE_MSG4_1:
	$FAO_S	MSG4_ERR_CTL1,FAO_LEN,FAO_DESC,MSG_A,MSG_D
					; FORMAT A STRING
	BSBW	OUTPUT_MSG		; ... AND PRINT IT
	RSB				; RETURN TO CALLER
WRITE_MSG4_2:
	$FAO_S	MSG4_ERR_CTL2,FAO_LEN,FAO_DESC,MSG_A,	-
		MSG_B,MSG_C,@MSG_D,@MSG_E
					; FORMAT A NON-STRING DATA ITEM
	BSBW	OUTPUT_MSG		; ... AND PRINT IT
	RSB				; RETURN TO CALLER
	.PAGE
COMP_SC::
	CMPL	EXPV,RECV		; IS STATUS CODE THE ONE WE EXPECTED ?
	BEQLU	COMP_SCX		; YES -- GO RETURN
	ERR_EXIT   LONG,   -
	  <UNEXPECTED STATUS CODE FROM NON-SUBJECT SYSTEM SERVICE>,,,PCV
					; NO -- ISSUE ERR_EXIT WITH PCV PARAMETER
COMP_SCX:
	RSB				; RETURN TO CALLER (SS_CHECK MACRO)
;
;
PROCESS_ERR::
	MOVB	#1,EFLAG		; INDICATE AN ERROR HAS OCCURRED
	BSBW	HALT_TC			; HALT FURTHER EXECUTION OF TEST CASES
	MOVAL	TEST_MOD_FAIL,TMD_ADDR 	; INDICATE FAILED IN END MSG
	INSV	#ERROR,#0,#3,MOD_MSG_CODE ; ADJUST STATUS CODE FOR ERROR
	BSBW	WRITE_MSG3		; FORMAT & WRITE ERROR MSG
	BSBW	WRITE_MSG4		; WRITE EXP/REC/PC MSGS
	TSTB	CFLAG			; HAVE CONDITIONS ALREADY BEEN PRINTED ?
	BNEQ	PROCESS_ERRX		; YES -- JUST GO RETURN
	BSBW	FORM_CONDS		; NO -- PRINT THEM BEFORE RETURNING
PROCESS_ERRX:
	RSB				; ... AND RETURN TO CALLER (ERR_EXIT MACRO)
OUTPUT_MSG::
;
;  PRINT A MESSAGE FORMATTED BY FAO AND RETURN TO CALLER
;
	MOVW	FAO_LEN,FAO_DESC 	; SET UP ACTUAL LENGTH IN MSG BUFFER
	PUTMSG	<#UETP$_TEXT,#1,#FAO_DESC> ; PRINT THE MSG
	MOVW	#BUFFL,FAO_DESC		; ... AND RESTORE BUFFER TO MAX LENGTH
	RSB
SAVE_REGS::
;
;  SAVE CONTENTS OF REGS R2 THROUGH R6 FOR USE BY CHMRTN
;
	MOVAL	REG_SAVE_AREA,R1 	; INITIALIZE R1 TO BEG OF AREA
	MOVL	R2,(R1)+		; SAVE R2
	MOVL	R3,(R1)+		; SAVE R3
	MOVL	R4,(R1)+		; SAVE R4
	MOVL	R5,(R1)+		; SAVE R5
	MOVL	R6,(R1)+		; SAVE R6
	RSB				; RETURN TO CALLER
REST_REGS::
;
;  RESTORE REGS R2 THROUGH R6 ... USED IN CHMRTN AND IN MODE MACRO
;
	MOVAL	REG_SAVE_AREA,R1 	; INITIALIZE R1 TO BEG OF AREA
	MOVL	(R1)+,R2		; RESTORE R2
	MOVL	(R1)+,R3		; RESTORE R3
	MOVL	(R1)+,R4		; RESTORE R4
	MOVL	(R1)+,R5		; RESTORE R5
	MOVL	(R1)+,R6		; RESTORE R6
	RSB				; RETURN TO CALLER
	.PAGE
HALT_TC:
;
;	HALT FURTHER EXECUTION OF TEST CASES BY STORING CURRENT
;	INDEX REGISTER VALUES INTO TABLE SIZE FIELDS FOR ALL
;	CONDITIONS.
;
	MOVB	R2,COND1_H		; ALTER END OF COND 1 TABLE TO CURR ELEMENT
	MOVB	R3,COND2_H		; ALTER END OF COND 2 TABLE TO CURR ELEMENT
	MOVB	R4,COND3_H		; ALTER END OF COND 3 TABLE TO CURR ELEMENT
	MOVB	R5,COND4_H		; ALTER END OF COND 4 TABLE TO CURR ELEMENT
	MOVB	R6,COND5_H		; ALTER END OF COND 5 TABLE TO CURR ELEMENT
	RSB				; RETURN TO CALLER
MOD_MSG_PRINT::
;
;  *****************************************************************
;  *                                                               *
;  *  PRINTS THE TEST MODULE BEGUN/SUCCESSFUL/FAILED MESSAGES      *
;  *	   (USING THE PUTMSG MACRO).                               *
;  *                                                               *
;  *****************************************************************
;
	PUTMSG	<MOD_MSG_CODE,#2,TMN_ADDR,TMD_ADDR> 
					; PRINT MSG ...
	RSB				; ... AND RETURN TO CALLER
;
CHMRTN::
; **********************************************************
; *
; *	CHANGE MODE ROUTINE. THIS ROUTINE GETS CONTROL WHENEVER
; *	A CMKRNL OR CMEXEC SYSTEM SERVICE IS ISSUED
; *	BY THE MODE MACRO ('TO' OPTION).  IT MERELY RESTORES 
; *	REGISTERS R2 THROUGH R6 AND DOES A JUMP INDIRECT
; *	ON A FIELD SET UP BY MODE.  IT HAS THE EFFECT  
; *	OF RETURNING TO THE END OF THE MODE MACRO EXPANSION.
; *
; *************************************************************
;
	.WORD	0			; ENTRY MASK
	BSBW	REST_REGS		; RESTORE REGS R2-R6
	JMP	@CHM_CONT		; RETURN TO MODE MACRO IN NEW MODE
;
; *	RET INSTRUCTION WILL BE ISSUED IN EXPANSION OF 'MODE FROM, ....' MACRO
;
	.END	SUCCOMMON
