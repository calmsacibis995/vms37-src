	.TITLE	SATSSS60 SATS SYST SRV TESTS  TIME SERVS (SUCC S.C.)
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSTST (SATS SYSTEM SERVICE TESTS)
;
; ABSTRACT:
;
;		THIS MODULE CONTAINS SUBROUTINES WHICH, WHEN LINKED
; WITH SUCCOMMON.OBJ, FORM TEST MODULE SATSSS60 TO TEST SUCCESSFUL
; OPERATION OF THE TIME SYSTEM SERVICES. EACH SERVICE IS INVOKED
; UNDER VARIOUS INPUT CONDITIONS WITH VARYING INPUT PARAMETERS. ONLY
; SUCCESSFUL STATUS CODES ARE EXPECTED IN THIS TEST MODULE.  CORRECT 
; OPERATION OF THE SERVICE FOR EACH OF ITS ISSUANCES IS VERIFIED BY
; CHECKING FOR AN SS$_NORMAL STATUS CODE, EXPECTED RETURN ARGUMENTS
; AND EXPECTED FUNCTIONALITY PERFORMED.
;
; ENVIRONMENT:	USER MODE IMAGE; NEEDS CMKRNL PRIVILEGE,
;		DYNAMICALLY ACQUIRES OTHER PRIVILEGES, AS NEEDED.
;
; AUTHOR: THOMAS L. CAFARELLA,		CREATION DATE: JUN, 1978
;
; MODIFIED BY:
;
;	, : VERSION
; 01	- 
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$PRVDEF				; PRIVILEGE BIT DEFINITIONS
	$PHDDEF				; PROCESS HEADER OFFSETS
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
SHORT_ASC	= 1			; INDICATOR FOR SHORT $ASCTIM OUTPUT
LONG_ASC	= 0			; INDICATOR FOR LONG $ASCTIM OUTPUT
;
; OWN STORAGE:
;
	.PAGE
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
TEST_MOD_NAME::	STRING	C,<SATSSS60>	; TEST MODULE NAME
TEST_MOD_NAME_D: STRING	I,<SATSSS60>	; TEST MODULE NAME DESCRIPTOR
MSG1_INP_CTL:	STRING	I,<  SSTIM!4ZW: CONDITIONS:>
					; FAO CTL STRING FOR MSG1 IN SUCCOMMON.MAR
MSG3_ERR_CTL::	STRING	I,< *SSTIM!4ZW: !AS> 
					; FAO CTL STRING FOR MSG3 IN SUCCOMMON.MAR
;
; TABLE OF TIMBUF STRINGS FOR COND1 TABLE
;
C1_ELT1:	.ASCII	\25-DEC-1973 21:46:00.05\
C1_ELT2:	.ASCII	\31-AUG-2001  01:32:29.94\
C1_ELT3:	.ASCII	\  5753   18:56:01.13 \
C1_ELT4:	.ASCII	\--\
;
STD_TIMADR_BTM:				; TABLE OF STANDARD TIMADR ARGUMENT
					; ... VALUES OUTPUT BY $BINTIM
;
		.LONG	^XA2C67D20	; LOW-ORDER LONGWORD ...  1ST COND 1 ELEMENT
		.LONG	^X00810CAC	; HIGH-ORDER LONGWORD ... 1ST COND 1 ELEMENT
		.LONG	^X4347A340	; LOW-ORDER LONGWORD ...  2ND COND 1 ELEMENT
		.LONG	^X00A01545	; HIGH-ORDER LONGWORD ... 2ND COND 1 ELEMENT
		.LONG	^X2A513360	; LOW-ORDER LONGWORD ...  3RD COND 1 ELEMENT
		.LONG	^XFFEE56A7	; HIGH-ORDER LONGWORD ... 3RD COND 1 ELEMENT
;
STD_TIMBUF_ATMS:			; TABLE OF STANDARD TIMBUF ARGUMENT
					; ... VALUES OUTPUT BY $ASCTIM (SHORT)
					; NOTE -- WILL SKIP CHECKING HUNDREDTHS
					; ... OF A SECOND DUE TO ROUNDING ERROR
;
		.LONG	10,S_T_A_DATA+12 ; STRING DESCRIPTOR FOR 1ST COND 1 ELEMENT
		.LONG	10,S_T_A_DATA+34 ; STRING DESCRIPTOR FOR 2ND COND 1 ELEMENT
		.LONG	10,S_T_A_DATA+49 ; STRING DESCRIPTOR FOR 3RD COND 1 ELEMENT
;
STD_TIMBUF_ATML:			; TABLE OF STANDARD TIMBUF ARGUMENT
					; ... VALUES OUTPUT BY $ASCTIM (LONG)
					; NOTE -- WILL SKIP CHECKING HUNDREDTHS
					; ... OF A SECOND DUE TO ROUNDING ERROR
;
		.LONG	22,S_T_A_DATA	 ; STRING DESCRIPTOR FOR 1ST COND 1 ELEMENT
		.LONG	22,S_T_A_DATA+22 ; STRING DESCRIPTOR FOR 2ND COND 1 ELEMENT
		.LONG	15,S_T_A_DATA+44 ; STRING DESCRIPTOR FOR 3RD COND 1 ELEMENT
;
S_T_A_DATA:				; TABLE OF STRINGS FOR THE STD_TIMBUF_ATM
					; ... DESCRIPTORS ABOVE
;
		.ASCII	\25-DEC-1973 21:46:00.0\
		.ASCII	\31-AUG-2001 01:32:29.9\
		.ASCII	\5753 18:56:01.1\
;
STD_TIMBUF_NMT:				; TABLE OF ADDRESSES FOR STANDARD TIMBUF
					; ... ARGUMENT VALUES OUTPUT BY $NUMTIM
;
		.ADDRESS S_T_N_DATA	; ADDRESS OF BUFFER FOR 1ST COND 1 ELEMENT
		.ADDRESS S_T_N_DATA+14	; ADDRESS OF BUFFER FOR 2ND COND 1 ELEMENT
		.ADDRESS S_T_N_DATA+28	; ADDRESS OF BUFFER FOR 3RD COND 1 ELEMENT
;
S_T_N_DATA:				; TABLE OF 7-WORD BUFFERS POINTED TO BY
					; ... THE STD_TIMBUF_NMT ADDRESSES ABOVE
;
		.WORD	1973,12,25,21,46,0,5
		.WORD	2001,8,31,1,32,29,94
		.WORD	0,0,5753,18,56,1,13
	.PAGE
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
PRIVMASK:	.BLKQ	1		; ADDR OF PRIVILEGE MASK (IN PHD)
TIMADR_BTM:	.BLKQ	1		; TIMADR ARGUMENT FOR $BINTIM
TIMBUF_ATM:	STRING	O,24		; TIMBUF ARGUMENT FOR $ASCTIM
TIMLEN_ATM:	.BLKW	1		; TIMLEN ARGUMENT FOR $ASCTIM
TIMBUF_NMT:	.BLKW	7		; TIMBUF ARGUMENT FOR $NUMTIM
	.PAGE
	.SBTTL	CONDITION TABLES
;
;	***** CONDITION TABLES FOR TIME SYSTEM SERVICES *****
;
	COND	1,DESC,<TIMBUF>,-
		  <DATE IN PAST (INPUT TO $BINTIM)>,-
		  <DATE IN FUTURE (INPUT TO $BINTIM)>,-
		  <DELTA TIME INTERVAL (INPUT TO $BINTIM)>,-
		  <CURRENT TIME (INPUT TO $BINTIM)>,-
		  <CURRENT TIME (FROM $GETTIM)>,-
 
		    .LONG	23	; LENGTH OF STRING
		    .ADDRESS	C1_ELT1	; ADDRESS OF STRING
		    .LONG	24	; LENGTH OF STRING
		    .ADDRESS	C1_ELT2	; ADDRESS OF STRING
		    .LONG	21	; LENGTH OF STRING
		    .ADDRESS	C1_ELT3	; ADDRESS OF STRING
		    .LONG	2	; LENGTH OF STRING
		    .ADDRESS	C1_ELT4	; ADDRESS OF STRING
		    .LONG	0,0	; NO DESCRIPTOR FOR THIS TABLE ELEMENT
;
	COND	2,LONG,<CVTFLG>,-
		  <SHORT FORM OF $ASCTIM OUTPUT>,-
		  <LONG FORM OF $ASCTIM OUTPUT>,-
 
		    .LONG	SHORT_ASC ; THE SHORT AND ...
		    .LONG	LONG_ASC  ; ... LONG OF IT
;
	COND	3,NULL
 
	COND	4,NULL
 
	COND	5,NULL
 
	.PSECT	SATSSS60,RD,WRT,EXE
	.PAGE
	.SBTTL	TM_SETUP, TM_CLEANUP
;++
; FUNCTIONAL DESCRIPTION:
;
;		TM_SETUP AND TM_CLEANUP ARE CALLED TO PERFORM
; REQUIRED HOUSEKEEPING AT THE BEGINNING AND END, RESPECTIVELY, OF
; TEST MODULE EXECUTION.
;
; CALLING SEQUENCE:
;
;	BSBW TM_SETUP   BSBW TM_CLEANUP
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	TM_SETUP:  COND TABLE INDEX REGISTERS (R2,3,4,5,6) CLEARED;
;		   ALL PRIVILEGES ACQUIRED.
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



TM_SETUP::
	CLRL	R2			; INITIALIZE
	CLRL	R3			; .. CONDITION
	CLRL	R4			; .... TABLE
	CLRL	R5			; ...... INDEX
	CLRL	R6			; ........ REGISTERS
	BSBW	MOD_MSG_PRINT		; PRINT TEST MODULE BEGIN MSG
	MOVAL	TEST_MOD_SUCC,TMD_ADDR	; ASSUME END MSG WILL SHOW SUCCESS
	INSV	#SUCCESS,#0,#3,MOD_MSG_CODE ; ADJUST STATUS CODE FOR SUCCESS
	MODE	TO,5$,KRNL		; KERNEL MODE TO ACCESS PHD
	MOVL	@#CTL$GL_PHD,R9		; GET PROCESS HEADER ADDRESS
	MOVAL	PHD$Q_PRIVMSK(R9),PRIVMASK ; GET PRIV MASK ADDRESS
	MODE	FROM,5$	; BACK TO USER MODE
	PRIV	ADD,ALL			; GET ALL PRIVILEGES
	$SETPRN_S TEST_MOD_NAME_D 	; SET PROCESS NAME
	SS_CHECK  NORMAL		; CHECK STATUS CODE RETURNED FROM SETPRN
	RSB				; RETURN TO MAIN ROUTINE
TM_CLEANUP::
	BSBW	MOD_MSG_PRINT		; PRINT TEST MODULE END MSG
	RSB				; RETURN TO MAIN ROUTINE
	.PAGE
	.SBTTL	CONDITION SUBROUTINES - SETUP AND CLEANUP 
;++
; FUNCTIONAL DESCRIPTION:
;
;		CONDX AND CONDX_CLEANUP ARE SUBROUTINES WHICH ARE EXECUTED
; BEFORE AND AFTER THE VERIFY SUBROUTINE, RESPECTIVELY, WHENEVER A NEW
; CONDITION X VALUE IS SELECTED (SEE FUNCTIONAL DESCRIPTION OF SUCCOMMON
; ROUTINE IN SUCCOMMON.MAR). ANY SETUP FUNCTION PARTICULAR TO THE 
; CONDITION X TABLE IS INCLUDED IN THE CONDX SUBROUTINE AND CLEANED
; UP, IF NECESSARY, IN THE CONDX_CLEANUP SUBROUTINE. THIS INCLUDES,
; ESPECIALLY, CODE TO DETECT CONFLICTS AMONG CURRENT ENTRIES IN TWO
; OR MORE CONDITION TABLES. IF A CONFLICT IS DETECTED, A NON-ZERO
; VALUE IS STORED INTO CONFLICT, WHICH CAUSES THE CALLING ROUTINE
; (SUCCOMMON) TO SKIP THE CURRENT ENTRY IN THE CONDITION X TABLE.
;
; CALLING SEQUENCE:
;
;	BSBW CONDX   BSBW CONDX_CLEANUP
;	  WHERE X = 1,2,3,4,5
;
; INPUT PARAMETERS:
;
;	CONFLICT = 0
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;
; OUTPUT PARAMETERS:
;
;	CONFLICT SET TO NON-ZERO IF COND TABLE CONFLICT DETECTED.
;
; IMPLICIT OUTPUTS:
;
;	R2,3,4,5,6 PRESERVED
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



COND1::
	RSB				; RETURN TO MAIN ROUTINE
COND1_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND2::
	RSB				; RETURN TO MAIN ROUTINE
COND2_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND3::
	RSB				; RETURN TO MAIN ROUTINE
COND3_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND4::
	RSB				; RETURN TO MAIN ROUTINE
COND4_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND5::
	RSB				; RETURN TO MAIN ROUTINE
COND5_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
	.PAGE
	.SBTTL	FORM_CONDS
;++
; FUNCTIONAL DESCRIPTION:
;
; 		FORM_CONDS FORMATS AND PRINTS INFORMATION ABOUT
;  THE CURRENT ELEMENT IN EACH OF THE CONDITION TABLES.
;
; CALLING SEQUENCE:
;
;	BSBW FORM_CONDS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_T - TITLE TEXT FOR CONDX TABLE
;		CONDX_TAB - ELEMENT TEXT FOR CONDX TABLE
;		CONDX_C - CONTEXT OF THE CONDX TABLE
;		CONDX_E - DATA ELEMENTS OF THE CONDX TABLE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



FORM_CONDS::
	$FAO_S	MSG1_INP_CTL,FAO_LEN,FAO_DESC,TESTNUM
					; FORMAT CONDITIONS HEADER MSG
	BSBW	OUTPUT_MSG		; ... AND PRINT IT
	CMPB	#COND1_C,#NULL		; IS CONDITION 1 NULL ?
	BNEQU	10$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
10$:
	MOVAL	COND1_T,MSG_A		; SAVE ADDRESS OF CONDITION 1 TITLE FOR FAO
	MOVL	COND1_TAB[R2],MSG_B 	; SAVE ADDR OF COND 1 CURR TEXT ELT FOR FAO
	MOVB	#COND1_C,MSG_CTXT 	; SAVE CONDITION 1 CONTEXT FOR FAO
	MOV_VAL	COND1_C,COND1_E[R2],MSG_DATA1 ; GIVE COND 1 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 1 MSG
	CMPB	#COND2_C,#NULL		; IS CONDITION 2 NULL ?
	BNEQU	20$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
20$:
	MOVAL	COND2_T,MSG_A		; SAVE ADDRESS OF CONDITION 2 TITLE FOR FAO
	MOVL	COND2_TAB[R3],MSG_B 	; SAVE ADDR OF COND 2 CURR TEXT ELT FOR FAO
	MOVB	#COND2_C,MSG_CTXT 	; SAVE CONDITION 2 CONTEXT FOR FAO
	MOV_VAL	COND2_C,COND2_E[R3],MSG_DATA1 ; GIVE COND 2 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 2 MSG
	CMPB	#COND3_C,#NULL		; IS CONDITION 3 NULL ?
	BNEQU	30$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
30$:
	MOVAL	COND3_T,MSG_A		; SAVE ADDRESS OF CONDITION 3 TITLE FOR FAO
	MOVL	COND3_TAB[R4],MSG_B 	; SAVE ADDR OF COND 3 CURR TEXT ELT FOR FAO
	MOVB	#COND3_C,MSG_CTXT 	; SAVE CONDITION 3 CONTEXT FOR FAO
	MOV_VAL	COND3_C,COND3_E[R4],MSG_DATA1 ; GIVE COND 3 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 3 MSG
	CMPB	#COND4_C,#NULL		; IS CONDITION 4 NULL ?
	BEQLU	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
	MOVAL	COND4_T,MSG_A		; SAVE ADDRESS OF CONDITION 4 TITLE FOR FAO
	MOVL	COND4_TAB[R5],MSG_B 	; SAVE ADDR OF COND 4 CURR TEXT ELT FOR FAO
	MOVB	#COND4_C,MSG_CTXT 	; SAVE CONDITION 4 CONTEXT FOR FAO
	MOV_VAL	COND4_C,COND4_E[R5],MSG_DATA1 ; GIVE COND 4 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 4 MSG
	CMPB	#COND5_C,#NULL		; IS CONDITION 5 NULL ?
	BEQLU	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
	MOVAL	COND5_T,MSG_A		; SAVE ADDRESS OF CONDITION 5 TITLE FOR FAO
	MOVL	COND5_TAB[R6],MSG_B 	; SAVE ADDR OF COND 5 CURR TEXT ELT FOR FAO
	MOVB	#COND5_C,MSG_CTXT 	; SAVE CONDITION 5 CONTEXT FOR FAO
	MOV_VAL	COND5_C,COND5_E[R6],MSG_DATA1 ; GIVE COND 5 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 5 MSG
FORM_CONDSX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	VERIFY
;++
; FUNCTIONAL DESCRIPTION:
;
;		VERIFY IS CALLED ONCE FOR EACH COMBINATION OF CONDITION
; TABLE VALUES (AS DETERMINED BY THE INDEX REGISTERS R2,3,4,5,6 FOR
; COND TABLES 1,2,3,4,5, RESPECTIVELY). VERIFY ESTABLISHES THE CONDITIONS
; SPECIFIED BY THE COND TABLES AND ISSUES THE SUBJECT SYSTEM SERVICE.
;  THEN, THE SUCCESSFUL OPERATION OF THE SERVICE IS VERIFIED
; BY EXAMINING THE STATUS CODE RETURNED, THE VALUES FOR RETURN ARGUMENTS
; AND THE FUNCTIONALITY PERFORMED. THE EXAMINATIONS TAKE THE FORM OF 
; COMPARISONS AGAINST EXPECTED VALUES. ANY FAILING COMPARISON CAUSES AN
; ERR_EXIT MACRO TO BE EXECUTED (EITHER DIRECTLY, OR INDIRECTLY,
; THROUGH THE SS_CHECK MACRO); ERR_EXIT SETS EFLAG TO NON-ZERO,
; PRINTS ERROR MESSAGES AND CAUSES AN IMMEDIATE RSB TO CALLER.
; WHEN ERR_EXIT IS EXECUTED, FURTHER CALLS TO VERIFY ARE SUPPRESSED,
; AND, AFTER EXECUTING CLEANUP SUBROUTINES, THE IMAGE EXITS.
;
; CALLING SEQUENCE:
;
;	BSBW VERIFY
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_E - ADDRESS OF TABLE OF DATA VALUES FOR CONDX
;		  TABLE. IF THE CONTEXT OF TABLE X IS A SYSTEM SERVICE
;		  ARGUMENT, THE ARGUMENT NAME MAY BE USED AS A SYNONYM
;		  FOR CONDX_E.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	VERIFY HAS NO OUTPUT. SINCE ITS PURPOSE IS TO TEST FOR ERRORS,
;	IT MERELY RETURNS TO CALLER NORMALLY AFTER THE TESTS, PROVIDING
;	ALL WERE SUCCESSFUL; IF AN ERROR IS DISCOVERED, RETURN IS VIA
;	AN ERR_EXIT OR SS_CHECK MACRO, BOTH OF WHICH DOCUMENT DETECTED
;	ERRORS.
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



VERIFY::
	TSTB	CFLAG			; SHOULD CONDITIONS BE PRINTED ?
	BEQL	5$			; NO -- CONTINUE
	BSBW	FORM_CONDS		; YES -- FMT & PRINT ALL CONDS FOR THIS T.C.
5$:
	CMPL	R2,#4			; 5TH COND 1 ELEMENT ?
	BEQL	8$			; YES -- ISSUE $GETTIM INSTEAD OF $BINTIM
	BRW	15$			; NO -- GO ISSUE $BINTIM
8$:
;
; ****** SYSTEM SERVICE CALL WHICH IS THE SUBJECT OF THIS TEST CASE ******
;
	$GETTIM_S TIMADR=TIMADR_BTM
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BNEQU	12$			; NO -- PROCESS ERROR
	BRW	30$			; YES -- CONTINUE WITH $ASCTIM
12$:
	MOVL	#SS$_NORMAL,EXPV 	; NO -- LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM GETTIM>
15$:
;
; ****** SYSTEM SERVICE CALL WHICH IS THE SUBJECT OF THIS TEST CASE ******
;
	$BINTIM_S TIMBUF=TIMBUF[R2], -
		  TIMADR=TIMADR_BTM
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BEQLU	20$			; YES -- CONTINUE
	MOVL	#SS$_NORMAL,EXPV 	; NO -- LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM BINTIM>
20$:
	CMPL	R2,#2			; LOOKING AT CURRENT TIME ?
	BLEQ	25$			; NO -- COMPARE AGAINST STANDARDS
	BRW	30$			; YES -- SKIP COMPARE
25$:
	MOVAQ	STD_TIMADR_BTM[R2],R7	; AVOID INDEX MODE IN CMPC
	PUSHR	#CMPC_SAV		; SAVE SOME REGS USED BY CMPC (R2 AND R3)
	CMPC	#8,TIMADR_BTM,(R7)	; DID $BINTIM PRODUCE EXPECTED RESULT ?
	POPR	#CMPC_SAV		; RESTORE SOME REGS USED BY CMPC (R2 AND R3)
	BEQLU	30$			; YES -- CONTINUE
	MOVQ	STD_TIMADR_BTM[R2],EXPV	; NO -- LOAD UP EXPECTED AND
	MOVQ	TIMADR_BTM,RECV		; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT QUAD,<UNEXPECTED VALUE FOR TIMADR ARGUMENT >, -
		      <FROM $BINTIM>
30$:
	CMPL	CVTFLG[R3],#LONG_ASC	; LONG $ASCTIM OUTPUT INDICATED ?
	BEQL	33$			; YES -- GO GET STD TABLE OF LONG VALUES
	MOVAQ	STD_TIMBUF_ATMS[R2],R9	; NO -- GET STD TABLE OF SHORT TIMBUF VALUES
					; (R9 USED LATER FOR CMPC INSTR)
	MOVL	#11,TIMBUF_ATM		; ... AND USE A SHORT BUFFER
	BRB	37$			; GO ISSUE $ASCTIM
33$:
	MOVAQ	STD_TIMBUF_ATML[R2],R9	; GET STD TABLE OF LONG TIMBUF VALUES
	MOVL	#24,TIMBUF_ATM		; ... AND USE A LONG BUFFER
37$:
;
; ****** SYSTEM SERVICE CALL WHICH IS THE SUBJECT OF THIS TEST CASE ******
;
	$ASCTIM_S TIMLEN=TIMLEN_ATM,	-
		  TIMBUF=TIMBUF_ATM,	-
		  TIMADR=TIMADR_BTM,	-
		  CVTFLG=CVTFLG[R3]
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BEQLU	40$			; YES -- CONTINUE
	MOVL	#SS$_NORMAL,EXPV 	; NO -- LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM ASCTIM>
40$:
	CMPL	R2,#2			; LOOKING AT CURRENT TIME ?
	BLEQ	45$			; NO -- COMPARE AGAINST STANDARDS
	BRW	50$			; YES -- SKIP COMPARE
45$:
	PUSHR	#CMPC_SAV		; SAVE R2 & R3 BEFORE CMPC
	CMPC	(R9),@4(R9),@TIMBUF_ATM+4 ; DID $ASCTIM PRODUCE EXPECTED RESULT ?
	POPR	#CMPC_SAV		; RESTORE R2 & R3 AFTER CMPC
	BEQLU	50$			; YES -- GO ON TO $NUMTIM
	MOVQ	(R9),EXPV		; NO -- LOAD UP EXPECTED AND
	MOVQ	TIMBUF_ATM,RECV		; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT DESC,<UNEXPECTED VALUE FOR TIMBUF ARGUMENT >, -
		      <FROM $ASCTIM>
50$:
;
; ****** SYSTEM SERVICE CALL WHICH IS THE SUBJECT OF THIS TEST CASE ******
;
	$NUMTIM_S TIMBUF=TIMBUF_NMT, -
		  TIMADR=TIMADR_BTM
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BEQLU	60$			; YES -- CONTINUE
	MOVL	#SS$_NORMAL,EXPV 	; NO -- LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM NUMTIM>
60$:
	CMPL	R2,#2			; LOOKING AT CURRENT TIME ?
	BLEQ	65$			; NO -- COMPARE AGAINST STANDARDS
	BRW	VERIFYX			; YES -- SKIP COMPARE
65$:
	MOVL	STD_TIMBUF_NMT[R2],R7	; GET READY FOR ...
	MOVAL	TIMBUF_NMT,R8		; ... SERIES OF COMPARES
	CMPL	(R7),(R8)		; DO WORDS 1 & 2 OF TIMBUF MATCH STD ?
	BEQLU	70$			; YES -- GO LOOK AT MORE OF TIMBUF
	MOVL	(R7),EXPV		; NO -- LOAD UP EXPECTED AND
	MOVL	(R8),RECV		; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<UNEXPECTED VALUE FOR TIMBUF ARGUMENT >, -
		      <(WORDS 1 & 2) FROM $NUMTIM>
70$:
	CMPL	4(R7),4(R8)		; DO WORDS 3 & 4 OF TIMBUF MATCH STD ?
	BEQLU	80$			; YES -- GO LOOK AT MORE OF TIMBUF
	MOVL	4(R7),EXPV		; NO -- LOAD UP EXPECTED AND
	MOVL	4(R8),RECV		; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<UNEXPECTED VALUE FOR TIMBUF ARGUMENT >, -
		      <(WORDS 3 & 4) FROM $NUMTIM>
80$:
	CMPL	8(R7),8(R8)		; DO WORDS 5 & 6 OF TIMBUF MATCH STD ?
	BEQLU	VERIFYX			; YES -- DON'T LOOK AT WORD 7 ...
					; ... BECAUSE OF ROUNDING ERROR
	MOVL	8(R7),EXPV		; NO -- LOAD UP EXPECTED AND
	MOVL	8(R8),RECV		; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<UNEXPECTED VALUE FOR TIMBUF ARGUMENT >, -
		      <(WORDS 5 & 6) FROM $NUMTIM>
VERIFYX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	VFY_CLEANUP
;++
; FUNCTIONAL DESCRIPTION:
;
;		VFY_CLEANUP EXECUTES SYSTEM SERVICES TO UNDO THE
; EFFECT OF THOSE ISSUED IN THE VERIFY SUBROUTINE. VFY_CLEANUP MUST
; ASSUME THAT VERIFY MAY NOT HAVE EXECUTED IN ITS ENTIRETY (IF AN
; ERROR IS FOUND). ALSO, VFY_CLEANUP MAY ISSUE SS_CHECK OR ERR_EXIT
; ONLY AFTER PERFORMING ALL OF ITS CLEANUP OPERATIONS; THIS IS REQUIRED
; IN THE EVENT THAT VFY_CLEANUP IS CALLED DURING ERROR PROCESSING,
; WHEN PERFORMING THE REQUIRED CLEANUP IS MORE IMPORTANT THAN
; POSSIBLY DISCOVERING A SECOND ERROR.
;
; CALLING SEQUENCE:
;
;	BSBW VFY_CLEANUP
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_E - ADDRESS OF TABLE OF DATA VALUES FOR CONDX
;		  TABLE. IF THE CONTEXT OF TABLE X IS A SYSTEM SERVICE
;		  ARGUMENT, THE ARGUMENT NAME MAY BE USED AS A SYNONYM
;		  FOR CONDX_E.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



VFY_CLEANUP::
	RSB				; RETURN TO CALLER
	.END
