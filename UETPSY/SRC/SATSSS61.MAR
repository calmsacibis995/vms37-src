	.TITLE	SATSSS61 SATS SYST SERV TESTS  $SCH/CANWAK (SUCC S.C.)
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSTST (SATS SYSTEM SERVICE TESTS)
;
; ABSTRACT:
;
;		THIS MODULE CONTAINS SUBROUTINES WHICH, WHEN LINKED
; WITH SUCCOMMON.OBJ, FORM TEST MODULE SATSSS61 TO TEST SUCCESSFUL
; OPERATION OF THE $SCH/CANWAK SYSTEM SERVICE. THE SERVICE IS INVOKED
; UNDER VARIOUS INPUT CONDITIONS WITH VARYING INPUT PARAMETERS. ONLY
; SUCCESSFUL STATUS CODES ARE EXPECTED IN THIS TEST MODULE.  CORRECT 
; OPERATION OF THE SERVICE FOR EACH OF ITS ISSUANCES IS VERIFIED BY
; CHECKING FOR AN SS$_NORMAL STATUS CODE, EXPECTED RETURN ARGUMENTS
; AND EXPECTED FUNCTIONALITY PERFORMED.
;
; ENVIRONMENT:	USER MODE IMAGE; NEEDS CMKRNL PRIVILEGE,
;		DYNAMICALLY ACQUIRES OTHER PRIVILEGES, AS NEEDED.
;
; AUTHOR: THOMAS L. CAFARELLA,		CREATION DATE: APR, 1977
;
; MODIFIED BY:
;
;		VERSION 1.50 : 25-MAY-79
;
; 01  PJT  08/31/79	Fixed the cluster name string descriptor for the
;			ASCEFC system service.
; 02  LDJ  10/11/79	Fixed bug caused by DIB$K_LENGTH change ACG052.RNO mem
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$PRVDEF				; PRIVILEGE BIT DEFINITIONS
	$PHDDEF				; PROCESS HEADER OFFSETS
	$PQLDEF				; PROCESS QUOTA CODES
	$PCBDEF				; PCB LABELS
	$DIBDEF				; DEVICE INFO BLOCK OFFSETS
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
ONE_SEC		= 10*1000*1000		; 10 MILLION 100-NANOSECOND UNITS (OR 1 SEC)
;
; OWN STORAGE:
;
	.PAGE
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
TEST_MOD_NAME::	STRING	C,<SATSSS61>	; TEST MODULE NAME
TEST_MOD_NAME_D: STRING	I,<SATSSS61>	; TEST MODULE NAME DESCRIPTOR
MSG1_INP_CTL:	STRING	I,<  SSSCW!4ZW: CONDITIONS:>
					; FAO CTL STRING FOR MSG1 IN SUCCOMMON.MAR
MSG3_ERR_CTL::	STRING	I,< *SSSCW!4ZW: !AS> 
					; FAO CTL STRING FOR MSG3 IN SUCCOMMON.MAR
SUBJPRN:	STRING	I,<SATSSS61_CRE> ; PROCESS & MBX NAME FOR CREATED PROCESS
IMAGNAM:	STRING	I,<SYSTST$RES:SATSUT07.EXE> ; IMAGE NAME FOR CREATED PROC
CLUSTER:	.ASCID	/SS61/		; STRING DESCRIPTOR FOR CLUSTER
					; ... FOR CREATED PROCESS COMMUNICATION
QUOTALIST:	$QUOTA	CPULM,0		; INFINITE CPU
		$QUOTA	BYTLM,512	; BYTE LIMIT FOR BUFFERED I/O
		$QUOTA	FILLM,2		; OPEN FILE COUNT LIMIT
		$QUOTA	PGFLQUOTA,10	; PAGING FILE QUOTA
		$QUOTA	PRCLM,2		; SUBPROCESS QUOTA
		$QUOTA	TQELM,3		; TIMER QUEUE ENTRY QUOTA
		$QUOTA	LISTEND		; DEFINES END OF LIST
DELTA_1SEC:	.LONG	-ONE_SEC,-1	; DELTA TIME VALUE FOR 1 SECOND
DELTA_2SEC:	.LONG	-2*ONE_SEC,-1	; DELTA TIME VALUE FOR 2 SECONDS
DELTA_3SEC:	.LONG	-3*ONE_SEC,-1	; DELTA TIME VALUE FOR 3 SECONDS
DELTA_10SEC:	.LONG	-10*ONE_SEC,-1	; DELTA TIME VALUE FOR 10 SECONDS
DELTA_QSEC:	.LONG	-<ONE_SEC/4>,-1	; DELTA TIME VALUE FOR A QUARTER-SECOND
POS_3SEC:	.LONG	3*ONE_SEC,0	; 3 SECONDS (POSITIVE VALUE)
TIME_PAST:	STRING	I,<25-DEC-1973  21:46:00.00> ; A TIME IN THE PAST
	.PAGE
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
PRIVMASK:	.BLKQ	1		; ADDR OF PRIVILEGE MASK (IN PHD)
MBXCHAN:	.BLKL	1		; CHAN. NO. FOR MAILBOX FOR CREATED PROCESS
MBXCHANINFO:				; CHANNEL INFO RETURNED BY GETCHN
		.LONG	DIB$K_LENGTH
		.ADDRESS .+4
		.BLKB	DIB$K_LENGTH
MBXUNIT:	.BLKL	1		; SAVE AREA FOR MAILBOX UNIT NUMBER
MBXBUFF:	STRING	O,120		; MAILBOX BUFFER FOR CREATED PROCESS
DEST_PIDADR:	.BLKL	1		; DESTINATION PID ADDR, WRITTEN BY S.S.
ZEROPID:	.BLKL	1		; PID OF ZEROES
SELFPID:	.LONG	0		; PID OF THIS PROCESS
CREPID:		.BLKL	1		; PID OF CREATED PROCESS
SUBJPID:	.BLKL	1		; PID OF SUBJECT PROCESS (SELF OR OTHER)
ABS_3SEC:	.BLKQ	1		; WILL HOLD ABS TIME VALUE FOR NOW + 3 SECS
ABS_PAST:	.BLKQ	1		; WILL HOLD ABS TIME VALUE FOR TIME IN PAST
LONG_WAIT:	.BLKB	1		; LONG WAIT INDICATOR; 0=NO LONG WAIT
	.PAGE
	.SBTTL	CONDITION TABLES
;
;	***** CONDITION TABLES FOR SCH/CANWAK SYSTEM SERVICE *****
;
	COND	1,NOTARG,<PID ADDRESS>,-
		  <NOT SPECIFIED>,-
		  <SPECIFIED, NON-ZERO>,-
		  <SPECIFIED, ZERO>,-
 
		    .ADDRESS	0
		    .ADDRESS	SUBJPID
		    .ADDRESS	ZEROPID
;
	COND	2,NOTARG,<PROCESS NAME ADDRESS>,-
		  <SPECIFIED>,-
		  <NOT SPECIFIED>,-
 
		    .ADDRESS	SUBJPRN
		    .ADDRESS	0
;
	COND	3,NOTARG,<PROCESS TYPE>,-
		  <SELF>,-
		  <SUBPROCESS>,-
		  <DETACHED, DIFFERENT GROUP>,-
		  <DETACHED, SAME GROUP, SAME MEMBER>,-
		  <DETACHED, SAME GROUP, DIFFERENT MEMBER>,-
 
		    .LONG	^XFFFFFFFF 	; PSEUDO-UIC
		    .LONG	0	   	; PSEUDO-UIC
		    .BLKL	1	   	; UIC
		    .BLKL	1	   	; UIC
		    .BLKL	1	   	; UIC
;
	COND	4,NOTARG,<ORDERING OF CANCEL/WAKE/REPEAT>,-
		  <CANCEL, WAKE, REPEAT>,-
		  <WAKE, CANCEL, REPEAT>,-
		  <WAKE, REPEAT, CANCEL>,-
		  <WAKE, CANCEL>,-
 
		    .ADDRESS	ABS_3SEC,DELTA_1SEC   ; DAYTIM, REPTIM ARG ADDRESSES
		    .ADDRESS	DELTA_1SEC,DELTA_3SEC ; DAYTIM, REPTIM ARG ADDRESSES
		    .ADDRESS	ONES,ONES 	      ; DAYTIM, REPTIM ARG ADDRESSES
		    .ADDRESS	DELTA_1SEC,0	      ; DAYTIM, REPTIM ARG ADDRESSES
;
	COND	5,NULL
 
	.PSECT	SATSSS61,RD,WRT,EXE
	.PAGE
	.SBTTL	TM_SETUP, TM_CLEANUP
;++
; FUNCTIONAL DESCRIPTION:
;
;		TM_SETUP AND TM_CLEANUP ARE CALLED TO PERFORM
; REQUIRED HOUSEKEEPING AT THE BEGINNING AND END, RESPECTIVELY, OF
; TEST MODULE EXECUTION.
;
; CALLING SEQUENCE:
;
;	BSBW TM_SETUP   BSBW TM_CLEANUP
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	TM_SETUP:  COND TABLE INDEX REGISTERS (R2,3,4,5,6) CLEARED;
;		   ALL PRIVILEGES ACQUIRED.
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



TM_SETUP::
	CLRL	R2			; INITIALIZE
	CLRL	R3			; .. CONDITION
	CLRL	R4			; .... TABLE
	CLRL	R5			; ...... INDEX
	CLRL	R6			; ........ REGISTERS
	BSBW	MOD_MSG_PRINT		; PRINT TEST MODULE BEGIN MSG
	MOVAL	TEST_MOD_SUCC,TMD_ADDR	; ASSUME END MSG WILL SHOW SUCCESS
	INSV	#SUCCESS,#0,#3,MOD_MSG_CODE ; ADJUST STATUS CODE FOR SUCCESS
	MODE	TO,5$,KRNL		; KERNEL MODE TO ACCESS PHD
	MOVL	@#CTL$GL_PHD,R9		; GET PROCESS HEADER ADDRESS
	MOVAL	PHD$Q_PRIVMSK(R9),PRIVMASK ; GET PRIV MASK ADDRESS
	MODE	FROM,5$	; BACK TO USER MODE
	PRIV	ADD,ALL			; GET ALL PRIVILEGES
	$SETPRN_S TEST_MOD_NAME_D 	; SET PROCESS NAME
	SS_CHECK  NORMAL		; CHECK STATUS CODE RETURNED FROM SETPRN
	$WAKE_S	SELFPID			; GET MY PID
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
	$HIBER_S			; UNDO ABOVE WAKE
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
;
; THE FOLLOWING CODE ESTABLISHES UIC'S IN THE CONDITION 3 TABLE
;
	MODE	TO,20$,KRNL		; KERNEL MODE TO ACCESS PCB
	MOVL	@#SCH$GL_CURPCB,R9 	; GET CURRENT PCB ADDRESS
	MOVL	PCB$L_UIC(R9),R9 	; PICK UP UIC FROM PCB
	MODE	FROM,20$		; ... AND GET BACK TO USER MODE
;
; R9 NOW CONTAINS "MY" UIC
;
	MOVZBL	#2,R10			; GET COND3 TABLE INDEX NUMBER INTO A REG
	ADDL3	#^X10000,R9,COND3_E[R10] ; PUT DIFF GROUP UIC INTO 3RD TABLE ELT
	INCL	R10			; POINT TO 4TH COND3 TABLE ELEMENT
	MOVL	R9,COND3_E[R10]		; PUT MY UIC INTO TABLE
	INCL	R10			; POINT TO 5TH COND3 TABLE ELEMENT
	ADDL3	#1,R9,COND3_E[R10] 	; PUT DIFF MEMBER UIC INTO THE TABLE
	$CREMBX_S CHAN=MBXCHAN, LOGNAM=SUBJPRN, - ; GET MAILBOX FOR PROCESS
		  MAXMSG=#120, PROMSK=#0, BUFQUO=#240
	SS_CHECK NORMAL			; CHECK NORMAL COMPLETION
	$GETCHN_S CHAN=MBXCHAN, -	; GET CHAN INFO (UNIT NUMBER)
		  PRIBUF=MBXCHANINFO
	SS_CHECK NORMAL			; CHECK NORMAL COMPLETION
	MOVZWL	MBXCHANINFO+8+DIB$W_UNIT,MBXUNIT ; SAVE MAILBOX UNIT NUMBER
	$BINTIM_S TIMBUF=TIME_PAST, -	; SET UP A PAST TIME IN ABSOLUTE FORMAT
		  TIMADR=ABS_PAST
	RSB				; RETURN TO MAIN ROUTINE
TM_CLEANUP::
	$DELMBX_S  MBXCHAN		; DELETE TERMINATION MAILBOX
	BSBW	MOD_MSG_PRINT		; PRINT TEST MODULE END MSG
	RSB				; RETURN TO MAIN ROUTINE
	.PAGE
	.SBTTL	CONDITION SUBROUTINES - SETUP AND CLEANUP 
;++
; FUNCTIONAL DESCRIPTION:
;
;		CONDX AND CONDX_CLEANUP ARE SUBROUTINES WHICH ARE EXECUTED
; BEFORE AND AFTER THE VERIFY SUBROUTINE, RESPECTIVELY, WHENEVER A NEW
; CONDITION X VALUE IS SELECTED (SEE FUNCTIONAL DESCRIPTION OF SUCCOMMON
; ROUTINE IN SUCCOMMON.MAR). ANY SETUP FUNCTION PARTICULAR TO THE 
; CONDITION X TABLE IS INCLUDED IN THE CONDX SUBROUTINE AND CLEANED
; UP, IF NECESSARY, IN THE CONDX_CLEANUP SUBROUTINE. THIS INCLUDES,
; ESPECIALLY, CODE TO DETECT CONFLICTS AMONG CURRENT ENTRIES IN TWO
; OR MORE CONDITION TABLES. IF A CONFLICT IS DETECTED, A NON-ZERO
; VALUE IS STORED INTO CONFLICT, WHICH CAUSES THE CALLING ROUTINE
; (SUCCOMMON) TO SKIP THE CURRENT ENTRY IN THE CONDITION X TABLE.
;
; CALLING SEQUENCE:
;
;	BSBW CONDX   BSBW CONDX_CLEANUP
;	  WHERE X = 1,2,3,4,5
;
; INPUT PARAMETERS:
;
;	CONFLICT = 0
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;
; OUTPUT PARAMETERS:
;
;	CONFLICT SET TO NON-ZERO IF COND TABLE CONFLICT DETECTED.
;
; IMPLICIT OUTPUTS:
;
;	R2,3,4,5,6 PRESERVED
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



COND1::
	RSB				; RETURN TO MAIN ROUTINE
COND1_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND2::
	RSB				; RETURN TO MAIN ROUTINE
COND2_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND3::
	CMPL	R4,#2			; DOES CONDITION 3 SPECIFY DIFFERENT GROUP ?
	BEQL	20$			; YES -- THIS IS CONFLICT BECAUSE OF 
					; ... USE OF COMMON CLUSTERS
	CMPL	#SUBJPID,COND1_E[R2] 	; NON-ZERO PID SPECIFIED ?
	BEQLU	10$			; YES -- PROCESS IS "OTHER"
	TSTL	COND2_E[R3]		; IS PROCESS NAME SPECIFIED ?
	BNEQ	10$			; YES -- SUBJECT PROCESS IS "OTHER"
5$:
;
; PROCESS IS "SELF"
;
	CMPL	ONES,COND3_E[R4] 	; DOES CONDITION 3 SPECIFY "SELF" ?
	BEQLU	COND3X			; YES -- THEN ALL 3 CONDIT'NS ARE CONSISTENT
	BRB	20$			; NO -- INDICATE CONFLICT & GET OUT
10$:
;
; PROCESS IS "OTHER"
;
	CMPL	ONES,COND3_E[R4] 	; DOES CONDITION 3 SPECIFY "SELF" ?
	BNEQU	COND3X			; NO -- THEN ALL 3 CONDITIONS ARE CONSISTENT
20$:
	MOVB	ONES,CONFLICT		; YES -- INDICATE CONFLICT
COND3X:
	RSB				; RETURN TO MAIN ROUTINE
COND3_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND4::
	RSB				; RETURN TO MAIN ROUTINE
COND4_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND5::
	RSB				; RETURN TO MAIN ROUTINE
COND5_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
	.PAGE
	.SBTTL	FORM_CONDS
;++
; FUNCTIONAL DESCRIPTION:
;
; 		FORM_CONDS FORMATS AND PRINTS INFORMATION ABOUT
;  THE CURRENT ELEMENT IN EACH OF THE CONDITION TABLES.
;
; CALLING SEQUENCE:
;
;	BSBW FORM_CONDS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_T - TITLE TEXT FOR CONDX TABLE
;		CONDX_TAB - ELEMENT TEXT FOR CONDX TABLE
;		CONDX_C - CONTEXT OF THE CONDX TABLE
;		CONDX_E - DATA ELEMENTS OF THE CONDX TABLE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



FORM_CONDS::
	$FAO_S	MSG1_INP_CTL,FAO_LEN,FAO_DESC,TESTNUM
					; FORMAT CONDITIONS HEADER MSG
	BSBW	OUTPUT_MSG		; ... AND PRINT IT
	CMPB	#COND1_C,#NULL		; IS CONDITION 1 NULL ?
	BNEQU	10$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
10$:
	MOVAL	COND1_T,MSG_A		; SAVE ADDRESS OF CONDITION 1 TITLE FOR FAO
	MOVL	COND1_TAB[R2],MSG_B 	; SAVE ADDR OF COND 1 CURR TEXT ELT FOR FAO
	MOVB	#COND1_C,MSG_CTXT 	; SAVE CONDITION 1 CONTEXT FOR FAO
	MOV_VAL	COND1_C,COND1_E[R2],MSG_DATA1 ; GIVE COND 1 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 1 MSG
	CMPB	#COND2_C,#NULL		; IS CONDITION 2 NULL ?
	BNEQU	20$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
20$:
	MOVAL	COND2_T,MSG_A		; SAVE ADDRESS OF CONDITION 2 TITLE FOR FAO
	MOVL	COND2_TAB[R3],MSG_B 	; SAVE ADDR OF COND 2 CURR TEXT ELT FOR FAO
	MOVB	#COND2_C,MSG_CTXT 	; SAVE CONDITION 2 CONTEXT FOR FAO
	MOV_VAL	COND2_C,COND2_E[R3],MSG_DATA1 ; GIVE COND 2 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 2 MSG
	CMPB	#COND3_C,#NULL		; IS CONDITION 3 NULL ?
	BNEQU	30$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
30$:
	MOVAL	COND3_T,MSG_A		; SAVE ADDRESS OF CONDITION 3 TITLE FOR FAO
	MOVL	COND3_TAB[R4],MSG_B 	; SAVE ADDR OF COND 3 CURR TEXT ELT FOR FAO
	MOVB	#COND3_C,MSG_CTXT 	; SAVE CONDITION 3 CONTEXT FOR FAO
	MOV_VAL	COND3_C,COND3_E[R4],MSG_DATA1 ; GIVE COND 3 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 3 MSG
	CMPB	#COND4_C,#NULL		; IS CONDITION 4 NULL ?
	BEQLU	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
	MOVAL	COND4_T,MSG_A		; SAVE ADDRESS OF CONDITION 4 TITLE FOR FAO
	MOVL	COND4_TAB[R5],MSG_B 	; SAVE ADDR OF COND 4 CURR TEXT ELT FOR FAO
	MOVB	#COND4_C,MSG_CTXT 	; SAVE CONDITION 4 CONTEXT FOR FAO
	MOV_VAL	COND4_C,COND4_E[R5],MSG_DATA1 ; GIVE COND 4 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 4 MSG
	CMPB	#COND5_C,#NULL		; IS CONDITION 5 NULL ?
	BEQLU	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
	MOVAL	COND5_T,MSG_A		; SAVE ADDRESS OF CONDITION 5 TITLE FOR FAO
	MOVL	COND5_TAB[R6],MSG_B 	; SAVE ADDR OF COND 5 CURR TEXT ELT FOR FAO
	MOVB	#COND5_C,MSG_CTXT 	; SAVE CONDITION 5 CONTEXT FOR FAO
	MOV_VAL	COND5_C,COND5_E[R6],MSG_DATA1 ; GIVE COND 5 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 5 MSG
FORM_CONDSX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	VERIFY
;++
; FUNCTIONAL DESCRIPTION:
;
;		VERIFY IS CALLED ONCE FOR EACH COMBINATION OF CONDITION
; TABLE VALUES (AS DETERMINED BY THE INDEX REGISTERS R2,3,4,5,6 FOR
; COND TABLES 1,2,3,4,5, RESPECTIVELY). VERIFY ESTABLISHES THE CONDITIONS
; SPECIFIED BY THE COND TABLES AND ISSUES THE SUBJECT SYSTEM SERVICE
; ($SCH/CANWAK). THEN, THE SUCCESSFUL OPERATION OF THE SERVICE IS VERIFIED
; BY EXAMINING THE STATUS CODE RETURNED, THE VALUES FOR RETURN ARGUMENTS
; AND THE FUNCTIONALITY PERFORMED. THE EXAMINATIONS TAKE THE FORM OF 
; COMPARISONS AGAINST EXPECTED VALUES. ANY FAILING COMPARISON CAUSES AN
; ERR_EXIT MACRO TO BE EXECUTED (EITHER DIRECTLY, OR INDIRECTLY,
; THROUGH THE SS_CHECK MACRO); ERR_EXIT SETS EFLAG TO NON-ZERO,
; PRINTS ERROR MESSAGES AND CAUSES AN IMMEDIATE RSB TO CALLER.
; WHEN ERR_EXIT IS EXECUTED, FURTHER CALLS TO VERIFY ARE SUPPRESSED,
; AND, AFTER EXECUTING CLEANUP SUBROUTINES, THE IMAGE EXITS.
;
; CALLING SEQUENCE:
;
;	BSBW VERIFY
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_E - ADDRESS OF TABLE OF DATA VALUES FOR CONDX
;		  TABLE. IF THE CONTEXT OF TABLE X IS A SYSTEM SERVICE
;		  ARGUMENT, THE ARGUMENT NAME MAY BE USED AS A SYNONYM
;		  FOR CONDX_E.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	VERIFY HAS NO OUTPUT. SINCE ITS PURPOSE IS TO TEST FOR ERRORS,
;	IT MERELY RETURNS TO CALLER NORMALLY AFTER THE TESTS, PROVIDING
;	ALL WERE SUCCESSFUL; IF AN ERROR IS DISCOVERED, RETURN IS VIA
;	AN ERR_EXIT OR SS_CHECK MACRO, BOTH OF WHICH DOCUMENT DETECTED
;	ERRORS.
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



VERIFY::
	TSTB	CFLAG			; SHOULD CONDITIONS BE PRINTED ?
	BEQL	5$			; NO -- CONTINUE
	BSBW	FORM_CONDS		; YES -- FMT & PRINT ALL CONDS FOR THIS T.C.
5$:
	MOVL	SELFPID,SUBJPID		; ASSUME THE SUBJECT PID IS SELF
	CLRL	ZEROPID			; CLEAR ZERO PID
	CLRB	LONG_WAIT		; INITIALIZE LONG_WAIT INDICATOR
	CMPL	ONES,COND3_E[R4] 	; IS PROCESS FOR THIS TEST CASE SELF ?
	BNEQU	7$			; NO -- CONTINUE
	BRW	10$			; YES -- DON'T CREATE A PROCESS
7$:
	$CREPRC_S PIDADR=CREPID, PRCNAM=SUBJPRN, -
		  UIC=COND3_E[R4], IMAGE=IMAGNAM, -
		  MBXUNT=MBXUNIT, QUOTA=QUOTALIST
					; CREATE THE SUBJECT PROCESS
	SS_CHECK NORMAL			; ... AND MAKE SURE IT CREATED OK
	MOVL	CREPID,SUBJPID		; MAKE THE SUBJCT PID = THE ONE JUST CREATED
10$:
	MOVL	COND1_E[R2],DEST_PIDADR ; GET PID ADDRESS OUT OF TABLE
	MOVL	COND2_E[R3],R9		; PRCNAM ADDR INTO REG FOR INDIRECT REF'RNCE
	MOVQ	COND4_E[R5],R7		; GET DAYTIM, REPTIM ARG ADDRESSES INTO REGS
	$CANWAK_S SUBJPID		; ISSUE PRELIM CANWAK TO CLEAR THE DECKS
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
	$SETIMR_S DAYTIM=DELTA_10SEC, -	; SET "WATCHDOG" TIMER TO TRIP IF LONG WAIT
		  ASTADR=WATCH_AST
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
	$GETTIM_S ABS_3SEC		; GET CURRENT TIME
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
	ADDL	POS_3SEC,ABS_3SEC	; ADD 3 SECONDS TO LOWER LONGWORD
	ADWC	POS_3SEC+4,ABS_3SEC+4	; ADD POSSIBLE CARRY TO HIGHER LONGWORD
					; ABS_3SEC IS NOW VALID IF USED IN $SCHDWK
;
; ****** SYSTEM SERVICE CALL WHICH IS THE SUBJECT OF THIS TEST CASE ******
;
	$SCHDWK_S PIDADR=@DEST_PIDADR, PRCNAM=(R9), -
		  DAYTIM=(R7), REPTIM=(R8)
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BEQLU	15$			; YES -- CONTINUE
	MOVL	#SS$_NORMAL,EXPV 	; NO -- LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM SCHDWK>
15$:
	TSTL	DEST_PIDADR		; PID RETURNED BY SCHDWK ?
	BEQL	20$			; NO -- KEEP GOING
	CMPL	SUBJPID,@DEST_PIDADR 	; YES -- IS IT THE CORRECT ONE ?
	BEQL	20$			; YES -- CONTINUE
	MOVL	SUBJPID,EXPV		; NO --LOAD UP EXPECTED AND
	MOVL	@DEST_PIDADR,RECV 	; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT PID RETURNED BY SCHDWK>
20$:
	$CLREF_S EFN=#32		; CLEAR EVENT FLAG 32
	BLBS	R0,25$			; KEEP GOING IF OK
	SS_CHECK NORMAL			; USE SS_CHECK MACRO TO TERMINATE TEST MOD
25$:
	$SETIMR_S EFN=#32, -		; SET A 2-SECOND TIMER
		  DAYTIM=DELTA_2SEC
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
	$WAITFR_S EFN=#32		; WAIT 2 SECONDS TO ALLOW PROPER SYNCH'N
	SS_CHECK NORMAL			; CHECK FOR NORMAL RETURN
	CLRL	ZEROPID			; CLEAR OUT ZERO PID SCHDWK MAY HAVE SET
;
; ****** SYSTEM SERVICE CALL WHICH IS THE SUBJECT OF THIS TEST CASE ******
;
	$CANWAK_S PIDADR=@DEST_PIDADR, PRCNAM=(R9)
					; CANCEL SCHEDULED WAKE OR REPEAT
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BEQLU	30$			; YES -- CONTINUE
	MOVL	#SS$_NORMAL,EXPV 	; NO -- LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM CANWAK>
30$:
	TSTL	DEST_PIDADR		; PID RETURNED BY CANWAK ?
	BEQL	40$			; NO -- KEEP GOING
	CMPL	SUBJPID,@DEST_PIDADR 	; YES -- IS IT THE CORRECT ONE ?
	BEQL	40$			; YES -- CONTINUE
	MOVL	SUBJPID,EXPV		; NO --LOAD UP EXPECTED AND
	MOVL	@DEST_PIDADR,RECV 	; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT PID RETURNED BY CANWAK>
40$:
	CMPL	CREPID,SUBJPID		; WAS A PROCESS CREATED ?
	BEQLU	50$			; YES -- GO WAIT FOR IT TO END
	BRW	60$			; NO -- GO ISSUE HIBER
50$:
	$ASCEFC_S EFN=#64, NAME=CLUSTER	; ASSOC WITH CLUSTER FOR PROCESS SYNCHRO'N
	SS_CHECK  NORMAL		; CHECK FOR NORMAL STATUS
	$SETEF_S  EFN=#65		; LET CREATED PROC EXIT
	SS_CHECK  WASCLR		; BIT 65 SHOULD HAVE BEEN CLEAR
	$WAITFR_S EFN=#64		; WAIT UNTIL CREATED PROC CAN HIBERNATE
	SS_CHECK  NORMAL		; CHECK FOR NORMAL RETURN
	$DACEFC_S EFN=#64		; DISASSOC CLUSTER
	SS_CHECK  NORMAL		; CHECK FOR NORMAL STATUS
	$QIOW_S	CHAN=MBXCHAN, FUNC=#IO$_READVBLK, -
		P1=MBXBUFF+8, P2=MBXBUFF
					; WAIT FOR CREATED PROCESS TO SEND MAIL
	SS_CHECK NORMAL			; CHECK FOR NORMAL STATUS CODE
	BRB	70$			; ... AND GO SEE IF WE WERE STUCK IN HIBER
60$:
	$HIBER_S			; HIBERNATE TO SATISFY OUTSTANDING WAKE
	SS_CHECK NORMAL			; ... MAKE SURE IT FINISHED OK
70$:
;
;  CHECK TO SEE IF STUCK IN HIBER ...... IF LONG_WAIT
;  IS SET AND DID NOT EXPECT LONG WAIT, ISSUE ERR_EXIT
;  SAYING "STUCK IN HIBER".
;
	TSTB	LONG_WAIT		; DID WE WAIT A LONG TIME ?
	BEQL	VERIFYX			; NO -- THIS TEST CASE IS FINISHED
	TSTL	R5			; YES -- DID WE EXPECT TO REMAIN IN HIB'N ?
	BEQL	VERIFYX			; YES -- THAT'S OK
	CLRB	EXPV			; NO -- SOMETHING WENT WRONG .... LOAD UP
	CLRB	RECV			; ... EXPECTED & RECEIVED VALUES, THEN EXIT
	ERR_EXIT BYTE,<SUBJECT PROCESS WAS LEFT IN HIBERNATION>
VERIFYX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	VFY_CLEANUP
;++
; FUNCTIONAL DESCRIPTION:
;
;		VFY_CLEANUP EXECUTES SYSTEM SERVICES TO UNDO THE
; EFFECT OF THOSE ISSUED IN THE VERIFY SUBROUTINE. VFY_CLEANUP MUST
; ASSUME THAT VERIFY MAY NOT HAVE EXECUTED IN ITS ENTIRETY (IF AN
; ERROR IS FOUND). ALSO, VFY_CLEANUP MAY ISSUE SS_CHECK OR ERR_EXIT
; ONLY AFTER PERFORMING ALL OF ITS CLEANUP OPERATIONS; THIS IS REQUIRED
; IN THE EVENT THAT VFY_CLEANUP IS CALLED DURING ERROR PROCESSING,
; WHEN PERFORMING THE REQUIRED CLEANUP IS MORE IMPORTANT THAN
; POSSIBLY DISCOVERING A SECOND ERROR.
;
; CALLING SEQUENCE:
;
;	BSBW VFY_CLEANUP
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_E - ADDRESS OF TABLE OF DATA VALUES FOR CONDX
;		  TABLE. IF THE CONTEXT OF TABLE X IS A SYSTEM SERVICE
;		  ARGUMENT, THE ARGUMENT NAME MAY BE USED AS A SYNONYM
;		  FOR CONDX_E.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;

; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



VFY_CLEANUP::
	$CANWAK_S SUBJPID		; CANCEL ANY POSSIBLE OUTSTANDING WAKES
	$CANTIM_S 			; CANCEL WATCHDOG TIMER
	CMPL	CREPID,SUBJPID		; WAS A PROCESS CREATED FOR THIS TEST CASE ?
	BNEQU	VFY_CLEANUPX		; NO -- JUST EXIT
	$DELPRC_S SUBJPID		; YES -- DELETE IT
VFY_CLEANUPX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	WATCH_AST
;
; WATCH_AST SHOULD BE ENTERED ONLY WHEN THE CREATING OR CREATED
; PROCESS IS HIBERNATING. IT IS SCHEDULED WITH A 10-SECOND TIMER,
; WHICH IS CANCELED BEFORE DELIVERY IN ALL CASES EXCEPT WHEN THE
; SUBJECT PROCESS GOES INTO AN UNSATISFIED HIBERNATION. WHEN
; WATCH_AST IS ENTERED, IT SETS A FLAG INDICATING IT WAS ENTERED
; (LONG_WAIT) TO NON-ZERO, AND ISSUES A $WAKE FOR THE SUBJECT 
; PROCESS; THIS SHOULD CLEAR THE HIBERNATION. BACK IN THE MAIN
; ROUTINE, A CHECK IS MADE TO SEE IF THE WATCH_AST WAS ENTERED
; AND WHETHER OR NOT SUCH ENTRY WAS EXPECTED. AN UNEXPECTED ENTRY
; TO WATCH_AST CAUSES AN ERR_EXIT.
;
WATCH_AST:
	.WORD	0			; ENTRY MASK
	MOVB	ONES,LONG_WAIT		; INDICATE THAT THE AST WAS ENTERED
	$WAKE_S	SUBJPID			; WAKE THE (PRESUMABLY) HIBERNATING PROCESS
	RET				; ... AND GET OUT
	.END
