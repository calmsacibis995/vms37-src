	.TITLE UETINIT01 VAX/VMS UETP SYSTEM CONFIGURATION SIZER
	.IDENT	'V03-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This program creates a file called UETINIDEV.DAT containing all device
;	names and unit numbers of devices that are supported by the UETP.
;	The DDB and UCB list is searched to collect this information.
;	As this file is being created the device, if supported, has a quick
;	test done on it to make sure that it is basically functional. If
;	the device is not functional it is deselected from further UETP testing.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with interrupts enabled
;	at all times.  This program requires the following privileges and
;	quotas:
;			CMKRNL
;			GRPNAM
;			TMPMBX
;
;--
;
; AUTHOR: Larry D. Jones,	CREATION DATE: November, 1980
;
; MODIFIED BY:
;
;	V03-001	LDJ0003		Larry D. Jones,		15-Apr-1982
;		Fixed MA780 extra UCB record in the inidev file bug.
;
;	V02-007	RNH0002		Richard N. Holstein,	18-Jan-9182
;		Increase TEXT_BUFFER size to hold larger messages.  Fix
;		bug where BBS tested mask instead of bit position.
;
;	V02-006 RNP0003		Robert N. Perron,	31-Dec-1981
;		Removed upper casing of begin sentinels
;
;	V02-005	RNP0002		Robert N. Perron,	23-Dec-1981
;		Fixed so that non-supported devices do not appear in 
;		UETINIDEV.DAT. Added device summary printout to SUC_EXIT and
;		removed printing of DDB and UCB lines. Fixed handling of
;		remote terminals - skip them.
;
;	V02-004 RNP0001		Robert N. Perron,	05-Nov-1981
;		Modified to allow batch execution.
;
;	V02-003	LDJ0002		Larry D. Jones,		14-Oct-1981
;		Reset DNTM before creating each new subprocess.
;
;	V02-002	RNH0001		Richard N. Holstein,	05-Oct-1981
;		Change SS$_CONTROLC to be a warning.  Use secondary device
;		characteristics for DDB devices as appropriate.  Remove
;		ALWAYS flag - it prevents useful info from being typed and
;		is redundantly implemented by judicious use of SHRT_RPRT.
;
;	V02-001	LDJ0001		Larry D. Jones,		08-Sep-1981
;		Fixed reporting of NET as a non-supported device.
;
;**

	.SBTTL	Declarations
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$ACCDEF				; Accounting definitions
	$ADPDEF				; Adapter control block
	$CHFDEF				; Condition handler frame definitions
	$DDBDEF				; Device data block definitions
	$DIBDEF				; Device Information Block
	$JPIDEF				; JPI definitions
	$MPMDEF				; Multiport memory adapter reg. offsets
	$PQLDEF				; Process quota list definitions
	$SECDEF				; Section definitions
	$SHBDEF				; Shared memory control block
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$UCBDEF				; Unit control block definitions
	$UETPDEF			; UETP
;
; EQUATED SYMBOLS:
;
;   Facility number definitions:
	UETP_K = 116
	RMS_K = 1

;   SHR message definitions:
	UETP = UETP_K@STS$V_FAC_NO	; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_OPENIN = UETP!SHR$_OPENIN
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Internal flag bits...:
	SHRT_RPRTV   = 0		; Set if short report format desired
	CONTROL_CV   = 1		; Set if CTRL/C AST received
	UCB_NXTLIV   = 2		; Set if next line generated is a UCB
	DEVNOTSUPV   = 3		; Set if device is not supported
	NON_IOV      = 5		; Set when IOC$GL_DEVLIST exhausted
	BEGIN_MSGV   = 6		; Set when "begin" msg has been output
	ALL_FINISV   = 7		; Set if MPM is last dev in config
	DNTV         = 8		; Set when device test process fails
	BEGIN_FOUNDV = 9		; Set when beginning sentinel is found
	END_FOUNDV   = 10		; Set when ending sentinel is found
	DO_TESTABLEV = 11		; Set when seaching UETINIDEV for
					;  testable units
;   ...and corresponding masks:
	SHRT_RPRTM   = 1@SHRT_RPRTV
	CONTROL_CM   = 1@CONTROL_CV
	UCB_NXTLIM   = 1@UCB_NXTLIV
	DEVNOTSUPM   = 1@DEVNOTSUPV
	NON_IOM      = 1@NON_IOV
	BEGIN_MSGM   = 1@BEGIN_MSGV
	ALL_FINISM   = 1@ALL_FINISV
	DNTM	     = 1@DNTV
	BEGIN_FOUNDM = 1@BEGIN_FOUNDV
	END_FOUNDM   = 1@END_FOUNDV
	DO_TESTABLEM = 1@DO_TESTABLEV

;   Miscellany:
	LC_BITM       = ^X20		; Mask to convert lower case to upper
	REC_SIZE      = 20		; UETINIDEV.DAT maximum record size
	DDB_SIZE      = 6		; DDB record size without device designation
	UCB_SIZE      = 11		; UCB record size
	TEXT_BUFFER   = 250		; Internal text buffer size
	LOG_NAME_SYNC = 64		; EFN used to sync CTRLNAME
	MAX_DEV_DESIG = 8		; Longest possible controller name
	MAX_UNIT_DESIG= 5		; Longest possible unit number
	ESC           = ^X1B		; Escape character
	MBX_SIZE      = 256		; Mailbox buffer size
	CR	      = ^XD
	LF	      = ^XA


	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TSTNAM:					; This test name
	.ASCID	/UETINIT01/

SUPDEV_GBLSEC:				; How we access UETSUPDEV.DAT
	.ASCID	/UETSUPDEV/

MODE:					; Run mode logical name
	.ASCID	/MODE/

REPORT_NAME:				; Error output log name
	.ASCID	/REPORT/		; Long or short report indicator name

TTNAME_ROPTR:
	.WORD	63,0
	.ADDRESS TTNAME

EQUA1:
	.ASCID	/ONE/
EQUA2:
	.ASCID	/NORMAL/

OPNAM:
	.ASCII	/OPA0/			; Operator console name
CSNAM:
	.ASCII	/CSA0/			; Diagnostic load device name
RTNAM:					; Remote terminals
	.ASCID	/RTA/
NETNAM:
	.ASCII	/NET0/			; Networks

CS1:					; Device class and type control string
	.ASCID	/!2XB !2XB /

CS2:					; Device unit number control string
	.ASCID	/!5ZW/

CS3:					; Device class-only control string
	.ASCID	/!2XB **/

MPM_CS:					; Faked $FAO result from MPM "characteristics"
	.ASCID	/   **/

HEADER_REC:				; UETCONT00.DAT init records
	.ASCIC	/! UETP Device Test Phase/

PHASE_NAME:				; Phase name for the device test phase
	.ASCIC	/NAME = UETPDEV00/

LOG_NAME:				; UETCONT00 file log name
	.ASCIC	/LOG  = UETPDEV00.LOG/

SYSOUT:					; Log file name
	.ASCID	/UETINIT01.LOG;1/

LOGEXT:					; Log file extention
	.ASCII	/.LOG/

CONT_STR:				; Control string for UETCONT00 records
	.ASCID	/Y Y !AS "!AD"/

TEST_COUNT:				; Record count logical name for UETCONT00 file
	.ASCID	/TEST_COUNT/

TST_CNT_STR:				; Control string for UETCONT00 records
	.ASCID	/!UL/

DDB_CTRSTR:
	.ASCID	/DDB T !AC/		; DDB record control string

UCB_CTRSTR:
	.ASCID	/UCB T !5ZW/		; UCB record control string

END_MSG:
	.ASCII	/END OF UETINIDEV.DAT/	; Ending message
	END_MSGL = .-END_MSG

JPI_LIST:
	.WORD	4,JPI$_UIC		; List for the $GETJPI service
	.ADDRESS UIC,0
	.WORD	4,JPI$_ASTLM
	.ADDRESS ASTLM,0
	.WORD	4,JPI$_BIOLM
	.ADDRESS BIOLM,0
	.WORD	4,JPI$_DIOLM
	.ADDRESS DIOLM,0
	.WORD	4,JPI$_TQLM
	.ADDRESS TQLM,0
	.LONG	0

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

NO_CTRLNAME:
	.ASCID	/No controller specified with logical name CTRLNAME!/

DEAD_CTRLNAME:
	.ASCID	/Can't test controller !AS, marked as unusable in UETINIDEV.DAT./

NOUNIT_SELECTED:
	.ASCID	/No units selected for testing./

PASS_MSG:
	.ASCID	/End of pass !UL with !UL iterations at !%D./

THREEMIN:				; 3 minute delta time
	.LONG	-10*1000*1000*180,-1

UNIT_DESC:				; Descriptor used to convert unit #
	.LONG	5
	.ADDRESS BUFFER+6

CONT_DESC:				; Descriptor used to convert controller...
	.WORD	0,3			; ...from lowercase to uppercase
	.ADDRESS BUFFER+6

FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/

RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/

RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/

NO_LOG_NAME:
	.ASCID	/No logical name returned from the device test!/

MPM_LITERAL:				; Shared memory must be called "MPM"
	.ASCIC	/MPM/

TESTABLE_DESC:				; Initial part of msg str for testable
	.WORD	TESTABLE_LEN,0		;  units
	.ADDRESS TESTABLE
TESTABLE:
	.REPEAT MAX_DEV_DESIG		; Save enough room for device designation
	.ASCII / /
	.ENDR
	.ASCII	/  testable    /
	TESTABLE_LEN = .-TESTABLE

UNTESTABLE_DESC:			; Initial part of msg str for untestable
	.WORD	UNTEST_LEN,0		;  units
	.ADDRESS UNTESTABLE
UNTESTABLE:
	.REPEAT MAX_DEV_DESIG		; Always index same amount so items
	.ASCII / /			;  will line up
	.ENDR
	.ASCII	/  untestable  /
	UNTEST_LEN = .-UNTESTABLE

OVERFLOW_DESC:				; In case we get too many units for one
	.WORD	OVER_LEN,0		;  line this str will keep everything
	.ADDRESS OVERFLOW		;  lined up for continuing lines
OVERFLOW:
	.REPEAT MAX_DEV_DESIG
	.ASCII	/ /
	.ENDR
	.ASCII /              /
	OVER_LEN = .-OVERFLOW

SUMM_HEADER:
	.ASCID	<CR><LF>/ *** Summary of testable and untestable devices. ***/

FORMAT_ERR_MSG:
	.ASCID	/ Error in UETINIDEV.DAT format./

NONE_MSG:				; Msg for no testable units found
	.ASCID	/none/

BLANK_LINE:
	.ASCID	<CR>


	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

UIC:					; Our UIC
	.LONG	0
QUOTA_LIST:				; Quota list for created subprocess
	.BYTE	PQL$_ASTLM
ASTLM:
	.LONG	0
	.BYTE	PQL$_BIOLM
BIOLM:
	.LONG	0
	.BYTE	PQL$_DIOLM
DIOLM:
	.LONG	0
	.BYTE	PQL$_TQELM
TQLM:
	.LONG	0
	.BYTE	PQL$_LISTEND
TTCHAN:					; Channel associated with ctrl. term.
	.WORD	0

TTNAME_RWPTR:
	.WORD	TTNAME_LEN,0
	.ADDRESS TTNAME
TTNAME:
	.ASCII	/SYS$COMMAND/
	TTNAME_LEN = .-TTNAME
	.BLKB	63-TTNAME_LEN

MBXCHN:
	.WORD	0			; Mailbox channels
MBX1_CHAN:
	.WORD	0
MBX_UNIT:
	.WORD	0			; Mailbox unit number

FLAG:					; Miscellaneous flag bits
	.WORD	0			; (See Equated Symbols for definitions)
ARG:
	.LONG	2			; Argument count
	.LONG	0			; Storage location for next DDB address
	.LONG	0			; Storage location for next UCB address

LOG_RCD:				; Message vector for $PUTMSG
	.WORD	3			; Arg count
	.WORD	^B0001			; Message only flag
	.LONG	UETP$_TEXT		; Message ID
	.WORD	1			; FAO arg count
	.WORD	0			; No new msg flags
MSG_PTR:
	.LONG	BUFFER_PTR		; Message buffer

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

BUFA:
	.LONG	BUFFERA_LEN 		; FAO output string descriptor #2
	.ADDRESS BUFFERA
BUFA1:
	.LONG	0			; Output string descriptor #2
	.ADDRESS BUFFERA
BUFFERA:
	.BLKB	50			; FAO output buffer #2
	BUFFERA_LEN = .-BUFFER

DEVDSC:					; Device name descriptor
	.WORD	MAX_DEV_DESIG,0
	.ADDRESS DEV_NAME

MBX_BUF:
	.BLKB	MBX_SIZE		; Mail box read buffer

TEST_DSC:				; Device test file name descriptor
	.LONG	13
	.ADDRESS TEST_NAME

TEST_NAME:				; Device test file name
	.BLKB	13

LOGNAM_DSC:				; Logical name descriptor
	.LONG	0
	.ADDRESS LOGNAM
LOGNAM:
	.BLKB	17
DEV:
	.LONG	DIB$K_LENGTH		; Device Information Block
	.ADDRESS DEVBUF
DEVBUF:
	.BLKB	DIB$K_LENGTH

DEV_NAME:				; Device name buffer
	.BLKB	MAX_DEV_DESIG

ERROR_COUNT:				; Cumulative error count at runtime
	.LONG	0

STATUS:					; Status value on program exit
	.LONG	0

IOSTAT:					; QIO I/O status block
	.QUAD	0

AST_MODE:				; Prior setting of AST delivery
	.LONG	0

SS_FAIL_MODE:				; Prior setting of SS failure mode
	.LONG	0

INADDRESS:				; $CRMPSC address storage
	.LONG	0,0
OUTADDRESS:
	.LONG	0,0

UNIT_NUMBER:				; Current dev unit number for GET_LINE
	.WORD	0

TST_CNT:				; Count of UETCONT00 data records
	.LONG	0

DEVNAM_LEN:				; Current device name length
	.WORD	0

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

OUTSTR_DESC:				; Buffer for building output str for
	.LONG	0			;  summary 
	.ADDRESS OUTSTR
OUTSTR:
	.BLKB	80

UNIT_NUM:				; Unit number from UETINIDEV
	.BLKB MAX_UNIT_DESIG

UNIT_LEN:				; Length of unit number
	.WORD

; descriptors for start and stop sentinels

START_DESC:
	.LONG START_STR_LEN			; fill in with default
	.ADDRESS START_STR

START_STR:
	.ASCII /BEGIN/
	START_STR_LEN = .-START_STR
	.BLKB TEXT_BUFFER			; extra space if needed

STOP_DESC:
	.LONG STOP_STR_LEN			; fill in with default
	.ADDRESS STOP_STR

STOP_STR:
	.ASCII /ENDED/
	STOP_STR_LEN = .-STOP_STR
	.BLKB TEXT_BUFFER			; extra space if needed

TEMP_BUFF_DESC:
	.WORD TEXT_BUFFER,0			; temp buffer to hold capitalized
	.ADDRESS TEMP_BUFF_STR			; record to check for END sentenial

TEMP_BUFF_STR:
	.BLKB TEXT_BUFFER


	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

INI_FAB:				; Allocate FAB for UETINIDEV
	$FAB-
	FAC = <GET,PUT,UPD,TRN>,-
	RAT = CR,-
	SHR = <GET,PUT,UPI>,-
	FNM = <UETINIDEV.DAT>

INI_RAB:				; Allocate RAB for UETINIDEV
	$RAB-
	FAB = INI_FAB,-
	UBF = BUFFER,-
	RBF = BUFFER,-
	USZ = REC_SIZE

SUP_FAB:				; Allocate FAB for UETSUPDEV
	$FAB-
	FAC = GET,-
	SHR = <UPI,GET>,-
	RAT = CR,-
	FOP = UFO,-
	FNM = <UETSUPDEV.DAT>

CON_FAB:				; Allocate FAB for UETCONT00
	$FAB-
	FAC = <PUT>,-
	RAT = CR,-
	FNM = <UETCONT00.DAT>

CON_RAB:				; Allocate RAB for UETCONT00
	$RAB-
	FAB = CON_FAB

LOG_FAB:				; Log file FAB
	$FAB	FNM = <UETINIT01.LOG>,-
		RAT = CR,-
		FAC = PUT
LOG_RAB:				; Log file RAB
	$RAB	FAB = LOG_FAB,-
		RBF = BUFFER,-
		RSZ = TEXT_BUFFER
TMPLOG_FAB:				; Temporary log file FAB	
	$FAB	RAT = CR,-
		FAC = GET

TMPLOG_RAB:				; Temporary log file RAB
	$RAB	FAB = TMPLOG_FAB,-
		UBF = BUFFER,-
		USZ = TEXT_BUFFER
DDB_RFA:
	.BLKB	6			; Storage for current DDB RFA

	.SBTTL	Main Program
	.PSECT	UETINIT01,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

.ENTRY UETINIT01,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler
	$CREATE FAB = LOG_FAB,-
		ERR = RMS_ERROR		; Create the log file
	$CONNECT RAB = LOG_RAB,-
		 ERR = RMS_ERROR	; Connect the RAB
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	TSTNAM			; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
	BISW2	#BEGIN_MSGM,FLAG	; Set flag so we don't type it twice
	$SETPRN_S PRCNAM = TSTNAM	; Set the process name
10$:
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,-
		  RSLLEN = TTNAME_RWPTR,-
		  RSLBUF = TTNAME_ROPTR	; Translate the logical name
	MOVAL	TTNAME,TTNAME_RWPTR+4	; Undo possible previous PPF fixup
	CMPL	R0,#SS$_NOTRAN		; Have we reached the end yet?
	BEQL	20$			; Br if yes
	CMPB	#^X1B,TTNAME		; Is this a process permanent file?
	BNEQ	10$			; Br if not
	SUBW	#4,TTNAME_RWPTR		; Remove  RMS overhead from PPF name...
	ADDL	#4,TTNAME_RWPTR+4	; ...
	BRB	10$			; Now it's safe to retranslate
20$:
	$GETDEV_S DEVNAM = TTNAME_RWPTR,-
		  PRIBUF = DEV		; Get its device type
	CMPB	DEVBUF+DIB$B_DEVCLASS,#DC$_TERM ; Is this a terminal?
	BNEQ	30$			; BR if no
	$ASSIGN_S DEVNAM = TTNAME_RWPTR,- ; Set up for CTRL/C AST's
		  CHAN   = TTCHAN
	$QIOW_S	CHAN     = TTCHAN,-	; Enable CTRL/C AST's...
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND
	PUSHAL	TSTNAM			; ...and tell the user...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS ; ...how to abort gracefully...
	CALLS	#3,G^LIB$SIGNAL		; ...
30$:
	MOVAL	INI_RAB,R10		; Set the RAB pointer for UETINIDEV.DAT
	$CREATE	FAB = INI_FAB,-
		ERR = RMS_ERROR		; Create file "UETINIDEV.DAT"
	$CONNECT RAB = (R10)		; Connect the RAB and FAB
	$OPEN	FAB = SUP_FAB,-
		ERR = RMS_ERROR		; Open "UETSUPDEV.DAT"
	MOVAL	CON_RAB,R11		; Init RAB address
	$CREATE FAB = CON_FAB,-
		ERR = RMS_ERROR		; Create file "UETCONT00.DAT"
	$CONNECT RAB = (R11),-
		 ERR = RMS_ERROR	; Connect the RAB and FAB
	MOVZBW	PHASE_NAME,RAB$W_RSZ(R11) ; Set the record size
	MOVAL	PHASE_NAME+1,RAB$L_RBF(R11) ; Set the record address
	$PUT	RAB = (R11),-
		ERR = RMS_ERROR		; Write the record
	MOVZBW	LOG_NAME,RAB$W_RSZ(R11) ;  Set the record size
	MOVAL	LOG_NAME+1,RAB$L_RBF(R11) ; Set the record address
	$PUT	RAB = (R11),-
		ERR = RMS_ERROR		; Write the record
	MOVZBW	HEADER_REC,RAB$W_RSZ(R11) ; Set the record size
	MOVAL	HEADER_REC+1,RAB$L_RBF(R11) ; Set the record address
	$PUT	RAB = (R11),-
		ERR = RMS_ERROR		; Write the record
	$CRMPSC_S CHAN = SUP_FAB+FAB$L_STV,- ; Create the global section
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		GSDNAM = SUPDEV_GBLSEC,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_GBL
	SUBL3	OUTADDRESS,OUTADDRESS+4,R6 ; Create global section length
	$TRNLOG_S LOGNAM = REPORT_NAME,-
		  RSLBUF = FAO_BUF	; Get long or short report format
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/S/,BUFFER		; Is it short report?
	BNEQ	40$			; BR if not
	BISW2	#SHRT_RPRTM,FLAG	; Else set the flag bit
40$:
	$CRELOG_S TBLFLG = #1,-		; Set group logical name MODE...
		  LOGNAM = MODE,-	; ...to ONE
		  EQLNAM = EQUA1
	MOVL	L^IOC$GL_DEVLIST,ARG+4	; Get I/O data base list header
	$CREMBX_S CHAN  = MBXCHN	; Create a mailbox for the...
					; ...subprocess termination mailboxs
	$GETCHN_S CHAN   = MBXCHN,-
		  PRIBUF = DEV		; Get the mail box unit number
	MOVW	DEVBUF+DIB$W_UNIT,MBX_UNIT ; Save the mailbox unit number
	$GETJPI_S ITMLST = JPI_LIST	; Get our current quotas etc
	CLRL	TST_CNT			; Init the record counter
	$CREMBX_S CHAN   = MBX1_CHAN,-
		  MAXMSG = #MAX_DEV_DESIG,-
		  LOGNAM = TSTNAM	; Create the interprocess mailbox
; Fall into DDB loop

;
; For each testable item in the IOC$GL_DEVLIST chain, write a line to the
; UETINIDEV.DAT file corresponding to that item's DDB.  Do similar things
; for other testable peripherals which have no DDBs (e.g., shared memory).
;
LOOP:
	BICW2	#DEVNOTSUPM,FLAG	; Clear the device support flag
	SUBL3	OUTADDRESS,OUTADDRESS+4,R6 ; Create global section length
	$CMKRNL_S ROUTIN = GET_LINE,-	; Get info about some device
		  ARGLST = ARG
	TSTL	R0			; Are we all done
	BNEQ	10$			; BR if no
	BRW	SUC_EXIT		; BR if yes
10$:
	$FAO_S	CTRSTR = CS2,-		; Convert the device unit number...
		OUTBUF = BUFA,-		; ...to a decimal ASCII string
		OUTLEN = BUFA1,-
		P1     = UNIT_NUMBER
	SUBW3	#6,BUFFER_PTR,DEVNAM_LEN ; Figure the device name length
	ADDW3	DEVNAM_LEN,BUFA1,DEVDSC	; Put the device designation length...
					; ...in the device name desc
	ADDL3	BUFFER_PTR,#BUFFER,R7	; Generate the place to add the unit number
	MOVC3	BUFA1,BUFFERA,(R7)	; Add on the unit number
	MOVC3	DEVDSC,BUFFER+6,DEV_NAME ; Save the device name
	BBC	#NON_IOV,FLAG,15$	; BR if flag not set
	BRW	50$			; BR to fake $GETDEV for non-I/O devs
15$:
	CMPL	OPNAM,BUFFER+6		; We don't do OPA0's
	BNEQ	20$			; Skip if yes
	BRW	60$			; Bail out if this is one
20$:
	CMPL	CSNAM,BUFFER+6		; We don't do CSA1's either
	BNEQ	30$			; Skip if not one
	BRW	60$			; Bail out if this is one
30$:
	CMPL	NETNAM,BUFFER+6		; We don't do Decnet in the device tests
	BNEQ	35$			; Skip if not one
	BRW	70$			; But we support them so don't do DENOSU
35$:
	CMPC3	RTNAM,RTNAM+8,BUFFER+6	; We don't do remote terminals
	BNEQ	40$			; Skip if not one
	BRW	70$
40$:
	$GETDEV_S DEVNAM = DEVDSC,-
		  SCDBUF = DEV
	MOVZBL	DEVBUF+DIB$B_DEVCLASS,R7
	MOVZBL	DEVBUF+DIB$B_DEVTYPE,R8
	$FAO_S	CTRSTR = CS1,-
		OUTBUF = BUFA,-
		P1     = R7,-
		P2     = R8
	MATCHC	#6,BUFFERA,R6,@OUTADDRESS ; Find the device class and type
	BEQL	80$			; BR if it was found
	$FAO_S	CTRSTR = CS3,-
		OUTBUF = BUFA,-
		    P1 = R7		; Try for full class support
	MATCHC	#6,BUFFERA,R6,@OUTADDRESS ; Find the device class only
	BEQL	80$			; BR if found
	BRB	60$			; BR if not supported
50$:
	MOVC3	MPM_CS,MPM_CS+8,BUFFERA	; Just imitate $FAO results for non-I/O
	MATCHC	#6,BUFFERA,R6,@OUTADDRESS ; Match fake results
	BEQL	80$			; BR if supported
60$:
	BBS	#SHRT_RPRTV,FLAG,70$	; Skip the type out if short report
	DECL	DEVDSC			; Set the name length
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	TSTNAM			; Parameters on the stack
	PUSHL	#2
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_WARNING,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	CALLS	#4,G^LIB$SIGNAL		; And print the message
70$:
	MOVB	#^A/N/,BUFFER+4		; Deselect the device for testing
	BISW2	#DEVNOTSUPM,FLAG	; Set the device not supported flag
	BRB	90$
80$:
	MOVL	R3,R9			; Save the string start address
	MOVZWL	-8(R9),R6		; Get the record size
	MOVC3	#13,(R9),TEST_NAME	; Save the test name
	MOVZWL	DEVNAM_LEN,DEVDSC	; Get the device name length
	$QIOW_S	CHAN   = MBX1_CHAN,-
		FUNC   = #IO$_WRITEVBLK!IO$M_NOW,-
		IOSB   = IOSTAT,-
		P1     = DEV_NAME,-
		P2     = DEVDSC		; Put the device designation in the mailbox
	MOVW	BUFFER_PTR,RAB$W_RSZ(R10) ; Set line size
	$PUT	RAB = (R10),-
		ERR = RMS_ERROR		; Write the DDB line
	MOVC3	#6,RAB$W_RFA(R10),DDB_RFA ; Save the DDB RFA
90$:
	; Fall into UCB loop


; Write UETINIDEV.DAT line for each UCB of the testable device found above.
LOOP1:
	$CMKRNL_S ROUTIN = GET_LINE,-
		  ARGLST = ARG		; Get a UCB line
	
	BBS	#DEVNOTSUPV,FLAG,10$	; Br if the device is not supported
	BBS	#ALL_FINISV,FLAG,30$	; BR if all finished
	MOVW	BUFFER_PTR,RAB$W_RSZ(R10) ; Set line size
	MOVW	RAB$W_RSZ(R10),RAB$L_CTX(R10) ; Save the record size for PUT
	$PUT	RAB = (R10),-
		ERR = RMS_ERROR		; Write the UCB record
10$:
	BBC	#UCB_NXTLIV,FLAG,20$	; Br if no more UCB's
	BRW	LOOP1			; Do all of the UCB's
20$:
	BBC	#DEVNOTSUPV,FLAG,30$	; If no test or modification needed
	BRW	LOOP			; Because the device is not supported
30$:					; Therefore do the next DDB
	BICW2	#DEVNOTSUPM,FLAG	; All done with the UCB's
	MOVAL	END_MSG,RAB$L_RBF(R10)	; Set the end message address
	MOVW	#END_MSGL,RAB$W_RSZ(R10) ; Set the end message size
	$PUT	RAB = (R10),-
		ERR = RMS_ERROR		; Write the end message
	$FLUSH	RAB = (R10),-
		ERR = RMS_ERROR		; Make sure the device test sees
					; Everything that we put out
	MOVW	RAB$L_CTX(R10),RAB$W_RSZ(R10) ; Restore the record size
	MOVAL	BUFFER,RAB$L_RBF(R10)	; Restore the record buffer adr
	MOVAL	BUFFER,RAB$L_UBF(R10)	; Restore the record buffer adr
; Make the sub-process which will see if the devices found above have any
; testable units.
	BICW2	#DNTM,FLAG		; Clear the device not testable flag
	MOVZWL	TEST_DSC,LOGNAM_DSC	; Set the initial file size
	MOVC3	LOGNAM_DSC,TEST_NAME,LOGNAM ; Get the file first name
	LOCC	#^A/./,LOGNAM_DSC,LOGNAM ; Find where the extension goes
	MOVL	LOGEXT,(R1)		; Change the extension
	$CREPRC_S IMAGE = TEST_DSC,-
		  INPUT = TSTNAM,-	; Logical name of interprocess mailbox
                  OUTPUT= LOGNAM_DSC,-
		  QUOTA = QUOTA_LIST,-
		  MBXUNT= MBX_UNIT	; Create the subprocess
	$QIOW_S	 CHAN = MBXCHN,-
		  EFN = #1,-
		 FUNC = #IO$_READVBLK,-
		   P1 = MBX_BUF,-
		   P2 = #MBX_SIZE	; Set up the mailbox read
	MOVB	LOGNAM_DSC,TMPLOG_FAB+FAB$B_FNS ; Set the file name size
	MOVL	LOGNAM_DSC+4,-
		TMPLOG_FAB+FAB$L_FNA	; Set the file name address
	MOVAL	BUFFER,LOG_RAB+RAB$L_RBF ; Set the buffer write address
	$OPEN	FAB = TMPLOG_FAB,-
		ERR = RMS_ERROR		; Open the temp log file
	$CONNECT RAB = TMPLOG_RAB,-
		 ERR = RMS_ERROR	; Connect the temp log file
	BICW2	#<BEGIN_FOUNDM!END_FOUNDM>,-
		FLAG			; Clear begin and end sentinel flags
40$:
	$GET	RAB = TMPLOG_RAB	; Get a record from the temp log file
	CMPL	R0,#RMS$_EOF		; Is this the end?
	BNEQ	44$			; BR if it isn't
	BRW	50$			; All done with log file
44$:
	MOVW	TMPLOG_RAB+RAB$W_RSZ,-
		LOG_RAB+RAB$W_RSZ	; Copy over the transfer size
	$PUT	RAB = LOG_RAB,-
		ERR = RMS_ERROR		; Write the record to the log file
	MOVW	TMPLOG_RAB+RAB$W_RSZ,-
		BUFFER_PTR		; Copy over the transfer size
	BBS	#BEGIN_FOUNDV,FLAG,45$ ; Br if begin sentinel has been found
	PUSHAQ	BUFFER_PTR
	PUSHAQ	TEMP_BUFF_DESC
	CALLS	#2,G^STR$UPCASE		; change record to upper case

; look for beginning sentinel

	MATCHC	START_DESC,START_STR,-
		TEMP_BUFF_DESC,TEMP_BUFF_STR	; is there a begin?
	BNEQ	40$			; no, try again
	BISW2	#BEGIN_FOUNDM,FLAG	; We found it - set flag
	BBC	#SHRT_RPRTV,FLAG,46$	; Br if long report
	BRB	40$			; Go do next record
45$:
	BBS	#END_FOUNDV,FLAG,40$	; Br if we already reached end sentinel
	PUSHAQ	BUFFER_PTR
	PUSHAQ	TEMP_BUFF_DESC		; temp storage
	CALLS	#2,G^STR$UPCASE		; change record to upper case

; check for ended sentinel

	MATCHC	STOP_DESC,STOP_STR,-
		TEMP_BUFF_DESC,TEMP_BUFF_STR	; are we at end?
	BEQL	47$			; Br if we are
46$:
	$PUTMSG_S-			; Output record
		MSGVEC = LOG_RCD
	BRW	40$			; Do it until the end of input
47$:
	BISW2	#END_FOUNDM,FLAG	; We found end - set flag
	BBC	#SHRT_RPRTV,FLAG,46$	; Br if long report
	BRW	40$
50$:
	$CLOSE	FAB = TMPLOG_FAB,-
		ERR = RMS_ERROR		; Close the temp log file
	$ERASE	FAB = TMPLOG_FAB,-
		ERR = RMS_ERROR		; Delete the temp log file
	MOVB	#RAB$C_RFA,RAB$B_RAC(R10) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R10) ; Set RFA to DDB line
	$GET	RAB = (R10),-
		ERR = RMS_ERROR		; Go back to the DDB record
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R10) ; Set back to sequential mode
	CMPB	#^A/N/,BUFFER+4		; Any testable devices?
	BEQL	70$			; Br if not
	BLBC	MBX_BUF+ACC$L_FINALSTS,60$ ; No device testable if process failed
	MOVZWL	DEVNAM_LEN,R8		; Get the device name length
	$FAO_S	CTRSTR = CONT_STR,-
		OUTBUF = BUFA,-
		OUTLEN = BUFA1,-
		P1     = #TEST_DSC,-
		P2     = R8,-
		P3     = #DEV_NAME	; Make the UETCONT00 record
	MOVW	BUFA1,RAB$W_RSZ(R11)	; Set the record size
	MOVAL	BUFFERA,RAB$L_RBF(R11)	; Set the record address
	$PUT	RAB = (R11),-
		ERR = RMS_ERROR		; Write the record
	INCL	TST_CNT			; One more record
	BRB	70$			; Skip the fail stuff
60$:
	BISW2	#DNTM,FLAG		; Set device not testable flag
	MOVB	#^A/N/,BUFFER+4		; Set DDB not testable
	$UPDATE	RAB = (R10)		; Update the DDB record
70$:
	$GET	RAB = (R10),-
		ERR = RMS_ERROR		; Get a UCB record
	CMPB	#^A/U/,BUFFER		; Are all UCB's done?
	BNEQ	110$			; Br if yes
	BBC	#DNTV,FLAG,90$		; If devices testable then skip the update
	MOVB	#^A/N/,BUFFER+4		; Set not testable status
	$UPDATE	RAB = (R10)		; Update the record
90$:
	BRB	70$			; The next UCB
110$:
	$TRUNCATE RAB = (R10),-
		  ERR = RMS_ERROR	; Eat the END OF FILE message
	BBS	#ALL_FINISV,FLAG,SUC_EXIT ; BR if all devs are known done
	BRW	LOOP			; Do more DDB's

SUC_EXIT:
	MOVAL	END_MSG,RAB$L_RBF(R10)	; Set the end message address
	MOVW	#END_MSGL,RAB$W_RSZ(R10) ; Set the end message size
	$PUT	RAB = (R10),-
		ERR = RMS_ERROR		; Write the end message
	$FLUSH	RAB = (R10),-
		ERR = RMS_ERROR		; Make sure everything gets output
	$REWIND	RAB = (R10),-		; Go back to beginning of Uetinidev
		ERR = RMS_ERROR
	MOVAL	SUMM_HEADER,MSG_PTR	; Set up to output summary header
	MOVW	SUMM_HEADER,OUTSTR_DESC	; ...get msg lenth
	MOVC3	SUMM_HEADER,SUMM_HEADER+8,- ; ...set up initial msg
		OUTSTR
	BSBW	SUMM_OUTPUT		; Go output line
	$GET	RAB = (R10),-
		ERR = RMS_ERROR		; Get a DDB record
DDB_LOOP:
	MOVAL	BLANK_LINE,MSG_PTR	; Put output desc in putmsg vector
	MOVW	BLANK_LINE,OUTSTR_DESC	; ...get msg lenth
	MOVC3	BLANK_LINE,BLANK_LINE+8,- ; ...set up initial msg
		OUTSTR
	BSBW	SUMM_OUTPUT		; Go output blank line
	MOVAL	OUTSTR_DESC,MSG_PTR	; Put output desc in putmsg vector
	CMPB	#^A/D/,BUFFER		; DDB ?
	BEQL	10$
	PUSHAL	FORMAT_ERR_MSG		; If not a DDB something is wrong with
	PUSHL	#1			; ...UETINIDEV.DAT - output msg and
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...quit
	PUSHL	#3			; Current arg count
	BRW	ERROR_EXIT
10$:
	MOVW	TESTABLE_DESC,OUTSTR_DESC	; Get msg length
	MOVC3	TESTABLE_DESC,TESTABLE_DESC+8,- ; Set up initial msg
		OUTSTR
	CLRL	R8
	SUBW3	#6,RAB$W_RSZ(R10),R8		; Calc dev desig length
	MOVC3	R8,BUFFER+6,OUTSTR		; Put dev desig in output buffer
	MOVB	#^A/:/,OUTSTR(R8)		; Insert ":" after dev desig
	CLRL	R6				; Clear unit counter
	CLRL	R7				; Clear untestable found flag
	CMPB	#^A/T/,BUFFER+4			; Is DDB marked testable?
	BNEQ	20$
	BISW2	#DO_TESTABLEM,FLAG		; We will look testable units
	BRB	30$
20$:
	MOVC3	NONE_MSG,NONE_MSG+8,-		; Put "none" in output buff
		OUTSTR+TESTABLE_LEN
	ADDW2	NONE_MSG,OUTSTR_DESC		; Update buffer length
	BSBW	SUMM_OUTPUT			; Go output line
	BICW2	#DO_TESTABLEM,FLAG		; Now we will do untestable units
	MOVW	UNTESTABLE_DESC,OUTSTR_DESC	; Get msg length
	MOVC3	UNTESTABLE_DESC,UNTESTABLE_DESC+8,- ; Set up untestable msg
		OUTSTR
30$:
	MOVC3	#6,RAB$W_RFA(R10),DDB_RFA 	; Save the DDB RFA
UCB_LOOP:
	$GET	RAB = (R10),-
		ERR = RMS_ERROR		; Get a UCB record
	CMPB	#^A/U/,BUFFER		; Is it a UCB ?
	BEQL	10$
	BRW	90$
10$:
	CMPB	#^A/T/,BUFFER+4		; Is unit marked testable
	BEQL	30$
	BBC	#DO_TESTABLEV,FLAG,20$	; Br if we are doing untestable units
	MOVZBL	#1,R7			; Set flag - untestable unit found
	BRB	UCB_LOOP		; Go look for testable units
20$:
	CLRL	R7			; Clear flag so we will exit UCB loop
	BRB	40$
30$:
	BBC	#DO_TESTABLEV,FLAG,UCB_LOOP ; BR if not doing testable units
40$:
	MOVZWL	OUTSTR_DESC,R8		; Get current output str length
	SKPC	#^A/0/,#5,BUFFER+6	; Skip over zeros in unit number
	BNEQ	50$			; Br if non-zero char was found
	DECL	R1			; Move R1 back to last zero char
	MOVZBL	#1,R0			; Set char count to one
50$:
	MOVW	R0,UNIT_LEN		; Save unit number length
	MOVL	R1,R11			; Save unit number str address
	MOVC3	UNIT_LEN,(R11),UNIT_NUM	; Save unit number str
	INCL	R6			; Count (un)testable units
	CMPW	#1,R6			; First testable unit found?
	BNEQ	60$			; BR if not first
	MOVC3	UNIT_LEN,UNIT_NUM,-	; Add first testable unit to str
		OUTSTR(R8)
	ADDB2	UNIT_LEN,OUTSTR_DESC	; Update str length
	BRW	UCB_LOOP		; Go do next UCB
60$:
	ADDL3	UNIT_LEN,OUTSTR_DESC,R9	; Add unit num len + current str len
	ADDB2	#3,R9			; There must be room for ", nnn," on line
	CMPW	#^D80,R9		; Will this unit fit on line?
	BGEQ	70$			; BR if no room on line
	MOVB	#^A/,/,OUTSTR(R8)	; Add "," to end of line
	INCW	OUTSTR_DESC		; Update str length
	BSBW	SUMM_OUTPUT		; Go output line
	MOVW	OVERFLOW_DESC,OUTSTR_DESC	; Get msg length
	MOVC3	OVERFLOW_DESC,OVERFLOW_DESC+8,- ; Set up for overflow str
		OUTSTR
	MOVZWL	OUTSTR_DESC,R8		; Get current str length
	BRB	80$
70$:
	MOVW	#^A/, /,OUTSTR(R8)	; Add ", " to end of line
	ADDW2	#2,OUTSTR_DESC		; Update str length
	MOVZWL	OUTSTR_DESC,R8		; Get new str length
80$:
	MOVC3	UNIT_LEN,UNIT_NUM,-	; Add unit number to str
		OUTSTR(R8)
	ADDW2	UNIT_LEN,OUTSTR_DESC	; Update str length
	BRW	UCB_LOOP		; Go do next UCB
90$:
	TSTW	R6			; Were any units found?
	BEQL	100$
	BSBW	SUMM_OUTPUT		; Go output line
100$:
	BLBC	R7,110$			; Br if no untestable units
	BICW2	#DO_TESTABLEM,FLAG	; Now we will do untestable units
	MOVB	#RAB$C_RFA,RAB$B_RAC(R10) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R10) ; Set RFA to DDB line
	$GET	RAB = (R10),-
		ERR = RMS_ERROR		; Go back to the DDB record
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R10) ; Set back to sequential mode
	MOVW	UNTESTABLE_DESC,OUTSTR_DESC	; Get msg length
	MOVC3	UNTESTABLE_DESC,UNTESTABLE_DESC+8,- ; Set up untestable msg
		OUTSTR
	CLRL	R6			; Clear unit counter
	BRW	UCB_LOOP		; Go do untestable units
110$:
	CMPB	#^A/E/,BUFFER		; End of Uetinidev.dat?
	BEQL	120$			; Br if end
	BRW	DDB_LOOP		; Go do next DDB
120$:
	$CLOSE	FAB = INI_FAB
	MOVAL	BLANK_LINE,MSG_PTR	; Put output desc in putmsg vector
	MOVW	BLANK_LINE,OUTSTR_DESC	; ...get msg lenth
	MOVC3	BLANK_LINE,BLANK_LINE+8,- ; ...set up initial msg
		OUTSTR
	BSBW	SUMM_OUTPUT		; Go output blank line
	$FAO_S	CTRSTR = TST_CNT_STR,-
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		P1     = TST_CNT	; Create a string of the UETCONT00 record count
	$CRELOG_S TBLFLG = #1,-
		  LOGNAM = TEST_COUNT,-
		  EQLNAM = BUFFER_PTR	; Create the UETCONT00 record count logical name
	PUSHL	#0			; Set the time flag
	PUSHAL	TSTNAM			; Push the test name
	PUSHL	#2			; Push arg count
	PUSHL	#UETP$_ENDEDD!STS$K_SUCCESS ; Push signal name
	CALLS	#4,G^LIB$SIGNAL		; Output the message
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status

SUMM_OUTPUT:
	; This routine always outputs the summary to the log file.
	; If long report is specified it also outputs to SYS$OUTPUT.

	MOVW	OUTSTR_DESC,LOG_RAB+RAB$W_RSZ ; Get the message size
	MOVAL	OUTSTR,LOG_RAB+RAB$L_RBF ; Set the message address
	$PUT	RAB = LOG_RAB,-
		ERR = RMS_ERROR		; Write the log file
	BBS	#SHRT_RPRTV,FLAG,10$	; Skip if short report
	$PUTMSG_S-			; Output blank line
		MSGVEC = LOG_RCD
10$:
	RSB


	.SBTTL GET_LINE
;++
; FUNCTIONAL DESCRIPTION:
;	This routine collects I/O device information from the VMS I/O data
;	structures and forms it into a printable line in one of two formats.
;
;	1.	DDB line:
;			 DDB 0 DDD
;	2.	UCB line:
;			 UCB 1 UUUUU
;
;		Where DDD is the device designation in VMS and
;		      UUUUU is the device unit number in hex.
;
;	Pointers are maintained via the argument list where the two long word
;	arguments point to the next DDB and UCB to be accessed. A flag is maintained
;	in location FLAG to indicate the next type of line to be generated.
;	This routine executes in KRNL mode.
;
; CALLING SEQUENCE:
;	$CMKRNL_S ROUTIN = GET_LINE,-
;		  ARGLST = ARGS
;
; INPUT PARAMETERS:
;	ARG+4 contains address of next DDB to be referenced
;	ARG+8 contains address of next UCB to be referenced
;
; IMPLICIT INPUTS:
;	FLAG  bit UCB_NXTLIV = 0 means a DDB line will be generated next
;	FLAG  bit UCB_NXTLIV = 1 means a UCB line will be generated next
;
; OUTPUT PARAMETERS:
;	ARG+4 is updated automatically
;	ARG+8 is updated automatically
;
; IMPLICIT OUTPUTS:
;	FLAG  bit UCB_NXTLIV is updated automatically
;	FAO_BUF   contains a string descriptor for the output line
;	UNIT_NUMBER contains the unit number of the line that is output
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

GET_LINE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BBS	#NON_IOV,FLAG,GET_MPM_LINE ; BR if IOC$GL_DEVLIST exhausted
	BBS	#UCB_NXTLIV,FLAG,UNIT	; Br if a UCB to do now
	MOVL	4(AP),R8		; Get the DDB address
	BEQL	DDB_END			; Br if no more DDB's
	MOVAL	DDB_CTRSTR,R9		; Set for DDB control string
	MOVAL	DDB$T_NAME(R8),R10	; Get device designation
	MOVL	DDB$L_UCB(R8),8(AP)	; Update the UCB address
	MOVL	8(AP),R11		; Save a copy of the UCB address
	MOVW	UCB$W_UNIT(R11),UNIT_NUMBER ; Save the unit number
	MOVL	DDB$L_LINK(R8),4(AP)	; Update the DDB address
	BISW2	#UCB_NXTLIM,FLAG	; Set the UCB next flag
	BRW	COMMON			; Goto common code
UNIT:
	MOVAL	UCB_CTRSTR,R9		; Set for UCB control string
	MOVL	8(AP),R8		; Get the UCB address
	MOVZWL	UCB$W_UNIT(R8),R10	; Get the device unit number
	MOVW	R10,UNIT_NUMBER		; Save the unit number
	MOVL	UCB$L_LINK(R8),8(AP)	; Update the UCB address
	BNEQ	COMMON			; Br if the next line will be a UCB
	BICW2	#UCB_NXTLIM,FLAG	; Otherwise clear the UCB flag
COMMON:
	$FAO_S	CTRSTR = (R9),-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		    P1 = R10		; Create the string
	RET				; Return with FAO status

DDB_END:
	BISW2	#NON_IOM,FLAG		; Indicate IOC$GL_DEVLIST is exhausted
	BICW2	#UCB_NXTLIM,FLAG	; We have to start with a DDB

GET_MPM_LINE:
	BBS	#UCB_NXTLIV,FLAG,20$	; BR if we're to do a "UCB" now
	MOVL	G^EXE$GL_SHBLIST,04(AP)	; First call yields "DDB"
	BNEQ	10$			; BR if an MPM is connected
	CLRL	R0			; Indicate that all devs are done
	RET
10$:
	MOVAL	DDB_CTRSTR,R9		; Set up to print a DDB line...
	MOVAL	MPM_LITERAL,R10		; ...which always has the name "MPM"
	MOVL	04(AP),08(AP)		; Set up to get first SHB
	MOVL	08(AP),R8		; Point to our SHB for easy reference
	MOVL	SHB$L_ADP(R8),R11	; Point to ADP for this MPM...
	MOVL	ADP$L_CSR(R11),R11	; ...and thence to its CSR
	MOVL	MPM$L_MR(R11),R11	; (I/O space reference restriction)
	EXTZV	#MPM$V_MR_UNIT,-	; Get the unit number of our memory
		#MPM$S_MR_UNIT,R11,R7
	MOVW	R7,UNIT_NUMBER
	BISW2	#UCB_NXTLIM,FLAG	; Further calls will deal with "UCBs"
	BRB	40$			; Use "common" $FAO call

20$:
	MOVAL	UCB_CTRSTR,R9		; Set up to print a UCB line...
	MOVL	08(AP),R8		; Point to our SHB
	BNEQ	30$			; BR if there is one
	BICW2	#UCB_NXTLIM,FLAG	; Indicate no more "UCBs" for MPM
	BISW2	#ALL_FINISM,FLAG	; Indicate no more devs, period!
	MOVL	#SS$_NORMAL,R0		; Give a safe error return
	RET
30$:
	MOVL	SHB$L_ADP(R8),R11	; Point to ADP for this MPM...
	MOVL	ADP$L_CSR(R11),R11	; ...and thence to its CSR
	MOVL	MPM$L_MR(R11),R11	; (I/O space reference restriction)
	EXTZV	#MPM$V_MR_UNIT,-	; Get the unit number of our memory
		#MPM$S_MR_UNIT,R11,R10
	MOVW	R10,UNIT_NUMBER		; ...with its unit
	MOVL	SHB$L_LINK(R8),08(AP)	; Point to next SHB for next call

40$:
	$FAO_S	CTRSTR = (R9),-		; Create either DDB or UCB line
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R10
	RET

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a system service or RMS error occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:	$SETSFM_S ENBFLG = #0		; Disable SS failure mode for PUTMSG
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	20$			; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled
20$:	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#UETP_K
	BNEQ	30$			; BR if this is a system exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6),-
		  ACTRTN = 70$		; Print the message
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Return to the program
30$:
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	40$			; BR if not
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Yes, RMS_ERROR gets to handle them
40$:
	MOVL	CHF$L_SIG_NAME(R6),STATUS ; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,STATUS	; But is it a System Service failure?
	BNEQ	60$			; BR if not - no special case message
	$GETMSG_S MSGID = CHF$L_SIG_ARG1(R6),- ; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	50$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	CHF$L_SIG_ARG1(R6),-	; Give the message...
		#STS$V_SEVERITY,-	; ...the correct severity code
		#STS$S_SEVERITY,(SP)
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	60$
50$:
	PUSHL	CHF$L_SIG_ARG1(R6)	; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
60$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT

70$:
	.WORD	^M<R2>			; PUTMSG action routine
	MOVL	4(AP),R2		; Get the message descriptor address
	MOVZWL	(R2),LOG_RAB+RAB$W_RSZ	; Get the message size
	MOVL	4(R2),LOG_RAB+RAB$L_RBF ; Set the message address
	$PUT	RAB = LOG_RAB,-
		ERR = RMS_ERROR		; Write the log file
	MOVL	#SS$_NORMAL,R0		; Set the return status code
	RET

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	The FAB or RAB associated with the RMS call.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	RMS_COMMON		; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
RMS_COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get the file name size
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	TSTNAM			; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	BISW2	#CONTROL_CM,FLAG	; Set CTRL/C flag bit...
	MOVL	#<SS$_CONTROLC&^C7-	; ...and exit status
		!STS$K_WARNING-
		!STS$M_INHIB_MSG>,STATUS
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	$SETAST_S ENBFLG = #0		; ASTs can play havoc with messages
	BBS	#BEGIN_MSGV,FLAG,10$	; BR if "begin" msg has already been output
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	TSTNAM			; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
10$:
	ADDL3	(SP)+,#7,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	TSTNAM			; Push test name...
	PUSHL	#2			; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch

	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup on exits.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	Location STATUS contains the exit status, FLAG has synchronizing bits.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$SETAST_S ENBFLG = #0		; We're finished - no more ASTs
	$DELLOG_S LOGNAM = MODE,-
		  TBLFLG = #1		; Clean up the logical names
	$DISCONNECT  RAB = INI_RAB	; Disconnect the RAB from the FAB
	$CLOSE	     FAB = INI_FAB	; Close the UETINIDEV.DAT file
	$CLOSE	     FAB = CON_FAB	; Close the UETCONT00.DAT file
	$DISCONNECT  RAB = LOG_RAB	; Disconnect the RAB from the FAB
	$CLOSE	     FAB = LOG_FAB	; Close the UETINIT01.LOG file
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETINIT01
