	.TITLE	SATSSS56 SATS SYSTEM SERVICE TESTS  WAITS (SUCC S.C.)
	.IDENT	'V03-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSTST (SATS SYSTEM SERVICE TESTS)
;
; ABSTRACT:
;
;		THIS MODULE CONTAINS SUBROUTINES WHICH, WHEN LINKED
; WITH SUCCOMMON.OBJ, FORM TEST MODULE SATSSS56 TO TEST SUCCESSFUL
; OPERATION OF THE 3 WAIT SYSTEM SERVICES. EACH SERVICE IS INVOKED
; UNDER VARIOUS INPUT CONDITIONS WITH VARYING INPUT PARAMETERS. ONLY
; SUCCESSFUL STATUS CODES ARE EXPECTED IN THIS TEST MODULE.  CORRECT 
; OPERATION OF EACH SERVICE FOR EACH OF ITS ISSUANCES IS VERIFIED BY
; CHECKING FOR AN SS$_NORMAL STATUS CODE, EXPECTED RETURN ARGUMENTS
; AND EXPECTED FUNCTIONALITY PERFORMED.
;
; ENVIRONMENT:	USER MODE IMAGE; NEEDS CMKRNL PRIVILEGE,
;		DYNAMICALLY ACQUIRES OTHER PRIVILEGES, AS NEEDED.
;
; AUTHOR: THOMAS L. CAFARELLA,		CREATION DATE: OCT, 1977
;
; MODIFIED BY:
;
;		VERSION 1.5 : 25-MAY-79
;
; 01  LDJ  10/11/79	Fixed bug caused by DIB$K_LENGTH change ACG052.RNO mem
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$PRVDEF				; PRIVILEGE BIT DEFINITIONS
	$PHDDEF				; PROCESS HEADER OFFSETS
	$PQLDEF
	$DIBDEF			; DEVICE INFO BLOCK OFFSETS
;
; MACROS:
;
;
; EQUATED SYMBOLS:
;
EFGR0_MASK	= ^XFF000001		; FLAGS USED BY SYSTEM IN EVENT FLAG GROUP 0
PROC_CONS	= ^X12345678		; PROCESSING CONSTANT -- IN R0 UNTIL WAIT
					; ... SERVICE REPLACES IT WITH A STATUS CODE
;
; BIT NUMBERS FOR FLAGS CONTAINED IN "FLAGS" BYTE:
;
EXP_WAIT	= 0			; WAIT EXPECTED WHEN SUBJECT SERVICE ISSUED
REC_WAIT	= 1			; WAIT RECEIVED AFTER SUBJECT SERVICE ISSUED
PROCESSING	= 2			; MAIN ROUTINE PROCESSING WHEN AST DELIVERED
WAITING		= 3			; MAIN ROUTINE IN E.F. WAIT WHEN AST DELIV'D
FELLTHRU	= 4			; MAIN RTN HAD FALLEN THRU WAIT BY AST DEL'Y
ASTLOOP		= 5			; AST RE-ENTERED TOO OFTEN WITHOUT WAITING
CLUSCHG		= 6			; CLUSTER CHANGED ACROSS A WAIT
;
; OWN STORAGE:
;
	.PAGE
	.PSECT	RODATA,RD,NOWRT,NOEXE,LONG
TEST_MOD_NAME::	STRING	C,<SATSSS56>	; TEST MODULE NAME
TEST_MOD_NAME_D: STRING	I,<SATSSS56>	; TEST MODULE NAME DESCRIPTOR
MSG1_INP_CTL:	STRING	I,<  SSWAT!4ZW: CONDITIONS:>
					; FAO CTL STRING FOR MSG1 IN SUCCOMMON.MAR
MSG3_ERR_CTL::	STRING	I,< *SSWAT!4ZW: !AS> 
					; FAO CTL STRING FOR MSG3 IN SUCCOMMON.MAR
CREPRN:		STRING	I,<SATSSS56_CRE> ; CREATED PROCESS NAME
CLUS_NAME:	STRING	I,<SATSSS56_CLUS> ; SUBJECT CLUSTER NAME
IMAGNAM:	STRING	I,<SYSTST$RES:SATSUT11.EXE> ; IMAGE NAME FOR CREATED PROC
TIMEINCR:	.LONG	-10*1000,-1	; DELTA TIME OF 1 MILLISECOND
CHMKADD:				; THE FOLLOWING 3 LONGWORDS ARE THE
		.ADDRESS SYS$WAITFR+2	; ... CHMK ADDRESSES IN THE SYSTEM SERVICE
		.ADDRESS SYS$WFLAND+2	; ... VECTORS FOR SYS$WAITFR, SYS$WFLAND,
		.ADDRESS SYS$WFLOR+2	; ... AND SYS$WFLOR, RESPECTIVELY.
QUOTALIST:	$QUOTA	CPULM,0		; INFINITE CPU
		$QUOTA	BYTLM,512	; BYTE LIMIT FOR BUFFERED I/O
		$QUOTA	FILLM,2		; OPEN FILE COUNT LIMIT
		$QUOTA	PGFLQUOTA,10	; PAGING FILE QUOTA
		$QUOTA	PRCLM,2		; SUBPROCESS QUOTA
		$QUOTA	TQELM,3		; TIMER QUEUE ENTRY QUOTA
		$QUOTA	LISTEND		; DEFINES END OF LIST
	.PAGE
	.PSECT	RWDATA,RD,WRT,NOEXE,LONG
PRIVMASK:	.BLKQ	1		; ADDR OF PRIVILEGE MASK (IN PHD)
MBXCHAN:	.BLKL	1		; CHAN NO. FOR MAILBOX FOR CREATED PROCESS
MBXCHANINFO:				; CHANNEL INFO RETURNED BY GETCHN
		.LONG	DIB$K_LENGTH
		.ADDRESS .+4
		.BLKB	DIB$K_LENGTH
MBXUNIT:	.BLKL	1		; SAVE AREA FOR MAILBOX UNIT NUMBER
MBXBUFF:	STRING	O,120		; MAILBOX BUFFER FOR CREATED PROCESS
SUBJ_MASK:	.BLKL	1		; MASK TO BE SPECIFIED ON WAIT SYST SERVICES
TRIAL_MASK:	.BLKL	1		; CLUSTER MASK; USED TO SET SUBJECT CLUSTER
TM_WORK:	.BLKW	1		; WORK AREA FOR TRIAL_MASK
CLUS_STATE:	.BLKL	1		; STATE OF SUBJECT CLUSTER
CONSEC_P:	.BYTE	0		; COUNT OF CONSEC. "PROCESSING" AST ENTRIES
FLAGS:		.BYTE	0		; GEN. PURP. FLAGS; BIT DEFINITIONS ABOVE
PROCFLAG:	.BYTE	0		; PROCESS FLAG; 0 = CREATED PROC NON-EXIST.
	.PAGE
	.SBTTL	CONDITION TABLES
;
;	***** CONDITION TABLES FOR WAIT SYSTEM SERVICES *****
;
	COND	1,NOTARG,<WHERE WAITS ARE CLEARED>,-
		  <IN A DIFFERENT PROCESS>,-
		  <IN THE SAME PROCESS>,-
 
	COND	2,NOTARG,<TYPE OF WAIT SYSTEM SERVICE>,-
		  <$WAITFR>,-
		  <$WFLAND>,-
		  <$WFLOR>,-
 
	COND	3,LONG,<EFN>,-
		  <EVENT FLAGS 0-31 (EV FLAG GROUP 0)>,-
		  <EVENT FLAGS 32-63 (EV FLAG GROUP 1)>,-
		  <EVENT FLAGS 64-95 (EV FLAG GROUP 2)>,-
		  <EVENT FLAGS 96-127 (EV FLAG GROUP 3)>,-
 
		    .LONG	0	; EVENT FLAG GROUP (CLUSTER) 0
		    .LONG	32	; EVENT FLAG GROUP (CLUSTER) 1
		    .LONG	64	; EVENT FLAG GROUP (CLUSTER) 2
		    .LONG	96	; EVENT FLAG GROUP (CLUSTER) 3
;
	COND	4,LONG,<MASK>,-
		  <ALL 1-BITS>,-
		  <MIXED 0- AND 1-BITS>,-
 
		    .LONG	^XFFFFFFFF ; ALL 1-BITS
		    .LONG	^A/BITS/   ; MIXED BITS
;
	COND	5,NULL
 
	.PSECT	SATSSS56,RD,WRT,EXE
	.PAGE
	.SBTTL	TM_SETUP, TM_CLEANUP
;++
; FUNCTIONAL DESCRIPTION:
;
;		TM_SETUP AND TM_CLEANUP ARE CALLED TO PERFORM
; REQUIRED HOUSEKEEPING AT THE BEGINNING AND END, RESPECTIVELY, OF
; TEST MODULE EXECUTION.
;
; CALLING SEQUENCE:
;
;	BSBW TM_SETUP   BSBW TM_CLEANUP
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	TM_SETUP:  COND TABLE INDEX REGISTERS (R2,3,4,5,6) CLEARED;
;		   ALL PRIVILEGES ACQUIRED.
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



TM_SETUP::
	CLRL	R2			; INITIALIZE
	CLRL	R3			; .. CONDITION
	CLRL	R4			; .... TABLE
	CLRL	R5			; ...... INDEX
	CLRL	R6			; ........ REGISTERS
	BSBW	MOD_MSG_PRINT		; PRINT TEST MODULE BEGIN MSG
	MOVAL	TEST_MOD_SUCC,TMD_ADDR	; ASSUME END MSG WILL SHOW SUCCESS
	INSV	#SUCCESS,#0,#3,MOD_MSG_CODE ; ADJUST STATUS CODE FOR SUCCESS
	MODE	TO,5$,KRNL		; KERNEL MODE TO ACCESS PHD
	MOVL	@#CTL$GL_PHD,R9		; GET PROCESS HEADER ADDRESS
	MOVAL	PHD$Q_PRIVMSK(R9),PRIVMASK ; GET PRIV MASK ADDRESS
	MODE	FROM,5$	; BACK TO USER MODE
	PRIV	ADD,ALL			; GET ALL PRIVILEGES
	$SETPRN_S TEST_MOD_NAME_D 	; SET PROCESS NAME
	SS_CHECK  NORMAL		; CHECK STATUS CODE RETURNED FROM SETPRN
;
; GET 2 COMMON EVENT FLAG GROUPS ASSOCIATED FOR LATER USE
; ALSO, CREATE A PROCESS & ITS ASSOCIATED MAILBOX
;
	$ASCEFC_S EFN=#64, NAME=CLUS_NAME ; ASSOCIATE GROUP 2
	SS_CHECK NORMAL			; CHECK FOR NORMAL STATUS CODE
	$ASCEFC_S EFN=#96, NAME=CLUS_NAME ; ASSOCIATE GROUP 3
	SS_CHECK NORMAL			; CHECK FOR NORMAL STATUS CODE
	$CREMBX_S CHAN=MBXCHAN, LOGNAM=CREPRN, - 
		  MAXMSG=#120, PROMSK=#0, BUFQUO=#240
					; GET MAILBOX FOR PROCESS
	SS_CHECK NORMAL			; CHECK NORMAL COMPLETION
	$GETCHN_S CHAN=MBXCHAN, PRIBUF=MBXCHANINFO 
					; GET CHANNEL INFO (UNIT NUMBER)
	SS_CHECK NORMAL			; CHECK NORMAL COMPLETION
	MOVZWL	MBXCHANINFO+8+DIB$W_UNIT,MBXUNIT 
					; SAVE MAILBOX UNIT NUMBER
	$CREPRC_S PRCNAM=CREPRN, IMAGE=IMAGNAM, -
		  MBXUNT=MBXUNIT, QUOTA=QUOTALIST
					; CREATE PROCESS WHICH WILL CLEAR WAITS
	SS_CHECK NORMAL			; CHECK ITS COMPLETION
	MOVB	#1,PROCFLAG		; INDICATE CREATED PROCESS EXISTS
	RSB				; RETURN TO MAIN ROUTINE
TM_CLEANUP::
	TSTB	PROCFLAG		; DOES CREATED PROCESS EXIST ?
	BEQL	10$			; NO -- SKIP PROCESS-RELATED SERVICES
	$FORCEX_S PRCNAM=CREPRN, CODE=#SS$_NORMAL
					; FORCE SUBPROCESS TO EXIT & BE DELETED
	$QIOW_S	CHAN=MBXCHAN, FUNC=#IO$_READVBLK, -
		P1=MBXBUFF+8, P2=MBXBUFF
					; WAIT FOR IT TO SEND MAIL
10$:
	$DELMBX_S  MBXCHAN		; DELETE TERMINATION MAILBOX
	$DACEFC_S EFN=#64		; DISASSOCIATE ......
	$DACEFC_S EFN=#96		; .... COMMON CLUSTERS
	BSBW	MOD_MSG_PRINT		; PRINT TEST MODULE END MSG
	RSB				; RETURN TO MAIN ROUTINE
	.PAGE
	.SBTTL	CONDITION SUBROUTINES - SETUP AND CLEANUP 
;++
; FUNCTIONAL DESCRIPTION:
;
;		CONDX AND CONDX_CLEANUP ARE SUBROUTINES WHICH ARE EXECUTED
; BEFORE AND AFTER THE VERIFY SUBROUTINE, RESPECTIVELY, WHENEVER A NEW
; CONDITION X VALUE IS SELECTED (SEE FUNCTIONAL DESCRIPTION OF SUCCOMMON
; ROUTINE IN SUCCOMMON.MAR). ANY SETUP FUNCTION PARTICULAR TO THE 
; CONDITION X TABLE IS INCLUDED IN THE CONDX SUBROUTINE AND CLEANED
; UP, IF NECESSARY, IN THE CONDX_CLEANUP SUBROUTINE. THIS INCLUDES,
; ESPECIALLY, CODE TO DETECT CONFLICTS AMONG CURRENT ENTRIES IN TWO
; OR MORE CONDITION TABLES. IF A CONFLICT IS DETECTED, A NON-ZERO
; VALUE IS STORED INTO CONFLICT, WHICH CAUSES THE CALLING ROUTINE
; (SUCCOMMON) TO SKIP THE CURRENT ENTRY IN THE CONDITION X TABLE.
;
; CALLING SEQUENCE:
;
;	BSBW CONDX   BSBW CONDX_CLEANUP
;	  WHERE X = 1,2,3,4,5
;
; INPUT PARAMETERS:
;
;	CONFLICT = 0
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;
; OUTPUT PARAMETERS:
;
;	CONFLICT SET TO NON-ZERO IF COND TABLE CONFLICT DETECTED.
;
; IMPLICIT OUTPUTS:
;
;	R2,3,4,5,6 PRESERVED
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



COND1::
	RSB				; RETURN TO MAIN ROUTINE
COND1_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND2::
	RSB				; RETURN TO MAIN ROUTINE
COND2_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND3::
;
; CHECK FIRST FOR COND2/COND3 CONFLICT
;
	TSTL	R3			; $WAITFR (SINGLE FLAG) ?
	BNEQU	10$			; NO -- GO CHECK COND1/COND3 CONFLICT
	CMPL	EFN[R4],#32		; YES -- LOCAL EVENT FLAG GROUP 0 ?
	BLSS	20$			; YES -- FLAGS USED BY SYST; GO SET CONFLICT
10$:					; CHECK FOR COND1/COND3 CONFLICT
	TSTL	R2			; WAITS TO BE CLEARED IN DIFF PROCESS ?
	BNEQU	COND3X			; NO -- ALL IS OK; JUST EXIT
	CMPL	EFN[R4],#64		; YES -- LOCAL EVENT FLAG GROUP ?
	BGEQ	COND3X			; NO -- ALL IS OK; JUST EXIT
					; YES -- CAN'T SET LOCAL FLAGS IN DIFF PROC
20$:
	MOVB	ONES,CONFLICT		; INDICATE CONFLICT
COND3X:
	RSB				; RETURN TO MAIN ROUTINE
COND3_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND4::
	RSB				; RETURN TO MAIN ROUTINE
COND4_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
COND5::
	RSB				; RETURN TO MAIN ROUTINE
COND5_CLEANUP::
	RSB				; RETURN TO MAIN ROUTINE
	.PAGE
	.SBTTL	FORM_CONDS
;++
; FUNCTIONAL DESCRIPTION:
;
; 		FORM_CONDS FORMATS AND PRINTS INFORMATION ABOUT
;  THE CURRENT ELEMENT IN EACH OF THE CONDITION TABLES.
;
; CALLING SEQUENCE:
;
;	BSBW FORM_CONDS
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_T - TITLE TEXT FOR CONDX TABLE
;		CONDX_TAB - ELEMENT TEXT FOR CONDX TABLE
;		CONDX_C - CONTEXT OF THE CONDX TABLE
;		CONDX_E - DATA ELEMENTS OF THE CONDX TABLE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	NONE
;
;--



FORM_CONDS::
	$FAO_S	MSG1_INP_CTL,FAO_LEN,FAO_DESC,TESTNUM
					; FORMAT CONDITIONS HEADER MSG
	BSBW	OUTPUT_MSG		; ... AND PRINT IT
	CMPB	#COND1_C,#NULL		; IS CONDITION 1 NULL ?
	BNEQU	10$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
10$:
	MOVAL	COND1_T,MSG_A		; SAVE ADDRESS OF CONDITION 1 TITLE FOR FAO
	MOVL	COND1_TAB[R2],MSG_B 	; SAVE ADDR OF COND 1 CURR TEXT ELT FOR FAO
	MOVB	#COND1_C,MSG_CTXT 	; SAVE CONDITION 1 CONTEXT FOR FAO
	MOV_VAL	COND1_C,COND1_E[R2],MSG_DATA1 ; GIVE COND 1 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 1 MSG
	CMPB	#COND2_C,#NULL		; IS CONDITION 2 NULL ?
	BNEQU	20$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
20$:
	MOVAL	COND2_T,MSG_A		; SAVE ADDRESS OF CONDITION 2 TITLE FOR FAO
	MOVL	COND2_TAB[R3],MSG_B 	; SAVE ADDR OF COND 2 CURR TEXT ELT FOR FAO
	MOVB	#COND2_C,MSG_CTXT 	; SAVE CONDITION 2 CONTEXT FOR FAO
	MOV_VAL	COND2_C,COND2_E[R3],MSG_DATA1 ; GIVE COND 2 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 2 MSG
	CMPB	#COND3_C,#NULL		; IS CONDITION 3 NULL ?
	BNEQU	30$			; NO -- CONTINUE
	BRW	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
30$:
	MOVAL	COND3_T,MSG_A		; SAVE ADDRESS OF CONDITION 3 TITLE FOR FAO
	MOVL	COND3_TAB[R4],MSG_B 	; SAVE ADDR OF COND 3 CURR TEXT ELT FOR FAO
	MOVB	#COND3_C,MSG_CTXT 	; SAVE CONDITION 3 CONTEXT FOR FAO
	MOV_VAL	COND3_C,COND3_E[R4],MSG_DATA1 ; GIVE COND 3 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 3 MSG
	CMPB	#COND4_C,#NULL		; IS CONDITION 4 NULL ?
	BEQLU	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
	MOVAL	COND4_T,MSG_A		; SAVE ADDRESS OF CONDITION 4 TITLE FOR FAO
	MOVL	COND4_TAB[R5],MSG_B 	; SAVE ADDR OF COND 4 CURR TEXT ELT FOR FAO
	MOVB	#COND4_C,MSG_CTXT 	; SAVE CONDITION 4 CONTEXT FOR FAO
	MOV_VAL	COND4_C,COND4_E[R5],MSG_DATA1 ; GIVE COND 4 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 4 MSG
	CMPB	#COND5_C,#NULL		; IS CONDITION 5 NULL ?
	BEQLU	FORM_CONDSX		; YES -- SUBROUTINE IS FINISHED
	MOVAL	COND5_T,MSG_A		; SAVE ADDRESS OF CONDITION 5 TITLE FOR FAO
	MOVL	COND5_TAB[R6],MSG_B 	; SAVE ADDR OF COND 5 CURR TEXT ELT FOR FAO
	MOVB	#COND5_C,MSG_CTXT 	; SAVE CONDITION 5 CONTEXT FOR FAO
	MOV_VAL	COND5_C,COND5_E[R6],MSG_DATA1 ; GIVE COND 5 DATA VALUE TO FAO
	BSBW	WRITE_MSG2		; FORMAT AND WRITE CONDITION 5 MSG
FORM_CONDSX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	VERIFY
;++
; FUNCTIONAL DESCRIPTION:
;
;		VERIFY IS CALLED ONCE FOR EACH COMBINATION OF CONDITION
; TABLE VALUES (AS DETERMINED BY THE INDEX REGISTERS R2,3,4,5,6 FOR
; COND TABLES 1,2,3,4,5, RESPECTIVELY). VERIFY ESTABLISHES THE CONDITIONS
; SPECIFIED BY THE COND TABLES AND ISSUES THE SUBJECT SYSTEM SERVICE
; ($WAITEF, $WFLAND, $WFLOR). THEN, THE SUCCESSFUL OPERATION OF THE SERVICE
; IS VERIFIED BY EXAMINING THE STATUS CODE RETURNED, THE VALUES FOR RETURN
; ARGUMENTS AND THE FUNCTIONALITY PERFORMED. THE EXAMINATIONS TAKE THE 
; FORM OF COMPARISONS AGAINST EXPECTED VALUES. ANY FAILING COMPARISON
; CAUSES AN ERR_EXIT MACRO TO BE EXECUTED (EITHER DIRECTLY, OR INDIRECTLY,
; THROUGH THE SS_CHECK MACRO); ERR_EXIT SETS EFLAG TO NON-ZERO,
; PRINTS ERROR MESSAGES AND CAUSES AN IMMEDIATE RSB TO CALLER.
; WHEN ERR_EXIT IS EXECUTED, FURTHER CALLS TO VERIFY ARE SUPPRESSED,
; AND, AFTER EXECUTING CLEANUP SUBROUTINES, THE IMAGE EXITS.
;
; CALLING SEQUENCE:
;
;	BSBW VERIFY
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_E - ADDRESS OF TABLE OF DATA VALUES FOR CONDX
;		  TABLE. IF THE CONTEXT OF TABLE X IS A SYSTEM SERVICE
;		  ARGUMENT, THE ARGUMENT NAME MAY BE USED AS A SYNONYM
;		  FOR CONDX_E.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	VERIFY HAS NO OUTPUT. SINCE ITS PURPOSE IS TO TEST FOR ERRORS,
;	IT MERELY RETURNS TO CALLER NORMALLY AFTER THE TESTS, PROVIDING
;	ALL WERE SUCCESSFUL; IF AN ERROR IS DISCOVERED, RETURN IS VIA
;	AN ERR_EXIT OR SS_CHECK MACRO, BOTH OF WHICH DOCUMENT DETECTED
;	ERRORS.
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



VERIFY::
	TSTB	CFLAG			; SHOULD CONDITIONS BE PRINTED ?
	BEQL	5$			; NO -- CONTINUE
	BSBW	FORM_CONDS		; YES -- FMT & PRINT ALL CONDS FOR THIS T.C.
5$:
	BSBW	SAVE_REGS		; SAVE REGS 2-6 FOR LATER USE IN AST ROUTINE
	CLRW	TM_WORK			; INIT TRIAL_MASK WORK AREA
	MOVL	MASK[R5],SUBJ_MASK 	; GET SUBJECT MASK FOR THIS TEST CASE
	CMPL	EFN[R4],#32		; EVENT FLAG GROUP 0 ?
	BGEQ	10$			; NO -- CONTINUE
	BICL2	#EFGR0_MASK,SUBJ_MASK 	; YES -- STEER CLEAR OF FLAGS USED BY SYS
10$:
	MOVB	TM_WORK,TRIAL_MASK      ; PROPAGATE TM_WORK ....
	MOVB	TM_WORK,TRIAL_MASK+1    ; ... BYTE VALUE .......
	MOVW	TRIAL_MASK,TRIAL_MASK+2 ; ...... THRU TRIAL_MASK
	MOVL	EFN[R4],R10		; TELL BUILD_CLUST WHICH CLUSTER TO BUILD
	BSBW	BUILD_CLUST		; ESTAB CLUSTER ACCORDING TO TRIAL_MASK
	TSTB	EFLAG			; IS AN ERROR BEING PROCESSED ?
	BEQL	15$			; NO -- CONTINUE
	BRW	VERIFYX			; YES -- RETURN IMMEDIATELY
15$:
	CLRB	FLAGS			; CLEAR ALL FLAGS
	BSBW	SETEXPBIT		; SET EXPECTATION BIT
	$SETIMR_S DAYTIM=TIMEINCR, - 	; SCHEDULE AN AST IN 1 MILLISECOND
		  ASTADR=WAITAST
	SS_CHECK NORMAL			; CHECK SETIMR COMPLETION
	MOVL	#PROC_CONS,R0		; CONSTANT IN R0 TO BE CHECKED IN AST
;
; ****** ONE OF FOLLOWING WAIT CALLS IS THE SUBJECT OF THIS TEST CASE ******
;
	TSTL	R3			; WAITFR (SINGLE FLAG) ?
	BNEQU	20$			; NO -- CONTINUE
	$WAITFR_S EFN=EFN[R4]		; YES -- ISSUE SUBJECT SERVICE
	BRB	40$			; GO CHECK ITS COMPLETION
20$:
	CMPL	R3,#1			; WFLAND ?
	BNEQU	30$			; NO -- CONTINUE
	$WFLAND_S EFN=EFN[R4], MASK=SUBJ_MASK 
					; YES -- ISSUE SUBJECT SERVICE
	BRB	40$			; GO CHECK ITS COMPLETION
30$:
	$WFLOR_S EFN=EFN[R4], MASK=SUBJ_MASK ; MUST BE WFLOR
40$:
	BBSS	#FELLTHRU,FLAGS,.+1 	; INDICATE THAT WAIT IS DONE
	CMPL	R0,#SS$_NORMAL		; CODE RECEIVED = CODE EXPECTED ?
	BEQLU	50$			; YES -- CONTINUE
	MOVL	#SS$_NORMAL,EXPV 	; LOAD UP EXPECTED AND ...
	MOVL	R0,RECV			; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<INCORRECT STATUS CODE RETURNED FROM WAIT SERVICE>
50$:
	$HIBER_S			; SLEEP UNTIL WAITAST CHECKS RESULTS OF SERV
	BBC	#ASTLOOP,FLAGS,55$ 	; CONTINUE IF NO AST LOOP
	CLRB	EXPV			; AST LOOP -- SET UP FOR ERR_EXIT
	CLRB	RECV			; ........
	ERR_EXIT BYTE,<UNSATISFIED WAIT CONDITION>
55$:
	BBC	#CLUSCHG,FLAGS,58$ 	; CONTINUE IF NO CLUSTER CHANGE ERROR
	ERR_EXIT LONG,<CLUSTER EVENT FLAG SETTINGS CHANGED ACROSS WAIT>
58$:
	BBC	#EXP_WAIT,FLAGS,70$ 	; BRANCH IF FALL-THRU EXPECTED
	BBC	#REC_WAIT,FLAGS,60$ 	; WAIT EXP'D; BRANCH IF FALL-THRU RECEIVED
	BRW	80$			; WAIT EXPECTED & RECEIVED; THAT'S OK
60$:
	MOVL	TRIAL_MASK,EXPV		; SET UP TRIAL_MASK ....
	MOVL	TRIAL_MASK,RECV		; .... FOR MSG, THEN EXIT
	ERR_EXIT LONG,<WAIT EXP'D; FALL-THRU REC'D; VALUE IS CLUST BEFORE WAIT>
70$:
	BBS	#REC_WAIT,FLAGS,75$ 	; BRANCH IF WAIT REC'D; THAT'S AN ERROR
	BRW	80$			; FALL-THRU EXPECTED & RECEIVED; THAT'S OK
75$:
	MOVL	TRIAL_MASK,EXPV		; SET UP TRIAL_MASK ....
	MOVL	TRIAL_MASK,RECV		; .... FOR MSG, THEN EXIT
	ERR_EXIT LONG,<FALL-THRU EXP'D; WAIT REC'D; VALUE IS CLUST BEFORE WAIT>
80$:
	ACBW	#255,#1,TM_WORK,10$ 	; MAKE NEW TRIAL_MASK & LOOP
VERIFYX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	VFY_CLEANUP
;++
; FUNCTIONAL DESCRIPTION:
;
;		VFY_CLEANUP EXECUTES SYSTEM SERVICES TO UNDO THE
; EFFECT OF THOSE ISSUED IN THE VERIFY SUBROUTINE. VFY_CLEANUP MUST
; ASSUME THAT VERIFY MAY NOT HAVE EXECUTED IN ITS ENTIRETY (IF AN
; ERROR IS FOUND). ALSO, VFY_CLEANUP MAY ISSUE SS_CHECK OR ERR_EXIT
; ONLY AFTER PERFORMING ALL OF ITS CLEANUP OPERATIONS; THIS IS REQUIRED
; IN THE EVENT THAT VFY_CLEANUP IS CALLED DURING ERROR PROCESSING,
; WHEN PERFORMING THE REQUIRED CLEANUP IS MORE IMPORTANT THAN
; POSSIBLY DISCOVERING A SECOND ERROR.
;
; CALLING SEQUENCE:
;
;	BSBW VFY_CLEANUP
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	R2,3,4,5,6 CONTAIN CURRENT CONDITION TABLE INDEX VALUES
;	  FOR COND TABLES 1,2,3,4,5, RESPECTIVELY.
;	FOR X = 1,2,3,4,5 :
;		CONDX_E - ADDRESS OF TABLE OF DATA VALUES FOR CONDX
;		  TABLE. IF THE CONTEXT OF TABLE X IS A SYSTEM SERVICE
;		  ARGUMENT, THE ARGUMENT NAME MAY BE USED AS A SYNONYM
;		  FOR CONDX_E.
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	EFLAG SET TO NON-ZERO IF ERROR ENCOUNTERED.
;
; SIDE EFFECTS:
;
;	SS_CHECK AND ERR_EXIT MACROS CAUSE PREMATURE EXIT 
;	(VIA RSB) IF ERROR ENCOUNTERED.
;
;--



VFY_CLEANUP::
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	BUILD_CLUST SUBROUTINE
;
; **************************************************************
; *
; *	BUILD_CLUST SUBROUTINE
; *
; *	THIS SUBROUTINE SETS THE SUBJECT CLUSTER EQUAL TO
; *	  THE TRIAL_MASK BY ISSUING THE PROPER COMBINATION
; *	  OF 32 SETEF/CLREF'S. THEN A READEF IS ISSUED AND
; *	  THE NEW CLUSTER SETTINGS ARE VERIFIED.
; *
; *	INPUTS:
; *
; *		R10	 -	 THE LOW-ORDER EFN IN THE SUBJECT CLUSTER
; *
; *		TRIAL_MASK   -   LONGWORD CONTAINING THE MASK TO
; *				   WHICH THE SUBJECT CLUSTER IS
; *				   TO BE SET.
; *
; *	OUTPUTS:
; *
; *		SUBJECT CLUSTER - UPDATED TO LOOK LIKE TRIAL_MASK.
; *
; *		CLUS_STATE   -    LONGWORD CONTAINING THE IMAGE
; *				    OF THE NEWLY SET SUBJECT CLUSTER.
; *
; *	VOLATILE REGISTERS:
; *
; *		R0, R1, R8, R9
; *
; **************************************************************
;
BUILD_CLUST:
	MOVL	R10,R8			; ESTABLISH FIRST EFN (EVENT FLAG NO.)
	CLRL	R9			; INIT OFFSET INTO TRIAL_MASK
20$:
	BBS	R9,TRIAL_MASK,30$ 	; ISSUE $SETEF IF BIT FOR THIS FLAG IS SET
	$CLREF_S EFN=R8			; ... OTHERWISE, ISSUE $CLREF
	BLBS	R0,40$			; IF NORMAL STATUS, PROCESS NEXT EVENT FLAG
	SS_CHECK NORMAL			; USE SS_CHECK TO TERMINATE TEST MODULE
30$:
	$SETEF_S EFN=R8			; SET CURRENT EVENT FLAG
	BLBS	R0,40$			; IF NORMAL STATUS, PROCESS NEXT EVENT FLAG
	SS_CHECK NORMAL			; USE SS_CHECK TO TERMINATE TEST MODULE
40$:
	INCW	R8			; GET NEXT EFN
	ACBB	#31,#1,R9,20$		; GO DO NEXT EVENT FLAG
	$READEF_S EFN=R10, STATE=CLUS_STATE ; READ THE CLUSTER JUST BUILT
	BLBS	R0,50$			; CONTINUE IF NORMAL COMPLETION
	SS_CHECK NORMAL			; USE SS_CHECK TO TERMINATE TEST MODULE
50$:
	CMPL	CLUS_STATE,TRIAL_MASK 	; DID CLUSTER GET BUILT OK ?
	BEQLU	BUILD_CLUSTX		; YES -- SIMPLY EXIT
	MOVL	TRIAL_MASK,EXPV		; NO -- LOAD EXPECTED AND ...
	MOVL	CLUS_STATE,RECV		; ... RECEIVED VALUES, THEN EXIT
	ERR_EXIT LONG,<TRIAL MASK NOT BUILT CORRECTLY>
BUILD_CLUSTX:
	RSB				; RETURN TO CALLER
	.PAGE
	.SBTTL	SETEXPBIT SUBROUTINE
;
; **************************************************************
; *
; *	SETEXPBIT SUBROUTINE
; *
; *	THIS SUBROUTINE DETERMINES WHETHER TO EXPECT A WAIT
; *	  OR A FALL-THRU FROM THE UPCOMING ISSUANCE OF THE
; *	  SUBJECT WAIT SYSTEM SERVICE FOR THIS TEST CASE.
; *	  IF A WAIT IS EXPECTED, THE EXP_WAIT BIT IS SET; IF
; *	  A FALL-THRU IS EXPECTED, THE BIT IS NOT SET. THE
; *	  ALGORITHM FOR DETERMINING WHICH STATE TO EXPECT DEPENDS
; *	  ON WHICH OF THE THREE TYPES OF WAIT SYSTEM SERVICE
; *	  WILL BE ISSUED FOR THIS TEST CASE.
; *
; *		$WAITFR (SINGLE EVENT FLAG):
; *			IF THE LOW-ORDER BIT OF THE TRIAL_MASK
; *			IS SET, EXPECT A FALL-THRU; OTHERWISE,
; *			EXPECT A WAIT.
; *
; *		$WFLAND:
; *			DO A LOGICAL "AND" OF THE TRIAL_MASK WITH
; *			THE SUBJECT MASK; IF THE RESULT EQUALS THE
; *			SUBJECT MASK, EXPECT A FALL-THRU; OTHERWISE,
; *			EXPECT A WAIT.
; *
; *		$WFLOR:
; *			DO A LOGICAL "AND" OF THE TRIAL_MASK WITH
; *			THE SUBJECT MASK; IF THE RESULT IS ZERO,
; *			EXPECT A WAIT; OTHERWISE, EXPECT A FALL-THRU.
; *
; *	INPUTS:
; *
; *		R3      -    	CONDITION TABLE 2 INDEX REG,
; *				INDICATING TYPE OF WAIT SERVICE
; *
; *		SUBJ_MASK  -	SUBJECT MASK. LONGWORD DATA ITEM,
; *				USED AS THE VALUE FOR THE MASK
; *				ARGUMENT FOR $WFLAND & $WFLOR.
; *
; *		TRIAL_MASK  - 	TRIAL MASK. LONGWORD DATA ITEM,
; *				WHOSE BIT PATTERN IS EQUAL TO THE
; *				CURRENT SETTING OF THE SUBJECT
; *				EVENT FLAG CLUSTER.
; *
; *	OUTPUTS:
; *
; *		EXP_WAIT   -	BIT IN FLAGS BYTE. SET TO 1 IF
; *				A WAIT IS EXPECTED; REMAINS AS 0
; *				IF FALL-THRU IS EXPECTED.
; *
; *	VOLATILE REGISTERS:
; *
; *		R7
; *
; **************************************************************
;
SETEXPBIT:
	TSTL	R3			; $WAITFR (SINGLE FLAG) ?
	BNEQU	10$			; NO -- CONTINUE
	BLBS	TRIAL_MASK,SETEXPBITX 	; IF LOW BIT OF MASK SET, EXPECT A FALL-THRU
	BBCS	#EXP_WAIT,FLAGS,SETEXPBITX ; SET EXPECT-WAIT BIT & EXIT
10$:
	MCOML	SUBJ_MASK,R7		; LOGICALLY "AND" SUB_MASK ....
	BICL3	R7,TRIAL_MASK,R7 	; .... WITH TRIAL_MASK, RESULT IN R7
	CMPL	R3,#1			; $WFLAND ?
	BEQLU	20$			; YES -- GO TEST RESULT
					; NO -- ASSUME $WFLOR
	TSTL	R7			; RESULT ZERO ?
	BNEQU	SETEXPBITX		; NO -- EXPECT A FALL-THRU
	BBCS	#EXP_WAIT,FLAGS,SETEXPBITX ; YES -- SET BIT & EXIT
20$:
	CMPL	R7,SUBJ_MASK		; RESULT = SUBJECT MASK ?
	BEQLU	SETEXPBITX		; YES -- EXPECT A FALL-THRU
	BBCS	#EXP_WAIT,FLAGS,SETEXPBITX ; NO -- SET BIT & EXIT
SETEXPBITX:
	RSB
	.PAGE
	.SBTTL	SETSTBIT SUBROUTINE
;
;	THE SETSTBIT SUBROUTINE SETS A STATE BIT INDICATING
;	THE STATE OF THE MAIN (INTERRUPTED) ROUTINE WHEN
;	THE WAITAST WAS DELIVERED.
;
SETSTBIT:
	BBSC	#PROCESSING,FLAGS,.+1	; CLEAR "PROCESSING" ...
	BBSC	#WAITING,FLAGS,.+1	; ... AND "WAITING" FLAGS
	BBC	#FELLTHRU,FLAGS,10$	; CONTINUE IF NOT A FALL-THRU
	BRW	SETSTBITX		; STATE BIT ALREADY SET	; JUST EXIT
10$:
	CMPL	16(AP),CHMKADD[R3]	; PC POINTING TO WAIT'S CHMK ?
	BNEQU	20$			; NO -- GO SET "PROCESSING"
	CMPL	8(AP),#PROC_CONS	; YES -- PROCESSING CONST STILL SET IN R0 ?
	BEQLU	20$			; YES -- WAIT SERVICE NOT EXECUTED YET
	BBSS	#WAITING,FLAGS,.+1	; NO -- PROCESS IS WAITING
	BRB	SETSTBITX		; EXIT
20$:
	BBSS	#PROCESSING,FLAGS,.+1	; INDICATE STILL PROCESSING
SETSTBITX:
	RSB				; RETURN TO CALLER (WAITAST RTN)
	.PAGE
	.SBTTL	WAITAST ROUTINE
;
; THIS AST ROUTINE IS ENTERED AFTER A 1-MILLISECOND TIMER EXPIRES.
; THE TIMER IS SET JUST BEFORE ISSUING A WAIT SYSTEM SERVICE. SINCE
; THE WAIT SERVICE IS FOLLOWED BY A $HIBER, THE MAIN ROUTINE HAS
; TO HAVE BEEN IN ONE OF THE THREE FOLLOWING STATES AT TIME OF AST
; INTERRUPT:
;
;	WAITING -- THE WAIT SYSTEM SERVICE CAUSED AN EVENT FLAG WAIT.
;		   THE WAIT WILL BE CLEARED BY ISSUING SETEF'S AND
;		   THE REC_WAIT BIT WILL BE SET.
;
;	FELLTHRU --    THE WAIT SYSTEM SERVICE DID NOT CAUSE AN
;		       EVENT FLAG WAIT (THIS IS A FALL-THRU).
;		       A $HIBER FOLLOWING THE WAIT WILL BE
;		       CLEARED WITH A $WAKE AND THE REC_WAIT
;		       BIT WILL BE CLEARED.
;
;	PROCESSING -- NEITHER OF THE ABOVE TWO STATES. IN THIS CASE,
;		      THE 1-MILLISECOND TIMER IS REPEATED, EXPECTING
;		      ONE OF THE OTHER TWO STATES TO BE REACHED EVENT-
;		      UALLY.
;
WAITAST:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9> ; ENTRY MASK
	BSBW	REST_REGS		; RESTORE REGS 2-6 FOR USE IN AST
	BSBW	SETSTBIT		; DETERMINE STATE OF EXECUTION & SET BIT
	BBC	#PROCESSING,FLAGS,10$ 	; BRANCH IF NOT PROCESSING
	CMPB	CONSEC_P,#10		; 10 CONSECUTIVE "PROCESSING" AST ENTRIES ?
	BGEQ	5$			; YES -- DO NOT RE-SCHEDULE THIS AST
	INCB	CONSEC_P		; NO -- LOG THIS OCCURRENCE
	$SETIMR_S DAYTIM=TIMEINCR, -	; STILL PROCESSING; RE-SCHEDULE THIS AST
		  ASTADR=WAITAST
	BRW	WAITASTX		; .... EXIT BACK TO INTERRUPTED CODE
5$:
	BBSS	#ASTLOOP,FLAGS,.+1 	; INDICATE ERROR FOR LATER PROCESSING
	BBSS	#WAITING,FLAGS,.+1 	; FAKE WAITING STATE TO CLEAR WAIT
10$:					; EITHER WAITING OR FELLTHRU
	CLRB	CONSEC_P		; RE-INIT CNT OF CONSEC "PROCESSING" ENTRIES
;
;	THE FOLLOWING CODE READS THE CLUSTER & COMPARES IT 
;	AGAINST TRIAL_MASK FOR EQUALITY. IF EVENT FLAG GROUP 0,
;	COMPARE ONLY FLAGS 1-23, SINCE OTHERS MAY BE USED BY 
;	SYSTEM OR TEST MODULE.
;
	$READEF_S EFN=EFN[R4], STATE=CLUS_STATE 
					; GET STATE OF CLUSTER
	CMPL	EFN[R4],#32		; EVENT FLAG GROUP 0 ?
	BLSS	14$			; YES -- GO SPECIFY POS & SIZE FOR COMPARE
	CLRL	R8			; NO -- SPECIFY POSITION FOR COMPARE
	MOVB	#32,R9			; SPECIFY SIZE OF TRIAL_MASK FOR COMPARE
	BRB	17$			; GO DO COMPARE
14$:
	MOVZBL	#1,R8			; SPEC POSITION FOR E.F. GROUP 0
	MOVB	#23,R9			; .... AND SIZE
17$:
	XORL3	TRIAL_MASK,CLUS_STATE,R7 ; GET XOR OF 2 COMPARANDS
	CMPV	R8,R9,R7,#0		; COMPARE FOR BIT MATCHES USING POS & SIZE
	BEQLU	20$			; BITS MATCH -- CONTINUE
	MOVL	TRIAL_MASK,EXPV		; MISMATCH -- LOAD EXPECTED ....
	MOVL	CLUS_STATE,RECV		; ... AND RECEIVED VALUES
	BBSS	#CLUSCHG,FLAGS,.+1 	; INDICATE ERROR FOR LATER PROCESSING
20$:
	$WAKE_S				; WAKE SELF TO SATISFY $HIBER
	BBS	#WAITING,FLAGS,22$ 	; BRANCH IF WAITING
	BRW	WAITASTX		; MUST HAVE FALLEN THRU WAIT; JUST EXIT
22$:
	BBSS	#REC_WAIT,FLAGS,.+1 	; SET "WAIT RECEIVED" BIT & KEEP GOING
	TSTL	R2			; FIRST CONDITION 1 ELEMENT ?
	BEQLU	30$			; YES -- CLEAR WAIT IN CREATED PROCESS
					; NO -- CLEAR WAIT IN THIS PROCESS
	MOVL	EFN[R4],R8		; ESTABLISH FIRST EFN IN CLUSTER
	CLRL	R9			; INIT OFFSET OF EFN IN CLUSTER
25$:
	$SETEF_S EFN=R8			; SET THIS EVENT FLAG
	INCW	R8			; POINT TO NEXT ONE
	ACBB	#31,#1,R9,25$		; LOOP BACK TO SET NEXT ONE
	BRW	WAITASTX		; ALL DONE -- WAIT IS CLEARED
30$:
	$WAKE_S PRCNAM=CREPRN		; HAVE CREATED PROCESS ISSUE SETEF'S
	$QIOW_S	CHAN=MBXCHAN, FUNC=#IO$_READVBLK, -
		P1=MBXBUFF+8, P2=#1
					; ... WAIT UNTIL HE SIGNALS "DONE"
WAITASTX:
	RET				; TERMINATE THIS AST
	.END
