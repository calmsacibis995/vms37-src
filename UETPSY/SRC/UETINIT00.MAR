	.TITLE UETINIT00 VAX/VMS UETP USER INTERFACE PROGRAM
	.IDENT	'V03-002'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This program handles all UETP user interface dialogue.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with interrupts enabled
;	at all times.  This program requires the following privileges and
;	quotas:
;		GRPNAM CMEXEC
;
;--
;
; AUTHOR: Larry D. Jones,	CREATION DATE: November, 1980
;
; MODIFIED BY:
;
;	V03-002	LDJ0006		Larry D. Jones,		30-Mar-1982
;		Fix dump mode equation output, modified by history and
;		set the 11/782 cpu scale value.
;
;	V03-001	RNH0005		Richard N. Holstein,	23-Mar-1982
;		Fix confusing error message.
;
;	V02-010	RNH0004		Richard N. Holstein,	27-Jan-1982
;		Adapt to the "final" format of the SHOW MEMORY command.  Put
;		in hooks for ATLAS (multiple CPU) configurations.  Comment out
;		code which was used for one estimate of LOADS based on nonpaged
;		pool usage; it's unnecessary given dynamic pool allocation.
;		Reinstall smarts to selectively ask LOADS question.
;
;	V02-009	RNH0003		Richard N. Holstein,	31-Dec-1981
;		Adapt to new format of SHOW MEMORY command.  Use
;		UETP$_FACILITY.  Some listing cleanup.  Always compute
;		and create LOADS logical name.
;
;	V02-008 RNP0001		Robert N. Perron,	02-Nov-1981
;		Modified to allow batch execution.
;
;	V02-007 LDJ0005		Larry D. Jones,		28-Oct-1981
;		Fixed system disk message reporting on systems with a
;		top level system directory specification.
;
;	V02-006	RNH0002		Richard N. Holstein,	12-Oct-1981
;		Use new systemwide logical name SYS$SYSROOT which replaces
;		SYS$SYSDISK.
;
;	V02-005	RNH0001		Richard N. Holstein,	02-Oct-1981
;		Added prompts to make it easy to run an individual phase.
;		Added comments at useful places.  SS$_CONTROLC is NOT a
;		success exit.
;
;	V02-004	LDJ0004		Larry D. Jones,		06-Sep-1981
;		Added SETPRV to default privileges and fixed privilege error
;		path logic. Added the version number ID in the welcome message.
;
;	V02-003	LDJ0003		Larry D. Jones,		01-Sep-1981
;		Fixed failure of LIB$GET_INPUT hang problem, running the
;		program from a batch job problem and changed the PPF check for
;		recursive translation code to be a byte test of ESC.
;
;	V02-002	LDJ0002		Larry D. Jones,		27-Aug-1981
;		Removed DFPFC quota and added ENQLM quota.
;
;	V02-001	LDJ0001		Larry D. Jones,		18-Aug-1981
;		Changed reference to nebula from 7ZZ to 730.
;**

	.SBTTL	Declarations
	.ENABLE SUPPRESSION
;
; INCLUDE FILES:
;
;	SYS$SYSTEM:SYS.STB		; To get EXE$GB_CPUTYPE
;	SYS$LIBRARY:LIB.MLB		; To get definitions
;	SHRLIB$:UETP.MLB		; To get UETP definitions
;
; MACROS:
;
	$CHFDEF				; Condition handler frame definitions
	$CLIDEF				; CLI definitions
	$CLISERVDEF			; CLI callback definitions
	$DIBDEF				; Device Information Block definitions
	$JPIDEF				; $GETJPI definitions
	$PRDEF				; Processor register definitions
	$SHRDEF				; Shared messages
	$STSDEF				; Status return
	$UETPDEF			; UETP


.MACRO	SHOMEM_TABLE	ENTRIES		; Layout table of items to find...
;					; ...in SHOMEM.DAT
ENTRY_COUNT = 0
.IRP	ENTRY,<ENTRIES>
	ENTRY_COUNT = ENTRY_COUNT+1	; Count the items to go in the table
.ENDR	; IRP ENTRY
TABLE_PTR = .				; This points to each entry in table
KEYSTRING_PTR = .			; This is a dummy for definition below
SAVE_TABLE_PTR = .			      ; We now have to define...
	SHOMEM_TABLE_ITEM		      ; ...the size...
SHOMEM_ENTRY_SIZE = TABLE_PTR-SAVE_TABLE_PTR  ; ...of a single table entry...
TABLE_PTR = SAVE_TABLE_PTR		      ; ...and reclaim space used...
. = SAVE_TABLE_PTR			      ; ...by the definition
	.BLKB	ENTRY_COUNT*SHOMEM_ENTRY_SIZE ; Reserve space for table items
KEYSTRING_PTR = .			; This points to each keystring
.IRP	ENTRY,<ENTRIES>
	SHOMEM_TABLE_ITEM	ENTRY	; Form the table
.ENDR	; IRP ENTRY
.ENDM	SHOMEM_TABLE


.MACRO	SHOMEM_TABLE_ITEM KEYSTRING=<>,STORAGE=0,POSITION=0,FLAGS=0
;					; Form individual...
;					; ...item for SHOMEM.DAT table
; KEYSTRING is a text string that is used to match against lines retruned
;		from a SHOW MEMORY command.  We select a line if a match is
;		found.  In generating our table, a descriptor to the .ASCII
;		string is inserted and the .ASCII strings concatenated at
;		the end of the table.  Offset of the pointer = 0
; STORAGE is the address of a variable used to store a value retrieved from
;		such a line.  Offset of the address = 8
; POSITION is the position of the leftmost of seven characters on the line
;		just selected.  The seven characters are assumed to be a
;		leading blank decimal integer.  Offset of this byte = 12
; FLAGS tells of special conditions that may be applied to this line or value.
;		Offset of the flags = 13
STRING_COUNT = 0
.IRPC	STRING,<KEYSTRING>	
	STRING_COUNT = STRING_COUNT+1	; Count characters in key for desc
.ENDR
. = TABLE_PTR				; First in each table entry is...
.LONG	STRING_COUNT			; ...a string descriptor for...
.ADDRESS KEYSTRING_PTR			; ...the key string to match
.ADDRESS STORAGE			; Next comes a variable to store...
					; ...the value we find
.BYTE	POSITION			; This points to the leftmost byte...
					; ...of the item on a particular...
					; ...line which we want
.BYTE	FLAGS				; Remember if we take special action...
					; ...for this item
TABLE_PTR = .				; Point to the next item in the table
. = KEYSTRING_PTR			; Store the text that is the key...
.ASCII	"KEYSTRING"			; ...for which we search
KEYSTRING_PTR = .			; Note that we end up after last string
.ENDM	SHOMEM_TABLE_ITEM		


	.MACRO ITMENT NAME,POSITION,EXPECTED,POQ
	.=PC1...
	.BYTE	^X'POSITION		; Bit of priv or quota to check
	PC1...=PC1...+1
	.=PC2...
	.LONG	EXPECTED		; Expected results
	PC2...=PC2...+4
	.=PC3...
	.ADDRESS PC5...			; Address of priv or quota ASCIC name
	PC3...=PC3...+4
	.=PC4...
	.BYTE POQ			; Privilege or quota indicator bit
	PC4...=PC4...+1
	.=PC5...
NAME:					; Ascic name
	.ASCIC	/NAME/
	PC5...=.
	.ENDM ITMENT



;
; EQUATED SYMBOLS:
;
;   Assembly parameters:
; Late in the development of VMS V3A, dynamic allocation of nonpaged pool was
; added to VMS.  This made obsolete our calculation of LOADS based on the
; SYSGEN parameter NPAGDYN.  Remove that calculation, but as a hedge against
; future wisdom, do so with a .REPEAT 0, the "0" being an equated symbol.
	POOL_ESTIMATE = 0		; If 0, don't assemble code to base...
					; ...LOADS on pool space. If 1, use...
					; ...pool space as one limiting factor
.IIF NE POOL_ESTIMATE&^XFFFFFFFE, .ERROR ; POOL_ESTIMATE must be either 0 or 1!

;   Facility number definitions:
	RMS_K = 1

;   SHR message definitions:
	UETP = UETP$_FACILITY@STS$V_FAC_NO ; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Miscellany:
	LOGNAM_SIZE   = 64		; Maximum logical name size
	SYMBOL_CNT    = 4		; Number of local syms to be evaluated
	TEXT_BUFFER   = 256		; Internal text buffer size
	MAXSYM_SZ     = 64		; Maximum symbol size
	CR            = ^XD		; Carriage return
	LF	      = ^XA		; Line feed
	M 	      = ^A/M/		; M character
	SPACE	      = ^A/ /		; Space character
	TAB           = ^A/	/	; Tab character
	LCBIT	      = ^X20		; Lower case bit
	PROMPTV       = 1		; Prompt flag
	PROMPTM       = ^X2		; Prompt flag mask
	TERMINALV     = 2		; SYS$COMMAND is a  terminal 
	TERMINALM     = ^X4		; Terminal flag mask
	PRIV_PRNTV    = 3
	DUMPM	      = ^X10		; Dump mode flag
	PRIV_CNT      = 30		; Privilege count
	QUOT_CNT      = 10		; Quota count
	REPEATV       = 0		; Bit which indicates a SHOMEM_TABLE...
	REPEATM       = 1@REPEATV	; ...item is repeatable on next record
	CONTINUEV     = REPEATV+1	; Bit which indicates a SHOMEM_TABLE...
	CONTINUEM     = 1@CONTINUEV	; ...item can continue to the next line
;
;   The following definitions are estimates at per process usage of page
;   and pool space.
;
	PP_PAGE_USAGE = 1000 
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
	PP_POOL_USAGE = 400
.ENDC	; .IF NE POOL_ESTIMATE
;
;   The following definition is an estimate at percentage of a process continuous
;   use of its WS.
;
	PER_WS_INUSE = ^F0.20

	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETINIT00/

MODE:					; Run mode logical name
	.ASCID	/MODE/

USERS:					; Load count logical name
	.ASCID	/LOADS/

PASS_NAME:				; Local pass count logical name
	.ASCID	/PASSCNT/

REPORT_NAME:				; Long or short report indicator name
	.ASCID	/REPORT/

TTNAME_ROPTR:				; Terminal controlling test
	.WORD	63,0
	.ADDRESS TTNAME

SYSDISK:				; Name of device we are booted from
	.ASCID	/SYS$SYSROOT/

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

SHOMEM_ERROR:
	.ASCID	\Can't find item in column !UB on "!AS" line!/!_of $SHOW \-
		\MEMORY command.  Can't compute default load test count.\

SYNTAX_ERROR_MSG:
	.ASCID	/Syntax error in response.  Please try again./

INVALID_PHASE_MSG:
	.ASCID	/!AS is not a valid phase!/

INVALID_PASS_MSG:
	.ASCID	/!AS is not a valid pass count!/

INVALID_LOADCNT_MSG:
	.ASCID 	/!AS is not a valid load count!/

INVALID_REPORT_MSG:
	.ASCID	/!AS is not a valid report type!/

WRONG_ACCOUNT:
	.LONG	WAL
	.ADDRESS .+4
	.ASCII	\You are logged into the wrong account.\<CR><LF>
	.ASCII	\              Please login to the SYSTEST account.\<CR><LF>
	WAL=.-WRONG_ACCOUNT-8

STRSTR:
	.ASCID	\  The following:\<13><10>
ENDSTR:
	.LONG	END_SIZ
	.ADDRESS .+4
	.ASCII	\  are non-standard for the SYSTEST account and may\
	.BYTE	13,10
	.ASCII 	\		result in UETP errors.\
	END_SIZ=.-ENDSTR-8
CTRSTR:
	.ASCID	\!_!AC !AC,\
PRV_STR:
	.ASCIC	\privilege\
QUO_STR:
	.ASCIC	\quota\
FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/

RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/

RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/
SYSTEM:
	.ASCID	<LF>\You are running on an !AC CPU with !UL pages of memory.\
DISK:
	.ASCID	\Your system disk is !AS.\
PASS_PROMPT:
	.ASCID	\How many passes of UETP do you wish to run [1]? \
LOAD_PROMPT:
	.ASCID	\How many simulated user loads do you want [!UL]? \
REPORT_PROMPT:
	.ASCID	\Do you want Long or Short report format [Long]? \
START_MESSAGE:
	.ASCID	\UETP starting at !%D with parameters:\
LONG_MSG:
	.ASCID	/, long report./<CR><LF>
SHORT_MSG:
	.ASCID	/, short report./<CR><LF>

DUMP1:
	.LONG	DUMP1L
	.ADDRESS .+4
	.ASCII	\MIN(CPU_SCALE*((MEM_FREE+MEM_MODIFY)/(WS_SIZE*PER_WS_INUSE)),\<CR><LF>
	.ASCII	\                  FREE_PROCESS_SLOTS,\<CR><LF>
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
	.ASCII	\                  FREE_POOL/PP_POOL_USAGE,\<CR><LF>
.ENDC	; .IF NE POOL_ESTIMATE
	.ASCII	\                  FREE_PAGE/PP_PAGE_USAGE)\<CR><LF>
	DUMP1L=.-DUMP1-8
DUMP2:
	.LONG	DUMP2L
	.ADDRESS .+4
	.ASCII	\MIN(!AS*((!UL+!UL)/(!UL*!AS)),!/\
	.ASCII	\                  !UL,!/\
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
	.ASCII	\                  !UL/!UL,!/\
.ENDC	; .IF NE POOL_ESTIMATE
	.ASCII	\                  !UL/!UL)\
	DUMP2L=.-DUMP2-8

LOGINOUT:				; Name of login image
	.ASCID	/SYS$SYSTEM:LOGINOUT.EXE/
SHOMEM_DESC:				; Name of command file created
	.ASCID	/SHOMEM.COM/
SHOMEM_OUTPUT:				; Name of output data file
	.ASCID	/SHOMEM.DAT/
SHOMEM:					; Contents of command file
	.ASCII	/$SHOW MEMORY/
	SHOMEM_LEN = .-SHOMEM

OFFSET:					; Offset table
	.BLKB	PRIV_CNT+QUOT_CNT
EXPECTED:				; Results expected table
	.BLKL	PRIV_CNT+QUOT_CNT
NAM_PTRS:				; Name pointer table
	.BLKL	PRIV_CNT+QUOT_CNT
POQ_TBL:				; Priv or Quota table
	.BLKB	PRIV_CNT+QUOT_CNT
NAME_TBL:				; ASCIC name table
	PC1... = OFFSET
	PC2... = EXPECTED
	PC3... = NAM_PTRS
	PC4... = POQ_TBL
	PC5... = .
	.LIST MEB
	ITMENT ALLSPOOL , 04, 0, 0	; Privilege entries
	.NLIST MEB
	ITMENT BUGCHK   , 17, 0, 0
	ITMENT BYPASS   , 1D, 0, 0
	ITMENT CMEXEC   , 01, 1, 0
	ITMENT CMKRNL   , 00, 1, 0
	ITMENT DETACH   , 05, 1, 0
	ITMENT DIAGNOSE , 06, 1, 0
	ITMENT EXQUOTA  , 13, 0, 0
	ITMENT GROUP    , 08, 1, 0
	ITMENT GRPNAM   , 03, 1, 0
	ITMENT LOG_IO   , 07, 1, 0
	ITMENT MOUNT    , 11, 0, 0
	ITMENT NETMBX   , 14, 1, 0
	ITMENT NOACNT   , 09, 0, 0
	ITMENT OPER     , 12, 0, 0
	ITMENT PFNMAP   , 1A, 0, 0
	ITMENT PHY_IO   , 16, 1, 0
	ITMENT PRMCEB   , 0A, 1, 0
	ITMENT PRMGBL   , 18, 0, 0
	ITMENT PRMMBX   , 0B, 1, 0
	ITMENT PSWAPM   , 0C, 0, 0
	ITMENT SETPRI   , 0D, 0, 0
	ITMENT SETPRV   , 0E, 1, 0
	ITMENT SHMEM    , 1B, 0, 0
	ITMENT SYSGBL   , 19, 0, 0
	ITMENT SYSNAM   , 02, 1, 0
	ITMENT SYSPRV   , 1C, 1, 0
	ITMENT TMPMBX   , 0F, 1, 0
	ITMENT VOLPRO   , 15, 1, 0
	ITMENT WORLD    , 10, 0, 0

	ITMENT ASTLM    , 00, 50,	1	; Quota entries
	ITMENT BIOLM    , 01, 12,	1
	ITMENT BYTLM    , 02, 20480,	1
	ITMENT CPULIM   , 03, 0,	1
	ITMENT ENQLM    , 04, 20,	1
	ITMENT DIOLM    , 05, 12,	1
	ITMENT FILLM    , 06, 20,	1
	ITMENT PGFLQUOTA, 07, 10000,	1
	ITMENT PRCLM    , 08, 8,	1
	ITMENT TQLM     , 09, 20,	1

SHOMEM_DATA_TABLE:			; Table of items to find in SHOMEM.DAT
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
SHOMEM_TABLE	< -
	<<Main Memory>,        MEM_SIZE,  33,0>,-
	<<Main Memory>,        MEM_FREE,  45,0>,-
	<<Main Memory>,        MEM_MODIFY,69,0>,-
	<<Process Entry Slots>,SWAP_SIZE, 45,0>,-
	<<Nonpaged Variable>,  POOL_SIZE, 45,0>,-
	<<Paging File Usage>,  0,          0,0>,-
	<<SYSEXE]PAGEFILE.SYS>,PAGE_SIZE, 45,CONTINUEM!REPEATM> -
	>
.IFF
SHOMEM_TABLE	< -
	<<Main Memory>,        MEM_SIZE,  33,0>,-
	<<Main Memory>,        MEM_FREE,  45,0>,-
	<<Main Memory>,        MEM_MODIFY,69,0>,-
	<<Process Entry Slots>,SWAP_SIZE, 45,0>,-
	<<Paging File Usage>,  0,          0,0>,-
	<<SYSEXE]PAGEFILE.SYS>,PAGE_SIZE, 45,CONTINUEM!REPEATM> -
	>
.ENDC	; .IF NE POOL_ESTIMATE

; NOTE:  The code which searches CPU tables limits itself to looking at
; PR$_SID_TYPMAX entries.  This limit in the code must also be patched if more
; entries are patched in.
; Negative entries in the following tables apply to tightly coupled, multiple
; CPU configurations (e.g., 11/782, a.k.a., ATLAS).

; No negative entries for this table
CPU_TYPE_TABLE:				; Table of known CPU types
	.BYTE	PR$_SID_TYP780
	.BYTE	PR$_SID_TYP750
	.BYTE	PR$_SID_TYP730
	.BYTE	0			; Expansion room...
	.BYTE	0			; ...for two new CPU's
; End of CPU_TYPE_TABLE

; Negative entries for CPU_NAME_TABLE
	.BLKL	4			; Expansion for new CPU configurations
	.ADDRESS A782
CPU_NAME_TABLE:				; CPU names address table
	.ADDRESS A780
	.ADDRESS A750
	.ADDRESS A730
	.ADDRESS ANEW1			; Expansion room for two new CPU's
	.ADDRESS ANEW2
; End of CPU_NAME_TABLE

; Negative entries for CPU_SCALE_TABLE
	.FLOAT	0.0			; Future CPU
	.FLOAT	0.0			; Future CPU
	.FLOAT	0.0			; Future CPU
	.FLOAT	0.0			; Future CPU
	.FLOAT	1.4			; 11/782
CPU_SCALE_TABLE:			; Scale to help balance loads vs CPU performance
	.FLOAT	1.0			; 11/780
	.FLOAT	0.8			; 11/750
	.FLOAT	0.5			; 11/730
	.FLOAT	0.0			; Future CPU
	.FLOAT	0.0			; Future CPU
; End of CPU_SCALE_TABLE

A780:					; CPU names
	.ASCIC	\11/780\
A750:
	.ASCIC	\11/750\
A730:
	.ASCIC	\11/730\
ANEW1:					; Future CPU name #1
	.ASCIC	\          \
ANEW2:					; Future CPU name #2
	.ASCIC	\          \
UNKNOWN_CPU:
	.ASCIC	\UNKNOWN\
A782:					; Multiple 11/780
	.ASCIC	\11/782\

USER_LIST:				; GETJPI item list for USERNAME and WS size
	.WORD	12
	.WORD	JPI$_USERNAME
	.LONG	BUFFER
	.LONG	OUTLEN
	.WORD	4
	.WORD	JPI$_WSQUOTA
	.LONG	WS_SIZE
	.LONG	0
	.WORD	4
	.WORD	JPI$_ASTLM
	.LONG	JPI_ASTLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_BIOLM
	.LONG	JPI_BIOLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_BYTLM
	.LONG	JPI_BYTLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_CPULIM
	.LONG	JPI_CPULIM
	.LONG	0
	.WORD	4
	.WORD	JPI$_ENQLM
	.LONG	JPI_ENQLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_DIOLM
	.LONG	JPI_DIOLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_FILLM
	.LONG	JPI_FILLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_PGFLQUOTA
	.LONG	JPI_PGFLQUOTA
	.LONG	0
	.WORD	4
	.WORD	JPI$_PRCLM
	.LONG	JPI_PRCLM
	.LONG	0
	.WORD	4
	.WORD	JPI$_TQLM
	.LONG	JPI_TQLM
	.LONG	0
	.WORD	8
	.WORD	JPI$_CURPRIV
	.LONG	PRIVS
	.LONG	0
	.LONG	0

DIB_BUF:				; Device Info Block desc
	.LONG	DIB$K_LENGTH
	.ADDRESS DIB

SYM_NAM_TABLE:	; Names of parameters in local symbol table
					; If defined they represent:
SYM_P1:			 		; phase
	.WORD	P1_LEN,0 
	.ADDRESS P1_NAM
SYM_P2:					; pass count
	.WORD	P2_LEN,0
	.ADDRESS P2_NAM
SYM_P3:					; number of loads
	.WORD	P3_LEN,0
	.ADDRESS P3_NAM
SYM_P4:					; long or short report
	.WORD	P4_LEN,0
	.ADDRESS P4_NAM
P1_NAM:
	.ASCII	/P1/
	P1_LEN = .-P1_NAM
P2_NAM:
	.ASCII	/P2/
	P2_LEN = .-P2_NAM
P3_NAM:
	.ASCII	/P3/
	P3_LEN = .-P3_NAM
P4_NAM:
	.ASCII	/P4/
	P4_LEN = .-P4_NAM

ALL_PHASE:				; Literal to mean run "ALL" UETP phases
	.ASCID	\ALL\			; (must match phase name in PHASE_TABLE)

LOAD_PHASE:				; Literal to mean run just "LOAD" test
	.ASCID	\LOAD\			; (must match phase name in PHASE_TABLE)

PHASE_PROMPT:				; See if full UETP run is wanted
	.ASCID	\Run "ALL" UETP phases or just "ONE" [ALL]? \

COMMA_BLANK:				; Separator between phase names...
	.ASCIC	\, \			; ...for WHICH_PHASE $FAOL string

NEW_LINE:				; Continue list of phase names...
	.ASCIC	<13><10>\              \ ; ...on a new line

WHICH_PHASE1:				; Allow selection of single UETP phase
	.ASCID	\!/!/Pick one of:  !#(AC)\  ; (The count of characters which...
					    ; ...are $FAOL commands is the...
					    ; ...number subtracted from the...
					    ; ...initial line character count...
					    ; ...when forming this message)
WHICH_PHASE2:
	.ASCIC	<13><10>\for the phase you'd like to run: \

UETPPHASE:				; Group logical name for label in UETP.COM
	.ASCID	\UETPPHASE\

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

WELCOME:
	.LONG	WELCOML
	.ADDRESS .+4
	.ASCII	<CR><LF><LF><LF>\	Welcome to VAX/VMS UETP Version \
VERSION:
	.BLKB	8
	.ASCII	<CR><LF>
	WELCOML = .-WELCOME-8

TTCHAN:					; Channel for the terminal
	.WORD	0
TTNAME_RWPTR:
	.WORD	TTNAME_LEN,0
	.ADDRESS TTNAME
TTNAME:
	.ASCII	/SYS$COMMAND/
	TTNAME_LEN= .-TTNAME
	.BLKB	63-TTNAME_LEN
ERROR_COUNT:				; Error count
	.LONG	0
FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

PHASES:					; Used in startup msg
	.ASCID	\ phases\

PASS_MSG:				; Used in startup msg
	.ASCID	\, !UL passes\

LOAD_MSG:				; More for startup msg
	.ASCID	\, !UL load!%S\

PARAM_MSG:				; Here is where the parameter portion
	.WORD	0,0			; ...of the startup msg gets assembled
	.ADDRESS PARAM_BUF
PARAM_BUF:
	.BLKB	TEXT_BUFFER

AST_MODE:				; Prior setting of AST delivery
	.LONG	0

SS_FAIL_MODE:				; Prior setting of SS failure mode
	.LONG	0

LOADS_DESC:				; Loads general purpose desc.
	.LONG	0
	.ADDRESS 0

CPU_SCALE_DES:				; Descriptor for CPU scale value
	.ASCID	/    /

WS_INUSE_DES:				; Descriptor for percent of WS inuse
	.ASCID	/    /
WS_INUSE:				; Storage for percent of WS inuse
	.FLOAT	0
DISK_BUFFER:				; System disk name
	.LONG	LOGNAM_SIZE
	.ADDRESS .+4
	.BLKB	LOGNAM_SIZE

DIB:					; Device Information Block
	.BLKB	DIB$K_LENGTH

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

MBX_CHAN:				; Mail box channel
	.WORD	0
MBX_UNIT:				; Mail box unit number
	.WORD	0
MBX_BUF:				; Termination mailbox
	.BLKB	TEXT_BUFFER

PAGE_COUNT:				; Floating point format memory page count
	.FLOAT	0
PAGE_BUF:				; String storage for memory size
	.LONG	5
	.ADDRESS .+4
	.BLKB	5

STATUS:					; Status value on program exit
	.LONG	0

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

FLAGS:					; Flags byte where...
	.BYTE	0			; Bit 1 set = prompt for input
					; Bit 2 set = SYS$COMMAND is a terminal
					; Bit 3 set = priv message printed
					; Bit 3 clr = priv message never printed
					; Bit 4 set = dump mode
					; Bit 4 clr = normal mode

SYM_VAL_TABLE:				; Buffers for parameters P1-P4

P1_DESC:
	.LONG	0
	.ADDRESS P1_BUF
P2_DESC:
	.LONG	0
	.ADDRESS P2_BUF
P3_DESC:
	.LONG	0
	.ADDRESS P3_BUF
P4_DESC:
	.LONG	0
	.ADDRESS P4_BUF
P1_BUF:
	.BLKB	MAXSYM_SZ
P2_BUF:
	.BLKB	MAXSYM_SZ
P3_BUF:
	.BLKB	MAXSYM_SZ
P4_BUF:
	.BLKB	MAXSYM_SZ


ANSWER:					; Answer buffer desc
	.LONG	TEXT_BUFFER
	.ADDRESS .+4
	.BLKB	TEXT_BUFFER

OUTLEN:					; Output string desc
	.LONG	0
	.ADDRESS ANSWER+8

CPU_SCALE:				; This CPU's scale factor
	.FLOAT	0.0
PASS_COUNT:				; Total pass count
	.LONG	0
LOAD_COUNT:				; Total load count
	.LONG	0

PHASE_TABLE:
	$LIB_KEY_TABLE	< -
		<<DEVICE>,>-
		<<SYSTEM_SERVICE>,>-
		<<RMS32>,>-
		<<LOAD>,>-		; (Must match phase name in LOAD_PHASE)
		<<RSX_UTILITY>,>-
		<<RSX_EXEC_DIRECTIVE>,>-
		<<NATIVE_UTILITY>,>-
		<<DECNET>,>-
		<<ALL>,>-
	> ; End of $LIB_KEY_TABLE
	.BLKL	4			; Allow us to patch in two more...
					; ...phases if the UETP grows
					; References to PHASE_TABLE...
					; ...must also be patched

VECTOR:					; Message vector for $PUTMSG
	.WORD	3			; Arg count - total number of longwords
	.WORD	^B0001			; Message flag
	.LONG	UETP$_TEXT		; Message ID
	.WORD	1			; FAO arg count
	.WORD	0			; New message flags
MSG_DESC:
	.LONG	BUFFER_PTR		; Address of message descriptor

WS_SIZE:				; GETJPI results list
	.LONG	0
JPI_ASTLM:
	.LONG	0
JPI_BIOLM:
	.LONG	0
JPI_BYTLM:
	.LONG	0
JPI_CPULIM:
	.LONG	0
JPI_ENQLM:
	.LONG	0
JPI_DIOLM:
	.LONG	0
JPI_FILLM:
	.LONG	0
JPI_PGFLQUOTA:
	.LONG	0
JPI_PRCLM:
	.LONG	0
JPI_TQLM:
	.LONG	0
PRIVS:
	.QUAD	0

TEMP_LENGTH:				; Temporary string desc...
	.LONG	0			; ...for the conversion...
TEMP_ADDR:				; ...of the numeric items...
	.LONG	0			; ...we find in SHOMEM.DAT
TEMP_VALUE:				; Temporary value of numeric item...
	.LONG	0			; ...we found in SHOMEM.DAT

MEM_SIZE:				; Total physical memory size in pages
	.LONG	0

MEM_FREE:				; Physical memory not being used now
	.LONG	0

MEM_MODIFY:				; Physical memory on the modified list
	.LONG	0

SWAP_SIZE:				; Count of free process entry slots
	.LONG	0

.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
POOL_SIZE:				; Nonpaged variable pool in bytes
	.LONG	0
.ENDC	; .IF NE POOL_ESTIMATE

PAGE_SIZE:				; Secondary storage for paging in pages
	.LONG	0

;
; CLI call back request descriptor
;
CLI_REQ_DESC:
	.BYTE	CLI$K_CLISERV
	.WORD	CLI$K_GETSYM		; Get local sym is what we want to do
	.BYTE	CLI$K_LOCAL_SYM
	.QUAD	0			; Desc of symbol name - CLI$Q_NAMDESC
	.QUAD	0			; Desc of returned value -CLI$Q_VALDESC

	.PSECT	RMS_STUFF,LONG
SHOMEM_FAB:				; Command file FAB
	$FAB	FNM = <SHOMEM.COM>,-
		FAC = PUT
SHOMEM_RAB:				; Command file RAB
	$RAB	FAB = SHOMEM_FAB,-
		RBF = SHOMEM,-
		RSZ = SHOMEM_LEN

DATA_FAB:				; Data file FAB
	$FAB	FNM = <SHOMEM.DAT>
DATA_RAB:				; Data file RAB
	$RAB	FAB = DATA_FAB,-
		UBF = MBX_BUF,-
		USZ = TEXT_BUFFER
LOG_FAB:				; Log file FAB
	$FAB	FNM = <UETP.LOG>,-
		RAT = CR,-
		FAC = PUT
LOG_RAB:				; Log file RAB
	$RAB	FAB = LOG_FAB,-
		RBF = BUFFER,-
		RSZ = TEXT_BUFFER



	.SBTTL	Main Program
	.PSECT	UETINIT00,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

;+
;	UETINIT00 queries the user for UETP run-time information and welcomes
;	the user to UETP. The user is told what CPU type, memory configuration,
;	and system disk type he/she is running on. The user is prompted for the
;	number of complete passes he/she wants and if he/she responds with a
;	carriage return the default is one pass. The user is prompted for the
;	number of parallel simulated users that he wishes to have used in the
;	load test portion of the UETP. If he/she responds with a carriage return
;	UETINIT00 calculates an appropriate value for the configuration that is
;	being used and informs the user as to what that value is. The user is
;	prompted for the report format (long or short) that is desired. If a
;	carriage return is the response, then long report format is used.
;	The UETP.LOG file is first created in this program as well.  The user
;	is allowed to choose to run the entire UETP or a single phase, with the
;	default being the entire UETP.
;-

.ENTRY UETINIT00,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler
	$SETPRN_S PRCNAM = TEST_NAME	; Set the process name
10$:
	$TRNLOG_S LOGNAM = TTNAME_RWPTR,-
		  RSLLEN = TTNAME_RWPTR,-
		  RSLBUF = TTNAME_ROPTR	; Translate the logical name
	MOVAL	TTNAME,TTNAME_RWPTR+4	; Undo possible previous PPF fixup
	CMPL	R0,#SS$_NOTRAN		; Have we reached the end yet?
	BEQL	15$			; Br if yes
	CMPB	#^X1B,TTNAME		; Is this a process permanent file?
	BNEQ	10$			; Br if not
	SUBW	#4,TTNAME_RWPTR		; Remove  RMS overhead from PPF name...
	ADDL	#4,TTNAME_RWPTR+4	; ...
	BRB	10$			; Now it's safe to retranslate
15$:
	$GETDEV_S DEVNAM = TTNAME_RWPTR,-
		  PRIBUF = DIB_BUF 	; Get its device type
	CMPB	DIB+DIB$B_DEVCLASS,#DC$_TERM ; Is this a terminal?
	BNEQ	17$			; BR if no
	BISB2	#TERMINALM,FLAGS	; Set terminal flag
	$ASSIGN_S DEVNAM = TTNAME_RWPTR,- ; Set up for CTRL/C AST's
		  CHAN   = TTCHAN
	$QIOW_S	CHAN     = TTCHAN,-	; Enable CTRL/C AST's...
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND
17$:
	$GETJPI_S ITMLST = USER_LIST	; Get the username, privs and quotas
	CMPC3	ACNT_NAME,ACNT_NAME+8,-
		BUFFER			; Are we in the right account?
	BEQL	20$			; Br if no...
	PUSHAL	WRONG_ACCOUNT		; ...else report and exit
	PUSHL	#1			; Arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Signal name
	PUSHL	#3			; Parameter count
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT		; Give the user the last rights
20$:
	$CREATE FAB = LOG_FAB		; Create the log file
	$CONNECT RAB = LOG_RAB		; Connect the RAB
	$TRNLOG_S LOGNAM = MODE,-
		  RSLBUF = FAO_BUF	; Get mode
	BICB2	#LCBIT,BUFFER		; Convert to upper case
	CMPB	#^A/D/,BUFFER		; Is it dump
	BNEQ	30$			; BR if not
	BISB2	#DUMPM,FLAGS		; Else set the flag bit
30$:
	MOVQ	G^SYS$GQ_VERSION,VERSION ; Get the system version number
	MOVAL	WELCOME,MSG_DESC	; Message desc
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well
	BBC	#TERMINALV,FLAGS,35$	; Skip CTRL/C msg if no terminal
	PUSHAL	TEST_NAME		; ...tell the user...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS ; ...how to abort gracefully
	CALLS	#3,G^LIB$SIGNAL
35$:

;
; Go through this process' privileges and quotas.  If something nonstandard
; shows up, give a warning.
;
	CLRL	R2			; Init an index variable
40$:
	MOVZBL	OFFSET[R2],R4		; Get the offset of the priv
	EXTZV	R4,#1,PRIVS,R3		; Get the priv
	CMPL	EXPECTED[R2],R3		; Check it
	BNEQ	80$			; Br if bad
50$:
	AOBLSS	#PRIV_CNT,R2,40$	; Do all privs
60$:
	MOVZBL	OFFSET[R2],R4		; Get the offset of the quota
	CMPL	EXPECTED[R2],-
		JPI_ASTLM[R4]		; Check it
	BNEQ	80$			; Br if bad
70$:
	AOBLSS	#PRIV_CNT+QUOT_CNT,R2,60$ ; Do all quotas
	BBSC	#PRIV_PRNTV,FLAGS,75$	; Only print the ending message once...
	BRW	110$			; ... else skip it
75$:
	PUSHAL	ENDSTR			; push the message address
	PUSHL	#1			; push the arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; push the signal name
	CALLS	#3,G^LIB$SIGNAL		; print the starting error message
	BRB	110$
80$:
	BBSS	#PRIV_PRNTV,FLAGS,90$	; Only print the end error message once
	INCL	ERROR_COUNT		; Bump the error count
	PUSHAL	STRSTR			; Push the string address
	PUSHL	#1			; Push the arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Push the signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	#6,G^LIB$SIGNAL		; Print the error message
90$:
	MOVAL	PRV_STR,R6		; Default to priv
	MOVZBL	POQ_TBL[R2],R7		; Get the item type
	BLBC	R7,100$			; Br if it was priv...
	MOVAL	QUO_STR,R6		; ...else change it to quota
100$:
	$FAO_S	CTRSTR = CTRSTR,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = NAM_PTRS[R2],-
		P2     = R6		; Generate the string
	PUSHAL	BUFFER_PTR		; Push the address...
	PUSHL	#1			; ...the arg count...
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; ...the signal name...
	CALLS	#3,G^LIB$SIGNAL		; ...and print the message
	MOVZBL	POQ_TBL[R2],R7		; Get the item type
	BLBC	R7,105$			; Return to the loop for quotas...
	BRW	70$			; ...here or...
105$:
	BRW	50$			; ...privs here
110$:
;
; Figure out the CPU type in preparation for defining the number of load test
; loads to run.
;
	MOVZBL	G^EXE$GB_CPUTYPE,R6	; Get the CPU type
	MOVAL	CPU_TYPE_TABLE,R7	; Get the table address
	CLRL	R8			; Clear out an index
120$:
	CMPB	R6,(R7)+		; Is this it?
	BEQL	130$			; Br if yes
	AOBLSS	#PR$_SID_TYPMAX,-
		R8,120$			; Check all of them
	MOVAL	UNKNOWN_CPU,R8		; This is a strange one!
	BRB	140$
130$:
; CPU type alone is not enough to figure loads.  Multiple CPU configurations
; mean that we can handle different load mixes.  Figuring whether we indeed
; have a multiple CPU configuration uses the VMS location EXE$GL_MP, which
; if nonzero, indicates the presence of a tightly-coupled, second processor.
	TSTL	G^EXE$GL_MP		; Are we multiprocessing?
	BEQL	135$			; BR if not
	MCOML	R8,R8			; Convert to negative index if we are
135$:
	MOVF	CPU_SCALE_TABLE[R8],CPU_SCALE ; Save the CPU scale factor
	MOVL	CPU_NAME_TABLE[R8],R8	; Ah! that's what kind of CPU it is.
140$:

;+
; The following code creates a file called SHOMEM.COM which contains a single
; DCL command of $SHOW MEMORY. It then creates a subprocess and executes the
; file to create an ascii sequential data file ( SHOMEM.DAT) containing the
; results of the command from SYS$OUTPUT. The command file is then deleted and
; the needed system information is extracted from the output file. Once the
; needed information is extracted the output and command files are deleted.
;-

	$CREMBX_S	CHAN = MBX_CHAN	; Generate a mailbox
	$GETCHN_S	CHAN = MBX_CHAN,-
			PRIBUF = DIB_BUF ; Get its unit number...
	MOVW	DIB+DIB$W_UNIT,MBX_UNIT	; ...and save it
	$CREATE FAB = SHOMEM_FAB,-
		ERR = RMS_ERROR		; Create the command file
	$CONNECT RAB = SHOMEM_RAB
	$PUT	RAB = SHOMEM_RAB,-
		ERR = RMS_ERROR		; Put a '$SHOW MEMORY' in it
	$CLOSE	FAB = SHOMEM_FAB,-
		ERR = RMS_ERROR		; Close it
	$CREPRC_S IMAGE = LOGINOUT,-
		  INPUT = SHOMEM_DESC,-
		  OUTPUT= SHOMEM_OUTPUT,-
		  MBXUNT= MBX_UNIT	; Create the detached process
	$QIOW_S	 CHAN = MBX_CHAN,-
		  EFN = #1,-
		 FUNC = #IO$_READVBLK,-
		   P1 = MBX_BUF,-
		   P2 = #TEXT_BUFFER	; Wait for the process to finish
	$ERASE	FAB = SHOMEM_FAB,-
		ERR = RMS_ERROR		; Clean up the command file
	$OPEN	FAB = DATA_FAB,-
		ERR = RMS_ERROR		; Open the resulting data file
	$CONNECT RAB = DATA_RAB
	PUSHL	R8			; Save this over SHOMEM_READ
	BSBW	SHOMEM_READ		; Read all the data we need
	POPL	R8			; Restore after SHOMEM_READ
	$FAO_S	CTRSTR = SYSTEM,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R8,-
		P2     = MEM_SIZE	; Generate the string
	MOVAL	BUFFER_PTR,MSG_DESC
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well
	$TRNLOG_S LOGNAM = SYSDISK,-
		  RSLLEN = DISK_BUFFER,-
		  RSLBUF = DISK_BUFFER	; Get the system disk designation
	$FAO_S	CTRSTR = DISK,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DISK_BUFFER   ; Format system disk msg
	MOVAL	BUFFER_PTR,MSG_DESC
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well

;+
; 	Here we call the CLI to get values for local symbols P1-P4. If they are
;	not defined SYS$CLI returns LIB$_NOSUCHSYM and each associated descriptor
;	is left with length zero. 
;-
	CLRL	R9			; Symbols found counter
	MOVAL	CLI_REQ_DESC,R6		; CLI request block
	MOVAL	SYM_NAM_TABLE,R7	; Parameter names
	MOVAL	SYM_VAL_TABLE,R8	; Table for returned values
	MOVL	#SYMBOL_CNT,R11		; Loop count
150$:
	MOVQ	(R7)+,CLI$Q_NAMDESC(R6) ; Put symbol name desc in req block
	CLRQ	CLI$Q_VALDESC(R6)	; Init return desc
	PUSHAL	(R6)			; Push address of the req block
	CALLS	#1,G^SYS$CLI		; Callback to the CLI
	CMPL	R0,#SS$_NORMAL		; Did we find it
	BNEQ	160$			; BR if not
	TSTW	CLI$Q_VALDESC(R6)	; Test for zero length
	BEQL	160$			; Br if zero length
	SKPC	#^A/ /,CLI$Q_VALDESC(R6),- ; Make sure we did not get all spaces
		@<CLI$Q_VALDESC+4>(R6)
	BEQL	160$			; BR if only spaces
	INCL	R9			; Count this one found
	MOVL	CLI$Q_VALDESC(R6),(R8)+	; Save return length
	MOVC3	CLI$Q_VALDESC(R6),-	; ...and value
		@<CLI$Q_VALDESC+4>(R6),@(R8) 
	SUBL2	#4,R8			; Reset R8 to start of present descriptor
160$:
	ADDL2	#8,R8			; Move PTR to next value descriptor
	SOBGTR	R11,150$		; Repeat until we tried them all
	TSTL	R9			; Were any symbols defined?
	BNEQ	PHASE			; BR if we found at least one
	BBC	#TERMINALV,FLAGS,PHASE	; BR if we are not connected to a 
					;  terminal -we will use default values
	BISB2	#PROMPTM,FLAGS		; No parameters were defined and we are
					;  connected to a terminal so set the
					;  flag for prompting


;+
;	See if the user wants to run the entire UETP or just a single phase.
;	Define a logical name, UETPPHASE, with the result.  UETP.COM will use
;	the translation of UETPPHASE to branch to the appropriate phase.
;-

PHASE:
	BBC	#PROMPTV,FLAGS,5$	; BR if prompt flag is clear
	PUSHAL	OUTLEN			; Receives length of response
	PUSHAL	PHASE_PROMPT		; User's prompt
	PUSHAL	ANSWER			; User's reply string
	CALLS	#3,G^LIB$GET_COMMAND	; See which phase(s) the user wants
	BLBS	R0,10$			; Can we read SYS$COMMAND?
	MOVL	R0,STATUS		; Supply and exit status...
	BRW	FINI			; ...and bail out if we can't
5$:
	TSTB	P1_DESC			; Was a phase defined?
	BEQL	10$			; BR if not defined - use default "ALL"
	MOVL	P1_DESC,OUTLEN		; Set P1 param length in buffer
	MOVC3	P1_DESC,P1_BUF,@OUTLEN+4 ; Put in defined phase name
	BRW	70$			; Go check for valid phase
10$:
	MOVZWL	ALL_PHASE,BUFFER_PTR	 ; Assume we want ALL UETP phases...
	MOVC3	ALL_PHASE,@ALL_PHASE+4,- ; ...which means the "ALL" label...
		BUFFER			 ; ...and a default name for $CRELOG
	BBC	#PROMPTV,FLAGS,20$	; BR if we are not prompting
	TSTL	OUTLEN			; Was there any response?
	BNEQ	30$			; BR if there was
20$:
	BRW	100$			; Skip syntax check & selection
30$:
	BICB2	#LCBIT,ANSWER+8		; We understand upper case responses
	CMPB	#^A/A/,ANSWER+8		; Do we want ALL phases?
	BEQL	20$			; We do, skip phase selection
	CMPB	#^A/O/,ANSWER+8		; Did user supply correct syntax for ONE?
	BEQL	40$			; BR if so - select a phase
	BSBW	SYNTAX_ERROR		; Bad response - give an error...
	BRB	PHASE			; ...and reprompt
40$:
;
; Form on the stack a $FAOL PRMLST of UETP phase names, based on the list to be
; passed to LIB$LOOKUP_KEY.  Be somewhat clever in listing the names, inserting
; proper spacing and new lines.  In doing so, remember that $FAOL uses a FIFO
; algorithm for removing items from the PRMLST.  We'll preallocate a worst case
; amount of space on the stack (which is normally LIFO!) and stick pointers to
; .ASCIC strings on the list in FIFO order. The space needed takes into account
; that we could need three longwords per phase name (the name, separator
; characters and newline), that the list of names has a count of longwords at
; its front instead of a count of entries, and that we're allocating bytes, not
; longwords.  Use the $FAOL results as the prompt for the phase we want to
; execute.
;
	MOVL	SP,R6			; R6 will clean up the stack later
	CLRL	R7			; R7 counts the .ASCIC strings
	MOVAL	PHASE_TABLE,R8		; R8 points to the phase name list
	SUBL2	#2,(R8)			; Shorten table so ALL isn't output
	MULL3	#6,(R8),R9		; Figure worst case of space we'll need
	SUBL2	R9,SP			; Preallocate space on the stack
	MOVL	SP,R9			; R9 points to base of FIFO list
	ASHL	#-1,(R8)+,R10		; R10 counts phase names remaining
					; (R8 now points to ptr to first name)
	MOVZBL	WHICH_PHASE1,R11	; R11 counts characters on a line
	SUBL2	#10,R11			; Correct for $FAOL command characters
50$:
	ADDB3	@(R8),R11,R5		; If phase name + current line width...
	ACBB	#80,COMMA_BLANK,R5,60$	; ...+ separator chars .GT. 80...
	MOVAL	NEW_LINE,(R9)+		; ...then start a new line,...
	SUBB3	#2,NEW_LINE,R5		; ...figure what column we're on,...
	INCL	R7			; ...and count another .ASCIC string
60$:
	MOVL	(R8)+,(R9)+		; Put a phase name on $FAOL PRMLST
	TSTL	(R8)+			; Skip over LIB$LOOKUP_KEY assoc. value
	MOVAL	COMMA_BLANK,(R9)+	; Put separator chars on $FAOL PRMLST
	ADDL2	#2,R7			; Count the .ASCIC strings we've pushed
	MOVL	R5,R11			; Update current line width
	SOBGTR	R10,50$			; Loop if there are more phase names
	MOVAL	WHICH_PHASE2,-(R9)	; Use second half of prompt to...
					; ...overwrite trailing separator chars
	PUSHL	R7			; Put .ASCIC count in front of PRMLST
	MOVL	SP,R8			; Save pointer to the PRMLST
	$FAOL_S	CTRSTR = WHICH_PHASE1,-	; Form prompt for...
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		PRMLST = (R8)
	MOVL	R6,SP			; (Restore stack: rid it of PRMLST)
	PUSHAL	OUTLEN
	PUSHAL	BUFFER_PTR
	PUSHAL	ANSWER
	CALLS	#3,G^LIB$GET_COMMAND	; ...deciding which phase to run
	BLBS	R0,70$			; Can we read SYS$COMMAND?
	MOVL	R0,STATUS		; Supply an exit status...
	BRW	FINI			; ...and bail out if we can't
70$:
;
; Now that we've got a phase name (from P1 or prompt), see if it is a valid
; phase name. If it isn't, give some sort of useful message and reprompt or
; if from P1 bitch and bail-out.
;
	PUSHAL	OUTLEN			; Convert possible...
	PUSHAL	OUTLEN			; ...lowercase answer...
	CALLS	#2,G^STR$UPCASE		; ...to uppercase
	PUSHAL	BUFFER_PTR		; See which phase: out-len...
	PUSHAL	FAO_BUF			; ...full-dsc-adr...
	PUSHL	#0			; ...key-value-adr...
	PUSHAL	PHASE_TABLE		; ...key-table-adr...
	PUSHAL	OUTLEN			; ...str-dsc-adr...
	CALLS	#5,G^LIB$LOOKUP_KEY	; ...
	CMPW	#SS$_NORMAL,R0		; Did we get a unique match?
	BNEQ	75$			; BR if not
	BRW	100$			; This branch should reach
75$:
	BBC	#PROMPTV,FLAGS,90$	; Br if we were not prompting
	PUSHR	#^M<R0>			; Save status over $GETMSG
	$GETMSG_S MSGID = R0,-		; Figure out...
		 MSGLEN = BUFFER_PTR,-	; ...if the message...
		 BUFADR = FAO_BUF,-	; ...associated with our fail code...
		 FLAGS  = #0,-		; ...needs any $FAO args
		 OUTADR = MSG_BLOCK
	POPR	#^M<R0>			; Restore failure code
	MOVZBL	MSG_BLOCK+1,R1		; Make $FAO arg count more useable
	BEQL	80$			; BR if there are no associated args
	PUSHAL	OUTLEN			; Assume that the arg is the bad string
	PUSHL	#1
	MOVL	#2,R1
80$:
	ADDL2	#4,R1			; Old arg count+4 gives LIB$SIGNAL args
	PUSHL	R0			; Yell at the user if bad reply...
	PUSHAL	SYNTAX_ERROR_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	R1,G^LIB$SIGNAL
	BRW	40$			; ...and politely ask again
  
90$:	; P1 is an invalid phase name - bitch and quit

	$FAO_S	CTRSTR = INVALID_PHASE_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P1_DESC
	PUSHL	#SS$_BADPARAM
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#4
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT

;
; We've got our phase name or ALL phases.  The logical name we create from it
; will be used to dispatch to the correct phase(s) once we've exited this
; image, so it must either be created in other than user mode (a pain), or in
; other than the process logical name table.  We choose to define a group
; logical name.
;
100$:
	MOVW	BUFFER_PTR,PARAM_MSG ; Save phase name for parameter msg
	MOVC3	BUFFER_PTR,BUFFER,PARAM_BUF
	$CRELOG_S LOGNAM = UETPPHASE,-	; Define logical name for UETP.COM label
		  EQLNAM = BUFFER_PTR,-
		  TBLFLG = #1		; It's a group logical name

;+
; If the prompt flag is set we prompt the user for the number of passes else
; if P2 is defined we use that for pass count. If P2 is not defined or the
; prompt returns null, we use the default which is one pass.
;-

PASS:
	BBC	#PROMPTV,FLAGS,3$	; BR if not prompting
	PUSHAL	OUTLEN			; Set response length location
	PUSHAL	PASS_PROMPT		; Set prompt string
	PUSHAL	ANSWER			; Set answer address
	CALLS	#3,G^LIB$GET_COMMAND	; Ask for the pass count
	BLBS	R0,5$			; If no failure than continue
	MOVL	R0,STATUS		; else save error and
	BRW	FINI			; bail out
3$:
	MOVL	P2_DESC,OUTLEN		; Set P2 param length in buffer
	MOVC3	P2_DESC,P2_BUF,@OUTLEN+4 ; Put in defined pass count
5$:
	TSTL	OUTLEN			; Do we have a value yet?
	BNEQ	10$			; Br if yes...

6$:	; Use default of one pass

	MOVL	#1,PASS_COUNT		; save the integer default
	MOVL	#1,OUTLEN		; ...else fill in the default pass count
	MOVB	#^A/1/,ANSWER+8
	BRB	20$			; Go to logical name create

10$:	; Here we test for valid input - either from P2 or response to prompt

	PUSHL	#4			; Push size of results
	PUSHAL	PASS_COUNT		; Push place for results
	PUSHAL	OUTLEN			; Push ascii results
	CALLS	#3,G^OTS$CVT_TI_L	; Save the long word pass count
	CMPL	R0,#OTS$_INPCONERR	; Did it get input right?
	BNEQ	20$			; Br if yes...
	BBC	#PROMPTV,FLAGS,15$	; BR if not prompting
	BSBW	SYNTAX_ERROR		; ...else report the error...
	BRB	PASS			; ...and try again

15$:	; P2 is an invalid string for pass count - bitch and quit

	$FAO_S	CTRSTR = INVALID_PASS_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P2_DESC
	PUSHL	#SS$_BADPARAM
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#4
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT
20$:
	$CRELOG_S LOGNAM = PASS_NAME,-
		  EQLNAM = OUTLEN,-
		  TBLFLG = #1		; Make the pass count group logical name


;+
;	The default LOADS value is determined by several system parameters.
;	These parameters are extracted from the system and crunched to a
;	final value.  The system parameters are:
;
;		EXE$GB_CPUTYPE
;		MEM_FREE	Free main memory
;		MEM_MODIFY	Modified main memory
;		WS_SIZE		Current process working set size
;		FREE_PAGE	Free Page file space	Found using $SHOW MEMORY
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
;		FREE_POOL	Free Pool space		Found using $SHOW MEMORY
.ENDC	; .IF NE POOL_ESTIMATE
;		FREE_SWAP_SLOT	Free Swap slots		Found using $SHOW MEMORY
;
;	Constants are defined in this program for the calculation:
;
;		PP_PAGE_USAGE  Estimated amount of page file used per process
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
;		PP_POOL_USAGE  Estimated amount of pool space used per process
.ENDC	; .IF NE POOL_ESTIMATE
;		PER_WS_INUSE   Estimated amount of WS in constant use
;		CPU_SCALE      Estimated CPU performance ratio where 11/780 = 1
;
;	The equation used with these values is:
;
;	LOADS =  MIN( CPU_SCALE((MEM_FREE+MEM_MODIFY)/(WS_SIZE*PER_WS_INUSE)),
;		      FREE_PROCESS_SLOT,
;		     (FREE_POOL/PP_POOL_USAGE), 
;		     (FREE_PAGE/PP_PAGE_USAGE))
;-

LOAD:
	BBS	#PROMPTV,FLAGS,10$	; BR if prompting
	TSTB	P3_DESC			; Was P3 defined?
	BEQL	10$			; BR if it wasn't
	MOVL	P3_DESC,OUTLEN		; Set P3 param length in buffer
	MOVC3	P3_DESC,P3_BUF,@OUTLEN+4 ; Use P3 for load count
	BRW	60$			; Go test for valid input
10$:
	BITB	#DUMPM,FLAGS		; Dump mode?
	BNEQ	20$			; Br if yes...
	BRW	30$			; ...else skip the print of the dump
20$:
	PUSHAL	DUMP1			; Push output address
	PUSHL	#1			; Push arg count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push signal name
	CALLS	#3,G^LIB$SIGNAL		; Output the equation
	PUSHL	#2			; Push # of digits in the fraction
	PUSHAL	W^CPU_SCALE_DES		; Push string storage desc adr
	PUSHAF	W^CPU_SCALE		; Push adr of floating number
	CALLS	#3,G^FOR$CNV_OUT_F	; Make the number a string
	MOVF	#PER_WS_INUSE,WS_INUSE	; Get the percent of WS inuse
	PUSHL	#2			; Push # of digits in the fraction
	PUSHAL	W^WS_INUSE_DES		; Push string storage desc adr
	PUSHAF	W^WS_INUSE		; Push adr of floating number
	CALLS	#3,G^FOR$CNV_OUT_F	; Make the number a string
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
	$FAO_S	CTRSTR = DUMP2,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #CPU_SCALE_DES,-
		P2     = MEM_FREE,-
		P3     = MEM_MODIFY,-
		P4     = WS_SIZE,-
		P5     = #WS_INUSE_DES,-
		P6     = SWAP_SIZE,-
		P7     = POOL_SIZE,-
		P8     = #PP_POOL_USAGE,-
		P9     = PAGE_SIZE,-
		P10    = #PP_PAGE_USAGE ; Make the output string
.IFF
	$FAO_S	CTRSTR = DUMP2,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #CPU_SCALE_DES,-
		P2     = MEM_FREE,-
		P3     = MEM_MODIFY,-
		P4     = WS_SIZE,-
		P5     = #WS_INUSE_DES,-
		P6     = SWAP_SIZE,-
		P7     = PAGE_SIZE,-
		P8     = #PP_PAGE_USAGE ; Make the output string
.ENDC	; .IF NE POOL_ESTIMATE
	PUSHAL	BUFFER_PTR		; Push the string address
	PUSHL	#1			; Push the argument count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push the signal name
	CALLS	#3,G^LIB$SIGNAL		; Print the filled in equation
30$:
	ADDL2	MEM_MODIFY,MEM_FREE	; Calculate the total amount of free memory
	CVTLF	WS_SIZE,WS_SIZE		; Convert WS to floating format
	CVTLF	MEM_FREE,MEM_FREE	; Convert free memory size to float
	MULF2	#PER_WS_INUSE,WS_SIZE	; Scale the WS
	DIVF2	WS_SIZE,MEM_FREE	; Create a rough process capacity count
	MULF2	CPU_SCALE,MEM_FREE	; Scale the count for the CPU type
	CVTFL	MEM_FREE,LOAD_COUNT	; Covert back to integer and save...
					; ...and assume that it is the
					; reasonable LOAD count
	DIVL2	#PP_PAGE_USAGE,PAGE_SIZE ; Calculate page process count limit
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
	DIVL2	#PP_POOL_USAGE,POOL_SIZE ; Calculate pool process count limit
.ENDC	; .IF NE POOL_ESTIMATE
	PUSHAL	SWAP_SIZE		; Find the minimum of swap slots...
	PUSHAL	PAGE_SIZE		; ...free page file space...
	PUSHAL	LOAD_COUNT		; ...usable main memory...
.IF NE POOL_ESTIMATE	; Assemble this only if pool space is used for LOADS
	PUSHAL	POOL_SIZE		; ...and free pool space...
	CALLS	#4,G^MTH$JMIN0		; ...and leave the results in R0
.IFF
	CALLS	#3,G^MTH$JMIN0		; ...and leave the results in R0
.ENDC	; .IF NE POOL_ESTIMATE
	MOVL	R0,LOAD_COUNT		; save the MIN

	$SETSFM_S ENBFLG = #0		; Disable SS failure mode if no match
	$DELLOG_S LOGNAM = USERS,-	; Clean out any possible name that...
		  TBLFLG = #1		; ...might be left from a previous run
	$SETSFM_S ENBFLG = #1		; Re-enable system service failure mode

	BBC	#PROMPTV,FLAGS,56$	; BR if we're not prompting at all
	$TRNLOG_S LOGNAM = UETPPHASE,-	; We need only prompt...
		  RSLLEN = BUFFER_PTR,-	; ...if the user has indicated...
		  RSLBUF = FAO_BUF,-
		  DSBMSK = #^B101
	CMPC5	BUFFER_PTR,BUFFER,#0,-	; ...that either ALL phases...
		ALL_PHASE,@ALL_PHASE+4
	BEQL	40$
	CMPC5	BUFFER_PTR,BUFFER,#0,-	; ...or the LOAD phase are/is to be run
		LOAD_PHASE,@LOAD_PHASE+4
	BNEQ	56$			; Chosen phase gives user no choice
40$:	
	$FAO_S  CTRSTR = LOAD_PROMPT,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = LOAD_COUNT	; Create the prompt string
50$:
	PUSHAL	OUTLEN			; Set response length location
	PUSHAL	BUFFER_PTR		; Set prompt string
	PUSHAL	ANSWER			; Set answer address
	CALLS	#3,G^LIB$GET_COMMAND	; Ask for the load count
	BLBS	R0,55$			; If no failure than continue
	MOVL	R0,STATUS		; else save error and
	BRW	FINI			; bail out
55$:
	TSTL	OUTLEN			; Any response?
	BNEQ	60$			; Br if yes...

56$:	; Convert calculated number of loads to ascii

	MOVL	#4,OUTLEN		; Set the results length
	PUSHAL	OUTLEN			; Push output string desc
	PUSHAL	LOAD_COUNT		; Push the load count value
	CALLS	#2,G^OTS$CVT_L_TI	; Convert the load count to a string
	BRB	80$			; Go to logical name creation

60$:	; Test for valid input from P3 or prompt response

	PUSHL	#4			; Push size of results
	PUSHAL	ARG_COUNT		; Push place for results
	PUSHAL	OUTLEN			; Push ascii results
	CALLS	#3,G^OTS$CVT_TI_L	; Save the long word load count
	CMPL	R0,#OTS$_INPCONERR	; Did it get typed in right?
	BNEQ	70$			; Br if yes...
	BBC	#PROMPTV,FLAGS,65$	; BR if not prompting
	BSBW	SYNTAX_ERROR		; ...else report the error...
	BRW	50$			; ...and try again

65$:	; P3 is an invalid load count - bitch and quit

	$FAO_S	CTRSTR = INVALID_LOADCNT_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P3_DESC
	PUSHL	#SS$_BADPARAM
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#4
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT
70$:
	MOVL	ARG_COUNT,LOAD_COUNT	; It converted OK save it away
80$:
	$CRELOG_S LOGNAM = USERS,-
		  EQLNAM = OUTLEN,-
		  TBLFLG = #1		; Make the load count group logical name

;+
; If the prompt flag is set we prompt the user for LONG or SHORT report format 
; to be used by the rest of the UETP, else if P4 is defined we use that.
; If P4 is not defined or the prompt returns null, we use the default which
; is LONG report.
;-

REPORT_Q:
	BBS	#PROMPTV,FLAGS,3$	; BR if prompting
	MOVL	P4_DESC,OUTLEN		; Set P4 param length in buffer
	MOVC3	P4_DESC,P4_BUF,@OUTLEN+4 ; Put specified mode in buffer 
	BRB	5$
3$:
	PUSHAL	OUTLEN			; Set response length location
	PUSHAL	REPORT_PROMPT		; Set prompt string
	PUSHAL	ANSWER			; Set asnwer address
	CALLS	#3,G^LIB$GET_COMMAND	; Ask for the report format
	BLBS	R0,5$			; If no failure than continue
	MOVL	R0,STATUS		; else save error and
	BRW	FINI			; bail out
5$:
	TSTL	OUTLEN			; Any format specified?
	BNEQ	10$			; Br if yes...
	BRB	20$			; Go fill in LONG
10$:
	BICB2	#LCBIT,ANSWER+8		; Make sure that it is upper case
	CMPB	#^A/L/,ANSWER+8		; Is it long report format?
	BEQL	20$			; Br if yes
	CMPB	#^A/S/,ANSWER+8		; Is it short report format?
	BEQL	30$			; Br if yes...
	BBC	#PROMPTV,FLAGS,15$	; BR if not prompting
	BSBW	SYNTAX_ERROR		; ...else report a syntax error...
	BRB	REPORT_Q		; ...and ask again

15$:	; P4 is an invalid report type - bitch and quit

	$FAO_S	CTRSTR = INVALID_REPORT_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #P4_DESC
	PUSHL	#SS$_BADPARAM
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#4
	MOVL	#SS$_BADPARAM,STATUS	; Set the exit status
	BRW	ERROR_EXIT
20$:	; Long format
	MOVW	#4,OUTLEN
	MOVL	#^A/LONG/,ANSWER+8
	BRB	40$
30$:	; Short format
	MOVW	#5,OUTLEN
	MOVQ	#^A/SHORT/,ANSWER+8
40$:
	$CRELOG_S LOGNAM = REPORT_NAME,-
		  EQLNAM = OUTLEN,-
		  TBLFLG = #1		; Make the report format group logical name

;+
;
; Any additional UETP prompting code should be inserted at this point
; in the code.
;
;-

;+
;	All the interaction needed to set up a run of the UETP has been done.
;	Clean up and form a message summarizing what the user wants.
;-
FINAL_MESSAGE:
	$CLOSE FAB = DATA_FAB,-
	       ERR = RMS_ERROR		; Close the data file from $SHOW MEMORY
	$ERASE FAB = DATA_FAB,-
	       ERR = RMS_ERROR		; Delete the file
	$FAO_S	CTRSTR = START_MESSAGE,-; Make the startup message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #0
	MOVAL	BUFFER_PTR,MSG_DESC
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well
	MATCHC	ALL_PHASE,@ALL_PHASE+4,- ; See if we are running ALL phases
		PARAM_MSG,PARAM_BUF
	BEQL	10$			; Br if "ALL"
	SUBW2	#1,PHASES		; Drop the "S" off "PHASES"
10$:
	MOVZWL	PARAM_MSG,R6		; Get current length
	MOVC3	PHASES,@PHASES+4,-	; Add "PHASE(S)" to  msg
		PARAM_BUF[R6]
	ADDW2	PHASES,PARAM_MSG	; Update msg length

	CMPL	#1,PASS_COUNT		; Are we running only 1 pass
	BNEQ	20$			; Br if not 1	
	SUBW2	#2,PASS_MSG		; Drop "ES" off "PASSES"
20$:
	$FAO_S	CTRSTR = PASS_MSG,-	; Create pass count portion of start msg
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = PASS_COUNT
	MOVZWL	PARAM_MSG,R6		; Get current length
	MOVC3	BUFFER_PTR,@BUFFER_PTR+4,- ; Add number of pass(es) to  msg
		PARAM_BUF[R6]
	ADDW2	BUFFER_PTR,PARAM_MSG	; Update msg length
	$FAO_S	CTRSTR = LOAD_MSG,-	; Create loads count part of start msg
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = LOAD_COUNT
	MOVZWL	PARAM_MSG,R6		; Get current length
	MOVC3	BUFFER_PTR,@BUFFER_PTR+4,- ; Add number of load(s) to msg
		PARAM_BUF[R6]
	ADDW2	BUFFER_PTR,PARAM_MSG	; Update msg length
30$:
	MOVZWL	PARAM_MSG,R6		; Get current length
	CMPB	#^A/L/,ANSWER+8		; Long report?
	BNEQ	40$			; Br if not Long
	MOVC3	LONG_MSG,@LONG_MSG+4,-	; Add "LONG REPORT" to msg
		PARAM_BUF[R6]
	ADDW2	LONG_MSG,PARAM_MSG	; Update length
	BRB	50$			; Go output message
40$:
	MOVC3	SHORT_MSG,@SHORT_MSG+4,- ; Add "SHORT REPORT" too msg
		PARAM_BUF[R6]
	ADDW2	SHORT_MSG,PARAM_MSG	; Update msg length
50$:
	MOVAL	PARAM_MSG,MSG_DESC
	$PUTMSG_S-
		MSGVEC = VECTOR,-	; Go ahead and output msg
		ACTRTN = ACTRTN		; Output it to log file as well
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status


	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a system service or RMS error occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	The messages are output to SYS$OUTPUT and to UETP.LOG.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	CLRL	AST_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Were AST's enabled?
	BNEQ	10$			; BR if not enabled
	MOVL	#1,AST_MODE		; Set it to be reenabled
10$:	$SETSFM_S ENBFLG = #0		; Disable SS failure mode for PUTMSG
	CLRL	SS_FAIL_MODE		; Assume it was disabled
	CMPL	R0,#SS$_WASSET		; Was SS failure mode enabled?
	BNEQ	20$			; BR if not enabled
	MOVL	#1,SS_FAIL_MODE		; Set it to be reenabled
20$:	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#UETP$_FACILITY
	BNEQ	30$			; BR if this is a system exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6)- ; Print the message
		  ACTRTN = ACTRTN	; Print the message
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Return to the program
30$:
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- ; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	40$			; BR if not
	$SETSFM_S ENBFLG = SS_FAIL_MODE	; Set to previous state
	$SETAST_S ENBFLG = AST_MODE	; Set to previous state
	RET				; Yes, RMS_ERROR gets to handle them
40$:
	MOVL	CHF$L_SIG_NAME(R6),STATUS ; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,STATUS	; But is it a System Service failure?
	BNEQ	60$			; BR if not - no special case message
	$GETMSG_S MSGID = CHF$L_SIG_ARG1(R6),- ; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	50$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	CHF$L_SIG_ARG1(R6),-	; Give the message...
		#STS$V_SEVERITY,-	; ...the correct severity code
		#STS$S_SEVERITY,(SP)
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	60$
50$:
	PUSHL	CHF$L_SIG_ARG1(R6)	; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
60$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT

ACTRTN:
	.WORD	^M<R2>
	MOVL	4(AP),R2		; get the message descriptor address
	MOVZWL	(R2),LOG_RAB+RAB$W_RSZ	; set the message size
	MOVL	4(R2),LOG_RAB+RAB$L_RBF	; set the message address
	$PUT	RAB = LOG_RAB		; write to the log file
	MOVL	#SS$_NORMAL,R0		; set the return status code
	RET


	.SBTTL	SHOMEM.DAT RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls specific to
;	SHOMEM.DAT.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found in SHOMEM.DAT.
;
; INPUT PARAMETERS:
;	The RAB associated with the RMS call.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	RMS$_EOF
;
; SIDE EFFECTS:
;	May call RMS_ERROR if an unknown error is found.
;	Program may exit, depending on severity of the error.
;
;--

SHOMEM_RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; Get a pointer to our RAB
	CMPL	#RMS$_EOF,RAB$L_STS(R6)	; End of file?
	BNEQ	10$			; BR if not
	RET				; EOF is acceptable - do nothing
10$:
	PUSHL	4(AP)			; Any other error spells trouble...
	CALLS	#1,RMS_ERROR		; ...so let a real handler hassle it
	RET

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	The FAB or RAB associated with the RMS call.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get file name size for implicit PUSHL
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	Read Data from SHOMEM.DAT
;++
; FUNCTIONAL DESCRIPTION:
;	Now that we have the results of a $SHOW MEMORY in a file, we'll select
;	certain items we'll need to calculate LOADS.  Because it's difficult to
;	find items in the $SHOW MEMORY file, we search it using a table which
;	includes a key string used to find a particular line within the file
;	and a pointer to select the numeric item once we are at the right
;	line.  The value of the item will be stored for later use.
;
;	ASSUME storage values are initialized to zero by assembly.
;	ASSUME key strings in our table relate to items which are either in the
;	current line of the file or to following lines (i.e., one pass through
;	the file).
;	ASSUME pointer to leftmost byte is always greater than zero.
;	ASSUME that if a key string in our table is indicated to be repeating,
;	that is the last key in the table, because we will continue forever to
;	search for that string.
;	ASSUME there is at least one item for which we have to search.
;
; CALLING SEQUENCE:
;	BSBW	SHOMEM_READ
;
; IMPLICIT INPUTS:
;	SHOMEM.DAT has been opened for reading.
;	SHOMEM_DATA_TABLE contains entries for each item we want to find.  The
;		entries are formatted as:
;		offset  0:  string descriptor to KEYWORD parameter
;		offset  8:  address of place to store value of what we read
;		offset 12:  position in line of leftmost character to read
;		offset 13:  flags
;	ASSUMptions made above.
;
; IMPLICIT OUTPUTS:
;	Storage items named in SHOMEM_DATA_TABLE are filled from SHOMEM.DAT.
;
; SIDE EFECTS:
;	SHOMEM.DAT is read.
;	R0 through R8 are trashed.
;	Program exits on errors.
;
;--
SHOMEM_READ:
	MOVAL	SHOMEM_DATA_TABLE,R6	; R6 points to current line in table
	CLRL	R7			; R7 counts lines in the table
	MOVC5	#0,#0,#0,#TEXT_BUFFER,MBX_BUF ; Initialize buffer to force $GET
	MOVL	#7,TEMP_LENGTH		; All numbers we read are 7 digits
;
; Go through SHOMEM.DAT sequentially until a line with our string is found.
; Sometimes we just search for a line to position us within the file.  Skip
; to the next string after such lines are found.
;
10$:					; Repeat until we're through the table
	MATCHC	0(R6),@4(R6),-		; While the key string we want...
		DATA_RAB+RAB$W_RSZ,MBX_BUF 
	BEQL	20$
	$GET	RAB = DATA_RAB,-	; ...is not in this record...
		ERR = SHOMEM_RMS_ERROR	; ...read the next record
	CMPL	#RMS$_EOF,R0		; Find an EOF?
	BNEQ	10$			; Loop if not
	BRB	100$			; Exit main loop on EOF
20$:
	TSTL	8(R6)			; Do we need a value for this key?
	BEQL	40$			; BR if not - we only positioned file
;
; We have a line from which we have to extract some information.  The position
; of that information on the line is strictly determined by the SHOW MEMORY
; command.  In some cases though, prior information on the line (e.g., a file
; spec) can be long enought to interfere with what we want.  In that case, the
; next line of SHOMEM.DAT has what we want, and in the original position.
;
	MOVZBL	12(R6),R8		; Get the position of the numeric field
	ADDL3	R8,TEMP_LENGTH,R5	; Figure rightmost column of field
	CMPB	R5,DATA_RAB+RAB$W_RSZ	; Is the record long enough for us?
	BGTR	120$			; BR if not - an error
	CMPB	#^A/ /,MBX_BUF-1(R8)	; A blank preceding our field says...
	BEQL	30$			; ...there was room - go read it if so
	BBC	#CONTINUEV,13(R6),120$	; No room on this line. BR if disallowed
	$GET	RAB = DATA_RAB,-	; We're continued on next line. Get it
		ERR = RMS_ERROR		; Note we use regular handler error
30$:
	MOVAB	MBX_BUF(R8),TEMP_ADDR	; Finish descriptor to our field
	PUSHAL	TEMP_VALUE		; Convert the text string...
	PUSHAL	TEMP_LENGTH		; ...
	CALLS	#2,G^OTS$CVT_TI_L	; ...to its equivalent numeric value
	BLBC	R0,120$			; BR if error during conversion
;
; There are times when we must repeatedly search using the same string as a
; key because an item is repeated in SHOMEM.DAT.  With that in mind, we
; accumulate data and avoid updating our pointer into SHOMEM_DATA_TABLE.
;
	ADDL2	TEMP_VALUE,@8(R6)	; Put value in its place
	BBC	#REPEATV,13(R6),40$	 ; If this is a repeating key, then...
	MOVC5	#0,#0,#0,#TEXT_BUFFER,MBX_BUF ; ...reinit buffer to force $GET
	BRW	10$			; BR back to read next record
40$:
	ADDL2	#SHOMEM_ENTRY_SIZE,R6	; Not a repeating key so point...
	ACBL	#ENTRY_COUNT,#1,R7,10$	; ...to next item in table
;
; We must be a little tricky on checking to see that we finished correctly.
; Because the last item in the table can be repeating, we could find a value(s)
; for it, yet still run out of file looking for more values.  We will get an
; error if not all items in the table were satisfied.
;
100$:
	CMPB	#ENTRY_COUNT,R7		; Get here because table exhausted?
	BGEQ	110$			; BR if not
	RSB				; Yes, we're through successfully
110$:
	CMPB	#ENTRY_COUNT-1,R7	; Were we on the final item in table?
	BNEQ	120$			; BR if not - an error
	TSTL	@8(R6)			; Did we get some value for that item?
	BEQL	120$			; BR if not - an error
	RSB				; Yes, we're through successfully
120$:
	$FAO_S	CTRSTR = SHOMEM_ERROR,-	; Form an error message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = 12(R6),-
		P2     = R6
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#3
	BRW	ERROR_EXIT

	.SBTTL	Syntax Error Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles syntax errors.
;
; CALLING SEQUENCE:
;	BSBW SYNTAX_ERROR
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

SYNTAX_ERROR:

	PUSHAL	SYNTAX_ERROR_MSG
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	#3,G^LIB$SIGNAL
	RSB

	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	TEST_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message...
	MOVL	#<SS$_CONTROLC&^C7-	; ...and exit status
		!STS$K_WARNING-
		!STS$M_INHIB_MSG>,STATUS
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	ADDL3	(SP)+,#7,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	TEST_NAME		; Push test name...
	PUSHL	#2			; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ERBOX!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch
FINI:
	TSTL	STATUS			; Was an exit status supplied?
	BNEQ	10$			; BR if one was
	MOVL	#UETP$_ABENDD!STS$K_ERROR,- ; None there, supply a default
		STATUS
10$:
	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup on exits.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	Location STATUS contains the exit status
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$CLOSE FAB = LOG_FAB		; Close the log file
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETINIT00
