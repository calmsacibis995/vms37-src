	.TITLE	REQUEST_COMMAND - OPERATOR REQUEST TO REQUEST COMMAND IMAGE
	.IDENT	'V03-001'
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	REQUEST OPERATOR SERIVCE COMMAND.
;
; ABSTRACT:
;
;	THIS IMAGE IMPLEMENTS THE REQUEST COMMAND USED BY USERS TO REQUEST
;	THE SERIVCE OF AN OPERATOR.
;
; AUTHOR:
;	R.HEINEN 28-SEP-1977
;
; MODIFIED BY:
;
;	V03-001	BLS0158		Benn Schreiber	16-Mar-1982
;		Remove $CLIDEFQUALREQU and get symbols from STARLET
;
; 102	STJ0126		Steven T. Jeffreys,	07-Oct-1981
;	Suppress the printing of the operator response status code,
;	as the information is already part of the reply text.
;
; 101	T. Halvorsen	1-May-1979
;	Fix code to obtain job name for non-interactive jobs.  It
;	was putting garbage (escapes, etc) into the log message.
;--
;
; EXTERNAL SYMBOLS
;
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$JPIDEF				; DEFINE JPI SYMBOLS
	$OPCDEF				; DEFINE OPCOM SYMBOLS
	$OPCMSG				; DEFINE OPCOM MESSAGES
	$STSDEF				; DEFINE STS SYMBOLS
;
; LOCAL MACROS
;
	.MACRO	CLI	A,B,C
	.IF	NB	C
	PUSHAB	C
	.IFF
	CLRL	-(SP)
	.ENDC
	.IF	NB	B
	PUSHAB	B
	.IFF
	CLRL	-(SP)
	.ENDC
	.IF	NB	A
	PUSHAB	A
	.IFF
	CLRL	-(SP)
	.ENDC
	CALLS	#3,@W^CALLBACK
	.ENDM
;
; LOCAL STORAGE
;
	.PSECT	OPCOM_IMPURE,NOEXE,QUAD
 
;
; DATA STORAGE FOR TRANSLATION OF THE SYS$SOMMAND DEVICE
;

SYS_CMD:	.ASCID	'SYS$COMMAND'

SYS_CMD_I:	.LONG	0,.+4		; TRANSLATION OR GETJPI JOB NAME
		.BLKB	16

JPI_DATA:	.WORD	16		; MAX SIZE
		.WORD	JPI$_PRCNAM	; 
		.LONG	SYS_CMD_I+8	; STORAGE ADDRESS
		.LONG	SYS_CMD_I	; SIZE STORAGE ADDRESS
		.LONG	0
;
; STORAGE FOR DEVICE INFORMATION ON SYS$COMMAND
;
SYS_CMD_CHAR:	.LONG	4,.+4
		.BLKB	4		; DEVICE CHARACTERISTICS
;
; PROMPT STRING FOR CONTROL C ACTION
;
PROMPT:	.BYTE	20$-10$
10$:	.BYTE	13,10
	.ASCII	/REQUEST - Enter message or cancel request with <^Z>/
	.BYTE	13,10
	.ASCII	/REQUEST - Message? /
20$:
;
; WAIT FOR OPERATOR MESSAGE SYS$PUTMSG ARG LIST
;
WAIT_ARGS:	.LONG	3
		.LONG	10$
		.LONG	0,0
10$:		.LONG	3+<15@16>
		.LONG	OPC$_OPRNOTIF
		.LONG	1
		.LONG	0
;
; REPLY MESSAGE SYS$PUTMSG ARG LIST
;
REPLY_ARG1:	.LONG	3
		.LONG	10$
		.LONG	0,0
10$:		.LONG	2+<15@16>
REPLY_CODE:
		.WORD	0
		.WORD	5
		.LONG	0
REPLY_ARG2:	.LONG	3
		.LONG	10$
		.LONG	0,0
10$:		.LONG	4+<15@16>
		.LONG	OPC$_OPREPLY
		.LONG	2
REPLY_DESC:
		.LONG	0,0
;
; BUFFER DESCRIPTERS
;
OUT_DESC:	.LONG	0
		.LONG	BUFFER
INPUT_DESC:	.LONG	64
		.LONG	BUFFER
BUFFER:		.BLKB	64
REPLYBUF:	.BLKB	128+OPC$L_MS_TEXT
;
; OPERATOR MESSAGE
;
TEXT_DESC:	.LONG	128,TEXT
MSG_DESC:	.LONG	0
		.LONG	10$
		.LONG	0		; PAD SPACE
10$:	
		.BYTE	OPC$_RQ_RQST
TARGET:		.BLKB	3
		.LONG	1
TEXT:		.BLKB	128
;
; MESSAGE BUILDING CONTROL STRING
;
MSG_CONTROL:	.ASCID	'!AS, !AS'
;
; NO OPERATOR RESPONSE TEXT
;
NO_RESPONSE:	.ASCID	'no operator response text'
;
; CLI RESULT PARSE DATA STORAGE
;
CLI_MESSAGE:	$CLIREQDESC	RQTYPE=CLI$K_INPUT1
CLI_INITCMD:	$CLIREQDESC	RQTYPE=CLI$K_INITPRS
CLI_MAJORQUAL:	$CLIREQDESC	RQTYPE=CLI$K_GETQUAL,QUALST=QUALS
CLI_STRINGVAL:	$CLIREQDESC	RQTYPE=CLI$K_ASCIIVAL
CLI_WORKAREA:	.BLKB	CLI$C_WORKAREA
;
; QUALIFIER DESCS
;
QUALS:
REPL_QUAL:	$CLIQUALDESC QDCODE=CLI$K_REQU_REPL,TRUACT=REPL_ROUT
TO_QUAL:	$CLIQUALDESC QDCODE=CLI$K_REQU_TO,TRUACT=TO_ROUT
	$CLIQUALDESC	END_LIST
;
; LIST FOR MATCHC ON OPERATOR NAMES
;
NAME_BUF:				;
	.LONG	0,0,0			; 
;
; MISC STORAGE
;
MB_CHAN:	.LONG	0
TT_CHAN:	.LONG	0
MB_IOSB:	.LONG	0,0
TT_IOSB:	.LONG	0,0
MASK:		.LONG	0
CALLBACK:	.LONG	0
STATUS:		.LONG	0

	.SBTTL	REQUEST - REQUEST OPERATOR SERVICE
	.PSECT	OPCOM_CODE,NOWRT
;++
; REQUEST - REQUEST OPERATOR SERVICE COMMAND
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE REQUEST COMMAND IMAGE.
;
; THE ACTION IS TO ACT ON THE CLI'S RESULT PARSE DATA AND PERFORM THE REQUIRED
; OPERATOR UTILITY.
;
; INPUTS:
;
;	CLI RESULT PARSE DATA IS AVAILABLE
;
; OUTPUTS:
;
;	IMAGE EXIT WITH STATUS OF THE OPERATION.
;--
EXIT:	$EXIT_S	R0			; EXIT ON ERROR
REQUEST:				;
	.WORD	0			;
	MOVL	#OPC$_NOCLI,W^STATUS	; ASSUME ILLEGAL STATUS
	INSV	#-1,#0,#24,W^TARGET	; ASSUME ALL TERMINALS ARE TARGET
	MOVL	CLI$A_UTILSERV(AP),W^CALLBACK; GET CALL BACK ADDRESS
	BEQL	EXIT			; IF EQL THEN ERROR
	MOVZBL	#SS$_NORMAL,W^STATUS	; SET SUCCESS
	CLI	W^CLI_INITCMD,W^CLI_WORKAREA; INIT PARSE
	CLI	W^CLI_MAJORQUAL,W^CLI_WORKAREA,W^MASK; START QUALIFIER WORK
	MOVL	W^STATUS,R0		; GET THE STATUS OF THE QUALIFIER CALLS
	BLBC	R0,EXIT			; IF ERROR THEN EXIT
;
; TRANSLATE SYS$COMMAND TO GET TERMINAL NAME
;
	MOVZBL	#5,R2			; SET TRANSLATE LOOP COUNT
20$:	MOVL	#24,W^SYS_CMD_I		; SET 24 MAX CHARS
	$TRNLOG_S	LOGNAM=W^SYS_CMD,-
			RSLLEN=W^SYS_CMD_I,-
			RSLBUF=W^SYS_CMD_I
	MOVQ	W^SYS_CMD_I,W^SYS_CMD	; SET UP FOR NEXT TRANSLATE
	BLBC	R0,40$			; IF LOW CLEAR THEN DONE
	CMPW	R0,#SS$_NOTRAN		; IF NOT NORMAL THEN TRY AGAIN
	BEQL	40$			;
	CMPB	@W^SYS_CMD_I+4,#^X01B	; ESCAPE START STRING?
	BEQL	30$
	SOBGTR	R2,20$			;
	BRB	40$
30$:	ADDL	#4,W^SYS_CMD_I+4
	SUBL	#4,W^SYS_CMD_I
40$:	$GETDEV_S	W^SYS_CMD_I,,W^SYS_CMD_CHAR
	BBS	#DEV$V_TRM,@W^SYS_CMD_CHAR+4,55$; BR IF TERMINAL
	MOVAB	W^SYS_CMD_I+8,W^SYS_CMD_I+4	; RESET ADDRESS IN DESC.
	$GETJPI_S	ITMLST=JPI_DATA	; GET PROCESS NAME
	MOVQ	W^SYS_CMD_I,R0		; GET PROCESS NAME DESCRIPTOR
	SKPC	#^A/_/,R0,(R1)		; PASS ALL UNDERSCORES
	BEQL	60$			; IF EQL THEN NO USCORES
	MOVQ	R0,W^SYS_CMD_I		; COPY REMAINDER
	BRB	60$			; AVIOD ASSIGN
55$:	$ASSIGN_S	DEVNAM=W^SYS_CMD_I,CHAN=W^TT_CHAN
60$:	CLI	W^CLI_MESSAGE,W^CLI_WORKAREA,W^MASK
	MOVAB	W^CLI_MESSAGE+CLI$Q_RQDESC,R3; GET SIZE AND ADDRESS OF MESSAGE
	MOVAB	W^SYS_CMD_I,R0		; ADDRESS NAME DESC
	$FAO_S	W^MSG_CONTROL,W^MSG_DESC,W^TEXT_DESC,R0,R3
	ADDL	#OPC$L_MS_TEXT,W^MSG_DESC; ADJUST MESSAGE SIZE
	PUSHL	W^MB_CHAN		; SET MAILBOX CHANNEL NUMBER
	PUSHAB	W^MSG_DESC		; MESSAGE DESC
	CALLS	#2,@#SYS$SNDOPR		; SEND THE MESSAGE
	BLBS	R0,70$			; BR IF NOT ERROR
65$:	BRW	EXIT
;
; IF REPLY REQUESTED THE TELL USER AND AWAIT REPLY
;
70$:	TSTL	W^MB_CHAN		; REPLY REQUEST?
	BEQL	65$			; IF NEQ THEN YES
;
; ASK FOR CONTROL C
;
	BSBW	GET_ATTN_AST
80$:	$QIOW_S	#1,W^MB_CHAN,#IO$_READVBLK,W^MB_IOSB,,,W^REPLYBUF,#128
	BLBC	R0,100$			; EXIT ON ERROR
	MOVZWL	W^MB_IOSB,R0		;
	BLBC	R0,100$			; 
	MOVW	W^REPLYBUF+2,W^REPLY_CODE; INSERT MESSAGE CODE FOR EXIT
	MOVZWL	W^MB_IOSB+2,W^REPLY_DESC; SET UP FOR TEXT MESSAGE OUTPUT
	MOVAB	W^REPLYBUF+8,W^REPLY_DESC+4;
	SUBL	#8,W^REPLY_DESC		;
	BLSS	90$			; IF LSS THEN BAD MESSAGE
	BNEQ	85$			; IF NEQ THEN OPERATOR TEXT PRESENT
	MOVQ	W^NO_RESPONSE,W^REPLY_DESC; RESET TEXT
85$:	CALLG	W^REPLY_ARG2,@#SYS$PUTMSG; OUTPUT TEXT MESSAGE
	CMPW	W^REPLY_CODE,#<OPC$_RQSTPEND&^X0FFFF>; REQUEST STILL PENDING?
	BNEQ	90$			; IF NEQ THEN DONE
	BSBW	OUTPUT_WAITING		; OUTPUT WAITING MESSAGE
	BRB	80$			; WAIT AGAIN
90$:	$DASSGN_S	W^MB_CHAN	;
	$DASSGN_S	W^TT_CHAN	; 
95$:	MOVL	#<OPC$_RQSTCMPLTE!STS$M_INHIB_MSG>,R0	; SET UP SUBSYSTEM
	MOVW	W^REPLY_CODE,R0		;
100$:	$EXIT_S	R0			; DONE

;
; GET ATTENTION AST ROUTINE
;
GET_ATTN_AST:
	$QIOW_S	#0,W^TT_CHAN,#IO$_SETMODE!IO$M_CTRLCAST,,,,W^ATTN_AST
OUTPUT_WAITING:
	CALLG	W^WAIT_ARGS,@#SYS$PUTMSG
	RSB
;
; ATTENTION AST ROUTINE
;
ATTN_AST:
	.WORD	^M<R1,R2,R3,R4,R5>
5$:	MOVAB	W^PROMPT,R0
	MOVZBL	(R0)+,R1
	MOVZBL	W^SYS_CMD_I,R3		; GET SIZE OF TERMINAL NAME
	ADDL	#2,R3			; AND PASS COMMA
	ADDL3	#OPC$L_MS_TEXT,R3,W^MSG_DESC; SET UP SIZE
	MOVAB	W^TEXT[R3],R3		; ADDRESS MESSAGE AREA
	$QIOW_S	#2,W^TT_CHAN,#IO$_READPROMPT,W^TT_IOSB,,,(R3),#120,,,R0,R1
	BLBC	R0,100$
	BLBC	W^TT_IOSB,100$		;
	MOVB	#OPC$_RQ_RQST,@W^MSG_DESC+4; ASSUME INFO MESSAGE
	PUSHL	#0			; ASSUME NO CANCEL
	MOVZWL	W^TT_IOSB+2,R0		; GET TEXT SIZE
	BNEQ	10$			; IF NEQ THEN PRESENT
	CMPB	W^TT_IOSB+4,#^X01A	; "^Z"?
	BNEQ	5$			; IF NEQ THEN ASK AGAIN
	MOVB	#OPC$_RQ_CANCEL,@W^MSG_DESC+4
	MOVL	W^MB_CHAN,(SP)		; SET UP CANCEL REPLY
10$:	ADDL	R0,W^MSG_DESC		; SET UP MESSAGE SIZE
	PUSHAB	W^MSG_DESC		; 
	CALLS	#2,@#SYS$SNDOPR		;
	BLBC	R0,100$			; EXIT IF ERROR
	BSBW	GET_ATTN_AST		; GET THE ATTENTION AST
	RET				; EXIT AST
100$:	$EXIT_S	R0			; EXIT ON AST ERROR

	.SBTTL	QUALIFIER ACTION ROUTINES
 
	.ENABL	LSB
 
;++
;  OPERATOR TERMINAL QUALIFIER
;--
TO_ROUT:				; OPERATOR TERMINAL QUALIFIER
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	CLRL	W^TARGET		; ASSUME NO NAMES
	MOVAB	W^TO_QUAL,R6		; ADDRESS QUALIFIER
	TSTW	CLI$W_QDVALSIZ(R6)	; ANY NAME AT ALL?
	BEQL	115$			; IF EQL THEN ERROR
	MOVAB	W^OPC$A_NAMES,R9	; ADDRESS MATCH DATA
	MOVAB	W^NAME_BUF,R8		;
20$:	TSTW	CLI$W_QDVALSIZ(R6)	; VALUE PRESENT?
	BEQL	100$			; IF EQL THEN NO
	CLI	W^CLI_STRINGVAL,W^CLI_WORKAREA,(R6)
	MOVL	W^CLI_STRINGVAL+CLI$Q_RQDESC,R7; GET SIZE OF THE VALUE
	MOVC5	R7,@W^CLI_STRINGVAL+CLI$Q_RQDESC+4,#0,#12,(R8); MOVE NAME TO THIS SPACE
	BISB	#^X080,(R8)		; SET BIT FOR MATCH
	MATCHC	R7,(R8),#OPC$C_NAMES,(R9);
	BNEQ	115$			; IF NEQ THEN ILLEGAL OPERATOR NAME
	BICB	#7,R3			; FIND OFFSET IN TABLE
	SUBL	R9,R3			; 
	ASHL	#-3,R3,R3		;
	BBSS	R3,W^TARGET,20$		; SET THE BIT
	BRB	20$
100$:	MOVZBL	#SS$_NORMAL,W^STATUS	; SET STATUS AS SUCCESS
	RET
115$:	MOVL	#OPC$_UNKNOPR,W^STATUS	; SET UNKNOWN OPERATOR ERROR
120$:	RET				;
 
;++
; REPLY QUALIFIER
;--
REPL_ROUT:				; REPLY QUALIFIER ROUTINE
	.WORD	0
$CREMBX_S	#0,W^MB_CHAN,#OPC$L_MS_TEXT+128,#2*<OPC$L_MS_TEXT+128>,#^X000FF
	MOVL	R0,W^STATUS		; SAVE STATUS
	RET				;
	.END	 REQUEST
