	.TITLE	TST03A
	.IDENT	/V03000/
	.PSECT	TST03A
;
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982 BY					    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; VERSION X02
;
; WRITTEN BY CLARK A. D'ELIA, NOVEMBER 1972
;
; MODIFIED BY:
;	C.A. D'ELIA	AUGUST 1974  (FOR RSX-11M)
;	THOMAS J MILLER	7/15/75 (CHANGE TESTS FOR INVALID DPB SIZES)
;	LARRY JONES	JANUARY 1978 (VAX/VMS SUPPORT)
;
;+
;
; MODULE 'TST03A' IS DESIGNED TO TEST SYSTEM DIRECTIVES OF
; RSX-11M.  THE DIRECTIVES TESTED ARE AS FOLLOWS:
;
;	GET TIME PARAMETERS
;	MARK TIME
;	RUN
;
;
;-
 
	.MCALL	WTSE$,CLEF$S,CLEF$,MRKT$,RUN$,GTIM$S,MRKT$S
	.MCALL	SETF$S,GTIM$,WTSE$S,WTLO$,EXIT$S,RUN$C,RQST$C
	.MCALL	CALL,RETURN
 
 
;
; LOCAL ASSIGNMENTS
;
 
LF=12				;LINE FEED ASCII CODE
 
;
; LOCAL DATA
;
 
TIMB1:	.BLKW	8.		;TIME PARAMETERS BUFFER #1
 
TIMB2:	.BLKW	8.		;TIME PARAMETERS BUFFER #2
 
TIMDIF:	.BLKW	4		;TIME DIFFERENCE BUFFER
 
TOLER:	.BLKW	1		;HOLDS TIMING ERROR TOLERANCE (IN TICKS)
 
TCKTBL:				;TABLE OF CLOCK TICK CONSTANTS
TCKSEC:	.BLKW	1		;TICKS PER SECOND
TCKMIN:	.BLKW	1		;TICKS PER MINUTE
 
TST03C:	.RAD50	/TST03C/
 
TST03Z:	.RAD50	/03Z/
 
	.NLIST	BEX
 
MONTH:	.RAD50	/JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC/
 
LMG00:	.ASCII	/+++ DATE:  %D-%R-%D%N/
	.ASCII	/    TIME:  /
LEM00:	.ASCIZ	/%D:%D:%D:%D/
LMG01:	.ASCIZ	/%N    CLOCK FREQUENCY:  %D. CPS/<LF>
 
LEM01:	.ASCIZ	/"TIMING" ERROR%NEXP'D: %D:%D:%D:%D, RCV'D: /
 
LEM02:	.ASCII	/TASK ACTIVATION ERROR%NEXP'D BY %D-%D-%D-%D, BUT/
	.ASCIZ	/ NOT ACTIVE BY /
 
LEM03:	.ASCIZ	/, EVENT FLAG NOT CLEARED BY "MARK TIME" DIRECTIVE/
 
LEM04:	.ASCIZ	/, %D. RESCHEDULE ERROR(S) DECTECTED/
 
LEM05:	.ASCIZ	/%NMARK TIME REQUEST NOT FLUSHED AT TASK EXIT/
 
	.LIST	BEX
	.PAGE
	.PSECT	$DPB$$

;
; THIS PSECT CONTAINS ONLY DPB'S
;
 
CL37:	CLEF$	37.


WT37:	WTSE$	37.
 
 
MKTDPB:	MRKT$
 
 
GTIM2:	GTIM$	TIMB2


RUNDPB:	RUN$	TST03C


RUN03B:	RUN$	TST03B,,,,,4.,SECOND
 
 
W3637:	WTLO$	2,000030	;WAIT FOR EVENT FLAGS 36. OR 37.
 
 
W3638:	WTLO$	2,000050	;WAIT FOR EVENT FLAGS 36. OR 38.
	.PAGE
	.PSECT	TST03A
	.EVEN
;+
;
; INITIALLY, THE TASK SENDS AN IDENTIFYING MESSAGE TO THE USER
; AT TI: .  THE MESSAGE GIVES THE TEST NUMBER AND THE FACT THAT THE
; TASK HAS STARTED EXECUTION.
;
;-
	$$TEST	3,A
	CALL	.STST		;PRINT THE 'START OF TEST' MESSAGE
;+
;
; THE  FOLLOWING STEP ISSUES A "GET TIME PARAMETERS" DIRECTIVE.
; THE SYSTEM WILL RETURN EIGHT WORDS OF INFORMATION, WHICH INCLUDES
; YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, CLOCK TICK, AND THE NUMBER
; OF CLOCK TICKS IN A SECOND (A VARIABLE).  THERE IS NO ACCURATE WAY
; TO CHECK OUT THIS INFORMATION, SO IT IS ASSUMED TO BE CORRECT.
; HOWEVER, THE TIME INFORMATION WILL BE PRINTED IN A MESSAGE TO TI:.
;
;-
	CALL	GETIME		;GET TIME INFORMATION
	MOV	#TIMB1,R2	;POINT P2 AT TIME BUFFER
	MOV	R2,R0		;AND COPY IT INTO R0
	MOV	4(R0),-(SP)	;SWITCH THE POSITIONS OF ...
	MOV	(R0),4(R0)	;... THE YEAR AND THE DAY
	MOV	(SP)+,(R0)+	;
	MOV	(R0),R1		;PUT NUMERIC VALUE OF MONTH IN R1
	ROL	R1		;CONVERT IT TO WORD OFFSET
	MOV	MONTH-2(R1),(R0)  ;PUT RAD-50 VALUE OF MONTH IN ARG LIST
	MOV	#.OBUF,R0	;PUT ADDR OF OUTPUT BUFFER IN R0
	MOV	#LMG00,R1	;PUT ADDR OF FORMAT STRING IN R1
	CALL	$EDMSG		;CREATE FIRST PART OF MESSAGE
	MOV	#LMG01,R1	;PUT ADDR OF NEXT FORMAT STRING IN R1
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
 
;
; CALCULATE THE REQUIRED CONSTANTS BASED ON CLOCK TICKS PER SECOND
;
 
	MOV	#TCKTBL,R3	;PUT ADDR OF TICK CONVERSION TABLE IN R3
	MOV	TIMB1+G.TICP,R0	;PUT NUMBER OF CLOCKTICKS/SECOND IN R0
	MOV	R0,(R3)+	;PUT TICKS/SECOND IN CONVERSION TABLE
	MOV	#60.,R1		;PUT NUMBER OF SECONDS/MINUTE IN R1
	CALL	$MUL		;CALCULATE NUMBER OF CLOCKTICKS/MINUTE
	MOV	R1,(R3)+	;PUT TICKS/MINUTE IN TABLE, TOO
 
;+
;
; THE TIMING ERROR TOLERANCE FACTOR MUST BE DETERMINED, BECAUSE IT IS
; POSSIBLE FOR THIS TEST TO DECLARE ERROR MESSAGES BASED ON TIME
; DIFFERENCES CAUSED SOLELY BY THE FACT THAT THE SYSTEM CLOCK IS
; RUNNING TOO FAST.  THIS IS DONE FOR THE INITIAL TESTING BY
; GETTING THE TIME, WAITING ON AN EVENT FLAG THAT IS ALREADY SET,
; GETTING THE TIME AGAIN, AND USING THE DIFFERENCE AS THE TOLERANCE.
; THIS TOLERANCE REPRESENTS THE TIME IN CLOCK TICKS REQUIRED TO
; EXECUTED A COUPLE OF DIRECTIVES.
;
;-
	$$STEP
	SETF$S	#37.,.RJCT	;FIRST SET EVENT FLAG #37.
	BCS	20$		;SKIP IF DIRECTIVE FAILED
	CALL	GETIME		;GET INITIAL TIME
	DIR$	#WT37,.RJCT	;WAIT FOR EFN #37. (ALREADY SET)
	BCS	20$		;SKIP IF DIRECTIVE FAILED
	DIR$	#GTIM2,.ABORT	;GET CURRENT TIME (OR ABORT)
	CALL	.SUCC		;CHECK FOR SUCCESS RETURN STATUS
	MOV	#100.,TOLER	;SET DUMMY TOLERANCE OF 100. TICKS
	MOV	#TIMB1+G.TIHR,R2  ;POINT R2 TO EXPECTED TIME
	MOV	#TIMB2+G.TIHR,R1  ;POINT R1 TO RECEIVED (CURRENT) TIME
	CALL	CHKTOL		;CHECK TO SEE IF THEY'RE WITHIN TOLERANCE
	BCC	10$		;SKIP IF NO ERROR--DIFFERENCE IN 'TIMDIF'
	CALL	TIMERR		;ERROR--RECEIVED TIME .LT. EXPECTED TIME
	JMP	.ABORT		;ABORT TEST
10$:	MOV	TIMDIF+6,TOLER	;USE DIFFERENCE AS TOLERANCE
	INC	TOLER		;ACCOUNT FOR TICK BOUNDARY
20$:
;+
;
; IN THIS STEP, THE "MARK TIME" DIRECTIVE IS CALLED TO SET EVENT
; FLAG #1 AT A SPECIFIED FUTURE TIME.  THE EXPECTED TIME OF THAT
; SIGNIFICANT EVENT IS CALCULATED IN THIS STEP AND SAVED FOR LATER
; TESTING.
;
;-
	$$STEP
	CALL	GETIME		;GET CURRENT TIME
	MRKT$S	#1,#5.,#SECOND,,.RJCT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
 
;
; READ THE EVENT FLAG FOR LATER TESTING
;
 
	CLEF$S	#1,.RJCT	;GET POLARITY OF EFN #1
	MOV	@#$DSW,-(SP)	;SAVE POLARITY ON STACK
 
;
; CALCULATE TIME OF THE "MARK TIME" DIRECTIVE'S SIGNIFICANT EVENT
;
 
	MOV	#5.,R0		;PUT MARK TIME MAGNITUDE IN R0
	MOV	#SECOND,R1	;PUT MARK TIME UNIT IN R1
	MOV	#TIMB1+G.TIHR,R2 ;PUT ADDR OF TIME LIST IN R2
	CALL	ADDTIM		;AND ADD THE TIME IN R0,R1
 
;
; WAIT FOR THE SIGNIFICANT EVENT TO OCCUR
;
 
	WTSE$S	#1,.RJCT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
 
;+
;
; AT THIS POINT THE TASK HAS BEEN AWAKENED BY THE SIGNIFICANT EVENT.
; TO OBTAIN THE CURRENT TIME THE "GET TIME PARAMETERS" DIRECTIVE
; WILL BE ISSUED.  THE CURRENT TIME WILL BE COMPARED TO THE TIME
; PREVIOUSLY CALCULATED TO BE THAT OF THE SIGNIFICANT EVENT.  IF
; THEY DON'T MATCH, AN ERROR OCCURRED AND IT WILL BE REPORTED.
;
;-
	$$STEP
	DIR$	#GTIM2,.ABORT	;GET CURRENT (RECEIVED) TIME
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	MOV	#TIMB2+G.TIHR,R1 ;PUT ADDR OF CURRENT TIME LIST IN R1
	CALL	CMPTIM		;COMPARE THE TWO TIME LISTS
	BCC	2$		;BRANCH IF THEY MATCH UP
	CALL	CHKTOL		;CHECK ERROR FOR TIME TOLERANCE
	BCC	2$		;SKIP IF O.K.
	CALL	TIMERR		;ELSE, REPORT THE DISCREPANCY
 
;
; EXAMINE THE POLARITY OF FLAG READ EARLIER
;
 
2$:	CMP	#IS.CLR,(SP)+	;CLEAN STACK & EXAMINE FLAG
	BEQ	10$		;SKIP IF FLAG WAS CLEAR
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM03,R1	;PUT ADDR OF FORMAT IN R1
	MOV	SP,R2		;PUT ANY EVEN ADDR IN R2
	CALL	.PRTMG		;CREATE REST OF MESSAGE & PRINT IT
10$:
;+
;
; THE NEXT SET OF TIMING TESTS INVOLVE THE SCHEDULING OF ANOTHER TASK.
; THIS WILL REQUIRE THAT A NEW TIMING TOLERANCE FACTOR BE DETERMNED.
; THIS IS DONE BY CLEARING AN EVENT FLAG, GETTING THE TIME, REQUESTING
; THE EXECUTION OF THE OTHER TASK, WAITING FOR THE TASK TO SET THE EVENT
; FLAG, GETTING THE NEW TIME, AND CALCULATING THE DIFFERENCE AS DONE
; EARLIER.
;
;-
 
	.ENABL	LSB
 
	$$STEP
	DIR$	#CL37,.RJCT	;CLEAR EVENT FLAG #37.
	BCS	10$		;SKIP IF DIRECTIVE FAILED
	CALL	GETIME		;GET CURRENT (EXPECTED) TIME
	RQST$C	TST03B,,,,,TST03A,.RJCT  ;REQUEST 'TST03B'
	BCS	10$		;SKIP IF DIRECTIVE FAILED
	DIR$	#WT37,.RJCT	;WAIT FOR 'TST03B' TO EXECUTE
	DIR$	#GTIM2,.ABORT	;GET CURRENT (RECEIVED) TIME
	MOV	#100.,TOLER	;ALLOW 100. TICKS TOLERANCE
	MOV	#TIMB1+G.TIHR,R2  ;POINT R2 TO EXPECTED TIME
	MOV	#TIMB2+G.TIHR,R1  ;POINT R1 TO RECEIVED TIME
	CALL	CHKTOL		;CALC TIME DIFFERENCE
	BCC	5$		;SKIP IF NO ERROR
	CALL	TIMERR		;ERROR--RECEIVED TIME .LT. EXPECTED TIME
	JMP	.ABORT		;ABORT TEST
5$:	MOV	TIMDIF+6,TOLER	;USE DIFFERENCE AS TOLERANCE
	INC	TOLER		;ACCOUNT FOR TICK BOUNDARY
10$:
 
	.DSABL	LSB
 
;+
;
; THE "RUN" DIRECTIVE WILL BE ISSUED TO ACTIVATE TASK 'TST03B'.
; THE EXPECTED TIME OF TASK ACTIVATION WILL BE CALCULATED FOR
; LATER TESTING.  TO INSURE THAT THIS TASK DOES NOT PERMANENTLY
; HANG UP, A "MARK TIME" DIRECTIVE WILL ALSO BE ISSUED.  THAT
; WILL AWAKEN THIS TASK IF THE "RUN" REQUEST FAILS.
;
;-
	$$STEP
;*****
	JMP	STP11
;*****
	DIR$	#CL37,.RJCT	;CLEAR FLAG # 37
	CALL	GETIME		;GET CURRENT TIME
	DIR$	#RUN03B,.ABORT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	MRKT$S	#36.,#5.,#SECOND,,.ABORT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
 
;
; CALCULATE THE TIME OF 'TST03B' ACTIVATION
;
 
	MOV	#4.,R0		;PUT THE TIME INTERVAL MAGNITUDE IN R0
	MOV	#SECOND,R1	;PUT THE TIME INTERVAL UNIT IN R1
	MOV	#TIMB1+G.TIHR,R2 ;PUT ADDR OF CURRENT TIME LIST IN R2
	CALL	ADDTIM		;ADD THEM UP
;+
;
; THE TASK WILL NOW WAIT FOR A SIGNIFICANT EVENT TO OCCUR WITH THE
; SETTING OF AN EVENT FLAG BY 'TST03B' OR "MARK TIME".  ONCE THE TASK
; IS AWAKENED, IT WILL GET THE TIME AND DETERMINE WHICH FLAG WAS SET.
; IF THE FLAG WAS SET BY "MARK TIME", AN ERROR OCCURRED ('TST03B' DID
; NOT BECOME ACTIVE) AND A MESSAGE IS SENT TO TI: .  IF THE FLAG WAS
; SET BY 'TST03B', GET THE TIME AND COMPARE IT TO THE EXPECTED
; TIME.  IF THEY DON'T MATCH, SEND AN ERROR MESSAGE TO TI:.  ONCE THE
; TEST IS COMPLETED, WAIT FOR THE "MARK TIME" FLAG TO BE SET BEFORE
; CONTINUING.
;
;-
	$$STEP
	DIR$	#W3637,.RJCT	;WAIT FOR FLAG #36 OR #37
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
 
;
; TASK IS AWAKE -- PROCEED
;
 
	DIR$	#GTIM2,.ABORT	;GET CURRENT (RECEIVED) TIME
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	CLEF$S	#37.,.RJCT	;GET POLARITY OF EFN #37.
	BCS	2$		;BRANCH IF THE DIRECTIVE FAILED
	CMP	#IS.CLR,@#$DSW	;CHECK FLAG POLARITY
	BEQ	1$		;IF CLEAR, EVENT WAS "MARK TIME"
 
;
; EVENT WAS CAUSED BY 'TST03B' -- CHECK THE TIME
;
 
	MOV	#TIMB2+G.TIHR,R1  ;PUT ADDR OF CURRENT TIME IN R1
	CALL	CMPTIM		;COMPARE IT WITH EXPECTED TIME
	BCC	2$		;BRANCH IF THEY MATCH UP
	CALL	CHKTOL		;CHECK ERROR FOR TIME TOLERANCE
	BCC	2$		;SKIP IF O.K.
	CALL	TIMERR		;ELSE, REPORT THE ERROR
 
;
; THE "MARK TIME" EVENT IS STILL PENDING.  ISSUE A WAIT UNTIL
; IT OCCURS.
;
 
	WTSE$S	#36.,.ABORT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	BR	2$		;NOW, BRANCH TO THE NEXT TEST STEP
 
;
; THE EARLIER TEST INDICATED THAT THE EVENT WAS NOT CAUSED BY 'TST03B'.
; REPORT THIS ERROR.
;
 
1$:	CALL	ATVERR		;NOTIFY THE USER OF ACTIVATION ERROR
 
2$:
;+
;
; THIS TASK WILL NOW TEST THE RE-SCHEDULE OPTION FOR THE "RUN" DIRECTIVE.
; TASK 'TST03B' WILL BE SCHEDULED TO RUN EVERY 3 SECONDS FOR 10
; ITERATIONS.  ERRORS DISCOVERED DURING THAT TIME WILL BE REPORTED AT
; THE END.
;
;-
	$$STEP
	CALL	GETIME		;GET CURRENT TIME
	RUN$C	TST03B,,,,,3,SECOND,3,SECOND,TST03A,.ABORT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	MOV	#TIMB1+G.TIHR,R2 ;PUT ADDR OF CURRENT TIME LIST IN R2
	CLR	R4		;R4 WILL COUNT NUMBER OF ERRORS
	MOV	#10.,R3		;WANT TO ITERATE 10 TIMES
1$:	DIR$	#CL37,.ABORT	;FLAG 37 MUST BE CLEARED
	MOV	#3.,R0		;PUT DELTA INTERVAL OF 3
	MOV	#SECOND,R1	;... SECONDS IN R0 & R1
	CALL	ADDTIM		;CALCULATE TIME OF EVENT
	DIR$	#WT37,.ABORT	;WAIT FOR 'TST03B' TO SET FLAG 37
	DIR$	#GTIM2,.ABORT	;GET CURRENT TIME
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	MOV	#TIMB2+G.TIHR,R1 ;PUT ADDR OF TIME LIST IN R1
	CALL	CMPTIM		;COMPARE CURRENT WITH EXPECTED TIME
	BCC	2$		;SKIP IF THEY MATCH
	CALL	CHKTOL		;CHECK ERROR FOR TIME TOLERANCE
	BCC	2$		;SKIP IF O.K.
	INC	R4		;ELSE, ADD ONE TO ERROR COUNT
2$:	SOB	R3,1$		;DO THIS 10 TIMES
	TST	R4		;DONE -- ANY ERRORS?
	BEQ	3$		;BRANCH IF NONE
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM04,R1	;PUT ADDR OF ERROR FORMAT IN R1
	MOV	R4,-(SP)	;PUT ERROR COUNT IN STACK
	MOV	SP,R2		;PUT ARGUMENT ADDR IN R2
	CALL	.PRTMG		;COMPLETE SETUP & PRINT MESSAGE
	TST	(SP)+		;CLEAN STACK
3$:
;+
;
; THE NEXT STEP TESTS THAT A "MARK TIME" REQUEST IS FLUSHED FROM
; THE SYSTEM WHEN THE TASK THAT ISSUED IT BECOMES INACTIVE.  THIS
; IS TESTED BY FIRST CLEARING EVENT FLAG #38., REQUESTING TASK
; 'TST03C', GENERATING ANOTHER MARK TIME, AND WAITING FOR THE
; SIGNIFICANT EVENT TO OCCUR.  THE EVENT FLAG SET WILL TELL
; WHICH EVENT OCCURRED.
;
;-
	$$STEP
	CLEF$S	#38.,.RJCT	;CLEAR FLAG  #38
	RQST$C	TST03C,,,,,TST03A,.RJCT ;REQUEST 'TST03C'
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	MRKT$S	#36.,#2,#SECOND,,.RJCT ;SET UP FOR A FUTURE EVENT
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	DIR$	#W3638,.RJCT	;WAIT FOR FLAGS #36 OR #38
	CALL	.SUCC		;CHECK FOR SUCCESSFUL RETURN STATUS
	CLEF$S	#38.,.RJCT	;GET POLARITY OF EFN #38.
	BCS	1$		;SKIP IF DIRECTIVE FAILED
	CMP	#IS.CLR,@#$DSW	;EXAMINE FLAG 38.
	BEQ	1$		;SKIP IF IT'S CLEAR
	CALL	.IDOUT		;ELSE, SETUP STEP IDENTIFICATION
	MOV	#LEM05,R1	;PUT FORMAT ADDR IN R1
	CALL	.PRTMG		;CREATE REST OF MESSAGE AND PRINT
1$:
;+
;
; THE REMAINING SERIES OF STEPS ATTEMPT TO FOUL UP THE SYSTEM.  ALL
; OF THE DIRECTIVE CALLS CONTAIN ERRORS TO TEST THE SYSTEMS ABILITY
; TO DETECT AND PROCESS ERRORS.  IF ANY OF THE ERRORS ARE HANDLED
; INCORRECTLY, A MESSAGE WILL BE SENT TO TI: .
;
; FIRST, THE "GET TIME PARAMETERS" DIRECTIVE WILL BE TESTED BY CALLING
; WITH A BUFFER ADDRESS OUT OF THIS SEGMENT.
;
;-
	$$STEP
	CALL	$ADCHK		;IS ADDRESS CHECKING SUPPORTED?
	BCS	SKPACK		;SKIP IF NOT
	GTIM$S	#160000
	MOV	#IE.ADP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE RETURN STATUS
;+
;
; THE "GET TIME PARAMETERS" DIRECTIVE IS INVOKED SPECIFYING THE ADDRESS
; OF THE EIGHT-WORD BUFFER ON AN ODD ADDRESS.
;
;-
	$$STEP
	GTIM$S	#TIMB1+1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE RETURN STATUS
 
SKPACK:				;BRANCH HERE IF NO ADDRESS CHECKING
 
;+
;
; THE "GET TIME PARAMETERS" IS CALLED WITH AN INVALID DPB SIZE.
;
;-
	$$STEP
 
 
	.PSECT	$DPB$$
	.ENABL	LSB
 
10$:	.BYTE	61.,4		;"GET TIME PARAMETERS" DIC & INV SIZE
 
 
	.PSECT	TST03A
 
	DIR$	#10$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE RETURN STATUS
 
	.DSABL	LSB
 
;+
;
; THE "MARK TIME" DIRECTIVE WILL BE TESTED BY CALLING WITH A ZERO TIME
; INTERVAL.
;
;-
	$$STEP
	MOV	#MKTDPB,R3	;PUT ADDR OF "MARK TIME" DPB IN R3
	MOV	R3,R4		;PUT ADDR OF TIME INTERVAL
	ADD	#M.KTMG,R4	;MAGNITUDE IN R4
	MOV	R4,R5		;PUT ADDR OF TIME INTERVAL
	TST	(R5)+		;UNIT IN R5
	CLR	(R4)		;SPECIFY A ZERO TIME
	CLR	(R5)		;INTERVAL
	CLR	M.KTEF(R3)	;CLEAR EVENT FLAG NUMBER
	DIR$	R3		;INVOKE "MARK TIME"
	MOV	#IE.ITI,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE RETURN STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS CALLED WITH A TIME INTERVAL UNIT GREATER
; THAN FOUR.
;
;-
	$$STEP
	INC	(R4)		;CHANGE TIME MAGNITUDE TO ONE
	MOV	#5,(R5)		;CHANGE TIME UNIT TO 5 (ILLEGAL)
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE RETURN STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS INVOKED WITH A NEGATIVE TIME INTERVAL
; MAGNITUDE OF CLOCK TICKS.
;
;-
	$$STEP
	MOV	#-1,(R4)	;CHANGE TIME MAGNITUE TO MINUS ONE
	MOV	#TICK,(R5)	;CHANGE TIME UNIT TO TICK
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE RETURN STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS CALLED SPECIFYING A NEGATIVE TIME
; INTERVAL MAGNITUDE OF SECONDS.
;
;-
	$$STEP
	INC	(R5)		;CHANGE TIME UNIT TO SECOND
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS ISSUED WITH A NEGATIVE TIME INTERVAL
; MAGNITUDE OF MINUTES.
;
;-
	$$STEP
	INC	(R5)		;CHANGE TIME UNIT TO MINUTE
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE WILL BE CALLED WITH A NEGATIVE TIME INTERVAL
; MAGNITUDE OF HOURS.
;
;-
	$$STEP
	INC	(R5)		;CHANGE TIME UNIT TO HOUR
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS INVOKED WITH A TIME INTERVAL
; MAGNITUDE OF HOURS GREATER THAN ONE DAY.
;
;-
	$$STEP
	MOV	#25.,(R4)	;CHANGE TIME INTERVAL TO 25 HOURS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS ISSUED WITH A TIME INTERVAL
; MAGNITUDE OF MINUTES GREATER THAN ONE DAY.
;
;-
	$$STEP
	MOV	#1441.,(R4)	;CHANGE TIME INTERVAL TO
	DEC	(R5)		;1441 MINUTES
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS ISSUED WITH A NEGATIVE EVENT FLAG
; SPECIFIED.
;
;-
	$$STEP
	MOV	#TICK,(R5)	;CHANGE TIME UNIT TO TICK
	MOV	#-1,M.KTEF(R3)	;SPECIFY A NEGATIVE EVENT FLAG
	DIR$	R3
	MOV	#IE.IEF,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS CALLED WITH AN EVENT FLAG NUMBER THAT
; IS TOO LARGE.
;
;-
	$$STEP
	MOV	#65.,M.KTEF(R3)	;MAKE EVENT FLAG NUMBER TOO LARGE
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "MARK TIME" DIRECTIVE IS SPECIFIED WITH AN INVALID DPB SIZE.
;
;-
	$$STEP
 
 
	.PSECT	$DPB$$
	.ENABL	LSB
 
10$:	.BYTE	23.,1.		;"MARK TIME" DIC & INVALID DPB SIZE
 
 
	.PSECT	TST03A
 
	DIR$	#10$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
 
	.DSABL	LSB
 
;+
;
; THE "RUN" DIRECTIVE WILL BE ISSUED TO ATTEMPT TO ACTIVATE A TASK
; WITH A NULL NAME.
;
;-
	$$STEP
	MOV	#RUNDPB,R3	;PUT ADDR OF RUN DPB IN R3
	MOV	#RUNDPB+R.UNTN,R4  ;PUT ADDR OF TASK NAME IN R4
	CLR	(R4)+		;AND CLEAR BOTH WORDS
	CLR	(R4)		;
	MOV	#1,R.UNSM(R3)	;SPECIFY TIME INTERVAL OF
	MOV	#TICK,R.UNSU(R3) ;ONE TICK
	DIR$	R3		;INVOKE RUN
	MOV	#IE.INS,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED WITH A NON-EXISTENT TASK NAME.

;

;-
	$$STEP
	MOV	TST03Z,(R4)	;MAKE TASK NAME NON-EXISTENT

	DIR$	R3		;INVOKE RUN
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	MOV	TST03C+2,(R4)	;RESTORE DPB TO CONTAIN 'TST03C' AS ...
	MOV	TST03C,-(R4)	;... THE TASK NAME
;+
;
; THE "RUN" DIRECTIVE IS ISSUED WITH A TIME INTERVAL UNIT SPECIFICATION
; OF ZERO.
;
;-
	$$STEP
	MOV	#RUNDPB+R.UNSM,R4  ;PUT INTERVAL MAG ADDR IN R4
	MOV	#RUNDPB+R.UNSU,R5  ;PUT ADDR OF INTERVAL UNIT IN R5
	MOV	#1,(R4)		;MAKE TIME MAGNITUDE ONE
	CLR	(R5)		;MAKE TIME UNIT ZERO
	DIR$	R3
	MOV	#IE.ITI,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED WITH A TIME INTERVAL UNIT GREATER
; THAN FOUR.
;
;-
	$$STEP
	MOV	#5,(R5)		;CHANGE TIME UNIT TO 5
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS ISSUED SPECIFYING A NEGATIVE TIME MAGNITUDE
; OF TICKS.
;
;-
	$$STEP
	MOV	#-1,(R4)	;CHANGE TIME MAGNITUDE TO MINUS ONE
	MOV	#TICK,(R5)	;CHANGE TIME UNIT TO TICKS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS INVOKED WITH A NEGATIVE TIME INTERVAL OF
; SECONDS.
;
;-
	$$STEP
	INC	(R5)		;CHANGE TIME UNIT TO SECONDS
	DIR$	R3		;INVOKE "RUN" DIRECTIVE
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED SPECIFYING A NEGATIVE TIME INTERVAL
; OF MINUTES.
;
;-
	$$STEP
	INC	(R5)		;CHANGE TIME UNIT TO MINUTES
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS ISSUED WITH A NEGATIVE TIME INTERVAL OF
; HOURS.
;
;-
	$$STEP
	INC	(R5)		;CHANGE TIME UNIT TO HOURS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS INVOKED SPECIFYING A TIME INTERVAL OF HOURS
; GREATER THAN ONE DAY.
;
;-
	$$STEP
	MOV	#25.,(R4)	;CHANGE TIME INTERVAL TO 25 HOURS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED WITH A TIME INTERVAL OF MINUTES
; GREATER THAN ONE DAY.
;
;-
	$$STEP
	MOV	#1441.,(R4)	;CHANGE TIME INTERVAL TO
	DEC	(R5)		;1441 MINUTES
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS ISSUED SPECIFYING A RE-SCHEDULE TIME MAGNITUDE
; OF ONE WITH A RE-SCHEDULE TIME UNIT OF ZERO.
;
;-
	$$STEP
	MOV	#1,(R4)		;SET SCHEDULE MAGNITUDE TO ONE
	MOV	#TICK,(R5)	;SET SCHEDULE UNIT TO TICK
	ADD	#<R.UNRM-R.UNSM>,R4 ;PUT RE-SCHED MAGNITUDE ADDR IN R4
	ADD	#<R.UNRU-R.UNSU>,R5 ;PUT RE-SCHED UNIT ADDR IN R5
	MOV	#1,(R4)		;SET RE-SCHED MAGNITUDE TO ONE
	CLR	(R5)		;SET RE-SCHED UNIT TO ZERO
	DIR$	R3		;INVOKE THE "RUN" DIRECTIVE
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED WITH A RE-SCHEDULE TIME UNIT
; SPECIFICATION GREATER THAN FOUR.
;
;-
	$$STEP
	MOV	#5,(R5)		;CCHANGE RE-SHED UNIT TO 5
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS INVOKED WITH A RE-SCHEDULE TIME INTERVAL
; OF NEGATIVE TICKS.
;
;-
	$$STEP
	MOV	#-1,(R4)	;CHANGE RE-SCHED TIME TO
	MOV	#TICK,(R5)	;MINUS ONE TICKS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS ISSUED WITH A RE-SCHEDULE TIME INTERVAL
; OF NEGATIVE SECONDS.
;
;-
	$$STEP
	INC	(R5)		;CHANGE RE-SCHEDULE UNIT TO SECONDS
	DIR$	R3		;INVOKE "RUN"
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED SPECIFYING A RE-SCHEDULE TIME
; INTERVAL OF NEGATIVE MINUTES.
;
;-
	$$STEP
	INC	(R5)		;CHANGE RE-SCHEDULE UNIT TO MINUTES
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS INVOKED WITH A RE-SCHEDULE TIME INTERVAL
; OF NEGATIVE HOURS.
;
;-
	$$STEP
	INC	(R5)		;CHANGE RE-SCHEDULE UNIT TO HOURS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS ISSUED WITH A RE-SCHEDULE TIME INTERVAL
; OF HOURS GREATER THAN ONE DAY.
;
;-
	$$STEP
	MOV	#25.,(R4)	;CHANGE RE-SCHED INTERVAL TO 25 HOURS
	DIR$	R3
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
;+
;
; THE "RUN" DIRECTIVE IS CALLED WITH A RE-SCHEDULE TIME INTERVAL
; OF MINUTES GREATER THAN ONE DAY.
;
;-
	$$STEP
	MOV	#1441.,(R4)	;CHANGE RE-SCHEDULE TIME INTERVAL
	DEC	(R5)		;1441 MINUTES
	DIR$	R3		;INVOKE THE "RUN" DIRECTIVE
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS

;+
;
; THE "RUN" DIRECTIVE IS INVOKED WITH A DPB CONTAINING AN
; INVALID DPB SIZE.
;
;-
	$$STEP
 
 
	.PSECT	$DPB$$
	.ENABL	LSB
 
10$:	.BYTE	17.,0		;"RUN" DIC & INVALID DPB SIZE
20$:	.BYTE	17.,1		;"RUN" DIC & INVALID DPB SIZE
 
 
	.PSECT	TST03A
 
	DIR$	#10$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
	DIR$	#20$		;INVOKE INVALID DPB
	MOV	#IE.SDP,R1	;PUT EXPECTED ERROR STATUS IN R1
	CALL	.FAIL		;CHECK FOR PROPER FAILURE STATUS
 
	.DSABL	LSB
 
;+
;
; THE TASK IS FINISHED -- SEND MESSAGE AND EXIT FROM THE SYSTEM.
;
;-
	$$STEP
	CALL	.ETST		;SEND END OF TEST MESSAGE
	EXIT$S	.RJCT
	.PAGE
;
;
;		'GETIME'
;
; THIS SHORT SUBROUTINE IS USED TO INSURE THE ACCURACY OF TESTS BASED
; UPON TIME COMPARISONS.  ASSUMING A LIGHT SYSTEM LOAD (I.E. ONLY THIS
; TEST RUNNING), THIS ROUTINE INSURES THAT THE TIME LOGGED AT THE START OF
; A TEST STEP IS AS CLOSE TO THE BEGINNING OF A CLOCK TICK AS POSSIBLE.
; HENCE, THE CLOCK WILL NOT BE ABLE TO ADVANCE ANOTHER TICK BETWEEN A
; CLOCK READING AND A DIRECTIVE SETTING UP A CLOCK QUEUE ENTRY IN ONE STEP.
;
;
GETIME:	MRKT$S	#1,#1,#TICK	;WAIT UNTIL NEXT CLOCK TICK
	WTSE$S	#1
	GTIM$S	#TIMB1,.ABORT	;GET TIME (OR ABORT TASK)
	RETURN			;RETURN TO THE TEST
 
 
;
;
;		'CMPTIM'
;
; THIS SUBROUTINE COMPARES TWO FOUR WORD TIME LISTS.  ONE LIST IS
; POINTED TO BY R1, AND THE OTHER LIST IS POINTED TO BY R2.  IF
; THE LISTS ELEMENTS MATCH, ON RETURN THE C-BIT IS CLEARED.  OTHER-
; WISE, THE C-BIT IS SET.
;
;
CMPTIM:	MOV	R1,-(SP)	;SAVE R1
	MOV	R2,-(SP)	;SAVE R2
	ADD	#8.,R1		;INCREMENT BOTH R1 & R2 TO POINT TO THE
	ADD	#8.,R2		;END OF THE LISTS
	MOV	#4.,-(SP)	;PUSH A COUNTER ON THE STACK
1$:	CMP	-(R1),-(R2)	;COMPARE LIST ELEMENTS
	BNE	2$		;SKIP IF THEY DON'T MATCH
	DEC	(SP)		;DECREMENT THE COUNTER
	BNE	1$		;AND REPEAT UNTIL IT'S ZERO
2$:	TST	(SP)+		;TEST COUNTER, POP STK & CLR C-BIT
	BEQ	3$		;SKIP IF CLEAR (IE. LISTS MATCH)
	MOV	(SP)+,R2	;RESTORE R2
	MOV	(SP)+,R1	;RESTORE R1
	SEC			;SET C-BIT
	BR	4$		;AND BRANCH
3$:	ADD	#4,SP		;POP R2 & R1 FROM STACK
4$:	RETURN			;THEN RETURN
	.PAGE
;
;		'CHKTOL'
;
; THIS SUBROUTINE IS CALLED WHEN IT IS DISCOVERED THAT A TIMING
; DISCREPANCY OCCURRED.  BEFORE AN ERROR MESSAGE IS SENT, A CHECK
; IS MADE OF THE TWO TIME VALUES.  IF THE RECEIVED TIME IS LESS
; THAN THE EXPECTED TIME, AND ERROR IS DECLARED.  HOWEVER, IF THE
; RECEIVED TIME IS GREATER THAN THE EXPECTED TIME BY LESS THAN A
; PRE-DETERMINED TOLERANCE, AN ERROR IS NOT DECLARED.  THE ERROR IS
; RETURNED BY SETTING THE C-BIT.
;
;
CHKTOL:	MOV	R3,-(SP)	;SAVE R3 AND R4
	MOV	R4,-(SP)	;
	MOV	#TIMDIF,R3	;POINT R3 TO TIME DIFFERENCE BUFFER
	MOV	(R1)+,(R3)+	;COPY RECEIVED TIME INTO DIFFERENCE BUFFER
	MOV	(R1)+,(R3)+	;
	MOV	(R1)+,(R3)+	;
	MOV	(R1)+,(R3)+	;
	SUB	#8.,R1		;RESTORE ADDRESS IN R1
	ADD	#8.,R2		;POINT R2 PAST BUFFER OF EXPECTED TIME
	MOV	TCKSEC,R4	;PUT CLOCKTICKS/SECOND IN R4
	CALL	100$		;SUBTRACT TICKS
	MOV	#60.,R4		;PUT SECONDS/MINUTE (MINUTES/HOUR) IN R4
	CALL	100$		;SUBTRACT SECONDS
	CALL	100$		;SUBTRACT MINUTES
	SUB	-(R2),-(R3)	;SUBTRACT HOURS
	TST	(R3)+		;WAS HOURS DIFFERENCE ZERO?
	BNE	10$		;SKIP IF NOT
	TST	(R3)+		;WAS MINUTES DIFFERENCE ZERO?
	BNE	10$		;SKIP IF NOT
	TST	(R3)+		;WAS SECONDS DIFFERENCE ZERO?
	BNE	10$		;SKIP IF NOT
	CMP	TOLER,(R3)+	;COMPARE TICKS DIFFERENCE W/ TOLERANCE
	BGE	20$		;SKIP IF WITHIN TOLERANCE
10$:	SEC			;SET C-BIT TO INDICATE ERROR
20$:	MOV	(SP)+,R4	;RESTORE R4 AND R3
	MOV	(SP)+,R3	;
	RETURN
 
100$:	SUB	-(R2),-(R3)	;SUBTRACT TIME
	BGE	200$		;SKIP IF RESULT IS POSITIVE
	ADD	R4,(R3)		;ELSE, BORROW FROM NEXT HIGHER TIME UNIT
	DEC	-2(R3)		;
200$:	RETURN
	.PAGE
;
;
;		'ADDTIM'
;
; THIS SUBROUTINE ADDS A TIME MAGNITUDE IN R0 REPRESENTING AN NUMBER OF
; TIME UNITS IN R1 (MUST BE 4, 3, 2, OR 1) TO THE FOUR WORD TIME LIST
; (REPRESENTED AS HOURS, MINUTES, SECONDS, AND TICKS) POINTED TO BY R2.
; ON RETURN, R0 & R1 HAVE BEEN ALTERED, AND THE TIME LIST HAS THE NEW
; TIME IN IT.
;
;
ADDTIM:	ADD	#10.,R2		;POINT R2 PAST THE END OF THE LIST
	ASL	R1		;MAKE TIME UNIT A WORD OFFSET
	SUB	R1,R2		;ADJUST LIST POINTER TO PROPER ENTRY
	ADD	#1$-2,R1	;CALCULATE BRANCH ADDRESS
	JMP	@(R1)		;AND JUMP TO IT
1$:	.WORD	2$		;UNIT = TICK = 1
	.WORD	3$		;UNIT = SECOND = 2
	.WORD	4$		;UNIT = MINUTE = 3
	.WORD	5$		;UNIT = HOUR = 4
2$:	MOV	TCKSEC,R1	;PUT TICKS/SECOND IN R1
	CALL	6$		;ADD IN THE TICKS
3$:	MOV	#60.,R1		;PUT SECONDS/MINUTE IN R1
	CALL	6$		;ADD IN THE SECONDS
4$:	MOV	#60.,R1		;PUT MINUTES/HOUR IN R1
	CALL	6$		;ADD IN THE MINUTES
5$:	MOV	#24.,R1		;PUT HOURS/DAY IN R1
				;ADD IN THE HOURS AND RETURN
 
6$:	ADD	-(R2),R0	;ADD TIME FROM LIST TO THAT IN R0
	CALL	$DIV		;DIVIDE R1 (UNIT MOD) INTO R0 (UNIT SUM)
	MOV	R1,(R2)		;PUT REMAINDER IN LIST
	RETURN			;LEAVE CARRY IN R0
	.PAGE
;
;
;		'TIMMSG'
;
; AN ERROR MESSAGE MUST BE PRINTED OUT, GIVING THE VALUE OF TWO TIME
; LISTS.  THE FIRST PART OF THE MESSAGE, HOWEVER, MUST BE THE STEP
; IDENTIFICATION, AND THE REMAINING PARTS MUST BE THE TWO TIME LISTS.
; IN ORDER TO PRINT THE MESSAGE PROPERLY, THE LIST ADDRESSES AND THE
; FORMAT ADDRESSES MUST ALREADY BE PUSHED ON THE STACK IN THE
; CORRECT ORDER.  RETURN IS MADE DIRECTLY BACK TO THE TEST PROGRAM.
;
;
TIMMSG:	CALL	.IDOUT		;CREATE OUTPUT OF STEP IDENTIFICATION
	MOV	(SP)+,R1	;POP FORMAT ADDR INTO R1
	MOV	(SP),R2		;PUT ARG LIST ADDR IN R2
	CALL	$EDMSG		;CREATE OUTPUT LINE
	MOV	2(SP),R1	;PUT FORMAT ADDR IN R1
	MOV	4(SP),R2	;PUT ARG LIST ADDR IN R2
	CALL	.PRTMG		;CREATE LINE AND OUTPUT MESSAGE
	MOV	(SP)+,R2	;RESTORE EXPECTED TIME LIST ADDR
	TST	(SP)+		;POP STACK
	MOV	(SP)+,R1	;RESTORE RETURNED TIME LIST ADDR
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R3	;RESTORE R3
	RETURN			;RETURN DIRECTLY TO TEST PROGRAM
	.PAGE
;
;
;		'TIMERR'
;
; A COMPARE OF TWO TIME LISTS HAS FAILED.  THE ADDRESS OF THE EXPECTED
; TIME LIST IS IN R2, AND THE ADDRESS OF THE RETURNED TIME LIST IS IN
; R1.  THIS ROUTINE SETS UP THE PROPER ADDRESSES IN THE STACK AND
; JUMPS TO 'TIMMSG' TO OUTPUT THE MESSAGE.
;
;
TIMERR:	MOV	R3,-(SP)	;SAVE R3
	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;PUSH ADDR OF RETURNED TIME LIST ON STK
	MOV	#LEM00,-(SP)	;PUSH FORMAT ADDR ON STACK
	MOV	R2,-(SP)	;PUSH ADDR OF EXPECTED TIME LIST ON STK
	MOV	#LEM01,-(SP)	;PUSH ANOTHER FORMAT ADDR ON STACK
	JMP	TIMMSG		;JUMP TO MESSAGE PRINTING ROUTINE
;
;
;		'ATVERR'
;
; A TASK DID NOT ACTIVATE IN TIME.  THE ADDRESS OF THE EXPECTED TIME
; LIST IS IN R2, AND THE ADDRESS OF THE CURRENT TIME LIST IS IN
; R1.  THIS ROUTINE ALSO SETS UP ADDRESSES IN THE STACK AND JUMPS
; TO 'TIMMSG' TO OUTPUT THE MESSAGE.
;
;
ATVERR:	MOV	R3,-(SP)	;SAVE R3
	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;PUSH ADDR OF RETURNED TIME LIST ON STK
	MOV	#LEM00,-(SP)	;PUSH FORMAT ADDR ON STACK
	MOV	R2,-(SP)	;PUSH ADDR OF EXPECTED TIME LIST ON STK
	MOV	#LEM02,-(SP)	;PUSH ANOTHER FORMAT ADDR ON STACK
	JMP	TIMMSG		;JUMP TO MESSAGE PRINTING ROUTINE


; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	.END	STP0
